static bool should_merge(struct fsnotify_event *old_fsn,\r\nstruct fsnotify_event *new_fsn)\r\n{\r\nstruct fanotify_event_info *old, *new;\r\npr_debug("%s: old=%p new=%p\n", __func__, old_fsn, new_fsn);\r\nold = FANOTIFY_E(old_fsn);\r\nnew = FANOTIFY_E(new_fsn);\r\nif (old_fsn->inode == new_fsn->inode && old->tgid == new->tgid &&\r\nold->path.mnt == new->path.mnt &&\r\nold->path.dentry == new->path.dentry)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int fanotify_merge(struct list_head *list, struct fsnotify_event *event)\r\n{\r\nstruct fsnotify_event *test_event;\r\nbool do_merge = false;\r\npr_debug("%s: list=%p event=%p\n", __func__, list, event);\r\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\r\nif (event->mask & FAN_ALL_PERM_EVENTS)\r\nreturn 0;\r\n#endif\r\nlist_for_each_entry_reverse(test_event, list, list) {\r\nif (should_merge(test_event, event)) {\r\ndo_merge = true;\r\nbreak;\r\n}\r\n}\r\nif (!do_merge)\r\nreturn 0;\r\ntest_event->mask |= event->mask;\r\nreturn 1;\r\n}\r\nstatic int fanotify_get_response(struct fsnotify_group *group,\r\nstruct fanotify_perm_event_info *event)\r\n{\r\nint ret;\r\npr_debug("%s: group=%p event=%p\n", __func__, group, event);\r\nwait_event(group->fanotify_data.access_waitq, event->response ||\r\natomic_read(&group->fanotify_data.bypass_perm));\r\nif (!event->response)\r\nreturn 0;\r\nswitch (event->response) {\r\ncase FAN_ALLOW:\r\nret = 0;\r\nbreak;\r\ncase FAN_DENY:\r\ndefault:\r\nret = -EPERM;\r\n}\r\nevent->response = 0;\r\npr_debug("%s: group=%p event=%p about to return ret=%d\n", __func__,\r\ngroup, event, ret);\r\nreturn ret;\r\n}\r\nstatic bool fanotify_should_send_event(struct fsnotify_mark *inode_mark,\r\nstruct fsnotify_mark *vfsmnt_mark,\r\nu32 event_mask,\r\nvoid *data, int data_type)\r\n{\r\n__u32 marks_mask, marks_ignored_mask;\r\nstruct path *path = data;\r\npr_debug("%s: inode_mark=%p vfsmnt_mark=%p mask=%x data=%p"\r\n" data_type=%d\n", __func__, inode_mark, vfsmnt_mark,\r\nevent_mask, data, data_type);\r\nif (data_type != FSNOTIFY_EVENT_PATH)\r\nreturn false;\r\nif (!S_ISREG(path->dentry->d_inode->i_mode) &&\r\n!S_ISDIR(path->dentry->d_inode->i_mode))\r\nreturn false;\r\nif (inode_mark && vfsmnt_mark) {\r\nmarks_mask = (vfsmnt_mark->mask | inode_mark->mask);\r\nmarks_ignored_mask = (vfsmnt_mark->ignored_mask | inode_mark->ignored_mask);\r\n} else if (inode_mark) {\r\nif ((event_mask & FS_EVENT_ON_CHILD) &&\r\n!(inode_mark->mask & FS_EVENT_ON_CHILD))\r\nreturn false;\r\nmarks_mask = inode_mark->mask;\r\nmarks_ignored_mask = inode_mark->ignored_mask;\r\n} else if (vfsmnt_mark) {\r\nmarks_mask = vfsmnt_mark->mask;\r\nmarks_ignored_mask = vfsmnt_mark->ignored_mask;\r\n} else {\r\nBUG();\r\n}\r\nif (S_ISDIR(path->dentry->d_inode->i_mode) &&\r\n(marks_ignored_mask & FS_ISDIR))\r\nreturn false;\r\nif (event_mask & marks_mask & ~marks_ignored_mask)\r\nreturn true;\r\nreturn false;\r\n}\r\nstruct fanotify_event_info *fanotify_alloc_event(struct inode *inode, u32 mask,\r\nstruct path *path)\r\n{\r\nstruct fanotify_event_info *event;\r\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\r\nif (mask & FAN_ALL_PERM_EVENTS) {\r\nstruct fanotify_perm_event_info *pevent;\r\npevent = kmem_cache_alloc(fanotify_perm_event_cachep,\r\nGFP_KERNEL);\r\nif (!pevent)\r\nreturn NULL;\r\nevent = &pevent->fae;\r\npevent->response = 0;\r\ngoto init;\r\n}\r\n#endif\r\nevent = kmem_cache_alloc(fanotify_event_cachep, GFP_KERNEL);\r\nif (!event)\r\nreturn NULL;\r\ninit: __maybe_unused\r\nfsnotify_init_event(&event->fse, inode, mask);\r\nevent->tgid = get_pid(task_tgid(current));\r\nif (path) {\r\nevent->path = *path;\r\npath_get(&event->path);\r\n} else {\r\nevent->path.mnt = NULL;\r\nevent->path.dentry = NULL;\r\n}\r\nreturn event;\r\n}\r\nstatic int fanotify_handle_event(struct fsnotify_group *group,\r\nstruct inode *inode,\r\nstruct fsnotify_mark *inode_mark,\r\nstruct fsnotify_mark *fanotify_mark,\r\nu32 mask, void *data, int data_type,\r\nconst unsigned char *file_name, u32 cookie)\r\n{\r\nint ret = 0;\r\nstruct fanotify_event_info *event;\r\nstruct fsnotify_event *fsn_event;\r\nBUILD_BUG_ON(FAN_ACCESS != FS_ACCESS);\r\nBUILD_BUG_ON(FAN_MODIFY != FS_MODIFY);\r\nBUILD_BUG_ON(FAN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE);\r\nBUILD_BUG_ON(FAN_CLOSE_WRITE != FS_CLOSE_WRITE);\r\nBUILD_BUG_ON(FAN_OPEN != FS_OPEN);\r\nBUILD_BUG_ON(FAN_EVENT_ON_CHILD != FS_EVENT_ON_CHILD);\r\nBUILD_BUG_ON(FAN_Q_OVERFLOW != FS_Q_OVERFLOW);\r\nBUILD_BUG_ON(FAN_OPEN_PERM != FS_OPEN_PERM);\r\nBUILD_BUG_ON(FAN_ACCESS_PERM != FS_ACCESS_PERM);\r\nBUILD_BUG_ON(FAN_ONDIR != FS_ISDIR);\r\nif (!fanotify_should_send_event(inode_mark, fanotify_mark, mask, data,\r\ndata_type))\r\nreturn 0;\r\npr_debug("%s: group=%p inode=%p mask=%x\n", __func__, group, inode,\r\nmask);\r\nevent = fanotify_alloc_event(inode, mask, data);\r\nif (unlikely(!event))\r\nreturn -ENOMEM;\r\nfsn_event = &event->fse;\r\nret = fsnotify_add_notify_event(group, fsn_event, fanotify_merge);\r\nif (ret) {\r\nBUG_ON(ret == 1 && mask & FAN_ALL_PERM_EVENTS);\r\nfsnotify_destroy_event(group, fsn_event);\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\r\nif (mask & FAN_ALL_PERM_EVENTS) {\r\nret = fanotify_get_response(group, FANOTIFY_PE(fsn_event));\r\nfsnotify_destroy_event(group, fsn_event);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void fanotify_free_group_priv(struct fsnotify_group *group)\r\n{\r\nstruct user_struct *user;\r\nuser = group->fanotify_data.user;\r\natomic_dec(&user->fanotify_listeners);\r\nfree_uid(user);\r\n}\r\nstatic void fanotify_free_event(struct fsnotify_event *fsn_event)\r\n{\r\nstruct fanotify_event_info *event;\r\nevent = FANOTIFY_E(fsn_event);\r\npath_put(&event->path);\r\nput_pid(event->tgid);\r\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\r\nif (fsn_event->mask & FAN_ALL_PERM_EVENTS) {\r\nkmem_cache_free(fanotify_perm_event_cachep,\r\nFANOTIFY_PE(fsn_event));\r\nreturn;\r\n}\r\n#endif\r\nkmem_cache_free(fanotify_event_cachep, event);\r\n}
