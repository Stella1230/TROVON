static void vmw_hw_context_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDestroyContext body;\r\n} *cmd;\r\nif (res->func->destroy == vmw_gb_context_destroy) {\r\nmutex_lock(&dev_priv->cmdbuf_mutex);\r\nmutex_lock(&dev_priv->binding_mutex);\r\n(void) vmw_context_binding_state_kill\r\n(&container_of(res, struct vmw_user_context, res)->cbs);\r\n(void) vmw_gb_context_destroy(res);\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nif (dev_priv->pinned_bo != NULL &&\r\n!dev_priv->query_cid_valid)\r\n__vmw_execbuf_release_pinned_bo(dev_priv, NULL);\r\nmutex_unlock(&dev_priv->cmdbuf_mutex);\r\nreturn;\r\n}\r\nvmw_execbuf_release_pinned_bo(dev_priv);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for surface "\r\n"destruction.\n");\r\nreturn;\r\n}\r\ncmd->header.id = cpu_to_le32(SVGA_3D_CMD_CONTEXT_DESTROY);\r\ncmd->header.size = cpu_to_le32(sizeof(cmd->body));\r\ncmd->body.cid = cpu_to_le32(res->id);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nvmw_3d_resource_dec(dev_priv, false);\r\n}\r\nstatic int vmw_gb_context_init(struct vmw_private *dev_priv,\r\nstruct vmw_resource *res,\r\nvoid (*res_free) (struct vmw_resource *res))\r\n{\r\nint ret;\r\nstruct vmw_user_context *uctx =\r\ncontainer_of(res, struct vmw_user_context, res);\r\nret = vmw_resource_init(dev_priv, res, true,\r\nres_free, &vmw_gb_context_func);\r\nres->backup_size = SVGA3D_CONTEXT_DATA_SIZE;\r\nif (unlikely(ret != 0)) {\r\nif (res_free)\r\nres_free(res);\r\nelse\r\nkfree(res);\r\nreturn ret;\r\n}\r\nmemset(&uctx->cbs, 0, sizeof(uctx->cbs));\r\nINIT_LIST_HEAD(&uctx->cbs.list);\r\nvmw_resource_activate(res, vmw_hw_context_destroy);\r\nreturn 0;\r\n}\r\nstatic int vmw_context_init(struct vmw_private *dev_priv,\r\nstruct vmw_resource *res,\r\nvoid (*res_free) (struct vmw_resource *res))\r\n{\r\nint ret;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDefineContext body;\r\n} *cmd;\r\nif (dev_priv->has_mob)\r\nreturn vmw_gb_context_init(dev_priv, res, res_free);\r\nret = vmw_resource_init(dev_priv, res, false,\r\nres_free, &vmw_legacy_context_func);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to allocate a resource id.\n");\r\ngoto out_early;\r\n}\r\nif (unlikely(res->id >= SVGA3D_MAX_CONTEXT_IDS)) {\r\nDRM_ERROR("Out of hw context ids.\n");\r\nvmw_resource_unreference(&res);\r\nreturn -ENOMEM;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nvmw_resource_unreference(&res);\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = cpu_to_le32(SVGA_3D_CMD_CONTEXT_DEFINE);\r\ncmd->header.size = cpu_to_le32(sizeof(cmd->body));\r\ncmd->body.cid = cpu_to_le32(res->id);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\n(void) vmw_3d_resource_inc(dev_priv, false);\r\nvmw_resource_activate(res, vmw_hw_context_destroy);\r\nreturn 0;\r\nout_early:\r\nif (res_free == NULL)\r\nkfree(res);\r\nelse\r\nres_free(res);\r\nreturn ret;\r\n}\r\nstruct vmw_resource *vmw_context_alloc(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_resource *res = kmalloc(sizeof(*res), GFP_KERNEL);\r\nint ret;\r\nif (unlikely(res == NULL))\r\nreturn NULL;\r\nret = vmw_context_init(dev_priv, res, NULL);\r\nreturn (ret == 0) ? res : NULL;\r\n}\r\nstatic int vmw_gb_context_create(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nint ret;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDefineGBContext body;\r\n} *cmd;\r\nif (likely(res->id != -1))\r\nreturn 0;\r\nret = vmw_resource_alloc_id(res);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to allocate a context id.\n");\r\ngoto out_no_id;\r\n}\r\nif (unlikely(res->id >= VMWGFX_NUM_GB_CONTEXT)) {\r\nret = -EBUSY;\r\ngoto out_no_fifo;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for context "\r\n"creation.\n");\r\nret = -ENOMEM;\r\ngoto out_no_fifo;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DEFINE_GB_CONTEXT;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = res->id;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\n(void) vmw_3d_resource_inc(dev_priv, false);\r\nreturn 0;\r\nout_no_fifo:\r\nvmw_resource_release_id(res);\r\nout_no_id:\r\nreturn ret;\r\n}\r\nstatic int vmw_gb_context_bind(struct vmw_resource *res,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdBindGBContext body;\r\n} *cmd;\r\nstruct ttm_buffer_object *bo = val_buf->bo;\r\nBUG_ON(bo->mem.mem_type != VMW_PL_MOB);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for context "\r\n"binding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_BIND_GB_CONTEXT;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = res->id;\r\ncmd->body.mobid = bo->mem.start;\r\ncmd->body.validContents = res->backup_dirty;\r\nres->backup_dirty = false;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic int vmw_gb_context_unbind(struct vmw_resource *res,\r\nbool readback,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct ttm_buffer_object *bo = val_buf->bo;\r\nstruct vmw_fence_obj *fence;\r\nstruct vmw_user_context *uctx =\r\ncontainer_of(res, struct vmw_user_context, res);\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdReadbackGBContext body;\r\n} *cmd1;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdBindGBContext body;\r\n} *cmd2;\r\nuint32_t submit_size;\r\nuint8_t *cmd;\r\nBUG_ON(bo->mem.mem_type != VMW_PL_MOB);\r\nmutex_lock(&dev_priv->binding_mutex);\r\nvmw_context_binding_state_scrub(&uctx->cbs);\r\nsubmit_size = sizeof(*cmd2) + (readback ? sizeof(*cmd1) : 0);\r\ncmd = vmw_fifo_reserve(dev_priv, submit_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for context "\r\n"unbinding.\n");\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nreturn -ENOMEM;\r\n}\r\ncmd2 = (void *) cmd;\r\nif (readback) {\r\ncmd1 = (void *) cmd;\r\ncmd1->header.id = SVGA_3D_CMD_READBACK_GB_CONTEXT;\r\ncmd1->header.size = sizeof(cmd1->body);\r\ncmd1->body.cid = res->id;\r\ncmd2 = (void *) (&cmd1[1]);\r\n}\r\ncmd2->header.id = SVGA_3D_CMD_BIND_GB_CONTEXT;\r\ncmd2->header.size = sizeof(cmd2->body);\r\ncmd2->body.cid = res->id;\r\ncmd2->body.mobid = SVGA3D_INVALID_ID;\r\nvmw_fifo_commit(dev_priv, submit_size);\r\nmutex_unlock(&dev_priv->binding_mutex);\r\n(void) vmw_execbuf_fence_commands(NULL, dev_priv,\r\n&fence, NULL);\r\nvmw_fence_single_bo(bo, fence);\r\nif (likely(fence != NULL))\r\nvmw_fence_obj_unreference(&fence);\r\nreturn 0;\r\n}\r\nstatic int vmw_gb_context_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDestroyGBContext body;\r\n} *cmd;\r\nif (likely(res->id == -1))\r\nreturn 0;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for context "\r\n"destruction.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DESTROY_GB_CONTEXT;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = res->id;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nif (dev_priv->query_cid == res->id)\r\ndev_priv->query_cid_valid = false;\r\nvmw_resource_release_id(res);\r\nvmw_3d_resource_dec(dev_priv, false);\r\nreturn 0;\r\n}\r\nstatic struct vmw_resource *\r\nvmw_user_context_base_to_res(struct ttm_base_object *base)\r\n{\r\nreturn &(container_of(base, struct vmw_user_context, base)->res);\r\n}\r\nstatic void vmw_user_context_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_user_context *ctx =\r\ncontainer_of(res, struct vmw_user_context, res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nttm_base_object_kfree(ctx, base);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_context_size);\r\n}\r\nstatic void vmw_user_context_base_release(struct ttm_base_object **p_base)\r\n{\r\nstruct ttm_base_object *base = *p_base;\r\nstruct vmw_user_context *ctx =\r\ncontainer_of(base, struct vmw_user_context, base);\r\nstruct vmw_resource *res = &ctx->res;\r\n*p_base = NULL;\r\nvmw_resource_unreference(&res);\r\n}\r\nint vmw_context_destroy_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_context_arg *arg = (struct drm_vmw_context_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nreturn ttm_ref_object_base_unref(tfile, arg->cid, TTM_REF_USAGE);\r\n}\r\nint vmw_context_define_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_user_context *ctx;\r\nstruct vmw_resource *res;\r\nstruct vmw_resource *tmp;\r\nstruct drm_vmw_context_arg *arg = (struct drm_vmw_context_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nint ret;\r\nif (unlikely(vmw_user_context_size == 0))\r\nvmw_user_context_size = ttm_round_pot(sizeof(*ctx)) + 128;\r\nret = ttm_read_lock(&dev_priv->reservation_sem, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv),\r\nvmw_user_context_size,\r\nfalse, true);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for context"\r\n" creation.\n");\r\ngoto out_unlock;\r\n}\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (unlikely(ctx == NULL)) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_context_size);\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nres = &ctx->res;\r\nctx->base.shareable = false;\r\nctx->base.tfile = NULL;\r\nret = vmw_context_init(dev_priv, res, vmw_user_context_free);\r\nif (unlikely(ret != 0))\r\ngoto out_unlock;\r\ntmp = vmw_resource_reference(&ctx->res);\r\nret = ttm_base_object_init(tfile, &ctx->base, false, VMW_RES_CONTEXT,\r\n&vmw_user_context_base_release, NULL);\r\nif (unlikely(ret != 0)) {\r\nvmw_resource_unreference(&tmp);\r\ngoto out_err;\r\n}\r\narg->cid = ctx->base.hash.key;\r\nout_err:\r\nvmw_resource_unreference(&res);\r\nout_unlock:\r\nttm_read_unlock(&dev_priv->reservation_sem);\r\nreturn ret;\r\n}\r\nstatic int vmw_context_scrub_shader(struct vmw_ctx_bindinfo *bi, bool rebind)\r\n{\r\nstruct vmw_private *dev_priv = bi->ctx->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdSetShader body;\r\n} *cmd;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"unbinding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_SET_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = bi->ctx->id;\r\ncmd->body.type = bi->i1.shader_type;\r\ncmd->body.shid = ((rebind) ? bi->res->id : SVGA3D_INVALID_ID);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic int vmw_context_scrub_render_target(struct vmw_ctx_bindinfo *bi,\r\nbool rebind)\r\n{\r\nstruct vmw_private *dev_priv = bi->ctx->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdSetRenderTarget body;\r\n} *cmd;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for render target "\r\n"unbinding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_SETRENDERTARGET;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = bi->ctx->id;\r\ncmd->body.type = bi->i1.rt_type;\r\ncmd->body.target.sid = ((rebind) ? bi->res->id : SVGA3D_INVALID_ID);\r\ncmd->body.target.face = 0;\r\ncmd->body.target.mipmap = 0;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic int vmw_context_scrub_texture(struct vmw_ctx_bindinfo *bi,\r\nbool rebind)\r\n{\r\nstruct vmw_private *dev_priv = bi->ctx->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nstruct {\r\nSVGA3dCmdSetTextureState c;\r\nSVGA3dTextureState s1;\r\n} body;\r\n} *cmd;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for texture "\r\n"unbinding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_SETTEXTURESTATE;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.c.cid = bi->ctx->id;\r\ncmd->body.s1.stage = bi->i1.texture_stage;\r\ncmd->body.s1.name = SVGA3D_TS_BIND_TEXTURE;\r\ncmd->body.s1.value = ((rebind) ? bi->res->id : SVGA3D_INVALID_ID);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic void vmw_context_binding_drop(struct vmw_ctx_binding *cb)\r\n{\r\nlist_del(&cb->ctx_list);\r\nif (!list_empty(&cb->res_list))\r\nlist_del(&cb->res_list);\r\ncb->bi.ctx = NULL;\r\n}\r\nint vmw_context_binding_add(struct vmw_ctx_binding_state *cbs,\r\nconst struct vmw_ctx_bindinfo *bi)\r\n{\r\nstruct vmw_ctx_binding *loc;\r\nswitch (bi->bt) {\r\ncase vmw_ctx_binding_rt:\r\nif (unlikely((unsigned)bi->i1.rt_type >= SVGA3D_RT_MAX)) {\r\nDRM_ERROR("Illegal render target type %u.\n",\r\n(unsigned) bi->i1.rt_type);\r\nreturn -EINVAL;\r\n}\r\nloc = &cbs->render_targets[bi->i1.rt_type];\r\nbreak;\r\ncase vmw_ctx_binding_tex:\r\nif (unlikely((unsigned)bi->i1.texture_stage >=\r\nSVGA3D_NUM_TEXTURE_UNITS)) {\r\nDRM_ERROR("Illegal texture/sampler unit %u.\n",\r\n(unsigned) bi->i1.texture_stage);\r\nreturn -EINVAL;\r\n}\r\nloc = &cbs->texture_units[bi->i1.texture_stage];\r\nbreak;\r\ncase vmw_ctx_binding_shader:\r\nif (unlikely((unsigned)bi->i1.shader_type >=\r\nSVGA3D_SHADERTYPE_MAX)) {\r\nDRM_ERROR("Illegal shader type %u.\n",\r\n(unsigned) bi->i1.shader_type);\r\nreturn -EINVAL;\r\n}\r\nloc = &cbs->shaders[bi->i1.shader_type];\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (loc->bi.ctx != NULL)\r\nvmw_context_binding_drop(loc);\r\nloc->bi = *bi;\r\nloc->bi.scrubbed = false;\r\nlist_add_tail(&loc->ctx_list, &cbs->list);\r\nINIT_LIST_HEAD(&loc->res_list);\r\nreturn 0;\r\n}\r\nstatic void vmw_context_binding_transfer(struct vmw_ctx_binding_state *cbs,\r\nconst struct vmw_ctx_bindinfo *bi)\r\n{\r\nstruct vmw_ctx_binding *loc;\r\nswitch (bi->bt) {\r\ncase vmw_ctx_binding_rt:\r\nloc = &cbs->render_targets[bi->i1.rt_type];\r\nbreak;\r\ncase vmw_ctx_binding_tex:\r\nloc = &cbs->texture_units[bi->i1.texture_stage];\r\nbreak;\r\ncase vmw_ctx_binding_shader:\r\nloc = &cbs->shaders[bi->i1.shader_type];\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (loc->bi.ctx != NULL)\r\nvmw_context_binding_drop(loc);\r\nif (bi->res != NULL) {\r\nloc->bi = *bi;\r\nlist_add_tail(&loc->ctx_list, &cbs->list);\r\nlist_add_tail(&loc->res_list, &bi->res->binding_head);\r\n}\r\n}\r\nstatic void vmw_context_binding_kill(struct vmw_ctx_binding *cb)\r\n{\r\nif (!cb->bi.scrubbed) {\r\n(void) vmw_scrub_funcs[cb->bi.bt](&cb->bi, false);\r\ncb->bi.scrubbed = true;\r\n}\r\nvmw_context_binding_drop(cb);\r\n}\r\nstatic void vmw_context_binding_state_kill(struct vmw_ctx_binding_state *cbs)\r\n{\r\nstruct vmw_ctx_binding *entry, *next;\r\nlist_for_each_entry_safe(entry, next, &cbs->list, ctx_list)\r\nvmw_context_binding_kill(entry);\r\n}\r\nstatic void vmw_context_binding_state_scrub(struct vmw_ctx_binding_state *cbs)\r\n{\r\nstruct vmw_ctx_binding *entry;\r\nlist_for_each_entry(entry, &cbs->list, ctx_list) {\r\nif (!entry->bi.scrubbed) {\r\n(void) vmw_scrub_funcs[entry->bi.bt](&entry->bi, false);\r\nentry->bi.scrubbed = true;\r\n}\r\n}\r\n}\r\nvoid vmw_context_binding_res_list_kill(struct list_head *head)\r\n{\r\nstruct vmw_ctx_binding *entry, *next;\r\nlist_for_each_entry_safe(entry, next, head, res_list)\r\nvmw_context_binding_kill(entry);\r\n}\r\nvoid vmw_context_binding_res_list_scrub(struct list_head *head)\r\n{\r\nstruct vmw_ctx_binding *entry;\r\nlist_for_each_entry(entry, head, res_list) {\r\nif (!entry->bi.scrubbed) {\r\n(void) vmw_scrub_funcs[entry->bi.bt](&entry->bi, false);\r\nentry->bi.scrubbed = true;\r\n}\r\n}\r\n}\r\nvoid vmw_context_binding_state_transfer(struct vmw_resource *ctx,\r\nstruct vmw_ctx_binding_state *from)\r\n{\r\nstruct vmw_user_context *uctx =\r\ncontainer_of(ctx, struct vmw_user_context, res);\r\nstruct vmw_ctx_binding *entry, *next;\r\nlist_for_each_entry_safe(entry, next, &from->list, ctx_list)\r\nvmw_context_binding_transfer(&uctx->cbs, &entry->bi);\r\n}\r\nint vmw_context_rebind_all(struct vmw_resource *ctx)\r\n{\r\nstruct vmw_ctx_binding *entry;\r\nstruct vmw_user_context *uctx =\r\ncontainer_of(ctx, struct vmw_user_context, res);\r\nstruct vmw_ctx_binding_state *cbs = &uctx->cbs;\r\nint ret;\r\nlist_for_each_entry(entry, &cbs->list, ctx_list) {\r\nif (likely(!entry->bi.scrubbed))\r\ncontinue;\r\nif (WARN_ON(entry->bi.res == NULL || entry->bi.res->id ==\r\nSVGA3D_INVALID_ID))\r\ncontinue;\r\nret = vmw_scrub_funcs[entry->bi.bt](&entry->bi, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nentry->bi.scrubbed = false;\r\n}\r\nreturn 0;\r\n}\r\nstruct list_head *vmw_context_binding_list(struct vmw_resource *ctx)\r\n{\r\nreturn &(container_of(ctx, struct vmw_user_context, res)->cbs.list);\r\n}
