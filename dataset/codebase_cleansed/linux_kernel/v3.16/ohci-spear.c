static int spear_ohci_hcd_drv_probe(struct platform_device *pdev)\r\n{\r\nconst struct hc_driver *driver = &ohci_spear_hc_driver;\r\nstruct ohci_hcd *ohci;\r\nstruct usb_hcd *hcd = NULL;\r\nstruct clk *usbh_clk;\r\nstruct spear_ohci *sohci_p;\r\nstruct resource *res;\r\nint retval, irq;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nretval = irq;\r\ngoto fail;\r\n}\r\nretval = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nif (retval)\r\ngoto fail;\r\nusbh_clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(usbh_clk)) {\r\ndev_err(&pdev->dev, "Error getting interface clock\n");\r\nretval = PTR_ERR(usbh_clk);\r\ngoto fail;\r\n}\r\nhcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));\r\nif (!hcd) {\r\nretval = -ENOMEM;\r\ngoto fail;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nretval = -ENODEV;\r\ngoto err_put_hcd;\r\n}\r\nhcd->rsrc_start = pdev->resource[0].start;\r\nhcd->rsrc_len = resource_size(res);\r\nhcd->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hcd->regs)) {\r\nretval = PTR_ERR(hcd->regs);\r\ngoto err_put_hcd;\r\n}\r\nsohci_p = to_spear_ohci(hcd);\r\nsohci_p->clk = usbh_clk;\r\nclk_prepare_enable(sohci_p->clk);\r\nohci = hcd_to_ohci(hcd);\r\nretval = usb_add_hcd(hcd, platform_get_irq(pdev, 0), 0);\r\nif (retval == 0) {\r\ndevice_wakeup_enable(hcd->self.controller);\r\nreturn retval;\r\n}\r\nclk_disable_unprepare(sohci_p->clk);\r\nerr_put_hcd:\r\nusb_put_hcd(hcd);\r\nfail:\r\ndev_err(&pdev->dev, "init fail, %d\n", retval);\r\nreturn retval;\r\n}\r\nstatic int spear_ohci_hcd_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct spear_ohci *sohci_p = to_spear_ohci(hcd);\r\nusb_remove_hcd(hcd);\r\nif (sohci_p->clk)\r\nclk_disable_unprepare(sohci_p->clk);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic int spear_ohci_hcd_drv_suspend(struct platform_device *pdev,\r\npm_message_t message)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nstruct spear_ohci *sohci_p = to_spear_ohci(hcd);\r\nbool do_wakeup = device_may_wakeup(&pdev->dev);\r\nint ret;\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nret = ohci_suspend(hcd, do_wakeup);\r\nif (ret)\r\nreturn ret;\r\nclk_disable_unprepare(sohci_p->clk);\r\nreturn ret;\r\n}\r\nstatic int spear_ohci_hcd_drv_resume(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nstruct spear_ohci *sohci_p = to_spear_ohci(hcd);\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nclk_prepare_enable(sohci_p->clk);\r\nohci_resume(hcd, false);\r\nreturn 0;\r\n}\r\nstatic int __init ohci_spear_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", hcd_name);\r\nohci_init_driver(&ohci_spear_hc_driver, &spear_overrides);\r\nreturn platform_driver_register(&spear_ohci_hcd_driver);\r\n}\r\nstatic void __exit ohci_spear_cleanup(void)\r\n{\r\nplatform_driver_unregister(&spear_ohci_hcd_driver);\r\n}
