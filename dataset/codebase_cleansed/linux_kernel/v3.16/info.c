int snd_info_check_reserved_words(const char *str)\r\n{\r\nstatic char *reserved[] =\r\n{\r\n"version",\r\n"meminfo",\r\n"memdebug",\r\n"detect",\r\n"devices",\r\n"oss",\r\n"cards",\r\n"timers",\r\n"synth",\r\n"pcm",\r\n"seq",\r\nNULL\r\n};\r\nchar **xstr = reserved;\r\nwhile (*xstr) {\r\nif (!strcmp(*xstr, str))\r\nreturn 0;\r\nxstr++;\r\n}\r\nif (!strncmp(str, "card", 4))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int resize_info_buffer(struct snd_info_buffer *buffer,\r\nunsigned int nsize)\r\n{\r\nchar *nbuf;\r\nnsize = PAGE_ALIGN(nsize);\r\nnbuf = krealloc(buffer->buffer, nsize, GFP_KERNEL | __GFP_ZERO);\r\nif (! nbuf)\r\nreturn -ENOMEM;\r\nbuffer->buffer = nbuf;\r\nbuffer->len = nsize;\r\nreturn 0;\r\n}\r\nint snd_iprintf(struct snd_info_buffer *buffer, const char *fmt, ...)\r\n{\r\nva_list args;\r\nint len, res;\r\nint err = 0;\r\nmight_sleep();\r\nif (buffer->stop || buffer->error)\r\nreturn 0;\r\nlen = buffer->len - buffer->size;\r\nva_start(args, fmt);\r\nfor (;;) {\r\nva_list ap;\r\nva_copy(ap, args);\r\nres = vsnprintf(buffer->buffer + buffer->curr, len, fmt, ap);\r\nva_end(ap);\r\nif (res < len)\r\nbreak;\r\nerr = resize_info_buffer(buffer, buffer->len + PAGE_SIZE);\r\nif (err < 0)\r\nbreak;\r\nlen = buffer->len - buffer->size;\r\n}\r\nva_end(args);\r\nif (err < 0)\r\nreturn err;\r\nbuffer->curr += res;\r\nbuffer->size += res;\r\nreturn res;\r\n}\r\nstatic loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)\r\n{\r\nstruct snd_info_private_data *data;\r\nstruct snd_info_entry *entry;\r\nloff_t ret = -EINVAL, size;\r\ndata = file->private_data;\r\nentry = data->entry;\r\nmutex_lock(&entry->access);\r\nif (entry->content == SNDRV_INFO_CONTENT_DATA &&\r\nentry->c.ops->llseek) {\r\noffset = entry->c.ops->llseek(entry,\r\ndata->file_private_data,\r\nfile, offset, orig);\r\ngoto out;\r\n}\r\nif (entry->content == SNDRV_INFO_CONTENT_DATA)\r\nsize = entry->size;\r\nelse\r\nsize = 0;\r\nswitch (orig) {\r\ncase SEEK_SET:\r\nbreak;\r\ncase SEEK_CUR:\r\noffset += file->f_pos;\r\nbreak;\r\ncase SEEK_END:\r\nif (!size)\r\ngoto out;\r\noffset += size;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nif (offset < 0)\r\ngoto out;\r\nif (size && offset > size)\r\noffset = size;\r\nfile->f_pos = offset;\r\nret = offset;\r\nout:\r\nmutex_unlock(&entry->access);\r\nreturn ret;\r\n}\r\nstatic ssize_t snd_info_entry_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t * offset)\r\n{\r\nstruct snd_info_private_data *data;\r\nstruct snd_info_entry *entry;\r\nstruct snd_info_buffer *buf;\r\nsize_t size = 0;\r\nloff_t pos;\r\ndata = file->private_data;\r\nif (snd_BUG_ON(!data))\r\nreturn -ENXIO;\r\npos = *offset;\r\nif (pos < 0 || (long) pos != pos || (ssize_t) count < 0)\r\nreturn -EIO;\r\nif ((unsigned long) pos + (unsigned long) count < (unsigned long) pos)\r\nreturn -EIO;\r\nentry = data->entry;\r\nswitch (entry->content) {\r\ncase SNDRV_INFO_CONTENT_TEXT:\r\nbuf = data->rbuffer;\r\nif (buf == NULL)\r\nreturn -EIO;\r\nif (pos >= buf->size)\r\nreturn 0;\r\nsize = buf->size - pos;\r\nsize = min(count, size);\r\nif (copy_to_user(buffer, buf->buffer + pos, size))\r\nreturn -EFAULT;\r\nbreak;\r\ncase SNDRV_INFO_CONTENT_DATA:\r\nif (pos >= entry->size)\r\nreturn 0;\r\nif (entry->c.ops->read) {\r\nsize = entry->size - pos;\r\nsize = min(count, size);\r\nsize = entry->c.ops->read(entry,\r\ndata->file_private_data,\r\nfile, buffer, size, pos);\r\n}\r\nbreak;\r\n}\r\nif ((ssize_t) size > 0)\r\n*offset = pos + size;\r\nreturn size;\r\n}\r\nstatic ssize_t snd_info_entry_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t * offset)\r\n{\r\nstruct snd_info_private_data *data;\r\nstruct snd_info_entry *entry;\r\nstruct snd_info_buffer *buf;\r\nssize_t size = 0;\r\nloff_t pos;\r\ndata = file->private_data;\r\nif (snd_BUG_ON(!data))\r\nreturn -ENXIO;\r\nentry = data->entry;\r\npos = *offset;\r\nif (pos < 0 || (long) pos != pos || (ssize_t) count < 0)\r\nreturn -EIO;\r\nif ((unsigned long) pos + (unsigned long) count < (unsigned long) pos)\r\nreturn -EIO;\r\nswitch (entry->content) {\r\ncase SNDRV_INFO_CONTENT_TEXT:\r\nbuf = data->wbuffer;\r\nif (buf == NULL)\r\nreturn -EIO;\r\nmutex_lock(&entry->access);\r\nif (pos + count >= buf->len) {\r\nif (resize_info_buffer(buf, pos + count)) {\r\nmutex_unlock(&entry->access);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (copy_from_user(buf->buffer + pos, buffer, count)) {\r\nmutex_unlock(&entry->access);\r\nreturn -EFAULT;\r\n}\r\nbuf->size = pos + count;\r\nmutex_unlock(&entry->access);\r\nsize = count;\r\nbreak;\r\ncase SNDRV_INFO_CONTENT_DATA:\r\nif (entry->c.ops->write && count > 0) {\r\nsize_t maxsize = entry->size - pos;\r\ncount = min(count, maxsize);\r\nsize = entry->c.ops->write(entry,\r\ndata->file_private_data,\r\nfile, buffer, count, pos);\r\n}\r\nbreak;\r\n}\r\nif ((ssize_t) size > 0)\r\n*offset = pos + size;\r\nreturn size;\r\n}\r\nstatic int snd_info_entry_open(struct inode *inode, struct file *file)\r\n{\r\nstruct snd_info_entry *entry;\r\nstruct snd_info_private_data *data;\r\nstruct snd_info_buffer *buffer;\r\nint mode, err;\r\nmutex_lock(&info_mutex);\r\nentry = PDE_DATA(inode);\r\nif (entry == NULL || ! entry->p) {\r\nmutex_unlock(&info_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (!try_module_get(entry->module)) {\r\nerr = -EFAULT;\r\ngoto __error1;\r\n}\r\nmode = file->f_flags & O_ACCMODE;\r\nif (mode == O_RDONLY || mode == O_RDWR) {\r\nif ((entry->content == SNDRV_INFO_CONTENT_DATA &&\r\nentry->c.ops->read == NULL)) {\r\nerr = -ENODEV;\r\ngoto __error;\r\n}\r\n}\r\nif (mode == O_WRONLY || mode == O_RDWR) {\r\nif ((entry->content == SNDRV_INFO_CONTENT_DATA &&\r\nentry->c.ops->write == NULL)) {\r\nerr = -ENODEV;\r\ngoto __error;\r\n}\r\n}\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (data == NULL) {\r\nerr = -ENOMEM;\r\ngoto __error;\r\n}\r\ndata->entry = entry;\r\nswitch (entry->content) {\r\ncase SNDRV_INFO_CONTENT_TEXT:\r\nif (mode == O_RDONLY || mode == O_RDWR) {\r\nbuffer = kzalloc(sizeof(*buffer), GFP_KERNEL);\r\nif (buffer == NULL)\r\ngoto __nomem;\r\ndata->rbuffer = buffer;\r\nbuffer->len = PAGE_SIZE;\r\nbuffer->buffer = kzalloc(buffer->len, GFP_KERNEL);\r\nif (buffer->buffer == NULL)\r\ngoto __nomem;\r\n}\r\nif (mode == O_WRONLY || mode == O_RDWR) {\r\nbuffer = kzalloc(sizeof(*buffer), GFP_KERNEL);\r\nif (buffer == NULL)\r\ngoto __nomem;\r\ndata->wbuffer = buffer;\r\nbuffer->len = PAGE_SIZE;\r\nbuffer->buffer = kmalloc(buffer->len, GFP_KERNEL);\r\nif (buffer->buffer == NULL)\r\ngoto __nomem;\r\n}\r\nbreak;\r\ncase SNDRV_INFO_CONTENT_DATA:\r\nif (entry->c.ops->open) {\r\nif ((err = entry->c.ops->open(entry, mode,\r\n&data->file_private_data)) < 0) {\r\nkfree(data);\r\ngoto __error;\r\n}\r\n}\r\nbreak;\r\n}\r\nfile->private_data = data;\r\nmutex_unlock(&info_mutex);\r\nif (entry->content == SNDRV_INFO_CONTENT_TEXT &&\r\n(mode == O_RDONLY || mode == O_RDWR)) {\r\nif (entry->c.text.read) {\r\nmutex_lock(&entry->access);\r\nentry->c.text.read(entry, data->rbuffer);\r\nmutex_unlock(&entry->access);\r\n}\r\n}\r\nreturn 0;\r\n__nomem:\r\nif (data->rbuffer) {\r\nkfree(data->rbuffer->buffer);\r\nkfree(data->rbuffer);\r\n}\r\nif (data->wbuffer) {\r\nkfree(data->wbuffer->buffer);\r\nkfree(data->wbuffer);\r\n}\r\nkfree(data);\r\nerr = -ENOMEM;\r\n__error:\r\nmodule_put(entry->module);\r\n__error1:\r\nmutex_unlock(&info_mutex);\r\nreturn err;\r\n}\r\nstatic int snd_info_entry_release(struct inode *inode, struct file *file)\r\n{\r\nstruct snd_info_entry *entry;\r\nstruct snd_info_private_data *data;\r\nint mode;\r\nmode = file->f_flags & O_ACCMODE;\r\ndata = file->private_data;\r\nentry = data->entry;\r\nswitch (entry->content) {\r\ncase SNDRV_INFO_CONTENT_TEXT:\r\nif (data->rbuffer) {\r\nkfree(data->rbuffer->buffer);\r\nkfree(data->rbuffer);\r\n}\r\nif (data->wbuffer) {\r\nif (entry->c.text.write) {\r\nentry->c.text.write(entry, data->wbuffer);\r\nif (data->wbuffer->error) {\r\nif (entry->card)\r\ndev_warn(entry->card->dev, "info: data write error to %s (%i)\n",\r\nentry->name,\r\ndata->wbuffer->error);\r\nelse\r\npr_warn("ALSA: info: data write error to %s (%i)\n",\r\nentry->name,\r\ndata->wbuffer->error);\r\n}\r\n}\r\nkfree(data->wbuffer->buffer);\r\nkfree(data->wbuffer);\r\n}\r\nbreak;\r\ncase SNDRV_INFO_CONTENT_DATA:\r\nif (entry->c.ops->release)\r\nentry->c.ops->release(entry, mode,\r\ndata->file_private_data);\r\nbreak;\r\n}\r\nmodule_put(entry->module);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic unsigned int snd_info_entry_poll(struct file *file, poll_table * wait)\r\n{\r\nstruct snd_info_private_data *data;\r\nstruct snd_info_entry *entry;\r\nunsigned int mask;\r\ndata = file->private_data;\r\nif (data == NULL)\r\nreturn 0;\r\nentry = data->entry;\r\nmask = 0;\r\nswitch (entry->content) {\r\ncase SNDRV_INFO_CONTENT_DATA:\r\nif (entry->c.ops->poll)\r\nreturn entry->c.ops->poll(entry,\r\ndata->file_private_data,\r\nfile, wait);\r\nif (entry->c.ops->read)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (entry->c.ops->write)\r\nmask |= POLLOUT | POLLWRNORM;\r\nbreak;\r\n}\r\nreturn mask;\r\n}\r\nstatic long snd_info_entry_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct snd_info_private_data *data;\r\nstruct snd_info_entry *entry;\r\ndata = file->private_data;\r\nif (data == NULL)\r\nreturn 0;\r\nentry = data->entry;\r\nswitch (entry->content) {\r\ncase SNDRV_INFO_CONTENT_DATA:\r\nif (entry->c.ops->ioctl)\r\nreturn entry->c.ops->ioctl(entry,\r\ndata->file_private_data,\r\nfile, cmd, arg);\r\nbreak;\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic int snd_info_entry_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct snd_info_private_data *data;\r\nstruct snd_info_entry *entry;\r\ndata = file->private_data;\r\nif (data == NULL)\r\nreturn 0;\r\nentry = data->entry;\r\nswitch (entry->content) {\r\ncase SNDRV_INFO_CONTENT_DATA:\r\nif (entry->c.ops->mmap)\r\nreturn entry->c.ops->mmap(entry,\r\ndata->file_private_data,\r\ninode, file, vma);\r\nbreak;\r\n}\r\nreturn -ENXIO;\r\n}\r\nint __init snd_info_init(void)\r\n{\r\nstruct proc_dir_entry *p;\r\np = proc_mkdir("asound", NULL);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nsnd_proc_root = p;\r\n#ifdef CONFIG_SND_OSSEMUL\r\n{\r\nstruct snd_info_entry *entry;\r\nif ((entry = snd_info_create_module_entry(THIS_MODULE, "oss", NULL)) == NULL)\r\nreturn -ENOMEM;\r\nentry->mode = S_IFDIR | S_IRUGO | S_IXUGO;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nreturn -ENOMEM;\r\n}\r\nsnd_oss_root = entry;\r\n}\r\n#endif\r\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\r\n{\r\nstruct snd_info_entry *entry;\r\nif ((entry = snd_info_create_module_entry(THIS_MODULE, "seq", NULL)) == NULL)\r\nreturn -ENOMEM;\r\nentry->mode = S_IFDIR | S_IRUGO | S_IXUGO;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nreturn -ENOMEM;\r\n}\r\nsnd_seq_root = entry;\r\n}\r\n#endif\r\nsnd_info_version_init();\r\nsnd_minor_info_init();\r\nsnd_minor_info_oss_init();\r\nsnd_card_info_init();\r\nreturn 0;\r\n}\r\nint __exit snd_info_done(void)\r\n{\r\nsnd_card_info_done();\r\nsnd_minor_info_oss_done();\r\nsnd_minor_info_done();\r\nsnd_info_version_done();\r\nif (snd_proc_root) {\r\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\r\nsnd_info_free_entry(snd_seq_root);\r\n#endif\r\n#ifdef CONFIG_SND_OSSEMUL\r\nsnd_info_free_entry(snd_oss_root);\r\n#endif\r\nproc_remove(snd_proc_root);\r\n}\r\nreturn 0;\r\n}\r\nint snd_info_card_create(struct snd_card *card)\r\n{\r\nchar str[8];\r\nstruct snd_info_entry *entry;\r\nif (snd_BUG_ON(!card))\r\nreturn -ENXIO;\r\nsprintf(str, "card%i", card->number);\r\nif ((entry = snd_info_create_module_entry(card->module, str, NULL)) == NULL)\r\nreturn -ENOMEM;\r\nentry->mode = S_IFDIR | S_IRUGO | S_IXUGO;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nreturn -ENOMEM;\r\n}\r\ncard->proc_root = entry;\r\nreturn 0;\r\n}\r\nint snd_info_card_register(struct snd_card *card)\r\n{\r\nstruct proc_dir_entry *p;\r\nif (snd_BUG_ON(!card))\r\nreturn -ENXIO;\r\nif (!strcmp(card->id, card->proc_root->name))\r\nreturn 0;\r\np = proc_symlink(card->id, snd_proc_root, card->proc_root->name);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\ncard->proc_root_link = p;\r\nreturn 0;\r\n}\r\nvoid snd_info_card_id_change(struct snd_card *card)\r\n{\r\nmutex_lock(&info_mutex);\r\nif (card->proc_root_link) {\r\nproc_remove(card->proc_root_link);\r\ncard->proc_root_link = NULL;\r\n}\r\nif (strcmp(card->id, card->proc_root->name))\r\ncard->proc_root_link = proc_symlink(card->id,\r\nsnd_proc_root,\r\ncard->proc_root->name);\r\nmutex_unlock(&info_mutex);\r\n}\r\nvoid snd_info_card_disconnect(struct snd_card *card)\r\n{\r\nif (!card)\r\nreturn;\r\nmutex_lock(&info_mutex);\r\nproc_remove(card->proc_root_link);\r\ncard->proc_root_link = NULL;\r\nif (card->proc_root)\r\nsnd_info_disconnect(card->proc_root);\r\nmutex_unlock(&info_mutex);\r\n}\r\nint snd_info_card_free(struct snd_card *card)\r\n{\r\nif (!card)\r\nreturn 0;\r\nsnd_info_free_entry(card->proc_root);\r\ncard->proc_root = NULL;\r\nreturn 0;\r\n}\r\nint snd_info_get_line(struct snd_info_buffer *buffer, char *line, int len)\r\n{\r\nint c = -1;\r\nif (snd_BUG_ON(!buffer || !buffer->buffer))\r\nreturn 1;\r\nif (len <= 0 || buffer->stop || buffer->error)\r\nreturn 1;\r\nwhile (!buffer->stop) {\r\nc = buffer->buffer[buffer->curr++];\r\nif (buffer->curr >= buffer->size)\r\nbuffer->stop = 1;\r\nif (c == '\n')\r\nbreak;\r\nif (len) {\r\nlen--;\r\n*line++ = c;\r\n}\r\n}\r\n*line = '\0';\r\nreturn 0;\r\n}\r\nconst char *snd_info_get_str(char *dest, const char *src, int len)\r\n{\r\nint c;\r\nwhile (*src == ' ' || *src == '\t')\r\nsrc++;\r\nif (*src == '"' || *src == '\'') {\r\nc = *src++;\r\nwhile (--len > 0 && *src && *src != c) {\r\n*dest++ = *src++;\r\n}\r\nif (*src == c)\r\nsrc++;\r\n} else {\r\nwhile (--len > 0 && *src && *src != ' ' && *src != '\t') {\r\n*dest++ = *src++;\r\n}\r\n}\r\n*dest = 0;\r\nwhile (*src == ' ' || *src == '\t')\r\nsrc++;\r\nreturn src;\r\n}\r\nstatic struct snd_info_entry *snd_info_create_entry(const char *name)\r\n{\r\nstruct snd_info_entry *entry;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (entry == NULL)\r\nreturn NULL;\r\nentry->name = kstrdup(name, GFP_KERNEL);\r\nif (entry->name == NULL) {\r\nkfree(entry);\r\nreturn NULL;\r\n}\r\nentry->mode = S_IFREG | S_IRUGO;\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nmutex_init(&entry->access);\r\nINIT_LIST_HEAD(&entry->children);\r\nINIT_LIST_HEAD(&entry->list);\r\nreturn entry;\r\n}\r\nstruct snd_info_entry *snd_info_create_module_entry(struct module * module,\r\nconst char *name,\r\nstruct snd_info_entry *parent)\r\n{\r\nstruct snd_info_entry *entry = snd_info_create_entry(name);\r\nif (entry) {\r\nentry->module = module;\r\nentry->parent = parent;\r\n}\r\nreturn entry;\r\n}\r\nstruct snd_info_entry *snd_info_create_card_entry(struct snd_card *card,\r\nconst char *name,\r\nstruct snd_info_entry * parent)\r\n{\r\nstruct snd_info_entry *entry = snd_info_create_entry(name);\r\nif (entry) {\r\nentry->module = card->module;\r\nentry->card = card;\r\nentry->parent = parent;\r\n}\r\nreturn entry;\r\n}\r\nstatic void snd_info_disconnect(struct snd_info_entry *entry)\r\n{\r\nstruct list_head *p, *n;\r\nstruct proc_dir_entry *root;\r\nlist_for_each_safe(p, n, &entry->children) {\r\nsnd_info_disconnect(list_entry(p, struct snd_info_entry, list));\r\n}\r\nif (! entry->p)\r\nreturn;\r\nlist_del_init(&entry->list);\r\nroot = entry->parent == NULL ? snd_proc_root : entry->parent->p;\r\nsnd_BUG_ON(!root);\r\nproc_remove(entry->p);\r\nentry->p = NULL;\r\n}\r\nstatic int snd_info_dev_free_entry(struct snd_device *device)\r\n{\r\nstruct snd_info_entry *entry = device->device_data;\r\nsnd_info_free_entry(entry);\r\nreturn 0;\r\n}\r\nstatic int snd_info_dev_register_entry(struct snd_device *device)\r\n{\r\nstruct snd_info_entry *entry = device->device_data;\r\nreturn snd_info_register(entry);\r\n}\r\nint snd_card_proc_new(struct snd_card *card, const char *name,\r\nstruct snd_info_entry **entryp)\r\n{\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_info_dev_free_entry,\r\n.dev_register = snd_info_dev_register_entry,\r\n};\r\nstruct snd_info_entry *entry;\r\nint err;\r\nentry = snd_info_create_card_entry(card, name, card->proc_root);\r\nif (! entry)\r\nreturn -ENOMEM;\r\nif ((err = snd_device_new(card, SNDRV_DEV_INFO, entry, &ops)) < 0) {\r\nsnd_info_free_entry(entry);\r\nreturn err;\r\n}\r\nif (entryp)\r\n*entryp = entry;\r\nreturn 0;\r\n}\r\nvoid snd_info_free_entry(struct snd_info_entry * entry)\r\n{\r\nif (entry == NULL)\r\nreturn;\r\nif (entry->p) {\r\nmutex_lock(&info_mutex);\r\nsnd_info_disconnect(entry);\r\nmutex_unlock(&info_mutex);\r\n}\r\nkfree(entry->name);\r\nif (entry->private_free)\r\nentry->private_free(entry);\r\nkfree(entry);\r\n}\r\nint snd_info_register(struct snd_info_entry * entry)\r\n{\r\nstruct proc_dir_entry *root, *p = NULL;\r\nif (snd_BUG_ON(!entry))\r\nreturn -ENXIO;\r\nroot = entry->parent == NULL ? snd_proc_root : entry->parent->p;\r\nmutex_lock(&info_mutex);\r\nif (S_ISDIR(entry->mode)) {\r\np = proc_mkdir_mode(entry->name, entry->mode, root);\r\nif (!p) {\r\nmutex_unlock(&info_mutex);\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\np = proc_create_data(entry->name, entry->mode, root,\r\n&snd_info_entry_operations, entry);\r\nif (!p) {\r\nmutex_unlock(&info_mutex);\r\nreturn -ENOMEM;\r\n}\r\nproc_set_size(p, entry->size);\r\n}\r\nentry->p = p;\r\nif (entry->parent)\r\nlist_add_tail(&entry->list, &entry->parent->children);\r\nmutex_unlock(&info_mutex);\r\nreturn 0;\r\n}\r\nstatic void snd_info_version_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\r\n{\r\nsnd_iprintf(buffer,\r\n"Advanced Linux Sound Architecture Driver Version k%s.\n",\r\ninit_utsname()->release);\r\n}\r\nstatic int __init snd_info_version_init(void)\r\n{\r\nstruct snd_info_entry *entry;\r\nentry = snd_info_create_module_entry(THIS_MODULE, "version", NULL);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nentry->c.text.read = snd_info_version_read;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nreturn -ENOMEM;\r\n}\r\nsnd_info_version_entry = entry;\r\nreturn 0;\r\n}\r\nstatic int __exit snd_info_version_done(void)\r\n{\r\nsnd_info_free_entry(snd_info_version_entry);\r\nreturn 0;\r\n}
