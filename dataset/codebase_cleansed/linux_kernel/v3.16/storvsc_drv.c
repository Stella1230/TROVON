static void storvsc_device_scan(struct work_struct *work)\r\n{\r\nstruct storvsc_scan_work *wrk;\r\nuint lun;\r\nstruct scsi_device *sdev;\r\nwrk = container_of(work, struct storvsc_scan_work, work);\r\nlun = wrk->lun;\r\nsdev = scsi_device_lookup(wrk->host, 0, 0, lun);\r\nif (!sdev)\r\ngoto done;\r\nscsi_rescan_device(&sdev->sdev_gendev);\r\nscsi_device_put(sdev);\r\ndone:\r\nkfree(wrk);\r\n}\r\nstatic void storvsc_bus_scan(struct work_struct *work)\r\n{\r\nstruct storvsc_scan_work *wrk;\r\nint id, order_id;\r\nwrk = container_of(work, struct storvsc_scan_work, work);\r\nfor (id = 0; id < wrk->host->max_id; ++id) {\r\nif (wrk->host->reverse_ordering)\r\norder_id = wrk->host->max_id - id - 1;\r\nelse\r\norder_id = id;\r\nscsi_scan_target(&wrk->host->shost_gendev, 0,\r\norder_id, SCAN_WILD_CARD, 1);\r\n}\r\nkfree(wrk);\r\n}\r\nstatic void storvsc_remove_lun(struct work_struct *work)\r\n{\r\nstruct storvsc_scan_work *wrk;\r\nstruct scsi_device *sdev;\r\nwrk = container_of(work, struct storvsc_scan_work, work);\r\nif (!scsi_host_get(wrk->host))\r\ngoto done;\r\nsdev = scsi_device_lookup(wrk->host, 0, 0, wrk->lun);\r\nif (sdev) {\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\n}\r\nscsi_host_put(wrk->host);\r\ndone:\r\nkfree(wrk);\r\n}\r\nstatic inline u16 storvsc_get_version(u8 major, u8 minor)\r\n{\r\nu16 version;\r\nversion = ((major << 8) | minor);\r\nreturn version;\r\n}\r\nstatic inline struct storvsc_device *get_out_stor_device(\r\nstruct hv_device *device)\r\n{\r\nstruct storvsc_device *stor_device;\r\nstor_device = hv_get_drvdata(device);\r\nif (stor_device && stor_device->destroy)\r\nstor_device = NULL;\r\nreturn stor_device;\r\n}\r\nstatic inline void storvsc_wait_to_drain(struct storvsc_device *dev)\r\n{\r\ndev->drain_notify = true;\r\nwait_event(dev->waiting_to_drain,\r\natomic_read(&dev->num_outstanding_req) == 0);\r\ndev->drain_notify = false;\r\n}\r\nstatic inline struct storvsc_device *get_in_stor_device(\r\nstruct hv_device *device)\r\n{\r\nstruct storvsc_device *stor_device;\r\nstor_device = hv_get_drvdata(device);\r\nif (!stor_device)\r\ngoto get_in_err;\r\nif (stor_device->destroy &&\r\n(atomic_read(&stor_device->num_outstanding_req) == 0))\r\nstor_device = NULL;\r\nget_in_err:\r\nreturn stor_device;\r\n}\r\nstatic void destroy_bounce_buffer(struct scatterlist *sgl,\r\nunsigned int sg_count)\r\n{\r\nint i;\r\nstruct page *page_buf;\r\nfor (i = 0; i < sg_count; i++) {\r\npage_buf = sg_page((&sgl[i]));\r\nif (page_buf != NULL)\r\n__free_page(page_buf);\r\n}\r\nkfree(sgl);\r\n}\r\nstatic int do_bounce_buffer(struct scatterlist *sgl, unsigned int sg_count)\r\n{\r\nint i;\r\nif (sg_count < 2)\r\nreturn -1;\r\nfor (i = 0; i < sg_count; i++) {\r\nif (i == 0) {\r\nif (sgl[i].offset + sgl[i].length != PAGE_SIZE)\r\nreturn i;\r\n} else if (i == sg_count - 1) {\r\nif (sgl[i].offset != 0)\r\nreturn i;\r\n} else {\r\nif (sgl[i].length != PAGE_SIZE || sgl[i].offset != 0)\r\nreturn i;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic struct scatterlist *create_bounce_buffer(struct scatterlist *sgl,\r\nunsigned int sg_count,\r\nunsigned int len,\r\nint write)\r\n{\r\nint i;\r\nint num_pages;\r\nstruct scatterlist *bounce_sgl;\r\nstruct page *page_buf;\r\nunsigned int buf_len = ((write == WRITE_TYPE) ? 0 : PAGE_SIZE);\r\nnum_pages = ALIGN(len, PAGE_SIZE) >> PAGE_SHIFT;\r\nbounce_sgl = kcalloc(num_pages, sizeof(struct scatterlist), GFP_ATOMIC);\r\nif (!bounce_sgl)\r\nreturn NULL;\r\nsg_init_table(bounce_sgl, num_pages);\r\nfor (i = 0; i < num_pages; i++) {\r\npage_buf = alloc_page(GFP_ATOMIC);\r\nif (!page_buf)\r\ngoto cleanup;\r\nsg_set_page(&bounce_sgl[i], page_buf, buf_len, 0);\r\n}\r\nreturn bounce_sgl;\r\ncleanup:\r\ndestroy_bounce_buffer(bounce_sgl, num_pages);\r\nreturn NULL;\r\n}\r\nstatic inline unsigned long sg_kmap_atomic(struct scatterlist *sgl, int idx)\r\n{\r\nvoid *addr = kmap_atomic(sg_page(sgl + idx));\r\nreturn (unsigned long)addr;\r\n}\r\nstatic inline void sg_kunmap_atomic(unsigned long addr)\r\n{\r\nkunmap_atomic((void *)addr);\r\n}\r\nstatic unsigned int copy_from_bounce_buffer(struct scatterlist *orig_sgl,\r\nstruct scatterlist *bounce_sgl,\r\nunsigned int orig_sgl_count,\r\nunsigned int bounce_sgl_count)\r\n{\r\nint i;\r\nint j = 0;\r\nunsigned long src, dest;\r\nunsigned int srclen, destlen, copylen;\r\nunsigned int total_copied = 0;\r\nunsigned long bounce_addr = 0;\r\nunsigned long dest_addr = 0;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < orig_sgl_count; i++) {\r\ndest_addr = sg_kmap_atomic(orig_sgl,i) + orig_sgl[i].offset;\r\ndest = dest_addr;\r\ndestlen = orig_sgl[i].length;\r\nif (bounce_addr == 0)\r\nbounce_addr = sg_kmap_atomic(bounce_sgl,j);\r\nwhile (destlen) {\r\nsrc = bounce_addr + bounce_sgl[j].offset;\r\nsrclen = bounce_sgl[j].length - bounce_sgl[j].offset;\r\ncopylen = min(srclen, destlen);\r\nmemcpy((void *)dest, (void *)src, copylen);\r\ntotal_copied += copylen;\r\nbounce_sgl[j].offset += copylen;\r\ndestlen -= copylen;\r\ndest += copylen;\r\nif (bounce_sgl[j].offset == bounce_sgl[j].length) {\r\nsg_kunmap_atomic(bounce_addr);\r\nj++;\r\nif (j == bounce_sgl_count) {\r\nsg_kunmap_atomic(dest_addr - orig_sgl[i].offset);\r\nlocal_irq_restore(flags);\r\nreturn total_copied;\r\n}\r\nif (destlen || i != orig_sgl_count - 1)\r\nbounce_addr = sg_kmap_atomic(bounce_sgl,j);\r\n} else if (destlen == 0 && i == orig_sgl_count - 1) {\r\nsg_kunmap_atomic(bounce_addr);\r\n}\r\n}\r\nsg_kunmap_atomic(dest_addr - orig_sgl[i].offset);\r\n}\r\nlocal_irq_restore(flags);\r\nreturn total_copied;\r\n}\r\nstatic unsigned int copy_to_bounce_buffer(struct scatterlist *orig_sgl,\r\nstruct scatterlist *bounce_sgl,\r\nunsigned int orig_sgl_count)\r\n{\r\nint i;\r\nint j = 0;\r\nunsigned long src, dest;\r\nunsigned int srclen, destlen, copylen;\r\nunsigned int total_copied = 0;\r\nunsigned long bounce_addr = 0;\r\nunsigned long src_addr = 0;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < orig_sgl_count; i++) {\r\nsrc_addr = sg_kmap_atomic(orig_sgl,i) + orig_sgl[i].offset;\r\nsrc = src_addr;\r\nsrclen = orig_sgl[i].length;\r\nif (bounce_addr == 0)\r\nbounce_addr = sg_kmap_atomic(bounce_sgl,j);\r\nwhile (srclen) {\r\ndest = bounce_addr + bounce_sgl[j].length;\r\ndestlen = PAGE_SIZE - bounce_sgl[j].length;\r\ncopylen = min(srclen, destlen);\r\nmemcpy((void *)dest, (void *)src, copylen);\r\ntotal_copied += copylen;\r\nbounce_sgl[j].length += copylen;\r\nsrclen -= copylen;\r\nsrc += copylen;\r\nif (bounce_sgl[j].length == PAGE_SIZE) {\r\nsg_kunmap_atomic(bounce_addr);\r\nj++;\r\nif (srclen || i != orig_sgl_count - 1)\r\nbounce_addr = sg_kmap_atomic(bounce_sgl,j);\r\n} else if (srclen == 0 && i == orig_sgl_count - 1) {\r\nsg_kunmap_atomic(bounce_addr);\r\n}\r\n}\r\nsg_kunmap_atomic(src_addr - orig_sgl[i].offset);\r\n}\r\nlocal_irq_restore(flags);\r\nreturn total_copied;\r\n}\r\nstatic void handle_sc_creation(struct vmbus_channel *new_sc)\r\n{\r\nstruct hv_device *device = new_sc->primary_channel->device_obj;\r\nstruct storvsc_device *stor_device;\r\nstruct vmstorage_channel_properties props;\r\nstor_device = get_out_stor_device(device);\r\nif (!stor_device)\r\nreturn;\r\nif (stor_device->open_sub_channel == false)\r\nreturn;\r\nmemset(&props, 0, sizeof(struct vmstorage_channel_properties));\r\nvmbus_open(new_sc,\r\nstorvsc_ringbuffer_size,\r\nstorvsc_ringbuffer_size,\r\n(void *)&props,\r\nsizeof(struct vmstorage_channel_properties),\r\nstorvsc_on_channel_callback, new_sc);\r\n}\r\nstatic void handle_multichannel_storage(struct hv_device *device, int max_chns)\r\n{\r\nstruct storvsc_device *stor_device;\r\nint num_cpus = num_online_cpus();\r\nint num_sc;\r\nstruct storvsc_cmd_request *request;\r\nstruct vstor_packet *vstor_packet;\r\nint ret, t;\r\nnum_sc = ((max_chns > num_cpus) ? num_cpus : max_chns);\r\nstor_device = get_out_stor_device(device);\r\nif (!stor_device)\r\nreturn;\r\nrequest = &stor_device->init_request;\r\nvstor_packet = &request->vstor_packet;\r\nstor_device->open_sub_channel = true;\r\nvmbus_set_sc_create_callback(device->channel, handle_sc_creation);\r\nif (vmbus_are_subchannels_present(device->channel))\r\nreturn;\r\nstor_device->open_sub_channel = false;\r\nmemset(request, 0, sizeof(struct storvsc_cmd_request));\r\ninit_completion(&request->wait_event);\r\nvstor_packet->operation = VSTOR_OPERATION_CREATE_SUB_CHANNELS;\r\nvstor_packet->flags = REQUEST_COMPLETION_FLAG;\r\nvstor_packet->sub_channel_count = num_sc;\r\nret = vmbus_sendpacket(device->channel, vstor_packet,\r\n(sizeof(struct vstor_packet) -\r\nvmscsi_size_delta),\r\n(unsigned long)request,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (ret != 0)\r\nreturn;\r\nt = wait_for_completion_timeout(&request->wait_event, 10*HZ);\r\nif (t == 0)\r\nreturn;\r\nif (vstor_packet->operation != VSTOR_OPERATION_COMPLETE_IO ||\r\nvstor_packet->status != 0)\r\nreturn;\r\nstor_device->open_sub_channel = true;\r\nvmbus_are_subchannels_present(device->channel);\r\n}\r\nstatic int storvsc_channel_init(struct hv_device *device)\r\n{\r\nstruct storvsc_device *stor_device;\r\nstruct storvsc_cmd_request *request;\r\nstruct vstor_packet *vstor_packet;\r\nint ret, t;\r\nint max_chns;\r\nbool process_sub_channels = false;\r\nstor_device = get_out_stor_device(device);\r\nif (!stor_device)\r\nreturn -ENODEV;\r\nrequest = &stor_device->init_request;\r\nvstor_packet = &request->vstor_packet;\r\nmemset(request, 0, sizeof(struct storvsc_cmd_request));\r\ninit_completion(&request->wait_event);\r\nvstor_packet->operation = VSTOR_OPERATION_BEGIN_INITIALIZATION;\r\nvstor_packet->flags = REQUEST_COMPLETION_FLAG;\r\nret = vmbus_sendpacket(device->channel, vstor_packet,\r\n(sizeof(struct vstor_packet) -\r\nvmscsi_size_delta),\r\n(unsigned long)request,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (ret != 0)\r\ngoto cleanup;\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\nif (vstor_packet->operation != VSTOR_OPERATION_COMPLETE_IO ||\r\nvstor_packet->status != 0)\r\ngoto cleanup;\r\nmemset(vstor_packet, 0, sizeof(struct vstor_packet));\r\nvstor_packet->operation = VSTOR_OPERATION_QUERY_PROTOCOL_VERSION;\r\nvstor_packet->flags = REQUEST_COMPLETION_FLAG;\r\nvstor_packet->version.major_minor =\r\nstorvsc_get_version(vmstor_current_major, vmstor_current_minor);\r\nvstor_packet->version.revision = 0;\r\nret = vmbus_sendpacket(device->channel, vstor_packet,\r\n(sizeof(struct vstor_packet) -\r\nvmscsi_size_delta),\r\n(unsigned long)request,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (ret != 0)\r\ngoto cleanup;\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\nif (vstor_packet->operation != VSTOR_OPERATION_COMPLETE_IO ||\r\nvstor_packet->status != 0)\r\ngoto cleanup;\r\nmemset(vstor_packet, 0, sizeof(struct vstor_packet));\r\nvstor_packet->operation = VSTOR_OPERATION_QUERY_PROPERTIES;\r\nvstor_packet->flags = REQUEST_COMPLETION_FLAG;\r\nret = vmbus_sendpacket(device->channel, vstor_packet,\r\n(sizeof(struct vstor_packet) -\r\nvmscsi_size_delta),\r\n(unsigned long)request,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (ret != 0)\r\ngoto cleanup;\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\nif (vstor_packet->operation != VSTOR_OPERATION_COMPLETE_IO ||\r\nvstor_packet->status != 0)\r\ngoto cleanup;\r\nmax_chns = vstor_packet->storage_channel_properties.max_channel_cnt;\r\nif ((vmbus_proto_version != VERSION_WIN7) &&\r\n(vmbus_proto_version != VERSION_WS2008)) {\r\nif (vstor_packet->storage_channel_properties.flags &\r\nSTORAGE_CHANNEL_SUPPORTS_MULTI_CHANNEL)\r\nprocess_sub_channels = true;\r\n}\r\nmemset(vstor_packet, 0, sizeof(struct vstor_packet));\r\nvstor_packet->operation = VSTOR_OPERATION_END_INITIALIZATION;\r\nvstor_packet->flags = REQUEST_COMPLETION_FLAG;\r\nret = vmbus_sendpacket(device->channel, vstor_packet,\r\n(sizeof(struct vstor_packet) -\r\nvmscsi_size_delta),\r\n(unsigned long)request,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (ret != 0)\r\ngoto cleanup;\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\nif (vstor_packet->operation != VSTOR_OPERATION_COMPLETE_IO ||\r\nvstor_packet->status != 0)\r\ngoto cleanup;\r\nif (process_sub_channels)\r\nhandle_multichannel_storage(device, max_chns);\r\ncleanup:\r\nreturn ret;\r\n}\r\nstatic void storvsc_handle_error(struct vmscsi_request *vm_srb,\r\nstruct scsi_cmnd *scmnd,\r\nstruct Scsi_Host *host,\r\nu8 asc, u8 ascq)\r\n{\r\nstruct storvsc_scan_work *wrk;\r\nvoid (*process_err_fn)(struct work_struct *work);\r\nbool do_work = false;\r\nswitch (vm_srb->srb_status) {\r\ncase SRB_STATUS_ERROR:\r\nswitch (scmnd->cmnd[0]) {\r\ncase ATA_16:\r\ncase ATA_12:\r\nset_host_byte(scmnd, DID_PASSTHROUGH);\r\nbreak;\r\ndefault:\r\nset_host_byte(scmnd, DID_TARGET_FAILURE);\r\n}\r\nbreak;\r\ncase SRB_STATUS_INVALID_LUN:\r\ndo_work = true;\r\nprocess_err_fn = storvsc_remove_lun;\r\nbreak;\r\ncase (SRB_STATUS_ABORTED | SRB_STATUS_AUTOSENSE_VALID):\r\nif ((asc == 0x2a) && (ascq == 0x9)) {\r\ndo_work = true;\r\nprocess_err_fn = storvsc_device_scan;\r\nset_host_byte(scmnd, DID_REQUEUE);\r\n}\r\nbreak;\r\n}\r\nif (!do_work)\r\nreturn;\r\nwrk = kmalloc(sizeof(struct storvsc_scan_work), GFP_ATOMIC);\r\nif (!wrk) {\r\nset_host_byte(scmnd, DID_TARGET_FAILURE);\r\nreturn;\r\n}\r\nwrk->host = host;\r\nwrk->lun = vm_srb->lun;\r\nINIT_WORK(&wrk->work, process_err_fn);\r\nschedule_work(&wrk->work);\r\n}\r\nstatic void storvsc_command_completion(struct storvsc_cmd_request *cmd_request)\r\n{\r\nstruct scsi_cmnd *scmnd = cmd_request->cmd;\r\nstruct hv_host_device *host_dev = shost_priv(scmnd->device->host);\r\nvoid (*scsi_done_fn)(struct scsi_cmnd *);\r\nstruct scsi_sense_hdr sense_hdr;\r\nstruct vmscsi_request *vm_srb;\r\nstruct stor_mem_pools *memp = scmnd->device->hostdata;\r\nstruct Scsi_Host *host;\r\nstruct storvsc_device *stor_dev;\r\nstruct hv_device *dev = host_dev->dev;\r\nstor_dev = get_in_stor_device(dev);\r\nhost = stor_dev->host;\r\nvm_srb = &cmd_request->vstor_packet.vm_srb;\r\nif (cmd_request->bounce_sgl_count) {\r\nif (vm_srb->data_in == READ_TYPE)\r\ncopy_from_bounce_buffer(scsi_sglist(scmnd),\r\ncmd_request->bounce_sgl,\r\nscsi_sg_count(scmnd),\r\ncmd_request->bounce_sgl_count);\r\ndestroy_bounce_buffer(cmd_request->bounce_sgl,\r\ncmd_request->bounce_sgl_count);\r\n}\r\nscmnd->result = vm_srb->scsi_status;\r\nif (scmnd->result) {\r\nif (scsi_normalize_sense(scmnd->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE, &sense_hdr))\r\nscsi_print_sense_hdr("storvsc", &sense_hdr);\r\n}\r\nif (vm_srb->srb_status != SRB_STATUS_SUCCESS)\r\nstorvsc_handle_error(vm_srb, scmnd, host, sense_hdr.asc,\r\nsense_hdr.ascq);\r\nscsi_set_resid(scmnd,\r\ncmd_request->data_buffer.len -\r\nvm_srb->data_transfer_length);\r\nscsi_done_fn = scmnd->scsi_done;\r\nscmnd->host_scribble = NULL;\r\nscmnd->scsi_done = NULL;\r\nscsi_done_fn(scmnd);\r\nmempool_free(cmd_request, memp->request_mempool);\r\n}\r\nstatic void storvsc_on_io_completion(struct hv_device *device,\r\nstruct vstor_packet *vstor_packet,\r\nstruct storvsc_cmd_request *request)\r\n{\r\nstruct storvsc_device *stor_device;\r\nstruct vstor_packet *stor_pkt;\r\nstor_device = hv_get_drvdata(device);\r\nstor_pkt = &request->vstor_packet;\r\nif ((stor_pkt->vm_srb.cdb[0] == INQUIRY) ||\r\n(stor_pkt->vm_srb.cdb[0] == MODE_SENSE)) {\r\nvstor_packet->vm_srb.scsi_status = 0;\r\nvstor_packet->vm_srb.srb_status = SRB_STATUS_SUCCESS;\r\n}\r\nstor_pkt->vm_srb.scsi_status = vstor_packet->vm_srb.scsi_status;\r\nstor_pkt->vm_srb.srb_status = vstor_packet->vm_srb.srb_status;\r\nstor_pkt->vm_srb.sense_info_length =\r\nvstor_packet->vm_srb.sense_info_length;\r\nif (vstor_packet->vm_srb.scsi_status != 0 ||\r\nvstor_packet->vm_srb.srb_status != SRB_STATUS_SUCCESS){\r\ndev_warn(&device->device,\r\n"cmd 0x%x scsi status 0x%x srb status 0x%x\n",\r\nstor_pkt->vm_srb.cdb[0],\r\nvstor_packet->vm_srb.scsi_status,\r\nvstor_packet->vm_srb.srb_status);\r\n}\r\nif ((vstor_packet->vm_srb.scsi_status & 0xFF) == 0x02) {\r\nif (vstor_packet->vm_srb.srb_status &\r\nSRB_STATUS_AUTOSENSE_VALID) {\r\ndev_warn(&device->device,\r\n"stor pkt %p autosense data valid - len %d\n",\r\nrequest,\r\nvstor_packet->vm_srb.sense_info_length);\r\nmemcpy(request->sense_buffer,\r\nvstor_packet->vm_srb.sense_data,\r\nvstor_packet->vm_srb.sense_info_length);\r\n}\r\n}\r\nstor_pkt->vm_srb.data_transfer_length =\r\nvstor_packet->vm_srb.data_transfer_length;\r\nstorvsc_command_completion(request);\r\nif (atomic_dec_and_test(&stor_device->num_outstanding_req) &&\r\nstor_device->drain_notify)\r\nwake_up(&stor_device->waiting_to_drain);\r\n}\r\nstatic void storvsc_on_receive(struct hv_device *device,\r\nstruct vstor_packet *vstor_packet,\r\nstruct storvsc_cmd_request *request)\r\n{\r\nstruct storvsc_scan_work *work;\r\nstruct storvsc_device *stor_device;\r\nswitch (vstor_packet->operation) {\r\ncase VSTOR_OPERATION_COMPLETE_IO:\r\nstorvsc_on_io_completion(device, vstor_packet, request);\r\nbreak;\r\ncase VSTOR_OPERATION_REMOVE_DEVICE:\r\ncase VSTOR_OPERATION_ENUMERATE_BUS:\r\nstor_device = get_in_stor_device(device);\r\nwork = kmalloc(sizeof(struct storvsc_scan_work), GFP_ATOMIC);\r\nif (!work)\r\nreturn;\r\nINIT_WORK(&work->work, storvsc_bus_scan);\r\nwork->host = stor_device->host;\r\nschedule_work(&work->work);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void storvsc_on_channel_callback(void *context)\r\n{\r\nstruct vmbus_channel *channel = (struct vmbus_channel *)context;\r\nstruct hv_device *device;\r\nstruct storvsc_device *stor_device;\r\nu32 bytes_recvd;\r\nu64 request_id;\r\nunsigned char packet[ALIGN(sizeof(struct vstor_packet), 8)];\r\nstruct storvsc_cmd_request *request;\r\nint ret;\r\nif (channel->primary_channel != NULL)\r\ndevice = channel->primary_channel->device_obj;\r\nelse\r\ndevice = channel->device_obj;\r\nstor_device = get_in_stor_device(device);\r\nif (!stor_device)\r\nreturn;\r\ndo {\r\nret = vmbus_recvpacket(channel, packet,\r\nALIGN((sizeof(struct vstor_packet) -\r\nvmscsi_size_delta), 8),\r\n&bytes_recvd, &request_id);\r\nif (ret == 0 && bytes_recvd > 0) {\r\nrequest = (struct storvsc_cmd_request *)\r\n(unsigned long)request_id;\r\nif ((request == &stor_device->init_request) ||\r\n(request == &stor_device->reset_request)) {\r\nmemcpy(&request->vstor_packet, packet,\r\n(sizeof(struct vstor_packet) -\r\nvmscsi_size_delta));\r\ncomplete(&request->wait_event);\r\n} else {\r\nstorvsc_on_receive(device,\r\n(struct vstor_packet *)packet,\r\nrequest);\r\n}\r\n} else {\r\nbreak;\r\n}\r\n} while (1);\r\nreturn;\r\n}\r\nstatic int storvsc_connect_to_vsp(struct hv_device *device, u32 ring_size)\r\n{\r\nstruct vmstorage_channel_properties props;\r\nint ret;\r\nmemset(&props, 0, sizeof(struct vmstorage_channel_properties));\r\nret = vmbus_open(device->channel,\r\nring_size,\r\nring_size,\r\n(void *)&props,\r\nsizeof(struct vmstorage_channel_properties),\r\nstorvsc_on_channel_callback, device->channel);\r\nif (ret != 0)\r\nreturn ret;\r\nret = storvsc_channel_init(device);\r\nreturn ret;\r\n}\r\nstatic int storvsc_dev_remove(struct hv_device *device)\r\n{\r\nstruct storvsc_device *stor_device;\r\nunsigned long flags;\r\nstor_device = hv_get_drvdata(device);\r\nspin_lock_irqsave(&device->channel->inbound_lock, flags);\r\nstor_device->destroy = true;\r\nspin_unlock_irqrestore(&device->channel->inbound_lock, flags);\r\nstorvsc_wait_to_drain(stor_device);\r\nspin_lock_irqsave(&device->channel->inbound_lock, flags);\r\nhv_set_drvdata(device, NULL);\r\nspin_unlock_irqrestore(&device->channel->inbound_lock, flags);\r\nvmbus_close(device->channel);\r\nkfree(stor_device);\r\nreturn 0;\r\n}\r\nstatic int storvsc_do_io(struct hv_device *device,\r\nstruct storvsc_cmd_request *request)\r\n{\r\nstruct storvsc_device *stor_device;\r\nstruct vstor_packet *vstor_packet;\r\nstruct vmbus_channel *outgoing_channel;\r\nint ret = 0;\r\nvstor_packet = &request->vstor_packet;\r\nstor_device = get_out_stor_device(device);\r\nif (!stor_device)\r\nreturn -ENODEV;\r\nrequest->device = device;\r\noutgoing_channel = vmbus_get_outgoing_channel(device->channel);\r\nvstor_packet->flags |= REQUEST_COMPLETION_FLAG;\r\nvstor_packet->vm_srb.length = (sizeof(struct vmscsi_request) -\r\nvmscsi_size_delta);\r\nvstor_packet->vm_srb.sense_info_length = sense_buffer_size;\r\nvstor_packet->vm_srb.data_transfer_length =\r\nrequest->data_buffer.len;\r\nvstor_packet->operation = VSTOR_OPERATION_EXECUTE_SRB;\r\nif (request->data_buffer.len) {\r\nret = vmbus_sendpacket_multipagebuffer(outgoing_channel,\r\n&request->data_buffer,\r\nvstor_packet,\r\n(sizeof(struct vstor_packet) -\r\nvmscsi_size_delta),\r\n(unsigned long)request);\r\n} else {\r\nret = vmbus_sendpacket(device->channel, vstor_packet,\r\n(sizeof(struct vstor_packet) -\r\nvmscsi_size_delta),\r\n(unsigned long)request,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\n}\r\nif (ret != 0)\r\nreturn ret;\r\natomic_inc(&stor_device->num_outstanding_req);\r\nreturn ret;\r\n}\r\nstatic int storvsc_device_alloc(struct scsi_device *sdevice)\r\n{\r\nstruct stor_mem_pools *memp;\r\nint number = STORVSC_MIN_BUF_NR;\r\nmemp = kzalloc(sizeof(struct stor_mem_pools), GFP_KERNEL);\r\nif (!memp)\r\nreturn -ENOMEM;\r\nmemp->request_pool =\r\nkmem_cache_create(dev_name(&sdevice->sdev_dev),\r\nsizeof(struct storvsc_cmd_request), 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!memp->request_pool)\r\ngoto err0;\r\nmemp->request_mempool = mempool_create(number, mempool_alloc_slab,\r\nmempool_free_slab,\r\nmemp->request_pool);\r\nif (!memp->request_mempool)\r\ngoto err1;\r\nsdevice->hostdata = memp;\r\nreturn 0;\r\nerr1:\r\nkmem_cache_destroy(memp->request_pool);\r\nerr0:\r\nkfree(memp);\r\nreturn -ENOMEM;\r\n}\r\nstatic void storvsc_device_destroy(struct scsi_device *sdevice)\r\n{\r\nstruct stor_mem_pools *memp = sdevice->hostdata;\r\nif (!memp)\r\nreturn;\r\nmempool_destroy(memp->request_mempool);\r\nkmem_cache_destroy(memp->request_pool);\r\nkfree(memp);\r\nsdevice->hostdata = NULL;\r\n}\r\nstatic int storvsc_device_configure(struct scsi_device *sdevice)\r\n{\r\nscsi_adjust_queue_depth(sdevice, MSG_SIMPLE_TAG,\r\nSTORVSC_MAX_IO_REQUESTS);\r\nblk_queue_max_segment_size(sdevice->request_queue, PAGE_SIZE);\r\nblk_queue_bounce_limit(sdevice->request_queue, BLK_BOUNCE_ANY);\r\nblk_queue_rq_timeout(sdevice->request_queue, (storvsc_timeout * HZ));\r\nsdevice->no_write_same = 1;\r\nreturn 0;\r\n}\r\nstatic int storvsc_get_chs(struct scsi_device *sdev, struct block_device * bdev,\r\nsector_t capacity, int *info)\r\n{\r\nsector_t nsect = capacity;\r\nsector_t cylinders = nsect;\r\nint heads, sectors_pt;\r\nheads = 0xff;\r\nsectors_pt = 0x3f;\r\nsector_div(cylinders, heads * sectors_pt);\r\nif ((sector_t)(cylinders + 1) * heads * sectors_pt < nsect)\r\ncylinders = 0xffff;\r\ninfo[0] = heads;\r\ninfo[1] = sectors_pt;\r\ninfo[2] = (int)cylinders;\r\nreturn 0;\r\n}\r\nstatic int storvsc_host_reset_handler(struct scsi_cmnd *scmnd)\r\n{\r\nstruct hv_host_device *host_dev = shost_priv(scmnd->device->host);\r\nstruct hv_device *device = host_dev->dev;\r\nstruct storvsc_device *stor_device;\r\nstruct storvsc_cmd_request *request;\r\nstruct vstor_packet *vstor_packet;\r\nint ret, t;\r\nstor_device = get_out_stor_device(device);\r\nif (!stor_device)\r\nreturn FAILED;\r\nrequest = &stor_device->reset_request;\r\nvstor_packet = &request->vstor_packet;\r\ninit_completion(&request->wait_event);\r\nvstor_packet->operation = VSTOR_OPERATION_RESET_BUS;\r\nvstor_packet->flags = REQUEST_COMPLETION_FLAG;\r\nvstor_packet->vm_srb.path_id = stor_device->path_id;\r\nret = vmbus_sendpacket(device->channel, vstor_packet,\r\n(sizeof(struct vstor_packet) -\r\nvmscsi_size_delta),\r\n(unsigned long)&stor_device->reset_request,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (ret != 0)\r\nreturn FAILED;\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0)\r\nreturn TIMEOUT_ERROR;\r\nstorvsc_wait_to_drain(stor_device);\r\nreturn SUCCESS;\r\n}\r\nstatic bool storvsc_scsi_cmd_ok(struct scsi_cmnd *scmnd)\r\n{\r\nbool allowed = true;\r\nu8 scsi_op = scmnd->cmnd[0];\r\nswitch (scsi_op) {\r\ncase WRITE_SAME:\r\ncase SET_WINDOW:\r\nscmnd->result = ILLEGAL_REQUEST << 16;\r\nallowed = false;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn allowed;\r\n}\r\nstatic int storvsc_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scmnd)\r\n{\r\nint ret;\r\nstruct hv_host_device *host_dev = shost_priv(host);\r\nstruct hv_device *dev = host_dev->dev;\r\nstruct storvsc_cmd_request *cmd_request;\r\nunsigned int request_size = 0;\r\nint i;\r\nstruct scatterlist *sgl;\r\nunsigned int sg_count = 0;\r\nstruct vmscsi_request *vm_srb;\r\nstruct stor_mem_pools *memp = scmnd->device->hostdata;\r\nif (!storvsc_scsi_cmd_ok(scmnd)) {\r\nscmnd->scsi_done(scmnd);\r\nreturn 0;\r\n}\r\nrequest_size = sizeof(struct storvsc_cmd_request);\r\ncmd_request = mempool_alloc(memp->request_mempool,\r\nGFP_ATOMIC);\r\nif (!cmd_request)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\nmemset(cmd_request, 0, sizeof(struct storvsc_cmd_request));\r\ncmd_request->cmd = scmnd;\r\nscmnd->host_scribble = (unsigned char *)cmd_request;\r\nvm_srb = &cmd_request->vstor_packet.vm_srb;\r\nvm_srb->win8_extension.time_out_value = 60;\r\nswitch (scmnd->sc_data_direction) {\r\ncase DMA_TO_DEVICE:\r\nvm_srb->data_in = WRITE_TYPE;\r\nvm_srb->win8_extension.srb_flags |= SRB_FLAGS_DATA_OUT;\r\nvm_srb->win8_extension.srb_flags |=\r\n(SRB_FLAGS_QUEUE_ACTION_ENABLE |\r\nSRB_FLAGS_DISABLE_SYNCH_TRANSFER);\r\nbreak;\r\ncase DMA_FROM_DEVICE:\r\nvm_srb->data_in = READ_TYPE;\r\nvm_srb->win8_extension.srb_flags |= SRB_FLAGS_DATA_IN;\r\nvm_srb->win8_extension.srb_flags |=\r\n(SRB_FLAGS_QUEUE_ACTION_ENABLE |\r\nSRB_FLAGS_DISABLE_SYNCH_TRANSFER);\r\nbreak;\r\ndefault:\r\nvm_srb->data_in = UNKNOWN_TYPE;\r\nvm_srb->win8_extension.srb_flags = 0;\r\nbreak;\r\n}\r\nvm_srb->port_number = host_dev->port;\r\nvm_srb->path_id = scmnd->device->channel;\r\nvm_srb->target_id = scmnd->device->id;\r\nvm_srb->lun = scmnd->device->lun;\r\nvm_srb->cdb_length = scmnd->cmd_len;\r\nmemcpy(vm_srb->cdb, scmnd->cmnd, vm_srb->cdb_length);\r\ncmd_request->sense_buffer = scmnd->sense_buffer;\r\ncmd_request->data_buffer.len = scsi_bufflen(scmnd);\r\nif (scsi_sg_count(scmnd)) {\r\nsgl = (struct scatterlist *)scsi_sglist(scmnd);\r\nsg_count = scsi_sg_count(scmnd);\r\nif (do_bounce_buffer(sgl, scsi_sg_count(scmnd)) != -1) {\r\ncmd_request->bounce_sgl =\r\ncreate_bounce_buffer(sgl, scsi_sg_count(scmnd),\r\nscsi_bufflen(scmnd),\r\nvm_srb->data_in);\r\nif (!cmd_request->bounce_sgl) {\r\nret = SCSI_MLQUEUE_HOST_BUSY;\r\ngoto queue_error;\r\n}\r\ncmd_request->bounce_sgl_count =\r\nALIGN(scsi_bufflen(scmnd), PAGE_SIZE) >>\r\nPAGE_SHIFT;\r\nif (vm_srb->data_in == WRITE_TYPE)\r\ncopy_to_bounce_buffer(sgl,\r\ncmd_request->bounce_sgl,\r\nscsi_sg_count(scmnd));\r\nsgl = cmd_request->bounce_sgl;\r\nsg_count = cmd_request->bounce_sgl_count;\r\n}\r\ncmd_request->data_buffer.offset = sgl[0].offset;\r\nfor (i = 0; i < sg_count; i++)\r\ncmd_request->data_buffer.pfn_array[i] =\r\npage_to_pfn(sg_page((&sgl[i])));\r\n} else if (scsi_sglist(scmnd)) {\r\ncmd_request->data_buffer.offset =\r\nvirt_to_phys(scsi_sglist(scmnd)) & (PAGE_SIZE-1);\r\ncmd_request->data_buffer.pfn_array[0] =\r\nvirt_to_phys(scsi_sglist(scmnd)) >> PAGE_SHIFT;\r\n}\r\nret = storvsc_do_io(dev, cmd_request);\r\nif (ret == -EAGAIN) {\r\nif (cmd_request->bounce_sgl_count) {\r\ndestroy_bounce_buffer(cmd_request->bounce_sgl,\r\ncmd_request->bounce_sgl_count);\r\nret = SCSI_MLQUEUE_DEVICE_BUSY;\r\ngoto queue_error;\r\n}\r\n}\r\nreturn 0;\r\nqueue_error:\r\nmempool_free(cmd_request, memp->request_mempool);\r\nscmnd->host_scribble = NULL;\r\nreturn ret;\r\n}\r\nstatic int storvsc_probe(struct hv_device *device,\r\nconst struct hv_vmbus_device_id *dev_id)\r\n{\r\nint ret;\r\nstruct Scsi_Host *host;\r\nstruct hv_host_device *host_dev;\r\nbool dev_is_ide = ((dev_id->driver_data == IDE_GUID) ? true : false);\r\nint target = 0;\r\nstruct storvsc_device *stor_device;\r\nif (vmbus_proto_version == VERSION_WIN8) {\r\nsense_buffer_size = POST_WIN7_STORVSC_SENSE_BUFFER_SIZE;\r\nvmscsi_size_delta = 0;\r\nvmstor_current_major = VMSTOR_WIN8_MAJOR;\r\nvmstor_current_minor = VMSTOR_WIN8_MINOR;\r\n} else {\r\nsense_buffer_size = PRE_WIN8_STORVSC_SENSE_BUFFER_SIZE;\r\nvmscsi_size_delta = sizeof(struct vmscsi_win8_extension);\r\nvmstor_current_major = VMSTOR_WIN7_MAJOR;\r\nvmstor_current_minor = VMSTOR_WIN7_MINOR;\r\n}\r\nhost = scsi_host_alloc(&scsi_driver,\r\nsizeof(struct hv_host_device));\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost_dev = shost_priv(host);\r\nmemset(host_dev, 0, sizeof(struct hv_host_device));\r\nhost_dev->port = host->host_no;\r\nhost_dev->dev = device;\r\nstor_device = kzalloc(sizeof(struct storvsc_device), GFP_KERNEL);\r\nif (!stor_device) {\r\nret = -ENOMEM;\r\ngoto err_out0;\r\n}\r\nstor_device->destroy = false;\r\nstor_device->open_sub_channel = false;\r\ninit_waitqueue_head(&stor_device->waiting_to_drain);\r\nstor_device->device = device;\r\nstor_device->host = host;\r\nhv_set_drvdata(device, stor_device);\r\nstor_device->port_number = host->host_no;\r\nret = storvsc_connect_to_vsp(device, storvsc_ringbuffer_size);\r\nif (ret)\r\ngoto err_out1;\r\nhost_dev->path = stor_device->path_id;\r\nhost_dev->target = stor_device->target_id;\r\nhost->max_lun = STORVSC_MAX_LUNS_PER_TARGET;\r\nhost->max_id = STORVSC_MAX_TARGETS;\r\nhost->max_channel = STORVSC_MAX_CHANNELS - 1;\r\nhost->max_cmd_len = STORVSC_MAX_CMD_LEN;\r\nret = scsi_add_host(host, &device->device);\r\nif (ret != 0)\r\ngoto err_out2;\r\nif (!dev_is_ide) {\r\nscsi_scan_host(host);\r\n} else {\r\ntarget = (device->dev_instance.b[5] << 8 |\r\ndevice->dev_instance.b[4]);\r\nret = scsi_add_device(host, 0, target, 0);\r\nif (ret) {\r\nscsi_remove_host(host);\r\ngoto err_out2;\r\n}\r\n}\r\nreturn 0;\r\nerr_out2:\r\nstorvsc_dev_remove(device);\r\ngoto err_out0;\r\nerr_out1:\r\nkfree(stor_device);\r\nerr_out0:\r\nscsi_host_put(host);\r\nreturn ret;\r\n}\r\nstatic int storvsc_remove(struct hv_device *dev)\r\n{\r\nstruct storvsc_device *stor_device = hv_get_drvdata(dev);\r\nstruct Scsi_Host *host = stor_device->host;\r\nscsi_remove_host(host);\r\nstorvsc_dev_remove(dev);\r\nscsi_host_put(host);\r\nreturn 0;\r\n}\r\nstatic int __init storvsc_drv_init(void)\r\n{\r\nu32 max_outstanding_req_per_channel;\r\nmax_outstanding_req_per_channel =\r\n((storvsc_ringbuffer_size - PAGE_SIZE) /\r\nALIGN(MAX_MULTIPAGE_BUFFER_PACKET +\r\nsizeof(struct vstor_packet) + sizeof(u64) -\r\nvmscsi_size_delta,\r\nsizeof(u64)));\r\nif (max_outstanding_req_per_channel <\r\nSTORVSC_MAX_IO_REQUESTS)\r\nreturn -EINVAL;\r\nreturn vmbus_driver_register(&storvsc_drv);\r\n}\r\nstatic void __exit storvsc_drv_exit(void)\r\n{\r\nvmbus_driver_unregister(&storvsc_drv);\r\n}
