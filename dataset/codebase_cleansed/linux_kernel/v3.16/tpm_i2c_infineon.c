static int iic_tpm_read(u8 addr, u8 *buffer, size_t len)\r\n{\r\nstruct i2c_msg msg1 = {\r\n.addr = tpm_dev.client->addr,\r\n.len = 1,\r\n.buf = &addr\r\n};\r\nstruct i2c_msg msg2 = {\r\n.addr = tpm_dev.client->addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = buffer\r\n};\r\nstruct i2c_msg msgs[] = {msg1, msg2};\r\nint rc = 0;\r\nint count;\r\nif (!tpm_dev.client->adapter->algo->master_xfer)\r\nreturn -EOPNOTSUPP;\r\ni2c_lock_adapter(tpm_dev.client->adapter);\r\nif (tpm_dev.chip_type == SLB9645) {\r\nfor (count = 0; count < MAX_COUNT; count++) {\r\nrc = __i2c_transfer(tpm_dev.client->adapter, msgs, 2);\r\nif (rc > 0)\r\nbreak;\r\nusleep_range(SLEEP_DURATION_LOW, SLEEP_DURATION_HI);\r\n}\r\n} else {\r\nfor (count = 0; count < MAX_COUNT; count++) {\r\nrc = __i2c_transfer(tpm_dev.client->adapter, &msg1, 1);\r\nif (rc > 0)\r\nbreak;\r\nusleep_range(SLEEP_DURATION_LOW, SLEEP_DURATION_HI);\r\n}\r\nif (rc <= 0)\r\ngoto out;\r\nfor (count = 0; count < MAX_COUNT; count++) {\r\nusleep_range(SLEEP_DURATION_LOW, SLEEP_DURATION_HI);\r\nrc = __i2c_transfer(tpm_dev.client->adapter, &msg2, 1);\r\nif (rc > 0)\r\nbreak;\r\n}\r\n}\r\nout:\r\ni2c_unlock_adapter(tpm_dev.client->adapter);\r\nusleep_range(SLEEP_DURATION_LOW, SLEEP_DURATION_HI);\r\nif (rc <= 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int iic_tpm_write_generic(u8 addr, u8 *buffer, size_t len,\r\nunsigned int sleep_low,\r\nunsigned int sleep_hi, u8 max_count)\r\n{\r\nint rc = -EIO;\r\nint count;\r\nstruct i2c_msg msg1 = {\r\n.addr = tpm_dev.client->addr,\r\n.len = len + 1,\r\n.buf = tpm_dev.buf\r\n};\r\nif (len > TPM_BUFSIZE)\r\nreturn -EINVAL;\r\nif (!tpm_dev.client->adapter->algo->master_xfer)\r\nreturn -EOPNOTSUPP;\r\ni2c_lock_adapter(tpm_dev.client->adapter);\r\ntpm_dev.buf[0] = addr;\r\nmemcpy(&(tpm_dev.buf[1]), buffer, len);\r\nfor (count = 0; count < max_count; count++) {\r\nrc = __i2c_transfer(tpm_dev.client->adapter, &msg1, 1);\r\nif (rc > 0)\r\nbreak;\r\nusleep_range(sleep_low, sleep_hi);\r\n}\r\ni2c_unlock_adapter(tpm_dev.client->adapter);\r\nusleep_range(SLEEP_DURATION_LOW, SLEEP_DURATION_HI);\r\nif (rc <= 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int iic_tpm_write(u8 addr, u8 *buffer, size_t len)\r\n{\r\nreturn iic_tpm_write_generic(addr, buffer, len, SLEEP_DURATION_LOW,\r\nSLEEP_DURATION_HI, MAX_COUNT);\r\n}\r\nstatic int iic_tpm_write_long(u8 addr, u8 *buffer, size_t len)\r\n{\r\nreturn iic_tpm_write_generic(addr, buffer, len, SLEEP_DURATION_LONG_LOW,\r\nSLEEP_DURATION_LONG_HI, MAX_COUNT_LONG);\r\n}\r\nstatic int check_locality(struct tpm_chip *chip, int loc)\r\n{\r\nu8 buf;\r\nint rc;\r\nrc = iic_tpm_read(TPM_ACCESS(loc), &buf, 1);\r\nif (rc < 0)\r\nreturn rc;\r\nif ((buf & (TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID)) ==\r\n(TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID)) {\r\nchip->vendor.locality = loc;\r\nreturn loc;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void release_locality(struct tpm_chip *chip, int loc, int force)\r\n{\r\nu8 buf;\r\nif (iic_tpm_read(TPM_ACCESS(loc), &buf, 1) < 0)\r\nreturn;\r\nif (force || (buf & (TPM_ACCESS_REQUEST_PENDING | TPM_ACCESS_VALID)) ==\r\n(TPM_ACCESS_REQUEST_PENDING | TPM_ACCESS_VALID)) {\r\nbuf = TPM_ACCESS_ACTIVE_LOCALITY;\r\niic_tpm_write(TPM_ACCESS(loc), &buf, 1);\r\n}\r\n}\r\nstatic int request_locality(struct tpm_chip *chip, int loc)\r\n{\r\nunsigned long stop;\r\nu8 buf = TPM_ACCESS_REQUEST_USE;\r\nif (check_locality(chip, loc) >= 0)\r\nreturn loc;\r\niic_tpm_write(TPM_ACCESS(loc), &buf, 1);\r\nstop = jiffies + chip->vendor.timeout_a;\r\ndo {\r\nif (check_locality(chip, loc) >= 0)\r\nreturn loc;\r\nusleep_range(TPM_TIMEOUT_US_LOW, TPM_TIMEOUT_US_HI);\r\n} while (time_before(jiffies, stop));\r\nreturn -ETIME;\r\n}\r\nstatic u8 tpm_tis_i2c_status(struct tpm_chip *chip)\r\n{\r\nu8 buf = 0xFF;\r\nu8 i = 0;\r\ndo {\r\nif (iic_tpm_read(TPM_STS(chip->vendor.locality), &buf, 1) < 0)\r\nreturn 0;\r\ni++;\r\n} while ((buf == 0xFF) && i < 10);\r\nreturn buf;\r\n}\r\nstatic void tpm_tis_i2c_ready(struct tpm_chip *chip)\r\n{\r\nu8 buf = TPM_STS_COMMAND_READY;\r\niic_tpm_write_long(TPM_STS(chip->vendor.locality), &buf, 1);\r\n}\r\nstatic ssize_t get_burstcount(struct tpm_chip *chip)\r\n{\r\nunsigned long stop;\r\nssize_t burstcnt;\r\nu8 buf[3];\r\nstop = jiffies + chip->vendor.timeout_d;\r\ndo {\r\nif (iic_tpm_read(TPM_STS(chip->vendor.locality)+1, buf, 3) < 0)\r\nburstcnt = 0;\r\nelse\r\nburstcnt = (buf[2] << 16) + (buf[1] << 8) + buf[0];\r\nif (burstcnt)\r\nreturn burstcnt;\r\nusleep_range(TPM_TIMEOUT_US_LOW, TPM_TIMEOUT_US_HI);\r\n} while (time_before(jiffies, stop));\r\nreturn -EBUSY;\r\n}\r\nstatic int wait_for_stat(struct tpm_chip *chip, u8 mask, unsigned long timeout,\r\nint *status)\r\n{\r\nunsigned long stop;\r\n*status = tpm_tis_i2c_status(chip);\r\nif ((*status != 0xFF) && (*status & mask) == mask)\r\nreturn 0;\r\nstop = jiffies + timeout;\r\ndo {\r\nusleep_range(TPM_TIMEOUT_US_LOW, TPM_TIMEOUT_US_HI);\r\n*status = tpm_tis_i2c_status(chip);\r\nif ((*status & mask) == mask)\r\nreturn 0;\r\n} while (time_before(jiffies, stop));\r\nreturn -ETIME;\r\n}\r\nstatic int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nsize_t size = 0;\r\nssize_t burstcnt;\r\nu8 retries = 0;\r\nint rc;\r\nwhile (size < count) {\r\nburstcnt = get_burstcount(chip);\r\nif (burstcnt < 0)\r\nreturn burstcnt;\r\nif (burstcnt > (count - size))\r\nburstcnt = count - size;\r\nrc = iic_tpm_read(TPM_DATA_FIFO(chip->vendor.locality),\r\n&(buf[size]), burstcnt);\r\nif (rc == 0)\r\nsize += burstcnt;\r\nelse if (rc < 0)\r\nretries++;\r\nif (retries > MAX_COUNT_LONG)\r\nreturn -EIO;\r\n}\r\nreturn size;\r\n}\r\nstatic int tpm_tis_i2c_recv(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nint size = 0;\r\nint expected, status;\r\nif (count < TPM_HEADER_SIZE) {\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nsize = recv_data(chip, buf, TPM_HEADER_SIZE);\r\nif (size < TPM_HEADER_SIZE) {\r\ndev_err(chip->dev, "Unable to read header\n");\r\ngoto out;\r\n}\r\nexpected = be32_to_cpu(*(__be32 *)(buf + 2));\r\nif ((size_t) expected > count) {\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nsize += recv_data(chip, &buf[TPM_HEADER_SIZE],\r\nexpected - TPM_HEADER_SIZE);\r\nif (size < expected) {\r\ndev_err(chip->dev, "Unable to read remainder of result\n");\r\nsize = -ETIME;\r\ngoto out;\r\n}\r\nwait_for_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c, &status);\r\nif (status & TPM_STS_DATA_AVAIL) {\r\ndev_err(chip->dev, "Error left over data\n");\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nout:\r\ntpm_tis_i2c_ready(chip);\r\nusleep_range(SLEEP_DURATION_RESET_LOW, SLEEP_DURATION_RESET_HI);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn size;\r\n}\r\nstatic int tpm_tis_i2c_send(struct tpm_chip *chip, u8 *buf, size_t len)\r\n{\r\nint rc, status;\r\nssize_t burstcnt;\r\nsize_t count = 0;\r\nu8 retries = 0;\r\nu8 sts = TPM_STS_GO;\r\nif (len > TPM_BUFSIZE)\r\nreturn -E2BIG;\r\nif (request_locality(chip, 0) < 0)\r\nreturn -EBUSY;\r\nstatus = tpm_tis_i2c_status(chip);\r\nif ((status & TPM_STS_COMMAND_READY) == 0) {\r\ntpm_tis_i2c_ready(chip);\r\nif (wait_for_stat\r\n(chip, TPM_STS_COMMAND_READY,\r\nchip->vendor.timeout_b, &status) < 0) {\r\nrc = -ETIME;\r\ngoto out_err;\r\n}\r\n}\r\nwhile (count < len - 1) {\r\nburstcnt = get_burstcount(chip);\r\nif (burstcnt < 0)\r\nreturn burstcnt;\r\nif (burstcnt > (len - 1 - count))\r\nburstcnt = len - 1 - count;\r\nrc = iic_tpm_write(TPM_DATA_FIFO(chip->vendor.locality),\r\n&(buf[count]), burstcnt);\r\nif (rc == 0)\r\ncount += burstcnt;\r\nelse if (rc < 0)\r\nretries++;\r\nif (retries > MAX_COUNT_LONG) {\r\nrc = -EIO;\r\ngoto out_err;\r\n}\r\nwait_for_stat(chip, TPM_STS_VALID,\r\nchip->vendor.timeout_c, &status);\r\nif ((status & TPM_STS_DATA_EXPECT) == 0) {\r\nrc = -EIO;\r\ngoto out_err;\r\n}\r\n}\r\niic_tpm_write(TPM_DATA_FIFO(chip->vendor.locality), &(buf[count]), 1);\r\nwait_for_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c, &status);\r\nif ((status & TPM_STS_DATA_EXPECT) != 0) {\r\nrc = -EIO;\r\ngoto out_err;\r\n}\r\niic_tpm_write(TPM_STS(chip->vendor.locality), &sts, 1);\r\nreturn len;\r\nout_err:\r\ntpm_tis_i2c_ready(chip);\r\nusleep_range(SLEEP_DURATION_RESET_LOW, SLEEP_DURATION_RESET_HI);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn rc;\r\n}\r\nstatic bool tpm_tis_i2c_req_canceled(struct tpm_chip *chip, u8 status)\r\n{\r\nreturn (status == TPM_STS_COMMAND_READY);\r\n}\r\nstatic int tpm_tis_i2c_init(struct device *dev)\r\n{\r\nu32 vendor;\r\nint rc = 0;\r\nstruct tpm_chip *chip;\r\nchip = tpm_register_hardware(dev, &tpm_tis_i2c);\r\nif (!chip) {\r\ndev_err(dev, "could not register hardware\n");\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nchip->vendor.irq = 0;\r\nchip->vendor.timeout_a = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\r\nchip->vendor.timeout_b = msecs_to_jiffies(TIS_LONG_TIMEOUT);\r\nchip->vendor.timeout_c = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\r\nchip->vendor.timeout_d = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\r\nif (request_locality(chip, 0) != 0) {\r\ndev_err(dev, "could not request locality\n");\r\nrc = -ENODEV;\r\ngoto out_vendor;\r\n}\r\nif (iic_tpm_read(TPM_DID_VID(0), (u8 *)&vendor, 4) < 0) {\r\ndev_err(dev, "could not read vendor id\n");\r\nrc = -EIO;\r\ngoto out_release;\r\n}\r\nif (vendor == TPM_TIS_I2C_DID_VID_9645) {\r\ntpm_dev.chip_type = SLB9645;\r\n} else if (vendor == TPM_TIS_I2C_DID_VID_9635) {\r\ntpm_dev.chip_type = SLB9635;\r\n} else {\r\ndev_err(dev, "vendor id did not match! ID was %08x\n", vendor);\r\nrc = -ENODEV;\r\ngoto out_release;\r\n}\r\ndev_info(dev, "1.2 TPM (device-id 0x%X)\n", vendor >> 16);\r\nINIT_LIST_HEAD(&chip->vendor.list);\r\ntpm_dev.chip = chip;\r\ntpm_get_timeouts(chip);\r\ntpm_do_selftest(chip);\r\nreturn 0;\r\nout_release:\r\nrelease_locality(chip, chip->vendor.locality, 1);\r\nout_vendor:\r\ntpm_dev_vendor_release(chip);\r\ntpm_remove_hardware(chip->dev);\r\nchip->dev->release = NULL;\r\nchip->release = NULL;\r\ntpm_dev.client = NULL;\r\nout_err:\r\nreturn rc;\r\n}\r\nstatic int tpm_tis_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint rc;\r\nstruct device *dev = &(client->dev);\r\nif (tpm_dev.client != NULL) {\r\ndev_err(dev, "This driver only supports one client at a time\n");\r\nreturn -EBUSY;\r\n}\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(dev, "no algorithms associated to the i2c bus\n");\r\nreturn -ENODEV;\r\n}\r\ntpm_dev.client = client;\r\nrc = tpm_tis_i2c_init(&client->dev);\r\nif (rc != 0) {\r\ntpm_dev.client = NULL;\r\nrc = -ENODEV;\r\n}\r\nreturn rc;\r\n}\r\nstatic int tpm_tis_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct tpm_chip *chip = tpm_dev.chip;\r\nrelease_locality(chip, chip->vendor.locality, 1);\r\ntpm_dev_vendor_release(chip);\r\ntpm_remove_hardware(chip->dev);\r\nchip->dev->release = NULL;\r\nchip->release = NULL;\r\ntpm_dev.client = NULL;\r\nreturn 0;\r\n}
