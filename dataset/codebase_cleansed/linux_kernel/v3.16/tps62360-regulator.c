static bool find_voltage_set_register(struct tps62360_chip *tps,\r\nint req_vsel, int *vset_reg_id)\r\n{\r\nint i;\r\nbool found = false;\r\nint new_vset_reg = tps->lru_index[3];\r\nint found_index = 3;\r\nfor (i = 0; i < 4; ++i) {\r\nif (tps->curr_vset_vsel[tps->lru_index[i]] == req_vsel) {\r\nnew_vset_reg = tps->lru_index[i];\r\nfound_index = i;\r\nfound = true;\r\ngoto update_lru_index;\r\n}\r\n}\r\nupdate_lru_index:\r\nfor (i = found_index; i > 0; i--)\r\ntps->lru_index[i] = tps->lru_index[i - 1];\r\ntps->lru_index[0] = new_vset_reg;\r\n*vset_reg_id = new_vset_reg;\r\nreturn found;\r\n}\r\nstatic int tps62360_dcdc_get_voltage_sel(struct regulator_dev *dev)\r\n{\r\nstruct tps62360_chip *tps = rdev_get_drvdata(dev);\r\nint vsel;\r\nunsigned int data;\r\nint ret;\r\nret = regmap_read(tps->regmap, REG_VSET0 + tps->curr_vset_id, &data);\r\nif (ret < 0) {\r\ndev_err(tps->dev, "%s(): register %d read failed with err %d\n",\r\n__func__, REG_VSET0 + tps->curr_vset_id, ret);\r\nreturn ret;\r\n}\r\nvsel = (int)data & tps->voltage_reg_mask;\r\nreturn vsel;\r\n}\r\nstatic int tps62360_dcdc_set_voltage_sel(struct regulator_dev *dev,\r\nunsigned selector)\r\n{\r\nstruct tps62360_chip *tps = rdev_get_drvdata(dev);\r\nint ret;\r\nbool found = false;\r\nint new_vset_id = tps->curr_vset_id;\r\nif (tps->valid_gpios)\r\nfound = find_voltage_set_register(tps, selector, &new_vset_id);\r\nif (!found) {\r\nret = regmap_update_bits(tps->regmap, REG_VSET0 + new_vset_id,\r\ntps->voltage_reg_mask, selector);\r\nif (ret < 0) {\r\ndev_err(tps->dev,\r\n"%s(): register %d update failed with err %d\n",\r\n__func__, REG_VSET0 + new_vset_id, ret);\r\nreturn ret;\r\n}\r\ntps->curr_vset_id = new_vset_id;\r\ntps->curr_vset_vsel[new_vset_id] = selector;\r\n}\r\nif (tps->valid_gpios) {\r\ngpio_set_value_cansleep(tps->vsel0_gpio, new_vset_id & 0x1);\r\ngpio_set_value_cansleep(tps->vsel1_gpio,\r\n(new_vset_id >> 1) & 0x1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tps62360_set_mode(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nstruct tps62360_chip *tps = rdev_get_drvdata(rdev);\r\nint i;\r\nint val;\r\nint ret;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nval = FORCE_PWM_ENABLE;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!tps->valid_gpios) {\r\nret = regmap_update_bits(tps->regmap,\r\nREG_VSET0 + tps->curr_vset_id, FORCE_PWM_ENABLE, val);\r\nif (ret < 0)\r\ndev_err(tps->dev,\r\n"%s(): register %d update failed with err %d\n",\r\n__func__, REG_VSET0 + tps->curr_vset_id, ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < 4; ++i) {\r\nret = regmap_update_bits(tps->regmap,\r\nREG_VSET0 + i, FORCE_PWM_ENABLE, val);\r\nif (ret < 0) {\r\ndev_err(tps->dev,\r\n"%s(): register %d update failed with err %d\n",\r\n__func__, REG_VSET0 + i, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int tps62360_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct tps62360_chip *tps = rdev_get_drvdata(rdev);\r\nunsigned int data;\r\nint ret;\r\nret = regmap_read(tps->regmap, REG_VSET0 + tps->curr_vset_id, &data);\r\nif (ret < 0) {\r\ndev_err(tps->dev, "%s(): register %d read failed with err %d\n",\r\n__func__, REG_VSET0 + tps->curr_vset_id, ret);\r\nreturn ret;\r\n}\r\nreturn (data & FORCE_PWM_ENABLE) ?\r\nREGULATOR_MODE_FAST : REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int tps62360_init_dcdc(struct tps62360_chip *tps,\r\nstruct tps62360_regulator_platform_data *pdata)\r\n{\r\nint ret;\r\nunsigned int ramp_ctrl;\r\nif (tps->en_internal_pulldn)\r\nret = regmap_write(tps->regmap, REG_CONTROL, 0xE0);\r\nelse\r\nret = regmap_write(tps->regmap, REG_CONTROL, 0x0);\r\nif (ret < 0) {\r\ndev_err(tps->dev,\r\n"%s(): register %d write failed with err %d\n",\r\n__func__, REG_CONTROL, ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(tps->regmap, REG_RAMPCTRL, BIT(2), 0);\r\nif (ret < 0) {\r\ndev_err(tps->dev,\r\n"%s(): register %d update failed with err %d\n",\r\n__func__, REG_RAMPCTRL, ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(tps->regmap, REG_RAMPCTRL, &ramp_ctrl);\r\nif (ret < 0) {\r\ndev_err(tps->dev,\r\n"%s(): register %d read failed with err %d\n",\r\n__func__, REG_RAMPCTRL, ret);\r\nreturn ret;\r\n}\r\nramp_ctrl = (ramp_ctrl >> 5) & 0x7;\r\ntps->desc.ramp_delay = DIV_ROUND_UP(32000, BIT(ramp_ctrl));\r\nreturn ret;\r\n}\r\nstatic struct tps62360_regulator_platform_data *\r\nof_get_tps62360_platform_data(struct device *dev)\r\n{\r\nstruct tps62360_regulator_platform_data *pdata;\r\nstruct device_node *np = dev->of_node;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\npdata->reg_init_data = of_get_regulator_init_data(dev, dev->of_node);\r\nif (!pdata->reg_init_data) {\r\ndev_err(dev, "Not able to get OF regulator init data\n");\r\nreturn NULL;\r\n}\r\npdata->vsel0_gpio = of_get_named_gpio(np, "vsel0-gpio", 0);\r\npdata->vsel1_gpio = of_get_named_gpio(np, "vsel1-gpio", 0);\r\nif (of_find_property(np, "ti,vsel0-state-high", NULL))\r\npdata->vsel0_def_state = 1;\r\nif (of_find_property(np, "ti,vsel1-state-high", NULL))\r\npdata->vsel1_def_state = 1;\r\nif (of_find_property(np, "ti,enable-pull-down", NULL))\r\npdata->en_internal_pulldn = true;\r\nif (of_find_property(np, "ti,enable-vout-discharge", NULL))\r\npdata->en_discharge = true;\r\nreturn pdata;\r\n}\r\nstatic int tps62360_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct regulator_config config = { };\r\nstruct tps62360_regulator_platform_data *pdata;\r\nstruct regulator_dev *rdev;\r\nstruct tps62360_chip *tps;\r\nint ret;\r\nint i;\r\nint chip_id;\r\npdata = dev_get_platdata(&client->dev);\r\nif (client->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(of_match_ptr(tps62360_of_match),\r\n&client->dev);\r\nif (!match) {\r\ndev_err(&client->dev, "Error: No device match found\n");\r\nreturn -ENODEV;\r\n}\r\nchip_id = (int)(long)match->data;\r\nif (!pdata)\r\npdata = of_get_tps62360_platform_data(&client->dev);\r\n} else if (id) {\r\nchip_id = id->driver_data;\r\n} else {\r\ndev_err(&client->dev, "No device tree match or id table match found\n");\r\nreturn -ENODEV;\r\n}\r\nif (!pdata) {\r\ndev_err(&client->dev, "%s(): Platform data not found\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\ntps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);\r\nif (!tps)\r\nreturn -ENOMEM;\r\ntps->en_discharge = pdata->en_discharge;\r\ntps->en_internal_pulldn = pdata->en_internal_pulldn;\r\ntps->vsel0_gpio = pdata->vsel0_gpio;\r\ntps->vsel1_gpio = pdata->vsel1_gpio;\r\ntps->dev = &client->dev;\r\nswitch (chip_id) {\r\ncase TPS62360:\r\ncase TPS62362:\r\ntps->desc.min_uV = TPS62360_BASE_VOLTAGE;\r\ntps->voltage_reg_mask = 0x3F;\r\ntps->desc.n_voltages = TPS62360_N_VOLTAGES;\r\nbreak;\r\ncase TPS62361:\r\ncase TPS62363:\r\ntps->desc.min_uV = TPS62361_BASE_VOLTAGE;\r\ntps->voltage_reg_mask = 0x7F;\r\ntps->desc.n_voltages = TPS62361_N_VOLTAGES;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\ntps->desc.name = client->name;\r\ntps->desc.id = 0;\r\ntps->desc.ops = &tps62360_dcdc_ops;\r\ntps->desc.type = REGULATOR_VOLTAGE;\r\ntps->desc.owner = THIS_MODULE;\r\ntps->desc.uV_step = 10000;\r\ntps->regmap = devm_regmap_init_i2c(client, &tps62360_regmap_config);\r\nif (IS_ERR(tps->regmap)) {\r\nret = PTR_ERR(tps->regmap);\r\ndev_err(&client->dev,\r\n"%s(): regmap allocation failed with err %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(client, tps);\r\ntps->curr_vset_id = (pdata->vsel1_def_state & 1) * 2 +\r\n(pdata->vsel0_def_state & 1);\r\ntps->lru_index[0] = tps->curr_vset_id;\r\ntps->valid_gpios = false;\r\nif (gpio_is_valid(tps->vsel0_gpio) && gpio_is_valid(tps->vsel1_gpio)) {\r\nint gpio_flags;\r\ngpio_flags = (pdata->vsel0_def_state) ?\r\nGPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;\r\nret = devm_gpio_request_one(&client->dev, tps->vsel0_gpio,\r\ngpio_flags, "tps62360-vsel0");\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"%s(): Could not obtain vsel0 GPIO %d: %d\n",\r\n__func__, tps->vsel0_gpio, ret);\r\nreturn ret;\r\n}\r\ngpio_flags = (pdata->vsel1_def_state) ?\r\nGPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;\r\nret = devm_gpio_request_one(&client->dev, tps->vsel1_gpio,\r\ngpio_flags, "tps62360-vsel1");\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"%s(): Could not obtain vsel1 GPIO %d: %d\n",\r\n__func__, tps->vsel1_gpio, ret);\r\nreturn ret;\r\n}\r\ntps->valid_gpios = true;\r\nfor (i = 0; i < 4; ++i)\r\ntps->lru_index[i] = i;\r\ntps->lru_index[0] = tps->curr_vset_id;\r\ntps->lru_index[tps->curr_vset_id] = 0;\r\n}\r\nret = tps62360_init_dcdc(tps, pdata);\r\nif (ret < 0) {\r\ndev_err(tps->dev, "%s(): Init failed with err = %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nconfig.dev = &client->dev;\r\nconfig.init_data = pdata->reg_init_data;\r\nconfig.driver_data = tps;\r\nconfig.of_node = client->dev.of_node;\r\nrdev = devm_regulator_register(&client->dev, &tps->desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(tps->dev,\r\n"%s(): regulator register failed with err %s\n",\r\n__func__, id->name);\r\nreturn PTR_ERR(rdev);\r\n}\r\ntps->rdev = rdev;\r\nreturn 0;\r\n}\r\nstatic void tps62360_shutdown(struct i2c_client *client)\r\n{\r\nstruct tps62360_chip *tps = i2c_get_clientdata(client);\r\nint st;\r\nif (!tps->en_discharge)\r\nreturn;\r\nst = regmap_update_bits(tps->regmap, REG_RAMPCTRL, BIT(2), BIT(2));\r\nif (st < 0)\r\ndev_err(tps->dev,\r\n"%s(): register %d update failed with err %d\n",\r\n__func__, REG_RAMPCTRL, st);\r\n}\r\nstatic int __init tps62360_init(void)\r\n{\r\nreturn i2c_add_driver(&tps62360_i2c_driver);\r\n}\r\nstatic void __exit tps62360_cleanup(void)\r\n{\r\ni2c_del_driver(&tps62360_i2c_driver);\r\n}
