static int tp_field__init_uint(struct tp_field *field,\r\nstruct format_field *format_field,\r\nbool needs_swap)\r\n{\r\nfield->offset = format_field->offset;\r\nswitch (format_field->size) {\r\ncase 1:\r\nfield->integer = tp_field__u8;\r\nbreak;\r\ncase 2:\r\nfield->integer = needs_swap ? tp_field__swapped_u16 : tp_field__u16;\r\nbreak;\r\ncase 4:\r\nfield->integer = needs_swap ? tp_field__swapped_u32 : tp_field__u32;\r\nbreak;\r\ncase 8:\r\nfield->integer = needs_swap ? tp_field__swapped_u64 : tp_field__u64;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void *tp_field__ptr(struct tp_field *field, struct perf_sample *sample)\r\n{\r\nreturn sample->raw_data + field->offset;\r\n}\r\nstatic int tp_field__init_ptr(struct tp_field *field, struct format_field *format_field)\r\n{\r\nfield->offset = format_field->offset;\r\nfield->pointer = tp_field__ptr;\r\nreturn 0;\r\n}\r\nstatic int perf_evsel__init_tp_uint_field(struct perf_evsel *evsel,\r\nstruct tp_field *field,\r\nconst char *name)\r\n{\r\nstruct format_field *format_field = perf_evsel__field(evsel, name);\r\nif (format_field == NULL)\r\nreturn -1;\r\nreturn tp_field__init_uint(field, format_field, evsel->needs_swap);\r\n}\r\nstatic int perf_evsel__init_tp_ptr_field(struct perf_evsel *evsel,\r\nstruct tp_field *field,\r\nconst char *name)\r\n{\r\nstruct format_field *format_field = perf_evsel__field(evsel, name);\r\nif (format_field == NULL)\r\nreturn -1;\r\nreturn tp_field__init_ptr(field, format_field);\r\n}\r\nstatic void perf_evsel__delete_priv(struct perf_evsel *evsel)\r\n{\r\nzfree(&evsel->priv);\r\nperf_evsel__delete(evsel);\r\n}\r\nstatic int perf_evsel__init_syscall_tp(struct perf_evsel *evsel, void *handler)\r\n{\r\nevsel->priv = malloc(sizeof(struct syscall_tp));\r\nif (evsel->priv != NULL) {\r\nif (perf_evsel__init_sc_tp_uint_field(evsel, id))\r\ngoto out_delete;\r\nevsel->handler = handler;\r\nreturn 0;\r\n}\r\nreturn -ENOMEM;\r\nout_delete:\r\nzfree(&evsel->priv);\r\nreturn -ENOENT;\r\n}\r\nstatic struct perf_evsel *perf_evsel__syscall_newtp(const char *direction, void *handler)\r\n{\r\nstruct perf_evsel *evsel = perf_evsel__newtp("raw_syscalls", direction);\r\nif (evsel == NULL)\r\nevsel = perf_evsel__newtp("syscalls", direction);\r\nif (evsel) {\r\nif (perf_evsel__init_syscall_tp(evsel, handler))\r\ngoto out_delete;\r\n}\r\nreturn evsel;\r\nout_delete:\r\nperf_evsel__delete_priv(evsel);\r\nreturn NULL;\r\n}\r\nstatic int perf_evlist__add_syscall_newtp(struct perf_evlist *evlist,\r\nvoid *sys_enter_handler,\r\nvoid *sys_exit_handler)\r\n{\r\nint ret = -1;\r\nstruct perf_evsel *sys_enter, *sys_exit;\r\nsys_enter = perf_evsel__syscall_newtp("sys_enter", sys_enter_handler);\r\nif (sys_enter == NULL)\r\ngoto out;\r\nif (perf_evsel__init_sc_tp_ptr_field(sys_enter, args))\r\ngoto out_delete_sys_enter;\r\nsys_exit = perf_evsel__syscall_newtp("sys_exit", sys_exit_handler);\r\nif (sys_exit == NULL)\r\ngoto out_delete_sys_enter;\r\nif (perf_evsel__init_sc_tp_uint_field(sys_exit, ret))\r\ngoto out_delete_sys_exit;\r\nperf_evlist__add(evlist, sys_enter);\r\nperf_evlist__add(evlist, sys_exit);\r\nret = 0;\r\nout:\r\nreturn ret;\r\nout_delete_sys_exit:\r\nperf_evsel__delete_priv(sys_exit);\r\nout_delete_sys_enter:\r\nperf_evsel__delete_priv(sys_enter);\r\ngoto out;\r\n}\r\nstatic size_t __syscall_arg__scnprintf_strarray(char *bf, size_t size,\r\nconst char *intfmt,\r\nstruct syscall_arg *arg)\r\n{\r\nstruct strarray *sa = arg->parm;\r\nint idx = arg->val - sa->offset;\r\nif (idx < 0 || idx >= sa->nr_entries)\r\nreturn scnprintf(bf, size, intfmt, arg->val);\r\nreturn scnprintf(bf, size, "%s", sa->entries[idx]);\r\n}\r\nstatic size_t syscall_arg__scnprintf_strarray(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nreturn __syscall_arg__scnprintf_strarray(bf, size, "%d", arg);\r\n}\r\nstatic size_t syscall_arg__scnprintf_strhexarray(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nreturn __syscall_arg__scnprintf_strarray(bf, size, "%#x", arg);\r\n}\r\nstatic size_t syscall_arg__scnprintf_fd_at(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nint fd = arg->val;\r\nif (fd == AT_FDCWD)\r\nreturn scnprintf(bf, size, "CWD");\r\nreturn syscall_arg__scnprintf_fd(bf, size, arg);\r\n}\r\nstatic size_t syscall_arg__scnprintf_hex(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nreturn scnprintf(bf, size, "%#lx", arg->val);\r\n}\r\nstatic size_t syscall_arg__scnprintf_mmap_prot(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nint printed = 0, prot = arg->val;\r\nif (prot == PROT_NONE)\r\nreturn scnprintf(bf, size, "NONE");\r\n#define P_MMAP_PROT(n) \\r\nif (prot & PROT_##n) { \\r\nprinted += scnprintf(bf + printed, size - printed, "%s%s", printed ? "|" : "", #n); \\r\nprot &= ~PROT_##n; \\r\n}\r\nP_MMAP_PROT(EXEC);\r\nP_MMAP_PROT(READ);\r\nP_MMAP_PROT(WRITE);\r\n#ifdef PROT_SEM\r\nP_MMAP_PROT(SEM);\r\n#endif\r\nP_MMAP_PROT(GROWSDOWN);\r\nP_MMAP_PROT(GROWSUP);\r\n#undef P_MMAP_PROT\r\nif (prot)\r\nprinted += scnprintf(bf + printed, size - printed, "%s%#x", printed ? "|" : "", prot);\r\nreturn printed;\r\n}\r\nstatic size_t syscall_arg__scnprintf_mmap_flags(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nint printed = 0, flags = arg->val;\r\n#define P_MMAP_FLAG(n) \\r\nif (flags & MAP_##n) { \\r\nprinted += scnprintf(bf + printed, size - printed, "%s%s", printed ? "|" : "", #n); \\r\nflags &= ~MAP_##n; \\r\n}\r\nP_MMAP_FLAG(SHARED);\r\nP_MMAP_FLAG(PRIVATE);\r\n#ifdef MAP_32BIT\r\nP_MMAP_FLAG(32BIT);\r\n#endif\r\nP_MMAP_FLAG(ANONYMOUS);\r\nP_MMAP_FLAG(DENYWRITE);\r\nP_MMAP_FLAG(EXECUTABLE);\r\nP_MMAP_FLAG(FILE);\r\nP_MMAP_FLAG(FIXED);\r\nP_MMAP_FLAG(GROWSDOWN);\r\n#ifdef MAP_HUGETLB\r\nP_MMAP_FLAG(HUGETLB);\r\n#endif\r\nP_MMAP_FLAG(LOCKED);\r\nP_MMAP_FLAG(NONBLOCK);\r\nP_MMAP_FLAG(NORESERVE);\r\nP_MMAP_FLAG(POPULATE);\r\nP_MMAP_FLAG(STACK);\r\n#ifdef MAP_UNINITIALIZED\r\nP_MMAP_FLAG(UNINITIALIZED);\r\n#endif\r\n#undef P_MMAP_FLAG\r\nif (flags)\r\nprinted += scnprintf(bf + printed, size - printed, "%s%#x", printed ? "|" : "", flags);\r\nreturn printed;\r\n}\r\nstatic size_t syscall_arg__scnprintf_madvise_behavior(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nint behavior = arg->val;\r\nswitch (behavior) {\r\n#define P_MADV_BHV(n) case MADV_##n: return scnprintf(bf, size, #n)\r\nP_MADV_BHV(NORMAL);\r\nP_MADV_BHV(RANDOM);\r\nP_MADV_BHV(SEQUENTIAL);\r\nP_MADV_BHV(WILLNEED);\r\nP_MADV_BHV(DONTNEED);\r\nP_MADV_BHV(REMOVE);\r\nP_MADV_BHV(DONTFORK);\r\nP_MADV_BHV(DOFORK);\r\nP_MADV_BHV(HWPOISON);\r\n#ifdef MADV_SOFT_OFFLINE\r\nP_MADV_BHV(SOFT_OFFLINE);\r\n#endif\r\nP_MADV_BHV(MERGEABLE);\r\nP_MADV_BHV(UNMERGEABLE);\r\n#ifdef MADV_HUGEPAGE\r\nP_MADV_BHV(HUGEPAGE);\r\n#endif\r\n#ifdef MADV_NOHUGEPAGE\r\nP_MADV_BHV(NOHUGEPAGE);\r\n#endif\r\n#ifdef MADV_DONTDUMP\r\nP_MADV_BHV(DONTDUMP);\r\n#endif\r\n#ifdef MADV_DODUMP\r\nP_MADV_BHV(DODUMP);\r\n#endif\r\n#undef P_MADV_PHV\r\ndefault: break;\r\n}\r\nreturn scnprintf(bf, size, "%#x", behavior);\r\n}\r\nstatic size_t syscall_arg__scnprintf_flock(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nint printed = 0, op = arg->val;\r\nif (op == 0)\r\nreturn scnprintf(bf, size, "NONE");\r\n#define P_CMD(cmd) \\r\nif ((op & LOCK_##cmd) == LOCK_##cmd) { \\r\nprinted += scnprintf(bf + printed, size - printed, "%s%s", printed ? "|" : "", #cmd); \\r\nop &= ~LOCK_##cmd; \\r\n}\r\nP_CMD(SH);\r\nP_CMD(EX);\r\nP_CMD(NB);\r\nP_CMD(UN);\r\nP_CMD(MAND);\r\nP_CMD(RW);\r\nP_CMD(READ);\r\nP_CMD(WRITE);\r\n#undef P_OP\r\nif (op)\r\nprinted += scnprintf(bf + printed, size - printed, "%s%#x", printed ? "|" : "", op);\r\nreturn printed;\r\n}\r\nstatic size_t syscall_arg__scnprintf_futex_op(char *bf, size_t size, struct syscall_arg *arg)\r\n{\r\nenum syscall_futex_args {\r\nSCF_UADDR = (1 << 0),\r\nSCF_OP = (1 << 1),\r\nSCF_VAL = (1 << 2),\r\nSCF_TIMEOUT = (1 << 3),\r\nSCF_UADDR2 = (1 << 4),\r\nSCF_VAL3 = (1 << 5),\r\n};\r\nint op = arg->val;\r\nint cmd = op & FUTEX_CMD_MASK;\r\nsize_t printed = 0;\r\nswitch (cmd) {\r\n#define P_FUTEX_OP(n) case FUTEX_##n: printed = scnprintf(bf, size, #n);\r\nP_FUTEX_OP(WAIT); arg->mask |= SCF_VAL3|SCF_UADDR2; break;\r\nP_FUTEX_OP(WAKE); arg->mask |= SCF_VAL3|SCF_UADDR2|SCF_TIMEOUT; break;\r\nP_FUTEX_OP(FD); arg->mask |= SCF_VAL3|SCF_UADDR2|SCF_TIMEOUT; break;\r\nP_FUTEX_OP(REQUEUE); arg->mask |= SCF_VAL3|SCF_TIMEOUT; break;\r\nP_FUTEX_OP(CMP_REQUEUE); arg->mask |= SCF_TIMEOUT; break;\r\nP_FUTEX_OP(CMP_REQUEUE_PI); arg->mask |= SCF_TIMEOUT; break;\r\nP_FUTEX_OP(WAKE_OP); break;\r\nP_FUTEX_OP(LOCK_PI); arg->mask |= SCF_VAL3|SCF_UADDR2|SCF_TIMEOUT; break;\r\nP_FUTEX_OP(UNLOCK_PI); arg->mask |= SCF_VAL3|SCF_UADDR2|SCF_TIMEOUT; break;\r\nP_FUTEX_OP(TRYLOCK_PI); arg->mask |= SCF_VAL3|SCF_UADDR2; break;\r\nP_FUTEX_OP(WAIT_BITSET); arg->mask |= SCF_UADDR2; break;\r\nP_FUTEX_OP(WAKE_BITSET); arg->mask |= SCF_UADDR2; break;\r\nP_FUTEX_OP(WAIT_REQUEUE_PI); break;\r\ndefault: printed = scnprintf(bf, size, "%#x", cmd); break;\r\n}\r\nif (op & FUTEX_PRIVATE_FLAG)\r\nprinted += scnprintf(bf + printed, size - printed, "|PRIV");\r\nif (op & FUTEX_CLOCK_REALTIME)\r\nprinted += scnprintf(bf + printed, size - printed, "|CLKRT");\r\nreturn printed;\r\n}\r\nstatic size_t syscall_arg__scnprintf_socket_type(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nsize_t printed;\r\nint type = arg->val,\r\nflags = type & ~SOCK_TYPE_MASK;\r\ntype &= SOCK_TYPE_MASK;\r\nswitch (type) {\r\n#define P_SK_TYPE(n) case SOCK_##n: printed = scnprintf(bf, size, #n); break;\r\nP_SK_TYPE(STREAM);\r\nP_SK_TYPE(DGRAM);\r\nP_SK_TYPE(RAW);\r\nP_SK_TYPE(RDM);\r\nP_SK_TYPE(SEQPACKET);\r\nP_SK_TYPE(DCCP);\r\nP_SK_TYPE(PACKET);\r\n#undef P_SK_TYPE\r\ndefault:\r\nprinted = scnprintf(bf, size, "%#x", type);\r\n}\r\n#define P_SK_FLAG(n) \\r\nif (flags & SOCK_##n) { \\r\nprinted += scnprintf(bf + printed, size - printed, "|%s", #n); \\r\nflags &= ~SOCK_##n; \\r\n}\r\nP_SK_FLAG(CLOEXEC);\r\nP_SK_FLAG(NONBLOCK);\r\n#undef P_SK_FLAG\r\nif (flags)\r\nprinted += scnprintf(bf + printed, size - printed, "|%#x", flags);\r\nreturn printed;\r\n}\r\nstatic size_t syscall_arg__scnprintf_msg_flags(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nint printed = 0, flags = arg->val;\r\nif (flags == 0)\r\nreturn scnprintf(bf, size, "NONE");\r\n#define P_MSG_FLAG(n) \\r\nif (flags & MSG_##n) { \\r\nprinted += scnprintf(bf + printed, size - printed, "%s%s", printed ? "|" : "", #n); \\r\nflags &= ~MSG_##n; \\r\n}\r\nP_MSG_FLAG(OOB);\r\nP_MSG_FLAG(PEEK);\r\nP_MSG_FLAG(DONTROUTE);\r\nP_MSG_FLAG(TRYHARD);\r\nP_MSG_FLAG(CTRUNC);\r\nP_MSG_FLAG(PROBE);\r\nP_MSG_FLAG(TRUNC);\r\nP_MSG_FLAG(DONTWAIT);\r\nP_MSG_FLAG(EOR);\r\nP_MSG_FLAG(WAITALL);\r\nP_MSG_FLAG(FIN);\r\nP_MSG_FLAG(SYN);\r\nP_MSG_FLAG(CONFIRM);\r\nP_MSG_FLAG(RST);\r\nP_MSG_FLAG(ERRQUEUE);\r\nP_MSG_FLAG(NOSIGNAL);\r\nP_MSG_FLAG(MORE);\r\nP_MSG_FLAG(WAITFORONE);\r\nP_MSG_FLAG(SENDPAGE_NOTLAST);\r\nP_MSG_FLAG(FASTOPEN);\r\nP_MSG_FLAG(CMSG_CLOEXEC);\r\n#undef P_MSG_FLAG\r\nif (flags)\r\nprinted += scnprintf(bf + printed, size - printed, "%s%#x", printed ? "|" : "", flags);\r\nreturn printed;\r\n}\r\nstatic size_t syscall_arg__scnprintf_access_mode(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nsize_t printed = 0;\r\nint mode = arg->val;\r\nif (mode == F_OK)\r\nreturn scnprintf(bf, size, "F");\r\n#define P_MODE(n) \\r\nif (mode & n##_OK) { \\r\nprinted += scnprintf(bf + printed, size - printed, "%s", #n); \\r\nmode &= ~n##_OK; \\r\n}\r\nP_MODE(R);\r\nP_MODE(W);\r\nP_MODE(X);\r\n#undef P_MODE\r\nif (mode)\r\nprinted += scnprintf(bf + printed, size - printed, "|%#x", mode);\r\nreturn printed;\r\n}\r\nstatic size_t syscall_arg__scnprintf_open_flags(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nint printed = 0, flags = arg->val;\r\nif (!(flags & O_CREAT))\r\narg->mask |= 1 << (arg->idx + 1);\r\nif (flags == 0)\r\nreturn scnprintf(bf, size, "RDONLY");\r\n#define P_FLAG(n) \\r\nif (flags & O_##n) { \\r\nprinted += scnprintf(bf + printed, size - printed, "%s%s", printed ? "|" : "", #n); \\r\nflags &= ~O_##n; \\r\n}\r\nP_FLAG(APPEND);\r\nP_FLAG(ASYNC);\r\nP_FLAG(CLOEXEC);\r\nP_FLAG(CREAT);\r\nP_FLAG(DIRECT);\r\nP_FLAG(DIRECTORY);\r\nP_FLAG(EXCL);\r\nP_FLAG(LARGEFILE);\r\nP_FLAG(NOATIME);\r\nP_FLAG(NOCTTY);\r\n#ifdef O_NONBLOCK\r\nP_FLAG(NONBLOCK);\r\n#elif O_NDELAY\r\nP_FLAG(NDELAY);\r\n#endif\r\n#ifdef O_PATH\r\nP_FLAG(PATH);\r\n#endif\r\nP_FLAG(RDWR);\r\n#ifdef O_DSYNC\r\nif ((flags & O_SYNC) == O_SYNC)\r\nprinted += scnprintf(bf + printed, size - printed, "%s%s", printed ? "|" : "", "SYNC");\r\nelse {\r\nP_FLAG(DSYNC);\r\n}\r\n#else\r\nP_FLAG(SYNC);\r\n#endif\r\nP_FLAG(TRUNC);\r\nP_FLAG(WRONLY);\r\n#undef P_FLAG\r\nif (flags)\r\nprinted += scnprintf(bf + printed, size - printed, "%s%#x", printed ? "|" : "", flags);\r\nreturn printed;\r\n}\r\nstatic size_t syscall_arg__scnprintf_eventfd_flags(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nint printed = 0, flags = arg->val;\r\nif (flags == 0)\r\nreturn scnprintf(bf, size, "NONE");\r\n#define P_FLAG(n) \\r\nif (flags & EFD_##n) { \\r\nprinted += scnprintf(bf + printed, size - printed, "%s%s", printed ? "|" : "", #n); \\r\nflags &= ~EFD_##n; \\r\n}\r\nP_FLAG(SEMAPHORE);\r\nP_FLAG(CLOEXEC);\r\nP_FLAG(NONBLOCK);\r\n#undef P_FLAG\r\nif (flags)\r\nprinted += scnprintf(bf + printed, size - printed, "%s%#x", printed ? "|" : "", flags);\r\nreturn printed;\r\n}\r\nstatic size_t syscall_arg__scnprintf_pipe_flags(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nint printed = 0, flags = arg->val;\r\n#define P_FLAG(n) \\r\nif (flags & O_##n) { \\r\nprinted += scnprintf(bf + printed, size - printed, "%s%s", printed ? "|" : "", #n); \\r\nflags &= ~O_##n; \\r\n}\r\nP_FLAG(CLOEXEC);\r\nP_FLAG(NONBLOCK);\r\n#undef P_FLAG\r\nif (flags)\r\nprinted += scnprintf(bf + printed, size - printed, "%s%#x", printed ? "|" : "", flags);\r\nreturn printed;\r\n}\r\nstatic size_t syscall_arg__scnprintf_signum(char *bf, size_t size, struct syscall_arg *arg)\r\n{\r\nint sig = arg->val;\r\nswitch (sig) {\r\n#define P_SIGNUM(n) case SIG##n: return scnprintf(bf, size, #n)\r\nP_SIGNUM(HUP);\r\nP_SIGNUM(INT);\r\nP_SIGNUM(QUIT);\r\nP_SIGNUM(ILL);\r\nP_SIGNUM(TRAP);\r\nP_SIGNUM(ABRT);\r\nP_SIGNUM(BUS);\r\nP_SIGNUM(FPE);\r\nP_SIGNUM(KILL);\r\nP_SIGNUM(USR1);\r\nP_SIGNUM(SEGV);\r\nP_SIGNUM(USR2);\r\nP_SIGNUM(PIPE);\r\nP_SIGNUM(ALRM);\r\nP_SIGNUM(TERM);\r\nP_SIGNUM(CHLD);\r\nP_SIGNUM(CONT);\r\nP_SIGNUM(STOP);\r\nP_SIGNUM(TSTP);\r\nP_SIGNUM(TTIN);\r\nP_SIGNUM(TTOU);\r\nP_SIGNUM(URG);\r\nP_SIGNUM(XCPU);\r\nP_SIGNUM(XFSZ);\r\nP_SIGNUM(VTALRM);\r\nP_SIGNUM(PROF);\r\nP_SIGNUM(WINCH);\r\nP_SIGNUM(IO);\r\nP_SIGNUM(PWR);\r\nP_SIGNUM(SYS);\r\n#ifdef SIGEMT\r\nP_SIGNUM(EMT);\r\n#endif\r\n#ifdef SIGSTKFLT\r\nP_SIGNUM(STKFLT);\r\n#endif\r\n#ifdef SIGSWI\r\nP_SIGNUM(SWI);\r\n#endif\r\ndefault: break;\r\n}\r\nreturn scnprintf(bf, size, "%#x", sig);\r\n}\r\nstatic int syscall_fmt__cmp(const void *name, const void *fmtp)\r\n{\r\nconst struct syscall_fmt *fmt = fmtp;\r\nreturn strcmp(name, fmt->name);\r\n}\r\nstatic struct syscall_fmt *syscall_fmt__find(const char *name)\r\n{\r\nconst int nmemb = ARRAY_SIZE(syscall_fmts);\r\nreturn bsearch(name, syscall_fmts, nmemb, sizeof(struct syscall_fmt), syscall_fmt__cmp);\r\n}\r\nstatic size_t fprintf_duration(unsigned long t, FILE *fp)\r\n{\r\ndouble duration = (double)t / NSEC_PER_MSEC;\r\nsize_t printed = fprintf(fp, "(");\r\nif (duration >= 1.0)\r\nprinted += color_fprintf(fp, PERF_COLOR_RED, "%6.3f ms", duration);\r\nelse if (duration >= 0.01)\r\nprinted += color_fprintf(fp, PERF_COLOR_YELLOW, "%6.3f ms", duration);\r\nelse\r\nprinted += color_fprintf(fp, PERF_COLOR_NORMAL, "%6.3f ms", duration);\r\nreturn printed + fprintf(fp, "): ");\r\n}\r\nstatic struct thread_trace *thread_trace__new(void)\r\n{\r\nstruct thread_trace *ttrace = zalloc(sizeof(struct thread_trace));\r\nif (ttrace)\r\nttrace->paths.max = -1;\r\nttrace->syscall_stats = intlist__new(NULL);\r\nreturn ttrace;\r\n}\r\nstatic struct thread_trace *thread__trace(struct thread *thread, FILE *fp)\r\n{\r\nstruct thread_trace *ttrace;\r\nif (thread == NULL)\r\ngoto fail;\r\nif (thread->priv == NULL)\r\nthread->priv = thread_trace__new();\r\nif (thread->priv == NULL)\r\ngoto fail;\r\nttrace = thread->priv;\r\n++ttrace->nr_events;\r\nreturn ttrace;\r\nfail:\r\ncolor_fprintf(fp, PERF_COLOR_RED,\r\n"WARNING: not enough memory, dropping samples!\n");\r\nreturn NULL;\r\n}\r\nstatic int trace__set_fd_pathname(struct thread *thread, int fd, const char *pathname)\r\n{\r\nstruct thread_trace *ttrace = thread->priv;\r\nif (fd > ttrace->paths.max) {\r\nchar **npath = realloc(ttrace->paths.table, (fd + 1) * sizeof(char *));\r\nif (npath == NULL)\r\nreturn -1;\r\nif (ttrace->paths.max != -1) {\r\nmemset(npath + ttrace->paths.max + 1, 0,\r\n(fd - ttrace->paths.max) * sizeof(char *));\r\n} else {\r\nmemset(npath, 0, (fd + 1) * sizeof(char *));\r\n}\r\nttrace->paths.table = npath;\r\nttrace->paths.max = fd;\r\n}\r\nttrace->paths.table[fd] = strdup(pathname);\r\nreturn ttrace->paths.table[fd] != NULL ? 0 : -1;\r\n}\r\nstatic int thread__read_fd_path(struct thread *thread, int fd)\r\n{\r\nchar linkname[PATH_MAX], pathname[PATH_MAX];\r\nstruct stat st;\r\nint ret;\r\nif (thread->pid_ == thread->tid) {\r\nscnprintf(linkname, sizeof(linkname),\r\n"/proc/%d/fd/%d", thread->pid_, fd);\r\n} else {\r\nscnprintf(linkname, sizeof(linkname),\r\n"/proc/%d/task/%d/fd/%d", thread->pid_, thread->tid, fd);\r\n}\r\nif (lstat(linkname, &st) < 0 || st.st_size + 1 > (off_t)sizeof(pathname))\r\nreturn -1;\r\nret = readlink(linkname, pathname, sizeof(pathname));\r\nif (ret < 0 || ret > st.st_size)\r\nreturn -1;\r\npathname[ret] = '\0';\r\nreturn trace__set_fd_pathname(thread, fd, pathname);\r\n}\r\nstatic const char *thread__fd_path(struct thread *thread, int fd,\r\nstruct trace *trace)\r\n{\r\nstruct thread_trace *ttrace = thread->priv;\r\nif (ttrace == NULL)\r\nreturn NULL;\r\nif (fd < 0)\r\nreturn NULL;\r\nif ((fd > ttrace->paths.max || ttrace->paths.table[fd] == NULL))\r\nif (!trace->live)\r\nreturn NULL;\r\n++trace->stats.proc_getname;\r\nif (thread__read_fd_path(thread, fd)) {\r\nreturn NULL;\r\n}\r\nreturn ttrace->paths.table[fd];\r\n}\r\nstatic size_t syscall_arg__scnprintf_fd(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nint fd = arg->val;\r\nsize_t printed = scnprintf(bf, size, "%d", fd);\r\nconst char *path = thread__fd_path(arg->thread, fd, arg->trace);\r\nif (path)\r\nprinted += scnprintf(bf + printed, size - printed, "<%s>", path);\r\nreturn printed;\r\n}\r\nstatic size_t syscall_arg__scnprintf_close_fd(char *bf, size_t size,\r\nstruct syscall_arg *arg)\r\n{\r\nint fd = arg->val;\r\nsize_t printed = syscall_arg__scnprintf_fd(bf, size, arg);\r\nstruct thread_trace *ttrace = arg->thread->priv;\r\nif (ttrace && fd >= 0 && fd <= ttrace->paths.max)\r\nzfree(&ttrace->paths.table[fd]);\r\nreturn printed;\r\n}\r\nstatic bool trace__filter_duration(struct trace *trace, double t)\r\n{\r\nreturn t < (trace->duration_filter * NSEC_PER_MSEC);\r\n}\r\nstatic size_t trace__fprintf_tstamp(struct trace *trace, u64 tstamp, FILE *fp)\r\n{\r\ndouble ts = (double)(tstamp - trace->base_time) / NSEC_PER_MSEC;\r\nreturn fprintf(fp, "%10.3f ", ts);\r\n}\r\nstatic void sig_handler(int sig)\r\n{\r\ndone = true;\r\ninterrupted = sig == SIGINT;\r\n}\r\nstatic size_t trace__fprintf_entry_head(struct trace *trace, struct thread *thread,\r\nu64 duration, u64 tstamp, FILE *fp)\r\n{\r\nsize_t printed = trace__fprintf_tstamp(trace, tstamp, fp);\r\nprinted += fprintf_duration(duration, fp);\r\nif (trace->multiple_threads) {\r\nif (trace->show_comm)\r\nprinted += fprintf(fp, "%.14s/", thread__comm_str(thread));\r\nprinted += fprintf(fp, "%d ", thread->tid);\r\n}\r\nreturn printed;\r\n}\r\nstatic int trace__process_event(struct trace *trace, struct machine *machine,\r\nunion perf_event *event, struct perf_sample *sample)\r\n{\r\nint ret = 0;\r\nswitch (event->header.type) {\r\ncase PERF_RECORD_LOST:\r\ncolor_fprintf(trace->output, PERF_COLOR_RED,\r\n"LOST %" PRIu64 " events!\n", event->lost.lost);\r\nret = machine__process_lost_event(machine, event, sample);\r\ndefault:\r\nret = machine__process_event(machine, event, sample);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int trace__tool_process(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nstruct trace *trace = container_of(tool, struct trace, tool);\r\nreturn trace__process_event(trace, machine, event, sample);\r\n}\r\nstatic int trace__symbols_init(struct trace *trace, struct perf_evlist *evlist)\r\n{\r\nint err = symbol__init();\r\nif (err)\r\nreturn err;\r\ntrace->host = machine__new_host();\r\nif (trace->host == NULL)\r\nreturn -ENOMEM;\r\nerr = __machine__synthesize_threads(trace->host, &trace->tool, &trace->opts.target,\r\nevlist->threads, trace__tool_process, false);\r\nif (err)\r\nsymbol__exit();\r\nreturn err;\r\n}\r\nstatic int syscall__set_arg_fmts(struct syscall *sc)\r\n{\r\nstruct format_field *field;\r\nint idx = 0;\r\nsc->arg_scnprintf = calloc(sc->tp_format->format.nr_fields - 1, sizeof(void *));\r\nif (sc->arg_scnprintf == NULL)\r\nreturn -1;\r\nif (sc->fmt)\r\nsc->arg_parm = sc->fmt->arg_parm;\r\nfor (field = sc->tp_format->format.fields->next; field; field = field->next) {\r\nif (sc->fmt && sc->fmt->arg_scnprintf[idx])\r\nsc->arg_scnprintf[idx] = sc->fmt->arg_scnprintf[idx];\r\nelse if (field->flags & FIELD_IS_POINTER)\r\nsc->arg_scnprintf[idx] = syscall_arg__scnprintf_hex;\r\n++idx;\r\n}\r\nreturn 0;\r\n}\r\nstatic int trace__read_syscall_info(struct trace *trace, int id)\r\n{\r\nchar tp_name[128];\r\nstruct syscall *sc;\r\nconst char *name = audit_syscall_to_name(id, trace->audit.machine);\r\nif (name == NULL)\r\nreturn -1;\r\nif (id > trace->syscalls.max) {\r\nstruct syscall *nsyscalls = realloc(trace->syscalls.table, (id + 1) * sizeof(*sc));\r\nif (nsyscalls == NULL)\r\nreturn -1;\r\nif (trace->syscalls.max != -1) {\r\nmemset(nsyscalls + trace->syscalls.max + 1, 0,\r\n(id - trace->syscalls.max) * sizeof(*sc));\r\n} else {\r\nmemset(nsyscalls, 0, (id + 1) * sizeof(*sc));\r\n}\r\ntrace->syscalls.table = nsyscalls;\r\ntrace->syscalls.max = id;\r\n}\r\nsc = trace->syscalls.table + id;\r\nsc->name = name;\r\nif (trace->ev_qualifier) {\r\nbool in = strlist__find(trace->ev_qualifier, name) != NULL;\r\nif (!(in ^ trace->not_ev_qualifier)) {\r\nsc->filtered = true;\r\nreturn 0;\r\n}\r\n}\r\nsc->fmt = syscall_fmt__find(sc->name);\r\nsnprintf(tp_name, sizeof(tp_name), "sys_enter_%s", sc->name);\r\nsc->tp_format = trace_event__tp_format("syscalls", tp_name);\r\nif (sc->tp_format == NULL && sc->fmt && sc->fmt->alias) {\r\nsnprintf(tp_name, sizeof(tp_name), "sys_enter_%s", sc->fmt->alias);\r\nsc->tp_format = trace_event__tp_format("syscalls", tp_name);\r\n}\r\nif (sc->tp_format == NULL)\r\nreturn -1;\r\nreturn syscall__set_arg_fmts(sc);\r\n}\r\nstatic size_t syscall__scnprintf_args(struct syscall *sc, char *bf, size_t size,\r\nunsigned long *args, struct trace *trace,\r\nstruct thread *thread)\r\n{\r\nsize_t printed = 0;\r\nif (sc->tp_format != NULL) {\r\nstruct format_field *field;\r\nu8 bit = 1;\r\nstruct syscall_arg arg = {\r\n.idx = 0,\r\n.mask = 0,\r\n.trace = trace,\r\n.thread = thread,\r\n};\r\nfor (field = sc->tp_format->format.fields->next; field;\r\nfield = field->next, ++arg.idx, bit <<= 1) {\r\nif (arg.mask & bit)\r\ncontinue;\r\nif (args[arg.idx] == 0 &&\r\n!(sc->arg_scnprintf &&\r\nsc->arg_scnprintf[arg.idx] == SCA_STRARRAY &&\r\nsc->arg_parm[arg.idx]))\r\ncontinue;\r\nprinted += scnprintf(bf + printed, size - printed,\r\n"%s%s: ", printed ? ", " : "", field->name);\r\nif (sc->arg_scnprintf && sc->arg_scnprintf[arg.idx]) {\r\narg.val = args[arg.idx];\r\nif (sc->arg_parm)\r\narg.parm = sc->arg_parm[arg.idx];\r\nprinted += sc->arg_scnprintf[arg.idx](bf + printed,\r\nsize - printed, &arg);\r\n} else {\r\nprinted += scnprintf(bf + printed, size - printed,\r\n"%ld", args[arg.idx]);\r\n}\r\n}\r\n} else {\r\nint i = 0;\r\nwhile (i < 6) {\r\nprinted += scnprintf(bf + printed, size - printed,\r\n"%sarg%d: %ld",\r\nprinted ? ", " : "", i, args[i]);\r\n++i;\r\n}\r\n}\r\nreturn printed;\r\n}\r\nstatic struct syscall *trace__syscall_info(struct trace *trace,\r\nstruct perf_evsel *evsel, int id)\r\n{\r\nif (id < 0) {\r\nif (verbose > 1) {\r\nstatic u64 n;\r\nfprintf(trace->output, "Invalid syscall %d id, skipping (%s, %" PRIu64 ") ...\n",\r\nid, perf_evsel__name(evsel), ++n);\r\n}\r\nreturn NULL;\r\n}\r\nif ((id > trace->syscalls.max || trace->syscalls.table[id].name == NULL) &&\r\ntrace__read_syscall_info(trace, id))\r\ngoto out_cant_read;\r\nif ((id > trace->syscalls.max || trace->syscalls.table[id].name == NULL))\r\ngoto out_cant_read;\r\nreturn &trace->syscalls.table[id];\r\nout_cant_read:\r\nif (verbose) {\r\nfprintf(trace->output, "Problems reading syscall %d", id);\r\nif (id <= trace->syscalls.max && trace->syscalls.table[id].name != NULL)\r\nfprintf(trace->output, "(%s)", trace->syscalls.table[id].name);\r\nfputs(" information\n", trace->output);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void thread__update_stats(struct thread_trace *ttrace,\r\nint id, struct perf_sample *sample)\r\n{\r\nstruct int_node *inode;\r\nstruct stats *stats;\r\nu64 duration = 0;\r\ninode = intlist__findnew(ttrace->syscall_stats, id);\r\nif (inode == NULL)\r\nreturn;\r\nstats = inode->priv;\r\nif (stats == NULL) {\r\nstats = malloc(sizeof(struct stats));\r\nif (stats == NULL)\r\nreturn;\r\ninit_stats(stats);\r\ninode->priv = stats;\r\n}\r\nif (ttrace->entry_time && sample->time > ttrace->entry_time)\r\nduration = sample->time - ttrace->entry_time;\r\nupdate_stats(stats, duration);\r\n}\r\nstatic int trace__sys_enter(struct trace *trace, struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nchar *msg;\r\nvoid *args;\r\nsize_t printed = 0;\r\nstruct thread *thread;\r\nint id = perf_evsel__sc_tp_uint(evsel, id, sample);\r\nstruct syscall *sc = trace__syscall_info(trace, evsel, id);\r\nstruct thread_trace *ttrace;\r\nif (sc == NULL)\r\nreturn -1;\r\nif (sc->filtered)\r\nreturn 0;\r\nthread = machine__findnew_thread(trace->host, sample->pid, sample->tid);\r\nttrace = thread__trace(thread, trace->output);\r\nif (ttrace == NULL)\r\nreturn -1;\r\nargs = perf_evsel__sc_tp_ptr(evsel, args, sample);\r\nttrace = thread->priv;\r\nif (ttrace->entry_str == NULL) {\r\nttrace->entry_str = malloc(1024);\r\nif (!ttrace->entry_str)\r\nreturn -1;\r\n}\r\nttrace->entry_time = sample->time;\r\nmsg = ttrace->entry_str;\r\nprinted += scnprintf(msg + printed, 1024 - printed, "%s(", sc->name);\r\nprinted += syscall__scnprintf_args(sc, msg + printed, 1024 - printed,\r\nargs, trace, thread);\r\nif (!strcmp(sc->name, "exit_group") || !strcmp(sc->name, "exit")) {\r\nif (!trace->duration_filter && !trace->summary_only) {\r\ntrace__fprintf_entry_head(trace, thread, 1, sample->time, trace->output);\r\nfprintf(trace->output, "%-70s\n", ttrace->entry_str);\r\n}\r\n} else\r\nttrace->entry_pending = true;\r\nreturn 0;\r\n}\r\nstatic int trace__sys_exit(struct trace *trace, struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nint ret;\r\nu64 duration = 0;\r\nstruct thread *thread;\r\nint id = perf_evsel__sc_tp_uint(evsel, id, sample);\r\nstruct syscall *sc = trace__syscall_info(trace, evsel, id);\r\nstruct thread_trace *ttrace;\r\nif (sc == NULL)\r\nreturn -1;\r\nif (sc->filtered)\r\nreturn 0;\r\nthread = machine__findnew_thread(trace->host, sample->pid, sample->tid);\r\nttrace = thread__trace(thread, trace->output);\r\nif (ttrace == NULL)\r\nreturn -1;\r\nif (trace->summary)\r\nthread__update_stats(ttrace, id, sample);\r\nret = perf_evsel__sc_tp_uint(evsel, ret, sample);\r\nif (id == trace->audit.open_id && ret >= 0 && trace->last_vfs_getname) {\r\ntrace__set_fd_pathname(thread, ret, trace->last_vfs_getname);\r\ntrace->last_vfs_getname = NULL;\r\n++trace->stats.vfs_getname;\r\n}\r\nttrace = thread->priv;\r\nttrace->exit_time = sample->time;\r\nif (ttrace->entry_time) {\r\nduration = sample->time - ttrace->entry_time;\r\nif (trace__filter_duration(trace, duration))\r\ngoto out;\r\n} else if (trace->duration_filter)\r\ngoto out;\r\nif (trace->summary_only)\r\ngoto out;\r\ntrace__fprintf_entry_head(trace, thread, duration, sample->time, trace->output);\r\nif (ttrace->entry_pending) {\r\nfprintf(trace->output, "%-70s", ttrace->entry_str);\r\n} else {\r\nfprintf(trace->output, " ... [");\r\ncolor_fprintf(trace->output, PERF_COLOR_YELLOW, "continued");\r\nfprintf(trace->output, "]: %s()", sc->name);\r\n}\r\nif (sc->fmt == NULL) {\r\nsigned_print:\r\nfprintf(trace->output, ") = %d", ret);\r\n} else if (ret < 0 && sc->fmt->errmsg) {\r\nchar bf[256];\r\nconst char *emsg = strerror_r(-ret, bf, sizeof(bf)),\r\n*e = audit_errno_to_name(-ret);\r\nfprintf(trace->output, ") = -1 %s %s", e, emsg);\r\n} else if (ret == 0 && sc->fmt->timeout)\r\nfprintf(trace->output, ") = 0 Timeout");\r\nelse if (sc->fmt->hexret)\r\nfprintf(trace->output, ") = %#x", ret);\r\nelse\r\ngoto signed_print;\r\nfputc('\n', trace->output);\r\nout:\r\nttrace->entry_pending = false;\r\nreturn 0;\r\n}\r\nstatic int trace__vfs_getname(struct trace *trace, struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\ntrace->last_vfs_getname = perf_evsel__rawptr(evsel, sample, "pathname");\r\nreturn 0;\r\n}\r\nstatic int trace__sched_stat_runtime(struct trace *trace, struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nu64 runtime = perf_evsel__intval(evsel, sample, "runtime");\r\ndouble runtime_ms = (double)runtime / NSEC_PER_MSEC;\r\nstruct thread *thread = machine__findnew_thread(trace->host,\r\nsample->pid,\r\nsample->tid);\r\nstruct thread_trace *ttrace = thread__trace(thread, trace->output);\r\nif (ttrace == NULL)\r\ngoto out_dump;\r\nttrace->runtime_ms += runtime_ms;\r\ntrace->runtime_ms += runtime_ms;\r\nreturn 0;\r\nout_dump:\r\nfprintf(trace->output, "%s: comm=%s,pid=%u,runtime=%" PRIu64 ",vruntime=%" PRIu64 ")\n",\r\nevsel->name,\r\nperf_evsel__strval(evsel, sample, "comm"),\r\n(pid_t)perf_evsel__intval(evsel, sample, "pid"),\r\nruntime,\r\nperf_evsel__intval(evsel, sample, "vruntime"));\r\nreturn 0;\r\n}\r\nstatic bool skip_sample(struct trace *trace, struct perf_sample *sample)\r\n{\r\nif ((trace->pid_list && intlist__find(trace->pid_list, sample->pid)) ||\r\n(trace->tid_list && intlist__find(trace->tid_list, sample->tid)))\r\nreturn false;\r\nif (trace->pid_list || trace->tid_list)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int trace__process_sample(struct perf_tool *tool,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nstruct trace *trace = container_of(tool, struct trace, tool);\r\nint err = 0;\r\ntracepoint_handler handler = evsel->handler;\r\nif (skip_sample(trace, sample))\r\nreturn 0;\r\nif (!trace->full_time && trace->base_time == 0)\r\ntrace->base_time = sample->time;\r\nif (handler) {\r\n++trace->nr_events;\r\nhandler(trace, evsel, sample);\r\n}\r\nreturn err;\r\n}\r\nstatic int parse_target_str(struct trace *trace)\r\n{\r\nif (trace->opts.target.pid) {\r\ntrace->pid_list = intlist__new(trace->opts.target.pid);\r\nif (trace->pid_list == NULL) {\r\npr_err("Error parsing process id string\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (trace->opts.target.tid) {\r\ntrace->tid_list = intlist__new(trace->opts.target.tid);\r\nif (trace->tid_list == NULL) {\r\npr_err("Error parsing thread id string\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int trace__record(int argc, const char **argv)\r\n{\r\nunsigned int rec_argc, i, j;\r\nconst char **rec_argv;\r\nconst char * const record_args[] = {\r\n"record",\r\n"-R",\r\n"-m", "1024",\r\n"-c", "1",\r\n"-e",\r\n};\r\nrec_argc = ARRAY_SIZE(record_args) + 1 + argc;\r\nrec_argv = calloc(rec_argc + 1, sizeof(char *));\r\nif (rec_argv == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(record_args); i++)\r\nrec_argv[i] = record_args[i];\r\nif (is_valid_tracepoint("raw_syscalls:sys_enter"))\r\nrec_argv[i] = "raw_syscalls:sys_enter,raw_syscalls:sys_exit";\r\nelse if (is_valid_tracepoint("syscalls:sys_enter"))\r\nrec_argv[i] = "syscalls:sys_enter,syscalls:sys_exit";\r\nelse {\r\npr_err("Neither raw_syscalls nor syscalls events exist.\n");\r\nreturn -1;\r\n}\r\ni++;\r\nfor (j = 0; j < (unsigned int)argc; j++, i++)\r\nrec_argv[i] = argv[j];\r\nreturn cmd_record(i, rec_argv, NULL);\r\n}\r\nstatic void perf_evlist__add_vfs_getname(struct perf_evlist *evlist)\r\n{\r\nstruct perf_evsel *evsel = perf_evsel__newtp("probe", "vfs_getname");\r\nif (evsel == NULL)\r\nreturn;\r\nif (perf_evsel__field(evsel, "pathname") == NULL) {\r\nperf_evsel__delete(evsel);\r\nreturn;\r\n}\r\nevsel->handler = trace__vfs_getname;\r\nperf_evlist__add(evlist, evsel);\r\n}\r\nstatic int trace__run(struct trace *trace, int argc, const char **argv)\r\n{\r\nstruct perf_evlist *evlist = perf_evlist__new();\r\nstruct perf_evsel *evsel;\r\nint err = -1, i;\r\nunsigned long before;\r\nconst bool forks = argc > 0;\r\ntrace->live = true;\r\nif (evlist == NULL) {\r\nfprintf(trace->output, "Not enough memory to run!\n");\r\ngoto out;\r\n}\r\nif (perf_evlist__add_syscall_newtp(evlist, trace__sys_enter, trace__sys_exit))\r\ngoto out_error_tp;\r\nperf_evlist__add_vfs_getname(evlist);\r\nif (trace->sched &&\r\nperf_evlist__add_newtp(evlist, "sched", "sched_stat_runtime",\r\ntrace__sched_stat_runtime))\r\ngoto out_error_tp;\r\nerr = perf_evlist__create_maps(evlist, &trace->opts.target);\r\nif (err < 0) {\r\nfprintf(trace->output, "Problems parsing the target to trace, check your options!\n");\r\ngoto out_delete_evlist;\r\n}\r\nerr = trace__symbols_init(trace, evlist);\r\nif (err < 0) {\r\nfprintf(trace->output, "Problems initializing symbol libraries!\n");\r\ngoto out_delete_evlist;\r\n}\r\nperf_evlist__config(evlist, &trace->opts);\r\nsignal(SIGCHLD, sig_handler);\r\nsignal(SIGINT, sig_handler);\r\nif (forks) {\r\nerr = perf_evlist__prepare_workload(evlist, &trace->opts.target,\r\nargv, false, NULL);\r\nif (err < 0) {\r\nfprintf(trace->output, "Couldn't run the workload!\n");\r\ngoto out_delete_evlist;\r\n}\r\n}\r\nerr = perf_evlist__open(evlist);\r\nif (err < 0)\r\ngoto out_error_open;\r\nerr = perf_evlist__mmap(evlist, trace->opts.mmap_pages, false);\r\nif (err < 0) {\r\nfprintf(trace->output, "Couldn't mmap the events: %s\n", strerror(errno));\r\ngoto out_delete_evlist;\r\n}\r\nperf_evlist__enable(evlist);\r\nif (forks)\r\nperf_evlist__start_workload(evlist);\r\ntrace->multiple_threads = evlist->threads->map[0] == -1 || evlist->threads->nr > 1;\r\nagain:\r\nbefore = trace->nr_events;\r\nfor (i = 0; i < evlist->nr_mmaps; i++) {\r\nunion perf_event *event;\r\nwhile ((event = perf_evlist__mmap_read(evlist, i)) != NULL) {\r\nconst u32 type = event->header.type;\r\ntracepoint_handler handler;\r\nstruct perf_sample sample;\r\n++trace->nr_events;\r\nerr = perf_evlist__parse_sample(evlist, event, &sample);\r\nif (err) {\r\nfprintf(trace->output, "Can't parse sample, err = %d, skipping...\n", err);\r\ngoto next_event;\r\n}\r\nif (!trace->full_time && trace->base_time == 0)\r\ntrace->base_time = sample.time;\r\nif (type != PERF_RECORD_SAMPLE) {\r\ntrace__process_event(trace, trace->host, event, &sample);\r\ncontinue;\r\n}\r\nevsel = perf_evlist__id2evsel(evlist, sample.id);\r\nif (evsel == NULL) {\r\nfprintf(trace->output, "Unknown tp ID %" PRIu64 ", skipping...\n", sample.id);\r\ngoto next_event;\r\n}\r\nif (sample.raw_data == NULL) {\r\nfprintf(trace->output, "%s sample with no payload for tid: %d, cpu %d, raw_size=%d, skipping...\n",\r\nperf_evsel__name(evsel), sample.tid,\r\nsample.cpu, sample.raw_size);\r\ngoto next_event;\r\n}\r\nhandler = evsel->handler;\r\nhandler(trace, evsel, &sample);\r\nnext_event:\r\nperf_evlist__mmap_consume(evlist, i);\r\nif (interrupted)\r\ngoto out_disable;\r\n}\r\n}\r\nif (trace->nr_events == before) {\r\nint timeout = done ? 100 : -1;\r\nif (poll(evlist->pollfd, evlist->nr_fds, timeout) > 0)\r\ngoto again;\r\n} else {\r\ngoto again;\r\n}\r\nout_disable:\r\nperf_evlist__disable(evlist);\r\nif (!err) {\r\nif (trace->summary)\r\ntrace__fprintf_thread_summary(trace, trace->output);\r\nif (trace->show_tool_stats) {\r\nfprintf(trace->output, "Stats:\n "\r\n" vfs_getname : %" PRIu64 "\n"\r\n" proc_getname: %" PRIu64 "\n",\r\ntrace->stats.vfs_getname,\r\ntrace->stats.proc_getname);\r\n}\r\n}\r\nout_delete_evlist:\r\nperf_evlist__delete(evlist);\r\nout:\r\ntrace->live = false;\r\nreturn err;\r\n{\r\nchar errbuf[BUFSIZ];\r\nout_error_tp:\r\nperf_evlist__strerror_tp(evlist, errno, errbuf, sizeof(errbuf));\r\ngoto out_error;\r\nout_error_open:\r\nperf_evlist__strerror_open(evlist, errno, errbuf, sizeof(errbuf));\r\nout_error:\r\nfprintf(trace->output, "%s\n", errbuf);\r\ngoto out_delete_evlist;\r\n}\r\n}\r\nstatic int trace__replay(struct trace *trace)\r\n{\r\nconst struct perf_evsel_str_handler handlers[] = {\r\n{ "probe:vfs_getname", trace__vfs_getname, },\r\n};\r\nstruct perf_data_file file = {\r\n.path = input_name,\r\n.mode = PERF_DATA_MODE_READ,\r\n};\r\nstruct perf_session *session;\r\nstruct perf_evsel *evsel;\r\nint err = -1;\r\ntrace->tool.sample = trace__process_sample;\r\ntrace->tool.mmap = perf_event__process_mmap;\r\ntrace->tool.mmap2 = perf_event__process_mmap2;\r\ntrace->tool.comm = perf_event__process_comm;\r\ntrace->tool.exit = perf_event__process_exit;\r\ntrace->tool.fork = perf_event__process_fork;\r\ntrace->tool.attr = perf_event__process_attr;\r\ntrace->tool.tracing_data = perf_event__process_tracing_data;\r\ntrace->tool.build_id = perf_event__process_build_id;\r\ntrace->tool.ordered_samples = true;\r\ntrace->tool.ordering_requires_timestamps = true;\r\ntrace->multiple_threads = true;\r\nif (symbol__init() < 0)\r\nreturn -1;\r\nsession = perf_session__new(&file, false, &trace->tool);\r\nif (session == NULL)\r\nreturn -ENOMEM;\r\ntrace->host = &session->machines.host;\r\nerr = perf_session__set_tracepoints_handlers(session, handlers);\r\nif (err)\r\ngoto out;\r\nevsel = perf_evlist__find_tracepoint_by_name(session->evlist,\r\n"raw_syscalls:sys_enter");\r\nif (evsel == NULL)\r\nevsel = perf_evlist__find_tracepoint_by_name(session->evlist,\r\n"syscalls:sys_enter");\r\nif (evsel == NULL) {\r\npr_err("Data file does not have raw_syscalls:sys_enter event\n");\r\ngoto out;\r\n}\r\nif (perf_evsel__init_syscall_tp(evsel, trace__sys_enter) < 0 ||\r\nperf_evsel__init_sc_tp_ptr_field(evsel, args)) {\r\npr_err("Error during initialize raw_syscalls:sys_enter event\n");\r\ngoto out;\r\n}\r\nevsel = perf_evlist__find_tracepoint_by_name(session->evlist,\r\n"raw_syscalls:sys_exit");\r\nif (evsel == NULL)\r\nevsel = perf_evlist__find_tracepoint_by_name(session->evlist,\r\n"syscalls:sys_exit");\r\nif (evsel == NULL) {\r\npr_err("Data file does not have raw_syscalls:sys_exit event\n");\r\ngoto out;\r\n}\r\nif (perf_evsel__init_syscall_tp(evsel, trace__sys_exit) < 0 ||\r\nperf_evsel__init_sc_tp_uint_field(evsel, ret)) {\r\npr_err("Error during initialize raw_syscalls:sys_exit event\n");\r\ngoto out;\r\n}\r\nerr = parse_target_str(trace);\r\nif (err != 0)\r\ngoto out;\r\nsetup_pager();\r\nerr = perf_session__process_events(session, &trace->tool);\r\nif (err)\r\npr_err("Failed to process events, error %d", err);\r\nelse if (trace->summary)\r\ntrace__fprintf_thread_summary(trace, trace->output);\r\nout:\r\nperf_session__delete(session);\r\nreturn err;\r\n}\r\nstatic size_t trace__fprintf_threads_header(FILE *fp)\r\n{\r\nsize_t printed;\r\nprinted = fprintf(fp, "\n Summary of events:\n\n");\r\nreturn printed;\r\n}\r\nstatic size_t thread__dump_stats(struct thread_trace *ttrace,\r\nstruct trace *trace, FILE *fp)\r\n{\r\nstruct stats *stats;\r\nsize_t printed = 0;\r\nstruct syscall *sc;\r\nstruct int_node *inode = intlist__first(ttrace->syscall_stats);\r\nif (inode == NULL)\r\nreturn 0;\r\nprinted += fprintf(fp, "\n");\r\nprinted += fprintf(fp, " syscall calls min avg max stddev\n");\r\nprinted += fprintf(fp, " (msec) (msec) (msec) (%%)\n");\r\nprinted += fprintf(fp, " --------------- -------- --------- --------- --------- ------\n");\r\nwhile (inode) {\r\nstats = inode->priv;\r\nif (stats) {\r\ndouble min = (double)(stats->min) / NSEC_PER_MSEC;\r\ndouble max = (double)(stats->max) / NSEC_PER_MSEC;\r\ndouble avg = avg_stats(stats);\r\ndouble pct;\r\nu64 n = (u64) stats->n;\r\npct = avg ? 100.0 * stddev_stats(stats)/avg : 0.0;\r\navg /= NSEC_PER_MSEC;\r\nsc = &trace->syscalls.table[inode->i];\r\nprinted += fprintf(fp, " %-15s", sc->name);\r\nprinted += fprintf(fp, " %8" PRIu64 " %9.3f %9.3f",\r\nn, min, avg);\r\nprinted += fprintf(fp, " %9.3f %9.2f%%\n", max, pct);\r\n}\r\ninode = intlist__next(inode);\r\n}\r\nprinted += fprintf(fp, "\n\n");\r\nreturn printed;\r\n}\r\nstatic int trace__fprintf_one_thread(struct thread *thread, void *priv)\r\n{\r\nstruct summary_data *data = priv;\r\nFILE *fp = data->fp;\r\nsize_t printed = data->printed;\r\nstruct trace *trace = data->trace;\r\nstruct thread_trace *ttrace = thread->priv;\r\ndouble ratio;\r\nif (ttrace == NULL)\r\nreturn 0;\r\nratio = (double)ttrace->nr_events / trace->nr_events * 100.0;\r\nprinted += fprintf(fp, " %s (%d), ", thread__comm_str(thread), thread->tid);\r\nprinted += fprintf(fp, "%lu events, ", ttrace->nr_events);\r\nprinted += fprintf(fp, "%.1f%%", ratio);\r\nprinted += fprintf(fp, ", %.3f msec\n", ttrace->runtime_ms);\r\nprinted += thread__dump_stats(ttrace, trace, fp);\r\ndata->printed += printed;\r\nreturn 0;\r\n}\r\nstatic size_t trace__fprintf_thread_summary(struct trace *trace, FILE *fp)\r\n{\r\nstruct summary_data data = {\r\n.fp = fp,\r\n.trace = trace\r\n};\r\ndata.printed = trace__fprintf_threads_header(fp);\r\nmachine__for_each_thread(trace->host, trace__fprintf_one_thread, &data);\r\nreturn data.printed;\r\n}\r\nstatic int trace__set_duration(const struct option *opt, const char *str,\r\nint unset __maybe_unused)\r\n{\r\nstruct trace *trace = opt->value;\r\ntrace->duration_filter = atof(str);\r\nreturn 0;\r\n}\r\nstatic int trace__open_output(struct trace *trace, const char *filename)\r\n{\r\nstruct stat st;\r\nif (!stat(filename, &st) && st.st_size) {\r\nchar oldname[PATH_MAX];\r\nscnprintf(oldname, sizeof(oldname), "%s.old", filename);\r\nunlink(oldname);\r\nrename(filename, oldname);\r\n}\r\ntrace->output = fopen(filename, "w");\r\nreturn trace->output == NULL ? -errno : 0;\r\n}\r\nint cmd_trace(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nconst char * const trace_usage[] = {\r\n"perf trace [<options>] [<command>]",\r\n"perf trace [<options>] -- <command> [<options>]",\r\n"perf trace record [<options>] [<command>]",\r\n"perf trace record [<options>] -- <command> [<options>]",\r\nNULL\r\n};\r\nstruct trace trace = {\r\n.audit = {\r\n.machine = audit_detect_machine(),\r\n.open_id = audit_name_to_syscall("open", trace.audit.machine),\r\n},\r\n.syscalls = {\r\n. max = -1,\r\n},\r\n.opts = {\r\n.target = {\r\n.uid = UINT_MAX,\r\n.uses_mmap = true,\r\n},\r\n.user_freq = UINT_MAX,\r\n.user_interval = ULLONG_MAX,\r\n.no_buffering = true,\r\n.mmap_pages = 1024,\r\n},\r\n.output = stdout,\r\n.show_comm = true,\r\n};\r\nconst char *output_name = NULL;\r\nconst char *ev_qualifier_str = NULL;\r\nconst struct option trace_options[] = {\r\nOPT_BOOLEAN(0, "comm", &trace.show_comm,\r\n"show the thread COMM next to its id"),\r\nOPT_BOOLEAN(0, "tool_stats", &trace.show_tool_stats, "show tool stats"),\r\nOPT_STRING('e', "expr", &ev_qualifier_str, "expr",\r\n"list of events to trace"),\r\nOPT_STRING('o', "output", &output_name, "file", "output file name"),\r\nOPT_STRING('i', "input", &input_name, "file", "Analyze events in file"),\r\nOPT_STRING('p', "pid", &trace.opts.target.pid, "pid",\r\n"trace events on existing process id"),\r\nOPT_STRING('t', "tid", &trace.opts.target.tid, "tid",\r\n"trace events on existing thread id"),\r\nOPT_BOOLEAN('a', "all-cpus", &trace.opts.target.system_wide,\r\n"system-wide collection from all CPUs"),\r\nOPT_STRING('C', "cpu", &trace.opts.target.cpu_list, "cpu",\r\n"list of cpus to monitor"),\r\nOPT_BOOLEAN(0, "no-inherit", &trace.opts.no_inherit,\r\n"child tasks do not inherit counters"),\r\nOPT_CALLBACK('m', "mmap-pages", &trace.opts.mmap_pages, "pages",\r\n"number of mmap data pages",\r\nperf_evlist__parse_mmap_pages),\r\nOPT_STRING('u', "uid", &trace.opts.target.uid_str, "user",\r\n"user to profile"),\r\nOPT_CALLBACK(0, "duration", &trace, "float",\r\n"show only events with duration > N.M ms",\r\ntrace__set_duration),\r\nOPT_BOOLEAN(0, "sched", &trace.sched, "show blocking scheduler events"),\r\nOPT_INCR('v', "verbose", &verbose, "be more verbose"),\r\nOPT_BOOLEAN('T', "time", &trace.full_time,\r\n"Show full timestamp, not time relative to first start"),\r\nOPT_BOOLEAN('s', "summary", &trace.summary_only,\r\n"Show only syscall summary with statistics"),\r\nOPT_BOOLEAN('S', "with-summary", &trace.summary,\r\n"Show all syscalls and summary with statistics"),\r\nOPT_END()\r\n};\r\nint err;\r\nchar bf[BUFSIZ];\r\nif ((argc > 1) && (strcmp(argv[1], "record") == 0))\r\nreturn trace__record(argc-2, &argv[2]);\r\nargc = parse_options(argc, argv, trace_options, trace_usage, 0);\r\nif (trace.summary_only)\r\ntrace.summary = trace.summary_only;\r\nif (output_name != NULL) {\r\nerr = trace__open_output(&trace, output_name);\r\nif (err < 0) {\r\nperror("failed to create output file");\r\ngoto out;\r\n}\r\n}\r\nif (ev_qualifier_str != NULL) {\r\nconst char *s = ev_qualifier_str;\r\ntrace.not_ev_qualifier = *s == '!';\r\nif (trace.not_ev_qualifier)\r\n++s;\r\ntrace.ev_qualifier = strlist__new(true, s);\r\nif (trace.ev_qualifier == NULL) {\r\nfputs("Not enough memory to parse event qualifier",\r\ntrace.output);\r\nerr = -ENOMEM;\r\ngoto out_close;\r\n}\r\n}\r\nerr = target__validate(&trace.opts.target);\r\nif (err) {\r\ntarget__strerror(&trace.opts.target, err, bf, sizeof(bf));\r\nfprintf(trace.output, "%s", bf);\r\ngoto out_close;\r\n}\r\nerr = target__parse_uid(&trace.opts.target);\r\nif (err) {\r\ntarget__strerror(&trace.opts.target, err, bf, sizeof(bf));\r\nfprintf(trace.output, "%s", bf);\r\ngoto out_close;\r\n}\r\nif (!argc && target__none(&trace.opts.target))\r\ntrace.opts.target.system_wide = true;\r\nif (input_name)\r\nerr = trace__replay(&trace);\r\nelse\r\nerr = trace__run(&trace, argc, argv);\r\nout_close:\r\nif (output_name != NULL)\r\nfclose(trace.output);\r\nout:\r\nreturn err;\r\n}
