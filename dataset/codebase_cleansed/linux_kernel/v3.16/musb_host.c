struct musb *hcd_to_musb(struct usb_hcd *hcd)\r\n{\r\nreturn *(struct musb **) hcd->hcd_priv;\r\n}\r\nstatic void musb_h_tx_flush_fifo(struct musb_hw_ep *ep)\r\n{\r\nstruct musb *musb = ep->musb;\r\nvoid __iomem *epio = ep->regs;\r\nu16 csr;\r\nu16 lastcsr = 0;\r\nint retries = 1000;\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nwhile (csr & MUSB_TXCSR_FIFONOTEMPTY) {\r\nif (csr != lastcsr)\r\ndev_dbg(musb->controller, "Host TX FIFONOTEMPTY csr: %02x\n", csr);\r\nlastcsr = csr;\r\ncsr |= MUSB_TXCSR_FLUSHFIFO;\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nif (WARN(retries-- < 1,\r\n"Could not flush host TX%d fifo: csr: %04x\n",\r\nep->epnum, csr))\r\nreturn;\r\nmdelay(1);\r\n}\r\n}\r\nstatic void musb_h_ep0_flush_fifo(struct musb_hw_ep *ep)\r\n{\r\nvoid __iomem *epio = ep->regs;\r\nu16 csr;\r\nint retries = 5;\r\ndo {\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nif (!(csr & (MUSB_CSR0_TXPKTRDY | MUSB_CSR0_RXPKTRDY)))\r\nbreak;\r\nmusb_writew(epio, MUSB_TXCSR, MUSB_CSR0_FLUSHFIFO);\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nudelay(10);\r\n} while (--retries);\r\nWARN(!retries, "Could not flush host TX%d fifo: csr: %04x\n",\r\nep->epnum, csr);\r\nmusb_writew(epio, MUSB_TXCSR, 0);\r\n}\r\nstatic inline void musb_h_tx_start(struct musb_hw_ep *ep)\r\n{\r\nu16 txcsr;\r\nif (ep->epnum) {\r\ntxcsr = musb_readw(ep->regs, MUSB_TXCSR);\r\ntxcsr |= MUSB_TXCSR_TXPKTRDY | MUSB_TXCSR_H_WZC_BITS;\r\nmusb_writew(ep->regs, MUSB_TXCSR, txcsr);\r\n} else {\r\ntxcsr = MUSB_CSR0_H_SETUPPKT | MUSB_CSR0_TXPKTRDY;\r\nmusb_writew(ep->regs, MUSB_CSR0, txcsr);\r\n}\r\n}\r\nstatic inline void musb_h_tx_dma_start(struct musb_hw_ep *ep)\r\n{\r\nu16 txcsr;\r\ntxcsr = musb_readw(ep->regs, MUSB_TXCSR);\r\ntxcsr |= MUSB_TXCSR_DMAENAB | MUSB_TXCSR_H_WZC_BITS;\r\nif (is_cppi_enabled())\r\ntxcsr |= MUSB_TXCSR_DMAMODE;\r\nmusb_writew(ep->regs, MUSB_TXCSR, txcsr);\r\n}\r\nstatic void musb_ep_set_qh(struct musb_hw_ep *ep, int is_in, struct musb_qh *qh)\r\n{\r\nif (is_in != 0 || ep->is_shared_fifo)\r\nep->in_qh = qh;\r\nif (is_in == 0 || ep->is_shared_fifo)\r\nep->out_qh = qh;\r\n}\r\nstatic struct musb_qh *musb_ep_get_qh(struct musb_hw_ep *ep, int is_in)\r\n{\r\nreturn is_in ? ep->in_qh : ep->out_qh;\r\n}\r\nstatic void\r\nmusb_start_urb(struct musb *musb, int is_in, struct musb_qh *qh)\r\n{\r\nu16 frame;\r\nu32 len;\r\nvoid __iomem *mbase = musb->mregs;\r\nstruct urb *urb = next_urb(qh);\r\nvoid *buf = urb->transfer_buffer;\r\nu32 offset = 0;\r\nstruct musb_hw_ep *hw_ep = qh->hw_ep;\r\nunsigned pipe = urb->pipe;\r\nu8 address = usb_pipedevice(pipe);\r\nint epnum = hw_ep->epnum;\r\nqh->offset = 0;\r\nqh->segsize = 0;\r\nswitch (qh->type) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nis_in = 0;\r\nmusb->ep0_stage = MUSB_EP0_START;\r\nbuf = urb->setup_packet;\r\nlen = 8;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nqh->iso_idx = 0;\r\nqh->frame = 0;\r\noffset = urb->iso_frame_desc[0].offset;\r\nlen = urb->iso_frame_desc[0].length;\r\nbreak;\r\ndefault:\r\nbuf = urb->transfer_buffer + urb->actual_length;\r\nlen = urb->transfer_buffer_length - urb->actual_length;\r\n}\r\ndev_dbg(musb->controller, "qh %p urb %p dev%d ep%d%s%s, hw_ep %d, %p/%d\n",\r\nqh, urb, address, qh->epnum,\r\nis_in ? "in" : "out",\r\n({char *s; switch (qh->type) {\r\ncase USB_ENDPOINT_XFER_CONTROL: s = ""; break;\r\ncase USB_ENDPOINT_XFER_BULK: s = "-bulk"; break;\r\ncase USB_ENDPOINT_XFER_ISOC: s = "-iso"; break;\r\ndefault: s = "-intr"; break;\r\n} s; }),\r\nepnum, buf + offset, len);\r\nmusb_ep_set_qh(hw_ep, is_in, qh);\r\nmusb_ep_program(musb, epnum, urb, !is_in, buf, offset, len);\r\nif (is_in)\r\nreturn;\r\nswitch (qh->type) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ncase USB_ENDPOINT_XFER_INT:\r\ndev_dbg(musb->controller, "check whether there's still time for periodic Tx\n");\r\nframe = musb_readw(mbase, MUSB_FRAME);\r\nif (1) {\r\nqh->frame = 0;\r\ngoto start;\r\n} else {\r\nqh->frame = urb->start_frame;\r\ndev_dbg(musb->controller, "SOF for %d\n", epnum);\r\n#if 1\r\nmusb_writeb(mbase, MUSB_INTRUSBE, 0xff);\r\n#endif\r\n}\r\nbreak;\r\ndefault:\r\nstart:\r\ndev_dbg(musb->controller, "Start TX%d %s\n", epnum,\r\nhw_ep->tx_channel ? "dma" : "pio");\r\nif (!hw_ep->tx_channel)\r\nmusb_h_tx_start(hw_ep);\r\nelse if (is_cppi_enabled() || tusb_dma_omap())\r\nmusb_h_tx_dma_start(hw_ep);\r\n}\r\n}\r\nstatic void musb_giveback(struct musb *musb, struct urb *urb, int status)\r\n__releases(musb->lock)\r\n__acquires(musb->lock)\r\n{\r\ndev_dbg(musb->controller,\r\n"complete %p %pF (%d), dev%d ep%d%s, %d/%d\n",\r\nurb, urb->complete, status,\r\nusb_pipedevice(urb->pipe),\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out",\r\nurb->actual_length, urb->transfer_buffer_length\r\n);\r\nusb_hcd_unlink_urb_from_ep(musb->hcd, urb);\r\nspin_unlock(&musb->lock);\r\nusb_hcd_giveback_urb(musb->hcd, urb, status);\r\nspin_lock(&musb->lock);\r\n}\r\nstatic inline void musb_save_toggle(struct musb_qh *qh, int is_in,\r\nstruct urb *urb)\r\n{\r\nvoid __iomem *epio = qh->hw_ep->regs;\r\nu16 csr;\r\nif (is_in)\r\ncsr = musb_readw(epio, MUSB_RXCSR) & MUSB_RXCSR_H_DATATOGGLE;\r\nelse\r\ncsr = musb_readw(epio, MUSB_TXCSR) & MUSB_TXCSR_H_DATATOGGLE;\r\nusb_settoggle(urb->dev, qh->epnum, !is_in, csr ? 1 : 0);\r\n}\r\nstatic void musb_advance_schedule(struct musb *musb, struct urb *urb,\r\nstruct musb_hw_ep *hw_ep, int is_in)\r\n{\r\nstruct musb_qh *qh = musb_ep_get_qh(hw_ep, is_in);\r\nstruct musb_hw_ep *ep = qh->hw_ep;\r\nint ready = qh->is_ready;\r\nint status;\r\nstatus = (urb->status == -EINPROGRESS) ? 0 : urb->status;\r\nswitch (qh->type) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\ncase USB_ENDPOINT_XFER_INT:\r\nmusb_save_toggle(qh, is_in, urb);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (status == 0 && urb->error_count)\r\nstatus = -EXDEV;\r\nbreak;\r\n}\r\nqh->is_ready = 0;\r\nmusb_giveback(musb, urb, status);\r\nqh->is_ready = ready;\r\nif (list_empty(&qh->hep->urb_list)) {\r\nstruct list_head *head;\r\nstruct dma_controller *dma = musb->dma_controller;\r\nif (is_in) {\r\nep->rx_reinit = 1;\r\nif (ep->rx_channel) {\r\ndma->channel_release(ep->rx_channel);\r\nep->rx_channel = NULL;\r\n}\r\n} else {\r\nep->tx_reinit = 1;\r\nif (ep->tx_channel) {\r\ndma->channel_release(ep->tx_channel);\r\nep->tx_channel = NULL;\r\n}\r\n}\r\nmusb_ep_set_qh(ep, is_in, NULL);\r\nqh->hep->hcpriv = NULL;\r\nswitch (qh->type) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (qh->mux == 1) {\r\nhead = qh->ring.prev;\r\nlist_del(&qh->ring);\r\nkfree(qh);\r\nqh = first_qh(head);\r\nbreak;\r\n}\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ncase USB_ENDPOINT_XFER_INT:\r\nkfree(qh);\r\nqh = NULL;\r\nbreak;\r\n}\r\n}\r\nif (qh != NULL && qh->is_ready) {\r\ndev_dbg(musb->controller, "... next ep%d %cX urb %p\n",\r\nhw_ep->epnum, is_in ? 'R' : 'T', next_urb(qh));\r\nmusb_start_urb(musb, is_in, qh);\r\n}\r\n}\r\nstatic u16 musb_h_flush_rxfifo(struct musb_hw_ep *hw_ep, u16 csr)\r\n{\r\ncsr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_RXPKTRDY;\r\ncsr &= ~(MUSB_RXCSR_H_REQPKT\r\n| MUSB_RXCSR_H_AUTOREQ\r\n| MUSB_RXCSR_AUTOCLEAR);\r\nmusb_writew(hw_ep->regs, MUSB_RXCSR, csr);\r\nmusb_writew(hw_ep->regs, MUSB_RXCSR, csr);\r\nreturn musb_readw(hw_ep->regs, MUSB_RXCSR);\r\n}\r\nstatic bool\r\nmusb_host_packet_rx(struct musb *musb, struct urb *urb, u8 epnum, u8 iso_err)\r\n{\r\nu16 rx_count;\r\nu8 *buf;\r\nu16 csr;\r\nbool done = false;\r\nu32 length;\r\nint do_flush = 0;\r\nstruct musb_hw_ep *hw_ep = musb->endpoints + epnum;\r\nvoid __iomem *epio = hw_ep->regs;\r\nstruct musb_qh *qh = hw_ep->in_qh;\r\nint pipe = urb->pipe;\r\nvoid *buffer = urb->transfer_buffer;\r\nrx_count = musb_readw(epio, MUSB_RXCOUNT);\r\ndev_dbg(musb->controller, "RX%d count %d, buffer %p len %d/%d\n", epnum, rx_count,\r\nurb->transfer_buffer, qh->offset,\r\nurb->transfer_buffer_length);\r\nif (usb_pipeisoc(pipe)) {\r\nint status = 0;\r\nstruct usb_iso_packet_descriptor *d;\r\nif (iso_err) {\r\nstatus = -EILSEQ;\r\nurb->error_count++;\r\n}\r\nd = urb->iso_frame_desc + qh->iso_idx;\r\nbuf = buffer + d->offset;\r\nlength = d->length;\r\nif (rx_count > length) {\r\nif (status == 0) {\r\nstatus = -EOVERFLOW;\r\nurb->error_count++;\r\n}\r\ndev_dbg(musb->controller, "** OVERFLOW %d into %d\n", rx_count, length);\r\ndo_flush = 1;\r\n} else\r\nlength = rx_count;\r\nurb->actual_length += length;\r\nd->actual_length = length;\r\nd->status = status;\r\ndone = (++qh->iso_idx >= urb->number_of_packets);\r\n} else {\r\nbuf = buffer + qh->offset;\r\nlength = urb->transfer_buffer_length - qh->offset;\r\nif (rx_count > length) {\r\nif (urb->status == -EINPROGRESS)\r\nurb->status = -EOVERFLOW;\r\ndev_dbg(musb->controller, "** OVERFLOW %d into %d\n", rx_count, length);\r\ndo_flush = 1;\r\n} else\r\nlength = rx_count;\r\nurb->actual_length += length;\r\nqh->offset += length;\r\ndone = (urb->actual_length == urb->transfer_buffer_length)\r\n|| (rx_count < qh->maxpacket)\r\n|| (urb->status != -EINPROGRESS);\r\nif (done\r\n&& (urb->status == -EINPROGRESS)\r\n&& (urb->transfer_flags & URB_SHORT_NOT_OK)\r\n&& (urb->actual_length\r\n< urb->transfer_buffer_length))\r\nurb->status = -EREMOTEIO;\r\n}\r\nmusb_read_fifo(hw_ep, length, buf);\r\ncsr = musb_readw(epio, MUSB_RXCSR);\r\ncsr |= MUSB_RXCSR_H_WZC_BITS;\r\nif (unlikely(do_flush))\r\nmusb_h_flush_rxfifo(hw_ep, csr);\r\nelse {\r\ncsr &= ~(MUSB_RXCSR_RXPKTRDY | MUSB_RXCSR_H_REQPKT);\r\nif (!done)\r\ncsr |= MUSB_RXCSR_H_REQPKT;\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\n}\r\nreturn done;\r\n}\r\nstatic void\r\nmusb_rx_reinit(struct musb *musb, struct musb_qh *qh, struct musb_hw_ep *ep)\r\n{\r\nu16 csr;\r\nif (ep->is_shared_fifo) {\r\ncsr = musb_readw(ep->regs, MUSB_TXCSR);\r\nif (csr & MUSB_TXCSR_MODE) {\r\nmusb_h_tx_flush_fifo(ep);\r\ncsr = musb_readw(ep->regs, MUSB_TXCSR);\r\nmusb_writew(ep->regs, MUSB_TXCSR,\r\ncsr | MUSB_TXCSR_FRCDATATOG);\r\n}\r\nif (csr & MUSB_TXCSR_DMAMODE)\r\nmusb_writew(ep->regs, MUSB_TXCSR, MUSB_TXCSR_DMAMODE);\r\nmusb_writew(ep->regs, MUSB_TXCSR, 0);\r\n} else {\r\ncsr = musb_readw(ep->regs, MUSB_RXCSR);\r\nif (csr & MUSB_RXCSR_RXPKTRDY)\r\nWARNING("rx%d, packet/%d ready?\n", ep->epnum,\r\nmusb_readw(ep->regs, MUSB_RXCOUNT));\r\nmusb_h_flush_rxfifo(ep, MUSB_RXCSR_CLRDATATOG);\r\n}\r\nif (musb->is_multipoint) {\r\nmusb_write_rxfunaddr(ep->target_regs, qh->addr_reg);\r\nmusb_write_rxhubaddr(ep->target_regs, qh->h_addr_reg);\r\nmusb_write_rxhubport(ep->target_regs, qh->h_port_reg);\r\n} else\r\nmusb_writeb(musb->mregs, MUSB_FADDR, qh->addr_reg);\r\nmusb_writeb(ep->regs, MUSB_RXTYPE, qh->type_reg);\r\nmusb_writeb(ep->regs, MUSB_RXINTERVAL, qh->intv_reg);\r\nif (musb->double_buffer_not_ok)\r\nmusb_writew(ep->regs, MUSB_RXMAXP, ep->max_packet_sz_rx);\r\nelse\r\nmusb_writew(ep->regs, MUSB_RXMAXP,\r\nqh->maxpacket | ((qh->hb_mult - 1) << 11));\r\nep->rx_reinit = 0;\r\n}\r\nstatic bool musb_tx_dma_program(struct dma_controller *dma,\r\nstruct musb_hw_ep *hw_ep, struct musb_qh *qh,\r\nstruct urb *urb, u32 offset, u32 length)\r\n{\r\nstruct dma_channel *channel = hw_ep->tx_channel;\r\nvoid __iomem *epio = hw_ep->regs;\r\nu16 pkt_size = qh->maxpacket;\r\nu16 csr;\r\nu8 mode;\r\n#if defined(CONFIG_USB_INVENTRA_DMA) || defined(CONFIG_USB_UX500_DMA)\r\nif (length > channel->max_len)\r\nlength = channel->max_len;\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nif (length > pkt_size) {\r\nmode = 1;\r\ncsr |= MUSB_TXCSR_DMAMODE | MUSB_TXCSR_DMAENAB;\r\nif (qh->hb_mult == 1 || (qh->hb_mult > 1 &&\r\ncan_bulk_split(hw_ep->musb, qh->type)))\r\ncsr |= MUSB_TXCSR_AUTOSET;\r\n} else {\r\nmode = 0;\r\ncsr &= ~(MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAMODE);\r\ncsr |= MUSB_TXCSR_DMAENAB;\r\n}\r\nchannel->desired_mode = mode;\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\n#else\r\nif (!is_cppi_enabled() && !tusb_dma_omap())\r\nreturn false;\r\nchannel->actual_len = 0;\r\nmode = (urb->transfer_flags & URB_ZERO_PACKET) ? 1 : 0;\r\n#endif\r\nqh->segsize = length;\r\nwmb();\r\nif (!dma->channel_program(channel, pkt_size, mode,\r\nurb->transfer_dma + offset, length)) {\r\ndma->channel_release(channel);\r\nhw_ep->tx_channel = NULL;\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\ncsr &= ~(MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAENAB);\r\nmusb_writew(epio, MUSB_TXCSR, csr | MUSB_TXCSR_H_WZC_BITS);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void musb_ep_program(struct musb *musb, u8 epnum,\r\nstruct urb *urb, int is_out,\r\nu8 *buf, u32 offset, u32 len)\r\n{\r\nstruct dma_controller *dma_controller;\r\nstruct dma_channel *dma_channel;\r\nu8 dma_ok;\r\nvoid __iomem *mbase = musb->mregs;\r\nstruct musb_hw_ep *hw_ep = musb->endpoints + epnum;\r\nvoid __iomem *epio = hw_ep->regs;\r\nstruct musb_qh *qh = musb_ep_get_qh(hw_ep, !is_out);\r\nu16 packet_sz = qh->maxpacket;\r\nu8 use_dma = 1;\r\nu16 csr;\r\ndev_dbg(musb->controller, "%s hw%d urb %p spd%d dev%d ep%d%s "\r\n"h_addr%02x h_port%02x bytes %d\n",\r\nis_out ? "-->" : "<--",\r\nepnum, urb, urb->dev->speed,\r\nqh->addr_reg, qh->epnum, is_out ? "out" : "in",\r\nqh->h_addr_reg, qh->h_port_reg,\r\nlen);\r\nmusb_ep_select(mbase, epnum);\r\nif (is_out && !len) {\r\nuse_dma = 0;\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\ncsr &= ~MUSB_TXCSR_DMAENAB;\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\nhw_ep->tx_channel = NULL;\r\n}\r\ndma_controller = musb->dma_controller;\r\nif (use_dma && is_dma_capable() && epnum && dma_controller) {\r\ndma_channel = is_out ? hw_ep->tx_channel : hw_ep->rx_channel;\r\nif (!dma_channel) {\r\ndma_channel = dma_controller->channel_alloc(\r\ndma_controller, hw_ep, is_out);\r\nif (is_out)\r\nhw_ep->tx_channel = dma_channel;\r\nelse\r\nhw_ep->rx_channel = dma_channel;\r\n}\r\n} else\r\ndma_channel = NULL;\r\nif (is_out) {\r\nu16 csr;\r\nu16 int_txe;\r\nu16 load_count;\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nint_txe = musb->intrtxe;\r\nmusb_writew(mbase, MUSB_INTRTXE, int_txe & ~(1 << epnum));\r\nif (epnum) {\r\nif (!hw_ep->tx_double_buffered)\r\nmusb_h_tx_flush_fifo(hw_ep);\r\ncsr &= ~(MUSB_TXCSR_H_NAKTIMEOUT\r\n| MUSB_TXCSR_AUTOSET\r\n| MUSB_TXCSR_DMAENAB\r\n| MUSB_TXCSR_FRCDATATOG\r\n| MUSB_TXCSR_H_RXSTALL\r\n| MUSB_TXCSR_H_ERROR\r\n| MUSB_TXCSR_TXPKTRDY\r\n);\r\ncsr |= MUSB_TXCSR_MODE;\r\nif (!hw_ep->tx_double_buffered) {\r\nif (usb_gettoggle(urb->dev, qh->epnum, 1))\r\ncsr |= MUSB_TXCSR_H_WR_DATATOGGLE\r\n| MUSB_TXCSR_H_DATATOGGLE;\r\nelse\r\ncsr |= MUSB_TXCSR_CLRDATATOG;\r\n}\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\ncsr &= ~MUSB_TXCSR_DMAMODE;\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\n} else {\r\nmusb_h_ep0_flush_fifo(hw_ep);\r\n}\r\nif (musb->is_multipoint) {\r\nmusb_write_txfunaddr(mbase, epnum, qh->addr_reg);\r\nmusb_write_txhubaddr(mbase, epnum, qh->h_addr_reg);\r\nmusb_write_txhubport(mbase, epnum, qh->h_port_reg);\r\n} else\r\nmusb_writeb(mbase, MUSB_FADDR, qh->addr_reg);\r\nif (epnum) {\r\nmusb_writeb(epio, MUSB_TXTYPE, qh->type_reg);\r\nif (musb->double_buffer_not_ok) {\r\nmusb_writew(epio, MUSB_TXMAXP,\r\nhw_ep->max_packet_sz_tx);\r\n} else if (can_bulk_split(musb, qh->type)) {\r\nqh->hb_mult = hw_ep->max_packet_sz_tx\r\n/ packet_sz;\r\nmusb_writew(epio, MUSB_TXMAXP, packet_sz\r\n| ((qh->hb_mult) - 1) << 11);\r\n} else {\r\nmusb_writew(epio, MUSB_TXMAXP,\r\nqh->maxpacket |\r\n((qh->hb_mult - 1) << 11));\r\n}\r\nmusb_writeb(epio, MUSB_TXINTERVAL, qh->intv_reg);\r\n} else {\r\nmusb_writeb(epio, MUSB_NAKLIMIT0, qh->intv_reg);\r\nif (musb->is_multipoint)\r\nmusb_writeb(epio, MUSB_TYPE0,\r\nqh->type_reg);\r\n}\r\nif (can_bulk_split(musb, qh->type))\r\nload_count = min((u32) hw_ep->max_packet_sz_tx,\r\nlen);\r\nelse\r\nload_count = min((u32) packet_sz, len);\r\nif (dma_channel && musb_tx_dma_program(dma_controller,\r\nhw_ep, qh, urb, offset, len))\r\nload_count = 0;\r\nif (load_count) {\r\nqh->segsize = load_count;\r\nif (!buf) {\r\nsg_miter_start(&qh->sg_miter, urb->sg, 1,\r\nSG_MITER_ATOMIC\r\n| SG_MITER_FROM_SG);\r\nif (!sg_miter_next(&qh->sg_miter)) {\r\ndev_err(musb->controller,\r\n"error: sg"\r\n"list empty\n");\r\nsg_miter_stop(&qh->sg_miter);\r\ngoto finish;\r\n}\r\nbuf = qh->sg_miter.addr + urb->sg->offset +\r\nurb->actual_length;\r\nload_count = min_t(u32, load_count,\r\nqh->sg_miter.length);\r\nmusb_write_fifo(hw_ep, load_count, buf);\r\nqh->sg_miter.consumed = load_count;\r\nsg_miter_stop(&qh->sg_miter);\r\n} else\r\nmusb_write_fifo(hw_ep, load_count, buf);\r\n}\r\nfinish:\r\nmusb_writew(mbase, MUSB_INTRTXE, int_txe);\r\n} else {\r\nu16 csr;\r\nif (hw_ep->rx_reinit) {\r\nmusb_rx_reinit(musb, qh, hw_ep);\r\nif (usb_gettoggle(urb->dev, qh->epnum, 0))\r\ncsr = MUSB_RXCSR_H_WR_DATATOGGLE\r\n| MUSB_RXCSR_H_DATATOGGLE;\r\nelse\r\ncsr = 0;\r\nif (qh->type == USB_ENDPOINT_XFER_INT)\r\ncsr |= MUSB_RXCSR_DISNYET;\r\n} else {\r\ncsr = musb_readw(hw_ep->regs, MUSB_RXCSR);\r\nif (csr & (MUSB_RXCSR_RXPKTRDY\r\n| MUSB_RXCSR_DMAENAB\r\n| MUSB_RXCSR_H_REQPKT))\r\nERR("broken !rx_reinit, ep%d csr %04x\n",\r\nhw_ep->epnum, csr);\r\ncsr &= MUSB_RXCSR_DISNYET;\r\n}\r\nif ((is_cppi_enabled() || tusb_dma_omap()) && dma_channel) {\r\ndma_channel->actual_len = 0L;\r\nqh->segsize = len;\r\nmusb_writew(hw_ep->regs, MUSB_RXCSR, csr);\r\ncsr = musb_readw(hw_ep->regs, MUSB_RXCSR);\r\ndma_ok = dma_controller->channel_program(dma_channel,\r\npacket_sz, !(urb->transfer_flags &\r\nURB_SHORT_NOT_OK),\r\nurb->transfer_dma + offset,\r\nqh->segsize);\r\nif (!dma_ok) {\r\ndma_controller->channel_release(dma_channel);\r\nhw_ep->rx_channel = dma_channel = NULL;\r\n} else\r\ncsr |= MUSB_RXCSR_DMAENAB;\r\n}\r\ncsr |= MUSB_RXCSR_H_REQPKT;\r\ndev_dbg(musb->controller, "RXCSR%d := %04x\n", epnum, csr);\r\nmusb_writew(hw_ep->regs, MUSB_RXCSR, csr);\r\ncsr = musb_readw(hw_ep->regs, MUSB_RXCSR);\r\n}\r\n}\r\nstatic void musb_bulk_nak_timeout(struct musb *musb, struct musb_hw_ep *ep,\r\nint is_in)\r\n{\r\nstruct dma_channel *dma;\r\nstruct urb *urb;\r\nvoid __iomem *mbase = musb->mregs;\r\nvoid __iomem *epio = ep->regs;\r\nstruct musb_qh *cur_qh, *next_qh;\r\nu16 rx_csr, tx_csr;\r\nmusb_ep_select(mbase, ep->epnum);\r\nif (is_in) {\r\ndma = is_dma_capable() ? ep->rx_channel : NULL;\r\nrx_csr = musb_readw(epio, MUSB_RXCSR);\r\nrx_csr |= MUSB_RXCSR_H_WZC_BITS;\r\nrx_csr &= ~MUSB_RXCSR_DATAERROR;\r\nmusb_writew(epio, MUSB_RXCSR, rx_csr);\r\ncur_qh = first_qh(&musb->in_bulk);\r\n} else {\r\ndma = is_dma_capable() ? ep->tx_channel : NULL;\r\ntx_csr = musb_readw(epio, MUSB_TXCSR);\r\ntx_csr |= MUSB_TXCSR_H_WZC_BITS;\r\ntx_csr &= ~MUSB_TXCSR_H_NAKTIMEOUT;\r\nmusb_writew(epio, MUSB_TXCSR, tx_csr);\r\ncur_qh = first_qh(&musb->out_bulk);\r\n}\r\nif (cur_qh) {\r\nurb = next_urb(cur_qh);\r\nif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\r\ndma->status = MUSB_DMA_STATUS_CORE_ABORT;\r\nmusb->dma_controller->channel_abort(dma);\r\nurb->actual_length += dma->actual_len;\r\ndma->actual_len = 0L;\r\n}\r\nmusb_save_toggle(cur_qh, is_in, urb);\r\nif (is_in) {\r\nlist_move_tail(&cur_qh->ring, &musb->in_bulk);\r\nnext_qh = first_qh(&musb->in_bulk);\r\nep->rx_reinit = 1;\r\n} else {\r\nlist_move_tail(&cur_qh->ring, &musb->out_bulk);\r\nnext_qh = first_qh(&musb->out_bulk);\r\nep->tx_reinit = 1;\r\n}\r\nmusb_start_urb(musb, is_in, next_qh);\r\n}\r\n}\r\nstatic bool musb_h_ep0_continue(struct musb *musb, u16 len, struct urb *urb)\r\n{\r\nbool more = false;\r\nu8 *fifo_dest = NULL;\r\nu16 fifo_count = 0;\r\nstruct musb_hw_ep *hw_ep = musb->control_ep;\r\nstruct musb_qh *qh = hw_ep->in_qh;\r\nstruct usb_ctrlrequest *request;\r\nswitch (musb->ep0_stage) {\r\ncase MUSB_EP0_IN:\r\nfifo_dest = urb->transfer_buffer + urb->actual_length;\r\nfifo_count = min_t(size_t, len, urb->transfer_buffer_length -\r\nurb->actual_length);\r\nif (fifo_count < len)\r\nurb->status = -EOVERFLOW;\r\nmusb_read_fifo(hw_ep, fifo_count, fifo_dest);\r\nurb->actual_length += fifo_count;\r\nif (len < qh->maxpacket) {\r\n} else if (urb->actual_length <\r\nurb->transfer_buffer_length)\r\nmore = true;\r\nbreak;\r\ncase MUSB_EP0_START:\r\nrequest = (struct usb_ctrlrequest *) urb->setup_packet;\r\nif (!request->wLength) {\r\ndev_dbg(musb->controller, "start no-DATA\n");\r\nbreak;\r\n} else if (request->bRequestType & USB_DIR_IN) {\r\ndev_dbg(musb->controller, "start IN-DATA\n");\r\nmusb->ep0_stage = MUSB_EP0_IN;\r\nmore = true;\r\nbreak;\r\n} else {\r\ndev_dbg(musb->controller, "start OUT-DATA\n");\r\nmusb->ep0_stage = MUSB_EP0_OUT;\r\nmore = true;\r\n}\r\ncase MUSB_EP0_OUT:\r\nfifo_count = min_t(size_t, qh->maxpacket,\r\nurb->transfer_buffer_length -\r\nurb->actual_length);\r\nif (fifo_count) {\r\nfifo_dest = (u8 *) (urb->transfer_buffer\r\n+ urb->actual_length);\r\ndev_dbg(musb->controller, "Sending %d byte%s to ep0 fifo %p\n",\r\nfifo_count,\r\n(fifo_count == 1) ? "" : "s",\r\nfifo_dest);\r\nmusb_write_fifo(hw_ep, fifo_count, fifo_dest);\r\nurb->actual_length += fifo_count;\r\nmore = true;\r\n}\r\nbreak;\r\ndefault:\r\nERR("bogus ep0 stage %d\n", musb->ep0_stage);\r\nbreak;\r\n}\r\nreturn more;\r\n}\r\nirqreturn_t musb_h_ep0_irq(struct musb *musb)\r\n{\r\nstruct urb *urb;\r\nu16 csr, len;\r\nint status = 0;\r\nvoid __iomem *mbase = musb->mregs;\r\nstruct musb_hw_ep *hw_ep = musb->control_ep;\r\nvoid __iomem *epio = hw_ep->regs;\r\nstruct musb_qh *qh = hw_ep->in_qh;\r\nbool complete = false;\r\nirqreturn_t retval = IRQ_NONE;\r\nurb = next_urb(qh);\r\nmusb_ep_select(mbase, 0);\r\ncsr = musb_readw(epio, MUSB_CSR0);\r\nlen = (csr & MUSB_CSR0_RXPKTRDY)\r\n? musb_readb(epio, MUSB_COUNT0)\r\n: 0;\r\ndev_dbg(musb->controller, "<== csr0 %04x, qh %p, count %d, urb %p, stage %d\n",\r\ncsr, qh, len, urb, musb->ep0_stage);\r\nif (MUSB_EP0_STATUS == musb->ep0_stage) {\r\nretval = IRQ_HANDLED;\r\ncomplete = true;\r\n}\r\nif (csr & MUSB_CSR0_H_RXSTALL) {\r\ndev_dbg(musb->controller, "STALLING ENDPOINT\n");\r\nstatus = -EPIPE;\r\n} else if (csr & MUSB_CSR0_H_ERROR) {\r\ndev_dbg(musb->controller, "no response, csr0 %04x\n", csr);\r\nstatus = -EPROTO;\r\n} else if (csr & MUSB_CSR0_H_NAKTIMEOUT) {\r\ndev_dbg(musb->controller, "control NAK timeout\n");\r\nmusb_writew(epio, MUSB_CSR0, 0);\r\nretval = IRQ_HANDLED;\r\n}\r\nif (status) {\r\ndev_dbg(musb->controller, "aborting\n");\r\nretval = IRQ_HANDLED;\r\nif (urb)\r\nurb->status = status;\r\ncomplete = true;\r\nif (csr & MUSB_CSR0_H_REQPKT) {\r\ncsr &= ~MUSB_CSR0_H_REQPKT;\r\nmusb_writew(epio, MUSB_CSR0, csr);\r\ncsr &= ~MUSB_CSR0_H_NAKTIMEOUT;\r\nmusb_writew(epio, MUSB_CSR0, csr);\r\n} else {\r\nmusb_h_ep0_flush_fifo(hw_ep);\r\n}\r\nmusb_writeb(epio, MUSB_NAKLIMIT0, 0);\r\nmusb_writew(epio, MUSB_CSR0, 0);\r\n}\r\nif (unlikely(!urb)) {\r\nERR("no URB for end 0\n");\r\nmusb_h_ep0_flush_fifo(hw_ep);\r\ngoto done;\r\n}\r\nif (!complete) {\r\nif (musb_h_ep0_continue(musb, len, urb)) {\r\ncsr = (MUSB_EP0_IN == musb->ep0_stage)\r\n? MUSB_CSR0_H_REQPKT : MUSB_CSR0_TXPKTRDY;\r\n} else {\r\nif (usb_pipeout(urb->pipe)\r\n|| !urb->transfer_buffer_length)\r\ncsr = MUSB_CSR0_H_STATUSPKT\r\n| MUSB_CSR0_H_REQPKT;\r\nelse\r\ncsr = MUSB_CSR0_H_STATUSPKT\r\n| MUSB_CSR0_TXPKTRDY;\r\ncsr |= MUSB_CSR0_H_DIS_PING;\r\nmusb->ep0_stage = MUSB_EP0_STATUS;\r\ndev_dbg(musb->controller, "ep0 STATUS, csr %04x\n", csr);\r\n}\r\nmusb_writew(epio, MUSB_CSR0, csr);\r\nretval = IRQ_HANDLED;\r\n} else\r\nmusb->ep0_stage = MUSB_EP0_IDLE;\r\nif (complete)\r\nmusb_advance_schedule(musb, urb, hw_ep, 1);\r\ndone:\r\nreturn retval;\r\n}\r\nvoid musb_host_tx(struct musb *musb, u8 epnum)\r\n{\r\nint pipe;\r\nbool done = false;\r\nu16 tx_csr;\r\nsize_t length = 0;\r\nsize_t offset = 0;\r\nstruct musb_hw_ep *hw_ep = musb->endpoints + epnum;\r\nvoid __iomem *epio = hw_ep->regs;\r\nstruct musb_qh *qh = hw_ep->out_qh;\r\nstruct urb *urb = next_urb(qh);\r\nu32 status = 0;\r\nvoid __iomem *mbase = musb->mregs;\r\nstruct dma_channel *dma;\r\nbool transfer_pending = false;\r\nmusb_ep_select(mbase, epnum);\r\ntx_csr = musb_readw(epio, MUSB_TXCSR);\r\nif (!urb) {\r\ndev_dbg(musb->controller, "extra TX%d ready, csr %04x\n", epnum, tx_csr);\r\nreturn;\r\n}\r\npipe = urb->pipe;\r\ndma = is_dma_capable() ? hw_ep->tx_channel : NULL;\r\ndev_dbg(musb->controller, "OUT/TX%d end, csr %04x%s\n", epnum, tx_csr,\r\ndma ? ", dma" : "");\r\nif (tx_csr & MUSB_TXCSR_H_RXSTALL) {\r\ndev_dbg(musb->controller, "TX end %d stall\n", epnum);\r\nstatus = -EPIPE;\r\n} else if (tx_csr & MUSB_TXCSR_H_ERROR) {\r\ndev_dbg(musb->controller, "TX 3strikes on ep=%d\n", epnum);\r\nstatus = -ETIMEDOUT;\r\n} else if (tx_csr & MUSB_TXCSR_H_NAKTIMEOUT) {\r\nif (USB_ENDPOINT_XFER_BULK == qh->type && qh->mux == 1\r\n&& !list_is_singular(&musb->out_bulk)) {\r\ndev_dbg(musb->controller,\r\n"NAK timeout on TX%d ep\n", epnum);\r\nmusb_bulk_nak_timeout(musb, hw_ep, 0);\r\n} else {\r\ndev_dbg(musb->controller,\r\n"TX end=%d device not responding\n", epnum);\r\nmusb_ep_select(mbase, epnum);\r\nmusb_writew(epio, MUSB_TXCSR,\r\nMUSB_TXCSR_H_WZC_BITS\r\n| MUSB_TXCSR_TXPKTRDY);\r\n}\r\nreturn;\r\n}\r\ndone:\r\nif (status) {\r\nif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\r\ndma->status = MUSB_DMA_STATUS_CORE_ABORT;\r\n(void) musb->dma_controller->channel_abort(dma);\r\n}\r\nmusb_h_tx_flush_fifo(hw_ep);\r\ntx_csr &= ~(MUSB_TXCSR_AUTOSET\r\n| MUSB_TXCSR_DMAENAB\r\n| MUSB_TXCSR_H_ERROR\r\n| MUSB_TXCSR_H_RXSTALL\r\n| MUSB_TXCSR_H_NAKTIMEOUT\r\n);\r\nmusb_ep_select(mbase, epnum);\r\nmusb_writew(epio, MUSB_TXCSR, tx_csr);\r\nmusb_writew(epio, MUSB_TXCSR, tx_csr);\r\nmusb_writeb(epio, MUSB_TXINTERVAL, 0);\r\ndone = true;\r\n}\r\nif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\r\ndev_dbg(musb->controller, "extra TX%d ready, csr %04x\n", epnum, tx_csr);\r\nreturn;\r\n}\r\nif (is_dma_capable() && dma && !status) {\r\nif (tx_csr & MUSB_TXCSR_DMAMODE) {\r\ntx_csr &= musb_readw(epio, MUSB_TXCSR);\r\nif (tx_csr & MUSB_TXCSR_TXPKTRDY) {\r\ntx_csr &= ~(MUSB_TXCSR_DMAENAB |\r\nMUSB_TXCSR_TXPKTRDY);\r\nmusb_writew(epio, MUSB_TXCSR,\r\ntx_csr | MUSB_TXCSR_H_WZC_BITS);\r\n}\r\ntx_csr &= ~(MUSB_TXCSR_DMAMODE |\r\nMUSB_TXCSR_TXPKTRDY);\r\nmusb_writew(epio, MUSB_TXCSR,\r\ntx_csr | MUSB_TXCSR_H_WZC_BITS);\r\ntx_csr = musb_readw(epio, MUSB_TXCSR);\r\n}\r\nif (tx_csr & (MUSB_TXCSR_FIFONOTEMPTY | MUSB_TXCSR_TXPKTRDY)) {\r\ndev_dbg(musb->controller, "DMA complete but packet still in FIFO, "\r\n"CSR %04x\n", tx_csr);\r\nreturn;\r\n}\r\n}\r\nif (!status || dma || usb_pipeisoc(pipe)) {\r\nif (dma)\r\nlength = dma->actual_len;\r\nelse\r\nlength = qh->segsize;\r\nqh->offset += length;\r\nif (usb_pipeisoc(pipe)) {\r\nstruct usb_iso_packet_descriptor *d;\r\nd = urb->iso_frame_desc + qh->iso_idx;\r\nd->actual_length = length;\r\nd->status = status;\r\nif (++qh->iso_idx >= urb->number_of_packets) {\r\ndone = true;\r\n} else {\r\nd++;\r\noffset = d->offset;\r\nlength = d->length;\r\n}\r\n} else if (dma && urb->transfer_buffer_length == qh->offset) {\r\ndone = true;\r\n} else {\r\nif (qh->segsize < qh->maxpacket)\r\ndone = true;\r\nelse if (qh->offset == urb->transfer_buffer_length\r\n&& !(urb->transfer_flags\r\n& URB_ZERO_PACKET))\r\ndone = true;\r\nif (!done) {\r\noffset = qh->offset;\r\nlength = urb->transfer_buffer_length - offset;\r\ntransfer_pending = true;\r\n}\r\n}\r\n}\r\nif (urb->status != -EINPROGRESS) {\r\ndone = true;\r\nif (status == 0)\r\nstatus = urb->status;\r\n}\r\nif (done) {\r\nurb->status = status;\r\nurb->actual_length = qh->offset;\r\nmusb_advance_schedule(musb, urb, hw_ep, USB_DIR_OUT);\r\nreturn;\r\n} else if ((usb_pipeisoc(pipe) || transfer_pending) && dma) {\r\nif (musb_tx_dma_program(musb->dma_controller, hw_ep, qh, urb,\r\noffset, length)) {\r\nif (is_cppi_enabled() || tusb_dma_omap())\r\nmusb_h_tx_dma_start(hw_ep);\r\nreturn;\r\n}\r\n} else if (tx_csr & MUSB_TXCSR_DMAENAB) {\r\ndev_dbg(musb->controller, "not complete, but DMA enabled?\n");\r\nreturn;\r\n}\r\nif (length > qh->maxpacket)\r\nlength = qh->maxpacket;\r\nusb_hcd_unmap_urb_for_dma(musb->hcd, urb);\r\nif (!urb->transfer_buffer)\r\nqh->use_sg = true;\r\nif (qh->use_sg) {\r\nif (!sg_miter_next(&qh->sg_miter)) {\r\ndev_err(musb->controller, "error: sg list empty\n");\r\nsg_miter_stop(&qh->sg_miter);\r\nstatus = -EINVAL;\r\ngoto done;\r\n}\r\nurb->transfer_buffer = qh->sg_miter.addr;\r\nlength = min_t(u32, length, qh->sg_miter.length);\r\nmusb_write_fifo(hw_ep, length, urb->transfer_buffer);\r\nqh->sg_miter.consumed = length;\r\nsg_miter_stop(&qh->sg_miter);\r\n} else {\r\nmusb_write_fifo(hw_ep, length, urb->transfer_buffer + offset);\r\n}\r\nqh->segsize = length;\r\nif (qh->use_sg) {\r\nif (offset + length >= urb->transfer_buffer_length)\r\nqh->use_sg = false;\r\n}\r\nmusb_ep_select(mbase, epnum);\r\nmusb_writew(epio, MUSB_TXCSR,\r\nMUSB_TXCSR_H_WZC_BITS | MUSB_TXCSR_TXPKTRDY);\r\n}\r\nvoid musb_host_rx(struct musb *musb, u8 epnum)\r\n{\r\nstruct urb *urb;\r\nstruct musb_hw_ep *hw_ep = musb->endpoints + epnum;\r\nvoid __iomem *epio = hw_ep->regs;\r\nstruct musb_qh *qh = hw_ep->in_qh;\r\nsize_t xfer_len;\r\nvoid __iomem *mbase = musb->mregs;\r\nint pipe;\r\nu16 rx_csr, val;\r\nbool iso_err = false;\r\nbool done = false;\r\nu32 status;\r\nstruct dma_channel *dma;\r\nunsigned int sg_flags = SG_MITER_ATOMIC | SG_MITER_TO_SG;\r\nmusb_ep_select(mbase, epnum);\r\nurb = next_urb(qh);\r\ndma = is_dma_capable() ? hw_ep->rx_channel : NULL;\r\nstatus = 0;\r\nxfer_len = 0;\r\nrx_csr = musb_readw(epio, MUSB_RXCSR);\r\nval = rx_csr;\r\nif (unlikely(!urb)) {\r\ndev_dbg(musb->controller, "BOGUS RX%d ready, csr %04x, count %d\n", epnum, val,\r\nmusb_readw(epio, MUSB_RXCOUNT));\r\nmusb_h_flush_rxfifo(hw_ep, MUSB_RXCSR_CLRDATATOG);\r\nreturn;\r\n}\r\npipe = urb->pipe;\r\ndev_dbg(musb->controller, "<== hw %d rxcsr %04x, urb actual %d (+dma %zu)\n",\r\nepnum, rx_csr, urb->actual_length,\r\ndma ? dma->actual_len : 0);\r\nif (rx_csr & MUSB_RXCSR_H_RXSTALL) {\r\ndev_dbg(musb->controller, "RX end %d STALL\n", epnum);\r\nstatus = -EPIPE;\r\n} else if (rx_csr & MUSB_RXCSR_H_ERROR) {\r\ndev_dbg(musb->controller, "end %d RX proto error\n", epnum);\r\nstatus = -EPROTO;\r\nmusb_writeb(epio, MUSB_RXINTERVAL, 0);\r\n} else if (rx_csr & MUSB_RXCSR_DATAERROR) {\r\nif (USB_ENDPOINT_XFER_ISOC != qh->type) {\r\ndev_dbg(musb->controller, "RX end %d NAK timeout\n", epnum);\r\nif (usb_pipebulk(urb->pipe)\r\n&& qh->mux == 1\r\n&& !list_is_singular(&musb->in_bulk)) {\r\nmusb_bulk_nak_timeout(musb, hw_ep, 1);\r\nreturn;\r\n}\r\nmusb_ep_select(mbase, epnum);\r\nrx_csr |= MUSB_RXCSR_H_WZC_BITS;\r\nrx_csr &= ~MUSB_RXCSR_DATAERROR;\r\nmusb_writew(epio, MUSB_RXCSR, rx_csr);\r\ngoto finish;\r\n} else {\r\ndev_dbg(musb->controller, "RX end %d ISO data error\n", epnum);\r\niso_err = true;\r\n}\r\n} else if (rx_csr & MUSB_RXCSR_INCOMPRX) {\r\ndev_dbg(musb->controller, "end %d high bandwidth incomplete ISO packet RX\n",\r\nepnum);\r\nstatus = -EPROTO;\r\n}\r\nif (status) {\r\nif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\r\ndma->status = MUSB_DMA_STATUS_CORE_ABORT;\r\n(void) musb->dma_controller->channel_abort(dma);\r\nxfer_len = dma->actual_len;\r\n}\r\nmusb_h_flush_rxfifo(hw_ep, MUSB_RXCSR_CLRDATATOG);\r\nmusb_writeb(epio, MUSB_RXINTERVAL, 0);\r\ndone = true;\r\ngoto finish;\r\n}\r\nif (unlikely(dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY)) {\r\nERR("RX%d dma busy, csr %04x\n", epnum, rx_csr);\r\ngoto finish;\r\n}\r\n#if !defined(CONFIG_USB_INVENTRA_DMA) && !defined(CONFIG_USB_UX500_DMA)\r\nif (rx_csr & MUSB_RXCSR_H_REQPKT) {\r\nif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\r\ndma->status = MUSB_DMA_STATUS_CORE_ABORT;\r\n(void) musb->dma_controller->channel_abort(dma);\r\nxfer_len = dma->actual_len;\r\ndone = true;\r\n}\r\ndev_dbg(musb->controller, "RXCSR%d %04x, reqpkt, len %zu%s\n", epnum, rx_csr,\r\nxfer_len, dma ? ", dma" : "");\r\nrx_csr &= ~MUSB_RXCSR_H_REQPKT;\r\nmusb_ep_select(mbase, epnum);\r\nmusb_writew(epio, MUSB_RXCSR,\r\nMUSB_RXCSR_H_WZC_BITS | rx_csr);\r\n}\r\n#endif\r\nif (dma && (rx_csr & MUSB_RXCSR_DMAENAB)) {\r\nxfer_len = dma->actual_len;\r\nval &= ~(MUSB_RXCSR_DMAENAB\r\n| MUSB_RXCSR_H_AUTOREQ\r\n| MUSB_RXCSR_AUTOCLEAR\r\n| MUSB_RXCSR_RXPKTRDY);\r\nmusb_writew(hw_ep->regs, MUSB_RXCSR, val);\r\n#if defined(CONFIG_USB_INVENTRA_DMA) || defined(CONFIG_USB_UX500_DMA) || \\r\ndefined(CONFIG_USB_TI_CPPI41_DMA)\r\nif (usb_pipeisoc(pipe)) {\r\nstruct usb_iso_packet_descriptor *d;\r\nd = urb->iso_frame_desc + qh->iso_idx;\r\nd->actual_length = xfer_len;\r\nif (d->status != -EILSEQ && d->status != -EOVERFLOW)\r\nd->status = 0;\r\nif (++qh->iso_idx >= urb->number_of_packets) {\r\ndone = true;\r\n} else {\r\n#if defined(CONFIG_USB_TI_CPPI41_DMA)\r\nstruct dma_controller *c;\r\ndma_addr_t *buf;\r\nu32 length, ret;\r\nc = musb->dma_controller;\r\nbuf = (void *)\r\nurb->iso_frame_desc[qh->iso_idx].offset\r\n+ (u32)urb->transfer_dma;\r\nlength =\r\nurb->iso_frame_desc[qh->iso_idx].length;\r\nval |= MUSB_RXCSR_DMAENAB;\r\nmusb_writew(hw_ep->regs, MUSB_RXCSR, val);\r\nret = c->channel_program(dma, qh->maxpacket,\r\n0, (u32) buf, length);\r\n#endif\r\ndone = false;\r\n}\r\n} else {\r\ndone = (urb->actual_length + xfer_len >=\r\nurb->transfer_buffer_length\r\n|| dma->actual_len < qh->maxpacket);\r\n}\r\nif (!done) {\r\nval |= MUSB_RXCSR_H_REQPKT;\r\nmusb_writew(epio, MUSB_RXCSR,\r\nMUSB_RXCSR_H_WZC_BITS | val);\r\n}\r\ndev_dbg(musb->controller, "ep %d dma %s, rxcsr %04x, rxcount %d\n", epnum,\r\ndone ? "off" : "reset",\r\nmusb_readw(epio, MUSB_RXCSR),\r\nmusb_readw(epio, MUSB_RXCOUNT));\r\n#else\r\ndone = true;\r\n#endif\r\n} else if (urb->status == -EINPROGRESS) {\r\nif (unlikely(!(rx_csr & MUSB_RXCSR_RXPKTRDY))) {\r\nstatus = -EPROTO;\r\nERR("Rx interrupt with no errors or packet!\n");\r\nmusb_ep_select(mbase, epnum);\r\nval &= ~MUSB_RXCSR_H_REQPKT;\r\nmusb_writew(epio, MUSB_RXCSR, val);\r\ngoto finish;\r\n}\r\n#if defined(CONFIG_USB_INVENTRA_DMA) || defined(CONFIG_USB_UX500_DMA) || \\r\ndefined(CONFIG_USB_TI_CPPI41_DMA)\r\nif (dma) {\r\nstruct dma_controller *c;\r\nu16 rx_count;\r\nint ret, length;\r\ndma_addr_t buf;\r\nrx_count = musb_readw(epio, MUSB_RXCOUNT);\r\ndev_dbg(musb->controller, "RX%d count %d, buffer 0x%llx len %d/%d\n",\r\nepnum, rx_count,\r\n(unsigned long long) urb->transfer_dma\r\n+ urb->actual_length,\r\nqh->offset,\r\nurb->transfer_buffer_length);\r\nc = musb->dma_controller;\r\nif (usb_pipeisoc(pipe)) {\r\nint d_status = 0;\r\nstruct usb_iso_packet_descriptor *d;\r\nd = urb->iso_frame_desc + qh->iso_idx;\r\nif (iso_err) {\r\nd_status = -EILSEQ;\r\nurb->error_count++;\r\n}\r\nif (rx_count > d->length) {\r\nif (d_status == 0) {\r\nd_status = -EOVERFLOW;\r\nurb->error_count++;\r\n}\r\ndev_dbg(musb->controller, "** OVERFLOW %d into %d\n",\\r\nrx_count, d->length);\r\nlength = d->length;\r\n} else\r\nlength = rx_count;\r\nd->status = d_status;\r\nbuf = urb->transfer_dma + d->offset;\r\n} else {\r\nlength = rx_count;\r\nbuf = urb->transfer_dma +\r\nurb->actual_length;\r\n}\r\ndma->desired_mode = 0;\r\n#ifdef USE_MODE1\r\nif ((urb->transfer_flags &\r\nURB_SHORT_NOT_OK)\r\n&& (urb->transfer_buffer_length -\r\nurb->actual_length)\r\n> qh->maxpacket)\r\ndma->desired_mode = 1;\r\nif (rx_count < hw_ep->max_packet_sz_rx) {\r\nlength = rx_count;\r\ndma->desired_mode = 0;\r\n} else {\r\nlength = urb->transfer_buffer_length;\r\n}\r\n#endif\r\nval = musb_readw(epio, MUSB_RXCSR);\r\nval &= ~MUSB_RXCSR_H_REQPKT;\r\nif (dma->desired_mode == 0)\r\nval &= ~MUSB_RXCSR_H_AUTOREQ;\r\nelse\r\nval |= MUSB_RXCSR_H_AUTOREQ;\r\nval |= MUSB_RXCSR_DMAENAB;\r\nif (qh->hb_mult == 1)\r\nval |= MUSB_RXCSR_AUTOCLEAR;\r\nmusb_writew(epio, MUSB_RXCSR,\r\nMUSB_RXCSR_H_WZC_BITS | val);\r\nret = c->channel_program(\r\ndma, qh->maxpacket,\r\ndma->desired_mode, buf, length);\r\nif (!ret) {\r\nc->channel_release(dma);\r\nhw_ep->rx_channel = NULL;\r\ndma = NULL;\r\nval = musb_readw(epio, MUSB_RXCSR);\r\nval &= ~(MUSB_RXCSR_DMAENAB\r\n| MUSB_RXCSR_H_AUTOREQ\r\n| MUSB_RXCSR_AUTOCLEAR);\r\nmusb_writew(epio, MUSB_RXCSR, val);\r\n}\r\n}\r\n#endif\r\nif (!dma) {\r\nunsigned int received_len;\r\nusb_hcd_unmap_urb_for_dma(musb->hcd, urb);\r\nif (!urb->transfer_buffer) {\r\nqh->use_sg = true;\r\nsg_miter_start(&qh->sg_miter, urb->sg, 1,\r\nsg_flags);\r\n}\r\nif (qh->use_sg) {\r\nif (!sg_miter_next(&qh->sg_miter)) {\r\ndev_err(musb->controller, "error: sg list empty\n");\r\nsg_miter_stop(&qh->sg_miter);\r\nstatus = -EINVAL;\r\ndone = true;\r\ngoto finish;\r\n}\r\nurb->transfer_buffer = qh->sg_miter.addr;\r\nreceived_len = urb->actual_length;\r\nqh->offset = 0x0;\r\ndone = musb_host_packet_rx(musb, urb, epnum,\r\niso_err);\r\nreceived_len = urb->actual_length -\r\nreceived_len;\r\nqh->sg_miter.consumed = received_len;\r\nsg_miter_stop(&qh->sg_miter);\r\n} else {\r\ndone = musb_host_packet_rx(musb, urb,\r\nepnum, iso_err);\r\n}\r\ndev_dbg(musb->controller, "read %spacket\n", done ? "last " : "");\r\n}\r\n}\r\nfinish:\r\nurb->actual_length += xfer_len;\r\nqh->offset += xfer_len;\r\nif (done) {\r\nif (qh->use_sg)\r\nqh->use_sg = false;\r\nif (urb->status == -EINPROGRESS)\r\nurb->status = status;\r\nmusb_advance_schedule(musb, urb, hw_ep, USB_DIR_IN);\r\n}\r\n}\r\nstatic int musb_schedule(\r\nstruct musb *musb,\r\nstruct musb_qh *qh,\r\nint is_in)\r\n{\r\nint idle;\r\nint best_diff;\r\nint best_end, epnum;\r\nstruct musb_hw_ep *hw_ep = NULL;\r\nstruct list_head *head = NULL;\r\nu8 toggle;\r\nu8 txtype;\r\nstruct urb *urb = next_urb(qh);\r\nif (qh->type == USB_ENDPOINT_XFER_CONTROL) {\r\nhead = &musb->control;\r\nhw_ep = musb->control_ep;\r\ngoto success;\r\n}\r\nbest_diff = 4096;\r\nbest_end = -1;\r\nfor (epnum = 1, hw_ep = musb->endpoints + 1;\r\nepnum < musb->nr_endpoints;\r\nepnum++, hw_ep++) {\r\nint diff;\r\nif (musb_ep_get_qh(hw_ep, is_in) != NULL)\r\ncontinue;\r\nif (hw_ep == musb->bulk_ep)\r\ncontinue;\r\nif (is_in)\r\ndiff = hw_ep->max_packet_sz_rx;\r\nelse\r\ndiff = hw_ep->max_packet_sz_tx;\r\ndiff -= (qh->maxpacket * qh->hb_mult);\r\nif (diff >= 0 && best_diff > diff) {\r\nhw_ep = musb->endpoints + epnum;\r\ntoggle = usb_gettoggle(urb->dev, qh->epnum, !is_in);\r\ntxtype = (musb_readb(hw_ep->regs, MUSB_TXTYPE)\r\n>> 4) & 0x3;\r\nif (!is_in && (qh->type == USB_ENDPOINT_XFER_BULK) &&\r\ntoggle && (txtype == USB_ENDPOINT_XFER_ISOC))\r\ncontinue;\r\nbest_diff = diff;\r\nbest_end = epnum;\r\n}\r\n}\r\nif (best_end < 0 && qh->type == USB_ENDPOINT_XFER_BULK) {\r\nhw_ep = musb->bulk_ep;\r\nif (is_in)\r\nhead = &musb->in_bulk;\r\nelse\r\nhead = &musb->out_bulk;\r\nif (qh->dev)\r\nqh->intv_reg =\r\n(USB_SPEED_HIGH == qh->dev->speed) ? 8 : 4;\r\ngoto success;\r\n} else if (best_end < 0) {\r\nreturn -ENOSPC;\r\n}\r\nidle = 1;\r\nqh->mux = 0;\r\nhw_ep = musb->endpoints + best_end;\r\ndev_dbg(musb->controller, "qh %p periodic slot %d\n", qh, best_end);\r\nsuccess:\r\nif (head) {\r\nidle = list_empty(head);\r\nlist_add_tail(&qh->ring, head);\r\nqh->mux = 1;\r\n}\r\nqh->hw_ep = hw_ep;\r\nqh->hep->hcpriv = qh;\r\nif (idle)\r\nmusb_start_urb(musb, is_in, qh);\r\nreturn 0;\r\n}\r\nstatic int musb_urb_enqueue(\r\nstruct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nunsigned long flags;\r\nstruct musb *musb = hcd_to_musb(hcd);\r\nstruct usb_host_endpoint *hep = urb->ep;\r\nstruct musb_qh *qh;\r\nstruct usb_endpoint_descriptor *epd = &hep->desc;\r\nint ret;\r\nunsigned type_reg;\r\nunsigned interval;\r\nif (!is_host_active(musb) || !musb->is_active)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nret = usb_hcd_link_urb_to_ep(hcd, urb);\r\nqh = ret ? NULL : hep->hcpriv;\r\nif (qh)\r\nurb->hcpriv = qh;\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nif (qh || ret)\r\nreturn ret;\r\nqh = kzalloc(sizeof *qh, mem_flags);\r\nif (!qh) {\r\nspin_lock_irqsave(&musb->lock, flags);\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nqh->hep = hep;\r\nqh->dev = urb->dev;\r\nINIT_LIST_HEAD(&qh->ring);\r\nqh->is_ready = 1;\r\nqh->maxpacket = usb_endpoint_maxp(epd);\r\nqh->type = usb_endpoint_type(epd);\r\nqh->hb_mult = 1 + ((qh->maxpacket >> 11) & 0x03);\r\nif (qh->hb_mult > 1) {\r\nint ok = (qh->type == USB_ENDPOINT_XFER_ISOC);\r\nif (ok)\r\nok = (usb_pipein(urb->pipe) && musb->hb_iso_rx)\r\n|| (usb_pipeout(urb->pipe) && musb->hb_iso_tx);\r\nif (!ok) {\r\nret = -EMSGSIZE;\r\ngoto done;\r\n}\r\nqh->maxpacket &= 0x7ff;\r\n}\r\nqh->epnum = usb_endpoint_num(epd);\r\nqh->addr_reg = (u8) usb_pipedevice(urb->pipe);\r\ntype_reg = (qh->type << 4) | qh->epnum;\r\nswitch (urb->dev->speed) {\r\ncase USB_SPEED_LOW:\r\ntype_reg |= 0xc0;\r\nbreak;\r\ncase USB_SPEED_FULL:\r\ntype_reg |= 0x80;\r\nbreak;\r\ndefault:\r\ntype_reg |= 0x40;\r\n}\r\nqh->type_reg = type_reg;\r\nswitch (qh->type) {\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (urb->dev->speed <= USB_SPEED_FULL) {\r\ninterval = max_t(u8, epd->bInterval, 1);\r\nbreak;\r\n}\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ninterval = min_t(u8, epd->bInterval, 16);\r\nbreak;\r\ndefault:\r\ninterval = 0;\r\n}\r\nqh->intv_reg = interval;\r\nif (musb->is_multipoint) {\r\nstruct usb_device *parent = urb->dev->parent;\r\nif (parent != hcd->self.root_hub) {\r\nqh->h_addr_reg = (u8) parent->devnum;\r\nif (urb->dev->tt) {\r\nqh->h_port_reg = (u8) urb->dev->ttport;\r\nif (urb->dev->tt->hub)\r\nqh->h_addr_reg =\r\n(u8) urb->dev->tt->hub->devnum;\r\nif (urb->dev->tt->multi)\r\nqh->h_addr_reg |= 0x80;\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&musb->lock, flags);\r\nif (hep->hcpriv || !next_urb(qh)) {\r\nkfree(qh);\r\nqh = NULL;\r\nret = 0;\r\n} else\r\nret = musb_schedule(musb, qh,\r\nepd->bEndpointAddress & USB_ENDPOINT_DIR_MASK);\r\nif (ret == 0) {\r\nurb->hcpriv = qh;\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\ndone:\r\nif (ret != 0) {\r\nspin_lock_irqsave(&musb->lock, flags);\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nkfree(qh);\r\n}\r\nreturn ret;\r\n}\r\nstatic int musb_cleanup_urb(struct urb *urb, struct musb_qh *qh)\r\n{\r\nstruct musb_hw_ep *ep = qh->hw_ep;\r\nstruct musb *musb = ep->musb;\r\nvoid __iomem *epio = ep->regs;\r\nunsigned hw_end = ep->epnum;\r\nvoid __iomem *regs = ep->musb->mregs;\r\nint is_in = usb_pipein(urb->pipe);\r\nint status = 0;\r\nu16 csr;\r\nmusb_ep_select(regs, hw_end);\r\nif (is_dma_capable()) {\r\nstruct dma_channel *dma;\r\ndma = is_in ? ep->rx_channel : ep->tx_channel;\r\nif (dma) {\r\nstatus = ep->musb->dma_controller->channel_abort(dma);\r\ndev_dbg(musb->controller,\r\n"abort %cX%d DMA for urb %p --> %d\n",\r\nis_in ? 'R' : 'T', ep->epnum,\r\nurb, status);\r\nurb->actual_length += dma->actual_len;\r\n}\r\n}\r\nif (ep->epnum && is_in) {\r\ncsr = musb_h_flush_rxfifo(ep, 0);\r\n} else if (ep->epnum) {\r\nmusb_h_tx_flush_fifo(ep);\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\ncsr &= ~(MUSB_TXCSR_AUTOSET\r\n| MUSB_TXCSR_DMAENAB\r\n| MUSB_TXCSR_H_RXSTALL\r\n| MUSB_TXCSR_H_NAKTIMEOUT\r\n| MUSB_TXCSR_H_ERROR\r\n| MUSB_TXCSR_TXPKTRDY);\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\n} else {\r\nmusb_h_ep0_flush_fifo(ep);\r\n}\r\nif (status == 0)\r\nmusb_advance_schedule(ep->musb, urb, ep, is_in);\r\nreturn status;\r\n}\r\nstatic int musb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct musb *musb = hcd_to_musb(hcd);\r\nstruct musb_qh *qh;\r\nunsigned long flags;\r\nint is_in = usb_pipein(urb->pipe);\r\nint ret;\r\ndev_dbg(musb->controller, "urb=%p, dev%d ep%d%s\n", urb,\r\nusb_pipedevice(urb->pipe),\r\nusb_pipeendpoint(urb->pipe),\r\nis_in ? "in" : "out");\r\nspin_lock_irqsave(&musb->lock, flags);\r\nret = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (ret)\r\ngoto done;\r\nqh = urb->hcpriv;\r\nif (!qh)\r\ngoto done;\r\nif (!qh->is_ready\r\n|| urb->urb_list.prev != &qh->hep->urb_list\r\n|| musb_ep_get_qh(qh->hw_ep, is_in) != qh) {\r\nint ready = qh->is_ready;\r\nqh->is_ready = 0;\r\nmusb_giveback(musb, urb, 0);\r\nqh->is_ready = ready;\r\nif (ready && list_empty(&qh->hep->urb_list)) {\r\nqh->hep->hcpriv = NULL;\r\nlist_del(&qh->ring);\r\nkfree(qh);\r\n}\r\n} else\r\nret = musb_cleanup_urb(urb, qh);\r\ndone:\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void\r\nmusb_h_disable(struct usb_hcd *hcd, struct usb_host_endpoint *hep)\r\n{\r\nu8 is_in = hep->desc.bEndpointAddress & USB_DIR_IN;\r\nunsigned long flags;\r\nstruct musb *musb = hcd_to_musb(hcd);\r\nstruct musb_qh *qh;\r\nstruct urb *urb;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nqh = hep->hcpriv;\r\nif (qh == NULL)\r\ngoto exit;\r\nqh->is_ready = 0;\r\nif (musb_ep_get_qh(qh->hw_ep, is_in) == qh) {\r\nurb = next_urb(qh);\r\nif (!urb->unlinked)\r\nurb->status = -ESHUTDOWN;\r\nmusb_cleanup_urb(urb, qh);\r\nwhile (!list_empty(&hep->urb_list)) {\r\nurb = next_urb(qh);\r\nurb->status = -ESHUTDOWN;\r\nmusb_advance_schedule(musb, urb, qh->hw_ep, is_in);\r\n}\r\n} else {\r\nwhile (!list_empty(&hep->urb_list))\r\nmusb_giveback(musb, next_urb(qh), -ESHUTDOWN);\r\nhep->hcpriv = NULL;\r\nlist_del(&qh->ring);\r\nkfree(qh);\r\n}\r\nexit:\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic int musb_h_get_frame_number(struct usb_hcd *hcd)\r\n{\r\nstruct musb *musb = hcd_to_musb(hcd);\r\nreturn musb_readw(musb->mregs, MUSB_FRAME);\r\n}\r\nstatic int musb_h_start(struct usb_hcd *hcd)\r\n{\r\nstruct musb *musb = hcd_to_musb(hcd);\r\nhcd->state = HC_STATE_RUNNING;\r\nmusb->port1_status = 0;\r\nreturn 0;\r\n}\r\nstatic void musb_h_stop(struct usb_hcd *hcd)\r\n{\r\nmusb_stop(hcd_to_musb(hcd));\r\nhcd->state = HC_STATE_HALT;\r\n}\r\nstatic int musb_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nstruct musb *musb = hcd_to_musb(hcd);\r\nu8 devctl;\r\nmusb_port_suspend(musb, true);\r\nif (!is_host_active(musb))\r\nreturn 0;\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_SUSPEND:\r\nreturn 0;\r\ncase OTG_STATE_A_WAIT_VRISE:\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS)\r\nmusb->xceiv->state = OTG_STATE_A_WAIT_BCON;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (musb->is_active) {\r\nWARNING("trying to suspend as %s while active\n",\r\nusb_otg_state_string(musb->xceiv->state));\r\nreturn -EBUSY;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int musb_bus_resume(struct usb_hcd *hcd)\r\n{\r\nstruct musb *musb = hcd_to_musb(hcd);\r\nif (musb->config &&\r\nmusb->config->host_port_deassert_reset_at_resume)\r\nmusb_port_reset(musb, false);\r\nreturn 0;\r\n}\r\nstatic void musb_free_temp_buffer(struct urb *urb)\r\n{\r\nenum dma_data_direction dir;\r\nstruct musb_temp_buffer *temp;\r\nif (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))\r\nreturn;\r\ndir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\ntemp = container_of(urb->transfer_buffer, struct musb_temp_buffer,\r\ndata);\r\nif (dir == DMA_FROM_DEVICE) {\r\nmemcpy(temp->old_xfer_buffer, temp->data,\r\nurb->transfer_buffer_length);\r\n}\r\nurb->transfer_buffer = temp->old_xfer_buffer;\r\nkfree(temp->kmalloc_ptr);\r\nurb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;\r\n}\r\nstatic int musb_alloc_temp_buffer(struct urb *urb, gfp_t mem_flags)\r\n{\r\nenum dma_data_direction dir;\r\nstruct musb_temp_buffer *temp;\r\nvoid *kmalloc_ptr;\r\nsize_t kmalloc_size;\r\nif (urb->num_sgs || urb->sg ||\r\nurb->transfer_buffer_length == 0 ||\r\n!((uintptr_t)urb->transfer_buffer & (MUSB_USB_DMA_ALIGN - 1)))\r\nreturn 0;\r\ndir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\nkmalloc_size = urb->transfer_buffer_length +\r\nsizeof(struct musb_temp_buffer) + MUSB_USB_DMA_ALIGN - 1;\r\nkmalloc_ptr = kmalloc(kmalloc_size, mem_flags);\r\nif (!kmalloc_ptr)\r\nreturn -ENOMEM;\r\ntemp = PTR_ALIGN(kmalloc_ptr, MUSB_USB_DMA_ALIGN);\r\ntemp->kmalloc_ptr = kmalloc_ptr;\r\ntemp->old_xfer_buffer = urb->transfer_buffer;\r\nif (dir == DMA_TO_DEVICE)\r\nmemcpy(temp->data, urb->transfer_buffer,\r\nurb->transfer_buffer_length);\r\nurb->transfer_buffer = temp->data;\r\nurb->transfer_flags |= URB_ALIGNED_TEMP_BUFFER;\r\nreturn 0;\r\n}\r\nstatic int musb_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct musb *musb = hcd_to_musb(hcd);\r\nint ret;\r\nif (musb->hwvers < MUSB_HWVERS_1800)\r\nreturn usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);\r\nret = musb_alloc_temp_buffer(urb, mem_flags);\r\nif (ret)\r\nreturn ret;\r\nret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);\r\nif (ret)\r\nmusb_free_temp_buffer(urb);\r\nreturn ret;\r\n}\r\nstatic void musb_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nstruct musb *musb = hcd_to_musb(hcd);\r\nusb_hcd_unmap_urb_for_dma(hcd, urb);\r\nif (musb->hwvers < MUSB_HWVERS_1800)\r\nreturn;\r\nmusb_free_temp_buffer(urb);\r\n}\r\nint musb_host_alloc(struct musb *musb)\r\n{\r\nstruct device *dev = musb->controller;\r\nmusb->hcd = usb_create_hcd(&musb_hc_driver, dev, dev_name(dev));\r\nif (!musb->hcd)\r\nreturn -EINVAL;\r\n*musb->hcd->hcd_priv = (unsigned long) musb;\r\nmusb->hcd->self.uses_pio_for_control = 1;\r\nmusb->hcd->uses_new_polling = 1;\r\nmusb->hcd->has_tt = 1;\r\nreturn 0;\r\n}\r\nvoid musb_host_cleanup(struct musb *musb)\r\n{\r\nif (musb->port_mode == MUSB_PORT_MODE_GADGET)\r\nreturn;\r\nusb_remove_hcd(musb->hcd);\r\nmusb->hcd = NULL;\r\n}\r\nvoid musb_host_free(struct musb *musb)\r\n{\r\nusb_put_hcd(musb->hcd);\r\n}\r\nint musb_host_setup(struct musb *musb, int power_budget)\r\n{\r\nint ret;\r\nstruct usb_hcd *hcd = musb->hcd;\r\nMUSB_HST_MODE(musb);\r\nmusb->xceiv->otg->default_a = 1;\r\nmusb->xceiv->state = OTG_STATE_A_IDLE;\r\notg_set_host(musb->xceiv->otg, &hcd->self);\r\nhcd->self.otg_port = 1;\r\nmusb->xceiv->otg->host = &hcd->self;\r\nhcd->power_budget = 2 * (power_budget ? : 250);\r\nret = usb_add_hcd(hcd, 0, 0);\r\nif (ret < 0)\r\nreturn ret;\r\ndevice_wakeup_enable(hcd->self.controller);\r\nreturn 0;\r\n}\r\nvoid musb_host_resume_root_hub(struct musb *musb)\r\n{\r\nusb_hcd_resume_root_hub(musb->hcd);\r\n}\r\nvoid musb_host_poke_root_hub(struct musb *musb)\r\n{\r\nMUSB_HST_MODE(musb);\r\nif (musb->hcd->status_urb)\r\nusb_hcd_poll_rh_status(musb->hcd);\r\nelse\r\nusb_hcd_resume_root_hub(musb->hcd);\r\n}
