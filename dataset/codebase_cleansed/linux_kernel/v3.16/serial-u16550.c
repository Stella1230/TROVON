static inline void snd_uart16550_add_timer(struct snd_uart16550 *uart)\r\n{\r\nif (!uart->timer_running) {\r\nuart->buffer_timer.expires = jiffies + (HZ+255)/256;\r\nuart->timer_running = 1;\r\nadd_timer(&uart->buffer_timer);\r\n}\r\n}\r\nstatic inline void snd_uart16550_del_timer(struct snd_uart16550 *uart)\r\n{\r\nif (uart->timer_running) {\r\ndel_timer(&uart->buffer_timer);\r\nuart->timer_running = 0;\r\n}\r\n}\r\nstatic inline void snd_uart16550_buffer_output(struct snd_uart16550 *uart)\r\n{\r\nunsigned short buff_out = uart->buff_out;\r\nif (uart->buff_in_count > 0) {\r\noutb(uart->tx_buff[buff_out], uart->base + UART_TX);\r\nuart->fifo_count++;\r\nbuff_out++;\r\nbuff_out &= TX_BUFF_MASK;\r\nuart->buff_out = buff_out;\r\nuart->buff_in_count--;\r\n}\r\n}\r\nstatic void snd_uart16550_io_loop(struct snd_uart16550 * uart)\r\n{\r\nunsigned char c, status;\r\nint substream;\r\nsubstream = uart->prev_in;\r\nwhile ((status = inb(uart->base + UART_LSR)) & UART_LSR_DR) {\r\nc = inb(uart->base + UART_RX);\r\nif (c & 0x80)\r\nuart->rstatus = c;\r\nif (uart->adaptor == SNDRV_SERIAL_GENERIC) {\r\nif (uart->rstatus == 0xf5) {\r\nif (c <= SNDRV_SERIAL_MAX_INS && c > 0)\r\nsubstream = c - 1;\r\nif (c != 0xf5)\r\nuart->rstatus = 0;\r\n} else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN)\r\n&& uart->midi_input[substream])\r\nsnd_rawmidi_receive(uart->midi_input[substream],\r\n&c, 1);\r\n} else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN) &&\r\nuart->midi_input[substream])\r\nsnd_rawmidi_receive(uart->midi_input[substream], &c, 1);\r\nif (status & UART_LSR_OE)\r\nsnd_printk(KERN_WARNING\r\n"%s: Overrun on device at 0x%lx\n",\r\nuart->rmidi->name, uart->base);\r\n}\r\nuart->prev_in = substream;\r\nif (status & UART_LSR_THRE)\r\nuart->fifo_count = 0;\r\nif (uart->adaptor == SNDRV_SERIAL_MS124W_SA\r\n|| uart->adaptor == SNDRV_SERIAL_GENERIC) {\r\nstatus = inb(uart->base + UART_MSR);\r\nwhile (uart->fifo_count == 0 && (status & UART_MSR_CTS) &&\r\nuart->buff_in_count > 0) {\r\nsnd_uart16550_buffer_output(uart);\r\nstatus = inb(uart->base + UART_MSR);\r\n}\r\n} else {\r\nwhile (uart->fifo_count < uart->fifo_limit\r\n&& uart->buff_in_count > 0)\r\nsnd_uart16550_buffer_output(uart);\r\n}\r\nif (uart->irq < 0 && uart->buff_in_count > 0)\r\nsnd_uart16550_add_timer(uart);\r\n}\r\nstatic irqreturn_t snd_uart16550_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_uart16550 *uart;\r\nuart = dev_id;\r\nspin_lock(&uart->open_lock);\r\nif (uart->filemode == SERIAL_MODE_NOT_OPENED) {\r\nspin_unlock(&uart->open_lock);\r\nreturn IRQ_NONE;\r\n}\r\ninb(uart->base + UART_IIR);\r\nsnd_uart16550_io_loop(uart);\r\nspin_unlock(&uart->open_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void snd_uart16550_buffer_timer(unsigned long data)\r\n{\r\nunsigned long flags;\r\nstruct snd_uart16550 *uart;\r\nuart = (struct snd_uart16550 *)data;\r\nspin_lock_irqsave(&uart->open_lock, flags);\r\nsnd_uart16550_del_timer(uart);\r\nsnd_uart16550_io_loop(uart);\r\nspin_unlock_irqrestore(&uart->open_lock, flags);\r\n}\r\nstatic int snd_uart16550_detect(struct snd_uart16550 *uart)\r\n{\r\nunsigned long io_base = uart->base;\r\nint ok;\r\nunsigned char c;\r\nif (io_base == 0 || io_base == SNDRV_AUTO_PORT) {\r\nreturn -ENODEV;\r\n}\r\nuart->res_base = request_region(io_base, 8, "Serial MIDI");\r\nif (uart->res_base == NULL) {\r\nsnd_printk(KERN_ERR "u16550: can't grab port 0x%lx\n", io_base);\r\nreturn -EBUSY;\r\n}\r\nok = 1;\r\noutb(UART_LCR_WLEN8, io_base + UART_LCR);\r\nc = inb(io_base + UART_IER);\r\nif ((c & 0xf0) != 0)\r\nok = 0;\r\noutb(0xaa, io_base + UART_SCR);\r\nc = inb(io_base + UART_SCR);\r\nif (c != 0xaa)\r\nok = 0;\r\noutb(0x55, io_base + UART_SCR);\r\nc = inb(io_base + UART_SCR);\r\nif (c != 0x55)\r\nok = 0;\r\nreturn ok;\r\n}\r\nstatic void snd_uart16550_do_open(struct snd_uart16550 * uart)\r\n{\r\nchar byte;\r\nuart->buff_in_count = 0;\r\nuart->buff_in = 0;\r\nuart->buff_out = 0;\r\nuart->fifo_limit = 1;\r\nuart->fifo_count = 0;\r\nuart->timer_running = 0;\r\noutb(UART_FCR_ENABLE_FIFO\r\n| UART_FCR_CLEAR_RCVR\r\n| UART_FCR_CLEAR_XMIT\r\n| UART_FCR_TRIGGER_4\r\n,uart->base + UART_FCR);\r\nif ((inb(uart->base + UART_IIR) & 0xf0) == 0xc0)\r\nuart->fifo_limit = 16;\r\nif (uart->divisor != 0) {\r\nuart->old_line_ctrl_reg = inb(uart->base + UART_LCR);\r\noutb(UART_LCR_DLAB\r\n,uart->base + UART_LCR);\r\nuart->old_divisor_lsb = inb(uart->base + UART_DLL);\r\nuart->old_divisor_msb = inb(uart->base + UART_DLM);\r\noutb(uart->divisor\r\n,uart->base + UART_DLL);\r\noutb(0\r\n,uart->base + UART_DLM);\r\n}\r\noutb(UART_LCR_WLEN8\r\n| 0\r\n| 0\r\n| 0\r\n,uart->base + UART_LCR);\r\nswitch (uart->adaptor) {\r\ndefault:\r\noutb(UART_MCR_RTS\r\n| UART_MCR_DTR\r\n| UART_MCR_OUT2\r\n,uart->base + UART_MCR);\r\nbreak;\r\ncase SNDRV_SERIAL_MS124W_SA:\r\ncase SNDRV_SERIAL_MS124W_MB:\r\noutb(UART_MCR_RTS | (0&UART_MCR_DTR) | UART_MCR_OUT2,\r\nuart->base + UART_MCR);\r\nbreak;\r\ncase SNDRV_SERIAL_MS124T:\r\noutb(UART_MCR_RTS | UART_MCR_DTR | UART_MCR_OUT2,\r\nuart->base + UART_MCR);\r\nbreak;\r\n}\r\nif (uart->irq < 0) {\r\nbyte = (0 & UART_IER_RDI)\r\n|(0 & UART_IER_THRI)\r\n;\r\n} else if (uart->adaptor == SNDRV_SERIAL_MS124W_SA) {\r\nbyte = UART_IER_RDI\r\n| UART_IER_MSI\r\n;\r\n} else if (uart->adaptor == SNDRV_SERIAL_GENERIC) {\r\nbyte = UART_IER_RDI\r\n| UART_IER_MSI\r\n| UART_IER_THRI\r\n;\r\n} else {\r\nbyte = UART_IER_RDI\r\n| UART_IER_THRI\r\n;\r\n}\r\noutb(byte, uart->base + UART_IER);\r\ninb(uart->base + UART_LSR);\r\ninb(uart->base + UART_IIR);\r\ninb(uart->base + UART_RX);\r\n}\r\nstatic void snd_uart16550_do_close(struct snd_uart16550 * uart)\r\n{\r\nif (uart->irq < 0)\r\nsnd_uart16550_del_timer(uart);\r\noutb((0 & UART_IER_RDI)\r\n|(0 & UART_IER_THRI)\r\n,uart->base + UART_IER);\r\nswitch (uart->adaptor) {\r\ndefault:\r\noutb((0 & UART_MCR_RTS)\r\n|(0 & UART_MCR_DTR)\r\n|(0 & UART_MCR_OUT2)\r\n,uart->base + UART_MCR);\r\nbreak;\r\ncase SNDRV_SERIAL_MS124W_SA:\r\ncase SNDRV_SERIAL_MS124W_MB:\r\noutb(UART_MCR_RTS | (0&UART_MCR_DTR) | (0&UART_MCR_OUT2),\r\nuart->base + UART_MCR);\r\nbreak;\r\ncase SNDRV_SERIAL_MS124T:\r\noutb(UART_MCR_RTS | UART_MCR_DTR | (0&UART_MCR_OUT2),\r\nuart->base + UART_MCR);\r\nbreak;\r\n}\r\ninb(uart->base + UART_IIR);\r\nif (uart->divisor != 0) {\r\noutb(UART_LCR_DLAB\r\n,uart->base + UART_LCR);\r\noutb(uart->old_divisor_lsb\r\n,uart->base + UART_DLL);\r\noutb(uart->old_divisor_msb\r\n,uart->base + UART_DLM);\r\noutb(uart->old_line_ctrl_reg\r\n,uart->base + UART_LCR);\r\n}\r\n}\r\nstatic int snd_uart16550_input_open(struct snd_rawmidi_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_uart16550 *uart = substream->rmidi->private_data;\r\nspin_lock_irqsave(&uart->open_lock, flags);\r\nif (uart->filemode == SERIAL_MODE_NOT_OPENED)\r\nsnd_uart16550_do_open(uart);\r\nuart->filemode |= SERIAL_MODE_INPUT_OPEN;\r\nuart->midi_input[substream->number] = substream;\r\nspin_unlock_irqrestore(&uart->open_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_uart16550_input_close(struct snd_rawmidi_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_uart16550 *uart = substream->rmidi->private_data;\r\nspin_lock_irqsave(&uart->open_lock, flags);\r\nuart->filemode &= ~SERIAL_MODE_INPUT_OPEN;\r\nuart->midi_input[substream->number] = NULL;\r\nif (uart->filemode == SERIAL_MODE_NOT_OPENED)\r\nsnd_uart16550_do_close(uart);\r\nspin_unlock_irqrestore(&uart->open_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void snd_uart16550_input_trigger(struct snd_rawmidi_substream *substream,\r\nint up)\r\n{\r\nunsigned long flags;\r\nstruct snd_uart16550 *uart = substream->rmidi->private_data;\r\nspin_lock_irqsave(&uart->open_lock, flags);\r\nif (up)\r\nuart->filemode |= SERIAL_MODE_INPUT_TRIGGERED;\r\nelse\r\nuart->filemode &= ~SERIAL_MODE_INPUT_TRIGGERED;\r\nspin_unlock_irqrestore(&uart->open_lock, flags);\r\n}\r\nstatic int snd_uart16550_output_open(struct snd_rawmidi_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_uart16550 *uart = substream->rmidi->private_data;\r\nspin_lock_irqsave(&uart->open_lock, flags);\r\nif (uart->filemode == SERIAL_MODE_NOT_OPENED)\r\nsnd_uart16550_do_open(uart);\r\nuart->filemode |= SERIAL_MODE_OUTPUT_OPEN;\r\nuart->midi_output[substream->number] = substream;\r\nspin_unlock_irqrestore(&uart->open_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_uart16550_output_close(struct snd_rawmidi_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_uart16550 *uart = substream->rmidi->private_data;\r\nspin_lock_irqsave(&uart->open_lock, flags);\r\nuart->filemode &= ~SERIAL_MODE_OUTPUT_OPEN;\r\nuart->midi_output[substream->number] = NULL;\r\nif (uart->filemode == SERIAL_MODE_NOT_OPENED)\r\nsnd_uart16550_do_close(uart);\r\nspin_unlock_irqrestore(&uart->open_lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline int snd_uart16550_buffer_can_write(struct snd_uart16550 *uart,\r\nint Num)\r\n{\r\nif (uart->buff_in_count + Num < TX_BUFF_SIZE)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline int snd_uart16550_write_buffer(struct snd_uart16550 *uart,\r\nunsigned char byte)\r\n{\r\nunsigned short buff_in = uart->buff_in;\r\nif (uart->buff_in_count < TX_BUFF_SIZE) {\r\nuart->tx_buff[buff_in] = byte;\r\nbuff_in++;\r\nbuff_in &= TX_BUFF_MASK;\r\nuart->buff_in = buff_in;\r\nuart->buff_in_count++;\r\nif (uart->irq < 0)\r\nsnd_uart16550_add_timer(uart);\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int snd_uart16550_output_byte(struct snd_uart16550 *uart,\r\nstruct snd_rawmidi_substream *substream,\r\nunsigned char midi_byte)\r\n{\r\nif (uart->buff_in_count == 0\r\n&& ((uart->adaptor != SNDRV_SERIAL_MS124W_SA &&\r\nuart->adaptor != SNDRV_SERIAL_GENERIC) ||\r\n(uart->fifo_count == 0\r\n&& (inb(uart->base + UART_MSR) & UART_MSR_CTS)))) {\r\nif ((inb(uart->base + UART_LSR) & UART_LSR_THRE) != 0) {\r\nuart->fifo_count = 1;\r\noutb(midi_byte, uart->base + UART_TX);\r\n} else {\r\nif (uart->fifo_count < uart->fifo_limit) {\r\nuart->fifo_count++;\r\noutb(midi_byte, uart->base + UART_TX);\r\n} else {\r\nsnd_uart16550_write_buffer(uart, midi_byte);\r\n}\r\n}\r\n} else {\r\nif (!snd_uart16550_write_buffer(uart, midi_byte)) {\r\nsnd_printk(KERN_WARNING\r\n"%s: Buffer overrun on device at 0x%lx\n",\r\nuart->rmidi->name, uart->base);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void snd_uart16550_output_write(struct snd_rawmidi_substream *substream)\r\n{\r\nunsigned long flags;\r\nunsigned char midi_byte, addr_byte;\r\nstruct snd_uart16550 *uart = substream->rmidi->private_data;\r\nchar first;\r\nstatic unsigned long lasttime = 0;\r\nspin_lock_irqsave(&uart->open_lock, flags);\r\nif (uart->irq < 0)\r\nsnd_uart16550_io_loop(uart);\r\nif (uart->adaptor == SNDRV_SERIAL_MS124W_MB) {\r\nwhile (1) {\r\nif (uart->buff_in_count > TX_BUFF_SIZE - 2)\r\nbreak;\r\nif (snd_rawmidi_transmit(substream, &midi_byte, 1) != 1)\r\nbreak;\r\n#ifdef SNDRV_SERIAL_MS124W_MB_NOCOMBO\r\naddr_byte = (1 << (substream->number + 4)) | 0x08;\r\n#else\r\naddr_byte = (substream->number << 4) | 0x08;\r\nif (addr_byte == 0x08)\r\naddr_byte = 0xf8;\r\n#endif\r\nsnd_uart16550_output_byte(uart, substream, addr_byte);\r\nsnd_uart16550_output_byte(uart, substream, midi_byte);\r\n}\r\n} else {\r\nfirst = 0;\r\nwhile (snd_rawmidi_transmit_peek(substream, &midi_byte, 1) == 1) {\r\nif (first == 0 &&\r\n(uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS ||\r\nuart->adaptor == SNDRV_SERIAL_GENERIC) &&\r\n(uart->prev_out != substream->number ||\r\ntime_after(jiffies, lasttime + 3*HZ))) {\r\nif (snd_uart16550_buffer_can_write(uart, 3)) {\r\nuart->prev_out = substream->number;\r\nsnd_uart16550_output_byte(uart, substream,\r\n0xf5);\r\nsnd_uart16550_output_byte(uart, substream,\r\nuart->prev_out + 1);\r\nif (midi_byte < 0x80 &&\r\nuart->adaptor == SNDRV_SERIAL_SOUNDCANVAS)\r\nsnd_uart16550_output_byte(uart, substream, uart->prev_status[uart->prev_out]);\r\n} else if (!uart->drop_on_full)\r\nbreak;\r\n}\r\nif (!snd_uart16550_output_byte(uart, substream, midi_byte) &&\r\n!uart->drop_on_full )\r\nbreak;\r\nif (midi_byte >= 0x80 && midi_byte < 0xf0)\r\nuart->prev_status[uart->prev_out] = midi_byte;\r\nfirst = 1;\r\nsnd_rawmidi_transmit_ack( substream, 1 );\r\n}\r\nlasttime = jiffies;\r\n}\r\nspin_unlock_irqrestore(&uart->open_lock, flags);\r\n}\r\nstatic void snd_uart16550_output_trigger(struct snd_rawmidi_substream *substream,\r\nint up)\r\n{\r\nunsigned long flags;\r\nstruct snd_uart16550 *uart = substream->rmidi->private_data;\r\nspin_lock_irqsave(&uart->open_lock, flags);\r\nif (up)\r\nuart->filemode |= SERIAL_MODE_OUTPUT_TRIGGERED;\r\nelse\r\nuart->filemode &= ~SERIAL_MODE_OUTPUT_TRIGGERED;\r\nspin_unlock_irqrestore(&uart->open_lock, flags);\r\nif (up)\r\nsnd_uart16550_output_write(substream);\r\n}\r\nstatic int snd_uart16550_free(struct snd_uart16550 *uart)\r\n{\r\nif (uart->irq >= 0)\r\nfree_irq(uart->irq, uart);\r\nrelease_and_free_resource(uart->res_base);\r\nkfree(uart);\r\nreturn 0;\r\n}\r\nstatic int snd_uart16550_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_uart16550 *uart = device->device_data;\r\nreturn snd_uart16550_free(uart);\r\n}\r\nstatic int snd_uart16550_create(struct snd_card *card,\r\nunsigned long iobase,\r\nint irq,\r\nunsigned int speed,\r\nunsigned int base,\r\nint adaptor,\r\nint droponfull,\r\nstruct snd_uart16550 **ruart)\r\n{\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_uart16550_dev_free,\r\n};\r\nstruct snd_uart16550 *uart;\r\nint err;\r\nif ((uart = kzalloc(sizeof(*uart), GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nuart->adaptor = adaptor;\r\nuart->card = card;\r\nspin_lock_init(&uart->open_lock);\r\nuart->irq = -1;\r\nuart->base = iobase;\r\nuart->drop_on_full = droponfull;\r\nif ((err = snd_uart16550_detect(uart)) <= 0) {\r\nprintk(KERN_ERR "no UART detected at 0x%lx\n", iobase);\r\nsnd_uart16550_free(uart);\r\nreturn -ENODEV;\r\n}\r\nif (irq >= 0 && irq != SNDRV_AUTO_IRQ) {\r\nif (request_irq(irq, snd_uart16550_interrupt,\r\n0, "Serial MIDI", uart)) {\r\nsnd_printk(KERN_WARNING\r\n"irq %d busy. Using Polling.\n", irq);\r\n} else {\r\nuart->irq = irq;\r\n}\r\n}\r\nuart->divisor = base / speed;\r\nuart->speed = base / (unsigned int)uart->divisor;\r\nuart->speed_base = base;\r\nuart->prev_out = -1;\r\nuart->prev_in = 0;\r\nuart->rstatus = 0;\r\nmemset(uart->prev_status, 0x80, sizeof(unsigned char) * SNDRV_SERIAL_MAX_OUTS);\r\ninit_timer(&uart->buffer_timer);\r\nuart->buffer_timer.function = snd_uart16550_buffer_timer;\r\nuart->buffer_timer.data = (unsigned long)uart;\r\nuart->timer_running = 0;\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, uart, &ops)) < 0) {\r\nsnd_uart16550_free(uart);\r\nreturn err;\r\n}\r\nswitch (uart->adaptor) {\r\ncase SNDRV_SERIAL_MS124W_SA:\r\ncase SNDRV_SERIAL_MS124W_MB:\r\noutb(UART_MCR_RTS | (0&UART_MCR_DTR), uart->base + UART_MCR);\r\nbreak;\r\ncase SNDRV_SERIAL_MS124T:\r\noutb(UART_MCR_RTS | UART_MCR_DTR, uart->base + UART_MCR);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ruart)\r\n*ruart = uart;\r\nreturn 0;\r\n}\r\nstatic void snd_uart16550_substreams(struct snd_rawmidi_str *stream)\r\n{\r\nstruct snd_rawmidi_substream *substream;\r\nlist_for_each_entry(substream, &stream->substreams, list) {\r\nsprintf(substream->name, "Serial MIDI %d", substream->number + 1);\r\n}\r\n}\r\nstatic int snd_uart16550_rmidi(struct snd_uart16550 *uart, int device,\r\nint outs, int ins,\r\nstruct snd_rawmidi **rmidi)\r\n{\r\nstruct snd_rawmidi *rrawmidi;\r\nint err;\r\nerr = snd_rawmidi_new(uart->card, "UART Serial MIDI", device,\r\nouts, ins, &rrawmidi);\r\nif (err < 0)\r\nreturn err;\r\nsnd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_INPUT,\r\n&snd_uart16550_input);\r\nsnd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\r\n&snd_uart16550_output);\r\nstrcpy(rrawmidi->name, "Serial MIDI");\r\nsnd_uart16550_substreams(&rrawmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT]);\r\nsnd_uart16550_substreams(&rrawmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT]);\r\nrrawmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\r\nSNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\nrrawmidi->private_data = uart;\r\nif (rmidi)\r\n*rmidi = rrawmidi;\r\nreturn 0;\r\n}\r\nstatic int snd_serial_probe(struct platform_device *devptr)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_uart16550 *uart;\r\nint err;\r\nint dev = devptr->id;\r\nswitch (adaptor[dev]) {\r\ncase SNDRV_SERIAL_SOUNDCANVAS:\r\nins[dev] = 1;\r\nbreak;\r\ncase SNDRV_SERIAL_MS124T:\r\ncase SNDRV_SERIAL_MS124W_SA:\r\nouts[dev] = 1;\r\nins[dev] = 1;\r\nbreak;\r\ncase SNDRV_SERIAL_MS124W_MB:\r\nouts[dev] = 16;\r\nins[dev] = 1;\r\nbreak;\r\ncase SNDRV_SERIAL_GENERIC:\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR\r\n"Adaptor type is out of range 0-%d (%d)\n",\r\nSNDRV_SERIAL_MAX_ADAPTOR, adaptor[dev]);\r\nreturn -ENODEV;\r\n}\r\nif (outs[dev] < 1 || outs[dev] > SNDRV_SERIAL_MAX_OUTS) {\r\nsnd_printk(KERN_ERR\r\n"Count of outputs is out of range 1-%d (%d)\n",\r\nSNDRV_SERIAL_MAX_OUTS, outs[dev]);\r\nreturn -ENODEV;\r\n}\r\nif (ins[dev] < 1 || ins[dev] > SNDRV_SERIAL_MAX_INS) {\r\nsnd_printk(KERN_ERR\r\n"Count of inputs is out of range 1-%d (%d)\n",\r\nSNDRV_SERIAL_MAX_INS, ins[dev]);\r\nreturn -ENODEV;\r\n}\r\nerr = snd_card_new(&devptr->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0)\r\nreturn err;\r\nstrcpy(card->driver, "Serial");\r\nstrcpy(card->shortname, "Serial MIDI (UART16550A)");\r\nif ((err = snd_uart16550_create(card,\r\nport[dev],\r\nirq[dev],\r\nspeed[dev],\r\nbase[dev],\r\nadaptor[dev],\r\ndroponfull[dev],\r\n&uart)) < 0)\r\ngoto _err;\r\nerr = snd_uart16550_rmidi(uart, 0, outs[dev], ins[dev], &uart->rmidi);\r\nif (err < 0)\r\ngoto _err;\r\nsprintf(card->longname, "%s [%s] at %#lx, irq %d",\r\ncard->shortname,\r\nadaptor_names[uart->adaptor],\r\nuart->base,\r\nuart->irq);\r\nif ((err = snd_card_register(card)) < 0)\r\ngoto _err;\r\nplatform_set_drvdata(devptr, card);\r\nreturn 0;\r\n_err:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int snd_serial_remove(struct platform_device *devptr)\r\n{\r\nsnd_card_free(platform_get_drvdata(devptr));\r\nreturn 0;\r\n}\r\nstatic void snd_serial_unregister_all(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(devices); ++i)\r\nplatform_device_unregister(devices[i]);\r\nplatform_driver_unregister(&snd_serial_driver);\r\n}\r\nstatic int __init alsa_card_serial_init(void)\r\n{\r\nint i, cards, err;\r\nif ((err = platform_driver_register(&snd_serial_driver)) < 0)\r\nreturn err;\r\ncards = 0;\r\nfor (i = 0; i < SNDRV_CARDS; i++) {\r\nstruct platform_device *device;\r\nif (! enable[i])\r\ncontinue;\r\ndevice = platform_device_register_simple(SND_SERIAL_DRIVER,\r\ni, NULL, 0);\r\nif (IS_ERR(device))\r\ncontinue;\r\nif (!platform_get_drvdata(device)) {\r\nplatform_device_unregister(device);\r\ncontinue;\r\n}\r\ndevices[i] = device;\r\ncards++;\r\n}\r\nif (! cards) {\r\n#ifdef MODULE\r\nprintk(KERN_ERR "serial midi soundcard not found or device busy\n");\r\n#endif\r\nsnd_serial_unregister_all();\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_card_serial_exit(void)\r\n{\r\nsnd_serial_unregister_all();\r\n}
