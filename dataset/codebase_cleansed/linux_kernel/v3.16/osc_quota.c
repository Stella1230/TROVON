static inline struct osc_quota_info *osc_oqi_alloc(obd_uid id)\r\n{\r\nstruct osc_quota_info *oqi;\r\nOBD_SLAB_ALLOC_PTR(oqi, osc_quota_kmem);\r\nif (oqi != NULL)\r\noqi->oqi_id = id;\r\nreturn oqi;\r\n}\r\nint osc_quota_chkdq(struct client_obd *cli, const unsigned int qid[])\r\n{\r\nint type;\r\nfor (type = 0; type < MAXQUOTAS; type++) {\r\nstruct osc_quota_info *oqi;\r\noqi = cfs_hash_lookup(cli->cl_quota_hash[type], &qid[type]);\r\nif (oqi) {\r\nCDEBUG(D_QUOTA, "chkdq found noquota for %s %d\n",\r\ntype == USRQUOTA ? "user" : "grout", qid[type]);\r\nreturn NO_QUOTA;\r\n}\r\n}\r\nreturn QUOTA_OK;\r\n}\r\nint osc_quota_setdq(struct client_obd *cli, const unsigned int qid[],\r\nobd_flag valid, obd_flag flags)\r\n{\r\nint type;\r\nint rc = 0;\r\nif ((valid & (OBD_MD_FLUSRQUOTA | OBD_MD_FLGRPQUOTA)) == 0)\r\nreturn 0;\r\nfor (type = 0; type < MAXQUOTAS; type++) {\r\nstruct osc_quota_info *oqi;\r\nif ((valid & MD_QUOTA_FLAG(type)) == 0)\r\ncontinue;\r\noqi = cfs_hash_lookup(cli->cl_quota_hash[type], &qid[type]);\r\nif ((flags & FL_QUOTA_FLAG(type)) != 0) {\r\nif (oqi != NULL)\r\ncontinue;\r\noqi = osc_oqi_alloc(qid[type]);\r\nif (oqi == NULL) {\r\nrc = -ENOMEM;\r\nbreak;\r\n}\r\nrc = cfs_hash_add_unique(cli->cl_quota_hash[type],\r\n&qid[type], &oqi->oqi_hash);\r\nif (rc == -EALREADY) {\r\nrc = 0;\r\nOBD_SLAB_FREE_PTR(oqi, osc_quota_kmem);\r\n}\r\nCDEBUG(D_QUOTA, "%s: setdq to insert for %s %d (%d)\n",\r\ncli->cl_import->imp_obd->obd_name,\r\ntype == USRQUOTA ? "user" : "group",\r\nqid[type], rc);\r\n} else {\r\nif (oqi == NULL)\r\ncontinue;\r\noqi = cfs_hash_del_key(cli->cl_quota_hash[type],\r\n&qid[type]);\r\nif (oqi)\r\nOBD_SLAB_FREE_PTR(oqi, osc_quota_kmem);\r\nCDEBUG(D_QUOTA, "%s: setdq to remove for %s %d (%p)\n",\r\ncli->cl_import->imp_obd->obd_name,\r\ntype == USRQUOTA ? "user" : "group",\r\nqid[type], oqi);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic unsigned\r\noqi_hashfn(struct cfs_hash *hs, const void *key, unsigned mask)\r\n{\r\nreturn cfs_hash_u32_hash(*((__u32*)key), mask);\r\n}\r\nstatic int\r\noqi_keycmp(const void *key, struct hlist_node *hnode)\r\n{\r\nstruct osc_quota_info *oqi;\r\nobd_uid uid;\r\nLASSERT(key != NULL);\r\nuid = *((obd_uid*)key);\r\noqi = hlist_entry(hnode, struct osc_quota_info, oqi_hash);\r\nreturn uid == oqi->oqi_id;\r\n}\r\nstatic void *\r\noqi_key(struct hlist_node *hnode)\r\n{\r\nstruct osc_quota_info *oqi;\r\noqi = hlist_entry(hnode, struct osc_quota_info, oqi_hash);\r\nreturn &oqi->oqi_id;\r\n}\r\nstatic void *\r\noqi_object(struct hlist_node *hnode)\r\n{\r\nreturn hlist_entry(hnode, struct osc_quota_info, oqi_hash);\r\n}\r\nstatic void\r\noqi_get(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\n}\r\nstatic void\r\noqi_put_locked(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\n}\r\nstatic void\r\noqi_exit(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct osc_quota_info *oqi;\r\noqi = hlist_entry(hnode, struct osc_quota_info, oqi_hash);\r\nOBD_SLAB_FREE_PTR(oqi, osc_quota_kmem);\r\n}\r\nint osc_quota_setup(struct obd_device *obd)\r\n{\r\nstruct client_obd *cli = &obd->u.cli;\r\nint i, type;\r\nfor (type = 0; type < MAXQUOTAS; type++) {\r\ncli->cl_quota_hash[type] = cfs_hash_create("QUOTA_HASH",\r\nHASH_QUOTA_CUR_BITS,\r\nHASH_QUOTA_MAX_BITS,\r\nHASH_QUOTA_BKT_BITS,\r\n0,\r\nCFS_HASH_MIN_THETA,\r\nCFS_HASH_MAX_THETA,\r\n&quota_hash_ops,\r\nCFS_HASH_DEFAULT);\r\nif (cli->cl_quota_hash[type] == NULL)\r\nbreak;\r\n}\r\nif (type == MAXQUOTAS)\r\nreturn 0;\r\nfor (i = 0; i < type; i++)\r\ncfs_hash_putref(cli->cl_quota_hash[i]);\r\nreturn -ENOMEM;\r\n}\r\nint osc_quota_cleanup(struct obd_device *obd)\r\n{\r\nstruct client_obd *cli = &obd->u.cli;\r\nint type;\r\nfor (type = 0; type < MAXQUOTAS; type++)\r\ncfs_hash_putref(cli->cl_quota_hash[type]);\r\nreturn 0;\r\n}\r\nint osc_quotactl(struct obd_device *unused, struct obd_export *exp,\r\nstruct obd_quotactl *oqctl)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct obd_quotactl *oqc;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),\r\n&RQF_OST_QUOTACTL, LUSTRE_OST_VERSION,\r\nOST_QUOTACTL);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\noqc = req_capsule_client_get(&req->rq_pill, &RMF_OBD_QUOTACTL);\r\n*oqc = *oqctl;\r\nptlrpc_request_set_replen(req);\r\nptlrpc_at_set_req_timeout(req);\r\nreq->rq_no_resend = 1;\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nCERROR("ptlrpc_queue_wait failed, rc: %d\n", rc);\r\nif (req->rq_repmsg) {\r\noqc = req_capsule_server_get(&req->rq_pill, &RMF_OBD_QUOTACTL);\r\nif (oqc) {\r\n*oqctl = *oqc;\r\n} else if (!rc) {\r\nCERROR("Can't unpack obd_quotactl\n");\r\nrc = -EPROTO;\r\n}\r\n} else if (!rc) {\r\nCERROR("Can't unpack obd_quotactl\n");\r\nrc = -EPROTO;\r\n}\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nint osc_quotacheck(struct obd_device *unused, struct obd_export *exp,\r\nstruct obd_quotactl *oqctl)\r\n{\r\nstruct client_obd *cli = &exp->exp_obd->u.cli;\r\nstruct ptlrpc_request *req;\r\nstruct obd_quotactl *body;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),\r\n&RQF_OST_QUOTACHECK, LUSTRE_OST_VERSION,\r\nOST_QUOTACHECK);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_OBD_QUOTACTL);\r\n*body = *oqctl;\r\nptlrpc_request_set_replen(req);\r\ncli->cl_qchk_stat = -ENODATA;\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\ncli->cl_qchk_stat = rc;\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nint osc_quota_poll_check(struct obd_export *exp, struct if_quotacheck *qchk)\r\n{\r\nstruct client_obd *cli = &exp->exp_obd->u.cli;\r\nint rc;\r\nqchk->obd_uuid = cli->cl_target_uuid;\r\nmemcpy(qchk->obd_type, LUSTRE_OST_NAME, strlen(LUSTRE_OST_NAME));\r\nrc = cli->cl_qchk_stat;\r\nif (rc == CL_NOT_QUOTACHECKED)\r\nrc = -EINTR;\r\nreturn rc;\r\n}
