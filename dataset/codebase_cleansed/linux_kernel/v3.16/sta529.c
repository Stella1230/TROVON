static bool sta529_readable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase STA529_FFXCFG0:\r\ncase STA529_FFXCFG1:\r\ncase STA529_MVOL:\r\ncase STA529_LVOL:\r\ncase STA529_RVOL:\r\ncase STA529_S2PCFG0:\r\ncase STA529_S2PCFG1:\r\ncase STA529_P2SCFG0:\r\ncase STA529_P2SCFG1:\r\ncase STA529_ADCCFG:\r\ncase STA529_CKOCFG:\r\ncase STA529_MISC:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int sta529_set_bias_level(struct snd_soc_codec *codec, enum\r\nsnd_soc_bias_level level)\r\n{\r\nstruct sta529 *sta529 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, STA529_FFXCFG0, POWER_CNTLMSAK,\r\nPOWER_UP);\r\nsnd_soc_update_bits(codec, STA529_MISC, FFX_CLK_MSK,\r\nFFX_CLK_ENB);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF)\r\nregcache_sync(sta529->regmap);\r\nsnd_soc_update_bits(codec, STA529_FFXCFG0,\r\nPOWER_CNTLMSAK, POWER_STDBY);\r\nsnd_soc_update_bits(codec, STA529_FFXCFG0, FFX_MASK,\r\nFFX_OFF);\r\nsnd_soc_update_bits(codec, STA529_MISC, FFX_CLK_MSK,\r\nFFX_CLK_DIS);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int sta529_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint pdata, play_freq_val, record_freq_val;\r\nint bclk_to_fs_ratio;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\npdata = 1;\r\nbclk_to_fs_ratio = 0;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\npdata = 2;\r\nbclk_to_fs_ratio = 1;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\npdata = 3;\r\nbclk_to_fs_ratio = 2;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported format\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\ncase 11025:\r\nplay_freq_val = 0;\r\nrecord_freq_val = 2;\r\nbreak;\r\ncase 16000:\r\ncase 22050:\r\nplay_freq_val = 1;\r\nrecord_freq_val = 0;\r\nbreak;\r\ncase 32000:\r\ncase 44100:\r\ncase 48000:\r\nplay_freq_val = 2;\r\nrecord_freq_val = 0;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported rate\n");\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsnd_soc_update_bits(codec, STA529_S2PCFG1, PDATA_LEN_MSK,\r\npdata << 6);\r\nsnd_soc_update_bits(codec, STA529_S2PCFG1, BCLK_TO_FS_MSK,\r\nbclk_to_fs_ratio << 4);\r\nsnd_soc_update_bits(codec, STA529_MISC, PLAY_FREQ_RANGE_MSK,\r\nplay_freq_val << 4);\r\n} else {\r\nsnd_soc_update_bits(codec, STA529_P2SCFG1, PDATA_LEN_MSK,\r\npdata << 6);\r\nsnd_soc_update_bits(codec, STA529_P2SCFG1, BCLK_TO_FS_MSK,\r\nbclk_to_fs_ratio << 4);\r\nsnd_soc_update_bits(codec, STA529_MISC, CAP_FREQ_RANGE_MSK,\r\nrecord_freq_val << 2);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sta529_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nu8 val = 0;\r\nif (mute)\r\nval |= CODEC_MUTE_VAL;\r\nsnd_soc_update_bits(dai->codec, STA529_FFXCFG0, AUDIO_MUTE_MSK, val);\r\nreturn 0;\r\n}\r\nstatic int sta529_set_dai_fmt(struct snd_soc_dai *codec_dai, u32 fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu8 mode = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nmode = LEFT_J_DATA_FORMAT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nmode = I2S_DATA_FORMAT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nmode = RIGHT_J_DATA_FORMAT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, STA529_S2PCFG0, DATA_FORMAT_MSK, mode);\r\nreturn 0;\r\n}\r\nstatic int sta529_probe(struct snd_soc_codec *codec)\r\n{\r\nsta529_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int sta529_remove(struct snd_soc_codec *codec)\r\n{\r\nsta529_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int sta529_suspend(struct snd_soc_codec *codec)\r\n{\r\nsta529_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int sta529_resume(struct snd_soc_codec *codec)\r\n{\r\nsta529_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int sta529_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct sta529 *sta529;\r\nint ret;\r\nif (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EINVAL;\r\nsta529 = devm_kzalloc(&i2c->dev, sizeof(struct sta529), GFP_KERNEL);\r\nif (sta529 == NULL) {\r\ndev_err(&i2c->dev, "Can not allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nsta529->regmap = devm_regmap_init_i2c(i2c, &sta529_regmap);\r\nif (IS_ERR(sta529->regmap)) {\r\nret = PTR_ERR(sta529->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(i2c, sta529);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&sta529_codec_driver, &sta529_dai, 1);\r\nif (ret != 0)\r\ndev_err(&i2c->dev, "Failed to register CODEC: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int sta529_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
