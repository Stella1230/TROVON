static ssize_t omap_fbdev_write(struct fb_info *fbi, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nssize_t res;\r\nres = fb_sys_write(fbi, buf, count, ppos);\r\nomap_fbdev_flush(fbi, 0, 0, fbi->var.xres, fbi->var.yres);\r\nreturn res;\r\n}\r\nstatic void omap_fbdev_fillrect(struct fb_info *fbi,\r\nconst struct fb_fillrect *rect)\r\n{\r\nsys_fillrect(fbi, rect);\r\nomap_fbdev_flush(fbi, rect->dx, rect->dy, rect->width, rect->height);\r\n}\r\nstatic void omap_fbdev_copyarea(struct fb_info *fbi,\r\nconst struct fb_copyarea *area)\r\n{\r\nsys_copyarea(fbi, area);\r\nomap_fbdev_flush(fbi, area->dx, area->dy, area->width, area->height);\r\n}\r\nstatic void omap_fbdev_imageblit(struct fb_info *fbi,\r\nconst struct fb_image *image)\r\n{\r\nsys_imageblit(fbi, image);\r\nomap_fbdev_flush(fbi, image->dx, image->dy,\r\nimage->width, image->height);\r\n}\r\nstatic void pan_worker(struct work_struct *work)\r\n{\r\nstruct omap_fbdev *fbdev = container_of(work, struct omap_fbdev, work);\r\nstruct fb_info *fbi = fbdev->base.fbdev;\r\nint npages;\r\nnpages = fbi->fix.line_length >> PAGE_SHIFT;\r\nomap_gem_roll(fbdev->bo, fbi->var.yoffset * npages);\r\n}\r\nstatic int omap_fbdev_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *fbi)\r\n{\r\nstruct drm_fb_helper *helper = get_fb(fbi);\r\nstruct omap_fbdev *fbdev = to_omap_fbdev(helper);\r\nif (!helper)\r\ngoto fallback;\r\nif (!fbdev->ywrap_enabled)\r\ngoto fallback;\r\nif (drm_can_sleep()) {\r\npan_worker(&fbdev->work);\r\n} else {\r\nstruct omap_drm_private *priv = helper->dev->dev_private;\r\nqueue_work(priv->wq, &fbdev->work);\r\n}\r\nreturn 0;\r\nfallback:\r\nreturn drm_fb_helper_pan_display(var, fbi);\r\n}\r\nstatic int omap_fbdev_create(struct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct omap_fbdev *fbdev = to_omap_fbdev(helper);\r\nstruct drm_device *dev = helper->dev;\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_framebuffer *fb = NULL;\r\nunion omap_gem_size gsize;\r\nstruct fb_info *fbi = NULL;\r\nstruct drm_mode_fb_cmd2 mode_cmd = {0};\r\ndma_addr_t paddr;\r\nint ret;\r\nsizes->surface_bpp = 32;\r\nsizes->surface_depth = 32;\r\nDBG("create fbdev: %dx%d@%d (%dx%d)", sizes->surface_width,\r\nsizes->surface_height, sizes->surface_bpp,\r\nsizes->fb_width, sizes->fb_height);\r\nmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\r\nsizes->surface_depth);\r\nmode_cmd.width = sizes->surface_width;\r\nmode_cmd.height = sizes->surface_height;\r\nmode_cmd.pitches[0] = align_pitch(\r\nmode_cmd.width * ((sizes->surface_bpp + 7) / 8),\r\nmode_cmd.width, sizes->surface_bpp);\r\nfbdev->ywrap_enabled = priv->has_dmm && ywrap_enabled;\r\nif (fbdev->ywrap_enabled) {\r\nmode_cmd.pitches[0] = ALIGN(mode_cmd.pitches[0], PAGE_SIZE);\r\n}\r\ngsize = (union omap_gem_size){\r\n.bytes = PAGE_ALIGN(mode_cmd.pitches[0] * mode_cmd.height),\r\n};\r\nDBG("allocating %d bytes for fb %d", gsize.bytes, dev->primary->index);\r\nfbdev->bo = omap_gem_new(dev, gsize, OMAP_BO_SCANOUT | OMAP_BO_WC);\r\nif (!fbdev->bo) {\r\ndev_err(dev->dev, "failed to allocate buffer object\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nfb = omap_framebuffer_init(dev, &mode_cmd, &fbdev->bo);\r\nif (IS_ERR(fb)) {\r\ndev_err(dev->dev, "failed to allocate fb\n");\r\ndrm_gem_object_unreference(fbdev->bo);\r\nret = PTR_ERR(fb);\r\ngoto fail;\r\n}\r\nret = omap_gem_get_paddr(fbdev->bo, &paddr, true);\r\nif (ret) {\r\ndev_err(dev->dev,\r\n"could not map (paddr)! Skipping framebuffer alloc\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nfbi = framebuffer_alloc(0, dev->dev);\r\nif (!fbi) {\r\ndev_err(dev->dev, "failed to allocate fb info\n");\r\nret = -ENOMEM;\r\ngoto fail_unlock;\r\n}\r\nDBG("fbi=%p, dev=%p", fbi, dev);\r\nfbdev->fb = fb;\r\nhelper->fb = fb;\r\nhelper->fbdev = fbi;\r\nfbi->par = helper;\r\nfbi->flags = FBINFO_DEFAULT;\r\nfbi->fbops = &omap_fb_ops;\r\nstrcpy(fbi->fix.id, MODULE_NAME);\r\nret = fb_alloc_cmap(&fbi->cmap, 256, 0);\r\nif (ret) {\r\nret = -ENOMEM;\r\ngoto fail_unlock;\r\n}\r\ndrm_fb_helper_fill_fix(fbi, fb->pitches[0], fb->depth);\r\ndrm_fb_helper_fill_var(fbi, helper, sizes->fb_width, sizes->fb_height);\r\ndev->mode_config.fb_base = paddr;\r\nfbi->screen_base = omap_gem_vaddr(fbdev->bo);\r\nfbi->screen_size = fbdev->bo->size;\r\nfbi->fix.smem_start = paddr;\r\nfbi->fix.smem_len = fbdev->bo->size;\r\nif (fbdev->ywrap_enabled) {\r\nDRM_INFO("Enabling DMM ywrap scrolling\n");\r\nfbi->flags |= FBINFO_HWACCEL_YWRAP | FBINFO_READS_FAST;\r\nfbi->fix.ywrapstep = 1;\r\n}\r\nDBG("par=%p, %dx%d", fbi->par, fbi->var.xres, fbi->var.yres);\r\nDBG("allocated %dx%d fb", fbdev->fb->width, fbdev->fb->height);\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\nfail_unlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nfail:\r\nif (ret) {\r\nif (fbi)\r\nframebuffer_release(fbi);\r\nif (fb) {\r\ndrm_framebuffer_unregister_private(fb);\r\ndrm_framebuffer_remove(fb);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic struct drm_fb_helper *get_fb(struct fb_info *fbi)\r\n{\r\nif (!fbi || strcmp(fbi->fix.id, MODULE_NAME)) {\r\nreturn NULL;\r\n}\r\nreturn fbi->par;\r\n}\r\nstatic void omap_fbdev_flush(struct fb_info *fbi, int x, int y, int w, int h)\r\n{\r\nstruct drm_fb_helper *helper = get_fb(fbi);\r\nif (!helper)\r\nreturn;\r\nVERB("flush fbdev: %d,%d %dx%d, fbi=%p", x, y, w, h, fbi);\r\nomap_framebuffer_flush(helper->fb, x, y, w, h);\r\n}\r\nstruct drm_fb_helper *omap_fbdev_init(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct omap_fbdev *fbdev = NULL;\r\nstruct drm_fb_helper *helper;\r\nint ret = 0;\r\nfbdev = kzalloc(sizeof(*fbdev), GFP_KERNEL);\r\nif (!fbdev)\r\ngoto fail;\r\nINIT_WORK(&fbdev->work, pan_worker);\r\nhelper = &fbdev->base;\r\nhelper->funcs = &omap_fb_helper_funcs;\r\nret = drm_fb_helper_init(dev, helper,\r\npriv->num_crtcs, priv->num_connectors);\r\nif (ret) {\r\ndev_err(dev->dev, "could not init fbdev: ret=%d\n", ret);\r\ngoto fail;\r\n}\r\ndrm_fb_helper_single_add_all_connectors(helper);\r\ndrm_helper_disable_unused_functions(dev);\r\ndrm_fb_helper_initial_config(helper, 32);\r\npriv->fbdev = helper;\r\nreturn helper;\r\nfail:\r\nkfree(fbdev);\r\nreturn NULL;\r\n}\r\nvoid omap_fbdev_free(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_fb_helper *helper = priv->fbdev;\r\nstruct omap_fbdev *fbdev;\r\nstruct fb_info *fbi;\r\nDBG();\r\nfbi = helper->fbdev;\r\nif (fbi) {\r\nunregister_framebuffer(fbi);\r\nframebuffer_release(fbi);\r\n}\r\ndrm_fb_helper_fini(helper);\r\nfbdev = to_omap_fbdev(priv->fbdev);\r\nomap_gem_put_paddr(fbdev->bo);\r\nif (fbdev->fb) {\r\ndrm_framebuffer_unregister_private(fbdev->fb);\r\ndrm_framebuffer_remove(fbdev->fb);\r\n}\r\nkfree(fbdev);\r\npriv->fbdev = NULL;\r\n}
