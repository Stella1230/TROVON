static inline struct lpc32xx_udc *to_udc(struct usb_gadget *g)\r\n{\r\nreturn container_of(g, struct lpc32xx_udc, gadget);\r\n}\r\nstatic void proc_ep_show(struct seq_file *s, struct lpc32xx_ep *ep)\r\n{\r\nstruct lpc32xx_request *req;\r\nseq_printf(s, "\n");\r\nseq_printf(s, "%12s, maxpacket %4d %3s",\r\nep->ep.name, ep->ep.maxpacket,\r\nep->is_in ? "in" : "out");\r\nseq_printf(s, " type %4s", epnames[ep->eptype]);\r\nseq_printf(s, " ints: %12d", ep->totalints);\r\nif (list_empty(&ep->queue))\r\nseq_printf(s, "\t(queue empty)\n");\r\nelse {\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nu32 length = req->req.actual;\r\nseq_printf(s, "\treq %p len %d/%d buf %p\n",\r\n&req->req, length,\r\nreq->req.length, req->req.buf);\r\n}\r\n}\r\n}\r\nstatic int proc_udc_show(struct seq_file *s, void *unused)\r\n{\r\nstruct lpc32xx_udc *udc = s->private;\r\nstruct lpc32xx_ep *ep;\r\nunsigned long flags;\r\nseq_printf(s, "%s: version %s\n", driver_name, DRIVER_VERSION);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nseq_printf(s, "vbus %s, pullup %s, %s powered%s, gadget %s\n\n",\r\nudc->vbus ? "present" : "off",\r\nudc->enabled ? (udc->vbus ? "active" : "enabled") :\r\n"disabled",\r\nudc->selfpowered ? "self" : "VBUS",\r\nudc->suspended ? ", suspended" : "",\r\nudc->driver ? udc->driver->driver.name : "(none)");\r\nif (udc->enabled && udc->vbus) {\r\nproc_ep_show(s, &udc->ep[0]);\r\nlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list)\r\nproc_ep_show(s, ep);\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int proc_udc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_udc_show, PDE_DATA(inode));\r\n}\r\nstatic void create_debug_file(struct lpc32xx_udc *udc)\r\n{\r\nudc->pde = debugfs_create_file(debug_filename, 0, NULL, udc, &proc_ops);\r\n}\r\nstatic void remove_debug_file(struct lpc32xx_udc *udc)\r\n{\r\nif (udc->pde)\r\ndebugfs_remove(udc->pde);\r\n}\r\nstatic inline void create_debug_file(struct lpc32xx_udc *udc) {}\r\nstatic inline void remove_debug_file(struct lpc32xx_udc *udc) {}\r\nstatic void isp1301_udc_configure(struct lpc32xx_udc *udc)\r\n{\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\n(ISP1301_I2C_MODE_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),\r\nMC1_UART_EN);\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\n(ISP1301_I2C_MODE_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR), ~0);\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_MODE_CONTROL_1, (MC1_SPEED_REG | MC1_DAT_SE0));\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\n(ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR), ~0);\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_MODE_CONTROL_2, (MC2_BI_DI | MC2_SPD_SUSP_CTRL));\r\nif (udc->board->vbus_drv_pol != 0)\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_OTG_CONTROL_1, OTG1_VBUS_DRV);\r\nelse\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR,\r\nOTG1_VBUS_DRV);\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\n(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR), ~0);\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_OTG_CONTROL_1,\r\n(0 | OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN));\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_OTG_CONTROL_1, OTG1_VBUS_DISCHRG);\r\nmsleep(1);\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\n(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),\r\nOTG1_VBUS_DISCHRG);\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_INTERRUPT_FALLING, INT_VBUS_VLD);\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_INTERRUPT_RISING, INT_VBUS_VLD);\r\nwritel((readl(USB_CTRL) | USB_DEV_NEED_CLK_EN), USB_CTRL);\r\ndev_info(udc->dev, "ISP1301 Vendor ID : 0x%04x\n",\r\ni2c_smbus_read_word_data(udc->isp1301_i2c_client, 0x00));\r\ndev_info(udc->dev, "ISP1301 Product ID : 0x%04x\n",\r\ni2c_smbus_read_word_data(udc->isp1301_i2c_client, 0x02));\r\ndev_info(udc->dev, "ISP1301 Version ID : 0x%04x\n",\r\ni2c_smbus_read_word_data(udc->isp1301_i2c_client, 0x14));\r\n}\r\nstatic void isp1301_pullup_set(struct lpc32xx_udc *udc)\r\n{\r\nif (udc->pullup)\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_OTG_CONTROL_1, OTG1_DP_PULLUP);\r\nelse\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR,\r\nOTG1_DP_PULLUP);\r\n}\r\nstatic void pullup_work(struct work_struct *work)\r\n{\r\nstruct lpc32xx_udc *udc =\r\ncontainer_of(work, struct lpc32xx_udc, pullup_job);\r\nisp1301_pullup_set(udc);\r\n}\r\nstatic void isp1301_pullup_enable(struct lpc32xx_udc *udc, int en_pullup,\r\nint block)\r\n{\r\nif (en_pullup == udc->pullup)\r\nreturn;\r\nudc->pullup = en_pullup;\r\nif (block)\r\nisp1301_pullup_set(udc);\r\nelse\r\nschedule_work(&udc->pullup_job);\r\n}\r\nstatic void isp1301_set_powerstate(struct lpc32xx_udc *udc, int enable)\r\n{\r\nif (enable != 0)\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR,\r\nMC2_GLOBAL_PWR_DN);\r\nelse\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_MODE_CONTROL_2, MC2_GLOBAL_PWR_DN);\r\n}\r\nstatic void power_work(struct work_struct *work)\r\n{\r\nstruct lpc32xx_udc *udc =\r\ncontainer_of(work, struct lpc32xx_udc, power_job);\r\nisp1301_set_powerstate(udc, udc->poweron);\r\n}\r\nstatic void udc_protocol_cmd_w(struct lpc32xx_udc *udc, u32 cmd)\r\n{\r\nu32 pass = 0;\r\nint to;\r\nu32 tmp = readl(USBD_DEVINTST(udc->udp_baseaddr));\r\n(void) tmp;\r\nwhile (pass == 0) {\r\nwritel(USBD_CCEMPTY, USBD_DEVINTCLR(udc->udp_baseaddr));\r\nwritel(cmd, USBD_CMDCODE(udc->udp_baseaddr));\r\nto = 10000;\r\nwhile (((readl(USBD_DEVINTST(udc->udp_baseaddr)) &\r\nUSBD_CCEMPTY) == 0) && (to > 0)) {\r\nto--;\r\n}\r\nif (to > 0)\r\npass = 1;\r\ncpu_relax();\r\n}\r\n}\r\nstatic inline void udc_protocol_cmd_data_w(struct lpc32xx_udc *udc, u32 cmd,\r\nu32 data)\r\n{\r\nudc_protocol_cmd_w(udc, cmd);\r\nudc_protocol_cmd_w(udc, data);\r\n}\r\nstatic u32 udc_protocol_cmd_r(struct lpc32xx_udc *udc, u32 cmd)\r\n{\r\nu32 tmp;\r\nint to = 1000;\r\nwritel((USBD_CDFULL | USBD_CCEMPTY),\r\nUSBD_DEVINTCLR(udc->udp_baseaddr));\r\nudc_protocol_cmd_w(udc, cmd);\r\ntmp = readl(USBD_DEVINTST(udc->udp_baseaddr));\r\nwhile ((!(readl(USBD_DEVINTST(udc->udp_baseaddr)) & USBD_CDFULL))\r\n&& (to > 0))\r\nto--;\r\nif (!to)\r\ndev_dbg(udc->dev,\r\n"Protocol engine didn't receive response (CDFULL)\n");\r\nreturn readl(USBD_CMDDATA(udc->udp_baseaddr));\r\n}\r\nstatic inline void uda_enable_devint(struct lpc32xx_udc *udc, u32 devmask)\r\n{\r\nudc->enabled_devints |= devmask;\r\nwritel(udc->enabled_devints, USBD_DEVINTEN(udc->udp_baseaddr));\r\n}\r\nstatic inline void uda_disable_devint(struct lpc32xx_udc *udc, u32 mask)\r\n{\r\nudc->enabled_devints &= ~mask;\r\nwritel(udc->enabled_devints, USBD_DEVINTEN(udc->udp_baseaddr));\r\n}\r\nstatic inline void uda_clear_devint(struct lpc32xx_udc *udc, u32 mask)\r\n{\r\nwritel(mask, USBD_DEVINTCLR(udc->udp_baseaddr));\r\n}\r\nstatic void uda_enable_hwepint(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nudc->enabled_hwepints |= (1 << hwep);\r\nwritel(udc->enabled_hwepints, USBD_EPINTEN(udc->udp_baseaddr));\r\n}\r\nstatic void uda_disable_hwepint(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nudc->enabled_hwepints &= ~(1 << hwep);\r\nwritel(udc->enabled_hwepints, USBD_EPINTEN(udc->udp_baseaddr));\r\n}\r\nstatic inline void uda_clear_hwepint(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nwritel((1 << hwep), USBD_EPINTCLR(udc->udp_baseaddr));\r\n}\r\nstatic inline void udc_ep_dma_enable(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nwritel((1 << hwep), USBD_EPDMAEN(udc->udp_baseaddr));\r\n}\r\nstatic inline void udc_ep_dma_disable(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nwritel((1 << hwep), USBD_EPDMADIS(udc->udp_baseaddr));\r\n}\r\nstatic void udc_realize_hwep(struct lpc32xx_udc *udc, u32 hwep,\r\nu32 maxpacket)\r\n{\r\nint to = 1000;\r\nwritel(USBD_EP_RLZED, USBD_DEVINTCLR(udc->udp_baseaddr));\r\nwritel(hwep, USBD_EPIND(udc->udp_baseaddr));\r\nudc->realized_eps |= (1 << hwep);\r\nwritel(udc->realized_eps, USBD_REEP(udc->udp_baseaddr));\r\nwritel(maxpacket, USBD_EPMAXPSIZE(udc->udp_baseaddr));\r\nwhile ((!(readl(USBD_DEVINTST(udc->udp_baseaddr)) &\r\nUSBD_EP_RLZED)) && (to > 0))\r\nto--;\r\nif (!to)\r\ndev_dbg(udc->dev, "EP not correctly realized in hardware\n");\r\nwritel(USBD_EP_RLZED, USBD_DEVINTCLR(udc->udp_baseaddr));\r\n}\r\nstatic void udc_unrealize_hwep(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nudc->realized_eps &= ~(1 << hwep);\r\nwritel(udc->realized_eps, USBD_REEP(udc->udp_baseaddr));\r\n}\r\nstatic u32 udc_selep_clrint(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nudc_protocol_cmd_w(udc, CMD_SEL_EP_CLRI(hwep));\r\nreturn udc_protocol_cmd_r(udc, DAT_SEL_EP_CLRI(hwep));\r\n}\r\nstatic void udc_disable_hwep(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nudc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(hwep),\r\nDAT_WR_BYTE(EP_STAT_DA));\r\n}\r\nstatic void udc_stall_hwep(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nudc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(hwep),\r\nDAT_WR_BYTE(EP_STAT_ST));\r\n}\r\nstatic void udc_clrstall_hwep(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nudc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(hwep),\r\nDAT_WR_BYTE(0));\r\n}\r\nstatic void udc_select_hwep(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nudc_protocol_cmd_w(udc, CMD_SEL_EP(hwep));\r\n}\r\nstatic void udc_clr_buffer_hwep(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nudc_select_hwep(udc, hwep);\r\nudc_protocol_cmd_w(udc, CMD_CLR_BUF);\r\n}\r\nstatic void udc_val_buffer_hwep(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nudc_select_hwep(udc, hwep);\r\nudc_protocol_cmd_w(udc, CMD_VALID_BUF);\r\n}\r\nstatic inline u32 udc_clearep_getsts(struct lpc32xx_udc *udc, u32 hwep)\r\n{\r\nuda_clear_hwepint(udc, hwep);\r\nreturn udc_selep_clrint(udc, hwep);\r\n}\r\nstatic struct lpc32xx_usbd_dd_gad *udc_dd_alloc(struct lpc32xx_udc *udc)\r\n{\r\ndma_addr_t dma;\r\nstruct lpc32xx_usbd_dd_gad *dd;\r\ndd = (struct lpc32xx_usbd_dd_gad *) dma_pool_alloc(\r\nudc->dd_cache, (GFP_KERNEL | GFP_DMA), &dma);\r\nif (dd)\r\ndd->this_dma = dma;\r\nreturn dd;\r\n}\r\nstatic void udc_dd_free(struct lpc32xx_udc *udc, struct lpc32xx_usbd_dd_gad *dd)\r\n{\r\ndma_pool_free(udc->dd_cache, dd, dd->this_dma);\r\n}\r\nstatic void udc_clk_set(struct lpc32xx_udc *udc, int enable)\r\n{\r\nif (enable != 0) {\r\nif (udc->clocked)\r\nreturn;\r\nudc->clocked = 1;\r\nclk_enable(udc->usb_pll_clk);\r\nwritel(readl(USB_CTRL) | USB_DEV_NEED_CLK_EN,\r\nUSB_CTRL);\r\nclk_enable(udc->usb_otg_clk);\r\n} else {\r\nif (!udc->clocked)\r\nreturn;\r\nudc->clocked = 0;\r\nclk_disable(udc->usb_pll_clk);\r\nwritel(readl(USB_CTRL) & ~USB_DEV_NEED_CLK_EN,\r\nUSB_CTRL);\r\nclk_disable(udc->usb_otg_clk);\r\n}\r\n}\r\nstatic void udc_set_address(struct lpc32xx_udc *udc, u32 addr)\r\n{\r\nudc_protocol_cmd_data_w(udc, CMD_SET_ADDR,\r\nDAT_WR_BYTE(DEV_EN | addr));\r\n}\r\nstatic int udc_ep_in_req_dma(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)\r\n{\r\nstruct lpc32xx_request *req;\r\nu32 hwep = ep->hwep_num;\r\nep->req_pending = 1;\r\nreq = list_entry(ep->queue.next, struct lpc32xx_request, queue);\r\nudc->udca_v_base[hwep] = req->dd_desc_ptr->this_dma;\r\nudc_ep_dma_enable(udc, hwep);\r\nif (req->req.length % ep->ep.maxpacket)\r\nreq->send_zlp = 0;\r\nreturn 0;\r\n}\r\nstatic int udc_ep_out_req_dma(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)\r\n{\r\nstruct lpc32xx_request *req;\r\nu32 hwep = ep->hwep_num;\r\nep->req_pending = 1;\r\nreq = list_entry(ep->queue.next, struct lpc32xx_request, queue);\r\nudc->udca_v_base[hwep] = req->dd_desc_ptr->this_dma;\r\nudc_ep_dma_enable(udc, hwep);\r\nreturn 0;\r\n}\r\nstatic void udc_disable(struct lpc32xx_udc *udc)\r\n{\r\nu32 i;\r\nudc_protocol_cmd_data_w(udc, CMD_CFG_DEV, DAT_WR_BYTE(0));\r\nudc_protocol_cmd_data_w(udc, CMD_SET_DEV_STAT, DAT_WR_BYTE(0));\r\nuda_disable_devint(udc, 0x3FF);\r\nfor (i = 0; i < 32; i++) {\r\nuda_disable_hwepint(udc, i);\r\nuda_clear_hwepint(udc, i);\r\nudc_disable_hwep(udc, i);\r\nudc_unrealize_hwep(udc, i);\r\nudc->udca_v_base[i] = 0;\r\nudc_ep_dma_disable(udc, i);\r\nwritel((1 << i), USBD_EOTINTCLR(udc->udp_baseaddr));\r\nwritel((1 << i), USBD_NDDRTINTCLR(udc->udp_baseaddr));\r\nwritel((1 << i), USBD_SYSERRTINTCLR(udc->udp_baseaddr));\r\nwritel((1 << i), USBD_DMARCLR(udc->udp_baseaddr));\r\n}\r\nwritel(0, USBD_DMAINTEN(udc->udp_baseaddr));\r\nwritel(0, USBD_UDCAH(udc->udp_baseaddr));\r\n}\r\nstatic void udc_enable(struct lpc32xx_udc *udc)\r\n{\r\nu32 i;\r\nstruct lpc32xx_ep *ep = &udc->ep[0];\r\nudc_disable(udc);\r\nudc_protocol_cmd_data_w(udc, CMD_SET_DEV_STAT, DAT_WR_BYTE(DEV_CON));\r\nwritel(USBD_EP_FAST, USBD_DEVINTPRI(udc->udp_baseaddr));\r\nwritel(0xFFFF, USBD_EPINTPRI(udc->udp_baseaddr));\r\nwritel(0x3FF, USBD_DEVINTCLR(udc->udp_baseaddr));\r\nwritel(udc->udca_p_base, USBD_UDCAH(udc->udp_baseaddr));\r\nfor (i = 0; i <= 1; i++) {\r\nudc_realize_hwep(udc, i, ep->ep.maxpacket);\r\nuda_enable_hwepint(udc, i);\r\nudc_select_hwep(udc, i);\r\nudc_clrstall_hwep(udc, i);\r\nudc_clr_buffer_hwep(udc, i);\r\n}\r\nuda_clear_devint(udc, (USBD_ERR_INT | USBD_DEV_STAT | USBD_EP_SLOW |\r\nUSBD_EP_FAST));\r\nuda_enable_devint(udc, (USBD_ERR_INT | USBD_DEV_STAT | USBD_EP_SLOW |\r\nUSBD_EP_FAST));\r\nudc_set_address(udc, 0);\r\nudc_set_address(udc, 0);\r\nwritel((USBD_SYS_ERR_INT | USBD_EOT_INT),\r\nUSBD_DMAINTEN(udc->udp_baseaddr));\r\nudc->dev_status = 0;\r\n}\r\nstatic void uda_power_event(struct lpc32xx_udc *udc, u32 conn)\r\n{\r\nif (udc->board->conn_chgb != NULL)\r\nudc->board->conn_chgb(conn);\r\n}\r\nstatic void uda_resm_susp_event(struct lpc32xx_udc *udc, u32 conn)\r\n{\r\nif (udc->board->susp_chgb != NULL)\r\nudc->board->susp_chgb(conn);\r\nif (conn)\r\nudc->suspended = 0;\r\nelse\r\nudc->suspended = 1;\r\n}\r\nstatic void uda_remwkp_cgh(struct lpc32xx_udc *udc)\r\n{\r\nif (udc->board->rmwk_chgb != NULL)\r\nudc->board->rmwk_chgb(udc->dev_status &\r\n(1 << USB_DEVICE_REMOTE_WAKEUP));\r\n}\r\nstatic void udc_pop_fifo(struct lpc32xx_udc *udc, u8 *data, u32 bytes)\r\n{\r\nint n, i, bl;\r\nu16 *p16;\r\nu32 *p32, tmp, cbytes;\r\nswitch (((u32) data) & 0x3) {\r\ncase 0:\r\np32 = (u32 *) data;\r\ncbytes = (bytes & ~0x3);\r\nfor (n = 0; n < cbytes; n += 4)\r\n*p32++ = readl(USBD_RXDATA(udc->udp_baseaddr));\r\nbl = bytes - cbytes;\r\nif (bl) {\r\ntmp = readl(USBD_RXDATA(udc->udp_baseaddr));\r\nfor (n = 0; n < bl; n++)\r\ndata[cbytes + n] = ((tmp >> (n * 8)) & 0xFF);\r\n}\r\nbreak;\r\ncase 1:\r\ncase 3:\r\nfor (n = 0; n < bytes; n += 4) {\r\ntmp = readl(USBD_RXDATA(udc->udp_baseaddr));\r\nbl = bytes - n;\r\nif (bl > 3)\r\nbl = 3;\r\nfor (i = 0; i < bl; i++)\r\ndata[n + i] = (u8) ((tmp >> (n * 8)) & 0xFF);\r\n}\r\nbreak;\r\ncase 2:\r\np16 = (u16 *) data;\r\ncbytes = (bytes & ~0x3);\r\nfor (n = 0; n < cbytes; n += 4) {\r\ntmp = readl(USBD_RXDATA(udc->udp_baseaddr));\r\n*p16++ = (u16)(tmp & 0xFFFF);\r\n*p16++ = (u16)((tmp >> 16) & 0xFFFF);\r\n}\r\nbl = bytes - cbytes;\r\nif (bl) {\r\ntmp = readl(USBD_RXDATA(udc->udp_baseaddr));\r\nfor (n = 0; n < bl; n++)\r\ndata[cbytes + n] = ((tmp >> (n * 8)) & 0xFF);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic u32 udc_read_hwep(struct lpc32xx_udc *udc, u32 hwep, u32 *data,\r\nu32 bytes)\r\n{\r\nu32 tmpv;\r\nint to = 1000;\r\nu32 tmp, hwrep = ((hwep & 0x1E) << 1) | CTRL_RD_EN;\r\nwritel(hwrep, USBD_CTRL(udc->udp_baseaddr));\r\nwhile ((((tmpv = readl(USBD_RXPLEN(udc->udp_baseaddr))) &\r\nPKT_RDY) == 0) && (to > 0))\r\nto--;\r\nif (!to)\r\ndev_dbg(udc->dev, "No packet ready on FIFO EP read\n");\r\ntmp = tmpv & PKT_LNGTH_MASK;\r\nif (bytes < tmp)\r\ntmp = bytes;\r\nif ((tmp > 0) && (data != NULL))\r\nudc_pop_fifo(udc, (u8 *) data, tmp);\r\nwritel(((hwep & 0x1E) << 1), USBD_CTRL(udc->udp_baseaddr));\r\nudc_clr_buffer_hwep(udc, hwep);\r\nreturn tmp;\r\n}\r\nstatic void udc_stuff_fifo(struct lpc32xx_udc *udc, u8 *data, u32 bytes)\r\n{\r\nint n, i, bl;\r\nu16 *p16;\r\nu32 *p32, tmp, cbytes;\r\nswitch (((u32) data) & 0x3) {\r\ncase 0:\r\np32 = (u32 *) data;\r\ncbytes = (bytes & ~0x3);\r\nfor (n = 0; n < cbytes; n += 4)\r\nwritel(*p32++, USBD_TXDATA(udc->udp_baseaddr));\r\nbl = bytes - cbytes;\r\nif (bl) {\r\ntmp = 0;\r\nfor (n = 0; n < bl; n++)\r\ntmp |= data[cbytes + n] << (n * 8);\r\nwritel(tmp, USBD_TXDATA(udc->udp_baseaddr));\r\n}\r\nbreak;\r\ncase 1:\r\ncase 3:\r\nfor (n = 0; n < bytes; n += 4) {\r\nbl = bytes - n;\r\nif (bl > 4)\r\nbl = 4;\r\ntmp = 0;\r\nfor (i = 0; i < bl; i++)\r\ntmp |= data[n + i] << (i * 8);\r\nwritel(tmp, USBD_TXDATA(udc->udp_baseaddr));\r\n}\r\nbreak;\r\ncase 2:\r\np16 = (u16 *) data;\r\ncbytes = (bytes & ~0x3);\r\nfor (n = 0; n < cbytes; n += 4) {\r\ntmp = *p16++ & 0xFFFF;\r\ntmp |= (*p16++ & 0xFFFF) << 16;\r\nwritel(tmp, USBD_TXDATA(udc->udp_baseaddr));\r\n}\r\nbl = bytes - cbytes;\r\nif (bl) {\r\ntmp = 0;\r\nfor (n = 0; n < bl; n++)\r\ntmp |= data[cbytes + n] << (n * 8);\r\nwritel(tmp, USBD_TXDATA(udc->udp_baseaddr));\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void udc_write_hwep(struct lpc32xx_udc *udc, u32 hwep, u32 *data,\r\nu32 bytes)\r\n{\r\nu32 hwwep = ((hwep & 0x1E) << 1) | CTRL_WR_EN;\r\nif ((bytes > 0) && (data == NULL))\r\nreturn;\r\nwritel(hwwep, USBD_CTRL(udc->udp_baseaddr));\r\nwritel(bytes, USBD_TXPLEN(udc->udp_baseaddr));\r\nif (bytes == 0)\r\nwritel(0, USBD_TXDATA(udc->udp_baseaddr));\r\nelse\r\nudc_stuff_fifo(udc, (u8 *) data, bytes);\r\nwritel(((hwep & 0x1E) << 1), USBD_CTRL(udc->udp_baseaddr));\r\nudc_val_buffer_hwep(udc, hwep);\r\n}\r\nstatic void uda_usb_reset(struct lpc32xx_udc *udc)\r\n{\r\nu32 i = 0;\r\nudc_enable(udc);\r\nudc->gadget.speed = USB_SPEED_FULL;\r\nfor (i = 1; i < NUM_ENDPOINTS; i++) {\r\nstruct lpc32xx_ep *ep = &udc->ep[i];\r\nep->req_pending = 0;\r\n}\r\n}\r\nstatic void udc_ep0_send_zlp(struct lpc32xx_udc *udc)\r\n{\r\nudc_write_hwep(udc, EP_IN, NULL, 0);\r\n}\r\nstatic u16 udc_get_current_frame(struct lpc32xx_udc *udc)\r\n{\r\nu16 flo, fhi;\r\nudc_protocol_cmd_w(udc, CMD_RD_FRAME);\r\nflo = (u16) udc_protocol_cmd_r(udc, DAT_RD_FRAME);\r\nfhi = (u16) udc_protocol_cmd_r(udc, DAT_RD_FRAME);\r\nreturn (fhi << 8) | flo;\r\n}\r\nstatic inline void udc_set_device_configured(struct lpc32xx_udc *udc)\r\n{\r\nudc_protocol_cmd_data_w(udc, CMD_CFG_DEV, DAT_WR_BYTE(CONF_DVICE));\r\n}\r\nstatic inline void udc_set_device_unconfigured(struct lpc32xx_udc *udc)\r\n{\r\nudc_protocol_cmd_data_w(udc, CMD_CFG_DEV, DAT_WR_BYTE(0));\r\n}\r\nstatic void udc_reinit(struct lpc32xx_udc *udc)\r\n{\r\nu32 i;\r\nINIT_LIST_HEAD(&udc->gadget.ep_list);\r\nINIT_LIST_HEAD(&udc->gadget.ep0->ep_list);\r\nfor (i = 0; i < NUM_ENDPOINTS; i++) {\r\nstruct lpc32xx_ep *ep = &udc->ep[i];\r\nif (i != 0)\r\nlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\r\nusb_ep_set_maxpacket_limit(&ep->ep, ep->maxpacket);\r\nINIT_LIST_HEAD(&ep->queue);\r\nep->req_pending = 0;\r\n}\r\nudc->ep0state = WAIT_FOR_SETUP;\r\n}\r\nstatic void done(struct lpc32xx_ep *ep, struct lpc32xx_request *req, int status)\r\n{\r\nstruct lpc32xx_udc *udc = ep->udc;\r\nlist_del_init(&req->queue);\r\nif (req->req.status == -EINPROGRESS)\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\nif (ep->lep) {\r\nusb_gadget_unmap_request(&udc->gadget, &req->req, ep->is_in);\r\nudc_dd_free(udc, req->dd_desc_ptr);\r\n}\r\nif (status && status != -ESHUTDOWN)\r\nep_dbg(ep, "%s done %p, status %d\n", ep->ep.name, req, status);\r\nep->req_pending = 0;\r\nspin_unlock(&udc->lock);\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&udc->lock);\r\n}\r\nstatic void nuke(struct lpc32xx_ep *ep, int status)\r\n{\r\nstruct lpc32xx_request *req;\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next, struct lpc32xx_request, queue);\r\ndone(ep, req, status);\r\n}\r\nif (status == -ESHUTDOWN) {\r\nuda_disable_hwepint(ep->udc, ep->hwep_num);\r\nudc_disable_hwep(ep->udc, ep->hwep_num);\r\n}\r\n}\r\nstatic int udc_ep0_in_req(struct lpc32xx_udc *udc)\r\n{\r\nstruct lpc32xx_request *req;\r\nstruct lpc32xx_ep *ep0 = &udc->ep[0];\r\nu32 tsend, ts = 0;\r\nif (list_empty(&ep0->queue))\r\nreturn 0;\r\nelse\r\nreq = list_entry(ep0->queue.next, struct lpc32xx_request,\r\nqueue);\r\ntsend = ts = req->req.length - req->req.actual;\r\nif (ts == 0) {\r\nudc_ep0_send_zlp(udc);\r\ndone(ep0, req, 0);\r\nreturn 1;\r\n} else if (ts > ep0->ep.maxpacket)\r\nts = ep0->ep.maxpacket;\r\nudc_write_hwep(udc, EP_IN, (req->req.buf + req->req.actual), ts);\r\nreq->req.actual += ts;\r\nif (tsend >= ep0->ep.maxpacket)\r\nreturn 0;\r\nudc->ep0state = WAIT_FOR_SETUP;\r\ndone(ep0, req, 0);\r\nreturn 1;\r\n}\r\nstatic int udc_ep0_out_req(struct lpc32xx_udc *udc)\r\n{\r\nstruct lpc32xx_request *req;\r\nstruct lpc32xx_ep *ep0 = &udc->ep[0];\r\nu32 tr, bufferspace;\r\nif (list_empty(&ep0->queue))\r\nreturn 0;\r\nelse\r\nreq = list_entry(ep0->queue.next, struct lpc32xx_request,\r\nqueue);\r\nif (req) {\r\nif (req->req.length == 0) {\r\ndone(ep0, req, 0);\r\nudc->ep0state = WAIT_FOR_SETUP;\r\nreturn 1;\r\n}\r\nbufferspace = req->req.length - req->req.actual;\r\nif (bufferspace > ep0->ep.maxpacket)\r\nbufferspace = ep0->ep.maxpacket;\r\nprefetchw(req->req.buf + req->req.actual);\r\ntr = udc_read_hwep(udc, EP_OUT, req->req.buf + req->req.actual,\r\nbufferspace);\r\nreq->req.actual += bufferspace;\r\nif (tr < ep0->ep.maxpacket) {\r\ndone(ep0, req, 0);\r\nudc->ep0state = WAIT_FOR_SETUP;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void stop_activity(struct lpc32xx_udc *udc)\r\n{\r\nstruct usb_gadget_driver *driver = udc->driver;\r\nint i;\r\nif (udc->gadget.speed == USB_SPEED_UNKNOWN)\r\ndriver = NULL;\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nudc->suspended = 0;\r\nfor (i = 0; i < NUM_ENDPOINTS; i++) {\r\nstruct lpc32xx_ep *ep = &udc->ep[i];\r\nnuke(ep, -ESHUTDOWN);\r\n}\r\nif (driver) {\r\nspin_unlock(&udc->lock);\r\ndriver->disconnect(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\nisp1301_pullup_enable(udc, 0, 0);\r\nudc_disable(udc);\r\nudc_reinit(udc);\r\n}\r\nstatic void pullup(struct lpc32xx_udc *udc, int is_on)\r\n{\r\nif (!udc->clocked)\r\nreturn;\r\nif (!udc->enabled || !udc->vbus)\r\nis_on = 0;\r\nif (is_on != udc->pullup)\r\nisp1301_pullup_enable(udc, is_on, 0);\r\n}\r\nstatic int lpc32xx_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);\r\nstruct lpc32xx_udc *udc = ep->udc;\r\nunsigned long flags;\r\nif ((ep->hwep_num_base == 0) || (ep->hwep_num == 0))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nnuke(ep, -ESHUTDOWN);\r\nudc_ep_dma_disable(udc, ep->hwep_num);\r\nwritel(1 << ep->hwep_num, USBD_EOTINTCLR(udc->udp_baseaddr));\r\nwritel(1 << ep->hwep_num, USBD_NDDRTINTCLR(udc->udp_baseaddr));\r\nwritel(1 << ep->hwep_num, USBD_SYSERRTINTCLR(udc->udp_baseaddr));\r\nwritel(1 << ep->hwep_num, USBD_DMARCLR(udc->udp_baseaddr));\r\nudc->udca_v_base[ep->hwep_num] = 0;\r\nuda_clear_hwepint(udc, ep->hwep_num);\r\nudc_unrealize_hwep(udc, ep->hwep_num);\r\nep->hwep_num = 0;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\natomic_dec(&udc->enabled_ep_cnt);\r\nwake_up(&udc->ep_disable_wait_queue);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);\r\nstruct lpc32xx_udc *udc = ep->udc;\r\nu16 maxpacket;\r\nu32 tmp;\r\nunsigned long flags;\r\nif ((!_ep) || (!ep) || (!desc) ||\r\n(desc->bDescriptorType != USB_DT_ENDPOINT)) {\r\ndev_dbg(udc->dev, "bad ep or descriptor\n");\r\nreturn -EINVAL;\r\n}\r\nmaxpacket = usb_endpoint_maxp(desc);\r\nif ((maxpacket == 0) || (maxpacket > ep->maxpacket)) {\r\ndev_dbg(udc->dev, "bad ep descriptor's packet size\n");\r\nreturn -EINVAL;\r\n}\r\nif (ep->hwep_num_base == 0) {\r\ndev_dbg(udc->dev, "Can't re-enable EP0!!!\n");\r\nreturn -EINVAL;\r\n}\r\nif ((!udc->driver) || (udc->gadget.speed == USB_SPEED_UNKNOWN)) {\r\ndev_dbg(udc->dev, "bogus device state\n");\r\nreturn -ESHUTDOWN;\r\n}\r\ntmp = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\r\nswitch (tmp) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nreturn -EINVAL;\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (maxpacket > ep->maxpacket) {\r\ndev_dbg(udc->dev,\r\n"Bad INT endpoint maxpacket %d\n", maxpacket);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nswitch (maxpacket) {\r\ncase 8:\r\ncase 16:\r\ncase 32:\r\ncase 64:\r\nbreak;\r\ndefault:\r\ndev_dbg(udc->dev,\r\n"Bad BULK endpoint maxpacket %d\n", maxpacket);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nbreak;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nep->is_in = (desc->bEndpointAddress & USB_DIR_IN) != 0;\r\nep->ep.maxpacket = maxpacket;\r\nif (ep->is_in)\r\nep->hwep_num = ep->hwep_num_base + EP_IN;\r\nelse\r\nep->hwep_num = ep->hwep_num_base;\r\nep_dbg(ep, "EP enabled: %s, HW:%d, MP:%d IN:%d\n", ep->ep.name,\r\nep->hwep_num, maxpacket, (ep->is_in == 1));\r\nudc_realize_hwep(udc, ep->hwep_num, ep->ep.maxpacket);\r\nudc_clr_buffer_hwep(udc, ep->hwep_num);\r\nuda_disable_hwepint(udc, ep->hwep_num);\r\nudc_clrstall_hwep(udc, ep->hwep_num);\r\nudc_ep_dma_disable(udc, ep->hwep_num);\r\nwritel(1 << ep->hwep_num, USBD_EOTINTCLR(udc->udp_baseaddr));\r\nwritel(1 << ep->hwep_num, USBD_NDDRTINTCLR(udc->udp_baseaddr));\r\nwritel(1 << ep->hwep_num, USBD_SYSERRTINTCLR(udc->udp_baseaddr));\r\nwritel(1 << ep->hwep_num, USBD_DMARCLR(udc->udp_baseaddr));\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\natomic_inc(&udc->enabled_ep_cnt);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *lpc32xx_ep_alloc_request(struct usb_ep *_ep,\r\ngfp_t gfp_flags)\r\n{\r\nstruct lpc32xx_request *req;\r\nreq = kzalloc(sizeof(struct lpc32xx_request), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void lpc32xx_ep_free_request(struct usb_ep *_ep,\r\nstruct usb_request *_req)\r\n{\r\nstruct lpc32xx_request *req;\r\nreq = container_of(_req, struct lpc32xx_request, req);\r\nBUG_ON(!list_empty(&req->queue));\r\nkfree(req);\r\n}\r\nstatic int lpc32xx_ep_queue(struct usb_ep *_ep,\r\nstruct usb_request *_req, gfp_t gfp_flags)\r\n{\r\nstruct lpc32xx_request *req;\r\nstruct lpc32xx_ep *ep;\r\nstruct lpc32xx_udc *udc;\r\nunsigned long flags;\r\nint status = 0;\r\nreq = container_of(_req, struct lpc32xx_request, req);\r\nep = container_of(_ep, struct lpc32xx_ep, ep);\r\nif (!_req || !_req->complete || !_req->buf ||\r\n!list_empty(&req->queue))\r\nreturn -EINVAL;\r\nudc = ep->udc;\r\nif (!_ep) {\r\ndev_dbg(udc->dev, "invalid ep\n");\r\nreturn -EINVAL;\r\n}\r\nif ((!udc) || (!udc->driver) ||\r\n(udc->gadget.speed == USB_SPEED_UNKNOWN)) {\r\ndev_dbg(udc->dev, "invalid device\n");\r\nreturn -EINVAL;\r\n}\r\nif (ep->lep) {\r\nstruct lpc32xx_usbd_dd_gad *dd;\r\nstatus = usb_gadget_map_request(&udc->gadget, _req, ep->is_in);\r\nif (status)\r\nreturn status;\r\ndd = udc_dd_alloc(udc);\r\nif (!dd) {\r\nreturn -ENOMEM;\r\n}\r\nreq->dd_desc_ptr = dd;\r\ndd->dd_next_phy = dd->dd_next_v = 0;\r\ndd->dd_buffer_addr = req->req.dma;\r\ndd->dd_status = 0;\r\nif (ep->eptype == EP_ISO_TYPE) {\r\ndd->dd_setup = DD_SETUP_ISO_EP |\r\nDD_SETUP_PACKETLEN(0) |\r\nDD_SETUP_DMALENBYTES(1);\r\ndd->dd_iso_ps_mem_addr = dd->this_dma + 24;\r\nif (ep->is_in)\r\ndd->iso_status[0] = req->req.length;\r\nelse\r\ndd->iso_status[0] = 0;\r\n} else\r\ndd->dd_setup = DD_SETUP_PACKETLEN(ep->ep.maxpacket) |\r\nDD_SETUP_DMALENBYTES(req->req.length);\r\n}\r\nep_dbg(ep, "%s queue req %p len %d buf %p (in=%d) z=%d\n", _ep->name,\r\n_req, _req->length, _req->buf, ep->is_in, _req->zero);\r\nspin_lock_irqsave(&udc->lock, flags);\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nreq->send_zlp = _req->zero;\r\nif (list_empty(&ep->queue)) {\r\nlist_add_tail(&req->queue, &ep->queue);\r\nif (ep->hwep_num_base == 0) {\r\nif (ep->is_in) {\r\nudc->ep0state = DATA_IN;\r\nstatus = udc_ep0_in_req(udc);\r\n} else {\r\nudc->ep0state = DATA_OUT;\r\nstatus = udc_ep0_out_req(udc);\r\n}\r\n} else if (ep->is_in) {\r\nif (!ep->req_pending)\r\nudc_ep_in_req_dma(udc, ep);\r\n} else\r\nif (!ep->req_pending)\r\nudc_ep_out_req_dma(udc, ep);\r\n} else\r\nlist_add_tail(&req->queue, &ep->queue);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn (status < 0) ? status : 0;\r\n}\r\nstatic int lpc32xx_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct lpc32xx_ep *ep;\r\nstruct lpc32xx_request *req;\r\nunsigned long flags;\r\nep = container_of(_ep, struct lpc32xx_ep, ep);\r\nif (!_ep || ep->hwep_num_base == 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ep->udc->lock, flags);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nreturn -EINVAL;\r\n}\r\ndone(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_ep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);\r\nstruct lpc32xx_udc *udc = ep->udc;\r\nunsigned long flags;\r\nif ((!ep) || (ep->hwep_num <= 1))\r\nreturn -EINVAL;\r\nif (ep->is_in)\r\nreturn -EAGAIN;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (value == 1) {\r\nudc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(ep->hwep_num),\r\nDAT_WR_BYTE(EP_STAT_ST));\r\n} else {\r\nep->wedge = 0;\r\nudc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(ep->hwep_num),\r\nDAT_WR_BYTE(0));\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_ep_set_wedge(struct usb_ep *_ep)\r\n{\r\nstruct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);\r\nif (!_ep || !ep->udc)\r\nreturn -EINVAL;\r\nep->wedge = 1;\r\nreturn usb_ep_set_halt(_ep);\r\n}\r\nvoid udc_send_in_zlp(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)\r\n{\r\nudc_clearep_getsts(udc, ep->hwep_num);\r\nudc_write_hwep(udc, ep->hwep_num, NULL, 0);\r\n}\r\nvoid udc_handle_eps(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)\r\n{\r\nu32 epstatus;\r\nstruct lpc32xx_request *req;\r\nif (ep->hwep_num <= 0)\r\nreturn;\r\nuda_clear_hwepint(udc, ep->hwep_num);\r\nif (!(udc->enabled_hwepints & (1 << ep->hwep_num)))\r\nreturn;\r\nepstatus = udc_clearep_getsts(udc, ep->hwep_num);\r\nif (epstatus & EP_SEL_F)\r\nreturn;\r\nif (ep->is_in) {\r\nudc_send_in_zlp(udc, ep);\r\nuda_disable_hwepint(udc, ep->hwep_num);\r\n} else\r\nreturn;\r\nreq = list_entry(ep->queue.next, struct lpc32xx_request, queue);\r\nif (req) {\r\ndone(ep, req, 0);\r\nif (!list_empty(&ep->queue)) {\r\nif (ep->is_in)\r\nudc_ep_in_req_dma(udc, ep);\r\nelse\r\nudc_ep_out_req_dma(udc, ep);\r\n} else\r\nep->req_pending = 0;\r\n}\r\n}\r\nstatic void udc_handle_dma_ep(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)\r\n{\r\nu32 status, epstatus;\r\nstruct lpc32xx_request *req;\r\nstruct lpc32xx_usbd_dd_gad *dd;\r\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\r\nep->totalints++;\r\n#endif\r\nreq = list_entry(ep->queue.next, struct lpc32xx_request, queue);\r\nif (!req) {\r\nep_err(ep, "DMA interrupt on no req!\n");\r\nreturn;\r\n}\r\ndd = req->dd_desc_ptr;\r\nif (!(dd->dd_status & DD_STATUS_DD_RETIRED))\r\nep_warn(ep, "DMA descriptor did not retire\n");\r\nudc_ep_dma_disable(udc, ep->hwep_num);\r\nwritel((1 << ep->hwep_num), USBD_EOTINTCLR(udc->udp_baseaddr));\r\nwritel((1 << ep->hwep_num), USBD_NDDRTINTCLR(udc->udp_baseaddr));\r\nif (readl(USBD_SYSERRTINTST(udc->udp_baseaddr)) &\r\n(1 << ep->hwep_num)) {\r\nwritel((1 << ep->hwep_num),\r\nUSBD_SYSERRTINTCLR(udc->udp_baseaddr));\r\nep_err(ep, "AHB critical error!\n");\r\nep->req_pending = 0;\r\ndone(ep, req, -ECONNABORTED);\r\nreturn;\r\n}\r\nstatus = dd->dd_status;\r\nswitch (status & DD_STATUS_STS_MASK) {\r\ncase DD_STATUS_STS_NS:\r\nep->req_pending = 0;\r\nep_err(ep, "DMA critical EP error: DD not serviced (0x%x)!\n",\r\nstatus);\r\ndone(ep, req, -ECONNABORTED);\r\nreturn;\r\ncase DD_STATUS_STS_BS:\r\nep->req_pending = 0;\r\nep_err(ep, "DMA critical EP error: EOT prior to service completion (0x%x)!\n",\r\nstatus);\r\ndone(ep, req, -ECONNABORTED);\r\nreturn;\r\ncase DD_STATUS_STS_NC:\r\ncase DD_STATUS_STS_DUR:\r\nbreak;\r\ndefault:\r\nep->req_pending = 0;\r\nep_err(ep, "DMA critical EP error: System error (0x%x)!\n",\r\nstatus);\r\ndone(ep, req, -ECONNABORTED);\r\nreturn;\r\n}\r\nif (ep->eptype == EP_ISO_TYPE) {\r\nif (ep->is_in)\r\nreq->req.actual = req->req.length;\r\nelse\r\nreq->req.actual = dd->iso_status[0] & 0xFFFF;\r\n} else\r\nreq->req.actual += DD_STATUS_CURDMACNT(status);\r\nif (req->send_zlp) {\r\nif (udc_clearep_getsts(udc, ep->hwep_num) & EP_SEL_F) {\r\nudc_clearep_getsts(udc, ep->hwep_num);\r\nuda_enable_hwepint(udc, ep->hwep_num);\r\nepstatus = udc_clearep_getsts(udc, ep->hwep_num);\r\nreturn;\r\n} else\r\nudc_send_in_zlp(udc, ep);\r\n}\r\ndone(ep, req, 0);\r\nudc_clearep_getsts(udc, ep->hwep_num);\r\nif (!list_empty((&ep->queue))) {\r\nif (ep->is_in)\r\nudc_ep_in_req_dma(udc, ep);\r\nelse\r\nudc_ep_out_req_dma(udc, ep);\r\n} else\r\nep->req_pending = 0;\r\n}\r\nstatic void udc_handle_dev(struct lpc32xx_udc *udc)\r\n{\r\nu32 tmp;\r\nudc_protocol_cmd_w(udc, CMD_GET_DEV_STAT);\r\ntmp = udc_protocol_cmd_r(udc, DAT_GET_DEV_STAT);\r\nif (tmp & DEV_RST)\r\nuda_usb_reset(udc);\r\nelse if (tmp & DEV_CON_CH)\r\nuda_power_event(udc, (tmp & DEV_CON));\r\nelse if (tmp & DEV_SUS_CH) {\r\nif (tmp & DEV_SUS) {\r\nif (udc->vbus == 0)\r\nstop_activity(udc);\r\nelse if ((udc->gadget.speed != USB_SPEED_UNKNOWN) &&\r\nudc->driver) {\r\nudc->poweron = 0;\r\nschedule_work(&udc->pullup_job);\r\nuda_resm_susp_event(udc, 1);\r\n}\r\n} else if ((udc->gadget.speed != USB_SPEED_UNKNOWN) &&\r\nudc->driver && udc->vbus) {\r\nuda_resm_susp_event(udc, 0);\r\nudc->poweron = 1;\r\nschedule_work(&udc->pullup_job);\r\n}\r\n}\r\n}\r\nstatic int udc_get_status(struct lpc32xx_udc *udc, u16 reqtype, u16 wIndex)\r\n{\r\nstruct lpc32xx_ep *ep;\r\nu32 ep0buff = 0, tmp;\r\nswitch (reqtype & USB_RECIP_MASK) {\r\ncase USB_RECIP_INTERFACE:\r\nbreak;\r\ncase USB_RECIP_DEVICE:\r\nep0buff = (udc->selfpowered << USB_DEVICE_SELF_POWERED);\r\nif (udc->dev_status & (1 << USB_DEVICE_REMOTE_WAKEUP))\r\nep0buff |= (1 << USB_DEVICE_REMOTE_WAKEUP);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\ntmp = wIndex & USB_ENDPOINT_NUMBER_MASK;\r\nep = &udc->ep[tmp];\r\nif ((tmp == 0) || (tmp >= NUM_ENDPOINTS))\r\nreturn -EOPNOTSUPP;\r\nif (wIndex & USB_DIR_IN) {\r\nif (!ep->is_in)\r\nreturn -EOPNOTSUPP;\r\n} else if (ep->is_in)\r\nreturn -EOPNOTSUPP;\r\nudc_protocol_cmd_w(udc, CMD_SEL_EP(ep->hwep_num));\r\ntmp = udc_protocol_cmd_r(udc, DAT_SEL_EP(ep->hwep_num));\r\nif (tmp & EP_SEL_ST)\r\nep0buff = (1 << USB_ENDPOINT_HALT);\r\nelse\r\nep0buff = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nudc_write_hwep(udc, EP_IN, &ep0buff, 2);\r\nreturn 0;\r\n}\r\nstatic void udc_handle_ep0_setup(struct lpc32xx_udc *udc)\r\n{\r\nstruct lpc32xx_ep *ep, *ep0 = &udc->ep[0];\r\nstruct usb_ctrlrequest ctrlpkt;\r\nint i, bytes;\r\nu16 wIndex, wValue, wLength, reqtype, req, tmp;\r\nnuke(ep0, -EPROTO);\r\nbytes = udc_read_hwep(udc, EP_OUT, (u32 *) &ctrlpkt, 8);\r\nif (bytes != 8) {\r\nep_warn(ep0, "Incorrectly sized setup packet (s/b 8, is %d)!\n",\r\nbytes);\r\nreturn;\r\n}\r\nwIndex = le16_to_cpu(ctrlpkt.wIndex);\r\nwValue = le16_to_cpu(ctrlpkt.wValue);\r\nwLength = le16_to_cpu(ctrlpkt.wLength);\r\nreqtype = le16_to_cpu(ctrlpkt.bRequestType);\r\nif (likely(reqtype & USB_DIR_IN))\r\nep0->is_in = 1;\r\nelse\r\nep0->is_in = 0;\r\nreq = le16_to_cpu(ctrlpkt.bRequest);\r\nswitch (req) {\r\ncase USB_REQ_CLEAR_FEATURE:\r\ncase USB_REQ_SET_FEATURE:\r\nswitch (reqtype) {\r\ncase (USB_TYPE_STANDARD | USB_RECIP_DEVICE):\r\nif (wValue != USB_DEVICE_REMOTE_WAKEUP)\r\ngoto stall;\r\nif (req == USB_REQ_CLEAR_FEATURE)\r\nudc->dev_status &=\r\n~(1 << USB_DEVICE_REMOTE_WAKEUP);\r\nelse\r\nudc->dev_status |=\r\n(1 << USB_DEVICE_REMOTE_WAKEUP);\r\nuda_remwkp_cgh(udc);\r\ngoto zlp_send;\r\ncase (USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):\r\ntmp = wIndex & USB_ENDPOINT_NUMBER_MASK;\r\nif ((wValue != USB_ENDPOINT_HALT) ||\r\n(tmp >= NUM_ENDPOINTS))\r\nbreak;\r\nep = &udc->ep[tmp];\r\ntmp = ep->hwep_num;\r\nif (tmp == 0)\r\nbreak;\r\nif (req == USB_REQ_SET_FEATURE)\r\nudc_stall_hwep(udc, tmp);\r\nelse if (!ep->wedge)\r\nudc_clrstall_hwep(udc, tmp);\r\ngoto zlp_send;\r\ndefault:\r\nbreak;\r\n}\r\ncase USB_REQ_SET_ADDRESS:\r\nif (reqtype == (USB_TYPE_STANDARD | USB_RECIP_DEVICE)) {\r\nudc_set_address(udc, wValue);\r\ngoto zlp_send;\r\n}\r\nbreak;\r\ncase USB_REQ_GET_STATUS:\r\nudc_get_status(udc, reqtype, wIndex);\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nif (likely(udc->driver)) {\r\nspin_unlock(&udc->lock);\r\ni = udc->driver->setup(&udc->gadget, &ctrlpkt);\r\nspin_lock(&udc->lock);\r\nif (req == USB_REQ_SET_CONFIGURATION) {\r\nif (wValue) {\r\nudc_set_device_configured(udc);\r\nudc_protocol_cmd_data_w(udc, CMD_SET_MODE,\r\nDAT_WR_BYTE(AP_CLK |\r\nINAK_BI | INAK_II));\r\n} else {\r\nudc_set_device_unconfigured(udc);\r\nudc_protocol_cmd_data_w(udc, CMD_SET_MODE,\r\nDAT_WR_BYTE(AP_CLK));\r\n}\r\n}\r\nif (i < 0) {\r\ndev_dbg(udc->dev,\r\n"req %02x.%02x protocol STALL; stat %d\n",\r\nreqtype, req, i);\r\nudc->ep0state = WAIT_FOR_SETUP;\r\ngoto stall;\r\n}\r\n}\r\nif (!ep0->is_in)\r\nudc_ep0_send_zlp(udc);\r\nreturn;\r\nstall:\r\nudc_stall_hwep(udc, EP_IN);\r\nreturn;\r\nzlp_send:\r\nudc_ep0_send_zlp(udc);\r\nreturn;\r\n}\r\nstatic void udc_handle_ep0_in(struct lpc32xx_udc *udc)\r\n{\r\nstruct lpc32xx_ep *ep0 = &udc->ep[0];\r\nu32 epstatus;\r\nepstatus = udc_clearep_getsts(udc, EP_IN);\r\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\r\nep0->totalints++;\r\n#endif\r\nif (epstatus & EP_SEL_ST) {\r\nudc_clrstall_hwep(udc, EP_IN);\r\nnuke(ep0, -ECONNABORTED);\r\nudc->ep0state = WAIT_FOR_SETUP;\r\nreturn;\r\n}\r\nif (!(epstatus & EP_SEL_F)) {\r\nif (udc->ep0state == DATA_IN)\r\nudc_ep0_in_req(udc);\r\nelse {\r\nnuke(ep0, -ECONNABORTED);\r\nudc->ep0state = WAIT_FOR_SETUP;\r\n}\r\n}\r\n}\r\nstatic void udc_handle_ep0_out(struct lpc32xx_udc *udc)\r\n{\r\nstruct lpc32xx_ep *ep0 = &udc->ep[0];\r\nu32 epstatus;\r\nepstatus = udc_clearep_getsts(udc, EP_OUT);\r\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\r\nep0->totalints++;\r\n#endif\r\nif (epstatus & EP_SEL_ST) {\r\nudc_clrstall_hwep(udc, EP_OUT);\r\nnuke(ep0, -ECONNABORTED);\r\nudc->ep0state = WAIT_FOR_SETUP;\r\nreturn;\r\n}\r\nif (epstatus & EP_SEL_EPN)\r\nreturn;\r\nif (epstatus & EP_SEL_STP) {\r\nnuke(ep0, 0);\r\nudc->ep0state = WAIT_FOR_SETUP;\r\n}\r\nif (epstatus & EP_SEL_F)\r\nswitch (udc->ep0state) {\r\ncase WAIT_FOR_SETUP:\r\nudc_handle_ep0_setup(udc);\r\nbreak;\r\ncase DATA_OUT:\r\nudc_ep0_out_req(udc);\r\nbreak;\r\ndefault:\r\nnuke(ep0, -ECONNABORTED);\r\nudc->ep0state = WAIT_FOR_SETUP;\r\n}\r\n}\r\nstatic int lpc32xx_get_frame(struct usb_gadget *gadget)\r\n{\r\nint frame;\r\nunsigned long flags;\r\nstruct lpc32xx_udc *udc = to_udc(gadget);\r\nif (!udc->clocked)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nframe = (int) udc_get_current_frame(udc);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn frame;\r\n}\r\nstatic int lpc32xx_wakeup(struct usb_gadget *gadget)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int lpc32xx_set_selfpowered(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct lpc32xx_udc *udc = to_udc(gadget);\r\nudc->selfpowered = (is_on != 0);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_vbus_session(struct usb_gadget *gadget, int is_active)\r\n{\r\nunsigned long flags;\r\nstruct lpc32xx_udc *udc = to_udc(gadget);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (udc->driver) {\r\nudc_clk_set(udc, 1);\r\nudc_enable(udc);\r\npullup(udc, is_active);\r\n} else {\r\nstop_activity(udc);\r\npullup(udc, 0);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nif (atomic_read(&udc->enabled_ep_cnt))\r\nwait_event_interruptible(udc->ep_disable_wait_queue,\r\n(atomic_read(&udc->enabled_ep_cnt) == 0));\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc_clk_set(udc, 0);\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct lpc32xx_udc *udc = to_udc(gadget);\r\npullup(udc, is_on);\r\nreturn 0;\r\n}\r\nstatic void nop_release(struct device *dev)\r\n{\r\n}\r\nstatic irqreturn_t lpc32xx_usb_lp_irq(int irq, void *_udc)\r\n{\r\nu32 tmp, devstat;\r\nstruct lpc32xx_udc *udc = _udc;\r\nspin_lock(&udc->lock);\r\ndevstat = readl(USBD_DEVINTST(udc->udp_baseaddr));\r\ndevstat &= ~USBD_EP_FAST;\r\nwritel(devstat, USBD_DEVINTCLR(udc->udp_baseaddr));\r\ndevstat = devstat & udc->enabled_devints;\r\nif (devstat & USBD_DEV_STAT)\r\nudc_handle_dev(udc);\r\nif (devstat & ERR_INT) {\r\nudc_protocol_cmd_w(udc, CMD_RD_ERR_STAT);\r\ntmp = udc_protocol_cmd_r(udc, DAT_RD_ERR_STAT);\r\ndev_dbg(udc->dev, "Device error (0x%x)!\n", tmp);\r\n}\r\nspin_unlock(&udc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t lpc32xx_usb_hp_irq(int irq, void *_udc)\r\n{\r\nu32 tmp;\r\nstruct lpc32xx_udc *udc = _udc;\r\nspin_lock(&udc->lock);\r\nwritel(USBD_EP_FAST, USBD_DEVINTCLR(udc->udp_baseaddr));\r\ntmp = readl(USBD_EPINTST(udc->udp_baseaddr));\r\nif (tmp & (EP_MASK_SEL(0, EP_OUT) | EP_MASK_SEL(0, EP_IN))) {\r\nif (tmp & (EP_MASK_SEL(0, EP_IN)))\r\nudc_handle_ep0_in(udc);\r\nif (tmp & (EP_MASK_SEL(0, EP_OUT)))\r\nudc_handle_ep0_out(udc);\r\n}\r\nif (tmp & ~(EP_MASK_SEL(0, EP_OUT) | EP_MASK_SEL(0, EP_IN))) {\r\nint i;\r\nfor (i = 1; i < NUM_ENDPOINTS; i++) {\r\nif (tmp & (1 << udc->ep[i].hwep_num))\r\nudc_handle_eps(udc, &udc->ep[i]);\r\n}\r\n}\r\nspin_unlock(&udc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t lpc32xx_usb_devdma_irq(int irq, void *_udc)\r\n{\r\nstruct lpc32xx_udc *udc = _udc;\r\nint i;\r\nu32 tmp;\r\nspin_lock(&udc->lock);\r\ntmp = readl(USBD_EOTINTST(udc->udp_baseaddr)) |\r\n(readl(USBD_EPDMAST(udc->udp_baseaddr)) &\r\nreadl(USBD_NDDRTINTST(udc->udp_baseaddr))) |\r\nreadl(USBD_SYSERRTINTST(udc->udp_baseaddr));\r\nfor (i = 1; i < NUM_ENDPOINTS; i++) {\r\nif (tmp & (1 << udc->ep[i].hwep_num))\r\nudc_handle_dma_ep(udc, &udc->ep[i]);\r\n}\r\nspin_unlock(&udc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void vbus_work(struct work_struct *work)\r\n{\r\nu8 value;\r\nstruct lpc32xx_udc *udc = container_of(work, struct lpc32xx_udc,\r\nvbus_job);\r\nif (udc->enabled != 0) {\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_OTG_CONTROL_1, OTG1_VBUS_DISCHRG);\r\nmsleep(100);\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR,\r\nOTG1_VBUS_DISCHRG);\r\ni2c_smbus_write_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_INTERRUPT_LATCH |\r\nISP1301_I2C_REG_CLEAR_ADDR, ~0);\r\nvalue = i2c_smbus_read_byte_data(udc->isp1301_i2c_client,\r\nISP1301_I2C_INTERRUPT_SOURCE);\r\nif (value & INT_SESS_VLD)\r\nudc->vbus = 1;\r\nelse\r\nudc->vbus = 0;\r\nif (udc->last_vbus != udc->vbus) {\r\nudc->last_vbus = udc->vbus;\r\nlpc32xx_vbus_session(&udc->gadget, udc->vbus);\r\n}\r\n}\r\nenable_irq(udc->udp_irq[IRQ_USB_ATX]);\r\n}\r\nstatic irqreturn_t lpc32xx_usb_vbus_irq(int irq, void *_udc)\r\n{\r\nstruct lpc32xx_udc *udc = _udc;\r\ndisable_irq_nosync(udc->udp_irq[IRQ_USB_ATX]);\r\nschedule_work(&udc->vbus_job);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lpc32xx_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct lpc32xx_udc *udc = to_udc(gadget);\r\nint i;\r\nif (!driver || driver->max_speed < USB_SPEED_FULL || !driver->setup) {\r\ndev_err(udc->dev, "bad parameter.\n");\r\nreturn -EINVAL;\r\n}\r\nif (udc->driver) {\r\ndev_err(udc->dev, "UDC already has a gadget driver\n");\r\nreturn -EBUSY;\r\n}\r\nudc->driver = driver;\r\nudc->gadget.dev.of_node = udc->dev->of_node;\r\nudc->enabled = 1;\r\nudc->selfpowered = 1;\r\nudc->vbus = 0;\r\nudc->last_vbus = udc->vbus = 0;\r\nschedule_work(&udc->vbus_job);\r\nfor (i = IRQ_USB_LP; i < IRQ_USB_ATX; i++)\r\nenable_irq(udc->udp_irq[i]);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_stop(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nint i;\r\nstruct lpc32xx_udc *udc = to_udc(gadget);\r\nif (!driver || driver != udc->driver)\r\nreturn -EINVAL;\r\nfor (i = IRQ_USB_LP; i <= IRQ_USB_ATX; i++)\r\ndisable_irq(udc->udp_irq[i]);\r\nif (udc->clocked) {\r\nspin_lock(&udc->lock);\r\nstop_activity(udc);\r\nspin_unlock(&udc->lock);\r\nif (atomic_read(&udc->enabled_ep_cnt))\r\nwait_event_interruptible(udc->ep_disable_wait_queue,\r\n(atomic_read(&udc->enabled_ep_cnt) == 0));\r\nspin_lock(&udc->lock);\r\nudc_clk_set(udc, 0);\r\nspin_unlock(&udc->lock);\r\n}\r\nudc->enabled = 0;\r\nudc->driver = NULL;\r\nreturn 0;\r\n}\r\nstatic void lpc32xx_udc_shutdown(struct platform_device *dev)\r\n{\r\nstruct lpc32xx_udc *udc = platform_get_drvdata(dev);\r\npullup(udc, 0);\r\n}\r\nstatic void lpc32xx_usbd_conn_chg(int conn)\r\n{\r\n}\r\nstatic void lpc32xx_usbd_susp_chg(int susp)\r\n{\r\n}\r\nstatic void lpc32xx_rmwkup_chg(int remote_wakup_enable)\r\n{\r\n}\r\nstatic int __init lpc32xx_udc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct lpc32xx_udc *udc;\r\nint retval, i;\r\nstruct resource *res;\r\ndma_addr_t dma_handle;\r\nstruct device_node *isp1301_node;\r\nudc = kzalloc(sizeof(*udc), GFP_KERNEL);\r\nif (!udc)\r\nreturn -ENOMEM;\r\nmemcpy(udc, &controller_template, sizeof(*udc));\r\nfor (i = 0; i <= 15; i++)\r\nudc->ep[i].udc = udc;\r\nudc->gadget.ep0 = &udc->ep[0].ep;\r\nudc->gadget.dev.parent = dev;\r\nudc->pdev = pdev;\r\nudc->dev = &pdev->dev;\r\nudc->enabled = 0;\r\nif (pdev->dev.of_node) {\r\nisp1301_node = of_parse_phandle(pdev->dev.of_node,\r\n"transceiver", 0);\r\n} else {\r\nisp1301_node = NULL;\r\n}\r\nudc->isp1301_i2c_client = isp1301_get_client(isp1301_node);\r\nif (!udc->isp1301_i2c_client) {\r\nretval = -EPROBE_DEFER;\r\ngoto phy_fail;\r\n}\r\ndev_info(udc->dev, "ISP1301 I2C device at address 0x%x\n",\r\nudc->isp1301_i2c_client->addr);\r\npdev->dev.dma_mask = &lpc32xx_usbd_dmamask;\r\nretval = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (retval)\r\ngoto resource_fail;\r\nudc->board = &lpc32xx_usbddata;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nretval = -ENXIO;\r\ngoto resource_fail;\r\n}\r\nspin_lock_init(&udc->lock);\r\nfor (i = 0; i < 4; i++) {\r\nudc->udp_irq[i] = platform_get_irq(pdev, i);\r\nif (udc->udp_irq[i] < 0) {\r\ndev_err(udc->dev,\r\n"irq resource %d not available!\n", i);\r\nretval = udc->udp_irq[i];\r\ngoto irq_fail;\r\n}\r\n}\r\nudc->io_p_start = res->start;\r\nudc->io_p_size = resource_size(res);\r\nif (!request_mem_region(udc->io_p_start, udc->io_p_size, driver_name)) {\r\ndev_err(udc->dev, "someone's using UDC memory\n");\r\nretval = -EBUSY;\r\ngoto request_mem_region_fail;\r\n}\r\nudc->udp_baseaddr = ioremap(udc->io_p_start, udc->io_p_size);\r\nif (!udc->udp_baseaddr) {\r\nretval = -ENOMEM;\r\ndev_err(udc->dev, "IO map failure\n");\r\ngoto io_map_fail;\r\n}\r\nwritel(USB_SLAVE_HCLK_EN | (1 << 19), USB_CTRL);\r\nudc->usb_pll_clk = clk_get(&pdev->dev, "ck_pll5");\r\nif (IS_ERR(udc->usb_pll_clk)) {\r\ndev_err(udc->dev, "failed to acquire USB PLL\n");\r\nretval = PTR_ERR(udc->usb_pll_clk);\r\ngoto pll_get_fail;\r\n}\r\nudc->usb_slv_clk = clk_get(&pdev->dev, "ck_usbd");\r\nif (IS_ERR(udc->usb_slv_clk)) {\r\ndev_err(udc->dev, "failed to acquire USB device clock\n");\r\nretval = PTR_ERR(udc->usb_slv_clk);\r\ngoto usb_clk_get_fail;\r\n}\r\nudc->usb_otg_clk = clk_get(&pdev->dev, "ck_usb_otg");\r\nif (IS_ERR(udc->usb_otg_clk)) {\r\ndev_err(udc->dev, "failed to acquire USB otg clock\n");\r\nretval = PTR_ERR(udc->usb_otg_clk);\r\ngoto usb_otg_clk_get_fail;\r\n}\r\nretval = clk_enable(udc->usb_pll_clk);\r\nif (retval < 0) {\r\ndev_err(udc->dev, "failed to start USB PLL\n");\r\ngoto pll_enable_fail;\r\n}\r\nretval = clk_set_rate(udc->usb_pll_clk, 48000);\r\nif (retval < 0) {\r\ndev_err(udc->dev, "failed to set USB clock rate\n");\r\ngoto pll_set_fail;\r\n}\r\nwritel(readl(USB_CTRL) | USB_DEV_NEED_CLK_EN, USB_CTRL);\r\nretval = clk_enable(udc->usb_slv_clk);\r\nif (retval < 0) {\r\ndev_err(udc->dev, "failed to start USB device clock\n");\r\ngoto usb_clk_enable_fail;\r\n}\r\nretval = clk_enable(udc->usb_otg_clk);\r\nif (retval < 0) {\r\ndev_err(udc->dev, "failed to start USB otg clock\n");\r\ngoto usb_otg_clk_enable_fail;\r\n}\r\nudc->poweron = udc->pullup = 0;\r\nINIT_WORK(&udc->pullup_job, pullup_work);\r\nINIT_WORK(&udc->vbus_job, vbus_work);\r\n#ifdef CONFIG_PM\r\nINIT_WORK(&udc->power_job, power_work);\r\n#endif\r\nudc->clocked = 1;\r\nisp1301_udc_configure(udc);\r\nudc->udca_v_base = dma_alloc_coherent(&pdev->dev, UDCA_BUFF_SIZE,\r\n&dma_handle,\r\n(GFP_KERNEL | GFP_DMA));\r\nif (!udc->udca_v_base) {\r\ndev_err(udc->dev, "error getting UDCA region\n");\r\nretval = -ENOMEM;\r\ngoto i2c_fail;\r\n}\r\nudc->udca_p_base = dma_handle;\r\ndev_dbg(udc->dev, "DMA buffer(0x%x bytes), P:0x%08x, V:0x%p\n",\r\nUDCA_BUFF_SIZE, udc->udca_p_base, udc->udca_v_base);\r\nudc->dd_cache = dma_pool_create("udc_dd", udc->dev,\r\nsizeof(struct lpc32xx_usbd_dd_gad),\r\nsizeof(u32), 0);\r\nif (!udc->dd_cache) {\r\ndev_err(udc->dev, "error getting DD DMA region\n");\r\nretval = -ENOMEM;\r\ngoto dma_alloc_fail;\r\n}\r\nudc_disable(udc);\r\nudc_reinit(udc);\r\nretval = request_irq(udc->udp_irq[IRQ_USB_LP], lpc32xx_usb_lp_irq,\r\n0, "udc_lp", udc);\r\nif (retval < 0) {\r\ndev_err(udc->dev, "LP request irq %d failed\n",\r\nudc->udp_irq[IRQ_USB_LP]);\r\ngoto irq_lp_fail;\r\n}\r\nretval = request_irq(udc->udp_irq[IRQ_USB_HP], lpc32xx_usb_hp_irq,\r\n0, "udc_hp", udc);\r\nif (retval < 0) {\r\ndev_err(udc->dev, "HP request irq %d failed\n",\r\nudc->udp_irq[IRQ_USB_HP]);\r\ngoto irq_hp_fail;\r\n}\r\nretval = request_irq(udc->udp_irq[IRQ_USB_DEVDMA],\r\nlpc32xx_usb_devdma_irq, 0, "udc_dma", udc);\r\nif (retval < 0) {\r\ndev_err(udc->dev, "DEV request irq %d failed\n",\r\nudc->udp_irq[IRQ_USB_DEVDMA]);\r\ngoto irq_dev_fail;\r\n}\r\nretval = request_irq(udc->udp_irq[IRQ_USB_ATX], lpc32xx_usb_vbus_irq,\r\n0, "udc_otg", udc);\r\nif (retval < 0) {\r\ndev_err(udc->dev, "VBUS request irq %d failed\n",\r\nudc->udp_irq[IRQ_USB_ATX]);\r\ngoto irq_xcvr_fail;\r\n}\r\ninit_waitqueue_head(&udc->ep_disable_wait_queue);\r\natomic_set(&udc->enabled_ep_cnt, 0);\r\nfor (i = IRQ_USB_LP; i <= IRQ_USB_ATX; i++)\r\ndisable_irq(udc->udp_irq[i]);\r\nretval = usb_add_gadget_udc(dev, &udc->gadget);\r\nif (retval < 0)\r\ngoto add_gadget_fail;\r\ndev_set_drvdata(dev, udc);\r\ndevice_init_wakeup(dev, 1);\r\ncreate_debug_file(udc);\r\nudc_clk_set(udc, 0);\r\ndev_info(udc->dev, "%s version %s\n", driver_name, DRIVER_VERSION);\r\nreturn 0;\r\nadd_gadget_fail:\r\nfree_irq(udc->udp_irq[IRQ_USB_ATX], udc);\r\nirq_xcvr_fail:\r\nfree_irq(udc->udp_irq[IRQ_USB_DEVDMA], udc);\r\nirq_dev_fail:\r\nfree_irq(udc->udp_irq[IRQ_USB_HP], udc);\r\nirq_hp_fail:\r\nfree_irq(udc->udp_irq[IRQ_USB_LP], udc);\r\nirq_lp_fail:\r\ndma_pool_destroy(udc->dd_cache);\r\ndma_alloc_fail:\r\ndma_free_coherent(&pdev->dev, UDCA_BUFF_SIZE,\r\nudc->udca_v_base, udc->udca_p_base);\r\ni2c_fail:\r\nclk_disable(udc->usb_otg_clk);\r\nusb_otg_clk_enable_fail:\r\nclk_disable(udc->usb_slv_clk);\r\nusb_clk_enable_fail:\r\npll_set_fail:\r\nclk_disable(udc->usb_pll_clk);\r\npll_enable_fail:\r\nclk_put(udc->usb_otg_clk);\r\nusb_otg_clk_get_fail:\r\nclk_put(udc->usb_slv_clk);\r\nusb_clk_get_fail:\r\nclk_put(udc->usb_pll_clk);\r\npll_get_fail:\r\niounmap(udc->udp_baseaddr);\r\nio_map_fail:\r\nrelease_mem_region(udc->io_p_start, udc->io_p_size);\r\ndev_err(udc->dev, "%s probe failed, %d\n", driver_name, retval);\r\nrequest_mem_region_fail:\r\nirq_fail:\r\nresource_fail:\r\nphy_fail:\r\nkfree(udc);\r\nreturn retval;\r\n}\r\nstatic int lpc32xx_udc_remove(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_udc *udc = platform_get_drvdata(pdev);\r\nusb_del_gadget_udc(&udc->gadget);\r\nif (udc->driver)\r\nreturn -EBUSY;\r\nudc_clk_set(udc, 1);\r\nudc_disable(udc);\r\npullup(udc, 0);\r\nfree_irq(udc->udp_irq[IRQ_USB_ATX], udc);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nremove_debug_file(udc);\r\ndma_pool_destroy(udc->dd_cache);\r\ndma_free_coherent(&pdev->dev, UDCA_BUFF_SIZE,\r\nudc->udca_v_base, udc->udca_p_base);\r\nfree_irq(udc->udp_irq[IRQ_USB_DEVDMA], udc);\r\nfree_irq(udc->udp_irq[IRQ_USB_HP], udc);\r\nfree_irq(udc->udp_irq[IRQ_USB_LP], udc);\r\nclk_disable(udc->usb_otg_clk);\r\nclk_put(udc->usb_otg_clk);\r\nclk_disable(udc->usb_slv_clk);\r\nclk_put(udc->usb_slv_clk);\r\nclk_disable(udc->usb_pll_clk);\r\nclk_put(udc->usb_pll_clk);\r\niounmap(udc->udp_baseaddr);\r\nrelease_mem_region(udc->io_p_start, udc->io_p_size);\r\nkfree(udc);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_udc_suspend(struct platform_device *pdev, pm_message_t mesg)\r\n{\r\nstruct lpc32xx_udc *udc = platform_get_drvdata(pdev);\r\nif (udc->clocked) {\r\nudc->poweron = 0;\r\nisp1301_set_powerstate(udc, 0);\r\nudc_clk_set(udc, 0);\r\nudc->clocked = 1;\r\nclk_disable(udc->usb_slv_clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_udc_resume(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_udc *udc = platform_get_drvdata(pdev);\r\nif (udc->clocked) {\r\nclk_enable(udc->usb_slv_clk);\r\nudc_clk_set(udc, 1);\r\nudc->poweron = 1;\r\nisp1301_set_powerstate(udc, 1);\r\n}\r\nreturn 0;\r\n}
