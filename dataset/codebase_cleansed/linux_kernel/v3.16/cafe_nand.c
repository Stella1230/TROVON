static int cafe_device_ready(struct mtd_info *mtd)\r\n{\r\nstruct cafe_priv *cafe = mtd->priv;\r\nint result = !!(cafe_readl(cafe, NAND_STATUS) & 0x40000000);\r\nuint32_t irqs = cafe_readl(cafe, NAND_IRQ);\r\ncafe_writel(cafe, irqs, NAND_IRQ);\r\ncafe_dev_dbg(&cafe->pdev->dev, "NAND device is%s ready, IRQ %x (%x) (%x,%x)\n",\r\nresult?"":" not", irqs, cafe_readl(cafe, NAND_IRQ),\r\ncafe_readl(cafe, GLOBAL_IRQ), cafe_readl(cafe, GLOBAL_IRQ_MASK));\r\nreturn result;\r\n}\r\nstatic void cafe_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nstruct cafe_priv *cafe = mtd->priv;\r\nif (usedma)\r\nmemcpy(cafe->dmabuf + cafe->datalen, buf, len);\r\nelse\r\nmemcpy_toio(cafe->mmio + CAFE_NAND_WRITE_DATA + cafe->datalen, buf, len);\r\ncafe->datalen += len;\r\ncafe_dev_dbg(&cafe->pdev->dev, "Copy 0x%x bytes to write buffer. datalen 0x%x\n",\r\nlen, cafe->datalen);\r\n}\r\nstatic void cafe_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct cafe_priv *cafe = mtd->priv;\r\nif (usedma)\r\nmemcpy(buf, cafe->dmabuf + cafe->datalen, len);\r\nelse\r\nmemcpy_fromio(buf, cafe->mmio + CAFE_NAND_READ_DATA + cafe->datalen, len);\r\ncafe_dev_dbg(&cafe->pdev->dev, "Copy 0x%x bytes from position 0x%x in read buffer.\n",\r\nlen, cafe->datalen);\r\ncafe->datalen += len;\r\n}\r\nstatic uint8_t cafe_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct cafe_priv *cafe = mtd->priv;\r\nuint8_t d;\r\ncafe_read_buf(mtd, &d, 1);\r\ncafe_dev_dbg(&cafe->pdev->dev, "Read %02x\n", d);\r\nreturn d;\r\n}\r\nstatic void cafe_nand_cmdfunc(struct mtd_info *mtd, unsigned command,\r\nint column, int page_addr)\r\n{\r\nstruct cafe_priv *cafe = mtd->priv;\r\nint adrbytes = 0;\r\nuint32_t ctl1;\r\nuint32_t doneint = 0x80000000;\r\ncafe_dev_dbg(&cafe->pdev->dev, "cmdfunc %02x, 0x%x, 0x%x\n",\r\ncommand, column, page_addr);\r\nif (command == NAND_CMD_ERASE2 || command == NAND_CMD_PAGEPROG) {\r\ncafe_writel(cafe, cafe->ctl2 | 0x100 | command, NAND_CTRL2);\r\nctl1 = cafe->ctl1;\r\ncafe->ctl2 &= ~(1<<30);\r\ncafe_dev_dbg(&cafe->pdev->dev, "Continue command, ctl1 %08x, #data %d\n",\r\ncafe->ctl1, cafe->nr_data);\r\ngoto do_command;\r\n}\r\ncafe_writel(cafe, 0, NAND_CTRL2);\r\nif (mtd->writesize > 512 &&\r\ncommand == NAND_CMD_READOOB) {\r\ncolumn += mtd->writesize;\r\ncommand = NAND_CMD_READ0;\r\n}\r\nif (column != -1) {\r\ncafe_writel(cafe, column, NAND_ADDR1);\r\nadrbytes = 2;\r\nif (page_addr != -1)\r\ngoto write_adr2;\r\n} else if (page_addr != -1) {\r\ncafe_writel(cafe, page_addr & 0xffff, NAND_ADDR1);\r\npage_addr >>= 16;\r\nwrite_adr2:\r\ncafe_writel(cafe, page_addr, NAND_ADDR2);\r\nadrbytes += 2;\r\nif (mtd->size > mtd->writesize << 16)\r\nadrbytes++;\r\n}\r\ncafe->data_pos = cafe->datalen = 0;\r\nctl1 = 0x80000000 | command | (cafe->ctl1 & CTRL1_CHIPSELECT);\r\nif (command == NAND_CMD_READID || command == NAND_CMD_STATUS) {\r\nctl1 |= (1<<26);\r\ncafe->datalen = 4;\r\nadrbytes = 1;\r\n} else if (command == NAND_CMD_READ0 || command == NAND_CMD_READ1 ||\r\ncommand == NAND_CMD_READOOB || command == NAND_CMD_RNDOUT) {\r\nctl1 |= 1<<26;\r\ncafe->datalen = mtd->writesize + mtd->oobsize - column;\r\n} else if (command == NAND_CMD_SEQIN)\r\nctl1 |= 1<<25;\r\nif (adrbytes)\r\nctl1 |= ((adrbytes-1)|8) << 27;\r\nif (command == NAND_CMD_SEQIN || command == NAND_CMD_ERASE1) {\r\ncafe->ctl1 = ctl1;\r\ncafe_dev_dbg(&cafe->pdev->dev, "Setup for delayed command, ctl1 %08x, dlen %x\n",\r\ncafe->ctl1, cafe->datalen);\r\nreturn;\r\n}\r\nif (command == NAND_CMD_RNDOUT)\r\ncafe_writel(cafe, cafe->ctl2 | 0x100 | NAND_CMD_RNDOUTSTART, NAND_CTRL2);\r\nelse if (command == NAND_CMD_READ0 && mtd->writesize > 512)\r\ncafe_writel(cafe, cafe->ctl2 | 0x100 | NAND_CMD_READSTART, NAND_CTRL2);\r\ndo_command:\r\ncafe_dev_dbg(&cafe->pdev->dev, "dlen %x, ctl1 %x, ctl2 %x\n",\r\ncafe->datalen, ctl1, cafe_readl(cafe, NAND_CTRL2));\r\ncafe_writel(cafe, cafe->datalen, NAND_DATA_LEN);\r\ncafe_writel(cafe, 0x90000000, NAND_IRQ);\r\nif (usedma && (ctl1 & (3<<25))) {\r\nuint32_t dmactl = 0xc0000000 + cafe->datalen;\r\nif (ctl1 & (1<<26)) {\r\ndmactl |= (1<<29);\r\ndoneint = 0x10000000;\r\n}\r\ncafe_writel(cafe, dmactl, NAND_DMA_CTRL);\r\n}\r\ncafe->datalen = 0;\r\nif (unlikely(regdebug)) {\r\nint i;\r\nprintk("About to write command %08x to register 0\n", ctl1);\r\nfor (i=4; i< 0x5c; i+=4)\r\nprintk("Register %x: %08x\n", i, readl(cafe->mmio + i));\r\n}\r\ncafe_writel(cafe, ctl1, NAND_CTRL1);\r\nndelay(100);\r\nif (1) {\r\nint c;\r\nuint32_t irqs;\r\nfor (c = 500000; c != 0; c--) {\r\nirqs = cafe_readl(cafe, NAND_IRQ);\r\nif (irqs & doneint)\r\nbreak;\r\nudelay(1);\r\nif (!(c % 100000))\r\ncafe_dev_dbg(&cafe->pdev->dev, "Wait for ready, IRQ %x\n", irqs);\r\ncpu_relax();\r\n}\r\ncafe_writel(cafe, doneint, NAND_IRQ);\r\ncafe_dev_dbg(&cafe->pdev->dev, "Command %x completed after %d usec, irqs %x (%x)\n",\r\ncommand, 500000-c, irqs, cafe_readl(cafe, NAND_IRQ));\r\n}\r\nWARN_ON(cafe->ctl2 & (1<<30));\r\nswitch (command) {\r\ncase NAND_CMD_CACHEDPROG:\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\ncase NAND_CMD_SEQIN:\r\ncase NAND_CMD_RNDIN:\r\ncase NAND_CMD_STATUS:\r\ncase NAND_CMD_RNDOUT:\r\ncafe_writel(cafe, cafe->ctl2, NAND_CTRL2);\r\nreturn;\r\n}\r\nnand_wait_ready(mtd);\r\ncafe_writel(cafe, cafe->ctl2, NAND_CTRL2);\r\n}\r\nstatic void cafe_select_chip(struct mtd_info *mtd, int chipnr)\r\n{\r\nstruct cafe_priv *cafe = mtd->priv;\r\ncafe_dev_dbg(&cafe->pdev->dev, "select_chip %d\n", chipnr);\r\nif (chipnr)\r\ncafe->ctl1 |= CTRL1_CHIPSELECT;\r\nelse\r\ncafe->ctl1 &= ~CTRL1_CHIPSELECT;\r\n}\r\nstatic irqreturn_t cafe_nand_interrupt(int irq, void *id)\r\n{\r\nstruct mtd_info *mtd = id;\r\nstruct cafe_priv *cafe = mtd->priv;\r\nuint32_t irqs = cafe_readl(cafe, NAND_IRQ);\r\ncafe_writel(cafe, irqs & ~0x90000000, NAND_IRQ);\r\nif (!irqs)\r\nreturn IRQ_NONE;\r\ncafe_dev_dbg(&cafe->pdev->dev, "irq, bits %x (%x)\n", irqs, cafe_readl(cafe, NAND_IRQ));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void cafe_nand_bug(struct mtd_info *mtd)\r\n{\r\nBUG();\r\n}\r\nstatic int cafe_nand_write_oob(struct mtd_info *mtd,\r\nstruct nand_chip *chip, int page)\r\n{\r\nint status = 0;\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nreturn status & NAND_STATUS_FAIL ? -EIO : 0;\r\n}\r\nstatic int cafe_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nchip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int cafe_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nstruct cafe_priv *cafe = mtd->priv;\r\nunsigned int max_bitflips = 0;\r\ncafe_dev_dbg(&cafe->pdev->dev, "ECC result %08x SYN1,2 %08x\n",\r\ncafe_readl(cafe, NAND_ECC_RESULT),\r\ncafe_readl(cafe, NAND_ECC_SYN01));\r\nchip->read_buf(mtd, buf, mtd->writesize);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nif (checkecc && cafe_readl(cafe, NAND_ECC_RESULT) & (1<<18)) {\r\nunsigned short syn[8], pat[4];\r\nint pos[4];\r\nu8 *oob = chip->oob_poi;\r\nint i, n;\r\nfor (i=0; i<8; i+=2) {\r\nuint32_t tmp = cafe_readl(cafe, NAND_ECC_SYN01 + (i*2));\r\nsyn[i] = cafe->rs->index_of[tmp & 0xfff];\r\nsyn[i+1] = cafe->rs->index_of[(tmp >> 16) & 0xfff];\r\n}\r\nn = decode_rs16(cafe->rs, NULL, NULL, 1367, syn, 0, pos, 0,\r\npat);\r\nfor (i = 0; i < n; i++) {\r\nint p = pos[i];\r\nif (p > 1374) {\r\nn = -1374;\r\n} else if (p == 0) {\r\nif (pat[i] > 0xff)\r\nn = -2048;\r\nelse\r\nbuf[0] ^= pat[i];\r\n} else if (p == 1365) {\r\nbuf[2047] ^= pat[i] >> 4;\r\noob[0] ^= pat[i] << 4;\r\n} else if (p > 1365) {\r\nif ((p & 1) == 1) {\r\noob[3*p/2 - 2048] ^= pat[i] >> 4;\r\noob[3*p/2 - 2047] ^= pat[i] << 4;\r\n} else {\r\noob[3*p/2 - 2049] ^= pat[i] >> 8;\r\noob[3*p/2 - 2048] ^= pat[i];\r\n}\r\n} else if ((p & 1) == 1) {\r\nbuf[3*p/2] ^= pat[i] >> 4;\r\nbuf[3*p/2 + 1] ^= pat[i] << 4;\r\n} else {\r\nbuf[3*p/2 - 1] ^= pat[i] >> 8;\r\nbuf[3*p/2] ^= pat[i];\r\n}\r\n}\r\nif (n < 0) {\r\ndev_dbg(&cafe->pdev->dev, "Failed to correct ECC at %08x\n",\r\ncafe_readl(cafe, NAND_ADDR2) * 2048);\r\nfor (i = 0; i < 0x5c; i += 4)\r\nprintk("Register %x: %08x\n", i, readl(cafe->mmio + i));\r\nmtd->ecc_stats.failed++;\r\n} else {\r\ndev_dbg(&cafe->pdev->dev, "Corrected %d symbol errors\n", n);\r\nmtd->ecc_stats.corrected += n;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, n);\r\n}\r\n}\r\nreturn max_bitflips;\r\n}\r\nstatic int cafe_nand_write_page_lowlevel(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nstruct cafe_priv *cafe = mtd->priv;\r\nchip->write_buf(mtd, buf, mtd->writesize);\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\ncafe->ctl2 |= (1<<30);\r\nreturn 0;\r\n}\r\nstatic int cafe_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint32_t offset, int data_len, const uint8_t *buf,\r\nint oob_required, int page, int cached, int raw)\r\n{\r\nint status;\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);\r\nif (unlikely(raw))\r\nstatus = chip->ecc.write_page_raw(mtd, chip, buf, oob_required);\r\nelse\r\nstatus = chip->ecc.write_page(mtd, chip, buf, oob_required);\r\nif (status < 0)\r\nreturn status;\r\ncached = 0;\r\nif (!cached || !(chip->options & NAND_CACHEPRG)) {\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif ((status & NAND_STATUS_FAIL) && (chip->errstat))\r\nstatus = chip->errstat(mtd, chip, FL_WRITING, status,\r\npage);\r\nif (status & NAND_STATUS_FAIL)\r\nreturn -EIO;\r\n} else {\r\nchip->cmdfunc(mtd, NAND_CMD_CACHEDPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cafe_nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned short gf64_mul(u8 a, u8 b)\r\n{\r\nu8 c;\r\nunsigned int i;\r\nc = 0;\r\nfor (i = 0; i < 6; i++) {\r\nif (a & 1)\r\nc ^= b;\r\na >>= 1;\r\nb <<= 1;\r\nif ((b & 0x40) != 0)\r\nb ^= 0x43;\r\n}\r\nreturn c;\r\n}\r\nstatic u16 gf4096_mul(u16 a, u16 b)\r\n{\r\nu8 ah, al, bh, bl, ch, cl;\r\nah = a >> 6;\r\nal = a & 0x3f;\r\nbh = b >> 6;\r\nbl = b & 0x3f;\r\nch = gf64_mul(ah ^ al, bh ^ bl) ^ gf64_mul(al, bl);\r\ncl = gf64_mul(gf64_mul(ah, bh), 0x21) ^ gf64_mul(al, bl);\r\nreturn (ch << 6) ^ cl;\r\n}\r\nstatic int cafe_mul(int x)\r\n{\r\nif (x == 0)\r\nreturn 1;\r\nreturn gf4096_mul(x, 0xe01);\r\n}\r\nstatic int cafe_nand_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct mtd_info *mtd;\r\nstruct cafe_priv *cafe;\r\nuint32_t ctrl;\r\nint err = 0;\r\nint old_dma;\r\nstruct nand_buffers *nbuf;\r\nif ((pdev->class >> 8) != PCI_CLASS_MEMORY_FLASH)\r\nreturn -ENODEV;\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\npci_set_master(pdev);\r\nmtd = kzalloc(sizeof(*mtd) + sizeof(struct cafe_priv), GFP_KERNEL);\r\nif (!mtd)\r\nreturn -ENOMEM;\r\ncafe = (void *)(&mtd[1]);\r\nmtd->dev.parent = &pdev->dev;\r\nmtd->priv = cafe;\r\nmtd->owner = THIS_MODULE;\r\ncafe->pdev = pdev;\r\ncafe->mmio = pci_iomap(pdev, 0, 0);\r\nif (!cafe->mmio) {\r\ndev_warn(&pdev->dev, "failed to iomap\n");\r\nerr = -ENOMEM;\r\ngoto out_free_mtd;\r\n}\r\ncafe->rs = init_rs_non_canonical(12, &cafe_mul, 0, 1, 8);\r\nif (!cafe->rs) {\r\nerr = -ENOMEM;\r\ngoto out_ior;\r\n}\r\ncafe->nand.cmdfunc = cafe_nand_cmdfunc;\r\ncafe->nand.dev_ready = cafe_device_ready;\r\ncafe->nand.read_byte = cafe_read_byte;\r\ncafe->nand.read_buf = cafe_read_buf;\r\ncafe->nand.write_buf = cafe_write_buf;\r\ncafe->nand.select_chip = cafe_select_chip;\r\ncafe->nand.chip_delay = 0;\r\ncafe->nand.bbt_options = NAND_BBT_USE_FLASH;\r\ncafe->nand.options = NAND_OWN_BUFFERS;\r\nif (skipbbt) {\r\ncafe->nand.options |= NAND_SKIP_BBTSCAN;\r\ncafe->nand.block_bad = cafe_nand_block_bad;\r\n}\r\nif (numtimings && numtimings != 3) {\r\ndev_warn(&cafe->pdev->dev, "%d timing register values ignored; precisely three are required\n", numtimings);\r\n}\r\nif (numtimings == 3) {\r\ncafe_dev_dbg(&cafe->pdev->dev, "Using provided timings (%08x %08x %08x)\n",\r\ntiming[0], timing[1], timing[2]);\r\n} else {\r\ntiming[0] = cafe_readl(cafe, NAND_TIMING1);\r\ntiming[1] = cafe_readl(cafe, NAND_TIMING2);\r\ntiming[2] = cafe_readl(cafe, NAND_TIMING3);\r\nif (timing[0] | timing[1] | timing[2]) {\r\ncafe_dev_dbg(&cafe->pdev->dev, "Timing registers already set (%08x %08x %08x)\n",\r\ntiming[0], timing[1], timing[2]);\r\n} else {\r\ndev_warn(&cafe->pdev->dev, "Timing registers unset; using most conservative defaults\n");\r\ntiming[0] = timing[1] = timing[2] = 0xffffffff;\r\n}\r\n}\r\ncafe_writel(cafe, 1, NAND_RESET);\r\ncafe_writel(cafe, 0, NAND_RESET);\r\ncafe_writel(cafe, timing[0], NAND_TIMING1);\r\ncafe_writel(cafe, timing[1], NAND_TIMING2);\r\ncafe_writel(cafe, timing[2], NAND_TIMING3);\r\ncafe_writel(cafe, 0xffffffff, NAND_IRQ_MASK);\r\nerr = request_irq(pdev->irq, &cafe_nand_interrupt, IRQF_SHARED,\r\n"CAFE NAND", mtd);\r\nif (err) {\r\ndev_warn(&pdev->dev, "Could not register IRQ %d\n", pdev->irq);\r\ngoto out_ior;\r\n}\r\nctrl = cafe_readl(cafe, GLOBAL_CTRL);\r\nctrl &= 0xffffeff0;\r\nctrl |= 0x00007000;\r\ncafe_writel(cafe, ctrl | 0x05, GLOBAL_CTRL);\r\ncafe_writel(cafe, ctrl | 0x0a, GLOBAL_CTRL);\r\ncafe_writel(cafe, 0, NAND_DMA_CTRL);\r\ncafe_writel(cafe, 0x7006, GLOBAL_CTRL);\r\ncafe_writel(cafe, 0x700a, GLOBAL_CTRL);\r\ncafe_writel(cafe, 0x80000007, GLOBAL_IRQ_MASK);\r\ncafe_dev_dbg(&cafe->pdev->dev, "Control %x, IRQ mask %x\n",\r\ncafe_readl(cafe, GLOBAL_CTRL),\r\ncafe_readl(cafe, GLOBAL_IRQ_MASK));\r\nold_dma = usedma;\r\nusedma = 0;\r\nif (nand_scan_ident(mtd, 2, NULL)) {\r\nerr = -ENXIO;\r\ngoto out_irq;\r\n}\r\ncafe->dmabuf = dma_alloc_coherent(&cafe->pdev->dev,\r\n2112 + sizeof(struct nand_buffers) +\r\nmtd->writesize + mtd->oobsize,\r\n&cafe->dmaaddr, GFP_KERNEL);\r\nif (!cafe->dmabuf) {\r\nerr = -ENOMEM;\r\ngoto out_irq;\r\n}\r\ncafe->nand.buffers = nbuf = (void *)cafe->dmabuf + 2112;\r\ncafe_writel(cafe, cafe->dmaaddr & 0xffffffff, NAND_DMA_ADDR0);\r\nif (sizeof(cafe->dmaaddr) > 4)\r\ncafe_writel(cafe, (cafe->dmaaddr >> 16) >> 16, NAND_DMA_ADDR1);\r\nelse\r\ncafe_writel(cafe, 0, NAND_DMA_ADDR1);\r\ncafe_dev_dbg(&cafe->pdev->dev, "Set DMA address to %x (virt %p)\n",\r\ncafe_readl(cafe, NAND_DMA_ADDR0), cafe->dmabuf);\r\nnbuf->ecccalc = NULL;\r\nnbuf->ecccode = NULL;\r\nnbuf->databuf = (uint8_t *)(nbuf + 1);\r\nusedma = old_dma;\r\ncafe->ctl2 = 1<<27;\r\nif (mtd->writesize == 2048)\r\ncafe->ctl2 |= 1<<29;\r\nif (mtd->writesize == 2048) {\r\ncafe->nand.ecc.layout = &cafe_oobinfo_2048;\r\ncafe->nand.bbt_td = &cafe_bbt_main_descr_2048;\r\ncafe->nand.bbt_md = &cafe_bbt_mirror_descr_2048;\r\n} else if (mtd->writesize == 512) {\r\ncafe->nand.ecc.layout = &cafe_oobinfo_512;\r\ncafe->nand.bbt_td = &cafe_bbt_main_descr_512;\r\ncafe->nand.bbt_md = &cafe_bbt_mirror_descr_512;\r\n} else {\r\nprintk(KERN_WARNING "Unexpected NAND flash writesize %d. Aborting\n",\r\nmtd->writesize);\r\ngoto out_free_dma;\r\n}\r\ncafe->nand.ecc.mode = NAND_ECC_HW_SYNDROME;\r\ncafe->nand.ecc.size = mtd->writesize;\r\ncafe->nand.ecc.bytes = 14;\r\ncafe->nand.ecc.strength = 4;\r\ncafe->nand.ecc.hwctl = (void *)cafe_nand_bug;\r\ncafe->nand.ecc.calculate = (void *)cafe_nand_bug;\r\ncafe->nand.ecc.correct = (void *)cafe_nand_bug;\r\ncafe->nand.write_page = cafe_nand_write_page;\r\ncafe->nand.ecc.write_page = cafe_nand_write_page_lowlevel;\r\ncafe->nand.ecc.write_oob = cafe_nand_write_oob;\r\ncafe->nand.ecc.read_page = cafe_nand_read_page;\r\ncafe->nand.ecc.read_oob = cafe_nand_read_oob;\r\nerr = nand_scan_tail(mtd);\r\nif (err)\r\ngoto out_free_dma;\r\npci_set_drvdata(pdev, mtd);\r\nmtd->name = "cafe_nand";\r\nmtd_device_parse_register(mtd, part_probes, NULL, NULL, 0);\r\ngoto out;\r\nout_free_dma:\r\ndma_free_coherent(&cafe->pdev->dev,\r\n2112 + sizeof(struct nand_buffers) +\r\nmtd->writesize + mtd->oobsize,\r\ncafe->dmabuf, cafe->dmaaddr);\r\nout_irq:\r\ncafe_writel(cafe, ~1 & cafe_readl(cafe, GLOBAL_IRQ_MASK), GLOBAL_IRQ_MASK);\r\nfree_irq(pdev->irq, mtd);\r\nout_ior:\r\npci_iounmap(pdev, cafe->mmio);\r\nout_free_mtd:\r\nkfree(mtd);\r\nout:\r\nreturn err;\r\n}\r\nstatic void cafe_nand_remove(struct pci_dev *pdev)\r\n{\r\nstruct mtd_info *mtd = pci_get_drvdata(pdev);\r\nstruct cafe_priv *cafe = mtd->priv;\r\ncafe_writel(cafe, ~1 & cafe_readl(cafe, GLOBAL_IRQ_MASK), GLOBAL_IRQ_MASK);\r\nfree_irq(pdev->irq, mtd);\r\nnand_release(mtd);\r\nfree_rs(cafe->rs);\r\npci_iounmap(pdev, cafe->mmio);\r\ndma_free_coherent(&cafe->pdev->dev,\r\n2112 + sizeof(struct nand_buffers) +\r\nmtd->writesize + mtd->oobsize,\r\ncafe->dmabuf, cafe->dmaaddr);\r\nkfree(mtd);\r\n}\r\nstatic int cafe_nand_resume(struct pci_dev *pdev)\r\n{\r\nuint32_t ctrl;\r\nstruct mtd_info *mtd = pci_get_drvdata(pdev);\r\nstruct cafe_priv *cafe = mtd->priv;\r\ncafe_writel(cafe, 1, NAND_RESET);\r\ncafe_writel(cafe, 0, NAND_RESET);\r\ncafe_writel(cafe, 0xffffffff, NAND_IRQ_MASK);\r\ncafe_writel(cafe, timing[0], NAND_TIMING1);\r\ncafe_writel(cafe, timing[1], NAND_TIMING2);\r\ncafe_writel(cafe, timing[2], NAND_TIMING3);\r\nctrl = cafe_readl(cafe, GLOBAL_CTRL);\r\nctrl &= 0xffffeff0;\r\nctrl |= 0x00007000;\r\ncafe_writel(cafe, ctrl | 0x05, GLOBAL_CTRL);\r\ncafe_writel(cafe, ctrl | 0x0a, GLOBAL_CTRL);\r\ncafe_writel(cafe, 0, NAND_DMA_CTRL);\r\ncafe_writel(cafe, 0x7006, GLOBAL_CTRL);\r\ncafe_writel(cafe, 0x700a, GLOBAL_CTRL);\r\ncafe_writel(cafe, cafe->dmaaddr & 0xffffffff, NAND_DMA_ADDR0);\r\nif (sizeof(cafe->dmaaddr) > 4)\r\ncafe_writel(cafe, (cafe->dmaaddr >> 16) >> 16, NAND_DMA_ADDR1);\r\nelse\r\ncafe_writel(cafe, 0, NAND_DMA_ADDR1);\r\ncafe_writel(cafe, 0x80000007, GLOBAL_IRQ_MASK);\r\nreturn 0;\r\n}
