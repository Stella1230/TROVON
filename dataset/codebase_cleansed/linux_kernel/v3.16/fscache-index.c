int nfs_fscache_register(void)\r\n{\r\nreturn fscache_register_netfs(&nfs_fscache_netfs);\r\n}\r\nvoid nfs_fscache_unregister(void)\r\n{\r\nfscache_unregister_netfs(&nfs_fscache_netfs);\r\n}\r\nstatic uint16_t nfs_server_get_key(const void *cookie_netfs_data,\r\nvoid *buffer, uint16_t bufmax)\r\n{\r\nconst struct nfs_client *clp = cookie_netfs_data;\r\nconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) &clp->cl_addr;\r\nconst struct sockaddr_in *sin = (struct sockaddr_in *) &clp->cl_addr;\r\nstruct nfs_server_key *key = buffer;\r\nuint16_t len = sizeof(struct nfs_server_key);\r\nkey->nfsversion = clp->rpc_ops->version;\r\nkey->family = clp->cl_addr.ss_family;\r\nmemset(key, 0, len);\r\nswitch (clp->cl_addr.ss_family) {\r\ncase AF_INET:\r\nkey->port = sin->sin_port;\r\nkey->addr[0].ipv4_addr = sin->sin_addr;\r\nlen += sizeof(key->addr[0].ipv4_addr);\r\nbreak;\r\ncase AF_INET6:\r\nkey->port = sin6->sin6_port;\r\nkey->addr[0].ipv6_addr = sin6->sin6_addr;\r\nlen += sizeof(key->addr[0].ipv6_addr);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "NFS: Unknown network family '%d'\n",\r\nclp->cl_addr.ss_family);\r\nlen = 0;\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nstatic uint16_t nfs_super_get_key(const void *cookie_netfs_data,\r\nvoid *buffer, uint16_t bufmax)\r\n{\r\nconst struct nfs_fscache_key *key;\r\nconst struct nfs_server *nfss = cookie_netfs_data;\r\nuint16_t len;\r\nkey = nfss->fscache_key;\r\nlen = sizeof(key->key) + key->key.uniq_len;\r\nif (len > bufmax) {\r\nlen = 0;\r\n} else {\r\nmemcpy(buffer, &key->key, sizeof(key->key));\r\nmemcpy(buffer + sizeof(key->key),\r\nkey->key.uniquifier, key->key.uniq_len);\r\n}\r\nreturn len;\r\n}\r\nstatic uint16_t nfs_fscache_inode_get_key(const void *cookie_netfs_data,\r\nvoid *buffer, uint16_t bufmax)\r\n{\r\nconst struct nfs_inode *nfsi = cookie_netfs_data;\r\nuint16_t nsize;\r\nnsize = nfsi->fh.size;\r\nmemcpy(buffer, nfsi->fh.data, nsize);\r\nreturn nsize;\r\n}\r\nstatic void nfs_fscache_inode_get_attr(const void *cookie_netfs_data,\r\nuint64_t *size)\r\n{\r\nconst struct nfs_inode *nfsi = cookie_netfs_data;\r\n*size = nfsi->vfs_inode.i_size;\r\n}\r\nstatic uint16_t nfs_fscache_inode_get_aux(const void *cookie_netfs_data,\r\nvoid *buffer, uint16_t bufmax)\r\n{\r\nstruct nfs_fscache_inode_auxdata auxdata;\r\nconst struct nfs_inode *nfsi = cookie_netfs_data;\r\nmemset(&auxdata, 0, sizeof(auxdata));\r\nauxdata.size = nfsi->vfs_inode.i_size;\r\nauxdata.mtime = nfsi->vfs_inode.i_mtime;\r\nauxdata.ctime = nfsi->vfs_inode.i_ctime;\r\nif (NFS_SERVER(&nfsi->vfs_inode)->nfs_client->rpc_ops->version == 4)\r\nauxdata.change_attr = nfsi->vfs_inode.i_version;\r\nif (bufmax > sizeof(auxdata))\r\nbufmax = sizeof(auxdata);\r\nmemcpy(buffer, &auxdata, bufmax);\r\nreturn bufmax;\r\n}\r\nstatic\r\nenum fscache_checkaux nfs_fscache_inode_check_aux(void *cookie_netfs_data,\r\nconst void *data,\r\nuint16_t datalen)\r\n{\r\nstruct nfs_fscache_inode_auxdata auxdata;\r\nstruct nfs_inode *nfsi = cookie_netfs_data;\r\nif (datalen != sizeof(auxdata))\r\nreturn FSCACHE_CHECKAUX_OBSOLETE;\r\nmemset(&auxdata, 0, sizeof(auxdata));\r\nauxdata.size = nfsi->vfs_inode.i_size;\r\nauxdata.mtime = nfsi->vfs_inode.i_mtime;\r\nauxdata.ctime = nfsi->vfs_inode.i_ctime;\r\nif (NFS_SERVER(&nfsi->vfs_inode)->nfs_client->rpc_ops->version == 4)\r\nauxdata.change_attr = nfsi->vfs_inode.i_version;\r\nif (memcmp(data, &auxdata, datalen) != 0)\r\nreturn FSCACHE_CHECKAUX_OBSOLETE;\r\nreturn FSCACHE_CHECKAUX_OKAY;\r\n}\r\nstatic void nfs_fscache_inode_now_uncached(void *cookie_netfs_data)\r\n{\r\nstruct nfs_inode *nfsi = cookie_netfs_data;\r\nstruct pagevec pvec;\r\npgoff_t first;\r\nint loop, nr_pages;\r\npagevec_init(&pvec, 0);\r\nfirst = 0;\r\ndprintk("NFS: nfs_inode_now_uncached: nfs_inode 0x%p\n", nfsi);\r\nfor (;;) {\r\nnr_pages = pagevec_lookup(&pvec,\r\nnfsi->vfs_inode.i_mapping,\r\nfirst,\r\nPAGEVEC_SIZE - pagevec_count(&pvec));\r\nif (!nr_pages)\r\nbreak;\r\nfor (loop = 0; loop < nr_pages; loop++)\r\nClearPageFsCache(pvec.pages[loop]);\r\nfirst = pvec.pages[nr_pages - 1]->index + 1;\r\npvec.nr = nr_pages;\r\npagevec_release(&pvec);\r\ncond_resched();\r\n}\r\n}\r\nstatic void nfs_fh_get_context(void *cookie_netfs_data, void *context)\r\n{\r\nget_nfs_open_context(context);\r\n}\r\nstatic void nfs_fh_put_context(void *cookie_netfs_data, void *context)\r\n{\r\nif (context)\r\nput_nfs_open_context(context);\r\n}
