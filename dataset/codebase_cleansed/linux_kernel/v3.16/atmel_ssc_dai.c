static irqreturn_t atmel_ssc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct atmel_ssc_info *ssc_p = dev_id;\r\nstruct atmel_pcm_dma_params *dma_params;\r\nu32 ssc_sr;\r\nu32 ssc_substream_mask;\r\nint i;\r\nssc_sr = (unsigned long)ssc_readl(ssc_p->ssc->regs, SR)\r\n& (unsigned long)ssc_readl(ssc_p->ssc->regs, IMR);\r\nfor (i = 0; i < ARRAY_SIZE(ssc_p->dma_params); i++) {\r\ndma_params = ssc_p->dma_params[i];\r\nif ((dma_params != NULL) &&\r\n(dma_params->dma_intr_handler != NULL)) {\r\nssc_substream_mask = (dma_params->mask->ssc_endx |\r\ndma_params->mask->ssc_endbuf);\r\nif (ssc_sr & ssc_substream_mask) {\r\ndma_params->dma_intr_handler(ssc_sr,\r\ndma_params->\r\nsubstream);\r\n}\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int atmel_ssc_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[dai->id];\r\nstruct atmel_pcm_dma_params *dma_params;\r\nint dir, dir_mask;\r\npr_debug("atmel_ssc_startup: SSC_SR=0x%u\n",\r\nssc_readl(ssc_p->ssc->regs, SR));\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndir = 0;\r\ndir_mask = SSC_DIR_MASK_PLAYBACK;\r\n} else {\r\ndir = 1;\r\ndir_mask = SSC_DIR_MASK_CAPTURE;\r\n}\r\ndma_params = &ssc_dma_params[dai->id][dir];\r\ndma_params->ssc = ssc_p->ssc;\r\ndma_params->substream = substream;\r\nssc_p->dma_params[dir] = dma_params;\r\nsnd_soc_dai_set_dma_data(dai, substream, dma_params);\r\nspin_lock_irq(&ssc_p->lock);\r\nif (ssc_p->dir_mask & dir_mask) {\r\nspin_unlock_irq(&ssc_p->lock);\r\nreturn -EBUSY;\r\n}\r\nssc_p->dir_mask |= dir_mask;\r\nspin_unlock_irq(&ssc_p->lock);\r\nreturn 0;\r\n}\r\nstatic void atmel_ssc_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[dai->id];\r\nstruct atmel_pcm_dma_params *dma_params;\r\nint dir, dir_mask;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndir = 0;\r\nelse\r\ndir = 1;\r\ndma_params = ssc_p->dma_params[dir];\r\nif (dma_params != NULL) {\r\nssc_writel(ssc_p->ssc->regs, CR, dma_params->mask->ssc_disable);\r\npr_debug("atmel_ssc_shutdown: %s disabled SSC_SR=0x%08x\n",\r\n(dir ? "receive" : "transmit"),\r\nssc_readl(ssc_p->ssc->regs, SR));\r\ndma_params->ssc = NULL;\r\ndma_params->substream = NULL;\r\nssc_p->dma_params[dir] = NULL;\r\n}\r\ndir_mask = 1 << dir;\r\nspin_lock_irq(&ssc_p->lock);\r\nssc_p->dir_mask &= ~dir_mask;\r\nif (!ssc_p->dir_mask) {\r\nif (ssc_p->initialized) {\r\npr_debug("atmel_ssc_dau: Stopping clock\n");\r\nclk_disable(ssc_p->ssc->clk);\r\nfree_irq(ssc_p->ssc->irq, ssc_p);\r\nssc_p->initialized = 0;\r\n}\r\nssc_writel(ssc_p->ssc->regs, CR, SSC_BIT(CR_SWRST));\r\nssc_p->cmr_div = ssc_p->tcmr_period = ssc_p->rcmr_period = 0;\r\n}\r\nspin_unlock_irq(&ssc_p->lock);\r\n}\r\nstatic int atmel_ssc_set_dai_fmt(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt)\r\n{\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[cpu_dai->id];\r\nssc_p->daifmt = fmt;\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,\r\nint div_id, int div)\r\n{\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[cpu_dai->id];\r\nswitch (div_id) {\r\ncase ATMEL_SSC_CMR_DIV:\r\nif (ssc_p->cmr_div == 0)\r\nssc_p->cmr_div = div;\r\nelse\r\nif (div != ssc_p->cmr_div)\r\nreturn -EBUSY;\r\nbreak;\r\ncase ATMEL_SSC_TCMR_PERIOD:\r\nssc_p->tcmr_period = div;\r\nbreak;\r\ncase ATMEL_SSC_RCMR_PERIOD:\r\nssc_p->rcmr_period = div;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint id = dai->id;\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[id];\r\nstruct ssc_device *ssc = ssc_p->ssc;\r\nstruct atmel_pcm_dma_params *dma_params;\r\nint dir, channels, bits;\r\nu32 tfmr, rfmr, tcmr, rcmr;\r\nint start_event;\r\nint ret;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndir = 0;\r\nelse\r\ndir = 1;\r\ndma_params = ssc_p->dma_params[dir];\r\nchannels = params_channels(params);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S8:\r\nbits = 8;\r\ndma_params->pdc_xfer_size = 1;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbits = 16;\r\ndma_params->pdc_xfer_size = 2;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nbits = 24;\r\ndma_params->pdc_xfer_size = 4;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nbits = 32;\r\ndma_params->pdc_xfer_size = 4;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "atmel_ssc_dai: unsupported PCM format");\r\nreturn -EINVAL;\r\n}\r\nif ((ssc_p->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_I2S\r\n&& bits > 16) {\r\nprintk(KERN_WARNING\r\n"atmel_ssc_dai: sample size %d "\r\n"is too large for I2S\n", bits);\r\nreturn -EINVAL;\r\n}\r\nswitch (ssc_p->daifmt\r\n& (SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_MASTER_MASK)) {\r\ncase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS:\r\nrcmr = SSC_BF(RCMR_PERIOD, ssc_p->rcmr_period)\r\n| SSC_BF(RCMR_STTDLY, START_DELAY)\r\n| SSC_BF(RCMR_START, SSC_START_FALLING_RF)\r\n| SSC_BF(RCMR_CKI, SSC_CKI_RISING)\r\n| SSC_BF(RCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(RCMR_CKS, SSC_CKS_DIV);\r\nrfmr = SSC_BF(RFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(RFMR_FSOS, SSC_FSOS_NEGATIVE)\r\n| SSC_BF(RFMR_FSLEN, (bits - 1))\r\n| SSC_BF(RFMR_DATNB, (channels - 1))\r\n| SSC_BIT(RFMR_MSBF)\r\n| SSC_BF(RFMR_LOOP, 0)\r\n| SSC_BF(RFMR_DATLEN, (bits - 1));\r\ntcmr = SSC_BF(TCMR_PERIOD, ssc_p->tcmr_period)\r\n| SSC_BF(TCMR_STTDLY, START_DELAY)\r\n| SSC_BF(TCMR_START, SSC_START_FALLING_RF)\r\n| SSC_BF(TCMR_CKI, SSC_CKI_FALLING)\r\n| SSC_BF(TCMR_CKO, SSC_CKO_CONTINUOUS)\r\n| SSC_BF(TCMR_CKS, SSC_CKS_DIV);\r\ntfmr = SSC_BF(TFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(TFMR_FSDEN, 0)\r\n| SSC_BF(TFMR_FSOS, SSC_FSOS_NEGATIVE)\r\n| SSC_BF(TFMR_FSLEN, (bits - 1))\r\n| SSC_BF(TFMR_DATNB, (channels - 1))\r\n| SSC_BIT(TFMR_MSBF)\r\n| SSC_BF(TFMR_DATDEF, 0)\r\n| SSC_BF(TFMR_DATLEN, (bits - 1));\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM:\r\nstart_event = ((channels == 1)\r\n? SSC_START_FALLING_RF\r\n: SSC_START_EDGE_RF);\r\nrcmr = SSC_BF(RCMR_PERIOD, 0)\r\n| SSC_BF(RCMR_STTDLY, START_DELAY)\r\n| SSC_BF(RCMR_START, start_event)\r\n| SSC_BF(RCMR_CKI, SSC_CKI_RISING)\r\n| SSC_BF(RCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(RCMR_CKS, ssc->clk_from_rk_pin ?\r\nSSC_CKS_PIN : SSC_CKS_CLOCK);\r\nrfmr = SSC_BF(RFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(RFMR_FSOS, SSC_FSOS_NONE)\r\n| SSC_BF(RFMR_FSLEN, 0)\r\n| SSC_BF(RFMR_DATNB, 0)\r\n| SSC_BIT(RFMR_MSBF)\r\n| SSC_BF(RFMR_LOOP, 0)\r\n| SSC_BF(RFMR_DATLEN, (bits - 1));\r\ntcmr = SSC_BF(TCMR_PERIOD, 0)\r\n| SSC_BF(TCMR_STTDLY, START_DELAY)\r\n| SSC_BF(TCMR_START, start_event)\r\n| SSC_BF(TCMR_CKI, SSC_CKI_FALLING)\r\n| SSC_BF(TCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(TCMR_CKS, ssc->clk_from_rk_pin ?\r\nSSC_CKS_CLOCK : SSC_CKS_PIN);\r\ntfmr = SSC_BF(TFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(TFMR_FSDEN, 0)\r\n| SSC_BF(TFMR_FSOS, SSC_FSOS_NONE)\r\n| SSC_BF(TFMR_FSLEN, 0)\r\n| SSC_BF(TFMR_DATNB, 0)\r\n| SSC_BIT(TFMR_MSBF)\r\n| SSC_BF(TFMR_DATDEF, 0)\r\n| SSC_BF(TFMR_DATLEN, (bits - 1));\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_CBS_CFS:\r\nrcmr = SSC_BF(RCMR_PERIOD, ssc_p->rcmr_period)\r\n| SSC_BF(RCMR_STTDLY, 1)\r\n| SSC_BF(RCMR_START, SSC_START_RISING_RF)\r\n| SSC_BF(RCMR_CKI, SSC_CKI_RISING)\r\n| SSC_BF(RCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(RCMR_CKS, SSC_CKS_DIV);\r\nrfmr = SSC_BF(RFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(RFMR_FSOS, SSC_FSOS_POSITIVE)\r\n| SSC_BF(RFMR_FSLEN, 0)\r\n| SSC_BF(RFMR_DATNB, (channels - 1))\r\n| SSC_BIT(RFMR_MSBF)\r\n| SSC_BF(RFMR_LOOP, 0)\r\n| SSC_BF(RFMR_DATLEN, (bits - 1));\r\ntcmr = SSC_BF(TCMR_PERIOD, ssc_p->tcmr_period)\r\n| SSC_BF(TCMR_STTDLY, 1)\r\n| SSC_BF(TCMR_START, SSC_START_RISING_RF)\r\n| SSC_BF(TCMR_CKI, SSC_CKI_RISING)\r\n| SSC_BF(TCMR_CKO, SSC_CKO_CONTINUOUS)\r\n| SSC_BF(TCMR_CKS, SSC_CKS_DIV);\r\ntfmr = SSC_BF(TFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(TFMR_FSDEN, 0)\r\n| SSC_BF(TFMR_FSOS, SSC_FSOS_POSITIVE)\r\n| SSC_BF(TFMR_FSLEN, 0)\r\n| SSC_BF(TFMR_DATNB, (channels - 1))\r\n| SSC_BIT(TFMR_MSBF)\r\n| SSC_BF(TFMR_DATDEF, 0)\r\n| SSC_BF(TFMR_DATLEN, (bits - 1));\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_CBM_CFM:\r\nrcmr = SSC_BF(RCMR_PERIOD, 0)\r\n| SSC_BF(RCMR_STTDLY, START_DELAY)\r\n| SSC_BF(RCMR_START, SSC_START_RISING_RF)\r\n| SSC_BF(RCMR_CKI, SSC_CKI_RISING)\r\n| SSC_BF(RCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(RCMR_CKS, ssc->clk_from_rk_pin ?\r\nSSC_CKS_PIN : SSC_CKS_CLOCK);\r\nrfmr = SSC_BF(RFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(RFMR_FSOS, SSC_FSOS_NONE)\r\n| SSC_BF(RFMR_FSLEN, 0)\r\n| SSC_BF(RFMR_DATNB, (channels - 1))\r\n| SSC_BIT(RFMR_MSBF)\r\n| SSC_BF(RFMR_LOOP, 0)\r\n| SSC_BF(RFMR_DATLEN, (bits - 1));\r\ntcmr = SSC_BF(TCMR_PERIOD, 0)\r\n| SSC_BF(TCMR_STTDLY, START_DELAY)\r\n| SSC_BF(TCMR_START, SSC_START_RISING_RF)\r\n| SSC_BF(TCMR_CKI, SSC_CKI_FALLING)\r\n| SSC_BF(TCMR_CKO, SSC_CKO_NONE)\r\n| SSC_BF(RCMR_CKS, ssc->clk_from_rk_pin ?\r\nSSC_CKS_CLOCK : SSC_CKS_PIN);\r\ntfmr = SSC_BF(TFMR_FSEDGE, SSC_FSEDGE_POSITIVE)\r\n| SSC_BF(TFMR_FSDEN, 0)\r\n| SSC_BF(TFMR_FSOS, SSC_FSOS_NONE)\r\n| SSC_BF(TFMR_FSLEN, 0)\r\n| SSC_BF(TFMR_DATNB, (channels - 1))\r\n| SSC_BIT(TFMR_MSBF)\r\n| SSC_BF(TFMR_DATDEF, 0)\r\n| SSC_BF(TFMR_DATLEN, (bits - 1));\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "atmel_ssc_dai: unsupported DAI format 0x%x\n",\r\nssc_p->daifmt);\r\nreturn -EINVAL;\r\n}\r\npr_debug("atmel_ssc_hw_params: "\r\n"RCMR=%08x RFMR=%08x TCMR=%08x TFMR=%08x\n",\r\nrcmr, rfmr, tcmr, tfmr);\r\nif (!ssc_p->initialized) {\r\npr_debug("atmel_ssc_dai: Starting clock\n");\r\nclk_enable(ssc_p->ssc->clk);\r\nssc_writel(ssc_p->ssc->regs, CR, SSC_BIT(CR_SWRST));\r\nssc_writel(ssc_p->ssc->regs, PDC_RPR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_RCR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_RNPR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_RNCR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_TPR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_TCR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_TNPR, 0);\r\nssc_writel(ssc_p->ssc->regs, PDC_TNCR, 0);\r\nret = request_irq(ssc_p->ssc->irq, atmel_ssc_interrupt, 0,\r\nssc_p->name, ssc_p);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING\r\n"atmel_ssc_dai: request_irq failure\n");\r\npr_debug("Atmel_ssc_dai: Stoping clock\n");\r\nclk_disable(ssc_p->ssc->clk);\r\nreturn ret;\r\n}\r\nssc_p->initialized = 1;\r\n}\r\nssc_writel(ssc_p->ssc->regs, CMR, ssc_p->cmr_div);\r\nssc_writel(ssc_p->ssc->regs, RCMR, rcmr);\r\nssc_writel(ssc_p->ssc->regs, RFMR, rfmr);\r\nssc_writel(ssc_p->ssc->regs, TCMR, tcmr);\r\nssc_writel(ssc_p->ssc->regs, TFMR, tfmr);\r\npr_debug("atmel_ssc_dai,hw_params: SSC initialized\n");\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[dai->id];\r\nstruct atmel_pcm_dma_params *dma_params;\r\nint dir;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndir = 0;\r\nelse\r\ndir = 1;\r\ndma_params = ssc_p->dma_params[dir];\r\nssc_writel(ssc_p->ssc->regs, CR, dma_params->mask->ssc_disable);\r\nssc_writel(ssc_p->ssc->regs, IDR, dma_params->mask->ssc_error);\r\npr_debug("%s enabled SSC_SR=0x%08x\n",\r\ndir ? "receive" : "transmit",\r\nssc_readl(ssc_p->ssc->regs, SR));\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct atmel_ssc_info *ssc_p = &ssc_info[dai->id];\r\nstruct atmel_pcm_dma_params *dma_params;\r\nint dir;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndir = 0;\r\nelse\r\ndir = 1;\r\ndma_params = ssc_p->dma_params[dir];\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nssc_writel(ssc_p->ssc->regs, CR, dma_params->mask->ssc_enable);\r\nbreak;\r\ndefault:\r\nssc_writel(ssc_p->ssc->regs, CR, dma_params->mask->ssc_disable);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_suspend(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct atmel_ssc_info *ssc_p;\r\nif (!cpu_dai->active)\r\nreturn 0;\r\nssc_p = &ssc_info[cpu_dai->id];\r\nssc_p->ssc_state.ssc_sr = ssc_readl(ssc_p->ssc->regs, SR);\r\nssc_writel(ssc_p->ssc->regs, CR, SSC_BIT(CR_TXDIS) | SSC_BIT(CR_RXDIS));\r\nssc_p->ssc_state.ssc_imr = ssc_readl(ssc_p->ssc->regs, IMR);\r\nssc_writel(ssc_p->ssc->regs, IDR, ssc_p->ssc_state.ssc_imr);\r\nssc_p->ssc_state.ssc_cmr = ssc_readl(ssc_p->ssc->regs, CMR);\r\nssc_p->ssc_state.ssc_rcmr = ssc_readl(ssc_p->ssc->regs, RCMR);\r\nssc_p->ssc_state.ssc_rfmr = ssc_readl(ssc_p->ssc->regs, RFMR);\r\nssc_p->ssc_state.ssc_tcmr = ssc_readl(ssc_p->ssc->regs, TCMR);\r\nssc_p->ssc_state.ssc_tfmr = ssc_readl(ssc_p->ssc->regs, TFMR);\r\nreturn 0;\r\n}\r\nstatic int atmel_ssc_resume(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct atmel_ssc_info *ssc_p;\r\nu32 cr;\r\nif (!cpu_dai->active)\r\nreturn 0;\r\nssc_p = &ssc_info[cpu_dai->id];\r\nssc_writel(ssc_p->ssc->regs, TFMR, ssc_p->ssc_state.ssc_tfmr);\r\nssc_writel(ssc_p->ssc->regs, TCMR, ssc_p->ssc_state.ssc_tcmr);\r\nssc_writel(ssc_p->ssc->regs, RFMR, ssc_p->ssc_state.ssc_rfmr);\r\nssc_writel(ssc_p->ssc->regs, RCMR, ssc_p->ssc_state.ssc_rcmr);\r\nssc_writel(ssc_p->ssc->regs, CMR, ssc_p->ssc_state.ssc_cmr);\r\nssc_writel(ssc_p->ssc->regs, IER, ssc_p->ssc_state.ssc_imr);\r\ncr = 0;\r\ncr |=\r\n(ssc_p->ssc_state.ssc_sr & SSC_BIT(SR_RXEN)) ? SSC_BIT(CR_RXEN) : 0;\r\ncr |=\r\n(ssc_p->ssc_state.ssc_sr & SSC_BIT(SR_TXEN)) ? SSC_BIT(CR_TXEN) : 0;\r\nssc_writel(ssc_p->ssc->regs, CR, cr);\r\nreturn 0;\r\n}\r\nstatic int asoc_ssc_init(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ssc_device *ssc = platform_get_drvdata(pdev);\r\nint ret;\r\nret = snd_soc_register_component(dev, &atmel_ssc_component,\r\n&atmel_ssc_dai, 1);\r\nif (ret) {\r\ndev_err(dev, "Could not register DAI: %d\n", ret);\r\ngoto err;\r\n}\r\nif (ssc->pdata->use_dma)\r\nret = atmel_pcm_dma_platform_register(dev);\r\nelse\r\nret = atmel_pcm_pdc_platform_register(dev);\r\nif (ret) {\r\ndev_err(dev, "Could not register PCM: %d\n", ret);\r\ngoto err_unregister_dai;\r\n}\r\nreturn 0;\r\nerr_unregister_dai:\r\nsnd_soc_unregister_component(dev);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void asoc_ssc_exit(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ssc_device *ssc = platform_get_drvdata(pdev);\r\nif (ssc->pdata->use_dma)\r\natmel_pcm_dma_platform_unregister(dev);\r\nelse\r\natmel_pcm_pdc_platform_unregister(dev);\r\nsnd_soc_unregister_component(dev);\r\n}\r\nint atmel_ssc_set_audio(int ssc_id)\r\n{\r\nstruct ssc_device *ssc;\r\nint ret;\r\nssc = ssc_request(ssc_id);\r\nif (IS_ERR(ssc)) {\r\npr_err("Unable to parent ASoC SSC DAI on SSC: %ld\n",\r\nPTR_ERR(ssc));\r\nreturn PTR_ERR(ssc);\r\n} else {\r\nssc_info[ssc_id].ssc = ssc;\r\n}\r\nret = asoc_ssc_init(&ssc->pdev->dev);\r\nreturn ret;\r\n}\r\nvoid atmel_ssc_put_audio(int ssc_id)\r\n{\r\nstruct ssc_device *ssc = ssc_info[ssc_id].ssc;\r\nasoc_ssc_exit(&ssc->pdev->dev);\r\nssc_free(ssc);\r\n}
