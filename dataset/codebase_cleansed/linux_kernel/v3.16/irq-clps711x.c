static asmlinkage void __exception_irq_entry clps711x_irqh(struct pt_regs *regs)\r\n{\r\nu32 irqnr, irqstat;\r\ndo {\r\nirqstat = readw_relaxed(clps711x_intc->intmr[0]) &\r\nreadw_relaxed(clps711x_intc->intsr[0]);\r\nif (irqstat) {\r\nirqnr = irq_find_mapping(clps711x_intc->domain,\r\nfls(irqstat) - 1);\r\nhandle_IRQ(irqnr, regs);\r\n}\r\nirqstat = readw_relaxed(clps711x_intc->intmr[1]) &\r\nreadw_relaxed(clps711x_intc->intsr[1]);\r\nif (irqstat) {\r\nirqnr = irq_find_mapping(clps711x_intc->domain,\r\nfls(irqstat) - 1 + 16);\r\nhandle_IRQ(irqnr, regs);\r\n}\r\n} while (irqstat);\r\n}\r\nstatic void clps711x_intc_eoi(struct irq_data *d)\r\n{\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nwritel_relaxed(0, clps711x_intc->base + clps711x_irqs[hwirq].eoi);\r\n}\r\nstatic void clps711x_intc_mask(struct irq_data *d)\r\n{\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nvoid __iomem *intmr = clps711x_intc->intmr[hwirq / 16];\r\nu32 tmp;\r\ntmp = readl_relaxed(intmr);\r\ntmp &= ~(1 << (hwirq % 16));\r\nwritel_relaxed(tmp, intmr);\r\n}\r\nstatic void clps711x_intc_unmask(struct irq_data *d)\r\n{\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nvoid __iomem *intmr = clps711x_intc->intmr[hwirq / 16];\r\nu32 tmp;\r\ntmp = readl_relaxed(intmr);\r\ntmp |= 1 << (hwirq % 16);\r\nwritel_relaxed(tmp, intmr);\r\n}\r\nstatic int __init clps711x_intc_irq_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_flow_handler_t handler = handle_level_irq;\r\nunsigned int flags = IRQF_VALID | IRQF_PROBE;\r\nif (!clps711x_irqs[hw].flags)\r\nreturn 0;\r\nif (clps711x_irqs[hw].flags & CLPS711X_FLAG_FIQ) {\r\nhandler = handle_bad_irq;\r\nflags |= IRQF_NOAUTOEN;\r\n} else if (clps711x_irqs[hw].eoi) {\r\nhandler = handle_fasteoi_irq;\r\n}\r\nif (clps711x_irqs[hw].eoi)\r\nwritel_relaxed(0, clps711x_intc->base + clps711x_irqs[hw].eoi);\r\nirq_set_chip_and_handler(virq, &clps711x_intc_chip, handler);\r\nset_irq_flags(virq, flags);\r\nreturn 0;\r\n}\r\nstatic int __init _clps711x_intc_init(struct device_node *np,\r\nphys_addr_t base, resource_size_t size)\r\n{\r\nint err;\r\nclps711x_intc = kzalloc(sizeof(*clps711x_intc), GFP_KERNEL);\r\nif (!clps711x_intc)\r\nreturn -ENOMEM;\r\nclps711x_intc->base = ioremap(base, size);\r\nif (!clps711x_intc->base) {\r\nerr = -ENOMEM;\r\ngoto out_kfree;\r\n}\r\nclps711x_intc->intsr[0] = clps711x_intc->base + CLPS711X_INTSR1;\r\nclps711x_intc->intmr[0] = clps711x_intc->base + CLPS711X_INTMR1;\r\nclps711x_intc->intsr[1] = clps711x_intc->base + CLPS711X_INTSR2;\r\nclps711x_intc->intmr[1] = clps711x_intc->base + CLPS711X_INTMR2;\r\nclps711x_intc->intsr[2] = clps711x_intc->base + CLPS711X_INTSR3;\r\nclps711x_intc->intmr[2] = clps711x_intc->base + CLPS711X_INTMR3;\r\nwritel_relaxed(0, clps711x_intc->intmr[0]);\r\nwritel_relaxed(0, clps711x_intc->intmr[1]);\r\nwritel_relaxed(0, clps711x_intc->intmr[2]);\r\nerr = irq_alloc_descs(-1, 0, ARRAY_SIZE(clps711x_irqs), numa_node_id());\r\nif (IS_ERR_VALUE(err))\r\ngoto out_iounmap;\r\nclps711x_intc->ops.map = clps711x_intc_irq_map;\r\nclps711x_intc->ops.xlate = irq_domain_xlate_onecell;\r\nclps711x_intc->domain =\r\nirq_domain_add_legacy(np, ARRAY_SIZE(clps711x_irqs),\r\n0, 0, &clps711x_intc->ops, NULL);\r\nif (!clps711x_intc->domain) {\r\nerr = -ENOMEM;\r\ngoto out_irqfree;\r\n}\r\nirq_set_default_host(clps711x_intc->domain);\r\nset_handle_irq(clps711x_irqh);\r\n#ifdef CONFIG_FIQ\r\ninit_FIQ(0);\r\n#endif\r\nreturn 0;\r\nout_irqfree:\r\nirq_free_descs(0, ARRAY_SIZE(clps711x_irqs));\r\nout_iounmap:\r\niounmap(clps711x_intc->base);\r\nout_kfree:\r\nkfree(clps711x_intc);\r\nreturn err;\r\n}\r\nvoid __init clps711x_intc_init(phys_addr_t base, resource_size_t size)\r\n{\r\nBUG_ON(_clps711x_intc_init(NULL, base, size));\r\n}\r\nstatic int __init clps711x_intc_init_dt(struct device_node *np,\r\nstruct device_node *parent)\r\n{\r\nstruct resource res;\r\nint err;\r\nerr = of_address_to_resource(np, 0, &res);\r\nif (err)\r\nreturn err;\r\nreturn _clps711x_intc_init(np, res.start, resource_size(&res));\r\n}
