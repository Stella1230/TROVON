int big_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\r\n{\r\nstruct path *path = (struct path *)&key->payload.data2;\r\nstruct file *file;\r\nssize_t written;\r\nsize_t datalen = prep->datalen;\r\nint ret;\r\nret = -EINVAL;\r\nif (datalen <= 0 || datalen > 1024 * 1024 || !prep->data)\r\ngoto error;\r\nret = key_payload_reserve(key, 16);\r\nif (ret < 0)\r\ngoto error;\r\nkey->type_data.x[1] = datalen;\r\nif (datalen > BIG_KEY_FILE_THRESHOLD) {\r\nfile = shmem_kernel_file_setup("", datalen, 0);\r\nif (IS_ERR(file)) {\r\nret = PTR_ERR(file);\r\ngoto err_quota;\r\n}\r\nwritten = kernel_write(file, prep->data, prep->datalen, 0);\r\nif (written != datalen) {\r\nret = written;\r\nif (written >= 0)\r\nret = -ENOMEM;\r\ngoto err_fput;\r\n}\r\n*path = file->f_path;\r\npath_get(path);\r\nfput(file);\r\n} else {\r\nvoid *data = kmalloc(datalen, GFP_KERNEL);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto err_quota;\r\n}\r\nkey->payload.data = memcpy(data, prep->data, prep->datalen);\r\n}\r\nreturn 0;\r\nerr_fput:\r\nfput(file);\r\nerr_quota:\r\nkey_payload_reserve(key, 0);\r\nerror:\r\nreturn ret;\r\n}\r\nvoid big_key_revoke(struct key *key)\r\n{\r\nstruct path *path = (struct path *)&key->payload.data2;\r\nkey_payload_reserve(key, 0);\r\nif (key_is_instantiated(key) && key->type_data.x[1] > BIG_KEY_FILE_THRESHOLD)\r\nvfs_truncate(path, 0);\r\n}\r\nvoid big_key_destroy(struct key *key)\r\n{\r\nif (key->type_data.x[1] > BIG_KEY_FILE_THRESHOLD) {\r\nstruct path *path = (struct path *)&key->payload.data2;\r\npath_put(path);\r\npath->mnt = NULL;\r\npath->dentry = NULL;\r\n} else {\r\nkfree(key->payload.data);\r\nkey->payload.data = NULL;\r\n}\r\n}\r\nvoid big_key_describe(const struct key *key, struct seq_file *m)\r\n{\r\nunsigned long datalen = key->type_data.x[1];\r\nseq_puts(m, key->description);\r\nif (key_is_instantiated(key))\r\nseq_printf(m, ": %lu [%s]",\r\ndatalen,\r\ndatalen > BIG_KEY_FILE_THRESHOLD ? "file" : "buff");\r\n}\r\nlong big_key_read(const struct key *key, char __user *buffer, size_t buflen)\r\n{\r\nunsigned long datalen = key->type_data.x[1];\r\nlong ret;\r\nif (!buffer || buflen < datalen)\r\nreturn datalen;\r\nif (datalen > BIG_KEY_FILE_THRESHOLD) {\r\nstruct path *path = (struct path *)&key->payload.data2;\r\nstruct file *file;\r\nloff_t pos;\r\nfile = dentry_open(path, O_RDONLY, current_cred());\r\nif (IS_ERR(file))\r\nreturn PTR_ERR(file);\r\npos = 0;\r\nret = vfs_read(file, buffer, datalen, &pos);\r\nfput(file);\r\nif (ret >= 0 && ret != datalen)\r\nret = -EIO;\r\n} else {\r\nret = datalen;\r\nif (copy_to_user(buffer, key->payload.data, datalen) != 0)\r\nret = -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init big_key_init(void)\r\n{\r\nreturn register_key_type(&key_type_big_key);\r\n}\r\nstatic void __exit big_key_cleanup(void)\r\n{\r\nunregister_key_type(&key_type_big_key);\r\n}
