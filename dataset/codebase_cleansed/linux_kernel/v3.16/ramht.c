static u32\r\nnouveau_ramht_hash(struct nouveau_ramht *ramht, int chid, u32 handle)\r\n{\r\nu32 hash = 0;\r\nwhile (handle) {\r\nhash ^= (handle & ((1 << ramht->bits) - 1));\r\nhandle >>= ramht->bits;\r\n}\r\nhash ^= chid << (ramht->bits - 4);\r\nhash = hash << 3;\r\nreturn hash;\r\n}\r\nint\r\nnouveau_ramht_insert(struct nouveau_ramht *ramht, int chid,\r\nu32 handle, u32 context)\r\n{\r\nstruct nouveau_bar *bar = nouveau_bar(ramht);\r\nu32 co, ho;\r\nco = ho = nouveau_ramht_hash(ramht, chid, handle);\r\ndo {\r\nif (!nv_ro32(ramht, co + 4)) {\r\nnv_wo32(ramht, co + 0, handle);\r\nnv_wo32(ramht, co + 4, context);\r\nif (bar)\r\nbar->flush(bar);\r\nreturn co;\r\n}\r\nco += 8;\r\nif (co >= nv_gpuobj(ramht)->size)\r\nco = 0;\r\n} while (co != ho);\r\nreturn -ENOMEM;\r\n}\r\nvoid\r\nnouveau_ramht_remove(struct nouveau_ramht *ramht, int cookie)\r\n{\r\nstruct nouveau_bar *bar = nouveau_bar(ramht);\r\nnv_wo32(ramht, cookie + 0, 0x00000000);\r\nnv_wo32(ramht, cookie + 4, 0x00000000);\r\nif (bar)\r\nbar->flush(bar);\r\n}\r\nint\r\nnouveau_ramht_new(struct nouveau_object *parent, struct nouveau_object *pargpu,\r\nu32 size, u32 align, struct nouveau_ramht **pramht)\r\n{\r\nstruct nouveau_ramht *ramht;\r\nint ret;\r\nret = nouveau_gpuobj_create(parent, parent->engine ?\r\nparent->engine : parent,\r\n&nouveau_ramht_oclass, 0, pargpu, size,\r\nalign, NVOBJ_FLAG_ZERO_ALLOC, &ramht);\r\n*pramht = ramht;\r\nif (ret)\r\nreturn ret;\r\nramht->bits = order_base_2(nv_gpuobj(ramht)->size >> 3);\r\nreturn 0;\r\n}
