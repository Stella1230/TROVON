void aa_free_domain_entries(struct aa_domain *domain)\r\n{\r\nint i;\r\nif (domain) {\r\nif (!domain->table)\r\nreturn;\r\nfor (i = 0; i < domain->size; i++)\r\nkzfree(domain->table[i]);\r\nkzfree(domain->table);\r\ndomain->table = NULL;\r\n}\r\n}\r\nstatic int may_change_ptraced_domain(struct aa_profile *to_profile)\r\n{\r\nstruct task_struct *tracer;\r\nstruct aa_profile *tracerp = NULL;\r\nint error = 0;\r\nrcu_read_lock();\r\ntracer = ptrace_parent(current);\r\nif (tracer)\r\ntracerp = aa_get_task_profile(tracer);\r\nif (!tracer || unconfined(tracerp))\r\ngoto out;\r\nerror = aa_may_ptrace(tracerp, to_profile, PTRACE_MODE_ATTACH);\r\nout:\r\nrcu_read_unlock();\r\naa_put_profile(tracerp);\r\nreturn error;\r\n}\r\nstatic struct file_perms change_profile_perms(struct aa_profile *profile,\r\nstruct aa_namespace *ns,\r\nconst char *name, u32 request,\r\nunsigned int start)\r\n{\r\nstruct file_perms perms;\r\nstruct path_cond cond = { };\r\nunsigned int state;\r\nif (unconfined(profile)) {\r\nperms.allow = AA_MAY_CHANGE_PROFILE | AA_MAY_ONEXEC;\r\nperms.audit = perms.quiet = perms.kill = 0;\r\nreturn perms;\r\n} else if (!profile->file.dfa) {\r\nreturn nullperms;\r\n} else if ((ns == profile->ns)) {\r\naa_str_perms(profile->file.dfa, start, name, &cond, &perms);\r\nif (COMBINED_PERM_MASK(perms) & request)\r\nreturn perms;\r\n}\r\nstate = aa_dfa_match(profile->file.dfa, start, ns->base.name);\r\nstate = aa_dfa_match_len(profile->file.dfa, state, ":", 1);\r\naa_str_perms(profile->file.dfa, state, name, &cond, &perms);\r\nreturn perms;\r\n}\r\nstatic struct aa_profile *__attach_match(const char *name,\r\nstruct list_head *head)\r\n{\r\nint len = 0;\r\nstruct aa_profile *profile, *candidate = NULL;\r\nlist_for_each_entry_rcu(profile, head, base.list) {\r\nif (profile->flags & PFLAG_NULL)\r\ncontinue;\r\nif (profile->xmatch && profile->xmatch_len > len) {\r\nunsigned int state = aa_dfa_match(profile->xmatch,\r\nDFA_START, name);\r\nu32 perm = dfa_user_allow(profile->xmatch, state);\r\nif (perm & MAY_EXEC) {\r\ncandidate = profile;\r\nlen = profile->xmatch_len;\r\n}\r\n} else if (!strcmp(profile->base.name, name))\r\nreturn profile;\r\n}\r\nreturn candidate;\r\n}\r\nstatic struct aa_profile *find_attach(struct aa_namespace *ns,\r\nstruct list_head *list, const char *name)\r\n{\r\nstruct aa_profile *profile;\r\nrcu_read_lock();\r\nprofile = aa_get_profile(__attach_match(name, list));\r\nrcu_read_unlock();\r\nreturn profile;\r\n}\r\nstatic const char *separate_fqname(const char *fqname, const char **ns_name)\r\n{\r\nconst char *name;\r\nif (fqname[0] == ':') {\r\n*ns_name = fqname + 1;\r\nname = *ns_name + strlen(*ns_name) + 1;\r\nif (!*name)\r\nname = NULL;\r\n} else {\r\n*ns_name = NULL;\r\nname = fqname;\r\n}\r\nreturn name;\r\n}\r\nstatic const char *next_name(int xtype, const char *name)\r\n{\r\nreturn NULL;\r\n}\r\nstatic struct aa_profile *x_table_lookup(struct aa_profile *profile, u32 xindex)\r\n{\r\nstruct aa_profile *new_profile = NULL;\r\nstruct aa_namespace *ns = profile->ns;\r\nu32 xtype = xindex & AA_X_TYPE_MASK;\r\nint index = xindex & AA_X_INDEX_MASK;\r\nconst char *name;\r\nfor (name = profile->file.trans.table[index]; !new_profile && name;\r\nname = next_name(xtype, name)) {\r\nstruct aa_namespace *new_ns;\r\nconst char *xname = NULL;\r\nnew_ns = NULL;\r\nif (xindex & AA_X_CHILD) {\r\nnew_profile = aa_find_child(profile, name);\r\ncontinue;\r\n} else if (*name == ':') {\r\nconst char *ns_name;\r\nxname = name = separate_fqname(name, &ns_name);\r\nif (!xname)\r\nxname = profile->base.hname;\r\nif (*ns_name == '@') {\r\n;\r\n}\r\nnew_ns = aa_find_namespace(ns, ns_name);\r\nif (!new_ns)\r\ncontinue;\r\n} else if (*name == '@') {\r\ncontinue;\r\n} else {\r\nxname = name;\r\n}\r\nnew_profile = aa_lookup_profile(new_ns ? new_ns : ns, xname);\r\naa_put_namespace(new_ns);\r\n}\r\nreturn new_profile;\r\n}\r\nstatic struct aa_profile *x_to_profile(struct aa_profile *profile,\r\nconst char *name, u32 xindex)\r\n{\r\nstruct aa_profile *new_profile = NULL;\r\nstruct aa_namespace *ns = profile->ns;\r\nu32 xtype = xindex & AA_X_TYPE_MASK;\r\nswitch (xtype) {\r\ncase AA_X_NONE:\r\nreturn NULL;\r\ncase AA_X_NAME:\r\nif (xindex & AA_X_CHILD)\r\nnew_profile = find_attach(ns, &profile->base.profiles,\r\nname);\r\nelse\r\nnew_profile = find_attach(ns, &ns->base.profiles,\r\nname);\r\nbreak;\r\ncase AA_X_TABLE:\r\nnew_profile = x_table_lookup(profile, xindex);\r\nbreak;\r\n}\r\nreturn new_profile;\r\n}\r\nint apparmor_bprm_set_creds(struct linux_binprm *bprm)\r\n{\r\nstruct aa_task_cxt *cxt;\r\nstruct aa_profile *profile, *new_profile = NULL;\r\nstruct aa_namespace *ns;\r\nchar *buffer = NULL;\r\nunsigned int state;\r\nstruct file_perms perms = {};\r\nstruct path_cond cond = {\r\nfile_inode(bprm->file)->i_uid,\r\nfile_inode(bprm->file)->i_mode\r\n};\r\nconst char *name = NULL, *target = NULL, *info = NULL;\r\nint error = cap_bprm_set_creds(bprm);\r\nif (error)\r\nreturn error;\r\nif (bprm->cred_prepared)\r\nreturn 0;\r\ncxt = cred_cxt(bprm->cred);\r\nBUG_ON(!cxt);\r\nprofile = aa_get_newest_profile(cxt->profile);\r\nns = profile->ns;\r\nstate = profile->file.start;\r\nerror = aa_path_name(&bprm->file->f_path, profile->path_flags, &buffer,\r\n&name, &info);\r\nif (error) {\r\nif (unconfined(profile) ||\r\n(profile->flags & PFLAG_IX_ON_NAME_ERROR))\r\nerror = 0;\r\nname = bprm->filename;\r\ngoto audit;\r\n}\r\nif (unconfined(profile)) {\r\nif (cxt->onexec)\r\nnew_profile = aa_get_profile(cxt->onexec);\r\nelse\r\nnew_profile = find_attach(ns, &ns->base.profiles, name);\r\nif (!new_profile)\r\ngoto cleanup;\r\ngoto apply;\r\n}\r\nstate = aa_str_perms(profile->file.dfa, state, name, &cond, &perms);\r\nif (cxt->onexec) {\r\nstruct file_perms cp;\r\ninfo = "change_profile onexec";\r\nif (!(perms.allow & AA_MAY_ONEXEC))\r\ngoto audit;\r\nstate = aa_dfa_null_transition(profile->file.dfa, state);\r\ncp = change_profile_perms(profile, cxt->onexec->ns,\r\ncxt->onexec->base.name,\r\nAA_MAY_ONEXEC, state);\r\nif (!(cp.allow & AA_MAY_ONEXEC))\r\ngoto audit;\r\nnew_profile = aa_get_newest_profile(cxt->onexec);\r\ngoto apply;\r\n}\r\nif (perms.allow & MAY_EXEC) {\r\nnew_profile = x_to_profile(profile, name, perms.xindex);\r\nif (!new_profile) {\r\nif (perms.xindex & AA_X_INHERIT) {\r\ninfo = "ix fallback";\r\nnew_profile = aa_get_profile(profile);\r\ngoto x_clear;\r\n} else if (perms.xindex & AA_X_UNCONFINED) {\r\nnew_profile = aa_get_newest_profile(ns->unconfined);\r\ninfo = "ux fallback";\r\n} else {\r\nerror = -ENOENT;\r\ninfo = "profile not found";\r\nperms.allow &= ~MAY_EXEC;\r\n}\r\n}\r\n} else if (COMPLAIN_MODE(profile)) {\r\nnew_profile = aa_new_null_profile(profile, 0);\r\nif (!new_profile) {\r\nerror = -ENOMEM;\r\ninfo = "could not create null profile";\r\n} else {\r\nerror = -EACCES;\r\ntarget = new_profile->base.hname;\r\n}\r\nperms.xindex |= AA_X_UNSAFE;\r\n} else\r\nerror = -EACCES;\r\nif (bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS) {\r\naa_put_profile(new_profile);\r\nerror = -EPERM;\r\ngoto cleanup;\r\n}\r\nif (!new_profile)\r\ngoto audit;\r\nif (bprm->unsafe & LSM_UNSAFE_SHARE) {\r\n;\r\n}\r\nif (bprm->unsafe & (LSM_UNSAFE_PTRACE | LSM_UNSAFE_PTRACE_CAP)) {\r\nerror = may_change_ptraced_domain(new_profile);\r\nif (error) {\r\naa_put_profile(new_profile);\r\ngoto audit;\r\n}\r\n}\r\nif (!(perms.xindex & AA_X_UNSAFE)) {\r\nAA_DEBUG("scrubbing environment variables for %s profile=%s\n",\r\nname, new_profile->base.hname);\r\nbprm->unsafe |= AA_SECURE_X_NEEDED;\r\n}\r\napply:\r\ntarget = new_profile->base.hname;\r\nbprm->per_clear |= PER_CLEAR_ON_SETID;\r\nx_clear:\r\naa_put_profile(cxt->profile);\r\ncxt->profile = new_profile;\r\naa_clear_task_cxt_trans(cxt);\r\naudit:\r\nerror = aa_audit_file(profile, &perms, GFP_KERNEL, OP_EXEC, MAY_EXEC,\r\nname, target, cond.uid, info, error);\r\ncleanup:\r\naa_put_profile(profile);\r\nkfree(buffer);\r\nreturn error;\r\n}\r\nint apparmor_bprm_secureexec(struct linux_binprm *bprm)\r\n{\r\nint ret = cap_bprm_secureexec(bprm);\r\nif (!ret && (bprm->unsafe & AA_SECURE_X_NEEDED))\r\nret = 1;\r\nreturn ret;\r\n}\r\nvoid apparmor_bprm_committing_creds(struct linux_binprm *bprm)\r\n{\r\nstruct aa_profile *profile = __aa_current_profile();\r\nstruct aa_task_cxt *new_cxt = cred_cxt(bprm->cred);\r\nif ((new_cxt->profile == profile) ||\r\n(unconfined(new_cxt->profile)))\r\nreturn;\r\ncurrent->pdeath_signal = 0;\r\n__aa_transition_rlimits(profile, new_cxt->profile);\r\n}\r\nvoid apparmor_bprm_committed_creds(struct linux_binprm *bprm)\r\n{\r\nreturn;\r\n}\r\nstatic char *new_compound_name(const char *n1, const char *n2)\r\n{\r\nchar *name = kmalloc(strlen(n1) + strlen(n2) + 3, GFP_KERNEL);\r\nif (name)\r\nsprintf(name, "%s//%s", n1, n2);\r\nreturn name;\r\n}\r\nint aa_change_hat(const char *hats[], int count, u64 token, bool permtest)\r\n{\r\nconst struct cred *cred;\r\nstruct aa_task_cxt *cxt;\r\nstruct aa_profile *profile, *previous_profile, *hat = NULL;\r\nchar *name = NULL;\r\nint i;\r\nstruct file_perms perms = {};\r\nconst char *target = NULL, *info = NULL;\r\nint error = 0;\r\nif (current->no_new_privs)\r\nreturn -EPERM;\r\ncred = get_current_cred();\r\ncxt = cred_cxt(cred);\r\nprofile = aa_cred_profile(cred);\r\nprevious_profile = cxt->previous;\r\nif (unconfined(profile)) {\r\ninfo = "unconfined";\r\nerror = -EPERM;\r\ngoto audit;\r\n}\r\nif (count) {\r\nstruct aa_profile *root;\r\nif (PROFILE_IS_HAT(profile))\r\nroot = aa_get_profile_rcu(&profile->parent);\r\nelse\r\nroot = aa_get_profile(profile);\r\nfor (i = 0; i < count && !hat; i++)\r\nhat = aa_find_child(root, hats[i]);\r\nif (!hat) {\r\nif (!COMPLAIN_MODE(root) || permtest) {\r\nif (list_empty(&root->base.profiles))\r\nerror = -ECHILD;\r\nelse\r\nerror = -ENOENT;\r\naa_put_profile(root);\r\ngoto out;\r\n}\r\nname = new_compound_name(root->base.hname, hats[0]);\r\naa_put_profile(root);\r\ntarget = name;\r\nhat = aa_new_null_profile(profile, 1);\r\nif (!hat) {\r\ninfo = "failed null profile create";\r\nerror = -ENOMEM;\r\ngoto audit;\r\n}\r\n} else {\r\naa_put_profile(root);\r\ntarget = hat->base.hname;\r\nif (!PROFILE_IS_HAT(hat)) {\r\ninfo = "target not hat";\r\nerror = -EPERM;\r\ngoto audit;\r\n}\r\n}\r\nerror = may_change_ptraced_domain(hat);\r\nif (error) {\r\ninfo = "ptraced";\r\nerror = -EPERM;\r\ngoto audit;\r\n}\r\nif (!permtest) {\r\nerror = aa_set_current_hat(hat, token);\r\nif (error == -EACCES)\r\nperms.kill = AA_MAY_CHANGEHAT;\r\nelse if (name && !error)\r\nerror = -ENOENT;\r\n}\r\n} else if (previous_profile) {\r\ntarget = previous_profile->base.hname;\r\nerror = aa_restore_previous_profile(token);\r\nperms.kill = AA_MAY_CHANGEHAT;\r\n} else\r\ngoto out;\r\naudit:\r\nif (!permtest)\r\nerror = aa_audit_file(profile, &perms, GFP_KERNEL,\r\nOP_CHANGE_HAT, AA_MAY_CHANGEHAT, NULL,\r\ntarget, GLOBAL_ROOT_UID, info, error);\r\nout:\r\naa_put_profile(hat);\r\nkfree(name);\r\nput_cred(cred);\r\nreturn error;\r\n}\r\nint aa_change_profile(const char *ns_name, const char *hname, bool onexec,\r\nbool permtest)\r\n{\r\nconst struct cred *cred;\r\nstruct aa_profile *profile, *target = NULL;\r\nstruct aa_namespace *ns = NULL;\r\nstruct file_perms perms = {};\r\nconst char *name = NULL, *info = NULL;\r\nint op, error = 0;\r\nu32 request;\r\nif (!hname && !ns_name)\r\nreturn -EINVAL;\r\nif (onexec) {\r\nrequest = AA_MAY_ONEXEC;\r\nop = OP_CHANGE_ONEXEC;\r\n} else {\r\nrequest = AA_MAY_CHANGE_PROFILE;\r\nop = OP_CHANGE_PROFILE;\r\n}\r\ncred = get_current_cred();\r\nprofile = aa_cred_profile(cred);\r\nif (current->no_new_privs && !unconfined(profile)) {\r\nput_cred(cred);\r\nreturn -EPERM;\r\n}\r\nif (ns_name) {\r\nns = aa_find_namespace(profile->ns, ns_name);\r\nif (!ns) {\r\nname = ns_name;\r\ninfo = "namespace not found";\r\nerror = -ENOENT;\r\ngoto audit;\r\n}\r\n} else\r\nns = aa_get_namespace(profile->ns);\r\nif (!hname) {\r\nif (unconfined(profile))\r\nhname = ns->unconfined->base.hname;\r\nelse\r\nhname = profile->base.hname;\r\n}\r\nperms = change_profile_perms(profile, ns, hname, request,\r\nprofile->file.start);\r\nif (!(perms.allow & request)) {\r\nerror = -EACCES;\r\ngoto audit;\r\n}\r\ntarget = aa_lookup_profile(ns, hname);\r\nif (!target) {\r\ninfo = "profile not found";\r\nerror = -ENOENT;\r\nif (permtest || !COMPLAIN_MODE(profile))\r\ngoto audit;\r\ntarget = aa_new_null_profile(profile, 0);\r\nif (!target) {\r\ninfo = "failed null profile create";\r\nerror = -ENOMEM;\r\ngoto audit;\r\n}\r\n}\r\nerror = may_change_ptraced_domain(target);\r\nif (error) {\r\ninfo = "ptrace prevents transition";\r\ngoto audit;\r\n}\r\nif (permtest)\r\ngoto audit;\r\nif (onexec)\r\nerror = aa_set_current_onexec(target);\r\nelse\r\nerror = aa_replace_current_profile(target);\r\naudit:\r\nif (!permtest)\r\nerror = aa_audit_file(profile, &perms, GFP_KERNEL, op, request,\r\nname, hname, GLOBAL_ROOT_UID, info, error);\r\naa_put_namespace(ns);\r\naa_put_profile(target);\r\nput_cred(cred);\r\nreturn error;\r\n}
