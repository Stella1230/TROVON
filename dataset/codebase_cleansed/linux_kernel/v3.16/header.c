void perf_header__set_feat(struct perf_header *header, int feat)\r\n{\r\nset_bit(feat, header->adds_features);\r\n}\r\nvoid perf_header__clear_feat(struct perf_header *header, int feat)\r\n{\r\nclear_bit(feat, header->adds_features);\r\n}\r\nbool perf_header__has_feat(const struct perf_header *header, int feat)\r\n{\r\nreturn test_bit(feat, header->adds_features);\r\n}\r\nstatic int do_write(int fd, const void *buf, size_t size)\r\n{\r\nwhile (size) {\r\nint ret = write(fd, buf, size);\r\nif (ret < 0)\r\nreturn -errno;\r\nsize -= ret;\r\nbuf += ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_padded(int fd, const void *bf, size_t count,\r\nsize_t count_aligned)\r\n{\r\nstatic const char zero_buf[NAME_ALIGN];\r\nint err = do_write(fd, bf, count);\r\nif (!err)\r\nerr = do_write(fd, zero_buf, count_aligned - count);\r\nreturn err;\r\n}\r\nstatic int do_write_string(int fd, const char *str)\r\n{\r\nu32 len, olen;\r\nint ret;\r\nolen = strlen(str) + 1;\r\nlen = PERF_ALIGN(olen, NAME_ALIGN);\r\nret = do_write(fd, &len, sizeof(len));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn write_padded(fd, str, olen, len);\r\n}\r\nstatic char *do_read_string(int fd, struct perf_header *ph)\r\n{\r\nssize_t sz, ret;\r\nu32 len;\r\nchar *buf;\r\nsz = readn(fd, &len, sizeof(len));\r\nif (sz < (ssize_t)sizeof(len))\r\nreturn NULL;\r\nif (ph->needs_swap)\r\nlen = bswap_32(len);\r\nbuf = malloc(len);\r\nif (!buf)\r\nreturn NULL;\r\nret = readn(fd, buf, len);\r\nif (ret == (ssize_t)len) {\r\nreturn buf;\r\n}\r\nfree(buf);\r\nreturn NULL;\r\n}\r\nint\r\nperf_header__set_cmdline(int argc, const char **argv)\r\n{\r\nint i;\r\nif (header_argv)\r\nreturn 0;\r\nheader_argc = (u32)argc;\r\nheader_argv = calloc(argc, sizeof(char *));\r\nif (!header_argv)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < argc ; i++)\r\nheader_argv[i] = argv[i];\r\nreturn 0;\r\n}\r\nstatic int write_buildid(const char *name, size_t name_len, u8 *build_id,\r\npid_t pid, u16 misc, int fd)\r\n{\r\nint err;\r\nstruct build_id_event b;\r\nsize_t len;\r\nlen = name_len + 1;\r\nlen = PERF_ALIGN(len, NAME_ALIGN);\r\nmemset(&b, 0, sizeof(b));\r\nmemcpy(&b.build_id, build_id, BUILD_ID_SIZE);\r\nb.pid = pid;\r\nb.header.misc = misc;\r\nb.header.size = sizeof(b) + len;\r\nerr = do_write(fd, &b, sizeof(b));\r\nif (err < 0)\r\nreturn err;\r\nreturn write_padded(fd, name, name_len + 1, len);\r\n}\r\nstatic int __dsos__write_buildid_table(struct list_head *head,\r\nstruct machine *machine,\r\npid_t pid, u16 misc, int fd)\r\n{\r\nchar nm[PATH_MAX];\r\nstruct dso *pos;\r\ndsos__for_each_with_build_id(pos, head) {\r\nint err;\r\nconst char *name;\r\nsize_t name_len;\r\nif (!pos->hit)\r\ncontinue;\r\nif (is_vdso_map(pos->short_name)) {\r\nname = (char *) VDSO__MAP_NAME;\r\nname_len = sizeof(VDSO__MAP_NAME) + 1;\r\n} else if (dso__is_kcore(pos)) {\r\nmachine__mmap_name(machine, nm, sizeof(nm));\r\nname = nm;\r\nname_len = strlen(nm) + 1;\r\n} else {\r\nname = pos->long_name;\r\nname_len = pos->long_name_len + 1;\r\n}\r\nerr = write_buildid(name, name_len, pos->build_id,\r\npid, misc, fd);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int machine__write_buildid_table(struct machine *machine, int fd)\r\n{\r\nint err;\r\nu16 kmisc = PERF_RECORD_MISC_KERNEL,\r\numisc = PERF_RECORD_MISC_USER;\r\nif (!machine__is_host(machine)) {\r\nkmisc = PERF_RECORD_MISC_GUEST_KERNEL;\r\numisc = PERF_RECORD_MISC_GUEST_USER;\r\n}\r\nerr = __dsos__write_buildid_table(&machine->kernel_dsos, machine,\r\nmachine->pid, kmisc, fd);\r\nif (err == 0)\r\nerr = __dsos__write_buildid_table(&machine->user_dsos, machine,\r\nmachine->pid, umisc, fd);\r\nreturn err;\r\n}\r\nstatic int dsos__write_buildid_table(struct perf_header *header, int fd)\r\n{\r\nstruct perf_session *session = container_of(header,\r\nstruct perf_session, header);\r\nstruct rb_node *nd;\r\nint err = machine__write_buildid_table(&session->machines.host, fd);\r\nif (err)\r\nreturn err;\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nerr = machine__write_buildid_table(pos, fd);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nint build_id_cache__add_s(const char *sbuild_id, const char *debugdir,\r\nconst char *name, bool is_kallsyms, bool is_vdso)\r\n{\r\nconst size_t size = PATH_MAX;\r\nchar *realname, *filename = zalloc(size),\r\n*linkname = zalloc(size), *targetname;\r\nint len, err = -1;\r\nbool slash = is_kallsyms || is_vdso;\r\nif (is_kallsyms) {\r\nif (symbol_conf.kptr_restrict) {\r\npr_debug("Not caching a kptr_restrict'ed /proc/kallsyms\n");\r\nerr = 0;\r\ngoto out_free;\r\n}\r\nrealname = (char *) name;\r\n} else\r\nrealname = realpath(name, NULL);\r\nif (realname == NULL || filename == NULL || linkname == NULL)\r\ngoto out_free;\r\nlen = scnprintf(filename, size, "%s%s%s",\r\ndebugdir, slash ? "/" : "",\r\nis_vdso ? VDSO__MAP_NAME : realname);\r\nif (mkdir_p(filename, 0755))\r\ngoto out_free;\r\nsnprintf(filename + len, size - len, "/%s", sbuild_id);\r\nif (access(filename, F_OK)) {\r\nif (is_kallsyms) {\r\nif (copyfile("/proc/kallsyms", filename))\r\ngoto out_free;\r\n} else if (link(realname, filename) && copyfile(name, filename))\r\ngoto out_free;\r\n}\r\nlen = scnprintf(linkname, size, "%s/.build-id/%.2s",\r\ndebugdir, sbuild_id);\r\nif (access(linkname, X_OK) && mkdir_p(linkname, 0755))\r\ngoto out_free;\r\nsnprintf(linkname + len, size - len, "/%s", sbuild_id + 2);\r\ntargetname = filename + strlen(debugdir) - 5;\r\nmemcpy(targetname, "../..", 5);\r\nif (symlink(targetname, linkname) == 0)\r\nerr = 0;\r\nout_free:\r\nif (!is_kallsyms)\r\nfree(realname);\r\nfree(filename);\r\nfree(linkname);\r\nreturn err;\r\n}\r\nstatic int build_id_cache__add_b(const u8 *build_id, size_t build_id_size,\r\nconst char *name, const char *debugdir,\r\nbool is_kallsyms, bool is_vdso)\r\n{\r\nchar sbuild_id[BUILD_ID_SIZE * 2 + 1];\r\nbuild_id__sprintf(build_id, build_id_size, sbuild_id);\r\nreturn build_id_cache__add_s(sbuild_id, debugdir, name,\r\nis_kallsyms, is_vdso);\r\n}\r\nint build_id_cache__remove_s(const char *sbuild_id, const char *debugdir)\r\n{\r\nconst size_t size = PATH_MAX;\r\nchar *filename = zalloc(size),\r\n*linkname = zalloc(size);\r\nint err = -1;\r\nif (filename == NULL || linkname == NULL)\r\ngoto out_free;\r\nsnprintf(linkname, size, "%s/.build-id/%.2s/%s",\r\ndebugdir, sbuild_id, sbuild_id + 2);\r\nif (access(linkname, F_OK))\r\ngoto out_free;\r\nif (readlink(linkname, filename, size - 1) < 0)\r\ngoto out_free;\r\nif (unlink(linkname))\r\ngoto out_free;\r\nsnprintf(linkname, size, "%s/.build-id/%.2s/%s",\r\ndebugdir, sbuild_id, filename);\r\nif (unlink(linkname))\r\ngoto out_free;\r\nerr = 0;\r\nout_free:\r\nfree(filename);\r\nfree(linkname);\r\nreturn err;\r\n}\r\nstatic int dso__cache_build_id(struct dso *dso, struct machine *machine,\r\nconst char *debugdir)\r\n{\r\nbool is_kallsyms = dso->kernel && dso->long_name[0] != '/';\r\nbool is_vdso = is_vdso_map(dso->short_name);\r\nconst char *name = dso->long_name;\r\nchar nm[PATH_MAX];\r\nif (dso__is_kcore(dso)) {\r\nis_kallsyms = true;\r\nmachine__mmap_name(machine, nm, sizeof(nm));\r\nname = nm;\r\n}\r\nreturn build_id_cache__add_b(dso->build_id, sizeof(dso->build_id), name,\r\ndebugdir, is_kallsyms, is_vdso);\r\n}\r\nstatic int __dsos__cache_build_ids(struct list_head *head,\r\nstruct machine *machine, const char *debugdir)\r\n{\r\nstruct dso *pos;\r\nint err = 0;\r\ndsos__for_each_with_build_id(pos, head)\r\nif (dso__cache_build_id(pos, machine, debugdir))\r\nerr = -1;\r\nreturn err;\r\n}\r\nstatic int machine__cache_build_ids(struct machine *machine, const char *debugdir)\r\n{\r\nint ret = __dsos__cache_build_ids(&machine->kernel_dsos, machine,\r\ndebugdir);\r\nret |= __dsos__cache_build_ids(&machine->user_dsos, machine, debugdir);\r\nreturn ret;\r\n}\r\nstatic int perf_session__cache_build_ids(struct perf_session *session)\r\n{\r\nstruct rb_node *nd;\r\nint ret;\r\nchar debugdir[PATH_MAX];\r\nsnprintf(debugdir, sizeof(debugdir), "%s", buildid_dir);\r\nif (mkdir(debugdir, 0755) != 0 && errno != EEXIST)\r\nreturn -1;\r\nret = machine__cache_build_ids(&session->machines.host, debugdir);\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nret |= machine__cache_build_ids(pos, debugdir);\r\n}\r\nreturn ret ? -1 : 0;\r\n}\r\nstatic bool machine__read_build_ids(struct machine *machine, bool with_hits)\r\n{\r\nbool ret = __dsos__read_build_ids(&machine->kernel_dsos, with_hits);\r\nret |= __dsos__read_build_ids(&machine->user_dsos, with_hits);\r\nreturn ret;\r\n}\r\nstatic bool perf_session__read_build_ids(struct perf_session *session, bool with_hits)\r\n{\r\nstruct rb_node *nd;\r\nbool ret = machine__read_build_ids(&session->machines.host, with_hits);\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nret |= machine__read_build_ids(pos, with_hits);\r\n}\r\nreturn ret;\r\n}\r\nstatic int write_tracing_data(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist)\r\n{\r\nreturn read_tracing_data(fd, &evlist->entries);\r\n}\r\nstatic int write_build_id(int fd, struct perf_header *h,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nstruct perf_session *session;\r\nint err;\r\nsession = container_of(h, struct perf_session, header);\r\nif (!perf_session__read_build_ids(session, true))\r\nreturn -1;\r\nerr = dsos__write_buildid_table(h, fd);\r\nif (err < 0) {\r\npr_debug("failed to write buildid table\n");\r\nreturn err;\r\n}\r\nif (!no_buildid_cache)\r\nperf_session__cache_build_ids(session);\r\nreturn 0;\r\n}\r\nstatic int write_hostname(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nstruct utsname uts;\r\nint ret;\r\nret = uname(&uts);\r\nif (ret < 0)\r\nreturn -1;\r\nreturn do_write_string(fd, uts.nodename);\r\n}\r\nstatic int write_osrelease(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nstruct utsname uts;\r\nint ret;\r\nret = uname(&uts);\r\nif (ret < 0)\r\nreturn -1;\r\nreturn do_write_string(fd, uts.release);\r\n}\r\nstatic int write_arch(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nstruct utsname uts;\r\nint ret;\r\nret = uname(&uts);\r\nif (ret < 0)\r\nreturn -1;\r\nreturn do_write_string(fd, uts.machine);\r\n}\r\nstatic int write_version(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nreturn do_write_string(fd, perf_version_string);\r\n}\r\nstatic int write_cpudesc(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\n#ifndef CPUINFO_PROC\r\n#define CPUINFO_PROC NULL\r\n#endif\r\nFILE *file;\r\nchar *buf = NULL;\r\nchar *s, *p;\r\nconst char *search = CPUINFO_PROC;\r\nsize_t len = 0;\r\nint ret = -1;\r\nif (!search)\r\nreturn -1;\r\nfile = fopen("/proc/cpuinfo", "r");\r\nif (!file)\r\nreturn -1;\r\nwhile (getline(&buf, &len, file) > 0) {\r\nret = strncmp(buf, search, strlen(search));\r\nif (!ret)\r\nbreak;\r\n}\r\nif (ret)\r\ngoto done;\r\ns = buf;\r\np = strchr(buf, ':');\r\nif (p && *(p+1) == ' ' && *(p+2))\r\ns = p + 2;\r\np = strchr(s, '\n');\r\nif (p)\r\n*p = '\0';\r\np = s;\r\nwhile (*p) {\r\nif (isspace(*p)) {\r\nchar *r = p + 1;\r\nchar *q = r;\r\n*p = ' ';\r\nwhile (*q && isspace(*q))\r\nq++;\r\nif (q != (p+1))\r\nwhile ((*r++ = *q++));\r\n}\r\np++;\r\n}\r\nret = do_write_string(fd, s);\r\ndone:\r\nfree(buf);\r\nfclose(file);\r\nreturn ret;\r\n}\r\nstatic int write_nrcpus(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nlong nr;\r\nu32 nrc, nra;\r\nint ret;\r\nnr = sysconf(_SC_NPROCESSORS_CONF);\r\nif (nr < 0)\r\nreturn -1;\r\nnrc = (u32)(nr & UINT_MAX);\r\nnr = sysconf(_SC_NPROCESSORS_ONLN);\r\nif (nr < 0)\r\nreturn -1;\r\nnra = (u32)(nr & UINT_MAX);\r\nret = do_write(fd, &nrc, sizeof(nrc));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn do_write(fd, &nra, sizeof(nra));\r\n}\r\nstatic int write_event_desc(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist)\r\n{\r\nstruct perf_evsel *evsel;\r\nu32 nre, nri, sz;\r\nint ret;\r\nnre = evlist->nr_entries;\r\nret = do_write(fd, &nre, sizeof(nre));\r\nif (ret < 0)\r\nreturn ret;\r\nsz = (u32)sizeof(evsel->attr);\r\nret = do_write(fd, &sz, sizeof(sz));\r\nif (ret < 0)\r\nreturn ret;\r\nevlist__for_each(evlist, evsel) {\r\nret = do_write(fd, &evsel->attr, sz);\r\nif (ret < 0)\r\nreturn ret;\r\nnri = evsel->ids;\r\nret = do_write(fd, &nri, sizeof(nri));\r\nif (ret < 0)\r\nreturn ret;\r\nret = do_write_string(fd, perf_evsel__name(evsel));\r\nif (ret < 0)\r\nreturn ret;\r\nret = do_write(fd, evsel->id, evsel->ids * sizeof(u64));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_cmdline(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nchar buf[MAXPATHLEN];\r\nchar proc[32];\r\nu32 i, n;\r\nint ret;\r\nsprintf(proc, "/proc/%d/exe", getpid());\r\nret = readlink(proc, buf, sizeof(buf));\r\nif (ret <= 0)\r\nreturn -1;\r\nbuf[ret] = '\0';\r\nn = header_argc + 1;\r\nret = do_write(fd, &n, sizeof(n));\r\nif (ret < 0)\r\nreturn ret;\r\nret = do_write_string(fd, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0 ; i < header_argc; i++) {\r\nret = do_write_string(fd, header_argv[i]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int build_cpu_topo(struct cpu_topo *tp, int cpu)\r\n{\r\nFILE *fp;\r\nchar filename[MAXPATHLEN];\r\nchar *buf = NULL, *p;\r\nsize_t len = 0;\r\nssize_t sret;\r\nu32 i = 0;\r\nint ret = -1;\r\nsprintf(filename, CORE_SIB_FMT, cpu);\r\nfp = fopen(filename, "r");\r\nif (!fp)\r\ngoto try_threads;\r\nsret = getline(&buf, &len, fp);\r\nfclose(fp);\r\nif (sret <= 0)\r\ngoto try_threads;\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = '\0';\r\nfor (i = 0; i < tp->core_sib; i++) {\r\nif (!strcmp(buf, tp->core_siblings[i]))\r\nbreak;\r\n}\r\nif (i == tp->core_sib) {\r\ntp->core_siblings[i] = buf;\r\ntp->core_sib++;\r\nbuf = NULL;\r\nlen = 0;\r\n}\r\nret = 0;\r\ntry_threads:\r\nsprintf(filename, THRD_SIB_FMT, cpu);\r\nfp = fopen(filename, "r");\r\nif (!fp)\r\ngoto done;\r\nif (getline(&buf, &len, fp) <= 0)\r\ngoto done;\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = '\0';\r\nfor (i = 0; i < tp->thread_sib; i++) {\r\nif (!strcmp(buf, tp->thread_siblings[i]))\r\nbreak;\r\n}\r\nif (i == tp->thread_sib) {\r\ntp->thread_siblings[i] = buf;\r\ntp->thread_sib++;\r\nbuf = NULL;\r\n}\r\nret = 0;\r\ndone:\r\nif(fp)\r\nfclose(fp);\r\nfree(buf);\r\nreturn ret;\r\n}\r\nstatic void free_cpu_topo(struct cpu_topo *tp)\r\n{\r\nu32 i;\r\nif (!tp)\r\nreturn;\r\nfor (i = 0 ; i < tp->core_sib; i++)\r\nzfree(&tp->core_siblings[i]);\r\nfor (i = 0 ; i < tp->thread_sib; i++)\r\nzfree(&tp->thread_siblings[i]);\r\nfree(tp);\r\n}\r\nstatic struct cpu_topo *build_cpu_topology(void)\r\n{\r\nstruct cpu_topo *tp;\r\nvoid *addr;\r\nu32 nr, i;\r\nsize_t sz;\r\nlong ncpus;\r\nint ret = -1;\r\nncpus = sysconf(_SC_NPROCESSORS_CONF);\r\nif (ncpus < 0)\r\nreturn NULL;\r\nnr = (u32)(ncpus & UINT_MAX);\r\nsz = nr * sizeof(char *);\r\naddr = calloc(1, sizeof(*tp) + 2 * sz);\r\nif (!addr)\r\nreturn NULL;\r\ntp = addr;\r\naddr += sizeof(*tp);\r\ntp->core_siblings = addr;\r\naddr += sz;\r\ntp->thread_siblings = addr;\r\nfor (i = 0; i < nr; i++) {\r\nret = build_cpu_topo(tp, i);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nif (ret) {\r\nfree_cpu_topo(tp);\r\ntp = NULL;\r\n}\r\nreturn tp;\r\n}\r\nstatic int write_cpu_topology(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nstruct cpu_topo *tp;\r\nu32 i;\r\nint ret;\r\ntp = build_cpu_topology();\r\nif (!tp)\r\nreturn -1;\r\nret = do_write(fd, &tp->core_sib, sizeof(tp->core_sib));\r\nif (ret < 0)\r\ngoto done;\r\nfor (i = 0; i < tp->core_sib; i++) {\r\nret = do_write_string(fd, tp->core_siblings[i]);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nret = do_write(fd, &tp->thread_sib, sizeof(tp->thread_sib));\r\nif (ret < 0)\r\ngoto done;\r\nfor (i = 0; i < tp->thread_sib; i++) {\r\nret = do_write_string(fd, tp->thread_siblings[i]);\r\nif (ret < 0)\r\nbreak;\r\n}\r\ndone:\r\nfree_cpu_topo(tp);\r\nreturn ret;\r\n}\r\nstatic int write_total_mem(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nchar *buf = NULL;\r\nFILE *fp;\r\nsize_t len = 0;\r\nint ret = -1, n;\r\nuint64_t mem;\r\nfp = fopen("/proc/meminfo", "r");\r\nif (!fp)\r\nreturn -1;\r\nwhile (getline(&buf, &len, fp) > 0) {\r\nret = strncmp(buf, "MemTotal:", 9);\r\nif (!ret)\r\nbreak;\r\n}\r\nif (!ret) {\r\nn = sscanf(buf, "%*s %"PRIu64, &mem);\r\nif (n == 1)\r\nret = do_write(fd, &mem, sizeof(mem));\r\n}\r\nfree(buf);\r\nfclose(fp);\r\nreturn ret;\r\n}\r\nstatic int write_topo_node(int fd, int node)\r\n{\r\nchar str[MAXPATHLEN];\r\nchar field[32];\r\nchar *buf = NULL, *p;\r\nsize_t len = 0;\r\nFILE *fp;\r\nu64 mem_total, mem_free, mem;\r\nint ret = -1;\r\nsprintf(str, "/sys/devices/system/node/node%d/meminfo", node);\r\nfp = fopen(str, "r");\r\nif (!fp)\r\nreturn -1;\r\nwhile (getline(&buf, &len, fp) > 0) {\r\nif (!strchr(buf, ':'))\r\ncontinue;\r\nif (sscanf(buf, "%*s %*d %31s %"PRIu64, field, &mem) != 2)\r\ngoto done;\r\nif (!strcmp(field, "MemTotal:"))\r\nmem_total = mem;\r\nif (!strcmp(field, "MemFree:"))\r\nmem_free = mem;\r\n}\r\nfclose(fp);\r\nfp = NULL;\r\nret = do_write(fd, &mem_total, sizeof(u64));\r\nif (ret)\r\ngoto done;\r\nret = do_write(fd, &mem_free, sizeof(u64));\r\nif (ret)\r\ngoto done;\r\nret = -1;\r\nsprintf(str, "/sys/devices/system/node/node%d/cpulist", node);\r\nfp = fopen(str, "r");\r\nif (!fp)\r\ngoto done;\r\nif (getline(&buf, &len, fp) <= 0)\r\ngoto done;\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = '\0';\r\nret = do_write_string(fd, buf);\r\ndone:\r\nfree(buf);\r\nif (fp)\r\nfclose(fp);\r\nreturn ret;\r\n}\r\nstatic int write_numa_topology(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nchar *buf = NULL;\r\nsize_t len = 0;\r\nFILE *fp;\r\nstruct cpu_map *node_map = NULL;\r\nchar *c;\r\nu32 nr, i, j;\r\nint ret = -1;\r\nfp = fopen("/sys/devices/system/node/online", "r");\r\nif (!fp)\r\nreturn -1;\r\nif (getline(&buf, &len, fp) <= 0)\r\ngoto done;\r\nc = strchr(buf, '\n');\r\nif (c)\r\n*c = '\0';\r\nnode_map = cpu_map__new(buf);\r\nif (!node_map)\r\ngoto done;\r\nnr = (u32)node_map->nr;\r\nret = do_write(fd, &nr, sizeof(nr));\r\nif (ret < 0)\r\ngoto done;\r\nfor (i = 0; i < nr; i++) {\r\nj = (u32)node_map->map[i];\r\nret = do_write(fd, &j, sizeof(j));\r\nif (ret < 0)\r\nbreak;\r\nret = write_topo_node(fd, i);\r\nif (ret < 0)\r\nbreak;\r\n}\r\ndone:\r\nfree(buf);\r\nfclose(fp);\r\nfree(node_map);\r\nreturn ret;\r\n}\r\nstatic int write_pmu_mappings(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nstruct perf_pmu *pmu = NULL;\r\noff_t offset = lseek(fd, 0, SEEK_CUR);\r\n__u32 pmu_num = 0;\r\nint ret;\r\nret = do_write(fd, &pmu_num, sizeof(pmu_num));\r\nif (ret < 0)\r\nreturn ret;\r\nwhile ((pmu = perf_pmu__scan(pmu))) {\r\nif (!pmu->name)\r\ncontinue;\r\npmu_num++;\r\nret = do_write(fd, &pmu->type, sizeof(pmu->type));\r\nif (ret < 0)\r\nreturn ret;\r\nret = do_write_string(fd, pmu->name);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (pwrite(fd, &pmu_num, sizeof(pmu_num), offset) != sizeof(pmu_num)) {\r\nlseek(fd, offset, SEEK_SET);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_group_desc(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist)\r\n{\r\nu32 nr_groups = evlist->nr_groups;\r\nstruct perf_evsel *evsel;\r\nint ret;\r\nret = do_write(fd, &nr_groups, sizeof(nr_groups));\r\nif (ret < 0)\r\nreturn ret;\r\nevlist__for_each(evlist, evsel) {\r\nif (perf_evsel__is_group_leader(evsel) &&\r\nevsel->nr_members > 1) {\r\nconst char *name = evsel->group_name ?: "{anon_group}";\r\nu32 leader_idx = evsel->idx;\r\nu32 nr_members = evsel->nr_members;\r\nret = do_write_string(fd, name);\r\nif (ret < 0)\r\nreturn ret;\r\nret = do_write(fd, &leader_idx, sizeof(leader_idx));\r\nif (ret < 0)\r\nreturn ret;\r\nret = do_write(fd, &nr_members, sizeof(nr_members));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_cpuid(int fd, struct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nchar buffer[64];\r\nint ret;\r\nret = get_cpuid(buffer, sizeof(buffer));\r\nif (!ret)\r\ngoto write_it;\r\nreturn -1;\r\nwrite_it:\r\nreturn do_write_string(fd, buffer);\r\n}\r\nstatic int write_branch_stack(int fd __maybe_unused,\r\nstruct perf_header *h __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic void print_hostname(struct perf_header *ph, int fd __maybe_unused,\r\nFILE *fp)\r\n{\r\nfprintf(fp, "# hostname : %s\n", ph->env.hostname);\r\n}\r\nstatic void print_osrelease(struct perf_header *ph, int fd __maybe_unused,\r\nFILE *fp)\r\n{\r\nfprintf(fp, "# os release : %s\n", ph->env.os_release);\r\n}\r\nstatic void print_arch(struct perf_header *ph, int fd __maybe_unused, FILE *fp)\r\n{\r\nfprintf(fp, "# arch : %s\n", ph->env.arch);\r\n}\r\nstatic void print_cpudesc(struct perf_header *ph, int fd __maybe_unused,\r\nFILE *fp)\r\n{\r\nfprintf(fp, "# cpudesc : %s\n", ph->env.cpu_desc);\r\n}\r\nstatic void print_nrcpus(struct perf_header *ph, int fd __maybe_unused,\r\nFILE *fp)\r\n{\r\nfprintf(fp, "# nrcpus online : %u\n", ph->env.nr_cpus_online);\r\nfprintf(fp, "# nrcpus avail : %u\n", ph->env.nr_cpus_avail);\r\n}\r\nstatic void print_version(struct perf_header *ph, int fd __maybe_unused,\r\nFILE *fp)\r\n{\r\nfprintf(fp, "# perf version : %s\n", ph->env.version);\r\n}\r\nstatic void print_cmdline(struct perf_header *ph, int fd __maybe_unused,\r\nFILE *fp)\r\n{\r\nint nr, i;\r\nchar *str;\r\nnr = ph->env.nr_cmdline;\r\nstr = ph->env.cmdline;\r\nfprintf(fp, "# cmdline : ");\r\nfor (i = 0; i < nr; i++) {\r\nfprintf(fp, "%s ", str);\r\nstr += strlen(str) + 1;\r\n}\r\nfputc('\n', fp);\r\n}\r\nstatic void print_cpu_topology(struct perf_header *ph, int fd __maybe_unused,\r\nFILE *fp)\r\n{\r\nint nr, i;\r\nchar *str;\r\nnr = ph->env.nr_sibling_cores;\r\nstr = ph->env.sibling_cores;\r\nfor (i = 0; i < nr; i++) {\r\nfprintf(fp, "# sibling cores : %s\n", str);\r\nstr += strlen(str) + 1;\r\n}\r\nnr = ph->env.nr_sibling_threads;\r\nstr = ph->env.sibling_threads;\r\nfor (i = 0; i < nr; i++) {\r\nfprintf(fp, "# sibling threads : %s\n", str);\r\nstr += strlen(str) + 1;\r\n}\r\n}\r\nstatic void free_event_desc(struct perf_evsel *events)\r\n{\r\nstruct perf_evsel *evsel;\r\nif (!events)\r\nreturn;\r\nfor (evsel = events; evsel->attr.size; evsel++) {\r\nzfree(&evsel->name);\r\nzfree(&evsel->id);\r\n}\r\nfree(events);\r\n}\r\nstatic struct perf_evsel *\r\nread_event_desc(struct perf_header *ph, int fd)\r\n{\r\nstruct perf_evsel *evsel, *events = NULL;\r\nu64 *id;\r\nvoid *buf = NULL;\r\nu32 nre, sz, nr, i, j;\r\nssize_t ret;\r\nsize_t msz;\r\nret = readn(fd, &nre, sizeof(nre));\r\nif (ret != (ssize_t)sizeof(nre))\r\ngoto error;\r\nif (ph->needs_swap)\r\nnre = bswap_32(nre);\r\nret = readn(fd, &sz, sizeof(sz));\r\nif (ret != (ssize_t)sizeof(sz))\r\ngoto error;\r\nif (ph->needs_swap)\r\nsz = bswap_32(sz);\r\nbuf = malloc(sz);\r\nif (!buf)\r\ngoto error;\r\nevents = calloc(nre + 1, sizeof(*events));\r\nif (!events)\r\ngoto error;\r\nmsz = sizeof(evsel->attr);\r\nif (sz < msz)\r\nmsz = sz;\r\nfor (i = 0, evsel = events; i < nre; evsel++, i++) {\r\nevsel->idx = i;\r\nret = readn(fd, buf, sz);\r\nif (ret != (ssize_t)sz)\r\ngoto error;\r\nif (ph->needs_swap)\r\nperf_event__attr_swap(buf);\r\nmemcpy(&evsel->attr, buf, msz);\r\nret = readn(fd, &nr, sizeof(nr));\r\nif (ret != (ssize_t)sizeof(nr))\r\ngoto error;\r\nif (ph->needs_swap) {\r\nnr = bswap_32(nr);\r\nevsel->needs_swap = true;\r\n}\r\nevsel->name = do_read_string(fd, ph);\r\nif (!nr)\r\ncontinue;\r\nid = calloc(nr, sizeof(*id));\r\nif (!id)\r\ngoto error;\r\nevsel->ids = nr;\r\nevsel->id = id;\r\nfor (j = 0 ; j < nr; j++) {\r\nret = readn(fd, id, sizeof(*id));\r\nif (ret != (ssize_t)sizeof(*id))\r\ngoto error;\r\nif (ph->needs_swap)\r\n*id = bswap_64(*id);\r\nid++;\r\n}\r\n}\r\nout:\r\nfree(buf);\r\nreturn events;\r\nerror:\r\nif (events)\r\nfree_event_desc(events);\r\nevents = NULL;\r\ngoto out;\r\n}\r\nstatic void print_event_desc(struct perf_header *ph, int fd, FILE *fp)\r\n{\r\nstruct perf_evsel *evsel, *events = read_event_desc(ph, fd);\r\nu32 j;\r\nu64 *id;\r\nif (!events) {\r\nfprintf(fp, "# event desc: not available or unable to read\n");\r\nreturn;\r\n}\r\nfor (evsel = events; evsel->attr.size; evsel++) {\r\nfprintf(fp, "# event : name = %s, ", evsel->name);\r\nfprintf(fp, "type = %d, config = 0x%"PRIx64\r\n", config1 = 0x%"PRIx64", config2 = 0x%"PRIx64,\r\nevsel->attr.type,\r\n(u64)evsel->attr.config,\r\n(u64)evsel->attr.config1,\r\n(u64)evsel->attr.config2);\r\nfprintf(fp, ", excl_usr = %d, excl_kern = %d",\r\nevsel->attr.exclude_user,\r\nevsel->attr.exclude_kernel);\r\nfprintf(fp, ", excl_host = %d, excl_guest = %d",\r\nevsel->attr.exclude_host,\r\nevsel->attr.exclude_guest);\r\nfprintf(fp, ", precise_ip = %d", evsel->attr.precise_ip);\r\nfprintf(fp, ", attr_mmap2 = %d", evsel->attr.mmap2);\r\nfprintf(fp, ", attr_mmap = %d", evsel->attr.mmap);\r\nfprintf(fp, ", attr_mmap_data = %d", evsel->attr.mmap_data);\r\nif (evsel->ids) {\r\nfprintf(fp, ", id = {");\r\nfor (j = 0, id = evsel->id; j < evsel->ids; j++, id++) {\r\nif (j)\r\nfputc(',', fp);\r\nfprintf(fp, " %"PRIu64, *id);\r\n}\r\nfprintf(fp, " }");\r\n}\r\nfputc('\n', fp);\r\n}\r\nfree_event_desc(events);\r\n}\r\nstatic void print_total_mem(struct perf_header *ph, int fd __maybe_unused,\r\nFILE *fp)\r\n{\r\nfprintf(fp, "# total memory : %Lu kB\n", ph->env.total_mem);\r\n}\r\nstatic void print_numa_topology(struct perf_header *ph, int fd __maybe_unused,\r\nFILE *fp)\r\n{\r\nu32 nr, c, i;\r\nchar *str, *tmp;\r\nuint64_t mem_total, mem_free;\r\nnr = ph->env.nr_numa_nodes;\r\nstr = ph->env.numa_nodes;\r\nfor (i = 0; i < nr; i++) {\r\nc = strtoul(str, &tmp, 0);\r\nif (*tmp != ':')\r\ngoto error;\r\nstr = tmp + 1;\r\nmem_total = strtoull(str, &tmp, 0);\r\nif (*tmp != ':')\r\ngoto error;\r\nstr = tmp + 1;\r\nmem_free = strtoull(str, &tmp, 0);\r\nif (*tmp != ':')\r\ngoto error;\r\nfprintf(fp, "# node%u meminfo : total = %"PRIu64" kB,"\r\n" free = %"PRIu64" kB\n",\r\nc, mem_total, mem_free);\r\nstr = tmp + 1;\r\nfprintf(fp, "# node%u cpu list : %s\n", c, str);\r\nstr += strlen(str) + 1;\r\n}\r\nreturn;\r\nerror:\r\nfprintf(fp, "# numa topology : not available\n");\r\n}\r\nstatic void print_cpuid(struct perf_header *ph, int fd __maybe_unused, FILE *fp)\r\n{\r\nfprintf(fp, "# cpuid : %s\n", ph->env.cpuid);\r\n}\r\nstatic void print_branch_stack(struct perf_header *ph __maybe_unused,\r\nint fd __maybe_unused, FILE *fp)\r\n{\r\nfprintf(fp, "# contains samples with branch stack\n");\r\n}\r\nstatic void print_pmu_mappings(struct perf_header *ph, int fd __maybe_unused,\r\nFILE *fp)\r\n{\r\nconst char *delimiter = "# pmu mappings: ";\r\nchar *str, *tmp;\r\nu32 pmu_num;\r\nu32 type;\r\npmu_num = ph->env.nr_pmu_mappings;\r\nif (!pmu_num) {\r\nfprintf(fp, "# pmu mappings: not available\n");\r\nreturn;\r\n}\r\nstr = ph->env.pmu_mappings;\r\nwhile (pmu_num) {\r\ntype = strtoul(str, &tmp, 0);\r\nif (*tmp != ':')\r\ngoto error;\r\nstr = tmp + 1;\r\nfprintf(fp, "%s%s = %" PRIu32, delimiter, str, type);\r\ndelimiter = ", ";\r\nstr += strlen(str) + 1;\r\npmu_num--;\r\n}\r\nfprintf(fp, "\n");\r\nif (!pmu_num)\r\nreturn;\r\nerror:\r\nfprintf(fp, "# pmu mappings: unable to read\n");\r\n}\r\nstatic void print_group_desc(struct perf_header *ph, int fd __maybe_unused,\r\nFILE *fp)\r\n{\r\nstruct perf_session *session;\r\nstruct perf_evsel *evsel;\r\nu32 nr = 0;\r\nsession = container_of(ph, struct perf_session, header);\r\nevlist__for_each(session->evlist, evsel) {\r\nif (perf_evsel__is_group_leader(evsel) &&\r\nevsel->nr_members > 1) {\r\nfprintf(fp, "# group: %s{%s", evsel->group_name ?: "",\r\nperf_evsel__name(evsel));\r\nnr = evsel->nr_members - 1;\r\n} else if (nr) {\r\nfprintf(fp, ",%s", perf_evsel__name(evsel));\r\nif (--nr == 0)\r\nfprintf(fp, "}\n");\r\n}\r\n}\r\n}\r\nstatic int __event_process_build_id(struct build_id_event *bev,\r\nchar *filename,\r\nstruct perf_session *session)\r\n{\r\nint err = -1;\r\nstruct list_head *head;\r\nstruct machine *machine;\r\nu16 misc;\r\nstruct dso *dso;\r\nenum dso_kernel_type dso_type;\r\nmachine = perf_session__findnew_machine(session, bev->pid);\r\nif (!machine)\r\ngoto out;\r\nmisc = bev->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\r\nswitch (misc) {\r\ncase PERF_RECORD_MISC_KERNEL:\r\ndso_type = DSO_TYPE_KERNEL;\r\nhead = &machine->kernel_dsos;\r\nbreak;\r\ncase PERF_RECORD_MISC_GUEST_KERNEL:\r\ndso_type = DSO_TYPE_GUEST_KERNEL;\r\nhead = &machine->kernel_dsos;\r\nbreak;\r\ncase PERF_RECORD_MISC_USER:\r\ncase PERF_RECORD_MISC_GUEST_USER:\r\ndso_type = DSO_TYPE_USER;\r\nhead = &machine->user_dsos;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\ndso = __dsos__findnew(head, filename);\r\nif (dso != NULL) {\r\nchar sbuild_id[BUILD_ID_SIZE * 2 + 1];\r\ndso__set_build_id(dso, &bev->build_id);\r\nif (filename[0] == '[')\r\ndso->kernel = dso_type;\r\nbuild_id__sprintf(dso->build_id, sizeof(dso->build_id),\r\nsbuild_id);\r\npr_debug("build id event received for %s: %s\n",\r\ndso->long_name, sbuild_id);\r\n}\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int perf_header__read_build_ids_abi_quirk(struct perf_header *header,\r\nint input, u64 offset, u64 size)\r\n{\r\nstruct perf_session *session = container_of(header, struct perf_session, header);\r\nstruct {\r\nstruct perf_event_header header;\r\nu8 build_id[PERF_ALIGN(BUILD_ID_SIZE, sizeof(u64))];\r\nchar filename[0];\r\n} old_bev;\r\nstruct build_id_event bev;\r\nchar filename[PATH_MAX];\r\nu64 limit = offset + size;\r\nwhile (offset < limit) {\r\nssize_t len;\r\nif (readn(input, &old_bev, sizeof(old_bev)) != sizeof(old_bev))\r\nreturn -1;\r\nif (header->needs_swap)\r\nperf_event_header__bswap(&old_bev.header);\r\nlen = old_bev.header.size - sizeof(old_bev);\r\nif (readn(input, filename, len) != len)\r\nreturn -1;\r\nbev.header = old_bev.header;\r\nbev.pid = HOST_KERNEL_ID;\r\nif (bev.header.misc == PERF_RECORD_MISC_GUEST_USER ||\r\nbev.header.misc == PERF_RECORD_MISC_GUEST_KERNEL)\r\nbev.pid = DEFAULT_GUEST_KERNEL_ID;\r\nmemcpy(bev.build_id, old_bev.build_id, sizeof(bev.build_id));\r\n__event_process_build_id(&bev, filename, session);\r\noffset += bev.header.size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int perf_header__read_build_ids(struct perf_header *header,\r\nint input, u64 offset, u64 size)\r\n{\r\nstruct perf_session *session = container_of(header, struct perf_session, header);\r\nstruct build_id_event bev;\r\nchar filename[PATH_MAX];\r\nu64 limit = offset + size, orig_offset = offset;\r\nint err = -1;\r\nwhile (offset < limit) {\r\nssize_t len;\r\nif (readn(input, &bev, sizeof(bev)) != sizeof(bev))\r\ngoto out;\r\nif (header->needs_swap)\r\nperf_event_header__bswap(&bev.header);\r\nlen = bev.header.size - sizeof(bev);\r\nif (readn(input, filename, len) != len)\r\ngoto out;\r\nif (memcmp(filename, "nel.kallsyms]", 13) == 0) {\r\nif (lseek(input, orig_offset, SEEK_SET) == (off_t)-1)\r\nreturn -1;\r\nreturn perf_header__read_build_ids_abi_quirk(header, input, offset, size);\r\n}\r\n__event_process_build_id(&bev, filename, session);\r\noffset += bev.header.size;\r\n}\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int process_tracing_data(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph __maybe_unused,\r\nint fd, void *data)\r\n{\r\nssize_t ret = trace_report(fd, data, false);\r\nreturn ret < 0 ? -1 : 0;\r\n}\r\nstatic int process_build_id(struct perf_file_section *section,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nif (perf_header__read_build_ids(ph, fd, section->offset, section->size))\r\npr_debug("Failed to read buildids, continuing...\n");\r\nreturn 0;\r\n}\r\nstatic int process_hostname(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nph->env.hostname = do_read_string(fd, ph);\r\nreturn ph->env.hostname ? 0 : -ENOMEM;\r\n}\r\nstatic int process_osrelease(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nph->env.os_release = do_read_string(fd, ph);\r\nreturn ph->env.os_release ? 0 : -ENOMEM;\r\n}\r\nstatic int process_version(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nph->env.version = do_read_string(fd, ph);\r\nreturn ph->env.version ? 0 : -ENOMEM;\r\n}\r\nstatic int process_arch(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nph->env.arch = do_read_string(fd, ph);\r\nreturn ph->env.arch ? 0 : -ENOMEM;\r\n}\r\nstatic int process_nrcpus(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nssize_t ret;\r\nu32 nr;\r\nret = readn(fd, &nr, sizeof(nr));\r\nif (ret != sizeof(nr))\r\nreturn -1;\r\nif (ph->needs_swap)\r\nnr = bswap_32(nr);\r\nph->env.nr_cpus_online = nr;\r\nret = readn(fd, &nr, sizeof(nr));\r\nif (ret != sizeof(nr))\r\nreturn -1;\r\nif (ph->needs_swap)\r\nnr = bswap_32(nr);\r\nph->env.nr_cpus_avail = nr;\r\nreturn 0;\r\n}\r\nstatic int process_cpudesc(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nph->env.cpu_desc = do_read_string(fd, ph);\r\nreturn ph->env.cpu_desc ? 0 : -ENOMEM;\r\n}\r\nstatic int process_cpuid(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nph->env.cpuid = do_read_string(fd, ph);\r\nreturn ph->env.cpuid ? 0 : -ENOMEM;\r\n}\r\nstatic int process_total_mem(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nuint64_t mem;\r\nssize_t ret;\r\nret = readn(fd, &mem, sizeof(mem));\r\nif (ret != sizeof(mem))\r\nreturn -1;\r\nif (ph->needs_swap)\r\nmem = bswap_64(mem);\r\nph->env.total_mem = mem;\r\nreturn 0;\r\n}\r\nstatic struct perf_evsel *\r\nperf_evlist__find_by_index(struct perf_evlist *evlist, int idx)\r\n{\r\nstruct perf_evsel *evsel;\r\nevlist__for_each(evlist, evsel) {\r\nif (evsel->idx == idx)\r\nreturn evsel;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nperf_evlist__set_event_name(struct perf_evlist *evlist,\r\nstruct perf_evsel *event)\r\n{\r\nstruct perf_evsel *evsel;\r\nif (!event->name)\r\nreturn;\r\nevsel = perf_evlist__find_by_index(evlist, event->idx);\r\nif (!evsel)\r\nreturn;\r\nif (evsel->name)\r\nreturn;\r\nevsel->name = strdup(event->name);\r\n}\r\nstatic int\r\nprocess_event_desc(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *header, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nstruct perf_session *session;\r\nstruct perf_evsel *evsel, *events = read_event_desc(header, fd);\r\nif (!events)\r\nreturn 0;\r\nsession = container_of(header, struct perf_session, header);\r\nfor (evsel = events; evsel->attr.size; evsel++)\r\nperf_evlist__set_event_name(session->evlist, evsel);\r\nfree_event_desc(events);\r\nreturn 0;\r\n}\r\nstatic int process_cmdline(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nssize_t ret;\r\nchar *str;\r\nu32 nr, i;\r\nstruct strbuf sb;\r\nret = readn(fd, &nr, sizeof(nr));\r\nif (ret != sizeof(nr))\r\nreturn -1;\r\nif (ph->needs_swap)\r\nnr = bswap_32(nr);\r\nph->env.nr_cmdline = nr;\r\nstrbuf_init(&sb, 128);\r\nfor (i = 0; i < nr; i++) {\r\nstr = do_read_string(fd, ph);\r\nif (!str)\r\ngoto error;\r\nstrbuf_add(&sb, str, strlen(str) + 1);\r\nfree(str);\r\n}\r\nph->env.cmdline = strbuf_detach(&sb, NULL);\r\nreturn 0;\r\nerror:\r\nstrbuf_release(&sb);\r\nreturn -1;\r\n}\r\nstatic int process_cpu_topology(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nssize_t ret;\r\nu32 nr, i;\r\nchar *str;\r\nstruct strbuf sb;\r\nret = readn(fd, &nr, sizeof(nr));\r\nif (ret != sizeof(nr))\r\nreturn -1;\r\nif (ph->needs_swap)\r\nnr = bswap_32(nr);\r\nph->env.nr_sibling_cores = nr;\r\nstrbuf_init(&sb, 128);\r\nfor (i = 0; i < nr; i++) {\r\nstr = do_read_string(fd, ph);\r\nif (!str)\r\ngoto error;\r\nstrbuf_add(&sb, str, strlen(str) + 1);\r\nfree(str);\r\n}\r\nph->env.sibling_cores = strbuf_detach(&sb, NULL);\r\nret = readn(fd, &nr, sizeof(nr));\r\nif (ret != sizeof(nr))\r\nreturn -1;\r\nif (ph->needs_swap)\r\nnr = bswap_32(nr);\r\nph->env.nr_sibling_threads = nr;\r\nfor (i = 0; i < nr; i++) {\r\nstr = do_read_string(fd, ph);\r\nif (!str)\r\ngoto error;\r\nstrbuf_add(&sb, str, strlen(str) + 1);\r\nfree(str);\r\n}\r\nph->env.sibling_threads = strbuf_detach(&sb, NULL);\r\nreturn 0;\r\nerror:\r\nstrbuf_release(&sb);\r\nreturn -1;\r\n}\r\nstatic int process_numa_topology(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nssize_t ret;\r\nu32 nr, node, i;\r\nchar *str;\r\nuint64_t mem_total, mem_free;\r\nstruct strbuf sb;\r\nret = readn(fd, &nr, sizeof(nr));\r\nif (ret != sizeof(nr))\r\ngoto error;\r\nif (ph->needs_swap)\r\nnr = bswap_32(nr);\r\nph->env.nr_numa_nodes = nr;\r\nstrbuf_init(&sb, 256);\r\nfor (i = 0; i < nr; i++) {\r\nret = readn(fd, &node, sizeof(node));\r\nif (ret != sizeof(node))\r\ngoto error;\r\nret = readn(fd, &mem_total, sizeof(u64));\r\nif (ret != sizeof(u64))\r\ngoto error;\r\nret = readn(fd, &mem_free, sizeof(u64));\r\nif (ret != sizeof(u64))\r\ngoto error;\r\nif (ph->needs_swap) {\r\nnode = bswap_32(node);\r\nmem_total = bswap_64(mem_total);\r\nmem_free = bswap_64(mem_free);\r\n}\r\nstrbuf_addf(&sb, "%u:%"PRIu64":%"PRIu64":",\r\nnode, mem_total, mem_free);\r\nstr = do_read_string(fd, ph);\r\nif (!str)\r\ngoto error;\r\nstrbuf_add(&sb, str, strlen(str) + 1);\r\nfree(str);\r\n}\r\nph->env.numa_nodes = strbuf_detach(&sb, NULL);\r\nreturn 0;\r\nerror:\r\nstrbuf_release(&sb);\r\nreturn -1;\r\n}\r\nstatic int process_pmu_mappings(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nssize_t ret;\r\nchar *name;\r\nu32 pmu_num;\r\nu32 type;\r\nstruct strbuf sb;\r\nret = readn(fd, &pmu_num, sizeof(pmu_num));\r\nif (ret != sizeof(pmu_num))\r\nreturn -1;\r\nif (ph->needs_swap)\r\npmu_num = bswap_32(pmu_num);\r\nif (!pmu_num) {\r\npr_debug("pmu mappings not available\n");\r\nreturn 0;\r\n}\r\nph->env.nr_pmu_mappings = pmu_num;\r\nstrbuf_init(&sb, 128);\r\nwhile (pmu_num) {\r\nif (readn(fd, &type, sizeof(type)) != sizeof(type))\r\ngoto error;\r\nif (ph->needs_swap)\r\ntype = bswap_32(type);\r\nname = do_read_string(fd, ph);\r\nif (!name)\r\ngoto error;\r\nstrbuf_addf(&sb, "%u:%s", type, name);\r\nstrbuf_add(&sb, "", 1);\r\nfree(name);\r\npmu_num--;\r\n}\r\nph->env.pmu_mappings = strbuf_detach(&sb, NULL);\r\nreturn 0;\r\nerror:\r\nstrbuf_release(&sb);\r\nreturn -1;\r\n}\r\nstatic int process_group_desc(struct perf_file_section *section __maybe_unused,\r\nstruct perf_header *ph, int fd,\r\nvoid *data __maybe_unused)\r\n{\r\nsize_t ret = -1;\r\nu32 i, nr, nr_groups;\r\nstruct perf_session *session;\r\nstruct perf_evsel *evsel, *leader = NULL;\r\nstruct group_desc {\r\nchar *name;\r\nu32 leader_idx;\r\nu32 nr_members;\r\n} *desc;\r\nif (readn(fd, &nr_groups, sizeof(nr_groups)) != sizeof(nr_groups))\r\nreturn -1;\r\nif (ph->needs_swap)\r\nnr_groups = bswap_32(nr_groups);\r\nph->env.nr_groups = nr_groups;\r\nif (!nr_groups) {\r\npr_debug("group desc not available\n");\r\nreturn 0;\r\n}\r\ndesc = calloc(nr_groups, sizeof(*desc));\r\nif (!desc)\r\nreturn -1;\r\nfor (i = 0; i < nr_groups; i++) {\r\ndesc[i].name = do_read_string(fd, ph);\r\nif (!desc[i].name)\r\ngoto out_free;\r\nif (readn(fd, &desc[i].leader_idx, sizeof(u32)) != sizeof(u32))\r\ngoto out_free;\r\nif (readn(fd, &desc[i].nr_members, sizeof(u32)) != sizeof(u32))\r\ngoto out_free;\r\nif (ph->needs_swap) {\r\ndesc[i].leader_idx = bswap_32(desc[i].leader_idx);\r\ndesc[i].nr_members = bswap_32(desc[i].nr_members);\r\n}\r\n}\r\nsession = container_of(ph, struct perf_session, header);\r\nsession->evlist->nr_groups = nr_groups;\r\ni = nr = 0;\r\nevlist__for_each(session->evlist, evsel) {\r\nif (evsel->idx == (int) desc[i].leader_idx) {\r\nevsel->leader = evsel;\r\nif (strcmp(desc[i].name, "{anon_group}")) {\r\nevsel->group_name = desc[i].name;\r\ndesc[i].name = NULL;\r\n}\r\nevsel->nr_members = desc[i].nr_members;\r\nif (i >= nr_groups || nr > 0) {\r\npr_debug("invalid group desc\n");\r\ngoto out_free;\r\n}\r\nleader = evsel;\r\nnr = evsel->nr_members - 1;\r\ni++;\r\n} else if (nr) {\r\nevsel->leader = leader;\r\nnr--;\r\n}\r\n}\r\nif (i != nr_groups || nr != 0) {\r\npr_debug("invalid group desc\n");\r\ngoto out_free;\r\n}\r\nret = 0;\r\nout_free:\r\nfor (i = 0; i < nr_groups; i++)\r\nzfree(&desc[i].name);\r\nfree(desc);\r\nreturn ret;\r\n}\r\nstatic int perf_file_section__fprintf_info(struct perf_file_section *section,\r\nstruct perf_header *ph,\r\nint feat, int fd, void *data)\r\n{\r\nstruct header_print_data *hd = data;\r\nif (lseek(fd, section->offset, SEEK_SET) == (off_t)-1) {\r\npr_debug("Failed to lseek to %" PRIu64 " offset for feature "\r\n"%d, continuing...\n", section->offset, feat);\r\nreturn 0;\r\n}\r\nif (feat >= HEADER_LAST_FEATURE) {\r\npr_warning("unknown feature %d\n", feat);\r\nreturn 0;\r\n}\r\nif (!feat_ops[feat].print)\r\nreturn 0;\r\nif (!feat_ops[feat].full_only || hd->full)\r\nfeat_ops[feat].print(ph, fd, hd->fp);\r\nelse\r\nfprintf(hd->fp, "# %s info available, use -I to display\n",\r\nfeat_ops[feat].name);\r\nreturn 0;\r\n}\r\nint perf_header__fprintf_info(struct perf_session *session, FILE *fp, bool full)\r\n{\r\nstruct header_print_data hd;\r\nstruct perf_header *header = &session->header;\r\nint fd = perf_data_file__fd(session->file);\r\nhd.fp = fp;\r\nhd.full = full;\r\nperf_header__process_sections(header, fd, &hd,\r\nperf_file_section__fprintf_info);\r\nreturn 0;\r\n}\r\nstatic int do_write_feat(int fd, struct perf_header *h, int type,\r\nstruct perf_file_section **p,\r\nstruct perf_evlist *evlist)\r\n{\r\nint err;\r\nint ret = 0;\r\nif (perf_header__has_feat(h, type)) {\r\nif (!feat_ops[type].write)\r\nreturn -1;\r\n(*p)->offset = lseek(fd, 0, SEEK_CUR);\r\nerr = feat_ops[type].write(fd, h, evlist);\r\nif (err < 0) {\r\npr_debug("failed to write feature %d\n", type);\r\nlseek(fd, (*p)->offset, SEEK_SET);\r\nreturn -1;\r\n}\r\n(*p)->size = lseek(fd, 0, SEEK_CUR) - (*p)->offset;\r\n(*p)++;\r\n}\r\nreturn ret;\r\n}\r\nstatic int perf_header__adds_write(struct perf_header *header,\r\nstruct perf_evlist *evlist, int fd)\r\n{\r\nint nr_sections;\r\nstruct perf_file_section *feat_sec, *p;\r\nint sec_size;\r\nu64 sec_start;\r\nint feat;\r\nint err;\r\nnr_sections = bitmap_weight(header->adds_features, HEADER_FEAT_BITS);\r\nif (!nr_sections)\r\nreturn 0;\r\nfeat_sec = p = calloc(nr_sections, sizeof(*feat_sec));\r\nif (feat_sec == NULL)\r\nreturn -ENOMEM;\r\nsec_size = sizeof(*feat_sec) * nr_sections;\r\nsec_start = header->feat_offset;\r\nlseek(fd, sec_start + sec_size, SEEK_SET);\r\nfor_each_set_bit(feat, header->adds_features, HEADER_FEAT_BITS) {\r\nif (do_write_feat(fd, header, feat, &p, evlist))\r\nperf_header__clear_feat(header, feat);\r\n}\r\nlseek(fd, sec_start, SEEK_SET);\r\nerr = do_write(fd, feat_sec, sec_size);\r\nif (err < 0)\r\npr_debug("failed to write feature section\n");\r\nfree(feat_sec);\r\nreturn err;\r\n}\r\nint perf_header__write_pipe(int fd)\r\n{\r\nstruct perf_pipe_file_header f_header;\r\nint err;\r\nf_header = (struct perf_pipe_file_header){\r\n.magic = PERF_MAGIC,\r\n.size = sizeof(f_header),\r\n};\r\nerr = do_write(fd, &f_header, sizeof(f_header));\r\nif (err < 0) {\r\npr_debug("failed to write perf pipe header\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint perf_session__write_header(struct perf_session *session,\r\nstruct perf_evlist *evlist,\r\nint fd, bool at_exit)\r\n{\r\nstruct perf_file_header f_header;\r\nstruct perf_file_attr f_attr;\r\nstruct perf_header *header = &session->header;\r\nstruct perf_evsel *evsel;\r\nu64 attr_offset;\r\nint err;\r\nlseek(fd, sizeof(f_header), SEEK_SET);\r\nevlist__for_each(session->evlist, evsel) {\r\nevsel->id_offset = lseek(fd, 0, SEEK_CUR);\r\nerr = do_write(fd, evsel->id, evsel->ids * sizeof(u64));\r\nif (err < 0) {\r\npr_debug("failed to write perf header\n");\r\nreturn err;\r\n}\r\n}\r\nattr_offset = lseek(fd, 0, SEEK_CUR);\r\nevlist__for_each(evlist, evsel) {\r\nf_attr = (struct perf_file_attr){\r\n.attr = evsel->attr,\r\n.ids = {\r\n.offset = evsel->id_offset,\r\n.size = evsel->ids * sizeof(u64),\r\n}\r\n};\r\nerr = do_write(fd, &f_attr, sizeof(f_attr));\r\nif (err < 0) {\r\npr_debug("failed to write perf header attribute\n");\r\nreturn err;\r\n}\r\n}\r\nif (!header->data_offset)\r\nheader->data_offset = lseek(fd, 0, SEEK_CUR);\r\nheader->feat_offset = header->data_offset + header->data_size;\r\nif (at_exit) {\r\nerr = perf_header__adds_write(header, evlist, fd);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nf_header = (struct perf_file_header){\r\n.magic = PERF_MAGIC,\r\n.size = sizeof(f_header),\r\n.attr_size = sizeof(f_attr),\r\n.attrs = {\r\n.offset = attr_offset,\r\n.size = evlist->nr_entries * sizeof(f_attr),\r\n},\r\n.data = {\r\n.offset = header->data_offset,\r\n.size = header->data_size,\r\n},\r\n};\r\nmemcpy(&f_header.adds_features, &header->adds_features, sizeof(header->adds_features));\r\nlseek(fd, 0, SEEK_SET);\r\nerr = do_write(fd, &f_header, sizeof(f_header));\r\nif (err < 0) {\r\npr_debug("failed to write perf header\n");\r\nreturn err;\r\n}\r\nlseek(fd, header->data_offset + header->data_size, SEEK_SET);\r\nreturn 0;\r\n}\r\nstatic int perf_header__getbuffer64(struct perf_header *header,\r\nint fd, void *buf, size_t size)\r\n{\r\nif (readn(fd, buf, size) <= 0)\r\nreturn -1;\r\nif (header->needs_swap)\r\nmem_bswap_64(buf, size);\r\nreturn 0;\r\n}\r\nint perf_header__process_sections(struct perf_header *header, int fd,\r\nvoid *data,\r\nint (*process)(struct perf_file_section *section,\r\nstruct perf_header *ph,\r\nint feat, int fd, void *data))\r\n{\r\nstruct perf_file_section *feat_sec, *sec;\r\nint nr_sections;\r\nint sec_size;\r\nint feat;\r\nint err;\r\nnr_sections = bitmap_weight(header->adds_features, HEADER_FEAT_BITS);\r\nif (!nr_sections)\r\nreturn 0;\r\nfeat_sec = sec = calloc(nr_sections, sizeof(*feat_sec));\r\nif (!feat_sec)\r\nreturn -1;\r\nsec_size = sizeof(*feat_sec) * nr_sections;\r\nlseek(fd, header->feat_offset, SEEK_SET);\r\nerr = perf_header__getbuffer64(header, fd, feat_sec, sec_size);\r\nif (err < 0)\r\ngoto out_free;\r\nfor_each_set_bit(feat, header->adds_features, HEADER_LAST_FEATURE) {\r\nerr = process(sec++, header, feat, fd, data);\r\nif (err < 0)\r\ngoto out_free;\r\n}\r\nerr = 0;\r\nout_free:\r\nfree(feat_sec);\r\nreturn err;\r\n}\r\nstatic int try_all_file_abis(uint64_t hdr_sz, struct perf_header *ph)\r\n{\r\nuint64_t ref_size, attr_size;\r\nint i;\r\nfor (i = 0 ; attr_file_abi_sizes[i]; i++) {\r\nref_size = attr_file_abi_sizes[i]\r\n+ sizeof(struct perf_file_section);\r\nif (hdr_sz != ref_size) {\r\nattr_size = bswap_64(hdr_sz);\r\nif (attr_size != ref_size)\r\ncontinue;\r\nph->needs_swap = true;\r\n}\r\npr_debug("ABI%d perf.data file detected, need_swap=%d\n",\r\ni,\r\nph->needs_swap);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int try_all_pipe_abis(uint64_t hdr_sz, struct perf_header *ph)\r\n{\r\nu64 attr_size;\r\nint i;\r\nfor (i = 0 ; attr_pipe_abi_sizes[i]; i++) {\r\nif (hdr_sz != attr_pipe_abi_sizes[i]) {\r\nattr_size = bswap_64(hdr_sz);\r\nif (attr_size != hdr_sz)\r\ncontinue;\r\nph->needs_swap = true;\r\n}\r\npr_debug("Pipe ABI%d perf.data file detected\n", i);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nbool is_perf_magic(u64 magic)\r\n{\r\nif (!memcmp(&magic, __perf_magic1, sizeof(magic))\r\n|| magic == __perf_magic2\r\n|| magic == __perf_magic2_sw)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int check_magic_endian(u64 magic, uint64_t hdr_sz,\r\nbool is_pipe, struct perf_header *ph)\r\n{\r\nint ret;\r\nret = memcmp(&magic, __perf_magic1, sizeof(magic));\r\nif (ret == 0) {\r\nph->version = PERF_HEADER_VERSION_1;\r\npr_debug("legacy perf.data format\n");\r\nif (is_pipe)\r\nreturn try_all_pipe_abis(hdr_sz, ph);\r\nreturn try_all_file_abis(hdr_sz, ph);\r\n}\r\nif (magic == __perf_magic2)\r\nreturn 0;\r\nif (magic != __perf_magic2_sw)\r\nreturn -1;\r\nph->needs_swap = true;\r\nph->version = PERF_HEADER_VERSION_2;\r\nreturn 0;\r\n}\r\nint perf_file_header__read(struct perf_file_header *header,\r\nstruct perf_header *ph, int fd)\r\n{\r\nssize_t ret;\r\nlseek(fd, 0, SEEK_SET);\r\nret = readn(fd, header, sizeof(*header));\r\nif (ret <= 0)\r\nreturn -1;\r\nif (check_magic_endian(header->magic,\r\nheader->attr_size, false, ph) < 0) {\r\npr_debug("magic/endian check failed\n");\r\nreturn -1;\r\n}\r\nif (ph->needs_swap) {\r\nmem_bswap_64(header, offsetof(struct perf_file_header,\r\nadds_features));\r\n}\r\nif (header->size != sizeof(*header)) {\r\nif (header->size == offsetof(typeof(*header), adds_features))\r\nbitmap_zero(header->adds_features, HEADER_FEAT_BITS);\r\nelse\r\nreturn -1;\r\n} else if (ph->needs_swap) {\r\nmem_bswap_64(&header->adds_features,\r\nBITS_TO_U64(HEADER_FEAT_BITS));\r\nif (!test_bit(HEADER_HOSTNAME, header->adds_features)) {\r\nmem_bswap_64(&header->adds_features,\r\nBITS_TO_U64(HEADER_FEAT_BITS));\r\nmem_bswap_32(&header->adds_features,\r\nBITS_TO_U32(HEADER_FEAT_BITS));\r\n}\r\nif (!test_bit(HEADER_HOSTNAME, header->adds_features)) {\r\nbitmap_zero(header->adds_features, HEADER_FEAT_BITS);\r\nset_bit(HEADER_BUILD_ID, header->adds_features);\r\n}\r\n}\r\nmemcpy(&ph->adds_features, &header->adds_features,\r\nsizeof(ph->adds_features));\r\nph->data_offset = header->data.offset;\r\nph->data_size = header->data.size;\r\nph->feat_offset = header->data.offset + header->data.size;\r\nreturn 0;\r\n}\r\nstatic int perf_file_section__process(struct perf_file_section *section,\r\nstruct perf_header *ph,\r\nint feat, int fd, void *data)\r\n{\r\nif (lseek(fd, section->offset, SEEK_SET) == (off_t)-1) {\r\npr_debug("Failed to lseek to %" PRIu64 " offset for feature "\r\n"%d, continuing...\n", section->offset, feat);\r\nreturn 0;\r\n}\r\nif (feat >= HEADER_LAST_FEATURE) {\r\npr_debug("unknown feature %d, continuing...\n", feat);\r\nreturn 0;\r\n}\r\nif (!feat_ops[feat].process)\r\nreturn 0;\r\nreturn feat_ops[feat].process(section, ph, fd, data);\r\n}\r\nstatic int perf_file_header__read_pipe(struct perf_pipe_file_header *header,\r\nstruct perf_header *ph, int fd,\r\nbool repipe)\r\n{\r\nssize_t ret;\r\nret = readn(fd, header, sizeof(*header));\r\nif (ret <= 0)\r\nreturn -1;\r\nif (check_magic_endian(header->magic, header->size, true, ph) < 0) {\r\npr_debug("endian/magic failed\n");\r\nreturn -1;\r\n}\r\nif (ph->needs_swap)\r\nheader->size = bswap_64(header->size);\r\nif (repipe && do_write(STDOUT_FILENO, header, sizeof(*header)) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int perf_header__read_pipe(struct perf_session *session)\r\n{\r\nstruct perf_header *header = &session->header;\r\nstruct perf_pipe_file_header f_header;\r\nif (perf_file_header__read_pipe(&f_header, header,\r\nperf_data_file__fd(session->file),\r\nsession->repipe) < 0) {\r\npr_debug("incompatible file format\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_attr(int fd, struct perf_header *ph,\r\nstruct perf_file_attr *f_attr)\r\n{\r\nstruct perf_event_attr *attr = &f_attr->attr;\r\nsize_t sz, left;\r\nsize_t our_sz = sizeof(f_attr->attr);\r\nssize_t ret;\r\nmemset(f_attr, 0, sizeof(*f_attr));\r\nret = readn(fd, attr, PERF_ATTR_SIZE_VER0);\r\nif (ret <= 0) {\r\npr_debug("cannot read %d bytes of header attr\n",\r\nPERF_ATTR_SIZE_VER0);\r\nreturn -1;\r\n}\r\nsz = attr->size;\r\nif (ph->needs_swap)\r\nsz = bswap_32(sz);\r\nif (sz == 0) {\r\nsz = PERF_ATTR_SIZE_VER0;\r\n} else if (sz > our_sz) {\r\npr_debug("file uses a more recent and unsupported ABI"\r\n" (%zu bytes extra)\n", sz - our_sz);\r\nreturn -1;\r\n}\r\nleft = sz - PERF_ATTR_SIZE_VER0;\r\nif (left) {\r\nvoid *ptr = attr;\r\nptr += PERF_ATTR_SIZE_VER0;\r\nret = readn(fd, ptr, left);\r\n}\r\nret = readn(fd, &f_attr->ids, sizeof(f_attr->ids));\r\nreturn ret <= 0 ? -1 : 0;\r\n}\r\nstatic int perf_evsel__prepare_tracepoint_event(struct perf_evsel *evsel,\r\nstruct pevent *pevent)\r\n{\r\nstruct event_format *event;\r\nchar bf[128];\r\nif (evsel->tp_format)\r\nreturn 0;\r\nif (pevent == NULL) {\r\npr_debug("broken or missing trace data\n");\r\nreturn -1;\r\n}\r\nevent = pevent_find_event(pevent, evsel->attr.config);\r\nif (event == NULL)\r\nreturn -1;\r\nif (!evsel->name) {\r\nsnprintf(bf, sizeof(bf), "%s:%s", event->system, event->name);\r\nevsel->name = strdup(bf);\r\nif (evsel->name == NULL)\r\nreturn -1;\r\n}\r\nevsel->tp_format = event;\r\nreturn 0;\r\n}\r\nstatic int perf_evlist__prepare_tracepoint_events(struct perf_evlist *evlist,\r\nstruct pevent *pevent)\r\n{\r\nstruct perf_evsel *pos;\r\nevlist__for_each(evlist, pos) {\r\nif (pos->attr.type == PERF_TYPE_TRACEPOINT &&\r\nperf_evsel__prepare_tracepoint_event(pos, pevent))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint perf_session__read_header(struct perf_session *session)\r\n{\r\nstruct perf_data_file *file = session->file;\r\nstruct perf_header *header = &session->header;\r\nstruct perf_file_header f_header;\r\nstruct perf_file_attr f_attr;\r\nu64 f_id;\r\nint nr_attrs, nr_ids, i, j;\r\nint fd = perf_data_file__fd(file);\r\nsession->evlist = perf_evlist__new();\r\nif (session->evlist == NULL)\r\nreturn -ENOMEM;\r\nif (perf_data_file__is_pipe(file))\r\nreturn perf_header__read_pipe(session);\r\nif (perf_file_header__read(&f_header, header, fd) < 0)\r\nreturn -EINVAL;\r\nif (f_header.data.size == 0) {\r\npr_warning("WARNING: The %s file's data size field is 0 which is unexpected.\n"\r\n"Was the 'perf record' command properly terminated?\n",\r\nfile->path);\r\n}\r\nnr_attrs = f_header.attrs.size / f_header.attr_size;\r\nlseek(fd, f_header.attrs.offset, SEEK_SET);\r\nfor (i = 0; i < nr_attrs; i++) {\r\nstruct perf_evsel *evsel;\r\noff_t tmp;\r\nif (read_attr(fd, header, &f_attr) < 0)\r\ngoto out_errno;\r\nif (header->needs_swap)\r\nperf_event__attr_swap(&f_attr.attr);\r\ntmp = lseek(fd, 0, SEEK_CUR);\r\nevsel = perf_evsel__new(&f_attr.attr);\r\nif (evsel == NULL)\r\ngoto out_delete_evlist;\r\nevsel->needs_swap = header->needs_swap;\r\nperf_evlist__add(session->evlist, evsel);\r\nnr_ids = f_attr.ids.size / sizeof(u64);\r\nif (perf_evsel__alloc_id(evsel, 1, nr_ids))\r\ngoto out_delete_evlist;\r\nlseek(fd, f_attr.ids.offset, SEEK_SET);\r\nfor (j = 0; j < nr_ids; j++) {\r\nif (perf_header__getbuffer64(header, fd, &f_id, sizeof(f_id)))\r\ngoto out_errno;\r\nperf_evlist__id_add(session->evlist, evsel, 0, j, f_id);\r\n}\r\nlseek(fd, tmp, SEEK_SET);\r\n}\r\nsymbol_conf.nr_events = nr_attrs;\r\nperf_header__process_sections(header, fd, &session->tevent,\r\nperf_file_section__process);\r\nif (perf_evlist__prepare_tracepoint_events(session->evlist,\r\nsession->tevent.pevent))\r\ngoto out_delete_evlist;\r\nreturn 0;\r\nout_errno:\r\nreturn -errno;\r\nout_delete_evlist:\r\nperf_evlist__delete(session->evlist);\r\nsession->evlist = NULL;\r\nreturn -ENOMEM;\r\n}\r\nint perf_event__synthesize_attr(struct perf_tool *tool,\r\nstruct perf_event_attr *attr, u32 ids, u64 *id,\r\nperf_event__handler_t process)\r\n{\r\nunion perf_event *ev;\r\nsize_t size;\r\nint err;\r\nsize = sizeof(struct perf_event_attr);\r\nsize = PERF_ALIGN(size, sizeof(u64));\r\nsize += sizeof(struct perf_event_header);\r\nsize += ids * sizeof(u64);\r\nev = malloc(size);\r\nif (ev == NULL)\r\nreturn -ENOMEM;\r\nev->attr.attr = *attr;\r\nmemcpy(ev->attr.id, id, ids * sizeof(u64));\r\nev->attr.header.type = PERF_RECORD_HEADER_ATTR;\r\nev->attr.header.size = (u16)size;\r\nif (ev->attr.header.size == size)\r\nerr = process(tool, ev, NULL, NULL);\r\nelse\r\nerr = -E2BIG;\r\nfree(ev);\r\nreturn err;\r\n}\r\nint perf_event__synthesize_attrs(struct perf_tool *tool,\r\nstruct perf_session *session,\r\nperf_event__handler_t process)\r\n{\r\nstruct perf_evsel *evsel;\r\nint err = 0;\r\nevlist__for_each(session->evlist, evsel) {\r\nerr = perf_event__synthesize_attr(tool, &evsel->attr, evsel->ids,\r\nevsel->id, process);\r\nif (err) {\r\npr_debug("failed to create perf header attribute\n");\r\nreturn err;\r\n}\r\n}\r\nreturn err;\r\n}\r\nint perf_event__process_attr(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_evlist **pevlist)\r\n{\r\nu32 i, ids, n_ids;\r\nstruct perf_evsel *evsel;\r\nstruct perf_evlist *evlist = *pevlist;\r\nif (evlist == NULL) {\r\n*pevlist = evlist = perf_evlist__new();\r\nif (evlist == NULL)\r\nreturn -ENOMEM;\r\n}\r\nevsel = perf_evsel__new(&event->attr.attr);\r\nif (evsel == NULL)\r\nreturn -ENOMEM;\r\nperf_evlist__add(evlist, evsel);\r\nids = event->header.size;\r\nids -= (void *)&event->attr.id - (void *)event;\r\nn_ids = ids / sizeof(u64);\r\nif (perf_evsel__alloc_id(evsel, 1, n_ids))\r\nreturn -ENOMEM;\r\nfor (i = 0; i < n_ids; i++) {\r\nperf_evlist__id_add(evlist, evsel, 0, i, event->attr.id[i]);\r\n}\r\nsymbol_conf.nr_events = evlist->nr_entries;\r\nreturn 0;\r\n}\r\nint perf_event__synthesize_tracing_data(struct perf_tool *tool, int fd,\r\nstruct perf_evlist *evlist,\r\nperf_event__handler_t process)\r\n{\r\nunion perf_event ev;\r\nstruct tracing_data *tdata;\r\nssize_t size = 0, aligned_size = 0, padding;\r\nint err __maybe_unused = 0;\r\ntdata = tracing_data_get(&evlist->entries, fd, true);\r\nif (!tdata)\r\nreturn -1;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.tracing_data.header.type = PERF_RECORD_HEADER_TRACING_DATA;\r\nsize = tdata->size;\r\naligned_size = PERF_ALIGN(size, sizeof(u64));\r\npadding = aligned_size - size;\r\nev.tracing_data.header.size = sizeof(ev.tracing_data);\r\nev.tracing_data.size = aligned_size;\r\nprocess(tool, &ev, NULL, NULL);\r\ntracing_data_put(tdata);\r\nwrite_padded(fd, NULL, 0, padding);\r\nreturn aligned_size;\r\n}\r\nint perf_event__process_tracing_data(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_session *session)\r\n{\r\nssize_t size_read, padding, size = event->tracing_data.size;\r\nint fd = perf_data_file__fd(session->file);\r\noff_t offset = lseek(fd, 0, SEEK_CUR);\r\nchar buf[BUFSIZ];\r\nlseek(fd, offset + sizeof(struct tracing_data_event),\r\nSEEK_SET);\r\nsize_read = trace_report(fd, &session->tevent,\r\nsession->repipe);\r\npadding = PERF_ALIGN(size_read, sizeof(u64)) - size_read;\r\nif (readn(fd, buf, padding) < 0) {\r\npr_err("%s: reading input file", __func__);\r\nreturn -1;\r\n}\r\nif (session->repipe) {\r\nint retw = write(STDOUT_FILENO, buf, padding);\r\nif (retw <= 0 || retw != padding) {\r\npr_err("%s: repiping tracing data padding", __func__);\r\nreturn -1;\r\n}\r\n}\r\nif (size_read + padding != size) {\r\npr_err("%s: tracing data size mismatch", __func__);\r\nreturn -1;\r\n}\r\nperf_evlist__prepare_tracepoint_events(session->evlist,\r\nsession->tevent.pevent);\r\nreturn size_read + padding;\r\n}\r\nint perf_event__synthesize_build_id(struct perf_tool *tool,\r\nstruct dso *pos, u16 misc,\r\nperf_event__handler_t process,\r\nstruct machine *machine)\r\n{\r\nunion perf_event ev;\r\nsize_t len;\r\nint err = 0;\r\nif (!pos->hit)\r\nreturn err;\r\nmemset(&ev, 0, sizeof(ev));\r\nlen = pos->long_name_len + 1;\r\nlen = PERF_ALIGN(len, NAME_ALIGN);\r\nmemcpy(&ev.build_id.build_id, pos->build_id, sizeof(pos->build_id));\r\nev.build_id.header.type = PERF_RECORD_HEADER_BUILD_ID;\r\nev.build_id.header.misc = misc;\r\nev.build_id.pid = machine->pid;\r\nev.build_id.header.size = sizeof(ev.build_id) + len;\r\nmemcpy(&ev.build_id.filename, pos->long_name, pos->long_name_len);\r\nerr = process(tool, &ev, NULL, machine);\r\nreturn err;\r\n}\r\nint perf_event__process_build_id(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_session *session)\r\n{\r\n__event_process_build_id(&event->build_id,\r\nevent->build_id.filename,\r\nsession);\r\nreturn 0;\r\n}\r\nvoid disable_buildid_cache(void)\r\n{\r\nno_buildid_cache = true;\r\n}
