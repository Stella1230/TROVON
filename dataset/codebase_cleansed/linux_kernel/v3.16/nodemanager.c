struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\r\n{\r\nstruct o2nm_node *node = NULL;\r\nif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\r\ngoto out;\r\nread_lock(&o2nm_single_cluster->cl_nodes_lock);\r\nnode = o2nm_single_cluster->cl_nodes[node_num];\r\nif (node)\r\nconfig_item_get(&node->nd_item);\r\nread_unlock(&o2nm_single_cluster->cl_nodes_lock);\r\nout:\r\nreturn node;\r\n}\r\nint o2nm_configured_node_map(unsigned long *map, unsigned bytes)\r\n{\r\nstruct o2nm_cluster *cluster = o2nm_single_cluster;\r\nBUG_ON(bytes < (sizeof(cluster->cl_nodes_bitmap)));\r\nif (cluster == NULL)\r\nreturn -EINVAL;\r\nread_lock(&cluster->cl_nodes_lock);\r\nmemcpy(map, cluster->cl_nodes_bitmap, sizeof(cluster->cl_nodes_bitmap));\r\nread_unlock(&cluster->cl_nodes_lock);\r\nreturn 0;\r\n}\r\nstatic struct o2nm_node *o2nm_node_ip_tree_lookup(struct o2nm_cluster *cluster,\r\n__be32 ip_needle,\r\nstruct rb_node ***ret_p,\r\nstruct rb_node **ret_parent)\r\n{\r\nstruct rb_node **p = &cluster->cl_node_ip_tree.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct o2nm_node *node, *ret = NULL;\r\nwhile (*p) {\r\nint cmp;\r\nparent = *p;\r\nnode = rb_entry(parent, struct o2nm_node, nd_ip_node);\r\ncmp = memcmp(&ip_needle, &node->nd_ipv4_address,\r\nsizeof(ip_needle));\r\nif (cmp < 0)\r\np = &(*p)->rb_left;\r\nelse if (cmp > 0)\r\np = &(*p)->rb_right;\r\nelse {\r\nret = node;\r\nbreak;\r\n}\r\n}\r\nif (ret_p != NULL)\r\n*ret_p = p;\r\nif (ret_parent != NULL)\r\n*ret_parent = parent;\r\nreturn ret;\r\n}\r\nstruct o2nm_node *o2nm_get_node_by_ip(__be32 addr)\r\n{\r\nstruct o2nm_node *node = NULL;\r\nstruct o2nm_cluster *cluster = o2nm_single_cluster;\r\nif (cluster == NULL)\r\ngoto out;\r\nread_lock(&cluster->cl_nodes_lock);\r\nnode = o2nm_node_ip_tree_lookup(cluster, addr, NULL, NULL);\r\nif (node)\r\nconfig_item_get(&node->nd_item);\r\nread_unlock(&cluster->cl_nodes_lock);\r\nout:\r\nreturn node;\r\n}\r\nvoid o2nm_node_put(struct o2nm_node *node)\r\n{\r\nconfig_item_put(&node->nd_item);\r\n}\r\nvoid o2nm_node_get(struct o2nm_node *node)\r\n{\r\nconfig_item_get(&node->nd_item);\r\n}\r\nu8 o2nm_this_node(void)\r\n{\r\nu8 node_num = O2NM_MAX_NODES;\r\nif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\r\nnode_num = o2nm_single_cluster->cl_local_node;\r\nreturn node_num;\r\n}\r\nstatic struct o2nm_cluster *to_o2nm_cluster(struct config_item *item)\r\n{\r\nreturn item ?\r\ncontainer_of(to_config_group(item), struct o2nm_cluster,\r\ncl_group)\r\n: NULL;\r\n}\r\nstatic struct o2nm_node *to_o2nm_node(struct config_item *item)\r\n{\r\nreturn item ? container_of(item, struct o2nm_node, nd_item) : NULL;\r\n}\r\nstatic void o2nm_node_release(struct config_item *item)\r\n{\r\nstruct o2nm_node *node = to_o2nm_node(item);\r\nkfree(node);\r\n}\r\nstatic ssize_t o2nm_node_num_read(struct o2nm_node *node, char *page)\r\n{\r\nreturn sprintf(page, "%d\n", node->nd_num);\r\n}\r\nstatic struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\r\n{\r\nreturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\r\n}\r\nstatic ssize_t o2nm_node_num_write(struct o2nm_node *node, const char *page,\r\nsize_t count)\r\n{\r\nstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\r\nunsigned long tmp;\r\nchar *p = (char *)page;\r\ntmp = simple_strtoul(p, &p, 0);\r\nif (!p || (*p && (*p != '\n')))\r\nreturn -EINVAL;\r\nif (tmp >= O2NM_MAX_NODES)\r\nreturn -ERANGE;\r\nif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\r\n!test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\r\nreturn -EINVAL;\r\nwrite_lock(&cluster->cl_nodes_lock);\r\nif (cluster->cl_nodes[tmp])\r\np = NULL;\r\nelse {\r\ncluster->cl_nodes[tmp] = node;\r\nnode->nd_num = tmp;\r\nset_bit(tmp, cluster->cl_nodes_bitmap);\r\n}\r\nwrite_unlock(&cluster->cl_nodes_lock);\r\nif (p == NULL)\r\nreturn -EEXIST;\r\nreturn count;\r\n}\r\nstatic ssize_t o2nm_node_ipv4_port_read(struct o2nm_node *node, char *page)\r\n{\r\nreturn sprintf(page, "%u\n", ntohs(node->nd_ipv4_port));\r\n}\r\nstatic ssize_t o2nm_node_ipv4_port_write(struct o2nm_node *node,\r\nconst char *page, size_t count)\r\n{\r\nunsigned long tmp;\r\nchar *p = (char *)page;\r\ntmp = simple_strtoul(p, &p, 0);\r\nif (!p || (*p && (*p != '\n')))\r\nreturn -EINVAL;\r\nif (tmp == 0)\r\nreturn -EINVAL;\r\nif (tmp >= (u16)-1)\r\nreturn -ERANGE;\r\nnode->nd_ipv4_port = htons(tmp);\r\nreturn count;\r\n}\r\nstatic ssize_t o2nm_node_ipv4_address_read(struct o2nm_node *node, char *page)\r\n{\r\nreturn sprintf(page, "%pI4\n", &node->nd_ipv4_address);\r\n}\r\nstatic ssize_t o2nm_node_ipv4_address_write(struct o2nm_node *node,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\r\nint ret, i;\r\nstruct rb_node **p, *parent;\r\nunsigned int octets[4];\r\n__be32 ipv4_addr = 0;\r\nret = sscanf(page, "%3u.%3u.%3u.%3u", &octets[3], &octets[2],\r\n&octets[1], &octets[0]);\r\nif (ret != 4)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(octets); i++) {\r\nif (octets[i] > 255)\r\nreturn -ERANGE;\r\nbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\r\n}\r\nret = 0;\r\nwrite_lock(&cluster->cl_nodes_lock);\r\nif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\r\nret = -EEXIST;\r\nelse {\r\nrb_link_node(&node->nd_ip_node, parent, p);\r\nrb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\r\n}\r\nwrite_unlock(&cluster->cl_nodes_lock);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\r\nreturn count;\r\n}\r\nstatic ssize_t o2nm_node_local_read(struct o2nm_node *node, char *page)\r\n{\r\nreturn sprintf(page, "%d\n", node->nd_local);\r\n}\r\nstatic ssize_t o2nm_node_local_write(struct o2nm_node *node, const char *page,\r\nsize_t count)\r\n{\r\nstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\r\nunsigned long tmp;\r\nchar *p = (char *)page;\r\nssize_t ret;\r\ntmp = simple_strtoul(p, &p, 0);\r\nif (!p || (*p && (*p != '\n')))\r\nreturn -EINVAL;\r\ntmp = !!tmp;\r\nif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\r\n!test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\r\n!test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\r\nreturn -EINVAL;\r\nif (tmp && tmp == cluster->cl_has_local &&\r\ncluster->cl_local_node != node->nd_num)\r\nreturn -EBUSY;\r\nif (tmp && !cluster->cl_has_local) {\r\nret = o2net_start_listening(node);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!tmp && cluster->cl_has_local &&\r\ncluster->cl_local_node == node->nd_num) {\r\no2net_stop_listening(node);\r\ncluster->cl_local_node = O2NM_INVALID_NODE_NUM;\r\n}\r\nnode->nd_local = tmp;\r\nif (node->nd_local) {\r\ncluster->cl_has_local = tmp;\r\ncluster->cl_local_node = node->nd_num;\r\n}\r\nreturn count;\r\n}\r\nstatic int o2nm_attr_index(struct configfs_attribute *attr)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(o2nm_node_attrs); i++) {\r\nif (attr == o2nm_node_attrs[i])\r\nreturn i;\r\n}\r\nBUG();\r\nreturn 0;\r\n}\r\nstatic ssize_t o2nm_node_show(struct config_item *item,\r\nstruct configfs_attribute *attr,\r\nchar *page)\r\n{\r\nstruct o2nm_node *node = to_o2nm_node(item);\r\nstruct o2nm_node_attribute *o2nm_node_attr =\r\ncontainer_of(attr, struct o2nm_node_attribute, attr);\r\nssize_t ret = 0;\r\nif (o2nm_node_attr->show)\r\nret = o2nm_node_attr->show(node, page);\r\nreturn ret;\r\n}\r\nstatic ssize_t o2nm_node_store(struct config_item *item,\r\nstruct configfs_attribute *attr,\r\nconst char *page, size_t count)\r\n{\r\nstruct o2nm_node *node = to_o2nm_node(item);\r\nstruct o2nm_node_attribute *o2nm_node_attr =\r\ncontainer_of(attr, struct o2nm_node_attribute, attr);\r\nssize_t ret;\r\nint attr_index = o2nm_attr_index(attr);\r\nif (o2nm_node_attr->store == NULL) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (test_bit(attr_index, &node->nd_set_attributes))\r\nreturn -EBUSY;\r\nret = o2nm_node_attr->store(node, page, count);\r\nif (ret < count)\r\ngoto out;\r\nset_bit(attr_index, &node->nd_set_attributes);\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t o2nm_cluster_attr_write(const char *page, ssize_t count,\r\nunsigned int *val)\r\n{\r\nunsigned long tmp;\r\nchar *p = (char *)page;\r\ntmp = simple_strtoul(p, &p, 0);\r\nif (!p || (*p && (*p != '\n')))\r\nreturn -EINVAL;\r\nif (tmp == 0)\r\nreturn -EINVAL;\r\nif (tmp >= (u32)-1)\r\nreturn -ERANGE;\r\n*val = tmp;\r\nreturn count;\r\n}\r\nstatic ssize_t o2nm_cluster_attr_idle_timeout_ms_read(\r\nstruct o2nm_cluster *cluster, char *page)\r\n{\r\nreturn sprintf(page, "%u\n", cluster->cl_idle_timeout_ms);\r\n}\r\nstatic ssize_t o2nm_cluster_attr_idle_timeout_ms_write(\r\nstruct o2nm_cluster *cluster, const char *page, size_t count)\r\n{\r\nssize_t ret;\r\nunsigned int val;\r\nret = o2nm_cluster_attr_write(page, count, &val);\r\nif (ret > 0) {\r\nif (cluster->cl_idle_timeout_ms != val\r\n&& o2net_num_connected_peers()) {\r\nmlog(ML_NOTICE,\r\n"o2net: cannot change idle timeout after "\r\n"the first peer has agreed to it."\r\n" %d connected peers\n",\r\no2net_num_connected_peers());\r\nret = -EINVAL;\r\n} else if (val <= cluster->cl_keepalive_delay_ms) {\r\nmlog(ML_NOTICE, "o2net: idle timeout must be larger "\r\n"than keepalive delay\n");\r\nret = -EINVAL;\r\n} else {\r\ncluster->cl_idle_timeout_ms = val;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t o2nm_cluster_attr_keepalive_delay_ms_read(\r\nstruct o2nm_cluster *cluster, char *page)\r\n{\r\nreturn sprintf(page, "%u\n", cluster->cl_keepalive_delay_ms);\r\n}\r\nstatic ssize_t o2nm_cluster_attr_keepalive_delay_ms_write(\r\nstruct o2nm_cluster *cluster, const char *page, size_t count)\r\n{\r\nssize_t ret;\r\nunsigned int val;\r\nret = o2nm_cluster_attr_write(page, count, &val);\r\nif (ret > 0) {\r\nif (cluster->cl_keepalive_delay_ms != val\r\n&& o2net_num_connected_peers()) {\r\nmlog(ML_NOTICE,\r\n"o2net: cannot change keepalive delay after"\r\n" the first peer has agreed to it."\r\n" %d connected peers\n",\r\no2net_num_connected_peers());\r\nret = -EINVAL;\r\n} else if (val >= cluster->cl_idle_timeout_ms) {\r\nmlog(ML_NOTICE, "o2net: keepalive delay must be "\r\n"smaller than idle timeout\n");\r\nret = -EINVAL;\r\n} else {\r\ncluster->cl_keepalive_delay_ms = val;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t o2nm_cluster_attr_reconnect_delay_ms_read(\r\nstruct o2nm_cluster *cluster, char *page)\r\n{\r\nreturn sprintf(page, "%u\n", cluster->cl_reconnect_delay_ms);\r\n}\r\nstatic ssize_t o2nm_cluster_attr_reconnect_delay_ms_write(\r\nstruct o2nm_cluster *cluster, const char *page, size_t count)\r\n{\r\nreturn o2nm_cluster_attr_write(page, count,\r\n&cluster->cl_reconnect_delay_ms);\r\n}\r\nstatic ssize_t o2nm_cluster_attr_fence_method_read(\r\nstruct o2nm_cluster *cluster, char *page)\r\n{\r\nssize_t ret = 0;\r\nif (cluster)\r\nret = sprintf(page, "%s\n",\r\no2nm_fence_method_desc[cluster->cl_fence_method]);\r\nreturn ret;\r\n}\r\nstatic ssize_t o2nm_cluster_attr_fence_method_write(\r\nstruct o2nm_cluster *cluster, const char *page, size_t count)\r\n{\r\nunsigned int i;\r\nif (page[count - 1] != '\n')\r\ngoto bail;\r\nfor (i = 0; i < O2NM_FENCE_METHODS; ++i) {\r\nif (count != strlen(o2nm_fence_method_desc[i]) + 1)\r\ncontinue;\r\nif (strncasecmp(page, o2nm_fence_method_desc[i], count - 1))\r\ncontinue;\r\nif (cluster->cl_fence_method != i) {\r\nprintk(KERN_INFO "ocfs2: Changing fence method to %s\n",\r\no2nm_fence_method_desc[i]);\r\ncluster->cl_fence_method = i;\r\n}\r\nreturn count;\r\n}\r\nbail:\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t o2nm_cluster_show(struct config_item *item,\r\nstruct configfs_attribute *attr,\r\nchar *page)\r\n{\r\nstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\r\nstruct o2nm_cluster_attribute *o2nm_cluster_attr =\r\ncontainer_of(attr, struct o2nm_cluster_attribute, attr);\r\nssize_t ret = 0;\r\nif (o2nm_cluster_attr->show)\r\nret = o2nm_cluster_attr->show(cluster, page);\r\nreturn ret;\r\n}\r\nstatic ssize_t o2nm_cluster_store(struct config_item *item,\r\nstruct configfs_attribute *attr,\r\nconst char *page, size_t count)\r\n{\r\nstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\r\nstruct o2nm_cluster_attribute *o2nm_cluster_attr =\r\ncontainer_of(attr, struct o2nm_cluster_attribute, attr);\r\nssize_t ret;\r\nif (o2nm_cluster_attr->store == NULL) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = o2nm_cluster_attr->store(cluster, page, count);\r\nif (ret < count)\r\ngoto out;\r\nout:\r\nreturn ret;\r\n}\r\nstatic struct config_item *o2nm_node_group_make_item(struct config_group *group,\r\nconst char *name)\r\n{\r\nstruct o2nm_node *node = NULL;\r\nif (strlen(name) > O2NM_MAX_NAME_LEN)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nnode = kzalloc(sizeof(struct o2nm_node), GFP_KERNEL);\r\nif (node == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nstrcpy(node->nd_name, name);\r\nconfig_item_init_type_name(&node->nd_item, name, &o2nm_node_type);\r\nspin_lock_init(&node->nd_lock);\r\nmlog(ML_CLUSTER, "o2nm: Registering node %s\n", name);\r\nreturn &node->nd_item;\r\n}\r\nstatic void o2nm_node_group_drop_item(struct config_group *group,\r\nstruct config_item *item)\r\n{\r\nstruct o2nm_node *node = to_o2nm_node(item);\r\nstruct o2nm_cluster *cluster = to_o2nm_cluster(group->cg_item.ci_parent);\r\no2net_disconnect_node(node);\r\nif (cluster->cl_has_local &&\r\n(cluster->cl_local_node == node->nd_num)) {\r\ncluster->cl_has_local = 0;\r\ncluster->cl_local_node = O2NM_INVALID_NODE_NUM;\r\no2net_stop_listening(node);\r\n}\r\nwrite_lock(&cluster->cl_nodes_lock);\r\nif (node->nd_ipv4_address)\r\nrb_erase(&node->nd_ip_node, &cluster->cl_node_ip_tree);\r\nif (cluster->cl_nodes[node->nd_num] == node) {\r\ncluster->cl_nodes[node->nd_num] = NULL;\r\nclear_bit(node->nd_num, cluster->cl_nodes_bitmap);\r\n}\r\nwrite_unlock(&cluster->cl_nodes_lock);\r\nmlog(ML_CLUSTER, "o2nm: Unregistered node %s\n",\r\nconfig_item_name(&node->nd_item));\r\nconfig_item_put(item);\r\n}\r\nstatic void o2nm_cluster_release(struct config_item *item)\r\n{\r\nstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\r\nkfree(cluster->cl_group.default_groups);\r\nkfree(cluster);\r\n}\r\nstatic struct config_group *o2nm_cluster_group_make_group(struct config_group *group,\r\nconst char *name)\r\n{\r\nstruct o2nm_cluster *cluster = NULL;\r\nstruct o2nm_node_group *ns = NULL;\r\nstruct config_group *o2hb_group = NULL, *ret = NULL;\r\nvoid *defs = NULL;\r\nif (o2nm_single_cluster)\r\nreturn ERR_PTR(-ENOSPC);\r\ncluster = kzalloc(sizeof(struct o2nm_cluster), GFP_KERNEL);\r\nns = kzalloc(sizeof(struct o2nm_node_group), GFP_KERNEL);\r\ndefs = kcalloc(3, sizeof(struct config_group *), GFP_KERNEL);\r\no2hb_group = o2hb_alloc_hb_set();\r\nif (cluster == NULL || ns == NULL || o2hb_group == NULL || defs == NULL)\r\ngoto out;\r\nconfig_group_init_type_name(&cluster->cl_group, name,\r\n&o2nm_cluster_type);\r\nconfig_group_init_type_name(&ns->ns_group, "node",\r\n&o2nm_node_group_type);\r\ncluster->cl_group.default_groups = defs;\r\ncluster->cl_group.default_groups[0] = &ns->ns_group;\r\ncluster->cl_group.default_groups[1] = o2hb_group;\r\ncluster->cl_group.default_groups[2] = NULL;\r\nrwlock_init(&cluster->cl_nodes_lock);\r\ncluster->cl_node_ip_tree = RB_ROOT;\r\ncluster->cl_reconnect_delay_ms = O2NET_RECONNECT_DELAY_MS_DEFAULT;\r\ncluster->cl_idle_timeout_ms = O2NET_IDLE_TIMEOUT_MS_DEFAULT;\r\ncluster->cl_keepalive_delay_ms = O2NET_KEEPALIVE_DELAY_MS_DEFAULT;\r\ncluster->cl_fence_method = O2NM_FENCE_RESET;\r\nret = &cluster->cl_group;\r\no2nm_single_cluster = cluster;\r\nout:\r\nif (ret == NULL) {\r\nkfree(cluster);\r\nkfree(ns);\r\no2hb_free_hb_set(o2hb_group);\r\nkfree(defs);\r\nret = ERR_PTR(-ENOMEM);\r\n}\r\nreturn ret;\r\n}\r\nstatic void o2nm_cluster_group_drop_item(struct config_group *group, struct config_item *item)\r\n{\r\nstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\r\nint i;\r\nstruct config_item *killme;\r\nBUG_ON(o2nm_single_cluster != cluster);\r\no2nm_single_cluster = NULL;\r\nfor (i = 0; cluster->cl_group.default_groups[i]; i++) {\r\nkillme = &cluster->cl_group.default_groups[i]->cg_item;\r\ncluster->cl_group.default_groups[i] = NULL;\r\nconfig_item_put(killme);\r\n}\r\nconfig_item_put(item);\r\n}\r\nint o2nm_depend_item(struct config_item *item)\r\n{\r\nreturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);\r\n}\r\nvoid o2nm_undepend_item(struct config_item *item)\r\n{\r\nconfigfs_undepend_item(&o2nm_cluster_group.cs_subsys, item);\r\n}\r\nint o2nm_depend_this_node(void)\r\n{\r\nint ret = 0;\r\nstruct o2nm_node *local_node;\r\nlocal_node = o2nm_get_node_by_num(o2nm_this_node());\r\nif (!local_node) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = o2nm_depend_item(&local_node->nd_item);\r\no2nm_node_put(local_node);\r\nout:\r\nreturn ret;\r\n}\r\nvoid o2nm_undepend_this_node(void)\r\n{\r\nstruct o2nm_node *local_node;\r\nlocal_node = o2nm_get_node_by_num(o2nm_this_node());\r\nBUG_ON(!local_node);\r\no2nm_undepend_item(&local_node->nd_item);\r\no2nm_node_put(local_node);\r\n}\r\nstatic void __exit exit_o2nm(void)\r\n{\r\no2net_unregister_hb_callbacks();\r\nconfigfs_unregister_subsystem(&o2nm_cluster_group.cs_subsys);\r\no2cb_sys_shutdown();\r\no2net_exit();\r\no2hb_exit();\r\n}\r\nstatic int __init init_o2nm(void)\r\n{\r\nint ret = -1;\r\nret = o2hb_init();\r\nif (ret)\r\ngoto out;\r\nret = o2net_init();\r\nif (ret)\r\ngoto out_o2hb;\r\nret = o2net_register_hb_callbacks();\r\nif (ret)\r\ngoto out_o2net;\r\nconfig_group_init(&o2nm_cluster_group.cs_subsys.su_group);\r\nmutex_init(&o2nm_cluster_group.cs_subsys.su_mutex);\r\nret = configfs_register_subsystem(&o2nm_cluster_group.cs_subsys);\r\nif (ret) {\r\nprintk(KERN_ERR "nodemanager: Registration returned %d\n", ret);\r\ngoto out_callbacks;\r\n}\r\nret = o2cb_sys_init();\r\nif (!ret)\r\ngoto out;\r\nconfigfs_unregister_subsystem(&o2nm_cluster_group.cs_subsys);\r\nout_callbacks:\r\no2net_unregister_hb_callbacks();\r\nout_o2net:\r\no2net_exit();\r\nout_o2hb:\r\no2hb_exit();\r\nout:\r\nreturn ret;\r\n}
