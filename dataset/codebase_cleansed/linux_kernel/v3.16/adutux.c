static inline void adu_debug_data(struct device *dev, const char *function,\r\nint size, const unsigned char *data)\r\n{\r\ndev_dbg(dev, "%s - length = %d, data = %*ph\n",\r\nfunction, size, size, data);\r\n}\r\nstatic void adu_abort_transfers(struct adu_device *dev)\r\n{\r\nunsigned long flags;\r\nif (dev->udev == NULL)\r\nreturn;\r\nspin_lock_irqsave(&dev->buflock, flags);\r\nif (!dev->read_urb_finished) {\r\nspin_unlock_irqrestore(&dev->buflock, flags);\r\nusb_kill_urb(dev->interrupt_in_urb);\r\n} else\r\nspin_unlock_irqrestore(&dev->buflock, flags);\r\nspin_lock_irqsave(&dev->buflock, flags);\r\nif (!dev->out_urb_finished) {\r\nspin_unlock_irqrestore(&dev->buflock, flags);\r\nusb_kill_urb(dev->interrupt_out_urb);\r\n} else\r\nspin_unlock_irqrestore(&dev->buflock, flags);\r\n}\r\nstatic void adu_delete(struct adu_device *dev)\r\n{\r\nusb_free_urb(dev->interrupt_in_urb);\r\nusb_free_urb(dev->interrupt_out_urb);\r\nkfree(dev->read_buffer_primary);\r\nkfree(dev->read_buffer_secondary);\r\nkfree(dev->interrupt_in_buffer);\r\nkfree(dev->interrupt_out_buffer);\r\nkfree(dev);\r\n}\r\nstatic void adu_interrupt_in_callback(struct urb *urb)\r\n{\r\nstruct adu_device *dev = urb->context;\r\nint status = urb->status;\r\nadu_debug_data(&dev->udev->dev, __func__,\r\nurb->actual_length, urb->transfer_buffer);\r\nspin_lock(&dev->buflock);\r\nif (status != 0) {\r\nif ((status != -ENOENT) && (status != -ECONNRESET) &&\r\n(status != -ESHUTDOWN)) {\r\ndev_dbg(&dev->udev->dev,\r\n"%s : nonzero status received: %d\n",\r\n__func__, status);\r\n}\r\ngoto exit;\r\n}\r\nif (urb->actual_length > 0 && dev->interrupt_in_buffer[0] != 0x00) {\r\nif (dev->read_buffer_length <\r\n(4 * usb_endpoint_maxp(dev->interrupt_in_endpoint)) -\r\n(urb->actual_length)) {\r\nmemcpy (dev->read_buffer_primary +\r\ndev->read_buffer_length,\r\ndev->interrupt_in_buffer, urb->actual_length);\r\ndev->read_buffer_length += urb->actual_length;\r\ndev_dbg(&dev->udev->dev,"%s reading %d\n", __func__,\r\nurb->actual_length);\r\n} else {\r\ndev_dbg(&dev->udev->dev,"%s : read_buffer overflow\n",\r\n__func__);\r\n}\r\n}\r\nexit:\r\ndev->read_urb_finished = 1;\r\nspin_unlock(&dev->buflock);\r\nwake_up_interruptible(&dev->read_wait);\r\n}\r\nstatic void adu_interrupt_out_callback(struct urb *urb)\r\n{\r\nstruct adu_device *dev = urb->context;\r\nint status = urb->status;\r\nadu_debug_data(&dev->udev->dev, __func__,\r\nurb->actual_length, urb->transfer_buffer);\r\nif (status != 0) {\r\nif ((status != -ENOENT) &&\r\n(status != -ECONNRESET)) {\r\ndev_dbg(&dev->udev->dev,\r\n"%s :nonzero status received: %d\n", __func__,\r\nstatus);\r\n}\r\nreturn;\r\n}\r\nspin_lock(&dev->buflock);\r\ndev->out_urb_finished = 1;\r\nwake_up(&dev->write_wait);\r\nspin_unlock(&dev->buflock);\r\n}\r\nstatic int adu_open(struct inode *inode, struct file *file)\r\n{\r\nstruct adu_device *dev = NULL;\r\nstruct usb_interface *interface;\r\nint subminor;\r\nint retval;\r\nsubminor = iminor(inode);\r\nretval = mutex_lock_interruptible(&adutux_mutex);\r\nif (retval)\r\ngoto exit_no_lock;\r\ninterface = usb_find_interface(&adu_driver, subminor);\r\nif (!interface) {\r\npr_err("%s - error, can't find device for minor %d\n",\r\n__func__, subminor);\r\nretval = -ENODEV;\r\ngoto exit_no_device;\r\n}\r\ndev = usb_get_intfdata(interface);\r\nif (!dev || !dev->udev) {\r\nretval = -ENODEV;\r\ngoto exit_no_device;\r\n}\r\nif (dev->open_count) {\r\nretval = -EBUSY;\r\ngoto exit_no_device;\r\n}\r\n++dev->open_count;\r\ndev_dbg(&dev->udev->dev, "%s: open count %d\n", __func__,\r\ndev->open_count);\r\nfile->private_data = dev;\r\ndev->read_buffer_length = 0;\r\nusb_fill_int_urb(dev->interrupt_in_urb, dev->udev,\r\nusb_rcvintpipe(dev->udev,\r\ndev->interrupt_in_endpoint->bEndpointAddress),\r\ndev->interrupt_in_buffer,\r\nusb_endpoint_maxp(dev->interrupt_in_endpoint),\r\nadu_interrupt_in_callback, dev,\r\ndev->interrupt_in_endpoint->bInterval);\r\ndev->read_urb_finished = 0;\r\nif (usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL))\r\ndev->read_urb_finished = 1;\r\ndev->out_urb_finished = 1;\r\nretval = 0;\r\nexit_no_device:\r\nmutex_unlock(&adutux_mutex);\r\nexit_no_lock:\r\nreturn retval;\r\n}\r\nstatic void adu_release_internal(struct adu_device *dev)\r\n{\r\n--dev->open_count;\r\ndev_dbg(&dev->udev->dev, "%s : open count %d\n", __func__,\r\ndev->open_count);\r\nif (dev->open_count <= 0) {\r\nadu_abort_transfers(dev);\r\ndev->open_count = 0;\r\n}\r\n}\r\nstatic int adu_release(struct inode *inode, struct file *file)\r\n{\r\nstruct adu_device *dev;\r\nint retval = 0;\r\nif (file == NULL) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\ndev = file->private_data;\r\nif (dev == NULL) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nmutex_lock(&adutux_mutex);\r\nif (dev->open_count <= 0) {\r\ndev_dbg(&dev->udev->dev, "%s : device not opened\n", __func__);\r\nretval = -ENODEV;\r\ngoto unlock;\r\n}\r\nadu_release_internal(dev);\r\nif (dev->udev == NULL) {\r\nif (!dev->open_count)\r\nadu_delete(dev);\r\n}\r\nunlock:\r\nmutex_unlock(&adutux_mutex);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic ssize_t adu_read(struct file *file, __user char *buffer, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct adu_device *dev;\r\nsize_t bytes_read = 0;\r\nsize_t bytes_to_read = count;\r\nint i;\r\nint retval = 0;\r\nint timeout = 0;\r\nint should_submit = 0;\r\nunsigned long flags;\r\nDECLARE_WAITQUEUE(wait, current);\r\ndev = file->private_data;\r\nif (mutex_lock_interruptible(&dev->mtx))\r\nreturn -ERESTARTSYS;\r\nif (dev->udev == NULL) {\r\nretval = -ENODEV;\r\npr_err("No device or device unplugged %d\n", retval);\r\ngoto exit;\r\n}\r\nif (count == 0) {\r\ndev_dbg(&dev->udev->dev, "%s : read request of 0 bytes\n",\r\n__func__);\r\ngoto exit;\r\n}\r\ntimeout = COMMAND_TIMEOUT;\r\ndev_dbg(&dev->udev->dev, "%s : about to start looping\n", __func__);\r\nwhile (bytes_to_read) {\r\nint data_in_secondary = dev->secondary_tail - dev->secondary_head;\r\ndev_dbg(&dev->udev->dev,\r\n"%s : while, data_in_secondary=%d, status=%d\n",\r\n__func__, data_in_secondary,\r\ndev->interrupt_in_urb->status);\r\nif (data_in_secondary) {\r\nint amount = bytes_to_read < data_in_secondary ? bytes_to_read : data_in_secondary;\r\ni = copy_to_user(buffer, dev->read_buffer_secondary+dev->secondary_head, amount);\r\nif (i) {\r\nretval = -EFAULT;\r\ngoto exit;\r\n}\r\ndev->secondary_head += (amount - i);\r\nbytes_read += (amount - i);\r\nbytes_to_read -= (amount - i);\r\nif (i) {\r\nretval = bytes_read ? bytes_read : -EFAULT;\r\ngoto exit;\r\n}\r\n} else {\r\nspin_lock_irqsave (&dev->buflock, flags);\r\nif (dev->read_buffer_length) {\r\nchar *tmp;\r\ndev_dbg(&dev->udev->dev,\r\n"%s : swap, read_buffer_length = %d\n",\r\n__func__, dev->read_buffer_length);\r\ntmp = dev->read_buffer_secondary;\r\ndev->read_buffer_secondary = dev->read_buffer_primary;\r\ndev->read_buffer_primary = tmp;\r\ndev->secondary_head = 0;\r\ndev->secondary_tail = dev->read_buffer_length;\r\ndev->read_buffer_length = 0;\r\nspin_unlock_irqrestore(&dev->buflock, flags);\r\nshould_submit = 1;\r\n} else {\r\nif (!dev->read_urb_finished) {\r\nspin_unlock_irqrestore(&dev->buflock, flags);\r\ndev_dbg(&dev->udev->dev,\r\n"%s : submitted already\n",\r\n__func__);\r\n} else {\r\ndev_dbg(&dev->udev->dev,\r\n"%s : initiate input\n",\r\n__func__);\r\ndev->read_urb_finished = 0;\r\nspin_unlock_irqrestore(&dev->buflock, flags);\r\nusb_fill_int_urb(dev->interrupt_in_urb, dev->udev,\r\nusb_rcvintpipe(dev->udev,\r\ndev->interrupt_in_endpoint->bEndpointAddress),\r\ndev->interrupt_in_buffer,\r\nusb_endpoint_maxp(dev->interrupt_in_endpoint),\r\nadu_interrupt_in_callback,\r\ndev,\r\ndev->interrupt_in_endpoint->bInterval);\r\nretval = usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev->read_urb_finished = 1;\r\nif (retval == -ENOMEM) {\r\nretval = bytes_read ? bytes_read : -ENOMEM;\r\n}\r\ndev_dbg(&dev->udev->dev,\r\n"%s : submit failed\n",\r\n__func__);\r\ngoto exit;\r\n}\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(&dev->read_wait, &wait);\r\nspin_lock_irqsave(&dev->buflock, flags);\r\nif (!dev->read_urb_finished) {\r\nspin_unlock_irqrestore(&dev->buflock, flags);\r\ntimeout = schedule_timeout(COMMAND_TIMEOUT);\r\n} else {\r\nspin_unlock_irqrestore(&dev->buflock, flags);\r\nset_current_state(TASK_RUNNING);\r\n}\r\nremove_wait_queue(&dev->read_wait, &wait);\r\nif (timeout <= 0) {\r\ndev_dbg(&dev->udev->dev,\r\n"%s : timeout\n", __func__);\r\nretval = bytes_read ? bytes_read : -ETIMEDOUT;\r\ngoto exit;\r\n}\r\nif (signal_pending(current)) {\r\ndev_dbg(&dev->udev->dev,\r\n"%s : signal pending\n",\r\n__func__);\r\nretval = bytes_read ? bytes_read : -EINTR;\r\ngoto exit;\r\n}\r\n}\r\n}\r\n}\r\nretval = bytes_read;\r\nspin_lock_irqsave(&dev->buflock, flags);\r\nif (should_submit && dev->read_urb_finished) {\r\ndev->read_urb_finished = 0;\r\nspin_unlock_irqrestore(&dev->buflock, flags);\r\nusb_fill_int_urb(dev->interrupt_in_urb, dev->udev,\r\nusb_rcvintpipe(dev->udev,\r\ndev->interrupt_in_endpoint->bEndpointAddress),\r\ndev->interrupt_in_buffer,\r\nusb_endpoint_maxp(dev->interrupt_in_endpoint),\r\nadu_interrupt_in_callback,\r\ndev,\r\ndev->interrupt_in_endpoint->bInterval);\r\nif (usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL) != 0)\r\ndev->read_urb_finished = 1;\r\n} else {\r\nspin_unlock_irqrestore(&dev->buflock, flags);\r\n}\r\nexit:\r\nmutex_unlock(&dev->mtx);\r\nreturn retval;\r\n}\r\nstatic ssize_t adu_write(struct file *file, const __user char *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nDECLARE_WAITQUEUE(waita, current);\r\nstruct adu_device *dev;\r\nsize_t bytes_written = 0;\r\nsize_t bytes_to_write;\r\nsize_t buffer_size;\r\nunsigned long flags;\r\nint retval;\r\ndev = file->private_data;\r\nretval = mutex_lock_interruptible(&dev->mtx);\r\nif (retval)\r\ngoto exit_nolock;\r\nif (dev->udev == NULL) {\r\nretval = -ENODEV;\r\npr_err("No device or device unplugged %d\n", retval);\r\ngoto exit;\r\n}\r\nif (count == 0) {\r\ndev_dbg(&dev->udev->dev, "%s : write request of 0 bytes\n",\r\n__func__);\r\ngoto exit;\r\n}\r\nwhile (count > 0) {\r\nadd_wait_queue(&dev->write_wait, &waita);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_lock_irqsave(&dev->buflock, flags);\r\nif (!dev->out_urb_finished) {\r\nspin_unlock_irqrestore(&dev->buflock, flags);\r\nmutex_unlock(&dev->mtx);\r\nif (signal_pending(current)) {\r\ndev_dbg(&dev->udev->dev, "%s : interrupted\n",\r\n__func__);\r\nset_current_state(TASK_RUNNING);\r\nretval = -EINTR;\r\ngoto exit_onqueue;\r\n}\r\nif (schedule_timeout(COMMAND_TIMEOUT) == 0) {\r\ndev_dbg(&dev->udev->dev,\r\n"%s - command timed out.\n", __func__);\r\nretval = -ETIMEDOUT;\r\ngoto exit_onqueue;\r\n}\r\nremove_wait_queue(&dev->write_wait, &waita);\r\nretval = mutex_lock_interruptible(&dev->mtx);\r\nif (retval) {\r\nretval = bytes_written ? bytes_written : retval;\r\ngoto exit_nolock;\r\n}\r\ndev_dbg(&dev->udev->dev,\r\n"%s : in progress, count = %Zd\n",\r\n__func__, count);\r\n} else {\r\nspin_unlock_irqrestore(&dev->buflock, flags);\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&dev->write_wait, &waita);\r\ndev_dbg(&dev->udev->dev, "%s : sending, count = %Zd\n",\r\n__func__, count);\r\nbuffer_size = usb_endpoint_maxp(dev->interrupt_out_endpoint);\r\nbytes_to_write = count > buffer_size ? buffer_size : count;\r\ndev_dbg(&dev->udev->dev,\r\n"%s : buffer_size = %Zd, count = %Zd, bytes_to_write = %Zd\n",\r\n__func__, buffer_size, count, bytes_to_write);\r\nif (copy_from_user(dev->interrupt_out_buffer, buffer, bytes_to_write) != 0) {\r\nretval = -EFAULT;\r\ngoto exit;\r\n}\r\nusb_fill_int_urb(\r\ndev->interrupt_out_urb,\r\ndev->udev,\r\nusb_sndintpipe(dev->udev, dev->interrupt_out_endpoint->bEndpointAddress),\r\ndev->interrupt_out_buffer,\r\nbytes_to_write,\r\nadu_interrupt_out_callback,\r\ndev,\r\ndev->interrupt_out_endpoint->bInterval);\r\ndev->interrupt_out_urb->actual_length = bytes_to_write;\r\ndev->out_urb_finished = 0;\r\nretval = usb_submit_urb(dev->interrupt_out_urb, GFP_KERNEL);\r\nif (retval < 0) {\r\ndev->out_urb_finished = 1;\r\ndev_err(&dev->udev->dev, "Couldn't submit "\r\n"interrupt_out_urb %d\n", retval);\r\ngoto exit;\r\n}\r\nbuffer += bytes_to_write;\r\ncount -= bytes_to_write;\r\nbytes_written += bytes_to_write;\r\n}\r\n}\r\nmutex_unlock(&dev->mtx);\r\nreturn bytes_written;\r\nexit:\r\nmutex_unlock(&dev->mtx);\r\nexit_nolock:\r\nreturn retval;\r\nexit_onqueue:\r\nremove_wait_queue(&dev->write_wait, &waita);\r\nreturn retval;\r\n}\r\nstatic int adu_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct adu_device *dev = NULL;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint retval = -ENODEV;\r\nint in_end_size;\r\nint out_end_size;\r\nint i;\r\nif (udev == NULL) {\r\ndev_err(&interface->dev, "udev is NULL.\n");\r\ngoto exit;\r\n}\r\ndev = kzalloc(sizeof(struct adu_device), GFP_KERNEL);\r\nif (dev == NULL) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\nretval = -ENOMEM;\r\ngoto exit;\r\n}\r\nmutex_init(&dev->mtx);\r\nspin_lock_init(&dev->buflock);\r\ndev->udev = udev;\r\ninit_waitqueue_head(&dev->read_wait);\r\ninit_waitqueue_head(&dev->write_wait);\r\niface_desc = &interface->altsetting[0];\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(endpoint))\r\ndev->interrupt_in_endpoint = endpoint;\r\nif (usb_endpoint_is_int_out(endpoint))\r\ndev->interrupt_out_endpoint = endpoint;\r\n}\r\nif (dev->interrupt_in_endpoint == NULL) {\r\ndev_err(&interface->dev, "interrupt in endpoint not found\n");\r\ngoto error;\r\n}\r\nif (dev->interrupt_out_endpoint == NULL) {\r\ndev_err(&interface->dev, "interrupt out endpoint not found\n");\r\ngoto error;\r\n}\r\nin_end_size = usb_endpoint_maxp(dev->interrupt_in_endpoint);\r\nout_end_size = usb_endpoint_maxp(dev->interrupt_out_endpoint);\r\ndev->read_buffer_primary = kmalloc((4 * in_end_size), GFP_KERNEL);\r\nif (!dev->read_buffer_primary) {\r\ndev_err(&interface->dev, "Couldn't allocate read_buffer_primary\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nmemset(dev->read_buffer_primary, 'a', in_end_size);\r\nmemset(dev->read_buffer_primary + in_end_size, 'b', in_end_size);\r\nmemset(dev->read_buffer_primary + (2 * in_end_size), 'c', in_end_size);\r\nmemset(dev->read_buffer_primary + (3 * in_end_size), 'd', in_end_size);\r\ndev->read_buffer_secondary = kmalloc((4 * in_end_size), GFP_KERNEL);\r\nif (!dev->read_buffer_secondary) {\r\ndev_err(&interface->dev, "Couldn't allocate read_buffer_secondary\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nmemset(dev->read_buffer_secondary, 'e', in_end_size);\r\nmemset(dev->read_buffer_secondary + in_end_size, 'f', in_end_size);\r\nmemset(dev->read_buffer_secondary + (2 * in_end_size), 'g', in_end_size);\r\nmemset(dev->read_buffer_secondary + (3 * in_end_size), 'h', in_end_size);\r\ndev->interrupt_in_buffer = kmalloc(in_end_size, GFP_KERNEL);\r\nif (!dev->interrupt_in_buffer) {\r\ndev_err(&interface->dev, "Couldn't allocate interrupt_in_buffer\n");\r\ngoto error;\r\n}\r\nmemset(dev->interrupt_in_buffer, 'i', in_end_size);\r\ndev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->interrupt_in_urb) {\r\ndev_err(&interface->dev, "Couldn't allocate interrupt_in_urb\n");\r\ngoto error;\r\n}\r\ndev->interrupt_out_buffer = kmalloc(out_end_size, GFP_KERNEL);\r\nif (!dev->interrupt_out_buffer) {\r\ndev_err(&interface->dev, "Couldn't allocate interrupt_out_buffer\n");\r\ngoto error;\r\n}\r\ndev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->interrupt_out_urb) {\r\ndev_err(&interface->dev, "Couldn't allocate interrupt_out_urb\n");\r\ngoto error;\r\n}\r\nif (!usb_string(udev, udev->descriptor.iSerialNumber, dev->serial_number,\r\nsizeof(dev->serial_number))) {\r\ndev_err(&interface->dev, "Could not retrieve serial number\n");\r\ngoto error;\r\n}\r\ndev_dbg(&interface->dev,"serial_number=%s", dev->serial_number);\r\nusb_set_intfdata(interface, dev);\r\nretval = usb_register_dev(interface, &adu_class);\r\nif (retval) {\r\ndev_err(&interface->dev, "Not able to get a minor for this device.\n");\r\nusb_set_intfdata(interface, NULL);\r\ngoto error;\r\n}\r\ndev->minor = interface->minor;\r\ndev_info(&interface->dev, "ADU%d %s now attached to /dev/usb/adutux%d\n",\r\nle16_to_cpu(udev->descriptor.idProduct), dev->serial_number,\r\n(dev->minor - ADU_MINOR_BASE));\r\nexit:\r\nreturn retval;\r\nerror:\r\nadu_delete(dev);\r\nreturn retval;\r\n}\r\nstatic void adu_disconnect(struct usb_interface *interface)\r\n{\r\nstruct adu_device *dev;\r\nint minor;\r\ndev = usb_get_intfdata(interface);\r\nmutex_lock(&dev->mtx);\r\ndev->udev = NULL;\r\nminor = dev->minor;\r\nusb_deregister_dev(interface, &adu_class);\r\nmutex_unlock(&dev->mtx);\r\nmutex_lock(&adutux_mutex);\r\nusb_set_intfdata(interface, NULL);\r\ndev_dbg(&dev->udev->dev, "%s : open count %d\n",\r\n__func__, dev->open_count);\r\nif (!dev->open_count)\r\nadu_delete(dev);\r\nmutex_unlock(&adutux_mutex);\r\ndev_info(&interface->dev, "ADU device adutux%d now disconnected\n",\r\n(minor - ADU_MINOR_BASE));\r\n}
