static int\r\ngetMNP_single(struct nouveau_subdev *subdev, struct nvbios_pll *info, int clk,\r\nint *pN, int *pM, int *pP)\r\n{\r\nstruct nouveau_bios *bios = nouveau_bios(subdev);\r\nint minvco = info->vco1.min_freq, maxvco = info->vco1.max_freq;\r\nint minM = info->vco1.min_m, maxM = info->vco1.max_m;\r\nint minN = info->vco1.min_n, maxN = info->vco1.max_n;\r\nint minU = info->vco1.min_inputfreq;\r\nint maxU = info->vco1.max_inputfreq;\r\nint minP = info->min_p;\r\nint maxP = info->max_p_usable;\r\nint crystal = info->refclk;\r\nint M, N, thisP, P;\r\nint clkP, calcclk;\r\nint delta, bestdelta = INT_MAX;\r\nint bestclk = 0;\r\nif (bios->version.major < 0x60) {\r\nint cv = bios->version.chip;\r\nif (cv < 0x17 || cv == 0x1a || cv == 0x20) {\r\nif (clk > 250000)\r\nmaxM = 6;\r\nif (clk > 340000)\r\nmaxM = 2;\r\n} else if (cv < 0x40) {\r\nif (clk > 150000)\r\nmaxM = 6;\r\nif (clk > 200000)\r\nmaxM = 4;\r\nif (clk > 340000)\r\nmaxM = 2;\r\n}\r\n}\r\nP = 1 << maxP;\r\nif ((clk * P) < minvco) {\r\nminvco = clk * maxP;\r\nmaxvco = minvco * 2;\r\n}\r\nif (clk + clk/200 > maxvco)\r\nmaxvco = clk + clk/200;\r\nfor (thisP = minP; thisP <= maxP; thisP++) {\r\nP = 1 << thisP;\r\nclkP = clk * P;\r\nif (clkP < minvco)\r\ncontinue;\r\nif (clkP > maxvco)\r\nreturn bestclk;\r\nfor (M = minM; M <= maxM; M++) {\r\nif (crystal/M < minU)\r\nreturn bestclk;\r\nif (crystal/M > maxU)\r\ncontinue;\r\nN = (clkP * M + crystal/2) / crystal;\r\nif (N < minN)\r\ncontinue;\r\nif (N > maxN)\r\nbreak;\r\ncalcclk = ((N * crystal + P/2) / P + M/2) / M;\r\ndelta = abs(calcclk - clk);\r\nif (delta < bestdelta) {\r\nbestdelta = delta;\r\nbestclk = calcclk;\r\n*pN = N;\r\n*pM = M;\r\n*pP = thisP;\r\nif (delta == 0)\r\nreturn bestclk;\r\n}\r\n}\r\n}\r\nreturn bestclk;\r\n}\r\nstatic int\r\ngetMNP_double(struct nouveau_subdev *subdev, struct nvbios_pll *info, int clk,\r\nint *pN1, int *pM1, int *pN2, int *pM2, int *pP)\r\n{\r\nint chip_version = nouveau_bios(subdev)->version.chip;\r\nint minvco1 = info->vco1.min_freq, maxvco1 = info->vco1.max_freq;\r\nint minvco2 = info->vco2.min_freq, maxvco2 = info->vco2.max_freq;\r\nint minU1 = info->vco1.min_inputfreq, minU2 = info->vco2.min_inputfreq;\r\nint maxU1 = info->vco1.max_inputfreq, maxU2 = info->vco2.max_inputfreq;\r\nint minM1 = info->vco1.min_m, maxM1 = info->vco1.max_m;\r\nint minN1 = info->vco1.min_n, maxN1 = info->vco1.max_n;\r\nint minM2 = info->vco2.min_m, maxM2 = info->vco2.max_m;\r\nint minN2 = info->vco2.min_n, maxN2 = info->vco2.max_n;\r\nint maxlog2P = info->max_p_usable;\r\nint crystal = info->refclk;\r\nbool fixedgain2 = (minM2 == maxM2 && minN2 == maxN2);\r\nint M1, N1, M2, N2, log2P;\r\nint clkP, calcclk1, calcclk2, calcclkout;\r\nint delta, bestdelta = INT_MAX;\r\nint bestclk = 0;\r\nint vco2 = (maxvco2 - maxvco2/200) / 2;\r\nfor (log2P = 0; clk && log2P < maxlog2P && clk <= (vco2 >> log2P); log2P++)\r\n;\r\nclkP = clk << log2P;\r\nif (maxvco2 < clk + clk/200)\r\nmaxvco2 = clk + clk/200;\r\nfor (M1 = minM1; M1 <= maxM1; M1++) {\r\nif (crystal/M1 < minU1)\r\nreturn bestclk;\r\nif (crystal/M1 > maxU1)\r\ncontinue;\r\nfor (N1 = minN1; N1 <= maxN1; N1++) {\r\ncalcclk1 = crystal * N1 / M1;\r\nif (calcclk1 < minvco1)\r\ncontinue;\r\nif (calcclk1 > maxvco1)\r\nbreak;\r\nfor (M2 = minM2; M2 <= maxM2; M2++) {\r\nif (calcclk1/M2 < minU2)\r\nbreak;\r\nif (calcclk1/M2 > maxU2)\r\ncontinue;\r\nN2 = (clkP * M2 + calcclk1/2) / calcclk1;\r\nif (N2 < minN2)\r\ncontinue;\r\nif (N2 > maxN2)\r\nbreak;\r\nif (!fixedgain2) {\r\nif (chip_version < 0x60)\r\nif (N2/M2 < 4 || N2/M2 > 10)\r\ncontinue;\r\ncalcclk2 = calcclk1 * N2 / M2;\r\nif (calcclk2 < minvco2)\r\nbreak;\r\nif (calcclk2 > maxvco2)\r\ncontinue;\r\n} else\r\ncalcclk2 = calcclk1;\r\ncalcclkout = calcclk2 >> log2P;\r\ndelta = abs(calcclkout - clk);\r\nif (delta < bestdelta) {\r\nbestdelta = delta;\r\nbestclk = calcclkout;\r\n*pN1 = N1;\r\n*pM1 = M1;\r\n*pN2 = N2;\r\n*pM2 = M2;\r\n*pP = log2P;\r\nif (delta == 0)\r\nreturn bestclk;\r\n}\r\n}\r\n}\r\n}\r\nreturn bestclk;\r\n}\r\nint\r\nnv04_pll_calc(struct nouveau_subdev *subdev, struct nvbios_pll *info, u32 freq,\r\nint *N1, int *M1, int *N2, int *M2, int *P)\r\n{\r\nint ret;\r\nif (!info->vco2.max_freq || !N2) {\r\nret = getMNP_single(subdev, info, freq, N1, M1, P);\r\nif (N2) {\r\n*N2 = 1;\r\n*M2 = 1;\r\n}\r\n} else {\r\nret = getMNP_double(subdev, info, freq, N1, M1, N2, M2, P);\r\n}\r\nif (!ret)\r\nnv_error(subdev, "unable to compute acceptable pll values\n");\r\nreturn ret;\r\n}
