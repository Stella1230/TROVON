int rawobj_empty(rawobj_t *obj)\r\n{\r\nLASSERT(equi(obj->len, obj->data));\r\nreturn (obj->len == 0);\r\n}\r\nint rawobj_alloc(rawobj_t *obj, char *buf, int len)\r\n{\r\nLASSERT(obj);\r\nLASSERT(len >= 0);\r\nobj->len = len;\r\nif (len) {\r\nOBD_ALLOC_LARGE(obj->data, len);\r\nif (!obj->data) {\r\nobj->len = 0;\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(obj->data, buf, len);\r\n} else\r\nobj->data = NULL;\r\nreturn 0;\r\n}\r\nvoid rawobj_free(rawobj_t *obj)\r\n{\r\nLASSERT(obj);\r\nif (obj->len) {\r\nLASSERT(obj->data);\r\nOBD_FREE_LARGE(obj->data, obj->len);\r\nobj->len = 0;\r\nobj->data = NULL;\r\n} else\r\nLASSERT(!obj->data);\r\n}\r\nint rawobj_equal(rawobj_t *a, rawobj_t *b)\r\n{\r\nLASSERT(a && b);\r\nreturn (a->len == b->len &&\r\n(!a->len || !memcmp(a->data, b->data, a->len)));\r\n}\r\nint rawobj_dup(rawobj_t *dest, rawobj_t *src)\r\n{\r\nLASSERT(src && dest);\r\ndest->len = src->len;\r\nif (dest->len) {\r\nOBD_ALLOC_LARGE(dest->data, dest->len);\r\nif (!dest->data) {\r\ndest->len = 0;\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(dest->data, src->data, dest->len);\r\n} else\r\ndest->data = NULL;\r\nreturn 0;\r\n}\r\nint rawobj_serialize(rawobj_t *obj, __u32 **buf, __u32 *buflen)\r\n{\r\n__u32 len;\r\nLASSERT(obj);\r\nLASSERT(buf);\r\nLASSERT(buflen);\r\nlen = cfs_size_round4(obj->len);\r\nif (*buflen < 4 + len) {\r\nCERROR("buflen %u < %u\n", *buflen, 4 + len);\r\nreturn -EINVAL;\r\n}\r\n*(*buf)++ = cpu_to_le32(obj->len);\r\nmemcpy(*buf, obj->data, obj->len);\r\n*buf += (len >> 2);\r\n*buflen -= (4 + len);\r\nreturn 0;\r\n}\r\nstatic int __rawobj_extract(rawobj_t *obj, __u32 **buf, __u32 *buflen,\r\nint alloc, int local)\r\n{\r\n__u32 len;\r\nif (*buflen < sizeof(__u32)) {\r\nCERROR("buflen %u\n", *buflen);\r\nreturn -EINVAL;\r\n}\r\nobj->len = *(*buf)++;\r\nif (!local)\r\nobj->len = le32_to_cpu(obj->len);\r\n*buflen -= sizeof(__u32);\r\nif (!obj->len) {\r\nobj->data = NULL;\r\nreturn 0;\r\n}\r\nlen = local ? obj->len : cfs_size_round4(obj->len);\r\nif (*buflen < len) {\r\nCERROR("buflen %u < %u\n", *buflen, len);\r\nobj->len = 0;\r\nreturn -EINVAL;\r\n}\r\nif (!alloc)\r\nobj->data = (__u8 *) *buf;\r\nelse {\r\nOBD_ALLOC_LARGE(obj->data, obj->len);\r\nif (!obj->data) {\r\nCERROR("fail to alloc %u bytes\n", obj->len);\r\nobj->len = 0;\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(obj->data, *buf, obj->len);\r\n}\r\n*((char **)buf) += len;\r\n*buflen -= len;\r\nreturn 0;\r\n}\r\nint rawobj_extract(rawobj_t *obj, __u32 **buf, __u32 *buflen)\r\n{\r\nreturn __rawobj_extract(obj, buf, buflen, 0, 0);\r\n}\r\nint rawobj_extract_alloc(rawobj_t *obj, __u32 **buf, __u32 *buflen)\r\n{\r\nreturn __rawobj_extract(obj, buf, buflen, 1, 0);\r\n}\r\nint rawobj_extract_local(rawobj_t *obj, __u32 **buf, __u32 *buflen)\r\n{\r\nreturn __rawobj_extract(obj, buf, buflen, 0, 1);\r\n}\r\nint rawobj_extract_local_alloc(rawobj_t *obj, __u32 **buf, __u32 *buflen)\r\n{\r\nreturn __rawobj_extract(obj, buf, buflen, 1, 1);\r\n}\r\nint rawobj_from_netobj(rawobj_t *rawobj, netobj_t *netobj)\r\n{\r\nrawobj->len = netobj->len;\r\nrawobj->data = netobj->data;\r\nreturn 0;\r\n}\r\nint rawobj_from_netobj_alloc(rawobj_t *rawobj, netobj_t *netobj)\r\n{\r\nrawobj->len = 0;\r\nrawobj->data = NULL;\r\nif (netobj->len == 0)\r\nreturn 0;\r\nOBD_ALLOC_LARGE(rawobj->data, netobj->len);\r\nif (rawobj->data == NULL)\r\nreturn -ENOMEM;\r\nrawobj->len = netobj->len;\r\nmemcpy(rawobj->data, netobj->data, netobj->len);\r\nreturn 0;\r\n}\r\nint buffer_extract_bytes(const void **buf, __u32 *buflen,\r\nvoid *res, __u32 reslen)\r\n{\r\nif (*buflen < reslen) {\r\nCERROR("buflen %u < %u\n", *buflen, reslen);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(res, *buf, reslen);\r\n*buf += reslen;\r\n*buflen -= reslen;\r\nreturn 0;\r\n}
