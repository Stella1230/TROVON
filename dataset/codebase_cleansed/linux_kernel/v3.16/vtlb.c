static int __is_tr_translated(struct thash_data *trp, u64 rid, u64 va)\r\n{\r\nreturn ((trp->p) && (trp->rid == rid)\r\n&& ((va-trp->vadr) < PSIZE(trp->ps)));\r\n}\r\nstatic int __is_tr_overlap(struct thash_data *trp, u64 rid, u64 sva, u64 eva)\r\n{\r\nu64 sa1, ea1;\r\nif (!trp->p || trp->rid != rid)\r\nreturn 0;\r\nsa1 = trp->vadr;\r\nea1 = sa1 + PSIZE(trp->ps) - 1;\r\neva -= 1;\r\nif ((sva > ea1) || (sa1 > eva))\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nvoid machine_tlb_purge(u64 va, u64 ps)\r\n{\r\nia64_ptcl(va, ps << 2);\r\n}\r\nvoid local_flush_tlb_all(void)\r\n{\r\nint i, j;\r\nunsigned long flags, count0, count1;\r\nunsigned long stride0, stride1, addr;\r\naddr = current_vcpu->arch.ptce_base;\r\ncount0 = current_vcpu->arch.ptce_count[0];\r\ncount1 = current_vcpu->arch.ptce_count[1];\r\nstride0 = current_vcpu->arch.ptce_stride[0];\r\nstride1 = current_vcpu->arch.ptce_stride[1];\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < count0; ++i) {\r\nfor (j = 0; j < count1; ++j) {\r\nia64_ptce(addr);\r\naddr += stride1;\r\n}\r\naddr += stride0;\r\n}\r\nlocal_irq_restore(flags);\r\nia64_srlz_i();\r\n}\r\nint vhpt_enabled(struct kvm_vcpu *vcpu, u64 vadr, enum vhpt_ref ref)\r\n{\r\nunion ia64_rr vrr;\r\nunion ia64_pta vpta;\r\nstruct ia64_psr vpsr;\r\nvpsr = *(struct ia64_psr *)&VCPU(vcpu, vpsr);\r\nvrr.val = vcpu_get_rr(vcpu, vadr);\r\nvpta.val = vcpu_get_pta(vcpu);\r\nif (vrr.ve & vpta.ve) {\r\nswitch (ref) {\r\ncase DATA_REF:\r\ncase NA_REF:\r\nreturn vpsr.dt;\r\ncase INST_REF:\r\nreturn vpsr.dt && vpsr.it && vpsr.ic;\r\ncase RSE_REF:\r\nreturn vpsr.dt && vpsr.rt;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstruct thash_data *vsa_thash(union ia64_pta vpta, u64 va, u64 vrr, u64 *tag)\r\n{\r\nu64 index, pfn, rid, pfn_bits;\r\npfn_bits = vpta.size - 5 - 8;\r\npfn = REGION_OFFSET(va) >> _REGION_PAGE_SIZE(vrr);\r\nrid = _REGION_ID(vrr);\r\nindex = ((rid & 0xff) << pfn_bits)|(pfn & ((1UL << pfn_bits) - 1));\r\n*tag = ((rid >> 8) & 0xffff) | ((pfn >> pfn_bits) << 16);\r\nreturn (struct thash_data *)((vpta.base << PTA_BASE_SHIFT) +\r\n(index << 5));\r\n}\r\nstruct thash_data *__vtr_lookup(struct kvm_vcpu *vcpu, u64 va, int type)\r\n{\r\nstruct thash_data *trp;\r\nint i;\r\nu64 rid;\r\nrid = vcpu_get_rr(vcpu, va);\r\nrid = rid & RR_RID_MASK;\r\nif (type == D_TLB) {\r\nif (vcpu_quick_region_check(vcpu->arch.dtr_regions, va)) {\r\nfor (trp = (struct thash_data *)&vcpu->arch.dtrs, i = 0;\r\ni < NDTRS; i++, trp++) {\r\nif (__is_tr_translated(trp, rid, va))\r\nreturn trp;\r\n}\r\n}\r\n} else {\r\nif (vcpu_quick_region_check(vcpu->arch.itr_regions, va)) {\r\nfor (trp = (struct thash_data *)&vcpu->arch.itrs, i = 0;\r\ni < NITRS; i++, trp++) {\r\nif (__is_tr_translated(trp, rid, va))\r\nreturn trp;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void vhpt_insert(u64 pte, u64 itir, u64 ifa, u64 gpte)\r\n{\r\nunion ia64_rr rr;\r\nstruct thash_data *head;\r\nunsigned long ps, gpaddr;\r\nps = itir_ps(itir);\r\nrr.val = ia64_get_rr(ifa);\r\ngpaddr = ((gpte & _PAGE_PPN_MASK) >> ps << ps) |\r\n(ifa & ((1UL << ps) - 1));\r\nhead = (struct thash_data *)ia64_thash(ifa);\r\nhead->etag = INVALID_TI_TAG;\r\nia64_mf();\r\nhead->page_flags = pte & ~PAGE_FLAGS_RV_MASK;\r\nhead->itir = rr.ps << 2;\r\nhead->etag = ia64_ttag(ifa);\r\nhead->gpaddr = gpaddr;\r\n}\r\nvoid mark_pages_dirty(struct kvm_vcpu *v, u64 pte, u64 ps)\r\n{\r\nu64 i, dirty_pages = 1;\r\nu64 base_gfn = (pte&_PAGE_PPN_MASK) >> PAGE_SHIFT;\r\nvmm_spinlock_t *lock = __kvm_va(v->arch.dirty_log_lock_pa);\r\nvoid *dirty_bitmap = (void *)KVM_MEM_DIRTY_LOG_BASE;\r\ndirty_pages <<= ps <= PAGE_SHIFT ? 0 : ps - PAGE_SHIFT;\r\nvmm_spin_lock(lock);\r\nfor (i = 0; i < dirty_pages; i++) {\r\nif (!test_bit(base_gfn + i, dirty_bitmap))\r\nset_bit(base_gfn + i , dirty_bitmap);\r\n}\r\nvmm_spin_unlock(lock);\r\n}\r\nvoid thash_vhpt_insert(struct kvm_vcpu *v, u64 pte, u64 itir, u64 va, int type)\r\n{\r\nu64 phy_pte, psr;\r\nunion ia64_rr mrr;\r\nmrr.val = ia64_get_rr(va);\r\nphy_pte = translate_phy_pte(&pte, itir, va);\r\nif (itir_ps(itir) >= mrr.ps) {\r\nvhpt_insert(phy_pte, itir, va, pte);\r\n} else {\r\nphy_pte &= ~PAGE_FLAGS_RV_MASK;\r\npsr = ia64_clear_ic();\r\nia64_itc(type, va, phy_pte, itir_ps(itir));\r\nparavirt_dv_serialize_data();\r\nia64_set_psr(psr);\r\n}\r\nif (!(pte&VTLB_PTE_IO))\r\nmark_pages_dirty(v, pte, itir_ps(itir));\r\n}\r\nstruct thash_data *vhpt_lookup(u64 va)\r\n{\r\nstruct thash_data *head;\r\nu64 tag;\r\nhead = (struct thash_data *)ia64_thash(va);\r\ntag = ia64_ttag(va);\r\nif (head->etag == tag)\r\nreturn head;\r\nreturn NULL;\r\n}\r\nu64 guest_vhpt_lookup(u64 iha, u64 *pte)\r\n{\r\nu64 ret;\r\nstruct thash_data *data;\r\ndata = __vtr_lookup(current_vcpu, iha, D_TLB);\r\nif (data != NULL)\r\nthash_vhpt_insert(current_vcpu, data->page_flags,\r\ndata->itir, iha, D_TLB);\r\nasm volatile ("rsm psr.ic|psr.i;;"\r\n"srlz.d;;"\r\n"ld8.s r9=[%1];;"\r\n"tnat.nz p6,p7=r9;;"\r\n"(p6) mov %0=1;"\r\n"(p6) mov r9=r0;"\r\n"(p7) extr.u r9=r9,0,53;;"\r\n"(p7) mov %0=r0;"\r\n"(p7) st8 [%2]=r9;;"\r\n"ssm psr.ic;;"\r\n"srlz.d;;"\r\n"ssm psr.i;;"\r\n"srlz.d;;"\r\n: "=&r"(ret) : "r"(iha), "r"(pte) : "memory");\r\nreturn ret;\r\n}\r\nstatic void vtlb_purge(struct kvm_vcpu *v, u64 va, u64 ps)\r\n{\r\nstruct thash_data *cur;\r\nu64 start, curadr, size, psbits, tag, rr_ps, num;\r\nunion ia64_rr vrr;\r\nstruct thash_cb *hcb = &v->arch.vtlb;\r\nvrr.val = vcpu_get_rr(v, va);\r\npsbits = VMX(v, psbits[(va >> 61)]);\r\nstart = va & ~((1UL << ps) - 1);\r\nwhile (psbits) {\r\ncuradr = start;\r\nrr_ps = __ffs(psbits);\r\npsbits &= ~(1UL << rr_ps);\r\nnum = 1UL << ((ps < rr_ps) ? 0 : (ps - rr_ps));\r\nsize = PSIZE(rr_ps);\r\nvrr.ps = rr_ps;\r\nwhile (num) {\r\ncur = vsa_thash(hcb->pta, curadr, vrr.val, &tag);\r\nif (cur->etag == tag && cur->ps == rr_ps)\r\ncur->etag = INVALID_TI_TAG;\r\ncuradr += size;\r\nnum--;\r\n}\r\n}\r\n}\r\nstatic void vhpt_purge(struct kvm_vcpu *v, u64 va, u64 ps)\r\n{\r\nstruct thash_data *cur;\r\nu64 start, size, tag, num;\r\nunion ia64_rr rr;\r\nstart = va & ~((1UL << ps) - 1);\r\nrr.val = ia64_get_rr(va);\r\nsize = PSIZE(rr.ps);\r\nnum = 1UL << ((ps < rr.ps) ? 0 : (ps - rr.ps));\r\nwhile (num) {\r\ncur = (struct thash_data *)ia64_thash(start);\r\ntag = ia64_ttag(start);\r\nif (cur->etag == tag)\r\ncur->etag = INVALID_TI_TAG;\r\nstart += size;\r\nnum--;\r\n}\r\nmachine_tlb_purge(va, ps);\r\n}\r\nvoid vtlb_insert(struct kvm_vcpu *v, u64 pte, u64 itir, u64 va)\r\n{\r\nstruct thash_data *head;\r\nunion ia64_rr vrr;\r\nu64 tag;\r\nstruct thash_cb *hcb = &v->arch.vtlb;\r\nvrr.val = vcpu_get_rr(v, va);\r\nvrr.ps = itir_ps(itir);\r\nVMX(v, psbits[va >> 61]) |= (1UL << vrr.ps);\r\nhead = vsa_thash(hcb->pta, va, vrr.val, &tag);\r\nhead->page_flags = pte;\r\nhead->itir = itir;\r\nhead->etag = tag;\r\n}\r\nint vtr_find_overlap(struct kvm_vcpu *vcpu, u64 va, u64 ps, int type)\r\n{\r\nstruct thash_data *trp;\r\nint i;\r\nu64 end, rid;\r\nrid = vcpu_get_rr(vcpu, va);\r\nrid = rid & RR_RID_MASK;\r\nend = va + PSIZE(ps);\r\nif (type == D_TLB) {\r\nif (vcpu_quick_region_check(vcpu->arch.dtr_regions, va)) {\r\nfor (trp = (struct thash_data *)&vcpu->arch.dtrs, i = 0;\r\ni < NDTRS; i++, trp++) {\r\nif (__is_tr_overlap(trp, rid, va, end))\r\nreturn i;\r\n}\r\n}\r\n} else {\r\nif (vcpu_quick_region_check(vcpu->arch.itr_regions, va)) {\r\nfor (trp = (struct thash_data *)&vcpu->arch.itrs, i = 0;\r\ni < NITRS; i++, trp++) {\r\nif (__is_tr_overlap(trp, rid, va, end))\r\nreturn i;\r\n}\r\n}\r\n}\r\nreturn -1;\r\n}\r\nvoid thash_purge_entries(struct kvm_vcpu *v, u64 va, u64 ps)\r\n{\r\nif (vcpu_quick_region_check(v->arch.tc_regions, va))\r\nvtlb_purge(v, va, ps);\r\nvhpt_purge(v, va, ps);\r\n}\r\nvoid thash_purge_entries_remote(struct kvm_vcpu *v, u64 va, u64 ps)\r\n{\r\nu64 old_va = va;\r\nva = REGION_OFFSET(va);\r\nif (vcpu_quick_region_check(v->arch.tc_regions, old_va))\r\nvtlb_purge(v, va, ps);\r\nvhpt_purge(v, va, ps);\r\n}\r\nu64 translate_phy_pte(u64 *pte, u64 itir, u64 va)\r\n{\r\nu64 ps, ps_mask, paddr, maddr, io_mask;\r\nunion pte_flags phy_pte;\r\nps = itir_ps(itir);\r\nps_mask = ~((1UL << ps) - 1);\r\nphy_pte.val = *pte;\r\npaddr = *pte;\r\npaddr = ((paddr & _PAGE_PPN_MASK) & ps_mask) | (va & ~ps_mask);\r\nmaddr = kvm_get_mpt_entry(paddr >> PAGE_SHIFT);\r\nio_mask = maddr & GPFN_IO_MASK;\r\nif (io_mask && (io_mask != GPFN_PHYS_MMIO)) {\r\n*pte |= VTLB_PTE_IO;\r\nreturn -1;\r\n}\r\nmaddr = ((maddr & _PAGE_PPN_MASK) & PAGE_MASK) |\r\n(paddr & ~PAGE_MASK);\r\nphy_pte.ppn = maddr >> ARCH_PAGE_SHIFT;\r\nreturn phy_pte.val;\r\n}\r\nvoid thash_purge_and_insert(struct kvm_vcpu *v, u64 pte, u64 itir,\r\nu64 ifa, int type)\r\n{\r\nu64 ps;\r\nu64 phy_pte, io_mask, index;\r\nunion ia64_rr vrr, mrr;\r\nps = itir_ps(itir);\r\nvrr.val = vcpu_get_rr(v, ifa);\r\nmrr.val = ia64_get_rr(ifa);\r\nindex = (pte & _PAGE_PPN_MASK) >> PAGE_SHIFT;\r\nio_mask = kvm_get_mpt_entry(index) & GPFN_IO_MASK;\r\nphy_pte = translate_phy_pte(&pte, itir, ifa);\r\nif (!(pte & VTLB_PTE_IO) && ((pte & _PAGE_MA_MASK) != _PAGE_MA_NAT) &&\r\nio_mask != GPFN_PHYS_MMIO) {\r\npte &= ~_PAGE_MA_MASK;\r\nphy_pte &= ~_PAGE_MA_MASK;\r\n}\r\nvtlb_purge(v, ifa, ps);\r\nvhpt_purge(v, ifa, ps);\r\nif ((ps != mrr.ps) || (pte & VTLB_PTE_IO)) {\r\nvtlb_insert(v, pte, itir, ifa);\r\nvcpu_quick_region_set(VMX(v, tc_regions), ifa);\r\n}\r\nif (pte & VTLB_PTE_IO)\r\nreturn;\r\nif (ps >= mrr.ps)\r\nvhpt_insert(phy_pte, itir, ifa, pte);\r\nelse {\r\nu64 psr;\r\nphy_pte &= ~PAGE_FLAGS_RV_MASK;\r\npsr = ia64_clear_ic();\r\nia64_itc(type, ifa, phy_pte, ps);\r\nparavirt_dv_serialize_data();\r\nia64_set_psr(psr);\r\n}\r\nif (!(pte&VTLB_PTE_IO))\r\nmark_pages_dirty(v, pte, ps);\r\n}\r\nvoid thash_purge_all(struct kvm_vcpu *v)\r\n{\r\nint i;\r\nstruct thash_data *head;\r\nstruct thash_cb *vtlb, *vhpt;\r\nvtlb = &v->arch.vtlb;\r\nvhpt = &v->arch.vhpt;\r\nfor (i = 0; i < 8; i++)\r\nVMX(v, psbits[i]) = 0;\r\nhead = vtlb->hash;\r\nfor (i = 0; i < vtlb->num; i++) {\r\nhead->page_flags = 0;\r\nhead->etag = INVALID_TI_TAG;\r\nhead->itir = 0;\r\nhead->next = 0;\r\nhead++;\r\n};\r\nhead = vhpt->hash;\r\nfor (i = 0; i < vhpt->num; i++) {\r\nhead->page_flags = 0;\r\nhead->etag = INVALID_TI_TAG;\r\nhead->itir = 0;\r\nhead->next = 0;\r\nhead++;\r\n};\r\nlocal_flush_tlb_all();\r\n}\r\nstruct thash_data *vtlb_lookup(struct kvm_vcpu *v, u64 va, int is_data)\r\n{\r\nstruct thash_data *cch;\r\nu64 psbits, ps, tag;\r\nunion ia64_rr vrr;\r\nstruct thash_cb *hcb = &v->arch.vtlb;\r\ncch = __vtr_lookup(v, va, is_data);\r\nif (cch)\r\nreturn cch;\r\nif (vcpu_quick_region_check(v->arch.tc_regions, va) == 0)\r\nreturn NULL;\r\npsbits = VMX(v, psbits[(va >> 61)]);\r\nvrr.val = vcpu_get_rr(v, va);\r\nwhile (psbits) {\r\nps = __ffs(psbits);\r\npsbits &= ~(1UL << ps);\r\nvrr.ps = ps;\r\ncch = vsa_thash(hcb->pta, va, vrr.val, &tag);\r\nif (cch->etag == tag && cch->ps == ps)\r\nreturn cch;\r\n}\r\nreturn NULL;\r\n}\r\nvoid thash_init(struct thash_cb *hcb, u64 sz)\r\n{\r\nint i;\r\nstruct thash_data *head;\r\nhcb->pta.val = (unsigned long)hcb->hash;\r\nhcb->pta.vf = 1;\r\nhcb->pta.ve = 1;\r\nhcb->pta.size = sz;\r\nhead = hcb->hash;\r\nfor (i = 0; i < hcb->num; i++) {\r\nhead->page_flags = 0;\r\nhead->itir = 0;\r\nhead->etag = INVALID_TI_TAG;\r\nhead->next = 0;\r\nhead++;\r\n}\r\n}\r\nu64 kvm_get_mpt_entry(u64 gpfn)\r\n{\r\nu64 *base = (u64 *) KVM_P2M_BASE;\r\nif (gpfn >= (KVM_P2M_SIZE >> 3))\r\npanic_vm(current_vcpu, "Invalid gpfn =%lx\n", gpfn);\r\nreturn *(base + gpfn);\r\n}\r\nu64 kvm_lookup_mpa(u64 gpfn)\r\n{\r\nu64 maddr;\r\nmaddr = kvm_get_mpt_entry(gpfn);\r\nreturn maddr&_PAGE_PPN_MASK;\r\n}\r\nu64 kvm_gpa_to_mpa(u64 gpa)\r\n{\r\nu64 pte = kvm_lookup_mpa(gpa >> PAGE_SHIFT);\r\nreturn (pte >> PAGE_SHIFT << PAGE_SHIFT) | (gpa & ~PAGE_MASK);\r\n}\r\nint fetch_code(struct kvm_vcpu *vcpu, u64 gip, IA64_BUNDLE *pbundle)\r\n{\r\nu64 gpip = 0;\r\nu64 *vpa;\r\nstruct thash_data *tlb;\r\nu64 maddr;\r\nif (!(VCPU(vcpu, vpsr) & IA64_PSR_IT)) {\r\ngpip = gip;\r\n} else {\r\ntlb = vtlb_lookup(vcpu, gip, I_TLB);\r\nif (tlb)\r\ngpip = (tlb->ppn >> (tlb->ps - 12) << tlb->ps) |\r\n(gip & (PSIZE(tlb->ps) - 1));\r\n}\r\nif (gpip) {\r\nmaddr = kvm_gpa_to_mpa(gpip);\r\n} else {\r\ntlb = vhpt_lookup(gip);\r\nif (tlb == NULL) {\r\nia64_ptcl(gip, ARCH_PAGE_SHIFT << 2);\r\nreturn IA64_FAULT;\r\n}\r\nmaddr = (tlb->ppn >> (tlb->ps - 12) << tlb->ps)\r\n| (gip & (PSIZE(tlb->ps) - 1));\r\n}\r\nvpa = (u64 *)__kvm_va(maddr);\r\npbundle->i64[0] = *vpa++;\r\npbundle->i64[1] = *vpa;\r\nreturn IA64_NO_FAULT;\r\n}\r\nvoid kvm_init_vhpt(struct kvm_vcpu *v)\r\n{\r\nv->arch.vhpt.num = VHPT_NUM_ENTRIES;\r\nthash_init(&v->arch.vhpt, VHPT_SHIFT);\r\nia64_set_pta(v->arch.vhpt.pta.val);\r\n}\r\nvoid kvm_init_vtlb(struct kvm_vcpu *v)\r\n{\r\nv->arch.vtlb.num = VTLB_NUM_ENTRIES;\r\nthash_init(&v->arch.vtlb, VTLB_SHIFT);\r\n}
