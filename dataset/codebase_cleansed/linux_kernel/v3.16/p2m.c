static int xen_add_phys_to_mach_entry(struct xen_p2m_entry *new)\r\n{\r\nstruct rb_node **link = &phys_to_mach.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct xen_p2m_entry *entry;\r\nint rc = 0;\r\nwhile (*link) {\r\nparent = *link;\r\nentry = rb_entry(parent, struct xen_p2m_entry, rbnode_phys);\r\nif (new->mfn == entry->mfn)\r\ngoto err_out;\r\nif (new->pfn == entry->pfn)\r\ngoto err_out;\r\nif (new->pfn < entry->pfn)\r\nlink = &(*link)->rb_left;\r\nelse\r\nlink = &(*link)->rb_right;\r\n}\r\nrb_link_node(&new->rbnode_phys, parent, link);\r\nrb_insert_color(&new->rbnode_phys, &phys_to_mach);\r\ngoto out;\r\nerr_out:\r\nrc = -EINVAL;\r\npr_warn("%s: cannot add pfn=%pa -> mfn=%pa: pfn=%pa -> mfn=%pa already exists\n",\r\n__func__, &new->pfn, &new->mfn, &entry->pfn, &entry->mfn);\r\nout:\r\nreturn rc;\r\n}\r\nunsigned long __pfn_to_mfn(unsigned long pfn)\r\n{\r\nstruct rb_node *n = phys_to_mach.rb_node;\r\nstruct xen_p2m_entry *entry;\r\nunsigned long irqflags;\r\nread_lock_irqsave(&p2m_lock, irqflags);\r\nwhile (n) {\r\nentry = rb_entry(n, struct xen_p2m_entry, rbnode_phys);\r\nif (entry->pfn <= pfn &&\r\nentry->pfn + entry->nr_pages > pfn) {\r\nread_unlock_irqrestore(&p2m_lock, irqflags);\r\nreturn entry->mfn + (pfn - entry->pfn);\r\n}\r\nif (pfn < entry->pfn)\r\nn = n->rb_left;\r\nelse\r\nn = n->rb_right;\r\n}\r\nread_unlock_irqrestore(&p2m_lock, irqflags);\r\nreturn INVALID_P2M_ENTRY;\r\n}\r\nstatic int xen_add_mach_to_phys_entry(struct xen_p2m_entry *new)\r\n{\r\nstruct rb_node **link = &mach_to_phys.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct xen_p2m_entry *entry;\r\nint rc = 0;\r\nwhile (*link) {\r\nparent = *link;\r\nentry = rb_entry(parent, struct xen_p2m_entry, rbnode_mach);\r\nif (new->mfn == entry->mfn)\r\ngoto err_out;\r\nif (new->pfn == entry->pfn)\r\ngoto err_out;\r\nif (new->mfn < entry->mfn)\r\nlink = &(*link)->rb_left;\r\nelse\r\nlink = &(*link)->rb_right;\r\n}\r\nrb_link_node(&new->rbnode_mach, parent, link);\r\nrb_insert_color(&new->rbnode_mach, &mach_to_phys);\r\ngoto out;\r\nerr_out:\r\nrc = -EINVAL;\r\npr_warn("%s: cannot add pfn=%pa -> mfn=%pa: pfn=%pa -> mfn=%pa already exists\n",\r\n__func__, &new->pfn, &new->mfn, &entry->pfn, &entry->mfn);\r\nout:\r\nreturn rc;\r\n}\r\nunsigned long __mfn_to_pfn(unsigned long mfn)\r\n{\r\nstruct rb_node *n = mach_to_phys.rb_node;\r\nstruct xen_p2m_entry *entry;\r\nunsigned long irqflags;\r\nread_lock_irqsave(&p2m_lock, irqflags);\r\nwhile (n) {\r\nentry = rb_entry(n, struct xen_p2m_entry, rbnode_mach);\r\nif (entry->mfn <= mfn &&\r\nentry->mfn + entry->nr_pages > mfn) {\r\nread_unlock_irqrestore(&p2m_lock, irqflags);\r\nreturn entry->pfn + (mfn - entry->mfn);\r\n}\r\nif (mfn < entry->mfn)\r\nn = n->rb_left;\r\nelse\r\nn = n->rb_right;\r\n}\r\nread_unlock_irqrestore(&p2m_lock, irqflags);\r\nreturn INVALID_P2M_ENTRY;\r\n}\r\nint set_foreign_p2m_mapping(struct gnttab_map_grant_ref *map_ops,\r\nstruct gnttab_map_grant_ref *kmap_ops,\r\nstruct page **pages, unsigned int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nif (map_ops[i].status)\r\ncontinue;\r\nset_phys_to_machine(map_ops[i].host_addr >> PAGE_SHIFT,\r\nmap_ops[i].dev_bus_addr >> PAGE_SHIFT);\r\n}\r\nreturn 0;\r\n}\r\nint clear_foreign_p2m_mapping(struct gnttab_unmap_grant_ref *unmap_ops,\r\nstruct gnttab_map_grant_ref *kmap_ops,\r\nstruct page **pages, unsigned int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nset_phys_to_machine(unmap_ops[i].host_addr >> PAGE_SHIFT,\r\nINVALID_P2M_ENTRY);\r\n}\r\nreturn 0;\r\n}\r\nbool __set_phys_to_machine_multi(unsigned long pfn,\r\nunsigned long mfn, unsigned long nr_pages)\r\n{\r\nint rc;\r\nunsigned long irqflags;\r\nstruct xen_p2m_entry *p2m_entry;\r\nstruct rb_node *n = phys_to_mach.rb_node;\r\nif (mfn == INVALID_P2M_ENTRY) {\r\nwrite_lock_irqsave(&p2m_lock, irqflags);\r\nwhile (n) {\r\np2m_entry = rb_entry(n, struct xen_p2m_entry, rbnode_phys);\r\nif (p2m_entry->pfn <= pfn &&\r\np2m_entry->pfn + p2m_entry->nr_pages > pfn) {\r\nrb_erase(&p2m_entry->rbnode_mach, &mach_to_phys);\r\nrb_erase(&p2m_entry->rbnode_phys, &phys_to_mach);\r\nwrite_unlock_irqrestore(&p2m_lock, irqflags);\r\nkfree(p2m_entry);\r\nreturn true;\r\n}\r\nif (pfn < p2m_entry->pfn)\r\nn = n->rb_left;\r\nelse\r\nn = n->rb_right;\r\n}\r\nwrite_unlock_irqrestore(&p2m_lock, irqflags);\r\nreturn true;\r\n}\r\np2m_entry = kzalloc(sizeof(struct xen_p2m_entry), GFP_NOWAIT);\r\nif (!p2m_entry) {\r\npr_warn("cannot allocate xen_p2m_entry\n");\r\nreturn false;\r\n}\r\np2m_entry->pfn = pfn;\r\np2m_entry->nr_pages = nr_pages;\r\np2m_entry->mfn = mfn;\r\nwrite_lock_irqsave(&p2m_lock, irqflags);\r\nif ((rc = xen_add_phys_to_mach_entry(p2m_entry) < 0) ||\r\n(rc = xen_add_mach_to_phys_entry(p2m_entry) < 0)) {\r\nwrite_unlock_irqrestore(&p2m_lock, irqflags);\r\nreturn false;\r\n}\r\nwrite_unlock_irqrestore(&p2m_lock, irqflags);\r\nreturn true;\r\n}\r\nbool __set_phys_to_machine(unsigned long pfn, unsigned long mfn)\r\n{\r\nreturn __set_phys_to_machine_multi(pfn, mfn, 1);\r\n}\r\nstatic int p2m_init(void)\r\n{\r\nrwlock_init(&p2m_lock);\r\nreturn 0;\r\n}
