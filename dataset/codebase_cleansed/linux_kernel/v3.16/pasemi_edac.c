static u32 pasemi_edac_get_error_info(struct mem_ctl_info *mci)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(mci->pdev);\r\nu32 tmp;\r\npci_read_config_dword(pdev, MCDEBUG_ERRSTA,\r\n&tmp);\r\ntmp &= (MCDEBUG_ERRSTA_RFL_STATUS | MCDEBUG_ERRSTA_MBE_STATUS\r\n| MCDEBUG_ERRSTA_SBE_STATUS);\r\nif (tmp) {\r\nif (tmp & MCDEBUG_ERRSTA_SBE_STATUS)\r\npci_write_config_dword(pdev, MCDEBUG_ERRCNT1,\r\nMCDEBUG_ERRCNT1_SBE_CNT_OVRFLO);\r\npci_write_config_dword(pdev, MCDEBUG_ERRSTA, tmp);\r\n}\r\nreturn tmp;\r\n}\r\nstatic void pasemi_edac_process_error_info(struct mem_ctl_info *mci, u32 errsta)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(mci->pdev);\r\nu32 errlog1a;\r\nu32 cs;\r\nif (!errsta)\r\nreturn;\r\npci_read_config_dword(pdev, MCDEBUG_ERRLOG1A, &errlog1a);\r\ncs = (errlog1a & MCDEBUG_ERRLOG1A_MERR_CS_M) >>\r\nMCDEBUG_ERRLOG1A_MERR_CS_S;\r\nif (errsta & (MCDEBUG_ERRSTA_MBE_STATUS |\r\nMCDEBUG_ERRSTA_RFL_STATUS)) {\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\nmci->csrows[cs]->first_page, 0, 0,\r\ncs, 0, -1, mci->ctl_name, "");\r\n}\r\nif (errsta & MCDEBUG_ERRSTA_SBE_STATUS)\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\nmci->csrows[cs]->first_page, 0, 0,\r\ncs, 0, -1, mci->ctl_name, "");\r\n}\r\nstatic void pasemi_edac_check(struct mem_ctl_info *mci)\r\n{\r\nu32 errsta;\r\nerrsta = pasemi_edac_get_error_info(mci);\r\nif (errsta)\r\npasemi_edac_process_error_info(mci, errsta);\r\n}\r\nstatic int pasemi_edac_init_csrows(struct mem_ctl_info *mci,\r\nstruct pci_dev *pdev,\r\nenum edac_type edac_mode)\r\n{\r\nstruct csrow_info *csrow;\r\nstruct dimm_info *dimm;\r\nu32 rankcfg;\r\nint index;\r\nfor (index = 0; index < mci->nr_csrows; index++) {\r\ncsrow = mci->csrows[index];\r\ndimm = csrow->channels[0]->dimm;\r\npci_read_config_dword(pdev,\r\nMCDRAM_RANKCFG + (index * 12),\r\n&rankcfg);\r\nif (!(rankcfg & MCDRAM_RANKCFG_EN))\r\ncontinue;\r\nswitch ((rankcfg & MCDRAM_RANKCFG_TYPE_SIZE_M) >>\r\nMCDRAM_RANKCFG_TYPE_SIZE_S) {\r\ncase 0:\r\ndimm->nr_pages = 128 << (20 - PAGE_SHIFT);\r\nbreak;\r\ncase 1:\r\ndimm->nr_pages = 256 << (20 - PAGE_SHIFT);\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ndimm->nr_pages = 512 << (20 - PAGE_SHIFT);\r\nbreak;\r\ncase 4:\r\ndimm->nr_pages = 1024 << (20 - PAGE_SHIFT);\r\nbreak;\r\ncase 5:\r\ndimm->nr_pages = 2048 << (20 - PAGE_SHIFT);\r\nbreak;\r\ndefault:\r\nedac_mc_printk(mci, KERN_ERR,\r\n"Unrecognized Rank Config. rankcfg=%u\n",\r\nrankcfg);\r\nreturn -EINVAL;\r\n}\r\ncsrow->first_page = last_page_in_mmc;\r\ncsrow->last_page = csrow->first_page + dimm->nr_pages - 1;\r\nlast_page_in_mmc += dimm->nr_pages;\r\ncsrow->page_mask = 0;\r\ndimm->grain = PASEMI_EDAC_ERROR_GRAIN;\r\ndimm->mtype = MEM_DDR;\r\ndimm->dtype = DEV_UNKNOWN;\r\ndimm->edac_mode = edac_mode;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pasemi_edac_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct mem_ctl_info *mci = NULL;\r\nstruct edac_mc_layer layers[2];\r\nu32 errctl1, errcor, scrub, mcen;\r\npci_read_config_dword(pdev, MCCFG_MCEN, &mcen);\r\nif (!(mcen & MCCFG_MCEN_MMC_EN))\r\nreturn -ENODEV;\r\npci_read_config_dword(pdev, MCDEBUG_ERRCTL1, &errctl1);\r\nerrctl1 |= MCDEBUG_ERRCTL1_SBE_LOG_EN |\r\nMCDEBUG_ERRCTL1_MBE_LOG_EN |\r\nMCDEBUG_ERRCTL1_RFL_LOG_EN;\r\npci_write_config_dword(pdev, MCDEBUG_ERRCTL1, errctl1);\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = PASEMI_EDAC_NR_CSROWS;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = PASEMI_EDAC_NR_CHANS;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(system_mmc_id++, ARRAY_SIZE(layers), layers,\r\n0);\r\nif (mci == NULL)\r\nreturn -ENOMEM;\r\npci_read_config_dword(pdev, MCCFG_ERRCOR, &errcor);\r\nerrcor |= MCCFG_ERRCOR_RNK_FAIL_DET_EN |\r\nMCCFG_ERRCOR_ECC_GEN_EN |\r\nMCCFG_ERRCOR_ECC_CRR_EN;\r\nmci->pdev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_DDR | MEM_FLAG_RDDR;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_EC | EDAC_FLAG_SECDED;\r\nmci->edac_cap = (errcor & MCCFG_ERRCOR_ECC_GEN_EN) ?\r\n((errcor & MCCFG_ERRCOR_ECC_CRR_EN) ?\r\n(EDAC_FLAG_EC | EDAC_FLAG_SECDED) : EDAC_FLAG_EC) :\r\nEDAC_FLAG_NONE;\r\nmci->mod_name = MODULE_NAME;\r\nmci->dev_name = pci_name(pdev);\r\nmci->ctl_name = "pasemi,pwrficient-mc";\r\nmci->edac_check = pasemi_edac_check;\r\nmci->ctl_page_to_phys = NULL;\r\npci_read_config_dword(pdev, MCCFG_SCRUB, &scrub);\r\nmci->scrub_cap = SCRUB_FLAG_HW_PROG | SCRUB_FLAG_HW_SRC;\r\nmci->scrub_mode =\r\n((errcor & MCCFG_ERRCOR_ECC_CRR_EN) ? SCRUB_FLAG_HW_SRC : 0) |\r\n((scrub & MCCFG_SCRUB_RGLR_SCRB_EN) ? SCRUB_FLAG_HW_PROG : 0);\r\nif (pasemi_edac_init_csrows(mci, pdev,\r\n(mci->edac_cap & EDAC_FLAG_SECDED) ?\r\nEDAC_SECDED :\r\n((mci->edac_cap & EDAC_FLAG_EC) ?\r\nEDAC_EC : EDAC_NONE)))\r\ngoto fail;\r\npasemi_edac_get_error_info(mci);\r\nif (edac_mc_add_mc(mci))\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nedac_mc_free(mci);\r\nreturn -ENODEV;\r\n}\r\nstatic void pasemi_edac_remove(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci = edac_mc_del_mc(&pdev->dev);\r\nif (!mci)\r\nreturn;\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init pasemi_edac_init(void)\r\n{\r\nopstate_init();\r\nreturn pci_register_driver(&pasemi_edac_driver);\r\n}\r\nstatic void __exit pasemi_edac_exit(void)\r\n{\r\npci_unregister_driver(&pasemi_edac_driver);\r\n}
