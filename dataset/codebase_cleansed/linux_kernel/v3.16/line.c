static irqreturn_t line_interrupt(int irq, void *data)\r\n{\r\nstruct chan *chan = data;\r\nstruct line *line = chan->line;\r\nif (line)\r\nchan_interrupt(line, irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int write_room(struct line *line)\r\n{\r\nint n;\r\nif (line->buffer == NULL)\r\nreturn LINE_BUFSIZE - 1;\r\nn = line->head - line->tail;\r\nif (n <= 0)\r\nn += LINE_BUFSIZE;\r\nreturn n - 1;\r\n}\r\nint line_write_room(struct tty_struct *tty)\r\n{\r\nstruct line *line = tty->driver_data;\r\nunsigned long flags;\r\nint room;\r\nspin_lock_irqsave(&line->lock, flags);\r\nroom = write_room(line);\r\nspin_unlock_irqrestore(&line->lock, flags);\r\nreturn room;\r\n}\r\nint line_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct line *line = tty->driver_data;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&line->lock, flags);\r\nret = LINE_BUFSIZE - (write_room(line) + 1);\r\nspin_unlock_irqrestore(&line->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int buffer_data(struct line *line, const char *buf, int len)\r\n{\r\nint end, room;\r\nif (line->buffer == NULL) {\r\nline->buffer = kmalloc(LINE_BUFSIZE, GFP_ATOMIC);\r\nif (line->buffer == NULL) {\r\nprintk(KERN_ERR "buffer_data - atomic allocation "\r\n"failed\n");\r\nreturn 0;\r\n}\r\nline->head = line->buffer;\r\nline->tail = line->buffer;\r\n}\r\nroom = write_room(line);\r\nlen = (len > room) ? room : len;\r\nend = line->buffer + LINE_BUFSIZE - line->tail;\r\nif (len < end) {\r\nmemcpy(line->tail, buf, len);\r\nline->tail += len;\r\n}\r\nelse {\r\nmemcpy(line->tail, buf, end);\r\nbuf += end;\r\nmemcpy(line->buffer, buf, len - end);\r\nline->tail = line->buffer + len - end;\r\n}\r\nreturn len;\r\n}\r\nstatic int flush_buffer(struct line *line)\r\n{\r\nint n, count;\r\nif ((line->buffer == NULL) || (line->head == line->tail))\r\nreturn 1;\r\nif (line->tail < line->head) {\r\ncount = line->buffer + LINE_BUFSIZE - line->head;\r\nn = write_chan(line->chan_out, line->head, count,\r\nline->driver->write_irq);\r\nif (n < 0)\r\nreturn n;\r\nif (n == count) {\r\nline->head = line->buffer;\r\n} else {\r\nline->head += n;\r\nreturn 0;\r\n}\r\n}\r\ncount = line->tail - line->head;\r\nn = write_chan(line->chan_out, line->head, count,\r\nline->driver->write_irq);\r\nif (n < 0)\r\nreturn n;\r\nline->head += n;\r\nreturn line->head == line->tail;\r\n}\r\nvoid line_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct line *line = tty->driver_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&line->lock, flags);\r\nflush_buffer(line);\r\nspin_unlock_irqrestore(&line->lock, flags);\r\n}\r\nvoid line_flush_chars(struct tty_struct *tty)\r\n{\r\nline_flush_buffer(tty);\r\n}\r\nint line_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nreturn line_write(tty, &ch, sizeof(ch));\r\n}\r\nint line_write(struct tty_struct *tty, const unsigned char *buf, int len)\r\n{\r\nstruct line *line = tty->driver_data;\r\nunsigned long flags;\r\nint n, ret = 0;\r\nspin_lock_irqsave(&line->lock, flags);\r\nif (line->head != line->tail)\r\nret = buffer_data(line, buf, len);\r\nelse {\r\nn = write_chan(line->chan_out, buf, len,\r\nline->driver->write_irq);\r\nif (n < 0) {\r\nret = n;\r\ngoto out_up;\r\n}\r\nlen -= n;\r\nret += n;\r\nif (len > 0)\r\nret += buffer_data(line, buf + n, len);\r\n}\r\nout_up:\r\nspin_unlock_irqrestore(&line->lock, flags);\r\nreturn ret;\r\n}\r\nvoid line_set_termios(struct tty_struct *tty, struct ktermios * old)\r\n{\r\n}\r\nvoid line_throttle(struct tty_struct *tty)\r\n{\r\nstruct line *line = tty->driver_data;\r\ndeactivate_chan(line->chan_in, line->driver->read_irq);\r\nline->throttled = 1;\r\n}\r\nvoid line_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct line *line = tty->driver_data;\r\nline->throttled = 0;\r\nchan_interrupt(line, line->driver->read_irq);\r\nif (!line->throttled)\r\nreactivate_chan(line->chan_in, line->driver->read_irq);\r\n}\r\nstatic irqreturn_t line_write_interrupt(int irq, void *data)\r\n{\r\nstruct chan *chan = data;\r\nstruct line *line = chan->line;\r\nint err;\r\nspin_lock(&line->lock);\r\nerr = flush_buffer(line);\r\nif (err == 0) {\r\nspin_unlock(&line->lock);\r\nreturn IRQ_NONE;\r\n} else if (err < 0) {\r\nline->head = line->buffer;\r\nline->tail = line->buffer;\r\n}\r\nspin_unlock(&line->lock);\r\ntty_port_tty_wakeup(&line->port);\r\nreturn IRQ_HANDLED;\r\n}\r\nint line_setup_irq(int fd, int input, int output, struct line *line, void *data)\r\n{\r\nconst struct line_driver *driver = line->driver;\r\nint err = 0;\r\nif (input)\r\nerr = um_request_irq(driver->read_irq, fd, IRQ_READ,\r\nline_interrupt, IRQF_SHARED,\r\ndriver->read_irq_name, data);\r\nif (err)\r\nreturn err;\r\nif (output)\r\nerr = um_request_irq(driver->write_irq, fd, IRQ_WRITE,\r\nline_write_interrupt, IRQF_SHARED,\r\ndriver->write_irq_name, data);\r\nreturn err;\r\n}\r\nstatic int line_activate(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nint ret;\r\nstruct line *line = tty->driver_data;\r\nret = enable_chan(line);\r\nif (ret)\r\nreturn ret;\r\nif (!line->sigio) {\r\nchan_enable_winch(line->chan_out, port);\r\nline->sigio = 1;\r\n}\r\nchan_window_size(line, &tty->winsize.ws_row,\r\n&tty->winsize.ws_col);\r\nreturn 0;\r\n}\r\nstatic void line_destruct(struct tty_port *port)\r\n{\r\nstruct tty_struct *tty = tty_port_tty_get(port);\r\nstruct line *line = tty->driver_data;\r\nif (line->sigio) {\r\nunregister_winch(tty);\r\nline->sigio = 0;\r\n}\r\n}\r\nint line_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct line *line = tty->driver_data;\r\nreturn tty_port_open(&line->port, tty, filp);\r\n}\r\nint line_install(struct tty_driver *driver, struct tty_struct *tty,\r\nstruct line *line)\r\n{\r\nint ret;\r\nret = tty_standard_install(driver, tty);\r\nif (ret)\r\nreturn ret;\r\ntty->driver_data = line;\r\nreturn 0;\r\n}\r\nvoid line_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct line *line = tty->driver_data;\r\ntty_port_close(&line->port, tty, filp);\r\n}\r\nvoid line_hangup(struct tty_struct *tty)\r\n{\r\nstruct line *line = tty->driver_data;\r\ntty_port_hangup(&line->port);\r\n}\r\nvoid close_lines(struct line *lines, int nlines)\r\n{\r\nint i;\r\nfor(i = 0; i < nlines; i++)\r\nclose_chan(&lines[i]);\r\n}\r\nint setup_one_line(struct line *lines, int n, char *init,\r\nconst struct chan_opts *opts, char **error_out)\r\n{\r\nstruct line *line = &lines[n];\r\nstruct tty_driver *driver = line->driver->driver;\r\nint err = -EINVAL;\r\nif (line->port.count) {\r\n*error_out = "Device is already open";\r\ngoto out;\r\n}\r\nif (!strcmp(init, "none")) {\r\nif (line->valid) {\r\nline->valid = 0;\r\nkfree(line->init_str);\r\ntty_unregister_device(driver, n);\r\nparse_chan_pair(NULL, line, n, opts, error_out);\r\nerr = 0;\r\n}\r\n} else {\r\nchar *new = kstrdup(init, GFP_KERNEL);\r\nif (!new) {\r\n*error_out = "Failed to allocate memory";\r\nreturn -ENOMEM;\r\n}\r\nif (line->valid) {\r\ntty_unregister_device(driver, n);\r\nkfree(line->init_str);\r\n}\r\nline->init_str = new;\r\nline->valid = 1;\r\nerr = parse_chan_pair(new, line, n, opts, error_out);\r\nif (!err) {\r\nstruct device *d = tty_port_register_device(&line->port,\r\ndriver, n, NULL);\r\nif (IS_ERR(d)) {\r\n*error_out = "Failed to register device";\r\nerr = PTR_ERR(d);\r\nparse_chan_pair(NULL, line, n, opts, error_out);\r\n}\r\n}\r\nif (err) {\r\nline->init_str = NULL;\r\nline->valid = 0;\r\nkfree(new);\r\n}\r\n}\r\nout:\r\nreturn err;\r\n}\r\nint line_setup(char **conf, unsigned int num, char **def,\r\nchar *init, char *name)\r\n{\r\nchar *error;\r\nif (*init == '=') {\r\n*def = init + 1;\r\n} else {\r\nchar *end;\r\nunsigned n = simple_strtoul(init, &end, 0);\r\nif (*end != '=') {\r\nerror = "Couldn't parse device number";\r\ngoto out;\r\n}\r\nif (n >= num) {\r\nerror = "Device number out of range";\r\ngoto out;\r\n}\r\nconf[n] = end + 1;\r\n}\r\nreturn 0;\r\nout:\r\nprintk(KERN_ERR "Failed to set up %s with "\r\n"configuration string \"%s\" : %s\n", name, init, error);\r\nreturn -EINVAL;\r\n}\r\nint line_config(struct line *lines, unsigned int num, char *str,\r\nconst struct chan_opts *opts, char **error_out)\r\n{\r\nchar *end;\r\nint n;\r\nif (*str == '=') {\r\n*error_out = "Can't configure all devices from mconsole";\r\nreturn -EINVAL;\r\n}\r\nn = simple_strtoul(str, &end, 0);\r\nif (*end++ != '=') {\r\n*error_out = "Couldn't parse device number";\r\nreturn -EINVAL;\r\n}\r\nif (n >= num) {\r\n*error_out = "Device number out of range";\r\nreturn -EINVAL;\r\n}\r\nreturn setup_one_line(lines, n, end, opts, error_out);\r\n}\r\nint line_get_config(char *name, struct line *lines, unsigned int num, char *str,\r\nint size, char **error_out)\r\n{\r\nstruct line *line;\r\nchar *end;\r\nint dev, n = 0;\r\ndev = simple_strtoul(name, &end, 0);\r\nif ((*end != '\0') || (end == name)) {\r\n*error_out = "line_get_config failed to parse device number";\r\nreturn 0;\r\n}\r\nif ((dev < 0) || (dev >= num)) {\r\n*error_out = "device number out of range";\r\nreturn 0;\r\n}\r\nline = &lines[dev];\r\nif (!line->valid)\r\nCONFIG_CHUNK(str, size, n, "none", 1);\r\nelse {\r\nstruct tty_struct *tty = tty_port_tty_get(&line->port);\r\nif (tty == NULL) {\r\nCONFIG_CHUNK(str, size, n, line->init_str, 1);\r\n} else {\r\nn = chan_config_string(line, str, size, error_out);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nreturn n;\r\n}\r\nint line_id(char **str, int *start_out, int *end_out)\r\n{\r\nchar *end;\r\nint n;\r\nn = simple_strtoul(*str, &end, 0);\r\nif ((*end != '\0') || (end == *str))\r\nreturn -1;\r\n*str = end;\r\n*start_out = n;\r\n*end_out = n;\r\nreturn n;\r\n}\r\nint line_remove(struct line *lines, unsigned int num, int n, char **error_out)\r\n{\r\nif (n >= num) {\r\n*error_out = "Device number out of range";\r\nreturn -EINVAL;\r\n}\r\nreturn setup_one_line(lines, n, "none", NULL, error_out);\r\n}\r\nint register_lines(struct line_driver *line_driver,\r\nconst struct tty_operations *ops,\r\nstruct line *lines, int nlines)\r\n{\r\nstruct tty_driver *driver = alloc_tty_driver(nlines);\r\nint err;\r\nint i;\r\nif (!driver)\r\nreturn -ENOMEM;\r\ndriver->driver_name = line_driver->name;\r\ndriver->name = line_driver->device_name;\r\ndriver->major = line_driver->major;\r\ndriver->minor_start = line_driver->minor_start;\r\ndriver->type = line_driver->type;\r\ndriver->subtype = line_driver->subtype;\r\ndriver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\ndriver->init_termios = tty_std_termios;\r\nfor (i = 0; i < nlines; i++) {\r\ntty_port_init(&lines[i].port);\r\nlines[i].port.ops = &line_port_ops;\r\nspin_lock_init(&lines[i].lock);\r\nlines[i].driver = line_driver;\r\nINIT_LIST_HEAD(&lines[i].chan_list);\r\n}\r\ntty_set_operations(driver, ops);\r\nerr = tty_register_driver(driver);\r\nif (err) {\r\nprintk(KERN_ERR "register_lines : can't register %s driver\n",\r\nline_driver->name);\r\nput_tty_driver(driver);\r\nfor (i = 0; i < nlines; i++)\r\ntty_port_destroy(&lines[i].port);\r\nreturn err;\r\n}\r\nline_driver->driver = driver;\r\nmconsole_register_dev(&line_driver->mc);\r\nreturn 0;\r\n}\r\nstatic void __free_winch(struct work_struct *work)\r\n{\r\nstruct winch *winch = container_of(work, struct winch, work);\r\num_free_irq(WINCH_IRQ, winch);\r\nif (winch->pid != -1)\r\nos_kill_process(winch->pid, 1);\r\nif (winch->stack != 0)\r\nfree_stack(winch->stack, 0);\r\nkfree(winch);\r\n}\r\nstatic void free_winch(struct winch *winch)\r\n{\r\nint fd = winch->fd;\r\nwinch->fd = -1;\r\nif (fd != -1)\r\nos_close_file(fd);\r\nlist_del(&winch->list);\r\n__free_winch(&winch->work);\r\n}\r\nstatic irqreturn_t winch_interrupt(int irq, void *data)\r\n{\r\nstruct winch *winch = data;\r\nstruct tty_struct *tty;\r\nstruct line *line;\r\nint fd = winch->fd;\r\nint err;\r\nchar c;\r\nif (fd != -1) {\r\nerr = generic_read(fd, &c, NULL);\r\nif (err < 0) {\r\nif (err != -EAGAIN) {\r\nwinch->fd = -1;\r\nlist_del(&winch->list);\r\nos_close_file(fd);\r\nprintk(KERN_ERR "winch_interrupt : "\r\n"read failed, errno = %d\n", -err);\r\nprintk(KERN_ERR "fd %d is losing SIGWINCH "\r\n"support\n", winch->tty_fd);\r\nINIT_WORK(&winch->work, __free_winch);\r\nschedule_work(&winch->work);\r\nreturn IRQ_HANDLED;\r\n}\r\ngoto out;\r\n}\r\n}\r\ntty = tty_port_tty_get(winch->port);\r\nif (tty != NULL) {\r\nline = tty->driver_data;\r\nif (line != NULL) {\r\nchan_window_size(line, &tty->winsize.ws_row,\r\n&tty->winsize.ws_col);\r\nkill_pgrp(tty->pgrp, SIGWINCH, 1);\r\n}\r\ntty_kref_put(tty);\r\n}\r\nout:\r\nif (winch->fd != -1)\r\nreactivate_fd(winch->fd, WINCH_IRQ);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid register_winch_irq(int fd, int tty_fd, int pid, struct tty_port *port,\r\nunsigned long stack)\r\n{\r\nstruct winch *winch;\r\nwinch = kmalloc(sizeof(*winch), GFP_KERNEL);\r\nif (winch == NULL) {\r\nprintk(KERN_ERR "register_winch_irq - kmalloc failed\n");\r\ngoto cleanup;\r\n}\r\n*winch = ((struct winch) { .list = LIST_HEAD_INIT(winch->list),\r\n.fd = fd,\r\n.tty_fd = tty_fd,\r\n.pid = pid,\r\n.port = port,\r\n.stack = stack });\r\nif (um_request_irq(WINCH_IRQ, fd, IRQ_READ, winch_interrupt,\r\nIRQF_SHARED, "winch", winch) < 0) {\r\nprintk(KERN_ERR "register_winch_irq - failed to register "\r\n"IRQ\n");\r\ngoto out_free;\r\n}\r\nspin_lock(&winch_handler_lock);\r\nlist_add(&winch->list, &winch_handlers);\r\nspin_unlock(&winch_handler_lock);\r\nreturn;\r\nout_free:\r\nkfree(winch);\r\ncleanup:\r\nos_kill_process(pid, 1);\r\nos_close_file(fd);\r\nif (stack != 0)\r\nfree_stack(stack, 0);\r\n}\r\nstatic void unregister_winch(struct tty_struct *tty)\r\n{\r\nstruct list_head *ele, *next;\r\nstruct winch *winch;\r\nstruct tty_struct *wtty;\r\nspin_lock(&winch_handler_lock);\r\nlist_for_each_safe(ele, next, &winch_handlers) {\r\nwinch = list_entry(ele, struct winch, list);\r\nwtty = tty_port_tty_get(winch->port);\r\nif (wtty == tty) {\r\nfree_winch(winch);\r\nbreak;\r\n}\r\ntty_kref_put(wtty);\r\n}\r\nspin_unlock(&winch_handler_lock);\r\n}\r\nstatic void winch_cleanup(void)\r\n{\r\nstruct list_head *ele, *next;\r\nstruct winch *winch;\r\nspin_lock(&winch_handler_lock);\r\nlist_for_each_safe(ele, next, &winch_handlers) {\r\nwinch = list_entry(ele, struct winch, list);\r\nfree_winch(winch);\r\n}\r\nspin_unlock(&winch_handler_lock);\r\n}\r\nchar *add_xterm_umid(char *base)\r\n{\r\nchar *umid, *title;\r\nint len;\r\numid = get_umid();\r\nif (*umid == '\0')\r\nreturn base;\r\nlen = strlen(base) + strlen(" ()") + strlen(umid) + 1;\r\ntitle = kmalloc(len, GFP_KERNEL);\r\nif (title == NULL) {\r\nprintk(KERN_ERR "Failed to allocate buffer for xterm title\n");\r\nreturn base;\r\n}\r\nsnprintf(title, len, "%s (%s)", base, umid);\r\nreturn title;\r\n}
