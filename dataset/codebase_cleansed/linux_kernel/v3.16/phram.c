static int phram_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nu_char *start = mtd->priv;\r\nmemset(start + instr->addr, 0xff, instr->len);\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nstatic int phram_point(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, void **virt, resource_size_t *phys)\r\n{\r\n*virt = mtd->priv + from;\r\n*retlen = len;\r\nreturn 0;\r\n}\r\nstatic int phram_unpoint(struct mtd_info *mtd, loff_t from, size_t len)\r\n{\r\nreturn 0;\r\n}\r\nstatic int phram_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nu_char *start = mtd->priv;\r\nmemcpy(buf, start + from, len);\r\n*retlen = len;\r\nreturn 0;\r\n}\r\nstatic int phram_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nu_char *start = mtd->priv;\r\nmemcpy(start + to, buf, len);\r\n*retlen = len;\r\nreturn 0;\r\n}\r\nstatic void unregister_devices(void)\r\n{\r\nstruct phram_mtd_list *this, *safe;\r\nlist_for_each_entry_safe(this, safe, &phram_list, list) {\r\nmtd_device_unregister(&this->mtd);\r\niounmap(this->mtd.priv);\r\nkfree(this->mtd.name);\r\nkfree(this);\r\n}\r\n}\r\nstatic int register_device(char *name, phys_addr_t start, size_t len)\r\n{\r\nstruct phram_mtd_list *new;\r\nint ret = -ENOMEM;\r\nnew = kzalloc(sizeof(*new), GFP_KERNEL);\r\nif (!new)\r\ngoto out0;\r\nret = -EIO;\r\nnew->mtd.priv = ioremap(start, len);\r\nif (!new->mtd.priv) {\r\npr_err("ioremap failed\n");\r\ngoto out1;\r\n}\r\nnew->mtd.name = name;\r\nnew->mtd.size = len;\r\nnew->mtd.flags = MTD_CAP_RAM;\r\nnew->mtd._erase = phram_erase;\r\nnew->mtd._point = phram_point;\r\nnew->mtd._unpoint = phram_unpoint;\r\nnew->mtd._read = phram_read;\r\nnew->mtd._write = phram_write;\r\nnew->mtd.owner = THIS_MODULE;\r\nnew->mtd.type = MTD_RAM;\r\nnew->mtd.erasesize = PAGE_SIZE;\r\nnew->mtd.writesize = 1;\r\nret = -EAGAIN;\r\nif (mtd_device_register(&new->mtd, NULL, 0)) {\r\npr_err("Failed to register new device\n");\r\ngoto out2;\r\n}\r\nlist_add_tail(&new->list, &phram_list);\r\nreturn 0;\r\nout2:\r\niounmap(new->mtd.priv);\r\nout1:\r\nkfree(new);\r\nout0:\r\nreturn ret;\r\n}\r\nstatic int parse_num64(uint64_t *num64, char *token)\r\n{\r\nsize_t len;\r\nint shift = 0;\r\nint ret;\r\nlen = strlen(token);\r\nif (len > 2) {\r\nif (token[len - 1] == 'i') {\r\nswitch (token[len - 2]) {\r\ncase 'G':\r\nshift += 10;\r\ncase 'M':\r\nshift += 10;\r\ncase 'k':\r\nshift += 10;\r\ntoken[len - 2] = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nret = kstrtou64(token, 0, num64);\r\n*num64 <<= shift;\r\nreturn ret;\r\n}\r\nstatic int parse_name(char **pname, const char *token)\r\n{\r\nsize_t len;\r\nchar *name;\r\nlen = strlen(token) + 1;\r\nif (len > 64)\r\nreturn -ENOSPC;\r\nname = kmalloc(len, GFP_KERNEL);\r\nif (!name)\r\nreturn -ENOMEM;\r\nstrcpy(name, token);\r\n*pname = name;\r\nreturn 0;\r\n}\r\nstatic inline void kill_final_newline(char *str)\r\n{\r\nchar *newline = strrchr(str, '\n');\r\nif (newline && !newline[1])\r\n*newline = 0;\r\n}\r\nstatic int phram_setup(const char *val)\r\n{\r\nchar buf[64 + 20 + 20], *str = buf;\r\nchar *token[3];\r\nchar *name;\r\nuint64_t start;\r\nuint64_t len;\r\nint i, ret;\r\nif (strnlen(val, sizeof(buf)) >= sizeof(buf))\r\nparse_err("parameter too long\n");\r\nstrcpy(str, val);\r\nkill_final_newline(str);\r\nfor (i=0; i<3; i++)\r\ntoken[i] = strsep(&str, ",");\r\nif (str)\r\nparse_err("too many arguments\n");\r\nif (!token[2])\r\nparse_err("not enough arguments\n");\r\nret = parse_name(&name, token[0]);\r\nif (ret)\r\nreturn ret;\r\nret = parse_num64(&start, token[1]);\r\nif (ret) {\r\nkfree(name);\r\nparse_err("illegal start address\n");\r\n}\r\nret = parse_num64(&len, token[2]);\r\nif (ret) {\r\nkfree(name);\r\nparse_err("illegal device length\n");\r\n}\r\nret = register_device(name, start, len);\r\nif (!ret)\r\npr_info("%s device: %#llx at %#llx\n", name, len, start);\r\nelse\r\nkfree(name);\r\nreturn ret;\r\n}\r\nstatic int phram_param_call(const char *val, struct kernel_param *kp)\r\n{\r\n#ifdef MODULE\r\nreturn phram_setup(val);\r\n#else\r\nif (phram_init_called)\r\nreturn phram_setup(val);\r\nif (strlen(val) >= sizeof(phram_paramline))\r\nreturn -ENOSPC;\r\nstrcpy(phram_paramline, val);\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int __init init_phram(void)\r\n{\r\nint ret = 0;\r\n#ifndef MODULE\r\nif (phram_paramline[0])\r\nret = phram_setup(phram_paramline);\r\nphram_init_called = 1;\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit cleanup_phram(void)\r\n{\r\nunregister_devices();\r\n}
