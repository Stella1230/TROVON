int register_acpi_bus_type(struct acpi_bus_type *type)\r\n{\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nif (type && type->match && type->find_companion) {\r\ndown_write(&bus_type_sem);\r\nlist_add_tail(&type->list, &bus_type_list);\r\nup_write(&bus_type_sem);\r\nprintk(KERN_INFO PREFIX "bus type %s registered\n", type->name);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint unregister_acpi_bus_type(struct acpi_bus_type *type)\r\n{\r\nif (acpi_disabled)\r\nreturn 0;\r\nif (type) {\r\ndown_write(&bus_type_sem);\r\nlist_del_init(&type->list);\r\nup_write(&bus_type_sem);\r\nprintk(KERN_INFO PREFIX "bus type %s unregistered\n",\r\ntype->name);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic struct acpi_bus_type *acpi_get_bus_type(struct device *dev)\r\n{\r\nstruct acpi_bus_type *tmp, *ret = NULL;\r\ndown_read(&bus_type_sem);\r\nlist_for_each_entry(tmp, &bus_type_list, list) {\r\nif (tmp->match(dev)) {\r\nret = tmp;\r\nbreak;\r\n}\r\n}\r\nup_read(&bus_type_sem);\r\nreturn ret;\r\n}\r\nstatic int find_child_checks(struct acpi_device *adev, bool check_children)\r\n{\r\nbool sta_present = true;\r\nunsigned long long sta;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(adev->handle, "_STA", NULL, &sta);\r\nif (status == AE_NOT_FOUND)\r\nsta_present = false;\r\nelse if (ACPI_FAILURE(status) || !(sta & ACPI_STA_DEVICE_ENABLED))\r\nreturn -ENODEV;\r\nif (check_children && list_empty(&adev->children))\r\nreturn -ENODEV;\r\nreturn sta_present ? FIND_CHILD_MAX_SCORE : FIND_CHILD_MIN_SCORE;\r\n}\r\nstruct acpi_device *acpi_find_child_device(struct acpi_device *parent,\r\nu64 address, bool check_children)\r\n{\r\nstruct acpi_device *adev, *ret = NULL;\r\nint ret_score = 0;\r\nif (!parent)\r\nreturn NULL;\r\nlist_for_each_entry(adev, &parent->children, node) {\r\nunsigned long long addr;\r\nacpi_status status;\r\nint score;\r\nstatus = acpi_evaluate_integer(adev->handle, METHOD_NAME__ADR,\r\nNULL, &addr);\r\nif (ACPI_FAILURE(status) || addr != address)\r\ncontinue;\r\nif (!ret) {\r\nret = adev;\r\ncontinue;\r\n}\r\nif (!ret_score) {\r\nret_score = find_child_checks(ret, check_children);\r\nif (ret_score == FIND_CHILD_MAX_SCORE)\r\nreturn ret;\r\n}\r\nscore = find_child_checks(adev, check_children);\r\nif (score == FIND_CHILD_MAX_SCORE) {\r\nreturn adev;\r\n} else if (score > ret_score) {\r\nret = adev;\r\nret_score = score;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void acpi_physnode_link_name(char *buf, unsigned int node_id)\r\n{\r\nif (node_id > 0)\r\nsnprintf(buf, PHYSICAL_NODE_NAME_SIZE,\r\nPHYSICAL_NODE_STRING "%u", node_id);\r\nelse\r\nstrcpy(buf, PHYSICAL_NODE_STRING);\r\n}\r\nint acpi_bind_one(struct device *dev, struct acpi_device *acpi_dev)\r\n{\r\nstruct acpi_device_physical_node *physical_node, *pn;\r\nchar physical_node_name[PHYSICAL_NODE_NAME_SIZE];\r\nstruct list_head *physnode_list;\r\nunsigned int node_id;\r\nint retval = -EINVAL;\r\nif (ACPI_COMPANION(dev)) {\r\nif (acpi_dev) {\r\ndev_warn(dev, "ACPI companion already set\n");\r\nreturn -EINVAL;\r\n} else {\r\nacpi_dev = ACPI_COMPANION(dev);\r\n}\r\n}\r\nif (!acpi_dev)\r\nreturn -EINVAL;\r\nget_device(&acpi_dev->dev);\r\nget_device(dev);\r\nphysical_node = kzalloc(sizeof(*physical_node), GFP_KERNEL);\r\nif (!physical_node) {\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\nmutex_lock(&acpi_dev->physical_node_lock);\r\nphysnode_list = &acpi_dev->physical_node_list;\r\nnode_id = 0;\r\nlist_for_each_entry(pn, &acpi_dev->physical_node_list, node) {\r\nif (pn->dev == dev) {\r\nmutex_unlock(&acpi_dev->physical_node_lock);\r\ndev_warn(dev, "Already associated with ACPI node\n");\r\nkfree(physical_node);\r\nif (ACPI_COMPANION(dev) != acpi_dev)\r\ngoto err;\r\nput_device(dev);\r\nput_device(&acpi_dev->dev);\r\nreturn 0;\r\n}\r\nif (pn->node_id == node_id) {\r\nphysnode_list = &pn->node;\r\nnode_id++;\r\n}\r\n}\r\nphysical_node->node_id = node_id;\r\nphysical_node->dev = dev;\r\nlist_add(&physical_node->node, physnode_list);\r\nacpi_dev->physical_node_count++;\r\nif (!ACPI_COMPANION(dev))\r\nACPI_COMPANION_SET(dev, acpi_dev);\r\nacpi_physnode_link_name(physical_node_name, node_id);\r\nretval = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,\r\nphysical_node_name);\r\nif (retval)\r\ndev_err(&acpi_dev->dev, "Failed to create link %s (%d)\n",\r\nphysical_node_name, retval);\r\nretval = sysfs_create_link(&dev->kobj, &acpi_dev->dev.kobj,\r\n"firmware_node");\r\nif (retval)\r\ndev_err(dev, "Failed to create link firmware_node (%d)\n",\r\nretval);\r\nmutex_unlock(&acpi_dev->physical_node_lock);\r\nif (acpi_dev->wakeup.flags.valid)\r\ndevice_set_wakeup_capable(dev, true);\r\nreturn 0;\r\nerr:\r\nACPI_COMPANION_SET(dev, NULL);\r\nput_device(dev);\r\nput_device(&acpi_dev->dev);\r\nreturn retval;\r\n}\r\nint acpi_unbind_one(struct device *dev)\r\n{\r\nstruct acpi_device *acpi_dev = ACPI_COMPANION(dev);\r\nstruct acpi_device_physical_node *entry;\r\nif (!acpi_dev)\r\nreturn 0;\r\nmutex_lock(&acpi_dev->physical_node_lock);\r\nlist_for_each_entry(entry, &acpi_dev->physical_node_list, node)\r\nif (entry->dev == dev) {\r\nchar physnode_name[PHYSICAL_NODE_NAME_SIZE];\r\nlist_del(&entry->node);\r\nacpi_dev->physical_node_count--;\r\nacpi_physnode_link_name(physnode_name, entry->node_id);\r\nsysfs_remove_link(&acpi_dev->dev.kobj, physnode_name);\r\nsysfs_remove_link(&dev->kobj, "firmware_node");\r\nACPI_COMPANION_SET(dev, NULL);\r\nput_device(dev);\r\nput_device(&acpi_dev->dev);\r\nkfree(entry);\r\nbreak;\r\n}\r\nmutex_unlock(&acpi_dev->physical_node_lock);\r\nreturn 0;\r\n}\r\nstatic int acpi_platform_notify(struct device *dev)\r\n{\r\nstruct acpi_bus_type *type = acpi_get_bus_type(dev);\r\nstruct acpi_device *adev;\r\nint ret;\r\nret = acpi_bind_one(dev, NULL);\r\nif (ret && type) {\r\nstruct acpi_device *adev;\r\nadev = type->find_companion(dev);\r\nif (!adev) {\r\nDBG("Unable to get handle for %s\n", dev_name(dev));\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nret = acpi_bind_one(dev, adev);\r\nif (ret)\r\ngoto out;\r\n}\r\nadev = ACPI_COMPANION(dev);\r\nif (!adev)\r\ngoto out;\r\nif (type && type->setup)\r\ntype->setup(dev);\r\nelse if (adev->handler && adev->handler->bind)\r\nadev->handler->bind(dev);\r\nout:\r\n#if ACPI_GLUE_DEBUG\r\nif (!ret) {\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nacpi_get_name(ACPI_HANDLE(dev), ACPI_FULL_PATHNAME, &buffer);\r\nDBG("Device %s -> %s\n", dev_name(dev), (char *)buffer.pointer);\r\nkfree(buffer.pointer);\r\n} else\r\nDBG("Device %s -> No ACPI support\n", dev_name(dev));\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int acpi_platform_notify_remove(struct device *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nstruct acpi_bus_type *type;\r\nif (!adev)\r\nreturn 0;\r\ntype = acpi_get_bus_type(dev);\r\nif (type && type->cleanup)\r\ntype->cleanup(dev);\r\nelse if (adev->handler && adev->handler->unbind)\r\nadev->handler->unbind(dev);\r\nacpi_unbind_one(dev);\r\nreturn 0;\r\n}\r\nint __init init_acpi_device_notify(void)\r\n{\r\nif (platform_notify || platform_notify_remove) {\r\nprintk(KERN_ERR PREFIX "Can't use platform_notify\n");\r\nreturn 0;\r\n}\r\nplatform_notify = acpi_platform_notify;\r\nplatform_notify_remove = acpi_platform_notify_remove;\r\nreturn 0;\r\n}
