static bool\r\nquota_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct xt_quota_info *q = (void *)par->matchinfo;\r\nstruct xt_quota_priv *priv = q->master;\r\nbool ret = q->flags & XT_QUOTA_INVERT;\r\nspin_lock_bh(&priv->lock);\r\nif (priv->quota >= skb->len) {\r\npriv->quota -= skb->len;\r\nret = !ret;\r\n} else {\r\npriv->quota = 0;\r\n}\r\nspin_unlock_bh(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int quota_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nstruct xt_quota_info *q = par->matchinfo;\r\nif (q->flags & ~XT_QUOTA_MASK)\r\nreturn -EINVAL;\r\nq->master = kmalloc(sizeof(*q->master), GFP_KERNEL);\r\nif (q->master == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&q->master->lock);\r\nq->master->quota = q->quota;\r\nreturn 0;\r\n}\r\nstatic void quota_mt_destroy(const struct xt_mtdtor_param *par)\r\n{\r\nconst struct xt_quota_info *q = par->matchinfo;\r\nkfree(q->master);\r\n}\r\nstatic int __init quota_mt_init(void)\r\n{\r\nreturn xt_register_match(&quota_mt_reg);\r\n}\r\nstatic void __exit quota_mt_exit(void)\r\n{\r\nxt_unregister_match(&quota_mt_reg);\r\n}
