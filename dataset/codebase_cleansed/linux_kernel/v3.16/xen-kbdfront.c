static irqreturn_t input_handler(int rq, void *dev_id)\r\n{\r\nstruct xenkbd_info *info = dev_id;\r\nstruct xenkbd_page *page = info->page;\r\n__u32 cons, prod;\r\nprod = page->in_prod;\r\nif (prod == page->in_cons)\r\nreturn IRQ_HANDLED;\r\nrmb();\r\nfor (cons = page->in_cons; cons != prod; cons++) {\r\nunion xenkbd_in_event *event;\r\nstruct input_dev *dev;\r\nevent = &XENKBD_IN_RING_REF(page, cons);\r\ndev = info->ptr;\r\nswitch (event->type) {\r\ncase XENKBD_TYPE_MOTION:\r\ninput_report_rel(dev, REL_X, event->motion.rel_x);\r\ninput_report_rel(dev, REL_Y, event->motion.rel_y);\r\nif (event->motion.rel_z)\r\ninput_report_rel(dev, REL_WHEEL,\r\n-event->motion.rel_z);\r\nbreak;\r\ncase XENKBD_TYPE_KEY:\r\ndev = NULL;\r\nif (test_bit(event->key.keycode, info->kbd->keybit))\r\ndev = info->kbd;\r\nif (test_bit(event->key.keycode, info->ptr->keybit))\r\ndev = info->ptr;\r\nif (dev)\r\ninput_report_key(dev, event->key.keycode,\r\nevent->key.pressed);\r\nelse\r\npr_warning("unhandled keycode 0x%x\n",\r\nevent->key.keycode);\r\nbreak;\r\ncase XENKBD_TYPE_POS:\r\ninput_report_abs(dev, ABS_X, event->pos.abs_x);\r\ninput_report_abs(dev, ABS_Y, event->pos.abs_y);\r\nif (event->pos.rel_z)\r\ninput_report_rel(dev, REL_WHEEL,\r\n-event->pos.rel_z);\r\nbreak;\r\n}\r\nif (dev)\r\ninput_sync(dev);\r\n}\r\nmb();\r\npage->in_cons = cons;\r\nnotify_remote_via_irq(info->irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int xenkbd_probe(struct xenbus_device *dev,\r\nconst struct xenbus_device_id *id)\r\n{\r\nint ret, i, abs;\r\nstruct xenkbd_info *info;\r\nstruct input_dev *kbd, *ptr;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\nxenbus_dev_fatal(dev, -ENOMEM, "allocating info structure");\r\nreturn -ENOMEM;\r\n}\r\ndev_set_drvdata(&dev->dev, info);\r\ninfo->xbdev = dev;\r\ninfo->irq = -1;\r\ninfo->gref = -1;\r\nsnprintf(info->phys, sizeof(info->phys), "xenbus/%s", dev->nodename);\r\ninfo->page = (void *)__get_free_page(GFP_KERNEL | __GFP_ZERO);\r\nif (!info->page)\r\ngoto error_nomem;\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-abs-pointer", "%d", &abs) < 0)\r\nabs = 0;\r\nif (abs)\r\nxenbus_printf(XBT_NIL, dev->nodename, "request-abs-pointer", "1");\r\nkbd = input_allocate_device();\r\nif (!kbd)\r\ngoto error_nomem;\r\nkbd->name = "Xen Virtual Keyboard";\r\nkbd->phys = info->phys;\r\nkbd->id.bustype = BUS_PCI;\r\nkbd->id.vendor = 0x5853;\r\nkbd->id.product = 0xffff;\r\n__set_bit(EV_KEY, kbd->evbit);\r\nfor (i = KEY_ESC; i < KEY_UNKNOWN; i++)\r\n__set_bit(i, kbd->keybit);\r\nfor (i = KEY_OK; i < KEY_MAX; i++)\r\n__set_bit(i, kbd->keybit);\r\nret = input_register_device(kbd);\r\nif (ret) {\r\ninput_free_device(kbd);\r\nxenbus_dev_fatal(dev, ret, "input_register_device(kbd)");\r\ngoto error;\r\n}\r\ninfo->kbd = kbd;\r\nptr = input_allocate_device();\r\nif (!ptr)\r\ngoto error_nomem;\r\nptr->name = "Xen Virtual Pointer";\r\nptr->phys = info->phys;\r\nptr->id.bustype = BUS_PCI;\r\nptr->id.vendor = 0x5853;\r\nptr->id.product = 0xfffe;\r\nif (abs) {\r\n__set_bit(EV_ABS, ptr->evbit);\r\ninput_set_abs_params(ptr, ABS_X, 0, XENFB_WIDTH, 0, 0);\r\ninput_set_abs_params(ptr, ABS_Y, 0, XENFB_HEIGHT, 0, 0);\r\n} else {\r\ninput_set_capability(ptr, EV_REL, REL_X);\r\ninput_set_capability(ptr, EV_REL, REL_Y);\r\n}\r\ninput_set_capability(ptr, EV_REL, REL_WHEEL);\r\n__set_bit(EV_KEY, ptr->evbit);\r\nfor (i = BTN_LEFT; i <= BTN_TASK; i++)\r\n__set_bit(i, ptr->keybit);\r\nret = input_register_device(ptr);\r\nif (ret) {\r\ninput_free_device(ptr);\r\nxenbus_dev_fatal(dev, ret, "input_register_device(ptr)");\r\ngoto error;\r\n}\r\ninfo->ptr = ptr;\r\nret = xenkbd_connect_backend(dev, info);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror_nomem:\r\nret = -ENOMEM;\r\nxenbus_dev_fatal(dev, ret, "allocating device memory");\r\nerror:\r\nxenkbd_remove(dev);\r\nreturn ret;\r\n}\r\nstatic int xenkbd_resume(struct xenbus_device *dev)\r\n{\r\nstruct xenkbd_info *info = dev_get_drvdata(&dev->dev);\r\nxenkbd_disconnect_backend(info);\r\nmemset(info->page, 0, PAGE_SIZE);\r\nreturn xenkbd_connect_backend(dev, info);\r\n}\r\nstatic int xenkbd_remove(struct xenbus_device *dev)\r\n{\r\nstruct xenkbd_info *info = dev_get_drvdata(&dev->dev);\r\nxenkbd_disconnect_backend(info);\r\nif (info->kbd)\r\ninput_unregister_device(info->kbd);\r\nif (info->ptr)\r\ninput_unregister_device(info->ptr);\r\nfree_page((unsigned long)info->page);\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic int xenkbd_connect_backend(struct xenbus_device *dev,\r\nstruct xenkbd_info *info)\r\n{\r\nint ret, evtchn;\r\nstruct xenbus_transaction xbt;\r\nret = gnttab_grant_foreign_access(dev->otherend_id,\r\nvirt_to_mfn(info->page), 0);\r\nif (ret < 0)\r\nreturn ret;\r\ninfo->gref = ret;\r\nret = xenbus_alloc_evtchn(dev, &evtchn);\r\nif (ret)\r\ngoto error_grant;\r\nret = bind_evtchn_to_irqhandler(evtchn, input_handler,\r\n0, dev->devicetype, info);\r\nif (ret < 0) {\r\nxenbus_dev_fatal(dev, ret, "bind_evtchn_to_irqhandler");\r\ngoto error_evtchan;\r\n}\r\ninfo->irq = ret;\r\nagain:\r\nret = xenbus_transaction_start(&xbt);\r\nif (ret) {\r\nxenbus_dev_fatal(dev, ret, "starting transaction");\r\ngoto error_irqh;\r\n}\r\nret = xenbus_printf(xbt, dev->nodename, "page-ref", "%lu",\r\nvirt_to_mfn(info->page));\r\nif (ret)\r\ngoto error_xenbus;\r\nret = xenbus_printf(xbt, dev->nodename, "page-gref", "%u", info->gref);\r\nif (ret)\r\ngoto error_xenbus;\r\nret = xenbus_printf(xbt, dev->nodename, "event-channel", "%u",\r\nevtchn);\r\nif (ret)\r\ngoto error_xenbus;\r\nret = xenbus_transaction_end(xbt, 0);\r\nif (ret) {\r\nif (ret == -EAGAIN)\r\ngoto again;\r\nxenbus_dev_fatal(dev, ret, "completing transaction");\r\ngoto error_irqh;\r\n}\r\nxenbus_switch_state(dev, XenbusStateInitialised);\r\nreturn 0;\r\nerror_xenbus:\r\nxenbus_transaction_end(xbt, 1);\r\nxenbus_dev_fatal(dev, ret, "writing xenstore");\r\nerror_irqh:\r\nunbind_from_irqhandler(info->irq, info);\r\ninfo->irq = -1;\r\nerror_evtchan:\r\nxenbus_free_evtchn(dev, evtchn);\r\nerror_grant:\r\ngnttab_end_foreign_access_ref(info->gref, 0);\r\ninfo->gref = -1;\r\nreturn ret;\r\n}\r\nstatic void xenkbd_disconnect_backend(struct xenkbd_info *info)\r\n{\r\nif (info->irq >= 0)\r\nunbind_from_irqhandler(info->irq, info);\r\ninfo->irq = -1;\r\nif (info->gref >= 0)\r\ngnttab_end_foreign_access_ref(info->gref, 0);\r\ninfo->gref = -1;\r\n}\r\nstatic void xenkbd_backend_changed(struct xenbus_device *dev,\r\nenum xenbus_state backend_state)\r\n{\r\nstruct xenkbd_info *info = dev_get_drvdata(&dev->dev);\r\nint ret, val;\r\nswitch (backend_state) {\r\ncase XenbusStateInitialising:\r\ncase XenbusStateInitialised:\r\ncase XenbusStateReconfiguring:\r\ncase XenbusStateReconfigured:\r\ncase XenbusStateUnknown:\r\nbreak;\r\ncase XenbusStateInitWait:\r\nInitWait:\r\nret = xenbus_scanf(XBT_NIL, info->xbdev->otherend,\r\n"feature-abs-pointer", "%d", &val);\r\nif (ret < 0)\r\nval = 0;\r\nif (val) {\r\nret = xenbus_printf(XBT_NIL, info->xbdev->nodename,\r\n"request-abs-pointer", "1");\r\nif (ret)\r\npr_warning("xenkbd: can't request abs-pointer");\r\n}\r\nxenbus_switch_state(dev, XenbusStateConnected);\r\nbreak;\r\ncase XenbusStateConnected:\r\nif (dev->state != XenbusStateConnected)\r\ngoto InitWait;\r\nif (xenbus_scanf(XBT_NIL, info->xbdev->otherend,\r\n"width", "%d", &val) > 0)\r\ninput_set_abs_params(info->ptr, ABS_X, 0, val, 0, 0);\r\nif (xenbus_scanf(XBT_NIL, info->xbdev->otherend,\r\n"height", "%d", &val) > 0)\r\ninput_set_abs_params(info->ptr, ABS_Y, 0, val, 0, 0);\r\nbreak;\r\ncase XenbusStateClosed:\r\nif (dev->state == XenbusStateClosed)\r\nbreak;\r\ncase XenbusStateClosing:\r\nxenbus_frontend_closed(dev);\r\nbreak;\r\n}\r\n}\r\nstatic int __init xenkbd_init(void)\r\n{\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nif (xen_initial_domain())\r\nreturn -ENODEV;\r\nif (!xen_has_pv_devices())\r\nreturn -ENODEV;\r\nreturn xenbus_register_frontend(&xenkbd_driver);\r\n}\r\nstatic void __exit xenkbd_cleanup(void)\r\n{\r\nxenbus_unregister_driver(&xenkbd_driver);\r\n}
