static int rsi_sdio_stats_read(struct seq_file *seq, void *data)\r\n{\r\nstruct rsi_common *common = seq->private;\r\nstruct rsi_hw *adapter = common->priv;\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nseq_printf(seq, "total_sdio_interrupts: %d\n",\r\ndev->rx_info.sdio_int_counter);\r\nseq_printf(seq, "sdio_msdu_pending_intr_count: %d\n",\r\ndev->rx_info.total_sdio_msdu_pending_intr);\r\nseq_printf(seq, "sdio_buff_full_count : %d\n",\r\ndev->rx_info.buf_full_counter);\r\nseq_printf(seq, "sdio_buf_semi_full_count %d\n",\r\ndev->rx_info.buf_semi_full_counter);\r\nseq_printf(seq, "sdio_unknown_intr_count: %d\n",\r\ndev->rx_info.total_sdio_unknown_intr);\r\nseq_printf(seq, "BUFFER FULL STATUS : %d\n",\r\ndev->rx_info.buffer_full);\r\nseq_printf(seq, "SEMI BUFFER FULL STATUS : %d\n",\r\ndev->rx_info.semi_buffer_full);\r\nseq_printf(seq, "MGMT BUFFER FULL STATUS : %d\n",\r\ndev->rx_info.mgmt_buffer_full);\r\nseq_printf(seq, "BUFFER FULL COUNTER : %d\n",\r\ndev->rx_info.buf_full_counter);\r\nseq_printf(seq, "BUFFER SEMI FULL COUNTER : %d\n",\r\ndev->rx_info.buf_semi_full_counter);\r\nseq_printf(seq, "MGMT BUFFER FULL COUNTER : %d\n",\r\ndev->rx_info.mgmt_buf_full_counter);\r\nreturn 0;\r\n}\r\nstatic int rsi_sdio_stats_open(struct inode *inode,\r\nstruct file *file)\r\n{\r\nreturn single_open(file, rsi_sdio_stats_read, inode->i_private);\r\n}\r\nstatic int rsi_version_read(struct seq_file *seq, void *data)\r\n{\r\nstruct rsi_common *common = seq->private;\r\ncommon->driver_ver.major = 0;\r\ncommon->driver_ver.minor = 1;\r\ncommon->driver_ver.release_num = 0;\r\ncommon->driver_ver.patch_num = 0;\r\nseq_printf(seq, "Driver : %x.%d.%d.%d\nLMAC : %d.%d.%d.%d\n",\r\ncommon->driver_ver.major,\r\ncommon->driver_ver.minor,\r\ncommon->driver_ver.release_num,\r\ncommon->driver_ver.patch_num,\r\ncommon->fw_ver.major,\r\ncommon->fw_ver.minor,\r\ncommon->fw_ver.release_num,\r\ncommon->fw_ver.patch_num);\r\nreturn 0;\r\n}\r\nstatic int rsi_version_open(struct inode *inode,\r\nstruct file *file)\r\n{\r\nreturn single_open(file, rsi_version_read, inode->i_private);\r\n}\r\nstatic int rsi_stats_read(struct seq_file *seq, void *data)\r\n{\r\nstruct rsi_common *common = seq->private;\r\nunsigned char fsm_state[][32] = {\r\n"FSM_CARD_NOT_READY",\r\n"FSM_BOOT_PARAMS_SENT",\r\n"FSM_EEPROM_READ_MAC_ADDR",\r\n"FSM_RESET_MAC_SENT",\r\n"FSM_RADIO_CAPS_SENT",\r\n"FSM_BB_RF_PROG_SENT",\r\n"FSM_MAC_INIT_DONE"\r\n};\r\nseq_puts(seq, "==> RSI STA DRIVER STATUS <==\n");\r\nseq_puts(seq, "DRIVER_FSM_STATE: ");\r\nif (common->fsm_state <= FSM_MAC_INIT_DONE)\r\nseq_printf(seq, "%s", fsm_state[common->fsm_state]);\r\nseq_printf(seq, "(%d)\n\n", common->fsm_state);\r\nseq_printf(seq, "total_mgmt_pkt_send : %d\n",\r\ncommon->tx_stats.total_tx_pkt_send[MGMT_SOFT_Q]);\r\nseq_printf(seq, "total_mgmt_pkt_queued : %d\n",\r\nskb_queue_len(&common->tx_queue[4]));\r\nseq_printf(seq, "total_mgmt_pkt_freed : %d\n",\r\ncommon->tx_stats.total_tx_pkt_freed[MGMT_SOFT_Q]);\r\nseq_printf(seq, "total_data_vo_pkt_send: %8d\t",\r\ncommon->tx_stats.total_tx_pkt_send[VO_Q]);\r\nseq_printf(seq, "total_data_vo_pkt_queued: %8d\t",\r\nskb_queue_len(&common->tx_queue[0]));\r\nseq_printf(seq, "total_vo_pkt_freed: %8d\n",\r\ncommon->tx_stats.total_tx_pkt_freed[VO_Q]);\r\nseq_printf(seq, "total_data_vi_pkt_send: %8d\t",\r\ncommon->tx_stats.total_tx_pkt_send[VI_Q]);\r\nseq_printf(seq, "total_data_vi_pkt_queued: %8d\t",\r\nskb_queue_len(&common->tx_queue[1]));\r\nseq_printf(seq, "total_vi_pkt_freed: %8d\n",\r\ncommon->tx_stats.total_tx_pkt_freed[VI_Q]);\r\nseq_printf(seq, "total_data_be_pkt_send: %8d\t",\r\ncommon->tx_stats.total_tx_pkt_send[BE_Q]);\r\nseq_printf(seq, "total_data_be_pkt_queued: %8d\t",\r\nskb_queue_len(&common->tx_queue[2]));\r\nseq_printf(seq, "total_be_pkt_freed: %8d\n",\r\ncommon->tx_stats.total_tx_pkt_freed[BE_Q]);\r\nseq_printf(seq, "total_data_bk_pkt_send: %8d\t",\r\ncommon->tx_stats.total_tx_pkt_send[BK_Q]);\r\nseq_printf(seq, "total_data_bk_pkt_queued: %8d\t",\r\nskb_queue_len(&common->tx_queue[3]));\r\nseq_printf(seq, "total_bk_pkt_freed: %8d\n",\r\ncommon->tx_stats.total_tx_pkt_freed[BK_Q]);\r\nseq_puts(seq, "\n");\r\nreturn 0;\r\n}\r\nstatic int rsi_stats_open(struct inode *inode,\r\nstruct file *file)\r\n{\r\nreturn single_open(file, rsi_stats_read, inode->i_private);\r\n}\r\nstatic int rsi_debug_zone_read(struct seq_file *seq, void *data)\r\n{\r\nrsi_dbg(FSM_ZONE, "%x: rsi_enabled zone", rsi_zone_enabled);\r\nseq_printf(seq, "The zones available are %#x\n",\r\nrsi_zone_enabled);\r\nreturn 0;\r\n}\r\nstatic int rsi_debug_read(struct inode *inode,\r\nstruct file *file)\r\n{\r\nreturn single_open(file, rsi_debug_zone_read, inode->i_private);\r\n}\r\nstatic ssize_t rsi_debug_zone_write(struct file *filp,\r\nconst char __user *buff,\r\nsize_t len,\r\nloff_t *data)\r\n{\r\nunsigned long dbg_zone;\r\nint ret;\r\nif (!len)\r\nreturn 0;\r\nret = kstrtoul_from_user(buff, len, 16, &dbg_zone);\r\nif (ret)\r\nreturn ret;\r\nrsi_zone_enabled = dbg_zone;\r\nreturn len;\r\n}\r\nint rsi_init_dbgfs(struct rsi_hw *adapter)\r\n{\r\nstruct rsi_common *common = adapter->priv;\r\nstruct rsi_debugfs *dev_dbgfs;\r\nchar devdir[6];\r\nint ii;\r\nconst struct rsi_dbg_files *files;\r\ndev_dbgfs = kzalloc(sizeof(*dev_dbgfs), GFP_KERNEL);\r\nif (!dev_dbgfs)\r\nreturn -ENOMEM;\r\nadapter->dfsentry = dev_dbgfs;\r\nsnprintf(devdir, sizeof(devdir), "%s",\r\nwiphy_name(adapter->hw->wiphy));\r\ndev_dbgfs->subdir = debugfs_create_dir(devdir, NULL);\r\nif (!dev_dbgfs->subdir) {\r\nkfree(dev_dbgfs);\r\nreturn -ENOMEM;\r\n}\r\nfor (ii = 0; ii < adapter->num_debugfs_entries; ii++) {\r\nfiles = &dev_debugfs_files[ii];\r\ndev_dbgfs->rsi_files[ii] =\r\ndebugfs_create_file(files->name,\r\nfiles->perms,\r\ndev_dbgfs->subdir,\r\ncommon,\r\n&files->fops);\r\n}\r\nreturn 0;\r\n}\r\nvoid rsi_remove_dbgfs(struct rsi_hw *adapter)\r\n{\r\nstruct rsi_debugfs *dev_dbgfs = adapter->dfsentry;\r\nif (!dev_dbgfs)\r\nreturn;\r\ndebugfs_remove_recursive(dev_dbgfs->subdir);\r\n}
