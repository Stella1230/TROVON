static unsigned int get_apic_id(unsigned long x)\r\n{\r\nunsigned long value;\r\nunsigned int id;\r\nrdmsrl(MSR_FAM10H_NODE_ID, value);\r\nid = ((x >> 24) & 0xffU) | ((value << 2) & 0x3f00U);\r\nreturn id;\r\n}\r\nstatic unsigned long set_apic_id(unsigned int id)\r\n{\r\nunsigned long x;\r\nx = ((id & 0xffU) << 24);\r\nreturn x;\r\n}\r\nstatic unsigned int read_xapic_id(void)\r\n{\r\nreturn get_apic_id(apic_read(APIC_ID));\r\n}\r\nstatic int numachip_apic_id_valid(int apicid)\r\n{\r\nreturn 1;\r\n}\r\nstatic int numachip_apic_id_registered(void)\r\n{\r\nreturn physid_isset(read_xapic_id(), phys_cpu_present_map);\r\n}\r\nstatic int numachip_phys_pkg_id(int initial_apic_id, int index_msb)\r\n{\r\nreturn initial_apic_id >> index_msb;\r\n}\r\nstatic int numachip_wakeup_secondary(int phys_apicid, unsigned long start_rip)\r\n{\r\nunion numachip_csr_g3_ext_irq_gen int_gen;\r\nint_gen.s._destination_apic_id = phys_apicid;\r\nint_gen.s._vector = 0;\r\nint_gen.s._msgtype = APIC_DM_INIT >> 8;\r\nint_gen.s._index = 0;\r\nwrite_lcsr(CSR_G3_EXT_IRQ_GEN, int_gen.v);\r\nint_gen.s._msgtype = APIC_DM_STARTUP >> 8;\r\nint_gen.s._vector = start_rip >> 12;\r\nwrite_lcsr(CSR_G3_EXT_IRQ_GEN, int_gen.v);\r\natomic_set(&init_deasserted, 1);\r\nreturn 0;\r\n}\r\nstatic void numachip_send_IPI_one(int cpu, int vector)\r\n{\r\nunion numachip_csr_g3_ext_irq_gen int_gen;\r\nint apicid = per_cpu(x86_cpu_to_apicid, cpu);\r\nint_gen.s._destination_apic_id = apicid;\r\nint_gen.s._vector = vector;\r\nint_gen.s._msgtype = (vector == NMI_VECTOR ? APIC_DM_NMI : APIC_DM_FIXED) >> 8;\r\nint_gen.s._index = 0;\r\nwrite_lcsr(CSR_G3_EXT_IRQ_GEN, int_gen.v);\r\n}\r\nstatic void numachip_send_IPI_mask(const struct cpumask *mask, int vector)\r\n{\r\nunsigned int cpu;\r\nfor_each_cpu(cpu, mask)\r\nnumachip_send_IPI_one(cpu, vector);\r\n}\r\nstatic void numachip_send_IPI_mask_allbutself(const struct cpumask *mask,\r\nint vector)\r\n{\r\nunsigned int this_cpu = smp_processor_id();\r\nunsigned int cpu;\r\nfor_each_cpu(cpu, mask) {\r\nif (cpu != this_cpu)\r\nnumachip_send_IPI_one(cpu, vector);\r\n}\r\n}\r\nstatic void numachip_send_IPI_allbutself(int vector)\r\n{\r\nunsigned int this_cpu = smp_processor_id();\r\nunsigned int cpu;\r\nfor_each_online_cpu(cpu) {\r\nif (cpu != this_cpu)\r\nnumachip_send_IPI_one(cpu, vector);\r\n}\r\n}\r\nstatic void numachip_send_IPI_all(int vector)\r\n{\r\nnumachip_send_IPI_mask(cpu_online_mask, vector);\r\n}\r\nstatic void numachip_send_IPI_self(int vector)\r\n{\r\n__default_send_IPI_shortcut(APIC_DEST_SELF, vector, APIC_DEST_PHYSICAL);\r\n}\r\nstatic int __init numachip_probe(void)\r\n{\r\nreturn apic == &apic_numachip;\r\n}\r\nstatic void __init map_csrs(void)\r\n{\r\nprintk(KERN_INFO "NumaChip: Mapping local CSR space (%016llx - %016llx)\n",\r\nNUMACHIP_LCSR_BASE, NUMACHIP_LCSR_BASE + NUMACHIP_LCSR_SIZE - 1);\r\ninit_extra_mapping_uc(NUMACHIP_LCSR_BASE, NUMACHIP_LCSR_SIZE);\r\nprintk(KERN_INFO "NumaChip: Mapping global CSR space (%016llx - %016llx)\n",\r\nNUMACHIP_GCSR_BASE, NUMACHIP_GCSR_BASE + NUMACHIP_GCSR_SIZE - 1);\r\ninit_extra_mapping_uc(NUMACHIP_GCSR_BASE, NUMACHIP_GCSR_SIZE);\r\n}\r\nstatic void fixup_cpu_id(struct cpuinfo_x86 *c, int node)\r\n{\r\nif (c->phys_proc_id != node) {\r\nc->phys_proc_id = node;\r\nper_cpu(cpu_llc_id, smp_processor_id()) = node;\r\n}\r\n}\r\nstatic int __init numachip_system_init(void)\r\n{\r\nunsigned int val;\r\nif (!numachip_system)\r\nreturn 0;\r\nx86_cpuinit.fixup_cpu_id = fixup_cpu_id;\r\nx86_init.pci.arch_init = pci_numachip_init;\r\nmap_csrs();\r\nval = read_lcsr(CSR_G0_NODE_IDS);\r\nprintk(KERN_INFO "NumaChip: Local NodeID = %08x\n", val);\r\nreturn 0;\r\n}\r\nstatic int numachip_acpi_madt_oem_check(char *oem_id, char *oem_table_id)\r\n{\r\nif (!strncmp(oem_id, "NUMASC", 6)) {\r\nnumachip_system = 1;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
