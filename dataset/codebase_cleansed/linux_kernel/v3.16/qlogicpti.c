static inline void qlogicpti_enable_irqs(struct qlogicpti *qpti)\r\n{\r\nsbus_writew(SBUS_CTRL_ERIRQ | SBUS_CTRL_GENAB,\r\nqpti->qregs + SBUS_CTRL);\r\n}\r\nstatic inline void qlogicpti_disable_irqs(struct qlogicpti *qpti)\r\n{\r\nsbus_writew(0, qpti->qregs + SBUS_CTRL);\r\n}\r\nstatic inline void set_sbus_cfg1(struct qlogicpti *qpti)\r\n{\r\nu16 val;\r\nu8 bursts = qpti->bursts;\r\n#if 0\r\nif (sbus_can_burst64() && (bursts & DMA_BURST64)) {\r\nval = (SBUS_CFG1_BENAB | SBUS_CFG1_B64);\r\n} else\r\n#endif\r\nif (bursts & DMA_BURST32) {\r\nval = (SBUS_CFG1_BENAB | SBUS_CFG1_B32);\r\n} else if (bursts & DMA_BURST16) {\r\nval = (SBUS_CFG1_BENAB | SBUS_CFG1_B16);\r\n} else if (bursts & DMA_BURST8) {\r\nval = (SBUS_CFG1_BENAB | SBUS_CFG1_B8);\r\n} else {\r\nval = 0;\r\n}\r\nsbus_writew(val, qpti->qregs + SBUS_CFG1);\r\n}\r\nstatic int qlogicpti_mbox_command(struct qlogicpti *qpti, u_short param[], int force)\r\n{\r\nint loop_count;\r\nu16 tmp;\r\nif (mbox_param[param[0]] == 0)\r\nreturn 1;\r\ntmp = sbus_readw(qpti->qregs + SBUS_SEMAPHORE);\r\ntmp |= SBUS_SEMAPHORE_LCK;\r\nsbus_writew(tmp, qpti->qregs + SBUS_SEMAPHORE);\r\nloop_count = DEFAULT_LOOP_COUNT;\r\nwhile (--loop_count && (sbus_readw(qpti->qregs + HCCTRL) & HCCTRL_HIRQ)) {\r\nbarrier();\r\ncpu_relax();\r\n}\r\nif (!loop_count)\r\nprintk(KERN_EMERG "qlogicpti%d: mbox_command loop timeout #1\n",\r\nqpti->qpti_id);\r\nswitch (mbox_param[param[0]] >> 4) {\r\ncase 6: sbus_writew(param[5], qpti->qregs + MBOX5);\r\ncase 5: sbus_writew(param[4], qpti->qregs + MBOX4);\r\ncase 4: sbus_writew(param[3], qpti->qregs + MBOX3);\r\ncase 3: sbus_writew(param[2], qpti->qregs + MBOX2);\r\ncase 2: sbus_writew(param[1], qpti->qregs + MBOX1);\r\ncase 1: sbus_writew(param[0], qpti->qregs + MBOX0);\r\n}\r\ntmp = sbus_readw(qpti->qregs + HCCTRL);\r\ntmp |= HCCTRL_CRIRQ;\r\nsbus_writew(tmp, qpti->qregs + HCCTRL);\r\nsbus_writew(0, qpti->qregs + SBUS_SEMAPHORE);\r\ntmp = sbus_readw(qpti->qregs + HCCTRL);\r\ntmp |= HCCTRL_SHIRQ;\r\nsbus_writew(tmp, qpti->qregs + HCCTRL);\r\nloop_count = DEFAULT_LOOP_COUNT;\r\nwhile (--loop_count &&\r\n(sbus_readw(qpti->qregs + HCCTRL) & HCCTRL_CRIRQ))\r\nudelay(20);\r\nif (!loop_count)\r\nprintk(KERN_EMERG "qlogicpti%d: mbox_command[%04x] loop timeout #2\n",\r\nqpti->qpti_id, param[0]);\r\nloop_count = DEFAULT_LOOP_COUNT;\r\nwhile (--loop_count &&\r\n!(sbus_readw(qpti->qregs + SBUS_SEMAPHORE) & SBUS_SEMAPHORE_LCK)) {\r\nudelay(20);\r\nif (sbus_readw(qpti->qregs + MBOX0) & 0x4000)\r\nbreak;\r\n}\r\nif (!loop_count)\r\nprintk(KERN_EMERG "qlogicpti%d: mbox_command[%04x] loop timeout #3\n",\r\nqpti->qpti_id, param[0]);\r\nloop_count = DEFAULT_LOOP_COUNT;\r\nwhile (--loop_count && (sbus_readw(qpti->qregs + MBOX0) == 0x04))\r\nudelay(20);\r\nif (!loop_count)\r\nprintk(KERN_EMERG "qlogicpti%d: mbox_command[%04x] loop timeout #4\n",\r\nqpti->qpti_id, param[0]);\r\nswitch (mbox_param[param[0]] & 0xf) {\r\ncase 6: param[5] = sbus_readw(qpti->qregs + MBOX5);\r\ncase 5: param[4] = sbus_readw(qpti->qregs + MBOX4);\r\ncase 4: param[3] = sbus_readw(qpti->qregs + MBOX3);\r\ncase 3: param[2] = sbus_readw(qpti->qregs + MBOX2);\r\ncase 2: param[1] = sbus_readw(qpti->qregs + MBOX1);\r\ncase 1: param[0] = sbus_readw(qpti->qregs + MBOX0);\r\n}\r\ntmp = sbus_readw(qpti->qregs + HCCTRL);\r\ntmp |= HCCTRL_CRIRQ;\r\nsbus_writew(tmp, qpti->qregs + HCCTRL);\r\ntmp = sbus_readw(qpti->qregs + SBUS_SEMAPHORE);\r\ntmp &= ~(SBUS_SEMAPHORE_LCK);\r\nsbus_writew(tmp, qpti->qregs + SBUS_SEMAPHORE);\r\nreturn 0;\r\n}\r\nstatic inline void qlogicpti_set_hostdev_defaults(struct qlogicpti *qpti)\r\n{\r\nint i;\r\nqpti->host_param.initiator_scsi_id = qpti->scsi_id;\r\nqpti->host_param.bus_reset_delay = 3;\r\nqpti->host_param.retry_count = 0;\r\nqpti->host_param.retry_delay = 5;\r\nqpti->host_param.async_data_setup_time = 3;\r\nqpti->host_param.req_ack_active_negation = 1;\r\nqpti->host_param.data_line_active_negation = 1;\r\nqpti->host_param.data_dma_burst_enable = 1;\r\nqpti->host_param.command_dma_burst_enable = 1;\r\nqpti->host_param.tag_aging = 8;\r\nqpti->host_param.selection_timeout = 250;\r\nqpti->host_param.max_queue_depth = 256;\r\nfor(i = 0; i < MAX_TARGETS; i++) {\r\nqpti->dev_param[i].device_flags = 0xcd;\r\nqpti->dev_param[i].execution_throttle = 16;\r\nif (qpti->ultra) {\r\nqpti->dev_param[i].synchronous_period = 12;\r\nqpti->dev_param[i].synchronous_offset = 8;\r\n} else {\r\nqpti->dev_param[i].synchronous_period = 25;\r\nqpti->dev_param[i].synchronous_offset = 12;\r\n}\r\nqpti->dev_param[i].device_enable = 1;\r\n}\r\n}\r\nstatic int qlogicpti_reset_hardware(struct Scsi_Host *host)\r\n{\r\nstruct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;\r\nu_short param[6];\r\nunsigned short risc_code_addr;\r\nint loop_count, i;\r\nunsigned long flags;\r\nrisc_code_addr = 0x1000;\r\nspin_lock_irqsave(host->host_lock, flags);\r\nsbus_writew(HCCTRL_PAUSE, qpti->qregs + HCCTRL);\r\nif (sbus_readw(qpti->qregs + CPU_PCTRL) & CPU_PCTRL_BSY) {\r\nsbus_writew(CPU_ORIDE_RMOD, qpti->qregs + CPU_ORIDE);\r\nsbus_writew(CPU_CMD_BRESET, qpti->qregs + CPU_CMD);\r\nudelay(400);\r\n}\r\nsbus_writew(SBUS_CTRL_RESET, qpti->qregs + SBUS_CTRL);\r\nsbus_writew((DMA_CTRL_CCLEAR | DMA_CTRL_CIRQ), qpti->qregs + CMD_DMA_CTRL);\r\nsbus_writew((DMA_CTRL_CCLEAR | DMA_CTRL_CIRQ), qpti->qregs + DATA_DMA_CTRL);\r\nloop_count = DEFAULT_LOOP_COUNT;\r\nwhile (--loop_count && ((sbus_readw(qpti->qregs + MBOX0) & 0xff) == 0x04))\r\nudelay(20);\r\nif (!loop_count)\r\nprintk(KERN_EMERG "qlogicpti%d: reset_hardware loop timeout\n",\r\nqpti->qpti_id);\r\nsbus_writew(HCCTRL_PAUSE, qpti->qregs + HCCTRL);\r\nset_sbus_cfg1(qpti);\r\nqlogicpti_enable_irqs(qpti);\r\nif (sbus_readw(qpti->qregs + RISC_PSR) & RISC_PSR_ULTRA) {\r\nqpti->ultra = 1;\r\nsbus_writew((RISC_MTREG_P0ULTRA | RISC_MTREG_P1ULTRA),\r\nqpti->qregs + RISC_MTREG);\r\n} else {\r\nqpti->ultra = 0;\r\nsbus_writew((RISC_MTREG_P0DFLT | RISC_MTREG_P1DFLT),\r\nqpti->qregs + RISC_MTREG);\r\n}\r\nqlogicpti_set_hostdev_defaults(qpti);\r\nsbus_writew(HCCTRL_REL, qpti->qregs + HCCTRL);\r\nparam[0] = MBOX_EXEC_FIRMWARE;\r\nparam[1] = risc_code_addr;\r\nif (qlogicpti_mbox_command(qpti, param, 1)) {\r\nprintk(KERN_EMERG "qlogicpti%d: Cannot execute ISP firmware.\n",\r\nqpti->qpti_id);\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nreturn 1;\r\n}\r\nparam[0] = MBOX_SET_INIT_SCSI_ID;\r\nparam[1] = qpti->host_param.initiator_scsi_id;\r\nif (qlogicpti_mbox_command(qpti, param, 1) ||\r\n(param[0] != MBOX_COMMAND_COMPLETE)) {\r\nprintk(KERN_EMERG "qlogicpti%d: Cannot set initiator SCSI ID.\n",\r\nqpti->qpti_id);\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nreturn 1;\r\n}\r\nqpti->req_in_ptr = qpti->res_out_ptr = 0;\r\nparam[0] = MBOX_INIT_RES_QUEUE;\r\nparam[1] = RES_QUEUE_LEN + 1;\r\nparam[2] = (u_short) (qpti->res_dvma >> 16);\r\nparam[3] = (u_short) (qpti->res_dvma & 0xffff);\r\nparam[4] = param[5] = 0;\r\nif (qlogicpti_mbox_command(qpti, param, 1)) {\r\nprintk(KERN_EMERG "qlogicpti%d: Cannot init response queue.\n",\r\nqpti->qpti_id);\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nreturn 1;\r\n}\r\nparam[0] = MBOX_INIT_REQ_QUEUE;\r\nparam[1] = QLOGICPTI_REQ_QUEUE_LEN + 1;\r\nparam[2] = (u_short) (qpti->req_dvma >> 16);\r\nparam[3] = (u_short) (qpti->req_dvma & 0xffff);\r\nparam[4] = param[5] = 0;\r\nif (qlogicpti_mbox_command(qpti, param, 1)) {\r\nprintk(KERN_EMERG "qlogicpti%d: Cannot init request queue.\n",\r\nqpti->qpti_id);\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nreturn 1;\r\n}\r\nparam[0] = MBOX_SET_RETRY_COUNT;\r\nparam[1] = qpti->host_param.retry_count;\r\nparam[2] = qpti->host_param.retry_delay;\r\nqlogicpti_mbox_command(qpti, param, 0);\r\nparam[0] = MBOX_SET_TAG_AGE_LIMIT;\r\nparam[1] = qpti->host_param.tag_aging;\r\nqlogicpti_mbox_command(qpti, param, 0);\r\nfor (i = 0; i < MAX_TARGETS; i++) {\r\nparam[0] = MBOX_GET_DEV_QUEUE_PARAMS;\r\nparam[1] = (i << 8);\r\nqlogicpti_mbox_command(qpti, param, 0);\r\n}\r\nparam[0] = MBOX_GET_FIRMWARE_STATUS;\r\nqlogicpti_mbox_command(qpti, param, 0);\r\nparam[0] = MBOX_SET_SELECT_TIMEOUT;\r\nparam[1] = qpti->host_param.selection_timeout;\r\nqlogicpti_mbox_command(qpti, param, 0);\r\nfor (i = 0; i < MAX_TARGETS; i++) {\r\nparam[0] = MBOX_SET_TARGET_PARAMS;\r\nparam[1] = (i << 8);\r\nparam[2] = (qpti->dev_param[i].device_flags << 8);\r\nparam[2] |= 0xc0;\r\nparam[3] = 0;\r\nqlogicpti_mbox_command(qpti, param, 0);\r\n}\r\nparam[0] = MBOX_BUS_RESET;\r\nparam[1] = qpti->host_param.bus_reset_delay;\r\nqlogicpti_mbox_command(qpti, param, 0);\r\nqpti->send_marker = 1;\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int qlogicpti_load_firmware(struct qlogicpti *qpti)\r\n{\r\nconst struct firmware *fw;\r\nconst char fwname[] = "qlogic/isp1000.bin";\r\nconst __le16 *fw_data;\r\nstruct Scsi_Host *host = qpti->qhost;\r\nunsigned short csum = 0;\r\nunsigned short param[6];\r\nunsigned short risc_code_addr, risc_code_length;\r\nint err;\r\nunsigned long flags;\r\nint i, timeout;\r\nerr = request_firmware(&fw, fwname, &qpti->op->dev);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to load image \"%s\" err %d\n",\r\nfwname, err);\r\nreturn err;\r\n}\r\nif (fw->size % 2) {\r\nprintk(KERN_ERR "Bogus length %zu in image \"%s\"\n",\r\nfw->size, fwname);\r\nerr = -EINVAL;\r\ngoto outfirm;\r\n}\r\nfw_data = (const __le16 *)&fw->data[0];\r\nrisc_code_addr = 0x1000;\r\nrisc_code_length = fw->size / 2;\r\nspin_lock_irqsave(host->host_lock, flags);\r\nfor (i = 0; i < risc_code_length; i++)\r\ncsum += __le16_to_cpu(fw_data[i]);\r\nif (csum) {\r\nprintk(KERN_EMERG "qlogicpti%d: Aieee, firmware checksum failed!",\r\nqpti->qpti_id);\r\nerr = 1;\r\ngoto out;\r\n}\r\nsbus_writew(SBUS_CTRL_RESET, qpti->qregs + SBUS_CTRL);\r\nsbus_writew((DMA_CTRL_CCLEAR | DMA_CTRL_CIRQ), qpti->qregs + CMD_DMA_CTRL);\r\nsbus_writew((DMA_CTRL_CCLEAR | DMA_CTRL_CIRQ), qpti->qregs + DATA_DMA_CTRL);\r\ntimeout = PTI_RESET_LIMIT;\r\nwhile (--timeout && (sbus_readw(qpti->qregs + SBUS_CTRL) & SBUS_CTRL_RESET))\r\nudelay(20);\r\nif (!timeout) {\r\nprintk(KERN_EMERG "qlogicpti%d: Cannot reset the ISP.", qpti->qpti_id);\r\nerr = 1;\r\ngoto out;\r\n}\r\nsbus_writew(HCCTRL_RESET, qpti->qregs + HCCTRL);\r\nmdelay(1);\r\nsbus_writew((SBUS_CTRL_GENAB | SBUS_CTRL_ERIRQ), qpti->qregs + SBUS_CTRL);\r\nset_sbus_cfg1(qpti);\r\nsbus_writew(0, qpti->qregs + SBUS_SEMAPHORE);\r\nif (sbus_readw(qpti->qregs + RISC_PSR) & RISC_PSR_ULTRA) {\r\nqpti->ultra = 1;\r\nsbus_writew((RISC_MTREG_P0ULTRA | RISC_MTREG_P1ULTRA),\r\nqpti->qregs + RISC_MTREG);\r\n} else {\r\nqpti->ultra = 0;\r\nsbus_writew((RISC_MTREG_P0DFLT | RISC_MTREG_P1DFLT),\r\nqpti->qregs + RISC_MTREG);\r\n}\r\nsbus_writew(HCCTRL_REL, qpti->qregs + HCCTRL);\r\nsbus_writew(HCCTRL_PAUSE, qpti->qregs + HCCTRL);\r\nif (sbus_readw(qpti->qregs + CPU_PDIFF) & CPU_PDIFF_MODE)\r\nqpti->differential = 1;\r\nelse\r\nqpti->differential = 0;\r\nsbus_writew(HCCTRL_REL, qpti->qregs + HCCTRL);\r\nparam[0] = MBOX_STOP_FIRMWARE;\r\nparam[1] = param[2] = param[3] = param[4] = param[5] = 0;\r\nif (qlogicpti_mbox_command(qpti, param, 1)) {\r\nprintk(KERN_EMERG "qlogicpti%d: Cannot stop firmware for reload.\n",\r\nqpti->qpti_id);\r\nerr = 1;\r\ngoto out;\r\n}\r\nfor (i = 0; i < risc_code_length; i++) {\r\nparam[0] = MBOX_WRITE_RAM_WORD;\r\nparam[1] = risc_code_addr + i;\r\nparam[2] = __le16_to_cpu(fw_data[i]);\r\nif (qlogicpti_mbox_command(qpti, param, 1) ||\r\nparam[0] != MBOX_COMMAND_COMPLETE) {\r\nprintk("qlogicpti%d: Firmware dload failed, I'm bolixed!\n",\r\nqpti->qpti_id);\r\nerr = 1;\r\ngoto out;\r\n}\r\n}\r\nsbus_writew(HCCTRL_RESET, qpti->qregs + HCCTRL);\r\nmdelay(1);\r\nqlogicpti_enable_irqs(qpti);\r\nsbus_writew(0, qpti->qregs + SBUS_SEMAPHORE);\r\nsbus_writew(HCCTRL_REL, qpti->qregs + HCCTRL);\r\nparam[0] = MBOX_VERIFY_CHECKSUM;\r\nparam[1] = risc_code_addr;\r\nif (qlogicpti_mbox_command(qpti, param, 1) ||\r\n(param[0] != MBOX_COMMAND_COMPLETE)) {\r\nprintk(KERN_EMERG "qlogicpti%d: New firmware csum failure!\n",\r\nqpti->qpti_id);\r\nerr = 1;\r\ngoto out;\r\n}\r\nparam[0] = MBOX_EXEC_FIRMWARE;\r\nparam[1] = risc_code_addr;\r\nqlogicpti_mbox_command(qpti, param, 1);\r\nparam[0] = MBOX_ABOUT_FIRMWARE;\r\nif (qlogicpti_mbox_command(qpti, param, 1) ||\r\n(param[0] != MBOX_COMMAND_COMPLETE)) {\r\nprintk(KERN_EMERG "qlogicpti%d: AboutFirmware cmd fails.\n",\r\nqpti->qpti_id);\r\nerr = 1;\r\ngoto out;\r\n}\r\nqpti->fware_majrev = param[1];\r\nqpti->fware_minrev = param[2];\r\nqpti->fware_micrev = param[3];\r\nparam[0] = MBOX_SET_CLOCK_RATE;\r\nparam[1] = qpti->clock;\r\nif (qlogicpti_mbox_command(qpti, param, 1) ||\r\n(param[0] != MBOX_COMMAND_COMPLETE)) {\r\nprintk(KERN_EMERG "qlogicpti%d: could not set clock rate.\n",\r\nqpti->qpti_id);\r\nerr = 1;\r\ngoto out;\r\n}\r\nif (qpti->is_pti != 0) {\r\nparam[0] = MBOX_WRITE_RAM_WORD;\r\nparam[1] = 0xff80;\r\nparam[2] = (unsigned short) qpti->scsi_id;\r\nqlogicpti_mbox_command(qpti, param, 1);\r\nparam[0] = MBOX_WRITE_RAM_WORD;\r\nparam[1] = 0xff00;\r\nparam[2] = (unsigned short) 3;\r\nqlogicpti_mbox_command(qpti, param, 1);\r\n}\r\nout:\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\noutfirm:\r\nrelease_firmware(fw);\r\nreturn err;\r\n}\r\nstatic int qlogicpti_verify_tmon(struct qlogicpti *qpti)\r\n{\r\nint curstat = sbus_readb(qpti->sreg);\r\ncurstat &= 0xf0;\r\nif (!(curstat & SREG_FUSE) && (qpti->swsreg & SREG_FUSE))\r\nprintk("qlogicpti%d: Fuse returned to normal state.\n", qpti->qpti_id);\r\nif (!(curstat & SREG_TPOWER) && (qpti->swsreg & SREG_TPOWER))\r\nprintk("qlogicpti%d: termpwr back to normal state.\n", qpti->qpti_id);\r\nif (curstat != qpti->swsreg) {\r\nint error = 0;\r\nif (curstat & SREG_FUSE) {\r\nerror++;\r\nprintk("qlogicpti%d: Fuse is open!\n", qpti->qpti_id);\r\n}\r\nif (curstat & SREG_TPOWER) {\r\nerror++;\r\nprintk("qlogicpti%d: termpwr failure\n", qpti->qpti_id);\r\n}\r\nif (qpti->differential &&\r\n(curstat & SREG_DSENSE) != SREG_DSENSE) {\r\nerror++;\r\nprintk("qlogicpti%d: You have a single ended device on a "\r\n"differential bus! Please fix!\n", qpti->qpti_id);\r\n}\r\nqpti->swsreg = curstat;\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void qpti_chain_add(struct qlogicpti *qpti)\r\n{\r\nspin_lock_irq(&qptichain_lock);\r\nif (qptichain != NULL) {\r\nstruct qlogicpti *qlink = qptichain;\r\nwhile(qlink->next)\r\nqlink = qlink->next;\r\nqlink->next = qpti;\r\n} else {\r\nqptichain = qpti;\r\n}\r\nqpti->next = NULL;\r\nspin_unlock_irq(&qptichain_lock);\r\n}\r\nstatic void qpti_chain_del(struct qlogicpti *qpti)\r\n{\r\nspin_lock_irq(&qptichain_lock);\r\nif (qptichain == qpti) {\r\nqptichain = qpti->next;\r\n} else {\r\nstruct qlogicpti *qlink = qptichain;\r\nwhile(qlink->next != qpti)\r\nqlink = qlink->next;\r\nqlink->next = qpti->next;\r\n}\r\nqpti->next = NULL;\r\nspin_unlock_irq(&qptichain_lock);\r\n}\r\nstatic int qpti_map_regs(struct qlogicpti *qpti)\r\n{\r\nstruct platform_device *op = qpti->op;\r\nqpti->qregs = of_ioremap(&op->resource[0], 0,\r\nresource_size(&op->resource[0]),\r\n"PTI Qlogic/ISP");\r\nif (!qpti->qregs) {\r\nprintk("PTI: Qlogic/ISP registers are unmappable\n");\r\nreturn -1;\r\n}\r\nif (qpti->is_pti) {\r\nqpti->sreg = of_ioremap(&op->resource[0], (16 * 4096),\r\nsizeof(unsigned char),\r\n"PTI Qlogic/ISP statreg");\r\nif (!qpti->sreg) {\r\nprintk("PTI: Qlogic/ISP status register is unmappable\n");\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qpti_register_irq(struct qlogicpti *qpti)\r\n{\r\nstruct platform_device *op = qpti->op;\r\nqpti->qhost->irq = qpti->irq = op->archdata.irqs[0];\r\nif (request_irq(qpti->irq, qpti_intr,\r\nIRQF_SHARED, "QlogicPTI", qpti))\r\ngoto fail;\r\nprintk("qlogicpti%d: IRQ %d ", qpti->qpti_id, qpti->irq);\r\nreturn 0;\r\nfail:\r\nprintk("qlogicpti%d: Cannot acquire irq line\n", qpti->qpti_id);\r\nreturn -1;\r\n}\r\nstatic void qpti_get_scsi_id(struct qlogicpti *qpti)\r\n{\r\nstruct platform_device *op = qpti->op;\r\nstruct device_node *dp;\r\ndp = op->dev.of_node;\r\nqpti->scsi_id = of_getintprop_default(dp, "initiator-id", -1);\r\nif (qpti->scsi_id == -1)\r\nqpti->scsi_id = of_getintprop_default(dp, "scsi-initiator-id",\r\n-1);\r\nif (qpti->scsi_id == -1)\r\nqpti->scsi_id =\r\nof_getintprop_default(dp->parent,\r\n"scsi-initiator-id", 7);\r\nqpti->qhost->this_id = qpti->scsi_id;\r\nqpti->qhost->max_sectors = 64;\r\nprintk("SCSI ID %d ", qpti->scsi_id);\r\n}\r\nstatic void qpti_get_bursts(struct qlogicpti *qpti)\r\n{\r\nstruct platform_device *op = qpti->op;\r\nu8 bursts, bmask;\r\nbursts = of_getintprop_default(op->dev.of_node, "burst-sizes", 0xff);\r\nbmask = of_getintprop_default(op->dev.of_node->parent, "burst-sizes", 0xff);\r\nif (bmask != 0xff)\r\nbursts &= bmask;\r\nif (bursts == 0xff ||\r\n(bursts & DMA_BURST16) == 0 ||\r\n(bursts & DMA_BURST32) == 0)\r\nbursts = (DMA_BURST32 - 1);\r\nqpti->bursts = bursts;\r\n}\r\nstatic void qpti_get_clock(struct qlogicpti *qpti)\r\n{\r\nunsigned int cfreq;\r\ncfreq = prom_getintdefault(qpti->prom_node,"clock-frequency",40000000);\r\nqpti->clock = (cfreq + 500000)/1000000;\r\nif (qpti->clock == 0)\r\nqpti->clock = 40;\r\n}\r\nstatic int qpti_map_queues(struct qlogicpti *qpti)\r\n{\r\nstruct platform_device *op = qpti->op;\r\n#define QSIZE(entries) (((entries) + 1) * QUEUE_ENTRY_LEN)\r\nqpti->res_cpu = dma_alloc_coherent(&op->dev,\r\nQSIZE(RES_QUEUE_LEN),\r\n&qpti->res_dvma, GFP_ATOMIC);\r\nif (qpti->res_cpu == NULL ||\r\nqpti->res_dvma == 0) {\r\nprintk("QPTI: Cannot map response queue.\n");\r\nreturn -1;\r\n}\r\nqpti->req_cpu = dma_alloc_coherent(&op->dev,\r\nQSIZE(QLOGICPTI_REQ_QUEUE_LEN),\r\n&qpti->req_dvma, GFP_ATOMIC);\r\nif (qpti->req_cpu == NULL ||\r\nqpti->req_dvma == 0) {\r\ndma_free_coherent(&op->dev, QSIZE(RES_QUEUE_LEN),\r\nqpti->res_cpu, qpti->res_dvma);\r\nprintk("QPTI: Cannot map request queue.\n");\r\nreturn -1;\r\n}\r\nmemset(qpti->res_cpu, 0, QSIZE(RES_QUEUE_LEN));\r\nmemset(qpti->req_cpu, 0, QSIZE(QLOGICPTI_REQ_QUEUE_LEN));\r\nreturn 0;\r\n}\r\nconst char *qlogicpti_info(struct Scsi_Host *host)\r\n{\r\nstatic char buf[80];\r\nstruct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;\r\nsprintf(buf, "PTI Qlogic,ISP SBUS SCSI irq %d regs at %p",\r\nqpti->qhost->irq, qpti->qregs);\r\nreturn buf;\r\n}\r\nstatic inline void marker_frob(struct Command_Entry *cmd)\r\n{\r\nstruct Marker_Entry *marker = (struct Marker_Entry *) cmd;\r\nmemset(marker, 0, sizeof(struct Marker_Entry));\r\nmarker->hdr.entry_cnt = 1;\r\nmarker->hdr.entry_type = ENTRY_MARKER;\r\nmarker->modifier = SYNC_ALL;\r\nmarker->rsvd = 0;\r\n}\r\nstatic inline void cmd_frob(struct Command_Entry *cmd, struct scsi_cmnd *Cmnd,\r\nstruct qlogicpti *qpti)\r\n{\r\nmemset(cmd, 0, sizeof(struct Command_Entry));\r\ncmd->hdr.entry_cnt = 1;\r\ncmd->hdr.entry_type = ENTRY_COMMAND;\r\ncmd->target_id = Cmnd->device->id;\r\ncmd->target_lun = Cmnd->device->lun;\r\ncmd->cdb_length = Cmnd->cmd_len;\r\ncmd->control_flags = 0;\r\nif (Cmnd->device->tagged_supported) {\r\nif (qpti->cmd_count[Cmnd->device->id] == 0)\r\nqpti->tag_ages[Cmnd->device->id] = jiffies;\r\nif (time_after(jiffies, qpti->tag_ages[Cmnd->device->id] + (5*HZ))) {\r\ncmd->control_flags = CFLAG_ORDERED_TAG;\r\nqpti->tag_ages[Cmnd->device->id] = jiffies;\r\n} else\r\ncmd->control_flags = CFLAG_SIMPLE_TAG;\r\n}\r\nif ((Cmnd->cmnd[0] == WRITE_6) ||\r\n(Cmnd->cmnd[0] == WRITE_10) ||\r\n(Cmnd->cmnd[0] == WRITE_12))\r\ncmd->control_flags |= CFLAG_WRITE;\r\nelse\r\ncmd->control_flags |= CFLAG_READ;\r\ncmd->time_out = Cmnd->request->timeout/HZ;\r\nmemcpy(cmd->cdb, Cmnd->cmnd, Cmnd->cmd_len);\r\n}\r\nstatic inline int load_cmd(struct scsi_cmnd *Cmnd, struct Command_Entry *cmd,\r\nstruct qlogicpti *qpti, u_int in_ptr, u_int out_ptr)\r\n{\r\nstruct dataseg *ds;\r\nstruct scatterlist *sg, *s;\r\nint i, n;\r\nif (scsi_bufflen(Cmnd)) {\r\nint sg_count;\r\nsg = scsi_sglist(Cmnd);\r\nsg_count = dma_map_sg(&qpti->op->dev, sg,\r\nscsi_sg_count(Cmnd),\r\nCmnd->sc_data_direction);\r\nds = cmd->dataseg;\r\ncmd->segment_cnt = sg_count;\r\nn = sg_count;\r\nif (n > 4)\r\nn = 4;\r\nfor_each_sg(sg, s, n, i) {\r\nds[i].d_base = sg_dma_address(s);\r\nds[i].d_count = sg_dma_len(s);\r\n}\r\nsg_count -= 4;\r\nsg = s;\r\nwhile (sg_count > 0) {\r\nstruct Continuation_Entry *cont;\r\n++cmd->hdr.entry_cnt;\r\ncont = (struct Continuation_Entry *) &qpti->req_cpu[in_ptr];\r\nin_ptr = NEXT_REQ_PTR(in_ptr);\r\nif (in_ptr == out_ptr)\r\nreturn -1;\r\ncont->hdr.entry_type = ENTRY_CONTINUATION;\r\ncont->hdr.entry_cnt = 0;\r\ncont->hdr.sys_def_1 = 0;\r\ncont->hdr.flags = 0;\r\ncont->reserved = 0;\r\nds = cont->dataseg;\r\nn = sg_count;\r\nif (n > 7)\r\nn = 7;\r\nfor_each_sg(sg, s, n, i) {\r\nds[i].d_base = sg_dma_address(s);\r\nds[i].d_count = sg_dma_len(s);\r\n}\r\nsg_count -= n;\r\nsg = s;\r\n}\r\n} else {\r\ncmd->dataseg[0].d_base = 0;\r\ncmd->dataseg[0].d_count = 0;\r\ncmd->segment_cnt = 1;\r\n}\r\ncmd->handle = in_ptr;\r\nqpti->cmd_slots[in_ptr] = Cmnd;\r\nqpti->cmd_count[Cmnd->device->id]++;\r\nsbus_writew(in_ptr, qpti->qregs + MBOX4);\r\nqpti->req_in_ptr = in_ptr;\r\nreturn in_ptr;\r\n}\r\nstatic inline void update_can_queue(struct Scsi_Host *host, u_int in_ptr, u_int out_ptr)\r\n{\r\nint num_free = QLOGICPTI_REQ_QUEUE_LEN - REQ_QUEUE_DEPTH(in_ptr, out_ptr) - 64;\r\nhost->can_queue = host->host_busy + num_free;\r\nhost->sg_tablesize = QLOGICPTI_MAX_SG(num_free);\r\n}\r\nstatic int qlogicpti_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct qlogicpti *qpti = shost_priv(sdev->host);\r\nint tgt = sdev->id;\r\nu_short param[6];\r\nif (sdev->sdtr) {\r\nqpti->dev_param[tgt].device_flags |= 0x10;\r\n} else {\r\nqpti->dev_param[tgt].synchronous_offset = 0;\r\nqpti->dev_param[tgt].synchronous_period = 0;\r\n}\r\nif (sdev->wdtr)\r\nqpti->dev_param[tgt].device_flags |= 0x20;\r\nparam[0] = MBOX_SET_TARGET_PARAMS;\r\nparam[1] = (tgt << 8);\r\nparam[2] = (qpti->dev_param[tgt].device_flags << 8);\r\nif (qpti->dev_param[tgt].device_flags & 0x10) {\r\nparam[3] = (qpti->dev_param[tgt].synchronous_offset << 8) |\r\nqpti->dev_param[tgt].synchronous_period;\r\n} else {\r\nparam[3] = 0;\r\n}\r\nqlogicpti_mbox_command(qpti, param, 0);\r\nreturn 0;\r\n}\r\nstatic int qlogicpti_queuecommand_lck(struct scsi_cmnd *Cmnd, void (*done)(struct scsi_cmnd *))\r\n{\r\nstruct Scsi_Host *host = Cmnd->device->host;\r\nstruct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;\r\nstruct Command_Entry *cmd;\r\nu_int out_ptr;\r\nint in_ptr;\r\nCmnd->scsi_done = done;\r\nin_ptr = qpti->req_in_ptr;\r\ncmd = (struct Command_Entry *) &qpti->req_cpu[in_ptr];\r\nout_ptr = sbus_readw(qpti->qregs + MBOX4);\r\nin_ptr = NEXT_REQ_PTR(in_ptr);\r\nif (in_ptr == out_ptr)\r\ngoto toss_command;\r\nif (qpti->send_marker) {\r\nmarker_frob(cmd);\r\nqpti->send_marker = 0;\r\nif (NEXT_REQ_PTR(in_ptr) == out_ptr) {\r\nsbus_writew(in_ptr, qpti->qregs + MBOX4);\r\nqpti->req_in_ptr = in_ptr;\r\ngoto toss_command;\r\n}\r\ncmd = (struct Command_Entry *) &qpti->req_cpu[in_ptr];\r\nin_ptr = NEXT_REQ_PTR(in_ptr);\r\n}\r\ncmd_frob(cmd, Cmnd, qpti);\r\nif ((in_ptr = load_cmd(Cmnd, cmd, qpti, in_ptr, out_ptr)) == -1)\r\ngoto toss_command;\r\nupdate_can_queue(host, in_ptr, out_ptr);\r\nreturn 0;\r\ntoss_command:\r\nprintk(KERN_EMERG "qlogicpti%d: request queue overflow\n",\r\nqpti->qpti_id);\r\nCmnd->result = DID_BUS_BUSY;\r\ndone(Cmnd);\r\nreturn 1;\r\n}\r\nstruct scsi_cmnd *qlogicpti_intr_handler(struct qlogicpti *qpti)\r\n{\r\nstruct scsi_cmnd *Cmnd, *done_queue = NULL;\r\nstruct Status_Entry *sts;\r\nu_int in_ptr, out_ptr;\r\nif (!(sbus_readw(qpti->qregs + SBUS_STAT) & SBUS_STAT_RINT))\r\nreturn NULL;\r\nin_ptr = sbus_readw(qpti->qregs + MBOX5);\r\nsbus_writew(HCCTRL_CRIRQ, qpti->qregs + HCCTRL);\r\nif (sbus_readw(qpti->qregs + SBUS_SEMAPHORE) & SBUS_SEMAPHORE_LCK) {\r\nswitch (sbus_readw(qpti->qregs + MBOX0)) {\r\ncase ASYNC_SCSI_BUS_RESET:\r\ncase EXECUTION_TIMEOUT_RESET:\r\nqpti->send_marker = 1;\r\nbreak;\r\ncase INVALID_COMMAND:\r\ncase HOST_INTERFACE_ERROR:\r\ncase COMMAND_ERROR:\r\ncase COMMAND_PARAM_ERROR:\r\nbreak;\r\n};\r\nsbus_writew(0, qpti->qregs + SBUS_SEMAPHORE);\r\n}\r\nout_ptr = qpti->res_out_ptr;\r\nwhile (out_ptr != in_ptr) {\r\nu_int cmd_slot;\r\nsts = (struct Status_Entry *) &qpti->res_cpu[out_ptr];\r\nout_ptr = NEXT_RES_PTR(out_ptr);\r\ncmd_slot = sts->handle;\r\nCmnd = qpti->cmd_slots[cmd_slot];\r\nqpti->cmd_slots[cmd_slot] = NULL;\r\nif (sts->completion_status == CS_RESET_OCCURRED ||\r\nsts->completion_status == CS_ABORTED ||\r\n(sts->status_flags & STF_BUS_RESET))\r\nqpti->send_marker = 1;\r\nif (sts->state_flags & SF_GOT_SENSE)\r\nmemcpy(Cmnd->sense_buffer, sts->req_sense_data,\r\nSCSI_SENSE_BUFFERSIZE);\r\nif (sts->hdr.entry_type == ENTRY_STATUS)\r\nCmnd->result =\r\nqlogicpti_return_status(sts, qpti->qpti_id);\r\nelse\r\nCmnd->result = DID_ERROR << 16;\r\nif (scsi_bufflen(Cmnd))\r\ndma_unmap_sg(&qpti->op->dev,\r\nscsi_sglist(Cmnd), scsi_sg_count(Cmnd),\r\nCmnd->sc_data_direction);\r\nqpti->cmd_count[Cmnd->device->id]--;\r\nsbus_writew(out_ptr, qpti->qregs + MBOX5);\r\nCmnd->host_scribble = (unsigned char *) done_queue;\r\ndone_queue = Cmnd;\r\n}\r\nqpti->res_out_ptr = out_ptr;\r\nreturn done_queue;\r\n}\r\nstatic irqreturn_t qpti_intr(int irq, void *dev_id)\r\n{\r\nstruct qlogicpti *qpti = dev_id;\r\nunsigned long flags;\r\nstruct scsi_cmnd *dq;\r\nspin_lock_irqsave(qpti->qhost->host_lock, flags);\r\ndq = qlogicpti_intr_handler(qpti);\r\nif (dq != NULL) {\r\ndo {\r\nstruct scsi_cmnd *next;\r\nnext = (struct scsi_cmnd *) dq->host_scribble;\r\ndq->scsi_done(dq);\r\ndq = next;\r\n} while (dq != NULL);\r\n}\r\nspin_unlock_irqrestore(qpti->qhost->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int qlogicpti_abort(struct scsi_cmnd *Cmnd)\r\n{\r\nu_short param[6];\r\nstruct Scsi_Host *host = Cmnd->device->host;\r\nstruct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;\r\nint return_status = SUCCESS;\r\nu32 cmd_cookie;\r\nint i;\r\nprintk(KERN_WARNING "qlogicpti%d: Aborting cmd for tgt[%d] lun[%d]\n",\r\nqpti->qpti_id, (int)Cmnd->device->id, (int)Cmnd->device->lun);\r\nqlogicpti_disable_irqs(qpti);\r\nfor (i = 0; i < QLOGICPTI_REQ_QUEUE_LEN + 1; i++)\r\nif (qpti->cmd_slots[i] == Cmnd)\r\nbreak;\r\ncmd_cookie = i;\r\nparam[0] = MBOX_ABORT;\r\nparam[1] = (((u_short) Cmnd->device->id) << 8) | Cmnd->device->lun;\r\nparam[2] = cmd_cookie >> 16;\r\nparam[3] = cmd_cookie & 0xffff;\r\nif (qlogicpti_mbox_command(qpti, param, 0) ||\r\n(param[0] != MBOX_COMMAND_COMPLETE)) {\r\nprintk(KERN_EMERG "qlogicpti%d: scsi abort failure: %x\n",\r\nqpti->qpti_id, param[0]);\r\nreturn_status = FAILED;\r\n}\r\nqlogicpti_enable_irqs(qpti);\r\nreturn return_status;\r\n}\r\nstatic int qlogicpti_reset(struct scsi_cmnd *Cmnd)\r\n{\r\nu_short param[6];\r\nstruct Scsi_Host *host = Cmnd->device->host;\r\nstruct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;\r\nint return_status = SUCCESS;\r\nprintk(KERN_WARNING "qlogicpti%d: Resetting SCSI bus!\n",\r\nqpti->qpti_id);\r\nqlogicpti_disable_irqs(qpti);\r\nparam[0] = MBOX_BUS_RESET;\r\nparam[1] = qpti->host_param.bus_reset_delay;\r\nif (qlogicpti_mbox_command(qpti, param, 0) ||\r\n(param[0] != MBOX_COMMAND_COMPLETE)) {\r\nprintk(KERN_EMERG "qlogicisp%d: scsi bus reset failure: %x\n",\r\nqpti->qpti_id, param[0]);\r\nreturn_status = FAILED;\r\n}\r\nqlogicpti_enable_irqs(qpti);\r\nreturn return_status;\r\n}\r\nstatic int qpti_sbus_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct Scsi_Host *host;\r\nstruct qlogicpti *qpti;\r\nstatic int nqptis;\r\nconst char *fcode;\r\nif (op->archdata.irqs[0] == 0)\r\nreturn -ENODEV;\r\nhost = scsi_host_alloc(&qpti_template, sizeof(struct qlogicpti));\r\nif (!host)\r\nreturn -ENOMEM;\r\nqpti = shost_priv(host);\r\nhost->max_id = MAX_TARGETS;\r\nqpti->qhost = host;\r\nqpti->op = op;\r\nqpti->qpti_id = nqptis;\r\nstrcpy(qpti->prom_name, op->dev.of_node->name);\r\nqpti->is_pti = strcmp(qpti->prom_name, "QLGC,isp");\r\nif (qpti_map_regs(qpti) < 0)\r\ngoto fail_unlink;\r\nif (qpti_register_irq(qpti) < 0)\r\ngoto fail_unmap_regs;\r\nqpti_get_scsi_id(qpti);\r\nqpti_get_bursts(qpti);\r\nqpti_get_clock(qpti);\r\nmemset(qpti->cmd_slots, 0, sizeof(qpti->cmd_slots));\r\nif (qpti_map_queues(qpti) < 0)\r\ngoto fail_free_irq;\r\nif (qlogicpti_load_firmware(qpti))\r\ngoto fail_unmap_queues;\r\nif (qpti->is_pti) {\r\nif (qlogicpti_verify_tmon(qpti))\r\ngoto fail_unmap_queues;\r\n}\r\nif (qlogicpti_reset_hardware(host))\r\ngoto fail_unmap_queues;\r\nprintk("(Firmware v%d.%d.%d)", qpti->fware_majrev,\r\nqpti->fware_minrev, qpti->fware_micrev);\r\nfcode = of_get_property(dp, "isp-fcode", NULL);\r\nif (fcode && fcode[0])\r\nprintk("(FCode %s)", fcode);\r\nif (of_find_property(dp, "differential", NULL) != NULL)\r\nqpti->differential = 1;\r\nprintk("\nqlogicpti%d: [%s Wide, using %s interface]\n",\r\nqpti->qpti_id,\r\n(qpti->ultra ? "Ultra" : "Fast"),\r\n(qpti->differential ? "differential" : "single ended"));\r\nif (scsi_add_host(host, &op->dev)) {\r\nprintk("qlogicpti%d: Failed scsi_add_host\n", qpti->qpti_id);\r\ngoto fail_unmap_queues;\r\n}\r\ndev_set_drvdata(&op->dev, qpti);\r\nqpti_chain_add(qpti);\r\nscsi_scan_host(host);\r\nnqptis++;\r\nreturn 0;\r\nfail_unmap_queues:\r\n#define QSIZE(entries) (((entries) + 1) * QUEUE_ENTRY_LEN)\r\ndma_free_coherent(&op->dev,\r\nQSIZE(RES_QUEUE_LEN),\r\nqpti->res_cpu, qpti->res_dvma);\r\ndma_free_coherent(&op->dev,\r\nQSIZE(QLOGICPTI_REQ_QUEUE_LEN),\r\nqpti->req_cpu, qpti->req_dvma);\r\n#undef QSIZE\r\nfail_unmap_regs:\r\nof_iounmap(&op->resource[0], qpti->qregs,\r\nresource_size(&op->resource[0]));\r\nif (qpti->is_pti)\r\nof_iounmap(&op->resource[0], qpti->sreg,\r\nsizeof(unsigned char));\r\nfail_free_irq:\r\nfree_irq(qpti->irq, qpti);\r\nfail_unlink:\r\nscsi_host_put(host);\r\nreturn -ENODEV;\r\n}\r\nstatic int qpti_sbus_remove(struct platform_device *op)\r\n{\r\nstruct qlogicpti *qpti = dev_get_drvdata(&op->dev);\r\nqpti_chain_del(qpti);\r\nscsi_remove_host(qpti->qhost);\r\nsbus_writew(0, qpti->qregs + SBUS_CTRL);\r\nfree_irq(qpti->irq, qpti);\r\n#define QSIZE(entries) (((entries) + 1) * QUEUE_ENTRY_LEN)\r\ndma_free_coherent(&op->dev,\r\nQSIZE(RES_QUEUE_LEN),\r\nqpti->res_cpu, qpti->res_dvma);\r\ndma_free_coherent(&op->dev,\r\nQSIZE(QLOGICPTI_REQ_QUEUE_LEN),\r\nqpti->req_cpu, qpti->req_dvma);\r\n#undef QSIZE\r\nof_iounmap(&op->resource[0], qpti->qregs,\r\nresource_size(&op->resource[0]));\r\nif (qpti->is_pti)\r\nof_iounmap(&op->resource[0], qpti->sreg, sizeof(unsigned char));\r\nscsi_host_put(qpti->qhost);\r\nreturn 0;\r\n}\r\nstatic int __init qpti_init(void)\r\n{\r\nreturn platform_driver_register(&qpti_sbus_driver);\r\n}\r\nstatic void __exit qpti_exit(void)\r\n{\r\nplatform_driver_unregister(&qpti_sbus_driver);\r\n}
