static inline void WR(struct i2c_au1550_data *a, int r, unsigned long v)\r\n{\r\n__raw_writel(v, a->psc_base + r);\r\nwmb();\r\n}\r\nstatic inline unsigned long RD(struct i2c_au1550_data *a, int r)\r\n{\r\nreturn __raw_readl(a->psc_base + r);\r\n}\r\nstatic int wait_xfer_done(struct i2c_au1550_data *adap)\r\n{\r\nint i;\r\nfor (i = 0; i < adap->xfer_timeout; i++) {\r\nif (RD(adap, PSC_SMBSTAT) & PSC_SMBSTAT_TE)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int wait_ack(struct i2c_au1550_data *adap)\r\n{\r\nunsigned long stat;\r\nif (wait_xfer_done(adap))\r\nreturn -ETIMEDOUT;\r\nstat = RD(adap, PSC_SMBEVNT);\r\nif ((stat & (PSC_SMBEVNT_DN | PSC_SMBEVNT_AN | PSC_SMBEVNT_AL)) != 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int wait_master_done(struct i2c_au1550_data *adap)\r\n{\r\nint i;\r\nfor (i = 0; i < 2 * adap->xfer_timeout; i++) {\r\nif ((RD(adap, PSC_SMBEVNT) & PSC_SMBEVNT_MD) != 0)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int\r\ndo_address(struct i2c_au1550_data *adap, unsigned int addr, int rd, int q)\r\n{\r\nunsigned long stat;\r\nstat = RD(adap, PSC_SMBSTAT);\r\nWR(adap, PSC_SMBEVNT, PSC_SMBEVNT_ALLCLR);\r\nif (!(stat & PSC_SMBSTAT_TE) || !(stat & PSC_SMBSTAT_RE)) {\r\nWR(adap, PSC_SMBPCR, PSC_SMBPCR_DC);\r\nwhile ((RD(adap, PSC_SMBPCR) & PSC_SMBPCR_DC) != 0)\r\ncpu_relax();\r\nudelay(50);\r\n}\r\naddr <<= 1;\r\nif (rd)\r\naddr |= 1;\r\nif (q)\r\naddr |= PSC_SMBTXRX_STP;\r\nWR(adap, PSC_SMBTXRX, addr);\r\nWR(adap, PSC_SMBPCR, PSC_SMBPCR_MS);\r\nif (wait_ack(adap))\r\nreturn -EIO;\r\nreturn (q) ? wait_master_done(adap) : 0;\r\n}\r\nstatic int wait_for_rx_byte(struct i2c_au1550_data *adap, unsigned char *out)\r\n{\r\nint j;\r\nif (wait_xfer_done(adap))\r\nreturn -EIO;\r\nj = adap->xfer_timeout * 100;\r\ndo {\r\nj--;\r\nif (j <= 0)\r\nreturn -EIO;\r\nif ((RD(adap, PSC_SMBSTAT) & PSC_SMBSTAT_RE) == 0)\r\nj = 0;\r\nelse\r\nudelay(1);\r\n} while (j > 0);\r\n*out = RD(adap, PSC_SMBTXRX);\r\nreturn 0;\r\n}\r\nstatic int i2c_read(struct i2c_au1550_data *adap, unsigned char *buf,\r\nunsigned int len)\r\n{\r\nint i;\r\nif (len == 0)\r\nreturn 0;\r\ni = 0;\r\nwhile (i < (len - 1)) {\r\nWR(adap, PSC_SMBTXRX, 0);\r\nif (wait_for_rx_byte(adap, &buf[i]))\r\nreturn -EIO;\r\ni++;\r\n}\r\nWR(adap, PSC_SMBTXRX, PSC_SMBTXRX_STP);\r\nif (wait_master_done(adap))\r\nreturn -EIO;\r\nbuf[i] = (unsigned char)(RD(adap, PSC_SMBTXRX) & 0xff);\r\nreturn 0;\r\n}\r\nstatic int i2c_write(struct i2c_au1550_data *adap, unsigned char *buf,\r\nunsigned int len)\r\n{\r\nint i;\r\nunsigned long data;\r\nif (len == 0)\r\nreturn 0;\r\ni = 0;\r\nwhile (i < (len-1)) {\r\ndata = buf[i];\r\nWR(adap, PSC_SMBTXRX, data);\r\nif (wait_ack(adap))\r\nreturn -EIO;\r\ni++;\r\n}\r\ndata = buf[i];\r\ndata |= PSC_SMBTXRX_STP;\r\nWR(adap, PSC_SMBTXRX, data);\r\nif (wait_master_done(adap))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nau1550_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct i2c_au1550_data *adap = i2c_adap->algo_data;\r\nstruct i2c_msg *p;\r\nint i, err = 0;\r\nWR(adap, PSC_CTRL, PSC_CTRL_ENABLE);\r\nfor (i = 0; !err && i < num; i++) {\r\np = &msgs[i];\r\nerr = do_address(adap, p->addr, p->flags & I2C_M_RD,\r\n(p->len == 0));\r\nif (err || !p->len)\r\ncontinue;\r\nif (p->flags & I2C_M_RD)\r\nerr = i2c_read(adap, p->buf, p->len);\r\nelse\r\nerr = i2c_write(adap, p->buf, p->len);\r\n}\r\nif (err == 0)\r\nerr = num;\r\nWR(adap, PSC_CTRL, PSC_CTRL_SUSPEND);\r\nreturn err;\r\n}\r\nstatic u32 au1550_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic void i2c_au1550_setup(struct i2c_au1550_data *priv)\r\n{\r\nunsigned long cfg;\r\nWR(priv, PSC_CTRL, PSC_CTRL_DISABLE);\r\nWR(priv, PSC_SEL, PSC_SEL_PS_SMBUSMODE);\r\nWR(priv, PSC_SMBCFG, 0);\r\nWR(priv, PSC_CTRL, PSC_CTRL_ENABLE);\r\nwhile ((RD(priv, PSC_SMBSTAT) & PSC_SMBSTAT_SR) == 0)\r\ncpu_relax();\r\ncfg = PSC_SMBCFG_RT_FIFO8 | PSC_SMBCFG_TT_FIFO8 | PSC_SMBCFG_DD_DISABLE;\r\nWR(priv, PSC_SMBCFG, cfg);\r\ncfg |= PSC_SMBCFG_SET_DIV(PSC_SMBCFG_DIV8);\r\nWR(priv, PSC_SMBCFG, cfg);\r\nWR(priv, PSC_SMBMSK, PSC_SMBMSK_ALLMASK);\r\nWR(priv, PSC_SMBTMR, PSC_SMBTMR_SET_TH(0) | PSC_SMBTMR_SET_PS(15) | \\r\nPSC_SMBTMR_SET_PU(15) | PSC_SMBTMR_SET_SH(15) | \\r\nPSC_SMBTMR_SET_SU(15) | PSC_SMBTMR_SET_CL(15) | \\r\nPSC_SMBTMR_SET_CH(15));\r\ncfg |= PSC_SMBCFG_DE_ENABLE;\r\nWR(priv, PSC_SMBCFG, cfg);\r\nwhile ((RD(priv, PSC_SMBSTAT) & PSC_SMBSTAT_SR) == 0)\r\ncpu_relax();\r\nWR(priv, PSC_CTRL, PSC_CTRL_SUSPEND);\r\n}\r\nstatic void i2c_au1550_disable(struct i2c_au1550_data *priv)\r\n{\r\nWR(priv, PSC_SMBCFG, 0);\r\nWR(priv, PSC_CTRL, PSC_CTRL_DISABLE);\r\n}\r\nstatic int\r\ni2c_au1550_probe(struct platform_device *pdev)\r\n{\r\nstruct i2c_au1550_data *priv;\r\nstruct resource *r;\r\nint ret;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\npriv = kzalloc(sizeof(struct i2c_au1550_data), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npriv->ioarea = request_mem_region(r->start, resource_size(r),\r\npdev->name);\r\nif (!priv->ioarea) {\r\nret = -EBUSY;\r\ngoto out_mem;\r\n}\r\npriv->psc_base = ioremap(r->start, resource_size(r));\r\nif (!priv->psc_base) {\r\nret = -EIO;\r\ngoto out_map;\r\n}\r\npriv->xfer_timeout = 200;\r\npriv->adap.nr = pdev->id;\r\npriv->adap.algo = &au1550_algo;\r\npriv->adap.algo_data = priv;\r\npriv->adap.dev.parent = &pdev->dev;\r\nstrlcpy(priv->adap.name, "Au1xxx PSC I2C", sizeof(priv->adap.name));\r\ni2c_au1550_setup(priv);\r\nret = i2c_add_numbered_adapter(&priv->adap);\r\nif (ret == 0) {\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}\r\ni2c_au1550_disable(priv);\r\niounmap(priv->psc_base);\r\nout_map:\r\nrelease_resource(priv->ioarea);\r\nkfree(priv->ioarea);\r\nout_mem:\r\nkfree(priv);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int i2c_au1550_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_au1550_data *priv = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&priv->adap);\r\ni2c_au1550_disable(priv);\r\niounmap(priv->psc_base);\r\nrelease_resource(priv->ioarea);\r\nkfree(priv->ioarea);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int i2c_au1550_suspend(struct device *dev)\r\n{\r\nstruct i2c_au1550_data *priv = dev_get_drvdata(dev);\r\ni2c_au1550_disable(priv);\r\nreturn 0;\r\n}\r\nstatic int i2c_au1550_resume(struct device *dev)\r\n{\r\nstruct i2c_au1550_data *priv = dev_get_drvdata(dev);\r\ni2c_au1550_setup(priv);\r\nreturn 0;\r\n}
