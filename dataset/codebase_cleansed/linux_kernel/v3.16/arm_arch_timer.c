static __always_inline\r\nvoid arch_timer_reg_write(int access, enum arch_timer_reg reg, u32 val,\r\nstruct clock_event_device *clk)\r\n{\r\nif (access == ARCH_TIMER_MEM_PHYS_ACCESS) {\r\nstruct arch_timer *timer = to_arch_timer(clk);\r\nswitch (reg) {\r\ncase ARCH_TIMER_REG_CTRL:\r\nwritel_relaxed(val, timer->base + CNTP_CTL);\r\nbreak;\r\ncase ARCH_TIMER_REG_TVAL:\r\nwritel_relaxed(val, timer->base + CNTP_TVAL);\r\nbreak;\r\n}\r\n} else if (access == ARCH_TIMER_MEM_VIRT_ACCESS) {\r\nstruct arch_timer *timer = to_arch_timer(clk);\r\nswitch (reg) {\r\ncase ARCH_TIMER_REG_CTRL:\r\nwritel_relaxed(val, timer->base + CNTV_CTL);\r\nbreak;\r\ncase ARCH_TIMER_REG_TVAL:\r\nwritel_relaxed(val, timer->base + CNTV_TVAL);\r\nbreak;\r\n}\r\n} else {\r\narch_timer_reg_write_cp15(access, reg, val);\r\n}\r\n}\r\nstatic __always_inline\r\nu32 arch_timer_reg_read(int access, enum arch_timer_reg reg,\r\nstruct clock_event_device *clk)\r\n{\r\nu32 val;\r\nif (access == ARCH_TIMER_MEM_PHYS_ACCESS) {\r\nstruct arch_timer *timer = to_arch_timer(clk);\r\nswitch (reg) {\r\ncase ARCH_TIMER_REG_CTRL:\r\nval = readl_relaxed(timer->base + CNTP_CTL);\r\nbreak;\r\ncase ARCH_TIMER_REG_TVAL:\r\nval = readl_relaxed(timer->base + CNTP_TVAL);\r\nbreak;\r\n}\r\n} else if (access == ARCH_TIMER_MEM_VIRT_ACCESS) {\r\nstruct arch_timer *timer = to_arch_timer(clk);\r\nswitch (reg) {\r\ncase ARCH_TIMER_REG_CTRL:\r\nval = readl_relaxed(timer->base + CNTV_CTL);\r\nbreak;\r\ncase ARCH_TIMER_REG_TVAL:\r\nval = readl_relaxed(timer->base + CNTV_TVAL);\r\nbreak;\r\n}\r\n} else {\r\nval = arch_timer_reg_read_cp15(access, reg);\r\n}\r\nreturn val;\r\n}\r\nstatic __always_inline irqreturn_t timer_handler(const int access,\r\nstruct clock_event_device *evt)\r\n{\r\nunsigned long ctrl;\r\nctrl = arch_timer_reg_read(access, ARCH_TIMER_REG_CTRL, evt);\r\nif (ctrl & ARCH_TIMER_CTRL_IT_STAT) {\r\nctrl |= ARCH_TIMER_CTRL_IT_MASK;\r\narch_timer_reg_write(access, ARCH_TIMER_REG_CTRL, ctrl, evt);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t arch_timer_handler_virt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nreturn timer_handler(ARCH_TIMER_VIRT_ACCESS, evt);\r\n}\r\nstatic irqreturn_t arch_timer_handler_phys(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nreturn timer_handler(ARCH_TIMER_PHYS_ACCESS, evt);\r\n}\r\nstatic irqreturn_t arch_timer_handler_phys_mem(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nreturn timer_handler(ARCH_TIMER_MEM_PHYS_ACCESS, evt);\r\n}\r\nstatic irqreturn_t arch_timer_handler_virt_mem(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nreturn timer_handler(ARCH_TIMER_MEM_VIRT_ACCESS, evt);\r\n}\r\nstatic __always_inline void timer_set_mode(const int access, int mode,\r\nstruct clock_event_device *clk)\r\n{\r\nunsigned long ctrl;\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\nctrl = arch_timer_reg_read(access, ARCH_TIMER_REG_CTRL, clk);\r\nctrl &= ~ARCH_TIMER_CTRL_ENABLE;\r\narch_timer_reg_write(access, ARCH_TIMER_REG_CTRL, ctrl, clk);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void arch_timer_set_mode_virt(enum clock_event_mode mode,\r\nstruct clock_event_device *clk)\r\n{\r\ntimer_set_mode(ARCH_TIMER_VIRT_ACCESS, mode, clk);\r\n}\r\nstatic void arch_timer_set_mode_phys(enum clock_event_mode mode,\r\nstruct clock_event_device *clk)\r\n{\r\ntimer_set_mode(ARCH_TIMER_PHYS_ACCESS, mode, clk);\r\n}\r\nstatic void arch_timer_set_mode_virt_mem(enum clock_event_mode mode,\r\nstruct clock_event_device *clk)\r\n{\r\ntimer_set_mode(ARCH_TIMER_MEM_VIRT_ACCESS, mode, clk);\r\n}\r\nstatic void arch_timer_set_mode_phys_mem(enum clock_event_mode mode,\r\nstruct clock_event_device *clk)\r\n{\r\ntimer_set_mode(ARCH_TIMER_MEM_PHYS_ACCESS, mode, clk);\r\n}\r\nstatic __always_inline void set_next_event(const int access, unsigned long evt,\r\nstruct clock_event_device *clk)\r\n{\r\nunsigned long ctrl;\r\nctrl = arch_timer_reg_read(access, ARCH_TIMER_REG_CTRL, clk);\r\nctrl |= ARCH_TIMER_CTRL_ENABLE;\r\nctrl &= ~ARCH_TIMER_CTRL_IT_MASK;\r\narch_timer_reg_write(access, ARCH_TIMER_REG_TVAL, evt, clk);\r\narch_timer_reg_write(access, ARCH_TIMER_REG_CTRL, ctrl, clk);\r\n}\r\nstatic int arch_timer_set_next_event_virt(unsigned long evt,\r\nstruct clock_event_device *clk)\r\n{\r\nset_next_event(ARCH_TIMER_VIRT_ACCESS, evt, clk);\r\nreturn 0;\r\n}\r\nstatic int arch_timer_set_next_event_phys(unsigned long evt,\r\nstruct clock_event_device *clk)\r\n{\r\nset_next_event(ARCH_TIMER_PHYS_ACCESS, evt, clk);\r\nreturn 0;\r\n}\r\nstatic int arch_timer_set_next_event_virt_mem(unsigned long evt,\r\nstruct clock_event_device *clk)\r\n{\r\nset_next_event(ARCH_TIMER_MEM_VIRT_ACCESS, evt, clk);\r\nreturn 0;\r\n}\r\nstatic int arch_timer_set_next_event_phys_mem(unsigned long evt,\r\nstruct clock_event_device *clk)\r\n{\r\nset_next_event(ARCH_TIMER_MEM_PHYS_ACCESS, evt, clk);\r\nreturn 0;\r\n}\r\nstatic void __arch_timer_setup(unsigned type,\r\nstruct clock_event_device *clk)\r\n{\r\nclk->features = CLOCK_EVT_FEAT_ONESHOT;\r\nif (type == ARCH_CP15_TIMER) {\r\nif (arch_timer_c3stop)\r\nclk->features |= CLOCK_EVT_FEAT_C3STOP;\r\nclk->name = "arch_sys_timer";\r\nclk->rating = 450;\r\nclk->cpumask = cpumask_of(smp_processor_id());\r\nif (arch_timer_use_virtual) {\r\nclk->irq = arch_timer_ppi[VIRT_PPI];\r\nclk->set_mode = arch_timer_set_mode_virt;\r\nclk->set_next_event = arch_timer_set_next_event_virt;\r\n} else {\r\nclk->irq = arch_timer_ppi[PHYS_SECURE_PPI];\r\nclk->set_mode = arch_timer_set_mode_phys;\r\nclk->set_next_event = arch_timer_set_next_event_phys;\r\n}\r\n} else {\r\nclk->features |= CLOCK_EVT_FEAT_DYNIRQ;\r\nclk->name = "arch_mem_timer";\r\nclk->rating = 400;\r\nclk->cpumask = cpu_all_mask;\r\nif (arch_timer_mem_use_virtual) {\r\nclk->set_mode = arch_timer_set_mode_virt_mem;\r\nclk->set_next_event =\r\narch_timer_set_next_event_virt_mem;\r\n} else {\r\nclk->set_mode = arch_timer_set_mode_phys_mem;\r\nclk->set_next_event =\r\narch_timer_set_next_event_phys_mem;\r\n}\r\n}\r\nclk->set_mode(CLOCK_EVT_MODE_SHUTDOWN, clk);\r\nclockevents_config_and_register(clk, arch_timer_rate, 0xf, 0x7fffffff);\r\n}\r\nstatic void arch_timer_configure_evtstream(void)\r\n{\r\nint evt_stream_div, pos;\r\nevt_stream_div = arch_timer_rate / ARCH_TIMER_EVT_STREAM_FREQ;\r\npos = fls(evt_stream_div);\r\nif (pos > 1 && !(evt_stream_div & (1 << (pos - 2))))\r\npos--;\r\narch_timer_evtstrm_enable(min(pos, 15));\r\n}\r\nstatic int arch_timer_setup(struct clock_event_device *clk)\r\n{\r\n__arch_timer_setup(ARCH_CP15_TIMER, clk);\r\nif (arch_timer_use_virtual)\r\nenable_percpu_irq(arch_timer_ppi[VIRT_PPI], 0);\r\nelse {\r\nenable_percpu_irq(arch_timer_ppi[PHYS_SECURE_PPI], 0);\r\nif (arch_timer_ppi[PHYS_NONSECURE_PPI])\r\nenable_percpu_irq(arch_timer_ppi[PHYS_NONSECURE_PPI], 0);\r\n}\r\narch_counter_set_user_access();\r\nif (IS_ENABLED(CONFIG_ARM_ARCH_TIMER_EVTSTREAM))\r\narch_timer_configure_evtstream();\r\nreturn 0;\r\n}\r\nstatic void\r\narch_timer_detect_rate(void __iomem *cntbase, struct device_node *np)\r\n{\r\nif (arch_timer_rate)\r\nreturn;\r\nif (of_property_read_u32(np, "clock-frequency", &arch_timer_rate)) {\r\nif (cntbase)\r\narch_timer_rate = readl_relaxed(cntbase + CNTFRQ);\r\nelse\r\narch_timer_rate = arch_timer_get_cntfrq();\r\n}\r\nif (arch_timer_rate == 0)\r\npr_warn("Architected timer frequency not available\n");\r\n}\r\nstatic void arch_timer_banner(unsigned type)\r\n{\r\npr_info("Architected %s%s%s timer(s) running at %lu.%02luMHz (%s%s%s).\n",\r\ntype & ARCH_CP15_TIMER ? "cp15" : "",\r\ntype == (ARCH_CP15_TIMER | ARCH_MEM_TIMER) ? " and " : "",\r\ntype & ARCH_MEM_TIMER ? "mmio" : "",\r\n(unsigned long)arch_timer_rate / 1000000,\r\n(unsigned long)(arch_timer_rate / 10000) % 100,\r\ntype & ARCH_CP15_TIMER ?\r\narch_timer_use_virtual ? "virt" : "phys" :\r\n"",\r\ntype == (ARCH_CP15_TIMER | ARCH_MEM_TIMER) ? "/" : "",\r\ntype & ARCH_MEM_TIMER ?\r\narch_timer_mem_use_virtual ? "virt" : "phys" :\r\n"");\r\n}\r\nu32 arch_timer_get_rate(void)\r\n{\r\nreturn arch_timer_rate;\r\n}\r\nstatic u64 arch_counter_get_cntvct_mem(void)\r\n{\r\nu32 vct_lo, vct_hi, tmp_hi;\r\ndo {\r\nvct_hi = readl_relaxed(arch_counter_base + CNTVCT_HI);\r\nvct_lo = readl_relaxed(arch_counter_base + CNTVCT_LO);\r\ntmp_hi = readl_relaxed(arch_counter_base + CNTVCT_HI);\r\n} while (vct_hi != tmp_hi);\r\nreturn ((u64) vct_hi << 32) | vct_lo;\r\n}\r\nstatic cycle_t arch_counter_read(struct clocksource *cs)\r\n{\r\nreturn arch_timer_read_counter();\r\n}\r\nstatic cycle_t arch_counter_read_cc(const struct cyclecounter *cc)\r\n{\r\nreturn arch_timer_read_counter();\r\n}\r\nstruct timecounter *arch_timer_get_timecounter(void)\r\n{\r\nreturn &timecounter;\r\n}\r\nstatic void __init arch_counter_register(unsigned type)\r\n{\r\nu64 start_count;\r\nif (type & ARCH_CP15_TIMER)\r\narch_timer_read_counter = arch_counter_get_cntvct;\r\nelse\r\narch_timer_read_counter = arch_counter_get_cntvct_mem;\r\nstart_count = arch_timer_read_counter();\r\nclocksource_register_hz(&clocksource_counter, arch_timer_rate);\r\ncyclecounter.mult = clocksource_counter.mult;\r\ncyclecounter.shift = clocksource_counter.shift;\r\ntimecounter_init(&timecounter, &cyclecounter, start_count);\r\nsched_clock_register(arch_timer_read_counter, 56, arch_timer_rate);\r\n}\r\nstatic void arch_timer_stop(struct clock_event_device *clk)\r\n{\r\npr_debug("arch_timer_teardown disable IRQ%d cpu #%d\n",\r\nclk->irq, smp_processor_id());\r\nif (arch_timer_use_virtual)\r\ndisable_percpu_irq(arch_timer_ppi[VIRT_PPI]);\r\nelse {\r\ndisable_percpu_irq(arch_timer_ppi[PHYS_SECURE_PPI]);\r\nif (arch_timer_ppi[PHYS_NONSECURE_PPI])\r\ndisable_percpu_irq(arch_timer_ppi[PHYS_NONSECURE_PPI]);\r\n}\r\nclk->set_mode(CLOCK_EVT_MODE_UNUSED, clk);\r\n}\r\nstatic int arch_timer_cpu_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_STARTING:\r\narch_timer_setup(this_cpu_ptr(arch_timer_evt));\r\nbreak;\r\ncase CPU_DYING:\r\narch_timer_stop(this_cpu_ptr(arch_timer_evt));\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int arch_timer_cpu_pm_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nif (action == CPU_PM_ENTER)\r\nsaved_cntkctl = arch_timer_get_cntkctl();\r\nelse if (action == CPU_PM_ENTER_FAILED || action == CPU_PM_EXIT)\r\narch_timer_set_cntkctl(saved_cntkctl);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init arch_timer_cpu_pm_init(void)\r\n{\r\nreturn cpu_pm_register_notifier(&arch_timer_cpu_pm_notifier);\r\n}\r\nstatic int __init arch_timer_cpu_pm_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init arch_timer_register(void)\r\n{\r\nint err;\r\nint ppi;\r\narch_timer_evt = alloc_percpu(struct clock_event_device);\r\nif (!arch_timer_evt) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nif (arch_timer_use_virtual) {\r\nppi = arch_timer_ppi[VIRT_PPI];\r\nerr = request_percpu_irq(ppi, arch_timer_handler_virt,\r\n"arch_timer", arch_timer_evt);\r\n} else {\r\nppi = arch_timer_ppi[PHYS_SECURE_PPI];\r\nerr = request_percpu_irq(ppi, arch_timer_handler_phys,\r\n"arch_timer", arch_timer_evt);\r\nif (!err && arch_timer_ppi[PHYS_NONSECURE_PPI]) {\r\nppi = arch_timer_ppi[PHYS_NONSECURE_PPI];\r\nerr = request_percpu_irq(ppi, arch_timer_handler_phys,\r\n"arch_timer", arch_timer_evt);\r\nif (err)\r\nfree_percpu_irq(arch_timer_ppi[PHYS_SECURE_PPI],\r\narch_timer_evt);\r\n}\r\n}\r\nif (err) {\r\npr_err("arch_timer: can't register interrupt %d (%d)\n",\r\nppi, err);\r\ngoto out_free;\r\n}\r\nerr = register_cpu_notifier(&arch_timer_cpu_nb);\r\nif (err)\r\ngoto out_free_irq;\r\nerr = arch_timer_cpu_pm_init();\r\nif (err)\r\ngoto out_unreg_notify;\r\narch_timer_setup(this_cpu_ptr(arch_timer_evt));\r\nreturn 0;\r\nout_unreg_notify:\r\nunregister_cpu_notifier(&arch_timer_cpu_nb);\r\nout_free_irq:\r\nif (arch_timer_use_virtual)\r\nfree_percpu_irq(arch_timer_ppi[VIRT_PPI], arch_timer_evt);\r\nelse {\r\nfree_percpu_irq(arch_timer_ppi[PHYS_SECURE_PPI],\r\narch_timer_evt);\r\nif (arch_timer_ppi[PHYS_NONSECURE_PPI])\r\nfree_percpu_irq(arch_timer_ppi[PHYS_NONSECURE_PPI],\r\narch_timer_evt);\r\n}\r\nout_free:\r\nfree_percpu(arch_timer_evt);\r\nout:\r\nreturn err;\r\n}\r\nstatic int __init arch_timer_mem_register(void __iomem *base, unsigned int irq)\r\n{\r\nint ret;\r\nirq_handler_t func;\r\nstruct arch_timer *t;\r\nt = kzalloc(sizeof(*t), GFP_KERNEL);\r\nif (!t)\r\nreturn -ENOMEM;\r\nt->base = base;\r\nt->evt.irq = irq;\r\n__arch_timer_setup(ARCH_MEM_TIMER, &t->evt);\r\nif (arch_timer_mem_use_virtual)\r\nfunc = arch_timer_handler_virt_mem;\r\nelse\r\nfunc = arch_timer_handler_phys_mem;\r\nret = request_irq(irq, func, IRQF_TIMER, "arch_mem_timer", &t->evt);\r\nif (ret) {\r\npr_err("arch_timer: Failed to request mem timer irq\n");\r\nkfree(t);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __init arch_timer_common_init(void)\r\n{\r\nunsigned mask = ARCH_CP15_TIMER | ARCH_MEM_TIMER;\r\nif ((arch_timers_present & mask) != mask) {\r\nif (of_find_matching_node(NULL, arch_timer_mem_of_match) &&\r\n!(arch_timers_present & ARCH_MEM_TIMER))\r\nreturn;\r\nif (of_find_matching_node(NULL, arch_timer_of_match) &&\r\n!(arch_timers_present & ARCH_CP15_TIMER))\r\nreturn;\r\n}\r\narch_timer_banner(arch_timers_present);\r\narch_counter_register(arch_timers_present);\r\narch_timer_arch_init();\r\n}\r\nstatic void __init arch_timer_init(struct device_node *np)\r\n{\r\nint i;\r\nif (arch_timers_present & ARCH_CP15_TIMER) {\r\npr_warn("arch_timer: multiple nodes in dt, skipping\n");\r\nreturn;\r\n}\r\narch_timers_present |= ARCH_CP15_TIMER;\r\nfor (i = PHYS_SECURE_PPI; i < MAX_TIMER_PPI; i++)\r\narch_timer_ppi[i] = irq_of_parse_and_map(np, i);\r\narch_timer_detect_rate(NULL, np);\r\nif (is_hyp_mode_available() || !arch_timer_ppi[VIRT_PPI]) {\r\narch_timer_use_virtual = false;\r\nif (!arch_timer_ppi[PHYS_SECURE_PPI] ||\r\n!arch_timer_ppi[PHYS_NONSECURE_PPI]) {\r\npr_warn("arch_timer: No interrupt available, giving up\n");\r\nreturn;\r\n}\r\n}\r\narch_timer_c3stop = !of_property_read_bool(np, "always-on");\r\narch_timer_register();\r\narch_timer_common_init();\r\n}\r\nstatic void __init arch_timer_mem_init(struct device_node *np)\r\n{\r\nstruct device_node *frame, *best_frame = NULL;\r\nvoid __iomem *cntctlbase, *base;\r\nunsigned int irq;\r\nu32 cnttidr;\r\narch_timers_present |= ARCH_MEM_TIMER;\r\ncntctlbase = of_iomap(np, 0);\r\nif (!cntctlbase) {\r\npr_err("arch_timer: Can't find CNTCTLBase\n");\r\nreturn;\r\n}\r\ncnttidr = readl_relaxed(cntctlbase + CNTTIDR);\r\niounmap(cntctlbase);\r\nfor_each_available_child_of_node(np, frame) {\r\nint n;\r\nif (of_property_read_u32(frame, "frame-number", &n)) {\r\npr_err("arch_timer: Missing frame-number\n");\r\nof_node_put(best_frame);\r\nof_node_put(frame);\r\nreturn;\r\n}\r\nif (cnttidr & CNTTIDR_VIRT(n)) {\r\nof_node_put(best_frame);\r\nbest_frame = frame;\r\narch_timer_mem_use_virtual = true;\r\nbreak;\r\n}\r\nof_node_put(best_frame);\r\nbest_frame = of_node_get(frame);\r\n}\r\nbase = arch_counter_base = of_iomap(best_frame, 0);\r\nif (!base) {\r\npr_err("arch_timer: Can't map frame's registers\n");\r\nof_node_put(best_frame);\r\nreturn;\r\n}\r\nif (arch_timer_mem_use_virtual)\r\nirq = irq_of_parse_and_map(best_frame, 1);\r\nelse\r\nirq = irq_of_parse_and_map(best_frame, 0);\r\nof_node_put(best_frame);\r\nif (!irq) {\r\npr_err("arch_timer: Frame missing %s irq",\r\narch_timer_mem_use_virtual ? "virt" : "phys");\r\nreturn;\r\n}\r\narch_timer_detect_rate(base, np);\r\narch_timer_mem_register(base, irq);\r\narch_timer_common_init();\r\n}
