static inline unsigned int mbox_read_reg(size_t ofs)\r\n{\r\nreturn __raw_readl(mbox_base + ofs);\r\n}\r\nstatic inline void mbox_write_reg(u32 val, size_t ofs)\r\n{\r\n__raw_writel(val, mbox_base + ofs);\r\n}\r\nstatic int omap2_mbox_startup(struct omap_mbox *mbox)\r\n{\r\nu32 l;\r\npm_runtime_enable(mbox->dev->parent);\r\npm_runtime_get_sync(mbox->dev->parent);\r\nl = mbox_read_reg(MAILBOX_REVISION);\r\npr_debug("omap mailbox rev %d.%d\n", (l & 0xf0) >> 4, (l & 0x0f));\r\nreturn 0;\r\n}\r\nstatic void omap2_mbox_shutdown(struct omap_mbox *mbox)\r\n{\r\npm_runtime_put_sync(mbox->dev->parent);\r\npm_runtime_disable(mbox->dev->parent);\r\n}\r\nstatic mbox_msg_t omap2_mbox_fifo_read(struct omap_mbox *mbox)\r\n{\r\nstruct omap_mbox2_fifo *fifo =\r\n&((struct omap_mbox2_priv *)mbox->priv)->rx_fifo;\r\nreturn (mbox_msg_t) mbox_read_reg(fifo->msg);\r\n}\r\nstatic void omap2_mbox_fifo_write(struct omap_mbox *mbox, mbox_msg_t msg)\r\n{\r\nstruct omap_mbox2_fifo *fifo =\r\n&((struct omap_mbox2_priv *)mbox->priv)->tx_fifo;\r\nmbox_write_reg(msg, fifo->msg);\r\n}\r\nstatic int omap2_mbox_fifo_empty(struct omap_mbox *mbox)\r\n{\r\nstruct omap_mbox2_fifo *fifo =\r\n&((struct omap_mbox2_priv *)mbox->priv)->rx_fifo;\r\nreturn (mbox_read_reg(fifo->msg_stat) == 0);\r\n}\r\nstatic int omap2_mbox_fifo_full(struct omap_mbox *mbox)\r\n{\r\nstruct omap_mbox2_fifo *fifo =\r\n&((struct omap_mbox2_priv *)mbox->priv)->tx_fifo;\r\nreturn mbox_read_reg(fifo->fifo_stat);\r\n}\r\nstatic void omap2_mbox_enable_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\r\n{\r\nstruct omap_mbox2_priv *p = mbox->priv;\r\nu32 l, bit = (irq == IRQ_TX) ? p->notfull_bit : p->newmsg_bit;\r\nl = mbox_read_reg(p->irqenable);\r\nl |= bit;\r\nmbox_write_reg(l, p->irqenable);\r\n}\r\nstatic void omap2_mbox_disable_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\r\n{\r\nstruct omap_mbox2_priv *p = mbox->priv;\r\nu32 bit = (irq == IRQ_TX) ? p->notfull_bit : p->newmsg_bit;\r\nif (!p->intr_type)\r\nbit = mbox_read_reg(p->irqdisable) & ~bit;\r\nmbox_write_reg(bit, p->irqdisable);\r\n}\r\nstatic void omap2_mbox_ack_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\r\n{\r\nstruct omap_mbox2_priv *p = mbox->priv;\r\nu32 bit = (irq == IRQ_TX) ? p->notfull_bit : p->newmsg_bit;\r\nmbox_write_reg(bit, p->irqstatus);\r\nmbox_read_reg(p->irqstatus);\r\n}\r\nstatic int omap2_mbox_is_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)\r\n{\r\nstruct omap_mbox2_priv *p = mbox->priv;\r\nu32 bit = (irq == IRQ_TX) ? p->notfull_bit : p->newmsg_bit;\r\nu32 enable = mbox_read_reg(p->irqenable);\r\nu32 status = mbox_read_reg(p->irqstatus);\r\nreturn (int)(enable & status & bit);\r\n}\r\nstatic void omap2_mbox_save_ctx(struct omap_mbox *mbox)\r\n{\r\nint i;\r\nstruct omap_mbox2_priv *p = mbox->priv;\r\nint nr_regs;\r\nif (p->intr_type)\r\nnr_regs = OMAP4_MBOX_NR_REGS;\r\nelse\r\nnr_regs = MBOX_NR_REGS;\r\nfor (i = 0; i < nr_regs; i++) {\r\np->ctx[i] = mbox_read_reg(i * sizeof(u32));\r\ndev_dbg(mbox->dev, "%s: [%02x] %08x\n", __func__,\r\ni, p->ctx[i]);\r\n}\r\n}\r\nstatic void omap2_mbox_restore_ctx(struct omap_mbox *mbox)\r\n{\r\nint i;\r\nstruct omap_mbox2_priv *p = mbox->priv;\r\nint nr_regs;\r\nif (p->intr_type)\r\nnr_regs = OMAP4_MBOX_NR_REGS;\r\nelse\r\nnr_regs = MBOX_NR_REGS;\r\nfor (i = 0; i < nr_regs; i++) {\r\nmbox_write_reg(p->ctx[i], i * sizeof(u32));\r\ndev_dbg(mbox->dev, "%s: [%02x] %08x\n", __func__,\r\ni, p->ctx[i]);\r\n}\r\n}\r\nstatic int omap2_mbox_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem;\r\nint ret;\r\nstruct omap_mbox **list, *mbox, *mboxblk;\r\nstruct omap_mbox2_priv *priv, *privblk;\r\nstruct omap_mbox_pdata *pdata = pdev->dev.platform_data;\r\nstruct omap_mbox_dev_info *info;\r\nint i;\r\nif (!pdata || !pdata->info_cnt || !pdata->info) {\r\npr_err("%s: platform not supported\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nlist = kzalloc((pdata->info_cnt + 1) * sizeof(*list), GFP_KERNEL);\r\nif (!list)\r\nreturn -ENOMEM;\r\nmboxblk = mbox = kzalloc(pdata->info_cnt * sizeof(*mbox), GFP_KERNEL);\r\nif (!mboxblk) {\r\nret = -ENOMEM;\r\ngoto free_list;\r\n}\r\nprivblk = priv = kzalloc(pdata->info_cnt * sizeof(*priv), GFP_KERNEL);\r\nif (!privblk) {\r\nret = -ENOMEM;\r\ngoto free_mboxblk;\r\n}\r\ninfo = pdata->info;\r\nfor (i = 0; i < pdata->info_cnt; i++, info++, priv++) {\r\npriv->tx_fifo.msg = MAILBOX_MESSAGE(info->tx_id);\r\npriv->tx_fifo.fifo_stat = MAILBOX_FIFOSTATUS(info->tx_id);\r\npriv->rx_fifo.msg = MAILBOX_MESSAGE(info->rx_id);\r\npriv->rx_fifo.msg_stat = MAILBOX_MSGSTATUS(info->rx_id);\r\npriv->notfull_bit = MAILBOX_IRQ_NOTFULL(info->tx_id);\r\npriv->newmsg_bit = MAILBOX_IRQ_NEWMSG(info->rx_id);\r\nif (pdata->intr_type) {\r\npriv->irqenable = OMAP4_MAILBOX_IRQENABLE(info->usr_id);\r\npriv->irqstatus = OMAP4_MAILBOX_IRQSTATUS(info->usr_id);\r\npriv->irqdisable =\r\nOMAP4_MAILBOX_IRQENABLE_CLR(info->usr_id);\r\n} else {\r\npriv->irqenable = MAILBOX_IRQENABLE(info->usr_id);\r\npriv->irqstatus = MAILBOX_IRQSTATUS(info->usr_id);\r\npriv->irqdisable = MAILBOX_IRQENABLE(info->usr_id);\r\n}\r\npriv->intr_type = pdata->intr_type;\r\nmbox->priv = priv;\r\nmbox->name = info->name;\r\nmbox->ops = &omap2_mbox_ops;\r\nmbox->irq = platform_get_irq(pdev, info->irq_id);\r\nif (mbox->irq < 0) {\r\nret = mbox->irq;\r\ngoto free_privblk;\r\n}\r\nlist[i] = mbox++;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\nret = -ENOENT;\r\ngoto free_privblk;\r\n}\r\nmbox_base = ioremap(mem->start, resource_size(mem));\r\nif (!mbox_base) {\r\nret = -ENOMEM;\r\ngoto free_privblk;\r\n}\r\nret = omap_mbox_register(&pdev->dev, list);\r\nif (ret)\r\ngoto unmap_mbox;\r\nplatform_set_drvdata(pdev, list);\r\nreturn 0;\r\nunmap_mbox:\r\niounmap(mbox_base);\r\nfree_privblk:\r\nkfree(privblk);\r\nfree_mboxblk:\r\nkfree(mboxblk);\r\nfree_list:\r\nkfree(list);\r\nreturn ret;\r\n}\r\nstatic int omap2_mbox_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_mbox2_priv *privblk;\r\nstruct omap_mbox **list = platform_get_drvdata(pdev);\r\nstruct omap_mbox *mboxblk = list[0];\r\nprivblk = mboxblk->priv;\r\nomap_mbox_unregister();\r\niounmap(mbox_base);\r\nkfree(privblk);\r\nkfree(mboxblk);\r\nkfree(list);\r\nreturn 0;\r\n}\r\nstatic int __init omap2_mbox_init(void)\r\n{\r\nreturn platform_driver_register(&omap2_mbox_driver);\r\n}\r\nstatic void __exit omap2_mbox_exit(void)\r\n{\r\nplatform_driver_unregister(&omap2_mbox_driver);\r\n}
