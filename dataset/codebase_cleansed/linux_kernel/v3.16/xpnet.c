static void\r\nxpnet_receive(short partid, int channel, struct xpnet_message *msg)\r\n{\r\nstruct sk_buff *skb;\r\nvoid *dst;\r\nenum xp_retval ret;\r\nif (!XPNET_VALID_MSG(msg)) {\r\nxpc_received(partid, channel, (void *)msg);\r\nxpnet_device->stats.rx_errors++;\r\nreturn;\r\n}\r\ndev_dbg(xpnet, "received 0x%lx, %d, %d, %d\n", msg->buf_pa, msg->size,\r\nmsg->leadin_ignore, msg->tailout_ignore);\r\nskb = dev_alloc_skb(msg->size + L1_CACHE_BYTES);\r\nif (!skb) {\r\ndev_err(xpnet, "failed on dev_alloc_skb(%d)\n",\r\nmsg->size + L1_CACHE_BYTES);\r\nxpc_received(partid, channel, (void *)msg);\r\nxpnet_device->stats.rx_errors++;\r\nreturn;\r\n}\r\nskb_reserve(skb, (L1_CACHE_BYTES - ((u64)skb->data &\r\n(L1_CACHE_BYTES - 1)) +\r\nmsg->leadin_ignore));\r\nskb_put(skb, (msg->size - msg->leadin_ignore - msg->tailout_ignore));\r\nif ((XPNET_VERSION_MINOR(msg->version) == 1) &&\r\n(msg->embedded_bytes != 0)) {\r\ndev_dbg(xpnet, "copying embedded message. memcpy(0x%p, 0x%p, "\r\n"%lu)\n", skb->data, &msg->data,\r\n(size_t)msg->embedded_bytes);\r\nskb_copy_to_linear_data(skb, &msg->data,\r\n(size_t)msg->embedded_bytes);\r\n} else {\r\ndst = (void *)((u64)skb->data & ~(L1_CACHE_BYTES - 1));\r\ndev_dbg(xpnet, "transferring buffer to the skb->data area;\n\t"\r\n"xp_remote_memcpy(0x%p, 0x%p, %hu)\n", dst,\r\n(void *)msg->buf_pa, msg->size);\r\nret = xp_remote_memcpy(xp_pa(dst), msg->buf_pa, msg->size);\r\nif (ret != xpSuccess) {\r\ndev_err(xpnet, "xp_remote_memcpy(0x%p, 0x%p, 0x%hx) "\r\n"returned error=0x%x\n", dst,\r\n(void *)msg->buf_pa, msg->size, ret);\r\nxpc_received(partid, channel, (void *)msg);\r\nxpnet_device->stats.rx_errors++;\r\nreturn;\r\n}\r\n}\r\ndev_dbg(xpnet, "<skb->head=0x%p skb->data=0x%p skb->tail=0x%p "\r\n"skb->end=0x%p skb->len=%d\n", (void *)skb->head,\r\n(void *)skb->data, skb_tail_pointer(skb), skb_end_pointer(skb),\r\nskb->len);\r\nskb->protocol = eth_type_trans(skb, xpnet_device);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\ndev_dbg(xpnet, "passing skb to network layer\n"\r\n"\tskb->head=0x%p skb->data=0x%p skb->tail=0x%p "\r\n"skb->end=0x%p skb->len=%d\n",\r\n(void *)skb->head, (void *)skb->data, skb_tail_pointer(skb),\r\nskb_end_pointer(skb), skb->len);\r\nxpnet_device->stats.rx_packets++;\r\nxpnet_device->stats.rx_bytes += skb->len + ETH_HLEN;\r\nnetif_rx_ni(skb);\r\nxpc_received(partid, channel, (void *)msg);\r\n}\r\nstatic void\r\nxpnet_connection_activity(enum xp_retval reason, short partid, int channel,\r\nvoid *data, void *key)\r\n{\r\nDBUG_ON(partid < 0 || partid >= xp_max_npartitions);\r\nDBUG_ON(channel != XPC_NET_CHANNEL);\r\nswitch (reason) {\r\ncase xpMsgReceived:\r\nDBUG_ON(data == NULL);\r\nxpnet_receive(partid, channel, (struct xpnet_message *)data);\r\nbreak;\r\ncase xpConnected:\r\nspin_lock_bh(&xpnet_broadcast_lock);\r\n__set_bit(partid, xpnet_broadcast_partitions);\r\nspin_unlock_bh(&xpnet_broadcast_lock);\r\nnetif_carrier_on(xpnet_device);\r\ndev_dbg(xpnet, "%s connected to partition %d\n",\r\nxpnet_device->name, partid);\r\nbreak;\r\ndefault:\r\nspin_lock_bh(&xpnet_broadcast_lock);\r\n__clear_bit(partid, xpnet_broadcast_partitions);\r\nspin_unlock_bh(&xpnet_broadcast_lock);\r\nif (bitmap_empty((unsigned long *)xpnet_broadcast_partitions,\r\nxp_max_npartitions)) {\r\nnetif_carrier_off(xpnet_device);\r\n}\r\ndev_dbg(xpnet, "%s disconnected from partition %d\n",\r\nxpnet_device->name, partid);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nxpnet_dev_open(struct net_device *dev)\r\n{\r\nenum xp_retval ret;\r\ndev_dbg(xpnet, "calling xpc_connect(%d, 0x%p, NULL, %ld, %ld, %ld, "\r\n"%ld)\n", XPC_NET_CHANNEL, xpnet_connection_activity,\r\n(unsigned long)XPNET_MSG_SIZE,\r\n(unsigned long)XPNET_MSG_NENTRIES,\r\n(unsigned long)XPNET_MAX_KTHREADS,\r\n(unsigned long)XPNET_MAX_IDLE_KTHREADS);\r\nret = xpc_connect(XPC_NET_CHANNEL, xpnet_connection_activity, NULL,\r\nXPNET_MSG_SIZE, XPNET_MSG_NENTRIES,\r\nXPNET_MAX_KTHREADS, XPNET_MAX_IDLE_KTHREADS);\r\nif (ret != xpSuccess) {\r\ndev_err(xpnet, "ifconfig up of %s failed on XPC connect, "\r\n"ret=%d\n", dev->name, ret);\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(xpnet, "ifconfig up of %s; XPC connected\n", dev->name);\r\nreturn 0;\r\n}\r\nstatic int\r\nxpnet_dev_stop(struct net_device *dev)\r\n{\r\nxpc_disconnect(XPC_NET_CHANNEL);\r\ndev_dbg(xpnet, "ifconfig down of %s; XPC disconnected\n", dev->name);\r\nreturn 0;\r\n}\r\nstatic int\r\nxpnet_dev_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif ((new_mtu < 68) || (new_mtu > XPNET_MAX_MTU)) {\r\ndev_err(xpnet, "ifconfig %s mtu %d failed; value must be "\r\n"between 68 and %ld\n", dev->name, new_mtu,\r\nXPNET_MAX_MTU);\r\nreturn -EINVAL;\r\n}\r\ndev->mtu = new_mtu;\r\ndev_dbg(xpnet, "ifconfig %s mtu set to %d\n", dev->name, new_mtu);\r\nreturn 0;\r\n}\r\nstatic void\r\nxpnet_send_completed(enum xp_retval reason, short partid, int channel,\r\nvoid *__qm)\r\n{\r\nstruct xpnet_pending_msg *queued_msg = (struct xpnet_pending_msg *)__qm;\r\nDBUG_ON(queued_msg == NULL);\r\ndev_dbg(xpnet, "message to %d notified with reason %d\n",\r\npartid, reason);\r\nif (atomic_dec_return(&queued_msg->use_count) == 0) {\r\ndev_dbg(xpnet, "all acks for skb->head=-x%p\n",\r\n(void *)queued_msg->skb->head);\r\ndev_kfree_skb_any(queued_msg->skb);\r\nkfree(queued_msg);\r\n}\r\n}\r\nstatic void\r\nxpnet_send(struct sk_buff *skb, struct xpnet_pending_msg *queued_msg,\r\nu64 start_addr, u64 end_addr, u16 embedded_bytes, int dest_partid)\r\n{\r\nu8 msg_buffer[XPNET_MSG_SIZE];\r\nstruct xpnet_message *msg = (struct xpnet_message *)&msg_buffer;\r\nu16 msg_size = sizeof(struct xpnet_message);\r\nenum xp_retval ret;\r\nmsg->embedded_bytes = embedded_bytes;\r\nif (unlikely(embedded_bytes != 0)) {\r\nmsg->version = XPNET_VERSION_EMBED;\r\ndev_dbg(xpnet, "calling memcpy(0x%p, 0x%p, 0x%lx)\n",\r\n&msg->data, skb->data, (size_t)embedded_bytes);\r\nskb_copy_from_linear_data(skb, &msg->data,\r\n(size_t)embedded_bytes);\r\nmsg_size += embedded_bytes - 1;\r\n} else {\r\nmsg->version = XPNET_VERSION;\r\n}\r\nmsg->magic = XPNET_MAGIC;\r\nmsg->size = end_addr - start_addr;\r\nmsg->leadin_ignore = (u64)skb->data - start_addr;\r\nmsg->tailout_ignore = end_addr - (u64)skb_tail_pointer(skb);\r\nmsg->buf_pa = xp_pa((void *)start_addr);\r\ndev_dbg(xpnet, "sending XPC message to %d:%d\n"\r\n"msg->buf_pa=0x%lx, msg->size=%u, "\r\n"msg->leadin_ignore=%u, msg->tailout_ignore=%u\n",\r\ndest_partid, XPC_NET_CHANNEL, msg->buf_pa, msg->size,\r\nmsg->leadin_ignore, msg->tailout_ignore);\r\natomic_inc(&queued_msg->use_count);\r\nret = xpc_send_notify(dest_partid, XPC_NET_CHANNEL, XPC_NOWAIT, msg,\r\nmsg_size, xpnet_send_completed, queued_msg);\r\nif (unlikely(ret != xpSuccess))\r\natomic_dec(&queued_msg->use_count);\r\n}\r\nstatic int\r\nxpnet_dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct xpnet_pending_msg *queued_msg;\r\nu64 start_addr, end_addr;\r\nshort dest_partid;\r\nu16 embedded_bytes = 0;\r\ndev_dbg(xpnet, ">skb->head=0x%p skb->data=0x%p skb->tail=0x%p "\r\n"skb->end=0x%p skb->len=%d\n", (void *)skb->head,\r\n(void *)skb->data, skb_tail_pointer(skb), skb_end_pointer(skb),\r\nskb->len);\r\nif (skb->data[0] == 0x33) {\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nqueued_msg = kmalloc(sizeof(struct xpnet_pending_msg), GFP_ATOMIC);\r\nif (queued_msg == NULL) {\r\ndev_warn(xpnet, "failed to kmalloc %ld bytes; dropping "\r\n"packet\n", sizeof(struct xpnet_pending_msg));\r\ndev->stats.tx_errors++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstart_addr = ((u64)skb->data & ~(L1_CACHE_BYTES - 1));\r\nend_addr = L1_CACHE_ALIGN((u64)skb_tail_pointer(skb));\r\nif (unlikely(skb->len <= XPNET_MSG_DATA_MAX)) {\r\nembedded_bytes = skb->len;\r\n}\r\natomic_set(&queued_msg->use_count, 1);\r\nqueued_msg->skb = skb;\r\nif (skb->data[0] == 0xff) {\r\nfor_each_set_bit(dest_partid, xpnet_broadcast_partitions,\r\nxp_max_npartitions) {\r\nxpnet_send(skb, queued_msg, start_addr, end_addr,\r\nembedded_bytes, dest_partid);\r\n}\r\n} else {\r\ndest_partid = (short)skb->data[XPNET_PARTID_OCTET + 1];\r\ndest_partid |= (short)skb->data[XPNET_PARTID_OCTET + 0] << 8;\r\nif (dest_partid >= 0 &&\r\ndest_partid < xp_max_npartitions &&\r\ntest_bit(dest_partid, xpnet_broadcast_partitions) != 0) {\r\nxpnet_send(skb, queued_msg, start_addr, end_addr,\r\nembedded_bytes, dest_partid);\r\n}\r\n}\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nif (atomic_dec_return(&queued_msg->use_count) == 0) {\r\ndev_kfree_skb(skb);\r\nkfree(queued_msg);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void\r\nxpnet_dev_tx_timeout(struct net_device *dev)\r\n{\r\ndev->stats.tx_errors++;\r\n}\r\nstatic int __init\r\nxpnet_init(void)\r\n{\r\nint result;\r\nif (!is_shub() && !is_uv())\r\nreturn -ENODEV;\r\ndev_info(xpnet, "registering network device %s\n", XPNET_DEVICE_NAME);\r\nxpnet_broadcast_partitions = kzalloc(BITS_TO_LONGS(xp_max_npartitions) *\r\nsizeof(long), GFP_KERNEL);\r\nif (xpnet_broadcast_partitions == NULL)\r\nreturn -ENOMEM;\r\nxpnet_device = alloc_netdev(0, XPNET_DEVICE_NAME, ether_setup);\r\nif (xpnet_device == NULL) {\r\nkfree(xpnet_broadcast_partitions);\r\nreturn -ENOMEM;\r\n}\r\nnetif_carrier_off(xpnet_device);\r\nxpnet_device->netdev_ops = &xpnet_netdev_ops;\r\nxpnet_device->mtu = XPNET_DEF_MTU;\r\nxpnet_device->dev_addr[0] = 0x02;\r\nxpnet_device->dev_addr[XPNET_PARTID_OCTET + 1] = xp_partition_id;\r\nxpnet_device->dev_addr[XPNET_PARTID_OCTET + 0] = (xp_partition_id >> 8);\r\nxpnet_device->flags &= ~IFF_MULTICAST;\r\nxpnet_device->features = NETIF_F_HW_CSUM;\r\nresult = register_netdev(xpnet_device);\r\nif (result != 0) {\r\nfree_netdev(xpnet_device);\r\nkfree(xpnet_broadcast_partitions);\r\n}\r\nreturn result;\r\n}\r\nstatic void __exit\r\nxpnet_exit(void)\r\n{\r\ndev_info(xpnet, "unregistering network device %s\n",\r\nxpnet_device[0].name);\r\nunregister_netdev(xpnet_device);\r\nfree_netdev(xpnet_device);\r\nkfree(xpnet_broadcast_partitions);\r\n}
