static int usecs_to_dev(unsigned long usecs, unsigned long const array[],\r\nint size)\r\n{\r\nint i;\r\nint rval = -EINVAL;\r\nfor (i = 0; i < size / 2; i++)\r\nif (array[(i * 2) + 1] >= usecs) {\r\nrval = array[i * 2];\r\nbreak;\r\n}\r\nreturn rval;\r\n}\r\nstatic irqreturn_t si4713_handler(int irq, void *dev)\r\n{\r\nstruct si4713_device *sdev = dev;\r\nv4l2_dbg(2, debug, &sdev->sd,\r\n"%s: sending signal to completion work.\n", __func__);\r\ncomplete(&sdev->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int si4713_send_command(struct si4713_device *sdev, const u8 command,\r\nconst u8 args[], const int argn,\r\nu8 response[], const int respn, const int usecs)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sdev->sd);\r\nunsigned long until_jiffies;\r\nu8 data1[MAX_ARGS + 1];\r\nint err;\r\nif (!client->adapter)\r\nreturn -ENODEV;\r\ndata1[0] = command;\r\nmemcpy(data1 + 1, args, argn);\r\nDBG_BUFFER(&sdev->sd, "Parameters", data1, argn + 1);\r\nerr = i2c_master_send(client, data1, argn + 1);\r\nif (err != argn + 1) {\r\nv4l2_err(&sdev->sd, "Error while sending command 0x%02x\n",\r\ncommand);\r\nreturn err < 0 ? err : -EIO;\r\n}\r\nuntil_jiffies = jiffies + usecs_to_jiffies(usecs) + 1;\r\nif (client->irq) {\r\nif (!wait_for_completion_timeout(&sdev->work,\r\nusecs_to_jiffies(usecs) + 1))\r\nv4l2_warn(&sdev->sd,\r\n"(%s) Device took too much time to answer.\n",\r\n__func__);\r\n}\r\ndo {\r\nerr = i2c_master_recv(client, response, respn);\r\nif (err != respn) {\r\nv4l2_err(&sdev->sd,\r\n"Error %d while reading response for command 0x%02x\n",\r\nerr, command);\r\nreturn err < 0 ? err : -EIO;\r\n}\r\nDBG_BUFFER(&sdev->sd, "Response", response, respn);\r\nif (!check_command_failed(response[0]))\r\nreturn 0;\r\nif (client->irq)\r\nreturn -EBUSY;\r\nif (usecs <= 1000)\r\nusleep_range(usecs, 1000);\r\nelse\r\nusleep_range(1000, 2000);\r\n} while (time_is_after_jiffies(until_jiffies));\r\nreturn -EBUSY;\r\n}\r\nstatic int si4713_read_property(struct si4713_device *sdev, u16 prop, u32 *pv)\r\n{\r\nint err;\r\nu8 val[SI4713_GET_PROP_NRESP];\r\nconst u8 args[SI4713_GET_PROP_NARGS] = {\r\n0x00,\r\nmsb(prop),\r\nlsb(prop),\r\n};\r\nerr = si4713_send_command(sdev, SI4713_CMD_GET_PROPERTY,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (err < 0)\r\nreturn err;\r\n*pv = compose_u16(val[2], val[3]);\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: property=0x%02x value=0x%02x status=0x%02x\n",\r\n__func__, prop, *pv, val[0]);\r\nreturn err;\r\n}\r\nstatic int si4713_write_property(struct si4713_device *sdev, u16 prop, u16 val)\r\n{\r\nint rval;\r\nu8 resp[SI4713_SET_PROP_NRESP];\r\nconst u8 args[SI4713_SET_PROP_NARGS] = {\r\n0x00,\r\nmsb(prop),\r\nlsb(prop),\r\nmsb(val),\r\nlsb(val),\r\n};\r\nrval = si4713_send_command(sdev, SI4713_CMD_SET_PROPERTY,\r\nargs, ARRAY_SIZE(args),\r\nresp, ARRAY_SIZE(resp),\r\nDEFAULT_TIMEOUT);\r\nif (rval < 0)\r\nreturn rval;\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: property=0x%02x value=0x%02x status=0x%02x\n",\r\n__func__, prop, val, resp[0]);\r\nmsleep(TIMEOUT_SET_PROPERTY);\r\nreturn rval;\r\n}\r\nstatic int si4713_powerup(struct si4713_device *sdev)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sdev->sd);\r\nint err;\r\nu8 resp[SI4713_PWUP_NRESP];\r\nu8 args[SI4713_PWUP_NARGS] = {\r\nSI4713_PWUP_GPO2OEN | SI4713_PWUP_FUNC_TX,\r\nSI4713_PWUP_OPMOD_ANALOG,\r\n};\r\nif (sdev->power_state)\r\nreturn 0;\r\nif (sdev->supplies) {\r\nerr = regulator_bulk_enable(sdev->supplies, sdev->supply_data);\r\nif (err) {\r\nv4l2_err(&sdev->sd, "Failed to enable supplies: %d\n", err);\r\nreturn err;\r\n}\r\n}\r\nif (gpio_is_valid(sdev->gpio_reset)) {\r\nudelay(50);\r\ngpio_set_value(sdev->gpio_reset, 1);\r\n}\r\nif (client->irq)\r\nargs[0] |= SI4713_PWUP_CTSIEN;\r\nerr = si4713_send_command(sdev, SI4713_CMD_POWER_UP,\r\nargs, ARRAY_SIZE(args),\r\nresp, ARRAY_SIZE(resp),\r\nTIMEOUT_POWER_UP);\r\nif (!err) {\r\nv4l2_dbg(1, debug, &sdev->sd, "Powerup response: 0x%02x\n",\r\nresp[0]);\r\nv4l2_dbg(1, debug, &sdev->sd, "Device in power up mode\n");\r\nsdev->power_state = POWER_ON;\r\nif (client->irq)\r\nerr = si4713_write_property(sdev, SI4713_GPO_IEN,\r\nSI4713_STC_INT | SI4713_CTS);\r\nreturn err;\r\n}\r\nif (gpio_is_valid(sdev->gpio_reset))\r\ngpio_set_value(sdev->gpio_reset, 0);\r\nif (sdev->supplies) {\r\nerr = regulator_bulk_disable(sdev->supplies, sdev->supply_data);\r\nif (err)\r\nv4l2_err(&sdev->sd,\r\n"Failed to disable supplies: %d\n", err);\r\n}\r\nreturn err;\r\n}\r\nstatic int si4713_powerdown(struct si4713_device *sdev)\r\n{\r\nint err;\r\nu8 resp[SI4713_PWDN_NRESP];\r\nif (!sdev->power_state)\r\nreturn 0;\r\nerr = si4713_send_command(sdev, SI4713_CMD_POWER_DOWN,\r\nNULL, 0,\r\nresp, ARRAY_SIZE(resp),\r\nDEFAULT_TIMEOUT);\r\nif (!err) {\r\nv4l2_dbg(1, debug, &sdev->sd, "Power down response: 0x%02x\n",\r\nresp[0]);\r\nv4l2_dbg(1, debug, &sdev->sd, "Device in reset mode\n");\r\nif (gpio_is_valid(sdev->gpio_reset))\r\ngpio_set_value(sdev->gpio_reset, 0);\r\nif (sdev->supplies) {\r\nerr = regulator_bulk_disable(sdev->supplies,\r\nsdev->supply_data);\r\nif (err)\r\nv4l2_err(&sdev->sd,\r\n"Failed to disable supplies: %d\n", err);\r\n}\r\nsdev->power_state = POWER_OFF;\r\n}\r\nreturn err;\r\n}\r\nstatic int si4713_checkrev(struct si4713_device *sdev)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sdev->sd);\r\nint rval;\r\nu8 resp[SI4713_GETREV_NRESP];\r\nrval = si4713_send_command(sdev, SI4713_CMD_GET_REV,\r\nNULL, 0,\r\nresp, ARRAY_SIZE(resp),\r\nDEFAULT_TIMEOUT);\r\nif (rval < 0)\r\nreturn rval;\r\nif (resp[1] == SI4713_PRODUCT_NUMBER) {\r\nv4l2_info(&sdev->sd, "chip found @ 0x%02x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\n} else {\r\nv4l2_err(&sdev->sd, "Invalid product number 0x%X\n", resp[1]);\r\nrval = -EINVAL;\r\n}\r\nreturn rval;\r\n}\r\nstatic int si4713_wait_stc(struct si4713_device *sdev, const int usecs)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sdev->sd);\r\nu8 resp[SI4713_GET_STATUS_NRESP];\r\nunsigned long start_jiffies = jiffies;\r\nint err;\r\nif (client->irq &&\r\n!wait_for_completion_timeout(&sdev->work, usecs_to_jiffies(usecs) + 1))\r\nv4l2_warn(&sdev->sd,\r\n"(%s) Device took too much time to answer.\n", __func__);\r\nfor (;;) {\r\nerr = si4713_send_command(sdev, SI4713_CMD_GET_INT_STATUS,\r\nNULL, 0,\r\nresp, ARRAY_SIZE(resp),\r\nDEFAULT_TIMEOUT);\r\nif (err >= 0) {\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: status bits: 0x%02x\n", __func__, resp[0]);\r\nif (resp[0] & SI4713_STC_INT)\r\nreturn 0;\r\n}\r\nif (jiffies_to_usecs(jiffies - start_jiffies) > usecs)\r\nreturn err < 0 ? err : -EIO;\r\nusleep_range(3000, 4000);\r\n}\r\n}\r\nstatic int si4713_tx_tune_freq(struct si4713_device *sdev, u16 frequency)\r\n{\r\nint err;\r\nu8 val[SI4713_TXFREQ_NRESP];\r\nconst u8 args[SI4713_TXFREQ_NARGS] = {\r\n0x00,\r\nmsb(frequency),\r\nlsb(frequency),\r\n};\r\nerr = si4713_send_command(sdev, SI4713_CMD_TX_TUNE_FREQ,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (err < 0)\r\nreturn err;\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: frequency=0x%02x status=0x%02x\n", __func__,\r\nfrequency, val[0]);\r\nerr = si4713_wait_stc(sdev, TIMEOUT_TX_TUNE);\r\nif (err < 0)\r\nreturn err;\r\nreturn compose_u16(args[1], args[2]);\r\n}\r\nstatic int si4713_tx_tune_power(struct si4713_device *sdev, u8 power,\r\nu8 antcap)\r\n{\r\nint err;\r\nu8 val[SI4713_TXPWR_NRESP];\r\nu8 args[SI4713_TXPWR_NARGS] = {\r\n0x00,\r\n0x00,\r\npower,\r\nantcap,\r\n};\r\nif (power > 0 && power < SI4713_MIN_POWER)\r\nargs[2] = power = SI4713_MIN_POWER;\r\nerr = si4713_send_command(sdev, SI4713_CMD_TX_TUNE_POWER,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (err < 0)\r\nreturn err;\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: power=0x%02x antcap=0x%02x status=0x%02x\n",\r\n__func__, power, antcap, val[0]);\r\nreturn si4713_wait_stc(sdev, TIMEOUT_TX_TUNE_POWER);\r\n}\r\nstatic int si4713_tx_tune_measure(struct si4713_device *sdev, u16 frequency,\r\nu8 antcap)\r\n{\r\nint err;\r\nu8 val[SI4713_TXMEA_NRESP];\r\nconst u8 args[SI4713_TXMEA_NARGS] = {\r\n0x00,\r\nmsb(frequency),\r\nlsb(frequency),\r\nantcap,\r\n};\r\nsdev->tune_rnl = DEFAULT_TUNE_RNL;\r\nif (antcap > SI4713_MAX_ANTCAP)\r\nreturn -EDOM;\r\nerr = si4713_send_command(sdev, SI4713_CMD_TX_TUNE_MEASURE,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (err < 0)\r\nreturn err;\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: frequency=0x%02x antcap=0x%02x status=0x%02x\n",\r\n__func__, frequency, antcap, val[0]);\r\nreturn si4713_wait_stc(sdev, TIMEOUT_TX_TUNE);\r\n}\r\nstatic int si4713_tx_tune_status(struct si4713_device *sdev, u8 intack,\r\nu16 *frequency, u8 *power,\r\nu8 *antcap, u8 *noise)\r\n{\r\nint err;\r\nu8 val[SI4713_TXSTATUS_NRESP];\r\nconst u8 args[SI4713_TXSTATUS_NARGS] = {\r\nintack & SI4713_INTACK_MASK,\r\n};\r\nerr = si4713_send_command(sdev, SI4713_CMD_TX_TUNE_STATUS,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (!err) {\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: status=0x%02x\n", __func__, val[0]);\r\n*frequency = compose_u16(val[2], val[3]);\r\nsdev->frequency = *frequency;\r\n*power = val[5];\r\n*antcap = val[6];\r\n*noise = val[7];\r\nv4l2_dbg(1, debug, &sdev->sd, "%s: response: %d x 10 kHz "\r\n"(power %d, antcap %d, rnl %d)\n", __func__,\r\n*frequency, *power, *antcap, *noise);\r\n}\r\nreturn err;\r\n}\r\nstatic int si4713_tx_rds_buff(struct si4713_device *sdev, u8 mode, u16 rdsb,\r\nu16 rdsc, u16 rdsd, s8 *cbleft)\r\n{\r\nint err;\r\nu8 val[SI4713_RDSBUFF_NRESP];\r\nconst u8 args[SI4713_RDSBUFF_NARGS] = {\r\nmode & SI4713_RDSBUFF_MODE_MASK,\r\nmsb(rdsb),\r\nlsb(rdsb),\r\nmsb(rdsc),\r\nlsb(rdsc),\r\nmsb(rdsd),\r\nlsb(rdsd),\r\n};\r\nerr = si4713_send_command(sdev, SI4713_CMD_TX_RDS_BUFF,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (!err) {\r\nv4l2_dbg(1, debug, &sdev->sd,\r\n"%s: status=0x%02x\n", __func__, val[0]);\r\n*cbleft = (s8)val[2] - val[3];\r\nv4l2_dbg(1, debug, &sdev->sd, "%s: response: interrupts"\r\n" 0x%02x cb avail: %d cb used %d fifo avail"\r\n" %d fifo used %d\n", __func__, val[1],\r\nval[2], val[3], val[4], val[5]);\r\n}\r\nreturn err;\r\n}\r\nstatic int si4713_tx_rds_ps(struct si4713_device *sdev, u8 psid,\r\nunsigned char *pschar)\r\n{\r\nint err;\r\nu8 val[SI4713_RDSPS_NRESP];\r\nconst u8 args[SI4713_RDSPS_NARGS] = {\r\npsid & SI4713_RDSPS_PSID_MASK,\r\npschar[0],\r\npschar[1],\r\npschar[2],\r\npschar[3],\r\n};\r\nerr = si4713_send_command(sdev, SI4713_CMD_TX_RDS_PS,\r\nargs, ARRAY_SIZE(args), val,\r\nARRAY_SIZE(val), DEFAULT_TIMEOUT);\r\nif (err < 0)\r\nreturn err;\r\nv4l2_dbg(1, debug, &sdev->sd, "%s: status=0x%02x\n", __func__, val[0]);\r\nreturn err;\r\n}\r\nstatic int si4713_set_power_state(struct si4713_device *sdev, u8 value)\r\n{\r\nif (value)\r\nreturn si4713_powerup(sdev);\r\nreturn si4713_powerdown(sdev);\r\n}\r\nstatic int si4713_set_mute(struct si4713_device *sdev, u16 mute)\r\n{\r\nint rval = 0;\r\nmute = set_mute(mute);\r\nif (sdev->power_state)\r\nrval = si4713_write_property(sdev,\r\nSI4713_TX_LINE_INPUT_MUTE, mute);\r\nreturn rval;\r\n}\r\nstatic int si4713_set_rds_ps_name(struct si4713_device *sdev, char *ps_name)\r\n{\r\nint rval = 0, i;\r\nu8 len = 0;\r\nif (!strlen(ps_name))\r\nmemset(ps_name, 0, MAX_RDS_PS_NAME + 1);\r\nif (sdev->power_state) {\r\nfor (i = 0; i < MAX_RDS_PS_NAME; i += (RDS_BLOCK / 2)) {\r\nrval = si4713_tx_rds_ps(sdev, (i / (RDS_BLOCK / 2)),\r\nps_name + i);\r\nif (rval < 0)\r\nreturn rval;\r\n}\r\nif (strlen(ps_name))\r\nlen = strlen(ps_name) - 1;\r\nelse\r\nlen = 1;\r\nrval = si4713_write_property(sdev,\r\nSI4713_TX_RDS_PS_MESSAGE_COUNT,\r\nrds_ps_nblocks(len));\r\nif (rval < 0)\r\nreturn rval;\r\nrval = si4713_write_property(sdev,\r\nSI4713_TX_RDS_PS_REPEAT_COUNT,\r\nDEFAULT_RDS_PS_REPEAT_COUNT * 2);\r\nif (rval < 0)\r\nreturn rval;\r\n}\r\nreturn rval;\r\n}\r\nstatic int si4713_set_rds_radio_text(struct si4713_device *sdev, const char *rt)\r\n{\r\nstatic const char cr[RDS_RADIOTEXT_BLK_SIZE] = { RDS_CARRIAGE_RETURN, 0 };\r\nint rval = 0, i;\r\nu16 t_index = 0;\r\nu8 b_index = 0, cr_inserted = 0;\r\ns8 left;\r\nif (!sdev->power_state)\r\nreturn rval;\r\nrval = si4713_tx_rds_buff(sdev, RDS_BLOCK_CLEAR, 0, 0, 0, &left);\r\nif (rval < 0)\r\nreturn rval;\r\nif (!strlen(rt))\r\nreturn rval;\r\ndo {\r\nif (t_index < (RDS_RADIOTEXT_INDEX_MAX * RDS_RADIOTEXT_BLK_SIZE)) {\r\nfor (i = 0; i < RDS_RADIOTEXT_BLK_SIZE; i++) {\r\nif (!rt[t_index + i] ||\r\nrt[t_index + i] == RDS_CARRIAGE_RETURN) {\r\nrt = cr;\r\ncr_inserted = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nrval = si4713_tx_rds_buff(sdev, RDS_BLOCK_LOAD,\r\ncompose_u16(RDS_RADIOTEXT_2A, b_index++),\r\ncompose_u16(rt[t_index], rt[t_index + 1]),\r\ncompose_u16(rt[t_index + 2], rt[t_index + 3]),\r\n&left);\r\nif (rval < 0)\r\nreturn rval;\r\nt_index += RDS_RADIOTEXT_BLK_SIZE;\r\nif (cr_inserted)\r\nbreak;\r\n} while (left > 0);\r\nreturn rval;\r\n}\r\nstatic int si4713_update_tune_status(struct si4713_device *sdev)\r\n{\r\nint rval;\r\nu16 f = 0;\r\nu8 p = 0, a = 0, n = 0;\r\nrval = si4713_tx_tune_status(sdev, 0x00, &f, &p, &a, &n);\r\nif (rval < 0)\r\ngoto exit;\r\nsdev->tune_rnl = n;\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int si4713_choose_econtrol_action(struct si4713_device *sdev, u32 id,\r\ns32 *bit, s32 *mask, u16 *property, int *mul,\r\nunsigned long **table, int *size)\r\n{\r\ns32 rval = 0;\r\nswitch (id) {\r\ncase V4L2_CID_RDS_TX_PI:\r\n*property = SI4713_TX_RDS_PI;\r\n*mul = 1;\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_THRESHOLD:\r\n*property = SI4713_TX_ACOMP_THRESHOLD;\r\n*mul = 1;\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_GAIN:\r\n*property = SI4713_TX_ACOMP_GAIN;\r\n*mul = 1;\r\nbreak;\r\ncase V4L2_CID_PILOT_TONE_FREQUENCY:\r\n*property = SI4713_TX_PILOT_FREQUENCY;\r\n*mul = 1;\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME:\r\n*property = SI4713_TX_ACOMP_ATTACK_TIME;\r\n*mul = ATTACK_TIME_UNIT;\r\nbreak;\r\ncase V4L2_CID_PILOT_TONE_DEVIATION:\r\n*property = SI4713_TX_PILOT_DEVIATION;\r\n*mul = 10;\r\nbreak;\r\ncase V4L2_CID_AUDIO_LIMITER_DEVIATION:\r\n*property = SI4713_TX_AUDIO_DEVIATION;\r\n*mul = 10;\r\nbreak;\r\ncase V4L2_CID_RDS_TX_DEVIATION:\r\n*property = SI4713_TX_RDS_DEVIATION;\r\n*mul = 1;\r\nbreak;\r\ncase V4L2_CID_RDS_TX_PTY:\r\n*property = SI4713_TX_RDS_PS_MISC;\r\n*bit = 5;\r\n*mask = 0x1F << 5;\r\nbreak;\r\ncase V4L2_CID_AUDIO_LIMITER_ENABLED:\r\n*property = SI4713_TX_ACOMP_ENABLE;\r\n*bit = 1;\r\n*mask = 1 << 1;\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_ENABLED:\r\n*property = SI4713_TX_ACOMP_ENABLE;\r\n*bit = 0;\r\n*mask = 1 << 0;\r\nbreak;\r\ncase V4L2_CID_PILOT_TONE_ENABLED:\r\n*property = SI4713_TX_COMPONENT_ENABLE;\r\n*bit = 0;\r\n*mask = 1 << 0;\r\nbreak;\r\ncase V4L2_CID_AUDIO_LIMITER_RELEASE_TIME:\r\n*property = SI4713_TX_LIMITER_RELEASE_TIME;\r\n*table = limiter_times;\r\n*size = ARRAY_SIZE(limiter_times);\r\nbreak;\r\ncase V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME:\r\n*property = SI4713_TX_ACOMP_RELEASE_TIME;\r\n*table = acomp_rtimes;\r\n*size = ARRAY_SIZE(acomp_rtimes);\r\nbreak;\r\ncase V4L2_CID_TUNE_PREEMPHASIS:\r\n*property = SI4713_TX_PREEMPHASIS;\r\n*table = preemphasis_values;\r\n*size = ARRAY_SIZE(preemphasis_values);\r\nbreak;\r\ndefault:\r\nrval = -EINVAL;\r\nbreak;\r\n}\r\nreturn rval;\r\n}\r\nstatic int si4713_setup(struct si4713_device *sdev)\r\n{\r\nstruct v4l2_frequency f;\r\nstruct v4l2_modulator vm;\r\nint rval;\r\nf.tuner = 0;\r\nf.frequency = sdev->frequency ? sdev->frequency : DEFAULT_FREQUENCY;\r\nf.frequency = si4713_to_v4l2(f.frequency);\r\nrval = si4713_s_frequency(&sdev->sd, &f);\r\nvm.index = 0;\r\nif (sdev->stereo)\r\nvm.txsubchans = V4L2_TUNER_SUB_STEREO;\r\nelse\r\nvm.txsubchans = V4L2_TUNER_SUB_MONO;\r\nif (sdev->rds_enabled)\r\nvm.txsubchans |= V4L2_TUNER_SUB_RDS;\r\nsi4713_s_modulator(&sdev->sd, &vm);\r\nreturn rval;\r\n}\r\nstatic int si4713_initialize(struct si4713_device *sdev)\r\n{\r\nint rval;\r\nrval = si4713_set_power_state(sdev, POWER_ON);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = si4713_checkrev(sdev);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = si4713_set_power_state(sdev, POWER_OFF);\r\nif (rval < 0)\r\nreturn rval;\r\nsdev->frequency = DEFAULT_FREQUENCY;\r\nsdev->stereo = 1;\r\nsdev->tune_rnl = DEFAULT_TUNE_RNL;\r\nreturn 0;\r\n}\r\nstatic int si4713_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct si4713_device *sdev =\r\ncontainer_of(ctrl->handler, struct si4713_device, ctrl_handler);\r\nu32 val = 0;\r\ns32 bit = 0, mask = 0;\r\nu16 property = 0;\r\nint mul = 0;\r\nunsigned long *table = NULL;\r\nint size = 0;\r\nbool force = false;\r\nint c;\r\nint ret = 0;\r\nif (ctrl->id != V4L2_CID_AUDIO_MUTE)\r\nreturn -EINVAL;\r\nif (ctrl->is_new) {\r\nif (ctrl->val) {\r\nret = si4713_set_mute(sdev, ctrl->val);\r\nif (!ret)\r\nret = si4713_set_power_state(sdev, POWER_DOWN);\r\nreturn ret;\r\n}\r\nret = si4713_set_power_state(sdev, POWER_UP);\r\nif (!ret)\r\nret = si4713_set_mute(sdev, ctrl->val);\r\nif (!ret)\r\nret = si4713_setup(sdev);\r\nif (ret)\r\nreturn ret;\r\nforce = true;\r\n}\r\nif (!sdev->power_state)\r\nreturn 0;\r\nfor (c = 1; !ret && c < ctrl->ncontrols; c++) {\r\nctrl = ctrl->cluster[c];\r\nif (!force && !ctrl->is_new)\r\ncontinue;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RDS_TX_PS_NAME:\r\nret = si4713_set_rds_ps_name(sdev, ctrl->string);\r\nbreak;\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT:\r\nret = si4713_set_rds_radio_text(sdev, ctrl->string);\r\nbreak;\r\ncase V4L2_CID_TUNE_ANTENNA_CAPACITOR:\r\nif (force)\r\nbreak;\r\ncase V4L2_CID_TUNE_POWER_LEVEL:\r\nret = si4713_tx_tune_power(sdev,\r\nsdev->tune_pwr_level->val, sdev->tune_ant_cap->val);\r\nif (!ret) {\r\nsdev->tune_ant_cap->is_new = false;\r\nsdev->tune_pwr_level->is_new = false;\r\n}\r\nbreak;\r\ndefault:\r\nret = si4713_choose_econtrol_action(sdev, ctrl->id, &bit,\r\n&mask, &property, &mul, &table, &size);\r\nif (ret < 0)\r\nbreak;\r\nval = ctrl->val;\r\nif (mul) {\r\nval = val / mul;\r\n} else if (table) {\r\nret = usecs_to_dev(val, table, size);\r\nif (ret < 0)\r\nbreak;\r\nval = ret;\r\nret = 0;\r\n}\r\nif (mask) {\r\nret = si4713_read_property(sdev, property, &val);\r\nif (ret < 0)\r\nbreak;\r\nval = set_bits(val, ctrl->val, bit, mask);\r\n}\r\nret = si4713_write_property(sdev, property, val);\r\nif (ret < 0)\r\nbreak;\r\nif (mask)\r\nval = ctrl->val;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic long si4713_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nstruct si4713_rnl *rnl = arg;\r\nu16 frequency;\r\nint rval = 0;\r\nif (!arg)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SI4713_IOC_MEASURE_RNL:\r\nfrequency = v4l2_to_si4713(rnl->frequency);\r\nif (sdev->power_state) {\r\nrval = si4713_tx_tune_measure(sdev, frequency, 0);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = si4713_update_tune_status(sdev);\r\nif (rval < 0)\r\nreturn rval;\r\n}\r\nrnl->rnl = sdev->tune_rnl;\r\nbreak;\r\ndefault:\r\nrval = -ENOIOCTLCMD;\r\n}\r\nreturn rval;\r\n}\r\nstatic int si4713_g_modulator(struct v4l2_subdev *sd, struct v4l2_modulator *vm)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nint rval = 0;\r\nif (!sdev)\r\nreturn -ENODEV;\r\nif (vm->index > 0)\r\nreturn -EINVAL;\r\nstrncpy(vm->name, "FM Modulator", 32);\r\nvm->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LOW |\r\nV4L2_TUNER_CAP_RDS | V4L2_TUNER_CAP_RDS_CONTROLS;\r\nvm->rangelow = si4713_to_v4l2(FREQ_RANGE_LOW);\r\nvm->rangehigh = si4713_to_v4l2(FREQ_RANGE_HIGH);\r\nif (sdev->power_state) {\r\nu32 comp_en = 0;\r\nrval = si4713_read_property(sdev, SI4713_TX_COMPONENT_ENABLE,\r\n&comp_en);\r\nif (rval < 0)\r\nreturn rval;\r\nsdev->stereo = get_status_bit(comp_en, 1, 1 << 1);\r\n}\r\nif (sdev->stereo)\r\nvm->txsubchans = V4L2_TUNER_SUB_STEREO;\r\nelse\r\nvm->txsubchans = V4L2_TUNER_SUB_MONO;\r\nif (sdev->rds_enabled)\r\nvm->txsubchans |= V4L2_TUNER_SUB_RDS;\r\nelse\r\nvm->txsubchans &= ~V4L2_TUNER_SUB_RDS;\r\nreturn rval;\r\n}\r\nstatic int si4713_s_modulator(struct v4l2_subdev *sd, const struct v4l2_modulator *vm)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nint rval = 0;\r\nu16 stereo, rds;\r\nu32 p;\r\nif (!sdev)\r\nreturn -ENODEV;\r\nif (vm->index > 0)\r\nreturn -EINVAL;\r\nif (vm->txsubchans & V4L2_TUNER_SUB_STEREO)\r\nstereo = 1;\r\nelse if (vm->txsubchans & V4L2_TUNER_SUB_MONO)\r\nstereo = 0;\r\nelse\r\nreturn -EINVAL;\r\nrds = !!(vm->txsubchans & V4L2_TUNER_SUB_RDS);\r\nif (sdev->power_state) {\r\nrval = si4713_read_property(sdev,\r\nSI4713_TX_COMPONENT_ENABLE, &p);\r\nif (rval < 0)\r\nreturn rval;\r\np = set_bits(p, stereo, 1, 1 << 1);\r\np = set_bits(p, rds, 2, 1 << 2);\r\nrval = si4713_write_property(sdev,\r\nSI4713_TX_COMPONENT_ENABLE, p);\r\nif (rval < 0)\r\nreturn rval;\r\n}\r\nsdev->stereo = stereo;\r\nsdev->rds_enabled = rds;\r\nreturn rval;\r\n}\r\nstatic int si4713_g_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nint rval = 0;\r\nif (f->tuner)\r\nreturn -EINVAL;\r\nif (sdev->power_state) {\r\nu16 freq;\r\nu8 p, a, n;\r\nrval = si4713_tx_tune_status(sdev, 0x00, &freq, &p, &a, &n);\r\nif (rval < 0)\r\nreturn rval;\r\nsdev->frequency = freq;\r\n}\r\nf->frequency = si4713_to_v4l2(sdev->frequency);\r\nreturn rval;\r\n}\r\nstatic int si4713_s_frequency(struct v4l2_subdev *sd, const struct v4l2_frequency *f)\r\n{\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nint rval = 0;\r\nu16 frequency = v4l2_to_si4713(f->frequency);\r\nif (f->tuner)\r\nreturn -EINVAL;\r\nfrequency = clamp_t(u16, frequency, FREQ_RANGE_LOW, FREQ_RANGE_HIGH);\r\nif (sdev->power_state) {\r\nrval = si4713_tx_tune_freq(sdev, frequency);\r\nif (rval < 0)\r\nreturn rval;\r\nfrequency = rval;\r\nrval = 0;\r\n}\r\nsdev->frequency = frequency;\r\nreturn rval;\r\n}\r\nstatic int si4713_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct si4713_device *sdev;\r\nstruct si4713_platform_data *pdata = client->dev.platform_data;\r\nstruct v4l2_ctrl_handler *hdl;\r\nint rval, i;\r\nsdev = kzalloc(sizeof(*sdev), GFP_KERNEL);\r\nif (!sdev) {\r\ndev_err(&client->dev, "Failed to alloc video device.\n");\r\nrval = -ENOMEM;\r\ngoto exit;\r\n}\r\nsdev->gpio_reset = -1;\r\nif (pdata && gpio_is_valid(pdata->gpio_reset)) {\r\nrval = gpio_request(pdata->gpio_reset, "si4713 reset");\r\nif (rval) {\r\ndev_err(&client->dev,\r\n"Failed to request gpio: %d\n", rval);\r\ngoto free_sdev;\r\n}\r\nsdev->gpio_reset = pdata->gpio_reset;\r\ngpio_direction_output(sdev->gpio_reset, 0);\r\nsdev->supplies = pdata->supplies;\r\n}\r\nfor (i = 0; i < sdev->supplies; i++)\r\nsdev->supply_data[i].supply = pdata->supply_names[i];\r\nrval = regulator_bulk_get(&client->dev, sdev->supplies,\r\nsdev->supply_data);\r\nif (rval) {\r\ndev_err(&client->dev, "Cannot get regulators: %d\n", rval);\r\ngoto free_gpio;\r\n}\r\nv4l2_i2c_subdev_init(&sdev->sd, client, &si4713_subdev_ops);\r\ninit_completion(&sdev->work);\r\nhdl = &sdev->ctrl_handler;\r\nv4l2_ctrl_handler_init(hdl, 20);\r\nsdev->mute = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, DEFAULT_MUTE);\r\nsdev->rds_pi = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_RDS_TX_PI, 0, 0xffff, 1, DEFAULT_RDS_PI);\r\nsdev->rds_pty = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_RDS_TX_PTY, 0, 31, 1, DEFAULT_RDS_PTY);\r\nsdev->rds_deviation = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_RDS_TX_DEVIATION, 0, MAX_RDS_DEVIATION,\r\n10, DEFAULT_RDS_DEVIATION);\r\nsdev->rds_ps_name = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_RDS_TX_PS_NAME, 0, MAX_RDS_PS_NAME, 8, 0);\r\nsdev->rds_radio_text = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_RDS_TX_RADIO_TEXT, 0, MAX_RDS_RADIO_TEXT, 32, 0);\r\nsdev->limiter_enabled = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_AUDIO_LIMITER_ENABLED, 0, 1, 1, 1);\r\nsdev->limiter_release_time = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_AUDIO_LIMITER_RELEASE_TIME, 250,\r\nMAX_LIMITER_RELEASE_TIME, 10, DEFAULT_LIMITER_RTIME);\r\nsdev->limiter_deviation = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_AUDIO_LIMITER_DEVIATION, 0,\r\nMAX_LIMITER_DEVIATION, 10, DEFAULT_LIMITER_DEV);\r\nsdev->compression_enabled = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_AUDIO_COMPRESSION_ENABLED, 0, 1, 1, 1);\r\nsdev->compression_gain = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_AUDIO_COMPRESSION_GAIN, 0, MAX_ACOMP_GAIN, 1,\r\nDEFAULT_ACOMP_GAIN);\r\nsdev->compression_threshold = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_AUDIO_COMPRESSION_THRESHOLD,\r\nMIN_ACOMP_THRESHOLD, MAX_ACOMP_THRESHOLD, 1,\r\nDEFAULT_ACOMP_THRESHOLD);\r\nsdev->compression_attack_time = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME, 0,\r\nMAX_ACOMP_ATTACK_TIME, 500, DEFAULT_ACOMP_ATIME);\r\nsdev->compression_release_time = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME, 100000,\r\nMAX_ACOMP_RELEASE_TIME, 100000, DEFAULT_ACOMP_RTIME);\r\nsdev->pilot_tone_enabled = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_PILOT_TONE_ENABLED, 0, 1, 1, 1);\r\nsdev->pilot_tone_deviation = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_PILOT_TONE_DEVIATION, 0, MAX_PILOT_DEVIATION,\r\n10, DEFAULT_PILOT_DEVIATION);\r\nsdev->pilot_tone_freq = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_PILOT_TONE_FREQUENCY, 0, MAX_PILOT_FREQUENCY,\r\n1, DEFAULT_PILOT_FREQUENCY);\r\nsdev->tune_preemphasis = v4l2_ctrl_new_std_menu(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_TUNE_PREEMPHASIS,\r\nV4L2_PREEMPHASIS_75_uS, 0, V4L2_PREEMPHASIS_50_uS);\r\nsdev->tune_pwr_level = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_TUNE_POWER_LEVEL, 0, SI4713_MAX_POWER,\r\n1, DEFAULT_POWER_LEVEL);\r\nsdev->tune_ant_cap = v4l2_ctrl_new_std(hdl, &si4713_ctrl_ops,\r\nV4L2_CID_TUNE_ANTENNA_CAPACITOR, 0, SI4713_MAX_ANTCAP,\r\n1, 0);\r\nif (hdl->error) {\r\nrval = hdl->error;\r\ngoto free_ctrls;\r\n}\r\nv4l2_ctrl_cluster(20, &sdev->mute);\r\nsdev->sd.ctrl_handler = hdl;\r\nif (client->irq) {\r\nrval = request_irq(client->irq,\r\nsi4713_handler, IRQF_TRIGGER_FALLING,\r\nclient->name, sdev);\r\nif (rval < 0) {\r\nv4l2_err(&sdev->sd, "Could not request IRQ\n");\r\ngoto put_reg;\r\n}\r\nv4l2_dbg(1, debug, &sdev->sd, "IRQ requested.\n");\r\n} else {\r\nv4l2_warn(&sdev->sd, "IRQ not configured. Using timeouts.\n");\r\n}\r\nrval = si4713_initialize(sdev);\r\nif (rval < 0) {\r\nv4l2_err(&sdev->sd, "Failed to probe device information.\n");\r\ngoto free_irq;\r\n}\r\nreturn 0;\r\nfree_irq:\r\nif (client->irq)\r\nfree_irq(client->irq, sdev);\r\nfree_ctrls:\r\nv4l2_ctrl_handler_free(hdl);\r\nput_reg:\r\nregulator_bulk_free(sdev->supplies, sdev->supply_data);\r\nfree_gpio:\r\nif (gpio_is_valid(sdev->gpio_reset))\r\ngpio_free(sdev->gpio_reset);\r\nfree_sdev:\r\nkfree(sdev);\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int si4713_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct si4713_device *sdev = to_si4713_device(sd);\r\nif (sdev->power_state)\r\nsi4713_set_power_state(sdev, POWER_DOWN);\r\nif (client->irq > 0)\r\nfree_irq(client->irq, sdev);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nregulator_bulk_free(sdev->supplies, sdev->supply_data);\r\nif (gpio_is_valid(sdev->gpio_reset))\r\ngpio_free(sdev->gpio_reset);\r\nkfree(sdev);\r\nreturn 0;\r\n}
