static int ls_object_init(const struct lu_env *env, struct lu_object *o,\r\nconst struct lu_object_conf *unused)\r\n{\r\nstruct ls_device *ls;\r\nstruct lu_object *below;\r\nstruct lu_device *under;\r\nls = container_of0(o->lo_dev, struct ls_device, ls_top_dev.dd_lu_dev);\r\nunder = &ls->ls_osd->dd_lu_dev;\r\nbelow = under->ld_ops->ldo_object_alloc(env, o->lo_header, under);\r\nif (below == NULL)\r\nreturn -ENOMEM;\r\nlu_object_add(o, below);\r\nreturn 0;\r\n}\r\nstatic void ls_object_free(const struct lu_env *env, struct lu_object *o)\r\n{\r\nstruct ls_object *obj = lu2ls_obj(o);\r\nstruct lu_object_header *h = o->lo_header;\r\ndt_object_fini(&obj->ls_obj);\r\nlu_object_header_fini(h);\r\nOBD_FREE_PTR(obj);\r\n}\r\nstruct lu_object *ls_object_alloc(const struct lu_env *env,\r\nconst struct lu_object_header *_h,\r\nstruct lu_device *d)\r\n{\r\nstruct lu_object_header *h;\r\nstruct ls_object *o;\r\nstruct lu_object *l;\r\nLASSERT(_h == NULL);\r\nOBD_ALLOC_PTR(o);\r\nif (o != NULL) {\r\nl = &o->ls_obj.do_lu;\r\nh = &o->ls_header;\r\nlu_object_header_init(h);\r\ndt_object_init(&o->ls_obj, h, d);\r\nlu_object_add_top(h, l);\r\nl->lo_ops = &ls_lu_obj_ops;\r\nreturn l;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nstatic struct ls_device *__ls_find_dev(struct dt_device *dev)\r\n{\r\nstruct ls_device *ls, *ret = NULL;\r\nlist_for_each_entry(ls, &ls_list_head, ls_linkage) {\r\nif (ls->ls_osd == dev) {\r\natomic_inc(&ls->ls_refcount);\r\nret = ls;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstruct ls_device *ls_find_dev(struct dt_device *dev)\r\n{\r\nstruct ls_device *ls;\r\nmutex_lock(&ls_list_mutex);\r\nls = __ls_find_dev(dev);\r\nmutex_unlock(&ls_list_mutex);\r\nreturn ls;\r\n}\r\nstruct ls_device *ls_device_get(struct dt_device *dev)\r\n{\r\nstruct ls_device *ls;\r\nmutex_lock(&ls_list_mutex);\r\nls = __ls_find_dev(dev);\r\nif (ls)\r\nGOTO(out_ls, ls);\r\nOBD_ALLOC_PTR(ls);\r\nif (ls == NULL)\r\nGOTO(out_ls, ls = ERR_PTR(-ENOMEM));\r\natomic_set(&ls->ls_refcount, 1);\r\nINIT_LIST_HEAD(&ls->ls_los_list);\r\nmutex_init(&ls->ls_los_mutex);\r\nls->ls_osd = dev;\r\nLASSERT(dev->dd_lu_dev.ld_site);\r\nlu_device_init(&ls->ls_top_dev.dd_lu_dev, &ls_lu_type);\r\nls->ls_top_dev.dd_lu_dev.ld_ops = &ls_lu_dev_ops;\r\nls->ls_top_dev.dd_lu_dev.ld_site = dev->dd_lu_dev.ld_site;\r\nlist_add(&ls->ls_linkage, &ls_list_head);\r\nout_ls:\r\nmutex_unlock(&ls_list_mutex);\r\nreturn ls;\r\n}\r\nvoid ls_device_put(const struct lu_env *env, struct ls_device *ls)\r\n{\r\nLASSERT(env);\r\nif (!atomic_dec_and_test(&ls->ls_refcount))\r\nreturn;\r\nmutex_lock(&ls_list_mutex);\r\nif (atomic_read(&ls->ls_refcount) == 0) {\r\nLASSERT(list_empty(&ls->ls_los_list));\r\nlist_del(&ls->ls_linkage);\r\nlu_site_purge(env, ls->ls_top_dev.dd_lu_dev.ld_site, ~0);\r\nlu_device_fini(&ls->ls_top_dev.dd_lu_dev);\r\nOBD_FREE_PTR(ls);\r\n}\r\nmutex_unlock(&ls_list_mutex);\r\n}\r\nint local_object_fid_generate(const struct lu_env *env,\r\nstruct local_oid_storage *los,\r\nstruct lu_fid *fid)\r\n{\r\nLASSERT(los->los_dev);\r\nLASSERT(los->los_obj);\r\nmutex_lock(&los->los_id_lock);\r\nfid->f_seq = los->los_seq;\r\nfid->f_oid = ++los->los_last_oid;\r\nfid->f_ver = 0;\r\nmutex_unlock(&los->los_id_lock);\r\nreturn 0;\r\n}\r\nint local_object_declare_create(const struct lu_env *env,\r\nstruct local_oid_storage *los,\r\nstruct dt_object *o, struct lu_attr *attr,\r\nstruct dt_object_format *dof,\r\nstruct thandle *th)\r\n{\r\nstruct dt_thread_info *dti = dt_info(env);\r\nint rc;\r\nif (los != NULL) {\r\nLASSERT(dt_object_exists(los->los_obj));\r\nrc = dt_declare_record_write(env, los->los_obj,\r\nsizeof(struct los_ondisk), 0, th);\r\nif (rc)\r\nreturn rc;\r\n}\r\nrc = dt_declare_create(env, o, attr, NULL, dof, th);\r\nif (rc)\r\nreturn rc;\r\ndti->dti_lb.lb_buf = NULL;\r\ndti->dti_lb.lb_len = sizeof(dti->dti_lma);\r\nrc = dt_declare_xattr_set(env, o, &dti->dti_lb, XATTR_NAME_LMA, 0, th);\r\nreturn rc;\r\n}\r\nint local_object_create(const struct lu_env *env,\r\nstruct local_oid_storage *los,\r\nstruct dt_object *o, struct lu_attr *attr,\r\nstruct dt_object_format *dof, struct thandle *th)\r\n{\r\nstruct dt_thread_info *dti = dt_info(env);\r\n__le64 lastid;\r\nint rc;\r\nrc = dt_create(env, o, attr, NULL, dof, th);\r\nif (rc)\r\nreturn rc;\r\nif (los == NULL)\r\nreturn rc;\r\nLASSERT(los->los_obj);\r\nLASSERT(dt_object_exists(los->los_obj));\r\nmutex_lock(&los->los_id_lock);\r\nlastid = cpu_to_le64(los->los_last_oid);\r\ndti->dti_off = 0;\r\ndti->dti_lb.lb_buf = &lastid;\r\ndti->dti_lb.lb_len = sizeof(lastid);\r\nrc = dt_record_write(env, los->los_obj, &dti->dti_lb, &dti->dti_off,\r\nth);\r\nmutex_unlock(&los->los_id_lock);\r\nreturn rc;\r\n}\r\nstruct dt_object *__local_file_create(const struct lu_env *env,\r\nconst struct lu_fid *fid,\r\nstruct local_oid_storage *los,\r\nstruct ls_device *ls,\r\nstruct dt_object *parent,\r\nconst char *name, struct lu_attr *attr,\r\nstruct dt_object_format *dof)\r\n{\r\nstruct dt_thread_info *dti = dt_info(env);\r\nstruct dt_object *dto;\r\nstruct thandle *th;\r\nint rc;\r\ndto = ls_locate(env, ls, fid);\r\nif (unlikely(IS_ERR(dto)))\r\nreturn dto;\r\nLASSERT(dto != NULL);\r\nif (dt_object_exists(dto))\r\nGOTO(out, rc = -EEXIST);\r\nth = dt_trans_create(env, ls->ls_osd);\r\nif (IS_ERR(th))\r\nGOTO(out, rc = PTR_ERR(th));\r\nrc = local_object_declare_create(env, los, dto, attr, dof, th);\r\nif (rc)\r\nGOTO(trans_stop, rc);\r\nif (dti->dti_dof.dof_type == DFT_DIR) {\r\ndt_declare_ref_add(env, dto, th);\r\ndt_declare_ref_add(env, parent, th);\r\n}\r\nrc = dt_declare_insert(env, parent, (void *)fid, (void *)name, th);\r\nif (rc)\r\nGOTO(trans_stop, rc);\r\nrc = dt_trans_start_local(env, ls->ls_osd, th);\r\nif (rc)\r\nGOTO(trans_stop, rc);\r\ndt_write_lock(env, dto, 0);\r\nif (dt_object_exists(dto))\r\nGOTO(unlock, rc = 0);\r\nCDEBUG(D_OTHER, "create new object "DFID"\n",\r\nPFID(lu_object_fid(&dto->do_lu)));\r\nrc = local_object_create(env, los, dto, attr, dof, th);\r\nif (rc)\r\nGOTO(unlock, rc);\r\nLASSERT(dt_object_exists(dto));\r\nif (dti->dti_dof.dof_type == DFT_DIR) {\r\nif (!dt_try_as_dir(env, dto))\r\nGOTO(destroy, rc = -ENOTDIR);\r\nrc = dt_insert(env, dto, (void *)fid, (void *)".", th,\r\nBYPASS_CAPA, 1);\r\nif (rc)\r\nGOTO(destroy, rc);\r\ndt_ref_add(env, dto, th);\r\nrc = dt_insert(env, dto, (void *)lu_object_fid(&parent->do_lu),\r\n(void *)"..", th, BYPASS_CAPA, 1);\r\nif (rc)\r\nGOTO(destroy, rc);\r\n}\r\ndt_write_lock(env, parent, 0);\r\nrc = dt_insert(env, parent, (const struct dt_rec *)fid,\r\n(const struct dt_key *)name, th, BYPASS_CAPA, 1);\r\nif (dti->dti_dof.dof_type == DFT_DIR)\r\ndt_ref_add(env, parent, th);\r\ndt_write_unlock(env, parent);\r\nif (rc)\r\nGOTO(destroy, rc);\r\ndestroy:\r\nif (rc)\r\ndt_destroy(env, dto, th);\r\nunlock:\r\ndt_write_unlock(env, dto);\r\ntrans_stop:\r\ndt_trans_stop(env, ls->ls_osd, th);\r\nout:\r\nif (rc) {\r\nlu_object_put_nocache(env, &dto->do_lu);\r\ndto = ERR_PTR(rc);\r\n}\r\nreturn dto;\r\n}\r\nstruct dt_object *local_file_find_or_create(const struct lu_env *env,\r\nstruct local_oid_storage *los,\r\nstruct dt_object *parent,\r\nconst char *name, __u32 mode)\r\n{\r\nstruct dt_thread_info *dti = dt_info(env);\r\nstruct dt_object *dto;\r\nint rc;\r\nLASSERT(parent);\r\nrc = dt_lookup_dir(env, parent, name, &dti->dti_fid);\r\nif (rc == 0)\r\ndto = ls_locate(env, dt2ls_dev(los->los_dev), &dti->dti_fid);\r\nelse if (rc != -ENOENT)\r\ndto = ERR_PTR(rc);\r\nelse {\r\nrc = local_object_fid_generate(env, los, &dti->dti_fid);\r\nif (rc < 0) {\r\ndto = ERR_PTR(rc);\r\n} else {\r\ndti->dti_attr.la_valid = LA_MODE;\r\ndti->dti_attr.la_mode = mode;\r\ndti->dti_dof.dof_type = dt_mode_to_dft(mode & S_IFMT);\r\ndto = __local_file_create(env, &dti->dti_fid, los,\r\ndt2ls_dev(los->los_dev),\r\nparent, name, &dti->dti_attr,\r\n&dti->dti_dof);\r\n}\r\n}\r\nreturn dto;\r\n}\r\nstruct dt_object *local_file_find_or_create_with_fid(const struct lu_env *env,\r\nstruct dt_device *dt,\r\nconst struct lu_fid *fid,\r\nstruct dt_object *parent,\r\nconst char *name,\r\n__u32 mode)\r\n{\r\nstruct dt_thread_info *dti = dt_info(env);\r\nstruct dt_object *dto;\r\nint rc;\r\nLASSERT(parent);\r\nrc = dt_lookup_dir(env, parent, name, &dti->dti_fid);\r\nif (rc == 0) {\r\ndto = dt_locate(env, dt, &dti->dti_fid);\r\n} else if (rc != -ENOENT) {\r\ndto = ERR_PTR(rc);\r\n} else {\r\nstruct ls_device *ls;\r\nls = ls_device_get(dt);\r\nif (IS_ERR(ls)) {\r\ndto = ERR_CAST(ls);\r\n} else {\r\ndti->dti_attr.la_valid = LA_MODE;\r\ndti->dti_attr.la_mode = mode;\r\ndti->dti_dof.dof_type = dt_mode_to_dft(mode & S_IFMT);\r\ndto = __local_file_create(env, fid, NULL, ls, parent,\r\nname, &dti->dti_attr,\r\n&dti->dti_dof);\r\nif (!IS_ERR(dto)) {\r\ndti->dti_fid = dto->do_lu.lo_header->loh_fid;\r\nlu_object_put_nocache(env, &dto->do_lu);\r\ndto = dt_locate(env, dt, &dti->dti_fid);\r\n}\r\nls_device_put(env, ls);\r\n}\r\n}\r\nreturn dto;\r\n}\r\nstruct dt_object *local_index_find_or_create(const struct lu_env *env,\r\nstruct local_oid_storage *los,\r\nstruct dt_object *parent,\r\nconst char *name, __u32 mode,\r\nconst struct dt_index_features *ft)\r\n{\r\nstruct dt_thread_info *dti = dt_info(env);\r\nstruct dt_object *dto;\r\nint rc;\r\nLASSERT(parent);\r\nrc = dt_lookup_dir(env, parent, name, &dti->dti_fid);\r\nif (rc == 0) {\r\ndto = ls_locate(env, dt2ls_dev(los->los_dev), &dti->dti_fid);\r\n} else if (rc != -ENOENT) {\r\ndto = ERR_PTR(rc);\r\n} else {\r\nrc = local_object_fid_generate(env, los, &dti->dti_fid);\r\nif (rc < 0) {\r\ndto = ERR_PTR(rc);\r\n} else {\r\ndti->dti_attr.la_valid = LA_MODE;\r\ndti->dti_attr.la_mode = mode;\r\ndti->dti_dof.dof_type = DFT_INDEX;\r\ndti->dti_dof.u.dof_idx.di_feat = ft;\r\ndto = __local_file_create(env, &dti->dti_fid, los,\r\ndt2ls_dev(los->los_dev),\r\nparent, name, &dti->dti_attr,\r\n&dti->dti_dof);\r\n}\r\n}\r\nreturn dto;\r\n}\r\nstruct dt_object *\r\nlocal_index_find_or_create_with_fid(const struct lu_env *env,\r\nstruct dt_device *dt,\r\nconst struct lu_fid *fid,\r\nstruct dt_object *parent,\r\nconst char *name, __u32 mode,\r\nconst struct dt_index_features *ft)\r\n{\r\nstruct dt_thread_info *dti = dt_info(env);\r\nstruct dt_object *dto;\r\nint rc;\r\nLASSERT(parent);\r\nrc = dt_lookup_dir(env, parent, name, &dti->dti_fid);\r\nif (rc == 0) {\r\nif (!lu_fid_eq(fid, &dti->dti_fid))\r\ndto = ERR_PTR(-EINVAL);\r\nelse\r\ndto = dt_locate(env, dt, fid);\r\n} else if (rc != -ENOENT) {\r\ndto = ERR_PTR(rc);\r\n} else {\r\nstruct ls_device *ls;\r\nls = ls_device_get(dt);\r\nif (IS_ERR(ls)) {\r\ndto = ERR_CAST(ls);\r\n} else {\r\ndti->dti_attr.la_valid = LA_MODE;\r\ndti->dti_attr.la_mode = mode;\r\ndti->dti_dof.dof_type = DFT_INDEX;\r\ndti->dti_dof.u.dof_idx.di_feat = ft;\r\ndto = __local_file_create(env, fid, NULL, ls, parent,\r\nname, &dti->dti_attr,\r\n&dti->dti_dof);\r\nif (!IS_ERR(dto)) {\r\ndti->dti_fid = dto->do_lu.lo_header->loh_fid;\r\nlu_object_put_nocache(env, &dto->do_lu);\r\ndto = dt_locate(env, dt, &dti->dti_fid);\r\n}\r\nls_device_put(env, ls);\r\n}\r\n}\r\nreturn dto;\r\n}\r\nstatic int local_object_declare_unlink(const struct lu_env *env,\r\nstruct dt_device *dt,\r\nstruct dt_object *p,\r\nstruct dt_object *c, const char *name,\r\nstruct thandle *th)\r\n{\r\nint rc;\r\nrc = dt_declare_delete(env, p, (const struct dt_key *)name, th);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = dt_declare_ref_del(env, c, th);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn dt_declare_destroy(env, c, th);\r\n}\r\nint local_object_unlink(const struct lu_env *env, struct dt_device *dt,\r\nstruct dt_object *parent, const char *name)\r\n{\r\nstruct dt_thread_info *dti = dt_info(env);\r\nstruct dt_object *dto;\r\nstruct thandle *th;\r\nint rc;\r\nrc = dt_lookup_dir(env, parent, name, &dti->dti_fid);\r\nif (rc == -ENOENT)\r\nreturn 0;\r\nelse if (rc < 0)\r\nreturn rc;\r\ndto = dt_locate(env, dt, &dti->dti_fid);\r\nif (unlikely(IS_ERR(dto)))\r\nreturn PTR_ERR(dto);\r\nth = dt_trans_create(env, dt);\r\nif (IS_ERR(th))\r\nGOTO(out, rc = PTR_ERR(th));\r\nrc = local_object_declare_unlink(env, dt, parent, dto, name, th);\r\nif (rc < 0)\r\nGOTO(stop, rc);\r\nrc = dt_trans_start_local(env, dt, th);\r\nif (rc < 0)\r\nGOTO(stop, rc);\r\ndt_write_lock(env, dto, 0);\r\nrc = dt_delete(env, parent, (struct dt_key *)name, th, BYPASS_CAPA);\r\nif (rc < 0)\r\nGOTO(unlock, rc);\r\nrc = dt_ref_del(env, dto, th);\r\nif (rc < 0) {\r\nrc = dt_insert(env, parent,\r\n(const struct dt_rec *)&dti->dti_fid,\r\n(const struct dt_key *)name, th, BYPASS_CAPA, 1);\r\nGOTO(unlock, rc);\r\n}\r\nrc = dt_destroy(env, dto, th);\r\nunlock:\r\ndt_write_unlock(env, dto);\r\nstop:\r\ndt_trans_stop(env, dt, th);\r\nout:\r\nlu_object_put_nocache(env, &dto->do_lu);\r\nreturn rc;\r\n}\r\nstruct local_oid_storage *dt_los_find(struct ls_device *ls, __u64 seq)\r\n{\r\nstruct local_oid_storage *los, *ret = NULL;\r\nlist_for_each_entry(los, &ls->ls_los_list, los_list) {\r\nif (los->los_seq == seq) {\r\natomic_inc(&los->los_refcount);\r\nret = los;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid dt_los_put(struct local_oid_storage *los)\r\n{\r\nif (atomic_dec_and_test(&los->los_refcount))\r\nLBUG();\r\nreturn;\r\n}\r\nint lastid_compat_check(const struct lu_env *env, struct dt_device *dev,\r\n__u64 lastid_seq, __u32 *first_oid, struct ls_device *ls)\r\n{\r\nstruct dt_thread_info *dti = dt_info(env);\r\nstruct dt_object *root = NULL;\r\nstruct los_ondisk losd;\r\nstruct dt_object *o = NULL;\r\nint rc = 0;\r\nrc = dt_root_get(env, dev, &dti->dti_fid);\r\nif (rc)\r\nreturn rc;\r\nroot = ls_locate(env, ls, &dti->dti_fid);\r\nif (IS_ERR(root))\r\nreturn PTR_ERR(root);\r\nsnprintf(dti->dti_buf, sizeof(dti->dti_buf), "seq-"LPX64"-lastid",\r\nlastid_seq);\r\nrc = dt_lookup_dir(env, root, dti->dti_buf, &dti->dti_fid);\r\nlu_object_put_nocache(env, &root->do_lu);\r\nif (rc == -ENOENT) {\r\nif (lastid_seq != FID_SEQ_LLOG)\r\nreturn 0;\r\ndti->dti_fid.f_seq = FID_SEQ_LLOG;\r\ndti->dti_fid.f_oid = 1;\r\ndti->dti_fid.f_ver = 0;\r\no = ls_locate(env, ls, &dti->dti_fid);\r\nif (IS_ERR(o))\r\nreturn PTR_ERR(o);\r\nif (!dt_object_exists(o)) {\r\nlu_object_put_nocache(env, &o->do_lu);\r\nreturn 0;\r\n}\r\nCDEBUG(D_INFO, "Found old llog lastid file\n");\r\n} else if (rc < 0) {\r\nreturn rc;\r\n} else {\r\nCDEBUG(D_INFO, "Found old lastid file for sequence "LPX64"\n",\r\nlastid_seq);\r\no = ls_locate(env, ls, &dti->dti_fid);\r\nif (IS_ERR(o))\r\nreturn PTR_ERR(o);\r\n}\r\nLASSERT(dt_object_exists(o));\r\ndti->dti_off = 0;\r\ndti->dti_lb.lb_buf = &losd;\r\ndti->dti_lb.lb_len = sizeof(losd);\r\ndt_read_lock(env, o, 0);\r\nrc = dt_record_read(env, o, &dti->dti_lb, &dti->dti_off);\r\ndt_read_unlock(env, o);\r\nlu_object_put_nocache(env, &o->do_lu);\r\nif (rc == 0 && le32_to_cpu(losd.lso_magic) != LOS_MAGIC) {\r\nCERROR("%s: wrong content of seq-"LPX64"-lastid file, magic %x\n",\r\no->do_lu.lo_dev->ld_obd->obd_name, lastid_seq,\r\nle32_to_cpu(losd.lso_magic));\r\nreturn -EINVAL;\r\n} else if (rc < 0) {\r\nCERROR("%s: failed to read seq-"LPX64"-lastid: rc = %d\n",\r\no->do_lu.lo_dev->ld_obd->obd_name, lastid_seq, rc);\r\nreturn rc;\r\n}\r\n*first_oid = le32_to_cpu(losd.lso_next_oid);\r\nreturn rc;\r\n}\r\nint local_oid_storage_init(const struct lu_env *env, struct dt_device *dev,\r\nconst struct lu_fid *first_fid,\r\nstruct local_oid_storage **los)\r\n{\r\nstruct dt_thread_info *dti = dt_info(env);\r\nstruct ls_device *ls;\r\nobd_id lastid;\r\nstruct dt_object *o = NULL;\r\nstruct thandle *th;\r\n__u32 first_oid = fid_oid(first_fid);\r\nint rc = 0;\r\nls = ls_device_get(dev);\r\nif (IS_ERR(ls))\r\nreturn PTR_ERR(ls);\r\nmutex_lock(&ls->ls_los_mutex);\r\n*los = dt_los_find(ls, fid_seq(first_fid));\r\nif (*los != NULL)\r\nGOTO(out, rc = 0);\r\nOBD_ALLOC_PTR(*los);\r\nif (*los == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\natomic_set(&(*los)->los_refcount, 1);\r\nmutex_init(&(*los)->los_id_lock);\r\n(*los)->los_dev = &ls->ls_top_dev;\r\natomic_inc(&ls->ls_refcount);\r\nlist_add(&(*los)->los_list, &ls->ls_los_list);\r\ndti->dti_fid.f_seq = fid_seq(first_fid);\r\ndti->dti_fid.f_oid = LUSTRE_FID_LASTID_OID;\r\ndti->dti_fid.f_ver = 0;\r\no = ls_locate(env, ls, &dti->dti_fid);\r\nif (IS_ERR(o))\r\nGOTO(out_los, rc = PTR_ERR(o));\r\nif (!dt_object_exists(o)) {\r\nrc = lastid_compat_check(env, dev, fid_seq(first_fid),\r\n&first_oid, ls);\r\nif (rc < 0)\r\nGOTO(out_los, rc);\r\nth = dt_trans_create(env, dev);\r\nif (IS_ERR(th))\r\nGOTO(out_los, rc = PTR_ERR(th));\r\ndti->dti_attr.la_valid = LA_MODE | LA_TYPE;\r\ndti->dti_attr.la_mode = S_IFREG | S_IRUGO | S_IWUSR;\r\ndti->dti_dof.dof_type = dt_mode_to_dft(S_IFREG);\r\nrc = dt_declare_create(env, o, &dti->dti_attr, NULL,\r\n&dti->dti_dof, th);\r\nif (rc)\r\nGOTO(out_trans, rc);\r\nrc = dt_declare_record_write(env, o, sizeof(lastid), 0, th);\r\nif (rc)\r\nGOTO(out_trans, rc);\r\nrc = dt_trans_start_local(env, dev, th);\r\nif (rc)\r\nGOTO(out_trans, rc);\r\ndt_write_lock(env, o, 0);\r\nif (dt_object_exists(o))\r\nGOTO(out_lock, rc = 0);\r\nrc = dt_create(env, o, &dti->dti_attr, NULL, &dti->dti_dof,\r\nth);\r\nif (rc)\r\nGOTO(out_lock, rc);\r\nlastid = cpu_to_le64(first_oid);\r\ndti->dti_off = 0;\r\ndti->dti_lb.lb_buf = &lastid;\r\ndti->dti_lb.lb_len = sizeof(lastid);\r\nrc = dt_record_write(env, o, &dti->dti_lb, &dti->dti_off, th);\r\nif (rc)\r\nGOTO(out_lock, rc);\r\nout_lock:\r\ndt_write_unlock(env, o);\r\nout_trans:\r\ndt_trans_stop(env, dev, th);\r\n} else {\r\ndti->dti_off = 0;\r\ndti->dti_lb.lb_buf = &lastid;\r\ndti->dti_lb.lb_len = sizeof(lastid);\r\ndt_read_lock(env, o, 0);\r\nrc = dt_record_read(env, o, &dti->dti_lb, &dti->dti_off);\r\ndt_read_unlock(env, o);\r\nif (rc == 0 && le64_to_cpu(lastid) > OBIF_MAX_OID) {\r\nCERROR("%s: bad oid "LPU64" is read from LAST_ID\n",\r\no->do_lu.lo_dev->ld_obd->obd_name,\r\nle64_to_cpu(lastid));\r\nrc = -EINVAL;\r\n}\r\n}\r\nout_los:\r\nif (rc != 0) {\r\nlist_del(&(*los)->los_list);\r\natomic_dec(&ls->ls_refcount);\r\nOBD_FREE_PTR(*los);\r\n*los = NULL;\r\nif (o != NULL && !IS_ERR(o))\r\nlu_object_put_nocache(env, &o->do_lu);\r\n} else {\r\n(*los)->los_seq = fid_seq(first_fid);\r\n(*los)->los_last_oid = le64_to_cpu(lastid);\r\n(*los)->los_obj = o;\r\nif ((*los)->los_last_oid < first_oid)\r\n(*los)->los_last_oid = first_oid;\r\n}\r\nout:\r\nmutex_unlock(&ls->ls_los_mutex);\r\nls_device_put(env, ls);\r\nreturn rc;\r\n}\r\nvoid local_oid_storage_fini(const struct lu_env *env,\r\nstruct local_oid_storage *los)\r\n{\r\nstruct ls_device *ls;\r\nif (!atomic_dec_and_test(&los->los_refcount))\r\nreturn;\r\nLASSERT(env);\r\nLASSERT(los->los_dev);\r\nls = dt2ls_dev(los->los_dev);\r\nmutex_lock(&ls->ls_los_mutex);\r\nif (atomic_read(&los->los_refcount) == 0) {\r\nif (los->los_obj)\r\nlu_object_put_nocache(env, &los->los_obj->do_lu);\r\nlist_del(&los->los_list);\r\nOBD_FREE_PTR(los);\r\n}\r\nmutex_unlock(&ls->ls_los_mutex);\r\nls_device_put(env, ls);\r\n}
