static inline u16 i2c_rd16(struct s6i2c_if *iface, unsigned n)\r\n{\r\nreturn readw(iface->reg + (n));\r\n}\r\nstatic inline void i2c_wr16(struct s6i2c_if *iface, unsigned n, u16 v)\r\n{\r\nwritew(v, iface->reg + (n));\r\n}\r\nstatic inline u32 i2c_rd32(struct s6i2c_if *iface, unsigned n)\r\n{\r\nreturn readl(iface->reg + (n));\r\n}\r\nstatic inline void i2c_wr32(struct s6i2c_if *iface, unsigned n, u32 v)\r\n{\r\nwritel(v, iface->reg + (n));\r\n}\r\nstatic void s6i2c_handle_interrupt(struct s6i2c_if *iface)\r\n{\r\nif (i2c_rd16(iface, S6_I2C_INTRSTAT) & (1 << S6_I2C_INTR_TXABRT)) {\r\ni2c_rd16(iface, S6_I2C_CLRTXABRT);\r\ni2c_wr16(iface, S6_I2C_INTRMASK, 0);\r\ncomplete(&iface->complete);\r\nreturn;\r\n}\r\nif (iface->msgs_done >= iface->msgs_num) {\r\ndev_err(&iface->adap.dev, "s6i2c: spurious I2C irq: %04x\n",\r\ni2c_rd16(iface, S6_I2C_INTRSTAT));\r\ni2c_wr16(iface, S6_I2C_INTRMASK, 0);\r\nreturn;\r\n}\r\nwhile ((iface->msgs_push < iface->msgs_num)\r\n&& (i2c_rd16(iface, S6_I2C_STATUS) & (1 << S6_I2C_STATUS_TFNF))) {\r\nstruct i2c_msg *m = &iface->msgs[iface->msgs_push];\r\nif (!(m->flags & I2C_M_RD))\r\ni2c_wr16(iface, S6_I2C_DATACMD, m->buf[iface->push]);\r\nelse\r\ni2c_wr16(iface, S6_I2C_DATACMD,\r\n1 << S6_I2C_DATACMD_READ);\r\nif (++iface->push >= m->len) {\r\niface->push = 0;\r\niface->msgs_push += 1;\r\n}\r\n}\r\ndo {\r\nstruct i2c_msg *m = &iface->msgs[iface->msgs_done];\r\nif (!(m->flags & I2C_M_RD)) {\r\nif (iface->msgs_done < iface->msgs_push)\r\niface->msgs_done += 1;\r\nelse\r\nbreak;\r\n} else if (i2c_rd16(iface, S6_I2C_STATUS)\r\n& (1 << S6_I2C_STATUS_RFNE)) {\r\nm->buf[iface->done] = i2c_rd16(iface, S6_I2C_DATACMD);\r\nif (++iface->done >= m->len) {\r\niface->done = 0;\r\niface->msgs_done += 1;\r\n}\r\n} else{\r\nbreak;\r\n}\r\n} while (iface->msgs_done < iface->msgs_num);\r\nif (iface->msgs_done >= iface->msgs_num) {\r\ni2c_wr16(iface, S6_I2C_INTRMASK, 1 << S6_I2C_INTR_TXABRT);\r\ncomplete(&iface->complete);\r\n} else if (iface->msgs_push >= iface->msgs_num) {\r\ni2c_wr16(iface, S6_I2C_INTRMASK, (1 << S6_I2C_INTR_TXABRT) |\r\n(1 << S6_I2C_INTR_RXFULL));\r\n} else {\r\ni2c_wr16(iface, S6_I2C_INTRMASK, (1 << S6_I2C_INTR_TXABRT) |\r\n(1 << S6_I2C_INTR_TXEMPTY) |\r\n(1 << S6_I2C_INTR_RXFULL));\r\n}\r\n}\r\nstatic irqreturn_t s6i2c_interrupt_entry(int irq, void *dev_id)\r\n{\r\nstruct s6i2c_if *iface = dev_id;\r\nif (!(i2c_rd16(iface, S6_I2C_STATUS) & ((1 << S6_I2C_INTR_RXUNDER)\r\n| (1 << S6_I2C_INTR_RXOVER)\r\n| (1 << S6_I2C_INTR_RXFULL)\r\n| (1 << S6_I2C_INTR_TXOVER)\r\n| (1 << S6_I2C_INTR_TXEMPTY)\r\n| (1 << S6_I2C_INTR_RDREQ)\r\n| (1 << S6_I2C_INTR_TXABRT)\r\n| (1 << S6_I2C_INTR_RXDONE)\r\n| (1 << S6_I2C_INTR_ACTIVITY)\r\n| (1 << S6_I2C_INTR_STOPDET)\r\n| (1 << S6_I2C_INTR_STARTDET)\r\n| (1 << S6_I2C_INTR_GENCALL))))\r\nreturn IRQ_NONE;\r\nspin_lock(&iface->lock);\r\ndel_timer(&iface->timeout_timer);\r\ns6i2c_handle_interrupt(iface);\r\nspin_unlock(&iface->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void s6i2c_timeout(unsigned long data)\r\n{\r\nstruct s6i2c_if *iface = (struct s6i2c_if *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&iface->lock, flags);\r\ns6i2c_handle_interrupt(iface);\r\nif (--iface->timeout_count > 0) {\r\niface->timeout_timer.expires = jiffies + POLL_TIMEOUT;\r\nadd_timer(&iface->timeout_timer);\r\n} else {\r\ncomplete(&iface->complete);\r\ni2c_wr16(iface, S6_I2C_INTRMASK, 0);\r\n}\r\nspin_unlock_irqrestore(&iface->lock, flags);\r\n}\r\nstatic int s6i2c_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct s6i2c_if *iface = adap->algo_data;\r\nint i;\r\nif (num == 0)\r\nreturn 0;\r\nif (i2c_rd16(iface, S6_I2C_STATUS) & (1 << S6_I2C_STATUS_ACTIVITY))\r\nyield();\r\ni2c_wr16(iface, S6_I2C_INTRMASK, 0);\r\ni2c_rd16(iface, S6_I2C_CLRINTR);\r\nfor (i = 0; i < num; i++) {\r\nif (msgs[i].flags & I2C_M_TEN) {\r\ndev_err(&adap->dev,\r\n"s6i2c: 10 bits addr not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (msgs[i].len == 0) {\r\ndev_err(&adap->dev,\r\n"s6i2c: zero length message not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (msgs[i].addr != msgs[0].addr) {\r\ndev_err(&adap->dev,\r\n"s6i2c: multiple xfer cannot change target\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\niface->msgs = msgs;\r\niface->msgs_num = num;\r\niface->msgs_push = 0;\r\niface->msgs_done = 0;\r\niface->push = 0;\r\niface->done = 0;\r\niface->timeout_count = 10;\r\ni2c_wr16(iface, S6_I2C_TAR, msgs[0].addr);\r\ni2c_wr16(iface, S6_I2C_ENABLE, 1);\r\ni2c_wr16(iface, S6_I2C_INTRMASK, (1 << S6_I2C_INTR_TXEMPTY) |\r\n(1 << S6_I2C_INTR_TXABRT));\r\niface->timeout_timer.expires = jiffies + POLL_TIMEOUT;\r\nadd_timer(&iface->timeout_timer);\r\nwait_for_completion(&iface->complete);\r\ndel_timer_sync(&iface->timeout_timer);\r\nwhile (i2c_rd32(iface, S6_I2C_TXFLR) > 0)\r\nschedule();\r\nwhile (i2c_rd16(iface, S6_I2C_STATUS) & (1 << S6_I2C_STATUS_ACTIVITY))\r\nschedule();\r\ni2c_wr16(iface, S6_I2C_INTRMASK, 0);\r\ni2c_wr16(iface, S6_I2C_ENABLE, 0);\r\nreturn iface->msgs_done;\r\n}\r\nstatic u32 s6i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic u16 nanoseconds_on_clk(struct s6i2c_if *iface, u32 ns)\r\n{\r\nu32 dividend = ((clk_get_rate(iface->clk) / 1000) * ns) / 1000000;\r\nif (dividend > 0xffff)\r\nreturn 0xffff;\r\nreturn dividend;\r\n}\r\nstatic int s6i2c_probe(struct platform_device *dev)\r\n{\r\nstruct s6i2c_if *iface = &s6i2c_if;\r\nstruct i2c_adapter *p_adap;\r\nconst char *clock;\r\nint bus_num, rc;\r\nspin_lock_init(&iface->lock);\r\ninit_completion(&iface->complete);\r\niface->irq = platform_get_irq(dev, 0);\r\nif (iface->irq < 0) {\r\nrc = iface->irq;\r\ngoto err_out;\r\n}\r\niface->res = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!iface->res) {\r\nrc = -ENXIO;\r\ngoto err_out;\r\n}\r\niface->res = request_mem_region(iface->res->start,\r\nresource_size(iface->res),\r\ndev->dev.bus_id);\r\nif (!iface->res) {\r\nrc = -EBUSY;\r\ngoto err_out;\r\n}\r\niface->reg = ioremap_nocache(iface->res->start,\r\nresource_size(iface->res));\r\nif (!iface->reg) {\r\nrc = -ENOMEM;\r\ngoto err_reg;\r\n}\r\nclock = 0;\r\nbus_num = -1;\r\nif (dev_get_platdata(&dev->dev)) {\r\nstruct s6_i2c_platform_data *pdata =\r\ndev_get_platdata(&dev->dev);\r\nbus_num = pdata->bus_num;\r\nclock = pdata->clock;\r\n}\r\niface->clk = clk_get(&dev->dev, clock);\r\nif (IS_ERR(iface->clk)) {\r\nrc = PTR_ERR(iface->clk);\r\ngoto err_map;\r\n}\r\nrc = clk_enable(iface->clk);\r\nif (rc < 0)\r\ngoto err_clk_put;\r\ninit_timer(&iface->timeout_timer);\r\niface->timeout_timer.function = s6i2c_timeout;\r\niface->timeout_timer.data = (unsigned long)iface;\r\np_adap = &iface->adap;\r\nstrlcpy(p_adap->name, dev->name, sizeof(p_adap->name));\r\np_adap->algo = &s6i2c_algorithm;\r\np_adap->algo_data = iface;\r\np_adap->nr = bus_num;\r\np_adap->class = 0;\r\np_adap->dev.parent = &dev->dev;\r\ni2c_wr16(iface, S6_I2C_INTRMASK, 0);\r\nrc = request_irq(iface->irq, s6i2c_interrupt_entry,\r\nIRQF_SHARED, dev->name, iface);\r\nif (rc) {\r\ndev_err(&p_adap->dev, "s6i2c: can't get IRQ %d\n", iface->irq);\r\ngoto err_clk_dis;\r\n}\r\ni2c_wr16(iface, S6_I2C_ENABLE, 0);\r\nudelay(1);\r\ni2c_wr32(iface, S6_I2C_SRESET, 1 << S6_I2C_SRESET_IC_SRST);\r\ni2c_wr16(iface, S6_I2C_CLRTXABRT, 1);\r\ni2c_wr16(iface, S6_I2C_CON,\r\n(1 << S6_I2C_CON_MASTER) |\r\n(S6_I2C_CON_SPEED_NORMAL << S6_I2C_CON_SPEED) |\r\n(0 << S6_I2C_CON_10BITSLAVE) |\r\n(0 << S6_I2C_CON_10BITMASTER) |\r\n(1 << S6_I2C_CON_RESTARTENA) |\r\n(1 << S6_I2C_CON_SLAVEDISABLE));\r\ni2c_wr16(iface, S6_I2C_SSHCNT, nanoseconds_on_clk(iface, 4000));\r\ni2c_wr16(iface, S6_I2C_SSLCNT, nanoseconds_on_clk(iface, 4700));\r\ni2c_wr16(iface, S6_I2C_FSHCNT, nanoseconds_on_clk(iface, 600));\r\ni2c_wr16(iface, S6_I2C_FSLCNT, nanoseconds_on_clk(iface, 1300));\r\ni2c_wr16(iface, S6_I2C_RXTL, 0);\r\ni2c_wr16(iface, S6_I2C_TXTL, 0);\r\nplatform_set_drvdata(dev, iface);\r\nrc = i2c_add_numbered_adapter(p_adap);\r\nif (rc)\r\ngoto err_irq_free;\r\nreturn 0;\r\nerr_irq_free:\r\nfree_irq(iface->irq, iface);\r\nerr_clk_dis:\r\nclk_disable(iface->clk);\r\nerr_clk_put:\r\nclk_put(iface->clk);\r\nerr_map:\r\niounmap(iface->reg);\r\nerr_reg:\r\nrelease_mem_region(iface->res->start,\r\nresource_size(iface->res));\r\nerr_out:\r\nreturn rc;\r\n}\r\nstatic int s6i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct s6i2c_if *iface = platform_get_drvdata(pdev);\r\ni2c_wr16(iface, S6_I2C_ENABLE, 0);\r\ni2c_del_adapter(&iface->adap);\r\nfree_irq(iface->irq, iface);\r\nclk_disable(iface->clk);\r\nclk_put(iface->clk);\r\niounmap(iface->reg);\r\nrelease_mem_region(iface->res->start,\r\nresource_size(iface->res));\r\nreturn 0;\r\n}\r\nstatic int __init s6i2c_init(void)\r\n{\r\npr_info("I2C: S6000 I2C driver\n");\r\nreturn platform_driver_register(&s6i2c_driver);\r\n}\r\nstatic void __exit s6i2c_exit(void)\r\n{\r\nplatform_driver_unregister(&s6i2c_driver);\r\n}
