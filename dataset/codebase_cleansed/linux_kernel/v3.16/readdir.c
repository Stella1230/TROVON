static void dump_cifs_file_struct(struct file *file, char *label)\r\n{\r\nstruct cifsFileInfo *cf;\r\nif (file) {\r\ncf = file->private_data;\r\nif (cf == NULL) {\r\ncifs_dbg(FYI, "empty cifs private file data\n");\r\nreturn;\r\n}\r\nif (cf->invalidHandle)\r\ncifs_dbg(FYI, "invalid handle\n");\r\nif (cf->srch_inf.endOfSearch)\r\ncifs_dbg(FYI, "end of search\n");\r\nif (cf->srch_inf.emptyDir)\r\ncifs_dbg(FYI, "empty dir\n");\r\n}\r\n}\r\nstatic inline void dump_cifs_file_struct(struct file *file, char *label)\r\n{\r\n}\r\nstatic void\r\ncifs_prime_dcache(struct dentry *parent, struct qstr *name,\r\nstruct cifs_fattr *fattr)\r\n{\r\nstruct dentry *dentry, *alias;\r\nstruct inode *inode;\r\nstruct super_block *sb = parent->d_inode->i_sb;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\r\ncifs_dbg(FYI, "%s: for %s\n", __func__, name->name);\r\ndentry = d_hash_and_lookup(parent, name);\r\nif (unlikely(IS_ERR(dentry)))\r\nreturn;\r\nif (dentry) {\r\nint err;\r\ninode = dentry->d_inode;\r\nif (inode) {\r\nif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM))\r\nfattr->cf_uniqueid = CIFS_I(inode)->uniqueid;\r\nif (CIFS_I(inode)->uniqueid == fattr->cf_uniqueid) {\r\ncifs_fattr_to_inode(inode, fattr);\r\ngoto out;\r\n}\r\n}\r\nerr = d_invalidate(dentry);\r\ndput(dentry);\r\nif (err)\r\nreturn;\r\n}\r\nif (fattr->cf_flags & CIFS_FATTR_NEED_REVAL)\r\nreturn;\r\ndentry = d_alloc(parent, name);\r\nif (!dentry)\r\nreturn;\r\ninode = cifs_iget(sb, fattr);\r\nif (!inode)\r\ngoto out;\r\nalias = d_materialise_unique(dentry, inode);\r\nif (alias && !IS_ERR(alias))\r\ndput(alias);\r\nout:\r\ndput(dentry);\r\n}\r\nstatic void\r\ncifs_fill_common_info(struct cifs_fattr *fattr, struct cifs_sb_info *cifs_sb)\r\n{\r\nfattr->cf_uid = cifs_sb->mnt_uid;\r\nfattr->cf_gid = cifs_sb->mnt_gid;\r\nif (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\r\nfattr->cf_mode = S_IFDIR | cifs_sb->mnt_dir_mode;\r\nfattr->cf_dtype = DT_DIR;\r\n} else {\r\nfattr->cf_mode = S_IFREG | cifs_sb->mnt_file_mode;\r\nfattr->cf_dtype = DT_REG;\r\n}\r\nif (fattr->cf_cifsattrs & ATTR_REPARSE)\r\nfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\r\nfattr->cf_flags |= CIFS_FATTR_UNKNOWN_NLINK;\r\nif (fattr->cf_cifsattrs & ATTR_READONLY)\r\nfattr->cf_mode &= ~S_IWUGO;\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)\r\nfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL &&\r\nfattr->cf_cifsattrs & ATTR_SYSTEM) {\r\nif (fattr->cf_eof == 0) {\r\nfattr->cf_mode &= ~S_IFMT;\r\nfattr->cf_mode |= S_IFIFO;\r\nfattr->cf_dtype = DT_FIFO;\r\n} else {\r\nfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\r\n}\r\n}\r\n}\r\nvoid\r\ncifs_dir_info_to_fattr(struct cifs_fattr *fattr, FILE_DIRECTORY_INFO *info,\r\nstruct cifs_sb_info *cifs_sb)\r\n{\r\nmemset(fattr, 0, sizeof(*fattr));\r\nfattr->cf_cifsattrs = le32_to_cpu(info->ExtFileAttributes);\r\nfattr->cf_eof = le64_to_cpu(info->EndOfFile);\r\nfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\r\nfattr->cf_createtime = le64_to_cpu(info->CreationTime);\r\nfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\r\nfattr->cf_ctime = cifs_NTtimeToUnix(info->ChangeTime);\r\nfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\r\ncifs_fill_common_info(fattr, cifs_sb);\r\n}\r\nstatic void\r\ncifs_std_info_to_fattr(struct cifs_fattr *fattr, FIND_FILE_STANDARD_INFO *info,\r\nstruct cifs_sb_info *cifs_sb)\r\n{\r\nint offset = cifs_sb_master_tcon(cifs_sb)->ses->server->timeAdj;\r\nmemset(fattr, 0, sizeof(*fattr));\r\nfattr->cf_atime = cnvrtDosUnixTm(info->LastAccessDate,\r\ninfo->LastAccessTime, offset);\r\nfattr->cf_ctime = cnvrtDosUnixTm(info->LastWriteDate,\r\ninfo->LastWriteTime, offset);\r\nfattr->cf_mtime = cnvrtDosUnixTm(info->LastWriteDate,\r\ninfo->LastWriteTime, offset);\r\nfattr->cf_cifsattrs = le16_to_cpu(info->Attributes);\r\nfattr->cf_bytes = le32_to_cpu(info->AllocationSize);\r\nfattr->cf_eof = le32_to_cpu(info->DataSize);\r\ncifs_fill_common_info(fattr, cifs_sb);\r\n}\r\nstatic int\r\ninitiate_cifs_search(const unsigned int xid, struct file *file)\r\n{\r\n__u16 search_flags;\r\nint rc = 0;\r\nchar *full_path = NULL;\r\nstruct cifsFileInfo *cifsFile;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(file->f_path.dentry->d_sb);\r\nstruct tcon_link *tlink = NULL;\r\nstruct cifs_tcon *tcon;\r\nstruct TCP_Server_Info *server;\r\nif (file->private_data == NULL) {\r\ntlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink))\r\nreturn PTR_ERR(tlink);\r\ncifsFile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\r\nif (cifsFile == NULL) {\r\nrc = -ENOMEM;\r\ngoto error_exit;\r\n}\r\nfile->private_data = cifsFile;\r\ncifsFile->tlink = cifs_get_tlink(tlink);\r\ntcon = tlink_tcon(tlink);\r\n} else {\r\ncifsFile = file->private_data;\r\ntcon = tlink_tcon(cifsFile->tlink);\r\n}\r\nserver = tcon->ses->server;\r\nif (!server->ops->query_dir_first) {\r\nrc = -ENOSYS;\r\ngoto error_exit;\r\n}\r\ncifsFile->invalidHandle = true;\r\ncifsFile->srch_inf.endOfSearch = false;\r\nfull_path = build_path_from_dentry(file->f_path.dentry);\r\nif (full_path == NULL) {\r\nrc = -ENOMEM;\r\ngoto error_exit;\r\n}\r\ncifs_dbg(FYI, "Full path: %s start at: %lld\n", full_path, file->f_pos);\r\nffirst_retry:\r\nif (tcon->unix_ext)\r\ncifsFile->srch_inf.info_level = SMB_FIND_FILE_UNIX;\r\nelse if ((tcon->ses->capabilities &\r\ntcon->ses->server->vals->cap_nt_find) == 0) {\r\ncifsFile->srch_inf.info_level = SMB_FIND_FILE_INFO_STANDARD;\r\n} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\r\ncifsFile->srch_inf.info_level = SMB_FIND_FILE_ID_FULL_DIR_INFO;\r\n} else {\r\ncifsFile->srch_inf.info_level = SMB_FIND_FILE_DIRECTORY_INFO;\r\n}\r\nsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\r\nif (backup_cred(cifs_sb))\r\nsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\r\nrc = server->ops->query_dir_first(xid, tcon, full_path, cifs_sb,\r\n&cifsFile->fid, search_flags,\r\n&cifsFile->srch_inf);\r\nif (rc == 0)\r\ncifsFile->invalidHandle = false;\r\nelse if ((rc == -EOPNOTSUPP) &&\r\n(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\r\ncifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\r\ngoto ffirst_retry;\r\n}\r\nerror_exit:\r\nkfree(full_path);\r\ncifs_put_tlink(tlink);\r\nreturn rc;\r\n}\r\nstatic int cifs_unicode_bytelen(const char *str)\r\n{\r\nint len;\r\nconst __le16 *ustr = (const __le16 *)str;\r\nfor (len = 0; len <= PATH_MAX; len++) {\r\nif (ustr[len] == 0)\r\nreturn len << 1;\r\n}\r\ncifs_dbg(FYI, "Unicode string longer than PATH_MAX found\n");\r\nreturn len << 1;\r\n}\r\nstatic char *nxt_dir_entry(char *old_entry, char *end_of_smb, int level)\r\n{\r\nchar *new_entry;\r\nFILE_DIRECTORY_INFO *pDirInfo = (FILE_DIRECTORY_INFO *)old_entry;\r\nif (level == SMB_FIND_FILE_INFO_STANDARD) {\r\nFIND_FILE_STANDARD_INFO *pfData;\r\npfData = (FIND_FILE_STANDARD_INFO *)pDirInfo;\r\nnew_entry = old_entry + sizeof(FIND_FILE_STANDARD_INFO) +\r\npfData->FileNameLength;\r\n} else\r\nnew_entry = old_entry + le32_to_cpu(pDirInfo->NextEntryOffset);\r\ncifs_dbg(FYI, "new entry %p old entry %p\n", new_entry, old_entry);\r\nif (new_entry >= end_of_smb) {\r\ncifs_dbg(VFS, "search entry %p began after end of SMB %p old entry %p\n",\r\nnew_entry, end_of_smb, old_entry);\r\nreturn NULL;\r\n} else if (((level == SMB_FIND_FILE_INFO_STANDARD) &&\r\n(new_entry + sizeof(FIND_FILE_STANDARD_INFO) > end_of_smb))\r\n|| ((level != SMB_FIND_FILE_INFO_STANDARD) &&\r\n(new_entry + sizeof(FILE_DIRECTORY_INFO) > end_of_smb))) {\r\ncifs_dbg(VFS, "search entry %p extends after end of SMB %p\n",\r\nnew_entry, end_of_smb);\r\nreturn NULL;\r\n} else\r\nreturn new_entry;\r\n}\r\nstatic void cifs_fill_dirent_unix(struct cifs_dirent *de,\r\nconst FILE_UNIX_INFO *info, bool is_unicode)\r\n{\r\nde->name = &info->FileName[0];\r\nif (is_unicode)\r\nde->namelen = cifs_unicode_bytelen(de->name);\r\nelse\r\nde->namelen = strnlen(de->name, PATH_MAX);\r\nde->resume_key = info->ResumeKey;\r\nde->ino = le64_to_cpu(info->basic.UniqueId);\r\n}\r\nstatic void cifs_fill_dirent_dir(struct cifs_dirent *de,\r\nconst FILE_DIRECTORY_INFO *info)\r\n{\r\nde->name = &info->FileName[0];\r\nde->namelen = le32_to_cpu(info->FileNameLength);\r\nde->resume_key = info->FileIndex;\r\n}\r\nstatic void cifs_fill_dirent_full(struct cifs_dirent *de,\r\nconst FILE_FULL_DIRECTORY_INFO *info)\r\n{\r\nde->name = &info->FileName[0];\r\nde->namelen = le32_to_cpu(info->FileNameLength);\r\nde->resume_key = info->FileIndex;\r\n}\r\nstatic void cifs_fill_dirent_search(struct cifs_dirent *de,\r\nconst SEARCH_ID_FULL_DIR_INFO *info)\r\n{\r\nde->name = &info->FileName[0];\r\nde->namelen = le32_to_cpu(info->FileNameLength);\r\nde->resume_key = info->FileIndex;\r\nde->ino = le64_to_cpu(info->UniqueId);\r\n}\r\nstatic void cifs_fill_dirent_both(struct cifs_dirent *de,\r\nconst FILE_BOTH_DIRECTORY_INFO *info)\r\n{\r\nde->name = &info->FileName[0];\r\nde->namelen = le32_to_cpu(info->FileNameLength);\r\nde->resume_key = info->FileIndex;\r\n}\r\nstatic void cifs_fill_dirent_std(struct cifs_dirent *de,\r\nconst FIND_FILE_STANDARD_INFO *info)\r\n{\r\nde->name = &info->FileName[0];\r\nde->namelen = info->FileNameLength;\r\nde->resume_key = info->ResumeKey;\r\n}\r\nstatic int cifs_fill_dirent(struct cifs_dirent *de, const void *info,\r\nu16 level, bool is_unicode)\r\n{\r\nmemset(de, 0, sizeof(*de));\r\nswitch (level) {\r\ncase SMB_FIND_FILE_UNIX:\r\ncifs_fill_dirent_unix(de, info, is_unicode);\r\nbreak;\r\ncase SMB_FIND_FILE_DIRECTORY_INFO:\r\ncifs_fill_dirent_dir(de, info);\r\nbreak;\r\ncase SMB_FIND_FILE_FULL_DIRECTORY_INFO:\r\ncifs_fill_dirent_full(de, info);\r\nbreak;\r\ncase SMB_FIND_FILE_ID_FULL_DIR_INFO:\r\ncifs_fill_dirent_search(de, info);\r\nbreak;\r\ncase SMB_FIND_FILE_BOTH_DIRECTORY_INFO:\r\ncifs_fill_dirent_both(de, info);\r\nbreak;\r\ncase SMB_FIND_FILE_INFO_STANDARD:\r\ncifs_fill_dirent_std(de, info);\r\nbreak;\r\ndefault:\r\ncifs_dbg(FYI, "Unknown findfirst level %d\n", level);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cifs_entry_is_dot(struct cifs_dirent *de, bool is_unicode)\r\n{\r\nint rc = 0;\r\nif (!de->name)\r\nreturn 0;\r\nif (is_unicode) {\r\n__le16 *ufilename = (__le16 *)de->name;\r\nif (de->namelen == 2) {\r\nif (ufilename[0] == UNICODE_DOT)\r\nrc = 1;\r\n} else if (de->namelen == 4) {\r\nif (ufilename[0] == UNICODE_DOT &&\r\nufilename[1] == UNICODE_DOT)\r\nrc = 2;\r\n}\r\n} else {\r\nif (de->namelen == 1) {\r\nif (de->name[0] == '.')\r\nrc = 1;\r\n} else if (de->namelen == 2) {\r\nif (de->name[0] == '.' && de->name[1] == '.')\r\nrc = 2;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int is_dir_changed(struct file *file)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct cifsInodeInfo *cifsInfo = CIFS_I(inode);\r\nif (cifsInfo->time == 0)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int cifs_save_resume_key(const char *current_entry,\r\nstruct cifsFileInfo *file_info)\r\n{\r\nstruct cifs_dirent de;\r\nint rc;\r\nrc = cifs_fill_dirent(&de, current_entry, file_info->srch_inf.info_level,\r\nfile_info->srch_inf.unicode);\r\nif (!rc) {\r\nfile_info->srch_inf.presume_name = de.name;\r\nfile_info->srch_inf.resume_name_len = de.namelen;\r\nfile_info->srch_inf.resume_key = de.resume_key;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nfind_cifs_entry(const unsigned int xid, struct cifs_tcon *tcon, loff_t pos,\r\nstruct file *file, char **current_entry, int *num_to_ret)\r\n{\r\n__u16 search_flags;\r\nint rc = 0;\r\nint pos_in_buf = 0;\r\nloff_t first_entry_in_buffer;\r\nloff_t index_to_find = pos;\r\nstruct cifsFileInfo *cfile = file->private_data;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(file->f_path.dentry->d_sb);\r\nstruct TCP_Server_Info *server = tcon->ses->server;\r\nif (!server->ops->query_dir_first || !server->ops->query_dir_next)\r\nreturn -ENOSYS;\r\nif ((cfile == NULL) || (current_entry == NULL) || (num_to_ret == NULL))\r\nreturn -ENOENT;\r\n*current_entry = NULL;\r\nfirst_entry_in_buffer = cfile->srch_inf.index_of_last_entry -\r\ncfile->srch_inf.entries_in_buffer;\r\ndump_cifs_file_struct(file, "In fce ");\r\nif (((index_to_find < cfile->srch_inf.index_of_last_entry) &&\r\nis_dir_changed(file)) || (index_to_find < first_entry_in_buffer)) {\r\ncifs_dbg(FYI, "search backing up - close and restart search\n");\r\nspin_lock(&cifs_file_list_lock);\r\nif (!cfile->srch_inf.endOfSearch && !cfile->invalidHandle) {\r\ncfile->invalidHandle = true;\r\nspin_unlock(&cifs_file_list_lock);\r\nif (server->ops->close)\r\nserver->ops->close(xid, tcon, &cfile->fid);\r\n} else\r\nspin_unlock(&cifs_file_list_lock);\r\nif (cfile->srch_inf.ntwrk_buf_start) {\r\ncifs_dbg(FYI, "freeing SMB ff cache buf on search rewind\n");\r\nif (cfile->srch_inf.smallBuf)\r\ncifs_small_buf_release(cfile->srch_inf.\r\nntwrk_buf_start);\r\nelse\r\ncifs_buf_release(cfile->srch_inf.\r\nntwrk_buf_start);\r\ncfile->srch_inf.ntwrk_buf_start = NULL;\r\n}\r\nrc = initiate_cifs_search(xid, file);\r\nif (rc) {\r\ncifs_dbg(FYI, "error %d reinitiating a search on rewind\n",\r\nrc);\r\nreturn rc;\r\n}\r\nif (cfile->srch_inf.last_entry)\r\ncifs_save_resume_key(cfile->srch_inf.last_entry, cfile);\r\n}\r\nsearch_flags = CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME;\r\nif (backup_cred(cifs_sb))\r\nsearch_flags |= CIFS_SEARCH_BACKUP_SEARCH;\r\nwhile ((index_to_find >= cfile->srch_inf.index_of_last_entry) &&\r\n(rc == 0) && !cfile->srch_inf.endOfSearch) {\r\ncifs_dbg(FYI, "calling findnext2\n");\r\nrc = server->ops->query_dir_next(xid, tcon, &cfile->fid,\r\nsearch_flags,\r\n&cfile->srch_inf);\r\nif (cfile->srch_inf.last_entry)\r\ncifs_save_resume_key(cfile->srch_inf.last_entry, cfile);\r\nif (rc)\r\nreturn -ENOENT;\r\n}\r\nif (index_to_find < cfile->srch_inf.index_of_last_entry) {\r\nint i;\r\nchar *cur_ent;\r\nchar *end_of_smb = cfile->srch_inf.ntwrk_buf_start +\r\nserver->ops->calc_smb_size(\r\ncfile->srch_inf.ntwrk_buf_start);\r\ncur_ent = cfile->srch_inf.srch_entries_start;\r\nfirst_entry_in_buffer = cfile->srch_inf.index_of_last_entry\r\n- cfile->srch_inf.entries_in_buffer;\r\npos_in_buf = index_to_find - first_entry_in_buffer;\r\ncifs_dbg(FYI, "found entry - pos_in_buf %d\n", pos_in_buf);\r\nfor (i = 0; (i < (pos_in_buf)) && (cur_ent != NULL); i++) {\r\ncur_ent = nxt_dir_entry(cur_ent, end_of_smb,\r\ncfile->srch_inf.info_level);\r\n}\r\nif ((cur_ent == NULL) && (i < pos_in_buf)) {\r\ncifs_dbg(VFS, "reached end of buf searching for pos in buf %d index to find %lld rc %d\n",\r\npos_in_buf, index_to_find, rc);\r\n}\r\nrc = 0;\r\n*current_entry = cur_ent;\r\n} else {\r\ncifs_dbg(FYI, "index not in buffer - could not findnext into it\n");\r\nreturn 0;\r\n}\r\nif (pos_in_buf >= cfile->srch_inf.entries_in_buffer) {\r\ncifs_dbg(FYI, "can not return entries pos_in_buf beyond last\n");\r\n*num_to_ret = 0;\r\n} else\r\n*num_to_ret = cfile->srch_inf.entries_in_buffer - pos_in_buf;\r\nreturn rc;\r\n}\r\nstatic int cifs_filldir(char *find_entry, struct file *file,\r\nstruct dir_context *ctx,\r\nchar *scratch_buf, unsigned int max_len)\r\n{\r\nstruct cifsFileInfo *file_info = file->private_data;\r\nstruct super_block *sb = file->f_path.dentry->d_sb;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\r\nstruct cifs_dirent de = { NULL, };\r\nstruct cifs_fattr fattr;\r\nstruct qstr name;\r\nint rc = 0;\r\nino_t ino;\r\nrc = cifs_fill_dirent(&de, find_entry, file_info->srch_inf.info_level,\r\nfile_info->srch_inf.unicode);\r\nif (rc)\r\nreturn rc;\r\nif (de.namelen > max_len) {\r\ncifs_dbg(VFS, "bad search response length %zd past smb end\n",\r\nde.namelen);\r\nreturn -EINVAL;\r\n}\r\nif (cifs_entry_is_dot(&de, file_info->srch_inf.unicode))\r\nreturn 0;\r\nif (file_info->srch_inf.unicode) {\r\nstruct nls_table *nlt = cifs_sb->local_nls;\r\nname.name = scratch_buf;\r\nname.len =\r\ncifs_from_utf16((char *)name.name, (__le16 *)de.name,\r\nUNICODE_NAME_MAX,\r\nmin_t(size_t, de.namelen,\r\n(size_t)max_len), nlt,\r\ncifs_sb->mnt_cifs_flags &\r\nCIFS_MOUNT_MAP_SPECIAL_CHR);\r\nname.len -= nls_nullsize(nlt);\r\n} else {\r\nname.name = de.name;\r\nname.len = de.namelen;\r\n}\r\nswitch (file_info->srch_inf.info_level) {\r\ncase SMB_FIND_FILE_UNIX:\r\ncifs_unix_basic_to_fattr(&fattr,\r\n&((FILE_UNIX_INFO *)find_entry)->basic,\r\ncifs_sb);\r\nbreak;\r\ncase SMB_FIND_FILE_INFO_STANDARD:\r\ncifs_std_info_to_fattr(&fattr,\r\n(FIND_FILE_STANDARD_INFO *)find_entry,\r\ncifs_sb);\r\nbreak;\r\ndefault:\r\ncifs_dir_info_to_fattr(&fattr,\r\n(FILE_DIRECTORY_INFO *)find_entry,\r\ncifs_sb);\r\nbreak;\r\n}\r\nif (de.ino && (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\r\nfattr.cf_uniqueid = de.ino;\r\n} else {\r\nfattr.cf_uniqueid = iunique(sb, ROOT_I);\r\ncifs_autodisable_serverino(cifs_sb);\r\n}\r\nif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) &&\r\ncouldbe_mf_symlink(&fattr))\r\nfattr.cf_flags |= CIFS_FATTR_NEED_REVAL;\r\ncifs_prime_dcache(file->f_dentry, &name, &fattr);\r\nino = cifs_uniqueid_to_ino_t(fattr.cf_uniqueid);\r\nreturn !dir_emit(ctx, name.name, name.len, ino, fattr.cf_dtype);\r\n}\r\nint cifs_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\nint rc = 0;\r\nunsigned int xid;\r\nint i;\r\nstruct cifs_tcon *tcon;\r\nstruct cifsFileInfo *cifsFile = NULL;\r\nchar *current_entry;\r\nint num_to_fill = 0;\r\nchar *tmp_buf = NULL;\r\nchar *end_of_smb;\r\nunsigned int max_len;\r\nxid = get_xid();\r\nif (file->private_data == NULL) {\r\nrc = initiate_cifs_search(xid, file);\r\ncifs_dbg(FYI, "initiate cifs search rc %d\n", rc);\r\nif (rc)\r\ngoto rddir2_exit;\r\n}\r\nif (!dir_emit_dots(file, ctx))\r\ngoto rddir2_exit;\r\nif (file->private_data == NULL) {\r\nrc = -EINVAL;\r\ngoto rddir2_exit;\r\n}\r\ncifsFile = file->private_data;\r\nif (cifsFile->srch_inf.endOfSearch) {\r\nif (cifsFile->srch_inf.emptyDir) {\r\ncifs_dbg(FYI, "End of search, empty dir\n");\r\nrc = 0;\r\ngoto rddir2_exit;\r\n}\r\n}\r\ntcon = tlink_tcon(cifsFile->tlink);\r\nrc = find_cifs_entry(xid, tcon, ctx->pos, file, &current_entry,\r\n&num_to_fill);\r\nif (rc) {\r\ncifs_dbg(FYI, "fce error %d\n", rc);\r\ngoto rddir2_exit;\r\n} else if (current_entry != NULL) {\r\ncifs_dbg(FYI, "entry %lld found\n", ctx->pos);\r\n} else {\r\ncifs_dbg(FYI, "could not find entry\n");\r\ngoto rddir2_exit;\r\n}\r\ncifs_dbg(FYI, "loop through %d times filling dir for net buf %p\n",\r\nnum_to_fill, cifsFile->srch_inf.ntwrk_buf_start);\r\nmax_len = tcon->ses->server->ops->calc_smb_size(\r\ncifsFile->srch_inf.ntwrk_buf_start);\r\nend_of_smb = cifsFile->srch_inf.ntwrk_buf_start + max_len;\r\ntmp_buf = kmalloc(UNICODE_NAME_MAX, GFP_KERNEL);\r\nif (tmp_buf == NULL) {\r\nrc = -ENOMEM;\r\ngoto rddir2_exit;\r\n}\r\nfor (i = 0; i < num_to_fill; i++) {\r\nif (current_entry == NULL) {\r\ncifs_dbg(VFS, "past SMB end, num to fill %d i %d\n",\r\nnum_to_fill, i);\r\nbreak;\r\n}\r\nrc = cifs_filldir(current_entry, file, ctx,\r\ntmp_buf, max_len);\r\nif (rc) {\r\nif (rc > 0)\r\nrc = 0;\r\nbreak;\r\n}\r\nctx->pos++;\r\nif (ctx->pos ==\r\ncifsFile->srch_inf.index_of_last_entry) {\r\ncifs_dbg(FYI, "last entry in buf at pos %lld %s\n",\r\nctx->pos, tmp_buf);\r\ncifs_save_resume_key(current_entry, cifsFile);\r\nbreak;\r\n} else\r\ncurrent_entry =\r\nnxt_dir_entry(current_entry, end_of_smb,\r\ncifsFile->srch_inf.info_level);\r\n}\r\nkfree(tmp_buf);\r\nrddir2_exit:\r\nfree_xid(xid);\r\nreturn rc;\r\n}
