static void ab8500_power_off(void)\r\n{\r\nsigset_t old;\r\nsigset_t all;\r\nstatic char *pss[] = {"ab8500_ac", "pm2301", "ab8500_usb"};\r\nint i;\r\nbool charger_present = false;\r\nunion power_supply_propval val;\r\nstruct power_supply *psy;\r\nint ret;\r\nif (sysctrl_dev == NULL) {\r\npr_err("%s: sysctrl not initialized\n", __func__);\r\nreturn;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pss); i++) {\r\npsy = power_supply_get_by_name(pss[i]);\r\nif (!psy)\r\ncontinue;\r\nret = psy->get_property(psy, POWER_SUPPLY_PROP_ONLINE, &val);\r\nif (!ret && val.intval) {\r\ncharger_present = true;\r\nbreak;\r\n}\r\n}\r\nif (!charger_present)\r\ngoto shutdown;\r\npsy = power_supply_get_by_name("ab8500_btemp");\r\nif (psy) {\r\nret = psy->get_property(psy, POWER_SUPPLY_PROP_TECHNOLOGY,\r\n&val);\r\nif (!ret && val.intval != POWER_SUPPLY_TECHNOLOGY_UNKNOWN) {\r\nprintk(KERN_INFO\r\n"Charger \"%s\" is connected with known battery."\r\n" Rebooting.\n",\r\npss[i]);\r\nmachine_restart("charging");\r\n}\r\n}\r\nshutdown:\r\nsigfillset(&all);\r\nif (!sigprocmask(SIG_BLOCK, &all, &old)) {\r\n(void)ab8500_sysctrl_set(AB8500_STW4500CTRL1,\r\nAB8500_STW4500CTRL1_SWOFF |\r\nAB8500_STW4500CTRL1_SWRESET4500N);\r\n(void)sigprocmask(SIG_SETMASK, &old, NULL);\r\n}\r\n}\r\nvoid ab8500_restart(char mode, const char *cmd)\r\n{\r\nstruct ab8500_platform_data *plat;\r\nstruct ab8500_sysctrl_platform_data *pdata;\r\nu16 reason = 0;\r\nu8 val;\r\nif (sysctrl_dev == NULL) {\r\npr_err("%s: sysctrl not initialized\n", __func__);\r\nreturn;\r\n}\r\nplat = dev_get_platdata(sysctrl_dev->parent);\r\npdata = plat->sysctrl;\r\nif (pdata && pdata->reboot_reason_code)\r\nreason = pdata->reboot_reason_code(cmd);\r\nelse\r\npr_warn("[%s] No reboot reason set. Default reason %d\n",\r\n__func__, reason);\r\nabx500_get_register_interruptible(sysctrl_dev, AB8500_RTC,\r\nRTC_CTRL , &val);\r\nabx500_set_register_interruptible(sysctrl_dev, AB8500_RTC,\r\nRTC_CTRL , (val & ~RTC_ALARM_ENABLE));\r\nval = reason & 0xFF;\r\nabx500_set_register_interruptible(sysctrl_dev, AB8500_RTC,\r\nAB8500_ALARM_MIN_LOW , val);\r\nval = (reason>>8) & 0xFF;\r\nabx500_set_register_interruptible(sysctrl_dev, AB8500_RTC,\r\nAB8500_ALARM_MIN_MID , val);\r\nab8500_sysctrl_write(AB8500_MAINWDOGTIMER, 0xFF, 0x0);\r\nab8500_sysctrl_write(AB8500_MAINWDOGCTRL, 0xFF, (AB8500_ENABLE_WD |\r\nAB8500_WD_RESTART_ON_EXPIRE | AB8500_KICK_WD));\r\n}\r\nstatic inline bool valid_bank(u8 bank)\r\n{\r\nreturn ((bank == AB8500_SYS_CTRL1_BLOCK) ||\r\n(bank == AB8500_SYS_CTRL2_BLOCK));\r\n}\r\nint ab8500_sysctrl_read(u16 reg, u8 *value)\r\n{\r\nu8 bank;\r\nif (sysctrl_dev == NULL)\r\nreturn -EINVAL;\r\nbank = (reg >> 8);\r\nif (!valid_bank(bank))\r\nreturn -EINVAL;\r\nreturn abx500_get_register_interruptible(sysctrl_dev, bank,\r\n(u8)(reg & 0xFF), value);\r\n}\r\nint ab8500_sysctrl_write(u16 reg, u8 mask, u8 value)\r\n{\r\nu8 bank;\r\nif (sysctrl_dev == NULL)\r\nreturn -EINVAL;\r\nbank = (reg >> 8);\r\nif (!valid_bank(bank))\r\nreturn -EINVAL;\r\nreturn abx500_mask_and_set_register_interruptible(sysctrl_dev, bank,\r\n(u8)(reg & 0xFF), mask, value);\r\n}\r\nstatic int ab8500_sysctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct ab8500 *ab8500 = dev_get_drvdata(pdev->dev.parent);\r\nstruct ab8500_platform_data *plat;\r\nstruct ab8500_sysctrl_platform_data *pdata;\r\nplat = dev_get_platdata(pdev->dev.parent);\r\nif (!plat)\r\nreturn -EINVAL;\r\nsysctrl_dev = &pdev->dev;\r\nif (!pm_power_off)\r\npm_power_off = ab8500_power_off;\r\npdata = plat->sysctrl;\r\nif (pdata) {\r\nint last, ret, i, j;\r\nif (is_ab8505(ab8500))\r\nlast = AB8500_SYSCLKREQ4RFCLKBUF;\r\nelse\r\nlast = AB8500_SYSCLKREQ8RFCLKBUF;\r\nfor (i = AB8500_SYSCLKREQ1RFCLKBUF; i <= last; i++) {\r\nj = i - AB8500_SYSCLKREQ1RFCLKBUF;\r\nret = ab8500_sysctrl_write(i, 0xff,\r\npdata->initial_req_buf_config[j]);\r\ndev_dbg(&pdev->dev,\r\n"Setting SysClkReq%dRfClkBuf 0x%X\n",\r\nj + 1,\r\npdata->initial_req_buf_config[j]);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"unable to set sysClkReq%dRfClkBuf: "\r\n"%d\n", j + 1, ret);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ab8500_sysctrl_remove(struct platform_device *pdev)\r\n{\r\nsysctrl_dev = NULL;\r\nif (pm_power_off == ab8500_power_off)\r\npm_power_off = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init ab8500_sysctrl_init(void)\r\n{\r\nreturn platform_driver_register(&ab8500_sysctrl_driver);\r\n}
