__u64 gss_get_next_ctx_index(void)\r\n{\r\n__u64 idx;\r\nspin_lock(&__ctx_index_lock);\r\nidx = __ctx_index++;\r\nspin_unlock(&__ctx_index_lock);\r\nreturn idx;\r\n}\r\nstatic inline unsigned long hash_mem(char *buf, int length, int bits)\r\n{\r\nunsigned long hash = 0;\r\nunsigned long l = 0;\r\nint len = 0;\r\nunsigned char c;\r\ndo {\r\nif (len == length) {\r\nc = (char) len;\r\nlen = -1;\r\n} else\r\nc = *buf++;\r\nl = (l << 8) | c;\r\nlen++;\r\nif ((len & (BITS_PER_LONG/8-1)) == 0)\r\nhash = hash_long(hash^l, BITS_PER_LONG);\r\n} while (len);\r\nreturn hash >> (BITS_PER_LONG - bits);\r\n}\r\nstatic inline int rsi_hash(struct rsi *item)\r\n{\r\nreturn hash_mem((char *)item->in_handle.data, item->in_handle.len,\r\nRSI_HASHBITS) ^\r\nhash_mem((char *)item->in_token.data, item->in_token.len,\r\nRSI_HASHBITS);\r\n}\r\nstatic inline int __rsi_match(struct rsi *item, struct rsi *tmp)\r\n{\r\nreturn (rawobj_equal(&item->in_handle, &tmp->in_handle) &&\r\nrawobj_equal(&item->in_token, &tmp->in_token));\r\n}\r\nstatic void rsi_free(struct rsi *rsi)\r\n{\r\nrawobj_free(&rsi->in_handle);\r\nrawobj_free(&rsi->in_token);\r\nrawobj_free(&rsi->out_handle);\r\nrawobj_free(&rsi->out_token);\r\n}\r\nstatic void rsi_request(struct cache_detail *cd,\r\nstruct cache_head *h,\r\nchar **bpp, int *blen)\r\n{\r\nstruct rsi *rsi = container_of(h, struct rsi, h);\r\n__u64 index = 0;\r\nif (rsi->in_handle.len == 0)\r\nindex = gss_get_next_ctx_index();\r\nqword_addhex(bpp, blen, (char *) &rsi->lustre_svc,\r\nsizeof(rsi->lustre_svc));\r\nqword_addhex(bpp, blen, (char *) &rsi->nid, sizeof(rsi->nid));\r\nqword_addhex(bpp, blen, (char *) &index, sizeof(index));\r\nqword_addhex(bpp, blen, rsi->in_handle.data, rsi->in_handle.len);\r\nqword_addhex(bpp, blen, rsi->in_token.data, rsi->in_token.len);\r\n(*bpp)[-1] = '\n';\r\n}\r\nstatic int rsi_upcall(struct cache_detail *cd, struct cache_head *h)\r\n{\r\nreturn sunrpc_cache_pipe_upcall(cd, h, rsi_request);\r\n}\r\nstatic inline void __rsi_init(struct rsi *new, struct rsi *item)\r\n{\r\nnew->out_handle = RAWOBJ_EMPTY;\r\nnew->out_token = RAWOBJ_EMPTY;\r\nnew->in_handle = item->in_handle;\r\nitem->in_handle = RAWOBJ_EMPTY;\r\nnew->in_token = item->in_token;\r\nitem->in_token = RAWOBJ_EMPTY;\r\nnew->lustre_svc = item->lustre_svc;\r\nnew->nid = item->nid;\r\ninit_waitqueue_head(&new->waitq);\r\n}\r\nstatic inline void __rsi_update(struct rsi *new, struct rsi *item)\r\n{\r\nLASSERT(new->out_handle.len == 0);\r\nLASSERT(new->out_token.len == 0);\r\nnew->out_handle = item->out_handle;\r\nitem->out_handle = RAWOBJ_EMPTY;\r\nnew->out_token = item->out_token;\r\nitem->out_token = RAWOBJ_EMPTY;\r\nnew->major_status = item->major_status;\r\nnew->minor_status = item->minor_status;\r\n}\r\nstatic void rsi_put(struct kref *ref)\r\n{\r\nstruct rsi *rsi = container_of(ref, struct rsi, h.ref);\r\nLASSERT(rsi->h.next == NULL);\r\nrsi_free(rsi);\r\nOBD_FREE_PTR(rsi);\r\n}\r\nstatic int rsi_match(struct cache_head *a, struct cache_head *b)\r\n{\r\nstruct rsi *item = container_of(a, struct rsi, h);\r\nstruct rsi *tmp = container_of(b, struct rsi, h);\r\nreturn __rsi_match(item, tmp);\r\n}\r\nstatic void rsi_init(struct cache_head *cnew, struct cache_head *citem)\r\n{\r\nstruct rsi *new = container_of(cnew, struct rsi, h);\r\nstruct rsi *item = container_of(citem, struct rsi, h);\r\n__rsi_init(new, item);\r\n}\r\nstatic void update_rsi(struct cache_head *cnew, struct cache_head *citem)\r\n{\r\nstruct rsi *new = container_of(cnew, struct rsi, h);\r\nstruct rsi *item = container_of(citem, struct rsi, h);\r\n__rsi_update(new, item);\r\n}\r\nstatic struct cache_head *rsi_alloc(void)\r\n{\r\nstruct rsi *rsi;\r\nOBD_ALLOC_PTR(rsi);\r\nif (rsi)\r\nreturn &rsi->h;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic int rsi_parse(struct cache_detail *cd, char *mesg, int mlen)\r\n{\r\nchar *buf = mesg;\r\nchar *ep;\r\nint len;\r\nstruct rsi rsii, *rsip = NULL;\r\ntime_t expiry;\r\nint status = -EINVAL;\r\nmemset(&rsii, 0, sizeof(rsii));\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len < 0)\r\ngoto out;\r\nif (rawobj_alloc(&rsii.in_handle, buf, len)) {\r\nstatus = -ENOMEM;\r\ngoto out;\r\n}\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len < 0)\r\ngoto out;\r\nif (rawobj_alloc(&rsii.in_token, buf, len)) {\r\nstatus = -ENOMEM;\r\ngoto out;\r\n}\r\nrsip = rsi_lookup(&rsii);\r\nif (!rsip)\r\ngoto out;\r\nrsii.h.flags = 0;\r\nexpiry = get_expiry(&mesg);\r\nif (expiry == 0)\r\ngoto out;\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len <= 0)\r\ngoto out;\r\nrsii.major_status = simple_strtol(buf, &ep, 10);\r\nif (*ep)\r\ngoto out;\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len <= 0)\r\ngoto out;\r\nrsii.minor_status = simple_strtol(buf, &ep, 10);\r\nif (*ep)\r\ngoto out;\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len < 0)\r\ngoto out;\r\nif (rawobj_alloc(&rsii.out_handle, buf, len)) {\r\nstatus = -ENOMEM;\r\ngoto out;\r\n}\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len < 0)\r\ngoto out;\r\nif (rawobj_alloc(&rsii.out_token, buf, len)) {\r\nstatus = -ENOMEM;\r\ngoto out;\r\n}\r\nrsii.h.expiry_time = expiry;\r\nrsip = rsi_update(&rsii, rsip);\r\nstatus = 0;\r\nout:\r\nrsi_free(&rsii);\r\nif (rsip) {\r\nwake_up_all(&rsip->waitq);\r\ncache_put(&rsip->h, &rsi_cache);\r\n} else {\r\nstatus = -ENOMEM;\r\n}\r\nif (status)\r\nCERROR("rsi parse error %d\n", status);\r\nreturn status;\r\n}\r\nstatic struct rsi *rsi_lookup(struct rsi *item)\r\n{\r\nstruct cache_head *ch;\r\nint hash = rsi_hash(item);\r\nch = sunrpc_cache_lookup(&rsi_cache, &item->h, hash);\r\nif (ch)\r\nreturn container_of(ch, struct rsi, h);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic struct rsi *rsi_update(struct rsi *new, struct rsi *old)\r\n{\r\nstruct cache_head *ch;\r\nint hash = rsi_hash(new);\r\nch = sunrpc_cache_update(&rsi_cache, &new->h, &old->h, hash);\r\nif (ch)\r\nreturn container_of(ch, struct rsi, h);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic void rsc_free(struct rsc *rsci)\r\n{\r\nrawobj_free(&rsci->handle);\r\nrawobj_free(&rsci->ctx.gsc_rvs_hdl);\r\nlgss_delete_sec_context(&rsci->ctx.gsc_mechctx);\r\n}\r\nstatic inline int rsc_hash(struct rsc *rsci)\r\n{\r\nreturn hash_mem((char *)rsci->handle.data,\r\nrsci->handle.len, RSC_HASHBITS);\r\n}\r\nstatic inline int __rsc_match(struct rsc *new, struct rsc *tmp)\r\n{\r\nreturn rawobj_equal(&new->handle, &tmp->handle);\r\n}\r\nstatic inline void __rsc_init(struct rsc *new, struct rsc *tmp)\r\n{\r\nnew->handle = tmp->handle;\r\ntmp->handle = RAWOBJ_EMPTY;\r\nnew->target = NULL;\r\nmemset(&new->ctx, 0, sizeof(new->ctx));\r\nnew->ctx.gsc_rvs_hdl = RAWOBJ_EMPTY;\r\n}\r\nstatic inline void __rsc_update(struct rsc *new, struct rsc *tmp)\r\n{\r\nnew->ctx = tmp->ctx;\r\ntmp->ctx.gsc_rvs_hdl = RAWOBJ_EMPTY;\r\ntmp->ctx.gsc_mechctx = NULL;\r\nmemset(&new->ctx.gsc_seqdata, 0, sizeof(new->ctx.gsc_seqdata));\r\nspin_lock_init(&new->ctx.gsc_seqdata.ssd_lock);\r\n}\r\nstatic void rsc_put(struct kref *ref)\r\n{\r\nstruct rsc *rsci = container_of(ref, struct rsc, h.ref);\r\nLASSERT(rsci->h.next == NULL);\r\nrsc_free(rsci);\r\nOBD_FREE_PTR(rsci);\r\n}\r\nstatic int rsc_match(struct cache_head *a, struct cache_head *b)\r\n{\r\nstruct rsc *new = container_of(a, struct rsc, h);\r\nstruct rsc *tmp = container_of(b, struct rsc, h);\r\nreturn __rsc_match(new, tmp);\r\n}\r\nstatic void rsc_init(struct cache_head *cnew, struct cache_head *ctmp)\r\n{\r\nstruct rsc *new = container_of(cnew, struct rsc, h);\r\nstruct rsc *tmp = container_of(ctmp, struct rsc, h);\r\n__rsc_init(new, tmp);\r\n}\r\nstatic void update_rsc(struct cache_head *cnew, struct cache_head *ctmp)\r\n{\r\nstruct rsc *new = container_of(cnew, struct rsc, h);\r\nstruct rsc *tmp = container_of(ctmp, struct rsc, h);\r\n__rsc_update(new, tmp);\r\n}\r\nstatic struct cache_head * rsc_alloc(void)\r\n{\r\nstruct rsc *rsc;\r\nOBD_ALLOC_PTR(rsc);\r\nif (rsc)\r\nreturn &rsc->h;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic int rsc_parse(struct cache_detail *cd, char *mesg, int mlen)\r\n{\r\nchar *buf = mesg;\r\nint len, rv, tmp_int;\r\nstruct rsc rsci, *rscp = NULL;\r\ntime_t expiry;\r\nint status = -EINVAL;\r\nstruct gss_api_mech *gm = NULL;\r\nmemset(&rsci, 0, sizeof(rsci));\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len < 0) goto out;\r\nstatus = -ENOMEM;\r\nif (rawobj_alloc(&rsci.handle, buf, len))\r\ngoto out;\r\nrsci.h.flags = 0;\r\nexpiry = get_expiry(&mesg);\r\nstatus = -EINVAL;\r\nif (expiry == 0)\r\ngoto out;\r\nrv = get_int(&mesg, &tmp_int);\r\nif (rv) {\r\nCERROR("fail to get remote flag\n");\r\ngoto out;\r\n}\r\nrsci.ctx.gsc_remote = (tmp_int != 0);\r\nrv = get_int(&mesg, &tmp_int);\r\nif (rv) {\r\nCERROR("fail to get oss user flag\n");\r\ngoto out;\r\n}\r\nrsci.ctx.gsc_usr_root = (tmp_int != 0);\r\nrv = get_int(&mesg, &tmp_int);\r\nif (rv) {\r\nCERROR("fail to get mds user flag\n");\r\ngoto out;\r\n}\r\nrsci.ctx.gsc_usr_mds = (tmp_int != 0);\r\nrv = get_int(&mesg, &tmp_int);\r\nif (rv) {\r\nCERROR("fail to get oss user flag\n");\r\ngoto out;\r\n}\r\nrsci.ctx.gsc_usr_oss = (tmp_int != 0);\r\nrv = get_int(&mesg, (int *) &rsci.ctx.gsc_mapped_uid);\r\nif (rv) {\r\nCERROR("fail to get mapped uid\n");\r\ngoto out;\r\n}\r\nrscp = rsc_lookup(&rsci);\r\nif (!rscp)\r\ngoto out;\r\nrv = get_int(&mesg, (int *) &rsci.ctx.gsc_uid);\r\nif (rv == -EINVAL)\r\ngoto out;\r\nif (rv == -ENOENT) {\r\nCERROR("NOENT? set rsc entry negative\n");\r\nset_bit(CACHE_NEGATIVE, &rsci.h.flags);\r\n} else {\r\nrawobj_t tmp_buf;\r\nunsigned long ctx_expiry;\r\nif (get_int(&mesg, (int *) &rsci.ctx.gsc_gid))\r\ngoto out;\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len < 0)\r\ngoto out;\r\ngm = lgss_name_to_mech(buf);\r\nstatus = -EOPNOTSUPP;\r\nif (!gm)\r\ngoto out;\r\nstatus = -EINVAL;\r\nlen = qword_get(&mesg, buf, mlen);\r\nif (len < 0)\r\ngoto out;\r\ntmp_buf.len = len;\r\ntmp_buf.data = (unsigned char *)buf;\r\nif (lgss_import_sec_context(&tmp_buf, gm,\r\n&rsci.ctx.gsc_mechctx))\r\ngoto out;\r\nif (lgss_inquire_context(rsci.ctx.gsc_mechctx, &ctx_expiry)) {\r\nCERROR("unable to get expire time, drop it\n");\r\ngoto out;\r\n}\r\nexpiry = (time_t) ctx_expiry;\r\n}\r\nrsci.h.expiry_time = expiry;\r\nrscp = rsc_update(&rsci, rscp);\r\nstatus = 0;\r\nout:\r\nif (gm)\r\nlgss_mech_put(gm);\r\nrsc_free(&rsci);\r\nif (rscp)\r\ncache_put(&rscp->h, &rsc_cache);\r\nelse\r\nstatus = -ENOMEM;\r\nif (status)\r\nCERROR("parse rsc error %d\n", status);\r\nreturn status;\r\n}\r\nstatic struct rsc *rsc_lookup(struct rsc *item)\r\n{\r\nstruct cache_head *ch;\r\nint hash = rsc_hash(item);\r\nch = sunrpc_cache_lookup(&rsc_cache, &item->h, hash);\r\nif (ch)\r\nreturn container_of(ch, struct rsc, h);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic struct rsc *rsc_update(struct rsc *new, struct rsc *old)\r\n{\r\nstruct cache_head *ch;\r\nint hash = rsc_hash(new);\r\nch = sunrpc_cache_update(&rsc_cache, &new->h, &old->h, hash);\r\nif (ch)\r\nreturn container_of(ch, struct rsc, h);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic void rsc_flush(rsc_entry_match *match, long data)\r\n{\r\nstruct cache_head **ch;\r\nstruct rsc *rscp;\r\nint n;\r\nwrite_lock(&rsc_cache.hash_lock);\r\nfor (n = 0; n < RSC_HASHMAX; n++) {\r\nfor (ch = &rsc_cache.hash_table[n]; *ch;) {\r\nrscp = container_of(*ch, struct rsc, h);\r\nif (!match(rscp, data)) {\r\nch = &((*ch)->next);\r\ncontinue;\r\n}\r\n*ch = (*ch)->next;\r\nrscp->h.next = NULL;\r\ncache_get(&rscp->h);\r\nset_bit(CACHE_NEGATIVE, &rscp->h.flags);\r\nCOMPAT_RSC_PUT(&rscp->h, &rsc_cache);\r\nrsc_cache.entries--;\r\n}\r\n}\r\nwrite_unlock(&rsc_cache.hash_lock);\r\n}\r\nstatic int match_uid(struct rsc *rscp, long uid)\r\n{\r\nif ((int) uid == -1)\r\nreturn 1;\r\nreturn ((int) rscp->ctx.gsc_uid == (int) uid);\r\n}\r\nstatic int match_target(struct rsc *rscp, long target)\r\n{\r\nreturn (rscp->target == (struct obd_device *) target);\r\n}\r\nstatic inline void rsc_flush_uid(int uid)\r\n{\r\nif (uid == -1)\r\nCWARN("flush all gss contexts...\n");\r\nrsc_flush(match_uid, (long) uid);\r\n}\r\nstatic inline void rsc_flush_target(struct obd_device *target)\r\n{\r\nrsc_flush(match_target, (long) target);\r\n}\r\nvoid gss_secsvc_flush(struct obd_device *target)\r\n{\r\nrsc_flush_target(target);\r\n}\r\nstatic struct rsc *gss_svc_searchbyctx(rawobj_t *handle)\r\n{\r\nstruct rsc rsci;\r\nstruct rsc *found;\r\nmemset(&rsci, 0, sizeof(rsci));\r\nif (rawobj_dup(&rsci.handle, handle))\r\nreturn NULL;\r\nfound = rsc_lookup(&rsci);\r\nrsc_free(&rsci);\r\nif (!found)\r\nreturn NULL;\r\nif (cache_check(&rsc_cache, &found->h, NULL))\r\nreturn NULL;\r\nreturn found;\r\n}\r\nint gss_svc_upcall_install_rvs_ctx(struct obd_import *imp,\r\nstruct gss_sec *gsec,\r\nstruct gss_cli_ctx *gctx)\r\n{\r\nstruct rsc rsci, *rscp = NULL;\r\nunsigned long ctx_expiry;\r\n__u32 major;\r\nint rc;\r\nmemset(&rsci, 0, sizeof(rsci));\r\nif (rawobj_alloc(&rsci.handle, (char *) &gsec->gs_rvs_hdl,\r\nsizeof(gsec->gs_rvs_hdl)))\r\nGOTO(out, rc = -ENOMEM);\r\nrscp = rsc_lookup(&rsci);\r\nif (rscp == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nmajor = lgss_copy_reverse_context(gctx->gc_mechctx,\r\n&rsci.ctx.gsc_mechctx);\r\nif (major != GSS_S_COMPLETE)\r\nGOTO(out, rc = -ENOMEM);\r\nif (lgss_inquire_context(rsci.ctx.gsc_mechctx, &ctx_expiry)) {\r\nCERROR("unable to get expire time, drop it\n");\r\nGOTO(out, rc = -EINVAL);\r\n}\r\nrsci.h.expiry_time = (time_t) ctx_expiry;\r\nif (strcmp(imp->imp_obd->obd_type->typ_name, LUSTRE_MDC_NAME) == 0)\r\nrsci.ctx.gsc_usr_mds = 1;\r\nelse if (strcmp(imp->imp_obd->obd_type->typ_name, LUSTRE_OSC_NAME) == 0)\r\nrsci.ctx.gsc_usr_oss = 1;\r\nelse\r\nrsci.ctx.gsc_usr_root = 1;\r\nrscp = rsc_update(&rsci, rscp);\r\nif (rscp == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nrscp->target = imp->imp_obd;\r\nrawobj_dup(&gctx->gc_svc_handle, &rscp->handle);\r\nCWARN("create reverse svc ctx %p to %s: idx "LPX64"\n",\r\n&rscp->ctx, obd2cli_tgt(imp->imp_obd), gsec->gs_rvs_hdl);\r\nrc = 0;\r\nout:\r\nif (rscp)\r\ncache_put(&rscp->h, &rsc_cache);\r\nrsc_free(&rsci);\r\nif (rc)\r\nCERROR("create reverse svc ctx: idx "LPX64", rc %d\n",\r\ngsec->gs_rvs_hdl, rc);\r\nreturn rc;\r\n}\r\nint gss_svc_upcall_expire_rvs_ctx(rawobj_t *handle)\r\n{\r\nconst cfs_time_t expire = 20;\r\nstruct rsc *rscp;\r\nrscp = gss_svc_searchbyctx(handle);\r\nif (rscp) {\r\nCDEBUG(D_SEC, "reverse svcctx %p (rsc %p) expire soon\n",\r\n&rscp->ctx, rscp);\r\nrscp->h.expiry_time = cfs_time_current_sec() + expire;\r\nCOMPAT_RSC_PUT(&rscp->h, &rsc_cache);\r\n}\r\nreturn 0;\r\n}\r\nint gss_svc_upcall_dup_handle(rawobj_t *handle, struct gss_svc_ctx *ctx)\r\n{\r\nstruct rsc *rscp = container_of(ctx, struct rsc, ctx);\r\nreturn rawobj_dup(handle, &rscp->handle);\r\n}\r\nint gss_svc_upcall_update_sequence(rawobj_t *handle, __u32 seq)\r\n{\r\nstruct rsc *rscp;\r\nrscp = gss_svc_searchbyctx(handle);\r\nif (rscp) {\r\nCDEBUG(D_SEC, "reverse svcctx %p (rsc %p) update seq to %u\n",\r\n&rscp->ctx, rscp, seq + 1);\r\nrscp->ctx.gsc_rvs_seq = seq + 1;\r\nCOMPAT_RSC_PUT(&rscp->h, &rsc_cache);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct cache_deferred_req* cache_upcall_defer(struct cache_req *req)\r\n{\r\nreturn NULL;\r\n}\r\nint gss_svc_upcall_handle_init(struct ptlrpc_request *req,\r\nstruct gss_svc_reqctx *grctx,\r\nstruct gss_wire_ctx *gw,\r\nstruct obd_device *target,\r\n__u32 lustre_svc,\r\nrawobj_t *rvs_hdl,\r\nrawobj_t *in_token)\r\n{\r\nstruct ptlrpc_reply_state *rs;\r\nstruct rsc *rsci = NULL;\r\nstruct rsi *rsip = NULL, rsikey;\r\nwait_queue_t wait;\r\nint replen = sizeof(struct ptlrpc_body);\r\nstruct gss_rep_header *rephdr;\r\nint first_check = 1;\r\nint rc = SECSVC_DROP;\r\nmemset(&rsikey, 0, sizeof(rsikey));\r\nrsikey.lustre_svc = lustre_svc;\r\nrsikey.nid = (__u64) req->rq_peer.nid;\r\nif (rawobj_dup(&rsikey.in_handle, &gw->gw_handle)) {\r\nCERROR("fail to dup context handle\n");\r\nGOTO(out, rc);\r\n}\r\nif (rawobj_dup(&rsikey.in_token, in_token)) {\r\nCERROR("can't duplicate token\n");\r\nrawobj_free(&rsikey.in_handle);\r\nGOTO(out, rc);\r\n}\r\nrsip = rsi_lookup(&rsikey);\r\nrsi_free(&rsikey);\r\nif (!rsip) {\r\nCERROR("error in rsi_lookup.\n");\r\nif (!gss_pack_err_notify(req, GSS_S_FAILURE, 0))\r\nrc = SECSVC_COMPLETE;\r\nGOTO(out, rc);\r\n}\r\ncache_get(&rsip->h);\r\ninit_waitqueue_head(&rsip->waitq);\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&rsip->waitq, &wait);\r\ncache_check:\r\nrc = cache_check(&rsi_cache, &rsip->h, &cache_upcall_chandle);\r\nswitch (rc) {\r\ncase -EAGAIN: {\r\nint valid;\r\nif (first_check) {\r\nfirst_check = 0;\r\nread_lock(&rsi_cache.hash_lock);\r\nvalid = test_bit(CACHE_VALID, &rsip->h.flags);\r\nif (valid == 0)\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nread_unlock(&rsi_cache.hash_lock);\r\nif (valid == 0)\r\nschedule_timeout(GSS_SVC_UPCALL_TIMEOUT *\r\nHZ);\r\ncache_get(&rsip->h);\r\ngoto cache_check;\r\n}\r\nCWARN("waited %ds timeout, drop\n", GSS_SVC_UPCALL_TIMEOUT);\r\nbreak;\r\n}\r\ncase -ENOENT:\r\nCWARN("cache_check return ENOENT, drop\n");\r\nbreak;\r\ncase 0:\r\nif (!first_check)\r\ncache_put(&rsip->h, &rsi_cache);\r\nCDEBUG(D_SEC, "cache_check is good\n");\r\nbreak;\r\n}\r\nremove_wait_queue(&rsip->waitq, &wait);\r\ncache_put(&rsip->h, &rsi_cache);\r\nif (rc)\r\nGOTO(out, rc = SECSVC_DROP);\r\nrc = SECSVC_DROP;\r\nrsci = gss_svc_searchbyctx(&rsip->out_handle);\r\nif (!rsci) {\r\nCERROR("authentication failed\n");\r\nif (!gss_pack_err_notify(req, GSS_S_FAILURE, 0))\r\nrc = SECSVC_COMPLETE;\r\nGOTO(out, rc);\r\n} else {\r\ncache_get(&rsci->h);\r\ngrctx->src_ctx = &rsci->ctx;\r\n}\r\nif (rawobj_dup(&rsci->ctx.gsc_rvs_hdl, rvs_hdl)) {\r\nCERROR("failed duplicate reverse handle\n");\r\nGOTO(out, rc);\r\n}\r\nrsci->target = target;\r\nCDEBUG(D_SEC, "server create rsc %p(%u->%s)\n",\r\nrsci, rsci->ctx.gsc_uid, libcfs_nid2str(req->rq_peer.nid));\r\nif (rsip->out_handle.len > PTLRPC_GSS_MAX_HANDLE_SIZE) {\r\nCERROR("handle size %u too large\n", rsip->out_handle.len);\r\nGOTO(out, rc = SECSVC_DROP);\r\n}\r\ngrctx->src_init = 1;\r\ngrctx->src_reserve_len = cfs_size_round4(rsip->out_token.len);\r\nrc = lustre_pack_reply_v2(req, 1, &replen, NULL, 0);\r\nif (rc) {\r\nCERROR("failed to pack reply: %d\n", rc);\r\nGOTO(out, rc = SECSVC_DROP);\r\n}\r\nrs = req->rq_reply_state;\r\nLASSERT(rs->rs_repbuf->lm_bufcount == 3);\r\nLASSERT(rs->rs_repbuf->lm_buflens[0] >=\r\nsizeof(*rephdr) + rsip->out_handle.len);\r\nLASSERT(rs->rs_repbuf->lm_buflens[2] >= rsip->out_token.len);\r\nrephdr = lustre_msg_buf(rs->rs_repbuf, 0, 0);\r\nrephdr->gh_version = PTLRPC_GSS_VERSION;\r\nrephdr->gh_flags = 0;\r\nrephdr->gh_proc = PTLRPC_GSS_PROC_ERR;\r\nrephdr->gh_major = rsip->major_status;\r\nrephdr->gh_minor = rsip->minor_status;\r\nrephdr->gh_seqwin = GSS_SEQ_WIN;\r\nrephdr->gh_handle.len = rsip->out_handle.len;\r\nmemcpy(rephdr->gh_handle.data, rsip->out_handle.data,\r\nrsip->out_handle.len);\r\nmemcpy(lustre_msg_buf(rs->rs_repbuf, 2, 0), rsip->out_token.data,\r\nrsip->out_token.len);\r\nrs->rs_repdata_len = lustre_shrink_msg(rs->rs_repbuf, 2,\r\nrsip->out_token.len, 0);\r\nrc = SECSVC_OK;\r\nout:\r\n#if 0\r\nif (rsip)\r\nrsi_put(&rsip->h, &rsi_cache);\r\n#endif\r\nif (rsci) {\r\nif (rc != SECSVC_OK)\r\nset_bit(CACHE_NEGATIVE, &rsci->h.flags);\r\nelse\r\nCDEBUG(D_SEC, "create rsc with idx "LPX64"\n",\r\ngss_handle_to_u64(&rsci->handle));\r\nCOMPAT_RSC_PUT(&rsci->h, &rsc_cache);\r\n}\r\nreturn rc;\r\n}\r\nstruct gss_svc_ctx *gss_svc_upcall_get_ctx(struct ptlrpc_request *req,\r\nstruct gss_wire_ctx *gw)\r\n{\r\nstruct rsc *rsc;\r\nrsc = gss_svc_searchbyctx(&gw->gw_handle);\r\nif (!rsc) {\r\nCWARN("Invalid gss ctx idx "LPX64" from %s\n",\r\ngss_handle_to_u64(&gw->gw_handle),\r\nlibcfs_nid2str(req->rq_peer.nid));\r\nreturn NULL;\r\n}\r\nreturn &rsc->ctx;\r\n}\r\nvoid gss_svc_upcall_put_ctx(struct gss_svc_ctx *ctx)\r\n{\r\nstruct rsc *rsc = container_of(ctx, struct rsc, ctx);\r\nCOMPAT_RSC_PUT(&rsc->h, &rsc_cache);\r\n}\r\nvoid gss_svc_upcall_destroy_ctx(struct gss_svc_ctx *ctx)\r\n{\r\nstruct rsc *rsc = container_of(ctx, struct rsc, ctx);\r\nset_bit(CACHE_NEGATIVE, &rsc->h.flags);\r\nrsc->h.expiry_time = 1;\r\n}\r\nint __init gss_init_svc_upcall(void)\r\n{\r\nint i;\r\nspin_lock_init(&__ctx_index_lock);\r\ncfs_get_random_bytes(&__ctx_index, sizeof(__ctx_index));\r\ncache_register(&rsi_cache);\r\ncache_register(&rsc_cache);\r\nfor (i = 0; i < 6; i++) {\r\nif (atomic_read(&rsi_cache.readers) > 0)\r\nbreak;\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nLASSERT(HZ >= 4);\r\nschedule_timeout(HZ / 4);\r\n}\r\nif (atomic_read(&rsi_cache.readers) == 0)\r\nCWARN("Init channel is not opened by lsvcgssd, following "\r\n"request might be dropped until lsvcgssd is active\n");\r\nreturn 0;\r\n}\r\nvoid __exit gss_exit_svc_upcall(void)\r\n{\r\ncache_purge(&rsi_cache);\r\ncache_unregister(&rsi_cache);\r\ncache_purge(&rsc_cache);\r\ncache_unregister(&rsc_cache);\r\n}
