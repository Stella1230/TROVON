static inline void lov_sub_enter(struct lov_io_sub *sub)\r\n{\r\nsub->sub_reenter++;\r\n}\r\nstatic inline void lov_sub_exit(struct lov_io_sub *sub)\r\n{\r\nsub->sub_reenter--;\r\n}\r\nstatic void lov_io_sub_fini(const struct lu_env *env, struct lov_io *lio,\r\nstruct lov_io_sub *sub)\r\n{\r\nif (sub->sub_io != NULL) {\r\nif (sub->sub_io_initialized) {\r\nlov_sub_enter(sub);\r\ncl_io_fini(sub->sub_env, sub->sub_io);\r\nlov_sub_exit(sub);\r\nsub->sub_io_initialized = 0;\r\nlio->lis_active_subios--;\r\n}\r\nif (sub->sub_stripe == lio->lis_single_subio_index)\r\nlio->lis_single_subio_index = -1;\r\nelse if (!sub->sub_borrowed)\r\nOBD_FREE_PTR(sub->sub_io);\r\nsub->sub_io = NULL;\r\n}\r\nif (sub->sub_env != NULL && !IS_ERR(sub->sub_env)) {\r\nif (!sub->sub_borrowed)\r\ncl_env_put(sub->sub_env, &sub->sub_refcheck);\r\nsub->sub_env = NULL;\r\n}\r\n}\r\nstatic void lov_io_sub_inherit(struct cl_io *io, struct lov_io *lio,\r\nint stripe, loff_t start, loff_t end)\r\n{\r\nstruct lov_stripe_md *lsm = lio->lis_object->lo_lsm;\r\nstruct cl_io *parent = lio->lis_cl.cis_io;\r\nswitch (io->ci_type) {\r\ncase CIT_SETATTR: {\r\nio->u.ci_setattr.sa_attr = parent->u.ci_setattr.sa_attr;\r\nio->u.ci_setattr.sa_valid = parent->u.ci_setattr.sa_valid;\r\nio->u.ci_setattr.sa_capa = parent->u.ci_setattr.sa_capa;\r\nif (cl_io_is_trunc(io)) {\r\nloff_t new_size = parent->u.ci_setattr.sa_attr.lvb_size;\r\nnew_size = lov_size_to_stripe(lsm, new_size, stripe);\r\nio->u.ci_setattr.sa_attr.lvb_size = new_size;\r\n}\r\nbreak;\r\n}\r\ncase CIT_FAULT: {\r\nstruct cl_object *obj = parent->ci_obj;\r\nloff_t off = cl_offset(obj, parent->u.ci_fault.ft_index);\r\nio->u.ci_fault = parent->u.ci_fault;\r\noff = lov_size_to_stripe(lsm, off, stripe);\r\nio->u.ci_fault.ft_index = cl_index(obj, off);\r\nbreak;\r\n}\r\ncase CIT_FSYNC: {\r\nio->u.ci_fsync.fi_start = start;\r\nio->u.ci_fsync.fi_end = end;\r\nio->u.ci_fsync.fi_capa = parent->u.ci_fsync.fi_capa;\r\nio->u.ci_fsync.fi_fid = parent->u.ci_fsync.fi_fid;\r\nio->u.ci_fsync.fi_mode = parent->u.ci_fsync.fi_mode;\r\nbreak;\r\n}\r\ncase CIT_READ:\r\ncase CIT_WRITE: {\r\nio->u.ci_wr.wr_sync = cl_io_is_sync_write(parent);\r\nif (cl_io_is_append(parent)) {\r\nio->u.ci_wr.wr_append = 1;\r\n} else {\r\nio->u.ci_rw.crw_pos = start;\r\nio->u.ci_rw.crw_count = end - start;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int lov_io_sub_init(const struct lu_env *env, struct lov_io *lio,\r\nstruct lov_io_sub *sub)\r\n{\r\nstruct lov_object *lov = lio->lis_object;\r\nstruct lov_device *ld = lu2lov_dev(lov2cl(lov)->co_lu.lo_dev);\r\nstruct cl_io *sub_io;\r\nstruct cl_object *sub_obj;\r\nstruct cl_io *io = lio->lis_cl.cis_io;\r\nint stripe = sub->sub_stripe;\r\nint result;\r\nLASSERT(sub->sub_io == NULL);\r\nLASSERT(sub->sub_env == NULL);\r\nLASSERT(sub->sub_stripe < lio->lis_stripe_count);\r\nresult = 0;\r\nsub->sub_io_initialized = 0;\r\nsub->sub_borrowed = 0;\r\nif (lio->lis_mem_frozen) {\r\nLASSERT(mutex_is_locked(&ld->ld_mutex));\r\nsub->sub_io = &ld->ld_emrg[stripe]->emrg_subio;\r\nsub->sub_env = ld->ld_emrg[stripe]->emrg_env;\r\nsub->sub_borrowed = 1;\r\n} else {\r\nvoid *cookie;\r\ncookie = cl_env_reenter();\r\nsub->sub_env = cl_env_get(&sub->sub_refcheck);\r\ncl_env_reexit(cookie);\r\nif (IS_ERR(sub->sub_env))\r\nresult = PTR_ERR(sub->sub_env);\r\nif (result == 0) {\r\nif (lio->lis_active_subios == 0) {\r\nsub->sub_io = &lio->lis_single_subio;\r\nlio->lis_single_subio_index = stripe;\r\n} else {\r\nOBD_ALLOC_PTR(sub->sub_io);\r\nif (sub->sub_io == NULL)\r\nresult = -ENOMEM;\r\n}\r\n}\r\n}\r\nif (result == 0) {\r\nsub_obj = lovsub2cl(lov_r0(lov)->lo_sub[stripe]);\r\nsub_io = sub->sub_io;\r\nsub_io->ci_obj = sub_obj;\r\nsub_io->ci_result = 0;\r\nsub_io->ci_parent = io;\r\nsub_io->ci_lockreq = io->ci_lockreq;\r\nsub_io->ci_type = io->ci_type;\r\nsub_io->ci_no_srvlock = io->ci_no_srvlock;\r\nsub_io->ci_noatime = io->ci_noatime;\r\nlov_sub_enter(sub);\r\nresult = cl_io_sub_init(sub->sub_env, sub_io,\r\nio->ci_type, sub_obj);\r\nlov_sub_exit(sub);\r\nif (result >= 0) {\r\nlio->lis_active_subios++;\r\nsub->sub_io_initialized = 1;\r\nresult = 0;\r\n}\r\n}\r\nif (result != 0)\r\nlov_io_sub_fini(env, lio, sub);\r\nreturn result;\r\n}\r\nstruct lov_io_sub *lov_sub_get(const struct lu_env *env,\r\nstruct lov_io *lio, int stripe)\r\n{\r\nint rc;\r\nstruct lov_io_sub *sub = &lio->lis_subs[stripe];\r\nLASSERT(stripe < lio->lis_stripe_count);\r\nif (!sub->sub_io_initialized) {\r\nsub->sub_stripe = stripe;\r\nrc = lov_io_sub_init(env, lio, sub);\r\n} else\r\nrc = 0;\r\nif (rc == 0)\r\nlov_sub_enter(sub);\r\nelse\r\nsub = ERR_PTR(rc);\r\nreturn sub;\r\n}\r\nvoid lov_sub_put(struct lov_io_sub *sub)\r\n{\r\nlov_sub_exit(sub);\r\n}\r\nstatic int lov_page_stripe(const struct cl_page *page)\r\n{\r\nstruct lovsub_object *subobj;\r\nsubobj = lu2lovsub(\r\nlu_object_locate(page->cp_child->cp_obj->co_lu.lo_header,\r\n&lovsub_device_type));\r\nLASSERT(subobj != NULL);\r\nreturn subobj->lso_index;\r\n}\r\nstruct lov_io_sub *lov_page_subio(const struct lu_env *env, struct lov_io *lio,\r\nconst struct cl_page_slice *slice)\r\n{\r\nstruct lov_stripe_md *lsm = lio->lis_object->lo_lsm;\r\nstruct cl_page *page = slice->cpl_page;\r\nint stripe;\r\nLASSERT(lio->lis_cl.cis_io != NULL);\r\nLASSERT(cl2lov(slice->cpl_obj) == lio->lis_object);\r\nLASSERT(lsm != NULL);\r\nLASSERT(lio->lis_nr_subios > 0);\r\nstripe = lov_page_stripe(page);\r\nreturn lov_sub_get(env, lio, stripe);\r\n}\r\nstatic int lov_io_subio_init(const struct lu_env *env, struct lov_io *lio,\r\nstruct cl_io *io)\r\n{\r\nstruct lov_stripe_md *lsm = lio->lis_object->lo_lsm;\r\nint result;\r\nLASSERT(lio->lis_object != NULL);\r\nOBD_ALLOC_LARGE(lio->lis_subs,\r\nlsm->lsm_stripe_count * sizeof(lio->lis_subs[0]));\r\nif (lio->lis_subs != NULL) {\r\nlio->lis_nr_subios = lio->lis_stripe_count;\r\nlio->lis_single_subio_index = -1;\r\nlio->lis_active_subios = 0;\r\nresult = 0;\r\n} else\r\nresult = -ENOMEM;\r\nreturn result;\r\n}\r\nstatic void lov_io_slice_init(struct lov_io *lio,\r\nstruct lov_object *obj, struct cl_io *io)\r\n{\r\nio->ci_result = 0;\r\nlio->lis_object = obj;\r\nLASSERT(obj->lo_lsm != NULL);\r\nlio->lis_stripe_count = obj->lo_lsm->lsm_stripe_count;\r\nswitch (io->ci_type) {\r\ncase CIT_READ:\r\ncase CIT_WRITE:\r\nlio->lis_pos = io->u.ci_rw.crw_pos;\r\nlio->lis_endpos = io->u.ci_rw.crw_pos + io->u.ci_rw.crw_count;\r\nlio->lis_io_endpos = lio->lis_endpos;\r\nif (cl_io_is_append(io)) {\r\nLASSERT(io->ci_type == CIT_WRITE);\r\nlio->lis_pos = 0;\r\nlio->lis_endpos = OBD_OBJECT_EOF;\r\n}\r\nbreak;\r\ncase CIT_SETATTR:\r\nif (cl_io_is_trunc(io))\r\nlio->lis_pos = io->u.ci_setattr.sa_attr.lvb_size;\r\nelse\r\nlio->lis_pos = 0;\r\nlio->lis_endpos = OBD_OBJECT_EOF;\r\nbreak;\r\ncase CIT_FAULT: {\r\npgoff_t index = io->u.ci_fault.ft_index;\r\nlio->lis_pos = cl_offset(io->ci_obj, index);\r\nlio->lis_endpos = cl_offset(io->ci_obj, index + 1);\r\nbreak;\r\n}\r\ncase CIT_FSYNC: {\r\nlio->lis_pos = io->u.ci_fsync.fi_start;\r\nlio->lis_endpos = io->u.ci_fsync.fi_end;\r\nbreak;\r\n}\r\ncase CIT_MISC:\r\nlio->lis_pos = 0;\r\nlio->lis_endpos = OBD_OBJECT_EOF;\r\nbreak;\r\ndefault:\r\nLBUG();\r\n}\r\n}\r\nstatic void lov_io_fini(const struct lu_env *env, const struct cl_io_slice *ios)\r\n{\r\nstruct lov_io *lio = cl2lov_io(env, ios);\r\nstruct lov_object *lov = cl2lov(ios->cis_obj);\r\nint i;\r\nif (lio->lis_subs != NULL) {\r\nfor (i = 0; i < lio->lis_nr_subios; i++)\r\nlov_io_sub_fini(env, lio, &lio->lis_subs[i]);\r\nOBD_FREE_LARGE(lio->lis_subs,\r\nlio->lis_nr_subios * sizeof(lio->lis_subs[0]));\r\nlio->lis_nr_subios = 0;\r\n}\r\nLASSERT(atomic_read(&lov->lo_active_ios) > 0);\r\nif (atomic_dec_and_test(&lov->lo_active_ios))\r\nwake_up_all(&lov->lo_waitq);\r\n}\r\nstatic obd_off lov_offset_mod(obd_off val, int delta)\r\n{\r\nif (val != OBD_OBJECT_EOF)\r\nval += delta;\r\nreturn val;\r\n}\r\nstatic int lov_io_iter_init(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct lov_io *lio = cl2lov_io(env, ios);\r\nstruct lov_stripe_md *lsm = lio->lis_object->lo_lsm;\r\nstruct lov_io_sub *sub;\r\nobd_off endpos;\r\nobd_off start;\r\nobd_off end;\r\nint stripe;\r\nint rc = 0;\r\nendpos = lov_offset_mod(lio->lis_endpos, -1);\r\nfor (stripe = 0; stripe < lio->lis_stripe_count; stripe++) {\r\nif (!lov_stripe_intersects(lsm, stripe, lio->lis_pos,\r\nendpos, &start, &end))\r\ncontinue;\r\nend = lov_offset_mod(end, +1);\r\nsub = lov_sub_get(env, lio, stripe);\r\nif (!IS_ERR(sub)) {\r\nlov_io_sub_inherit(sub->sub_io, lio, stripe,\r\nstart, end);\r\nrc = cl_io_iter_init(sub->sub_env, sub->sub_io);\r\nlov_sub_put(sub);\r\nCDEBUG(D_VFSTRACE, "shrink: %d ["LPU64", "LPU64")\n",\r\nstripe, start, end);\r\n} else\r\nrc = PTR_ERR(sub);\r\nif (!rc)\r\nlist_add_tail(&sub->sub_linkage, &lio->lis_active);\r\nelse\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int lov_io_rw_iter_init(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct lov_io *lio = cl2lov_io(env, ios);\r\nstruct cl_io *io = ios->cis_io;\r\nstruct lov_stripe_md *lsm = lio->lis_object->lo_lsm;\r\n__u64 start = io->u.ci_rw.crw_pos;\r\nloff_t next;\r\nunsigned long ssize = lsm->lsm_stripe_size;\r\nLASSERT(io->ci_type == CIT_READ || io->ci_type == CIT_WRITE);\r\nif (lio->lis_nr_subios != 1 && !cl_io_is_append(io)) {\r\nlov_do_div64(start, ssize);\r\nnext = (start + 1) * ssize;\r\nif (next <= start * ssize)\r\nnext = ~0ull;\r\nio->ci_continue = next < lio->lis_io_endpos;\r\nio->u.ci_rw.crw_count = min_t(loff_t, lio->lis_io_endpos,\r\nnext) - io->u.ci_rw.crw_pos;\r\nlio->lis_pos = io->u.ci_rw.crw_pos;\r\nlio->lis_endpos = io->u.ci_rw.crw_pos + io->u.ci_rw.crw_count;\r\nCDEBUG(D_VFSTRACE, "stripe: "LPU64" chunk: ["LPU64", "LPU64") "\r\nLPU64"\n", (__u64)start, lio->lis_pos, lio->lis_endpos,\r\n(__u64)lio->lis_io_endpos);\r\n}\r\nreturn lov_io_iter_init(env, ios);\r\n}\r\nstatic int lov_io_call(const struct lu_env *env, struct lov_io *lio,\r\nint (*iofunc)(const struct lu_env *, struct cl_io *))\r\n{\r\nstruct cl_io *parent = lio->lis_cl.cis_io;\r\nstruct lov_io_sub *sub;\r\nint rc = 0;\r\nlist_for_each_entry(sub, &lio->lis_active, sub_linkage) {\r\nlov_sub_enter(sub);\r\nrc = iofunc(sub->sub_env, sub->sub_io);\r\nlov_sub_exit(sub);\r\nif (rc)\r\nbreak;\r\nif (parent->ci_result == 0)\r\nparent->ci_result = sub->sub_io->ci_result;\r\n}\r\nreturn rc;\r\n}\r\nstatic int lov_io_lock(const struct lu_env *env, const struct cl_io_slice *ios)\r\n{\r\nreturn lov_io_call(env, cl2lov_io(env, ios), cl_io_lock);\r\n}\r\nstatic int lov_io_start(const struct lu_env *env, const struct cl_io_slice *ios)\r\n{\r\nreturn lov_io_call(env, cl2lov_io(env, ios), cl_io_start);\r\n}\r\nstatic int lov_io_end_wrapper(const struct lu_env *env, struct cl_io *io)\r\n{\r\nif (io->ci_state == CIS_IO_GOING)\r\ncl_io_end(env, io);\r\nelse\r\nio->ci_state = CIS_IO_FINISHED;\r\nreturn 0;\r\n}\r\nstatic int lov_io_iter_fini_wrapper(const struct lu_env *env, struct cl_io *io)\r\n{\r\ncl_io_iter_fini(env, io);\r\nreturn 0;\r\n}\r\nstatic int lov_io_unlock_wrapper(const struct lu_env *env, struct cl_io *io)\r\n{\r\ncl_io_unlock(env, io);\r\nreturn 0;\r\n}\r\nstatic void lov_io_end(const struct lu_env *env, const struct cl_io_slice *ios)\r\n{\r\nint rc;\r\nrc = lov_io_call(env, cl2lov_io(env, ios), lov_io_end_wrapper);\r\nLASSERT(rc == 0);\r\n}\r\nstatic void lov_io_iter_fini(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct lov_io *lio = cl2lov_io(env, ios);\r\nint rc;\r\nrc = lov_io_call(env, lio, lov_io_iter_fini_wrapper);\r\nLASSERT(rc == 0);\r\nwhile (!list_empty(&lio->lis_active))\r\nlist_del_init(lio->lis_active.next);\r\n}\r\nstatic void lov_io_unlock(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nint rc;\r\nrc = lov_io_call(env, cl2lov_io(env, ios), lov_io_unlock_wrapper);\r\nLASSERT(rc == 0);\r\n}\r\nstatic struct cl_page_list *lov_io_submit_qin(struct lov_device *ld,\r\nstruct cl_page_list *qin,\r\nint idx, int alloc)\r\n{\r\nreturn alloc ? &qin[idx] : &ld->ld_emrg[idx]->emrg_page_list;\r\n}\r\nstatic int lov_io_submit(const struct lu_env *env,\r\nconst struct cl_io_slice *ios,\r\nenum cl_req_type crt, struct cl_2queue *queue)\r\n{\r\nstruct lov_io *lio = cl2lov_io(env, ios);\r\nstruct lov_object *obj = lio->lis_object;\r\nstruct lov_device *ld = lu2lov_dev(lov2cl(obj)->co_lu.lo_dev);\r\nstruct cl_page_list *qin = &queue->c2_qin;\r\nstruct cl_2queue *cl2q = &lov_env_info(env)->lti_cl2q;\r\nstruct cl_page_list *stripes_qin = NULL;\r\nstruct cl_page *page;\r\nstruct cl_page *tmp;\r\nint stripe;\r\n#define QIN(stripe) lov_io_submit_qin(ld, stripes_qin, stripe, alloc)\r\nint rc = 0;\r\nint alloc =\r\n!(current->flags & PF_MEMALLOC);\r\nif (lio->lis_active_subios == 1) {\r\nint idx = lio->lis_single_subio_index;\r\nstruct lov_io_sub *sub;\r\nLASSERT(idx < lio->lis_nr_subios);\r\nsub = lov_sub_get(env, lio, idx);\r\nLASSERT(!IS_ERR(sub));\r\nLASSERT(sub->sub_io == &lio->lis_single_subio);\r\nrc = cl_io_submit_rw(sub->sub_env, sub->sub_io,\r\ncrt, queue);\r\nlov_sub_put(sub);\r\nreturn rc;\r\n}\r\nLASSERT(lio->lis_subs != NULL);\r\nif (alloc) {\r\nOBD_ALLOC_LARGE(stripes_qin,\r\nsizeof(*stripes_qin) * lio->lis_nr_subios);\r\nif (stripes_qin == NULL)\r\nreturn -ENOMEM;\r\nfor (stripe = 0; stripe < lio->lis_nr_subios; stripe++)\r\ncl_page_list_init(&stripes_qin[stripe]);\r\n} else {\r\nmutex_lock(&ld->ld_mutex);\r\nlio->lis_mem_frozen = 1;\r\n}\r\ncl_2queue_init(cl2q);\r\ncl_page_list_for_each_safe(page, tmp, qin) {\r\nstripe = lov_page_stripe(page);\r\ncl_page_list_move(QIN(stripe), qin, page);\r\n}\r\nfor (stripe = 0; stripe < lio->lis_nr_subios; stripe++) {\r\nstruct lov_io_sub *sub;\r\nstruct cl_page_list *sub_qin = QIN(stripe);\r\nif (list_empty(&sub_qin->pl_pages))\r\ncontinue;\r\ncl_page_list_splice(sub_qin, &cl2q->c2_qin);\r\nsub = lov_sub_get(env, lio, stripe);\r\nif (!IS_ERR(sub)) {\r\nrc = cl_io_submit_rw(sub->sub_env, sub->sub_io,\r\ncrt, cl2q);\r\nlov_sub_put(sub);\r\n} else\r\nrc = PTR_ERR(sub);\r\ncl_page_list_splice(&cl2q->c2_qin, &queue->c2_qin);\r\ncl_page_list_splice(&cl2q->c2_qout, &queue->c2_qout);\r\nif (rc != 0)\r\nbreak;\r\n}\r\nfor (stripe = 0; stripe < lio->lis_nr_subios; stripe++) {\r\nstruct cl_page_list *sub_qin = QIN(stripe);\r\nif (list_empty(&sub_qin->pl_pages))\r\ncontinue;\r\ncl_page_list_splice(sub_qin, qin);\r\n}\r\nif (alloc) {\r\nOBD_FREE_LARGE(stripes_qin,\r\nsizeof(*stripes_qin) * lio->lis_nr_subios);\r\n} else {\r\nint i;\r\nfor (i = 0; i < lio->lis_nr_subios; i++) {\r\nstruct cl_io *cio = lio->lis_subs[i].sub_io;\r\nif (cio && cio == &ld->ld_emrg[i]->emrg_subio)\r\nlov_io_sub_fini(env, lio, &lio->lis_subs[i]);\r\n}\r\nlio->lis_mem_frozen = 0;\r\nmutex_unlock(&ld->ld_mutex);\r\n}\r\nreturn rc;\r\n#undef QIN\r\n}\r\nstatic int lov_io_prepare_write(const struct lu_env *env,\r\nconst struct cl_io_slice *ios,\r\nconst struct cl_page_slice *slice,\r\nunsigned from, unsigned to)\r\n{\r\nstruct lov_io *lio = cl2lov_io(env, ios);\r\nstruct cl_page *sub_page = lov_sub_page(slice);\r\nstruct lov_io_sub *sub;\r\nint result;\r\nsub = lov_page_subio(env, lio, slice);\r\nif (!IS_ERR(sub)) {\r\nresult = cl_io_prepare_write(sub->sub_env, sub->sub_io,\r\nsub_page, from, to);\r\nlov_sub_put(sub);\r\n} else\r\nresult = PTR_ERR(sub);\r\nreturn result;\r\n}\r\nstatic int lov_io_commit_write(const struct lu_env *env,\r\nconst struct cl_io_slice *ios,\r\nconst struct cl_page_slice *slice,\r\nunsigned from, unsigned to)\r\n{\r\nstruct lov_io *lio = cl2lov_io(env, ios);\r\nstruct cl_page *sub_page = lov_sub_page(slice);\r\nstruct lov_io_sub *sub;\r\nint result;\r\nsub = lov_page_subio(env, lio, slice);\r\nif (!IS_ERR(sub)) {\r\nresult = cl_io_commit_write(sub->sub_env, sub->sub_io,\r\nsub_page, from, to);\r\nlov_sub_put(sub);\r\n} else\r\nresult = PTR_ERR(sub);\r\nreturn result;\r\n}\r\nstatic int lov_io_fault_start(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct cl_fault_io *fio;\r\nstruct lov_io *lio;\r\nstruct lov_io_sub *sub;\r\nfio = &ios->cis_io->u.ci_fault;\r\nlio = cl2lov_io(env, ios);\r\nsub = lov_sub_get(env, lio, lov_page_stripe(fio->ft_page));\r\nsub->sub_io->u.ci_fault.ft_nob = fio->ft_nob;\r\nlov_sub_put(sub);\r\nreturn lov_io_start(env, ios);\r\n}\r\nstatic void lov_io_fsync_end(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct lov_io *lio = cl2lov_io(env, ios);\r\nstruct lov_io_sub *sub;\r\nunsigned int *written = &ios->cis_io->u.ci_fsync.fi_nr_written;\r\n*written = 0;\r\nlist_for_each_entry(sub, &lio->lis_active, sub_linkage) {\r\nstruct cl_io *subio = sub->sub_io;\r\nlov_sub_enter(sub);\r\nlov_io_end_wrapper(sub->sub_env, subio);\r\nlov_sub_exit(sub);\r\nif (subio->ci_result == 0)\r\n*written += subio->u.ci_fsync.fi_nr_written;\r\n}\r\n}\r\nstatic void lov_empty_io_fini(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct lov_object *lov = cl2lov(ios->cis_obj);\r\nif (atomic_dec_and_test(&lov->lo_active_ios))\r\nwake_up_all(&lov->lo_waitq);\r\n}\r\nstatic void lov_empty_impossible(const struct lu_env *env,\r\nstruct cl_io_slice *ios)\r\n{\r\nLBUG();\r\n}\r\nint lov_io_init_raid0(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_io *io)\r\n{\r\nstruct lov_io *lio = lov_env_io(env);\r\nstruct lov_object *lov = cl2lov(obj);\r\nINIT_LIST_HEAD(&lio->lis_active);\r\nlov_io_slice_init(lio, lov, io);\r\nif (io->ci_result == 0) {\r\nio->ci_result = lov_io_subio_init(env, lio, io);\r\nif (io->ci_result == 0) {\r\ncl_io_slice_add(io, &lio->lis_cl, obj, &lov_io_ops);\r\natomic_inc(&lov->lo_active_ios);\r\n}\r\n}\r\nreturn io->ci_result;\r\n}\r\nint lov_io_init_empty(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_io *io)\r\n{\r\nstruct lov_object *lov = cl2lov(obj);\r\nstruct lov_io *lio = lov_env_io(env);\r\nint result;\r\nlio->lis_object = lov;\r\nswitch (io->ci_type) {\r\ndefault:\r\nLBUG();\r\ncase CIT_MISC:\r\ncase CIT_READ:\r\nresult = 0;\r\nbreak;\r\ncase CIT_FSYNC:\r\ncase CIT_SETATTR:\r\nresult = +1;\r\nbreak;\r\ncase CIT_WRITE:\r\nresult = -EBADF;\r\nbreak;\r\ncase CIT_FAULT:\r\nresult = -EFAULT;\r\nCERROR("Page fault on a file without stripes: "DFID"\n",\r\nPFID(lu_object_fid(&obj->co_lu)));\r\nbreak;\r\n}\r\nif (result == 0) {\r\ncl_io_slice_add(io, &lio->lis_cl, obj, &lov_empty_io_ops);\r\natomic_inc(&lov->lo_active_ios);\r\n}\r\nio->ci_result = result < 0 ? result : 0;\r\nreturn result != 0;\r\n}\r\nint lov_io_init_released(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_io *io)\r\n{\r\nstruct lov_object *lov = cl2lov(obj);\r\nstruct lov_io *lio = lov_env_io(env);\r\nint result;\r\nLASSERT(lov->lo_lsm != NULL);\r\nlio->lis_object = lov;\r\nswitch (io->ci_type) {\r\ndefault:\r\nLASSERTF(0, "invalid type %d\n", io->ci_type);\r\ncase CIT_MISC:\r\ncase CIT_FSYNC:\r\nresult = 1;\r\nbreak;\r\ncase CIT_SETATTR:\r\nif (cl_io_is_trunc(io))\r\nio->ci_restore_needed = 1;\r\nresult = -ENODATA;\r\nbreak;\r\ncase CIT_READ:\r\ncase CIT_WRITE:\r\ncase CIT_FAULT:\r\nio->ci_restore_needed = 1;\r\nresult = -ENODATA;\r\nbreak;\r\n}\r\nif (result == 0) {\r\ncl_io_slice_add(io, &lio->lis_cl, obj, &lov_empty_io_ops);\r\natomic_inc(&lov->lo_active_ios);\r\n}\r\nio->ci_result = result < 0 ? result : 0;\r\nreturn result != 0;\r\n}
