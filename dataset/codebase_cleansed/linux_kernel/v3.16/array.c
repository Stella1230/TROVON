static inline void task_name(struct seq_file *m, struct task_struct *p)\r\n{\r\nint i;\r\nchar *buf, *end;\r\nchar *name;\r\nchar tcomm[sizeof(p->comm)];\r\nget_task_comm(tcomm, p);\r\nseq_puts(m, "Name:\t");\r\nend = m->buf + m->size;\r\nbuf = m->buf + m->count;\r\nname = tcomm;\r\ni = sizeof(tcomm);\r\nwhile (i && (buf < end)) {\r\nunsigned char c = *name;\r\nname++;\r\ni--;\r\n*buf = c;\r\nif (!c)\r\nbreak;\r\nif (c == '\\') {\r\nbuf++;\r\nif (buf < end)\r\n*buf++ = c;\r\ncontinue;\r\n}\r\nif (c == '\n') {\r\n*buf++ = '\\';\r\nif (buf < end)\r\n*buf++ = 'n';\r\ncontinue;\r\n}\r\nbuf++;\r\n}\r\nm->count = buf - m->buf;\r\nseq_putc(m, '\n');\r\n}\r\nstatic inline const char *get_task_state(struct task_struct *tsk)\r\n{\r\nunsigned int state = (tsk->state | tsk->exit_state) & TASK_REPORT;\r\nBUILD_BUG_ON(1 + ilog2(TASK_REPORT) != ARRAY_SIZE(task_state_array)-1);\r\nreturn task_state_array[fls(state)];\r\n}\r\nstatic inline void task_state(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *p)\r\n{\r\nstruct user_namespace *user_ns = seq_user_ns(m);\r\nstruct group_info *group_info;\r\nint g;\r\nstruct fdtable *fdt = NULL;\r\nconst struct cred *cred;\r\npid_t ppid, tpid;\r\nrcu_read_lock();\r\nppid = pid_alive(p) ?\r\ntask_tgid_nr_ns(rcu_dereference(p->real_parent), ns) : 0;\r\ntpid = 0;\r\nif (pid_alive(p)) {\r\nstruct task_struct *tracer = ptrace_parent(p);\r\nif (tracer)\r\ntpid = task_pid_nr_ns(tracer, ns);\r\n}\r\ncred = get_task_cred(p);\r\nseq_printf(m,\r\n"State:\t%s\n"\r\n"Tgid:\t%d\n"\r\n"Ngid:\t%d\n"\r\n"Pid:\t%d\n"\r\n"PPid:\t%d\n"\r\n"TracerPid:\t%d\n"\r\n"Uid:\t%d\t%d\t%d\t%d\n"\r\n"Gid:\t%d\t%d\t%d\t%d\n",\r\nget_task_state(p),\r\ntask_tgid_nr_ns(p, ns),\r\ntask_numa_group_id(p),\r\npid_nr_ns(pid, ns),\r\nppid, tpid,\r\nfrom_kuid_munged(user_ns, cred->uid),\r\nfrom_kuid_munged(user_ns, cred->euid),\r\nfrom_kuid_munged(user_ns, cred->suid),\r\nfrom_kuid_munged(user_ns, cred->fsuid),\r\nfrom_kgid_munged(user_ns, cred->gid),\r\nfrom_kgid_munged(user_ns, cred->egid),\r\nfrom_kgid_munged(user_ns, cred->sgid),\r\nfrom_kgid_munged(user_ns, cred->fsgid));\r\ntask_lock(p);\r\nif (p->files)\r\nfdt = files_fdtable(p->files);\r\nseq_printf(m,\r\n"FDSize:\t%d\n"\r\n"Groups:\t",\r\nfdt ? fdt->max_fds : 0);\r\nrcu_read_unlock();\r\ngroup_info = cred->group_info;\r\ntask_unlock(p);\r\nfor (g = 0; g < group_info->ngroups; g++)\r\nseq_printf(m, "%d ",\r\nfrom_kgid_munged(user_ns, GROUP_AT(group_info, g)));\r\nput_cred(cred);\r\nseq_putc(m, '\n');\r\n}\r\nvoid render_sigset_t(struct seq_file *m, const char *header,\r\nsigset_t *set)\r\n{\r\nint i;\r\nseq_puts(m, header);\r\ni = _NSIG;\r\ndo {\r\nint x = 0;\r\ni -= 4;\r\nif (sigismember(set, i+1)) x |= 1;\r\nif (sigismember(set, i+2)) x |= 2;\r\nif (sigismember(set, i+3)) x |= 4;\r\nif (sigismember(set, i+4)) x |= 8;\r\nseq_printf(m, "%x", x);\r\n} while (i >= 4);\r\nseq_putc(m, '\n');\r\n}\r\nstatic void collect_sigign_sigcatch(struct task_struct *p, sigset_t *ign,\r\nsigset_t *catch)\r\n{\r\nstruct k_sigaction *k;\r\nint i;\r\nk = p->sighand->action;\r\nfor (i = 1; i <= _NSIG; ++i, ++k) {\r\nif (k->sa.sa_handler == SIG_IGN)\r\nsigaddset(ign, i);\r\nelse if (k->sa.sa_handler != SIG_DFL)\r\nsigaddset(catch, i);\r\n}\r\n}\r\nstatic inline void task_sig(struct seq_file *m, struct task_struct *p)\r\n{\r\nunsigned long flags;\r\nsigset_t pending, shpending, blocked, ignored, caught;\r\nint num_threads = 0;\r\nunsigned long qsize = 0;\r\nunsigned long qlim = 0;\r\nsigemptyset(&pending);\r\nsigemptyset(&shpending);\r\nsigemptyset(&blocked);\r\nsigemptyset(&ignored);\r\nsigemptyset(&caught);\r\nif (lock_task_sighand(p, &flags)) {\r\npending = p->pending.signal;\r\nshpending = p->signal->shared_pending.signal;\r\nblocked = p->blocked;\r\ncollect_sigign_sigcatch(p, &ignored, &caught);\r\nnum_threads = get_nr_threads(p);\r\nrcu_read_lock();\r\nqsize = atomic_read(&__task_cred(p)->user->sigpending);\r\nrcu_read_unlock();\r\nqlim = task_rlimit(p, RLIMIT_SIGPENDING);\r\nunlock_task_sighand(p, &flags);\r\n}\r\nseq_printf(m, "Threads:\t%d\n", num_threads);\r\nseq_printf(m, "SigQ:\t%lu/%lu\n", qsize, qlim);\r\nrender_sigset_t(m, "SigPnd:\t", &pending);\r\nrender_sigset_t(m, "ShdPnd:\t", &shpending);\r\nrender_sigset_t(m, "SigBlk:\t", &blocked);\r\nrender_sigset_t(m, "SigIgn:\t", &ignored);\r\nrender_sigset_t(m, "SigCgt:\t", &caught);\r\n}\r\nstatic void render_cap_t(struct seq_file *m, const char *header,\r\nkernel_cap_t *a)\r\n{\r\nunsigned __capi;\r\nseq_puts(m, header);\r\nCAP_FOR_EACH_U32(__capi) {\r\nseq_printf(m, "%08x",\r\na->cap[(_KERNEL_CAPABILITY_U32S-1) - __capi]);\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic inline void task_cap(struct seq_file *m, struct task_struct *p)\r\n{\r\nconst struct cred *cred;\r\nkernel_cap_t cap_inheritable, cap_permitted, cap_effective, cap_bset;\r\nrcu_read_lock();\r\ncred = __task_cred(p);\r\ncap_inheritable = cred->cap_inheritable;\r\ncap_permitted = cred->cap_permitted;\r\ncap_effective = cred->cap_effective;\r\ncap_bset = cred->cap_bset;\r\nrcu_read_unlock();\r\nNORM_CAPS(cap_inheritable);\r\nNORM_CAPS(cap_permitted);\r\nNORM_CAPS(cap_effective);\r\nNORM_CAPS(cap_bset);\r\nrender_cap_t(m, "CapInh:\t", &cap_inheritable);\r\nrender_cap_t(m, "CapPrm:\t", &cap_permitted);\r\nrender_cap_t(m, "CapEff:\t", &cap_effective);\r\nrender_cap_t(m, "CapBnd:\t", &cap_bset);\r\n}\r\nstatic inline void task_seccomp(struct seq_file *m, struct task_struct *p)\r\n{\r\n#ifdef CONFIG_SECCOMP\r\nseq_printf(m, "Seccomp:\t%d\n", p->seccomp.mode);\r\n#endif\r\n}\r\nstatic inline void task_context_switch_counts(struct seq_file *m,\r\nstruct task_struct *p)\r\n{\r\nseq_printf(m, "voluntary_ctxt_switches:\t%lu\n"\r\n"nonvoluntary_ctxt_switches:\t%lu\n",\r\np->nvcsw,\r\np->nivcsw);\r\n}\r\nstatic void task_cpus_allowed(struct seq_file *m, struct task_struct *task)\r\n{\r\nseq_puts(m, "Cpus_allowed:\t");\r\nseq_cpumask(m, &task->cpus_allowed);\r\nseq_putc(m, '\n');\r\nseq_puts(m, "Cpus_allowed_list:\t");\r\nseq_cpumask_list(m, &task->cpus_allowed);\r\nseq_putc(m, '\n');\r\n}\r\nint proc_pid_status(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task)\r\n{\r\nstruct mm_struct *mm = get_task_mm(task);\r\ntask_name(m, task);\r\ntask_state(m, ns, pid, task);\r\nif (mm) {\r\ntask_mem(m, mm);\r\nmmput(mm);\r\n}\r\ntask_sig(m, task);\r\ntask_cap(m, task);\r\ntask_seccomp(m, task);\r\ntask_cpus_allowed(m, task);\r\ncpuset_task_status_allowed(m, task);\r\ntask_context_switch_counts(m, task);\r\nreturn 0;\r\n}\r\nstatic int do_task_stat(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task, int whole)\r\n{\r\nunsigned long vsize, eip, esp, wchan = ~0UL;\r\nint priority, nice;\r\nint tty_pgrp = -1, tty_nr = 0;\r\nsigset_t sigign, sigcatch;\r\nchar state;\r\npid_t ppid = 0, pgid = -1, sid = -1;\r\nint num_threads = 0;\r\nint permitted;\r\nstruct mm_struct *mm;\r\nunsigned long long start_time;\r\nunsigned long cmin_flt = 0, cmaj_flt = 0;\r\nunsigned long min_flt = 0, maj_flt = 0;\r\ncputime_t cutime, cstime, utime, stime;\r\ncputime_t cgtime, gtime;\r\nunsigned long rsslim = 0;\r\nchar tcomm[sizeof(task->comm)];\r\nunsigned long flags;\r\nstate = *get_task_state(task);\r\nvsize = eip = esp = 0;\r\npermitted = ptrace_may_access(task, PTRACE_MODE_READ | PTRACE_MODE_NOAUDIT);\r\nmm = get_task_mm(task);\r\nif (mm) {\r\nvsize = task_vsize(mm);\r\nif (permitted) {\r\neip = KSTK_EIP(task);\r\nesp = KSTK_ESP(task);\r\n}\r\n}\r\nget_task_comm(tcomm, task);\r\nsigemptyset(&sigign);\r\nsigemptyset(&sigcatch);\r\ncutime = cstime = utime = stime = 0;\r\ncgtime = gtime = 0;\r\nif (lock_task_sighand(task, &flags)) {\r\nstruct signal_struct *sig = task->signal;\r\nif (sig->tty) {\r\nstruct pid *pgrp = tty_get_pgrp(sig->tty);\r\ntty_pgrp = pid_nr_ns(pgrp, ns);\r\nput_pid(pgrp);\r\ntty_nr = new_encode_dev(tty_devnum(sig->tty));\r\n}\r\nnum_threads = get_nr_threads(task);\r\ncollect_sigign_sigcatch(task, &sigign, &sigcatch);\r\ncmin_flt = sig->cmin_flt;\r\ncmaj_flt = sig->cmaj_flt;\r\ncutime = sig->cutime;\r\ncstime = sig->cstime;\r\ncgtime = sig->cgtime;\r\nrsslim = ACCESS_ONCE(sig->rlim[RLIMIT_RSS].rlim_cur);\r\nif (whole) {\r\nstruct task_struct *t = task;\r\ndo {\r\nmin_flt += t->min_flt;\r\nmaj_flt += t->maj_flt;\r\ngtime += task_gtime(t);\r\n} while_each_thread(task, t);\r\nmin_flt += sig->min_flt;\r\nmaj_flt += sig->maj_flt;\r\nthread_group_cputime_adjusted(task, &utime, &stime);\r\ngtime += sig->gtime;\r\n}\r\nsid = task_session_nr_ns(task, ns);\r\nppid = task_tgid_nr_ns(task->real_parent, ns);\r\npgid = task_pgrp_nr_ns(task, ns);\r\nunlock_task_sighand(task, &flags);\r\n}\r\nint proc_tgid_stat(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task)\r\n{\r\nreturn do_task_stat(m, ns, pid, task, 1);\r\n}\r\nint proc_pid_statm(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task)\r\n{\r\nunsigned long size = 0, resident = 0, shared = 0, text = 0, data = 0;\r\nstruct mm_struct *mm = get_task_mm(task);\r\nif (mm) {\r\nsize = task_statm(mm, &shared, &text, &data, &resident);\r\nmmput(mm);\r\n}\r\nseq_put_decimal_ull(m, 0, size);\r\nseq_put_decimal_ull(m, ' ', resident);\r\nseq_put_decimal_ull(m, ' ', shared);\r\nseq_put_decimal_ull(m, ' ', text);\r\nseq_put_decimal_ull(m, ' ', 0);\r\nseq_put_decimal_ull(m, ' ', data);\r\nseq_put_decimal_ull(m, ' ', 0);\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic struct pid *\r\nget_children_pid(struct inode *inode, struct pid *pid_prev, loff_t pos)\r\n{\r\nstruct task_struct *start, *task;\r\nstruct pid *pid = NULL;\r\nread_lock(&tasklist_lock);\r\nstart = pid_task(proc_pid(inode), PIDTYPE_PID);\r\nif (!start)\r\ngoto out;\r\nif (pid_prev) {\r\ntask = pid_task(pid_prev, PIDTYPE_PID);\r\nif (task && task->real_parent == start &&\r\n!(list_empty(&task->sibling))) {\r\nif (list_is_last(&task->sibling, &start->children))\r\ngoto out;\r\ntask = list_first_entry(&task->sibling,\r\nstruct task_struct, sibling);\r\npid = get_pid(task_pid(task));\r\ngoto out;\r\n}\r\n}\r\nlist_for_each_entry(task, &start->children, sibling) {\r\nif (pos-- == 0) {\r\npid = get_pid(task_pid(task));\r\nbreak;\r\n}\r\n}\r\nout:\r\nread_unlock(&tasklist_lock);\r\nreturn pid;\r\n}\r\nstatic int children_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct inode *inode = seq->private;\r\npid_t pid;\r\npid = pid_nr_ns(v, inode->i_sb->s_fs_info);\r\nreturn seq_printf(seq, "%d ", pid);\r\n}\r\nstatic void *children_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn get_children_pid(seq->private, NULL, *pos);\r\n}\r\nstatic void *children_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct pid *pid;\r\npid = get_children_pid(seq->private, v, *pos + 1);\r\nput_pid(v);\r\n++*pos;\r\nreturn pid;\r\n}\r\nstatic void children_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nput_pid(v);\r\n}\r\nstatic int children_seq_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *m;\r\nint ret;\r\nret = seq_open(file, &children_seq_ops);\r\nif (ret)\r\nreturn ret;\r\nm = file->private_data;\r\nm->private = inode;\r\nreturn ret;\r\n}\r\nint children_seq_release(struct inode *inode, struct file *file)\r\n{\r\nseq_release(inode, file);\r\nreturn 0;\r\n}
