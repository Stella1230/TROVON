static void rpc_register_client(struct rpc_clnt *clnt)\r\n{\r\nstruct net *net = rpc_net_ns(clnt);\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nspin_lock(&sn->rpc_client_lock);\r\nlist_add(&clnt->cl_clients, &sn->all_clients);\r\nspin_unlock(&sn->rpc_client_lock);\r\n}\r\nstatic void rpc_unregister_client(struct rpc_clnt *clnt)\r\n{\r\nstruct net *net = rpc_net_ns(clnt);\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nspin_lock(&sn->rpc_client_lock);\r\nlist_del(&clnt->cl_clients);\r\nspin_unlock(&sn->rpc_client_lock);\r\n}\r\nstatic void __rpc_clnt_remove_pipedir(struct rpc_clnt *clnt)\r\n{\r\nrpc_remove_client_dir(clnt);\r\n}\r\nstatic void rpc_clnt_remove_pipedir(struct rpc_clnt *clnt)\r\n{\r\nstruct net *net = rpc_net_ns(clnt);\r\nstruct super_block *pipefs_sb;\r\npipefs_sb = rpc_get_sb_net(net);\r\nif (pipefs_sb) {\r\n__rpc_clnt_remove_pipedir(clnt);\r\nrpc_put_sb_net(net);\r\n}\r\n}\r\nstatic struct dentry *rpc_setup_pipedir_sb(struct super_block *sb,\r\nstruct rpc_clnt *clnt)\r\n{\r\nstatic uint32_t clntid;\r\nconst char *dir_name = clnt->cl_program->pipe_dir_name;\r\nchar name[15];\r\nstruct dentry *dir, *dentry;\r\ndir = rpc_d_lookup_sb(sb, dir_name);\r\nif (dir == NULL) {\r\npr_info("RPC: pipefs directory doesn't exist: %s\n", dir_name);\r\nreturn dir;\r\n}\r\nfor (;;) {\r\nsnprintf(name, sizeof(name), "clnt%x", (unsigned int)clntid++);\r\nname[sizeof(name) - 1] = '\0';\r\ndentry = rpc_create_client_dir(dir, name, clnt);\r\nif (!IS_ERR(dentry))\r\nbreak;\r\nif (dentry == ERR_PTR(-EEXIST))\r\ncontinue;\r\nprintk(KERN_INFO "RPC: Couldn't create pipefs entry"\r\n" %s/%s, error %ld\n",\r\ndir_name, name, PTR_ERR(dentry));\r\nbreak;\r\n}\r\ndput(dir);\r\nreturn dentry;\r\n}\r\nstatic int\r\nrpc_setup_pipedir(struct super_block *pipefs_sb, struct rpc_clnt *clnt)\r\n{\r\nstruct dentry *dentry;\r\nif (clnt->cl_program->pipe_dir_name != NULL) {\r\ndentry = rpc_setup_pipedir_sb(pipefs_sb, clnt);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rpc_clnt_skip_event(struct rpc_clnt *clnt, unsigned long event)\r\n{\r\nif (clnt->cl_program->pipe_dir_name == NULL)\r\nreturn 1;\r\nswitch (event) {\r\ncase RPC_PIPEFS_MOUNT:\r\nif (clnt->cl_pipedir_objects.pdh_dentry != NULL)\r\nreturn 1;\r\nif (atomic_read(&clnt->cl_count) == 0)\r\nreturn 1;\r\nbreak;\r\ncase RPC_PIPEFS_UMOUNT:\r\nif (clnt->cl_pipedir_objects.pdh_dentry == NULL)\r\nreturn 1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __rpc_clnt_handle_event(struct rpc_clnt *clnt, unsigned long event,\r\nstruct super_block *sb)\r\n{\r\nstruct dentry *dentry;\r\nint err = 0;\r\nswitch (event) {\r\ncase RPC_PIPEFS_MOUNT:\r\ndentry = rpc_setup_pipedir_sb(sb, clnt);\r\nif (!dentry)\r\nreturn -ENOENT;\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\nbreak;\r\ncase RPC_PIPEFS_UMOUNT:\r\n__rpc_clnt_remove_pipedir(clnt);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: unknown event: %ld\n", __func__, event);\r\nreturn -ENOTSUPP;\r\n}\r\nreturn err;\r\n}\r\nstatic int __rpc_pipefs_event(struct rpc_clnt *clnt, unsigned long event,\r\nstruct super_block *sb)\r\n{\r\nint error = 0;\r\nfor (;; clnt = clnt->cl_parent) {\r\nif (!rpc_clnt_skip_event(clnt, event))\r\nerror = __rpc_clnt_handle_event(clnt, event, sb);\r\nif (error || clnt == clnt->cl_parent)\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nstatic struct rpc_clnt *rpc_get_client_for_event(struct net *net, int event)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nstruct rpc_clnt *clnt;\r\nspin_lock(&sn->rpc_client_lock);\r\nlist_for_each_entry(clnt, &sn->all_clients, cl_clients) {\r\nif (rpc_clnt_skip_event(clnt, event))\r\ncontinue;\r\nspin_unlock(&sn->rpc_client_lock);\r\nreturn clnt;\r\n}\r\nspin_unlock(&sn->rpc_client_lock);\r\nreturn NULL;\r\n}\r\nstatic int rpc_pipefs_event(struct notifier_block *nb, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct super_block *sb = ptr;\r\nstruct rpc_clnt *clnt;\r\nint error = 0;\r\nwhile ((clnt = rpc_get_client_for_event(sb->s_fs_info, event))) {\r\nerror = __rpc_pipefs_event(clnt, event, sb);\r\nif (error)\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nint rpc_clients_notifier_register(void)\r\n{\r\nreturn rpc_pipefs_notifier_register(&rpc_clients_block);\r\n}\r\nvoid rpc_clients_notifier_unregister(void)\r\n{\r\nreturn rpc_pipefs_notifier_unregister(&rpc_clients_block);\r\n}\r\nstatic struct rpc_xprt *rpc_clnt_set_transport(struct rpc_clnt *clnt,\r\nstruct rpc_xprt *xprt,\r\nconst struct rpc_timeout *timeout)\r\n{\r\nstruct rpc_xprt *old;\r\nspin_lock(&clnt->cl_lock);\r\nold = rcu_dereference_protected(clnt->cl_xprt,\r\nlockdep_is_held(&clnt->cl_lock));\r\nif (!xprt_bound(xprt))\r\nclnt->cl_autobind = 1;\r\nclnt->cl_timeout = timeout;\r\nrcu_assign_pointer(clnt->cl_xprt, xprt);\r\nspin_unlock(&clnt->cl_lock);\r\nreturn old;\r\n}\r\nstatic void rpc_clnt_set_nodename(struct rpc_clnt *clnt, const char *nodename)\r\n{\r\nclnt->cl_nodelen = strlen(nodename);\r\nif (clnt->cl_nodelen > UNX_MAXNODENAME)\r\nclnt->cl_nodelen = UNX_MAXNODENAME;\r\nmemcpy(clnt->cl_nodename, nodename, clnt->cl_nodelen);\r\n}\r\nstatic int rpc_client_register(struct rpc_clnt *clnt,\r\nrpc_authflavor_t pseudoflavor,\r\nconst char *client_name)\r\n{\r\nstruct rpc_auth_create_args auth_args = {\r\n.pseudoflavor = pseudoflavor,\r\n.target_name = client_name,\r\n};\r\nstruct rpc_auth *auth;\r\nstruct net *net = rpc_net_ns(clnt);\r\nstruct super_block *pipefs_sb;\r\nint err;\r\npipefs_sb = rpc_get_sb_net(net);\r\nif (pipefs_sb) {\r\nerr = rpc_setup_pipedir(pipefs_sb, clnt);\r\nif (err)\r\ngoto out;\r\n}\r\nrpc_register_client(clnt);\r\nif (pipefs_sb)\r\nrpc_put_sb_net(net);\r\nauth = rpcauth_create(&auth_args, clnt);\r\nif (IS_ERR(auth)) {\r\ndprintk("RPC: Couldn't create auth handle (flavor %u)\n",\r\npseudoflavor);\r\nerr = PTR_ERR(auth);\r\ngoto err_auth;\r\n}\r\nreturn 0;\r\nerr_auth:\r\npipefs_sb = rpc_get_sb_net(net);\r\nrpc_unregister_client(clnt);\r\n__rpc_clnt_remove_pipedir(clnt);\r\nout:\r\nif (pipefs_sb)\r\nrpc_put_sb_net(net);\r\nreturn err;\r\n}\r\nstatic int rpc_alloc_clid(struct rpc_clnt *clnt)\r\n{\r\nint clid;\r\nclid = ida_simple_get(&rpc_clids, 0, 0, GFP_KERNEL);\r\nif (clid < 0)\r\nreturn clid;\r\nclnt->cl_clid = clid;\r\nreturn 0;\r\n}\r\nstatic void rpc_free_clid(struct rpc_clnt *clnt)\r\n{\r\nida_simple_remove(&rpc_clids, clnt->cl_clid);\r\n}\r\nstatic struct rpc_clnt * rpc_new_client(const struct rpc_create_args *args,\r\nstruct rpc_xprt *xprt,\r\nstruct rpc_clnt *parent)\r\n{\r\nconst struct rpc_program *program = args->program;\r\nconst struct rpc_version *version;\r\nstruct rpc_clnt *clnt = NULL;\r\nconst struct rpc_timeout *timeout;\r\nint err;\r\ndprintk("RPC: creating %s client for %s (xprt %p)\n",\r\nprogram->name, args->servername, xprt);\r\nerr = rpciod_up();\r\nif (err)\r\ngoto out_no_rpciod;\r\nerr = -EINVAL;\r\nif (args->version >= program->nrvers)\r\ngoto out_err;\r\nversion = program->version[args->version];\r\nif (version == NULL)\r\ngoto out_err;\r\nerr = -ENOMEM;\r\nclnt = kzalloc(sizeof(*clnt), GFP_KERNEL);\r\nif (!clnt)\r\ngoto out_err;\r\nclnt->cl_parent = parent ? : clnt;\r\nerr = rpc_alloc_clid(clnt);\r\nif (err)\r\ngoto out_no_clid;\r\nclnt->cl_procinfo = version->procs;\r\nclnt->cl_maxproc = version->nrprocs;\r\nclnt->cl_prog = args->prognumber ? : program->number;\r\nclnt->cl_vers = version->number;\r\nclnt->cl_stats = program->stats;\r\nclnt->cl_metrics = rpc_alloc_iostats(clnt);\r\nrpc_init_pipe_dir_head(&clnt->cl_pipedir_objects);\r\nerr = -ENOMEM;\r\nif (clnt->cl_metrics == NULL)\r\ngoto out_no_stats;\r\nclnt->cl_program = program;\r\nINIT_LIST_HEAD(&clnt->cl_tasks);\r\nspin_lock_init(&clnt->cl_lock);\r\ntimeout = xprt->timeout;\r\nif (args->timeout != NULL) {\r\nmemcpy(&clnt->cl_timeout_default, args->timeout,\r\nsizeof(clnt->cl_timeout_default));\r\ntimeout = &clnt->cl_timeout_default;\r\n}\r\nrpc_clnt_set_transport(clnt, xprt, timeout);\r\nclnt->cl_rtt = &clnt->cl_rtt_default;\r\nrpc_init_rtt(&clnt->cl_rtt_default, clnt->cl_timeout->to_initval);\r\natomic_set(&clnt->cl_count, 1);\r\nrpc_clnt_set_nodename(clnt, utsname()->nodename);\r\nerr = rpc_client_register(clnt, args->authflavor, args->client_name);\r\nif (err)\r\ngoto out_no_path;\r\nif (parent)\r\natomic_inc(&parent->cl_count);\r\nreturn clnt;\r\nout_no_path:\r\nrpc_free_iostats(clnt->cl_metrics);\r\nout_no_stats:\r\nrpc_free_clid(clnt);\r\nout_no_clid:\r\nkfree(clnt);\r\nout_err:\r\nrpciod_down();\r\nout_no_rpciod:\r\nxprt_put(xprt);\r\nreturn ERR_PTR(err);\r\n}\r\nstruct rpc_clnt *rpc_create_xprt(struct rpc_create_args *args,\r\nstruct rpc_xprt *xprt)\r\n{\r\nstruct rpc_clnt *clnt = NULL;\r\nclnt = rpc_new_client(args, xprt, NULL);\r\nif (IS_ERR(clnt))\r\nreturn clnt;\r\nif (!(args->flags & RPC_CLNT_CREATE_NOPING)) {\r\nint err = rpc_ping(clnt);\r\nif (err != 0) {\r\nrpc_shutdown_client(clnt);\r\nreturn ERR_PTR(err);\r\n}\r\n}\r\nclnt->cl_softrtry = 1;\r\nif (args->flags & RPC_CLNT_CREATE_HARDRTRY)\r\nclnt->cl_softrtry = 0;\r\nif (args->flags & RPC_CLNT_CREATE_AUTOBIND)\r\nclnt->cl_autobind = 1;\r\nif (args->flags & RPC_CLNT_CREATE_DISCRTRY)\r\nclnt->cl_discrtry = 1;\r\nif (!(args->flags & RPC_CLNT_CREATE_QUIET))\r\nclnt->cl_chatty = 1;\r\nreturn clnt;\r\n}\r\nstruct rpc_clnt *rpc_create(struct rpc_create_args *args)\r\n{\r\nstruct rpc_xprt *xprt;\r\nstruct xprt_create xprtargs = {\r\n.net = args->net,\r\n.ident = args->protocol,\r\n.srcaddr = args->saddress,\r\n.dstaddr = args->address,\r\n.addrlen = args->addrsize,\r\n.servername = args->servername,\r\n.bc_xprt = args->bc_xprt,\r\n};\r\nchar servername[48];\r\nif (args->flags & RPC_CLNT_CREATE_INFINITE_SLOTS)\r\nxprtargs.flags |= XPRT_CREATE_INFINITE_SLOTS;\r\nif (args->flags & RPC_CLNT_CREATE_NO_IDLE_TIMEOUT)\r\nxprtargs.flags |= XPRT_CREATE_NO_IDLE_TIMEOUT;\r\nif (xprtargs.servername == NULL) {\r\nstruct sockaddr_un *sun =\r\n(struct sockaddr_un *)args->address;\r\nstruct sockaddr_in *sin =\r\n(struct sockaddr_in *)args->address;\r\nstruct sockaddr_in6 *sin6 =\r\n(struct sockaddr_in6 *)args->address;\r\nservername[0] = '\0';\r\nswitch (args->address->sa_family) {\r\ncase AF_LOCAL:\r\nsnprintf(servername, sizeof(servername), "%s",\r\nsun->sun_path);\r\nbreak;\r\ncase AF_INET:\r\nsnprintf(servername, sizeof(servername), "%pI4",\r\n&sin->sin_addr.s_addr);\r\nbreak;\r\ncase AF_INET6:\r\nsnprintf(servername, sizeof(servername), "%pI6",\r\n&sin6->sin6_addr);\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nxprtargs.servername = servername;\r\n}\r\nxprt = xprt_create_transport(&xprtargs);\r\nif (IS_ERR(xprt))\r\nreturn (struct rpc_clnt *)xprt;\r\nxprt->resvport = 1;\r\nif (args->flags & RPC_CLNT_CREATE_NONPRIVPORT)\r\nxprt->resvport = 0;\r\nreturn rpc_create_xprt(args, xprt);\r\n}\r\nstatic struct rpc_clnt *__rpc_clone_client(struct rpc_create_args *args,\r\nstruct rpc_clnt *clnt)\r\n{\r\nstruct rpc_xprt *xprt;\r\nstruct rpc_clnt *new;\r\nint err;\r\nerr = -ENOMEM;\r\nrcu_read_lock();\r\nxprt = xprt_get(rcu_dereference(clnt->cl_xprt));\r\nrcu_read_unlock();\r\nif (xprt == NULL)\r\ngoto out_err;\r\nargs->servername = xprt->servername;\r\nnew = rpc_new_client(args, xprt, clnt);\r\nif (IS_ERR(new)) {\r\nerr = PTR_ERR(new);\r\ngoto out_err;\r\n}\r\nnew->cl_autobind = 0;\r\nnew->cl_softrtry = clnt->cl_softrtry;\r\nnew->cl_discrtry = clnt->cl_discrtry;\r\nnew->cl_chatty = clnt->cl_chatty;\r\nreturn new;\r\nout_err:\r\ndprintk("RPC: %s: returned error %d\n", __func__, err);\r\nreturn ERR_PTR(err);\r\n}\r\nstruct rpc_clnt *rpc_clone_client(struct rpc_clnt *clnt)\r\n{\r\nstruct rpc_create_args args = {\r\n.program = clnt->cl_program,\r\n.prognumber = clnt->cl_prog,\r\n.version = clnt->cl_vers,\r\n.authflavor = clnt->cl_auth->au_flavor,\r\n};\r\nreturn __rpc_clone_client(&args, clnt);\r\n}\r\nstruct rpc_clnt *\r\nrpc_clone_client_set_auth(struct rpc_clnt *clnt, rpc_authflavor_t flavor)\r\n{\r\nstruct rpc_create_args args = {\r\n.program = clnt->cl_program,\r\n.prognumber = clnt->cl_prog,\r\n.version = clnt->cl_vers,\r\n.authflavor = flavor,\r\n};\r\nreturn __rpc_clone_client(&args, clnt);\r\n}\r\nint rpc_switch_client_transport(struct rpc_clnt *clnt,\r\nstruct xprt_create *args,\r\nconst struct rpc_timeout *timeout)\r\n{\r\nconst struct rpc_timeout *old_timeo;\r\nrpc_authflavor_t pseudoflavor;\r\nstruct rpc_xprt *xprt, *old;\r\nstruct rpc_clnt *parent;\r\nint err;\r\nxprt = xprt_create_transport(args);\r\nif (IS_ERR(xprt)) {\r\ndprintk("RPC: failed to create new xprt for clnt %p\n",\r\nclnt);\r\nreturn PTR_ERR(xprt);\r\n}\r\npseudoflavor = clnt->cl_auth->au_flavor;\r\nold_timeo = clnt->cl_timeout;\r\nold = rpc_clnt_set_transport(clnt, xprt, timeout);\r\nrpc_unregister_client(clnt);\r\n__rpc_clnt_remove_pipedir(clnt);\r\nparent = clnt->cl_parent;\r\nclnt->cl_parent = clnt;\r\nerr = rpc_client_register(clnt, pseudoflavor, NULL);\r\nif (err)\r\ngoto out_revert;\r\nsynchronize_rcu();\r\nif (parent != clnt)\r\nrpc_release_client(parent);\r\nxprt_put(old);\r\ndprintk("RPC: replaced xprt for clnt %p\n", clnt);\r\nreturn 0;\r\nout_revert:\r\nrpc_clnt_set_transport(clnt, old, old_timeo);\r\nclnt->cl_parent = parent;\r\nrpc_client_register(clnt, pseudoflavor, NULL);\r\nxprt_put(xprt);\r\ndprintk("RPC: failed to switch xprt for clnt %p\n", clnt);\r\nreturn err;\r\n}\r\nvoid rpc_killall_tasks(struct rpc_clnt *clnt)\r\n{\r\nstruct rpc_task *rovr;\r\nif (list_empty(&clnt->cl_tasks))\r\nreturn;\r\ndprintk("RPC: killing all tasks for client %p\n", clnt);\r\nspin_lock(&clnt->cl_lock);\r\nlist_for_each_entry(rovr, &clnt->cl_tasks, tk_task) {\r\nif (!RPC_IS_ACTIVATED(rovr))\r\ncontinue;\r\nif (!(rovr->tk_flags & RPC_TASK_KILLED)) {\r\nrovr->tk_flags |= RPC_TASK_KILLED;\r\nrpc_exit(rovr, -EIO);\r\nif (RPC_IS_QUEUED(rovr))\r\nrpc_wake_up_queued_task(rovr->tk_waitqueue,\r\nrovr);\r\n}\r\n}\r\nspin_unlock(&clnt->cl_lock);\r\n}\r\nvoid rpc_shutdown_client(struct rpc_clnt *clnt)\r\n{\r\nmight_sleep();\r\ndprintk_rcu("RPC: shutting down %s client for %s\n",\r\nclnt->cl_program->name,\r\nrcu_dereference(clnt->cl_xprt)->servername);\r\nwhile (!list_empty(&clnt->cl_tasks)) {\r\nrpc_killall_tasks(clnt);\r\nwait_event_timeout(destroy_wait,\r\nlist_empty(&clnt->cl_tasks), 1*HZ);\r\n}\r\nrpc_release_client(clnt);\r\n}\r\nstatic struct rpc_clnt *\r\nrpc_free_client(struct rpc_clnt *clnt)\r\n{\r\nstruct rpc_clnt *parent = NULL;\r\ndprintk_rcu("RPC: destroying %s client for %s\n",\r\nclnt->cl_program->name,\r\nrcu_dereference(clnt->cl_xprt)->servername);\r\nif (clnt->cl_parent != clnt)\r\nparent = clnt->cl_parent;\r\nrpc_clnt_remove_pipedir(clnt);\r\nrpc_unregister_client(clnt);\r\nrpc_free_iostats(clnt->cl_metrics);\r\nclnt->cl_metrics = NULL;\r\nxprt_put(rcu_dereference_raw(clnt->cl_xprt));\r\nrpciod_down();\r\nrpc_free_clid(clnt);\r\nkfree(clnt);\r\nreturn parent;\r\n}\r\nstatic struct rpc_clnt *\r\nrpc_free_auth(struct rpc_clnt *clnt)\r\n{\r\nif (clnt->cl_auth == NULL)\r\nreturn rpc_free_client(clnt);\r\natomic_inc(&clnt->cl_count);\r\nrpcauth_release(clnt->cl_auth);\r\nclnt->cl_auth = NULL;\r\nif (atomic_dec_and_test(&clnt->cl_count))\r\nreturn rpc_free_client(clnt);\r\nreturn NULL;\r\n}\r\nvoid\r\nrpc_release_client(struct rpc_clnt *clnt)\r\n{\r\ndprintk("RPC: rpc_release_client(%p)\n", clnt);\r\ndo {\r\nif (list_empty(&clnt->cl_tasks))\r\nwake_up(&destroy_wait);\r\nif (!atomic_dec_and_test(&clnt->cl_count))\r\nbreak;\r\nclnt = rpc_free_auth(clnt);\r\n} while (clnt != NULL);\r\n}\r\nstruct rpc_clnt *rpc_bind_new_program(struct rpc_clnt *old,\r\nconst struct rpc_program *program,\r\nu32 vers)\r\n{\r\nstruct rpc_create_args args = {\r\n.program = program,\r\n.prognumber = program->number,\r\n.version = vers,\r\n.authflavor = old->cl_auth->au_flavor,\r\n};\r\nstruct rpc_clnt *clnt;\r\nint err;\r\nclnt = __rpc_clone_client(&args, old);\r\nif (IS_ERR(clnt))\r\ngoto out;\r\nerr = rpc_ping(clnt);\r\nif (err != 0) {\r\nrpc_shutdown_client(clnt);\r\nclnt = ERR_PTR(err);\r\n}\r\nout:\r\nreturn clnt;\r\n}\r\nvoid rpc_task_release_client(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nif (clnt != NULL) {\r\nspin_lock(&clnt->cl_lock);\r\nlist_del(&task->tk_task);\r\nspin_unlock(&clnt->cl_lock);\r\ntask->tk_client = NULL;\r\nrpc_release_client(clnt);\r\n}\r\n}\r\nstatic\r\nvoid rpc_task_set_client(struct rpc_task *task, struct rpc_clnt *clnt)\r\n{\r\nif (clnt != NULL) {\r\nrpc_task_release_client(task);\r\ntask->tk_client = clnt;\r\natomic_inc(&clnt->cl_count);\r\nif (clnt->cl_softrtry)\r\ntask->tk_flags |= RPC_TASK_SOFT;\r\nif (clnt->cl_noretranstimeo)\r\ntask->tk_flags |= RPC_TASK_NO_RETRANS_TIMEOUT;\r\nif (sk_memalloc_socks()) {\r\nstruct rpc_xprt *xprt;\r\nrcu_read_lock();\r\nxprt = rcu_dereference(clnt->cl_xprt);\r\nif (xprt->swapper)\r\ntask->tk_flags |= RPC_TASK_SWAPPER;\r\nrcu_read_unlock();\r\n}\r\nspin_lock(&clnt->cl_lock);\r\nlist_add_tail(&task->tk_task, &clnt->cl_tasks);\r\nspin_unlock(&clnt->cl_lock);\r\n}\r\n}\r\nvoid rpc_task_reset_client(struct rpc_task *task, struct rpc_clnt *clnt)\r\n{\r\nrpc_task_release_client(task);\r\nrpc_task_set_client(task, clnt);\r\n}\r\nstatic void\r\nrpc_task_set_rpc_message(struct rpc_task *task, const struct rpc_message *msg)\r\n{\r\nif (msg != NULL) {\r\ntask->tk_msg.rpc_proc = msg->rpc_proc;\r\ntask->tk_msg.rpc_argp = msg->rpc_argp;\r\ntask->tk_msg.rpc_resp = msg->rpc_resp;\r\nif (msg->rpc_cred != NULL)\r\ntask->tk_msg.rpc_cred = get_rpccred(msg->rpc_cred);\r\n}\r\n}\r\nstatic void\r\nrpc_default_callback(struct rpc_task *task, void *data)\r\n{\r\n}\r\nstruct rpc_task *rpc_run_task(const struct rpc_task_setup *task_setup_data)\r\n{\r\nstruct rpc_task *task;\r\ntask = rpc_new_task(task_setup_data);\r\nif (IS_ERR(task))\r\ngoto out;\r\nrpc_task_set_client(task, task_setup_data->rpc_client);\r\nrpc_task_set_rpc_message(task, task_setup_data->rpc_message);\r\nif (task->tk_action == NULL)\r\nrpc_call_start(task);\r\natomic_inc(&task->tk_count);\r\nrpc_execute(task);\r\nout:\r\nreturn task;\r\n}\r\nint rpc_call_sync(struct rpc_clnt *clnt, const struct rpc_message *msg, int flags)\r\n{\r\nstruct rpc_task *task;\r\nstruct rpc_task_setup task_setup_data = {\r\n.rpc_client = clnt,\r\n.rpc_message = msg,\r\n.callback_ops = &rpc_default_ops,\r\n.flags = flags,\r\n};\r\nint status;\r\nWARN_ON_ONCE(flags & RPC_TASK_ASYNC);\r\nif (flags & RPC_TASK_ASYNC) {\r\nrpc_release_calldata(task_setup_data.callback_ops,\r\ntask_setup_data.callback_data);\r\nreturn -EINVAL;\r\n}\r\ntask = rpc_run_task(&task_setup_data);\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nstatus = task->tk_status;\r\nrpc_put_task(task);\r\nreturn status;\r\n}\r\nint\r\nrpc_call_async(struct rpc_clnt *clnt, const struct rpc_message *msg, int flags,\r\nconst struct rpc_call_ops *tk_ops, void *data)\r\n{\r\nstruct rpc_task *task;\r\nstruct rpc_task_setup task_setup_data = {\r\n.rpc_client = clnt,\r\n.rpc_message = msg,\r\n.callback_ops = tk_ops,\r\n.callback_data = data,\r\n.flags = flags|RPC_TASK_ASYNC,\r\n};\r\ntask = rpc_run_task(&task_setup_data);\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nrpc_put_task(task);\r\nreturn 0;\r\n}\r\nstruct rpc_task *rpc_run_bc_task(struct rpc_rqst *req,\r\nconst struct rpc_call_ops *tk_ops)\r\n{\r\nstruct rpc_task *task;\r\nstruct xdr_buf *xbufp = &req->rq_snd_buf;\r\nstruct rpc_task_setup task_setup_data = {\r\n.callback_ops = tk_ops,\r\n};\r\ndprintk("RPC: rpc_run_bc_task req= %p\n", req);\r\ntask = rpc_new_task(&task_setup_data);\r\nif (IS_ERR(task)) {\r\nxprt_free_bc_request(req);\r\ngoto out;\r\n}\r\ntask->tk_rqstp = req;\r\nxbufp->len = xbufp->head[0].iov_len + xbufp->page_len +\r\nxbufp->tail[0].iov_len;\r\ntask->tk_action = call_bc_transmit;\r\natomic_inc(&task->tk_count);\r\nWARN_ON_ONCE(atomic_read(&task->tk_count) != 2);\r\nrpc_execute(task);\r\nout:\r\ndprintk("RPC: rpc_run_bc_task: task= %p\n", task);\r\nreturn task;\r\n}\r\nvoid\r\nrpc_call_start(struct rpc_task *task)\r\n{\r\ntask->tk_action = call_start;\r\n}\r\nsize_t rpc_peeraddr(struct rpc_clnt *clnt, struct sockaddr *buf, size_t bufsize)\r\n{\r\nsize_t bytes;\r\nstruct rpc_xprt *xprt;\r\nrcu_read_lock();\r\nxprt = rcu_dereference(clnt->cl_xprt);\r\nbytes = xprt->addrlen;\r\nif (bytes > bufsize)\r\nbytes = bufsize;\r\nmemcpy(buf, &xprt->addr, bytes);\r\nrcu_read_unlock();\r\nreturn bytes;\r\n}\r\nconst char *rpc_peeraddr2str(struct rpc_clnt *clnt,\r\nenum rpc_display_format_t format)\r\n{\r\nstruct rpc_xprt *xprt;\r\nxprt = rcu_dereference(clnt->cl_xprt);\r\nif (xprt->address_strings[format] != NULL)\r\nreturn xprt->address_strings[format];\r\nelse\r\nreturn "unprintable";\r\n}\r\nstatic int rpc_sockname(struct net *net, struct sockaddr *sap, size_t salen,\r\nstruct sockaddr *buf, int buflen)\r\n{\r\nstruct socket *sock;\r\nint err;\r\nerr = __sock_create(net, sap->sa_family,\r\nSOCK_DGRAM, IPPROTO_UDP, &sock, 1);\r\nif (err < 0) {\r\ndprintk("RPC: can't create UDP socket (%d)\n", err);\r\ngoto out;\r\n}\r\nswitch (sap->sa_family) {\r\ncase AF_INET:\r\nerr = kernel_bind(sock,\r\n(struct sockaddr *)&rpc_inaddr_loopback,\r\nsizeof(rpc_inaddr_loopback));\r\nbreak;\r\ncase AF_INET6:\r\nerr = kernel_bind(sock,\r\n(struct sockaddr *)&rpc_in6addr_loopback,\r\nsizeof(rpc_in6addr_loopback));\r\nbreak;\r\ndefault:\r\nerr = -EAFNOSUPPORT;\r\ngoto out;\r\n}\r\nif (err < 0) {\r\ndprintk("RPC: can't bind UDP socket (%d)\n", err);\r\ngoto out_release;\r\n}\r\nerr = kernel_connect(sock, sap, salen, 0);\r\nif (err < 0) {\r\ndprintk("RPC: can't connect UDP socket (%d)\n", err);\r\ngoto out_release;\r\n}\r\nerr = kernel_getsockname(sock, buf, &buflen);\r\nif (err < 0) {\r\ndprintk("RPC: getsockname failed (%d)\n", err);\r\ngoto out_release;\r\n}\r\nerr = 0;\r\nif (buf->sa_family == AF_INET6) {\r\nstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)buf;\r\nsin6->sin6_scope_id = 0;\r\n}\r\ndprintk("RPC: %s succeeded\n", __func__);\r\nout_release:\r\nsock_release(sock);\r\nout:\r\nreturn err;\r\n}\r\nstatic int rpc_anyaddr(int family, struct sockaddr *buf, size_t buflen)\r\n{\r\nswitch (family) {\r\ncase AF_INET:\r\nif (buflen < sizeof(rpc_inaddr_loopback))\r\nreturn -EINVAL;\r\nmemcpy(buf, &rpc_inaddr_loopback,\r\nsizeof(rpc_inaddr_loopback));\r\nbreak;\r\ncase AF_INET6:\r\nif (buflen < sizeof(rpc_in6addr_loopback))\r\nreturn -EINVAL;\r\nmemcpy(buf, &rpc_in6addr_loopback,\r\nsizeof(rpc_in6addr_loopback));\r\ndefault:\r\ndprintk("RPC: %s: address family not supported\n",\r\n__func__);\r\nreturn -EAFNOSUPPORT;\r\n}\r\ndprintk("RPC: %s: succeeded\n", __func__);\r\nreturn 0;\r\n}\r\nint rpc_localaddr(struct rpc_clnt *clnt, struct sockaddr *buf, size_t buflen)\r\n{\r\nstruct sockaddr_storage address;\r\nstruct sockaddr *sap = (struct sockaddr *)&address;\r\nstruct rpc_xprt *xprt;\r\nstruct net *net;\r\nsize_t salen;\r\nint err;\r\nrcu_read_lock();\r\nxprt = rcu_dereference(clnt->cl_xprt);\r\nsalen = xprt->addrlen;\r\nmemcpy(sap, &xprt->addr, salen);\r\nnet = get_net(xprt->xprt_net);\r\nrcu_read_unlock();\r\nrpc_set_port(sap, 0);\r\nerr = rpc_sockname(net, sap, salen, buf, buflen);\r\nput_net(net);\r\nif (err != 0)\r\nreturn rpc_anyaddr(sap->sa_family, buf, buflen);\r\nreturn 0;\r\n}\r\nvoid\r\nrpc_setbufsize(struct rpc_clnt *clnt, unsigned int sndsize, unsigned int rcvsize)\r\n{\r\nstruct rpc_xprt *xprt;\r\nrcu_read_lock();\r\nxprt = rcu_dereference(clnt->cl_xprt);\r\nif (xprt->ops->set_buffer_size)\r\nxprt->ops->set_buffer_size(xprt, sndsize, rcvsize);\r\nrcu_read_unlock();\r\n}\r\nint rpc_protocol(struct rpc_clnt *clnt)\r\n{\r\nint protocol;\r\nrcu_read_lock();\r\nprotocol = rcu_dereference(clnt->cl_xprt)->prot;\r\nrcu_read_unlock();\r\nreturn protocol;\r\n}\r\nstruct net *rpc_net_ns(struct rpc_clnt *clnt)\r\n{\r\nstruct net *ret;\r\nrcu_read_lock();\r\nret = rcu_dereference(clnt->cl_xprt)->xprt_net;\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nsize_t rpc_max_payload(struct rpc_clnt *clnt)\r\n{\r\nsize_t ret;\r\nrcu_read_lock();\r\nret = rcu_dereference(clnt->cl_xprt)->max_payload;\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nunsigned long rpc_get_timeout(struct rpc_clnt *clnt)\r\n{\r\nunsigned long ret;\r\nrcu_read_lock();\r\nret = rcu_dereference(clnt->cl_xprt)->timeout->to_initval;\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nvoid rpc_force_rebind(struct rpc_clnt *clnt)\r\n{\r\nif (clnt->cl_autobind) {\r\nrcu_read_lock();\r\nxprt_clear_bound(rcu_dereference(clnt->cl_xprt));\r\nrcu_read_unlock();\r\n}\r\n}\r\nint\r\nrpc_restart_call_prepare(struct rpc_task *task)\r\n{\r\nif (RPC_ASSASSINATED(task))\r\nreturn 0;\r\ntask->tk_action = call_start;\r\ntask->tk_status = 0;\r\nif (task->tk_ops->rpc_call_prepare != NULL)\r\ntask->tk_action = rpc_prepare_task;\r\nreturn 1;\r\n}\r\nint\r\nrpc_restart_call(struct rpc_task *task)\r\n{\r\nif (RPC_ASSASSINATED(task))\r\nreturn 0;\r\ntask->tk_action = call_start;\r\ntask->tk_status = 0;\r\nreturn 1;\r\n}\r\nstatic const char *rpc_proc_name(const struct rpc_task *task)\r\n{\r\nconst struct rpc_procinfo *proc = task->tk_msg.rpc_proc;\r\nif (proc) {\r\nif (proc->p_name)\r\nreturn proc->p_name;\r\nelse\r\nreturn "NULL";\r\n} else\r\nreturn "no proc";\r\n}\r\nstatic void\r\ncall_start(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\ndprintk("RPC: %5u call_start %s%d proc %s (%s)\n", task->tk_pid,\r\nclnt->cl_program->name, clnt->cl_vers,\r\nrpc_proc_name(task),\r\n(RPC_IS_ASYNC(task) ? "async" : "sync"));\r\ntask->tk_msg.rpc_proc->p_count++;\r\nclnt->cl_stats->rpccnt++;\r\ntask->tk_action = call_reserve;\r\n}\r\nstatic void\r\ncall_reserve(struct rpc_task *task)\r\n{\r\ndprint_status(task);\r\ntask->tk_status = 0;\r\ntask->tk_action = call_reserveresult;\r\nxprt_reserve(task);\r\n}\r\nstatic void\r\ncall_reserveresult(struct rpc_task *task)\r\n{\r\nint status = task->tk_status;\r\ndprint_status(task);\r\ntask->tk_status = 0;\r\nif (status >= 0) {\r\nif (task->tk_rqstp) {\r\ntask->tk_action = call_refresh;\r\nreturn;\r\n}\r\nprintk(KERN_ERR "%s: status=%d, but no request slot, exiting\n",\r\n__func__, status);\r\nrpc_exit(task, -EIO);\r\nreturn;\r\n}\r\nif (task->tk_rqstp) {\r\nprintk(KERN_ERR "%s: status=%d, request allocated anyway\n",\r\n__func__, status);\r\nxprt_release(task);\r\n}\r\nswitch (status) {\r\ncase -ENOMEM:\r\nrpc_delay(task, HZ >> 2);\r\ncase -EAGAIN:\r\ntask->tk_action = call_retry_reserve;\r\nreturn;\r\ncase -EIO:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: unrecognized error %d, exiting\n",\r\n__func__, status);\r\nbreak;\r\n}\r\nrpc_exit(task, status);\r\n}\r\nstatic void\r\ncall_retry_reserve(struct rpc_task *task)\r\n{\r\ndprint_status(task);\r\ntask->tk_status = 0;\r\ntask->tk_action = call_reserveresult;\r\nxprt_retry_reserve(task);\r\n}\r\nstatic void\r\ncall_refresh(struct rpc_task *task)\r\n{\r\ndprint_status(task);\r\ntask->tk_action = call_refreshresult;\r\ntask->tk_status = 0;\r\ntask->tk_client->cl_stats->rpcauthrefresh++;\r\nrpcauth_refreshcred(task);\r\n}\r\nstatic void\r\ncall_refreshresult(struct rpc_task *task)\r\n{\r\nint status = task->tk_status;\r\ndprint_status(task);\r\ntask->tk_status = 0;\r\ntask->tk_action = call_refresh;\r\nswitch (status) {\r\ncase 0:\r\nif (rpcauth_uptodatecred(task)) {\r\ntask->tk_action = call_allocate;\r\nreturn;\r\n}\r\ncase -ETIMEDOUT:\r\nrpc_delay(task, 3*HZ);\r\ncase -EAGAIN:\r\nstatus = -EACCES;\r\ncase -EKEYEXPIRED:\r\nif (!task->tk_cred_retry)\r\nbreak;\r\ntask->tk_cred_retry--;\r\ndprintk("RPC: %5u %s: retry refresh creds\n",\r\ntask->tk_pid, __func__);\r\nreturn;\r\n}\r\ndprintk("RPC: %5u %s: refresh creds failed with error %d\n",\r\ntask->tk_pid, __func__, status);\r\nrpc_exit(task, status);\r\n}\r\nstatic void\r\ncall_allocate(struct rpc_task *task)\r\n{\r\nunsigned int slack = task->tk_rqstp->rq_cred->cr_auth->au_cslack;\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nstruct rpc_xprt *xprt = req->rq_xprt;\r\nstruct rpc_procinfo *proc = task->tk_msg.rpc_proc;\r\ndprint_status(task);\r\ntask->tk_status = 0;\r\ntask->tk_action = call_bind;\r\nif (req->rq_buffer)\r\nreturn;\r\nif (proc->p_proc != 0) {\r\nBUG_ON(proc->p_arglen == 0);\r\nif (proc->p_decode != NULL)\r\nBUG_ON(proc->p_replen == 0);\r\n}\r\nreq->rq_callsize = RPC_CALLHDRSIZE + (slack << 1) + proc->p_arglen;\r\nreq->rq_callsize <<= 2;\r\nreq->rq_rcvsize = RPC_REPHDRSIZE + slack + proc->p_replen;\r\nreq->rq_rcvsize <<= 2;\r\nreq->rq_buffer = xprt->ops->buf_alloc(task,\r\nreq->rq_callsize + req->rq_rcvsize);\r\nif (req->rq_buffer != NULL)\r\nreturn;\r\ndprintk("RPC: %5u rpc_buffer allocation failed\n", task->tk_pid);\r\nif (RPC_IS_ASYNC(task) || !fatal_signal_pending(current)) {\r\ntask->tk_action = call_allocate;\r\nrpc_delay(task, HZ>>4);\r\nreturn;\r\n}\r\nrpc_exit(task, -ERESTARTSYS);\r\n}\r\nstatic inline int\r\nrpc_task_need_encode(struct rpc_task *task)\r\n{\r\nreturn task->tk_rqstp->rq_snd_buf.len == 0;\r\n}\r\nstatic inline void\r\nrpc_task_force_reencode(struct rpc_task *task)\r\n{\r\ntask->tk_rqstp->rq_snd_buf.len = 0;\r\ntask->tk_rqstp->rq_bytes_sent = 0;\r\n}\r\nstatic inline void\r\nrpc_xdr_buf_init(struct xdr_buf *buf, void *start, size_t len)\r\n{\r\nbuf->head[0].iov_base = start;\r\nbuf->head[0].iov_len = len;\r\nbuf->tail[0].iov_len = 0;\r\nbuf->page_len = 0;\r\nbuf->flags = 0;\r\nbuf->len = 0;\r\nbuf->buflen = len;\r\n}\r\nstatic void\r\nrpc_xdr_encode(struct rpc_task *task)\r\n{\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nkxdreproc_t encode;\r\n__be32 *p;\r\ndprint_status(task);\r\nrpc_xdr_buf_init(&req->rq_snd_buf,\r\nreq->rq_buffer,\r\nreq->rq_callsize);\r\nrpc_xdr_buf_init(&req->rq_rcv_buf,\r\n(char *)req->rq_buffer + req->rq_callsize,\r\nreq->rq_rcvsize);\r\np = rpc_encode_header(task);\r\nif (p == NULL) {\r\nprintk(KERN_INFO "RPC: couldn't encode RPC header, exit EIO\n");\r\nrpc_exit(task, -EIO);\r\nreturn;\r\n}\r\nencode = task->tk_msg.rpc_proc->p_encode;\r\nif (encode == NULL)\r\nreturn;\r\ntask->tk_status = rpcauth_wrap_req(task, encode, req, p,\r\ntask->tk_msg.rpc_argp);\r\n}\r\nstatic void\r\ncall_bind(struct rpc_task *task)\r\n{\r\nstruct rpc_xprt *xprt = task->tk_rqstp->rq_xprt;\r\ndprint_status(task);\r\ntask->tk_action = call_connect;\r\nif (!xprt_bound(xprt)) {\r\ntask->tk_action = call_bind_status;\r\ntask->tk_timeout = xprt->bind_timeout;\r\nxprt->ops->rpcbind(task);\r\n}\r\n}\r\nstatic void\r\ncall_bind_status(struct rpc_task *task)\r\n{\r\nint status = -EIO;\r\nif (task->tk_status >= 0) {\r\ndprint_status(task);\r\ntask->tk_status = 0;\r\ntask->tk_action = call_connect;\r\nreturn;\r\n}\r\ntrace_rpc_bind_status(task);\r\nswitch (task->tk_status) {\r\ncase -ENOMEM:\r\ndprintk("RPC: %5u rpcbind out of memory\n", task->tk_pid);\r\nrpc_delay(task, HZ >> 2);\r\ngoto retry_timeout;\r\ncase -EACCES:\r\ndprintk("RPC: %5u remote rpcbind: RPC program/version "\r\n"unavailable\n", task->tk_pid);\r\nif (task->tk_msg.rpc_proc->p_proc == 0) {\r\nstatus = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (task->tk_rebind_retry == 0)\r\nbreak;\r\ntask->tk_rebind_retry--;\r\nrpc_delay(task, 3*HZ);\r\ngoto retry_timeout;\r\ncase -ETIMEDOUT:\r\ndprintk("RPC: %5u rpcbind request timed out\n",\r\ntask->tk_pid);\r\ngoto retry_timeout;\r\ncase -EPFNOSUPPORT:\r\ndprintk("RPC: %5u unrecognized remote rpcbind service\n",\r\ntask->tk_pid);\r\nbreak;\r\ncase -EPROTONOSUPPORT:\r\ndprintk("RPC: %5u remote rpcbind version unavailable, retrying\n",\r\ntask->tk_pid);\r\ngoto retry_timeout;\r\ncase -ECONNREFUSED:\r\ncase -ECONNRESET:\r\ncase -ECONNABORTED:\r\ncase -ENOTCONN:\r\ncase -EHOSTDOWN:\r\ncase -EHOSTUNREACH:\r\ncase -ENETUNREACH:\r\ncase -EPIPE:\r\ndprintk("RPC: %5u remote rpcbind unreachable: %d\n",\r\ntask->tk_pid, task->tk_status);\r\nif (!RPC_IS_SOFTCONN(task)) {\r\nrpc_delay(task, 5*HZ);\r\ngoto retry_timeout;\r\n}\r\nstatus = task->tk_status;\r\nbreak;\r\ndefault:\r\ndprintk("RPC: %5u unrecognized rpcbind error (%d)\n",\r\ntask->tk_pid, -task->tk_status);\r\n}\r\nrpc_exit(task, status);\r\nreturn;\r\nretry_timeout:\r\ntask->tk_status = 0;\r\ntask->tk_action = call_timeout;\r\n}\r\nstatic void\r\ncall_connect(struct rpc_task *task)\r\n{\r\nstruct rpc_xprt *xprt = task->tk_rqstp->rq_xprt;\r\ndprintk("RPC: %5u call_connect xprt %p %s connected\n",\r\ntask->tk_pid, xprt,\r\n(xprt_connected(xprt) ? "is" : "is not"));\r\ntask->tk_action = call_transmit;\r\nif (!xprt_connected(xprt)) {\r\ntask->tk_action = call_connect_status;\r\nif (task->tk_status < 0)\r\nreturn;\r\nif (task->tk_flags & RPC_TASK_NOCONNECT) {\r\nrpc_exit(task, -ENOTCONN);\r\nreturn;\r\n}\r\nxprt_connect(task);\r\n}\r\n}\r\nstatic void\r\ncall_connect_status(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nint status = task->tk_status;\r\ndprint_status(task);\r\ntrace_rpc_connect_status(task, status);\r\ntask->tk_status = 0;\r\nswitch (status) {\r\ncase -ECONNREFUSED:\r\ncase -ECONNRESET:\r\ncase -ECONNABORTED:\r\ncase -ENETUNREACH:\r\ncase -EHOSTUNREACH:\r\nif (RPC_IS_SOFTCONN(task))\r\nbreak;\r\nrpc_delay(task, 3*HZ);\r\ncase -EAGAIN:\r\ncase -ETIMEDOUT:\r\ntask->tk_action = call_timeout;\r\nreturn;\r\ncase 0:\r\nclnt->cl_stats->netreconn++;\r\ntask->tk_action = call_transmit;\r\nreturn;\r\n}\r\nrpc_exit(task, status);\r\n}\r\nstatic void\r\ncall_transmit(struct rpc_task *task)\r\n{\r\nint is_retrans = RPC_WAS_SENT(task);\r\ndprint_status(task);\r\ntask->tk_action = call_status;\r\nif (task->tk_status < 0)\r\nreturn;\r\nif (!xprt_prepare_transmit(task))\r\nreturn;\r\ntask->tk_action = call_transmit_status;\r\nif (rpc_task_need_encode(task)) {\r\nrpc_xdr_encode(task);\r\nif (task->tk_status != 0) {\r\nif (task->tk_status == -EAGAIN)\r\nrpc_delay(task, HZ >> 4);\r\nelse\r\nrpc_exit(task, task->tk_status);\r\nreturn;\r\n}\r\n}\r\nxprt_transmit(task);\r\nif (task->tk_status < 0)\r\nreturn;\r\nif (is_retrans)\r\ntask->tk_client->cl_stats->rpcretrans++;\r\ncall_transmit_status(task);\r\nif (rpc_reply_expected(task))\r\nreturn;\r\ntask->tk_action = rpc_exit_task;\r\nrpc_wake_up_queued_task(&task->tk_rqstp->rq_xprt->pending, task);\r\n}\r\nstatic void\r\ncall_transmit_status(struct rpc_task *task)\r\n{\r\ntask->tk_action = call_status;\r\nif (task->tk_status == 0) {\r\nxprt_end_transmit(task);\r\nrpc_task_force_reencode(task);\r\nreturn;\r\n}\r\nswitch (task->tk_status) {\r\ncase -EAGAIN:\r\nbreak;\r\ndefault:\r\ndprint_status(task);\r\nxprt_end_transmit(task);\r\nrpc_task_force_reencode(task);\r\nbreak;\r\ncase -ECONNREFUSED:\r\ncase -EHOSTDOWN:\r\ncase -EHOSTUNREACH:\r\ncase -ENETUNREACH:\r\nif (RPC_IS_SOFTCONN(task)) {\r\nxprt_end_transmit(task);\r\nrpc_exit(task, task->tk_status);\r\nbreak;\r\n}\r\ncase -ECONNRESET:\r\ncase -ECONNABORTED:\r\ncase -ENOTCONN:\r\ncase -EPIPE:\r\nrpc_task_force_reencode(task);\r\n}\r\n}\r\nstatic void\r\ncall_bc_transmit(struct rpc_task *task)\r\n{\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nif (!xprt_prepare_transmit(task)) {\r\ntask->tk_status = 0;\r\ntask->tk_action = call_bc_transmit;\r\nreturn;\r\n}\r\ntask->tk_action = rpc_exit_task;\r\nif (task->tk_status < 0) {\r\nprintk(KERN_NOTICE "RPC: Could not send backchannel reply "\r\n"error: %d\n", task->tk_status);\r\nreturn;\r\n}\r\nxprt_transmit(task);\r\nxprt_end_transmit(task);\r\ndprint_status(task);\r\nswitch (task->tk_status) {\r\ncase 0:\r\nbreak;\r\ncase -EHOSTDOWN:\r\ncase -EHOSTUNREACH:\r\ncase -ENETUNREACH:\r\ncase -ETIMEDOUT:\r\nprintk(KERN_NOTICE "RPC: Could not send backchannel reply "\r\n"error: %d\n", task->tk_status);\r\nxprt_conditional_disconnect(req->rq_xprt,\r\nreq->rq_connect_cookie);\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(task->tk_status == -EAGAIN);\r\nprintk(KERN_NOTICE "RPC: Could not send backchannel reply "\r\n"error: %d\n", task->tk_status);\r\nbreak;\r\n}\r\nrpc_wake_up_queued_task(&req->rq_xprt->pending, task);\r\n}\r\nstatic void\r\ncall_status(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nint status;\r\nif (req->rq_reply_bytes_recvd > 0 && !req->rq_bytes_sent)\r\ntask->tk_status = req->rq_reply_bytes_recvd;\r\ndprint_status(task);\r\nstatus = task->tk_status;\r\nif (status >= 0) {\r\ntask->tk_action = call_decode;\r\nreturn;\r\n}\r\ntrace_rpc_call_status(task);\r\ntask->tk_status = 0;\r\nswitch(status) {\r\ncase -EHOSTDOWN:\r\ncase -EHOSTUNREACH:\r\ncase -ENETUNREACH:\r\nif (RPC_IS_SOFTCONN(task)) {\r\nrpc_exit(task, status);\r\nbreak;\r\n}\r\nrpc_delay(task, 3*HZ);\r\ncase -ETIMEDOUT:\r\ntask->tk_action = call_timeout;\r\nif (!(task->tk_flags & RPC_TASK_NO_RETRANS_TIMEOUT)\r\n&& task->tk_client->cl_discrtry)\r\nxprt_conditional_disconnect(req->rq_xprt,\r\nreq->rq_connect_cookie);\r\nbreak;\r\ncase -ECONNREFUSED:\r\ncase -ECONNRESET:\r\ncase -ECONNABORTED:\r\nrpc_force_rebind(clnt);\r\nrpc_delay(task, 3*HZ);\r\ncase -EPIPE:\r\ncase -ENOTCONN:\r\ntask->tk_action = call_bind;\r\nbreak;\r\ncase -EAGAIN:\r\ntask->tk_action = call_transmit;\r\nbreak;\r\ncase -EIO:\r\nrpc_exit(task, status);\r\nbreak;\r\ndefault:\r\nif (clnt->cl_chatty)\r\nprintk("%s: RPC call returned error %d\n",\r\nclnt->cl_program->name, -status);\r\nrpc_exit(task, status);\r\n}\r\n}\r\nstatic void\r\ncall_timeout(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nif (xprt_adjust_timeout(task->tk_rqstp) == 0) {\r\ndprintk("RPC: %5u call_timeout (minor)\n", task->tk_pid);\r\ngoto retry;\r\n}\r\ndprintk("RPC: %5u call_timeout (major)\n", task->tk_pid);\r\ntask->tk_timeouts++;\r\nif (RPC_IS_SOFTCONN(task)) {\r\nrpc_exit(task, -ETIMEDOUT);\r\nreturn;\r\n}\r\nif (RPC_IS_SOFT(task)) {\r\nif (clnt->cl_chatty) {\r\nrcu_read_lock();\r\nprintk(KERN_NOTICE "%s: server %s not responding, timed out\n",\r\nclnt->cl_program->name,\r\nrcu_dereference(clnt->cl_xprt)->servername);\r\nrcu_read_unlock();\r\n}\r\nif (task->tk_flags & RPC_TASK_TIMEOUT)\r\nrpc_exit(task, -ETIMEDOUT);\r\nelse\r\nrpc_exit(task, -EIO);\r\nreturn;\r\n}\r\nif (!(task->tk_flags & RPC_CALL_MAJORSEEN)) {\r\ntask->tk_flags |= RPC_CALL_MAJORSEEN;\r\nif (clnt->cl_chatty) {\r\nrcu_read_lock();\r\nprintk(KERN_NOTICE "%s: server %s not responding, still trying\n",\r\nclnt->cl_program->name,\r\nrcu_dereference(clnt->cl_xprt)->servername);\r\nrcu_read_unlock();\r\n}\r\n}\r\nrpc_force_rebind(clnt);\r\nrpcauth_invalcred(task);\r\nretry:\r\ntask->tk_action = call_bind;\r\ntask->tk_status = 0;\r\n}\r\nstatic void\r\ncall_decode(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nkxdrdproc_t decode = task->tk_msg.rpc_proc->p_decode;\r\n__be32 *p;\r\ndprint_status(task);\r\nif (task->tk_flags & RPC_CALL_MAJORSEEN) {\r\nif (clnt->cl_chatty) {\r\nrcu_read_lock();\r\nprintk(KERN_NOTICE "%s: server %s OK\n",\r\nclnt->cl_program->name,\r\nrcu_dereference(clnt->cl_xprt)->servername);\r\nrcu_read_unlock();\r\n}\r\ntask->tk_flags &= ~RPC_CALL_MAJORSEEN;\r\n}\r\nsmp_rmb();\r\nreq->rq_rcv_buf.len = req->rq_private_buf.len;\r\nWARN_ON(memcmp(&req->rq_rcv_buf, &req->rq_private_buf,\r\nsizeof(req->rq_rcv_buf)) != 0);\r\nif (req->rq_rcv_buf.len < 12) {\r\nif (!RPC_IS_SOFT(task)) {\r\ntask->tk_action = call_bind;\r\ngoto out_retry;\r\n}\r\ndprintk("RPC: %s: too small RPC reply size (%d bytes)\n",\r\nclnt->cl_program->name, task->tk_status);\r\ntask->tk_action = call_timeout;\r\ngoto out_retry;\r\n}\r\np = rpc_verify_header(task);\r\nif (IS_ERR(p)) {\r\nif (p == ERR_PTR(-EAGAIN))\r\ngoto out_retry;\r\nreturn;\r\n}\r\ntask->tk_action = rpc_exit_task;\r\nif (decode) {\r\ntask->tk_status = rpcauth_unwrap_resp(task, decode, req, p,\r\ntask->tk_msg.rpc_resp);\r\n}\r\ndprintk("RPC: %5u call_decode result %d\n", task->tk_pid,\r\ntask->tk_status);\r\nreturn;\r\nout_retry:\r\ntask->tk_status = 0;\r\nif (task->tk_rqstp == req) {\r\nreq->rq_reply_bytes_recvd = req->rq_rcv_buf.len = 0;\r\nif (task->tk_client->cl_discrtry)\r\nxprt_conditional_disconnect(req->rq_xprt,\r\nreq->rq_connect_cookie);\r\n}\r\n}\r\nstatic __be32 *\r\nrpc_encode_header(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\n__be32 *p = req->rq_svec[0].iov_base;\r\np = xprt_skip_transport_header(req->rq_xprt, p);\r\n*p++ = req->rq_xid;\r\n*p++ = htonl(RPC_CALL);\r\n*p++ = htonl(RPC_VERSION);\r\n*p++ = htonl(clnt->cl_prog);\r\n*p++ = htonl(clnt->cl_vers);\r\n*p++ = htonl(task->tk_msg.rpc_proc->p_proc);\r\np = rpcauth_marshcred(task, p);\r\nreq->rq_slen = xdr_adjust_iovec(&req->rq_svec[0], p);\r\nreturn p;\r\n}\r\nstatic __be32 *\r\nrpc_verify_header(struct rpc_task *task)\r\n{\r\nstruct rpc_clnt *clnt = task->tk_client;\r\nstruct kvec *iov = &task->tk_rqstp->rq_rcv_buf.head[0];\r\nint len = task->tk_rqstp->rq_rcv_buf.len >> 2;\r\n__be32 *p = iov->iov_base;\r\nu32 n;\r\nint error = -EACCES;\r\nif ((task->tk_rqstp->rq_rcv_buf.len & 3) != 0) {\r\ndprintk("RPC: %5u %s: XDR representation not a multiple of"\r\n" 4 bytes: 0x%x\n", task->tk_pid, __func__,\r\ntask->tk_rqstp->rq_rcv_buf.len);\r\nerror = -EIO;\r\ngoto out_err;\r\n}\r\nif ((len -= 3) < 0)\r\ngoto out_overflow;\r\np += 1;\r\nif ((n = ntohl(*p++)) != RPC_REPLY) {\r\ndprintk("RPC: %5u %s: not an RPC reply: %x\n",\r\ntask->tk_pid, __func__, n);\r\nerror = -EIO;\r\ngoto out_garbage;\r\n}\r\nif ((n = ntohl(*p++)) != RPC_MSG_ACCEPTED) {\r\nif (--len < 0)\r\ngoto out_overflow;\r\nswitch ((n = ntohl(*p++))) {\r\ncase RPC_AUTH_ERROR:\r\nbreak;\r\ncase RPC_MISMATCH:\r\ndprintk("RPC: %5u %s: RPC call version mismatch!\n",\r\ntask->tk_pid, __func__);\r\nerror = -EPROTONOSUPPORT;\r\ngoto out_err;\r\ndefault:\r\ndprintk("RPC: %5u %s: RPC call rejected, "\r\n"unknown error: %x\n",\r\ntask->tk_pid, __func__, n);\r\nerror = -EIO;\r\ngoto out_err;\r\n}\r\nif (--len < 0)\r\ngoto out_overflow;\r\nswitch ((n = ntohl(*p++))) {\r\ncase RPC_AUTH_REJECTEDCRED:\r\ncase RPC_AUTH_REJECTEDVERF:\r\ncase RPCSEC_GSS_CREDPROBLEM:\r\ncase RPCSEC_GSS_CTXPROBLEM:\r\nif (!task->tk_cred_retry)\r\nbreak;\r\ntask->tk_cred_retry--;\r\ndprintk("RPC: %5u %s: retry stale creds\n",\r\ntask->tk_pid, __func__);\r\nrpcauth_invalcred(task);\r\nxprt_release(task);\r\ntask->tk_action = call_reserve;\r\ngoto out_retry;\r\ncase RPC_AUTH_BADCRED:\r\ncase RPC_AUTH_BADVERF:\r\nif (!task->tk_garb_retry)\r\nbreak;\r\ntask->tk_garb_retry--;\r\ndprintk("RPC: %5u %s: retry garbled creds\n",\r\ntask->tk_pid, __func__);\r\ntask->tk_action = call_bind;\r\ngoto out_retry;\r\ncase RPC_AUTH_TOOWEAK:\r\nrcu_read_lock();\r\nprintk(KERN_NOTICE "RPC: server %s requires stronger "\r\n"authentication.\n",\r\nrcu_dereference(clnt->cl_xprt)->servername);\r\nrcu_read_unlock();\r\nbreak;\r\ndefault:\r\ndprintk("RPC: %5u %s: unknown auth error: %x\n",\r\ntask->tk_pid, __func__, n);\r\nerror = -EIO;\r\n}\r\ndprintk("RPC: %5u %s: call rejected %d\n",\r\ntask->tk_pid, __func__, n);\r\ngoto out_err;\r\n}\r\np = rpcauth_checkverf(task, p);\r\nif (IS_ERR(p)) {\r\nerror = PTR_ERR(p);\r\ndprintk("RPC: %5u %s: auth check failed with %d\n",\r\ntask->tk_pid, __func__, error);\r\ngoto out_garbage;\r\n}\r\nlen = p - (__be32 *)iov->iov_base - 1;\r\nif (len < 0)\r\ngoto out_overflow;\r\nswitch ((n = ntohl(*p++))) {\r\ncase RPC_SUCCESS:\r\nreturn p;\r\ncase RPC_PROG_UNAVAIL:\r\ndprintk_rcu("RPC: %5u %s: program %u is unsupported "\r\n"by server %s\n", task->tk_pid, __func__,\r\n(unsigned int)clnt->cl_prog,\r\nrcu_dereference(clnt->cl_xprt)->servername);\r\nerror = -EPFNOSUPPORT;\r\ngoto out_err;\r\ncase RPC_PROG_MISMATCH:\r\ndprintk_rcu("RPC: %5u %s: program %u, version %u unsupported "\r\n"by server %s\n", task->tk_pid, __func__,\r\n(unsigned int)clnt->cl_prog,\r\n(unsigned int)clnt->cl_vers,\r\nrcu_dereference(clnt->cl_xprt)->servername);\r\nerror = -EPROTONOSUPPORT;\r\ngoto out_err;\r\ncase RPC_PROC_UNAVAIL:\r\ndprintk_rcu("RPC: %5u %s: proc %s unsupported by program %u, "\r\n"version %u on server %s\n",\r\ntask->tk_pid, __func__,\r\nrpc_proc_name(task),\r\nclnt->cl_prog, clnt->cl_vers,\r\nrcu_dereference(clnt->cl_xprt)->servername);\r\nerror = -EOPNOTSUPP;\r\ngoto out_err;\r\ncase RPC_GARBAGE_ARGS:\r\ndprintk("RPC: %5u %s: server saw garbage\n",\r\ntask->tk_pid, __func__);\r\nbreak;\r\ndefault:\r\ndprintk("RPC: %5u %s: server accept status: %x\n",\r\ntask->tk_pid, __func__, n);\r\n}\r\nout_garbage:\r\nclnt->cl_stats->rpcgarbage++;\r\nif (task->tk_garb_retry) {\r\ntask->tk_garb_retry--;\r\ndprintk("RPC: %5u %s: retrying\n",\r\ntask->tk_pid, __func__);\r\ntask->tk_action = call_bind;\r\nout_retry:\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\nout_err:\r\nrpc_exit(task, error);\r\ndprintk("RPC: %5u %s: call failed with error %d\n", task->tk_pid,\r\n__func__, error);\r\nreturn ERR_PTR(error);\r\nout_overflow:\r\ndprintk("RPC: %5u %s: server reply was truncated.\n", task->tk_pid,\r\n__func__);\r\ngoto out_garbage;\r\n}\r\nstatic void rpcproc_encode_null(void *rqstp, struct xdr_stream *xdr, void *obj)\r\n{\r\n}\r\nstatic int rpcproc_decode_null(void *rqstp, struct xdr_stream *xdr, void *obj)\r\n{\r\nreturn 0;\r\n}\r\nstatic int rpc_ping(struct rpc_clnt *clnt)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &rpcproc_null,\r\n};\r\nint err;\r\nmsg.rpc_cred = authnull_ops.lookup_cred(NULL, NULL, 0);\r\nerr = rpc_call_sync(clnt, &msg, RPC_TASK_SOFT | RPC_TASK_SOFTCONN);\r\nput_rpccred(msg.rpc_cred);\r\nreturn err;\r\n}\r\nstruct rpc_task *rpc_call_null(struct rpc_clnt *clnt, struct rpc_cred *cred, int flags)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &rpcproc_null,\r\n.rpc_cred = cred,\r\n};\r\nstruct rpc_task_setup task_setup_data = {\r\n.rpc_client = clnt,\r\n.rpc_message = &msg,\r\n.callback_ops = &rpc_default_ops,\r\n.flags = flags,\r\n};\r\nreturn rpc_run_task(&task_setup_data);\r\n}\r\nstatic void rpc_show_header(void)\r\n{\r\nprintk(KERN_INFO "-pid- flgs status -client- --rqstp- "\r\n"-timeout ---ops--\n");\r\n}\r\nstatic void rpc_show_task(const struct rpc_clnt *clnt,\r\nconst struct rpc_task *task)\r\n{\r\nconst char *rpc_waitq = "none";\r\nif (RPC_IS_QUEUED(task))\r\nrpc_waitq = rpc_qname(task->tk_waitqueue);\r\nprintk(KERN_INFO "%5u %04x %6d %8p %8p %8ld %8p %sv%u %s a:%ps q:%s\n",\r\ntask->tk_pid, task->tk_flags, task->tk_status,\r\nclnt, task->tk_rqstp, task->tk_timeout, task->tk_ops,\r\nclnt->cl_program->name, clnt->cl_vers, rpc_proc_name(task),\r\ntask->tk_action, rpc_waitq);\r\n}\r\nvoid rpc_show_tasks(struct net *net)\r\n{\r\nstruct rpc_clnt *clnt;\r\nstruct rpc_task *task;\r\nint header = 0;\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nspin_lock(&sn->rpc_client_lock);\r\nlist_for_each_entry(clnt, &sn->all_clients, cl_clients) {\r\nspin_lock(&clnt->cl_lock);\r\nlist_for_each_entry(task, &clnt->cl_tasks, tk_task) {\r\nif (!header) {\r\nrpc_show_header();\r\nheader++;\r\n}\r\nrpc_show_task(clnt, task);\r\n}\r\nspin_unlock(&clnt->cl_lock);\r\n}\r\nspin_unlock(&sn->rpc_client_lock);\r\n}
