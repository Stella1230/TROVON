static int\r\nparam_set_pool_mode(const char *val, struct kernel_param *kp)\r\n{\r\nint *ip = (int *)kp->arg;\r\nstruct svc_pool_map *m = &svc_pool_map;\r\nint err;\r\nmutex_lock(&svc_pool_map_mutex);\r\nerr = -EBUSY;\r\nif (m->count)\r\ngoto out;\r\nerr = 0;\r\nif (!strncmp(val, "auto", 4))\r\n*ip = SVC_POOL_AUTO;\r\nelse if (!strncmp(val, "global", 6))\r\n*ip = SVC_POOL_GLOBAL;\r\nelse if (!strncmp(val, "percpu", 6))\r\n*ip = SVC_POOL_PERCPU;\r\nelse if (!strncmp(val, "pernode", 7))\r\n*ip = SVC_POOL_PERNODE;\r\nelse\r\nerr = -EINVAL;\r\nout:\r\nmutex_unlock(&svc_pool_map_mutex);\r\nreturn err;\r\n}\r\nstatic int\r\nparam_get_pool_mode(char *buf, struct kernel_param *kp)\r\n{\r\nint *ip = (int *)kp->arg;\r\nswitch (*ip)\r\n{\r\ncase SVC_POOL_AUTO:\r\nreturn strlcpy(buf, "auto", 20);\r\ncase SVC_POOL_GLOBAL:\r\nreturn strlcpy(buf, "global", 20);\r\ncase SVC_POOL_PERCPU:\r\nreturn strlcpy(buf, "percpu", 20);\r\ncase SVC_POOL_PERNODE:\r\nreturn strlcpy(buf, "pernode", 20);\r\ndefault:\r\nreturn sprintf(buf, "%d", *ip);\r\n}\r\n}\r\nstatic int\r\nsvc_pool_map_choose_mode(void)\r\n{\r\nunsigned int node;\r\nif (nr_online_nodes > 1) {\r\nreturn SVC_POOL_PERNODE;\r\n}\r\nnode = first_online_node;\r\nif (nr_cpus_node(node) > 2) {\r\nreturn SVC_POOL_PERCPU;\r\n}\r\nreturn SVC_POOL_GLOBAL;\r\n}\r\nstatic int\r\nsvc_pool_map_alloc_arrays(struct svc_pool_map *m, unsigned int maxpools)\r\n{\r\nm->to_pool = kcalloc(maxpools, sizeof(unsigned int), GFP_KERNEL);\r\nif (!m->to_pool)\r\ngoto fail;\r\nm->pool_to = kcalloc(maxpools, sizeof(unsigned int), GFP_KERNEL);\r\nif (!m->pool_to)\r\ngoto fail_free;\r\nreturn 0;\r\nfail_free:\r\nkfree(m->to_pool);\r\nm->to_pool = NULL;\r\nfail:\r\nreturn -ENOMEM;\r\n}\r\nstatic int\r\nsvc_pool_map_init_percpu(struct svc_pool_map *m)\r\n{\r\nunsigned int maxpools = nr_cpu_ids;\r\nunsigned int pidx = 0;\r\nunsigned int cpu;\r\nint err;\r\nerr = svc_pool_map_alloc_arrays(m, maxpools);\r\nif (err)\r\nreturn err;\r\nfor_each_online_cpu(cpu) {\r\nBUG_ON(pidx > maxpools);\r\nm->to_pool[cpu] = pidx;\r\nm->pool_to[pidx] = cpu;\r\npidx++;\r\n}\r\nreturn pidx;\r\n}\r\nstatic int\r\nsvc_pool_map_init_pernode(struct svc_pool_map *m)\r\n{\r\nunsigned int maxpools = nr_node_ids;\r\nunsigned int pidx = 0;\r\nunsigned int node;\r\nint err;\r\nerr = svc_pool_map_alloc_arrays(m, maxpools);\r\nif (err)\r\nreturn err;\r\nfor_each_node_with_cpus(node) {\r\nBUG_ON(pidx > maxpools);\r\nm->to_pool[node] = pidx;\r\nm->pool_to[pidx] = node;\r\npidx++;\r\n}\r\nreturn pidx;\r\n}\r\nstatic unsigned int\r\nsvc_pool_map_get(void)\r\n{\r\nstruct svc_pool_map *m = &svc_pool_map;\r\nint npools = -1;\r\nmutex_lock(&svc_pool_map_mutex);\r\nif (m->count++) {\r\nmutex_unlock(&svc_pool_map_mutex);\r\nreturn m->npools;\r\n}\r\nif (m->mode == SVC_POOL_AUTO)\r\nm->mode = svc_pool_map_choose_mode();\r\nswitch (m->mode) {\r\ncase SVC_POOL_PERCPU:\r\nnpools = svc_pool_map_init_percpu(m);\r\nbreak;\r\ncase SVC_POOL_PERNODE:\r\nnpools = svc_pool_map_init_pernode(m);\r\nbreak;\r\n}\r\nif (npools < 0) {\r\nnpools = 1;\r\nm->mode = SVC_POOL_GLOBAL;\r\n}\r\nm->npools = npools;\r\nmutex_unlock(&svc_pool_map_mutex);\r\nreturn m->npools;\r\n}\r\nstatic void\r\nsvc_pool_map_put(void)\r\n{\r\nstruct svc_pool_map *m = &svc_pool_map;\r\nmutex_lock(&svc_pool_map_mutex);\r\nif (!--m->count) {\r\nkfree(m->to_pool);\r\nm->to_pool = NULL;\r\nkfree(m->pool_to);\r\nm->pool_to = NULL;\r\nm->npools = 0;\r\n}\r\nmutex_unlock(&svc_pool_map_mutex);\r\n}\r\nstatic int svc_pool_map_get_node(unsigned int pidx)\r\n{\r\nconst struct svc_pool_map *m = &svc_pool_map;\r\nif (m->count) {\r\nif (m->mode == SVC_POOL_PERCPU)\r\nreturn cpu_to_node(m->pool_to[pidx]);\r\nif (m->mode == SVC_POOL_PERNODE)\r\nreturn m->pool_to[pidx];\r\n}\r\nreturn NUMA_NO_NODE;\r\n}\r\nstatic inline void\r\nsvc_pool_map_set_cpumask(struct task_struct *task, unsigned int pidx)\r\n{\r\nstruct svc_pool_map *m = &svc_pool_map;\r\nunsigned int node = m->pool_to[pidx];\r\nWARN_ON_ONCE(m->count == 0);\r\nif (m->count == 0)\r\nreturn;\r\nswitch (m->mode) {\r\ncase SVC_POOL_PERCPU:\r\n{\r\nset_cpus_allowed_ptr(task, cpumask_of(node));\r\nbreak;\r\n}\r\ncase SVC_POOL_PERNODE:\r\n{\r\nset_cpus_allowed_ptr(task, cpumask_of_node(node));\r\nbreak;\r\n}\r\n}\r\n}\r\nstruct svc_pool *\r\nsvc_pool_for_cpu(struct svc_serv *serv, int cpu)\r\n{\r\nstruct svc_pool_map *m = &svc_pool_map;\r\nunsigned int pidx = 0;\r\nif (svc_serv_is_pooled(serv)) {\r\nswitch (m->mode) {\r\ncase SVC_POOL_PERCPU:\r\npidx = m->to_pool[cpu];\r\nbreak;\r\ncase SVC_POOL_PERNODE:\r\npidx = m->to_pool[cpu_to_node(cpu)];\r\nbreak;\r\n}\r\n}\r\nreturn &serv->sv_pools[pidx % serv->sv_nrpools];\r\n}\r\nint svc_rpcb_setup(struct svc_serv *serv, struct net *net)\r\n{\r\nint err;\r\nerr = rpcb_create_local(net);\r\nif (err)\r\nreturn err;\r\nsvc_unregister(serv, net);\r\nreturn 0;\r\n}\r\nvoid svc_rpcb_cleanup(struct svc_serv *serv, struct net *net)\r\n{\r\nsvc_unregister(serv, net);\r\nrpcb_put_local(net);\r\n}\r\nstatic int svc_uses_rpcbind(struct svc_serv *serv)\r\n{\r\nstruct svc_program *progp;\r\nunsigned int i;\r\nfor (progp = serv->sv_program; progp; progp = progp->pg_next) {\r\nfor (i = 0; i < progp->pg_nvers; i++) {\r\nif (progp->pg_vers[i] == NULL)\r\ncontinue;\r\nif (progp->pg_vers[i]->vs_hidden == 0)\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint svc_bind(struct svc_serv *serv, struct net *net)\r\n{\r\nif (!svc_uses_rpcbind(serv))\r\nreturn 0;\r\nreturn svc_rpcb_setup(serv, net);\r\n}\r\nstatic struct svc_serv *\r\n__svc_create(struct svc_program *prog, unsigned int bufsize, int npools,\r\nvoid (*shutdown)(struct svc_serv *serv, struct net *net))\r\n{\r\nstruct svc_serv *serv;\r\nunsigned int vers;\r\nunsigned int xdrsize;\r\nunsigned int i;\r\nif (!(serv = kzalloc(sizeof(*serv), GFP_KERNEL)))\r\nreturn NULL;\r\nserv->sv_name = prog->pg_name;\r\nserv->sv_program = prog;\r\nserv->sv_nrthreads = 1;\r\nserv->sv_stats = prog->pg_stats;\r\nif (bufsize > RPCSVC_MAXPAYLOAD)\r\nbufsize = RPCSVC_MAXPAYLOAD;\r\nserv->sv_max_payload = bufsize? bufsize : 4096;\r\nserv->sv_max_mesg = roundup(serv->sv_max_payload + PAGE_SIZE, PAGE_SIZE);\r\nserv->sv_shutdown = shutdown;\r\nxdrsize = 0;\r\nwhile (prog) {\r\nprog->pg_lovers = prog->pg_nvers-1;\r\nfor (vers=0; vers<prog->pg_nvers ; vers++)\r\nif (prog->pg_vers[vers]) {\r\nprog->pg_hivers = vers;\r\nif (prog->pg_lovers > vers)\r\nprog->pg_lovers = vers;\r\nif (prog->pg_vers[vers]->vs_xdrsize > xdrsize)\r\nxdrsize = prog->pg_vers[vers]->vs_xdrsize;\r\n}\r\nprog = prog->pg_next;\r\n}\r\nserv->sv_xdrsize = xdrsize;\r\nINIT_LIST_HEAD(&serv->sv_tempsocks);\r\nINIT_LIST_HEAD(&serv->sv_permsocks);\r\ninit_timer(&serv->sv_temptimer);\r\nspin_lock_init(&serv->sv_lock);\r\nserv->sv_nrpools = npools;\r\nserv->sv_pools =\r\nkcalloc(serv->sv_nrpools, sizeof(struct svc_pool),\r\nGFP_KERNEL);\r\nif (!serv->sv_pools) {\r\nkfree(serv);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < serv->sv_nrpools; i++) {\r\nstruct svc_pool *pool = &serv->sv_pools[i];\r\ndprintk("svc: initialising pool %u for %s\n",\r\ni, serv->sv_name);\r\npool->sp_id = i;\r\nINIT_LIST_HEAD(&pool->sp_threads);\r\nINIT_LIST_HEAD(&pool->sp_sockets);\r\nINIT_LIST_HEAD(&pool->sp_all_threads);\r\nspin_lock_init(&pool->sp_lock);\r\n}\r\nif (svc_uses_rpcbind(serv) && (!serv->sv_shutdown))\r\nserv->sv_shutdown = svc_rpcb_cleanup;\r\nreturn serv;\r\n}\r\nstruct svc_serv *\r\nsvc_create(struct svc_program *prog, unsigned int bufsize,\r\nvoid (*shutdown)(struct svc_serv *serv, struct net *net))\r\n{\r\nreturn __svc_create(prog, bufsize, 1, shutdown);\r\n}\r\nstruct svc_serv *\r\nsvc_create_pooled(struct svc_program *prog, unsigned int bufsize,\r\nvoid (*shutdown)(struct svc_serv *serv, struct net *net),\r\nsvc_thread_fn func, struct module *mod)\r\n{\r\nstruct svc_serv *serv;\r\nunsigned int npools = svc_pool_map_get();\r\nserv = __svc_create(prog, bufsize, npools, shutdown);\r\nif (serv != NULL) {\r\nserv->sv_function = func;\r\nserv->sv_module = mod;\r\n}\r\nreturn serv;\r\n}\r\nvoid svc_shutdown_net(struct svc_serv *serv, struct net *net)\r\n{\r\nsvc_close_net(serv, net);\r\nif (serv->sv_shutdown)\r\nserv->sv_shutdown(serv, net);\r\n}\r\nvoid\r\nsvc_destroy(struct svc_serv *serv)\r\n{\r\ndprintk("svc: svc_destroy(%s, %d)\n",\r\nserv->sv_program->pg_name,\r\nserv->sv_nrthreads);\r\nif (serv->sv_nrthreads) {\r\nif (--(serv->sv_nrthreads) != 0) {\r\nsvc_sock_update_bufs(serv);\r\nreturn;\r\n}\r\n} else\r\nprintk("svc_destroy: no threads for serv=%p!\n", serv);\r\ndel_timer_sync(&serv->sv_temptimer);\r\nBUG_ON(!list_empty(&serv->sv_permsocks));\r\nBUG_ON(!list_empty(&serv->sv_tempsocks));\r\ncache_clean_deferred(serv);\r\nif (svc_serv_is_pooled(serv))\r\nsvc_pool_map_put();\r\nkfree(serv->sv_pools);\r\nkfree(serv);\r\n}\r\nstatic int\r\nsvc_init_buffer(struct svc_rqst *rqstp, unsigned int size, int node)\r\n{\r\nunsigned int pages, arghi;\r\nif (svc_is_backchannel(rqstp))\r\nreturn 1;\r\npages = size / PAGE_SIZE + 1;\r\narghi = 0;\r\nWARN_ON_ONCE(pages > RPCSVC_MAXPAGES);\r\nif (pages > RPCSVC_MAXPAGES)\r\npages = RPCSVC_MAXPAGES;\r\nwhile (pages) {\r\nstruct page *p = alloc_pages_node(node, GFP_KERNEL, 0);\r\nif (!p)\r\nbreak;\r\nrqstp->rq_pages[arghi++] = p;\r\npages--;\r\n}\r\nreturn pages == 0;\r\n}\r\nstatic void\r\nsvc_release_buffer(struct svc_rqst *rqstp)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(rqstp->rq_pages); i++)\r\nif (rqstp->rq_pages[i])\r\nput_page(rqstp->rq_pages[i]);\r\n}\r\nstruct svc_rqst *\r\nsvc_prepare_thread(struct svc_serv *serv, struct svc_pool *pool, int node)\r\n{\r\nstruct svc_rqst *rqstp;\r\nrqstp = kzalloc_node(sizeof(*rqstp), GFP_KERNEL, node);\r\nif (!rqstp)\r\ngoto out_enomem;\r\ninit_waitqueue_head(&rqstp->rq_wait);\r\nserv->sv_nrthreads++;\r\nspin_lock_bh(&pool->sp_lock);\r\npool->sp_nrthreads++;\r\nlist_add(&rqstp->rq_all, &pool->sp_all_threads);\r\nspin_unlock_bh(&pool->sp_lock);\r\nrqstp->rq_server = serv;\r\nrqstp->rq_pool = pool;\r\nrqstp->rq_argp = kmalloc_node(serv->sv_xdrsize, GFP_KERNEL, node);\r\nif (!rqstp->rq_argp)\r\ngoto out_thread;\r\nrqstp->rq_resp = kmalloc_node(serv->sv_xdrsize, GFP_KERNEL, node);\r\nif (!rqstp->rq_resp)\r\ngoto out_thread;\r\nif (!svc_init_buffer(rqstp, serv->sv_max_mesg, node))\r\ngoto out_thread;\r\nreturn rqstp;\r\nout_thread:\r\nsvc_exit_thread(rqstp);\r\nout_enomem:\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic inline struct svc_pool *\r\nchoose_pool(struct svc_serv *serv, struct svc_pool *pool, unsigned int *state)\r\n{\r\nif (pool != NULL)\r\nreturn pool;\r\nreturn &serv->sv_pools[(*state)++ % serv->sv_nrpools];\r\n}\r\nstatic inline struct task_struct *\r\nchoose_victim(struct svc_serv *serv, struct svc_pool *pool, unsigned int *state)\r\n{\r\nunsigned int i;\r\nstruct task_struct *task = NULL;\r\nif (pool != NULL) {\r\nspin_lock_bh(&pool->sp_lock);\r\n} else {\r\nfor (i = 0; i < serv->sv_nrpools; i++) {\r\npool = &serv->sv_pools[--(*state) % serv->sv_nrpools];\r\nspin_lock_bh(&pool->sp_lock);\r\nif (!list_empty(&pool->sp_all_threads))\r\ngoto found_pool;\r\nspin_unlock_bh(&pool->sp_lock);\r\n}\r\nreturn NULL;\r\n}\r\nfound_pool:\r\nif (!list_empty(&pool->sp_all_threads)) {\r\nstruct svc_rqst *rqstp;\r\nrqstp = list_entry(pool->sp_all_threads.next, struct svc_rqst, rq_all);\r\nlist_del_init(&rqstp->rq_all);\r\ntask = rqstp->rq_task;\r\n}\r\nspin_unlock_bh(&pool->sp_lock);\r\nreturn task;\r\n}\r\nint\r\nsvc_set_num_threads(struct svc_serv *serv, struct svc_pool *pool, int nrservs)\r\n{\r\nstruct svc_rqst *rqstp;\r\nstruct task_struct *task;\r\nstruct svc_pool *chosen_pool;\r\nint error = 0;\r\nunsigned int state = serv->sv_nrthreads-1;\r\nint node;\r\nif (pool == NULL) {\r\nnrservs -= (serv->sv_nrthreads-1);\r\n} else {\r\nspin_lock_bh(&pool->sp_lock);\r\nnrservs -= pool->sp_nrthreads;\r\nspin_unlock_bh(&pool->sp_lock);\r\n}\r\nwhile (nrservs > 0) {\r\nnrservs--;\r\nchosen_pool = choose_pool(serv, pool, &state);\r\nnode = svc_pool_map_get_node(chosen_pool->sp_id);\r\nrqstp = svc_prepare_thread(serv, chosen_pool, node);\r\nif (IS_ERR(rqstp)) {\r\nerror = PTR_ERR(rqstp);\r\nbreak;\r\n}\r\n__module_get(serv->sv_module);\r\ntask = kthread_create_on_node(serv->sv_function, rqstp,\r\nnode, "%s", serv->sv_name);\r\nif (IS_ERR(task)) {\r\nerror = PTR_ERR(task);\r\nmodule_put(serv->sv_module);\r\nsvc_exit_thread(rqstp);\r\nbreak;\r\n}\r\nrqstp->rq_task = task;\r\nif (serv->sv_nrpools > 1)\r\nsvc_pool_map_set_cpumask(task, chosen_pool->sp_id);\r\nsvc_sock_update_bufs(serv);\r\nwake_up_process(task);\r\n}\r\nwhile (nrservs < 0 &&\r\n(task = choose_victim(serv, pool, &state)) != NULL) {\r\nsend_sig(SIGINT, task, 1);\r\nnrservs++;\r\n}\r\nreturn error;\r\n}\r\nvoid\r\nsvc_exit_thread(struct svc_rqst *rqstp)\r\n{\r\nstruct svc_serv *serv = rqstp->rq_server;\r\nstruct svc_pool *pool = rqstp->rq_pool;\r\nsvc_release_buffer(rqstp);\r\nkfree(rqstp->rq_resp);\r\nkfree(rqstp->rq_argp);\r\nkfree(rqstp->rq_auth_data);\r\nspin_lock_bh(&pool->sp_lock);\r\npool->sp_nrthreads--;\r\nlist_del(&rqstp->rq_all);\r\nspin_unlock_bh(&pool->sp_lock);\r\nkfree(rqstp);\r\nif (serv)\r\nsvc_destroy(serv);\r\n}\r\nstatic int __svc_rpcb_register4(struct net *net, const u32 program,\r\nconst u32 version,\r\nconst unsigned short protocol,\r\nconst unsigned short port)\r\n{\r\nconst struct sockaddr_in sin = {\r\n.sin_family = AF_INET,\r\n.sin_addr.s_addr = htonl(INADDR_ANY),\r\n.sin_port = htons(port),\r\n};\r\nconst char *netid;\r\nint error;\r\nswitch (protocol) {\r\ncase IPPROTO_UDP:\r\nnetid = RPCBIND_NETID_UDP;\r\nbreak;\r\ncase IPPROTO_TCP:\r\nnetid = RPCBIND_NETID_TCP;\r\nbreak;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nerror = rpcb_v4_register(net, program, version,\r\n(const struct sockaddr *)&sin, netid);\r\nif (error == -EPROTONOSUPPORT)\r\nerror = rpcb_register(net, program, version, protocol, port);\r\nreturn error;\r\n}\r\nstatic int __svc_rpcb_register6(struct net *net, const u32 program,\r\nconst u32 version,\r\nconst unsigned short protocol,\r\nconst unsigned short port)\r\n{\r\nconst struct sockaddr_in6 sin6 = {\r\n.sin6_family = AF_INET6,\r\n.sin6_addr = IN6ADDR_ANY_INIT,\r\n.sin6_port = htons(port),\r\n};\r\nconst char *netid;\r\nint error;\r\nswitch (protocol) {\r\ncase IPPROTO_UDP:\r\nnetid = RPCBIND_NETID_UDP6;\r\nbreak;\r\ncase IPPROTO_TCP:\r\nnetid = RPCBIND_NETID_TCP6;\r\nbreak;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nerror = rpcb_v4_register(net, program, version,\r\n(const struct sockaddr *)&sin6, netid);\r\nif (error == -EPROTONOSUPPORT)\r\nerror = -EAFNOSUPPORT;\r\nreturn error;\r\n}\r\nstatic int __svc_register(struct net *net, const char *progname,\r\nconst u32 program, const u32 version,\r\nconst int family,\r\nconst unsigned short protocol,\r\nconst unsigned short port)\r\n{\r\nint error = -EAFNOSUPPORT;\r\nswitch (family) {\r\ncase PF_INET:\r\nerror = __svc_rpcb_register4(net, program, version,\r\nprotocol, port);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase PF_INET6:\r\nerror = __svc_rpcb_register6(net, program, version,\r\nprotocol, port);\r\n#endif\r\n}\r\nreturn error;\r\n}\r\nint svc_register(const struct svc_serv *serv, struct net *net,\r\nconst int family, const unsigned short proto,\r\nconst unsigned short port)\r\n{\r\nstruct svc_program *progp;\r\nstruct svc_version *vers;\r\nunsigned int i;\r\nint error = 0;\r\nWARN_ON_ONCE(proto == 0 && port == 0);\r\nif (proto == 0 && port == 0)\r\nreturn -EINVAL;\r\nfor (progp = serv->sv_program; progp; progp = progp->pg_next) {\r\nfor (i = 0; i < progp->pg_nvers; i++) {\r\nvers = progp->pg_vers[i];\r\nif (vers == NULL)\r\ncontinue;\r\ndprintk("svc: svc_register(%sv%d, %s, %u, %u)%s\n",\r\nprogp->pg_name,\r\ni,\r\nproto == IPPROTO_UDP? "udp" : "tcp",\r\nport,\r\nfamily,\r\nvers->vs_hidden ?\r\n" (but not telling portmap)" : "");\r\nif (vers->vs_hidden)\r\ncontinue;\r\nerror = __svc_register(net, progp->pg_name, progp->pg_prog,\r\ni, family, proto, port);\r\nif (vers->vs_rpcb_optnl) {\r\nerror = 0;\r\ncontinue;\r\n}\r\nif (error < 0) {\r\nprintk(KERN_WARNING "svc: failed to register "\r\n"%sv%u RPC service (errno %d).\n",\r\nprogp->pg_name, i, -error);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn error;\r\n}\r\nstatic void __svc_unregister(struct net *net, const u32 program, const u32 version,\r\nconst char *progname)\r\n{\r\nint error;\r\nerror = rpcb_v4_register(net, program, version, NULL, "");\r\nif (error == -EPROTONOSUPPORT)\r\nerror = rpcb_register(net, program, version, 0, 0);\r\ndprintk("svc: %s(%sv%u), error %d\n",\r\n__func__, progname, version, error);\r\n}\r\nstatic void svc_unregister(const struct svc_serv *serv, struct net *net)\r\n{\r\nstruct svc_program *progp;\r\nunsigned long flags;\r\nunsigned int i;\r\nclear_thread_flag(TIF_SIGPENDING);\r\nfor (progp = serv->sv_program; progp; progp = progp->pg_next) {\r\nfor (i = 0; i < progp->pg_nvers; i++) {\r\nif (progp->pg_vers[i] == NULL)\r\ncontinue;\r\nif (progp->pg_vers[i]->vs_hidden)\r\ncontinue;\r\ndprintk("svc: attempting to unregister %sv%u\n",\r\nprogp->pg_name, i);\r\n__svc_unregister(net, progp->pg_prog, i, progp->pg_name);\r\n}\r\n}\r\nspin_lock_irqsave(&current->sighand->siglock, flags);\r\nrecalc_sigpending();\r\nspin_unlock_irqrestore(&current->sighand->siglock, flags);\r\n}\r\nint\r\nsvc_process(struct svc_rqst *rqstp)\r\n{\r\nstruct kvec *argv = &rqstp->rq_arg.head[0];\r\nstruct kvec *resv = &rqstp->rq_res.head[0];\r\nstruct svc_serv *serv = rqstp->rq_server;\r\nu32 dir;\r\nrqstp->rq_next_page = &rqstp->rq_respages[1];\r\nresv->iov_base = page_address(rqstp->rq_respages[0]);\r\nresv->iov_len = 0;\r\nrqstp->rq_res.pages = rqstp->rq_respages + 1;\r\nrqstp->rq_res.len = 0;\r\nrqstp->rq_res.page_base = 0;\r\nrqstp->rq_res.page_len = 0;\r\nrqstp->rq_res.buflen = PAGE_SIZE;\r\nrqstp->rq_res.tail[0].iov_base = NULL;\r\nrqstp->rq_res.tail[0].iov_len = 0;\r\nrqstp->rq_xid = svc_getu32(argv);\r\ndir = svc_getnl(argv);\r\nif (dir != 0) {\r\nsvc_printk(rqstp, "bad direction %d, dropping request\n", dir);\r\nserv->sv_stats->rpcbadfmt++;\r\nsvc_drop(rqstp);\r\nreturn 0;\r\n}\r\nif (svc_process_common(rqstp, argv, resv))\r\nreturn svc_send(rqstp);\r\nelse {\r\nsvc_drop(rqstp);\r\nreturn 0;\r\n}\r\n}\r\nint\r\nbc_svc_process(struct svc_serv *serv, struct rpc_rqst *req,\r\nstruct svc_rqst *rqstp)\r\n{\r\nstruct kvec *argv = &rqstp->rq_arg.head[0];\r\nstruct kvec *resv = &rqstp->rq_res.head[0];\r\nrqstp->rq_xprt = serv->sv_bc_xprt;\r\nrqstp->rq_xid = req->rq_xid;\r\nrqstp->rq_prot = req->rq_xprt->prot;\r\nrqstp->rq_server = serv;\r\nrqstp->rq_addrlen = sizeof(req->rq_xprt->addr);\r\nmemcpy(&rqstp->rq_addr, &req->rq_xprt->addr, rqstp->rq_addrlen);\r\nmemcpy(&rqstp->rq_arg, &req->rq_rcv_buf, sizeof(rqstp->rq_arg));\r\nmemcpy(&rqstp->rq_res, &req->rq_snd_buf, sizeof(rqstp->rq_res));\r\nresv->iov_len = 0;\r\nif (rqstp->rq_prot != IPPROTO_TCP) {\r\nprintk(KERN_ERR "No support for Non-TCP transports!\n");\r\nBUG();\r\n}\r\nsvc_getu32(argv);\r\nsvc_getnl(argv);\r\nif (svc_process_common(rqstp, argv, resv)) {\r\nmemcpy(&req->rq_snd_buf, &rqstp->rq_res,\r\nsizeof(req->rq_snd_buf));\r\nreturn bc_send(req);\r\n} else {\r\nxprt_free_bc_request(req);\r\nreturn 0;\r\n}\r\n}\r\nu32 svc_max_payload(const struct svc_rqst *rqstp)\r\n{\r\nu32 max = rqstp->rq_xprt->xpt_class->xcl_max_payload;\r\nif (rqstp->rq_server->sv_max_payload < max)\r\nmax = rqstp->rq_server->sv_max_payload;\r\nreturn max;\r\n}
