static int vmk80xx_check_data_link(struct comedi_device *dev)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nunsigned int tx_pipe;\r\nunsigned int rx_pipe;\r\nunsigned char tx[1];\r\nunsigned char rx[2];\r\ntx_pipe = usb_sndbulkpipe(usb, 0x01);\r\nrx_pipe = usb_rcvbulkpipe(usb, 0x81);\r\ntx[0] = VMK8061_CMD_RD_PWR_STAT;\r\nusb_bulk_msg(usb, tx_pipe, tx, 1, NULL, devpriv->ep_tx->bInterval);\r\nusb_bulk_msg(usb, rx_pipe, rx, 2, NULL, HZ * 10);\r\nreturn (int)rx[1];\r\n}\r\nstatic void vmk80xx_read_eeprom(struct comedi_device *dev, int flag)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nunsigned int tx_pipe;\r\nunsigned int rx_pipe;\r\nunsigned char tx[1];\r\nunsigned char rx[64];\r\nint cnt;\r\ntx_pipe = usb_sndbulkpipe(usb, 0x01);\r\nrx_pipe = usb_rcvbulkpipe(usb, 0x81);\r\ntx[0] = VMK8061_CMD_RD_VERSION;\r\nusb_bulk_msg(usb, tx_pipe, tx, 1, NULL, devpriv->ep_tx->bInterval);\r\nusb_bulk_msg(usb, rx_pipe, rx, 64, &cnt, HZ * 10);\r\nrx[cnt] = '\0';\r\nif (flag & IC3_VERSION)\r\nstrncpy(devpriv->fw.ic3_vers, rx + 1, 24);\r\nelse\r\nstrncpy(devpriv->fw.ic6_vers, rx + 25, 24);\r\n}\r\nstatic void vmk80xx_do_bulk_msg(struct comedi_device *dev)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\n__u8 tx_addr;\r\n__u8 rx_addr;\r\nunsigned int tx_pipe;\r\nunsigned int rx_pipe;\r\nsize_t size;\r\ntx_addr = devpriv->ep_tx->bEndpointAddress;\r\nrx_addr = devpriv->ep_rx->bEndpointAddress;\r\ntx_pipe = usb_sndbulkpipe(usb, tx_addr);\r\nrx_pipe = usb_rcvbulkpipe(usb, rx_addr);\r\nsize = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);\r\nusb_bulk_msg(usb, tx_pipe, devpriv->usb_tx_buf,\r\nsize, NULL, devpriv->ep_tx->bInterval);\r\nusb_bulk_msg(usb, rx_pipe, devpriv->usb_rx_buf, size, NULL, HZ * 10);\r\n}\r\nstatic int vmk80xx_read_packet(struct comedi_device *dev)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usb_endpoint_descriptor *ep;\r\nunsigned int pipe;\r\nif (devpriv->model == VMK8061_MODEL) {\r\nvmk80xx_do_bulk_msg(dev);\r\nreturn 0;\r\n}\r\nep = devpriv->ep_rx;\r\npipe = usb_rcvintpipe(usb, ep->bEndpointAddress);\r\nreturn usb_interrupt_msg(usb, pipe, devpriv->usb_rx_buf,\r\nle16_to_cpu(ep->wMaxPacketSize), NULL,\r\nHZ * 10);\r\n}\r\nstatic int vmk80xx_write_packet(struct comedi_device *dev, int cmd)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usb_endpoint_descriptor *ep;\r\nunsigned int pipe;\r\ndevpriv->usb_tx_buf[0] = cmd;\r\nif (devpriv->model == VMK8061_MODEL) {\r\nvmk80xx_do_bulk_msg(dev);\r\nreturn 0;\r\n}\r\nep = devpriv->ep_tx;\r\npipe = usb_sndintpipe(usb, ep->bEndpointAddress);\r\nreturn usb_interrupt_msg(usb, pipe, devpriv->usb_tx_buf,\r\nle16_to_cpu(ep->wMaxPacketSize), NULL,\r\nHZ * 10);\r\n}\r\nstatic int vmk80xx_reset_device(struct comedi_device *dev)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nsize_t size;\r\nint retval;\r\nsize = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);\r\nmemset(devpriv->usb_tx_buf, 0, size);\r\nretval = vmk80xx_write_packet(dev, VMK8055_CMD_RST);\r\nif (retval)\r\nreturn retval;\r\nreturn vmk80xx_write_packet(dev, VMK8055_CMD_WRT_AD);\r\n}\r\nstatic int vmk80xx_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nint chan;\r\nint reg[2];\r\nint n;\r\ndown(&devpriv->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\nswitch (devpriv->model) {\r\ncase VMK8055_MODEL:\r\nif (!chan)\r\nreg[0] = VMK8055_AI1_REG;\r\nelse\r\nreg[0] = VMK8055_AI2_REG;\r\nbreak;\r\ncase VMK8061_MODEL:\r\ndefault:\r\nreg[0] = VMK8061_AI_REG1;\r\nreg[1] = VMK8061_AI_REG2;\r\ndevpriv->usb_tx_buf[0] = VMK8061_CMD_RD_AI;\r\ndevpriv->usb_tx_buf[VMK8061_CH_REG] = chan;\r\nbreak;\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\nif (vmk80xx_read_packet(dev))\r\nbreak;\r\nif (devpriv->model == VMK8055_MODEL) {\r\ndata[n] = devpriv->usb_rx_buf[reg[0]];\r\ncontinue;\r\n}\r\ndata[n] = devpriv->usb_rx_buf[reg[0]] + 256 *\r\ndevpriv->usb_rx_buf[reg[1]];\r\n}\r\nup(&devpriv->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nint chan;\r\nint cmd;\r\nint reg;\r\nint n;\r\ndown(&devpriv->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\nswitch (devpriv->model) {\r\ncase VMK8055_MODEL:\r\ncmd = VMK8055_CMD_WRT_AD;\r\nif (!chan)\r\nreg = VMK8055_AO1_REG;\r\nelse\r\nreg = VMK8055_AO2_REG;\r\nbreak;\r\ndefault:\r\ncmd = VMK8061_CMD_SET_AO;\r\nreg = VMK8061_AO_REG;\r\ndevpriv->usb_tx_buf[VMK8061_CH_REG] = chan;\r\nbreak;\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\ndevpriv->usb_tx_buf[reg] = data[n];\r\nif (vmk80xx_write_packet(dev, cmd))\r\nbreak;\r\n}\r\nup(&devpriv->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nint chan;\r\nint reg;\r\nint n;\r\ndown(&devpriv->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\nreg = VMK8061_AO_REG - 1;\r\ndevpriv->usb_tx_buf[0] = VMK8061_CMD_RD_AO;\r\nfor (n = 0; n < insn->n; n++) {\r\nif (vmk80xx_read_packet(dev))\r\nbreak;\r\ndata[n] = devpriv->usb_rx_buf[reg + chan];\r\n}\r\nup(&devpriv->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nunsigned char *rx_buf;\r\nint reg;\r\nint retval;\r\ndown(&devpriv->limit_sem);\r\nrx_buf = devpriv->usb_rx_buf;\r\nif (devpriv->model == VMK8061_MODEL) {\r\nreg = VMK8061_DI_REG;\r\ndevpriv->usb_tx_buf[0] = VMK8061_CMD_RD_DI;\r\n} else {\r\nreg = VMK8055_DI_REG;\r\n}\r\nretval = vmk80xx_read_packet(dev);\r\nif (!retval) {\r\nif (devpriv->model == VMK8055_MODEL)\r\ndata[1] = (((rx_buf[reg] >> 4) & 0x03) |\r\n((rx_buf[reg] << 2) & 0x04) |\r\n((rx_buf[reg] >> 3) & 0x18));\r\nelse\r\ndata[1] = rx_buf[reg];\r\nretval = 2;\r\n}\r\nup(&devpriv->limit_sem);\r\nreturn retval;\r\n}\r\nstatic int vmk80xx_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nunsigned char *rx_buf = devpriv->usb_rx_buf;\r\nunsigned char *tx_buf = devpriv->usb_tx_buf;\r\nint reg, cmd;\r\nint ret = 0;\r\nif (devpriv->model == VMK8061_MODEL) {\r\nreg = VMK8061_DO_REG;\r\ncmd = VMK8061_CMD_DO;\r\n} else {\r\nreg = VMK8055_DO_REG;\r\ncmd = VMK8055_CMD_WRT_AD;\r\n}\r\ndown(&devpriv->limit_sem);\r\nif (comedi_dio_update_state(s, data)) {\r\ntx_buf[reg] = s->state;\r\nret = vmk80xx_write_packet(dev, cmd);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (devpriv->model == VMK8061_MODEL) {\r\ntx_buf[0] = VMK8061_CMD_RD_DO;\r\nret = vmk80xx_read_packet(dev);\r\nif (ret)\r\ngoto out;\r\ndata[1] = rx_buf[reg];\r\n} else {\r\ndata[1] = s->state;\r\n}\r\nout:\r\nup(&devpriv->limit_sem);\r\nreturn ret ? ret : insn->n;\r\n}\r\nstatic int vmk80xx_cnt_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nint chan;\r\nint reg[2];\r\nint n;\r\ndown(&devpriv->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\nswitch (devpriv->model) {\r\ncase VMK8055_MODEL:\r\nif (!chan)\r\nreg[0] = VMK8055_CNT1_REG;\r\nelse\r\nreg[0] = VMK8055_CNT2_REG;\r\nbreak;\r\ncase VMK8061_MODEL:\r\ndefault:\r\nreg[0] = VMK8061_CNT_REG;\r\nreg[1] = VMK8061_CNT_REG;\r\ndevpriv->usb_tx_buf[0] = VMK8061_CMD_RD_CNT;\r\nbreak;\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\nif (vmk80xx_read_packet(dev))\r\nbreak;\r\nif (devpriv->model == VMK8055_MODEL)\r\ndata[n] = devpriv->usb_rx_buf[reg[0]];\r\nelse\r\ndata[n] = devpriv->usb_rx_buf[reg[0] * (chan + 1) + 1]\r\n+ 256 * devpriv->usb_rx_buf[reg[1] * 2 + 2];\r\n}\r\nup(&devpriv->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_cnt_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nunsigned int insn_cmd;\r\nint chan;\r\nint cmd;\r\nint reg;\r\nint n;\r\ninsn_cmd = data[0];\r\nif (insn_cmd != INSN_CONFIG_RESET && insn_cmd != GPCT_RESET)\r\nreturn -EINVAL;\r\ndown(&devpriv->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\nif (devpriv->model == VMK8055_MODEL) {\r\nif (!chan) {\r\ncmd = VMK8055_CMD_RST_CNT1;\r\nreg = VMK8055_CNT1_REG;\r\n} else {\r\ncmd = VMK8055_CMD_RST_CNT2;\r\nreg = VMK8055_CNT2_REG;\r\n}\r\ndevpriv->usb_tx_buf[reg] = 0x00;\r\n} else {\r\ncmd = VMK8061_CMD_RST_CNT;\r\n}\r\nfor (n = 0; n < insn->n; n++)\r\nif (vmk80xx_write_packet(dev, cmd))\r\nbreak;\r\nup(&devpriv->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_cnt_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nunsigned long debtime;\r\nunsigned long val;\r\nint chan;\r\nint cmd;\r\nint n;\r\ndown(&devpriv->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\nif (!chan)\r\ncmd = VMK8055_CMD_DEB1_TIME;\r\nelse\r\ncmd = VMK8055_CMD_DEB2_TIME;\r\nfor (n = 0; n < insn->n; n++) {\r\ndebtime = data[n];\r\nif (debtime == 0)\r\ndebtime = 1;\r\nif (debtime > 7450)\r\ndebtime = 7450;\r\nval = int_sqrt(debtime * 1000 / 115);\r\nif (((val + 1) * val) < debtime * 1000 / 115)\r\nval += 1;\r\ndevpriv->usb_tx_buf[6 + chan] = val;\r\nif (vmk80xx_write_packet(dev, cmd))\r\nbreak;\r\n}\r\nup(&devpriv->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_pwm_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nunsigned char *tx_buf;\r\nunsigned char *rx_buf;\r\nint reg[2];\r\nint n;\r\ndown(&devpriv->limit_sem);\r\ntx_buf = devpriv->usb_tx_buf;\r\nrx_buf = devpriv->usb_rx_buf;\r\nreg[0] = VMK8061_PWM_REG1;\r\nreg[1] = VMK8061_PWM_REG2;\r\ntx_buf[0] = VMK8061_CMD_RD_PWM;\r\nfor (n = 0; n < insn->n; n++) {\r\nif (vmk80xx_read_packet(dev))\r\nbreak;\r\ndata[n] = rx_buf[reg[0]] + 4 * rx_buf[reg[1]];\r\n}\r\nup(&devpriv->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_pwm_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nunsigned char *tx_buf;\r\nint reg[2];\r\nint cmd;\r\nint n;\r\ndown(&devpriv->limit_sem);\r\ntx_buf = devpriv->usb_tx_buf;\r\nreg[0] = VMK8061_PWM_REG1;\r\nreg[1] = VMK8061_PWM_REG2;\r\ncmd = VMK8061_CMD_OUT_PWM;\r\nfor (n = 0; n < insn->n; n++) {\r\ntx_buf[reg[0]] = (unsigned char)(data[n] & 0x03);\r\ntx_buf[reg[1]] = (unsigned char)(data[n] >> 2) & 0xff;\r\nif (vmk80xx_write_packet(dev, cmd))\r\nbreak;\r\n}\r\nup(&devpriv->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_find_usb_endpoints(struct comedi_device *dev)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct usb_host_interface *iface_desc = intf->cur_altsetting;\r\nstruct usb_endpoint_descriptor *ep_desc;\r\nint i;\r\nif (iface_desc->desc.bNumEndpoints != 2)\r\nreturn -ENODEV;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\r\nep_desc = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(ep_desc) ||\r\nusb_endpoint_is_bulk_in(ep_desc)) {\r\nif (!devpriv->ep_rx)\r\ndevpriv->ep_rx = ep_desc;\r\ncontinue;\r\n}\r\nif (usb_endpoint_is_int_out(ep_desc) ||\r\nusb_endpoint_is_bulk_out(ep_desc)) {\r\nif (!devpriv->ep_tx)\r\ndevpriv->ep_tx = ep_desc;\r\ncontinue;\r\n}\r\n}\r\nif (!devpriv->ep_rx || !devpriv->ep_tx)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int vmk80xx_alloc_usb_buffers(struct comedi_device *dev)\r\n{\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nsize_t size;\r\nsize = le16_to_cpu(devpriv->ep_rx->wMaxPacketSize);\r\ndevpriv->usb_rx_buf = kzalloc(size, GFP_KERNEL);\r\nif (!devpriv->usb_rx_buf)\r\nreturn -ENOMEM;\r\nsize = le16_to_cpu(devpriv->ep_tx->wMaxPacketSize);\r\ndevpriv->usb_tx_buf = kzalloc(size, GFP_KERNEL);\r\nif (!devpriv->usb_tx_buf) {\r\nkfree(devpriv->usb_rx_buf);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmk80xx_init_subdevices(struct comedi_device *dev)\r\n{\r\nconst struct vmk80xx_board *boardinfo = comedi_board(dev);\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s;\r\nint n_subd;\r\nint ret;\r\ndown(&devpriv->limit_sem);\r\nif (devpriv->model == VMK8055_MODEL)\r\nn_subd = 5;\r\nelse\r\nn_subd = 6;\r\nret = comedi_alloc_subdevices(dev, n_subd);\r\nif (ret) {\r\nup(&devpriv->limit_sem);\r\nreturn ret;\r\n}\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\ns->n_chan = boardinfo->ai_nchans;\r\ns->maxdata = boardinfo->ai_maxdata;\r\ns->range_table = boardinfo->range;\r\ns->insn_read = vmk80xx_ai_insn_read;\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITEABLE | SDF_GROUND;\r\ns->n_chan = boardinfo->ao_nchans;\r\ns->maxdata = 0x00ff;\r\ns->range_table = boardinfo->range;\r\ns->insn_write = vmk80xx_ao_insn_write;\r\nif (devpriv->model == VMK8061_MODEL) {\r\ns->subdev_flags |= SDF_READABLE;\r\ns->insn_read = vmk80xx_ao_insn_read;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = boardinfo->di_nchans;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = vmk80xx_di_insn_bits;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITEABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = vmk80xx_do_insn_bits;\r\ns = &dev->subdevices[4];\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 2;\r\ns->maxdata = boardinfo->cnt_maxdata;\r\ns->insn_read = vmk80xx_cnt_insn_read;\r\ns->insn_config = vmk80xx_cnt_insn_config;\r\nif (devpriv->model == VMK8055_MODEL) {\r\ns->subdev_flags |= SDF_WRITEABLE;\r\ns->insn_write = vmk80xx_cnt_insn_write;\r\n}\r\nif (devpriv->model == VMK8061_MODEL) {\r\ns = &dev->subdevices[5];\r\ns->type = COMEDI_SUBD_PWM;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITEABLE;\r\ns->n_chan = boardinfo->pwm_nchans;\r\ns->maxdata = boardinfo->pwm_maxdata;\r\ns->insn_read = vmk80xx_pwm_insn_read;\r\ns->insn_write = vmk80xx_pwm_insn_write;\r\n}\r\nup(&devpriv->limit_sem);\r\nreturn 0;\r\n}\r\nstatic int vmk80xx_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nconst struct vmk80xx_board *boardinfo;\r\nstruct vmk80xx_private *devpriv;\r\nint ret;\r\nboardinfo = &vmk80xx_boardinfo[context];\r\ndev->board_ptr = boardinfo;\r\ndev->board_name = boardinfo->name;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ndevpriv->model = boardinfo->model;\r\nret = vmk80xx_find_usb_endpoints(dev);\r\nif (ret)\r\nreturn ret;\r\nret = vmk80xx_alloc_usb_buffers(dev);\r\nif (ret)\r\nreturn ret;\r\nsema_init(&devpriv->limit_sem, 8);\r\nusb_set_intfdata(intf, devpriv);\r\nif (devpriv->model == VMK8061_MODEL) {\r\nvmk80xx_read_eeprom(dev, IC3_VERSION);\r\ndev_info(&intf->dev, "%s\n", devpriv->fw.ic3_vers);\r\nif (vmk80xx_check_data_link(dev)) {\r\nvmk80xx_read_eeprom(dev, IC6_VERSION);\r\ndev_info(&intf->dev, "%s\n", devpriv->fw.ic6_vers);\r\n}\r\n}\r\nif (devpriv->model == VMK8055_MODEL)\r\nvmk80xx_reset_device(dev);\r\nreturn vmk80xx_init_subdevices(dev);\r\n}\r\nstatic void vmk80xx_detach(struct comedi_device *dev)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct vmk80xx_private *devpriv = dev->private;\r\nif (!devpriv)\r\nreturn;\r\ndown(&devpriv->limit_sem);\r\nusb_set_intfdata(intf, NULL);\r\nkfree(devpriv->usb_rx_buf);\r\nkfree(devpriv->usb_tx_buf);\r\nup(&devpriv->limit_sem);\r\n}\r\nstatic int vmk80xx_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn comedi_usb_auto_config(intf, &vmk80xx_driver, id->driver_info);\r\n}
