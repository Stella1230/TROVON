void ax25_register_pid(struct ax25_protocol *ap)\r\n{\r\nwrite_lock_bh(&protocol_list_lock);\r\nap->next = protocol_list;\r\nprotocol_list = ap;\r\nwrite_unlock_bh(&protocol_list_lock);\r\n}\r\nvoid ax25_protocol_release(unsigned int pid)\r\n{\r\nstruct ax25_protocol *protocol;\r\nwrite_lock_bh(&protocol_list_lock);\r\nprotocol = protocol_list;\r\nif (protocol == NULL)\r\ngoto out;\r\nif (protocol->pid == pid) {\r\nprotocol_list = protocol->next;\r\ngoto out;\r\n}\r\nwhile (protocol != NULL && protocol->next != NULL) {\r\nif (protocol->next->pid == pid) {\r\nprotocol->next = protocol->next->next;\r\ngoto out;\r\n}\r\nprotocol = protocol->next;\r\n}\r\nout:\r\nwrite_unlock_bh(&protocol_list_lock);\r\n}\r\nvoid ax25_linkfail_register(struct ax25_linkfail *lf)\r\n{\r\nspin_lock_bh(&linkfail_lock);\r\nhlist_add_head(&lf->lf_node, &ax25_linkfail_list);\r\nspin_unlock_bh(&linkfail_lock);\r\n}\r\nvoid ax25_linkfail_release(struct ax25_linkfail *lf)\r\n{\r\nspin_lock_bh(&linkfail_lock);\r\nhlist_del_init(&lf->lf_node);\r\nspin_unlock_bh(&linkfail_lock);\r\n}\r\nint ax25_listen_register(ax25_address *callsign, struct net_device *dev)\r\n{\r\nstruct listen_struct *listen;\r\nif (ax25_listen_mine(callsign, dev))\r\nreturn 0;\r\nif ((listen = kmalloc(sizeof(*listen), GFP_ATOMIC)) == NULL)\r\nreturn -ENOMEM;\r\nlisten->callsign = *callsign;\r\nlisten->dev = dev;\r\nspin_lock_bh(&listen_lock);\r\nlisten->next = listen_list;\r\nlisten_list = listen;\r\nspin_unlock_bh(&listen_lock);\r\nreturn 0;\r\n}\r\nvoid ax25_listen_release(ax25_address *callsign, struct net_device *dev)\r\n{\r\nstruct listen_struct *s, *listen;\r\nspin_lock_bh(&listen_lock);\r\nlisten = listen_list;\r\nif (listen == NULL) {\r\nspin_unlock_bh(&listen_lock);\r\nreturn;\r\n}\r\nif (ax25cmp(&listen->callsign, callsign) == 0 && listen->dev == dev) {\r\nlisten_list = listen->next;\r\nspin_unlock_bh(&listen_lock);\r\nkfree(listen);\r\nreturn;\r\n}\r\nwhile (listen != NULL && listen->next != NULL) {\r\nif (ax25cmp(&listen->next->callsign, callsign) == 0 && listen->next->dev == dev) {\r\ns = listen->next;\r\nlisten->next = listen->next->next;\r\nspin_unlock_bh(&listen_lock);\r\nkfree(s);\r\nreturn;\r\n}\r\nlisten = listen->next;\r\n}\r\nspin_unlock_bh(&listen_lock);\r\n}\r\nvoid ax25_link_failed(ax25_cb *ax25, int reason)\r\n{\r\nstruct ax25_linkfail *lf;\r\nspin_lock_bh(&linkfail_lock);\r\nhlist_for_each_entry(lf, &ax25_linkfail_list, lf_node)\r\nlf->func(ax25, reason);\r\nspin_unlock_bh(&linkfail_lock);\r\n}\r\nint ax25_protocol_is_registered(unsigned int pid)\r\n{\r\nstruct ax25_protocol *protocol;\r\nint res = 0;\r\nread_lock_bh(&protocol_list_lock);\r\nfor (protocol = protocol_list; protocol != NULL; protocol = protocol->next)\r\nif (protocol->pid == pid) {\r\nres = 1;\r\nbreak;\r\n}\r\nread_unlock_bh(&protocol_list_lock);\r\nreturn res;\r\n}
