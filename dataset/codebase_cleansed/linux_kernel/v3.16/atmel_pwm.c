static inline void pwm_writel(const struct pwm *p, unsigned offset, u32 val)\r\n{\r\n__raw_writel(val, p->base + offset);\r\n}\r\nstatic inline u32 pwm_readl(const struct pwm *p, unsigned offset)\r\n{\r\nreturn __raw_readl(p->base + offset);\r\n}\r\nstatic inline void __iomem *pwmc_regs(const struct pwm *p, int index)\r\n{\r\nreturn p->base + 0x200 + index * 0x20;\r\n}\r\nstatic void pwm_dumpregs(struct pwm_channel *ch, char *tag)\r\n{\r\nstruct device *dev = &pwm->pdev->dev;\r\ndev_dbg(dev, "%s: mr %08x, sr %08x, imr %08x\n",\r\ntag,\r\npwm_readl(pwm, PWM_MR),\r\npwm_readl(pwm, PWM_SR),\r\npwm_readl(pwm, PWM_IMR));\r\ndev_dbg(dev,\r\n"pwm ch%d - mr %08x, dty %u, prd %u, cnt %u\n",\r\nch->index,\r\npwm_channel_readl(ch, PWM_CMR),\r\npwm_channel_readl(ch, PWM_CDTY),\r\npwm_channel_readl(ch, PWM_CPRD),\r\npwm_channel_readl(ch, PWM_CCNT));\r\n}\r\nint pwm_channel_alloc(int index, struct pwm_channel *ch)\r\n{\r\nunsigned long flags;\r\nint status = 0;\r\nif (!pwm)\r\nreturn -EPROBE_DEFER;\r\nif (!(pwm->mask & 1 << index))\r\nreturn -ENODEV;\r\nif (index < 0 || index >= PWM_NCHAN || !ch)\r\nreturn -EINVAL;\r\nmemset(ch, 0, sizeof *ch);\r\nspin_lock_irqsave(&pwm->lock, flags);\r\nif (pwm->channel[index])\r\nstatus = -EBUSY;\r\nelse {\r\nclk_enable(pwm->clk);\r\nch->regs = pwmc_regs(pwm, index);\r\nch->index = index;\r\nch->mck = clk_get_rate(pwm->clk);\r\npwm->channel[index] = ch;\r\npwm->handler[index] = NULL;\r\npwm_writel(pwm, PWM_DIS, 1 << index);\r\npwm_writel(pwm, PWM_IDR, 1 << index);\r\n}\r\nspin_unlock_irqrestore(&pwm->lock, flags);\r\nreturn status;\r\n}\r\nstatic int pwmcheck(struct pwm_channel *ch)\r\n{\r\nint index;\r\nif (!pwm)\r\nreturn -ENODEV;\r\nif (!ch)\r\nreturn -EINVAL;\r\nindex = ch->index;\r\nif (index < 0 || index >= PWM_NCHAN || pwm->channel[index] != ch)\r\nreturn -EINVAL;\r\nreturn index;\r\n}\r\nint pwm_channel_free(struct pwm_channel *ch)\r\n{\r\nunsigned long flags;\r\nint t;\r\nspin_lock_irqsave(&pwm->lock, flags);\r\nt = pwmcheck(ch);\r\nif (t >= 0) {\r\npwm->channel[t] = NULL;\r\npwm->handler[t] = NULL;\r\npwm_writel(pwm, PWM_DIS, 1 << t);\r\npwm_writel(pwm, PWM_IDR, 1 << t);\r\nclk_disable(pwm->clk);\r\nt = 0;\r\n}\r\nspin_unlock_irqrestore(&pwm->lock, flags);\r\nreturn t;\r\n}\r\nint __pwm_channel_onoff(struct pwm_channel *ch, int enabled)\r\n{\r\nunsigned long flags;\r\nint t;\r\nspin_lock_irqsave(&pwm->lock, flags);\r\nt = pwmcheck(ch);\r\nif (t >= 0) {\r\npwm_writel(pwm, enabled ? PWM_ENA : PWM_DIS, 1 << t);\r\nt = 0;\r\npwm_dumpregs(ch, enabled ? "enable" : "disable");\r\n}\r\nspin_unlock_irqrestore(&pwm->lock, flags);\r\nreturn t;\r\n}\r\nint pwm_clk_alloc(unsigned prescale, unsigned div)\r\n{\r\nunsigned long flags;\r\nu32 mr;\r\nu32 val = (prescale << 8) | div;\r\nint ret = -EBUSY;\r\nif (prescale >= 10 || div == 0 || div > 255)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&pwm->lock, flags);\r\nmr = pwm_readl(pwm, PWM_MR);\r\nif ((mr & 0xffff) == 0) {\r\nmr |= val;\r\nret = PWM_CPR_CLKA;\r\n} else if ((mr & (0xffff << 16)) == 0) {\r\nmr |= val << 16;\r\nret = PWM_CPR_CLKB;\r\n}\r\nif (ret > 0)\r\npwm_writel(pwm, PWM_MR, mr);\r\nspin_unlock_irqrestore(&pwm->lock, flags);\r\nreturn ret;\r\n}\r\nvoid pwm_clk_free(unsigned clk)\r\n{\r\nunsigned long flags;\r\nu32 mr;\r\nspin_lock_irqsave(&pwm->lock, flags);\r\nmr = pwm_readl(pwm, PWM_MR);\r\nif (clk == PWM_CPR_CLKA)\r\npwm_writel(pwm, PWM_MR, mr & ~(0xffff << 0));\r\nif (clk == PWM_CPR_CLKB)\r\npwm_writel(pwm, PWM_MR, mr & ~(0xffff << 16));\r\nspin_unlock_irqrestore(&pwm->lock, flags);\r\n}\r\nint pwm_channel_handler(struct pwm_channel *ch,\r\nvoid (*handler)(struct pwm_channel *ch))\r\n{\r\nunsigned long flags;\r\nint t;\r\nspin_lock_irqsave(&pwm->lock, flags);\r\nt = pwmcheck(ch);\r\nif (t >= 0) {\r\npwm->handler[t] = handler;\r\npwm_writel(pwm, handler ? PWM_IER : PWM_IDR, 1 << t);\r\nt = 0;\r\n}\r\nspin_unlock_irqrestore(&pwm->lock, flags);\r\nreturn t;\r\n}\r\nstatic irqreturn_t pwm_irq(int id, void *_pwm)\r\n{\r\nstruct pwm *p = _pwm;\r\nirqreturn_t handled = IRQ_NONE;\r\nu32 irqstat;\r\nint index;\r\nspin_lock(&p->lock);\r\nirqstat = pwm_readl(pwm, PWM_ISR);\r\nwhile (irqstat) {\r\nstruct pwm_channel *ch;\r\nvoid (*handler)(struct pwm_channel *ch);\r\nindex = ffs(irqstat) - 1;\r\nirqstat &= ~(1 << index);\r\nch = pwm->channel[index];\r\nhandler = pwm->handler[index];\r\nif (handler && ch) {\r\nspin_unlock(&p->lock);\r\nhandler(ch);\r\nspin_lock(&p->lock);\r\nhandled = IRQ_HANDLED;\r\n}\r\n}\r\nspin_unlock(&p->lock);\r\nreturn handled;\r\n}\r\nstatic int __init pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nint irq = platform_get_irq(pdev, 0);\r\nu32 *mp = pdev->dev.platform_data;\r\nstruct pwm *p;\r\nint status = -EIO;\r\nif (pwm)\r\nreturn -EBUSY;\r\nif (!r || irq < 0 || !mp || !*mp)\r\nreturn -ENODEV;\r\nif (*mp & ~((1<<PWM_NCHAN)-1)) {\r\ndev_warn(&pdev->dev, "mask 0x%x ... more than %d channels\n",\r\n*mp, PWM_NCHAN);\r\nreturn -EINVAL;\r\n}\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\nspin_lock_init(&p->lock);\r\np->pdev = pdev;\r\np->mask = *mp;\r\np->irq = irq;\r\np->base = ioremap(r->start, resource_size(r));\r\nif (!p->base)\r\ngoto fail;\r\np->clk = clk_get(&pdev->dev, "pwm_clk");\r\nif (IS_ERR(p->clk)) {\r\nstatus = PTR_ERR(p->clk);\r\np->clk = NULL;\r\ngoto fail;\r\n}\r\nstatus = request_irq(irq, pwm_irq, 0, pdev->name, p);\r\nif (status < 0)\r\ngoto fail;\r\npwm = p;\r\nplatform_set_drvdata(pdev, p);\r\nreturn 0;\r\nfail:\r\nif (p->clk)\r\nclk_put(p->clk);\r\nif (p->base)\r\niounmap(p->base);\r\nkfree(p);\r\nreturn status;\r\n}\r\nstatic int __exit pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct pwm *p = platform_get_drvdata(pdev);\r\nif (p != pwm)\r\nreturn -EINVAL;\r\nclk_enable(pwm->clk);\r\npwm_writel(pwm, PWM_DIS, (1 << PWM_NCHAN) - 1);\r\npwm_writel(pwm, PWM_IDR, (1 << PWM_NCHAN) - 1);\r\nclk_disable(pwm->clk);\r\npwm = NULL;\r\nfree_irq(p->irq, p);\r\nclk_put(p->clk);\r\niounmap(p->base);\r\nkfree(p);\r\nreturn 0;\r\n}
