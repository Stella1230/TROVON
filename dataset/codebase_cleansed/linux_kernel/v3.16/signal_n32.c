asmlinkage void sysn32_rt_sigreturn(nabi_no_regargs struct pt_regs regs)\r\n{\r\nstruct rt_sigframe_n32 __user *frame;\r\nsigset_t set;\r\nint sig;\r\nframe = (struct rt_sigframe_n32 __user *) regs.regs[29];\r\nif (!access_ok(VERIFY_READ, frame, sizeof(*frame)))\r\ngoto badframe;\r\nif (__copy_conv_sigset_from_user(&set, &frame->rs_uc.uc_sigmask))\r\ngoto badframe;\r\nset_current_blocked(&set);\r\nsig = restore_sigcontext(&regs, &frame->rs_uc.uc_mcontext);\r\nif (sig < 0)\r\ngoto badframe;\r\nelse if (sig)\r\nforce_sig(sig, current);\r\nif (compat_restore_altstack(&frame->rs_uc.uc_stack))\r\ngoto badframe;\r\n__asm__ __volatile__(\r\n"move\t$29, %0\n\t"\r\n"j\tsyscall_exit"\r\n:\r\n:"r" (&regs));\r\nbadframe:\r\nforce_sig(SIGSEGV, current);\r\n}\r\nstatic int setup_rt_frame_n32(void *sig_return, struct k_sigaction *ka,\r\nstruct pt_regs *regs, int signr, sigset_t *set, siginfo_t *info)\r\n{\r\nstruct rt_sigframe_n32 __user *frame;\r\nint err = 0;\r\nframe = get_sigframe(ka, regs, sizeof(*frame));\r\nif (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))\r\ngoto give_sigsegv;\r\nerr |= copy_siginfo_to_user32(&frame->rs_info, info);\r\nerr |= __put_user(0, &frame->rs_uc.uc_flags);\r\nerr |= __put_user(0, &frame->rs_uc.uc_link);\r\nerr |= __compat_save_altstack(&frame->rs_uc.uc_stack, regs->regs[29]);\r\nerr |= setup_sigcontext(regs, &frame->rs_uc.uc_mcontext);\r\nerr |= __copy_conv_sigset_to_user(&frame->rs_uc.uc_sigmask, set);\r\nif (err)\r\ngoto give_sigsegv;\r\nregs->regs[ 4] = signr;\r\nregs->regs[ 5] = (unsigned long) &frame->rs_info;\r\nregs->regs[ 6] = (unsigned long) &frame->rs_uc;\r\nregs->regs[29] = (unsigned long) frame;\r\nregs->regs[31] = (unsigned long) sig_return;\r\nregs->cp0_epc = regs->regs[25] = (unsigned long) ka->sa.sa_handler;\r\nDEBUGP("SIG deliver (%s:%d): sp=0x%p pc=0x%lx ra=0x%lx\n",\r\ncurrent->comm, current->pid,\r\nframe, regs->cp0_epc, regs->regs[31]);\r\nreturn 0;\r\ngive_sigsegv:\r\nforce_sigsegv(signr, current);\r\nreturn -EFAULT;\r\n}
