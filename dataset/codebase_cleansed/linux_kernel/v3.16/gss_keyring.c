static inline void keyring_upcall_lock(struct gss_sec_keyring *gsec_kr)\r\n{\r\n#ifdef HAVE_KEYRING_UPCALL_SERIALIZED\r\nmutex_lock(&gsec_kr->gsk_uc_lock);\r\n#endif\r\n}\r\nstatic inline void keyring_upcall_unlock(struct gss_sec_keyring *gsec_kr)\r\n{\r\n#ifdef HAVE_KEYRING_UPCALL_SERIALIZED\r\nmutex_unlock(&gsec_kr->gsk_uc_lock);\r\n#endif\r\n}\r\nstatic inline void key_revoke_locked(struct key *key)\r\n{\r\nset_bit(KEY_FLAG_REVOKED, &key->flags);\r\n}\r\nstatic void ctx_upcall_timeout_kr(unsigned long data)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = (struct ptlrpc_cli_ctx *) data;\r\nstruct key *key = ctx2gctx_keyring(ctx)->gck_key;\r\nCWARN("ctx %p, key %p\n", ctx, key);\r\nLASSERT(key);\r\ncli_ctx_expire(ctx);\r\nkey_revoke_locked(key);\r\n}\r\nstatic\r\nvoid ctx_start_timer_kr(struct ptlrpc_cli_ctx *ctx, long timeout)\r\n{\r\nstruct gss_cli_ctx_keyring *gctx_kr = ctx2gctx_keyring(ctx);\r\nstruct timer_list *timer = gctx_kr->gck_timer;\r\nLASSERT(timer);\r\nCDEBUG(D_SEC, "ctx %p: start timer %lds\n", ctx, timeout);\r\ntimeout = timeout * HZ + cfs_time_current();\r\ninit_timer(timer);\r\ntimer->expires = timeout;\r\ntimer->data = (unsigned long) ctx;\r\ntimer->function = ctx_upcall_timeout_kr;\r\nadd_timer(timer);\r\n}\r\nstatic\r\nvoid ctx_clear_timer_kr(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nstruct gss_cli_ctx_keyring *gctx_kr = ctx2gctx_keyring(ctx);\r\nstruct timer_list *timer = gctx_kr->gck_timer;\r\nif (timer == NULL)\r\nreturn;\r\nCDEBUG(D_SEC, "ctx %p, key %p\n", ctx, gctx_kr->gck_key);\r\ngctx_kr->gck_timer = NULL;\r\ndel_singleshot_timer_sync(timer);\r\nOBD_FREE_PTR(timer);\r\n}\r\nstatic\r\nstruct ptlrpc_cli_ctx *ctx_create_kr(struct ptlrpc_sec *sec,\r\nstruct vfs_cred *vcred)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx;\r\nstruct gss_cli_ctx_keyring *gctx_kr;\r\nOBD_ALLOC_PTR(gctx_kr);\r\nif (gctx_kr == NULL)\r\nreturn NULL;\r\nOBD_ALLOC_PTR(gctx_kr->gck_timer);\r\nif (gctx_kr->gck_timer == NULL) {\r\nOBD_FREE_PTR(gctx_kr);\r\nreturn NULL;\r\n}\r\ninit_timer(gctx_kr->gck_timer);\r\nctx = &gctx_kr->gck_base.gc_base;\r\nif (gss_cli_ctx_init_common(sec, ctx, &gss_keyring_ctxops, vcred)) {\r\nOBD_FREE_PTR(gctx_kr->gck_timer);\r\nOBD_FREE_PTR(gctx_kr);\r\nreturn NULL;\r\n}\r\nctx->cc_expire = cfs_time_current_sec() + KEYRING_UPCALL_TIMEOUT;\r\nclear_bit(PTLRPC_CTX_NEW_BIT, &ctx->cc_flags);\r\natomic_inc(&ctx->cc_refcount);\r\nreturn ctx;\r\n}\r\nstatic void ctx_destroy_kr(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nstruct ptlrpc_sec *sec = ctx->cc_sec;\r\nstruct gss_cli_ctx_keyring *gctx_kr = ctx2gctx_keyring(ctx);\r\nCDEBUG(D_SEC, "destroying ctx %p\n", ctx);\r\nLASSERT(sec);\r\nLASSERT(atomic_read(&sec->ps_refcount) > 0);\r\nLASSERT(atomic_read(&sec->ps_nctx) > 0);\r\nLASSERT(test_bit(PTLRPC_CTX_CACHED_BIT, &ctx->cc_flags) == 0);\r\nLASSERT(gctx_kr->gck_key == NULL);\r\nctx_clear_timer_kr(ctx);\r\nLASSERT(gctx_kr->gck_timer == NULL);\r\nif (gss_cli_ctx_fini_common(sec, ctx))\r\nreturn;\r\nOBD_FREE_PTR(gctx_kr);\r\natomic_dec(&sec->ps_nctx);\r\nsptlrpc_sec_put(sec);\r\n}\r\nstatic void ctx_release_kr(struct ptlrpc_cli_ctx *ctx, int sync)\r\n{\r\nif (sync) {\r\nctx_destroy_kr(ctx);\r\n} else {\r\natomic_inc(&ctx->cc_refcount);\r\nsptlrpc_gc_add_ctx(ctx);\r\n}\r\n}\r\nstatic void ctx_put_kr(struct ptlrpc_cli_ctx *ctx, int sync)\r\n{\r\nLASSERT(atomic_read(&ctx->cc_refcount) > 0);\r\nif (atomic_dec_and_test(&ctx->cc_refcount))\r\nctx_release_kr(ctx, sync);\r\n}\r\nstatic inline void spin_lock_if(spinlock_t *lock, int condition)\r\n{\r\nif (condition)\r\nspin_lock(lock);\r\n}\r\nstatic inline void spin_unlock_if(spinlock_t *lock, int condition)\r\n{\r\nif (condition)\r\nspin_unlock(lock);\r\n}\r\nstatic void ctx_enlist_kr(struct ptlrpc_cli_ctx *ctx, int is_root, int locked)\r\n{\r\nstruct ptlrpc_sec *sec = ctx->cc_sec;\r\nstruct gss_sec_keyring *gsec_kr = sec2gsec_keyring(sec);\r\nLASSERT(!test_bit(PTLRPC_CTX_CACHED_BIT, &ctx->cc_flags));\r\nLASSERT(atomic_read(&ctx->cc_refcount) > 0);\r\nspin_lock_if(&sec->ps_lock, !locked);\r\natomic_inc(&ctx->cc_refcount);\r\nset_bit(PTLRPC_CTX_CACHED_BIT, &ctx->cc_flags);\r\nhlist_add_head(&ctx->cc_cache, &gsec_kr->gsk_clist);\r\nif (is_root)\r\ngsec_kr->gsk_root_ctx = ctx;\r\nspin_unlock_if(&sec->ps_lock, !locked);\r\n}\r\nstatic int ctx_unlist_kr(struct ptlrpc_cli_ctx *ctx, int locked)\r\n{\r\nstruct ptlrpc_sec *sec = ctx->cc_sec;\r\nstruct gss_sec_keyring *gsec_kr = sec2gsec_keyring(sec);\r\nif (test_and_clear_bit(PTLRPC_CTX_CACHED_BIT, &ctx->cc_flags) == 0)\r\nreturn 0;\r\nspin_lock_if(&sec->ps_lock, !locked);\r\nif (gsec_kr->gsk_root_ctx == ctx)\r\ngsec_kr->gsk_root_ctx = NULL;\r\nhlist_del_init(&ctx->cc_cache);\r\natomic_dec(&ctx->cc_refcount);\r\nspin_unlock_if(&sec->ps_lock, !locked);\r\nreturn 1;\r\n}\r\nstatic void bind_key_ctx(struct key *key, struct ptlrpc_cli_ctx *ctx)\r\n{\r\nLASSERT(atomic_read(&ctx->cc_refcount) > 0);\r\nLASSERT(atomic_read(&key->usage) > 0);\r\nLASSERT(ctx2gctx_keyring(ctx)->gck_key == NULL);\r\nLASSERT(key->payload.data == NULL);\r\nkey_get(key);\r\natomic_inc(&ctx->cc_refcount);\r\nctx2gctx_keyring(ctx)->gck_key = key;\r\nkey->payload.data = ctx;\r\n}\r\nstatic void unbind_key_ctx(struct key *key, struct ptlrpc_cli_ctx *ctx)\r\n{\r\nLASSERT(key->payload.data == ctx);\r\nLASSERT(test_bit(PTLRPC_CTX_CACHED_BIT, &ctx->cc_flags) == 0);\r\nkey_revoke_locked(key);\r\nkey->payload.data = NULL;\r\nctx2gctx_keyring(ctx)->gck_key = NULL;\r\nctx_clear_timer_kr(ctx);\r\nctx_put_kr(ctx, 1);\r\nkey_put(key);\r\n}\r\nstatic void unbind_ctx_kr(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nstruct key *key = ctx2gctx_keyring(ctx)->gck_key;\r\nif (key) {\r\nLASSERT(key->payload.data == ctx);\r\nkey_get(key);\r\ndown_write(&key->sem);\r\nunbind_key_ctx(key, ctx);\r\nup_write(&key->sem);\r\nkey_put(key);\r\n}\r\n}\r\nstatic void unbind_key_locked(struct key *key)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = key->payload.data;\r\nif (ctx)\r\nunbind_key_ctx(key, ctx);\r\n}\r\nstatic void kill_ctx_kr(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nif (ctx_unlist_kr(ctx, 0))\r\nunbind_ctx_kr(ctx);\r\n}\r\nstatic void kill_key_locked(struct key *key)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = key->payload.data;\r\nif (ctx && ctx_unlist_kr(ctx, 0))\r\nunbind_key_locked(key);\r\n}\r\nstatic void dispose_ctx_list_kr(struct hlist_head *freelist)\r\n{\r\nstruct hlist_node *next;\r\nstruct ptlrpc_cli_ctx *ctx;\r\nstruct gss_cli_ctx *gctx;\r\nhlist_for_each_entry_safe(ctx, next, freelist, cc_cache) {\r\nhlist_del_init(&ctx->cc_cache);\r\ngctx = ctx2gctx(ctx);\r\nif (!rawobj_empty(&gctx->gc_svc_handle) &&\r\nsec_is_reverse(gctx->gc_base.cc_sec)) {\r\ngss_svc_upcall_update_sequence(&gctx->gc_svc_handle,\r\n(__u32) atomic_read(&gctx->gc_seq));\r\n}\r\nsptlrpc_cli_ctx_wakeup(ctx);\r\nunbind_ctx_kr(ctx);\r\nctx_put_kr(ctx, 0);\r\n}\r\n}\r\nstatic\r\nstruct ptlrpc_cli_ctx * sec_lookup_root_ctx_kr(struct ptlrpc_sec *sec)\r\n{\r\nstruct gss_sec_keyring *gsec_kr = sec2gsec_keyring(sec);\r\nstruct ptlrpc_cli_ctx *ctx = NULL;\r\nspin_lock(&sec->ps_lock);\r\nctx = gsec_kr->gsk_root_ctx;\r\nif (ctx == NULL && unlikely(sec_is_reverse(sec))) {\r\nstruct ptlrpc_cli_ctx *tmp;\r\nhlist_for_each_entry(tmp, &gsec_kr->gsk_clist, cc_cache) {\r\nif (ctx == NULL || ctx->cc_expire == 0 ||\r\nctx->cc_expire > tmp->cc_expire) {\r\nctx = tmp;\r\ngsec_kr->gsk_root_ctx = ctx;\r\n}\r\n}\r\n}\r\nif (ctx) {\r\nLASSERT(atomic_read(&ctx->cc_refcount) > 0);\r\nLASSERT(!hlist_empty(&gsec_kr->gsk_clist));\r\natomic_inc(&ctx->cc_refcount);\r\n}\r\nspin_unlock(&sec->ps_lock);\r\nreturn ctx;\r\n}\r\nstatic\r\nvoid rvs_sec_install_root_ctx_kr(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_cli_ctx *new_ctx,\r\nstruct key *key)\r\n{\r\nstruct gss_sec_keyring *gsec_kr = sec2gsec_keyring(sec);\r\nstruct ptlrpc_cli_ctx *ctx;\r\ncfs_time_t now;\r\nLASSERT(sec_is_reverse(sec));\r\nspin_lock(&sec->ps_lock);\r\nnow = cfs_time_current_sec();\r\nhlist_for_each_entry(ctx, &gsec_kr->gsk_clist, cc_cache) {\r\nif (ctx->cc_expire > now + RVS_CTX_EXPIRE_NICE) {\r\nctx->cc_early_expire = 1;\r\nctx->cc_expire = now + RVS_CTX_EXPIRE_NICE;\r\n}\r\n}\r\nctx_enlist_kr(new_ctx, gsec_kr->gsk_root_ctx ? 0 : 1, 1);\r\nif (key)\r\nbind_key_ctx(key, new_ctx);\r\nspin_unlock(&sec->ps_lock);\r\n}\r\nstatic void construct_key_desc(void *buf, int bufsize,\r\nstruct ptlrpc_sec *sec, uid_t uid)\r\n{\r\nsnprintf(buf, bufsize, "%d@%x", uid, sec->ps_id);\r\n((char *)buf)[bufsize - 1] = '\0';\r\n}\r\nstatic\r\nstruct ptlrpc_sec * gss_sec_create_kr(struct obd_import *imp,\r\nstruct ptlrpc_svc_ctx *svcctx,\r\nstruct sptlrpc_flavor *sf)\r\n{\r\nstruct gss_sec_keyring *gsec_kr;\r\nOBD_ALLOC(gsec_kr, sizeof(*gsec_kr));\r\nif (gsec_kr == NULL)\r\nreturn NULL;\r\nINIT_HLIST_HEAD(&gsec_kr->gsk_clist);\r\ngsec_kr->gsk_root_ctx = NULL;\r\nmutex_init(&gsec_kr->gsk_root_uc_lock);\r\n#ifdef HAVE_KEYRING_UPCALL_SERIALIZED\r\nmutex_init(&gsec_kr->gsk_uc_lock);\r\n#endif\r\nif (gss_sec_create_common(&gsec_kr->gsk_base, &gss_policy_keyring,\r\nimp, svcctx, sf))\r\ngoto err_free;\r\nif (svcctx != NULL &&\r\nsec_install_rctx_kr(&gsec_kr->gsk_base.gs_base, svcctx)) {\r\ngss_sec_destroy_common(&gsec_kr->gsk_base);\r\ngoto err_free;\r\n}\r\nreturn &gsec_kr->gsk_base.gs_base;\r\nerr_free:\r\nOBD_FREE(gsec_kr, sizeof(*gsec_kr));\r\nreturn NULL;\r\n}\r\nstatic\r\nvoid gss_sec_destroy_kr(struct ptlrpc_sec *sec)\r\n{\r\nstruct gss_sec *gsec = sec2gsec(sec);\r\nstruct gss_sec_keyring *gsec_kr = sec2gsec_keyring(sec);\r\nCDEBUG(D_SEC, "destroy %s@%p\n", sec->ps_policy->sp_name, sec);\r\nLASSERT(hlist_empty(&gsec_kr->gsk_clist));\r\nLASSERT(gsec_kr->gsk_root_ctx == NULL);\r\ngss_sec_destroy_common(gsec);\r\nOBD_FREE(gsec_kr, sizeof(*gsec_kr));\r\n}\r\nstatic inline int user_is_root(struct ptlrpc_sec *sec, struct vfs_cred *vcred)\r\n{\r\nif (sec_is_rootonly(sec) || (vcred->vc_uid == 0))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void request_key_unlink(struct key *key)\r\n{\r\nstruct task_struct *tsk = current;\r\nstruct key *ring;\r\nswitch (key_cred(tsk)->jit_keyring) {\r\ncase KEY_REQKEY_DEFL_DEFAULT:\r\ncase KEY_REQKEY_DEFL_THREAD_KEYRING:\r\nring = key_get(key_cred(tsk)->thread_keyring);\r\nif (ring)\r\nbreak;\r\ncase KEY_REQKEY_DEFL_PROCESS_KEYRING:\r\nring = key_get(key_tgcred(tsk)->process_keyring);\r\nif (ring)\r\nbreak;\r\ncase KEY_REQKEY_DEFL_SESSION_KEYRING:\r\nrcu_read_lock();\r\nring = key_get(rcu_dereference(key_tgcred(tsk)\r\n->session_keyring));\r\nrcu_read_unlock();\r\nif (ring)\r\nbreak;\r\ncase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\r\nring = key_get(key_cred(tsk)->user->session_keyring);\r\nbreak;\r\ncase KEY_REQKEY_DEFL_USER_KEYRING:\r\nring = key_get(key_cred(tsk)->user->uid_keyring);\r\nbreak;\r\ncase KEY_REQKEY_DEFL_GROUP_KEYRING:\r\ndefault:\r\nLBUG();\r\n}\r\nLASSERT(ring);\r\nkey_unlink(ring, key);\r\nkey_put(ring);\r\n}\r\nstatic\r\nstruct ptlrpc_cli_ctx * gss_sec_lookup_ctx_kr(struct ptlrpc_sec *sec,\r\nstruct vfs_cred *vcred,\r\nint create, int remove_dead)\r\n{\r\nstruct obd_import *imp = sec->ps_import;\r\nstruct gss_sec_keyring *gsec_kr = sec2gsec_keyring(sec);\r\nstruct ptlrpc_cli_ctx *ctx = NULL;\r\nunsigned int is_root = 0, create_new = 0;\r\nstruct key *key;\r\nchar desc[24];\r\nchar *coinfo;\r\nint coinfo_size;\r\nchar *co_flags = "";\r\nLASSERT(imp != NULL);\r\nis_root = user_is_root(sec, vcred);\r\nif (is_root) {\r\nctx = sec_lookup_root_ctx_kr(sec);\r\nif (ctx || sec_is_reverse(sec))\r\nreturn ctx;\r\n}\r\nLASSERT(create != 0);\r\nif (is_root) {\r\nmutex_lock(&gsec_kr->gsk_root_uc_lock);\r\nctx = sec_lookup_root_ctx_kr(sec);\r\nif (ctx)\r\ngoto out;\r\nsec2gsec(sec)->gs_rvs_hdl = gss_get_next_ctx_index();\r\nswitch (sec->ps_part) {\r\ncase LUSTRE_SP_MDT:\r\nco_flags = "m";\r\nbreak;\r\ncase LUSTRE_SP_OST:\r\nco_flags = "o";\r\nbreak;\r\ncase LUSTRE_SP_MGC:\r\nco_flags = "rmo";\r\nbreak;\r\ncase LUSTRE_SP_CLI:\r\nco_flags = "r";\r\nbreak;\r\ncase LUSTRE_SP_MGS:\r\ndefault:\r\nLBUG();\r\n}\r\n}\r\nconstruct_key_desc(desc, sizeof(desc), sec, vcred->vc_uid);\r\ncoinfo_size = sizeof(struct obd_uuid) + MAX_OBD_NAME + 64;\r\nOBD_ALLOC(coinfo, coinfo_size);\r\nif (coinfo == NULL)\r\ngoto out;\r\nsnprintf(coinfo, coinfo_size, "%d:%s:%u:%u:%s:%d:"LPX64":%s",\r\nsec->ps_id, sec2gsec(sec)->gs_mech->gm_name,\r\nvcred->vc_uid, vcred->vc_gid,\r\nco_flags, import_to_gss_svc(imp),\r\nimp->imp_connection->c_peer.nid, imp->imp_obd->obd_name);\r\nCDEBUG(D_SEC, "requesting key for %s\n", desc);\r\nkeyring_upcall_lock(gsec_kr);\r\nkey = request_key(&gss_key_type, desc, coinfo);\r\nkeyring_upcall_unlock(gsec_kr);\r\nOBD_FREE(coinfo, coinfo_size);\r\nif (IS_ERR(key)) {\r\nCERROR("failed request key: %ld\n", PTR_ERR(key));\r\ngoto out;\r\n}\r\nCDEBUG(D_SEC, "obtained key %08x for %s\n", key->serial, desc);\r\ndown_write(&key->sem);\r\nif (likely(key->payload.data != NULL)) {\r\nctx = key->payload.data;\r\nLASSERT(atomic_read(&ctx->cc_refcount) >= 1);\r\nLASSERT(ctx2gctx_keyring(ctx)->gck_key == key);\r\nLASSERT(atomic_read(&key->usage) >= 2);\r\natomic_inc(&ctx->cc_refcount);\r\n} else {\r\nctx = ctx_create_kr(sec, vcred);\r\nif (ctx != NULL) {\r\nctx_enlist_kr(ctx, is_root, 0);\r\nbind_key_ctx(key, ctx);\r\nctx_start_timer_kr(ctx, KEYRING_UPCALL_TIMEOUT);\r\nCDEBUG(D_SEC, "installed key %p <-> ctx %p (sec %p)\n",\r\nkey, ctx, sec);\r\n} else {\r\nkey_revoke_locked(key);\r\n}\r\ncreate_new = 1;\r\n}\r\nup_write(&key->sem);\r\nif (is_root && create_new)\r\nrequest_key_unlink(key);\r\nkey_put(key);\r\nout:\r\nif (is_root)\r\nmutex_unlock(&gsec_kr->gsk_root_uc_lock);\r\nreturn ctx;\r\n}\r\nstatic\r\nvoid gss_sec_release_ctx_kr(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_cli_ctx *ctx,\r\nint sync)\r\n{\r\nLASSERT(atomic_read(&sec->ps_refcount) > 0);\r\nLASSERT(atomic_read(&ctx->cc_refcount) == 0);\r\nctx_release_kr(ctx, sync);\r\n}\r\nstatic\r\nvoid flush_user_ctx_cache_kr(struct ptlrpc_sec *sec,\r\nuid_t uid,\r\nint grace, int force)\r\n{\r\nstruct key *key;\r\nchar desc[24];\r\nif (sec_is_reverse(sec) || sec_is_rootonly(sec))\r\nreturn;\r\nconstruct_key_desc(desc, sizeof(desc), sec, uid);\r\nfor (;;) {\r\nkey = request_key(&gss_key_type, desc, NULL);\r\nif (IS_ERR(key)) {\r\nCDEBUG(D_SEC, "No more key found for current user\n");\r\nbreak;\r\n}\r\ndown_write(&key->sem);\r\nkill_key_locked(key);\r\nkey_revoke_locked(key);\r\nup_write(&key->sem);\r\nkey_put(key);\r\n}\r\n}\r\nstatic\r\nvoid flush_spec_ctx_cache_kr(struct ptlrpc_sec *sec,\r\nuid_t uid,\r\nint grace, int force)\r\n{\r\nstruct gss_sec_keyring *gsec_kr;\r\nstruct hlist_head freelist = HLIST_HEAD_INIT;\r\nstruct hlist_node *next;\r\nstruct ptlrpc_cli_ctx *ctx;\r\ngsec_kr = sec2gsec_keyring(sec);\r\nspin_lock(&sec->ps_lock);\r\nhlist_for_each_entry_safe(ctx, next,\r\n&gsec_kr->gsk_clist, cc_cache) {\r\nLASSERT(atomic_read(&ctx->cc_refcount) > 0);\r\nif (uid != -1 && uid != ctx->cc_vcred.vc_uid)\r\ncontinue;\r\nif (atomic_read(&ctx->cc_refcount) > 2) {\r\nif (!force)\r\ncontinue;\r\nCWARN("flush busy ctx %p(%u->%s, extra ref %d)\n",\r\nctx, ctx->cc_vcred.vc_uid,\r\nsec2target_str(ctx->cc_sec),\r\natomic_read(&ctx->cc_refcount) - 2);\r\n}\r\nset_bit(PTLRPC_CTX_DEAD_BIT, &ctx->cc_flags);\r\nif (!grace)\r\nclear_bit(PTLRPC_CTX_UPTODATE_BIT, &ctx->cc_flags);\r\natomic_inc(&ctx->cc_refcount);\r\nif (ctx_unlist_kr(ctx, 1)) {\r\nhlist_add_head(&ctx->cc_cache, &freelist);\r\n} else {\r\nLASSERT(atomic_read(&ctx->cc_refcount) >= 2);\r\natomic_dec(&ctx->cc_refcount);\r\n}\r\n}\r\nspin_unlock(&sec->ps_lock);\r\ndispose_ctx_list_kr(&freelist);\r\n}\r\nstatic\r\nint gss_sec_flush_ctx_cache_kr(struct ptlrpc_sec *sec,\r\nuid_t uid, int grace, int force)\r\n{\r\nCDEBUG(D_SEC, "sec %p(%d, nctx %d), uid %d, grace %d, force %d\n",\r\nsec, atomic_read(&sec->ps_refcount),\r\natomic_read(&sec->ps_nctx),\r\nuid, grace, force);\r\nif (uid != -1 && uid != 0)\r\nflush_user_ctx_cache_kr(sec, uid, grace, force);\r\nelse\r\nflush_spec_ctx_cache_kr(sec, uid, grace, force);\r\nreturn 0;\r\n}\r\nstatic\r\nvoid gss_sec_gc_ctx_kr(struct ptlrpc_sec *sec)\r\n{\r\nstruct gss_sec_keyring *gsec_kr = sec2gsec_keyring(sec);\r\nstruct hlist_head freelist = HLIST_HEAD_INIT;\r\nstruct hlist_node *next;\r\nstruct ptlrpc_cli_ctx *ctx;\r\nCWARN("running gc\n");\r\nspin_lock(&sec->ps_lock);\r\nhlist_for_each_entry_safe(ctx, next,\r\n&gsec_kr->gsk_clist, cc_cache) {\r\nLASSERT(atomic_read(&ctx->cc_refcount) > 0);\r\natomic_inc(&ctx->cc_refcount);\r\nif (cli_ctx_check_death(ctx) && ctx_unlist_kr(ctx, 1)) {\r\nhlist_add_head(&ctx->cc_cache, &freelist);\r\nCWARN("unhashed ctx %p\n", ctx);\r\n} else {\r\nLASSERT(atomic_read(&ctx->cc_refcount) >= 2);\r\natomic_dec(&ctx->cc_refcount);\r\n}\r\n}\r\nspin_unlock(&sec->ps_lock);\r\ndispose_ctx_list_kr(&freelist);\r\n}\r\nstatic\r\nint gss_sec_display_kr(struct ptlrpc_sec *sec, struct seq_file *seq)\r\n{\r\nstruct gss_sec_keyring *gsec_kr = sec2gsec_keyring(sec);\r\nstruct hlist_node *next;\r\nstruct ptlrpc_cli_ctx *ctx;\r\nstruct gss_cli_ctx *gctx;\r\ntime_t now = cfs_time_current_sec();\r\nspin_lock(&sec->ps_lock);\r\nhlist_for_each_entry_safe(ctx, next,\r\n&gsec_kr->gsk_clist, cc_cache) {\r\nstruct key *key;\r\nchar flags_str[40];\r\nchar mech[40];\r\ngctx = ctx2gctx(ctx);\r\nkey = ctx2gctx_keyring(ctx)->gck_key;\r\ngss_cli_ctx_flags2str(ctx->cc_flags,\r\nflags_str, sizeof(flags_str));\r\nif (gctx->gc_mechctx)\r\nlgss_display(gctx->gc_mechctx, mech, sizeof(mech));\r\nelse\r\nsnprintf(mech, sizeof(mech), "N/A");\r\nmech[sizeof(mech) - 1] = '\0';\r\nseq_printf(seq, "%p: uid %u, ref %d, expire %ld(%+ld), fl %s, "\r\n"seq %d, win %u, key %08x(ref %d), "\r\n"hdl "LPX64":"LPX64", mech: %s\n",\r\nctx, ctx->cc_vcred.vc_uid,\r\natomic_read(&ctx->cc_refcount),\r\nctx->cc_expire,\r\nctx->cc_expire ? ctx->cc_expire - now : 0,\r\nflags_str,\r\natomic_read(&gctx->gc_seq),\r\ngctx->gc_win,\r\nkey ? key->serial : 0,\r\nkey ? atomic_read(&key->usage) : 0,\r\ngss_handle_to_u64(&gctx->gc_handle),\r\ngss_handle_to_u64(&gctx->gc_svc_handle),\r\nmech);\r\n}\r\nspin_unlock(&sec->ps_lock);\r\nreturn 0;\r\n}\r\nstatic\r\nint gss_cli_ctx_refresh_kr(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nreturn 0;\r\n}\r\nstatic\r\nint gss_cli_ctx_validate_kr(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nLASSERT(atomic_read(&ctx->cc_refcount) > 0);\r\nLASSERT(ctx->cc_sec);\r\nif (cli_ctx_check_death(ctx)) {\r\nkill_ctx_kr(ctx);\r\nreturn 1;\r\n}\r\nif (cli_ctx_is_ready(ctx))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic\r\nvoid gss_cli_ctx_die_kr(struct ptlrpc_cli_ctx *ctx, int grace)\r\n{\r\nLASSERT(atomic_read(&ctx->cc_refcount) > 0);\r\nLASSERT(ctx->cc_sec);\r\ncli_ctx_expire(ctx);\r\nkill_ctx_kr(ctx);\r\n}\r\nstatic\r\nint sec_install_rctx_kr(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_svc_ctx *svc_ctx)\r\n{\r\nstruct ptlrpc_cli_ctx *cli_ctx;\r\nstruct vfs_cred vcred = { 0, 0 };\r\nint rc;\r\nLASSERT(sec);\r\nLASSERT(svc_ctx);\r\ncli_ctx = ctx_create_kr(sec, &vcred);\r\nif (cli_ctx == NULL)\r\nreturn -ENOMEM;\r\nrc = gss_copy_rvc_cli_ctx(cli_ctx, svc_ctx);\r\nif (rc) {\r\nCERROR("failed copy reverse cli ctx: %d\n", rc);\r\nctx_put_kr(cli_ctx, 1);\r\nreturn rc;\r\n}\r\nrvs_sec_install_root_ctx_kr(sec, cli_ctx, NULL);\r\nctx_put_kr(cli_ctx, 1);\r\nreturn 0;\r\n}\r\nstatic\r\nint gss_svc_accept_kr(struct ptlrpc_request *req)\r\n{\r\nreturn gss_svc_accept(&gss_policy_keyring, req);\r\n}\r\nstatic\r\nint gss_svc_install_rctx_kr(struct obd_import *imp,\r\nstruct ptlrpc_svc_ctx *svc_ctx)\r\n{\r\nstruct ptlrpc_sec *sec;\r\nint rc;\r\nsec = sptlrpc_import_sec_ref(imp);\r\nLASSERT(sec);\r\nrc = sec_install_rctx_kr(sec, svc_ctx);\r\nsptlrpc_sec_put(sec);\r\nreturn rc;\r\n}\r\nstatic\r\nint gss_kt_instantiate(struct key *key, const void *data, size_t datalen)\r\n{\r\nint rc;\r\nif (data != NULL || datalen != 0) {\r\nCERROR("invalid: data %p, len %lu\n", data, (long)datalen);\r\nreturn -EINVAL;\r\n}\r\nif (key->payload.data != 0) {\r\nCERROR("key already have payload\n");\r\nreturn -EINVAL;\r\n}\r\nLASSERT(key_tgcred(current)->session_keyring);\r\nlockdep_off();\r\nrc = key_link(key_tgcred(current)->session_keyring, key);\r\nlockdep_on();\r\nif (unlikely(rc)) {\r\nCERROR("failed to link key %08x to keyring %08x: %d\n",\r\nkey->serial,\r\nkey_tgcred(current)->session_keyring->serial, rc);\r\nreturn rc;\r\n}\r\nCDEBUG(D_SEC, "key %p instantiated, ctx %p\n", key, key->payload.data);\r\nreturn 0;\r\n}\r\nstatic\r\nint gss_kt_update(struct key *key, const void *data, size_t datalen)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = key->payload.data;\r\nstruct gss_cli_ctx *gctx;\r\nrawobj_t tmpobj = RAWOBJ_EMPTY;\r\n__u32 datalen32 = (__u32) datalen;\r\nint rc;\r\nif (data == NULL || datalen == 0) {\r\nCWARN("invalid: data %p, len %lu\n", data, (long)datalen);\r\nreturn -EINVAL;\r\n}\r\nif (ctx == NULL) {\r\nCDEBUG(D_SEC, "update too soon: key %p(%x) flags %lx\n",\r\nkey, key->serial, key->flags);\r\nrc = key_validate(key);\r\nif (rc == 0)\r\nreturn -EAGAIN;\r\nelse\r\nreturn rc;\r\n}\r\nLASSERT(atomic_read(&ctx->cc_refcount) > 0);\r\nLASSERT(ctx->cc_sec);\r\nctx_clear_timer_kr(ctx);\r\nif (cli_ctx_is_refreshed(ctx)) {\r\nCWARN("ctx already done refresh\n");\r\nreturn 0;\r\n}\r\nsptlrpc_cli_ctx_get(ctx);\r\ngctx = ctx2gctx(ctx);\r\nrc = buffer_extract_bytes(&data, &datalen32, &gctx->gc_win,\r\nsizeof(gctx->gc_win));\r\nif (rc) {\r\nCERROR("failed extract seq_win\n");\r\ngoto out;\r\n}\r\nif (gctx->gc_win == 0) {\r\n__u32 nego_rpc_err, nego_gss_err;\r\nrc = buffer_extract_bytes(&data, &datalen32, &nego_rpc_err,\r\nsizeof(nego_rpc_err));\r\nif (rc) {\r\nCERROR("failed to extrace rpc rc\n");\r\ngoto out;\r\n}\r\nrc = buffer_extract_bytes(&data, &datalen32, &nego_gss_err,\r\nsizeof(nego_gss_err));\r\nif (rc) {\r\nCERROR("failed to extrace gss rc\n");\r\ngoto out;\r\n}\r\nCERROR("negotiation: rpc err %d, gss err %x\n",\r\nnego_rpc_err, nego_gss_err);\r\nrc = nego_rpc_err ? nego_rpc_err : -EACCES;\r\n} else {\r\nrc = rawobj_extract_local_alloc(&gctx->gc_handle,\r\n(__u32 **) &data, &datalen32);\r\nif (rc) {\r\nCERROR("failed extract handle\n");\r\ngoto out;\r\n}\r\nrc = rawobj_extract_local(&tmpobj, (__u32 **) &data,&datalen32);\r\nif (rc) {\r\nCERROR("failed extract mech\n");\r\ngoto out;\r\n}\r\nrc = lgss_import_sec_context(&tmpobj,\r\nsec2gsec(ctx->cc_sec)->gs_mech,\r\n&gctx->gc_mechctx);\r\nif (rc != GSS_S_COMPLETE)\r\nCERROR("failed import context\n");\r\nelse\r\nrc = 0;\r\n}\r\nout:\r\nif (rc == 0) {\r\ngss_cli_ctx_uptodate(gctx);\r\n} else {\r\nkill_key_locked(key);\r\ncli_ctx_expire(ctx);\r\nif (rc != -ERESTART)\r\nset_bit(PTLRPC_CTX_ERROR_BIT, &ctx->cc_flags);\r\n}\r\nsptlrpc_cli_ctx_put(ctx, 1);\r\nreturn 0;\r\n}\r\nstatic\r\nint gss_kt_match(const struct key *key, const void *desc)\r\n{\r\nreturn (strcmp(key->description, (const char *) desc) == 0);\r\n}\r\nstatic\r\nvoid gss_kt_destroy(struct key *key)\r\n{\r\nLASSERT(key->payload.data == NULL);\r\nCDEBUG(D_SEC, "destroy key %p\n", key);\r\n}\r\nstatic\r\nvoid gss_kt_describe(const struct key *key, struct seq_file *s)\r\n{\r\nif (key->description == NULL)\r\nseq_puts(s, "[null]");\r\nelse\r\nseq_puts(s, key->description);\r\n}\r\nint __init gss_init_keyring(void)\r\n{\r\nint rc;\r\nrc = register_key_type(&gss_key_type);\r\nif (rc) {\r\nCERROR("failed to register keyring type: %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = sptlrpc_register_policy(&gss_policy_keyring);\r\nif (rc) {\r\nunregister_key_type(&gss_key_type);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nvoid __exit gss_exit_keyring(void)\r\n{\r\nunregister_key_type(&gss_key_type);\r\nsptlrpc_unregister_policy(&gss_policy_keyring);\r\n}
