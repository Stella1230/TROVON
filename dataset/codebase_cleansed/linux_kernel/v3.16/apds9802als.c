static ssize_t als_sensing_range_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint val;\r\nval = i2c_smbus_read_byte_data(client, 0x81);\r\nif (val < 0)\r\nreturn val;\r\nif (val & 1)\r\nreturn sprintf(buf, "4095\n");\r\nelse\r\nreturn sprintf(buf, "65535\n");\r\n}\r\nstatic int als_wait_for_data_ready(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint ret;\r\nint retry = 10;\r\ndo {\r\nmsleep(30);\r\nret = i2c_smbus_read_byte_data(client, 0x86);\r\n} while (!(ret & 0x80) && retry--);\r\nif (retry < 0) {\r\ndev_warn(dev, "timeout waiting for data ready\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t als_lux0_input_data_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct als_data *data = i2c_get_clientdata(client);\r\nint ret_val;\r\nint temp;\r\npm_runtime_get_sync(dev);\r\nmutex_lock(&data->mutex);\r\ni2c_smbus_write_byte(client, 0x40);\r\ntemp = i2c_smbus_read_byte_data(client, 0x81);\r\ni2c_smbus_write_byte_data(client, 0x81, temp | 0x08);\r\nret_val = als_wait_for_data_ready(dev);\r\nif (ret_val < 0)\r\ngoto failed;\r\ntemp = i2c_smbus_read_byte_data(client, 0x8C);\r\nif (temp < 0) {\r\nret_val = temp;\r\ngoto failed;\r\n}\r\nret_val = i2c_smbus_read_byte_data(client, 0x8D);\r\nif (ret_val < 0)\r\ngoto failed;\r\nmutex_unlock(&data->mutex);\r\npm_runtime_put_sync(dev);\r\ntemp = (ret_val << 8) | temp;\r\nreturn sprintf(buf, "%d\n", temp);\r\nfailed:\r\nmutex_unlock(&data->mutex);\r\npm_runtime_put_sync(dev);\r\nreturn ret_val;\r\n}\r\nstatic ssize_t als_sensing_range_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct als_data *data = i2c_get_clientdata(client);\r\nint ret_val;\r\nunsigned long val;\r\nret_val = kstrtoul(buf, 10, &val);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (val < 4096)\r\nval = 1;\r\nelse if (val < 65536)\r\nval = 2;\r\nelse\r\nreturn -ERANGE;\r\npm_runtime_get_sync(dev);\r\nmutex_lock(&data->mutex);\r\nret_val = i2c_smbus_read_byte_data(client, 0x81);\r\nif (ret_val < 0)\r\ngoto fail;\r\nret_val = ret_val & 0xFA;\r\nif (val == 1)\r\nret_val = (ret_val | 0x01);\r\nelse\r\nret_val = (ret_val | 0x00);\r\nret_val = i2c_smbus_write_byte_data(client, 0x81, ret_val);\r\nif (ret_val >= 0) {\r\nmutex_unlock(&data->mutex);\r\npm_runtime_put_sync(dev);\r\nreturn count;\r\n}\r\nfail:\r\nmutex_unlock(&data->mutex);\r\npm_runtime_put_sync(dev);\r\nreturn ret_val;\r\n}\r\nstatic int als_set_power_state(struct i2c_client *client, bool on_off)\r\n{\r\nint ret_val;\r\nstruct als_data *data = i2c_get_clientdata(client);\r\nmutex_lock(&data->mutex);\r\nret_val = i2c_smbus_read_byte_data(client, 0x80);\r\nif (ret_val < 0)\r\ngoto fail;\r\nif (on_off)\r\nret_val = ret_val | 0x01;\r\nelse\r\nret_val = ret_val & 0xFE;\r\nret_val = i2c_smbus_write_byte_data(client, 0x80, ret_val);\r\nfail:\r\nmutex_unlock(&data->mutex);\r\nreturn ret_val;\r\n}\r\nstatic int als_set_default_config(struct i2c_client *client)\r\n{\r\nint ret_val;\r\nret_val = i2c_smbus_write_byte_data(client, 0x80, 0x01);\r\nif (ret_val < 0) {\r\ndev_err(&client->dev, "failed default switch on write\n");\r\nreturn ret_val;\r\n}\r\nret_val = i2c_smbus_write_byte_data(client, 0x81, 0x08);\r\nif (ret_val < 0)\r\ndev_err(&client->dev, "failed default LUX on write\n");\r\nals_wait_for_data_ready(&client->dev);\r\nreturn ret_val;\r\n}\r\nstatic int apds9802als_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint res;\r\nstruct als_data *data;\r\ndata = kzalloc(sizeof(struct als_data), GFP_KERNEL);\r\nif (data == NULL) {\r\ndev_err(&client->dev, "Memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\ni2c_set_clientdata(client, data);\r\nres = sysfs_create_group(&client->dev.kobj, &m_als_gr);\r\nif (res) {\r\ndev_err(&client->dev, "device create file failed\n");\r\ngoto als_error1;\r\n}\r\ndev_info(&client->dev, "ALS chip found\n");\r\nals_set_default_config(client);\r\nmutex_init(&data->mutex);\r\npm_runtime_set_active(&client->dev);\r\npm_runtime_enable(&client->dev);\r\nreturn res;\r\nals_error1:\r\nkfree(data);\r\nreturn res;\r\n}\r\nstatic int apds9802als_remove(struct i2c_client *client)\r\n{\r\nstruct als_data *data = i2c_get_clientdata(client);\r\npm_runtime_get_sync(&client->dev);\r\nals_set_power_state(client, false);\r\nsysfs_remove_group(&client->dev.kobj, &m_als_gr);\r\npm_runtime_disable(&client->dev);\r\npm_runtime_set_suspended(&client->dev);\r\npm_runtime_put_noidle(&client->dev);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int apds9802als_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nals_set_power_state(client, false);\r\nreturn 0;\r\n}\r\nstatic int apds9802als_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nals_set_power_state(client, true);\r\nreturn 0;\r\n}
