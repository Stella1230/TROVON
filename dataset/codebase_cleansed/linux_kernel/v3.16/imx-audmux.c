static const char *audmux_port_string(int port)\r\n{\r\nswitch (port) {\r\ncase MX31_AUDMUX_PORT1_SSI0:\r\nreturn "imx-ssi.0";\r\ncase MX31_AUDMUX_PORT2_SSI1:\r\nreturn "imx-ssi.1";\r\ncase MX31_AUDMUX_PORT3_SSI_PINS_3:\r\nreturn "SSI3";\r\ncase MX31_AUDMUX_PORT4_SSI_PINS_4:\r\nreturn "SSI4";\r\ncase MX31_AUDMUX_PORT5_SSI_PINS_5:\r\nreturn "SSI5";\r\ncase MX31_AUDMUX_PORT6_SSI_PINS_6:\r\nreturn "SSI6";\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nstatic ssize_t audmux_read_file(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nssize_t ret;\r\nchar *buf;\r\nint port = (int)file->private_data;\r\nu32 pdcr, ptcr;\r\nif (audmux_clk) {\r\nret = clk_prepare_enable(audmux_clk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nptcr = readl(audmux_base + IMX_AUDMUX_V2_PTCR(port));\r\npdcr = readl(audmux_base + IMX_AUDMUX_V2_PDCR(port));\r\nif (audmux_clk)\r\nclk_disable_unprepare(audmux_clk);\r\nbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = snprintf(buf, PAGE_SIZE, "PDCR: %08x\nPTCR: %08x\n",\r\npdcr, ptcr);\r\nif (ptcr & IMX_AUDMUX_V2_PTCR_TFSDIR)\r\nret += snprintf(buf + ret, PAGE_SIZE - ret,\r\n"TxFS output from %s, ",\r\naudmux_port_string((ptcr >> 27) & 0x7));\r\nelse\r\nret += snprintf(buf + ret, PAGE_SIZE - ret,\r\n"TxFS input, ");\r\nif (ptcr & IMX_AUDMUX_V2_PTCR_TCLKDIR)\r\nret += snprintf(buf + ret, PAGE_SIZE - ret,\r\n"TxClk output from %s",\r\naudmux_port_string((ptcr >> 22) & 0x7));\r\nelse\r\nret += snprintf(buf + ret, PAGE_SIZE - ret,\r\n"TxClk input");\r\nret += snprintf(buf + ret, PAGE_SIZE - ret, "\n");\r\nif (ptcr & IMX_AUDMUX_V2_PTCR_SYN) {\r\nret += snprintf(buf + ret, PAGE_SIZE - ret,\r\n"Port is symmetric");\r\n} else {\r\nif (ptcr & IMX_AUDMUX_V2_PTCR_RFSDIR)\r\nret += snprintf(buf + ret, PAGE_SIZE - ret,\r\n"RxFS output from %s, ",\r\naudmux_port_string((ptcr >> 17) & 0x7));\r\nelse\r\nret += snprintf(buf + ret, PAGE_SIZE - ret,\r\n"RxFS input, ");\r\nif (ptcr & IMX_AUDMUX_V2_PTCR_RCLKDIR)\r\nret += snprintf(buf + ret, PAGE_SIZE - ret,\r\n"RxClk output from %s",\r\naudmux_port_string((ptcr >> 12) & 0x7));\r\nelse\r\nret += snprintf(buf + ret, PAGE_SIZE - ret,\r\n"RxClk input");\r\n}\r\nret += snprintf(buf + ret, PAGE_SIZE - ret,\r\n"\nData received from %s\n",\r\naudmux_port_string((pdcr >> 13) & 0x7));\r\nret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void audmux_debugfs_init(void)\r\n{\r\nint i;\r\nchar buf[20];\r\naudmux_debugfs_root = debugfs_create_dir("audmux", NULL);\r\nif (!audmux_debugfs_root) {\r\npr_warning("Failed to create AUDMUX debugfs root\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < MX31_AUDMUX_PORT7_SSI_PINS_7 + 1; i++) {\r\nsnprintf(buf, sizeof(buf), "ssi%d", i);\r\nif (!debugfs_create_file(buf, 0444, audmux_debugfs_root,\r\n(void *)i, &audmux_debugfs_fops))\r\npr_warning("Failed to create AUDMUX port %d debugfs file\n",\r\ni);\r\n}\r\n}\r\nstatic void audmux_debugfs_remove(void)\r\n{\r\ndebugfs_remove_recursive(audmux_debugfs_root);\r\n}\r\nstatic inline void audmux_debugfs_init(void)\r\n{\r\n}\r\nstatic inline void audmux_debugfs_remove(void)\r\n{\r\n}\r\nint imx_audmux_v1_configure_port(unsigned int port, unsigned int pcr)\r\n{\r\nif (audmux_type != IMX21_AUDMUX)\r\nreturn -EINVAL;\r\nif (!audmux_base)\r\nreturn -ENOSYS;\r\nif (port >= ARRAY_SIZE(port_mapping))\r\nreturn -EINVAL;\r\nwritel(pcr, audmux_base + port_mapping[port]);\r\nreturn 0;\r\n}\r\nint imx_audmux_v2_configure_port(unsigned int port, unsigned int ptcr,\r\nunsigned int pdcr)\r\n{\r\nint ret;\r\nif (audmux_type != IMX31_AUDMUX)\r\nreturn -EINVAL;\r\nif (!audmux_base)\r\nreturn -ENOSYS;\r\nif (audmux_clk) {\r\nret = clk_prepare_enable(audmux_clk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nwritel(ptcr, audmux_base + IMX_AUDMUX_V2_PTCR(port));\r\nwritel(pdcr, audmux_base + IMX_AUDMUX_V2_PDCR(port));\r\nif (audmux_clk)\r\nclk_disable_unprepare(audmux_clk);\r\nreturn 0;\r\n}\r\nstatic int imx_audmux_parse_dt_defaults(struct platform_device *pdev,\r\nstruct device_node *of_node)\r\n{\r\nstruct device_node *child;\r\nfor_each_available_child_of_node(of_node, child) {\r\nunsigned int port;\r\nunsigned int ptcr = 0;\r\nunsigned int pdcr = 0;\r\nunsigned int pcr = 0;\r\nunsigned int val;\r\nint ret;\r\nint i = 0;\r\nret = of_property_read_u32(child, "fsl,audmux-port", &port);\r\nif (ret) {\r\ndev_warn(&pdev->dev, "Failed to get fsl,audmux-port of child node \"%s\"\n",\r\nchild->full_name);\r\ncontinue;\r\n}\r\nif (!of_property_read_bool(child, "fsl,port-config")) {\r\ndev_warn(&pdev->dev, "child node \"%s\" does not have property fsl,port-config\n",\r\nchild->full_name);\r\ncontinue;\r\n}\r\nfor (i = 0; (ret = of_property_read_u32_index(child,\r\n"fsl,port-config", i, &val)) == 0;\r\n++i) {\r\nif (audmux_type == IMX31_AUDMUX) {\r\nif (i % 2)\r\npdcr |= val;\r\nelse\r\nptcr |= val;\r\n} else {\r\npcr |= val;\r\n}\r\n}\r\nif (ret != -EOVERFLOW) {\r\ndev_err(&pdev->dev, "Failed to read u32 at index %d of child %s\n",\r\ni, child->full_name);\r\ncontinue;\r\n}\r\nif (audmux_type == IMX31_AUDMUX) {\r\nif (i % 2) {\r\ndev_err(&pdev->dev, "One pdcr value is missing in child node %s\n",\r\nchild->full_name);\r\ncontinue;\r\n}\r\nimx_audmux_v2_configure_port(port, ptcr, pdcr);\r\n} else {\r\nimx_audmux_v1_configure_port(port, pcr);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_audmux_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nconst struct of_device_id *of_id =\r\nof_match_device(imx_audmux_dt_ids, &pdev->dev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naudmux_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(audmux_base))\r\nreturn PTR_ERR(audmux_base);\r\naudmux_clk = devm_clk_get(&pdev->dev, "audmux");\r\nif (IS_ERR(audmux_clk)) {\r\ndev_dbg(&pdev->dev, "cannot get clock: %ld\n",\r\nPTR_ERR(audmux_clk));\r\naudmux_clk = NULL;\r\n}\r\nif (of_id)\r\npdev->id_entry = of_id->data;\r\naudmux_type = pdev->id_entry->driver_data;\r\nif (audmux_type == IMX31_AUDMUX)\r\naudmux_debugfs_init();\r\nif (of_id)\r\nimx_audmux_parse_dt_defaults(pdev, pdev->dev.of_node);\r\nreturn 0;\r\n}\r\nstatic int imx_audmux_remove(struct platform_device *pdev)\r\n{\r\nif (audmux_type == IMX31_AUDMUX)\r\naudmux_debugfs_remove();\r\nreturn 0;\r\n}\r\nstatic int __init imx_audmux_init(void)\r\n{\r\nreturn platform_driver_register(&imx_audmux_driver);\r\n}\r\nstatic void __exit imx_audmux_exit(void)\r\n{\r\nplatform_driver_unregister(&imx_audmux_driver);\r\n}
