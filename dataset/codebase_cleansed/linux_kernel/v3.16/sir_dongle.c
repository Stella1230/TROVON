int irda_register_dongle(struct dongle_driver *new)\r\n{\r\nstruct list_head *entry;\r\nstruct dongle_driver *drv;\r\nIRDA_DEBUG(0, "%s : registering dongle \"%s\" (%d).\n",\r\n__func__, new->driver_name, new->type);\r\nmutex_lock(&dongle_list_lock);\r\nlist_for_each(entry, &dongle_list) {\r\ndrv = list_entry(entry, struct dongle_driver, dongle_list);\r\nif (new->type == drv->type) {\r\nmutex_unlock(&dongle_list_lock);\r\nreturn -EEXIST;\r\n}\r\n}\r\nlist_add(&new->dongle_list, &dongle_list);\r\nmutex_unlock(&dongle_list_lock);\r\nreturn 0;\r\n}\r\nint irda_unregister_dongle(struct dongle_driver *drv)\r\n{\r\nmutex_lock(&dongle_list_lock);\r\nlist_del(&drv->dongle_list);\r\nmutex_unlock(&dongle_list_lock);\r\nreturn 0;\r\n}\r\nint sirdev_get_dongle(struct sir_dev *dev, IRDA_DONGLE type)\r\n{\r\nstruct list_head *entry;\r\nconst struct dongle_driver *drv = NULL;\r\nint err = -EINVAL;\r\nrequest_module("irda-dongle-%d", type);\r\nif (dev->dongle_drv != NULL)\r\nreturn -EBUSY;\r\nmutex_lock(&dongle_list_lock);\r\nlist_for_each(entry, &dongle_list) {\r\ndrv = list_entry(entry, struct dongle_driver, dongle_list);\r\nif (drv->type == type)\r\nbreak;\r\nelse\r\ndrv = NULL;\r\n}\r\nif (!drv) {\r\nerr = -ENODEV;\r\ngoto out_unlock;\r\n}\r\nif (!try_module_get(drv->owner)) {\r\nerr = -ESTALE;\r\ngoto out_unlock;\r\n}\r\ndev->dongle_drv = drv;\r\nif (!drv->open || (err=drv->open(dev))!=0)\r\ngoto out_reject;\r\nmutex_unlock(&dongle_list_lock);\r\nreturn 0;\r\nout_reject:\r\ndev->dongle_drv = NULL;\r\nmodule_put(drv->owner);\r\nout_unlock:\r\nmutex_unlock(&dongle_list_lock);\r\nreturn err;\r\n}\r\nint sirdev_put_dongle(struct sir_dev *dev)\r\n{\r\nconst struct dongle_driver *drv = dev->dongle_drv;\r\nif (drv) {\r\nif (drv->close)\r\ndrv->close(dev);\r\ndev->dongle_drv = NULL;\r\nmodule_put(drv->owner);\r\n}\r\nreturn 0;\r\n}
