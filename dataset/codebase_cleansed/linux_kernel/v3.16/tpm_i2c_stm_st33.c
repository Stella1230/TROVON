static int write8_reg(struct i2c_client *client, u8 tpm_register,\r\nu8 *tpm_data, u16 tpm_size)\r\n{\r\nstruct st33zp24_platform_data *pin_infos;\r\npin_infos = client->dev.platform_data;\r\npin_infos->tpm_i2c_buffer[0][0] = tpm_register;\r\nmemcpy(&pin_infos->tpm_i2c_buffer[0][1], tpm_data, tpm_size);\r\nreturn i2c_master_send(client, pin_infos->tpm_i2c_buffer[0],\r\ntpm_size + 1);\r\n}\r\nstatic int read8_reg(struct i2c_client *client, u8 tpm_register,\r\nu8 *tpm_data, int tpm_size)\r\n{\r\nu8 status = 0;\r\nu8 data;\r\ndata = TPM_DUMMY_BYTE;\r\nstatus = write8_reg(client, tpm_register, &data, 1);\r\nif (status == 2)\r\nstatus = i2c_master_recv(client, tpm_data, tpm_size);\r\nreturn status;\r\n}\r\nstatic void clear_interruption(struct i2c_client *client)\r\n{\r\nu8 interrupt;\r\nI2C_READ_DATA(client, TPM_INT_STATUS, &interrupt, 1);\r\nI2C_WRITE_DATA(client, TPM_INT_STATUS, &interrupt, 1);\r\nI2C_READ_DATA(client, TPM_INT_STATUS, &interrupt, 1);\r\n}\r\nstatic long _wait_for_interrupt_serirq_timeout(struct tpm_chip *chip,\r\nunsigned long timeout)\r\n{\r\nlong status;\r\nstruct i2c_client *client;\r\nstruct st33zp24_platform_data *pin_infos;\r\nclient = (struct i2c_client *)TPM_VPRIV(chip);\r\npin_infos = client->dev.platform_data;\r\nstatus = wait_for_completion_interruptible_timeout(\r\n&pin_infos->irq_detection,\r\ntimeout);\r\nif (status > 0)\r\nenable_irq(gpio_to_irq(pin_infos->io_serirq));\r\ngpio_direction_input(pin_infos->io_serirq);\r\nreturn status;\r\n}\r\nstatic int wait_for_serirq_timeout(struct tpm_chip *chip, bool condition,\r\nunsigned long timeout)\r\n{\r\nint status = 2;\r\nstruct i2c_client *client;\r\nclient = (struct i2c_client *)TPM_VPRIV(chip);\r\nstatus = _wait_for_interrupt_serirq_timeout(chip, timeout);\r\nif (!status) {\r\nstatus = -EBUSY;\r\n} else {\r\nclear_interruption(client);\r\nif (condition)\r\nstatus = 1;\r\n}\r\nreturn status;\r\n}\r\nstatic void tpm_stm_i2c_cancel(struct tpm_chip *chip)\r\n{\r\nstruct i2c_client *client;\r\nu8 data;\r\nclient = (struct i2c_client *)TPM_VPRIV(chip);\r\ndata = TPM_STS_COMMAND_READY;\r\nI2C_WRITE_DATA(client, TPM_STS, &data, 1);\r\nif (chip->vendor.irq)\r\nwait_for_serirq_timeout(chip, 1, chip->vendor.timeout_a);\r\n}\r\nstatic u8 tpm_stm_i2c_status(struct tpm_chip *chip)\r\n{\r\nstruct i2c_client *client;\r\nu8 data;\r\nclient = (struct i2c_client *)TPM_VPRIV(chip);\r\nI2C_READ_DATA(client, TPM_STS, &data, 1);\r\nreturn data;\r\n}\r\nstatic int check_locality(struct tpm_chip *chip)\r\n{\r\nstruct i2c_client *client;\r\nu8 data;\r\nu8 status;\r\nclient = (struct i2c_client *)TPM_VPRIV(chip);\r\nstatus = I2C_READ_DATA(client, TPM_ACCESS, &data, 1);\r\nif (status && (data &\r\n(TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID)) ==\r\n(TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID))\r\nreturn chip->vendor.locality;\r\nreturn -EACCES;\r\n}\r\nstatic int request_locality(struct tpm_chip *chip)\r\n{\r\nunsigned long stop;\r\nlong rc;\r\nstruct i2c_client *client;\r\nu8 data;\r\nclient = (struct i2c_client *)TPM_VPRIV(chip);\r\nif (check_locality(chip) == chip->vendor.locality)\r\nreturn chip->vendor.locality;\r\ndata = TPM_ACCESS_REQUEST_USE;\r\nrc = I2C_WRITE_DATA(client, TPM_ACCESS, &data, 1);\r\nif (rc < 0)\r\ngoto end;\r\nif (chip->vendor.irq) {\r\nrc = wait_for_serirq_timeout(chip, (check_locality\r\n(chip) >= 0),\r\nchip->vendor.timeout_a);\r\nif (rc > 0)\r\nreturn chip->vendor.locality;\r\n} else {\r\nstop = jiffies + chip->vendor.timeout_a;\r\ndo {\r\nif (check_locality(chip) >= 0)\r\nreturn chip->vendor.locality;\r\nmsleep(TPM_TIMEOUT);\r\n} while (time_before(jiffies, stop));\r\n}\r\nrc = -EACCES;\r\nend:\r\nreturn rc;\r\n}\r\nstatic void release_locality(struct tpm_chip *chip)\r\n{\r\nstruct i2c_client *client;\r\nu8 data;\r\nclient = (struct i2c_client *)TPM_VPRIV(chip);\r\ndata = TPM_ACCESS_ACTIVE_LOCALITY;\r\nI2C_WRITE_DATA(client, TPM_ACCESS, &data, 1);\r\n}\r\nstatic int get_burstcount(struct tpm_chip *chip)\r\n{\r\nunsigned long stop;\r\nint burstcnt, status;\r\nu8 tpm_reg, temp;\r\nstruct i2c_client *client = (struct i2c_client *)TPM_VPRIV(chip);\r\nstop = jiffies + chip->vendor.timeout_d;\r\ndo {\r\ntpm_reg = TPM_STS + 1;\r\nstatus = I2C_READ_DATA(client, tpm_reg, &temp, 1);\r\nif (status < 0)\r\ngoto end;\r\ntpm_reg = tpm_reg + 1;\r\nburstcnt = temp;\r\nstatus = I2C_READ_DATA(client, tpm_reg, &temp, 1);\r\nif (status < 0)\r\ngoto end;\r\nburstcnt |= temp << 8;\r\nif (burstcnt)\r\nreturn burstcnt;\r\nmsleep(TPM_TIMEOUT);\r\n} while (time_before(jiffies, stop));\r\nend:\r\nreturn -EBUSY;\r\n}\r\nstatic int wait_for_stat(struct tpm_chip *chip, u8 mask, unsigned long timeout,\r\nwait_queue_head_t *queue)\r\n{\r\nunsigned long stop;\r\nlong rc;\r\nu8 status;\r\nif (chip->vendor.irq) {\r\nrc = wait_for_serirq_timeout(chip, ((tpm_stm_i2c_status\r\n(chip) & mask) ==\r\nmask), timeout);\r\nif (rc > 0)\r\nreturn 0;\r\n} else {\r\nstop = jiffies + timeout;\r\ndo {\r\nmsleep(TPM_TIMEOUT);\r\nstatus = tpm_stm_i2c_status(chip);\r\nif ((status & mask) == mask)\r\nreturn 0;\r\n} while (time_before(jiffies, stop));\r\n}\r\nreturn -ETIME;\r\n}\r\nstatic int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nint size = 0, burstcnt, len;\r\nstruct i2c_client *client;\r\nclient = (struct i2c_client *)TPM_VPRIV(chip);\r\nwhile (size < count &&\r\nwait_for_stat(chip,\r\nTPM_STS_DATA_AVAIL | TPM_STS_VALID,\r\nchip->vendor.timeout_c,\r\n&chip->vendor.read_queue)\r\n== 0) {\r\nburstcnt = get_burstcount(chip);\r\nif (burstcnt < 0)\r\nreturn burstcnt;\r\nlen = min_t(int, burstcnt, count - size);\r\nI2C_READ_DATA(client, TPM_DATA_FIFO, buf + size, len);\r\nsize += len;\r\n}\r\nreturn size;\r\n}\r\nstatic irqreturn_t tpm_ioserirq_handler(int irq, void *dev_id)\r\n{\r\nstruct tpm_chip *chip = dev_id;\r\nstruct i2c_client *client;\r\nstruct st33zp24_platform_data *pin_infos;\r\ndisable_irq_nosync(irq);\r\nclient = (struct i2c_client *)TPM_VPRIV(chip);\r\npin_infos = client->dev.platform_data;\r\ncomplete(&pin_infos->irq_detection);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tpm_stm_i2c_send(struct tpm_chip *chip, unsigned char *buf,\r\nsize_t len)\r\n{\r\nu32 status, i, size;\r\nint burstcnt = 0;\r\nint ret;\r\nu8 data;\r\nstruct i2c_client *client;\r\nif (chip == NULL)\r\nreturn -EBUSY;\r\nif (len < TPM_HEADER_SIZE)\r\nreturn -EBUSY;\r\nclient = (struct i2c_client *)TPM_VPRIV(chip);\r\nclient->flags = 0;\r\nret = request_locality(chip);\r\nif (ret < 0)\r\nreturn ret;\r\nstatus = tpm_stm_i2c_status(chip);\r\nif ((status & TPM_STS_COMMAND_READY) == 0) {\r\ntpm_stm_i2c_cancel(chip);\r\nif (wait_for_stat\r\n(chip, TPM_STS_COMMAND_READY, chip->vendor.timeout_b,\r\n&chip->vendor.int_queue) < 0) {\r\nret = -ETIME;\r\ngoto out_err;\r\n}\r\n}\r\nfor (i = 0; i < len - 1;) {\r\nburstcnt = get_burstcount(chip);\r\nif (burstcnt < 0)\r\nreturn burstcnt;\r\nsize = min_t(int, len - i - 1, burstcnt);\r\nret = I2C_WRITE_DATA(client, TPM_DATA_FIFO, buf, size);\r\nif (ret < 0)\r\ngoto out_err;\r\ni += size;\r\n}\r\nstatus = tpm_stm_i2c_status(chip);\r\nif ((status & TPM_STS_DATA_EXPECT) == 0) {\r\nret = -EIO;\r\ngoto out_err;\r\n}\r\nret = I2C_WRITE_DATA(client, TPM_DATA_FIFO, buf + len - 1, 1);\r\nif (ret < 0)\r\ngoto out_err;\r\nstatus = tpm_stm_i2c_status(chip);\r\nif ((status & TPM_STS_DATA_EXPECT) != 0) {\r\nret = -EIO;\r\ngoto out_err;\r\n}\r\ndata = TPM_STS_GO;\r\nI2C_WRITE_DATA(client, TPM_STS, &data, 1);\r\nreturn len;\r\nout_err:\r\ntpm_stm_i2c_cancel(chip);\r\nrelease_locality(chip);\r\nreturn ret;\r\n}\r\nstatic int tpm_stm_i2c_recv(struct tpm_chip *chip, unsigned char *buf,\r\nsize_t count)\r\n{\r\nint size = 0;\r\nint expected;\r\nif (chip == NULL)\r\nreturn -EBUSY;\r\nif (count < TPM_HEADER_SIZE) {\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nsize = recv_data(chip, buf, TPM_HEADER_SIZE);\r\nif (size < TPM_HEADER_SIZE) {\r\ndev_err(chip->dev, "Unable to read header\n");\r\ngoto out;\r\n}\r\nexpected = be32_to_cpu(*(__be32 *)(buf + 2));\r\nif (expected > count) {\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nsize += recv_data(chip, &buf[TPM_HEADER_SIZE],\r\nexpected - TPM_HEADER_SIZE);\r\nif (size < expected) {\r\ndev_err(chip->dev, "Unable to read remainder of result\n");\r\nsize = -ETIME;\r\ngoto out;\r\n}\r\nout:\r\nchip->ops->cancel(chip);\r\nrelease_locality(chip);\r\nreturn size;\r\n}\r\nstatic bool tpm_st33_i2c_req_canceled(struct tpm_chip *chip, u8 status)\r\n{\r\nreturn (status == TPM_STS_COMMAND_READY);\r\n}\r\nstatic int\r\ntpm_st33_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nint err;\r\nu8 intmask;\r\nstruct tpm_chip *chip;\r\nstruct st33zp24_platform_data *platform_data;\r\nif (client == NULL) {\r\npr_info("%s: i2c client is NULL. Device not accessible.\n",\r\n__func__);\r\nerr = -ENODEV;\r\ngoto end;\r\n}\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_info(&client->dev, "client not i2c capable\n");\r\nerr = -ENODEV;\r\ngoto end;\r\n}\r\nchip = tpm_register_hardware(&client->dev, &st_i2c_tpm);\r\nif (!chip) {\r\ndev_info(&client->dev, "fail chip\n");\r\nerr = -ENODEV;\r\ngoto end;\r\n}\r\nplatform_data = client->dev.platform_data;\r\nif (!platform_data) {\r\ndev_info(&client->dev, "chip not available\n");\r\nerr = -ENODEV;\r\ngoto _tpm_clean_answer;\r\n}\r\nplatform_data->tpm_i2c_buffer[0] =\r\nkmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\r\nif (platform_data->tpm_i2c_buffer[0] == NULL) {\r\nerr = -ENOMEM;\r\ngoto _tpm_clean_answer;\r\n}\r\nplatform_data->tpm_i2c_buffer[1] =\r\nkmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\r\nif (platform_data->tpm_i2c_buffer[1] == NULL) {\r\nerr = -ENOMEM;\r\ngoto _tpm_clean_response1;\r\n}\r\nTPM_VPRIV(chip) = client;\r\nchip->vendor.timeout_a = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\r\nchip->vendor.timeout_b = msecs_to_jiffies(TIS_LONG_TIMEOUT);\r\nchip->vendor.timeout_c = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\r\nchip->vendor.timeout_d = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\r\nchip->vendor.locality = LOCALITY0;\r\nif (power_mgt) {\r\nerr = gpio_request(platform_data->io_lpcpd, "TPM IO_LPCPD");\r\nif (err)\r\ngoto _gpio_init1;\r\ngpio_set_value(platform_data->io_lpcpd, 1);\r\n}\r\nif (interrupts) {\r\ninit_completion(&platform_data->irq_detection);\r\nif (request_locality(chip) != LOCALITY0) {\r\nerr = -ENODEV;\r\ngoto _tpm_clean_response2;\r\n}\r\nerr = gpio_request(platform_data->io_serirq, "TPM IO_SERIRQ");\r\nif (err)\r\ngoto _gpio_init2;\r\nclear_interruption(client);\r\nerr = request_irq(gpio_to_irq(platform_data->io_serirq),\r\n&tpm_ioserirq_handler,\r\nIRQF_TRIGGER_HIGH,\r\n"TPM SERIRQ management", chip);\r\nif (err < 0) {\r\ndev_err(chip->dev , "TPM SERIRQ signals %d not available\n",\r\ngpio_to_irq(platform_data->io_serirq));\r\ngoto _irq_set;\r\n}\r\nerr = I2C_READ_DATA(client, TPM_INT_ENABLE, &intmask, 1);\r\nif (err < 0)\r\ngoto _irq_set;\r\nintmask |= TPM_INTF_CMD_READY_INT\r\n| TPM_INTF_FIFO_AVALAIBLE_INT\r\n| TPM_INTF_WAKE_UP_READY_INT\r\n| TPM_INTF_LOCALITY_CHANGE_INT\r\n| TPM_INTF_STS_VALID_INT\r\n| TPM_INTF_DATA_AVAIL_INT;\r\nerr = I2C_WRITE_DATA(client, TPM_INT_ENABLE, &intmask, 1);\r\nif (err < 0)\r\ngoto _irq_set;\r\nintmask = TPM_GLOBAL_INT_ENABLE;\r\nerr = I2C_WRITE_DATA(client, (TPM_INT_ENABLE + 3), &intmask, 1);\r\nif (err < 0)\r\ngoto _irq_set;\r\nerr = I2C_READ_DATA(client, TPM_INT_STATUS, &intmask, 1);\r\nif (err < 0)\r\ngoto _irq_set;\r\nchip->vendor.irq = interrupts;\r\ntpm_gen_interrupt(chip);\r\n}\r\ntpm_get_timeouts(chip);\r\ndev_info(chip->dev, "TPM I2C Initialized\n");\r\nreturn 0;\r\n_irq_set:\r\nfree_irq(gpio_to_irq(platform_data->io_serirq), (void *)chip);\r\n_gpio_init2:\r\nif (interrupts)\r\ngpio_free(platform_data->io_serirq);\r\n_gpio_init1:\r\nif (power_mgt)\r\ngpio_free(platform_data->io_lpcpd);\r\n_tpm_clean_response2:\r\nkzfree(platform_data->tpm_i2c_buffer[1]);\r\nplatform_data->tpm_i2c_buffer[1] = NULL;\r\n_tpm_clean_response1:\r\nkzfree(platform_data->tpm_i2c_buffer[0]);\r\nplatform_data->tpm_i2c_buffer[0] = NULL;\r\n_tpm_clean_answer:\r\ntpm_remove_hardware(chip->dev);\r\nend:\r\npr_info("TPM I2C initialisation fail\n");\r\nreturn err;\r\n}\r\nstatic int tpm_st33_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct tpm_chip *chip = (struct tpm_chip *)i2c_get_clientdata(client);\r\nstruct st33zp24_platform_data *pin_infos =\r\n((struct i2c_client *)TPM_VPRIV(chip))->dev.platform_data;\r\nif (pin_infos != NULL) {\r\nfree_irq(pin_infos->io_serirq, chip);\r\ngpio_free(pin_infos->io_serirq);\r\ngpio_free(pin_infos->io_lpcpd);\r\ntpm_remove_hardware(chip->dev);\r\nif (pin_infos->tpm_i2c_buffer[1] != NULL) {\r\nkzfree(pin_infos->tpm_i2c_buffer[1]);\r\npin_infos->tpm_i2c_buffer[1] = NULL;\r\n}\r\nif (pin_infos->tpm_i2c_buffer[0] != NULL) {\r\nkzfree(pin_infos->tpm_i2c_buffer[0]);\r\npin_infos->tpm_i2c_buffer[0] = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tpm_st33_i2c_pm_suspend(struct device *dev)\r\n{\r\nstruct st33zp24_platform_data *pin_infos = dev->platform_data;\r\nint ret = 0;\r\nif (power_mgt) {\r\ngpio_set_value(pin_infos->io_lpcpd, 0);\r\n} else {\r\nret = tpm_pm_suspend(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int tpm_st33_i2c_pm_resume(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nstruct st33zp24_platform_data *pin_infos = dev->platform_data;\r\nint ret = 0;\r\nif (power_mgt) {\r\ngpio_set_value(pin_infos->io_lpcpd, 1);\r\nret = wait_for_serirq_timeout(chip,\r\n(chip->ops->status(chip) &\r\nTPM_STS_VALID) == TPM_STS_VALID,\r\nchip->vendor.timeout_b);\r\n} else {\r\nret = tpm_pm_resume(dev);\r\nif (!ret)\r\ntpm_do_selftest(chip);\r\n}\r\nreturn ret;\r\n}
