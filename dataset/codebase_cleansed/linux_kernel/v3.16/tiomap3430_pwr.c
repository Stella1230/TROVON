int handle_constraints_set(struct bridge_dev_context *dev_context,\r\nvoid *pargs)\r\n{\r\n#ifdef CONFIG_TIDSPBRIDGE_DVFS\r\nu32 *constraint_val;\r\nstruct omap_dsp_platform_data *pdata =\r\nomap_dspbridge_dev->dev.platform_data;\r\nconstraint_val = (u32 *) (pargs);\r\ndev_dbg(bridge, "OPP: %s opp requested = 0x%x\n", __func__,\r\n(u32) *(constraint_val + 1));\r\nif (pdata->dsp_set_min_opp)\r\n(*pdata->dsp_set_min_opp) ((u32) *(constraint_val + 1));\r\n#endif\r\nreturn 0;\r\n}\r\nint handle_hibernation_from_dsp(struct bridge_dev_context *dev_context)\r\n{\r\nint status = 0;\r\n#ifdef CONFIG_PM\r\nu16 timeout = PWRSTST_TIMEOUT / 10;\r\nu32 pwr_state;\r\n#ifdef CONFIG_TIDSPBRIDGE_DVFS\r\nu32 opplevel;\r\nstruct io_mgr *hio_mgr;\r\n#endif\r\nstruct omap_dsp_platform_data *pdata =\r\nomap_dspbridge_dev->dev.platform_data;\r\npwr_state = (*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD, OMAP2_PM_PWSTST) &\r\nOMAP_POWERSTATEST_MASK;\r\nwhile ((pwr_state != PWRDM_POWER_OFF) && --timeout) {\r\nif (msleep_interruptible(10)) {\r\npr_err("Waiting for DSP OFF mode interrupted\n");\r\nreturn -EPERM;\r\n}\r\npwr_state = (*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD,\r\nOMAP2_PM_PWSTST) &\r\nOMAP_POWERSTATEST_MASK;\r\n}\r\nif (timeout == 0) {\r\npr_err("%s: Timed out waiting for DSP off mode\n", __func__);\r\nstatus = -ETIMEDOUT;\r\nreturn status;\r\n} else {\r\nomap_mbox_save_ctx(dev_context->mbox);\r\nstatus = dsp_clock_disable_all(dev_context->dsp_per_clks);\r\ndsp_wdt_enable(false);\r\nif (!status) {\r\ndev_context->brd_state = BRD_DSP_HIBERNATION;\r\n#ifdef CONFIG_TIDSPBRIDGE_DVFS\r\nstatus =\r\ndev_get_io_mgr(dev_context->dev_obj, &hio_mgr);\r\nif (!hio_mgr) {\r\nstatus = DSP_EHANDLE;\r\nreturn status;\r\n}\r\nio_sh_msetting(hio_mgr, SHM_GETOPP, &opplevel);\r\nif (pdata->dsp_set_min_opp)\r\n(*pdata->dsp_set_min_opp) (VDD1_OPP1);\r\nstatus = 0;\r\n#endif\r\n}\r\n}\r\n#endif\r\nreturn status;\r\n}\r\nint sleep_dsp(struct bridge_dev_context *dev_context, u32 dw_cmd,\r\nvoid *pargs)\r\n{\r\nint status = 0;\r\n#ifdef CONFIG_PM\r\n#ifdef CONFIG_TIDSPBRIDGE_NTFY_PWRERR\r\nstruct deh_mgr *hdeh_mgr;\r\n#endif\r\nu16 timeout = PWRSTST_TIMEOUT / 10;\r\nu32 pwr_state, target_pwr_state;\r\nstruct omap_dsp_platform_data *pdata =\r\nomap_dspbridge_dev->dev.platform_data;\r\nif ((dw_cmd != PWR_DEEPSLEEP) && (dw_cmd != PWR_EMERGENCYDEEPSLEEP))\r\nreturn -EINVAL;\r\nswitch (dev_context->brd_state) {\r\ncase BRD_RUNNING:\r\nomap_mbox_save_ctx(dev_context->mbox);\r\nif (dsp_test_sleepstate == PWRDM_POWER_OFF) {\r\nsm_interrupt_dsp(dev_context, MBX_PM_DSPHIBERNATE);\r\ndev_dbg(bridge, "PM: %s - sent hibernate cmd to DSP\n",\r\n__func__);\r\ntarget_pwr_state = PWRDM_POWER_OFF;\r\n} else {\r\nsm_interrupt_dsp(dev_context, MBX_PM_DSPRETENTION);\r\ntarget_pwr_state = PWRDM_POWER_RET;\r\n}\r\nbreak;\r\ncase BRD_RETENTION:\r\nomap_mbox_save_ctx(dev_context->mbox);\r\nif (dsp_test_sleepstate == PWRDM_POWER_OFF) {\r\nsm_interrupt_dsp(dev_context, MBX_PM_DSPHIBERNATE);\r\ntarget_pwr_state = PWRDM_POWER_OFF;\r\n} else\r\nreturn 0;\r\nbreak;\r\ncase BRD_HIBERNATION:\r\ncase BRD_DSP_HIBERNATION:\r\ndev_dbg(bridge, "PM: %s - DSP already in hibernation\n",\r\n__func__);\r\nreturn 0;\r\ncase BRD_STOPPED:\r\ndev_dbg(bridge, "PM: %s - Board in STOP state\n", __func__);\r\nreturn 0;\r\ndefault:\r\ndev_dbg(bridge, "PM: %s - Bridge in Illegal state\n", __func__);\r\nreturn -EPERM;\r\n}\r\npwr_state = (*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD, OMAP2_PM_PWSTST) &\r\nOMAP_POWERSTATEST_MASK;\r\nwhile ((pwr_state != target_pwr_state) && --timeout) {\r\nif (msleep_interruptible(10)) {\r\npr_err("Waiting for DSP to Suspend interrupted\n");\r\nreturn -EPERM;\r\n}\r\npwr_state = (*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD,\r\nOMAP2_PM_PWSTST) &\r\nOMAP_POWERSTATEST_MASK;\r\n}\r\nif (!timeout) {\r\npr_err("%s: Timed out waiting for DSP off mode, state %x\n",\r\n__func__, pwr_state);\r\n#ifdef CONFIG_TIDSPBRIDGE_NTFY_PWRERR\r\ndev_get_deh_mgr(dev_context->dev_obj, &hdeh_mgr);\r\nbridge_deh_notify(hdeh_mgr, DSP_PWRERROR, 0);\r\n#endif\r\nreturn -ETIMEDOUT;\r\n} else {\r\nif (dsp_test_sleepstate == PWRDM_POWER_OFF)\r\ndev_context->brd_state = BRD_HIBERNATION;\r\nelse\r\ndev_context->brd_state = BRD_RETENTION;\r\ndsp_wdt_enable(false);\r\nstatus = dsp_clock_disable_all(dev_context->dsp_per_clks);\r\nif (status)\r\nreturn status;\r\n#ifdef CONFIG_TIDSPBRIDGE_DVFS\r\nelse if (target_pwr_state == PWRDM_POWER_OFF) {\r\nif (pdata->dsp_set_min_opp)\r\n(*pdata->dsp_set_min_opp) (VDD1_OPP1);\r\n}\r\n#endif\r\n}\r\n#endif\r\nreturn status;\r\n}\r\nint wake_dsp(struct bridge_dev_context *dev_context, void *pargs)\r\n{\r\nint status = 0;\r\n#ifdef CONFIG_PM\r\nif (dev_context->brd_state == BRD_RUNNING ||\r\ndev_context->brd_state == BRD_STOPPED) {\r\nreturn 0;\r\n}\r\nsm_interrupt_dsp(dev_context, MBX_PM_DSPWAKEUP);\r\ndev_context->brd_state = BRD_RUNNING;\r\n#endif\r\nreturn status;\r\n}\r\nint dsp_peripheral_clk_ctrl(struct bridge_dev_context *dev_context,\r\nvoid *pargs)\r\n{\r\nu32 ext_clk = 0;\r\nu32 ext_clk_id = 0;\r\nu32 ext_clk_cmd = 0;\r\nu32 clk_id_index = MBX_PM_MAX_RESOURCES;\r\nu32 tmp_index;\r\nu32 dsp_per_clks_before;\r\nint status = 0;\r\ndsp_per_clks_before = dev_context->dsp_per_clks;\r\next_clk = (u32) *((u32 *) pargs);\r\next_clk_id = ext_clk & MBX_PM_CLK_IDMASK;\r\nfor (tmp_index = 0; tmp_index < MBX_PM_MAX_RESOURCES; tmp_index++) {\r\nif (ext_clk_id == bpwr_clkid[tmp_index]) {\r\nclk_id_index = tmp_index;\r\nbreak;\r\n}\r\n}\r\nif (clk_id_index == MBX_PM_MAX_RESOURCES) {\r\nreturn -EPERM;\r\n}\r\next_clk_cmd = (ext_clk >> MBX_PM_CLK_CMDSHIFT) & MBX_PM_CLK_CMDMASK;\r\nswitch (ext_clk_cmd) {\r\ncase BPWR_DISABLE_CLOCK:\r\nstatus = dsp_clk_disable(bpwr_clks[clk_id_index].clk);\r\ndsp_clk_wakeup_event_ctrl(bpwr_clks[clk_id_index].clk_id,\r\nfalse);\r\nif (!status) {\r\n(dev_context->dsp_per_clks) &=\r\n(~((u32) (1 << bpwr_clks[clk_id_index].clk)));\r\n}\r\nbreak;\r\ncase BPWR_ENABLE_CLOCK:\r\nstatus = dsp_clk_enable(bpwr_clks[clk_id_index].clk);\r\ndsp_clk_wakeup_event_ctrl(bpwr_clks[clk_id_index].clk_id, true);\r\nif (!status)\r\n(dev_context->dsp_per_clks) |=\r\n(1 << bpwr_clks[clk_id_index].clk);\r\nbreak;\r\ndefault:\r\ndev_dbg(bridge, "%s: Unsupported CMD\n", __func__);\r\n}\r\nreturn status;\r\n}\r\nint pre_scale_dsp(struct bridge_dev_context *dev_context, void *pargs)\r\n{\r\n#ifdef CONFIG_TIDSPBRIDGE_DVFS\r\nu32 level;\r\nu32 voltage_domain;\r\nvoltage_domain = *((u32 *) pargs);\r\nlevel = *((u32 *) pargs + 1);\r\ndev_dbg(bridge, "OPP: %s voltage_domain = %x, level = 0x%x\n",\r\n__func__, voltage_domain, level);\r\nif ((dev_context->brd_state == BRD_HIBERNATION) ||\r\n(dev_context->brd_state == BRD_RETENTION) ||\r\n(dev_context->brd_state == BRD_DSP_HIBERNATION)) {\r\ndev_dbg(bridge, "OPP: %s IVA in sleep. No message to DSP\n");\r\nreturn 0;\r\n} else if (dev_context->brd_state == BRD_RUNNING) {\r\ndev_dbg(bridge, "OPP: %s sent notification to DSP\n", __func__);\r\nsm_interrupt_dsp(dev_context, MBX_PM_SETPOINT_PRENOTIFY);\r\nreturn 0;\r\n} else {\r\nreturn -EPERM;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nint post_scale_dsp(struct bridge_dev_context *dev_context,\r\nvoid *pargs)\r\n{\r\nint status = 0;\r\n#ifdef CONFIG_TIDSPBRIDGE_DVFS\r\nu32 level;\r\nu32 voltage_domain;\r\nstruct io_mgr *hio_mgr;\r\nstatus = dev_get_io_mgr(dev_context->dev_obj, &hio_mgr);\r\nif (!hio_mgr)\r\nreturn -EFAULT;\r\nvoltage_domain = *((u32 *) pargs);\r\nlevel = *((u32 *) pargs + 1);\r\ndev_dbg(bridge, "OPP: %s voltage_domain = %x, level = 0x%x\n",\r\n__func__, voltage_domain, level);\r\nif ((dev_context->brd_state == BRD_HIBERNATION) ||\r\n(dev_context->brd_state == BRD_RETENTION) ||\r\n(dev_context->brd_state == BRD_DSP_HIBERNATION)) {\r\nio_sh_msetting(hio_mgr, SHM_CURROPP, &level);\r\ndev_dbg(bridge, "OPP: %s IVA in sleep. Wrote to shm\n",\r\n__func__);\r\n} else if (dev_context->brd_state == BRD_RUNNING) {\r\nio_sh_msetting(hio_mgr, SHM_CURROPP, &level);\r\nsm_interrupt_dsp(dev_context, MBX_PM_SETPOINT_POSTNOTIFY);\r\ndev_dbg(bridge,\r\n"OPP: %s wrote to shm. Sent post notification to DSP\n",\r\n__func__);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\n#endif\r\nreturn status;\r\n}\r\nvoid dsp_clk_wakeup_event_ctrl(u32 clock_id, bool enable)\r\n{\r\nstruct cfg_hostres *resources;\r\nint status = 0;\r\nu32 iva2_grpsel;\r\nu32 mpu_grpsel;\r\nstruct dev_object *hdev_object = NULL;\r\nstruct bridge_dev_context *bridge_context = NULL;\r\nhdev_object = (struct dev_object *)drv_get_first_dev_object();\r\nif (!hdev_object)\r\nreturn;\r\nstatus = dev_get_bridge_context(hdev_object, &bridge_context);\r\nif (!bridge_context)\r\nreturn;\r\nresources = bridge_context->resources;\r\nif (!resources)\r\nreturn;\r\nswitch (clock_id) {\r\ncase BPWR_GP_TIMER5:\r\niva2_grpsel = readl(resources->per_pm_base + 0xA8);\r\nmpu_grpsel = readl(resources->per_pm_base + 0xA4);\r\nif (enable) {\r\niva2_grpsel |= OMAP3430_GRPSEL_GPT5_MASK;\r\nmpu_grpsel &= ~OMAP3430_GRPSEL_GPT5_MASK;\r\n} else {\r\nmpu_grpsel |= OMAP3430_GRPSEL_GPT5_MASK;\r\niva2_grpsel &= ~OMAP3430_GRPSEL_GPT5_MASK;\r\n}\r\nwritel(iva2_grpsel, resources->per_pm_base + 0xA8);\r\nwritel(mpu_grpsel, resources->per_pm_base + 0xA4);\r\nbreak;\r\ncase BPWR_GP_TIMER6:\r\niva2_grpsel = readl(resources->per_pm_base + 0xA8);\r\nmpu_grpsel = readl(resources->per_pm_base + 0xA4);\r\nif (enable) {\r\niva2_grpsel |= OMAP3430_GRPSEL_GPT6_MASK;\r\nmpu_grpsel &= ~OMAP3430_GRPSEL_GPT6_MASK;\r\n} else {\r\nmpu_grpsel |= OMAP3430_GRPSEL_GPT6_MASK;\r\niva2_grpsel &= ~OMAP3430_GRPSEL_GPT6_MASK;\r\n}\r\nwritel(iva2_grpsel, resources->per_pm_base + 0xA8);\r\nwritel(mpu_grpsel, resources->per_pm_base + 0xA4);\r\nbreak;\r\ncase BPWR_GP_TIMER7:\r\niva2_grpsel = readl(resources->per_pm_base + 0xA8);\r\nmpu_grpsel = readl(resources->per_pm_base + 0xA4);\r\nif (enable) {\r\niva2_grpsel |= OMAP3430_GRPSEL_GPT7_MASK;\r\nmpu_grpsel &= ~OMAP3430_GRPSEL_GPT7_MASK;\r\n} else {\r\nmpu_grpsel |= OMAP3430_GRPSEL_GPT7_MASK;\r\niva2_grpsel &= ~OMAP3430_GRPSEL_GPT7_MASK;\r\n}\r\nwritel(iva2_grpsel, resources->per_pm_base + 0xA8);\r\nwritel(mpu_grpsel, resources->per_pm_base + 0xA4);\r\nbreak;\r\ncase BPWR_GP_TIMER8:\r\niva2_grpsel = readl(resources->per_pm_base + 0xA8);\r\nmpu_grpsel = readl(resources->per_pm_base + 0xA4);\r\nif (enable) {\r\niva2_grpsel |= OMAP3430_GRPSEL_GPT8_MASK;\r\nmpu_grpsel &= ~OMAP3430_GRPSEL_GPT8_MASK;\r\n} else {\r\nmpu_grpsel |= OMAP3430_GRPSEL_GPT8_MASK;\r\niva2_grpsel &= ~OMAP3430_GRPSEL_GPT8_MASK;\r\n}\r\nwritel(iva2_grpsel, resources->per_pm_base + 0xA8);\r\nwritel(mpu_grpsel, resources->per_pm_base + 0xA4);\r\nbreak;\r\ncase BPWR_MCBSP1:\r\niva2_grpsel = readl(resources->core_pm_base + 0xA8);\r\nmpu_grpsel = readl(resources->core_pm_base + 0xA4);\r\nif (enable) {\r\niva2_grpsel |= OMAP3430_GRPSEL_MCBSP1_MASK;\r\nmpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP1_MASK;\r\n} else {\r\nmpu_grpsel |= OMAP3430_GRPSEL_MCBSP1_MASK;\r\niva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP1_MASK;\r\n}\r\nwritel(iva2_grpsel, resources->core_pm_base + 0xA8);\r\nwritel(mpu_grpsel, resources->core_pm_base + 0xA4);\r\nbreak;\r\ncase BPWR_MCBSP2:\r\niva2_grpsel = readl(resources->per_pm_base + 0xA8);\r\nmpu_grpsel = readl(resources->per_pm_base + 0xA4);\r\nif (enable) {\r\niva2_grpsel |= OMAP3430_GRPSEL_MCBSP2_MASK;\r\nmpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP2_MASK;\r\n} else {\r\nmpu_grpsel |= OMAP3430_GRPSEL_MCBSP2_MASK;\r\niva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP2_MASK;\r\n}\r\nwritel(iva2_grpsel, resources->per_pm_base + 0xA8);\r\nwritel(mpu_grpsel, resources->per_pm_base + 0xA4);\r\nbreak;\r\ncase BPWR_MCBSP3:\r\niva2_grpsel = readl(resources->per_pm_base + 0xA8);\r\nmpu_grpsel = readl(resources->per_pm_base + 0xA4);\r\nif (enable) {\r\niva2_grpsel |= OMAP3430_GRPSEL_MCBSP3_MASK;\r\nmpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP3_MASK;\r\n} else {\r\nmpu_grpsel |= OMAP3430_GRPSEL_MCBSP3_MASK;\r\niva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP3_MASK;\r\n}\r\nwritel(iva2_grpsel, resources->per_pm_base + 0xA8);\r\nwritel(mpu_grpsel, resources->per_pm_base + 0xA4);\r\nbreak;\r\ncase BPWR_MCBSP4:\r\niva2_grpsel = readl(resources->per_pm_base + 0xA8);\r\nmpu_grpsel = readl(resources->per_pm_base + 0xA4);\r\nif (enable) {\r\niva2_grpsel |= OMAP3430_GRPSEL_MCBSP4_MASK;\r\nmpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP4_MASK;\r\n} else {\r\nmpu_grpsel |= OMAP3430_GRPSEL_MCBSP4_MASK;\r\niva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP4_MASK;\r\n}\r\nwritel(iva2_grpsel, resources->per_pm_base + 0xA8);\r\nwritel(mpu_grpsel, resources->per_pm_base + 0xA4);\r\nbreak;\r\ncase BPWR_MCBSP5:\r\niva2_grpsel = readl(resources->per_pm_base + 0xA8);\r\nmpu_grpsel = readl(resources->per_pm_base + 0xA4);\r\nif (enable) {\r\niva2_grpsel |= OMAP3430_GRPSEL_MCBSP5_MASK;\r\nmpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP5_MASK;\r\n} else {\r\nmpu_grpsel |= OMAP3430_GRPSEL_MCBSP5_MASK;\r\niva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP5_MASK;\r\n}\r\nwritel(iva2_grpsel, resources->per_pm_base + 0xA8);\r\nwritel(mpu_grpsel, resources->per_pm_base + 0xA4);\r\nbreak;\r\n}\r\n}
