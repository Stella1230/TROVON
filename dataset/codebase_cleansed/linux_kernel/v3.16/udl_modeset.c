static char *udl_set_register(char *buf, u8 reg, u8 val)\r\n{\r\n*buf++ = 0xAF;\r\n*buf++ = 0x20;\r\n*buf++ = reg;\r\n*buf++ = val;\r\nreturn buf;\r\n}\r\nstatic char *udl_vidreg_lock(char *buf)\r\n{\r\nreturn udl_set_register(buf, 0xFF, 0x00);\r\n}\r\nstatic char *udl_vidreg_unlock(char *buf)\r\n{\r\nreturn udl_set_register(buf, 0xFF, 0xFF);\r\n}\r\nstatic char *udl_set_blank(char *buf, int dpms_mode)\r\n{\r\nu8 reg;\r\nswitch (dpms_mode) {\r\ncase DRM_MODE_DPMS_OFF:\r\nreg = 0x07;\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\nreg = 0x05;\r\nbreak;\r\ncase DRM_MODE_DPMS_SUSPEND:\r\nreg = 0x01;\r\nbreak;\r\ncase DRM_MODE_DPMS_ON:\r\nreg = 0x00;\r\nbreak;\r\n}\r\nreturn udl_set_register(buf, 0x1f, reg);\r\n}\r\nstatic char *udl_set_color_depth(char *buf, u8 selection)\r\n{\r\nreturn udl_set_register(buf, 0x00, selection);\r\n}\r\nstatic char *udl_set_base16bpp(char *wrptr, u32 base)\r\n{\r\nwrptr = udl_set_register(wrptr, 0x20, base >> 16);\r\nwrptr = udl_set_register(wrptr, 0x21, base >> 8);\r\nreturn udl_set_register(wrptr, 0x22, base);\r\n}\r\nstatic char *udl_set_base8bpp(char *wrptr, u32 base)\r\n{\r\nwrptr = udl_set_register(wrptr, 0x26, base >> 16);\r\nwrptr = udl_set_register(wrptr, 0x27, base >> 8);\r\nreturn udl_set_register(wrptr, 0x28, base);\r\n}\r\nstatic char *udl_set_register_16(char *wrptr, u8 reg, u16 value)\r\n{\r\nwrptr = udl_set_register(wrptr, reg, value >> 8);\r\nreturn udl_set_register(wrptr, reg+1, value);\r\n}\r\nstatic char *udl_set_register_16be(char *wrptr, u8 reg, u16 value)\r\n{\r\nwrptr = udl_set_register(wrptr, reg, value);\r\nreturn udl_set_register(wrptr, reg+1, value >> 8);\r\n}\r\nstatic u16 udl_lfsr16(u16 actual_count)\r\n{\r\nu32 lv = 0xFFFF;\r\nwhile (actual_count--) {\r\nlv = ((lv << 1) |\r\n(((lv >> 15) ^ (lv >> 4) ^ (lv >> 2) ^ (lv >> 1)) & 1))\r\n& 0xFFFF;\r\n}\r\nreturn (u16) lv;\r\n}\r\nstatic char *udl_set_register_lfsr16(char *wrptr, u8 reg, u16 value)\r\n{\r\nreturn udl_set_register_16(wrptr, reg, udl_lfsr16(value));\r\n}\r\nstatic char *udl_set_vid_cmds(char *wrptr, struct drm_display_mode *mode)\r\n{\r\nu16 xds, yds;\r\nu16 xde, yde;\r\nu16 yec;\r\nxds = mode->crtc_htotal - mode->crtc_hsync_start;\r\nwrptr = udl_set_register_lfsr16(wrptr, 0x01, xds);\r\nxde = xds + mode->crtc_hdisplay;\r\nwrptr = udl_set_register_lfsr16(wrptr, 0x03, xde);\r\nyds = mode->crtc_vtotal - mode->crtc_vsync_start;\r\nwrptr = udl_set_register_lfsr16(wrptr, 0x05, yds);\r\nyde = yds + mode->crtc_vdisplay;\r\nwrptr = udl_set_register_lfsr16(wrptr, 0x07, yde);\r\nwrptr = udl_set_register_lfsr16(wrptr, 0x09,\r\nmode->crtc_htotal - 1);\r\nwrptr = udl_set_register_lfsr16(wrptr, 0x0B, 1);\r\nwrptr = udl_set_register_lfsr16(wrptr, 0x0D,\r\nmode->crtc_hsync_end - mode->crtc_hsync_start + 1);\r\nwrptr = udl_set_register_16(wrptr, 0x0F, mode->hdisplay);\r\nyec = mode->crtc_vtotal;\r\nwrptr = udl_set_register_lfsr16(wrptr, 0x11, yec);\r\nwrptr = udl_set_register_lfsr16(wrptr, 0x13, 0);\r\nwrptr = udl_set_register_lfsr16(wrptr, 0x15, mode->crtc_vsync_end - mode->crtc_vsync_start);\r\nwrptr = udl_set_register_16(wrptr, 0x17, mode->crtc_vdisplay);\r\nwrptr = udl_set_register_16be(wrptr, 0x1B,\r\nmode->clock / 5);\r\nreturn wrptr;\r\n}\r\nstatic char *udl_dummy_render(char *wrptr)\r\n{\r\n*wrptr++ = 0xAF;\r\n*wrptr++ = 0x6A;\r\n*wrptr++ = 0x00;\r\n*wrptr++ = 0x00;\r\n*wrptr++ = 0x00;\r\n*wrptr++ = 0x01;\r\n*wrptr++ = 0x00;\r\n*wrptr++ = 0x00;\r\n*wrptr++ = 0x00;\r\nreturn wrptr;\r\n}\r\nstatic int udl_crtc_write_mode_to_hw(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct udl_device *udl = dev->dev_private;\r\nstruct urb *urb;\r\nchar *buf;\r\nint retval;\r\nurb = udl_get_urb(dev);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nbuf = (char *)urb->transfer_buffer;\r\nmemcpy(buf, udl->mode_buf, udl->mode_buf_len);\r\nretval = udl_submit_urb(dev, urb, udl->mode_buf_len);\r\nDRM_INFO("write mode info %d\n", udl->mode_buf_len);\r\nreturn retval;\r\n}\r\nstatic void udl_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct udl_device *udl = dev->dev_private;\r\nint retval;\r\nif (mode == DRM_MODE_DPMS_OFF) {\r\nchar *buf;\r\nstruct urb *urb;\r\nurb = udl_get_urb(dev);\r\nif (!urb)\r\nreturn;\r\nbuf = (char *)urb->transfer_buffer;\r\nbuf = udl_vidreg_lock(buf);\r\nbuf = udl_set_blank(buf, mode);\r\nbuf = udl_vidreg_unlock(buf);\r\nbuf = udl_dummy_render(buf);\r\nretval = udl_submit_urb(dev, urb, buf - (char *)\r\nurb->transfer_buffer);\r\n} else {\r\nif (udl->mode_buf_len == 0) {\r\nDRM_ERROR("Trying to enable DPMS with no mode\n");\r\nreturn;\r\n}\r\nudl_crtc_write_mode_to_hw(crtc);\r\n}\r\n}\r\nstatic bool udl_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic int udl_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct udl_framebuffer *ufb = to_udl_fb(crtc->primary->fb);\r\nstruct udl_device *udl = dev->dev_private;\r\nchar *buf;\r\nchar *wrptr;\r\nint color_depth = 0;\r\nbuf = (char *)udl->mode_buf;\r\nwrptr = udl_vidreg_lock(buf);\r\nwrptr = udl_set_color_depth(wrptr, color_depth);\r\nwrptr = udl_set_base16bpp(wrptr, 0);\r\nwrptr = udl_set_base8bpp(wrptr, 2 * mode->vdisplay * mode->hdisplay);\r\nwrptr = udl_set_vid_cmds(wrptr, adjusted_mode);\r\nwrptr = udl_set_blank(wrptr, DRM_MODE_DPMS_ON);\r\nwrptr = udl_vidreg_unlock(wrptr);\r\nwrptr = udl_dummy_render(wrptr);\r\nufb->active_16 = true;\r\nif (old_fb) {\r\nstruct udl_framebuffer *uold_fb = to_udl_fb(old_fb);\r\nuold_fb->active_16 = false;\r\n}\r\nudl->mode_buf_len = wrptr - buf;\r\nudl_handle_damage(ufb, 0, 0, ufb->base.width, ufb->base.height);\r\nreturn 0;\r\n}\r\nstatic void udl_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nudl_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic void udl_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\ndrm_crtc_cleanup(crtc);\r\nkfree(crtc);\r\n}\r\nstatic void udl_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void udl_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nudl_crtc_dpms(crtc, DRM_MODE_DPMS_ON);\r\n}\r\nstatic int udl_crtc_init(struct drm_device *dev)\r\n{\r\nstruct drm_crtc *crtc;\r\ncrtc = kzalloc(sizeof(struct drm_crtc) + sizeof(struct drm_connector *), GFP_KERNEL);\r\nif (crtc == NULL)\r\nreturn -ENOMEM;\r\ndrm_crtc_init(dev, crtc, &udl_crtc_funcs);\r\ndrm_crtc_helper_add(crtc, &udl_helper_funcs);\r\nreturn 0;\r\n}\r\nint udl_modeset_init(struct drm_device *dev)\r\n{\r\nstruct drm_encoder *encoder;\r\ndrm_mode_config_init(dev);\r\ndev->mode_config.min_width = 640;\r\ndev->mode_config.min_height = 480;\r\ndev->mode_config.max_width = 2048;\r\ndev->mode_config.max_height = 2048;\r\ndev->mode_config.prefer_shadow = 0;\r\ndev->mode_config.preferred_depth = 24;\r\ndev->mode_config.funcs = &udl_mode_funcs;\r\ndrm_mode_create_dirty_info_property(dev);\r\nudl_crtc_init(dev);\r\nencoder = udl_encoder_init(dev);\r\nudl_connector_init(dev, encoder);\r\nreturn 0;\r\n}\r\nvoid udl_modeset_cleanup(struct drm_device *dev)\r\n{\r\ndrm_mode_config_cleanup(dev);\r\n}
