static inline void crossbar_writel(int irq_no, int cb_no)\r\n{\r\nwritel(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);\r\n}\r\nstatic inline void crossbar_writew(int irq_no, int cb_no)\r\n{\r\nwritew(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);\r\n}\r\nstatic inline void crossbar_writeb(int irq_no, int cb_no)\r\n{\r\nwriteb(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);\r\n}\r\nstatic inline int allocate_free_irq(int cb_no)\r\n{\r\nint i;\r\nfor (i = 0; i < cb->int_max; i++) {\r\nif (cb->irq_map[i] == IRQ_FREE) {\r\ncb->irq_map[i] = cb_no;\r\nreturn i;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int crossbar_domain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\ncb->write(hw - GIC_IRQ_START, cb->irq_map[hw - GIC_IRQ_START]);\r\nreturn 0;\r\n}\r\nstatic void crossbar_domain_unmap(struct irq_domain *d, unsigned int irq)\r\n{\r\nirq_hw_number_t hw = irq_get_irq_data(irq)->hwirq;\r\nif (hw > GIC_IRQ_START)\r\ncb->irq_map[hw - GIC_IRQ_START] = IRQ_FREE;\r\n}\r\nstatic int crossbar_domain_xlate(struct irq_domain *d,\r\nstruct device_node *controller,\r\nconst u32 *intspec, unsigned int intsize,\r\nunsigned long *out_hwirq,\r\nunsigned int *out_type)\r\n{\r\nunsigned long ret;\r\nret = allocate_free_irq(intspec[1]);\r\nif (IS_ERR_VALUE(ret))\r\nreturn ret;\r\n*out_hwirq = ret + GIC_IRQ_START;\r\nreturn 0;\r\n}\r\nstatic int __init crossbar_of_init(struct device_node *node)\r\n{\r\nint i, size, max, reserved = 0, entry;\r\nconst __be32 *irqsr;\r\ncb = kzalloc(sizeof(*cb), GFP_KERNEL);\r\nif (!cb)\r\nreturn -ENOMEM;\r\ncb->crossbar_base = of_iomap(node, 0);\r\nif (!cb->crossbar_base)\r\ngoto err1;\r\nof_property_read_u32(node, "ti,max-irqs", &max);\r\ncb->irq_map = kzalloc(max * sizeof(int), GFP_KERNEL);\r\nif (!cb->irq_map)\r\ngoto err2;\r\ncb->int_max = max;\r\nfor (i = 0; i < max; i++)\r\ncb->irq_map[i] = IRQ_FREE;\r\nirqsr = of_get_property(node, "ti,irqs-reserved", &size);\r\nif (irqsr) {\r\nsize /= sizeof(__be32);\r\nfor (i = 0; i < size; i++) {\r\nof_property_read_u32_index(node,\r\n"ti,irqs-reserved",\r\ni, &entry);\r\nif (entry > max) {\r\npr_err("Invalid reserved entry\n");\r\ngoto err3;\r\n}\r\ncb->irq_map[entry] = 0;\r\n}\r\n}\r\ncb->register_offsets = kzalloc(max * sizeof(int), GFP_KERNEL);\r\nif (!cb->register_offsets)\r\ngoto err3;\r\nof_property_read_u32(node, "ti,reg-size", &size);\r\nswitch (size) {\r\ncase 1:\r\ncb->write = crossbar_writeb;\r\nbreak;\r\ncase 2:\r\ncb->write = crossbar_writew;\r\nbreak;\r\ncase 4:\r\ncb->write = crossbar_writel;\r\nbreak;\r\ndefault:\r\npr_err("Invalid reg-size property\n");\r\ngoto err4;\r\nbreak;\r\n}\r\nfor (i = 0; i < max; i++) {\r\nif (!cb->irq_map[i])\r\ncontinue;\r\ncb->register_offsets[i] = reserved;\r\nreserved += size;\r\n}\r\nregister_routable_domain_ops(&routable_irq_domain_ops);\r\nreturn 0;\r\nerr4:\r\nkfree(cb->register_offsets);\r\nerr3:\r\nkfree(cb->irq_map);\r\nerr2:\r\niounmap(cb->crossbar_base);\r\nerr1:\r\nkfree(cb);\r\nreturn -ENOMEM;\r\n}\r\nint __init irqcrossbar_init(void)\r\n{\r\nstruct device_node *np;\r\nnp = of_find_matching_node(NULL, crossbar_match);\r\nif (!np)\r\nreturn -ENODEV;\r\ncrossbar_of_init(np);\r\nreturn 0;\r\n}
