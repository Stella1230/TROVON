static u16 __phy_read(struct gem *gp, int phy_addr, int reg)\r\n{\r\nu32 cmd;\r\nint limit = 10000;\r\ncmd = (1 << 30);\r\ncmd |= (2 << 28);\r\ncmd |= (phy_addr << 23) & MIF_FRAME_PHYAD;\r\ncmd |= (reg << 18) & MIF_FRAME_REGAD;\r\ncmd |= (MIF_FRAME_TAMSB);\r\nwritel(cmd, gp->regs + MIF_FRAME);\r\nwhile (--limit) {\r\ncmd = readl(gp->regs + MIF_FRAME);\r\nif (cmd & MIF_FRAME_TALSB)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!limit)\r\ncmd = 0xffff;\r\nreturn cmd & MIF_FRAME_DATA;\r\n}\r\nstatic inline int _phy_read(struct net_device *dev, int mii_id, int reg)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nreturn __phy_read(gp, mii_id, reg);\r\n}\r\nstatic inline u16 phy_read(struct gem *gp, int reg)\r\n{\r\nreturn __phy_read(gp, gp->mii_phy_addr, reg);\r\n}\r\nstatic void __phy_write(struct gem *gp, int phy_addr, int reg, u16 val)\r\n{\r\nu32 cmd;\r\nint limit = 10000;\r\ncmd = (1 << 30);\r\ncmd |= (1 << 28);\r\ncmd |= (phy_addr << 23) & MIF_FRAME_PHYAD;\r\ncmd |= (reg << 18) & MIF_FRAME_REGAD;\r\ncmd |= (MIF_FRAME_TAMSB);\r\ncmd |= (val & MIF_FRAME_DATA);\r\nwritel(cmd, gp->regs + MIF_FRAME);\r\nwhile (limit--) {\r\ncmd = readl(gp->regs + MIF_FRAME);\r\nif (cmd & MIF_FRAME_TALSB)\r\nbreak;\r\nudelay(10);\r\n}\r\n}\r\nstatic inline void _phy_write(struct net_device *dev, int mii_id, int reg, int val)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\n__phy_write(gp, mii_id, reg, val & 0xffff);\r\n}\r\nstatic inline void phy_write(struct gem *gp, int reg, u16 val)\r\n{\r\n__phy_write(gp, gp->mii_phy_addr, reg, val);\r\n}\r\nstatic inline void gem_enable_ints(struct gem *gp)\r\n{\r\nwritel(GREG_STAT_TXDONE, gp->regs + GREG_IMASK);\r\n}\r\nstatic inline void gem_disable_ints(struct gem *gp)\r\n{\r\nwritel(GREG_STAT_NAPI | GREG_STAT_TXDONE, gp->regs + GREG_IMASK);\r\n(void)readl(gp->regs + GREG_IMASK);\r\n}\r\nstatic void gem_get_cell(struct gem *gp)\r\n{\r\nBUG_ON(gp->cell_enabled < 0);\r\ngp->cell_enabled++;\r\n#ifdef CONFIG_PPC_PMAC\r\nif (gp->cell_enabled == 1) {\r\nmb();\r\npmac_call_feature(PMAC_FTR_GMAC_ENABLE, gp->of_node, 0, 1);\r\nudelay(10);\r\n}\r\n#endif\r\n}\r\nstatic void gem_put_cell(struct gem *gp)\r\n{\r\nBUG_ON(gp->cell_enabled <= 0);\r\ngp->cell_enabled--;\r\n#ifdef CONFIG_PPC_PMAC\r\nif (gp->cell_enabled == 0) {\r\nmb();\r\npmac_call_feature(PMAC_FTR_GMAC_ENABLE, gp->of_node, 0, 0);\r\nudelay(10);\r\n}\r\n#endif\r\n}\r\nstatic inline void gem_netif_stop(struct gem *gp)\r\n{\r\ngp->dev->trans_start = jiffies;\r\nnapi_disable(&gp->napi);\r\nnetif_tx_disable(gp->dev);\r\n}\r\nstatic inline void gem_netif_start(struct gem *gp)\r\n{\r\nnetif_wake_queue(gp->dev);\r\nnapi_enable(&gp->napi);\r\n}\r\nstatic void gem_schedule_reset(struct gem *gp)\r\n{\r\ngp->reset_task_pending = 1;\r\nschedule_work(&gp->reset_task);\r\n}\r\nstatic void gem_handle_mif_event(struct gem *gp, u32 reg_val, u32 changed_bits)\r\n{\r\nif (netif_msg_intr(gp))\r\nprintk(KERN_DEBUG "%s: mif interrupt\n", gp->dev->name);\r\n}\r\nstatic int gem_pcs_interrupt(struct net_device *dev, struct gem *gp, u32 gem_status)\r\n{\r\nu32 pcs_istat = readl(gp->regs + PCS_ISTAT);\r\nu32 pcs_miistat;\r\nif (netif_msg_intr(gp))\r\nprintk(KERN_DEBUG "%s: pcs interrupt, pcs_istat: 0x%x\n",\r\ngp->dev->name, pcs_istat);\r\nif (!(pcs_istat & PCS_ISTAT_LSC)) {\r\nnetdev_err(dev, "PCS irq but no link status change???\n");\r\nreturn 0;\r\n}\r\npcs_miistat = readl(gp->regs + PCS_MIISTAT);\r\nif (!(pcs_miistat & PCS_MIISTAT_LS))\r\npcs_miistat |=\r\n(readl(gp->regs + PCS_MIISTAT) &\r\nPCS_MIISTAT_LS);\r\nif (pcs_miistat & PCS_MIISTAT_ANC) {\r\nif (pcs_miistat & PCS_MIISTAT_RF)\r\nnetdev_info(dev, "PCS AutoNEG complete, RemoteFault\n");\r\nelse\r\nnetdev_info(dev, "PCS AutoNEG complete\n");\r\n}\r\nif (pcs_miistat & PCS_MIISTAT_LS) {\r\nnetdev_info(dev, "PCS link is now up\n");\r\nnetif_carrier_on(gp->dev);\r\n} else {\r\nnetdev_info(dev, "PCS link is now down\n");\r\nnetif_carrier_off(gp->dev);\r\nif (!timer_pending(&gp->link_timer))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gem_txmac_interrupt(struct net_device *dev, struct gem *gp, u32 gem_status)\r\n{\r\nu32 txmac_stat = readl(gp->regs + MAC_TXSTAT);\r\nif (netif_msg_intr(gp))\r\nprintk(KERN_DEBUG "%s: txmac interrupt, txmac_stat: 0x%x\n",\r\ngp->dev->name, txmac_stat);\r\nif ((txmac_stat & MAC_TXSTAT_DTE) &&\r\n!(txmac_stat & ~MAC_TXSTAT_DTE))\r\nreturn 0;\r\nif (txmac_stat & MAC_TXSTAT_URUN) {\r\nnetdev_err(dev, "TX MAC xmit underrun\n");\r\ndev->stats.tx_fifo_errors++;\r\n}\r\nif (txmac_stat & MAC_TXSTAT_MPE) {\r\nnetdev_err(dev, "TX MAC max packet size error\n");\r\ndev->stats.tx_errors++;\r\n}\r\nif (txmac_stat & MAC_TXSTAT_NCE)\r\ndev->stats.collisions += 0x10000;\r\nif (txmac_stat & MAC_TXSTAT_ECE) {\r\ndev->stats.tx_aborted_errors += 0x10000;\r\ndev->stats.collisions += 0x10000;\r\n}\r\nif (txmac_stat & MAC_TXSTAT_LCE) {\r\ndev->stats.tx_aborted_errors += 0x10000;\r\ndev->stats.collisions += 0x10000;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gem_rxmac_reset(struct gem *gp)\r\n{\r\nstruct net_device *dev = gp->dev;\r\nint limit, i;\r\nu64 desc_dma;\r\nu32 val;\r\nwritel(MAC_RXRST_CMD, gp->regs + MAC_RXRST);\r\nfor (limit = 0; limit < 5000; limit++) {\r\nif (!(readl(gp->regs + MAC_RXRST) & MAC_RXRST_CMD))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (limit == 5000) {\r\nnetdev_err(dev, "RX MAC will not reset, resetting whole chip\n");\r\nreturn 1;\r\n}\r\nwritel(gp->mac_rx_cfg & ~MAC_RXCFG_ENAB,\r\ngp->regs + MAC_RXCFG);\r\nfor (limit = 0; limit < 5000; limit++) {\r\nif (!(readl(gp->regs + MAC_RXCFG) & MAC_RXCFG_ENAB))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (limit == 5000) {\r\nnetdev_err(dev, "RX MAC will not disable, resetting whole chip\n");\r\nreturn 1;\r\n}\r\nwritel(0, gp->regs + RXDMA_CFG);\r\nfor (limit = 0; limit < 5000; limit++) {\r\nif (!(readl(gp->regs + RXDMA_CFG) & RXDMA_CFG_ENABLE))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (limit == 5000) {\r\nnetdev_err(dev, "RX DMA will not disable, resetting whole chip\n");\r\nreturn 1;\r\n}\r\nmdelay(5);\r\nwritel(gp->swrst_base | GREG_SWRST_RXRST,\r\ngp->regs + GREG_SWRST);\r\nfor (limit = 0; limit < 5000; limit++) {\r\nif (!(readl(gp->regs + GREG_SWRST) & GREG_SWRST_RXRST))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (limit == 5000) {\r\nnetdev_err(dev, "RX reset command will not execute, resetting whole chip\n");\r\nreturn 1;\r\n}\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct gem_rxd *rxd = &gp->init_block->rxd[i];\r\nif (gp->rx_skbs[i] == NULL) {\r\nnetdev_err(dev, "Parts of RX ring empty, resetting whole chip\n");\r\nreturn 1;\r\n}\r\nrxd->status_word = cpu_to_le64(RXDCTRL_FRESH(gp));\r\n}\r\ngp->rx_new = gp->rx_old = 0;\r\ndesc_dma = (u64) gp->gblock_dvma;\r\ndesc_dma += (INIT_BLOCK_TX_RING_SIZE * sizeof(struct gem_txd));\r\nwritel(desc_dma >> 32, gp->regs + RXDMA_DBHI);\r\nwritel(desc_dma & 0xffffffff, gp->regs + RXDMA_DBLOW);\r\nwritel(RX_RING_SIZE - 4, gp->regs + RXDMA_KICK);\r\nval = (RXDMA_CFG_BASE | (RX_OFFSET << 10) |\r\n((14 / 2) << 13) | RXDMA_CFG_FTHRESH_128);\r\nwritel(val, gp->regs + RXDMA_CFG);\r\nif (readl(gp->regs + GREG_BIFCFG) & GREG_BIFCFG_M66EN)\r\nwritel(((5 & RXDMA_BLANK_IPKTS) |\r\n((8 << 12) & RXDMA_BLANK_ITIME)),\r\ngp->regs + RXDMA_BLANK);\r\nelse\r\nwritel(((5 & RXDMA_BLANK_IPKTS) |\r\n((4 << 12) & RXDMA_BLANK_ITIME)),\r\ngp->regs + RXDMA_BLANK);\r\nval = (((gp->rx_pause_off / 64) << 0) & RXDMA_PTHRESH_OFF);\r\nval |= (((gp->rx_pause_on / 64) << 12) & RXDMA_PTHRESH_ON);\r\nwritel(val, gp->regs + RXDMA_PTHRESH);\r\nval = readl(gp->regs + RXDMA_CFG);\r\nwritel(val | RXDMA_CFG_ENABLE, gp->regs + RXDMA_CFG);\r\nwritel(MAC_RXSTAT_RCV, gp->regs + MAC_RXMASK);\r\nval = readl(gp->regs + MAC_RXCFG);\r\nwritel(val | MAC_RXCFG_ENAB, gp->regs + MAC_RXCFG);\r\nreturn 0;\r\n}\r\nstatic int gem_rxmac_interrupt(struct net_device *dev, struct gem *gp, u32 gem_status)\r\n{\r\nu32 rxmac_stat = readl(gp->regs + MAC_RXSTAT);\r\nint ret = 0;\r\nif (netif_msg_intr(gp))\r\nprintk(KERN_DEBUG "%s: rxmac interrupt, rxmac_stat: 0x%x\n",\r\ngp->dev->name, rxmac_stat);\r\nif (rxmac_stat & MAC_RXSTAT_OFLW) {\r\nu32 smac = readl(gp->regs + MAC_SMACHINE);\r\nnetdev_err(dev, "RX MAC fifo overflow smac[%08x]\n", smac);\r\ndev->stats.rx_over_errors++;\r\ndev->stats.rx_fifo_errors++;\r\nret = gem_rxmac_reset(gp);\r\n}\r\nif (rxmac_stat & MAC_RXSTAT_ACE)\r\ndev->stats.rx_frame_errors += 0x10000;\r\nif (rxmac_stat & MAC_RXSTAT_CCE)\r\ndev->stats.rx_crc_errors += 0x10000;\r\nif (rxmac_stat & MAC_RXSTAT_LCE)\r\ndev->stats.rx_length_errors += 0x10000;\r\nreturn ret;\r\n}\r\nstatic int gem_mac_interrupt(struct net_device *dev, struct gem *gp, u32 gem_status)\r\n{\r\nu32 mac_cstat = readl(gp->regs + MAC_CSTAT);\r\nif (netif_msg_intr(gp))\r\nprintk(KERN_DEBUG "%s: mac interrupt, mac_cstat: 0x%x\n",\r\ngp->dev->name, mac_cstat);\r\nif (mac_cstat & MAC_CSTAT_PS)\r\ngp->pause_entered++;\r\nif (mac_cstat & MAC_CSTAT_PRCV)\r\ngp->pause_last_time_recvd = (mac_cstat >> 16);\r\nreturn 0;\r\n}\r\nstatic int gem_mif_interrupt(struct net_device *dev, struct gem *gp, u32 gem_status)\r\n{\r\nu32 mif_status = readl(gp->regs + MIF_STATUS);\r\nu32 reg_val, changed_bits;\r\nreg_val = (mif_status & MIF_STATUS_DATA) >> 16;\r\nchanged_bits = (mif_status & MIF_STATUS_STAT);\r\ngem_handle_mif_event(gp, reg_val, changed_bits);\r\nreturn 0;\r\n}\r\nstatic int gem_pci_interrupt(struct net_device *dev, struct gem *gp, u32 gem_status)\r\n{\r\nu32 pci_estat = readl(gp->regs + GREG_PCIESTAT);\r\nif (gp->pdev->vendor == PCI_VENDOR_ID_SUN &&\r\ngp->pdev->device == PCI_DEVICE_ID_SUN_GEM) {\r\nnetdev_err(dev, "PCI error [%04x]", pci_estat);\r\nif (pci_estat & GREG_PCIESTAT_BADACK)\r\npr_cont(" <No ACK64# during ABS64 cycle>");\r\nif (pci_estat & GREG_PCIESTAT_DTRTO)\r\npr_cont(" <Delayed transaction timeout>");\r\nif (pci_estat & GREG_PCIESTAT_OTHER)\r\npr_cont(" <other>");\r\npr_cont("\n");\r\n} else {\r\npci_estat |= GREG_PCIESTAT_OTHER;\r\nnetdev_err(dev, "PCI error\n");\r\n}\r\nif (pci_estat & GREG_PCIESTAT_OTHER) {\r\nu16 pci_cfg_stat;\r\npci_read_config_word(gp->pdev, PCI_STATUS,\r\n&pci_cfg_stat);\r\nnetdev_err(dev, "Read PCI cfg space status [%04x]\n",\r\npci_cfg_stat);\r\nif (pci_cfg_stat & PCI_STATUS_PARITY)\r\nnetdev_err(dev, "PCI parity error detected\n");\r\nif (pci_cfg_stat & PCI_STATUS_SIG_TARGET_ABORT)\r\nnetdev_err(dev, "PCI target abort\n");\r\nif (pci_cfg_stat & PCI_STATUS_REC_TARGET_ABORT)\r\nnetdev_err(dev, "PCI master acks target abort\n");\r\nif (pci_cfg_stat & PCI_STATUS_REC_MASTER_ABORT)\r\nnetdev_err(dev, "PCI master abort\n");\r\nif (pci_cfg_stat & PCI_STATUS_SIG_SYSTEM_ERROR)\r\nnetdev_err(dev, "PCI system error SERR#\n");\r\nif (pci_cfg_stat & PCI_STATUS_DETECTED_PARITY)\r\nnetdev_err(dev, "PCI parity error\n");\r\npci_cfg_stat &= (PCI_STATUS_PARITY |\r\nPCI_STATUS_SIG_TARGET_ABORT |\r\nPCI_STATUS_REC_TARGET_ABORT |\r\nPCI_STATUS_REC_MASTER_ABORT |\r\nPCI_STATUS_SIG_SYSTEM_ERROR |\r\nPCI_STATUS_DETECTED_PARITY);\r\npci_write_config_word(gp->pdev,\r\nPCI_STATUS, pci_cfg_stat);\r\n}\r\nreturn 1;\r\n}\r\nstatic int gem_abnormal_irq(struct net_device *dev, struct gem *gp, u32 gem_status)\r\n{\r\nif (gem_status & GREG_STAT_RXNOBUF) {\r\nif (netif_msg_rx_err(gp))\r\nprintk(KERN_DEBUG "%s: no buffer for rx frame\n",\r\ngp->dev->name);\r\ndev->stats.rx_dropped++;\r\n}\r\nif (gem_status & GREG_STAT_RXTAGERR) {\r\nif (netif_msg_rx_err(gp))\r\nprintk(KERN_DEBUG "%s: corrupt rx tag framing\n",\r\ngp->dev->name);\r\ndev->stats.rx_errors++;\r\nreturn 1;\r\n}\r\nif (gem_status & GREG_STAT_PCS) {\r\nif (gem_pcs_interrupt(dev, gp, gem_status))\r\nreturn 1;\r\n}\r\nif (gem_status & GREG_STAT_TXMAC) {\r\nif (gem_txmac_interrupt(dev, gp, gem_status))\r\nreturn 1;\r\n}\r\nif (gem_status & GREG_STAT_RXMAC) {\r\nif (gem_rxmac_interrupt(dev, gp, gem_status))\r\nreturn 1;\r\n}\r\nif (gem_status & GREG_STAT_MAC) {\r\nif (gem_mac_interrupt(dev, gp, gem_status))\r\nreturn 1;\r\n}\r\nif (gem_status & GREG_STAT_MIF) {\r\nif (gem_mif_interrupt(dev, gp, gem_status))\r\nreturn 1;\r\n}\r\nif (gem_status & GREG_STAT_PCIERR) {\r\nif (gem_pci_interrupt(dev, gp, gem_status))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic __inline__ void gem_tx(struct net_device *dev, struct gem *gp, u32 gem_status)\r\n{\r\nint entry, limit;\r\nentry = gp->tx_old;\r\nlimit = ((gem_status & GREG_STAT_TXNR) >> GREG_STAT_TXNR_SHIFT);\r\nwhile (entry != limit) {\r\nstruct sk_buff *skb;\r\nstruct gem_txd *txd;\r\ndma_addr_t dma_addr;\r\nu32 dma_len;\r\nint frag;\r\nif (netif_msg_tx_done(gp))\r\nprintk(KERN_DEBUG "%s: tx done, slot %d\n",\r\ngp->dev->name, entry);\r\nskb = gp->tx_skbs[entry];\r\nif (skb_shinfo(skb)->nr_frags) {\r\nint last = entry + skb_shinfo(skb)->nr_frags;\r\nint walk = entry;\r\nint incomplete = 0;\r\nlast &= (TX_RING_SIZE - 1);\r\nfor (;;) {\r\nwalk = NEXT_TX(walk);\r\nif (walk == limit)\r\nincomplete = 1;\r\nif (walk == last)\r\nbreak;\r\n}\r\nif (incomplete)\r\nbreak;\r\n}\r\ngp->tx_skbs[entry] = NULL;\r\ndev->stats.tx_bytes += skb->len;\r\nfor (frag = 0; frag <= skb_shinfo(skb)->nr_frags; frag++) {\r\ntxd = &gp->init_block->txd[entry];\r\ndma_addr = le64_to_cpu(txd->buffer);\r\ndma_len = le64_to_cpu(txd->control_word) & TXDCTRL_BUFSZ;\r\npci_unmap_page(gp->pdev, dma_addr, dma_len, PCI_DMA_TODEVICE);\r\nentry = NEXT_TX(entry);\r\n}\r\ndev->stats.tx_packets++;\r\ndev_consume_skb_any(skb);\r\n}\r\ngp->tx_old = entry;\r\nsmp_mb();\r\nif (unlikely(netif_queue_stopped(dev) &&\r\nTX_BUFFS_AVAIL(gp) > (MAX_SKB_FRAGS + 1))) {\r\nstruct netdev_queue *txq = netdev_get_tx_queue(dev, 0);\r\n__netif_tx_lock(txq, smp_processor_id());\r\nif (netif_queue_stopped(dev) &&\r\nTX_BUFFS_AVAIL(gp) > (MAX_SKB_FRAGS + 1))\r\nnetif_wake_queue(dev);\r\n__netif_tx_unlock(txq);\r\n}\r\n}\r\nstatic __inline__ void gem_post_rxds(struct gem *gp, int limit)\r\n{\r\nint cluster_start, curr, count, kick;\r\ncluster_start = curr = (gp->rx_new & ~(4 - 1));\r\ncount = 0;\r\nkick = -1;\r\nwmb();\r\nwhile (curr != limit) {\r\ncurr = NEXT_RX(curr);\r\nif (++count == 4) {\r\nstruct gem_rxd *rxd =\r\n&gp->init_block->rxd[cluster_start];\r\nfor (;;) {\r\nrxd->status_word = cpu_to_le64(RXDCTRL_FRESH(gp));\r\nrxd++;\r\ncluster_start = NEXT_RX(cluster_start);\r\nif (cluster_start == curr)\r\nbreak;\r\n}\r\nkick = curr;\r\ncount = 0;\r\n}\r\n}\r\nif (kick >= 0) {\r\nmb();\r\nwritel(kick, gp->regs + RXDMA_KICK);\r\n}\r\n}\r\nint gem_rx(struct gem *gp, int work_to_do)\r\n{\r\nstruct net_device *dev = gp->dev;\r\nint entry, drops, work_done = 0;\r\nu32 done;\r\n__sum16 csum;\r\nif (netif_msg_rx_status(gp))\r\nprintk(KERN_DEBUG "%s: rx interrupt, done: %d, rx_new: %d\n",\r\ngp->dev->name, readl(gp->regs + RXDMA_DONE), gp->rx_new);\r\nentry = gp->rx_new;\r\ndrops = 0;\r\ndone = readl(gp->regs + RXDMA_DONE);\r\nfor (;;) {\r\nstruct gem_rxd *rxd = &gp->init_block->rxd[entry];\r\nstruct sk_buff *skb;\r\nu64 status = le64_to_cpu(rxd->status_word);\r\ndma_addr_t dma_addr;\r\nint len;\r\nif ((status & RXDCTRL_OWN) != 0)\r\nbreak;\r\nif (work_done >= RX_RING_SIZE || work_done >= work_to_do)\r\nbreak;\r\nif (entry == done) {\r\ndone = readl(gp->regs + RXDMA_DONE);\r\nif (entry == done)\r\nbreak;\r\n}\r\nwork_done++;\r\nskb = gp->rx_skbs[entry];\r\nlen = (status & RXDCTRL_BUFSZ) >> 16;\r\nif ((len < ETH_ZLEN) || (status & RXDCTRL_BAD)) {\r\ndev->stats.rx_errors++;\r\nif (len < ETH_ZLEN)\r\ndev->stats.rx_length_errors++;\r\nif (len & RXDCTRL_BAD)\r\ndev->stats.rx_crc_errors++;\r\ndrop_it:\r\ndev->stats.rx_dropped++;\r\ngoto next;\r\n}\r\ndma_addr = le64_to_cpu(rxd->buffer);\r\nif (len > RX_COPY_THRESHOLD) {\r\nstruct sk_buff *new_skb;\r\nnew_skb = gem_alloc_skb(dev, RX_BUF_ALLOC_SIZE(gp), GFP_ATOMIC);\r\nif (new_skb == NULL) {\r\ndrops++;\r\ngoto drop_it;\r\n}\r\npci_unmap_page(gp->pdev, dma_addr,\r\nRX_BUF_ALLOC_SIZE(gp),\r\nPCI_DMA_FROMDEVICE);\r\ngp->rx_skbs[entry] = new_skb;\r\nskb_put(new_skb, (gp->rx_buf_sz + RX_OFFSET));\r\nrxd->buffer = cpu_to_le64(pci_map_page(gp->pdev,\r\nvirt_to_page(new_skb->data),\r\noffset_in_page(new_skb->data),\r\nRX_BUF_ALLOC_SIZE(gp),\r\nPCI_DMA_FROMDEVICE));\r\nskb_reserve(new_skb, RX_OFFSET);\r\nskb_trim(skb, len);\r\n} else {\r\nstruct sk_buff *copy_skb = netdev_alloc_skb(dev, len + 2);\r\nif (copy_skb == NULL) {\r\ndrops++;\r\ngoto drop_it;\r\n}\r\nskb_reserve(copy_skb, 2);\r\nskb_put(copy_skb, len);\r\npci_dma_sync_single_for_cpu(gp->pdev, dma_addr, len, PCI_DMA_FROMDEVICE);\r\nskb_copy_from_linear_data(skb, copy_skb->data, len);\r\npci_dma_sync_single_for_device(gp->pdev, dma_addr, len, PCI_DMA_FROMDEVICE);\r\nskb = copy_skb;\r\n}\r\ncsum = (__force __sum16)htons((status & RXDCTRL_TCPCSUM) ^ 0xffff);\r\nskb->csum = csum_unfold(csum);\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\nskb->protocol = eth_type_trans(skb, gp->dev);\r\nnapi_gro_receive(&gp->napi, skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\nnext:\r\nentry = NEXT_RX(entry);\r\n}\r\ngem_post_rxds(gp, entry);\r\ngp->rx_new = entry;\r\nif (drops)\r\nnetdev_info(gp->dev, "Memory squeeze, deferring packet\n");\r\nreturn work_done;\r\n}\r\nstatic int gem_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct gem *gp = container_of(napi, struct gem, napi);\r\nstruct net_device *dev = gp->dev;\r\nint work_done;\r\nwork_done = 0;\r\ndo {\r\nif (unlikely(gp->status & GREG_STAT_ABNORMAL)) {\r\nstruct netdev_queue *txq = netdev_get_tx_queue(dev, 0);\r\nint reset;\r\n__netif_tx_lock(txq, smp_processor_id());\r\nreset = gem_abnormal_irq(dev, gp, gp->status);\r\n__netif_tx_unlock(txq);\r\nif (reset) {\r\ngem_schedule_reset(gp);\r\nnapi_complete(napi);\r\nreturn work_done;\r\n}\r\n}\r\ngem_tx(dev, gp, gp->status);\r\nwork_done += gem_rx(gp, budget - work_done);\r\nif (work_done >= budget)\r\nreturn work_done;\r\ngp->status = readl(gp->regs + GREG_STAT);\r\n} while (gp->status & GREG_STAT_NAPI);\r\nnapi_complete(napi);\r\ngem_enable_ints(gp);\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t gem_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct gem *gp = netdev_priv(dev);\r\nif (napi_schedule_prep(&gp->napi)) {\r\nu32 gem_status = readl(gp->regs + GREG_STAT);\r\nif (unlikely(gem_status == 0)) {\r\nnapi_enable(&gp->napi);\r\nreturn IRQ_NONE;\r\n}\r\nif (netif_msg_intr(gp))\r\nprintk(KERN_DEBUG "%s: gem_interrupt() gem_status: 0x%x\n",\r\ngp->dev->name, gem_status);\r\ngp->status = gem_status;\r\ngem_disable_ints(gp);\r\n__napi_schedule(&gp->napi);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void gem_poll_controller(struct net_device *dev)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\ndisable_irq(gp->pdev->irq);\r\ngem_interrupt(gp->pdev->irq, dev);\r\nenable_irq(gp->pdev->irq);\r\n}\r\nstatic void gem_tx_timeout(struct net_device *dev)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nnetdev_err(dev, "transmit timed out, resetting\n");\r\nnetdev_err(dev, "TX_STATE[%08x:%08x:%08x]\n",\r\nreadl(gp->regs + TXDMA_CFG),\r\nreadl(gp->regs + MAC_TXSTAT),\r\nreadl(gp->regs + MAC_TXCFG));\r\nnetdev_err(dev, "RX_STATE[%08x:%08x:%08x]\n",\r\nreadl(gp->regs + RXDMA_CFG),\r\nreadl(gp->regs + MAC_RXSTAT),\r\nreadl(gp->regs + MAC_RXCFG));\r\ngem_schedule_reset(gp);\r\n}\r\nstatic __inline__ int gem_intme(int entry)\r\n{\r\nif (!(entry & ((TX_RING_SIZE>>1)-1)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t gem_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nint entry;\r\nu64 ctrl;\r\nctrl = 0;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nconst u64 csum_start_off = skb_checksum_start_offset(skb);\r\nconst u64 csum_stuff_off = csum_start_off + skb->csum_offset;\r\nctrl = (TXDCTRL_CENAB |\r\n(csum_start_off << 15) |\r\n(csum_stuff_off << 21));\r\n}\r\nif (unlikely(TX_BUFFS_AVAIL(gp) <= (skb_shinfo(skb)->nr_frags + 1))) {\r\nif (!netif_queue_stopped(dev)) {\r\nnetif_stop_queue(dev);\r\nnetdev_err(dev, "BUG! Tx Ring full when queue awake!\n");\r\n}\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nentry = gp->tx_new;\r\ngp->tx_skbs[entry] = skb;\r\nif (skb_shinfo(skb)->nr_frags == 0) {\r\nstruct gem_txd *txd = &gp->init_block->txd[entry];\r\ndma_addr_t mapping;\r\nu32 len;\r\nlen = skb->len;\r\nmapping = pci_map_page(gp->pdev,\r\nvirt_to_page(skb->data),\r\noffset_in_page(skb->data),\r\nlen, PCI_DMA_TODEVICE);\r\nctrl |= TXDCTRL_SOF | TXDCTRL_EOF | len;\r\nif (gem_intme(entry))\r\nctrl |= TXDCTRL_INTME;\r\ntxd->buffer = cpu_to_le64(mapping);\r\nwmb();\r\ntxd->control_word = cpu_to_le64(ctrl);\r\nentry = NEXT_TX(entry);\r\n} else {\r\nstruct gem_txd *txd;\r\nu32 first_len;\r\nu64 intme;\r\ndma_addr_t first_mapping;\r\nint frag, first_entry = entry;\r\nintme = 0;\r\nif (gem_intme(entry))\r\nintme |= TXDCTRL_INTME;\r\nfirst_len = skb_headlen(skb);\r\nfirst_mapping = pci_map_page(gp->pdev, virt_to_page(skb->data),\r\noffset_in_page(skb->data),\r\nfirst_len, PCI_DMA_TODEVICE);\r\nentry = NEXT_TX(entry);\r\nfor (frag = 0; frag < skb_shinfo(skb)->nr_frags; frag++) {\r\nconst skb_frag_t *this_frag = &skb_shinfo(skb)->frags[frag];\r\nu32 len;\r\ndma_addr_t mapping;\r\nu64 this_ctrl;\r\nlen = skb_frag_size(this_frag);\r\nmapping = skb_frag_dma_map(&gp->pdev->dev, this_frag,\r\n0, len, DMA_TO_DEVICE);\r\nthis_ctrl = ctrl;\r\nif (frag == skb_shinfo(skb)->nr_frags - 1)\r\nthis_ctrl |= TXDCTRL_EOF;\r\ntxd = &gp->init_block->txd[entry];\r\ntxd->buffer = cpu_to_le64(mapping);\r\nwmb();\r\ntxd->control_word = cpu_to_le64(this_ctrl | len);\r\nif (gem_intme(entry))\r\nintme |= TXDCTRL_INTME;\r\nentry = NEXT_TX(entry);\r\n}\r\ntxd = &gp->init_block->txd[first_entry];\r\ntxd->buffer = cpu_to_le64(first_mapping);\r\nwmb();\r\ntxd->control_word =\r\ncpu_to_le64(ctrl | TXDCTRL_SOF | intme | first_len);\r\n}\r\ngp->tx_new = entry;\r\nif (unlikely(TX_BUFFS_AVAIL(gp) <= (MAX_SKB_FRAGS + 1))) {\r\nnetif_stop_queue(dev);\r\nsmp_mb();\r\nif (TX_BUFFS_AVAIL(gp) > (MAX_SKB_FRAGS + 1))\r\nnetif_wake_queue(dev);\r\n}\r\nif (netif_msg_tx_queued(gp))\r\nprintk(KERN_DEBUG "%s: tx queued, slot %d, skblen %d\n",\r\ndev->name, entry, skb->len);\r\nmb();\r\nwritel(gp->tx_new, gp->regs + TXDMA_KICK);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void gem_pcs_reset(struct gem *gp)\r\n{\r\nint limit;\r\nu32 val;\r\nval = readl(gp->regs + PCS_MIICTRL);\r\nval |= PCS_MIICTRL_RST;\r\nwritel(val, gp->regs + PCS_MIICTRL);\r\nlimit = 32;\r\nwhile (readl(gp->regs + PCS_MIICTRL) & PCS_MIICTRL_RST) {\r\nudelay(100);\r\nif (limit-- <= 0)\r\nbreak;\r\n}\r\nif (limit < 0)\r\nnetdev_warn(gp->dev, "PCS reset bit would not clear\n");\r\n}\r\nstatic void gem_pcs_reinit_adv(struct gem *gp)\r\n{\r\nu32 val;\r\nval = readl(gp->regs + PCS_CFG);\r\nval &= ~(PCS_CFG_ENABLE | PCS_CFG_TO);\r\nwritel(val, gp->regs + PCS_CFG);\r\nval = readl(gp->regs + PCS_MIIADV);\r\nval |= (PCS_MIIADV_FD | PCS_MIIADV_HD |\r\nPCS_MIIADV_SP | PCS_MIIADV_AP);\r\nwritel(val, gp->regs + PCS_MIIADV);\r\nval = readl(gp->regs + PCS_MIICTRL);\r\nval |= (PCS_MIICTRL_RAN | PCS_MIICTRL_ANE);\r\nval &= ~PCS_MIICTRL_WB;\r\nwritel(val, gp->regs + PCS_MIICTRL);\r\nval = readl(gp->regs + PCS_CFG);\r\nval |= PCS_CFG_ENABLE;\r\nwritel(val, gp->regs + PCS_CFG);\r\nval = readl(gp->regs + PCS_SCTRL);\r\nif (gp->phy_type == phy_serialink)\r\nval &= ~PCS_SCTRL_LOOP;\r\nelse\r\nval |= PCS_SCTRL_LOOP;\r\nwritel(val, gp->regs + PCS_SCTRL);\r\n}\r\nstatic void gem_reset(struct gem *gp)\r\n{\r\nint limit;\r\nu32 val;\r\nwritel(0xffffffff, gp->regs + GREG_IMASK);\r\nwritel(gp->swrst_base | GREG_SWRST_TXRST | GREG_SWRST_RXRST,\r\ngp->regs + GREG_SWRST);\r\nlimit = STOP_TRIES;\r\ndo {\r\nudelay(20);\r\nval = readl(gp->regs + GREG_SWRST);\r\nif (limit-- <= 0)\r\nbreak;\r\n} while (val & (GREG_SWRST_TXRST | GREG_SWRST_RXRST));\r\nif (limit < 0)\r\nnetdev_err(gp->dev, "SW reset is ghetto\n");\r\nif (gp->phy_type == phy_serialink || gp->phy_type == phy_serdes)\r\ngem_pcs_reinit_adv(gp);\r\n}\r\nstatic void gem_start_dma(struct gem *gp)\r\n{\r\nu32 val;\r\nval = readl(gp->regs + TXDMA_CFG);\r\nwritel(val | TXDMA_CFG_ENABLE, gp->regs + TXDMA_CFG);\r\nval = readl(gp->regs + RXDMA_CFG);\r\nwritel(val | RXDMA_CFG_ENABLE, gp->regs + RXDMA_CFG);\r\nval = readl(gp->regs + MAC_TXCFG);\r\nwritel(val | MAC_TXCFG_ENAB, gp->regs + MAC_TXCFG);\r\nval = readl(gp->regs + MAC_RXCFG);\r\nwritel(val | MAC_RXCFG_ENAB, gp->regs + MAC_RXCFG);\r\n(void) readl(gp->regs + MAC_RXCFG);\r\nudelay(100);\r\ngem_enable_ints(gp);\r\nwritel(RX_RING_SIZE - 4, gp->regs + RXDMA_KICK);\r\n}\r\nstatic void gem_stop_dma(struct gem *gp)\r\n{\r\nu32 val;\r\nval = readl(gp->regs + TXDMA_CFG);\r\nwritel(val & ~TXDMA_CFG_ENABLE, gp->regs + TXDMA_CFG);\r\nval = readl(gp->regs + RXDMA_CFG);\r\nwritel(val & ~RXDMA_CFG_ENABLE, gp->regs + RXDMA_CFG);\r\nval = readl(gp->regs + MAC_TXCFG);\r\nwritel(val & ~MAC_TXCFG_ENAB, gp->regs + MAC_TXCFG);\r\nval = readl(gp->regs + MAC_RXCFG);\r\nwritel(val & ~MAC_RXCFG_ENAB, gp->regs + MAC_RXCFG);\r\n(void) readl(gp->regs + MAC_RXCFG);\r\n}\r\nstatic void gem_begin_auto_negotiation(struct gem *gp, struct ethtool_cmd *ep)\r\n{\r\nu32 advertise, features;\r\nint autoneg;\r\nint speed;\r\nint duplex;\r\nif (gp->phy_type != phy_mii_mdio0 &&\r\ngp->phy_type != phy_mii_mdio1)\r\ngoto non_mii;\r\nif (found_mii_phy(gp))\r\nfeatures = gp->phy_mii.def->features;\r\nelse\r\nfeatures = 0;\r\nadvertise = features & ADVERTISE_MASK;\r\nif (gp->phy_mii.advertising != 0)\r\nadvertise &= gp->phy_mii.advertising;\r\nautoneg = gp->want_autoneg;\r\nspeed = gp->phy_mii.speed;\r\nduplex = gp->phy_mii.duplex;\r\nif (!ep)\r\ngoto start_aneg;\r\nif (ep->autoneg == AUTONEG_ENABLE) {\r\nadvertise = ep->advertising;\r\nautoneg = 1;\r\n} else {\r\nautoneg = 0;\r\nspeed = ethtool_cmd_speed(ep);\r\nduplex = ep->duplex;\r\n}\r\nstart_aneg:\r\nif ((features & SUPPORTED_Autoneg) == 0)\r\nautoneg = 0;\r\nif (speed == SPEED_1000 &&\r\n!(features & (SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full)))\r\nspeed = SPEED_100;\r\nif (speed == SPEED_100 &&\r\n!(features & (SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full)))\r\nspeed = SPEED_10;\r\nif (duplex == DUPLEX_FULL &&\r\n!(features & (SUPPORTED_1000baseT_Full |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_10baseT_Full)))\r\nduplex = DUPLEX_HALF;\r\nif (speed == 0)\r\nspeed = SPEED_10;\r\nif (!netif_device_present(gp->dev)) {\r\ngp->phy_mii.autoneg = gp->want_autoneg = autoneg;\r\ngp->phy_mii.speed = speed;\r\ngp->phy_mii.duplex = duplex;\r\nreturn;\r\n}\r\ngp->want_autoneg = autoneg;\r\nif (autoneg) {\r\nif (found_mii_phy(gp))\r\ngp->phy_mii.def->ops->setup_aneg(&gp->phy_mii, advertise);\r\ngp->lstate = link_aneg;\r\n} else {\r\nif (found_mii_phy(gp))\r\ngp->phy_mii.def->ops->setup_forced(&gp->phy_mii, speed, duplex);\r\ngp->lstate = link_force_ok;\r\n}\r\nnon_mii:\r\ngp->timer_ticks = 0;\r\nmod_timer(&gp->link_timer, jiffies + ((12 * HZ) / 10));\r\n}\r\nstatic int gem_set_link_modes(struct gem *gp)\r\n{\r\nstruct netdev_queue *txq = netdev_get_tx_queue(gp->dev, 0);\r\nint full_duplex, speed, pause;\r\nu32 val;\r\nfull_duplex = 0;\r\nspeed = SPEED_10;\r\npause = 0;\r\nif (found_mii_phy(gp)) {\r\nif (gp->phy_mii.def->ops->read_link(&gp->phy_mii))\r\nreturn 1;\r\nfull_duplex = (gp->phy_mii.duplex == DUPLEX_FULL);\r\nspeed = gp->phy_mii.speed;\r\npause = gp->phy_mii.pause;\r\n} else if (gp->phy_type == phy_serialink ||\r\ngp->phy_type == phy_serdes) {\r\nu32 pcs_lpa = readl(gp->regs + PCS_MIILP);\r\nif ((pcs_lpa & PCS_MIIADV_FD) || gp->phy_type == phy_serdes)\r\nfull_duplex = 1;\r\nspeed = SPEED_1000;\r\n}\r\nnetif_info(gp, link, gp->dev, "Link is up at %d Mbps, %s-duplex\n",\r\nspeed, (full_duplex ? "full" : "half"));\r\n__netif_tx_lock(txq, smp_processor_id());\r\nval = (MAC_TXCFG_EIPG0 | MAC_TXCFG_NGU);\r\nif (full_duplex) {\r\nval |= (MAC_TXCFG_ICS | MAC_TXCFG_ICOLL);\r\n} else {\r\n}\r\nwritel(val, gp->regs + MAC_TXCFG);\r\nval = (MAC_XIFCFG_OE | MAC_XIFCFG_LLED);\r\nif (!full_duplex &&\r\n(gp->phy_type == phy_mii_mdio0 ||\r\ngp->phy_type == phy_mii_mdio1)) {\r\nval |= MAC_XIFCFG_DISE;\r\n} else if (full_duplex) {\r\nval |= MAC_XIFCFG_FLED;\r\n}\r\nif (speed == SPEED_1000)\r\nval |= (MAC_XIFCFG_GMII);\r\nwritel(val, gp->regs + MAC_XIFCFG);\r\nif (speed == SPEED_1000 && !full_duplex) {\r\nval = readl(gp->regs + MAC_TXCFG);\r\nwritel(val | MAC_TXCFG_TCE, gp->regs + MAC_TXCFG);\r\nval = readl(gp->regs + MAC_RXCFG);\r\nwritel(val | MAC_RXCFG_RCE, gp->regs + MAC_RXCFG);\r\n} else {\r\nval = readl(gp->regs + MAC_TXCFG);\r\nwritel(val & ~MAC_TXCFG_TCE, gp->regs + MAC_TXCFG);\r\nval = readl(gp->regs + MAC_RXCFG);\r\nwritel(val & ~MAC_RXCFG_RCE, gp->regs + MAC_RXCFG);\r\n}\r\nif (gp->phy_type == phy_serialink ||\r\ngp->phy_type == phy_serdes) {\r\nu32 pcs_lpa = readl(gp->regs + PCS_MIILP);\r\nif (pcs_lpa & (PCS_MIIADV_SP | PCS_MIIADV_AP))\r\npause = 1;\r\n}\r\nif (!full_duplex)\r\nwritel(512, gp->regs + MAC_STIME);\r\nelse\r\nwritel(64, gp->regs + MAC_STIME);\r\nval = readl(gp->regs + MAC_MCCFG);\r\nif (pause)\r\nval |= (MAC_MCCFG_SPE | MAC_MCCFG_RPE);\r\nelse\r\nval &= ~(MAC_MCCFG_SPE | MAC_MCCFG_RPE);\r\nwritel(val, gp->regs + MAC_MCCFG);\r\ngem_start_dma(gp);\r\n__netif_tx_unlock(txq);\r\nif (netif_msg_link(gp)) {\r\nif (pause) {\r\nnetdev_info(gp->dev,\r\n"Pause is enabled (rxfifo: %d off: %d on: %d)\n",\r\ngp->rx_fifo_sz,\r\ngp->rx_pause_off,\r\ngp->rx_pause_on);\r\n} else {\r\nnetdev_info(gp->dev, "Pause is disabled\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int gem_mdio_link_not_up(struct gem *gp)\r\n{\r\nswitch (gp->lstate) {\r\ncase link_force_ret:\r\nnetif_info(gp, link, gp->dev,\r\n"Autoneg failed again, keeping forced mode\n");\r\ngp->phy_mii.def->ops->setup_forced(&gp->phy_mii,\r\ngp->last_forced_speed, DUPLEX_HALF);\r\ngp->timer_ticks = 5;\r\ngp->lstate = link_force_ok;\r\nreturn 0;\r\ncase link_aneg:\r\nif (gp->phy_mii.def->magic_aneg)\r\nreturn 1;\r\nnetif_info(gp, link, gp->dev, "switching to forced 100bt\n");\r\ngp->phy_mii.def->ops->setup_forced(&gp->phy_mii, SPEED_100,\r\nDUPLEX_HALF);\r\ngp->timer_ticks = 5;\r\ngp->lstate = link_force_try;\r\nreturn 0;\r\ncase link_force_try:\r\nif (gp->phy_mii.speed == SPEED_100) {\r\ngp->phy_mii.def->ops->setup_forced(&gp->phy_mii, SPEED_10,\r\nDUPLEX_HALF);\r\ngp->timer_ticks = 5;\r\nnetif_info(gp, link, gp->dev,\r\n"switching to forced 10bt\n");\r\nreturn 0;\r\n} else\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void gem_link_timer(unsigned long data)\r\n{\r\nstruct gem *gp = (struct gem *) data;\r\nstruct net_device *dev = gp->dev;\r\nint restart_aneg = 0;\r\nif (gp->reset_task_pending)\r\nreturn;\r\nif (gp->phy_type == phy_serialink ||\r\ngp->phy_type == phy_serdes) {\r\nu32 val = readl(gp->regs + PCS_MIISTAT);\r\nif (!(val & PCS_MIISTAT_LS))\r\nval = readl(gp->regs + PCS_MIISTAT);\r\nif ((val & PCS_MIISTAT_LS) != 0) {\r\nif (gp->lstate == link_up)\r\ngoto restart;\r\ngp->lstate = link_up;\r\nnetif_carrier_on(dev);\r\n(void)gem_set_link_modes(gp);\r\n}\r\ngoto restart;\r\n}\r\nif (found_mii_phy(gp) && gp->phy_mii.def->ops->poll_link(&gp->phy_mii)) {\r\nif (gp->lstate == link_force_try && gp->want_autoneg) {\r\ngp->lstate = link_force_ret;\r\ngp->last_forced_speed = gp->phy_mii.speed;\r\ngp->timer_ticks = 5;\r\nif (netif_msg_link(gp))\r\nnetdev_info(dev,\r\n"Got link after fallback, retrying autoneg once...\n");\r\ngp->phy_mii.def->ops->setup_aneg(&gp->phy_mii, gp->phy_mii.advertising);\r\n} else if (gp->lstate != link_up) {\r\ngp->lstate = link_up;\r\nnetif_carrier_on(dev);\r\nif (gem_set_link_modes(gp))\r\nrestart_aneg = 1;\r\n}\r\n} else {\r\nif (gp->lstate == link_up) {\r\ngp->lstate = link_down;\r\nnetif_info(gp, link, dev, "Link down\n");\r\nnetif_carrier_off(dev);\r\ngem_schedule_reset(gp);\r\nreturn;\r\n} else if (++gp->timer_ticks > 10) {\r\nif (found_mii_phy(gp))\r\nrestart_aneg = gem_mdio_link_not_up(gp);\r\nelse\r\nrestart_aneg = 1;\r\n}\r\n}\r\nif (restart_aneg) {\r\ngem_begin_auto_negotiation(gp, NULL);\r\nreturn;\r\n}\r\nrestart:\r\nmod_timer(&gp->link_timer, jiffies + ((12 * HZ) / 10));\r\n}\r\nstatic void gem_clean_rings(struct gem *gp)\r\n{\r\nstruct gem_init_block *gb = gp->init_block;\r\nstruct sk_buff *skb;\r\nint i;\r\ndma_addr_t dma_addr;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct gem_rxd *rxd;\r\nrxd = &gb->rxd[i];\r\nif (gp->rx_skbs[i] != NULL) {\r\nskb = gp->rx_skbs[i];\r\ndma_addr = le64_to_cpu(rxd->buffer);\r\npci_unmap_page(gp->pdev, dma_addr,\r\nRX_BUF_ALLOC_SIZE(gp),\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb_any(skb);\r\ngp->rx_skbs[i] = NULL;\r\n}\r\nrxd->status_word = 0;\r\nwmb();\r\nrxd->buffer = 0;\r\n}\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nif (gp->tx_skbs[i] != NULL) {\r\nstruct gem_txd *txd;\r\nint frag;\r\nskb = gp->tx_skbs[i];\r\ngp->tx_skbs[i] = NULL;\r\nfor (frag = 0; frag <= skb_shinfo(skb)->nr_frags; frag++) {\r\nint ent = i & (TX_RING_SIZE - 1);\r\ntxd = &gb->txd[ent];\r\ndma_addr = le64_to_cpu(txd->buffer);\r\npci_unmap_page(gp->pdev, dma_addr,\r\nle64_to_cpu(txd->control_word) &\r\nTXDCTRL_BUFSZ, PCI_DMA_TODEVICE);\r\nif (frag != skb_shinfo(skb)->nr_frags)\r\ni++;\r\n}\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\n}\r\nstatic void gem_init_rings(struct gem *gp)\r\n{\r\nstruct gem_init_block *gb = gp->init_block;\r\nstruct net_device *dev = gp->dev;\r\nint i;\r\ndma_addr_t dma_addr;\r\ngp->rx_new = gp->rx_old = gp->tx_new = gp->tx_old = 0;\r\ngem_clean_rings(gp);\r\ngp->rx_buf_sz = max(dev->mtu + ETH_HLEN + VLAN_HLEN,\r\n(unsigned)VLAN_ETH_FRAME_LEN);\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct sk_buff *skb;\r\nstruct gem_rxd *rxd = &gb->rxd[i];\r\nskb = gem_alloc_skb(dev, RX_BUF_ALLOC_SIZE(gp), GFP_KERNEL);\r\nif (!skb) {\r\nrxd->buffer = 0;\r\nrxd->status_word = 0;\r\ncontinue;\r\n}\r\ngp->rx_skbs[i] = skb;\r\nskb_put(skb, (gp->rx_buf_sz + RX_OFFSET));\r\ndma_addr = pci_map_page(gp->pdev,\r\nvirt_to_page(skb->data),\r\noffset_in_page(skb->data),\r\nRX_BUF_ALLOC_SIZE(gp),\r\nPCI_DMA_FROMDEVICE);\r\nrxd->buffer = cpu_to_le64(dma_addr);\r\nwmb();\r\nrxd->status_word = cpu_to_le64(RXDCTRL_FRESH(gp));\r\nskb_reserve(skb, RX_OFFSET);\r\n}\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nstruct gem_txd *txd = &gb->txd[i];\r\ntxd->control_word = 0;\r\nwmb();\r\ntxd->buffer = 0;\r\n}\r\nwmb();\r\n}\r\nstatic void gem_init_phy(struct gem *gp)\r\n{\r\nu32 mifcfg;\r\nmifcfg = readl(gp->regs + MIF_CFG);\r\nmifcfg &= ~MIF_CFG_BBMODE;\r\nwritel(mifcfg, gp->regs + MIF_CFG);\r\nif (gp->pdev->vendor == PCI_VENDOR_ID_APPLE) {\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\n#ifdef CONFIG_PPC_PMAC\r\npmac_call_feature(PMAC_FTR_GMAC_PHY_RESET, gp->of_node, 0, 0);\r\nmsleep(20);\r\n#endif\r\nphy_write(gp, MII_BMCR, BMCR_RESET);\r\nmsleep(20);\r\nif (phy_read(gp, MII_BMCR) != 0xffff)\r\nbreak;\r\nif (i == 2)\r\nnetdev_warn(gp->dev, "GMAC PHY not responding !\n");\r\n}\r\n}\r\nif (gp->pdev->vendor == PCI_VENDOR_ID_SUN &&\r\ngp->pdev->device == PCI_DEVICE_ID_SUN_GEM) {\r\nu32 val;\r\nif (gp->phy_type == phy_mii_mdio0 ||\r\ngp->phy_type == phy_mii_mdio1) {\r\nval = PCS_DMODE_MGM;\r\n} else if (gp->phy_type == phy_serialink) {\r\nval = PCS_DMODE_SM | PCS_DMODE_GMOE;\r\n} else {\r\nval = PCS_DMODE_ESM;\r\n}\r\nwritel(val, gp->regs + PCS_DMODE);\r\n}\r\nif (gp->phy_type == phy_mii_mdio0 ||\r\ngp->phy_type == phy_mii_mdio1) {\r\nsungem_phy_probe(&gp->phy_mii, gp->mii_phy_addr);\r\nif (gp->phy_mii.def && gp->phy_mii.def->ops->init)\r\ngp->phy_mii.def->ops->init(&gp->phy_mii);\r\n} else {\r\ngem_pcs_reset(gp);\r\ngem_pcs_reinit_adv(gp);\r\n}\r\ngp->timer_ticks = 0;\r\ngp->lstate = link_down;\r\nnetif_carrier_off(gp->dev);\r\nif (gp->phy_type == phy_mii_mdio0 ||\r\ngp->phy_type == phy_mii_mdio1)\r\nnetdev_info(gp->dev, "Found %s PHY\n",\r\ngp->phy_mii.def ? gp->phy_mii.def->name : "no");\r\ngem_begin_auto_negotiation(gp, NULL);\r\n}\r\nstatic void gem_init_dma(struct gem *gp)\r\n{\r\nu64 desc_dma = (u64) gp->gblock_dvma;\r\nu32 val;\r\nval = (TXDMA_CFG_BASE | (0x7ff << 10) | TXDMA_CFG_PMODE);\r\nwritel(val, gp->regs + TXDMA_CFG);\r\nwritel(desc_dma >> 32, gp->regs + TXDMA_DBHI);\r\nwritel(desc_dma & 0xffffffff, gp->regs + TXDMA_DBLOW);\r\ndesc_dma += (INIT_BLOCK_TX_RING_SIZE * sizeof(struct gem_txd));\r\nwritel(0, gp->regs + TXDMA_KICK);\r\nval = (RXDMA_CFG_BASE | (RX_OFFSET << 10) |\r\n((14 / 2) << 13) | RXDMA_CFG_FTHRESH_128);\r\nwritel(val, gp->regs + RXDMA_CFG);\r\nwritel(desc_dma >> 32, gp->regs + RXDMA_DBHI);\r\nwritel(desc_dma & 0xffffffff, gp->regs + RXDMA_DBLOW);\r\nwritel(RX_RING_SIZE - 4, gp->regs + RXDMA_KICK);\r\nval = (((gp->rx_pause_off / 64) << 0) & RXDMA_PTHRESH_OFF);\r\nval |= (((gp->rx_pause_on / 64) << 12) & RXDMA_PTHRESH_ON);\r\nwritel(val, gp->regs + RXDMA_PTHRESH);\r\nif (readl(gp->regs + GREG_BIFCFG) & GREG_BIFCFG_M66EN)\r\nwritel(((5 & RXDMA_BLANK_IPKTS) |\r\n((8 << 12) & RXDMA_BLANK_ITIME)),\r\ngp->regs + RXDMA_BLANK);\r\nelse\r\nwritel(((5 & RXDMA_BLANK_IPKTS) |\r\n((4 << 12) & RXDMA_BLANK_ITIME)),\r\ngp->regs + RXDMA_BLANK);\r\n}\r\nstatic u32 gem_setup_multicast(struct gem *gp)\r\n{\r\nu32 rxcfg = 0;\r\nint i;\r\nif ((gp->dev->flags & IFF_ALLMULTI) ||\r\n(netdev_mc_count(gp->dev) > 256)) {\r\nfor (i=0; i<16; i++)\r\nwritel(0xffff, gp->regs + MAC_HASH0 + (i << 2));\r\nrxcfg |= MAC_RXCFG_HFE;\r\n} else if (gp->dev->flags & IFF_PROMISC) {\r\nrxcfg |= MAC_RXCFG_PROM;\r\n} else {\r\nu16 hash_table[16];\r\nu32 crc;\r\nstruct netdev_hw_addr *ha;\r\nint i;\r\nmemset(hash_table, 0, sizeof(hash_table));\r\nnetdev_for_each_mc_addr(ha, gp->dev) {\r\ncrc = ether_crc_le(6, ha->addr);\r\ncrc >>= 24;\r\nhash_table[crc >> 4] |= 1 << (15 - (crc & 0xf));\r\n}\r\nfor (i=0; i<16; i++)\r\nwritel(hash_table[i], gp->regs + MAC_HASH0 + (i << 2));\r\nrxcfg |= MAC_RXCFG_HFE;\r\n}\r\nreturn rxcfg;\r\n}\r\nstatic void gem_init_mac(struct gem *gp)\r\n{\r\nunsigned char *e = &gp->dev->dev_addr[0];\r\nwritel(0x1bf0, gp->regs + MAC_SNDPAUSE);\r\nwritel(0x00, gp->regs + MAC_IPG0);\r\nwritel(0x08, gp->regs + MAC_IPG1);\r\nwritel(0x04, gp->regs + MAC_IPG2);\r\nwritel(0x40, gp->regs + MAC_STIME);\r\nwritel(0x40, gp->regs + MAC_MINFSZ);\r\nwritel(0x20000000 | (gp->rx_buf_sz + 4), gp->regs + MAC_MAXFSZ);\r\nwritel(0x07, gp->regs + MAC_PASIZE);\r\nwritel(0x04, gp->regs + MAC_JAMSIZE);\r\nwritel(0x10, gp->regs + MAC_ATTLIM);\r\nwritel(0x8808, gp->regs + MAC_MCTYPE);\r\nwritel((e[5] | (e[4] << 8)) & 0x3ff, gp->regs + MAC_RANDSEED);\r\nwritel((e[4] << 8) | e[5], gp->regs + MAC_ADDR0);\r\nwritel((e[2] << 8) | e[3], gp->regs + MAC_ADDR1);\r\nwritel((e[0] << 8) | e[1], gp->regs + MAC_ADDR2);\r\nwritel(0, gp->regs + MAC_ADDR3);\r\nwritel(0, gp->regs + MAC_ADDR4);\r\nwritel(0, gp->regs + MAC_ADDR5);\r\nwritel(0x0001, gp->regs + MAC_ADDR6);\r\nwritel(0xc200, gp->regs + MAC_ADDR7);\r\nwritel(0x0180, gp->regs + MAC_ADDR8);\r\nwritel(0, gp->regs + MAC_AFILT0);\r\nwritel(0, gp->regs + MAC_AFILT1);\r\nwritel(0, gp->regs + MAC_AFILT2);\r\nwritel(0, gp->regs + MAC_AF21MSK);\r\nwritel(0, gp->regs + MAC_AF0MSK);\r\ngp->mac_rx_cfg = gem_setup_multicast(gp);\r\n#ifdef STRIP_FCS\r\ngp->mac_rx_cfg |= MAC_RXCFG_SFCS;\r\n#endif\r\nwritel(0, gp->regs + MAC_NCOLL);\r\nwritel(0, gp->regs + MAC_FASUCC);\r\nwritel(0, gp->regs + MAC_ECOLL);\r\nwritel(0, gp->regs + MAC_LCOLL);\r\nwritel(0, gp->regs + MAC_DTIMER);\r\nwritel(0, gp->regs + MAC_PATMPS);\r\nwritel(0, gp->regs + MAC_RFCTR);\r\nwritel(0, gp->regs + MAC_LERR);\r\nwritel(0, gp->regs + MAC_AERR);\r\nwritel(0, gp->regs + MAC_FCSERR);\r\nwritel(0, gp->regs + MAC_RXCVERR);\r\nwritel(0, gp->regs + MAC_TXCFG);\r\nwritel(gp->mac_rx_cfg, gp->regs + MAC_RXCFG);\r\nwritel(0, gp->regs + MAC_MCCFG);\r\nwritel(0, gp->regs + MAC_XIFCFG);\r\nwritel(MAC_TXSTAT_XMIT, gp->regs + MAC_TXMASK);\r\nwritel(MAC_RXSTAT_RCV, gp->regs + MAC_RXMASK);\r\nwritel(0xffffffff, gp->regs + MAC_MCMASK);\r\nif (gp->has_wol)\r\nwritel(0, gp->regs + WOL_WAKECSR);\r\n}\r\nstatic void gem_init_pause_thresholds(struct gem *gp)\r\n{\r\nu32 cfg;\r\nif (gp->rx_fifo_sz <= (2 * 1024)) {\r\ngp->rx_pause_off = gp->rx_pause_on = gp->rx_fifo_sz;\r\n} else {\r\nint max_frame = (gp->rx_buf_sz + 4 + 64) & ~63;\r\nint off = (gp->rx_fifo_sz - (max_frame * 2));\r\nint on = off - max_frame;\r\ngp->rx_pause_off = off;\r\ngp->rx_pause_on = on;\r\n}\r\ncfg = 0;\r\nif (gp->pdev->vendor == PCI_VENDOR_ID_APPLE)\r\ncfg |= GREG_CFG_RONPAULBIT | GREG_CFG_ENBUG2FIX;\r\n#if !defined(CONFIG_SPARC64) && !defined(CONFIG_ALPHA)\r\ncfg |= GREG_CFG_IBURST;\r\n#endif\r\ncfg |= ((31 << 1) & GREG_CFG_TXDMALIM);\r\ncfg |= ((31 << 6) & GREG_CFG_RXDMALIM);\r\nwritel(cfg, gp->regs + GREG_CFG);\r\nif (!(readl(gp->regs + GREG_CFG) & GREG_CFG_IBURST)) {\r\ncfg = ((2 << 1) & GREG_CFG_TXDMALIM);\r\ncfg |= ((8 << 6) & GREG_CFG_RXDMALIM);\r\nwritel(cfg, gp->regs + GREG_CFG);\r\n}\r\n}\r\nstatic int gem_check_invariants(struct gem *gp)\r\n{\r\nstruct pci_dev *pdev = gp->pdev;\r\nu32 mif_cfg;\r\nif (pdev->vendor == PCI_VENDOR_ID_APPLE) {\r\ngp->phy_type = phy_mii_mdio0;\r\ngp->tx_fifo_sz = readl(gp->regs + TXDMA_FSZ) * 64;\r\ngp->rx_fifo_sz = readl(gp->regs + RXDMA_FSZ) * 64;\r\ngp->swrst_base = 0;\r\nmif_cfg = readl(gp->regs + MIF_CFG);\r\nmif_cfg &= ~(MIF_CFG_PSELECT|MIF_CFG_POLL|MIF_CFG_BBMODE|MIF_CFG_MDI1);\r\nmif_cfg |= MIF_CFG_MDI0;\r\nwritel(mif_cfg, gp->regs + MIF_CFG);\r\nwritel(PCS_DMODE_MGM, gp->regs + PCS_DMODE);\r\nwritel(MAC_XIFCFG_OE, gp->regs + MAC_XIFCFG);\r\nif (gp->pdev->device == PCI_DEVICE_ID_APPLE_K2_GMAC)\r\ngp->mii_phy_addr = 1;\r\nelse\r\ngp->mii_phy_addr = 0;\r\nreturn 0;\r\n}\r\nmif_cfg = readl(gp->regs + MIF_CFG);\r\nif (pdev->vendor == PCI_VENDOR_ID_SUN &&\r\npdev->device == PCI_DEVICE_ID_SUN_RIO_GEM) {\r\nif ((mif_cfg & (MIF_CFG_MDI0 | MIF_CFG_MDI1)) == 0) {\r\npr_err("RIO GEM lacks MII phy, mif_cfg[%08x]\n",\r\nmif_cfg);\r\nreturn -1;\r\n}\r\n}\r\nif (mif_cfg & MIF_CFG_MDI1) {\r\ngp->phy_type = phy_mii_mdio1;\r\nmif_cfg |= MIF_CFG_PSELECT;\r\nwritel(mif_cfg, gp->regs + MIF_CFG);\r\n} else if (mif_cfg & MIF_CFG_MDI0) {\r\ngp->phy_type = phy_mii_mdio0;\r\nmif_cfg &= ~MIF_CFG_PSELECT;\r\nwritel(mif_cfg, gp->regs + MIF_CFG);\r\n} else {\r\n#ifdef CONFIG_SPARC\r\nconst char *p;\r\np = of_get_property(gp->of_node, "shared-pins", NULL);\r\nif (p && !strcmp(p, "serdes"))\r\ngp->phy_type = phy_serdes;\r\nelse\r\n#endif\r\ngp->phy_type = phy_serialink;\r\n}\r\nif (gp->phy_type == phy_mii_mdio1 ||\r\ngp->phy_type == phy_mii_mdio0) {\r\nint i;\r\nfor (i = 0; i < 32; i++) {\r\ngp->mii_phy_addr = i;\r\nif (phy_read(gp, MII_BMCR) != 0xffff)\r\nbreak;\r\n}\r\nif (i == 32) {\r\nif (pdev->device != PCI_DEVICE_ID_SUN_GEM) {\r\npr_err("RIO MII phy will not respond\n");\r\nreturn -1;\r\n}\r\ngp->phy_type = phy_serdes;\r\n}\r\n}\r\ngp->tx_fifo_sz = readl(gp->regs + TXDMA_FSZ) * 64;\r\ngp->rx_fifo_sz = readl(gp->regs + RXDMA_FSZ) * 64;\r\nif (pdev->vendor == PCI_VENDOR_ID_SUN) {\r\nif (pdev->device == PCI_DEVICE_ID_SUN_GEM) {\r\nif (gp->tx_fifo_sz != (9 * 1024) ||\r\ngp->rx_fifo_sz != (20 * 1024)) {\r\npr_err("GEM has bogus fifo sizes tx(%d) rx(%d)\n",\r\ngp->tx_fifo_sz, gp->rx_fifo_sz);\r\nreturn -1;\r\n}\r\ngp->swrst_base = 0;\r\n} else {\r\nif (gp->tx_fifo_sz != (2 * 1024) ||\r\ngp->rx_fifo_sz != (2 * 1024)) {\r\npr_err("RIO GEM has bogus fifo sizes tx(%d) rx(%d)\n",\r\ngp->tx_fifo_sz, gp->rx_fifo_sz);\r\nreturn -1;\r\n}\r\ngp->swrst_base = (64 / 4) << GREG_SWRST_CACHE_SHIFT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void gem_reinit_chip(struct gem *gp)\r\n{\r\ngem_reset(gp);\r\ngem_disable_ints(gp);\r\ngem_init_rings(gp);\r\ngem_init_pause_thresholds(gp);\r\ngem_init_dma(gp);\r\ngem_init_mac(gp);\r\n}\r\nstatic void gem_stop_phy(struct gem *gp, int wol)\r\n{\r\nu32 mifcfg;\r\nmsleep(10);\r\nmifcfg = readl(gp->regs + MIF_CFG);\r\nmifcfg &= ~MIF_CFG_POLL;\r\nwritel(mifcfg, gp->regs + MIF_CFG);\r\nif (wol && gp->has_wol) {\r\nunsigned char *e = &gp->dev->dev_addr[0];\r\nu32 csr;\r\nwritel(MAC_RXCFG_HFE | MAC_RXCFG_SFCS | MAC_RXCFG_ENAB,\r\ngp->regs + MAC_RXCFG);\r\nwritel((e[4] << 8) | e[5], gp->regs + WOL_MATCH0);\r\nwritel((e[2] << 8) | e[3], gp->regs + WOL_MATCH1);\r\nwritel((e[0] << 8) | e[1], gp->regs + WOL_MATCH2);\r\nwritel(WOL_MCOUNT_N | WOL_MCOUNT_M, gp->regs + WOL_MCOUNT);\r\ncsr = WOL_WAKECSR_ENABLE;\r\nif ((readl(gp->regs + MAC_XIFCFG) & MAC_XIFCFG_GMII) == 0)\r\ncsr |= WOL_WAKECSR_MII;\r\nwritel(csr, gp->regs + WOL_WAKECSR);\r\n} else {\r\nwritel(0, gp->regs + MAC_RXCFG);\r\n(void)readl(gp->regs + MAC_RXCFG);\r\nmsleep(10);\r\n}\r\nwritel(0, gp->regs + MAC_TXCFG);\r\nwritel(0, gp->regs + MAC_XIFCFG);\r\nwritel(0, gp->regs + TXDMA_CFG);\r\nwritel(0, gp->regs + RXDMA_CFG);\r\nif (!wol) {\r\ngem_reset(gp);\r\nwritel(MAC_TXRST_CMD, gp->regs + MAC_TXRST);\r\nwritel(MAC_RXRST_CMD, gp->regs + MAC_RXRST);\r\nif (found_mii_phy(gp) && gp->phy_mii.def->ops->suspend)\r\ngp->phy_mii.def->ops->suspend(&gp->phy_mii);\r\nwritel(mifcfg | MIF_CFG_BBMODE, gp->regs + MIF_CFG);\r\nwritel(0, gp->regs + MIF_BBCLK);\r\nwritel(0, gp->regs + MIF_BBDATA);\r\nwritel(0, gp->regs + MIF_BBOENAB);\r\nwritel(MAC_XIFCFG_GMII | MAC_XIFCFG_LBCK, gp->regs + MAC_XIFCFG);\r\n(void) readl(gp->regs + MAC_XIFCFG);\r\n}\r\n}\r\nstatic int gem_do_start(struct net_device *dev)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nint rc;\r\ngem_get_cell(gp);\r\nrc = pci_enable_device(gp->pdev);\r\nif (rc) {\r\nnetdev_err(dev, "Failed to enable chip on PCI bus !\n");\r\ngem_put_cell(gp);\r\nreturn -ENXIO;\r\n}\r\npci_set_master(gp->pdev);\r\ngem_reinit_chip(gp);\r\nrc = request_irq(gp->pdev->irq, gem_interrupt,\r\nIRQF_SHARED, dev->name, (void *)dev);\r\nif (rc) {\r\nnetdev_err(dev, "failed to request irq !\n");\r\ngem_reset(gp);\r\ngem_clean_rings(gp);\r\ngem_put_cell(gp);\r\nreturn rc;\r\n}\r\nnetif_device_attach(dev);\r\ngem_netif_start(gp);\r\ngem_init_phy(gp);\r\nreturn 0;\r\n}\r\nstatic void gem_do_stop(struct net_device *dev, int wol)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\ngem_netif_stop(gp);\r\ngem_disable_ints(gp);\r\ndel_timer_sync(&gp->link_timer);\r\ngp->reset_task_pending = 0;\r\ngem_stop_dma(gp);\r\nmsleep(10);\r\nif (!wol)\r\ngem_reset(gp);\r\nmsleep(10);\r\ngem_clean_rings(gp);\r\nfree_irq(gp->pdev->irq, (void *) dev);\r\ngem_stop_phy(gp, wol);\r\npci_disable_device(gp->pdev);\r\nif (!wol)\r\ngem_put_cell(gp);\r\n}\r\nstatic void gem_reset_task(struct work_struct *work)\r\n{\r\nstruct gem *gp = container_of(work, struct gem, reset_task);\r\nrtnl_lock();\r\nif (!netif_device_present(gp->dev) ||\r\n!netif_running(gp->dev) ||\r\n!gp->reset_task_pending) {\r\nrtnl_unlock();\r\nreturn;\r\n}\r\ndel_timer_sync(&gp->link_timer);\r\ngem_netif_stop(gp);\r\ngem_reinit_chip(gp);\r\nif (gp->lstate == link_up)\r\ngem_set_link_modes(gp);\r\ngem_netif_start(gp);\r\ngp->reset_task_pending = 0;\r\nif (gp->lstate != link_up)\r\ngem_begin_auto_negotiation(gp, NULL);\r\nelse\r\nmod_timer(&gp->link_timer, jiffies + ((12 * HZ) / 10));\r\nrtnl_unlock();\r\n}\r\nstatic int gem_open(struct net_device *dev)\r\n{\r\nif (netif_device_present(dev))\r\nreturn gem_do_start(dev);\r\nreturn 0;\r\n}\r\nstatic int gem_close(struct net_device *dev)\r\n{\r\nif (netif_device_present(dev))\r\ngem_do_stop(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int gem_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct gem *gp = netdev_priv(dev);\r\nrtnl_lock();\r\nif (!netif_running(dev)) {\r\nnetif_device_detach(dev);\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nnetdev_info(dev, "suspending, WakeOnLan %s\n",\r\n(gp->wake_on_lan && netif_running(dev)) ?\r\n"enabled" : "disabled");\r\nnetif_device_detach(dev);\r\ngp->asleep_wol = !!gp->wake_on_lan;\r\ngem_do_stop(dev, gp->asleep_wol);\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nstatic int gem_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct gem *gp = netdev_priv(dev);\r\nrtnl_lock();\r\nif (!netif_running(dev)) {\r\nnetif_device_attach(dev);\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\ngem_do_start(dev);\r\nif (gp->asleep_wol)\r\ngem_put_cell(gp);\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *gem_get_stats(struct net_device *dev)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nif (!netif_device_present(dev) || !netif_running(dev))\r\ngoto bail;\r\nif (WARN_ON(!gp->cell_enabled))\r\ngoto bail;\r\ndev->stats.rx_crc_errors += readl(gp->regs + MAC_FCSERR);\r\nwritel(0, gp->regs + MAC_FCSERR);\r\ndev->stats.rx_frame_errors += readl(gp->regs + MAC_AERR);\r\nwritel(0, gp->regs + MAC_AERR);\r\ndev->stats.rx_length_errors += readl(gp->regs + MAC_LERR);\r\nwritel(0, gp->regs + MAC_LERR);\r\ndev->stats.tx_aborted_errors += readl(gp->regs + MAC_ECOLL);\r\ndev->stats.collisions +=\r\n(readl(gp->regs + MAC_ECOLL) + readl(gp->regs + MAC_LCOLL));\r\nwritel(0, gp->regs + MAC_ECOLL);\r\nwritel(0, gp->regs + MAC_LCOLL);\r\nbail:\r\nreturn &dev->stats;\r\n}\r\nstatic int gem_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *macaddr = (struct sockaddr *) addr;\r\nstruct gem *gp = netdev_priv(dev);\r\nunsigned char *e = &dev->dev_addr[0];\r\nif (!is_valid_ether_addr(macaddr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, macaddr->sa_data, dev->addr_len);\r\nif (!netif_running(dev) || !netif_device_present(dev))\r\nreturn 0;\r\nif (WARN_ON(!gp->cell_enabled))\r\nreturn 0;\r\nwritel((e[4] << 8) | e[5], gp->regs + MAC_ADDR0);\r\nwritel((e[2] << 8) | e[3], gp->regs + MAC_ADDR1);\r\nwritel((e[0] << 8) | e[1], gp->regs + MAC_ADDR2);\r\nreturn 0;\r\n}\r\nstatic void gem_set_multicast(struct net_device *dev)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nu32 rxcfg, rxcfg_new;\r\nint limit = 10000;\r\nif (!netif_running(dev) || !netif_device_present(dev))\r\nreturn;\r\nif (gp->reset_task_pending || WARN_ON(!gp->cell_enabled))\r\nreturn;\r\nrxcfg = readl(gp->regs + MAC_RXCFG);\r\nrxcfg_new = gem_setup_multicast(gp);\r\n#ifdef STRIP_FCS\r\nrxcfg_new |= MAC_RXCFG_SFCS;\r\n#endif\r\ngp->mac_rx_cfg = rxcfg_new;\r\nwritel(rxcfg & ~MAC_RXCFG_ENAB, gp->regs + MAC_RXCFG);\r\nwhile (readl(gp->regs + MAC_RXCFG) & MAC_RXCFG_ENAB) {\r\nif (!limit--)\r\nbreak;\r\nudelay(10);\r\n}\r\nrxcfg &= ~(MAC_RXCFG_PROM | MAC_RXCFG_HFE);\r\nrxcfg |= rxcfg_new;\r\nwritel(rxcfg, gp->regs + MAC_RXCFG);\r\n}\r\nstatic int gem_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nif (new_mtu < GEM_MIN_MTU || new_mtu > GEM_MAX_MTU)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nif (!netif_running(dev) || !netif_device_present(dev))\r\nreturn 0;\r\nif (WARN_ON(!gp->cell_enabled))\r\nreturn 0;\r\ngem_netif_stop(gp);\r\ngem_reinit_chip(gp);\r\nif (gp->lstate == link_up)\r\ngem_set_link_modes(gp);\r\ngem_netif_start(gp);\r\nreturn 0;\r\n}\r\nstatic void gem_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(gp->pdev), sizeof(info->bus_info));\r\n}\r\nstatic int gem_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nif (gp->phy_type == phy_mii_mdio0 ||\r\ngp->phy_type == phy_mii_mdio1) {\r\nif (gp->phy_mii.def)\r\ncmd->supported = gp->phy_mii.def->features;\r\nelse\r\ncmd->supported = (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full);\r\ncmd->port = PORT_MII;\r\ncmd->transceiver = XCVR_EXTERNAL;\r\ncmd->phy_address = 0;\r\ncmd->autoneg = gp->want_autoneg;\r\nethtool_cmd_speed_set(cmd, gp->phy_mii.speed);\r\ncmd->duplex = gp->phy_mii.duplex;\r\ncmd->advertising = gp->phy_mii.advertising;\r\nif (cmd->advertising == 0)\r\ncmd->advertising = cmd->supported;\r\n} else {\r\ncmd->supported =\r\n(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |\r\nSUPPORTED_Autoneg);\r\ncmd->advertising = cmd->supported;\r\nethtool_cmd_speed_set(cmd, 0);\r\ncmd->duplex = cmd->port = cmd->phy_address =\r\ncmd->transceiver = cmd->autoneg = 0;\r\nif (gp->phy_type == phy_serdes) {\r\ncmd->port = PORT_FIBRE;\r\ncmd->supported = (SUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full |\r\nSUPPORTED_FIBRE | SUPPORTED_Autoneg |\r\nSUPPORTED_Pause | SUPPORTED_Asym_Pause);\r\ncmd->advertising = cmd->supported;\r\ncmd->transceiver = XCVR_INTERNAL;\r\nif (gp->lstate == link_up)\r\nethtool_cmd_speed_set(cmd, SPEED_1000);\r\ncmd->duplex = DUPLEX_FULL;\r\ncmd->autoneg = 1;\r\n}\r\n}\r\ncmd->maxtxpkt = cmd->maxrxpkt = 0;\r\nreturn 0;\r\n}\r\nstatic int gem_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nu32 speed = ethtool_cmd_speed(cmd);\r\nif (cmd->autoneg != AUTONEG_ENABLE &&\r\ncmd->autoneg != AUTONEG_DISABLE)\r\nreturn -EINVAL;\r\nif (cmd->autoneg == AUTONEG_ENABLE &&\r\ncmd->advertising == 0)\r\nreturn -EINVAL;\r\nif (cmd->autoneg == AUTONEG_DISABLE &&\r\n((speed != SPEED_1000 &&\r\nspeed != SPEED_100 &&\r\nspeed != SPEED_10) ||\r\n(cmd->duplex != DUPLEX_HALF &&\r\ncmd->duplex != DUPLEX_FULL)))\r\nreturn -EINVAL;\r\nif (netif_device_present(gp->dev)) {\r\ndel_timer_sync(&gp->link_timer);\r\ngem_begin_auto_negotiation(gp, cmd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gem_nway_reset(struct net_device *dev)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nif (!gp->want_autoneg)\r\nreturn -EINVAL;\r\nif (netif_device_present(gp->dev)) {\r\ndel_timer_sync(&gp->link_timer);\r\ngem_begin_auto_negotiation(gp, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 gem_get_msglevel(struct net_device *dev)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nreturn gp->msg_enable;\r\n}\r\nstatic void gem_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\ngp->msg_enable = value;\r\n}\r\nstatic void gem_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nif (gp->has_wol) {\r\nwol->supported = WOL_SUPPORTED_MASK;\r\nwol->wolopts = gp->wake_on_lan;\r\n} else {\r\nwol->supported = 0;\r\nwol->wolopts = 0;\r\n}\r\n}\r\nstatic int gem_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nif (!gp->has_wol)\r\nreturn -EOPNOTSUPP;\r\ngp->wake_on_lan = wol->wolopts & WOL_SUPPORTED_MASK;\r\nreturn 0;\r\n}\r\nstatic int gem_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct gem *gp = netdev_priv(dev);\r\nstruct mii_ioctl_data *data = if_mii(ifr);\r\nint rc = -EOPNOTSUPP;\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = gp->mii_phy_addr;\r\ncase SIOCGMIIREG:\r\ndata->val_out = __phy_read(gp, data->phy_id & 0x1f,\r\ndata->reg_num & 0x1f);\r\nrc = 0;\r\nbreak;\r\ncase SIOCSMIIREG:\r\n__phy_write(gp, data->phy_id & 0x1f, data->reg_num & 0x1f,\r\ndata->val_in);\r\nrc = 0;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int find_eth_addr_in_vpd(void __iomem *rom_base, int len, unsigned char *dev_addr)\r\n{\r\nint this_offset;\r\nfor (this_offset = 0x20; this_offset < len; this_offset++) {\r\nvoid __iomem *p = rom_base + this_offset;\r\nint i;\r\nif (readb(p + 0) != 0x90 ||\r\nreadb(p + 1) != 0x00 ||\r\nreadb(p + 2) != 0x09 ||\r\nreadb(p + 3) != 0x4e ||\r\nreadb(p + 4) != 0x41 ||\r\nreadb(p + 5) != 0x06)\r\ncontinue;\r\nthis_offset += 6;\r\np += 6;\r\nfor (i = 0; i < 6; i++)\r\ndev_addr[i] = readb(p + i);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void get_gem_mac_nonobp(struct pci_dev *pdev, unsigned char *dev_addr)\r\n{\r\nsize_t size;\r\nvoid __iomem *p = pci_map_rom(pdev, &size);\r\nif (p) {\r\nint found;\r\nfound = readb(p) == 0x55 &&\r\nreadb(p + 1) == 0xaa &&\r\nfind_eth_addr_in_vpd(p, (64 * 1024), dev_addr);\r\npci_unmap_rom(pdev, p);\r\nif (found)\r\nreturn;\r\n}\r\ndev_addr[0] = 0x08;\r\ndev_addr[1] = 0x00;\r\ndev_addr[2] = 0x20;\r\nget_random_bytes(dev_addr + 3, 3);\r\n}\r\nstatic int gem_get_device_address(struct gem *gp)\r\n{\r\n#if defined(CONFIG_SPARC) || defined(CONFIG_PPC_PMAC)\r\nstruct net_device *dev = gp->dev;\r\nconst unsigned char *addr;\r\naddr = of_get_property(gp->of_node, "local-mac-address", NULL);\r\nif (addr == NULL) {\r\n#ifdef CONFIG_SPARC\r\naddr = idprom->id_ethaddr;\r\n#else\r\nprintk("\n");\r\npr_err("%s: can't get mac-address\n", dev->name);\r\nreturn -1;\r\n#endif\r\n}\r\nmemcpy(dev->dev_addr, addr, ETH_ALEN);\r\n#else\r\nget_gem_mac_nonobp(gp->pdev, gp->dev->dev_addr);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void gem_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nif (dev) {\r\nstruct gem *gp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\ncancel_work_sync(&gp->reset_task);\r\npci_free_consistent(pdev,\r\nsizeof(struct gem_init_block),\r\ngp->init_block,\r\ngp->gblock_dvma);\r\niounmap(gp->regs);\r\npci_release_regions(pdev);\r\nfree_netdev(dev);\r\n}\r\n}\r\nstatic int gem_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nunsigned long gemreg_base, gemreg_len;\r\nstruct net_device *dev;\r\nstruct gem *gp;\r\nint err, pci_using_dac;\r\nprintk_once(KERN_INFO "%s", version);\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\npr_err("Cannot enable MMIO operation, aborting\n");\r\nreturn err;\r\n}\r\npci_set_master(pdev);\r\nif (pdev->vendor == PCI_VENDOR_ID_SUN &&\r\npdev->device == PCI_DEVICE_ID_SUN_GEM &&\r\n!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {\r\npci_using_dac = 1;\r\n} else {\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\npr_err("No usable DMA configuration, aborting\n");\r\ngoto err_disable_device;\r\n}\r\npci_using_dac = 0;\r\n}\r\ngemreg_base = pci_resource_start(pdev, 0);\r\ngemreg_len = pci_resource_len(pdev, 0);\r\nif ((pci_resource_flags(pdev, 0) & IORESOURCE_IO) != 0) {\r\npr_err("Cannot find proper PCI device base address, aborting\n");\r\nerr = -ENODEV;\r\ngoto err_disable_device;\r\n}\r\ndev = alloc_etherdev(sizeof(*gp));\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto err_disable_device;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\ngp = netdev_priv(dev);\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err) {\r\npr_err("Cannot obtain PCI resources, aborting\n");\r\ngoto err_out_free_netdev;\r\n}\r\ngp->pdev = pdev;\r\ngp->dev = dev;\r\ngp->msg_enable = DEFAULT_MSG;\r\ninit_timer(&gp->link_timer);\r\ngp->link_timer.function = gem_link_timer;\r\ngp->link_timer.data = (unsigned long) gp;\r\nINIT_WORK(&gp->reset_task, gem_reset_task);\r\ngp->lstate = link_down;\r\ngp->timer_ticks = 0;\r\nnetif_carrier_off(dev);\r\ngp->regs = ioremap(gemreg_base, gemreg_len);\r\nif (!gp->regs) {\r\npr_err("Cannot map device registers, aborting\n");\r\nerr = -EIO;\r\ngoto err_out_free_res;\r\n}\r\n#if defined(CONFIG_PPC_PMAC) || defined(CONFIG_SPARC)\r\ngp->of_node = pci_device_to_OF_node(pdev);\r\n#endif\r\nif (pdev->vendor == PCI_VENDOR_ID_APPLE)\r\ngp->has_wol = 1;\r\ngem_get_cell(gp);\r\ngem_reset(gp);\r\ngp->phy_mii.dev = dev;\r\ngp->phy_mii.mdio_read = _phy_read;\r\ngp->phy_mii.mdio_write = _phy_write;\r\n#ifdef CONFIG_PPC_PMAC\r\ngp->phy_mii.platform_data = gp->of_node;\r\n#endif\r\ngp->want_autoneg = 1;\r\nif (gem_check_invariants(gp)) {\r\nerr = -ENODEV;\r\ngoto err_out_iounmap;\r\n}\r\ngp->init_block = (struct gem_init_block *)\r\npci_alloc_consistent(pdev, sizeof(struct gem_init_block),\r\n&gp->gblock_dvma);\r\nif (!gp->init_block) {\r\npr_err("Cannot allocate init block, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_out_iounmap;\r\n}\r\nerr = gem_get_device_address(gp);\r\nif (err)\r\ngoto err_out_free_consistent;\r\ndev->netdev_ops = &gem_netdev_ops;\r\nnetif_napi_add(dev, &gp->napi, gem_poll, 64);\r\ndev->ethtool_ops = &gem_ethtool_ops;\r\ndev->watchdog_timeo = 5 * HZ;\r\ndev->dma = 0;\r\npci_set_drvdata(pdev, dev);\r\ndev->hw_features = NETIF_F_SG | NETIF_F_HW_CSUM;\r\ndev->features |= dev->hw_features | NETIF_F_RXCSUM;\r\nif (pci_using_dac)\r\ndev->features |= NETIF_F_HIGHDMA;\r\nif (register_netdev(dev)) {\r\npr_err("Cannot register net device, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_out_free_consistent;\r\n}\r\nrtnl_lock();\r\ngem_put_cell(gp);\r\nrtnl_unlock();\r\nnetdev_info(dev, "Sun GEM (PCI) 10/100/1000BaseT Ethernet %pM\n",\r\ndev->dev_addr);\r\nreturn 0;\r\nerr_out_free_consistent:\r\ngem_remove_one(pdev);\r\nerr_out_iounmap:\r\ngem_put_cell(gp);\r\niounmap(gp->regs);\r\nerr_out_free_res:\r\npci_release_regions(pdev);\r\nerr_out_free_netdev:\r\nfree_netdev(dev);\r\nerr_disable_device:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}
