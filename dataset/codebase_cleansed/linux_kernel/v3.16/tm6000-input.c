void tm6000_ir_wait(struct tm6000_core *dev, u8 state)\r\n{\r\nstruct tm6000_IR *ir = dev->ir;\r\nif (!dev->ir)\r\nreturn;\r\ndprintk(2, "%s: %i\n",__func__, ir->wait);\r\nif (state)\r\nir->wait = 1;\r\nelse\r\nir->wait = 0;\r\n}\r\nstatic int tm6000_ir_config(struct tm6000_IR *ir)\r\n{\r\nstruct tm6000_core *dev = ir->dev;\r\nu32 pulse = 0, leader = 0;\r\ndprintk(2, "%s\n",__func__);\r\nswitch (ir->rc_type) {\r\ncase RC_BIT_NEC:\r\nleader = 900;\r\npulse = 700;\r\nbreak;\r\ndefault:\r\ncase RC_BIT_RC5:\r\nleader = 900;\r\npulse = 1780;\r\nbreak;\r\n}\r\npulse = ir_clock_mhz * pulse;\r\nleader = ir_clock_mhz * leader;\r\nif (ir->rc_type == RC_BIT_NEC)\r\nleader = leader | 0x8000;\r\ndprintk(2, "%s: %s, %d MHz, leader = 0x%04x, pulse = 0x%06x \n",\r\n__func__,\r\n(ir->rc_type == RC_BIT_NEC) ? "NEC" : "RC-5",\r\nir_clock_mhz, leader, pulse);\r\ntm6000_set_reg(dev, TM6010_REQ07_RE5_REMOTE_WAKEUP, 0xfe);\r\ntm6000_set_reg(dev, TM6010_REQ07_RD8_IR, 0x2f);\r\ntm6000_set_reg(dev, TM6010_REQ07_RDA_IR_WAKEUP_SEL, 0xff);\r\ntm6000_set_reg(dev, TM6010_REQ07_RDB_IR_WAKEUP_ADD, 0xff);\r\ntm6000_set_reg(dev, TM6010_REQ07_RDC_IR_LEADER1, leader >> 8);\r\ntm6000_set_reg(dev, TM6010_REQ07_RDD_IR_LEADER0, leader);\r\ntm6000_set_reg(dev, TM6010_REQ07_RDE_IR_PULSE_CNT1, pulse >> 8);\r\ntm6000_set_reg(dev, TM6010_REQ07_RDF_IR_PULSE_CNT0, pulse);\r\nif (!ir->polling)\r\ntm6000_set_reg(dev, REQ_04_EN_DISABLE_MCU_INT, 2, 0);\r\nelse\r\ntm6000_set_reg(dev, REQ_04_EN_DISABLE_MCU_INT, 2, 1);\r\nmsleep(10);\r\ntm6000_flash_led(dev, 0);\r\nmsleep(100);\r\ntm6000_flash_led(dev, 1);\r\nir->pwled = 1;\r\nreturn 0;\r\n}\r\nstatic void tm6000_ir_urb_received(struct urb *urb)\r\n{\r\nstruct tm6000_core *dev = urb->context;\r\nstruct tm6000_IR *ir = dev->ir;\r\nstruct tm6000_ir_poll_result poll_result;\r\nchar *buf;\r\ndprintk(2, "%s\n",__func__);\r\nif (urb->status < 0 || urb->actual_length <= 0) {\r\nprintk(KERN_INFO "tm6000: IR URB failure: status: %i, length %i\n",\r\nurb->status, urb->actual_length);\r\nir->submit_urb = 1;\r\nschedule_delayed_work(&ir->work, msecs_to_jiffies(URB_SUBMIT_DELAY));\r\nreturn;\r\n}\r\nbuf = urb->transfer_buffer;\r\nif (ir_debug)\r\nprint_hex_dump(KERN_DEBUG, "tm6000: IR data: ",\r\nDUMP_PREFIX_OFFSET,16, 1,\r\nbuf, urb->actual_length, false);\r\npoll_result.rc_data = buf[0];\r\nif (urb->actual_length > 1)\r\npoll_result.rc_data |= buf[1] << 8;\r\ndprintk(1, "%s, scancode: 0x%04x\n",__func__, poll_result.rc_data);\r\nrc_keydown(ir->rc, poll_result.rc_data, 0);\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\nir->pwled = 2;\r\nschedule_delayed_work(&ir->work, msecs_to_jiffies(10));\r\n}\r\nstatic void tm6000_ir_handle_key(struct work_struct *work)\r\n{\r\nstruct tm6000_IR *ir = container_of(work, struct tm6000_IR, work.work);\r\nstruct tm6000_core *dev = ir->dev;\r\nstruct tm6000_ir_poll_result poll_result;\r\nint rc;\r\nu8 buf[2];\r\nif (ir->wait)\r\nreturn;\r\ndprintk(3, "%s\n",__func__);\r\nrc = tm6000_read_write_usb(dev, USB_DIR_IN |\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nREQ_02_GET_IR_CODE, 0, 0, buf, 2);\r\nif (rc < 0)\r\nreturn;\r\nif (rc > 1)\r\npoll_result.rc_data = buf[0] | buf[1] << 8;\r\nelse\r\npoll_result.rc_data = buf[0];\r\nif ((poll_result.rc_data & 0xff) == 0xff) {\r\nif (!ir->pwled) {\r\ntm6000_flash_led(dev, 1);\r\nir->pwled = 1;\r\n}\r\nreturn;\r\n}\r\ndprintk(1, "%s, scancode: 0x%04x\n",__func__, poll_result.rc_data);\r\nrc_keydown(ir->rc, poll_result.rc_data, 0);\r\ntm6000_flash_led(dev, 0);\r\nir->pwled = 0;\r\nschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));\r\n}\r\nstatic void tm6000_ir_int_work(struct work_struct *work)\r\n{\r\nstruct tm6000_IR *ir = container_of(work, struct tm6000_IR, work.work);\r\nstruct tm6000_core *dev = ir->dev;\r\nint rc;\r\ndprintk(3, "%s, submit_urb = %d, pwled = %d\n",__func__, ir->submit_urb,\r\nir->pwled);\r\nif (ir->submit_urb) {\r\ndprintk(3, "Resubmit urb\n");\r\ntm6000_set_reg(dev, REQ_04_EN_DISABLE_MCU_INT, 2, 0);\r\nrc = usb_submit_urb(ir->int_urb, GFP_ATOMIC);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "tm6000: Can't submit an IR interrupt. Error %i\n",\r\nrc);\r\nschedule_delayed_work(&ir->work, msecs_to_jiffies(URB_SUBMIT_DELAY));\r\nreturn;\r\n}\r\nir->submit_urb = 0;\r\n}\r\nif (ir->pwled == 2) {\r\ntm6000_flash_led(dev, 0);\r\nir->pwled = 0;\r\nschedule_delayed_work(&ir->work, msecs_to_jiffies(URB_INT_LED_DELAY));\r\n} else if (!ir->pwled) {\r\ntm6000_flash_led(dev, 1);\r\nir->pwled = 1;\r\n}\r\n}\r\nstatic int tm6000_ir_start(struct rc_dev *rc)\r\n{\r\nstruct tm6000_IR *ir = rc->priv;\r\ndprintk(2, "%s\n",__func__);\r\nschedule_delayed_work(&ir->work, 0);\r\nreturn 0;\r\n}\r\nstatic void tm6000_ir_stop(struct rc_dev *rc)\r\n{\r\nstruct tm6000_IR *ir = rc->priv;\r\ndprintk(2, "%s\n",__func__);\r\ncancel_delayed_work_sync(&ir->work);\r\n}\r\nstatic int tm6000_ir_change_protocol(struct rc_dev *rc, u64 *rc_type)\r\n{\r\nstruct tm6000_IR *ir = rc->priv;\r\nif (!ir)\r\nreturn 0;\r\ndprintk(2, "%s\n",__func__);\r\nif ((rc->rc_map.scan) && (*rc_type == RC_BIT_NEC))\r\nir->key_addr = ((rc->rc_map.scan[0].scancode >> 8) & 0xffff);\r\nir->rc_type = *rc_type;\r\ntm6000_ir_config(ir);\r\nreturn 0;\r\n}\r\nstatic int __tm6000_ir_int_start(struct rc_dev *rc)\r\n{\r\nstruct tm6000_IR *ir = rc->priv;\r\nstruct tm6000_core *dev;\r\nint pipe, size;\r\nint err = -ENOMEM;\r\nif (!ir)\r\nreturn -ENODEV;\r\ndev = ir->dev;\r\ndprintk(2, "%s\n",__func__);\r\nir->int_urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!ir->int_urb)\r\nreturn -ENOMEM;\r\npipe = usb_rcvintpipe(dev->udev,\r\ndev->int_in.endp->desc.bEndpointAddress\r\n& USB_ENDPOINT_NUMBER_MASK);\r\nsize = usb_maxpacket(dev->udev, pipe, usb_pipeout(pipe));\r\ndprintk(1, "IR max size: %d\n", size);\r\nir->int_urb->transfer_buffer = kzalloc(size, GFP_ATOMIC);\r\nif (ir->int_urb->transfer_buffer == NULL) {\r\nusb_free_urb(ir->int_urb);\r\nreturn err;\r\n}\r\ndprintk(1, "int interval: %d\n", dev->int_in.endp->desc.bInterval);\r\nusb_fill_int_urb(ir->int_urb, dev->udev, pipe,\r\nir->int_urb->transfer_buffer, size,\r\ntm6000_ir_urb_received, dev,\r\ndev->int_in.endp->desc.bInterval);\r\nir->submit_urb = 1;\r\nschedule_delayed_work(&ir->work, msecs_to_jiffies(URB_SUBMIT_DELAY));\r\nreturn 0;\r\n}\r\nstatic void __tm6000_ir_int_stop(struct rc_dev *rc)\r\n{\r\nstruct tm6000_IR *ir = rc->priv;\r\nif (!ir || !ir->int_urb)\r\nreturn;\r\ndprintk(2, "%s\n",__func__);\r\nusb_kill_urb(ir->int_urb);\r\nkfree(ir->int_urb->transfer_buffer);\r\nusb_free_urb(ir->int_urb);\r\nir->int_urb = NULL;\r\n}\r\nint tm6000_ir_int_start(struct tm6000_core *dev)\r\n{\r\nstruct tm6000_IR *ir = dev->ir;\r\nif (!ir)\r\nreturn 0;\r\nreturn __tm6000_ir_int_start(ir->rc);\r\n}\r\nvoid tm6000_ir_int_stop(struct tm6000_core *dev)\r\n{\r\nstruct tm6000_IR *ir = dev->ir;\r\nif (!ir || !ir->rc)\r\nreturn;\r\n__tm6000_ir_int_stop(ir->rc);\r\n}\r\nint tm6000_ir_init(struct tm6000_core *dev)\r\n{\r\nstruct tm6000_IR *ir;\r\nstruct rc_dev *rc;\r\nint err = -ENOMEM;\r\nu64 rc_type;\r\nif (!enable_ir)\r\nreturn -ENODEV;\r\nif (!dev->caps.has_remote)\r\nreturn 0;\r\nif (!dev->ir_codes)\r\nreturn 0;\r\nir = kzalloc(sizeof(*ir), GFP_ATOMIC);\r\nrc = rc_allocate_device();\r\nif (!ir || !rc)\r\ngoto out;\r\ndprintk(2, "%s\n", __func__);\r\nir->dev = dev;\r\ndev->ir = ir;\r\nir->rc = rc;\r\nrc_set_allowed_protocols(rc, RC_BIT_RC5 | RC_BIT_NEC);\r\nrc->scanmask = 0xffff;\r\nrc->priv = ir;\r\nrc->change_protocol = tm6000_ir_change_protocol;\r\nif (dev->int_in.endp) {\r\nrc->open = __tm6000_ir_int_start;\r\nrc->close = __tm6000_ir_int_stop;\r\nINIT_DELAYED_WORK(&ir->work, tm6000_ir_int_work);\r\n} else {\r\nrc->open = tm6000_ir_start;\r\nrc->close = tm6000_ir_stop;\r\nir->polling = 50;\r\nINIT_DELAYED_WORK(&ir->work, tm6000_ir_handle_key);\r\n}\r\nrc->driver_type = RC_DRIVER_SCANCODE;\r\nsnprintf(ir->name, sizeof(ir->name), "tm5600/60x0 IR (%s)",\r\ndev->name);\r\nusb_make_path(dev->udev, ir->phys, sizeof(ir->phys));\r\nstrlcat(ir->phys, "/input0", sizeof(ir->phys));\r\nrc_type = RC_BIT_UNKNOWN;\r\ntm6000_ir_change_protocol(rc, &rc_type);\r\nrc->input_name = ir->name;\r\nrc->input_phys = ir->phys;\r\nrc->input_id.bustype = BUS_USB;\r\nrc->input_id.version = 1;\r\nrc->input_id.vendor = le16_to_cpu(dev->udev->descriptor.idVendor);\r\nrc->input_id.product = le16_to_cpu(dev->udev->descriptor.idProduct);\r\nrc->map_name = dev->ir_codes;\r\nrc->driver_name = "tm6000";\r\nrc->dev.parent = &dev->udev->dev;\r\nerr = rc_register_device(rc);\r\nif (err)\r\ngoto out;\r\nreturn 0;\r\nout:\r\ndev->ir = NULL;\r\nrc_free_device(rc);\r\nkfree(ir);\r\nreturn err;\r\n}\r\nint tm6000_ir_fini(struct tm6000_core *dev)\r\n{\r\nstruct tm6000_IR *ir = dev->ir;\r\nif (!ir)\r\nreturn 0;\r\ndprintk(2, "%s\n",__func__);\r\nif (!ir->polling)\r\n__tm6000_ir_int_stop(ir->rc);\r\ntm6000_ir_stop(ir->rc);\r\ntm6000_flash_led(dev, 0);\r\nir->pwled = 0;\r\nrc_unregister_device(ir->rc);\r\nkfree(ir);\r\ndev->ir = NULL;\r\nreturn 0;\r\n}
