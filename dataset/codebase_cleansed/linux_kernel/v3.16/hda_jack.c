bool is_jack_detectable(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nif (codec->no_jack_detect)\r\nreturn false;\r\nif (!(snd_hda_query_pin_caps(codec, nid) & AC_PINCAP_PRES_DETECT))\r\nreturn false;\r\nif (get_defcfg_misc(snd_hda_codec_get_pincfg(codec, nid)) &\r\nAC_DEFCFG_MISC_NO_PRESENCE)\r\nreturn false;\r\nif (!(get_wcaps(codec, nid) & AC_WCAP_UNSOL_CAP) &&\r\n!codec->jackpoll_interval)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic u32 read_pin_sense(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nu32 pincap;\r\nu32 val;\r\nif (!codec->no_trigger_sense) {\r\npincap = snd_hda_query_pin_caps(codec, nid);\r\nif (pincap & AC_PINCAP_TRIG_REQ)\r\nsnd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_SET_PIN_SENSE, 0);\r\n}\r\nval = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_PIN_SENSE, 0);\r\nif (codec->inv_jack_detect)\r\nval ^= AC_PINSENSE_PRESENCE;\r\nreturn val;\r\n}\r\nstruct hda_jack_tbl *\r\nsnd_hda_jack_tbl_get(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_jack_tbl *jack = codec->jacktbl.list;\r\nint i;\r\nif (!nid || !jack)\r\nreturn NULL;\r\nfor (i = 0; i < codec->jacktbl.used; i++, jack++)\r\nif (jack->nid == nid)\r\nreturn jack;\r\nreturn NULL;\r\n}\r\nstruct hda_jack_tbl *\r\nsnd_hda_jack_tbl_get_from_tag(struct hda_codec *codec, unsigned char tag)\r\n{\r\nstruct hda_jack_tbl *jack = codec->jacktbl.list;\r\nint i;\r\nif (!tag || !jack)\r\nreturn NULL;\r\nfor (i = 0; i < codec->jacktbl.used; i++, jack++)\r\nif (jack->tag == tag)\r\nreturn jack;\r\nreturn NULL;\r\n}\r\nstruct hda_jack_tbl *\r\nsnd_hda_jack_tbl_new(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_jack_tbl *jack = snd_hda_jack_tbl_get(codec, nid);\r\nif (jack)\r\nreturn jack;\r\njack = snd_array_new(&codec->jacktbl);\r\nif (!jack)\r\nreturn NULL;\r\njack->nid = nid;\r\njack->jack_dirty = 1;\r\njack->tag = codec->jacktbl.used;\r\nreturn jack;\r\n}\r\nvoid snd_hda_jack_tbl_clear(struct hda_codec *codec)\r\n{\r\n#ifdef CONFIG_SND_HDA_INPUT_JACK\r\nif (!codec->bus->shutdown && codec->jacktbl.list) {\r\nstruct hda_jack_tbl *jack = codec->jacktbl.list;\r\nint i;\r\nfor (i = 0; i < codec->jacktbl.used; i++, jack++) {\r\nif (jack->jack)\r\nsnd_device_free(codec->bus->card, jack->jack);\r\n}\r\n}\r\n#endif\r\nsnd_array_free(&codec->jacktbl);\r\n}\r\nstatic void jack_detect_update(struct hda_codec *codec,\r\nstruct hda_jack_tbl *jack)\r\n{\r\nif (!jack->jack_dirty)\r\nreturn;\r\nif (jack->phantom_jack)\r\njack->pin_sense = AC_PINSENSE_PRESENCE;\r\nelse\r\njack->pin_sense = read_pin_sense(codec, jack->nid);\r\nif (jack->gating_jack && !snd_hda_jack_detect(codec, jack->gating_jack))\r\njack->pin_sense &= ~AC_PINSENSE_PRESENCE;\r\njack->jack_dirty = 0;\r\nif (jack->gated_jack) {\r\nstruct hda_jack_tbl *gated =\r\nsnd_hda_jack_tbl_get(codec, jack->gated_jack);\r\nif (gated) {\r\ngated->jack_dirty = 1;\r\njack_detect_update(codec, gated);\r\n}\r\n}\r\n}\r\nvoid snd_hda_jack_set_dirty_all(struct hda_codec *codec)\r\n{\r\nstruct hda_jack_tbl *jack = codec->jacktbl.list;\r\nint i;\r\nfor (i = 0; i < codec->jacktbl.used; i++, jack++)\r\nif (jack->nid)\r\njack->jack_dirty = 1;\r\n}\r\nu32 snd_hda_pin_sense(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_jack_tbl *jack = snd_hda_jack_tbl_get(codec, nid);\r\nif (jack) {\r\njack_detect_update(codec, jack);\r\nreturn jack->pin_sense;\r\n}\r\nreturn read_pin_sense(codec, nid);\r\n}\r\nint snd_hda_jack_detect_state(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_jack_tbl *jack = snd_hda_jack_tbl_get(codec, nid);\r\nif (jack && jack->phantom_jack)\r\nreturn HDA_JACK_PHANTOM;\r\nelse if (snd_hda_pin_sense(codec, nid) & AC_PINSENSE_PRESENCE)\r\nreturn HDA_JACK_PRESENT;\r\nelse\r\nreturn HDA_JACK_NOT_PRESENT;\r\n}\r\nint snd_hda_jack_detect_enable_callback(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned char action,\r\nhda_jack_callback cb)\r\n{\r\nstruct hda_jack_tbl *jack = snd_hda_jack_tbl_new(codec, nid);\r\nif (!jack)\r\nreturn -ENOMEM;\r\nif (jack->jack_detect)\r\nreturn 0;\r\njack->jack_detect = 1;\r\nif (action)\r\njack->action = action;\r\nif (cb)\r\njack->callback = cb;\r\nif (codec->jackpoll_interval > 0)\r\nreturn 0;\r\nreturn snd_hda_codec_write_cache(codec, nid, 0,\r\nAC_VERB_SET_UNSOLICITED_ENABLE,\r\nAC_USRSP_EN | jack->tag);\r\n}\r\nint snd_hda_jack_detect_enable(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned char action)\r\n{\r\nreturn snd_hda_jack_detect_enable_callback(codec, nid, action, NULL);\r\n}\r\nint snd_hda_jack_set_gating_jack(struct hda_codec *codec, hda_nid_t gated_nid,\r\nhda_nid_t gating_nid)\r\n{\r\nstruct hda_jack_tbl *gated = snd_hda_jack_tbl_new(codec, gated_nid);\r\nstruct hda_jack_tbl *gating = snd_hda_jack_tbl_new(codec, gating_nid);\r\nif (!gated || !gating)\r\nreturn -EINVAL;\r\ngated->gating_jack = gating_nid;\r\ngating->gated_jack = gated_nid;\r\nreturn 0;\r\n}\r\nvoid snd_hda_jack_report_sync(struct hda_codec *codec)\r\n{\r\nstruct hda_jack_tbl *jack;\r\nint i, state;\r\njack = codec->jacktbl.list;\r\nfor (i = 0; i < codec->jacktbl.used; i++, jack++)\r\nif (jack->nid)\r\njack_detect_update(codec, jack);\r\njack = codec->jacktbl.list;\r\nfor (i = 0; i < codec->jacktbl.used; i++, jack++)\r\nif (jack->nid) {\r\nif (!jack->kctl || jack->block_report)\r\ncontinue;\r\nstate = get_jack_plug_state(jack->pin_sense);\r\nsnd_kctl_jack_report(codec->bus->card, jack->kctl, state);\r\n#ifdef CONFIG_SND_HDA_INPUT_JACK\r\nif (jack->jack)\r\nsnd_jack_report(jack->jack,\r\nstate ? jack->type : 0);\r\n#endif\r\n}\r\n}\r\nstatic int get_input_jack_type(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int def_conf = snd_hda_codec_get_pincfg(codec, nid);\r\nswitch (get_defcfg_device(def_conf)) {\r\ncase AC_JACK_LINE_OUT:\r\ncase AC_JACK_SPEAKER:\r\nreturn SND_JACK_LINEOUT;\r\ncase AC_JACK_HP_OUT:\r\nreturn SND_JACK_HEADPHONE;\r\ncase AC_JACK_SPDIF_OUT:\r\ncase AC_JACK_DIG_OTHER_OUT:\r\nreturn SND_JACK_AVOUT;\r\ncase AC_JACK_MIC_IN:\r\nreturn SND_JACK_MICROPHONE;\r\ndefault:\r\nreturn SND_JACK_LINEIN;\r\n}\r\n}\r\nstatic void hda_free_jack_priv(struct snd_jack *jack)\r\n{\r\nstruct hda_jack_tbl *jacks = jack->private_data;\r\njacks->nid = 0;\r\njacks->jack = NULL;\r\n}\r\nstatic int __snd_hda_jack_add_kctl(struct hda_codec *codec, hda_nid_t nid,\r\nconst char *name, int idx, bool phantom_jack)\r\n{\r\nstruct hda_jack_tbl *jack;\r\nstruct snd_kcontrol *kctl;\r\nint err, state;\r\njack = snd_hda_jack_tbl_new(codec, nid);\r\nif (!jack)\r\nreturn 0;\r\nif (jack->kctl)\r\nreturn 0;\r\nkctl = snd_kctl_jack_new(name, idx, codec);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nerr = snd_hda_ctl_add(codec, nid, kctl);\r\nif (err < 0)\r\nreturn err;\r\njack->kctl = kctl;\r\njack->phantom_jack = !!phantom_jack;\r\nstate = snd_hda_jack_detect(codec, nid);\r\nsnd_kctl_jack_report(codec->bus->card, kctl, state);\r\n#ifdef CONFIG_SND_HDA_INPUT_JACK\r\nif (!phantom_jack) {\r\njack->type = get_input_jack_type(codec, nid);\r\nerr = snd_jack_new(codec->bus->card, name, jack->type,\r\n&jack->jack);\r\nif (err < 0)\r\nreturn err;\r\njack->jack->private_data = jack;\r\njack->jack->private_free = hda_free_jack_priv;\r\nsnd_jack_report(jack->jack, state ? jack->type : 0);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nint snd_hda_jack_add_kctl(struct hda_codec *codec, hda_nid_t nid,\r\nconst char *name, int idx)\r\n{\r\nreturn __snd_hda_jack_add_kctl(codec, nid, name, idx, false);\r\n}\r\nstatic int get_unique_index(struct hda_codec *codec, const char *name, int idx)\r\n{\r\nstruct hda_jack_tbl *jack;\r\nint i, len = strlen(name);\r\nagain:\r\njack = codec->jacktbl.list;\r\nfor (i = 0; i < codec->jacktbl.used; i++, jack++) {\r\nif (jack->kctl &&\r\n!strncmp(name, jack->kctl->id.name, len) &&\r\n!strcmp(" Jack", jack->kctl->id.name + len) &&\r\njack->kctl->id.index == idx) {\r\nidx++;\r\ngoto again;\r\n}\r\n}\r\nreturn idx;\r\n}\r\nstatic int add_jack_kctl(struct hda_codec *codec, hda_nid_t nid,\r\nconst struct auto_pin_cfg *cfg,\r\nconst char *base_name)\r\n{\r\nunsigned int def_conf, conn;\r\nchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nint idx, err;\r\nbool phantom_jack;\r\nif (!nid)\r\nreturn 0;\r\ndef_conf = snd_hda_codec_get_pincfg(codec, nid);\r\nconn = get_defcfg_connect(def_conf);\r\nif (conn == AC_JACK_PORT_NONE)\r\nreturn 0;\r\nphantom_jack = (conn != AC_JACK_PORT_COMPLEX) ||\r\n!is_jack_detectable(codec, nid);\r\nif (base_name) {\r\nstrlcpy(name, base_name, sizeof(name));\r\nidx = 0;\r\n} else\r\nsnd_hda_get_pin_label(codec, nid, cfg, name, sizeof(name), &idx);\r\nif (phantom_jack)\r\nstrncat(name, " Phantom", sizeof(name) - strlen(name) - 1);\r\nidx = get_unique_index(codec, name, idx);\r\nerr = __snd_hda_jack_add_kctl(codec, nid, name, idx, phantom_jack);\r\nif (err < 0)\r\nreturn err;\r\nif (!phantom_jack)\r\nreturn snd_hda_jack_detect_enable(codec, nid, 0);\r\nreturn 0;\r\n}\r\nint snd_hda_jack_add_kctls(struct hda_codec *codec,\r\nconst struct auto_pin_cfg *cfg)\r\n{\r\nconst hda_nid_t *p;\r\nint i, err;\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\nif (cfg->inputs[i].is_headphone_mic) {\r\nif (auto_cfg_hp_outs(cfg) == 1)\r\nerr = add_jack_kctl(codec, auto_cfg_hp_pins(cfg)[0],\r\ncfg, "Headphone Mic");\r\nelse\r\nerr = add_jack_kctl(codec, cfg->inputs[i].pin,\r\ncfg, "Headphone Mic");\r\n} else\r\nerr = add_jack_kctl(codec, cfg->inputs[i].pin, cfg,\r\nNULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0, p = cfg->line_out_pins; i < cfg->line_outs; i++, p++) {\r\nerr = add_jack_kctl(codec, *p, cfg, NULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0, p = cfg->hp_pins; i < cfg->hp_outs; i++, p++) {\r\nif (*p == *cfg->line_out_pins)\r\nbreak;\r\nerr = add_jack_kctl(codec, *p, cfg, NULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0, p = cfg->speaker_pins; i < cfg->speaker_outs; i++, p++) {\r\nif (*p == *cfg->line_out_pins)\r\nbreak;\r\nerr = add_jack_kctl(codec, *p, cfg, NULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0, p = cfg->dig_out_pins; i < cfg->dig_outs; i++, p++) {\r\nerr = add_jack_kctl(codec, *p, cfg, NULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = add_jack_kctl(codec, cfg->dig_in_pin, cfg, NULL);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_jack_kctl(codec, cfg->mono_out_pin, cfg, NULL);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void call_jack_callback(struct hda_codec *codec,\r\nstruct hda_jack_tbl *jack)\r\n{\r\nif (jack->callback)\r\njack->callback(codec, jack);\r\nif (jack->gated_jack) {\r\nstruct hda_jack_tbl *gated =\r\nsnd_hda_jack_tbl_get(codec, jack->gated_jack);\r\nif (gated && gated->callback)\r\ngated->callback(codec, gated);\r\n}\r\n}\r\nvoid snd_hda_jack_unsol_event(struct hda_codec *codec, unsigned int res)\r\n{\r\nstruct hda_jack_tbl *event;\r\nint tag = (res >> AC_UNSOL_RES_TAG_SHIFT) & 0x7f;\r\nevent = snd_hda_jack_tbl_get_from_tag(codec, tag);\r\nif (!event)\r\nreturn;\r\nevent->jack_dirty = 1;\r\ncall_jack_callback(codec, event);\r\nsnd_hda_jack_report_sync(codec);\r\n}\r\nvoid snd_hda_jack_poll_all(struct hda_codec *codec)\r\n{\r\nstruct hda_jack_tbl *jack = codec->jacktbl.list;\r\nint i, changes = 0;\r\nfor (i = 0; i < codec->jacktbl.used; i++, jack++) {\r\nunsigned int old_sense;\r\nif (!jack->nid || !jack->jack_dirty || jack->phantom_jack)\r\ncontinue;\r\nold_sense = get_jack_plug_state(jack->pin_sense);\r\njack_detect_update(codec, jack);\r\nif (old_sense == get_jack_plug_state(jack->pin_sense))\r\ncontinue;\r\nchanges = 1;\r\ncall_jack_callback(codec, jack);\r\n}\r\nif (changes)\r\nsnd_hda_jack_report_sync(codec);\r\n}
