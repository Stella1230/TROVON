static void illegal_state_warn(unsigned state, unsigned char firstbyte)\r\n{\r\nprintk(KERN_WARNING "isdn_x25iface: firstbyte %x illegal in"\r\n"current state %d\n", firstbyte, state);\r\n}\r\nstatic int pdata_is_bad(ix25_pdata_t *pda) {\r\nif (pda && pda->magic == ISDN_X25IFACE_MAGIC) return 0;\r\nprintk(KERN_WARNING\r\n"isdn_x25iface_xxx: illegal pointer to proto data\n");\r\nreturn 1;\r\n}\r\nstruct concap_proto *isdn_x25iface_proto_new(void)\r\n{\r\nix25_pdata_t *tmp = kmalloc(sizeof(ix25_pdata_t), GFP_KERNEL);\r\nIX25DEBUG("isdn_x25iface_proto_new\n");\r\nif (tmp) {\r\ntmp->magic = ISDN_X25IFACE_MAGIC;\r\ntmp->state = WAN_UNCONFIGURED;\r\nspin_lock_init(&tmp->priv.lock);\r\ntmp->priv.dops = NULL;\r\ntmp->priv.net_dev = NULL;\r\ntmp->priv.pops = &ix25_pops;\r\ntmp->priv.flags = 0;\r\ntmp->priv.proto_data = tmp;\r\nreturn (&(tmp->priv));\r\n}\r\nreturn NULL;\r\n}\r\nstatic int isdn_x25iface_proto_close(struct concap_proto *cprot) {\r\nix25_pdata_t *tmp;\r\nint ret = 0;\r\nulong flags;\r\nif (!cprot) {\r\nprintk(KERN_ERR "isdn_x25iface_proto_close: "\r\n"invalid concap_proto pointer\n");\r\nreturn -1;\r\n}\r\nIX25DEBUG("isdn_x25iface_proto_close %s \n", MY_DEVNAME(cprot->net_dev));\r\nspin_lock_irqsave(&cprot->lock, flags);\r\ncprot->dops = NULL;\r\ncprot->net_dev = NULL;\r\ntmp = cprot->proto_data;\r\nif (pdata_is_bad(tmp)) {\r\nret = -1;\r\n} else {\r\ntmp->state = WAN_UNCONFIGURED;\r\n}\r\nspin_unlock_irqrestore(&cprot->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void isdn_x25iface_proto_del(struct concap_proto *cprot) {\r\nix25_pdata_t *tmp;\r\nIX25DEBUG("isdn_x25iface_proto_del \n");\r\nif (!cprot) {\r\nprintk(KERN_ERR "isdn_x25iface_proto_del: "\r\n"concap_proto pointer is NULL\n");\r\nreturn;\r\n}\r\ntmp = cprot->proto_data;\r\nif (tmp == NULL) {\r\nprintk(KERN_ERR "isdn_x25iface_proto_del: inconsistent "\r\n"proto_data pointer (maybe already deleted?)\n");\r\nreturn;\r\n}\r\nif (cprot->dops) isdn_x25iface_proto_close(cprot);\r\ntmp->magic = 0;\r\ncprot->proto_data = NULL;\r\nkfree(tmp);\r\nreturn;\r\n}\r\nstatic int isdn_x25iface_proto_restart(struct concap_proto *cprot,\r\nstruct net_device *ndev,\r\nstruct concap_device_ops *dops)\r\n{\r\nix25_pdata_t *pda = cprot->proto_data;\r\nulong flags;\r\nIX25DEBUG("isdn_x25iface_proto_restart %s \n", MY_DEVNAME(ndev));\r\nif (pdata_is_bad(pda)) return -1;\r\nif (!(dops && dops->data_req && dops->connect_req\r\n&& dops->disconn_req)) {\r\nprintk(KERN_WARNING "isdn_x25iface_restart: required dops"\r\n" missing\n");\r\nisdn_x25iface_proto_close(cprot);\r\nreturn -1;\r\n}\r\nspin_lock_irqsave(&cprot->lock, flags);\r\ncprot->net_dev = ndev;\r\ncprot->pops = &ix25_pops;\r\ncprot->dops = dops;\r\npda->state = WAN_DISCONNECTED;\r\nspin_unlock_irqrestore(&cprot->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int isdn_x25iface_receive(struct concap_proto *cprot, struct sk_buff *skb)\r\n{\r\nIX25DEBUG("isdn_x25iface_receive %s \n", MY_DEVNAME(cprot->net_dev));\r\nif (((ix25_pdata_t *)(cprot->proto_data))\r\n->state == WAN_CONNECTED) {\r\nif (skb_push(skb, 1)) {\r\nskb->data[0] = X25_IFACE_DATA;\r\nskb->protocol = x25_type_trans(skb, cprot->net_dev);\r\nnetif_rx(skb);\r\nreturn 0;\r\n}\r\n}\r\nprintk(KERN_WARNING "isdn_x25iface_receive %s: not connected, skb dropped\n", MY_DEVNAME(cprot->net_dev));\r\ndev_kfree_skb(skb);\r\nreturn -1;\r\n}\r\nstatic int isdn_x25iface_connect_ind(struct concap_proto *cprot)\r\n{\r\nstruct sk_buff *skb;\r\nenum wan_states *state_p\r\n= &(((ix25_pdata_t *)(cprot->proto_data))->state);\r\nIX25DEBUG("isdn_x25iface_connect_ind %s \n"\r\n, MY_DEVNAME(cprot->net_dev));\r\nif (*state_p == WAN_UNCONFIGURED) {\r\nprintk(KERN_WARNING\r\n"isdn_x25iface_connect_ind while unconfigured %s\n"\r\n, MY_DEVNAME(cprot->net_dev));\r\nreturn -1;\r\n}\r\n*state_p = WAN_CONNECTED;\r\nskb = dev_alloc_skb(1);\r\nif (skb) {\r\n*(skb_put(skb, 1)) = X25_IFACE_CONNECT;\r\nskb->protocol = x25_type_trans(skb, cprot->net_dev);\r\nnetif_rx(skb);\r\nreturn 0;\r\n} else {\r\nprintk(KERN_WARNING "isdn_x25iface_connect_ind: "\r\n" out of memory -- disconnecting\n");\r\ncprot->dops->disconn_req(cprot);\r\nreturn -1;\r\n}\r\n}\r\nstatic int isdn_x25iface_disconn_ind(struct concap_proto *cprot)\r\n{\r\nstruct sk_buff *skb;\r\nenum wan_states *state_p\r\n= &(((ix25_pdata_t *)(cprot->proto_data))->state);\r\nIX25DEBUG("isdn_x25iface_disconn_ind %s \n", MY_DEVNAME(cprot->net_dev));\r\nif (*state_p == WAN_UNCONFIGURED) {\r\nprintk(KERN_WARNING\r\n"isdn_x25iface_disconn_ind while unconfigured\n");\r\nreturn -1;\r\n}\r\nif (!cprot->net_dev) return -1;\r\n*state_p = WAN_DISCONNECTED;\r\nskb = dev_alloc_skb(1);\r\nif (skb) {\r\n*(skb_put(skb, 1)) = X25_IFACE_DISCONNECT;\r\nskb->protocol = x25_type_trans(skb, cprot->net_dev);\r\nnetif_rx(skb);\r\nreturn 0;\r\n} else {\r\nprintk(KERN_WARNING "isdn_x25iface_disconn_ind:"\r\n" out of memory\n");\r\nreturn -1;\r\n}\r\n}\r\nstatic int isdn_x25iface_xmit(struct concap_proto *cprot, struct sk_buff *skb)\r\n{\r\nunsigned char firstbyte = skb->data[0];\r\nenum wan_states *state = &((ix25_pdata_t *)cprot->proto_data)->state;\r\nint ret = 0;\r\nIX25DEBUG("isdn_x25iface_xmit: %s first=%x state=%d\n",\r\nMY_DEVNAME(cprot->net_dev), firstbyte, *state);\r\nswitch (firstbyte) {\r\ncase X25_IFACE_DATA:\r\nif (*state == WAN_CONNECTED) {\r\nskb_pull(skb, 1);\r\ncprot->net_dev->trans_start = jiffies;\r\nret = (cprot->dops->data_req(cprot, skb));\r\nif (ret) skb_push(skb, 1);\r\nreturn ret;\r\n}\r\nillegal_state_warn(*state, firstbyte);\r\nbreak;\r\ncase X25_IFACE_CONNECT:\r\nif (*state == WAN_DISCONNECTED) {\r\n*state = WAN_CONNECTING;\r\nret = cprot->dops->connect_req(cprot);\r\nif (ret) {\r\nisdn_x25iface_disconn_ind(cprot);\r\n}\r\n} else {\r\nillegal_state_warn(*state, firstbyte);\r\n}\r\nbreak;\r\ncase X25_IFACE_DISCONNECT:\r\nswitch (*state) {\r\ncase WAN_DISCONNECTED:\r\nprintk(KERN_WARNING "isdn_x25iface_xmit: disconnect "\r\n" requested while disconnected\n");\r\nisdn_x25iface_disconn_ind(cprot);\r\nbreak;\r\ncase WAN_CONNECTING:\r\ncase WAN_CONNECTED:\r\n*state = WAN_DISCONNECTED;\r\ncprot->dops->disconn_req(cprot);\r\nbreak;\r\ndefault:\r\nillegal_state_warn(*state, firstbyte);\r\n}\r\nbreak;\r\ncase X25_IFACE_PARAMS:\r\nprintk(KERN_WARNING "isdn_x25iface_xmit: setting of lapb"\r\n" options not yet supported\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "isdn_x25iface_xmit: frame with illegal"\r\n" first byte %x ignored:\n", firstbyte);\r\n}\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}
