static inline void mcspi_write_reg(struct spi_master *master,\r\nint idx, u32 val)\r\n{\r\nstruct omap2_mcspi *mcspi = spi_master_get_devdata(master);\r\nwritel_relaxed(val, mcspi->base + idx);\r\n}\r\nstatic inline u32 mcspi_read_reg(struct spi_master *master, int idx)\r\n{\r\nstruct omap2_mcspi *mcspi = spi_master_get_devdata(master);\r\nreturn readl_relaxed(mcspi->base + idx);\r\n}\r\nstatic inline void mcspi_write_cs_reg(const struct spi_device *spi,\r\nint idx, u32 val)\r\n{\r\nstruct omap2_mcspi_cs *cs = spi->controller_state;\r\nwritel_relaxed(val, cs->base + idx);\r\n}\r\nstatic inline u32 mcspi_read_cs_reg(const struct spi_device *spi, int idx)\r\n{\r\nstruct omap2_mcspi_cs *cs = spi->controller_state;\r\nreturn readl_relaxed(cs->base + idx);\r\n}\r\nstatic inline u32 mcspi_cached_chconf0(const struct spi_device *spi)\r\n{\r\nstruct omap2_mcspi_cs *cs = spi->controller_state;\r\nreturn cs->chconf0;\r\n}\r\nstatic inline void mcspi_write_chconf0(const struct spi_device *spi, u32 val)\r\n{\r\nstruct omap2_mcspi_cs *cs = spi->controller_state;\r\ncs->chconf0 = val;\r\nmcspi_write_cs_reg(spi, OMAP2_MCSPI_CHCONF0, val);\r\nmcspi_read_cs_reg(spi, OMAP2_MCSPI_CHCONF0);\r\n}\r\nstatic inline int mcspi_bytes_per_word(int word_len)\r\n{\r\nif (word_len <= 8)\r\nreturn 1;\r\nelse if (word_len <= 16)\r\nreturn 2;\r\nelse\r\nreturn 4;\r\n}\r\nstatic void omap2_mcspi_set_dma_req(const struct spi_device *spi,\r\nint is_read, int enable)\r\n{\r\nu32 l, rw;\r\nl = mcspi_cached_chconf0(spi);\r\nif (is_read)\r\nrw = OMAP2_MCSPI_CHCONF_DMAR;\r\nelse\r\nrw = OMAP2_MCSPI_CHCONF_DMAW;\r\nif (enable)\r\nl |= rw;\r\nelse\r\nl &= ~rw;\r\nmcspi_write_chconf0(spi, l);\r\n}\r\nstatic void omap2_mcspi_set_enable(const struct spi_device *spi, int enable)\r\n{\r\nstruct omap2_mcspi_cs *cs = spi->controller_state;\r\nu32 l;\r\nl = cs->chctrl0;\r\nif (enable)\r\nl |= OMAP2_MCSPI_CHCTRL_EN;\r\nelse\r\nl &= ~OMAP2_MCSPI_CHCTRL_EN;\r\ncs->chctrl0 = l;\r\nmcspi_write_cs_reg(spi, OMAP2_MCSPI_CHCTRL0, cs->chctrl0);\r\nmcspi_read_cs_reg(spi, OMAP2_MCSPI_CHCTRL0);\r\n}\r\nstatic void omap2_mcspi_force_cs(struct spi_device *spi, int cs_active)\r\n{\r\nu32 l;\r\nl = mcspi_cached_chconf0(spi);\r\nif (cs_active)\r\nl |= OMAP2_MCSPI_CHCONF_FORCE;\r\nelse\r\nl &= ~OMAP2_MCSPI_CHCONF_FORCE;\r\nmcspi_write_chconf0(spi, l);\r\n}\r\nstatic void omap2_mcspi_set_master_mode(struct spi_master *master)\r\n{\r\nstruct omap2_mcspi *mcspi = spi_master_get_devdata(master);\r\nstruct omap2_mcspi_regs *ctx = &mcspi->ctx;\r\nu32 l;\r\nl = mcspi_read_reg(master, OMAP2_MCSPI_MODULCTRL);\r\nl &= ~(OMAP2_MCSPI_MODULCTRL_STEST | OMAP2_MCSPI_MODULCTRL_MS);\r\nl |= OMAP2_MCSPI_MODULCTRL_SINGLE;\r\nmcspi_write_reg(master, OMAP2_MCSPI_MODULCTRL, l);\r\nctx->modulctrl = l;\r\n}\r\nstatic void omap2_mcspi_set_fifo(const struct spi_device *spi,\r\nstruct spi_transfer *t, int enable)\r\n{\r\nstruct spi_master *master = spi->master;\r\nstruct omap2_mcspi_cs *cs = spi->controller_state;\r\nstruct omap2_mcspi *mcspi;\r\nunsigned int wcnt;\r\nint max_fifo_depth, fifo_depth, bytes_per_word;\r\nu32 chconf, xferlevel;\r\nmcspi = spi_master_get_devdata(master);\r\nchconf = mcspi_cached_chconf0(spi);\r\nif (enable) {\r\nbytes_per_word = mcspi_bytes_per_word(cs->word_len);\r\nif (t->len % bytes_per_word != 0)\r\ngoto disable_fifo;\r\nif (t->rx_buf != NULL && t->tx_buf != NULL)\r\nmax_fifo_depth = OMAP2_MCSPI_MAX_FIFODEPTH / 2;\r\nelse\r\nmax_fifo_depth = OMAP2_MCSPI_MAX_FIFODEPTH;\r\nfifo_depth = gcd(t->len, max_fifo_depth);\r\nif (fifo_depth < 2 || fifo_depth % bytes_per_word != 0)\r\ngoto disable_fifo;\r\nwcnt = t->len / bytes_per_word;\r\nif (wcnt > OMAP2_MCSPI_MAX_FIFOWCNT)\r\ngoto disable_fifo;\r\nxferlevel = wcnt << 16;\r\nif (t->rx_buf != NULL) {\r\nchconf |= OMAP2_MCSPI_CHCONF_FFER;\r\nxferlevel |= (fifo_depth - 1) << 8;\r\n}\r\nif (t->tx_buf != NULL) {\r\nchconf |= OMAP2_MCSPI_CHCONF_FFET;\r\nxferlevel |= fifo_depth - 1;\r\n}\r\nmcspi_write_reg(master, OMAP2_MCSPI_XFERLEVEL, xferlevel);\r\nmcspi_write_chconf0(spi, chconf);\r\nmcspi->fifo_depth = fifo_depth;\r\nreturn;\r\n}\r\ndisable_fifo:\r\nif (t->rx_buf != NULL)\r\nchconf &= ~OMAP2_MCSPI_CHCONF_FFER;\r\nelse\r\nchconf &= ~OMAP2_MCSPI_CHCONF_FFET;\r\nmcspi_write_chconf0(spi, chconf);\r\nmcspi->fifo_depth = 0;\r\n}\r\nstatic void omap2_mcspi_restore_ctx(struct omap2_mcspi *mcspi)\r\n{\r\nstruct spi_master *spi_cntrl = mcspi->master;\r\nstruct omap2_mcspi_regs *ctx = &mcspi->ctx;\r\nstruct omap2_mcspi_cs *cs;\r\nmcspi_write_reg(spi_cntrl, OMAP2_MCSPI_MODULCTRL, ctx->modulctrl);\r\nmcspi_write_reg(spi_cntrl, OMAP2_MCSPI_WAKEUPENABLE, ctx->wakeupenable);\r\nlist_for_each_entry(cs, &ctx->cs, node)\r\nwritel_relaxed(cs->chconf0, cs->base + OMAP2_MCSPI_CHCONF0);\r\n}\r\nstatic int mcspi_wait_for_reg_bit(void __iomem *reg, unsigned long bit)\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(1000);\r\nwhile (!(readl_relaxed(reg) & bit)) {\r\nif (time_after(jiffies, timeout)) {\r\nif (!(readl_relaxed(reg) & bit))\r\nreturn -ETIMEDOUT;\r\nelse\r\nreturn 0;\r\n}\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap2_mcspi_rx_callback(void *data)\r\n{\r\nstruct spi_device *spi = data;\r\nstruct omap2_mcspi *mcspi = spi_master_get_devdata(spi->master);\r\nstruct omap2_mcspi_dma *mcspi_dma = &mcspi->dma_channels[spi->chip_select];\r\nomap2_mcspi_set_dma_req(spi, 1, 0);\r\ncomplete(&mcspi_dma->dma_rx_completion);\r\n}\r\nstatic void omap2_mcspi_tx_callback(void *data)\r\n{\r\nstruct spi_device *spi = data;\r\nstruct omap2_mcspi *mcspi = spi_master_get_devdata(spi->master);\r\nstruct omap2_mcspi_dma *mcspi_dma = &mcspi->dma_channels[spi->chip_select];\r\nomap2_mcspi_set_dma_req(spi, 0, 0);\r\ncomplete(&mcspi_dma->dma_tx_completion);\r\n}\r\nstatic void omap2_mcspi_tx_dma(struct spi_device *spi,\r\nstruct spi_transfer *xfer,\r\nstruct dma_slave_config cfg)\r\n{\r\nstruct omap2_mcspi *mcspi;\r\nstruct omap2_mcspi_dma *mcspi_dma;\r\nunsigned int count;\r\nmcspi = spi_master_get_devdata(spi->master);\r\nmcspi_dma = &mcspi->dma_channels[spi->chip_select];\r\ncount = xfer->len;\r\nif (mcspi_dma->dma_tx) {\r\nstruct dma_async_tx_descriptor *tx;\r\nstruct scatterlist sg;\r\ndmaengine_slave_config(mcspi_dma->dma_tx, &cfg);\r\nsg_init_table(&sg, 1);\r\nsg_dma_address(&sg) = xfer->tx_dma;\r\nsg_dma_len(&sg) = xfer->len;\r\ntx = dmaengine_prep_slave_sg(mcspi_dma->dma_tx, &sg, 1,\r\nDMA_MEM_TO_DEV, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (tx) {\r\ntx->callback = omap2_mcspi_tx_callback;\r\ntx->callback_param = spi;\r\ndmaengine_submit(tx);\r\n} else {\r\n}\r\n}\r\ndma_async_issue_pending(mcspi_dma->dma_tx);\r\nomap2_mcspi_set_dma_req(spi, 0, 1);\r\n}\r\nstatic unsigned\r\nomap2_mcspi_rx_dma(struct spi_device *spi, struct spi_transfer *xfer,\r\nstruct dma_slave_config cfg,\r\nunsigned es)\r\n{\r\nstruct omap2_mcspi *mcspi;\r\nstruct omap2_mcspi_dma *mcspi_dma;\r\nunsigned int count, dma_count;\r\nu32 l;\r\nint elements = 0;\r\nint word_len, element_count;\r\nstruct omap2_mcspi_cs *cs = spi->controller_state;\r\nmcspi = spi_master_get_devdata(spi->master);\r\nmcspi_dma = &mcspi->dma_channels[spi->chip_select];\r\ncount = xfer->len;\r\ndma_count = xfer->len;\r\nif (mcspi->fifo_depth == 0)\r\ndma_count -= es;\r\nword_len = cs->word_len;\r\nl = mcspi_cached_chconf0(spi);\r\nif (word_len <= 8)\r\nelement_count = count;\r\nelse if (word_len <= 16)\r\nelement_count = count >> 1;\r\nelse\r\nelement_count = count >> 2;\r\nif (mcspi_dma->dma_rx) {\r\nstruct dma_async_tx_descriptor *tx;\r\nstruct scatterlist sg;\r\ndmaengine_slave_config(mcspi_dma->dma_rx, &cfg);\r\nif ((l & OMAP2_MCSPI_CHCONF_TURBO) && mcspi->fifo_depth == 0)\r\ndma_count -= es;\r\nsg_init_table(&sg, 1);\r\nsg_dma_address(&sg) = xfer->rx_dma;\r\nsg_dma_len(&sg) = dma_count;\r\ntx = dmaengine_prep_slave_sg(mcspi_dma->dma_rx, &sg, 1,\r\nDMA_DEV_TO_MEM, DMA_PREP_INTERRUPT |\r\nDMA_CTRL_ACK);\r\nif (tx) {\r\ntx->callback = omap2_mcspi_rx_callback;\r\ntx->callback_param = spi;\r\ndmaengine_submit(tx);\r\n} else {\r\n}\r\n}\r\ndma_async_issue_pending(mcspi_dma->dma_rx);\r\nomap2_mcspi_set_dma_req(spi, 1, 1);\r\nwait_for_completion(&mcspi_dma->dma_rx_completion);\r\ndma_unmap_single(mcspi->dev, xfer->rx_dma, count,\r\nDMA_FROM_DEVICE);\r\nif (mcspi->fifo_depth > 0)\r\nreturn count;\r\nomap2_mcspi_set_enable(spi, 0);\r\nelements = element_count - 1;\r\nif (l & OMAP2_MCSPI_CHCONF_TURBO) {\r\nelements--;\r\nif (likely(mcspi_read_cs_reg(spi, OMAP2_MCSPI_CHSTAT0)\r\n& OMAP2_MCSPI_CHSTAT_RXS)) {\r\nu32 w;\r\nw = mcspi_read_cs_reg(spi, OMAP2_MCSPI_RX0);\r\nif (word_len <= 8)\r\n((u8 *)xfer->rx_buf)[elements++] = w;\r\nelse if (word_len <= 16)\r\n((u16 *)xfer->rx_buf)[elements++] = w;\r\nelse\r\n((u32 *)xfer->rx_buf)[elements++] = w;\r\n} else {\r\nint bytes_per_word = mcspi_bytes_per_word(word_len);\r\ndev_err(&spi->dev, "DMA RX penultimate word empty\n");\r\ncount -= (bytes_per_word << 1);\r\nomap2_mcspi_set_enable(spi, 1);\r\nreturn count;\r\n}\r\n}\r\nif (likely(mcspi_read_cs_reg(spi, OMAP2_MCSPI_CHSTAT0)\r\n& OMAP2_MCSPI_CHSTAT_RXS)) {\r\nu32 w;\r\nw = mcspi_read_cs_reg(spi, OMAP2_MCSPI_RX0);\r\nif (word_len <= 8)\r\n((u8 *)xfer->rx_buf)[elements] = w;\r\nelse if (word_len <= 16)\r\n((u16 *)xfer->rx_buf)[elements] = w;\r\nelse\r\n((u32 *)xfer->rx_buf)[elements] = w;\r\n} else {\r\ndev_err(&spi->dev, "DMA RX last word empty\n");\r\ncount -= mcspi_bytes_per_word(word_len);\r\n}\r\nomap2_mcspi_set_enable(spi, 1);\r\nreturn count;\r\n}\r\nstatic unsigned\r\nomap2_mcspi_txrx_dma(struct spi_device *spi, struct spi_transfer *xfer)\r\n{\r\nstruct omap2_mcspi *mcspi;\r\nstruct omap2_mcspi_cs *cs = spi->controller_state;\r\nstruct omap2_mcspi_dma *mcspi_dma;\r\nunsigned int count;\r\nu32 l;\r\nu8 *rx;\r\nconst u8 *tx;\r\nstruct dma_slave_config cfg;\r\nenum dma_slave_buswidth width;\r\nunsigned es;\r\nu32 burst;\r\nvoid __iomem *chstat_reg;\r\nvoid __iomem *irqstat_reg;\r\nint wait_res;\r\nmcspi = spi_master_get_devdata(spi->master);\r\nmcspi_dma = &mcspi->dma_channels[spi->chip_select];\r\nl = mcspi_cached_chconf0(spi);\r\nif (cs->word_len <= 8) {\r\nwidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nes = 1;\r\n} else if (cs->word_len <= 16) {\r\nwidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nes = 2;\r\n} else {\r\nwidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nes = 4;\r\n}\r\ncount = xfer->len;\r\nburst = 1;\r\nif (mcspi->fifo_depth > 0) {\r\nif (count > mcspi->fifo_depth)\r\nburst = mcspi->fifo_depth / es;\r\nelse\r\nburst = count / es;\r\n}\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.src_addr = cs->phys + OMAP2_MCSPI_RX0;\r\ncfg.dst_addr = cs->phys + OMAP2_MCSPI_TX0;\r\ncfg.src_addr_width = width;\r\ncfg.dst_addr_width = width;\r\ncfg.src_maxburst = burst;\r\ncfg.dst_maxburst = burst;\r\nrx = xfer->rx_buf;\r\ntx = xfer->tx_buf;\r\nif (tx != NULL)\r\nomap2_mcspi_tx_dma(spi, xfer, cfg);\r\nif (rx != NULL)\r\ncount = omap2_mcspi_rx_dma(spi, xfer, cfg, es);\r\nif (tx != NULL) {\r\nwait_for_completion(&mcspi_dma->dma_tx_completion);\r\ndma_unmap_single(mcspi->dev, xfer->tx_dma, xfer->len,\r\nDMA_TO_DEVICE);\r\nif (mcspi->fifo_depth > 0) {\r\nirqstat_reg = mcspi->base + OMAP2_MCSPI_IRQSTATUS;\r\nif (mcspi_wait_for_reg_bit(irqstat_reg,\r\nOMAP2_MCSPI_IRQSTATUS_EOW) < 0)\r\ndev_err(&spi->dev, "EOW timed out\n");\r\nmcspi_write_reg(mcspi->master, OMAP2_MCSPI_IRQSTATUS,\r\nOMAP2_MCSPI_IRQSTATUS_EOW);\r\n}\r\nif (rx == NULL) {\r\nchstat_reg = cs->base + OMAP2_MCSPI_CHSTAT0;\r\nif (mcspi->fifo_depth > 0) {\r\nwait_res = mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_TXFFE);\r\nif (wait_res < 0)\r\ndev_err(&spi->dev, "TXFFE timed out\n");\r\n} else {\r\nwait_res = mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_TXS);\r\nif (wait_res < 0)\r\ndev_err(&spi->dev, "TXS timed out\n");\r\n}\r\nif (wait_res >= 0 &&\r\n(mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_EOT) < 0))\r\ndev_err(&spi->dev, "EOT timed out\n");\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic unsigned\r\nomap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer)\r\n{\r\nstruct omap2_mcspi *mcspi;\r\nstruct omap2_mcspi_cs *cs = spi->controller_state;\r\nunsigned int count, c;\r\nu32 l;\r\nvoid __iomem *base = cs->base;\r\nvoid __iomem *tx_reg;\r\nvoid __iomem *rx_reg;\r\nvoid __iomem *chstat_reg;\r\nint word_len;\r\nmcspi = spi_master_get_devdata(spi->master);\r\ncount = xfer->len;\r\nc = count;\r\nword_len = cs->word_len;\r\nl = mcspi_cached_chconf0(spi);\r\ntx_reg = base + OMAP2_MCSPI_TX0;\r\nrx_reg = base + OMAP2_MCSPI_RX0;\r\nchstat_reg = base + OMAP2_MCSPI_CHSTAT0;\r\nif (c < (word_len>>3))\r\nreturn 0;\r\nif (word_len <= 8) {\r\nu8 *rx;\r\nconst u8 *tx;\r\nrx = xfer->rx_buf;\r\ntx = xfer->tx_buf;\r\ndo {\r\nc -= 1;\r\nif (tx != NULL) {\r\nif (mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_TXS) < 0) {\r\ndev_err(&spi->dev, "TXS timed out\n");\r\ngoto out;\r\n}\r\ndev_vdbg(&spi->dev, "write-%d %02x\n",\r\nword_len, *tx);\r\nwritel_relaxed(*tx++, tx_reg);\r\n}\r\nif (rx != NULL) {\r\nif (mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_RXS) < 0) {\r\ndev_err(&spi->dev, "RXS timed out\n");\r\ngoto out;\r\n}\r\nif (c == 1 && tx == NULL &&\r\n(l & OMAP2_MCSPI_CHCONF_TURBO)) {\r\nomap2_mcspi_set_enable(spi, 0);\r\n*rx++ = readl_relaxed(rx_reg);\r\ndev_vdbg(&spi->dev, "read-%d %02x\n",\r\nword_len, *(rx - 1));\r\nif (mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_RXS) < 0) {\r\ndev_err(&spi->dev,\r\n"RXS timed out\n");\r\ngoto out;\r\n}\r\nc = 0;\r\n} else if (c == 0 && tx == NULL) {\r\nomap2_mcspi_set_enable(spi, 0);\r\n}\r\n*rx++ = readl_relaxed(rx_reg);\r\ndev_vdbg(&spi->dev, "read-%d %02x\n",\r\nword_len, *(rx - 1));\r\n}\r\n} while (c);\r\n} else if (word_len <= 16) {\r\nu16 *rx;\r\nconst u16 *tx;\r\nrx = xfer->rx_buf;\r\ntx = xfer->tx_buf;\r\ndo {\r\nc -= 2;\r\nif (tx != NULL) {\r\nif (mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_TXS) < 0) {\r\ndev_err(&spi->dev, "TXS timed out\n");\r\ngoto out;\r\n}\r\ndev_vdbg(&spi->dev, "write-%d %04x\n",\r\nword_len, *tx);\r\nwritel_relaxed(*tx++, tx_reg);\r\n}\r\nif (rx != NULL) {\r\nif (mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_RXS) < 0) {\r\ndev_err(&spi->dev, "RXS timed out\n");\r\ngoto out;\r\n}\r\nif (c == 2 && tx == NULL &&\r\n(l & OMAP2_MCSPI_CHCONF_TURBO)) {\r\nomap2_mcspi_set_enable(spi, 0);\r\n*rx++ = readl_relaxed(rx_reg);\r\ndev_vdbg(&spi->dev, "read-%d %04x\n",\r\nword_len, *(rx - 1));\r\nif (mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_RXS) < 0) {\r\ndev_err(&spi->dev,\r\n"RXS timed out\n");\r\ngoto out;\r\n}\r\nc = 0;\r\n} else if (c == 0 && tx == NULL) {\r\nomap2_mcspi_set_enable(spi, 0);\r\n}\r\n*rx++ = readl_relaxed(rx_reg);\r\ndev_vdbg(&spi->dev, "read-%d %04x\n",\r\nword_len, *(rx - 1));\r\n}\r\n} while (c >= 2);\r\n} else if (word_len <= 32) {\r\nu32 *rx;\r\nconst u32 *tx;\r\nrx = xfer->rx_buf;\r\ntx = xfer->tx_buf;\r\ndo {\r\nc -= 4;\r\nif (tx != NULL) {\r\nif (mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_TXS) < 0) {\r\ndev_err(&spi->dev, "TXS timed out\n");\r\ngoto out;\r\n}\r\ndev_vdbg(&spi->dev, "write-%d %08x\n",\r\nword_len, *tx);\r\nwritel_relaxed(*tx++, tx_reg);\r\n}\r\nif (rx != NULL) {\r\nif (mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_RXS) < 0) {\r\ndev_err(&spi->dev, "RXS timed out\n");\r\ngoto out;\r\n}\r\nif (c == 4 && tx == NULL &&\r\n(l & OMAP2_MCSPI_CHCONF_TURBO)) {\r\nomap2_mcspi_set_enable(spi, 0);\r\n*rx++ = readl_relaxed(rx_reg);\r\ndev_vdbg(&spi->dev, "read-%d %08x\n",\r\nword_len, *(rx - 1));\r\nif (mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_RXS) < 0) {\r\ndev_err(&spi->dev,\r\n"RXS timed out\n");\r\ngoto out;\r\n}\r\nc = 0;\r\n} else if (c == 0 && tx == NULL) {\r\nomap2_mcspi_set_enable(spi, 0);\r\n}\r\n*rx++ = readl_relaxed(rx_reg);\r\ndev_vdbg(&spi->dev, "read-%d %08x\n",\r\nword_len, *(rx - 1));\r\n}\r\n} while (c >= 4);\r\n}\r\nif (xfer->rx_buf == NULL) {\r\nif (mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_TXS) < 0) {\r\ndev_err(&spi->dev, "TXS timed out\n");\r\n} else if (mcspi_wait_for_reg_bit(chstat_reg,\r\nOMAP2_MCSPI_CHSTAT_EOT) < 0)\r\ndev_err(&spi->dev, "EOT timed out\n");\r\nomap2_mcspi_set_enable(spi, 0);\r\n}\r\nout:\r\nomap2_mcspi_set_enable(spi, 1);\r\nreturn count - c;\r\n}\r\nstatic u32 omap2_mcspi_calc_divisor(u32 speed_hz)\r\n{\r\nu32 div;\r\nfor (div = 0; div < 15; div++)\r\nif (speed_hz >= (OMAP2_MCSPI_MAX_FREQ >> div))\r\nreturn div;\r\nreturn 15;\r\n}\r\nstatic int omap2_mcspi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct omap2_mcspi_cs *cs = spi->controller_state;\r\nstruct omap2_mcspi *mcspi;\r\nstruct spi_master *spi_cntrl;\r\nu32 l = 0, clkd = 0, div, extclk = 0, clkg = 0;\r\nu8 word_len = spi->bits_per_word;\r\nu32 speed_hz = spi->max_speed_hz;\r\nmcspi = spi_master_get_devdata(spi->master);\r\nspi_cntrl = mcspi->master;\r\nif (t != NULL && t->bits_per_word)\r\nword_len = t->bits_per_word;\r\ncs->word_len = word_len;\r\nif (t && t->speed_hz)\r\nspeed_hz = t->speed_hz;\r\nspeed_hz = min_t(u32, speed_hz, OMAP2_MCSPI_MAX_FREQ);\r\nif (speed_hz < (OMAP2_MCSPI_MAX_FREQ / OMAP2_MCSPI_MAX_DIVIDER)) {\r\nclkd = omap2_mcspi_calc_divisor(speed_hz);\r\nspeed_hz = OMAP2_MCSPI_MAX_FREQ >> clkd;\r\nclkg = 0;\r\n} else {\r\ndiv = (OMAP2_MCSPI_MAX_FREQ + speed_hz - 1) / speed_hz;\r\nspeed_hz = OMAP2_MCSPI_MAX_FREQ / div;\r\nclkd = (div - 1) & 0xf;\r\nextclk = (div - 1) >> 4;\r\nclkg = OMAP2_MCSPI_CHCONF_CLKG;\r\n}\r\nl = mcspi_cached_chconf0(spi);\r\nif (mcspi->pin_dir == MCSPI_PINDIR_D0_IN_D1_OUT) {\r\nl &= ~OMAP2_MCSPI_CHCONF_IS;\r\nl &= ~OMAP2_MCSPI_CHCONF_DPE1;\r\nl |= OMAP2_MCSPI_CHCONF_DPE0;\r\n} else {\r\nl |= OMAP2_MCSPI_CHCONF_IS;\r\nl |= OMAP2_MCSPI_CHCONF_DPE1;\r\nl &= ~OMAP2_MCSPI_CHCONF_DPE0;\r\n}\r\nl &= ~OMAP2_MCSPI_CHCONF_WL_MASK;\r\nl |= (word_len - 1) << 7;\r\nif (!(spi->mode & SPI_CS_HIGH))\r\nl |= OMAP2_MCSPI_CHCONF_EPOL;\r\nelse\r\nl &= ~OMAP2_MCSPI_CHCONF_EPOL;\r\nl &= ~OMAP2_MCSPI_CHCONF_CLKD_MASK;\r\nl |= clkd << 2;\r\nl &= ~OMAP2_MCSPI_CHCONF_CLKG;\r\nl |= clkg;\r\nif (clkg) {\r\ncs->chctrl0 &= ~OMAP2_MCSPI_CHCTRL_EXTCLK_MASK;\r\ncs->chctrl0 |= extclk << 8;\r\nmcspi_write_cs_reg(spi, OMAP2_MCSPI_CHCTRL0, cs->chctrl0);\r\n}\r\nif (spi->mode & SPI_CPOL)\r\nl |= OMAP2_MCSPI_CHCONF_POL;\r\nelse\r\nl &= ~OMAP2_MCSPI_CHCONF_POL;\r\nif (spi->mode & SPI_CPHA)\r\nl |= OMAP2_MCSPI_CHCONF_PHA;\r\nelse\r\nl &= ~OMAP2_MCSPI_CHCONF_PHA;\r\nmcspi_write_chconf0(spi, l);\r\ndev_dbg(&spi->dev, "setup: speed %d, sample %s edge, clk %s\n",\r\nspeed_hz,\r\n(spi->mode & SPI_CPHA) ? "trailing" : "leading",\r\n(spi->mode & SPI_CPOL) ? "inverted" : "normal");\r\nreturn 0;\r\n}\r\nstatic int omap2_mcspi_request_dma(struct spi_device *spi)\r\n{\r\nstruct spi_master *master = spi->master;\r\nstruct omap2_mcspi *mcspi;\r\nstruct omap2_mcspi_dma *mcspi_dma;\r\ndma_cap_mask_t mask;\r\nunsigned sig;\r\nmcspi = spi_master_get_devdata(master);\r\nmcspi_dma = mcspi->dma_channels + spi->chip_select;\r\ninit_completion(&mcspi_dma->dma_rx_completion);\r\ninit_completion(&mcspi_dma->dma_tx_completion);\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nsig = mcspi_dma->dma_rx_sync_dev;\r\nmcspi_dma->dma_rx =\r\ndma_request_slave_channel_compat(mask, omap_dma_filter_fn,\r\n&sig, &master->dev,\r\nmcspi_dma->dma_rx_ch_name);\r\nif (!mcspi_dma->dma_rx)\r\ngoto no_dma;\r\nsig = mcspi_dma->dma_tx_sync_dev;\r\nmcspi_dma->dma_tx =\r\ndma_request_slave_channel_compat(mask, omap_dma_filter_fn,\r\n&sig, &master->dev,\r\nmcspi_dma->dma_tx_ch_name);\r\nif (!mcspi_dma->dma_tx) {\r\ndma_release_channel(mcspi_dma->dma_rx);\r\nmcspi_dma->dma_rx = NULL;\r\ngoto no_dma;\r\n}\r\nreturn 0;\r\nno_dma:\r\ndev_warn(&spi->dev, "not using DMA for McSPI\n");\r\nreturn -EAGAIN;\r\n}\r\nstatic int omap2_mcspi_setup(struct spi_device *spi)\r\n{\r\nint ret;\r\nstruct omap2_mcspi *mcspi = spi_master_get_devdata(spi->master);\r\nstruct omap2_mcspi_regs *ctx = &mcspi->ctx;\r\nstruct omap2_mcspi_dma *mcspi_dma;\r\nstruct omap2_mcspi_cs *cs = spi->controller_state;\r\nmcspi_dma = &mcspi->dma_channels[spi->chip_select];\r\nif (!cs) {\r\ncs = kzalloc(sizeof *cs, GFP_KERNEL);\r\nif (!cs)\r\nreturn -ENOMEM;\r\ncs->base = mcspi->base + spi->chip_select * 0x14;\r\ncs->phys = mcspi->phys + spi->chip_select * 0x14;\r\ncs->chconf0 = 0;\r\ncs->chctrl0 = 0;\r\nspi->controller_state = cs;\r\nlist_add_tail(&cs->node, &ctx->cs);\r\n}\r\nif (!mcspi_dma->dma_rx || !mcspi_dma->dma_tx) {\r\nret = omap2_mcspi_request_dma(spi);\r\nif (ret < 0 && ret != -EAGAIN)\r\nreturn ret;\r\n}\r\nret = pm_runtime_get_sync(mcspi->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = omap2_mcspi_setup_transfer(spi, NULL);\r\npm_runtime_mark_last_busy(mcspi->dev);\r\npm_runtime_put_autosuspend(mcspi->dev);\r\nreturn ret;\r\n}\r\nstatic void omap2_mcspi_cleanup(struct spi_device *spi)\r\n{\r\nstruct omap2_mcspi *mcspi;\r\nstruct omap2_mcspi_dma *mcspi_dma;\r\nstruct omap2_mcspi_cs *cs;\r\nmcspi = spi_master_get_devdata(spi->master);\r\nif (spi->controller_state) {\r\ncs = spi->controller_state;\r\nlist_del(&cs->node);\r\nkfree(cs);\r\n}\r\nif (spi->chip_select < spi->master->num_chipselect) {\r\nmcspi_dma = &mcspi->dma_channels[spi->chip_select];\r\nif (mcspi_dma->dma_rx) {\r\ndma_release_channel(mcspi_dma->dma_rx);\r\nmcspi_dma->dma_rx = NULL;\r\n}\r\nif (mcspi_dma->dma_tx) {\r\ndma_release_channel(mcspi_dma->dma_tx);\r\nmcspi_dma->dma_tx = NULL;\r\n}\r\n}\r\n}\r\nstatic void omap2_mcspi_work(struct omap2_mcspi *mcspi, struct spi_message *m)\r\n{\r\nstruct spi_device *spi;\r\nstruct spi_transfer *t = NULL;\r\nstruct spi_master *master;\r\nstruct omap2_mcspi_dma *mcspi_dma;\r\nint cs_active = 0;\r\nstruct omap2_mcspi_cs *cs;\r\nstruct omap2_mcspi_device_config *cd;\r\nint par_override = 0;\r\nint status = 0;\r\nu32 chconf;\r\nspi = m->spi;\r\nmaster = spi->master;\r\nmcspi_dma = mcspi->dma_channels + spi->chip_select;\r\ncs = spi->controller_state;\r\ncd = spi->controller_data;\r\nomap2_mcspi_set_enable(spi, 0);\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (t->tx_buf == NULL && t->rx_buf == NULL && t->len) {\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nif (par_override ||\r\n(t->speed_hz != spi->max_speed_hz) ||\r\n(t->bits_per_word != spi->bits_per_word)) {\r\npar_override = 1;\r\nstatus = omap2_mcspi_setup_transfer(spi, t);\r\nif (status < 0)\r\nbreak;\r\nif (t->speed_hz == spi->max_speed_hz &&\r\nt->bits_per_word == spi->bits_per_word)\r\npar_override = 0;\r\n}\r\nif (cd && cd->cs_per_word) {\r\nchconf = mcspi->ctx.modulctrl;\r\nchconf &= ~OMAP2_MCSPI_MODULCTRL_SINGLE;\r\nmcspi_write_reg(master, OMAP2_MCSPI_MODULCTRL, chconf);\r\nmcspi->ctx.modulctrl =\r\nmcspi_read_cs_reg(spi, OMAP2_MCSPI_MODULCTRL);\r\n}\r\nif (!cs_active) {\r\nomap2_mcspi_force_cs(spi, 1);\r\ncs_active = 1;\r\n}\r\nchconf = mcspi_cached_chconf0(spi);\r\nchconf &= ~OMAP2_MCSPI_CHCONF_TRM_MASK;\r\nchconf &= ~OMAP2_MCSPI_CHCONF_TURBO;\r\nif (t->tx_buf == NULL)\r\nchconf |= OMAP2_MCSPI_CHCONF_TRM_RX_ONLY;\r\nelse if (t->rx_buf == NULL)\r\nchconf |= OMAP2_MCSPI_CHCONF_TRM_TX_ONLY;\r\nif (cd && cd->turbo_mode && t->tx_buf == NULL) {\r\nif (t->len > ((cs->word_len + 7) >> 3))\r\nchconf |= OMAP2_MCSPI_CHCONF_TURBO;\r\n}\r\nmcspi_write_chconf0(spi, chconf);\r\nif (t->len) {\r\nunsigned count;\r\nif ((mcspi_dma->dma_rx && mcspi_dma->dma_tx) &&\r\n(m->is_dma_mapped || t->len >= DMA_MIN_BYTES))\r\nomap2_mcspi_set_fifo(spi, t, 1);\r\nomap2_mcspi_set_enable(spi, 1);\r\nif (t->tx_buf == NULL)\r\nwritel_relaxed(0, cs->base\r\n+ OMAP2_MCSPI_TX0);\r\nif ((mcspi_dma->dma_rx && mcspi_dma->dma_tx) &&\r\n(m->is_dma_mapped || t->len >= DMA_MIN_BYTES))\r\ncount = omap2_mcspi_txrx_dma(spi, t);\r\nelse\r\ncount = omap2_mcspi_txrx_pio(spi, t);\r\nm->actual_length += count;\r\nif (count != t->len) {\r\nstatus = -EIO;\r\nbreak;\r\n}\r\n}\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nif (t->cs_change) {\r\nomap2_mcspi_force_cs(spi, 0);\r\ncs_active = 0;\r\n}\r\nomap2_mcspi_set_enable(spi, 0);\r\nif (mcspi->fifo_depth > 0)\r\nomap2_mcspi_set_fifo(spi, t, 0);\r\n}\r\nif (par_override) {\r\npar_override = 0;\r\nstatus = omap2_mcspi_setup_transfer(spi, NULL);\r\n}\r\nif (cs_active)\r\nomap2_mcspi_force_cs(spi, 0);\r\nif (cd && cd->cs_per_word) {\r\nchconf = mcspi->ctx.modulctrl;\r\nchconf |= OMAP2_MCSPI_MODULCTRL_SINGLE;\r\nmcspi_write_reg(master, OMAP2_MCSPI_MODULCTRL, chconf);\r\nmcspi->ctx.modulctrl =\r\nmcspi_read_cs_reg(spi, OMAP2_MCSPI_MODULCTRL);\r\n}\r\nomap2_mcspi_set_enable(spi, 0);\r\nif (mcspi->fifo_depth > 0 && t)\r\nomap2_mcspi_set_fifo(spi, t, 0);\r\nm->status = status;\r\n}\r\nstatic int omap2_mcspi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *m)\r\n{\r\nstruct spi_device *spi;\r\nstruct omap2_mcspi *mcspi;\r\nstruct omap2_mcspi_dma *mcspi_dma;\r\nstruct spi_transfer *t;\r\nspi = m->spi;\r\nmcspi = spi_master_get_devdata(master);\r\nmcspi_dma = mcspi->dma_channels + spi->chip_select;\r\nm->actual_length = 0;\r\nm->status = 0;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nconst void *tx_buf = t->tx_buf;\r\nvoid *rx_buf = t->rx_buf;\r\nunsigned len = t->len;\r\nif ((len && !(rx_buf || tx_buf))) {\r\ndev_dbg(mcspi->dev, "transfer: %d Hz, %d %s%s, %d bpw\n",\r\nt->speed_hz,\r\nlen,\r\ntx_buf ? "tx" : "",\r\nrx_buf ? "rx" : "",\r\nt->bits_per_word);\r\nreturn -EINVAL;\r\n}\r\nif (m->is_dma_mapped || len < DMA_MIN_BYTES)\r\ncontinue;\r\nif (mcspi_dma->dma_tx && tx_buf != NULL) {\r\nt->tx_dma = dma_map_single(mcspi->dev, (void *) tx_buf,\r\nlen, DMA_TO_DEVICE);\r\nif (dma_mapping_error(mcspi->dev, t->tx_dma)) {\r\ndev_dbg(mcspi->dev, "dma %cX %d bytes error\n",\r\n'T', len);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (mcspi_dma->dma_rx && rx_buf != NULL) {\r\nt->rx_dma = dma_map_single(mcspi->dev, rx_buf, t->len,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(mcspi->dev, t->rx_dma)) {\r\ndev_dbg(mcspi->dev, "dma %cX %d bytes error\n",\r\n'R', len);\r\nif (tx_buf != NULL)\r\ndma_unmap_single(mcspi->dev, t->tx_dma,\r\nlen, DMA_TO_DEVICE);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nomap2_mcspi_work(mcspi, m);\r\nspi_finalize_current_message(master);\r\nreturn 0;\r\n}\r\nstatic int omap2_mcspi_master_setup(struct omap2_mcspi *mcspi)\r\n{\r\nstruct spi_master *master = mcspi->master;\r\nstruct omap2_mcspi_regs *ctx = &mcspi->ctx;\r\nint ret = 0;\r\nret = pm_runtime_get_sync(mcspi->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nmcspi_write_reg(master, OMAP2_MCSPI_WAKEUPENABLE,\r\nOMAP2_MCSPI_WAKEUPENABLE_WKEN);\r\nctx->wakeupenable = OMAP2_MCSPI_WAKEUPENABLE_WKEN;\r\nomap2_mcspi_set_master_mode(master);\r\npm_runtime_mark_last_busy(mcspi->dev);\r\npm_runtime_put_autosuspend(mcspi->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_mcspi_runtime_resume(struct device *dev)\r\n{\r\nstruct omap2_mcspi *mcspi;\r\nstruct spi_master *master;\r\nmaster = dev_get_drvdata(dev);\r\nmcspi = spi_master_get_devdata(master);\r\nomap2_mcspi_restore_ctx(mcspi);\r\nreturn 0;\r\n}\r\nstatic int omap2_mcspi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nconst struct omap2_mcspi_platform_config *pdata;\r\nstruct omap2_mcspi *mcspi;\r\nstruct resource *r;\r\nint status = 0, i;\r\nu32 regs_offset = 0;\r\nstatic int bus_num = 1;\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof *mcspi);\r\nif (master == NULL) {\r\ndev_dbg(&pdev->dev, "master allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\r\nmaster->setup = omap2_mcspi_setup;\r\nmaster->auto_runtime_pm = true;\r\nmaster->transfer_one_message = omap2_mcspi_transfer_one_message;\r\nmaster->cleanup = omap2_mcspi_cleanup;\r\nmaster->dev.of_node = node;\r\nmaster->max_speed_hz = OMAP2_MCSPI_MAX_FREQ;\r\nmaster->min_speed_hz = OMAP2_MCSPI_MAX_FREQ >> 15;\r\nplatform_set_drvdata(pdev, master);\r\nmcspi = spi_master_get_devdata(master);\r\nmcspi->master = master;\r\nmatch = of_match_device(omap_mcspi_of_match, &pdev->dev);\r\nif (match) {\r\nu32 num_cs = 1;\r\npdata = match->data;\r\nof_property_read_u32(node, "ti,spi-num-cs", &num_cs);\r\nmaster->num_chipselect = num_cs;\r\nmaster->bus_num = bus_num++;\r\nif (of_get_property(node, "ti,pindir-d0-out-d1-in", NULL))\r\nmcspi->pin_dir = MCSPI_PINDIR_D0_OUT_D1_IN;\r\n} else {\r\npdata = dev_get_platdata(&pdev->dev);\r\nmaster->num_chipselect = pdata->num_cs;\r\nif (pdev->id != -1)\r\nmaster->bus_num = pdev->id;\r\nmcspi->pin_dir = pdata->pin_dir;\r\n}\r\nregs_offset = pdata->regs_offset;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\nstatus = -ENODEV;\r\ngoto free_master;\r\n}\r\nr->start += regs_offset;\r\nr->end += regs_offset;\r\nmcspi->phys = r->start;\r\nmcspi->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(mcspi->base)) {\r\nstatus = PTR_ERR(mcspi->base);\r\ngoto free_master;\r\n}\r\nmcspi->dev = &pdev->dev;\r\nINIT_LIST_HEAD(&mcspi->ctx.cs);\r\nmcspi->dma_channels = devm_kcalloc(&pdev->dev, master->num_chipselect,\r\nsizeof(struct omap2_mcspi_dma),\r\nGFP_KERNEL);\r\nif (mcspi->dma_channels == NULL) {\r\nstatus = -ENOMEM;\r\ngoto free_master;\r\n}\r\nfor (i = 0; i < master->num_chipselect; i++) {\r\nchar *dma_rx_ch_name = mcspi->dma_channels[i].dma_rx_ch_name;\r\nchar *dma_tx_ch_name = mcspi->dma_channels[i].dma_tx_ch_name;\r\nstruct resource *dma_res;\r\nsprintf(dma_rx_ch_name, "rx%d", i);\r\nif (!pdev->dev.of_node) {\r\ndma_res =\r\nplatform_get_resource_byname(pdev,\r\nIORESOURCE_DMA,\r\ndma_rx_ch_name);\r\nif (!dma_res) {\r\ndev_dbg(&pdev->dev,\r\n"cannot get DMA RX channel\n");\r\nstatus = -ENODEV;\r\nbreak;\r\n}\r\nmcspi->dma_channels[i].dma_rx_sync_dev =\r\ndma_res->start;\r\n}\r\nsprintf(dma_tx_ch_name, "tx%d", i);\r\nif (!pdev->dev.of_node) {\r\ndma_res =\r\nplatform_get_resource_byname(pdev,\r\nIORESOURCE_DMA,\r\ndma_tx_ch_name);\r\nif (!dma_res) {\r\ndev_dbg(&pdev->dev,\r\n"cannot get DMA TX channel\n");\r\nstatus = -ENODEV;\r\nbreak;\r\n}\r\nmcspi->dma_channels[i].dma_tx_sync_dev =\r\ndma_res->start;\r\n}\r\n}\r\nif (status < 0)\r\ngoto free_master;\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, SPI_AUTOSUSPEND_TIMEOUT);\r\npm_runtime_enable(&pdev->dev);\r\nstatus = omap2_mcspi_master_setup(mcspi);\r\nif (status < 0)\r\ngoto disable_pm;\r\nstatus = devm_spi_register_master(&pdev->dev, master);\r\nif (status < 0)\r\ngoto disable_pm;\r\nreturn status;\r\ndisable_pm:\r\npm_runtime_disable(&pdev->dev);\r\nfree_master:\r\nspi_master_put(master);\r\nreturn status;\r\n}\r\nstatic int omap2_mcspi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct omap2_mcspi *mcspi = spi_master_get_devdata(master);\r\npm_runtime_put_sync(mcspi->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int omap2_mcspi_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct omap2_mcspi *mcspi = spi_master_get_devdata(master);\r\nstruct omap2_mcspi_regs *ctx = &mcspi->ctx;\r\nstruct omap2_mcspi_cs *cs;\r\npm_runtime_get_sync(mcspi->dev);\r\nlist_for_each_entry(cs, &ctx->cs, node) {\r\nif ((cs->chconf0 & OMAP2_MCSPI_CHCONF_FORCE) == 0) {\r\ncs->chconf0 |= OMAP2_MCSPI_CHCONF_FORCE;\r\nwritel_relaxed(cs->chconf0, cs->base + OMAP2_MCSPI_CHCONF0);\r\ncs->chconf0 &= ~OMAP2_MCSPI_CHCONF_FORCE;\r\nwritel_relaxed(cs->chconf0, cs->base + OMAP2_MCSPI_CHCONF0);\r\n}\r\n}\r\npm_runtime_mark_last_busy(mcspi->dev);\r\npm_runtime_put_autosuspend(mcspi->dev);\r\nreturn 0;\r\n}
