static inline struct sci_port *\r\nto_sci_port(struct uart_port *uart)\r\n{\r\nreturn container_of(uart, struct sci_port, port);\r\n}\r\nstatic unsigned int sci_serial_in(struct uart_port *p, int offset)\r\n{\r\nstruct plat_sci_reg *reg = sci_getreg(p, offset);\r\nif (reg->size == 8)\r\nreturn ioread8(p->membase + (reg->offset << p->regshift));\r\nelse if (reg->size == 16)\r\nreturn ioread16(p->membase + (reg->offset << p->regshift));\r\nelse\r\nWARN(1, "Invalid register access\n");\r\nreturn 0;\r\n}\r\nstatic void sci_serial_out(struct uart_port *p, int offset, int value)\r\n{\r\nstruct plat_sci_reg *reg = sci_getreg(p, offset);\r\nif (reg->size == 8)\r\niowrite8(value, p->membase + (reg->offset << p->regshift));\r\nelse if (reg->size == 16)\r\niowrite16(value, p->membase + (reg->offset << p->regshift));\r\nelse\r\nWARN(1, "Invalid register access\n");\r\n}\r\nstatic int sci_probe_regmap(struct plat_sci_port *cfg)\r\n{\r\nswitch (cfg->type) {\r\ncase PORT_SCI:\r\ncfg->regtype = SCIx_SCI_REGTYPE;\r\nbreak;\r\ncase PORT_IRDA:\r\ncfg->regtype = SCIx_IRDA_REGTYPE;\r\nbreak;\r\ncase PORT_SCIFA:\r\ncfg->regtype = SCIx_SCIFA_REGTYPE;\r\nbreak;\r\ncase PORT_SCIFB:\r\ncfg->regtype = SCIx_SCIFB_REGTYPE;\r\nbreak;\r\ncase PORT_SCIF:\r\ncfg->regtype = SCIx_SH4_SCIF_REGTYPE;\r\nbreak;\r\ncase PORT_HSCIF:\r\ncfg->regtype = SCIx_HSCIF_REGTYPE;\r\nbreak;\r\ndefault:\r\npr_err("Can't probe register map for given port\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sci_port_enable(struct sci_port *sci_port)\r\n{\r\nif (!sci_port->port.dev)\r\nreturn;\r\npm_runtime_get_sync(sci_port->port.dev);\r\nclk_prepare_enable(sci_port->iclk);\r\nsci_port->port.uartclk = clk_get_rate(sci_port->iclk);\r\nclk_prepare_enable(sci_port->fclk);\r\n}\r\nstatic void sci_port_disable(struct sci_port *sci_port)\r\n{\r\nif (!sci_port->port.dev)\r\nreturn;\r\ndel_timer_sync(&sci_port->break_timer);\r\nsci_port->break_flag = 0;\r\nclk_disable_unprepare(sci_port->fclk);\r\nclk_disable_unprepare(sci_port->iclk);\r\npm_runtime_put_sync(sci_port->port.dev);\r\n}\r\nstatic int sci_poll_get_char(struct uart_port *port)\r\n{\r\nunsigned short status;\r\nint c;\r\ndo {\r\nstatus = serial_port_in(port, SCxSR);\r\nif (status & SCxSR_ERRORS(port)) {\r\nserial_port_out(port, SCxSR, SCxSR_ERROR_CLEAR(port));\r\ncontinue;\r\n}\r\nbreak;\r\n} while (1);\r\nif (!(status & SCxSR_RDxF(port)))\r\nreturn NO_POLL_CHAR;\r\nc = serial_port_in(port, SCxRDR);\r\nserial_port_in(port, SCxSR);\r\nserial_port_out(port, SCxSR, SCxSR_RDxF_CLEAR(port));\r\nreturn c;\r\n}\r\nstatic void sci_poll_put_char(struct uart_port *port, unsigned char c)\r\n{\r\nunsigned short status;\r\ndo {\r\nstatus = serial_port_in(port, SCxSR);\r\n} while (!(status & SCxSR_TDxE(port)));\r\nserial_port_out(port, SCxTDR, c);\r\nserial_port_out(port, SCxSR, SCxSR_TDxE_CLEAR(port) & ~SCxSR_TEND(port));\r\n}\r\nstatic void sci_init_pins(struct uart_port *port, unsigned int cflag)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nstruct plat_sci_reg *reg = sci_regmap[s->cfg->regtype] + SCSPTR;\r\nif (s->cfg->ops && s->cfg->ops->init_pins) {\r\ns->cfg->ops->init_pins(port, cflag);\r\nreturn;\r\n}\r\nif (!reg->size)\r\nreturn;\r\nif ((s->cfg->capabilities & SCIx_HAVE_RTSCTS) &&\r\n((!(cflag & CRTSCTS)))) {\r\nunsigned short status;\r\nstatus = serial_port_in(port, SCSPTR);\r\nstatus &= ~SCSPTR_CTSIO;\r\nstatus |= SCSPTR_RTSIO;\r\nserial_port_out(port, SCSPTR, status);\r\n}\r\n}\r\nstatic int sci_txfill(struct uart_port *port)\r\n{\r\nstruct plat_sci_reg *reg;\r\nreg = sci_getreg(port, SCTFDR);\r\nif (reg->size)\r\nreturn serial_port_in(port, SCTFDR) & ((port->fifosize << 1) - 1);\r\nreg = sci_getreg(port, SCFDR);\r\nif (reg->size)\r\nreturn serial_port_in(port, SCFDR) >> 8;\r\nreturn !(serial_port_in(port, SCxSR) & SCI_TDRE);\r\n}\r\nstatic int sci_txroom(struct uart_port *port)\r\n{\r\nreturn port->fifosize - sci_txfill(port);\r\n}\r\nstatic int sci_rxfill(struct uart_port *port)\r\n{\r\nstruct plat_sci_reg *reg;\r\nreg = sci_getreg(port, SCRFDR);\r\nif (reg->size)\r\nreturn serial_port_in(port, SCRFDR) & ((port->fifosize << 1) - 1);\r\nreg = sci_getreg(port, SCFDR);\r\nif (reg->size)\r\nreturn serial_port_in(port, SCFDR) & ((port->fifosize << 1) - 1);\r\nreturn (serial_port_in(port, SCxSR) & SCxSR_RDxF(port)) != 0;\r\n}\r\nstatic inline int sci_rxd_in(struct uart_port *port)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nif (s->cfg->port_reg <= 0)\r\nreturn 1;\r\nreturn !!__raw_readb((void __iomem *)(uintptr_t)s->cfg->port_reg);\r\n}\r\nstatic void sci_transmit_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned int stopped = uart_tx_stopped(port);\r\nunsigned short status;\r\nunsigned short ctrl;\r\nint count;\r\nstatus = serial_port_in(port, SCxSR);\r\nif (!(status & SCxSR_TDxE(port))) {\r\nctrl = serial_port_in(port, SCSCR);\r\nif (uart_circ_empty(xmit))\r\nctrl &= ~SCSCR_TIE;\r\nelse\r\nctrl |= SCSCR_TIE;\r\nserial_port_out(port, SCSCR, ctrl);\r\nreturn;\r\n}\r\ncount = sci_txroom(port);\r\ndo {\r\nunsigned char c;\r\nif (port->x_char) {\r\nc = port->x_char;\r\nport->x_char = 0;\r\n} else if (!uart_circ_empty(xmit) && !stopped) {\r\nc = xmit->buf[xmit->tail];\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\n} else {\r\nbreak;\r\n}\r\nserial_port_out(port, SCxTDR, c);\r\nport->icount.tx++;\r\n} while (--count > 0);\r\nserial_port_out(port, SCxSR, SCxSR_TDxE_CLEAR(port));\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit)) {\r\nsci_stop_tx(port);\r\n} else {\r\nctrl = serial_port_in(port, SCSCR);\r\nif (port->type != PORT_SCI) {\r\nserial_port_in(port, SCxSR);\r\nserial_port_out(port, SCxSR, SCxSR_TDxE_CLEAR(port));\r\n}\r\nctrl |= SCSCR_TIE;\r\nserial_port_out(port, SCSCR, ctrl);\r\n}\r\n}\r\nstatic void sci_receive_chars(struct uart_port *port)\r\n{\r\nstruct sci_port *sci_port = to_sci_port(port);\r\nstruct tty_port *tport = &port->state->port;\r\nint i, count, copied = 0;\r\nunsigned short status;\r\nunsigned char flag;\r\nstatus = serial_port_in(port, SCxSR);\r\nif (!(status & SCxSR_RDxF(port)))\r\nreturn;\r\nwhile (1) {\r\ncount = tty_buffer_request_room(tport, sci_rxfill(port));\r\nif (count == 0)\r\nbreak;\r\nif (port->type == PORT_SCI) {\r\nchar c = serial_port_in(port, SCxRDR);\r\nif (uart_handle_sysrq_char(port, c) ||\r\nsci_port->break_flag)\r\ncount = 0;\r\nelse\r\ntty_insert_flip_char(tport, c, TTY_NORMAL);\r\n} else {\r\nfor (i = 0; i < count; i++) {\r\nchar c = serial_port_in(port, SCxRDR);\r\nstatus = serial_port_in(port, SCxSR);\r\n#if defined(CONFIG_CPU_SH3)\r\nif (sci_port->break_flag) {\r\nif ((c == 0) &&\r\n(status & SCxSR_FER(port))) {\r\ncount--; i--;\r\ncontinue;\r\n}\r\ndev_dbg(port->dev, "debounce<%02x>\n", c);\r\nsci_port->break_flag = 0;\r\nif (STEPFN(c)) {\r\ncount--; i--;\r\ncontinue;\r\n}\r\n}\r\n#endif\r\nif (uart_handle_sysrq_char(port, c)) {\r\ncount--; i--;\r\ncontinue;\r\n}\r\nif (status & SCxSR_FER(port)) {\r\nflag = TTY_FRAME;\r\nport->icount.frame++;\r\ndev_notice(port->dev, "frame error\n");\r\n} else if (status & SCxSR_PER(port)) {\r\nflag = TTY_PARITY;\r\nport->icount.parity++;\r\ndev_notice(port->dev, "parity error\n");\r\n} else\r\nflag = TTY_NORMAL;\r\ntty_insert_flip_char(tport, c, flag);\r\n}\r\n}\r\nserial_port_in(port, SCxSR);\r\nserial_port_out(port, SCxSR, SCxSR_RDxF_CLEAR(port));\r\ncopied += count;\r\nport->icount.rx += count;\r\n}\r\nif (copied) {\r\ntty_flip_buffer_push(tport);\r\n} else {\r\nserial_port_in(port, SCxSR);\r\nserial_port_out(port, SCxSR, SCxSR_RDxF_CLEAR(port));\r\n}\r\n}\r\nstatic inline void sci_schedule_break_timer(struct sci_port *port)\r\n{\r\nmod_timer(&port->break_timer, jiffies + SCI_BREAK_JIFFIES);\r\n}\r\nstatic void sci_break_timer(unsigned long data)\r\n{\r\nstruct sci_port *port = (struct sci_port *)data;\r\nif (sci_rxd_in(&port->port) == 0) {\r\nport->break_flag = 1;\r\nsci_schedule_break_timer(port);\r\n} else if (port->break_flag == 1) {\r\nport->break_flag = 2;\r\nsci_schedule_break_timer(port);\r\n} else\r\nport->break_flag = 0;\r\n}\r\nstatic int sci_handle_errors(struct uart_port *port)\r\n{\r\nint copied = 0;\r\nunsigned short status = serial_port_in(port, SCxSR);\r\nstruct tty_port *tport = &port->state->port;\r\nstruct sci_port *s = to_sci_port(port);\r\nif (status & (1 << s->overrun_bit)) {\r\nport->icount.overrun++;\r\nif (tty_insert_flip_char(tport, 0, TTY_OVERRUN))\r\ncopied++;\r\ndev_notice(port->dev, "overrun error\n");\r\n}\r\nif (status & SCxSR_FER(port)) {\r\nif (sci_rxd_in(port) == 0) {\r\nstruct sci_port *sci_port = to_sci_port(port);\r\nif (!sci_port->break_flag) {\r\nport->icount.brk++;\r\nsci_port->break_flag = 1;\r\nsci_schedule_break_timer(sci_port);\r\nif (uart_handle_break(port))\r\nreturn 0;\r\ndev_dbg(port->dev, "BREAK detected\n");\r\nif (tty_insert_flip_char(tport, 0, TTY_BREAK))\r\ncopied++;\r\n}\r\n} else {\r\nport->icount.frame++;\r\nif (tty_insert_flip_char(tport, 0, TTY_FRAME))\r\ncopied++;\r\ndev_notice(port->dev, "frame error\n");\r\n}\r\n}\r\nif (status & SCxSR_PER(port)) {\r\nport->icount.parity++;\r\nif (tty_insert_flip_char(tport, 0, TTY_PARITY))\r\ncopied++;\r\ndev_notice(port->dev, "parity error\n");\r\n}\r\nif (copied)\r\ntty_flip_buffer_push(tport);\r\nreturn copied;\r\n}\r\nstatic int sci_handle_fifo_overrun(struct uart_port *port)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nstruct sci_port *s = to_sci_port(port);\r\nstruct plat_sci_reg *reg;\r\nint copied = 0;\r\nreg = sci_getreg(port, SCLSR);\r\nif (!reg->size)\r\nreturn 0;\r\nif ((serial_port_in(port, SCLSR) & (1 << s->overrun_bit))) {\r\nserial_port_out(port, SCLSR, 0);\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\ntty_flip_buffer_push(tport);\r\ndev_notice(port->dev, "overrun error\n");\r\ncopied++;\r\n}\r\nreturn copied;\r\n}\r\nstatic int sci_handle_breaks(struct uart_port *port)\r\n{\r\nint copied = 0;\r\nunsigned short status = serial_port_in(port, SCxSR);\r\nstruct tty_port *tport = &port->state->port;\r\nstruct sci_port *s = to_sci_port(port);\r\nif (uart_handle_break(port))\r\nreturn 0;\r\nif (!s->break_flag && status & SCxSR_BRK(port)) {\r\n#if defined(CONFIG_CPU_SH3)\r\ns->break_flag = 1;\r\n#endif\r\nport->icount.brk++;\r\nif (tty_insert_flip_char(tport, 0, TTY_BREAK))\r\ncopied++;\r\ndev_dbg(port->dev, "BREAK detected\n");\r\n}\r\nif (copied)\r\ntty_flip_buffer_push(tport);\r\ncopied += sci_handle_fifo_overrun(port);\r\nreturn copied;\r\n}\r\nstatic irqreturn_t sci_rx_interrupt(int irq, void *ptr)\r\n{\r\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\r\nstruct uart_port *port = ptr;\r\nstruct sci_port *s = to_sci_port(port);\r\nif (s->chan_rx) {\r\nu16 scr = serial_port_in(port, SCSCR);\r\nu16 ssr = serial_port_in(port, SCxSR);\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\r\ndisable_irq_nosync(irq);\r\nscr |= SCSCR_RDRQE;\r\n} else {\r\nscr &= ~SCSCR_RIE;\r\n}\r\nserial_port_out(port, SCSCR, scr);\r\nserial_port_out(port, SCxSR, ssr & ~(1 | SCxSR_RDxF(port)));\r\ndev_dbg(port->dev, "Rx IRQ %lu: setup t-out in %u jiffies\n",\r\njiffies, s->rx_timeout);\r\nmod_timer(&s->rx_timer, jiffies + s->rx_timeout);\r\nreturn IRQ_HANDLED;\r\n}\r\n#endif\r\nsci_receive_chars(ptr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sci_tx_interrupt(int irq, void *ptr)\r\n{\r\nstruct uart_port *port = ptr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nsci_transmit_chars(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sci_er_interrupt(int irq, void *ptr)\r\n{\r\nstruct uart_port *port = ptr;\r\nif (port->type == PORT_SCI) {\r\nif (sci_handle_errors(port)) {\r\nserial_port_in(port, SCxSR);\r\nserial_port_out(port, SCxSR, SCxSR_RDxF_CLEAR(port));\r\n}\r\n} else {\r\nsci_handle_fifo_overrun(port);\r\nsci_rx_interrupt(irq, ptr);\r\n}\r\nserial_port_out(port, SCxSR, SCxSR_ERROR_CLEAR(port));\r\nsci_tx_interrupt(irq, ptr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sci_br_interrupt(int irq, void *ptr)\r\n{\r\nstruct uart_port *port = ptr;\r\nsci_handle_breaks(port);\r\nserial_port_out(port, SCxSR, SCxSR_BREAK_CLEAR(port));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline unsigned long port_rx_irq_mask(struct uart_port *port)\r\n{\r\nreturn SCSCR_RIE | (to_sci_port(port)->cfg->scscr & SCSCR_REIE);\r\n}\r\nstatic irqreturn_t sci_mpxed_interrupt(int irq, void *ptr)\r\n{\r\nunsigned short ssr_status, scr_status, err_enabled;\r\nstruct uart_port *port = ptr;\r\nstruct sci_port *s = to_sci_port(port);\r\nirqreturn_t ret = IRQ_NONE;\r\nssr_status = serial_port_in(port, SCxSR);\r\nscr_status = serial_port_in(port, SCSCR);\r\nerr_enabled = scr_status & port_rx_irq_mask(port);\r\nif ((ssr_status & SCxSR_TDxE(port)) && (scr_status & SCSCR_TIE) &&\r\n!s->chan_tx)\r\nret = sci_tx_interrupt(irq, ptr);\r\nif (((ssr_status & SCxSR_RDxF(port)) || s->chan_rx) &&\r\n(scr_status & SCSCR_RIE))\r\nret = sci_rx_interrupt(irq, ptr);\r\nif ((ssr_status & SCxSR_ERRORS(port)) && err_enabled)\r\nret = sci_er_interrupt(irq, ptr);\r\nif ((ssr_status & SCxSR_BRK(port)) && err_enabled)\r\nret = sci_br_interrupt(irq, ptr);\r\nreturn ret;\r\n}\r\nstatic int sci_notifier(struct notifier_block *self,\r\nunsigned long phase, void *p)\r\n{\r\nstruct sci_port *sci_port;\r\nunsigned long flags;\r\nsci_port = container_of(self, struct sci_port, freq_transition);\r\nif (phase == CPUFREQ_POSTCHANGE) {\r\nstruct uart_port *port = &sci_port->port;\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->uartclk = clk_get_rate(sci_port->iclk);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int sci_request_irq(struct sci_port *port)\r\n{\r\nstruct uart_port *up = &port->port;\r\nint i, j, ret = 0;\r\nfor (i = j = 0; i < SCIx_NR_IRQS; i++, j++) {\r\nstruct sci_irq_desc *desc;\r\nint irq;\r\nif (SCIx_IRQ_IS_MUXED(port)) {\r\ni = SCIx_MUX_IRQ;\r\nirq = up->irq;\r\n} else {\r\nirq = port->irqs[i];\r\nif (unlikely(irq < 0))\r\ncontinue;\r\n}\r\ndesc = sci_irq_desc + i;\r\nport->irqstr[j] = kasprintf(GFP_KERNEL, "%s:%s",\r\ndev_name(up->dev), desc->desc);\r\nif (!port->irqstr[j]) {\r\ndev_err(up->dev, "Failed to allocate %s IRQ string\n",\r\ndesc->desc);\r\ngoto out_nomem;\r\n}\r\nret = request_irq(irq, desc->handler, up->irqflags,\r\nport->irqstr[j], port);\r\nif (unlikely(ret)) {\r\ndev_err(up->dev, "Can't allocate %s IRQ\n", desc->desc);\r\ngoto out_noirq;\r\n}\r\n}\r\nreturn 0;\r\nout_noirq:\r\nwhile (--i >= 0)\r\nfree_irq(port->irqs[i], port);\r\nout_nomem:\r\nwhile (--j >= 0)\r\nkfree(port->irqstr[j]);\r\nreturn ret;\r\n}\r\nstatic void sci_free_irq(struct sci_port *port)\r\n{\r\nint i;\r\nfor (i = 0; i < SCIx_NR_IRQS; i++) {\r\nint irq = port->irqs[i];\r\nif (unlikely(irq < 0))\r\ncontinue;\r\nfree_irq(port->irqs[i], port);\r\nkfree(port->irqstr[i]);\r\nif (SCIx_IRQ_IS_MUXED(port)) {\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic unsigned int sci_tx_empty(struct uart_port *port)\r\n{\r\nunsigned short status = serial_port_in(port, SCxSR);\r\nunsigned short in_tx_fifo = sci_txfill(port);\r\nreturn (status & SCxSR_TEND(port)) && !in_tx_fifo ? TIOCSER_TEMT : 0;\r\n}\r\nstatic void sci_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nif (mctrl & TIOCM_LOOP) {\r\nstruct plat_sci_reg *reg;\r\nreg = sci_getreg(port, SCFCR);\r\nif (reg->size)\r\nserial_port_out(port, SCFCR,\r\nserial_port_in(port, SCFCR) |\r\nSCFCR_LOOP);\r\n}\r\n}\r\nstatic unsigned int sci_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void sci_dma_tx_complete(void *arg)\r\n{\r\nstruct sci_port *s = arg;\r\nstruct uart_port *port = &s->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned long flags;\r\ndev_dbg(port->dev, "%s(%d)\n", __func__, port->line);\r\nspin_lock_irqsave(&port->lock, flags);\r\nxmit->tail += sg_dma_len(&s->sg_tx);\r\nxmit->tail &= UART_XMIT_SIZE - 1;\r\nport->icount.tx += sg_dma_len(&s->sg_tx);\r\nasync_tx_ack(s->desc_tx);\r\ns->desc_tx = NULL;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (!uart_circ_empty(xmit)) {\r\ns->cookie_tx = 0;\r\nschedule_work(&s->work_tx);\r\n} else {\r\ns->cookie_tx = -EINVAL;\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\r\nu16 ctrl = serial_port_in(port, SCSCR);\r\nserial_port_out(port, SCSCR, ctrl & ~SCSCR_TIE);\r\n}\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int sci_dma_rx_push(struct sci_port *s, size_t count)\r\n{\r\nstruct uart_port *port = &s->port;\r\nstruct tty_port *tport = &port->state->port;\r\nint i, active, room;\r\nroom = tty_buffer_request_room(tport, count);\r\nif (s->active_rx == s->cookie_rx[0]) {\r\nactive = 0;\r\n} else if (s->active_rx == s->cookie_rx[1]) {\r\nactive = 1;\r\n} else {\r\ndev_err(port->dev, "cookie %d not found!\n", s->active_rx);\r\nreturn 0;\r\n}\r\nif (room < count)\r\ndev_warn(port->dev, "Rx overrun: dropping %zu bytes\n",\r\ncount - room);\r\nif (!room)\r\nreturn room;\r\nfor (i = 0; i < room; i++)\r\ntty_insert_flip_char(tport, ((u8 *)sg_virt(&s->sg_rx[active]))[i],\r\nTTY_NORMAL);\r\nport->icount.rx += room;\r\nreturn room;\r\n}\r\nstatic void sci_dma_rx_complete(void *arg)\r\n{\r\nstruct sci_port *s = arg;\r\nstruct uart_port *port = &s->port;\r\nunsigned long flags;\r\nint count;\r\ndev_dbg(port->dev, "%s(%d) active #%d\n",\r\n__func__, port->line, s->active_rx);\r\nspin_lock_irqsave(&port->lock, flags);\r\ncount = sci_dma_rx_push(s, s->buf_len_rx);\r\nmod_timer(&s->rx_timer, jiffies + s->rx_timeout);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (count)\r\ntty_flip_buffer_push(&port->state->port);\r\nschedule_work(&s->work_rx);\r\n}\r\nstatic void sci_rx_dma_release(struct sci_port *s, bool enable_pio)\r\n{\r\nstruct dma_chan *chan = s->chan_rx;\r\nstruct uart_port *port = &s->port;\r\ns->chan_rx = NULL;\r\ns->cookie_rx[0] = s->cookie_rx[1] = -EINVAL;\r\ndma_release_channel(chan);\r\nif (sg_dma_address(&s->sg_rx[0]))\r\ndma_free_coherent(port->dev, s->buf_len_rx * 2,\r\nsg_virt(&s->sg_rx[0]), sg_dma_address(&s->sg_rx[0]));\r\nif (enable_pio)\r\nsci_start_rx(port);\r\n}\r\nstatic void sci_tx_dma_release(struct sci_port *s, bool enable_pio)\r\n{\r\nstruct dma_chan *chan = s->chan_tx;\r\nstruct uart_port *port = &s->port;\r\ns->chan_tx = NULL;\r\ns->cookie_tx = -EINVAL;\r\ndma_release_channel(chan);\r\nif (enable_pio)\r\nsci_start_tx(port);\r\n}\r\nstatic void sci_submit_rx(struct sci_port *s)\r\n{\r\nstruct dma_chan *chan = s->chan_rx;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nstruct scatterlist *sg = &s->sg_rx[i];\r\nstruct dma_async_tx_descriptor *desc;\r\ndesc = dmaengine_prep_slave_sg(chan,\r\nsg, 1, DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT);\r\nif (desc) {\r\ns->desc_rx[i] = desc;\r\ndesc->callback = sci_dma_rx_complete;\r\ndesc->callback_param = s;\r\ns->cookie_rx[i] = desc->tx_submit(desc);\r\n}\r\nif (!desc || s->cookie_rx[i] < 0) {\r\nif (i) {\r\nasync_tx_ack(s->desc_rx[0]);\r\ns->cookie_rx[0] = -EINVAL;\r\n}\r\nif (desc) {\r\nasync_tx_ack(desc);\r\ns->cookie_rx[i] = -EINVAL;\r\n}\r\ndev_warn(s->port.dev,\r\n"failed to re-start DMA, using PIO\n");\r\nsci_rx_dma_release(s, true);\r\nreturn;\r\n}\r\ndev_dbg(s->port.dev, "%s(): cookie %d to #%d\n",\r\n__func__, s->cookie_rx[i], i);\r\n}\r\ns->active_rx = s->cookie_rx[0];\r\ndma_async_issue_pending(chan);\r\n}\r\nstatic void work_fn_rx(struct work_struct *work)\r\n{\r\nstruct sci_port *s = container_of(work, struct sci_port, work_rx);\r\nstruct uart_port *port = &s->port;\r\nstruct dma_async_tx_descriptor *desc;\r\nint new;\r\nif (s->active_rx == s->cookie_rx[0]) {\r\nnew = 0;\r\n} else if (s->active_rx == s->cookie_rx[1]) {\r\nnew = 1;\r\n} else {\r\ndev_err(port->dev, "cookie %d not found!\n", s->active_rx);\r\nreturn;\r\n}\r\ndesc = s->desc_rx[new];\r\nif (dma_async_is_tx_complete(s->chan_rx, s->active_rx, NULL, NULL) !=\r\nDMA_COMPLETE) {\r\nstruct dma_chan *chan = s->chan_rx;\r\nstruct shdma_desc *sh_desc = container_of(desc,\r\nstruct shdma_desc, async_tx);\r\nunsigned long flags;\r\nint count;\r\nchan->device->device_control(chan, DMA_TERMINATE_ALL, 0);\r\ndev_dbg(port->dev, "Read %zu bytes with cookie %d\n",\r\nsh_desc->partial, sh_desc->cookie);\r\nspin_lock_irqsave(&port->lock, flags);\r\ncount = sci_dma_rx_push(s, sh_desc->partial);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (count)\r\ntty_flip_buffer_push(&port->state->port);\r\nsci_submit_rx(s);\r\nreturn;\r\n}\r\ns->cookie_rx[new] = desc->tx_submit(desc);\r\nif (s->cookie_rx[new] < 0) {\r\ndev_warn(port->dev, "Failed submitting Rx DMA descriptor\n");\r\nsci_rx_dma_release(s, true);\r\nreturn;\r\n}\r\ns->active_rx = s->cookie_rx[!new];\r\ndev_dbg(port->dev, "%s: cookie %d #%d, new active #%d\n",\r\n__func__, s->cookie_rx[new], new, s->active_rx);\r\n}\r\nstatic void work_fn_tx(struct work_struct *work)\r\n{\r\nstruct sci_port *s = container_of(work, struct sci_port, work_tx);\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct dma_chan *chan = s->chan_tx;\r\nstruct uart_port *port = &s->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct scatterlist *sg = &s->sg_tx;\r\nspin_lock_irq(&port->lock);\r\nsg->offset = xmit->tail & (UART_XMIT_SIZE - 1);\r\nsg_dma_address(sg) = (sg_dma_address(sg) & ~(UART_XMIT_SIZE - 1)) +\r\nsg->offset;\r\nsg_dma_len(sg) = min((int)CIRC_CNT(xmit->head, xmit->tail, UART_XMIT_SIZE),\r\nCIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE));\r\nspin_unlock_irq(&port->lock);\r\nBUG_ON(!sg_dma_len(sg));\r\ndesc = dmaengine_prep_slave_sg(chan,\r\nsg, s->sg_len_tx, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\nsci_tx_dma_release(s, true);\r\nreturn;\r\n}\r\ndma_sync_sg_for_device(port->dev, sg, 1, DMA_TO_DEVICE);\r\nspin_lock_irq(&port->lock);\r\ns->desc_tx = desc;\r\ndesc->callback = sci_dma_tx_complete;\r\ndesc->callback_param = s;\r\nspin_unlock_irq(&port->lock);\r\ns->cookie_tx = desc->tx_submit(desc);\r\nif (s->cookie_tx < 0) {\r\ndev_warn(port->dev, "Failed submitting Tx DMA descriptor\n");\r\nsci_tx_dma_release(s, true);\r\nreturn;\r\n}\r\ndev_dbg(port->dev, "%s: %p: %d...%d, cookie %d\n",\r\n__func__, xmit->buf, xmit->tail, xmit->head, s->cookie_tx);\r\ndma_async_issue_pending(chan);\r\n}\r\nstatic void sci_start_tx(struct uart_port *port)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nunsigned short ctrl;\r\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\r\nu16 new, scr = serial_port_in(port, SCSCR);\r\nif (s->chan_tx)\r\nnew = scr | SCSCR_TDRQE;\r\nelse\r\nnew = scr & ~SCSCR_TDRQE;\r\nif (new != scr)\r\nserial_port_out(port, SCSCR, new);\r\n}\r\nif (s->chan_tx && !uart_circ_empty(&s->port.state->xmit) &&\r\ns->cookie_tx < 0) {\r\ns->cookie_tx = 0;\r\nschedule_work(&s->work_tx);\r\n}\r\n#endif\r\nif (!s->chan_tx || port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\r\nctrl = serial_port_in(port, SCSCR);\r\nserial_port_out(port, SCSCR, ctrl | SCSCR_TIE);\r\n}\r\n}\r\nstatic void sci_stop_tx(struct uart_port *port)\r\n{\r\nunsigned short ctrl;\r\nctrl = serial_port_in(port, SCSCR);\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\r\nctrl &= ~SCSCR_TDRQE;\r\nctrl &= ~SCSCR_TIE;\r\nserial_port_out(port, SCSCR, ctrl);\r\n}\r\nstatic void sci_start_rx(struct uart_port *port)\r\n{\r\nunsigned short ctrl;\r\nctrl = serial_port_in(port, SCSCR) | port_rx_irq_mask(port);\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\r\nctrl &= ~SCSCR_RDRQE;\r\nserial_port_out(port, SCSCR, ctrl);\r\n}\r\nstatic void sci_stop_rx(struct uart_port *port)\r\n{\r\nunsigned short ctrl;\r\nctrl = serial_port_in(port, SCSCR);\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB)\r\nctrl &= ~SCSCR_RDRQE;\r\nctrl &= ~port_rx_irq_mask(port);\r\nserial_port_out(port, SCSCR, ctrl);\r\n}\r\nstatic void sci_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void sci_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nstruct plat_sci_reg *reg = sci_regmap[s->cfg->regtype] + SCSPTR;\r\nunsigned short scscr, scsptr;\r\nif (!reg->size) {\r\nreturn;\r\n}\r\nscsptr = serial_port_in(port, SCSPTR);\r\nscscr = serial_port_in(port, SCSCR);\r\nif (break_state == -1) {\r\nscsptr = (scsptr | SCSPTR_SPB2IO) & ~SCSPTR_SPB2DT;\r\nscscr &= ~SCSCR_TE;\r\n} else {\r\nscsptr = (scsptr | SCSPTR_SPB2DT) & ~SCSPTR_SPB2IO;\r\nscscr |= SCSCR_TE;\r\n}\r\nserial_port_out(port, SCSPTR, scsptr);\r\nserial_port_out(port, SCSCR, scscr);\r\n}\r\nstatic bool filter(struct dma_chan *chan, void *slave)\r\n{\r\nstruct sh_dmae_slave *param = slave;\r\ndev_dbg(chan->device->dev, "%s: slave ID %d\n",\r\n__func__, param->shdma_slave.slave_id);\r\nchan->private = &param->shdma_slave;\r\nreturn true;\r\n}\r\nstatic void rx_timer_fn(unsigned long arg)\r\n{\r\nstruct sci_port *s = (struct sci_port *)arg;\r\nstruct uart_port *port = &s->port;\r\nu16 scr = serial_port_in(port, SCSCR);\r\nif (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {\r\nscr &= ~SCSCR_RDRQE;\r\nenable_irq(s->irqs[SCIx_RXI_IRQ]);\r\n}\r\nserial_port_out(port, SCSCR, scr | SCSCR_RIE);\r\ndev_dbg(port->dev, "DMA Rx timed out\n");\r\nschedule_work(&s->work_rx);\r\n}\r\nstatic void sci_request_dma(struct uart_port *port)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nstruct sh_dmae_slave *param;\r\nstruct dma_chan *chan;\r\ndma_cap_mask_t mask;\r\nint nent;\r\ndev_dbg(port->dev, "%s: port %d\n", __func__, port->line);\r\nif (s->cfg->dma_slave_tx <= 0 || s->cfg->dma_slave_rx <= 0)\r\nreturn;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nparam = &s->param_tx;\r\nparam->shdma_slave.slave_id = s->cfg->dma_slave_tx;\r\ns->cookie_tx = -EINVAL;\r\nchan = dma_request_channel(mask, filter, param);\r\ndev_dbg(port->dev, "%s: TX: got channel %p\n", __func__, chan);\r\nif (chan) {\r\ns->chan_tx = chan;\r\nsg_init_table(&s->sg_tx, 1);\r\nBUG_ON((uintptr_t)port->state->xmit.buf & ~PAGE_MASK);\r\nsg_set_page(&s->sg_tx, virt_to_page(port->state->xmit.buf),\r\nUART_XMIT_SIZE,\r\n(uintptr_t)port->state->xmit.buf & ~PAGE_MASK);\r\nnent = dma_map_sg(port->dev, &s->sg_tx, 1, DMA_TO_DEVICE);\r\nif (!nent)\r\nsci_tx_dma_release(s, false);\r\nelse\r\ndev_dbg(port->dev, "%s: mapped %d@%p to %pad\n",\r\n__func__,\r\nsg_dma_len(&s->sg_tx), port->state->xmit.buf,\r\n&sg_dma_address(&s->sg_tx));\r\ns->sg_len_tx = nent;\r\nINIT_WORK(&s->work_tx, work_fn_tx);\r\n}\r\nparam = &s->param_rx;\r\nparam->shdma_slave.slave_id = s->cfg->dma_slave_rx;\r\nchan = dma_request_channel(mask, filter, param);\r\ndev_dbg(port->dev, "%s: RX: got channel %p\n", __func__, chan);\r\nif (chan) {\r\ndma_addr_t dma[2];\r\nvoid *buf[2];\r\nint i;\r\ns->chan_rx = chan;\r\ns->buf_len_rx = 2 * max(16, (int)port->fifosize);\r\nbuf[0] = dma_alloc_coherent(port->dev, s->buf_len_rx * 2,\r\n&dma[0], GFP_KERNEL);\r\nif (!buf[0]) {\r\ndev_warn(port->dev,\r\n"failed to allocate dma buffer, using PIO\n");\r\nsci_rx_dma_release(s, true);\r\nreturn;\r\n}\r\nbuf[1] = buf[0] + s->buf_len_rx;\r\ndma[1] = dma[0] + s->buf_len_rx;\r\nfor (i = 0; i < 2; i++) {\r\nstruct scatterlist *sg = &s->sg_rx[i];\r\nsg_init_table(sg, 1);\r\nsg_set_page(sg, virt_to_page(buf[i]), s->buf_len_rx,\r\n(uintptr_t)buf[i] & ~PAGE_MASK);\r\nsg_dma_address(sg) = dma[i];\r\n}\r\nINIT_WORK(&s->work_rx, work_fn_rx);\r\nsetup_timer(&s->rx_timer, rx_timer_fn, (unsigned long)s);\r\nsci_submit_rx(s);\r\n}\r\n}\r\nstatic void sci_free_dma(struct uart_port *port)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nif (s->chan_tx)\r\nsci_tx_dma_release(s, false);\r\nif (s->chan_rx)\r\nsci_rx_dma_release(s, false);\r\n}\r\nstatic inline void sci_request_dma(struct uart_port *port)\r\n{\r\n}\r\nstatic inline void sci_free_dma(struct uart_port *port)\r\n{\r\n}\r\nstatic int sci_startup(struct uart_port *port)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nunsigned long flags;\r\nint ret;\r\ndev_dbg(port->dev, "%s(%d)\n", __func__, port->line);\r\nret = sci_request_irq(s);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nsci_request_dma(port);\r\nspin_lock_irqsave(&port->lock, flags);\r\nsci_start_tx(port);\r\nsci_start_rx(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void sci_shutdown(struct uart_port *port)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nunsigned long flags;\r\ndev_dbg(port->dev, "%s(%d)\n", __func__, port->line);\r\nspin_lock_irqsave(&port->lock, flags);\r\nsci_stop_rx(port);\r\nsci_stop_tx(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nsci_free_dma(port);\r\nsci_free_irq(s);\r\n}\r\nstatic unsigned int sci_scbrr_calc(struct sci_port *s, unsigned int bps,\r\nunsigned long freq)\r\n{\r\nif (s->sampling_rate)\r\nreturn DIV_ROUND_CLOSEST(freq, s->sampling_rate * bps) - 1;\r\nWARN_ON(1);\r\nreturn ((freq + 16 * bps) / (32 * bps) - 1);\r\n}\r\nstatic void sci_baud_calc_hscif(unsigned int bps, unsigned long freq,\r\nint *brr, unsigned int *srr,\r\nunsigned int *cks)\r\n{\r\nint sr, c, br, err;\r\nint min_err = 1000;\r\nfor (sr = 8; sr <= 32; sr++) {\r\nfor (c = 0; c <= 3; c++) {\r\nbr = freq / (sr * (1 << (2 * c + 1)) * bps) - 1;\r\nif (br < 0 || br > 255)\r\ncontinue;\r\nerr = freq / ((br + 1) * bps * sr *\r\n(1 << (2 * c + 1)) / 1000) - 1000;\r\nif (min_err > err) {\r\nmin_err = err;\r\n*brr = br;\r\n*srr = sr - 1;\r\n*cks = c;\r\n}\r\n}\r\n}\r\nif (min_err == 1000) {\r\nWARN_ON(1);\r\n*brr = 255;\r\n*srr = 15;\r\n*cks = 0;\r\n}\r\n}\r\nstatic void sci_reset(struct uart_port *port)\r\n{\r\nstruct plat_sci_reg *reg;\r\nunsigned int status;\r\ndo {\r\nstatus = serial_port_in(port, SCxSR);\r\n} while (!(status & SCxSR_TEND(port)));\r\nserial_port_out(port, SCSCR, 0x00);\r\nreg = sci_getreg(port, SCFCR);\r\nif (reg->size)\r\nserial_port_out(port, SCFCR, SCFCR_RFRST | SCFCR_TFRST);\r\n}\r\nstatic void sci_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct sci_port *s = to_sci_port(port);\r\nstruct plat_sci_reg *reg;\r\nunsigned int baud, smr_val, max_baud, cks = 0;\r\nint t = -1;\r\nunsigned int srr = 15;\r\nmax_baud = port->uartclk ? port->uartclk / 16 : 115200;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, max_baud);\r\nif (likely(baud && port->uartclk)) {\r\nif (s->cfg->type == PORT_HSCIF) {\r\nsci_baud_calc_hscif(baud, port->uartclk, &t, &srr,\r\n&cks);\r\n} else {\r\nt = sci_scbrr_calc(s, baud, port->uartclk);\r\nfor (cks = 0; t >= 256 && cks <= 3; cks++)\r\nt >>= 2;\r\n}\r\n}\r\nsci_port_enable(s);\r\nsci_reset(port);\r\nsmr_val = serial_port_in(port, SCSMR) & 3;\r\nif ((termios->c_cflag & CSIZE) == CS7)\r\nsmr_val |= SCSMR_CHR;\r\nif (termios->c_cflag & PARENB)\r\nsmr_val |= SCSMR_PE;\r\nif (termios->c_cflag & PARODD)\r\nsmr_val |= SCSMR_PE | SCSMR_ODD;\r\nif (termios->c_cflag & CSTOPB)\r\nsmr_val |= SCSMR_STOP;\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\ndev_dbg(port->dev, "%s: SMR %x, cks %x, t %x, SCSCR %x\n",\r\n__func__, smr_val, cks, t, s->cfg->scscr);\r\nif (t >= 0) {\r\nserial_port_out(port, SCSMR, (smr_val & ~SCSMR_CKS) | cks);\r\nserial_port_out(port, SCBRR, t);\r\nreg = sci_getreg(port, HSSRR);\r\nif (reg->size)\r\nserial_port_out(port, HSSRR, srr | HSCIF_SRE);\r\nudelay((1000000+(baud-1)) / baud);\r\n} else\r\nserial_port_out(port, SCSMR, smr_val);\r\nsci_init_pins(port, termios->c_cflag);\r\nreg = sci_getreg(port, SCFCR);\r\nif (reg->size) {\r\nunsigned short ctrl = serial_port_in(port, SCFCR);\r\nif (s->cfg->capabilities & SCIx_HAVE_RTSCTS) {\r\nif (termios->c_cflag & CRTSCTS)\r\nctrl |= SCFCR_MCE;\r\nelse\r\nctrl &= ~SCFCR_MCE;\r\n}\r\nctrl &= ~(SCFCR_RFRST | SCFCR_TFRST);\r\nserial_port_out(port, SCFCR, ctrl);\r\n}\r\nserial_port_out(port, SCSCR, s->cfg->scscr);\r\n#ifdef CONFIG_SERIAL_SH_SCI_DMA\r\nif (s->chan_rx) {\r\ns->rx_timeout = (port->timeout - HZ / 50) * s->buf_len_rx * 3 /\r\nport->fifosize / 2;\r\ndev_dbg(port->dev, "DMA Rx t-out %ums, tty t-out %u jiffies\n",\r\ns->rx_timeout * 1000 / HZ, port->timeout);\r\nif (s->rx_timeout < msecs_to_jiffies(20))\r\ns->rx_timeout = msecs_to_jiffies(20);\r\n}\r\n#endif\r\nif ((termios->c_cflag & CREAD) != 0)\r\nsci_start_rx(port);\r\nsci_port_disable(s);\r\n}\r\nstatic void sci_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct sci_port *sci_port = to_sci_port(port);\r\nswitch (state) {\r\ncase UART_PM_STATE_OFF:\r\nsci_port_disable(sci_port);\r\nbreak;\r\ndefault:\r\nsci_port_enable(sci_port);\r\nbreak;\r\n}\r\n}\r\nstatic const char *sci_type(struct uart_port *port)\r\n{\r\nswitch (port->type) {\r\ncase PORT_IRDA:\r\nreturn "irda";\r\ncase PORT_SCI:\r\nreturn "sci";\r\ncase PORT_SCIF:\r\nreturn "scif";\r\ncase PORT_SCIFA:\r\nreturn "scifa";\r\ncase PORT_SCIFB:\r\nreturn "scifb";\r\ncase PORT_HSCIF:\r\nreturn "hscif";\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline unsigned long sci_port_size(struct uart_port *port)\r\n{\r\nif (port->type == PORT_HSCIF)\r\nreturn 96;\r\nelse\r\nreturn 64;\r\n}\r\nstatic int sci_remap_port(struct uart_port *port)\r\n{\r\nunsigned long size = sci_port_size(port);\r\nif (port->membase)\r\nreturn 0;\r\nif (port->flags & UPF_IOREMAP) {\r\nport->membase = ioremap_nocache(port->mapbase, size);\r\nif (unlikely(!port->membase)) {\r\ndev_err(port->dev, "can't remap port#%d\n", port->line);\r\nreturn -ENXIO;\r\n}\r\n} else {\r\nport->membase = (void __iomem *)(uintptr_t)port->mapbase;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sci_release_port(struct uart_port *port)\r\n{\r\nif (port->flags & UPF_IOREMAP) {\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nrelease_mem_region(port->mapbase, sci_port_size(port));\r\n}\r\nstatic int sci_request_port(struct uart_port *port)\r\n{\r\nunsigned long size = sci_port_size(port);\r\nstruct resource *res;\r\nint ret;\r\nres = request_mem_region(port->mapbase, size, dev_name(port->dev));\r\nif (unlikely(res == NULL))\r\nreturn -EBUSY;\r\nret = sci_remap_port(port);\r\nif (unlikely(ret != 0)) {\r\nrelease_resource(res);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sci_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nstruct sci_port *sport = to_sci_port(port);\r\nport->type = sport->cfg->type;\r\nsci_request_port(port);\r\n}\r\n}\r\nstatic int sci_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nif (ser->baud_base < 2400)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sci_init_single(struct platform_device *dev,\r\nstruct sci_port *sci_port, unsigned int index,\r\nstruct plat_sci_port *p, bool early)\r\n{\r\nstruct uart_port *port = &sci_port->port;\r\nconst struct resource *res;\r\nunsigned int sampling_rate;\r\nunsigned int i;\r\nint ret;\r\nsci_port->cfg = p;\r\nport->ops = &sci_uart_ops;\r\nport->iotype = UPIO_MEM;\r\nport->line = index;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (res == NULL)\r\nreturn -ENOMEM;\r\nport->mapbase = res->start;\r\nfor (i = 0; i < ARRAY_SIZE(sci_port->irqs); ++i)\r\nsci_port->irqs[i] = platform_get_irq(dev, i);\r\nif (sci_port->irqs[0] < 0)\r\nreturn -ENXIO;\r\nif (sci_port->irqs[1] < 0) {\r\nsci_port->irqs[1] = sci_port->irqs[0];\r\nsci_port->irqs[2] = sci_port->irqs[0];\r\nsci_port->irqs[3] = sci_port->irqs[0];\r\n}\r\nif (p->regtype == SCIx_PROBE_REGTYPE) {\r\nret = sci_probe_regmap(p);\r\nif (unlikely(ret))\r\nreturn ret;\r\n}\r\nswitch (p->type) {\r\ncase PORT_SCIFB:\r\nport->fifosize = 256;\r\nsci_port->overrun_bit = 9;\r\nsampling_rate = 16;\r\nbreak;\r\ncase PORT_HSCIF:\r\nport->fifosize = 128;\r\nsampling_rate = 0;\r\nsci_port->overrun_bit = 0;\r\nbreak;\r\ncase PORT_SCIFA:\r\nport->fifosize = 64;\r\nsci_port->overrun_bit = 9;\r\nsampling_rate = 16;\r\nbreak;\r\ncase PORT_SCIF:\r\nport->fifosize = 16;\r\nif (p->regtype == SCIx_SH7705_SCIF_REGTYPE) {\r\nsci_port->overrun_bit = 9;\r\nsampling_rate = 16;\r\n} else {\r\nsci_port->overrun_bit = 0;\r\nsampling_rate = 32;\r\n}\r\nbreak;\r\ndefault:\r\nport->fifosize = 1;\r\nsci_port->overrun_bit = 5;\r\nsampling_rate = 32;\r\nbreak;\r\n}\r\nsci_port->sampling_rate = p->sampling_rate ? p->sampling_rate\r\n: sampling_rate;\r\nif (!early) {\r\nsci_port->iclk = clk_get(&dev->dev, "sci_ick");\r\nif (IS_ERR(sci_port->iclk)) {\r\nsci_port->iclk = clk_get(&dev->dev, "peripheral_clk");\r\nif (IS_ERR(sci_port->iclk)) {\r\ndev_err(&dev->dev, "can't get iclk\n");\r\nreturn PTR_ERR(sci_port->iclk);\r\n}\r\n}\r\nsci_port->fclk = clk_get(&dev->dev, "sci_fck");\r\nif (IS_ERR(sci_port->fclk))\r\nsci_port->fclk = NULL;\r\nport->dev = &dev->dev;\r\npm_runtime_enable(&dev->dev);\r\n}\r\nsci_port->break_timer.data = (unsigned long)sci_port;\r\nsci_port->break_timer.function = sci_break_timer;\r\ninit_timer(&sci_port->break_timer);\r\nsci_port->error_mask = (p->type == PORT_SCI) ?\r\nSCI_DEFAULT_ERROR_MASK : SCIF_DEFAULT_ERROR_MASK;\r\nsci_port->error_mask |= 1 << sci_port->overrun_bit;\r\nport->type = p->type;\r\nport->flags = UPF_FIXED_PORT | p->flags;\r\nport->regshift = p->regshift;\r\nport->irq = sci_port->irqs[SCIx_RXI_IRQ];\r\nport->irqflags = 0;\r\nport->serial_in = sci_serial_in;\r\nport->serial_out = sci_serial_out;\r\nif (p->dma_slave_tx > 0 && p->dma_slave_rx > 0)\r\ndev_dbg(port->dev, "DMA tx %d, rx %d\n",\r\np->dma_slave_tx, p->dma_slave_rx);\r\nreturn 0;\r\n}\r\nstatic void sci_cleanup_single(struct sci_port *port)\r\n{\r\nclk_put(port->iclk);\r\nclk_put(port->fclk);\r\npm_runtime_disable(port->port.dev);\r\n}\r\nstatic void serial_console_putchar(struct uart_port *port, int ch)\r\n{\r\nsci_poll_put_char(port, ch);\r\n}\r\nstatic void serial_console_write(struct console *co, const char *s,\r\nunsigned count)\r\n{\r\nstruct sci_port *sci_port = &sci_ports[co->index];\r\nstruct uart_port *port = &sci_port->port;\r\nunsigned short bits, ctrl;\r\nunsigned long flags;\r\nint locked = 1;\r\nlocal_irq_save(flags);\r\nif (port->sysrq)\r\nlocked = 0;\r\nelse if (oops_in_progress)\r\nlocked = spin_trylock(&port->lock);\r\nelse\r\nspin_lock(&port->lock);\r\nctrl = serial_port_in(port, SCSCR);\r\nserial_port_out(port, SCSCR, sci_port->cfg->scscr);\r\nuart_console_write(port, s, count, serial_console_putchar);\r\nbits = SCxSR_TDxE(port) | SCxSR_TEND(port);\r\nwhile ((serial_port_in(port, SCxSR) & bits) != bits)\r\ncpu_relax();\r\nserial_port_out(port, SCSCR, ctrl);\r\nif (locked)\r\nspin_unlock(&port->lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int serial_console_setup(struct console *co, char *options)\r\n{\r\nstruct sci_port *sci_port;\r\nstruct uart_port *port;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint ret;\r\nif (co->index < 0 || co->index >= SCI_NPORTS)\r\nreturn -ENODEV;\r\nsci_port = &sci_ports[co->index];\r\nport = &sci_port->port;\r\nif (!port->ops)\r\nreturn -ENODEV;\r\nret = sci_remap_port(port);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int sci_probe_earlyprintk(struct platform_device *pdev)\r\n{\r\nstruct plat_sci_port *cfg = dev_get_platdata(&pdev->dev);\r\nif (early_serial_console.data)\r\nreturn -EEXIST;\r\nearly_serial_console.index = pdev->id;\r\nsci_init_single(pdev, &sci_ports[pdev->id], pdev->id, cfg, true);\r\nserial_console_setup(&early_serial_console, early_serial_buf);\r\nif (!strstr(early_serial_buf, "keep"))\r\nearly_serial_console.flags |= CON_BOOT;\r\nregister_console(&early_serial_console);\r\nreturn 0;\r\n}\r\nstatic inline int sci_probe_earlyprintk(struct platform_device *pdev)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int sci_remove(struct platform_device *dev)\r\n{\r\nstruct sci_port *port = platform_get_drvdata(dev);\r\ncpufreq_unregister_notifier(&port->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\nuart_remove_one_port(&sci_uart_driver, &port->port);\r\nsci_cleanup_single(port);\r\nreturn 0;\r\n}\r\nstatic struct plat_sci_port *\r\nsci_parse_dt(struct platform_device *pdev, unsigned int *dev_id)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nconst struct sci_port_info *info;\r\nstruct plat_sci_port *p;\r\nint id;\r\nif (!IS_ENABLED(CONFIG_OF) || !np)\r\nreturn NULL;\r\nmatch = of_match_node(of_sci_match, pdev->dev.of_node);\r\nif (!match)\r\nreturn NULL;\r\ninfo = match->data;\r\np = devm_kzalloc(&pdev->dev, sizeof(struct plat_sci_port), GFP_KERNEL);\r\nif (!p) {\r\ndev_err(&pdev->dev, "failed to allocate DT config data\n");\r\nreturn NULL;\r\n}\r\nid = of_alias_get_id(np, "serial");\r\nif (id < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id (%d)\n", id);\r\nreturn NULL;\r\n}\r\n*dev_id = id;\r\np->flags = UPF_IOREMAP | UPF_BOOT_AUTOCONF;\r\np->type = info->type;\r\np->regtype = info->regtype;\r\np->scscr = SCSCR_RE | SCSCR_TE;\r\nreturn p;\r\n}\r\nstatic int sci_probe_single(struct platform_device *dev,\r\nunsigned int index,\r\nstruct plat_sci_port *p,\r\nstruct sci_port *sciport)\r\n{\r\nint ret;\r\nif (unlikely(index >= SCI_NPORTS)) {\r\ndev_notice(&dev->dev, "Attempting to register port %d when only %d are available\n",\r\nindex+1, SCI_NPORTS);\r\ndev_notice(&dev->dev, "Consider bumping CONFIG_SERIAL_SH_SCI_NR_UARTS!\n");\r\nreturn -EINVAL;\r\n}\r\nret = sci_init_single(dev, sciport, index, p, false);\r\nif (ret)\r\nreturn ret;\r\nret = uart_add_one_port(&sci_uart_driver, &sciport->port);\r\nif (ret) {\r\nsci_cleanup_single(sciport);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sci_probe(struct platform_device *dev)\r\n{\r\nstruct plat_sci_port *p;\r\nstruct sci_port *sp;\r\nunsigned int dev_id;\r\nint ret;\r\nif (is_early_platform_device(dev))\r\nreturn sci_probe_earlyprintk(dev);\r\nif (dev->dev.of_node) {\r\np = sci_parse_dt(dev, &dev_id);\r\nif (p == NULL)\r\nreturn -EINVAL;\r\n} else {\r\np = dev->dev.platform_data;\r\nif (p == NULL) {\r\ndev_err(&dev->dev, "no platform data supplied\n");\r\nreturn -EINVAL;\r\n}\r\ndev_id = dev->id;\r\n}\r\nsp = &sci_ports[dev_id];\r\nplatform_set_drvdata(dev, sp);\r\nret = sci_probe_single(dev, dev_id, p, sp);\r\nif (ret)\r\nreturn ret;\r\nsp->freq_transition.notifier_call = sci_notifier;\r\nret = cpufreq_register_notifier(&sp->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\nif (unlikely(ret < 0)) {\r\nuart_remove_one_port(&sci_uart_driver, &sp->port);\r\nsci_cleanup_single(sp);\r\nreturn ret;\r\n}\r\n#ifdef CONFIG_SH_STANDARD_BIOS\r\nsh_bios_gdb_detach();\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int sci_suspend(struct device *dev)\r\n{\r\nstruct sci_port *sport = dev_get_drvdata(dev);\r\nif (sport)\r\nuart_suspend_port(&sci_uart_driver, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int sci_resume(struct device *dev)\r\n{\r\nstruct sci_port *sport = dev_get_drvdata(dev);\r\nif (sport)\r\nuart_resume_port(&sci_uart_driver, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int __init sci_init(void)\r\n{\r\nint ret;\r\npr_info("%s\n", banner);\r\nret = uart_register_driver(&sci_uart_driver);\r\nif (likely(ret == 0)) {\r\nret = platform_driver_register(&sci_driver);\r\nif (unlikely(ret))\r\nuart_unregister_driver(&sci_uart_driver);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit sci_exit(void)\r\n{\r\nplatform_driver_unregister(&sci_driver);\r\nuart_unregister_driver(&sci_uart_driver);\r\n}
