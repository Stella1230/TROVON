static void port_power(struct sl811 *sl811, int is_on)\r\n{\r\nstruct usb_hcd *hcd = sl811_to_hcd(sl811);\r\nif (is_on) {\r\nif (sl811->port1 & USB_PORT_STAT_POWER)\r\nreturn;\r\nsl811->port1 = USB_PORT_STAT_POWER;\r\nsl811->irq_enable = SL11H_INTMASK_INSRMV;\r\n} else {\r\nsl811->port1 = 0;\r\nsl811->irq_enable = 0;\r\nhcd->state = HC_STATE_HALT;\r\n}\r\nsl811->ctrl1 = 0;\r\nsl811_write(sl811, SL11H_IRQ_ENABLE, 0);\r\nsl811_write(sl811, SL11H_IRQ_STATUS, ~0);\r\nif (sl811->board && sl811->board->port_power) {\r\ndev_dbg(hcd->self.controller, "power %s\n",\r\nis_on ? "on" : "off");\r\nsl811->board->port_power(hcd->self.controller, is_on);\r\n}\r\nif (sl811->board && sl811->board->reset)\r\nsl811->board->reset(hcd->self.controller);\r\nelse {\r\nsl811_write(sl811, SL11H_CTLREG1, SL11H_CTL1MASK_SE0);\r\nmdelay(20);\r\n}\r\nsl811_write(sl811, SL11H_IRQ_ENABLE, 0);\r\nsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\r\nsl811_write(sl811, SL811HS_CTLREG2, SL811HS_CTL2_INIT);\r\nsl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);\r\n}\r\nstatic void setup_packet(\r\nstruct sl811 *sl811,\r\nstruct sl811h_ep *ep,\r\nstruct urb *urb,\r\nu8 bank,\r\nu8 control\r\n)\r\n{\r\nu8 addr;\r\nu8 len;\r\nvoid __iomem *data_reg;\r\naddr = SL811HS_PACKET_BUF(bank == 0);\r\nlen = sizeof(struct usb_ctrlrequest);\r\ndata_reg = sl811->data_reg;\r\nsl811_write_buf(sl811, addr, urb->setup_packet, len);\r\nsl811_write(sl811, bank + SL11H_BUFADDRREG, addr);\r\nwriteb(len, data_reg);\r\nwriteb(SL_SETUP , data_reg);\r\nwriteb(usb_pipedevice(urb->pipe), data_reg);\r\nsl811_write(sl811, bank + SL11H_HOSTCTLREG,\r\ncontrol | SL11H_HCTLMASK_OUT);\r\nep->length = 0;\r\nPACKET("SETUP qh%p\n", ep);\r\n}\r\nstatic void status_packet(\r\nstruct sl811 *sl811,\r\nstruct sl811h_ep *ep,\r\nstruct urb *urb,\r\nu8 bank,\r\nu8 control\r\n)\r\n{\r\nint do_out;\r\nvoid __iomem *data_reg;\r\ndo_out = urb->transfer_buffer_length && usb_pipein(urb->pipe);\r\ndata_reg = sl811->data_reg;\r\nsl811_write(sl811, bank + SL11H_BUFADDRREG, 0);\r\nwriteb(0, data_reg);\r\nwriteb((do_out ? SL_OUT : SL_IN) , data_reg);\r\nwriteb(usb_pipedevice(urb->pipe), data_reg);\r\ncontrol |= SL11H_HCTLMASK_TOGGLE;\r\nif (do_out)\r\ncontrol |= SL11H_HCTLMASK_OUT;\r\nsl811_write(sl811, bank + SL11H_HOSTCTLREG, control);\r\nep->length = 0;\r\nPACKET("STATUS%s/%s qh%p\n", ep->nak_count ? "/retry" : "",\r\ndo_out ? "out" : "in", ep);\r\n}\r\nstatic void in_packet(\r\nstruct sl811 *sl811,\r\nstruct sl811h_ep *ep,\r\nstruct urb *urb,\r\nu8 bank,\r\nu8 control\r\n)\r\n{\r\nu8 addr;\r\nu8 len;\r\nvoid __iomem *data_reg;\r\nlen = ep->maxpacket;\r\naddr = SL811HS_PACKET_BUF(bank == 0);\r\nif (!(control & SL11H_HCTLMASK_ISOCH)\r\n&& usb_gettoggle(urb->dev, ep->epnum, 0))\r\ncontrol |= SL11H_HCTLMASK_TOGGLE;\r\ndata_reg = sl811->data_reg;\r\nsl811_write(sl811, bank + SL11H_BUFADDRREG, addr);\r\nwriteb(len, data_reg);\r\nwriteb(SL_IN | ep->epnum, data_reg);\r\nwriteb(usb_pipedevice(urb->pipe), data_reg);\r\nsl811_write(sl811, bank + SL11H_HOSTCTLREG, control);\r\nep->length = min_t(u32, len,\r\nurb->transfer_buffer_length - urb->actual_length);\r\nPACKET("IN%s/%d qh%p len%d\n", ep->nak_count ? "/retry" : "",\r\n!!usb_gettoggle(urb->dev, ep->epnum, 0), ep, len);\r\n}\r\nstatic void out_packet(\r\nstruct sl811 *sl811,\r\nstruct sl811h_ep *ep,\r\nstruct urb *urb,\r\nu8 bank,\r\nu8 control\r\n)\r\n{\r\nvoid *buf;\r\nu8 addr;\r\nu8 len;\r\nvoid __iomem *data_reg;\r\nbuf = urb->transfer_buffer + urb->actual_length;\r\nprefetch(buf);\r\nlen = min_t(u32, ep->maxpacket,\r\nurb->transfer_buffer_length - urb->actual_length);\r\nif (!(control & SL11H_HCTLMASK_ISOCH)\r\n&& usb_gettoggle(urb->dev, ep->epnum, 1))\r\ncontrol |= SL11H_HCTLMASK_TOGGLE;\r\naddr = SL811HS_PACKET_BUF(bank == 0);\r\ndata_reg = sl811->data_reg;\r\nsl811_write_buf(sl811, addr, buf, len);\r\nsl811_write(sl811, bank + SL11H_BUFADDRREG, addr);\r\nwriteb(len, data_reg);\r\nwriteb(SL_OUT | ep->epnum, data_reg);\r\nwriteb(usb_pipedevice(urb->pipe), data_reg);\r\nsl811_write(sl811, bank + SL11H_HOSTCTLREG,\r\ncontrol | SL11H_HCTLMASK_OUT);\r\nep->length = len;\r\nPACKET("OUT%s/%d qh%p len%d\n", ep->nak_count ? "/retry" : "",\r\n!!usb_gettoggle(urb->dev, ep->epnum, 1), ep, len);\r\n}\r\nstatic inline void sofirq_on(struct sl811 *sl811)\r\n{\r\nif (sl811->irq_enable & SL11H_INTMASK_SOFINTR)\r\nreturn;\r\ndev_dbg(sl811_to_hcd(sl811)->self.controller, "sof irq on\n");\r\nsl811->irq_enable |= SL11H_INTMASK_SOFINTR;\r\n}\r\nstatic inline void sofirq_off(struct sl811 *sl811)\r\n{\r\nif (!(sl811->irq_enable & SL11H_INTMASK_SOFINTR))\r\nreturn;\r\ndev_dbg(sl811_to_hcd(sl811)->self.controller, "sof irq off\n");\r\nsl811->irq_enable &= ~SL11H_INTMASK_SOFINTR;\r\n}\r\nstatic struct sl811h_ep *start(struct sl811 *sl811, u8 bank)\r\n{\r\nstruct sl811h_ep *ep;\r\nstruct urb *urb;\r\nint fclock;\r\nu8 control;\r\nif (sl811->next_periodic) {\r\nep = sl811->next_periodic;\r\nsl811->next_periodic = ep->next;\r\n} else {\r\nif (sl811->next_async)\r\nep = sl811->next_async;\r\nelse if (!list_empty(&sl811->async))\r\nep = container_of(sl811->async.next,\r\nstruct sl811h_ep, schedule);\r\nelse {\r\nreturn NULL;\r\n}\r\n#ifdef USE_B\r\nif ((bank && sl811->active_b == ep) || sl811->active_a == ep)\r\nreturn NULL;\r\n#endif\r\nif (ep->schedule.next == &sl811->async)\r\nsl811->next_async = NULL;\r\nelse\r\nsl811->next_async = container_of(ep->schedule.next,\r\nstruct sl811h_ep, schedule);\r\n}\r\nif (unlikely(list_empty(&ep->hep->urb_list))) {\r\ndev_dbg(sl811_to_hcd(sl811)->self.controller,\r\n"empty %p queue?\n", ep);\r\nreturn NULL;\r\n}\r\nurb = container_of(ep->hep->urb_list.next, struct urb, urb_list);\r\ncontrol = ep->defctrl;\r\nfclock = sl811_read(sl811, SL11H_SOFTMRREG) << 6;\r\nfclock -= 100;\r\nif (urb->dev->speed == USB_SPEED_LOW) {\r\nif (control & SL11H_HCTLMASK_PREAMBLE) {\r\nfclock -= 800;\r\n}\r\nfclock -= ep->maxpacket << 8;\r\nif (fclock < 0) {\r\nif (ep->period)\r\nsl811->stat_overrun++;\r\nsofirq_on(sl811);\r\nreturn NULL;\r\n}\r\n} else {\r\nfclock -= 12000 / 19;\r\nif (fclock < 0) {\r\nif (ep->period)\r\nsl811->stat_overrun++;\r\ncontrol |= SL11H_HCTLMASK_AFTERSOF;\r\n} else if (ep->nak_count)\r\ncontrol |= SL11H_HCTLMASK_AFTERSOF;\r\n}\r\nswitch (ep->nextpid) {\r\ncase USB_PID_IN:\r\nin_packet(sl811, ep, urb, bank, control);\r\nbreak;\r\ncase USB_PID_OUT:\r\nout_packet(sl811, ep, urb, bank, control);\r\nbreak;\r\ncase USB_PID_SETUP:\r\nsetup_packet(sl811, ep, urb, bank, control);\r\nbreak;\r\ncase USB_PID_ACK:\r\nstatus_packet(sl811, ep, urb, bank, control);\r\nbreak;\r\ndefault:\r\ndev_dbg(sl811_to_hcd(sl811)->self.controller,\r\n"bad ep%p pid %02x\n", ep, ep->nextpid);\r\nep = NULL;\r\n}\r\nreturn ep;\r\n}\r\nstatic inline void start_transfer(struct sl811 *sl811)\r\n{\r\nif (sl811->port1 & USB_PORT_STAT_SUSPEND)\r\nreturn;\r\nif (sl811->active_a == NULL) {\r\nsl811->active_a = start(sl811, SL811_EP_A(SL811_HOST_BUF));\r\nif (sl811->active_a != NULL)\r\nsl811->jiffies_a = jiffies + MIN_JIFFIES;\r\n}\r\n#ifdef USE_B\r\nif (sl811->active_b == NULL) {\r\nsl811->active_b = start(sl811, SL811_EP_B(SL811_HOST_BUF));\r\nif (sl811->active_b != NULL)\r\nsl811->jiffies_b = jiffies + MIN_JIFFIES;\r\n}\r\n#endif\r\n}\r\nstatic void finish_request(\r\nstruct sl811 *sl811,\r\nstruct sl811h_ep *ep,\r\nstruct urb *urb,\r\nint status\r\n) __releases(sl811->lock) __acquires(sl811->lock)\r\n{\r\nunsigned i;\r\nif (usb_pipecontrol(urb->pipe))\r\nep->nextpid = USB_PID_SETUP;\r\nusb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);\r\nspin_unlock(&sl811->lock);\r\nusb_hcd_giveback_urb(sl811_to_hcd(sl811), urb, status);\r\nspin_lock(&sl811->lock);\r\nif (!list_empty(&ep->hep->urb_list))\r\nreturn;\r\nif (!list_empty(&ep->schedule)) {\r\nlist_del_init(&ep->schedule);\r\nif (ep == sl811->next_async)\r\nsl811->next_async = NULL;\r\nreturn;\r\n}\r\ndev_dbg(sl811_to_hcd(sl811)->self.controller,\r\n"deschedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);\r\nfor (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {\r\nstruct sl811h_ep *temp;\r\nstruct sl811h_ep **prev = &sl811->periodic[i];\r\nwhile (*prev && ((temp = *prev) != ep))\r\nprev = &temp->next;\r\nif (*prev)\r\n*prev = ep->next;\r\nsl811->load[i] -= ep->load;\r\n}\r\nep->branch = PERIODIC_SIZE;\r\nsl811->periodic_count--;\r\nsl811_to_hcd(sl811)->self.bandwidth_allocated\r\n-= ep->load / ep->period;\r\nif (ep == sl811->next_periodic)\r\nsl811->next_periodic = ep->next;\r\nif (sl811->periodic_count == 0)\r\nsofirq_off(sl811);\r\n}\r\nstatic void\r\ndone(struct sl811 *sl811, struct sl811h_ep *ep, u8 bank)\r\n{\r\nu8 status;\r\nstruct urb *urb;\r\nint urbstat = -EINPROGRESS;\r\nif (unlikely(!ep))\r\nreturn;\r\nstatus = sl811_read(sl811, bank + SL11H_PKTSTATREG);\r\nurb = container_of(ep->hep->urb_list.next, struct urb, urb_list);\r\nif (status & SL11H_STATMASK_NAK) {\r\nif (!ep->period)\r\nep->nak_count++;\r\nep->error_count = 0;\r\n} else if (status & SL11H_STATMASK_ACK) {\r\nstruct usb_device *udev = urb->dev;\r\nint len;\r\nunsigned char *buf;\r\nep->nak_count = ep->error_count = 0;\r\nswitch (ep->nextpid) {\r\ncase USB_PID_OUT:\r\nurb->actual_length += ep->length;\r\nusb_dotoggle(udev, ep->epnum, 1);\r\nif (urb->actual_length\r\n== urb->transfer_buffer_length) {\r\nif (usb_pipecontrol(urb->pipe))\r\nep->nextpid = USB_PID_ACK;\r\nelse if (ep->length < ep->maxpacket\r\n|| !(urb->transfer_flags\r\n& URB_ZERO_PACKET))\r\nurbstat = 0;\r\n}\r\nbreak;\r\ncase USB_PID_IN:\r\nbuf = urb->transfer_buffer + urb->actual_length;\r\nprefetchw(buf);\r\nlen = ep->maxpacket - sl811_read(sl811,\r\nbank + SL11H_XFERCNTREG);\r\nif (len > ep->length) {\r\nlen = ep->length;\r\nurbstat = -EOVERFLOW;\r\n}\r\nurb->actual_length += len;\r\nsl811_read_buf(sl811, SL811HS_PACKET_BUF(bank == 0),\r\nbuf, len);\r\nusb_dotoggle(udev, ep->epnum, 0);\r\nif (urbstat == -EINPROGRESS &&\r\n(len < ep->maxpacket ||\r\nurb->actual_length ==\r\nurb->transfer_buffer_length)) {\r\nif (usb_pipecontrol(urb->pipe))\r\nep->nextpid = USB_PID_ACK;\r\nelse\r\nurbstat = 0;\r\n}\r\nbreak;\r\ncase USB_PID_SETUP:\r\nif (urb->transfer_buffer_length == urb->actual_length)\r\nep->nextpid = USB_PID_ACK;\r\nelse if (usb_pipeout(urb->pipe)) {\r\nusb_settoggle(udev, 0, 1, 1);\r\nep->nextpid = USB_PID_OUT;\r\n} else {\r\nusb_settoggle(udev, 0, 0, 1);\r\nep->nextpid = USB_PID_IN;\r\n}\r\nbreak;\r\ncase USB_PID_ACK:\r\nurbstat = 0;\r\nbreak;\r\n}\r\n} else if (status & SL11H_STATMASK_STALL) {\r\nPACKET("...STALL_%02x qh%p\n", bank, ep);\r\nep->nak_count = ep->error_count = 0;\r\nurbstat = -EPIPE;\r\n} else if (++ep->error_count >= 3) {\r\nif (status & SL11H_STATMASK_TMOUT)\r\nurbstat = -ETIME;\r\nelse if (status & SL11H_STATMASK_OVF)\r\nurbstat = -EOVERFLOW;\r\nelse\r\nurbstat = -EPROTO;\r\nep->error_count = 0;\r\nPACKET("...3STRIKES_%02x %02x qh%p stat %d\n",\r\nbank, status, ep, urbstat);\r\n}\r\nif (urbstat != -EINPROGRESS || urb->unlinked)\r\nfinish_request(sl811, ep, urb, urbstat);\r\n}\r\nstatic inline u8 checkdone(struct sl811 *sl811)\r\n{\r\nu8 ctl;\r\nu8 irqstat = 0;\r\nif (sl811->active_a && time_before_eq(sl811->jiffies_a, jiffies)) {\r\nctl = sl811_read(sl811, SL811_EP_A(SL11H_HOSTCTLREG));\r\nif (ctl & SL11H_HCTLMASK_ARM)\r\nsl811_write(sl811, SL811_EP_A(SL11H_HOSTCTLREG), 0);\r\ndev_dbg(sl811_to_hcd(sl811)->self.controller,\r\n"%s DONE_A: ctrl %02x sts %02x\n",\r\n(ctl & SL11H_HCTLMASK_ARM) ? "timeout" : "lost",\r\nctl,\r\nsl811_read(sl811, SL811_EP_A(SL11H_PKTSTATREG)));\r\nirqstat |= SL11H_INTMASK_DONE_A;\r\n}\r\n#ifdef USE_B\r\nif (sl811->active_b && time_before_eq(sl811->jiffies_b, jiffies)) {\r\nctl = sl811_read(sl811, SL811_EP_B(SL11H_HOSTCTLREG));\r\nif (ctl & SL11H_HCTLMASK_ARM)\r\nsl811_write(sl811, SL811_EP_B(SL11H_HOSTCTLREG), 0);\r\ndev_dbg(sl811_to_hcd(sl811)->self.controller,\r\n"%s DONE_B: ctrl %02x sts %02x\n",\r\n(ctl & SL11H_HCTLMASK_ARM) ? "timeout" : "lost",\r\nctl,\r\nsl811_read(sl811, SL811_EP_B(SL11H_PKTSTATREG)));\r\nirqstat |= SL11H_INTMASK_DONE_A;\r\n}\r\n#endif\r\nreturn irqstat;\r\n}\r\nstatic irqreturn_t sl811h_irq(struct usb_hcd *hcd)\r\n{\r\nstruct sl811 *sl811 = hcd_to_sl811(hcd);\r\nu8 irqstat;\r\nirqreturn_t ret = IRQ_NONE;\r\nunsigned retries = 5;\r\nspin_lock(&sl811->lock);\r\nretry:\r\nirqstat = sl811_read(sl811, SL11H_IRQ_STATUS) & ~SL11H_INTMASK_DP;\r\nif (irqstat) {\r\nsl811_write(sl811, SL11H_IRQ_STATUS, irqstat);\r\nirqstat &= sl811->irq_enable;\r\n}\r\n#ifdef QUIRK2\r\nif (irqstat == 0) {\r\nirqstat = checkdone(sl811);\r\nif (irqstat)\r\nsl811->stat_lost++;\r\n}\r\n#endif\r\nif (irqstat & SL11H_INTMASK_DONE_A) {\r\ndone(sl811, sl811->active_a, SL811_EP_A(SL811_HOST_BUF));\r\nsl811->active_a = NULL;\r\nsl811->stat_a++;\r\n}\r\n#ifdef USE_B\r\nif (irqstat & SL11H_INTMASK_DONE_B) {\r\ndone(sl811, sl811->active_b, SL811_EP_B(SL811_HOST_BUF));\r\nsl811->active_b = NULL;\r\nsl811->stat_b++;\r\n}\r\n#endif\r\nif (irqstat & SL11H_INTMASK_SOFINTR) {\r\nunsigned index;\r\nindex = sl811->frame++ % (PERIODIC_SIZE - 1);\r\nsl811->stat_sof++;\r\nif (sl811->next_periodic) {\r\nsl811->stat_overrun++;\r\n}\r\nif (sl811->periodic[index])\r\nsl811->next_periodic = sl811->periodic[index];\r\n}\r\nif (irqstat & SL11H_INTMASK_INSRMV) {\r\nsl811->stat_insrmv++;\r\nsl811->stat_wake = 0;\r\nsl811->stat_sof = 0;\r\nsl811->stat_a = 0;\r\nsl811->stat_b = 0;\r\nsl811->stat_lost = 0;\r\nsl811->ctrl1 = 0;\r\nsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\r\nsl811->irq_enable = SL11H_INTMASK_INSRMV;\r\nsl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);\r\nif (sl811->active_a) {\r\nsl811_write(sl811, SL811_EP_A(SL11H_HOSTCTLREG), 0);\r\nfinish_request(sl811, sl811->active_a,\r\ncontainer_of(sl811->active_a\r\n->hep->urb_list.next,\r\nstruct urb, urb_list),\r\n-ESHUTDOWN);\r\nsl811->active_a = NULL;\r\n}\r\n#ifdef USE_B\r\nif (sl811->active_b) {\r\nsl811_write(sl811, SL811_EP_B(SL11H_HOSTCTLREG), 0);\r\nfinish_request(sl811, sl811->active_b,\r\ncontainer_of(sl811->active_b\r\n->hep->urb_list.next,\r\nstruct urb, urb_list),\r\nNULL, -ESHUTDOWN);\r\nsl811->active_b = NULL;\r\n}\r\n#endif\r\nif (irqstat & SL11H_INTMASK_RD)\r\nsl811->port1 &= ~USB_PORT_STAT_CONNECTION;\r\nelse\r\nsl811->port1 |= USB_PORT_STAT_CONNECTION;\r\nsl811->port1 |= USB_PORT_STAT_C_CONNECTION << 16;\r\n} else if (irqstat & SL11H_INTMASK_RD) {\r\nif (sl811->port1 & USB_PORT_STAT_SUSPEND) {\r\ndev_dbg(hcd->self.controller, "wakeup\n");\r\nsl811->port1 |= USB_PORT_STAT_C_SUSPEND << 16;\r\nsl811->stat_wake++;\r\n} else\r\nirqstat &= ~SL11H_INTMASK_RD;\r\n}\r\nif (irqstat) {\r\nif (sl811->port1 & USB_PORT_STAT_ENABLE)\r\nstart_transfer(sl811);\r\nret = IRQ_HANDLED;\r\nif (retries--)\r\ngoto retry;\r\n}\r\nif (sl811->periodic_count == 0 && list_empty(&sl811->async))\r\nsofirq_off(sl811);\r\nsl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);\r\nspin_unlock(&sl811->lock);\r\nreturn ret;\r\n}\r\nstatic int balance(struct sl811 *sl811, u16 period, u16 load)\r\n{\r\nint i, branch = -ENOSPC;\r\nfor (i = 0; i < period ; i++) {\r\nif (branch < 0 || sl811->load[branch] > sl811->load[i]) {\r\nint j;\r\nfor (j = i; j < PERIODIC_SIZE; j += period) {\r\nif ((sl811->load[j] + load)\r\n> MAX_PERIODIC_LOAD)\r\nbreak;\r\n}\r\nif (j < PERIODIC_SIZE)\r\ncontinue;\r\nbranch = i;\r\n}\r\n}\r\nreturn branch;\r\n}\r\nstatic int sl811h_urb_enqueue(\r\nstruct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mem_flags\r\n) {\r\nstruct sl811 *sl811 = hcd_to_sl811(hcd);\r\nstruct usb_device *udev = urb->dev;\r\nunsigned int pipe = urb->pipe;\r\nint is_out = !usb_pipein(pipe);\r\nint type = usb_pipetype(pipe);\r\nint epnum = usb_pipeendpoint(pipe);\r\nstruct sl811h_ep *ep = NULL;\r\nunsigned long flags;\r\nint i;\r\nint retval;\r\nstruct usb_host_endpoint *hep = urb->ep;\r\n#ifndef CONFIG_USB_SL811_HCD_ISO\r\nif (type == PIPE_ISOCHRONOUS)\r\nreturn -ENOSPC;\r\n#endif\r\nif (!hep->hcpriv) {\r\nep = kzalloc(sizeof *ep, mem_flags);\r\nif (ep == NULL)\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&sl811->lock, flags);\r\nif (!(sl811->port1 & USB_PORT_STAT_ENABLE)\r\n|| !HC_IS_RUNNING(hcd->state)) {\r\nretval = -ENODEV;\r\nkfree(ep);\r\ngoto fail_not_linked;\r\n}\r\nretval = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (retval) {\r\nkfree(ep);\r\ngoto fail_not_linked;\r\n}\r\nif (hep->hcpriv) {\r\nkfree(ep);\r\nep = hep->hcpriv;\r\n} else if (!ep) {\r\nretval = -ENOMEM;\r\ngoto fail;\r\n} else {\r\nINIT_LIST_HEAD(&ep->schedule);\r\nep->udev = udev;\r\nep->epnum = epnum;\r\nep->maxpacket = usb_maxpacket(udev, urb->pipe, is_out);\r\nep->defctrl = SL11H_HCTLMASK_ARM | SL11H_HCTLMASK_ENABLE;\r\nusb_settoggle(udev, epnum, is_out, 0);\r\nif (type == PIPE_CONTROL)\r\nep->nextpid = USB_PID_SETUP;\r\nelse if (is_out)\r\nep->nextpid = USB_PID_OUT;\r\nelse\r\nep->nextpid = USB_PID_IN;\r\nif (ep->maxpacket > H_MAXPACKET) {\r\ndev_dbg(hcd->self.controller,\r\n"dev %d ep%d maxpacket %d\n", udev->devnum,\r\nepnum, ep->maxpacket);\r\nretval = -EINVAL;\r\nkfree(ep);\r\ngoto fail;\r\n}\r\nif (udev->speed == USB_SPEED_LOW) {\r\nif (!(sl811->ctrl1 & SL11H_CTL1MASK_LSPD))\r\nep->defctrl |= SL11H_HCTLMASK_PREAMBLE;\r\n}\r\nswitch (type) {\r\ncase PIPE_ISOCHRONOUS:\r\ncase PIPE_INTERRUPT:\r\nif (urb->interval > PERIODIC_SIZE)\r\nurb->interval = PERIODIC_SIZE;\r\nep->period = urb->interval;\r\nep->branch = PERIODIC_SIZE;\r\nif (type == PIPE_ISOCHRONOUS)\r\nep->defctrl |= SL11H_HCTLMASK_ISOCH;\r\nep->load = usb_calc_bus_time(udev->speed, !is_out,\r\n(type == PIPE_ISOCHRONOUS),\r\nusb_maxpacket(udev, pipe, is_out))\r\n/ 1000;\r\nbreak;\r\n}\r\nep->hep = hep;\r\nhep->hcpriv = ep;\r\n}\r\nswitch (type) {\r\ncase PIPE_CONTROL:\r\ncase PIPE_BULK:\r\nif (list_empty(&ep->schedule))\r\nlist_add_tail(&ep->schedule, &sl811->async);\r\nbreak;\r\ncase PIPE_ISOCHRONOUS:\r\ncase PIPE_INTERRUPT:\r\nurb->interval = ep->period;\r\nif (ep->branch < PERIODIC_SIZE) {\r\nurb->start_frame = (sl811->frame & (PERIODIC_SIZE - 1))\r\n+ ep->branch;\r\nbreak;\r\n}\r\nretval = balance(sl811, ep->period, ep->load);\r\nif (retval < 0)\r\ngoto fail;\r\nep->branch = retval;\r\nretval = 0;\r\nurb->start_frame = (sl811->frame & (PERIODIC_SIZE - 1))\r\n+ ep->branch;\r\ndev_dbg(hcd->self.controller, "schedule qh%d/%p branch %d\n",\r\nep->period, ep, ep->branch);\r\nfor (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {\r\nstruct sl811h_ep **prev = &sl811->periodic[i];\r\nstruct sl811h_ep *here = *prev;\r\nwhile (here && ep != here) {\r\nif (ep->period > here->period)\r\nbreak;\r\nprev = &here->next;\r\nhere = *prev;\r\n}\r\nif (ep != here) {\r\nep->next = here;\r\n*prev = ep;\r\n}\r\nsl811->load[i] += ep->load;\r\n}\r\nsl811->periodic_count++;\r\nhcd->self.bandwidth_allocated += ep->load / ep->period;\r\nsofirq_on(sl811);\r\n}\r\nurb->hcpriv = hep;\r\nstart_transfer(sl811);\r\nsl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);\r\nfail:\r\nif (retval)\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nfail_not_linked:\r\nspin_unlock_irqrestore(&sl811->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int sl811h_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct sl811 *sl811 = hcd_to_sl811(hcd);\r\nstruct usb_host_endpoint *hep;\r\nunsigned long flags;\r\nstruct sl811h_ep *ep;\r\nint retval;\r\nspin_lock_irqsave(&sl811->lock, flags);\r\nretval = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (retval)\r\ngoto fail;\r\nhep = urb->hcpriv;\r\nep = hep->hcpriv;\r\nif (ep) {\r\nif (ep->hep->urb_list.next != &urb->urb_list) {\r\n} else if (sl811->active_a == ep) {\r\nif (time_before_eq(sl811->jiffies_a, jiffies)) {\r\ndev_dbg(hcd->self.controller,\r\n"giveup on DONE_A: ctrl %02x sts %02x\n",\r\nsl811_read(sl811,\r\nSL811_EP_A(SL11H_HOSTCTLREG)),\r\nsl811_read(sl811,\r\nSL811_EP_A(SL11H_PKTSTATREG)));\r\nsl811_write(sl811, SL811_EP_A(SL11H_HOSTCTLREG),\r\n0);\r\nsl811->active_a = NULL;\r\n} else\r\nurb = NULL;\r\n#ifdef USE_B\r\n} else if (sl811->active_b == ep) {\r\nif (time_before_eq(sl811->jiffies_a, jiffies)) {\r\ndev_dbg(hcd->self.controller,\r\n"giveup on DONE_B: ctrl %02x sts %02x\n",\r\nsl811_read(sl811,\r\nSL811_EP_B(SL11H_HOSTCTLREG)),\r\nsl811_read(sl811,\r\nSL811_EP_B(SL11H_PKTSTATREG)));\r\nsl811_write(sl811, SL811_EP_B(SL11H_HOSTCTLREG),\r\n0);\r\nsl811->active_b = NULL;\r\n} else\r\nurb = NULL;\r\n#endif\r\n} else {\r\n}\r\nif (urb)\r\nfinish_request(sl811, ep, urb, 0);\r\nelse\r\ndev_dbg(sl811_to_hcd(sl811)->self.controller,\r\n"dequeue, urb %p active %s; wait4irq\n", urb,\r\n(sl811->active_a == ep) ? "A" : "B");\r\n} else\r\nretval = -EINVAL;\r\nfail:\r\nspin_unlock_irqrestore(&sl811->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void\r\nsl811h_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *hep)\r\n{\r\nstruct sl811h_ep *ep = hep->hcpriv;\r\nif (!ep)\r\nreturn;\r\nif (!list_empty(&hep->urb_list))\r\nmsleep(3);\r\nif (!list_empty(&hep->urb_list))\r\ndev_warn(hcd->self.controller, "ep %p not empty?\n", ep);\r\nkfree(ep);\r\nhep->hcpriv = NULL;\r\n}\r\nstatic int\r\nsl811h_get_frame(struct usb_hcd *hcd)\r\n{\r\nstruct sl811 *sl811 = hcd_to_sl811(hcd);\r\nreturn sl811->frame;\r\n}\r\nstatic int\r\nsl811h_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct sl811 *sl811 = hcd_to_sl811(hcd);\r\n#ifdef QUIRK3\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (!timer_pending(&sl811->timer)) {\r\nif (sl811h_irq( hcd) != IRQ_NONE)\r\nsl811->stat_lost++;\r\n}\r\nlocal_irq_restore(flags);\r\n#endif\r\nif (!(sl811->port1 & (0xffff << 16)))\r\nreturn 0;\r\n*buf = (1 << 1);\r\nreturn 1;\r\n}\r\nstatic void\r\nsl811h_hub_descriptor (\r\nstruct sl811 *sl811,\r\nstruct usb_hub_descriptor *desc\r\n) {\r\nu16 temp = 0;\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = 1;\r\ndesc->bDescLength = 9;\r\ndesc->bPwrOn2PwrGood = 0;\r\nif (sl811->board && sl811->board->port_power) {\r\ndesc->bPwrOn2PwrGood = sl811->board->potpg;\r\nif (!desc->bPwrOn2PwrGood)\r\ndesc->bPwrOn2PwrGood = 10;\r\ntemp = 0x0001;\r\n} else\r\ntemp = 0x0002;\r\ntemp |= 0x0010;\r\ndesc->wHubCharacteristics = cpu_to_le16(temp);\r\ndesc->u.hs.DeviceRemovable[0] = 0 << 1;\r\ndesc->u.hs.DeviceRemovable[1] = ~0;\r\n}\r\nstatic void\r\nsl811h_timer(unsigned long _sl811)\r\n{\r\nstruct sl811 *sl811 = (void *) _sl811;\r\nunsigned long flags;\r\nu8 irqstat;\r\nu8 signaling = sl811->ctrl1 & SL11H_CTL1MASK_FORCE;\r\nconst u32 mask = USB_PORT_STAT_CONNECTION\r\n| USB_PORT_STAT_ENABLE\r\n| USB_PORT_STAT_LOW_SPEED;\r\nspin_lock_irqsave(&sl811->lock, flags);\r\nsl811->ctrl1 &= ~SL11H_CTL1MASK_FORCE;\r\nsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\r\nudelay(3);\r\nirqstat = sl811_read(sl811, SL11H_IRQ_STATUS);\r\nswitch (signaling) {\r\ncase SL11H_CTL1MASK_SE0:\r\ndev_dbg(sl811_to_hcd(sl811)->self.controller, "end reset\n");\r\nsl811->port1 = (USB_PORT_STAT_C_RESET << 16)\r\n| USB_PORT_STAT_POWER;\r\nsl811->ctrl1 = 0;\r\nif (irqstat & SL11H_INTMASK_INSRMV)\r\nirqstat &= ~SL11H_INTMASK_RD;\r\nbreak;\r\ncase SL11H_CTL1MASK_K:\r\ndev_dbg(sl811_to_hcd(sl811)->self.controller, "end resume\n");\r\nsl811->port1 &= ~USB_PORT_STAT_SUSPEND;\r\nbreak;\r\ndefault:\r\ndev_dbg(sl811_to_hcd(sl811)->self.controller,\r\n"odd timer signaling: %02x\n", signaling);\r\nbreak;\r\n}\r\nsl811_write(sl811, SL11H_IRQ_STATUS, irqstat);\r\nif (irqstat & SL11H_INTMASK_RD) {\r\nif (sl811->port1 & USB_PORT_STAT_CONNECTION)\r\nsl811->port1 |= (USB_PORT_STAT_C_CONNECTION << 16)\r\n| (USB_PORT_STAT_C_ENABLE << 16);\r\nsl811->port1 &= ~mask;\r\nsl811->irq_enable = SL11H_INTMASK_INSRMV;\r\n} else {\r\nsl811->port1 |= mask;\r\nif (irqstat & SL11H_INTMASK_DP)\r\nsl811->port1 &= ~USB_PORT_STAT_LOW_SPEED;\r\nsl811->irq_enable = SL11H_INTMASK_INSRMV | SL11H_INTMASK_RD;\r\n}\r\nif (sl811->port1 & USB_PORT_STAT_CONNECTION) {\r\nu8 ctrl2 = SL811HS_CTL2_INIT;\r\nsl811->irq_enable |= SL11H_INTMASK_DONE_A;\r\n#ifdef USE_B\r\nsl811->irq_enable |= SL11H_INTMASK_DONE_B;\r\n#endif\r\nif (sl811->port1 & USB_PORT_STAT_LOW_SPEED) {\r\nsl811->ctrl1 |= SL11H_CTL1MASK_LSPD;\r\nctrl2 |= SL811HS_CTL2MASK_DSWAP;\r\n}\r\nsl811->ctrl1 |= SL11H_CTL1MASK_SOF_ENA;\r\nsl811_write(sl811, SL11H_SOFLOWREG, 0xe0);\r\nsl811_write(sl811, SL811HS_CTLREG2, ctrl2);\r\nsl811_write(sl811, SL811_EP_A(SL11H_BUFLNTHREG), 0);\r\nwriteb(SL_SOF, sl811->data_reg);\r\nwriteb(0, sl811->data_reg);\r\nsl811_write(sl811, SL811_EP_A(SL11H_HOSTCTLREG),\r\nSL11H_HCTLMASK_ARM);\r\n} else {\r\nsl811->ctrl1 = 0;\r\n}\r\nsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\r\nsl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);\r\nspin_unlock_irqrestore(&sl811->lock, flags);\r\n}\r\nstatic int\r\nsl811h_hub_control(\r\nstruct usb_hcd *hcd,\r\nu16 typeReq,\r\nu16 wValue,\r\nu16 wIndex,\r\nchar *buf,\r\nu16 wLength\r\n) {\r\nstruct sl811 *sl811 = hcd_to_sl811(hcd);\r\nint retval = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sl811->lock, flags);\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\ncase SetHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\ncase C_HUB_LOCAL_POWER:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nif (wIndex != 1 || wLength != 0)\r\ngoto error;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nsl811->port1 &= USB_PORT_STAT_POWER;\r\nsl811->ctrl1 = 0;\r\nsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\r\nsl811->irq_enable = SL11H_INTMASK_INSRMV;\r\nsl811_write(sl811, SL11H_IRQ_ENABLE,\r\nsl811->irq_enable);\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (!(sl811->port1 & USB_PORT_STAT_SUSPEND))\r\nbreak;\r\ndev_dbg(hcd->self.controller, "start resume...\n");\r\nsl811->irq_enable = 0;\r\nsl811_write(sl811, SL11H_IRQ_ENABLE,\r\nsl811->irq_enable);\r\nsl811->ctrl1 |= SL11H_CTL1MASK_K;\r\nsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\r\nmod_timer(&sl811->timer, jiffies\r\n+ msecs_to_jiffies(20));\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nport_power(sl811, 0);\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ncase USB_PORT_FEAT_C_RESET:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nsl811->port1 &= ~(1 << wValue);\r\nbreak;\r\ncase GetHubDescriptor:\r\nsl811h_hub_descriptor(sl811, (struct usb_hub_descriptor *) buf);\r\nbreak;\r\ncase GetHubStatus:\r\nput_unaligned_le32(0, buf);\r\nbreak;\r\ncase GetPortStatus:\r\nif (wIndex != 1)\r\ngoto error;\r\nput_unaligned_le32(sl811->port1, buf);\r\n#ifndef VERBOSE\r\nif (*(u16*)(buf+2))\r\n#endif\r\ndev_dbg(hcd->self.controller, "GetPortStatus %08x\n",\r\nsl811->port1);\r\nbreak;\r\ncase SetPortFeature:\r\nif (wIndex != 1 || wLength != 0)\r\ngoto error;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (sl811->port1 & USB_PORT_STAT_RESET)\r\ngoto error;\r\nif (!(sl811->port1 & USB_PORT_STAT_ENABLE))\r\ngoto error;\r\ndev_dbg(hcd->self.controller,"suspend...\n");\r\nsl811->ctrl1 &= ~SL11H_CTL1MASK_SOF_ENA;\r\nsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nport_power(sl811, 1);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nif (sl811->port1 & USB_PORT_STAT_SUSPEND)\r\ngoto error;\r\nif (!(sl811->port1 & USB_PORT_STAT_POWER))\r\nbreak;\r\nsl811->irq_enable = 0;\r\nsl811_write(sl811, SL11H_IRQ_ENABLE,\r\nsl811->irq_enable);\r\nsl811->ctrl1 = SL11H_CTL1MASK_SE0;\r\nsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\r\nsl811->port1 |= USB_PORT_STAT_RESET;\r\nmod_timer(&sl811->timer, jiffies\r\n+ msecs_to_jiffies(50));\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nsl811->port1 |= 1 << wValue;\r\nbreak;\r\ndefault:\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nspin_unlock_irqrestore(&sl811->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int\r\nsl811h_bus_suspend(struct usb_hcd *hcd)\r\n{\r\ndev_dbg(hcd->self.controller, "%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int\r\nsl811h_bus_resume(struct usb_hcd *hcd)\r\n{\r\ndev_dbg(hcd->self.controller, "%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void dump_irq(struct seq_file *s, char *label, u8 mask)\r\n{\r\nseq_printf(s, "%s %02x%s%s%s%s%s%s\n", label, mask,\r\n(mask & SL11H_INTMASK_DONE_A) ? " done_a" : "",\r\n(mask & SL11H_INTMASK_DONE_B) ? " done_b" : "",\r\n(mask & SL11H_INTMASK_SOFINTR) ? " sof" : "",\r\n(mask & SL11H_INTMASK_INSRMV) ? " ins/rmv" : "",\r\n(mask & SL11H_INTMASK_RD) ? " rd" : "",\r\n(mask & SL11H_INTMASK_DP) ? " dp" : "");\r\n}\r\nstatic int sl811h_show(struct seq_file *s, void *unused)\r\n{\r\nstruct sl811 *sl811 = s->private;\r\nstruct sl811h_ep *ep;\r\nunsigned i;\r\nseq_printf(s, "%s\n%s version %s\nportstatus[1] = %08x\n",\r\nsl811_to_hcd(sl811)->product_desc,\r\nhcd_name, DRIVER_VERSION,\r\nsl811->port1);\r\nseq_printf(s, "insert/remove: %ld\n", sl811->stat_insrmv);\r\nseq_printf(s, "current session: done_a %ld done_b %ld "\r\n"wake %ld sof %ld overrun %ld lost %ld\n\n",\r\nsl811->stat_a, sl811->stat_b,\r\nsl811->stat_wake, sl811->stat_sof,\r\nsl811->stat_overrun, sl811->stat_lost);\r\nspin_lock_irq(&sl811->lock);\r\nif (sl811->ctrl1 & SL11H_CTL1MASK_SUSPEND)\r\nseq_printf(s, "(suspended)\n\n");\r\nelse {\r\nu8 t = sl811_read(sl811, SL11H_CTLREG1);\r\nseq_printf(s, "ctrl1 %02x%s%s%s%s\n", t,\r\n(t & SL11H_CTL1MASK_SOF_ENA) ? " sofgen" : "",\r\n({char *s; switch (t & SL11H_CTL1MASK_FORCE) {\r\ncase SL11H_CTL1MASK_NORMAL: s = ""; break;\r\ncase SL11H_CTL1MASK_SE0: s = " se0/reset"; break;\r\ncase SL11H_CTL1MASK_K: s = " k/resume"; break;\r\ndefault: s = "j"; break;\r\n} s; }),\r\n(t & SL11H_CTL1MASK_LSPD) ? " lowspeed" : "",\r\n(t & SL11H_CTL1MASK_SUSPEND) ? " suspend" : "");\r\ndump_irq(s, "irq_enable",\r\nsl811_read(sl811, SL11H_IRQ_ENABLE));\r\ndump_irq(s, "irq_status",\r\nsl811_read(sl811, SL11H_IRQ_STATUS));\r\nseq_printf(s, "frame clocks remaining: %d\n",\r\nsl811_read(sl811, SL11H_SOFTMRREG) << 6);\r\n}\r\nseq_printf(s, "A: qh%p ctl %02x sts %02x\n", sl811->active_a,\r\nsl811_read(sl811, SL811_EP_A(SL11H_HOSTCTLREG)),\r\nsl811_read(sl811, SL811_EP_A(SL11H_PKTSTATREG)));\r\nseq_printf(s, "B: qh%p ctl %02x sts %02x\n", sl811->active_b,\r\nsl811_read(sl811, SL811_EP_B(SL11H_HOSTCTLREG)),\r\nsl811_read(sl811, SL811_EP_B(SL11H_PKTSTATREG)));\r\nseq_printf(s, "\n");\r\nlist_for_each_entry (ep, &sl811->async, schedule) {\r\nstruct urb *urb;\r\nseq_printf(s, "%s%sqh%p, ep%d%s, maxpacket %d"\r\n" nak %d err %d\n",\r\n(ep == sl811->active_a) ? "(A) " : "",\r\n(ep == sl811->active_b) ? "(B) " : "",\r\nep, ep->epnum,\r\n({ char *s; switch (ep->nextpid) {\r\ncase USB_PID_IN: s = "in"; break;\r\ncase USB_PID_OUT: s = "out"; break;\r\ncase USB_PID_SETUP: s = "setup"; break;\r\ncase USB_PID_ACK: s = "status"; break;\r\ndefault: s = "?"; break;\r\n} s;}),\r\nep->maxpacket,\r\nep->nak_count, ep->error_count);\r\nlist_for_each_entry (urb, &ep->hep->urb_list, urb_list) {\r\nseq_printf(s, " urb%p, %d/%d\n", urb,\r\nurb->actual_length,\r\nurb->transfer_buffer_length);\r\n}\r\n}\r\nif (!list_empty(&sl811->async))\r\nseq_printf(s, "\n");\r\nseq_printf(s, "periodic size= %d\n", PERIODIC_SIZE);\r\nfor (i = 0; i < PERIODIC_SIZE; i++) {\r\nep = sl811->periodic[i];\r\nif (!ep)\r\ncontinue;\r\nseq_printf(s, "%2d [%3d]:\n", i, sl811->load[i]);\r\ndo {\r\nseq_printf(s,\r\n" %s%sqh%d/%p (%sdev%d ep%d%s max %d) "\r\n"err %d\n",\r\n(ep == sl811->active_a) ? "(A) " : "",\r\n(ep == sl811->active_b) ? "(B) " : "",\r\nep->period, ep,\r\n(ep->udev->speed == USB_SPEED_FULL)\r\n? "" : "ls ",\r\nep->udev->devnum, ep->epnum,\r\n(ep->epnum == 0) ? ""\r\n: ((ep->nextpid == USB_PID_IN)\r\n? "in"\r\n: "out"),\r\nep->maxpacket, ep->error_count);\r\nep = ep->next;\r\n} while (ep);\r\n}\r\nspin_unlock_irq(&sl811->lock);\r\nseq_printf(s, "\n");\r\nreturn 0;\r\n}\r\nstatic int sl811h_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, sl811h_show, inode->i_private);\r\n}\r\nstatic void create_debug_file(struct sl811 *sl811)\r\n{\r\nsl811->debug_file = debugfs_create_file("sl811h", S_IRUGO,\r\nusb_debug_root, sl811,\r\n&debug_ops);\r\n}\r\nstatic void remove_debug_file(struct sl811 *sl811)\r\n{\r\ndebugfs_remove(sl811->debug_file);\r\n}\r\nstatic void\r\nsl811h_stop(struct usb_hcd *hcd)\r\n{\r\nstruct sl811 *sl811 = hcd_to_sl811(hcd);\r\nunsigned long flags;\r\ndel_timer_sync(&hcd->rh_timer);\r\nspin_lock_irqsave(&sl811->lock, flags);\r\nport_power(sl811, 0);\r\nspin_unlock_irqrestore(&sl811->lock, flags);\r\n}\r\nstatic int\r\nsl811h_start(struct usb_hcd *hcd)\r\n{\r\nstruct sl811 *sl811 = hcd_to_sl811(hcd);\r\nhcd->state = HC_STATE_RUNNING;\r\nif (sl811->board) {\r\nif (!device_can_wakeup(hcd->self.controller))\r\ndevice_init_wakeup(hcd->self.controller,\r\nsl811->board->can_wakeup);\r\nhcd->power_budget = sl811->board->power * 2;\r\n}\r\nport_power(sl811, 1);\r\nreturn 0;\r\n}\r\nstatic int\r\nsl811h_remove(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct sl811 *sl811 = hcd_to_sl811(hcd);\r\nstruct resource *res;\r\nremove_debug_file(sl811);\r\nusb_remove_hcd(hcd);\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 1);\r\nif (res)\r\niounmap(sl811->data_reg);\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (res)\r\niounmap(sl811->addr_reg);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic int\r\nsl811h_probe(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct sl811 *sl811;\r\nstruct resource *addr, *data, *ires;\r\nint irq;\r\nvoid __iomem *addr_reg;\r\nvoid __iomem *data_reg;\r\nint retval;\r\nu8 tmp, ioaddr = 0;\r\nunsigned long irqflags;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nires = platform_get_resource(dev, IORESOURCE_IRQ, 0);\r\nif (dev->num_resources < 3 || !ires)\r\nreturn -ENODEV;\r\nirq = ires->start;\r\nirqflags = ires->flags & IRQF_TRIGGER_MASK;\r\nif (dev->dev.dma_mask) {\r\ndev_dbg(&dev->dev, "no we won't dma\n");\r\nreturn -EINVAL;\r\n}\r\naddr = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\ndata = platform_get_resource(dev, IORESOURCE_MEM, 1);\r\nretval = -EBUSY;\r\nif (!addr || !data) {\r\naddr = platform_get_resource(dev, IORESOURCE_IO, 0);\r\ndata = platform_get_resource(dev, IORESOURCE_IO, 1);\r\nif (!addr || !data)\r\nreturn -ENODEV;\r\nioaddr = 1;\r\naddr_reg = (void __iomem *) (unsigned long) addr->start;\r\ndata_reg = (void __iomem *) (unsigned long) data->start;\r\n} else {\r\naddr_reg = ioremap(addr->start, 1);\r\nif (addr_reg == NULL) {\r\nretval = -ENOMEM;\r\ngoto err2;\r\n}\r\ndata_reg = ioremap(data->start, 1);\r\nif (data_reg == NULL) {\r\nretval = -ENOMEM;\r\ngoto err4;\r\n}\r\n}\r\nhcd = usb_create_hcd(&sl811h_hc_driver, &dev->dev, dev_name(&dev->dev));\r\nif (!hcd) {\r\nretval = -ENOMEM;\r\ngoto err5;\r\n}\r\nhcd->rsrc_start = addr->start;\r\nsl811 = hcd_to_sl811(hcd);\r\nspin_lock_init(&sl811->lock);\r\nINIT_LIST_HEAD(&sl811->async);\r\nsl811->board = dev_get_platdata(&dev->dev);\r\ninit_timer(&sl811->timer);\r\nsl811->timer.function = sl811h_timer;\r\nsl811->timer.data = (unsigned long) sl811;\r\nsl811->addr_reg = addr_reg;\r\nsl811->data_reg = data_reg;\r\nspin_lock_irq(&sl811->lock);\r\nport_power(sl811, 0);\r\nspin_unlock_irq(&sl811->lock);\r\nmsleep(200);\r\ntmp = sl811_read(sl811, SL11H_HWREVREG);\r\nswitch (tmp >> 4) {\r\ncase 1:\r\nhcd->product_desc = "SL811HS v1.2";\r\nbreak;\r\ncase 2:\r\nhcd->product_desc = "SL811HS v1.5";\r\nbreak;\r\ndefault:\r\ndev_dbg(&dev->dev, "chiprev %02x\n", tmp);\r\nretval = -ENXIO;\r\ngoto err6;\r\n}\r\nirqflags |= IRQF_SHARED;\r\nretval = usb_add_hcd(hcd, irq, irqflags);\r\nif (retval != 0)\r\ngoto err6;\r\ndevice_wakeup_enable(hcd->self.controller);\r\ncreate_debug_file(sl811);\r\nreturn retval;\r\nerr6:\r\nusb_put_hcd(hcd);\r\nerr5:\r\nif (!ioaddr)\r\niounmap(data_reg);\r\nerr4:\r\nif (!ioaddr)\r\niounmap(addr_reg);\r\nerr2:\r\ndev_dbg(&dev->dev, "init error, %d\n", retval);\r\nreturn retval;\r\n}\r\nstatic int\r\nsl811h_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct sl811 *sl811 = hcd_to_sl811(hcd);\r\nint retval = 0;\r\nswitch (state.event) {\r\ncase PM_EVENT_FREEZE:\r\nretval = sl811h_bus_suspend(hcd);\r\nbreak;\r\ncase PM_EVENT_SUSPEND:\r\ncase PM_EVENT_HIBERNATE:\r\ncase PM_EVENT_PRETHAW:\r\nport_power(sl811, 0);\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic int\r\nsl811h_resume(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct sl811 *sl811 = hcd_to_sl811(hcd);\r\nif (!sl811->port1 || !device_can_wakeup(&hcd->self.root_hub->dev)) {\r\nsl811->port1 = 0;\r\nport_power(sl811, 1);\r\nusb_root_hub_lost_power(hcd->self.root_hub);\r\nreturn 0;\r\n}\r\nreturn sl811h_bus_resume(hcd);\r\n}
