const char * scsi_device_type(unsigned type)\r\n{\r\nif (type == 0x1e)\r\nreturn "Well-known LUN ";\r\nif (type == 0x1f)\r\nreturn "No Device ";\r\nif (type >= ARRAY_SIZE(scsi_device_types))\r\nreturn "Unknown ";\r\nreturn scsi_device_types[type];\r\n}\r\nstatic void\r\nscsi_host_free_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_host_cmd_pool *pool = shost->cmd_pool;\r\nif (cmd->prot_sdb)\r\nkmem_cache_free(scsi_sdb_cache, cmd->prot_sdb);\r\nkmem_cache_free(pool->sense_slab, cmd->sense_buffer);\r\nkmem_cache_free(pool->cmd_slab, cmd);\r\n}\r\nstatic struct scsi_cmnd *\r\nscsi_host_alloc_command(struct Scsi_Host *shost, gfp_t gfp_mask)\r\n{\r\nstruct scsi_host_cmd_pool *pool = shost->cmd_pool;\r\nstruct scsi_cmnd *cmd;\r\ncmd = kmem_cache_zalloc(pool->cmd_slab, gfp_mask | pool->gfp_mask);\r\nif (!cmd)\r\ngoto fail;\r\ncmd->sense_buffer = kmem_cache_alloc(pool->sense_slab,\r\ngfp_mask | pool->gfp_mask);\r\nif (!cmd->sense_buffer)\r\ngoto fail_free_cmd;\r\nif (scsi_host_get_prot(shost) >= SHOST_DIX_TYPE0_PROTECTION) {\r\ncmd->prot_sdb = kmem_cache_zalloc(scsi_sdb_cache, gfp_mask);\r\nif (!cmd->prot_sdb)\r\ngoto fail_free_sense;\r\n}\r\nreturn cmd;\r\nfail_free_sense:\r\nkmem_cache_free(pool->sense_slab, cmd->sense_buffer);\r\nfail_free_cmd:\r\nkmem_cache_free(pool->cmd_slab, cmd);\r\nfail:\r\nreturn NULL;\r\n}\r\nstruct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)\r\n{\r\nstruct scsi_cmnd *cmd = scsi_host_alloc_command(shost, gfp_mask);\r\nif (unlikely(!cmd)) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&shost->free_list_lock, flags);\r\nif (likely(!list_empty(&shost->free_list))) {\r\ncmd = list_entry(shost->free_list.next,\r\nstruct scsi_cmnd, list);\r\nlist_del_init(&cmd->list);\r\n}\r\nspin_unlock_irqrestore(&shost->free_list_lock, flags);\r\nif (cmd) {\r\nvoid *buf, *prot;\r\nbuf = cmd->sense_buffer;\r\nprot = cmd->prot_sdb;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->sense_buffer = buf;\r\ncmd->prot_sdb = prot;\r\n}\r\n}\r\nreturn cmd;\r\n}\r\nstruct scsi_cmnd *scsi_get_command(struct scsi_device *dev, gfp_t gfp_mask)\r\n{\r\nstruct scsi_cmnd *cmd = __scsi_get_command(dev->host, gfp_mask);\r\nunsigned long flags;\r\nif (unlikely(cmd == NULL))\r\nreturn NULL;\r\ncmd->device = dev;\r\nINIT_LIST_HEAD(&cmd->list);\r\nINIT_DELAYED_WORK(&cmd->abort_work, scmd_eh_abort_handler);\r\nspin_lock_irqsave(&dev->list_lock, flags);\r\nlist_add_tail(&cmd->list, &dev->cmd_list);\r\nspin_unlock_irqrestore(&dev->list_lock, flags);\r\ncmd->jiffies_at_alloc = jiffies;\r\nreturn cmd;\r\n}\r\nvoid __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)\r\n{\r\nunsigned long flags;\r\nif (unlikely(list_empty(&shost->free_list))) {\r\nspin_lock_irqsave(&shost->free_list_lock, flags);\r\nif (list_empty(&shost->free_list)) {\r\nlist_add(&cmd->list, &shost->free_list);\r\ncmd = NULL;\r\n}\r\nspin_unlock_irqrestore(&shost->free_list_lock, flags);\r\n}\r\nif (likely(cmd != NULL))\r\nscsi_host_free_command(shost, cmd);\r\n}\r\nvoid scsi_put_command(struct scsi_cmnd *cmd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cmd->device->list_lock, flags);\r\nBUG_ON(list_empty(&cmd->list));\r\nlist_del_init(&cmd->list);\r\nspin_unlock_irqrestore(&cmd->device->list_lock, flags);\r\ncancel_delayed_work(&cmd->abort_work);\r\n__scsi_put_command(cmd->device->host, cmd);\r\n}\r\nstatic struct scsi_host_cmd_pool *\r\nscsi_find_host_cmd_pool(struct Scsi_Host *shost)\r\n{\r\nif (shost->hostt->cmd_size)\r\nreturn shost->hostt->cmd_pool;\r\nif (shost->unchecked_isa_dma)\r\nreturn &scsi_cmd_dma_pool;\r\nreturn &scsi_cmd_pool;\r\n}\r\nstatic void\r\nscsi_free_host_cmd_pool(struct scsi_host_cmd_pool *pool)\r\n{\r\nkfree(pool->sense_name);\r\nkfree(pool->cmd_name);\r\nkfree(pool);\r\n}\r\nstatic struct scsi_host_cmd_pool *\r\nscsi_alloc_host_cmd_pool(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_host_template *hostt = shost->hostt;\r\nstruct scsi_host_cmd_pool *pool;\r\npool = kzalloc(sizeof(*pool), GFP_KERNEL);\r\nif (!pool)\r\nreturn NULL;\r\npool->cmd_name = kasprintf(GFP_KERNEL, "%s_cmd", hostt->name);\r\npool->sense_name = kasprintf(GFP_KERNEL, "%s_sense", hostt->name);\r\nif (!pool->cmd_name || !pool->sense_name) {\r\nscsi_free_host_cmd_pool(pool);\r\nreturn NULL;\r\n}\r\npool->slab_flags = SLAB_HWCACHE_ALIGN;\r\nif (shost->unchecked_isa_dma) {\r\npool->slab_flags |= SLAB_CACHE_DMA;\r\npool->gfp_mask = __GFP_DMA;\r\n}\r\nreturn pool;\r\n}\r\nstatic struct scsi_host_cmd_pool *\r\nscsi_get_host_cmd_pool(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_host_template *hostt = shost->hostt;\r\nstruct scsi_host_cmd_pool *retval = NULL, *pool;\r\nsize_t cmd_size = sizeof(struct scsi_cmnd) + hostt->cmd_size;\r\nmutex_lock(&host_cmd_pool_mutex);\r\npool = scsi_find_host_cmd_pool(shost);\r\nif (!pool) {\r\npool = scsi_alloc_host_cmd_pool(shost);\r\nif (!pool)\r\ngoto out;\r\n}\r\nif (!pool->users) {\r\npool->cmd_slab = kmem_cache_create(pool->cmd_name, cmd_size, 0,\r\npool->slab_flags, NULL);\r\nif (!pool->cmd_slab)\r\ngoto out_free_pool;\r\npool->sense_slab = kmem_cache_create(pool->sense_name,\r\nSCSI_SENSE_BUFFERSIZE, 0,\r\npool->slab_flags, NULL);\r\nif (!pool->sense_slab)\r\ngoto out_free_slab;\r\n}\r\npool->users++;\r\nretval = pool;\r\nout:\r\nmutex_unlock(&host_cmd_pool_mutex);\r\nreturn retval;\r\nout_free_slab:\r\nkmem_cache_destroy(pool->cmd_slab);\r\nout_free_pool:\r\nif (hostt->cmd_size)\r\nscsi_free_host_cmd_pool(pool);\r\ngoto out;\r\n}\r\nstatic void scsi_put_host_cmd_pool(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_host_template *hostt = shost->hostt;\r\nstruct scsi_host_cmd_pool *pool;\r\nmutex_lock(&host_cmd_pool_mutex);\r\npool = scsi_find_host_cmd_pool(shost);\r\nBUG_ON(pool->users == 0);\r\nif (!--pool->users) {\r\nkmem_cache_destroy(pool->cmd_slab);\r\nkmem_cache_destroy(pool->sense_slab);\r\nif (hostt->cmd_size)\r\nscsi_free_host_cmd_pool(pool);\r\n}\r\nmutex_unlock(&host_cmd_pool_mutex);\r\n}\r\nint scsi_setup_command_freelist(struct Scsi_Host *shost)\r\n{\r\nconst gfp_t gfp_mask = shost->unchecked_isa_dma ? GFP_DMA : GFP_KERNEL;\r\nstruct scsi_cmnd *cmd;\r\nspin_lock_init(&shost->free_list_lock);\r\nINIT_LIST_HEAD(&shost->free_list);\r\nshost->cmd_pool = scsi_get_host_cmd_pool(shost);\r\nif (!shost->cmd_pool)\r\nreturn -ENOMEM;\r\ncmd = scsi_host_alloc_command(shost, gfp_mask);\r\nif (!cmd) {\r\nscsi_put_host_cmd_pool(shost);\r\nshost->cmd_pool = NULL;\r\nreturn -ENOMEM;\r\n}\r\nlist_add(&cmd->list, &shost->free_list);\r\nreturn 0;\r\n}\r\nvoid scsi_destroy_command_freelist(struct Scsi_Host *shost)\r\n{\r\nif (!shost->cmd_pool)\r\nreturn;\r\nwhile (!list_empty(&shost->free_list)) {\r\nstruct scsi_cmnd *cmd;\r\ncmd = list_entry(shost->free_list.next, struct scsi_cmnd, list);\r\nlist_del_init(&cmd->list);\r\nscsi_host_free_command(shost, cmd);\r\n}\r\nshost->cmd_pool = NULL;\r\nscsi_put_host_cmd_pool(shost);\r\n}\r\nvoid scsi_log_send(struct scsi_cmnd *cmd)\r\n{\r\nunsigned int level;\r\nif (unlikely(scsi_logging_level)) {\r\nlevel = SCSI_LOG_LEVEL(SCSI_LOG_MLQUEUE_SHIFT,\r\nSCSI_LOG_MLQUEUE_BITS);\r\nif (level > 1) {\r\nscmd_printk(KERN_INFO, cmd, "Send: ");\r\nif (level > 2)\r\nprintk("0x%p ", cmd);\r\nprintk("\n");\r\nscsi_print_command(cmd);\r\nif (level > 3) {\r\nprintk(KERN_INFO "buffer = 0x%p, bufflen = %d,"\r\n" queuecommand 0x%p\n",\r\nscsi_sglist(cmd), scsi_bufflen(cmd),\r\ncmd->device->host->hostt->queuecommand);\r\n}\r\n}\r\n}\r\n}\r\nvoid scsi_log_completion(struct scsi_cmnd *cmd, int disposition)\r\n{\r\nunsigned int level;\r\nif (unlikely(scsi_logging_level)) {\r\nlevel = SCSI_LOG_LEVEL(SCSI_LOG_MLCOMPLETE_SHIFT,\r\nSCSI_LOG_MLCOMPLETE_BITS);\r\nif (((level > 0) && (cmd->result || disposition != SUCCESS)) ||\r\n(level > 1)) {\r\nscmd_printk(KERN_INFO, cmd, "Done: ");\r\nif (level > 2)\r\nprintk("0x%p ", cmd);\r\nswitch (disposition) {\r\ncase SUCCESS:\r\nprintk("SUCCESS\n");\r\nbreak;\r\ncase NEEDS_RETRY:\r\nprintk("RETRY\n");\r\nbreak;\r\ncase ADD_TO_MLQUEUE:\r\nprintk("MLQUEUE\n");\r\nbreak;\r\ncase FAILED:\r\nprintk("FAILED\n");\r\nbreak;\r\ncase TIMEOUT_ERROR:\r\nprintk("TIMEOUT\n");\r\nbreak;\r\ndefault:\r\nprintk("UNKNOWN\n");\r\n}\r\nscsi_print_result(cmd);\r\nscsi_print_command(cmd);\r\nif (status_byte(cmd->result) & CHECK_CONDITION)\r\nscsi_print_sense("", cmd);\r\nif (level > 3)\r\nscmd_printk(KERN_INFO, cmd,\r\n"scsi host busy %d failed %d\n",\r\ncmd->device->host->host_busy,\r\ncmd->device->host->host_failed);\r\n}\r\n}\r\n}\r\nvoid scsi_cmd_get_serial(struct Scsi_Host *host, struct scsi_cmnd *cmd)\r\n{\r\ncmd->serial_number = host->cmd_serial_number++;\r\nif (cmd->serial_number == 0)\r\ncmd->serial_number = host->cmd_serial_number++;\r\n}\r\nint scsi_dispatch_cmd(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *host = cmd->device->host;\r\nint rtn = 0;\r\natomic_inc(&cmd->device->iorequest_cnt);\r\nif (unlikely(cmd->device->sdev_state == SDEV_DEL)) {\r\ncmd->result = DID_NO_CONNECT << 16;\r\nscsi_done(cmd);\r\ngoto out;\r\n}\r\nif (unlikely(scsi_device_blocked(cmd->device))) {\r\nscsi_queue_insert(cmd, SCSI_MLQUEUE_DEVICE_BUSY);\r\nSCSI_LOG_MLQUEUE(3, printk("queuecommand : device blocked \n"));\r\ngoto out;\r\n}\r\nif (cmd->device->scsi_level <= SCSI_2 &&\r\ncmd->device->scsi_level != SCSI_UNKNOWN) {\r\ncmd->cmnd[1] = (cmd->cmnd[1] & 0x1f) |\r\n(cmd->device->lun << 5 & 0xe0);\r\n}\r\nscsi_log_send(cmd);\r\nif (cmd->cmd_len > cmd->device->host->max_cmd_len) {\r\nSCSI_LOG_MLQUEUE(3,\r\nprintk("queuecommand : command too long. "\r\n"cdb_size=%d host->max_cmd_len=%d\n",\r\ncmd->cmd_len, cmd->device->host->max_cmd_len));\r\ncmd->result = (DID_ABORT << 16);\r\nscsi_done(cmd);\r\ngoto out;\r\n}\r\nif (unlikely(host->shost_state == SHOST_DEL)) {\r\ncmd->result = (DID_NO_CONNECT << 16);\r\nscsi_done(cmd);\r\n} else {\r\ntrace_scsi_dispatch_cmd_start(cmd);\r\ncmd->scsi_done = scsi_done;\r\nrtn = host->hostt->queuecommand(host, cmd);\r\n}\r\nif (rtn) {\r\ntrace_scsi_dispatch_cmd_error(cmd, rtn);\r\nif (rtn != SCSI_MLQUEUE_DEVICE_BUSY &&\r\nrtn != SCSI_MLQUEUE_TARGET_BUSY)\r\nrtn = SCSI_MLQUEUE_HOST_BUSY;\r\nscsi_queue_insert(cmd, rtn);\r\nSCSI_LOG_MLQUEUE(3,\r\nprintk("queuecommand : request rejected\n"));\r\n}\r\nout:\r\nSCSI_LOG_MLQUEUE(3, printk("leaving scsi_dispatch_cmnd()\n"));\r\nreturn rtn;\r\n}\r\nstatic void scsi_done(struct scsi_cmnd *cmd)\r\n{\r\ntrace_scsi_dispatch_cmd_done(cmd);\r\nblk_complete_request(cmd->request);\r\n}\r\nvoid scsi_finish_command(struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_device *sdev = cmd->device;\r\nstruct scsi_target *starget = scsi_target(sdev);\r\nstruct Scsi_Host *shost = sdev->host;\r\nstruct scsi_driver *drv;\r\nunsigned int good_bytes;\r\nscsi_device_unbusy(sdev);\r\nshost->host_blocked = 0;\r\nstarget->target_blocked = 0;\r\nsdev->device_blocked = 0;\r\nif (SCSI_SENSE_VALID(cmd))\r\ncmd->result |= (DRIVER_SENSE << 24);\r\nSCSI_LOG_MLCOMPLETE(4, sdev_printk(KERN_INFO, sdev,\r\n"Notifying upper driver of completion "\r\n"(result %x)\n", cmd->result));\r\ngood_bytes = scsi_bufflen(cmd);\r\nif (cmd->request->cmd_type != REQ_TYPE_BLOCK_PC) {\r\nint old_good_bytes = good_bytes;\r\ndrv = scsi_cmd_to_driver(cmd);\r\nif (drv->done)\r\ngood_bytes = drv->done(cmd);\r\nif (good_bytes == old_good_bytes)\r\ngood_bytes -= scsi_get_resid(cmd);\r\n}\r\nscsi_io_completion(cmd, good_bytes);\r\n}\r\nvoid scsi_adjust_queue_depth(struct scsi_device *sdev, int tagged, int tags)\r\n{\r\nunsigned long flags;\r\nif (tags <= 0)\r\nreturn;\r\nspin_lock_irqsave(sdev->request_queue->queue_lock, flags);\r\nif (!sdev->host->bqt) {\r\nif (blk_queue_tagged(sdev->request_queue) &&\r\nblk_queue_resize_tags(sdev->request_queue, tags) != 0)\r\ngoto out;\r\n}\r\nsdev->queue_depth = tags;\r\nswitch (tagged) {\r\ncase MSG_ORDERED_TAG:\r\nsdev->ordered_tags = 1;\r\nsdev->simple_tags = 1;\r\nbreak;\r\ncase MSG_SIMPLE_TAG:\r\nsdev->ordered_tags = 0;\r\nsdev->simple_tags = 1;\r\nbreak;\r\ndefault:\r\nsdev_printk(KERN_WARNING, sdev,\r\n"scsi_adjust_queue_depth, bad queue type, "\r\n"disabled\n");\r\ncase 0:\r\nsdev->ordered_tags = sdev->simple_tags = 0;\r\nsdev->queue_depth = tags;\r\nbreak;\r\n}\r\nout:\r\nspin_unlock_irqrestore(sdev->request_queue->queue_lock, flags);\r\n}\r\nint scsi_track_queue_full(struct scsi_device *sdev, int depth)\r\n{\r\nif ((jiffies >> 4) == (sdev->last_queue_full_time >> 4))\r\nreturn 0;\r\nsdev->last_queue_full_time = jiffies;\r\nif (sdev->last_queue_full_depth != depth) {\r\nsdev->last_queue_full_count = 1;\r\nsdev->last_queue_full_depth = depth;\r\n} else {\r\nsdev->last_queue_full_count++;\r\n}\r\nif (sdev->last_queue_full_count <= 10)\r\nreturn 0;\r\nif (sdev->last_queue_full_depth < 8) {\r\nscsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);\r\nreturn -1;\r\n}\r\nif (sdev->ordered_tags)\r\nscsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG, depth);\r\nelse\r\nscsi_adjust_queue_depth(sdev, MSG_SIMPLE_TAG, depth);\r\nreturn depth;\r\n}\r\nstatic int scsi_vpd_inquiry(struct scsi_device *sdev, unsigned char *buffer,\r\nu8 page, unsigned len)\r\n{\r\nint result;\r\nunsigned char cmd[16];\r\nif (len < 4)\r\nreturn -EINVAL;\r\ncmd[0] = INQUIRY;\r\ncmd[1] = 1;\r\ncmd[2] = page;\r\ncmd[3] = len >> 8;\r\ncmd[4] = len & 0xff;\r\ncmd[5] = 0;\r\nresult = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buffer,\r\nlen, NULL, 30 * HZ, 3, NULL);\r\nif (result)\r\nreturn -EIO;\r\nif (buffer[1] != page)\r\nreturn -EIO;\r\nreturn get_unaligned_be16(&buffer[2]) + 4;\r\n}\r\nint scsi_get_vpd_page(struct scsi_device *sdev, u8 page, unsigned char *buf,\r\nint buf_len)\r\n{\r\nint i, result;\r\nif (sdev->skip_vpd_pages)\r\ngoto fail;\r\nresult = scsi_vpd_inquiry(sdev, buf, 0, buf_len);\r\nif (result < 4)\r\ngoto fail;\r\nif (page == 0)\r\nreturn 0;\r\nfor (i = 4; i < min(result, buf_len); i++)\r\nif (buf[i] == page)\r\ngoto found;\r\nif (i < result && i >= buf_len)\r\ngoto found;\r\ngoto fail;\r\nfound:\r\nresult = scsi_vpd_inquiry(sdev, buf, page, buf_len);\r\nif (result < 0)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nreturn -EINVAL;\r\n}\r\nvoid scsi_attach_vpd(struct scsi_device *sdev)\r\n{\r\nint result, i;\r\nint vpd_len = SCSI_VPD_PG_LEN;\r\nint pg80_supported = 0;\r\nint pg83_supported = 0;\r\nunsigned char *vpd_buf;\r\nif (sdev->skip_vpd_pages)\r\nreturn;\r\nretry_pg0:\r\nvpd_buf = kmalloc(vpd_len, GFP_KERNEL);\r\nif (!vpd_buf)\r\nreturn;\r\nresult = scsi_vpd_inquiry(sdev, vpd_buf, 0, vpd_len);\r\nif (result < 0) {\r\nkfree(vpd_buf);\r\nreturn;\r\n}\r\nif (result > vpd_len) {\r\nvpd_len = result;\r\nkfree(vpd_buf);\r\ngoto retry_pg0;\r\n}\r\nfor (i = 4; i < result; i++) {\r\nif (vpd_buf[i] == 0x80)\r\npg80_supported = 1;\r\nif (vpd_buf[i] == 0x83)\r\npg83_supported = 1;\r\n}\r\nkfree(vpd_buf);\r\nvpd_len = SCSI_VPD_PG_LEN;\r\nif (pg80_supported) {\r\nretry_pg80:\r\nvpd_buf = kmalloc(vpd_len, GFP_KERNEL);\r\nif (!vpd_buf)\r\nreturn;\r\nresult = scsi_vpd_inquiry(sdev, vpd_buf, 0x80, vpd_len);\r\nif (result < 0) {\r\nkfree(vpd_buf);\r\nreturn;\r\n}\r\nif (result > vpd_len) {\r\nvpd_len = result;\r\nkfree(vpd_buf);\r\ngoto retry_pg80;\r\n}\r\nsdev->vpd_pg80_len = result;\r\nsdev->vpd_pg80 = vpd_buf;\r\nvpd_len = SCSI_VPD_PG_LEN;\r\n}\r\nif (pg83_supported) {\r\nretry_pg83:\r\nvpd_buf = kmalloc(vpd_len, GFP_KERNEL);\r\nif (!vpd_buf)\r\nreturn;\r\nresult = scsi_vpd_inquiry(sdev, vpd_buf, 0x83, vpd_len);\r\nif (result < 0) {\r\nkfree(vpd_buf);\r\nreturn;\r\n}\r\nif (result > vpd_len) {\r\nvpd_len = result;\r\nkfree(vpd_buf);\r\ngoto retry_pg83;\r\n}\r\nsdev->vpd_pg83_len = result;\r\nsdev->vpd_pg83 = vpd_buf;\r\n}\r\n}\r\nint scsi_report_opcode(struct scsi_device *sdev, unsigned char *buffer,\r\nunsigned int len, unsigned char opcode)\r\n{\r\nunsigned char cmd[16];\r\nstruct scsi_sense_hdr sshdr;\r\nint result;\r\nif (sdev->no_report_opcodes || sdev->scsi_level < SCSI_SPC_3)\r\nreturn -EINVAL;\r\nmemset(cmd, 0, 16);\r\ncmd[0] = MAINTENANCE_IN;\r\ncmd[1] = MI_REPORT_SUPPORTED_OPERATION_CODES;\r\ncmd[2] = 1;\r\ncmd[3] = opcode;\r\nput_unaligned_be32(len, &cmd[6]);\r\nmemset(buffer, 0, len);\r\nresult = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buffer, len,\r\n&sshdr, 30 * HZ, 3, NULL);\r\nif (result && scsi_sense_valid(&sshdr) &&\r\nsshdr.sense_key == ILLEGAL_REQUEST &&\r\n(sshdr.asc == 0x20 || sshdr.asc == 0x24) && sshdr.ascq == 0x00)\r\nreturn -EINVAL;\r\nif ((buffer[1] & 3) == 3)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint scsi_device_get(struct scsi_device *sdev)\r\n{\r\nif (sdev->sdev_state == SDEV_DEL)\r\nreturn -ENXIO;\r\nif (!get_device(&sdev->sdev_gendev))\r\nreturn -ENXIO;\r\ntry_module_get(sdev->host->hostt->module);\r\nreturn 0;\r\n}\r\nvoid scsi_device_put(struct scsi_device *sdev)\r\n{\r\n#ifdef CONFIG_MODULE_UNLOAD\r\nstruct module *module = sdev->host->hostt->module;\r\nif (module && module_refcount(module) != 0)\r\nmodule_put(module);\r\n#endif\r\nput_device(&sdev->sdev_gendev);\r\n}\r\nstruct scsi_device *__scsi_iterate_devices(struct Scsi_Host *shost,\r\nstruct scsi_device *prev)\r\n{\r\nstruct list_head *list = (prev ? &prev->siblings : &shost->__devices);\r\nstruct scsi_device *next = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nwhile (list->next != &shost->__devices) {\r\nnext = list_entry(list->next, struct scsi_device, siblings);\r\nif (!scsi_device_get(next))\r\nbreak;\r\nnext = NULL;\r\nlist = list->next;\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (prev)\r\nscsi_device_put(prev);\r\nreturn next;\r\n}\r\nvoid starget_for_each_device(struct scsi_target *starget, void *data,\r\nvoid (*fn)(struct scsi_device *, void *))\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct scsi_device *sdev;\r\nshost_for_each_device(sdev, shost) {\r\nif ((sdev->channel == starget->channel) &&\r\n(sdev->id == starget->id))\r\nfn(sdev, data);\r\n}\r\n}\r\nvoid __starget_for_each_device(struct scsi_target *starget, void *data,\r\nvoid (*fn)(struct scsi_device *, void *))\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct scsi_device *sdev;\r\n__shost_for_each_device(sdev, shost) {\r\nif ((sdev->channel == starget->channel) &&\r\n(sdev->id == starget->id))\r\nfn(sdev, data);\r\n}\r\n}\r\nstruct scsi_device *__scsi_device_lookup_by_target(struct scsi_target *starget,\r\nuint lun)\r\n{\r\nstruct scsi_device *sdev;\r\nlist_for_each_entry(sdev, &starget->devices, same_target_siblings) {\r\nif (sdev->sdev_state == SDEV_DEL)\r\ncontinue;\r\nif (sdev->lun ==lun)\r\nreturn sdev;\r\n}\r\nreturn NULL;\r\n}\r\nstruct scsi_device *scsi_device_lookup_by_target(struct scsi_target *starget,\r\nuint lun)\r\n{\r\nstruct scsi_device *sdev;\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nsdev = __scsi_device_lookup_by_target(starget, lun);\r\nif (sdev && scsi_device_get(sdev))\r\nsdev = NULL;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn sdev;\r\n}\r\nstruct scsi_device *__scsi_device_lookup(struct Scsi_Host *shost,\r\nuint channel, uint id, uint lun)\r\n{\r\nstruct scsi_device *sdev;\r\nlist_for_each_entry(sdev, &shost->__devices, siblings) {\r\nif (sdev->channel == channel && sdev->id == id &&\r\nsdev->lun ==lun)\r\nreturn sdev;\r\n}\r\nreturn NULL;\r\n}\r\nstruct scsi_device *scsi_device_lookup(struct Scsi_Host *shost,\r\nuint channel, uint id, uint lun)\r\n{\r\nstruct scsi_device *sdev;\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nsdev = __scsi_device_lookup(shost, channel, id, lun);\r\nif (sdev && scsi_device_get(sdev))\r\nsdev = NULL;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn sdev;\r\n}\r\nstatic int __init init_scsi(void)\r\n{\r\nint error;\r\nerror = scsi_init_queue();\r\nif (error)\r\nreturn error;\r\nerror = scsi_init_procfs();\r\nif (error)\r\ngoto cleanup_queue;\r\nerror = scsi_init_devinfo();\r\nif (error)\r\ngoto cleanup_procfs;\r\nerror = scsi_init_hosts();\r\nif (error)\r\ngoto cleanup_devlist;\r\nerror = scsi_init_sysctl();\r\nif (error)\r\ngoto cleanup_hosts;\r\nerror = scsi_sysfs_register();\r\nif (error)\r\ngoto cleanup_sysctl;\r\nscsi_netlink_init();\r\nprintk(KERN_NOTICE "SCSI subsystem initialized\n");\r\nreturn 0;\r\ncleanup_sysctl:\r\nscsi_exit_sysctl();\r\ncleanup_hosts:\r\nscsi_exit_hosts();\r\ncleanup_devlist:\r\nscsi_exit_devinfo();\r\ncleanup_procfs:\r\nscsi_exit_procfs();\r\ncleanup_queue:\r\nscsi_exit_queue();\r\nprintk(KERN_ERR "SCSI subsystem failed to initialize, error = %d\n",\r\n-error);\r\nreturn error;\r\n}\r\nstatic void __exit exit_scsi(void)\r\n{\r\nscsi_netlink_exit();\r\nscsi_sysfs_unregister();\r\nscsi_exit_sysctl();\r\nscsi_exit_hosts();\r\nscsi_exit_devinfo();\r\nscsi_exit_procfs();\r\nscsi_exit_queue();\r\nasync_unregister_domain(&scsi_sd_probe_domain);\r\n}
