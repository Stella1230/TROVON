static int ip_vs_wrr_gcd_weight(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_dest *dest;\r\nint weight;\r\nint g = 0;\r\nlist_for_each_entry(dest, &svc->destinations, n_list) {\r\nweight = atomic_read(&dest->weight);\r\nif (weight > 0) {\r\nif (g > 0)\r\ng = gcd(weight, g);\r\nelse\r\ng = weight;\r\n}\r\n}\r\nreturn g ? g : 1;\r\n}\r\nstatic int ip_vs_wrr_max_weight(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_dest *dest;\r\nint new_weight, weight = 0;\r\nlist_for_each_entry(dest, &svc->destinations, n_list) {\r\nnew_weight = atomic_read(&dest->weight);\r\nif (new_weight > weight)\r\nweight = new_weight;\r\n}\r\nreturn weight;\r\n}\r\nstatic int ip_vs_wrr_init_svc(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_wrr_mark *mark;\r\nmark = kmalloc(sizeof(struct ip_vs_wrr_mark), GFP_KERNEL);\r\nif (mark == NULL)\r\nreturn -ENOMEM;\r\nmark->cl = list_entry(&svc->destinations, struct ip_vs_dest, n_list);\r\nmark->di = ip_vs_wrr_gcd_weight(svc);\r\nmark->mw = ip_vs_wrr_max_weight(svc) - (mark->di - 1);\r\nmark->cw = mark->mw;\r\nsvc->sched_data = mark;\r\nreturn 0;\r\n}\r\nstatic void ip_vs_wrr_done_svc(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_wrr_mark *mark = svc->sched_data;\r\nkfree_rcu(mark, rcu_head);\r\n}\r\nstatic int ip_vs_wrr_dest_changed(struct ip_vs_service *svc,\r\nstruct ip_vs_dest *dest)\r\n{\r\nstruct ip_vs_wrr_mark *mark = svc->sched_data;\r\nspin_lock_bh(&svc->sched_lock);\r\nmark->cl = list_entry(&svc->destinations, struct ip_vs_dest, n_list);\r\nmark->di = ip_vs_wrr_gcd_weight(svc);\r\nmark->mw = ip_vs_wrr_max_weight(svc) - (mark->di - 1);\r\nif (mark->cw > mark->mw || !mark->cw)\r\nmark->cw = mark->mw;\r\nelse if (mark->di > 1)\r\nmark->cw = (mark->cw / mark->di) * mark->di + 1;\r\nspin_unlock_bh(&svc->sched_lock);\r\nreturn 0;\r\n}\r\nstatic struct ip_vs_dest *\r\nip_vs_wrr_schedule(struct ip_vs_service *svc, const struct sk_buff *skb,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\nstruct ip_vs_dest *dest, *last, *stop = NULL;\r\nstruct ip_vs_wrr_mark *mark = svc->sched_data;\r\nbool last_pass = false, restarted = false;\r\nIP_VS_DBG(6, "%s(): Scheduling...\n", __func__);\r\nspin_lock_bh(&svc->sched_lock);\r\ndest = mark->cl;\r\nif (mark->mw == 0)\r\ngoto err_noavail;\r\nlast = dest;\r\nwhile (1) {\r\nlist_for_each_entry_continue_rcu(dest,\r\n&svc->destinations,\r\nn_list) {\r\nif (!(dest->flags & IP_VS_DEST_F_OVERLOAD) &&\r\natomic_read(&dest->weight) >= mark->cw)\r\ngoto found;\r\nif (dest == stop)\r\ngoto err_over;\r\n}\r\nmark->cw -= mark->di;\r\nif (mark->cw <= 0) {\r\nmark->cw = mark->mw;\r\nif (last_pass ||\r\n&last->n_list == &svc->destinations)\r\ngoto err_over;\r\nrestarted = true;\r\n}\r\nlast_pass = mark->cw <= mark->di;\r\nif (last_pass && restarted &&\r\n&last->n_list != &svc->destinations) {\r\nstop = last;\r\n}\r\n}\r\nfound:\r\nIP_VS_DBG_BUF(6, "WRR: server %s:%u "\r\n"activeconns %d refcnt %d weight %d\n",\r\nIP_VS_DBG_ADDR(svc->af, &dest->addr), ntohs(dest->port),\r\natomic_read(&dest->activeconns),\r\natomic_read(&dest->refcnt),\r\natomic_read(&dest->weight));\r\nmark->cl = dest;\r\nout:\r\nspin_unlock_bh(&svc->sched_lock);\r\nreturn dest;\r\nerr_noavail:\r\nmark->cl = dest;\r\ndest = NULL;\r\nip_vs_scheduler_err(svc, "no destination available");\r\ngoto out;\r\nerr_over:\r\nmark->cl = dest;\r\ndest = NULL;\r\nip_vs_scheduler_err(svc, "no destination available: "\r\n"all destinations are overloaded");\r\ngoto out;\r\n}\r\nstatic int __init ip_vs_wrr_init(void)\r\n{\r\nreturn register_ip_vs_scheduler(&ip_vs_wrr_scheduler) ;\r\n}\r\nstatic void __exit ip_vs_wrr_cleanup(void)\r\n{\r\nunregister_ip_vs_scheduler(&ip_vs_wrr_scheduler);\r\nsynchronize_rcu();\r\n}
