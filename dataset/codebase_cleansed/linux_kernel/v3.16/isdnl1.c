void\r\ndebugl1(struct IsdnCardState *cs, char *fmt, ...)\r\n{\r\nva_list args;\r\nchar tmp[8];\r\nva_start(args, fmt);\r\nsprintf(tmp, "Card%d ", cs->cardnr + 1);\r\nVHiSax_putstatus(cs, tmp, fmt, args);\r\nva_end(args);\r\n}\r\nstatic void\r\nl1m_debug(struct FsmInst *fi, char *fmt, ...)\r\n{\r\nva_list args;\r\nstruct PStack *st = fi->userdata;\r\nstruct IsdnCardState *cs = st->l1.hardware;\r\nchar tmp[8];\r\nva_start(args, fmt);\r\nsprintf(tmp, "Card%d ", cs->cardnr + 1);\r\nVHiSax_putstatus(cs, tmp, fmt, args);\r\nva_end(args);\r\n}\r\nstatic void\r\nL1activated(struct IsdnCardState *cs)\r\n{\r\nstruct PStack *st;\r\nst = cs->stlist;\r\nwhile (st) {\r\nif (test_and_clear_bit(FLG_L1_ACTIVATING, &st->l1.Flags))\r\nst->l1.l1l2(st, PH_ACTIVATE | CONFIRM, NULL);\r\nelse\r\nst->l1.l1l2(st, PH_ACTIVATE | INDICATION, NULL);\r\nst = st->next;\r\n}\r\n}\r\nstatic void\r\nL1deactivated(struct IsdnCardState *cs)\r\n{\r\nstruct PStack *st;\r\nst = cs->stlist;\r\nwhile (st) {\r\nif (test_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nst->l1.l1l2(st, PH_PAUSE | CONFIRM, NULL);\r\nst->l1.l1l2(st, PH_DEACTIVATE | INDICATION, NULL);\r\nst = st->next;\r\n}\r\ntest_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags);\r\n}\r\nvoid\r\nDChannel_proc_xmt(struct IsdnCardState *cs)\r\n{\r\nstruct PStack *stptr;\r\nif (cs->tx_skb)\r\nreturn;\r\nstptr = cs->stlist;\r\nwhile (stptr != NULL) {\r\nif (test_and_clear_bit(FLG_L1_PULL_REQ, &stptr->l1.Flags)) {\r\nstptr->l1.l1l2(stptr, PH_PULL | CONFIRM, NULL);\r\nbreak;\r\n} else\r\nstptr = stptr->next;\r\n}\r\n}\r\nvoid\r\nDChannel_proc_rcv(struct IsdnCardState *cs)\r\n{\r\nstruct sk_buff *skb, *nskb;\r\nstruct PStack *stptr = cs->stlist;\r\nint found, tei, sapi;\r\nif (stptr)\r\nif (test_bit(FLG_L1_ACTTIMER, &stptr->l1.Flags))\r\nFsmEvent(&stptr->l1.l1m, EV_TIMER_ACT, NULL);\r\nwhile ((skb = skb_dequeue(&cs->rq))) {\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA", 1);\r\n#endif\r\nstptr = cs->stlist;\r\nif (skb->len < 3) {\r\ndebugl1(cs, "D-channel frame too short(%d)", skb->len);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif ((skb->data[0] & 1) || !(skb->data[1] & 1)) {\r\ndebugl1(cs, "D-channel frame wrong EA0/EA1");\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nsapi = skb->data[0] >> 2;\r\ntei = skb->data[1] >> 1;\r\nif (cs->debug & DEB_DLOG_HEX)\r\nLogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE)\r\ndlogframe(cs, skb, 1);\r\nif (tei == GROUP_TEI) {\r\nif (sapi == CTRL_SAPI) {\r\nwhile (stptr != NULL) {\r\nif ((nskb = skb_clone(skb, GFP_ATOMIC)))\r\nstptr->l1.l1l2(stptr, PH_DATA | INDICATION, nskb);\r\nelse\r\nprintk(KERN_WARNING "HiSax: isdn broadcast buffer shortage\n");\r\nstptr = stptr->next;\r\n}\r\n} else if (sapi == TEI_SAPI) {\r\nwhile (stptr != NULL) {\r\nif ((nskb = skb_clone(skb, GFP_ATOMIC)))\r\nstptr->l1.l1tei(stptr, PH_DATA | INDICATION, nskb);\r\nelse\r\nprintk(KERN_WARNING "HiSax: tei broadcast buffer shortage\n");\r\nstptr = stptr->next;\r\n}\r\n}\r\ndev_kfree_skb(skb);\r\n} else if (sapi == CTRL_SAPI) {\r\nfound = 0;\r\nwhile (stptr != NULL)\r\nif (tei == stptr->l2.tei) {\r\nstptr->l1.l1l2(stptr, PH_DATA | INDICATION, skb);\r\nfound = !0;\r\nbreak;\r\n} else\r\nstptr = stptr->next;\r\nif (!found)\r\ndev_kfree_skb(skb);\r\n} else\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nstatic void\r\nBChannel_proc_xmt(struct BCState *bcs)\r\n{\r\nstruct PStack *st = bcs->st;\r\nif (test_bit(BC_FLG_BUSY, &bcs->Flag)) {\r\ndebugl1(bcs->cs, "BC_BUSY Error");\r\nreturn;\r\n}\r\nif (test_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags))\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\nif (!test_bit(BC_FLG_ACTIV, &bcs->Flag)) {\r\nif (!test_bit(BC_FLG_BUSY, &bcs->Flag) &&\r\nskb_queue_empty(&bcs->squeue)) {\r\nst->l2.l2l1(st, PH_DEACTIVATE | CONFIRM, NULL);\r\n}\r\n}\r\n}\r\nstatic void\r\nBChannel_proc_rcv(struct BCState *bcs)\r\n{\r\nstruct sk_buff *skb;\r\nif (bcs->st->l1.l1m.state == ST_L1_WAIT_ACT) {\r\nFsmDelTimer(&bcs->st->l1.timer, 4);\r\nFsmEvent(&bcs->st->l1.l1m, EV_TIMER_ACT, NULL);\r\n}\r\nwhile ((skb = skb_dequeue(&bcs->rqueue))) {\r\nbcs->st->l1.l1l2(bcs->st, PH_DATA | INDICATION, skb);\r\n}\r\n}\r\nstatic void\r\nBChannel_proc_ack(struct BCState *bcs)\r\n{\r\nu_long flags;\r\nint ack;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nack = bcs->ackcnt;\r\nbcs->ackcnt = 0;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nif (ack)\r\nlli_writewakeup(bcs->st, ack);\r\n}\r\nvoid\r\nBChannel_bh(struct work_struct *work)\r\n{\r\nstruct BCState *bcs = container_of(work, struct BCState, tqueue);\r\nif (!bcs)\r\nreturn;\r\nif (test_and_clear_bit(B_RCVBUFREADY, &bcs->event))\r\nBChannel_proc_rcv(bcs);\r\nif (test_and_clear_bit(B_XMTBUFREADY, &bcs->event))\r\nBChannel_proc_xmt(bcs);\r\nif (test_and_clear_bit(B_ACKPENDING, &bcs->event))\r\nBChannel_proc_ack(bcs);\r\n}\r\nvoid\r\nHiSax_addlist(struct IsdnCardState *cs,\r\nstruct PStack *st)\r\n{\r\nst->next = cs->stlist;\r\ncs->stlist = st;\r\n}\r\nvoid\r\nHiSax_rmlist(struct IsdnCardState *cs,\r\nstruct PStack *st)\r\n{\r\nstruct PStack *p;\r\nFsmDelTimer(&st->l1.timer, 0);\r\nif (cs->stlist == st)\r\ncs->stlist = st->next;\r\nelse {\r\np = cs->stlist;\r\nwhile (p)\r\nif (p->next == st) {\r\np->next = st->next;\r\nreturn;\r\n} else\r\np = p->next;\r\n}\r\n}\r\nvoid\r\ninit_bcstate(struct IsdnCardState *cs, int bc)\r\n{\r\nstruct BCState *bcs = cs->bcs + bc;\r\nbcs->cs = cs;\r\nbcs->channel = bc;\r\nINIT_WORK(&bcs->tqueue, BChannel_bh);\r\nspin_lock_init(&bcs->aclock);\r\nbcs->BC_SetStack = NULL;\r\nbcs->BC_Close = NULL;\r\nbcs->Flag = 0;\r\n}\r\nstatic char *\r\nl2cmd(u_char cmd)\r\n{\r\nswitch (cmd & ~0x10) {\r\ncase 1:\r\nreturn "RR";\r\ncase 5:\r\nreturn "RNR";\r\ncase 9:\r\nreturn "REJ";\r\ncase 0x6f:\r\nreturn "SABME";\r\ncase 0x0f:\r\nreturn "DM";\r\ncase 3:\r\nreturn "UI";\r\ncase 0x43:\r\nreturn "DISC";\r\ncase 0x63:\r\nreturn "UA";\r\ncase 0x87:\r\nreturn "FRMR";\r\ncase 0xaf:\r\nreturn "XID";\r\ndefault:\r\nif (!(cmd & 1))\r\nreturn "I";\r\nelse\r\nreturn "invalid command";\r\n}\r\n}\r\nstatic char *\r\nl2frames(u_char *ptr)\r\n{\r\nswitch (ptr[2] & ~0x10) {\r\ncase 1:\r\ncase 5:\r\ncase 9:\r\nsprintf(tmpdeb, "%s[%d](nr %d)", l2cmd(ptr[2]), ptr[3] & 1, ptr[3] >> 1);\r\nbreak;\r\ncase 0x6f:\r\ncase 0x0f:\r\ncase 3:\r\ncase 0x43:\r\ncase 0x63:\r\ncase 0x87:\r\ncase 0xaf:\r\nsprintf(tmpdeb, "%s[%d]", l2cmd(ptr[2]), (ptr[2] & 0x10) >> 4);\r\nbreak;\r\ndefault:\r\nif (!(ptr[2] & 1)) {\r\nsprintf(tmpdeb, "I[%d](ns %d, nr %d)", ptr[3] & 1, ptr[2] >> 1, ptr[3] >> 1);\r\nbreak;\r\n} else\r\nreturn "invalid command";\r\n}\r\nreturn tmpdeb;\r\n}\r\nvoid\r\nLogl2Frame(struct IsdnCardState *cs, struct sk_buff *skb, char *buf, int dir)\r\n{\r\nu_char *ptr;\r\nptr = skb->data;\r\nif (ptr[0] & 1 || !(ptr[1] & 1))\r\ndebugl1(cs, "Address not LAPD");\r\nelse\r\ndebugl1(cs, "%s %s: %s%c (sapi %d, tei %d)",\r\n(dir ? "<-" : "->"), buf, l2frames(ptr),\r\n((ptr[0] & 2) >> 1) == dir ? 'C' : 'R', ptr[0] >> 2, ptr[1] >> 1);\r\n}\r\nstatic void\r\nl1_reset(struct FsmInst *fi, int event, void *arg)\r\n{\r\nFsmChangeState(fi, ST_L1_F3);\r\n}\r\nstatic void\r\nl1_deact_cnf(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmChangeState(fi, ST_L1_F3);\r\nif (test_bit(FLG_L1_ACTIVATING, &st->l1.Flags))\r\nst->l1.l1hw(st, HW_ENABLE | REQUEST, NULL);\r\n}\r\nstatic void\r\nl1_deact_req_s(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmChangeState(fi, ST_L1_F3);\r\nFsmRestartTimer(&st->l1.timer, 550, EV_TIMER_DEACT, NULL, 2);\r\ntest_and_set_bit(FLG_L1_DEACTTIMER, &st->l1.Flags);\r\n}\r\nstatic void\r\nl1_power_up_s(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nif (test_bit(FLG_L1_ACTIVATING, &st->l1.Flags)) {\r\nFsmChangeState(fi, ST_L1_F4);\r\nst->l1.l1hw(st, HW_INFO3 | REQUEST, NULL);\r\nFsmRestartTimer(&st->l1.timer, TIMER3_VALUE, EV_TIMER3, NULL, 2);\r\ntest_and_set_bit(FLG_L1_T3RUN, &st->l1.Flags);\r\n} else\r\nFsmChangeState(fi, ST_L1_F3);\r\n}\r\nstatic void\r\nl1_go_F5(struct FsmInst *fi, int event, void *arg)\r\n{\r\nFsmChangeState(fi, ST_L1_F5);\r\n}\r\nstatic void\r\nl1_go_F8(struct FsmInst *fi, int event, void *arg)\r\n{\r\nFsmChangeState(fi, ST_L1_F8);\r\n}\r\nstatic void\r\nl1_info2_ind(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\n#ifdef HISAX_UINTERFACE\r\nif (test_bit(FLG_L1_UINT, &st->l1.Flags))\r\nFsmChangeState(fi, ST_L1_SYNC2);\r\nelse\r\n#endif\r\nFsmChangeState(fi, ST_L1_F6);\r\nst->l1.l1hw(st, HW_INFO3 | REQUEST, NULL);\r\n}\r\nstatic void\r\nl1_info4_ind(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\n#ifdef HISAX_UINTERFACE\r\nif (test_bit(FLG_L1_UINT, &st->l1.Flags))\r\nFsmChangeState(fi, ST_L1_TRANS);\r\nelse\r\n#endif\r\nFsmChangeState(fi, ST_L1_F7);\r\nst->l1.l1hw(st, HW_INFO3 | REQUEST, NULL);\r\nif (test_and_clear_bit(FLG_L1_DEACTTIMER, &st->l1.Flags))\r\nFsmDelTimer(&st->l1.timer, 4);\r\nif (!test_bit(FLG_L1_ACTIVATED, &st->l1.Flags)) {\r\nif (test_and_clear_bit(FLG_L1_T3RUN, &st->l1.Flags))\r\nFsmDelTimer(&st->l1.timer, 3);\r\nFsmRestartTimer(&st->l1.timer, 110, EV_TIMER_ACT, NULL, 2);\r\ntest_and_set_bit(FLG_L1_ACTTIMER, &st->l1.Flags);\r\n}\r\n}\r\nstatic void\r\nl1_timer3(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\ntest_and_clear_bit(FLG_L1_T3RUN, &st->l1.Flags);\r\nif (test_and_clear_bit(FLG_L1_ACTIVATING, &st->l1.Flags))\r\nL1deactivated(st->l1.hardware);\r\n#ifdef HISAX_UINTERFACE\r\nif (!test_bit(FLG_L1_UINT, &st->l1.Flags))\r\n#endif\r\nif (st->l1.l1m.state != ST_L1_F6) {\r\nFsmChangeState(fi, ST_L1_F3);\r\nst->l1.l1hw(st, HW_ENABLE | REQUEST, NULL);\r\n}\r\n}\r\nstatic void\r\nl1_timer_act(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\ntest_and_clear_bit(FLG_L1_ACTTIMER, &st->l1.Flags);\r\ntest_and_set_bit(FLG_L1_ACTIVATED, &st->l1.Flags);\r\nL1activated(st->l1.hardware);\r\n}\r\nstatic void\r\nl1_timer_deact(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\ntest_and_clear_bit(FLG_L1_DEACTTIMER, &st->l1.Flags);\r\ntest_and_clear_bit(FLG_L1_ACTIVATED, &st->l1.Flags);\r\nL1deactivated(st->l1.hardware);\r\nst->l1.l1hw(st, HW_DEACTIVATE | RESPONSE, NULL);\r\n}\r\nstatic void\r\nl1_activate_s(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nst->l1.l1hw(st, HW_RESET | REQUEST, NULL);\r\n}\r\nstatic void\r\nl1_activate_no(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nif ((!test_bit(FLG_L1_DEACTTIMER, &st->l1.Flags)) && (!test_bit(FLG_L1_T3RUN, &st->l1.Flags))) {\r\ntest_and_clear_bit(FLG_L1_ACTIVATING, &st->l1.Flags);\r\nL1deactivated(st->l1.hardware);\r\n}\r\n}\r\nstatic void\r\nl1_deact_req_u(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmChangeState(fi, ST_L1_RESET);\r\nFsmRestartTimer(&st->l1.timer, 550, EV_TIMER_DEACT, NULL, 2);\r\ntest_and_set_bit(FLG_L1_DEACTTIMER, &st->l1.Flags);\r\nst->l1.l1hw(st, HW_ENABLE | REQUEST, NULL);\r\n}\r\nstatic void\r\nl1_power_up_u(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmRestartTimer(&st->l1.timer, TIMER3_VALUE, EV_TIMER3, NULL, 2);\r\ntest_and_set_bit(FLG_L1_T3RUN, &st->l1.Flags);\r\n}\r\nstatic void\r\nl1_info0_ind(struct FsmInst *fi, int event, void *arg)\r\n{\r\nFsmChangeState(fi, ST_L1_DEACT);\r\n}\r\nstatic void\r\nl1_activate_u(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nst->l1.l1hw(st, HW_INFO1 | REQUEST, NULL);\r\n}\r\nstatic void\r\nl1b_activate(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmChangeState(fi, ST_L1_WAIT_ACT);\r\nFsmRestartTimer(&st->l1.timer, st->l1.delay, EV_TIMER_ACT, NULL, 2);\r\n}\r\nstatic void\r\nl1b_deactivate(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmChangeState(fi, ST_L1_WAIT_DEACT);\r\nFsmRestartTimer(&st->l1.timer, 10, EV_TIMER_DEACT, NULL, 2);\r\n}\r\nstatic void\r\nl1b_timer_act(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmChangeState(fi, ST_L1_ACTIV);\r\nst->l1.l1l2(st, PH_ACTIVATE | CONFIRM, NULL);\r\n}\r\nstatic void\r\nl1b_timer_deact(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmChangeState(fi, ST_L1_NULL);\r\nst->l2.l2l1(st, PH_DEACTIVATE | CONFIRM, NULL);\r\n}\r\nint __init\r\nIsdnl1New(void)\r\n{\r\nint retval;\r\nl1fsm_s.state_count = L1S_STATE_COUNT;\r\nl1fsm_s.event_count = L1_EVENT_COUNT;\r\nl1fsm_s.strEvent = strL1Event;\r\nl1fsm_s.strState = strL1SState;\r\nretval = FsmNew(&l1fsm_s, L1SFnList, ARRAY_SIZE(L1SFnList));\r\nif (retval)\r\nreturn retval;\r\nl1fsm_b.state_count = L1B_STATE_COUNT;\r\nl1fsm_b.event_count = L1_EVENT_COUNT;\r\nl1fsm_b.strEvent = strL1Event;\r\nl1fsm_b.strState = strL1BState;\r\nretval = FsmNew(&l1fsm_b, L1BFnList, ARRAY_SIZE(L1BFnList));\r\nif (retval) {\r\nFsmFree(&l1fsm_s);\r\nreturn retval;\r\n}\r\n#ifdef HISAX_UINTERFACE\r\nl1fsm_u.state_count = L1U_STATE_COUNT;\r\nl1fsm_u.event_count = L1_EVENT_COUNT;\r\nl1fsm_u.strEvent = strL1Event;\r\nl1fsm_u.strState = strL1UState;\r\nretval = FsmNew(&l1fsm_u, L1UFnList, ARRAY_SIZE(L1UFnList));\r\nif (retval) {\r\nFsmFree(&l1fsm_s);\r\nFsmFree(&l1fsm_b);\r\nreturn retval;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nvoid Isdnl1Free(void)\r\n{\r\n#ifdef HISAX_UINTERFACE\r\nFsmFree(&l1fsm_u);\r\n#endif\r\nFsmFree(&l1fsm_s);\r\nFsmFree(&l1fsm_b);\r\n}\r\nstatic void\r\ndch_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct IsdnCardState *cs = (struct IsdnCardState *) st->l1.hardware;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\ncase (PH_PULL | REQUEST):\r\ncase (PH_PULL | INDICATION):\r\nst->l1.l1hw(st, pr, arg);\r\nbreak;\r\ncase (PH_ACTIVATE | REQUEST):\r\nif (cs->debug)\r\ndebugl1(cs, "PH_ACTIVATE_REQ %s",\r\nst->l1.l1m.fsm->strState[st->l1.l1m.state]);\r\nif (test_bit(FLG_L1_ACTIVATED, &st->l1.Flags))\r\nst->l1.l1l2(st, PH_ACTIVATE | CONFIRM, NULL);\r\nelse {\r\ntest_and_set_bit(FLG_L1_ACTIVATING, &st->l1.Flags);\r\nFsmEvent(&st->l1.l1m, EV_PH_ACTIVATE, arg);\r\n}\r\nbreak;\r\ncase (PH_TESTLOOP | REQUEST):\r\nif (1 & (long) arg)\r\ndebugl1(cs, "PH_TEST_LOOP B1");\r\nif (2 & (long) arg)\r\ndebugl1(cs, "PH_TEST_LOOP B2");\r\nif (!(3 & (long) arg))\r\ndebugl1(cs, "PH_TEST_LOOP DISABLED");\r\nst->l1.l1hw(st, HW_TESTLOOP | REQUEST, arg);\r\nbreak;\r\ndefault:\r\nif (cs->debug)\r\ndebugl1(cs, "dch_l2l1 msg %04X unhandled", pr);\r\nbreak;\r\n}\r\n}\r\nvoid\r\nl1_msg(struct IsdnCardState *cs, int pr, void *arg) {\r\nstruct PStack *st;\r\nst = cs->stlist;\r\nwhile (st) {\r\nswitch (pr) {\r\ncase (HW_RESET | INDICATION):\r\nFsmEvent(&st->l1.l1m, EV_RESET_IND, arg);\r\nbreak;\r\ncase (HW_DEACTIVATE | CONFIRM):\r\nFsmEvent(&st->l1.l1m, EV_DEACT_CNF, arg);\r\nbreak;\r\ncase (HW_DEACTIVATE | INDICATION):\r\nFsmEvent(&st->l1.l1m, EV_DEACT_IND, arg);\r\nbreak;\r\ncase (HW_POWERUP | CONFIRM):\r\nFsmEvent(&st->l1.l1m, EV_POWER_UP, arg);\r\nbreak;\r\ncase (HW_RSYNC | INDICATION):\r\nFsmEvent(&st->l1.l1m, EV_RSYNC_IND, arg);\r\nbreak;\r\ncase (HW_INFO2 | INDICATION):\r\nFsmEvent(&st->l1.l1m, EV_INFO2_IND, arg);\r\nbreak;\r\ncase (HW_INFO4_P8 | INDICATION):\r\ncase (HW_INFO4_P10 | INDICATION):\r\nFsmEvent(&st->l1.l1m, EV_INFO4_IND, arg);\r\nbreak;\r\ndefault:\r\nif (cs->debug)\r\ndebugl1(cs, "l1msg %04X unhandled", pr);\r\nbreak;\r\n}\r\nst = st->next;\r\n}\r\n}\r\nvoid\r\nl1_msg_b(struct PStack *st, int pr, void *arg) {\r\nswitch (pr) {\r\ncase (PH_ACTIVATE | REQUEST):\r\nFsmEvent(&st->l1.l1m, EV_PH_ACTIVATE, NULL);\r\nbreak;\r\ncase (PH_DEACTIVATE | REQUEST):\r\nFsmEvent(&st->l1.l1m, EV_PH_DEACTIVATE, NULL);\r\nbreak;\r\n}\r\n}\r\nvoid\r\nsetstack_HiSax(struct PStack *st, struct IsdnCardState *cs)\r\n{\r\nst->l1.hardware = cs;\r\nst->protocol = cs->protocol;\r\nst->l1.l1m.fsm = &l1fsm_s;\r\nst->l1.l1m.state = ST_L1_F3;\r\nst->l1.Flags = 0;\r\n#ifdef HISAX_UINTERFACE\r\nif (test_bit(FLG_HW_L1_UINT, &cs->HW_Flags)) {\r\nst->l1.l1m.fsm = &l1fsm_u;\r\nst->l1.l1m.state = ST_L1_RESET;\r\nst->l1.Flags = FLG_L1_UINT;\r\n}\r\n#endif\r\nst->l1.l1m.debug = cs->debug;\r\nst->l1.l1m.userdata = st;\r\nst->l1.l1m.userint = 0;\r\nst->l1.l1m.printdebug = l1m_debug;\r\nFsmInitTimer(&st->l1.l1m, &st->l1.timer);\r\nsetstack_tei(st);\r\nsetstack_manager(st);\r\nst->l1.stlistp = &(cs->stlist);\r\nst->l2.l2l1 = dch_l2l1;\r\nif (cs->setstack_d)\r\ncs->setstack_d(st, cs);\r\n}\r\nvoid\r\nsetstack_l1_B(struct PStack *st)\r\n{\r\nstruct IsdnCardState *cs = st->l1.hardware;\r\nst->l1.l1m.fsm = &l1fsm_b;\r\nst->l1.l1m.state = ST_L1_NULL;\r\nst->l1.l1m.debug = cs->debug;\r\nst->l1.l1m.userdata = st;\r\nst->l1.l1m.userint = 0;\r\nst->l1.l1m.printdebug = l1m_debug;\r\nst->l1.Flags = 0;\r\nFsmInitTimer(&st->l1.l1m, &st->l1.timer);\r\n}
