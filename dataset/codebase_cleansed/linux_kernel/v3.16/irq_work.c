static bool irq_work_claim(struct irq_work *work)\r\n{\r\nunsigned long flags, oflags, nflags;\r\nflags = work->flags & ~IRQ_WORK_PENDING;\r\nfor (;;) {\r\nnflags = flags | IRQ_WORK_FLAGS;\r\noflags = cmpxchg(&work->flags, flags, nflags);\r\nif (oflags == flags)\r\nbreak;\r\nif (oflags & IRQ_WORK_PENDING)\r\nreturn false;\r\nflags = oflags;\r\ncpu_relax();\r\n}\r\nreturn true;\r\n}\r\nvoid __weak arch_irq_work_raise(void)\r\n{\r\n}\r\nbool irq_work_queue(struct irq_work *work)\r\n{\r\nif (!irq_work_claim(work))\r\nreturn false;\r\npreempt_disable();\r\nllist_add(&work->llnode, &__get_cpu_var(irq_work_list));\r\nif (!(work->flags & IRQ_WORK_LAZY) || tick_nohz_tick_stopped()) {\r\nif (!this_cpu_cmpxchg(irq_work_raised, 0, 1))\r\narch_irq_work_raise();\r\n}\r\npreempt_enable();\r\nreturn true;\r\n}\r\nbool irq_work_needs_cpu(void)\r\n{\r\nstruct llist_head *this_list;\r\nthis_list = &__get_cpu_var(irq_work_list);\r\nif (llist_empty(this_list))\r\nreturn false;\r\nWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\r\nreturn true;\r\n}\r\nstatic void __irq_work_run(void)\r\n{\r\nunsigned long flags;\r\nstruct irq_work *work;\r\nstruct llist_head *this_list;\r\nstruct llist_node *llnode;\r\n__this_cpu_write(irq_work_raised, 0);\r\nbarrier();\r\nthis_list = &__get_cpu_var(irq_work_list);\r\nif (llist_empty(this_list))\r\nreturn;\r\nBUG_ON(!irqs_disabled());\r\nllnode = llist_del_all(this_list);\r\nwhile (llnode != NULL) {\r\nwork = llist_entry(llnode, struct irq_work, llnode);\r\nllnode = llist_next(llnode);\r\nflags = work->flags & ~IRQ_WORK_PENDING;\r\nxchg(&work->flags, flags);\r\nwork->func(work);\r\n(void)cmpxchg(&work->flags, flags, flags & ~IRQ_WORK_BUSY);\r\n}\r\n}\r\nvoid irq_work_run(void)\r\n{\r\nBUG_ON(!in_irq());\r\n__irq_work_run();\r\n}\r\nvoid irq_work_sync(struct irq_work *work)\r\n{\r\nWARN_ON_ONCE(irqs_disabled());\r\nwhile (work->flags & IRQ_WORK_BUSY)\r\ncpu_relax();\r\n}\r\nstatic int irq_work_cpu_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nlong cpu = (long)hcpu;\r\nswitch (action) {\r\ncase CPU_DYING:\r\nif (WARN_ON_ONCE(cpu != smp_processor_id()))\r\nbreak;\r\n__irq_work_run();\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic __init int irq_work_init_cpu_notifier(void)\r\n{\r\ncpu_notify.notifier_call = irq_work_cpu_notify;\r\ncpu_notify.priority = 0;\r\nregister_cpu_notifier(&cpu_notify);\r\nreturn 0;\r\n}
