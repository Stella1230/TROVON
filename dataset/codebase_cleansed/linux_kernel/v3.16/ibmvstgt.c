static struct vio_port *target_to_port(struct srp_target *target)\r\n{\r\nreturn (struct vio_port *) target->ldata;\r\n}\r\nstatic inline union viosrp_iu *vio_iu(struct iu_entry *iue)\r\n{\r\nreturn (union viosrp_iu *) (iue->sbuf->buf);\r\n}\r\nstatic int send_iu(struct iu_entry *iue, uint64_t length, uint8_t format)\r\n{\r\nstruct srp_target *target = iue->target;\r\nstruct vio_port *vport = target_to_port(target);\r\nlong rc, rc1;\r\nunion {\r\nstruct viosrp_crq cooked;\r\nuint64_t raw[2];\r\n} crq;\r\nrc = h_copy_rdma(length, vport->liobn, iue->sbuf->dma,\r\nvport->riobn, iue->remote_token);\r\nif (rc)\r\neprintk("Error %ld transferring data\n", rc);\r\ncrq.cooked.valid = 0x80;\r\ncrq.cooked.format = format;\r\ncrq.cooked.reserved = 0x00;\r\ncrq.cooked.timeout = 0x00;\r\ncrq.cooked.IU_length = length;\r\ncrq.cooked.IU_data_ptr = vio_iu(iue)->srp.rsp.tag;\r\nif (rc == 0)\r\ncrq.cooked.status = 0x99;\r\nelse\r\ncrq.cooked.status = 0x00;\r\nrc1 = h_send_crq(vport->dma_dev->unit_address, crq.raw[0], crq.raw[1]);\r\nif (rc1) {\r\neprintk("%ld sending response\n", rc1);\r\nreturn rc1;\r\n}\r\nreturn rc;\r\n}\r\nstatic int send_rsp(struct iu_entry *iue, struct scsi_cmnd *sc,\r\nunsigned char status, unsigned char asc)\r\n{\r\nunion viosrp_iu *iu = vio_iu(iue);\r\nuint64_t tag = iu->srp.rsp.tag;\r\nif (test_bit(V_LINKED, &iue->flags) && (status == NO_SENSE))\r\nstatus = 0x10;\r\nmemset(iu, 0, sizeof(struct srp_rsp));\r\niu->srp.rsp.opcode = SRP_RSP;\r\niu->srp.rsp.req_lim_delta = 1;\r\niu->srp.rsp.tag = tag;\r\nif (test_bit(V_DIOVER, &iue->flags))\r\niu->srp.rsp.flags |= SRP_RSP_FLAG_DIOVER;\r\niu->srp.rsp.data_in_res_cnt = 0;\r\niu->srp.rsp.data_out_res_cnt = 0;\r\niu->srp.rsp.flags &= ~SRP_RSP_FLAG_RSPVALID;\r\niu->srp.rsp.resp_data_len = 0;\r\niu->srp.rsp.status = status;\r\nif (status) {\r\nuint8_t *sense = iu->srp.rsp.data;\r\nif (sc) {\r\niu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;\r\niu->srp.rsp.sense_data_len = SCSI_SENSE_BUFFERSIZE;\r\nmemcpy(sense, sc->sense_buffer, SCSI_SENSE_BUFFERSIZE);\r\n} else {\r\niu->srp.rsp.status = SAM_STAT_CHECK_CONDITION;\r\niu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;\r\niu->srp.rsp.sense_data_len = SRP_RSP_SENSE_DATA_LEN;\r\nsense[0] = (0x1 << 7 | 0x70);\r\nsense[2] = status;\r\nsense[7] = 0xa;\r\nsense[12] = asc;\r\n}\r\n}\r\nsend_iu(iue, sizeof(iu->srp.rsp) + SRP_RSP_SENSE_DATA_LEN,\r\nVIOSRP_SRP_FORMAT);\r\nreturn 0;\r\n}\r\nstatic void handle_cmd_queue(struct srp_target *target)\r\n{\r\nstruct Scsi_Host *shost = target->shost;\r\nstruct srp_rport *rport = target_to_port(target)->rport;\r\nstruct iu_entry *iue;\r\nstruct srp_cmd *cmd;\r\nunsigned long flags;\r\nint err;\r\nretry:\r\nspin_lock_irqsave(&target->lock, flags);\r\nlist_for_each_entry(iue, &target->cmd_queue, ilist) {\r\nif (!test_and_set_bit(V_FLYING, &iue->flags)) {\r\nspin_unlock_irqrestore(&target->lock, flags);\r\ncmd = iue->sbuf->buf;\r\nerr = srp_cmd_queue(shost, cmd, iue,\r\n(unsigned long)rport, 0);\r\nif (err) {\r\neprintk("cannot queue cmd %p %d\n", cmd, err);\r\nsrp_iu_put(iue);\r\n}\r\ngoto retry;\r\n}\r\n}\r\nspin_unlock_irqrestore(&target->lock, flags);\r\n}\r\nstatic int ibmvstgt_rdma(struct scsi_cmnd *sc, struct scatterlist *sg, int nsg,\r\nstruct srp_direct_buf *md, int nmd,\r\nenum dma_data_direction dir, unsigned int rest)\r\n{\r\nstruct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;\r\nstruct srp_target *target = iue->target;\r\nstruct vio_port *vport = target_to_port(target);\r\ndma_addr_t token;\r\nlong err;\r\nunsigned int done = 0;\r\nint i, sidx, soff;\r\nsidx = soff = 0;\r\ntoken = sg_dma_address(sg + sidx);\r\nfor (i = 0; i < nmd && rest; i++) {\r\nunsigned int mdone, mlen;\r\nmlen = min(rest, md[i].len);\r\nfor (mdone = 0; mlen;) {\r\nint slen = min(sg_dma_len(sg + sidx) - soff, mlen);\r\nif (dir == DMA_TO_DEVICE)\r\nerr = h_copy_rdma(slen,\r\nvport->riobn,\r\nmd[i].va + mdone,\r\nvport->liobn,\r\ntoken + soff);\r\nelse\r\nerr = h_copy_rdma(slen,\r\nvport->liobn,\r\ntoken + soff,\r\nvport->riobn,\r\nmd[i].va + mdone);\r\nif (err != H_SUCCESS) {\r\neprintk("rdma error %d %d %ld\n", dir, slen, err);\r\nreturn -EIO;\r\n}\r\nmlen -= slen;\r\nmdone += slen;\r\nsoff += slen;\r\ndone += slen;\r\nif (soff == sg_dma_len(sg + sidx)) {\r\nsidx++;\r\nsoff = 0;\r\ntoken = sg_dma_address(sg + sidx);\r\nif (sidx > nsg) {\r\neprintk("out of sg %p %d %d\n",\r\niue, sidx, nsg);\r\nreturn -EIO;\r\n}\r\n}\r\n};\r\nrest -= mlen;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ibmvstgt_cmd_done(struct scsi_cmnd *sc,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nunsigned long flags;\r\nstruct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;\r\nstruct srp_target *target = iue->target;\r\nint err = 0;\r\ndprintk("%p %p %x %u\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0],\r\nscsi_sg_count(sc));\r\nif (scsi_sg_count(sc))\r\nerr = srp_transfer_data(sc, &vio_iu(iue)->srp.cmd, ibmvstgt_rdma, 1, 1);\r\nspin_lock_irqsave(&target->lock, flags);\r\nlist_del(&iue->ilist);\r\nspin_unlock_irqrestore(&target->lock, flags);\r\nif (err|| sc->result != SAM_STAT_GOOD) {\r\neprintk("operation failed %p %d %x\n",\r\niue, sc->result, vio_iu(iue)->srp.cmd.cdb[0]);\r\nsend_rsp(iue, sc, HARDWARE_ERROR, 0x00);\r\n} else\r\nsend_rsp(iue, sc, NO_SENSE, 0x00);\r\ndone(sc);\r\nsrp_iu_put(iue);\r\nreturn 0;\r\n}\r\nint send_adapter_info(struct iu_entry *iue,\r\ndma_addr_t remote_buffer, uint16_t length)\r\n{\r\nstruct srp_target *target = iue->target;\r\nstruct vio_port *vport = target_to_port(target);\r\nstruct Scsi_Host *shost = target->shost;\r\ndma_addr_t data_token;\r\nstruct mad_adapter_info_data *info;\r\nint err;\r\ninfo = dma_alloc_coherent(target->dev, sizeof(*info), &data_token,\r\nGFP_KERNEL);\r\nif (!info) {\r\neprintk("bad dma_alloc_coherent %p\n", target);\r\nreturn 1;\r\n}\r\nerr = h_copy_rdma(sizeof(*info), vport->riobn, remote_buffer,\r\nvport->liobn, data_token);\r\nif (err == H_SUCCESS) {\r\ndprintk("Client connect: %s (%d)\n",\r\ninfo->partition_name, info->partition_number);\r\n}\r\nmemset(info, 0, sizeof(*info));\r\nstrcpy(info->srp_version, "16.a");\r\nstrncpy(info->partition_name, partition_name,\r\nsizeof(info->partition_name));\r\ninfo->partition_number = partition_number;\r\ninfo->mad_version = 1;\r\ninfo->os_type = 2;\r\ninfo->port_max_txu[0] = shost->hostt->max_sectors << 9;\r\nerr = h_copy_rdma(sizeof(*info), vport->liobn, data_token,\r\nvport->riobn, remote_buffer);\r\ndma_free_coherent(target->dev, sizeof(*info), info, data_token);\r\nif (err != H_SUCCESS) {\r\neprintk("Error sending adapter info %d\n", err);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void process_login(struct iu_entry *iue)\r\n{\r\nunion viosrp_iu *iu = vio_iu(iue);\r\nstruct srp_login_rsp *rsp = &iu->srp.login_rsp;\r\nuint64_t tag = iu->srp.rsp.tag;\r\nstruct Scsi_Host *shost = iue->target->shost;\r\nstruct srp_target *target = host_to_srp_target(shost);\r\nstruct vio_port *vport = target_to_port(target);\r\nstruct srp_rport_identifiers ids;\r\nmemset(&ids, 0, sizeof(ids));\r\nsprintf(ids.port_id, "%x", vport->dma_dev->unit_address);\r\nids.roles = SRP_RPORT_ROLE_INITIATOR;\r\nif (!vport->rport)\r\nvport->rport = srp_rport_add(shost, &ids);\r\nmemset(iu, 0, sizeof(struct srp_login_rsp));\r\nrsp->opcode = SRP_LOGIN_RSP;\r\nrsp->req_lim_delta = INITIAL_SRP_LIMIT;\r\nrsp->tag = tag;\r\nrsp->max_it_iu_len = sizeof(union srp_iu);\r\nrsp->max_ti_iu_len = sizeof(union srp_iu);\r\nrsp->buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;\r\nsend_iu(iue, sizeof(*rsp), VIOSRP_SRP_FORMAT);\r\n}\r\nstatic inline void queue_cmd(struct iu_entry *iue)\r\n{\r\nstruct srp_target *target = iue->target;\r\nunsigned long flags;\r\nspin_lock_irqsave(&target->lock, flags);\r\nlist_add_tail(&iue->ilist, &target->cmd_queue);\r\nspin_unlock_irqrestore(&target->lock, flags);\r\n}\r\nstatic int process_tsk_mgmt(struct iu_entry *iue)\r\n{\r\nunion viosrp_iu *iu = vio_iu(iue);\r\nint fn;\r\ndprintk("%p %u\n", iue, iu->srp.tsk_mgmt.tsk_mgmt_func);\r\nswitch (iu->srp.tsk_mgmt.tsk_mgmt_func) {\r\ncase SRP_TSK_ABORT_TASK:\r\nfn = ABORT_TASK;\r\nbreak;\r\ncase SRP_TSK_ABORT_TASK_SET:\r\nfn = ABORT_TASK_SET;\r\nbreak;\r\ncase SRP_TSK_CLEAR_TASK_SET:\r\nfn = CLEAR_TASK_SET;\r\nbreak;\r\ncase SRP_TSK_LUN_RESET:\r\nfn = LOGICAL_UNIT_RESET;\r\nbreak;\r\ncase SRP_TSK_CLEAR_ACA:\r\nfn = CLEAR_ACA;\r\nbreak;\r\ndefault:\r\nfn = 0;\r\n}\r\nif (fn)\r\nscsi_tgt_tsk_mgmt_request(iue->target->shost,\r\n(unsigned long)iue->target->shost,\r\nfn,\r\niu->srp.tsk_mgmt.task_tag,\r\n(struct scsi_lun *) &iu->srp.tsk_mgmt.lun,\r\niue);\r\nelse\r\nsend_rsp(iue, NULL, ILLEGAL_REQUEST, 0x20);\r\nreturn !fn;\r\n}\r\nstatic int process_mad_iu(struct iu_entry *iue)\r\n{\r\nunion viosrp_iu *iu = vio_iu(iue);\r\nstruct viosrp_adapter_info *info;\r\nstruct viosrp_host_config *conf;\r\nswitch (iu->mad.empty_iu.common.type) {\r\ncase VIOSRP_EMPTY_IU_TYPE:\r\neprintk("%s\n", "Unsupported EMPTY MAD IU");\r\nbreak;\r\ncase VIOSRP_ERROR_LOG_TYPE:\r\neprintk("%s\n", "Unsupported ERROR LOG MAD IU");\r\niu->mad.error_log.common.status = 1;\r\nsend_iu(iue, sizeof(iu->mad.error_log), VIOSRP_MAD_FORMAT);\r\nbreak;\r\ncase VIOSRP_ADAPTER_INFO_TYPE:\r\ninfo = &iu->mad.adapter_info;\r\ninfo->common.status = send_adapter_info(iue, info->buffer,\r\ninfo->common.length);\r\nsend_iu(iue, sizeof(*info), VIOSRP_MAD_FORMAT);\r\nbreak;\r\ncase VIOSRP_HOST_CONFIG_TYPE:\r\nconf = &iu->mad.host_config;\r\nconf->common.status = 1;\r\nsend_iu(iue, sizeof(*conf), VIOSRP_MAD_FORMAT);\r\nbreak;\r\ndefault:\r\neprintk("Unknown type %u\n", iu->srp.rsp.opcode);\r\n}\r\nreturn 1;\r\n}\r\nstatic int process_srp_iu(struct iu_entry *iue)\r\n{\r\nunion viosrp_iu *iu = vio_iu(iue);\r\nint done = 1;\r\nu8 opcode = iu->srp.rsp.opcode;\r\nswitch (opcode) {\r\ncase SRP_LOGIN_REQ:\r\nprocess_login(iue);\r\nbreak;\r\ncase SRP_TSK_MGMT:\r\ndone = process_tsk_mgmt(iue);\r\nbreak;\r\ncase SRP_CMD:\r\nqueue_cmd(iue);\r\ndone = 0;\r\nbreak;\r\ncase SRP_LOGIN_RSP:\r\ncase SRP_I_LOGOUT:\r\ncase SRP_T_LOGOUT:\r\ncase SRP_RSP:\r\ncase SRP_CRED_REQ:\r\ncase SRP_CRED_RSP:\r\ncase SRP_AER_REQ:\r\ncase SRP_AER_RSP:\r\neprintk("Unsupported type %u\n", opcode);\r\nbreak;\r\ndefault:\r\neprintk("Unknown type %u\n", opcode);\r\n}\r\nreturn done;\r\n}\r\nstatic void process_iu(struct viosrp_crq *crq, struct srp_target *target)\r\n{\r\nstruct vio_port *vport = target_to_port(target);\r\nstruct iu_entry *iue;\r\nlong err;\r\nint done = 1;\r\niue = srp_iu_get(target);\r\nif (!iue) {\r\neprintk("Error getting IU from pool, %p\n", target);\r\nreturn;\r\n}\r\niue->remote_token = crq->IU_data_ptr;\r\nerr = h_copy_rdma(crq->IU_length, vport->riobn,\r\niue->remote_token, vport->liobn, iue->sbuf->dma);\r\nif (err != H_SUCCESS) {\r\neprintk("%ld transferring data error %p\n", err, iue);\r\ngoto out;\r\n}\r\nif (crq->format == VIOSRP_MAD_FORMAT)\r\ndone = process_mad_iu(iue);\r\nelse\r\ndone = process_srp_iu(iue);\r\nout:\r\nif (done)\r\nsrp_iu_put(iue);\r\n}\r\nstatic irqreturn_t ibmvstgt_interrupt(int dummy, void *data)\r\n{\r\nstruct srp_target *target = data;\r\nstruct vio_port *vport = target_to_port(target);\r\nvio_disable_interrupts(vport->dma_dev);\r\nqueue_work(vtgtd, &vport->crq_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int crq_queue_create(struct crq_queue *queue, struct srp_target *target)\r\n{\r\nint err;\r\nstruct vio_port *vport = target_to_port(target);\r\nqueue->msgs = (struct viosrp_crq *) get_zeroed_page(GFP_KERNEL);\r\nif (!queue->msgs)\r\ngoto malloc_failed;\r\nqueue->size = PAGE_SIZE / sizeof(*queue->msgs);\r\nqueue->msg_token = dma_map_single(target->dev, queue->msgs,\r\nqueue->size * sizeof(*queue->msgs),\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(target->dev, queue->msg_token))\r\ngoto map_failed;\r\nerr = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,\r\nPAGE_SIZE);\r\nif (err == H_RESOURCE) {\r\ndo {\r\nerr = h_free_crq(vport->dma_dev->unit_address);\r\n} while (err == H_BUSY || H_IS_LONG_BUSY(err));\r\nerr = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,\r\nPAGE_SIZE);\r\n}\r\nif (err != H_SUCCESS && err != 2) {\r\neprintk("Error 0x%x opening virtual adapter\n", err);\r\ngoto reg_crq_failed;\r\n}\r\nerr = request_irq(vport->dma_dev->irq, &ibmvstgt_interrupt,\r\n0, "ibmvstgt", target);\r\nif (err)\r\ngoto req_irq_failed;\r\nvio_enable_interrupts(vport->dma_dev);\r\nh_send_crq(vport->dma_dev->unit_address, 0xC001000000000000, 0);\r\nqueue->cur = 0;\r\nspin_lock_init(&queue->lock);\r\nreturn 0;\r\nreq_irq_failed:\r\ndo {\r\nerr = h_free_crq(vport->dma_dev->unit_address);\r\n} while (err == H_BUSY || H_IS_LONG_BUSY(err));\r\nreg_crq_failed:\r\ndma_unmap_single(target->dev, queue->msg_token,\r\nqueue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);\r\nmap_failed:\r\nfree_page((unsigned long) queue->msgs);\r\nmalloc_failed:\r\nreturn -ENOMEM;\r\n}\r\nstatic void crq_queue_destroy(struct srp_target *target)\r\n{\r\nstruct vio_port *vport = target_to_port(target);\r\nstruct crq_queue *queue = &vport->crq_queue;\r\nint err;\r\nfree_irq(vport->dma_dev->irq, target);\r\ndo {\r\nerr = h_free_crq(vport->dma_dev->unit_address);\r\n} while (err == H_BUSY || H_IS_LONG_BUSY(err));\r\ndma_unmap_single(target->dev, queue->msg_token,\r\nqueue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);\r\nfree_page((unsigned long) queue->msgs);\r\n}\r\nstatic void process_crq(struct viosrp_crq *crq, struct srp_target *target)\r\n{\r\nstruct vio_port *vport = target_to_port(target);\r\ndprintk("%x %x\n", crq->valid, crq->format);\r\nswitch (crq->valid) {\r\ncase 0xC0:\r\nswitch (crq->format) {\r\ncase 0x01:\r\nh_send_crq(vport->dma_dev->unit_address,\r\n0xC002000000000000, 0);\r\nbreak;\r\ncase 0x02:\r\nbreak;\r\ndefault:\r\neprintk("Unknown format %u\n", crq->format);\r\n}\r\nbreak;\r\ncase 0xFF:\r\nbreak;\r\ncase 0x80:\r\nswitch (crq->format) {\r\ncase VIOSRP_SRP_FORMAT:\r\ncase VIOSRP_MAD_FORMAT:\r\nprocess_iu(crq, target);\r\nbreak;\r\ncase VIOSRP_OS400_FORMAT:\r\ncase VIOSRP_AIX_FORMAT:\r\ncase VIOSRP_LINUX_FORMAT:\r\ncase VIOSRP_INLINE_FORMAT:\r\neprintk("Unsupported format %u\n", crq->format);\r\nbreak;\r\ndefault:\r\neprintk("Unknown format %u\n", crq->format);\r\n}\r\nbreak;\r\ndefault:\r\neprintk("unknown message type 0x%02x!?\n", crq->valid);\r\n}\r\n}\r\nstatic inline struct viosrp_crq *next_crq(struct crq_queue *queue)\r\n{\r\nstruct viosrp_crq *crq;\r\nunsigned long flags;\r\nspin_lock_irqsave(&queue->lock, flags);\r\ncrq = &queue->msgs[queue->cur];\r\nif (crq->valid & 0x80) {\r\nif (++queue->cur == queue->size)\r\nqueue->cur = 0;\r\n} else\r\ncrq = NULL;\r\nspin_unlock_irqrestore(&queue->lock, flags);\r\nreturn crq;\r\n}\r\nstatic void handle_crq(struct work_struct *work)\r\n{\r\nstruct vio_port *vport = container_of(work, struct vio_port, crq_work);\r\nstruct srp_target *target = vport->target;\r\nstruct viosrp_crq *crq;\r\nint done = 0;\r\nwhile (!done) {\r\nwhile ((crq = next_crq(&vport->crq_queue)) != NULL) {\r\nprocess_crq(crq, target);\r\ncrq->valid = 0x00;\r\n}\r\nvio_enable_interrupts(vport->dma_dev);\r\ncrq = next_crq(&vport->crq_queue);\r\nif (crq) {\r\nvio_disable_interrupts(vport->dma_dev);\r\nprocess_crq(crq, target);\r\ncrq->valid = 0x00;\r\n} else\r\ndone = 1;\r\n}\r\nhandle_cmd_queue(target);\r\n}\r\nstatic int ibmvstgt_eh_abort_handler(struct scsi_cmnd *sc)\r\n{\r\nunsigned long flags;\r\nstruct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;\r\nstruct srp_target *target = iue->target;\r\ndprintk("%p %p %x\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0]);\r\nspin_lock_irqsave(&target->lock, flags);\r\nlist_del(&iue->ilist);\r\nspin_unlock_irqrestore(&target->lock, flags);\r\nsrp_iu_put(iue);\r\nreturn 0;\r\n}\r\nstatic int ibmvstgt_tsk_mgmt_response(struct Scsi_Host *shost,\r\nu64 itn_id, u64 mid, int result)\r\n{\r\nstruct iu_entry *iue = (struct iu_entry *) ((void *) mid);\r\nunion viosrp_iu *iu = vio_iu(iue);\r\nunsigned char status, asc;\r\neprintk("%p %d\n", iue, result);\r\nstatus = NO_SENSE;\r\nasc = 0;\r\nswitch (iu->srp.tsk_mgmt.tsk_mgmt_func) {\r\ncase SRP_TSK_ABORT_TASK:\r\nasc = 0x14;\r\nif (result)\r\nstatus = ABORTED_COMMAND;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsend_rsp(iue, NULL, status, asc);\r\nsrp_iu_put(iue);\r\nreturn 0;\r\n}\r\nstatic int ibmvstgt_it_nexus_response(struct Scsi_Host *shost, u64 itn_id,\r\nint result)\r\n{\r\nstruct srp_target *target = host_to_srp_target(shost);\r\nstruct vio_port *vport = target_to_port(target);\r\nif (result) {\r\neprintk("%p %d\n", shost, result);\r\nsrp_rport_del(vport->rport);\r\nvport->rport = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t system_id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", system_id);\r\n}\r\nstatic ssize_t partition_number_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", partition_number);\r\n}\r\nstatic ssize_t unit_address_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct srp_target *target = host_to_srp_target(shost);\r\nstruct vio_port *vport = target_to_port(target);\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", vport->dma_dev->unit_address);\r\n}\r\nstatic int ibmvstgt_probe(struct vio_dev *dev, const struct vio_device_id *id)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct srp_target *target;\r\nstruct vio_port *vport;\r\nunsigned int *dma, dma_size;\r\nint err = -ENOMEM;\r\nvport = kzalloc(sizeof(struct vio_port), GFP_KERNEL);\r\nif (!vport)\r\nreturn err;\r\nshost = scsi_host_alloc(&ibmvstgt_sht, sizeof(struct srp_target));\r\nif (!shost)\r\ngoto free_vport;\r\nshost->transportt = ibmvstgt_transport_template;\r\ntarget = host_to_srp_target(shost);\r\ntarget->shost = shost;\r\nvport->dma_dev = dev;\r\ntarget->ldata = vport;\r\nvport->target = target;\r\nerr = srp_target_alloc(target, &dev->dev, INITIAL_SRP_LIMIT,\r\nSRP_MAX_IU_LEN);\r\nif (err)\r\ngoto put_host;\r\ndma = (unsigned int *) vio_get_attribute(dev, "ibm,my-dma-window",\r\n&dma_size);\r\nif (!dma || dma_size != 40) {\r\neprintk("Couldn't get window property %d\n", dma_size);\r\nerr = -EIO;\r\ngoto free_srp_target;\r\n}\r\nvport->liobn = dma[0];\r\nvport->riobn = dma[5];\r\nINIT_WORK(&vport->crq_work, handle_crq);\r\nerr = scsi_add_host(shost, target->dev);\r\nif (err)\r\ngoto free_srp_target;\r\nerr = scsi_tgt_alloc_queue(shost);\r\nif (err)\r\ngoto remove_host;\r\nerr = crq_queue_create(&vport->crq_queue, target);\r\nif (err)\r\ngoto free_queue;\r\nreturn 0;\r\nfree_queue:\r\nscsi_tgt_free_queue(shost);\r\nremove_host:\r\nscsi_remove_host(shost);\r\nfree_srp_target:\r\nsrp_target_free(target);\r\nput_host:\r\nscsi_host_put(shost);\r\nfree_vport:\r\nkfree(vport);\r\nreturn err;\r\n}\r\nstatic int ibmvstgt_remove(struct vio_dev *dev)\r\n{\r\nstruct srp_target *target = dev_get_drvdata(&dev->dev);\r\nstruct Scsi_Host *shost = target->shost;\r\nstruct vio_port *vport = target->ldata;\r\ncrq_queue_destroy(target);\r\nsrp_remove_host(shost);\r\nscsi_remove_host(shost);\r\nscsi_tgt_free_queue(shost);\r\nsrp_target_free(target);\r\nkfree(vport);\r\nscsi_host_put(shost);\r\nreturn 0;\r\n}\r\nstatic int get_system_info(void)\r\n{\r\nstruct device_node *rootdn;\r\nconst char *id, *model, *name;\r\nconst unsigned int *num;\r\nrootdn = of_find_node_by_path("/");\r\nif (!rootdn)\r\nreturn -ENOENT;\r\nmodel = of_get_property(rootdn, "model", NULL);\r\nid = of_get_property(rootdn, "system-id", NULL);\r\nif (model && id)\r\nsnprintf(system_id, sizeof(system_id), "%s-%s", model, id);\r\nname = of_get_property(rootdn, "ibm,partition-name", NULL);\r\nif (name)\r\nstrncpy(partition_name, name, sizeof(partition_name));\r\nnum = of_get_property(rootdn, "ibm,partition-no", NULL);\r\nif (num)\r\npartition_number = *num;\r\nof_node_put(rootdn);\r\nreturn 0;\r\n}\r\nstatic int __init ibmvstgt_init(void)\r\n{\r\nint err = -ENOMEM;\r\nprintk("IBM eServer i/pSeries Virtual SCSI Target Driver\n");\r\nibmvstgt_transport_template =\r\nsrp_attach_transport(&ibmvstgt_transport_functions);\r\nif (!ibmvstgt_transport_template)\r\nreturn err;\r\nvtgtd = create_workqueue("ibmvtgtd");\r\nif (!vtgtd)\r\ngoto release_transport;\r\nerr = get_system_info();\r\nif (err)\r\ngoto destroy_wq;\r\nerr = vio_register_driver(&ibmvstgt_driver);\r\nif (err)\r\ngoto destroy_wq;\r\nreturn 0;\r\ndestroy_wq:\r\ndestroy_workqueue(vtgtd);\r\nrelease_transport:\r\nsrp_release_transport(ibmvstgt_transport_template);\r\nreturn err;\r\n}\r\nstatic void __exit ibmvstgt_exit(void)\r\n{\r\nprintk("Unregister IBM virtual SCSI driver\n");\r\ndestroy_workqueue(vtgtd);\r\nvio_unregister_driver(&ibmvstgt_driver);\r\nsrp_release_transport(ibmvstgt_transport_template);\r\n}
