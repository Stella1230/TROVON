static int sh_pfc_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->pfc->info->nr_groups;\r\n}\r\nstatic const char *sh_pfc_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->pfc->info->groups[selector].name;\r\n}\r\nstatic int sh_pfc_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst unsigned **pins, unsigned *num_pins)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = pmx->pfc->info->groups[selector].pins;\r\n*num_pins = pmx->pfc->info->groups[selector].nr_pins;\r\nreturn 0;\r\n}\r\nstatic void sh_pfc_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nunsigned offset)\r\n{\r\nseq_printf(s, "%s", DRV_NAME);\r\n}\r\nstatic int sh_pfc_map_add_config(struct pinctrl_map *map,\r\nconst char *group_or_pin,\r\nenum pinctrl_map_type type,\r\nunsigned long *configs,\r\nunsigned int num_configs)\r\n{\r\nunsigned long *cfgs;\r\ncfgs = kmemdup(configs, num_configs * sizeof(*cfgs),\r\nGFP_KERNEL);\r\nif (cfgs == NULL)\r\nreturn -ENOMEM;\r\nmap->type = type;\r\nmap->data.configs.group_or_pin = group_or_pin;\r\nmap->data.configs.configs = cfgs;\r\nmap->data.configs.num_configs = num_configs;\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_dt_subnode_to_map(struct device *dev, struct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned int *num_maps, unsigned int *index)\r\n{\r\nstruct pinctrl_map *maps = *map;\r\nunsigned int nmaps = *num_maps;\r\nunsigned int idx = *index;\r\nunsigned int num_configs;\r\nconst char *function = NULL;\r\nunsigned long *configs;\r\nstruct property *prop;\r\nunsigned int num_groups;\r\nunsigned int num_pins;\r\nconst char *group;\r\nconst char *pin;\r\nint ret;\r\nret = of_property_read_string(np, "renesas,function", &function);\r\nif (ret < 0 && ret != -EINVAL) {\r\ndev_err(dev, "Invalid function in DT\n");\r\nreturn ret;\r\n}\r\nret = pinconf_generic_parse_dt_config(np, &configs, &num_configs);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!function && num_configs == 0) {\r\ndev_err(dev,\r\n"DT node must contain at least a function or config\n");\r\ngoto done;\r\n}\r\nret = of_property_count_strings(np, "renesas,pins");\r\nif (ret == -EINVAL) {\r\nnum_pins = 0;\r\n} else if (ret < 0) {\r\ndev_err(dev, "Invalid pins list in DT\n");\r\ngoto done;\r\n} else {\r\nnum_pins = ret;\r\n}\r\nret = of_property_count_strings(np, "renesas,groups");\r\nif (ret == -EINVAL) {\r\nnum_groups = 0;\r\n} else if (ret < 0) {\r\ndev_err(dev, "Invalid pin groups list in DT\n");\r\ngoto done;\r\n} else {\r\nnum_groups = ret;\r\n}\r\nif (!num_pins && !num_groups) {\r\ndev_err(dev, "No pin or group provided in DT node\n");\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nif (function)\r\nnmaps += num_groups;\r\nif (configs)\r\nnmaps += num_pins + num_groups;\r\nmaps = krealloc(maps, sizeof(*maps) * nmaps, GFP_KERNEL);\r\nif (maps == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\n*map = maps;\r\n*num_maps = nmaps;\r\nof_property_for_each_string(np, "renesas,groups", prop, group) {\r\nif (function) {\r\nmaps[idx].type = PIN_MAP_TYPE_MUX_GROUP;\r\nmaps[idx].data.mux.group = group;\r\nmaps[idx].data.mux.function = function;\r\nidx++;\r\n}\r\nif (configs) {\r\nret = sh_pfc_map_add_config(&maps[idx], group,\r\nPIN_MAP_TYPE_CONFIGS_GROUP,\r\nconfigs, num_configs);\r\nif (ret < 0)\r\ngoto done;\r\nidx++;\r\n}\r\n}\r\nif (!configs) {\r\nret = 0;\r\ngoto done;\r\n}\r\nof_property_for_each_string(np, "renesas,pins", prop, pin) {\r\nret = sh_pfc_map_add_config(&maps[idx], pin,\r\nPIN_MAP_TYPE_CONFIGS_PIN,\r\nconfigs, num_configs);\r\nif (ret < 0)\r\ngoto done;\r\nidx++;\r\n}\r\ndone:\r\n*index = idx;\r\nkfree(configs);\r\nreturn ret;\r\n}\r\nstatic void sh_pfc_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\nunsigned int i;\r\nif (map == NULL)\r\nreturn;\r\nfor (i = 0; i < num_maps; ++i) {\r\nif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP ||\r\nmap[i].type == PIN_MAP_TYPE_CONFIGS_PIN)\r\nkfree(map[i].data.configs.configs);\r\n}\r\nkfree(map);\r\n}\r\nstatic int sh_pfc_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct device *dev = pmx->pfc->dev;\r\nstruct device_node *child;\r\nunsigned int index;\r\nint ret;\r\n*map = NULL;\r\n*num_maps = 0;\r\nindex = 0;\r\nfor_each_child_of_node(np, child) {\r\nret = sh_pfc_dt_subnode_to_map(dev, child, map, num_maps,\r\n&index);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nif (*num_maps == 0) {\r\nret = sh_pfc_dt_subnode_to_map(dev, np, map, num_maps, &index);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nif (*num_maps)\r\nreturn 0;\r\ndev_err(dev, "no mapping found in node %s\n", np->full_name);\r\nret = -EINVAL;\r\ndone:\r\nif (ret < 0)\r\nsh_pfc_dt_free_map(pctldev, *map, *num_maps);\r\nreturn ret;\r\n}\r\nstatic int sh_pfc_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->pfc->info->nr_functions;\r\n}\r\nstatic const char *sh_pfc_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->pfc->info->functions[selector].name;\r\n}\r\nstatic int sh_pfc_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pmx->pfc->info->functions[selector].groups;\r\n*num_groups = pmx->pfc->info->functions[selector].nr_groups;\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_func_enable(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nconst struct sh_pfc_pin_group *grp = &pfc->info->groups[group];\r\nunsigned long flags;\r\nunsigned int i;\r\nint ret = 0;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nfor (i = 0; i < grp->nr_pins; ++i) {\r\nint idx = sh_pfc_get_pin_index(pfc, grp->pins[i]);\r\nstruct sh_pfc_pin_config *cfg = &pmx->configs[idx];\r\nif (cfg->type != PINMUX_TYPE_NONE) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\n}\r\nfor (i = 0; i < grp->nr_pins; ++i) {\r\nret = sh_pfc_config_mux(pfc, grp->mux[i], PINMUX_TYPE_FUNCTION);\r\nif (ret < 0)\r\nbreak;\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void sh_pfc_func_disable(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nconst struct sh_pfc_pin_group *grp = &pfc->info->groups[group];\r\nunsigned long flags;\r\nunsigned int i;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nfor (i = 0; i < grp->nr_pins; ++i) {\r\nint idx = sh_pfc_get_pin_index(pfc, grp->pins[i]);\r\nstruct sh_pfc_pin_config *cfg = &pmx->configs[idx];\r\ncfg->type = PINMUX_TYPE_NONE;\r\n}\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\n}\r\nstatic int sh_pfc_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nint idx = sh_pfc_get_pin_index(pfc, offset);\r\nstruct sh_pfc_pin_config *cfg = &pmx->configs[idx];\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nif (cfg->type != PINMUX_TYPE_NONE) {\r\ndev_err(pfc->dev,\r\n"Pin %u is busy, can't configure it as GPIO.\n",\r\noffset);\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nif (!pfc->gpio) {\r\nconst struct sh_pfc_pin *pin = &pfc->info->pins[idx];\r\nret = sh_pfc_config_mux(pfc, pin->enum_id, PINMUX_TYPE_GPIO);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\ncfg->type = PINMUX_TYPE_GPIO;\r\nret = 0;\r\ndone:\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void sh_pfc_gpio_disable_free(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nint idx = sh_pfc_get_pin_index(pfc, offset);\r\nstruct sh_pfc_pin_config *cfg = &pmx->configs[idx];\r\nunsigned long flags;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\ncfg->type = PINMUX_TYPE_NONE;\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\n}\r\nstatic int sh_pfc_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset, bool input)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nint new_type = input ? PINMUX_TYPE_INPUT : PINMUX_TYPE_OUTPUT;\r\nint idx = sh_pfc_get_pin_index(pfc, offset);\r\nconst struct sh_pfc_pin *pin = &pfc->info->pins[idx];\r\nstruct sh_pfc_pin_config *cfg = &pmx->configs[idx];\r\nunsigned long flags;\r\nunsigned int dir;\r\nint ret;\r\nif (pin->configs) {\r\ndir = input ? SH_PFC_PIN_CFG_INPUT : SH_PFC_PIN_CFG_OUTPUT;\r\nif (!(pin->configs & dir))\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nret = sh_pfc_config_mux(pfc, pin->enum_id, new_type);\r\nif (ret < 0)\r\ngoto done;\r\ncfg->type = new_type;\r\ndone:\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic bool sh_pfc_pinconf_validate(struct sh_pfc *pfc, unsigned int _pin,\r\nenum pin_config_param param)\r\n{\r\nint idx = sh_pfc_get_pin_index(pfc, _pin);\r\nconst struct sh_pfc_pin *pin = &pfc->info->pins[idx];\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nreturn true;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nreturn pin->configs & SH_PFC_PIN_CFG_PULL_UP;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nreturn pin->configs & SH_PFC_PIN_CFG_PULL_DOWN;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int sh_pfc_pinconf_get(struct pinctrl_dev *pctldev, unsigned _pin,\r\nunsigned long *config)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nunsigned long flags;\r\nunsigned int bias;\r\nif (!sh_pfc_pinconf_validate(pfc, _pin, param))\r\nreturn -ENOTSUPP;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (!pfc->info->ops || !pfc->info->ops->get_bias)\r\nreturn -ENOTSUPP;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nbias = pfc->info->ops->get_bias(pfc, _pin);\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nif (bias != param)\r\nreturn -EINVAL;\r\n*config = 0;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_pinconf_set(struct pinctrl_dev *pctldev, unsigned _pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nenum pin_config_param param;\r\nunsigned long flags;\r\nunsigned int i;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\nif (!sh_pfc_pinconf_validate(pfc, _pin, param))\r\nreturn -ENOTSUPP;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif (!pfc->info->ops || !pfc->info->ops->set_bias)\r\nreturn -ENOTSUPP;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\npfc->info->ops->set_bias(pfc, _pin, param);\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_pinconf_group_set(struct pinctrl_dev *pctldev, unsigned group,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst unsigned int *pins;\r\nunsigned int num_pins;\r\nunsigned int i;\r\npins = pmx->pfc->info->groups[group].pins;\r\nnum_pins = pmx->pfc->info->groups[group].nr_pins;\r\nfor (i = 0; i < num_pins; ++i)\r\nsh_pfc_pinconf_set(pctldev, pins[i], configs, num_configs);\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_map_pins(struct sh_pfc *pfc, struct sh_pfc_pinctrl *pmx)\r\n{\r\nunsigned int i;\r\npmx->pins = devm_kzalloc(pfc->dev,\r\nsizeof(*pmx->pins) * pfc->info->nr_pins,\r\nGFP_KERNEL);\r\nif (unlikely(!pmx->pins))\r\nreturn -ENOMEM;\r\npmx->configs = devm_kzalloc(pfc->dev,\r\nsizeof(*pmx->configs) * pfc->info->nr_pins,\r\nGFP_KERNEL);\r\nif (unlikely(!pmx->configs))\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pfc->info->nr_pins; ++i) {\r\nconst struct sh_pfc_pin *info = &pfc->info->pins[i];\r\nstruct sh_pfc_pin_config *cfg = &pmx->configs[i];\r\nstruct pinctrl_pin_desc *pin = &pmx->pins[i];\r\npin->number = info->pin != (u16)-1 ? info->pin : i;\r\npin->name = info->name;\r\ncfg->type = PINMUX_TYPE_NONE;\r\n}\r\nreturn 0;\r\n}\r\nint sh_pfc_register_pinctrl(struct sh_pfc *pfc)\r\n{\r\nstruct sh_pfc_pinctrl *pmx;\r\nint ret;\r\npmx = devm_kzalloc(pfc->dev, sizeof(*pmx), GFP_KERNEL);\r\nif (unlikely(!pmx))\r\nreturn -ENOMEM;\r\npmx->pfc = pfc;\r\npfc->pinctrl = pmx;\r\nret = sh_pfc_map_pins(pfc, pmx);\r\nif (ret < 0)\r\nreturn ret;\r\npmx->pctl_desc.name = DRV_NAME;\r\npmx->pctl_desc.owner = THIS_MODULE;\r\npmx->pctl_desc.pctlops = &sh_pfc_pinctrl_ops;\r\npmx->pctl_desc.pmxops = &sh_pfc_pinmux_ops;\r\npmx->pctl_desc.confops = &sh_pfc_pinconf_ops;\r\npmx->pctl_desc.pins = pmx->pins;\r\npmx->pctl_desc.npins = pfc->info->nr_pins;\r\npmx->pctl = pinctrl_register(&pmx->pctl_desc, pfc->dev, pmx);\r\nif (pmx->pctl == NULL)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint sh_pfc_unregister_pinctrl(struct sh_pfc *pfc)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pfc->pinctrl;\r\npinctrl_unregister(pmx->pctl);\r\npfc->pinctrl = NULL;\r\nreturn 0;\r\n}
