static int acpi_pci_root_scan_dependent(struct acpi_device *adev)\r\n{\r\nacpiphp_check_host_bridge(adev);\r\nreturn 0;\r\n}\r\nint acpi_is_root_bridge(acpi_handle handle)\r\n{\r\nint ret;\r\nstruct acpi_device *device;\r\nret = acpi_bus_get_device(handle, &device);\r\nif (ret)\r\nreturn 0;\r\nret = acpi_match_device_ids(device, root_device_ids);\r\nif (ret)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic acpi_status\r\nget_root_bridge_busnr_callback(struct acpi_resource *resource, void *data)\r\n{\r\nstruct resource *res = data;\r\nstruct acpi_resource_address64 address;\r\nacpi_status status;\r\nstatus = acpi_resource_to_address64(resource, &address);\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\nif ((address.address_length > 0) &&\r\n(address.resource_type == ACPI_BUS_NUMBER_RANGE)) {\r\nres->start = address.minimum;\r\nres->end = address.minimum + address.address_length - 1;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status try_get_root_bridge_busnr(acpi_handle handle,\r\nstruct resource *res)\r\n{\r\nacpi_status status;\r\nres->start = -1;\r\nstatus =\r\nacpi_walk_resources(handle, METHOD_NAME__CRS,\r\nget_root_bridge_busnr_callback, res);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nif (res->start == -1)\r\nreturn AE_ERROR;\r\nreturn AE_OK;\r\n}\r\nstatic void decode_osc_bits(struct acpi_pci_root *root, char *msg, u32 word,\r\nstruct pci_osc_bit_struct *table, int size)\r\n{\r\nchar buf[80];\r\nint i, len = 0;\r\nstruct pci_osc_bit_struct *entry;\r\nbuf[0] = '\0';\r\nfor (i = 0, entry = table; i < size; i++, entry++)\r\nif (word & entry->bit)\r\nlen += snprintf(buf + len, sizeof(buf) - len, "%s%s",\r\nlen ? " " : "", entry->desc);\r\ndev_info(&root->device->dev, "_OSC: %s [%s]\n", msg, buf);\r\n}\r\nstatic void decode_osc_support(struct acpi_pci_root *root, char *msg, u32 word)\r\n{\r\ndecode_osc_bits(root, msg, word, pci_osc_support_bit,\r\nARRAY_SIZE(pci_osc_support_bit));\r\n}\r\nstatic void decode_osc_control(struct acpi_pci_root *root, char *msg, u32 word)\r\n{\r\ndecode_osc_bits(root, msg, word, pci_osc_control_bit,\r\nARRAY_SIZE(pci_osc_control_bit));\r\n}\r\nstatic acpi_status acpi_pci_run_osc(acpi_handle handle,\r\nconst u32 *capbuf, u32 *retval)\r\n{\r\nstruct acpi_osc_context context = {\r\n.uuid_str = pci_osc_uuid_str,\r\n.rev = 1,\r\n.cap.length = 12,\r\n.cap.pointer = (void *)capbuf,\r\n};\r\nacpi_status status;\r\nstatus = acpi_run_osc(handle, &context);\r\nif (ACPI_SUCCESS(status)) {\r\n*retval = *((u32 *)(context.ret.pointer + 8));\r\nkfree(context.ret.pointer);\r\n}\r\nreturn status;\r\n}\r\nstatic acpi_status acpi_pci_query_osc(struct acpi_pci_root *root,\r\nu32 support,\r\nu32 *control)\r\n{\r\nacpi_status status;\r\nu32 result, capbuf[3];\r\nsupport &= OSC_PCI_SUPPORT_MASKS;\r\nsupport |= root->osc_support_set;\r\ncapbuf[OSC_QUERY_DWORD] = OSC_QUERY_ENABLE;\r\ncapbuf[OSC_SUPPORT_DWORD] = support;\r\nif (control) {\r\n*control &= OSC_PCI_CONTROL_MASKS;\r\ncapbuf[OSC_CONTROL_DWORD] = *control | root->osc_control_set;\r\n} else {\r\ncapbuf[OSC_CONTROL_DWORD] = root->osc_control_set;\r\n}\r\nstatus = acpi_pci_run_osc(root->device->handle, capbuf, &result);\r\nif (ACPI_SUCCESS(status)) {\r\nroot->osc_support_set = support;\r\nif (control)\r\n*control = result;\r\n}\r\nreturn status;\r\n}\r\nstatic acpi_status acpi_pci_osc_support(struct acpi_pci_root *root, u32 flags)\r\n{\r\nacpi_status status;\r\nmutex_lock(&osc_lock);\r\nstatus = acpi_pci_query_osc(root, flags, NULL);\r\nmutex_unlock(&osc_lock);\r\nreturn status;\r\n}\r\nstruct acpi_pci_root *acpi_pci_find_root(acpi_handle handle)\r\n{\r\nstruct acpi_pci_root *root;\r\nstruct acpi_device *device;\r\nif (acpi_bus_get_device(handle, &device) ||\r\nacpi_match_device_ids(device, root_device_ids))\r\nreturn NULL;\r\nroot = acpi_driver_data(device);\r\nreturn root;\r\n}\r\nstruct pci_dev *acpi_get_pci_dev(acpi_handle handle)\r\n{\r\nint dev, fn;\r\nunsigned long long adr;\r\nacpi_status status;\r\nacpi_handle phandle;\r\nstruct pci_bus *pbus;\r\nstruct pci_dev *pdev = NULL;\r\nstruct acpi_handle_node *node, *tmp;\r\nstruct acpi_pci_root *root;\r\nLIST_HEAD(device_list);\r\nphandle = handle;\r\nwhile (!acpi_is_root_bridge(phandle)) {\r\nnode = kzalloc(sizeof(struct acpi_handle_node), GFP_KERNEL);\r\nif (!node)\r\ngoto out;\r\nINIT_LIST_HEAD(&node->node);\r\nnode->handle = phandle;\r\nlist_add(&node->node, &device_list);\r\nstatus = acpi_get_parent(phandle, &phandle);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\n}\r\nroot = acpi_pci_find_root(phandle);\r\nif (!root)\r\ngoto out;\r\npbus = root->bus;\r\nlist_for_each_entry(node, &device_list, node) {\r\nacpi_handle hnd = node->handle;\r\nstatus = acpi_evaluate_integer(hnd, "_ADR", NULL, &adr);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\ndev = (adr >> 16) & 0xffff;\r\nfn = adr & 0xffff;\r\npdev = pci_get_slot(pbus, PCI_DEVFN(dev, fn));\r\nif (!pdev || hnd == handle)\r\nbreak;\r\npbus = pdev->subordinate;\r\npci_dev_put(pdev);\r\nif (!pbus) {\r\ndev_dbg(&pdev->dev, "Not a PCI-to-PCI bridge\n");\r\npdev = NULL;\r\nbreak;\r\n}\r\n}\r\nout:\r\nlist_for_each_entry_safe(node, tmp, &device_list, node)\r\nkfree(node);\r\nreturn pdev;\r\n}\r\nacpi_status acpi_pci_osc_control_set(acpi_handle handle, u32 *mask, u32 req)\r\n{\r\nstruct acpi_pci_root *root;\r\nacpi_status status = AE_OK;\r\nu32 ctrl, capbuf[3];\r\nif (!mask)\r\nreturn AE_BAD_PARAMETER;\r\nctrl = *mask & OSC_PCI_CONTROL_MASKS;\r\nif ((ctrl & req) != req)\r\nreturn AE_TYPE;\r\nroot = acpi_pci_find_root(handle);\r\nif (!root)\r\nreturn AE_NOT_EXIST;\r\nmutex_lock(&osc_lock);\r\n*mask = ctrl | root->osc_control_set;\r\nif ((root->osc_control_set & ctrl) == ctrl)\r\ngoto out;\r\nwhile (*mask) {\r\nstatus = acpi_pci_query_osc(root, root->osc_support_set, mask);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\nif (ctrl == *mask)\r\nbreak;\r\ndecode_osc_control(root, "platform does not support",\r\nctrl & ~(*mask));\r\nctrl = *mask;\r\n}\r\nif ((ctrl & req) != req) {\r\ndecode_osc_control(root, "not requesting control; platform does not support",\r\nreq & ~(ctrl));\r\nstatus = AE_SUPPORT;\r\ngoto out;\r\n}\r\ncapbuf[OSC_QUERY_DWORD] = 0;\r\ncapbuf[OSC_SUPPORT_DWORD] = root->osc_support_set;\r\ncapbuf[OSC_CONTROL_DWORD] = ctrl;\r\nstatus = acpi_pci_run_osc(handle, capbuf, mask);\r\nif (ACPI_SUCCESS(status))\r\nroot->osc_control_set = *mask;\r\nout:\r\nmutex_unlock(&osc_lock);\r\nreturn status;\r\n}\r\nstatic void negotiate_os_control(struct acpi_pci_root *root, int *no_aspm,\r\nint *clear_aspm)\r\n{\r\nu32 support, control, requested;\r\nacpi_status status;\r\nstruct acpi_device *device = root->device;\r\nacpi_handle handle = device->handle;\r\nsupport = OSC_PCI_SEGMENT_GROUPS_SUPPORT;\r\nif (pci_ext_cfg_avail())\r\nsupport |= OSC_PCI_EXT_CONFIG_SUPPORT;\r\nif (pcie_aspm_support_enabled())\r\nsupport |= OSC_PCI_ASPM_SUPPORT | OSC_PCI_CLOCK_PM_SUPPORT;\r\nif (pci_msi_enabled())\r\nsupport |= OSC_PCI_MSI_SUPPORT;\r\ndecode_osc_support(root, "OS supports", support);\r\nstatus = acpi_pci_osc_support(root, support);\r\nif (ACPI_FAILURE(status)) {\r\ndev_info(&device->dev, "_OSC failed (%s); disabling ASPM\n",\r\nacpi_format_exception(status));\r\n*no_aspm = 1;\r\nreturn;\r\n}\r\nif (pcie_ports_disabled) {\r\ndev_info(&device->dev, "PCIe port services disabled; not requesting _OSC control\n");\r\nreturn;\r\n}\r\nif ((support & ACPI_PCIE_REQ_SUPPORT) != ACPI_PCIE_REQ_SUPPORT) {\r\ndecode_osc_support(root, "not requesting OS control; OS requires",\r\nACPI_PCIE_REQ_SUPPORT);\r\nreturn;\r\n}\r\ncontrol = OSC_PCI_EXPRESS_CAPABILITY_CONTROL\r\n| OSC_PCI_EXPRESS_NATIVE_HP_CONTROL\r\n| OSC_PCI_EXPRESS_PME_CONTROL;\r\nif (pci_aer_available()) {\r\nif (aer_acpi_firmware_first())\r\ndev_info(&device->dev,\r\n"PCIe AER handled by firmware\n");\r\nelse\r\ncontrol |= OSC_PCI_EXPRESS_AER_CONTROL;\r\n}\r\nrequested = control;\r\nstatus = acpi_pci_osc_control_set(handle, &control,\r\nOSC_PCI_EXPRESS_CAPABILITY_CONTROL);\r\nif (ACPI_SUCCESS(status)) {\r\ndecode_osc_control(root, "OS now controls", control);\r\nif (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_ASPM) {\r\n*clear_aspm = 1;\r\n}\r\n} else {\r\ndecode_osc_control(root, "OS requested", requested);\r\ndecode_osc_control(root, "platform willing to grant", control);\r\ndev_info(&device->dev, "_OSC failed (%s); disabling ASPM\n",\r\nacpi_format_exception(status));\r\n*no_aspm = 1;\r\n}\r\n}\r\nstatic int acpi_pci_root_add(struct acpi_device *device,\r\nconst struct acpi_device_id *not_used)\r\n{\r\nunsigned long long segment, bus;\r\nacpi_status status;\r\nint result;\r\nstruct acpi_pci_root *root;\r\nacpi_handle handle = device->handle;\r\nint no_aspm = 0, clear_aspm = 0;\r\nroot = kzalloc(sizeof(struct acpi_pci_root), GFP_KERNEL);\r\nif (!root)\r\nreturn -ENOMEM;\r\nsegment = 0;\r\nstatus = acpi_evaluate_integer(handle, METHOD_NAME__SEG, NULL,\r\n&segment);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\ndev_err(&device->dev, "can't evaluate _SEG\n");\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\nroot->secondary.flags = IORESOURCE_BUS;\r\nstatus = try_get_root_bridge_busnr(handle, &root->secondary);\r\nif (ACPI_FAILURE(status)) {\r\nroot->secondary.end = 0xFF;\r\ndev_warn(&device->dev,\r\nFW_BUG "no secondary bus range in _CRS\n");\r\nstatus = acpi_evaluate_integer(handle, METHOD_NAME__BBN,\r\nNULL, &bus);\r\nif (ACPI_SUCCESS(status))\r\nroot->secondary.start = bus;\r\nelse if (status == AE_NOT_FOUND)\r\nroot->secondary.start = 0;\r\nelse {\r\ndev_err(&device->dev, "can't evaluate _BBN\n");\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\n}\r\nroot->device = device;\r\nroot->segment = segment & 0xFFFF;\r\nstrcpy(acpi_device_name(device), ACPI_PCI_ROOT_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_PCI_ROOT_CLASS);\r\ndevice->driver_data = root;\r\npr_info(PREFIX "%s [%s] (domain %04x %pR)\n",\r\nacpi_device_name(device), acpi_device_bid(device),\r\nroot->segment, &root->secondary);\r\nroot->mcfg_addr = acpi_pci_root_get_mcfg_addr(handle);\r\nnegotiate_os_control(root, &no_aspm, &clear_aspm);\r\nroot->bus = pci_acpi_scan_root(root);\r\nif (!root->bus) {\r\ndev_err(&device->dev,\r\n"Bus %04x:%02x not present in PCI namespace\n",\r\nroot->segment, (unsigned int)root->secondary.start);\r\ndevice->driver_data = NULL;\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\nif (clear_aspm) {\r\ndev_info(&device->dev, "Disabling ASPM (FADT indicates it is unsupported)\n");\r\npcie_clear_aspm(root->bus);\r\n}\r\nif (no_aspm)\r\npcie_no_aspm();\r\npci_acpi_add_bus_pm_notifier(device, root->bus);\r\nif (device->wakeup.flags.run_wake)\r\ndevice_set_run_wake(root->bus->bridge, true);\r\nif (system_state != SYSTEM_BOOTING) {\r\npcibios_resource_survey_bus(root->bus);\r\npci_assign_unassigned_root_bus_resources(root->bus);\r\n}\r\npci_lock_rescan_remove();\r\npci_bus_add_devices(root->bus);\r\npci_unlock_rescan_remove();\r\nreturn 1;\r\nend:\r\nkfree(root);\r\nreturn result;\r\n}\r\nstatic void acpi_pci_root_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_pci_root *root = acpi_driver_data(device);\r\npci_lock_rescan_remove();\r\npci_stop_root_bus(root->bus);\r\ndevice_set_run_wake(root->bus->bridge, false);\r\npci_acpi_remove_bus_pm_notifier(device);\r\npci_remove_root_bus(root->bus);\r\npci_unlock_rescan_remove();\r\nkfree(root);\r\n}\r\nvoid __init acpi_pci_root_init(void)\r\n{\r\nacpi_hest_init();\r\nif (acpi_pci_disabled)\r\nreturn;\r\npci_acpi_crs_quirks();\r\nacpi_scan_add_handler_with_hotplug(&pci_root_handler, "pci_root");\r\n}
