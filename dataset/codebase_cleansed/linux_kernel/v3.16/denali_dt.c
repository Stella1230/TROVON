static int denali_dt_probe(struct platform_device *ofdev)\r\n{\r\nstruct resource *denali_reg, *nand_data;\r\nstruct denali_dt *dt;\r\nstruct denali_nand_info *denali;\r\nint ret;\r\nconst struct of_device_id *of_id;\r\nof_id = of_match_device(denali_nand_dt_ids, &ofdev->dev);\r\nif (of_id) {\r\nofdev->id_entry = of_id->data;\r\n} else {\r\npr_err("Failed to find the right device id.\n");\r\nreturn -ENOMEM;\r\n}\r\ndt = devm_kzalloc(&ofdev->dev, sizeof(*dt), GFP_KERNEL);\r\nif (!dt)\r\nreturn -ENOMEM;\r\ndenali = &dt->denali;\r\ndenali->platform = DT;\r\ndenali->dev = &ofdev->dev;\r\ndenali->irq = platform_get_irq(ofdev, 0);\r\nif (denali->irq < 0) {\r\ndev_err(&ofdev->dev, "no irq defined\n");\r\nreturn denali->irq;\r\n}\r\ndenali_reg = platform_get_resource_byname(ofdev, IORESOURCE_MEM, "denali_reg");\r\ndenali->flash_reg = devm_ioremap_resource(&ofdev->dev, denali_reg);\r\nif (IS_ERR(denali->flash_reg))\r\nreturn PTR_ERR(denali->flash_reg);\r\nnand_data = platform_get_resource_byname(ofdev, IORESOURCE_MEM, "nand_data");\r\ndenali->flash_mem = devm_ioremap_resource(&ofdev->dev, nand_data);\r\nif (IS_ERR(denali->flash_mem))\r\nreturn PTR_ERR(denali->flash_mem);\r\nif (!of_property_read_u32(ofdev->dev.of_node,\r\n"dma-mask", (u32 *)&denali_dma_mask)) {\r\ndenali->dev->dma_mask = &denali_dma_mask;\r\n} else {\r\ndenali->dev->dma_mask = NULL;\r\n}\r\ndt->clk = devm_clk_get(&ofdev->dev, NULL);\r\nif (IS_ERR(dt->clk)) {\r\ndev_err(&ofdev->dev, "no clk available\n");\r\nreturn PTR_ERR(dt->clk);\r\n}\r\nclk_prepare_enable(dt->clk);\r\nret = denali_init(denali);\r\nif (ret)\r\ngoto out_disable_clk;\r\nplatform_set_drvdata(ofdev, dt);\r\nreturn 0;\r\nout_disable_clk:\r\nclk_disable_unprepare(dt->clk);\r\nreturn ret;\r\n}\r\nstatic int denali_dt_remove(struct platform_device *ofdev)\r\n{\r\nstruct denali_dt *dt = platform_get_drvdata(ofdev);\r\ndenali_remove(&dt->denali);\r\nclk_disable(dt->clk);\r\nreturn 0;\r\n}
