static unsigned int get_time_pit(void)\r\n{\r\nunsigned long flags;\r\nunsigned int count;\r\nraw_spin_lock_irqsave(&i8253_lock, flags);\r\noutb_p(0x00, 0x43);\r\ncount = inb_p(0x40);\r\ncount |= inb_p(0x40) << 8;\r\nraw_spin_unlock_irqrestore(&i8253_lock, flags);\r\nreturn count;\r\n}\r\nstatic int gameport_measure_speed(struct gameport *gameport)\r\n{\r\n#if defined(__i386__)\r\nunsigned int i, t, t1, t2, t3, tx;\r\nunsigned long flags;\r\nif (gameport_open(gameport, NULL, GAMEPORT_MODE_RAW))\r\nreturn 0;\r\ntx = 1 << 30;\r\nfor(i = 0; i < 50; i++) {\r\nlocal_irq_save(flags);\r\nGET_TIME(t1);\r\nfor (t = 0; t < 50; t++) gameport_read(gameport);\r\nGET_TIME(t2);\r\nGET_TIME(t3);\r\nlocal_irq_restore(flags);\r\nudelay(i * 10);\r\nif ((t = DELTA(t2,t1) - DELTA(t3,t2)) < tx) tx = t;\r\n}\r\ngameport_close(gameport);\r\nreturn 59659 / (tx < 1 ? 1 : tx);\r\n#elif defined (__x86_64__)\r\nunsigned int i, t;\r\nunsigned long tx, t1, t2, flags;\r\nif (gameport_open(gameport, NULL, GAMEPORT_MODE_RAW))\r\nreturn 0;\r\ntx = 1 << 30;\r\nfor(i = 0; i < 50; i++) {\r\nlocal_irq_save(flags);\r\nrdtscl(t1);\r\nfor (t = 0; t < 50; t++) gameport_read(gameport);\r\nrdtscl(t2);\r\nlocal_irq_restore(flags);\r\nudelay(i * 10);\r\nif (t2 - t1 < tx) tx = t2 - t1;\r\n}\r\ngameport_close(gameport);\r\nreturn (this_cpu_read(cpu_info.loops_per_jiffy) *\r\n(unsigned long)HZ / (1000 / 50)) / (tx < 1 ? 1 : tx);\r\n#else\r\nunsigned int j, t = 0;\r\nif (gameport_open(gameport, NULL, GAMEPORT_MODE_RAW))\r\nreturn 0;\r\nj = jiffies; while (j == jiffies);\r\nj = jiffies; while (j == jiffies) { t++; gameport_read(gameport); }\r\ngameport_close(gameport);\r\nreturn t * HZ / 1000;\r\n#endif\r\n}\r\nvoid gameport_start_polling(struct gameport *gameport)\r\n{\r\nspin_lock(&gameport->timer_lock);\r\nif (!gameport->poll_cnt++) {\r\nBUG_ON(!gameport->poll_handler);\r\nBUG_ON(!gameport->poll_interval);\r\nmod_timer(&gameport->poll_timer, jiffies + msecs_to_jiffies(gameport->poll_interval));\r\n}\r\nspin_unlock(&gameport->timer_lock);\r\n}\r\nvoid gameport_stop_polling(struct gameport *gameport)\r\n{\r\nspin_lock(&gameport->timer_lock);\r\nif (!--gameport->poll_cnt)\r\ndel_timer(&gameport->poll_timer);\r\nspin_unlock(&gameport->timer_lock);\r\n}\r\nstatic void gameport_run_poll_handler(unsigned long d)\r\n{\r\nstruct gameport *gameport = (struct gameport *)d;\r\ngameport->poll_handler(gameport);\r\nif (gameport->poll_cnt)\r\nmod_timer(&gameport->poll_timer, jiffies + msecs_to_jiffies(gameport->poll_interval));\r\n}\r\nstatic int gameport_bind_driver(struct gameport *gameport, struct gameport_driver *drv)\r\n{\r\nint error;\r\ngameport->dev.driver = &drv->driver;\r\nif (drv->connect(gameport, drv)) {\r\ngameport->dev.driver = NULL;\r\nreturn -ENODEV;\r\n}\r\nerror = device_bind_driver(&gameport->dev);\r\nif (error) {\r\ndev_warn(&gameport->dev,\r\n"device_bind_driver() failed for %s (%s) and %s, error: %d\n",\r\ngameport->phys, gameport->name,\r\ndrv->description, error);\r\ndrv->disconnect(gameport);\r\ngameport->dev.driver = NULL;\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void gameport_find_driver(struct gameport *gameport)\r\n{\r\nint error;\r\nerror = device_attach(&gameport->dev);\r\nif (error < 0)\r\ndev_warn(&gameport->dev,\r\n"device_attach() failed for %s (%s), error: %d\n",\r\ngameport->phys, gameport->name, error);\r\n}\r\nstatic struct gameport_event *gameport_get_event(void)\r\n{\r\nstruct gameport_event *event = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gameport_event_lock, flags);\r\nif (!list_empty(&gameport_event_list)) {\r\nevent = list_first_entry(&gameport_event_list,\r\nstruct gameport_event, node);\r\nlist_del_init(&event->node);\r\n}\r\nspin_unlock_irqrestore(&gameport_event_lock, flags);\r\nreturn event;\r\n}\r\nstatic void gameport_free_event(struct gameport_event *event)\r\n{\r\nmodule_put(event->owner);\r\nkfree(event);\r\n}\r\nstatic void gameport_remove_duplicate_events(struct gameport_event *event)\r\n{\r\nstruct gameport_event *e, *next;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gameport_event_lock, flags);\r\nlist_for_each_entry_safe(e, next, &gameport_event_list, node) {\r\nif (event->object == e->object) {\r\nif (event->type != e->type)\r\nbreak;\r\nlist_del_init(&e->node);\r\ngameport_free_event(e);\r\n}\r\n}\r\nspin_unlock_irqrestore(&gameport_event_lock, flags);\r\n}\r\nstatic void gameport_handle_events(struct work_struct *work)\r\n{\r\nstruct gameport_event *event;\r\nmutex_lock(&gameport_mutex);\r\nif ((event = gameport_get_event())) {\r\nswitch (event->type) {\r\ncase GAMEPORT_REGISTER_PORT:\r\ngameport_add_port(event->object);\r\nbreak;\r\ncase GAMEPORT_ATTACH_DRIVER:\r\ngameport_attach_driver(event->object);\r\nbreak;\r\n}\r\ngameport_remove_duplicate_events(event);\r\ngameport_free_event(event);\r\n}\r\nmutex_unlock(&gameport_mutex);\r\n}\r\nstatic int gameport_queue_event(void *object, struct module *owner,\r\nenum gameport_event_type event_type)\r\n{\r\nunsigned long flags;\r\nstruct gameport_event *event;\r\nint retval = 0;\r\nspin_lock_irqsave(&gameport_event_lock, flags);\r\nlist_for_each_entry_reverse(event, &gameport_event_list, node) {\r\nif (event->object == object) {\r\nif (event->type == event_type)\r\ngoto out;\r\nbreak;\r\n}\r\n}\r\nevent = kmalloc(sizeof(struct gameport_event), GFP_ATOMIC);\r\nif (!event) {\r\npr_err("Not enough memory to queue event %d\n", event_type);\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nif (!try_module_get(owner)) {\r\npr_warning("Can't get module reference, dropping event %d\n",\r\nevent_type);\r\nkfree(event);\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nevent->type = event_type;\r\nevent->object = object;\r\nevent->owner = owner;\r\nlist_add_tail(&event->node, &gameport_event_list);\r\nqueue_work(system_long_wq, &gameport_event_work);\r\nout:\r\nspin_unlock_irqrestore(&gameport_event_lock, flags);\r\nreturn retval;\r\n}\r\nstatic void gameport_remove_pending_events(void *object)\r\n{\r\nstruct gameport_event *event, *next;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gameport_event_lock, flags);\r\nlist_for_each_entry_safe(event, next, &gameport_event_list, node) {\r\nif (event->object == object) {\r\nlist_del_init(&event->node);\r\ngameport_free_event(event);\r\n}\r\n}\r\nspin_unlock_irqrestore(&gameport_event_lock, flags);\r\n}\r\nstatic struct gameport *gameport_get_pending_child(struct gameport *parent)\r\n{\r\nstruct gameport_event *event;\r\nstruct gameport *gameport, *child = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gameport_event_lock, flags);\r\nlist_for_each_entry(event, &gameport_event_list, node) {\r\nif (event->type == GAMEPORT_REGISTER_PORT) {\r\ngameport = event->object;\r\nif (gameport->parent == parent) {\r\nchild = gameport;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&gameport_event_lock, flags);\r\nreturn child;\r\n}\r\nstatic ssize_t gameport_description_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct gameport *gameport = to_gameport_port(dev);\r\nreturn sprintf(buf, "%s\n", gameport->name);\r\n}\r\nstatic ssize_t drvctl_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct gameport *gameport = to_gameport_port(dev);\r\nstruct device_driver *drv;\r\nint error;\r\nerror = mutex_lock_interruptible(&gameport_mutex);\r\nif (error)\r\nreturn error;\r\nif (!strncmp(buf, "none", count)) {\r\ngameport_disconnect_port(gameport);\r\n} else if (!strncmp(buf, "reconnect", count)) {\r\ngameport_reconnect_port(gameport);\r\n} else if (!strncmp(buf, "rescan", count)) {\r\ngameport_disconnect_port(gameport);\r\ngameport_find_driver(gameport);\r\n} else if ((drv = driver_find(buf, &gameport_bus)) != NULL) {\r\ngameport_disconnect_port(gameport);\r\nerror = gameport_bind_driver(gameport, to_gameport_driver(drv));\r\n} else {\r\nerror = -EINVAL;\r\n}\r\nmutex_unlock(&gameport_mutex);\r\nreturn error ? error : count;\r\n}\r\nstatic void gameport_release_port(struct device *dev)\r\n{\r\nstruct gameport *gameport = to_gameport_port(dev);\r\nkfree(gameport);\r\nmodule_put(THIS_MODULE);\r\n}\r\nvoid gameport_set_phys(struct gameport *gameport, const char *fmt, ...)\r\n{\r\nva_list args;\r\nva_start(args, fmt);\r\nvsnprintf(gameport->phys, sizeof(gameport->phys), fmt, args);\r\nva_end(args);\r\n}\r\nstatic void gameport_init_port(struct gameport *gameport)\r\n{\r\nstatic atomic_t gameport_no = ATOMIC_INIT(0);\r\n__module_get(THIS_MODULE);\r\nmutex_init(&gameport->drv_mutex);\r\ndevice_initialize(&gameport->dev);\r\ndev_set_name(&gameport->dev, "gameport%lu",\r\n(unsigned long)atomic_inc_return(&gameport_no) - 1);\r\ngameport->dev.bus = &gameport_bus;\r\ngameport->dev.release = gameport_release_port;\r\nif (gameport->parent)\r\ngameport->dev.parent = &gameport->parent->dev;\r\nINIT_LIST_HEAD(&gameport->node);\r\nspin_lock_init(&gameport->timer_lock);\r\ninit_timer(&gameport->poll_timer);\r\ngameport->poll_timer.function = gameport_run_poll_handler;\r\ngameport->poll_timer.data = (unsigned long)gameport;\r\n}\r\nstatic void gameport_add_port(struct gameport *gameport)\r\n{\r\nint error;\r\nif (gameport->parent)\r\ngameport->parent->child = gameport;\r\ngameport->speed = gameport_measure_speed(gameport);\r\nlist_add_tail(&gameport->node, &gameport_list);\r\nif (gameport->io)\r\ndev_info(&gameport->dev, "%s is %s, io %#x, speed %dkHz\n",\r\ngameport->name, gameport->phys, gameport->io, gameport->speed);\r\nelse\r\ndev_info(&gameport->dev, "%s is %s, speed %dkHz\n",\r\ngameport->name, gameport->phys, gameport->speed);\r\nerror = device_add(&gameport->dev);\r\nif (error)\r\ndev_err(&gameport->dev,\r\n"device_add() failed for %s (%s), error: %d\n",\r\ngameport->phys, gameport->name, error);\r\n}\r\nstatic void gameport_destroy_port(struct gameport *gameport)\r\n{\r\nstruct gameport *child;\r\nchild = gameport_get_pending_child(gameport);\r\nif (child) {\r\ngameport_remove_pending_events(child);\r\nput_device(&child->dev);\r\n}\r\nif (gameport->parent) {\r\ngameport->parent->child = NULL;\r\ngameport->parent = NULL;\r\n}\r\nif (device_is_registered(&gameport->dev))\r\ndevice_del(&gameport->dev);\r\nlist_del_init(&gameport->node);\r\ngameport_remove_pending_events(gameport);\r\nput_device(&gameport->dev);\r\n}\r\nstatic void gameport_reconnect_port(struct gameport *gameport)\r\n{\r\ndo {\r\nif (!gameport->drv || !gameport->drv->reconnect || gameport->drv->reconnect(gameport)) {\r\ngameport_disconnect_port(gameport);\r\ngameport_find_driver(gameport);\r\nbreak;\r\n}\r\ngameport = gameport->child;\r\n} while (gameport);\r\n}\r\nstatic void gameport_disconnect_port(struct gameport *gameport)\r\n{\r\nstruct gameport *s, *parent;\r\nif (gameport->child) {\r\nfor (s = gameport; s->child; s = s->child)\r\n;\r\ndo {\r\nparent = s->parent;\r\ndevice_release_driver(&s->dev);\r\ngameport_destroy_port(s);\r\n} while ((s = parent) != gameport);\r\n}\r\ndevice_release_driver(&gameport->dev);\r\n}\r\nvoid __gameport_register_port(struct gameport *gameport, struct module *owner)\r\n{\r\ngameport_init_port(gameport);\r\ngameport_queue_event(gameport, owner, GAMEPORT_REGISTER_PORT);\r\n}\r\nvoid gameport_unregister_port(struct gameport *gameport)\r\n{\r\nmutex_lock(&gameport_mutex);\r\ngameport_disconnect_port(gameport);\r\ngameport_destroy_port(gameport);\r\nmutex_unlock(&gameport_mutex);\r\n}\r\nstatic ssize_t description_show(struct device_driver *drv, char *buf)\r\n{\r\nstruct gameport_driver *driver = to_gameport_driver(drv);\r\nreturn sprintf(buf, "%s\n", driver->description ? driver->description : "(none)");\r\n}\r\nstatic int gameport_driver_probe(struct device *dev)\r\n{\r\nstruct gameport *gameport = to_gameport_port(dev);\r\nstruct gameport_driver *drv = to_gameport_driver(dev->driver);\r\ndrv->connect(gameport, drv);\r\nreturn gameport->drv ? 0 : -ENODEV;\r\n}\r\nstatic int gameport_driver_remove(struct device *dev)\r\n{\r\nstruct gameport *gameport = to_gameport_port(dev);\r\nstruct gameport_driver *drv = to_gameport_driver(dev->driver);\r\ndrv->disconnect(gameport);\r\nreturn 0;\r\n}\r\nstatic void gameport_attach_driver(struct gameport_driver *drv)\r\n{\r\nint error;\r\nerror = driver_attach(&drv->driver);\r\nif (error)\r\npr_err("driver_attach() failed for %s, error: %d\n",\r\ndrv->driver.name, error);\r\n}\r\nint __gameport_register_driver(struct gameport_driver *drv, struct module *owner,\r\nconst char *mod_name)\r\n{\r\nint error;\r\ndrv->driver.bus = &gameport_bus;\r\ndrv->driver.owner = owner;\r\ndrv->driver.mod_name = mod_name;\r\ndrv->ignore = true;\r\nerror = driver_register(&drv->driver);\r\nif (error) {\r\npr_err("driver_register() failed for %s, error: %d\n",\r\ndrv->driver.name, error);\r\nreturn error;\r\n}\r\ndrv->ignore = false;\r\nerror = gameport_queue_event(drv, NULL, GAMEPORT_ATTACH_DRIVER);\r\nif (error) {\r\ndriver_unregister(&drv->driver);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nvoid gameport_unregister_driver(struct gameport_driver *drv)\r\n{\r\nstruct gameport *gameport;\r\nmutex_lock(&gameport_mutex);\r\ndrv->ignore = true;\r\ngameport_remove_pending_events(drv);\r\nstart_over:\r\nlist_for_each_entry(gameport, &gameport_list, node) {\r\nif (gameport->drv == drv) {\r\ngameport_disconnect_port(gameport);\r\ngameport_find_driver(gameport);\r\ngoto start_over;\r\n}\r\n}\r\ndriver_unregister(&drv->driver);\r\nmutex_unlock(&gameport_mutex);\r\n}\r\nstatic int gameport_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct gameport_driver *gameport_drv = to_gameport_driver(drv);\r\nreturn !gameport_drv->ignore;\r\n}\r\nstatic void gameport_set_drv(struct gameport *gameport, struct gameport_driver *drv)\r\n{\r\nmutex_lock(&gameport->drv_mutex);\r\ngameport->drv = drv;\r\nmutex_unlock(&gameport->drv_mutex);\r\n}\r\nint gameport_open(struct gameport *gameport, struct gameport_driver *drv, int mode)\r\n{\r\nif (gameport->open) {\r\nif (gameport->open(gameport, mode)) {\r\nreturn -1;\r\n}\r\n} else {\r\nif (mode != GAMEPORT_MODE_RAW)\r\nreturn -1;\r\n}\r\ngameport_set_drv(gameport, drv);\r\nreturn 0;\r\n}\r\nvoid gameport_close(struct gameport *gameport)\r\n{\r\ndel_timer_sync(&gameport->poll_timer);\r\ngameport->poll_handler = NULL;\r\ngameport->poll_interval = 0;\r\ngameport_set_drv(gameport, NULL);\r\nif (gameport->close)\r\ngameport->close(gameport);\r\n}\r\nstatic int __init gameport_init(void)\r\n{\r\nint error;\r\nerror = bus_register(&gameport_bus);\r\nif (error) {\r\npr_err("failed to register gameport bus, error: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit gameport_exit(void)\r\n{\r\nbus_unregister(&gameport_bus);\r\ncancel_work_sync(&gameport_event_work);\r\n}
