static int eata_pio_show_info(struct seq_file *m, struct Scsi_Host *shost)\r\n{\r\nseq_printf(m, "EATA (Extended Attachment) PIO driver version: "\r\n"%d.%d%s\n",VER_MAJOR, VER_MINOR, VER_SUB);\r\nseq_printf(m, "queued commands: %10ld\n"\r\n"processed interrupts:%10ld\n", queue_counter, int_counter);\r\nseq_printf(m, "\nscsi%-2d: HBA %.10s\n",\r\nshost->host_no, SD(shost)->name);\r\nseq_printf(m, "Firmware revision: v%s\n",\r\nSD(shost)->revision);\r\nseq_printf(m, "IO: PIO\n");\r\nseq_printf(m, "Base IO : %#.4x\n", (u32) shost->base);\r\nseq_printf(m, "Host Bus: %s\n",\r\n(SD(shost)->bustype == 'P')?"PCI ":\r\n(SD(shost)->bustype == 'E')?"EISA":"ISA ");\r\nreturn 0;\r\n}\r\nstatic int eata_pio_release(struct Scsi_Host *sh)\r\n{\r\nhostdata *hd = SD(sh);\r\nif (sh->irq && reg_IRQ[sh->irq] == 1)\r\nfree_irq(sh->irq, NULL);\r\nelse\r\nreg_IRQ[sh->irq]--;\r\nif (SD(sh)->channel == 0) {\r\nif (sh->io_port && sh->n_io_port)\r\nrelease_region(sh->io_port, sh->n_io_port);\r\n}\r\nif (hd->pdev)\r\npci_dev_put(hd->pdev);\r\nreturn 1;\r\n}\r\nstatic void IncStat(struct scsi_pointer *SCp, unsigned int Increment)\r\n{\r\nSCp->ptr += Increment;\r\nif ((SCp->this_residual -= Increment) == 0) {\r\nif ((--SCp->buffers_residual) == 0)\r\nSCp->Status = 0;\r\nelse {\r\nSCp->buffer++;\r\nSCp->ptr = sg_virt(SCp->buffer);\r\nSCp->this_residual = SCp->buffer->length;\r\n}\r\n}\r\n}\r\nstatic irqreturn_t do_eata_pio_int_handler(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nstruct Scsi_Host *dev = dev_id;\r\nirqreturn_t ret;\r\nspin_lock_irqsave(dev->host_lock, flags);\r\nret = eata_pio_int_handler(irq, dev_id);\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t eata_pio_int_handler(int irq, void *dev_id)\r\n{\r\nunsigned int eata_stat = 0xfffff;\r\nstruct scsi_cmnd *cmd;\r\nhostdata *hd;\r\nstruct eata_ccb *cp;\r\nunsigned long base;\r\nunsigned int x, z;\r\nstruct Scsi_Host *sh;\r\nunsigned short zwickel = 0;\r\nunsigned char stat, odd;\r\nirqreturn_t ret = IRQ_NONE;\r\nfor (x = 1, sh = first_HBA; x <= registered_HBAs; x++, sh = SD(sh)->prev)\r\n{\r\nif (sh->irq != irq)\r\ncontinue;\r\nif (inb(sh->base + HA_RSTATUS) & HA_SBUSY)\r\ncontinue;\r\nint_counter++;\r\nret = IRQ_HANDLED;\r\nhd = SD(sh);\r\ncp = &hd->ccb[0];\r\ncmd = cp->cmd;\r\nbase = cmd->device->host->base;\r\ndo {\r\nstat = inb(base + HA_RSTATUS);\r\nif (stat & HA_SDRQ) {\r\nif (cp->DataIn) {\r\nz = 256;\r\nodd = 0;\r\nwhile ((cmd->SCp.Status) && ((z > 0) || (odd))) {\r\nif (odd) {\r\n*(cmd->SCp.ptr) = zwickel >> 8;\r\nIncStat(&cmd->SCp, 1);\r\nodd = 0;\r\n}\r\nx = min_t(unsigned int, z, cmd->SCp.this_residual / 2);\r\ninsw(base + HA_RDATA, cmd->SCp.ptr, x);\r\nz -= x;\r\nIncStat(&cmd->SCp, 2 * x);\r\nif ((z > 0) && (cmd->SCp.this_residual == 1)) {\r\nzwickel = inw(base + HA_RDATA);\r\n*(cmd->SCp.ptr) = zwickel & 0xff;\r\nIncStat(&cmd->SCp, 1);\r\nz--;\r\nodd = 1;\r\n}\r\n}\r\nwhile (z > 0) {\r\nzwickel = inw(base + HA_RDATA);\r\nz--;\r\n}\r\n} else {\r\nodd = 0;\r\nz = 256;\r\nwhile ((cmd->SCp.Status) && ((z > 0) || (odd))) {\r\nif (odd) {\r\nzwickel += *(cmd->SCp.ptr) << 8;\r\nIncStat(&cmd->SCp, 1);\r\noutw(zwickel, base + HA_RDATA);\r\nz--;\r\nodd = 0;\r\n}\r\nx = min_t(unsigned int, z, cmd->SCp.this_residual / 2);\r\noutsw(base + HA_RDATA, cmd->SCp.ptr, x);\r\nz -= x;\r\nIncStat(&cmd->SCp, 2 * x);\r\nif ((z > 0) && (cmd->SCp.this_residual == 1)) {\r\nzwickel = *(cmd->SCp.ptr);\r\nzwickel &= 0xff;\r\nIncStat(&cmd->SCp, 1);\r\nodd = 1;\r\n}\r\n}\r\nwhile (z > 0 || odd) {\r\noutw(zwickel, base + HA_RDATA);\r\nz--;\r\nodd = 0;\r\n}\r\n}\r\n}\r\n}\r\nwhile ((stat & HA_SDRQ) || ((stat & HA_SMORE) && hd->moresupport));\r\nif (stat & HA_SBUSY)\r\nbreak;\r\nif (!(inb(base + HA_RSTATUS) & HA_SERROR)) {\r\ncmd->result = (DID_OK << 16);\r\nhd->devflags |= (1 << cp->cp_id);\r\n} else if (hd->devflags & (1 << cp->cp_id))\r\ncmd->result = (DID_OK << 16) + 0x02;\r\nelse\r\ncmd->result = (DID_NO_CONNECT << 16);\r\nif (cp->status == LOCKED) {\r\ncp->status = FREE;\r\neata_stat = inb(base + HA_RSTATUS);\r\nprintk(KERN_CRIT "eata_pio: int_handler, freeing locked " "queueslot\n");\r\nreturn ret;\r\n}\r\n#if DBG_INTR2\r\nif (stat != 0x50)\r\nprintk(KERN_DEBUG "stat: %#.2x, result: %#.8x\n", stat, cmd->result);\r\n#endif\r\ncp->status = FREE;\r\ncmd->scsi_done(cmd);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline unsigned int eata_pio_send_command(unsigned long base, unsigned char command)\r\n{\r\nunsigned int loop = 50;\r\nwhile (inb(base + HA_RSTATUS) & HA_SBUSY)\r\nif (--loop == 0)\r\nreturn 1;\r\noutb(HA_CTRL_8HEADS, base + HA_CTRLREG);\r\noutb(command, base + HA_WCOMMAND);\r\nreturn 0;\r\n}\r\nstatic int eata_pio_queue_lck(struct scsi_cmnd *cmd,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nunsigned int x, y;\r\nunsigned long base;\r\nhostdata *hd;\r\nstruct Scsi_Host *sh;\r\nstruct eata_ccb *cp;\r\nqueue_counter++;\r\nhd = HD(cmd);\r\nsh = cmd->device->host;\r\nbase = sh->base;\r\ny = x = 0;\r\nif (hd->ccb[y].status != FREE) {\r\nDBG(DBG_QUEUE, printk(KERN_EMERG "can_queue %d, x %d, y %d\n", sh->can_queue, x, y));\r\n#if DEBUG_EATA\r\npanic(KERN_EMERG "eata_pio: run out of queue slots cmdno:%ld " "intrno: %ld\n", queue_counter, int_counter);\r\n#else\r\npanic(KERN_EMERG "eata_pio: run out of queue slots....\n");\r\n#endif\r\n}\r\ncp = &hd->ccb[y];\r\nmemset(cp, 0, sizeof(struct eata_ccb));\r\ncp->status = USED;\r\nDBG(DBG_QUEUE, scmd_printk(KERN_DEBUG, cmd,\r\n"eata_pio_queue 0x%p, y %d\n", cmd, y));\r\ncmd->scsi_done = (void *) done;\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE)\r\ncp->DataOut = 1;\r\nelse\r\ncp->DataIn = 0;\r\ncp->Interpret = (cmd->device->id == hd->hostid);\r\ncp->cp_datalen = cpu_to_be32(scsi_bufflen(cmd));\r\ncp->Auto_Req_Sen = 0;\r\ncp->cp_reqDMA = 0;\r\ncp->reqlen = 0;\r\ncp->cp_id = cmd->device->id;\r\ncp->cp_lun = cmd->device->lun;\r\ncp->cp_dispri = 0;\r\ncp->cp_identify = 1;\r\nmemcpy(cp->cp_cdb, cmd->cmnd, COMMAND_SIZE(*cmd->cmnd));\r\ncp->cp_statDMA = 0;\r\ncp->cp_viraddr = cp;\r\ncp->cmd = cmd;\r\ncmd->host_scribble = (char *) &hd->ccb[y];\r\nif (!scsi_bufflen(cmd)) {\r\ncmd->SCp.buffers_residual = 1;\r\ncmd->SCp.ptr = NULL;\r\ncmd->SCp.this_residual = 0;\r\ncmd->SCp.buffer = NULL;\r\n} else {\r\ncmd->SCp.buffer = scsi_sglist(cmd);\r\ncmd->SCp.buffers_residual = scsi_sg_count(cmd);\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\ncmd->SCp.this_residual = cmd->SCp.buffer->length;\r\n}\r\ncmd->SCp.Status = (cmd->SCp.this_residual != 0);\r\nif (eata_pio_send_command(base, EATA_CMD_PIO_SEND_CP)) {\r\ncmd->result = DID_BUS_BUSY << 16;\r\nscmd_printk(KERN_NOTICE, cmd,\r\n"eata_pio_queue pid 0x%p, HBA busy, "\r\n"returning DID_BUS_BUSY, done.\n", cmd);\r\ndone(cmd);\r\ncp->status = FREE;\r\nreturn 0;\r\n}\r\nwhile (!(inb(base + HA_RSTATUS) & HA_SDRQ))\r\ncpu_relax();\r\noutsw(base + HA_RDATA, cp, hd->cplen);\r\noutb(EATA_CMD_PIO_TRUNC, base + HA_WCOMMAND);\r\nfor (x = 0; x < hd->cppadlen; x++)\r\noutw(0, base + HA_RDATA);\r\nDBG(DBG_QUEUE, scmd_printk(KERN_DEBUG, cmd,\r\n"Queued base %#.4lx cmd: 0x%p "\r\n"slot %d irq %d\n", sh->base, cmd, y, sh->irq));\r\nreturn 0;\r\n}\r\nint eata_pio_host_reset(struct scsi_cmnd *cmd)\r\n{\r\nunsigned int x, limit = 0;\r\nunsigned char success = 0;\r\nstruct scsi_cmnd *sp;\r\nstruct Scsi_Host *host = cmd->device->host;\r\nDBG(DBG_ABNORM, scmd_printk(KERN_WARNING, cmd,\r\n"eata_pio_reset called\n"));\r\nspin_lock_irq(host->host_lock);\r\nif (HD(cmd)->state == RESET) {\r\nprintk(KERN_WARNING "eata_pio_reset: exit, already in reset.\n");\r\nspin_unlock_irq(host->host_lock);\r\nreturn FAILED;\r\n}\r\nfor (x = 0; x < cmd->device->host->can_queue; x++) {\r\nif (HD(cmd)->ccb[x].status == FREE)\r\ncontinue;\r\nsp = HD(cmd)->ccb[x].cmd;\r\nHD(cmd)->ccb[x].status = RESET;\r\nprintk(KERN_WARNING "eata_pio_reset: slot %d in reset.\n", x);\r\nif (sp == NULL)\r\npanic("eata_pio_reset: slot %d, sp==NULL.\n", x);\r\n}\r\noutb(EATA_CMD_RESET, cmd->device->host->base + HA_WCOMMAND);\r\nDBG(DBG_ABNORM, printk(KERN_WARNING "eata_pio_reset: board reset done.\n"));\r\nHD(cmd)->state = RESET;\r\nspin_unlock_irq(host->host_lock);\r\nmsleep(3000);\r\nspin_lock_irq(host->host_lock);\r\nDBG(DBG_ABNORM, printk(KERN_WARNING "eata_pio_reset: interrupts disabled, " "loops %d.\n", limit));\r\nfor (x = 0; x < cmd->device->host->can_queue; x++) {\r\nif (HD(cmd)->ccb[x].status != RESET)\r\ncontinue;\r\nsp = HD(cmd)->ccb[x].cmd;\r\nsp->result = DID_RESET << 16;\r\nprintk(KERN_WARNING "eata_pio_reset: reset ccb %d.\n", x);\r\nHD(cmd)->ccb[x].status = FREE;\r\nsp->scsi_done(sp);\r\n}\r\nHD(cmd)->state = 0;\r\nspin_unlock_irq(host->host_lock);\r\nif (success) {\r\nDBG(DBG_ABNORM, printk(KERN_WARNING "eata_pio_reset: exit, success.\n"));\r\nreturn SUCCESS;\r\n} else {\r\nDBG(DBG_ABNORM, printk(KERN_WARNING "eata_pio_reset: exit, wakeup.\n"));\r\nreturn FAILED;\r\n}\r\n}\r\nstatic char *get_pio_board_data(unsigned long base, unsigned int irq, unsigned int id, unsigned long cplen, unsigned short cppadlen)\r\n{\r\nstruct eata_ccb cp;\r\nstatic char buff[256];\r\nint z;\r\nmemset(&cp, 0, sizeof(struct eata_ccb));\r\nmemset(buff, 0, sizeof(buff));\r\ncp.DataIn = 1;\r\ncp.Interpret = 1;\r\ncp.cp_datalen = cpu_to_be32(254);\r\ncp.cp_dataDMA = cpu_to_be32(0);\r\ncp.cp_id = id;\r\ncp.cp_lun = 0;\r\ncp.cp_cdb[0] = INQUIRY;\r\ncp.cp_cdb[1] = 0;\r\ncp.cp_cdb[2] = 0;\r\ncp.cp_cdb[3] = 0;\r\ncp.cp_cdb[4] = 254;\r\ncp.cp_cdb[5] = 0;\r\nif (eata_pio_send_command(base, EATA_CMD_PIO_SEND_CP))\r\nreturn NULL;\r\nwhile (!(inb(base + HA_RSTATUS) & HA_SDRQ))\r\ncpu_relax();\r\noutsw(base + HA_RDATA, &cp, cplen);\r\noutb(EATA_CMD_PIO_TRUNC, base + HA_WCOMMAND);\r\nfor (z = 0; z < cppadlen; z++)\r\noutw(0, base + HA_RDATA);\r\nwhile (inb(base + HA_RSTATUS) & HA_SBUSY)\r\ncpu_relax();\r\nif (inb(base + HA_RSTATUS) & HA_SERROR)\r\nreturn NULL;\r\nelse if (!(inb(base + HA_RSTATUS) & HA_SDRQ))\r\nreturn NULL;\r\nelse {\r\ninsw(base + HA_RDATA, &buff, 127);\r\nwhile (inb(base + HA_RSTATUS) & HA_SDRQ)\r\ninw(base + HA_RDATA);\r\nreturn buff;\r\n}\r\n}\r\nstatic int get_pio_conf_PIO(unsigned long base, struct get_conf *buf)\r\n{\r\nunsigned long loop = HZ / 2;\r\nint z;\r\nunsigned short *p;\r\nif (!request_region(base, 9, "eata_pio"))\r\nreturn 0;\r\nmemset(buf, 0, sizeof(struct get_conf));\r\nwhile (inb(base + HA_RSTATUS) & HA_SBUSY)\r\nif (--loop == 0)\r\ngoto fail;\r\nDBG(DBG_PIO && DBG_PROBE, printk(KERN_DEBUG "Issuing PIO READ CONFIG to HBA at %#lx\n", base));\r\neata_pio_send_command(base, EATA_CMD_PIO_READ_CONFIG);\r\nloop = 50;\r\nfor (p = (unsigned short *) buf; (long) p <= ((long) buf + (sizeof(struct get_conf) / 2)); p++) {\r\nwhile (!(inb(base + HA_RSTATUS) & HA_SDRQ))\r\nif (--loop == 0)\r\ngoto fail;\r\nloop = 50;\r\n*p = inw(base + HA_RDATA);\r\n}\r\nif (inb(base + HA_RSTATUS) & HA_SERROR) {\r\nDBG(DBG_PROBE, printk("eata_dma: get_conf_PIO, error during "\r\n"transfer for HBA at %lx\n", base));\r\ngoto fail;\r\n}\r\nif (cpu_to_be32(EATA_SIGNATURE) != buf->signature)\r\ngoto fail;\r\nDBG(DBG_PIO && DBG_PROBE, printk(KERN_NOTICE "EATA Controller found "\r\n"at %#4lx EATA Level: %x\n",\r\nbase, (unsigned int) (buf->version)));\r\nwhile (inb(base + HA_RSTATUS) & HA_SDRQ)\r\ninw(base + HA_RDATA);\r\nif (!ALLOW_DMA_BOARDS) {\r\nfor (z = 0; z < MAXISA; z++)\r\nif (base == ISAbases[z]) {\r\nbuf->IRQ = ISAirqs[z];\r\nbreak;\r\n}\r\n}\r\nreturn 1;\r\nfail:\r\nrelease_region(base, 9);\r\nreturn 0;\r\n}\r\nstatic void print_pio_config(struct get_conf *gc)\r\n{\r\nprintk("Please check values: (read config data)\n");\r\nprintk("LEN: %d ver:%d OCS:%d TAR:%d TRNXFR:%d MORES:%d\n", be32_to_cpu(gc->len), gc->version, gc->OCS_enabled, gc->TAR_support, gc->TRNXFR, gc->MORE_support);\r\nprintk("HAAV:%d SCSIID0:%d ID1:%d ID2:%d QUEUE:%d SG:%d SEC:%d\n", gc->HAA_valid, gc->scsi_id[3], gc->scsi_id[2], gc->scsi_id[1], be16_to_cpu(gc->queuesiz), be16_to_cpu(gc->SGsiz), gc->SECOND);\r\nprintk("IRQ:%d IRQT:%d FORCADR:%d MCH:%d RIDQ:%d\n", gc->IRQ, gc->IRQ_TR, gc->FORCADR, gc->MAX_CHAN, gc->ID_qest);\r\n}\r\nstatic unsigned int print_selftest(unsigned int base)\r\n{\r\nunsigned char buffer[512];\r\n#ifdef VERBOSE_SETUP\r\nint z;\r\n#endif\r\nprintk("eata_pio: executing controller self test & setup...\n");\r\nwhile (inb(base + HA_RSTATUS) & HA_SBUSY);\r\noutb(EATA_CMD_PIO_SETUPTEST, base + HA_WCOMMAND);\r\ndo {\r\nwhile (inb(base + HA_RSTATUS) & HA_SBUSY)\r\n;\r\nif (inb(base + HA_RSTATUS) & HA_SDRQ) {\r\ninsw(base + HA_RDATA, &buffer, 256);\r\n#ifdef VERBOSE_SETUP\r\nfor (z = 0; z < 511 && buffer[z]; z++)\r\nif (buffer[z] != 7)\r\nprintk("%c", buffer[z]);\r\n#endif\r\n}\r\n} while (inb(base + HA_RSTATUS) & (HA_SBUSY | HA_SDRQ));\r\nreturn (!(inb(base + HA_RSTATUS) & HA_SERROR));\r\n}\r\nstatic int register_pio_HBA(long base, struct get_conf *gc, struct pci_dev *pdev)\r\n{\r\nunsigned long size = 0;\r\nchar *buff;\r\nunsigned long cplen;\r\nunsigned short cppadlen;\r\nstruct Scsi_Host *sh;\r\nhostdata *hd;\r\nDBG(DBG_REGISTER, print_pio_config(gc));\r\nif (gc->DMA_support) {\r\nprintk("HBA at %#.4lx supports DMA. Please use EATA-DMA driver.\n", base);\r\nif (!ALLOW_DMA_BOARDS)\r\nreturn 0;\r\n}\r\nif ((buff = get_pio_board_data(base, gc->IRQ, gc->scsi_id[3], cplen = (cpu_to_be32(gc->cplen) + 1) / 2, cppadlen = (cpu_to_be16(gc->cppadlen) + 1) / 2)) == NULL) {\r\nprintk("HBA at %#lx didn't react on INQUIRY. Sorry.\n", base);\r\nreturn 0;\r\n}\r\nif (!print_selftest(base) && !ALLOW_DMA_BOARDS) {\r\nprintk("HBA at %#lx failed while performing self test & setup.\n", base);\r\nreturn 0;\r\n}\r\nsize = sizeof(hostdata) + (sizeof(struct eata_ccb) * be16_to_cpu(gc->queuesiz));\r\nsh = scsi_register(&driver_template, size);\r\nif (sh == NULL)\r\nreturn 0;\r\nif (!reg_IRQ[gc->IRQ]) {\r\nif (!request_irq(gc->IRQ, do_eata_pio_int_handler, 0, "EATA-PIO", sh)) {\r\nreg_IRQ[gc->IRQ]++;\r\nif (!gc->IRQ_TR)\r\nreg_IRQL[gc->IRQ] = 1;\r\n} else {\r\nprintk("Couldn't allocate IRQ %d, Sorry.\n", gc->IRQ);\r\nreturn 0;\r\n}\r\n} else {\r\nif (reg_IRQL[gc->IRQ]) {\r\nprintk("Can't support more than one HBA on this IRQ,\n" " if the IRQ is edge triggered. Sorry.\n");\r\nreturn 0;\r\n} else\r\nreg_IRQ[gc->IRQ]++;\r\n}\r\nhd = SD(sh);\r\nmemset(hd->ccb, 0, (sizeof(struct eata_ccb) * be16_to_cpu(gc->queuesiz)));\r\nmemset(hd->reads, 0, sizeof(hd->reads));\r\nstrlcpy(SD(sh)->vendor, &buff[8], sizeof(SD(sh)->vendor));\r\nstrlcpy(SD(sh)->name, &buff[16], sizeof(SD(sh)->name));\r\nSD(sh)->revision[0] = buff[32];\r\nSD(sh)->revision[1] = buff[33];\r\nSD(sh)->revision[2] = buff[34];\r\nSD(sh)->revision[3] = '.';\r\nSD(sh)->revision[4] = buff[35];\r\nSD(sh)->revision[5] = 0;\r\nswitch (be32_to_cpu(gc->len)) {\r\ncase 0x1c:\r\nSD(sh)->EATA_revision = 'a';\r\nbreak;\r\ncase 0x1e:\r\nSD(sh)->EATA_revision = 'b';\r\nbreak;\r\ncase 0x22:\r\nSD(sh)->EATA_revision = 'c';\r\nbreak;\r\ncase 0x24:\r\nSD(sh)->EATA_revision = 'z';\r\ndefault:\r\nSD(sh)->EATA_revision = '?';\r\n}\r\nif (be32_to_cpu(gc->len) >= 0x22) {\r\nif (gc->is_PCI)\r\nhd->bustype = IS_PCI;\r\nelse if (gc->is_EISA)\r\nhd->bustype = IS_EISA;\r\nelse\r\nhd->bustype = IS_ISA;\r\n} else {\r\nif (buff[21] == '4')\r\nhd->bustype = IS_PCI;\r\nelse if (buff[21] == '2')\r\nhd->bustype = IS_EISA;\r\nelse\r\nhd->bustype = IS_ISA;\r\n}\r\nSD(sh)->cplen = cplen;\r\nSD(sh)->cppadlen = cppadlen;\r\nSD(sh)->hostid = gc->scsi_id[3];\r\nSD(sh)->devflags = 1 << gc->scsi_id[3];\r\nSD(sh)->moresupport = gc->MORE_support;\r\nsh->unique_id = base;\r\nsh->base = base;\r\nsh->io_port = base;\r\nsh->n_io_port = 9;\r\nsh->irq = gc->IRQ;\r\nsh->dma_channel = PIO;\r\nsh->this_id = gc->scsi_id[3];\r\nsh->can_queue = 1;\r\nsh->cmd_per_lun = 1;\r\nsh->sg_tablesize = SG_ALL;\r\nhd->channel = 0;\r\nhd->pdev = pci_dev_get(pdev);\r\nsh->max_id = 8;\r\nsh->max_lun = 8;\r\nif (gc->SECOND)\r\nhd->primary = 0;\r\nelse\r\nhd->primary = 1;\r\nhd->next = NULL;\r\nhd->prev = last_HBA;\r\nif (hd->prev != NULL)\r\nSD(hd->prev)->next = sh;\r\nlast_HBA = sh;\r\nif (first_HBA == NULL)\r\nfirst_HBA = sh;\r\nregistered_HBAs++;\r\nreturn (1);\r\n}\r\nstatic void find_pio_ISA(struct get_conf *buf)\r\n{\r\nint i;\r\nfor (i = 0; i < MAXISA; i++) {\r\nif (!ISAbases[i])\r\ncontinue;\r\nif (!get_pio_conf_PIO(ISAbases[i], buf))\r\ncontinue;\r\nif (!register_pio_HBA(ISAbases[i], buf, NULL))\r\nrelease_region(ISAbases[i], 9);\r\nelse\r\nISAbases[i] = 0;\r\n}\r\nreturn;\r\n}\r\nstatic void find_pio_EISA(struct get_conf *buf)\r\n{\r\nu32 base;\r\nint i;\r\n#ifdef CHECKPAL\r\nu8 pal1, pal2, pal3;\r\n#endif\r\nfor (i = 0; i < MAXEISA; i++) {\r\nif (EISAbases[i]) {\r\nbase = 0x1c88 + (i * 0x1000);\r\n#ifdef CHECKPAL\r\npal1 = inb((u16) base - 8);\r\npal2 = inb((u16) base - 7);\r\npal3 = inb((u16) base - 6);\r\nif (((pal1 == 0x12) && (pal2 == 0x14)) || ((pal1 == 0x38) && (pal2 == 0xa3) && (pal3 == 0x82)) || ((pal1 == 0x06) && (pal2 == 0x94) && (pal3 == 0x24))) {\r\nDBG(DBG_PROBE, printk(KERN_NOTICE "EISA EATA id tags found: " "%x %x %x \n", (int) pal1, (int) pal2, (int) pal3));\r\n#endif\r\nif (get_pio_conf_PIO(base, buf)) {\r\nDBG(DBG_PROBE && DBG_EISA, print_pio_config(buf));\r\nif (buf->IRQ) {\r\nif (!register_pio_HBA(base, buf, NULL))\r\nrelease_region(base, 9);\r\n} else {\r\nprintk(KERN_NOTICE "eata_dma: No valid IRQ. HBA " "removed from list\n");\r\nrelease_region(base, 9);\r\n}\r\n}\r\nEISAbases[i] = 0;\r\n#ifdef CHECKPAL\r\n}\r\n#endif\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void find_pio_PCI(struct get_conf *buf)\r\n{\r\n#ifndef CONFIG_PCI\r\nprintk("eata_dma: kernel PCI support not enabled. Skipping scan for PCI HBAs.\n");\r\n#else\r\nstruct pci_dev *dev = NULL;\r\nunsigned long base, x;\r\nwhile ((dev = pci_get_device(PCI_VENDOR_ID_DPT, PCI_DEVICE_ID_DPT, dev)) != NULL) {\r\nDBG(DBG_PROBE && DBG_PCI, printk("eata_pio: find_PCI, HBA at %s\n", pci_name(dev)));\r\nif (pci_enable_device(dev))\r\ncontinue;\r\npci_set_master(dev);\r\nbase = pci_resource_flags(dev, 0);\r\nif (base & IORESOURCE_MEM) {\r\nprintk("eata_pio: invalid base address of device %s\n", pci_name(dev));\r\ncontinue;\r\n}\r\nbase = pci_resource_start(dev, 0);\r\nif ((inb(base) == 0x12) && (inb(base + 1) == 0x14))\r\ncontinue;\r\nbase += 0x10;\r\nif (base != 0x1f8) {\r\nif (get_pio_conf_PIO(base, buf)) {\r\nif (buf->FORCADR) {\r\nrelease_region(base, 9);\r\ncontinue;\r\n}\r\nif (!register_pio_HBA(base, buf, dev)) {\r\nrelease_region(base, 9);\r\ncontinue;\r\n}\r\nif (base < 0x1000) {\r\nfor (x = 0; x < MAXISA; ++x) {\r\nif (ISAbases[x] == base) {\r\nISAbases[x] = 0;\r\nbreak;\r\n}\r\n}\r\n} else if ((base & 0x0fff) == 0x0c88) {\r\nx = (base >> 12) & 0x0f;\r\nEISAbases[x] = 0;\r\n}\r\n}\r\n#ifdef CHECK_BLINK\r\nelse if (check_blink_state(base)) {\r\nprintk("eata_pio: HBA is in BLINK state.\n" "Consult your HBAs manual to correct this.\n");\r\n}\r\n#endif\r\n}\r\n}\r\n#endif\r\n}\r\nstatic int eata_pio_detect(struct scsi_host_template *tpnt)\r\n{\r\nstruct Scsi_Host *HBA_ptr;\r\nstruct get_conf gc;\r\nint i;\r\nfind_pio_PCI(&gc);\r\nfind_pio_EISA(&gc);\r\nfind_pio_ISA(&gc);\r\nfor (i = 0; i < MAXIRQ; i++)\r\nif (reg_IRQ[i])\r\nrequest_irq(i, do_eata_pio_int_handler, 0, "EATA-PIO", NULL);\r\nHBA_ptr = first_HBA;\r\nif (registered_HBAs != 0) {\r\nprintk("EATA (Extended Attachment) PIO driver version: %d.%d%s\n"\r\n"(c) 1993-95 Michael Neuffer, neuffer@goofy.zdv.uni-mainz.de\n" " Alfred Arnold, a.arnold@kfa-juelich.de\n" "This release only supports DASD devices (harddisks)\n", VER_MAJOR, VER_MINOR, VER_SUB);\r\nprintk("Registered HBAs:\n");\r\nprintk("HBA no. Boardtype: Revis: EATA: Bus: BaseIO: IRQ: Ch: ID: Pr:" " QS: SG: CPL:\n");\r\nfor (i = 1; i <= registered_HBAs; i++) {\r\nprintk("scsi%-2d: %.10s v%s 2.0%c %s %#.4lx %2d %d %d %c"\r\n" %2d %2d %2d\n",\r\nHBA_ptr->host_no, SD(HBA_ptr)->name, SD(HBA_ptr)->revision,\r\nSD(HBA_ptr)->EATA_revision, (SD(HBA_ptr)->bustype == 'P') ?\r\n"PCI " : (SD(HBA_ptr)->bustype == 'E') ? "EISA" : "ISA ",\r\nHBA_ptr->base, HBA_ptr->irq, SD(HBA_ptr)->channel, HBA_ptr->this_id,\r\nSD(HBA_ptr)->primary ? 'Y' : 'N', HBA_ptr->can_queue,\r\nHBA_ptr->sg_tablesize, HBA_ptr->cmd_per_lun);\r\nHBA_ptr = SD(HBA_ptr)->next;\r\n}\r\n}\r\nreturn (registered_HBAs);\r\n}
