static void wacom_scramble(__u8 *image)\r\n{\r\n__u16 mask;\r\n__u16 s1;\r\n__u16 s2;\r\n__u16 r1 ;\r\n__u16 r2 ;\r\n__u16 r;\r\n__u8 buf[256];\r\nint i, w, x, y, z;\r\nfor (x = 0; x < 32; x++) {\r\nfor (y = 0; y < 8; y++)\r\nbuf[(8 * x) + (7 - y)] = image[(8 * x) + y];\r\n}\r\nfor (x = 0; x < 4; x++) {\r\nfor (y = 0; y < 4; y++) {\r\nfor (z = 0; z < 8; z++) {\r\nmask = 0x0001;\r\nr1 = 0;\r\nr2 = 0;\r\ni = (x << 6) + (y << 4) + z;\r\ns1 = buf[i];\r\ns2 = buf[i+8];\r\nfor (w = 0; w < 8; w++) {\r\nr1 |= (s1 & mask);\r\nr2 |= (s2 & mask);\r\ns1 <<= 1;\r\ns2 <<= 1;\r\nmask <<= 2;\r\n}\r\nr = r1 | (r2 << 1);\r\ni = (x << 6) + (y << 4) + (z << 1);\r\nimage[i] = 0xFF & r;\r\nimage[i+1] = (0xFF00 & r) >> 8;\r\n}\r\n}\r\n}\r\n}\r\nstatic void wacom_set_image(struct hid_device *hdev, const char *image,\r\n__u8 icon_no)\r\n{\r\n__u8 rep_data[68];\r\n__u8 p[256];\r\nint ret, i, j;\r\nfor (i = 0; i < 256; i++)\r\np[i] = image[i];\r\nrep_data[0] = WAC_CMD_ICON_START_STOP;\r\nrep_data[1] = 0;\r\nret = hid_hw_raw_request(hdev, rep_data[0], rep_data, 2,\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nif (ret < 0)\r\ngoto err;\r\nrep_data[0] = WAC_CMD_ICON_TRANSFER;\r\nrep_data[1] = icon_no & 0x07;\r\nwacom_scramble(p);\r\nfor (i = 0; i < 4; i++) {\r\nfor (j = 0; j < 64; j++)\r\nrep_data[j + 3] = p[(i << 6) + j];\r\nrep_data[2] = i;\r\nret = hid_hw_raw_request(hdev, rep_data[0], rep_data, 67,\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\n}\r\nrep_data[0] = WAC_CMD_ICON_START_STOP;\r\nrep_data[1] = 0;\r\nret = hid_hw_raw_request(hdev, rep_data[0], rep_data, 2,\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nerr:\r\nreturn;\r\n}\r\nstatic void wacom_leds_set_brightness(struct led_classdev *led_dev,\r\nenum led_brightness value)\r\n{\r\nstruct device *dev = led_dev->dev->parent;\r\nstruct hid_device *hdev;\r\nstruct wacom_data *wdata;\r\nunsigned char *buf;\r\n__u8 led = 0;\r\nint i;\r\nhdev = container_of(dev, struct hid_device, dev);\r\nwdata = hid_get_drvdata(hdev);\r\nfor (i = 0; i < 4; ++i) {\r\nif (wdata->leds[i] == led_dev)\r\nwdata->led_selector = i;\r\n}\r\nled = wdata->led_selector | 0x04;\r\nbuf = kzalloc(9, GFP_KERNEL);\r\nif (buf) {\r\nbuf[0] = WAC_CMD_LED_CONTROL;\r\nbuf[1] = led;\r\nbuf[2] = value >> 2;\r\nbuf[3] = value;\r\nbuf[4] = 0x08;\r\nhid_hw_raw_request(hdev, buf[0], buf, 9, HID_FEATURE_REPORT,\r\nHID_REQ_SET_REPORT);\r\nkfree(buf);\r\n}\r\nreturn;\r\n}\r\nstatic enum led_brightness wacom_leds_get_brightness(struct led_classdev *led_dev)\r\n{\r\nstruct wacom_data *wdata;\r\nstruct device *dev = led_dev->dev->parent;\r\nint value = 0;\r\nint i;\r\nwdata = hid_get_drvdata(container_of(dev, struct hid_device, dev));\r\nfor (i = 0; i < 4; ++i) {\r\nif (wdata->leds[i] == led_dev) {\r\nvalue = wdata->leds[i]->brightness;\r\nbreak;\r\n}\r\n}\r\nreturn value;\r\n}\r\nstatic int wacom_initialize_leds(struct hid_device *hdev)\r\n{\r\nstruct wacom_data *wdata = hid_get_drvdata(hdev);\r\nstruct led_classdev *led;\r\nstruct device *dev = &hdev->dev;\r\nsize_t namesz = strlen(dev_name(dev)) + 12;\r\nchar *name;\r\nint i, ret;\r\nwdata->led_selector = 0;\r\nfor (i = 0; i < 4; i++) {\r\nled = kzalloc(sizeof(struct led_classdev) + namesz, GFP_KERNEL);\r\nif (!led) {\r\nhid_warn(hdev,\r\n"can't allocate memory for LED selector\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nname = (void *)&led[1];\r\nsnprintf(name, namesz, "%s:selector:%d", dev_name(dev), i);\r\nled->name = name;\r\nled->brightness = 0;\r\nled->max_brightness = 127;\r\nled->brightness_get = wacom_leds_get_brightness;\r\nled->brightness_set = wacom_leds_set_brightness;\r\nwdata->leds[i] = led;\r\nret = led_classdev_register(dev, wdata->leds[i]);\r\nif (ret) {\r\nwdata->leds[i] = NULL;\r\nkfree(led);\r\nhid_warn(hdev, "can't register LED\n");\r\ngoto err;\r\n}\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void wacom_destroy_leds(struct hid_device *hdev)\r\n{\r\nstruct wacom_data *wdata = hid_get_drvdata(hdev);\r\nstruct led_classdev *led;\r\nint i;\r\nfor (i = 0; i < 4; ++i) {\r\nif (wdata->leds[i]) {\r\nled = wdata->leds[i];\r\nwdata->leds[i] = NULL;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\n}\r\n}\r\nstatic int wacom_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct wacom_data *wdata = container_of(psy,\r\nstruct wacom_data, battery);\r\nint ret = 0;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = 1;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SCOPE:\r\nval->intval = POWER_SUPPLY_SCOPE_DEVICE;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nval->intval = wdata->battery_capacity;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (wdata->bat_charging)\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse\r\nif (wdata->battery_capacity == 100 && wdata->ps_connected)\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wacom_ac_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct wacom_data *wdata = container_of(psy, struct wacom_data, ac);\r\nint ret = 0;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = wdata->ps_connected;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SCOPE:\r\nval->intval = POWER_SUPPLY_SCOPE_DEVICE;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void wacom_set_features(struct hid_device *hdev, u8 speed)\r\n{\r\nstruct wacom_data *wdata = hid_get_drvdata(hdev);\r\nint limit, ret;\r\n__u8 rep_data[2];\r\nswitch (hdev->product) {\r\ncase USB_DEVICE_ID_WACOM_GRAPHIRE_BLUETOOTH:\r\nrep_data[0] = 0x03 ; rep_data[1] = 0x00;\r\nlimit = 3;\r\ndo {\r\nret = hid_hw_raw_request(hdev, rep_data[0], rep_data, 2,\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\n} while (ret < 0 && limit-- > 0);\r\nif (ret >= 0) {\r\nif (speed == 0)\r\nrep_data[0] = 0x05;\r\nelse\r\nrep_data[0] = 0x06;\r\nrep_data[1] = 0x00;\r\nlimit = 3;\r\ndo {\r\nret = hid_hw_raw_request(hdev, rep_data[0],\r\nrep_data, 2, HID_FEATURE_REPORT,\r\nHID_REQ_SET_REPORT);\r\n} while (ret < 0 && limit-- > 0);\r\nif (ret >= 0) {\r\nwdata->high_speed = speed;\r\nreturn;\r\n}\r\n}\r\nhid_warn(hdev, "failed to poke device, command %d, err %d\n",\r\nrep_data[0], ret);\r\nbreak;\r\ncase USB_DEVICE_ID_WACOM_INTUOS4_BLUETOOTH:\r\nif (speed == 1)\r\nwdata->features &= ~0x20;\r\nelse\r\nwdata->features |= 0x20;\r\nrep_data[0] = 0x03;\r\nrep_data[1] = wdata->features;\r\nret = hid_hw_raw_request(hdev, rep_data[0], rep_data, 2,\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nif (ret >= 0)\r\nwdata->high_speed = speed;\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic ssize_t wacom_show_speed(struct device *dev,\r\nstruct device_attribute\r\n*attr, char *buf)\r\n{\r\nstruct wacom_data *wdata = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%i\n", wdata->high_speed);\r\n}\r\nstatic ssize_t wacom_store_speed(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nint new_speed;\r\nif (sscanf(buf, "%1d", &new_speed ) != 1)\r\nreturn -EINVAL;\r\nif (new_speed == 0 || new_speed == 1) {\r\nwacom_set_features(hdev, new_speed);\r\nreturn strnlen(buf, PAGE_SIZE);\r\n} else\r\nreturn -EINVAL;\r\n}\r\nstatic int wacom_gr_parse_report(struct hid_device *hdev,\r\nstruct wacom_data *wdata,\r\nstruct input_dev *input, unsigned char *data)\r\n{\r\nint tool, x, y, rw;\r\ntool = 0;\r\nx = le16_to_cpu(*(__le16 *) &data[2]);\r\ny = le16_to_cpu(*(__le16 *) &data[4]);\r\nif (data[1] & 0x90) {\r\nswitch ((data[1] >> 5) & 3) {\r\ncase 0:\r\ntool = BTN_TOOL_PEN;\r\nbreak;\r\ncase 1:\r\ntool = BTN_TOOL_RUBBER;\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ntool = BTN_TOOL_MOUSE;\r\nbreak;\r\n}\r\nif (!(data[1] & 0x10))\r\ntool = 0;\r\n}\r\nif (wdata->tool != tool) {\r\nif (wdata->tool) {\r\nif (wdata->tool == BTN_TOOL_MOUSE) {\r\ninput_report_key(input, BTN_LEFT, 0);\r\ninput_report_key(input, BTN_RIGHT, 0);\r\ninput_report_key(input, BTN_MIDDLE, 0);\r\ninput_report_abs(input, ABS_DISTANCE,\r\ninput_abs_get_max(input, ABS_DISTANCE));\r\n} else {\r\ninput_report_key(input, BTN_TOUCH, 0);\r\ninput_report_key(input, BTN_STYLUS, 0);\r\ninput_report_key(input, BTN_STYLUS2, 0);\r\ninput_report_abs(input, ABS_PRESSURE, 0);\r\n}\r\ninput_report_key(input, wdata->tool, 0);\r\ninput_sync(input);\r\n}\r\nwdata->tool = tool;\r\nif (tool)\r\ninput_report_key(input, tool, 1);\r\n}\r\nif (tool) {\r\ninput_report_abs(input, ABS_X, x);\r\ninput_report_abs(input, ABS_Y, y);\r\nswitch ((data[1] >> 5) & 3) {\r\ncase 2:\r\ninput_report_key(input, BTN_MIDDLE, data[1] & 0x04);\r\nrw = (data[6] & 0x01) ? -1 :\r\n(data[6] & 0x02) ? 1 : 0;\r\ninput_report_rel(input, REL_WHEEL, rw);\r\ncase 3:\r\ninput_report_key(input, BTN_LEFT, data[1] & 0x01);\r\ninput_report_key(input, BTN_RIGHT, data[1] & 0x02);\r\nrw = 44 - (data[6] >> 2);\r\nif (rw < 0)\r\nrw = 0;\r\nelse if (rw > 31)\r\nrw = 31;\r\ninput_report_abs(input, ABS_DISTANCE, rw);\r\nbreak;\r\ndefault:\r\ninput_report_abs(input, ABS_PRESSURE,\r\ndata[6] | (((__u16) (data[1] & 0x08)) << 5));\r\ninput_report_key(input, BTN_TOUCH, data[1] & 0x01);\r\ninput_report_key(input, BTN_STYLUS, data[1] & 0x02);\r\ninput_report_key(input, BTN_STYLUS2, (tool == BTN_TOOL_PEN) && data[1] & 0x04);\r\nbreak;\r\n}\r\ninput_sync(input);\r\n}\r\nrw = data[7] & 0x03;\r\nif (rw != wdata->butstate) {\r\nwdata->butstate = rw;\r\ninput_report_key(input, BTN_0, rw & 0x02);\r\ninput_report_key(input, BTN_1, rw & 0x01);\r\ninput_report_key(input, BTN_TOOL_FINGER, 0xf0);\r\ninput_event(input, EV_MSC, MSC_SERIAL, 0xf0);\r\ninput_sync(input);\r\n}\r\nrw = (data[7] >> 2 & 0x07);\r\nif (rw != wdata->power_raw) {\r\nwdata->power_raw = rw;\r\nwdata->battery_capacity = batcap_gr[rw];\r\nif (rw == 7)\r\nwdata->ps_connected = 1;\r\nelse\r\nwdata->ps_connected = 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void wacom_i4_parse_button_report(struct wacom_data *wdata,\r\nstruct input_dev *input, unsigned char *data)\r\n{\r\n__u16 new_butstate;\r\n__u8 new_whlstate;\r\n__u8 sync = 0;\r\nnew_whlstate = data[1];\r\nif (new_whlstate != wdata->whlstate) {\r\nwdata->whlstate = new_whlstate;\r\nif (new_whlstate & 0x80) {\r\ninput_report_key(input, BTN_TOUCH, 1);\r\ninput_report_abs(input, ABS_WHEEL, (new_whlstate & 0x7f));\r\ninput_report_key(input, BTN_TOOL_FINGER, 1);\r\n} else {\r\ninput_report_key(input, BTN_TOUCH, 0);\r\ninput_report_abs(input, ABS_WHEEL, 0);\r\ninput_report_key(input, BTN_TOOL_FINGER, 0);\r\n}\r\nsync = 1;\r\n}\r\nnew_butstate = (data[3] << 1) | (data[2] & 0x01);\r\nif (new_butstate != wdata->butstate) {\r\nwdata->butstate = new_butstate;\r\ninput_report_key(input, BTN_0, new_butstate & 0x001);\r\ninput_report_key(input, BTN_1, new_butstate & 0x002);\r\ninput_report_key(input, BTN_2, new_butstate & 0x004);\r\ninput_report_key(input, BTN_3, new_butstate & 0x008);\r\ninput_report_key(input, BTN_4, new_butstate & 0x010);\r\ninput_report_key(input, BTN_5, new_butstate & 0x020);\r\ninput_report_key(input, BTN_6, new_butstate & 0x040);\r\ninput_report_key(input, BTN_7, new_butstate & 0x080);\r\ninput_report_key(input, BTN_8, new_butstate & 0x100);\r\ninput_report_key(input, BTN_TOOL_FINGER, 1);\r\nsync = 1;\r\n}\r\nif (sync) {\r\ninput_report_abs(input, ABS_MISC, PAD_DEVICE_ID);\r\ninput_event(input, EV_MSC, MSC_SERIAL, 0xffffffff);\r\ninput_sync(input);\r\n}\r\n}\r\nstatic void wacom_i4_parse_pen_report(struct wacom_data *wdata,\r\nstruct input_dev *input, unsigned char *data)\r\n{\r\n__u16 x, y, pressure;\r\n__u8 distance;\r\n__u8 tilt_x, tilt_y;\r\nswitch (data[1]) {\r\ncase 0x80:\r\ninput_report_key(input, BTN_TOUCH, 0);\r\ninput_report_abs(input, ABS_PRESSURE, 0);\r\ninput_report_key(input, BTN_STYLUS, 0);\r\ninput_report_key(input, BTN_STYLUS2, 0);\r\ninput_report_key(input, wdata->tool, 0);\r\ninput_report_abs(input, ABS_MISC, 0);\r\ninput_event(input, EV_MSC, MSC_SERIAL, wdata->serial);\r\nwdata->tool = 0;\r\ninput_sync(input);\r\nbreak;\r\ncase 0xC2:\r\nwdata->id = ((data[2] << 4) | (data[3] >> 4) |\r\n((data[7] & 0x0f) << 20) |\r\n((data[8] & 0xf0) << 12));\r\nwdata->serial = ((data[3] & 0x0f) << 28) +\r\n(data[4] << 20) + (data[5] << 12) +\r\n(data[6] << 4) + (data[7] >> 4);\r\nswitch (wdata->id) {\r\ncase 0x100802:\r\nwdata->tool = BTN_TOOL_PEN;\r\nbreak;\r\ncase 0x10080A:\r\nwdata->tool = BTN_TOOL_RUBBER;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nx = data[2] << 9 | data[3] << 1 | ((data[9] & 0x02) >> 1);\r\ny = data[4] << 9 | data[5] << 1 | (data[9] & 0x01);\r\npressure = (data[6] << 3) | ((data[7] & 0xC0) >> 5)\r\n| (data[1] & 0x01);\r\ndistance = (data[9] >> 2) & 0x3f;\r\ntilt_x = ((data[7] << 1) & 0x7e) | (data[8] >> 7);\r\ntilt_y = data[8] & 0x7f;\r\ninput_report_key(input, BTN_TOUCH, pressure > 1);\r\ninput_report_key(input, BTN_STYLUS, data[1] & 0x02);\r\ninput_report_key(input, BTN_STYLUS2, data[1] & 0x04);\r\ninput_report_key(input, wdata->tool, 1);\r\ninput_report_abs(input, ABS_X, x);\r\ninput_report_abs(input, ABS_Y, y);\r\ninput_report_abs(input, ABS_PRESSURE, pressure);\r\ninput_report_abs(input, ABS_DISTANCE, distance);\r\ninput_report_abs(input, ABS_TILT_X, tilt_x);\r\ninput_report_abs(input, ABS_TILT_Y, tilt_y);\r\ninput_report_abs(input, ABS_MISC, wdata->id);\r\ninput_event(input, EV_MSC, MSC_SERIAL, wdata->serial);\r\ninput_report_key(input, wdata->tool, 1);\r\ninput_sync(input);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic void wacom_i4_parse_report(struct hid_device *hdev,\r\nstruct wacom_data *wdata,\r\nstruct input_dev *input, unsigned char *data)\r\n{\r\nswitch (data[0]) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x02:\r\nwacom_i4_parse_pen_report(wdata, input, data);\r\nbreak;\r\ncase 0x03:\r\nwdata->features = data[2];\r\nbreak;\r\ncase 0x0C:\r\nwacom_i4_parse_button_report(wdata, input, data);\r\nbreak;\r\ndefault:\r\nhid_err(hdev, "Unknown report: %d,%d\n", data[0], data[1]);\r\nbreak;\r\n}\r\n}\r\nstatic int wacom_raw_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *raw_data, int size)\r\n{\r\nstruct wacom_data *wdata = hid_get_drvdata(hdev);\r\nstruct hid_input *hidinput;\r\nstruct input_dev *input;\r\nunsigned char *data = (unsigned char *) raw_data;\r\nint i;\r\n__u8 power_raw;\r\nif (!(hdev->claimed & HID_CLAIMED_INPUT))\r\nreturn 0;\r\nhidinput = list_entry(hdev->inputs.next, struct hid_input, list);\r\ninput = hidinput->input;\r\nswitch (hdev->product) {\r\ncase USB_DEVICE_ID_WACOM_GRAPHIRE_BLUETOOTH:\r\nif (data[0] == 0x03) {\r\nreturn wacom_gr_parse_report(hdev, wdata, input, data);\r\n} else {\r\nhid_err(hdev, "Unknown report: %d,%d size:%d\n",\r\ndata[0], data[1], size);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase USB_DEVICE_ID_WACOM_INTUOS4_BLUETOOTH:\r\ni = 1;\r\nswitch (data[0]) {\r\ncase 0x04:\r\nwacom_i4_parse_report(hdev, wdata, input, data + i);\r\ni += 10;\r\ncase 0x03:\r\nwacom_i4_parse_report(hdev, wdata, input, data + i);\r\ni += 10;\r\nwacom_i4_parse_report(hdev, wdata, input, data + i);\r\npower_raw = data[i+10];\r\nif (power_raw != wdata->power_raw) {\r\nwdata->power_raw = power_raw;\r\nwdata->battery_capacity = batcap_i4[power_raw & 0x07];\r\nwdata->bat_charging = (power_raw & 0x08) ? 1 : 0;\r\nwdata->ps_connected = (power_raw & 0x10) ? 1 : 0;\r\n}\r\nbreak;\r\ndefault:\r\nhid_err(hdev, "Unknown report: %d,%d size:%d\n",\r\ndata[0], data[1], size);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int wacom_input_mapped(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage, unsigned long **bit,\r\nint *max)\r\n{\r\nstruct input_dev *input = hi->input;\r\n__set_bit(INPUT_PROP_POINTER, input->propbit);\r\ninput->evbit[0] |= BIT(EV_KEY) | BIT(EV_ABS) | BIT(EV_REL);\r\n__set_bit(REL_WHEEL, input->relbit);\r\n__set_bit(BTN_TOOL_PEN, input->keybit);\r\n__set_bit(BTN_TOUCH, input->keybit);\r\n__set_bit(BTN_STYLUS, input->keybit);\r\n__set_bit(BTN_STYLUS2, input->keybit);\r\n__set_bit(BTN_LEFT, input->keybit);\r\n__set_bit(BTN_RIGHT, input->keybit);\r\n__set_bit(BTN_MIDDLE, input->keybit);\r\ninput_set_capability(input, EV_MSC, MSC_SERIAL);\r\n__set_bit(BTN_0, input->keybit);\r\n__set_bit(BTN_1, input->keybit);\r\n__set_bit(BTN_TOOL_FINGER, input->keybit);\r\n__set_bit(BTN_TOOL_RUBBER, input->keybit);\r\n__set_bit(BTN_TOOL_MOUSE, input->keybit);\r\nswitch (hdev->product) {\r\ncase USB_DEVICE_ID_WACOM_GRAPHIRE_BLUETOOTH:\r\ninput_set_abs_params(input, ABS_X, 0, 16704, 4, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, 12064, 4, 0);\r\ninput_set_abs_params(input, ABS_PRESSURE, 0, 511, 0, 0);\r\ninput_set_abs_params(input, ABS_DISTANCE, 0, 32, 0, 0);\r\nbreak;\r\ncase USB_DEVICE_ID_WACOM_INTUOS4_BLUETOOTH:\r\n__set_bit(ABS_WHEEL, input->absbit);\r\n__set_bit(ABS_MISC, input->absbit);\r\n__set_bit(BTN_2, input->keybit);\r\n__set_bit(BTN_3, input->keybit);\r\n__set_bit(BTN_4, input->keybit);\r\n__set_bit(BTN_5, input->keybit);\r\n__set_bit(BTN_6, input->keybit);\r\n__set_bit(BTN_7, input->keybit);\r\n__set_bit(BTN_8, input->keybit);\r\ninput_set_abs_params(input, ABS_WHEEL, 0, 71, 0, 0);\r\ninput_set_abs_params(input, ABS_X, 0, 40640, 4, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, 25400, 4, 0);\r\ninput_set_abs_params(input, ABS_PRESSURE, 0, 2047, 0, 0);\r\ninput_set_abs_params(input, ABS_DISTANCE, 0, 63, 0, 0);\r\ninput_set_abs_params(input, ABS_TILT_X, 0, 127, 0, 0);\r\ninput_set_abs_params(input, ABS_TILT_Y, 0, 127, 0, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wacom_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nstruct wacom_data *wdata;\r\nint ret;\r\nwdata = kzalloc(sizeof(*wdata), GFP_KERNEL);\r\nif (wdata == NULL) {\r\nhid_err(hdev, "can't alloc wacom descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\nhid_set_drvdata(hdev, wdata);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\ngoto err_free;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\ngoto err_free;\r\n}\r\nret = device_create_file(&hdev->dev, &dev_attr_speed);\r\nif (ret)\r\nhid_warn(hdev,\r\n"can't create sysfs speed attribute err: %d\n", ret);\r\n#define OLED_INIT(OLED_ID) \\r\ndo { \\r\nret = device_create_file(&hdev->dev, \\r\n&dev_attr_oled##OLED_ID##_img); \\r\nif (ret) \\r\nhid_warn(hdev, \\r\n"can't create sysfs oled attribute, err: %d\n", ret);\\r\n} while (0)\r\nOLED_INIT(0);\r\nOLED_INIT(1);\r\nOLED_INIT(2);\r\nOLED_INIT(3);\r\nOLED_INIT(4);\r\nOLED_INIT(5);\r\nOLED_INIT(6);\r\nOLED_INIT(7);\r\nwdata->features = 0;\r\nwacom_set_features(hdev, 1);\r\nif (hdev->product == USB_DEVICE_ID_WACOM_INTUOS4_BLUETOOTH) {\r\nsprintf(hdev->name, "%s", "Wacom Intuos4 WL");\r\nret = wacom_initialize_leds(hdev);\r\nif (ret)\r\nhid_warn(hdev,\r\n"can't create led attribute, err: %d\n", ret);\r\n}\r\nwdata->battery.properties = wacom_battery_props;\r\nwdata->battery.num_properties = ARRAY_SIZE(wacom_battery_props);\r\nwdata->battery.get_property = wacom_battery_get_property;\r\nwdata->battery.name = "wacom_battery";\r\nwdata->battery.type = POWER_SUPPLY_TYPE_BATTERY;\r\nwdata->battery.use_for_apm = 0;\r\nret = power_supply_register(&hdev->dev, &wdata->battery);\r\nif (ret) {\r\nhid_err(hdev, "can't create sysfs battery attribute, err: %d\n",\r\nret);\r\ngoto err_battery;\r\n}\r\npower_supply_powers(&wdata->battery, &hdev->dev);\r\nwdata->ac.properties = wacom_ac_props;\r\nwdata->ac.num_properties = ARRAY_SIZE(wacom_ac_props);\r\nwdata->ac.get_property = wacom_ac_get_property;\r\nwdata->ac.name = "wacom_ac";\r\nwdata->ac.type = POWER_SUPPLY_TYPE_MAINS;\r\nwdata->ac.use_for_apm = 0;\r\nret = power_supply_register(&hdev->dev, &wdata->ac);\r\nif (ret) {\r\nhid_err(hdev,\r\n"can't create ac battery attribute, err: %d\n", ret);\r\ngoto err_ac;\r\n}\r\npower_supply_powers(&wdata->ac, &hdev->dev);\r\nreturn 0;\r\nerr_ac:\r\npower_supply_unregister(&wdata->battery);\r\nerr_battery:\r\nwacom_destroy_leds(hdev);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled0_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled1_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled2_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled3_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled4_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled5_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled6_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled7_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_speed);\r\nhid_hw_stop(hdev);\r\nerr_free:\r\nkfree(wdata);\r\nreturn ret;\r\n}\r\nstatic void wacom_remove(struct hid_device *hdev)\r\n{\r\nstruct wacom_data *wdata = hid_get_drvdata(hdev);\r\nwacom_destroy_leds(hdev);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled0_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled1_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled2_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled3_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled4_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled5_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled6_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_oled7_img);\r\ndevice_remove_file(&hdev->dev, &dev_attr_speed);\r\nhid_hw_stop(hdev);\r\npower_supply_unregister(&wdata->battery);\r\npower_supply_unregister(&wdata->ac);\r\nkfree(hid_get_drvdata(hdev));\r\n}
