static int jl2005c_write2(struct gspca_dev *gspca_dev, unsigned char *command)\r\n{\r\nint retval;\r\nmemcpy(gspca_dev->usb_buf, command, 2);\r\nretval = usb_bulk_msg(gspca_dev->dev,\r\nusb_sndbulkpipe(gspca_dev->dev, 3),\r\ngspca_dev->usb_buf, 2, NULL, 500);\r\nif (retval < 0)\r\npr_err("command write [%02x] error %d\n",\r\ngspca_dev->usb_buf[0], retval);\r\nreturn retval;\r\n}\r\nstatic int jl2005c_read1(struct gspca_dev *gspca_dev)\r\n{\r\nint retval;\r\nretval = usb_bulk_msg(gspca_dev->dev,\r\nusb_rcvbulkpipe(gspca_dev->dev, 0x84),\r\ngspca_dev->usb_buf, 1, NULL, 500);\r\nif (retval < 0)\r\npr_err("read command [0x%02x] error %d\n",\r\ngspca_dev->usb_buf[0], retval);\r\nreturn retval;\r\n}\r\nstatic int jl2005c_read_reg(struct gspca_dev *gspca_dev, unsigned char reg)\r\n{\r\nint retval;\r\nstatic u8 instruction[2] = {0x95, 0x00};\r\ninstruction[1] = reg;\r\nretval = jl2005c_write2(gspca_dev, instruction);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = jl2005c_read1(gspca_dev);\r\nreturn retval;\r\n}\r\nstatic int jl2005c_start_new_frame(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nint retval;\r\nint frame_brightness = 0;\r\nstatic u8 instruction[2] = {0x7f, 0x01};\r\nretval = jl2005c_write2(gspca_dev, instruction);\r\nif (retval < 0)\r\nreturn retval;\r\ni = 0;\r\nwhile (i < 20 && !frame_brightness) {\r\nretval = jl2005c_read_reg(gspca_dev, 0x7e);\r\nif (retval < 0)\r\nreturn retval;\r\nframe_brightness = gspca_dev->usb_buf[0];\r\nretval = jl2005c_read_reg(gspca_dev, 0x7d);\r\nif (retval < 0)\r\nreturn retval;\r\ni++;\r\n}\r\nPDEBUG(D_FRAM, "frame_brightness is 0x%02x", gspca_dev->usb_buf[0]);\r\nreturn retval;\r\n}\r\nstatic int jl2005c_write_reg(struct gspca_dev *gspca_dev, unsigned char reg,\r\nunsigned char value)\r\n{\r\nint retval;\r\nu8 instruction[2];\r\ninstruction[0] = reg;\r\ninstruction[1] = value;\r\nretval = jl2005c_write2(gspca_dev, instruction);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn retval;\r\n}\r\nstatic int jl2005c_get_firmware_id(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nint i = 0;\r\nint retval = -1;\r\nunsigned char regs_to_read[] = {0x57, 0x02, 0x03, 0x5d, 0x5e, 0x5f};\r\nPDEBUG(D_PROBE, "Running jl2005c_get_firmware_id");\r\nretval = jl2005c_read_reg(gspca_dev, regs_to_read[0]);\r\nPDEBUG(D_PROBE, "response is %02x", gspca_dev->usb_buf[0]);\r\nif (retval < 0)\r\nreturn retval;\r\nfor (i = 0; i < 6; i++) {\r\nretval = jl2005c_read_reg(gspca_dev, regs_to_read[i]);\r\nif (retval < 0)\r\nreturn retval;\r\nsd->firmware_id[i] = gspca_dev->usb_buf[0];\r\n}\r\nPDEBUG(D_PROBE, "firmware ID is %02x%02x%02x%02x%02x%02x",\r\nsd->firmware_id[0],\r\nsd->firmware_id[1],\r\nsd->firmware_id[2],\r\nsd->firmware_id[3],\r\nsd->firmware_id[4],\r\nsd->firmware_id[5]);\r\nreturn 0;\r\n}\r\nstatic int jl2005c_stream_start_vga_lg\r\n(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nint retval = -1;\r\nstatic u8 instruction[][2] = {\r\n{0x05, 0x00},\r\n{0x7c, 0x00},\r\n{0x7d, 0x18},\r\n{0x02, 0x00},\r\n{0x01, 0x00},\r\n{0x04, 0x52},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(instruction); i++) {\r\nmsleep(60);\r\nretval = jl2005c_write2(gspca_dev, instruction[i]);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nmsleep(60);\r\nreturn retval;\r\n}\r\nstatic int jl2005c_stream_start_vga_small(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nint retval = -1;\r\nstatic u8 instruction[][2] = {\r\n{0x06, 0x00},\r\n{0x7c, 0x00},\r\n{0x7d, 0x1a},\r\n{0x02, 0x00},\r\n{0x01, 0x00},\r\n{0x04, 0x52},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(instruction); i++) {\r\nmsleep(60);\r\nretval = jl2005c_write2(gspca_dev, instruction[i]);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nmsleep(60);\r\nreturn retval;\r\n}\r\nstatic int jl2005c_stream_start_cif_lg(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nint retval = -1;\r\nstatic u8 instruction[][2] = {\r\n{0x05, 0x00},\r\n{0x7c, 0x00},\r\n{0x7d, 0x30},\r\n{0x02, 0x00},\r\n{0x01, 0x00},\r\n{0x04, 0x42},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(instruction); i++) {\r\nmsleep(60);\r\nretval = jl2005c_write2(gspca_dev, instruction[i]);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nmsleep(60);\r\nreturn retval;\r\n}\r\nstatic int jl2005c_stream_start_cif_small(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nint retval = -1;\r\nstatic u8 instruction[][2] = {\r\n{0x06, 0x00},\r\n{0x7c, 0x00},\r\n{0x7d, 0x32},\r\n{0x02, 0x00},\r\n{0x01, 0x00},\r\n{0x04, 0x42},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(instruction); i++) {\r\nmsleep(60);\r\nretval = jl2005c_write2(gspca_dev, instruction[i]);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nmsleep(60);\r\nreturn retval;\r\n}\r\nstatic int jl2005c_stop(struct gspca_dev *gspca_dev)\r\n{\r\nint retval;\r\nretval = jl2005c_write_reg(gspca_dev, 0x07, 0x00);\r\nreturn retval;\r\n}\r\nstatic void jl2005c_dostream(struct work_struct *work)\r\n{\r\nstruct sd *dev = container_of(work, struct sd, work_struct);\r\nstruct gspca_dev *gspca_dev = &dev->gspca_dev;\r\nint bytes_left = 0;\r\nint data_len;\r\nint header_read = 0;\r\nunsigned char header_sig[2] = {0x4a, 0x4c};\r\nint act_len;\r\nint packet_type;\r\nint ret;\r\nu8 *buffer;\r\nbuffer = kmalloc(JL2005C_MAX_TRANSFER, GFP_KERNEL | GFP_DMA);\r\nif (!buffer) {\r\npr_err("Couldn't allocate USB buffer\n");\r\ngoto quit_stream;\r\n}\r\nwhile (gspca_dev->present && gspca_dev->streaming) {\r\n#ifdef CONFIG_PM\r\nif (gspca_dev->frozen)\r\nbreak;\r\n#endif\r\nif (!header_read) {\r\nmutex_lock(&gspca_dev->usb_lock);\r\nret = jl2005c_start_new_frame(gspca_dev);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nif (ret < 0)\r\ngoto quit_stream;\r\nret = usb_bulk_msg(gspca_dev->dev,\r\nusb_rcvbulkpipe(gspca_dev->dev, 0x82),\r\nbuffer, JL2005C_MAX_TRANSFER, &act_len,\r\nJL2005C_DATA_TIMEOUT);\r\nPDEBUG(D_PACK,\r\n"Got %d bytes out of %d for header",\r\nact_len, JL2005C_MAX_TRANSFER);\r\nif (ret < 0 || act_len < JL2005C_MAX_TRANSFER)\r\ngoto quit_stream;\r\nif (memcmp(header_sig, buffer, 2) != 0) {\r\npr_err("First block is not the first block\n");\r\ngoto quit_stream;\r\n}\r\nbytes_left = buffer[0x07] * dev->block_size - act_len;\r\nPDEBUG(D_PACK, "bytes_left = 0x%x", bytes_left);\r\npacket_type = FIRST_PACKET;\r\ngspca_frame_add(gspca_dev, packet_type,\r\nbuffer, act_len);\r\nheader_read = 1;\r\n}\r\nwhile (bytes_left > 0 && gspca_dev->present) {\r\ndata_len = bytes_left > JL2005C_MAX_TRANSFER ?\r\nJL2005C_MAX_TRANSFER : bytes_left;\r\nret = usb_bulk_msg(gspca_dev->dev,\r\nusb_rcvbulkpipe(gspca_dev->dev, 0x82),\r\nbuffer, data_len, &act_len,\r\nJL2005C_DATA_TIMEOUT);\r\nif (ret < 0 || act_len < data_len)\r\ngoto quit_stream;\r\nPDEBUG(D_PACK,\r\n"Got %d bytes out of %d for frame",\r\ndata_len, bytes_left);\r\nbytes_left -= data_len;\r\nif (bytes_left == 0) {\r\npacket_type = LAST_PACKET;\r\nheader_read = 0;\r\n} else\r\npacket_type = INTER_PACKET;\r\ngspca_frame_add(gspca_dev, packet_type,\r\nbuffer, data_len);\r\n}\r\n}\r\nquit_stream:\r\nif (gspca_dev->present) {\r\nmutex_lock(&gspca_dev->usb_lock);\r\njl2005c_stop(gspca_dev);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\n}\r\nkfree(buffer);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct cam *cam;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ncam = &gspca_dev->cam;\r\ncam->bulk_size = 64;\r\ncam->bulk = 1;\r\njl2005c_get_firmware_id(gspca_dev);\r\nif ((sd->firmware_id[0] & 0xf0) == 0x40) {\r\ncam->cam_mode = cif_mode;\r\ncam->nmodes = ARRAY_SIZE(cif_mode);\r\nsd->block_size = 0x80;\r\n} else {\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\nsd->block_size = 0x200;\r\n}\r\nINIT_WORK(&sd->work_struct, jl2005c_dostream);\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->cap_mode = gspca_dev->cam.cam_mode;\r\nswitch (gspca_dev->pixfmt.width) {\r\ncase 640:\r\nPDEBUG(D_STREAM, "Start streaming at vga resolution");\r\njl2005c_stream_start_vga_lg(gspca_dev);\r\nbreak;\r\ncase 320:\r\nPDEBUG(D_STREAM, "Start streaming at qvga resolution");\r\njl2005c_stream_start_vga_small(gspca_dev);\r\nbreak;\r\ncase 352:\r\nPDEBUG(D_STREAM, "Start streaming at cif resolution");\r\njl2005c_stream_start_cif_lg(gspca_dev);\r\nbreak;\r\ncase 176:\r\nPDEBUG(D_STREAM, "Start streaming at qcif resolution");\r\njl2005c_stream_start_cif_small(gspca_dev);\r\nbreak;\r\ndefault:\r\npr_err("Unknown resolution specified\n");\r\nreturn -1;\r\n}\r\nsd->work_thread = create_singlethread_workqueue(MODULE_NAME);\r\nqueue_work(sd->work_thread, &sd->work_struct);\r\nreturn 0;\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *dev = (struct sd *) gspca_dev;\r\nmutex_unlock(&gspca_dev->usb_lock);\r\ndestroy_workqueue(dev->work_thread);\r\ndev->work_thread = NULL;\r\nmutex_lock(&gspca_dev->usb_lock);\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
