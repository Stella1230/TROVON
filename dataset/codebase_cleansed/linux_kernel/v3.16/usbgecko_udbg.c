static u32 ug_io_transaction(u32 in)\r\n{\r\nu32 __iomem *csr_reg = ug_io_base + EXI_CSR;\r\nu32 __iomem *data_reg = ug_io_base + EXI_DATA;\r\nu32 __iomem *cr_reg = ug_io_base + EXI_CR;\r\nu32 csr, data, cr;\r\ncsr = EXI_CSR_CLK_32MHZ | EXI_CSR_CS_0;\r\nout_be32(csr_reg, csr);\r\ndata = in;\r\nout_be32(data_reg, data);\r\ncr = EXI_CR_TLEN(2) | EXI_CR_READ_WRITE | EXI_CR_TSTART;\r\nout_be32(cr_reg, cr);\r\nwhile (in_be32(cr_reg) & EXI_CR_TSTART)\r\nbarrier();\r\nout_be32(csr_reg, 0);\r\ndata = in_be32(data_reg);\r\nreturn data;\r\n}\r\nstatic int ug_is_adapter_present(void)\r\n{\r\nif (!ug_io_base)\r\nreturn 0;\r\nreturn ug_io_transaction(0x90000000) == 0x04700000;\r\n}\r\nstatic int ug_is_txfifo_ready(void)\r\n{\r\nreturn ug_io_transaction(0xc0000000) & 0x04000000;\r\n}\r\nstatic void ug_raw_putc(char ch)\r\n{\r\nug_io_transaction(0xb0000000 | (ch << 20));\r\n}\r\nstatic void ug_putc(char ch)\r\n{\r\nint count = UG_WRITE_ATTEMPTS;\r\nif (!ug_io_base)\r\nreturn;\r\nif (ch == '\n')\r\nug_putc('\r');\r\nwhile (!ug_is_txfifo_ready() && count--)\r\nbarrier();\r\nif (count >= 0)\r\nug_raw_putc(ch);\r\n}\r\nstatic int ug_is_rxfifo_ready(void)\r\n{\r\nreturn ug_io_transaction(0xd0000000) & 0x04000000;\r\n}\r\nstatic int ug_raw_getc(void)\r\n{\r\nu32 data = ug_io_transaction(0xa0000000);\r\nif (data & 0x08000000)\r\nreturn (data >> 16) & 0xff;\r\nelse\r\nreturn -1;\r\n}\r\nstatic int ug_getc(void)\r\n{\r\nint count = UG_READ_ATTEMPTS;\r\nif (!ug_io_base)\r\nreturn -1;\r\nwhile (!ug_is_rxfifo_ready() && count--)\r\nbarrier();\r\nreturn ug_raw_getc();\r\n}\r\nvoid ug_udbg_putc(char ch)\r\n{\r\nug_putc(ch);\r\n}\r\nstatic int ug_udbg_getc(void)\r\n{\r\nint ch;\r\nwhile ((ch = ug_getc()) == -1)\r\nbarrier();\r\nreturn ch;\r\n}\r\nstatic int ug_udbg_getc_poll(void)\r\n{\r\nif (!ug_is_rxfifo_ready())\r\nreturn -1;\r\nreturn ug_getc();\r\n}\r\nstatic void __iomem *ug_udbg_setup_exi_io_base(struct device_node *np)\r\n{\r\nvoid __iomem *exi_io_base = NULL;\r\nphys_addr_t paddr;\r\nconst unsigned int *reg;\r\nreg = of_get_property(np, "reg", NULL);\r\nif (reg) {\r\npaddr = of_translate_address(np, reg);\r\nif (paddr)\r\nexi_io_base = ioremap(paddr, reg[1]);\r\n}\r\nreturn exi_io_base;\r\n}\r\nstatic void __iomem *ug_udbg_probe(void __iomem *exi_io_base)\r\n{\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nug_io_base = exi_io_base + 0x14 * i;\r\nif (ug_is_adapter_present())\r\nbreak;\r\n}\r\nif (i == 2)\r\nug_io_base = NULL;\r\nreturn ug_io_base;\r\n}\r\nvoid __init ug_udbg_init(void)\r\n{\r\nstruct device_node *np;\r\nvoid __iomem *exi_io_base;\r\nif (ug_io_base)\r\nudbg_printf("%s: early -> final\n", __func__);\r\nnp = of_find_compatible_node(NULL, NULL, "nintendo,flipper-exi");\r\nif (!np) {\r\nudbg_printf("%s: EXI node not found\n", __func__);\r\ngoto done;\r\n}\r\nexi_io_base = ug_udbg_setup_exi_io_base(np);\r\nif (!exi_io_base) {\r\nudbg_printf("%s: failed to setup EXI io base\n", __func__);\r\ngoto done;\r\n}\r\nif (!ug_udbg_probe(exi_io_base)) {\r\nudbg_printf("usbgecko_udbg: not found\n");\r\niounmap(exi_io_base);\r\n} else {\r\nudbg_putc = ug_udbg_putc;\r\nudbg_getc = ug_udbg_getc;\r\nudbg_getc_poll = ug_udbg_getc_poll;\r\nudbg_printf("usbgecko_udbg: ready\n");\r\n}\r\ndone:\r\nif (np)\r\nof_node_put(np);\r\nreturn;\r\n}\r\nstatic phys_addr_t __init ug_early_grab_io_addr(void)\r\n{\r\n#if defined(CONFIG_GAMECUBE)\r\nreturn 0x0c000000;\r\n#elif defined(CONFIG_WII)\r\nreturn 0x0d000000;\r\n#else\r\n#error Invalid platform for USB Gecko based early debugging.\r\n#endif\r\n}\r\nvoid __init udbg_init_usbgecko(void)\r\n{\r\nvoid __iomem *early_debug_area;\r\nvoid __iomem *exi_io_base;\r\nearly_debug_area = (void __iomem *)__fix_to_virt(FIX_EARLY_DEBUG_BASE);\r\nexi_io_base = early_debug_area + 0x00006800;\r\nif (!ug_udbg_probe(exi_io_base))\r\nreturn;\r\nudbg_putc = ug_udbg_putc;\r\nudbg_getc = ug_udbg_getc;\r\nudbg_getc_poll = ug_udbg_getc_poll;\r\nsetbat(1, (unsigned long)early_debug_area,\r\nug_early_grab_io_addr(), 128*1024, PAGE_KERNEL_NCG);\r\n}
