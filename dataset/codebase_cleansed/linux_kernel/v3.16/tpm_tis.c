static int is_itpm(struct pnp_dev *dev)\r\n{\r\nstruct acpi_device *acpi = pnp_acpi_device(dev);\r\nstruct acpi_hardware_id *id;\r\nif (!acpi)\r\nreturn 0;\r\nlist_for_each_entry(id, &acpi->pnp.ids, list) {\r\nif (!strcmp("INTC0102", id->id))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int is_itpm(struct pnp_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int wait_startup(struct tpm_chip *chip, int l)\r\n{\r\nunsigned long stop = jiffies + chip->vendor.timeout_a;\r\ndo {\r\nif (ioread8(chip->vendor.iobase + TPM_ACCESS(l)) &\r\nTPM_ACCESS_VALID)\r\nreturn 0;\r\nmsleep(TPM_TIMEOUT);\r\n} while (time_before(jiffies, stop));\r\nreturn -1;\r\n}\r\nstatic int check_locality(struct tpm_chip *chip, int l)\r\n{\r\nif ((ioread8(chip->vendor.iobase + TPM_ACCESS(l)) &\r\n(TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID)) ==\r\n(TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID))\r\nreturn chip->vendor.locality = l;\r\nreturn -1;\r\n}\r\nstatic void release_locality(struct tpm_chip *chip, int l, int force)\r\n{\r\nif (force || (ioread8(chip->vendor.iobase + TPM_ACCESS(l)) &\r\n(TPM_ACCESS_REQUEST_PENDING | TPM_ACCESS_VALID)) ==\r\n(TPM_ACCESS_REQUEST_PENDING | TPM_ACCESS_VALID))\r\niowrite8(TPM_ACCESS_ACTIVE_LOCALITY,\r\nchip->vendor.iobase + TPM_ACCESS(l));\r\n}\r\nstatic int request_locality(struct tpm_chip *chip, int l)\r\n{\r\nunsigned long stop, timeout;\r\nlong rc;\r\nif (check_locality(chip, l) >= 0)\r\nreturn l;\r\niowrite8(TPM_ACCESS_REQUEST_USE,\r\nchip->vendor.iobase + TPM_ACCESS(l));\r\nstop = jiffies + chip->vendor.timeout_a;\r\nif (chip->vendor.irq) {\r\nagain:\r\ntimeout = stop - jiffies;\r\nif ((long)timeout <= 0)\r\nreturn -1;\r\nrc = wait_event_interruptible_timeout(chip->vendor.int_queue,\r\n(check_locality\r\n(chip, l) >= 0),\r\ntimeout);\r\nif (rc > 0)\r\nreturn l;\r\nif (rc == -ERESTARTSYS && freezing(current)) {\r\nclear_thread_flag(TIF_SIGPENDING);\r\ngoto again;\r\n}\r\n} else {\r\ndo {\r\nif (check_locality(chip, l) >= 0)\r\nreturn l;\r\nmsleep(TPM_TIMEOUT);\r\n}\r\nwhile (time_before(jiffies, stop));\r\n}\r\nreturn -1;\r\n}\r\nstatic u8 tpm_tis_status(struct tpm_chip *chip)\r\n{\r\nreturn ioread8(chip->vendor.iobase +\r\nTPM_STS(chip->vendor.locality));\r\n}\r\nstatic void tpm_tis_ready(struct tpm_chip *chip)\r\n{\r\niowrite8(TPM_STS_COMMAND_READY,\r\nchip->vendor.iobase + TPM_STS(chip->vendor.locality));\r\n}\r\nstatic int get_burstcount(struct tpm_chip *chip)\r\n{\r\nunsigned long stop;\r\nint burstcnt;\r\nstop = jiffies + chip->vendor.timeout_d;\r\ndo {\r\nburstcnt = ioread8(chip->vendor.iobase +\r\nTPM_STS(chip->vendor.locality) + 1);\r\nburstcnt += ioread8(chip->vendor.iobase +\r\nTPM_STS(chip->vendor.locality) +\r\n2) << 8;\r\nif (burstcnt)\r\nreturn burstcnt;\r\nmsleep(TPM_TIMEOUT);\r\n} while (time_before(jiffies, stop));\r\nreturn -EBUSY;\r\n}\r\nstatic int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nint size = 0, burstcnt;\r\nwhile (size < count &&\r\nwait_for_tpm_stat(chip,\r\nTPM_STS_DATA_AVAIL | TPM_STS_VALID,\r\nchip->vendor.timeout_c,\r\n&chip->vendor.read_queue, true)\r\n== 0) {\r\nburstcnt = get_burstcount(chip);\r\nfor (; burstcnt > 0 && size < count; burstcnt--)\r\nbuf[size++] = ioread8(chip->vendor.iobase +\r\nTPM_DATA_FIFO(chip->vendor.\r\nlocality));\r\n}\r\nreturn size;\r\n}\r\nstatic int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nint size = 0;\r\nint expected, status;\r\nif (count < TPM_HEADER_SIZE) {\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nif ((size =\r\nrecv_data(chip, buf, TPM_HEADER_SIZE)) < TPM_HEADER_SIZE) {\r\ndev_err(chip->dev, "Unable to read header\n");\r\ngoto out;\r\n}\r\nexpected = be32_to_cpu(*(__be32 *) (buf + 2));\r\nif (expected > count) {\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nif ((size +=\r\nrecv_data(chip, &buf[TPM_HEADER_SIZE],\r\nexpected - TPM_HEADER_SIZE)) < expected) {\r\ndev_err(chip->dev, "Unable to read remainder of result\n");\r\nsize = -ETIME;\r\ngoto out;\r\n}\r\nwait_for_tpm_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c,\r\n&chip->vendor.int_queue, false);\r\nstatus = tpm_tis_status(chip);\r\nif (status & TPM_STS_DATA_AVAIL) {\r\ndev_err(chip->dev, "Error left over data\n");\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nout:\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn size;\r\n}\r\nstatic int tpm_tis_send_data(struct tpm_chip *chip, u8 *buf, size_t len)\r\n{\r\nint rc, status, burstcnt;\r\nsize_t count = 0;\r\nif (request_locality(chip, 0) < 0)\r\nreturn -EBUSY;\r\nstatus = tpm_tis_status(chip);\r\nif ((status & TPM_STS_COMMAND_READY) == 0) {\r\ntpm_tis_ready(chip);\r\nif (wait_for_tpm_stat\r\n(chip, TPM_STS_COMMAND_READY, chip->vendor.timeout_b,\r\n&chip->vendor.int_queue, false) < 0) {\r\nrc = -ETIME;\r\ngoto out_err;\r\n}\r\n}\r\nwhile (count < len - 1) {\r\nburstcnt = get_burstcount(chip);\r\nfor (; burstcnt > 0 && count < len - 1; burstcnt--) {\r\niowrite8(buf[count], chip->vendor.iobase +\r\nTPM_DATA_FIFO(chip->vendor.locality));\r\ncount++;\r\n}\r\nwait_for_tpm_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c,\r\n&chip->vendor.int_queue, false);\r\nstatus = tpm_tis_status(chip);\r\nif (!itpm && (status & TPM_STS_DATA_EXPECT) == 0) {\r\nrc = -EIO;\r\ngoto out_err;\r\n}\r\n}\r\niowrite8(buf[count],\r\nchip->vendor.iobase + TPM_DATA_FIFO(chip->vendor.locality));\r\nwait_for_tpm_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c,\r\n&chip->vendor.int_queue, false);\r\nstatus = tpm_tis_status(chip);\r\nif ((status & TPM_STS_DATA_EXPECT) != 0) {\r\nrc = -EIO;\r\ngoto out_err;\r\n}\r\nreturn 0;\r\nout_err:\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn rc;\r\n}\r\nstatic int tpm_tis_send(struct tpm_chip *chip, u8 *buf, size_t len)\r\n{\r\nint rc;\r\nu32 ordinal;\r\nrc = tpm_tis_send_data(chip, buf, len);\r\nif (rc < 0)\r\nreturn rc;\r\niowrite8(TPM_STS_GO,\r\nchip->vendor.iobase + TPM_STS(chip->vendor.locality));\r\nif (chip->vendor.irq) {\r\nordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\r\nif (wait_for_tpm_stat\r\n(chip, TPM_STS_DATA_AVAIL | TPM_STS_VALID,\r\ntpm_calc_ordinal_duration(chip, ordinal),\r\n&chip->vendor.read_queue, false) < 0) {\r\nrc = -ETIME;\r\ngoto out_err;\r\n}\r\n}\r\nreturn len;\r\nout_err:\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn rc;\r\n}\r\nstatic int probe_itpm(struct tpm_chip *chip)\r\n{\r\nint rc = 0;\r\nu8 cmd_getticks[] = {\r\n0x00, 0xc1, 0x00, 0x00, 0x00, 0x0a,\r\n0x00, 0x00, 0x00, 0xf1\r\n};\r\nsize_t len = sizeof(cmd_getticks);\r\nbool rem_itpm = itpm;\r\nu16 vendor = ioread16(chip->vendor.iobase + TPM_DID_VID(0));\r\nif (vendor != TPM_VID_INTEL)\r\nreturn 0;\r\nitpm = false;\r\nrc = tpm_tis_send_data(chip, cmd_getticks, len);\r\nif (rc == 0)\r\ngoto out;\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nitpm = true;\r\nrc = tpm_tis_send_data(chip, cmd_getticks, len);\r\nif (rc == 0) {\r\ndev_info(chip->dev, "Detected an iTPM.\n");\r\nrc = 1;\r\n} else\r\nrc = -EFAULT;\r\nout:\r\nitpm = rem_itpm;\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn rc;\r\n}\r\nstatic bool tpm_tis_req_canceled(struct tpm_chip *chip, u8 status)\r\n{\r\nswitch (chip->vendor.manufacturer_id) {\r\ncase TPM_VID_WINBOND:\r\nreturn ((status == TPM_STS_VALID) ||\r\n(status == (TPM_STS_VALID | TPM_STS_COMMAND_READY)));\r\ncase TPM_VID_STM:\r\nreturn (status == (TPM_STS_VALID | TPM_STS_COMMAND_READY));\r\ndefault:\r\nreturn (status == TPM_STS_COMMAND_READY);\r\n}\r\n}\r\nstatic irqreturn_t tis_int_probe(int irq, void *dev_id)\r\n{\r\nstruct tpm_chip *chip = dev_id;\r\nu32 interrupt;\r\ninterrupt = ioread32(chip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\nif (interrupt == 0)\r\nreturn IRQ_NONE;\r\nchip->vendor.probed_irq = irq;\r\niowrite32(interrupt,\r\nchip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t tis_int_handler(int dummy, void *dev_id)\r\n{\r\nstruct tpm_chip *chip = dev_id;\r\nu32 interrupt;\r\nint i;\r\ninterrupt = ioread32(chip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\nif (interrupt == 0)\r\nreturn IRQ_NONE;\r\nif (interrupt & TPM_INTF_DATA_AVAIL_INT)\r\nwake_up_interruptible(&chip->vendor.read_queue);\r\nif (interrupt & TPM_INTF_LOCALITY_CHANGE_INT)\r\nfor (i = 0; i < 5; i++)\r\nif (check_locality(chip, i) >= 0)\r\nbreak;\r\nif (interrupt &\r\n(TPM_INTF_LOCALITY_CHANGE_INT | TPM_INTF_STS_VALID_INT |\r\nTPM_INTF_CMD_READY_INT))\r\nwake_up_interruptible(&chip->vendor.int_queue);\r\niowrite32(interrupt,\r\nchip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\nioread32(chip->vendor.iobase + TPM_INT_STATUS(chip->vendor.locality));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tpm_tis_init(struct device *dev, resource_size_t start,\r\nresource_size_t len, unsigned int irq)\r\n{\r\nu32 vendor, intfcaps, intmask;\r\nint rc, i, irq_s, irq_e, probe;\r\nstruct tpm_chip *chip;\r\nif (!(chip = tpm_register_hardware(dev, &tpm_tis)))\r\nreturn -ENODEV;\r\nchip->vendor.iobase = ioremap(start, len);\r\nif (!chip->vendor.iobase) {\r\nrc = -EIO;\r\ngoto out_err;\r\n}\r\nchip->vendor.timeout_a = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\r\nchip->vendor.timeout_b = msecs_to_jiffies(TIS_LONG_TIMEOUT);\r\nchip->vendor.timeout_c = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\r\nchip->vendor.timeout_d = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\r\nif (wait_startup(chip, 0) != 0) {\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nif (request_locality(chip, 0) != 0) {\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nvendor = ioread32(chip->vendor.iobase + TPM_DID_VID(0));\r\nchip->vendor.manufacturer_id = vendor;\r\ndev_info(dev,\r\n"1.2 TPM (device-id 0x%X, rev-id %d)\n",\r\nvendor >> 16, ioread8(chip->vendor.iobase + TPM_RID(0)));\r\nif (!itpm) {\r\nprobe = probe_itpm(chip);\r\nif (probe < 0) {\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nitpm = !!probe;\r\n}\r\nif (itpm)\r\ndev_info(dev, "Intel iTPM workaround enabled\n");\r\nintfcaps =\r\nioread32(chip->vendor.iobase +\r\nTPM_INTF_CAPS(chip->vendor.locality));\r\ndev_dbg(dev, "TPM interface capabilities (0x%x):\n",\r\nintfcaps);\r\nif (intfcaps & TPM_INTF_BURST_COUNT_STATIC)\r\ndev_dbg(dev, "\tBurst Count Static\n");\r\nif (intfcaps & TPM_INTF_CMD_READY_INT)\r\ndev_dbg(dev, "\tCommand Ready Int Support\n");\r\nif (intfcaps & TPM_INTF_INT_EDGE_FALLING)\r\ndev_dbg(dev, "\tInterrupt Edge Falling\n");\r\nif (intfcaps & TPM_INTF_INT_EDGE_RISING)\r\ndev_dbg(dev, "\tInterrupt Edge Rising\n");\r\nif (intfcaps & TPM_INTF_INT_LEVEL_LOW)\r\ndev_dbg(dev, "\tInterrupt Level Low\n");\r\nif (intfcaps & TPM_INTF_INT_LEVEL_HIGH)\r\ndev_dbg(dev, "\tInterrupt Level High\n");\r\nif (intfcaps & TPM_INTF_LOCALITY_CHANGE_INT)\r\ndev_dbg(dev, "\tLocality Change Int Support\n");\r\nif (intfcaps & TPM_INTF_STS_VALID_INT)\r\ndev_dbg(dev, "\tSts Valid Int Support\n");\r\nif (intfcaps & TPM_INTF_DATA_AVAIL_INT)\r\ndev_dbg(dev, "\tData Avail Int Support\n");\r\nif (tpm_get_timeouts(chip)) {\r\ndev_err(dev, "Could not get TPM timeouts and durations\n");\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nif (tpm_do_selftest(chip)) {\r\ndev_err(dev, "TPM self test failed\n");\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\ninit_waitqueue_head(&chip->vendor.read_queue);\r\ninit_waitqueue_head(&chip->vendor.int_queue);\r\nintmask =\r\nioread32(chip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nintmask |= TPM_INTF_CMD_READY_INT\r\n| TPM_INTF_LOCALITY_CHANGE_INT | TPM_INTF_DATA_AVAIL_INT\r\n| TPM_INTF_STS_VALID_INT;\r\niowrite32(intmask,\r\nchip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nif (interrupts)\r\nchip->vendor.irq = irq;\r\nif (interrupts && !chip->vendor.irq) {\r\nirq_s =\r\nioread8(chip->vendor.iobase +\r\nTPM_INT_VECTOR(chip->vendor.locality));\r\nif (irq_s) {\r\nirq_e = irq_s;\r\n} else {\r\nirq_s = 3;\r\nirq_e = 15;\r\n}\r\nfor (i = irq_s; i <= irq_e && chip->vendor.irq == 0; i++) {\r\niowrite8(i, chip->vendor.iobase +\r\nTPM_INT_VECTOR(chip->vendor.locality));\r\nif (request_irq\r\n(i, tis_int_probe, IRQF_SHARED,\r\nchip->vendor.miscdev.name, chip) != 0) {\r\ndev_info(chip->dev,\r\n"Unable to request irq: %d for probe\n",\r\ni);\r\ncontinue;\r\n}\r\niowrite32(ioread32\r\n(chip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality)),\r\nchip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\niowrite32(intmask | TPM_GLOBAL_INT_ENABLE,\r\nchip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nchip->vendor.probed_irq = 0;\r\ntpm_gen_interrupt(chip);\r\nchip->vendor.irq = chip->vendor.probed_irq;\r\niowrite32(ioread32\r\n(chip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality)),\r\nchip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\niowrite32(intmask,\r\nchip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nfree_irq(i, chip);\r\n}\r\n}\r\nif (chip->vendor.irq) {\r\niowrite8(chip->vendor.irq,\r\nchip->vendor.iobase +\r\nTPM_INT_VECTOR(chip->vendor.locality));\r\nif (request_irq\r\n(chip->vendor.irq, tis_int_handler, IRQF_SHARED,\r\nchip->vendor.miscdev.name, chip) != 0) {\r\ndev_info(chip->dev,\r\n"Unable to request irq: %d for use\n",\r\nchip->vendor.irq);\r\nchip->vendor.irq = 0;\r\n} else {\r\niowrite32(ioread32\r\n(chip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality)),\r\nchip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\niowrite32(intmask | TPM_GLOBAL_INT_ENABLE,\r\nchip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\n}\r\n}\r\nINIT_LIST_HEAD(&chip->vendor.list);\r\nmutex_lock(&tis_lock);\r\nlist_add(&chip->vendor.list, &tis_chips);\r\nmutex_unlock(&tis_lock);\r\nreturn 0;\r\nout_err:\r\nif (chip->vendor.iobase)\r\niounmap(chip->vendor.iobase);\r\ntpm_remove_hardware(chip->dev);\r\nreturn rc;\r\n}\r\nstatic void tpm_tis_reenable_interrupts(struct tpm_chip *chip)\r\n{\r\nu32 intmask;\r\niowrite8(chip->vendor.irq, chip->vendor.iobase +\r\nTPM_INT_VECTOR(chip->vendor.locality));\r\nintmask =\r\nioread32(chip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nintmask |= TPM_INTF_CMD_READY_INT\r\n| TPM_INTF_LOCALITY_CHANGE_INT | TPM_INTF_DATA_AVAIL_INT\r\n| TPM_INTF_STS_VALID_INT | TPM_GLOBAL_INT_ENABLE;\r\niowrite32(intmask,\r\nchip->vendor.iobase + TPM_INT_ENABLE(chip->vendor.locality));\r\n}\r\nstatic int tpm_tis_resume(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nint ret;\r\nif (chip->vendor.irq)\r\ntpm_tis_reenable_interrupts(chip);\r\nret = tpm_pm_resume(dev);\r\nif (!ret)\r\ntpm_do_selftest(chip);\r\nreturn ret;\r\n}\r\nstatic int tpm_tis_pnp_init(struct pnp_dev *pnp_dev,\r\nconst struct pnp_device_id *pnp_id)\r\n{\r\nresource_size_t start, len;\r\nunsigned int irq = 0;\r\nstart = pnp_mem_start(pnp_dev, 0);\r\nlen = pnp_mem_len(pnp_dev, 0);\r\nif (pnp_irq_valid(pnp_dev, 0))\r\nirq = pnp_irq(pnp_dev, 0);\r\nelse\r\ninterrupts = false;\r\nif (is_itpm(pnp_dev))\r\nitpm = true;\r\nreturn tpm_tis_init(&pnp_dev->dev, start, len, irq);\r\n}\r\nstatic void tpm_tis_pnp_remove(struct pnp_dev *dev)\r\n{\r\nstruct tpm_chip *chip = pnp_get_drvdata(dev);\r\ntpm_dev_vendor_release(chip);\r\nkfree(chip);\r\n}\r\nstatic int __init init_tis(void)\r\n{\r\nint rc;\r\n#ifdef CONFIG_PNP\r\nif (!force)\r\nreturn pnp_register_driver(&tis_pnp_driver);\r\n#endif\r\nrc = platform_driver_register(&tis_drv);\r\nif (rc < 0)\r\nreturn rc;\r\npdev = platform_device_register_simple("tpm_tis", -1, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\nrc = PTR_ERR(pdev);\r\ngoto err_dev;\r\n}\r\nrc = tpm_tis_init(&pdev->dev, TIS_MEM_BASE, TIS_MEM_LEN, 0);\r\nif (rc)\r\ngoto err_init;\r\nreturn 0;\r\nerr_init:\r\nplatform_device_unregister(pdev);\r\nerr_dev:\r\nplatform_driver_unregister(&tis_drv);\r\nreturn rc;\r\n}\r\nstatic void __exit cleanup_tis(void)\r\n{\r\nstruct tpm_vendor_specific *i, *j;\r\nstruct tpm_chip *chip;\r\nmutex_lock(&tis_lock);\r\nlist_for_each_entry_safe(i, j, &tis_chips, list) {\r\nchip = to_tpm_chip(i);\r\ntpm_remove_hardware(chip->dev);\r\niowrite32(~TPM_GLOBAL_INT_ENABLE &\r\nioread32(chip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.\r\nlocality)),\r\nchip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nrelease_locality(chip, chip->vendor.locality, 1);\r\nif (chip->vendor.irq)\r\nfree_irq(chip->vendor.irq, chip);\r\niounmap(i->iobase);\r\nlist_del(&i->list);\r\n}\r\nmutex_unlock(&tis_lock);\r\n#ifdef CONFIG_PNP\r\nif (!force) {\r\npnp_unregister_driver(&tis_pnp_driver);\r\nreturn;\r\n}\r\n#endif\r\nplatform_device_unregister(pdev);\r\nplatform_driver_unregister(&tis_drv);\r\n}
