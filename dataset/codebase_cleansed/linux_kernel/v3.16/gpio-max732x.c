static int max732x_writeb(struct max732x_chip *chip, int group_a, uint8_t val)\r\n{\r\nstruct i2c_client *client;\r\nint ret;\r\nclient = group_a ? chip->client_group_a : chip->client_group_b;\r\nret = i2c_smbus_write_byte(client, val);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed writing\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max732x_readb(struct max732x_chip *chip, int group_a, uint8_t *val)\r\n{\r\nstruct i2c_client *client;\r\nint ret;\r\nclient = group_a ? chip->client_group_a : chip->client_group_b;\r\nret = i2c_smbus_read_byte(client);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed reading\n");\r\nreturn ret;\r\n}\r\n*val = (uint8_t)ret;\r\nreturn 0;\r\n}\r\nstatic inline int is_group_a(struct max732x_chip *chip, unsigned off)\r\n{\r\nreturn (1u << off) & chip->mask_group_a;\r\n}\r\nstatic int max732x_gpio_get_value(struct gpio_chip *gc, unsigned off)\r\n{\r\nstruct max732x_chip *chip;\r\nuint8_t reg_val;\r\nint ret;\r\nchip = container_of(gc, struct max732x_chip, gpio_chip);\r\nret = max732x_readb(chip, is_group_a(chip, off), &reg_val);\r\nif (ret < 0)\r\nreturn 0;\r\nreturn reg_val & (1u << (off & 0x7));\r\n}\r\nstatic void max732x_gpio_set_value(struct gpio_chip *gc, unsigned off, int val)\r\n{\r\nstruct max732x_chip *chip;\r\nuint8_t reg_out, mask = 1u << (off & 0x7);\r\nint ret;\r\nchip = container_of(gc, struct max732x_chip, gpio_chip);\r\nmutex_lock(&chip->lock);\r\nreg_out = (off > 7) ? chip->reg_out[1] : chip->reg_out[0];\r\nreg_out = (val) ? reg_out | mask : reg_out & ~mask;\r\nret = max732x_writeb(chip, is_group_a(chip, off), reg_out);\r\nif (ret < 0)\r\ngoto out;\r\nif (off > 7)\r\nchip->reg_out[1] = reg_out;\r\nelse\r\nchip->reg_out[0] = reg_out;\r\nout:\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic int max732x_gpio_direction_input(struct gpio_chip *gc, unsigned off)\r\n{\r\nstruct max732x_chip *chip;\r\nunsigned int mask = 1u << off;\r\nchip = container_of(gc, struct max732x_chip, gpio_chip);\r\nif ((mask & chip->dir_input) == 0) {\r\ndev_dbg(&chip->client->dev, "%s port %d is output only\n",\r\nchip->client->name, off);\r\nreturn -EACCES;\r\n}\r\nif ((mask & chip->dir_output))\r\nmax732x_gpio_set_value(gc, off, 1);\r\nreturn 0;\r\n}\r\nstatic int max732x_gpio_direction_output(struct gpio_chip *gc,\r\nunsigned off, int val)\r\n{\r\nstruct max732x_chip *chip;\r\nunsigned int mask = 1u << off;\r\nchip = container_of(gc, struct max732x_chip, gpio_chip);\r\nif ((mask & chip->dir_output) == 0) {\r\ndev_dbg(&chip->client->dev, "%s port %d is input only\n",\r\nchip->client->name, off);\r\nreturn -EACCES;\r\n}\r\nmax732x_gpio_set_value(gc, off, val);\r\nreturn 0;\r\n}\r\nstatic int max732x_writew(struct max732x_chip *chip, uint16_t val)\r\n{\r\nint ret;\r\nval = cpu_to_le16(val);\r\nret = i2c_master_send(chip->client_group_a, (char *)&val, 2);\r\nif (ret < 0) {\r\ndev_err(&chip->client_group_a->dev, "failed writing\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max732x_readw(struct max732x_chip *chip, uint16_t *val)\r\n{\r\nint ret;\r\nret = i2c_master_recv(chip->client_group_a, (char *)val, 2);\r\nif (ret < 0) {\r\ndev_err(&chip->client_group_a->dev, "failed reading\n");\r\nreturn ret;\r\n}\r\n*val = le16_to_cpu(*val);\r\nreturn 0;\r\n}\r\nstatic void max732x_irq_update_mask(struct max732x_chip *chip)\r\n{\r\nuint16_t msg;\r\nif (chip->irq_mask == chip->irq_mask_cur)\r\nreturn;\r\nchip->irq_mask = chip->irq_mask_cur;\r\nif (chip->irq_features == INT_NO_MASK)\r\nreturn;\r\nmutex_lock(&chip->lock);\r\nswitch (chip->irq_features) {\r\ncase INT_INDEP_MASK:\r\nmsg = (chip->irq_mask << 8) | chip->reg_out[0];\r\nmax732x_writew(chip, msg);\r\nbreak;\r\ncase INT_MERGED_MASK:\r\nmsg = chip->irq_mask | chip->reg_out[0];\r\nmax732x_writeb(chip, 1, (uint8_t)msg);\r\nbreak;\r\n}\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic int max732x_gpio_to_irq(struct gpio_chip *gc, unsigned off)\r\n{\r\nstruct max732x_chip *chip;\r\nchip = container_of(gc, struct max732x_chip, gpio_chip);\r\nreturn chip->irq_base + off;\r\n}\r\nstatic void max732x_irq_mask(struct irq_data *d)\r\n{\r\nstruct max732x_chip *chip = irq_data_get_irq_chip_data(d);\r\nchip->irq_mask_cur &= ~(1 << (d->irq - chip->irq_base));\r\n}\r\nstatic void max732x_irq_unmask(struct irq_data *d)\r\n{\r\nstruct max732x_chip *chip = irq_data_get_irq_chip_data(d);\r\nchip->irq_mask_cur |= 1 << (d->irq - chip->irq_base);\r\n}\r\nstatic void max732x_irq_bus_lock(struct irq_data *d)\r\n{\r\nstruct max732x_chip *chip = irq_data_get_irq_chip_data(d);\r\nmutex_lock(&chip->irq_lock);\r\nchip->irq_mask_cur = chip->irq_mask;\r\n}\r\nstatic void max732x_irq_bus_sync_unlock(struct irq_data *d)\r\n{\r\nstruct max732x_chip *chip = irq_data_get_irq_chip_data(d);\r\nmax732x_irq_update_mask(chip);\r\nmutex_unlock(&chip->irq_lock);\r\n}\r\nstatic int max732x_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct max732x_chip *chip = irq_data_get_irq_chip_data(d);\r\nuint16_t off = d->irq - chip->irq_base;\r\nuint16_t mask = 1 << off;\r\nif (!(mask & chip->dir_input)) {\r\ndev_dbg(&chip->client->dev, "%s port %d is output only\n",\r\nchip->client->name, off);\r\nreturn -EACCES;\r\n}\r\nif (!(type & IRQ_TYPE_EDGE_BOTH)) {\r\ndev_err(&chip->client->dev, "irq %d: unsupported type %d\n",\r\nd->irq, type);\r\nreturn -EINVAL;\r\n}\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nchip->irq_trig_fall |= mask;\r\nelse\r\nchip->irq_trig_fall &= ~mask;\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nchip->irq_trig_raise |= mask;\r\nelse\r\nchip->irq_trig_raise &= ~mask;\r\nreturn max732x_gpio_direction_input(&chip->gpio_chip, off);\r\n}\r\nstatic uint8_t max732x_irq_pending(struct max732x_chip *chip)\r\n{\r\nuint8_t cur_stat;\r\nuint8_t old_stat;\r\nuint8_t trigger;\r\nuint8_t pending;\r\nuint16_t status;\r\nint ret;\r\nret = max732x_readw(chip, &status);\r\nif (ret)\r\nreturn 0;\r\ntrigger = status >> 8;\r\ntrigger &= chip->irq_mask;\r\nif (!trigger)\r\nreturn 0;\r\ncur_stat = status & 0xFF;\r\ncur_stat &= chip->irq_mask;\r\nold_stat = cur_stat ^ trigger;\r\npending = (old_stat & chip->irq_trig_fall) |\r\n(cur_stat & chip->irq_trig_raise);\r\npending &= trigger;\r\nreturn pending;\r\n}\r\nstatic irqreturn_t max732x_irq_handler(int irq, void *devid)\r\n{\r\nstruct max732x_chip *chip = devid;\r\nuint8_t pending;\r\nuint8_t level;\r\npending = max732x_irq_pending(chip);\r\nif (!pending)\r\nreturn IRQ_HANDLED;\r\ndo {\r\nlevel = __ffs(pending);\r\nhandle_nested_irq(level + chip->irq_base);\r\npending &= ~(1 << level);\r\n} while (pending);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int max732x_irq_setup(struct max732x_chip *chip,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nstruct max732x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nint has_irq = max732x_features[id->driver_data] >> 32;\r\nint ret;\r\nif (pdata->irq_base && has_irq != INT_NONE) {\r\nint lvl;\r\nchip->irq_base = pdata->irq_base;\r\nchip->irq_features = has_irq;\r\nmutex_init(&chip->irq_lock);\r\nfor (lvl = 0; lvl < chip->gpio_chip.ngpio; lvl++) {\r\nint irq = lvl + chip->irq_base;\r\nif (!(chip->dir_input & (1 << lvl)))\r\ncontinue;\r\nirq_set_chip_data(irq, chip);\r\nirq_set_chip_and_handler(irq, &max732x_irq_chip,\r\nhandle_edge_irq);\r\nirq_set_nested_thread(irq, 1);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(irq);\r\n#endif\r\n}\r\nret = request_threaded_irq(client->irq,\r\nNULL,\r\nmax732x_irq_handler,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\ndev_name(&client->dev), chip);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to request irq %d\n",\r\nclient->irq);\r\ngoto out_failed;\r\n}\r\nchip->gpio_chip.to_irq = max732x_gpio_to_irq;\r\n}\r\nreturn 0;\r\nout_failed:\r\nchip->irq_base = 0;\r\nreturn ret;\r\n}\r\nstatic void max732x_irq_teardown(struct max732x_chip *chip)\r\n{\r\nif (chip->irq_base)\r\nfree_irq(chip->client->irq, chip);\r\n}\r\nstatic int max732x_irq_setup(struct max732x_chip *chip,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nstruct max732x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nint has_irq = max732x_features[id->driver_data] >> 32;\r\nif (pdata->irq_base && has_irq != INT_NONE)\r\ndev_warn(&client->dev, "interrupt support not compiled in\n");\r\nreturn 0;\r\n}\r\nstatic void max732x_irq_teardown(struct max732x_chip *chip)\r\n{\r\n}\r\nstatic int max732x_setup_gpio(struct max732x_chip *chip,\r\nconst struct i2c_device_id *id,\r\nunsigned gpio_start)\r\n{\r\nstruct gpio_chip *gc = &chip->gpio_chip;\r\nuint32_t id_data = (uint32_t)max732x_features[id->driver_data];\r\nint i, port = 0;\r\nfor (i = 0; i < 16; i++, id_data >>= 2) {\r\nunsigned int mask = 1 << port;\r\nswitch (id_data & 0x3) {\r\ncase PORT_OUTPUT:\r\nchip->dir_output |= mask;\r\nbreak;\r\ncase PORT_INPUT:\r\nchip->dir_input |= mask;\r\nbreak;\r\ncase PORT_OPENDRAIN:\r\nchip->dir_output |= mask;\r\nchip->dir_input |= mask;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nif (i < 8)\r\nchip->mask_group_a |= mask;\r\nport++;\r\n}\r\nif (chip->dir_input)\r\ngc->direction_input = max732x_gpio_direction_input;\r\nif (chip->dir_output) {\r\ngc->direction_output = max732x_gpio_direction_output;\r\ngc->set = max732x_gpio_set_value;\r\n}\r\ngc->get = max732x_gpio_get_value;\r\ngc->can_sleep = true;\r\ngc->base = gpio_start;\r\ngc->ngpio = port;\r\ngc->label = chip->client->name;\r\ngc->owner = THIS_MODULE;\r\nreturn port;\r\n}\r\nstatic int max732x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct max732x_platform_data *pdata;\r\nstruct max732x_chip *chip;\r\nstruct i2c_client *c;\r\nuint16_t addr_a, addr_b;\r\nint ret, nr_port;\r\npdata = dev_get_platdata(&client->dev);\r\nif (pdata == NULL) {\r\ndev_dbg(&client->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nchip = devm_kzalloc(&client->dev, sizeof(struct max732x_chip),\r\nGFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nchip->client = client;\r\nnr_port = max732x_setup_gpio(chip, id, pdata->gpio_base);\r\naddr_a = (client->addr & 0x0f) | 0x60;\r\naddr_b = (client->addr & 0x0f) | 0x50;\r\nswitch (client->addr & 0x70) {\r\ncase 0x60:\r\nchip->client_group_a = client;\r\nif (nr_port > 8) {\r\nc = i2c_new_dummy(client->adapter, addr_b);\r\nchip->client_group_b = chip->client_dummy = c;\r\n}\r\nbreak;\r\ncase 0x50:\r\nchip->client_group_b = client;\r\nif (nr_port > 8) {\r\nc = i2c_new_dummy(client->adapter, addr_a);\r\nchip->client_group_a = chip->client_dummy = c;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "invalid I2C address specified %02x\n",\r\nclient->addr);\r\nret = -EINVAL;\r\ngoto out_failed;\r\n}\r\nif (nr_port > 8 && !chip->client_dummy) {\r\ndev_err(&client->dev,\r\n"Failed to allocate second group I2C device\n");\r\nret = -ENODEV;\r\ngoto out_failed;\r\n}\r\nmutex_init(&chip->lock);\r\nmax732x_readb(chip, is_group_a(chip, 0), &chip->reg_out[0]);\r\nif (nr_port > 8)\r\nmax732x_readb(chip, is_group_a(chip, 8), &chip->reg_out[1]);\r\nret = max732x_irq_setup(chip, id);\r\nif (ret)\r\ngoto out_failed;\r\nret = gpiochip_add(&chip->gpio_chip);\r\nif (ret)\r\ngoto out_failed;\r\nif (pdata->setup) {\r\nret = pdata->setup(client, chip->gpio_chip.base,\r\nchip->gpio_chip.ngpio, pdata->context);\r\nif (ret < 0)\r\ndev_warn(&client->dev, "setup failed, %d\n", ret);\r\n}\r\ni2c_set_clientdata(client, chip);\r\nreturn 0;\r\nout_failed:\r\nif (chip->client_dummy)\r\ni2c_unregister_device(chip->client_dummy);\r\nmax732x_irq_teardown(chip);\r\nreturn ret;\r\n}\r\nstatic int max732x_remove(struct i2c_client *client)\r\n{\r\nstruct max732x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct max732x_chip *chip = i2c_get_clientdata(client);\r\nint ret;\r\nif (pdata->teardown) {\r\nret = pdata->teardown(client, chip->gpio_chip.base,\r\nchip->gpio_chip.ngpio, pdata->context);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "%s failed, %d\n",\r\n"teardown", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = gpiochip_remove(&chip->gpio_chip);\r\nif (ret) {\r\ndev_err(&client->dev, "%s failed, %d\n",\r\n"gpiochip_remove()", ret);\r\nreturn ret;\r\n}\r\nmax732x_irq_teardown(chip);\r\nif (chip->client_dummy)\r\ni2c_unregister_device(chip->client_dummy);\r\nreturn 0;\r\n}\r\nstatic int __init max732x_init(void)\r\n{\r\nreturn i2c_add_driver(&max732x_driver);\r\n}\r\nstatic void __exit max732x_exit(void)\r\n{\r\ni2c_del_driver(&max732x_driver);\r\n}
