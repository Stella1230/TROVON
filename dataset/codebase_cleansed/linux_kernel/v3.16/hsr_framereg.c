static struct node_entry *find_node_by_AddrA(struct list_head *node_db,\r\nconst unsigned char addr[ETH_ALEN])\r\n{\r\nstruct node_entry *node;\r\nlist_for_each_entry_rcu(node, node_db, mac_list) {\r\nif (ether_addr_equal(node->MacAddressA, addr))\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct node_entry *find_node_by_AddrB(struct list_head *node_db,\r\nconst unsigned char addr[ETH_ALEN])\r\n{\r\nstruct node_entry *node;\r\nlist_for_each_entry_rcu(node, node_db, mac_list) {\r\nif (ether_addr_equal(node->MacAddressB, addr))\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nstruct node_entry *hsr_find_node(struct list_head *node_db, struct sk_buff *skb)\r\n{\r\nstruct node_entry *node;\r\nstruct ethhdr *ethhdr;\r\nif (!skb_mac_header_was_set(skb))\r\nreturn NULL;\r\nethhdr = (struct ethhdr *) skb_mac_header(skb);\r\nlist_for_each_entry_rcu(node, node_db, mac_list) {\r\nif (ether_addr_equal(node->MacAddressA, ethhdr->h_source))\r\nreturn node;\r\nif (ether_addr_equal(node->MacAddressB, ethhdr->h_source))\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nint hsr_create_self_node(struct list_head *self_node_db,\r\nunsigned char addr_a[ETH_ALEN],\r\nunsigned char addr_b[ETH_ALEN])\r\n{\r\nstruct node_entry *node, *oldnode;\r\nnode = kmalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node)\r\nreturn -ENOMEM;\r\nether_addr_copy(node->MacAddressA, addr_a);\r\nether_addr_copy(node->MacAddressB, addr_b);\r\nrcu_read_lock();\r\noldnode = list_first_or_null_rcu(self_node_db,\r\nstruct node_entry, mac_list);\r\nif (oldnode) {\r\nlist_replace_rcu(&oldnode->mac_list, &node->mac_list);\r\nrcu_read_unlock();\r\nsynchronize_rcu();\r\nkfree(oldnode);\r\n} else {\r\nrcu_read_unlock();\r\nlist_add_tail_rcu(&node->mac_list, self_node_db);\r\n}\r\nreturn 0;\r\n}\r\nstruct node_entry *hsr_merge_node(struct hsr_priv *hsr_priv,\r\nstruct node_entry *node,\r\nstruct sk_buff *skb,\r\nenum hsr_dev_idx dev_idx)\r\n{\r\nstruct hsr_sup_payload *hsr_sp;\r\nstruct hsr_ethhdr_sp *hsr_ethsup;\r\nint i;\r\nunsigned long now;\r\nhsr_ethsup = (struct hsr_ethhdr_sp *) skb_mac_header(skb);\r\nhsr_sp = (struct hsr_sup_payload *) skb->data;\r\nif (node && !ether_addr_equal(node->MacAddressA, hsr_sp->MacAddressA)) {\r\nlist_del_rcu(&node->mac_list);\r\nkfree_rcu(node, rcu_head);\r\nnode = NULL;\r\n}\r\nif (node && (dev_idx == node->AddrB_if) &&\r\n!ether_addr_equal(node->MacAddressB, hsr_ethsup->ethhdr.h_source)) {\r\nlist_del_rcu(&node->mac_list);\r\nkfree_rcu(node, rcu_head);\r\nnode = NULL;\r\n}\r\nif (node && (dev_idx != node->AddrB_if) &&\r\n(node->AddrB_if != HSR_DEV_NONE) &&\r\n!ether_addr_equal(node->MacAddressA, hsr_ethsup->ethhdr.h_source)) {\r\nlist_del_rcu(&node->mac_list);\r\nkfree_rcu(node, rcu_head);\r\nnode = NULL;\r\n}\r\nif (node)\r\nreturn node;\r\nnode = find_node_by_AddrA(&hsr_priv->node_db, hsr_sp->MacAddressA);\r\nif (node) {\r\nether_addr_copy(node->MacAddressB, hsr_ethsup->ethhdr.h_source);\r\nnode->AddrB_if = dev_idx;\r\nreturn node;\r\n}\r\nnode = kzalloc(sizeof(*node), GFP_ATOMIC);\r\nif (!node)\r\nreturn NULL;\r\nether_addr_copy(node->MacAddressA, hsr_sp->MacAddressA);\r\nether_addr_copy(node->MacAddressB, hsr_ethsup->ethhdr.h_source);\r\nif (!ether_addr_equal(hsr_sp->MacAddressA, hsr_ethsup->ethhdr.h_source))\r\nnode->AddrB_if = dev_idx;\r\nelse\r\nnode->AddrB_if = HSR_DEV_NONE;\r\nnow = jiffies;\r\nfor (i = 0; i < HSR_MAX_SLAVE; i++)\r\nnode->time_in[i] = now;\r\nfor (i = 0; i < HSR_MAX_DEV; i++)\r\nnode->seq_out[i] = ntohs(hsr_ethsup->hsr_sup.sequence_nr) - 1;\r\nlist_add_tail_rcu(&node->mac_list, &hsr_priv->node_db);\r\nreturn node;\r\n}\r\nvoid hsr_addr_subst_source(struct hsr_priv *hsr_priv, struct sk_buff *skb)\r\n{\r\nstruct ethhdr *ethhdr;\r\nstruct node_entry *node;\r\nif (!skb_mac_header_was_set(skb)) {\r\nWARN_ONCE(1, "%s: Mac header not set\n", __func__);\r\nreturn;\r\n}\r\nethhdr = (struct ethhdr *) skb_mac_header(skb);\r\nrcu_read_lock();\r\nnode = find_node_by_AddrB(&hsr_priv->node_db, ethhdr->h_source);\r\nif (node)\r\nether_addr_copy(ethhdr->h_source, node->MacAddressA);\r\nrcu_read_unlock();\r\n}\r\nvoid hsr_addr_subst_dest(struct hsr_priv *hsr_priv, struct ethhdr *ethhdr,\r\nenum hsr_dev_idx dev_idx)\r\n{\r\nstruct node_entry *node;\r\nrcu_read_lock();\r\nnode = find_node_by_AddrA(&hsr_priv->node_db, ethhdr->h_dest);\r\nif (node && (node->AddrB_if == dev_idx))\r\nether_addr_copy(ethhdr->h_dest, node->MacAddressB);\r\nrcu_read_unlock();\r\n}\r\nstatic bool seq_nr_after(u16 a, u16 b)\r\n{\r\nif ((int) b - a == 32768)\r\nreturn false;\r\nreturn (((s16) (b - a)) < 0);\r\n}\r\nvoid hsr_register_frame_in(struct node_entry *node, enum hsr_dev_idx dev_idx)\r\n{\r\nif ((dev_idx < 0) || (dev_idx >= HSR_MAX_SLAVE)) {\r\nWARN_ONCE(1, "%s: Invalid dev_idx (%d)\n", __func__, dev_idx);\r\nreturn;\r\n}\r\nnode->time_in[dev_idx] = jiffies;\r\nnode->time_in_stale[dev_idx] = false;\r\n}\r\nint hsr_register_frame_out(struct node_entry *node, enum hsr_dev_idx dev_idx,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hsr_ethhdr *hsr_ethhdr;\r\nu16 sequence_nr;\r\nif ((dev_idx < 0) || (dev_idx >= HSR_MAX_DEV)) {\r\nWARN_ONCE(1, "%s: Invalid dev_idx (%d)\n", __func__, dev_idx);\r\nreturn -EINVAL;\r\n}\r\nif (!skb_mac_header_was_set(skb)) {\r\nWARN_ONCE(1, "%s: Mac header not set\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nhsr_ethhdr = (struct hsr_ethhdr *) skb_mac_header(skb);\r\nsequence_nr = ntohs(hsr_ethhdr->hsr_tag.sequence_nr);\r\nif (seq_nr_before_or_eq(sequence_nr, node->seq_out[dev_idx]))\r\nreturn 1;\r\nnode->seq_out[dev_idx] = sequence_nr;\r\nreturn 0;\r\n}\r\nstatic bool is_late(struct node_entry *node, enum hsr_dev_idx dev_idx)\r\n{\r\nenum hsr_dev_idx other;\r\nif (node->time_in_stale[dev_idx])\r\nreturn true;\r\nif (dev_idx == HSR_DEV_SLAVE_A)\r\nother = HSR_DEV_SLAVE_B;\r\nelse\r\nother = HSR_DEV_SLAVE_A;\r\nif (node->time_in_stale[other])\r\nreturn false;\r\nif (time_after(node->time_in[other], node->time_in[dev_idx] +\r\nmsecs_to_jiffies(MAX_SLAVE_DIFF)))\r\nreturn true;\r\nreturn false;\r\n}\r\nvoid hsr_prune_nodes(struct hsr_priv *hsr_priv)\r\n{\r\nstruct node_entry *node;\r\nunsigned long timestamp;\r\nunsigned long time_a, time_b;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(node, &hsr_priv->node_db, mac_list) {\r\ntime_a = node->time_in[HSR_DEV_SLAVE_A];\r\ntime_b = node->time_in[HSR_DEV_SLAVE_B];\r\nif (time_after(jiffies, time_a + MAX_JIFFY_OFFSET/2))\r\nnode->time_in_stale[HSR_DEV_SLAVE_A] = true;\r\nif (time_after(jiffies, time_b + MAX_JIFFY_OFFSET/2))\r\nnode->time_in_stale[HSR_DEV_SLAVE_B] = true;\r\ntimestamp = time_a;\r\nif (node->time_in_stale[HSR_DEV_SLAVE_A] ||\r\n(!node->time_in_stale[HSR_DEV_SLAVE_B] &&\r\ntime_after(time_b, time_a)))\r\ntimestamp = time_b;\r\nif (time_is_after_jiffies(timestamp +\r\nmsecs_to_jiffies(1.5*MAX_SLAVE_DIFF))) {\r\nif (is_late(node, HSR_DEV_SLAVE_A))\r\nhsr_nl_ringerror(hsr_priv, node->MacAddressA,\r\nHSR_DEV_SLAVE_A);\r\nelse if (is_late(node, HSR_DEV_SLAVE_B))\r\nhsr_nl_ringerror(hsr_priv, node->MacAddressA,\r\nHSR_DEV_SLAVE_B);\r\n}\r\nif (time_is_before_jiffies(timestamp +\r\nmsecs_to_jiffies(HSR_NODE_FORGET_TIME))) {\r\nhsr_nl_nodedown(hsr_priv, node->MacAddressA);\r\nlist_del_rcu(&node->mac_list);\r\nkfree_rcu(node, rcu_head);\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid *hsr_get_next_node(struct hsr_priv *hsr_priv, void *_pos,\r\nunsigned char addr[ETH_ALEN])\r\n{\r\nstruct node_entry *node;\r\nif (!_pos) {\r\nnode = list_first_or_null_rcu(&hsr_priv->node_db,\r\nstruct node_entry, mac_list);\r\nif (node)\r\nether_addr_copy(addr, node->MacAddressA);\r\nreturn node;\r\n}\r\nnode = _pos;\r\nlist_for_each_entry_continue_rcu(node, &hsr_priv->node_db, mac_list) {\r\nether_addr_copy(addr, node->MacAddressA);\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nint hsr_get_node_data(struct hsr_priv *hsr_priv,\r\nconst unsigned char *addr,\r\nunsigned char addr_b[ETH_ALEN],\r\nunsigned int *addr_b_ifindex,\r\nint *if1_age,\r\nu16 *if1_seq,\r\nint *if2_age,\r\nu16 *if2_seq)\r\n{\r\nstruct node_entry *node;\r\nunsigned long tdiff;\r\nrcu_read_lock();\r\nnode = find_node_by_AddrA(&hsr_priv->node_db, addr);\r\nif (!node) {\r\nrcu_read_unlock();\r\nreturn -ENOENT;\r\n}\r\nether_addr_copy(addr_b, node->MacAddressB);\r\ntdiff = jiffies - node->time_in[HSR_DEV_SLAVE_A];\r\nif (node->time_in_stale[HSR_DEV_SLAVE_A])\r\n*if1_age = INT_MAX;\r\n#if HZ <= MSEC_PER_SEC\r\nelse if (tdiff > msecs_to_jiffies(INT_MAX))\r\n*if1_age = INT_MAX;\r\n#endif\r\nelse\r\n*if1_age = jiffies_to_msecs(tdiff);\r\ntdiff = jiffies - node->time_in[HSR_DEV_SLAVE_B];\r\nif (node->time_in_stale[HSR_DEV_SLAVE_B])\r\n*if2_age = INT_MAX;\r\n#if HZ <= MSEC_PER_SEC\r\nelse if (tdiff > msecs_to_jiffies(INT_MAX))\r\n*if2_age = INT_MAX;\r\n#endif\r\nelse\r\n*if2_age = jiffies_to_msecs(tdiff);\r\n*if1_seq = node->seq_out[HSR_DEV_SLAVE_B];\r\n*if2_seq = node->seq_out[HSR_DEV_SLAVE_A];\r\nif ((node->AddrB_if != HSR_DEV_NONE) && hsr_priv->slave[node->AddrB_if])\r\n*addr_b_ifindex = hsr_priv->slave[node->AddrB_if]->ifindex;\r\nelse\r\n*addr_b_ifindex = -1;\r\nrcu_read_unlock();\r\nreturn 0;\r\n}
