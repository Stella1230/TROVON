void\r\ncifs_mark_open_files_invalid(struct cifs_tcon *tcon)\r\n{\r\nstruct cifsFileInfo *open_file = NULL;\r\nstruct list_head *tmp;\r\nstruct list_head *tmp1;\r\nspin_lock(&cifs_file_list_lock);\r\nlist_for_each_safe(tmp, tmp1, &tcon->openFileList) {\r\nopen_file = list_entry(tmp, struct cifsFileInfo, tlist);\r\nopen_file->invalidHandle = true;\r\nopen_file->oplock_break_cancelled = true;\r\n}\r\nspin_unlock(&cifs_file_list_lock);\r\n}\r\nstatic int\r\ncifs_reconnect_tcon(struct cifs_tcon *tcon, int smb_command)\r\n{\r\nint rc;\r\nstruct cifs_ses *ses;\r\nstruct TCP_Server_Info *server;\r\nstruct nls_table *nls_codepage;\r\nif (!tcon)\r\nreturn 0;\r\nses = tcon->ses;\r\nserver = ses->server;\r\nif (tcon->tidStatus == CifsExiting) {\r\nif (smb_command != SMB_COM_WRITE_ANDX &&\r\nsmb_command != SMB_COM_OPEN_ANDX &&\r\nsmb_command != SMB_COM_TREE_DISCONNECT) {\r\ncifs_dbg(FYI, "can not send cmd %d while umounting\n",\r\nsmb_command);\r\nreturn -ENODEV;\r\n}\r\n}\r\nwhile (server->tcpStatus == CifsNeedReconnect) {\r\nwait_event_interruptible_timeout(server->response_q,\r\n(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\r\nif (server->tcpStatus != CifsNeedReconnect)\r\nbreak;\r\nif (!tcon->retry) {\r\ncifs_dbg(FYI, "gave up waiting on reconnect in smb_init\n");\r\nreturn -EHOSTDOWN;\r\n}\r\n}\r\nif (!ses->need_reconnect && !tcon->need_reconnect)\r\nreturn 0;\r\nnls_codepage = load_nls_default();\r\nmutex_lock(&ses->session_mutex);\r\nrc = cifs_negotiate_protocol(0, ses);\r\nif (rc == 0 && ses->need_reconnect)\r\nrc = cifs_setup_session(0, ses, nls_codepage);\r\nif (rc || !tcon->need_reconnect) {\r\nmutex_unlock(&ses->session_mutex);\r\ngoto out;\r\n}\r\ncifs_mark_open_files_invalid(tcon);\r\nrc = CIFSTCon(0, ses, tcon->treeName, tcon, nls_codepage);\r\nmutex_unlock(&ses->session_mutex);\r\ncifs_dbg(FYI, "reconnect tcon rc = %d\n", rc);\r\nif (rc)\r\ngoto out;\r\natomic_inc(&tconInfoReconnectCount);\r\nif (ses->capabilities & CAP_UNIX)\r\nreset_cifs_unix_caps(0, tcon, NULL, NULL);\r\nout:\r\nswitch (smb_command) {\r\ncase SMB_COM_READ_ANDX:\r\ncase SMB_COM_WRITE_ANDX:\r\ncase SMB_COM_CLOSE:\r\ncase SMB_COM_FIND_CLOSE2:\r\ncase SMB_COM_LOCKING_ANDX:\r\nrc = -EAGAIN;\r\n}\r\nunload_nls(nls_codepage);\r\nreturn rc;\r\n}\r\nstatic int\r\nsmall_smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\r\nvoid **request_buf)\r\n{\r\nint rc;\r\nrc = cifs_reconnect_tcon(tcon, smb_command);\r\nif (rc)\r\nreturn rc;\r\n*request_buf = cifs_small_buf_get();\r\nif (*request_buf == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nheader_assemble((struct smb_hdr *) *request_buf, smb_command,\r\ntcon, wct);\r\nif (tcon != NULL)\r\ncifs_stats_inc(&tcon->num_smbs_sent);\r\nreturn 0;\r\n}\r\nint\r\nsmall_smb_init_no_tc(const int smb_command, const int wct,\r\nstruct cifs_ses *ses, void **request_buf)\r\n{\r\nint rc;\r\nstruct smb_hdr *buffer;\r\nrc = small_smb_init(smb_command, wct, NULL, request_buf);\r\nif (rc)\r\nreturn rc;\r\nbuffer = (struct smb_hdr *)*request_buf;\r\nbuffer->Mid = get_next_mid(ses->server);\r\nif (ses->capabilities & CAP_UNICODE)\r\nbuffer->Flags2 |= SMBFLG2_UNICODE;\r\nif (ses->capabilities & CAP_STATUS32)\r\nbuffer->Flags2 |= SMBFLG2_ERR_STATUS;\r\nreturn rc;\r\n}\r\nstatic int\r\n__smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\r\nvoid **request_buf, void **response_buf)\r\n{\r\n*request_buf = cifs_buf_get();\r\nif (*request_buf == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nif (response_buf)\r\n*response_buf = *request_buf;\r\nheader_assemble((struct smb_hdr *) *request_buf, smb_command, tcon,\r\nwct);\r\nif (tcon != NULL)\r\ncifs_stats_inc(&tcon->num_smbs_sent);\r\nreturn 0;\r\n}\r\nstatic int\r\nsmb_init(int smb_command, int wct, struct cifs_tcon *tcon,\r\nvoid **request_buf, void **response_buf)\r\n{\r\nint rc;\r\nrc = cifs_reconnect_tcon(tcon, smb_command);\r\nif (rc)\r\nreturn rc;\r\nreturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\r\n}\r\nstatic int\r\nsmb_init_no_reconnect(int smb_command, int wct, struct cifs_tcon *tcon,\r\nvoid **request_buf, void **response_buf)\r\n{\r\nif (tcon->ses->need_reconnect || tcon->need_reconnect)\r\nreturn -EHOSTDOWN;\r\nreturn __smb_init(smb_command, wct, tcon, request_buf, response_buf);\r\n}\r\nstatic int validate_t2(struct smb_t2_rsp *pSMB)\r\n{\r\nunsigned int total_size;\r\nif (pSMB->hdr.WordCount < 10)\r\ngoto vt2_err;\r\nif (get_unaligned_le16(&pSMB->t2_rsp.ParameterOffset) > 1024 ||\r\nget_unaligned_le16(&pSMB->t2_rsp.DataOffset) > 1024)\r\ngoto vt2_err;\r\ntotal_size = get_unaligned_le16(&pSMB->t2_rsp.ParameterCount);\r\nif (total_size >= 512)\r\ngoto vt2_err;\r\ntotal_size += get_unaligned_le16(&pSMB->t2_rsp.DataCount);\r\nif (total_size > get_bcc(&pSMB->hdr) ||\r\ntotal_size >= CIFSMaxBufSize + MAX_CIFS_HDR_SIZE)\r\ngoto vt2_err;\r\nreturn 0;\r\nvt2_err:\r\ncifs_dump_mem("Invalid transact2 SMB: ", (char *)pSMB,\r\nsizeof(struct smb_t2_rsp) + 16);\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\ndecode_ext_sec_blob(struct cifs_ses *ses, NEGOTIATE_RSP *pSMBr)\r\n{\r\nint rc = 0;\r\nu16 count;\r\nchar *guid = pSMBr->u.extended_response.GUID;\r\nstruct TCP_Server_Info *server = ses->server;\r\ncount = get_bcc(&pSMBr->hdr);\r\nif (count < SMB1_CLIENT_GUID_SIZE)\r\nreturn -EIO;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nif (server->srv_count > 1) {\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nif (memcmp(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE) != 0) {\r\ncifs_dbg(FYI, "server UID changed\n");\r\nmemcpy(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE);\r\n}\r\n} else {\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nmemcpy(server->server_GUID, guid, SMB1_CLIENT_GUID_SIZE);\r\n}\r\nif (count == SMB1_CLIENT_GUID_SIZE) {\r\nserver->sec_ntlmssp = true;\r\n} else {\r\ncount -= SMB1_CLIENT_GUID_SIZE;\r\nrc = decode_negTokenInit(\r\npSMBr->u.extended_response.SecurityBlob, count, server);\r\nif (rc != 1)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\ncifs_enable_signing(struct TCP_Server_Info *server, bool mnt_sign_required)\r\n{\r\nbool srv_sign_required = server->sec_mode & server->vals->signing_required;\r\nbool srv_sign_enabled = server->sec_mode & server->vals->signing_enabled;\r\nbool mnt_sign_enabled = global_secflags & CIFSSEC_MAY_SIGN;\r\nif (!mnt_sign_required)\r\nmnt_sign_required = ((global_secflags & CIFSSEC_MUST_SIGN) ==\r\nCIFSSEC_MUST_SIGN);\r\nmnt_sign_enabled = mnt_sign_required ? mnt_sign_required :\r\n(global_secflags & CIFSSEC_MAY_SIGN);\r\nif (srv_sign_required) {\r\nif (!mnt_sign_enabled) {\r\ncifs_dbg(VFS, "Server requires signing, but it's disabled in SecurityFlags!");\r\nreturn -ENOTSUPP;\r\n}\r\nserver->sign = true;\r\n}\r\nif (mnt_sign_required) {\r\nif (!srv_sign_enabled) {\r\ncifs_dbg(VFS, "Server does not support signing!");\r\nreturn -ENOTSUPP;\r\n}\r\nserver->sign = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndecode_lanman_negprot_rsp(struct TCP_Server_Info *server, NEGOTIATE_RSP *pSMBr)\r\n{\r\n__s16 tmp;\r\nstruct lanman_neg_rsp *rsp = (struct lanman_neg_rsp *)pSMBr;\r\nif (server->dialect != LANMAN_PROT && server->dialect != LANMAN2_PROT)\r\nreturn -EOPNOTSUPP;\r\nserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\r\nserver->maxReq = min_t(unsigned int,\r\nle16_to_cpu(rsp->MaxMpxCount),\r\ncifs_max_pending);\r\nset_credits(server, server->maxReq);\r\nserver->maxBuf = le16_to_cpu(rsp->MaxBufSize);\r\nif ((le16_to_cpu(rsp->RawMode) & RAW_ENABLE) == RAW_ENABLE) {\r\nserver->max_rw = 0xFF00;\r\nserver->capabilities = CAP_MPX_MODE | CAP_RAW_MODE;\r\n} else {\r\nserver->max_rw = 0;\r\nserver->capabilities = CAP_MPX_MODE;\r\n}\r\ntmp = (__s16)le16_to_cpu(rsp->ServerTimeZone);\r\nif (tmp == -1) {\r\nint val, seconds, remain, result;\r\nstruct timespec ts, utc;\r\nutc = CURRENT_TIME;\r\nts = cnvrtDosUnixTm(rsp->SrvTime.Date,\r\nrsp->SrvTime.Time, 0);\r\ncifs_dbg(FYI, "SrvTime %d sec since 1970 (utc: %d) diff: %d\n",\r\n(int)ts.tv_sec, (int)utc.tv_sec,\r\n(int)(utc.tv_sec - ts.tv_sec));\r\nval = (int)(utc.tv_sec - ts.tv_sec);\r\nseconds = abs(val);\r\nresult = (seconds / MIN_TZ_ADJ) * MIN_TZ_ADJ;\r\nremain = seconds % MIN_TZ_ADJ;\r\nif (remain >= (MIN_TZ_ADJ / 2))\r\nresult += MIN_TZ_ADJ;\r\nif (val < 0)\r\nresult = -result;\r\nserver->timeAdj = result;\r\n} else {\r\nserver->timeAdj = (int)tmp;\r\nserver->timeAdj *= 60;\r\n}\r\ncifs_dbg(FYI, "server->timeAdj: %d seconds\n", server->timeAdj);\r\nif (rsp->EncryptionKeyLength ==\r\ncpu_to_le16(CIFS_CRYPTO_KEY_SIZE)) {\r\nmemcpy(server->cryptkey, rsp->EncryptionKey,\r\nCIFS_CRYPTO_KEY_SIZE);\r\n} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {\r\nreturn -EIO;\r\n}\r\ncifs_dbg(FYI, "LANMAN negotiated\n");\r\nreturn 0;\r\n}\r\nstatic inline int\r\ndecode_lanman_negprot_rsp(struct TCP_Server_Info *server, NEGOTIATE_RSP *pSMBr)\r\n{\r\ncifs_dbg(VFS, "mount failed, cifs module not built with CIFS_WEAK_PW_HASH support\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic bool\r\nshould_set_ext_sec_flag(enum securityEnum sectype)\r\n{\r\nswitch (sectype) {\r\ncase RawNTLMSSP:\r\ncase Kerberos:\r\nreturn true;\r\ncase Unspecified:\r\nif (global_secflags &\r\n(CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP))\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nint\r\nCIFSSMBNegotiate(const unsigned int xid, struct cifs_ses *ses)\r\n{\r\nNEGOTIATE_REQ *pSMB;\r\nNEGOTIATE_RSP *pSMBr;\r\nint rc = 0;\r\nint bytes_returned;\r\nint i;\r\nstruct TCP_Server_Info *server = ses->server;\r\nu16 count;\r\nif (!server) {\r\nWARN(1, "%s: server is NULL!\n", __func__);\r\nreturn -EIO;\r\n}\r\nrc = smb_init(SMB_COM_NEGOTIATE, 0, NULL ,\r\n(void **) &pSMB, (void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\npSMB->hdr.Mid = get_next_mid(server);\r\npSMB->hdr.Flags2 |= (SMBFLG2_UNICODE | SMBFLG2_ERR_STATUS);\r\nif (should_set_ext_sec_flag(ses->sectype)) {\r\ncifs_dbg(FYI, "Requesting extended security.");\r\npSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\r\n}\r\ncount = 0;\r\nfor (i = 0; i < CIFS_NUM_PROT; i++) {\r\nstrncpy(pSMB->DialectsArray+count, protocols[i].name, 16);\r\ncount += strlen(protocols[i].name) + 1;\r\n}\r\ninc_rfc1001_len(pSMB, count);\r\npSMB->ByteCount = cpu_to_le16(count);\r\nrc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc != 0)\r\ngoto neg_err_exit;\r\nserver->dialect = le16_to_cpu(pSMBr->DialectIndex);\r\ncifs_dbg(FYI, "Dialect: %d\n", server->dialect);\r\nif ((pSMBr->hdr.WordCount < 13) || (server->dialect == BAD_PROT)) {\r\nrc = -EOPNOTSUPP;\r\ngoto neg_err_exit;\r\n} else if (pSMBr->hdr.WordCount == 13) {\r\nserver->negflavor = CIFS_NEGFLAVOR_LANMAN;\r\nrc = decode_lanman_negprot_rsp(server, pSMBr);\r\ngoto signing_check;\r\n} else if (pSMBr->hdr.WordCount != 17) {\r\nrc = -EOPNOTSUPP;\r\ngoto neg_err_exit;\r\n}\r\nserver->sec_mode = pSMBr->SecurityMode;\r\nif ((server->sec_mode & SECMODE_USER) == 0)\r\ncifs_dbg(FYI, "share mode security\n");\r\nserver->maxReq = min_t(unsigned int, le16_to_cpu(pSMBr->MaxMpxCount),\r\ncifs_max_pending);\r\nset_credits(server, server->maxReq);\r\nserver->maxBuf = le32_to_cpu(pSMBr->MaxBufferSize);\r\nserver->max_rw = le32_to_cpu(pSMBr->MaxRawSize);\r\ncifs_dbg(NOISY, "Max buf = %d\n", ses->server->maxBuf);\r\nserver->capabilities = le32_to_cpu(pSMBr->Capabilities);\r\nserver->timeAdj = (int)(__s16)le16_to_cpu(pSMBr->ServerTimeZone);\r\nserver->timeAdj *= 60;\r\nif (pSMBr->EncryptionKeyLength == CIFS_CRYPTO_KEY_SIZE) {\r\nserver->negflavor = CIFS_NEGFLAVOR_UNENCAP;\r\nmemcpy(ses->server->cryptkey, pSMBr->u.EncryptionKey,\r\nCIFS_CRYPTO_KEY_SIZE);\r\n} else if ((pSMBr->hdr.Flags2 & SMBFLG2_EXT_SEC ||\r\nserver->capabilities & CAP_EXTENDED_SECURITY) &&\r\n(pSMBr->EncryptionKeyLength == 0)) {\r\nserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\r\nrc = decode_ext_sec_blob(ses, pSMBr);\r\n} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {\r\nrc = -EIO;\r\n} else {\r\nserver->negflavor = CIFS_NEGFLAVOR_UNENCAP;\r\nserver->capabilities &= ~CAP_EXTENDED_SECURITY;\r\n}\r\nsigning_check:\r\nif (!rc)\r\nrc = cifs_enable_signing(server, ses->sign);\r\nneg_err_exit:\r\ncifs_buf_release(pSMB);\r\ncifs_dbg(FYI, "negprot rc %d\n", rc);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBTDis(const unsigned int xid, struct cifs_tcon *tcon)\r\n{\r\nstruct smb_hdr *smb_buffer;\r\nint rc = 0;\r\ncifs_dbg(FYI, "In tree disconnect\n");\r\nif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\r\nreturn -EIO;\r\nif ((tcon->need_reconnect) || (tcon->ses->need_reconnect))\r\nreturn 0;\r\nrc = small_smb_init(SMB_COM_TREE_DISCONNECT, 0, tcon,\r\n(void **)&smb_buffer);\r\nif (rc)\r\nreturn rc;\r\nrc = SendReceiveNoRsp(xid, tcon->ses, (char *)smb_buffer, 0);\r\nif (rc)\r\ncifs_dbg(FYI, "Tree disconnect failed %d\n", rc);\r\nif (rc == -EAGAIN)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nstatic void\r\ncifs_echo_callback(struct mid_q_entry *mid)\r\n{\r\nstruct TCP_Server_Info *server = mid->callback_data;\r\nDeleteMidQEntry(mid);\r\nadd_credits(server, 1, CIFS_ECHO_OP);\r\n}\r\nint\r\nCIFSSMBEcho(struct TCP_Server_Info *server)\r\n{\r\nECHO_REQ *smb;\r\nint rc = 0;\r\nstruct kvec iov;\r\nstruct smb_rqst rqst = { .rq_iov = &iov,\r\n.rq_nvec = 1 };\r\ncifs_dbg(FYI, "In echo request\n");\r\nrc = small_smb_init(SMB_COM_ECHO, 0, NULL, (void **)&smb);\r\nif (rc)\r\nreturn rc;\r\nsmb->hdr.Tid = 0xffff;\r\nsmb->hdr.WordCount = 1;\r\nput_unaligned_le16(1, &smb->EchoCount);\r\nput_bcc(1, &smb->hdr);\r\nsmb->Data[0] = 'a';\r\ninc_rfc1001_len(smb, 3);\r\niov.iov_base = smb;\r\niov.iov_len = be32_to_cpu(smb->hdr.smb_buf_length) + 4;\r\nrc = cifs_call_async(server, &rqst, NULL, cifs_echo_callback,\r\nserver, CIFS_ASYNC_OP | CIFS_ECHO_OP);\r\nif (rc)\r\ncifs_dbg(FYI, "Echo request failed: %d\n", rc);\r\ncifs_small_buf_release(smb);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBLogoff(const unsigned int xid, struct cifs_ses *ses)\r\n{\r\nLOGOFF_ANDX_REQ *pSMB;\r\nint rc = 0;\r\ncifs_dbg(FYI, "In SMBLogoff for session disconnect\n");\r\nif (!ses || !ses->server)\r\nreturn -EIO;\r\nmutex_lock(&ses->session_mutex);\r\nif (ses->need_reconnect)\r\ngoto session_already_dead;\r\nrc = small_smb_init(SMB_COM_LOGOFF_ANDX, 2, NULL, (void **)&pSMB);\r\nif (rc) {\r\nmutex_unlock(&ses->session_mutex);\r\nreturn rc;\r\n}\r\npSMB->hdr.Mid = get_next_mid(ses->server);\r\nif (ses->server->sign)\r\npSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\r\npSMB->hdr.Uid = ses->Suid;\r\npSMB->AndXCommand = 0xFF;\r\nrc = SendReceiveNoRsp(xid, ses, (char *) pSMB, 0);\r\nsession_already_dead:\r\nmutex_unlock(&ses->session_mutex);\r\nif (rc == -EAGAIN)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nint\r\nCIFSPOSIXDelFile(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *fileName, __u16 type,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nTRANSACTION2_SPI_REQ *pSMB = NULL;\r\nTRANSACTION2_SPI_RSP *pSMBr = NULL;\r\nstruct unlink_psx_rq *pRqD;\r\nint name_len;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\n__u16 params, param_offset, offset, byte_count;\r\ncifs_dbg(FYI, "In POSIX delete\n");\r\nPsxDelete:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\r\nPATH_MAX, nls_codepage, remap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(fileName, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, fileName, name_len);\r\n}\r\nparams = 6 + name_len;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = 0;\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_spi_req,\r\nInformationLevel) - 4;\r\noffset = param_offset + params;\r\npRqD = (struct unlink_psx_rq *)(((char *)&pSMB->hdr.Protocol) + offset);\r\npRqD->type = cpu_to_le16(type);\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\r\nbyte_count = 3 + params + sizeof(struct unlink_psx_rq);\r\npSMB->DataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\r\npSMB->TotalDataCount = cpu_to_le16(sizeof(struct unlink_psx_rq));\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->InformationLevel = cpu_to_le16(SMB_POSIX_UNLINK);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc)\r\ncifs_dbg(FYI, "Posix delete returned %d\n", rc);\r\ncifs_buf_release(pSMB);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_deletes);\r\nif (rc == -EAGAIN)\r\ngoto PsxDelete;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBDelFile(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\r\nstruct cifs_sb_info *cifs_sb)\r\n{\r\nDELETE_FILE_REQ *pSMB = NULL;\r\nDELETE_FILE_RSP *pSMBr = NULL;\r\nint rc = 0;\r\nint bytes_returned;\r\nint name_len;\r\nint remap = cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR;\r\nDelFileRetry:\r\nrc = smb_init(SMB_COM_DELETE, 1, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len = cifsConvertToUTF16((__le16 *) pSMB->fileName, name,\r\nPATH_MAX, cifs_sb->local_nls,\r\nremap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(name, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->fileName, name, name_len);\r\n}\r\npSMB->SearchAttributes =\r\ncpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM);\r\npSMB->BufferFormat = 0x04;\r\ninc_rfc1001_len(pSMB, name_len + 1);\r\npSMB->ByteCount = cpu_to_le16(name_len + 1);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_deletes);\r\nif (rc)\r\ncifs_dbg(FYI, "Error in RMFile = %d\n", rc);\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto DelFileRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBRmDir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\r\nstruct cifs_sb_info *cifs_sb)\r\n{\r\nDELETE_DIRECTORY_REQ *pSMB = NULL;\r\nDELETE_DIRECTORY_RSP *pSMBr = NULL;\r\nint rc = 0;\r\nint bytes_returned;\r\nint name_len;\r\nint remap = cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR;\r\ncifs_dbg(FYI, "In CIFSSMBRmDir\n");\r\nRmDirRetry:\r\nrc = smb_init(SMB_COM_DELETE_DIRECTORY, 0, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len = cifsConvertToUTF16((__le16 *) pSMB->DirName, name,\r\nPATH_MAX, cifs_sb->local_nls,\r\nremap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(name, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->DirName, name, name_len);\r\n}\r\npSMB->BufferFormat = 0x04;\r\ninc_rfc1001_len(pSMB, name_len + 1);\r\npSMB->ByteCount = cpu_to_le16(name_len + 1);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_rmdirs);\r\nif (rc)\r\ncifs_dbg(FYI, "Error in RMDir = %d\n", rc);\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto RmDirRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBMkDir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,\r\nstruct cifs_sb_info *cifs_sb)\r\n{\r\nint rc = 0;\r\nCREATE_DIRECTORY_REQ *pSMB = NULL;\r\nCREATE_DIRECTORY_RSP *pSMBr = NULL;\r\nint bytes_returned;\r\nint name_len;\r\nint remap = cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR;\r\ncifs_dbg(FYI, "In CIFSSMBMkDir\n");\r\nMkDirRetry:\r\nrc = smb_init(SMB_COM_CREATE_DIRECTORY, 0, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len = cifsConvertToUTF16((__le16 *) pSMB->DirName, name,\r\nPATH_MAX, cifs_sb->local_nls,\r\nremap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(name, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->DirName, name, name_len);\r\n}\r\npSMB->BufferFormat = 0x04;\r\ninc_rfc1001_len(pSMB, name_len + 1);\r\npSMB->ByteCount = cpu_to_le16(name_len + 1);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_mkdirs);\r\nif (rc)\r\ncifs_dbg(FYI, "Error in Mkdir = %d\n", rc);\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto MkDirRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSPOSIXCreate(const unsigned int xid, struct cifs_tcon *tcon,\r\n__u32 posix_flags, __u64 mode, __u16 *netfid,\r\nFILE_UNIX_BASIC_INFO *pRetData, __u32 *pOplock,\r\nconst char *name, const struct nls_table *nls_codepage,\r\nint remap)\r\n{\r\nTRANSACTION2_SPI_REQ *pSMB = NULL;\r\nTRANSACTION2_SPI_RSP *pSMBr = NULL;\r\nint name_len;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\n__u16 params, param_offset, offset, byte_count, count;\r\nOPEN_PSX_REQ *pdata;\r\nOPEN_PSX_RSP *psx_rsp;\r\ncifs_dbg(FYI, "In POSIX Create\n");\r\nPsxCreat:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName, name,\r\nPATH_MAX, nls_codepage, remap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(name, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, name, name_len);\r\n}\r\nparams = 6 + name_len;\r\ncount = sizeof(OPEN_PSX_REQ);\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_spi_req,\r\nInformationLevel) - 4;\r\noffset = param_offset + params;\r\npdata = (OPEN_PSX_REQ *)(((char *)&pSMB->hdr.Protocol) + offset);\r\npdata->Level = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\r\npdata->Permissions = cpu_to_le64(mode);\r\npdata->PosixOpenFlags = cpu_to_le32(posix_flags);\r\npdata->OpenFlags = cpu_to_le32(*pOplock);\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\r\nbyte_count = 3 + params + count;\r\npSMB->DataCount = cpu_to_le16(count);\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->InformationLevel = cpu_to_le16(SMB_POSIX_OPEN);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Posix create returned %d\n", rc);\r\ngoto psx_create_err;\r\n}\r\ncifs_dbg(FYI, "copying inode info\n");\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)) {\r\nrc = -EIO;\r\ngoto psx_create_err;\r\n}\r\npsx_rsp = (OPEN_PSX_RSP *)((char *) &pSMBr->hdr.Protocol\r\n+ le16_to_cpu(pSMBr->t2.DataOffset));\r\n*pOplock = le16_to_cpu(psx_rsp->OplockFlags);\r\nif (netfid)\r\n*netfid = psx_rsp->Fid;\r\nif (cpu_to_le32(FILE_CREATE) == psx_rsp->CreateAction)\r\n*pOplock |= CIFS_CREATE_ACTION;\r\nif (psx_rsp->ReturnedLevel != cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC)) {\r\npRetData->Type = cpu_to_le32(-1);\r\ncifs_dbg(NOISY, "unknown type\n");\r\n} else {\r\nif (get_bcc(&pSMBr->hdr) < sizeof(OPEN_PSX_RSP)\r\n+ sizeof(FILE_UNIX_BASIC_INFO)) {\r\ncifs_dbg(VFS, "Open response data too small\n");\r\npRetData->Type = cpu_to_le32(-1);\r\ngoto psx_create_err;\r\n}\r\nmemcpy((char *) pRetData,\r\n(char *)psx_rsp + sizeof(OPEN_PSX_RSP),\r\nsizeof(FILE_UNIX_BASIC_INFO));\r\n}\r\npsx_create_err:\r\ncifs_buf_release(pSMB);\r\nif (posix_flags & SMB_O_DIRECTORY)\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_posixmkdirs);\r\nelse\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_posixopens);\r\nif (rc == -EAGAIN)\r\ngoto PsxCreat;\r\nreturn rc;\r\n}\r\nstatic __u16 convert_disposition(int disposition)\r\n{\r\n__u16 ofun = 0;\r\nswitch (disposition) {\r\ncase FILE_SUPERSEDE:\r\nofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\r\nbreak;\r\ncase FILE_OPEN:\r\nofun = SMBOPEN_OAPPEND;\r\nbreak;\r\ncase FILE_CREATE:\r\nofun = SMBOPEN_OCREATE;\r\nbreak;\r\ncase FILE_OPEN_IF:\r\nofun = SMBOPEN_OCREATE | SMBOPEN_OAPPEND;\r\nbreak;\r\ncase FILE_OVERWRITE:\r\nofun = SMBOPEN_OTRUNC;\r\nbreak;\r\ncase FILE_OVERWRITE_IF:\r\nofun = SMBOPEN_OCREATE | SMBOPEN_OTRUNC;\r\nbreak;\r\ndefault:\r\ncifs_dbg(FYI, "unknown disposition %d\n", disposition);\r\nofun = SMBOPEN_OAPPEND;\r\n}\r\nreturn ofun;\r\n}\r\nstatic int\r\naccess_flags_to_smbopen_mode(const int access_flags)\r\n{\r\nint masked_flags = access_flags & (GENERIC_READ | GENERIC_WRITE);\r\nif (masked_flags == GENERIC_READ)\r\nreturn SMBOPEN_READ;\r\nelse if (masked_flags == GENERIC_WRITE)\r\nreturn SMBOPEN_WRITE;\r\nreturn SMBOPEN_READWRITE;\r\n}\r\nint\r\nSMBLegacyOpen(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *fileName, const int openDisposition,\r\nconst int access_flags, const int create_options, __u16 *netfid,\r\nint *pOplock, FILE_ALL_INFO *pfile_info,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nint rc = -EACCES;\r\nOPENX_REQ *pSMB = NULL;\r\nOPENX_RSP *pSMBr = NULL;\r\nint bytes_returned;\r\nint name_len;\r\n__u16 count;\r\nOldOpenRetry:\r\nrc = smb_init(SMB_COM_OPEN_ANDX, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\npSMB->AndXCommand = 0xFF;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\ncount = 1;\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) (pSMB->fileName + 1),\r\nfileName, PATH_MAX, nls_codepage, remap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\ncount = 0;\r\nname_len = strnlen(fileName, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->fileName, fileName, name_len);\r\n}\r\nif (*pOplock & REQ_OPLOCK)\r\npSMB->OpenFlags = cpu_to_le16(REQ_OPLOCK);\r\nelse if (*pOplock & REQ_BATCHOPLOCK)\r\npSMB->OpenFlags = cpu_to_le16(REQ_BATCHOPLOCK);\r\npSMB->OpenFlags |= cpu_to_le16(REQ_MORE_INFO);\r\npSMB->Mode = cpu_to_le16(access_flags_to_smbopen_mode(access_flags));\r\npSMB->Mode |= cpu_to_le16(0x40);\r\nif (create_options & CREATE_OPTION_SPECIAL)\r\npSMB->FileAttributes = cpu_to_le16(ATTR_SYSTEM);\r\nelse\r\npSMB->FileAttributes = cpu_to_le16(0);\r\nif (create_options & CREATE_OPTION_READONLY)\r\npSMB->FileAttributes |= cpu_to_le16(ATTR_READONLY);\r\npSMB->Sattr = cpu_to_le16(ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY);\r\npSMB->OpenFunction = cpu_to_le16(convert_disposition(openDisposition));\r\ncount += name_len;\r\ninc_rfc1001_len(pSMB, count);\r\npSMB->ByteCount = cpu_to_le16(count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *)pSMBr, &bytes_returned, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\r\nif (rc) {\r\ncifs_dbg(FYI, "Error in Open = %d\n", rc);\r\n} else {\r\n*netfid = pSMBr->Fid;\r\nif (pfile_info) {\r\npfile_info->CreationTime = 0;\r\npfile_info->LastAccessTime = 0;\r\npfile_info->LastWriteTime = 0;\r\npfile_info->ChangeTime = 0;\r\npfile_info->Attributes =\r\ncpu_to_le32(le16_to_cpu(pSMBr->FileAttributes));\r\npfile_info->AllocationSize =\r\ncpu_to_le64(le32_to_cpu(pSMBr->EndOfFile));\r\npfile_info->EndOfFile = pfile_info->AllocationSize;\r\npfile_info->NumberOfLinks = cpu_to_le32(1);\r\npfile_info->DeletePending = 0;\r\n}\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto OldOpenRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\r\nFILE_ALL_INFO *buf)\r\n{\r\nint rc = -EACCES;\r\nOPEN_REQ *req = NULL;\r\nOPEN_RSP *rsp = NULL;\r\nint bytes_returned;\r\nint name_len;\r\n__u16 count;\r\nstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\r\nstruct cifs_tcon *tcon = oparms->tcon;\r\nint remap = cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR;\r\nconst struct nls_table *nls = cifs_sb->local_nls;\r\nint create_options = oparms->create_options;\r\nint desired_access = oparms->desired_access;\r\nint disposition = oparms->disposition;\r\nconst char *path = oparms->path;\r\nopenRetry:\r\nrc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\r\n(void **)&rsp);\r\nif (rc)\r\nreturn rc;\r\nreq->AndXCommand = 0xFF;\r\nif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\r\ncount = 1;\r\nname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\r\npath, PATH_MAX, nls, remap);\r\nname_len++;\r\nname_len *= 2;\r\nreq->NameLength = cpu_to_le16(name_len);\r\n} else {\r\ncount = 0;\r\nname_len = strnlen(path, PATH_MAX);\r\nname_len++;\r\nreq->NameLength = cpu_to_le16(name_len);\r\nstrncpy(req->fileName, path, name_len);\r\n}\r\nif (*oplock & REQ_OPLOCK)\r\nreq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\r\nelse if (*oplock & REQ_BATCHOPLOCK)\r\nreq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\r\nreq->DesiredAccess = cpu_to_le32(desired_access);\r\nreq->AllocationSize = 0;\r\nif (create_options & CREATE_OPTION_SPECIAL)\r\nreq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\r\nelse\r\nreq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\r\nif (tcon->ses->capabilities & CAP_UNIX)\r\nreq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\r\nif (create_options & CREATE_OPTION_READONLY)\r\nreq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\r\nreq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\r\nreq->CreateDisposition = cpu_to_le32(disposition);\r\nreq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\r\nreq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\r\nreq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\r\ncount += name_len;\r\ninc_rfc1001_len(req, count);\r\nreq->ByteCount = cpu_to_le16(count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\r\n(struct smb_hdr *)rsp, &bytes_returned, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\r\nif (rc) {\r\ncifs_dbg(FYI, "Error in Open = %d\n", rc);\r\ncifs_buf_release(req);\r\nif (rc == -EAGAIN)\r\ngoto openRetry;\r\nreturn rc;\r\n}\r\n*oplock = rsp->OplockLevel;\r\noparms->fid->netfid = rsp->Fid;\r\nif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\r\n*oplock |= CIFS_CREATE_ACTION;\r\nif (buf) {\r\nmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\r\nbuf->AllocationSize = rsp->AllocationSize;\r\nbuf->EndOfFile = rsp->EndOfFile;\r\nbuf->NumberOfLinks = cpu_to_le32(1);\r\nbuf->DeletePending = 0;\r\n}\r\ncifs_buf_release(req);\r\nreturn rc;\r\n}\r\nstatic int\r\ncifs_readv_discard(struct TCP_Server_Info *server, struct mid_q_entry *mid)\r\n{\r\nunsigned int rfclen = get_rfc1002_length(server->smallbuf);\r\nint remaining = rfclen + 4 - server->total_read;\r\nstruct cifs_readdata *rdata = mid->callback_data;\r\nwhile (remaining > 0) {\r\nint length;\r\nlength = cifs_read_from_socket(server, server->bigbuf,\r\nmin_t(unsigned int, remaining,\r\nCIFSMaxBufSize + MAX_HEADER_SIZE(server)));\r\nif (length < 0)\r\nreturn length;\r\nserver->total_read += length;\r\nremaining -= length;\r\n}\r\ndequeue_mid(mid, rdata->result);\r\nreturn 0;\r\n}\r\nint\r\ncifs_readv_receive(struct TCP_Server_Info *server, struct mid_q_entry *mid)\r\n{\r\nint length, len;\r\nunsigned int data_offset, data_len;\r\nstruct cifs_readdata *rdata = mid->callback_data;\r\nchar *buf = server->smallbuf;\r\nunsigned int buflen = get_rfc1002_length(buf) + 4;\r\ncifs_dbg(FYI, "%s: mid=%llu offset=%llu bytes=%u\n",\r\n__func__, mid->mid, rdata->offset, rdata->bytes);\r\nlen = min_t(unsigned int, buflen, server->vals->read_rsp_size) -\r\nHEADER_SIZE(server) + 1;\r\nrdata->iov.iov_base = buf + HEADER_SIZE(server) - 1;\r\nrdata->iov.iov_len = len;\r\nlength = cifs_readv_from_socket(server, &rdata->iov, 1, len);\r\nif (length < 0)\r\nreturn length;\r\nserver->total_read += length;\r\nrdata->result = server->ops->map_error(buf, false);\r\nif (rdata->result != 0) {\r\ncifs_dbg(FYI, "%s: server returned error %d\n",\r\n__func__, rdata->result);\r\nreturn cifs_readv_discard(server, mid);\r\n}\r\nif (server->total_read < server->vals->read_rsp_size) {\r\ncifs_dbg(FYI, "%s: server returned short header. got=%u expected=%zu\n",\r\n__func__, server->total_read,\r\nserver->vals->read_rsp_size);\r\nrdata->result = -EIO;\r\nreturn cifs_readv_discard(server, mid);\r\n}\r\ndata_offset = server->ops->read_data_offset(buf) + 4;\r\nif (data_offset < server->total_read) {\r\ncifs_dbg(FYI, "%s: data offset (%u) inside read response header\n",\r\n__func__, data_offset);\r\ndata_offset = server->total_read;\r\n} else if (data_offset > MAX_CIFS_SMALL_BUFFER_SIZE) {\r\ncifs_dbg(FYI, "%s: data offset (%u) beyond end of smallbuf\n",\r\n__func__, data_offset);\r\nrdata->result = -EIO;\r\nreturn cifs_readv_discard(server, mid);\r\n}\r\ncifs_dbg(FYI, "%s: total_read=%u data_offset=%u\n",\r\n__func__, server->total_read, data_offset);\r\nlen = data_offset - server->total_read;\r\nif (len > 0) {\r\nrdata->iov.iov_base = buf + server->total_read;\r\nrdata->iov.iov_len = len;\r\nlength = cifs_readv_from_socket(server, &rdata->iov, 1, len);\r\nif (length < 0)\r\nreturn length;\r\nserver->total_read += length;\r\n}\r\nrdata->iov.iov_base = buf;\r\nrdata->iov.iov_len = server->total_read;\r\ncifs_dbg(FYI, "0: iov_base=%p iov_len=%zu\n",\r\nrdata->iov.iov_base, rdata->iov.iov_len);\r\ndata_len = server->ops->read_data_length(buf);\r\nif (data_offset + data_len > buflen) {\r\nrdata->result = -EIO;\r\nreturn cifs_readv_discard(server, mid);\r\n}\r\nlength = rdata->read_into_pages(server, rdata, data_len);\r\nif (length < 0)\r\nreturn length;\r\nserver->total_read += length;\r\nrdata->bytes = length;\r\ncifs_dbg(FYI, "total_read=%u buflen=%u remaining=%u\n",\r\nserver->total_read, buflen, data_len);\r\nif (server->total_read < buflen)\r\nreturn cifs_readv_discard(server, mid);\r\ndequeue_mid(mid, false);\r\nreturn length;\r\n}\r\nstatic void\r\ncifs_readv_callback(struct mid_q_entry *mid)\r\n{\r\nstruct cifs_readdata *rdata = mid->callback_data;\r\nstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\r\nstruct TCP_Server_Info *server = tcon->ses->server;\r\nstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\r\n.rq_nvec = 1,\r\n.rq_pages = rdata->pages,\r\n.rq_npages = rdata->nr_pages,\r\n.rq_pagesz = rdata->pagesz,\r\n.rq_tailsz = rdata->tailsz };\r\ncifs_dbg(FYI, "%s: mid=%llu state=%d result=%d bytes=%u\n",\r\n__func__, mid->mid, mid->mid_state, rdata->result,\r\nrdata->bytes);\r\nswitch (mid->mid_state) {\r\ncase MID_RESPONSE_RECEIVED:\r\nif (server->sign) {\r\nint rc = 0;\r\nrc = cifs_verify_signature(&rqst, server,\r\nmid->sequence_number);\r\nif (rc)\r\ncifs_dbg(VFS, "SMB signature verification returned error = %d\n",\r\nrc);\r\n}\r\ntask_io_account_read(rdata->bytes);\r\ncifs_stats_bytes_read(tcon, rdata->bytes);\r\nbreak;\r\ncase MID_REQUEST_SUBMITTED:\r\ncase MID_RETRY_NEEDED:\r\nrdata->result = -EAGAIN;\r\nbreak;\r\ndefault:\r\nrdata->result = -EIO;\r\n}\r\nqueue_work(cifsiod_wq, &rdata->work);\r\nDeleteMidQEntry(mid);\r\nadd_credits(server, 1, 0);\r\n}\r\nint\r\ncifs_async_readv(struct cifs_readdata *rdata)\r\n{\r\nint rc;\r\nREAD_REQ *smb = NULL;\r\nint wct;\r\nstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\r\nstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\r\n.rq_nvec = 1 };\r\ncifs_dbg(FYI, "%s: offset=%llu bytes=%u\n",\r\n__func__, rdata->offset, rdata->bytes);\r\nif (tcon->ses->capabilities & CAP_LARGE_FILES)\r\nwct = 12;\r\nelse {\r\nwct = 10;\r\nif ((rdata->offset >> 32) > 0) {\r\nreturn -EIO;\r\n}\r\n}\r\nrc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **)&smb);\r\nif (rc)\r\nreturn rc;\r\nsmb->hdr.Pid = cpu_to_le16((__u16)rdata->pid);\r\nsmb->hdr.PidHigh = cpu_to_le16((__u16)(rdata->pid >> 16));\r\nsmb->AndXCommand = 0xFF;\r\nsmb->Fid = rdata->cfile->fid.netfid;\r\nsmb->OffsetLow = cpu_to_le32(rdata->offset & 0xFFFFFFFF);\r\nif (wct == 12)\r\nsmb->OffsetHigh = cpu_to_le32(rdata->offset >> 32);\r\nsmb->Remaining = 0;\r\nsmb->MaxCount = cpu_to_le16(rdata->bytes & 0xFFFF);\r\nsmb->MaxCountHigh = cpu_to_le32(rdata->bytes >> 16);\r\nif (wct == 12)\r\nsmb->ByteCount = 0;\r\nelse {\r\nstruct smb_com_readx_req *smbr =\r\n(struct smb_com_readx_req *)smb;\r\nsmbr->ByteCount = 0;\r\n}\r\nrdata->iov.iov_base = smb;\r\nrdata->iov.iov_len = be32_to_cpu(smb->hdr.smb_buf_length) + 4;\r\nkref_get(&rdata->refcount);\r\nrc = cifs_call_async(tcon->ses->server, &rqst, cifs_readv_receive,\r\ncifs_readv_callback, rdata, 0);\r\nif (rc == 0)\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_reads);\r\nelse\r\nkref_put(&rdata->refcount, cifs_readdata_release);\r\ncifs_small_buf_release(smb);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBRead(const unsigned int xid, struct cifs_io_parms *io_parms,\r\nunsigned int *nbytes, char **buf, int *pbuf_type)\r\n{\r\nint rc = -EACCES;\r\nREAD_REQ *pSMB = NULL;\r\nREAD_RSP *pSMBr = NULL;\r\nchar *pReadData = NULL;\r\nint wct;\r\nint resp_buf_type = 0;\r\nstruct kvec iov[1];\r\n__u32 pid = io_parms->pid;\r\n__u16 netfid = io_parms->netfid;\r\n__u64 offset = io_parms->offset;\r\nstruct cifs_tcon *tcon = io_parms->tcon;\r\nunsigned int count = io_parms->length;\r\ncifs_dbg(FYI, "Reading %d bytes on fid %d\n", count, netfid);\r\nif (tcon->ses->capabilities & CAP_LARGE_FILES)\r\nwct = 12;\r\nelse {\r\nwct = 10;\r\nif ((offset >> 32) > 0) {\r\nreturn -EIO;\r\n}\r\n}\r\n*nbytes = 0;\r\nrc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **) &pSMB);\r\nif (rc)\r\nreturn rc;\r\npSMB->hdr.Pid = cpu_to_le16((__u16)pid);\r\npSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\r\nif (tcon->ses->server == NULL)\r\nreturn -ECONNABORTED;\r\npSMB->AndXCommand = 0xFF;\r\npSMB->Fid = netfid;\r\npSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\r\nif (wct == 12)\r\npSMB->OffsetHigh = cpu_to_le32(offset >> 32);\r\npSMB->Remaining = 0;\r\npSMB->MaxCount = cpu_to_le16(count & 0xFFFF);\r\npSMB->MaxCountHigh = cpu_to_le32(count >> 16);\r\nif (wct == 12)\r\npSMB->ByteCount = 0;\r\nelse {\r\nstruct smb_com_readx_req *pSMBW =\r\n(struct smb_com_readx_req *)pSMB;\r\npSMBW->ByteCount = 0;\r\n}\r\niov[0].iov_base = (char *)pSMB;\r\niov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\r\nrc = SendReceive2(xid, tcon->ses, iov, 1 ,\r\n&resp_buf_type, CIFS_LOG_ERROR);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_reads);\r\npSMBr = (READ_RSP *)iov[0].iov_base;\r\nif (rc) {\r\ncifs_dbg(VFS, "Send error in read = %d\n", rc);\r\n} else {\r\nint data_length = le16_to_cpu(pSMBr->DataLengthHigh);\r\ndata_length = data_length << 16;\r\ndata_length += le16_to_cpu(pSMBr->DataLength);\r\n*nbytes = data_length;\r\nif ((data_length > CIFSMaxBufSize)\r\n|| (data_length > count)) {\r\ncifs_dbg(FYI, "bad length %d for count %d\n",\r\ndata_length, count);\r\nrc = -EIO;\r\n*nbytes = 0;\r\n} else {\r\npReadData = (char *) (&pSMBr->hdr.Protocol) +\r\nle16_to_cpu(pSMBr->DataOffset);\r\nif (*buf)\r\nmemcpy(*buf, pReadData, data_length);\r\n}\r\n}\r\nif (*buf) {\r\nif (resp_buf_type == CIFS_SMALL_BUFFER)\r\ncifs_small_buf_release(iov[0].iov_base);\r\nelse if (resp_buf_type == CIFS_LARGE_BUFFER)\r\ncifs_buf_release(iov[0].iov_base);\r\n} else if (resp_buf_type != CIFS_NO_BUFFER) {\r\n*buf = iov[0].iov_base;\r\nif (resp_buf_type == CIFS_SMALL_BUFFER)\r\n*pbuf_type = CIFS_SMALL_BUFFER;\r\nelse if (resp_buf_type == CIFS_LARGE_BUFFER)\r\n*pbuf_type = CIFS_LARGE_BUFFER;\r\n}\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBWrite(const unsigned int xid, struct cifs_io_parms *io_parms,\r\nunsigned int *nbytes, const char *buf,\r\nconst char __user *ubuf, const int long_op)\r\n{\r\nint rc = -EACCES;\r\nWRITE_REQ *pSMB = NULL;\r\nWRITE_RSP *pSMBr = NULL;\r\nint bytes_returned, wct;\r\n__u32 bytes_sent;\r\n__u16 byte_count;\r\n__u32 pid = io_parms->pid;\r\n__u16 netfid = io_parms->netfid;\r\n__u64 offset = io_parms->offset;\r\nstruct cifs_tcon *tcon = io_parms->tcon;\r\nunsigned int count = io_parms->length;\r\n*nbytes = 0;\r\nif (tcon->ses == NULL)\r\nreturn -ECONNABORTED;\r\nif (tcon->ses->capabilities & CAP_LARGE_FILES)\r\nwct = 14;\r\nelse {\r\nwct = 12;\r\nif ((offset >> 32) > 0) {\r\nreturn -EIO;\r\n}\r\n}\r\nrc = smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\npSMB->hdr.Pid = cpu_to_le16((__u16)pid);\r\npSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\r\nif (tcon->ses->server == NULL)\r\nreturn -ECONNABORTED;\r\npSMB->AndXCommand = 0xFF;\r\npSMB->Fid = netfid;\r\npSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\r\nif (wct == 14)\r\npSMB->OffsetHigh = cpu_to_le32(offset >> 32);\r\npSMB->Reserved = 0xFFFFFFFF;\r\npSMB->WriteMode = 0;\r\npSMB->Remaining = 0;\r\nif (tcon->ses->capabilities & CAP_LARGE_WRITE_X) {\r\nbytes_sent = min_t(const unsigned int, CIFSMaxBufSize, count);\r\n} else {\r\nbytes_sent = (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE)\r\n& ~0xFF;\r\n}\r\nif (bytes_sent > count)\r\nbytes_sent = count;\r\npSMB->DataOffset =\r\ncpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\r\nif (buf)\r\nmemcpy(pSMB->Data, buf, bytes_sent);\r\nelse if (ubuf) {\r\nif (copy_from_user(pSMB->Data, ubuf, bytes_sent)) {\r\ncifs_buf_release(pSMB);\r\nreturn -EFAULT;\r\n}\r\n} else if (count != 0) {\r\ncifs_buf_release(pSMB);\r\nreturn -EINVAL;\r\n}\r\nif (wct == 14)\r\nbyte_count = bytes_sent + 1;\r\nelse\r\nbyte_count = bytes_sent + 5;\r\npSMB->DataLengthLow = cpu_to_le16(bytes_sent & 0xFFFF);\r\npSMB->DataLengthHigh = cpu_to_le16(bytes_sent >> 16);\r\ninc_rfc1001_len(pSMB, byte_count);\r\nif (wct == 14)\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nelse {\r\nstruct smb_com_writex_req *pSMBW =\r\n(struct smb_com_writex_req *)pSMB;\r\npSMBW->ByteCount = cpu_to_le16(byte_count);\r\n}\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, long_op);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in write = %d\n", rc);\r\n} else {\r\n*nbytes = le16_to_cpu(pSMBr->CountHigh);\r\n*nbytes = (*nbytes) << 16;\r\n*nbytes += le16_to_cpu(pSMBr->Count);\r\nif (*nbytes > count)\r\n*nbytes &= 0xFFFF;\r\n}\r\ncifs_buf_release(pSMB);\r\nreturn rc;\r\n}\r\nvoid\r\ncifs_writedata_release(struct kref *refcount)\r\n{\r\nstruct cifs_writedata *wdata = container_of(refcount,\r\nstruct cifs_writedata, refcount);\r\nif (wdata->cfile)\r\ncifsFileInfo_put(wdata->cfile);\r\nkfree(wdata);\r\n}\r\nstatic void\r\ncifs_writev_requeue(struct cifs_writedata *wdata)\r\n{\r\nint i, rc;\r\nstruct inode *inode = wdata->cfile->dentry->d_inode;\r\nstruct TCP_Server_Info *server;\r\nfor (i = 0; i < wdata->nr_pages; i++) {\r\nlock_page(wdata->pages[i]);\r\nclear_page_dirty_for_io(wdata->pages[i]);\r\n}\r\ndo {\r\nserver = tlink_tcon(wdata->cfile->tlink)->ses->server;\r\nrc = server->ops->async_writev(wdata, cifs_writedata_release);\r\n} while (rc == -EAGAIN);\r\nfor (i = 0; i < wdata->nr_pages; i++) {\r\nunlock_page(wdata->pages[i]);\r\nif (rc != 0) {\r\nSetPageError(wdata->pages[i]);\r\nend_page_writeback(wdata->pages[i]);\r\npage_cache_release(wdata->pages[i]);\r\n}\r\n}\r\nmapping_set_error(inode->i_mapping, rc);\r\nkref_put(&wdata->refcount, cifs_writedata_release);\r\n}\r\nvoid\r\ncifs_writev_complete(struct work_struct *work)\r\n{\r\nstruct cifs_writedata *wdata = container_of(work,\r\nstruct cifs_writedata, work);\r\nstruct inode *inode = wdata->cfile->dentry->d_inode;\r\nint i = 0;\r\nif (wdata->result == 0) {\r\nspin_lock(&inode->i_lock);\r\ncifs_update_eof(CIFS_I(inode), wdata->offset, wdata->bytes);\r\nspin_unlock(&inode->i_lock);\r\ncifs_stats_bytes_written(tlink_tcon(wdata->cfile->tlink),\r\nwdata->bytes);\r\n} else if (wdata->sync_mode == WB_SYNC_ALL && wdata->result == -EAGAIN)\r\nreturn cifs_writev_requeue(wdata);\r\nfor (i = 0; i < wdata->nr_pages; i++) {\r\nstruct page *page = wdata->pages[i];\r\nif (wdata->result == -EAGAIN)\r\n__set_page_dirty_nobuffers(page);\r\nelse if (wdata->result < 0)\r\nSetPageError(page);\r\nend_page_writeback(page);\r\npage_cache_release(page);\r\n}\r\nif (wdata->result != -EAGAIN)\r\nmapping_set_error(inode->i_mapping, wdata->result);\r\nkref_put(&wdata->refcount, cifs_writedata_release);\r\n}\r\nstruct cifs_writedata *\r\ncifs_writedata_alloc(unsigned int nr_pages, work_func_t complete)\r\n{\r\nstruct cifs_writedata *wdata;\r\nwdata = kzalloc(sizeof(*wdata) +\r\nsizeof(struct page *) * nr_pages, GFP_NOFS);\r\nif (wdata != NULL) {\r\nkref_init(&wdata->refcount);\r\nINIT_LIST_HEAD(&wdata->list);\r\ninit_completion(&wdata->done);\r\nINIT_WORK(&wdata->work, complete);\r\n}\r\nreturn wdata;\r\n}\r\nstatic void\r\ncifs_writev_callback(struct mid_q_entry *mid)\r\n{\r\nstruct cifs_writedata *wdata = mid->callback_data;\r\nstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\r\nunsigned int written;\r\nWRITE_RSP *smb = (WRITE_RSP *)mid->resp_buf;\r\nswitch (mid->mid_state) {\r\ncase MID_RESPONSE_RECEIVED:\r\nwdata->result = cifs_check_receive(mid, tcon->ses->server, 0);\r\nif (wdata->result != 0)\r\nbreak;\r\nwritten = le16_to_cpu(smb->CountHigh);\r\nwritten <<= 16;\r\nwritten += le16_to_cpu(smb->Count);\r\nif (written > wdata->bytes)\r\nwritten &= 0xFFFF;\r\nif (written < wdata->bytes)\r\nwdata->result = -ENOSPC;\r\nelse\r\nwdata->bytes = written;\r\nbreak;\r\ncase MID_REQUEST_SUBMITTED:\r\ncase MID_RETRY_NEEDED:\r\nwdata->result = -EAGAIN;\r\nbreak;\r\ndefault:\r\nwdata->result = -EIO;\r\nbreak;\r\n}\r\nqueue_work(cifsiod_wq, &wdata->work);\r\nDeleteMidQEntry(mid);\r\nadd_credits(tcon->ses->server, 1, 0);\r\n}\r\nint\r\ncifs_async_writev(struct cifs_writedata *wdata,\r\nvoid (*release)(struct kref *kref))\r\n{\r\nint rc = -EACCES;\r\nWRITE_REQ *smb = NULL;\r\nint wct;\r\nstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\r\nstruct kvec iov;\r\nstruct smb_rqst rqst = { };\r\nif (tcon->ses->capabilities & CAP_LARGE_FILES) {\r\nwct = 14;\r\n} else {\r\nwct = 12;\r\nif (wdata->offset >> 32 > 0) {\r\nreturn -EIO;\r\n}\r\n}\r\nrc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **)&smb);\r\nif (rc)\r\ngoto async_writev_out;\r\nsmb->hdr.Pid = cpu_to_le16((__u16)wdata->pid);\r\nsmb->hdr.PidHigh = cpu_to_le16((__u16)(wdata->pid >> 16));\r\nsmb->AndXCommand = 0xFF;\r\nsmb->Fid = wdata->cfile->fid.netfid;\r\nsmb->OffsetLow = cpu_to_le32(wdata->offset & 0xFFFFFFFF);\r\nif (wct == 14)\r\nsmb->OffsetHigh = cpu_to_le32(wdata->offset >> 32);\r\nsmb->Reserved = 0xFFFFFFFF;\r\nsmb->WriteMode = 0;\r\nsmb->Remaining = 0;\r\nsmb->DataOffset =\r\ncpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\r\niov.iov_len = be32_to_cpu(smb->hdr.smb_buf_length) + 4 + 1;\r\niov.iov_base = smb;\r\nrqst.rq_iov = &iov;\r\nrqst.rq_nvec = 1;\r\nrqst.rq_pages = wdata->pages;\r\nrqst.rq_npages = wdata->nr_pages;\r\nrqst.rq_pagesz = wdata->pagesz;\r\nrqst.rq_tailsz = wdata->tailsz;\r\ncifs_dbg(FYI, "async write at %llu %u bytes\n",\r\nwdata->offset, wdata->bytes);\r\nsmb->DataLengthLow = cpu_to_le16(wdata->bytes & 0xFFFF);\r\nsmb->DataLengthHigh = cpu_to_le16(wdata->bytes >> 16);\r\nif (wct == 14) {\r\ninc_rfc1001_len(&smb->hdr, wdata->bytes + 1);\r\nput_bcc(wdata->bytes + 1, &smb->hdr);\r\n} else {\r\nstruct smb_com_writex_req *smbw =\r\n(struct smb_com_writex_req *)smb;\r\ninc_rfc1001_len(&smbw->hdr, wdata->bytes + 5);\r\nput_bcc(wdata->bytes + 5, &smbw->hdr);\r\niov.iov_len += 4;\r\n}\r\nkref_get(&wdata->refcount);\r\nrc = cifs_call_async(tcon->ses->server, &rqst, NULL,\r\ncifs_writev_callback, wdata, 0);\r\nif (rc == 0)\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\r\nelse\r\nkref_put(&wdata->refcount, release);\r\nasync_writev_out:\r\ncifs_small_buf_release(smb);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBWrite2(const unsigned int xid, struct cifs_io_parms *io_parms,\r\nunsigned int *nbytes, struct kvec *iov, int n_vec)\r\n{\r\nint rc = -EACCES;\r\nWRITE_REQ *pSMB = NULL;\r\nint wct;\r\nint smb_hdr_len;\r\nint resp_buf_type = 0;\r\n__u32 pid = io_parms->pid;\r\n__u16 netfid = io_parms->netfid;\r\n__u64 offset = io_parms->offset;\r\nstruct cifs_tcon *tcon = io_parms->tcon;\r\nunsigned int count = io_parms->length;\r\n*nbytes = 0;\r\ncifs_dbg(FYI, "write2 at %lld %d bytes\n", (long long)offset, count);\r\nif (tcon->ses->capabilities & CAP_LARGE_FILES) {\r\nwct = 14;\r\n} else {\r\nwct = 12;\r\nif ((offset >> 32) > 0) {\r\nreturn -EIO;\r\n}\r\n}\r\nrc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB);\r\nif (rc)\r\nreturn rc;\r\npSMB->hdr.Pid = cpu_to_le16((__u16)pid);\r\npSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\r\nif (tcon->ses->server == NULL)\r\nreturn -ECONNABORTED;\r\npSMB->AndXCommand = 0xFF;\r\npSMB->Fid = netfid;\r\npSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\r\nif (wct == 14)\r\npSMB->OffsetHigh = cpu_to_le32(offset >> 32);\r\npSMB->Reserved = 0xFFFFFFFF;\r\npSMB->WriteMode = 0;\r\npSMB->Remaining = 0;\r\npSMB->DataOffset =\r\ncpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\r\npSMB->DataLengthLow = cpu_to_le16(count & 0xFFFF);\r\npSMB->DataLengthHigh = cpu_to_le16(count >> 16);\r\nsmb_hdr_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 1;\r\nif (wct == 14)\r\ninc_rfc1001_len(pSMB, count + 1);\r\nelse\r\ninc_rfc1001_len(pSMB, count + 5);\r\nif (wct == 14)\r\npSMB->ByteCount = cpu_to_le16(count + 1);\r\nelse {\r\nstruct smb_com_writex_req *pSMBW =\r\n(struct smb_com_writex_req *)pSMB;\r\npSMBW->ByteCount = cpu_to_le16(count + 5);\r\n}\r\niov[0].iov_base = pSMB;\r\nif (wct == 14)\r\niov[0].iov_len = smb_hdr_len + 4;\r\nelse\r\niov[0].iov_len = smb_hdr_len + 8;\r\nrc = SendReceive2(xid, tcon->ses, iov, n_vec + 1, &resp_buf_type, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error Write2 = %d\n", rc);\r\n} else if (resp_buf_type == 0) {\r\nrc = -EIO;\r\n} else {\r\nWRITE_RSP *pSMBr = (WRITE_RSP *)iov[0].iov_base;\r\n*nbytes = le16_to_cpu(pSMBr->CountHigh);\r\n*nbytes = (*nbytes) << 16;\r\n*nbytes += le16_to_cpu(pSMBr->Count);\r\nif (*nbytes > count)\r\n*nbytes &= 0xFFFF;\r\n}\r\nif (resp_buf_type == CIFS_SMALL_BUFFER)\r\ncifs_small_buf_release(iov[0].iov_base);\r\nelse if (resp_buf_type == CIFS_LARGE_BUFFER)\r\ncifs_buf_release(iov[0].iov_base);\r\nreturn rc;\r\n}\r\nint cifs_lockv(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst __u16 netfid, const __u8 lock_type, const __u32 num_unlock,\r\nconst __u32 num_lock, LOCKING_ANDX_RANGE *buf)\r\n{\r\nint rc = 0;\r\nLOCK_REQ *pSMB = NULL;\r\nstruct kvec iov[2];\r\nint resp_buf_type;\r\n__u16 count;\r\ncifs_dbg(FYI, "cifs_lockv num lock %d num unlock %d\n",\r\nnum_lock, num_unlock);\r\nrc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\r\nif (rc)\r\nreturn rc;\r\npSMB->Timeout = 0;\r\npSMB->NumberOfLocks = cpu_to_le16(num_lock);\r\npSMB->NumberOfUnlocks = cpu_to_le16(num_unlock);\r\npSMB->LockType = lock_type;\r\npSMB->AndXCommand = 0xFF;\r\npSMB->Fid = netfid;\r\ncount = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\r\ninc_rfc1001_len(pSMB, count);\r\npSMB->ByteCount = cpu_to_le16(count);\r\niov[0].iov_base = (char *)pSMB;\r\niov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4 -\r\n(num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\r\niov[1].iov_base = (char *)buf;\r\niov[1].iov_len = (num_unlock + num_lock) * sizeof(LOCKING_ANDX_RANGE);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\r\nrc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\r\nif (rc)\r\ncifs_dbg(FYI, "Send error in cifs_lockv = %d\n", rc);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBLock(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst __u16 smb_file_id, const __u32 netpid, const __u64 len,\r\nconst __u64 offset, const __u32 numUnlock,\r\nconst __u32 numLock, const __u8 lockType,\r\nconst bool waitFlag, const __u8 oplock_level)\r\n{\r\nint rc = 0;\r\nLOCK_REQ *pSMB = NULL;\r\nint bytes_returned;\r\nint flags = 0;\r\n__u16 count;\r\ncifs_dbg(FYI, "CIFSSMBLock timeout %d numLock %d\n",\r\n(int)waitFlag, numLock);\r\nrc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\r\nif (rc)\r\nreturn rc;\r\nif (lockType == LOCKING_ANDX_OPLOCK_RELEASE) {\r\nflags = CIFS_ASYNC_OP | CIFS_OBREAK_OP;\r\npSMB->Timeout = 0;\r\n} else if (waitFlag) {\r\nflags = CIFS_BLOCKING_OP;\r\npSMB->Timeout = cpu_to_le32(-1);\r\n} else {\r\npSMB->Timeout = 0;\r\n}\r\npSMB->NumberOfLocks = cpu_to_le16(numLock);\r\npSMB->NumberOfUnlocks = cpu_to_le16(numUnlock);\r\npSMB->LockType = lockType;\r\npSMB->OplockLevel = oplock_level;\r\npSMB->AndXCommand = 0xFF;\r\npSMB->Fid = smb_file_id;\r\nif ((numLock != 0) || (numUnlock != 0)) {\r\npSMB->Locks[0].Pid = cpu_to_le16(netpid);\r\npSMB->Locks[0].LengthLow = cpu_to_le32((u32)len);\r\npSMB->Locks[0].LengthHigh = cpu_to_le32((u32)(len>>32));\r\npSMB->Locks[0].OffsetLow = cpu_to_le32((u32)offset);\r\npSMB->Locks[0].OffsetHigh = cpu_to_le32((u32)(offset>>32));\r\ncount = sizeof(LOCKING_ANDX_RANGE);\r\n} else {\r\ncount = 0;\r\n}\r\ninc_rfc1001_len(pSMB, count);\r\npSMB->ByteCount = cpu_to_le16(count);\r\nif (waitFlag) {\r\nrc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMB, &bytes_returned);\r\ncifs_small_buf_release(pSMB);\r\n} else {\r\nrc = SendReceiveNoRsp(xid, tcon->ses, (char *)pSMB, flags);\r\n}\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\r\nif (rc)\r\ncifs_dbg(FYI, "Send error in Lock = %d\n", rc);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBPosixLock(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst __u16 smb_file_id, const __u32 netpid,\r\nconst loff_t start_offset, const __u64 len,\r\nstruct file_lock *pLockData, const __u16 lock_type,\r\nconst bool waitFlag)\r\n{\r\nstruct smb_com_transaction2_sfi_req *pSMB = NULL;\r\nstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\r\nstruct cifs_posix_lock *parm_data;\r\nint rc = 0;\r\nint timeout = 0;\r\nint bytes_returned = 0;\r\nint resp_buf_type = 0;\r\n__u16 params, param_offset, offset, byte_count, count;\r\nstruct kvec iov[1];\r\ncifs_dbg(FYI, "Posix Lock\n");\r\nrc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\r\nif (rc)\r\nreturn rc;\r\npSMBr = (struct smb_com_transaction2_sfi_rsp *)pSMB;\r\nparams = 6;\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\r\noffset = param_offset + params;\r\ncount = sizeof(struct cifs_posix_lock);\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\nif (pLockData)\r\npSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\r\nelse\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\r\nbyte_count = 3 + params + count;\r\npSMB->DataCount = cpu_to_le16(count);\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\nparm_data = (struct cifs_posix_lock *)\r\n(((char *) &pSMB->hdr.Protocol) + offset);\r\nparm_data->lock_type = cpu_to_le16(lock_type);\r\nif (waitFlag) {\r\ntimeout = CIFS_BLOCKING_OP;\r\nparm_data->lock_flags = cpu_to_le16(1);\r\npSMB->Timeout = cpu_to_le32(-1);\r\n} else\r\npSMB->Timeout = 0;\r\nparm_data->pid = cpu_to_le32(netpid);\r\nparm_data->start = cpu_to_le64(start_offset);\r\nparm_data->length = cpu_to_le64(len);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->Fid = smb_file_id;\r\npSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_LOCK);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nif (waitFlag) {\r\nrc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned);\r\n} else {\r\niov[0].iov_base = (char *)pSMB;\r\niov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\r\nrc = SendReceive2(xid, tcon->ses, iov, 1 ,\r\n&resp_buf_type, timeout);\r\npSMB = NULL;\r\npSMBr = (struct smb_com_transaction2_sfi_rsp *)iov[0].iov_base;\r\n}\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in Posix Lock = %d\n", rc);\r\n} else if (pLockData) {\r\n__u16 data_offset;\r\n__u16 data_count;\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < sizeof(*parm_data)) {\r\nrc = -EIO;\r\ngoto plk_err_exit;\r\n}\r\ndata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\ndata_count = le16_to_cpu(pSMBr->t2.DataCount);\r\nif (data_count < sizeof(struct cifs_posix_lock)) {\r\nrc = -EIO;\r\ngoto plk_err_exit;\r\n}\r\nparm_data = (struct cifs_posix_lock *)\r\n((char *)&pSMBr->hdr.Protocol + data_offset);\r\nif (parm_data->lock_type == __constant_cpu_to_le16(CIFS_UNLCK))\r\npLockData->fl_type = F_UNLCK;\r\nelse {\r\nif (parm_data->lock_type ==\r\n__constant_cpu_to_le16(CIFS_RDLCK))\r\npLockData->fl_type = F_RDLCK;\r\nelse if (parm_data->lock_type ==\r\n__constant_cpu_to_le16(CIFS_WRLCK))\r\npLockData->fl_type = F_WRLCK;\r\npLockData->fl_start = le64_to_cpu(parm_data->start);\r\npLockData->fl_end = pLockData->fl_start +\r\nle64_to_cpu(parm_data->length) - 1;\r\npLockData->fl_pid = le32_to_cpu(parm_data->pid);\r\n}\r\n}\r\nplk_err_exit:\r\nif (pSMB)\r\ncifs_small_buf_release(pSMB);\r\nif (resp_buf_type == CIFS_SMALL_BUFFER)\r\ncifs_small_buf_release(iov[0].iov_base);\r\nelse if (resp_buf_type == CIFS_LARGE_BUFFER)\r\ncifs_buf_release(iov[0].iov_base);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\r\n{\r\nint rc = 0;\r\nCLOSE_REQ *pSMB = NULL;\r\ncifs_dbg(FYI, "In CIFSSMBClose\n");\r\nrc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\r\nif (rc == -EAGAIN)\r\nreturn 0;\r\nif (rc)\r\nreturn rc;\r\npSMB->FileID = (__u16) smb_file_id;\r\npSMB->LastWriteTime = 0xFFFFFFFF;\r\npSMB->ByteCount = 0;\r\nrc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\r\nif (rc) {\r\nif (rc != -EINTR) {\r\ncifs_dbg(VFS, "Send error in Close = %d\n", rc);\r\n}\r\n}\r\nif (rc == -EAGAIN)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBFlush(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\r\n{\r\nint rc = 0;\r\nFLUSH_REQ *pSMB = NULL;\r\ncifs_dbg(FYI, "In CIFSSMBFlush\n");\r\nrc = small_smb_init(SMB_COM_FLUSH, 1, tcon, (void **) &pSMB);\r\nif (rc)\r\nreturn rc;\r\npSMB->FileID = (__u16) smb_file_id;\r\npSMB->ByteCount = 0;\r\nrc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_flushes);\r\nif (rc)\r\ncifs_dbg(VFS, "Send error in Flush = %d\n", rc);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBRename(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *from_name, const char *to_name,\r\nstruct cifs_sb_info *cifs_sb)\r\n{\r\nint rc = 0;\r\nRENAME_REQ *pSMB = NULL;\r\nRENAME_RSP *pSMBr = NULL;\r\nint bytes_returned;\r\nint name_len, name_len2;\r\n__u16 count;\r\nint remap = cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR;\r\ncifs_dbg(FYI, "In CIFSSMBRename\n");\r\nrenameRetry:\r\nrc = smb_init(SMB_COM_RENAME, 1, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\npSMB->BufferFormat = 0x04;\r\npSMB->SearchAttributes =\r\ncpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\r\nATTR_DIRECTORY);\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len = cifsConvertToUTF16((__le16 *) pSMB->OldFileName,\r\nfrom_name, PATH_MAX,\r\ncifs_sb->local_nls, remap);\r\nname_len++;\r\nname_len *= 2;\r\npSMB->OldFileName[name_len] = 0x04;\r\npSMB->OldFileName[name_len + 1] = 0x00;\r\nname_len2 =\r\ncifsConvertToUTF16((__le16 *)&pSMB->OldFileName[name_len+2],\r\nto_name, PATH_MAX, cifs_sb->local_nls,\r\nremap);\r\nname_len2 += 1 + 1 ;\r\nname_len2 *= 2;\r\n} else {\r\nname_len = strnlen(from_name, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->OldFileName, from_name, name_len);\r\nname_len2 = strnlen(to_name, PATH_MAX);\r\nname_len2++;\r\npSMB->OldFileName[name_len] = 0x04;\r\nstrncpy(&pSMB->OldFileName[name_len + 1], to_name, name_len2);\r\nname_len2++;\r\nname_len2++;\r\n}\r\ncount = 1 + name_len + name_len2;\r\ninc_rfc1001_len(pSMB, count);\r\npSMB->ByteCount = cpu_to_le16(count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_renames);\r\nif (rc)\r\ncifs_dbg(FYI, "Send error in rename = %d\n", rc);\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto renameRetry;\r\nreturn rc;\r\n}\r\nint CIFSSMBRenameOpenFile(const unsigned int xid, struct cifs_tcon *pTcon,\r\nint netfid, const char *target_name,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nstruct smb_com_transaction2_sfi_req *pSMB = NULL;\r\nstruct smb_com_transaction2_sfi_rsp *pSMBr = NULL;\r\nstruct set_file_rename *rename_info;\r\nchar *data_offset;\r\nchar dummy_string[30];\r\nint rc = 0;\r\nint bytes_returned = 0;\r\nint len_of_str;\r\n__u16 params, param_offset, offset, count, byte_count;\r\ncifs_dbg(FYI, "Rename to File by handle\n");\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, pTcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nparams = 6;\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\r\noffset = param_offset + params;\r\ndata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\r\nrename_info = (struct set_file_rename *) data_offset;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\r\nbyte_count = 3 + params;\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\nrename_info->overwrite = cpu_to_le32(1);\r\nrename_info->root_fid = 0;\r\nif (target_name == NULL) {\r\nsprintf(dummy_string, "cifs%x", pSMB->hdr.Mid);\r\nlen_of_str =\r\ncifsConvertToUTF16((__le16 *)rename_info->target_name,\r\ndummy_string, 24, nls_codepage, remap);\r\n} else {\r\nlen_of_str =\r\ncifsConvertToUTF16((__le16 *)rename_info->target_name,\r\ntarget_name, PATH_MAX, nls_codepage,\r\nremap);\r\n}\r\nrename_info->target_name_len = cpu_to_le32(2 * len_of_str);\r\ncount = 12 + (2 * len_of_str);\r\nbyte_count += count;\r\npSMB->DataCount = cpu_to_le16(count);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->Fid = netfid;\r\npSMB->InformationLevel =\r\ncpu_to_le16(SMB_SET_FILE_RENAME_INFORMATION);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, pTcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\ncifs_stats_inc(&pTcon->stats.cifs_stats.num_t2renames);\r\nif (rc)\r\ncifs_dbg(FYI, "Send error in Rename (by file handle) = %d\n",\r\nrc);\r\ncifs_buf_release(pSMB);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBCopy(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *fromName, const __u16 target_tid, const char *toName,\r\nconst int flags, const struct nls_table *nls_codepage, int remap)\r\n{\r\nint rc = 0;\r\nCOPY_REQ *pSMB = NULL;\r\nCOPY_RSP *pSMBr = NULL;\r\nint bytes_returned;\r\nint name_len, name_len2;\r\n__u16 count;\r\ncifs_dbg(FYI, "In CIFSSMBCopy\n");\r\ncopyRetry:\r\nrc = smb_init(SMB_COM_COPY, 1, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\npSMB->BufferFormat = 0x04;\r\npSMB->Tid2 = target_tid;\r\npSMB->Flags = cpu_to_le16(flags & COPY_TREE);\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len = cifsConvertToUTF16((__le16 *) pSMB->OldFileName,\r\nfromName, PATH_MAX, nls_codepage,\r\nremap);\r\nname_len++;\r\nname_len *= 2;\r\npSMB->OldFileName[name_len] = 0x04;\r\npSMB->OldFileName[name_len + 1] = 0x00;\r\nname_len2 =\r\ncifsConvertToUTF16((__le16 *)&pSMB->OldFileName[name_len+2],\r\ntoName, PATH_MAX, nls_codepage, remap);\r\nname_len2 += 1 + 1 ;\r\nname_len2 *= 2;\r\n} else {\r\nname_len = strnlen(fromName, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->OldFileName, fromName, name_len);\r\nname_len2 = strnlen(toName, PATH_MAX);\r\nname_len2++;\r\npSMB->OldFileName[name_len] = 0x04;\r\nstrncpy(&pSMB->OldFileName[name_len + 1], toName, name_len2);\r\nname_len2++;\r\nname_len2++;\r\n}\r\ncount = 1 + name_len + name_len2;\r\ninc_rfc1001_len(pSMB, count);\r\npSMB->ByteCount = cpu_to_le16(count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in copy = %d with %d files copied\n",\r\nrc, le16_to_cpu(pSMBr->CopyCount));\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto copyRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSUnixCreateSymLink(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *fromName, const char *toName,\r\nconst struct nls_table *nls_codepage)\r\n{\r\nTRANSACTION2_SPI_REQ *pSMB = NULL;\r\nTRANSACTION2_SPI_RSP *pSMBr = NULL;\r\nchar *data_offset;\r\nint name_len;\r\nint name_len_target;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\n__u16 params, param_offset, offset, byte_count;\r\ncifs_dbg(FYI, "In Symlink Unix style\n");\r\ncreateSymLinkRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifs_strtoUTF16((__le16 *) pSMB->FileName, fromName,\r\nPATH_MAX, nls_codepage);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(fromName, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, fromName, name_len);\r\n}\r\nparams = 6 + name_len;\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_spi_req,\r\nInformationLevel) - 4;\r\noffset = param_offset + params;\r\ndata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len_target =\r\ncifs_strtoUTF16((__le16 *) data_offset, toName, PATH_MAX\r\n, nls_codepage);\r\nname_len_target++;\r\nname_len_target *= 2;\r\n} else {\r\nname_len_target = strnlen(toName, PATH_MAX);\r\nname_len_target++;\r\nstrncpy(data_offset, toName, name_len_target);\r\n}\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\r\nbyte_count = 3 + params + name_len_target;\r\npSMB->DataCount = cpu_to_le16(name_len_target);\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_LINK);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_symlinks);\r\nif (rc)\r\ncifs_dbg(FYI, "Send error in SetPathInfo create symlink = %d\n",\r\nrc);\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto createSymLinkRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSUnixCreateHardLink(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *fromName, const char *toName,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nTRANSACTION2_SPI_REQ *pSMB = NULL;\r\nTRANSACTION2_SPI_RSP *pSMBr = NULL;\r\nchar *data_offset;\r\nint name_len;\r\nint name_len_target;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\n__u16 params, param_offset, offset, byte_count;\r\ncifs_dbg(FYI, "In Create Hard link Unix style\n");\r\ncreateHardLinkRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len = cifsConvertToUTF16((__le16 *) pSMB->FileName, toName,\r\nPATH_MAX, nls_codepage, remap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(toName, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, toName, name_len);\r\n}\r\nparams = 6 + name_len;\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_spi_req,\r\nInformationLevel) - 4;\r\noffset = param_offset + params;\r\ndata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len_target =\r\ncifsConvertToUTF16((__le16 *) data_offset, fromName,\r\nPATH_MAX, nls_codepage, remap);\r\nname_len_target++;\r\nname_len_target *= 2;\r\n} else {\r\nname_len_target = strnlen(fromName, PATH_MAX);\r\nname_len_target++;\r\nstrncpy(data_offset, fromName, name_len_target);\r\n}\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\r\nbyte_count = 3 + params + name_len_target;\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->DataCount = cpu_to_le16(name_len_target);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_HLINK);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_hardlinks);\r\nif (rc)\r\ncifs_dbg(FYI, "Send error in SetPathInfo (hard link) = %d\n",\r\nrc);\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto createHardLinkRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSCreateHardLink(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *from_name, const char *to_name,\r\nstruct cifs_sb_info *cifs_sb)\r\n{\r\nint rc = 0;\r\nNT_RENAME_REQ *pSMB = NULL;\r\nRENAME_RSP *pSMBr = NULL;\r\nint bytes_returned;\r\nint name_len, name_len2;\r\n__u16 count;\r\nint remap = cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR;\r\ncifs_dbg(FYI, "In CIFSCreateHardLink\n");\r\nwinCreateHardLinkRetry:\r\nrc = smb_init(SMB_COM_NT_RENAME, 4, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\npSMB->SearchAttributes =\r\ncpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\r\nATTR_DIRECTORY);\r\npSMB->Flags = cpu_to_le16(CREATE_HARD_LINK);\r\npSMB->ClusterCount = 0;\r\npSMB->BufferFormat = 0x04;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->OldFileName, from_name,\r\nPATH_MAX, cifs_sb->local_nls, remap);\r\nname_len++;\r\nname_len *= 2;\r\npSMB->OldFileName[name_len] = 0x04;\r\npSMB->OldFileName[name_len + 1] = 0x00;\r\nname_len2 =\r\ncifsConvertToUTF16((__le16 *)&pSMB->OldFileName[name_len+2],\r\nto_name, PATH_MAX, cifs_sb->local_nls,\r\nremap);\r\nname_len2 += 1 + 1 ;\r\nname_len2 *= 2;\r\n} else {\r\nname_len = strnlen(from_name, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->OldFileName, from_name, name_len);\r\nname_len2 = strnlen(to_name, PATH_MAX);\r\nname_len2++;\r\npSMB->OldFileName[name_len] = 0x04;\r\nstrncpy(&pSMB->OldFileName[name_len + 1], to_name, name_len2);\r\nname_len2++;\r\nname_len2++;\r\n}\r\ncount = 1 + name_len + name_len2;\r\ninc_rfc1001_len(pSMB, count);\r\npSMB->ByteCount = cpu_to_le16(count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_hardlinks);\r\nif (rc)\r\ncifs_dbg(FYI, "Send error in hard link (NT rename) = %d\n", rc);\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto winCreateHardLinkRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBUnixQuerySymLink(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst unsigned char *searchName, char **symlinkinfo,\r\nconst struct nls_table *nls_codepage)\r\n{\r\nTRANSACTION2_QPI_REQ *pSMB = NULL;\r\nTRANSACTION2_QPI_RSP *pSMBr = NULL;\r\nint rc = 0;\r\nint bytes_returned;\r\nint name_len;\r\n__u16 params, byte_count;\r\nchar *data_start;\r\ncifs_dbg(FYI, "In QPathSymLinkInfo (Unix) for path %s\n", searchName);\r\nquerySymLinkRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifs_strtoUTF16((__le16 *) pSMB->FileName, searchName,\r\nPATH_MAX, nls_codepage);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(searchName, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, searchName, name_len);\r\n}\r\nparams = 2 + 4 + name_len ;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\npSMB->ParameterOffset = cpu_to_le16(offsetof(\r\nstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\r\nbyte_count = params + 1 ;\r\npSMB->TotalParameterCount = cpu_to_le16(params);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\npSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_LINK);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in QuerySymLinkInfo = %d\n", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < 2)\r\nrc = -EIO;\r\nelse {\r\nbool is_unicode;\r\nu16 count = le16_to_cpu(pSMBr->t2.DataCount);\r\ndata_start = ((char *) &pSMBr->hdr.Protocol) +\r\nle16_to_cpu(pSMBr->t2.DataOffset);\r\nif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\r\nis_unicode = true;\r\nelse\r\nis_unicode = false;\r\n*symlinkinfo = cifs_strndup_from_utf16(data_start,\r\ncount, is_unicode, nls_codepage);\r\nif (!*symlinkinfo)\r\nrc = -ENOMEM;\r\n}\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto querySymLinkRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBQuerySymLink(const unsigned int xid, struct cifs_tcon *tcon,\r\n__u16 fid, char **symlinkinfo,\r\nconst struct nls_table *nls_codepage)\r\n{\r\nint rc = 0;\r\nint bytes_returned;\r\nstruct smb_com_transaction_ioctl_req *pSMB;\r\nstruct smb_com_transaction_ioctl_rsp *pSMBr;\r\nbool is_unicode;\r\nunsigned int sub_len;\r\nchar *sub_start;\r\nstruct reparse_symlink_data *reparse_buf;\r\nstruct reparse_posix_data *posix_buf;\r\n__u32 data_offset, data_count;\r\nchar *end_of_smb;\r\ncifs_dbg(FYI, "In Windows reparse style QueryLink for fid %u\n", fid);\r\nrc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\npSMB->TotalParameterCount = 0 ;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le32(2);\r\npSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\r\npSMB->MaxSetupCount = 4;\r\npSMB->Reserved = 0;\r\npSMB->ParameterOffset = 0;\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 4;\r\npSMB->SubCommand = cpu_to_le16(NT_TRANSACT_IOCTL);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\npSMB->FunctionCode = cpu_to_le32(FSCTL_GET_REPARSE_POINT);\r\npSMB->IsFsctl = 1;\r\npSMB->IsRootFlag = 0;\r\npSMB->Fid = fid;\r\npSMB->ByteCount = 0;\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in QueryReparseLinkInfo = %d\n", rc);\r\ngoto qreparse_out;\r\n}\r\ndata_offset = le32_to_cpu(pSMBr->DataOffset);\r\ndata_count = le32_to_cpu(pSMBr->DataCount);\r\nif (get_bcc(&pSMBr->hdr) < 2 || data_offset > 512) {\r\nrc = -EIO;\r\ngoto qreparse_out;\r\n}\r\nif (!data_count || (data_count > 2048)) {\r\nrc = -EIO;\r\ncifs_dbg(FYI, "Invalid return data count on get reparse info ioctl\n");\r\ngoto qreparse_out;\r\n}\r\nend_of_smb = 2 + get_bcc(&pSMBr->hdr) + (char *)&pSMBr->ByteCount;\r\nreparse_buf = (struct reparse_symlink_data *)\r\n((char *)&pSMBr->hdr.Protocol + data_offset);\r\nif ((char *)reparse_buf >= end_of_smb) {\r\nrc = -EIO;\r\ngoto qreparse_out;\r\n}\r\nif (reparse_buf->ReparseTag == cpu_to_le32(IO_REPARSE_TAG_NFS)) {\r\ncifs_dbg(FYI, "NFS style reparse tag\n");\r\nposix_buf = (struct reparse_posix_data *)reparse_buf;\r\nif (posix_buf->InodeType != cpu_to_le64(NFS_SPECFILE_LNK)) {\r\ncifs_dbg(FYI, "unsupported file type 0x%llx\n",\r\nle64_to_cpu(posix_buf->InodeType));\r\nrc = -EOPNOTSUPP;\r\ngoto qreparse_out;\r\n}\r\nis_unicode = true;\r\nsub_len = le16_to_cpu(reparse_buf->ReparseDataLength);\r\nif (posix_buf->PathBuffer + sub_len > end_of_smb) {\r\ncifs_dbg(FYI, "reparse buf beyond SMB\n");\r\nrc = -EIO;\r\ngoto qreparse_out;\r\n}\r\n*symlinkinfo = cifs_strndup_from_utf16(posix_buf->PathBuffer,\r\nsub_len, is_unicode, nls_codepage);\r\ngoto qreparse_out;\r\n} else if (reparse_buf->ReparseTag !=\r\ncpu_to_le32(IO_REPARSE_TAG_SYMLINK)) {\r\nrc = -EOPNOTSUPP;\r\ngoto qreparse_out;\r\n}\r\nsub_start = le16_to_cpu(reparse_buf->SubstituteNameOffset) +\r\nreparse_buf->PathBuffer;\r\nsub_len = le16_to_cpu(reparse_buf->SubstituteNameLength);\r\nif (sub_start + sub_len > end_of_smb) {\r\ncifs_dbg(FYI, "reparse buf beyond SMB\n");\r\nrc = -EIO;\r\ngoto qreparse_out;\r\n}\r\nif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\r\nis_unicode = true;\r\nelse\r\nis_unicode = false;\r\n*symlinkinfo = cifs_strndup_from_utf16(sub_start, sub_len, is_unicode,\r\nnls_codepage);\r\nif (!*symlinkinfo)\r\nrc = -ENOMEM;\r\nqreparse_out:\r\ncifs_buf_release(pSMB);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMB_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\r\n__u16 fid)\r\n{\r\nint rc = 0;\r\nint bytes_returned;\r\nstruct smb_com_transaction_compr_ioctl_req *pSMB;\r\nstruct smb_com_transaction_ioctl_rsp *pSMBr;\r\ncifs_dbg(FYI, "Set compression for %u\n", fid);\r\nrc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\npSMB->compression_state = cpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\r\npSMB->TotalParameterCount = 0;\r\npSMB->TotalDataCount = __constant_cpu_to_le32(2);\r\npSMB->MaxParameterCount = 0;\r\npSMB->MaxDataCount = 0;\r\npSMB->MaxSetupCount = 4;\r\npSMB->Reserved = 0;\r\npSMB->ParameterOffset = 0;\r\npSMB->DataCount = __constant_cpu_to_le32(2);\r\npSMB->DataOffset =\r\ncpu_to_le32(offsetof(struct smb_com_transaction_compr_ioctl_req,\r\ncompression_state) - 4);\r\npSMB->SetupCount = 4;\r\npSMB->SubCommand = __constant_cpu_to_le16(NT_TRANSACT_IOCTL);\r\npSMB->ParameterCount = 0;\r\npSMB->FunctionCode = __constant_cpu_to_le32(FSCTL_SET_COMPRESSION);\r\npSMB->IsFsctl = 1;\r\npSMB->IsRootFlag = 0;\r\npSMB->Fid = fid;\r\npSMB->ByteCount = __constant_cpu_to_le16(5);\r\ninc_rfc1001_len(pSMB, 5);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc)\r\ncifs_dbg(FYI, "Send error in SetCompression = %d\n", rc);\r\ncifs_buf_release(pSMB);\r\nreturn rc;\r\n}\r\nstatic void cifs_convert_ace(posix_acl_xattr_entry *ace,\r\nstruct cifs_posix_ace *cifs_ace)\r\n{\r\nace->e_perm = cpu_to_le16(cifs_ace->cifs_e_perm);\r\nace->e_tag = cpu_to_le16(cifs_ace->cifs_e_tag);\r\nace->e_id = cpu_to_le32(le64_to_cpu(cifs_ace->cifs_uid));\r\nreturn;\r\n}\r\nstatic int cifs_copy_posix_acl(char *trgt, char *src, const int buflen,\r\nconst int acl_type, const int size_of_data_area)\r\n{\r\nint size = 0;\r\nint i;\r\n__u16 count;\r\nstruct cifs_posix_ace *pACE;\r\nstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)src;\r\nposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)trgt;\r\nif (le16_to_cpu(cifs_acl->version) != CIFS_ACL_VERSION)\r\nreturn -EOPNOTSUPP;\r\nif (acl_type & ACL_TYPE_ACCESS) {\r\ncount = le16_to_cpu(cifs_acl->access_entry_count);\r\npACE = &cifs_acl->ace_array[0];\r\nsize = sizeof(struct cifs_posix_acl);\r\nsize += sizeof(struct cifs_posix_ace) * count;\r\nif (size_of_data_area < size) {\r\ncifs_dbg(FYI, "bad CIFS POSIX ACL size %d vs. %d\n",\r\nsize_of_data_area, size);\r\nreturn -EINVAL;\r\n}\r\n} else if (acl_type & ACL_TYPE_DEFAULT) {\r\ncount = le16_to_cpu(cifs_acl->access_entry_count);\r\nsize = sizeof(struct cifs_posix_acl);\r\nsize += sizeof(struct cifs_posix_ace) * count;\r\npACE = &cifs_acl->ace_array[count];\r\ncount = le16_to_cpu(cifs_acl->default_entry_count);\r\nsize += sizeof(struct cifs_posix_ace) * count;\r\nif (size_of_data_area < size)\r\nreturn -EINVAL;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nsize = posix_acl_xattr_size(count);\r\nif ((buflen == 0) || (local_acl == NULL)) {\r\n} else if (size > buflen) {\r\nreturn -ERANGE;\r\n} else {\r\nlocal_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\r\nfor (i = 0; i < count ; i++) {\r\ncifs_convert_ace(&local_acl->a_entries[i], pACE);\r\npACE++;\r\n}\r\n}\r\nreturn size;\r\n}\r\nstatic __u16 convert_ace_to_cifs_ace(struct cifs_posix_ace *cifs_ace,\r\nconst posix_acl_xattr_entry *local_ace)\r\n{\r\n__u16 rc = 0;\r\ncifs_ace->cifs_e_perm = le16_to_cpu(local_ace->e_perm);\r\ncifs_ace->cifs_e_tag = le16_to_cpu(local_ace->e_tag);\r\nif (local_ace->e_id == cpu_to_le32(-1)) {\r\ncifs_ace->cifs_uid = cpu_to_le64(-1);\r\n} else\r\ncifs_ace->cifs_uid = cpu_to_le64(le32_to_cpu(local_ace->e_id));\r\nreturn rc;\r\n}\r\nstatic __u16 ACL_to_cifs_posix(char *parm_data, const char *pACL,\r\nconst int buflen, const int acl_type)\r\n{\r\n__u16 rc = 0;\r\nstruct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)parm_data;\r\nposix_acl_xattr_header *local_acl = (posix_acl_xattr_header *)pACL;\r\nint count;\r\nint i;\r\nif ((buflen == 0) || (pACL == NULL) || (cifs_acl == NULL))\r\nreturn 0;\r\ncount = posix_acl_xattr_count((size_t)buflen);\r\ncifs_dbg(FYI, "setting acl with %d entries from buf of length %d and version of %d\n",\r\ncount, buflen, le32_to_cpu(local_acl->a_version));\r\nif (le32_to_cpu(local_acl->a_version) != 2) {\r\ncifs_dbg(FYI, "unknown POSIX ACL version %d\n",\r\nle32_to_cpu(local_acl->a_version));\r\nreturn 0;\r\n}\r\ncifs_acl->version = cpu_to_le16(1);\r\nif (acl_type == ACL_TYPE_ACCESS) {\r\ncifs_acl->access_entry_count = cpu_to_le16(count);\r\ncifs_acl->default_entry_count = __constant_cpu_to_le16(0xFFFF);\r\n} else if (acl_type == ACL_TYPE_DEFAULT) {\r\ncifs_acl->default_entry_count = cpu_to_le16(count);\r\ncifs_acl->access_entry_count = __constant_cpu_to_le16(0xFFFF);\r\n} else {\r\ncifs_dbg(FYI, "unknown ACL type %d\n", acl_type);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nrc = convert_ace_to_cifs_ace(&cifs_acl->ace_array[i],\r\n&local_acl->a_entries[i]);\r\nif (rc != 0) {\r\nbreak;\r\n}\r\n}\r\nif (rc == 0) {\r\nrc = (__u16)(count * sizeof(struct cifs_posix_ace));\r\nrc += sizeof(struct cifs_posix_acl);\r\n}\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBGetPosixACL(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst unsigned char *searchName,\r\nchar *acl_inf, const int buflen, const int acl_type,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nTRANSACTION2_QPI_REQ *pSMB = NULL;\r\nTRANSACTION2_QPI_RSP *pSMBr = NULL;\r\nint rc = 0;\r\nint bytes_returned;\r\nint name_len;\r\n__u16 params, byte_count;\r\ncifs_dbg(FYI, "In GetPosixACL (Unix) for path %s\n", searchName);\r\nqueryAclRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName,\r\nsearchName, PATH_MAX, nls_codepage,\r\nremap);\r\nname_len++;\r\nname_len *= 2;\r\npSMB->FileName[name_len] = 0;\r\npSMB->FileName[name_len+1] = 0;\r\n} else {\r\nname_len = strnlen(searchName, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, searchName, name_len);\r\n}\r\nparams = 2 + 4 + name_len ;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(4000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\npSMB->ParameterOffset = cpu_to_le16(\r\noffsetof(struct smb_com_transaction2_qpi_req,\r\nInformationLevel) - 4);\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\r\nbyte_count = params + 1 ;\r\npSMB->TotalParameterCount = cpu_to_le16(params);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\npSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_ACL);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_acl_get);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in Query POSIX ACL = %d\n", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < 2)\r\nrc = -EIO;\r\nelse {\r\n__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\n__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\r\nrc = cifs_copy_posix_acl(acl_inf,\r\n(char *)&pSMBr->hdr.Protocol+data_offset,\r\nbuflen, acl_type, count);\r\n}\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto queryAclRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBSetPosixACL(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst unsigned char *fileName,\r\nconst char *local_acl, const int buflen,\r\nconst int acl_type,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nstruct smb_com_transaction2_spi_req *pSMB = NULL;\r\nstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\r\nchar *parm_data;\r\nint name_len;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\n__u16 params, byte_count, data_count, param_offset, offset;\r\ncifs_dbg(FYI, "In SetPosixACL (Unix) for path %s\n", fileName);\r\nsetAclRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\r\nPATH_MAX, nls_codepage, remap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(fileName, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, fileName, name_len);\r\n}\r\nparams = 6 + name_len;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_spi_req,\r\nInformationLevel) - 4;\r\noffset = param_offset + params;\r\nparm_data = ((char *) &pSMB->hdr.Protocol) + offset;\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\ndata_count = ACL_to_cifs_posix(parm_data, local_acl, buflen, acl_type);\r\nif (data_count == 0) {\r\nrc = -EOPNOTSUPP;\r\ngoto setACLerrorExit;\r\n}\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\r\npSMB->InformationLevel = cpu_to_le16(SMB_SET_POSIX_ACL);\r\nbyte_count = 3 + params + data_count;\r\npSMB->DataCount = cpu_to_le16(data_count);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc)\r\ncifs_dbg(FYI, "Set POSIX ACL returned %d\n", rc);\r\nsetACLerrorExit:\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto setAclRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSGetExtAttr(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst int netfid, __u64 *pExtAttrBits, __u64 *pMask)\r\n{\r\nint rc = 0;\r\nstruct smb_t2_qfi_req *pSMB = NULL;\r\nstruct smb_t2_qfi_rsp *pSMBr = NULL;\r\nint bytes_returned;\r\n__u16 params, byte_count;\r\ncifs_dbg(FYI, "In GetExtAttr\n");\r\nif (tcon == NULL)\r\nreturn -ENODEV;\r\nGetExtAttrRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nparams = 2 + 2 ;\r\npSMB->t2.TotalDataCount = 0;\r\npSMB->t2.MaxParameterCount = cpu_to_le16(4);\r\npSMB->t2.MaxDataCount = cpu_to_le16(4000);\r\npSMB->t2.MaxSetupCount = 0;\r\npSMB->t2.Reserved = 0;\r\npSMB->t2.Flags = 0;\r\npSMB->t2.Timeout = 0;\r\npSMB->t2.Reserved2 = 0;\r\npSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\r\nFid) - 4);\r\npSMB->t2.DataCount = 0;\r\npSMB->t2.DataOffset = 0;\r\npSMB->t2.SetupCount = 1;\r\npSMB->t2.Reserved3 = 0;\r\npSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\r\nbyte_count = params + 1 ;\r\npSMB->t2.TotalParameterCount = cpu_to_le16(params);\r\npSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\r\npSMB->InformationLevel = cpu_to_le16(SMB_QUERY_ATTR_FLAGS);\r\npSMB->Pad = 0;\r\npSMB->Fid = netfid;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->t2.ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "error %d in GetExtAttr\n", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < 2)\r\nrc = -EIO;\r\nelse {\r\n__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\n__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\r\nstruct file_chattr_info *pfinfo;\r\nif (count != 16) {\r\ncifs_dbg(FYI, "Illegal size ret in GetExtAttr\n");\r\nrc = -EIO;\r\ngoto GetExtAttrOut;\r\n}\r\npfinfo = (struct file_chattr_info *)\r\n(data_offset + (char *) &pSMBr->hdr.Protocol);\r\n*pExtAttrBits = le64_to_cpu(pfinfo->mode);\r\n*pMask = le64_to_cpu(pfinfo->mask);\r\n}\r\n}\r\nGetExtAttrOut:\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto GetExtAttrRetry;\r\nreturn rc;\r\n}\r\nstatic int\r\nsmb_init_nttransact(const __u16 sub_command, const int setup_count,\r\nconst int parm_len, struct cifs_tcon *tcon,\r\nvoid **ret_buf)\r\n{\r\nint rc;\r\n__u32 temp_offset;\r\nstruct smb_com_ntransact_req *pSMB;\r\nrc = small_smb_init(SMB_COM_NT_TRANSACT, 19 + setup_count, tcon,\r\n(void **)&pSMB);\r\nif (rc)\r\nreturn rc;\r\n*ret_buf = (void *)pSMB;\r\npSMB->Reserved = 0;\r\npSMB->TotalParameterCount = cpu_to_le32(parm_len);\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\npSMB->DataCount = pSMB->TotalDataCount;\r\ntemp_offset = offsetof(struct smb_com_ntransact_req, Parms) +\r\n(setup_count * 2) - 4 ;\r\npSMB->ParameterOffset = cpu_to_le32(temp_offset);\r\npSMB->DataOffset = cpu_to_le32(temp_offset + parm_len);\r\npSMB->SetupCount = setup_count;\r\npSMB->SubCommand = cpu_to_le16(sub_command);\r\nreturn 0;\r\n}\r\nstatic int\r\nvalidate_ntransact(char *buf, char **ppparm, char **ppdata,\r\n__u32 *pparmlen, __u32 *pdatalen)\r\n{\r\nchar *end_of_smb;\r\n__u32 data_count, data_offset, parm_count, parm_offset;\r\nstruct smb_com_ntransact_rsp *pSMBr;\r\nu16 bcc;\r\n*pdatalen = 0;\r\n*pparmlen = 0;\r\nif (buf == NULL)\r\nreturn -EINVAL;\r\npSMBr = (struct smb_com_ntransact_rsp *)buf;\r\nbcc = get_bcc(&pSMBr->hdr);\r\nend_of_smb = 2 + bcc +\r\n(char *)&pSMBr->ByteCount;\r\ndata_offset = le32_to_cpu(pSMBr->DataOffset);\r\ndata_count = le32_to_cpu(pSMBr->DataCount);\r\nparm_offset = le32_to_cpu(pSMBr->ParameterOffset);\r\nparm_count = le32_to_cpu(pSMBr->ParameterCount);\r\n*ppparm = (char *)&pSMBr->hdr.Protocol + parm_offset;\r\n*ppdata = (char *)&pSMBr->hdr.Protocol + data_offset;\r\nif (*ppparm > end_of_smb) {\r\ncifs_dbg(FYI, "parms start after end of smb\n");\r\nreturn -EINVAL;\r\n} else if (parm_count + *ppparm > end_of_smb) {\r\ncifs_dbg(FYI, "parm end after end of smb\n");\r\nreturn -EINVAL;\r\n} else if (*ppdata > end_of_smb) {\r\ncifs_dbg(FYI, "data starts after end of smb\n");\r\nreturn -EINVAL;\r\n} else if (data_count + *ppdata > end_of_smb) {\r\ncifs_dbg(FYI, "data %p + count %d (%p) past smb end %p start %p\n",\r\n*ppdata, data_count, (data_count + *ppdata),\r\nend_of_smb, pSMBr);\r\nreturn -EINVAL;\r\n} else if (parm_count + data_count > bcc) {\r\ncifs_dbg(FYI, "parm count and data count larger than SMB\n");\r\nreturn -EINVAL;\r\n}\r\n*pdatalen = data_count;\r\n*pparmlen = parm_count;\r\nreturn 0;\r\n}\r\nint\r\nCIFSSMBGetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\r\nstruct cifs_ntsd **acl_inf, __u32 *pbuflen)\r\n{\r\nint rc = 0;\r\nint buf_type = 0;\r\nQUERY_SEC_DESC_REQ *pSMB;\r\nstruct kvec iov[1];\r\ncifs_dbg(FYI, "GetCifsACL\n");\r\n*pbuflen = 0;\r\n*acl_inf = NULL;\r\nrc = smb_init_nttransact(NT_TRANSACT_QUERY_SECURITY_DESC, 0,\r\n8 , tcon, (void **) &pSMB);\r\nif (rc)\r\nreturn rc;\r\npSMB->MaxParameterCount = cpu_to_le32(4);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Fid = fid;\r\npSMB->AclFlags = cpu_to_le32(CIFS_ACL_OWNER | CIFS_ACL_GROUP |\r\nCIFS_ACL_DACL);\r\npSMB->ByteCount = cpu_to_le16(11);\r\ninc_rfc1001_len(pSMB, 11);\r\niov[0].iov_base = (char *)pSMB;\r\niov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\r\nrc = SendReceive2(xid, tcon->ses, iov, 1 , &buf_type,\r\n0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_acl_get);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in QuerySecDesc = %d\n", rc);\r\n} else {\r\n__le32 *parm;\r\n__u32 parm_len;\r\n__u32 acl_len;\r\nstruct smb_com_ntransact_rsp *pSMBr;\r\nchar *pdata;\r\nrc = validate_ntransact(iov[0].iov_base, (char **)&parm,\r\n&pdata, &parm_len, pbuflen);\r\nif (rc)\r\ngoto qsec_out;\r\npSMBr = (struct smb_com_ntransact_rsp *)iov[0].iov_base;\r\ncifs_dbg(FYI, "smb %p parm %p data %p\n",\r\npSMBr, parm, *acl_inf);\r\nif (le32_to_cpu(pSMBr->ParameterCount) != 4) {\r\nrc = -EIO;\r\n*pbuflen = 0;\r\ngoto qsec_out;\r\n}\r\nacl_len = le32_to_cpu(*parm);\r\nif (acl_len != *pbuflen) {\r\ncifs_dbg(VFS, "acl length %d does not match %d\n",\r\nacl_len, *pbuflen);\r\nif (*pbuflen > acl_len)\r\n*pbuflen = acl_len;\r\n}\r\nif ((*pbuflen < sizeof(struct cifs_ntsd) + 8) ||\r\n(*pbuflen >= 64 * 1024)) {\r\ncifs_dbg(VFS, "bad acl length %d\n", *pbuflen);\r\nrc = -EINVAL;\r\n*pbuflen = 0;\r\n} else {\r\n*acl_inf = kmemdup(pdata, *pbuflen, GFP_KERNEL);\r\nif (*acl_inf == NULL) {\r\n*pbuflen = 0;\r\nrc = -ENOMEM;\r\n}\r\n}\r\n}\r\nqsec_out:\r\nif (buf_type == CIFS_SMALL_BUFFER)\r\ncifs_small_buf_release(iov[0].iov_base);\r\nelse if (buf_type == CIFS_LARGE_BUFFER)\r\ncifs_buf_release(iov[0].iov_base);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBSetCIFSACL(const unsigned int xid, struct cifs_tcon *tcon, __u16 fid,\r\nstruct cifs_ntsd *pntsd, __u32 acllen, int aclflag)\r\n{\r\n__u16 byte_count, param_count, data_count, param_offset, data_offset;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\nSET_SEC_DESC_REQ *pSMB = NULL;\r\nvoid *pSMBr;\r\nsetCifsAclRetry:\r\nrc = smb_init(SMB_COM_NT_TRANSACT, 19, tcon, (void **) &pSMB, &pSMBr);\r\nif (rc)\r\nreturn rc;\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\nparam_count = 8;\r\nparam_offset = offsetof(struct smb_com_transaction_ssec_req, Fid) - 4;\r\ndata_count = acllen;\r\ndata_offset = param_offset + param_count;\r\nbyte_count = 3 + param_count;\r\npSMB->DataCount = cpu_to_le32(data_count);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->MaxParameterCount = cpu_to_le32(4);\r\npSMB->MaxDataCount = cpu_to_le32(16384);\r\npSMB->ParameterCount = cpu_to_le32(param_count);\r\npSMB->ParameterOffset = cpu_to_le32(param_offset);\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->DataOffset = cpu_to_le32(data_offset);\r\npSMB->SetupCount = 0;\r\npSMB->SubCommand = cpu_to_le16(NT_TRANSACT_SET_SECURITY_DESC);\r\npSMB->ByteCount = cpu_to_le16(byte_count+data_count);\r\npSMB->Fid = fid;\r\npSMB->Reserved2 = 0;\r\npSMB->AclFlags = cpu_to_le32(aclflag);\r\nif (pntsd && acllen) {\r\nmemcpy((char *)pSMBr + offsetof(struct smb_hdr, Protocol) +\r\ndata_offset, pntsd, acllen);\r\ninc_rfc1001_len(pSMB, byte_count + data_count);\r\n} else\r\ninc_rfc1001_len(pSMB, byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\ncifs_dbg(FYI, "SetCIFSACL bytes_returned: %d, rc: %d\n",\r\nbytes_returned, rc);\r\nif (rc)\r\ncifs_dbg(FYI, "Set CIFS ACL returned %d\n", rc);\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto setCifsAclRetry;\r\nreturn (rc);\r\n}\r\nint\r\nSMBQueryInformation(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *search_name, FILE_ALL_INFO *data,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nQUERY_INFORMATION_REQ *pSMB;\r\nQUERY_INFORMATION_RSP *pSMBr;\r\nint rc = 0;\r\nint bytes_returned;\r\nint name_len;\r\ncifs_dbg(FYI, "In SMBQPath path %s\n", search_name);\r\nQInfRetry:\r\nrc = smb_init(SMB_COM_QUERY_INFORMATION, 0, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName,\r\nsearch_name, PATH_MAX, nls_codepage,\r\nremap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(search_name, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, search_name, name_len);\r\n}\r\npSMB->BufferFormat = 0x04;\r\nname_len++;\r\ninc_rfc1001_len(pSMB, (__u16)name_len);\r\npSMB->ByteCount = cpu_to_le16(name_len);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in QueryInfo = %d\n", rc);\r\n} else if (data) {\r\nstruct timespec ts;\r\n__u32 time = le32_to_cpu(pSMBr->last_write_time);\r\nmemset(data, 0, sizeof(FILE_ALL_INFO));\r\nts.tv_nsec = 0;\r\nts.tv_sec = time;\r\ndata->ChangeTime = cpu_to_le64(cifs_UnixTimeToNT(ts));\r\ndata->LastWriteTime = data->ChangeTime;\r\ndata->LastAccessTime = 0;\r\ndata->AllocationSize =\r\ncpu_to_le64(le32_to_cpu(pSMBr->size));\r\ndata->EndOfFile = data->AllocationSize;\r\ndata->Attributes =\r\ncpu_to_le32(le16_to_cpu(pSMBr->attr));\r\n} else\r\nrc = -EIO;\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto QInfRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\r\nu16 netfid, FILE_ALL_INFO *pFindData)\r\n{\r\nstruct smb_t2_qfi_req *pSMB = NULL;\r\nstruct smb_t2_qfi_rsp *pSMBr = NULL;\r\nint rc = 0;\r\nint bytes_returned;\r\n__u16 params, byte_count;\r\nQFileInfoRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nparams = 2 + 2 ;\r\npSMB->t2.TotalDataCount = 0;\r\npSMB->t2.MaxParameterCount = cpu_to_le16(4);\r\npSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\r\npSMB->t2.MaxSetupCount = 0;\r\npSMB->t2.Reserved = 0;\r\npSMB->t2.Flags = 0;\r\npSMB->t2.Timeout = 0;\r\npSMB->t2.Reserved2 = 0;\r\npSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\r\nFid) - 4);\r\npSMB->t2.DataCount = 0;\r\npSMB->t2.DataOffset = 0;\r\npSMB->t2.SetupCount = 1;\r\npSMB->t2.Reserved3 = 0;\r\npSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\r\nbyte_count = params + 1 ;\r\npSMB->t2.TotalParameterCount = cpu_to_le16(params);\r\npSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\r\npSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\r\npSMB->Pad = 0;\r\npSMB->Fid = netfid;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->t2.ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in QFileInfo = %d", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc)\r\nrc = -EIO;\r\nelse if (get_bcc(&pSMBr->hdr) < 40)\r\nrc = -EIO;\r\nelse if (pFindData) {\r\n__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\nmemcpy((char *) pFindData,\r\n(char *) &pSMBr->hdr.Protocol +\r\ndata_offset, sizeof(FILE_ALL_INFO));\r\n} else\r\nrc = -ENOMEM;\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto QFileInfoRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *search_name, FILE_ALL_INFO *data,\r\nint legacy ,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nTRANSACTION2_QPI_REQ *pSMB = NULL;\r\nTRANSACTION2_QPI_RSP *pSMBr = NULL;\r\nint rc = 0;\r\nint bytes_returned;\r\nint name_len;\r\n__u16 params, byte_count;\r\nQPathInfoRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName, search_name,\r\nPATH_MAX, nls_codepage, remap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(search_name, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, search_name, name_len);\r\n}\r\nparams = 2 + 4 + name_len ;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(4000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\npSMB->ParameterOffset = cpu_to_le16(offsetof(\r\nstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\r\nbyte_count = params + 1 ;\r\npSMB->TotalParameterCount = cpu_to_le16(params);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\nif (legacy)\r\npSMB->InformationLevel = cpu_to_le16(SMB_INFO_STANDARD);\r\nelse\r\npSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in QPathInfo = %d\n", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc)\r\nrc = -EIO;\r\nelse if (!legacy && get_bcc(&pSMBr->hdr) < 40)\r\nrc = -EIO;\r\nelse if (legacy && get_bcc(&pSMBr->hdr) < 24)\r\nrc = -EIO;\r\nelse if (data) {\r\nint size;\r\n__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\nif (legacy)\r\nsize = sizeof(FILE_INFO_STANDARD);\r\nelse\r\nsize = sizeof(FILE_ALL_INFO);\r\nmemcpy((char *) data, (char *) &pSMBr->hdr.Protocol +\r\ndata_offset, size);\r\n} else\r\nrc = -ENOMEM;\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto QPathInfoRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBUnixQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\r\nu16 netfid, FILE_UNIX_BASIC_INFO *pFindData)\r\n{\r\nstruct smb_t2_qfi_req *pSMB = NULL;\r\nstruct smb_t2_qfi_rsp *pSMBr = NULL;\r\nint rc = 0;\r\nint bytes_returned;\r\n__u16 params, byte_count;\r\nUnixQFileInfoRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nparams = 2 + 2 ;\r\npSMB->t2.TotalDataCount = 0;\r\npSMB->t2.MaxParameterCount = cpu_to_le16(4);\r\npSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\r\npSMB->t2.MaxSetupCount = 0;\r\npSMB->t2.Reserved = 0;\r\npSMB->t2.Flags = 0;\r\npSMB->t2.Timeout = 0;\r\npSMB->t2.Reserved2 = 0;\r\npSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\r\nFid) - 4);\r\npSMB->t2.DataCount = 0;\r\npSMB->t2.DataOffset = 0;\r\npSMB->t2.SetupCount = 1;\r\npSMB->t2.Reserved3 = 0;\r\npSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\r\nbyte_count = params + 1 ;\r\npSMB->t2.TotalParameterCount = cpu_to_le16(params);\r\npSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\r\npSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\r\npSMB->Pad = 0;\r\npSMB->Fid = netfid;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->t2.ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in UnixQFileInfo = %d", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\r\ncifs_dbg(VFS, "Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\n");\r\nrc = -EIO;\r\n} else {\r\n__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\nmemcpy((char *) pFindData,\r\n(char *) &pSMBr->hdr.Protocol +\r\ndata_offset,\r\nsizeof(FILE_UNIX_BASIC_INFO));\r\n}\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto UnixQFileInfoRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBUnixQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst unsigned char *searchName,\r\nFILE_UNIX_BASIC_INFO *pFindData,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nTRANSACTION2_QPI_REQ *pSMB = NULL;\r\nTRANSACTION2_QPI_RSP *pSMBr = NULL;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\nint name_len;\r\n__u16 params, byte_count;\r\ncifs_dbg(FYI, "In QPathInfo (Unix) the path %s\n", searchName);\r\nUnixQPathInfoRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\r\nPATH_MAX, nls_codepage, remap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(searchName, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, searchName, name_len);\r\n}\r\nparams = 2 + 4 + name_len ;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(4000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\npSMB->ParameterOffset = cpu_to_le16(offsetof(\r\nstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\r\nbyte_count = params + 1 ;\r\npSMB->TotalParameterCount = cpu_to_le16(params);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\npSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in UnixQPathInfo = %d", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\r\ncifs_dbg(VFS, "Malformed FILE_UNIX_BASIC_INFO response. Unix Extensions can be disabled on mount by specifying the nosfu mount option.\n");\r\nrc = -EIO;\r\n} else {\r\n__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\nmemcpy((char *) pFindData,\r\n(char *) &pSMBr->hdr.Protocol +\r\ndata_offset,\r\nsizeof(FILE_UNIX_BASIC_INFO));\r\n}\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto UnixQPathInfoRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSFindFirst(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *searchName, struct cifs_sb_info *cifs_sb,\r\n__u16 *pnetfid, __u16 search_flags,\r\nstruct cifs_search_info *psrch_inf, bool msearch)\r\n{\r\nTRANSACTION2_FFIRST_REQ *pSMB = NULL;\r\nTRANSACTION2_FFIRST_RSP *pSMBr = NULL;\r\nT2_FFIRST_RSP_PARMS *parms;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\nint name_len, remap;\r\n__u16 params, byte_count;\r\nstruct nls_table *nls_codepage;\r\ncifs_dbg(FYI, "In FindFirst for %s\n", searchName);\r\nfindFirstRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nnls_codepage = cifs_sb->local_nls;\r\nremap = cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\r\nPATH_MAX, nls_codepage, remap);\r\nname_len *= 2;\r\nif (msearch) {\r\npSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\r\npSMB->FileName[name_len+1] = 0;\r\npSMB->FileName[name_len+2] = '*';\r\npSMB->FileName[name_len+3] = 0;\r\nname_len += 4;\r\npSMB->FileName[name_len] = 0;\r\npSMB->FileName[name_len+1] = 0;\r\nname_len += 2;\r\n}\r\n} else {\r\nname_len = strnlen(searchName, PATH_MAX);\r\nstrncpy(pSMB->FileName, searchName, name_len);\r\nif (msearch) {\r\npSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\r\npSMB->FileName[name_len+1] = '*';\r\npSMB->FileName[name_len+2] = 0;\r\nname_len += 3;\r\n}\r\n}\r\nparams = 12 + name_len ;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(10);\r\npSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nbyte_count = params + 1 ;\r\npSMB->TotalParameterCount = cpu_to_le16(params);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(\r\noffsetof(struct smb_com_transaction2_ffirst_req, SearchAttributes)\r\n- 4);\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_FIND_FIRST);\r\npSMB->SearchAttributes =\r\ncpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\r\nATTR_DIRECTORY);\r\npSMB->SearchCount = cpu_to_le16(CIFSMaxBufSize/sizeof(FILE_UNIX_INFO));\r\npSMB->SearchFlags = cpu_to_le16(search_flags);\r\npSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\r\npSMB->SearchStorageType = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_ffirst);\r\nif (rc) {\r\ncifs_dbg(FYI, "Error in FindFirst = %d\n", rc);\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto findFirstRetry;\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc == 0) {\r\nunsigned int lnoff;\r\nif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\r\npsrch_inf->unicode = true;\r\nelse\r\npsrch_inf->unicode = false;\r\npsrch_inf->ntwrk_buf_start = (char *)pSMBr;\r\npsrch_inf->smallBuf = 0;\r\npsrch_inf->srch_entries_start =\r\n(char *) &pSMBr->hdr.Protocol +\r\nle16_to_cpu(pSMBr->t2.DataOffset);\r\nparms = (T2_FFIRST_RSP_PARMS *)((char *) &pSMBr->hdr.Protocol +\r\nle16_to_cpu(pSMBr->t2.ParameterOffset));\r\nif (parms->EndofSearch)\r\npsrch_inf->endOfSearch = true;\r\nelse\r\npsrch_inf->endOfSearch = false;\r\npsrch_inf->entries_in_buffer =\r\nle16_to_cpu(parms->SearchCount);\r\npsrch_inf->index_of_last_entry = 2 +\r\npsrch_inf->entries_in_buffer;\r\nlnoff = le16_to_cpu(parms->LastNameOffset);\r\nif (CIFSMaxBufSize < lnoff) {\r\ncifs_dbg(VFS, "ignoring corrupt resume name\n");\r\npsrch_inf->last_entry = NULL;\r\nreturn rc;\r\n}\r\npsrch_inf->last_entry = psrch_inf->srch_entries_start +\r\nlnoff;\r\nif (pnetfid)\r\n*pnetfid = parms->SearchHandle;\r\n} else {\r\ncifs_buf_release(pSMB);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nint CIFSFindNext(const unsigned int xid, struct cifs_tcon *tcon,\r\n__u16 searchHandle, __u16 search_flags,\r\nstruct cifs_search_info *psrch_inf)\r\n{\r\nTRANSACTION2_FNEXT_REQ *pSMB = NULL;\r\nTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\r\nT2_FNEXT_RSP_PARMS *parms;\r\nchar *response_data;\r\nint rc = 0;\r\nint bytes_returned;\r\nunsigned int name_len;\r\n__u16 params, byte_count;\r\ncifs_dbg(FYI, "In FindNext\n");\r\nif (psrch_inf->endOfSearch)\r\nreturn -ENOENT;\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nparams = 14;\r\nbyte_count = 0;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(8);\r\npSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\npSMB->ParameterOffset = cpu_to_le16(\r\noffsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\r\npSMB->SearchHandle = searchHandle;\r\npSMB->SearchCount =\r\ncpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\r\npSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\r\npSMB->ResumeKey = psrch_inf->resume_key;\r\npSMB->SearchFlags = cpu_to_le16(search_flags);\r\nname_len = psrch_inf->resume_name_len;\r\nparams += name_len;\r\nif (name_len < PATH_MAX) {\r\nmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\r\nbyte_count += name_len;\r\npSMB->ResumeFileName[name_len] = 0;\r\npSMB->ResumeFileName[name_len+1] = 0;\r\n} else {\r\nrc = -EINVAL;\r\ngoto FNext2_err_exit;\r\n}\r\nbyte_count = params + 1 ;\r\npSMB->TotalParameterCount = cpu_to_le16(params);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_fnext);\r\nif (rc) {\r\nif (rc == -EBADF) {\r\npsrch_inf->endOfSearch = true;\r\ncifs_buf_release(pSMB);\r\nrc = 0;\r\n} else\r\ncifs_dbg(FYI, "FindNext returned = %d\n", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc == 0) {\r\nunsigned int lnoff;\r\nif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\r\npsrch_inf->unicode = true;\r\nelse\r\npsrch_inf->unicode = false;\r\nresponse_data = (char *) &pSMBr->hdr.Protocol +\r\nle16_to_cpu(pSMBr->t2.ParameterOffset);\r\nparms = (T2_FNEXT_RSP_PARMS *)response_data;\r\nresponse_data = (char *)&pSMBr->hdr.Protocol +\r\nle16_to_cpu(pSMBr->t2.DataOffset);\r\nif (psrch_inf->smallBuf)\r\ncifs_small_buf_release(\r\npsrch_inf->ntwrk_buf_start);\r\nelse\r\ncifs_buf_release(psrch_inf->ntwrk_buf_start);\r\npsrch_inf->srch_entries_start = response_data;\r\npsrch_inf->ntwrk_buf_start = (char *)pSMB;\r\npsrch_inf->smallBuf = 0;\r\nif (parms->EndofSearch)\r\npsrch_inf->endOfSearch = true;\r\nelse\r\npsrch_inf->endOfSearch = false;\r\npsrch_inf->entries_in_buffer =\r\nle16_to_cpu(parms->SearchCount);\r\npsrch_inf->index_of_last_entry +=\r\npsrch_inf->entries_in_buffer;\r\nlnoff = le16_to_cpu(parms->LastNameOffset);\r\nif (CIFSMaxBufSize < lnoff) {\r\ncifs_dbg(VFS, "ignoring corrupt resume name\n");\r\npsrch_inf->last_entry = NULL;\r\nreturn rc;\r\n} else\r\npsrch_inf->last_entry =\r\npsrch_inf->srch_entries_start + lnoff;\r\n}\r\n}\r\nFNext2_err_exit:\r\nif (rc != 0)\r\ncifs_buf_release(pSMB);\r\nreturn rc;\r\n}\r\nint\r\nCIFSFindClose(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst __u16 searchHandle)\r\n{\r\nint rc = 0;\r\nFINDCLOSE_REQ *pSMB = NULL;\r\ncifs_dbg(FYI, "In CIFSSMBFindClose\n");\r\nrc = small_smb_init(SMB_COM_FIND_CLOSE2, 1, tcon, (void **)&pSMB);\r\nif (rc == -EAGAIN)\r\nreturn 0;\r\nif (rc)\r\nreturn rc;\r\npSMB->FileID = searchHandle;\r\npSMB->ByteCount = 0;\r\nrc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\r\nif (rc)\r\ncifs_dbg(VFS, "Send error in FindClose = %d\n", rc);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_fclose);\r\nif (rc == -EAGAIN)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nint\r\nCIFSGetSrvInodeNumber(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *search_name, __u64 *inode_number,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nint rc = 0;\r\nTRANSACTION2_QPI_REQ *pSMB = NULL;\r\nTRANSACTION2_QPI_RSP *pSMBr = NULL;\r\nint name_len, bytes_returned;\r\n__u16 params, byte_count;\r\ncifs_dbg(FYI, "In GetSrvInodeNum for %s\n", search_name);\r\nif (tcon == NULL)\r\nreturn -ENODEV;\r\nGetInodeNumberRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName,\r\nsearch_name, PATH_MAX, nls_codepage,\r\nremap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(search_name, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, search_name, name_len);\r\n}\r\nparams = 2 + 4 + name_len ;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(4000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\npSMB->ParameterOffset = cpu_to_le16(offsetof(\r\nstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\r\nbyte_count = params + 1 ;\r\npSMB->TotalParameterCount = cpu_to_le16(params);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\npSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_INTERNAL_INFO);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "error %d in QueryInternalInfo\n", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < 2)\r\nrc = -EIO;\r\nelse {\r\n__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\n__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\r\nstruct file_internal_info *pfinfo;\r\nif (count < 8) {\r\ncifs_dbg(FYI, "Illegal size ret in QryIntrnlInf\n");\r\nrc = -EIO;\r\ngoto GetInodeNumOut;\r\n}\r\npfinfo = (struct file_internal_info *)\r\n(data_offset + (char *) &pSMBr->hdr.Protocol);\r\n*inode_number = le64_to_cpu(pfinfo->UniqueId);\r\n}\r\n}\r\nGetInodeNumOut:\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto GetInodeNumberRetry;\r\nreturn rc;\r\n}\r\nstatic int\r\nparse_DFS_referrals(TRANSACTION2_GET_DFS_REFER_RSP *pSMBr,\r\nunsigned int *num_of_nodes,\r\nstruct dfs_info3_param **target_nodes,\r\nconst struct nls_table *nls_codepage, int remap,\r\nconst char *searchName)\r\n{\r\nint i, rc = 0;\r\nchar *data_end;\r\nbool is_unicode;\r\nstruct dfs_referral_level_3 *ref;\r\nif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\r\nis_unicode = true;\r\nelse\r\nis_unicode = false;\r\n*num_of_nodes = le16_to_cpu(pSMBr->NumberOfReferrals);\r\nif (*num_of_nodes < 1) {\r\ncifs_dbg(VFS, "num_referrals: must be at least > 0, but we get num_referrals = %d\n",\r\n*num_of_nodes);\r\nrc = -EINVAL;\r\ngoto parse_DFS_referrals_exit;\r\n}\r\nref = (struct dfs_referral_level_3 *) &(pSMBr->referrals);\r\nif (ref->VersionNumber != cpu_to_le16(3)) {\r\ncifs_dbg(VFS, "Referrals of V%d version are not supported, should be V3\n",\r\nle16_to_cpu(ref->VersionNumber));\r\nrc = -EINVAL;\r\ngoto parse_DFS_referrals_exit;\r\n}\r\ndata_end = (char *)(&(pSMBr->PathConsumed)) +\r\nle16_to_cpu(pSMBr->t2.DataCount);\r\ncifs_dbg(FYI, "num_referrals: %d dfs flags: 0x%x ...\n",\r\n*num_of_nodes, le32_to_cpu(pSMBr->DFSFlags));\r\n*target_nodes = kcalloc(*num_of_nodes, sizeof(struct dfs_info3_param),\r\nGFP_KERNEL);\r\nif (*target_nodes == NULL) {\r\nrc = -ENOMEM;\r\ngoto parse_DFS_referrals_exit;\r\n}\r\nfor (i = 0; i < *num_of_nodes; i++) {\r\nchar *temp;\r\nint max_len;\r\nstruct dfs_info3_param *node = (*target_nodes)+i;\r\nnode->flags = le32_to_cpu(pSMBr->DFSFlags);\r\nif (is_unicode) {\r\n__le16 *tmp = kmalloc(strlen(searchName)*2 + 2,\r\nGFP_KERNEL);\r\nif (tmp == NULL) {\r\nrc = -ENOMEM;\r\ngoto parse_DFS_referrals_exit;\r\n}\r\ncifsConvertToUTF16((__le16 *) tmp, searchName,\r\nPATH_MAX, nls_codepage, remap);\r\nnode->path_consumed = cifs_utf16_bytes(tmp,\r\nle16_to_cpu(pSMBr->PathConsumed),\r\nnls_codepage);\r\nkfree(tmp);\r\n} else\r\nnode->path_consumed = le16_to_cpu(pSMBr->PathConsumed);\r\nnode->server_type = le16_to_cpu(ref->ServerType);\r\nnode->ref_flag = le16_to_cpu(ref->ReferralEntryFlags);\r\ntemp = (char *)ref + le16_to_cpu(ref->DfsPathOffset);\r\nmax_len = data_end - temp;\r\nnode->path_name = cifs_strndup_from_utf16(temp, max_len,\r\nis_unicode, nls_codepage);\r\nif (!node->path_name) {\r\nrc = -ENOMEM;\r\ngoto parse_DFS_referrals_exit;\r\n}\r\ntemp = (char *)ref + le16_to_cpu(ref->NetworkAddressOffset);\r\nmax_len = data_end - temp;\r\nnode->node_name = cifs_strndup_from_utf16(temp, max_len,\r\nis_unicode, nls_codepage);\r\nif (!node->node_name) {\r\nrc = -ENOMEM;\r\ngoto parse_DFS_referrals_exit;\r\n}\r\nref++;\r\n}\r\nparse_DFS_referrals_exit:\r\nif (rc) {\r\nfree_dfs_info_array(*target_nodes, *num_of_nodes);\r\n*target_nodes = NULL;\r\n*num_of_nodes = 0;\r\n}\r\nreturn rc;\r\n}\r\nint\r\nCIFSGetDFSRefer(const unsigned int xid, struct cifs_ses *ses,\r\nconst char *search_name, struct dfs_info3_param **target_nodes,\r\nunsigned int *num_of_nodes,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nTRANSACTION2_GET_DFS_REFER_REQ *pSMB = NULL;\r\nTRANSACTION2_GET_DFS_REFER_RSP *pSMBr = NULL;\r\nint rc = 0;\r\nint bytes_returned;\r\nint name_len;\r\n__u16 params, byte_count;\r\n*num_of_nodes = 0;\r\n*target_nodes = NULL;\r\ncifs_dbg(FYI, "In GetDFSRefer the path %s\n", search_name);\r\nif (ses == NULL)\r\nreturn -ENODEV;\r\ngetDFSRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, NULL, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\npSMB->hdr.Mid = get_next_mid(ses->server);\r\npSMB->hdr.Tid = ses->ipc_tid;\r\npSMB->hdr.Uid = ses->Suid;\r\nif (ses->capabilities & CAP_STATUS32)\r\npSMB->hdr.Flags2 |= SMBFLG2_ERR_STATUS;\r\nif (ses->capabilities & CAP_DFS)\r\npSMB->hdr.Flags2 |= SMBFLG2_DFS;\r\nif (ses->capabilities & CAP_UNICODE) {\r\npSMB->hdr.Flags2 |= SMBFLG2_UNICODE;\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->RequestFileName,\r\nsearch_name, PATH_MAX, nls_codepage,\r\nremap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(search_name, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->RequestFileName, search_name, name_len);\r\n}\r\nif (ses->server && ses->server->sign)\r\npSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\r\npSMB->hdr.Uid = ses->Suid;\r\nparams = 2 + name_len ;\r\npSMB->TotalDataCount = 0;\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->MaxParameterCount = 0;\r\npSMB->MaxDataCount = cpu_to_le16(4000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\npSMB->ParameterOffset = cpu_to_le16(offsetof(\r\nstruct smb_com_transaction2_get_dfs_refer_req, MaxReferralLevel) - 4);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_GET_DFS_REFERRAL);\r\nbyte_count = params + 3 ;\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->MaxReferralLevel = cpu_to_le16(3);\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in GetDFSRefer = %d\n", rc);\r\ngoto GetDFSRefExit;\r\n}\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < 17) {\r\nrc = -EIO;\r\ngoto GetDFSRefExit;\r\n}\r\ncifs_dbg(FYI, "Decoding GetDFSRefer response BCC: %d Offset %d\n",\r\nget_bcc(&pSMBr->hdr), le16_to_cpu(pSMBr->t2.DataOffset));\r\nrc = parse_DFS_referrals(pSMBr, num_of_nodes,\r\ntarget_nodes, nls_codepage, remap,\r\nsearch_name);\r\nGetDFSRefExit:\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto getDFSRetry;\r\nreturn rc;\r\n}\r\nint\r\nSMBOldQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct kstatfs *FSData)\r\n{\r\nTRANSACTION2_QFSI_REQ *pSMB = NULL;\r\nTRANSACTION2_QFSI_RSP *pSMBr = NULL;\r\nFILE_SYSTEM_ALLOC_INFO *response_data;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\n__u16 params, byte_count;\r\ncifs_dbg(FYI, "OldQFSInfo\n");\r\noldQFSInfoRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nparams = 2;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nbyte_count = params + 1 ;\r\npSMB->TotalParameterCount = cpu_to_le16(params);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(offsetof(\r\nstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\r\npSMB->InformationLevel = cpu_to_le16(SMB_INFO_ALLOCATION);\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in QFSInfo = %d\n", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < 18)\r\nrc = -EIO;\r\nelse {\r\n__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\ncifs_dbg(FYI, "qfsinf resp BCC: %d Offset %d\n",\r\nget_bcc(&pSMBr->hdr), data_offset);\r\nresponse_data = (FILE_SYSTEM_ALLOC_INFO *)\r\n(((char *) &pSMBr->hdr.Protocol) + data_offset);\r\nFSData->f_bsize =\r\nle16_to_cpu(response_data->BytesPerSector) *\r\nle32_to_cpu(response_data->\r\nSectorsPerAllocationUnit);\r\nFSData->f_blocks =\r\nle32_to_cpu(response_data->TotalAllocationUnits);\r\nFSData->f_bfree = FSData->f_bavail =\r\nle32_to_cpu(response_data->FreeAllocationUnits);\r\ncifs_dbg(FYI, "Blocks: %lld Free: %lld Block size %ld\n",\r\n(unsigned long long)FSData->f_blocks,\r\n(unsigned long long)FSData->f_bfree,\r\nFSData->f_bsize);\r\n}\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto oldQFSInfoRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct kstatfs *FSData)\r\n{\r\nTRANSACTION2_QFSI_REQ *pSMB = NULL;\r\nTRANSACTION2_QFSI_RSP *pSMBr = NULL;\r\nFILE_SYSTEM_INFO *response_data;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\n__u16 params, byte_count;\r\ncifs_dbg(FYI, "In QFSInfo\n");\r\nQFSInfoRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nparams = 2;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nbyte_count = params + 1 ;\r\npSMB->TotalParameterCount = cpu_to_le16(params);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(offsetof(\r\nstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\r\npSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_SIZE_INFO);\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in QFSInfo = %d\n", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < 24)\r\nrc = -EIO;\r\nelse {\r\n__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\nresponse_data =\r\n(FILE_SYSTEM_INFO\r\n*) (((char *) &pSMBr->hdr.Protocol) +\r\ndata_offset);\r\nFSData->f_bsize =\r\nle32_to_cpu(response_data->BytesPerSector) *\r\nle32_to_cpu(response_data->\r\nSectorsPerAllocationUnit);\r\nFSData->f_blocks =\r\nle64_to_cpu(response_data->TotalAllocationUnits);\r\nFSData->f_bfree = FSData->f_bavail =\r\nle64_to_cpu(response_data->FreeAllocationUnits);\r\ncifs_dbg(FYI, "Blocks: %lld Free: %lld Block size %ld\n",\r\n(unsigned long long)FSData->f_blocks,\r\n(unsigned long long)FSData->f_bfree,\r\nFSData->f_bsize);\r\n}\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto QFSInfoRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBQFSAttributeInfo(const unsigned int xid, struct cifs_tcon *tcon)\r\n{\r\nTRANSACTION2_QFSI_REQ *pSMB = NULL;\r\nTRANSACTION2_QFSI_RSP *pSMBr = NULL;\r\nFILE_SYSTEM_ATTRIBUTE_INFO *response_data;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\n__u16 params, byte_count;\r\ncifs_dbg(FYI, "In QFSAttributeInfo\n");\r\nQFSAttributeRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nparams = 2;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nbyte_count = params + 1 ;\r\npSMB->TotalParameterCount = cpu_to_le16(params);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(offsetof(\r\nstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\r\npSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_ATTRIBUTE_INFO);\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(VFS, "Send error in QFSAttributeInfo = %d\n", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < 13) {\r\nrc = -EIO;\r\n} else {\r\n__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\nresponse_data =\r\n(FILE_SYSTEM_ATTRIBUTE_INFO\r\n*) (((char *) &pSMBr->hdr.Protocol) +\r\ndata_offset);\r\nmemcpy(&tcon->fsAttrInfo, response_data,\r\nsizeof(FILE_SYSTEM_ATTRIBUTE_INFO));\r\n}\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto QFSAttributeRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBQFSDeviceInfo(const unsigned int xid, struct cifs_tcon *tcon)\r\n{\r\nTRANSACTION2_QFSI_REQ *pSMB = NULL;\r\nTRANSACTION2_QFSI_RSP *pSMBr = NULL;\r\nFILE_SYSTEM_DEVICE_INFO *response_data;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\n__u16 params, byte_count;\r\ncifs_dbg(FYI, "In QFSDeviceInfo\n");\r\nQFSDeviceRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nparams = 2;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nbyte_count = params + 1 ;\r\npSMB->TotalParameterCount = cpu_to_le16(params);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(offsetof(\r\nstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\r\npSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_DEVICE_INFO);\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in QFSDeviceInfo = %d\n", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) <\r\nsizeof(FILE_SYSTEM_DEVICE_INFO))\r\nrc = -EIO;\r\nelse {\r\n__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\nresponse_data =\r\n(FILE_SYSTEM_DEVICE_INFO *)\r\n(((char *) &pSMBr->hdr.Protocol) +\r\ndata_offset);\r\nmemcpy(&tcon->fsDevInfo, response_data,\r\nsizeof(FILE_SYSTEM_DEVICE_INFO));\r\n}\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto QFSDeviceRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBQFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon)\r\n{\r\nTRANSACTION2_QFSI_REQ *pSMB = NULL;\r\nTRANSACTION2_QFSI_RSP *pSMBr = NULL;\r\nFILE_SYSTEM_UNIX_INFO *response_data;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\n__u16 params, byte_count;\r\ncifs_dbg(FYI, "In QFSUnixInfo\n");\r\nQFSUnixRetry:\r\nrc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\r\n(void **) &pSMB, (void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nparams = 2;\r\npSMB->TotalDataCount = 0;\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(100);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nbyte_count = params + 1 ;\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(offsetof(struct\r\nsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\r\npSMB->InformationLevel = cpu_to_le16(SMB_QUERY_CIFS_UNIX_INFO);\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(VFS, "Send error in QFSUnixInfo = %d\n", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < 13) {\r\nrc = -EIO;\r\n} else {\r\n__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\nresponse_data =\r\n(FILE_SYSTEM_UNIX_INFO\r\n*) (((char *) &pSMBr->hdr.Protocol) +\r\ndata_offset);\r\nmemcpy(&tcon->fsUnixInfo, response_data,\r\nsizeof(FILE_SYSTEM_UNIX_INFO));\r\n}\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto QFSUnixRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBSetFSUnixInfo(const unsigned int xid, struct cifs_tcon *tcon, __u64 cap)\r\n{\r\nTRANSACTION2_SETFSI_REQ *pSMB = NULL;\r\nTRANSACTION2_SETFSI_RSP *pSMBr = NULL;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\n__u16 params, param_offset, offset, byte_count;\r\ncifs_dbg(FYI, "In SETFSUnixInfo\n");\r\nSETFSUnixRetry:\r\nrc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\r\n(void **) &pSMB, (void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nparams = 4;\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_setfsi_req, FileNum)\r\n- 4;\r\noffset = param_offset + params;\r\npSMB->MaxParameterCount = cpu_to_le16(4);\r\npSMB->MaxDataCount = cpu_to_le16(100);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_FS_INFORMATION);\r\nbyte_count = 1 + params + 12;\r\npSMB->DataCount = cpu_to_le16(12);\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->FileNum = 0;\r\npSMB->InformationLevel = cpu_to_le16(SMB_SET_CIFS_UNIX_INFO);\r\npSMB->ClientUnixMajor = cpu_to_le16(CIFS_UNIX_MAJOR_VERSION);\r\npSMB->ClientUnixMinor = cpu_to_le16(CIFS_UNIX_MINOR_VERSION);\r\npSMB->ClientUnixCap = cpu_to_le64(cap);\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(VFS, "Send error in SETFSUnixInfo = %d\n", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc)\r\nrc = -EIO;\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto SETFSUnixRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBQFSPosixInfo(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct kstatfs *FSData)\r\n{\r\nTRANSACTION2_QFSI_REQ *pSMB = NULL;\r\nTRANSACTION2_QFSI_RSP *pSMBr = NULL;\r\nFILE_SYSTEM_POSIX_INFO *response_data;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\n__u16 params, byte_count;\r\ncifs_dbg(FYI, "In QFSPosixInfo\n");\r\nQFSPosixRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nparams = 2;\r\npSMB->TotalDataCount = 0;\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(100);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nbyte_count = params + 1 ;\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(offsetof(struct\r\nsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\r\npSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_FS_INFO);\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in QFSUnixInfo = %d\n", rc);\r\n} else {\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < 13) {\r\nrc = -EIO;\r\n} else {\r\n__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\nresponse_data =\r\n(FILE_SYSTEM_POSIX_INFO\r\n*) (((char *) &pSMBr->hdr.Protocol) +\r\ndata_offset);\r\nFSData->f_bsize =\r\nle32_to_cpu(response_data->BlockSize);\r\nFSData->f_blocks =\r\nle64_to_cpu(response_data->TotalBlocks);\r\nFSData->f_bfree =\r\nle64_to_cpu(response_data->BlocksAvail);\r\nif (response_data->UserBlocksAvail == cpu_to_le64(-1)) {\r\nFSData->f_bavail = FSData->f_bfree;\r\n} else {\r\nFSData->f_bavail =\r\nle64_to_cpu(response_data->UserBlocksAvail);\r\n}\r\nif (response_data->TotalFileNodes != cpu_to_le64(-1))\r\nFSData->f_files =\r\nle64_to_cpu(response_data->TotalFileNodes);\r\nif (response_data->FreeFileNodes != cpu_to_le64(-1))\r\nFSData->f_ffree =\r\nle64_to_cpu(response_data->FreeFileNodes);\r\n}\r\n}\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto QFSPosixRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBSetEOF(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *file_name, __u64 size, struct cifs_sb_info *cifs_sb,\r\nbool set_allocation)\r\n{\r\nstruct smb_com_transaction2_spi_req *pSMB = NULL;\r\nstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\r\nstruct file_end_of_file_info *parm_data;\r\nint name_len;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\nint remap = cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR;\r\n__u16 params, byte_count, data_count, param_offset, offset;\r\ncifs_dbg(FYI, "In SetEOF\n");\r\nSetEOFRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName, file_name,\r\nPATH_MAX, cifs_sb->local_nls, remap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(file_name, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, file_name, name_len);\r\n}\r\nparams = 6 + name_len;\r\ndata_count = sizeof(struct file_end_of_file_info);\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(4100);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_spi_req,\r\nInformationLevel) - 4;\r\noffset = param_offset + params;\r\nif (set_allocation) {\r\nif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\r\npSMB->InformationLevel =\r\ncpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO2);\r\nelse\r\npSMB->InformationLevel =\r\ncpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO);\r\n} else {\r\nif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\r\npSMB->InformationLevel =\r\ncpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO2);\r\nelse\r\npSMB->InformationLevel =\r\ncpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO);\r\n}\r\nparm_data =\r\n(struct file_end_of_file_info *) (((char *) &pSMB->hdr.Protocol) +\r\noffset);\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\r\nbyte_count = 3 + params + data_count;\r\npSMB->DataCount = cpu_to_le16(data_count);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\nparm_data->FileSize = cpu_to_le64(size);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc)\r\ncifs_dbg(FYI, "SetPathInfo (file size) returned %d\n", rc);\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto SetEOFRetry;\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBSetFileSize(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifsFileInfo *cfile, __u64 size, bool set_allocation)\r\n{\r\nstruct smb_com_transaction2_sfi_req *pSMB = NULL;\r\nstruct file_end_of_file_info *parm_data;\r\nint rc = 0;\r\n__u16 params, param_offset, offset, byte_count, count;\r\ncifs_dbg(FYI, "SetFileSize (via SetFileInfo) %lld\n",\r\n(long long)size);\r\nrc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\r\nif (rc)\r\nreturn rc;\r\npSMB->hdr.Pid = cpu_to_le16((__u16)cfile->pid);\r\npSMB->hdr.PidHigh = cpu_to_le16((__u16)(cfile->pid >> 16));\r\nparams = 6;\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\r\noffset = param_offset + params;\r\ncount = sizeof(struct file_end_of_file_info);\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\r\nbyte_count = 3 + params + count;\r\npSMB->DataCount = cpu_to_le16(count);\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\nparm_data =\r\n(struct file_end_of_file_info *) (((char *) &pSMB->hdr.Protocol)\r\n+ offset);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\nparm_data->FileSize = cpu_to_le64(size);\r\npSMB->Fid = cfile->fid.netfid;\r\nif (set_allocation) {\r\nif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\r\npSMB->InformationLevel =\r\ncpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO2);\r\nelse\r\npSMB->InformationLevel =\r\ncpu_to_le16(SMB_SET_FILE_ALLOCATION_INFO);\r\n} else {\r\nif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\r\npSMB->InformationLevel =\r\ncpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO2);\r\nelse\r\npSMB->InformationLevel =\r\ncpu_to_le16(SMB_SET_FILE_END_OF_FILE_INFO);\r\n}\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in SetFileInfo (SetFileSize) = %d\n",\r\nrc);\r\n}\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst FILE_BASIC_INFO *data, __u16 fid, __u32 pid_of_opener)\r\n{\r\nstruct smb_com_transaction2_sfi_req *pSMB = NULL;\r\nchar *data_offset;\r\nint rc = 0;\r\n__u16 params, param_offset, offset, byte_count, count;\r\ncifs_dbg(FYI, "Set Times (via SetFileInfo)\n");\r\nrc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\r\nif (rc)\r\nreturn rc;\r\npSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\r\npSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\r\nparams = 6;\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\r\noffset = param_offset + params;\r\ndata_offset = (char *)pSMB +\r\noffsetof(struct smb_hdr, Protocol) + offset;\r\ncount = sizeof(FILE_BASIC_INFO);\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\r\nbyte_count = 3 + params + count;\r\npSMB->DataCount = cpu_to_le16(count);\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->Fid = fid;\r\nif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\r\npSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\r\nelse\r\npSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\r\nrc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\r\nif (rc)\r\ncifs_dbg(FYI, "Send error in Set Time (SetFileInfo) = %d\n",\r\nrc);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBSetFileDisposition(const unsigned int xid, struct cifs_tcon *tcon,\r\nbool delete_file, __u16 fid, __u32 pid_of_opener)\r\n{\r\nstruct smb_com_transaction2_sfi_req *pSMB = NULL;\r\nchar *data_offset;\r\nint rc = 0;\r\n__u16 params, param_offset, offset, byte_count, count;\r\ncifs_dbg(FYI, "Set File Disposition (via SetFileInfo)\n");\r\nrc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\r\nif (rc)\r\nreturn rc;\r\npSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\r\npSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\r\nparams = 6;\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\r\noffset = param_offset + params;\r\ndata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\r\ncount = 1;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\r\nbyte_count = 3 + params + count;\r\npSMB->DataCount = cpu_to_le16(count);\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->Fid = fid;\r\npSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_DISPOSITION_INFO);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\n*data_offset = delete_file ? 1 : 0;\r\nrc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\r\nif (rc)\r\ncifs_dbg(FYI, "Send error in SetFileDisposition = %d\n", rc);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *fileName, const FILE_BASIC_INFO *data,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nTRANSACTION2_SPI_REQ *pSMB = NULL;\r\nTRANSACTION2_SPI_RSP *pSMBr = NULL;\r\nint name_len;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\nchar *data_offset;\r\n__u16 params, param_offset, offset, byte_count, count;\r\ncifs_dbg(FYI, "In SetTimes\n");\r\nSetTimesRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\r\nPATH_MAX, nls_codepage, remap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(fileName, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, fileName, name_len);\r\n}\r\nparams = 6 + name_len;\r\ncount = sizeof(FILE_BASIC_INFO);\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_spi_req,\r\nInformationLevel) - 4;\r\noffset = param_offset + params;\r\ndata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\r\nbyte_count = 3 + params + count;\r\npSMB->DataCount = cpu_to_le16(count);\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\nif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\r\npSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\r\nelse\r\npSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\nmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc)\r\ncifs_dbg(FYI, "SetPathInfo (times) returned %d\n", rc);\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto SetTimesRetry;\r\nreturn rc;\r\n}\r\nstatic void\r\ncifs_fill_unix_set_info(FILE_UNIX_BASIC_INFO *data_offset,\r\nconst struct cifs_unix_set_info_args *args)\r\n{\r\nu64 uid = NO_CHANGE_64, gid = NO_CHANGE_64;\r\nu64 mode = args->mode;\r\nif (uid_valid(args->uid))\r\nuid = from_kuid(&init_user_ns, args->uid);\r\nif (gid_valid(args->gid))\r\ngid = from_kgid(&init_user_ns, args->gid);\r\ndata_offset->EndOfFile = cpu_to_le64(NO_CHANGE_64);\r\ndata_offset->NumOfBytes = cpu_to_le64(NO_CHANGE_64);\r\ndata_offset->LastStatusChange = cpu_to_le64(args->ctime);\r\ndata_offset->LastAccessTime = cpu_to_le64(args->atime);\r\ndata_offset->LastModificationTime = cpu_to_le64(args->mtime);\r\ndata_offset->Uid = cpu_to_le64(uid);\r\ndata_offset->Gid = cpu_to_le64(gid);\r\ndata_offset->DevMajor = cpu_to_le64(MAJOR(args->device));\r\ndata_offset->DevMinor = cpu_to_le64(MINOR(args->device));\r\ndata_offset->Permissions = cpu_to_le64(mode);\r\nif (S_ISREG(mode))\r\ndata_offset->Type = cpu_to_le32(UNIX_FILE);\r\nelse if (S_ISDIR(mode))\r\ndata_offset->Type = cpu_to_le32(UNIX_DIR);\r\nelse if (S_ISLNK(mode))\r\ndata_offset->Type = cpu_to_le32(UNIX_SYMLINK);\r\nelse if (S_ISCHR(mode))\r\ndata_offset->Type = cpu_to_le32(UNIX_CHARDEV);\r\nelse if (S_ISBLK(mode))\r\ndata_offset->Type = cpu_to_le32(UNIX_BLOCKDEV);\r\nelse if (S_ISFIFO(mode))\r\ndata_offset->Type = cpu_to_le32(UNIX_FIFO);\r\nelse if (S_ISSOCK(mode))\r\ndata_offset->Type = cpu_to_le32(UNIX_SOCKET);\r\n}\r\nint\r\nCIFSSMBUnixSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst struct cifs_unix_set_info_args *args,\r\nu16 fid, u32 pid_of_opener)\r\n{\r\nstruct smb_com_transaction2_sfi_req *pSMB = NULL;\r\nchar *data_offset;\r\nint rc = 0;\r\nu16 params, param_offset, offset, byte_count, count;\r\ncifs_dbg(FYI, "Set Unix Info (via SetFileInfo)\n");\r\nrc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\r\nif (rc)\r\nreturn rc;\r\npSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\r\npSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\r\nparams = 6;\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\r\noffset = param_offset + params;\r\ndata_offset = (char *)pSMB +\r\noffsetof(struct smb_hdr, Protocol) + offset;\r\ncount = sizeof(FILE_UNIX_BASIC_INFO);\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\r\nbyte_count = 3 + params + count;\r\npSMB->DataCount = cpu_to_le16(count);\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->Fid = fid;\r\npSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\ncifs_fill_unix_set_info((FILE_UNIX_BASIC_INFO *)data_offset, args);\r\nrc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\r\nif (rc)\r\ncifs_dbg(FYI, "Send error in Set Time (SetFileInfo) = %d\n",\r\nrc);\r\nreturn rc;\r\n}\r\nint\r\nCIFSSMBUnixSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *file_name,\r\nconst struct cifs_unix_set_info_args *args,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nTRANSACTION2_SPI_REQ *pSMB = NULL;\r\nTRANSACTION2_SPI_RSP *pSMBr = NULL;\r\nint name_len;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\nFILE_UNIX_BASIC_INFO *data_offset;\r\n__u16 params, param_offset, offset, count, byte_count;\r\ncifs_dbg(FYI, "In SetUID/GID/Mode\n");\r\nsetPermsRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName, file_name,\r\nPATH_MAX, nls_codepage, remap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(file_name, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, file_name, name_len);\r\n}\r\nparams = 6 + name_len;\r\ncount = sizeof(FILE_UNIX_BASIC_INFO);\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_spi_req,\r\nInformationLevel) - 4;\r\noffset = param_offset + params;\r\ndata_offset =\r\n(FILE_UNIX_BASIC_INFO *) ((char *) &pSMB->hdr.Protocol +\r\noffset);\r\nmemset(data_offset, 0, count);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\r\nbyte_count = 3 + params + count;\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->DataCount = cpu_to_le16(count);\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\ncifs_fill_unix_set_info(data_offset, args);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc)\r\ncifs_dbg(FYI, "SetPathInfo (perms) returned %d\n", rc);\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto setPermsRetry;\r\nreturn rc;\r\n}\r\nssize_t\r\nCIFSSMBQAllEAs(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst unsigned char *searchName, const unsigned char *ea_name,\r\nchar *EAData, size_t buf_size,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nTRANSACTION2_QPI_REQ *pSMB = NULL;\r\nTRANSACTION2_QPI_RSP *pSMBr = NULL;\r\nint rc = 0;\r\nint bytes_returned;\r\nint list_len;\r\nstruct fealist *ea_response_data;\r\nstruct fea *temp_fea;\r\nchar *temp_ptr;\r\nchar *end_of_smb;\r\n__u16 params, byte_count, data_offset;\r\nunsigned int ea_name_len = ea_name ? strlen(ea_name) : 0;\r\ncifs_dbg(FYI, "In Query All EAs path %s\n", searchName);\r\nQAllEAsRetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nlist_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\r\nPATH_MAX, nls_codepage, remap);\r\nlist_len++;\r\nlist_len *= 2;\r\n} else {\r\nlist_len = strnlen(searchName, PATH_MAX);\r\nlist_len++;\r\nstrncpy(pSMB->FileName, searchName, list_len);\r\n}\r\nparams = 2 + 4 + list_len ;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\npSMB->ParameterOffset = cpu_to_le16(offsetof(\r\nstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\r\nbyte_count = params + 1 ;\r\npSMB->TotalParameterCount = cpu_to_le16(params);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\npSMB->InformationLevel = cpu_to_le16(SMB_INFO_QUERY_ALL_EAS);\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc) {\r\ncifs_dbg(FYI, "Send error in QueryAllEAs = %d\n", rc);\r\ngoto QAllEAsOut;\r\n}\r\nrc = validate_t2((struct smb_t2_rsp *)pSMBr);\r\nif (rc || get_bcc(&pSMBr->hdr) < 4) {\r\nrc = -EIO;\r\ngoto QAllEAsOut;\r\n}\r\ndata_offset = le16_to_cpu(pSMBr->t2.DataOffset);\r\nea_response_data = (struct fealist *)\r\n(((char *) &pSMBr->hdr.Protocol) + data_offset);\r\nlist_len = le32_to_cpu(ea_response_data->list_len);\r\ncifs_dbg(FYI, "ea length %d\n", list_len);\r\nif (list_len <= 8) {\r\ncifs_dbg(FYI, "empty EA list returned from server\n");\r\nif (ea_name)\r\nrc = -ENODATA;\r\ngoto QAllEAsOut;\r\n}\r\nend_of_smb = (char *)pByteArea(&pSMBr->hdr) + get_bcc(&pSMBr->hdr);\r\nif ((char *)ea_response_data + list_len > end_of_smb) {\r\ncifs_dbg(FYI, "EA list appears to go beyond SMB\n");\r\nrc = -EIO;\r\ngoto QAllEAsOut;\r\n}\r\nlist_len -= 4;\r\ntemp_fea = ea_response_data->list;\r\ntemp_ptr = (char *)temp_fea;\r\nwhile (list_len > 0) {\r\nunsigned int name_len;\r\n__u16 value_len;\r\nlist_len -= 4;\r\ntemp_ptr += 4;\r\nif (list_len < 0) {\r\ncifs_dbg(FYI, "EA entry goes beyond length of list\n");\r\nrc = -EIO;\r\ngoto QAllEAsOut;\r\n}\r\nname_len = temp_fea->name_len;\r\nvalue_len = le16_to_cpu(temp_fea->value_len);\r\nlist_len -= name_len + 1 + value_len;\r\nif (list_len < 0) {\r\ncifs_dbg(FYI, "EA entry goes beyond length of list\n");\r\nrc = -EIO;\r\ngoto QAllEAsOut;\r\n}\r\nif (ea_name) {\r\nif (ea_name_len == name_len &&\r\nmemcmp(ea_name, temp_ptr, name_len) == 0) {\r\ntemp_ptr += name_len + 1;\r\nrc = value_len;\r\nif (buf_size == 0)\r\ngoto QAllEAsOut;\r\nif ((size_t)value_len > buf_size) {\r\nrc = -ERANGE;\r\ngoto QAllEAsOut;\r\n}\r\nmemcpy(EAData, temp_ptr, value_len);\r\ngoto QAllEAsOut;\r\n}\r\n} else {\r\nrc += (5 + 1 + name_len);\r\nif (rc < (int) buf_size) {\r\nmemcpy(EAData, "user.", 5);\r\nEAData += 5;\r\nmemcpy(EAData, temp_ptr, name_len);\r\nEAData += name_len;\r\n*EAData = 0;\r\n++EAData;\r\n} else if (buf_size == 0) {\r\n} else {\r\nrc = -ERANGE;\r\nbreak;\r\n}\r\n}\r\ntemp_ptr += name_len + 1 + value_len;\r\ntemp_fea = (struct fea *)temp_ptr;\r\n}\r\nif (ea_name)\r\nrc = -ENODATA;\r\nQAllEAsOut:\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto QAllEAsRetry;\r\nreturn (ssize_t)rc;\r\n}\r\nint\r\nCIFSSMBSetEA(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *fileName, const char *ea_name, const void *ea_value,\r\nconst __u16 ea_value_len, const struct nls_table *nls_codepage,\r\nint remap)\r\n{\r\nstruct smb_com_transaction2_spi_req *pSMB = NULL;\r\nstruct smb_com_transaction2_spi_rsp *pSMBr = NULL;\r\nstruct fealist *parm_data;\r\nint name_len;\r\nint rc = 0;\r\nint bytes_returned = 0;\r\n__u16 params, param_offset, byte_count, offset, count;\r\ncifs_dbg(FYI, "In SetEA\n");\r\nSetEARetry:\r\nrc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\nif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\r\nname_len =\r\ncifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\r\nPATH_MAX, nls_codepage, remap);\r\nname_len++;\r\nname_len *= 2;\r\n} else {\r\nname_len = strnlen(fileName, PATH_MAX);\r\nname_len++;\r\nstrncpy(pSMB->FileName, fileName, name_len);\r\n}\r\nparams = 6 + name_len;\r\nif (ea_name == NULL)\r\nname_len = 0;\r\nelse\r\nname_len = strnlen(ea_name, 255);\r\ncount = sizeof(*parm_data) + ea_value_len + name_len;\r\npSMB->MaxParameterCount = cpu_to_le16(2);\r\npSMB->MaxDataCount = cpu_to_le16(1000);\r\npSMB->MaxSetupCount = 0;\r\npSMB->Reserved = 0;\r\npSMB->Flags = 0;\r\npSMB->Timeout = 0;\r\npSMB->Reserved2 = 0;\r\nparam_offset = offsetof(struct smb_com_transaction2_spi_req,\r\nInformationLevel) - 4;\r\noffset = param_offset + params;\r\npSMB->InformationLevel =\r\ncpu_to_le16(SMB_SET_FILE_EA);\r\nparm_data =\r\n(struct fealist *) (((char *) &pSMB->hdr.Protocol) +\r\noffset);\r\npSMB->ParameterOffset = cpu_to_le16(param_offset);\r\npSMB->DataOffset = cpu_to_le16(offset);\r\npSMB->SetupCount = 1;\r\npSMB->Reserved3 = 0;\r\npSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\r\nbyte_count = 3 + params + count;\r\npSMB->DataCount = cpu_to_le16(count);\r\nparm_data->list_len = cpu_to_le32(count);\r\nparm_data->list[0].EA_flags = 0;\r\nparm_data->list[0].name_len = (__u8)name_len;\r\nif (ea_name)\r\nstrncpy(parm_data->list[0].name, ea_name, name_len);\r\nparm_data->list[0].name[name_len] = 0;\r\nparm_data->list[0].value_len = cpu_to_le16(ea_value_len);\r\nif (ea_value_len)\r\nmemcpy(parm_data->list[0].name+name_len+1,\r\nea_value, ea_value_len);\r\npSMB->TotalDataCount = pSMB->DataCount;\r\npSMB->ParameterCount = cpu_to_le16(params);\r\npSMB->TotalParameterCount = pSMB->ParameterCount;\r\npSMB->Reserved4 = 0;\r\ninc_rfc1001_len(pSMB, byte_count);\r\npSMB->ByteCount = cpu_to_le16(byte_count);\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *) pSMBr, &bytes_returned, 0);\r\nif (rc)\r\ncifs_dbg(FYI, "SetPathInfo (EA) returned %d\n", rc);\r\ncifs_buf_release(pSMB);\r\nif (rc == -EAGAIN)\r\ngoto SetEARetry;\r\nreturn rc;\r\n}\r\nint CIFSSMBNotify(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst int notify_subdirs, const __u16 netfid,\r\n__u32 filter, struct file *pfile, int multishot,\r\nconst struct nls_table *nls_codepage)\r\n{\r\nint rc = 0;\r\nstruct smb_com_transaction_change_notify_req *pSMB = NULL;\r\nstruct smb_com_ntransaction_change_notify_rsp *pSMBr = NULL;\r\nstruct dir_notify_req *dnotify_req;\r\nint bytes_returned;\r\ncifs_dbg(FYI, "In CIFSSMBNotify for file handle %d\n", (int)netfid);\r\nrc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\r\n(void **) &pSMBr);\r\nif (rc)\r\nreturn rc;\r\npSMB->TotalParameterCount = 0 ;\r\npSMB->TotalDataCount = 0;\r\npSMB->MaxParameterCount = cpu_to_le32(2);\r\npSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\r\npSMB->MaxSetupCount = 4;\r\npSMB->Reserved = 0;\r\npSMB->ParameterOffset = 0;\r\npSMB->DataCount = 0;\r\npSMB->DataOffset = 0;\r\npSMB->SetupCount = 4;\r\npSMB->SubCommand = cpu_to_le16(NT_TRANSACT_NOTIFY_CHANGE);\r\npSMB->ParameterCount = pSMB->TotalParameterCount;\r\nif (notify_subdirs)\r\npSMB->WatchTree = 1;\r\npSMB->Reserved2 = 0;\r\npSMB->CompletionFilter = cpu_to_le32(filter);\r\npSMB->Fid = netfid;\r\npSMB->ByteCount = 0;\r\nrc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\r\n(struct smb_hdr *)pSMBr, &bytes_returned,\r\nCIFS_ASYNC_OP);\r\nif (rc) {\r\ncifs_dbg(FYI, "Error in Notify = %d\n", rc);\r\n} else {\r\ndnotify_req = kmalloc(\r\nsizeof(struct dir_notify_req),\r\nGFP_KERNEL);\r\nif (dnotify_req) {\r\ndnotify_req->Pid = pSMB->hdr.Pid;\r\ndnotify_req->PidHigh = pSMB->hdr.PidHigh;\r\ndnotify_req->Mid = pSMB->hdr.Mid;\r\ndnotify_req->Tid = pSMB->hdr.Tid;\r\ndnotify_req->Uid = pSMB->hdr.Uid;\r\ndnotify_req->netfid = netfid;\r\ndnotify_req->pfile = pfile;\r\ndnotify_req->filter = filter;\r\ndnotify_req->multishot = multishot;\r\nspin_lock(&GlobalMid_Lock);\r\nlist_add_tail(&dnotify_req->lhead,\r\n&GlobalDnotifyReqList);\r\nspin_unlock(&GlobalMid_Lock);\r\n} else\r\nrc = -ENOMEM;\r\n}\r\ncifs_buf_release(pSMB);\r\nreturn rc;\r\n}
