static int crypto_ctr_setkey(struct crypto_tfm *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_ctr_ctx *ctx = crypto_tfm_ctx(parent);\r\nstruct crypto_cipher *child = ctx->child;\r\nint err;\r\ncrypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_cipher_setkey(child, key, keylen);\r\ncrypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic void crypto_ctr_crypt_final(struct blkcipher_walk *walk,\r\nstruct crypto_cipher *tfm)\r\n{\r\nunsigned int bsize = crypto_cipher_blocksize(tfm);\r\nunsigned long alignmask = crypto_cipher_alignmask(tfm);\r\nu8 *ctrblk = walk->iv;\r\nu8 tmp[bsize + alignmask];\r\nu8 *keystream = PTR_ALIGN(tmp + 0, alignmask + 1);\r\nu8 *src = walk->src.virt.addr;\r\nu8 *dst = walk->dst.virt.addr;\r\nunsigned int nbytes = walk->nbytes;\r\ncrypto_cipher_encrypt_one(tfm, keystream, ctrblk);\r\ncrypto_xor(keystream, src, nbytes);\r\nmemcpy(dst, keystream, nbytes);\r\ncrypto_inc(ctrblk, bsize);\r\n}\r\nstatic int crypto_ctr_crypt_segment(struct blkcipher_walk *walk,\r\nstruct crypto_cipher *tfm)\r\n{\r\nvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *) =\r\ncrypto_cipher_alg(tfm)->cia_encrypt;\r\nunsigned int bsize = crypto_cipher_blocksize(tfm);\r\nu8 *ctrblk = walk->iv;\r\nu8 *src = walk->src.virt.addr;\r\nu8 *dst = walk->dst.virt.addr;\r\nunsigned int nbytes = walk->nbytes;\r\ndo {\r\nfn(crypto_cipher_tfm(tfm), dst, ctrblk);\r\ncrypto_xor(dst, src, bsize);\r\ncrypto_inc(ctrblk, bsize);\r\nsrc += bsize;\r\ndst += bsize;\r\n} while ((nbytes -= bsize) >= bsize);\r\nreturn nbytes;\r\n}\r\nstatic int crypto_ctr_crypt_inplace(struct blkcipher_walk *walk,\r\nstruct crypto_cipher *tfm)\r\n{\r\nvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *) =\r\ncrypto_cipher_alg(tfm)->cia_encrypt;\r\nunsigned int bsize = crypto_cipher_blocksize(tfm);\r\nunsigned long alignmask = crypto_cipher_alignmask(tfm);\r\nunsigned int nbytes = walk->nbytes;\r\nu8 *ctrblk = walk->iv;\r\nu8 *src = walk->src.virt.addr;\r\nu8 tmp[bsize + alignmask];\r\nu8 *keystream = PTR_ALIGN(tmp + 0, alignmask + 1);\r\ndo {\r\nfn(crypto_cipher_tfm(tfm), keystream, ctrblk);\r\ncrypto_xor(src, keystream, bsize);\r\ncrypto_inc(ctrblk, bsize);\r\nsrc += bsize;\r\n} while ((nbytes -= bsize) >= bsize);\r\nreturn nbytes;\r\n}\r\nstatic int crypto_ctr_crypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nstruct crypto_blkcipher *tfm = desc->tfm;\r\nstruct crypto_ctr_ctx *ctx = crypto_blkcipher_ctx(tfm);\r\nstruct crypto_cipher *child = ctx->child;\r\nunsigned int bsize = crypto_cipher_blocksize(child);\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt_block(desc, &walk, bsize);\r\nwhile (walk.nbytes >= bsize) {\r\nif (walk.src.virt.addr == walk.dst.virt.addr)\r\nnbytes = crypto_ctr_crypt_inplace(&walk, child);\r\nelse\r\nnbytes = crypto_ctr_crypt_segment(&walk, child);\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nif (walk.nbytes) {\r\ncrypto_ctr_crypt_final(&walk, child);\r\nerr = blkcipher_walk_done(desc, &walk, 0);\r\n}\r\nreturn err;\r\n}\r\nstatic int crypto_ctr_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct crypto_ctr_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_cipher *cipher;\r\ncipher = crypto_spawn_cipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\nreturn 0;\r\n}\r\nstatic void crypto_ctr_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_ctr_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_cipher(ctx->child);\r\n}\r\nstatic struct crypto_instance *crypto_ctr_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *alg;\r\nint err;\r\nerr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_BLKCIPHER);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nalg = crypto_attr_alg(tb[1], CRYPTO_ALG_TYPE_CIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (IS_ERR(alg))\r\nreturn ERR_CAST(alg);\r\nerr = -EINVAL;\r\nif (alg->cra_blocksize < 4)\r\ngoto out_put_alg;\r\nif (alg->cra_blocksize % 4)\r\ngoto out_put_alg;\r\ninst = crypto_alloc_instance("ctr", alg);\r\nif (IS_ERR(inst))\r\ngoto out;\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;\r\ninst->alg.cra_priority = alg->cra_priority;\r\ninst->alg.cra_blocksize = 1;\r\ninst->alg.cra_alignmask = alg->cra_alignmask | (__alignof__(u32) - 1);\r\ninst->alg.cra_type = &crypto_blkcipher_type;\r\ninst->alg.cra_blkcipher.ivsize = alg->cra_blocksize;\r\ninst->alg.cra_blkcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\r\ninst->alg.cra_blkcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\r\ninst->alg.cra_ctxsize = sizeof(struct crypto_ctr_ctx);\r\ninst->alg.cra_init = crypto_ctr_init_tfm;\r\ninst->alg.cra_exit = crypto_ctr_exit_tfm;\r\ninst->alg.cra_blkcipher.setkey = crypto_ctr_setkey;\r\ninst->alg.cra_blkcipher.encrypt = crypto_ctr_crypt;\r\ninst->alg.cra_blkcipher.decrypt = crypto_ctr_crypt;\r\ninst->alg.cra_blkcipher.geniv = "chainiv";\r\nout:\r\ncrypto_mod_put(alg);\r\nreturn inst;\r\nout_put_alg:\r\ninst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic void crypto_ctr_free(struct crypto_instance *inst)\r\n{\r\ncrypto_drop_spawn(crypto_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nstatic int crypto_rfc3686_setkey(struct crypto_ablkcipher *parent,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct crypto_rfc3686_ctx *ctx = crypto_ablkcipher_ctx(parent);\r\nstruct crypto_ablkcipher *child = ctx->child;\r\nint err;\r\nif (keylen < CTR_RFC3686_NONCE_SIZE)\r\nreturn -EINVAL;\r\nmemcpy(ctx->nonce, key + (keylen - CTR_RFC3686_NONCE_SIZE),\r\nCTR_RFC3686_NONCE_SIZE);\r\nkeylen -= CTR_RFC3686_NONCE_SIZE;\r\ncrypto_ablkcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ablkcipher_set_flags(child, crypto_ablkcipher_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ablkcipher_setkey(child, key, keylen);\r\ncrypto_ablkcipher_set_flags(parent, crypto_ablkcipher_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int crypto_rfc3686_crypt(struct ablkcipher_request *req)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);\r\nstruct crypto_rfc3686_ctx *ctx = crypto_ablkcipher_ctx(tfm);\r\nstruct crypto_ablkcipher *child = ctx->child;\r\nunsigned long align = crypto_ablkcipher_alignmask(tfm);\r\nstruct crypto_rfc3686_req_ctx *rctx =\r\n(void *)PTR_ALIGN((u8 *)ablkcipher_request_ctx(req), align + 1);\r\nstruct ablkcipher_request *subreq = &rctx->subreq;\r\nu8 *iv = rctx->iv;\r\nmemcpy(iv, ctx->nonce, CTR_RFC3686_NONCE_SIZE);\r\nmemcpy(iv + CTR_RFC3686_NONCE_SIZE, req->info, CTR_RFC3686_IV_SIZE);\r\n*(__be32 *)(iv + CTR_RFC3686_NONCE_SIZE + CTR_RFC3686_IV_SIZE) =\r\ncpu_to_be32(1);\r\nablkcipher_request_set_tfm(subreq, child);\r\nablkcipher_request_set_callback(subreq, req->base.flags,\r\nreq->base.complete, req->base.data);\r\nablkcipher_request_set_crypt(subreq, req->src, req->dst, req->nbytes,\r\niv);\r\nreturn crypto_ablkcipher_encrypt(subreq);\r\n}\r\nstatic int crypto_rfc3686_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_skcipher_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct crypto_rfc3686_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_ablkcipher *cipher;\r\nunsigned long align;\r\ncipher = crypto_spawn_skcipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\nalign = crypto_tfm_alg_alignmask(tfm);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ntfm->crt_ablkcipher.reqsize = align +\r\nsizeof(struct crypto_rfc3686_req_ctx) +\r\ncrypto_ablkcipher_reqsize(cipher);\r\nreturn 0;\r\n}\r\nstatic void crypto_rfc3686_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_rfc3686_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_ablkcipher(ctx->child);\r\n}\r\nstatic struct crypto_instance *crypto_rfc3686_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *alg;\r\nstruct crypto_skcipher_spawn *spawn;\r\nconst char *cipher_name;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn ERR_CAST(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_BLKCIPHER) & algt->mask)\r\nreturn ERR_PTR(-EINVAL);\r\ncipher_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(cipher_name))\r\nreturn ERR_CAST(cipher_name);\r\ninst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\r\nif (!inst)\r\nreturn ERR_PTR(-ENOMEM);\r\nspawn = crypto_instance_ctx(inst);\r\ncrypto_set_skcipher_spawn(spawn, inst);\r\nerr = crypto_grab_skcipher(spawn, cipher_name, 0,\r\ncrypto_requires_sync(algt->type,\r\nalgt->mask));\r\nif (err)\r\ngoto err_free_inst;\r\nalg = crypto_skcipher_spawn_alg(spawn);\r\nerr = -EINVAL;\r\nif (alg->cra_ablkcipher.ivsize != CTR_RFC3686_BLOCK_SIZE)\r\ngoto err_drop_spawn;\r\nif (alg->cra_blocksize != 1)\r\ngoto err_drop_spawn;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.cra_name, CRYPTO_MAX_ALG_NAME, "rfc3686(%s)",\r\nalg->cra_name) >= CRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_spawn;\r\nif (snprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc3686(%s)", alg->cra_driver_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_spawn;\r\ninst->alg.cra_priority = alg->cra_priority;\r\ninst->alg.cra_blocksize = 1;\r\ninst->alg.cra_alignmask = alg->cra_alignmask;\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER |\r\n(alg->cra_flags & CRYPTO_ALG_ASYNC);\r\ninst->alg.cra_type = &crypto_ablkcipher_type;\r\ninst->alg.cra_ablkcipher.ivsize = CTR_RFC3686_IV_SIZE;\r\ninst->alg.cra_ablkcipher.min_keysize =\r\nalg->cra_ablkcipher.min_keysize + CTR_RFC3686_NONCE_SIZE;\r\ninst->alg.cra_ablkcipher.max_keysize =\r\nalg->cra_ablkcipher.max_keysize + CTR_RFC3686_NONCE_SIZE;\r\ninst->alg.cra_ablkcipher.geniv = "seqiv";\r\ninst->alg.cra_ablkcipher.setkey = crypto_rfc3686_setkey;\r\ninst->alg.cra_ablkcipher.encrypt = crypto_rfc3686_crypt;\r\ninst->alg.cra_ablkcipher.decrypt = crypto_rfc3686_crypt;\r\ninst->alg.cra_ctxsize = sizeof(struct crypto_rfc3686_ctx);\r\ninst->alg.cra_init = crypto_rfc3686_init_tfm;\r\ninst->alg.cra_exit = crypto_rfc3686_exit_tfm;\r\nreturn inst;\r\nerr_drop_spawn:\r\ncrypto_drop_skcipher(spawn);\r\nerr_free_inst:\r\nkfree(inst);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void crypto_rfc3686_free(struct crypto_instance *inst)\r\n{\r\nstruct crypto_skcipher_spawn *spawn = crypto_instance_ctx(inst);\r\ncrypto_drop_skcipher(spawn);\r\nkfree(inst);\r\n}\r\nstatic int __init crypto_ctr_module_init(void)\r\n{\r\nint err;\r\nerr = crypto_register_template(&crypto_ctr_tmpl);\r\nif (err)\r\ngoto out;\r\nerr = crypto_register_template(&crypto_rfc3686_tmpl);\r\nif (err)\r\ngoto out_drop_ctr;\r\nout:\r\nreturn err;\r\nout_drop_ctr:\r\ncrypto_unregister_template(&crypto_ctr_tmpl);\r\ngoto out;\r\n}\r\nstatic void __exit crypto_ctr_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_rfc3686_tmpl);\r\ncrypto_unregister_template(&crypto_ctr_tmpl);\r\n}
