static int act8865_pdata_from_dt(struct device *dev,\r\nstruct device_node **of_node,\r\nstruct act8865_platform_data *pdata)\r\n{\r\nint matched, i;\r\nstruct device_node *np;\r\nstruct act8865_regulator_data *regulator;\r\nnp = of_get_child_by_name(dev->of_node, "regulators");\r\nif (!np) {\r\ndev_err(dev, "missing 'regulators' subnode in DT\n");\r\nreturn -EINVAL;\r\n}\r\nmatched = of_regulator_match(dev, np,\r\nact8865_matches, ARRAY_SIZE(act8865_matches));\r\nof_node_put(np);\r\nif (matched <= 0)\r\nreturn matched;\r\npdata->regulators = devm_kzalloc(dev,\r\nsizeof(struct act8865_regulator_data) *\r\nARRAY_SIZE(act8865_matches), GFP_KERNEL);\r\nif (!pdata->regulators)\r\nreturn -ENOMEM;\r\npdata->num_regulators = matched;\r\nregulator = pdata->regulators;\r\nfor (i = 0; i < ARRAY_SIZE(act8865_matches); i++) {\r\nregulator->id = i;\r\nregulator->name = act8865_matches[i].name;\r\nregulator->platform_data = act8865_matches[i].init_data;\r\nof_node[i] = act8865_matches[i].of_node;\r\nregulator++;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int act8865_pdata_from_dt(struct device *dev,\r\nstruct device_node **of_node,\r\nstruct act8865_platform_data *pdata)\r\n{\r\nreturn 0;\r\n}\r\nstatic int act8865_pmic_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *i2c_id)\r\n{\r\nstruct regulator_dev *rdev;\r\nstruct device *dev = &client->dev;\r\nstruct act8865_platform_data *pdata = dev_get_platdata(dev);\r\nstruct regulator_config config = { };\r\nstruct act8865 *act8865;\r\nstruct device_node *of_node[ACT8865_REG_NUM];\r\nint i, id;\r\nint ret = -EINVAL;\r\nint error;\r\nif (dev->of_node && !pdata) {\r\nconst struct of_device_id *id;\r\nstruct act8865_platform_data pdata_of;\r\nid = of_match_device(of_match_ptr(act8865_dt_ids), dev);\r\nif (!id)\r\nreturn -ENODEV;\r\nret = act8865_pdata_from_dt(dev, of_node, &pdata_of);\r\nif (ret < 0)\r\nreturn ret;\r\npdata = &pdata_of;\r\n}\r\nif (pdata->num_regulators > ACT8865_REG_NUM) {\r\ndev_err(dev, "Too many regulators found!\n");\r\nreturn -EINVAL;\r\n}\r\nact8865 = devm_kzalloc(dev, sizeof(struct act8865), GFP_KERNEL);\r\nif (!act8865)\r\nreturn -ENOMEM;\r\nact8865->regmap = devm_regmap_init_i2c(client, &act8865_regmap_config);\r\nif (IS_ERR(act8865->regmap)) {\r\nerror = PTR_ERR(act8865->regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nfor (i = 0; i < ACT8865_REG_NUM; i++) {\r\nid = pdata->regulators[i].id;\r\nconfig.dev = dev;\r\nconfig.init_data = pdata->regulators[i].platform_data;\r\nconfig.of_node = of_node[i];\r\nconfig.driver_data = act8865;\r\nconfig.regmap = act8865->regmap;\r\nrdev = devm_regulator_register(&client->dev, &act8865_reg[i],\r\n&config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(dev, "failed to register %s\n",\r\nact8865_reg[id].name);\r\nreturn PTR_ERR(rdev);\r\n}\r\n}\r\ni2c_set_clientdata(client, act8865);\r\nreturn 0;\r\n}
