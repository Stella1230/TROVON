static int __init arcnet_init(void)\r\n{\r\nint count;\r\narcnet_debug = debug;\r\nprintk("arcnet loaded.\n");\r\n#ifdef ALPHA_WARNING\r\nBUGLVL(D_EXTRA) {\r\nprintk("arcnet: ***\n"\r\n"arcnet: * Read arcnet.txt for important release notes!\n"\r\n"arcnet: *\n"\r\n"arcnet: * This is an ALPHA version! (Last stable release: v3.02) E-mail\n"\r\n"arcnet: * me if you have any questions, comments, or bug reports.\n"\r\n"arcnet: ***\n");\r\n}\r\n#endif\r\narc_raw_proto = arc_proto_default = arc_bcast_proto = &arc_proto_null;\r\nfor (count = 0; count < 256; count++)\r\narc_proto_map[count] = arc_proto_default;\r\nBUGLVL(D_DURING)\r\nprintk("arcnet: struct sizes: %Zd %Zd %Zd %Zd %Zd\n",\r\nsizeof(struct arc_hardware), sizeof(struct arc_rfc1201),\r\nsizeof(struct arc_rfc1051), sizeof(struct arc_eth_encap),\r\nsizeof(struct archdr));\r\nreturn 0;\r\n}\r\nstatic void __exit arcnet_exit(void)\r\n{\r\n}\r\nvoid arcnet_dump_skb(struct net_device *dev,\r\nstruct sk_buff *skb, char *desc)\r\n{\r\nchar hdr[32];\r\nsnprintf(hdr, sizeof(hdr), "%6s:%s skb->data:", dev->name, desc);\r\nprint_hex_dump(KERN_DEBUG, hdr, DUMP_PREFIX_OFFSET,\r\n16, 1, skb->data, skb->len, true);\r\n}\r\nstatic void arcnet_dump_packet(struct net_device *dev, int bufnum,\r\nchar *desc, int take_arcnet_lock)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nint i, length;\r\nunsigned long flags = 0;\r\nstatic uint8_t buf[512];\r\nchar hdr[32];\r\nif(take_arcnet_lock)\r\nspin_lock_irqsave(&lp->lock, flags);\r\nlp->hw.copy_from_card(dev, bufnum, 0, buf, 512);\r\nif(take_arcnet_lock)\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nlength = (buf[2] ? 256 : 512);\r\nsnprintf(hdr, sizeof(hdr), "%6s:%s packet dump:", dev->name, desc);\r\nprint_hex_dump(KERN_DEBUG, hdr, DUMP_PREFIX_OFFSET,\r\n16, 1, buf, length, true);\r\n}\r\nvoid arcnet_unregister_proto(struct ArcProto *proto)\r\n{\r\nint count;\r\nif (arc_proto_default == proto)\r\narc_proto_default = &arc_proto_null;\r\nif (arc_bcast_proto == proto)\r\narc_bcast_proto = arc_proto_default;\r\nif (arc_raw_proto == proto)\r\narc_raw_proto = arc_proto_default;\r\nfor (count = 0; count < 256; count++) {\r\nif (arc_proto_map[count] == proto)\r\narc_proto_map[count] = arc_proto_default;\r\n}\r\n}\r\nstatic void release_arcbuf(struct net_device *dev, int bufnum)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nint i;\r\nlp->buf_queue[lp->first_free_buf++] = bufnum;\r\nlp->first_free_buf %= 5;\r\nBUGLVL(D_DURING) {\r\nBUGMSG(D_DURING, "release_arcbuf: freed #%d; buffer queue is now: ",\r\nbufnum);\r\nfor (i = lp->next_buf; i != lp->first_free_buf; i = (i+1) % 5)\r\nBUGMSG2(D_DURING, "#%d ", lp->buf_queue[i]);\r\nBUGMSG2(D_DURING, "\n");\r\n}\r\n}\r\nstatic int get_arcbuf(struct net_device *dev)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nint buf = -1, i;\r\nif (!atomic_dec_and_test(&lp->buf_lock)) {\r\nBUGMSG(D_NORMAL, "get_arcbuf: overlap (%d)!\n",\r\nlp->buf_lock.counter);\r\n}\r\nelse {\r\nif (lp->next_buf >= 5)\r\nlp->next_buf -= 5;\r\nif (lp->next_buf == lp->first_free_buf)\r\nBUGMSG(D_NORMAL, "get_arcbuf: BUG: no buffers are available??\n");\r\nelse {\r\nbuf = lp->buf_queue[lp->next_buf++];\r\nlp->next_buf %= 5;\r\n}\r\n}\r\nBUGLVL(D_DURING) {\r\nBUGMSG(D_DURING, "get_arcbuf: got #%d; buffer queue is now: ", buf);\r\nfor (i = lp->next_buf; i != lp->first_free_buf; i = (i+1) % 5)\r\nBUGMSG2(D_DURING, "#%d ", lp->buf_queue[i]);\r\nBUGMSG2(D_DURING, "\n");\r\n}\r\natomic_inc(&lp->buf_lock);\r\nreturn buf;\r\n}\r\nstatic int choose_mtu(void)\r\n{\r\nint count, mtu = 65535;\r\nfor (count = 0; count < 256; count++) {\r\nif (arc_proto_map[count] != &arc_proto_null &&\r\narc_proto_map[count]->mtu < mtu) {\r\nmtu = arc_proto_map[count]->mtu;\r\n}\r\n}\r\nreturn mtu == 65535 ? XMTU : mtu;\r\n}\r\nstatic void arcdev_setup(struct net_device *dev)\r\n{\r\ndev->type = ARPHRD_ARCNET;\r\ndev->netdev_ops = &arcnet_netdev_ops;\r\ndev->header_ops = &arcnet_header_ops;\r\ndev->hard_header_len = sizeof(struct archdr);\r\ndev->mtu = choose_mtu();\r\ndev->addr_len = ARCNET_ALEN;\r\ndev->tx_queue_len = 100;\r\ndev->broadcast[0] = 0x00;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\ndev->flags = IFF_BROADCAST;\r\n}\r\nstruct net_device *alloc_arcdev(const char *name)\r\n{\r\nstruct net_device *dev;\r\ndev = alloc_netdev(sizeof(struct arcnet_local),\r\nname && *name ? name : "arc%d", arcdev_setup);\r\nif(dev) {\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nspin_lock_init(&lp->lock);\r\n}\r\nreturn dev;\r\n}\r\nint arcnet_open(struct net_device *dev)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nint count, newmtu, error;\r\nBUGMSG(D_INIT,"opened.");\r\nif (!try_module_get(lp->hw.owner))\r\nreturn -ENODEV;\r\nBUGLVL(D_PROTO) {\r\nBUGMSG(D_PROTO, "protocol map (default is '%c'): ",\r\narc_proto_default->suffix);\r\nfor (count = 0; count < 256; count++)\r\nBUGMSG2(D_PROTO, "%c", arc_proto_map[count]->suffix);\r\nBUGMSG2(D_PROTO, "\n");\r\n}\r\nBUGMSG(D_INIT, "arcnet_open: resetting card.\n");\r\nerror = -ENODEV;\r\nif (ARCRESET(0) && ARCRESET(1))\r\ngoto out_module_put;\r\nnewmtu = choose_mtu();\r\nif (newmtu < dev->mtu)\r\ndev->mtu = newmtu;\r\nBUGMSG(D_INIT, "arcnet_open: mtu: %d.\n", dev->mtu);\r\nmemset(lp->default_proto, 0, sizeof(lp->default_proto));\r\nfor (count = 0; count < 256; count++) {\r\nif (arc_proto_map[count] == arc_bcast_proto) {\r\nlp->default_proto[0] = count;\r\nbreak;\r\n}\r\n}\r\natomic_set(&lp->buf_lock, 1);\r\nlp->next_buf = lp->first_free_buf = 0;\r\nrelease_arcbuf(dev, 0);\r\nrelease_arcbuf(dev, 1);\r\nrelease_arcbuf(dev, 2);\r\nrelease_arcbuf(dev, 3);\r\nlp->cur_tx = lp->next_tx = -1;\r\nlp->cur_rx = -1;\r\nlp->rfc1201.sequence = 1;\r\nif (lp->hw.open)\r\nlp->hw.open(dev);\r\nif (dev->dev_addr[0] == 0)\r\nBUGMSG(D_NORMAL, "WARNING! Station address 00 is reserved "\r\n"for broadcasts!\n");\r\nelse if (dev->dev_addr[0] == 255)\r\nBUGMSG(D_NORMAL, "WARNING! Station address FF may confuse "\r\n"DOS networking programs!\n");\r\nBUGMSG(D_DEBUG, "%s: %d: %s\n",__FILE__,__LINE__,__func__);\r\nif (ASTATUS() & RESETflag) {\r\nBUGMSG(D_DEBUG, "%s: %d: %s\n",__FILE__,__LINE__,__func__);\r\nACOMMAND(CFLAGScmd | RESETclear);\r\n}\r\nBUGMSG(D_DEBUG, "%s: %d: %s\n",__FILE__,__LINE__,__func__);\r\nAINTMASK(0);\r\nudelay(1);\r\nBUGMSG(D_DEBUG, "%s: %d: %s\n",__FILE__,__LINE__,__func__);\r\nlp->intmask = NORXflag | RECONflag;\r\nAINTMASK(lp->intmask);\r\nBUGMSG(D_DEBUG, "%s: %d: %s\n",__FILE__,__LINE__,__func__);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nout_module_put:\r\nmodule_put(lp->hw.owner);\r\nreturn error;\r\n}\r\nint arcnet_close(struct net_device *dev)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nAINTMASK(0);\r\nACOMMAND(NOTXcmd);\r\nACOMMAND(NORXcmd);\r\nmdelay(1);\r\nlp->hw.close(dev);\r\nmodule_put(lp->hw.owner);\r\nreturn 0;\r\n}\r\nstatic int arcnet_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, const void *daddr,\r\nconst void *saddr, unsigned len)\r\n{\r\nconst struct arcnet_local *lp = netdev_priv(dev);\r\nuint8_t _daddr, proto_num;\r\nstruct ArcProto *proto;\r\nBUGMSG(D_DURING,\r\n"create header from %d to %d; protocol %d (%Xh); size %u.\n",\r\nsaddr ? *(uint8_t *) saddr : -1,\r\ndaddr ? *(uint8_t *) daddr : -1,\r\ntype, type, len);\r\nif (skb->len!=0 && len != skb->len)\r\nBUGMSG(D_NORMAL, "arcnet_header: Yikes! skb->len(%d) != len(%d)!\n",\r\nskb->len, len);\r\nif(type == ETH_P_ARCNET) {\r\nproto = arc_raw_proto;\r\nBUGMSG(D_DEBUG, "arc_raw_proto used. proto='%c'\n",proto->suffix);\r\n_daddr = daddr ? *(uint8_t *) daddr : 0;\r\n}\r\nelse if (!daddr) {\r\n*(uint16_t *) skb_push(skb, 2) = type;\r\nif (skb->network_header - skb->mac_header != 2)\r\nBUGMSG(D_NORMAL, "arcnet_header: Yikes! diff (%d) is not 2!\n",\r\n(int)(skb->network_header - skb->mac_header));\r\nreturn -2;\r\n}\r\nelse {\r\n_daddr = *(uint8_t *) daddr;\r\nproto_num = lp->default_proto[_daddr];\r\nproto = arc_proto_map[proto_num];\r\nBUGMSG(D_DURING, "building header for %02Xh using protocol '%c'\n",\r\nproto_num, proto->suffix);\r\nif (proto == &arc_proto_null && arc_bcast_proto != proto) {\r\nBUGMSG(D_DURING, "actually, let's use '%c' instead.\n",\r\narc_bcast_proto->suffix);\r\nproto = arc_bcast_proto;\r\n}\r\n}\r\nreturn proto->build_header(skb, dev, type, _daddr);\r\n}\r\nstatic int arcnet_rebuild_header(struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nint status = 0;\r\nunsigned short type;\r\nuint8_t daddr=0;\r\nstruct ArcProto *proto;\r\nif (skb->network_header - skb->mac_header != 2) {\r\nBUGMSG(D_NORMAL,\r\n"rebuild_header: shouldn't be here! (hdrsize=%d)\n",\r\n(int)(skb->network_header - skb->mac_header));\r\nreturn 0;\r\n}\r\ntype = *(uint16_t *) skb_pull(skb, 2);\r\nBUGMSG(D_DURING, "rebuild header for protocol %Xh\n", type);\r\nif (type == ETH_P_IP) {\r\n#ifdef CONFIG_INET\r\nBUGMSG(D_DURING, "rebuild header for ethernet protocol %Xh\n", type);\r\nstatus = arp_find(&daddr, skb) ? 1 : 0;\r\nBUGMSG(D_DURING, " rebuilt: dest is %d; protocol %Xh\n",\r\ndaddr, type);\r\n#endif\r\n} else {\r\nBUGMSG(D_NORMAL,\r\n"I don't understand ethernet protocol %Xh addresses!\n", type);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\n}\r\nif (!status)\r\nreturn 0;\r\nproto = arc_proto_map[lp->default_proto[daddr]];\r\nproto->build_header(skb, dev, type, daddr);\r\nreturn 1;\r\n}\r\nnetdev_tx_t arcnet_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nstruct archdr *pkt;\r\nstruct arc_rfc1201 *soft;\r\nstruct ArcProto *proto;\r\nint txbuf;\r\nunsigned long flags;\r\nint freeskb, retval;\r\nBUGMSG(D_DURING,\r\n"transmit requested (status=%Xh, txbufs=%d/%d, len=%d, protocol %x)\n",\r\nASTATUS(), lp->cur_tx, lp->next_tx, skb->len,skb->protocol);\r\npkt = (struct archdr *) skb->data;\r\nsoft = &pkt->soft.rfc1201;\r\nproto = arc_proto_map[soft->proto];\r\nBUGMSG(D_SKB_SIZE, "skb: transmitting %d bytes to %02X\n",\r\nskb->len, pkt->hard.dest);\r\nBUGLVL(D_SKB) arcnet_dump_skb(dev, skb, "tx");\r\nif (skb->len - ARC_HDR_SIZE > XMTU && !proto->continue_tx) {\r\nBUGMSG(D_NORMAL, "fixme: packet too large: compensating badly!\n");\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nAINTMASK(0);\r\nif(lp->next_tx == -1)\r\ntxbuf = get_arcbuf(dev);\r\nelse {\r\ntxbuf = -1;\r\n}\r\nif (txbuf != -1) {\r\nif (proto->prepare_tx(dev, pkt, skb->len, txbuf) &&\r\n!proto->ack_tx) {\r\ndev->stats.tx_bytes += skb->len;\r\nfreeskb = 1;\r\n} else {\r\nlp->outgoing.proto = proto;\r\nlp->outgoing.skb = skb;\r\nlp->outgoing.pkt = pkt;\r\nfreeskb = 0;\r\nif (proto->continue_tx &&\r\nproto->continue_tx(dev, txbuf)) {\r\nBUGMSG(D_NORMAL,\r\n"bug! continue_tx finished the first time! "\r\n"(proto='%c')\n", proto->suffix);\r\n}\r\n}\r\nretval = NETDEV_TX_OK;\r\nlp->next_tx = txbuf;\r\n} else {\r\nretval = NETDEV_TX_BUSY;\r\nfreeskb = 0;\r\n}\r\nBUGMSG(D_DEBUG, "%s: %d: %s, status: %x\n",__FILE__,__LINE__,__func__,ASTATUS());\r\nAINTMASK(0);\r\nBUGMSG(D_DEBUG, "%s: %d: %s\n",__FILE__,__LINE__,__func__);\r\nlp->intmask |= TXFREEflag|EXCNAKflag;\r\nAINTMASK(lp->intmask);\r\nBUGMSG(D_DEBUG, "%s: %d: %s, status: %x\n",__FILE__,__LINE__,__func__,ASTATUS());\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nif (freeskb) {\r\ndev_kfree_skb(skb);\r\n}\r\nreturn retval;\r\n}\r\nstatic int go_tx(struct net_device *dev)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nBUGMSG(D_DURING, "go_tx: status=%Xh, intmask=%Xh, next_tx=%d, cur_tx=%d\n",\r\nASTATUS(), lp->intmask, lp->next_tx, lp->cur_tx);\r\nif (lp->cur_tx != -1 || lp->next_tx == -1)\r\nreturn 0;\r\nBUGLVL(D_TX) arcnet_dump_packet(dev, lp->next_tx, "go_tx", 0);\r\nlp->cur_tx = lp->next_tx;\r\nlp->next_tx = -1;\r\nACOMMAND(TXcmd | (lp->cur_tx << 3));\r\ndev->stats.tx_packets++;\r\nlp->lasttrans_dest = lp->lastload_dest;\r\nlp->lastload_dest = 0;\r\nlp->excnak_pending = 0;\r\nlp->intmask |= TXFREEflag|EXCNAKflag;\r\nreturn 1;\r\n}\r\nvoid arcnet_timeout(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nint status = ASTATUS();\r\nchar *msg;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (status & TXFREEflag) {\r\nmsg = " - missed IRQ?";\r\n} else {\r\nmsg = "";\r\ndev->stats.tx_aborted_errors++;\r\nlp->timed_out = 1;\r\nACOMMAND(NOTXcmd | (lp->cur_tx << 3));\r\n}\r\ndev->stats.tx_errors++;\r\nAINTMASK(0);\r\nlp->intmask |= TXFREEflag|EXCNAKflag;\r\nAINTMASK(lp->intmask);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nif (time_after(jiffies, lp->last_timeout + 10*HZ)) {\r\nBUGMSG(D_EXTRA, "tx timed out%s (status=%Xh, intmask=%Xh, dest=%02Xh)\n",\r\nmsg, status, lp->intmask, lp->lasttrans_dest);\r\nlp->last_timeout = jiffies;\r\n}\r\nif (lp->cur_tx == -1)\r\nnetif_wake_queue(dev);\r\n}\r\nirqreturn_t arcnet_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct arcnet_local *lp;\r\nint recbuf, status, diagstatus, didsomething, boguscount;\r\nint retval = IRQ_NONE;\r\nBUGMSG(D_DURING, "\n");\r\nBUGMSG(D_DURING, "in arcnet_interrupt\n");\r\nlp = netdev_priv(dev);\r\nBUG_ON(!lp);\r\nspin_lock(&lp->lock);\r\nif (!netif_running(dev)) {\r\nif (ASTATUS() & RESETflag)\r\nACOMMAND(CFLAGScmd | RESETclear);\r\nAINTMASK(0);\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nBUGMSG(D_DURING, "in arcnet_inthandler (status=%Xh, intmask=%Xh)\n",\r\nASTATUS(), lp->intmask);\r\nboguscount = 5;\r\ndo {\r\nstatus = ASTATUS();\r\ndiagstatus = (status >> 8) & 0xFF;\r\nBUGMSG(D_DEBUG, "%s: %d: %s: status=%x\n",\r\n__FILE__,__LINE__,__func__,status);\r\ndidsomething = 0;\r\nif (status & RESETflag) {\r\nBUGMSG(D_NORMAL, "spurious reset (status=%Xh)\n", status);\r\narcnet_close(dev);\r\narcnet_open(dev);\r\nbreak;\r\n}\r\nrecbuf = -1;\r\nif (status & lp->intmask & NORXflag) {\r\nrecbuf = lp->cur_rx;\r\nBUGMSG(D_DURING, "Buffer #%d: receive irq (status=%Xh)\n",\r\nrecbuf, status);\r\nlp->cur_rx = get_arcbuf(dev);\r\nif (lp->cur_rx != -1) {\r\nBUGMSG(D_DURING, "enabling receive to buffer #%d\n",\r\nlp->cur_rx);\r\nACOMMAND(RXcmd | (lp->cur_rx << 3) | RXbcasts);\r\n}\r\ndidsomething++;\r\n}\r\nif((diagstatus & EXCNAKflag)) {\r\nBUGMSG(D_DURING, "EXCNAK IRQ (diagstat=%Xh)\n",\r\ndiagstatus);\r\nACOMMAND(NOTXcmd);\r\nlp->excnak_pending = 1;\r\nACOMMAND(EXCNAKclear);\r\nlp->intmask &= ~(EXCNAKflag);\r\ndidsomething++;\r\n}\r\nif ((status & lp->intmask & TXFREEflag) || lp->timed_out) {\r\nlp->intmask &= ~(TXFREEflag|EXCNAKflag);\r\nBUGMSG(D_DURING, "TX IRQ (stat=%Xh)\n", status);\r\nif (lp->cur_tx != -1 && !lp->timed_out) {\r\nif(!(status & TXACKflag)) {\r\nif (lp->lasttrans_dest != 0) {\r\nBUGMSG(D_EXTRA,\r\n"transmit was not acknowledged! "\r\n"(status=%Xh, dest=%02Xh)\n",\r\nstatus, lp->lasttrans_dest);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_carrier_errors++;\r\n} else {\r\nBUGMSG(D_DURING,\r\n"broadcast was not acknowledged; that's normal "\r\n"(status=%Xh, dest=%02Xh)\n",\r\nstatus, lp->lasttrans_dest);\r\n}\r\n}\r\nif (lp->outgoing.proto &&\r\nlp->outgoing.proto->ack_tx) {\r\nint ackstatus;\r\nif(status & TXACKflag)\r\nackstatus=2;\r\nelse if(lp->excnak_pending)\r\nackstatus=1;\r\nelse\r\nackstatus=0;\r\nlp->outgoing.proto\r\n->ack_tx(dev, ackstatus);\r\n}\r\n}\r\nif (lp->cur_tx != -1)\r\nrelease_arcbuf(dev, lp->cur_tx);\r\nlp->cur_tx = -1;\r\nlp->timed_out = 0;\r\ndidsomething++;\r\ngo_tx(dev);\r\nif (lp->outgoing.proto && lp->outgoing.proto->continue_tx) {\r\nint txbuf = get_arcbuf(dev);\r\nif (txbuf != -1) {\r\nif (lp->outgoing.proto->continue_tx(dev, txbuf)) {\r\ndev->stats.tx_bytes += lp->outgoing.skb->len;\r\nif(!lp->outgoing.proto->ack_tx)\r\n{\r\ndev_kfree_skb_irq(lp->outgoing.skb);\r\nlp->outgoing.proto = NULL;\r\n}\r\n}\r\nlp->next_tx = txbuf;\r\n}\r\n}\r\nif (lp->cur_tx == -1)\r\nnetif_wake_queue(dev);\r\n}\r\nif (recbuf != -1) {\r\nBUGLVL(D_RX) arcnet_dump_packet(dev, recbuf, "rx irq", 0);\r\narcnet_rx(dev, recbuf);\r\nrelease_arcbuf(dev, recbuf);\r\ndidsomething++;\r\n}\r\nif (status & lp->intmask & RECONflag) {\r\nACOMMAND(CFLAGScmd | CONFIGclear);\r\ndev->stats.tx_carrier_errors++;\r\nBUGMSG(D_RECON, "Network reconfiguration detected (status=%Xh)\n",\r\nstatus);\r\nif(diagstatus & 0x80)\r\nBUGMSG(D_RECON,"Put out that recon myself\n");\r\nif (!lp->first_recon || !lp->last_recon ||\r\ntime_after(jiffies, lp->last_recon + HZ * 10)) {\r\nif (lp->network_down)\r\nBUGMSG(D_NORMAL, "reconfiguration detected: cabling restored?\n");\r\nlp->first_recon = lp->last_recon = jiffies;\r\nlp->num_recons = lp->network_down = 0;\r\nBUGMSG(D_DURING, "recon: clearing counters.\n");\r\n} else {\r\nlp->last_recon = jiffies;\r\nlp->num_recons++;\r\nBUGMSG(D_DURING, "recon: counter=%d, time=%lds, net=%d\n",\r\nlp->num_recons,\r\n(lp->last_recon - lp->first_recon) / HZ,\r\nlp->network_down);\r\nif (!lp->network_down &&\r\n(lp->last_recon - lp->first_recon) <= HZ * 60 &&\r\nlp->num_recons >= RECON_THRESHOLD) {\r\nlp->network_down = 1;\r\nBUGMSG(D_NORMAL, "many reconfigurations detected: cabling problem?\n");\r\n} else if (!lp->network_down &&\r\nlp->last_recon - lp->first_recon > HZ * 60) {\r\nlp->first_recon = lp->last_recon;\r\nlp->num_recons = 1;\r\n}\r\n}\r\n} else if (lp->network_down &&\r\ntime_after(jiffies, lp->last_recon + HZ * 10)) {\r\nif (lp->network_down)\r\nBUGMSG(D_NORMAL, "cabling restored?\n");\r\nlp->first_recon = lp->last_recon = 0;\r\nlp->num_recons = lp->network_down = 0;\r\nBUGMSG(D_DURING, "not recon: clearing counters anyway.\n");\r\n}\r\nif(didsomething) {\r\nretval |= IRQ_HANDLED;\r\n}\r\n}\r\nwhile (--boguscount && didsomething);\r\nBUGMSG(D_DURING, "arcnet_interrupt complete (status=%Xh, count=%d)\n",\r\nASTATUS(), boguscount);\r\nBUGMSG(D_DURING, "\n");\r\nAINTMASK(0);\r\nudelay(1);\r\nAINTMASK(lp->intmask);\r\nspin_unlock(&lp->lock);\r\nreturn retval;\r\n}\r\nstatic void arcnet_rx(struct net_device *dev, int bufnum)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nstruct archdr pkt;\r\nstruct arc_rfc1201 *soft;\r\nint length, ofs;\r\nsoft = &pkt.soft.rfc1201;\r\nlp->hw.copy_from_card(dev, bufnum, 0, &pkt, ARC_HDR_SIZE);\r\nif (pkt.hard.offset[0]) {\r\nofs = pkt.hard.offset[0];\r\nlength = 256 - ofs;\r\n} else {\r\nofs = pkt.hard.offset[1];\r\nlength = 512 - ofs;\r\n}\r\nif (sizeof(pkt.soft) <= length)\r\nlp->hw.copy_from_card(dev, bufnum, ofs, soft, sizeof(pkt.soft));\r\nelse {\r\nmemset(&pkt.soft, 0, sizeof(pkt.soft));\r\nlp->hw.copy_from_card(dev, bufnum, ofs, soft, length);\r\n}\r\nBUGMSG(D_DURING, "Buffer #%d: received packet from %02Xh to %02Xh "\r\n"(%d+4 bytes)\n",\r\nbufnum, pkt.hard.source, pkt.hard.dest, length);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += length + ARC_HDR_SIZE;\r\nif (arc_proto_map[soft->proto]->is_ip) {\r\nBUGLVL(D_PROTO) {\r\nstruct ArcProto\r\n*oldp = arc_proto_map[lp->default_proto[pkt.hard.source]],\r\n*newp = arc_proto_map[soft->proto];\r\nif (oldp != newp) {\r\nBUGMSG(D_PROTO,\r\n"got protocol %02Xh; encap for host %02Xh is now '%c'"\r\n" (was '%c')\n", soft->proto, pkt.hard.source,\r\nnewp->suffix, oldp->suffix);\r\n}\r\n}\r\nlp->default_proto[0] = soft->proto;\r\nlp->default_proto[pkt.hard.source] = soft->proto;\r\n}\r\narc_proto_map[soft->proto]->rx(dev, bufnum, &pkt, length);\r\n}\r\nstatic void null_rx(struct net_device *dev, int bufnum,\r\nstruct archdr *pkthdr, int length)\r\n{\r\nBUGMSG(D_PROTO,\r\n"rx: don't know how to deal with proto %02Xh from host %02Xh.\n",\r\npkthdr->soft.rfc1201.proto, pkthdr->hard.source);\r\n}\r\nstatic int null_build_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, uint8_t daddr)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nBUGMSG(D_PROTO,\r\n"tx: can't build header for encap %02Xh; load a protocol driver.\n",\r\nlp->default_proto[daddr]);\r\nreturn 0;\r\n}\r\nstatic int null_prepare_tx(struct net_device *dev, struct archdr *pkt,\r\nint length, int bufnum)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nstruct arc_hardware newpkt;\r\nBUGMSG(D_PROTO, "tx: no encap for this host; load a protocol driver.\n");\r\nnewpkt.source = newpkt.dest = dev->dev_addr[0];\r\nnewpkt.offset[0] = 0xFF;\r\nlp->hw.copy_to_card(dev, bufnum, 0, &newpkt, ARC_HDR_SIZE);\r\nreturn 1;\r\n}
