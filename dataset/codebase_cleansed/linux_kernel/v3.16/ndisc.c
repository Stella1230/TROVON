static void ndisc_fill_addr_option(struct sk_buff *skb, int type, void *data)\r\n{\r\nint pad = ndisc_addr_option_pad(skb->dev->type);\r\nint data_len = skb->dev->addr_len;\r\nint space = ndisc_opt_addr_space(skb->dev);\r\nu8 *opt = skb_put(skb, space);\r\nopt[0] = type;\r\nopt[1] = space>>3;\r\nmemset(opt + 2, 0, pad);\r\nopt += pad;\r\nspace -= pad;\r\nmemcpy(opt+2, data, data_len);\r\ndata_len += 2;\r\nopt += data_len;\r\nif ((space -= data_len) > 0)\r\nmemset(opt, 0, space);\r\n}\r\nstatic struct nd_opt_hdr *ndisc_next_option(struct nd_opt_hdr *cur,\r\nstruct nd_opt_hdr *end)\r\n{\r\nint type;\r\nif (!cur || !end || cur >= end)\r\nreturn NULL;\r\ntype = cur->nd_opt_type;\r\ndo {\r\ncur = ((void *)cur) + (cur->nd_opt_len << 3);\r\n} while(cur < end && cur->nd_opt_type != type);\r\nreturn cur <= end && cur->nd_opt_type == type ? cur : NULL;\r\n}\r\nstatic inline int ndisc_is_useropt(struct nd_opt_hdr *opt)\r\n{\r\nreturn opt->nd_opt_type == ND_OPT_RDNSS ||\r\nopt->nd_opt_type == ND_OPT_DNSSL;\r\n}\r\nstatic struct nd_opt_hdr *ndisc_next_useropt(struct nd_opt_hdr *cur,\r\nstruct nd_opt_hdr *end)\r\n{\r\nif (!cur || !end || cur >= end)\r\nreturn NULL;\r\ndo {\r\ncur = ((void *)cur) + (cur->nd_opt_len << 3);\r\n} while(cur < end && !ndisc_is_useropt(cur));\r\nreturn cur <= end && ndisc_is_useropt(cur) ? cur : NULL;\r\n}\r\nstruct ndisc_options *ndisc_parse_options(u8 *opt, int opt_len,\r\nstruct ndisc_options *ndopts)\r\n{\r\nstruct nd_opt_hdr *nd_opt = (struct nd_opt_hdr *)opt;\r\nif (!nd_opt || opt_len < 0 || !ndopts)\r\nreturn NULL;\r\nmemset(ndopts, 0, sizeof(*ndopts));\r\nwhile (opt_len) {\r\nint l;\r\nif (opt_len < sizeof(struct nd_opt_hdr))\r\nreturn NULL;\r\nl = nd_opt->nd_opt_len << 3;\r\nif (opt_len < l || l == 0)\r\nreturn NULL;\r\nswitch (nd_opt->nd_opt_type) {\r\ncase ND_OPT_SOURCE_LL_ADDR:\r\ncase ND_OPT_TARGET_LL_ADDR:\r\ncase ND_OPT_MTU:\r\ncase ND_OPT_REDIRECT_HDR:\r\nif (ndopts->nd_opt_array[nd_opt->nd_opt_type]) {\r\nND_PRINTK(2, warn,\r\n"%s: duplicated ND6 option found: type=%d\n",\r\n__func__, nd_opt->nd_opt_type);\r\n} else {\r\nndopts->nd_opt_array[nd_opt->nd_opt_type] = nd_opt;\r\n}\r\nbreak;\r\ncase ND_OPT_PREFIX_INFO:\r\nndopts->nd_opts_pi_end = nd_opt;\r\nif (!ndopts->nd_opt_array[nd_opt->nd_opt_type])\r\nndopts->nd_opt_array[nd_opt->nd_opt_type] = nd_opt;\r\nbreak;\r\n#ifdef CONFIG_IPV6_ROUTE_INFO\r\ncase ND_OPT_ROUTE_INFO:\r\nndopts->nd_opts_ri_end = nd_opt;\r\nif (!ndopts->nd_opts_ri)\r\nndopts->nd_opts_ri = nd_opt;\r\nbreak;\r\n#endif\r\ndefault:\r\nif (ndisc_is_useropt(nd_opt)) {\r\nndopts->nd_useropts_end = nd_opt;\r\nif (!ndopts->nd_useropts)\r\nndopts->nd_useropts = nd_opt;\r\n} else {\r\nND_PRINTK(2, notice,\r\n"%s: ignored unsupported option; type=%d, len=%d\n",\r\n__func__,\r\nnd_opt->nd_opt_type,\r\nnd_opt->nd_opt_len);\r\n}\r\n}\r\nopt_len -= l;\r\nnd_opt = ((void *)nd_opt) + l;\r\n}\r\nreturn ndopts;\r\n}\r\nint ndisc_mc_map(const struct in6_addr *addr, char *buf, struct net_device *dev, int dir)\r\n{\r\nswitch (dev->type) {\r\ncase ARPHRD_ETHER:\r\ncase ARPHRD_IEEE802:\r\ncase ARPHRD_FDDI:\r\nipv6_eth_mc_map(addr, buf);\r\nreturn 0;\r\ncase ARPHRD_ARCNET:\r\nipv6_arcnet_mc_map(addr, buf);\r\nreturn 0;\r\ncase ARPHRD_INFINIBAND:\r\nipv6_ib_mc_map(addr, dev->broadcast, buf);\r\nreturn 0;\r\ncase ARPHRD_IPGRE:\r\nreturn ipv6_ipgre_mc_map(addr, dev->broadcast, buf);\r\ndefault:\r\nif (dir) {\r\nmemcpy(buf, dev->broadcast, dev->addr_len);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic u32 ndisc_hash(const void *pkey,\r\nconst struct net_device *dev,\r\n__u32 *hash_rnd)\r\n{\r\nreturn ndisc_hashfn(pkey, dev, hash_rnd);\r\n}\r\nstatic int ndisc_constructor(struct neighbour *neigh)\r\n{\r\nstruct in6_addr *addr = (struct in6_addr*)&neigh->primary_key;\r\nstruct net_device *dev = neigh->dev;\r\nstruct inet6_dev *in6_dev;\r\nstruct neigh_parms *parms;\r\nbool is_multicast = ipv6_addr_is_multicast(addr);\r\nin6_dev = in6_dev_get(dev);\r\nif (in6_dev == NULL) {\r\nreturn -EINVAL;\r\n}\r\nparms = in6_dev->nd_parms;\r\n__neigh_parms_put(neigh->parms);\r\nneigh->parms = neigh_parms_clone(parms);\r\nneigh->type = is_multicast ? RTN_MULTICAST : RTN_UNICAST;\r\nif (!dev->header_ops) {\r\nneigh->nud_state = NUD_NOARP;\r\nneigh->ops = &ndisc_direct_ops;\r\nneigh->output = neigh_direct_output;\r\n} else {\r\nif (is_multicast) {\r\nneigh->nud_state = NUD_NOARP;\r\nndisc_mc_map(addr, neigh->ha, dev, 1);\r\n} else if (dev->flags&(IFF_NOARP|IFF_LOOPBACK)) {\r\nneigh->nud_state = NUD_NOARP;\r\nmemcpy(neigh->ha, dev->dev_addr, dev->addr_len);\r\nif (dev->flags&IFF_LOOPBACK)\r\nneigh->type = RTN_LOCAL;\r\n} else if (dev->flags&IFF_POINTOPOINT) {\r\nneigh->nud_state = NUD_NOARP;\r\nmemcpy(neigh->ha, dev->broadcast, dev->addr_len);\r\n}\r\nif (dev->header_ops->cache)\r\nneigh->ops = &ndisc_hh_ops;\r\nelse\r\nneigh->ops = &ndisc_generic_ops;\r\nif (neigh->nud_state&NUD_VALID)\r\nneigh->output = neigh->ops->connected_output;\r\nelse\r\nneigh->output = neigh->ops->output;\r\n}\r\nin6_dev_put(in6_dev);\r\nreturn 0;\r\n}\r\nstatic int pndisc_constructor(struct pneigh_entry *n)\r\n{\r\nstruct in6_addr *addr = (struct in6_addr*)&n->key;\r\nstruct in6_addr maddr;\r\nstruct net_device *dev = n->dev;\r\nif (dev == NULL || __in6_dev_get(dev) == NULL)\r\nreturn -EINVAL;\r\naddrconf_addr_solict_mult(addr, &maddr);\r\nipv6_dev_mc_inc(dev, &maddr);\r\nreturn 0;\r\n}\r\nstatic void pndisc_destructor(struct pneigh_entry *n)\r\n{\r\nstruct in6_addr *addr = (struct in6_addr*)&n->key;\r\nstruct in6_addr maddr;\r\nstruct net_device *dev = n->dev;\r\nif (dev == NULL || __in6_dev_get(dev) == NULL)\r\nreturn;\r\naddrconf_addr_solict_mult(addr, &maddr);\r\nipv6_dev_mc_dec(dev, &maddr);\r\n}\r\nstatic struct sk_buff *ndisc_alloc_skb(struct net_device *dev,\r\nint len)\r\n{\r\nint hlen = LL_RESERVED_SPACE(dev);\r\nint tlen = dev->needed_tailroom;\r\nstruct sock *sk = dev_net(dev)->ipv6.ndisc_sk;\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(hlen + sizeof(struct ipv6hdr) + len + tlen, GFP_ATOMIC);\r\nif (!skb) {\r\nND_PRINTK(0, err, "ndisc: %s failed to allocate an skb\n",\r\n__func__);\r\nreturn NULL;\r\n}\r\nskb->protocol = htons(ETH_P_IPV6);\r\nskb->dev = dev;\r\nskb_reserve(skb, hlen + sizeof(struct ipv6hdr));\r\nskb_reset_transport_header(skb);\r\nskb_set_owner_w(skb, sk);\r\nreturn skb;\r\n}\r\nstatic void ip6_nd_hdr(struct sk_buff *skb,\r\nconst struct in6_addr *saddr,\r\nconst struct in6_addr *daddr,\r\nint hop_limit, int len)\r\n{\r\nstruct ipv6hdr *hdr;\r\nskb_push(skb, sizeof(*hdr));\r\nskb_reset_network_header(skb);\r\nhdr = ipv6_hdr(skb);\r\nip6_flow_hdr(hdr, 0, 0);\r\nhdr->payload_len = htons(len);\r\nhdr->nexthdr = IPPROTO_ICMPV6;\r\nhdr->hop_limit = hop_limit;\r\nhdr->saddr = *saddr;\r\nhdr->daddr = *daddr;\r\n}\r\nstatic void ndisc_send_skb(struct sk_buff *skb,\r\nconst struct in6_addr *daddr,\r\nconst struct in6_addr *saddr)\r\n{\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct net *net = dev_net(skb->dev);\r\nstruct sock *sk = net->ipv6.ndisc_sk;\r\nstruct inet6_dev *idev;\r\nint err;\r\nstruct icmp6hdr *icmp6h = icmp6_hdr(skb);\r\nu8 type;\r\ntype = icmp6h->icmp6_type;\r\nif (!dst) {\r\nstruct flowi6 fl6;\r\nicmpv6_flow_init(sk, &fl6, type, saddr, daddr, skb->dev->ifindex);\r\ndst = icmp6_dst_alloc(skb->dev, &fl6);\r\nif (IS_ERR(dst)) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nskb_dst_set(skb, dst);\r\n}\r\nicmp6h->icmp6_cksum = csum_ipv6_magic(saddr, daddr, skb->len,\r\nIPPROTO_ICMPV6,\r\ncsum_partial(icmp6h,\r\nskb->len, 0));\r\nip6_nd_hdr(skb, saddr, daddr, inet6_sk(sk)->hop_limit, skb->len);\r\nrcu_read_lock();\r\nidev = __in6_dev_get(dst->dev);\r\nIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUT, skb->len);\r\nerr = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL, dst->dev,\r\ndst_output);\r\nif (!err) {\r\nICMP6MSGOUT_INC_STATS(net, idev, type);\r\nICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid ndisc_send_na(struct net_device *dev, struct neighbour *neigh,\r\nconst struct in6_addr *daddr,\r\nconst struct in6_addr *solicited_addr,\r\nbool router, bool solicited, bool override, bool inc_opt)\r\n{\r\nstruct sk_buff *skb;\r\nstruct in6_addr tmpaddr;\r\nstruct inet6_ifaddr *ifp;\r\nconst struct in6_addr *src_addr;\r\nstruct nd_msg *msg;\r\nint optlen = 0;\r\nifp = ipv6_get_ifaddr(dev_net(dev), solicited_addr, dev, 1);\r\nif (ifp) {\r\nsrc_addr = solicited_addr;\r\nif (ifp->flags & IFA_F_OPTIMISTIC)\r\noverride = false;\r\ninc_opt |= ifp->idev->cnf.force_tllao;\r\nin6_ifa_put(ifp);\r\n} else {\r\nif (ipv6_dev_get_saddr(dev_net(dev), dev, daddr,\r\ninet6_sk(dev_net(dev)->ipv6.ndisc_sk)->srcprefs,\r\n&tmpaddr))\r\nreturn;\r\nsrc_addr = &tmpaddr;\r\n}\r\nif (!dev->addr_len)\r\ninc_opt = 0;\r\nif (inc_opt)\r\noptlen += ndisc_opt_addr_space(dev);\r\nskb = ndisc_alloc_skb(dev, sizeof(*msg) + optlen);\r\nif (!skb)\r\nreturn;\r\nmsg = (struct nd_msg *)skb_put(skb, sizeof(*msg));\r\n*msg = (struct nd_msg) {\r\n.icmph = {\r\n.icmp6_type = NDISC_NEIGHBOUR_ADVERTISEMENT,\r\n.icmp6_router = router,\r\n.icmp6_solicited = solicited,\r\n.icmp6_override = override,\r\n},\r\n.target = *solicited_addr,\r\n};\r\nif (inc_opt)\r\nndisc_fill_addr_option(skb, ND_OPT_TARGET_LL_ADDR,\r\ndev->dev_addr);\r\nndisc_send_skb(skb, daddr, src_addr);\r\n}\r\nstatic void ndisc_send_unsol_na(struct net_device *dev)\r\n{\r\nstruct inet6_dev *idev;\r\nstruct inet6_ifaddr *ifa;\r\nidev = in6_dev_get(dev);\r\nif (!idev)\r\nreturn;\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry(ifa, &idev->addr_list, if_list) {\r\nndisc_send_na(dev, NULL, &in6addr_linklocal_allnodes, &ifa->addr,\r\n!!idev->cnf.forwarding,\r\nfalse, true,\r\ntrue);\r\n}\r\nread_unlock_bh(&idev->lock);\r\nin6_dev_put(idev);\r\n}\r\nvoid ndisc_send_ns(struct net_device *dev, struct neighbour *neigh,\r\nconst struct in6_addr *solicit,\r\nconst struct in6_addr *daddr, const struct in6_addr *saddr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct in6_addr addr_buf;\r\nint inc_opt = dev->addr_len;\r\nint optlen = 0;\r\nstruct nd_msg *msg;\r\nif (saddr == NULL) {\r\nif (ipv6_get_lladdr(dev, &addr_buf,\r\n(IFA_F_TENTATIVE|IFA_F_OPTIMISTIC)))\r\nreturn;\r\nsaddr = &addr_buf;\r\n}\r\nif (ipv6_addr_any(saddr))\r\ninc_opt = false;\r\nif (inc_opt)\r\noptlen += ndisc_opt_addr_space(dev);\r\nskb = ndisc_alloc_skb(dev, sizeof(*msg) + optlen);\r\nif (!skb)\r\nreturn;\r\nmsg = (struct nd_msg *)skb_put(skb, sizeof(*msg));\r\n*msg = (struct nd_msg) {\r\n.icmph = {\r\n.icmp6_type = NDISC_NEIGHBOUR_SOLICITATION,\r\n},\r\n.target = *solicit,\r\n};\r\nif (inc_opt)\r\nndisc_fill_addr_option(skb, ND_OPT_SOURCE_LL_ADDR,\r\ndev->dev_addr);\r\nndisc_send_skb(skb, daddr, saddr);\r\n}\r\nvoid ndisc_send_rs(struct net_device *dev, const struct in6_addr *saddr,\r\nconst struct in6_addr *daddr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rs_msg *msg;\r\nint send_sllao = dev->addr_len;\r\nint optlen = 0;\r\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\r\nif (send_sllao) {\r\nstruct inet6_ifaddr *ifp = ipv6_get_ifaddr(dev_net(dev), saddr,\r\ndev, 1);\r\nif (ifp) {\r\nif (ifp->flags & IFA_F_OPTIMISTIC) {\r\nsend_sllao = 0;\r\n}\r\nin6_ifa_put(ifp);\r\n} else {\r\nsend_sllao = 0;\r\n}\r\n}\r\n#endif\r\nif (send_sllao)\r\noptlen += ndisc_opt_addr_space(dev);\r\nskb = ndisc_alloc_skb(dev, sizeof(*msg) + optlen);\r\nif (!skb)\r\nreturn;\r\nmsg = (struct rs_msg *)skb_put(skb, sizeof(*msg));\r\n*msg = (struct rs_msg) {\r\n.icmph = {\r\n.icmp6_type = NDISC_ROUTER_SOLICITATION,\r\n},\r\n};\r\nif (send_sllao)\r\nndisc_fill_addr_option(skb, ND_OPT_SOURCE_LL_ADDR,\r\ndev->dev_addr);\r\nndisc_send_skb(skb, daddr, saddr);\r\n}\r\nstatic void ndisc_error_report(struct neighbour *neigh, struct sk_buff *skb)\r\n{\r\ndst_link_failure(skb);\r\nkfree_skb(skb);\r\n}\r\nstatic void ndisc_solicit(struct neighbour *neigh, struct sk_buff *skb)\r\n{\r\nstruct in6_addr *saddr = NULL;\r\nstruct in6_addr mcaddr;\r\nstruct net_device *dev = neigh->dev;\r\nstruct in6_addr *target = (struct in6_addr *)&neigh->primary_key;\r\nint probes = atomic_read(&neigh->probes);\r\nif (skb && ipv6_chk_addr(dev_net(dev), &ipv6_hdr(skb)->saddr, dev, 1))\r\nsaddr = &ipv6_hdr(skb)->saddr;\r\nif ((probes -= NEIGH_VAR(neigh->parms, UCAST_PROBES)) < 0) {\r\nif (!(neigh->nud_state & NUD_VALID)) {\r\nND_PRINTK(1, dbg,\r\n"%s: trying to ucast probe in NUD_INVALID: %pI6\n",\r\n__func__, target);\r\n}\r\nndisc_send_ns(dev, neigh, target, target, saddr);\r\n} else if ((probes -= NEIGH_VAR(neigh->parms, APP_PROBES)) < 0) {\r\nneigh_app_ns(neigh);\r\n} else {\r\naddrconf_addr_solict_mult(target, &mcaddr);\r\nndisc_send_ns(dev, NULL, target, &mcaddr, saddr);\r\n}\r\n}\r\nstatic int pndisc_is_router(const void *pkey,\r\nstruct net_device *dev)\r\n{\r\nstruct pneigh_entry *n;\r\nint ret = -1;\r\nread_lock_bh(&nd_tbl.lock);\r\nn = __pneigh_lookup(&nd_tbl, dev_net(dev), pkey, dev);\r\nif (n)\r\nret = !!(n->flags & NTF_ROUTER);\r\nread_unlock_bh(&nd_tbl.lock);\r\nreturn ret;\r\n}\r\nstatic void ndisc_recv_ns(struct sk_buff *skb)\r\n{\r\nstruct nd_msg *msg = (struct nd_msg *)skb_transport_header(skb);\r\nconst struct in6_addr *saddr = &ipv6_hdr(skb)->saddr;\r\nconst struct in6_addr *daddr = &ipv6_hdr(skb)->daddr;\r\nu8 *lladdr = NULL;\r\nu32 ndoptlen = skb_tail_pointer(skb) - (skb_transport_header(skb) +\r\noffsetof(struct nd_msg, opt));\r\nstruct ndisc_options ndopts;\r\nstruct net_device *dev = skb->dev;\r\nstruct inet6_ifaddr *ifp;\r\nstruct inet6_dev *idev = NULL;\r\nstruct neighbour *neigh;\r\nint dad = ipv6_addr_any(saddr);\r\nbool inc;\r\nint is_router = -1;\r\nif (skb->len < sizeof(struct nd_msg)) {\r\nND_PRINTK(2, warn, "NS: packet too short\n");\r\nreturn;\r\n}\r\nif (ipv6_addr_is_multicast(&msg->target)) {\r\nND_PRINTK(2, warn, "NS: multicast target address\n");\r\nreturn;\r\n}\r\nif (dad && !ipv6_addr_is_solict_mult(daddr)) {\r\nND_PRINTK(2, warn, "NS: bad DAD packet (wrong destination)\n");\r\nreturn;\r\n}\r\nif (!ndisc_parse_options(msg->opt, ndoptlen, &ndopts)) {\r\nND_PRINTK(2, warn, "NS: invalid ND options\n");\r\nreturn;\r\n}\r\nif (ndopts.nd_opts_src_lladdr) {\r\nlladdr = ndisc_opt_addr_data(ndopts.nd_opts_src_lladdr, dev);\r\nif (!lladdr) {\r\nND_PRINTK(2, warn,\r\n"NS: invalid link-layer address length\n");\r\nreturn;\r\n}\r\nif (dad) {\r\nND_PRINTK(2, warn,\r\n"NS: bad DAD packet (link-layer address option)\n");\r\nreturn;\r\n}\r\n}\r\ninc = ipv6_addr_is_multicast(daddr);\r\nifp = ipv6_get_ifaddr(dev_net(dev), &msg->target, dev, 1);\r\nif (ifp) {\r\nif (ifp->flags & (IFA_F_TENTATIVE|IFA_F_OPTIMISTIC)) {\r\nif (dad) {\r\naddrconf_dad_failure(ifp);\r\nreturn;\r\n} else {\r\nif (!(ifp->flags & IFA_F_OPTIMISTIC))\r\ngoto out;\r\n}\r\n}\r\nidev = ifp->idev;\r\n} else {\r\nstruct net *net = dev_net(dev);\r\nidev = in6_dev_get(dev);\r\nif (!idev) {\r\nreturn;\r\n}\r\nif (ipv6_chk_acast_addr(net, dev, &msg->target) ||\r\n(idev->cnf.forwarding &&\r\n(net->ipv6.devconf_all->proxy_ndp || idev->cnf.proxy_ndp) &&\r\n(is_router = pndisc_is_router(&msg->target, dev)) >= 0)) {\r\nif (!(NEIGH_CB(skb)->flags & LOCALLY_ENQUEUED) &&\r\nskb->pkt_type != PACKET_HOST &&\r\ninc &&\r\nNEIGH_VAR(idev->nd_parms, PROXY_DELAY) != 0) {\r\nstruct sk_buff *n = skb_clone(skb, GFP_ATOMIC);\r\nif (n)\r\npneigh_enqueue(&nd_tbl, idev->nd_parms, n);\r\ngoto out;\r\n}\r\n} else\r\ngoto out;\r\n}\r\nif (is_router < 0)\r\nis_router = idev->cnf.forwarding;\r\nif (dad) {\r\nndisc_send_na(dev, NULL, &in6addr_linklocal_allnodes, &msg->target,\r\n!!is_router, false, (ifp != NULL), true);\r\ngoto out;\r\n}\r\nif (inc)\r\nNEIGH_CACHE_STAT_INC(&nd_tbl, rcv_probes_mcast);\r\nelse\r\nNEIGH_CACHE_STAT_INC(&nd_tbl, rcv_probes_ucast);\r\nneigh = __neigh_lookup(&nd_tbl, saddr, dev,\r\n!inc || lladdr || !dev->addr_len);\r\nif (neigh)\r\nneigh_update(neigh, lladdr, NUD_STALE,\r\nNEIGH_UPDATE_F_WEAK_OVERRIDE|\r\nNEIGH_UPDATE_F_OVERRIDE);\r\nif (neigh || !dev->header_ops) {\r\nndisc_send_na(dev, neigh, saddr, &msg->target,\r\n!!is_router,\r\ntrue, (ifp != NULL && inc), inc);\r\nif (neigh)\r\nneigh_release(neigh);\r\n}\r\nout:\r\nif (ifp)\r\nin6_ifa_put(ifp);\r\nelse\r\nin6_dev_put(idev);\r\n}\r\nstatic void ndisc_recv_na(struct sk_buff *skb)\r\n{\r\nstruct nd_msg *msg = (struct nd_msg *)skb_transport_header(skb);\r\nstruct in6_addr *saddr = &ipv6_hdr(skb)->saddr;\r\nconst struct in6_addr *daddr = &ipv6_hdr(skb)->daddr;\r\nu8 *lladdr = NULL;\r\nu32 ndoptlen = skb_tail_pointer(skb) - (skb_transport_header(skb) +\r\noffsetof(struct nd_msg, opt));\r\nstruct ndisc_options ndopts;\r\nstruct net_device *dev = skb->dev;\r\nstruct inet6_ifaddr *ifp;\r\nstruct neighbour *neigh;\r\nif (skb->len < sizeof(struct nd_msg)) {\r\nND_PRINTK(2, warn, "NA: packet too short\n");\r\nreturn;\r\n}\r\nif (ipv6_addr_is_multicast(&msg->target)) {\r\nND_PRINTK(2, warn, "NA: target address is multicast\n");\r\nreturn;\r\n}\r\nif (ipv6_addr_is_multicast(daddr) &&\r\nmsg->icmph.icmp6_solicited) {\r\nND_PRINTK(2, warn, "NA: solicited NA is multicasted\n");\r\nreturn;\r\n}\r\nif (!ndisc_parse_options(msg->opt, ndoptlen, &ndopts)) {\r\nND_PRINTK(2, warn, "NS: invalid ND option\n");\r\nreturn;\r\n}\r\nif (ndopts.nd_opts_tgt_lladdr) {\r\nlladdr = ndisc_opt_addr_data(ndopts.nd_opts_tgt_lladdr, dev);\r\nif (!lladdr) {\r\nND_PRINTK(2, warn,\r\n"NA: invalid link-layer address length\n");\r\nreturn;\r\n}\r\n}\r\nifp = ipv6_get_ifaddr(dev_net(dev), &msg->target, dev, 1);\r\nif (ifp) {\r\nif (skb->pkt_type != PACKET_LOOPBACK\r\n&& (ifp->flags & IFA_F_TENTATIVE)) {\r\naddrconf_dad_failure(ifp);\r\nreturn;\r\n}\r\nif (skb->pkt_type != PACKET_LOOPBACK)\r\nND_PRINTK(1, warn,\r\n"NA: someone advertises our address %pI6 on %s!\n",\r\n&ifp->addr, ifp->idev->dev->name);\r\nin6_ifa_put(ifp);\r\nreturn;\r\n}\r\nneigh = neigh_lookup(&nd_tbl, &msg->target, dev);\r\nif (neigh) {\r\nu8 old_flags = neigh->flags;\r\nstruct net *net = dev_net(dev);\r\nif (neigh->nud_state & NUD_FAILED)\r\ngoto out;\r\nif (lladdr && !memcmp(lladdr, dev->dev_addr, dev->addr_len) &&\r\nnet->ipv6.devconf_all->forwarding && net->ipv6.devconf_all->proxy_ndp &&\r\npneigh_lookup(&nd_tbl, net, &msg->target, dev, 0)) {\r\ngoto out;\r\n}\r\nneigh_update(neigh, lladdr,\r\nmsg->icmph.icmp6_solicited ? NUD_REACHABLE : NUD_STALE,\r\nNEIGH_UPDATE_F_WEAK_OVERRIDE|\r\n(msg->icmph.icmp6_override ? NEIGH_UPDATE_F_OVERRIDE : 0)|\r\nNEIGH_UPDATE_F_OVERRIDE_ISROUTER|\r\n(msg->icmph.icmp6_router ? NEIGH_UPDATE_F_ISROUTER : 0));\r\nif ((old_flags & ~neigh->flags) & NTF_ROUTER) {\r\nrt6_clean_tohost(dev_net(dev), saddr);\r\n}\r\nout:\r\nneigh_release(neigh);\r\n}\r\n}\r\nstatic void ndisc_recv_rs(struct sk_buff *skb)\r\n{\r\nstruct rs_msg *rs_msg = (struct rs_msg *)skb_transport_header(skb);\r\nunsigned long ndoptlen = skb->len - sizeof(*rs_msg);\r\nstruct neighbour *neigh;\r\nstruct inet6_dev *idev;\r\nconst struct in6_addr *saddr = &ipv6_hdr(skb)->saddr;\r\nstruct ndisc_options ndopts;\r\nu8 *lladdr = NULL;\r\nif (skb->len < sizeof(*rs_msg))\r\nreturn;\r\nidev = __in6_dev_get(skb->dev);\r\nif (!idev) {\r\nND_PRINTK(1, err, "RS: can't find in6 device\n");\r\nreturn;\r\n}\r\nif (!idev->cnf.forwarding)\r\ngoto out;\r\nif (ipv6_addr_any(saddr))\r\ngoto out;\r\nif (!ndisc_parse_options(rs_msg->opt, ndoptlen, &ndopts)) {\r\nND_PRINTK(2, notice, "NS: invalid ND option, ignored\n");\r\ngoto out;\r\n}\r\nif (ndopts.nd_opts_src_lladdr) {\r\nlladdr = ndisc_opt_addr_data(ndopts.nd_opts_src_lladdr,\r\nskb->dev);\r\nif (!lladdr)\r\ngoto out;\r\n}\r\nneigh = __neigh_lookup(&nd_tbl, saddr, skb->dev, 1);\r\nif (neigh) {\r\nneigh_update(neigh, lladdr, NUD_STALE,\r\nNEIGH_UPDATE_F_WEAK_OVERRIDE|\r\nNEIGH_UPDATE_F_OVERRIDE|\r\nNEIGH_UPDATE_F_OVERRIDE_ISROUTER);\r\nneigh_release(neigh);\r\n}\r\nout:\r\nreturn;\r\n}\r\nstatic void ndisc_ra_useropt(struct sk_buff *ra, struct nd_opt_hdr *opt)\r\n{\r\nstruct icmp6hdr *icmp6h = (struct icmp6hdr *)skb_transport_header(ra);\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nstruct nduseroptmsg *ndmsg;\r\nstruct net *net = dev_net(ra->dev);\r\nint err;\r\nint base_size = NLMSG_ALIGN(sizeof(struct nduseroptmsg)\r\n+ (opt->nd_opt_len << 3));\r\nsize_t msg_size = base_size + nla_total_size(sizeof(struct in6_addr));\r\nskb = nlmsg_new(msg_size, GFP_ATOMIC);\r\nif (skb == NULL) {\r\nerr = -ENOBUFS;\r\ngoto errout;\r\n}\r\nnlh = nlmsg_put(skb, 0, 0, RTM_NEWNDUSEROPT, base_size, 0);\r\nif (nlh == NULL) {\r\ngoto nla_put_failure;\r\n}\r\nndmsg = nlmsg_data(nlh);\r\nndmsg->nduseropt_family = AF_INET6;\r\nndmsg->nduseropt_ifindex = ra->dev->ifindex;\r\nndmsg->nduseropt_icmp_type = icmp6h->icmp6_type;\r\nndmsg->nduseropt_icmp_code = icmp6h->icmp6_code;\r\nndmsg->nduseropt_opts_len = opt->nd_opt_len << 3;\r\nmemcpy(ndmsg + 1, opt, opt->nd_opt_len << 3);\r\nif (nla_put(skb, NDUSEROPT_SRCADDR, sizeof(struct in6_addr),\r\n&ipv6_hdr(ra)->saddr))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nrtnl_notify(skb, net, 0, RTNLGRP_ND_USEROPT, NULL, GFP_ATOMIC);\r\nreturn;\r\nnla_put_failure:\r\nnlmsg_free(skb);\r\nerr = -EMSGSIZE;\r\nerrout:\r\nrtnl_set_sk_err(net, RTNLGRP_ND_USEROPT, err);\r\n}\r\nstatic void ndisc_router_discovery(struct sk_buff *skb)\r\n{\r\nstruct ra_msg *ra_msg = (struct ra_msg *)skb_transport_header(skb);\r\nstruct neighbour *neigh = NULL;\r\nstruct inet6_dev *in6_dev;\r\nstruct rt6_info *rt = NULL;\r\nint lifetime;\r\nstruct ndisc_options ndopts;\r\nint optlen;\r\nunsigned int pref = 0;\r\n__u8 * opt = (__u8 *)(ra_msg + 1);\r\noptlen = (skb_tail_pointer(skb) - skb_transport_header(skb)) -\r\nsizeof(struct ra_msg);\r\nif (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL)) {\r\nND_PRINTK(2, warn, "RA: source address is not link-local\n");\r\nreturn;\r\n}\r\nif (optlen < 0) {\r\nND_PRINTK(2, warn, "RA: packet too short\n");\r\nreturn;\r\n}\r\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\r\nif (skb->ndisc_nodetype == NDISC_NODETYPE_HOST) {\r\nND_PRINTK(2, warn, "RA: from host or unauthorized router\n");\r\nreturn;\r\n}\r\n#endif\r\nin6_dev = __in6_dev_get(skb->dev);\r\nif (in6_dev == NULL) {\r\nND_PRINTK(0, err, "RA: can't find inet6 device for %s\n",\r\nskb->dev->name);\r\nreturn;\r\n}\r\nif (!ndisc_parse_options(opt, optlen, &ndopts)) {\r\nND_PRINTK(2, warn, "RA: invalid ND options\n");\r\nreturn;\r\n}\r\nif (!ipv6_accept_ra(in6_dev))\r\ngoto skip_linkparms;\r\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\r\nif (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT)\r\ngoto skip_linkparms;\r\n#endif\r\nif (in6_dev->if_flags & IF_RS_SENT) {\r\nin6_dev->if_flags |= IF_RA_RCVD;\r\n}\r\nin6_dev->if_flags = (in6_dev->if_flags & ~(IF_RA_MANAGED |\r\nIF_RA_OTHERCONF)) |\r\n(ra_msg->icmph.icmp6_addrconf_managed ?\r\nIF_RA_MANAGED : 0) |\r\n(ra_msg->icmph.icmp6_addrconf_other ?\r\nIF_RA_OTHERCONF : 0);\r\nif (!in6_dev->cnf.accept_ra_defrtr)\r\ngoto skip_defrtr;\r\nif (ipv6_chk_addr(dev_net(in6_dev->dev), &ipv6_hdr(skb)->saddr, NULL, 0))\r\ngoto skip_defrtr;\r\nlifetime = ntohs(ra_msg->icmph.icmp6_rt_lifetime);\r\n#ifdef CONFIG_IPV6_ROUTER_PREF\r\npref = ra_msg->icmph.icmp6_router_pref;\r\nif (pref == ICMPV6_ROUTER_PREF_INVALID ||\r\n!in6_dev->cnf.accept_ra_rtr_pref)\r\npref = ICMPV6_ROUTER_PREF_MEDIUM;\r\n#endif\r\nrt = rt6_get_dflt_router(&ipv6_hdr(skb)->saddr, skb->dev);\r\nif (rt) {\r\nneigh = dst_neigh_lookup(&rt->dst, &ipv6_hdr(skb)->saddr);\r\nif (!neigh) {\r\nND_PRINTK(0, err,\r\n"RA: %s got default router without neighbour\n",\r\n__func__);\r\nip6_rt_put(rt);\r\nreturn;\r\n}\r\n}\r\nif (rt && lifetime == 0) {\r\nip6_del_rt(rt);\r\nrt = NULL;\r\n}\r\nif (rt == NULL && lifetime) {\r\nND_PRINTK(3, dbg, "RA: adding default router\n");\r\nrt = rt6_add_dflt_router(&ipv6_hdr(skb)->saddr, skb->dev, pref);\r\nif (rt == NULL) {\r\nND_PRINTK(0, err,\r\n"RA: %s failed to add default route\n",\r\n__func__);\r\nreturn;\r\n}\r\nneigh = dst_neigh_lookup(&rt->dst, &ipv6_hdr(skb)->saddr);\r\nif (neigh == NULL) {\r\nND_PRINTK(0, err,\r\n"RA: %s got default router without neighbour\n",\r\n__func__);\r\nip6_rt_put(rt);\r\nreturn;\r\n}\r\nneigh->flags |= NTF_ROUTER;\r\n} else if (rt) {\r\nrt->rt6i_flags = (rt->rt6i_flags & ~RTF_PREF_MASK) | RTF_PREF(pref);\r\n}\r\nif (rt)\r\nrt6_set_expires(rt, jiffies + (HZ * lifetime));\r\nif (ra_msg->icmph.icmp6_hop_limit) {\r\nin6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;\r\nif (rt)\r\ndst_metric_set(&rt->dst, RTAX_HOPLIMIT,\r\nra_msg->icmph.icmp6_hop_limit);\r\n}\r\nskip_defrtr:\r\nif (in6_dev->nd_parms) {\r\nunsigned long rtime = ntohl(ra_msg->retrans_timer);\r\nif (rtime && rtime/1000 < MAX_SCHEDULE_TIMEOUT/HZ) {\r\nrtime = (rtime*HZ)/1000;\r\nif (rtime < HZ/10)\r\nrtime = HZ/10;\r\nNEIGH_VAR_SET(in6_dev->nd_parms, RETRANS_TIME, rtime);\r\nin6_dev->tstamp = jiffies;\r\ninet6_ifinfo_notify(RTM_NEWLINK, in6_dev);\r\n}\r\nrtime = ntohl(ra_msg->reachable_time);\r\nif (rtime && rtime/1000 < MAX_SCHEDULE_TIMEOUT/(3*HZ)) {\r\nrtime = (rtime*HZ)/1000;\r\nif (rtime < HZ/10)\r\nrtime = HZ/10;\r\nif (rtime != NEIGH_VAR(in6_dev->nd_parms, BASE_REACHABLE_TIME)) {\r\nNEIGH_VAR_SET(in6_dev->nd_parms,\r\nBASE_REACHABLE_TIME, rtime);\r\nNEIGH_VAR_SET(in6_dev->nd_parms,\r\nGC_STALETIME, 3 * rtime);\r\nin6_dev->nd_parms->reachable_time = neigh_rand_reach_time(rtime);\r\nin6_dev->tstamp = jiffies;\r\ninet6_ifinfo_notify(RTM_NEWLINK, in6_dev);\r\n}\r\n}\r\n}\r\nskip_linkparms:\r\nif (!neigh)\r\nneigh = __neigh_lookup(&nd_tbl, &ipv6_hdr(skb)->saddr,\r\nskb->dev, 1);\r\nif (neigh) {\r\nu8 *lladdr = NULL;\r\nif (ndopts.nd_opts_src_lladdr) {\r\nlladdr = ndisc_opt_addr_data(ndopts.nd_opts_src_lladdr,\r\nskb->dev);\r\nif (!lladdr) {\r\nND_PRINTK(2, warn,\r\n"RA: invalid link-layer address length\n");\r\ngoto out;\r\n}\r\n}\r\nneigh_update(neigh, lladdr, NUD_STALE,\r\nNEIGH_UPDATE_F_WEAK_OVERRIDE|\r\nNEIGH_UPDATE_F_OVERRIDE|\r\nNEIGH_UPDATE_F_OVERRIDE_ISROUTER|\r\nNEIGH_UPDATE_F_ISROUTER);\r\n}\r\nif (!ipv6_accept_ra(in6_dev))\r\ngoto out;\r\n#ifdef CONFIG_IPV6_ROUTE_INFO\r\nif (ipv6_chk_addr(dev_net(in6_dev->dev), &ipv6_hdr(skb)->saddr, NULL, 0))\r\ngoto skip_routeinfo;\r\nif (in6_dev->cnf.accept_ra_rtr_pref && ndopts.nd_opts_ri) {\r\nstruct nd_opt_hdr *p;\r\nfor (p = ndopts.nd_opts_ri;\r\np;\r\np = ndisc_next_option(p, ndopts.nd_opts_ri_end)) {\r\nstruct route_info *ri = (struct route_info *)p;\r\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\r\nif (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT &&\r\nri->prefix_len == 0)\r\ncontinue;\r\n#endif\r\nif (ri->prefix_len == 0 &&\r\n!in6_dev->cnf.accept_ra_defrtr)\r\ncontinue;\r\nif (ri->prefix_len > in6_dev->cnf.accept_ra_rt_info_max_plen)\r\ncontinue;\r\nrt6_route_rcv(skb->dev, (u8*)p, (p->nd_opt_len) << 3,\r\n&ipv6_hdr(skb)->saddr);\r\n}\r\n}\r\nskip_routeinfo:\r\n#endif\r\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\r\nif (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT)\r\ngoto out;\r\n#endif\r\nif (in6_dev->cnf.accept_ra_pinfo && ndopts.nd_opts_pi) {\r\nstruct nd_opt_hdr *p;\r\nfor (p = ndopts.nd_opts_pi;\r\np;\r\np = ndisc_next_option(p, ndopts.nd_opts_pi_end)) {\r\naddrconf_prefix_rcv(skb->dev, (u8 *)p,\r\n(p->nd_opt_len) << 3,\r\nndopts.nd_opts_src_lladdr != NULL);\r\n}\r\n}\r\nif (ndopts.nd_opts_mtu) {\r\n__be32 n;\r\nu32 mtu;\r\nmemcpy(&n, ((u8*)(ndopts.nd_opts_mtu+1))+2, sizeof(mtu));\r\nmtu = ntohl(n);\r\nif (mtu < IPV6_MIN_MTU || mtu > skb->dev->mtu) {\r\nND_PRINTK(2, warn, "RA: invalid mtu: %d\n", mtu);\r\n} else if (in6_dev->cnf.mtu6 != mtu) {\r\nin6_dev->cnf.mtu6 = mtu;\r\nif (rt)\r\ndst_metric_set(&rt->dst, RTAX_MTU, mtu);\r\nrt6_mtu_change(skb->dev, mtu);\r\n}\r\n}\r\nif (ndopts.nd_useropts) {\r\nstruct nd_opt_hdr *p;\r\nfor (p = ndopts.nd_useropts;\r\np;\r\np = ndisc_next_useropt(p, ndopts.nd_useropts_end)) {\r\nndisc_ra_useropt(skb, p);\r\n}\r\n}\r\nif (ndopts.nd_opts_tgt_lladdr || ndopts.nd_opts_rh) {\r\nND_PRINTK(2, warn, "RA: invalid RA options\n");\r\n}\r\nout:\r\nip6_rt_put(rt);\r\nif (neigh)\r\nneigh_release(neigh);\r\n}\r\nstatic void ndisc_redirect_rcv(struct sk_buff *skb)\r\n{\r\nu8 *hdr;\r\nstruct ndisc_options ndopts;\r\nstruct rd_msg *msg = (struct rd_msg *)skb_transport_header(skb);\r\nu32 ndoptlen = skb_tail_pointer(skb) - (skb_transport_header(skb) +\r\noffsetof(struct rd_msg, opt));\r\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\r\nswitch (skb->ndisc_nodetype) {\r\ncase NDISC_NODETYPE_HOST:\r\ncase NDISC_NODETYPE_NODEFAULT:\r\nND_PRINTK(2, warn,\r\n"Redirect: from host or unauthorized router\n");\r\nreturn;\r\n}\r\n#endif\r\nif (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL)) {\r\nND_PRINTK(2, warn,\r\n"Redirect: source address is not link-local\n");\r\nreturn;\r\n}\r\nif (!ndisc_parse_options(msg->opt, ndoptlen, &ndopts))\r\nreturn;\r\nif (!ndopts.nd_opts_rh) {\r\nip6_redirect_no_header(skb, dev_net(skb->dev),\r\nskb->dev->ifindex, 0);\r\nreturn;\r\n}\r\nhdr = (u8 *)ndopts.nd_opts_rh;\r\nhdr += 8;\r\nif (!pskb_pull(skb, hdr - skb_transport_header(skb)))\r\nreturn;\r\nicmpv6_notify(skb, NDISC_REDIRECT, 0, 0);\r\n}\r\nstatic void ndisc_fill_redirect_hdr_option(struct sk_buff *skb,\r\nstruct sk_buff *orig_skb,\r\nint rd_len)\r\n{\r\nu8 *opt = skb_put(skb, rd_len);\r\nmemset(opt, 0, 8);\r\n*(opt++) = ND_OPT_REDIRECT_HDR;\r\n*(opt++) = (rd_len >> 3);\r\nopt += 6;\r\nmemcpy(opt, ipv6_hdr(orig_skb), rd_len - 8);\r\n}\r\nvoid ndisc_send_redirect(struct sk_buff *skb, const struct in6_addr *target)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nstruct net *net = dev_net(dev);\r\nstruct sock *sk = net->ipv6.ndisc_sk;\r\nint optlen = 0;\r\nstruct inet_peer *peer;\r\nstruct sk_buff *buff;\r\nstruct rd_msg *msg;\r\nstruct in6_addr saddr_buf;\r\nstruct rt6_info *rt;\r\nstruct dst_entry *dst;\r\nstruct flowi6 fl6;\r\nint rd_len;\r\nu8 ha_buf[MAX_ADDR_LEN], *ha = NULL;\r\nbool ret;\r\nif (ipv6_get_lladdr(dev, &saddr_buf, IFA_F_TENTATIVE)) {\r\nND_PRINTK(2, warn, "Redirect: no link-local address on %s\n",\r\ndev->name);\r\nreturn;\r\n}\r\nif (!ipv6_addr_equal(&ipv6_hdr(skb)->daddr, target) &&\r\nipv6_addr_type(target) != (IPV6_ADDR_UNICAST|IPV6_ADDR_LINKLOCAL)) {\r\nND_PRINTK(2, warn,\r\n"Redirect: target address is not link-local unicast\n");\r\nreturn;\r\n}\r\nicmpv6_flow_init(sk, &fl6, NDISC_REDIRECT,\r\n&saddr_buf, &ipv6_hdr(skb)->saddr, dev->ifindex);\r\ndst = ip6_route_output(net, NULL, &fl6);\r\nif (dst->error) {\r\ndst_release(dst);\r\nreturn;\r\n}\r\ndst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);\r\nif (IS_ERR(dst))\r\nreturn;\r\nrt = (struct rt6_info *) dst;\r\nif (rt->rt6i_flags & RTF_GATEWAY) {\r\nND_PRINTK(2, warn,\r\n"Redirect: destination is not a neighbour\n");\r\ngoto release;\r\n}\r\npeer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);\r\nret = inet_peer_xrlim_allow(peer, 1*HZ);\r\nif (peer)\r\ninet_putpeer(peer);\r\nif (!ret)\r\ngoto release;\r\nif (dev->addr_len) {\r\nstruct neighbour *neigh = dst_neigh_lookup(skb_dst(skb), target);\r\nif (!neigh) {\r\nND_PRINTK(2, warn,\r\n"Redirect: no neigh for target address\n");\r\ngoto release;\r\n}\r\nread_lock_bh(&neigh->lock);\r\nif (neigh->nud_state & NUD_VALID) {\r\nmemcpy(ha_buf, neigh->ha, dev->addr_len);\r\nread_unlock_bh(&neigh->lock);\r\nha = ha_buf;\r\noptlen += ndisc_opt_addr_space(dev);\r\n} else\r\nread_unlock_bh(&neigh->lock);\r\nneigh_release(neigh);\r\n}\r\nrd_len = min_t(unsigned int,\r\nIPV6_MIN_MTU - sizeof(struct ipv6hdr) - sizeof(*msg) - optlen,\r\nskb->len + 8);\r\nrd_len &= ~0x7;\r\noptlen += rd_len;\r\nbuff = ndisc_alloc_skb(dev, sizeof(*msg) + optlen);\r\nif (!buff)\r\ngoto release;\r\nmsg = (struct rd_msg *)skb_put(buff, sizeof(*msg));\r\n*msg = (struct rd_msg) {\r\n.icmph = {\r\n.icmp6_type = NDISC_REDIRECT,\r\n},\r\n.target = *target,\r\n.dest = ipv6_hdr(skb)->daddr,\r\n};\r\nif (ha)\r\nndisc_fill_addr_option(buff, ND_OPT_TARGET_LL_ADDR, ha);\r\nif (rd_len)\r\nndisc_fill_redirect_hdr_option(buff, skb, rd_len);\r\nskb_dst_set(buff, dst);\r\nndisc_send_skb(buff, &ipv6_hdr(skb)->saddr, &saddr_buf);\r\nreturn;\r\nrelease:\r\ndst_release(dst);\r\n}\r\nstatic void pndisc_redo(struct sk_buff *skb)\r\n{\r\nndisc_recv_ns(skb);\r\nkfree_skb(skb);\r\n}\r\nstatic bool ndisc_suppress_frag_ndisc(struct sk_buff *skb)\r\n{\r\nstruct inet6_dev *idev = __in6_dev_get(skb->dev);\r\nif (!idev)\r\nreturn true;\r\nif (IP6CB(skb)->flags & IP6SKB_FRAGMENTED &&\r\nidev->cnf.suppress_frag_ndisc) {\r\nnet_warn_ratelimited("Received fragmented ndisc packet. Carefully consider disabling suppress_frag_ndisc.\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint ndisc_rcv(struct sk_buff *skb)\r\n{\r\nstruct nd_msg *msg;\r\nif (ndisc_suppress_frag_ndisc(skb))\r\nreturn 0;\r\nif (skb_linearize(skb))\r\nreturn 0;\r\nmsg = (struct nd_msg *)skb_transport_header(skb);\r\n__skb_push(skb, skb->data - skb_transport_header(skb));\r\nif (ipv6_hdr(skb)->hop_limit != 255) {\r\nND_PRINTK(2, warn, "NDISC: invalid hop-limit: %d\n",\r\nipv6_hdr(skb)->hop_limit);\r\nreturn 0;\r\n}\r\nif (msg->icmph.icmp6_code != 0) {\r\nND_PRINTK(2, warn, "NDISC: invalid ICMPv6 code: %d\n",\r\nmsg->icmph.icmp6_code);\r\nreturn 0;\r\n}\r\nmemset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));\r\nswitch (msg->icmph.icmp6_type) {\r\ncase NDISC_NEIGHBOUR_SOLICITATION:\r\nndisc_recv_ns(skb);\r\nbreak;\r\ncase NDISC_NEIGHBOUR_ADVERTISEMENT:\r\nndisc_recv_na(skb);\r\nbreak;\r\ncase NDISC_ROUTER_SOLICITATION:\r\nndisc_recv_rs(skb);\r\nbreak;\r\ncase NDISC_ROUTER_ADVERTISEMENT:\r\nndisc_router_discovery(skb);\r\nbreak;\r\ncase NDISC_REDIRECT:\r\nndisc_redirect_rcv(skb);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ndisc_netdev_event(struct notifier_block *this, unsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct net *net = dev_net(dev);\r\nstruct inet6_dev *idev;\r\nswitch (event) {\r\ncase NETDEV_CHANGEADDR:\r\nneigh_changeaddr(&nd_tbl, dev);\r\nfib6_run_gc(0, net, false);\r\nidev = in6_dev_get(dev);\r\nif (!idev)\r\nbreak;\r\nif (idev->cnf.ndisc_notify)\r\nndisc_send_unsol_na(dev);\r\nin6_dev_put(idev);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nneigh_ifdown(&nd_tbl, dev);\r\nfib6_run_gc(0, net, false);\r\nbreak;\r\ncase NETDEV_NOTIFY_PEERS:\r\nndisc_send_unsol_na(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void ndisc_warn_deprecated_sysctl(struct ctl_table *ctl,\r\nconst char *func, const char *dev_name)\r\n{\r\nstatic char warncomm[TASK_COMM_LEN];\r\nstatic int warned;\r\nif (strcmp(warncomm, current->comm) && warned < 5) {\r\nstrcpy(warncomm, current->comm);\r\npr_warn("process `%s' is using deprecated sysctl (%s) net.ipv6.neigh.%s.%s - use net.ipv6.neigh.%s.%s_ms instead\n",\r\nwarncomm, func,\r\ndev_name, ctl->procname,\r\ndev_name, ctl->procname);\r\nwarned++;\r\n}\r\n}\r\nint ndisc_ifinfo_sysctl_change(struct ctl_table *ctl, int write, void __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nstruct net_device *dev = ctl->extra1;\r\nstruct inet6_dev *idev;\r\nint ret;\r\nif ((strcmp(ctl->procname, "retrans_time") == 0) ||\r\n(strcmp(ctl->procname, "base_reachable_time") == 0))\r\nndisc_warn_deprecated_sysctl(ctl, "syscall", dev ? dev->name : "default");\r\nif (strcmp(ctl->procname, "retrans_time") == 0)\r\nret = neigh_proc_dointvec(ctl, write, buffer, lenp, ppos);\r\nelse if (strcmp(ctl->procname, "base_reachable_time") == 0)\r\nret = neigh_proc_dointvec_jiffies(ctl, write,\r\nbuffer, lenp, ppos);\r\nelse if ((strcmp(ctl->procname, "retrans_time_ms") == 0) ||\r\n(strcmp(ctl->procname, "base_reachable_time_ms") == 0))\r\nret = neigh_proc_dointvec_ms_jiffies(ctl, write,\r\nbuffer, lenp, ppos);\r\nelse\r\nret = -1;\r\nif (write && ret == 0 && dev && (idev = in6_dev_get(dev)) != NULL) {\r\nif (ctl->data == &NEIGH_VAR(idev->nd_parms, BASE_REACHABLE_TIME))\r\nidev->nd_parms->reachable_time =\r\nneigh_rand_reach_time(NEIGH_VAR(idev->nd_parms, BASE_REACHABLE_TIME));\r\nidev->tstamp = jiffies;\r\ninet6_ifinfo_notify(RTM_NEWLINK, idev);\r\nin6_dev_put(idev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __net_init ndisc_net_init(struct net *net)\r\n{\r\nstruct ipv6_pinfo *np;\r\nstruct sock *sk;\r\nint err;\r\nerr = inet_ctl_sock_create(&sk, PF_INET6,\r\nSOCK_RAW, IPPROTO_ICMPV6, net);\r\nif (err < 0) {\r\nND_PRINTK(0, err,\r\n"NDISC: Failed to initialize the control socket (err %d)\n",\r\nerr);\r\nreturn err;\r\n}\r\nnet->ipv6.ndisc_sk = sk;\r\nnp = inet6_sk(sk);\r\nnp->hop_limit = 255;\r\nnp->mc_loop = 0;\r\nreturn 0;\r\n}\r\nstatic void __net_exit ndisc_net_exit(struct net *net)\r\n{\r\ninet_ctl_sock_destroy(net->ipv6.ndisc_sk);\r\n}\r\nint __init ndisc_init(void)\r\n{\r\nint err;\r\nerr = register_pernet_subsys(&ndisc_net_ops);\r\nif (err)\r\nreturn err;\r\nneigh_table_init(&nd_tbl);\r\n#ifdef CONFIG_SYSCTL\r\nerr = neigh_sysctl_register(NULL, &nd_tbl.parms,\r\n&ndisc_ifinfo_sysctl_change);\r\nif (err)\r\ngoto out_unregister_pernet;\r\nout:\r\n#endif\r\nreturn err;\r\n#ifdef CONFIG_SYSCTL\r\nout_unregister_pernet:\r\nunregister_pernet_subsys(&ndisc_net_ops);\r\ngoto out;\r\n#endif\r\n}\r\nint __init ndisc_late_init(void)\r\n{\r\nreturn register_netdevice_notifier(&ndisc_netdev_notifier);\r\n}\r\nvoid ndisc_late_cleanup(void)\r\n{\r\nunregister_netdevice_notifier(&ndisc_netdev_notifier);\r\n}\r\nvoid ndisc_cleanup(void)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nneigh_sysctl_unregister(&nd_tbl.parms);\r\n#endif\r\nneigh_table_clear(&nd_tbl);\r\nunregister_pernet_subsys(&ndisc_net_ops);\r\n}
