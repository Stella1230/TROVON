static int lm3639_chip_init(struct lm3639_chip_data *pchip)\r\n{\r\nint ret;\r\nunsigned int reg_val;\r\nstruct lm3639_platform_data *pdata = pchip->pdata;\r\nret =\r\nregmap_update_bits(pchip->regmap, REG_BL_CONF_1, 0x08,\r\npdata->pin_pwm);\r\nif (ret < 0)\r\ngoto out;\r\nreg_val = (pdata->pin_pwm & 0x40) | pdata->pin_strobe | pdata->pin_tx;\r\nret = regmap_update_bits(pchip->regmap, REG_IO_CTRL, 0x7C, reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_write(pchip->regmap, REG_BL_CONF_4, pdata->init_brt_led);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_write(pchip->regmap, REG_BL_CONF_3, pdata->init_brt_led);\r\nif (ret < 0)\r\ngoto out;\r\nif (!pdata->init_brt_led) {\r\nreg_val = pdata->fled_pins;\r\nreg_val |= pdata->bled_pins;\r\n} else {\r\nreg_val = pdata->fled_pins;\r\nreg_val |= pdata->bled_pins | 0x01;\r\n}\r\nret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x79, reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nreturn ret;\r\nout:\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nreturn ret;\r\n}\r\nstatic int lm3639_bled_update_status(struct backlight_device *bl)\r\n{\r\nint ret;\r\nunsigned int reg_val;\r\nstruct lm3639_chip_data *pchip = bl_get_data(bl);\r\nstruct lm3639_platform_data *pdata = pchip->pdata;\r\nret = regmap_read(pchip->regmap, REG_FLAG, &reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nif (reg_val != 0)\r\ndev_info(pchip->dev, "last flag is 0x%x\n", reg_val);\r\nif (pdata->pin_pwm) {\r\nif (pdata->pwm_set_intensity)\r\npdata->pwm_set_intensity(bl->props.brightness,\r\npdata->max_brt_led);\r\nelse\r\ndev_err(pchip->dev,\r\n"No pwm control func. in plat-data\n");\r\nreturn bl->props.brightness;\r\n}\r\nret = regmap_write(pchip->regmap, REG_BL_CONF_4, bl->props.brightness);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_write(pchip->regmap, REG_BL_CONF_3, bl->props.brightness);\r\nif (ret < 0)\r\ngoto out;\r\nif (!bl->props.brightness)\r\nret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x01, 0x00);\r\nelse\r\nret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto out;\r\nreturn bl->props.brightness;\r\nout:\r\ndev_err(pchip->dev, "i2c failed to access registers\n");\r\nreturn bl->props.brightness;\r\n}\r\nstatic int lm3639_bled_get_brightness(struct backlight_device *bl)\r\n{\r\nint ret;\r\nunsigned int reg_val;\r\nstruct lm3639_chip_data *pchip = bl_get_data(bl);\r\nstruct lm3639_platform_data *pdata = pchip->pdata;\r\nif (pdata->pin_pwm) {\r\nif (pdata->pwm_get_intensity)\r\nbl->props.brightness = pdata->pwm_get_intensity();\r\nelse\r\ndev_err(pchip->dev,\r\n"No pwm control func. in plat-data\n");\r\nreturn bl->props.brightness;\r\n}\r\nret = regmap_read(pchip->regmap, REG_BL_CONF_1, &reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nif (reg_val & 0x10)\r\nret = regmap_read(pchip->regmap, REG_BL_CONF_4, &reg_val);\r\nelse\r\nret = regmap_read(pchip->regmap, REG_BL_CONF_3, &reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nbl->props.brightness = reg_val;\r\nreturn bl->props.brightness;\r\nout:\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nreturn bl->props.brightness;\r\n}\r\nstatic ssize_t lm3639_bled_mode_store(struct device *dev,\r\nstruct device_attribute *devAttr,\r\nconst char *buf, size_t size)\r\n{\r\nssize_t ret;\r\nstruct lm3639_chip_data *pchip = dev_get_drvdata(dev);\r\nunsigned int state;\r\nret = kstrtouint(buf, 10, &state);\r\nif (ret)\r\ngoto out_input;\r\nif (!state)\r\nret =\r\nregmap_update_bits(pchip->regmap, REG_BL_CONF_1, 0x10,\r\n0x00);\r\nelse\r\nret =\r\nregmap_update_bits(pchip->regmap, REG_BL_CONF_1, 0x10,\r\n0x10);\r\nif (ret < 0)\r\ngoto out;\r\nreturn size;\r\nout:\r\ndev_err(pchip->dev, "%s:i2c access fail to register\n", __func__);\r\nreturn ret;\r\nout_input:\r\ndev_err(pchip->dev, "%s:input conversion fail\n", __func__);\r\nreturn ret;\r\n}\r\nstatic void lm3639_torch_brightness_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nint ret;\r\nunsigned int reg_val;\r\nstruct lm3639_chip_data *pchip;\r\npchip = container_of(cdev, struct lm3639_chip_data, cdev_torch);\r\nret = regmap_read(pchip->regmap, REG_FLAG, &reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nif (reg_val != 0)\r\ndev_info(pchip->dev, "last flag is 0x%x\n", reg_val);\r\nif (!brightness) {\r\nret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x06, 0x00);\r\nif (ret < 0)\r\ngoto out;\r\nreturn;\r\n}\r\nret = regmap_update_bits(pchip->regmap,\r\nREG_FL_CONF_1, 0x70, (brightness - 1) << 4);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x06, 0x02);\r\nif (ret < 0)\r\ngoto out;\r\nreturn;\r\nout:\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nreturn;\r\n}\r\nstatic void lm3639_flash_brightness_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nint ret;\r\nunsigned int reg_val;\r\nstruct lm3639_chip_data *pchip;\r\npchip = container_of(cdev, struct lm3639_chip_data, cdev_flash);\r\nret = regmap_read(pchip->regmap, REG_FLAG, &reg_val);\r\nif (ret < 0)\r\ngoto out;\r\nif (reg_val != 0)\r\ndev_info(pchip->dev, "last flag is 0x%x\n", reg_val);\r\nret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x06, 0x00);\r\nif (ret < 0)\r\ngoto out;\r\nif (!brightness)\r\nreturn;\r\nret = regmap_update_bits(pchip->regmap,\r\nREG_FL_CONF_1, 0x0F, brightness - 1);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x06, 0x06);\r\nif (ret < 0)\r\ngoto out;\r\nreturn;\r\nout:\r\ndev_err(pchip->dev, "i2c failed to access register\n");\r\nreturn;\r\n}\r\nstatic int lm3639_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct lm3639_chip_data *pchip;\r\nstruct lm3639_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct backlight_properties props;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "i2c functionality check fail.\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "Needs Platform Data.\n");\r\nreturn -ENODATA;\r\n}\r\npchip = devm_kzalloc(&client->dev,\r\nsizeof(struct lm3639_chip_data), GFP_KERNEL);\r\nif (!pchip)\r\nreturn -ENOMEM;\r\npchip->pdata = pdata;\r\npchip->dev = &client->dev;\r\npchip->regmap = devm_regmap_init_i2c(client, &lm3639_regmap);\r\nif (IS_ERR(pchip->regmap)) {\r\nret = PTR_ERR(pchip->regmap);\r\ndev_err(&client->dev, "fail : allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(client, pchip);\r\nret = lm3639_chip_init(pchip);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "fail : chip init\n");\r\ngoto err_out;\r\n}\r\nprops.type = BACKLIGHT_RAW;\r\nprops.brightness = pdata->init_brt_led;\r\nprops.max_brightness = pdata->max_brt_led;\r\npchip->bled =\r\ndevm_backlight_device_register(pchip->dev, "lm3639_bled",\r\npchip->dev, pchip, &lm3639_bled_ops,\r\n&props);\r\nif (IS_ERR(pchip->bled)) {\r\ndev_err(&client->dev, "fail : backlight register\n");\r\nret = PTR_ERR(pchip->bled);\r\ngoto err_out;\r\n}\r\nret = device_create_file(&(pchip->bled->dev), &dev_attr_bled_mode);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed : add sysfs entries\n");\r\ngoto err_out;\r\n}\r\npchip->cdev_flash.name = "lm3639_flash";\r\npchip->cdev_flash.max_brightness = 16;\r\npchip->cdev_flash.brightness_set = lm3639_flash_brightness_set;\r\nret = led_classdev_register((struct device *)\r\n&client->dev, &pchip->cdev_flash);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "fail : flash register\n");\r\ngoto err_flash;\r\n}\r\npchip->cdev_torch.name = "lm3639_torch";\r\npchip->cdev_torch.max_brightness = 8;\r\npchip->cdev_torch.brightness_set = lm3639_torch_brightness_set;\r\nret = led_classdev_register((struct device *)\r\n&client->dev, &pchip->cdev_torch);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "fail : torch register\n");\r\ngoto err_torch;\r\n}\r\nreturn 0;\r\nerr_torch:\r\nled_classdev_unregister(&pchip->cdev_flash);\r\nerr_flash:\r\ndevice_remove_file(&(pchip->bled->dev), &dev_attr_bled_mode);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int lm3639_remove(struct i2c_client *client)\r\n{\r\nstruct lm3639_chip_data *pchip = i2c_get_clientdata(client);\r\nregmap_write(pchip->regmap, REG_ENABLE, 0x00);\r\nif (&pchip->cdev_torch)\r\nled_classdev_unregister(&pchip->cdev_torch);\r\nif (&pchip->cdev_flash)\r\nled_classdev_unregister(&pchip->cdev_flash);\r\nif (pchip->bled)\r\ndevice_remove_file(&(pchip->bled->dev), &dev_attr_bled_mode);\r\nreturn 0;\r\n}
