static void acx565akm_transfer(struct panel_drv_data *ddata, int cmd,\r\nconst u8 *wbuf, int wlen, u8 *rbuf, int rlen)\r\n{\r\nstruct spi_message m;\r\nstruct spi_transfer *x, xfer[5];\r\nint r;\r\nBUG_ON(ddata->spi == NULL);\r\nspi_message_init(&m);\r\nmemset(xfer, 0, sizeof(xfer));\r\nx = &xfer[0];\r\ncmd &= 0xff;\r\nx->tx_buf = &cmd;\r\nx->bits_per_word = 9;\r\nx->len = 2;\r\nif (rlen > 1 && wlen == 0) {\r\nx->bits_per_word = 10;\r\ncmd <<= 1;\r\n}\r\nspi_message_add_tail(x, &m);\r\nif (wlen) {\r\nx++;\r\nx->tx_buf = wbuf;\r\nx->len = wlen;\r\nx->bits_per_word = 9;\r\nspi_message_add_tail(x, &m);\r\n}\r\nif (rlen) {\r\nx++;\r\nx->rx_buf = rbuf;\r\nx->len = rlen;\r\nspi_message_add_tail(x, &m);\r\n}\r\nr = spi_sync(ddata->spi, &m);\r\nif (r < 0)\r\ndev_dbg(&ddata->spi->dev, "spi_sync %d\n", r);\r\n}\r\nstatic inline void acx565akm_cmd(struct panel_drv_data *ddata, int cmd)\r\n{\r\nacx565akm_transfer(ddata, cmd, NULL, 0, NULL, 0);\r\n}\r\nstatic inline void acx565akm_write(struct panel_drv_data *ddata,\r\nint reg, const u8 *buf, int len)\r\n{\r\nacx565akm_transfer(ddata, reg, buf, len, NULL, 0);\r\n}\r\nstatic inline void acx565akm_read(struct panel_drv_data *ddata,\r\nint reg, u8 *buf, int len)\r\n{\r\nacx565akm_transfer(ddata, reg, NULL, 0, buf, len);\r\n}\r\nstatic void hw_guard_start(struct panel_drv_data *ddata, int guard_msec)\r\n{\r\nddata->hw_guard_wait = msecs_to_jiffies(guard_msec);\r\nddata->hw_guard_end = jiffies + ddata->hw_guard_wait;\r\n}\r\nstatic void hw_guard_wait(struct panel_drv_data *ddata)\r\n{\r\nunsigned long wait = ddata->hw_guard_end - jiffies;\r\nif ((long)wait > 0 && wait <= ddata->hw_guard_wait) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(wait);\r\n}\r\n}\r\nstatic void set_sleep_mode(struct panel_drv_data *ddata, int on)\r\n{\r\nint cmd;\r\nif (on)\r\ncmd = MIPID_CMD_SLEEP_IN;\r\nelse\r\ncmd = MIPID_CMD_SLEEP_OUT;\r\nhw_guard_wait(ddata);\r\nacx565akm_cmd(ddata, cmd);\r\nhw_guard_start(ddata, 120);\r\n}\r\nstatic void set_display_state(struct panel_drv_data *ddata, int enabled)\r\n{\r\nint cmd = enabled ? MIPID_CMD_DISP_ON : MIPID_CMD_DISP_OFF;\r\nacx565akm_cmd(ddata, cmd);\r\n}\r\nstatic int panel_enabled(struct panel_drv_data *ddata)\r\n{\r\nu32 disp_status;\r\nint enabled;\r\nacx565akm_read(ddata, MIPID_CMD_READ_DISP_STATUS,\r\n(u8 *)&disp_status, 4);\r\ndisp_status = __be32_to_cpu(disp_status);\r\nenabled = (disp_status & (1 << 17)) && (disp_status & (1 << 10));\r\ndev_dbg(&ddata->spi->dev,\r\n"LCD panel %senabled by bootloader (status 0x%04x)\n",\r\nenabled ? "" : "not ", disp_status);\r\nreturn enabled;\r\n}\r\nstatic int panel_detect(struct panel_drv_data *ddata)\r\n{\r\nacx565akm_read(ddata, MIPID_CMD_READ_DISP_ID, ddata->display_id, 3);\r\ndev_dbg(&ddata->spi->dev, "MIPI display ID: %02x%02x%02x\n",\r\nddata->display_id[0],\r\nddata->display_id[1],\r\nddata->display_id[2]);\r\nswitch (ddata->display_id[0]) {\r\ncase 0x10:\r\nddata->model = MIPID_VER_ACX565AKM;\r\nddata->name = "acx565akm";\r\nddata->has_bc = 1;\r\nddata->has_cabc = 1;\r\nbreak;\r\ncase 0x29:\r\nddata->model = MIPID_VER_L4F00311;\r\nddata->name = "l4f00311";\r\nbreak;\r\ncase 0x45:\r\nddata->model = MIPID_VER_LPH8923;\r\nddata->name = "lph8923";\r\nbreak;\r\ncase 0x83:\r\nddata->model = MIPID_VER_LS041Y3;\r\nddata->name = "ls041y3";\r\nbreak;\r\ndefault:\r\nddata->name = "unknown";\r\ndev_err(&ddata->spi->dev, "invalid display ID\n");\r\nreturn -ENODEV;\r\n}\r\nddata->revision = ddata->display_id[1];\r\ndev_info(&ddata->spi->dev, "omapfb: %s rev %02x LCD detected\n",\r\nddata->name, ddata->revision);\r\nreturn 0;\r\n}\r\nstatic void enable_backlight_ctrl(struct panel_drv_data *ddata, int enable)\r\n{\r\nu16 ctrl;\r\nacx565akm_read(ddata, MIPID_CMD_READ_CTRL_DISP, (u8 *)&ctrl, 1);\r\nif (enable) {\r\nctrl |= CTRL_DISP_BRIGHTNESS_CTRL_ON |\r\nCTRL_DISP_BACKLIGHT_ON;\r\n} else {\r\nctrl &= ~(CTRL_DISP_BRIGHTNESS_CTRL_ON |\r\nCTRL_DISP_BACKLIGHT_ON);\r\n}\r\nctrl |= 1 << 8;\r\nacx565akm_write(ddata, MIPID_CMD_WRITE_CTRL_DISP, (u8 *)&ctrl, 2);\r\n}\r\nstatic void set_cabc_mode(struct panel_drv_data *ddata, unsigned mode)\r\n{\r\nu16 cabc_ctrl;\r\nddata->cabc_mode = mode;\r\nif (!ddata->enabled)\r\nreturn;\r\ncabc_ctrl = 0;\r\nacx565akm_read(ddata, MIPID_CMD_READ_CABC, (u8 *)&cabc_ctrl, 1);\r\ncabc_ctrl &= ~3;\r\ncabc_ctrl |= (1 << 8) | (mode & 3);\r\nacx565akm_write(ddata, MIPID_CMD_WRITE_CABC, (u8 *)&cabc_ctrl, 2);\r\n}\r\nstatic unsigned get_cabc_mode(struct panel_drv_data *ddata)\r\n{\r\nreturn ddata->cabc_mode;\r\n}\r\nstatic unsigned get_hw_cabc_mode(struct panel_drv_data *ddata)\r\n{\r\nu8 cabc_ctrl;\r\nacx565akm_read(ddata, MIPID_CMD_READ_CABC, &cabc_ctrl, 1);\r\nreturn cabc_ctrl & 3;\r\n}\r\nstatic void acx565akm_set_brightness(struct panel_drv_data *ddata, int level)\r\n{\r\nint bv;\r\nbv = level | (1 << 8);\r\nacx565akm_write(ddata, MIPID_CMD_WRITE_DISP_BRIGHTNESS, (u8 *)&bv, 2);\r\nif (level)\r\nenable_backlight_ctrl(ddata, 1);\r\nelse\r\nenable_backlight_ctrl(ddata, 0);\r\n}\r\nstatic int acx565akm_get_actual_brightness(struct panel_drv_data *ddata)\r\n{\r\nu8 bv;\r\nacx565akm_read(ddata, MIPID_CMD_READ_DISP_BRIGHTNESS, &bv, 1);\r\nreturn bv;\r\n}\r\nstatic int acx565akm_bl_update_status(struct backlight_device *dev)\r\n{\r\nstruct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);\r\nint level;\r\ndev_dbg(&ddata->spi->dev, "%s\n", __func__);\r\nif (dev->props.fb_blank == FB_BLANK_UNBLANK &&\r\ndev->props.power == FB_BLANK_UNBLANK)\r\nlevel = dev->props.brightness;\r\nelse\r\nlevel = 0;\r\nif (ddata->has_bc)\r\nacx565akm_set_brightness(ddata, level);\r\nelse\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int acx565akm_bl_get_intensity(struct backlight_device *dev)\r\n{\r\nstruct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);\r\ndev_dbg(&dev->dev, "%s\n", __func__);\r\nif (!ddata->has_bc)\r\nreturn -ENODEV;\r\nif (dev->props.fb_blank == FB_BLANK_UNBLANK &&\r\ndev->props.power == FB_BLANK_UNBLANK) {\r\nif (ddata->has_bc)\r\nreturn acx565akm_get_actual_brightness(ddata);\r\nelse\r\nreturn dev->props.brightness;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acx565akm_bl_update_status_locked(struct backlight_device *dev)\r\n{\r\nstruct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);\r\nint r;\r\nmutex_lock(&ddata->mutex);\r\nr = acx565akm_bl_update_status(dev);\r\nmutex_unlock(&ddata->mutex);\r\nreturn r;\r\n}\r\nstatic int acx565akm_bl_get_intensity_locked(struct backlight_device *dev)\r\n{\r\nstruct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);\r\nint r;\r\nmutex_lock(&ddata->mutex);\r\nr = acx565akm_bl_get_intensity(dev);\r\nmutex_unlock(&ddata->mutex);\r\nreturn r;\r\n}\r\nstatic ssize_t show_cabc_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct panel_drv_data *ddata = dev_get_drvdata(dev);\r\nconst char *mode_str;\r\nint mode;\r\nint len;\r\nif (!ddata->has_cabc)\r\nmode = 0;\r\nelse\r\nmode = get_cabc_mode(ddata);\r\nmode_str = "unknown";\r\nif (mode >= 0 && mode < ARRAY_SIZE(cabc_modes))\r\nmode_str = cabc_modes[mode];\r\nlen = snprintf(buf, PAGE_SIZE, "%s\n", mode_str);\r\nreturn len < PAGE_SIZE - 1 ? len : PAGE_SIZE - 1;\r\n}\r\nstatic ssize_t store_cabc_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct panel_drv_data *ddata = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cabc_modes); i++) {\r\nconst char *mode_str = cabc_modes[i];\r\nint cmp_len = strlen(mode_str);\r\nif (count > 0 && buf[count - 1] == '\n')\r\ncount--;\r\nif (count != cmp_len)\r\ncontinue;\r\nif (strncmp(buf, mode_str, cmp_len) == 0)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(cabc_modes))\r\nreturn -EINVAL;\r\nif (!ddata->has_cabc && i != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&ddata->mutex);\r\nset_cabc_mode(ddata, i);\r\nmutex_unlock(&ddata->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t show_cabc_available_modes(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct panel_drv_data *ddata = dev_get_drvdata(dev);\r\nint len;\r\nint i;\r\nif (!ddata->has_cabc)\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", cabc_modes[0]);\r\nfor (i = 0, len = 0;\r\nlen < PAGE_SIZE && i < ARRAY_SIZE(cabc_modes); i++)\r\nlen += snprintf(&buf[len], PAGE_SIZE - len, "%s%s%s",\r\ni ? " " : "", cabc_modes[i],\r\ni == ARRAY_SIZE(cabc_modes) - 1 ? "\n" : "");\r\nreturn len < PAGE_SIZE ? len : PAGE_SIZE - 1;\r\n}\r\nstatic int acx565akm_connect(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\nif (omapdss_device_is_connected(dssdev))\r\nreturn 0;\r\nr = in->ops.sdi->connect(in, dssdev);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic void acx565akm_disconnect(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nif (!omapdss_device_is_connected(dssdev))\r\nreturn;\r\nin->ops.sdi->disconnect(in, dssdev);\r\n}\r\nstatic int acx565akm_panel_power_on(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\ndev_dbg(&ddata->spi->dev, "%s\n", __func__);\r\nin->ops.sdi->set_timings(in, &ddata->videomode);\r\nif (ddata->datapairs > 0)\r\nin->ops.sdi->set_datapairs(in, ddata->datapairs);\r\nr = in->ops.sdi->enable(in);\r\nif (r) {\r\npr_err("%s sdi enable failed\n", __func__);\r\nreturn r;\r\n}\r\nmsleep(50);\r\nif (gpio_is_valid(ddata->reset_gpio))\r\ngpio_set_value(ddata->reset_gpio, 1);\r\nif (ddata->enabled) {\r\ndev_dbg(&ddata->spi->dev, "panel already enabled\n");\r\nreturn 0;\r\n}\r\nmsleep(120);\r\nset_sleep_mode(ddata, 0);\r\nddata->enabled = 1;\r\nusleep_range(5000, 10000);\r\nset_display_state(ddata, 1);\r\nset_cabc_mode(ddata, ddata->cabc_mode);\r\nreturn acx565akm_bl_update_status(ddata->bl_dev);\r\n}\r\nstatic void acx565akm_panel_power_off(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\ndev_dbg(dssdev->dev, "%s\n", __func__);\r\nif (!ddata->enabled)\r\nreturn;\r\nset_display_state(ddata, 0);\r\nset_sleep_mode(ddata, 1);\r\nddata->enabled = 0;\r\nmsleep(50);\r\nif (gpio_is_valid(ddata->reset_gpio))\r\ngpio_set_value(ddata->reset_gpio, 0);\r\nmsleep(100);\r\nin->ops.sdi->disable(in);\r\n}\r\nstatic int acx565akm_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nint r;\r\ndev_dbg(dssdev->dev, "%s\n", __func__);\r\nif (!omapdss_device_is_connected(dssdev))\r\nreturn -ENODEV;\r\nif (omapdss_device_is_enabled(dssdev))\r\nreturn 0;\r\nmutex_lock(&ddata->mutex);\r\nr = acx565akm_panel_power_on(dssdev);\r\nmutex_unlock(&ddata->mutex);\r\nif (r)\r\nreturn r;\r\ndssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic void acx565akm_disable(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\ndev_dbg(dssdev->dev, "%s\n", __func__);\r\nif (!omapdss_device_is_enabled(dssdev))\r\nreturn;\r\nmutex_lock(&ddata->mutex);\r\nacx565akm_panel_power_off(dssdev);\r\nmutex_unlock(&ddata->mutex);\r\ndssdev->state = OMAP_DSS_DISPLAY_DISABLED;\r\n}\r\nstatic void acx565akm_set_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nddata->videomode = *timings;\r\ndssdev->panel.timings = *timings;\r\nin->ops.sdi->set_timings(in, timings);\r\n}\r\nstatic void acx565akm_get_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\n*timings = ddata->videomode;\r\n}\r\nstatic int acx565akm_check_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nreturn in->ops.sdi->check_timings(in, timings);\r\n}\r\nstatic int acx565akm_probe_pdata(struct spi_device *spi)\r\n{\r\nconst struct panel_acx565akm_platform_data *pdata;\r\nstruct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);\r\nstruct omap_dss_device *dssdev, *in;\r\npdata = dev_get_platdata(&spi->dev);\r\nddata->reset_gpio = pdata->reset_gpio;\r\nin = omap_dss_find_output(pdata->source);\r\nif (in == NULL) {\r\ndev_err(&spi->dev, "failed to find video source '%s'\n",\r\npdata->source);\r\nreturn -EPROBE_DEFER;\r\n}\r\nddata->in = in;\r\nddata->datapairs = pdata->datapairs;\r\ndssdev = &ddata->dssdev;\r\ndssdev->name = pdata->name;\r\nreturn 0;\r\n}\r\nstatic int acx565akm_probe_of(struct spi_device *spi)\r\n{\r\nstruct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);\r\nstruct device_node *np = spi->dev.of_node;\r\nddata->reset_gpio = of_get_named_gpio(np, "reset-gpios", 0);\r\nddata->in = omapdss_of_find_source_for_first_ep(np);\r\nif (IS_ERR(ddata->in)) {\r\ndev_err(&spi->dev, "failed to find video source\n");\r\nreturn PTR_ERR(ddata->in);\r\n}\r\nreturn 0;\r\n}\r\nstatic int acx565akm_probe(struct spi_device *spi)\r\n{\r\nstruct panel_drv_data *ddata;\r\nstruct omap_dss_device *dssdev;\r\nstruct backlight_device *bldev;\r\nint max_brightness, brightness;\r\nstruct backlight_properties props;\r\nint r;\r\ndev_dbg(&spi->dev, "%s\n", __func__);\r\nspi->mode = SPI_MODE_3;\r\nddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);\r\nif (ddata == NULL)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&spi->dev, ddata);\r\nddata->spi = spi;\r\nmutex_init(&ddata->mutex);\r\nif (dev_get_platdata(&spi->dev)) {\r\nr = acx565akm_probe_pdata(spi);\r\nif (r)\r\nreturn r;\r\n} else if (spi->dev.of_node) {\r\nr = acx565akm_probe_of(spi);\r\nif (r)\r\nreturn r;\r\n} else {\r\ndev_err(&spi->dev, "platform data missing!\n");\r\nreturn -ENODEV;\r\n}\r\nif (gpio_is_valid(ddata->reset_gpio)) {\r\nr = devm_gpio_request_one(&spi->dev, ddata->reset_gpio,\r\nGPIOF_OUT_INIT_LOW, "lcd reset");\r\nif (r)\r\ngoto err_gpio;\r\n}\r\nif (gpio_is_valid(ddata->reset_gpio))\r\ngpio_set_value(ddata->reset_gpio, 1);\r\nusleep_range(5000, 10000);\r\nddata->enabled = panel_enabled(ddata);\r\nr = panel_detect(ddata);\r\nif (!ddata->enabled && gpio_is_valid(ddata->reset_gpio))\r\ngpio_set_value(ddata->reset_gpio, 0);\r\nif (r) {\r\ndev_err(&spi->dev, "%s panel detect error\n", __func__);\r\ngoto err_detect;\r\n}\r\nmemset(&props, 0, sizeof(props));\r\nprops.fb_blank = FB_BLANK_UNBLANK;\r\nprops.power = FB_BLANK_UNBLANK;\r\nprops.type = BACKLIGHT_RAW;\r\nbldev = backlight_device_register("acx565akm", &ddata->spi->dev,\r\nddata, &acx565akm_bl_ops, &props);\r\nddata->bl_dev = bldev;\r\nif (ddata->has_cabc) {\r\nr = sysfs_create_group(&bldev->dev.kobj, &bldev_attr_group);\r\nif (r) {\r\ndev_err(&bldev->dev,\r\n"%s failed to create sysfs files\n", __func__);\r\ngoto err_sysfs;\r\n}\r\nddata->cabc_mode = get_hw_cabc_mode(ddata);\r\n}\r\nmax_brightness = 255;\r\nif (ddata->has_bc)\r\nbrightness = acx565akm_get_actual_brightness(ddata);\r\nelse\r\nbrightness = 0;\r\nbldev->props.max_brightness = max_brightness;\r\nbldev->props.brightness = brightness;\r\nacx565akm_bl_update_status(bldev);\r\nddata->videomode = acx565akm_panel_timings;\r\ndssdev = &ddata->dssdev;\r\ndssdev->dev = &spi->dev;\r\ndssdev->driver = &acx565akm_ops;\r\ndssdev->type = OMAP_DISPLAY_TYPE_SDI;\r\ndssdev->owner = THIS_MODULE;\r\ndssdev->panel.timings = ddata->videomode;\r\nr = omapdss_register_display(dssdev);\r\nif (r) {\r\ndev_err(&spi->dev, "Failed to register panel\n");\r\ngoto err_reg;\r\n}\r\nreturn 0;\r\nerr_reg:\r\nsysfs_remove_group(&bldev->dev.kobj, &bldev_attr_group);\r\nerr_sysfs:\r\nbacklight_device_unregister(bldev);\r\nerr_detect:\r\nerr_gpio:\r\nomap_dss_put_device(ddata->in);\r\nreturn r;\r\n}\r\nstatic int acx565akm_remove(struct spi_device *spi)\r\n{\r\nstruct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);\r\nstruct omap_dss_device *dssdev = &ddata->dssdev;\r\nstruct omap_dss_device *in = ddata->in;\r\ndev_dbg(&ddata->spi->dev, "%s\n", __func__);\r\nsysfs_remove_group(&ddata->bl_dev->dev.kobj, &bldev_attr_group);\r\nbacklight_device_unregister(ddata->bl_dev);\r\nomapdss_unregister_display(dssdev);\r\nacx565akm_disable(dssdev);\r\nacx565akm_disconnect(dssdev);\r\nomap_dss_put_device(in);\r\nreturn 0;\r\n}
