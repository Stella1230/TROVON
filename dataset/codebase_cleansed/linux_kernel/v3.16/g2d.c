static struct g2d_fmt *find_fmt(struct v4l2_format *f)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < NUM_FORMATS; i++) {\r\nif (formats[i].fourcc == f->fmt.pix.pixelformat)\r\nreturn &formats[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct g2d_frame *get_frame(struct g2d_ctx *ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nswitch (type) {\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nreturn &ctx->in;\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn &ctx->out;\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nstatic int g2d_queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct g2d_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct g2d_frame *f = get_frame(ctx, vq->type);\r\nif (IS_ERR(f))\r\nreturn PTR_ERR(f);\r\nsizes[0] = f->size;\r\n*nplanes = 1;\r\nalloc_ctxs[0] = ctx->dev->alloc_ctx;\r\nif (*nbuffers == 0)\r\n*nbuffers = 1;\r\nreturn 0;\r\n}\r\nstatic int g2d_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct g2d_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct g2d_frame *f = get_frame(ctx, vb->vb2_queue->type);\r\nif (IS_ERR(f))\r\nreturn PTR_ERR(f);\r\nvb2_set_plane_payload(vb, 0, f->size);\r\nreturn 0;\r\n}\r\nstatic void g2d_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct g2d_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vb);\r\n}\r\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct g2d_ctx *ctx = priv;\r\nint ret;\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->ops = &g2d_qops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nsrc_vq->lock = &ctx->dev->mutex;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ndst_vq->io_modes = VB2_MMAP | VB2_USERPTR;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->ops = &g2d_qops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\ndst_vq->lock = &ctx->dev->mutex;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic int g2d_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct g2d_ctx *ctx = container_of(ctrl->handler, struct g2d_ctx,\r\nctrl_handler);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->dev->ctrl_lock, flags);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_COLORFX:\r\nif (ctrl->val == V4L2_COLORFX_NEGATIVE)\r\nctx->rop = ROP4_INVERT;\r\nelse\r\nctx->rop = ROP4_COPY;\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nctx->flip = ctx->ctrl_hflip->val | (ctx->ctrl_vflip->val << 1);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ctx->dev->ctrl_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int g2d_setup_ctrls(struct g2d_ctx *ctx)\r\n{\r\nstruct g2d_dev *dev = ctx->dev;\r\nv4l2_ctrl_handler_init(&ctx->ctrl_handler, 3);\r\nctx->ctrl_hflip = v4l2_ctrl_new_std(&ctx->ctrl_handler, &g2d_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nctx->ctrl_vflip = v4l2_ctrl_new_std(&ctx->ctrl_handler, &g2d_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std_menu(\r\n&ctx->ctrl_handler,\r\n&g2d_ctrl_ops,\r\nV4L2_CID_COLORFX,\r\nV4L2_COLORFX_NEGATIVE,\r\n~((1 << V4L2_COLORFX_NONE) | (1 << V4L2_COLORFX_NEGATIVE)),\r\nV4L2_COLORFX_NONE);\r\nif (ctx->ctrl_handler.error) {\r\nint err = ctx->ctrl_handler.error;\r\nv4l2_err(&dev->v4l2_dev, "g2d_setup_ctrls failed\n");\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nreturn err;\r\n}\r\nv4l2_ctrl_cluster(2, &ctx->ctrl_hflip);\r\nreturn 0;\r\n}\r\nstatic int g2d_open(struct file *file)\r\n{\r\nstruct g2d_dev *dev = video_drvdata(file);\r\nstruct g2d_ctx *ctx = NULL;\r\nint ret = 0;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->dev = dev;\r\nctx->in = def_frame;\r\nctx->out = def_frame;\r\nif (mutex_lock_interruptible(&dev->mutex)) {\r\nkfree(ctx);\r\nreturn -ERESTARTSYS;\r\n}\r\nctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx, &queue_init);\r\nif (IS_ERR(ctx->fh.m2m_ctx)) {\r\nret = PTR_ERR(ctx->fh.m2m_ctx);\r\nmutex_unlock(&dev->mutex);\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nv4l2_fh_init(&ctx->fh, video_devdata(file));\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\ng2d_setup_ctrls(ctx);\r\nv4l2_ctrl_handler_setup(&ctx->ctrl_handler);\r\nctx->fh.ctrl_handler = &ctx->ctrl_handler;\r\nmutex_unlock(&dev->mutex);\r\nv4l2_info(&dev->v4l2_dev, "instance opened\n");\r\nreturn 0;\r\n}\r\nstatic int g2d_release(struct file *file)\r\n{\r\nstruct g2d_dev *dev = video_drvdata(file);\r\nstruct g2d_ctx *ctx = fh2ctx(file->private_data);\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nv4l2_info(&dev->v4l2_dev, "instance closed\n");\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrncpy(cap->driver, G2D_NAME, sizeof(cap->driver) - 1);\r\nstrncpy(cap->card, G2D_NAME, sizeof(cap->card) - 1);\r\ncap->bus_info[0] = 0;\r\ncap->version = KERNEL_VERSION(1, 0, 0);\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT |\r\nV4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt(struct file *file, void *prv, struct v4l2_fmtdesc *f)\r\n{\r\nstruct g2d_fmt *fmt;\r\nif (f->index >= NUM_FORMATS)\r\nreturn -EINVAL;\r\nfmt = &formats[f->index];\r\nf->pixelformat = fmt->fourcc;\r\nstrncpy(f->description, fmt->name, sizeof(f->description) - 1);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt(struct file *file, void *prv, struct v4l2_format *f)\r\n{\r\nstruct g2d_ctx *ctx = prv;\r\nstruct vb2_queue *vq;\r\nstruct g2d_frame *frm;\r\nvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nfrm = get_frame(ctx, f->type);\r\nif (IS_ERR(frm))\r\nreturn PTR_ERR(frm);\r\nf->fmt.pix.width = frm->width;\r\nf->fmt.pix.height = frm->height;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.pixelformat = frm->fmt->fourcc;\r\nf->fmt.pix.bytesperline = (frm->width * frm->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage = frm->size;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt(struct file *file, void *prv, struct v4l2_format *f)\r\n{\r\nstruct g2d_fmt *fmt;\r\nenum v4l2_field *field;\r\nfmt = find_fmt(f);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nfield = &f->fmt.pix.field;\r\nif (*field == V4L2_FIELD_ANY)\r\n*field = V4L2_FIELD_NONE;\r\nelse if (*field != V4L2_FIELD_NONE)\r\nreturn -EINVAL;\r\nif (f->fmt.pix.width > MAX_WIDTH)\r\nf->fmt.pix.width = MAX_WIDTH;\r\nif (f->fmt.pix.height > MAX_HEIGHT)\r\nf->fmt.pix.height = MAX_HEIGHT;\r\nif (f->fmt.pix.width < 1)\r\nf->fmt.pix.width = 1;\r\nif (f->fmt.pix.height < 1)\r\nf->fmt.pix.height = 1;\r\nf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt(struct file *file, void *prv, struct v4l2_format *f)\r\n{\r\nstruct g2d_ctx *ctx = prv;\r\nstruct g2d_dev *dev = ctx->dev;\r\nstruct vb2_queue *vq;\r\nstruct g2d_frame *frm;\r\nstruct g2d_fmt *fmt;\r\nint ret = 0;\r\nret = vidioc_try_fmt(file, prv, f);\r\nif (ret)\r\nreturn ret;\r\nvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\r\nif (vb2_is_busy(vq)) {\r\nv4l2_err(&dev->v4l2_dev, "queue (%d) bust\n", f->type);\r\nreturn -EBUSY;\r\n}\r\nfrm = get_frame(ctx, f->type);\r\nif (IS_ERR(frm))\r\nreturn PTR_ERR(frm);\r\nfmt = find_fmt(f);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nfrm->width = f->fmt.pix.width;\r\nfrm->height = f->fmt.pix.height;\r\nfrm->size = f->fmt.pix.sizeimage;\r\nfrm->o_width = 0;\r\nfrm->o_height = 0;\r\nfrm->c_width = frm->width;\r\nfrm->c_height = frm->height;\r\nfrm->right = frm->width;\r\nfrm->bottom = frm->height;\r\nfrm->fmt = fmt;\r\nfrm->stride = f->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nstatic int vidioc_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cr)\r\n{\r\nstruct g2d_ctx *ctx = priv;\r\nstruct g2d_frame *f;\r\nf = get_frame(ctx, cr->type);\r\nif (IS_ERR(f))\r\nreturn PTR_ERR(f);\r\ncr->bounds.left = 0;\r\ncr->bounds.top = 0;\r\ncr->bounds.width = f->width;\r\ncr->bounds.height = f->height;\r\ncr->defrect = cr->bounds;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_crop(struct file *file, void *prv, struct v4l2_crop *cr)\r\n{\r\nstruct g2d_ctx *ctx = prv;\r\nstruct g2d_frame *f;\r\nf = get_frame(ctx, cr->type);\r\nif (IS_ERR(f))\r\nreturn PTR_ERR(f);\r\ncr->c.left = f->o_height;\r\ncr->c.top = f->o_width;\r\ncr->c.width = f->c_width;\r\ncr->c.height = f->c_height;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_crop(struct file *file, void *prv, const struct v4l2_crop *cr)\r\n{\r\nstruct g2d_ctx *ctx = prv;\r\nstruct g2d_dev *dev = ctx->dev;\r\nstruct g2d_frame *f;\r\nf = get_frame(ctx, cr->type);\r\nif (IS_ERR(f))\r\nreturn PTR_ERR(f);\r\nif (cr->c.top < 0 || cr->c.left < 0) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"doesn't support negative values for top & left\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_crop(struct file *file, void *prv, const struct v4l2_crop *cr)\r\n{\r\nstruct g2d_ctx *ctx = prv;\r\nstruct g2d_frame *f;\r\nint ret;\r\nret = vidioc_try_crop(file, prv, cr);\r\nif (ret)\r\nreturn ret;\r\nf = get_frame(ctx, cr->type);\r\nif (IS_ERR(f))\r\nreturn PTR_ERR(f);\r\nf->c_width = cr->c.width;\r\nf->c_height = cr->c.height;\r\nf->o_width = cr->c.left;\r\nf->o_height = cr->c.top;\r\nf->bottom = f->o_height + f->c_height;\r\nf->right = f->o_width + f->c_width;\r\nreturn 0;\r\n}\r\nstatic void job_abort(void *prv)\r\n{\r\nstruct g2d_ctx *ctx = prv;\r\nstruct g2d_dev *dev = ctx->dev;\r\nint ret;\r\nif (dev->curr == NULL)\r\nreturn;\r\nret = wait_event_timeout(dev->irq_queue,\r\ndev->curr == NULL,\r\nmsecs_to_jiffies(G2D_TIMEOUT));\r\n}\r\nstatic void device_run(void *prv)\r\n{\r\nstruct g2d_ctx *ctx = prv;\r\nstruct g2d_dev *dev = ctx->dev;\r\nstruct vb2_buffer *src, *dst;\r\nunsigned long flags;\r\nu32 cmd = 0;\r\ndev->curr = ctx;\r\nsrc = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\ndst = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\nclk_enable(dev->gate);\r\ng2d_reset(dev);\r\nspin_lock_irqsave(&dev->ctrl_lock, flags);\r\ng2d_set_src_size(dev, &ctx->in);\r\ng2d_set_src_addr(dev, vb2_dma_contig_plane_dma_addr(src, 0));\r\ng2d_set_dst_size(dev, &ctx->out);\r\ng2d_set_dst_addr(dev, vb2_dma_contig_plane_dma_addr(dst, 0));\r\ng2d_set_rop4(dev, ctx->rop);\r\ng2d_set_flip(dev, ctx->flip);\r\nif (ctx->in.c_width != ctx->out.c_width ||\r\nctx->in.c_height != ctx->out.c_height) {\r\nif (dev->variant->hw_rev == TYPE_G2D_3X)\r\ncmd |= CMD_V3_ENABLE_STRETCH;\r\nelse\r\ng2d_set_v41_stretch(dev, &ctx->in, &ctx->out);\r\n}\r\ng2d_set_cmd(dev, cmd);\r\ng2d_start(dev);\r\nspin_unlock_irqrestore(&dev->ctrl_lock, flags);\r\n}\r\nstatic irqreturn_t g2d_isr(int irq, void *prv)\r\n{\r\nstruct g2d_dev *dev = prv;\r\nstruct g2d_ctx *ctx = dev->curr;\r\nstruct vb2_buffer *src, *dst;\r\ng2d_clear_int(dev);\r\nclk_disable(dev->gate);\r\nBUG_ON(ctx == NULL);\r\nsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\ndst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\r\nBUG_ON(src == NULL);\r\nBUG_ON(dst == NULL);\r\ndst->v4l2_buf.timecode = src->v4l2_buf.timecode;\r\ndst->v4l2_buf.timestamp = src->v4l2_buf.timestamp;\r\ndst->v4l2_buf.flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst->v4l2_buf.flags |=\r\nsrc->v4l2_buf.flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\nv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\r\nv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\r\nv4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);\r\ndev->curr = NULL;\r\nwake_up(&dev->irq_queue);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int g2d_probe(struct platform_device *pdev)\r\n{\r\nstruct g2d_dev *dev;\r\nstruct video_device *vfd;\r\nstruct resource *res;\r\nconst struct of_device_id *of_id;\r\nint ret = 0;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nspin_lock_init(&dev->ctrl_lock);\r\nmutex_init(&dev->mutex);\r\natomic_set(&dev->num_inst, 0);\r\ninit_waitqueue_head(&dev->irq_queue);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(dev->regs))\r\nreturn PTR_ERR(dev->regs);\r\ndev->clk = clk_get(&pdev->dev, "sclk_fimg2d");\r\nif (IS_ERR(dev->clk)) {\r\ndev_err(&pdev->dev, "failed to get g2d clock\n");\r\nreturn -ENXIO;\r\n}\r\nret = clk_prepare(dev->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to prepare g2d clock\n");\r\ngoto put_clk;\r\n}\r\ndev->gate = clk_get(&pdev->dev, "fimg2d");\r\nif (IS_ERR(dev->gate)) {\r\ndev_err(&pdev->dev, "failed to get g2d clock gate\n");\r\nret = -ENXIO;\r\ngoto unprep_clk;\r\n}\r\nret = clk_prepare(dev->gate);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to prepare g2d clock gate\n");\r\ngoto put_clk_gate;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "failed to find IRQ\n");\r\nret = -ENXIO;\r\ngoto unprep_clk_gate;\r\n}\r\ndev->irq = res->start;\r\nret = devm_request_irq(&pdev->dev, dev->irq, g2d_isr,\r\n0, pdev->name, dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to install IRQ\n");\r\ngoto put_clk_gate;\r\n}\r\ndev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(dev->alloc_ctx)) {\r\nret = PTR_ERR(dev->alloc_ctx);\r\ngoto unprep_clk_gate;\r\n}\r\nret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\r\nif (ret)\r\ngoto alloc_ctx_cleanup;\r\nvfd = video_device_alloc();\r\nif (!vfd) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to allocate video device\n");\r\nret = -ENOMEM;\r\ngoto unreg_v4l2_dev;\r\n}\r\n*vfd = g2d_videodev;\r\nvfd->lock = &dev->mutex;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, 0);\r\nif (ret) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to register video device\n");\r\ngoto rel_vdev;\r\n}\r\nvideo_set_drvdata(vfd, dev);\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s", g2d_videodev.name);\r\ndev->vfd = vfd;\r\nv4l2_info(&dev->v4l2_dev, "device registered as /dev/video%d\n",\r\nvfd->num);\r\nplatform_set_drvdata(pdev, dev);\r\ndev->m2m_dev = v4l2_m2m_init(&g2d_m2m_ops);\r\nif (IS_ERR(dev->m2m_dev)) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to init mem2mem device\n");\r\nret = PTR_ERR(dev->m2m_dev);\r\ngoto unreg_video_dev;\r\n}\r\ndef_frame.stride = (def_frame.width * def_frame.fmt->depth) >> 3;\r\nif (!pdev->dev.of_node) {\r\ndev->variant = g2d_get_drv_data(pdev);\r\n} else {\r\nof_id = of_match_node(exynos_g2d_match, pdev->dev.of_node);\r\nif (!of_id) {\r\nret = -ENODEV;\r\ngoto unreg_video_dev;\r\n}\r\ndev->variant = (struct g2d_variant *)of_id->data;\r\n}\r\nreturn 0;\r\nunreg_video_dev:\r\nvideo_unregister_device(dev->vfd);\r\nrel_vdev:\r\nvideo_device_release(vfd);\r\nunreg_v4l2_dev:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nalloc_ctx_cleanup:\r\nvb2_dma_contig_cleanup_ctx(dev->alloc_ctx);\r\nunprep_clk_gate:\r\nclk_unprepare(dev->gate);\r\nput_clk_gate:\r\nclk_put(dev->gate);\r\nunprep_clk:\r\nclk_unprepare(dev->clk);\r\nput_clk:\r\nclk_put(dev->clk);\r\nreturn ret;\r\n}\r\nstatic int g2d_remove(struct platform_device *pdev)\r\n{\r\nstruct g2d_dev *dev = platform_get_drvdata(pdev);\r\nv4l2_info(&dev->v4l2_dev, "Removing " G2D_NAME);\r\nv4l2_m2m_release(dev->m2m_dev);\r\nvideo_unregister_device(dev->vfd);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nvb2_dma_contig_cleanup_ctx(dev->alloc_ctx);\r\nclk_unprepare(dev->gate);\r\nclk_put(dev->gate);\r\nclk_unprepare(dev->clk);\r\nclk_put(dev->clk);\r\nreturn 0;\r\n}
