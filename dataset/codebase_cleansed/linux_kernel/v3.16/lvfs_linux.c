static void push_group_info(struct lvfs_run_ctxt *save,\r\nstruct group_info *ginfo)\r\n{\r\nif (!ginfo) {\r\nsave->ngroups = current_ngroups;\r\ncurrent_ngroups = 0;\r\n} else {\r\nstruct cred *cred;\r\ntask_lock(current);\r\nsave->group_info = current_cred()->group_info;\r\ncred = prepare_creds();\r\nif (cred) {\r\ncred->group_info = ginfo;\r\ncommit_creds(cred);\r\n}\r\ntask_unlock(current);\r\n}\r\n}\r\nstatic void pop_group_info(struct lvfs_run_ctxt *save,\r\nstruct group_info *ginfo)\r\n{\r\nif (!ginfo) {\r\ncurrent_ngroups = save->ngroups;\r\n} else {\r\nstruct cred *cred;\r\ntask_lock(current);\r\ncred = prepare_creds();\r\nif (cred) {\r\ncred->group_info = save->group_info;\r\ncommit_creds(cred);\r\n}\r\ntask_unlock(current);\r\n}\r\n}\r\nvoid push_ctxt(struct lvfs_run_ctxt *save, struct lvfs_run_ctxt *new_ctx,\r\nstruct lvfs_ucred *uc)\r\n{\r\nif (new_ctx->dt != NULL)\r\nreturn;\r\nASSERT_CTXT_MAGIC(new_ctx->magic);\r\nOBD_SET_CTXT_MAGIC(save);\r\nsave->fs = get_fs();\r\nLASSERT(d_count(cfs_fs_pwd(current->fs)));\r\nLASSERT(d_count(new_ctx->pwd));\r\nsave->pwd = dget(cfs_fs_pwd(current->fs));\r\nsave->pwdmnt = mntget(cfs_fs_mnt(current->fs));\r\nsave->luc.luc_umask = current_umask();\r\nsave->ngroups = current_cred()->group_info->ngroups;\r\nLASSERT(save->pwd);\r\nLASSERT(save->pwdmnt);\r\nLASSERT(new_ctx->pwd);\r\nLASSERT(new_ctx->pwdmnt);\r\nif (uc) {\r\nstruct cred *cred;\r\nsave->luc.luc_uid = current_uid();\r\nsave->luc.luc_gid = current_gid();\r\nsave->luc.luc_fsuid = current_fsuid();\r\nsave->luc.luc_fsgid = current_fsgid();\r\nsave->luc.luc_cap = current_cap();\r\ncred = prepare_creds();\r\nif (cred) {\r\ncred->uid = uc->luc_uid;\r\ncred->gid = uc->luc_gid;\r\ncred->fsuid = uc->luc_fsuid;\r\ncred->fsgid = uc->luc_fsgid;\r\ncred->cap_effective = uc->luc_cap;\r\ncommit_creds(cred);\r\n}\r\npush_group_info(save,\r\nuc->luc_ginfo ?:\r\nuc->luc_identity ? uc->luc_identity->mi_ginfo :\r\nNULL);\r\n}\r\ncurrent->fs->umask = 0;\r\nset_fs(new_ctx->fs);\r\nll_set_fs_pwd(current->fs, new_ctx->pwdmnt, new_ctx->pwd);\r\n}\r\nvoid pop_ctxt(struct lvfs_run_ctxt *saved, struct lvfs_run_ctxt *new_ctx,\r\nstruct lvfs_ucred *uc)\r\n{\r\nif (new_ctx->dt != NULL)\r\nreturn;\r\nASSERT_CTXT_MAGIC(saved->magic);\r\nASSERT_KERNEL_CTXT("popping non-kernel context!\n");\r\nLASSERTF(cfs_fs_pwd(current->fs) == new_ctx->pwd, "%p != %p\n",\r\ncfs_fs_pwd(current->fs), new_ctx->pwd);\r\nLASSERTF(cfs_fs_mnt(current->fs) == new_ctx->pwdmnt, "%p != %p\n",\r\ncfs_fs_mnt(current->fs), new_ctx->pwdmnt);\r\nset_fs(saved->fs);\r\nll_set_fs_pwd(current->fs, saved->pwdmnt, saved->pwd);\r\ndput(saved->pwd);\r\nmntput(saved->pwdmnt);\r\ncurrent->fs->umask = saved->luc.luc_umask;\r\nif (uc) {\r\nstruct cred *cred;\r\ncred = prepare_creds();\r\nif (cred) {\r\ncred->uid = saved->luc.luc_uid;\r\ncred->gid = saved->luc.luc_gid;\r\ncred->fsuid = saved->luc.luc_fsuid;\r\ncred->fsgid = saved->luc.luc_fsgid;\r\ncred->cap_effective = saved->luc.luc_cap;\r\ncommit_creds(cred);\r\n}\r\npop_group_info(saved,\r\nuc->luc_ginfo ?:\r\nuc->luc_identity ? uc->luc_identity->mi_ginfo :\r\nNULL);\r\n}\r\n}\r\nint lustre_rename(struct dentry *dir, struct vfsmount *mnt,\r\nchar *oldname, char *newname)\r\n{\r\nstruct dentry *dchild_old, *dchild_new;\r\nint err = 0;\r\nASSERT_KERNEL_CTXT("kernel doing rename outside kernel context\n");\r\nCDEBUG(D_INODE, "renaming file %.*s to %.*s\n",\r\n(int)strlen(oldname), oldname, (int)strlen(newname), newname);\r\ndchild_old = ll_lookup_one_len(oldname, dir, strlen(oldname));\r\nif (IS_ERR(dchild_old))\r\nreturn PTR_ERR(dchild_old);\r\nif (!dchild_old->d_inode)\r\nGOTO(put_old, err = -ENOENT);\r\ndchild_new = ll_lookup_one_len(newname, dir, strlen(newname));\r\nif (IS_ERR(dchild_new))\r\nGOTO(put_old, err = PTR_ERR(dchild_new));\r\nerr = ll_vfs_rename(dir->d_inode, dchild_old, mnt,\r\ndir->d_inode, dchild_new, mnt);\r\ndput(dchild_new);\r\nput_old:\r\ndput(dchild_old);\r\nreturn err;\r\n}\r\nstruct l_file *l_dentry_open(struct lvfs_run_ctxt *ctxt, struct l_dentry *de,\r\nint flags)\r\n{\r\nstruct path path = {\r\n.dentry = de,\r\n.mnt = ctxt->pwdmnt,\r\n};\r\nreturn dentry_open(&path, flags, current_cred());\r\n}\r\n__s64 lprocfs_read_helper(struct lprocfs_counter *lc,\r\nstruct lprocfs_counter_header *header,\r\nenum lprocfs_stats_flags flags,\r\nenum lprocfs_fields_flags field)\r\n{\r\n__s64 ret = 0;\r\nif (lc == NULL || header == NULL)\r\nreturn 0;\r\nswitch (field) {\r\ncase LPROCFS_FIELDS_FLAGS_CONFIG:\r\nret = header->lc_config;\r\nbreak;\r\ncase LPROCFS_FIELDS_FLAGS_SUM:\r\nret = lc->lc_sum;\r\nif ((flags & LPROCFS_STATS_FLAG_IRQ_SAFE) != 0)\r\nret += lc->lc_sum_irq;\r\nbreak;\r\ncase LPROCFS_FIELDS_FLAGS_MIN:\r\nret = lc->lc_min;\r\nbreak;\r\ncase LPROCFS_FIELDS_FLAGS_MAX:\r\nret = lc->lc_max;\r\nbreak;\r\ncase LPROCFS_FIELDS_FLAGS_AVG:\r\nret = (lc->lc_max - lc->lc_min) / 2;\r\nbreak;\r\ncase LPROCFS_FIELDS_FLAGS_SUMSQUARE:\r\nret = lc->lc_sumsquare;\r\nbreak;\r\ncase LPROCFS_FIELDS_FLAGS_COUNT:\r\nret = lc->lc_count;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}
