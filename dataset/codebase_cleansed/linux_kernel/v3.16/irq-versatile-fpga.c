static void fpga_irq_mask(struct irq_data *d)\r\n{\r\nstruct fpga_irq_data *f = irq_data_get_irq_chip_data(d);\r\nu32 mask = 1 << d->hwirq;\r\nwritel(mask, f->base + IRQ_ENABLE_CLEAR);\r\n}\r\nstatic void fpga_irq_unmask(struct irq_data *d)\r\n{\r\nstruct fpga_irq_data *f = irq_data_get_irq_chip_data(d);\r\nu32 mask = 1 << d->hwirq;\r\nwritel(mask, f->base + IRQ_ENABLE_SET);\r\n}\r\nstatic void fpga_irq_handle(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct fpga_irq_data *f = irq_desc_get_handler_data(desc);\r\nu32 status = readl(f->base + IRQ_STATUS);\r\nif (status == 0) {\r\ndo_bad_IRQ(irq, desc);\r\nreturn;\r\n}\r\ndo {\r\nirq = ffs(status) - 1;\r\nstatus &= ~(1 << irq);\r\ngeneric_handle_irq(irq_find_mapping(f->domain, irq));\r\n} while (status);\r\n}\r\nstatic int handle_one_fpga(struct fpga_irq_data *f, struct pt_regs *regs)\r\n{\r\nint handled = 0;\r\nint irq;\r\nu32 status;\r\nwhile ((status = readl(f->base + IRQ_STATUS))) {\r\nirq = ffs(status) - 1;\r\nhandle_IRQ(irq_find_mapping(f->domain, irq), regs);\r\nhandled = 1;\r\n}\r\nreturn handled;\r\n}\r\nasmlinkage void __exception_irq_entry fpga_handle_irq(struct pt_regs *regs)\r\n{\r\nint i, handled;\r\ndo {\r\nfor (i = 0, handled = 0; i < fpga_irq_id; ++i)\r\nhandled |= handle_one_fpga(&fpga_irq_devices[i], regs);\r\n} while (handled);\r\n}\r\nstatic int fpga_irqdomain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct fpga_irq_data *f = d->host_data;\r\nif (!(f->valid & BIT(hwirq)))\r\nreturn -EPERM;\r\nirq_set_chip_data(irq, f);\r\nirq_set_chip_and_handler(irq, &f->chip,\r\nhandle_level_irq);\r\nset_irq_flags(irq, IRQF_VALID | IRQF_PROBE);\r\nreturn 0;\r\n}\r\nvoid __init fpga_irq_init(void __iomem *base, const char *name, int irq_start,\r\nint parent_irq, u32 valid, struct device_node *node)\r\n{\r\nstruct fpga_irq_data *f;\r\nint i;\r\nif (fpga_irq_id >= ARRAY_SIZE(fpga_irq_devices)) {\r\npr_err("%s: too few FPGA IRQ controllers, increase CONFIG_VERSATILE_FPGA_IRQ_NR\n", __func__);\r\nreturn;\r\n}\r\nf = &fpga_irq_devices[fpga_irq_id];\r\nf->base = base;\r\nf->chip.name = name;\r\nf->chip.irq_ack = fpga_irq_mask;\r\nf->chip.irq_mask = fpga_irq_mask;\r\nf->chip.irq_unmask = fpga_irq_unmask;\r\nf->valid = valid;\r\nif (parent_irq != -1) {\r\nirq_set_handler_data(parent_irq, f);\r\nirq_set_chained_handler(parent_irq, fpga_irq_handle);\r\n}\r\nf->domain = irq_domain_add_simple(node, fls(valid), irq_start,\r\n&fpga_irqdomain_ops, f);\r\nfor (i = 0; i < fls(valid); i++)\r\nif (valid & BIT(i)) {\r\nif (!irq_start)\r\nirq_create_mapping(f->domain, i);\r\nf->used_irqs++;\r\n}\r\npr_info("FPGA IRQ chip %d \"%s\" @ %p, %u irqs",\r\nfpga_irq_id, name, base, f->used_irqs);\r\nif (parent_irq != -1)\r\npr_cont(", parent IRQ: %d\n", parent_irq);\r\nelse\r\npr_cont("\n");\r\nfpga_irq_id++;\r\n}\r\nint __init fpga_irq_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nvoid __iomem *base;\r\nu32 clear_mask;\r\nu32 valid_mask;\r\nint parent_irq;\r\nif (WARN_ON(!node))\r\nreturn -ENODEV;\r\nbase = of_iomap(node, 0);\r\nWARN(!base, "unable to map fpga irq registers\n");\r\nif (of_property_read_u32(node, "clear-mask", &clear_mask))\r\nclear_mask = 0;\r\nif (of_property_read_u32(node, "valid-mask", &valid_mask))\r\nvalid_mask = 0;\r\nparent_irq = irq_of_parse_and_map(node, 0);\r\nif (!parent_irq)\r\nparent_irq = -1;\r\nfpga_irq_init(base, node->name, 0, parent_irq, valid_mask, node);\r\nwritel(clear_mask, base + IRQ_ENABLE_CLEAR);\r\nwritel(clear_mask, base + FIQ_ENABLE_CLEAR);\r\nreturn 0;\r\n}
