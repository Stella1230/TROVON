static u32 ns_to_src(struct src_sel *s, u32 ns)\r\n{\r\nns >>= s->src_sel_shift;\r\nns &= SRC_SEL_MASK;\r\nreturn ns;\r\n}\r\nstatic u32 src_to_ns(struct src_sel *s, u8 src, u32 ns)\r\n{\r\nu32 mask;\r\nmask = SRC_SEL_MASK;\r\nmask <<= s->src_sel_shift;\r\nns &= ~mask;\r\nns |= src << s->src_sel_shift;\r\nreturn ns;\r\n}\r\nstatic u8 clk_rcg_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nint num_parents = __clk_get_num_parents(hw->clk);\r\nu32 ns;\r\nint i;\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nns = ns_to_src(&rcg->s, ns);\r\nfor (i = 0; i < num_parents; i++)\r\nif (ns == rcg->s.parent_map[i])\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic int reg_to_bank(struct clk_dyn_rcg *rcg, u32 bank)\r\n{\r\nbank &= BIT(rcg->mux_sel_bit);\r\nreturn !!bank;\r\n}\r\nstatic u8 clk_dyn_rcg_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nint num_parents = __clk_get_num_parents(hw->clk);\r\nu32 ns, ctl;\r\nint bank;\r\nint i;\r\nstruct src_sel *s;\r\nregmap_read(rcg->clkr.regmap, rcg->clkr.enable_reg, &ctl);\r\nbank = reg_to_bank(rcg, ctl);\r\ns = &rcg->s[bank];\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nns = ns_to_src(s, ns);\r\nfor (i = 0; i < num_parents; i++)\r\nif (ns == s->parent_map[i])\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic int clk_rcg_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nu32 ns;\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nns = src_to_ns(&rcg->s, rcg->s.parent_map[index], ns);\r\nregmap_write(rcg->clkr.regmap, rcg->ns_reg, ns);\r\nreturn 0;\r\n}\r\nstatic u32 md_to_m(struct mn *mn, u32 md)\r\n{\r\nmd >>= mn->m_val_shift;\r\nmd &= BIT(mn->width) - 1;\r\nreturn md;\r\n}\r\nstatic u32 ns_to_pre_div(struct pre_div *p, u32 ns)\r\n{\r\nns >>= p->pre_div_shift;\r\nns &= BIT(p->pre_div_width) - 1;\r\nreturn ns;\r\n}\r\nstatic u32 pre_div_to_ns(struct pre_div *p, u8 pre_div, u32 ns)\r\n{\r\nu32 mask;\r\nmask = BIT(p->pre_div_width) - 1;\r\nmask <<= p->pre_div_shift;\r\nns &= ~mask;\r\nns |= pre_div << p->pre_div_shift;\r\nreturn ns;\r\n}\r\nstatic u32 mn_to_md(struct mn *mn, u32 m, u32 n, u32 md)\r\n{\r\nu32 mask, mask_w;\r\nmask_w = BIT(mn->width) - 1;\r\nmask = (mask_w << mn->m_val_shift) | mask_w;\r\nmd &= ~mask;\r\nif (n) {\r\nm <<= mn->m_val_shift;\r\nmd |= m;\r\nmd |= ~n & mask_w;\r\n}\r\nreturn md;\r\n}\r\nstatic u32 ns_m_to_n(struct mn *mn, u32 ns, u32 m)\r\n{\r\nns = ~ns >> mn->n_val_shift;\r\nns &= BIT(mn->width) - 1;\r\nreturn ns + m;\r\n}\r\nstatic u32 reg_to_mnctr_mode(struct mn *mn, u32 val)\r\n{\r\nval >>= mn->mnctr_mode_shift;\r\nval &= MNCTR_MODE_MASK;\r\nreturn val;\r\n}\r\nstatic u32 mn_to_ns(struct mn *mn, u32 m, u32 n, u32 ns)\r\n{\r\nu32 mask;\r\nmask = BIT(mn->width) - 1;\r\nmask <<= mn->n_val_shift;\r\nns &= ~mask;\r\nif (n) {\r\nn = n - m;\r\nn = ~n;\r\nn &= BIT(mn->width) - 1;\r\nn <<= mn->n_val_shift;\r\nns |= n;\r\n}\r\nreturn ns;\r\n}\r\nstatic u32 mn_to_reg(struct mn *mn, u32 m, u32 n, u32 val)\r\n{\r\nu32 mask;\r\nmask = MNCTR_MODE_MASK << mn->mnctr_mode_shift;\r\nmask |= BIT(mn->mnctr_en_bit);\r\nval &= ~mask;\r\nif (n) {\r\nval |= BIT(mn->mnctr_en_bit);\r\nval |= MNCTR_MODE_DUAL << mn->mnctr_mode_shift;\r\n}\r\nreturn val;\r\n}\r\nstatic void configure_bank(struct clk_dyn_rcg *rcg, const struct freq_tbl *f)\r\n{\r\nu32 ns, md, ctl, *regp;\r\nint bank, new_bank;\r\nstruct mn *mn;\r\nstruct pre_div *p;\r\nstruct src_sel *s;\r\nbool enabled;\r\nu32 md_reg;\r\nu32 bank_reg;\r\nbool banked_mn = !!rcg->mn[1].width;\r\nstruct clk_hw *hw = &rcg->clkr.hw;\r\nenabled = __clk_is_enabled(hw->clk);\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nregmap_read(rcg->clkr.regmap, rcg->clkr.enable_reg, &ctl);\r\nif (banked_mn) {\r\nregp = &ctl;\r\nbank_reg = rcg->clkr.enable_reg;\r\n} else {\r\nregp = &ns;\r\nbank_reg = rcg->ns_reg;\r\n}\r\nbank = reg_to_bank(rcg, *regp);\r\nnew_bank = enabled ? !bank : bank;\r\nif (banked_mn) {\r\nmn = &rcg->mn[new_bank];\r\nmd_reg = rcg->md_reg[new_bank];\r\nns |= BIT(mn->mnctr_reset_bit);\r\nregmap_write(rcg->clkr.regmap, rcg->ns_reg, ns);\r\nregmap_read(rcg->clkr.regmap, md_reg, &md);\r\nmd = mn_to_md(mn, f->m, f->n, md);\r\nregmap_write(rcg->clkr.regmap, md_reg, md);\r\nns = mn_to_ns(mn, f->m, f->n, ns);\r\nregmap_write(rcg->clkr.regmap, rcg->ns_reg, ns);\r\nctl = mn_to_reg(mn, f->m, f->n, ctl);\r\nregmap_write(rcg->clkr.regmap, rcg->clkr.enable_reg, ctl);\r\nns &= ~BIT(mn->mnctr_reset_bit);\r\nregmap_write(rcg->clkr.regmap, rcg->ns_reg, ns);\r\n} else {\r\np = &rcg->p[new_bank];\r\nns = pre_div_to_ns(p, f->pre_div - 1, ns);\r\n}\r\ns = &rcg->s[new_bank];\r\nns = src_to_ns(s, s->parent_map[f->src], ns);\r\nregmap_write(rcg->clkr.regmap, rcg->ns_reg, ns);\r\nif (enabled) {\r\n*regp ^= BIT(rcg->mux_sel_bit);\r\nregmap_write(rcg->clkr.regmap, bank_reg, *regp);\r\n}\r\n}\r\nstatic int clk_dyn_rcg_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nu32 ns, ctl, md, reg;\r\nint bank;\r\nstruct freq_tbl f = { 0 };\r\nbool banked_mn = !!rcg->mn[1].width;\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nregmap_read(rcg->clkr.regmap, rcg->clkr.enable_reg, &ctl);\r\nreg = banked_mn ? ctl : ns;\r\nbank = reg_to_bank(rcg, reg);\r\nif (banked_mn) {\r\nregmap_read(rcg->clkr.regmap, rcg->md_reg[bank], &md);\r\nf.m = md_to_m(&rcg->mn[bank], md);\r\nf.n = ns_m_to_n(&rcg->mn[bank], ns, f.m);\r\n} else {\r\nf.pre_div = ns_to_pre_div(&rcg->p[bank], ns) + 1;\r\n}\r\nf.src = index;\r\nconfigure_bank(rcg, &f);\r\nreturn 0;\r\n}\r\nstatic unsigned long\r\ncalc_rate(unsigned long rate, u32 m, u32 n, u32 mode, u32 pre_div)\r\n{\r\nif (pre_div)\r\nrate /= pre_div + 1;\r\nif (mode) {\r\nu64 tmp = rate;\r\ntmp *= m;\r\ndo_div(tmp, n);\r\nrate = tmp;\r\n}\r\nreturn rate;\r\n}\r\nstatic unsigned long\r\nclk_rcg_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nu32 pre_div, m = 0, n = 0, ns, md, mode = 0;\r\nstruct mn *mn = &rcg->mn;\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\npre_div = ns_to_pre_div(&rcg->p, ns);\r\nif (rcg->mn.width) {\r\nregmap_read(rcg->clkr.regmap, rcg->md_reg, &md);\r\nm = md_to_m(mn, md);\r\nn = ns_m_to_n(mn, ns, m);\r\nif (rcg->clkr.enable_reg != rcg->ns_reg)\r\nregmap_read(rcg->clkr.regmap, rcg->clkr.enable_reg, &mode);\r\nelse\r\nmode = ns;\r\nmode = reg_to_mnctr_mode(mn, mode);\r\n}\r\nreturn calc_rate(parent_rate, m, n, mode, pre_div);\r\n}\r\nstatic unsigned long\r\nclk_dyn_rcg_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nu32 m, n, pre_div, ns, md, mode, reg;\r\nint bank;\r\nstruct mn *mn;\r\nbool banked_mn = !!rcg->mn[1].width;\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nif (banked_mn)\r\nregmap_read(rcg->clkr.regmap, rcg->clkr.enable_reg, &reg);\r\nelse\r\nreg = ns;\r\nbank = reg_to_bank(rcg, reg);\r\nif (banked_mn) {\r\nmn = &rcg->mn[bank];\r\nregmap_read(rcg->clkr.regmap, rcg->md_reg[bank], &md);\r\nm = md_to_m(mn, md);\r\nn = ns_m_to_n(mn, ns, m);\r\nmode = reg_to_mnctr_mode(mn, reg);\r\nreturn calc_rate(parent_rate, m, n, mode, 0);\r\n} else {\r\npre_div = ns_to_pre_div(&rcg->p[bank], ns);\r\nreturn calc_rate(parent_rate, 0, 0, 0, pre_div);\r\n}\r\n}\r\nstatic const\r\nstruct freq_tbl *find_freq(const struct freq_tbl *f, unsigned long rate)\r\n{\r\nif (!f)\r\nreturn NULL;\r\nfor (; f->freq; f++)\r\nif (rate <= f->freq)\r\nreturn f;\r\nreturn NULL;\r\n}\r\nstatic long _freq_tbl_determine_rate(struct clk_hw *hw,\r\nconst struct freq_tbl *f, unsigned long rate,\r\nunsigned long *p_rate, struct clk **p)\r\n{\r\nunsigned long clk_flags;\r\nf = find_freq(f, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nclk_flags = __clk_get_flags(hw->clk);\r\n*p = clk_get_parent_by_index(hw->clk, f->src);\r\nif (clk_flags & CLK_SET_RATE_PARENT) {\r\nrate = rate * f->pre_div;\r\nif (f->n) {\r\nu64 tmp = rate;\r\ntmp = tmp * f->n;\r\ndo_div(tmp, f->m);\r\nrate = tmp;\r\n}\r\n} else {\r\nrate = __clk_get_rate(*p);\r\n}\r\n*p_rate = rate;\r\nreturn f->freq;\r\n}\r\nstatic long clk_rcg_determine_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *p_rate, struct clk **p)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nreturn _freq_tbl_determine_rate(hw, rcg->freq_tbl, rate, p_rate, p);\r\n}\r\nstatic long clk_dyn_rcg_determine_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *p_rate, struct clk **p)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nreturn _freq_tbl_determine_rate(hw, rcg->freq_tbl, rate, p_rate, p);\r\n}\r\nstatic int clk_rcg_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nconst struct freq_tbl *f;\r\nu32 ns, md, ctl;\r\nstruct mn *mn = &rcg->mn;\r\nu32 mask = 0;\r\nunsigned int reset_reg;\r\nf = find_freq(rcg->freq_tbl, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nif (rcg->mn.reset_in_cc)\r\nreset_reg = rcg->clkr.enable_reg;\r\nelse\r\nreset_reg = rcg->ns_reg;\r\nif (rcg->mn.width) {\r\nmask = BIT(mn->mnctr_reset_bit);\r\nregmap_update_bits(rcg->clkr.regmap, reset_reg, mask, mask);\r\nregmap_read(rcg->clkr.regmap, rcg->md_reg, &md);\r\nmd = mn_to_md(mn, f->m, f->n, md);\r\nregmap_write(rcg->clkr.regmap, rcg->md_reg, md);\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nif (rcg->clkr.enable_reg != rcg->ns_reg) {\r\nregmap_read(rcg->clkr.regmap, rcg->clkr.enable_reg, &ctl);\r\nctl = mn_to_reg(mn, f->m, f->n, ctl);\r\nregmap_write(rcg->clkr.regmap, rcg->clkr.enable_reg, ctl);\r\n} else {\r\nns = mn_to_reg(mn, f->m, f->n, ns);\r\n}\r\nns = mn_to_ns(mn, f->m, f->n, ns);\r\n} else {\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\n}\r\nns = pre_div_to_ns(&rcg->p, f->pre_div - 1, ns);\r\nregmap_write(rcg->clkr.regmap, rcg->ns_reg, ns);\r\nregmap_update_bits(rcg->clkr.regmap, reset_reg, mask, 0);\r\nreturn 0;\r\n}\r\nstatic int __clk_dyn_rcg_set_rate(struct clk_hw *hw, unsigned long rate)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nconst struct freq_tbl *f;\r\nf = find_freq(rcg->freq_tbl, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nconfigure_bank(rcg, f);\r\nreturn 0;\r\n}\r\nstatic int clk_dyn_rcg_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nreturn __clk_dyn_rcg_set_rate(hw, rate);\r\n}\r\nstatic int clk_dyn_rcg_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate, u8 index)\r\n{\r\nreturn __clk_dyn_rcg_set_rate(hw, rate);\r\n}
