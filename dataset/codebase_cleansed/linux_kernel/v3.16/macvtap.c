static struct macvlan_dev *macvtap_get_vlan_rcu(const struct net_device *dev)\r\n{\r\nreturn rcu_dereference(dev->rx_handler_data);\r\n}\r\nstatic int macvtap_enable_queue(struct net_device *dev, struct file *file,\r\nstruct macvtap_queue *q)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nint err = -EINVAL;\r\nASSERT_RTNL();\r\nif (q->enabled)\r\ngoto out;\r\nerr = 0;\r\nrcu_assign_pointer(vlan->taps[vlan->numvtaps], q);\r\nq->queue_index = vlan->numvtaps;\r\nq->enabled = true;\r\nvlan->numvtaps++;\r\nout:\r\nreturn err;\r\n}\r\nstatic int macvtap_set_queue(struct net_device *dev, struct file *file,\r\nstruct macvtap_queue *q)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nint err = -EBUSY;\r\nrtnl_lock();\r\nif (vlan->numqueues == MAX_MACVTAP_QUEUES)\r\ngoto out;\r\nerr = 0;\r\nrcu_assign_pointer(q->vlan, vlan);\r\nrcu_assign_pointer(vlan->taps[vlan->numvtaps], q);\r\nsock_hold(&q->sk);\r\nq->file = file;\r\nq->queue_index = vlan->numvtaps;\r\nq->enabled = true;\r\nfile->private_data = q;\r\nlist_add_tail(&q->next, &vlan->queue_list);\r\nvlan->numvtaps++;\r\nvlan->numqueues++;\r\nout:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic int macvtap_disable_queue(struct macvtap_queue *q)\r\n{\r\nstruct macvlan_dev *vlan;\r\nstruct macvtap_queue *nq;\r\nASSERT_RTNL();\r\nif (!q->enabled)\r\nreturn -EINVAL;\r\nvlan = rtnl_dereference(q->vlan);\r\nif (vlan) {\r\nint index = q->queue_index;\r\nBUG_ON(index >= vlan->numvtaps);\r\nnq = rtnl_dereference(vlan->taps[vlan->numvtaps - 1]);\r\nnq->queue_index = index;\r\nrcu_assign_pointer(vlan->taps[index], nq);\r\nRCU_INIT_POINTER(vlan->taps[vlan->numvtaps - 1], NULL);\r\nq->enabled = false;\r\nvlan->numvtaps--;\r\n}\r\nreturn 0;\r\n}\r\nstatic void macvtap_put_queue(struct macvtap_queue *q)\r\n{\r\nstruct macvlan_dev *vlan;\r\nrtnl_lock();\r\nvlan = rtnl_dereference(q->vlan);\r\nif (vlan) {\r\nif (q->enabled)\r\nBUG_ON(macvtap_disable_queue(q));\r\nvlan->numqueues--;\r\nRCU_INIT_POINTER(q->vlan, NULL);\r\nsock_put(&q->sk);\r\nlist_del_init(&q->next);\r\n}\r\nrtnl_unlock();\r\nsynchronize_rcu();\r\nsock_put(&q->sk);\r\n}\r\nstatic struct macvtap_queue *macvtap_get_queue(struct net_device *dev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct macvtap_queue *tap = NULL;\r\nint numvtaps = ACCESS_ONCE(vlan->numvtaps);\r\n__u32 rxq;\r\nif (!numvtaps)\r\ngoto out;\r\nrxq = skb_get_hash(skb);\r\nif (rxq) {\r\ntap = rcu_dereference(vlan->taps[rxq % numvtaps]);\r\ngoto out;\r\n}\r\nif (likely(skb_rx_queue_recorded(skb))) {\r\nrxq = skb_get_rx_queue(skb);\r\nwhile (unlikely(rxq >= numvtaps))\r\nrxq -= numvtaps;\r\ntap = rcu_dereference(vlan->taps[rxq]);\r\ngoto out;\r\n}\r\ntap = rcu_dereference(vlan->taps[0]);\r\nout:\r\nreturn tap;\r\n}\r\nstatic void macvtap_del_queues(struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct macvtap_queue *q, *tmp, *qlist[MAX_MACVTAP_QUEUES];\r\nint i, j = 0;\r\nASSERT_RTNL();\r\nlist_for_each_entry_safe(q, tmp, &vlan->queue_list, next) {\r\nlist_del_init(&q->next);\r\nqlist[j++] = q;\r\nRCU_INIT_POINTER(q->vlan, NULL);\r\nif (q->enabled)\r\nvlan->numvtaps--;\r\nvlan->numqueues--;\r\n}\r\nfor (i = 0; i < vlan->numvtaps; i++)\r\nRCU_INIT_POINTER(vlan->taps[i], NULL);\r\nBUG_ON(vlan->numvtaps);\r\nBUG_ON(vlan->numqueues);\r\nvlan->numvtaps = MAX_MACVTAP_QUEUES;\r\nfor (--j; j >= 0; j--)\r\nsock_put(&qlist[j]->sk);\r\n}\r\nstatic rx_handler_result_t macvtap_handle_frame(struct sk_buff **pskb)\r\n{\r\nstruct sk_buff *skb = *pskb;\r\nstruct net_device *dev = skb->dev;\r\nstruct macvlan_dev *vlan;\r\nstruct macvtap_queue *q;\r\nnetdev_features_t features = TAP_FEATURES;\r\nvlan = macvtap_get_vlan_rcu(dev);\r\nif (!vlan)\r\nreturn RX_HANDLER_PASS;\r\nq = macvtap_get_queue(dev, skb);\r\nif (!q)\r\nreturn RX_HANDLER_PASS;\r\nif (skb_queue_len(&q->sk.sk_receive_queue) >= dev->tx_queue_len)\r\ngoto drop;\r\nskb_push(skb, ETH_HLEN);\r\nif (q->flags & IFF_VNET_HDR)\r\nfeatures |= vlan->tap_features;\r\nif (netif_needs_gso(skb, features)) {\r\nstruct sk_buff *segs = __skb_gso_segment(skb, features, false);\r\nif (IS_ERR(segs))\r\ngoto drop;\r\nif (!segs) {\r\nskb_queue_tail(&q->sk.sk_receive_queue, skb);\r\ngoto wake_up;\r\n}\r\nkfree_skb(skb);\r\nwhile (segs) {\r\nstruct sk_buff *nskb = segs->next;\r\nsegs->next = NULL;\r\nskb_queue_tail(&q->sk.sk_receive_queue, segs);\r\nsegs = nskb;\r\n}\r\n} else {\r\nif (skb->ip_summed == CHECKSUM_PARTIAL &&\r\n!(features & NETIF_F_ALL_CSUM) &&\r\nskb_checksum_help(skb))\r\ngoto drop;\r\nskb_queue_tail(&q->sk.sk_receive_queue, skb);\r\n}\r\nwake_up:\r\nwake_up_interruptible_poll(sk_sleep(&q->sk), POLLIN | POLLRDNORM | POLLRDBAND);\r\nreturn RX_HANDLER_CONSUMED;\r\ndrop:\r\nmacvlan_count_rx(vlan, 0, 0, 0);\r\nkfree_skb(skb);\r\nreturn RX_HANDLER_CONSUMED;\r\n}\r\nstatic int macvtap_get_minor(struct macvlan_dev *vlan)\r\n{\r\nint retval = -ENOMEM;\r\nmutex_lock(&minor_lock);\r\nretval = idr_alloc(&minor_idr, vlan, 1, MACVTAP_NUM_DEVS, GFP_KERNEL);\r\nif (retval >= 0) {\r\nvlan->minor = retval;\r\n} else if (retval == -ENOSPC) {\r\nprintk(KERN_ERR "too many macvtap devices\n");\r\nretval = -EINVAL;\r\n}\r\nmutex_unlock(&minor_lock);\r\nreturn retval < 0 ? retval : 0;\r\n}\r\nstatic void macvtap_free_minor(struct macvlan_dev *vlan)\r\n{\r\nmutex_lock(&minor_lock);\r\nif (vlan->minor) {\r\nidr_remove(&minor_idr, vlan->minor);\r\nvlan->minor = 0;\r\n}\r\nmutex_unlock(&minor_lock);\r\n}\r\nstatic struct net_device *dev_get_by_macvtap_minor(int minor)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct macvlan_dev *vlan;\r\nmutex_lock(&minor_lock);\r\nvlan = idr_find(&minor_idr, minor);\r\nif (vlan) {\r\ndev = vlan->dev;\r\ndev_hold(dev);\r\n}\r\nmutex_unlock(&minor_lock);\r\nreturn dev;\r\n}\r\nstatic int macvtap_newlink(struct net *src_net,\r\nstruct net_device *dev,\r\nstruct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nint err;\r\nINIT_LIST_HEAD(&vlan->queue_list);\r\nvlan->tap_features = TUN_OFFLOADS;\r\nerr = netdev_rx_handler_register(dev, macvtap_handle_frame, vlan);\r\nif (err)\r\nreturn err;\r\nreturn macvlan_common_newlink(src_net, dev, tb, data);\r\n}\r\nstatic void macvtap_dellink(struct net_device *dev,\r\nstruct list_head *head)\r\n{\r\nnetdev_rx_handler_unregister(dev);\r\nmacvtap_del_queues(dev);\r\nmacvlan_dellink(dev, head);\r\n}\r\nstatic void macvtap_setup(struct net_device *dev)\r\n{\r\nmacvlan_common_setup(dev);\r\ndev->tx_queue_len = TUN_READQ_SIZE;\r\n}\r\nstatic void macvtap_sock_write_space(struct sock *sk)\r\n{\r\nwait_queue_head_t *wqueue;\r\nif (!sock_writeable(sk) ||\r\n!test_and_clear_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags))\r\nreturn;\r\nwqueue = sk_sleep(sk);\r\nif (wqueue && waitqueue_active(wqueue))\r\nwake_up_interruptible_poll(wqueue, POLLOUT | POLLWRNORM | POLLWRBAND);\r\n}\r\nstatic void macvtap_sock_destruct(struct sock *sk)\r\n{\r\nskb_queue_purge(&sk->sk_receive_queue);\r\n}\r\nstatic int macvtap_open(struct inode *inode, struct file *file)\r\n{\r\nstruct net *net = current->nsproxy->net_ns;\r\nstruct net_device *dev = dev_get_by_macvtap_minor(iminor(inode));\r\nstruct macvtap_queue *q;\r\nint err;\r\nerr = -ENODEV;\r\nif (!dev)\r\ngoto out;\r\nerr = -ENOMEM;\r\nq = (struct macvtap_queue *)sk_alloc(net, AF_UNSPEC, GFP_KERNEL,\r\n&macvtap_proto);\r\nif (!q)\r\ngoto out;\r\nRCU_INIT_POINTER(q->sock.wq, &q->wq);\r\ninit_waitqueue_head(&q->wq.wait);\r\nq->sock.type = SOCK_RAW;\r\nq->sock.state = SS_CONNECTED;\r\nq->sock.file = file;\r\nq->sock.ops = &macvtap_socket_ops;\r\nsock_init_data(&q->sock, &q->sk);\r\nq->sk.sk_write_space = macvtap_sock_write_space;\r\nq->sk.sk_destruct = macvtap_sock_destruct;\r\nq->flags = IFF_VNET_HDR | IFF_NO_PI | IFF_TAP;\r\nq->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\r\nif ((dev->features & NETIF_F_HIGHDMA) && (dev->features & NETIF_F_SG))\r\nsock_set_flag(&q->sk, SOCK_ZEROCOPY);\r\nerr = macvtap_set_queue(dev, file, q);\r\nif (err)\r\nsock_put(&q->sk);\r\nout:\r\nif (dev)\r\ndev_put(dev);\r\nreturn err;\r\n}\r\nstatic int macvtap_release(struct inode *inode, struct file *file)\r\n{\r\nstruct macvtap_queue *q = file->private_data;\r\nmacvtap_put_queue(q);\r\nreturn 0;\r\n}\r\nstatic unsigned int macvtap_poll(struct file *file, poll_table * wait)\r\n{\r\nstruct macvtap_queue *q = file->private_data;\r\nunsigned int mask = POLLERR;\r\nif (!q)\r\ngoto out;\r\nmask = 0;\r\npoll_wait(file, &q->wq.wait, wait);\r\nif (!skb_queue_empty(&q->sk.sk_receive_queue))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (sock_writeable(&q->sk) ||\r\n(!test_and_set_bit(SOCK_ASYNC_NOSPACE, &q->sock.flags) &&\r\nsock_writeable(&q->sk)))\r\nmask |= POLLOUT | POLLWRNORM;\r\nout:\r\nreturn mask;\r\n}\r\nstatic inline struct sk_buff *macvtap_alloc_skb(struct sock *sk, size_t prepad,\r\nsize_t len, size_t linear,\r\nint noblock, int *err)\r\n{\r\nstruct sk_buff *skb;\r\nif (prepad + len < PAGE_SIZE || !linear)\r\nlinear = len;\r\nskb = sock_alloc_send_pskb(sk, prepad + linear, len - linear, noblock,\r\nerr, 0);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, prepad);\r\nskb_put(skb, linear);\r\nskb->data_len = len - linear;\r\nskb->len += len - linear;\r\nreturn skb;\r\n}\r\nstatic int macvtap_skb_from_vnet_hdr(struct sk_buff *skb,\r\nstruct virtio_net_hdr *vnet_hdr)\r\n{\r\nunsigned short gso_type = 0;\r\nif (vnet_hdr->gso_type != VIRTIO_NET_HDR_GSO_NONE) {\r\nswitch (vnet_hdr->gso_type & ~VIRTIO_NET_HDR_GSO_ECN) {\r\ncase VIRTIO_NET_HDR_GSO_TCPV4:\r\ngso_type = SKB_GSO_TCPV4;\r\nbreak;\r\ncase VIRTIO_NET_HDR_GSO_TCPV6:\r\ngso_type = SKB_GSO_TCPV6;\r\nbreak;\r\ncase VIRTIO_NET_HDR_GSO_UDP:\r\ngso_type = SKB_GSO_UDP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (vnet_hdr->gso_type & VIRTIO_NET_HDR_GSO_ECN)\r\ngso_type |= SKB_GSO_TCP_ECN;\r\nif (vnet_hdr->gso_size == 0)\r\nreturn -EINVAL;\r\n}\r\nif (vnet_hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) {\r\nif (!skb_partial_csum_set(skb, vnet_hdr->csum_start,\r\nvnet_hdr->csum_offset))\r\nreturn -EINVAL;\r\n}\r\nif (vnet_hdr->gso_type != VIRTIO_NET_HDR_GSO_NONE) {\r\nskb_shinfo(skb)->gso_size = vnet_hdr->gso_size;\r\nskb_shinfo(skb)->gso_type = gso_type;\r\nskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\r\nskb_shinfo(skb)->gso_segs = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void macvtap_skb_to_vnet_hdr(const struct sk_buff *skb,\r\nstruct virtio_net_hdr *vnet_hdr)\r\n{\r\nmemset(vnet_hdr, 0, sizeof(*vnet_hdr));\r\nif (skb_is_gso(skb)) {\r\nstruct skb_shared_info *sinfo = skb_shinfo(skb);\r\nvnet_hdr->hdr_len = skb_headlen(skb);\r\nvnet_hdr->gso_size = sinfo->gso_size;\r\nif (sinfo->gso_type & SKB_GSO_TCPV4)\r\nvnet_hdr->gso_type = VIRTIO_NET_HDR_GSO_TCPV4;\r\nelse if (sinfo->gso_type & SKB_GSO_TCPV6)\r\nvnet_hdr->gso_type = VIRTIO_NET_HDR_GSO_TCPV6;\r\nelse if (sinfo->gso_type & SKB_GSO_UDP)\r\nvnet_hdr->gso_type = VIRTIO_NET_HDR_GSO_UDP;\r\nelse\r\nBUG();\r\nif (sinfo->gso_type & SKB_GSO_TCP_ECN)\r\nvnet_hdr->gso_type |= VIRTIO_NET_HDR_GSO_ECN;\r\n} else\r\nvnet_hdr->gso_type = VIRTIO_NET_HDR_GSO_NONE;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nvnet_hdr->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\r\nvnet_hdr->csum_start = skb_checksum_start_offset(skb);\r\nvnet_hdr->csum_offset = skb->csum_offset;\r\n} else if (skb->ip_summed == CHECKSUM_UNNECESSARY) {\r\nvnet_hdr->flags = VIRTIO_NET_HDR_F_DATA_VALID;\r\n}\r\n}\r\nstatic ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,\r\nconst struct iovec *iv, unsigned long total_len,\r\nsize_t count, int noblock)\r\n{\r\nint good_linear = SKB_MAX_HEAD(NET_IP_ALIGN);\r\nstruct sk_buff *skb;\r\nstruct macvlan_dev *vlan;\r\nunsigned long len = total_len;\r\nint err;\r\nstruct virtio_net_hdr vnet_hdr = { 0 };\r\nint vnet_hdr_len = 0;\r\nint copylen = 0;\r\nbool zerocopy = false;\r\nsize_t linear;\r\nif (q->flags & IFF_VNET_HDR) {\r\nvnet_hdr_len = q->vnet_hdr_sz;\r\nerr = -EINVAL;\r\nif (len < vnet_hdr_len)\r\ngoto err;\r\nlen -= vnet_hdr_len;\r\nerr = memcpy_fromiovecend((void *)&vnet_hdr, iv, 0,\r\nsizeof(vnet_hdr));\r\nif (err < 0)\r\ngoto err;\r\nif ((vnet_hdr.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&\r\nvnet_hdr.csum_start + vnet_hdr.csum_offset + 2 >\r\nvnet_hdr.hdr_len)\r\nvnet_hdr.hdr_len = vnet_hdr.csum_start +\r\nvnet_hdr.csum_offset + 2;\r\nerr = -EINVAL;\r\nif (vnet_hdr.hdr_len > len)\r\ngoto err;\r\n}\r\nerr = -EINVAL;\r\nif (unlikely(len < ETH_HLEN))\r\ngoto err;\r\nerr = -EMSGSIZE;\r\nif (unlikely(count > UIO_MAXIOV))\r\ngoto err;\r\nif (m && m->msg_control && sock_flag(&q->sk, SOCK_ZEROCOPY)) {\r\ncopylen = vnet_hdr.hdr_len ? vnet_hdr.hdr_len : GOODCOPY_LEN;\r\nif (copylen > good_linear)\r\ncopylen = good_linear;\r\nlinear = copylen;\r\nif (iov_pages(iv, vnet_hdr_len + copylen, count)\r\n<= MAX_SKB_FRAGS)\r\nzerocopy = true;\r\n}\r\nif (!zerocopy) {\r\ncopylen = len;\r\nif (vnet_hdr.hdr_len > good_linear)\r\nlinear = good_linear;\r\nelse\r\nlinear = vnet_hdr.hdr_len;\r\n}\r\nskb = macvtap_alloc_skb(&q->sk, NET_IP_ALIGN, copylen,\r\nlinear, noblock, &err);\r\nif (!skb)\r\ngoto err;\r\nif (zerocopy)\r\nerr = zerocopy_sg_from_iovec(skb, iv, vnet_hdr_len, count);\r\nelse {\r\nerr = skb_copy_datagram_from_iovec(skb, 0, iv, vnet_hdr_len,\r\nlen);\r\nif (!err && m && m->msg_control) {\r\nstruct ubuf_info *uarg = m->msg_control;\r\nuarg->callback(uarg, false);\r\n}\r\n}\r\nif (err)\r\ngoto err_kfree;\r\nskb_set_network_header(skb, ETH_HLEN);\r\nskb_reset_mac_header(skb);\r\nskb->protocol = eth_hdr(skb)->h_proto;\r\nif (vnet_hdr_len) {\r\nerr = macvtap_skb_from_vnet_hdr(skb, &vnet_hdr);\r\nif (err)\r\ngoto err_kfree;\r\n}\r\nskb_probe_transport_header(skb, ETH_HLEN);\r\nrcu_read_lock();\r\nvlan = rcu_dereference(q->vlan);\r\nif (zerocopy) {\r\nskb_shinfo(skb)->destructor_arg = m->msg_control;\r\nskb_shinfo(skb)->tx_flags |= SKBTX_DEV_ZEROCOPY;\r\nskb_shinfo(skb)->tx_flags |= SKBTX_SHARED_FRAG;\r\n}\r\nif (vlan) {\r\nskb->dev = vlan->dev;\r\ndev_queue_xmit(skb);\r\n} else {\r\nkfree_skb(skb);\r\n}\r\nrcu_read_unlock();\r\nreturn total_len;\r\nerr_kfree:\r\nkfree_skb(skb);\r\nerr:\r\nrcu_read_lock();\r\nvlan = rcu_dereference(q->vlan);\r\nif (vlan)\r\nthis_cpu_inc(vlan->pcpu_stats->tx_dropped);\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic ssize_t macvtap_aio_write(struct kiocb *iocb, const struct iovec *iv,\r\nunsigned long count, loff_t pos)\r\n{\r\nstruct file *file = iocb->ki_filp;\r\nssize_t result = -ENOLINK;\r\nstruct macvtap_queue *q = file->private_data;\r\nresult = macvtap_get_user(q, NULL, iv, iov_length(iv, count), count,\r\nfile->f_flags & O_NONBLOCK);\r\nreturn result;\r\n}\r\nstatic ssize_t macvtap_put_user(struct macvtap_queue *q,\r\nconst struct sk_buff *skb,\r\nconst struct iovec *iv, int len)\r\n{\r\nint ret;\r\nint vnet_hdr_len = 0;\r\nint vlan_offset = 0;\r\nint copied, total;\r\nif (q->flags & IFF_VNET_HDR) {\r\nstruct virtio_net_hdr vnet_hdr;\r\nvnet_hdr_len = q->vnet_hdr_sz;\r\nif ((len -= vnet_hdr_len) < 0)\r\nreturn -EINVAL;\r\nmacvtap_skb_to_vnet_hdr(skb, &vnet_hdr);\r\nif (memcpy_toiovecend(iv, (void *)&vnet_hdr, 0, sizeof(vnet_hdr)))\r\nreturn -EFAULT;\r\n}\r\ntotal = copied = vnet_hdr_len;\r\ntotal += skb->len;\r\nif (!vlan_tx_tag_present(skb))\r\nlen = min_t(int, skb->len, len);\r\nelse {\r\nint copy;\r\nstruct {\r\n__be16 h_vlan_proto;\r\n__be16 h_vlan_TCI;\r\n} veth;\r\nveth.h_vlan_proto = skb->vlan_proto;\r\nveth.h_vlan_TCI = htons(vlan_tx_tag_get(skb));\r\nvlan_offset = offsetof(struct vlan_ethhdr, h_vlan_proto);\r\nlen = min_t(int, skb->len + VLAN_HLEN, len);\r\ntotal += VLAN_HLEN;\r\ncopy = min_t(int, vlan_offset, len);\r\nret = skb_copy_datagram_const_iovec(skb, 0, iv, copied, copy);\r\nlen -= copy;\r\ncopied += copy;\r\nif (ret || !len)\r\ngoto done;\r\ncopy = min_t(int, sizeof(veth), len);\r\nret = memcpy_toiovecend(iv, (void *)&veth, copied, copy);\r\nlen -= copy;\r\ncopied += copy;\r\nif (ret || !len)\r\ngoto done;\r\n}\r\nret = skb_copy_datagram_const_iovec(skb, vlan_offset, iv, copied, len);\r\ndone:\r\nreturn ret ? ret : total;\r\n}\r\nstatic ssize_t macvtap_do_read(struct macvtap_queue *q,\r\nconst struct iovec *iv, unsigned long len,\r\nint noblock)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct sk_buff *skb;\r\nssize_t ret = 0;\r\nwhile (len) {\r\nif (!noblock)\r\nprepare_to_wait(sk_sleep(&q->sk), &wait,\r\nTASK_INTERRUPTIBLE);\r\nskb = skb_dequeue(&q->sk.sk_receive_queue);\r\nif (!skb) {\r\nif (noblock) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nschedule();\r\ncontinue;\r\n}\r\nret = macvtap_put_user(q, skb, iv, len);\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nif (!noblock)\r\nfinish_wait(sk_sleep(&q->sk), &wait);\r\nreturn ret;\r\n}\r\nstatic ssize_t macvtap_aio_read(struct kiocb *iocb, const struct iovec *iv,\r\nunsigned long count, loff_t pos)\r\n{\r\nstruct file *file = iocb->ki_filp;\r\nstruct macvtap_queue *q = file->private_data;\r\nssize_t len, ret = 0;\r\nlen = iov_length(iv, count);\r\nif (len < 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = macvtap_do_read(q, iv, len, file->f_flags & O_NONBLOCK);\r\nret = min_t(ssize_t, ret, len);\r\nif (ret > 0)\r\niocb->ki_pos = ret;\r\nout:\r\nreturn ret;\r\n}\r\nstatic struct macvlan_dev *macvtap_get_vlan(struct macvtap_queue *q)\r\n{\r\nstruct macvlan_dev *vlan;\r\nASSERT_RTNL();\r\nvlan = rtnl_dereference(q->vlan);\r\nif (vlan)\r\ndev_hold(vlan->dev);\r\nreturn vlan;\r\n}\r\nstatic void macvtap_put_vlan(struct macvlan_dev *vlan)\r\n{\r\ndev_put(vlan->dev);\r\n}\r\nstatic int macvtap_ioctl_set_queue(struct file *file, unsigned int flags)\r\n{\r\nstruct macvtap_queue *q = file->private_data;\r\nstruct macvlan_dev *vlan;\r\nint ret;\r\nvlan = macvtap_get_vlan(q);\r\nif (!vlan)\r\nreturn -EINVAL;\r\nif (flags & IFF_ATTACH_QUEUE)\r\nret = macvtap_enable_queue(vlan->dev, file, q);\r\nelse if (flags & IFF_DETACH_QUEUE)\r\nret = macvtap_disable_queue(q);\r\nelse\r\nret = -EINVAL;\r\nmacvtap_put_vlan(vlan);\r\nreturn ret;\r\n}\r\nstatic int set_offload(struct macvtap_queue *q, unsigned long arg)\r\n{\r\nstruct macvlan_dev *vlan;\r\nnetdev_features_t features;\r\nnetdev_features_t feature_mask = 0;\r\nvlan = rtnl_dereference(q->vlan);\r\nif (!vlan)\r\nreturn -ENOLINK;\r\nfeatures = vlan->dev->features;\r\nif (arg & TUN_F_CSUM) {\r\nfeature_mask = NETIF_F_HW_CSUM;\r\nif (arg & (TUN_F_TSO4 | TUN_F_TSO6)) {\r\nif (arg & TUN_F_TSO_ECN)\r\nfeature_mask |= NETIF_F_TSO_ECN;\r\nif (arg & TUN_F_TSO4)\r\nfeature_mask |= NETIF_F_TSO;\r\nif (arg & TUN_F_TSO6)\r\nfeature_mask |= NETIF_F_TSO6;\r\n}\r\nif (arg & TUN_F_UFO)\r\nfeature_mask |= NETIF_F_UFO;\r\n}\r\nif (feature_mask & (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_UFO))\r\nfeatures |= RX_OFFLOADS;\r\nelse\r\nfeatures &= ~RX_OFFLOADS;\r\nvlan->tap_features = feature_mask;\r\nvlan->set_features = features;\r\nnetdev_update_features(vlan->dev);\r\nreturn 0;\r\n}\r\nstatic long macvtap_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct macvtap_queue *q = file->private_data;\r\nstruct macvlan_dev *vlan;\r\nvoid __user *argp = (void __user *)arg;\r\nstruct ifreq __user *ifr = argp;\r\nunsigned int __user *up = argp;\r\nunsigned int u;\r\nint __user *sp = argp;\r\nint s;\r\nint ret;\r\nswitch (cmd) {\r\ncase TUNSETIFF:\r\nif (get_user(u, &ifr->ifr_flags))\r\nreturn -EFAULT;\r\nret = 0;\r\nif ((u & ~(IFF_VNET_HDR | IFF_MULTI_QUEUE)) !=\r\n(IFF_NO_PI | IFF_TAP))\r\nret = -EINVAL;\r\nelse\r\nq->flags = u;\r\nreturn ret;\r\ncase TUNGETIFF:\r\nrtnl_lock();\r\nvlan = macvtap_get_vlan(q);\r\nif (!vlan) {\r\nrtnl_unlock();\r\nreturn -ENOLINK;\r\n}\r\nret = 0;\r\nif (copy_to_user(&ifr->ifr_name, vlan->dev->name, IFNAMSIZ) ||\r\nput_user(q->flags, &ifr->ifr_flags))\r\nret = -EFAULT;\r\nmacvtap_put_vlan(vlan);\r\nrtnl_unlock();\r\nreturn ret;\r\ncase TUNSETQUEUE:\r\nif (get_user(u, &ifr->ifr_flags))\r\nreturn -EFAULT;\r\nrtnl_lock();\r\nret = macvtap_ioctl_set_queue(file, u);\r\nrtnl_unlock();\r\nreturn ret;\r\ncase TUNGETFEATURES:\r\nif (put_user(IFF_TAP | IFF_NO_PI | IFF_VNET_HDR |\r\nIFF_MULTI_QUEUE, up))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase TUNSETSNDBUF:\r\nif (get_user(u, up))\r\nreturn -EFAULT;\r\nq->sk.sk_sndbuf = u;\r\nreturn 0;\r\ncase TUNGETVNETHDRSZ:\r\ns = q->vnet_hdr_sz;\r\nif (put_user(s, sp))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase TUNSETVNETHDRSZ:\r\nif (get_user(s, sp))\r\nreturn -EFAULT;\r\nif (s < (int)sizeof(struct virtio_net_hdr))\r\nreturn -EINVAL;\r\nq->vnet_hdr_sz = s;\r\nreturn 0;\r\ncase TUNSETOFFLOAD:\r\nif (arg & ~(TUN_F_CSUM | TUN_F_TSO4 | TUN_F_TSO6 |\r\nTUN_F_TSO_ECN | TUN_F_UFO))\r\nreturn -EINVAL;\r\nrtnl_lock();\r\nret = set_offload(q, arg);\r\nrtnl_unlock();\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic long macvtap_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn macvtap_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic int macvtap_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *m, size_t total_len)\r\n{\r\nstruct macvtap_queue *q = container_of(sock, struct macvtap_queue, sock);\r\nreturn macvtap_get_user(q, m, m->msg_iov, total_len, m->msg_iovlen,\r\nm->msg_flags & MSG_DONTWAIT);\r\n}\r\nstatic int macvtap_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *m, size_t total_len,\r\nint flags)\r\n{\r\nstruct macvtap_queue *q = container_of(sock, struct macvtap_queue, sock);\r\nint ret;\r\nif (flags & ~(MSG_DONTWAIT|MSG_TRUNC))\r\nreturn -EINVAL;\r\nret = macvtap_do_read(q, m->msg_iov, total_len,\r\nflags & MSG_DONTWAIT);\r\nif (ret > total_len) {\r\nm->msg_flags |= MSG_TRUNC;\r\nret = flags & MSG_TRUNC ? ret : total_len;\r\n}\r\nreturn ret;\r\n}\r\nstruct socket *macvtap_get_socket(struct file *file)\r\n{\r\nstruct macvtap_queue *q;\r\nif (file->f_op != &macvtap_fops)\r\nreturn ERR_PTR(-EINVAL);\r\nq = file->private_data;\r\nif (!q)\r\nreturn ERR_PTR(-EBADFD);\r\nreturn &q->sock;\r\n}\r\nstatic int macvtap_device_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct macvlan_dev *vlan;\r\nstruct device *classdev;\r\ndev_t devt;\r\nint err;\r\nif (dev->rtnl_link_ops != &macvtap_link_ops)\r\nreturn NOTIFY_DONE;\r\nvlan = netdev_priv(dev);\r\nswitch (event) {\r\ncase NETDEV_REGISTER:\r\nerr = macvtap_get_minor(vlan);\r\nif (err)\r\nreturn notifier_from_errno(err);\r\ndevt = MKDEV(MAJOR(macvtap_major), vlan->minor);\r\nclassdev = device_create(macvtap_class, &dev->dev, devt,\r\ndev, "tap%d", dev->ifindex);\r\nif (IS_ERR(classdev)) {\r\nmacvtap_free_minor(vlan);\r\nreturn notifier_from_errno(PTR_ERR(classdev));\r\n}\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\ndevt = MKDEV(MAJOR(macvtap_major), vlan->minor);\r\ndevice_destroy(macvtap_class, devt);\r\nmacvtap_free_minor(vlan);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int macvtap_init(void)\r\n{\r\nint err;\r\nerr = alloc_chrdev_region(&macvtap_major, 0,\r\nMACVTAP_NUM_DEVS, "macvtap");\r\nif (err)\r\ngoto out1;\r\ncdev_init(&macvtap_cdev, &macvtap_fops);\r\nerr = cdev_add(&macvtap_cdev, macvtap_major, MACVTAP_NUM_DEVS);\r\nif (err)\r\ngoto out2;\r\nmacvtap_class = class_create(THIS_MODULE, "macvtap");\r\nif (IS_ERR(macvtap_class)) {\r\nerr = PTR_ERR(macvtap_class);\r\ngoto out3;\r\n}\r\nerr = register_netdevice_notifier(&macvtap_notifier_block);\r\nif (err)\r\ngoto out4;\r\nerr = macvlan_link_register(&macvtap_link_ops);\r\nif (err)\r\ngoto out5;\r\nreturn 0;\r\nout5:\r\nunregister_netdevice_notifier(&macvtap_notifier_block);\r\nout4:\r\nclass_unregister(macvtap_class);\r\nout3:\r\ncdev_del(&macvtap_cdev);\r\nout2:\r\nunregister_chrdev_region(macvtap_major, MACVTAP_NUM_DEVS);\r\nout1:\r\nreturn err;\r\n}\r\nstatic void macvtap_exit(void)\r\n{\r\nrtnl_link_unregister(&macvtap_link_ops);\r\nunregister_netdevice_notifier(&macvtap_notifier_block);\r\nclass_unregister(macvtap_class);\r\ncdev_del(&macvtap_cdev);\r\nunregister_chrdev_region(macvtap_major, MACVTAP_NUM_DEVS);\r\n}
