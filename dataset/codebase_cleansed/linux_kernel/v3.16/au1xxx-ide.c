static inline void auide_insw(unsigned long port, void *addr, u32 count)\r\n{\r\n_auide_hwif *ahwif = &auide_hwif;\r\nchan_tab_t *ctp;\r\nau1x_ddma_desc_t *dp;\r\nif (!au1xxx_dbdma_put_dest(ahwif->rx_chan, virt_to_phys(addr),\r\ncount << 1, DDMA_FLAGS_NOIE)) {\r\nprintk(KERN_ERR "%s failed %d\n", __func__, __LINE__);\r\nreturn;\r\n}\r\nctp = *((chan_tab_t **)ahwif->rx_chan);\r\ndp = ctp->cur_ptr;\r\nwhile (dp->dscr_cmd0 & DSCR_CMD0_V)\r\n;\r\nctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);\r\n}\r\nstatic inline void auide_outsw(unsigned long port, void *addr, u32 count)\r\n{\r\n_auide_hwif *ahwif = &auide_hwif;\r\nchan_tab_t *ctp;\r\nau1x_ddma_desc_t *dp;\r\nif (!au1xxx_dbdma_put_source(ahwif->tx_chan, virt_to_phys(addr),\r\ncount << 1, DDMA_FLAGS_NOIE)) {\r\nprintk(KERN_ERR "%s failed %d\n", __func__, __LINE__);\r\nreturn;\r\n}\r\nctp = *((chan_tab_t **)ahwif->tx_chan);\r\ndp = ctp->cur_ptr;\r\nwhile (dp->dscr_cmd0 & DSCR_CMD0_V)\r\n;\r\nctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);\r\n}\r\nstatic void au1xxx_input_data(ide_drive_t *drive, struct ide_cmd *cmd,\r\nvoid *buf, unsigned int len)\r\n{\r\nauide_insw(drive->hwif->io_ports.data_addr, buf, (len + 1) / 2);\r\n}\r\nstatic void au1xxx_output_data(ide_drive_t *drive, struct ide_cmd *cmd,\r\nvoid *buf, unsigned int len)\r\n{\r\nauide_outsw(drive->hwif->io_ports.data_addr, buf, (len + 1) / 2);\r\n}\r\nstatic void au1xxx_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nint mem_sttime = 0, mem_stcfg = au_readl(MEM_STCFG2);\r\nswitch (drive->pio_mode - XFER_PIO_0) {\r\ncase 0:\r\nmem_sttime = SBC_IDE_TIMING(PIO0);\r\nmem_stcfg |= TS_MASK;\r\nmem_stcfg &= ~TCSOE_MASK;\r\nmem_stcfg &= ~TOECS_MASK;\r\nmem_stcfg |= SBC_IDE_PIO0_TCSOE | SBC_IDE_PIO0_TOECS;\r\nbreak;\r\ncase 1:\r\nmem_sttime = SBC_IDE_TIMING(PIO1);\r\nmem_stcfg |= TS_MASK;\r\nmem_stcfg &= ~TCSOE_MASK;\r\nmem_stcfg &= ~TOECS_MASK;\r\nmem_stcfg |= SBC_IDE_PIO1_TCSOE | SBC_IDE_PIO1_TOECS;\r\nbreak;\r\ncase 2:\r\nmem_sttime = SBC_IDE_TIMING(PIO2);\r\nmem_stcfg &= ~TS_MASK;\r\nmem_stcfg &= ~TCSOE_MASK;\r\nmem_stcfg &= ~TOECS_MASK;\r\nmem_stcfg |= SBC_IDE_PIO2_TCSOE | SBC_IDE_PIO2_TOECS;\r\nbreak;\r\ncase 3:\r\nmem_sttime = SBC_IDE_TIMING(PIO3);\r\nmem_stcfg &= ~TS_MASK;\r\nmem_stcfg &= ~TCSOE_MASK;\r\nmem_stcfg &= ~TOECS_MASK;\r\nmem_stcfg |= SBC_IDE_PIO3_TCSOE | SBC_IDE_PIO3_TOECS;\r\nbreak;\r\ncase 4:\r\nmem_sttime = SBC_IDE_TIMING(PIO4);\r\nmem_stcfg &= ~TS_MASK;\r\nmem_stcfg &= ~TCSOE_MASK;\r\nmem_stcfg &= ~TOECS_MASK;\r\nmem_stcfg |= SBC_IDE_PIO4_TCSOE | SBC_IDE_PIO4_TOECS;\r\nbreak;\r\n}\r\nau_writel(mem_sttime,MEM_STTIME2);\r\nau_writel(mem_stcfg,MEM_STCFG2);\r\n}\r\nstatic void auide_set_dma_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nint mem_sttime = 0, mem_stcfg = au_readl(MEM_STCFG2);\r\nswitch (drive->dma_mode) {\r\n#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA\r\ncase XFER_MW_DMA_2:\r\nmem_sttime = SBC_IDE_TIMING(MDMA2);\r\nmem_stcfg &= ~TS_MASK;\r\nmem_stcfg &= ~TCSOE_MASK;\r\nmem_stcfg &= ~TOECS_MASK;\r\nmem_stcfg |= SBC_IDE_MDMA2_TCSOE | SBC_IDE_MDMA2_TOECS;\r\nbreak;\r\ncase XFER_MW_DMA_1:\r\nmem_sttime = SBC_IDE_TIMING(MDMA1);\r\nmem_stcfg &= ~TS_MASK;\r\nmem_stcfg &= ~TCSOE_MASK;\r\nmem_stcfg &= ~TOECS_MASK;\r\nmem_stcfg |= SBC_IDE_MDMA1_TCSOE | SBC_IDE_MDMA1_TOECS;\r\nbreak;\r\ncase XFER_MW_DMA_0:\r\nmem_sttime = SBC_IDE_TIMING(MDMA0);\r\nmem_stcfg |= TS_MASK;\r\nmem_stcfg &= ~TCSOE_MASK;\r\nmem_stcfg &= ~TOECS_MASK;\r\nmem_stcfg |= SBC_IDE_MDMA0_TCSOE | SBC_IDE_MDMA0_TOECS;\r\nbreak;\r\n#endif\r\n}\r\nau_writel(mem_sttime,MEM_STTIME2);\r\nau_writel(mem_stcfg,MEM_STCFG2);\r\n}\r\nstatic int auide_build_dmatable(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\n_auide_hwif *ahwif = &auide_hwif;\r\nstruct scatterlist *sg;\r\nint i = cmd->sg_nents, count = 0;\r\nint iswrite = !!(cmd->tf_flags & IDE_TFLAG_WRITE);\r\nahwif->drive = drive;\r\nsg = hwif->sg_table;\r\nwhile (i && sg_dma_len(sg)) {\r\nu32 cur_addr;\r\nu32 cur_len;\r\ncur_addr = sg_dma_address(sg);\r\ncur_len = sg_dma_len(sg);\r\nwhile (cur_len) {\r\nu32 flags = DDMA_FLAGS_NOIE;\r\nunsigned int tc = (cur_len < 0xfe00)? cur_len: 0xfe00;\r\nif (++count >= PRD_ENTRIES) {\r\nprintk(KERN_WARNING "%s: DMA table too small\n",\r\ndrive->name);\r\nreturn 0;\r\n}\r\nif (1==i)\r\nflags = DDMA_FLAGS_IE;\r\nelse\r\nflags = DDMA_FLAGS_NOIE;\r\nif (iswrite) {\r\nif (!au1xxx_dbdma_put_source(ahwif->tx_chan,\r\nsg_phys(sg), tc, flags)) {\r\nprintk(KERN_ERR "%s failed %d\n",\r\n__func__, __LINE__);\r\n}\r\n} else {\r\nif (!au1xxx_dbdma_put_dest(ahwif->rx_chan,\r\nsg_phys(sg), tc, flags)) {\r\nprintk(KERN_ERR "%s failed %d\n",\r\n__func__, __LINE__);\r\n}\r\n}\r\ncur_addr += tc;\r\ncur_len -= tc;\r\n}\r\nsg = sg_next(sg);\r\ni--;\r\n}\r\nif (count)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int auide_dma_end(ide_drive_t *drive)\r\n{\r\nreturn 0;\r\n}\r\nstatic void auide_dma_start(ide_drive_t *drive )\r\n{\r\n}\r\nstatic int auide_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nif (auide_build_dmatable(drive, cmd) == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int auide_dma_test_irq(ide_drive_t *drive)\r\n{\r\ndrive->waiting_for_dma++;\r\nif (drive->waiting_for_dma >= DMA_WAIT_TIMEOUT) {\r\nprintk(KERN_WARNING "%s: timeout waiting for ddma to complete\n",\r\ndrive->name);\r\nreturn 1;\r\n}\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic void auide_dma_host_set(ide_drive_t *drive, int on)\r\n{\r\n}\r\nstatic void auide_ddma_tx_callback(int irq, void *param)\r\n{\r\n}\r\nstatic void auide_ddma_rx_callback(int irq, void *param)\r\n{\r\n}\r\nstatic void auide_init_dbdma_dev(dbdev_tab_t *dev, u32 dev_id, u32 tsize,\r\nu32 devwidth, u32 flags, u32 regbase)\r\n{\r\ndev->dev_id = dev_id;\r\ndev->dev_physaddr = CPHYSADDR(regbase);\r\ndev->dev_intlevel = 0;\r\ndev->dev_intpolarity = 0;\r\ndev->dev_tsize = tsize;\r\ndev->dev_devwidth = devwidth;\r\ndev->dev_flags = flags;\r\n}\r\nstatic int auide_ddma_init(ide_hwif_t *hwif, const struct ide_port_info *d)\r\n{\r\n_auide_hwif *auide = &auide_hwif;\r\ndbdev_tab_t source_dev_tab, target_dev_tab;\r\nu32 dev_id, tsize, devwidth, flags;\r\ndev_id = hwif->ddma_id;\r\ntsize = 8;\r\ndevwidth = 32;\r\n#ifdef IDE_AU1XXX_BURSTMODE\r\nflags = DEV_FLAGS_SYNC | DEV_FLAGS_BURSTABLE;\r\n#else\r\nflags = DEV_FLAGS_SYNC;\r\n#endif\r\nauide_init_dbdma_dev(&source_dev_tab, dev_id, tsize, devwidth,\r\nDEV_FLAGS_OUT | flags, auide->regbase);\r\nauide->tx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );\r\nauide_init_dbdma_dev(&source_dev_tab, dev_id, tsize, devwidth,\r\nDEV_FLAGS_IN | flags, auide->regbase);\r\nauide->rx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );\r\nauide_init_dbdma_dev(&target_dev_tab, (u32)DSCR_CMD0_ALWAYS, tsize,\r\ndevwidth, DEV_FLAGS_ANYUSE, auide->regbase);\r\nauide->target_dev_id = au1xxx_ddma_add_device(&target_dev_tab);\r\nauide->tx_chan = au1xxx_dbdma_chan_alloc(auide->target_dev_id,\r\nauide->tx_dev_id,\r\nauide_ddma_tx_callback,\r\n(void*)auide);\r\nauide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,\r\nauide->target_dev_id,\r\nauide_ddma_rx_callback,\r\n(void*)auide);\r\nauide->tx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->tx_chan,\r\nNUM_DESCRIPTORS);\r\nauide->rx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->rx_chan,\r\nNUM_DESCRIPTORS);\r\n(void)ide_allocate_dma_engine(hwif);\r\nau1xxx_dbdma_start( auide->tx_chan );\r\nau1xxx_dbdma_start( auide->rx_chan );\r\nreturn 0;\r\n}\r\nstatic int auide_ddma_init(ide_hwif_t *hwif, const struct ide_port_info *d)\r\n{\r\n_auide_hwif *auide = &auide_hwif;\r\ndbdev_tab_t source_dev_tab;\r\nint flags;\r\n#ifdef IDE_AU1XXX_BURSTMODE\r\nflags = DEV_FLAGS_SYNC | DEV_FLAGS_BURSTABLE;\r\n#else\r\nflags = DEV_FLAGS_SYNC;\r\n#endif\r\nauide_init_dbdma_dev(&source_dev_tab, (u32)DSCR_CMD0_ALWAYS, 8, 32,\r\nDEV_FLAGS_OUT | flags, auide->regbase);\r\nauide->tx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );\r\nauide_init_dbdma_dev(&source_dev_tab, (u32)DSCR_CMD0_ALWAYS, 8, 32,\r\nDEV_FLAGS_IN | flags, auide->regbase);\r\nauide->rx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );\r\nauide->tx_chan = au1xxx_dbdma_chan_alloc(DSCR_CMD0_ALWAYS,\r\nauide->tx_dev_id,\r\nNULL,\r\n(void*)auide);\r\nauide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,\r\nDSCR_CMD0_ALWAYS,\r\nNULL,\r\n(void*)auide);\r\nauide->tx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->tx_chan,\r\nNUM_DESCRIPTORS);\r\nauide->rx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->rx_chan,\r\nNUM_DESCRIPTORS);\r\nau1xxx_dbdma_start( auide->tx_chan );\r\nau1xxx_dbdma_start( auide->rx_chan );\r\nreturn 0;\r\n}\r\nstatic void auide_setup_ports(struct ide_hw *hw, _auide_hwif *ahwif)\r\n{\r\nint i;\r\nunsigned long *ata_regs = hw->io_ports_array;\r\nfor (i = 0; i < 8; i++)\r\n*ata_regs++ = ahwif->regbase + (i << IDE_REG_SHIFT);\r\n*ata_regs = ahwif->regbase + (14 << IDE_REG_SHIFT);\r\n}\r\nstatic int au_ide_probe(struct platform_device *dev)\r\n{\r\n_auide_hwif *ahwif = &auide_hwif;\r\nstruct resource *res;\r\nstruct ide_host *host;\r\nint ret = 0;\r\nstruct ide_hw hw, *hws[] = { &hw };\r\n#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)\r\nchar *mode = "MWDMA2";\r\n#elif defined(CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA)\r\nchar *mode = "PIO+DDMA(offload)";\r\n#endif\r\nmemset(&auide_hwif, 0, sizeof(_auide_hwif));\r\nahwif->irq = platform_get_irq(dev, 0);\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\npr_debug("%s %d: no base address\n", DRV_NAME, dev->id);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (ahwif->irq < 0) {\r\npr_debug("%s %d: no IRQ\n", DRV_NAME, dev->id);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res), dev->name)) {\r\npr_debug("%s: request_mem_region failed\n", DRV_NAME);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nahwif->regbase = (u32)ioremap(res->start, resource_size(res));\r\nif (ahwif->regbase == 0) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nres = platform_get_resource(dev, IORESOURCE_DMA, 0);\r\nif (!res) {\r\npr_debug("%s: no DDMA ID resource\n", DRV_NAME);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nahwif->ddma_id = res->start;\r\nmemset(&hw, 0, sizeof(hw));\r\nauide_setup_ports(&hw, ahwif);\r\nhw.irq = ahwif->irq;\r\nhw.dev = &dev->dev;\r\nret = ide_host_add(&au1xxx_port_info, hws, 1, &host);\r\nif (ret)\r\ngoto out;\r\nauide_hwif.hwif = host->ports[0];\r\nplatform_set_drvdata(dev, host);\r\nprintk(KERN_INFO "Au1xxx IDE(builtin) configured for %s\n", mode );\r\nout:\r\nreturn ret;\r\n}\r\nstatic int au_ide_remove(struct platform_device *dev)\r\n{\r\nstruct resource *res;\r\nstruct ide_host *host = platform_get_drvdata(dev);\r\n_auide_hwif *ahwif = &auide_hwif;\r\nide_host_remove(host);\r\niounmap((void *)ahwif->regbase);\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn 0;\r\n}\r\nstatic int __init au_ide_init(void)\r\n{\r\nreturn platform_driver_register(&au1200_ide_driver);\r\n}\r\nstatic void __exit au_ide_exit(void)\r\n{\r\nplatform_driver_unregister(&au1200_ide_driver);\r\n}
