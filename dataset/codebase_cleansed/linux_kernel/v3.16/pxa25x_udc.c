static void pullup_off(void)\r\n{\r\nstruct pxa2xx_udc_mach_info *mach = the_controller->mach;\r\nint off_level = mach->gpio_pullup_inverted;\r\nif (gpio_is_valid(mach->gpio_pullup))\r\ngpio_set_value(mach->gpio_pullup, off_level);\r\nelse if (mach->udc_command)\r\nmach->udc_command(PXA2XX_UDC_CMD_DISCONNECT);\r\n}\r\nstatic void pullup_on(void)\r\n{\r\nstruct pxa2xx_udc_mach_info *mach = the_controller->mach;\r\nint on_level = !mach->gpio_pullup_inverted;\r\nif (gpio_is_valid(mach->gpio_pullup))\r\ngpio_set_value(mach->gpio_pullup, on_level);\r\nelse if (mach->udc_command)\r\nmach->udc_command(PXA2XX_UDC_CMD_CONNECT);\r\n}\r\nstatic void pio_irq_enable(int bEndpointAddress)\r\n{\r\nbEndpointAddress &= 0xf;\r\nif (bEndpointAddress < 8)\r\nUICR0 &= ~(1 << bEndpointAddress);\r\nelse {\r\nbEndpointAddress -= 8;\r\nUICR1 &= ~(1 << bEndpointAddress);\r\n}\r\n}\r\nstatic void pio_irq_disable(int bEndpointAddress)\r\n{\r\nbEndpointAddress &= 0xf;\r\nif (bEndpointAddress < 8)\r\nUICR0 |= 1 << bEndpointAddress;\r\nelse {\r\nbEndpointAddress -= 8;\r\nUICR1 |= 1 << bEndpointAddress;\r\n}\r\n}\r\nstatic inline void udc_set_mask_UDCCR(int mask)\r\n{\r\nUDCCR = (UDCCR & UDCCR_MASK_BITS) | (mask & UDCCR_MASK_BITS);\r\n}\r\nstatic inline void udc_clear_mask_UDCCR(int mask)\r\n{\r\nUDCCR = (UDCCR & UDCCR_MASK_BITS) & ~(mask & UDCCR_MASK_BITS);\r\n}\r\nstatic inline void udc_ack_int_UDCCR(int mask)\r\n{\r\n__u32 udccr = UDCCR & UDCCR_MASK_BITS;\r\nUDCCR = udccr | (mask & ~UDCCR_MASK_BITS);\r\n}\r\nstatic int pxa25x_ep_enable (struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct pxa25x_ep *ep;\r\nstruct pxa25x_udc *dev;\r\nep = container_of (_ep, struct pxa25x_ep, ep);\r\nif (!_ep || !desc || _ep->name == ep0name\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT\r\n|| ep->bEndpointAddress != desc->bEndpointAddress\r\n|| ep->fifo_size < usb_endpoint_maxp (desc)) {\r\nDMSG("%s, bad ep or descriptor\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (ep->bmAttributes != desc->bmAttributes\r\n&& ep->bmAttributes != USB_ENDPOINT_XFER_BULK\r\n&& desc->bmAttributes != USB_ENDPOINT_XFER_INT) {\r\nDMSG("%s, %s type mismatch\n", __func__, _ep->name);\r\nreturn -EINVAL;\r\n}\r\nif ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK\r\n&& usb_endpoint_maxp (desc)\r\n!= BULK_FIFO_SIZE)\r\n|| !desc->wMaxPacketSize) {\r\nDMSG("%s, bad %s maxpacket\n", __func__, _ep->name);\r\nreturn -ERANGE;\r\n}\r\ndev = ep->dev;\r\nif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {\r\nDMSG("%s, bogus device state\n", __func__);\r\nreturn -ESHUTDOWN;\r\n}\r\nep->ep.desc = desc;\r\nep->stopped = 0;\r\nep->pio_irqs = 0;\r\nep->ep.maxpacket = usb_endpoint_maxp (desc);\r\npxa25x_ep_fifo_flush (_ep);\r\nDBG(DBG_VERBOSE, "enabled %s\n", _ep->name);\r\nreturn 0;\r\n}\r\nstatic int pxa25x_ep_disable (struct usb_ep *_ep)\r\n{\r\nstruct pxa25x_ep *ep;\r\nunsigned long flags;\r\nep = container_of (_ep, struct pxa25x_ep, ep);\r\nif (!_ep || !ep->ep.desc) {\r\nDMSG("%s, %s not enabled\n", __func__,\r\n_ep ? ep->ep.name : NULL);\r\nreturn -EINVAL;\r\n}\r\nlocal_irq_save(flags);\r\nnuke (ep, -ESHUTDOWN);\r\npxa25x_ep_fifo_flush (_ep);\r\nep->ep.desc = NULL;\r\nep->stopped = 1;\r\nlocal_irq_restore(flags);\r\nDBG(DBG_VERBOSE, "%s disabled\n", _ep->name);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *\r\npxa25x_ep_alloc_request (struct usb_ep *_ep, gfp_t gfp_flags)\r\n{\r\nstruct pxa25x_request *req;\r\nreq = kzalloc(sizeof(*req), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD (&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void\r\npxa25x_ep_free_request (struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct pxa25x_request *req;\r\nreq = container_of (_req, struct pxa25x_request, req);\r\nWARN_ON(!list_empty (&req->queue));\r\nkfree(req);\r\n}\r\nstatic void done(struct pxa25x_ep *ep, struct pxa25x_request *req, int status)\r\n{\r\nunsigned stopped = ep->stopped;\r\nlist_del_init(&req->queue);\r\nif (likely (req->req.status == -EINPROGRESS))\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\nif (status && status != -ESHUTDOWN)\r\nDBG(DBG_VERBOSE, "complete %s req %p stat %d len %u/%u\n",\r\nep->ep.name, &req->req, status,\r\nreq->req.actual, req->req.length);\r\nep->stopped = 1;\r\nreq->req.complete(&ep->ep, &req->req);\r\nep->stopped = stopped;\r\n}\r\nstatic inline void ep0_idle (struct pxa25x_udc *dev)\r\n{\r\ndev->ep0state = EP0_IDLE;\r\n}\r\nstatic int\r\nwrite_packet(volatile u32 *uddr, struct pxa25x_request *req, unsigned max)\r\n{\r\nu8 *buf;\r\nunsigned length, count;\r\nbuf = req->req.buf + req->req.actual;\r\nprefetch(buf);\r\nlength = min(req->req.length - req->req.actual, max);\r\nreq->req.actual += length;\r\ncount = length;\r\nwhile (likely(count--))\r\n*uddr = *buf++;\r\nreturn length;\r\n}\r\nstatic int\r\nwrite_fifo (struct pxa25x_ep *ep, struct pxa25x_request *req)\r\n{\r\nunsigned max;\r\nmax = usb_endpoint_maxp(ep->ep.desc);\r\ndo {\r\nunsigned count;\r\nint is_last, is_short;\r\ncount = write_packet(ep->reg_uddr, req, max);\r\nif (unlikely (count != max))\r\nis_last = is_short = 1;\r\nelse {\r\nif (likely(req->req.length != req->req.actual)\r\n|| req->req.zero)\r\nis_last = 0;\r\nelse\r\nis_last = 1;\r\nis_short = unlikely (max < ep->fifo_size);\r\n}\r\nDBG(DBG_VERY_NOISY, "wrote %s %d bytes%s%s %d left %p\n",\r\nep->ep.name, count,\r\nis_last ? "/L" : "", is_short ? "/S" : "",\r\nreq->req.length - req->req.actual, req);\r\n*ep->reg_udccs = UDCCS_BI_TPC;\r\nif (is_short)\r\n*ep->reg_udccs = UDCCS_BI_TSP;\r\nif (is_last) {\r\ndone (ep, req, 0);\r\nif (list_empty(&ep->queue))\r\npio_irq_disable (ep->bEndpointAddress);\r\nreturn 1;\r\n}\r\n} while (*ep->reg_udccs & UDCCS_BI_TFS);\r\nreturn 0;\r\n}\r\nstatic inline\r\nvoid ep0start(struct pxa25x_udc *dev, u32 flags, const char *tag)\r\n{\r\nUDCCS0 = flags|UDCCS0_SA|UDCCS0_OPR;\r\nUSIR0 = USIR0_IR0;\r\ndev->req_pending = 0;\r\nDBG(DBG_VERY_NOISY, "%s %s, %02x/%02x\n",\r\n__func__, tag, UDCCS0, flags);\r\n}\r\nstatic int\r\nwrite_ep0_fifo (struct pxa25x_ep *ep, struct pxa25x_request *req)\r\n{\r\nunsigned count;\r\nint is_short;\r\ncount = write_packet(&UDDR0, req, EP0_FIFO_SIZE);\r\nep->dev->stats.write.bytes += count;\r\nis_short = (count != EP0_FIFO_SIZE);\r\nDBG(DBG_VERY_NOISY, "ep0in %d bytes %d left %p\n", count,\r\nreq->req.length - req->req.actual, req);\r\nif (unlikely (is_short)) {\r\nif (ep->dev->req_pending)\r\nep0start(ep->dev, UDCCS0_IPR, "short IN");\r\nelse\r\nUDCCS0 = UDCCS0_IPR;\r\ncount = req->req.length;\r\ndone (ep, req, 0);\r\nep0_idle(ep->dev);\r\n#ifndef CONFIG_ARCH_IXP4XX\r\n#if 1\r\nif (count >= EP0_FIFO_SIZE) {\r\ncount = 100;\r\ndo {\r\nif ((UDCCS0 & UDCCS0_OPR) != 0) {\r\nUDCCS0 = UDCCS0_OPR;\r\nbreak;\r\n}\r\ncount--;\r\nudelay(1);\r\n} while (count);\r\n}\r\n#endif\r\n#endif\r\n} else if (ep->dev->req_pending)\r\nep0start(ep->dev, 0, "IN");\r\nreturn is_short;\r\n}\r\nstatic int\r\nread_fifo (struct pxa25x_ep *ep, struct pxa25x_request *req)\r\n{\r\nfor (;;) {\r\nu32 udccs;\r\nu8 *buf;\r\nunsigned bufferspace, count, is_short;\r\nudccs = *ep->reg_udccs;\r\nif (unlikely ((udccs & UDCCS_BO_RPC) == 0))\r\nbreak;\r\nbuf = req->req.buf + req->req.actual;\r\nprefetchw(buf);\r\nbufferspace = req->req.length - req->req.actual;\r\nif (likely (udccs & UDCCS_BO_RNE)) {\r\ncount = 1 + (0x0ff & *ep->reg_ubcr);\r\nreq->req.actual += min (count, bufferspace);\r\n} else\r\ncount = 0;\r\nis_short = (count < ep->ep.maxpacket);\r\nDBG(DBG_VERY_NOISY, "read %s %02x, %d bytes%s req %p %d/%d\n",\r\nep->ep.name, udccs, count,\r\nis_short ? "/S" : "",\r\nreq, req->req.actual, req->req.length);\r\nwhile (likely (count-- != 0)) {\r\nu8 byte = (u8) *ep->reg_uddr;\r\nif (unlikely (bufferspace == 0)) {\r\nif (req->req.status != -EOVERFLOW)\r\nDMSG("%s overflow %d\n",\r\nep->ep.name, count);\r\nreq->req.status = -EOVERFLOW;\r\n} else {\r\n*buf++ = byte;\r\nbufferspace--;\r\n}\r\n}\r\n*ep->reg_udccs = UDCCS_BO_RPC;\r\nif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\r\nif (udccs & UDCCS_IO_ROF)\r\nreq->req.status = -EHOSTUNREACH;\r\nis_short = 1;\r\n}\r\nif (is_short || req->req.actual == req->req.length) {\r\ndone (ep, req, 0);\r\nif (list_empty(&ep->queue))\r\npio_irq_disable (ep->bEndpointAddress);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nread_ep0_fifo (struct pxa25x_ep *ep, struct pxa25x_request *req)\r\n{\r\nu8 *buf, byte;\r\nunsigned bufferspace;\r\nbuf = req->req.buf + req->req.actual;\r\nbufferspace = req->req.length - req->req.actual;\r\nwhile (UDCCS0 & UDCCS0_RNE) {\r\nbyte = (u8) UDDR0;\r\nif (unlikely (bufferspace == 0)) {\r\nif (req->req.status != -EOVERFLOW)\r\nDMSG("%s overflow\n", ep->ep.name);\r\nreq->req.status = -EOVERFLOW;\r\n} else {\r\n*buf++ = byte;\r\nreq->req.actual++;\r\nbufferspace--;\r\n}\r\n}\r\nUDCCS0 = UDCCS0_OPR | UDCCS0_IPR;\r\nif (req->req.actual >= req->req.length)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int\r\npxa25x_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\r\n{\r\nstruct pxa25x_request *req;\r\nstruct pxa25x_ep *ep;\r\nstruct pxa25x_udc *dev;\r\nunsigned long flags;\r\nreq = container_of(_req, struct pxa25x_request, req);\r\nif (unlikely (!_req || !_req->complete || !_req->buf\r\n|| !list_empty(&req->queue))) {\r\nDMSG("%s, bad params\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nep = container_of(_ep, struct pxa25x_ep, ep);\r\nif (unlikely(!_ep || (!ep->ep.desc && ep->ep.name != ep0name))) {\r\nDMSG("%s, bad ep\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndev = ep->dev;\r\nif (unlikely (!dev->driver\r\n|| dev->gadget.speed == USB_SPEED_UNKNOWN)) {\r\nDMSG("%s, bogus device state\n", __func__);\r\nreturn -ESHUTDOWN;\r\n}\r\nif (unlikely (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC\r\n&& req->req.length > usb_endpoint_maxp(ep->ep.desc)))\r\nreturn -EMSGSIZE;\r\nDBG(DBG_NOISY, "%s queue req %p, len %d buf %p\n",\r\n_ep->name, _req, _req->length, _req->buf);\r\nlocal_irq_save(flags);\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nif (list_empty(&ep->queue) && !ep->stopped) {\r\nif (ep->ep.desc == NULL) {\r\nunsigned length = _req->length;\r\nswitch (dev->ep0state) {\r\ncase EP0_IN_DATA_PHASE:\r\ndev->stats.write.ops++;\r\nif (write_ep0_fifo(ep, req))\r\nreq = NULL;\r\nbreak;\r\ncase EP0_OUT_DATA_PHASE:\r\ndev->stats.read.ops++;\r\nif (dev->req_config) {\r\nDBG(DBG_VERBOSE, "ep0 config ack%s\n",\r\ndev->has_cfr ? "" : " raced");\r\nif (dev->has_cfr)\r\nUDCCFR = UDCCFR_AREN|UDCCFR_ACM\r\n|UDCCFR_MB1;\r\ndone(ep, req, 0);\r\ndev->ep0state = EP0_END_XFER;\r\nlocal_irq_restore (flags);\r\nreturn 0;\r\n}\r\nif (dev->req_pending)\r\nep0start(dev, UDCCS0_IPR, "OUT");\r\nif (length == 0 || ((UDCCS0 & UDCCS0_RNE) != 0\r\n&& read_ep0_fifo(ep, req))) {\r\nep0_idle(dev);\r\ndone(ep, req, 0);\r\nreq = NULL;\r\n}\r\nbreak;\r\ndefault:\r\nDMSG("ep0 i/o, odd state %d\n", dev->ep0state);\r\nlocal_irq_restore (flags);\r\nreturn -EL2HLT;\r\n}\r\n} else if ((ep->bEndpointAddress & USB_DIR_IN) != 0) {\r\nif ((*ep->reg_udccs & UDCCS_BI_TFS) != 0\r\n&& write_fifo(ep, req))\r\nreq = NULL;\r\n} else if ((*ep->reg_udccs & UDCCS_BO_RFS) != 0\r\n&& read_fifo(ep, req)) {\r\nreq = NULL;\r\n}\r\nif (likely(req && ep->ep.desc))\r\npio_irq_enable(ep->bEndpointAddress);\r\n}\r\nif (likely(req != NULL))\r\nlist_add_tail(&req->queue, &ep->queue);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void nuke(struct pxa25x_ep *ep, int status)\r\n{\r\nstruct pxa25x_request *req;\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct pxa25x_request,\r\nqueue);\r\ndone(ep, req, status);\r\n}\r\nif (ep->ep.desc)\r\npio_irq_disable (ep->bEndpointAddress);\r\n}\r\nstatic int pxa25x_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct pxa25x_ep *ep;\r\nstruct pxa25x_request *req;\r\nunsigned long flags;\r\nep = container_of(_ep, struct pxa25x_ep, ep);\r\nif (!_ep || ep->ep.name == ep0name)\r\nreturn -EINVAL;\r\nlocal_irq_save(flags);\r\nlist_for_each_entry (req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nlocal_irq_restore(flags);\r\nreturn -EINVAL;\r\n}\r\ndone(ep, req, -ECONNRESET);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int pxa25x_ep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct pxa25x_ep *ep;\r\nunsigned long flags;\r\nep = container_of(_ep, struct pxa25x_ep, ep);\r\nif (unlikely (!_ep\r\n|| (!ep->ep.desc && ep->ep.name != ep0name))\r\n|| ep->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\r\nDMSG("%s, bad ep\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (value == 0) {\r\nDMSG("only host can clear %s halt\n", _ep->name);\r\nreturn -EROFS;\r\n}\r\nlocal_irq_save(flags);\r\nif ((ep->bEndpointAddress & USB_DIR_IN) != 0\r\n&& ((*ep->reg_udccs & UDCCS_BI_TFS) == 0\r\n|| !list_empty(&ep->queue))) {\r\nlocal_irq_restore(flags);\r\nreturn -EAGAIN;\r\n}\r\n*ep->reg_udccs = UDCCS_BI_FST|UDCCS_BI_FTF;\r\nif (!ep->ep.desc) {\r\nstart_watchdog(ep->dev);\r\nep->dev->req_pending = 0;\r\nep->dev->ep0state = EP0_STALL;\r\n} else {\r\nunsigned i;\r\nfor (i = 0; i < 1000; i += 20) {\r\nif (*ep->reg_udccs & UDCCS_BI_SST)\r\nbreak;\r\nudelay(20);\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\nDBG(DBG_VERBOSE, "%s halt\n", _ep->name);\r\nreturn 0;\r\n}\r\nstatic int pxa25x_ep_fifo_status(struct usb_ep *_ep)\r\n{\r\nstruct pxa25x_ep *ep;\r\nep = container_of(_ep, struct pxa25x_ep, ep);\r\nif (!_ep) {\r\nDMSG("%s, bad ep\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif ((ep->bEndpointAddress & USB_DIR_IN) != 0)\r\nreturn -EOPNOTSUPP;\r\nif (ep->dev->gadget.speed == USB_SPEED_UNKNOWN\r\n|| (*ep->reg_udccs & UDCCS_BO_RFS) == 0)\r\nreturn 0;\r\nelse\r\nreturn (*ep->reg_ubcr & 0xfff) + 1;\r\n}\r\nstatic void pxa25x_ep_fifo_flush(struct usb_ep *_ep)\r\n{\r\nstruct pxa25x_ep *ep;\r\nep = container_of(_ep, struct pxa25x_ep, ep);\r\nif (!_ep || ep->ep.name == ep0name || !list_empty(&ep->queue)) {\r\nDMSG("%s, bad ep\n", __func__);\r\nreturn;\r\n}\r\nif ((ep->bEndpointAddress & USB_DIR_IN) == 0) {\r\nwhile (((*ep->reg_udccs) & UDCCS_BO_RNE) != 0)\r\n(void) *ep->reg_uddr;\r\nreturn;\r\n}\r\n*ep->reg_udccs = UDCCS_BI_TPC|UDCCS_BI_FTF|UDCCS_BI_TUR\r\n| (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC\r\n? 0 : UDCCS_BI_SST);\r\n}\r\nstatic int pxa25x_udc_get_frame(struct usb_gadget *_gadget)\r\n{\r\nreturn ((UFNRH & 0x07) << 8) | (UFNRL & 0xff);\r\n}\r\nstatic int pxa25x_udc_wakeup(struct usb_gadget *_gadget)\r\n{\r\nif ((UDCCS0 & UDCCS0_DRWF) == 0)\r\nreturn -EHOSTUNREACH;\r\nudc_set_mask_UDCCR(UDCCR_RSM);\r\nreturn 0;\r\n}\r\nstatic int pullup(struct pxa25x_udc *udc)\r\n{\r\nint is_active = udc->vbus && udc->pullup && !udc->suspended;\r\nDMSG("%s\n", is_active ? "active" : "inactive");\r\nif (is_active) {\r\nif (!udc->active) {\r\nudc->active = 1;\r\nclk_enable(udc->clk);\r\nudc_enable(udc);\r\n}\r\n} else {\r\nif (udc->active) {\r\nif (udc->gadget.speed != USB_SPEED_UNKNOWN) {\r\nDMSG("disconnect %s\n", udc->driver\r\n? udc->driver->driver.name\r\n: "(no driver)");\r\nstop_activity(udc, udc->driver);\r\n}\r\nudc_disable(udc);\r\nclk_disable(udc->clk);\r\nudc->active = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa25x_udc_vbus_session(struct usb_gadget *_gadget, int is_active)\r\n{\r\nstruct pxa25x_udc *udc;\r\nudc = container_of(_gadget, struct pxa25x_udc, gadget);\r\nudc->vbus = is_active;\r\nDMSG("vbus %s\n", is_active ? "supplied" : "inactive");\r\npullup(udc);\r\nreturn 0;\r\n}\r\nstatic int pxa25x_udc_pullup(struct usb_gadget *_gadget, int is_active)\r\n{\r\nstruct pxa25x_udc *udc;\r\nudc = container_of(_gadget, struct pxa25x_udc, gadget);\r\nif (!gpio_is_valid(udc->mach->gpio_pullup) && !udc->mach->udc_command)\r\nreturn -EOPNOTSUPP;\r\nudc->pullup = (is_active != 0);\r\npullup(udc);\r\nreturn 0;\r\n}\r\nstatic int pxa25x_udc_vbus_draw(struct usb_gadget *_gadget, unsigned mA)\r\n{\r\nstruct pxa25x_udc *udc;\r\nudc = container_of(_gadget, struct pxa25x_udc, gadget);\r\nif (!IS_ERR_OR_NULL(udc->transceiver))\r\nreturn usb_phy_set_power(udc->transceiver, mA);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nudc_seq_show(struct seq_file *m, void *_d)\r\n{\r\nstruct pxa25x_udc *dev = m->private;\r\nunsigned long flags;\r\nint i;\r\nu32 tmp;\r\nlocal_irq_save(flags);\r\nseq_printf(m, DRIVER_DESC "\n"\r\n"%s version: %s\nGadget driver: %s\nHost %s\n\n",\r\ndriver_name, DRIVER_VERSION SIZE_STR "(pio)",\r\ndev->driver ? dev->driver->driver.name : "(none)",\r\ndev->gadget.speed == USB_SPEED_FULL ? "full speed" : "disconnected");\r\nseq_printf(m,\r\n"uicr %02X.%02X, usir %02X.%02x, ufnr %02X.%02X\n",\r\nUICR1, UICR0, USIR1, USIR0, UFNRH, UFNRL);\r\ntmp = UDCCR;\r\nseq_printf(m,\r\n"udccr %02X =%s%s%s%s%s%s%s%s\n", tmp,\r\n(tmp & UDCCR_REM) ? " rem" : "",\r\n(tmp & UDCCR_RSTIR) ? " rstir" : "",\r\n(tmp & UDCCR_SRM) ? " srm" : "",\r\n(tmp & UDCCR_SUSIR) ? " susir" : "",\r\n(tmp & UDCCR_RESIR) ? " resir" : "",\r\n(tmp & UDCCR_RSM) ? " rsm" : "",\r\n(tmp & UDCCR_UDA) ? " uda" : "",\r\n(tmp & UDCCR_UDE) ? " ude" : "");\r\ntmp = UDCCS0;\r\nseq_printf(m,\r\n"udccs0 %02X =%s%s%s%s%s%s%s%s\n", tmp,\r\n(tmp & UDCCS0_SA) ? " sa" : "",\r\n(tmp & UDCCS0_RNE) ? " rne" : "",\r\n(tmp & UDCCS0_FST) ? " fst" : "",\r\n(tmp & UDCCS0_SST) ? " sst" : "",\r\n(tmp & UDCCS0_DRWF) ? " dwrf" : "",\r\n(tmp & UDCCS0_FTF) ? " ftf" : "",\r\n(tmp & UDCCS0_IPR) ? " ipr" : "",\r\n(tmp & UDCCS0_OPR) ? " opr" : "");\r\nif (dev->has_cfr) {\r\ntmp = UDCCFR;\r\nseq_printf(m,\r\n"udccfr %02X =%s%s\n", tmp,\r\n(tmp & UDCCFR_AREN) ? " aren" : "",\r\n(tmp & UDCCFR_ACM) ? " acm" : "");\r\n}\r\nif (dev->gadget.speed != USB_SPEED_FULL || !dev->driver)\r\ngoto done;\r\nseq_printf(m, "ep0 IN %lu/%lu, OUT %lu/%lu\nirqs %lu\n\n",\r\ndev->stats.write.bytes, dev->stats.write.ops,\r\ndev->stats.read.bytes, dev->stats.read.ops,\r\ndev->stats.irqs);\r\nfor (i = 0; i < PXA_UDC_NUM_ENDPOINTS; i++) {\r\nstruct pxa25x_ep *ep = &dev->ep [i];\r\nstruct pxa25x_request *req;\r\nif (i != 0) {\r\nconst struct usb_endpoint_descriptor *desc;\r\ndesc = ep->ep.desc;\r\nif (!desc)\r\ncontinue;\r\ntmp = *dev->ep [i].reg_udccs;\r\nseq_printf(m,\r\n"%s max %d %s udccs %02x irqs %lu\n",\r\nep->ep.name, usb_endpoint_maxp(desc),\r\n"pio", tmp, ep->pio_irqs);\r\n} else\r\nseq_printf(m, "ep0 max 16 pio irqs %lu\n",\r\nep->pio_irqs);\r\nif (list_empty(&ep->queue)) {\r\nseq_printf(m, "\t(nothing queued)\n");\r\ncontinue;\r\n}\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nseq_printf(m,\r\n"\treq %p len %d/%d buf %p\n",\r\n&req->req, req->req.actual,\r\nreq->req.length, req->req.buf);\r\n}\r\n}\r\ndone:\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nudc_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, udc_seq_show, inode->i_private);\r\n}\r\nstatic void udc_disable(struct pxa25x_udc *dev)\r\n{\r\nudc_set_mask_UDCCR(UDCCR_SRM|UDCCR_REM);\r\nUICR0 = UICR1 = 0xff;\r\nUFNRH = UFNRH_SIM;\r\npullup_off();\r\nudc_clear_mask_UDCCR(UDCCR_UDE);\r\nep0_idle (dev);\r\ndev->gadget.speed = USB_SPEED_UNKNOWN;\r\n}\r\nstatic void udc_reinit(struct pxa25x_udc *dev)\r\n{\r\nu32 i;\r\nINIT_LIST_HEAD (&dev->gadget.ep_list);\r\nINIT_LIST_HEAD (&dev->gadget.ep0->ep_list);\r\ndev->ep0state = EP0_IDLE;\r\nfor (i = 0; i < PXA_UDC_NUM_ENDPOINTS; i++) {\r\nstruct pxa25x_ep *ep = &dev->ep[i];\r\nif (i != 0)\r\nlist_add_tail (&ep->ep.ep_list, &dev->gadget.ep_list);\r\nep->ep.desc = NULL;\r\nep->stopped = 0;\r\nINIT_LIST_HEAD (&ep->queue);\r\nep->pio_irqs = 0;\r\nusb_ep_set_maxpacket_limit(&ep->ep, ep->ep.maxpacket);\r\n}\r\n}\r\nstatic void udc_enable (struct pxa25x_udc *dev)\r\n{\r\nudc_clear_mask_UDCCR(UDCCR_UDE);\r\nudc_ack_int_UDCCR(UDCCR_SUSIR|UDCCR_RESIR);\r\nep0_idle(dev);\r\ndev->gadget.speed = USB_SPEED_UNKNOWN;\r\ndev->stats.irqs = 0;\r\nudc_set_mask_UDCCR(UDCCR_UDE);\r\nif (!(UDCCR & UDCCR_UDA))\r\nudc_ack_int_UDCCR(UDCCR_RSTIR);\r\nif (dev->has_cfr ) {\r\nUDCCFR = UDCCFR_ACM | UDCCFR_MB1;\r\n} else {\r\nUDC_RES1 = 0x00;\r\nUDC_RES2 = 0x00;\r\n}\r\nudc_clear_mask_UDCCR(UDCCR_SRM | UDCCR_REM);\r\nUICR0 &= ~UICR0_IM0;\r\npullup_on();\r\n}\r\nstatic int pxa25x_udc_start(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct pxa25x_udc *dev = to_pxa25x(g);\r\nint retval;\r\ndev->driver = driver;\r\ndev->pullup = 1;\r\nif (!IS_ERR_OR_NULL(dev->transceiver)) {\r\nretval = otg_set_peripheral(dev->transceiver->otg,\r\n&dev->gadget);\r\nif (retval)\r\ngoto bind_fail;\r\n}\r\npullup(dev);\r\ndump_state(dev);\r\nreturn 0;\r\nbind_fail:\r\nreturn retval;\r\n}\r\nstatic void\r\nstop_activity(struct pxa25x_udc *dev, struct usb_gadget_driver *driver)\r\n{\r\nint i;\r\nif (dev->gadget.speed == USB_SPEED_UNKNOWN)\r\ndriver = NULL;\r\ndev->gadget.speed = USB_SPEED_UNKNOWN;\r\nfor (i = 0; i < PXA_UDC_NUM_ENDPOINTS; i++) {\r\nstruct pxa25x_ep *ep = &dev->ep[i];\r\nep->stopped = 1;\r\nnuke(ep, -ESHUTDOWN);\r\n}\r\ndel_timer_sync(&dev->timer);\r\nif (driver)\r\ndriver->disconnect(&dev->gadget);\r\nudc_reinit(dev);\r\n}\r\nstatic int pxa25x_udc_stop(struct usb_gadget*g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct pxa25x_udc *dev = to_pxa25x(g);\r\nlocal_irq_disable();\r\ndev->pullup = 0;\r\npullup(dev);\r\nstop_activity(dev, driver);\r\nlocal_irq_enable();\r\nif (!IS_ERR_OR_NULL(dev->transceiver))\r\n(void) otg_set_peripheral(dev->transceiver->otg, NULL);\r\ndev->driver = NULL;\r\ndump_state(dev);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\nlubbock_vbus_irq(int irq, void *_dev)\r\n{\r\nstruct pxa25x_udc *dev = _dev;\r\nint vbus;\r\ndev->stats.irqs++;\r\nswitch (irq) {\r\ncase LUBBOCK_USB_IRQ:\r\nvbus = 1;\r\ndisable_irq(LUBBOCK_USB_IRQ);\r\nenable_irq(LUBBOCK_USB_DISC_IRQ);\r\nbreak;\r\ncase LUBBOCK_USB_DISC_IRQ:\r\nvbus = 0;\r\ndisable_irq(LUBBOCK_USB_DISC_IRQ);\r\nenable_irq(LUBBOCK_USB_IRQ);\r\nbreak;\r\ndefault:\r\nreturn IRQ_NONE;\r\n}\r\npxa25x_udc_vbus_session(&dev->gadget, vbus);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void clear_ep_state (struct pxa25x_udc *dev)\r\n{\r\nunsigned i;\r\nfor (i = 1; i < PXA_UDC_NUM_ENDPOINTS; i++)\r\nnuke(&dev->ep[i], -ECONNABORTED);\r\n}\r\nstatic void udc_watchdog(unsigned long _dev)\r\n{\r\nstruct pxa25x_udc *dev = (void *)_dev;\r\nlocal_irq_disable();\r\nif (dev->ep0state == EP0_STALL\r\n&& (UDCCS0 & UDCCS0_FST) == 0\r\n&& (UDCCS0 & UDCCS0_SST) == 0) {\r\nUDCCS0 = UDCCS0_FST|UDCCS0_FTF;\r\nDBG(DBG_VERBOSE, "ep0 re-stall\n");\r\nstart_watchdog(dev);\r\n}\r\nlocal_irq_enable();\r\n}\r\nstatic void handle_ep0 (struct pxa25x_udc *dev)\r\n{\r\nu32 udccs0 = UDCCS0;\r\nstruct pxa25x_ep *ep = &dev->ep [0];\r\nstruct pxa25x_request *req;\r\nunion {\r\nstruct usb_ctrlrequest r;\r\nu8 raw [8];\r\nu32 word [2];\r\n} u;\r\nif (list_empty(&ep->queue))\r\nreq = NULL;\r\nelse\r\nreq = list_entry(ep->queue.next, struct pxa25x_request, queue);\r\nif (udccs0 & UDCCS0_SST) {\r\nnuke(ep, -EPIPE);\r\nUDCCS0 = UDCCS0_SST;\r\ndel_timer(&dev->timer);\r\nep0_idle(dev);\r\n}\r\nif ((udccs0 & UDCCS0_SA) != 0 && dev->ep0state != EP0_IDLE) {\r\nnuke(ep, 0);\r\ndel_timer(&dev->timer);\r\nep0_idle(dev);\r\n}\r\nswitch (dev->ep0state) {\r\ncase EP0_IDLE:\r\nudccs0 = UDCCS0;\r\nif (likely((udccs0 & (UDCCS0_OPR|UDCCS0_SA|UDCCS0_RNE))\r\n== (UDCCS0_OPR|UDCCS0_SA|UDCCS0_RNE))) {\r\nint i;\r\nnuke (ep, -EPROTO);\r\nfor (i = 0; i < 8; i++) {\r\nif (unlikely(!(UDCCS0 & UDCCS0_RNE))) {\r\nbad_setup:\r\nDMSG("SETUP %d!\n", i);\r\ngoto stall;\r\n}\r\nu.raw [i] = (u8) UDDR0;\r\n}\r\nif (unlikely((UDCCS0 & UDCCS0_RNE) != 0))\r\ngoto bad_setup;\r\ngot_setup:\r\nDBG(DBG_VERBOSE, "SETUP %02x.%02x v%04x i%04x l%04x\n",\r\nu.r.bRequestType, u.r.bRequest,\r\nle16_to_cpu(u.r.wValue),\r\nle16_to_cpu(u.r.wIndex),\r\nle16_to_cpu(u.r.wLength));\r\ndev->req_std = (u.r.bRequestType & USB_TYPE_MASK)\r\n== USB_TYPE_STANDARD;\r\ndev->req_config = 0;\r\ndev->req_pending = 1;\r\nswitch (u.r.bRequest) {\r\ncase USB_REQ_SET_CONFIGURATION:\r\nif (u.r.bRequestType == USB_RECIP_DEVICE) {\r\nconfig_change:\r\ndev->req_config = 1;\r\nclear_ep_state(dev);\r\n}\r\nbreak;\r\ncase USB_REQ_SET_INTERFACE:\r\nif (u.r.bRequestType == USB_RECIP_INTERFACE) {\r\nDMSG("broken set_interface (%d/%d)\n",\r\nle16_to_cpu(u.r.wIndex),\r\nle16_to_cpu(u.r.wValue));\r\ngoto config_change;\r\n}\r\nbreak;\r\ncase USB_REQ_SET_ADDRESS:\r\nif (u.r.bRequestType == USB_RECIP_DEVICE) {\r\nep0start(dev, 0, "address");\r\nreturn;\r\n}\r\nbreak;\r\n}\r\nif (u.r.bRequestType & USB_DIR_IN)\r\ndev->ep0state = EP0_IN_DATA_PHASE;\r\nelse\r\ndev->ep0state = EP0_OUT_DATA_PHASE;\r\ni = dev->driver->setup(&dev->gadget, &u.r);\r\nif (i < 0) {\r\nif (dev->req_config) {\r\nWARNING("config change %02x fail %d?\n",\r\nu.r.bRequest, i);\r\nreturn;\r\n}\r\nDBG(DBG_VERBOSE, "protocol STALL, "\r\n"%02x err %d\n", UDCCS0, i);\r\nstall:\r\nep0start(dev, UDCCS0_FST|UDCCS0_FTF, "stall");\r\nstart_watchdog(dev);\r\ndev->ep0state = EP0_STALL;\r\n} else if (dev->req_pending) {\r\nif (likely(dev->ep0state == EP0_IN_DATA_PHASE\r\n|| dev->req_std || u.r.wLength))\r\nep0start(dev, 0, "defer");\r\nelse\r\nep0start(dev, UDCCS0_IPR, "defer/IPR");\r\n}\r\nreturn;\r\n} else if (likely((udccs0 & (UDCCS0_OPR|UDCCS0_SA))\r\n== (UDCCS0_OPR|UDCCS0_SA))) {\r\nunsigned i;\r\nDBG(DBG_VERBOSE, "e131\n");\r\nnuke(ep, -EPROTO);\r\nfor (i = 0; i < 8; i++)\r\nu.raw [i] = (u8) UDDR0;\r\nif ((u.r.bRequestType & USB_RECIP_MASK)\r\n> USB_RECIP_OTHER)\r\ngoto stall;\r\nif (u.word [0] == 0 && u.word [1] == 0)\r\ngoto stall;\r\ngoto got_setup;\r\n} else {\r\nUDCCS0 = udccs0 & (UDCCS0_SA|UDCCS0_OPR);\r\n}\r\nbreak;\r\ncase EP0_IN_DATA_PHASE:\r\nif (udccs0 & UDCCS0_OPR) {\r\nUDCCS0 = UDCCS0_OPR|UDCCS0_FTF;\r\nDBG(DBG_VERBOSE, "ep0in premature status\n");\r\nif (req)\r\ndone(ep, req, 0);\r\nep0_idle(dev);\r\n} else {\r\nif (req) {\r\n(void) write_ep0_fifo(ep, req);\r\n}\r\n}\r\nbreak;\r\ncase EP0_OUT_DATA_PHASE:\r\nif (udccs0 & UDCCS0_OPR) {\r\nif (req) {\r\nif (read_ep0_fifo(ep, req))\r\ndone(ep, req, 0);\r\n}\r\n} else {\r\nDBG(DBG_VERBOSE, "ep0out premature status\n");\r\nif (req)\r\ndone(ep, req, 0);\r\nep0_idle(dev);\r\n}\r\nbreak;\r\ncase EP0_END_XFER:\r\nif (req)\r\ndone(ep, req, 0);\r\nif (udccs0 & UDCCS0_OPR)\r\nUDCCS0 = UDCCS0_OPR;\r\nep0_idle(dev);\r\nbreak;\r\ncase EP0_STALL:\r\nUDCCS0 = UDCCS0_FST;\r\nbreak;\r\n}\r\nUSIR0 = USIR0_IR0;\r\n}\r\nstatic void handle_ep(struct pxa25x_ep *ep)\r\n{\r\nstruct pxa25x_request *req;\r\nint is_in = ep->bEndpointAddress & USB_DIR_IN;\r\nint completed;\r\nu32 udccs, tmp;\r\ndo {\r\ncompleted = 0;\r\nif (likely (!list_empty(&ep->queue)))\r\nreq = list_entry(ep->queue.next,\r\nstruct pxa25x_request, queue);\r\nelse\r\nreq = NULL;\r\nudccs = *ep->reg_udccs;\r\nif (unlikely(is_in)) {\r\ntmp = UDCCS_BI_TUR;\r\nif (likely(ep->bmAttributes == USB_ENDPOINT_XFER_BULK))\r\ntmp |= UDCCS_BI_SST;\r\ntmp &= udccs;\r\nif (likely (tmp))\r\n*ep->reg_udccs = tmp;\r\nif (req && likely ((udccs & UDCCS_BI_TFS) != 0))\r\ncompleted = write_fifo(ep, req);\r\n} else {\r\nif (likely(ep->bmAttributes == USB_ENDPOINT_XFER_BULK))\r\ntmp = UDCCS_BO_SST | UDCCS_BO_DME;\r\nelse\r\ntmp = UDCCS_IO_ROF | UDCCS_IO_DME;\r\ntmp &= udccs;\r\nif (likely(tmp))\r\n*ep->reg_udccs = tmp;\r\nif (likely(req)) {\r\ncompleted = read_fifo(ep, req);\r\n} else\r\npio_irq_disable (ep->bEndpointAddress);\r\n}\r\nep->pio_irqs++;\r\n} while (completed);\r\n}\r\nstatic irqreturn_t\r\npxa25x_udc_irq(int irq, void *_dev)\r\n{\r\nstruct pxa25x_udc *dev = _dev;\r\nint handled;\r\ndev->stats.irqs++;\r\ndo {\r\nu32 udccr = UDCCR;\r\nhandled = 0;\r\nif (unlikely(udccr & UDCCR_SUSIR)) {\r\nudc_ack_int_UDCCR(UDCCR_SUSIR);\r\nhandled = 1;\r\nDBG(DBG_VERBOSE, "USB suspend\n");\r\nif (dev->gadget.speed != USB_SPEED_UNKNOWN\r\n&& dev->driver\r\n&& dev->driver->suspend)\r\ndev->driver->suspend(&dev->gadget);\r\nep0_idle (dev);\r\n}\r\nif (unlikely(udccr & UDCCR_RESIR)) {\r\nudc_ack_int_UDCCR(UDCCR_RESIR);\r\nhandled = 1;\r\nDBG(DBG_VERBOSE, "USB resume\n");\r\nif (dev->gadget.speed != USB_SPEED_UNKNOWN\r\n&& dev->driver\r\n&& dev->driver->resume)\r\ndev->driver->resume(&dev->gadget);\r\n}\r\nif (unlikely(udccr & UDCCR_RSTIR)) {\r\nudc_ack_int_UDCCR(UDCCR_RSTIR);\r\nhandled = 1;\r\nif ((UDCCR & UDCCR_UDA) == 0) {\r\nDBG(DBG_VERBOSE, "USB reset start\n");\r\nstop_activity (dev, dev->driver);\r\n} else {\r\nDBG(DBG_VERBOSE, "USB reset end\n");\r\ndev->gadget.speed = USB_SPEED_FULL;\r\nmemset(&dev->stats, 0, sizeof dev->stats);\r\n}\r\n} else {\r\nu32 usir0 = USIR0 & ~UICR0;\r\nu32 usir1 = USIR1 & ~UICR1;\r\nint i;\r\nif (unlikely (!usir0 && !usir1))\r\ncontinue;\r\nDBG(DBG_VERY_NOISY, "irq %02x.%02x\n", usir1, usir0);\r\nif (usir0 & USIR0_IR0) {\r\ndev->ep[0].pio_irqs++;\r\nhandle_ep0(dev);\r\nhandled = 1;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nu32 tmp = 1 << i;\r\nif (i && (usir0 & tmp)) {\r\nhandle_ep(&dev->ep[i]);\r\nUSIR0 |= tmp;\r\nhandled = 1;\r\n}\r\n#ifndef CONFIG_USB_PXA25X_SMALL\r\nif (usir1 & tmp) {\r\nhandle_ep(&dev->ep[i+8]);\r\nUSIR1 |= tmp;\r\nhandled = 1;\r\n}\r\n#endif\r\n}\r\n}\r\n} while (handled);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void nop_release (struct device *dev)\r\n{\r\nDMSG("%s %s\n", __func__, dev_name(dev));\r\n}\r\nstatic int pxa25x_udc_probe(struct platform_device *pdev)\r\n{\r\nstruct pxa25x_udc *dev = &memory;\r\nint retval, irq;\r\nu32 chiprev;\r\npr_info("%s: version %s\n", driver_name, DRIVER_VERSION);\r\nasm("mrc%? p15, 0, %0, c0, c0" : "=r" (chiprev));\r\nif ((chiprev & CP15R0_VENDOR_MASK) != CP15R0_XSCALE_VALUE) {\r\npr_err("%s: not XScale!\n", driver_name);\r\nreturn -ENODEV;\r\n}\r\nswitch (chiprev & CP15R0_PRODREV_MASK) {\r\n#if defined(CONFIG_ARCH_PXA)\r\ncase PXA255_A0:\r\ndev->has_cfr = 1;\r\nbreak;\r\ncase PXA250_A0:\r\ncase PXA250_A1:\r\ncase PXA250_B2: case PXA210_B2:\r\ncase PXA250_B1: case PXA210_B1:\r\ncase PXA250_B0: case PXA210_B0:\r\ncase PXA250_C0: case PXA210_C0:\r\nbreak;\r\n#elif defined(CONFIG_ARCH_IXP4XX)\r\ncase IXP425_A0:\r\ncase IXP425_B0:\r\ncase IXP465_AD:\r\ndev->has_cfr = 1;\r\nbreak;\r\n#endif\r\ndefault:\r\npr_err("%s: unrecognized processor: %08x\n",\r\ndriver_name, chiprev);\r\nreturn -ENODEV;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn -ENODEV;\r\ndev->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dev->clk)) {\r\nretval = PTR_ERR(dev->clk);\r\ngoto err_clk;\r\n}\r\npr_debug("%s: IRQ %d%s%s\n", driver_name, irq,\r\ndev->has_cfr ? "" : " (!cfr)",\r\nSIZE_STR "(pio)"\r\n);\r\ndev->dev = &pdev->dev;\r\ndev->mach = dev_get_platdata(&pdev->dev);\r\ndev->transceiver = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (gpio_is_valid(dev->mach->gpio_pullup)) {\r\nif ((retval = gpio_request(dev->mach->gpio_pullup,\r\n"pca25x_udc GPIO PULLUP"))) {\r\ndev_dbg(&pdev->dev,\r\n"can't get pullup gpio %d, err: %d\n",\r\ndev->mach->gpio_pullup, retval);\r\ngoto err_gpio_pullup;\r\n}\r\ngpio_direction_output(dev->mach->gpio_pullup, 0);\r\n}\r\ninit_timer(&dev->timer);\r\ndev->timer.function = udc_watchdog;\r\ndev->timer.data = (unsigned long) dev;\r\nthe_controller = dev;\r\nplatform_set_drvdata(pdev, dev);\r\nudc_disable(dev);\r\nudc_reinit(dev);\r\ndev->vbus = 0;\r\nretval = request_irq(irq, pxa25x_udc_irq,\r\n0, driver_name, dev);\r\nif (retval != 0) {\r\npr_err("%s: can't get irq %d, err %d\n",\r\ndriver_name, irq, retval);\r\ngoto err_irq1;\r\n}\r\ndev->got_irq = 1;\r\n#ifdef CONFIG_ARCH_LUBBOCK\r\nif (machine_is_lubbock()) {\r\nretval = request_irq(LUBBOCK_USB_DISC_IRQ, lubbock_vbus_irq,\r\n0, driver_name, dev);\r\nif (retval != 0) {\r\npr_err("%s: can't get irq %i, err %d\n",\r\ndriver_name, LUBBOCK_USB_DISC_IRQ, retval);\r\ngoto err_irq_lub;\r\n}\r\nretval = request_irq(LUBBOCK_USB_IRQ, lubbock_vbus_irq,\r\n0, driver_name, dev);\r\nif (retval != 0) {\r\npr_err("%s: can't get irq %i, err %d\n",\r\ndriver_name, LUBBOCK_USB_IRQ, retval);\r\ngoto lubbock_fail0;\r\n}\r\n} else\r\n#endif\r\ncreate_debug_files(dev);\r\nretval = usb_add_gadget_udc(&pdev->dev, &dev->gadget);\r\nif (!retval)\r\nreturn retval;\r\nremove_debug_files(dev);\r\n#ifdef CONFIG_ARCH_LUBBOCK\r\nlubbock_fail0:\r\nfree_irq(LUBBOCK_USB_DISC_IRQ, dev);\r\nerr_irq_lub:\r\nfree_irq(irq, dev);\r\n#endif\r\nerr_irq1:\r\nif (gpio_is_valid(dev->mach->gpio_pullup))\r\ngpio_free(dev->mach->gpio_pullup);\r\nerr_gpio_pullup:\r\nif (!IS_ERR_OR_NULL(dev->transceiver)) {\r\nusb_put_phy(dev->transceiver);\r\ndev->transceiver = NULL;\r\n}\r\nclk_put(dev->clk);\r\nerr_clk:\r\nreturn retval;\r\n}\r\nstatic void pxa25x_udc_shutdown(struct platform_device *_dev)\r\n{\r\npullup_off();\r\n}\r\nstatic int pxa25x_udc_remove(struct platform_device *pdev)\r\n{\r\nstruct pxa25x_udc *dev = platform_get_drvdata(pdev);\r\nif (dev->driver)\r\nreturn -EBUSY;\r\nusb_del_gadget_udc(&dev->gadget);\r\ndev->pullup = 0;\r\npullup(dev);\r\nremove_debug_files(dev);\r\nif (dev->got_irq) {\r\nfree_irq(platform_get_irq(pdev, 0), dev);\r\ndev->got_irq = 0;\r\n}\r\n#ifdef CONFIG_ARCH_LUBBOCK\r\nif (machine_is_lubbock()) {\r\nfree_irq(LUBBOCK_USB_DISC_IRQ, dev);\r\nfree_irq(LUBBOCK_USB_IRQ, dev);\r\n}\r\n#endif\r\nif (gpio_is_valid(dev->mach->gpio_pullup))\r\ngpio_free(dev->mach->gpio_pullup);\r\nclk_put(dev->clk);\r\nif (!IS_ERR_OR_NULL(dev->transceiver)) {\r\nusb_put_phy(dev->transceiver);\r\ndev->transceiver = NULL;\r\n}\r\nthe_controller = NULL;\r\nreturn 0;\r\n}\r\nstatic int pxa25x_udc_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct pxa25x_udc *udc = platform_get_drvdata(dev);\r\nunsigned long flags;\r\nif (!gpio_is_valid(udc->mach->gpio_pullup) && !udc->mach->udc_command)\r\nWARNING("USB host won't detect disconnect!\n");\r\nudc->suspended = 1;\r\nlocal_irq_save(flags);\r\npullup(udc);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int pxa25x_udc_resume(struct platform_device *dev)\r\n{\r\nstruct pxa25x_udc *udc = platform_get_drvdata(dev);\r\nunsigned long flags;\r\nudc->suspended = 0;\r\nlocal_irq_save(flags);\r\npullup(udc);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}
