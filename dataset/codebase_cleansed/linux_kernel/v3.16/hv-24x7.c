static ssize_t read_offset_data(void *dest, size_t dest_len,\r\nloff_t requested_offset, void *src,\r\nsize_t src_len, loff_t source_offset)\r\n{\r\nsize_t w_offset_in_s = requested_offset - source_offset;\r\nsize_t z_offset_in_s = src_len;\r\nsize_t v_offset_in_s = requested_offset + dest_len - src_len;\r\nsize_t u_offset_in_s = min(z_offset_in_s, v_offset_in_s);\r\nsize_t copy_len = u_offset_in_s - w_offset_in_s;\r\nif (requested_offset < 0 || source_offset < 0)\r\nreturn -EINVAL;\r\nif (z_offset_in_s <= w_offset_in_s)\r\nreturn 0;\r\nmemcpy(dest, src + w_offset_in_s, copy_len);\r\nreturn copy_len;\r\n}\r\nstatic unsigned long h_get_24x7_catalog_page_(unsigned long phys_4096,\r\nunsigned long version,\r\nunsigned long index)\r\n{\r\npr_devel("h_get_24x7_catalog_page(0x%lx, %lu, %lu)",\r\nphys_4096,\r\nversion,\r\nindex);\r\nWARN_ON(!IS_ALIGNED(phys_4096, 4096));\r\nreturn plpar_hcall_norets(H_GET_24X7_CATALOG_PAGE,\r\nphys_4096,\r\nversion,\r\nindex);\r\n}\r\nstatic unsigned long h_get_24x7_catalog_page(char page[],\r\nu64 version, u32 index)\r\n{\r\nreturn h_get_24x7_catalog_page_(virt_to_phys(page),\r\nversion, index);\r\n}\r\nstatic ssize_t catalog_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf,\r\nloff_t offset, size_t count)\r\n{\r\nunsigned long hret;\r\nssize_t ret = 0;\r\nsize_t catalog_len = 0, catalog_page_len = 0, page_count = 0;\r\nloff_t page_offset = 0;\r\nuint64_t catalog_version_num = 0;\r\nvoid *page = kmem_cache_alloc(hv_page_cache, GFP_USER);\r\nstruct hv_24x7_catalog_page_0 *page_0 = page;\r\nif (!page)\r\nreturn -ENOMEM;\r\nhret = h_get_24x7_catalog_page(page, 0, 0);\r\nif (hret) {\r\nret = -EIO;\r\ngoto e_free;\r\n}\r\ncatalog_version_num = be64_to_cpu(page_0->version);\r\ncatalog_page_len = be32_to_cpu(page_0->length);\r\ncatalog_len = catalog_page_len * 4096;\r\npage_offset = offset / 4096;\r\npage_count = count / 4096;\r\nif (page_offset >= catalog_page_len)\r\ngoto e_free;\r\nif (page_offset != 0) {\r\nhret = h_get_24x7_catalog_page(page, catalog_version_num,\r\npage_offset);\r\nif (hret) {\r\nret = -EIO;\r\ngoto e_free;\r\n}\r\n}\r\nret = read_offset_data(buf, count, offset,\r\npage, 4096, page_offset * 4096);\r\ne_free:\r\nif (hret)\r\npr_err("h_get_24x7_catalog_page(ver=%lld, page=%lld) failed:"\r\n" rc=%ld\n",\r\ncatalog_version_num, page_offset, hret);\r\nkfree(page);\r\npr_devel("catalog_read: offset=%lld(%lld) count=%zu(%zu) catalog_len=%zu(%zu) => %zd\n",\r\noffset, page_offset, count, page_count, catalog_len,\r\ncatalog_page_len, ret);\r\nreturn ret;\r\n}\r\nstatic bool is_physical_domain(int domain)\r\n{\r\nreturn domain == HV_24X7_PERF_DOMAIN_PHYSICAL_CHIP ||\r\ndomain == HV_24X7_PERF_DOMAIN_PHYSICAL_CORE;\r\n}\r\nstatic unsigned long single_24x7_request(u8 domain, u32 offset, u16 ix,\r\nu16 lpar, u64 *res,\r\nbool success_expected)\r\n{\r\nunsigned long ret;\r\nstruct reqb {\r\nstruct hv_24x7_request_buffer buf;\r\nstruct hv_24x7_request req;\r\n} __packed __aligned(4096) request_buffer = {\r\n.buf = {\r\n.interface_version = HV_24X7_IF_VERSION_CURRENT,\r\n.num_requests = 1,\r\n},\r\n.req = {\r\n.performance_domain = domain,\r\n.data_size = cpu_to_be16(8),\r\n.data_offset = cpu_to_be32(offset),\r\n.starting_lpar_ix = cpu_to_be16(lpar),\r\n.max_num_lpars = cpu_to_be16(1),\r\n.starting_ix = cpu_to_be16(ix),\r\n.max_ix = cpu_to_be16(1),\r\n}\r\n};\r\nstruct resb {\r\nstruct hv_24x7_data_result_buffer buf;\r\nstruct hv_24x7_result res;\r\nstruct hv_24x7_result_element elem;\r\n__be64 result;\r\n} __packed __aligned(4096) result_buffer = {};\r\nret = plpar_hcall_norets(H_GET_24X7_DATA,\r\nvirt_to_phys(&request_buffer), sizeof(request_buffer),\r\nvirt_to_phys(&result_buffer), sizeof(result_buffer));\r\nif (ret) {\r\nif (success_expected)\r\npr_err_ratelimited("hcall failed: %d %#x %#x %d => 0x%lx (%ld) detail=0x%x failing ix=%x\n",\r\ndomain, offset, ix, lpar,\r\nret, ret,\r\nresult_buffer.buf.detailed_rc,\r\nresult_buffer.buf.failing_request_ix);\r\nreturn ret;\r\n}\r\n*res = be64_to_cpu(result_buffer.result);\r\nreturn ret;\r\n}\r\nstatic unsigned long event_24x7_request(struct perf_event *event, u64 *res,\r\nbool success_expected)\r\n{\r\nreturn single_24x7_request(event_get_domain(event),\r\nevent_get_offset(event),\r\nevent_get_starting_index(event),\r\nevent_get_lpar(event),\r\nres,\r\nsuccess_expected);\r\n}\r\nstatic int h_24x7_event_init(struct perf_event *event)\r\n{\r\nstruct hv_perf_caps caps;\r\nunsigned domain;\r\nunsigned long hret;\r\nu64 ct;\r\nif (event->attr.type != event->pmu->type)\r\nreturn -ENOENT;\r\nif (event_get_reserved1(event) ||\r\nevent_get_reserved2(event) ||\r\nevent_get_reserved3(event)) {\r\npr_devel("reserved set when forbidden 0x%llx(0x%llx) 0x%llx(0x%llx) 0x%llx(0x%llx)\n",\r\nevent->attr.config,\r\nevent_get_reserved1(event),\r\nevent->attr.config1,\r\nevent_get_reserved2(event),\r\nevent->attr.config2,\r\nevent_get_reserved3(event));\r\nreturn -EINVAL;\r\n}\r\nif (event->attr.exclude_user ||\r\nevent->attr.exclude_kernel ||\r\nevent->attr.exclude_hv ||\r\nevent->attr.exclude_idle ||\r\nevent->attr.exclude_host ||\r\nevent->attr.exclude_guest ||\r\nis_sampling_event(event))\r\nreturn -EINVAL;\r\nif (has_branch_stack(event))\r\nreturn -EOPNOTSUPP;\r\nif (event_get_offset(event) % 8) {\r\npr_devel("bad alignment\n");\r\nreturn -EINVAL;\r\n}\r\ndomain = event_get_domain(event);\r\nif (domain > 6) {\r\npr_devel("invalid domain %d\n", domain);\r\nreturn -EINVAL;\r\n}\r\nhret = hv_perf_caps_get(&caps);\r\nif (hret) {\r\npr_devel("could not get capabilities: rc=%ld\n", hret);\r\nreturn -EIO;\r\n}\r\nif (!caps.collect_privileged && (is_physical_domain(domain) ||\r\n(event_get_lpar(event) != event_get_lpar_max()))) {\r\npr_devel("hv permisions disallow: is_physical_domain:%d, lpar=0x%llx\n",\r\nis_physical_domain(domain),\r\nevent_get_lpar(event));\r\nreturn -EACCES;\r\n}\r\nif (event_24x7_request(event, &ct, false)) {\r\npr_devel("test hcall failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 h_24x7_get_value(struct perf_event *event)\r\n{\r\nunsigned long ret;\r\nu64 ct;\r\nret = event_24x7_request(event, &ct, true);\r\nif (ret)\r\nreturn 0;\r\nreturn ct;\r\n}\r\nstatic void h_24x7_event_update(struct perf_event *event)\r\n{\r\ns64 prev;\r\nu64 now;\r\nnow = h_24x7_get_value(event);\r\nprev = local64_xchg(&event->hw.prev_count, now);\r\nlocal64_add(now - prev, &event->count);\r\n}\r\nstatic void h_24x7_event_start(struct perf_event *event, int flags)\r\n{\r\nif (flags & PERF_EF_RELOAD)\r\nlocal64_set(&event->hw.prev_count, h_24x7_get_value(event));\r\n}\r\nstatic void h_24x7_event_stop(struct perf_event *event, int flags)\r\n{\r\nh_24x7_event_update(event);\r\n}\r\nstatic int h_24x7_event_add(struct perf_event *event, int flags)\r\n{\r\nif (flags & PERF_EF_START)\r\nh_24x7_event_start(event, flags);\r\nreturn 0;\r\n}\r\nstatic int h_24x7_event_idx(struct perf_event *event)\r\n{\r\nreturn 0;\r\n}\r\nstatic int hv_24x7_init(void)\r\n{\r\nint r;\r\nunsigned long hret;\r\nstruct hv_perf_caps caps;\r\nif (!firmware_has_feature(FW_FEATURE_LPAR)) {\r\npr_debug("not a virtualized system, not enabling\n");\r\nreturn -ENODEV;\r\n}\r\nhret = hv_perf_caps_get(&caps);\r\nif (hret) {\r\npr_debug("could not obtain capabilities, not enabling, rc=%ld\n",\r\nhret);\r\nreturn -ENODEV;\r\n}\r\nhv_page_cache = kmem_cache_create("hv-page-4096", 4096, 4096, 0, NULL);\r\nif (!hv_page_cache)\r\nreturn -ENOMEM;\r\nr = perf_pmu_register(&h_24x7_pmu, h_24x7_pmu.name, -1);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}
