static inline void lec_arp_hold(struct lec_arp_table *entry)\r\n{\r\natomic_inc(&entry->usage);\r\n}\r\nstatic inline void lec_arp_put(struct lec_arp_table *entry)\r\n{\r\nif (atomic_dec_and_test(&entry->usage))\r\nkfree(entry);\r\n}\r\nstatic void lec_handle_bridge(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nchar *buff;\r\nstruct lec_priv *priv;\r\nbuff = skb->data + skb->dev->hard_header_len;\r\nif (*buff++ == 0x42 && *buff++ == 0x42 && *buff++ == 0x03) {\r\nstruct sock *sk;\r\nstruct sk_buff *skb2;\r\nstruct atmlec_msg *mesg;\r\nskb2 = alloc_skb(sizeof(struct atmlec_msg), GFP_ATOMIC);\r\nif (skb2 == NULL)\r\nreturn;\r\nskb2->len = sizeof(struct atmlec_msg);\r\nmesg = (struct atmlec_msg *)skb2->data;\r\nmesg->type = l_topology_change;\r\nbuff += 4;\r\nmesg->content.normal.flag = *buff & 0x01;\r\npriv = netdev_priv(dev);\r\natm_force_charge(priv->lecd, skb2->truesize);\r\nsk = sk_atm(priv->lecd);\r\nskb_queue_tail(&sk->sk_receive_queue, skb2);\r\nsk->sk_data_ready(sk);\r\n}\r\n}\r\nstatic int lec_open(struct net_device *dev)\r\n{\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void\r\nlec_send(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nATM_SKB(skb)->vcc = vcc;\r\nATM_SKB(skb)->atm_options = vcc->atm_options;\r\natomic_add(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);\r\nif (vcc->send(vcc, skb) < 0) {\r\ndev->stats.tx_dropped++;\r\nreturn;\r\n}\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\n}\r\nstatic void lec_tx_timeout(struct net_device *dev)\r\n{\r\npr_info("%s\n", dev->name);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t lec_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct sk_buff *skb2;\r\nstruct lec_priv *priv = netdev_priv(dev);\r\nstruct lecdatahdr_8023 *lec_h;\r\nstruct atm_vcc *vcc;\r\nstruct lec_arp_table *entry;\r\nunsigned char *dst;\r\nint min_frame_size;\r\nint is_rdesc;\r\npr_debug("called\n");\r\nif (!priv->lecd) {\r\npr_info("%s:No lecd attached\n", dev->name);\r\ndev->stats.tx_errors++;\r\nnetif_stop_queue(dev);\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\npr_debug("skbuff head:%lx data:%lx tail:%lx end:%lx\n",\r\n(long)skb->head, (long)skb->data, (long)skb_tail_pointer(skb),\r\n(long)skb_end_pointer(skb));\r\n#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)\r\nif (memcmp(skb->data, bridge_ula_lec, sizeof(bridge_ula_lec)) == 0)\r\nlec_handle_bridge(skb, dev);\r\n#endif\r\nif (skb_headroom(skb) < 2) {\r\npr_debug("reallocating skb\n");\r\nskb2 = skb_realloc_headroom(skb, LEC_HEADER_LEN);\r\nif (unlikely(!skb2)) {\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nconsume_skb(skb);\r\nskb = skb2;\r\n}\r\nskb_push(skb, 2);\r\nlec_h = (struct lecdatahdr_8023 *)skb->data;\r\nlec_h->le_header = htons(priv->lecid);\r\n#if DUMP_PACKETS >= 2\r\n#define MAX_DUMP_SKB 99\r\n#elif DUMP_PACKETS >= 1\r\n#define MAX_DUMP_SKB 30\r\n#endif\r\n#if DUMP_PACKETS >= 1\r\nprintk(KERN_DEBUG "%s: send datalen:%ld lecid:%4.4x\n",\r\ndev->name, skb->len, priv->lecid);\r\nprint_hex_dump(KERN_DEBUG, "", DUMP_OFFSET, 16, 1,\r\nskb->data, min(skb->len, MAX_DUMP_SKB), true);\r\n#endif\r\nmin_frame_size = LEC_MINIMUM_8023_SIZE;\r\nif (skb->len < min_frame_size) {\r\nif ((skb->len + skb_tailroom(skb)) < min_frame_size) {\r\nskb2 = skb_copy_expand(skb, 0,\r\nmin_frame_size - skb->truesize,\r\nGFP_ATOMIC);\r\ndev_kfree_skb(skb);\r\nif (skb2 == NULL) {\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nskb = skb2;\r\n}\r\nskb_put(skb, min_frame_size - skb->len);\r\n}\r\nis_rdesc = 0;\r\ndst = lec_h->h_dest;\r\nentry = NULL;\r\nvcc = lec_arp_resolve(priv, dst, is_rdesc, &entry);\r\npr_debug("%s:vcc:%p vcc_flags:%lx, entry:%p\n",\r\ndev->name, vcc, vcc ? vcc->flags : 0, entry);\r\nif (!vcc || !test_bit(ATM_VF_READY, &vcc->flags)) {\r\nif (entry && (entry->tx_wait.qlen < LEC_UNRES_QUE_LEN)) {\r\npr_debug("%s:queuing packet, MAC address %pM\n",\r\ndev->name, lec_h->h_dest);\r\nskb_queue_tail(&entry->tx_wait, skb);\r\n} else {\r\npr_debug("%s:tx queue full or no arp entry, dropping, MAC address: %pM\n",\r\ndev->name, lec_h->h_dest);\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\n}\r\ngoto out;\r\n}\r\n#if DUMP_PACKETS > 0\r\nprintk(KERN_DEBUG "%s:sending to vpi:%d vci:%d\n",\r\ndev->name, vcc->vpi, vcc->vci);\r\n#endif\r\nwhile (entry && (skb2 = skb_dequeue(&entry->tx_wait))) {\r\npr_debug("emptying tx queue, MAC address %pM\n", lec_h->h_dest);\r\nlec_send(vcc, skb2);\r\n}\r\nlec_send(vcc, skb);\r\nif (!atm_may_send(vcc, 0)) {\r\nstruct lec_vcc_priv *vpriv = LEC_VCC_PRIV(vcc);\r\nvpriv->xoff = 1;\r\nnetif_stop_queue(dev);\r\nif (atm_may_send(vcc, 0))\r\nnetif_wake_queue(dev);\r\n}\r\nout:\r\nif (entry)\r\nlec_arp_put(entry);\r\ndev->trans_start = jiffies;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int lec_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int lec_atm_send(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nunsigned long flags;\r\nstruct net_device *dev = (struct net_device *)vcc->proto_data;\r\nstruct lec_priv *priv = netdev_priv(dev);\r\nstruct atmlec_msg *mesg;\r\nstruct lec_arp_table *entry;\r\nint i;\r\nchar *tmp;\r\natomic_sub(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);\r\nmesg = (struct atmlec_msg *)skb->data;\r\ntmp = skb->data;\r\ntmp += sizeof(struct atmlec_msg);\r\npr_debug("%s: msg from zeppelin:%d\n", dev->name, mesg->type);\r\nswitch (mesg->type) {\r\ncase l_set_mac_addr:\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = mesg->content.normal.mac_addr[i];\r\nbreak;\r\ncase l_del_mac_addr:\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = 0;\r\nbreak;\r\ncase l_addr_delete:\r\nlec_addr_delete(priv, mesg->content.normal.atm_addr,\r\nmesg->content.normal.flag);\r\nbreak;\r\ncase l_topology_change:\r\npriv->topology_change = mesg->content.normal.flag;\r\nbreak;\r\ncase l_flush_complete:\r\nlec_flush_complete(priv, mesg->content.normal.flag);\r\nbreak;\r\ncase l_narp_req:\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nentry = lec_arp_find(priv, mesg->content.normal.mac_addr);\r\nlec_arp_remove(priv, entry);\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\nif (mesg->content.normal.no_source_le_narp)\r\nbreak;\r\ncase l_arp_update:\r\nlec_arp_update(priv, mesg->content.normal.mac_addr,\r\nmesg->content.normal.atm_addr,\r\nmesg->content.normal.flag,\r\nmesg->content.normal.targetless_le_arp);\r\npr_debug("in l_arp_update\n");\r\nif (mesg->sizeoftlvs != 0) {\r\npr_debug("LANE2 3.1.5, got tlvs, size %d\n",\r\nmesg->sizeoftlvs);\r\nlane2_associate_ind(dev, mesg->content.normal.mac_addr,\r\ntmp, mesg->sizeoftlvs);\r\n}\r\nbreak;\r\ncase l_config:\r\npriv->maximum_unknown_frame_count =\r\nmesg->content.config.maximum_unknown_frame_count;\r\npriv->max_unknown_frame_time =\r\n(mesg->content.config.max_unknown_frame_time * HZ);\r\npriv->max_retry_count = mesg->content.config.max_retry_count;\r\npriv->aging_time = (mesg->content.config.aging_time * HZ);\r\npriv->forward_delay_time =\r\n(mesg->content.config.forward_delay_time * HZ);\r\npriv->arp_response_time =\r\n(mesg->content.config.arp_response_time * HZ);\r\npriv->flush_timeout = (mesg->content.config.flush_timeout * HZ);\r\npriv->path_switching_delay =\r\n(mesg->content.config.path_switching_delay * HZ);\r\npriv->lane_version = mesg->content.config.lane_version;\r\npriv->lane2_ops = NULL;\r\nif (priv->lane_version > 1)\r\npriv->lane2_ops = &lane2_ops;\r\nif (dev_set_mtu(dev, mesg->content.config.mtu))\r\npr_info("%s: change_mtu to %d failed\n",\r\ndev->name, mesg->content.config.mtu);\r\npriv->is_proxy = mesg->content.config.is_proxy;\r\nbreak;\r\ncase l_flush_tran_id:\r\nlec_set_flush_tran_id(priv, mesg->content.normal.atm_addr,\r\nmesg->content.normal.flag);\r\nbreak;\r\ncase l_set_lecid:\r\npriv->lecid =\r\n(unsigned short)(0xffff & mesg->content.normal.flag);\r\nbreak;\r\ncase l_should_bridge:\r\n#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)\r\n{\r\npr_debug("%s: bridge zeppelin asks about %pM\n",\r\ndev->name, mesg->content.proxy.mac_addr);\r\nif (br_fdb_test_addr_hook == NULL)\r\nbreak;\r\nif (br_fdb_test_addr_hook(dev, mesg->content.proxy.mac_addr)) {\r\nstruct sk_buff *skb2;\r\nstruct sock *sk;\r\npr_debug("%s: entry found, responding to zeppelin\n",\r\ndev->name);\r\nskb2 = alloc_skb(sizeof(struct atmlec_msg), GFP_ATOMIC);\r\nif (skb2 == NULL)\r\nbreak;\r\nskb2->len = sizeof(struct atmlec_msg);\r\nskb_copy_to_linear_data(skb2, mesg, sizeof(*mesg));\r\natm_force_charge(priv->lecd, skb2->truesize);\r\nsk = sk_atm(priv->lecd);\r\nskb_queue_tail(&sk->sk_receive_queue, skb2);\r\nsk->sk_data_ready(sk);\r\n}\r\n}\r\n#endif\r\nbreak;\r\ndefault:\r\npr_info("%s: Unknown message type %d\n", dev->name, mesg->type);\r\ndev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void lec_atm_close(struct atm_vcc *vcc)\r\n{\r\nstruct sk_buff *skb;\r\nstruct net_device *dev = (struct net_device *)vcc->proto_data;\r\nstruct lec_priv *priv = netdev_priv(dev);\r\npriv->lecd = NULL;\r\nnetif_stop_queue(dev);\r\nlec_arp_destroy(priv);\r\nif (skb_peek(&sk_atm(vcc)->sk_receive_queue))\r\npr_info("%s closing with messages pending\n", dev->name);\r\nwhile ((skb = skb_dequeue(&sk_atm(vcc)->sk_receive_queue))) {\r\natm_return(vcc, skb->truesize);\r\ndev_kfree_skb(skb);\r\n}\r\npr_info("%s: Shut down!\n", dev->name);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int\r\nsend_to_lecd(struct lec_priv *priv, atmlec_msg_type type,\r\nconst unsigned char *mac_addr, const unsigned char *atm_addr,\r\nstruct sk_buff *data)\r\n{\r\nstruct sock *sk;\r\nstruct sk_buff *skb;\r\nstruct atmlec_msg *mesg;\r\nif (!priv || !priv->lecd)\r\nreturn -1;\r\nskb = alloc_skb(sizeof(struct atmlec_msg), GFP_ATOMIC);\r\nif (!skb)\r\nreturn -1;\r\nskb->len = sizeof(struct atmlec_msg);\r\nmesg = (struct atmlec_msg *)skb->data;\r\nmemset(mesg, 0, sizeof(struct atmlec_msg));\r\nmesg->type = type;\r\nif (data != NULL)\r\nmesg->sizeoftlvs = data->len;\r\nif (mac_addr)\r\nether_addr_copy(mesg->content.normal.mac_addr, mac_addr);\r\nelse\r\nmesg->content.normal.targetless_le_arp = 1;\r\nif (atm_addr)\r\nmemcpy(&mesg->content.normal.atm_addr, atm_addr, ATM_ESA_LEN);\r\natm_force_charge(priv->lecd, skb->truesize);\r\nsk = sk_atm(priv->lecd);\r\nskb_queue_tail(&sk->sk_receive_queue, skb);\r\nsk->sk_data_ready(sk);\r\nif (data != NULL) {\r\npr_debug("about to send %d bytes of data\n", data->len);\r\natm_force_charge(priv->lecd, data->truesize);\r\nskb_queue_tail(&sk->sk_receive_queue, data);\r\nsk->sk_data_ready(sk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lec_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif ((new_mtu < 68) || (new_mtu > 18190))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void lec_set_multicast_list(struct net_device *dev)\r\n{\r\n}\r\nstatic int lec_is_data_direct(struct atm_vcc *vcc)\r\n{\r\nreturn ((vcc->sap.blli[0].l3.tr9577.snap[4] == LEC_DATA_DIRECT_8023) ||\r\n(vcc->sap.blli[0].l3.tr9577.snap[4] == LEC_DATA_DIRECT_8025));\r\n}\r\nstatic void lec_push(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nunsigned long flags;\r\nstruct net_device *dev = (struct net_device *)vcc->proto_data;\r\nstruct lec_priv *priv = netdev_priv(dev);\r\n#if DUMP_PACKETS > 0\r\nprintk(KERN_DEBUG "%s: vcc vpi:%d vci:%d\n",\r\ndev->name, vcc->vpi, vcc->vci);\r\n#endif\r\nif (!skb) {\r\npr_debug("%s: null skb\n", dev->name);\r\nlec_vcc_close(priv, vcc);\r\nreturn;\r\n}\r\n#if DUMP_PACKETS >= 2\r\n#define MAX_SKB_DUMP 99\r\n#elif DUMP_PACKETS >= 1\r\n#define MAX_SKB_DUMP 30\r\n#endif\r\n#if DUMP_PACKETS > 0\r\nprintk(KERN_DEBUG "%s: rcv datalen:%ld lecid:%4.4x\n",\r\ndev->name, skb->len, priv->lecid);\r\nprint_hex_dump(KERN_DEBUG, "", DUMP_OFFSET, 16, 1,\r\nskb->data, min(MAX_SKB_DUMP, skb->len), true);\r\n#endif\r\nif (memcmp(skb->data, lec_ctrl_magic, 4) == 0) {\r\nstruct sock *sk = sk_atm(vcc);\r\npr_debug("%s: To daemon\n", dev->name);\r\nskb_queue_tail(&sk->sk_receive_queue, skb);\r\nsk->sk_data_ready(sk);\r\n} else {\r\nstruct lec_arp_table *entry;\r\nunsigned char *src, *dst;\r\natm_return(vcc, skb->truesize);\r\nif (*(__be16 *) skb->data == htons(priv->lecid) ||\r\n!priv->lecd || !(dev->flags & IFF_UP)) {\r\npr_debug("Ignoring frame...\n");\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\ndst = ((struct lecdatahdr_8023 *)skb->data)->h_dest;\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nif (lec_is_data_direct(vcc)) {\r\nsrc = ((struct lecdatahdr_8023 *)skb->data)->h_source;\r\nentry = lec_arp_find(priv, src);\r\nif (entry && entry->vcc != vcc) {\r\nlec_arp_remove(priv, entry);\r\nlec_arp_put(entry);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\nif (!(dst[0] & 0x01) &&\r\n!priv->is_proxy &&\r\nmemcmp(dst, dev->dev_addr, dev->addr_len)) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif (!hlist_empty(&priv->lec_arp_empty_ones))\r\nlec_arp_check_empties(priv, vcc, skb);\r\nskb_pull(skb, 2);\r\nskb->protocol = eth_type_trans(skb, dev);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nmemset(ATM_SKB(skb), 0, sizeof(struct atm_skb_data));\r\nnetif_rx(skb);\r\n}\r\n}\r\nstatic void lec_pop(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nstruct lec_vcc_priv *vpriv = LEC_VCC_PRIV(vcc);\r\nstruct net_device *dev = skb->dev;\r\nif (vpriv == NULL) {\r\npr_info("vpriv = NULL!?!?!?\n");\r\nreturn;\r\n}\r\nvpriv->old_pop(vcc, skb);\r\nif (vpriv->xoff && atm_may_send(vcc, 0)) {\r\nvpriv->xoff = 0;\r\nif (netif_running(dev) && netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nstatic int lec_vcc_attach(struct atm_vcc *vcc, void __user *arg)\r\n{\r\nstruct lec_vcc_priv *vpriv;\r\nint bytes_left;\r\nstruct atmlec_ioc ioc_data;\r\nbytes_left = copy_from_user(&ioc_data, arg, sizeof(struct atmlec_ioc));\r\nif (bytes_left != 0)\r\npr_info("copy from user failed for %d bytes\n", bytes_left);\r\nif (ioc_data.dev_num < 0 || ioc_data.dev_num >= MAX_LEC_ITF ||\r\n!dev_lec[ioc_data.dev_num])\r\nreturn -EINVAL;\r\nvpriv = kmalloc(sizeof(struct lec_vcc_priv), GFP_KERNEL);\r\nif (!vpriv)\r\nreturn -ENOMEM;\r\nvpriv->xoff = 0;\r\nvpriv->old_pop = vcc->pop;\r\nvcc->user_back = vpriv;\r\nvcc->pop = lec_pop;\r\nlec_vcc_added(netdev_priv(dev_lec[ioc_data.dev_num]),\r\n&ioc_data, vcc, vcc->push);\r\nvcc->proto_data = dev_lec[ioc_data.dev_num];\r\nvcc->push = lec_push;\r\nreturn 0;\r\n}\r\nstatic int lec_mcast_attach(struct atm_vcc *vcc, int arg)\r\n{\r\nif (arg < 0 || arg >= MAX_LEC_ITF || !dev_lec[arg])\r\nreturn -EINVAL;\r\nvcc->proto_data = dev_lec[arg];\r\nreturn lec_mcast_make(netdev_priv(dev_lec[arg]), vcc);\r\n}\r\nstatic int lecd_attach(struct atm_vcc *vcc, int arg)\r\n{\r\nint i;\r\nstruct lec_priv *priv;\r\nif (arg < 0)\r\ni = 0;\r\nelse\r\ni = arg;\r\nif (arg >= MAX_LEC_ITF)\r\nreturn -EINVAL;\r\nif (!dev_lec[i]) {\r\nint size;\r\nsize = sizeof(struct lec_priv);\r\ndev_lec[i] = alloc_etherdev(size);\r\nif (!dev_lec[i])\r\nreturn -ENOMEM;\r\ndev_lec[i]->netdev_ops = &lec_netdev_ops;\r\nsnprintf(dev_lec[i]->name, IFNAMSIZ, "lec%d", i);\r\nif (register_netdev(dev_lec[i])) {\r\nfree_netdev(dev_lec[i]);\r\nreturn -EINVAL;\r\n}\r\npriv = netdev_priv(dev_lec[i]);\r\n} else {\r\npriv = netdev_priv(dev_lec[i]);\r\nif (priv->lecd)\r\nreturn -EADDRINUSE;\r\n}\r\nlec_arp_init(priv);\r\npriv->itfnum = i;\r\npriv->lecd = vcc;\r\nvcc->dev = &lecatm_dev;\r\nvcc_insert_socket(sk_atm(vcc));\r\nvcc->proto_data = dev_lec[i];\r\nset_bit(ATM_VF_META, &vcc->flags);\r\nset_bit(ATM_VF_READY, &vcc->flags);\r\npriv->maximum_unknown_frame_count = 1;\r\npriv->max_unknown_frame_time = (1 * HZ);\r\npriv->vcc_timeout_period = (1200 * HZ);\r\npriv->max_retry_count = 1;\r\npriv->aging_time = (300 * HZ);\r\npriv->forward_delay_time = (15 * HZ);\r\npriv->topology_change = 0;\r\npriv->arp_response_time = (1 * HZ);\r\npriv->flush_timeout = (4 * HZ);\r\npriv->path_switching_delay = (6 * HZ);\r\nif (dev_lec[i]->flags & IFF_UP)\r\nnetif_start_queue(dev_lec[i]);\r\n__module_get(THIS_MODULE);\r\nreturn i;\r\n}\r\nstatic const char *lec_arp_get_status_string(unsigned char status)\r\n{\r\nstatic const char *const lec_arp_status_string[] = {\r\n"ESI_UNKNOWN ",\r\n"ESI_ARP_PENDING ",\r\n"ESI_VC_PENDING ",\r\n"<Undefined> ",\r\n"ESI_FLUSH_PENDING ",\r\n"ESI_FORWARD_DIRECT"\r\n};\r\nif (status > ESI_FORWARD_DIRECT)\r\nstatus = 3;\r\nreturn lec_arp_status_string[status];\r\n}\r\nstatic void lec_info(struct seq_file *seq, struct lec_arp_table *entry)\r\n{\r\nint i;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nseq_printf(seq, "%2.2x", entry->mac_addr[i] & 0xff);\r\nseq_printf(seq, " ");\r\nfor (i = 0; i < ATM_ESA_LEN; i++)\r\nseq_printf(seq, "%2.2x", entry->atm_addr[i] & 0xff);\r\nseq_printf(seq, " %s %4.4x", lec_arp_get_status_string(entry->status),\r\nentry->flags & 0xffff);\r\nif (entry->vcc)\r\nseq_printf(seq, "%3d %3d ", entry->vcc->vpi, entry->vcc->vci);\r\nelse\r\nseq_printf(seq, " ");\r\nif (entry->recv_vcc) {\r\nseq_printf(seq, " %3d %3d", entry->recv_vcc->vpi,\r\nentry->recv_vcc->vci);\r\n}\r\nseq_putc(seq, '\n');\r\n}\r\nstatic void *lec_tbl_walk(struct lec_state *state, struct hlist_head *tbl,\r\nloff_t *l)\r\n{\r\nstruct hlist_node *e = state->node;\r\nstruct lec_arp_table *tmp;\r\nif (!e)\r\ne = tbl->first;\r\nif (e == SEQ_START_TOKEN) {\r\ne = tbl->first;\r\n--*l;\r\n}\r\ntmp = container_of(e, struct lec_arp_table, next);\r\nhlist_for_each_entry_from(tmp, next) {\r\nif (--*l < 0)\r\nbreak;\r\n}\r\nstate->node = e;\r\nreturn (*l < 0) ? state : NULL;\r\n}\r\nstatic void *lec_arp_walk(struct lec_state *state, loff_t *l,\r\nstruct lec_priv *priv)\r\n{\r\nvoid *v = NULL;\r\nint p;\r\nfor (p = state->arp_table; p < LEC_ARP_TABLE_SIZE; p++) {\r\nv = lec_tbl_walk(state, &priv->lec_arp_tables[p], l);\r\nif (v)\r\nbreak;\r\n}\r\nstate->arp_table = p;\r\nreturn v;\r\n}\r\nstatic void *lec_misc_walk(struct lec_state *state, loff_t *l,\r\nstruct lec_priv *priv)\r\n{\r\nstruct hlist_head *lec_misc_tables[] = {\r\n&priv->lec_arp_empty_ones,\r\n&priv->lec_no_forward,\r\n&priv->mcast_fwds\r\n};\r\nvoid *v = NULL;\r\nint q;\r\nfor (q = state->misc_table; q < ARRAY_SIZE(lec_misc_tables); q++) {\r\nv = lec_tbl_walk(state, lec_misc_tables[q], l);\r\nif (v)\r\nbreak;\r\n}\r\nstate->misc_table = q;\r\nreturn v;\r\n}\r\nstatic void *lec_priv_walk(struct lec_state *state, loff_t *l,\r\nstruct lec_priv *priv)\r\n{\r\nif (!state->locked) {\r\nstate->locked = priv;\r\nspin_lock_irqsave(&priv->lec_arp_lock, state->flags);\r\n}\r\nif (!lec_arp_walk(state, l, priv) && !lec_misc_walk(state, l, priv)) {\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, state->flags);\r\nstate->locked = NULL;\r\nstate->arp_table = state->misc_table = 0;\r\n}\r\nreturn state->locked;\r\n}\r\nstatic void *lec_itf_walk(struct lec_state *state, loff_t *l)\r\n{\r\nstruct net_device *dev;\r\nvoid *v;\r\ndev = state->dev ? state->dev : dev_lec[state->itf];\r\nv = (dev && netdev_priv(dev)) ?\r\nlec_priv_walk(state, l, netdev_priv(dev)) : NULL;\r\nif (!v && dev) {\r\ndev_put(dev);\r\ndev = NULL;\r\n}\r\nstate->dev = dev;\r\nreturn v;\r\n}\r\nstatic void *lec_get_idx(struct lec_state *state, loff_t l)\r\n{\r\nvoid *v = NULL;\r\nfor (; state->itf < MAX_LEC_ITF; state->itf++) {\r\nv = lec_itf_walk(state, &l);\r\nif (v)\r\nbreak;\r\n}\r\nreturn v;\r\n}\r\nstatic void *lec_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct lec_state *state = seq->private;\r\nstate->itf = 0;\r\nstate->dev = NULL;\r\nstate->locked = NULL;\r\nstate->arp_table = 0;\r\nstate->misc_table = 0;\r\nstate->node = SEQ_START_TOKEN;\r\nreturn *pos ? lec_get_idx(state, *pos) : SEQ_START_TOKEN;\r\n}\r\nstatic void lec_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nstruct lec_state *state = seq->private;\r\nif (state->dev) {\r\nspin_unlock_irqrestore(&state->locked->lec_arp_lock,\r\nstate->flags);\r\ndev_put(state->dev);\r\n}\r\n}\r\nstatic void *lec_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct lec_state *state = seq->private;\r\nv = lec_get_idx(state, 1);\r\n*pos += !!PTR_ERR(v);\r\nreturn v;\r\n}\r\nstatic int lec_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstatic const char lec_banner[] =\r\n"Itf MAC ATM destination"\r\n" Status Flags "\r\n"VPI/VCI Recv VPI/VCI\n";\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq, lec_banner);\r\nelse {\r\nstruct lec_state *state = seq->private;\r\nstruct net_device *dev = state->dev;\r\nstruct lec_arp_table *entry = hlist_entry(state->node,\r\nstruct lec_arp_table,\r\nnext);\r\nseq_printf(seq, "%s ", dev->name);\r\nlec_info(seq, entry);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lec_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_private(file, &lec_seq_ops, sizeof(struct lec_state));\r\n}\r\nstatic int lane_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct atm_vcc *vcc = ATM_SD(sock);\r\nint err = 0;\r\nswitch (cmd) {\r\ncase ATMLEC_CTRL:\r\ncase ATMLEC_MCAST:\r\ncase ATMLEC_DATA:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nswitch (cmd) {\r\ncase ATMLEC_CTRL:\r\nerr = lecd_attach(vcc, (int)arg);\r\nif (err >= 0)\r\nsock->state = SS_CONNECTED;\r\nbreak;\r\ncase ATMLEC_MCAST:\r\nerr = lec_mcast_attach(vcc, (int)arg);\r\nbreak;\r\ncase ATMLEC_DATA:\r\nerr = lec_vcc_attach(vcc, (void __user *)arg);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int __init lane_module_init(void)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nstruct proc_dir_entry *p;\r\np = proc_create("lec", S_IRUGO, atm_proc_root, &lec_seq_fops);\r\nif (!p) {\r\npr_err("Unable to initialize /proc/net/atm/lec\n");\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nregister_atm_ioctl(&lane_ioctl_ops);\r\npr_info("lec.c: initialized\n");\r\nreturn 0;\r\n}\r\nstatic void __exit lane_module_cleanup(void)\r\n{\r\nint i;\r\nremove_proc_entry("lec", atm_proc_root);\r\nderegister_atm_ioctl(&lane_ioctl_ops);\r\nfor (i = 0; i < MAX_LEC_ITF; i++) {\r\nif (dev_lec[i] != NULL) {\r\nunregister_netdev(dev_lec[i]);\r\nfree_netdev(dev_lec[i]);\r\ndev_lec[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic int lane2_resolve(struct net_device *dev, const u8 *dst_mac, int force,\r\nu8 **tlvs, u32 *sizeoftlvs)\r\n{\r\nunsigned long flags;\r\nstruct lec_priv *priv = netdev_priv(dev);\r\nstruct lec_arp_table *table;\r\nstruct sk_buff *skb;\r\nint retval;\r\nif (force == 0) {\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\ntable = lec_arp_find(priv, dst_mac);\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\nif (table == NULL)\r\nreturn -1;\r\n*tlvs = kmemdup(table->tlvs, table->sizeoftlvs, GFP_ATOMIC);\r\nif (*tlvs == NULL)\r\nreturn -1;\r\n*sizeoftlvs = table->sizeoftlvs;\r\nreturn 0;\r\n}\r\nif (sizeoftlvs == NULL)\r\nretval = send_to_lecd(priv, l_arp_xmt, dst_mac, NULL, NULL);\r\nelse {\r\nskb = alloc_skb(*sizeoftlvs, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -1;\r\nskb->len = *sizeoftlvs;\r\nskb_copy_to_linear_data(skb, *tlvs, *sizeoftlvs);\r\nretval = send_to_lecd(priv, l_arp_xmt, dst_mac, NULL, skb);\r\n}\r\nreturn retval;\r\n}\r\nstatic int lane2_associate_req(struct net_device *dev, const u8 *lan_dst,\r\nconst u8 *tlvs, u32 sizeoftlvs)\r\n{\r\nint retval;\r\nstruct sk_buff *skb;\r\nstruct lec_priv *priv = netdev_priv(dev);\r\nif (!ether_addr_equal(lan_dst, dev->dev_addr))\r\nreturn 0;\r\nkfree(priv->tlvs);\r\npriv->tlvs = kmemdup(tlvs, sizeoftlvs, GFP_KERNEL);\r\nif (priv->tlvs == NULL)\r\nreturn 0;\r\npriv->sizeoftlvs = sizeoftlvs;\r\nskb = alloc_skb(sizeoftlvs, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn 0;\r\nskb->len = sizeoftlvs;\r\nskb_copy_to_linear_data(skb, tlvs, sizeoftlvs);\r\nretval = send_to_lecd(priv, l_associate_req, NULL, NULL, skb);\r\nif (retval != 0)\r\npr_info("lec.c: lane2_associate_req() failed\n");\r\nreturn 1;\r\n}\r\nstatic void lane2_associate_ind(struct net_device *dev, const u8 *mac_addr,\r\nconst u8 *tlvs, u32 sizeoftlvs)\r\n{\r\n#if 0\r\nint i = 0;\r\n#endif\r\nstruct lec_priv *priv = netdev_priv(dev);\r\n#if 0\r\nstruct lec_arp_table *entry = lec_arp_find(priv, mac_addr);\r\nif (entry == NULL)\r\nreturn;\r\nkfree(entry->tlvs);\r\nentry->tlvs = kmemdup(tlvs, sizeoftlvs, GFP_KERNEL);\r\nif (entry->tlvs == NULL)\r\nreturn;\r\nentry->sizeoftlvs = sizeoftlvs;\r\n#endif\r\n#if 0\r\npr_info("\n");\r\npr_info("dump of tlvs, sizeoftlvs=%d\n", sizeoftlvs);\r\nwhile (i < sizeoftlvs)\r\npr_cont("%02x ", tlvs[i++]);\r\npr_cont("\n");\r\n#endif\r\nif (priv->lane2_ops && priv->lane2_ops->associate_indicator) {\r\npriv->lane2_ops->associate_indicator(dev, mac_addr,\r\ntlvs, sizeoftlvs);\r\n}\r\n}\r\nstatic void lec_arp_init(struct lec_priv *priv)\r\n{\r\nunsigned short i;\r\nfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++)\r\nINIT_HLIST_HEAD(&priv->lec_arp_tables[i]);\r\nINIT_HLIST_HEAD(&priv->lec_arp_empty_ones);\r\nINIT_HLIST_HEAD(&priv->lec_no_forward);\r\nINIT_HLIST_HEAD(&priv->mcast_fwds);\r\nspin_lock_init(&priv->lec_arp_lock);\r\nINIT_DELAYED_WORK(&priv->lec_arp_work, lec_arp_check_expire);\r\nschedule_delayed_work(&priv->lec_arp_work, LEC_ARP_REFRESH_INTERVAL);\r\n}\r\nstatic void lec_arp_clear_vccs(struct lec_arp_table *entry)\r\n{\r\nif (entry->vcc) {\r\nstruct atm_vcc *vcc = entry->vcc;\r\nstruct lec_vcc_priv *vpriv = LEC_VCC_PRIV(vcc);\r\nstruct net_device *dev = (struct net_device *)vcc->proto_data;\r\nvcc->pop = vpriv->old_pop;\r\nif (vpriv->xoff)\r\nnetif_wake_queue(dev);\r\nkfree(vpriv);\r\nvcc->user_back = NULL;\r\nvcc->push = entry->old_push;\r\nvcc_release_async(vcc, -EPIPE);\r\nentry->vcc = NULL;\r\n}\r\nif (entry->recv_vcc) {\r\nentry->recv_vcc->push = entry->old_recv_push;\r\nvcc_release_async(entry->recv_vcc, -EPIPE);\r\nentry->recv_vcc = NULL;\r\n}\r\n}\r\nstatic inline void\r\nlec_arp_add(struct lec_priv *priv, struct lec_arp_table *entry)\r\n{\r\nstruct hlist_head *tmp;\r\ntmp = &priv->lec_arp_tables[HASH(entry->mac_addr[ETH_ALEN - 1])];\r\nhlist_add_head(&entry->next, tmp);\r\npr_debug("Added entry:%pM\n", entry->mac_addr);\r\n}\r\nstatic int\r\nlec_arp_remove(struct lec_priv *priv, struct lec_arp_table *to_remove)\r\n{\r\nstruct lec_arp_table *entry;\r\nint i, remove_vcc = 1;\r\nif (!to_remove)\r\nreturn -1;\r\nhlist_del(&to_remove->next);\r\ndel_timer(&to_remove->timer);\r\nif (to_remove->status >= ESI_FLUSH_PENDING) {\r\nfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\r\nhlist_for_each_entry(entry,\r\n&priv->lec_arp_tables[i], next) {\r\nif (memcmp(to_remove->atm_addr,\r\nentry->atm_addr, ATM_ESA_LEN) == 0) {\r\nremove_vcc = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (remove_vcc)\r\nlec_arp_clear_vccs(to_remove);\r\n}\r\nskb_queue_purge(&to_remove->tx_wait);\r\npr_debug("Removed entry:%pM\n", to_remove->mac_addr);\r\nreturn 0;\r\n}\r\nstatic const char *get_status_string(unsigned char st)\r\n{\r\nswitch (st) {\r\ncase ESI_UNKNOWN:\r\nreturn "ESI_UNKNOWN";\r\ncase ESI_ARP_PENDING:\r\nreturn "ESI_ARP_PENDING";\r\ncase ESI_VC_PENDING:\r\nreturn "ESI_VC_PENDING";\r\ncase ESI_FLUSH_PENDING:\r\nreturn "ESI_FLUSH_PENDING";\r\ncase ESI_FORWARD_DIRECT:\r\nreturn "ESI_FORWARD_DIRECT";\r\n}\r\nreturn "<UNKNOWN>";\r\n}\r\nstatic void dump_arp_table(struct lec_priv *priv)\r\n{\r\nstruct lec_arp_table *rulla;\r\nchar buf[256];\r\nint i, j, offset;\r\npr_info("Dump %p:\n", priv);\r\nfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\r\nhlist_for_each_entry(rulla,\r\n&priv->lec_arp_tables[i], next) {\r\noffset = 0;\r\noffset += sprintf(buf, "%d: %p\n", i, rulla);\r\noffset += sprintf(buf + offset, "Mac: %pM",\r\nrulla->mac_addr);\r\noffset += sprintf(buf + offset, " Atm:");\r\nfor (j = 0; j < ATM_ESA_LEN; j++) {\r\noffset += sprintf(buf + offset,\r\n"%2.2x ",\r\nrulla->atm_addr[j] & 0xff);\r\n}\r\noffset += sprintf(buf + offset,\r\n"Vcc vpi:%d vci:%d, Recv_vcc vpi:%d vci:%d Last_used:%lx, Timestamp:%lx, No_tries:%d ",\r\nrulla->vcc ? rulla->vcc->vpi : 0,\r\nrulla->vcc ? rulla->vcc->vci : 0,\r\nrulla->recv_vcc ? rulla->recv_vcc->\r\nvpi : 0,\r\nrulla->recv_vcc ? rulla->recv_vcc->\r\nvci : 0, rulla->last_used,\r\nrulla->timestamp, rulla->no_tries);\r\noffset +=\r\nsprintf(buf + offset,\r\n"Flags:%x, Packets_flooded:%x, Status: %s ",\r\nrulla->flags, rulla->packets_flooded,\r\nget_status_string(rulla->status));\r\npr_info("%s\n", buf);\r\n}\r\n}\r\nif (!hlist_empty(&priv->lec_no_forward))\r\npr_info("No forward\n");\r\nhlist_for_each_entry(rulla, &priv->lec_no_forward, next) {\r\noffset = 0;\r\noffset += sprintf(buf + offset, "Mac: %pM", rulla->mac_addr);\r\noffset += sprintf(buf + offset, " Atm:");\r\nfor (j = 0; j < ATM_ESA_LEN; j++) {\r\noffset += sprintf(buf + offset, "%2.2x ",\r\nrulla->atm_addr[j] & 0xff);\r\n}\r\noffset += sprintf(buf + offset,\r\n"Vcc vpi:%d vci:%d, Recv_vcc vpi:%d vci:%d Last_used:%lx, Timestamp:%lx, No_tries:%d ",\r\nrulla->vcc ? rulla->vcc->vpi : 0,\r\nrulla->vcc ? rulla->vcc->vci : 0,\r\nrulla->recv_vcc ? rulla->recv_vcc->vpi : 0,\r\nrulla->recv_vcc ? rulla->recv_vcc->vci : 0,\r\nrulla->last_used,\r\nrulla->timestamp, rulla->no_tries);\r\noffset += sprintf(buf + offset,\r\n"Flags:%x, Packets_flooded:%x, Status: %s ",\r\nrulla->flags, rulla->packets_flooded,\r\nget_status_string(rulla->status));\r\npr_info("%s\n", buf);\r\n}\r\nif (!hlist_empty(&priv->lec_arp_empty_ones))\r\npr_info("Empty ones\n");\r\nhlist_for_each_entry(rulla, &priv->lec_arp_empty_ones, next) {\r\noffset = 0;\r\noffset += sprintf(buf + offset, "Mac: %pM", rulla->mac_addr);\r\noffset += sprintf(buf + offset, " Atm:");\r\nfor (j = 0; j < ATM_ESA_LEN; j++) {\r\noffset += sprintf(buf + offset, "%2.2x ",\r\nrulla->atm_addr[j] & 0xff);\r\n}\r\noffset += sprintf(buf + offset,\r\n"Vcc vpi:%d vci:%d, Recv_vcc vpi:%d vci:%d Last_used:%lx, Timestamp:%lx, No_tries:%d ",\r\nrulla->vcc ? rulla->vcc->vpi : 0,\r\nrulla->vcc ? rulla->vcc->vci : 0,\r\nrulla->recv_vcc ? rulla->recv_vcc->vpi : 0,\r\nrulla->recv_vcc ? rulla->recv_vcc->vci : 0,\r\nrulla->last_used,\r\nrulla->timestamp, rulla->no_tries);\r\noffset += sprintf(buf + offset,\r\n"Flags:%x, Packets_flooded:%x, Status: %s ",\r\nrulla->flags, rulla->packets_flooded,\r\nget_status_string(rulla->status));\r\npr_info("%s", buf);\r\n}\r\nif (!hlist_empty(&priv->mcast_fwds))\r\npr_info("Multicast Forward VCCs\n");\r\nhlist_for_each_entry(rulla, &priv->mcast_fwds, next) {\r\noffset = 0;\r\noffset += sprintf(buf + offset, "Mac: %pM", rulla->mac_addr);\r\noffset += sprintf(buf + offset, " Atm:");\r\nfor (j = 0; j < ATM_ESA_LEN; j++) {\r\noffset += sprintf(buf + offset, "%2.2x ",\r\nrulla->atm_addr[j] & 0xff);\r\n}\r\noffset += sprintf(buf + offset,\r\n"Vcc vpi:%d vci:%d, Recv_vcc vpi:%d vci:%d Last_used:%lx, Timestamp:%lx, No_tries:%d ",\r\nrulla->vcc ? rulla->vcc->vpi : 0,\r\nrulla->vcc ? rulla->vcc->vci : 0,\r\nrulla->recv_vcc ? rulla->recv_vcc->vpi : 0,\r\nrulla->recv_vcc ? rulla->recv_vcc->vci : 0,\r\nrulla->last_used,\r\nrulla->timestamp, rulla->no_tries);\r\noffset += sprintf(buf + offset,\r\n"Flags:%x, Packets_flooded:%x, Status: %s ",\r\nrulla->flags, rulla->packets_flooded,\r\nget_status_string(rulla->status));\r\npr_info("%s\n", buf);\r\n}\r\n}\r\nstatic void lec_arp_destroy(struct lec_priv *priv)\r\n{\r\nunsigned long flags;\r\nstruct hlist_node *next;\r\nstruct lec_arp_table *entry;\r\nint i;\r\ncancel_delayed_work_sync(&priv->lec_arp_work);\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\r\nhlist_for_each_entry_safe(entry, next,\r\n&priv->lec_arp_tables[i], next) {\r\nlec_arp_remove(priv, entry);\r\nlec_arp_put(entry);\r\n}\r\nINIT_HLIST_HEAD(&priv->lec_arp_tables[i]);\r\n}\r\nhlist_for_each_entry_safe(entry, next,\r\n&priv->lec_arp_empty_ones, next) {\r\ndel_timer_sync(&entry->timer);\r\nlec_arp_clear_vccs(entry);\r\nhlist_del(&entry->next);\r\nlec_arp_put(entry);\r\n}\r\nINIT_HLIST_HEAD(&priv->lec_arp_empty_ones);\r\nhlist_for_each_entry_safe(entry, next,\r\n&priv->lec_no_forward, next) {\r\ndel_timer_sync(&entry->timer);\r\nlec_arp_clear_vccs(entry);\r\nhlist_del(&entry->next);\r\nlec_arp_put(entry);\r\n}\r\nINIT_HLIST_HEAD(&priv->lec_no_forward);\r\nhlist_for_each_entry_safe(entry, next, &priv->mcast_fwds, next) {\r\nlec_arp_clear_vccs(entry);\r\nhlist_del(&entry->next);\r\nlec_arp_put(entry);\r\n}\r\nINIT_HLIST_HEAD(&priv->mcast_fwds);\r\npriv->mcast_vcc = NULL;\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\n}\r\nstatic struct lec_arp_table *lec_arp_find(struct lec_priv *priv,\r\nconst unsigned char *mac_addr)\r\n{\r\nstruct hlist_head *head;\r\nstruct lec_arp_table *entry;\r\npr_debug("%pM\n", mac_addr);\r\nhead = &priv->lec_arp_tables[HASH(mac_addr[ETH_ALEN - 1])];\r\nhlist_for_each_entry(entry, head, next) {\r\nif (ether_addr_equal(mac_addr, entry->mac_addr))\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct lec_arp_table *make_entry(struct lec_priv *priv,\r\nconst unsigned char *mac_addr)\r\n{\r\nstruct lec_arp_table *to_return;\r\nto_return = kzalloc(sizeof(struct lec_arp_table), GFP_ATOMIC);\r\nif (!to_return) {\r\npr_info("LEC: Arp entry kmalloc failed\n");\r\nreturn NULL;\r\n}\r\nether_addr_copy(to_return->mac_addr, mac_addr);\r\nINIT_HLIST_NODE(&to_return->next);\r\nsetup_timer(&to_return->timer, lec_arp_expire_arp,\r\n(unsigned long)to_return);\r\nto_return->last_used = jiffies;\r\nto_return->priv = priv;\r\nskb_queue_head_init(&to_return->tx_wait);\r\natomic_set(&to_return->usage, 1);\r\nreturn to_return;\r\n}\r\nstatic void lec_arp_expire_arp(unsigned long data)\r\n{\r\nstruct lec_arp_table *entry;\r\nentry = (struct lec_arp_table *)data;\r\npr_debug("\n");\r\nif (entry->status == ESI_ARP_PENDING) {\r\nif (entry->no_tries <= entry->priv->max_retry_count) {\r\nif (entry->is_rdesc)\r\nsend_to_lecd(entry->priv, l_rdesc_arp_xmt,\r\nentry->mac_addr, NULL, NULL);\r\nelse\r\nsend_to_lecd(entry->priv, l_arp_xmt,\r\nentry->mac_addr, NULL, NULL);\r\nentry->no_tries++;\r\n}\r\nmod_timer(&entry->timer, jiffies + (1 * HZ));\r\n}\r\n}\r\nstatic void lec_arp_expire_vcc(unsigned long data)\r\n{\r\nunsigned long flags;\r\nstruct lec_arp_table *to_remove = (struct lec_arp_table *)data;\r\nstruct lec_priv *priv = to_remove->priv;\r\ndel_timer(&to_remove->timer);\r\npr_debug("%p %p: vpi:%d vci:%d\n",\r\nto_remove, priv,\r\nto_remove->vcc ? to_remove->recv_vcc->vpi : 0,\r\nto_remove->vcc ? to_remove->recv_vcc->vci : 0);\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nhlist_del(&to_remove->next);\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\nlec_arp_clear_vccs(to_remove);\r\nlec_arp_put(to_remove);\r\n}\r\nstatic bool __lec_arp_check_expire(struct lec_arp_table *entry,\r\nunsigned long now,\r\nstruct lec_priv *priv)\r\n{\r\nunsigned long time_to_check;\r\nif ((entry->flags) & LEC_REMOTE_FLAG && priv->topology_change)\r\ntime_to_check = priv->forward_delay_time;\r\nelse\r\ntime_to_check = priv->aging_time;\r\npr_debug("About to expire: %lx - %lx > %lx\n",\r\nnow, entry->last_used, time_to_check);\r\nif (time_after(now, entry->last_used + time_to_check) &&\r\n!(entry->flags & LEC_PERMANENT_FLAG) &&\r\n!(entry->mac_addr[0] & 0x01)) {\r\npr_debug("Entry timed out\n");\r\nlec_arp_remove(priv, entry);\r\nlec_arp_put(entry);\r\n} else {\r\nif ((entry->status == ESI_VC_PENDING ||\r\nentry->status == ESI_ARP_PENDING) &&\r\ntime_after_eq(now, entry->timestamp +\r\npriv->max_unknown_frame_time)) {\r\nentry->timestamp = jiffies;\r\nentry->packets_flooded = 0;\r\nif (entry->status == ESI_VC_PENDING)\r\nsend_to_lecd(priv, l_svc_setup,\r\nentry->mac_addr,\r\nentry->atm_addr,\r\nNULL);\r\n}\r\nif (entry->status == ESI_FLUSH_PENDING &&\r\ntime_after_eq(now, entry->timestamp +\r\npriv->path_switching_delay)) {\r\nlec_arp_hold(entry);\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic void lec_arp_check_expire(struct work_struct *work)\r\n{\r\nunsigned long flags;\r\nstruct lec_priv *priv =\r\ncontainer_of(work, struct lec_priv, lec_arp_work.work);\r\nstruct hlist_node *next;\r\nstruct lec_arp_table *entry;\r\nunsigned long now;\r\nint i;\r\npr_debug("%p\n", priv);\r\nnow = jiffies;\r\nrestart:\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\r\nhlist_for_each_entry_safe(entry, next,\r\n&priv->lec_arp_tables[i], next) {\r\nif (__lec_arp_check_expire(entry, now, priv)) {\r\nstruct sk_buff *skb;\r\nstruct atm_vcc *vcc = entry->vcc;\r\nspin_unlock_irqrestore(&priv->lec_arp_lock,\r\nflags);\r\nwhile ((skb = skb_dequeue(&entry->tx_wait)))\r\nlec_send(vcc, skb);\r\nentry->last_used = jiffies;\r\nentry->status = ESI_FORWARD_DIRECT;\r\nlec_arp_put(entry);\r\ngoto restart;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\nschedule_delayed_work(&priv->lec_arp_work, LEC_ARP_REFRESH_INTERVAL);\r\n}\r\nstatic struct atm_vcc *lec_arp_resolve(struct lec_priv *priv,\r\nconst unsigned char *mac_to_find,\r\nint is_rdesc,\r\nstruct lec_arp_table **ret_entry)\r\n{\r\nunsigned long flags;\r\nstruct lec_arp_table *entry;\r\nstruct atm_vcc *found;\r\nif (mac_to_find[0] & 0x01) {\r\nswitch (priv->lane_version) {\r\ncase 1:\r\nreturn priv->mcast_vcc;\r\ncase 2:\r\nif (ether_addr_equal(mac_to_find, bus_mac))\r\nreturn priv->mcast_vcc;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nentry = lec_arp_find(priv, mac_to_find);\r\nif (entry) {\r\nif (entry->status == ESI_FORWARD_DIRECT) {\r\nentry->last_used = jiffies;\r\nlec_arp_hold(entry);\r\n*ret_entry = entry;\r\nfound = entry->vcc;\r\ngoto out;\r\n}\r\nif (entry->status == ESI_ARP_PENDING)\r\nentry->no_tries = 0;\r\nif (entry->status != ESI_FLUSH_PENDING &&\r\nentry->packets_flooded <\r\npriv->maximum_unknown_frame_count) {\r\nentry->packets_flooded++;\r\npr_debug("Flooding..\n");\r\nfound = priv->mcast_vcc;\r\ngoto out;\r\n}\r\nlec_arp_hold(entry);\r\n*ret_entry = entry;\r\npr_debug("entry->status %d entry->vcc %p\n", entry->status,\r\nentry->vcc);\r\nfound = NULL;\r\n} else {\r\nentry = make_entry(priv, mac_to_find);\r\npr_debug("Making entry\n");\r\nif (!entry) {\r\nfound = priv->mcast_vcc;\r\ngoto out;\r\n}\r\nlec_arp_add(priv, entry);\r\nentry->packets_flooded = 1;\r\nentry->status = ESI_ARP_PENDING;\r\nentry->no_tries = 1;\r\nentry->last_used = entry->timestamp = jiffies;\r\nentry->is_rdesc = is_rdesc;\r\nif (entry->is_rdesc)\r\nsend_to_lecd(priv, l_rdesc_arp_xmt, mac_to_find, NULL,\r\nNULL);\r\nelse\r\nsend_to_lecd(priv, l_arp_xmt, mac_to_find, NULL, NULL);\r\nentry->timer.expires = jiffies + (1 * HZ);\r\nentry->timer.function = lec_arp_expire_arp;\r\nadd_timer(&entry->timer);\r\nfound = priv->mcast_vcc;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\nreturn found;\r\n}\r\nstatic int\r\nlec_addr_delete(struct lec_priv *priv, const unsigned char *atm_addr,\r\nunsigned long permanent)\r\n{\r\nunsigned long flags;\r\nstruct hlist_node *next;\r\nstruct lec_arp_table *entry;\r\nint i;\r\npr_debug("\n");\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\r\nhlist_for_each_entry_safe(entry, next,\r\n&priv->lec_arp_tables[i], next) {\r\nif (!memcmp(atm_addr, entry->atm_addr, ATM_ESA_LEN) &&\r\n(permanent ||\r\n!(entry->flags & LEC_PERMANENT_FLAG))) {\r\nlec_arp_remove(priv, entry);\r\nlec_arp_put(entry);\r\n}\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\nreturn -1;\r\n}\r\nstatic void\r\nlec_arp_update(struct lec_priv *priv, const unsigned char *mac_addr,\r\nconst unsigned char *atm_addr, unsigned long remoteflag,\r\nunsigned int targetless_le_arp)\r\n{\r\nunsigned long flags;\r\nstruct hlist_node *next;\r\nstruct lec_arp_table *entry, *tmp;\r\nint i;\r\npr_debug("%smac:%pM\n",\r\n(targetless_le_arp) ? "targetless " : "", mac_addr);\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nentry = lec_arp_find(priv, mac_addr);\r\nif (entry == NULL && targetless_le_arp)\r\ngoto out;\r\nif (!hlist_empty(&priv->lec_arp_empty_ones)) {\r\nhlist_for_each_entry_safe(entry, next,\r\n&priv->lec_arp_empty_ones, next) {\r\nif (memcmp(entry->atm_addr, atm_addr, ATM_ESA_LEN) == 0) {\r\nhlist_del(&entry->next);\r\ndel_timer(&entry->timer);\r\ntmp = lec_arp_find(priv, mac_addr);\r\nif (tmp) {\r\ndel_timer(&tmp->timer);\r\ntmp->status = ESI_FORWARD_DIRECT;\r\nmemcpy(tmp->atm_addr, atm_addr, ATM_ESA_LEN);\r\ntmp->vcc = entry->vcc;\r\ntmp->old_push = entry->old_push;\r\ntmp->last_used = jiffies;\r\ndel_timer(&entry->timer);\r\nlec_arp_put(entry);\r\nentry = tmp;\r\n} else {\r\nentry->status = ESI_FORWARD_DIRECT;\r\nether_addr_copy(entry->mac_addr,\r\nmac_addr);\r\nentry->last_used = jiffies;\r\nlec_arp_add(priv, entry);\r\n}\r\nif (remoteflag)\r\nentry->flags |= LEC_REMOTE_FLAG;\r\nelse\r\nentry->flags &= ~LEC_REMOTE_FLAG;\r\npr_debug("After update\n");\r\ndump_arp_table(priv);\r\ngoto out;\r\n}\r\n}\r\n}\r\nentry = lec_arp_find(priv, mac_addr);\r\nif (!entry) {\r\nentry = make_entry(priv, mac_addr);\r\nif (!entry)\r\ngoto out;\r\nentry->status = ESI_UNKNOWN;\r\nlec_arp_add(priv, entry);\r\n}\r\nmemcpy(entry->atm_addr, atm_addr, ATM_ESA_LEN);\r\ndel_timer(&entry->timer);\r\nfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\r\nhlist_for_each_entry(tmp,\r\n&priv->lec_arp_tables[i], next) {\r\nif (entry != tmp &&\r\n!memcmp(tmp->atm_addr, atm_addr, ATM_ESA_LEN)) {\r\nif (tmp->status > ESI_VC_PENDING) {\r\nentry->vcc = tmp->vcc;\r\nentry->old_push = tmp->old_push;\r\n}\r\nentry->status = tmp->status;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (remoteflag)\r\nentry->flags |= LEC_REMOTE_FLAG;\r\nelse\r\nentry->flags &= ~LEC_REMOTE_FLAG;\r\nif (entry->status == ESI_ARP_PENDING || entry->status == ESI_UNKNOWN) {\r\nentry->status = ESI_VC_PENDING;\r\nsend_to_lecd(priv, l_svc_setup, entry->mac_addr, atm_addr, NULL);\r\n}\r\npr_debug("After update2\n");\r\ndump_arp_table(priv);\r\nout:\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\n}\r\nstatic void\r\nlec_vcc_added(struct lec_priv *priv, const struct atmlec_ioc *ioc_data,\r\nstruct atm_vcc *vcc,\r\nvoid (*old_push) (struct atm_vcc *vcc, struct sk_buff *skb))\r\n{\r\nunsigned long flags;\r\nstruct lec_arp_table *entry;\r\nint i, found_entry = 0;\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nif (ioc_data->receive == 2) {\r\npr_debug("LEC_ARP: Attaching mcast forward\n");\r\n#if 0\r\nentry = lec_arp_find(priv, bus_mac);\r\nif (!entry) {\r\npr_info("LEC_ARP: Multicast entry not found!\n");\r\ngoto out;\r\n}\r\nmemcpy(entry->atm_addr, ioc_data->atm_addr, ATM_ESA_LEN);\r\nentry->recv_vcc = vcc;\r\nentry->old_recv_push = old_push;\r\n#endif\r\nentry = make_entry(priv, bus_mac);\r\nif (entry == NULL)\r\ngoto out;\r\ndel_timer(&entry->timer);\r\nmemcpy(entry->atm_addr, ioc_data->atm_addr, ATM_ESA_LEN);\r\nentry->recv_vcc = vcc;\r\nentry->old_recv_push = old_push;\r\nhlist_add_head(&entry->next, &priv->mcast_fwds);\r\ngoto out;\r\n} else if (ioc_data->receive == 1) {\r\npr_debug("LEC_ARP:Attaching data direct, not default: %2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\n",\r\nioc_data->atm_addr[0], ioc_data->atm_addr[1],\r\nioc_data->atm_addr[2], ioc_data->atm_addr[3],\r\nioc_data->atm_addr[4], ioc_data->atm_addr[5],\r\nioc_data->atm_addr[6], ioc_data->atm_addr[7],\r\nioc_data->atm_addr[8], ioc_data->atm_addr[9],\r\nioc_data->atm_addr[10], ioc_data->atm_addr[11],\r\nioc_data->atm_addr[12], ioc_data->atm_addr[13],\r\nioc_data->atm_addr[14], ioc_data->atm_addr[15],\r\nioc_data->atm_addr[16], ioc_data->atm_addr[17],\r\nioc_data->atm_addr[18], ioc_data->atm_addr[19]);\r\nentry = make_entry(priv, bus_mac);\r\nif (entry == NULL)\r\ngoto out;\r\nmemcpy(entry->atm_addr, ioc_data->atm_addr, ATM_ESA_LEN);\r\nmemset(entry->mac_addr, 0, ETH_ALEN);\r\nentry->recv_vcc = vcc;\r\nentry->old_recv_push = old_push;\r\nentry->status = ESI_UNKNOWN;\r\nentry->timer.expires = jiffies + priv->vcc_timeout_period;\r\nentry->timer.function = lec_arp_expire_vcc;\r\nhlist_add_head(&entry->next, &priv->lec_no_forward);\r\nadd_timer(&entry->timer);\r\ndump_arp_table(priv);\r\ngoto out;\r\n}\r\npr_debug("LEC_ARP:Attaching data direct, default: %2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\n",\r\nioc_data->atm_addr[0], ioc_data->atm_addr[1],\r\nioc_data->atm_addr[2], ioc_data->atm_addr[3],\r\nioc_data->atm_addr[4], ioc_data->atm_addr[5],\r\nioc_data->atm_addr[6], ioc_data->atm_addr[7],\r\nioc_data->atm_addr[8], ioc_data->atm_addr[9],\r\nioc_data->atm_addr[10], ioc_data->atm_addr[11],\r\nioc_data->atm_addr[12], ioc_data->atm_addr[13],\r\nioc_data->atm_addr[14], ioc_data->atm_addr[15],\r\nioc_data->atm_addr[16], ioc_data->atm_addr[17],\r\nioc_data->atm_addr[18], ioc_data->atm_addr[19]);\r\nfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\r\nhlist_for_each_entry(entry,\r\n&priv->lec_arp_tables[i], next) {\r\nif (memcmp\r\n(ioc_data->atm_addr, entry->atm_addr,\r\nATM_ESA_LEN) == 0) {\r\npr_debug("LEC_ARP: Attaching data direct\n");\r\npr_debug("Currently -> Vcc: %d, Rvcc:%d\n",\r\nentry->vcc ? entry->vcc->vci : 0,\r\nentry->recv_vcc ? entry->recv_vcc->\r\nvci : 0);\r\nfound_entry = 1;\r\ndel_timer(&entry->timer);\r\nentry->vcc = vcc;\r\nentry->old_push = old_push;\r\nif (entry->status == ESI_VC_PENDING) {\r\nif (priv->maximum_unknown_frame_count\r\n== 0)\r\nentry->status =\r\nESI_FORWARD_DIRECT;\r\nelse {\r\nentry->timestamp = jiffies;\r\nentry->status =\r\nESI_FLUSH_PENDING;\r\n#if 0\r\nsend_to_lecd(priv, l_flush_xmt,\r\nNULL,\r\nentry->atm_addr,\r\nNULL);\r\n#endif\r\n}\r\n} else {\r\n;\r\n}\r\n}\r\n}\r\n}\r\nif (found_entry) {\r\npr_debug("After vcc was added\n");\r\ndump_arp_table(priv);\r\ngoto out;\r\n}\r\nentry = make_entry(priv, bus_mac);\r\nif (!entry)\r\ngoto out;\r\nentry->vcc = vcc;\r\nentry->old_push = old_push;\r\nmemcpy(entry->atm_addr, ioc_data->atm_addr, ATM_ESA_LEN);\r\nmemset(entry->mac_addr, 0, ETH_ALEN);\r\nentry->status = ESI_UNKNOWN;\r\nhlist_add_head(&entry->next, &priv->lec_arp_empty_ones);\r\nentry->timer.expires = jiffies + priv->vcc_timeout_period;\r\nentry->timer.function = lec_arp_expire_vcc;\r\nadd_timer(&entry->timer);\r\npr_debug("After vcc was added\n");\r\ndump_arp_table(priv);\r\nout:\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\n}\r\nstatic void lec_flush_complete(struct lec_priv *priv, unsigned long tran_id)\r\n{\r\nunsigned long flags;\r\nstruct lec_arp_table *entry;\r\nint i;\r\npr_debug("%lx\n", tran_id);\r\nrestart:\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\r\nhlist_for_each_entry(entry,\r\n&priv->lec_arp_tables[i], next) {\r\nif (entry->flush_tran_id == tran_id &&\r\nentry->status == ESI_FLUSH_PENDING) {\r\nstruct sk_buff *skb;\r\nstruct atm_vcc *vcc = entry->vcc;\r\nlec_arp_hold(entry);\r\nspin_unlock_irqrestore(&priv->lec_arp_lock,\r\nflags);\r\nwhile ((skb = skb_dequeue(&entry->tx_wait)))\r\nlec_send(vcc, skb);\r\nentry->last_used = jiffies;\r\nentry->status = ESI_FORWARD_DIRECT;\r\nlec_arp_put(entry);\r\npr_debug("LEC_ARP: Flushed\n");\r\ngoto restart;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\ndump_arp_table(priv);\r\n}\r\nstatic void\r\nlec_set_flush_tran_id(struct lec_priv *priv,\r\nconst unsigned char *atm_addr, unsigned long tran_id)\r\n{\r\nunsigned long flags;\r\nstruct lec_arp_table *entry;\r\nint i;\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++)\r\nhlist_for_each_entry(entry,\r\n&priv->lec_arp_tables[i], next) {\r\nif (!memcmp(atm_addr, entry->atm_addr, ATM_ESA_LEN)) {\r\nentry->flush_tran_id = tran_id;\r\npr_debug("Set flush transaction id to %lx for %p\n",\r\ntran_id, entry);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\n}\r\nstatic int lec_mcast_make(struct lec_priv *priv, struct atm_vcc *vcc)\r\n{\r\nunsigned long flags;\r\nunsigned char mac_addr[] = {\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff\r\n};\r\nstruct lec_arp_table *to_add;\r\nstruct lec_vcc_priv *vpriv;\r\nint err = 0;\r\nvpriv = kmalloc(sizeof(struct lec_vcc_priv), GFP_KERNEL);\r\nif (!vpriv)\r\nreturn -ENOMEM;\r\nvpriv->xoff = 0;\r\nvpriv->old_pop = vcc->pop;\r\nvcc->user_back = vpriv;\r\nvcc->pop = lec_pop;\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nto_add = make_entry(priv, mac_addr);\r\nif (!to_add) {\r\nvcc->pop = vpriv->old_pop;\r\nkfree(vpriv);\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(to_add->atm_addr, vcc->remote.sas_addr.prv, ATM_ESA_LEN);\r\nto_add->status = ESI_FORWARD_DIRECT;\r\nto_add->flags |= LEC_PERMANENT_FLAG;\r\nto_add->vcc = vcc;\r\nto_add->old_push = vcc->push;\r\nvcc->push = lec_push;\r\npriv->mcast_vcc = vcc;\r\nlec_arp_add(priv, to_add);\r\nout:\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\nreturn err;\r\n}\r\nstatic void lec_vcc_close(struct lec_priv *priv, struct atm_vcc *vcc)\r\n{\r\nunsigned long flags;\r\nstruct hlist_node *next;\r\nstruct lec_arp_table *entry;\r\nint i;\r\npr_debug("LEC_ARP: lec_vcc_close vpi:%d vci:%d\n", vcc->vpi, vcc->vci);\r\ndump_arp_table(priv);\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nfor (i = 0; i < LEC_ARP_TABLE_SIZE; i++) {\r\nhlist_for_each_entry_safe(entry, next,\r\n&priv->lec_arp_tables[i], next) {\r\nif (vcc == entry->vcc) {\r\nlec_arp_remove(priv, entry);\r\nlec_arp_put(entry);\r\nif (priv->mcast_vcc == vcc)\r\npriv->mcast_vcc = NULL;\r\n}\r\n}\r\n}\r\nhlist_for_each_entry_safe(entry, next,\r\n&priv->lec_arp_empty_ones, next) {\r\nif (entry->vcc == vcc) {\r\nlec_arp_clear_vccs(entry);\r\ndel_timer(&entry->timer);\r\nhlist_del(&entry->next);\r\nlec_arp_put(entry);\r\n}\r\n}\r\nhlist_for_each_entry_safe(entry, next,\r\n&priv->lec_no_forward, next) {\r\nif (entry->recv_vcc == vcc) {\r\nlec_arp_clear_vccs(entry);\r\ndel_timer(&entry->timer);\r\nhlist_del(&entry->next);\r\nlec_arp_put(entry);\r\n}\r\n}\r\nhlist_for_each_entry_safe(entry, next, &priv->mcast_fwds, next) {\r\nif (entry->recv_vcc == vcc) {\r\nlec_arp_clear_vccs(entry);\r\nhlist_del(&entry->next);\r\nlec_arp_put(entry);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\ndump_arp_table(priv);\r\n}\r\nstatic void\r\nlec_arp_check_empties(struct lec_priv *priv,\r\nstruct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nunsigned long flags;\r\nstruct hlist_node *next;\r\nstruct lec_arp_table *entry, *tmp;\r\nstruct lecdatahdr_8023 *hdr = (struct lecdatahdr_8023 *)skb->data;\r\nunsigned char *src = hdr->h_source;\r\nspin_lock_irqsave(&priv->lec_arp_lock, flags);\r\nhlist_for_each_entry_safe(entry, next,\r\n&priv->lec_arp_empty_ones, next) {\r\nif (vcc == entry->vcc) {\r\ndel_timer(&entry->timer);\r\nether_addr_copy(entry->mac_addr, src);\r\nentry->status = ESI_FORWARD_DIRECT;\r\nentry->last_used = jiffies;\r\ntmp = lec_arp_find(priv, src);\r\nif (tmp) {\r\nlec_arp_remove(priv, tmp);\r\nlec_arp_put(tmp);\r\n}\r\nhlist_del(&entry->next);\r\nlec_arp_add(priv, entry);\r\ngoto out;\r\n}\r\n}\r\npr_debug("LEC_ARP: Arp_check_empties: entry not found!\n");\r\nout:\r\nspin_unlock_irqrestore(&priv->lec_arp_lock, flags);\r\n}
