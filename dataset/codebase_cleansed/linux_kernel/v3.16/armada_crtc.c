void\r\narmada_drm_crtc_update_regs(struct armada_crtc *dcrtc, struct armada_regs *regs)\r\n{\r\nwhile (regs->offset != ~0) {\r\nvoid __iomem *reg = dcrtc->base + regs->offset;\r\nuint32_t val;\r\nval = regs->mask;\r\nif (val != 0)\r\nval &= readl_relaxed(reg);\r\nwritel_relaxed(val | regs->val, reg);\r\n++regs;\r\n}\r\n}\r\nstatic void armada_drm_crtc_update(struct armada_crtc *dcrtc)\r\n{\r\nuint32_t dumb_ctrl;\r\ndumb_ctrl = dcrtc->cfg_dumb_ctrl;\r\nif (!dpms_blanked(dcrtc->dpms))\r\ndumb_ctrl |= CFG_DUMB_ENA;\r\nif (dpms_blanked(dcrtc->dpms) &&\r\n(dumb_ctrl & DUMB_MASK) == DUMB24_RGB888_0) {\r\ndumb_ctrl &= ~DUMB_MASK;\r\ndumb_ctrl |= DUMB_BLANK;\r\n}\r\nif (dcrtc->crtc.mode.flags & DRM_MODE_FLAG_NCSYNC)\r\ndumb_ctrl |= CFG_INV_CSYNC;\r\nif (dcrtc->crtc.mode.flags & DRM_MODE_FLAG_NHSYNC)\r\ndumb_ctrl |= CFG_INV_HSYNC;\r\nif (dcrtc->crtc.mode.flags & DRM_MODE_FLAG_NVSYNC)\r\ndumb_ctrl |= CFG_INV_VSYNC;\r\nif (dcrtc->dumb_ctrl != dumb_ctrl) {\r\ndcrtc->dumb_ctrl = dumb_ctrl;\r\nwritel_relaxed(dumb_ctrl, dcrtc->base + LCD_SPU_DUMB_CTRL);\r\n}\r\n}\r\nstatic unsigned armada_drm_crtc_calc_fb(struct drm_framebuffer *fb,\r\nint x, int y, struct armada_regs *regs, bool interlaced)\r\n{\r\nstruct armada_gem_object *obj = drm_fb_obj(fb);\r\nunsigned pitch = fb->pitches[0];\r\nunsigned offset = y * pitch + x * fb->bits_per_pixel / 8;\r\nuint32_t addr_odd, addr_even;\r\nunsigned i = 0;\r\nDRM_DEBUG_DRIVER("pitch %u x %d y %d bpp %d\n",\r\npitch, x, y, fb->bits_per_pixel);\r\naddr_odd = addr_even = obj->dev_addr + offset;\r\nif (interlaced) {\r\naddr_even += pitch;\r\npitch *= 2;\r\n}\r\narmada_reg_queue_set(regs, i, addr_odd, LCD_CFG_GRA_START_ADDR0);\r\narmada_reg_queue_set(regs, i, addr_even, LCD_CFG_GRA_START_ADDR1);\r\narmada_reg_queue_mod(regs, i, pitch, 0xffff, LCD_CFG_GRA_PITCH);\r\nreturn i;\r\n}\r\nstatic int armada_drm_crtc_queue_frame_work(struct armada_crtc *dcrtc,\r\nstruct armada_frame_work *work)\r\n{\r\nstruct drm_device *dev = dcrtc->crtc.dev;\r\nunsigned long flags;\r\nint ret;\r\nret = drm_vblank_get(dev, dcrtc->num);\r\nif (ret) {\r\nDRM_ERROR("failed to acquire vblank counter\n");\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (!dcrtc->frame_work)\r\ndcrtc->frame_work = work;\r\nelse\r\nret = -EBUSY;\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nif (ret)\r\ndrm_vblank_put(dev, dcrtc->num);\r\nreturn ret;\r\n}\r\nstatic void armada_drm_crtc_complete_frame_work(struct armada_crtc *dcrtc)\r\n{\r\nstruct drm_device *dev = dcrtc->crtc.dev;\r\nstruct armada_frame_work *work = dcrtc->frame_work;\r\ndcrtc->frame_work = NULL;\r\narmada_drm_crtc_update_regs(dcrtc, work->regs);\r\nif (work->event)\r\ndrm_send_vblank_event(dev, dcrtc->num, work->event);\r\ndrm_vblank_put(dev, dcrtc->num);\r\n__armada_drm_queue_unref_work(dcrtc->crtc.dev, work->old_fb);\r\nkfree(work);\r\n}\r\nstatic void armada_drm_crtc_finish_fb(struct armada_crtc *dcrtc,\r\nstruct drm_framebuffer *fb, bool force)\r\n{\r\nstruct armada_frame_work *work;\r\nif (!fb)\r\nreturn;\r\nif (force) {\r\ndrm_framebuffer_unreference(fb);\r\nreturn;\r\n}\r\nwork = kmalloc(sizeof(*work), GFP_KERNEL);\r\nif (work) {\r\nint i = 0;\r\nwork->event = NULL;\r\nwork->old_fb = fb;\r\narmada_reg_queue_end(work->regs, i);\r\nif (armada_drm_crtc_queue_frame_work(dcrtc, work) == 0)\r\nreturn;\r\nkfree(work);\r\n}\r\ndrm_framebuffer_unreference(fb);\r\n}\r\nstatic void armada_drm_vblank_off(struct armada_crtc *dcrtc)\r\n{\r\nstruct drm_device *dev = dcrtc->crtc.dev;\r\ndrm_vblank_off(dev, dcrtc->num);\r\nspin_lock_irq(&dev->event_lock);\r\nif (dcrtc->frame_work)\r\narmada_drm_crtc_complete_frame_work(dcrtc);\r\nspin_unlock_irq(&dev->event_lock);\r\n}\r\nvoid armada_drm_crtc_gamma_set(struct drm_crtc *crtc, u16 r, u16 g, u16 b,\r\nint idx)\r\n{\r\n}\r\nvoid armada_drm_crtc_gamma_get(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,\r\nint idx)\r\n{\r\n}\r\nstatic void armada_drm_crtc_dpms(struct drm_crtc *crtc, int dpms)\r\n{\r\nstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\r\nif (dcrtc->dpms != dpms) {\r\ndcrtc->dpms = dpms;\r\narmada_drm_crtc_update(dcrtc);\r\nif (dpms_blanked(dpms))\r\narmada_drm_vblank_off(dcrtc);\r\n}\r\n}\r\nstatic void armada_drm_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\r\nstruct drm_plane *plane;\r\nplane = dcrtc->plane;\r\nif (plane) {\r\nstruct drm_framebuffer *fb = plane->fb;\r\nplane->funcs->disable_plane(plane);\r\nplane->fb = NULL;\r\nplane->crtc = NULL;\r\ndrm_framebuffer_unreference(fb);\r\n}\r\n}\r\nstatic void armada_drm_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\r\nif (dcrtc->dpms != DRM_MODE_DPMS_ON) {\r\ndcrtc->dpms = DRM_MODE_DPMS_ON;\r\narmada_drm_crtc_update(dcrtc);\r\n}\r\n}\r\nstatic bool armada_drm_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode, struct drm_display_mode *adj)\r\n{\r\nstruct armada_private *priv = crtc->dev->dev_private;\r\nstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\r\nint ret;\r\nif (!priv->variant->has_spu_adv_reg &&\r\nadj->flags & DRM_MODE_FLAG_INTERLACE)\r\nreturn false;\r\nret = priv->variant->crtc_compute_clock(dcrtc, adj, NULL);\r\nif (ret)\r\nreturn false;\r\nreturn true;\r\n}\r\nvoid armada_drm_crtc_irq(struct armada_crtc *dcrtc, u32 stat)\r\n{\r\nstruct armada_vbl_event *e, *n;\r\nvoid __iomem *base = dcrtc->base;\r\nif (stat & DMA_FF_UNDERFLOW)\r\nDRM_ERROR("video underflow on crtc %u\n", dcrtc->num);\r\nif (stat & GRA_FF_UNDERFLOW)\r\nDRM_ERROR("graphics underflow on crtc %u\n", dcrtc->num);\r\nif (stat & VSYNC_IRQ)\r\ndrm_handle_vblank(dcrtc->crtc.dev, dcrtc->num);\r\nspin_lock(&dcrtc->irq_lock);\r\nlist_for_each_entry_safe(e, n, &dcrtc->vbl_list, node) {\r\nlist_del_init(&e->node);\r\ndrm_vblank_put(dcrtc->crtc.dev, dcrtc->num);\r\ne->fn(dcrtc, e->data);\r\n}\r\nif (stat & GRA_FRAME_IRQ && dcrtc->interlaced) {\r\nint i = stat & GRA_FRAME_IRQ0 ? 0 : 1;\r\nuint32_t val;\r\nwritel_relaxed(dcrtc->v[i].spu_v_porch, base + LCD_SPU_V_PORCH);\r\nwritel_relaxed(dcrtc->v[i].spu_v_h_total,\r\nbase + LCD_SPUT_V_H_TOTAL);\r\nval = readl_relaxed(base + LCD_SPU_ADV_REG);\r\nval &= ~(ADV_VSYNC_L_OFF | ADV_VSYNC_H_OFF | ADV_VSYNCOFFEN);\r\nval |= dcrtc->v[i].spu_adv_reg;\r\nwritel_relaxed(val, base + LCD_SPU_ADV_REG);\r\n}\r\nif (stat & DUMB_FRAMEDONE && dcrtc->cursor_update) {\r\nwritel_relaxed(dcrtc->cursor_hw_pos,\r\nbase + LCD_SPU_HWC_OVSA_HPXL_VLN);\r\nwritel_relaxed(dcrtc->cursor_hw_sz,\r\nbase + LCD_SPU_HWC_HPXL_VLN);\r\narmada_updatel(CFG_HWC_ENA,\r\nCFG_HWC_ENA | CFG_HWC_1BITMOD | CFG_HWC_1BITENA,\r\nbase + LCD_SPU_DMA_CTRL0);\r\ndcrtc->cursor_update = false;\r\narmada_drm_crtc_disable_irq(dcrtc, DUMB_FRAMEDONE_ENA);\r\n}\r\nspin_unlock(&dcrtc->irq_lock);\r\nif (stat & GRA_FRAME_IRQ) {\r\nstruct drm_device *dev = dcrtc->crtc.dev;\r\nspin_lock(&dev->event_lock);\r\nif (dcrtc->frame_work)\r\narmada_drm_crtc_complete_frame_work(dcrtc);\r\nspin_unlock(&dev->event_lock);\r\nwake_up(&dcrtc->frame_wait);\r\n}\r\n}\r\nvoid armada_drm_crtc_disable_irq(struct armada_crtc *dcrtc, u32 mask)\r\n{\r\nif (dcrtc->irq_ena & mask) {\r\ndcrtc->irq_ena &= ~mask;\r\nwritel(dcrtc->irq_ena, dcrtc->base + LCD_SPU_IRQ_ENA);\r\n}\r\n}\r\nvoid armada_drm_crtc_enable_irq(struct armada_crtc *dcrtc, u32 mask)\r\n{\r\nif ((dcrtc->irq_ena & mask) != mask) {\r\ndcrtc->irq_ena |= mask;\r\nwritel(dcrtc->irq_ena, dcrtc->base + LCD_SPU_IRQ_ENA);\r\nif (readl_relaxed(dcrtc->base + LCD_SPU_IRQ_ISR) & mask)\r\nwritel(0, dcrtc->base + LCD_SPU_IRQ_ISR);\r\n}\r\n}\r\nstatic uint32_t armada_drm_crtc_calculate_csc(struct armada_crtc *dcrtc)\r\n{\r\nstruct drm_display_mode *adj = &dcrtc->crtc.mode;\r\nuint32_t val = 0;\r\nif (dcrtc->csc_yuv_mode == CSC_YUV_CCIR709)\r\nval |= CFG_CSC_YUV_CCIR709;\r\nif (dcrtc->csc_rgb_mode == CSC_RGB_STUDIO)\r\nval |= CFG_CSC_RGB_STUDIO;\r\nif ((adj->hdisplay == 1280 && adj->vdisplay == 720 &&\r\n!(adj->flags & DRM_MODE_FLAG_INTERLACE)) ||\r\n(adj->hdisplay == 1920 && adj->vdisplay == 1080)) {\r\nif (dcrtc->csc_yuv_mode == CSC_AUTO)\r\nval |= CFG_CSC_YUV_CCIR709;\r\n}\r\nif (dcrtc->csc_rgb_mode == CSC_AUTO)\r\nval |= CFG_CSC_RGB_STUDIO;\r\nreturn val;\r\n}\r\nstatic int armada_drm_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode, struct drm_display_mode *adj,\r\nint x, int y, struct drm_framebuffer *old_fb)\r\n{\r\nstruct armada_private *priv = crtc->dev->dev_private;\r\nstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\r\nstruct armada_regs regs[17];\r\nuint32_t lm, rm, tm, bm, val, sclk;\r\nunsigned long flags;\r\nunsigned i;\r\nbool interlaced;\r\ndrm_framebuffer_reference(crtc->primary->fb);\r\ninterlaced = !!(adj->flags & DRM_MODE_FLAG_INTERLACE);\r\ni = armada_drm_crtc_calc_fb(dcrtc->crtc.primary->fb,\r\nx, y, regs, interlaced);\r\nrm = adj->crtc_hsync_start - adj->crtc_hdisplay;\r\nlm = adj->crtc_htotal - adj->crtc_hsync_end;\r\nbm = adj->crtc_vsync_start - adj->crtc_vdisplay;\r\ntm = adj->crtc_vtotal - adj->crtc_vsync_end;\r\nDRM_DEBUG_DRIVER("H: %d %d %d %d lm %d rm %d\n",\r\nadj->crtc_hdisplay,\r\nadj->crtc_hsync_start,\r\nadj->crtc_hsync_end,\r\nadj->crtc_htotal, lm, rm);\r\nDRM_DEBUG_DRIVER("V: %d %d %d %d tm %d bm %d\n",\r\nadj->crtc_vdisplay,\r\nadj->crtc_vsync_start,\r\nadj->crtc_vsync_end,\r\nadj->crtc_vtotal, tm, bm);\r\nwait_event(dcrtc->frame_wait, !dcrtc->frame_work);\r\ndrm_vblank_pre_modeset(crtc->dev, dcrtc->num);\r\ncrtc->mode = *adj;\r\nval = dcrtc->dumb_ctrl & ~CFG_DUMB_ENA;\r\nif (val != dcrtc->dumb_ctrl) {\r\ndcrtc->dumb_ctrl = val;\r\nwritel_relaxed(val, dcrtc->base + LCD_SPU_DUMB_CTRL);\r\n}\r\npriv->variant->crtc_compute_clock(dcrtc, adj, &sclk);\r\narmada_reg_queue_mod(regs, i, 0, CFG_PDWN64x66, LCD_SPU_SRAM_PARA1);\r\narmada_reg_queue_set(regs, i, sclk, LCD_CFG_SCLK_DIV);\r\nif (interlaced ^ dcrtc->interlaced) {\r\nif (adj->flags & DRM_MODE_FLAG_INTERLACE)\r\ndrm_vblank_get(dcrtc->crtc.dev, dcrtc->num);\r\nelse\r\ndrm_vblank_put(dcrtc->crtc.dev, dcrtc->num);\r\ndcrtc->interlaced = interlaced;\r\n}\r\nspin_lock_irqsave(&dcrtc->irq_lock, flags);\r\ndcrtc->v[1].spu_v_h_total = adj->crtc_vtotal << 16 |\r\nadj->crtc_htotal;\r\ndcrtc->v[1].spu_v_porch = tm << 16 | bm;\r\nval = adj->crtc_hsync_start;\r\ndcrtc->v[1].spu_adv_reg = val << 20 | val | ADV_VSYNCOFFEN |\r\npriv->variant->spu_adv_reg;\r\nif (interlaced) {\r\ndcrtc->v[0].spu_v_h_total = dcrtc->v[1].spu_v_h_total +\r\n(1 << 16);\r\ndcrtc->v[0].spu_v_porch = dcrtc->v[1].spu_v_porch + 1;\r\nval = adj->crtc_hsync_start - adj->crtc_htotal / 2;\r\ndcrtc->v[0].spu_adv_reg = val << 20 | val | ADV_VSYNCOFFEN |\r\npriv->variant->spu_adv_reg;\r\n} else {\r\ndcrtc->v[0] = dcrtc->v[1];\r\n}\r\nval = adj->crtc_vdisplay << 16 | adj->crtc_hdisplay;\r\narmada_reg_queue_set(regs, i, val, LCD_SPU_V_H_ACTIVE);\r\narmada_reg_queue_set(regs, i, val, LCD_SPU_GRA_HPXL_VLN);\r\narmada_reg_queue_set(regs, i, val, LCD_SPU_GZM_HPXL_VLN);\r\narmada_reg_queue_set(regs, i, (lm << 16) | rm, LCD_SPU_H_PORCH);\r\narmada_reg_queue_set(regs, i, dcrtc->v[0].spu_v_porch, LCD_SPU_V_PORCH);\r\narmada_reg_queue_set(regs, i, dcrtc->v[0].spu_v_h_total,\r\nLCD_SPUT_V_H_TOTAL);\r\nif (priv->variant->has_spu_adv_reg) {\r\narmada_reg_queue_mod(regs, i, dcrtc->v[0].spu_adv_reg,\r\nADV_VSYNC_L_OFF | ADV_VSYNC_H_OFF |\r\nADV_VSYNCOFFEN, LCD_SPU_ADV_REG);\r\n}\r\nval = CFG_GRA_ENA | CFG_GRA_HSMOOTH;\r\nval |= CFG_GRA_FMT(drm_fb_to_armada_fb(dcrtc->crtc.primary->fb)->fmt);\r\nval |= CFG_GRA_MOD(drm_fb_to_armada_fb(dcrtc->crtc.primary->fb)->mod);\r\nif (drm_fb_to_armada_fb(dcrtc->crtc.primary->fb)->fmt > CFG_420)\r\nval |= CFG_PALETTE_ENA;\r\nif (interlaced)\r\nval |= CFG_GRA_FTOGGLE;\r\narmada_reg_queue_mod(regs, i, val, CFG_GRAFORMAT |\r\nCFG_GRA_MOD(CFG_SWAPRB | CFG_SWAPUV |\r\nCFG_SWAPYU | CFG_YUV2RGB) |\r\nCFG_PALETTE_ENA | CFG_GRA_FTOGGLE,\r\nLCD_SPU_DMA_CTRL0);\r\nval = adj->flags & DRM_MODE_FLAG_NVSYNC ? CFG_VSYNC_INV : 0;\r\narmada_reg_queue_mod(regs, i, val, CFG_VSYNC_INV, LCD_SPU_DMA_CTRL1);\r\nval = dcrtc->spu_iopad_ctrl | armada_drm_crtc_calculate_csc(dcrtc);\r\narmada_reg_queue_set(regs, i, val, LCD_SPU_IOPAD_CONTROL);\r\narmada_reg_queue_end(regs, i);\r\narmada_drm_crtc_update_regs(dcrtc, regs);\r\nspin_unlock_irqrestore(&dcrtc->irq_lock, flags);\r\narmada_drm_crtc_update(dcrtc);\r\ndrm_vblank_post_modeset(crtc->dev, dcrtc->num);\r\narmada_drm_crtc_finish_fb(dcrtc, old_fb, dpms_blanked(dcrtc->dpms));\r\nreturn 0;\r\n}\r\nstatic int armada_drm_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\r\nstruct armada_regs regs[4];\r\nunsigned i;\r\ni = armada_drm_crtc_calc_fb(crtc->primary->fb, crtc->x, crtc->y, regs,\r\ndcrtc->interlaced);\r\narmada_reg_queue_end(regs, i);\r\nwait_event(dcrtc->frame_wait, !dcrtc->frame_work);\r\ndrm_framebuffer_reference(crtc->primary->fb);\r\narmada_drm_crtc_update_regs(dcrtc, regs);\r\narmada_drm_crtc_finish_fb(dcrtc, old_fb, dpms_blanked(dcrtc->dpms));\r\nreturn 0;\r\n}\r\nstatic void armada_drm_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void armada_drm_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\r\narmada_drm_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\r\narmada_drm_crtc_finish_fb(dcrtc, crtc->primary->fb, true);\r\nwritel_relaxed(CFG_PDWN256x32 | CFG_PDWN256x24 | CFG_PDWN256x8 |\r\nCFG_PDWN32x32 | CFG_PDWN16x66 | CFG_PDWN32x66 |\r\nCFG_PDWN64x66, dcrtc->base + LCD_SPU_SRAM_PARA1);\r\n}\r\nstatic void armada_load_cursor_argb(void __iomem *base, uint32_t *pix,\r\nunsigned stride, unsigned width, unsigned height)\r\n{\r\nuint32_t addr;\r\nunsigned y;\r\naddr = SRAM_HWC32_RAM1;\r\nfor (y = 0; y < height; y++) {\r\nuint32_t *p = &pix[y * stride];\r\nunsigned x;\r\nfor (x = 0; x < width; x++, p++) {\r\nuint32_t val = *p;\r\nval = (val & 0xff00ff00) |\r\n(val & 0x000000ff) << 16 |\r\n(val & 0x00ff0000) >> 16;\r\nwritel_relaxed(val,\r\nbase + LCD_SPU_SRAM_WRDAT);\r\nwritel_relaxed(addr | SRAM_WRITE,\r\nbase + LCD_SPU_SRAM_CTRL);\r\nreadl_relaxed(base + LCD_SPU_HWC_OVSA_HPXL_VLN);\r\naddr += 1;\r\nif ((addr & 0x00ff) == 0)\r\naddr += 0xf00;\r\nif ((addr & 0x30ff) == 0)\r\naddr = SRAM_HWC32_RAM2;\r\n}\r\n}\r\n}\r\nstatic void armada_drm_crtc_cursor_tran(void __iomem *base)\r\n{\r\nunsigned addr;\r\nfor (addr = 0; addr < 256; addr++) {\r\nwritel_relaxed(0x55555555, base + LCD_SPU_SRAM_WRDAT);\r\nwritel_relaxed(addr | SRAM_WRITE | SRAM_HWC32_TRAN,\r\nbase + LCD_SPU_SRAM_CTRL);\r\n}\r\n}\r\nstatic int armada_drm_crtc_cursor_update(struct armada_crtc *dcrtc, bool reload)\r\n{\r\nuint32_t xoff, xscr, w = dcrtc->cursor_w, s;\r\nuint32_t yoff, yscr, h = dcrtc->cursor_h;\r\nuint32_t para1;\r\nif (dcrtc->cursor_x < 0) {\r\nxoff = -dcrtc->cursor_x;\r\nxscr = 0;\r\nw -= min(xoff, w);\r\n} else if (dcrtc->cursor_x + w > dcrtc->crtc.mode.hdisplay) {\r\nxoff = 0;\r\nxscr = dcrtc->cursor_x;\r\nw = max_t(int, dcrtc->crtc.mode.hdisplay - dcrtc->cursor_x, 0);\r\n} else {\r\nxoff = 0;\r\nxscr = dcrtc->cursor_x;\r\n}\r\nif (dcrtc->cursor_y < 0) {\r\nyoff = -dcrtc->cursor_y;\r\nyscr = 0;\r\nh -= min(yoff, h);\r\n} else if (dcrtc->cursor_y + h > dcrtc->crtc.mode.vdisplay) {\r\nyoff = 0;\r\nyscr = dcrtc->cursor_y;\r\nh = max_t(int, dcrtc->crtc.mode.vdisplay - dcrtc->cursor_y, 0);\r\n} else {\r\nyoff = 0;\r\nyscr = dcrtc->cursor_y;\r\n}\r\ns = dcrtc->cursor_w;\r\nif (dcrtc->interlaced) {\r\ns *= 2;\r\nyscr /= 2;\r\nh /= 2;\r\n}\r\nif (!dcrtc->cursor_obj || !h || !w) {\r\nspin_lock_irq(&dcrtc->irq_lock);\r\narmada_drm_crtc_disable_irq(dcrtc, DUMB_FRAMEDONE_ENA);\r\ndcrtc->cursor_update = false;\r\narmada_updatel(0, CFG_HWC_ENA, dcrtc->base + LCD_SPU_DMA_CTRL0);\r\nspin_unlock_irq(&dcrtc->irq_lock);\r\nreturn 0;\r\n}\r\npara1 = readl_relaxed(dcrtc->base + LCD_SPU_SRAM_PARA1);\r\narmada_updatel(CFG_CSB_256x32, CFG_CSB_256x32 | CFG_PDWN256x32,\r\ndcrtc->base + LCD_SPU_SRAM_PARA1);\r\nif (!(para1 & CFG_CSB_256x32)) {\r\narmada_drm_crtc_cursor_tran(dcrtc->base);\r\nreload = true;\r\n}\r\nif (dcrtc->cursor_hw_sz != (h << 16 | w)) {\r\nspin_lock_irq(&dcrtc->irq_lock);\r\narmada_drm_crtc_disable_irq(dcrtc, DUMB_FRAMEDONE_ENA);\r\ndcrtc->cursor_update = false;\r\narmada_updatel(0, CFG_HWC_ENA, dcrtc->base + LCD_SPU_DMA_CTRL0);\r\nspin_unlock_irq(&dcrtc->irq_lock);\r\nreload = true;\r\n}\r\nif (reload) {\r\nstruct armada_gem_object *obj = dcrtc->cursor_obj;\r\nuint32_t *pix;\r\npix = obj->addr;\r\npix += yoff * s + xoff;\r\narmada_load_cursor_argb(dcrtc->base, pix, s, w, h);\r\n}\r\nspin_lock_irq(&dcrtc->irq_lock);\r\ndcrtc->cursor_hw_pos = yscr << 16 | xscr;\r\ndcrtc->cursor_hw_sz = h << 16 | w;\r\ndcrtc->cursor_update = true;\r\narmada_drm_crtc_enable_irq(dcrtc, DUMB_FRAMEDONE_ENA);\r\nspin_unlock_irq(&dcrtc->irq_lock);\r\nreturn 0;\r\n}\r\nstatic void cursor_update(void *data)\r\n{\r\narmada_drm_crtc_cursor_update(data, true);\r\n}\r\nstatic int armada_drm_crtc_cursor_set(struct drm_crtc *crtc,\r\nstruct drm_file *file, uint32_t handle, uint32_t w, uint32_t h)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\r\nstruct armada_private *priv = crtc->dev->dev_private;\r\nstruct armada_gem_object *obj = NULL;\r\nint ret;\r\nif (!priv->variant->has_spu_adv_reg)\r\nreturn -ENXIO;\r\nif (handle && w > 0 && h > 0) {\r\nif (w > 64 || h > 64 || (w > 32 && h > 32))\r\nreturn -ENOMEM;\r\nobj = armada_gem_object_lookup(dev, file, handle);\r\nif (!obj)\r\nreturn -ENOENT;\r\nif (!obj->addr) {\r\ndrm_gem_object_unreference_unlocked(&obj->obj);\r\nreturn -EINVAL;\r\n}\r\nif (obj->obj.size < w * h * 4) {\r\nDRM_ERROR("buffer is too small\n");\r\ndrm_gem_object_unreference_unlocked(&obj->obj);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nif (dcrtc->cursor_obj) {\r\ndcrtc->cursor_obj->update = NULL;\r\ndcrtc->cursor_obj->update_data = NULL;\r\ndrm_gem_object_unreference(&dcrtc->cursor_obj->obj);\r\n}\r\ndcrtc->cursor_obj = obj;\r\ndcrtc->cursor_w = w;\r\ndcrtc->cursor_h = h;\r\nret = armada_drm_crtc_cursor_update(dcrtc, true);\r\nif (obj) {\r\nobj->update_data = dcrtc;\r\nobj->update = cursor_update;\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\nstatic int armada_drm_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\r\nstruct armada_private *priv = crtc->dev->dev_private;\r\nint ret;\r\nif (!priv->variant->has_spu_adv_reg)\r\nreturn -EFAULT;\r\nmutex_lock(&dev->struct_mutex);\r\ndcrtc->cursor_x = x;\r\ndcrtc->cursor_y = y;\r\nret = armada_drm_crtc_cursor_update(dcrtc, false);\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\nstatic void armada_drm_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\r\nstruct armada_private *priv = crtc->dev->dev_private;\r\nif (dcrtc->cursor_obj)\r\ndrm_gem_object_unreference(&dcrtc->cursor_obj->obj);\r\npriv->dcrtc[dcrtc->num] = NULL;\r\ndrm_crtc_cleanup(&dcrtc->crtc);\r\nif (!IS_ERR(dcrtc->clk))\r\nclk_disable_unprepare(dcrtc->clk);\r\nkfree(dcrtc);\r\n}\r\nstatic int armada_drm_crtc_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb, struct drm_pending_vblank_event *event, uint32_t page_flip_flags)\r\n{\r\nstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\r\nstruct armada_frame_work *work;\r\nstruct drm_device *dev = crtc->dev;\r\nunsigned long flags;\r\nunsigned i;\r\nint ret;\r\nif (fb->pixel_format != crtc->primary->fb->pixel_format)\r\nreturn -EINVAL;\r\nwork = kmalloc(sizeof(*work), GFP_KERNEL);\r\nif (!work)\r\nreturn -ENOMEM;\r\nwork->event = event;\r\nwork->old_fb = dcrtc->crtc.primary->fb;\r\ni = armada_drm_crtc_calc_fb(fb, crtc->x, crtc->y, work->regs,\r\ndcrtc->interlaced);\r\narmada_reg_queue_end(work->regs, i);\r\ndrm_framebuffer_reference(work->old_fb);\r\nret = armada_drm_crtc_queue_frame_work(dcrtc, work);\r\nif (ret) {\r\ndrm_framebuffer_unreference(work->old_fb);\r\nkfree(work);\r\nreturn ret;\r\n}\r\ndcrtc->crtc.primary->fb = fb;\r\nif (dpms_blanked(dcrtc->dpms)) {\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (dcrtc->frame_work)\r\narmada_drm_crtc_complete_frame_work(dcrtc);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\narmada_drm_crtc_set_property(struct drm_crtc *crtc,\r\nstruct drm_property *property, uint64_t val)\r\n{\r\nstruct armada_private *priv = crtc->dev->dev_private;\r\nstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\r\nbool update_csc = false;\r\nif (property == priv->csc_yuv_prop) {\r\ndcrtc->csc_yuv_mode = val;\r\nupdate_csc = true;\r\n} else if (property == priv->csc_rgb_prop) {\r\ndcrtc->csc_rgb_mode = val;\r\nupdate_csc = true;\r\n}\r\nif (update_csc) {\r\nuint32_t val;\r\nval = dcrtc->spu_iopad_ctrl |\r\narmada_drm_crtc_calculate_csc(dcrtc);\r\nwritel_relaxed(val, dcrtc->base + LCD_SPU_IOPAD_CONTROL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int armada_drm_crtc_create_properties(struct drm_device *dev)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\nif (priv->csc_yuv_prop)\r\nreturn 0;\r\npriv->csc_yuv_prop = drm_property_create_enum(dev, 0,\r\n"CSC_YUV", armada_drm_csc_yuv_enum_list,\r\nARRAY_SIZE(armada_drm_csc_yuv_enum_list));\r\npriv->csc_rgb_prop = drm_property_create_enum(dev, 0,\r\n"CSC_RGB", armada_drm_csc_rgb_enum_list,\r\nARRAY_SIZE(armada_drm_csc_rgb_enum_list));\r\nif (!priv->csc_yuv_prop || !priv->csc_rgb_prop)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint armada_drm_crtc_create(struct drm_device *dev, unsigned num,\r\nstruct resource *res)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\nstruct armada_crtc *dcrtc;\r\nvoid __iomem *base;\r\nint ret;\r\nret = armada_drm_crtc_create_properties(dev);\r\nif (ret)\r\nreturn ret;\r\nbase = devm_request_and_ioremap(dev->dev, res);\r\nif (!base) {\r\nDRM_ERROR("failed to ioremap register\n");\r\nreturn -ENOMEM;\r\n}\r\ndcrtc = kzalloc(sizeof(*dcrtc), GFP_KERNEL);\r\nif (!dcrtc) {\r\nDRM_ERROR("failed to allocate Armada crtc\n");\r\nreturn -ENOMEM;\r\n}\r\ndcrtc->base = base;\r\ndcrtc->num = num;\r\ndcrtc->clk = ERR_PTR(-EINVAL);\r\ndcrtc->csc_yuv_mode = CSC_AUTO;\r\ndcrtc->csc_rgb_mode = CSC_AUTO;\r\ndcrtc->cfg_dumb_ctrl = DUMB24_RGB888_0;\r\ndcrtc->spu_iopad_ctrl = CFG_VSCALE_LN_EN | CFG_IOPAD_DUMB24;\r\nspin_lock_init(&dcrtc->irq_lock);\r\ndcrtc->irq_ena = CLEAN_SPU_IRQ_ISR;\r\nINIT_LIST_HEAD(&dcrtc->vbl_list);\r\ninit_waitqueue_head(&dcrtc->frame_wait);\r\nwritel_relaxed(0x00000001, dcrtc->base + LCD_CFG_SCLK_DIV);\r\nwritel_relaxed(0x00000000, dcrtc->base + LCD_SPU_BLANKCOLOR);\r\nwritel_relaxed(dcrtc->spu_iopad_ctrl,\r\ndcrtc->base + LCD_SPU_IOPAD_CONTROL);\r\nwritel_relaxed(0x00000000, dcrtc->base + LCD_SPU_SRAM_PARA0);\r\nwritel_relaxed(CFG_PDWN256x32 | CFG_PDWN256x24 | CFG_PDWN256x8 |\r\nCFG_PDWN32x32 | CFG_PDWN16x66 | CFG_PDWN32x66 |\r\nCFG_PDWN64x66, dcrtc->base + LCD_SPU_SRAM_PARA1);\r\nwritel_relaxed(0x2032ff81, dcrtc->base + LCD_SPU_DMA_CTRL1);\r\nwritel_relaxed(0x00000000, dcrtc->base + LCD_SPU_GRA_OVSA_HPXL_VLN);\r\nif (priv->variant->crtc_init) {\r\nret = priv->variant->crtc_init(dcrtc);\r\nif (ret) {\r\nkfree(dcrtc);\r\nreturn ret;\r\n}\r\n}\r\narmada_updatel(CFG_ARBFAST_ENA, 0, dcrtc->base + LCD_SPU_DMA_CTRL0);\r\npriv->dcrtc[dcrtc->num] = dcrtc;\r\ndrm_crtc_init(dev, &dcrtc->crtc, &armada_crtc_funcs);\r\ndrm_crtc_helper_add(&dcrtc->crtc, &armada_crtc_helper_funcs);\r\ndrm_object_attach_property(&dcrtc->crtc.base, priv->csc_yuv_prop,\r\ndcrtc->csc_yuv_mode);\r\ndrm_object_attach_property(&dcrtc->crtc.base, priv->csc_rgb_prop,\r\ndcrtc->csc_rgb_mode);\r\nreturn armada_overlay_plane_create(dev, 1 << dcrtc->num);\r\n}
