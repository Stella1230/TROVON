static void urb_free_priv (struct ohci_hcd *hc, urb_priv_t *urb_priv)\r\n{\r\nint last = urb_priv->length - 1;\r\nif (last >= 0) {\r\nint i;\r\nstruct td *td;\r\nfor (i = 0; i <= last; i++) {\r\ntd = urb_priv->td [i];\r\nif (td)\r\ntd_free (hc, td);\r\n}\r\n}\r\nlist_del (&urb_priv->pending);\r\nkfree (urb_priv);\r\n}\r\nstatic void\r\nfinish_urb(struct ohci_hcd *ohci, struct urb *urb, int status)\r\n__releases(ohci->lock)\r\n__acquires(ohci->lock)\r\n{\r\nstruct device *dev = ohci_to_hcd(ohci)->self.controller;\r\nstruct usb_host_endpoint *ep = urb->ep;\r\nstruct urb_priv *urb_priv;\r\nrestart:\r\nurb_free_priv (ohci, urb->hcpriv);\r\nurb->hcpriv = NULL;\r\nif (likely(status == -EINPROGRESS))\r\nstatus = 0;\r\nswitch (usb_pipetype (urb->pipe)) {\r\ncase PIPE_ISOCHRONOUS:\r\nohci_to_hcd(ohci)->self.bandwidth_isoc_reqs--;\r\nif (ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs == 0) {\r\nif (quirk_amdiso(ohci))\r\nusb_amd_quirk_pll_enable();\r\nif (quirk_amdprefetch(ohci))\r\nsb800_prefetch(dev, 0);\r\n}\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\nohci_to_hcd(ohci)->self.bandwidth_int_reqs--;\r\nbreak;\r\n}\r\nusb_hcd_unlink_urb_from_ep(ohci_to_hcd(ohci), urb);\r\nspin_unlock (&ohci->lock);\r\nusb_hcd_giveback_urb(ohci_to_hcd(ohci), urb, status);\r\nspin_lock (&ohci->lock);\r\nif (ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs == 0\r\n&& ohci_to_hcd(ohci)->self.bandwidth_int_reqs == 0) {\r\nohci->hc_control &= ~(OHCI_CTRL_PLE|OHCI_CTRL_IE);\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\n}\r\nif (!list_empty(&ep->urb_list)) {\r\nurb = list_first_entry(&ep->urb_list, struct urb, urb_list);\r\nurb_priv = urb->hcpriv;\r\nif (urb_priv->td_cnt > urb_priv->length) {\r\nstatus = 0;\r\ngoto restart;\r\n}\r\n}\r\n}\r\nstatic int balance (struct ohci_hcd *ohci, int interval, int load)\r\n{\r\nint i, branch = -ENOSPC;\r\nif (interval > NUM_INTS)\r\ninterval = NUM_INTS;\r\nfor (i = 0; i < interval ; i++) {\r\nif (branch < 0 || ohci->load [branch] > ohci->load [i]) {\r\nint j;\r\nfor (j = i; j < NUM_INTS; j += interval) {\r\nif ((ohci->load [j] + load) > 900)\r\nbreak;\r\n}\r\nif (j < NUM_INTS)\r\ncontinue;\r\nbranch = i;\r\n}\r\n}\r\nreturn branch;\r\n}\r\nstatic void periodic_link (struct ohci_hcd *ohci, struct ed *ed)\r\n{\r\nunsigned i;\r\nohci_dbg(ohci, "link %sed %p branch %d [%dus.], interval %d\n",\r\n(ed->hwINFO & cpu_to_hc32 (ohci, ED_ISO)) ? "iso " : "",\r\ned, ed->branch, ed->load, ed->interval);\r\nfor (i = ed->branch; i < NUM_INTS; i += ed->interval) {\r\nstruct ed **prev = &ohci->periodic [i];\r\n__hc32 *prev_p = &ohci->hcca->int_table [i];\r\nstruct ed *here = *prev;\r\nwhile (here && ed != here) {\r\nif (ed->interval > here->interval)\r\nbreak;\r\nprev = &here->ed_next;\r\nprev_p = &here->hwNextED;\r\nhere = *prev;\r\n}\r\nif (ed != here) {\r\ned->ed_next = here;\r\nif (here)\r\ned->hwNextED = *prev_p;\r\nwmb ();\r\n*prev = ed;\r\n*prev_p = cpu_to_hc32(ohci, ed->dma);\r\nwmb();\r\n}\r\nohci->load [i] += ed->load;\r\n}\r\nohci_to_hcd(ohci)->self.bandwidth_allocated += ed->load / ed->interval;\r\n}\r\nstatic int ed_schedule (struct ohci_hcd *ohci, struct ed *ed)\r\n{\r\nint branch;\r\ned->state = ED_OPER;\r\ned->ed_prev = NULL;\r\ned->ed_next = NULL;\r\ned->hwNextED = 0;\r\nif (quirk_zfmicro(ohci)\r\n&& (ed->type == PIPE_INTERRUPT)\r\n&& !(ohci->eds_scheduled++))\r\nmod_timer(&ohci->unlink_watchdog, round_jiffies(jiffies + HZ));\r\nwmb ();\r\nswitch (ed->type) {\r\ncase PIPE_CONTROL:\r\nif (ohci->ed_controltail == NULL) {\r\nWARN_ON (ohci->hc_control & OHCI_CTRL_CLE);\r\nohci_writel (ohci, ed->dma,\r\n&ohci->regs->ed_controlhead);\r\n} else {\r\nohci->ed_controltail->ed_next = ed;\r\nohci->ed_controltail->hwNextED = cpu_to_hc32 (ohci,\r\ned->dma);\r\n}\r\ned->ed_prev = ohci->ed_controltail;\r\nif (!ohci->ed_controltail && !ohci->ed_rm_list) {\r\nwmb();\r\nohci->hc_control |= OHCI_CTRL_CLE;\r\nohci_writel (ohci, 0, &ohci->regs->ed_controlcurrent);\r\nohci_writel (ohci, ohci->hc_control,\r\n&ohci->regs->control);\r\n}\r\nohci->ed_controltail = ed;\r\nbreak;\r\ncase PIPE_BULK:\r\nif (ohci->ed_bulktail == NULL) {\r\nWARN_ON (ohci->hc_control & OHCI_CTRL_BLE);\r\nohci_writel (ohci, ed->dma, &ohci->regs->ed_bulkhead);\r\n} else {\r\nohci->ed_bulktail->ed_next = ed;\r\nohci->ed_bulktail->hwNextED = cpu_to_hc32 (ohci,\r\ned->dma);\r\n}\r\ned->ed_prev = ohci->ed_bulktail;\r\nif (!ohci->ed_bulktail && !ohci->ed_rm_list) {\r\nwmb();\r\nohci->hc_control |= OHCI_CTRL_BLE;\r\nohci_writel (ohci, 0, &ohci->regs->ed_bulkcurrent);\r\nohci_writel (ohci, ohci->hc_control,\r\n&ohci->regs->control);\r\n}\r\nohci->ed_bulktail = ed;\r\nbreak;\r\ndefault:\r\nbranch = balance (ohci, ed->interval, ed->load);\r\nif (branch < 0) {\r\nohci_dbg (ohci,\r\n"ERR %d, interval %d msecs, load %d\n",\r\nbranch, ed->interval, ed->load);\r\nreturn branch;\r\n}\r\ned->branch = branch;\r\nperiodic_link (ohci, ed);\r\n}\r\nreturn 0;\r\n}\r\nstatic void periodic_unlink (struct ohci_hcd *ohci, struct ed *ed)\r\n{\r\nint i;\r\nfor (i = ed->branch; i < NUM_INTS; i += ed->interval) {\r\nstruct ed *temp;\r\nstruct ed **prev = &ohci->periodic [i];\r\n__hc32 *prev_p = &ohci->hcca->int_table [i];\r\nwhile (*prev && (temp = *prev) != ed) {\r\nprev_p = &temp->hwNextED;\r\nprev = &temp->ed_next;\r\n}\r\nif (*prev) {\r\n*prev_p = ed->hwNextED;\r\n*prev = ed->ed_next;\r\n}\r\nohci->load [i] -= ed->load;\r\n}\r\nohci_to_hcd(ohci)->self.bandwidth_allocated -= ed->load / ed->interval;\r\nohci_dbg(ohci, "unlink %sed %p branch %d [%dus.], interval %d\n",\r\n(ed->hwINFO & cpu_to_hc32 (ohci, ED_ISO)) ? "iso " : "",\r\ned, ed->branch, ed->load, ed->interval);\r\n}\r\nstatic void ed_deschedule (struct ohci_hcd *ohci, struct ed *ed)\r\n{\r\ned->hwINFO |= cpu_to_hc32 (ohci, ED_SKIP);\r\nwmb ();\r\ned->state = ED_UNLINK;\r\nswitch (ed->type) {\r\ncase PIPE_CONTROL:\r\nif (ed->ed_prev == NULL) {\r\nif (!ed->hwNextED) {\r\nohci->hc_control &= ~OHCI_CTRL_CLE;\r\nohci_writel (ohci, ohci->hc_control,\r\n&ohci->regs->control);\r\n} else\r\nohci_writel (ohci,\r\nhc32_to_cpup (ohci, &ed->hwNextED),\r\n&ohci->regs->ed_controlhead);\r\n} else {\r\ned->ed_prev->ed_next = ed->ed_next;\r\ned->ed_prev->hwNextED = ed->hwNextED;\r\n}\r\nif (ohci->ed_controltail == ed) {\r\nohci->ed_controltail = ed->ed_prev;\r\nif (ohci->ed_controltail)\r\nohci->ed_controltail->ed_next = NULL;\r\n} else if (ed->ed_next) {\r\ned->ed_next->ed_prev = ed->ed_prev;\r\n}\r\nbreak;\r\ncase PIPE_BULK:\r\nif (ed->ed_prev == NULL) {\r\nif (!ed->hwNextED) {\r\nohci->hc_control &= ~OHCI_CTRL_BLE;\r\nohci_writel (ohci, ohci->hc_control,\r\n&ohci->regs->control);\r\n} else\r\nohci_writel (ohci,\r\nhc32_to_cpup (ohci, &ed->hwNextED),\r\n&ohci->regs->ed_bulkhead);\r\n} else {\r\ned->ed_prev->ed_next = ed->ed_next;\r\ned->ed_prev->hwNextED = ed->hwNextED;\r\n}\r\nif (ohci->ed_bulktail == ed) {\r\nohci->ed_bulktail = ed->ed_prev;\r\nif (ohci->ed_bulktail)\r\nohci->ed_bulktail->ed_next = NULL;\r\n} else if (ed->ed_next) {\r\ned->ed_next->ed_prev = ed->ed_prev;\r\n}\r\nbreak;\r\ndefault:\r\nperiodic_unlink (ohci, ed);\r\nbreak;\r\n}\r\n}\r\nstatic struct ed *ed_get (\r\nstruct ohci_hcd *ohci,\r\nstruct usb_host_endpoint *ep,\r\nstruct usb_device *udev,\r\nunsigned int pipe,\r\nint interval\r\n) {\r\nstruct ed *ed;\r\nunsigned long flags;\r\nspin_lock_irqsave (&ohci->lock, flags);\r\nif (!(ed = ep->hcpriv)) {\r\nstruct td *td;\r\nint is_out;\r\nu32 info;\r\ned = ed_alloc (ohci, GFP_ATOMIC);\r\nif (!ed) {\r\ngoto done;\r\n}\r\ntd = td_alloc (ohci, GFP_ATOMIC);\r\nif (!td) {\r\ned_free (ohci, ed);\r\ned = NULL;\r\ngoto done;\r\n}\r\ned->dummy = td;\r\ned->hwTailP = cpu_to_hc32 (ohci, td->td_dma);\r\ned->hwHeadP = ed->hwTailP;\r\ned->state = ED_IDLE;\r\nis_out = !(ep->desc.bEndpointAddress & USB_DIR_IN);\r\ninfo = usb_pipedevice (pipe);\r\ned->type = usb_pipetype(pipe);\r\ninfo |= (ep->desc.bEndpointAddress & ~USB_DIR_IN) << 7;\r\ninfo |= usb_endpoint_maxp(&ep->desc) << 16;\r\nif (udev->speed == USB_SPEED_LOW)\r\ninfo |= ED_LOWSPEED;\r\nif (ed->type != PIPE_CONTROL) {\r\ninfo |= is_out ? ED_OUT : ED_IN;\r\nif (ed->type != PIPE_BULK) {\r\nif (ed->type == PIPE_ISOCHRONOUS)\r\ninfo |= ED_ISO;\r\nelse if (interval > 32)\r\ninterval = 32;\r\ned->interval = interval;\r\ned->load = usb_calc_bus_time (\r\nudev->speed, !is_out,\r\ned->type == PIPE_ISOCHRONOUS,\r\nusb_endpoint_maxp(&ep->desc))\r\n/ 1000;\r\n}\r\n}\r\ned->hwINFO = cpu_to_hc32(ohci, info);\r\nep->hcpriv = ed;\r\n}\r\ndone:\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nreturn ed;\r\n}\r\nstatic void start_ed_unlink (struct ohci_hcd *ohci, struct ed *ed)\r\n{\r\ned->hwINFO |= cpu_to_hc32 (ohci, ED_DEQUEUE);\r\ned_deschedule (ohci, ed);\r\ned->ed_next = ohci->ed_rm_list;\r\ned->ed_prev = NULL;\r\nohci->ed_rm_list = ed;\r\nohci_writel (ohci, OHCI_INTR_SF, &ohci->regs->intrstatus);\r\nohci_writel (ohci, OHCI_INTR_SF, &ohci->regs->intrenable);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\ned->tick = ohci_frame_no(ohci) + 1;\r\n}\r\nstatic void\r\ntd_fill (struct ohci_hcd *ohci, u32 info,\r\ndma_addr_t data, int len,\r\nstruct urb *urb, int index)\r\n{\r\nstruct td *td, *td_pt;\r\nstruct urb_priv *urb_priv = urb->hcpriv;\r\nint is_iso = info & TD_ISO;\r\nint hash;\r\nif (index != (urb_priv->length - 1)\r\n|| (urb->transfer_flags & URB_NO_INTERRUPT))\r\ninfo |= TD_DI_SET (6);\r\ntd_pt = urb_priv->td [index];\r\ntd = urb_priv->td [index] = urb_priv->ed->dummy;\r\nurb_priv->ed->dummy = td_pt;\r\ntd->ed = urb_priv->ed;\r\ntd->next_dl_td = NULL;\r\ntd->index = index;\r\ntd->urb = urb;\r\ntd->data_dma = data;\r\nif (!len)\r\ndata = 0;\r\ntd->hwINFO = cpu_to_hc32 (ohci, info);\r\nif (is_iso) {\r\ntd->hwCBP = cpu_to_hc32 (ohci, data & 0xFFFFF000);\r\n*ohci_hwPSWp(ohci, td, 0) = cpu_to_hc16 (ohci,\r\n(data & 0x0FFF) | 0xE000);\r\n} else {\r\ntd->hwCBP = cpu_to_hc32 (ohci, data);\r\n}\r\nif (data)\r\ntd->hwBE = cpu_to_hc32 (ohci, data + len - 1);\r\nelse\r\ntd->hwBE = 0;\r\ntd->hwNextTD = cpu_to_hc32 (ohci, td_pt->td_dma);\r\nlist_add_tail (&td->td_list, &td->ed->td_list);\r\nhash = TD_HASH_FUNC (td->td_dma);\r\ntd->td_hash = ohci->td_hash [hash];\r\nohci->td_hash [hash] = td;\r\nwmb ();\r\ntd->ed->hwTailP = td->hwNextTD;\r\n}\r\nstatic void td_submit_urb (\r\nstruct ohci_hcd *ohci,\r\nstruct urb *urb\r\n) {\r\nstruct urb_priv *urb_priv = urb->hcpriv;\r\nstruct device *dev = ohci_to_hcd(ohci)->self.controller;\r\ndma_addr_t data;\r\nint data_len = urb->transfer_buffer_length;\r\nint cnt = 0;\r\nu32 info = 0;\r\nint is_out = usb_pipeout (urb->pipe);\r\nint periodic = 0;\r\nif (!usb_gettoggle (urb->dev, usb_pipeendpoint (urb->pipe), is_out)) {\r\nusb_settoggle (urb->dev, usb_pipeendpoint (urb->pipe),\r\nis_out, 1);\r\nurb_priv->ed->hwHeadP &= ~cpu_to_hc32 (ohci, ED_C);\r\n}\r\nlist_add (&urb_priv->pending, &ohci->pending);\r\nif (data_len)\r\ndata = urb->transfer_dma;\r\nelse\r\ndata = 0;\r\nswitch (urb_priv->ed->type) {\r\ncase PIPE_INTERRUPT:\r\nperiodic = ohci_to_hcd(ohci)->self.bandwidth_int_reqs++ == 0\r\n&& ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs == 0;\r\ncase PIPE_BULK:\r\ninfo = is_out\r\n? TD_T_TOGGLE | TD_CC | TD_DP_OUT\r\n: TD_T_TOGGLE | TD_CC | TD_DP_IN;\r\nwhile (data_len > 4096) {\r\ntd_fill (ohci, info, data, 4096, urb, cnt);\r\ndata += 4096;\r\ndata_len -= 4096;\r\ncnt++;\r\n}\r\nif (!(urb->transfer_flags & URB_SHORT_NOT_OK))\r\ninfo |= TD_R;\r\ntd_fill (ohci, info, data, data_len, urb, cnt);\r\ncnt++;\r\nif ((urb->transfer_flags & URB_ZERO_PACKET)\r\n&& cnt < urb_priv->length) {\r\ntd_fill (ohci, info, 0, 0, urb, cnt);\r\ncnt++;\r\n}\r\nif (urb_priv->ed->type == PIPE_BULK) {\r\nwmb ();\r\nohci_writel (ohci, OHCI_BLF, &ohci->regs->cmdstatus);\r\n}\r\nbreak;\r\ncase PIPE_CONTROL:\r\ninfo = TD_CC | TD_DP_SETUP | TD_T_DATA0;\r\ntd_fill (ohci, info, urb->setup_dma, 8, urb, cnt++);\r\nif (data_len > 0) {\r\ninfo = TD_CC | TD_R | TD_T_DATA1;\r\ninfo |= is_out ? TD_DP_OUT : TD_DP_IN;\r\ntd_fill (ohci, info, data, data_len, urb, cnt++);\r\n}\r\ninfo = (is_out || data_len == 0)\r\n? TD_CC | TD_DP_IN | TD_T_DATA1\r\n: TD_CC | TD_DP_OUT | TD_T_DATA1;\r\ntd_fill (ohci, info, data, 0, urb, cnt++);\r\nwmb ();\r\nohci_writel (ohci, OHCI_CLF, &ohci->regs->cmdstatus);\r\nbreak;\r\ncase PIPE_ISOCHRONOUS:\r\nfor (cnt = urb_priv->td_cnt; cnt < urb->number_of_packets;\r\ncnt++) {\r\nint frame = urb->start_frame;\r\nframe += cnt * urb->interval;\r\nframe &= 0xffff;\r\ntd_fill (ohci, TD_CC | TD_ISO | frame,\r\ndata + urb->iso_frame_desc [cnt].offset,\r\nurb->iso_frame_desc [cnt].length, urb, cnt);\r\n}\r\nif (ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs == 0) {\r\nif (quirk_amdiso(ohci))\r\nusb_amd_quirk_pll_disable();\r\nif (quirk_amdprefetch(ohci))\r\nsb800_prefetch(dev, 1);\r\n}\r\nperiodic = ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs++ == 0\r\n&& ohci_to_hcd(ohci)->self.bandwidth_int_reqs == 0;\r\nbreak;\r\n}\r\nif (periodic) {\r\nwmb ();\r\nohci->hc_control |= OHCI_CTRL_PLE|OHCI_CTRL_IE;\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\n}\r\n}\r\nstatic int td_done(struct ohci_hcd *ohci, struct urb *urb, struct td *td)\r\n{\r\nu32 tdINFO = hc32_to_cpup (ohci, &td->hwINFO);\r\nint cc = 0;\r\nint status = -EINPROGRESS;\r\nlist_del (&td->td_list);\r\nif (tdINFO & TD_ISO) {\r\nu16 tdPSW = ohci_hwPSW(ohci, td, 0);\r\nint dlen = 0;\r\ncc = (tdPSW >> 12) & 0xF;\r\nif (tdINFO & TD_CC)\r\nreturn status;\r\nif (usb_pipeout (urb->pipe))\r\ndlen = urb->iso_frame_desc [td->index].length;\r\nelse {\r\nif (cc == TD_DATAUNDERRUN)\r\ncc = TD_CC_NOERROR;\r\ndlen = tdPSW & 0x3ff;\r\n}\r\nurb->actual_length += dlen;\r\nurb->iso_frame_desc [td->index].actual_length = dlen;\r\nurb->iso_frame_desc [td->index].status = cc_to_error [cc];\r\nif (cc != TD_CC_NOERROR)\r\nohci_dbg(ohci,\r\n"urb %p iso td %p (%d) len %d cc %d\n",\r\nurb, td, 1 + td->index, dlen, cc);\r\n} else {\r\nint type = usb_pipetype (urb->pipe);\r\nu32 tdBE = hc32_to_cpup (ohci, &td->hwBE);\r\ncc = TD_CC_GET (tdINFO);\r\nif (cc == TD_DATAUNDERRUN\r\n&& !(urb->transfer_flags & URB_SHORT_NOT_OK))\r\ncc = TD_CC_NOERROR;\r\nif (cc != TD_CC_NOERROR && cc < 0x0E)\r\nstatus = cc_to_error[cc];\r\nif ((type != PIPE_CONTROL || td->index != 0) && tdBE != 0) {\r\nif (td->hwCBP == 0)\r\nurb->actual_length += tdBE - td->data_dma + 1;\r\nelse\r\nurb->actual_length +=\r\nhc32_to_cpup (ohci, &td->hwCBP)\r\n- td->data_dma;\r\n}\r\nif (cc != TD_CC_NOERROR && cc < 0x0E)\r\nohci_dbg(ohci,\r\n"urb %p td %p (%d) cc %d, len=%d/%d\n",\r\nurb, td, 1 + td->index, cc,\r\nurb->actual_length,\r\nurb->transfer_buffer_length);\r\n}\r\nreturn status;\r\n}\r\nstatic void ed_halted(struct ohci_hcd *ohci, struct td *td, int cc)\r\n{\r\nstruct urb *urb = td->urb;\r\nurb_priv_t *urb_priv = urb->hcpriv;\r\nstruct ed *ed = td->ed;\r\nstruct list_head *tmp = td->td_list.next;\r\n__hc32 toggle = ed->hwHeadP & cpu_to_hc32 (ohci, ED_C);\r\ned->hwINFO |= cpu_to_hc32 (ohci, ED_SKIP);\r\nwmb ();\r\ned->hwHeadP &= ~cpu_to_hc32 (ohci, ED_H);\r\nwhile (tmp != &ed->td_list) {\r\nstruct td *next;\r\nnext = list_entry (tmp, struct td, td_list);\r\ntmp = next->td_list.next;\r\nif (next->urb != urb)\r\nbreak;\r\nlist_del(&next->td_list);\r\nurb_priv->td_cnt++;\r\ned->hwHeadP = next->hwNextTD | toggle;\r\n}\r\nswitch (cc) {\r\ncase TD_DATAUNDERRUN:\r\nif ((urb->transfer_flags & URB_SHORT_NOT_OK) == 0)\r\nbreak;\r\ncase TD_CC_STALL:\r\nif (usb_pipecontrol (urb->pipe))\r\nbreak;\r\ndefault:\r\nohci_dbg (ohci,\r\n"urb %p path %s ep%d%s %08x cc %d --> status %d\n",\r\nurb, urb->dev->devpath,\r\nusb_pipeendpoint (urb->pipe),\r\nusb_pipein (urb->pipe) ? "in" : "out",\r\nhc32_to_cpu (ohci, td->hwINFO),\r\ncc, cc_to_error [cc]);\r\n}\r\n}\r\nstatic struct td *dl_reverse_done_list (struct ohci_hcd *ohci)\r\n{\r\nu32 td_dma;\r\nstruct td *td_rev = NULL;\r\nstruct td *td = NULL;\r\ntd_dma = hc32_to_cpup (ohci, &ohci->hcca->done_head);\r\nohci->hcca->done_head = 0;\r\nwmb();\r\nwhile (td_dma) {\r\nint cc;\r\ntd = dma_to_td (ohci, td_dma);\r\nif (!td) {\r\nohci_err (ohci, "bad entry %8x\n", td_dma);\r\nbreak;\r\n}\r\ntd->hwINFO |= cpu_to_hc32 (ohci, TD_DONE);\r\ncc = TD_CC_GET (hc32_to_cpup (ohci, &td->hwINFO));\r\nif (cc != TD_CC_NOERROR\r\n&& (td->ed->hwHeadP & cpu_to_hc32 (ohci, ED_H)))\r\ned_halted(ohci, td, cc);\r\ntd->next_dl_td = td_rev;\r\ntd_rev = td;\r\ntd_dma = hc32_to_cpup (ohci, &td->hwNextTD);\r\n}\r\nreturn td_rev;\r\n}\r\nstatic void\r\nfinish_unlinks (struct ohci_hcd *ohci, u16 tick)\r\n{\r\nstruct ed *ed, **last;\r\nrescan_all:\r\nfor (last = &ohci->ed_rm_list, ed = *last; ed != NULL; ed = *last) {\r\nstruct list_head *entry, *tmp;\r\nint completed, modified;\r\n__hc32 *prev;\r\nif (likely(ohci->rh_state == OHCI_RH_RUNNING)) {\r\nif (tick_before (tick, ed->tick)) {\r\nskip_ed:\r\nlast = &ed->ed_next;\r\ncontinue;\r\n}\r\nif (!list_empty (&ed->td_list)) {\r\nstruct td *td;\r\nu32 head;\r\ntd = list_entry (ed->td_list.next, struct td,\r\ntd_list);\r\nhead = hc32_to_cpu (ohci, ed->hwHeadP) &\r\nTD_MASK;\r\nif (td->td_dma != head) {\r\nif (ed == ohci->ed_to_check)\r\nohci->ed_to_check = NULL;\r\nelse\r\ngoto skip_ed;\r\n}\r\n}\r\n}\r\n*last = ed->ed_next;\r\ned->ed_next = NULL;\r\nmodified = 0;\r\nrescan_this:\r\ncompleted = 0;\r\nprev = &ed->hwHeadP;\r\nlist_for_each_safe (entry, tmp, &ed->td_list) {\r\nstruct td *td;\r\nstruct urb *urb;\r\nurb_priv_t *urb_priv;\r\n__hc32 savebits;\r\nu32 tdINFO;\r\ntd = list_entry (entry, struct td, td_list);\r\nurb = td->urb;\r\nurb_priv = td->urb->hcpriv;\r\nif (!urb->unlinked) {\r\nprev = &td->hwNextTD;\r\ncontinue;\r\n}\r\nsavebits = *prev & ~cpu_to_hc32 (ohci, TD_MASK);\r\n*prev = td->hwNextTD | savebits;\r\ntdINFO = hc32_to_cpup(ohci, &td->hwINFO);\r\nif ((tdINFO & TD_T) == TD_T_DATA0)\r\ned->hwHeadP &= ~cpu_to_hc32(ohci, ED_C);\r\nelse if ((tdINFO & TD_T) == TD_T_DATA1)\r\ned->hwHeadP |= cpu_to_hc32(ohci, ED_C);\r\ntd_done (ohci, urb, td);\r\nurb_priv->td_cnt++;\r\nif (urb_priv->td_cnt >= urb_priv->length) {\r\nmodified = completed = 1;\r\nfinish_urb(ohci, urb, 0);\r\n}\r\n}\r\nif (completed && !list_empty (&ed->td_list))\r\ngoto rescan_this;\r\ned->state = ED_IDLE;\r\nif (quirk_zfmicro(ohci) && ed->type == PIPE_INTERRUPT)\r\nohci->eds_scheduled--;\r\ned->hwHeadP &= ~cpu_to_hc32(ohci, ED_H);\r\ned->hwNextED = 0;\r\nwmb ();\r\ned->hwINFO &= ~cpu_to_hc32 (ohci, ED_SKIP | ED_DEQUEUE);\r\nif (!list_empty (&ed->td_list)) {\r\nif (ohci->rh_state == OHCI_RH_RUNNING)\r\ned_schedule (ohci, ed);\r\n}\r\nif (modified)\r\ngoto rescan_all;\r\n}\r\nif (ohci->rh_state == OHCI_RH_RUNNING && !ohci->ed_rm_list) {\r\nu32 command = 0, control = 0;\r\nif (ohci->ed_controltail) {\r\ncommand |= OHCI_CLF;\r\nif (quirk_zfmicro(ohci))\r\nmdelay(1);\r\nif (!(ohci->hc_control & OHCI_CTRL_CLE)) {\r\ncontrol |= OHCI_CTRL_CLE;\r\nohci_writel (ohci, 0,\r\n&ohci->regs->ed_controlcurrent);\r\n}\r\n}\r\nif (ohci->ed_bulktail) {\r\ncommand |= OHCI_BLF;\r\nif (quirk_zfmicro(ohci))\r\nmdelay(1);\r\nif (!(ohci->hc_control & OHCI_CTRL_BLE)) {\r\ncontrol |= OHCI_CTRL_BLE;\r\nohci_writel (ohci, 0,\r\n&ohci->regs->ed_bulkcurrent);\r\n}\r\n}\r\nif (control) {\r\nohci->hc_control |= control;\r\nif (quirk_zfmicro(ohci))\r\nmdelay(1);\r\nohci_writel (ohci, ohci->hc_control,\r\n&ohci->regs->control);\r\n}\r\nif (command) {\r\nif (quirk_zfmicro(ohci))\r\nmdelay(1);\r\nohci_writel (ohci, command, &ohci->regs->cmdstatus);\r\n}\r\n}\r\n}\r\nstatic void takeback_td(struct ohci_hcd *ohci, struct td *td)\r\n{\r\nstruct urb *urb = td->urb;\r\nurb_priv_t *urb_priv = urb->hcpriv;\r\nstruct ed *ed = td->ed;\r\nint status;\r\nstatus = td_done(ohci, urb, td);\r\nurb_priv->td_cnt++;\r\nif (urb_priv->td_cnt >= urb_priv->length)\r\nfinish_urb(ohci, urb, status);\r\nif (list_empty(&ed->td_list)) {\r\nif (ed->state == ED_OPER)\r\nstart_ed_unlink(ohci, ed);\r\n} else if ((ed->hwINFO & cpu_to_hc32(ohci, ED_SKIP | ED_DEQUEUE))\r\n== cpu_to_hc32(ohci, ED_SKIP)) {\r\ntd = list_entry(ed->td_list.next, struct td, td_list);\r\nif (!(td->hwINFO & cpu_to_hc32(ohci, TD_DONE))) {\r\ned->hwINFO &= ~cpu_to_hc32(ohci, ED_SKIP);\r\nswitch (ed->type) {\r\ncase PIPE_CONTROL:\r\nohci_writel(ohci, OHCI_CLF,\r\n&ohci->regs->cmdstatus);\r\nbreak;\r\ncase PIPE_BULK:\r\nohci_writel(ohci, OHCI_BLF,\r\n&ohci->regs->cmdstatus);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\ndl_done_list (struct ohci_hcd *ohci)\r\n{\r\nstruct td *td = dl_reverse_done_list (ohci);\r\nwhile (td) {\r\nstruct td *td_next = td->next_dl_td;\r\nstruct ed *ed = td->ed;\r\nfor (;;) {\r\nstruct td *td2;\r\ntd2 = list_first_entry(&ed->td_list, struct td,\r\ntd_list);\r\nif (td2 == td)\r\nbreak;\r\ntakeback_td(ohci, td2);\r\n}\r\ntakeback_td(ohci, td);\r\ntd = td_next;\r\n}\r\n}
