static int vmw_gmrid_man_get_node(struct ttm_mem_type_manager *man,\r\nstruct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct vmwgfx_gmrid_man *gman =\r\n(struct vmwgfx_gmrid_man *)man->priv;\r\nint ret = 0;\r\nint id;\r\nmem->mm_node = NULL;\r\nspin_lock(&gman->lock);\r\nif (gman->max_gmr_pages > 0) {\r\ngman->used_gmr_pages += bo->num_pages;\r\nif (unlikely(gman->used_gmr_pages > gman->max_gmr_pages))\r\ngoto out_err_locked;\r\n}\r\ndo {\r\nspin_unlock(&gman->lock);\r\nif (unlikely(ida_pre_get(&gman->gmr_ida, GFP_KERNEL) == 0)) {\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\nspin_lock(&gman->lock);\r\nret = ida_get_new(&gman->gmr_ida, &id);\r\nif (unlikely(ret == 0 && id >= gman->max_gmr_ids)) {\r\nida_remove(&gman->gmr_ida, id);\r\nret = 0;\r\ngoto out_err_locked;\r\n}\r\n} while (ret == -EAGAIN);\r\nif (likely(ret == 0)) {\r\nmem->mm_node = gman;\r\nmem->start = id;\r\nmem->num_pages = bo->num_pages;\r\n} else\r\ngoto out_err_locked;\r\nspin_unlock(&gman->lock);\r\nreturn 0;\r\nout_err:\r\nspin_lock(&gman->lock);\r\nout_err_locked:\r\ngman->used_gmr_pages -= bo->num_pages;\r\nspin_unlock(&gman->lock);\r\nreturn ret;\r\n}\r\nstatic void vmw_gmrid_man_put_node(struct ttm_mem_type_manager *man,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct vmwgfx_gmrid_man *gman =\r\n(struct vmwgfx_gmrid_man *)man->priv;\r\nif (mem->mm_node) {\r\nspin_lock(&gman->lock);\r\nida_remove(&gman->gmr_ida, mem->start);\r\ngman->used_gmr_pages -= mem->num_pages;\r\nspin_unlock(&gman->lock);\r\nmem->mm_node = NULL;\r\n}\r\n}\r\nstatic int vmw_gmrid_man_init(struct ttm_mem_type_manager *man,\r\nunsigned long p_size)\r\n{\r\nstruct vmw_private *dev_priv =\r\ncontainer_of(man->bdev, struct vmw_private, bdev);\r\nstruct vmwgfx_gmrid_man *gman =\r\nkzalloc(sizeof(*gman), GFP_KERNEL);\r\nif (unlikely(gman == NULL))\r\nreturn -ENOMEM;\r\nspin_lock_init(&gman->lock);\r\ngman->used_gmr_pages = 0;\r\nida_init(&gman->gmr_ida);\r\nswitch (p_size) {\r\ncase VMW_PL_GMR:\r\ngman->max_gmr_ids = dev_priv->max_gmr_ids;\r\ngman->max_gmr_pages = dev_priv->max_gmr_pages;\r\nbreak;\r\ncase VMW_PL_MOB:\r\ngman->max_gmr_ids = VMWGFX_NUM_MOB;\r\ngman->max_gmr_pages = dev_priv->max_mob_pages;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nman->priv = (void *) gman;\r\nreturn 0;\r\n}\r\nstatic int vmw_gmrid_man_takedown(struct ttm_mem_type_manager *man)\r\n{\r\nstruct vmwgfx_gmrid_man *gman =\r\n(struct vmwgfx_gmrid_man *)man->priv;\r\nif (gman) {\r\nida_destroy(&gman->gmr_ida);\r\nkfree(gman);\r\n}\r\nreturn 0;\r\n}\r\nstatic void vmw_gmrid_man_debug(struct ttm_mem_type_manager *man,\r\nconst char *prefix)\r\n{\r\nprintk(KERN_INFO "%s: No debug info available for the GMR "\r\n"id manager.\n", prefix);\r\n}
