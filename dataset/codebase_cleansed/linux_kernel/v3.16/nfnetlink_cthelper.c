static int\r\nnfnl_userspace_cthelper(struct sk_buff *skb, unsigned int protoff,\r\nstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\r\n{\r\nconst struct nf_conn_help *help;\r\nstruct nf_conntrack_helper *helper;\r\nhelp = nfct_help(ct);\r\nif (help == NULL)\r\nreturn NF_DROP;\r\nhelper = rcu_dereference(help->helper);\r\nif (helper == NULL)\r\nreturn NF_DROP;\r\nif ((helper->flags &\r\n(NF_CT_HELPER_F_USERSPACE | NF_CT_HELPER_F_CONFIGURED)) ==\r\nNF_CT_HELPER_F_USERSPACE)\r\nreturn NF_ACCEPT;\r\nreturn NF_QUEUE_NR(helper->queue_num) | NF_VERDICT_FLAG_QUEUE_BYPASS;\r\n}\r\nstatic int\r\nnfnl_cthelper_parse_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nlattr *attr)\r\n{\r\nint err;\r\nstruct nlattr *tb[NFCTH_TUPLE_MAX+1];\r\nerr = nla_parse_nested(tb, NFCTH_TUPLE_MAX, attr, nfnl_cthelper_tuple_pol);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[NFCTH_TUPLE_L3PROTONUM] || !tb[NFCTH_TUPLE_L4PROTONUM])\r\nreturn -EINVAL;\r\ntuple->src.l3num = ntohs(nla_get_be16(tb[NFCTH_TUPLE_L3PROTONUM]));\r\ntuple->dst.protonum = nla_get_u8(tb[NFCTH_TUPLE_L4PROTONUM]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfnl_cthelper_from_nlattr(struct nlattr *attr, struct nf_conn *ct)\r\n{\r\nconst struct nf_conn_help *help = nfct_help(ct);\r\nif (attr == NULL)\r\nreturn -EINVAL;\r\nif (help->helper->data_len == 0)\r\nreturn -EINVAL;\r\nmemcpy(&help->data, nla_data(attr), help->helper->data_len);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfnl_cthelper_to_nlattr(struct sk_buff *skb, const struct nf_conn *ct)\r\n{\r\nconst struct nf_conn_help *help = nfct_help(ct);\r\nif (help->helper->data_len &&\r\nnla_put(skb, CTA_HELP_INFO, help->helper->data_len, &help->data))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -ENOSPC;\r\n}\r\nstatic int\r\nnfnl_cthelper_expect_policy(struct nf_conntrack_expect_policy *expect_policy,\r\nconst struct nlattr *attr)\r\n{\r\nint err;\r\nstruct nlattr *tb[NFCTH_POLICY_MAX+1];\r\nerr = nla_parse_nested(tb, NFCTH_POLICY_MAX, attr, nfnl_cthelper_expect_pol);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[NFCTH_POLICY_NAME] ||\r\n!tb[NFCTH_POLICY_EXPECT_MAX] ||\r\n!tb[NFCTH_POLICY_EXPECT_TIMEOUT])\r\nreturn -EINVAL;\r\nstrncpy(expect_policy->name,\r\nnla_data(tb[NFCTH_POLICY_NAME]), NF_CT_HELPER_NAME_LEN);\r\nexpect_policy->max_expected =\r\nntohl(nla_get_be32(tb[NFCTH_POLICY_EXPECT_MAX]));\r\nexpect_policy->timeout =\r\nntohl(nla_get_be32(tb[NFCTH_POLICY_EXPECT_TIMEOUT]));\r\nreturn 0;\r\n}\r\nstatic int\r\nnfnl_cthelper_parse_expect_policy(struct nf_conntrack_helper *helper,\r\nconst struct nlattr *attr)\r\n{\r\nint i, ret;\r\nstruct nf_conntrack_expect_policy *expect_policy;\r\nstruct nlattr *tb[NFCTH_POLICY_SET_MAX+1];\r\nret = nla_parse_nested(tb, NFCTH_POLICY_SET_MAX, attr,\r\nnfnl_cthelper_expect_policy_set);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!tb[NFCTH_POLICY_SET_NUM])\r\nreturn -EINVAL;\r\nhelper->expect_class_max =\r\nntohl(nla_get_be32(tb[NFCTH_POLICY_SET_NUM]));\r\nif (helper->expect_class_max != 0 &&\r\nhelper->expect_class_max > NF_CT_MAX_EXPECT_CLASSES)\r\nreturn -EOVERFLOW;\r\nexpect_policy = kzalloc(sizeof(struct nf_conntrack_expect_policy) *\r\nhelper->expect_class_max, GFP_KERNEL);\r\nif (expect_policy == NULL)\r\nreturn -ENOMEM;\r\nfor (i=0; i<helper->expect_class_max; i++) {\r\nif (!tb[NFCTH_POLICY_SET+i])\r\ngoto err;\r\nret = nfnl_cthelper_expect_policy(&expect_policy[i],\r\ntb[NFCTH_POLICY_SET+i]);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nhelper->expect_policy = expect_policy;\r\nreturn 0;\r\nerr:\r\nkfree(expect_policy);\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnfnl_cthelper_create(const struct nlattr * const tb[],\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nstruct nf_conntrack_helper *helper;\r\nint ret;\r\nif (!tb[NFCTH_TUPLE] || !tb[NFCTH_POLICY] || !tb[NFCTH_PRIV_DATA_LEN])\r\nreturn -EINVAL;\r\nhelper = kzalloc(sizeof(struct nf_conntrack_helper), GFP_KERNEL);\r\nif (helper == NULL)\r\nreturn -ENOMEM;\r\nret = nfnl_cthelper_parse_expect_policy(helper, tb[NFCTH_POLICY]);\r\nif (ret < 0)\r\ngoto err;\r\nstrncpy(helper->name, nla_data(tb[NFCTH_NAME]), NF_CT_HELPER_NAME_LEN);\r\nhelper->data_len = ntohl(nla_get_be32(tb[NFCTH_PRIV_DATA_LEN]));\r\nhelper->flags |= NF_CT_HELPER_F_USERSPACE;\r\nmemcpy(&helper->tuple, tuple, sizeof(struct nf_conntrack_tuple));\r\nhelper->me = THIS_MODULE;\r\nhelper->help = nfnl_userspace_cthelper;\r\nhelper->from_nlattr = nfnl_cthelper_from_nlattr;\r\nhelper->to_nlattr = nfnl_cthelper_to_nlattr;\r\nif (tb[NFCTH_QUEUE_NUM])\r\nhelper->queue_num = ntohl(nla_get_be32(tb[NFCTH_QUEUE_NUM]));\r\nif (tb[NFCTH_STATUS]) {\r\nint status = ntohl(nla_get_be32(tb[NFCTH_STATUS]));\r\nswitch(status) {\r\ncase NFCT_HELPER_STATUS_ENABLED:\r\nhelper->flags |= NF_CT_HELPER_F_CONFIGURED;\r\nbreak;\r\ncase NFCT_HELPER_STATUS_DISABLED:\r\nhelper->flags &= ~NF_CT_HELPER_F_CONFIGURED;\r\nbreak;\r\n}\r\n}\r\nret = nf_conntrack_helper_register(helper);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkfree(helper);\r\nreturn ret;\r\n}\r\nstatic int\r\nnfnl_cthelper_update(const struct nlattr * const tb[],\r\nstruct nf_conntrack_helper *helper)\r\n{\r\nint ret;\r\nif (tb[NFCTH_PRIV_DATA_LEN])\r\nreturn -EBUSY;\r\nif (tb[NFCTH_POLICY]) {\r\nret = nfnl_cthelper_parse_expect_policy(helper,\r\ntb[NFCTH_POLICY]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (tb[NFCTH_QUEUE_NUM])\r\nhelper->queue_num = ntohl(nla_get_be32(tb[NFCTH_QUEUE_NUM]));\r\nif (tb[NFCTH_STATUS]) {\r\nint status = ntohl(nla_get_be32(tb[NFCTH_STATUS]));\r\nswitch(status) {\r\ncase NFCT_HELPER_STATUS_ENABLED:\r\nhelper->flags |= NF_CT_HELPER_F_CONFIGURED;\r\nbreak;\r\ncase NFCT_HELPER_STATUS_DISABLED:\r\nhelper->flags &= ~NF_CT_HELPER_F_CONFIGURED;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnfnl_cthelper_new(struct sock *nfnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh, const struct nlattr * const tb[])\r\n{\r\nconst char *helper_name;\r\nstruct nf_conntrack_helper *cur, *helper = NULL;\r\nstruct nf_conntrack_tuple tuple;\r\nint ret = 0, i;\r\nif (!tb[NFCTH_NAME] || !tb[NFCTH_TUPLE])\r\nreturn -EINVAL;\r\nhelper_name = nla_data(tb[NFCTH_NAME]);\r\nret = nfnl_cthelper_parse_tuple(&tuple, tb[NFCTH_TUPLE]);\r\nif (ret < 0)\r\nreturn ret;\r\nrcu_read_lock();\r\nfor (i = 0; i < nf_ct_helper_hsize && !helper; i++) {\r\nhlist_for_each_entry_rcu(cur, &nf_ct_helper_hash[i], hnode) {\r\nif (!(cur->flags & NF_CT_HELPER_F_USERSPACE))\r\ncontinue;\r\nif (strncmp(cur->name, helper_name,\r\nNF_CT_HELPER_NAME_LEN) != 0)\r\ncontinue;\r\nif ((tuple.src.l3num != cur->tuple.src.l3num ||\r\ntuple.dst.protonum != cur->tuple.dst.protonum))\r\ncontinue;\r\nif (nlh->nlmsg_flags & NLM_F_EXCL) {\r\nret = -EEXIST;\r\ngoto err;\r\n}\r\nhelper = cur;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (helper == NULL)\r\nret = nfnl_cthelper_create(tb, &tuple);\r\nelse\r\nret = nfnl_cthelper_update(tb, helper);\r\nreturn ret;\r\nerr:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic int\r\nnfnl_cthelper_dump_tuple(struct sk_buff *skb,\r\nstruct nf_conntrack_helper *helper)\r\n{\r\nstruct nlattr *nest_parms;\r\nnest_parms = nla_nest_start(skb, NFCTH_TUPLE | NLA_F_NESTED);\r\nif (nest_parms == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put_be16(skb, NFCTH_TUPLE_L3PROTONUM,\r\nhtons(helper->tuple.src.l3num)))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, NFCTH_TUPLE_L4PROTONUM, helper->tuple.dst.protonum))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int\r\nnfnl_cthelper_dump_policy(struct sk_buff *skb,\r\nstruct nf_conntrack_helper *helper)\r\n{\r\nint i;\r\nstruct nlattr *nest_parms1, *nest_parms2;\r\nnest_parms1 = nla_nest_start(skb, NFCTH_POLICY | NLA_F_NESTED);\r\nif (nest_parms1 == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFCTH_POLICY_SET_NUM,\r\nhtonl(helper->expect_class_max)))\r\ngoto nla_put_failure;\r\nfor (i=0; i<helper->expect_class_max; i++) {\r\nnest_parms2 = nla_nest_start(skb,\r\n(NFCTH_POLICY_SET+i) | NLA_F_NESTED);\r\nif (nest_parms2 == NULL)\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, NFCTH_POLICY_NAME,\r\nhelper->expect_policy[i].name))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFCTH_POLICY_EXPECT_MAX,\r\nhtonl(helper->expect_policy[i].max_expected)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFCTH_POLICY_EXPECT_TIMEOUT,\r\nhtonl(helper->expect_policy[i].timeout)))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms2);\r\n}\r\nnla_nest_end(skb, nest_parms1);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int\r\nnfnl_cthelper_fill_info(struct sk_buff *skb, u32 portid, u32 seq, u32 type,\r\nint event, struct nf_conntrack_helper *helper)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nunsigned int flags = portid ? NLM_F_MULTI : 0;\r\nint status;\r\nevent |= NFNL_SUBSYS_CTHELPER << 8;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\ngoto nlmsg_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = AF_UNSPEC;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = 0;\r\nif (nla_put_string(skb, NFCTH_NAME, helper->name))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFCTH_QUEUE_NUM, htonl(helper->queue_num)))\r\ngoto nla_put_failure;\r\nif (nfnl_cthelper_dump_tuple(skb, helper) < 0)\r\ngoto nla_put_failure;\r\nif (nfnl_cthelper_dump_policy(skb, helper) < 0)\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFCTH_PRIV_DATA_LEN, htonl(helper->data_len)))\r\ngoto nla_put_failure;\r\nif (helper->flags & NF_CT_HELPER_F_CONFIGURED)\r\nstatus = NFCT_HELPER_STATUS_ENABLED;\r\nelse\r\nstatus = NFCT_HELPER_STATUS_DISABLED;\r\nif (nla_put_be32(skb, NFCTH_STATUS, htonl(status)))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn skb->len;\r\nnlmsg_failure:\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int\r\nnfnl_cthelper_dump_table(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct nf_conntrack_helper *cur, *last;\r\nrcu_read_lock();\r\nlast = (struct nf_conntrack_helper *)cb->args[1];\r\nfor (; cb->args[0] < nf_ct_helper_hsize; cb->args[0]++) {\r\nrestart:\r\nhlist_for_each_entry_rcu(cur,\r\n&nf_ct_helper_hash[cb->args[0]], hnode) {\r\nif (!(cur->flags & NF_CT_HELPER_F_USERSPACE))\r\ncontinue;\r\nif (cb->args[1]) {\r\nif (cur != last)\r\ncontinue;\r\ncb->args[1] = 0;\r\n}\r\nif (nfnl_cthelper_fill_info(skb,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(cb->nlh->nlmsg_type),\r\nNFNL_MSG_CTHELPER_NEW, cur) < 0) {\r\ncb->args[1] = (unsigned long)cur;\r\ngoto out;\r\n}\r\n}\r\n}\r\nif (cb->args[1]) {\r\ncb->args[1] = 0;\r\ngoto restart;\r\n}\r\nout:\r\nrcu_read_unlock();\r\nreturn skb->len;\r\n}\r\nstatic int\r\nnfnl_cthelper_get(struct sock *nfnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh, const struct nlattr * const tb[])\r\n{\r\nint ret = -ENOENT, i;\r\nstruct nf_conntrack_helper *cur;\r\nstruct sk_buff *skb2;\r\nchar *helper_name = NULL;\r\nstruct nf_conntrack_tuple tuple;\r\nbool tuple_set = false;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = nfnl_cthelper_dump_table,\r\n};\r\nreturn netlink_dump_start(nfnl, skb, nlh, &c);\r\n}\r\nif (tb[NFCTH_NAME])\r\nhelper_name = nla_data(tb[NFCTH_NAME]);\r\nif (tb[NFCTH_TUPLE]) {\r\nret = nfnl_cthelper_parse_tuple(&tuple, tb[NFCTH_TUPLE]);\r\nif (ret < 0)\r\nreturn ret;\r\ntuple_set = true;\r\n}\r\nfor (i = 0; i < nf_ct_helper_hsize; i++) {\r\nhlist_for_each_entry_rcu(cur, &nf_ct_helper_hash[i], hnode) {\r\nif (!(cur->flags & NF_CT_HELPER_F_USERSPACE))\r\ncontinue;\r\nif (helper_name && strncmp(cur->name, helper_name,\r\nNF_CT_HELPER_NAME_LEN) != 0) {\r\ncontinue;\r\n}\r\nif (tuple_set &&\r\n(tuple.src.l3num != cur->tuple.src.l3num ||\r\ntuple.dst.protonum != cur->tuple.dst.protonum))\r\ncontinue;\r\nskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb2 == NULL) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nret = nfnl_cthelper_fill_info(skb2, NETLINK_CB(skb).portid,\r\nnlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(nlh->nlmsg_type),\r\nNFNL_MSG_CTHELPER_NEW, cur);\r\nif (ret <= 0) {\r\nkfree_skb(skb2);\r\nbreak;\r\n}\r\nret = netlink_unicast(nfnl, skb2, NETLINK_CB(skb).portid,\r\nMSG_DONTWAIT);\r\nif (ret > 0)\r\nret = 0;\r\nreturn ret == -EAGAIN ? -ENOBUFS : ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnfnl_cthelper_del(struct sock *nfnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh, const struct nlattr * const tb[])\r\n{\r\nchar *helper_name = NULL;\r\nstruct nf_conntrack_helper *cur;\r\nstruct hlist_node *tmp;\r\nstruct nf_conntrack_tuple tuple;\r\nbool tuple_set = false, found = false;\r\nint i, j = 0, ret;\r\nif (tb[NFCTH_NAME])\r\nhelper_name = nla_data(tb[NFCTH_NAME]);\r\nif (tb[NFCTH_TUPLE]) {\r\nret = nfnl_cthelper_parse_tuple(&tuple, tb[NFCTH_TUPLE]);\r\nif (ret < 0)\r\nreturn ret;\r\ntuple_set = true;\r\n}\r\nfor (i = 0; i < nf_ct_helper_hsize; i++) {\r\nhlist_for_each_entry_safe(cur, tmp, &nf_ct_helper_hash[i],\r\nhnode) {\r\nif (!(cur->flags & NF_CT_HELPER_F_USERSPACE))\r\ncontinue;\r\nj++;\r\nif (helper_name && strncmp(cur->name, helper_name,\r\nNF_CT_HELPER_NAME_LEN) != 0) {\r\ncontinue;\r\n}\r\nif (tuple_set &&\r\n(tuple.src.l3num != cur->tuple.src.l3num ||\r\ntuple.dst.protonum != cur->tuple.dst.protonum))\r\ncontinue;\r\nfound = true;\r\nnf_conntrack_helper_unregister(cur);\r\n}\r\n}\r\nreturn (found || j == 0) ? 0 : -ENOENT;\r\n}\r\nstatic int __init nfnl_cthelper_init(void)\r\n{\r\nint ret;\r\nret = nfnetlink_subsys_register(&nfnl_cthelper_subsys);\r\nif (ret < 0) {\r\npr_err("nfnl_cthelper: cannot register with nfnetlink.\n");\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic void __exit nfnl_cthelper_exit(void)\r\n{\r\nstruct nf_conntrack_helper *cur;\r\nstruct hlist_node *tmp;\r\nint i;\r\nnfnetlink_subsys_unregister(&nfnl_cthelper_subsys);\r\nfor (i=0; i<nf_ct_helper_hsize; i++) {\r\nhlist_for_each_entry_safe(cur, tmp, &nf_ct_helper_hash[i],\r\nhnode) {\r\nif (!(cur->flags & NF_CT_HELPER_F_USERSPACE))\r\ncontinue;\r\nnf_conntrack_helper_unregister(cur);\r\n}\r\n}\r\n}
