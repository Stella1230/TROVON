static int snd_es1688_match(struct device *dev, unsigned int n)\r\n{\r\nreturn enable[n] && !is_isapnp_selected(n);\r\n}\r\nstatic int snd_es1688_legacy_create(struct snd_card *card,\r\nstruct device *dev, unsigned int n)\r\n{\r\nstruct snd_es1688 *chip = card->private_data;\r\nstatic long possible_ports[] = {0x220, 0x240, 0x260};\r\nstatic int possible_irqs[] = {5, 9, 10, 7, -1};\r\nstatic int possible_dmas[] = {1, 3, 0, -1};\r\nint i, error;\r\nif (irq[n] == SNDRV_AUTO_IRQ) {\r\nirq[n] = snd_legacy_find_free_irq(possible_irqs);\r\nif (irq[n] < 0) {\r\ndev_err(dev, "unable to find a free IRQ\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma8[n] == SNDRV_AUTO_DMA) {\r\ndma8[n] = snd_legacy_find_free_dma(possible_dmas);\r\nif (dma8[n] < 0) {\r\ndev_err(dev, "unable to find a free DMA\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (port[n] != SNDRV_AUTO_PORT)\r\nreturn snd_es1688_create(card, chip, port[n], mpu_port[n],\r\nirq[n], mpu_irq[n], dma8[n], ES1688_HW_AUTO);\r\ni = 0;\r\ndo {\r\nport[n] = possible_ports[i];\r\nerror = snd_es1688_create(card, chip, port[n], mpu_port[n],\r\nirq[n], mpu_irq[n], dma8[n], ES1688_HW_AUTO);\r\n} while (error < 0 && ++i < ARRAY_SIZE(possible_ports));\r\nreturn error;\r\n}\r\nstatic int snd_es1688_probe(struct snd_card *card, unsigned int n)\r\n{\r\nstruct snd_es1688 *chip = card->private_data;\r\nstruct snd_opl3 *opl3;\r\nstruct snd_pcm *pcm;\r\nint error;\r\nerror = snd_es1688_pcm(card, chip, 0, &pcm);\r\nif (error < 0)\r\nreturn error;\r\nerror = snd_es1688_mixer(card, chip);\r\nif (error < 0)\r\nreturn error;\r\nstrlcpy(card->driver, "ES1688", sizeof(card->driver));\r\nstrlcpy(card->shortname, pcm->name, sizeof(card->shortname));\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s at 0x%lx, irq %i, dma %i", pcm->name, chip->port,\r\nchip->irq, chip->dma8);\r\nif (fm_port[n] == SNDRV_AUTO_PORT)\r\nfm_port[n] = port[n];\r\nif (fm_port[n] > 0) {\r\nif (snd_opl3_create(card, fm_port[n], fm_port[n] + 2,\r\nOPL3_HW_OPL3, 0, &opl3) < 0)\r\ndev_warn(card->dev,\r\n"opl3 not detected at 0x%lx\n", fm_port[n]);\r\nelse {\r\nerror = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\r\nif (error < 0)\r\nreturn error;\r\n}\r\n}\r\nif (mpu_irq[n] >= 0 && mpu_irq[n] != SNDRV_AUTO_IRQ &&\r\nchip->mpu_port > 0) {\r\nerror = snd_mpu401_uart_new(card, 0, MPU401_HW_ES1688,\r\nchip->mpu_port, 0,\r\nmpu_irq[n], NULL);\r\nif (error < 0)\r\nreturn error;\r\n}\r\nreturn snd_card_register(card);\r\n}\r\nstatic int snd_es1688_isa_probe(struct device *dev, unsigned int n)\r\n{\r\nstruct snd_card *card;\r\nint error;\r\nerror = snd_card_new(dev, index[n], id[n], THIS_MODULE,\r\nsizeof(struct snd_es1688), &card);\r\nif (error < 0)\r\nreturn error;\r\nerror = snd_es1688_legacy_create(card, dev, n);\r\nif (error < 0)\r\ngoto out;\r\nerror = snd_es1688_probe(card, n);\r\nif (error < 0)\r\ngoto out;\r\ndev_set_drvdata(dev, card);\r\nreturn 0;\r\nout:\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\nstatic int snd_es1688_isa_remove(struct device *dev, unsigned int n)\r\n{\r\nsnd_card_free(dev_get_drvdata(dev));\r\nreturn 0;\r\n}\r\nstatic int snd_card_es968_pnp(struct snd_card *card, unsigned int n,\r\nstruct pnp_card_link *pcard,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nstruct snd_es1688 *chip = card->private_data;\r\nstruct pnp_dev *pdev;\r\nint error;\r\npdev = pnp_request_card_device(pcard, pid->devs[0].id, NULL);\r\nif (pdev == NULL)\r\nreturn -ENODEV;\r\nerror = pnp_activate_dev(pdev);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "ES968 pnp configure failure\n");\r\nreturn error;\r\n}\r\nport[n] = pnp_port_start(pdev, 0);\r\ndma8[n] = pnp_dma(pdev, 0);\r\nirq[n] = pnp_irq(pdev, 0);\r\nreturn snd_es1688_create(card, chip, port[n], mpu_port[n], irq[n],\r\nmpu_irq[n], dma8[n], ES1688_HW_AUTO);\r\n}\r\nstatic int snd_es968_pnp_detect(struct pnp_card_link *pcard,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nstruct snd_card *card;\r\nstatic unsigned int dev;\r\nint error;\r\nstruct snd_es1688 *chip;\r\nif (snd_es968_pnp_is_probed)\r\nreturn -EBUSY;\r\nfor ( ; dev < SNDRV_CARDS; dev++) {\r\nif (enable[dev] && isapnp[dev])\r\nbreak;\r\n}\r\nif (dev == SNDRV_CARDS)\r\nreturn -ENODEV;\r\nerror = snd_card_new(&pcard->card->dev,\r\nindex[dev], id[dev], THIS_MODULE,\r\nsizeof(struct snd_es1688), &card);\r\nif (error < 0)\r\nreturn error;\r\nchip = card->private_data;\r\nerror = snd_card_es968_pnp(card, dev, pcard, pid);\r\nif (error < 0) {\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\nerror = snd_es1688_probe(card, dev);\r\nif (error < 0)\r\nreturn error;\r\npnp_set_card_drvdata(pcard, card);\r\nsnd_es968_pnp_is_probed = 1;\r\nreturn 0;\r\n}\r\nstatic void snd_es968_pnp_remove(struct pnp_card_link *pcard)\r\n{\r\nsnd_card_free(pnp_get_card_drvdata(pcard));\r\npnp_set_card_drvdata(pcard, NULL);\r\nsnd_es968_pnp_is_probed = 0;\r\n}\r\nstatic int snd_es968_pnp_suspend(struct pnp_card_link *pcard,\r\npm_message_t state)\r\n{\r\nstruct snd_card *card = pnp_get_card_drvdata(pcard);\r\nstruct snd_es1688 *chip = card->private_data;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nreturn 0;\r\n}\r\nstatic int snd_es968_pnp_resume(struct pnp_card_link *pcard)\r\n{\r\nstruct snd_card *card = pnp_get_card_drvdata(pcard);\r\nstruct snd_es1688 *chip = card->private_data;\r\nsnd_es1688_reset(chip);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int __init alsa_card_es1688_init(void)\r\n{\r\n#ifdef CONFIG_PNP\r\npnp_register_card_driver(&es968_pnpc_driver);\r\nif (snd_es968_pnp_is_probed)\r\nreturn 0;\r\npnp_unregister_card_driver(&es968_pnpc_driver);\r\n#endif\r\nreturn isa_register_driver(&snd_es1688_driver, SNDRV_CARDS);\r\n}\r\nstatic void __exit alsa_card_es1688_exit(void)\r\n{\r\nif (!snd_es968_pnp_is_probed) {\r\nisa_unregister_driver(&snd_es1688_driver);\r\nreturn;\r\n}\r\n#ifdef CONFIG_PNP\r\npnp_unregister_card_driver(&es968_pnpc_driver);\r\n#endif\r\n}
