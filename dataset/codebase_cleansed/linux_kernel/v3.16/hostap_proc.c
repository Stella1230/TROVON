static int prism2_debug_proc_show(struct seq_file *m, void *v)\r\n{\r\nlocal_info_t *local = m->private;\r\nint i;\r\nseq_printf(m, "next_txfid=%d next_alloc=%d\n",\r\nlocal->next_txfid, local->next_alloc);\r\nfor (i = 0; i < PRISM2_TXFID_COUNT; i++)\r\nseq_printf(m, "FID: tx=%04X intransmit=%04X\n",\r\nlocal->txfid[i], local->intransmitfid[i]);\r\nseq_printf(m, "FW TX rate control: %d\n", local->fw_tx_rate_control);\r\nseq_printf(m, "beacon_int=%d\n", local->beacon_int);\r\nseq_printf(m, "dtim_period=%d\n", local->dtim_period);\r\nseq_printf(m, "wds_max_connections=%d\n", local->wds_max_connections);\r\nseq_printf(m, "dev_enabled=%d\n", local->dev_enabled);\r\nseq_printf(m, "sw_tick_stuck=%d\n", local->sw_tick_stuck);\r\nfor (i = 0; i < WEP_KEYS; i++) {\r\nif (local->crypt_info.crypt[i] &&\r\nlocal->crypt_info.crypt[i]->ops) {\r\nseq_printf(m, "crypt[%d]=%s\n", i,\r\nlocal->crypt_info.crypt[i]->ops->name);\r\n}\r\n}\r\nseq_printf(m, "pri_only=%d\n", local->pri_only);\r\nseq_printf(m, "pci=%d\n", local->func->hw_type == HOSTAP_HW_PCI);\r\nseq_printf(m, "sram_type=%d\n", local->sram_type);\r\nseq_printf(m, "no_pri=%d\n", local->no_pri);\r\nreturn 0;\r\n}\r\nstatic int prism2_debug_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, prism2_debug_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int prism2_stats_proc_show(struct seq_file *m, void *v)\r\n{\r\nlocal_info_t *local = m->private;\r\nstruct comm_tallies_sums *sums = &local->comm_tallies;\r\nseq_printf(m, "TxUnicastFrames=%u\n", sums->tx_unicast_frames);\r\nseq_printf(m, "TxMulticastframes=%u\n", sums->tx_multicast_frames);\r\nseq_printf(m, "TxFragments=%u\n", sums->tx_fragments);\r\nseq_printf(m, "TxUnicastOctets=%u\n", sums->tx_unicast_octets);\r\nseq_printf(m, "TxMulticastOctets=%u\n", sums->tx_multicast_octets);\r\nseq_printf(m, "TxDeferredTransmissions=%u\n",\r\nsums->tx_deferred_transmissions);\r\nseq_printf(m, "TxSingleRetryFrames=%u\n", sums->tx_single_retry_frames);\r\nseq_printf(m, "TxMultipleRetryFrames=%u\n",\r\nsums->tx_multiple_retry_frames);\r\nseq_printf(m, "TxRetryLimitExceeded=%u\n",\r\nsums->tx_retry_limit_exceeded);\r\nseq_printf(m, "TxDiscards=%u\n", sums->tx_discards);\r\nseq_printf(m, "RxUnicastFrames=%u\n", sums->rx_unicast_frames);\r\nseq_printf(m, "RxMulticastFrames=%u\n", sums->rx_multicast_frames);\r\nseq_printf(m, "RxFragments=%u\n", sums->rx_fragments);\r\nseq_printf(m, "RxUnicastOctets=%u\n", sums->rx_unicast_octets);\r\nseq_printf(m, "RxMulticastOctets=%u\n", sums->rx_multicast_octets);\r\nseq_printf(m, "RxFCSErrors=%u\n", sums->rx_fcs_errors);\r\nseq_printf(m, "RxDiscardsNoBuffer=%u\n", sums->rx_discards_no_buffer);\r\nseq_printf(m, "TxDiscardsWrongSA=%u\n", sums->tx_discards_wrong_sa);\r\nseq_printf(m, "RxDiscardsWEPUndecryptable=%u\n",\r\nsums->rx_discards_wep_undecryptable);\r\nseq_printf(m, "RxMessageInMsgFragments=%u\n",\r\nsums->rx_message_in_msg_fragments);\r\nseq_printf(m, "RxMessageInBadMsgFragments=%u\n",\r\nsums->rx_message_in_bad_msg_fragments);\r\nreturn 0;\r\n}\r\nstatic int prism2_stats_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, prism2_stats_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int prism2_wds_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct list_head *ptr = v;\r\nstruct hostap_interface *iface;\r\niface = list_entry(ptr, struct hostap_interface, list);\r\nif (iface->type == HOSTAP_INTERFACE_WDS)\r\nseq_printf(m, "%s\t%pM\n",\r\niface->dev->name, iface->u.wds.remote_addr);\r\nreturn 0;\r\n}\r\nstatic void *prism2_wds_proc_start(struct seq_file *m, loff_t *_pos)\r\n{\r\nlocal_info_t *local = m->private;\r\nread_lock_bh(&local->iface_lock);\r\nreturn seq_list_start(&local->hostap_interfaces, *_pos);\r\n}\r\nstatic void *prism2_wds_proc_next(struct seq_file *m, void *v, loff_t *_pos)\r\n{\r\nlocal_info_t *local = m->private;\r\nreturn seq_list_next(v, &local->hostap_interfaces, _pos);\r\n}\r\nstatic void prism2_wds_proc_stop(struct seq_file *m, void *v)\r\n{\r\nlocal_info_t *local = m->private;\r\nread_unlock_bh(&local->iface_lock);\r\n}\r\nstatic int prism2_wds_proc_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = seq_open(file, &prism2_wds_proc_seqops);\r\nif (ret == 0) {\r\nstruct seq_file *m = file->private_data;\r\nm->private = PDE_DATA(inode);\r\n}\r\nreturn ret;\r\n}\r\nstatic int prism2_bss_list_proc_show(struct seq_file *m, void *v)\r\n{\r\nlocal_info_t *local = m->private;\r\nstruct list_head *ptr = v;\r\nstruct hostap_bss_info *bss;\r\nint i;\r\nif (ptr == &local->bss_list) {\r\nseq_printf(m, "#BSSID\tlast_update\tcount\tcapab_info\tSSID(txt)\t"\r\n"SSID(hex)\tWPA IE\n");\r\nreturn 0;\r\n}\r\nbss = list_entry(ptr, struct hostap_bss_info, list);\r\nseq_printf(m, "%pM\t%lu\t%u\t0x%x\t",\r\nbss->bssid, bss->last_update,\r\nbss->count, bss->capab_info);\r\nfor (i = 0; i < bss->ssid_len; i++)\r\nseq_putc(m,bss->ssid[i] >= 32 && bss->ssid[i] < 127 ?\r\nbss->ssid[i] : '_');\r\nseq_putc(m, '\t');\r\nfor (i = 0; i < bss->ssid_len; i++)\r\nseq_printf(m, "%02x", bss->ssid[i]);\r\nseq_putc(m, '\t');\r\nfor (i = 0; i < bss->wpa_ie_len; i++)\r\nseq_printf(m, "%02x", bss->wpa_ie[i]);\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic void *prism2_bss_list_proc_start(struct seq_file *m, loff_t *_pos)\r\n{\r\nlocal_info_t *local = m->private;\r\nspin_lock_bh(&local->lock);\r\nreturn seq_list_start_head(&local->bss_list, *_pos);\r\n}\r\nstatic void *prism2_bss_list_proc_next(struct seq_file *m, void *v, loff_t *_pos)\r\n{\r\nlocal_info_t *local = m->private;\r\nreturn seq_list_next(v, &local->bss_list, _pos);\r\n}\r\nstatic void prism2_bss_list_proc_stop(struct seq_file *m, void *v)\r\n{\r\nlocal_info_t *local = m->private;\r\nspin_unlock_bh(&local->lock);\r\n}\r\nstatic int prism2_bss_list_proc_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = seq_open(file, &prism2_bss_list_proc_seqops);\r\nif (ret == 0) {\r\nstruct seq_file *m = file->private_data;\r\nm->private = PDE_DATA(inode);\r\n}\r\nreturn ret;\r\n}\r\nstatic int prism2_crypt_proc_show(struct seq_file *m, void *v)\r\n{\r\nlocal_info_t *local = m->private;\r\nint i;\r\nseq_printf(m, "tx_keyidx=%d\n", local->crypt_info.tx_keyidx);\r\nfor (i = 0; i < WEP_KEYS; i++) {\r\nif (local->crypt_info.crypt[i] &&\r\nlocal->crypt_info.crypt[i]->ops &&\r\nlocal->crypt_info.crypt[i]->ops->print_stats) {\r\nlocal->crypt_info.crypt[i]->ops->print_stats(\r\nm, local->crypt_info.crypt[i]->priv);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_crypt_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, prism2_crypt_proc_show, PDE_DATA(inode));\r\n}\r\nstatic ssize_t prism2_pda_proc_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *_pos)\r\n{\r\nlocal_info_t *local = PDE_DATA(file_inode(file));\r\nsize_t off;\r\nif (local->pda == NULL || *_pos >= PRISM2_PDA_SIZE)\r\nreturn 0;\r\noff = *_pos;\r\nif (count > PRISM2_PDA_SIZE - off)\r\ncount = PRISM2_PDA_SIZE - off;\r\nif (copy_to_user(buf, local->pda + off, count) != 0)\r\nreturn -EFAULT;\r\n*_pos += count;\r\nreturn count;\r\n}\r\nstatic ssize_t prism2_aux_dump_proc_no_read(struct file *file, char __user *buf,\r\nsize_t bufsize, loff_t *_pos)\r\n{\r\nreturn 0;\r\n}\r\nstatic int prism2_io_debug_proc_read(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nlocal_info_t *local = (local_info_t *) data;\r\nint head = local->io_debug_head;\r\nint start_bytes, left, copy, copied;\r\nif (off + count > PRISM2_IO_DEBUG_SIZE * 4) {\r\n*eof = 1;\r\nif (off >= PRISM2_IO_DEBUG_SIZE * 4)\r\nreturn 0;\r\ncount = PRISM2_IO_DEBUG_SIZE * 4 - off;\r\n}\r\ncopied = 0;\r\nstart_bytes = (PRISM2_IO_DEBUG_SIZE - head) * 4;\r\nleft = count;\r\nif (off < start_bytes) {\r\ncopy = start_bytes - off;\r\nif (copy > count)\r\ncopy = count;\r\nmemcpy(page, ((u8 *) &local->io_debug[head]) + off, copy);\r\nleft -= copy;\r\nif (left > 0)\r\nmemcpy(&page[copy], local->io_debug, left);\r\n} else {\r\nmemcpy(page, ((u8 *) local->io_debug) + (off - start_bytes),\r\nleft);\r\n}\r\n*start = page;\r\nreturn count;\r\n}\r\nstatic int prism2_scan_results_proc_show(struct seq_file *m, void *v)\r\n{\r\nlocal_info_t *local = m->private;\r\nunsigned long entry;\r\nint i, len;\r\nstruct hfa384x_hostscan_result *scanres;\r\nu8 *p;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(m,\r\n"CHID ANL SL BcnInt Capab Rate BSSID ATIM SupRates SSID\n");\r\nreturn 0;\r\n}\r\nentry = (unsigned long)v - 2;\r\nscanres = &local->last_scan_results[entry];\r\nseq_printf(m, "%d %d %d %d 0x%02x %d %pM %d ",\r\nle16_to_cpu(scanres->chid),\r\n(s16) le16_to_cpu(scanres->anl),\r\n(s16) le16_to_cpu(scanres->sl),\r\nle16_to_cpu(scanres->beacon_interval),\r\nle16_to_cpu(scanres->capability),\r\nle16_to_cpu(scanres->rate),\r\nscanres->bssid,\r\nle16_to_cpu(scanres->atim));\r\np = scanres->sup_rates;\r\nfor (i = 0; i < sizeof(scanres->sup_rates); i++) {\r\nif (p[i] == 0)\r\nbreak;\r\nseq_printf(m, "<%02x>", p[i]);\r\n}\r\nseq_putc(m, ' ');\r\np = scanres->ssid;\r\nlen = le16_to_cpu(scanres->ssid_len);\r\nif (len > 32)\r\nlen = 32;\r\nfor (i = 0; i < len; i++) {\r\nunsigned char c = p[i];\r\nif (c >= 32 && c < 127)\r\nseq_putc(m, c);\r\nelse\r\nseq_printf(m, "<%02x>", c);\r\n}\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic void *prism2_scan_results_proc_start(struct seq_file *m, loff_t *_pos)\r\n{\r\nlocal_info_t *local = m->private;\r\nspin_lock_bh(&local->lock);\r\nif (*_pos > local->last_scan_results_count)\r\nreturn NULL;\r\nreturn (void *)(unsigned long)(*_pos + 1);\r\n}\r\nstatic void *prism2_scan_results_proc_next(struct seq_file *m, void *v, loff_t *_pos)\r\n{\r\nlocal_info_t *local = m->private;\r\n++*_pos;\r\nif (*_pos > local->last_scan_results_count)\r\nreturn NULL;\r\nreturn (void *)(unsigned long)(*_pos + 1);\r\n}\r\nstatic void prism2_scan_results_proc_stop(struct seq_file *m, void *v)\r\n{\r\nlocal_info_t *local = m->private;\r\nspin_unlock_bh(&local->lock);\r\n}\r\nstatic int prism2_scan_results_proc_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = seq_open(file, &prism2_scan_results_proc_seqops);\r\nif (ret == 0) {\r\nstruct seq_file *m = file->private_data;\r\nm->private = PDE_DATA(inode);\r\n}\r\nreturn ret;\r\n}\r\nvoid hostap_init_proc(local_info_t *local)\r\n{\r\nlocal->proc = NULL;\r\nif (hostap_proc == NULL) {\r\nprintk(KERN_WARNING "%s: hostap proc directory not created\n",\r\nlocal->dev->name);\r\nreturn;\r\n}\r\nlocal->proc = proc_mkdir(local->ddev->name, hostap_proc);\r\nif (local->proc == NULL) {\r\nprintk(KERN_INFO "/proc/net/hostap/%s creation failed\n",\r\nlocal->ddev->name);\r\nreturn;\r\n}\r\n#ifndef PRISM2_NO_PROCFS_DEBUG\r\nproc_create_data("debug", 0, local->proc,\r\n&prism2_debug_proc_fops, local);\r\n#endif\r\nproc_create_data("stats", 0, local->proc,\r\n&prism2_stats_proc_fops, local);\r\nproc_create_data("wds", 0, local->proc,\r\n&prism2_wds_proc_fops, local);\r\nproc_create_data("pda", 0, local->proc,\r\n&prism2_pda_proc_fops, local);\r\nproc_create_data("aux_dump", 0, local->proc,\r\nlocal->func->read_aux_fops ?: &prism2_aux_dump_proc_fops,\r\nlocal);\r\nproc_create_data("bss_list", 0, local->proc,\r\n&prism2_bss_list_proc_fops, local);\r\nproc_create_data("crypt", 0, local->proc,\r\n&prism2_crypt_proc_fops, local);\r\n#ifdef PRISM2_IO_DEBUG\r\nproc_create_data("io_debug", 0, local->proc,\r\n&prism2_io_debug_proc_fops, local);\r\n#endif\r\n#ifndef PRISM2_NO_STATION_MODES\r\nproc_create_data("scan_results", 0, local->proc,\r\n&prism2_scan_results_proc_fops, local);\r\n#endif\r\n}\r\nvoid hostap_remove_proc(local_info_t *local)\r\n{\r\nproc_remove(local->proc);\r\n}
