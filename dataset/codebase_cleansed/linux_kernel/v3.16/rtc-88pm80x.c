static irqreturn_t rtc_update_handler(int irq, void *data)\r\n{\r\nstruct pm80x_rtc_info *info = (struct pm80x_rtc_info *)data;\r\nint mask;\r\nmask = PM800_ALARM | PM800_ALARM_WAKEUP;\r\nregmap_update_bits(info->map, PM800_RTC_CONTROL, mask | PM800_ALARM1_EN,\r\nmask);\r\nrtc_update_irq(info->rtc_dev, 1, RTC_AF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pm80x_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct pm80x_rtc_info *info = dev_get_drvdata(dev);\r\nif (enabled)\r\nregmap_update_bits(info->map, PM800_RTC_CONTROL,\r\nPM800_ALARM1_EN, PM800_ALARM1_EN);\r\nelse\r\nregmap_update_bits(info->map, PM800_RTC_CONTROL,\r\nPM800_ALARM1_EN, 0);\r\nreturn 0;\r\n}\r\nstatic void rtc_next_alarm_time(struct rtc_time *next, struct rtc_time *now,\r\nstruct rtc_time *alrm)\r\n{\r\nunsigned long next_time;\r\nunsigned long now_time;\r\nnext->tm_year = now->tm_year;\r\nnext->tm_mon = now->tm_mon;\r\nnext->tm_mday = now->tm_mday;\r\nnext->tm_hour = alrm->tm_hour;\r\nnext->tm_min = alrm->tm_min;\r\nnext->tm_sec = alrm->tm_sec;\r\nrtc_tm_to_time(now, &now_time);\r\nrtc_tm_to_time(next, &next_time);\r\nif (next_time < now_time) {\r\nnext_time += 60 * 60 * 24;\r\nrtc_time_to_tm(next_time, next);\r\n}\r\n}\r\nstatic int pm80x_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct pm80x_rtc_info *info = dev_get_drvdata(dev);\r\nunsigned char buf[4];\r\nunsigned long ticks, base, data;\r\nregmap_raw_read(info->map, PM800_RTC_EXPIRE2_1, buf, 4);\r\nbase = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\ndev_dbg(info->dev, "%x-%x-%x-%x\n", buf[0], buf[1], buf[2], buf[3]);\r\nregmap_raw_read(info->map, PM800_RTC_COUNTER1, buf, 4);\r\ndata = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\nticks = base + data;\r\ndev_dbg(info->dev, "get base:0x%lx, RO count:0x%lx, ticks:0x%lx\n",\r\nbase, data, ticks);\r\nrtc_time_to_tm(ticks, tm);\r\nreturn 0;\r\n}\r\nstatic int pm80x_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct pm80x_rtc_info *info = dev_get_drvdata(dev);\r\nunsigned char buf[4];\r\nunsigned long ticks, base, data;\r\nif ((tm->tm_year < 70) || (tm->tm_year > 138)) {\r\ndev_dbg(info->dev,\r\n"Set time %d out of range. Please set time between 1970 to 2038.\n",\r\n1900 + tm->tm_year);\r\nreturn -EINVAL;\r\n}\r\nrtc_tm_to_time(tm, &ticks);\r\nregmap_raw_read(info->map, PM800_RTC_COUNTER1, buf, 4);\r\ndata = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\nbase = ticks - data;\r\ndev_dbg(info->dev, "set base:0x%lx, RO count:0x%lx, ticks:0x%lx\n",\r\nbase, data, ticks);\r\nbuf[0] = base & 0xFF;\r\nbuf[1] = (base >> 8) & 0xFF;\r\nbuf[2] = (base >> 16) & 0xFF;\r\nbuf[3] = (base >> 24) & 0xFF;\r\nregmap_raw_write(info->map, PM800_RTC_EXPIRE2_1, buf, 4);\r\nreturn 0;\r\n}\r\nstatic int pm80x_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct pm80x_rtc_info *info = dev_get_drvdata(dev);\r\nunsigned char buf[4];\r\nunsigned long ticks, base, data;\r\nint ret;\r\nregmap_raw_read(info->map, PM800_RTC_EXPIRE2_1, buf, 4);\r\nbase = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\ndev_dbg(info->dev, "%x-%x-%x-%x\n", buf[0], buf[1], buf[2], buf[3]);\r\nregmap_raw_read(info->map, PM800_RTC_EXPIRE1_1, buf, 4);\r\ndata = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\nticks = base + data;\r\ndev_dbg(info->dev, "get base:0x%lx, RO count:0x%lx, ticks:0x%lx\n",\r\nbase, data, ticks);\r\nrtc_time_to_tm(ticks, &alrm->time);\r\nregmap_read(info->map, PM800_RTC_CONTROL, &ret);\r\nalrm->enabled = (ret & PM800_ALARM1_EN) ? 1 : 0;\r\nalrm->pending = (ret & (PM800_ALARM | PM800_ALARM_WAKEUP)) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int pm80x_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct pm80x_rtc_info *info = dev_get_drvdata(dev);\r\nstruct rtc_time now_tm, alarm_tm;\r\nunsigned long ticks, base, data;\r\nunsigned char buf[4];\r\nint mask;\r\nregmap_update_bits(info->map, PM800_RTC_CONTROL, PM800_ALARM1_EN, 0);\r\nregmap_raw_read(info->map, PM800_RTC_EXPIRE2_1, buf, 4);\r\nbase = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\ndev_dbg(info->dev, "%x-%x-%x-%x\n", buf[0], buf[1], buf[2], buf[3]);\r\nregmap_raw_read(info->map, PM800_RTC_COUNTER1, buf, 4);\r\ndata = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\nticks = base + data;\r\ndev_dbg(info->dev, "get base:0x%lx, RO count:0x%lx, ticks:0x%lx\n",\r\nbase, data, ticks);\r\nrtc_time_to_tm(ticks, &now_tm);\r\ndev_dbg(info->dev, "%s, now time : %lu\n", __func__, ticks);\r\nrtc_next_alarm_time(&alarm_tm, &now_tm, &alrm->time);\r\nrtc_tm_to_time(&alarm_tm, &ticks);\r\ndev_dbg(info->dev, "%s, alarm time: %lu\n", __func__, ticks);\r\ndata = ticks - base;\r\nbuf[0] = data & 0xff;\r\nbuf[1] = (data >> 8) & 0xff;\r\nbuf[2] = (data >> 16) & 0xff;\r\nbuf[3] = (data >> 24) & 0xff;\r\nregmap_raw_write(info->map, PM800_RTC_EXPIRE1_1, buf, 4);\r\nif (alrm->enabled) {\r\nmask = PM800_ALARM | PM800_ALARM_WAKEUP | PM800_ALARM1_EN;\r\nregmap_update_bits(info->map, PM800_RTC_CONTROL, mask, mask);\r\n} else {\r\nmask = PM800_ALARM | PM800_ALARM_WAKEUP | PM800_ALARM1_EN;\r\nregmap_update_bits(info->map, PM800_RTC_CONTROL, mask,\r\nPM800_ALARM | PM800_ALARM_WAKEUP);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm80x_rtc_suspend(struct device *dev)\r\n{\r\nreturn pm80x_dev_suspend(dev);\r\n}\r\nstatic int pm80x_rtc_resume(struct device *dev)\r\n{\r\nreturn pm80x_dev_resume(dev);\r\n}\r\nstatic int pm80x_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct pm80x_chip *chip = dev_get_drvdata(pdev->dev.parent);\r\nstruct pm80x_platform_data *pm80x_pdata =\r\ndev_get_platdata(pdev->dev.parent);\r\nstruct pm80x_rtc_pdata *pdata = NULL;\r\nstruct pm80x_rtc_info *info;\r\nstruct rtc_time tm;\r\nunsigned long ticks = 0;\r\nint ret;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (pdata == NULL)\r\ndev_warn(&pdev->dev, "No platform data!\n");\r\ninfo =\r\ndevm_kzalloc(&pdev->dev, sizeof(struct pm80x_rtc_info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->irq = platform_get_irq(pdev, 0);\r\nif (info->irq < 0) {\r\ndev_err(&pdev->dev, "No IRQ resource!\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ninfo->chip = chip;\r\ninfo->map = chip->regmap;\r\nif (!info->map) {\r\ndev_err(&pdev->dev, "no regmap!\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ninfo->dev = &pdev->dev;\r\ndev_set_drvdata(&pdev->dev, info);\r\nret = pm80x_request_irq(chip, info->irq, rtc_update_handler,\r\nIRQF_ONESHOT, "rtc", info);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to request IRQ: #%d: %d\n",\r\ninfo->irq, ret);\r\ngoto out;\r\n}\r\nret = pm80x_rtc_read_time(&pdev->dev, &tm);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to read initial time.\n");\r\ngoto out_rtc;\r\n}\r\nif ((tm.tm_year < 70) || (tm.tm_year > 138)) {\r\ntm.tm_year = 70;\r\ntm.tm_mon = 0;\r\ntm.tm_mday = 1;\r\ntm.tm_hour = 0;\r\ntm.tm_min = 0;\r\ntm.tm_sec = 0;\r\nret = pm80x_rtc_set_time(&pdev->dev, &tm);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to set initial time.\n");\r\ngoto out_rtc;\r\n}\r\n}\r\nrtc_tm_to_time(&tm, &ticks);\r\ninfo->rtc_dev = devm_rtc_device_register(&pdev->dev, "88pm80x-rtc",\r\n&pm80x_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(info->rtc_dev)) {\r\nret = PTR_ERR(info->rtc_dev);\r\ndev_err(&pdev->dev, "Failed to register RTC device: %d\n", ret);\r\ngoto out_rtc;\r\n}\r\nregmap_update_bits(info->map, PM800_RTC_CONTROL, PM800_RTC1_USE_XO,\r\nPM800_RTC1_USE_XO);\r\nif (pm80x_pdata) {\r\npdata = pm80x_pdata->rtc;\r\nif (pdata)\r\ninfo->rtc_dev->dev.platform_data = &pdata->rtc_wakeup;\r\n}\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn 0;\r\nout_rtc:\r\npm80x_free_irq(chip, info->irq, info);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pm80x_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct pm80x_rtc_info *info = platform_get_drvdata(pdev);\r\npm80x_free_irq(info->chip, info->irq, info);\r\nreturn 0;\r\n}
