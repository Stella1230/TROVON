static void usbhsg_queue_pop(struct usbhsg_uep *uep,\r\nstruct usbhsg_request *ureq,\r\nint status)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\r\nstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\r\nstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\r\ndev_dbg(dev, "pipe %d : queue pop\n", usbhs_pipe_number(pipe));\r\nureq->req.status = status;\r\nureq->req.complete(&uep->ep, &ureq->req);\r\n}\r\nstatic void usbhsg_queue_done(struct usbhs_priv *priv, struct usbhs_pkt *pkt)\r\n{\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nstruct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);\r\nstruct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);\r\nureq->req.actual = pkt->actual;\r\nusbhsg_queue_pop(uep, ureq, 0);\r\n}\r\nstatic void usbhsg_queue_push(struct usbhsg_uep *uep,\r\nstruct usbhsg_request *ureq)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\r\nstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\r\nstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\r\nstruct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);\r\nstruct usb_request *req = &ureq->req;\r\nreq->actual = 0;\r\nreq->status = -EINPROGRESS;\r\nusbhs_pkt_push(pipe, pkt, usbhsg_queue_done,\r\nreq->buf, req->length, req->zero, -1);\r\nusbhs_pkt_start(pipe);\r\ndev_dbg(dev, "pipe %d : queue push (%d)\n",\r\nusbhs_pipe_number(pipe),\r\nreq->length);\r\n}\r\nstatic int usbhsg_dma_map_ctrl(struct usbhs_pkt *pkt, int map)\r\n{\r\nstruct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);\r\nstruct usb_request *req = &ureq->req;\r\nstruct usbhs_pipe *pipe = pkt->pipe;\r\nstruct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);\r\nstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\r\nenum dma_data_direction dir;\r\nint ret = 0;\r\ndir = usbhs_pipe_is_dir_host(pipe);\r\nif (map) {\r\nWARN_ON(req->num_sgs);\r\nret = usb_gadget_map_request(&gpriv->gadget, req, dir);\r\nif (ret < 0)\r\nreturn ret;\r\npkt->dma = req->dma;\r\n} else {\r\nusb_gadget_unmap_request(&gpriv->gadget, req, dir);\r\n}\r\nreturn ret;\r\n}\r\nstatic int usbhsg_recip_handler_std_control_done(struct usbhs_priv *priv,\r\nstruct usbhsg_uep *uep,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\r\nstruct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);\r\nstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(dcp);\r\nusbhs_dcp_control_transfer_done(pipe);\r\nreturn 0;\r\n}\r\nstatic int usbhsg_recip_handler_std_clear_endpoint(struct usbhs_priv *priv,\r\nstruct usbhsg_uep *uep,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\r\nstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\r\nif (!usbhsg_status_has(gpriv, USBHSG_STATUS_WEDGE)) {\r\nusbhs_pipe_disable(pipe);\r\nusbhs_pipe_sequence_data0(pipe);\r\nusbhs_pipe_enable(pipe);\r\n}\r\nusbhsg_recip_handler_std_control_done(priv, uep, ctrl);\r\nusbhs_pkt_start(pipe);\r\nreturn 0;\r\n}\r\nstatic int usbhsg_recip_handler_std_set_device(struct usbhs_priv *priv,\r\nstruct usbhsg_uep *uep,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nswitch (le16_to_cpu(ctrl->wValue)) {\r\ncase USB_DEVICE_TEST_MODE:\r\nusbhsg_recip_handler_std_control_done(priv, uep, ctrl);\r\nudelay(100);\r\nusbhs_sys_set_test_mode(priv, le16_to_cpu(ctrl->wIndex >> 8));\r\nbreak;\r\ndefault:\r\nusbhsg_recip_handler_std_control_done(priv, uep, ctrl);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbhsg_recip_handler_std_set_endpoint(struct usbhs_priv *priv,\r\nstruct usbhsg_uep *uep,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\r\nusbhs_pipe_stall(pipe);\r\nusbhsg_recip_handler_std_control_done(priv, uep, ctrl);\r\nreturn 0;\r\n}\r\nstatic void __usbhsg_recip_send_complete(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct usbhsg_request *ureq = usbhsg_req_to_ureq(req);\r\nkfree(ureq->pkt.buf);\r\nusb_ep_free_request(ep, req);\r\n}\r\nstatic void __usbhsg_recip_send_status(struct usbhsg_gpriv *gpriv,\r\nunsigned short status)\r\n{\r\nstruct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);\r\nstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(dcp);\r\nstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\r\nstruct usb_request *req;\r\nunsigned short *buf;\r\nreq = usb_ep_alloc_request(&dcp->ep, GFP_ATOMIC);\r\nif (!req) {\r\ndev_err(dev, "recip request allocation fail\n");\r\nreturn;\r\n}\r\nbuf = kmalloc(sizeof(*buf), GFP_ATOMIC);\r\nif (!buf) {\r\nusb_ep_free_request(&dcp->ep, req);\r\ndev_err(dev, "recip data allocation fail\n");\r\nreturn;\r\n}\r\n*buf = cpu_to_le16(status);\r\nreq->complete = __usbhsg_recip_send_complete;\r\nreq->buf = buf;\r\nreq->length = sizeof(*buf);\r\nreq->zero = 0;\r\npipe->handler = &usbhs_fifo_pio_push_handler;\r\nusbhsg_queue_push(dcp, usbhsg_req_to_ureq(req));\r\n}\r\nstatic int usbhsg_recip_handler_std_get_device(struct usbhs_priv *priv,\r\nstruct usbhsg_uep *uep,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\r\nunsigned short status = 0;\r\nif (usbhsg_status_has(gpriv, USBHSG_STATUS_SELF_POWERED))\r\nstatus = 1 << USB_DEVICE_SELF_POWERED;\r\n__usbhsg_recip_send_status(gpriv, status);\r\nreturn 0;\r\n}\r\nstatic int usbhsg_recip_handler_std_get_interface(struct usbhs_priv *priv,\r\nstruct usbhsg_uep *uep,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\r\nunsigned short status = 0;\r\n__usbhsg_recip_send_status(gpriv, status);\r\nreturn 0;\r\n}\r\nstatic int usbhsg_recip_handler_std_get_endpoint(struct usbhs_priv *priv,\r\nstruct usbhsg_uep *uep,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\r\nstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\r\nunsigned short status = 0;\r\nif (usbhs_pipe_is_stall(pipe))\r\nstatus = 1 << USB_ENDPOINT_HALT;\r\n__usbhsg_recip_send_status(gpriv, status);\r\nreturn 0;\r\n}\r\nstatic int usbhsg_recip_run_handle(struct usbhs_priv *priv,\r\nstruct usbhsg_recip_handle *handler,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\r\nstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\r\nstruct usbhsg_uep *uep;\r\nstruct usbhs_pipe *pipe;\r\nint recip = ctrl->bRequestType & USB_RECIP_MASK;\r\nint nth = le16_to_cpu(ctrl->wIndex) & USB_ENDPOINT_NUMBER_MASK;\r\nint ret = 0;\r\nint (*func)(struct usbhs_priv *priv, struct usbhsg_uep *uep,\r\nstruct usb_ctrlrequest *ctrl);\r\nchar *msg;\r\nuep = usbhsg_gpriv_to_nth_uep(gpriv, nth);\r\npipe = usbhsg_uep_to_pipe(uep);\r\nif (!pipe) {\r\ndev_err(dev, "wrong recip request\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (recip) {\r\ncase USB_RECIP_DEVICE:\r\nmsg = "DEVICE";\r\nfunc = handler->device;\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nmsg = "INTERFACE";\r\nfunc = handler->interface;\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nmsg = "ENDPOINT";\r\nfunc = handler->endpoint;\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "unsupported RECIP(%d)\n", recip);\r\nfunc = NULL;\r\nret = -EINVAL;\r\n}\r\nif (func) {\r\ndev_dbg(dev, "%s (pipe %d :%s)\n", handler->name, nth, msg);\r\nret = func(priv, uep, ctrl);\r\n}\r\nreturn ret;\r\n}\r\nstatic int usbhsg_irq_dev_state(struct usbhs_priv *priv,\r\nstruct usbhs_irq_state *irq_state)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\r\nstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\r\ngpriv->gadget.speed = usbhs_bus_get_speed(priv);\r\ndev_dbg(dev, "state = %x : speed : %d\n",\r\nusbhs_status_get_device_state(irq_state),\r\ngpriv->gadget.speed);\r\nreturn 0;\r\n}\r\nstatic int usbhsg_irq_ctrl_stage(struct usbhs_priv *priv,\r\nstruct usbhs_irq_state *irq_state)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\r\nstruct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);\r\nstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(dcp);\r\nstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\r\nstruct usb_ctrlrequest ctrl;\r\nstruct usbhsg_recip_handle *recip_handler = NULL;\r\nint stage = usbhs_status_get_ctrl_stage(irq_state);\r\nint ret = 0;\r\ndev_dbg(dev, "stage = %d\n", stage);\r\nswitch (stage) {\r\ncase READ_DATA_STAGE:\r\npipe->handler = &usbhs_fifo_pio_push_handler;\r\nbreak;\r\ncase WRITE_DATA_STAGE:\r\npipe->handler = &usbhs_fifo_pio_pop_handler;\r\nbreak;\r\ncase NODATA_STATUS_STAGE:\r\npipe->handler = &usbhs_ctrl_stage_end_handler;\r\nbreak;\r\ndefault:\r\nreturn ret;\r\n}\r\nusbhs_usbreq_get_val(priv, &ctrl);\r\nswitch (ctrl.bRequestType & USB_TYPE_MASK) {\r\ncase USB_TYPE_STANDARD:\r\nswitch (ctrl.bRequest) {\r\ncase USB_REQ_CLEAR_FEATURE:\r\nrecip_handler = &req_clear_feature;\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nrecip_handler = &req_set_feature;\r\nbreak;\r\ncase USB_REQ_GET_STATUS:\r\nrecip_handler = &req_get_status;\r\nbreak;\r\n}\r\n}\r\nif (recip_handler)\r\nret = usbhsg_recip_run_handle(priv, recip_handler, &ctrl);\r\nelse\r\nret = gpriv->driver->setup(&gpriv->gadget, &ctrl);\r\nif (ret < 0)\r\nusbhs_pipe_stall(pipe);\r\nreturn ret;\r\n}\r\nstatic int usbhsg_pipe_disable(struct usbhsg_uep *uep)\r\n{\r\nstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\r\nstruct usbhs_pkt *pkt;\r\nwhile (1) {\r\npkt = usbhs_pkt_pop(pipe, NULL);\r\nif (!pkt)\r\nbreak;\r\nusbhsg_queue_pop(uep, usbhsg_pkt_to_ureq(pkt), -ECONNRESET);\r\n}\r\nusbhs_pipe_disable(pipe);\r\nreturn 0;\r\n}\r\nstatic int usbhsg_ep_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);\r\nstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\r\nstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\r\nstruct usbhs_pipe *pipe;\r\nint ret = -EIO;\r\nif (uep->pipe) {\r\nusbhs_pipe_clear(uep->pipe);\r\nusbhs_pipe_sequence_data0(uep->pipe);\r\nreturn 0;\r\n}\r\npipe = usbhs_pipe_malloc(priv,\r\nusb_endpoint_type(desc),\r\nusb_endpoint_dir_in(desc));\r\nif (pipe) {\r\nuep->pipe = pipe;\r\npipe->mod_private = uep;\r\nusbhs_pipe_config_update(pipe, 0,\r\nusb_endpoint_num(desc),\r\nusb_endpoint_maxp(desc));\r\nif (usb_endpoint_dir_in(desc))\r\npipe->handler = &usbhs_fifo_dma_push_handler;\r\nelse\r\npipe->handler = &usbhs_fifo_dma_pop_handler;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int usbhsg_ep_disable(struct usb_ep *ep)\r\n{\r\nstruct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);\r\nusbhsg_pipe_disable(uep);\r\nuep->pipe->mod_private = NULL;\r\nuep->pipe = NULL;\r\nreturn 0;\r\n}\r\nstatic struct usb_request *usbhsg_ep_alloc_request(struct usb_ep *ep,\r\ngfp_t gfp_flags)\r\n{\r\nstruct usbhsg_request *ureq;\r\nureq = kzalloc(sizeof *ureq, gfp_flags);\r\nif (!ureq)\r\nreturn NULL;\r\nusbhs_pkt_init(usbhsg_ureq_to_pkt(ureq));\r\nreturn &ureq->req;\r\n}\r\nstatic void usbhsg_ep_free_request(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct usbhsg_request *ureq = usbhsg_req_to_ureq(req);\r\nWARN_ON(!list_empty(&ureq->pkt.node));\r\nkfree(ureq);\r\n}\r\nstatic int usbhsg_ep_queue(struct usb_ep *ep, struct usb_request *req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);\r\nstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\r\nstruct usbhsg_request *ureq = usbhsg_req_to_ureq(req);\r\nstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\r\nif (usbhsg_is_not_connected(gpriv) ||\r\nunlikely(!gpriv->driver) ||\r\nunlikely(!pipe))\r\nreturn -ESHUTDOWN;\r\nusbhsg_queue_push(uep, ureq);\r\nreturn 0;\r\n}\r\nstatic int usbhsg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);\r\nstruct usbhsg_request *ureq = usbhsg_req_to_ureq(req);\r\nstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\r\nusbhs_pkt_pop(pipe, usbhsg_ureq_to_pkt(ureq));\r\nusbhsg_queue_pop(uep, ureq, -ECONNRESET);\r\nreturn 0;\r\n}\r\nstatic int __usbhsg_ep_set_halt_wedge(struct usb_ep *ep, int halt, int wedge)\r\n{\r\nstruct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);\r\nstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\r\nstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\r\nstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\r\nstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\r\nunsigned long flags;\r\nusbhsg_pipe_disable(uep);\r\ndev_dbg(dev, "set halt %d (pipe %d)\n",\r\nhalt, usbhs_pipe_number(pipe));\r\nusbhs_lock(priv, flags);\r\nif (halt)\r\nusbhs_pipe_stall(pipe);\r\nelse\r\nusbhs_pipe_disable(pipe);\r\nif (halt && wedge)\r\nusbhsg_status_set(gpriv, USBHSG_STATUS_WEDGE);\r\nelse\r\nusbhsg_status_clr(gpriv, USBHSG_STATUS_WEDGE);\r\nusbhs_unlock(priv, flags);\r\nreturn 0;\r\n}\r\nstatic int usbhsg_ep_set_halt(struct usb_ep *ep, int value)\r\n{\r\nreturn __usbhsg_ep_set_halt_wedge(ep, value, 0);\r\n}\r\nstatic int usbhsg_ep_set_wedge(struct usb_ep *ep)\r\n{\r\nreturn __usbhsg_ep_set_halt_wedge(ep, 1, 1);\r\n}\r\nstatic int usbhsg_try_start(struct usbhs_priv *priv, u32 status)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\r\nstruct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);\r\nstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nunsigned long flags;\r\nint ret = 0;\r\nusbhs_lock(priv, flags);\r\nusbhsg_status_set(gpriv, status);\r\nif (!(usbhsg_status_has(gpriv, USBHSG_STATUS_STARTED) &&\r\nusbhsg_status_has(gpriv, USBHSG_STATUS_REGISTERD)))\r\nret = -1;\r\nusbhs_unlock(priv, flags);\r\nif (ret < 0)\r\nreturn 0;\r\ndev_dbg(dev, "start gadget\n");\r\nusbhs_pipe_init(priv,\r\nusbhsg_dma_map_ctrl);\r\nusbhs_fifo_init(priv);\r\ndcp->pipe = usbhs_dcp_malloc(priv);\r\ndcp->pipe->mod_private = dcp;\r\nusbhs_pipe_config_update(dcp->pipe, 0, 0, 64);\r\nusbhs_sys_function_ctrl(priv, 1);\r\nmod->irq_dev_state = usbhsg_irq_dev_state;\r\nmod->irq_ctrl_stage = usbhsg_irq_ctrl_stage;\r\nusbhs_irq_callback_update(priv, mod);\r\nreturn 0;\r\n}\r\nstatic int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\r\nstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\r\nstruct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nunsigned long flags;\r\nint ret = 0;\r\nusbhs_lock(priv, flags);\r\nusbhsg_status_clr(gpriv, status);\r\nif (!usbhsg_status_has(gpriv, USBHSG_STATUS_STARTED) &&\r\n!usbhsg_status_has(gpriv, USBHSG_STATUS_REGISTERD))\r\nret = -1;\r\nusbhs_unlock(priv, flags);\r\nif (ret < 0)\r\nreturn 0;\r\nusbhs_fifo_quit(priv);\r\nmod->irq_dev_state = NULL;\r\nmod->irq_ctrl_stage = NULL;\r\nusbhs_irq_callback_update(priv, mod);\r\ngpriv->gadget.speed = USB_SPEED_UNKNOWN;\r\nusbhs_sys_set_test_mode(priv, 0);\r\nusbhs_sys_function_ctrl(priv, 0);\r\nusbhsg_ep_disable(&dcp->ep);\r\ndev_dbg(dev, "stop gadget\n");\r\nreturn 0;\r\n}\r\nstatic int usbhsg_gadget_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);\r\nstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\r\nif (!driver ||\r\n!driver->setup ||\r\ndriver->max_speed < USB_SPEED_FULL)\r\nreturn -EINVAL;\r\ngpriv->driver = driver;\r\nreturn usbhsg_try_start(priv, USBHSG_STATUS_REGISTERD);\r\n}\r\nstatic int usbhsg_gadget_stop(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);\r\nstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\r\nusbhsg_try_stop(priv, USBHSG_STATUS_REGISTERD);\r\ngpriv->driver = NULL;\r\nreturn 0;\r\n}\r\nstatic int usbhsg_get_frame(struct usb_gadget *gadget)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);\r\nstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\r\nreturn usbhs_frame_get_num(priv);\r\n}\r\nstatic int usbhsg_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);\r\nstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\r\nusbhs_sys_function_pullup(priv, is_on);\r\nreturn 0;\r\n}\r\nstatic int usbhsg_set_selfpowered(struct usb_gadget *gadget, int is_self)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);\r\nif (is_self)\r\nusbhsg_status_set(gpriv, USBHSG_STATUS_SELF_POWERED);\r\nelse\r\nusbhsg_status_clr(gpriv, USBHSG_STATUS_SELF_POWERED);\r\nreturn 0;\r\n}\r\nstatic int usbhsg_start(struct usbhs_priv *priv)\r\n{\r\nreturn usbhsg_try_start(priv, USBHSG_STATUS_STARTED);\r\n}\r\nstatic int usbhsg_stop(struct usbhs_priv *priv)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\r\nif (gpriv->driver &&\r\ngpriv->driver->disconnect)\r\ngpriv->driver->disconnect(&gpriv->gadget);\r\nreturn usbhsg_try_stop(priv, USBHSG_STATUS_STARTED);\r\n}\r\nint usbhs_mod_gadget_probe(struct usbhs_priv *priv)\r\n{\r\nstruct usbhsg_gpriv *gpriv;\r\nstruct usbhsg_uep *uep;\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint pipe_size = usbhs_get_dparam(priv, pipe_size);\r\nint i;\r\nint ret;\r\ngpriv = kzalloc(sizeof(struct usbhsg_gpriv), GFP_KERNEL);\r\nif (!gpriv) {\r\ndev_err(dev, "Could not allocate gadget priv\n");\r\nreturn -ENOMEM;\r\n}\r\nuep = kzalloc(sizeof(struct usbhsg_uep) * pipe_size, GFP_KERNEL);\r\nif (!uep) {\r\ndev_err(dev, "Could not allocate ep\n");\r\nret = -ENOMEM;\r\ngoto usbhs_mod_gadget_probe_err_gpriv;\r\n}\r\nusbhs_mod_register(priv, &gpriv->mod, USBHS_GADGET);\r\ngpriv->mod.name = "gadget";\r\ngpriv->mod.start = usbhsg_start;\r\ngpriv->mod.stop = usbhsg_stop;\r\ngpriv->uep = uep;\r\ngpriv->uep_size = pipe_size;\r\nusbhsg_status_init(gpriv);\r\ngpriv->gadget.dev.parent = dev;\r\ngpriv->gadget.name = "renesas_usbhs_udc";\r\ngpriv->gadget.ops = &usbhsg_gadget_ops;\r\ngpriv->gadget.max_speed = USB_SPEED_HIGH;\r\nINIT_LIST_HEAD(&gpriv->gadget.ep_list);\r\nusbhsg_for_each_uep_with_dcp(uep, gpriv, i) {\r\nuep->gpriv = gpriv;\r\nuep->pipe = NULL;\r\nsnprintf(uep->ep_name, EP_NAME_SIZE, "ep%d", i);\r\nuep->ep.name = uep->ep_name;\r\nuep->ep.ops = &usbhsg_ep_ops;\r\nINIT_LIST_HEAD(&uep->ep.ep_list);\r\nif (usbhsg_is_dcp(uep)) {\r\ngpriv->gadget.ep0 = &uep->ep;\r\nusb_ep_set_maxpacket_limit(&uep->ep, 64);\r\n}\r\nelse {\r\nusb_ep_set_maxpacket_limit(&uep->ep, 512);\r\nlist_add_tail(&uep->ep.ep_list, &gpriv->gadget.ep_list);\r\n}\r\n}\r\nret = usb_add_gadget_udc(dev, &gpriv->gadget);\r\nif (ret)\r\ngoto err_add_udc;\r\ndev_info(dev, "gadget probed\n");\r\nreturn 0;\r\nerr_add_udc:\r\nkfree(gpriv->uep);\r\nusbhs_mod_gadget_probe_err_gpriv:\r\nkfree(gpriv);\r\nreturn ret;\r\n}\r\nvoid usbhs_mod_gadget_remove(struct usbhs_priv *priv)\r\n{\r\nstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\r\nusb_del_gadget_udc(&gpriv->gadget);\r\nkfree(gpriv->uep);\r\nkfree(gpriv);\r\n}
