static void PRINT_PKT(u_char *buf, int length)\r\n{\r\nint i;\r\nint remainder;\r\nint lines;\r\nlines = length / 16;\r\nremainder = length % 16;\r\nfor (i = 0; i < lines ; i ++) {\r\nint cur;\r\nprintk(KERN_DEBUG);\r\nfor (cur = 0; cur < 8; cur++) {\r\nu_char a, b;\r\na = *buf++;\r\nb = *buf++;\r\npr_cont("%02x%02x ", a, b);\r\n}\r\npr_cont("\n");\r\n}\r\nprintk(KERN_DEBUG);\r\nfor (i = 0; i < remainder/2 ; i++) {\r\nu_char a, b;\r\na = *buf++;\r\nb = *buf++;\r\npr_cont("%02x%02x ", a, b);\r\n}\r\npr_cont("\n");\r\n}\r\nstatic inline void PRINT_PKT(u_char *buf, int length) { }\r\nstatic void smc_reset(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nunsigned int ctl, cfg;\r\nstruct sk_buff *pending_skb;\r\nDBG(2, dev, "%s\n", __func__);\r\nspin_lock_irq(&lp->lock);\r\nSMC_SELECT_BANK(lp, 2);\r\nSMC_SET_INT_MASK(lp, 0);\r\npending_skb = lp->pending_tx_skb;\r\nlp->pending_tx_skb = NULL;\r\nspin_unlock_irq(&lp->lock);\r\nif (pending_skb) {\r\ndev_kfree_skb(pending_skb);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\n}\r\nSMC_SELECT_BANK(lp, 0);\r\nSMC_SET_RCR(lp, RCR_SOFTRST);\r\nSMC_SELECT_BANK(lp, 1);\r\ncfg = CONFIG_DEFAULT;\r\nif (lp->cfg.flags & SMC91X_NOWAIT)\r\ncfg |= CONFIG_NO_WAIT;\r\ncfg |= CONFIG_EPH_POWER_EN;\r\nSMC_SET_CONFIG(lp, cfg);\r\nudelay(1);\r\nSMC_SELECT_BANK(lp, 0);\r\nSMC_SET_RCR(lp, RCR_CLEAR);\r\nSMC_SET_TCR(lp, TCR_CLEAR);\r\nSMC_SELECT_BANK(lp, 1);\r\nctl = SMC_GET_CTL(lp) | CTL_LE_ENABLE;\r\nif(!THROTTLE_TX_PKTS)\r\nctl |= CTL_AUTO_RELEASE;\r\nelse\r\nctl &= ~CTL_AUTO_RELEASE;\r\nSMC_SET_CTL(lp, ctl);\r\nSMC_SELECT_BANK(lp, 2);\r\nSMC_SET_MMU_CMD(lp, MC_RESET);\r\nSMC_WAIT_MMU_BUSY(lp);\r\n}\r\nstatic void smc_enable(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nint mask;\r\nDBG(2, dev, "%s\n", __func__);\r\nSMC_SELECT_BANK(lp, 0);\r\nSMC_SET_TCR(lp, lp->tcr_cur_mode);\r\nSMC_SET_RCR(lp, lp->rcr_cur_mode);\r\nSMC_SELECT_BANK(lp, 1);\r\nSMC_SET_MAC_ADDR(lp, dev->dev_addr);\r\nmask = IM_EPH_INT|IM_RX_OVRN_INT|IM_RCV_INT;\r\nif (lp->version >= (CHIP_91100 << 4))\r\nmask |= IM_MDINT;\r\nSMC_SELECT_BANK(lp, 2);\r\nSMC_SET_INT_MASK(lp, mask);\r\n}\r\nstatic void smc_shutdown(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nstruct sk_buff *pending_skb;\r\nDBG(2, dev, "%s: %s\n", CARDNAME, __func__);\r\nspin_lock_irq(&lp->lock);\r\nSMC_SELECT_BANK(lp, 2);\r\nSMC_SET_INT_MASK(lp, 0);\r\npending_skb = lp->pending_tx_skb;\r\nlp->pending_tx_skb = NULL;\r\nspin_unlock_irq(&lp->lock);\r\nif (pending_skb)\r\ndev_kfree_skb(pending_skb);\r\nSMC_SELECT_BANK(lp, 0);\r\nSMC_SET_RCR(lp, RCR_CLEAR);\r\nSMC_SET_TCR(lp, TCR_CLEAR);\r\n#ifdef POWER_DOWN\r\nSMC_SELECT_BANK(lp, 1);\r\nSMC_SET_CONFIG(lp, SMC_GET_CONFIG(lp) & ~CONFIG_EPH_POWER_EN);\r\n#endif\r\n}\r\nstatic inline void smc_rcv(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nunsigned int packet_number, status, packet_len;\r\nDBG(3, dev, "%s\n", __func__);\r\npacket_number = SMC_GET_RXFIFO(lp);\r\nif (unlikely(packet_number & RXFIFO_REMPTY)) {\r\nPRINTK(dev, "smc_rcv with nothing on FIFO.\n");\r\nreturn;\r\n}\r\nSMC_SET_PTR(lp, PTR_READ | PTR_RCV | PTR_AUTOINC);\r\nSMC_GET_PKT_HDR(lp, status, packet_len);\r\npacket_len &= 0x07ff;\r\nDBG(2, dev, "RX PNR 0x%x STATUS 0x%04x LENGTH 0x%04x (%d)\n",\r\npacket_number, status, packet_len, packet_len);\r\nback:\r\nif (unlikely(packet_len < 6 || status & RS_ERRORS)) {\r\nif (status & RS_TOOLONG && packet_len <= (1514 + 4 + 6)) {\r\nstatus &= ~RS_TOOLONG;\r\ngoto back;\r\n}\r\nif (packet_len < 6) {\r\nnetdev_err(dev, "fubar (rxlen %u status %x\n",\r\npacket_len, status);\r\nstatus |= RS_TOOSHORT;\r\n}\r\nSMC_WAIT_MMU_BUSY(lp);\r\nSMC_SET_MMU_CMD(lp, MC_RELEASE);\r\ndev->stats.rx_errors++;\r\nif (status & RS_ALGNERR)\r\ndev->stats.rx_frame_errors++;\r\nif (status & (RS_TOOSHORT | RS_TOOLONG))\r\ndev->stats.rx_length_errors++;\r\nif (status & RS_BADCRC)\r\ndev->stats.rx_crc_errors++;\r\n} else {\r\nstruct sk_buff *skb;\r\nunsigned char *data;\r\nunsigned int data_len;\r\nif (status & RS_MULTICAST)\r\ndev->stats.multicast++;\r\nskb = netdev_alloc_skb(dev, packet_len);\r\nif (unlikely(skb == NULL)) {\r\nSMC_WAIT_MMU_BUSY(lp);\r\nSMC_SET_MMU_CMD(lp, MC_RELEASE);\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\nif (lp->version == 0x90)\r\nstatus |= RS_ODDFRAME;\r\ndata_len = packet_len - ((status & RS_ODDFRAME) ? 5 : 6);\r\ndata = skb_put(skb, data_len);\r\nSMC_PULL_DATA(lp, data, packet_len - 4);\r\nSMC_WAIT_MMU_BUSY(lp);\r\nSMC_SET_MMU_CMD(lp, MC_RELEASE);\r\nPRINT_PKT(data, packet_len - 4);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += data_len;\r\n}\r\n}\r\nstatic void smc_hardware_send_pkt(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nstruct sk_buff *skb;\r\nunsigned int packet_no, len;\r\nunsigned char *buf;\r\nunsigned long flags;\r\nDBG(3, dev, "%s\n", __func__);\r\nif (!smc_special_trylock(&lp->lock, flags)) {\r\nnetif_stop_queue(dev);\r\ntasklet_schedule(&lp->tx_task);\r\nreturn;\r\n}\r\nskb = lp->pending_tx_skb;\r\nif (unlikely(!skb)) {\r\nsmc_special_unlock(&lp->lock, flags);\r\nreturn;\r\n}\r\nlp->pending_tx_skb = NULL;\r\npacket_no = SMC_GET_AR(lp);\r\nif (unlikely(packet_no & AR_FAILED)) {\r\nnetdev_err(dev, "Memory allocation failed.\n");\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_fifo_errors++;\r\nsmc_special_unlock(&lp->lock, flags);\r\ngoto done;\r\n}\r\nSMC_SET_PN(lp, packet_no);\r\nSMC_SET_PTR(lp, PTR_AUTOINC);\r\nbuf = skb->data;\r\nlen = skb->len;\r\nDBG(2, dev, "TX PNR 0x%x LENGTH 0x%04x (%d) BUF 0x%p\n",\r\npacket_no, len, len, buf);\r\nPRINT_PKT(buf, len);\r\nSMC_PUT_PKT_HDR(lp, 0, len + 6);\r\nSMC_PUSH_DATA(lp, buf, len & ~1);\r\nSMC_outw(((len & 1) ? (0x2000 | buf[len-1]) : 0), ioaddr, DATA_REG(lp));\r\nif (THROTTLE_TX_PKTS)\r\nnetif_stop_queue(dev);\r\nSMC_SET_MMU_CMD(lp, MC_ENQUEUE);\r\nsmc_special_unlock(&lp->lock, flags);\r\ndev->trans_start = jiffies;\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += len;\r\nSMC_ENABLE_INT(lp, IM_TX_INT | IM_TX_EMPTY_INT);\r\ndone: if (!THROTTLE_TX_PKTS)\r\nnetif_wake_queue(dev);\r\ndev_consume_skb_any(skb);\r\n}\r\nstatic int smc_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nunsigned int numPages, poll_count, status;\r\nunsigned long flags;\r\nDBG(3, dev, "%s\n", __func__);\r\nBUG_ON(lp->pending_tx_skb != NULL);\r\nnumPages = ((skb->len & ~1) + (6 - 1)) >> 8;\r\nif (unlikely(numPages > 7)) {\r\nnetdev_warn(dev, "Far too big packet error.\n");\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nsmc_special_lock(&lp->lock, flags);\r\nSMC_SET_MMU_CMD(lp, MC_ALLOC | numPages);\r\npoll_count = MEMORY_WAIT_TIME;\r\ndo {\r\nstatus = SMC_GET_INT(lp);\r\nif (status & IM_ALLOC_INT) {\r\nSMC_ACK_INT(lp, IM_ALLOC_INT);\r\nbreak;\r\n}\r\n} while (--poll_count);\r\nsmc_special_unlock(&lp->lock, flags);\r\nlp->pending_tx_skb = skb;\r\nif (!poll_count) {\r\nnetif_stop_queue(dev);\r\nDBG(2, dev, "TX memory allocation deferred.\n");\r\nSMC_ENABLE_INT(lp, IM_ALLOC_INT);\r\n} else {\r\nsmc_hardware_send_pkt((unsigned long)dev);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void smc_tx(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nunsigned int saved_packet, packet_no, tx_status, pkt_len;\r\nDBG(3, dev, "%s\n", __func__);\r\npacket_no = SMC_GET_TXFIFO(lp);\r\nif (unlikely(packet_no & TXFIFO_TEMPTY)) {\r\nPRINTK(dev, "smc_tx with nothing on FIFO.\n");\r\nreturn;\r\n}\r\nsaved_packet = SMC_GET_PN(lp);\r\nSMC_SET_PN(lp, packet_no);\r\nSMC_SET_PTR(lp, PTR_AUTOINC | PTR_READ);\r\nSMC_GET_PKT_HDR(lp, tx_status, pkt_len);\r\nDBG(2, dev, "TX STATUS 0x%04x PNR 0x%02x\n",\r\ntx_status, packet_no);\r\nif (!(tx_status & ES_TX_SUC))\r\ndev->stats.tx_errors++;\r\nif (tx_status & ES_LOSTCARR)\r\ndev->stats.tx_carrier_errors++;\r\nif (tx_status & (ES_LATCOL | ES_16COL)) {\r\nPRINTK(dev, "%s occurred on last xmit\n",\r\n(tx_status & ES_LATCOL) ?\r\n"late collision" : "too many collisions");\r\ndev->stats.tx_window_errors++;\r\nif (!(dev->stats.tx_window_errors & 63) && net_ratelimit()) {\r\nnetdev_info(dev, "unexpectedly large number of bad collisions. Please check duplex setting.\n");\r\n}\r\n}\r\nSMC_WAIT_MMU_BUSY(lp);\r\nSMC_SET_MMU_CMD(lp, MC_FREEPKT);\r\nSMC_WAIT_MMU_BUSY(lp);\r\nSMC_SET_PN(lp, saved_packet);\r\nSMC_SELECT_BANK(lp, 0);\r\nSMC_SET_TCR(lp, lp->tcr_cur_mode);\r\nSMC_SELECT_BANK(lp, 2);\r\n}\r\nstatic void smc_mii_out(struct net_device *dev, unsigned int val, int bits)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nunsigned int mii_reg, mask;\r\nmii_reg = SMC_GET_MII(lp) & ~(MII_MCLK | MII_MDOE | MII_MDO);\r\nmii_reg |= MII_MDOE;\r\nfor (mask = 1 << (bits - 1); mask; mask >>= 1) {\r\nif (val & mask)\r\nmii_reg |= MII_MDO;\r\nelse\r\nmii_reg &= ~MII_MDO;\r\nSMC_SET_MII(lp, mii_reg);\r\nudelay(MII_DELAY);\r\nSMC_SET_MII(lp, mii_reg | MII_MCLK);\r\nudelay(MII_DELAY);\r\n}\r\n}\r\nstatic unsigned int smc_mii_in(struct net_device *dev, int bits)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nunsigned int mii_reg, mask, val;\r\nmii_reg = SMC_GET_MII(lp) & ~(MII_MCLK | MII_MDOE | MII_MDO);\r\nSMC_SET_MII(lp, mii_reg);\r\nfor (mask = 1 << (bits - 1), val = 0; mask; mask >>= 1) {\r\nif (SMC_GET_MII(lp) & MII_MDI)\r\nval |= mask;\r\nSMC_SET_MII(lp, mii_reg);\r\nudelay(MII_DELAY);\r\nSMC_SET_MII(lp, mii_reg | MII_MCLK);\r\nudelay(MII_DELAY);\r\n}\r\nreturn val;\r\n}\r\nstatic int smc_phy_read(struct net_device *dev, int phyaddr, int phyreg)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nunsigned int phydata;\r\nSMC_SELECT_BANK(lp, 3);\r\nsmc_mii_out(dev, 0xffffffff, 32);\r\nsmc_mii_out(dev, 6 << 10 | phyaddr << 5 | phyreg, 14);\r\nphydata = smc_mii_in(dev, 18);\r\nSMC_SET_MII(lp, SMC_GET_MII(lp) & ~(MII_MCLK|MII_MDOE|MII_MDO));\r\nDBG(3, dev, "%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\n",\r\n__func__, phyaddr, phyreg, phydata);\r\nSMC_SELECT_BANK(lp, 2);\r\nreturn phydata;\r\n}\r\nstatic void smc_phy_write(struct net_device *dev, int phyaddr, int phyreg,\r\nint phydata)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nSMC_SELECT_BANK(lp, 3);\r\nsmc_mii_out(dev, 0xffffffff, 32);\r\nsmc_mii_out(dev, 5 << 28 | phyaddr << 23 | phyreg << 18 | 2 << 16 | phydata, 32);\r\nSMC_SET_MII(lp, SMC_GET_MII(lp) & ~(MII_MCLK|MII_MDOE|MII_MDO));\r\nDBG(3, dev, "%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\n",\r\n__func__, phyaddr, phyreg, phydata);\r\nSMC_SELECT_BANK(lp, 2);\r\n}\r\nstatic void smc_phy_detect(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nint phyaddr;\r\nDBG(2, dev, "%s\n", __func__);\r\nlp->phy_type = 0;\r\nfor (phyaddr = 1; phyaddr < 33; ++phyaddr) {\r\nunsigned int id1, id2;\r\nid1 = smc_phy_read(dev, phyaddr & 31, MII_PHYSID1);\r\nid2 = smc_phy_read(dev, phyaddr & 31, MII_PHYSID2);\r\nDBG(3, dev, "phy_id1=0x%x, phy_id2=0x%x\n",\r\nid1, id2);\r\nif (id1 != 0x0000 && id1 != 0xffff && id1 != 0x8000 &&\r\nid2 != 0x0000 && id2 != 0xffff && id2 != 0x8000) {\r\nlp->mii.phy_id = phyaddr & 31;\r\nlp->phy_type = id1 << 16 | id2;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int smc_phy_fixed(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nint phyaddr = lp->mii.phy_id;\r\nint bmcr, cfg1;\r\nDBG(3, dev, "%s\n", __func__);\r\ncfg1 = smc_phy_read(dev, phyaddr, PHY_CFG1_REG);\r\ncfg1 |= PHY_CFG1_LNKDIS;\r\nsmc_phy_write(dev, phyaddr, PHY_CFG1_REG, cfg1);\r\nbmcr = 0;\r\nif (lp->ctl_rfduplx)\r\nbmcr |= BMCR_FULLDPLX;\r\nif (lp->ctl_rspeed == 100)\r\nbmcr |= BMCR_SPEED100;\r\nsmc_phy_write(dev, phyaddr, MII_BMCR, bmcr);\r\nSMC_SELECT_BANK(lp, 0);\r\nSMC_SET_RPC(lp, lp->rpc_cur_mode);\r\nSMC_SELECT_BANK(lp, 2);\r\nreturn 1;\r\n}\r\nstatic int smc_phy_reset(struct net_device *dev, int phy)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nunsigned int bmcr;\r\nint timeout;\r\nsmc_phy_write(dev, phy, MII_BMCR, BMCR_RESET);\r\nfor (timeout = 2; timeout; timeout--) {\r\nspin_unlock_irq(&lp->lock);\r\nmsleep(50);\r\nspin_lock_irq(&lp->lock);\r\nbmcr = smc_phy_read(dev, phy, MII_BMCR);\r\nif (!(bmcr & BMCR_RESET))\r\nbreak;\r\n}\r\nreturn bmcr & BMCR_RESET;\r\n}\r\nstatic void smc_phy_powerdown(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nunsigned int bmcr;\r\nint phy = lp->mii.phy_id;\r\nif (lp->phy_type == 0)\r\nreturn;\r\ncancel_work_sync(&lp->phy_configure);\r\nbmcr = smc_phy_read(dev, phy, MII_BMCR);\r\nsmc_phy_write(dev, phy, MII_BMCR, bmcr | BMCR_PDOWN);\r\n}\r\nstatic void smc_phy_check_media(struct net_device *dev, int init)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nif (mii_check_media(&lp->mii, netif_msg_link(lp), init)) {\r\nif (lp->mii.full_duplex) {\r\nlp->tcr_cur_mode |= TCR_SWFDUP;\r\n} else {\r\nlp->tcr_cur_mode &= ~TCR_SWFDUP;\r\n}\r\nSMC_SELECT_BANK(lp, 0);\r\nSMC_SET_TCR(lp, lp->tcr_cur_mode);\r\n}\r\n}\r\nstatic void smc_phy_configure(struct work_struct *work)\r\n{\r\nstruct smc_local *lp =\r\ncontainer_of(work, struct smc_local, phy_configure);\r\nstruct net_device *dev = lp->dev;\r\nvoid __iomem *ioaddr = lp->base;\r\nint phyaddr = lp->mii.phy_id;\r\nint my_phy_caps;\r\nint my_ad_caps;\r\nint status;\r\nDBG(3, dev, "smc_program_phy()\n");\r\nspin_lock_irq(&lp->lock);\r\nif (lp->phy_type == 0)\r\ngoto smc_phy_configure_exit;\r\nif (smc_phy_reset(dev, phyaddr)) {\r\nnetdev_info(dev, "PHY reset timed out\n");\r\ngoto smc_phy_configure_exit;\r\n}\r\nsmc_phy_write(dev, phyaddr, PHY_MASK_REG,\r\nPHY_INT_LOSSSYNC | PHY_INT_CWRD | PHY_INT_SSD |\r\nPHY_INT_ESD | PHY_INT_RPOL | PHY_INT_JAB |\r\nPHY_INT_SPDDET | PHY_INT_DPLXDET);\r\nSMC_SELECT_BANK(lp, 0);\r\nSMC_SET_RPC(lp, lp->rpc_cur_mode);\r\nif (lp->mii.force_media) {\r\nsmc_phy_fixed(dev);\r\ngoto smc_phy_configure_exit;\r\n}\r\nmy_phy_caps = smc_phy_read(dev, phyaddr, MII_BMSR);\r\nif (!(my_phy_caps & BMSR_ANEGCAPABLE)) {\r\nnetdev_info(dev, "Auto negotiation NOT supported\n");\r\nsmc_phy_fixed(dev);\r\ngoto smc_phy_configure_exit;\r\n}\r\nmy_ad_caps = ADVERTISE_CSMA;\r\nif (my_phy_caps & BMSR_100BASE4)\r\nmy_ad_caps |= ADVERTISE_100BASE4;\r\nif (my_phy_caps & BMSR_100FULL)\r\nmy_ad_caps |= ADVERTISE_100FULL;\r\nif (my_phy_caps & BMSR_100HALF)\r\nmy_ad_caps |= ADVERTISE_100HALF;\r\nif (my_phy_caps & BMSR_10FULL)\r\nmy_ad_caps |= ADVERTISE_10FULL;\r\nif (my_phy_caps & BMSR_10HALF)\r\nmy_ad_caps |= ADVERTISE_10HALF;\r\nif (lp->ctl_rspeed != 100)\r\nmy_ad_caps &= ~(ADVERTISE_100BASE4|ADVERTISE_100FULL|ADVERTISE_100HALF);\r\nif (!lp->ctl_rfduplx)\r\nmy_ad_caps &= ~(ADVERTISE_100FULL|ADVERTISE_10FULL);\r\nsmc_phy_write(dev, phyaddr, MII_ADVERTISE, my_ad_caps);\r\nlp->mii.advertising = my_ad_caps;\r\nstatus = smc_phy_read(dev, phyaddr, MII_ADVERTISE);\r\nDBG(2, dev, "phy caps=%x\n", my_phy_caps);\r\nDBG(2, dev, "phy advertised caps=%x\n", my_ad_caps);\r\nsmc_phy_write(dev, phyaddr, MII_BMCR, BMCR_ANENABLE | BMCR_ANRESTART);\r\nsmc_phy_check_media(dev, 1);\r\nsmc_phy_configure_exit:\r\nSMC_SELECT_BANK(lp, 2);\r\nspin_unlock_irq(&lp->lock);\r\n}\r\nstatic void smc_phy_interrupt(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nint phyaddr = lp->mii.phy_id;\r\nint phy18;\r\nDBG(2, dev, "%s\n", __func__);\r\nif (lp->phy_type == 0)\r\nreturn;\r\nfor(;;) {\r\nsmc_phy_check_media(dev, 0);\r\nphy18 = smc_phy_read(dev, phyaddr, PHY_INT_REG);\r\nif ((phy18 & PHY_INT_INT) == 0)\r\nbreak;\r\n}\r\n}\r\nstatic void smc_10bt_check_media(struct net_device *dev, int init)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nunsigned int old_carrier, new_carrier;\r\nold_carrier = netif_carrier_ok(dev) ? 1 : 0;\r\nSMC_SELECT_BANK(lp, 0);\r\nnew_carrier = (SMC_GET_EPH_STATUS(lp) & ES_LINK_OK) ? 1 : 0;\r\nSMC_SELECT_BANK(lp, 2);\r\nif (init || (old_carrier != new_carrier)) {\r\nif (!new_carrier) {\r\nnetif_carrier_off(dev);\r\n} else {\r\nnetif_carrier_on(dev);\r\n}\r\nif (netif_msg_link(lp))\r\nnetdev_info(dev, "link %s\n",\r\nnew_carrier ? "up" : "down");\r\n}\r\n}\r\nstatic void smc_eph_interrupt(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nunsigned int ctl;\r\nsmc_10bt_check_media(dev, 0);\r\nSMC_SELECT_BANK(lp, 1);\r\nctl = SMC_GET_CTL(lp);\r\nSMC_SET_CTL(lp, ctl & ~CTL_LE_ENABLE);\r\nSMC_SET_CTL(lp, ctl);\r\nSMC_SELECT_BANK(lp, 2);\r\n}\r\nstatic irqreturn_t smc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nint status, mask, timeout, card_stats;\r\nint saved_pointer;\r\nDBG(3, dev, "%s\n", __func__);\r\nspin_lock(&lp->lock);\r\nSMC_INTERRUPT_PREAMBLE;\r\nsaved_pointer = SMC_GET_PTR(lp);\r\nmask = SMC_GET_INT_MASK(lp);\r\nSMC_SET_INT_MASK(lp, 0);\r\ntimeout = MAX_IRQ_LOOPS;\r\ndo {\r\nstatus = SMC_GET_INT(lp);\r\nDBG(2, dev, "INT 0x%02x MASK 0x%02x MEM 0x%04x FIFO 0x%04x\n",\r\nstatus, mask,\r\n({ int meminfo; SMC_SELECT_BANK(lp, 0);\r\nmeminfo = SMC_GET_MIR(lp);\r\nSMC_SELECT_BANK(lp, 2); meminfo; }),\r\nSMC_GET_FIFO(lp));\r\nstatus &= mask;\r\nif (!status)\r\nbreak;\r\nif (status & IM_TX_INT) {\r\nDBG(3, dev, "TX int\n");\r\nsmc_tx(dev);\r\nSMC_ACK_INT(lp, IM_TX_INT);\r\nif (THROTTLE_TX_PKTS)\r\nnetif_wake_queue(dev);\r\n} else if (status & IM_RCV_INT) {\r\nDBG(3, dev, "RX irq\n");\r\nsmc_rcv(dev);\r\n} else if (status & IM_ALLOC_INT) {\r\nDBG(3, dev, "Allocation irq\n");\r\ntasklet_hi_schedule(&lp->tx_task);\r\nmask &= ~IM_ALLOC_INT;\r\n} else if (status & IM_TX_EMPTY_INT) {\r\nDBG(3, dev, "TX empty\n");\r\nmask &= ~IM_TX_EMPTY_INT;\r\nSMC_SELECT_BANK(lp, 0);\r\ncard_stats = SMC_GET_COUNTER(lp);\r\nSMC_SELECT_BANK(lp, 2);\r\ndev->stats.collisions += card_stats & 0xF;\r\ncard_stats >>= 4;\r\ndev->stats.collisions += card_stats & 0xF;\r\n} else if (status & IM_RX_OVRN_INT) {\r\nDBG(1, dev, "RX overrun (EPH_ST 0x%04x)\n",\r\n({ int eph_st; SMC_SELECT_BANK(lp, 0);\r\neph_st = SMC_GET_EPH_STATUS(lp);\r\nSMC_SELECT_BANK(lp, 2); eph_st; }));\r\nSMC_ACK_INT(lp, IM_RX_OVRN_INT);\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_fifo_errors++;\r\n} else if (status & IM_EPH_INT) {\r\nsmc_eph_interrupt(dev);\r\n} else if (status & IM_MDINT) {\r\nSMC_ACK_INT(lp, IM_MDINT);\r\nsmc_phy_interrupt(dev);\r\n} else if (status & IM_ERCV_INT) {\r\nSMC_ACK_INT(lp, IM_ERCV_INT);\r\nPRINTK(dev, "UNSUPPORTED: ERCV INTERRUPT\n");\r\n}\r\n} while (--timeout);\r\nSMC_SET_PTR(lp, saved_pointer);\r\nSMC_SET_INT_MASK(lp, mask);\r\nspin_unlock(&lp->lock);\r\n#ifndef CONFIG_NET_POLL_CONTROLLER\r\nif (timeout == MAX_IRQ_LOOPS)\r\nPRINTK(dev, "spurious interrupt (mask = 0x%02x)\n",\r\nmask);\r\n#endif\r\nDBG(3, dev, "Interrupt done (%d loops)\n",\r\nMAX_IRQ_LOOPS - timeout);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void smc_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\nsmc_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic void smc_timeout(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nint status, mask, eph_st, meminfo, fifo;\r\nDBG(2, dev, "%s\n", __func__);\r\nspin_lock_irq(&lp->lock);\r\nstatus = SMC_GET_INT(lp);\r\nmask = SMC_GET_INT_MASK(lp);\r\nfifo = SMC_GET_FIFO(lp);\r\nSMC_SELECT_BANK(lp, 0);\r\neph_st = SMC_GET_EPH_STATUS(lp);\r\nmeminfo = SMC_GET_MIR(lp);\r\nSMC_SELECT_BANK(lp, 2);\r\nspin_unlock_irq(&lp->lock);\r\nPRINTK(dev, "TX timeout (INT 0x%02x INTMASK 0x%02x MEM 0x%04x FIFO 0x%04x EPH_ST 0x%04x)\n",\r\nstatus, mask, meminfo, fifo, eph_st);\r\nsmc_reset(dev);\r\nsmc_enable(dev);\r\nif (lp->phy_type != 0)\r\nschedule_work(&lp->phy_configure);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void smc_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nunsigned char multicast_table[8];\r\nint update_multicast = 0;\r\nDBG(2, dev, "%s\n", __func__);\r\nif (dev->flags & IFF_PROMISC) {\r\nDBG(2, dev, "RCR_PRMS\n");\r\nlp->rcr_cur_mode |= RCR_PRMS;\r\n}\r\nelse if (dev->flags & IFF_ALLMULTI || netdev_mc_count(dev) > 16) {\r\nDBG(2, dev, "RCR_ALMUL\n");\r\nlp->rcr_cur_mode |= RCR_ALMUL;\r\n}\r\nelse if (!netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\nstatic const unsigned char invert3[] = {0, 4, 2, 6, 1, 5, 3, 7};\r\nmemset(multicast_table, 0, sizeof(multicast_table));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint position;\r\nposition = crc32_le(~0, ha->addr, 6) & 0x3f;\r\nmulticast_table[invert3[position&7]] |=\r\n(1<<invert3[(position>>3)&7]);\r\n}\r\nlp->rcr_cur_mode &= ~(RCR_PRMS | RCR_ALMUL);\r\nupdate_multicast = 1;\r\n} else {\r\nDBG(2, dev, "~(RCR_PRMS|RCR_ALMUL)\n");\r\nlp->rcr_cur_mode &= ~(RCR_PRMS | RCR_ALMUL);\r\nmemset(multicast_table, 0, sizeof(multicast_table));\r\nupdate_multicast = 1;\r\n}\r\nspin_lock_irq(&lp->lock);\r\nSMC_SELECT_BANK(lp, 0);\r\nSMC_SET_RCR(lp, lp->rcr_cur_mode);\r\nif (update_multicast) {\r\nSMC_SELECT_BANK(lp, 3);\r\nSMC_SET_MCAST(lp, multicast_table);\r\n}\r\nSMC_SELECT_BANK(lp, 2);\r\nspin_unlock_irq(&lp->lock);\r\n}\r\nstatic int\r\nsmc_open(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nDBG(2, dev, "%s\n", __func__);\r\nlp->tcr_cur_mode = TCR_DEFAULT;\r\nlp->rcr_cur_mode = RCR_DEFAULT;\r\nlp->rpc_cur_mode = RPC_DEFAULT |\r\nlp->cfg.leda << RPC_LSXA_SHFT |\r\nlp->cfg.ledb << RPC_LSXB_SHFT;\r\nif (lp->phy_type == 0)\r\nlp->tcr_cur_mode |= TCR_MON_CSN;\r\nsmc_reset(dev);\r\nsmc_enable(dev);\r\nif (lp->phy_type != 0)\r\nsmc_phy_configure(&lp->phy_configure);\r\nelse {\r\nspin_lock_irq(&lp->lock);\r\nsmc_10bt_check_media(dev, 1);\r\nspin_unlock_irq(&lp->lock);\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int smc_close(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nDBG(2, dev, "%s\n", __func__);\r\nnetif_stop_queue(dev);\r\nnetif_carrier_off(dev);\r\nsmc_shutdown(dev);\r\ntasklet_kill(&lp->tx_task);\r\nsmc_phy_powerdown(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nsmc_ethtool_getsettings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nint ret;\r\ncmd->maxtxpkt = 1;\r\ncmd->maxrxpkt = 1;\r\nif (lp->phy_type != 0) {\r\nspin_lock_irq(&lp->lock);\r\nret = mii_ethtool_gset(&lp->mii, cmd);\r\nspin_unlock_irq(&lp->lock);\r\n} else {\r\ncmd->supported = SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_TP | SUPPORTED_AUI;\r\nif (lp->ctl_rspeed == 10)\r\nethtool_cmd_speed_set(cmd, SPEED_10);\r\nelse if (lp->ctl_rspeed == 100)\r\nethtool_cmd_speed_set(cmd, SPEED_100);\r\ncmd->autoneg = AUTONEG_DISABLE;\r\ncmd->transceiver = XCVR_INTERNAL;\r\ncmd->port = 0;\r\ncmd->duplex = lp->tcr_cur_mode & TCR_SWFDUP ? DUPLEX_FULL : DUPLEX_HALF;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nsmc_ethtool_setsettings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nint ret;\r\nif (lp->phy_type != 0) {\r\nspin_lock_irq(&lp->lock);\r\nret = mii_ethtool_sset(&lp->mii, cmd);\r\nspin_unlock_irq(&lp->lock);\r\n} else {\r\nif (cmd->autoneg != AUTONEG_DISABLE ||\r\ncmd->speed != SPEED_10 ||\r\n(cmd->duplex != DUPLEX_HALF && cmd->duplex != DUPLEX_FULL) ||\r\n(cmd->port != PORT_TP && cmd->port != PORT_AUI))\r\nreturn -EINVAL;\r\nlp->ctl_rfduplx = cmd->duplex == DUPLEX_FULL;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nsmc_ethtool_getdrvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, CARDNAME, sizeof(info->driver));\r\nstrlcpy(info->version, version, sizeof(info->version));\r\nstrlcpy(info->bus_info, dev_name(dev->dev.parent),\r\nsizeof(info->bus_info));\r\n}\r\nstatic int smc_ethtool_nwayreset(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nint ret = -EINVAL;\r\nif (lp->phy_type != 0) {\r\nspin_lock_irq(&lp->lock);\r\nret = mii_nway_restart(&lp->mii);\r\nspin_unlock_irq(&lp->lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic u32 smc_ethtool_getmsglevel(struct net_device *dev)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nreturn lp->msg_enable;\r\n}\r\nstatic void smc_ethtool_setmsglevel(struct net_device *dev, u32 level)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nlp->msg_enable = level;\r\n}\r\nstatic int smc_write_eeprom_word(struct net_device *dev, u16 addr, u16 word)\r\n{\r\nu16 ctl;\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nspin_lock_irq(&lp->lock);\r\nSMC_SELECT_BANK(lp, 1);\r\nSMC_SET_GP(lp, word);\r\nSMC_SELECT_BANK(lp, 2);\r\nSMC_SET_PTR(lp, addr);\r\nSMC_SELECT_BANK(lp, 1);\r\nctl = SMC_GET_CTL(lp);\r\nSMC_SET_CTL(lp, ctl | (CTL_EEPROM_SELECT | CTL_STORE));\r\ndo {\r\nudelay(1);\r\n} while (SMC_GET_CTL(lp) & CTL_STORE);\r\nSMC_SET_CTL(lp, ctl);\r\nSMC_SELECT_BANK(lp, 2);\r\nspin_unlock_irq(&lp->lock);\r\nreturn 0;\r\n}\r\nstatic int smc_read_eeprom_word(struct net_device *dev, u16 addr, u16 *word)\r\n{\r\nu16 ctl;\r\nstruct smc_local *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nspin_lock_irq(&lp->lock);\r\nSMC_SELECT_BANK(lp, 2);\r\nSMC_SET_PTR(lp, addr | PTR_READ);\r\nSMC_SELECT_BANK(lp, 1);\r\nSMC_SET_GP(lp, 0xffff);\r\nctl = SMC_GET_CTL(lp);\r\nSMC_SET_CTL(lp, ctl | (CTL_EEPROM_SELECT | CTL_RELOAD));\r\ndo {\r\nudelay(1);\r\n} while (SMC_GET_CTL(lp) & CTL_RELOAD);\r\n*word = SMC_GET_GP(lp);\r\nSMC_SET_CTL(lp, ctl);\r\nSMC_SELECT_BANK(lp, 2);\r\nspin_unlock_irq(&lp->lock);\r\nreturn 0;\r\n}\r\nstatic int smc_ethtool_geteeprom_len(struct net_device *dev)\r\n{\r\nreturn 0x23 * 2;\r\n}\r\nstatic int smc_ethtool_geteeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nint i;\r\nint imax;\r\nDBG(1, dev, "Reading %d bytes at %d(0x%x)\n",\r\neeprom->len, eeprom->offset, eeprom->offset);\r\nimax = smc_ethtool_geteeprom_len(dev);\r\nfor (i = 0; i < eeprom->len; i += 2) {\r\nint ret;\r\nu16 wbuf;\r\nint offset = i + eeprom->offset;\r\nif (offset > imax)\r\nbreak;\r\nret = smc_read_eeprom_word(dev, offset >> 1, &wbuf);\r\nif (ret != 0)\r\nreturn ret;\r\nDBG(2, dev, "Read 0x%x from 0x%x\n", wbuf, offset >> 1);\r\ndata[i] = (wbuf >> 8) & 0xff;\r\ndata[i+1] = wbuf & 0xff;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smc_ethtool_seteeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nint i;\r\nint imax;\r\nDBG(1, dev, "Writing %d bytes to %d(0x%x)\n",\r\neeprom->len, eeprom->offset, eeprom->offset);\r\nimax = smc_ethtool_geteeprom_len(dev);\r\nfor (i = 0; i < eeprom->len; i += 2) {\r\nint ret;\r\nu16 wbuf;\r\nint offset = i + eeprom->offset;\r\nif (offset > imax)\r\nbreak;\r\nwbuf = (data[i] << 8) | data[i + 1];\r\nDBG(2, dev, "Writing 0x%x to 0x%x\n", wbuf, offset >> 1);\r\nret = smc_write_eeprom_word(dev, offset >> 1, wbuf);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smc_findirq(struct smc_local *lp)\r\n{\r\nvoid __iomem *ioaddr = lp->base;\r\nint timeout = 20;\r\nunsigned long cookie;\r\nDBG(2, lp->dev, "%s: %s\n", CARDNAME, __func__);\r\ncookie = probe_irq_on();\r\nSMC_SELECT_BANK(lp, 2);\r\nSMC_SET_INT_MASK(lp, IM_ALLOC_INT);\r\nSMC_SET_MMU_CMD(lp, MC_ALLOC | 1);\r\ndo {\r\nint int_status;\r\nudelay(10);\r\nint_status = SMC_GET_INT(lp);\r\nif (int_status & IM_ALLOC_INT)\r\nbreak;\r\n} while (--timeout);\r\nSMC_SET_INT_MASK(lp, 0);\r\nreturn probe_irq_off(cookie);\r\n}\r\nstatic int smc_probe(struct net_device *dev, void __iomem *ioaddr,\r\nunsigned long irq_flags)\r\n{\r\nstruct smc_local *lp = netdev_priv(dev);\r\nint retval;\r\nunsigned int val, revision_register;\r\nconst char *version_string;\r\nDBG(2, dev, "%s: %s\n", CARDNAME, __func__);\r\nval = SMC_CURRENT_BANK(lp);\r\nDBG(2, dev, "%s: bank signature probe returned 0x%04x\n",\r\nCARDNAME, val);\r\nif ((val & 0xFF00) != 0x3300) {\r\nif ((val & 0xFF) == 0x33) {\r\nnetdev_warn(dev,\r\n"%s: Detected possible byte-swapped interface at IOADDR %p\n",\r\nCARDNAME, ioaddr);\r\n}\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\nSMC_SELECT_BANK(lp, 0);\r\nval = SMC_CURRENT_BANK(lp);\r\nif ((val & 0xFF00) != 0x3300) {\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\nSMC_SELECT_BANK(lp, 1);\r\nval = SMC_GET_BASE(lp);\r\nval = ((val & 0x1F00) >> 3) << SMC_IO_SHIFT;\r\nif (((unsigned long)ioaddr & (0x3e0 << SMC_IO_SHIFT)) != val) {\r\nnetdev_warn(dev, "%s: IOADDR %p doesn't match configuration (%x).\n",\r\nCARDNAME, ioaddr, val);\r\n}\r\nSMC_SELECT_BANK(lp, 3);\r\nrevision_register = SMC_GET_REV(lp);\r\nDBG(2, dev, "%s: revision = 0x%04x\n", CARDNAME, revision_register);\r\nversion_string = chip_ids[ (revision_register >> 4) & 0xF];\r\nif (!version_string || (revision_register & 0xff00) != 0x3300) {\r\nnetdev_warn(dev, "%s: IO %p: Unrecognized revision register 0x%04x, Contact author.\n",\r\nCARDNAME, ioaddr, revision_register);\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\npr_info_once("%s\n", version);\r\ndev->base_addr = (unsigned long)ioaddr;\r\nlp->base = ioaddr;\r\nlp->version = revision_register & 0xff;\r\nspin_lock_init(&lp->lock);\r\nSMC_SELECT_BANK(lp, 1);\r\nSMC_GET_MAC_ADDR(lp, dev->dev_addr);\r\nsmc_reset(dev);\r\nif (dev->irq < 1) {\r\nint trials;\r\ntrials = 3;\r\nwhile (trials--) {\r\ndev->irq = smc_findirq(lp);\r\nif (dev->irq)\r\nbreak;\r\nsmc_reset(dev);\r\n}\r\n}\r\nif (dev->irq == 0) {\r\nnetdev_warn(dev, "Couldn't autodetect your IRQ. Use irq=xx.\n");\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\ndev->irq = irq_canonicalize(dev->irq);\r\nether_setup(dev);\r\ndev->watchdog_timeo = msecs_to_jiffies(watchdog);\r\ndev->netdev_ops = &smc_netdev_ops;\r\ndev->ethtool_ops = &smc_ethtool_ops;\r\ntasklet_init(&lp->tx_task, smc_hardware_send_pkt, (unsigned long)dev);\r\nINIT_WORK(&lp->phy_configure, smc_phy_configure);\r\nlp->dev = dev;\r\nlp->mii.phy_id_mask = 0x1f;\r\nlp->mii.reg_num_mask = 0x1f;\r\nlp->mii.force_media = 0;\r\nlp->mii.full_duplex = 0;\r\nlp->mii.dev = dev;\r\nlp->mii.mdio_read = smc_phy_read;\r\nlp->mii.mdio_write = smc_phy_write;\r\nif (lp->version >= (CHIP_91100 << 4))\r\nsmc_phy_detect(dev);\r\nsmc_shutdown(dev);\r\nsmc_phy_powerdown(dev);\r\nlp->msg_enable = NETIF_MSG_LINK;\r\nlp->ctl_rfduplx = 0;\r\nlp->ctl_rspeed = 10;\r\nif (lp->version >= (CHIP_91100 << 4)) {\r\nlp->ctl_rfduplx = 1;\r\nlp->ctl_rspeed = 100;\r\n}\r\nretval = request_irq(dev->irq, smc_interrupt, irq_flags, dev->name, dev);\r\nif (retval)\r\ngoto err_out;\r\n#ifdef CONFIG_ARCH_PXA\r\n# ifdef SMC_USE_PXA_DMA\r\nlp->cfg.flags |= SMC91X_USE_DMA;\r\n# endif\r\nif (lp->cfg.flags & SMC91X_USE_DMA) {\r\nint dma = pxa_request_dma(dev->name, DMA_PRIO_LOW,\r\nsmc_pxa_dma_irq, NULL);\r\nif (dma >= 0)\r\ndev->dma = dma;\r\n}\r\n#endif\r\nretval = register_netdev(dev);\r\nif (retval == 0) {\r\nnetdev_info(dev, "%s (rev %d) at %p IRQ %d",\r\nversion_string, revision_register & 0x0f,\r\nlp->base, dev->irq);\r\nif (dev->dma != (unsigned char)-1)\r\npr_cont(" DMA %d", dev->dma);\r\npr_cont("%s%s\n",\r\nlp->cfg.flags & SMC91X_NOWAIT ? " [nowait]" : "",\r\nTHROTTLE_TX_PKTS ? " [throttle_tx]" : "");\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nnetdev_warn(dev, "Invalid ethernet MAC address. Please set using ifconfig\n");\r\n} else {\r\nnetdev_info(dev, "Ethernet addr: %pM\n",\r\ndev->dev_addr);\r\n}\r\nif (lp->phy_type == 0) {\r\nPRINTK(dev, "No PHY found\n");\r\n} else if ((lp->phy_type & 0xfffffff0) == 0x0016f840) {\r\nPRINTK(dev, "PHY LAN83C183 (LAN91C111 Internal)\n");\r\n} else if ((lp->phy_type & 0xfffffff0) == 0x02821c50) {\r\nPRINTK(dev, "PHY LAN83C180\n");\r\n}\r\n}\r\nerr_out:\r\n#ifdef CONFIG_ARCH_PXA\r\nif (retval && dev->dma != (unsigned char)-1)\r\npxa_free_dma(dev->dma);\r\n#endif\r\nreturn retval;\r\n}\r\nstatic int smc_enable_device(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct smc_local *lp = netdev_priv(ndev);\r\nunsigned long flags;\r\nunsigned char ecor, ecsr;\r\nvoid __iomem *addr;\r\nstruct resource * res;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "smc91x-attrib");\r\nif (!res)\r\nreturn 0;\r\naddr = ioremap(res->start, ATTRIB_SIZE);\r\nif (!addr)\r\nreturn -ENOMEM;\r\nlocal_irq_save(flags);\r\necor = readb(addr + (ECOR << SMC_IO_SHIFT)) & ~ECOR_RESET;\r\nwriteb(ecor | ECOR_RESET, addr + (ECOR << SMC_IO_SHIFT));\r\nreadb(addr + (ECOR << SMC_IO_SHIFT));\r\nudelay(100);\r\nwriteb(ecor, addr + (ECOR << SMC_IO_SHIFT));\r\nwriteb(ecor | ECOR_ENABLE, addr + (ECOR << SMC_IO_SHIFT));\r\necsr = readb(addr + (ECSR << SMC_IO_SHIFT)) & ~ECSR_IOIS8;\r\nif (!SMC_16BIT(lp))\r\necsr |= ECSR_IOIS8;\r\nwriteb(ecsr, addr + (ECSR << SMC_IO_SHIFT));\r\nlocal_irq_restore(flags);\r\niounmap(addr);\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int smc_request_attrib(struct platform_device *pdev,\r\nstruct net_device *ndev)\r\n{\r\nstruct resource * res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "smc91x-attrib");\r\nstruct smc_local *lp __maybe_unused = netdev_priv(ndev);\r\nif (!res)\r\nreturn 0;\r\nif (!request_mem_region(res->start, ATTRIB_SIZE, CARDNAME))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void smc_release_attrib(struct platform_device *pdev,\r\nstruct net_device *ndev)\r\n{\r\nstruct resource * res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "smc91x-attrib");\r\nstruct smc_local *lp __maybe_unused = netdev_priv(ndev);\r\nif (res)\r\nrelease_mem_region(res->start, ATTRIB_SIZE);\r\n}\r\nstatic inline void smc_request_datacs(struct platform_device *pdev, struct net_device *ndev)\r\n{\r\nif (SMC_CAN_USE_DATACS) {\r\nstruct resource * res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "smc91x-data32");\r\nstruct smc_local *lp = netdev_priv(ndev);\r\nif (!res)\r\nreturn;\r\nif(!request_mem_region(res->start, SMC_DATA_EXTENT, CARDNAME)) {\r\nnetdev_info(ndev, "%s: failed to request datacs memory region.\n",\r\nCARDNAME);\r\nreturn;\r\n}\r\nlp->datacs = ioremap(res->start, SMC_DATA_EXTENT);\r\n}\r\n}\r\nstatic void smc_release_datacs(struct platform_device *pdev, struct net_device *ndev)\r\n{\r\nif (SMC_CAN_USE_DATACS) {\r\nstruct smc_local *lp = netdev_priv(ndev);\r\nstruct resource * res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "smc91x-data32");\r\nif (lp->datacs)\r\niounmap(lp->datacs);\r\nlp->datacs = NULL;\r\nif (res)\r\nrelease_mem_region(res->start, SMC_DATA_EXTENT);\r\n}\r\n}\r\nstatic int smc_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct smc91x_platdata *pd = dev_get_platdata(&pdev->dev);\r\nconst struct of_device_id *match = NULL;\r\nstruct smc_local *lp;\r\nstruct net_device *ndev;\r\nstruct resource *res, *ires;\r\nunsigned int __iomem *addr;\r\nunsigned long irq_flags = SMC_IRQ_FLAGS;\r\nint ret;\r\nndev = alloc_etherdev(sizeof(struct smc_local));\r\nif (!ndev) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nlp = netdev_priv(ndev);\r\nlp->cfg.flags = 0;\r\nif (pd) {\r\nmemcpy(&lp->cfg, pd, sizeof(lp->cfg));\r\nlp->io_shift = SMC91X_IO_SHIFT(lp->cfg.flags);\r\n}\r\n#if IS_BUILTIN(CONFIG_OF)\r\nmatch = of_match_device(of_match_ptr(smc91x_match), &pdev->dev);\r\nif (match) {\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 val;\r\nif (!of_property_read_u32(np, "reg-io-width", &val)) {\r\nif (val & 1)\r\nlp->cfg.flags |= SMC91X_USE_8BIT;\r\nif ((val == 0) || (val & 2))\r\nlp->cfg.flags |= SMC91X_USE_16BIT;\r\nif (val & 4)\r\nlp->cfg.flags |= SMC91X_USE_32BIT;\r\n} else {\r\nlp->cfg.flags |= SMC91X_USE_16BIT;\r\n}\r\n}\r\n#endif\r\nif (!pd && !match) {\r\nlp->cfg.flags |= (SMC_CAN_USE_8BIT) ? SMC91X_USE_8BIT : 0;\r\nlp->cfg.flags |= (SMC_CAN_USE_16BIT) ? SMC91X_USE_16BIT : 0;\r\nlp->cfg.flags |= (SMC_CAN_USE_32BIT) ? SMC91X_USE_32BIT : 0;\r\nlp->cfg.flags |= (nowait) ? SMC91X_NOWAIT : 0;\r\n}\r\nif (!lp->cfg.leda && !lp->cfg.ledb) {\r\nlp->cfg.leda = RPC_LSA_DEFAULT;\r\nlp->cfg.ledb = RPC_LSB_DEFAULT;\r\n}\r\nndev->dma = (unsigned char)-1;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "smc91x-regs");\r\nif (!res)\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\ngoto out_free_netdev;\r\n}\r\nif (!request_mem_region(res->start, SMC_IO_EXTENT, CARDNAME)) {\r\nret = -EBUSY;\r\ngoto out_free_netdev;\r\n}\r\nires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!ires) {\r\nret = -ENODEV;\r\ngoto out_release_io;\r\n}\r\nndev->irq = ires->start;\r\nif (irq_flags == -1 || ires->flags & IRQF_TRIGGER_MASK)\r\nirq_flags = ires->flags & IRQF_TRIGGER_MASK;\r\nret = smc_request_attrib(pdev, ndev);\r\nif (ret)\r\ngoto out_release_io;\r\n#if defined(CONFIG_SA1100_ASSABET)\r\nneponset_ncr_set(NCR_ENET_OSC_EN);\r\n#endif\r\nplatform_set_drvdata(pdev, ndev);\r\nret = smc_enable_device(pdev);\r\nif (ret)\r\ngoto out_release_attrib;\r\naddr = ioremap(res->start, SMC_IO_EXTENT);\r\nif (!addr) {\r\nret = -ENOMEM;\r\ngoto out_release_attrib;\r\n}\r\n#ifdef CONFIG_ARCH_PXA\r\n{\r\nstruct smc_local *lp = netdev_priv(ndev);\r\nlp->device = &pdev->dev;\r\nlp->physaddr = res->start;\r\n}\r\n#endif\r\nret = smc_probe(ndev, addr, irq_flags);\r\nif (ret != 0)\r\ngoto out_iounmap;\r\nsmc_request_datacs(pdev, ndev);\r\nreturn 0;\r\nout_iounmap:\r\niounmap(addr);\r\nout_release_attrib:\r\nsmc_release_attrib(pdev, ndev);\r\nout_release_io:\r\nrelease_mem_region(res->start, SMC_IO_EXTENT);\r\nout_free_netdev:\r\nfree_netdev(ndev);\r\nout:\r\npr_info("%s: not found (%d).\n", CARDNAME, ret);\r\nreturn ret;\r\n}\r\nstatic int smc_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct smc_local *lp = netdev_priv(ndev);\r\nstruct resource *res;\r\nunregister_netdev(ndev);\r\nfree_irq(ndev->irq, ndev);\r\n#ifdef CONFIG_ARCH_PXA\r\nif (ndev->dma != (unsigned char)-1)\r\npxa_free_dma(ndev->dma);\r\n#endif\r\niounmap(lp->base);\r\nsmc_release_datacs(pdev,ndev);\r\nsmc_release_attrib(pdev,ndev);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "smc91x-regs");\r\nif (!res)\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, SMC_IO_EXTENT);\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}\r\nstatic int smc_drv_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nif (ndev) {\r\nif (netif_running(ndev)) {\r\nnetif_device_detach(ndev);\r\nsmc_shutdown(ndev);\r\nsmc_phy_powerdown(ndev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int smc_drv_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nif (ndev) {\r\nstruct smc_local *lp = netdev_priv(ndev);\r\nsmc_enable_device(pdev);\r\nif (netif_running(ndev)) {\r\nsmc_reset(ndev);\r\nsmc_enable(ndev);\r\nif (lp->phy_type != 0)\r\nsmc_phy_configure(&lp->phy_configure);\r\nnetif_device_attach(ndev);\r\n}\r\n}\r\nreturn 0;\r\n}
