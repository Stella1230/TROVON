static u8 qlcnic_dcb_get_num_app(struct qlcnic_adapter *adapter, u32 val)\r\n{\r\nif (qlcnic_82xx_check(adapter))\r\nreturn QLC_82XX_DCB_GET_NUMAPP(val);\r\nelse\r\nreturn QLC_83XX_DCB_GET_NUMAPP(val);\r\n}\r\nstatic inline u8 qlcnic_dcb_pfc_hdr_valid(struct qlcnic_adapter *adapter,\r\nu32 val)\r\n{\r\nif (qlcnic_82xx_check(adapter))\r\nreturn QLC_82XX_DCB_PFC_VALID(val);\r\nelse\r\nreturn QLC_83XX_DCB_PFC_VALID(val);\r\n}\r\nstatic inline u8 qlcnic_dcb_tsa_hdr_valid(struct qlcnic_adapter *adapter,\r\nu32 val)\r\n{\r\nif (qlcnic_82xx_check(adapter))\r\nreturn QLC_82XX_DCB_TSA_VALID(val);\r\nelse\r\nreturn QLC_83XX_DCB_TSA_VALID(val);\r\n}\r\nstatic inline u8 qlcnic_dcb_get_prio_map_app(struct qlcnic_adapter *adapter,\r\nu32 val)\r\n{\r\nif (qlcnic_82xx_check(adapter))\r\nreturn QLC_82XX_DCB_GET_PRIOMAP_APP(val);\r\nelse\r\nreturn QLC_83XX_DCB_GET_PRIOMAP_APP(val);\r\n}\r\nstatic int qlcnic_dcb_prio_count(u8 up_tc_map)\r\n{\r\nint j;\r\nfor (j = 0; j < QLC_DCB_MAX_TC; j++)\r\nif (up_tc_map & QLC_DCB_GET_MAP(j))\r\nbreak;\r\nreturn j;\r\n}\r\nstatic inline void __qlcnic_init_dcbnl_ops(struct qlcnic_dcb *dcb)\r\n{\r\nif (test_bit(QLCNIC_DCB_STATE, &dcb->state))\r\ndcb->adapter->netdev->dcbnl_ops = &qlcnic_dcbnl_ops;\r\n}\r\nstatic void qlcnic_set_dcb_ops(struct qlcnic_adapter *adapter)\r\n{\r\nif (qlcnic_82xx_check(adapter))\r\nadapter->dcb->ops = &qlcnic_82xx_dcb_ops;\r\nelse if (qlcnic_83xx_check(adapter))\r\nadapter->dcb->ops = &qlcnic_83xx_dcb_ops;\r\n}\r\nint qlcnic_register_dcb(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_dcb *dcb;\r\nif (qlcnic_sriov_vf_check(adapter))\r\nreturn 0;\r\ndcb = kzalloc(sizeof(struct qlcnic_dcb), GFP_ATOMIC);\r\nif (!dcb)\r\nreturn -ENOMEM;\r\nadapter->dcb = dcb;\r\ndcb->adapter = adapter;\r\nqlcnic_set_dcb_ops(adapter);\r\ndcb->state = 0;\r\nreturn 0;\r\n}\r\nstatic void __qlcnic_dcb_free(struct qlcnic_dcb *dcb)\r\n{\r\nstruct qlcnic_adapter *adapter;\r\nif (!dcb)\r\nreturn;\r\nadapter = dcb->adapter;\r\nwhile (test_bit(QLCNIC_DCB_AEN_MODE, &dcb->state))\r\nusleep_range(10000, 11000);\r\ncancel_delayed_work_sync(&dcb->aen_work);\r\nif (dcb->wq) {\r\ndestroy_workqueue(dcb->wq);\r\ndcb->wq = NULL;\r\n}\r\nkfree(dcb->cfg);\r\ndcb->cfg = NULL;\r\nkfree(dcb->param);\r\ndcb->param = NULL;\r\nkfree(dcb);\r\nadapter->dcb = NULL;\r\n}\r\nstatic void __qlcnic_dcb_get_info(struct qlcnic_dcb *dcb)\r\n{\r\nqlcnic_dcb_get_hw_capability(dcb);\r\nqlcnic_dcb_get_cee_cfg(dcb);\r\n}\r\nstatic int __qlcnic_dcb_attach(struct qlcnic_dcb *dcb)\r\n{\r\nint err = 0;\r\nINIT_DELAYED_WORK(&dcb->aen_work, qlcnic_dcb_aen_work);\r\ndcb->wq = create_singlethread_workqueue("qlcnic-dcb");\r\nif (!dcb->wq) {\r\ndev_err(&dcb->adapter->pdev->dev,\r\n"DCB workqueue allocation failed. DCB will be disabled\n");\r\nreturn -1;\r\n}\r\ndcb->cfg = kzalloc(sizeof(struct qlcnic_dcb_cfg), GFP_ATOMIC);\r\nif (!dcb->cfg) {\r\nerr = -ENOMEM;\r\ngoto out_free_wq;\r\n}\r\ndcb->param = kzalloc(sizeof(struct qlcnic_dcb_mbx_params), GFP_ATOMIC);\r\nif (!dcb->param) {\r\nerr = -ENOMEM;\r\ngoto out_free_cfg;\r\n}\r\nreturn 0;\r\nout_free_cfg:\r\nkfree(dcb->cfg);\r\ndcb->cfg = NULL;\r\nout_free_wq:\r\ndestroy_workqueue(dcb->wq);\r\ndcb->wq = NULL;\r\nreturn err;\r\n}\r\nstatic int __qlcnic_dcb_query_hw_capability(struct qlcnic_dcb *dcb, char *buf)\r\n{\r\nstruct qlcnic_adapter *adapter = dcb->adapter;\r\nstruct qlcnic_cmd_args cmd;\r\nu32 mbx_out;\r\nint err;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DCB_QUERY_CAP);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to query DCBX capability, err %d\n", err);\r\n} else {\r\nmbx_out = cmd.rsp.arg[1];\r\nif (buf)\r\nmemcpy(buf, &mbx_out, sizeof(u32));\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic int __qlcnic_dcb_get_capability(struct qlcnic_dcb *dcb, u32 *val)\r\n{\r\nstruct qlcnic_dcb_capability *cap = &dcb->cfg->capability;\r\nu32 mbx_out;\r\nint err;\r\nmemset(cap, 0, sizeof(struct qlcnic_dcb_capability));\r\nerr = qlcnic_dcb_query_hw_capability(dcb, (char *)val);\r\nif (err)\r\nreturn err;\r\nmbx_out = *val;\r\nif (QLC_DCB_TSA_SUPPORT(mbx_out))\r\ncap->tsa_capability = true;\r\nif (QLC_DCB_ETS_SUPPORT(mbx_out))\r\ncap->ets_capability = true;\r\ncap->max_num_tc = QLC_DCB_MAX_NUM_TC(mbx_out);\r\ncap->max_ets_tc = QLC_DCB_MAX_NUM_ETS_TC(mbx_out);\r\ncap->max_pfc_tc = QLC_DCB_MAX_NUM_PFC_TC(mbx_out);\r\nif (cap->max_num_tc > QLC_DCB_MAX_TC ||\r\ncap->max_ets_tc > cap->max_num_tc ||\r\ncap->max_pfc_tc > cap->max_num_tc) {\r\ndev_err(&dcb->adapter->pdev->dev, "Invalid DCB configuration\n");\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int qlcnic_82xx_dcb_get_hw_capability(struct qlcnic_dcb *dcb)\r\n{\r\nstruct qlcnic_dcb_cfg *cfg = dcb->cfg;\r\nstruct qlcnic_dcb_capability *cap;\r\nu32 mbx_out;\r\nint err;\r\nerr = __qlcnic_dcb_get_capability(dcb, &mbx_out);\r\nif (err)\r\nreturn err;\r\ncap = &cfg->capability;\r\ncap->dcb_capability = DCB_CAP_DCBX_VER_CEE | DCB_CAP_DCBX_LLD_MANAGED;\r\nif (cap->dcb_capability && cap->tsa_capability && cap->ets_capability)\r\nset_bit(QLCNIC_DCB_STATE, &dcb->state);\r\nreturn err;\r\n}\r\nstatic int qlcnic_82xx_dcb_query_cee_param(struct qlcnic_dcb *dcb,\r\nchar *buf, u8 type)\r\n{\r\nu16 size = sizeof(struct qlcnic_82xx_dcb_param_mbx_le);\r\nstruct qlcnic_adapter *adapter = dcb->adapter;\r\nstruct qlcnic_82xx_dcb_param_mbx_le *prsp_le;\r\nstruct device *dev = &adapter->pdev->dev;\r\ndma_addr_t cardrsp_phys_addr;\r\nstruct qlcnic_dcb_param rsp;\r\nstruct qlcnic_cmd_args cmd;\r\nu64 phys_addr;\r\nvoid *addr;\r\nint err, i;\r\nswitch (type) {\r\ncase QLC_DCB_LOCAL_PARAM_FWID:\r\ncase QLC_DCB_OPER_PARAM_FWID:\r\ncase QLC_DCB_PEER_PARAM_FWID:\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid parameter type %d\n", type);\r\nreturn -EINVAL;\r\n}\r\naddr = dma_alloc_coherent(dev, size, &cardrsp_phys_addr, GFP_KERNEL);\r\nif (addr == NULL)\r\nreturn -ENOMEM;\r\nprsp_le = addr;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DCB_QUERY_PARAM);\r\nif (err)\r\ngoto out_free_rsp;\r\nphys_addr = cardrsp_phys_addr;\r\ncmd.req.arg[1] = size | (type << 16);\r\ncmd.req.arg[2] = MSD(phys_addr);\r\ncmd.req.arg[3] = LSD(phys_addr);\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err) {\r\ndev_err(dev, "Failed to query DCBX parameter, err %d\n", err);\r\ngoto out;\r\n}\r\nmemset(&rsp, 0, sizeof(struct qlcnic_dcb_param));\r\nrsp.hdr_prio_pfc_map[0] = le32_to_cpu(prsp_le->hdr_prio_pfc_map[0]);\r\nrsp.hdr_prio_pfc_map[1] = le32_to_cpu(prsp_le->hdr_prio_pfc_map[1]);\r\nrsp.prio_pg_map[0] = le32_to_cpu(prsp_le->prio_pg_map[0]);\r\nrsp.prio_pg_map[1] = le32_to_cpu(prsp_le->prio_pg_map[1]);\r\nrsp.pg_bw_map[0] = le32_to_cpu(prsp_le->pg_bw_map[0]);\r\nrsp.pg_bw_map[1] = le32_to_cpu(prsp_le->pg_bw_map[1]);\r\nrsp.pg_tsa_map[0] = le32_to_cpu(prsp_le->pg_tsa_map[0]);\r\nrsp.pg_tsa_map[1] = le32_to_cpu(prsp_le->pg_tsa_map[1]);\r\nfor (i = 0; i < QLC_DCB_MAX_APP; i++)\r\nrsp.app[i] = le32_to_cpu(prsp_le->app[i]);\r\nif (buf)\r\nmemcpy(buf, &rsp, size);\r\nout:\r\nqlcnic_free_mbx_args(&cmd);\r\nout_free_rsp:\r\ndma_free_coherent(dev, size, addr, cardrsp_phys_addr);\r\nreturn err;\r\n}\r\nstatic int qlcnic_82xx_dcb_get_cee_cfg(struct qlcnic_dcb *dcb)\r\n{\r\nstruct qlcnic_dcb_mbx_params *mbx;\r\nint err;\r\nmbx = dcb->param;\r\nif (!mbx)\r\nreturn 0;\r\nerr = qlcnic_dcb_query_cee_param(dcb, (char *)&mbx->type[0],\r\nQLC_DCB_LOCAL_PARAM_FWID);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_dcb_query_cee_param(dcb, (char *)&mbx->type[1],\r\nQLC_DCB_OPER_PARAM_FWID);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_dcb_query_cee_param(dcb, (char *)&mbx->type[2],\r\nQLC_DCB_PEER_PARAM_FWID);\r\nif (err)\r\nreturn err;\r\nmbx->prio_tc_map = QLC_82XX_DCB_PRIO_TC_MAP;\r\nqlcnic_dcb_data_cee_param_map(dcb->adapter);\r\nreturn err;\r\n}\r\nstatic void qlcnic_dcb_aen_work(struct work_struct *work)\r\n{\r\nstruct qlcnic_dcb *dcb;\r\ndcb = container_of(work, struct qlcnic_dcb, aen_work.work);\r\nqlcnic_dcb_get_cee_cfg(dcb);\r\nclear_bit(QLCNIC_DCB_AEN_MODE, &dcb->state);\r\n}\r\nstatic void qlcnic_82xx_dcb_aen_handler(struct qlcnic_dcb *dcb, void *data)\r\n{\r\nif (test_and_set_bit(QLCNIC_DCB_AEN_MODE, &dcb->state))\r\nreturn;\r\nqueue_delayed_work(dcb->wq, &dcb->aen_work, 0);\r\n}\r\nstatic int qlcnic_83xx_dcb_get_hw_capability(struct qlcnic_dcb *dcb)\r\n{\r\nstruct qlcnic_dcb_capability *cap = &dcb->cfg->capability;\r\nu32 mbx_out;\r\nint err;\r\nerr = __qlcnic_dcb_get_capability(dcb, &mbx_out);\r\nif (err)\r\nreturn err;\r\nif (mbx_out & BIT_2)\r\ncap->dcb_capability = DCB_CAP_DCBX_VER_CEE;\r\nif (mbx_out & BIT_3)\r\ncap->dcb_capability |= DCB_CAP_DCBX_VER_IEEE;\r\nif (cap->dcb_capability)\r\ncap->dcb_capability |= DCB_CAP_DCBX_LLD_MANAGED;\r\nif (cap->dcb_capability && cap->tsa_capability && cap->ets_capability)\r\nset_bit(QLCNIC_DCB_STATE, &dcb->state);\r\nreturn err;\r\n}\r\nstatic int qlcnic_83xx_dcb_query_cee_param(struct qlcnic_dcb *dcb,\r\nchar *buf, u8 idx)\r\n{\r\nstruct qlcnic_adapter *adapter = dcb->adapter;\r\nstruct qlcnic_dcb_mbx_params mbx_out;\r\nint err, i, j, k, max_app, size;\r\nstruct qlcnic_dcb_param *each;\r\nstruct qlcnic_cmd_args cmd;\r\nu32 val;\r\nchar *p;\r\nsize = 0;\r\nmemset(&mbx_out, 0, sizeof(struct qlcnic_dcb_mbx_params));\r\nmemset(buf, 0, sizeof(struct qlcnic_dcb_mbx_params));\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DCB_QUERY_PARAM);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[0] |= QLC_DCB_FW_VER << 29;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to query DCBX param, err %d\n", err);\r\ngoto out;\r\n}\r\nmbx_out.prio_tc_map = cmd.rsp.arg[1];\r\np = memcpy(buf, &mbx_out, sizeof(u32));\r\nk = 2;\r\np += sizeof(u32);\r\nfor (j = 0; j < QLC_DCB_NUM_PARAM; j++) {\r\neach = &mbx_out.type[j];\r\neach->hdr_prio_pfc_map[0] = cmd.rsp.arg[k++];\r\neach->hdr_prio_pfc_map[1] = cmd.rsp.arg[k++];\r\neach->prio_pg_map[0] = cmd.rsp.arg[k++];\r\neach->prio_pg_map[1] = cmd.rsp.arg[k++];\r\neach->pg_bw_map[0] = cmd.rsp.arg[k++];\r\neach->pg_bw_map[1] = cmd.rsp.arg[k++];\r\neach->pg_tsa_map[0] = cmd.rsp.arg[k++];\r\neach->pg_tsa_map[1] = cmd.rsp.arg[k++];\r\nval = each->hdr_prio_pfc_map[0];\r\nmax_app = qlcnic_dcb_get_num_app(adapter, val);\r\nfor (i = 0; i < max_app; i++)\r\neach->app[i] = cmd.rsp.arg[i + k];\r\nsize = 16 * sizeof(u32);\r\nmemcpy(p, &each->hdr_prio_pfc_map[0], size);\r\np += size;\r\nif (j == 0)\r\nk = 18;\r\nelse\r\nk = 34;\r\n}\r\nout:\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_83xx_dcb_get_cee_cfg(struct qlcnic_dcb *dcb)\r\n{\r\nint err;\r\nerr = qlcnic_dcb_query_cee_param(dcb, (char *)dcb->param, 0);\r\nif (err)\r\nreturn err;\r\nqlcnic_dcb_data_cee_param_map(dcb->adapter);\r\nreturn err;\r\n}\r\nstatic void qlcnic_83xx_dcb_aen_handler(struct qlcnic_dcb *dcb, void *data)\r\n{\r\nu32 *val = data;\r\nif (test_and_set_bit(QLCNIC_DCB_AEN_MODE, &dcb->state))\r\nreturn;\r\nif (*val & BIT_8)\r\nset_bit(QLCNIC_DCB_STATE, &dcb->state);\r\nelse\r\nclear_bit(QLCNIC_DCB_STATE, &dcb->state);\r\nqueue_delayed_work(dcb->wq, &dcb->aen_work, 0);\r\n}\r\nstatic void qlcnic_dcb_fill_cee_tc_params(struct qlcnic_dcb_mbx_params *mbx,\r\nstruct qlcnic_dcb_param *each,\r\nstruct qlcnic_dcb_cee *type)\r\n{\r\nstruct qlcnic_dcb_tc_cfg *tc_cfg;\r\nu8 i, tc, pgid;\r\nfor (i = 0; i < QLC_DCB_MAX_PRIO; i++) {\r\ntc = QLC_DCB_GET_TC_PRIO(mbx->prio_tc_map, i);\r\ntc_cfg = &type->tc_cfg[tc];\r\ntc_cfg->valid = true;\r\ntc_cfg->up_tc_map |= QLC_DCB_GET_MAP(i);\r\nif (QLC_DCB_GET_PFC_PRIO(each->hdr_prio_pfc_map[1], i) &&\r\ntype->pfc_mode_enable) {\r\ntc_cfg->prio_cfg[i].valid = true;\r\ntc_cfg->prio_cfg[i].pfc_type = QLC_PFC_FULL;\r\n}\r\nif (i < 4)\r\npgid = QLC_DCB_GET_PGID_PRIO(each->prio_pg_map[0], i);\r\nelse\r\npgid = QLC_DCB_GET_PGID_PRIO(each->prio_pg_map[1], i);\r\ntc_cfg->pgid = pgid;\r\ntc_cfg->prio_type = QLC_PRIO_LINK;\r\ntype->pg_cfg[tc_cfg->pgid].prio_count++;\r\n}\r\n}\r\nstatic void qlcnic_dcb_fill_cee_pg_params(struct qlcnic_dcb_param *each,\r\nstruct qlcnic_dcb_cee *type)\r\n{\r\nstruct qlcnic_dcb_pg_cfg *pg_cfg;\r\nu8 i, tsa, bw_per;\r\nfor (i = 0; i < QLC_DCB_MAX_PG; i++) {\r\npg_cfg = &type->pg_cfg[i];\r\npg_cfg->valid = true;\r\nif (i < 4) {\r\nbw_per = QLC_DCB_GET_BWPER_PG(each->pg_bw_map[0], i);\r\ntsa = QLC_DCB_GET_TSA_PG(each->pg_tsa_map[0], i);\r\n} else {\r\nbw_per = QLC_DCB_GET_BWPER_PG(each->pg_bw_map[1], i);\r\ntsa = QLC_DCB_GET_TSA_PG(each->pg_tsa_map[1], i);\r\n}\r\npg_cfg->total_bw_percent = bw_per;\r\npg_cfg->tsa_type = tsa;\r\n}\r\n}\r\nstatic void\r\nqlcnic_dcb_fill_cee_app_params(struct qlcnic_adapter *adapter, u8 idx,\r\nstruct qlcnic_dcb_param *each,\r\nstruct qlcnic_dcb_cee *type)\r\n{\r\nstruct qlcnic_dcb_app *app;\r\nu8 i, num_app, map, cnt;\r\nstruct dcb_app new_app;\r\nnum_app = qlcnic_dcb_get_num_app(adapter, each->hdr_prio_pfc_map[0]);\r\nfor (i = 0; i < num_app; i++) {\r\napp = &type->app[i];\r\napp->valid = true;\r\napp->selector = QLC_DCB_GET_SELECTOR_APP(each->app[i]) - 1;\r\nnew_app.selector = app->selector;\r\napp->protocol = QLC_DCB_GET_PROTO_ID_APP(each->app[i]);\r\nnew_app.protocol = app->protocol;\r\nmap = qlcnic_dcb_get_prio_map_app(adapter, each->app[i]);\r\ncnt = qlcnic_dcb_prio_count(map);\r\nif (cnt >= QLC_DCB_MAX_TC)\r\ncnt = 0;\r\napp->priority = cnt;\r\nnew_app.priority = cnt;\r\nif (idx == QLC_DCB_OPER_IDX && adapter->netdev->dcbnl_ops)\r\ndcb_setapp(adapter->netdev, &new_app);\r\n}\r\n}\r\nstatic void qlcnic_dcb_map_cee_params(struct qlcnic_adapter *adapter, u8 idx)\r\n{\r\nstruct qlcnic_dcb_mbx_params *mbx = adapter->dcb->param;\r\nstruct qlcnic_dcb_param *each = &mbx->type[idx];\r\nstruct qlcnic_dcb_cfg *cfg = adapter->dcb->cfg;\r\nstruct qlcnic_dcb_cee *type = &cfg->type[idx];\r\ntype->tc_param_valid = false;\r\ntype->pfc_mode_enable = false;\r\nmemset(type->tc_cfg, 0,\r\nsizeof(struct qlcnic_dcb_tc_cfg) * QLC_DCB_MAX_TC);\r\nmemset(type->pg_cfg, 0,\r\nsizeof(struct qlcnic_dcb_pg_cfg) * QLC_DCB_MAX_TC);\r\nif (qlcnic_dcb_pfc_hdr_valid(adapter, each->hdr_prio_pfc_map[0]) &&\r\ncfg->capability.max_pfc_tc)\r\ntype->pfc_mode_enable = true;\r\nif (qlcnic_dcb_tsa_hdr_valid(adapter, each->hdr_prio_pfc_map[0]) &&\r\ncfg->capability.max_ets_tc)\r\ntype->tc_param_valid = true;\r\nqlcnic_dcb_fill_cee_tc_params(mbx, each, type);\r\nqlcnic_dcb_fill_cee_pg_params(each, type);\r\nqlcnic_dcb_fill_cee_app_params(adapter, idx, each, type);\r\n}\r\nstatic void qlcnic_dcb_data_cee_param_map(struct qlcnic_adapter *adapter)\r\n{\r\nint i;\r\nfor (i = 0; i < QLC_DCB_NUM_PARAM; i++)\r\nqlcnic_dcb_map_cee_params(adapter, i);\r\ndcbnl_cee_notify(adapter->netdev, RTM_GETDCB, DCB_CMD_CEE_GET, 0, 0);\r\n}\r\nstatic u8 qlcnic_dcb_get_state(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nreturn test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state);\r\n}\r\nstatic void qlcnic_dcb_get_perm_hw_addr(struct net_device *netdev, u8 *addr)\r\n{\r\nmemcpy(addr, netdev->perm_addr, netdev->addr_len);\r\n}\r\nstatic void\r\nqlcnic_dcb_get_pg_tc_cfg_tx(struct net_device *netdev, int tc, u8 *prio,\r\nu8 *pgid, u8 *bw_per, u8 *up_tc_map)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_dcb_tc_cfg *tc_cfg, *temp;\r\nstruct qlcnic_dcb_cee *type;\r\nu8 i, cnt, pg;\r\ntype = &adapter->dcb->cfg->type[QLC_DCB_OPER_IDX];\r\n*prio = *pgid = *bw_per = *up_tc_map = 0;\r\nif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state) ||\r\n!type->tc_param_valid)\r\nreturn;\r\nif (tc < 0 || (tc >= QLC_DCB_MAX_TC))\r\nreturn;\r\ntc_cfg = &type->tc_cfg[tc];\r\nif (!tc_cfg->valid)\r\nreturn;\r\n*pgid = tc_cfg->pgid;\r\n*prio = tc_cfg->prio_type;\r\n*up_tc_map = tc_cfg->up_tc_map;\r\npg = *pgid;\r\nfor (i = 0, cnt = 0; i < QLC_DCB_MAX_TC; i++) {\r\ntemp = &type->tc_cfg[i];\r\nif (temp->valid && (pg == temp->pgid))\r\ncnt++;\r\n}\r\ntc_cfg->bwg_percent = (100 / cnt);\r\n*bw_per = tc_cfg->bwg_percent;\r\n}\r\nstatic void qlcnic_dcb_get_pg_bwg_cfg_tx(struct net_device *netdev, int pgid,\r\nu8 *bw_pct)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_dcb_pg_cfg *pgcfg;\r\nstruct qlcnic_dcb_cee *type;\r\n*bw_pct = 0;\r\ntype = &adapter->dcb->cfg->type[QLC_DCB_OPER_IDX];\r\nif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state) ||\r\n!type->tc_param_valid)\r\nreturn;\r\nif (pgid < 0 || pgid >= QLC_DCB_MAX_PG)\r\nreturn;\r\npgcfg = &type->pg_cfg[pgid];\r\nif (!pgcfg->valid)\r\nreturn;\r\n*bw_pct = pgcfg->total_bw_percent;\r\n}\r\nstatic void qlcnic_dcb_get_pfc_cfg(struct net_device *netdev, int prio,\r\nu8 *setting)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_dcb_tc_cfg *tc_cfg;\r\nu8 val = QLC_DCB_GET_MAP(prio);\r\nstruct qlcnic_dcb_cee *type;\r\nu8 i;\r\n*setting = 0;\r\ntype = &adapter->dcb->cfg->type[QLC_DCB_OPER_IDX];\r\nif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state) ||\r\n!type->pfc_mode_enable)\r\nreturn;\r\nfor (i = 0; i < QLC_DCB_MAX_TC; i++) {\r\ntc_cfg = &type->tc_cfg[i];\r\nif (!tc_cfg->valid)\r\ncontinue;\r\nif ((val & tc_cfg->up_tc_map) && (tc_cfg->prio_cfg[prio].valid))\r\n*setting = tc_cfg->prio_cfg[prio].pfc_type;\r\n}\r\n}\r\nstatic u8 qlcnic_dcb_get_capability(struct net_device *netdev, int capid,\r\nu8 *cap)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\r\nreturn 0;\r\nswitch (capid) {\r\ncase DCB_CAP_ATTR_PG:\r\ncase DCB_CAP_ATTR_UP2TC:\r\ncase DCB_CAP_ATTR_PFC:\r\ncase DCB_CAP_ATTR_GSP:\r\n*cap = true;\r\nbreak;\r\ncase DCB_CAP_ATTR_PG_TCS:\r\ncase DCB_CAP_ATTR_PFC_TCS:\r\n*cap = 0x80;\r\nbreak;\r\ncase DCB_CAP_ATTR_DCBX:\r\n*cap = adapter->dcb->cfg->capability.dcb_capability;\r\nbreak;\r\ndefault:\r\n*cap = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_dcb_get_num_tcs(struct net_device *netdev, int attr, u8 *num)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_dcb_cfg *cfg = adapter->dcb->cfg;\r\nif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\r\nreturn -EINVAL;\r\nswitch (attr) {\r\ncase DCB_NUMTCS_ATTR_PG:\r\n*num = cfg->capability.max_ets_tc;\r\nreturn 0;\r\ncase DCB_NUMTCS_ATTR_PFC:\r\n*num = cfg->capability.max_pfc_tc;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic u8 qlcnic_dcb_get_app(struct net_device *netdev, u8 idtype, u16 id)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct dcb_app app = {\r\n.selector = idtype,\r\n.protocol = id,\r\n};\r\nif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\r\nreturn 0;\r\nreturn dcb_getapp(netdev, &app);\r\n}\r\nstatic u8 qlcnic_dcb_get_pfc_state(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_dcb *dcb = adapter->dcb;\r\nif (!test_bit(QLCNIC_DCB_STATE, &dcb->state))\r\nreturn 0;\r\nreturn dcb->cfg->type[QLC_DCB_OPER_IDX].pfc_mode_enable;\r\n}\r\nstatic u8 qlcnic_dcb_get_dcbx(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_dcb_cfg *cfg = adapter->dcb->cfg;\r\nif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\r\nreturn 0;\r\nreturn cfg->capability.dcb_capability;\r\n}\r\nstatic u8 qlcnic_dcb_get_feat_cfg(struct net_device *netdev, int fid, u8 *flag)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_dcb_cee *type;\r\nif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\r\nreturn 1;\r\ntype = &adapter->dcb->cfg->type[QLC_DCB_OPER_IDX];\r\n*flag = 0;\r\nswitch (fid) {\r\ncase DCB_FEATCFG_ATTR_PG:\r\nif (type->tc_param_valid)\r\n*flag |= DCB_FEATCFG_ENABLE;\r\nelse\r\n*flag |= DCB_FEATCFG_ERROR;\r\nbreak;\r\ncase DCB_FEATCFG_ATTR_PFC:\r\nif (type->pfc_mode_enable) {\r\nif (type->tc_cfg[0].prio_cfg[0].pfc_type)\r\n*flag |= DCB_FEATCFG_ENABLE;\r\n} else {\r\n*flag |= DCB_FEATCFG_ERROR;\r\n}\r\nbreak;\r\ncase DCB_FEATCFG_ATTR_APP:\r\n*flag |= DCB_FEATCFG_ENABLE;\r\nbreak;\r\ndefault:\r\nnetdev_err(netdev, "Invalid Feature ID %d\n", fid);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\nqlcnic_dcb_get_pg_tc_cfg_rx(struct net_device *netdev, int prio, u8 *prio_type,\r\nu8 *pgid, u8 *bw_pct, u8 *up_map)\r\n{\r\n*prio_type = *pgid = *bw_pct = *up_map = 0;\r\n}\r\nstatic inline void\r\nqlcnic_dcb_get_pg_bwg_cfg_rx(struct net_device *netdev, int pgid, u8 *bw_pct)\r\n{\r\n*bw_pct = 0;\r\n}\r\nstatic int qlcnic_dcb_peer_app_info(struct net_device *netdev,\r\nstruct dcb_peer_app_info *info,\r\nu16 *app_count)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_dcb_cee *peer;\r\nint i;\r\nmemset(info, 0, sizeof(*info));\r\n*app_count = 0;\r\nif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\r\nreturn 0;\r\npeer = &adapter->dcb->cfg->type[QLC_DCB_PEER_IDX];\r\nfor (i = 0; i < QLC_DCB_MAX_APP; i++) {\r\nif (peer->app[i].valid)\r\n(*app_count)++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_dcb_peer_app_table(struct net_device *netdev,\r\nstruct dcb_app *table)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_dcb_cee *peer;\r\nstruct qlcnic_dcb_app *app;\r\nint i, j;\r\nif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\r\nreturn 0;\r\npeer = &adapter->dcb->cfg->type[QLC_DCB_PEER_IDX];\r\nfor (i = 0, j = 0; i < QLC_DCB_MAX_APP; i++) {\r\napp = &peer->app[i];\r\nif (!app->valid)\r\ncontinue;\r\ntable[j].selector = app->selector;\r\ntable[j].priority = app->priority;\r\ntable[j++].protocol = app->protocol;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_dcb_cee_peer_get_pg(struct net_device *netdev,\r\nstruct cee_pg *pg)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_dcb_cee *peer;\r\nu8 i, j, k, map;\r\nif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\r\nreturn 0;\r\npeer = &adapter->dcb->cfg->type[QLC_DCB_PEER_IDX];\r\nfor (i = 0, j = 0; i < QLC_DCB_MAX_PG; i++) {\r\nif (!peer->pg_cfg[i].valid)\r\ncontinue;\r\npg->pg_bw[j] = peer->pg_cfg[i].total_bw_percent;\r\nfor (k = 0; k < QLC_DCB_MAX_TC; k++) {\r\nif (peer->tc_cfg[i].valid &&\r\n(peer->tc_cfg[i].pgid == i)) {\r\nmap = peer->tc_cfg[i].up_tc_map;\r\npg->prio_pg[j++] = map;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_dcb_cee_peer_get_pfc(struct net_device *netdev,\r\nstruct cee_pfc *pfc)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_dcb_cfg *cfg = adapter->dcb->cfg;\r\nstruct qlcnic_dcb_tc_cfg *tc;\r\nstruct qlcnic_dcb_cee *peer;\r\nu8 i, setting, prio;\r\npfc->pfc_en = 0;\r\nif (!test_bit(QLCNIC_DCB_STATE, &adapter->dcb->state))\r\nreturn 0;\r\npeer = &cfg->type[QLC_DCB_PEER_IDX];\r\nfor (i = 0; i < QLC_DCB_MAX_TC; i++) {\r\ntc = &peer->tc_cfg[i];\r\nprio = qlcnic_dcb_prio_count(tc->up_tc_map);\r\nsetting = 0;\r\nqlcnic_dcb_get_pfc_cfg(netdev, prio, &setting);\r\nif (setting)\r\npfc->pfc_en |= QLC_DCB_GET_MAP(i);\r\n}\r\npfc->tcs_supported = cfg->capability.max_pfc_tc;\r\nreturn 0;\r\n}
