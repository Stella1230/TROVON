static inline u32 keystone_timer_readl(unsigned long rg)\r\n{\r\nreturn readl_relaxed(timer.base + rg);\r\n}\r\nstatic inline void keystone_timer_writel(u32 val, unsigned long rg)\r\n{\r\nwritel_relaxed(val, timer.base + rg);\r\n}\r\nstatic inline void keystone_timer_barrier(void)\r\n{\r\n__iowmb();\r\n}\r\nstatic int keystone_timer_config(u64 period, enum clock_event_mode mode)\r\n{\r\nu32 tcr;\r\nu32 off;\r\ntcr = keystone_timer_readl(TCR);\r\noff = tcr & ~(TCR_ENAMODE_MASK);\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\ntcr |= TCR_ENAMODE_ONESHOT_MASK;\r\nbreak;\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\ntcr |= TCR_ENAMODE_PERIODIC_MASK;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nkeystone_timer_writel(off, TCR);\r\nkeystone_timer_barrier();\r\nkeystone_timer_writel(0, TIM12);\r\nkeystone_timer_writel(0, TIM34);\r\nkeystone_timer_writel(period & 0xffffffff, PRD12);\r\nkeystone_timer_writel(period >> 32, PRD34);\r\nkeystone_timer_barrier();\r\nkeystone_timer_writel(tcr, TCR);\r\nreturn 0;\r\n}\r\nstatic void keystone_timer_disable(void)\r\n{\r\nu32 tcr;\r\ntcr = keystone_timer_readl(TCR);\r\ntcr &= ~(TCR_ENAMODE_MASK);\r\nkeystone_timer_writel(tcr, TCR);\r\n}\r\nstatic irqreturn_t keystone_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int keystone_set_next_event(unsigned long cycles,\r\nstruct clock_event_device *evt)\r\n{\r\nreturn keystone_timer_config(cycles, evt->mode);\r\n}\r\nstatic void keystone_set_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *evt)\r\n{\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nkeystone_timer_config(timer.hz_period, CLOCK_EVT_MODE_PERIODIC);\r\nbreak;\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nkeystone_timer_disable();\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void __init keystone_timer_init(struct device_node *np)\r\n{\r\nstruct clock_event_device *event_dev = &timer.event_dev;\r\nunsigned long rate;\r\nstruct clk *clk;\r\nint irq, error;\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (irq == NO_IRQ) {\r\npr_err("%s: failed to map interrupts\n", __func__);\r\nreturn;\r\n}\r\ntimer.base = of_iomap(np, 0);\r\nif (!timer.base) {\r\npr_err("%s: failed to map registers\n", __func__);\r\nreturn;\r\n}\r\nclk = of_clk_get(np, 0);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: failed to get clock\n", __func__);\r\niounmap(timer.base);\r\nreturn;\r\n}\r\nerror = clk_prepare_enable(clk);\r\nif (error) {\r\npr_err("%s: failed to enable clock\n", __func__);\r\ngoto err;\r\n}\r\nrate = clk_get_rate(clk);\r\nkeystone_timer_writel(0, TCR);\r\nkeystone_timer_barrier();\r\nkeystone_timer_writel(0, TGCR);\r\nkeystone_timer_writel(TGCR_TIM_UNRESET_MASK, TGCR);\r\nkeystone_timer_writel(0, TIM12);\r\nkeystone_timer_writel(0, TIM34);\r\ntimer.hz_period = DIV_ROUND_UP(rate, HZ);\r\nkeystone_timer_writel(INTCTLSTAT_ENINT_MASK, INTCTLSTAT);\r\nerror = request_irq(irq, keystone_timer_interrupt, IRQF_TIMER,\r\nTIMER_NAME, event_dev);\r\nif (error) {\r\npr_err("%s: failed to setup irq\n", __func__);\r\ngoto err;\r\n}\r\nevent_dev->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\r\nevent_dev->set_next_event = keystone_set_next_event;\r\nevent_dev->set_mode = keystone_set_mode;\r\nevent_dev->cpumask = cpu_all_mask;\r\nevent_dev->owner = THIS_MODULE;\r\nevent_dev->name = TIMER_NAME;\r\nevent_dev->irq = irq;\r\nclockevents_config_and_register(event_dev, rate, 1, ULONG_MAX);\r\npr_info("keystone timer clock @%lu Hz\n", rate);\r\nreturn;\r\nerr:\r\nclk_put(clk);\r\niounmap(timer.base);\r\n}
