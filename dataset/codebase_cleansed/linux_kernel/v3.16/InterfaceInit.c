static void InterfaceAdapterFree(struct bcm_interface_adapter *psIntfAdapter)\r\n{\r\nint i = 0;\r\nif (psIntfAdapter->psAdapter->LEDInfo.led_thread_running &\r\nBCM_LED_THREAD_RUNNING_ACTIVELY) {\r\npsIntfAdapter->psAdapter->DriverState = DRIVER_HALT;\r\nwake_up(&psIntfAdapter->psAdapter->LEDInfo.notify_led_event);\r\n}\r\nreset_card_proc(psIntfAdapter->psAdapter);\r\nwhile (psIntfAdapter->psAdapter->DeviceAccess) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT,\r\nDRV_ENTRY, DBG_LVL_ALL,\r\n"Device is being accessed.\n");\r\nmsleep(100);\r\n}\r\nusb_free_urb(psIntfAdapter->psInterruptUrb);\r\nfor (i = 0; i < MAXIMUM_USB_TCB; i++) {\r\nif (psIntfAdapter->asUsbTcb[i].urb != NULL) {\r\nusb_free_urb(psIntfAdapter->asUsbTcb[i].urb);\r\npsIntfAdapter->asUsbTcb[i].urb = NULL;\r\n}\r\n}\r\nfor (i = 0; i < MAXIMUM_USB_RCB; i++) {\r\nif (psIntfAdapter->asUsbRcb[i].urb != NULL) {\r\nkfree(psIntfAdapter->asUsbRcb[i].urb->transfer_buffer);\r\nusb_free_urb(psIntfAdapter->asUsbRcb[i].urb);\r\npsIntfAdapter->asUsbRcb[i].urb = NULL;\r\n}\r\n}\r\nAdapterFree(psIntfAdapter->psAdapter);\r\n}\r\nstatic void ConfigureEndPointTypesThroughEEPROM(struct bcm_mini_adapter *Adapter)\r\n{\r\nu32 ulReg;\r\nint bytes;\r\nstruct bcm_interface_adapter *interfaceAdapter;\r\nulReg = ntohl(EP2_MPS_REG);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x128, 4, TRUE);\r\nulReg = ntohl(EP2_MPS);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x12C, 4, TRUE);\r\nulReg = ntohl(EP2_CFG_REG);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x132, 4, TRUE);\r\ninterfaceAdapter =\r\n(struct bcm_interface_adapter *)(Adapter->pvInterfaceAdapter);\r\nif (interfaceAdapter->bHighSpeedDevice) {\r\nulReg = ntohl(EP2_CFG_INT);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x136, 4, TRUE);\r\n} else {\r\nulReg = ntohl(EP2_CFG_BULK);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x136, 4, TRUE);\r\n}\r\nulReg = ntohl(EP4_MPS_REG);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x13C, 4, TRUE);\r\nulReg = ntohl(EP4_MPS);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x140, 4, TRUE);\r\nbytes = rdmalt(Adapter, 0x0F0110F8, &ulReg, sizeof(u32));\r\nif (bytes < 0) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, DRV_ENTRY,\r\nDBG_LVL_ALL, "reading of Tx EP failed\n");\r\nreturn;\r\n}\r\nulReg |= 0x6;\r\nulReg = ntohl(ulReg);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x1CC, 4, TRUE);\r\nulReg = ntohl(EP4_CFG_REG);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x1C8, 4, TRUE);\r\nulReg = ntohl(ISO_MPS_REG);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x1D2, 4, TRUE);\r\nulReg = ntohl(ISO_MPS);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x1D6, 4, TRUE);\r\nReadBeceemEEPROM(Adapter, 0x1FC, &ulReg);\r\nulReg &= 0x0101FFFF;\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x1FC, 4, TRUE);\r\nReadBeceemEEPROM(Adapter, 0xA8, &ulReg);\r\nif ((ulReg&0x00FF0000)>>16 > 0x30) {\r\nulReg = (ulReg&0xFF00FFFF)|(0x30<<16);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0xA8, 4, TRUE);\r\n}\r\nReadBeceemEEPROM(Adapter, 0x148, &ulReg);\r\nif ((ulReg&0x00FF0000)>>16 > 0x30) {\r\nulReg = (ulReg&0xFF00FFFF)|(0x30<<16);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x148, 4, TRUE);\r\n}\r\nulReg = 0;\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x122, 4, TRUE);\r\nulReg = 0;\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x1C2, 4, TRUE);\r\n}\r\nstatic int usbbcm_device_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nint retval;\r\nstruct bcm_mini_adapter *psAdapter;\r\nstruct bcm_interface_adapter *psIntfAdapter;\r\nstruct net_device *ndev;\r\nndev = alloc_etherdev_mq(sizeof(struct bcm_mini_adapter),\r\nNO_OF_QUEUES + 1);\r\nif (ndev == NULL) {\r\ndev_err(&udev->dev, DRV_NAME ": no memory for device\n");\r\nreturn -ENOMEM;\r\n}\r\nSET_NETDEV_DEV(ndev, &intf->dev);\r\npsAdapter = netdev_priv(ndev);\r\npsAdapter->dev = ndev;\r\npsAdapter->msg_enable = netif_msg_init(debug, default_msg);\r\npsAdapter->stDebugState.debug_level = DBG_LVL_CURR;\r\npsAdapter->stDebugState.type = DBG_TYPE_INITEXIT;\r\npsAdapter->stDebugState.subtype[DBG_TYPE_INITEXIT] = 0xff;\r\nBCM_SHOW_DEBUG_BITMAP(psAdapter);\r\nretval = InitAdapter(psAdapter);\r\nif (retval) {\r\ndev_err(&udev->dev, DRV_NAME ": InitAdapter Failed\n");\r\nAdapterFree(psAdapter);\r\nreturn retval;\r\n}\r\npsIntfAdapter = kzalloc(sizeof(struct bcm_interface_adapter),\r\nGFP_KERNEL);\r\nif (psIntfAdapter == NULL) {\r\nAdapterFree(psAdapter);\r\nreturn -ENOMEM;\r\n}\r\npsAdapter->pvInterfaceAdapter = psIntfAdapter;\r\npsIntfAdapter->psAdapter = psAdapter;\r\npsIntfAdapter->interface = intf;\r\nusb_set_intfdata(intf, psIntfAdapter);\r\nBCM_DEBUG_PRINT(psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"psIntfAdapter 0x%p\n", psIntfAdapter);\r\nretval = InterfaceAdapterInit(psIntfAdapter);\r\nif (retval) {\r\nif (-ENOENT == retval) {\r\nBCM_DEBUG_PRINT(psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY,\r\nDBG_LVL_ALL,\r\n"File Not Found. Use app to download.\n");\r\nreturn STATUS_SUCCESS;\r\n}\r\nBCM_DEBUG_PRINT(psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY,\r\nDBG_LVL_ALL, "InterfaceAdapterInit failed.\n");\r\nusb_set_intfdata(intf, NULL);\r\nudev = interface_to_usbdev(intf);\r\nusb_put_dev(udev);\r\nInterfaceAdapterFree(psIntfAdapter);\r\nreturn retval;\r\n}\r\nif (psAdapter->chip_id > T3) {\r\nuint32_t uiNackZeroLengthInt = 4;\r\nretval =\r\nwrmalt(psAdapter, DISABLE_USB_ZERO_LEN_INT,\r\n&uiNackZeroLengthInt,\r\nsizeof(uiNackZeroLengthInt));\r\nif (retval)\r\nreturn retval;\r\n}\r\nif (USB_CONFIG_ATT_WAKEUP & udev->actconfig->desc.bmAttributes) {\r\nif (psAdapter->bDoSuspend) {\r\n#ifdef CONFIG_PM\r\npm_runtime_set_autosuspend_delay(&udev->dev, 0);\r\nintf->needs_remote_wakeup = 1;\r\nusb_enable_autosuspend(udev);\r\ndevice_init_wakeup(&intf->dev, 1);\r\nINIT_WORK(&psIntfAdapter->usbSuspendWork,\r\nputUsbSuspend);\r\nBCM_DEBUG_PRINT(psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY,\r\nDBG_LVL_ALL,\r\n"Enabling USB Auto-Suspend\n");\r\n#endif\r\n} else {\r\nintf->needs_remote_wakeup = 0;\r\nusb_disable_autosuspend(udev);\r\n}\r\n}\r\npsAdapter->stDebugState.subtype[DBG_TYPE_INITEXIT] = 0x0;\r\nreturn retval;\r\n}\r\nstatic void usbbcm_disconnect(struct usb_interface *intf)\r\n{\r\nstruct bcm_interface_adapter *psIntfAdapter = usb_get_intfdata(intf);\r\nstruct bcm_mini_adapter *psAdapter;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nif (psIntfAdapter == NULL)\r\nreturn;\r\npsAdapter = psIntfAdapter->psAdapter;\r\nnetif_device_detach(psAdapter->dev);\r\nif (psAdapter->bDoSuspend)\r\nintf->needs_remote_wakeup = 0;\r\npsAdapter->device_removed = TRUE;\r\nusb_set_intfdata(intf, NULL);\r\nInterfaceAdapterFree(psIntfAdapter);\r\nusb_put_dev(udev);\r\n}\r\nstatic int AllocUsbCb(struct bcm_interface_adapter *psIntfAdapter)\r\n{\r\nint i = 0;\r\nfor (i = 0; i < MAXIMUM_USB_TCB; i++) {\r\npsIntfAdapter->asUsbTcb[i].urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (psIntfAdapter->asUsbTcb[i].urb == NULL) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_PRINTK, 0, 0,\r\n"Can't allocate Tx urb for index %d\n",\r\ni);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor (i = 0; i < MAXIMUM_USB_RCB; i++) {\r\npsIntfAdapter->asUsbRcb[i].urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (psIntfAdapter->asUsbRcb[i].urb == NULL) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_PRINTK, 0, 0,\r\n"Can't allocate Rx urb for index %d\n",\r\ni);\r\nreturn -ENOMEM;\r\n}\r\npsIntfAdapter->asUsbRcb[i].urb->transfer_buffer =\r\nkmalloc(MAX_DATA_BUFFER_SIZE, GFP_KERNEL);\r\nif (psIntfAdapter->asUsbRcb[i].urb->transfer_buffer == NULL) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_PRINTK, 0, 0,\r\n"Can't allocate Rx buffer for index %d\n",\r\ni);\r\nreturn -ENOMEM;\r\n}\r\npsIntfAdapter->asUsbRcb[i].urb->transfer_buffer_length =\r\nMAX_DATA_BUFFER_SIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int device_run(struct bcm_interface_adapter *psIntfAdapter)\r\n{\r\nint value = 0;\r\nUINT status = STATUS_SUCCESS;\r\nstatus = InitCardAndDownloadFirmware(psIntfAdapter->psAdapter);\r\nif (status != STATUS_SUCCESS) {\r\npr_err(DRV_NAME "InitCardAndDownloadFirmware failed.\n");\r\nreturn status;\r\n}\r\nif (psIntfAdapter->psAdapter->fw_download_done) {\r\nif (StartInterruptUrb(psIntfAdapter)) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_INITEXIT, DRV_ENTRY,\r\nDBG_LVL_ALL,\r\n"Cannot send interrupt in URB\n");\r\n}\r\npsIntfAdapter->psAdapter->waiting_to_fw_download_done = false;\r\nvalue = wait_event_timeout(\r\npsIntfAdapter->psAdapter->ioctl_fw_dnld_wait_queue,\r\npsIntfAdapter->psAdapter->waiting_to_fw_download_done,\r\n5 * HZ);\r\nif (value == 0)\r\npr_err(DRV_NAME ": Timeout waiting for mailbox interrupt.\n");\r\nif (register_control_device_interface(\r\npsIntfAdapter->psAdapter) < 0) {\r\npr_err(DRV_NAME ": Register Control Device failed.\n");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int InterfaceAdapterInit(struct bcm_interface_adapter *psIntfAdapter)\r\n{\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nsize_t buffer_size;\r\nunsigned long value;\r\nint retval = 0;\r\nint usedIntOutForBulkTransfer = 0;\r\nbool bBcm16 = false;\r\nUINT uiData = 0;\r\nint bytes;\r\npsIntfAdapter->udev =\r\nusb_get_dev(interface_to_usbdev(psIntfAdapter->interface));\r\npsIntfAdapter->bHighSpeedDevice =\r\n(psIntfAdapter->udev->speed == USB_SPEED_HIGH);\r\npsIntfAdapter->psAdapter->interface_rdm = BcmRDM;\r\npsIntfAdapter->psAdapter->interface_wrm = BcmWRM;\r\nbytes = rdmalt(psIntfAdapter->psAdapter, CHIP_ID_REG,\r\n(u32 *) &(psIntfAdapter->psAdapter->chip_id),\r\nsizeof(u32));\r\nif (bytes < 0) {\r\nretval = bytes;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0,\r\n"CHIP ID Read Failed\n");\r\nreturn retval;\r\n}\r\nif (0xbece3200 == (psIntfAdapter->psAdapter->chip_id & ~(0xF0)))\r\npsIntfAdapter->psAdapter->chip_id &= ~0xF0;\r\ndev_info(&psIntfAdapter->udev->dev, "RDM Chip ID 0x%lx\n",\r\npsIntfAdapter->psAdapter->chip_id);\r\niface_desc = psIntfAdapter->interface->cur_altsetting;\r\nif (psIntfAdapter->psAdapter->chip_id == T3B) {\r\nBeceemEEPROMBulkRead(psIntfAdapter->psAdapter, &uiData, 0x0, 4);\r\nif (uiData == BECM)\r\nbBcm16 = TRUE;\r\ndev_info(&psIntfAdapter->udev->dev,\r\n"number of alternate setting %d\n",\r\npsIntfAdapter->interface->num_altsetting);\r\nif (bBcm16 == TRUE) {\r\nif (psIntfAdapter->bHighSpeedDevice)\r\nretval = usb_set_interface(psIntfAdapter->udev,\r\nDEFAULT_SETTING_0,\r\nALTERNATE_SETTING_1);\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_INITEXIT, DRV_ENTRY,\r\nDBG_LVL_ALL,\r\n"BCM16 is applicable on this dongle\n");\r\nif (retval || !psIntfAdapter->bHighSpeedDevice) {\r\nusedIntOutForBulkTransfer = EP2;\r\nendpoint = &iface_desc->endpoint[EP2].desc;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_INITEXIT, DRV_ENTRY,\r\nDBG_LVL_ALL,\r\n"Interface altsetting failed or modem is configured to Full Speed, hence will work on default setting 0\n");\r\nif ((psIntfAdapter->bHighSpeedDevice &&\r\n!usb_endpoint_is_int_out(endpoint)) ||\r\n(!psIntfAdapter->bHighSpeedDevice &&\r\n!usb_endpoint_is_bulk_out(endpoint))) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_INITEXIT,\r\nDRV_ENTRY, DBG_LVL_ALL,\r\n"Configuring the EEPROM\n");\r\nConfigureEndPointTypesThroughEEPROM(\r\npsIntfAdapter->psAdapter);\r\nretval = usb_reset_device(\r\npsIntfAdapter->udev);\r\nif (retval) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_INITEXIT,\r\nDRV_ENTRY,\r\nDBG_LVL_ALL,\r\n"reset failed. Re-enumerating the device.\n");\r\nreturn retval;\r\n}\r\n}\r\nif (!psIntfAdapter->bHighSpeedDevice &&\r\nusb_endpoint_is_bulk_out(endpoint)) {\r\nUINT _uiData = ntohl(EP2_CFG_INT);\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_INITEXIT,\r\nDRV_ENTRY, DBG_LVL_ALL,\r\n"Reverting Bulk to INT as it is in Full Speed mode.\n");\r\nBeceemEEPROMBulkWrite(\r\npsIntfAdapter->psAdapter,\r\n(PUCHAR) & _uiData,\r\n0x136, 4, TRUE);\r\n}\r\n} else {\r\nusedIntOutForBulkTransfer = EP4;\r\nendpoint = &iface_desc->endpoint[EP4].desc;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_INITEXIT, DRV_ENTRY,\r\nDBG_LVL_ALL,\r\n"Choosing AltSetting as a default setting.\n");\r\nif (!usb_endpoint_is_int_out(endpoint)) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_INITEXIT,\r\nDRV_ENTRY, DBG_LVL_ALL,\r\n"Dongle does not have BCM16 Fix.\n");\r\nConfigureEndPointTypesThroughEEPROM(\r\npsIntfAdapter->psAdapter);\r\nretval = usb_reset_device(\r\npsIntfAdapter->udev);\r\nif (retval) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_INITEXIT,\r\nDRV_ENTRY,\r\nDBG_LVL_ALL,\r\n"reset failed. Re-enumerating the device.\n");\r\nreturn retval;\r\n}\r\n}\r\n}\r\n}\r\n}\r\niface_desc = psIntfAdapter->interface->cur_altsetting;\r\nfor (value = 0; value < iface_desc->desc.bNumEndpoints; ++value) {\r\nendpoint = &iface_desc->endpoint[value].desc;\r\nif (!psIntfAdapter->sBulkIn.bulk_in_endpointAddr &&\r\nusb_endpoint_is_bulk_in(endpoint)) {\r\nbuffer_size = le16_to_cpu(endpoint->wMaxPacketSize);\r\npsIntfAdapter->sBulkIn.bulk_in_size = buffer_size;\r\npsIntfAdapter->sBulkIn.bulk_in_endpointAddr =\r\nendpoint->bEndpointAddress;\r\npsIntfAdapter->sBulkIn.bulk_in_pipe = usb_rcvbulkpipe(\r\npsIntfAdapter->udev,\r\npsIntfAdapter->sBulkIn.bulk_in_endpointAddr);\r\n}\r\nif (!psIntfAdapter->sBulkOut.bulk_out_endpointAddr &&\r\nusb_endpoint_is_bulk_out(endpoint)) {\r\npsIntfAdapter->sBulkOut.bulk_out_endpointAddr =\r\nendpoint->bEndpointAddress;\r\npsIntfAdapter->sBulkOut.bulk_out_pipe = usb_sndbulkpipe(\r\npsIntfAdapter->udev,\r\npsIntfAdapter->sBulkOut.bulk_out_endpointAddr);\r\n}\r\nif (!psIntfAdapter->sIntrIn.int_in_endpointAddr &&\r\nusb_endpoint_is_int_in(endpoint)) {\r\nbuffer_size = le16_to_cpu(endpoint->wMaxPacketSize);\r\npsIntfAdapter->sIntrIn.int_in_size = buffer_size;\r\npsIntfAdapter->sIntrIn.int_in_endpointAddr =\r\nendpoint->bEndpointAddress;\r\npsIntfAdapter->sIntrIn.int_in_interval =\r\nendpoint->bInterval;\r\npsIntfAdapter->sIntrIn.int_in_buffer =\r\nkmalloc(buffer_size, GFP_KERNEL);\r\nif (!psIntfAdapter->sIntrIn.int_in_buffer)\r\nreturn -EINVAL;\r\n}\r\nif (!psIntfAdapter->sIntrOut.int_out_endpointAddr &&\r\nusb_endpoint_is_int_out(endpoint)) {\r\nif (!psIntfAdapter->sBulkOut.bulk_out_endpointAddr &&\r\n(psIntfAdapter->psAdapter->chip_id == T3B) &&\r\n(value == usedIntOutForBulkTransfer)) {\r\nbuffer_size =\r\nle16_to_cpu(endpoint->wMaxPacketSize);\r\npsIntfAdapter->sBulkOut.bulk_out_size =\r\nbuffer_size;\r\npsIntfAdapter->sBulkOut.bulk_out_endpointAddr =\r\nendpoint->bEndpointAddress;\r\npsIntfAdapter->sBulkOut.bulk_out_pipe =\r\nusb_sndintpipe(psIntfAdapter->udev,\r\npsIntfAdapter->sBulkOut\r\n.bulk_out_endpointAddr);\r\npsIntfAdapter->sBulkOut.int_out_interval =\r\nendpoint->bInterval;\r\n} else if (value == EP6) {\r\nbuffer_size =\r\nle16_to_cpu(endpoint->wMaxPacketSize);\r\npsIntfAdapter->sIntrOut.int_out_size =\r\nbuffer_size;\r\npsIntfAdapter->sIntrOut.int_out_endpointAddr =\r\nendpoint->bEndpointAddress;\r\npsIntfAdapter->sIntrOut.int_out_interval =\r\nendpoint->bInterval;\r\npsIntfAdapter->sIntrOut.int_out_buffer =\r\nkmalloc(buffer_size, GFP_KERNEL);\r\nif (!psIntfAdapter->sIntrOut.int_out_buffer)\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nusb_set_intfdata(psIntfAdapter->interface, psIntfAdapter);\r\npsIntfAdapter->psAdapter->bcm_file_download = InterfaceFileDownload;\r\npsIntfAdapter->psAdapter->bcm_file_readback_from_chip =\r\nInterfaceFileReadbackFromChip;\r\npsIntfAdapter->psAdapter->interface_transmit = InterfaceTransmitPacket;\r\nretval = CreateInterruptUrb(psIntfAdapter);\r\nif (retval) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0,\r\n"Cannot create interrupt urb\n");\r\nreturn retval;\r\n}\r\nretval = AllocUsbCb(psIntfAdapter);\r\nif (retval)\r\nreturn retval;\r\nreturn device_run(psIntfAdapter);\r\n}\r\nstatic int InterfaceSuspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct bcm_interface_adapter *psIntfAdapter = usb_get_intfdata(intf);\r\npsIntfAdapter->bSuspended = TRUE;\r\nif (psIntfAdapter->bPreparingForBusSuspend) {\r\npsIntfAdapter->bPreparingForBusSuspend = false;\r\nif (psIntfAdapter->psAdapter->LinkStatus == LINKUP_DONE) {\r\npsIntfAdapter->psAdapter->IdleMode = TRUE;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_INITEXIT, DRV_ENTRY,\r\nDBG_LVL_ALL,\r\n"Host Entered in PMU Idle Mode.\n");\r\n} else {\r\npsIntfAdapter->psAdapter->bShutStatus = TRUE;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_INITEXIT, DRV_ENTRY,\r\nDBG_LVL_ALL,\r\n"Host Entered in PMU Shutdown Mode.\n");\r\n}\r\n}\r\npsIntfAdapter->psAdapter->bPreparingForLowPowerMode = false;\r\nwake_up(&psIntfAdapter->psAdapter->lowpower_mode_wait_queue);\r\nreturn 0;\r\n}\r\nstatic int InterfaceResume(struct usb_interface *intf)\r\n{\r\nstruct bcm_interface_adapter *psIntfAdapter = usb_get_intfdata(intf);\r\nmdelay(100);\r\npsIntfAdapter->bSuspended = false;\r\nStartInterruptUrb(psIntfAdapter);\r\nInterfaceRx(psIntfAdapter);\r\nreturn 0;\r\n}\r\nstatic __init int bcm_init(void)\r\n{\r\nint retval;\r\npr_info("%s: %s, %s\n", DRV_NAME, DRV_DESCRIPTION, DRV_VERSION);\r\npr_info("%s\n", DRV_COPYRIGHT);\r\nbcm_class = class_create(THIS_MODULE, DRV_NAME);\r\nif (IS_ERR(bcm_class)) {\r\npr_err(DRV_NAME ": could not create class\n");\r\nreturn PTR_ERR(bcm_class);\r\n}\r\nretval = usb_register(&usbbcm_driver);\r\nif (retval < 0) {\r\npr_err(DRV_NAME ": could not register usb driver\n");\r\nclass_destroy(bcm_class);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic __exit void bcm_exit(void)\r\n{\r\nusb_deregister(&usbbcm_driver);\r\nclass_destroy(bcm_class);\r\n}
