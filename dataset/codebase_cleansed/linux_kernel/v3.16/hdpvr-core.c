void hdpvr_delete(struct hdpvr_device *dev)\r\n{\r\nhdpvr_free_buffers(dev);\r\nif (dev->video_dev)\r\nvideo_device_release(dev->video_dev);\r\nusb_put_dev(dev->udev);\r\n}\r\nstatic void challenge(u8 *bytes)\r\n{\r\n__le64 *i64P;\r\nu64 tmp64;\r\nuint i, idx;\r\nfor (idx = 0; idx < 32; ++idx) {\r\nif (idx & 0x3)\r\nbytes[(idx >> 3) + 3] = bytes[(idx >> 2) & 0x3];\r\nswitch (idx & 0x3) {\r\ncase 0x3:\r\nbytes[2] += bytes[3] * 4 + bytes[4] + bytes[5];\r\nbytes[4] += bytes[(idx & 0x1) * 2] * 9 + 9;\r\nbreak;\r\ncase 0x1:\r\nbytes[0] *= 8;\r\nbytes[0] += 7*idx + 4;\r\nbytes[6] += bytes[3] * 3;\r\nbreak;\r\ncase 0x0:\r\nbytes[3 - (idx >> 3)] = bytes[idx >> 2];\r\nbytes[5] += bytes[6] * 3;\r\nfor (i = 0; i < 3; i++)\r\nbytes[3] *= bytes[3] + 1;\r\nbreak;\r\ncase 0x2:\r\nfor (i = 0; i < 3; i++)\r\nbytes[1] *= bytes[6] + 1;\r\nfor (i = 0; i < 3; i++) {\r\ni64P = (__le64 *)bytes;\r\ntmp64 = le64_to_cpup(i64P);\r\ntmp64 = tmp64 + (tmp64 << (bytes[7] & 0x0f));\r\n*i64P = cpu_to_le64(tmp64);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int device_authorization(struct hdpvr_device *dev)\r\n{\r\nint ret, retval = -ENOMEM;\r\nchar request_type = 0x38, rcv_request = 0x81;\r\nchar *response;\r\n#ifdef HDPVR_DEBUG\r\nsize_t buf_size = 46;\r\nchar *print_buf = kzalloc(5*buf_size+1, GFP_KERNEL);\r\nif (!print_buf) {\r\nv4l2_err(&dev->v4l2_dev, "Out of memory\n");\r\nreturn retval;\r\n}\r\n#endif\r\nmutex_lock(&dev->usbc_mutex);\r\nret = usb_control_msg(dev->udev,\r\nusb_rcvctrlpipe(dev->udev, 0),\r\nrcv_request, 0x80 | request_type,\r\n0x0400, 0x0003,\r\ndev->usbc_buf, 46,\r\n10000);\r\nif (ret != 46) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"unexpected answer of status request, len %d\n", ret);\r\ngoto unlock;\r\n}\r\n#ifdef HDPVR_DEBUG\r\nelse {\r\nhex_dump_to_buffer(dev->usbc_buf, 46, 16, 1, print_buf,\r\n5*buf_size+1, 0);\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"Status request returned, len %d: %s\n",\r\nret, print_buf);\r\n}\r\n#endif\r\ndev->fw_ver = dev->usbc_buf[1];\r\nv4l2_info(&dev->v4l2_dev, "firmware version 0x%x dated %s\n",\r\ndev->fw_ver, &dev->usbc_buf[2]);\r\nif (dev->fw_ver > 0x15) {\r\ndev->options.brightness = 0x80;\r\ndev->options.contrast = 0x40;\r\ndev->options.hue = 0xf;\r\ndev->options.saturation = 0x40;\r\ndev->options.sharpness = 0x80;\r\n}\r\nswitch (dev->fw_ver) {\r\ncase HDPVR_FIRMWARE_VERSION:\r\ndev->flags &= ~HDPVR_FLAG_AC3_CAP;\r\nbreak;\r\ncase HDPVR_FIRMWARE_VERSION_AC3:\r\ncase HDPVR_FIRMWARE_VERSION_0X12:\r\ncase HDPVR_FIRMWARE_VERSION_0X15:\r\ncase HDPVR_FIRMWARE_VERSION_0X1E:\r\ndev->flags |= HDPVR_FLAG_AC3_CAP;\r\nbreak;\r\ndefault:\r\nv4l2_info(&dev->v4l2_dev, "untested firmware, the driver might"\r\n" not work.\n");\r\nif (dev->fw_ver >= HDPVR_FIRMWARE_VERSION_AC3)\r\ndev->flags |= HDPVR_FLAG_AC3_CAP;\r\nelse\r\ndev->flags &= ~HDPVR_FLAG_AC3_CAP;\r\n}\r\nresponse = dev->usbc_buf+38;\r\n#ifdef HDPVR_DEBUG\r\nhex_dump_to_buffer(response, 8, 16, 1, print_buf, 5*buf_size+1, 0);\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev, "challenge: %s\n",\r\nprint_buf);\r\n#endif\r\nchallenge(response);\r\n#ifdef HDPVR_DEBUG\r\nhex_dump_to_buffer(response, 8, 16, 1, print_buf, 5*buf_size+1, 0);\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev, " response: %s\n",\r\nprint_buf);\r\n#endif\r\nmsleep(100);\r\nret = usb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\n0xd1, 0x00 | request_type,\r\n0x0000, 0x0000,\r\nresponse, 8,\r\n10000);\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"magic request returned %d\n", ret);\r\nretval = ret != 8;\r\nunlock:\r\nmutex_unlock(&dev->usbc_mutex);\r\n#ifdef HDPVR_DEBUG\r\nkfree(print_buf);\r\n#endif\r\nreturn retval;\r\n}\r\nstatic int hdpvr_device_init(struct hdpvr_device *dev)\r\n{\r\nint ret;\r\nu8 *buf;\r\nif (device_authorization(dev))\r\nreturn -EACCES;\r\nhdpvr_set_options(dev);\r\nmutex_lock(&dev->usbc_mutex);\r\nbuf = dev->usbc_buf;\r\nbuf[0] = 0x03; buf[1] = 0x03; buf[2] = 0x00; buf[3] = 0x00;\r\nret = usb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\n0x01, 0x38,\r\nCTRL_LOW_PASS_FILTER_VALUE, CTRL_DEFAULT_INDEX,\r\nbuf, 4,\r\n1000);\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"control request returned %d\n", ret);\r\nmutex_unlock(&dev->usbc_mutex);\r\nmutex_lock(&dev->usbc_mutex);\r\nbuf[0] = 0x1;\r\nret = usb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\n0xd4, 0x38, 0, 0, buf, 1,\r\n1000);\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"control request returned %d\n", ret);\r\nbuf[0] = boost_audio;\r\nret = usb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\n0xd5, 0x38, 0, 0, buf, 1,\r\n1000);\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"control request returned %d\n", ret);\r\nmutex_unlock(&dev->usbc_mutex);\r\ndev->status = STATUS_IDLE;\r\nreturn 0;\r\n}\r\nstatic int hdpvr_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct hdpvr_device *dev;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct i2c_client *client;\r\nsize_t buffer_size;\r\nint i;\r\nint retval = -ENOMEM;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\ngoto error;\r\n}\r\nINIT_LIST_HEAD(&dev->free_buff_list);\r\nINIT_LIST_HEAD(&dev->rec_buff_list);\r\nif (v4l2_device_register(&interface->dev, &dev->v4l2_dev)) {\r\ndev_err(&interface->dev, "v4l2_device_register failed\n");\r\ngoto error;\r\n}\r\nmutex_init(&dev->io_mutex);\r\nmutex_init(&dev->i2c_mutex);\r\nmutex_init(&dev->usbc_mutex);\r\ndev->usbc_buf = kmalloc(64, GFP_KERNEL);\r\nif (!dev->usbc_buf) {\r\nv4l2_err(&dev->v4l2_dev, "Out of memory\n");\r\ngoto error;\r\n}\r\ninit_waitqueue_head(&dev->wait_buffer);\r\ninit_waitqueue_head(&dev->wait_data);\r\ndev->workqueue = create_singlethread_workqueue("hdpvr_buffer");\r\nif (!dev->workqueue)\r\ngoto error;\r\ndev->options = hdpvr_default_options;\r\nif (default_video_input < HDPVR_VIDEO_INPUTS)\r\ndev->options.video_input = default_video_input;\r\nif (default_audio_input < HDPVR_AUDIO_INPUTS) {\r\ndev->options.audio_input = default_audio_input;\r\nif (default_audio_input == HDPVR_SPDIF)\r\ndev->options.audio_codec =\r\nV4L2_MPEG_AUDIO_ENCODING_AC3;\r\n}\r\ndev->udev = usb_get_dev(interface_to_usbdev(interface));\r\niface_desc = interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!dev->bulk_in_endpointAddr &&\r\nusb_endpoint_is_bulk_in(endpoint)) {\r\nbuffer_size = 8192;\r\ndev->bulk_in_size = buffer_size;\r\ndev->bulk_in_endpointAddr = endpoint->bEndpointAddress;\r\n}\r\n}\r\nif (!dev->bulk_in_endpointAddr) {\r\nv4l2_err(&dev->v4l2_dev, "Could not find bulk-in endpoint\n");\r\ngoto error;\r\n}\r\nif (hdpvr_device_init(dev)) {\r\nv4l2_err(&dev->v4l2_dev, "device init failed\n");\r\ngoto error;\r\n}\r\nmutex_lock(&dev->io_mutex);\r\nif (hdpvr_alloc_buffers(dev, NUM_BUFFERS)) {\r\nmutex_unlock(&dev->io_mutex);\r\nv4l2_err(&dev->v4l2_dev,\r\n"allocating transfer buffers failed\n");\r\ngoto error;\r\n}\r\nmutex_unlock(&dev->io_mutex);\r\n#if IS_ENABLED(CONFIG_I2C)\r\nretval = hdpvr_register_i2c_adapter(dev);\r\nif (retval < 0) {\r\nv4l2_err(&dev->v4l2_dev, "i2c adapter register failed\n");\r\ngoto error;\r\n}\r\nclient = hdpvr_register_ir_rx_i2c(dev);\r\nif (!client) {\r\nv4l2_err(&dev->v4l2_dev, "i2c IR RX device register failed\n");\r\nretval = -ENODEV;\r\ngoto reg_fail;\r\n}\r\nclient = hdpvr_register_ir_tx_i2c(dev);\r\nif (!client) {\r\nv4l2_err(&dev->v4l2_dev, "i2c IR TX device register failed\n");\r\nretval = -ENODEV;\r\ngoto reg_fail;\r\n}\r\n#endif\r\nretval = hdpvr_register_videodev(dev, &interface->dev,\r\nvideo_nr[atomic_inc_return(&dev_nr)]);\r\nif (retval < 0) {\r\nv4l2_err(&dev->v4l2_dev, "registering videodev failed\n");\r\ngoto reg_fail;\r\n}\r\nv4l2_info(&dev->v4l2_dev, "device now attached to %s\n",\r\nvideo_device_node_name(dev->video_dev));\r\nreturn 0;\r\nreg_fail:\r\n#if IS_ENABLED(CONFIG_I2C)\r\ni2c_del_adapter(&dev->i2c_adapter);\r\n#endif\r\nerror:\r\nif (dev) {\r\nif (dev->workqueue)\r\ndestroy_workqueue(dev->workqueue);\r\nhdpvr_delete(dev);\r\n}\r\nreturn retval;\r\n}\r\nstatic void hdpvr_disconnect(struct usb_interface *interface)\r\n{\r\nstruct hdpvr_device *dev = to_hdpvr_dev(usb_get_intfdata(interface));\r\nv4l2_info(&dev->v4l2_dev, "device %s disconnected\n",\r\nvideo_device_node_name(dev->video_dev));\r\nmutex_lock(&dev->io_mutex);\r\ndev->status = STATUS_DISCONNECTED;\r\nwake_up_interruptible(&dev->wait_data);\r\nwake_up_interruptible(&dev->wait_buffer);\r\nmutex_unlock(&dev->io_mutex);\r\nv4l2_device_disconnect(&dev->v4l2_dev);\r\nmsleep(100);\r\nflush_workqueue(dev->workqueue);\r\nmutex_lock(&dev->io_mutex);\r\nhdpvr_cancel_queue(dev);\r\nmutex_unlock(&dev->io_mutex);\r\n#if IS_ENABLED(CONFIG_I2C)\r\ni2c_del_adapter(&dev->i2c_adapter);\r\n#endif\r\nvideo_unregister_device(dev->video_dev);\r\natomic_dec(&dev_nr);\r\n}
