static void nfs4_init_slot_table(struct nfs4_slot_table *tbl, const char *queue)\r\n{\r\ntbl->highest_used_slotid = NFS4_NO_SLOT;\r\nspin_lock_init(&tbl->slot_tbl_lock);\r\nrpc_init_priority_wait_queue(&tbl->slot_tbl_waitq, queue);\r\ninit_completion(&tbl->complete);\r\n}\r\nstatic void nfs4_shrink_slot_table(struct nfs4_slot_table *tbl, u32 newsize)\r\n{\r\nstruct nfs4_slot **p;\r\nif (newsize >= tbl->max_slots)\r\nreturn;\r\np = &tbl->slots;\r\nwhile (newsize--)\r\np = &(*p)->next;\r\nwhile (*p) {\r\nstruct nfs4_slot *slot = *p;\r\n*p = slot->next;\r\nkfree(slot);\r\ntbl->max_slots--;\r\n}\r\n}\r\nvoid nfs4_slot_tbl_drain_complete(struct nfs4_slot_table *tbl)\r\n{\r\nif (nfs4_slot_tbl_draining(tbl))\r\ncomplete(&tbl->complete);\r\n}\r\nvoid nfs4_free_slot(struct nfs4_slot_table *tbl, struct nfs4_slot *slot)\r\n{\r\nu32 slotid = slot->slot_nr;\r\n__clear_bit(slotid, tbl->used_slots);\r\nif (slotid == tbl->highest_used_slotid) {\r\nu32 new_max = find_last_bit(tbl->used_slots, slotid);\r\nif (new_max < slotid)\r\ntbl->highest_used_slotid = new_max;\r\nelse {\r\ntbl->highest_used_slotid = NFS4_NO_SLOT;\r\nnfs4_slot_tbl_drain_complete(tbl);\r\n}\r\n}\r\ndprintk("%s: slotid %u highest_used_slotid %u\n", __func__,\r\nslotid, tbl->highest_used_slotid);\r\n}\r\nstatic struct nfs4_slot *nfs4_new_slot(struct nfs4_slot_table *tbl,\r\nu32 slotid, u32 seq_init, gfp_t gfp_mask)\r\n{\r\nstruct nfs4_slot *slot;\r\nslot = kzalloc(sizeof(*slot), gfp_mask);\r\nif (slot) {\r\nslot->table = tbl;\r\nslot->slot_nr = slotid;\r\nslot->seq_nr = seq_init;\r\n}\r\nreturn slot;\r\n}\r\nstatic struct nfs4_slot *nfs4_find_or_create_slot(struct nfs4_slot_table *tbl,\r\nu32 slotid, u32 seq_init, gfp_t gfp_mask)\r\n{\r\nstruct nfs4_slot **p, *slot;\r\np = &tbl->slots;\r\nfor (;;) {\r\nif (*p == NULL) {\r\n*p = nfs4_new_slot(tbl, tbl->max_slots,\r\nseq_init, gfp_mask);\r\nif (*p == NULL)\r\nbreak;\r\ntbl->max_slots++;\r\n}\r\nslot = *p;\r\nif (slot->slot_nr == slotid)\r\nreturn slot;\r\np = &slot->next;\r\n}\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstruct nfs4_slot *nfs4_alloc_slot(struct nfs4_slot_table *tbl)\r\n{\r\nstruct nfs4_slot *ret = ERR_PTR(-EBUSY);\r\nu32 slotid;\r\ndprintk("--> %s used_slots=%04lx highest_used=%u max_slots=%u\n",\r\n__func__, tbl->used_slots[0], tbl->highest_used_slotid,\r\ntbl->max_slotid + 1);\r\nslotid = find_first_zero_bit(tbl->used_slots, tbl->max_slotid + 1);\r\nif (slotid > tbl->max_slotid)\r\ngoto out;\r\nret = nfs4_find_or_create_slot(tbl, slotid, 1, GFP_NOWAIT);\r\nif (IS_ERR(ret))\r\ngoto out;\r\n__set_bit(slotid, tbl->used_slots);\r\nif (slotid > tbl->highest_used_slotid ||\r\ntbl->highest_used_slotid == NFS4_NO_SLOT)\r\ntbl->highest_used_slotid = slotid;\r\nret->generation = tbl->generation;\r\nout:\r\ndprintk("<-- %s used_slots=%04lx highest_used=%u slotid=%u\n",\r\n__func__, tbl->used_slots[0], tbl->highest_used_slotid,\r\n!IS_ERR(ret) ? ret->slot_nr : NFS4_NO_SLOT);\r\nreturn ret;\r\n}\r\nstatic int nfs4_grow_slot_table(struct nfs4_slot_table *tbl,\r\nu32 max_reqs, u32 ivalue)\r\n{\r\nif (max_reqs <= tbl->max_slots)\r\nreturn 0;\r\nif (!IS_ERR(nfs4_find_or_create_slot(tbl, max_reqs - 1, ivalue, GFP_NOFS)))\r\nreturn 0;\r\nreturn -ENOMEM;\r\n}\r\nstatic void nfs4_reset_slot_table(struct nfs4_slot_table *tbl,\r\nu32 server_highest_slotid,\r\nu32 ivalue)\r\n{\r\nstruct nfs4_slot **p;\r\nnfs4_shrink_slot_table(tbl, server_highest_slotid + 1);\r\np = &tbl->slots;\r\nwhile (*p) {\r\n(*p)->seq_nr = ivalue;\r\n(*p)->interrupted = 0;\r\np = &(*p)->next;\r\n}\r\ntbl->highest_used_slotid = NFS4_NO_SLOT;\r\ntbl->target_highest_slotid = server_highest_slotid;\r\ntbl->server_highest_slotid = server_highest_slotid;\r\ntbl->d_target_highest_slotid = 0;\r\ntbl->d2_target_highest_slotid = 0;\r\ntbl->max_slotid = server_highest_slotid;\r\n}\r\nstatic int nfs4_realloc_slot_table(struct nfs4_slot_table *tbl,\r\nu32 max_reqs, u32 ivalue)\r\n{\r\nint ret;\r\ndprintk("--> %s: max_reqs=%u, tbl->max_slots %u\n", __func__,\r\nmax_reqs, tbl->max_slots);\r\nif (max_reqs > NFS4_MAX_SLOT_TABLE)\r\nmax_reqs = NFS4_MAX_SLOT_TABLE;\r\nret = nfs4_grow_slot_table(tbl, max_reqs, ivalue);\r\nif (ret)\r\ngoto out;\r\nspin_lock(&tbl->slot_tbl_lock);\r\nnfs4_reset_slot_table(tbl, max_reqs - 1, ivalue);\r\nspin_unlock(&tbl->slot_tbl_lock);\r\ndprintk("%s: tbl=%p slots=%p max_slots=%u\n", __func__,\r\ntbl, tbl->slots, tbl->max_slots);\r\nout:\r\ndprintk("<-- %s: return %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void nfs4_release_slot_table(struct nfs4_slot_table *tbl)\r\n{\r\nnfs4_shrink_slot_table(tbl, 0);\r\n}\r\nvoid nfs4_shutdown_slot_table(struct nfs4_slot_table *tbl)\r\n{\r\nnfs4_release_slot_table(tbl);\r\nrpc_destroy_wait_queue(&tbl->slot_tbl_waitq);\r\n}\r\nint nfs4_setup_slot_table(struct nfs4_slot_table *tbl, unsigned int max_reqs,\r\nconst char *queue)\r\n{\r\nnfs4_init_slot_table(tbl, queue);\r\nreturn nfs4_realloc_slot_table(tbl, max_reqs, 0);\r\n}\r\nstatic bool nfs41_assign_slot(struct rpc_task *task, void *pslot)\r\n{\r\nstruct nfs4_sequence_args *args = task->tk_msg.rpc_argp;\r\nstruct nfs4_sequence_res *res = task->tk_msg.rpc_resp;\r\nstruct nfs4_slot *slot = pslot;\r\nstruct nfs4_slot_table *tbl = slot->table;\r\nif (nfs4_slot_tbl_draining(tbl) && !args->sa_privileged)\r\nreturn false;\r\nslot->generation = tbl->generation;\r\nargs->sa_slot = slot;\r\nres->sr_timestamp = jiffies;\r\nres->sr_slot = slot;\r\nres->sr_status_flags = 0;\r\nres->sr_status = 1;\r\nreturn true;\r\n}\r\nstatic bool __nfs41_wake_and_assign_slot(struct nfs4_slot_table *tbl,\r\nstruct nfs4_slot *slot)\r\n{\r\nif (rpc_wake_up_first(&tbl->slot_tbl_waitq, nfs41_assign_slot, slot))\r\nreturn true;\r\nreturn false;\r\n}\r\nbool nfs41_wake_and_assign_slot(struct nfs4_slot_table *tbl,\r\nstruct nfs4_slot *slot)\r\n{\r\nif (slot->slot_nr > tbl->max_slotid)\r\nreturn false;\r\nreturn __nfs41_wake_and_assign_slot(tbl, slot);\r\n}\r\nstatic bool nfs41_try_wake_next_slot_table_entry(struct nfs4_slot_table *tbl)\r\n{\r\nstruct nfs4_slot *slot = nfs4_alloc_slot(tbl);\r\nif (!IS_ERR(slot)) {\r\nbool ret = __nfs41_wake_and_assign_slot(tbl, slot);\r\nif (ret)\r\nreturn ret;\r\nnfs4_free_slot(tbl, slot);\r\n}\r\nreturn false;\r\n}\r\nvoid nfs41_wake_slot_table(struct nfs4_slot_table *tbl)\r\n{\r\nfor (;;) {\r\nif (!nfs41_try_wake_next_slot_table_entry(tbl))\r\nbreak;\r\n}\r\n}\r\nstatic void nfs41_set_max_slotid_locked(struct nfs4_slot_table *tbl,\r\nu32 target_highest_slotid)\r\n{\r\nu32 max_slotid;\r\nmax_slotid = min(NFS4_MAX_SLOT_TABLE - 1, target_highest_slotid);\r\nif (max_slotid > tbl->server_highest_slotid)\r\nmax_slotid = tbl->server_highest_slotid;\r\nif (max_slotid > tbl->target_highest_slotid)\r\nmax_slotid = tbl->target_highest_slotid;\r\ntbl->max_slotid = max_slotid;\r\nnfs41_wake_slot_table(tbl);\r\n}\r\nstatic void nfs41_set_target_slotid_locked(struct nfs4_slot_table *tbl,\r\nu32 target_highest_slotid)\r\n{\r\nif (tbl->target_highest_slotid == target_highest_slotid)\r\nreturn;\r\ntbl->target_highest_slotid = target_highest_slotid;\r\ntbl->generation++;\r\n}\r\nvoid nfs41_set_target_slotid(struct nfs4_slot_table *tbl,\r\nu32 target_highest_slotid)\r\n{\r\nspin_lock(&tbl->slot_tbl_lock);\r\nnfs41_set_target_slotid_locked(tbl, target_highest_slotid);\r\ntbl->d_target_highest_slotid = 0;\r\ntbl->d2_target_highest_slotid = 0;\r\nnfs41_set_max_slotid_locked(tbl, target_highest_slotid);\r\nspin_unlock(&tbl->slot_tbl_lock);\r\n}\r\nstatic void nfs41_set_server_slotid_locked(struct nfs4_slot_table *tbl,\r\nu32 highest_slotid)\r\n{\r\nif (tbl->server_highest_slotid == highest_slotid)\r\nreturn;\r\nif (tbl->highest_used_slotid > highest_slotid)\r\nreturn;\r\nnfs4_shrink_slot_table(tbl, highest_slotid + 1);\r\ntbl->server_highest_slotid = highest_slotid;\r\n}\r\nstatic s32 nfs41_derivative_target_slotid(s32 s1, s32 s2)\r\n{\r\ns1 -= s2;\r\nif (s1 == 0)\r\nreturn 0;\r\nif (s1 < 0)\r\nreturn (s1 - 1) >> 1;\r\nreturn (s1 + 1) >> 1;\r\n}\r\nstatic int nfs41_sign_s32(s32 s1)\r\n{\r\nif (s1 > 0)\r\nreturn 1;\r\nif (s1 < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic bool nfs41_same_sign_or_zero_s32(s32 s1, s32 s2)\r\n{\r\nif (!s1 || !s2)\r\nreturn true;\r\nreturn nfs41_sign_s32(s1) == nfs41_sign_s32(s2);\r\n}\r\nstatic bool nfs41_is_outlier_target_slotid(struct nfs4_slot_table *tbl,\r\nu32 new_target)\r\n{\r\ns32 d_target, d2_target;\r\nbool ret = true;\r\nd_target = nfs41_derivative_target_slotid(new_target,\r\ntbl->target_highest_slotid);\r\nd2_target = nfs41_derivative_target_slotid(d_target,\r\ntbl->d_target_highest_slotid);\r\nif (nfs41_same_sign_or_zero_s32(d_target, tbl->d_target_highest_slotid))\r\nret = false;\r\nif (nfs41_same_sign_or_zero_s32(d2_target, tbl->d2_target_highest_slotid))\r\nret = false;\r\ntbl->d_target_highest_slotid = d_target;\r\ntbl->d2_target_highest_slotid = d2_target;\r\nreturn ret;\r\n}\r\nvoid nfs41_update_target_slotid(struct nfs4_slot_table *tbl,\r\nstruct nfs4_slot *slot,\r\nstruct nfs4_sequence_res *res)\r\n{\r\nspin_lock(&tbl->slot_tbl_lock);\r\nif (!nfs41_is_outlier_target_slotid(tbl, res->sr_target_highest_slotid))\r\nnfs41_set_target_slotid_locked(tbl, res->sr_target_highest_slotid);\r\nif (tbl->generation == slot->generation)\r\nnfs41_set_server_slotid_locked(tbl, res->sr_highest_slotid);\r\nnfs41_set_max_slotid_locked(tbl, res->sr_target_highest_slotid);\r\nspin_unlock(&tbl->slot_tbl_lock);\r\n}\r\nstatic void nfs4_release_session_slot_tables(struct nfs4_session *session)\r\n{\r\nnfs4_release_slot_table(&session->fc_slot_table);\r\nnfs4_release_slot_table(&session->bc_slot_table);\r\n}\r\nint nfs4_setup_session_slot_tables(struct nfs4_session *ses)\r\n{\r\nstruct nfs4_slot_table *tbl;\r\nint status;\r\ndprintk("--> %s\n", __func__);\r\ntbl = &ses->fc_slot_table;\r\ntbl->session = ses;\r\nstatus = nfs4_realloc_slot_table(tbl, ses->fc_attrs.max_reqs, 1);\r\nif (status)\r\nreturn status;\r\ntbl = &ses->bc_slot_table;\r\ntbl->session = ses;\r\nstatus = nfs4_realloc_slot_table(tbl, ses->bc_attrs.max_reqs, 0);\r\nif (status && tbl->slots == NULL)\r\nnfs4_release_session_slot_tables(ses);\r\nreturn status;\r\n}\r\nstruct nfs4_session *nfs4_alloc_session(struct nfs_client *clp)\r\n{\r\nstruct nfs4_session *session;\r\nsession = kzalloc(sizeof(struct nfs4_session), GFP_NOFS);\r\nif (!session)\r\nreturn NULL;\r\nnfs4_init_slot_table(&session->fc_slot_table, "ForeChannel Slot table");\r\nnfs4_init_slot_table(&session->bc_slot_table, "BackChannel Slot table");\r\nsession->session_state = 1<<NFS4_SESSION_INITING;\r\nsession->clp = clp;\r\nreturn session;\r\n}\r\nstatic void nfs4_destroy_session_slot_tables(struct nfs4_session *session)\r\n{\r\nnfs4_shutdown_slot_table(&session->fc_slot_table);\r\nnfs4_shutdown_slot_table(&session->bc_slot_table);\r\n}\r\nvoid nfs4_destroy_session(struct nfs4_session *session)\r\n{\r\nstruct rpc_xprt *xprt;\r\nstruct rpc_cred *cred;\r\ncred = nfs4_get_clid_cred(session->clp);\r\nnfs4_proc_destroy_session(session, cred);\r\nif (cred)\r\nput_rpccred(cred);\r\nrcu_read_lock();\r\nxprt = rcu_dereference(session->clp->cl_rpcclient->cl_xprt);\r\nrcu_read_unlock();\r\ndprintk("%s Destroy backchannel for xprt %p\n",\r\n__func__, xprt);\r\nxprt_destroy_backchannel(xprt, NFS41_BC_MIN_CALLBACKS);\r\nnfs4_destroy_session_slot_tables(session);\r\nkfree(session);\r\n}\r\nstatic int nfs41_check_session_ready(struct nfs_client *clp)\r\n{\r\nint ret;\r\nif (clp->cl_cons_state == NFS_CS_SESSION_INITING) {\r\nret = nfs4_client_recover_expired_lease(clp);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (clp->cl_cons_state < NFS_CS_READY)\r\nreturn -EPROTONOSUPPORT;\r\nsmp_rmb();\r\nreturn 0;\r\n}\r\nint nfs4_init_session(struct nfs_client *clp)\r\n{\r\nif (!nfs4_has_session(clp))\r\nreturn 0;\r\nclear_bit(NFS4_SESSION_INITING, &clp->cl_session->session_state);\r\nreturn nfs41_check_session_ready(clp);\r\n}\r\nint nfs4_init_ds_session(struct nfs_client *clp, unsigned long lease_time)\r\n{\r\nstruct nfs4_session *session = clp->cl_session;\r\nint ret;\r\nspin_lock(&clp->cl_lock);\r\nif (test_and_clear_bit(NFS4_SESSION_INITING, &session->session_state)) {\r\nclp->cl_lease_time = lease_time;\r\nclp->cl_last_renewal = jiffies;\r\n}\r\nspin_unlock(&clp->cl_lock);\r\nret = nfs41_check_session_ready(clp);\r\nif (ret)\r\nreturn ret;\r\nif (!is_ds_client(clp))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}
