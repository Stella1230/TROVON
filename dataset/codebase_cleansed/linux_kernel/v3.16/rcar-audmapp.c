static void audmapp_write(struct audmapp_chan *auchan, u32 data, u32 reg)\r\n{\r\nstruct audmapp_device *audev = to_dev(auchan);\r\nstruct device *dev = audev->dev;\r\ndev_dbg(dev, "w %p : %08x\n", auchan->base + reg, data);\r\niowrite32(data, auchan->base + reg);\r\n}\r\nstatic u32 audmapp_read(struct audmapp_chan *auchan, u32 reg)\r\n{\r\nreturn ioread32(auchan->base + reg);\r\n}\r\nstatic void audmapp_halt(struct shdma_chan *schan)\r\n{\r\nstruct audmapp_chan *auchan = to_chan(schan);\r\nint i;\r\naudmapp_write(auchan, 0, PDMACHCR);\r\nfor (i = 0; i < 1024; i++) {\r\nif (0 == audmapp_read(auchan, PDMACHCR))\r\nreturn;\r\nudelay(1);\r\n}\r\n}\r\nstatic void audmapp_start_xfer(struct shdma_chan *schan,\r\nstruct shdma_desc *sdecs)\r\n{\r\nstruct audmapp_chan *auchan = to_chan(schan);\r\nstruct audmapp_device *audev = to_dev(auchan);\r\nstruct audmapp_slave_config *cfg = auchan->config;\r\nstruct device *dev = audev->dev;\r\nu32 chcr = cfg->chcr | PDMACHCR_DE;\r\ndev_dbg(dev, "src/dst/chcr = %pad/%pad/%x\n",\r\n&cfg->src, &cfg->dst, cfg->chcr);\r\naudmapp_write(auchan, cfg->src, PDMASAR);\r\naudmapp_write(auchan, cfg->dst, PDMADAR);\r\naudmapp_write(auchan, chcr, PDMACHCR);\r\n}\r\nstatic struct audmapp_slave_config *\r\naudmapp_find_slave(struct audmapp_chan *auchan, int slave_id)\r\n{\r\nstruct audmapp_device *audev = to_dev(auchan);\r\nstruct audmapp_pdata *pdata = audev->pdata;\r\nstruct audmapp_slave_config *cfg;\r\nint i;\r\nif (slave_id >= AUDMAPP_SLAVE_NUMBER)\r\nreturn NULL;\r\nfor (i = 0, cfg = pdata->slave; i < pdata->slave_num; i++, cfg++)\r\nif (cfg->slave_id == slave_id)\r\nreturn cfg;\r\nreturn NULL;\r\n}\r\nstatic int audmapp_set_slave(struct shdma_chan *schan, int slave_id,\r\ndma_addr_t slave_addr, bool try)\r\n{\r\nstruct audmapp_chan *auchan = to_chan(schan);\r\nstruct audmapp_slave_config *cfg =\r\naudmapp_find_slave(auchan, slave_id);\r\nif (!cfg)\r\nreturn -ENODEV;\r\nif (try)\r\nreturn 0;\r\nauchan->config = cfg;\r\nreturn 0;\r\n}\r\nstatic int audmapp_desc_setup(struct shdma_chan *schan,\r\nstruct shdma_desc *sdecs,\r\ndma_addr_t src, dma_addr_t dst, size_t *len)\r\n{\r\nstruct audmapp_chan *auchan = to_chan(schan);\r\nstruct audmapp_slave_config *cfg = auchan->config;\r\nif (!cfg)\r\nreturn -ENODEV;\r\nif (*len > (size_t)AUDMAPP_LEN_MAX)\r\n*len = (size_t)AUDMAPP_LEN_MAX;\r\nreturn 0;\r\n}\r\nstatic void audmapp_setup_xfer(struct shdma_chan *schan,\r\nint slave_id)\r\n{\r\n}\r\nstatic dma_addr_t audmapp_slave_addr(struct shdma_chan *schan)\r\n{\r\nreturn 0;\r\n}\r\nstatic bool audmapp_channel_busy(struct shdma_chan *schan)\r\n{\r\nstruct audmapp_chan *auchan = to_chan(schan);\r\nu32 chcr = audmapp_read(auchan, PDMACHCR);\r\nreturn chcr & ~PDMACHCR_DE;\r\n}\r\nstatic bool audmapp_desc_completed(struct shdma_chan *schan,\r\nstruct shdma_desc *sdesc)\r\n{\r\nreturn true;\r\n}\r\nstatic struct shdma_desc *audmapp_embedded_desc(void *buf, int i)\r\n{\r\nreturn &((struct shdma_desc *)buf)[i];\r\n}\r\nstatic int audmapp_chan_probe(struct platform_device *pdev,\r\nstruct audmapp_device *audev, int id)\r\n{\r\nstruct shdma_dev *sdev = &audev->shdma_dev;\r\nstruct audmapp_chan *auchan;\r\nstruct shdma_chan *schan;\r\nstruct device *dev = audev->dev;\r\nauchan = devm_kzalloc(dev, sizeof(*auchan), GFP_KERNEL);\r\nif (!auchan)\r\nreturn -ENOMEM;\r\nschan = &auchan->shdma_chan;\r\nschan->max_xfer_len = AUDMAPP_LEN_MAX;\r\nshdma_chan_probe(sdev, schan, id);\r\nauchan->base = audev->chan_reg + 0x20 + (0x10 * id);\r\ndev_dbg(dev, "%02d : %p / %p", id, auchan->base, audev->chan_reg);\r\nreturn 0;\r\n}\r\nstatic void audmapp_chan_remove(struct audmapp_device *audev)\r\n{\r\nstruct dma_device *dma_dev = &audev->shdma_dev.dma_dev;\r\nstruct shdma_chan *schan;\r\nint i;\r\nshdma_for_each_chan(schan, &audev->shdma_dev, i) {\r\nBUG_ON(!schan);\r\nshdma_chan_remove(schan);\r\n}\r\ndma_dev->chancnt = 0;\r\n}\r\nstatic int audmapp_probe(struct platform_device *pdev)\r\n{\r\nstruct audmapp_pdata *pdata = pdev->dev.platform_data;\r\nstruct audmapp_device *audev;\r\nstruct shdma_dev *sdev;\r\nstruct dma_device *dma_dev;\r\nstruct resource *res;\r\nint err, i;\r\nif (!pdata)\r\nreturn -ENODEV;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naudev = devm_kzalloc(&pdev->dev, sizeof(*audev), GFP_KERNEL);\r\nif (!audev)\r\nreturn -ENOMEM;\r\naudev->dev = &pdev->dev;\r\naudev->pdata = pdata;\r\naudev->chan_reg = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(audev->chan_reg))\r\nreturn PTR_ERR(audev->chan_reg);\r\nsdev = &audev->shdma_dev;\r\nsdev->ops = &audmapp_shdma_ops;\r\nsdev->desc_size = sizeof(struct shdma_desc);\r\ndma_dev = &sdev->dma_dev;\r\ndma_dev->copy_align = LOG2_DEFAULT_XFER_SIZE;\r\ndma_cap_set(DMA_SLAVE, dma_dev->cap_mask);\r\nerr = shdma_init(&pdev->dev, sdev, AUDMAPP_MAX_CHANNELS);\r\nif (err < 0)\r\nreturn err;\r\nplatform_set_drvdata(pdev, audev);\r\nfor (i = 0; i < AUDMAPP_MAX_CHANNELS; i++) {\r\nerr = audmapp_chan_probe(pdev, audev, i);\r\nif (err)\r\ngoto chan_probe_err;\r\n}\r\nerr = dma_async_device_register(dma_dev);\r\nif (err < 0)\r\ngoto chan_probe_err;\r\nreturn err;\r\nchan_probe_err:\r\naudmapp_chan_remove(audev);\r\nshdma_cleanup(sdev);\r\nreturn err;\r\n}\r\nstatic int audmapp_remove(struct platform_device *pdev)\r\n{\r\nstruct audmapp_device *audev = platform_get_drvdata(pdev);\r\nstruct dma_device *dma_dev = &audev->shdma_dev.dma_dev;\r\ndma_async_device_unregister(dma_dev);\r\naudmapp_chan_remove(audev);\r\nshdma_cleanup(&audev->shdma_dev);\r\nreturn 0;\r\n}
