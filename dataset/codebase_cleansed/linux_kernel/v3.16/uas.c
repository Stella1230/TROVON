static void uas_unlink_data_urbs(struct uas_dev_info *devinfo,\r\nstruct uas_cmd_info *cmdinfo,\r\nunsigned long *lock_flags)\r\n{\r\ncmdinfo->state |= UNLINK_DATA_URBS;\r\nspin_unlock_irqrestore(&devinfo->lock, *lock_flags);\r\nif (cmdinfo->data_in_urb)\r\nusb_unlink_urb(cmdinfo->data_in_urb);\r\nif (cmdinfo->data_out_urb)\r\nusb_unlink_urb(cmdinfo->data_out_urb);\r\nspin_lock_irqsave(&devinfo->lock, *lock_flags);\r\ncmdinfo->state &= ~UNLINK_DATA_URBS;\r\n}\r\nstatic void uas_do_work(struct work_struct *work)\r\n{\r\nstruct uas_dev_info *devinfo =\r\ncontainer_of(work, struct uas_dev_info, work);\r\nstruct uas_cmd_info *cmdinfo;\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nlist_for_each_entry(cmdinfo, &devinfo->inflight_list, list) {\r\nstruct scsi_pointer *scp = (void *)cmdinfo;\r\nstruct scsi_cmnd *cmnd = container_of(scp, struct scsi_cmnd,\r\nSCp);\r\nif (!(cmdinfo->state & IS_IN_WORK_LIST))\r\ncontinue;\r\nerr = uas_submit_urbs(cmnd, cmnd->device->hostdata, GFP_ATOMIC);\r\nif (!err)\r\ncmdinfo->state &= ~IS_IN_WORK_LIST;\r\nelse\r\nschedule_work(&devinfo->work);\r\n}\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\n}\r\nstatic void uas_mark_cmd_dead(struct uas_dev_info *devinfo,\r\nstruct uas_cmd_info *cmdinfo,\r\nint result, const char *caller)\r\n{\r\nstruct scsi_pointer *scp = (void *)cmdinfo;\r\nstruct scsi_cmnd *cmnd = container_of(scp, struct scsi_cmnd, SCp);\r\nuas_log_cmd_state(cmnd, caller);\r\nWARN_ON_ONCE(!spin_is_locked(&devinfo->lock));\r\nWARN_ON_ONCE(cmdinfo->state & COMMAND_ABORTED);\r\ncmdinfo->state |= COMMAND_ABORTED;\r\ncmdinfo->state &= ~IS_IN_WORK_LIST;\r\ncmnd->result = result << 16;\r\nlist_move_tail(&cmdinfo->list, &devinfo->dead_list);\r\n}\r\nstatic void uas_abort_inflight(struct uas_dev_info *devinfo, int result,\r\nconst char *caller)\r\n{\r\nstruct uas_cmd_info *cmdinfo;\r\nstruct uas_cmd_info *temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nlist_for_each_entry_safe(cmdinfo, temp, &devinfo->inflight_list, list)\r\nuas_mark_cmd_dead(devinfo, cmdinfo, result, caller);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\n}\r\nstatic void uas_add_work(struct uas_cmd_info *cmdinfo)\r\n{\r\nstruct scsi_pointer *scp = (void *)cmdinfo;\r\nstruct scsi_cmnd *cmnd = container_of(scp, struct scsi_cmnd, SCp);\r\nstruct uas_dev_info *devinfo = cmnd->device->hostdata;\r\nWARN_ON_ONCE(!spin_is_locked(&devinfo->lock));\r\ncmdinfo->state |= IS_IN_WORK_LIST;\r\nschedule_work(&devinfo->work);\r\n}\r\nstatic void uas_zap_dead(struct uas_dev_info *devinfo)\r\n{\r\nstruct uas_cmd_info *cmdinfo;\r\nstruct uas_cmd_info *temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nlist_for_each_entry_safe(cmdinfo, temp, &devinfo->dead_list, list) {\r\nstruct scsi_pointer *scp = (void *)cmdinfo;\r\nstruct scsi_cmnd *cmnd = container_of(scp, struct scsi_cmnd,\r\nSCp);\r\nuas_log_cmd_state(cmnd, __func__);\r\nWARN_ON_ONCE(!(cmdinfo->state & COMMAND_ABORTED));\r\ncmdinfo->state &= ~(COMMAND_INFLIGHT |\r\nDATA_IN_URB_INFLIGHT |\r\nDATA_OUT_URB_INFLIGHT);\r\nuas_try_complete(cmnd, __func__);\r\n}\r\ndevinfo->running_task = 0;\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\n}\r\nstatic void uas_sense(struct urb *urb, struct scsi_cmnd *cmnd)\r\n{\r\nstruct sense_iu *sense_iu = urb->transfer_buffer;\r\nstruct scsi_device *sdev = cmnd->device;\r\nif (urb->actual_length > 16) {\r\nunsigned len = be16_to_cpup(&sense_iu->len);\r\nif (len + 16 != urb->actual_length) {\r\nint newlen = min(len + 16, urb->actual_length) - 16;\r\nif (newlen < 0)\r\nnewlen = 0;\r\nsdev_printk(KERN_INFO, sdev, "%s: urb length %d "\r\n"disagrees with IU sense data length %d, "\r\n"using %d bytes of sense data\n", __func__,\r\nurb->actual_length, len, newlen);\r\nlen = newlen;\r\n}\r\nmemcpy(cmnd->sense_buffer, sense_iu->sense, len);\r\n}\r\ncmnd->result = sense_iu->status;\r\n}\r\nstatic void uas_sense_old(struct urb *urb, struct scsi_cmnd *cmnd)\r\n{\r\nstruct sense_iu_old *sense_iu = urb->transfer_buffer;\r\nstruct scsi_device *sdev = cmnd->device;\r\nif (urb->actual_length > 8) {\r\nunsigned len = be16_to_cpup(&sense_iu->len) - 2;\r\nif (len + 8 != urb->actual_length) {\r\nint newlen = min(len + 8, urb->actual_length) - 8;\r\nif (newlen < 0)\r\nnewlen = 0;\r\nsdev_printk(KERN_INFO, sdev, "%s: urb length %d "\r\n"disagrees with IU sense data length %d, "\r\n"using %d bytes of sense data\n", __func__,\r\nurb->actual_length, len, newlen);\r\nlen = newlen;\r\n}\r\nmemcpy(cmnd->sense_buffer, sense_iu->sense, len);\r\n}\r\ncmnd->result = sense_iu->status;\r\n}\r\nstatic void uas_log_cmd_state(struct scsi_cmnd *cmnd, const char *caller)\r\n{\r\nstruct uas_cmd_info *ci = (void *)&cmnd->SCp;\r\nscmd_printk(KERN_INFO, cmnd, "%s %p tag %d, inflight:"\r\n"%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",\r\ncaller, cmnd, cmnd->request->tag,\r\n(ci->state & SUBMIT_STATUS_URB) ? " s-st" : "",\r\n(ci->state & ALLOC_DATA_IN_URB) ? " a-in" : "",\r\n(ci->state & SUBMIT_DATA_IN_URB) ? " s-in" : "",\r\n(ci->state & ALLOC_DATA_OUT_URB) ? " a-out" : "",\r\n(ci->state & SUBMIT_DATA_OUT_URB) ? " s-out" : "",\r\n(ci->state & ALLOC_CMD_URB) ? " a-cmd" : "",\r\n(ci->state & SUBMIT_CMD_URB) ? " s-cmd" : "",\r\n(ci->state & COMMAND_INFLIGHT) ? " CMD" : "",\r\n(ci->state & DATA_IN_URB_INFLIGHT) ? " IN" : "",\r\n(ci->state & DATA_OUT_URB_INFLIGHT) ? " OUT" : "",\r\n(ci->state & COMMAND_COMPLETED) ? " done" : "",\r\n(ci->state & COMMAND_ABORTED) ? " abort" : "",\r\n(ci->state & UNLINK_DATA_URBS) ? " unlink": "",\r\n(ci->state & IS_IN_WORK_LIST) ? " work" : "");\r\n}\r\nstatic int uas_try_complete(struct scsi_cmnd *cmnd, const char *caller)\r\n{\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\r\nWARN_ON_ONCE(!spin_is_locked(&devinfo->lock));\r\nif (cmdinfo->state & (COMMAND_INFLIGHT |\r\nDATA_IN_URB_INFLIGHT |\r\nDATA_OUT_URB_INFLIGHT |\r\nUNLINK_DATA_URBS))\r\nreturn -EBUSY;\r\nWARN_ON_ONCE(cmdinfo->state & COMMAND_COMPLETED);\r\ncmdinfo->state |= COMMAND_COMPLETED;\r\nusb_free_urb(cmdinfo->data_in_urb);\r\nusb_free_urb(cmdinfo->data_out_urb);\r\nif (cmdinfo->state & COMMAND_ABORTED)\r\nscmd_printk(KERN_INFO, cmnd, "abort completed\n");\r\nlist_del(&cmdinfo->list);\r\ncmnd->scsi_done(cmnd);\r\nreturn 0;\r\n}\r\nstatic void uas_xfer_data(struct urb *urb, struct scsi_cmnd *cmnd,\r\nunsigned direction)\r\n{\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nint err;\r\ncmdinfo->state |= direction | SUBMIT_STATUS_URB;\r\nerr = uas_submit_urbs(cmnd, cmnd->device->hostdata, GFP_ATOMIC);\r\nif (err) {\r\nuas_add_work(cmdinfo);\r\n}\r\n}\r\nstatic void uas_stat_cmplt(struct urb *urb)\r\n{\r\nstruct iu *iu = urb->transfer_buffer;\r\nstruct Scsi_Host *shost = urb->context;\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nstruct scsi_cmnd *cmnd;\r\nstruct uas_cmd_info *cmdinfo;\r\nunsigned long flags;\r\nu16 tag;\r\nif (urb->status) {\r\nif (urb->status == -ENOENT) {\r\ndev_err(&urb->dev->dev, "stat urb: killed, stream %d\n",\r\nurb->stream_id);\r\n} else {\r\ndev_err(&urb->dev->dev, "stat urb: status %d\n",\r\nurb->status);\r\n}\r\nusb_free_urb(urb);\r\nreturn;\r\n}\r\nif (devinfo->resetting) {\r\nusb_free_urb(urb);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\ntag = be16_to_cpup(&iu->tag) - 1;\r\nif (tag == 0)\r\ncmnd = devinfo->cmnd;\r\nelse\r\ncmnd = scsi_host_find_tag(shost, tag - 1);\r\nif (!cmnd) {\r\nif (iu->iu_id == IU_ID_RESPONSE) {\r\nif (!devinfo->running_task)\r\ndev_warn(&urb->dev->dev,\r\n"stat urb: recv unexpected response iu\n");\r\nmemcpy(&devinfo->response, iu, sizeof(devinfo->response));\r\n}\r\nusb_free_urb(urb);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn;\r\n}\r\ncmdinfo = (void *)&cmnd->SCp;\r\nswitch (iu->iu_id) {\r\ncase IU_ID_STATUS:\r\nif (devinfo->cmnd == cmnd)\r\ndevinfo->cmnd = NULL;\r\nif (urb->actual_length < 16)\r\ndevinfo->uas_sense_old = 1;\r\nif (devinfo->uas_sense_old)\r\nuas_sense_old(urb, cmnd);\r\nelse\r\nuas_sense(urb, cmnd);\r\nif (cmnd->result != 0) {\r\nuas_unlink_data_urbs(devinfo, cmdinfo, &flags);\r\n}\r\ncmdinfo->state &= ~COMMAND_INFLIGHT;\r\nuas_try_complete(cmnd, __func__);\r\nbreak;\r\ncase IU_ID_READ_READY:\r\nif (!cmdinfo->data_in_urb ||\r\n(cmdinfo->state & DATA_IN_URB_INFLIGHT)) {\r\nscmd_printk(KERN_ERR, cmnd, "unexpected read rdy\n");\r\nbreak;\r\n}\r\nuas_xfer_data(urb, cmnd, SUBMIT_DATA_IN_URB);\r\nbreak;\r\ncase IU_ID_WRITE_READY:\r\nif (!cmdinfo->data_out_urb ||\r\n(cmdinfo->state & DATA_OUT_URB_INFLIGHT)) {\r\nscmd_printk(KERN_ERR, cmnd, "unexpected write rdy\n");\r\nbreak;\r\n}\r\nuas_xfer_data(urb, cmnd, SUBMIT_DATA_OUT_URB);\r\nbreak;\r\ndefault:\r\nscmd_printk(KERN_ERR, cmnd,\r\n"Bogus IU (%d) received on status pipe\n", iu->iu_id);\r\n}\r\nusb_free_urb(urb);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\n}\r\nstatic void uas_data_cmplt(struct urb *urb)\r\n{\r\nstruct scsi_cmnd *cmnd = urb->context;\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\r\nstruct scsi_data_buffer *sdb = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nif (cmdinfo->data_in_urb == urb) {\r\nsdb = scsi_in(cmnd);\r\ncmdinfo->state &= ~DATA_IN_URB_INFLIGHT;\r\n} else if (cmdinfo->data_out_urb == urb) {\r\nsdb = scsi_out(cmnd);\r\ncmdinfo->state &= ~DATA_OUT_URB_INFLIGHT;\r\n}\r\nif (sdb == NULL) {\r\nWARN_ON_ONCE(1);\r\n} else if (urb->status) {\r\nif (urb->status != -ECONNRESET) {\r\nuas_log_cmd_state(cmnd, __func__);\r\nscmd_printk(KERN_ERR, cmnd,\r\n"data cmplt err %d stream %d\n",\r\nurb->status, urb->stream_id);\r\n}\r\nsdb->resid = sdb->length;\r\n} else {\r\nsdb->resid = sdb->length - urb->actual_length;\r\n}\r\nuas_try_complete(cmnd, __func__);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\n}\r\nstatic void uas_cmd_cmplt(struct urb *urb)\r\n{\r\nstruct scsi_cmnd *cmnd = urb->context;\r\nif (urb->status) {\r\nuas_log_cmd_state(cmnd, __func__);\r\nscmd_printk(KERN_ERR, cmnd, "cmd cmplt err %d\n", urb->status);\r\n}\r\nusb_free_urb(urb);\r\n}\r\nstatic struct urb *uas_alloc_data_urb(struct uas_dev_info *devinfo, gfp_t gfp,\r\nunsigned int pipe, u16 stream_id,\r\nstruct scsi_cmnd *cmnd,\r\nenum dma_data_direction dir)\r\n{\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct urb *urb = usb_alloc_urb(0, gfp);\r\nstruct scsi_data_buffer *sdb = (dir == DMA_FROM_DEVICE)\r\n? scsi_in(cmnd) : scsi_out(cmnd);\r\nif (!urb)\r\ngoto out;\r\nusb_fill_bulk_urb(urb, udev, pipe, NULL, sdb->length,\r\nuas_data_cmplt, cmnd);\r\nurb->stream_id = stream_id;\r\nurb->num_sgs = udev->bus->sg_tablesize ? sdb->table.nents : 0;\r\nurb->sg = sdb->table.sgl;\r\nout:\r\nreturn urb;\r\n}\r\nstatic struct urb *uas_alloc_sense_urb(struct uas_dev_info *devinfo, gfp_t gfp,\r\nstruct Scsi_Host *shost, u16 stream_id)\r\n{\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct urb *urb = usb_alloc_urb(0, gfp);\r\nstruct sense_iu *iu;\r\nif (!urb)\r\ngoto out;\r\niu = kzalloc(sizeof(*iu), gfp);\r\nif (!iu)\r\ngoto free;\r\nusb_fill_bulk_urb(urb, udev, devinfo->status_pipe, iu, sizeof(*iu),\r\nuas_stat_cmplt, shost);\r\nurb->stream_id = stream_id;\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nout:\r\nreturn urb;\r\nfree:\r\nusb_free_urb(urb);\r\nreturn NULL;\r\n}\r\nstatic struct urb *uas_alloc_cmd_urb(struct uas_dev_info *devinfo, gfp_t gfp,\r\nstruct scsi_cmnd *cmnd)\r\n{\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct scsi_device *sdev = cmnd->device;\r\nstruct urb *urb = usb_alloc_urb(0, gfp);\r\nstruct command_iu *iu;\r\nint len;\r\nif (!urb)\r\ngoto out;\r\nlen = cmnd->cmd_len - 16;\r\nif (len < 0)\r\nlen = 0;\r\nlen = ALIGN(len, 4);\r\niu = kzalloc(sizeof(*iu) + len, gfp);\r\nif (!iu)\r\ngoto free;\r\niu->iu_id = IU_ID_COMMAND;\r\nif (blk_rq_tagged(cmnd->request))\r\niu->tag = cpu_to_be16(cmnd->request->tag + 2);\r\nelse\r\niu->tag = cpu_to_be16(1);\r\niu->prio_attr = UAS_SIMPLE_TAG;\r\niu->len = len;\r\nint_to_scsilun(sdev->lun, &iu->lun);\r\nmemcpy(iu->cdb, cmnd->cmnd, cmnd->cmd_len);\r\nusb_fill_bulk_urb(urb, udev, devinfo->cmd_pipe, iu, sizeof(*iu) + len,\r\nuas_cmd_cmplt, cmnd);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nout:\r\nreturn urb;\r\nfree:\r\nusb_free_urb(urb);\r\nreturn NULL;\r\n}\r\nstatic int uas_submit_task_urb(struct scsi_cmnd *cmnd, gfp_t gfp,\r\nu8 function, u16 stream_id)\r\n{\r\nstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct urb *urb = usb_alloc_urb(0, gfp);\r\nstruct task_mgmt_iu *iu;\r\nint err = -ENOMEM;\r\nif (!urb)\r\ngoto err;\r\niu = kzalloc(sizeof(*iu), gfp);\r\nif (!iu)\r\ngoto err;\r\niu->iu_id = IU_ID_TASK_MGMT;\r\niu->tag = cpu_to_be16(stream_id);\r\nint_to_scsilun(cmnd->device->lun, &iu->lun);\r\niu->function = function;\r\nswitch (function) {\r\ncase TMF_ABORT_TASK:\r\nif (blk_rq_tagged(cmnd->request))\r\niu->task_tag = cpu_to_be16(cmnd->request->tag + 2);\r\nelse\r\niu->task_tag = cpu_to_be16(1);\r\nbreak;\r\n}\r\nusb_fill_bulk_urb(urb, udev, devinfo->cmd_pipe, iu, sizeof(*iu),\r\nuas_cmd_cmplt, cmnd);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nusb_anchor_urb(urb, &devinfo->cmd_urbs);\r\nerr = usb_submit_urb(urb, gfp);\r\nif (err) {\r\nusb_unanchor_urb(urb);\r\nuas_log_cmd_state(cmnd, __func__);\r\nscmd_printk(KERN_ERR, cmnd, "task submission err %d\n", err);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nusb_free_urb(urb);\r\nreturn err;\r\n}\r\nstatic struct urb *uas_submit_sense_urb(struct scsi_cmnd *cmnd,\r\ngfp_t gfp, unsigned int stream)\r\n{\r\nstruct Scsi_Host *shost = cmnd->device->host;\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nstruct urb *urb;\r\nint err;\r\nurb = uas_alloc_sense_urb(devinfo, gfp, shost, stream);\r\nif (!urb)\r\nreturn NULL;\r\nusb_anchor_urb(urb, &devinfo->sense_urbs);\r\nerr = usb_submit_urb(urb, gfp);\r\nif (err) {\r\nusb_unanchor_urb(urb);\r\nuas_log_cmd_state(cmnd, __func__);\r\nshost_printk(KERN_INFO, shost,\r\n"sense urb submission error %d stream %d\n",\r\nerr, stream);\r\nusb_free_urb(urb);\r\nreturn NULL;\r\n}\r\nreturn urb;\r\n}\r\nstatic int uas_submit_urbs(struct scsi_cmnd *cmnd,\r\nstruct uas_dev_info *devinfo, gfp_t gfp)\r\n{\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nstruct urb *urb;\r\nint err;\r\nWARN_ON_ONCE(!spin_is_locked(&devinfo->lock));\r\nif (cmdinfo->state & SUBMIT_STATUS_URB) {\r\nurb = uas_submit_sense_urb(cmnd, gfp, cmdinfo->stream);\r\nif (!urb)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\ncmdinfo->state &= ~SUBMIT_STATUS_URB;\r\n}\r\nif (cmdinfo->state & ALLOC_DATA_IN_URB) {\r\ncmdinfo->data_in_urb = uas_alloc_data_urb(devinfo, gfp,\r\ndevinfo->data_in_pipe, cmdinfo->stream,\r\ncmnd, DMA_FROM_DEVICE);\r\nif (!cmdinfo->data_in_urb)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\ncmdinfo->state &= ~ALLOC_DATA_IN_URB;\r\n}\r\nif (cmdinfo->state & SUBMIT_DATA_IN_URB) {\r\nusb_anchor_urb(cmdinfo->data_in_urb, &devinfo->data_urbs);\r\nerr = usb_submit_urb(cmdinfo->data_in_urb, gfp);\r\nif (err) {\r\nusb_unanchor_urb(cmdinfo->data_in_urb);\r\nuas_log_cmd_state(cmnd, __func__);\r\nscmd_printk(KERN_INFO, cmnd,\r\n"data in urb submission error %d stream %d\n",\r\nerr, cmdinfo->data_in_urb->stream_id);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\ncmdinfo->state &= ~SUBMIT_DATA_IN_URB;\r\ncmdinfo->state |= DATA_IN_URB_INFLIGHT;\r\n}\r\nif (cmdinfo->state & ALLOC_DATA_OUT_URB) {\r\ncmdinfo->data_out_urb = uas_alloc_data_urb(devinfo, gfp,\r\ndevinfo->data_out_pipe, cmdinfo->stream,\r\ncmnd, DMA_TO_DEVICE);\r\nif (!cmdinfo->data_out_urb)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\ncmdinfo->state &= ~ALLOC_DATA_OUT_URB;\r\n}\r\nif (cmdinfo->state & SUBMIT_DATA_OUT_URB) {\r\nusb_anchor_urb(cmdinfo->data_out_urb, &devinfo->data_urbs);\r\nerr = usb_submit_urb(cmdinfo->data_out_urb, gfp);\r\nif (err) {\r\nusb_unanchor_urb(cmdinfo->data_out_urb);\r\nuas_log_cmd_state(cmnd, __func__);\r\nscmd_printk(KERN_INFO, cmnd,\r\n"data out urb submission error %d stream %d\n",\r\nerr, cmdinfo->data_out_urb->stream_id);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\ncmdinfo->state &= ~SUBMIT_DATA_OUT_URB;\r\ncmdinfo->state |= DATA_OUT_URB_INFLIGHT;\r\n}\r\nif (cmdinfo->state & ALLOC_CMD_URB) {\r\ncmdinfo->cmd_urb = uas_alloc_cmd_urb(devinfo, gfp, cmnd);\r\nif (!cmdinfo->cmd_urb)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\ncmdinfo->state &= ~ALLOC_CMD_URB;\r\n}\r\nif (cmdinfo->state & SUBMIT_CMD_URB) {\r\nusb_anchor_urb(cmdinfo->cmd_urb, &devinfo->cmd_urbs);\r\nerr = usb_submit_urb(cmdinfo->cmd_urb, gfp);\r\nif (err) {\r\nusb_unanchor_urb(cmdinfo->cmd_urb);\r\nuas_log_cmd_state(cmnd, __func__);\r\nscmd_printk(KERN_INFO, cmnd,\r\n"cmd urb submission error %d\n", err);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\ncmdinfo->cmd_urb = NULL;\r\ncmdinfo->state &= ~SUBMIT_CMD_URB;\r\ncmdinfo->state |= COMMAND_INFLIGHT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uas_queuecommand_lck(struct scsi_cmnd *cmnd,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nstruct scsi_device *sdev = cmnd->device;\r\nstruct uas_dev_info *devinfo = sdev->hostdata;\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nunsigned long flags;\r\nint err;\r\nBUILD_BUG_ON(sizeof(struct uas_cmd_info) > sizeof(struct scsi_pointer));\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nif (devinfo->resetting) {\r\ncmnd->result = DID_ERROR << 16;\r\ncmnd->scsi_done(cmnd);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn 0;\r\n}\r\nif (devinfo->cmnd) {\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\nmemset(cmdinfo, 0, sizeof(*cmdinfo));\r\nif (blk_rq_tagged(cmnd->request)) {\r\ncmdinfo->stream = cmnd->request->tag + 2;\r\n} else {\r\ndevinfo->cmnd = cmnd;\r\ncmdinfo->stream = 1;\r\n}\r\ncmnd->scsi_done = done;\r\ncmdinfo->state = SUBMIT_STATUS_URB |\r\nALLOC_CMD_URB | SUBMIT_CMD_URB;\r\nswitch (cmnd->sc_data_direction) {\r\ncase DMA_FROM_DEVICE:\r\ncmdinfo->state |= ALLOC_DATA_IN_URB | SUBMIT_DATA_IN_URB;\r\nbreak;\r\ncase DMA_BIDIRECTIONAL:\r\ncmdinfo->state |= ALLOC_DATA_IN_URB | SUBMIT_DATA_IN_URB;\r\ncase DMA_TO_DEVICE:\r\ncmdinfo->state |= ALLOC_DATA_OUT_URB | SUBMIT_DATA_OUT_URB;\r\ncase DMA_NONE:\r\nbreak;\r\n}\r\nif (!devinfo->use_streams) {\r\ncmdinfo->state &= ~(SUBMIT_DATA_IN_URB | SUBMIT_DATA_OUT_URB);\r\ncmdinfo->stream = 0;\r\n}\r\nerr = uas_submit_urbs(cmnd, devinfo, GFP_ATOMIC);\r\nif (err) {\r\nif (cmdinfo->state & SUBMIT_STATUS_URB) {\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\nuas_add_work(cmdinfo);\r\n}\r\nlist_add_tail(&cmdinfo->list, &devinfo->inflight_list);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn 0;\r\n}\r\nint uas_eh_abort_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nif (devinfo->resetting) {\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn FAILED;\r\n}\r\nuas_mark_cmd_dead(devinfo, cmdinfo, DID_ABORT, __func__);\r\nif (cmdinfo->state & COMMAND_INFLIGHT) {\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nret = uas_eh_task_mgmt(cmnd, "ABORT TASK", TMF_ABORT_TASK);\r\n} else {\r\nuas_unlink_data_urbs(devinfo, cmdinfo, &flags);\r\nuas_try_complete(cmnd, __func__);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nret = SUCCESS;\r\n}\r\nreturn ret;\r\n}\r\nstatic int uas_eh_device_reset_handler(struct scsi_cmnd *cmnd)\r\n{\r\nsdev_printk(KERN_INFO, cmnd->device, "%s\n", __func__);\r\nreturn uas_eh_task_mgmt(cmnd, "LOGICAL UNIT RESET",\r\nTMF_LOGICAL_UNIT_RESET);\r\n}\r\nstatic int uas_eh_bus_reset_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct scsi_device *sdev = cmnd->device;\r\nstruct uas_dev_info *devinfo = sdev->hostdata;\r\nstruct usb_device *udev = devinfo->udev;\r\nint err;\r\nerr = usb_lock_device_for_reset(udev, devinfo->intf);\r\nif (err) {\r\nshost_printk(KERN_ERR, sdev->host,\r\n"%s FAILED to get lock err %d\n", __func__, err);\r\nreturn FAILED;\r\n}\r\nshost_printk(KERN_INFO, sdev->host, "%s start\n", __func__);\r\ndevinfo->resetting = 1;\r\nuas_abort_inflight(devinfo, DID_RESET, __func__);\r\nusb_kill_anchored_urbs(&devinfo->cmd_urbs);\r\nusb_kill_anchored_urbs(&devinfo->sense_urbs);\r\nusb_kill_anchored_urbs(&devinfo->data_urbs);\r\nuas_zap_dead(devinfo);\r\nerr = usb_reset_device(udev);\r\ndevinfo->resetting = 0;\r\nusb_unlock_device(udev);\r\nif (err) {\r\nshost_printk(KERN_INFO, sdev->host, "%s FAILED\n", __func__);\r\nreturn FAILED;\r\n}\r\nshost_printk(KERN_INFO, sdev->host, "%s success\n", __func__);\r\nreturn SUCCESS;\r\n}\r\nstatic int uas_slave_alloc(struct scsi_device *sdev)\r\n{\r\nsdev->hostdata = (void *)sdev->host->hostdata;\r\nblk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));\r\nreturn 0;\r\n}\r\nstatic int uas_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct uas_dev_info *devinfo = sdev->hostdata;\r\nscsi_set_tag_type(sdev, MSG_ORDERED_TAG);\r\nscsi_activate_tcq(sdev, devinfo->qdepth - 2);\r\nreturn 0;\r\n}\r\nstatic int uas_switch_interface(struct usb_device *udev,\r\nstruct usb_interface *intf)\r\n{\r\nint alt;\r\nalt = uas_find_uas_alt_setting(intf);\r\nif (alt < 0)\r\nreturn alt;\r\nreturn usb_set_interface(udev,\r\nintf->altsetting[0].desc.bInterfaceNumber, alt);\r\n}\r\nstatic int uas_configure_endpoints(struct uas_dev_info *devinfo)\r\n{\r\nstruct usb_host_endpoint *eps[4] = { };\r\nstruct usb_device *udev = devinfo->udev;\r\nint r;\r\ndevinfo->uas_sense_old = 0;\r\ndevinfo->cmnd = NULL;\r\nr = uas_find_endpoints(devinfo->intf->cur_altsetting, eps);\r\nif (r)\r\nreturn r;\r\ndevinfo->cmd_pipe = usb_sndbulkpipe(udev,\r\nusb_endpoint_num(&eps[0]->desc));\r\ndevinfo->status_pipe = usb_rcvbulkpipe(udev,\r\nusb_endpoint_num(&eps[1]->desc));\r\ndevinfo->data_in_pipe = usb_rcvbulkpipe(udev,\r\nusb_endpoint_num(&eps[2]->desc));\r\ndevinfo->data_out_pipe = usb_sndbulkpipe(udev,\r\nusb_endpoint_num(&eps[3]->desc));\r\nif (udev->speed != USB_SPEED_SUPER) {\r\ndevinfo->qdepth = 256;\r\ndevinfo->use_streams = 0;\r\n} else {\r\ndevinfo->qdepth = usb_alloc_streams(devinfo->intf, eps + 1,\r\n3, 256, GFP_NOIO);\r\nif (devinfo->qdepth < 0)\r\nreturn devinfo->qdepth;\r\ndevinfo->use_streams = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void uas_free_streams(struct uas_dev_info *devinfo)\r\n{\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct usb_host_endpoint *eps[3];\r\neps[0] = usb_pipe_endpoint(udev, devinfo->status_pipe);\r\neps[1] = usb_pipe_endpoint(udev, devinfo->data_in_pipe);\r\neps[2] = usb_pipe_endpoint(udev, devinfo->data_out_pipe);\r\nusb_free_streams(devinfo->intf, eps, 3, GFP_NOIO);\r\n}\r\nstatic int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nint result = -ENOMEM;\r\nstruct Scsi_Host *shost = NULL;\r\nstruct uas_dev_info *devinfo;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nif (!uas_use_uas_driver(intf, id))\r\nreturn -ENODEV;\r\nif (uas_switch_interface(udev, intf))\r\nreturn -ENODEV;\r\nshost = scsi_host_alloc(&uas_host_template,\r\nsizeof(struct uas_dev_info));\r\nif (!shost)\r\ngoto set_alt0;\r\nshost->max_cmd_len = 16 + 252;\r\nshost->max_id = 1;\r\nshost->max_lun = 256;\r\nshost->max_channel = 0;\r\nshost->sg_tablesize = udev->bus->sg_tablesize;\r\ndevinfo = (struct uas_dev_info *)shost->hostdata;\r\ndevinfo->intf = intf;\r\ndevinfo->udev = udev;\r\ndevinfo->resetting = 0;\r\ndevinfo->running_task = 0;\r\ndevinfo->shutdown = 0;\r\ninit_usb_anchor(&devinfo->cmd_urbs);\r\ninit_usb_anchor(&devinfo->sense_urbs);\r\ninit_usb_anchor(&devinfo->data_urbs);\r\nspin_lock_init(&devinfo->lock);\r\nINIT_WORK(&devinfo->work, uas_do_work);\r\nINIT_LIST_HEAD(&devinfo->inflight_list);\r\nINIT_LIST_HEAD(&devinfo->dead_list);\r\nresult = uas_configure_endpoints(devinfo);\r\nif (result)\r\ngoto set_alt0;\r\nresult = scsi_init_shared_tag_map(shost, devinfo->qdepth - 2);\r\nif (result)\r\ngoto free_streams;\r\nusb_set_intfdata(intf, shost);\r\nresult = scsi_add_host(shost, &intf->dev);\r\nif (result)\r\ngoto free_streams;\r\nscsi_scan_host(shost);\r\nreturn result;\r\nfree_streams:\r\nuas_free_streams(devinfo);\r\nusb_set_intfdata(intf, NULL);\r\nset_alt0:\r\nusb_set_interface(udev, intf->altsetting[0].desc.bInterfaceNumber, 0);\r\nif (shost)\r\nscsi_host_put(shost);\r\nreturn result;\r\n}\r\nstatic int uas_pre_reset(struct usb_interface *intf)\r\n{\r\nstruct Scsi_Host *shost = usb_get_intfdata(intf);\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nunsigned long flags;\r\nif (devinfo->shutdown)\r\nreturn 0;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nscsi_block_requests(shost);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nflush_work(&devinfo->work);\r\nif (usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000) == 0) {\r\nshost_printk(KERN_ERR, shost, "%s: timed out\n", __func__);\r\nreturn 1;\r\n}\r\nuas_free_streams(devinfo);\r\nreturn 0;\r\n}\r\nstatic int uas_post_reset(struct usb_interface *intf)\r\n{\r\nstruct Scsi_Host *shost = usb_get_intfdata(intf);\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nunsigned long flags;\r\nif (devinfo->shutdown)\r\nreturn 0;\r\nif (uas_configure_endpoints(devinfo) != 0) {\r\nshost_printk(KERN_ERR, shost,\r\n"%s: alloc streams error after reset", __func__);\r\nreturn 1;\r\n}\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nscsi_report_bus_reset(shost, 0);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nscsi_unblock_requests(shost);\r\nreturn 0;\r\n}\r\nstatic int uas_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct Scsi_Host *shost = usb_get_intfdata(intf);\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nflush_work(&devinfo->work);\r\nif (usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000) == 0) {\r\nshost_printk(KERN_ERR, shost, "%s: timed out\n", __func__);\r\nreturn -ETIME;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uas_resume(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic int uas_reset_resume(struct usb_interface *intf)\r\n{\r\nstruct Scsi_Host *shost = usb_get_intfdata(intf);\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nunsigned long flags;\r\nif (uas_configure_endpoints(devinfo) != 0) {\r\nshost_printk(KERN_ERR, shost,\r\n"%s: alloc streams error after reset", __func__);\r\nreturn -EIO;\r\n}\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nscsi_report_bus_reset(shost, 0);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void uas_disconnect(struct usb_interface *intf)\r\n{\r\nstruct Scsi_Host *shost = usb_get_intfdata(intf);\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\ndevinfo->resetting = 1;\r\ncancel_work_sync(&devinfo->work);\r\nuas_abort_inflight(devinfo, DID_NO_CONNECT, __func__);\r\nusb_kill_anchored_urbs(&devinfo->cmd_urbs);\r\nusb_kill_anchored_urbs(&devinfo->sense_urbs);\r\nusb_kill_anchored_urbs(&devinfo->data_urbs);\r\nuas_zap_dead(devinfo);\r\nscsi_remove_host(shost);\r\nuas_free_streams(devinfo);\r\nscsi_host_put(shost);\r\n}\r\nstatic void uas_shutdown(struct device *dev)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct Scsi_Host *shost = usb_get_intfdata(intf);\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nif (system_state != SYSTEM_RESTART)\r\nreturn;\r\ndevinfo->shutdown = 1;\r\nuas_free_streams(devinfo);\r\nusb_set_interface(udev, intf->altsetting[0].desc.bInterfaceNumber, 0);\r\nusb_reset_device(udev);\r\n}
