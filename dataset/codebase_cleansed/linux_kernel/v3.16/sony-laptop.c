static void do_sony_laptop_release_key(unsigned long unused)\r\n{\r\nstruct sony_laptop_keypress kp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sony_laptop_input.fifo_lock, flags);\r\nif (kfifo_out(&sony_laptop_input.fifo,\r\n(unsigned char *)&kp, sizeof(kp)) == sizeof(kp)) {\r\ninput_report_key(kp.dev, kp.key, 0);\r\ninput_sync(kp.dev);\r\n}\r\nif (kfifo_len(&sony_laptop_input.fifo) != 0)\r\nmod_timer(&sony_laptop_input.release_key_timer,\r\njiffies + msecs_to_jiffies(10));\r\nspin_unlock_irqrestore(&sony_laptop_input.fifo_lock, flags);\r\n}\r\nstatic void sony_laptop_report_input_event(u8 event)\r\n{\r\nstruct input_dev *jog_dev = sony_laptop_input.jog_dev;\r\nstruct input_dev *key_dev = sony_laptop_input.key_dev;\r\nstruct sony_laptop_keypress kp = { NULL };\r\nint scancode = -1;\r\nif (event == SONYPI_EVENT_FNKEY_RELEASED ||\r\nevent == SONYPI_EVENT_ANYBUTTON_RELEASED) {\r\nreturn;\r\n}\r\nswitch (event) {\r\ncase SONYPI_EVENT_JOGDIAL_UP:\r\ncase SONYPI_EVENT_JOGDIAL_UP_PRESSED:\r\ninput_report_rel(jog_dev, REL_WHEEL, 1);\r\ninput_sync(jog_dev);\r\nreturn;\r\ncase SONYPI_EVENT_JOGDIAL_DOWN:\r\ncase SONYPI_EVENT_JOGDIAL_DOWN_PRESSED:\r\ninput_report_rel(jog_dev, REL_WHEEL, -1);\r\ninput_sync(jog_dev);\r\nreturn;\r\ncase SONYPI_EVENT_JOGDIAL_PRESSED:\r\nkp.key = BTN_MIDDLE;\r\nkp.dev = jog_dev;\r\nbreak;\r\ndefault:\r\nif (event >= ARRAY_SIZE(sony_laptop_input_index)) {\r\ndprintk("sony_laptop_report_input_event, event not known: %d\n", event);\r\nbreak;\r\n}\r\nif ((scancode = sony_laptop_input_index[event]) != -1) {\r\nkp.key = sony_laptop_input_keycode_map[scancode];\r\nif (kp.key != KEY_UNKNOWN)\r\nkp.dev = key_dev;\r\n}\r\nbreak;\r\n}\r\nif (kp.dev) {\r\nif (scancode != -1)\r\ninput_event(kp.dev, EV_MSC, MSC_SCAN, scancode);\r\ninput_report_key(kp.dev, kp.key, 1);\r\ninput_sync(kp.dev);\r\nkfifo_in_locked(&sony_laptop_input.fifo,\r\n(unsigned char *)&kp, sizeof(kp),\r\n&sony_laptop_input.fifo_lock);\r\nmod_timer(&sony_laptop_input.release_key_timer,\r\njiffies + msecs_to_jiffies(10));\r\n} else\r\ndprintk("unknown input event %.2x\n", event);\r\n}\r\nstatic int sony_laptop_setup_input(struct acpi_device *acpi_device)\r\n{\r\nstruct input_dev *jog_dev;\r\nstruct input_dev *key_dev;\r\nint i;\r\nint error;\r\nif (atomic_add_return(1, &sony_laptop_input.users) > 1)\r\nreturn 0;\r\nspin_lock_init(&sony_laptop_input.fifo_lock);\r\nerror = kfifo_alloc(&sony_laptop_input.fifo,\r\nSONY_LAPTOP_BUF_SIZE, GFP_KERNEL);\r\nif (error) {\r\npr_err("kfifo_alloc failed\n");\r\ngoto err_dec_users;\r\n}\r\nsetup_timer(&sony_laptop_input.release_key_timer,\r\ndo_sony_laptop_release_key, 0);\r\nkey_dev = input_allocate_device();\r\nif (!key_dev) {\r\nerror = -ENOMEM;\r\ngoto err_free_kfifo;\r\n}\r\nkey_dev->name = "Sony Vaio Keys";\r\nkey_dev->id.bustype = BUS_ISA;\r\nkey_dev->id.vendor = PCI_VENDOR_ID_SONY;\r\nkey_dev->dev.parent = &acpi_device->dev;\r\ninput_set_capability(key_dev, EV_MSC, MSC_SCAN);\r\n__set_bit(EV_KEY, key_dev->evbit);\r\nkey_dev->keycodesize = sizeof(sony_laptop_input_keycode_map[0]);\r\nkey_dev->keycodemax = ARRAY_SIZE(sony_laptop_input_keycode_map);\r\nkey_dev->keycode = &sony_laptop_input_keycode_map;\r\nfor (i = 0; i < ARRAY_SIZE(sony_laptop_input_keycode_map); i++)\r\n__set_bit(sony_laptop_input_keycode_map[i], key_dev->keybit);\r\n__clear_bit(KEY_RESERVED, key_dev->keybit);\r\nerror = input_register_device(key_dev);\r\nif (error)\r\ngoto err_free_keydev;\r\nsony_laptop_input.key_dev = key_dev;\r\njog_dev = input_allocate_device();\r\nif (!jog_dev) {\r\nerror = -ENOMEM;\r\ngoto err_unregister_keydev;\r\n}\r\njog_dev->name = "Sony Vaio Jogdial";\r\njog_dev->id.bustype = BUS_ISA;\r\njog_dev->id.vendor = PCI_VENDOR_ID_SONY;\r\njog_dev->dev.parent = &acpi_device->dev;\r\ninput_set_capability(jog_dev, EV_KEY, BTN_MIDDLE);\r\ninput_set_capability(jog_dev, EV_REL, REL_WHEEL);\r\nerror = input_register_device(jog_dev);\r\nif (error)\r\ngoto err_free_jogdev;\r\nsony_laptop_input.jog_dev = jog_dev;\r\nreturn 0;\r\nerr_free_jogdev:\r\ninput_free_device(jog_dev);\r\nerr_unregister_keydev:\r\ninput_unregister_device(key_dev);\r\nkey_dev = NULL;\r\nerr_free_keydev:\r\ninput_free_device(key_dev);\r\nerr_free_kfifo:\r\nkfifo_free(&sony_laptop_input.fifo);\r\nerr_dec_users:\r\natomic_dec(&sony_laptop_input.users);\r\nreturn error;\r\n}\r\nstatic void sony_laptop_remove_input(void)\r\n{\r\nstruct sony_laptop_keypress kp = { NULL };\r\nif (!atomic_dec_and_test(&sony_laptop_input.users))\r\nreturn;\r\ndel_timer_sync(&sony_laptop_input.release_key_timer);\r\nwhile (kfifo_out(&sony_laptop_input.fifo,\r\n(unsigned char *)&kp, sizeof(kp)) == sizeof(kp)) {\r\ninput_report_key(kp.dev, kp.key, 0);\r\ninput_sync(kp.dev);\r\n}\r\ninput_unregister_device(sony_laptop_input.key_dev);\r\nsony_laptop_input.key_dev = NULL;\r\nif (sony_laptop_input.jog_dev) {\r\ninput_unregister_device(sony_laptop_input.jog_dev);\r\nsony_laptop_input.jog_dev = NULL;\r\n}\r\nkfifo_free(&sony_laptop_input.fifo);\r\n}\r\nstatic int sony_pf_add(void)\r\n{\r\nint ret = 0;\r\nif (atomic_add_return(1, &sony_pf_users) > 1)\r\nreturn 0;\r\nret = platform_driver_register(&sony_pf_driver);\r\nif (ret)\r\ngoto out;\r\nsony_pf_device = platform_device_alloc("sony-laptop", -1);\r\nif (!sony_pf_device) {\r\nret = -ENOMEM;\r\ngoto out_platform_registered;\r\n}\r\nret = platform_device_add(sony_pf_device);\r\nif (ret)\r\ngoto out_platform_alloced;\r\nreturn 0;\r\nout_platform_alloced:\r\nplatform_device_put(sony_pf_device);\r\nsony_pf_device = NULL;\r\nout_platform_registered:\r\nplatform_driver_unregister(&sony_pf_driver);\r\nout:\r\natomic_dec(&sony_pf_users);\r\nreturn ret;\r\n}\r\nstatic void sony_pf_remove(void)\r\n{\r\nif (!atomic_dec_and_test(&sony_pf_users))\r\nreturn;\r\nplatform_device_unregister(sony_pf_device);\r\nplatform_driver_unregister(&sony_pf_driver);\r\n}\r\nstatic union acpi_object *__call_snc_method(acpi_handle handle, char *method,\r\nu64 *value)\r\n{\r\nunion acpi_object *result = NULL;\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nacpi_status status;\r\nif (value) {\r\nstruct acpi_object_list params;\r\nunion acpi_object in;\r\nin.type = ACPI_TYPE_INTEGER;\r\nin.integer.value = *value;\r\nparams.count = 1;\r\nparams.pointer = &in;\r\nstatus = acpi_evaluate_object(handle, method, &params, &output);\r\ndprintk("__call_snc_method: [%s:0x%.8x%.8x]\n", method,\r\n(unsigned int)(*value >> 32),\r\n(unsigned int)*value & 0xffffffff);\r\n} else {\r\nstatus = acpi_evaluate_object(handle, method, NULL, &output);\r\ndprintk("__call_snc_method: [%s]\n", method);\r\n}\r\nif (ACPI_FAILURE(status)) {\r\npr_err("Failed to evaluate [%s]\n", method);\r\nreturn NULL;\r\n}\r\nresult = (union acpi_object *) output.pointer;\r\nif (!result)\r\ndprintk("No return object [%s]\n", method);\r\nreturn result;\r\n}\r\nstatic int sony_nc_int_call(acpi_handle handle, char *name, int *value,\r\nint *result)\r\n{\r\nunion acpi_object *object = NULL;\r\nif (value) {\r\nu64 v = *value;\r\nobject = __call_snc_method(handle, name, &v);\r\n} else\r\nobject = __call_snc_method(handle, name, NULL);\r\nif (!object)\r\nreturn -EINVAL;\r\nif (object->type != ACPI_TYPE_INTEGER) {\r\npr_warn("Invalid acpi_object: expected 0x%x got 0x%x\n",\r\nACPI_TYPE_INTEGER, object->type);\r\nkfree(object);\r\nreturn -EINVAL;\r\n}\r\nif (result)\r\n*result = object->integer.value;\r\nkfree(object);\r\nreturn 0;\r\n}\r\nstatic int sony_nc_buffer_call(acpi_handle handle, char *name, u64 *value,\r\nvoid *buffer, size_t buflen)\r\n{\r\nint ret = 0;\r\nsize_t len;\r\nunion acpi_object *object = __call_snc_method(handle, name, value);\r\nif (!object)\r\nreturn -EINVAL;\r\nif (object->type == ACPI_TYPE_BUFFER) {\r\nlen = MIN(buflen, object->buffer.length);\r\nmemcpy(buffer, object->buffer.pointer, len);\r\n} else if (object->type == ACPI_TYPE_INTEGER) {\r\nlen = MIN(buflen, sizeof(object->integer.value));\r\nmemcpy(buffer, &object->integer.value, len);\r\n} else {\r\npr_warn("Invalid acpi_object: expected 0x%x got 0x%x\n",\r\nACPI_TYPE_BUFFER, object->type);\r\nret = -EINVAL;\r\n}\r\nkfree(object);\r\nreturn ret;\r\n}\r\nstatic ssize_t sony_nc_handles_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nssize_t len = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(handles->cap); i++) {\r\nlen += snprintf(buffer + len, PAGE_SIZE - len, "0x%.4x ",\r\nhandles->cap[i]);\r\n}\r\nlen += snprintf(buffer + len, PAGE_SIZE - len, "\n");\r\nreturn len;\r\n}\r\nstatic int sony_nc_handles_setup(struct platform_device *pd)\r\n{\r\nint i, r, result, arg;\r\nhandles = kzalloc(sizeof(*handles), GFP_KERNEL);\r\nif (!handles)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(handles->cap); i++) {\r\narg = i + 0x20;\r\nr = sony_nc_int_call(sony_nc_acpi_handle, "SN00", &arg,\r\n&result);\r\nif (!r) {\r\ndprintk("caching handle 0x%.4x (offset: 0x%.2x)\n",\r\nresult, i);\r\nhandles->cap[i] = result;\r\n}\r\n}\r\nif (debug) {\r\nsysfs_attr_init(&handles->devattr.attr);\r\nhandles->devattr.attr.name = "handles";\r\nhandles->devattr.attr.mode = S_IRUGO;\r\nhandles->devattr.show = sony_nc_handles_show;\r\nif (device_create_file(&pd->dev, &handles->devattr)) {\r\nkfree(handles);\r\nhandles = NULL;\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sony_nc_handles_cleanup(struct platform_device *pd)\r\n{\r\nif (handles) {\r\nif (debug)\r\ndevice_remove_file(&pd->dev, &handles->devattr);\r\nkfree(handles);\r\nhandles = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sony_find_snc_handle(int handle)\r\n{\r\nint i;\r\nif (!handles || !handle)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 0x10; i++) {\r\nif (handles->cap[i] == handle) {\r\ndprintk("found handle 0x%.4x (offset: 0x%.2x)\n",\r\nhandle, i);\r\nreturn i;\r\n}\r\n}\r\ndprintk("handle 0x%.4x not found\n", handle);\r\nreturn -EINVAL;\r\n}\r\nstatic int sony_call_snc_handle(int handle, int argument, int *result)\r\n{\r\nint arg, ret = 0;\r\nint offset = sony_find_snc_handle(handle);\r\nif (offset < 0)\r\nreturn offset;\r\narg = offset | argument;\r\nret = sony_nc_int_call(sony_nc_acpi_handle, "SN07", &arg, result);\r\ndprintk("called SN07 with 0x%.4x (result: 0x%.4x)\n", arg, *result);\r\nreturn ret;\r\n}\r\nstatic int brightness_default_validate(const int direction, const int value)\r\n{\r\nswitch (direction) {\r\ncase SNC_VALIDATE_OUT:\r\nreturn value - 1;\r\ncase SNC_VALIDATE_IN:\r\nif (value >= 0 && value < SONY_MAX_BRIGHTNESS)\r\nreturn value + 1;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int boolean_validate(const int direction, const int value)\r\n{\r\nif (direction == SNC_VALIDATE_IN) {\r\nif (value != 0 && value != 1)\r\nreturn -EINVAL;\r\n}\r\nreturn value;\r\n}\r\nstatic ssize_t sony_nc_sysfs_show(struct device *dev, struct device_attribute *attr,\r\nchar *buffer)\r\n{\r\nint value, ret = 0;\r\nstruct sony_nc_value *item =\r\ncontainer_of(attr, struct sony_nc_value, devattr);\r\nif (!*item->acpiget)\r\nreturn -EIO;\r\nret = sony_nc_int_call(sony_nc_acpi_handle, *item->acpiget, NULL,\r\n&value);\r\nif (ret < 0)\r\nreturn -EIO;\r\nif (item->validate)\r\nvalue = item->validate(SNC_VALIDATE_OUT, value);\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n", value);\r\n}\r\nstatic ssize_t sony_nc_sysfs_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nint value;\r\nint ret = 0;\r\nstruct sony_nc_value *item =\r\ncontainer_of(attr, struct sony_nc_value, devattr);\r\nif (!item->acpiset)\r\nreturn -EIO;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoint(buffer, 10, &value))\r\nreturn -EINVAL;\r\nif (item->validate)\r\nvalue = item->validate(SNC_VALIDATE_IN, value);\r\nif (value < 0)\r\nreturn value;\r\nret = sony_nc_int_call(sony_nc_acpi_handle, *item->acpiset,\r\n&value, NULL);\r\nif (ret < 0)\r\nreturn -EIO;\r\nitem->value = value;\r\nitem->valid = 1;\r\nreturn count;\r\n}\r\nstatic int sony_backlight_update_status(struct backlight_device *bd)\r\n{\r\nint arg = bd->props.brightness + 1;\r\nreturn sony_nc_int_call(sony_nc_acpi_handle, "SBRT", &arg, NULL);\r\n}\r\nstatic int sony_backlight_get_brightness(struct backlight_device *bd)\r\n{\r\nint value;\r\nif (sony_nc_int_call(sony_nc_acpi_handle, "GBRT", NULL, &value))\r\nreturn 0;\r\nreturn value - 1;\r\n}\r\nstatic int sony_nc_get_brightness_ng(struct backlight_device *bd)\r\n{\r\nint result;\r\nstruct sony_backlight_props *sdev =\r\n(struct sony_backlight_props *)bl_get_data(bd);\r\nsony_call_snc_handle(sdev->handle, sdev->cmd_base + 0x100, &result);\r\nreturn (result & 0xff) - sdev->offset;\r\n}\r\nstatic int sony_nc_update_status_ng(struct backlight_device *bd)\r\n{\r\nint value, result;\r\nstruct sony_backlight_props *sdev =\r\n(struct sony_backlight_props *)bl_get_data(bd);\r\nvalue = bd->props.brightness + sdev->offset;\r\nif (sony_call_snc_handle(sdev->handle, sdev->cmd_base | (value << 0x10),\r\n&result))\r\nreturn -EIO;\r\nreturn value;\r\n}\r\nstatic int sony_nc_hotkeys_decode(u32 event, unsigned int handle)\r\n{\r\nint ret = -EINVAL;\r\nunsigned int result = 0;\r\nstruct sony_nc_event *key_event;\r\nif (sony_call_snc_handle(handle, 0x200, &result)) {\r\ndprintk("Unable to decode event 0x%.2x 0x%.2x\n", handle,\r\nevent);\r\nreturn -EINVAL;\r\n}\r\nresult &= 0xFF;\r\nif (handle == 0x0100)\r\nkey_event = sony_100_events;\r\nelse\r\nkey_event = sony_127_events;\r\nfor (; key_event->data; key_event++) {\r\nif (key_event->data == result) {\r\nret = key_event->event;\r\nbreak;\r\n}\r\n}\r\nif (!key_event->data)\r\npr_info("Unknown hotkey 0x%.2x/0x%.2x (handle 0x%.2x)\n",\r\nevent, result, handle);\r\nreturn ret;\r\n}\r\nstatic void sony_nc_notify(struct acpi_device *device, u32 event)\r\n{\r\nu32 real_ev = event;\r\nu8 ev_type = 0;\r\ndprintk("sony_nc_notify, event: 0x%.2x\n", event);\r\nif (event >= 0x90) {\r\nunsigned int result = 0;\r\nunsigned int arg = 0;\r\nunsigned int handle = 0;\r\nunsigned int offset = event - 0x90;\r\nif (offset >= ARRAY_SIZE(handles->cap)) {\r\npr_err("Event 0x%x outside of capabilities list\n",\r\nevent);\r\nreturn;\r\n}\r\nhandle = handles->cap[offset];\r\nswitch (handle) {\r\ncase 0x0100:\r\ncase 0x0127:\r\nev_type = HOTKEY;\r\nreal_ev = sony_nc_hotkeys_decode(event, handle);\r\nif (real_ev > 0)\r\nsony_laptop_report_input_event(real_ev);\r\nelse\r\nreal_ev = event;\r\nbreak;\r\ncase 0x0124:\r\ncase 0x0135:\r\nev_type = KILLSWITCH;\r\nsony_call_snc_handle(handle, 0x0100, &result);\r\nreal_ev = result & 0x03;\r\nif (real_ev == 1)\r\nsony_nc_rfkill_update();\r\nbreak;\r\ncase 0x0128:\r\ncase 0x0146:\r\nsony_call_snc_handle(handle, 0x0000, &result);\r\ndprintk("GFX switch event received (reason: %s)\n",\r\n(result == 0x1) ? "switch change" :\r\n(result == 0x2) ? "output switch" :\r\n(result == 0x3) ? "output switch" :\r\n"");\r\nev_type = GFX_SWITCH;\r\nreal_ev = __sony_nc_gfx_switch_status_get();\r\nbreak;\r\ncase 0x015B:\r\nev_type = GFX_SWITCH;\r\nreal_ev = __sony_nc_gfx_switch_status_get();\r\nbreak;\r\ndefault:\r\ndprintk("Unknown event 0x%x for handle 0x%x\n",\r\nevent, handle);\r\nbreak;\r\n}\r\narg = 1 << offset;\r\nsony_nc_int_call(sony_nc_acpi_handle, "SN05", &arg, &result);\r\n} else {\r\nev_type = HOTKEY;\r\nsony_laptop_report_input_event(real_ev);\r\n}\r\nacpi_bus_generate_netlink_event(sony_nc_acpi_device->pnp.device_class,\r\ndev_name(&sony_nc_acpi_device->dev), ev_type, real_ev);\r\n}\r\nstatic acpi_status sony_walk_callback(acpi_handle handle, u32 level,\r\nvoid *context, void **return_value)\r\n{\r\nstruct acpi_device_info *info;\r\nif (ACPI_SUCCESS(acpi_get_object_info(handle, &info))) {\r\npr_warn("method: name: %4.4s, args %X\n",\r\n(char *)&info->name, info->param_count);\r\nkfree(info);\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic void sony_nc_function_setup(struct acpi_device *device,\r\nstruct platform_device *pf_device)\r\n{\r\nunsigned int i, result, bitmask, arg;\r\nif (!handles)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(handles->cap); i++) {\r\nunsigned int handle = handles->cap[i];\r\nif (!handle)\r\ncontinue;\r\ndprintk("setting up handle 0x%.4x\n", handle);\r\nswitch (handle) {\r\ncase 0x0100:\r\ncase 0x0101:\r\ncase 0x0127:\r\nsony_call_snc_handle(handle, 0, &result);\r\nbreak;\r\ncase 0x0102:\r\nsony_call_snc_handle(handle, 0x100, &result);\r\nbreak;\r\ncase 0x0105:\r\ncase 0x0148:\r\nresult = sony_nc_touchpad_setup(pf_device, handle);\r\nif (result)\r\npr_err("couldn't set up touchpad control function (%d)\n",\r\nresult);\r\nbreak;\r\ncase 0x0115:\r\ncase 0x0136:\r\ncase 0x013f:\r\nresult = sony_nc_battery_care_setup(pf_device, handle);\r\nif (result)\r\npr_err("couldn't set up battery care function (%d)\n",\r\nresult);\r\nbreak;\r\ncase 0x0119:\r\ncase 0x015D:\r\nresult = sony_nc_lid_resume_setup(pf_device, handle);\r\nif (result)\r\npr_err("couldn't set up lid resume function (%d)\n",\r\nresult);\r\nbreak;\r\ncase 0x0122:\r\nresult = sony_nc_thermal_setup(pf_device);\r\nif (result)\r\npr_err("couldn't set up thermal profile function (%d)\n",\r\nresult);\r\nbreak;\r\ncase 0x0128:\r\ncase 0x0146:\r\ncase 0x015B:\r\nresult = sony_nc_gfx_switch_setup(pf_device, handle);\r\nif (result)\r\npr_err("couldn't set up GFX Switch status (%d)\n",\r\nresult);\r\nbreak;\r\ncase 0x0131:\r\nresult = sony_nc_highspeed_charging_setup(pf_device);\r\nif (result)\r\npr_err("couldn't set up high speed charging function (%d)\n",\r\nresult);\r\nbreak;\r\ncase 0x0124:\r\ncase 0x0135:\r\nresult = sony_nc_rfkill_setup(device, handle);\r\nif (result)\r\npr_err("couldn't set up rfkill support (%d)\n",\r\nresult);\r\nbreak;\r\ncase 0x0137:\r\ncase 0x0143:\r\ncase 0x014b:\r\ncase 0x014c:\r\ncase 0x0163:\r\nresult = sony_nc_kbd_backlight_setup(pf_device, handle);\r\nif (result)\r\npr_err("couldn't set up keyboard backlight function (%d)\n",\r\nresult);\r\nbreak;\r\ncase 0x0121:\r\nresult = sony_nc_lowbatt_setup(pf_device);\r\nif (result)\r\npr_err("couldn't set up low battery function (%d)\n",\r\nresult);\r\nbreak;\r\ncase 0x0149:\r\nresult = sony_nc_fanspeed_setup(pf_device);\r\nif (result)\r\npr_err("couldn't set up fan speed function (%d)\n",\r\nresult);\r\nbreak;\r\ncase 0x0155:\r\nresult = sony_nc_usb_charge_setup(pf_device);\r\nif (result)\r\npr_err("couldn't set up USB charge support (%d)\n",\r\nresult);\r\nbreak;\r\ncase 0x011D:\r\nresult = sony_nc_panelid_setup(pf_device);\r\nif (result)\r\npr_err("couldn't set up panel ID function (%d)\n",\r\nresult);\r\nbreak;\r\ncase 0x0168:\r\nresult = sony_nc_smart_conn_setup(pf_device);\r\nif (result)\r\npr_err("couldn't set up smart connect support (%d)\n",\r\nresult);\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\n}\r\narg = 0x10;\r\nif (!sony_nc_int_call(sony_nc_acpi_handle, "SN00", &arg, &bitmask))\r\nsony_nc_int_call(sony_nc_acpi_handle, "SN02", &bitmask,\r\n&result);\r\n}\r\nstatic void sony_nc_function_cleanup(struct platform_device *pd)\r\n{\r\nunsigned int i, result, bitmask, handle;\r\nsony_nc_int_call(sony_nc_acpi_handle, "SN01", NULL, &bitmask);\r\nsony_nc_int_call(sony_nc_acpi_handle, "SN03", &bitmask, &result);\r\nfor (i = 0; i < ARRAY_SIZE(handles->cap); i++) {\r\nhandle = handles->cap[i];\r\nif (!handle)\r\ncontinue;\r\nswitch (handle) {\r\ncase 0x0105:\r\ncase 0x0148:\r\nsony_nc_touchpad_cleanup(pd);\r\nbreak;\r\ncase 0x0115:\r\ncase 0x0136:\r\ncase 0x013f:\r\nsony_nc_battery_care_cleanup(pd);\r\nbreak;\r\ncase 0x0119:\r\ncase 0x015D:\r\nsony_nc_lid_resume_cleanup(pd);\r\nbreak;\r\ncase 0x0122:\r\nsony_nc_thermal_cleanup(pd);\r\nbreak;\r\ncase 0x0128:\r\ncase 0x0146:\r\ncase 0x015B:\r\nsony_nc_gfx_switch_cleanup(pd);\r\nbreak;\r\ncase 0x0131:\r\nsony_nc_highspeed_charging_cleanup(pd);\r\nbreak;\r\ncase 0x0124:\r\ncase 0x0135:\r\nsony_nc_rfkill_cleanup();\r\nbreak;\r\ncase 0x0137:\r\ncase 0x0143:\r\ncase 0x014b:\r\ncase 0x014c:\r\ncase 0x0163:\r\nsony_nc_kbd_backlight_cleanup(pd, handle);\r\nbreak;\r\ncase 0x0121:\r\nsony_nc_lowbatt_cleanup(pd);\r\nbreak;\r\ncase 0x0149:\r\nsony_nc_fanspeed_cleanup(pd);\r\nbreak;\r\ncase 0x0155:\r\nsony_nc_usb_charge_cleanup(pd);\r\nbreak;\r\ncase 0x011D:\r\nsony_nc_panelid_cleanup(pd);\r\nbreak;\r\ncase 0x0168:\r\nsony_nc_smart_conn_cleanup(pd);\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\n}\r\nsony_nc_handles_cleanup(pd);\r\n}\r\nstatic void sony_nc_function_resume(void)\r\n{\r\nunsigned int i, result, bitmask, arg;\r\ndprintk("Resuming SNC device\n");\r\nfor (i = 0; i < ARRAY_SIZE(handles->cap); i++) {\r\nunsigned int handle = handles->cap[i];\r\nif (!handle)\r\ncontinue;\r\nswitch (handle) {\r\ncase 0x0100:\r\ncase 0x0101:\r\ncase 0x0127:\r\nsony_call_snc_handle(handle, 0, &result);\r\nbreak;\r\ncase 0x0102:\r\nsony_call_snc_handle(handle, 0x100, &result);\r\nbreak;\r\ncase 0x0122:\r\nsony_nc_thermal_resume();\r\nbreak;\r\ncase 0x0124:\r\ncase 0x0135:\r\nsony_nc_rfkill_update();\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\n}\r\narg = 0x10;\r\nif (!sony_nc_int_call(sony_nc_acpi_handle, "SN00", &arg, &bitmask))\r\nsony_nc_int_call(sony_nc_acpi_handle, "SN02", &bitmask,\r\n&result);\r\n}\r\nstatic int sony_nc_resume(struct device *dev)\r\n{\r\nstruct sony_nc_value *item;\r\nfor (item = sony_nc_values; item->name; item++) {\r\nint ret;\r\nif (!item->valid)\r\ncontinue;\r\nret = sony_nc_int_call(sony_nc_acpi_handle, *item->acpiset,\r\n&item->value, NULL);\r\nif (ret < 0) {\r\npr_err("%s: %d\n", __func__, ret);\r\nbreak;\r\n}\r\n}\r\nif (acpi_has_method(sony_nc_acpi_handle, "ECON")) {\r\nint arg = 1;\r\nif (sony_nc_int_call(sony_nc_acpi_handle, "ECON", &arg, NULL))\r\ndprintk("ECON Method failed\n");\r\n}\r\nif (acpi_has_method(sony_nc_acpi_handle, "SN00"))\r\nsony_nc_function_resume();\r\nreturn 0;\r\n}\r\nstatic void sony_nc_rfkill_cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < N_SONY_RFKILL; i++) {\r\nif (sony_rfkill_devices[i]) {\r\nrfkill_unregister(sony_rfkill_devices[i]);\r\nrfkill_destroy(sony_rfkill_devices[i]);\r\n}\r\n}\r\n}\r\nstatic int sony_nc_rfkill_set(void *data, bool blocked)\r\n{\r\nint result;\r\nint argument = sony_rfkill_address[(long) data] + 0x100;\r\nif (!blocked)\r\nargument |= 0x070000;\r\nreturn sony_call_snc_handle(sony_rfkill_handle, argument, &result);\r\n}\r\nstatic int sony_nc_setup_rfkill(struct acpi_device *device,\r\nenum sony_nc_rfkill nc_type)\r\n{\r\nint err = 0;\r\nstruct rfkill *rfk;\r\nenum rfkill_type type;\r\nconst char *name;\r\nint result;\r\nbool hwblock, swblock;\r\nswitch (nc_type) {\r\ncase SONY_WIFI:\r\ntype = RFKILL_TYPE_WLAN;\r\nname = "sony-wifi";\r\nbreak;\r\ncase SONY_BLUETOOTH:\r\ntype = RFKILL_TYPE_BLUETOOTH;\r\nname = "sony-bluetooth";\r\nbreak;\r\ncase SONY_WWAN:\r\ntype = RFKILL_TYPE_WWAN;\r\nname = "sony-wwan";\r\nbreak;\r\ncase SONY_WIMAX:\r\ntype = RFKILL_TYPE_WIMAX;\r\nname = "sony-wimax";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrfk = rfkill_alloc(name, &device->dev, type,\r\n&sony_rfkill_ops, (void *)nc_type);\r\nif (!rfk)\r\nreturn -ENOMEM;\r\nif (sony_call_snc_handle(sony_rfkill_handle, 0x200, &result) < 0) {\r\nrfkill_destroy(rfk);\r\nreturn -1;\r\n}\r\nhwblock = !(result & 0x1);\r\nif (sony_call_snc_handle(sony_rfkill_handle,\r\nsony_rfkill_address[nc_type],\r\n&result) < 0) {\r\nrfkill_destroy(rfk);\r\nreturn -1;\r\n}\r\nswblock = !(result & 0x2);\r\nrfkill_init_sw_state(rfk, swblock);\r\nrfkill_set_hw_state(rfk, hwblock);\r\nerr = rfkill_register(rfk);\r\nif (err) {\r\nrfkill_destroy(rfk);\r\nreturn err;\r\n}\r\nsony_rfkill_devices[nc_type] = rfk;\r\nreturn err;\r\n}\r\nstatic void sony_nc_rfkill_update(void)\r\n{\r\nenum sony_nc_rfkill i;\r\nint result;\r\nbool hwblock;\r\nsony_call_snc_handle(sony_rfkill_handle, 0x200, &result);\r\nhwblock = !(result & 0x1);\r\nfor (i = 0; i < N_SONY_RFKILL; i++) {\r\nint argument = sony_rfkill_address[i];\r\nif (!sony_rfkill_devices[i])\r\ncontinue;\r\nif (hwblock) {\r\nif (rfkill_set_hw_state(sony_rfkill_devices[i], true)) {\r\n}\r\ncontinue;\r\n}\r\nsony_call_snc_handle(sony_rfkill_handle, argument, &result);\r\nrfkill_set_states(sony_rfkill_devices[i],\r\n!(result & 0x2), false);\r\n}\r\n}\r\nstatic int sony_nc_rfkill_setup(struct acpi_device *device,\r\nunsigned int handle)\r\n{\r\nu64 offset;\r\nint i;\r\nunsigned char buffer[32] = { 0 };\r\noffset = sony_find_snc_handle(handle);\r\nsony_rfkill_handle = handle;\r\ni = sony_nc_buffer_call(sony_nc_acpi_handle, "SN06", &offset, buffer,\r\n32);\r\nif (i < 0)\r\nreturn i;\r\nfor (i = 0; i < ARRAY_SIZE(buffer); i++) {\r\nif (buffer[i] == 0xff)\r\nbreak;\r\ndprintk("Radio devices, found 0x%.2x\n", buffer[i]);\r\nif (buffer[i] == 0 && !sony_rfkill_devices[SONY_WIFI])\r\nsony_nc_setup_rfkill(device, SONY_WIFI);\r\nif (buffer[i] == 0x10 && !sony_rfkill_devices[SONY_BLUETOOTH])\r\nsony_nc_setup_rfkill(device, SONY_BLUETOOTH);\r\nif (((0xf0 & buffer[i]) == 0x20 ||\r\n(0xf0 & buffer[i]) == 0x50) &&\r\n!sony_rfkill_devices[SONY_WWAN])\r\nsony_nc_setup_rfkill(device, SONY_WWAN);\r\nif (buffer[i] == 0x30 && !sony_rfkill_devices[SONY_WIMAX])\r\nsony_nc_setup_rfkill(device, SONY_WIMAX);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t __sony_nc_kbd_backlight_mode_set(u8 value)\r\n{\r\nint result;\r\nif (value > 2)\r\nreturn -EINVAL;\r\nif (sony_call_snc_handle(kbdbl_ctl->handle,\r\n(value << 0x10) | (kbdbl_ctl->base), &result))\r\nreturn -EIO;\r\nif (value != 1)\r\nsony_call_snc_handle(kbdbl_ctl->handle,\r\n(value << 0x0f) | (kbdbl_ctl->base + 0x100),\r\n&result);\r\nkbdbl_ctl->mode = value;\r\nreturn 0;\r\n}\r\nstatic ssize_t sony_nc_kbd_backlight_mode_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nint ret = 0;\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoul(buffer, 10, &value))\r\nreturn -EINVAL;\r\nret = __sony_nc_kbd_backlight_mode_set(value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_nc_kbd_backlight_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nssize_t count = 0;\r\ncount = snprintf(buffer, PAGE_SIZE, "%d\n", kbdbl_ctl->mode);\r\nreturn count;\r\n}\r\nstatic int __sony_nc_kbd_backlight_timeout_set(u8 value)\r\n{\r\nint result;\r\nif (value > 3)\r\nreturn -EINVAL;\r\nif (sony_call_snc_handle(kbdbl_ctl->handle, (value << 0x10) |\r\n(kbdbl_ctl->base + 0x200), &result))\r\nreturn -EIO;\r\nkbdbl_ctl->timeout = value;\r\nreturn 0;\r\n}\r\nstatic ssize_t sony_nc_kbd_backlight_timeout_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nint ret = 0;\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoul(buffer, 10, &value))\r\nreturn -EINVAL;\r\nret = __sony_nc_kbd_backlight_timeout_set(value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_nc_kbd_backlight_timeout_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nssize_t count = 0;\r\ncount = snprintf(buffer, PAGE_SIZE, "%d\n", kbdbl_ctl->timeout);\r\nreturn count;\r\n}\r\nstatic int sony_nc_kbd_backlight_setup(struct platform_device *pd,\r\nunsigned int handle)\r\n{\r\nint result;\r\nint ret = 0;\r\nif (kbdbl_ctl) {\r\npr_warn("handle 0x%.4x: keyboard backlight setup already done for 0x%.4x\n",\r\nhandle, kbdbl_ctl->handle);\r\nreturn -EBUSY;\r\n}\r\nret = sony_call_snc_handle(handle, handle == 0x0137 ? 0x0B00 : 0x0100,\r\n&result);\r\nif (ret)\r\nreturn ret;\r\nif ((handle == 0x0137 && !(result & 0x02)) ||\r\n!(result & 0x01)) {\r\ndprintk("no backlight keyboard found\n");\r\nreturn 0;\r\n}\r\nkbdbl_ctl = kzalloc(sizeof(*kbdbl_ctl), GFP_KERNEL);\r\nif (!kbdbl_ctl)\r\nreturn -ENOMEM;\r\nkbdbl_ctl->mode = kbd_backlight;\r\nkbdbl_ctl->timeout = kbd_backlight_timeout;\r\nkbdbl_ctl->handle = handle;\r\nif (handle == 0x0137)\r\nkbdbl_ctl->base = 0x0C00;\r\nelse\r\nkbdbl_ctl->base = 0x4000;\r\nsysfs_attr_init(&kbdbl_ctl->mode_attr.attr);\r\nkbdbl_ctl->mode_attr.attr.name = "kbd_backlight";\r\nkbdbl_ctl->mode_attr.attr.mode = S_IRUGO | S_IWUSR;\r\nkbdbl_ctl->mode_attr.show = sony_nc_kbd_backlight_mode_show;\r\nkbdbl_ctl->mode_attr.store = sony_nc_kbd_backlight_mode_store;\r\nsysfs_attr_init(&kbdbl_ctl->timeout_attr.attr);\r\nkbdbl_ctl->timeout_attr.attr.name = "kbd_backlight_timeout";\r\nkbdbl_ctl->timeout_attr.attr.mode = S_IRUGO | S_IWUSR;\r\nkbdbl_ctl->timeout_attr.show = sony_nc_kbd_backlight_timeout_show;\r\nkbdbl_ctl->timeout_attr.store = sony_nc_kbd_backlight_timeout_store;\r\nret = device_create_file(&pd->dev, &kbdbl_ctl->mode_attr);\r\nif (ret)\r\ngoto outkzalloc;\r\nret = device_create_file(&pd->dev, &kbdbl_ctl->timeout_attr);\r\nif (ret)\r\ngoto outmode;\r\n__sony_nc_kbd_backlight_mode_set(kbdbl_ctl->mode);\r\n__sony_nc_kbd_backlight_timeout_set(kbdbl_ctl->timeout);\r\nreturn 0;\r\noutmode:\r\ndevice_remove_file(&pd->dev, &kbdbl_ctl->mode_attr);\r\noutkzalloc:\r\nkfree(kbdbl_ctl);\r\nkbdbl_ctl = NULL;\r\nreturn ret;\r\n}\r\nstatic void sony_nc_kbd_backlight_cleanup(struct platform_device *pd,\r\nunsigned int handle)\r\n{\r\nif (kbdbl_ctl && handle == kbdbl_ctl->handle) {\r\ndevice_remove_file(&pd->dev, &kbdbl_ctl->mode_attr);\r\ndevice_remove_file(&pd->dev, &kbdbl_ctl->timeout_attr);\r\nkfree(kbdbl_ctl);\r\nkbdbl_ctl = NULL;\r\n}\r\n}\r\nstatic ssize_t sony_nc_battery_care_limit_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned int result, cmd;\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoul(buffer, 10, &value))\r\nreturn -EINVAL;\r\ncmd = 0;\r\nif (value > 0) {\r\nif (value <= 50)\r\ncmd = 0x20;\r\nelse if (value <= 80)\r\ncmd = 0x10;\r\nelse if (value <= 100)\r\ncmd = 0x30;\r\nelse\r\nreturn -EINVAL;\r\nif (bcare_ctl->handle != 0x013f)\r\ncmd = cmd | (cmd << 2);\r\ncmd = (cmd | 0x1) << 0x10;\r\n}\r\nif (sony_call_snc_handle(bcare_ctl->handle, cmd | 0x0100, &result))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_nc_battery_care_limit_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nunsigned int result, status;\r\nif (sony_call_snc_handle(bcare_ctl->handle, 0x0000, &result))\r\nreturn -EIO;\r\nstatus = (result & 0x01) ? ((result & 0x30) >> 0x04) : 0;\r\nswitch (status) {\r\ncase 1:\r\nstatus = 80;\r\nbreak;\r\ncase 2:\r\nstatus = 50;\r\nbreak;\r\ncase 3:\r\nstatus = 100;\r\nbreak;\r\ndefault:\r\nstatus = 0;\r\nbreak;\r\n}\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n", status);\r\n}\r\nstatic ssize_t sony_nc_battery_care_health_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nssize_t count = 0;\r\nunsigned int health;\r\nif (sony_call_snc_handle(bcare_ctl->handle, 0x0200, &health))\r\nreturn -EIO;\r\ncount = snprintf(buffer, PAGE_SIZE, "%d\n", health & 0xff);\r\nreturn count;\r\n}\r\nstatic int sony_nc_battery_care_setup(struct platform_device *pd,\r\nunsigned int handle)\r\n{\r\nint ret = 0;\r\nbcare_ctl = kzalloc(sizeof(struct battery_care_control), GFP_KERNEL);\r\nif (!bcare_ctl)\r\nreturn -ENOMEM;\r\nbcare_ctl->handle = handle;\r\nsysfs_attr_init(&bcare_ctl->attrs[0].attr);\r\nbcare_ctl->attrs[0].attr.name = "battery_care_limiter";\r\nbcare_ctl->attrs[0].attr.mode = S_IRUGO | S_IWUSR;\r\nbcare_ctl->attrs[0].show = sony_nc_battery_care_limit_show;\r\nbcare_ctl->attrs[0].store = sony_nc_battery_care_limit_store;\r\nret = device_create_file(&pd->dev, &bcare_ctl->attrs[0]);\r\nif (ret)\r\ngoto outkzalloc;\r\nif (handle == 0x0115)\r\nreturn 0;\r\nsysfs_attr_init(&bcare_ctl->attrs[1].attr);\r\nbcare_ctl->attrs[1].attr.name = "battery_care_health";\r\nbcare_ctl->attrs[1].attr.mode = S_IRUGO;\r\nbcare_ctl->attrs[1].show = sony_nc_battery_care_health_show;\r\nret = device_create_file(&pd->dev, &bcare_ctl->attrs[1]);\r\nif (ret)\r\ngoto outlimiter;\r\nreturn 0;\r\noutlimiter:\r\ndevice_remove_file(&pd->dev, &bcare_ctl->attrs[0]);\r\noutkzalloc:\r\nkfree(bcare_ctl);\r\nbcare_ctl = NULL;\r\nreturn ret;\r\n}\r\nstatic void sony_nc_battery_care_cleanup(struct platform_device *pd)\r\n{\r\nif (bcare_ctl) {\r\ndevice_remove_file(&pd->dev, &bcare_ctl->attrs[0]);\r\nif (bcare_ctl->handle != 0x0115)\r\ndevice_remove_file(&pd->dev, &bcare_ctl->attrs[1]);\r\nkfree(bcare_ctl);\r\nbcare_ctl = NULL;\r\n}\r\n}\r\nstatic int sony_nc_thermal_mode_set(unsigned short mode)\r\n{\r\nunsigned int result;\r\nif ((mode && !(th_handle->profiles & mode)) || mode >= THM_PROFILE_MAX)\r\nreturn -EINVAL;\r\nif (sony_call_snc_handle(0x0122, mode << 0x10 | 0x0200, &result))\r\nreturn -EIO;\r\nth_handle->mode = mode;\r\nreturn 0;\r\n}\r\nstatic int sony_nc_thermal_mode_get(void)\r\n{\r\nunsigned int result;\r\nif (sony_call_snc_handle(0x0122, 0x0100, &result))\r\nreturn -EIO;\r\nreturn result & 0xff;\r\n}\r\nstatic ssize_t sony_nc_thermal_profiles_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nshort cnt;\r\nsize_t idx = 0;\r\nfor (cnt = 0; cnt < THM_PROFILE_MAX; cnt++) {\r\nif (!cnt || (th_handle->profiles & cnt))\r\nidx += snprintf(buffer + idx, PAGE_SIZE - idx, "%s ",\r\nsnc_thermal_profiles[cnt]);\r\n}\r\nidx += snprintf(buffer + idx, PAGE_SIZE - idx, "\n");\r\nreturn idx;\r\n}\r\nstatic ssize_t sony_nc_thermal_mode_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned short cmd;\r\nsize_t len = count;\r\nif (count == 0)\r\nreturn -EINVAL;\r\nif (buffer[len - 1] == '\n')\r\nlen--;\r\nfor (cmd = 0; cmd < THM_PROFILE_MAX; cmd++)\r\nif (strncmp(buffer, snc_thermal_profiles[cmd], len) == 0)\r\nbreak;\r\nif (sony_nc_thermal_mode_set(cmd))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_nc_thermal_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nssize_t count = 0;\r\nint mode = sony_nc_thermal_mode_get();\r\nif (mode < 0)\r\nreturn mode;\r\ncount = snprintf(buffer, PAGE_SIZE, "%s\n", snc_thermal_profiles[mode]);\r\nreturn count;\r\n}\r\nstatic int sony_nc_thermal_setup(struct platform_device *pd)\r\n{\r\nint ret = 0;\r\nth_handle = kzalloc(sizeof(struct snc_thermal_ctrl), GFP_KERNEL);\r\nif (!th_handle)\r\nreturn -ENOMEM;\r\nret = sony_call_snc_handle(0x0122, 0x0000, &th_handle->profiles);\r\nif (ret) {\r\npr_warn("couldn't to read the thermal profiles\n");\r\ngoto outkzalloc;\r\n}\r\nret = sony_nc_thermal_mode_get();\r\nif (ret < 0) {\r\npr_warn("couldn't to read the current thermal profile");\r\ngoto outkzalloc;\r\n}\r\nth_handle->mode = ret;\r\nsysfs_attr_init(&th_handle->profiles_attr.attr);\r\nth_handle->profiles_attr.attr.name = "thermal_profiles";\r\nth_handle->profiles_attr.attr.mode = S_IRUGO;\r\nth_handle->profiles_attr.show = sony_nc_thermal_profiles_show;\r\nsysfs_attr_init(&th_handle->mode_attr.attr);\r\nth_handle->mode_attr.attr.name = "thermal_control";\r\nth_handle->mode_attr.attr.mode = S_IRUGO | S_IWUSR;\r\nth_handle->mode_attr.show = sony_nc_thermal_mode_show;\r\nth_handle->mode_attr.store = sony_nc_thermal_mode_store;\r\nret = device_create_file(&pd->dev, &th_handle->profiles_attr);\r\nif (ret)\r\ngoto outkzalloc;\r\nret = device_create_file(&pd->dev, &th_handle->mode_attr);\r\nif (ret)\r\ngoto outprofiles;\r\nreturn 0;\r\noutprofiles:\r\ndevice_remove_file(&pd->dev, &th_handle->profiles_attr);\r\noutkzalloc:\r\nkfree(th_handle);\r\nth_handle = NULL;\r\nreturn ret;\r\n}\r\nstatic void sony_nc_thermal_cleanup(struct platform_device *pd)\r\n{\r\nif (th_handle) {\r\ndevice_remove_file(&pd->dev, &th_handle->profiles_attr);\r\ndevice_remove_file(&pd->dev, &th_handle->mode_attr);\r\nkfree(th_handle);\r\nth_handle = NULL;\r\n}\r\n}\r\nstatic void sony_nc_thermal_resume(void)\r\n{\r\nunsigned int status = sony_nc_thermal_mode_get();\r\nif (status != th_handle->mode)\r\nsony_nc_thermal_mode_set(th_handle->mode);\r\n}\r\nstatic ssize_t sony_nc_lid_resume_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned int result;\r\nunsigned long value;\r\nunsigned int pos = LID_RESUME_S5;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoul(buffer, 10, &value) || value > 1)\r\nreturn -EINVAL;\r\nwhile (pos < LID_RESUME_MAX) {\r\nif (&lid_ctl->attrs[pos].attr == &attr->attr)\r\nbreak;\r\npos++;\r\n}\r\nif (pos == LID_RESUME_MAX)\r\nreturn -EINVAL;\r\nif (value)\r\nvalue = lid_ctl->status | (1 << pos);\r\nelse\r\nvalue = lid_ctl->status & ~(1 << pos);\r\nif (sony_call_snc_handle(lid_ctl->handle, value << 0x10 | 0x0100,\r\n&result))\r\nreturn -EIO;\r\nlid_ctl->status = value;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_nc_lid_resume_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buffer)\r\n{\r\nunsigned int pos = LID_RESUME_S5;\r\nwhile (pos < LID_RESUME_MAX) {\r\nif (&lid_ctl->attrs[pos].attr == &attr->attr)\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n",\r\n(lid_ctl->status >> pos) & 0x01);\r\npos++;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sony_nc_lid_resume_setup(struct platform_device *pd,\r\nunsigned int handle)\r\n{\r\nunsigned int result;\r\nint i;\r\nif (sony_call_snc_handle(handle, 0x0000, &result))\r\nreturn -EIO;\r\nlid_ctl = kzalloc(sizeof(struct snc_lid_resume_control), GFP_KERNEL);\r\nif (!lid_ctl)\r\nreturn -ENOMEM;\r\nlid_ctl->status = result & 0x7;\r\nlid_ctl->handle = handle;\r\nsysfs_attr_init(&lid_ctl->attrs[0].attr);\r\nlid_ctl->attrs[LID_RESUME_S5].attr.name = "lid_resume_S5";\r\nlid_ctl->attrs[LID_RESUME_S5].attr.mode = S_IRUGO | S_IWUSR;\r\nlid_ctl->attrs[LID_RESUME_S5].show = sony_nc_lid_resume_show;\r\nlid_ctl->attrs[LID_RESUME_S5].store = sony_nc_lid_resume_store;\r\nif (handle == 0x0119) {\r\nsysfs_attr_init(&lid_ctl->attrs[1].attr);\r\nlid_ctl->attrs[LID_RESUME_S4].attr.name = "lid_resume_S4";\r\nlid_ctl->attrs[LID_RESUME_S4].attr.mode = S_IRUGO | S_IWUSR;\r\nlid_ctl->attrs[LID_RESUME_S4].show = sony_nc_lid_resume_show;\r\nlid_ctl->attrs[LID_RESUME_S4].store = sony_nc_lid_resume_store;\r\nsysfs_attr_init(&lid_ctl->attrs[2].attr);\r\nlid_ctl->attrs[LID_RESUME_S3].attr.name = "lid_resume_S3";\r\nlid_ctl->attrs[LID_RESUME_S3].attr.mode = S_IRUGO | S_IWUSR;\r\nlid_ctl->attrs[LID_RESUME_S3].show = sony_nc_lid_resume_show;\r\nlid_ctl->attrs[LID_RESUME_S3].store = sony_nc_lid_resume_store;\r\n}\r\nfor (i = 0; i < LID_RESUME_MAX &&\r\nlid_ctl->attrs[LID_RESUME_S3].attr.name; i++) {\r\nresult = device_create_file(&pd->dev, &lid_ctl->attrs[i]);\r\nif (result)\r\ngoto liderror;\r\n}\r\nreturn 0;\r\nliderror:\r\nfor (i--; i >= 0; i--)\r\ndevice_remove_file(&pd->dev, &lid_ctl->attrs[i]);\r\nkfree(lid_ctl);\r\nlid_ctl = NULL;\r\nreturn result;\r\n}\r\nstatic void sony_nc_lid_resume_cleanup(struct platform_device *pd)\r\n{\r\nint i;\r\nif (lid_ctl) {\r\nfor (i = 0; i < LID_RESUME_MAX; i++) {\r\nif (!lid_ctl->attrs[i].attr.name)\r\nbreak;\r\ndevice_remove_file(&pd->dev, &lid_ctl->attrs[i]);\r\n}\r\nkfree(lid_ctl);\r\nlid_ctl = NULL;\r\n}\r\n}\r\nstatic int __sony_nc_gfx_switch_status_get(void)\r\n{\r\nunsigned int result;\r\nif (sony_call_snc_handle(gfxs_ctl->handle,\r\ngfxs_ctl->handle == 0x015B ? 0x0000 : 0x0100,\r\n&result))\r\nreturn -EIO;\r\nswitch (gfxs_ctl->handle) {\r\ncase 0x0146:\r\nreturn result & 0x1 ? SPEED : STAMINA;\r\nbreak;\r\ncase 0x015B:\r\nreturn result & 0x1 ? STAMINA : SPEED;\r\nbreak;\r\ncase 0x0128:\r\ndprintk("GFX Status: 0x%x\n", result);\r\nreturn result & 0x80 ? AUTO :\r\nresult & 0x02 ? STAMINA : SPEED;\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t sony_nc_gfx_switch_status_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buffer)\r\n{\r\nint pos = __sony_nc_gfx_switch_status_get();\r\nif (pos < 0)\r\nreturn pos;\r\nreturn snprintf(buffer, PAGE_SIZE, "%s\n",\r\npos == SPEED ? "speed" :\r\npos == STAMINA ? "stamina" :\r\npos == AUTO ? "auto" : "unknown");\r\n}\r\nstatic int sony_nc_gfx_switch_setup(struct platform_device *pd,\r\nunsigned int handle)\r\n{\r\nunsigned int result;\r\ngfxs_ctl = kzalloc(sizeof(struct snc_gfx_switch_control), GFP_KERNEL);\r\nif (!gfxs_ctl)\r\nreturn -ENOMEM;\r\ngfxs_ctl->handle = handle;\r\nsysfs_attr_init(&gfxs_ctl->attr.attr);\r\ngfxs_ctl->attr.attr.name = "gfx_switch_status";\r\ngfxs_ctl->attr.attr.mode = S_IRUGO;\r\ngfxs_ctl->attr.show = sony_nc_gfx_switch_status_show;\r\nresult = device_create_file(&pd->dev, &gfxs_ctl->attr);\r\nif (result)\r\ngoto gfxerror;\r\nreturn 0;\r\ngfxerror:\r\nkfree(gfxs_ctl);\r\ngfxs_ctl = NULL;\r\nreturn result;\r\n}\r\nstatic void sony_nc_gfx_switch_cleanup(struct platform_device *pd)\r\n{\r\nif (gfxs_ctl) {\r\ndevice_remove_file(&pd->dev, &gfxs_ctl->attr);\r\nkfree(gfxs_ctl);\r\ngfxs_ctl = NULL;\r\n}\r\n}\r\nstatic ssize_t sony_nc_highspeed_charging_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned int result;\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoul(buffer, 10, &value) || value > 1)\r\nreturn -EINVAL;\r\nif (sony_call_snc_handle(0x0131, value << 0x10 | 0x0200, &result))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_nc_highspeed_charging_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nunsigned int result;\r\nif (sony_call_snc_handle(0x0131, 0x0100, &result))\r\nreturn -EIO;\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n", result & 0x01);\r\n}\r\nstatic int sony_nc_highspeed_charging_setup(struct platform_device *pd)\r\n{\r\nunsigned int result;\r\nif (sony_call_snc_handle(0x0131, 0x0000, &result) || !(result & 0x01)) {\r\npr_info("No High Speed Charging capability found\n");\r\nreturn 0;\r\n}\r\nhsc_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\r\nif (!hsc_handle)\r\nreturn -ENOMEM;\r\nsysfs_attr_init(&hsc_handle->attr);\r\nhsc_handle->attr.name = "battery_highspeed_charging";\r\nhsc_handle->attr.mode = S_IRUGO | S_IWUSR;\r\nhsc_handle->show = sony_nc_highspeed_charging_show;\r\nhsc_handle->store = sony_nc_highspeed_charging_store;\r\nresult = device_create_file(&pd->dev, hsc_handle);\r\nif (result) {\r\nkfree(hsc_handle);\r\nhsc_handle = NULL;\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sony_nc_highspeed_charging_cleanup(struct platform_device *pd)\r\n{\r\nif (hsc_handle) {\r\ndevice_remove_file(&pd->dev, hsc_handle);\r\nkfree(hsc_handle);\r\nhsc_handle = NULL;\r\n}\r\n}\r\nstatic ssize_t sony_nc_lowbatt_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned int result;\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoul(buffer, 10, &value) || value > 1)\r\nreturn -EINVAL;\r\nif (sony_call_snc_handle(0x0121, value << 8, &result))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_nc_lowbatt_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nunsigned int result;\r\nif (sony_call_snc_handle(0x0121, 0x0200, &result))\r\nreturn -EIO;\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n", result & 1);\r\n}\r\nstatic int sony_nc_lowbatt_setup(struct platform_device *pd)\r\n{\r\nunsigned int result;\r\nlowbatt_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\r\nif (!lowbatt_handle)\r\nreturn -ENOMEM;\r\nsysfs_attr_init(&lowbatt_handle->attr);\r\nlowbatt_handle->attr.name = "lowbatt_hibernate";\r\nlowbatt_handle->attr.mode = S_IRUGO | S_IWUSR;\r\nlowbatt_handle->show = sony_nc_lowbatt_show;\r\nlowbatt_handle->store = sony_nc_lowbatt_store;\r\nresult = device_create_file(&pd->dev, lowbatt_handle);\r\nif (result) {\r\nkfree(lowbatt_handle);\r\nlowbatt_handle = NULL;\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sony_nc_lowbatt_cleanup(struct platform_device *pd)\r\n{\r\nif (lowbatt_handle) {\r\ndevice_remove_file(&pd->dev, lowbatt_handle);\r\nkfree(lowbatt_handle);\r\nlowbatt_handle = NULL;\r\n}\r\n}\r\nstatic ssize_t sony_nc_hsfan_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned int result;\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoul(buffer, 10, &value) || value > 1)\r\nreturn -EINVAL;\r\nif (sony_call_snc_handle(0x0149, value << 0x10 | 0x0200, &result))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_nc_hsfan_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nunsigned int result;\r\nif (sony_call_snc_handle(0x0149, 0x0100, &result))\r\nreturn -EIO;\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n", result & 0x01);\r\n}\r\nstatic ssize_t sony_nc_fanspeed_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nunsigned int result;\r\nif (sony_call_snc_handle(0x0149, 0x0300, &result))\r\nreturn -EIO;\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n", result & 0xff);\r\n}\r\nstatic int sony_nc_fanspeed_setup(struct platform_device *pd)\r\n{\r\nunsigned int result;\r\nfan_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\r\nif (!fan_handle)\r\nreturn -ENOMEM;\r\nhsf_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\r\nif (!hsf_handle) {\r\nresult = -ENOMEM;\r\ngoto out_hsf_handle_alloc;\r\n}\r\nsysfs_attr_init(&fan_handle->attr);\r\nfan_handle->attr.name = "fanspeed";\r\nfan_handle->attr.mode = S_IRUGO;\r\nfan_handle->show = sony_nc_fanspeed_show;\r\nfan_handle->store = NULL;\r\nsysfs_attr_init(&hsf_handle->attr);\r\nhsf_handle->attr.name = "fan_forced";\r\nhsf_handle->attr.mode = S_IRUGO | S_IWUSR;\r\nhsf_handle->show = sony_nc_hsfan_show;\r\nhsf_handle->store = sony_nc_hsfan_store;\r\nresult = device_create_file(&pd->dev, fan_handle);\r\nif (result)\r\ngoto out_fan_handle;\r\nresult = device_create_file(&pd->dev, hsf_handle);\r\nif (result)\r\ngoto out_hsf_handle;\r\nreturn 0;\r\nout_hsf_handle:\r\ndevice_remove_file(&pd->dev, fan_handle);\r\nout_fan_handle:\r\nkfree(hsf_handle);\r\nhsf_handle = NULL;\r\nout_hsf_handle_alloc:\r\nkfree(fan_handle);\r\nfan_handle = NULL;\r\nreturn result;\r\n}\r\nstatic void sony_nc_fanspeed_cleanup(struct platform_device *pd)\r\n{\r\nif (fan_handle) {\r\ndevice_remove_file(&pd->dev, fan_handle);\r\nkfree(fan_handle);\r\nfan_handle = NULL;\r\n}\r\nif (hsf_handle) {\r\ndevice_remove_file(&pd->dev, hsf_handle);\r\nkfree(hsf_handle);\r\nhsf_handle = NULL;\r\n}\r\n}\r\nstatic ssize_t sony_nc_usb_charge_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned int result;\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoul(buffer, 10, &value) || value > 1)\r\nreturn -EINVAL;\r\nif (sony_call_snc_handle(0x0155, value << 0x10 | 0x0100, &result))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_nc_usb_charge_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nunsigned int result;\r\nif (sony_call_snc_handle(0x0155, 0x0000, &result))\r\nreturn -EIO;\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n", result & 0x01);\r\n}\r\nstatic int sony_nc_usb_charge_setup(struct platform_device *pd)\r\n{\r\nunsigned int result;\r\nif (sony_call_snc_handle(0x0155, 0x0000, &result) || !(result & 0x01)) {\r\npr_info("No USB Charge capability found\n");\r\nreturn 0;\r\n}\r\nuc_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\r\nif (!uc_handle)\r\nreturn -ENOMEM;\r\nsysfs_attr_init(&uc_handle->attr);\r\nuc_handle->attr.name = "usb_charge";\r\nuc_handle->attr.mode = S_IRUGO | S_IWUSR;\r\nuc_handle->show = sony_nc_usb_charge_show;\r\nuc_handle->store = sony_nc_usb_charge_store;\r\nresult = device_create_file(&pd->dev, uc_handle);\r\nif (result) {\r\nkfree(uc_handle);\r\nuc_handle = NULL;\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sony_nc_usb_charge_cleanup(struct platform_device *pd)\r\n{\r\nif (uc_handle) {\r\ndevice_remove_file(&pd->dev, uc_handle);\r\nkfree(uc_handle);\r\nuc_handle = NULL;\r\n}\r\n}\r\nstatic ssize_t sony_nc_panelid_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nunsigned int result;\r\nif (sony_call_snc_handle(0x011D, 0x0000, &result))\r\nreturn -EIO;\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n", result);\r\n}\r\nstatic int sony_nc_panelid_setup(struct platform_device *pd)\r\n{\r\nunsigned int result;\r\npanel_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\r\nif (!panel_handle)\r\nreturn -ENOMEM;\r\nsysfs_attr_init(&panel_handle->attr);\r\npanel_handle->attr.name = "panel_id";\r\npanel_handle->attr.mode = S_IRUGO;\r\npanel_handle->show = sony_nc_panelid_show;\r\npanel_handle->store = NULL;\r\nresult = device_create_file(&pd->dev, panel_handle);\r\nif (result) {\r\nkfree(panel_handle);\r\npanel_handle = NULL;\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sony_nc_panelid_cleanup(struct platform_device *pd)\r\n{\r\nif (panel_handle) {\r\ndevice_remove_file(&pd->dev, panel_handle);\r\nkfree(panel_handle);\r\npanel_handle = NULL;\r\n}\r\n}\r\nstatic ssize_t sony_nc_smart_conn_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned int result;\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoul(buffer, 10, &value) || value > 1)\r\nreturn -EINVAL;\r\nif (sony_call_snc_handle(0x0168, value << 0x10, &result))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic int sony_nc_smart_conn_setup(struct platform_device *pd)\r\n{\r\nunsigned int result;\r\nsc_handle = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);\r\nif (!sc_handle)\r\nreturn -ENOMEM;\r\nsysfs_attr_init(&sc_handle->attr);\r\nsc_handle->attr.name = "smart_connect";\r\nsc_handle->attr.mode = S_IWUSR;\r\nsc_handle->show = NULL;\r\nsc_handle->store = sony_nc_smart_conn_store;\r\nresult = device_create_file(&pd->dev, sc_handle);\r\nif (result) {\r\nkfree(sc_handle);\r\nsc_handle = NULL;\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sony_nc_smart_conn_cleanup(struct platform_device *pd)\r\n{\r\nif (sc_handle) {\r\ndevice_remove_file(&pd->dev, sc_handle);\r\nkfree(sc_handle);\r\nsc_handle = NULL;\r\n}\r\n}\r\nstatic ssize_t sony_nc_touchpad_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buffer, size_t count)\r\n{\r\nunsigned int result;\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoul(buffer, 10, &value) || value > 1)\r\nreturn -EINVAL;\r\nif (sony_call_snc_handle(tp_ctl->handle,\r\n(!value << 0x10) | 0x100, &result))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_nc_touchpad_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nunsigned int result;\r\nif (sony_call_snc_handle(tp_ctl->handle, 0x000, &result))\r\nreturn -EINVAL;\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n", !(result & 0x01));\r\n}\r\nstatic int sony_nc_touchpad_setup(struct platform_device *pd,\r\nunsigned int handle)\r\n{\r\nint ret = 0;\r\ntp_ctl = kzalloc(sizeof(struct touchpad_control), GFP_KERNEL);\r\nif (!tp_ctl)\r\nreturn -ENOMEM;\r\ntp_ctl->handle = handle;\r\nsysfs_attr_init(&tp_ctl->attr.attr);\r\ntp_ctl->attr.attr.name = "touchpad";\r\ntp_ctl->attr.attr.mode = S_IRUGO | S_IWUSR;\r\ntp_ctl->attr.show = sony_nc_touchpad_show;\r\ntp_ctl->attr.store = sony_nc_touchpad_store;\r\nret = device_create_file(&pd->dev, &tp_ctl->attr);\r\nif (ret) {\r\nkfree(tp_ctl);\r\ntp_ctl = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void sony_nc_touchpad_cleanup(struct platform_device *pd)\r\n{\r\nif (tp_ctl) {\r\ndevice_remove_file(&pd->dev, &tp_ctl->attr);\r\nkfree(tp_ctl);\r\ntp_ctl = NULL;\r\n}\r\n}\r\nstatic void sony_nc_backlight_ng_read_limits(int handle,\r\nstruct sony_backlight_props *props)\r\n{\r\nu64 offset;\r\nint i;\r\nint lvl_table_len = 0;\r\nu8 min = 0xff, max = 0x00;\r\nunsigned char buffer[32] = { 0 };\r\nprops->handle = handle;\r\nprops->offset = 0;\r\nprops->maxlvl = 0xff;\r\noffset = sony_find_snc_handle(handle);\r\ni = sony_nc_buffer_call(sony_nc_acpi_handle, "SN06", &offset, buffer,\r\n32);\r\nif (i < 0)\r\nreturn;\r\nswitch (handle) {\r\ncase 0x012f:\r\ncase 0x0137:\r\nlvl_table_len = 9;\r\nbreak;\r\ncase 0x143:\r\ncase 0x14b:\r\ncase 0x14c:\r\nlvl_table_len = 16;\r\nbreak;\r\n}\r\nfor (i = 0; i < lvl_table_len && i < ARRAY_SIZE(buffer); i++) {\r\ndprintk("Brightness level: %d\n", buffer[i]);\r\nif (!buffer[i])\r\nbreak;\r\nif (buffer[i] > max)\r\nmax = buffer[i];\r\nif (buffer[i] < min)\r\nmin = buffer[i];\r\n}\r\nprops->offset = min;\r\nprops->maxlvl = max;\r\ndprintk("Brightness levels: min=%d max=%d\n", props->offset,\r\nprops->maxlvl);\r\n}\r\nstatic void sony_nc_backlight_setup(void)\r\n{\r\nint max_brightness = 0;\r\nconst struct backlight_ops *ops = NULL;\r\nstruct backlight_properties props;\r\nif (sony_find_snc_handle(0x12f) >= 0) {\r\nops = &sony_backlight_ng_ops;\r\nsony_bl_props.cmd_base = 0x0100;\r\nsony_nc_backlight_ng_read_limits(0x12f, &sony_bl_props);\r\nmax_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;\r\n} else if (sony_find_snc_handle(0x137) >= 0) {\r\nops = &sony_backlight_ng_ops;\r\nsony_bl_props.cmd_base = 0x0100;\r\nsony_nc_backlight_ng_read_limits(0x137, &sony_bl_props);\r\nmax_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;\r\n} else if (sony_find_snc_handle(0x143) >= 0) {\r\nops = &sony_backlight_ng_ops;\r\nsony_bl_props.cmd_base = 0x3000;\r\nsony_nc_backlight_ng_read_limits(0x143, &sony_bl_props);\r\nmax_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;\r\n} else if (sony_find_snc_handle(0x14b) >= 0) {\r\nops = &sony_backlight_ng_ops;\r\nsony_bl_props.cmd_base = 0x3000;\r\nsony_nc_backlight_ng_read_limits(0x14b, &sony_bl_props);\r\nmax_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;\r\n} else if (sony_find_snc_handle(0x14c) >= 0) {\r\nops = &sony_backlight_ng_ops;\r\nsony_bl_props.cmd_base = 0x3000;\r\nsony_nc_backlight_ng_read_limits(0x14c, &sony_bl_props);\r\nmax_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;\r\n} else if (acpi_has_method(sony_nc_acpi_handle, "GBRT")) {\r\nops = &sony_backlight_ops;\r\nmax_brightness = SONY_MAX_BRIGHTNESS - 1;\r\n} else\r\nreturn;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = max_brightness;\r\nsony_bl_props.dev = backlight_device_register("sony", NULL,\r\n&sony_bl_props,\r\nops, &props);\r\nif (IS_ERR(sony_bl_props.dev)) {\r\npr_warn("unable to register backlight device\n");\r\nsony_bl_props.dev = NULL;\r\n} else\r\nsony_bl_props.dev->props.brightness =\r\nops->get_brightness(sony_bl_props.dev);\r\n}\r\nstatic void sony_nc_backlight_cleanup(void)\r\n{\r\nif (sony_bl_props.dev)\r\nbacklight_device_unregister(sony_bl_props.dev);\r\n}\r\nstatic int sony_nc_add(struct acpi_device *device)\r\n{\r\nacpi_status status;\r\nint result = 0;\r\nstruct sony_nc_value *item;\r\nsony_nc_acpi_device = device;\r\nstrcpy(acpi_device_class(device), "sony/hotkey");\r\nsony_nc_acpi_handle = device->handle;\r\nresult = acpi_bus_get_status(device);\r\nif (!result && !device->status.present) {\r\ndprintk("Device not present\n");\r\nresult = -ENODEV;\r\ngoto outwalk;\r\n}\r\nresult = sony_pf_add();\r\nif (result)\r\ngoto outpresent;\r\nif (debug) {\r\nstatus = acpi_walk_namespace(ACPI_TYPE_METHOD,\r\nsony_nc_acpi_handle, 1, sony_walk_callback,\r\nNULL, NULL, NULL);\r\nif (ACPI_FAILURE(status)) {\r\npr_warn("unable to walk acpi resources\n");\r\nresult = -ENODEV;\r\ngoto outpresent;\r\n}\r\n}\r\nresult = sony_laptop_setup_input(device);\r\nif (result) {\r\npr_err("Unable to create input devices\n");\r\ngoto outplatform;\r\n}\r\nif (acpi_has_method(sony_nc_acpi_handle, "ECON")) {\r\nint arg = 1;\r\nif (sony_nc_int_call(sony_nc_acpi_handle, "ECON", &arg, NULL))\r\ndprintk("ECON Method failed\n");\r\n}\r\nif (acpi_has_method(sony_nc_acpi_handle, "SN00")) {\r\ndprintk("Doing SNC setup\n");\r\nresult = sony_nc_handles_setup(sony_pf_device);\r\nif (!result)\r\nsony_nc_function_setup(device, sony_pf_device);\r\n}\r\nif (acpi_video_backlight_support()) {\r\npr_info("brightness ignored, must be controlled by ACPI video driver\n");\r\n} else {\r\nsony_nc_backlight_setup();\r\n}\r\nfor (item = sony_nc_values; item->name; ++item) {\r\nif (!debug && item->debug)\r\ncontinue;\r\nfor (; item->acpiget && *item->acpiget; ++item->acpiget) {\r\nif (acpi_has_method(sony_nc_acpi_handle,\r\n*item->acpiget)) {\r\ndprintk("Found %s getter: %s\n",\r\nitem->name, *item->acpiget);\r\nitem->devattr.attr.mode |= S_IRUGO;\r\nbreak;\r\n}\r\n}\r\nfor (; item->acpiset && *item->acpiset; ++item->acpiset) {\r\nif (acpi_has_method(sony_nc_acpi_handle,\r\n*item->acpiset)) {\r\ndprintk("Found %s setter: %s\n",\r\nitem->name, *item->acpiset);\r\nitem->devattr.attr.mode |= S_IWUSR;\r\nbreak;\r\n}\r\n}\r\nif (item->devattr.attr.mode != 0) {\r\nresult =\r\ndevice_create_file(&sony_pf_device->dev,\r\n&item->devattr);\r\nif (result)\r\ngoto out_sysfs;\r\n}\r\n}\r\npr_info("SNC setup done.\n");\r\nreturn 0;\r\nout_sysfs:\r\nfor (item = sony_nc_values; item->name; ++item) {\r\ndevice_remove_file(&sony_pf_device->dev, &item->devattr);\r\n}\r\nsony_nc_backlight_cleanup();\r\nsony_nc_function_cleanup(sony_pf_device);\r\nsony_nc_handles_cleanup(sony_pf_device);\r\noutplatform:\r\nsony_laptop_remove_input();\r\noutpresent:\r\nsony_pf_remove();\r\noutwalk:\r\nsony_nc_rfkill_cleanup();\r\nreturn result;\r\n}\r\nstatic int sony_nc_remove(struct acpi_device *device)\r\n{\r\nstruct sony_nc_value *item;\r\nsony_nc_backlight_cleanup();\r\nsony_nc_acpi_device = NULL;\r\nfor (item = sony_nc_values; item->name; ++item) {\r\ndevice_remove_file(&sony_pf_device->dev, &item->devattr);\r\n}\r\nsony_nc_function_cleanup(sony_pf_device);\r\nsony_nc_handles_cleanup(sony_pf_device);\r\nsony_pf_remove();\r\nsony_laptop_remove_input();\r\ndprintk(SONY_NC_DRIVER_NAME " removed.\n");\r\nreturn 0;\r\n}\r\nstatic u8 sony_pic_call1(u8 dev)\r\n{\r\nu8 v1, v2;\r\nwait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2,\r\nITERATIONS_LONG);\r\noutb(dev, spic_dev.cur_ioport->io1.minimum + 4);\r\nv1 = inb_p(spic_dev.cur_ioport->io1.minimum + 4);\r\nv2 = inb_p(spic_dev.cur_ioport->io1.minimum);\r\ndprintk("sony_pic_call1(0x%.2x): 0x%.4x\n", dev, (v2 << 8) | v1);\r\nreturn v2;\r\n}\r\nstatic u8 sony_pic_call2(u8 dev, u8 fn)\r\n{\r\nu8 v1;\r\nwait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2,\r\nITERATIONS_LONG);\r\noutb(dev, spic_dev.cur_ioport->io1.minimum + 4);\r\nwait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2,\r\nITERATIONS_LONG);\r\noutb(fn, spic_dev.cur_ioport->io1.minimum);\r\nv1 = inb_p(spic_dev.cur_ioport->io1.minimum);\r\ndprintk("sony_pic_call2(0x%.2x - 0x%.2x): 0x%.4x\n", dev, fn, v1);\r\nreturn v1;\r\n}\r\nstatic u8 sony_pic_call3(u8 dev, u8 fn, u8 v)\r\n{\r\nu8 v1;\r\nwait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2, ITERATIONS_LONG);\r\noutb(dev, spic_dev.cur_ioport->io1.minimum + 4);\r\nwait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2, ITERATIONS_LONG);\r\noutb(fn, spic_dev.cur_ioport->io1.minimum);\r\nwait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2, ITERATIONS_LONG);\r\noutb(v, spic_dev.cur_ioport->io1.minimum);\r\nv1 = inb_p(spic_dev.cur_ioport->io1.minimum);\r\ndprintk("sony_pic_call3(0x%.2x - 0x%.2x - 0x%.2x): 0x%.4x\n",\r\ndev, fn, v, v1);\r\nreturn v1;\r\n}\r\nstatic int type3_handle_irq(const u8 data_mask, const u8 ev)\r\n{\r\nif (data_mask == 0x31) {\r\nif (ev == 0x5c || ev == 0x5f)\r\nsony_pic_call1(0xA0);\r\nelse if (ev == 0x61)\r\nsony_pic_call1(0xB3);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void sony_pic_detect_device_type(struct sony_pic_dev *dev)\r\n{\r\nstruct pci_dev *pcidev;\r\npcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82371AB_3, NULL);\r\nif (pcidev) {\r\ndev->model = SONYPI_DEVICE_TYPE1;\r\ndev->evport_offset = SONYPI_TYPE1_OFFSET;\r\ndev->event_types = type1_events;\r\ngoto out;\r\n}\r\npcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_ICH6_1, NULL);\r\nif (pcidev) {\r\ndev->model = SONYPI_DEVICE_TYPE2;\r\ndev->evport_offset = SONYPI_TYPE2_OFFSET;\r\ndev->event_types = type2_events;\r\ngoto out;\r\n}\r\npcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_ICH7_1, NULL);\r\nif (pcidev) {\r\ndev->model = SONYPI_DEVICE_TYPE3;\r\ndev->handle_irq = type3_handle_irq;\r\ndev->evport_offset = SONYPI_TYPE3_OFFSET;\r\ndev->event_types = type3_events;\r\ngoto out;\r\n}\r\npcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_ICH8_4, NULL);\r\nif (pcidev) {\r\ndev->model = SONYPI_DEVICE_TYPE3;\r\ndev->handle_irq = type3_handle_irq;\r\ndev->evport_offset = SONYPI_TYPE3_OFFSET;\r\ndev->event_types = type3_events;\r\ngoto out;\r\n}\r\npcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_ICH9_1, NULL);\r\nif (pcidev) {\r\ndev->model = SONYPI_DEVICE_TYPE3;\r\ndev->handle_irq = type3_handle_irq;\r\ndev->evport_offset = SONYPI_TYPE3_OFFSET;\r\ndev->event_types = type3_events;\r\ngoto out;\r\n}\r\ndev->model = SONYPI_DEVICE_TYPE2;\r\ndev->evport_offset = SONYPI_TYPE2_OFFSET;\r\ndev->event_types = type2_events;\r\nout:\r\nif (pcidev)\r\npci_dev_put(pcidev);\r\npr_info("detected Type%d model\n",\r\ndev->model == SONYPI_DEVICE_TYPE1 ? 1 :\r\ndev->model == SONYPI_DEVICE_TYPE2 ? 2 : 3);\r\n}\r\nstatic int __sony_pic_camera_ready(void)\r\n{\r\nu8 v;\r\nv = sony_pic_call2(0x8f, SONYPI_CAMERA_STATUS);\r\nreturn (v != 0xff && (v & SONYPI_CAMERA_STATUS_READY));\r\n}\r\nstatic int __sony_pic_camera_off(void)\r\n{\r\nif (!camera) {\r\npr_warn("camera control not enabled\n");\r\nreturn -ENODEV;\r\n}\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_PICTURE,\r\nSONYPI_CAMERA_MUTE_MASK),\r\nITERATIONS_SHORT);\r\nif (spic_dev.camera_power) {\r\nsony_pic_call2(0x91, 0);\r\nspic_dev.camera_power = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __sony_pic_camera_on(void)\r\n{\r\nint i, j, x;\r\nif (!camera) {\r\npr_warn("camera control not enabled\n");\r\nreturn -ENODEV;\r\n}\r\nif (spic_dev.camera_power)\r\nreturn 0;\r\nfor (j = 5; j > 0; j--) {\r\nfor (x = 0; x < 100 && sony_pic_call2(0x91, 0x1); x++)\r\nmsleep(10);\r\nsony_pic_call1(0x93);\r\nfor (i = 400; i > 0; i--) {\r\nif (__sony_pic_camera_ready())\r\nbreak;\r\nmsleep(10);\r\n}\r\nif (i)\r\nbreak;\r\n}\r\nif (j == 0) {\r\npr_warn("failed to power on camera\n");\r\nreturn -ENODEV;\r\n}\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_CONTROL,\r\n0x5a),\r\nITERATIONS_SHORT);\r\nspic_dev.camera_power = 1;\r\nreturn 0;\r\n}\r\nint sony_pic_camera_command(int command, u8 value)\r\n{\r\nif (!camera)\r\nreturn -EIO;\r\nmutex_lock(&spic_dev.lock);\r\nswitch (command) {\r\ncase SONY_PIC_COMMAND_SETCAMERA:\r\nif (value)\r\n__sony_pic_camera_on();\r\nelse\r\n__sony_pic_camera_off();\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERABRIGHTNESS:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_BRIGHTNESS, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERACONTRAST:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_CONTRAST, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERAHUE:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_HUE, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERACOLOR:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_COLOR, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERASHARPNESS:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_SHARPNESS, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERAPICTURE:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_PICTURE, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ncase SONY_PIC_COMMAND_SETCAMERAAGC:\r\nwait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_AGC, value),\r\nITERATIONS_SHORT);\r\nbreak;\r\ndefault:\r\npr_err("sony_pic_camera_command invalid: %d\n", command);\r\nbreak;\r\n}\r\nmutex_unlock(&spic_dev.lock);\r\nreturn 0;\r\n}\r\nstatic void __sony_pic_set_wwanpower(u8 state)\r\n{\r\nstate = !!state;\r\nif (spic_dev.wwan_power == state)\r\nreturn;\r\nsony_pic_call2(0xB0, state);\r\nsony_pic_call1(0x82);\r\nspic_dev.wwan_power = state;\r\n}\r\nstatic ssize_t sony_pic_wwanpower_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoul(buffer, 10, &value))\r\nreturn -EINVAL;\r\nmutex_lock(&spic_dev.lock);\r\n__sony_pic_set_wwanpower(value);\r\nmutex_unlock(&spic_dev.lock);\r\nreturn count;\r\n}\r\nstatic ssize_t sony_pic_wwanpower_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nssize_t count;\r\nmutex_lock(&spic_dev.lock);\r\ncount = snprintf(buffer, PAGE_SIZE, "%d\n", spic_dev.wwan_power);\r\nmutex_unlock(&spic_dev.lock);\r\nreturn count;\r\n}\r\nstatic void __sony_pic_set_bluetoothpower(u8 state)\r\n{\r\nstate = !!state;\r\nif (spic_dev.bluetooth_power == state)\r\nreturn;\r\nsony_pic_call2(0x96, state);\r\nsony_pic_call1(0x82);\r\nspic_dev.bluetooth_power = state;\r\n}\r\nstatic ssize_t sony_pic_bluetoothpower_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoul(buffer, 10, &value))\r\nreturn -EINVAL;\r\nmutex_lock(&spic_dev.lock);\r\n__sony_pic_set_bluetoothpower(value);\r\nmutex_unlock(&spic_dev.lock);\r\nreturn count;\r\n}\r\nstatic ssize_t sony_pic_bluetoothpower_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nssize_t count = 0;\r\nmutex_lock(&spic_dev.lock);\r\ncount = snprintf(buffer, PAGE_SIZE, "%d\n", spic_dev.bluetooth_power);\r\nmutex_unlock(&spic_dev.lock);\r\nreturn count;\r\n}\r\nstatic int sony_pic_set_fanspeed(unsigned long value)\r\n{\r\nreturn ec_write(SONY_PIC_FAN0_STATUS, value);\r\n}\r\nstatic int sony_pic_get_fanspeed(u8 *value)\r\n{\r\nreturn ec_read(SONY_PIC_FAN0_STATUS, value);\r\n}\r\nstatic ssize_t sony_pic_fanspeed_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nunsigned long value;\r\nif (count > 31)\r\nreturn -EINVAL;\r\nif (kstrtoul(buffer, 10, &value))\r\nreturn -EINVAL;\r\nif (sony_pic_set_fanspeed(value))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t sony_pic_fanspeed_show(struct device *dev,\r\nstruct device_attribute *attr, char *buffer)\r\n{\r\nu8 value = 0;\r\nif (sony_pic_get_fanspeed(&value))\r\nreturn -EIO;\r\nreturn snprintf(buffer, PAGE_SIZE, "%d\n", value);\r\n}\r\nstatic int sonypi_misc_fasync(int fd, struct file *filp, int on)\r\n{\r\nreturn fasync_helper(fd, filp, on, &sonypi_compat.fifo_async);\r\n}\r\nstatic int sonypi_misc_release(struct inode *inode, struct file *file)\r\n{\r\natomic_dec(&sonypi_compat.open_count);\r\nreturn 0;\r\n}\r\nstatic int sonypi_misc_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sonypi_compat.fifo_lock, flags);\r\nif (atomic_inc_return(&sonypi_compat.open_count) == 1)\r\nkfifo_reset(&sonypi_compat.fifo);\r\nspin_unlock_irqrestore(&sonypi_compat.fifo_lock, flags);\r\nreturn 0;\r\n}\r\nstatic ssize_t sonypi_misc_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nssize_t ret;\r\nunsigned char c;\r\nif ((kfifo_len(&sonypi_compat.fifo) == 0) &&\r\n(file->f_flags & O_NONBLOCK))\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible(sonypi_compat.fifo_proc_list,\r\nkfifo_len(&sonypi_compat.fifo) != 0);\r\nif (ret)\r\nreturn ret;\r\nwhile (ret < count &&\r\n(kfifo_out_locked(&sonypi_compat.fifo, &c, sizeof(c),\r\n&sonypi_compat.fifo_lock) == sizeof(c))) {\r\nif (put_user(c, buf++))\r\nreturn -EFAULT;\r\nret++;\r\n}\r\nif (ret > 0) {\r\nstruct inode *inode = file_inode(file);\r\ninode->i_atime = current_fs_time(inode->i_sb);\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int sonypi_misc_poll(struct file *file, poll_table *wait)\r\n{\r\npoll_wait(file, &sonypi_compat.fifo_proc_list, wait);\r\nif (kfifo_len(&sonypi_compat.fifo))\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int ec_read16(u8 addr, u16 *value)\r\n{\r\nu8 val_lb, val_hb;\r\nif (ec_read(addr, &val_lb))\r\nreturn -1;\r\nif (ec_read(addr + 1, &val_hb))\r\nreturn -1;\r\n*value = val_lb | (val_hb << 8);\r\nreturn 0;\r\n}\r\nstatic long sonypi_misc_ioctl(struct file *fp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret = 0;\r\nvoid __user *argp = (void __user *)arg;\r\nu8 val8;\r\nu16 val16;\r\nint value;\r\nmutex_lock(&spic_dev.lock);\r\nswitch (cmd) {\r\ncase SONYPI_IOCGBRT:\r\nif (sony_bl_props.dev == NULL) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (sony_nc_int_call(sony_nc_acpi_handle, "GBRT", NULL,\r\n&value)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nval8 = ((value & 0xff) - 1) << 5;\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCSBRT:\r\nif (sony_bl_props.dev == NULL) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_from_user(&val8, argp, sizeof(val8))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nvalue = (val8 >> 5) + 1;\r\nif (sony_nc_int_call(sony_nc_acpi_handle, "SBRT", &value,\r\nNULL)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nsony_bl_props.dev->props.brightness =\r\nsony_backlight_get_brightness(sony_bl_props.dev);\r\nbreak;\r\ncase SONYPI_IOCGBAT1CAP:\r\nif (ec_read16(SONYPI_BAT1_FULL, &val16)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val16, sizeof(val16)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBAT1REM:\r\nif (ec_read16(SONYPI_BAT1_LEFT, &val16)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val16, sizeof(val16)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBAT2CAP:\r\nif (ec_read16(SONYPI_BAT2_FULL, &val16)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val16, sizeof(val16)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBAT2REM:\r\nif (ec_read16(SONYPI_BAT2_LEFT, &val16)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val16, sizeof(val16)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBATFLAGS:\r\nif (ec_read(SONYPI_BAT_FLAGS, &val8)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nval8 &= 0x07;\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCGBLUE:\r\nval8 = spic_dev.bluetooth_power;\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCSBLUE:\r\nif (copy_from_user(&val8, argp, sizeof(val8))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\n__sony_pic_set_bluetoothpower(val8);\r\nbreak;\r\ncase SONYPI_IOCGFAN:\r\nif (sony_pic_get_fanspeed(&val8)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ncase SONYPI_IOCSFAN:\r\nif (copy_from_user(&val8, argp, sizeof(val8))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (sony_pic_set_fanspeed(val8))\r\nret = -EIO;\r\nbreak;\r\ncase SONYPI_IOCGTEMP:\r\nif (ec_read(SONYPI_TEMP_STATUS, &val8)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &val8, sizeof(val8)))\r\nret = -EFAULT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&spic_dev.lock);\r\nreturn ret;\r\n}\r\nstatic void sonypi_compat_report_event(u8 event)\r\n{\r\nkfifo_in_locked(&sonypi_compat.fifo, (unsigned char *)&event,\r\nsizeof(event), &sonypi_compat.fifo_lock);\r\nkill_fasync(&sonypi_compat.fifo_async, SIGIO, POLL_IN);\r\nwake_up_interruptible(&sonypi_compat.fifo_proc_list);\r\n}\r\nstatic int sonypi_compat_init(void)\r\n{\r\nint error;\r\nspin_lock_init(&sonypi_compat.fifo_lock);\r\nerror =\r\nkfifo_alloc(&sonypi_compat.fifo, SONY_LAPTOP_BUF_SIZE, GFP_KERNEL);\r\nif (error) {\r\npr_err("kfifo_alloc failed\n");\r\nreturn error;\r\n}\r\ninit_waitqueue_head(&sonypi_compat.fifo_proc_list);\r\nif (minor != -1)\r\nsonypi_misc_device.minor = minor;\r\nerror = misc_register(&sonypi_misc_device);\r\nif (error) {\r\npr_err("misc_register failed\n");\r\ngoto err_free_kfifo;\r\n}\r\nif (minor == -1)\r\npr_info("device allocated minor is %d\n",\r\nsonypi_misc_device.minor);\r\nreturn 0;\r\nerr_free_kfifo:\r\nkfifo_free(&sonypi_compat.fifo);\r\nreturn error;\r\n}\r\nstatic void sonypi_compat_exit(void)\r\n{\r\nmisc_deregister(&sonypi_misc_device);\r\nkfifo_free(&sonypi_compat.fifo);\r\n}\r\nstatic int sonypi_compat_init(void) { return 0; }\r\nstatic void sonypi_compat_exit(void) { }\r\nstatic void sonypi_compat_report_event(u8 event) { }\r\nstatic acpi_status\r\nsony_pic_read_possible_resource(struct acpi_resource *resource, void *context)\r\n{\r\nu32 i;\r\nstruct sony_pic_dev *dev = (struct sony_pic_dev *)context;\r\nswitch (resource->type) {\r\ncase ACPI_RESOURCE_TYPE_START_DEPENDENT:\r\n{\r\nstruct sony_pic_ioport *ioport = kzalloc(sizeof(*ioport), GFP_KERNEL);\r\nif (!ioport)\r\nreturn AE_ERROR;\r\nlist_add(&ioport->list, &dev->ioports);\r\nreturn AE_OK;\r\n}\r\ncase ACPI_RESOURCE_TYPE_END_DEPENDENT:\r\nreturn AE_OK;\r\ncase ACPI_RESOURCE_TYPE_IRQ:\r\n{\r\nstruct acpi_resource_irq *p = &resource->data.irq;\r\nstruct sony_pic_irq *interrupt = NULL;\r\nif (!p || !p->interrupt_count) {\r\ndprintk("Blank IRQ resource\n");\r\nreturn AE_OK;\r\n}\r\nfor (i = 0; i < p->interrupt_count; i++) {\r\nif (!p->interrupts[i]) {\r\npr_warn("Invalid IRQ %d\n",\r\np->interrupts[i]);\r\ncontinue;\r\n}\r\ninterrupt = kzalloc(sizeof(*interrupt),\r\nGFP_KERNEL);\r\nif (!interrupt)\r\nreturn AE_ERROR;\r\nlist_add(&interrupt->list, &dev->interrupts);\r\ninterrupt->irq.triggering = p->triggering;\r\ninterrupt->irq.polarity = p->polarity;\r\ninterrupt->irq.sharable = p->sharable;\r\ninterrupt->irq.interrupt_count = 1;\r\ninterrupt->irq.interrupts[0] = p->interrupts[i];\r\n}\r\nreturn AE_OK;\r\n}\r\ncase ACPI_RESOURCE_TYPE_IO:\r\n{\r\nstruct acpi_resource_io *io = &resource->data.io;\r\nstruct sony_pic_ioport *ioport =\r\nlist_first_entry(&dev->ioports, struct sony_pic_ioport, list);\r\nif (!io) {\r\ndprintk("Blank IO resource\n");\r\nreturn AE_OK;\r\n}\r\nif (!ioport->io1.minimum) {\r\nmemcpy(&ioport->io1, io, sizeof(*io));\r\ndprintk("IO1 at 0x%.4x (0x%.2x)\n", ioport->io1.minimum,\r\nioport->io1.address_length);\r\n}\r\nelse if (!ioport->io2.minimum) {\r\nmemcpy(&ioport->io2, io, sizeof(*io));\r\ndprintk("IO2 at 0x%.4x (0x%.2x)\n", ioport->io2.minimum,\r\nioport->io2.address_length);\r\n}\r\nelse {\r\npr_err("Unknown SPIC Type, more than 2 IO Ports\n");\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\ndefault:\r\ndprintk("Resource %d isn't an IRQ nor an IO port\n",\r\nresource->type);\r\ncase ACPI_RESOURCE_TYPE_END_TAG:\r\nreturn AE_OK;\r\n}\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nstatic int sony_pic_possible_resources(struct acpi_device *device)\r\n{\r\nint result = 0;\r\nacpi_status status = AE_OK;\r\nif (!device)\r\nreturn -EINVAL;\r\ndprintk("Evaluating _STA\n");\r\nresult = acpi_bus_get_status(device);\r\nif (result) {\r\npr_warn("Unable to read status\n");\r\ngoto end;\r\n}\r\nif (!device->status.enabled)\r\ndprintk("Device disabled\n");\r\nelse\r\ndprintk("Device enabled\n");\r\ndprintk("Evaluating %s\n", METHOD_NAME__PRS);\r\nstatus = acpi_walk_resources(device->handle, METHOD_NAME__PRS,\r\nsony_pic_read_possible_resource, &spic_dev);\r\nif (ACPI_FAILURE(status)) {\r\npr_warn("Failure evaluating %s\n", METHOD_NAME__PRS);\r\nresult = -ENODEV;\r\n}\r\nend:\r\nreturn result;\r\n}\r\nstatic int sony_pic_disable(struct acpi_device *device)\r\n{\r\nacpi_status ret = acpi_evaluate_object(device->handle, "_DIS", NULL,\r\nNULL);\r\nif (ACPI_FAILURE(ret) && ret != AE_NOT_FOUND)\r\nreturn -ENXIO;\r\ndprintk("Device disabled\n");\r\nreturn 0;\r\n}\r\nstatic int sony_pic_enable(struct acpi_device *device,\r\nstruct sony_pic_ioport *ioport, struct sony_pic_irq *irq)\r\n{\r\nacpi_status status;\r\nint result = 0;\r\nstruct {\r\nstruct acpi_resource res1;\r\nstruct acpi_resource res2;\r\nstruct acpi_resource res3;\r\nstruct acpi_resource res4;\r\n} *resource;\r\nstruct acpi_buffer buffer = { 0, NULL };\r\nif (!ioport || !irq)\r\nreturn -EINVAL;\r\nresource = kzalloc(sizeof(*resource) + 1, GFP_KERNEL);\r\nif (!resource)\r\nreturn -ENOMEM;\r\nbuffer.length = sizeof(*resource) + 1;\r\nbuffer.pointer = resource;\r\nif (spic_dev.model == SONYPI_DEVICE_TYPE1) {\r\nresource->res1.type = ACPI_RESOURCE_TYPE_IO;\r\nresource->res1.length = sizeof(struct acpi_resource);\r\nmemcpy(&resource->res1.data.io, &ioport->io1,\r\nsizeof(struct acpi_resource_io));\r\nresource->res2.type = ACPI_RESOURCE_TYPE_IO;\r\nresource->res2.length = sizeof(struct acpi_resource);\r\nmemcpy(&resource->res2.data.io, &ioport->io2,\r\nsizeof(struct acpi_resource_io));\r\nresource->res3.type = ACPI_RESOURCE_TYPE_IRQ;\r\nresource->res3.length = sizeof(struct acpi_resource);\r\nmemcpy(&resource->res3.data.irq, &irq->irq,\r\nsizeof(struct acpi_resource_irq));\r\nresource->res3.data.irq.sharable = ACPI_SHARED;\r\nresource->res4.type = ACPI_RESOURCE_TYPE_END_TAG;\r\nresource->res4.length = sizeof(struct acpi_resource);\r\n}\r\nelse {\r\nresource->res1.type = ACPI_RESOURCE_TYPE_IO;\r\nresource->res1.length = sizeof(struct acpi_resource);\r\nmemcpy(&resource->res1.data.io, &ioport->io1,\r\nsizeof(struct acpi_resource_io));\r\nresource->res2.type = ACPI_RESOURCE_TYPE_IRQ;\r\nresource->res2.length = sizeof(struct acpi_resource);\r\nmemcpy(&resource->res2.data.irq, &irq->irq,\r\nsizeof(struct acpi_resource_irq));\r\nresource->res2.data.irq.sharable = ACPI_SHARED;\r\nresource->res3.type = ACPI_RESOURCE_TYPE_END_TAG;\r\nresource->res3.length = sizeof(struct acpi_resource);\r\n}\r\ndprintk("Evaluating _SRS\n");\r\nstatus = acpi_set_current_resources(device->handle, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("Error evaluating _SRS\n");\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\nsony_pic_call1(0x82);\r\nsony_pic_call2(0x81, 0xff);\r\nsony_pic_call1(compat ? 0x92 : 0x82);\r\nend:\r\nkfree(resource);\r\nreturn result;\r\n}\r\nstatic irqreturn_t sony_pic_irq(int irq, void *dev_id)\r\n{\r\nint i, j;\r\nu8 ev = 0;\r\nu8 data_mask = 0;\r\nu8 device_event = 0;\r\nstruct sony_pic_dev *dev = (struct sony_pic_dev *) dev_id;\r\nev = inb_p(dev->cur_ioport->io1.minimum);\r\nif (dev->cur_ioport->io2.minimum)\r\ndata_mask = inb_p(dev->cur_ioport->io2.minimum);\r\nelse\r\ndata_mask = inb_p(dev->cur_ioport->io1.minimum +\r\ndev->evport_offset);\r\ndprintk("event ([%.2x] [%.2x]) at port 0x%.4x(+0x%.2x)\n",\r\nev, data_mask, dev->cur_ioport->io1.minimum,\r\ndev->evport_offset);\r\nif (ev == 0x00 || ev == 0xff)\r\nreturn IRQ_HANDLED;\r\nfor (i = 0; dev->event_types[i].mask; i++) {\r\nif ((data_mask & dev->event_types[i].data) !=\r\ndev->event_types[i].data)\r\ncontinue;\r\nif (!(mask & dev->event_types[i].mask))\r\ncontinue;\r\nfor (j = 0; dev->event_types[i].events[j].event; j++) {\r\nif (ev == dev->event_types[i].events[j].data) {\r\ndevice_event =\r\ndev->event_types[i].events[j].event;\r\nif (!device_event)\r\nreturn IRQ_HANDLED;\r\ngoto found;\r\n}\r\n}\r\n}\r\nif (dev->handle_irq && dev->handle_irq(data_mask, ev) == 0)\r\nreturn IRQ_HANDLED;\r\ndprintk("unknown event ([%.2x] [%.2x]) at port 0x%.4x(+0x%.2x)\n",\r\nev, data_mask, dev->cur_ioport->io1.minimum,\r\ndev->evport_offset);\r\nreturn IRQ_HANDLED;\r\nfound:\r\nsony_laptop_report_input_event(device_event);\r\nsonypi_compat_report_event(device_event);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sony_pic_remove(struct acpi_device *device)\r\n{\r\nstruct sony_pic_ioport *io, *tmp_io;\r\nstruct sony_pic_irq *irq, *tmp_irq;\r\nif (sony_pic_disable(device)) {\r\npr_err("Couldn't disable device\n");\r\nreturn -ENXIO;\r\n}\r\nfree_irq(spic_dev.cur_irq->irq.interrupts[0], &spic_dev);\r\nrelease_region(spic_dev.cur_ioport->io1.minimum,\r\nspic_dev.cur_ioport->io1.address_length);\r\nif (spic_dev.cur_ioport->io2.minimum)\r\nrelease_region(spic_dev.cur_ioport->io2.minimum,\r\nspic_dev.cur_ioport->io2.address_length);\r\nsonypi_compat_exit();\r\nsony_laptop_remove_input();\r\nsysfs_remove_group(&sony_pf_device->dev.kobj, &spic_attribute_group);\r\nsony_pf_remove();\r\nlist_for_each_entry_safe(io, tmp_io, &spic_dev.ioports, list) {\r\nlist_del(&io->list);\r\nkfree(io);\r\n}\r\nlist_for_each_entry_safe(irq, tmp_irq, &spic_dev.interrupts, list) {\r\nlist_del(&irq->list);\r\nkfree(irq);\r\n}\r\nspic_dev.cur_ioport = NULL;\r\nspic_dev.cur_irq = NULL;\r\ndprintk(SONY_PIC_DRIVER_NAME " removed.\n");\r\nreturn 0;\r\n}\r\nstatic int sony_pic_add(struct acpi_device *device)\r\n{\r\nint result;\r\nstruct sony_pic_ioport *io, *tmp_io;\r\nstruct sony_pic_irq *irq, *tmp_irq;\r\nspic_dev.acpi_dev = device;\r\nstrcpy(acpi_device_class(device), "sony/hotkey");\r\nsony_pic_detect_device_type(&spic_dev);\r\nmutex_init(&spic_dev.lock);\r\nresult = sony_pic_possible_resources(device);\r\nif (result) {\r\npr_err("Unable to read possible resources\n");\r\ngoto err_free_resources;\r\n}\r\nresult = sony_laptop_setup_input(device);\r\nif (result) {\r\npr_err("Unable to create input devices\n");\r\ngoto err_free_resources;\r\n}\r\nresult = sonypi_compat_init();\r\nif (result)\r\ngoto err_remove_input;\r\nlist_for_each_entry_reverse(io, &spic_dev.ioports, list) {\r\nif (request_region(io->io1.minimum, io->io1.address_length,\r\n"Sony Programmable I/O Device")) {\r\ndprintk("I/O port1: 0x%.4x (0x%.4x) + 0x%.2x\n",\r\nio->io1.minimum, io->io1.maximum,\r\nio->io1.address_length);\r\nif (io->io2.minimum) {\r\nif (request_region(io->io2.minimum,\r\nio->io2.address_length,\r\n"Sony Programmable I/O Device")) {\r\ndprintk("I/O port2: 0x%.4x (0x%.4x) + 0x%.2x\n",\r\nio->io2.minimum, io->io2.maximum,\r\nio->io2.address_length);\r\nspic_dev.cur_ioport = io;\r\nbreak;\r\n}\r\nelse {\r\ndprintk("Unable to get I/O port2: "\r\n"0x%.4x (0x%.4x) + 0x%.2x\n",\r\nio->io2.minimum, io->io2.maximum,\r\nio->io2.address_length);\r\nrelease_region(io->io1.minimum,\r\nio->io1.address_length);\r\n}\r\n}\r\nelse {\r\nspic_dev.cur_ioport = io;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!spic_dev.cur_ioport) {\r\npr_err("Failed to request_region\n");\r\nresult = -ENODEV;\r\ngoto err_remove_compat;\r\n}\r\nlist_for_each_entry_reverse(irq, &spic_dev.interrupts, list) {\r\nif (!request_irq(irq->irq.interrupts[0], sony_pic_irq,\r\n0, "sony-laptop", &spic_dev)) {\r\ndprintk("IRQ: %d - triggering: %d - "\r\n"polarity: %d - shr: %d\n",\r\nirq->irq.interrupts[0],\r\nirq->irq.triggering,\r\nirq->irq.polarity,\r\nirq->irq.sharable);\r\nspic_dev.cur_irq = irq;\r\nbreak;\r\n}\r\n}\r\nif (!spic_dev.cur_irq) {\r\npr_err("Failed to request_irq\n");\r\nresult = -ENODEV;\r\ngoto err_release_region;\r\n}\r\nresult = sony_pic_enable(device, spic_dev.cur_ioport, spic_dev.cur_irq);\r\nif (result) {\r\npr_err("Couldn't enable device\n");\r\ngoto err_free_irq;\r\n}\r\nspic_dev.bluetooth_power = -1;\r\nresult = sony_pf_add();\r\nif (result)\r\ngoto err_disable_device;\r\nresult = sysfs_create_group(&sony_pf_device->dev.kobj, &spic_attribute_group);\r\nif (result)\r\ngoto err_remove_pf;\r\npr_info("SPIC setup done.\n");\r\nreturn 0;\r\nerr_remove_pf:\r\nsony_pf_remove();\r\nerr_disable_device:\r\nsony_pic_disable(device);\r\nerr_free_irq:\r\nfree_irq(spic_dev.cur_irq->irq.interrupts[0], &spic_dev);\r\nerr_release_region:\r\nrelease_region(spic_dev.cur_ioport->io1.minimum,\r\nspic_dev.cur_ioport->io1.address_length);\r\nif (spic_dev.cur_ioport->io2.minimum)\r\nrelease_region(spic_dev.cur_ioport->io2.minimum,\r\nspic_dev.cur_ioport->io2.address_length);\r\nerr_remove_compat:\r\nsonypi_compat_exit();\r\nerr_remove_input:\r\nsony_laptop_remove_input();\r\nerr_free_resources:\r\nlist_for_each_entry_safe(io, tmp_io, &spic_dev.ioports, list) {\r\nlist_del(&io->list);\r\nkfree(io);\r\n}\r\nlist_for_each_entry_safe(irq, tmp_irq, &spic_dev.interrupts, list) {\r\nlist_del(&irq->list);\r\nkfree(irq);\r\n}\r\nspic_dev.cur_ioport = NULL;\r\nspic_dev.cur_irq = NULL;\r\nreturn result;\r\n}\r\nstatic int sony_pic_suspend(struct device *dev)\r\n{\r\nif (sony_pic_disable(to_acpi_device(dev)))\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nstatic int sony_pic_resume(struct device *dev)\r\n{\r\nsony_pic_enable(to_acpi_device(dev),\r\nspic_dev.cur_ioport, spic_dev.cur_irq);\r\nreturn 0;\r\n}\r\nstatic int __init sony_laptop_init(void)\r\n{\r\nint result;\r\nif (!no_spic && dmi_check_system(sonypi_dmi_table)) {\r\nresult = acpi_bus_register_driver(&sony_pic_driver);\r\nif (result) {\r\npr_err("Unable to register SPIC driver\n");\r\ngoto out;\r\n}\r\nspic_drv_registered = 1;\r\n}\r\nresult = acpi_bus_register_driver(&sony_nc_driver);\r\nif (result) {\r\npr_err("Unable to register SNC driver\n");\r\ngoto out_unregister_pic;\r\n}\r\nreturn 0;\r\nout_unregister_pic:\r\nif (spic_drv_registered)\r\nacpi_bus_unregister_driver(&sony_pic_driver);\r\nout:\r\nreturn result;\r\n}\r\nstatic void __exit sony_laptop_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&sony_nc_driver);\r\nif (spic_drv_registered)\r\nacpi_bus_unregister_driver(&sony_pic_driver);\r\n}
