static bool wm8962_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8962_CLOCKING1:\r\ncase WM8962_CLOCKING2:\r\ncase WM8962_SOFTWARE_RESET:\r\ncase WM8962_ALC2:\r\ncase WM8962_THERMAL_SHUTDOWN_STATUS:\r\ncase WM8962_ADDITIONAL_CONTROL_4:\r\ncase WM8962_CLASS_D_CONTROL_1:\r\ncase WM8962_DC_SERVO_6:\r\ncase WM8962_INTERRUPT_STATUS_1:\r\ncase WM8962_INTERRUPT_STATUS_2:\r\ncase WM8962_DSP2_EXECCONTROL:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool wm8962_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8962_LEFT_INPUT_VOLUME:\r\ncase WM8962_RIGHT_INPUT_VOLUME:\r\ncase WM8962_HPOUTL_VOLUME:\r\ncase WM8962_HPOUTR_VOLUME:\r\ncase WM8962_CLOCKING1:\r\ncase WM8962_ADC_DAC_CONTROL_1:\r\ncase WM8962_ADC_DAC_CONTROL_2:\r\ncase WM8962_AUDIO_INTERFACE_0:\r\ncase WM8962_CLOCKING2:\r\ncase WM8962_AUDIO_INTERFACE_1:\r\ncase WM8962_LEFT_DAC_VOLUME:\r\ncase WM8962_RIGHT_DAC_VOLUME:\r\ncase WM8962_AUDIO_INTERFACE_2:\r\ncase WM8962_SOFTWARE_RESET:\r\ncase WM8962_ALC1:\r\ncase WM8962_ALC2:\r\ncase WM8962_ALC3:\r\ncase WM8962_NOISE_GATE:\r\ncase WM8962_LEFT_ADC_VOLUME:\r\ncase WM8962_RIGHT_ADC_VOLUME:\r\ncase WM8962_ADDITIONAL_CONTROL_1:\r\ncase WM8962_ADDITIONAL_CONTROL_2:\r\ncase WM8962_PWR_MGMT_1:\r\ncase WM8962_PWR_MGMT_2:\r\ncase WM8962_ADDITIONAL_CONTROL_3:\r\ncase WM8962_ANTI_POP:\r\ncase WM8962_CLOCKING_3:\r\ncase WM8962_INPUT_MIXER_CONTROL_1:\r\ncase WM8962_LEFT_INPUT_MIXER_VOLUME:\r\ncase WM8962_RIGHT_INPUT_MIXER_VOLUME:\r\ncase WM8962_INPUT_MIXER_CONTROL_2:\r\ncase WM8962_INPUT_BIAS_CONTROL:\r\ncase WM8962_LEFT_INPUT_PGA_CONTROL:\r\ncase WM8962_RIGHT_INPUT_PGA_CONTROL:\r\ncase WM8962_SPKOUTL_VOLUME:\r\ncase WM8962_SPKOUTR_VOLUME:\r\ncase WM8962_THERMAL_SHUTDOWN_STATUS:\r\ncase WM8962_ADDITIONAL_CONTROL_4:\r\ncase WM8962_CLASS_D_CONTROL_1:\r\ncase WM8962_CLASS_D_CONTROL_2:\r\ncase WM8962_CLOCKING_4:\r\ncase WM8962_DAC_DSP_MIXING_1:\r\ncase WM8962_DAC_DSP_MIXING_2:\r\ncase WM8962_DC_SERVO_0:\r\ncase WM8962_DC_SERVO_1:\r\ncase WM8962_DC_SERVO_4:\r\ncase WM8962_DC_SERVO_6:\r\ncase WM8962_ANALOGUE_PGA_BIAS:\r\ncase WM8962_ANALOGUE_HP_0:\r\ncase WM8962_ANALOGUE_HP_2:\r\ncase WM8962_CHARGE_PUMP_1:\r\ncase WM8962_CHARGE_PUMP_B:\r\ncase WM8962_WRITE_SEQUENCER_CONTROL_1:\r\ncase WM8962_WRITE_SEQUENCER_CONTROL_2:\r\ncase WM8962_WRITE_SEQUENCER_CONTROL_3:\r\ncase WM8962_CONTROL_INTERFACE:\r\ncase WM8962_MIXER_ENABLES:\r\ncase WM8962_HEADPHONE_MIXER_1:\r\ncase WM8962_HEADPHONE_MIXER_2:\r\ncase WM8962_HEADPHONE_MIXER_3:\r\ncase WM8962_HEADPHONE_MIXER_4:\r\ncase WM8962_SPEAKER_MIXER_1:\r\ncase WM8962_SPEAKER_MIXER_2:\r\ncase WM8962_SPEAKER_MIXER_3:\r\ncase WM8962_SPEAKER_MIXER_4:\r\ncase WM8962_SPEAKER_MIXER_5:\r\ncase WM8962_BEEP_GENERATOR_1:\r\ncase WM8962_OSCILLATOR_TRIM_3:\r\ncase WM8962_OSCILLATOR_TRIM_4:\r\ncase WM8962_OSCILLATOR_TRIM_7:\r\ncase WM8962_ANALOGUE_CLOCKING1:\r\ncase WM8962_ANALOGUE_CLOCKING2:\r\ncase WM8962_ANALOGUE_CLOCKING3:\r\ncase WM8962_PLL_SOFTWARE_RESET:\r\ncase WM8962_PLL2:\r\ncase WM8962_PLL_4:\r\ncase WM8962_PLL_9:\r\ncase WM8962_PLL_10:\r\ncase WM8962_PLL_11:\r\ncase WM8962_PLL_12:\r\ncase WM8962_PLL_13:\r\ncase WM8962_PLL_14:\r\ncase WM8962_PLL_15:\r\ncase WM8962_PLL_16:\r\ncase WM8962_FLL_CONTROL_1:\r\ncase WM8962_FLL_CONTROL_2:\r\ncase WM8962_FLL_CONTROL_3:\r\ncase WM8962_FLL_CONTROL_5:\r\ncase WM8962_FLL_CONTROL_6:\r\ncase WM8962_FLL_CONTROL_7:\r\ncase WM8962_FLL_CONTROL_8:\r\ncase WM8962_GENERAL_TEST_1:\r\ncase WM8962_DF1:\r\ncase WM8962_DF2:\r\ncase WM8962_DF3:\r\ncase WM8962_DF4:\r\ncase WM8962_DF5:\r\ncase WM8962_DF6:\r\ncase WM8962_DF7:\r\ncase WM8962_LHPF1:\r\ncase WM8962_LHPF2:\r\ncase WM8962_THREED1:\r\ncase WM8962_THREED2:\r\ncase WM8962_THREED3:\r\ncase WM8962_THREED4:\r\ncase WM8962_DRC_1:\r\ncase WM8962_DRC_2:\r\ncase WM8962_DRC_3:\r\ncase WM8962_DRC_4:\r\ncase WM8962_DRC_5:\r\ncase WM8962_TLOOPBACK:\r\ncase WM8962_EQ1:\r\ncase WM8962_EQ2:\r\ncase WM8962_EQ3:\r\ncase WM8962_EQ4:\r\ncase WM8962_EQ5:\r\ncase WM8962_EQ6:\r\ncase WM8962_EQ7:\r\ncase WM8962_EQ8:\r\ncase WM8962_EQ9:\r\ncase WM8962_EQ10:\r\ncase WM8962_EQ11:\r\ncase WM8962_EQ12:\r\ncase WM8962_EQ13:\r\ncase WM8962_EQ14:\r\ncase WM8962_EQ15:\r\ncase WM8962_EQ16:\r\ncase WM8962_EQ17:\r\ncase WM8962_EQ18:\r\ncase WM8962_EQ19:\r\ncase WM8962_EQ20:\r\ncase WM8962_EQ21:\r\ncase WM8962_EQ22:\r\ncase WM8962_EQ23:\r\ncase WM8962_EQ24:\r\ncase WM8962_EQ25:\r\ncase WM8962_EQ26:\r\ncase WM8962_EQ27:\r\ncase WM8962_EQ28:\r\ncase WM8962_EQ29:\r\ncase WM8962_EQ30:\r\ncase WM8962_EQ31:\r\ncase WM8962_EQ32:\r\ncase WM8962_EQ33:\r\ncase WM8962_EQ34:\r\ncase WM8962_EQ35:\r\ncase WM8962_EQ36:\r\ncase WM8962_EQ37:\r\ncase WM8962_EQ38:\r\ncase WM8962_EQ39:\r\ncase WM8962_EQ40:\r\ncase WM8962_EQ41:\r\ncase WM8962_GPIO_BASE:\r\ncase WM8962_GPIO_2:\r\ncase WM8962_GPIO_3:\r\ncase WM8962_GPIO_5:\r\ncase WM8962_GPIO_6:\r\ncase WM8962_INTERRUPT_STATUS_1:\r\ncase WM8962_INTERRUPT_STATUS_2:\r\ncase WM8962_INTERRUPT_STATUS_1_MASK:\r\ncase WM8962_INTERRUPT_STATUS_2_MASK:\r\ncase WM8962_INTERRUPT_CONTROL:\r\ncase WM8962_IRQ_DEBOUNCE:\r\ncase WM8962_MICINT_SOURCE_POL:\r\ncase WM8962_DSP2_POWER_MANAGEMENT:\r\ncase WM8962_DSP2_EXECCONTROL:\r\ncase WM8962_DSP2_INSTRUCTION_RAM_0:\r\ncase WM8962_DSP2_ADDRESS_RAM_2:\r\ncase WM8962_DSP2_ADDRESS_RAM_1:\r\ncase WM8962_DSP2_ADDRESS_RAM_0:\r\ncase WM8962_DSP2_DATA1_RAM_1:\r\ncase WM8962_DSP2_DATA1_RAM_0:\r\ncase WM8962_DSP2_DATA2_RAM_1:\r\ncase WM8962_DSP2_DATA2_RAM_0:\r\ncase WM8962_DSP2_DATA3_RAM_1:\r\ncase WM8962_DSP2_DATA3_RAM_0:\r\ncase WM8962_DSP2_COEFF_RAM_0:\r\ncase WM8962_RETUNEADC_SHARED_COEFF_1:\r\ncase WM8962_RETUNEADC_SHARED_COEFF_0:\r\ncase WM8962_RETUNEDAC_SHARED_COEFF_1:\r\ncase WM8962_RETUNEDAC_SHARED_COEFF_0:\r\ncase WM8962_SOUNDSTAGE_ENABLES_1:\r\ncase WM8962_SOUNDSTAGE_ENABLES_0:\r\ncase WM8962_HDBASS_AI_1:\r\ncase WM8962_HDBASS_AI_0:\r\ncase WM8962_HDBASS_AR_1:\r\ncase WM8962_HDBASS_AR_0:\r\ncase WM8962_HDBASS_B_1:\r\ncase WM8962_HDBASS_B_0:\r\ncase WM8962_HDBASS_K_1:\r\ncase WM8962_HDBASS_K_0:\r\ncase WM8962_HDBASS_N1_1:\r\ncase WM8962_HDBASS_N1_0:\r\ncase WM8962_HDBASS_N2_1:\r\ncase WM8962_HDBASS_N2_0:\r\ncase WM8962_HDBASS_N3_1:\r\ncase WM8962_HDBASS_N3_0:\r\ncase WM8962_HDBASS_N4_1:\r\ncase WM8962_HDBASS_N4_0:\r\ncase WM8962_HDBASS_N5_1:\r\ncase WM8962_HDBASS_N5_0:\r\ncase WM8962_HDBASS_X1_1:\r\ncase WM8962_HDBASS_X1_0:\r\ncase WM8962_HDBASS_X2_1:\r\ncase WM8962_HDBASS_X2_0:\r\ncase WM8962_HDBASS_X3_1:\r\ncase WM8962_HDBASS_X3_0:\r\ncase WM8962_HDBASS_ATK_1:\r\ncase WM8962_HDBASS_ATK_0:\r\ncase WM8962_HDBASS_DCY_1:\r\ncase WM8962_HDBASS_DCY_0:\r\ncase WM8962_HDBASS_PG_1:\r\ncase WM8962_HDBASS_PG_0:\r\ncase WM8962_HPF_C_1:\r\ncase WM8962_HPF_C_0:\r\ncase WM8962_ADCL_RETUNE_C1_1:\r\ncase WM8962_ADCL_RETUNE_C1_0:\r\ncase WM8962_ADCL_RETUNE_C2_1:\r\ncase WM8962_ADCL_RETUNE_C2_0:\r\ncase WM8962_ADCL_RETUNE_C3_1:\r\ncase WM8962_ADCL_RETUNE_C3_0:\r\ncase WM8962_ADCL_RETUNE_C4_1:\r\ncase WM8962_ADCL_RETUNE_C4_0:\r\ncase WM8962_ADCL_RETUNE_C5_1:\r\ncase WM8962_ADCL_RETUNE_C5_0:\r\ncase WM8962_ADCL_RETUNE_C6_1:\r\ncase WM8962_ADCL_RETUNE_C6_0:\r\ncase WM8962_ADCL_RETUNE_C7_1:\r\ncase WM8962_ADCL_RETUNE_C7_0:\r\ncase WM8962_ADCL_RETUNE_C8_1:\r\ncase WM8962_ADCL_RETUNE_C8_0:\r\ncase WM8962_ADCL_RETUNE_C9_1:\r\ncase WM8962_ADCL_RETUNE_C9_0:\r\ncase WM8962_ADCL_RETUNE_C10_1:\r\ncase WM8962_ADCL_RETUNE_C10_0:\r\ncase WM8962_ADCL_RETUNE_C11_1:\r\ncase WM8962_ADCL_RETUNE_C11_0:\r\ncase WM8962_ADCL_RETUNE_C12_1:\r\ncase WM8962_ADCL_RETUNE_C12_0:\r\ncase WM8962_ADCL_RETUNE_C13_1:\r\ncase WM8962_ADCL_RETUNE_C13_0:\r\ncase WM8962_ADCL_RETUNE_C14_1:\r\ncase WM8962_ADCL_RETUNE_C14_0:\r\ncase WM8962_ADCL_RETUNE_C15_1:\r\ncase WM8962_ADCL_RETUNE_C15_0:\r\ncase WM8962_ADCL_RETUNE_C16_1:\r\ncase WM8962_ADCL_RETUNE_C16_0:\r\ncase WM8962_ADCL_RETUNE_C17_1:\r\ncase WM8962_ADCL_RETUNE_C17_0:\r\ncase WM8962_ADCL_RETUNE_C18_1:\r\ncase WM8962_ADCL_RETUNE_C18_0:\r\ncase WM8962_ADCL_RETUNE_C19_1:\r\ncase WM8962_ADCL_RETUNE_C19_0:\r\ncase WM8962_ADCL_RETUNE_C20_1:\r\ncase WM8962_ADCL_RETUNE_C20_0:\r\ncase WM8962_ADCL_RETUNE_C21_1:\r\ncase WM8962_ADCL_RETUNE_C21_0:\r\ncase WM8962_ADCL_RETUNE_C22_1:\r\ncase WM8962_ADCL_RETUNE_C22_0:\r\ncase WM8962_ADCL_RETUNE_C23_1:\r\ncase WM8962_ADCL_RETUNE_C23_0:\r\ncase WM8962_ADCL_RETUNE_C24_1:\r\ncase WM8962_ADCL_RETUNE_C24_0:\r\ncase WM8962_ADCL_RETUNE_C25_1:\r\ncase WM8962_ADCL_RETUNE_C25_0:\r\ncase WM8962_ADCL_RETUNE_C26_1:\r\ncase WM8962_ADCL_RETUNE_C26_0:\r\ncase WM8962_ADCL_RETUNE_C27_1:\r\ncase WM8962_ADCL_RETUNE_C27_0:\r\ncase WM8962_ADCL_RETUNE_C28_1:\r\ncase WM8962_ADCL_RETUNE_C28_0:\r\ncase WM8962_ADCL_RETUNE_C29_1:\r\ncase WM8962_ADCL_RETUNE_C29_0:\r\ncase WM8962_ADCL_RETUNE_C30_1:\r\ncase WM8962_ADCL_RETUNE_C30_0:\r\ncase WM8962_ADCL_RETUNE_C31_1:\r\ncase WM8962_ADCL_RETUNE_C31_0:\r\ncase WM8962_ADCL_RETUNE_C32_1:\r\ncase WM8962_ADCL_RETUNE_C32_0:\r\ncase WM8962_RETUNEADC_PG2_1:\r\ncase WM8962_RETUNEADC_PG2_0:\r\ncase WM8962_RETUNEADC_PG_1:\r\ncase WM8962_RETUNEADC_PG_0:\r\ncase WM8962_ADCR_RETUNE_C1_1:\r\ncase WM8962_ADCR_RETUNE_C1_0:\r\ncase WM8962_ADCR_RETUNE_C2_1:\r\ncase WM8962_ADCR_RETUNE_C2_0:\r\ncase WM8962_ADCR_RETUNE_C3_1:\r\ncase WM8962_ADCR_RETUNE_C3_0:\r\ncase WM8962_ADCR_RETUNE_C4_1:\r\ncase WM8962_ADCR_RETUNE_C4_0:\r\ncase WM8962_ADCR_RETUNE_C5_1:\r\ncase WM8962_ADCR_RETUNE_C5_0:\r\ncase WM8962_ADCR_RETUNE_C6_1:\r\ncase WM8962_ADCR_RETUNE_C6_0:\r\ncase WM8962_ADCR_RETUNE_C7_1:\r\ncase WM8962_ADCR_RETUNE_C7_0:\r\ncase WM8962_ADCR_RETUNE_C8_1:\r\ncase WM8962_ADCR_RETUNE_C8_0:\r\ncase WM8962_ADCR_RETUNE_C9_1:\r\ncase WM8962_ADCR_RETUNE_C9_0:\r\ncase WM8962_ADCR_RETUNE_C10_1:\r\ncase WM8962_ADCR_RETUNE_C10_0:\r\ncase WM8962_ADCR_RETUNE_C11_1:\r\ncase WM8962_ADCR_RETUNE_C11_0:\r\ncase WM8962_ADCR_RETUNE_C12_1:\r\ncase WM8962_ADCR_RETUNE_C12_0:\r\ncase WM8962_ADCR_RETUNE_C13_1:\r\ncase WM8962_ADCR_RETUNE_C13_0:\r\ncase WM8962_ADCR_RETUNE_C14_1:\r\ncase WM8962_ADCR_RETUNE_C14_0:\r\ncase WM8962_ADCR_RETUNE_C15_1:\r\ncase WM8962_ADCR_RETUNE_C15_0:\r\ncase WM8962_ADCR_RETUNE_C16_1:\r\ncase WM8962_ADCR_RETUNE_C16_0:\r\ncase WM8962_ADCR_RETUNE_C17_1:\r\ncase WM8962_ADCR_RETUNE_C17_0:\r\ncase WM8962_ADCR_RETUNE_C18_1:\r\ncase WM8962_ADCR_RETUNE_C18_0:\r\ncase WM8962_ADCR_RETUNE_C19_1:\r\ncase WM8962_ADCR_RETUNE_C19_0:\r\ncase WM8962_ADCR_RETUNE_C20_1:\r\ncase WM8962_ADCR_RETUNE_C20_0:\r\ncase WM8962_ADCR_RETUNE_C21_1:\r\ncase WM8962_ADCR_RETUNE_C21_0:\r\ncase WM8962_ADCR_RETUNE_C22_1:\r\ncase WM8962_ADCR_RETUNE_C22_0:\r\ncase WM8962_ADCR_RETUNE_C23_1:\r\ncase WM8962_ADCR_RETUNE_C23_0:\r\ncase WM8962_ADCR_RETUNE_C24_1:\r\ncase WM8962_ADCR_RETUNE_C24_0:\r\ncase WM8962_ADCR_RETUNE_C25_1:\r\ncase WM8962_ADCR_RETUNE_C25_0:\r\ncase WM8962_ADCR_RETUNE_C26_1:\r\ncase WM8962_ADCR_RETUNE_C26_0:\r\ncase WM8962_ADCR_RETUNE_C27_1:\r\ncase WM8962_ADCR_RETUNE_C27_0:\r\ncase WM8962_ADCR_RETUNE_C28_1:\r\ncase WM8962_ADCR_RETUNE_C28_0:\r\ncase WM8962_ADCR_RETUNE_C29_1:\r\ncase WM8962_ADCR_RETUNE_C29_0:\r\ncase WM8962_ADCR_RETUNE_C30_1:\r\ncase WM8962_ADCR_RETUNE_C30_0:\r\ncase WM8962_ADCR_RETUNE_C31_1:\r\ncase WM8962_ADCR_RETUNE_C31_0:\r\ncase WM8962_ADCR_RETUNE_C32_1:\r\ncase WM8962_ADCR_RETUNE_C32_0:\r\ncase WM8962_DACL_RETUNE_C1_1:\r\ncase WM8962_DACL_RETUNE_C1_0:\r\ncase WM8962_DACL_RETUNE_C2_1:\r\ncase WM8962_DACL_RETUNE_C2_0:\r\ncase WM8962_DACL_RETUNE_C3_1:\r\ncase WM8962_DACL_RETUNE_C3_0:\r\ncase WM8962_DACL_RETUNE_C4_1:\r\ncase WM8962_DACL_RETUNE_C4_0:\r\ncase WM8962_DACL_RETUNE_C5_1:\r\ncase WM8962_DACL_RETUNE_C5_0:\r\ncase WM8962_DACL_RETUNE_C6_1:\r\ncase WM8962_DACL_RETUNE_C6_0:\r\ncase WM8962_DACL_RETUNE_C7_1:\r\ncase WM8962_DACL_RETUNE_C7_0:\r\ncase WM8962_DACL_RETUNE_C8_1:\r\ncase WM8962_DACL_RETUNE_C8_0:\r\ncase WM8962_DACL_RETUNE_C9_1:\r\ncase WM8962_DACL_RETUNE_C9_0:\r\ncase WM8962_DACL_RETUNE_C10_1:\r\ncase WM8962_DACL_RETUNE_C10_0:\r\ncase WM8962_DACL_RETUNE_C11_1:\r\ncase WM8962_DACL_RETUNE_C11_0:\r\ncase WM8962_DACL_RETUNE_C12_1:\r\ncase WM8962_DACL_RETUNE_C12_0:\r\ncase WM8962_DACL_RETUNE_C13_1:\r\ncase WM8962_DACL_RETUNE_C13_0:\r\ncase WM8962_DACL_RETUNE_C14_1:\r\ncase WM8962_DACL_RETUNE_C14_0:\r\ncase WM8962_DACL_RETUNE_C15_1:\r\ncase WM8962_DACL_RETUNE_C15_0:\r\ncase WM8962_DACL_RETUNE_C16_1:\r\ncase WM8962_DACL_RETUNE_C16_0:\r\ncase WM8962_DACL_RETUNE_C17_1:\r\ncase WM8962_DACL_RETUNE_C17_0:\r\ncase WM8962_DACL_RETUNE_C18_1:\r\ncase WM8962_DACL_RETUNE_C18_0:\r\ncase WM8962_DACL_RETUNE_C19_1:\r\ncase WM8962_DACL_RETUNE_C19_0:\r\ncase WM8962_DACL_RETUNE_C20_1:\r\ncase WM8962_DACL_RETUNE_C20_0:\r\ncase WM8962_DACL_RETUNE_C21_1:\r\ncase WM8962_DACL_RETUNE_C21_0:\r\ncase WM8962_DACL_RETUNE_C22_1:\r\ncase WM8962_DACL_RETUNE_C22_0:\r\ncase WM8962_DACL_RETUNE_C23_1:\r\ncase WM8962_DACL_RETUNE_C23_0:\r\ncase WM8962_DACL_RETUNE_C24_1:\r\ncase WM8962_DACL_RETUNE_C24_0:\r\ncase WM8962_DACL_RETUNE_C25_1:\r\ncase WM8962_DACL_RETUNE_C25_0:\r\ncase WM8962_DACL_RETUNE_C26_1:\r\ncase WM8962_DACL_RETUNE_C26_0:\r\ncase WM8962_DACL_RETUNE_C27_1:\r\ncase WM8962_DACL_RETUNE_C27_0:\r\ncase WM8962_DACL_RETUNE_C28_1:\r\ncase WM8962_DACL_RETUNE_C28_0:\r\ncase WM8962_DACL_RETUNE_C29_1:\r\ncase WM8962_DACL_RETUNE_C29_0:\r\ncase WM8962_DACL_RETUNE_C30_1:\r\ncase WM8962_DACL_RETUNE_C30_0:\r\ncase WM8962_DACL_RETUNE_C31_1:\r\ncase WM8962_DACL_RETUNE_C31_0:\r\ncase WM8962_DACL_RETUNE_C32_1:\r\ncase WM8962_DACL_RETUNE_C32_0:\r\ncase WM8962_RETUNEDAC_PG2_1:\r\ncase WM8962_RETUNEDAC_PG2_0:\r\ncase WM8962_RETUNEDAC_PG_1:\r\ncase WM8962_RETUNEDAC_PG_0:\r\ncase WM8962_DACR_RETUNE_C1_1:\r\ncase WM8962_DACR_RETUNE_C1_0:\r\ncase WM8962_DACR_RETUNE_C2_1:\r\ncase WM8962_DACR_RETUNE_C2_0:\r\ncase WM8962_DACR_RETUNE_C3_1:\r\ncase WM8962_DACR_RETUNE_C3_0:\r\ncase WM8962_DACR_RETUNE_C4_1:\r\ncase WM8962_DACR_RETUNE_C4_0:\r\ncase WM8962_DACR_RETUNE_C5_1:\r\ncase WM8962_DACR_RETUNE_C5_0:\r\ncase WM8962_DACR_RETUNE_C6_1:\r\ncase WM8962_DACR_RETUNE_C6_0:\r\ncase WM8962_DACR_RETUNE_C7_1:\r\ncase WM8962_DACR_RETUNE_C7_0:\r\ncase WM8962_DACR_RETUNE_C8_1:\r\ncase WM8962_DACR_RETUNE_C8_0:\r\ncase WM8962_DACR_RETUNE_C9_1:\r\ncase WM8962_DACR_RETUNE_C9_0:\r\ncase WM8962_DACR_RETUNE_C10_1:\r\ncase WM8962_DACR_RETUNE_C10_0:\r\ncase WM8962_DACR_RETUNE_C11_1:\r\ncase WM8962_DACR_RETUNE_C11_0:\r\ncase WM8962_DACR_RETUNE_C12_1:\r\ncase WM8962_DACR_RETUNE_C12_0:\r\ncase WM8962_DACR_RETUNE_C13_1:\r\ncase WM8962_DACR_RETUNE_C13_0:\r\ncase WM8962_DACR_RETUNE_C14_1:\r\ncase WM8962_DACR_RETUNE_C14_0:\r\ncase WM8962_DACR_RETUNE_C15_1:\r\ncase WM8962_DACR_RETUNE_C15_0:\r\ncase WM8962_DACR_RETUNE_C16_1:\r\ncase WM8962_DACR_RETUNE_C16_0:\r\ncase WM8962_DACR_RETUNE_C17_1:\r\ncase WM8962_DACR_RETUNE_C17_0:\r\ncase WM8962_DACR_RETUNE_C18_1:\r\ncase WM8962_DACR_RETUNE_C18_0:\r\ncase WM8962_DACR_RETUNE_C19_1:\r\ncase WM8962_DACR_RETUNE_C19_0:\r\ncase WM8962_DACR_RETUNE_C20_1:\r\ncase WM8962_DACR_RETUNE_C20_0:\r\ncase WM8962_DACR_RETUNE_C21_1:\r\ncase WM8962_DACR_RETUNE_C21_0:\r\ncase WM8962_DACR_RETUNE_C22_1:\r\ncase WM8962_DACR_RETUNE_C22_0:\r\ncase WM8962_DACR_RETUNE_C23_1:\r\ncase WM8962_DACR_RETUNE_C23_0:\r\ncase WM8962_DACR_RETUNE_C24_1:\r\ncase WM8962_DACR_RETUNE_C24_0:\r\ncase WM8962_DACR_RETUNE_C25_1:\r\ncase WM8962_DACR_RETUNE_C25_0:\r\ncase WM8962_DACR_RETUNE_C26_1:\r\ncase WM8962_DACR_RETUNE_C26_0:\r\ncase WM8962_DACR_RETUNE_C27_1:\r\ncase WM8962_DACR_RETUNE_C27_0:\r\ncase WM8962_DACR_RETUNE_C28_1:\r\ncase WM8962_DACR_RETUNE_C28_0:\r\ncase WM8962_DACR_RETUNE_C29_1:\r\ncase WM8962_DACR_RETUNE_C29_0:\r\ncase WM8962_DACR_RETUNE_C30_1:\r\ncase WM8962_DACR_RETUNE_C30_0:\r\ncase WM8962_DACR_RETUNE_C31_1:\r\ncase WM8962_DACR_RETUNE_C31_0:\r\ncase WM8962_DACR_RETUNE_C32_1:\r\ncase WM8962_DACR_RETUNE_C32_0:\r\ncase WM8962_VSS_XHD2_1:\r\ncase WM8962_VSS_XHD2_0:\r\ncase WM8962_VSS_XHD3_1:\r\ncase WM8962_VSS_XHD3_0:\r\ncase WM8962_VSS_XHN1_1:\r\ncase WM8962_VSS_XHN1_0:\r\ncase WM8962_VSS_XHN2_1:\r\ncase WM8962_VSS_XHN2_0:\r\ncase WM8962_VSS_XHN3_1:\r\ncase WM8962_VSS_XHN3_0:\r\ncase WM8962_VSS_XLA_1:\r\ncase WM8962_VSS_XLA_0:\r\ncase WM8962_VSS_XLB_1:\r\ncase WM8962_VSS_XLB_0:\r\ncase WM8962_VSS_XLG_1:\r\ncase WM8962_VSS_XLG_0:\r\ncase WM8962_VSS_PG2_1:\r\ncase WM8962_VSS_PG2_0:\r\ncase WM8962_VSS_PG_1:\r\ncase WM8962_VSS_PG_0:\r\ncase WM8962_VSS_XTD1_1:\r\ncase WM8962_VSS_XTD1_0:\r\ncase WM8962_VSS_XTD2_1:\r\ncase WM8962_VSS_XTD2_0:\r\ncase WM8962_VSS_XTD3_1:\r\ncase WM8962_VSS_XTD3_0:\r\ncase WM8962_VSS_XTD4_1:\r\ncase WM8962_VSS_XTD4_0:\r\ncase WM8962_VSS_XTD5_1:\r\ncase WM8962_VSS_XTD5_0:\r\ncase WM8962_VSS_XTD6_1:\r\ncase WM8962_VSS_XTD6_0:\r\ncase WM8962_VSS_XTD7_1:\r\ncase WM8962_VSS_XTD7_0:\r\ncase WM8962_VSS_XTD8_1:\r\ncase WM8962_VSS_XTD8_0:\r\ncase WM8962_VSS_XTD9_1:\r\ncase WM8962_VSS_XTD9_0:\r\ncase WM8962_VSS_XTD10_1:\r\ncase WM8962_VSS_XTD10_0:\r\ncase WM8962_VSS_XTD11_1:\r\ncase WM8962_VSS_XTD11_0:\r\ncase WM8962_VSS_XTD12_1:\r\ncase WM8962_VSS_XTD12_0:\r\ncase WM8962_VSS_XTD13_1:\r\ncase WM8962_VSS_XTD13_0:\r\ncase WM8962_VSS_XTD14_1:\r\ncase WM8962_VSS_XTD14_0:\r\ncase WM8962_VSS_XTD15_1:\r\ncase WM8962_VSS_XTD15_0:\r\ncase WM8962_VSS_XTD16_1:\r\ncase WM8962_VSS_XTD16_0:\r\ncase WM8962_VSS_XTD17_1:\r\ncase WM8962_VSS_XTD17_0:\r\ncase WM8962_VSS_XTD18_1:\r\ncase WM8962_VSS_XTD18_0:\r\ncase WM8962_VSS_XTD19_1:\r\ncase WM8962_VSS_XTD19_0:\r\ncase WM8962_VSS_XTD20_1:\r\ncase WM8962_VSS_XTD20_0:\r\ncase WM8962_VSS_XTD21_1:\r\ncase WM8962_VSS_XTD21_0:\r\ncase WM8962_VSS_XTD22_1:\r\ncase WM8962_VSS_XTD22_0:\r\ncase WM8962_VSS_XTD23_1:\r\ncase WM8962_VSS_XTD23_0:\r\ncase WM8962_VSS_XTD24_1:\r\ncase WM8962_VSS_XTD24_0:\r\ncase WM8962_VSS_XTD25_1:\r\ncase WM8962_VSS_XTD25_0:\r\ncase WM8962_VSS_XTD26_1:\r\ncase WM8962_VSS_XTD26_0:\r\ncase WM8962_VSS_XTD27_1:\r\ncase WM8962_VSS_XTD27_0:\r\ncase WM8962_VSS_XTD28_1:\r\ncase WM8962_VSS_XTD28_0:\r\ncase WM8962_VSS_XTD29_1:\r\ncase WM8962_VSS_XTD29_0:\r\ncase WM8962_VSS_XTD30_1:\r\ncase WM8962_VSS_XTD30_0:\r\ncase WM8962_VSS_XTD31_1:\r\ncase WM8962_VSS_XTD31_0:\r\ncase WM8962_VSS_XTD32_1:\r\ncase WM8962_VSS_XTD32_0:\r\ncase WM8962_VSS_XTS1_1:\r\ncase WM8962_VSS_XTS1_0:\r\ncase WM8962_VSS_XTS2_1:\r\ncase WM8962_VSS_XTS2_0:\r\ncase WM8962_VSS_XTS3_1:\r\ncase WM8962_VSS_XTS3_0:\r\ncase WM8962_VSS_XTS4_1:\r\ncase WM8962_VSS_XTS4_0:\r\ncase WM8962_VSS_XTS5_1:\r\ncase WM8962_VSS_XTS5_0:\r\ncase WM8962_VSS_XTS6_1:\r\ncase WM8962_VSS_XTS6_0:\r\ncase WM8962_VSS_XTS7_1:\r\ncase WM8962_VSS_XTS7_0:\r\ncase WM8962_VSS_XTS8_1:\r\ncase WM8962_VSS_XTS8_0:\r\ncase WM8962_VSS_XTS9_1:\r\ncase WM8962_VSS_XTS9_0:\r\ncase WM8962_VSS_XTS10_1:\r\ncase WM8962_VSS_XTS10_0:\r\ncase WM8962_VSS_XTS11_1:\r\ncase WM8962_VSS_XTS11_0:\r\ncase WM8962_VSS_XTS12_1:\r\ncase WM8962_VSS_XTS12_0:\r\ncase WM8962_VSS_XTS13_1:\r\ncase WM8962_VSS_XTS13_0:\r\ncase WM8962_VSS_XTS14_1:\r\ncase WM8962_VSS_XTS14_0:\r\ncase WM8962_VSS_XTS15_1:\r\ncase WM8962_VSS_XTS15_0:\r\ncase WM8962_VSS_XTS16_1:\r\ncase WM8962_VSS_XTS16_0:\r\ncase WM8962_VSS_XTS17_1:\r\ncase WM8962_VSS_XTS17_0:\r\ncase WM8962_VSS_XTS18_1:\r\ncase WM8962_VSS_XTS18_0:\r\ncase WM8962_VSS_XTS19_1:\r\ncase WM8962_VSS_XTS19_0:\r\ncase WM8962_VSS_XTS20_1:\r\ncase WM8962_VSS_XTS20_0:\r\ncase WM8962_VSS_XTS21_1:\r\ncase WM8962_VSS_XTS21_0:\r\ncase WM8962_VSS_XTS22_1:\r\ncase WM8962_VSS_XTS22_0:\r\ncase WM8962_VSS_XTS23_1:\r\ncase WM8962_VSS_XTS23_0:\r\ncase WM8962_VSS_XTS24_1:\r\ncase WM8962_VSS_XTS24_0:\r\ncase WM8962_VSS_XTS25_1:\r\ncase WM8962_VSS_XTS25_0:\r\ncase WM8962_VSS_XTS26_1:\r\ncase WM8962_VSS_XTS26_0:\r\ncase WM8962_VSS_XTS27_1:\r\ncase WM8962_VSS_XTS27_0:\r\ncase WM8962_VSS_XTS28_1:\r\ncase WM8962_VSS_XTS28_0:\r\ncase WM8962_VSS_XTS29_1:\r\ncase WM8962_VSS_XTS29_0:\r\ncase WM8962_VSS_XTS30_1:\r\ncase WM8962_VSS_XTS30_0:\r\ncase WM8962_VSS_XTS31_1:\r\ncase WM8962_VSS_XTS31_0:\r\ncase WM8962_VSS_XTS32_1:\r\ncase WM8962_VSS_XTS32_0:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int wm8962_reset(struct wm8962_priv *wm8962)\r\n{\r\nint ret;\r\nret = regmap_write(wm8962->regmap, WM8962_SOFTWARE_RESET, 0x6243);\r\nif (ret != 0)\r\nreturn ret;\r\nreturn regmap_write(wm8962->regmap, WM8962_PLL_SOFTWARE_RESET, 0);\r\n}\r\nstatic int wm8962_dsp2_write_config(struct snd_soc_codec *codec)\r\n{\r\nreturn regcache_sync_region(codec->control_data,\r\nWM8962_HDBASS_AI_1, WM8962_MAX_REGISTER);\r\n}\r\nstatic int wm8962_dsp2_set_enable(struct snd_soc_codec *codec, u16 val)\r\n{\r\nu16 adcl = snd_soc_read(codec, WM8962_LEFT_ADC_VOLUME);\r\nu16 adcr = snd_soc_read(codec, WM8962_RIGHT_ADC_VOLUME);\r\nu16 dac = snd_soc_read(codec, WM8962_ADC_DAC_CONTROL_1);\r\nsnd_soc_write(codec, WM8962_LEFT_ADC_VOLUME, 0);\r\nsnd_soc_write(codec, WM8962_RIGHT_ADC_VOLUME, WM8962_ADC_VU);\r\nsnd_soc_update_bits(codec, WM8962_ADC_DAC_CONTROL_1,\r\nWM8962_DAC_MUTE, WM8962_DAC_MUTE);\r\nsnd_soc_write(codec, WM8962_SOUNDSTAGE_ENABLES_0, val);\r\nsnd_soc_write(codec, WM8962_LEFT_ADC_VOLUME, adcl);\r\nsnd_soc_write(codec, WM8962_RIGHT_ADC_VOLUME, adcr);\r\nsnd_soc_update_bits(codec, WM8962_ADC_DAC_CONTROL_1,\r\nWM8962_DAC_MUTE, dac);\r\nreturn 0;\r\n}\r\nstatic int wm8962_dsp2_start(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nwm8962_dsp2_write_config(codec);\r\nsnd_soc_write(codec, WM8962_DSP2_EXECCONTROL, WM8962_DSP2_RUNR);\r\nwm8962_dsp2_set_enable(codec, wm8962->dsp2_ena);\r\nreturn 0;\r\n}\r\nstatic int wm8962_dsp2_stop(struct snd_soc_codec *codec)\r\n{\r\nwm8962_dsp2_set_enable(codec, 0);\r\nsnd_soc_write(codec, WM8962_DSP2_EXECCONTROL, WM8962_DSP2_STOP);\r\nreturn 0;\r\n}\r\nstatic int wm8962_dsp2_ena_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int wm8962_dsp2_ena_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint shift = kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = !!(wm8962->dsp2_ena & 1 << shift);\r\nreturn 0;\r\n}\r\nstatic int wm8962_dsp2_ena_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint shift = kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nint old = wm8962->dsp2_ena;\r\nint ret = 0;\r\nint dsp2_running = snd_soc_read(codec, WM8962_DSP2_POWER_MANAGEMENT) &\r\nWM8962_DSP2_ENA;\r\nmutex_lock(&codec->mutex);\r\nif (ucontrol->value.integer.value[0])\r\nwm8962->dsp2_ena |= 1 << shift;\r\nelse\r\nwm8962->dsp2_ena &= ~(1 << shift);\r\nif (wm8962->dsp2_ena == old)\r\ngoto out;\r\nret = 1;\r\nif (dsp2_running) {\r\nif (wm8962->dsp2_ena)\r\nwm8962_dsp2_set_enable(codec, wm8962->dsp2_ena);\r\nelse\r\nwm8962_dsp2_stop(codec);\r\n}\r\nout:\r\nmutex_unlock(&codec->mutex);\r\nreturn ret;\r\n}\r\nstatic int wm8962_put_hp_sw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nu16 *reg_cache = codec->reg_cache;\r\nint ret;\r\nret = snd_soc_put_volsw(kcontrol, ucontrol);\r\nif (ret == 0)\r\nreturn 0;\r\nif (snd_soc_read(codec, WM8962_PWR_MGMT_2) & WM8962_HPOUTL_PGA_ENA)\r\nreturn snd_soc_write(codec, WM8962_HPOUTL_VOLUME,\r\nreg_cache[WM8962_HPOUTL_VOLUME]);\r\nif (snd_soc_read(codec, WM8962_PWR_MGMT_2) & WM8962_HPOUTR_PGA_ENA)\r\nreturn snd_soc_write(codec, WM8962_HPOUTR_VOLUME,\r\nreg_cache[WM8962_HPOUTR_VOLUME]);\r\nreturn 0;\r\n}\r\nstatic int wm8962_put_spk_sw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint ret;\r\nret = snd_soc_put_volsw(kcontrol, ucontrol);\r\nif (ret == 0)\r\nreturn 0;\r\nret = snd_soc_read(codec, WM8962_PWR_MGMT_2);\r\nif (ret & WM8962_SPKOUTL_PGA_ENA) {\r\nsnd_soc_write(codec, WM8962_SPKOUTL_VOLUME,\r\nsnd_soc_read(codec, WM8962_SPKOUTL_VOLUME));\r\nreturn 1;\r\n}\r\nif (ret & WM8962_SPKOUTR_PGA_ENA)\r\nsnd_soc_write(codec, WM8962_SPKOUTR_VOLUME,\r\nsnd_soc_read(codec, WM8962_SPKOUTR_VOLUME));\r\nreturn 1;\r\n}\r\nstatic int cp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nmsleep(5);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nint timeout;\r\nint reg;\r\nint expected = (WM8962_DCS_STARTUP_DONE_HP1L |\r\nWM8962_DCS_STARTUP_DONE_HP1R);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, WM8962_ANALOGUE_HP_0,\r\nWM8962_HP1L_ENA | WM8962_HP1R_ENA,\r\nWM8962_HP1L_ENA | WM8962_HP1R_ENA);\r\nudelay(20);\r\nsnd_soc_update_bits(codec, WM8962_ANALOGUE_HP_0,\r\nWM8962_HP1L_ENA_DLY | WM8962_HP1R_ENA_DLY,\r\nWM8962_HP1L_ENA_DLY | WM8962_HP1R_ENA_DLY);\r\nsnd_soc_update_bits(codec, WM8962_DC_SERVO_1,\r\nWM8962_HP1L_DCS_ENA | WM8962_HP1R_DCS_ENA |\r\nWM8962_HP1L_DCS_STARTUP |\r\nWM8962_HP1R_DCS_STARTUP,\r\nWM8962_HP1L_DCS_ENA | WM8962_HP1R_DCS_ENA |\r\nWM8962_HP1L_DCS_STARTUP |\r\nWM8962_HP1R_DCS_STARTUP);\r\ntimeout = 0;\r\ndo {\r\nmsleep(1);\r\nreg = snd_soc_read(codec, WM8962_DC_SERVO_6);\r\nif (reg < 0) {\r\ndev_err(codec->dev,\r\n"Failed to read DCS status: %d\n",\r\nreg);\r\ncontinue;\r\n}\r\ndev_dbg(codec->dev, "DCS status: %x\n", reg);\r\n} while (++timeout < 200 && (reg & expected) != expected);\r\nif ((reg & expected) != expected)\r\ndev_err(codec->dev, "DC servo timed out\n");\r\nelse\r\ndev_dbg(codec->dev, "DC servo complete after %dms\n",\r\ntimeout);\r\nsnd_soc_update_bits(codec, WM8962_ANALOGUE_HP_0,\r\nWM8962_HP1L_ENA_OUTP |\r\nWM8962_HP1R_ENA_OUTP,\r\nWM8962_HP1L_ENA_OUTP |\r\nWM8962_HP1R_ENA_OUTP);\r\nudelay(20);\r\nsnd_soc_update_bits(codec, WM8962_ANALOGUE_HP_0,\r\nWM8962_HP1L_RMV_SHORT |\r\nWM8962_HP1R_RMV_SHORT,\r\nWM8962_HP1L_RMV_SHORT |\r\nWM8962_HP1R_RMV_SHORT);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, WM8962_ANALOGUE_HP_0,\r\nWM8962_HP1L_RMV_SHORT |\r\nWM8962_HP1R_RMV_SHORT, 0);\r\nudelay(20);\r\nsnd_soc_update_bits(codec, WM8962_DC_SERVO_1,\r\nWM8962_HP1L_DCS_ENA | WM8962_HP1R_DCS_ENA |\r\nWM8962_HP1L_DCS_STARTUP |\r\nWM8962_HP1R_DCS_STARTUP,\r\n0);\r\nsnd_soc_update_bits(codec, WM8962_ANALOGUE_HP_0,\r\nWM8962_HP1L_ENA | WM8962_HP1R_ENA |\r\nWM8962_HP1L_ENA_DLY | WM8962_HP1R_ENA_DLY |\r\nWM8962_HP1L_ENA_OUTP |\r\nWM8962_HP1R_ENA_OUTP, 0);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int out_pga_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nint reg;\r\nswitch (w->shift) {\r\ncase WM8962_HPOUTR_PGA_ENA_SHIFT:\r\nreg = WM8962_HPOUTR_VOLUME;\r\nbreak;\r\ncase WM8962_HPOUTL_PGA_ENA_SHIFT:\r\nreg = WM8962_HPOUTL_VOLUME;\r\nbreak;\r\ncase WM8962_SPKOUTR_PGA_ENA_SHIFT:\r\nreg = WM8962_SPKOUTR_VOLUME;\r\nbreak;\r\ncase WM8962_SPKOUTL_PGA_ENA_SHIFT:\r\nreg = WM8962_SPKOUTL_VOLUME;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nreturn snd_soc_write(codec, reg, snd_soc_read(codec, reg));\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int dsp2_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nif (wm8962->dsp2_ena)\r\nwm8962_dsp2_start(codec);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nif (wm8962->dsp2_ena)\r\nwm8962_dsp2_stop(codec);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8962_add_widgets(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8962_pdata *pdata = dev_get_platdata(codec->dev);\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nsnd_soc_add_codec_controls(codec, wm8962_snd_controls,\r\nARRAY_SIZE(wm8962_snd_controls));\r\nif (pdata && pdata->spk_mono)\r\nsnd_soc_add_codec_controls(codec, wm8962_spk_mono_controls,\r\nARRAY_SIZE(wm8962_spk_mono_controls));\r\nelse\r\nsnd_soc_add_codec_controls(codec, wm8962_spk_stereo_controls,\r\nARRAY_SIZE(wm8962_spk_stereo_controls));\r\nsnd_soc_dapm_new_controls(dapm, wm8962_dapm_widgets,\r\nARRAY_SIZE(wm8962_dapm_widgets));\r\nif (pdata && pdata->spk_mono)\r\nsnd_soc_dapm_new_controls(dapm, wm8962_dapm_spk_mono_widgets,\r\nARRAY_SIZE(wm8962_dapm_spk_mono_widgets));\r\nelse\r\nsnd_soc_dapm_new_controls(dapm, wm8962_dapm_spk_stereo_widgets,\r\nARRAY_SIZE(wm8962_dapm_spk_stereo_widgets));\r\nsnd_soc_dapm_add_routes(dapm, wm8962_intercon,\r\nARRAY_SIZE(wm8962_intercon));\r\nif (pdata && pdata->spk_mono)\r\nsnd_soc_dapm_add_routes(dapm, wm8962_spk_mono_intercon,\r\nARRAY_SIZE(wm8962_spk_mono_intercon));\r\nelse\r\nsnd_soc_dapm_add_routes(dapm, wm8962_spk_stereo_intercon,\r\nARRAY_SIZE(wm8962_spk_stereo_intercon));\r\nsnd_soc_dapm_disable_pin(dapm, "Beep");\r\nreturn 0;\r\n}\r\nstatic void wm8962_configure_bclk(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nint dspclk, i;\r\nint clocking2 = 0;\r\nint clocking4 = 0;\r\nint aif2 = 0;\r\nif (!wm8962->sysclk_rate) {\r\ndev_dbg(codec->dev, "No SYSCLK configured\n");\r\nreturn;\r\n}\r\nif (!wm8962->bclk || !wm8962->lrclk) {\r\ndev_dbg(codec->dev, "No audio clocks configured\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(sysclk_rates); i++) {\r\nif (sysclk_rates[i] == wm8962->sysclk_rate / wm8962->lrclk) {\r\nclocking4 |= i << WM8962_SYSCLK_RATE_SHIFT;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(sysclk_rates)) {\r\ndev_err(codec->dev, "Unsupported sysclk ratio %d\n",\r\nwm8962->sysclk_rate / wm8962->lrclk);\r\nreturn;\r\n}\r\ndev_dbg(codec->dev, "Selected sysclk ratio %d\n", sysclk_rates[i]);\r\nsnd_soc_update_bits(codec, WM8962_CLOCKING_4,\r\nWM8962_SYSCLK_RATE_MASK, clocking4);\r\ndspclk = snd_soc_read(codec, WM8962_CLOCKING1);\r\nif (dspclk < 0) {\r\ndev_err(codec->dev, "Failed to read DSPCLK: %d\n", dspclk);\r\nreturn;\r\n}\r\ndspclk = (dspclk & WM8962_DSPCLK_DIV_MASK) >> WM8962_DSPCLK_DIV_SHIFT;\r\nswitch (dspclk) {\r\ncase 0:\r\ndspclk = wm8962->sysclk_rate;\r\nbreak;\r\ncase 1:\r\ndspclk = wm8962->sysclk_rate / 2;\r\nbreak;\r\ncase 2:\r\ndspclk = wm8962->sysclk_rate / 4;\r\nbreak;\r\ndefault:\r\ndev_warn(codec->dev, "Unknown DSPCLK divisor read back\n");\r\ndspclk = wm8962->sysclk;\r\n}\r\ndev_dbg(codec->dev, "DSPCLK is %dHz, BCLK %d\n", dspclk, wm8962->bclk);\r\nfor (i = 0; i < ARRAY_SIZE(bclk_divs); i++) {\r\nif (bclk_divs[i] < 0)\r\ncontinue;\r\nif (dspclk / bclk_divs[i] == wm8962->bclk) {\r\ndev_dbg(codec->dev, "Selected BCLK_DIV %d for %dHz\n",\r\nbclk_divs[i], wm8962->bclk);\r\nclocking2 |= i;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(bclk_divs)) {\r\ndev_err(codec->dev, "Unsupported BCLK ratio %d\n",\r\ndspclk / wm8962->bclk);\r\nreturn;\r\n}\r\naif2 |= wm8962->bclk / wm8962->lrclk;\r\ndev_dbg(codec->dev, "Selected LRCLK divisor %d for %dHz\n",\r\nwm8962->bclk / wm8962->lrclk, wm8962->lrclk);\r\nsnd_soc_update_bits(codec, WM8962_CLOCKING2,\r\nWM8962_BCLK_DIV_MASK, clocking2);\r\nsnd_soc_update_bits(codec, WM8962_AUDIO_INTERFACE_2,\r\nWM8962_AIF_RATE_MASK, aif2);\r\n}\r\nstatic int wm8962_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nif (level == codec->dapm.bias_level)\r\nreturn 0;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM8962_PWR_MGMT_1,\r\nWM8962_VMID_SEL_MASK, 0x80);\r\nwm8962_configure_bclk(codec);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_update_bits(codec, WM8962_PWR_MGMT_1,\r\nWM8962_VMID_SEL_MASK, 0x100);\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF)\r\nmsleep(100);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8962_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nint aif0 = 0;\r\nint adctl3 = 0;\r\nwm8962->bclk = snd_soc_params_to_bclk(params);\r\nif (params_channels(params) == 1)\r\nwm8962->bclk *= 2;\r\nwm8962->lrclk = params_rate(params);\r\nfor (i = 0; i < ARRAY_SIZE(sr_vals); i++) {\r\nif (sr_vals[i].rate == wm8962->lrclk) {\r\nadctl3 |= sr_vals[i].reg;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(sr_vals)) {\r\ndev_err(codec->dev, "Unsupported rate %dHz\n", wm8962->lrclk);\r\nreturn -EINVAL;\r\n}\r\nif (wm8962->lrclk % 8000 == 0)\r\nadctl3 |= WM8962_SAMPLE_RATE_INT_MODE;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\naif0 |= 0x4;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\naif0 |= 0x8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\naif0 |= 0xc;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8962_AUDIO_INTERFACE_0,\r\nWM8962_WL_MASK, aif0);\r\nsnd_soc_update_bits(codec, WM8962_ADDITIONAL_CONTROL_3,\r\nWM8962_SAMPLE_RATE_INT_MODE |\r\nWM8962_SAMPLE_RATE_MASK, adctl3);\r\ndev_dbg(codec->dev, "hw_params set BCLK %dHz LRCLK %dHz\n",\r\nwm8962->bclk, wm8962->lrclk);\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_ON)\r\nwm8962_configure_bclk(codec);\r\nreturn 0;\r\n}\r\nstatic int wm8962_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nint src;\r\nswitch (clk_id) {\r\ncase WM8962_SYSCLK_MCLK:\r\nwm8962->sysclk = WM8962_SYSCLK_MCLK;\r\nsrc = 0;\r\nbreak;\r\ncase WM8962_SYSCLK_FLL:\r\nwm8962->sysclk = WM8962_SYSCLK_FLL;\r\nsrc = 1 << WM8962_SYSCLK_SRC_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8962_CLOCKING2, WM8962_SYSCLK_SRC_MASK,\r\nsrc);\r\nwm8962->sysclk_rate = freq;\r\nwm8962_configure_bclk(codec);\r\nreturn 0;\r\n}\r\nstatic int wm8962_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint aif0 = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naif0 |= WM8962_LRCLK_INV | 3;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naif0 |= 3;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naif0 |= 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\naif0 |= 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif0 |= WM8962_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\naif0 |= WM8962_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\naif0 |= WM8962_BCLK_INV | WM8962_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naif0 |= WM8962_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8962_AUDIO_INTERFACE_0,\r\nWM8962_FMT_MASK | WM8962_BCLK_INV | WM8962_MSTR |\r\nWM8962_LRCLK_INV, aif0);\r\nreturn 0;\r\n}\r\nstatic int fll_factors(struct _fll_div *fll_div, unsigned int Fref,\r\nunsigned int Fout)\r\n{\r\nunsigned int target;\r\nunsigned int div;\r\nunsigned int fratio, gcd_fll;\r\nint i;\r\ndiv = 1;\r\nfll_div->fll_refclk_div = 0;\r\nwhile ((Fref / div) > 13500000) {\r\ndiv *= 2;\r\nfll_div->fll_refclk_div++;\r\nif (div > 4) {\r\npr_err("Can't scale %dMHz input down to <=13.5MHz\n",\r\nFref);\r\nreturn -EINVAL;\r\n}\r\n}\r\npr_debug("FLL Fref=%u Fout=%u\n", Fref, Fout);\r\nFref /= div;\r\ndiv = 2;\r\nwhile (Fout * div < 90000000) {\r\ndiv++;\r\nif (div > 64) {\r\npr_err("Unable to find FLL_OUTDIV for Fout=%uHz\n",\r\nFout);\r\nreturn -EINVAL;\r\n}\r\n}\r\ntarget = Fout * div;\r\nfll_div->fll_outdiv = div - 1;\r\npr_debug("FLL Fvco=%dHz\n", target);\r\nfor (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {\r\nif (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {\r\nfll_div->fll_fratio = fll_fratios[i].fll_fratio;\r\nfratio = fll_fratios[i].ratio;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(fll_fratios)) {\r\npr_err("Unable to find FLL_FRATIO for Fref=%uHz\n", Fref);\r\nreturn -EINVAL;\r\n}\r\nfll_div->n = target / (fratio * Fref);\r\nif (target % Fref == 0) {\r\nfll_div->theta = 0;\r\nfll_div->lambda = 0;\r\n} else {\r\ngcd_fll = gcd(target, fratio * Fref);\r\nfll_div->theta = (target - (fll_div->n * fratio * Fref))\r\n/ gcd_fll;\r\nfll_div->lambda = (fratio * Fref) / gcd_fll;\r\n}\r\npr_debug("FLL N=%x THETA=%x LAMBDA=%x\n",\r\nfll_div->n, fll_div->theta, fll_div->lambda);\r\npr_debug("FLL_FRATIO=%x FLL_OUTDIV=%x FLL_REFCLK_DIV=%x\n",\r\nfll_div->fll_fratio, fll_div->fll_outdiv,\r\nfll_div->fll_refclk_div);\r\nreturn 0;\r\n}\r\nstatic int wm8962_set_fll(struct snd_soc_codec *codec, int fll_id, int source,\r\nunsigned int Fref, unsigned int Fout)\r\n{\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nstruct _fll_div fll_div;\r\nunsigned long timeout;\r\nint ret;\r\nint fll1 = 0;\r\nif (source == wm8962->fll_src && Fref == wm8962->fll_fref &&\r\nFout == wm8962->fll_fout)\r\nreturn 0;\r\nif (Fout == 0) {\r\ndev_dbg(codec->dev, "FLL disabled\n");\r\nwm8962->fll_fref = 0;\r\nwm8962->fll_fout = 0;\r\nsnd_soc_update_bits(codec, WM8962_FLL_CONTROL_1,\r\nWM8962_FLL_ENA, 0);\r\npm_runtime_put(codec->dev);\r\nreturn 0;\r\n}\r\nret = fll_factors(&fll_div, Fref, Fout);\r\nif (ret != 0)\r\nreturn ret;\r\nsnd_soc_update_bits(codec, WM8962_FLL_CONTROL_1, WM8962_FLL_ENA, 0);\r\nswitch (fll_id) {\r\ncase WM8962_FLL_MCLK:\r\ncase WM8962_FLL_BCLK:\r\ncase WM8962_FLL_OSC:\r\nfll1 |= (fll_id - 1) << WM8962_FLL_REFCLK_SRC_SHIFT;\r\nbreak;\r\ncase WM8962_FLL_INT:\r\nsnd_soc_update_bits(codec, WM8962_FLL_CONTROL_1,\r\nWM8962_FLL_OSC_ENA, WM8962_FLL_OSC_ENA);\r\nsnd_soc_update_bits(codec, WM8962_FLL_CONTROL_5,\r\nWM8962_FLL_FRC_NCO, WM8962_FLL_FRC_NCO);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown FLL source %d\n", ret);\r\nreturn -EINVAL;\r\n}\r\nif (fll_div.theta || fll_div.lambda)\r\nfll1 |= WM8962_FLL_FRAC;\r\nsnd_soc_update_bits(codec, WM8962_FLL_CONTROL_1, WM8962_FLL_ENA, 0);\r\nsnd_soc_update_bits(codec, WM8962_FLL_CONTROL_2,\r\nWM8962_FLL_OUTDIV_MASK |\r\nWM8962_FLL_REFCLK_DIV_MASK,\r\n(fll_div.fll_outdiv << WM8962_FLL_OUTDIV_SHIFT) |\r\n(fll_div.fll_refclk_div));\r\nsnd_soc_update_bits(codec, WM8962_FLL_CONTROL_3,\r\nWM8962_FLL_FRATIO_MASK, fll_div.fll_fratio);\r\nsnd_soc_write(codec, WM8962_FLL_CONTROL_6, fll_div.theta);\r\nsnd_soc_write(codec, WM8962_FLL_CONTROL_7, fll_div.lambda);\r\nsnd_soc_write(codec, WM8962_FLL_CONTROL_8, fll_div.n);\r\ntry_wait_for_completion(&wm8962->fll_lock);\r\npm_runtime_get_sync(codec->dev);\r\nsnd_soc_update_bits(codec, WM8962_FLL_CONTROL_1,\r\nWM8962_FLL_FRAC | WM8962_FLL_REFCLK_SRC_MASK |\r\nWM8962_FLL_ENA, fll1 | WM8962_FLL_ENA);\r\ndev_dbg(codec->dev, "FLL configured for %dHz->%dHz\n", Fref, Fout);\r\nret = 0;\r\nif (fll1 & WM8962_FLL_ENA) {\r\nif (wm8962->irq)\r\ntimeout = msecs_to_jiffies(5);\r\nelse\r\ntimeout = msecs_to_jiffies(1);\r\ntimeout = wait_for_completion_timeout(&wm8962->fll_lock,\r\ntimeout);\r\nif (timeout == 0 && wm8962->irq) {\r\ndev_err(codec->dev, "FLL lock timed out");\r\nret = -ETIMEDOUT;\r\n}\r\n}\r\nwm8962->fll_fref = Fref;\r\nwm8962->fll_fout = Fout;\r\nwm8962->fll_src = source;\r\nreturn ret;\r\n}\r\nstatic int wm8962_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint val;\r\nif (mute)\r\nval = WM8962_DAC_MUTE;\r\nelse\r\nval = 0;\r\nreturn snd_soc_update_bits(codec, WM8962_ADC_DAC_CONTROL_1,\r\nWM8962_DAC_MUTE, val);\r\n}\r\nstatic void wm8962_mic_work(struct work_struct *work)\r\n{\r\nstruct wm8962_priv *wm8962 = container_of(work,\r\nstruct wm8962_priv,\r\nmic_work.work);\r\nstruct snd_soc_codec *codec = wm8962->codec;\r\nint status = 0;\r\nint irq_pol = 0;\r\nint reg;\r\nreg = snd_soc_read(codec, WM8962_ADDITIONAL_CONTROL_4);\r\nif (reg & WM8962_MICDET_STS) {\r\nstatus |= SND_JACK_MICROPHONE;\r\nirq_pol |= WM8962_MICD_IRQ_POL;\r\n}\r\nif (reg & WM8962_MICSHORT_STS) {\r\nstatus |= SND_JACK_BTN_0;\r\nirq_pol |= WM8962_MICSCD_IRQ_POL;\r\n}\r\nsnd_soc_jack_report(wm8962->jack, status,\r\nSND_JACK_MICROPHONE | SND_JACK_BTN_0);\r\nsnd_soc_update_bits(codec, WM8962_MICINT_SOURCE_POL,\r\nWM8962_MICSCD_IRQ_POL |\r\nWM8962_MICD_IRQ_POL, irq_pol);\r\n}\r\nstatic irqreturn_t wm8962_irq(int irq, void *data)\r\n{\r\nstruct device *dev = data;\r\nstruct wm8962_priv *wm8962 = dev_get_drvdata(dev);\r\nunsigned int mask;\r\nunsigned int active;\r\nint reg, ret;\r\nret = regmap_read(wm8962->regmap, WM8962_INTERRUPT_STATUS_2_MASK,\r\n&mask);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to read interrupt mask: %d\n",\r\nret);\r\nreturn IRQ_NONE;\r\n}\r\nret = regmap_read(wm8962->regmap, WM8962_INTERRUPT_STATUS_2, &active);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to read interrupt: %d\n", ret);\r\nreturn IRQ_NONE;\r\n}\r\nactive &= ~mask;\r\nif (!active)\r\nreturn IRQ_NONE;\r\nret = regmap_write(wm8962->regmap, WM8962_INTERRUPT_STATUS_2, active);\r\nif (ret != 0)\r\ndev_warn(dev, "Failed to ack interrupt: %d\n", ret);\r\nif (active & WM8962_FLL_LOCK_EINT) {\r\ndev_dbg(dev, "FLL locked\n");\r\ncomplete(&wm8962->fll_lock);\r\n}\r\nif (active & WM8962_FIFOS_ERR_EINT)\r\ndev_err(dev, "FIFO error\n");\r\nif (active & WM8962_TEMP_SHUT_EINT) {\r\ndev_crit(dev, "Thermal shutdown\n");\r\nret = regmap_read(wm8962->regmap,\r\nWM8962_THERMAL_SHUTDOWN_STATUS, &reg);\r\nif (ret != 0) {\r\ndev_warn(dev, "Failed to read thermal status: %d\n",\r\nret);\r\nreg = 0;\r\n}\r\nif (reg & WM8962_TEMP_ERR_HP)\r\ndev_crit(dev, "Headphone thermal error\n");\r\nif (reg & WM8962_TEMP_WARN_HP)\r\ndev_crit(dev, "Headphone thermal warning\n");\r\nif (reg & WM8962_TEMP_ERR_SPK)\r\ndev_crit(dev, "Speaker thermal error\n");\r\nif (reg & WM8962_TEMP_WARN_SPK)\r\ndev_crit(dev, "Speaker thermal warning\n");\r\n}\r\nif (active & (WM8962_MICSCD_EINT | WM8962_MICD_EINT)) {\r\ndev_dbg(dev, "Microphone event detected\n");\r\n#ifndef CONFIG_SND_SOC_WM8962_MODULE\r\ntrace_snd_soc_jack_irq(dev_name(dev));\r\n#endif\r\npm_wakeup_event(dev, 300);\r\nschedule_delayed_work(&wm8962->mic_work,\r\nmsecs_to_jiffies(250));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint wm8962_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack)\r\n{\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nint irq_mask, enable;\r\nwm8962->jack = jack;\r\nif (jack) {\r\nirq_mask = 0;\r\nenable = WM8962_MICDET_ENA;\r\n} else {\r\nirq_mask = WM8962_MICD_EINT | WM8962_MICSCD_EINT;\r\nenable = 0;\r\n}\r\nsnd_soc_update_bits(codec, WM8962_INTERRUPT_STATUS_2_MASK,\r\nWM8962_MICD_EINT | WM8962_MICSCD_EINT, irq_mask);\r\nsnd_soc_update_bits(codec, WM8962_ADDITIONAL_CONTROL_4,\r\nWM8962_MICDET_ENA, enable);\r\nsnd_soc_jack_report(wm8962->jack, 0,\r\nSND_JACK_MICROPHONE | SND_JACK_BTN_0);\r\nif (jack) {\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm, "SYSCLK");\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm, "MICBIAS");\r\n} else {\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "SYSCLK");\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "MICBIAS");\r\n}\r\nreturn 0;\r\n}\r\nstatic void wm8962_beep_work(struct work_struct *work)\r\n{\r\nstruct wm8962_priv *wm8962 =\r\ncontainer_of(work, struct wm8962_priv, beep_work);\r\nstruct snd_soc_codec *codec = wm8962->codec;\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nint i;\r\nint reg = 0;\r\nint best = 0;\r\nif (wm8962->beep_rate) {\r\nfor (i = 0; i < ARRAY_SIZE(beep_rates); i++) {\r\nif (abs(wm8962->beep_rate - beep_rates[i]) <\r\nabs(wm8962->beep_rate - beep_rates[best]))\r\nbest = i;\r\n}\r\ndev_dbg(codec->dev, "Set beep rate %dHz for requested %dHz\n",\r\nbeep_rates[best], wm8962->beep_rate);\r\nreg = WM8962_BEEP_ENA | (best << WM8962_BEEP_RATE_SHIFT);\r\nsnd_soc_dapm_enable_pin(dapm, "Beep");\r\n} else {\r\ndev_dbg(codec->dev, "Disabling beep\n");\r\nsnd_soc_dapm_disable_pin(dapm, "Beep");\r\n}\r\nsnd_soc_update_bits(codec, WM8962_BEEP_GENERATOR_1,\r\nWM8962_BEEP_ENA | WM8962_BEEP_RATE_MASK, reg);\r\nsnd_soc_dapm_sync(dapm);\r\n}\r\nstatic int wm8962_beep_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int hz)\r\n{\r\nstruct snd_soc_codec *codec = input_get_drvdata(dev);\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "Beep event %x %x\n", code, hz);\r\nswitch (code) {\r\ncase SND_BELL:\r\nif (hz)\r\nhz = 1000;\r\ncase SND_TONE:\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nwm8962->beep_rate = hz;\r\nschedule_work(&wm8962->beep_work);\r\nreturn 0;\r\n}\r\nstatic ssize_t wm8962_beep_set(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct wm8962_priv *wm8962 = dev_get_drvdata(dev);\r\nlong int time;\r\nint ret;\r\nret = strict_strtol(buf, 10, &time);\r\nif (ret != 0)\r\nreturn ret;\r\ninput_event(wm8962->beep, EV_SND, SND_TONE, time);\r\nreturn count;\r\n}\r\nstatic void wm8962_init_beep(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nwm8962->beep = input_allocate_device();\r\nif (!wm8962->beep) {\r\ndev_err(codec->dev, "Failed to allocate beep device\n");\r\nreturn;\r\n}\r\nINIT_WORK(&wm8962->beep_work, wm8962_beep_work);\r\nwm8962->beep_rate = 0;\r\nwm8962->beep->name = "WM8962 Beep Generator";\r\nwm8962->beep->phys = dev_name(codec->dev);\r\nwm8962->beep->id.bustype = BUS_I2C;\r\nwm8962->beep->evbit[0] = BIT_MASK(EV_SND);\r\nwm8962->beep->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\r\nwm8962->beep->event = wm8962_beep_event;\r\nwm8962->beep->dev.parent = codec->dev;\r\ninput_set_drvdata(wm8962->beep, codec);\r\nret = input_register_device(wm8962->beep);\r\nif (ret != 0) {\r\ninput_free_device(wm8962->beep);\r\nwm8962->beep = NULL;\r\ndev_err(codec->dev, "Failed to register beep device\n");\r\n}\r\nret = device_create_file(codec->dev, &dev_attr_beep);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to create keyclick file: %d\n",\r\nret);\r\n}\r\n}\r\nstatic void wm8962_free_beep(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\ndevice_remove_file(codec->dev, &dev_attr_beep);\r\ninput_unregister_device(wm8962->beep);\r\ncancel_work_sync(&wm8962->beep_work);\r\nwm8962->beep = NULL;\r\nsnd_soc_update_bits(codec, WM8962_BEEP_GENERATOR_1, WM8962_BEEP_ENA,0);\r\n}\r\nstatic void wm8962_init_beep(struct snd_soc_codec *codec)\r\n{\r\n}\r\nstatic void wm8962_free_beep(struct snd_soc_codec *codec)\r\n{\r\n}\r\nstatic void wm8962_set_gpio_mode(struct snd_soc_codec *codec, int gpio)\r\n{\r\nint mask = 0;\r\nint val = 0;\r\nswitch (gpio) {\r\ncase 2:\r\nmask = WM8962_CLKOUT2_SEL_MASK;\r\nval = 1 << WM8962_CLKOUT2_SEL_SHIFT;\r\nbreak;\r\ncase 3:\r\nmask = WM8962_CLKOUT3_SEL_MASK;\r\nval = 1 << WM8962_CLKOUT3_SEL_SHIFT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (mask)\r\nsnd_soc_update_bits(codec, WM8962_ANALOGUE_CLOCKING1,\r\nmask, val);\r\n}\r\nstatic inline struct wm8962_priv *gpio_to_wm8962(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct wm8962_priv, gpio_chip);\r\n}\r\nstatic int wm8962_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct wm8962_priv *wm8962 = gpio_to_wm8962(chip);\r\nstruct snd_soc_codec *codec = wm8962->codec;\r\nswitch (offset + 1) {\r\ncase 2:\r\ncase 3:\r\ncase 5:\r\ncase 6:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwm8962_set_gpio_mode(codec, offset + 1);\r\nreturn 0;\r\n}\r\nstatic void wm8962_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct wm8962_priv *wm8962 = gpio_to_wm8962(chip);\r\nstruct snd_soc_codec *codec = wm8962->codec;\r\nsnd_soc_update_bits(codec, WM8962_GPIO_BASE + offset,\r\nWM8962_GP2_LVL, !!value << WM8962_GP2_LVL_SHIFT);\r\n}\r\nstatic int wm8962_gpio_direction_out(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct wm8962_priv *wm8962 = gpio_to_wm8962(chip);\r\nstruct snd_soc_codec *codec = wm8962->codec;\r\nint ret, val;\r\nval = (1 << WM8962_GP2_FN_SHIFT) | (value << WM8962_GP2_LVL_SHIFT);\r\nret = snd_soc_update_bits(codec, WM8962_GPIO_BASE + offset,\r\nWM8962_GP2_FN_MASK | WM8962_GP2_LVL, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void wm8962_init_gpio(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8962_pdata *pdata = dev_get_platdata(codec->dev);\r\nint ret;\r\nwm8962->gpio_chip = wm8962_template_chip;\r\nwm8962->gpio_chip.ngpio = WM8962_MAX_GPIO;\r\nwm8962->gpio_chip.dev = codec->dev;\r\nif (pdata && pdata->gpio_base)\r\nwm8962->gpio_chip.base = pdata->gpio_base;\r\nelse\r\nwm8962->gpio_chip.base = -1;\r\nret = gpiochip_add(&wm8962->gpio_chip);\r\nif (ret != 0)\r\ndev_err(codec->dev, "Failed to add GPIOs: %d\n", ret);\r\n}\r\nstatic void wm8962_free_gpio(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = gpiochip_remove(&wm8962->gpio_chip);\r\nif (ret != 0)\r\ndev_err(codec->dev, "Failed to remove GPIOs: %d\n", ret);\r\n}\r\nstatic void wm8962_init_gpio(struct snd_soc_codec *codec)\r\n{\r\n}\r\nstatic void wm8962_free_gpio(struct snd_soc_codec *codec)\r\n{\r\n}\r\nstatic int wm8962_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret;\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8962_pdata *pdata = dev_get_platdata(codec->dev);\r\nu16 *reg_cache = codec->reg_cache;\r\nint i, trigger, irq_pol;\r\nbool dmicclk, dmicdat;\r\nwm8962->codec = codec;\r\ncodec->control_data = wm8962->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 16, 16, SND_SOC_REGMAP);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nwm8962->disable_nb[0].notifier_call = wm8962_regulator_event_0;\r\nwm8962->disable_nb[1].notifier_call = wm8962_regulator_event_1;\r\nwm8962->disable_nb[2].notifier_call = wm8962_regulator_event_2;\r\nwm8962->disable_nb[3].notifier_call = wm8962_regulator_event_3;\r\nwm8962->disable_nb[4].notifier_call = wm8962_regulator_event_4;\r\nwm8962->disable_nb[5].notifier_call = wm8962_regulator_event_5;\r\nwm8962->disable_nb[6].notifier_call = wm8962_regulator_event_6;\r\nwm8962->disable_nb[7].notifier_call = wm8962_regulator_event_7;\r\nfor (i = 0; i < ARRAY_SIZE(wm8962->supplies); i++) {\r\nret = regulator_register_notifier(wm8962->supplies[i].consumer,\r\n&wm8962->disable_nb[i]);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to register regulator notifier: %d\n",\r\nret);\r\n}\r\n}\r\nsnd_soc_update_bits(codec, WM8962_CLOCKING2, WM8962_SYSCLK_ENA, 0);\r\nsnd_soc_update_bits(codec, WM8962_CLOCKING2,\r\nWM8962_CLKREG_OVD, WM8962_CLKREG_OVD);\r\nsnd_soc_update_bits(codec, WM8962_PLL2,\r\nWM8962_OSC_ENA | WM8962_PLL2_ENA | WM8962_PLL3_ENA,\r\n0);\r\nif (pdata) {\r\nfor (i = 0; i < ARRAY_SIZE(pdata->gpio_init); i++)\r\nif (pdata->gpio_init[i]) {\r\nwm8962_set_gpio_mode(codec, i + 1);\r\nsnd_soc_write(codec, 0x200 + i,\r\npdata->gpio_init[i] & 0xffff);\r\n}\r\nif (pdata->spk_mono)\r\nreg_cache[WM8962_CLASS_D_CONTROL_2]\r\n|= WM8962_SPK_MONO;\r\nif (pdata->mic_cfg)\r\nsnd_soc_update_bits(codec, WM8962_ADDITIONAL_CONTROL_4,\r\nWM8962_MICDET_ENA |\r\nWM8962_MICDET_THR_MASK |\r\nWM8962_MICSHORT_THR_MASK |\r\nWM8962_MICBIAS_LVL,\r\npdata->mic_cfg);\r\n}\r\nsnd_soc_update_bits(codec, WM8962_LEFT_INPUT_VOLUME,\r\nWM8962_IN_VU, WM8962_IN_VU);\r\nsnd_soc_update_bits(codec, WM8962_RIGHT_INPUT_VOLUME,\r\nWM8962_IN_VU, WM8962_IN_VU);\r\nsnd_soc_update_bits(codec, WM8962_LEFT_ADC_VOLUME,\r\nWM8962_ADC_VU, WM8962_ADC_VU);\r\nsnd_soc_update_bits(codec, WM8962_RIGHT_ADC_VOLUME,\r\nWM8962_ADC_VU, WM8962_ADC_VU);\r\nsnd_soc_update_bits(codec, WM8962_LEFT_DAC_VOLUME,\r\nWM8962_DAC_VU, WM8962_DAC_VU);\r\nsnd_soc_update_bits(codec, WM8962_RIGHT_DAC_VOLUME,\r\nWM8962_DAC_VU, WM8962_DAC_VU);\r\nsnd_soc_update_bits(codec, WM8962_SPKOUTL_VOLUME,\r\nWM8962_SPKOUT_VU, WM8962_SPKOUT_VU);\r\nsnd_soc_update_bits(codec, WM8962_SPKOUTR_VOLUME,\r\nWM8962_SPKOUT_VU, WM8962_SPKOUT_VU);\r\nsnd_soc_update_bits(codec, WM8962_HPOUTL_VOLUME,\r\nWM8962_HPOUT_VU, WM8962_HPOUT_VU);\r\nsnd_soc_update_bits(codec, WM8962_HPOUTR_VOLUME,\r\nWM8962_HPOUT_VU, WM8962_HPOUT_VU);\r\nsnd_soc_update_bits(codec, WM8962_EQ1, WM8962_EQ_SHARED_COEFF, 0);\r\nsnd_soc_update_bits(codec, WM8962_IRQ_DEBOUNCE,\r\nWM8962_FLL_LOCK_DB | WM8962_PLL3_LOCK_DB |\r\nWM8962_PLL2_LOCK_DB | WM8962_TEMP_SHUT_DB,\r\n0);\r\nwm8962_add_widgets(codec);\r\ndmicclk = false;\r\ndmicdat = false;\r\nfor (i = 0; i < WM8962_MAX_GPIO; i++) {\r\nswitch (snd_soc_read(codec, WM8962_GPIO_BASE + i)\r\n& WM8962_GP2_FN_MASK) {\r\ncase WM8962_GPIO_FN_DMICCLK:\r\ndmicclk = true;\r\nbreak;\r\ncase WM8962_GPIO_FN_DMICDAT:\r\ndmicdat = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (!dmicclk || !dmicdat) {\r\ndev_dbg(codec->dev, "DMIC not in use, disabling\n");\r\nsnd_soc_dapm_nc_pin(&codec->dapm, "DMICDAT");\r\n}\r\nif (dmicclk != dmicdat)\r\ndev_warn(codec->dev, "DMIC GPIOs partially configured\n");\r\nwm8962_init_beep(codec);\r\nwm8962_init_gpio(codec);\r\nif (wm8962->irq) {\r\nif (pdata && pdata->irq_active_low) {\r\ntrigger = IRQF_TRIGGER_LOW;\r\nirq_pol = WM8962_IRQ_POL;\r\n} else {\r\ntrigger = IRQF_TRIGGER_HIGH;\r\nirq_pol = 0;\r\n}\r\nsnd_soc_update_bits(codec, WM8962_INTERRUPT_CONTROL,\r\nWM8962_IRQ_POL, irq_pol);\r\nret = request_threaded_irq(wm8962->irq, NULL, wm8962_irq,\r\ntrigger | IRQF_ONESHOT,\r\n"wm8962", codec->dev);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to request IRQ %d: %d\n",\r\nwm8962->irq, ret);\r\nwm8962->irq = 0;\r\n} else {\r\nsnd_soc_update_bits(codec,\r\nWM8962_INTERRUPT_STATUS_2_MASK,\r\nWM8962_FLL_LOCK_EINT |\r\nWM8962_TEMP_SHUT_EINT |\r\nWM8962_FIFOS_ERR_EINT, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8962_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8962_priv *wm8962 = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nif (wm8962->irq)\r\nfree_irq(wm8962->irq, codec);\r\ncancel_delayed_work_sync(&wm8962->mic_work);\r\nwm8962_free_gpio(codec);\r\nwm8962_free_beep(codec);\r\nfor (i = 0; i < ARRAY_SIZE(wm8962->supplies); i++)\r\nregulator_unregister_notifier(wm8962->supplies[i].consumer,\r\n&wm8962->disable_nb[i]);\r\nreturn 0;\r\n}\r\nstatic __devinit int wm8962_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8962_pdata *pdata = dev_get_platdata(&i2c->dev);\r\nstruct wm8962_priv *wm8962;\r\nunsigned int reg;\r\nint ret, i;\r\nwm8962 = devm_kzalloc(&i2c->dev, sizeof(struct wm8962_priv),\r\nGFP_KERNEL);\r\nif (wm8962 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, wm8962);\r\nINIT_DELAYED_WORK(&wm8962->mic_work, wm8962_mic_work);\r\ninit_completion(&wm8962->fll_lock);\r\nwm8962->irq = i2c->irq;\r\nfor (i = 0; i < ARRAY_SIZE(wm8962->supplies); i++)\r\nwm8962->supplies[i].supply = wm8962_supply_names[i];\r\nret = regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8962->supplies),\r\nwm8962->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to request supplies: %d\n", ret);\r\ngoto err;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8962->supplies),\r\nwm8962->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to enable supplies: %d\n", ret);\r\ngoto err_get;\r\n}\r\nwm8962->regmap = regmap_init_i2c(i2c, &wm8962_regmap);\r\nif (IS_ERR(wm8962->regmap)) {\r\nret = PTR_ERR(wm8962->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate regmap: %d\n", ret);\r\ngoto err_enable;\r\n}\r\nregcache_cache_bypass(wm8962->regmap, true);\r\nret = regmap_read(wm8962->regmap, WM8962_SOFTWARE_RESET, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to read ID register\n");\r\ngoto err_regmap;\r\n}\r\nif (reg != 0x6243) {\r\ndev_err(&i2c->dev,\r\n"Device is not a WM8962, ID %x != 0x6243\n", reg);\r\nret = -EINVAL;\r\ngoto err_regmap;\r\n}\r\nret = regmap_read(wm8962->regmap, WM8962_RIGHT_INPUT_VOLUME, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to read device revision: %d\n",\r\nret);\r\ngoto err_regmap;\r\n}\r\ndev_info(&i2c->dev, "customer id %x revision %c\n",\r\n(reg & WM8962_CUST_ID_MASK) >> WM8962_CUST_ID_SHIFT,\r\n((reg & WM8962_CHIP_REV_MASK) >> WM8962_CHIP_REV_SHIFT)\r\n+ 'A');\r\nregcache_cache_bypass(wm8962->regmap, false);\r\nret = wm8962_reset(wm8962);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to issue reset\n");\r\ngoto err_regmap;\r\n}\r\nif (pdata && pdata->in4_dc_measure) {\r\nret = regmap_register_patch(wm8962->regmap,\r\nwm8962_dc_measure,\r\nARRAY_SIZE(wm8962_dc_measure));\r\nif (ret != 0)\r\ndev_err(&i2c->dev,\r\n"Failed to configure for DC mesurement: %d\n",\r\nret);\r\n}\r\npm_runtime_enable(&i2c->dev);\r\npm_request_idle(&i2c->dev);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8962, &wm8962_dai, 1);\r\nif (ret < 0)\r\ngoto err_regmap;\r\nregulator_bulk_disable(ARRAY_SIZE(wm8962->supplies), wm8962->supplies);\r\nreturn 0;\r\nerr_regmap:\r\nregmap_exit(wm8962->regmap);\r\nerr_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(wm8962->supplies), wm8962->supplies);\r\nerr_get:\r\nregulator_bulk_free(ARRAY_SIZE(wm8962->supplies), wm8962->supplies);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic __devexit int wm8962_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct wm8962_priv *wm8962 = dev_get_drvdata(&client->dev);\r\nsnd_soc_unregister_codec(&client->dev);\r\nregmap_exit(wm8962->regmap);\r\nregulator_bulk_free(ARRAY_SIZE(wm8962->supplies), wm8962->supplies);\r\nreturn 0;\r\n}\r\nstatic int wm8962_runtime_resume(struct device *dev)\r\n{\r\nstruct wm8962_priv *wm8962 = dev_get_drvdata(dev);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8962->supplies),\r\nwm8962->supplies);\r\nif (ret != 0) {\r\ndev_err(dev,\r\n"Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(wm8962->regmap, false);\r\nwm8962_reset(wm8962);\r\nregcache_sync(wm8962->regmap);\r\nreturn 0;\r\n}\r\nstatic int wm8962_runtime_suspend(struct device *dev)\r\n{\r\nstruct wm8962_priv *wm8962 = dev_get_drvdata(dev);\r\nregmap_update_bits(wm8962->regmap, WM8962_PWR_MGMT_1,\r\nWM8962_VMID_SEL_MASK | WM8962_BIAS_ENA, 0);\r\nregmap_update_bits(wm8962->regmap, WM8962_ANTI_POP,\r\nWM8962_STARTUP_BIAS_ENA |\r\nWM8962_VMID_BUF_ENA, 0);\r\nregcache_cache_only(wm8962->regmap, true);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8962->supplies),\r\nwm8962->supplies);\r\nreturn 0;\r\n}
