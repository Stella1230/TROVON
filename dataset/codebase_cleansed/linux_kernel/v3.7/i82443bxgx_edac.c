static void i82443bxgx_edacmc_get_error_info(struct mem_ctl_info *mci,\r\nstruct i82443bxgx_edacmc_error_info\r\n*info)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(mci->pdev);\r\npci_read_config_dword(pdev, I82443BXGX_EAP, &info->eap);\r\nif (info->eap & I82443BXGX_EAP_OFFSET_SBE)\r\npci_write_bits32(pdev, I82443BXGX_EAP,\r\nI82443BXGX_EAP_OFFSET_SBE,\r\nI82443BXGX_EAP_OFFSET_SBE);\r\nif (info->eap & I82443BXGX_EAP_OFFSET_MBE)\r\npci_write_bits32(pdev, I82443BXGX_EAP,\r\nI82443BXGX_EAP_OFFSET_MBE,\r\nI82443BXGX_EAP_OFFSET_MBE);\r\n}\r\nstatic int i82443bxgx_edacmc_process_error_info(struct mem_ctl_info *mci,\r\nstruct\r\ni82443bxgx_edacmc_error_info\r\n*info, int handle_errors)\r\n{\r\nint error_found = 0;\r\nu32 eapaddr, page, pageoffset;\r\neapaddr = (info->eap & 0xfffff000);\r\npage = eapaddr >> PAGE_SHIFT;\r\npageoffset = eapaddr - (page << PAGE_SHIFT);\r\nif (info->eap & I82443BXGX_EAP_OFFSET_SBE) {\r\nerror_found = 1;\r\nif (handle_errors)\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\npage, pageoffset, 0,\r\nedac_mc_find_csrow_by_page(mci, page),\r\n0, -1, mci->ctl_name, "");\r\n}\r\nif (info->eap & I82443BXGX_EAP_OFFSET_MBE) {\r\nerror_found = 1;\r\nif (handle_errors)\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\npage, pageoffset, 0,\r\nedac_mc_find_csrow_by_page(mci, page),\r\n0, -1, mci->ctl_name, "");\r\n}\r\nreturn error_found;\r\n}\r\nstatic void i82443bxgx_edacmc_check(struct mem_ctl_info *mci)\r\n{\r\nstruct i82443bxgx_edacmc_error_info info;\r\nedac_dbg(1, "MC%d\n", mci->mc_idx);\r\ni82443bxgx_edacmc_get_error_info(mci, &info);\r\ni82443bxgx_edacmc_process_error_info(mci, &info, 1);\r\n}\r\nstatic void i82443bxgx_init_csrows(struct mem_ctl_info *mci,\r\nstruct pci_dev *pdev,\r\nenum edac_type edac_mode,\r\nenum mem_type mtype)\r\n{\r\nstruct csrow_info *csrow;\r\nstruct dimm_info *dimm;\r\nint index;\r\nu8 drbar, dramc;\r\nu32 row_base, row_high_limit, row_high_limit_last;\r\npci_read_config_byte(pdev, I82443BXGX_DRAMC, &dramc);\r\nrow_high_limit_last = 0;\r\nfor (index = 0; index < mci->nr_csrows; index++) {\r\ncsrow = mci->csrows[index];\r\ndimm = csrow->channels[0]->dimm;\r\npci_read_config_byte(pdev, I82443BXGX_DRB + index, &drbar);\r\nedac_dbg(1, "MC%d: Row=%d DRB = %#0x\n",\r\nmci->mc_idx, index, drbar);\r\nrow_high_limit = ((u32) drbar << 23);\r\nedac_dbg(1, "MC%d: Row=%d, Boundary Address=%#0x, Last = %#0x\n",\r\nmci->mc_idx, index, row_high_limit,\r\nrow_high_limit_last);\r\nif (row_high_limit_last && !row_high_limit)\r\nrow_high_limit = 1UL << 31;\r\nif (row_high_limit == row_high_limit_last)\r\ncontinue;\r\nrow_base = row_high_limit_last;\r\ncsrow->first_page = row_base >> PAGE_SHIFT;\r\ncsrow->last_page = (row_high_limit >> PAGE_SHIFT) - 1;\r\ndimm->nr_pages = csrow->last_page - csrow->first_page + 1;\r\ndimm->grain = 1 << 12;\r\ndimm->mtype = mtype;\r\ndimm->dtype = DEV_UNKNOWN;\r\ndimm->edac_mode = edac_mode;\r\nrow_high_limit_last = row_high_limit;\r\n}\r\n}\r\nstatic int i82443bxgx_edacmc_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nu8 dramc;\r\nu32 nbxcfg, ecc_mode;\r\nenum mem_type mtype;\r\nenum edac_type edac_mode;\r\nedac_dbg(0, "MC:\n");\r\nif (pci_read_config_dword(pdev, I82443BXGX_NBXCFG, &nbxcfg))\r\nreturn -EIO;\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = I82443BXGX_NR_CSROWS;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = I82443BXGX_NR_CHANS;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, 0);\r\nif (mci == NULL)\r\nreturn -ENOMEM;\r\nedac_dbg(0, "MC: mci = %p\n", mci);\r\nmci->pdev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_EDO | MEM_FLAG_SDR | MEM_FLAG_RDR;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_EC | EDAC_FLAG_SECDED;\r\npci_read_config_byte(pdev, I82443BXGX_DRAMC, &dramc);\r\nswitch ((dramc >> I82443BXGX_DRAMC_OFFSET_DT) & (BIT(0) | BIT(1))) {\r\ncase I82443BXGX_DRAMC_DRAM_IS_EDO:\r\nmtype = MEM_EDO;\r\nbreak;\r\ncase I82443BXGX_DRAMC_DRAM_IS_SDRAM:\r\nmtype = MEM_SDR;\r\nbreak;\r\ncase I82443BXGX_DRAMC_DRAM_IS_RSDRAM:\r\nmtype = MEM_RDR;\r\nbreak;\r\ndefault:\r\nedac_dbg(0, "Unknown/reserved DRAM type value in DRAMC register!\n");\r\nmtype = -MEM_UNKNOWN;\r\n}\r\nif ((mtype == MEM_SDR) || (mtype == MEM_RDR))\r\nmci->edac_cap = mci->edac_ctl_cap;\r\nelse\r\nmci->edac_cap = EDAC_FLAG_NONE;\r\nmci->scrub_cap = SCRUB_FLAG_HW_SRC;\r\npci_read_config_dword(pdev, I82443BXGX_NBXCFG, &nbxcfg);\r\necc_mode = ((nbxcfg >> I82443BXGX_NBXCFG_OFFSET_DRAM_INTEGRITY) &\r\n(BIT(0) | BIT(1)));\r\nmci->scrub_mode = (ecc_mode == I82443BXGX_NBXCFG_INTEGRITY_SCRUB)\r\n? SCRUB_HW_SRC : SCRUB_NONE;\r\nswitch (ecc_mode) {\r\ncase I82443BXGX_NBXCFG_INTEGRITY_NONE:\r\nedac_mode = EDAC_NONE;\r\nbreak;\r\ncase I82443BXGX_NBXCFG_INTEGRITY_EC:\r\nedac_mode = EDAC_EC;\r\nbreak;\r\ncase I82443BXGX_NBXCFG_INTEGRITY_ECC:\r\ncase I82443BXGX_NBXCFG_INTEGRITY_SCRUB:\r\nedac_mode = EDAC_SECDED;\r\nbreak;\r\ndefault:\r\nedac_dbg(0, "Unknown/reserved ECC state in NBXCFG register!\n");\r\nedac_mode = EDAC_UNKNOWN;\r\nbreak;\r\n}\r\ni82443bxgx_init_csrows(mci, pdev, edac_mode, mtype);\r\npci_write_bits32(pdev, I82443BXGX_EAP,\r\n(I82443BXGX_EAP_OFFSET_SBE |\r\nI82443BXGX_EAP_OFFSET_MBE),\r\n(I82443BXGX_EAP_OFFSET_SBE |\r\nI82443BXGX_EAP_OFFSET_MBE));\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = I82443_REVISION;\r\nmci->ctl_name = "I82443BXGX";\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = i82443bxgx_edacmc_check;\r\nmci->ctl_page_to_phys = NULL;\r\nif (edac_mc_add_mc(mci)) {\r\nedac_dbg(3, "failed edac_mc_add_mc()\n");\r\ngoto fail;\r\n}\r\ni82443bxgx_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\r\nif (!i82443bxgx_pci) {\r\nprintk(KERN_WARNING\r\n"%s(): Unable to create PCI control\n",\r\n__func__);\r\nprintk(KERN_WARNING\r\n"%s(): PCI error report via EDAC not setup\n",\r\n__func__);\r\n}\r\nedac_dbg(3, "MC: success\n");\r\nreturn 0;\r\nfail:\r\nedac_mc_free(mci);\r\nreturn -ENODEV;\r\n}\r\nstatic int __devinit i82443bxgx_edacmc_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint rc;\r\nedac_dbg(0, "MC:\n");\r\nrc = i82443bxgx_edacmc_probe1(pdev, ent->driver_data);\r\nif (mci_pdev == NULL)\r\nmci_pdev = pci_dev_get(pdev);\r\nreturn rc;\r\n}\r\nstatic void __devexit i82443bxgx_edacmc_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nedac_dbg(0, "\n");\r\nif (i82443bxgx_pci)\r\nedac_pci_release_generic_ctl(i82443bxgx_pci);\r\nif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\r\nreturn;\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init i82443bxgx_edacmc_init(void)\r\n{\r\nint pci_rc;\r\nopstate_init();\r\npci_rc = pci_register_driver(&i82443bxgx_edacmc_driver);\r\nif (pci_rc < 0)\r\ngoto fail0;\r\nif (mci_pdev == NULL) {\r\nconst struct pci_device_id *id = &i82443bxgx_pci_tbl[0];\r\nint i = 0;\r\ni82443bxgx_registered = 0;\r\nwhile (mci_pdev == NULL && id->vendor != 0) {\r\nmci_pdev = pci_get_device(id->vendor,\r\nid->device, NULL);\r\ni++;\r\nid = &i82443bxgx_pci_tbl[i];\r\n}\r\nif (!mci_pdev) {\r\nedac_dbg(0, "i82443bxgx pci_get_device fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\npci_rc = i82443bxgx_edacmc_init_one(mci_pdev, i82443bxgx_pci_tbl);\r\nif (pci_rc < 0) {\r\nedac_dbg(0, "i82443bxgx init fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\n}\r\nreturn 0;\r\nfail1:\r\npci_unregister_driver(&i82443bxgx_edacmc_driver);\r\nfail0:\r\nif (mci_pdev != NULL)\r\npci_dev_put(mci_pdev);\r\nreturn pci_rc;\r\n}\r\nstatic void __exit i82443bxgx_edacmc_exit(void)\r\n{\r\npci_unregister_driver(&i82443bxgx_edacmc_driver);\r\nif (!i82443bxgx_registered)\r\ni82443bxgx_edacmc_remove_one(mci_pdev);\r\nif (mci_pdev)\r\npci_dev_put(mci_pdev);\r\n}
