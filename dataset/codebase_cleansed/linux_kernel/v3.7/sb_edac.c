static char *get_dram_attr(u32 reg)\r\n{\r\nswitch(DRAM_ATTR(reg)) {\r\ncase 0:\r\nreturn "DRAM";\r\ncase 1:\r\nreturn "MMCFG";\r\ncase 2:\r\nreturn "NXM";\r\ndefault:\r\nreturn "unknown";\r\n}\r\n}\r\nstatic inline int sad_pkg(u32 reg, int interleave)\r\n{\r\nswitch (interleave) {\r\ncase 0:\r\nreturn SAD_PKG0(reg);\r\ncase 1:\r\nreturn SAD_PKG1(reg);\r\ncase 2:\r\nreturn SAD_PKG2(reg);\r\ncase 3:\r\nreturn SAD_PKG3(reg);\r\ncase 4:\r\nreturn SAD_PKG4(reg);\r\ncase 5:\r\nreturn SAD_PKG5(reg);\r\ncase 6:\r\nreturn SAD_PKG6(reg);\r\ncase 7:\r\nreturn SAD_PKG7(reg);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline int numrank(u32 mtr)\r\n{\r\nint ranks = (1 << RANK_CNT_BITS(mtr));\r\nif (ranks > 4) {\r\nedac_dbg(0, "Invalid number of ranks: %d (max = 4) raw value = %x (%04x)\n",\r\nranks, (unsigned int)RANK_CNT_BITS(mtr), mtr);\r\nreturn -EINVAL;\r\n}\r\nreturn ranks;\r\n}\r\nstatic inline int numrow(u32 mtr)\r\n{\r\nint rows = (RANK_WIDTH_BITS(mtr) + 12);\r\nif (rows < 13 || rows > 18) {\r\nedac_dbg(0, "Invalid number of rows: %d (should be between 14 and 17) raw value = %x (%04x)\n",\r\nrows, (unsigned int)RANK_WIDTH_BITS(mtr), mtr);\r\nreturn -EINVAL;\r\n}\r\nreturn 1 << rows;\r\n}\r\nstatic inline int numcol(u32 mtr)\r\n{\r\nint cols = (COL_WIDTH_BITS(mtr) + 10);\r\nif (cols > 12) {\r\nedac_dbg(0, "Invalid number of cols: %d (max = 4) raw value = %x (%04x)\n",\r\ncols, (unsigned int)COL_WIDTH_BITS(mtr), mtr);\r\nreturn -EINVAL;\r\n}\r\nreturn 1 << cols;\r\n}\r\nstatic struct sbridge_dev *get_sbridge_dev(u8 bus)\r\n{\r\nstruct sbridge_dev *sbridge_dev;\r\nlist_for_each_entry(sbridge_dev, &sbridge_edac_list, list) {\r\nif (sbridge_dev->bus == bus)\r\nreturn sbridge_dev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sbridge_dev *alloc_sbridge_dev(u8 bus,\r\nconst struct pci_id_table *table)\r\n{\r\nstruct sbridge_dev *sbridge_dev;\r\nsbridge_dev = kzalloc(sizeof(*sbridge_dev), GFP_KERNEL);\r\nif (!sbridge_dev)\r\nreturn NULL;\r\nsbridge_dev->pdev = kzalloc(sizeof(*sbridge_dev->pdev) * table->n_devs,\r\nGFP_KERNEL);\r\nif (!sbridge_dev->pdev) {\r\nkfree(sbridge_dev);\r\nreturn NULL;\r\n}\r\nsbridge_dev->bus = bus;\r\nsbridge_dev->n_devs = table->n_devs;\r\nlist_add_tail(&sbridge_dev->list, &sbridge_edac_list);\r\nreturn sbridge_dev;\r\n}\r\nstatic void free_sbridge_dev(struct sbridge_dev *sbridge_dev)\r\n{\r\nlist_del(&sbridge_dev->list);\r\nkfree(sbridge_dev->pdev);\r\nkfree(sbridge_dev);\r\n}\r\nstatic struct pci_dev *get_pdev_slot_func(u8 bus, unsigned slot,\r\nunsigned func)\r\n{\r\nstruct sbridge_dev *sbridge_dev = get_sbridge_dev(bus);\r\nint i;\r\nif (!sbridge_dev)\r\nreturn NULL;\r\nfor (i = 0; i < sbridge_dev->n_devs; i++) {\r\nif (!sbridge_dev->pdev[i])\r\ncontinue;\r\nif (PCI_SLOT(sbridge_dev->pdev[i]->devfn) == slot &&\r\nPCI_FUNC(sbridge_dev->pdev[i]->devfn) == func) {\r\nedac_dbg(1, "Associated %02x.%02x.%d with %p\n",\r\nbus, slot, func, sbridge_dev->pdev[i]);\r\nreturn sbridge_dev->pdev[i];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int check_if_ecc_is_active(const u8 bus)\r\n{\r\nstruct pci_dev *pdev = NULL;\r\nu32 mcmtr;\r\npdev = get_pdev_slot_func(bus, 15, 0);\r\nif (!pdev) {\r\nsbridge_printk(KERN_ERR, "Couldn't find PCI device "\r\n"%2x.%02d.%d!!!\n",\r\nbus, 15, 0);\r\nreturn -ENODEV;\r\n}\r\npci_read_config_dword(pdev, MCMTR, &mcmtr);\r\nif (!IS_ECC_ENABLED(mcmtr)) {\r\nsbridge_printk(KERN_ERR, "ECC is disabled. Aborting\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_dimm_config(struct mem_ctl_info *mci)\r\n{\r\nstruct sbridge_pvt *pvt = mci->pvt_info;\r\nstruct dimm_info *dimm;\r\nunsigned i, j, banks, ranks, rows, cols, npages;\r\nu64 size;\r\nu32 reg;\r\nenum edac_type mode;\r\nenum mem_type mtype;\r\npci_read_config_dword(pvt->pci_br, SAD_TARGET, &reg);\r\npvt->sbridge_dev->source_id = SOURCE_ID(reg);\r\npci_read_config_dword(pvt->pci_br, SAD_CONTROL, &reg);\r\npvt->sbridge_dev->node_id = NODE_ID(reg);\r\nedac_dbg(0, "mc#%d: Node ID: %d, source ID: %d\n",\r\npvt->sbridge_dev->mc,\r\npvt->sbridge_dev->node_id,\r\npvt->sbridge_dev->source_id);\r\npci_read_config_dword(pvt->pci_ras, RASENABLES, &reg);\r\nif (IS_MIRROR_ENABLED(reg)) {\r\nedac_dbg(0, "Memory mirror is enabled\n");\r\npvt->is_mirrored = true;\r\n} else {\r\nedac_dbg(0, "Memory mirror is disabled\n");\r\npvt->is_mirrored = false;\r\n}\r\npci_read_config_dword(pvt->pci_ta, MCMTR, &pvt->info.mcmtr);\r\nif (IS_LOCKSTEP_ENABLED(pvt->info.mcmtr)) {\r\nedac_dbg(0, "Lockstep is enabled\n");\r\nmode = EDAC_S8ECD8ED;\r\npvt->is_lockstep = true;\r\n} else {\r\nedac_dbg(0, "Lockstep is disabled\n");\r\nmode = EDAC_S4ECD4ED;\r\npvt->is_lockstep = false;\r\n}\r\nif (IS_CLOSE_PG(pvt->info.mcmtr)) {\r\nedac_dbg(0, "address map is on closed page mode\n");\r\npvt->is_close_pg = true;\r\n} else {\r\nedac_dbg(0, "address map is on open page mode\n");\r\npvt->is_close_pg = false;\r\n}\r\npci_read_config_dword(pvt->pci_ddrio, RANK_CFG_A, &reg);\r\nif (IS_RDIMM_ENABLED(reg)) {\r\nedac_dbg(0, "Memory is registered\n");\r\nmtype = MEM_RDDR3;\r\n} else {\r\nedac_dbg(0, "Memory is unregistered\n");\r\nmtype = MEM_DDR3;\r\n}\r\nbanks = 8;\r\nfor (i = 0; i < NUM_CHANNELS; i++) {\r\nu32 mtr;\r\nfor (j = 0; j < ARRAY_SIZE(mtr_regs); j++) {\r\ndimm = EDAC_DIMM_PTR(mci->layers, mci->dimms, mci->n_layers,\r\ni, j, 0);\r\npci_read_config_dword(pvt->pci_tad[i],\r\nmtr_regs[j], &mtr);\r\nedac_dbg(4, "Channel #%d MTR%d = %x\n", i, j, mtr);\r\nif (IS_DIMM_PRESENT(mtr)) {\r\npvt->channel[i].dimms++;\r\nranks = numrank(mtr);\r\nrows = numrow(mtr);\r\ncols = numcol(mtr);\r\nsize = ((u64)rows * cols * banks * ranks) >> (20 - 3);\r\nnpages = MiB_TO_PAGES(size);\r\nedac_dbg(0, "mc#%d: channel %d, dimm %d, %Ld Mb (%d pages) bank: %d, rank: %d, row: %#x, col: %#x\n",\r\npvt->sbridge_dev->mc, i, j,\r\nsize, npages,\r\nbanks, ranks, rows, cols);\r\ndimm->nr_pages = npages;\r\ndimm->grain = 32;\r\ndimm->dtype = (banks == 8) ? DEV_X8 : DEV_X4;\r\ndimm->mtype = mtype;\r\ndimm->edac_mode = mode;\r\nsnprintf(dimm->label, sizeof(dimm->label),\r\n"CPU_SrcID#%u_Channel#%u_DIMM#%u",\r\npvt->sbridge_dev->source_id, i, j);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void get_memory_layout(const struct mem_ctl_info *mci)\r\n{\r\nstruct sbridge_pvt *pvt = mci->pvt_info;\r\nint i, j, k, n_sads, n_tads, sad_interl;\r\nu32 reg;\r\nu64 limit, prv = 0;\r\nu64 tmp_mb;\r\nu32 mb, kb;\r\nu32 rir_way;\r\npci_read_config_dword(pvt->pci_sad1, TOLM,\r\n&reg);\r\npvt->tolm = GET_TOLM(reg);\r\ntmp_mb = (1 + pvt->tolm) >> 20;\r\nmb = div_u64_rem(tmp_mb, 1000, &kb);\r\nedac_dbg(0, "TOLM: %u.%03u GB (0x%016Lx)\n", mb, kb, (u64)pvt->tolm);\r\npci_read_config_dword(pvt->pci_sad1, TOHM,\r\n&reg);\r\npvt->tohm = GET_TOHM(reg);\r\ntmp_mb = (1 + pvt->tohm) >> 20;\r\nmb = div_u64_rem(tmp_mb, 1000, &kb);\r\nedac_dbg(0, "TOHM: %u.%03u GB (0x%016Lx)", mb, kb, (u64)pvt->tohm);\r\nprv = 0;\r\nfor (n_sads = 0; n_sads < MAX_SAD; n_sads++) {\r\npci_read_config_dword(pvt->pci_sad0, dram_rule[n_sads],\r\n&reg);\r\nlimit = SAD_LIMIT(reg);\r\nif (!DRAM_RULE_ENABLE(reg))\r\ncontinue;\r\nif (limit <= prv)\r\nbreak;\r\ntmp_mb = (limit + 1) >> 20;\r\nmb = div_u64_rem(tmp_mb, 1000, &kb);\r\nedac_dbg(0, "SAD#%d %s up to %u.%03u GB (0x%016Lx) Interleave: %s reg=0x%08x\n",\r\nn_sads,\r\nget_dram_attr(reg),\r\nmb, kb,\r\n((u64)tmp_mb) << 20L,\r\nINTERLEAVE_MODE(reg) ? "8:6" : "[8:6]XOR[18:16]",\r\nreg);\r\nprv = limit;\r\npci_read_config_dword(pvt->pci_sad0, interleave_list[n_sads],\r\n&reg);\r\nsad_interl = sad_pkg(reg, 0);\r\nfor (j = 0; j < 8; j++) {\r\nif (j > 0 && sad_interl == sad_pkg(reg, j))\r\nbreak;\r\nedac_dbg(0, "SAD#%d, interleave #%d: %d\n",\r\nn_sads, j, sad_pkg(reg, j));\r\n}\r\n}\r\nprv = 0;\r\nfor (n_tads = 0; n_tads < MAX_TAD; n_tads++) {\r\npci_read_config_dword(pvt->pci_ha0, tad_dram_rule[n_tads],\r\n&reg);\r\nlimit = TAD_LIMIT(reg);\r\nif (limit <= prv)\r\nbreak;\r\ntmp_mb = (limit + 1) >> 20;\r\nmb = div_u64_rem(tmp_mb, 1000, &kb);\r\nedac_dbg(0, "TAD#%d: up to %u.%03u GB (0x%016Lx), socket interleave %d, memory interleave %d, TGT: %d, %d, %d, %d, reg=0x%08x\n",\r\nn_tads, mb, kb,\r\n((u64)tmp_mb) << 20L,\r\n(u32)TAD_SOCK(reg),\r\n(u32)TAD_CH(reg),\r\n(u32)TAD_TGT0(reg),\r\n(u32)TAD_TGT1(reg),\r\n(u32)TAD_TGT2(reg),\r\n(u32)TAD_TGT3(reg),\r\nreg);\r\nprv = limit;\r\n}\r\nfor (i = 0; i < NUM_CHANNELS; i++) {\r\nif (!pvt->channel[i].dimms)\r\ncontinue;\r\nfor (j = 0; j < n_tads; j++) {\r\npci_read_config_dword(pvt->pci_tad[i],\r\ntad_ch_nilv_offset[j],\r\n&reg);\r\ntmp_mb = TAD_OFFSET(reg) >> 20;\r\nmb = div_u64_rem(tmp_mb, 1000, &kb);\r\nedac_dbg(0, "TAD CH#%d, offset #%d: %u.%03u GB (0x%016Lx), reg=0x%08x\n",\r\ni, j,\r\nmb, kb,\r\n((u64)tmp_mb) << 20L,\r\nreg);\r\n}\r\n}\r\nfor (i = 0; i < NUM_CHANNELS; i++) {\r\nif (!pvt->channel[i].dimms)\r\ncontinue;\r\nfor (j = 0; j < MAX_RIR_RANGES; j++) {\r\npci_read_config_dword(pvt->pci_tad[i],\r\nrir_way_limit[j],\r\n&reg);\r\nif (!IS_RIR_VALID(reg))\r\ncontinue;\r\ntmp_mb = RIR_LIMIT(reg) >> 20;\r\nrir_way = 1 << RIR_WAY(reg);\r\nmb = div_u64_rem(tmp_mb, 1000, &kb);\r\nedac_dbg(0, "CH#%d RIR#%d, limit: %u.%03u GB (0x%016Lx), way: %d, reg=0x%08x\n",\r\ni, j,\r\nmb, kb,\r\n((u64)tmp_mb) << 20L,\r\nrir_way,\r\nreg);\r\nfor (k = 0; k < rir_way; k++) {\r\npci_read_config_dword(pvt->pci_tad[i],\r\nrir_offset[j][k],\r\n&reg);\r\ntmp_mb = RIR_OFFSET(reg) << 6;\r\nmb = div_u64_rem(tmp_mb, 1000, &kb);\r\nedac_dbg(0, "CH#%d RIR#%d INTL#%d, offset %u.%03u GB (0x%016Lx), tgt: %d, reg=0x%08x\n",\r\ni, j, k,\r\nmb, kb,\r\n((u64)tmp_mb) << 20L,\r\n(u32)RIR_RNK_TGT(reg),\r\nreg);\r\n}\r\n}\r\n}\r\n}\r\nstruct mem_ctl_info *get_mci_for_node_id(u8 node_id)\r\n{\r\nstruct sbridge_dev *sbridge_dev;\r\nlist_for_each_entry(sbridge_dev, &sbridge_edac_list, list) {\r\nif (sbridge_dev->node_id == node_id)\r\nreturn sbridge_dev->mci;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int get_memory_error_data(struct mem_ctl_info *mci,\r\nu64 addr,\r\nu8 *socket,\r\nlong *channel_mask,\r\nu8 *rank,\r\nchar **area_type, char *msg)\r\n{\r\nstruct mem_ctl_info *new_mci;\r\nstruct sbridge_pvt *pvt = mci->pvt_info;\r\nint n_rir, n_sads, n_tads, sad_way, sck_xch;\r\nint sad_interl, idx, base_ch;\r\nint interleave_mode;\r\nunsigned sad_interleave[MAX_INTERLEAVE];\r\nu32 reg;\r\nu8 ch_way,sck_way;\r\nu32 tad_offset;\r\nu32 rir_way;\r\nu32 mb, kb;\r\nu64 ch_addr, offset, limit, prv = 0;\r\nif ((addr > (u64) pvt->tolm) && (addr < (1LL << 32))) {\r\nsprintf(msg, "Error at TOLM area, on addr 0x%08Lx", addr);\r\nreturn -EINVAL;\r\n}\r\nif (addr >= (u64)pvt->tohm) {\r\nsprintf(msg, "Error at MMIOH area, on addr 0x%016Lx", addr);\r\nreturn -EINVAL;\r\n}\r\nfor (n_sads = 0; n_sads < MAX_SAD; n_sads++) {\r\npci_read_config_dword(pvt->pci_sad0, dram_rule[n_sads],\r\n&reg);\r\nif (!DRAM_RULE_ENABLE(reg))\r\ncontinue;\r\nlimit = SAD_LIMIT(reg);\r\nif (limit <= prv) {\r\nsprintf(msg, "Can't discover the memory socket");\r\nreturn -EINVAL;\r\n}\r\nif (addr <= limit)\r\nbreak;\r\nprv = limit;\r\n}\r\nif (n_sads == MAX_SAD) {\r\nsprintf(msg, "Can't discover the memory socket");\r\nreturn -EINVAL;\r\n}\r\n*area_type = get_dram_attr(reg);\r\ninterleave_mode = INTERLEAVE_MODE(reg);\r\npci_read_config_dword(pvt->pci_sad0, interleave_list[n_sads],\r\n&reg);\r\nsad_interl = sad_pkg(reg, 0);\r\nfor (sad_way = 0; sad_way < 8; sad_way++) {\r\nif (sad_way > 0 && sad_interl == sad_pkg(reg, sad_way))\r\nbreak;\r\nsad_interleave[sad_way] = sad_pkg(reg, sad_way);\r\nedac_dbg(0, "SAD interleave #%d: %d\n",\r\nsad_way, sad_interleave[sad_way]);\r\n}\r\nedac_dbg(0, "mc#%d: Error detected on SAD#%d: address 0x%016Lx < 0x%016Lx, Interleave [%d:6]%s\n",\r\npvt->sbridge_dev->mc,\r\nn_sads,\r\naddr,\r\nlimit,\r\nsad_way + 7,\r\ninterleave_mode ? "" : "XOR[18:16]");\r\nif (interleave_mode)\r\nidx = ((addr >> 6) ^ (addr >> 16)) & 7;\r\nelse\r\nidx = (addr >> 6) & 7;\r\nswitch (sad_way) {\r\ncase 1:\r\nidx = 0;\r\nbreak;\r\ncase 2:\r\nidx = idx & 1;\r\nbreak;\r\ncase 4:\r\nidx = idx & 3;\r\nbreak;\r\ncase 8:\r\nbreak;\r\ndefault:\r\nsprintf(msg, "Can't discover socket interleave");\r\nreturn -EINVAL;\r\n}\r\n*socket = sad_interleave[idx];\r\nedac_dbg(0, "SAD interleave index: %d (wayness %d) = CPU socket %d\n",\r\nidx, sad_way, *socket);\r\nnew_mci = get_mci_for_node_id(*socket);\r\nif (!new_mci) {\r\nsprintf(msg, "Struct for socket #%u wasn't initialized",\r\n*socket);\r\nreturn -EINVAL;\r\n}\r\nmci = new_mci;\r\npvt = mci->pvt_info;\r\nprv = 0;\r\nfor (n_tads = 0; n_tads < MAX_TAD; n_tads++) {\r\npci_read_config_dword(pvt->pci_ha0, tad_dram_rule[n_tads],\r\n&reg);\r\nlimit = TAD_LIMIT(reg);\r\nif (limit <= prv) {\r\nsprintf(msg, "Can't discover the memory channel");\r\nreturn -EINVAL;\r\n}\r\nif (addr <= limit)\r\nbreak;\r\nprv = limit;\r\n}\r\nch_way = TAD_CH(reg) + 1;\r\nsck_way = TAD_SOCK(reg) + 1;\r\npci_read_config_dword(pvt->pci_tad[0],\r\ntad_ch_nilv_offset[n_tads],\r\n&tad_offset);\r\nif (ch_way == 3)\r\nidx = addr >> 6;\r\nelse\r\nidx = addr >> (6 + sck_way);\r\nidx = idx % ch_way;\r\nswitch (idx) {\r\ncase 0:\r\nbase_ch = TAD_TGT0(reg);\r\nbreak;\r\ncase 1:\r\nbase_ch = TAD_TGT1(reg);\r\nbreak;\r\ncase 2:\r\nbase_ch = TAD_TGT2(reg);\r\nbreak;\r\ncase 3:\r\nbase_ch = TAD_TGT3(reg);\r\nbreak;\r\ndefault:\r\nsprintf(msg, "Can't discover the TAD target");\r\nreturn -EINVAL;\r\n}\r\n*channel_mask = 1 << base_ch;\r\nif (pvt->is_mirrored) {\r\n*channel_mask |= 1 << ((base_ch + 2) % 4);\r\nswitch(ch_way) {\r\ncase 2:\r\ncase 4:\r\nsck_xch = 1 << sck_way * (ch_way >> 1);\r\nbreak;\r\ndefault:\r\nsprintf(msg, "Invalid mirror set. Can't decode addr");\r\nreturn -EINVAL;\r\n}\r\n} else\r\nsck_xch = (1 << sck_way) * ch_way;\r\nif (pvt->is_lockstep)\r\n*channel_mask |= 1 << ((base_ch + 1) % 4);\r\noffset = TAD_OFFSET(tad_offset);\r\nedac_dbg(0, "TAD#%d: address 0x%016Lx < 0x%016Lx, socket interleave %d, channel interleave %d (offset 0x%08Lx), index %d, base ch: %d, ch mask: 0x%02lx\n",\r\nn_tads,\r\naddr,\r\nlimit,\r\n(u32)TAD_SOCK(reg),\r\nch_way,\r\noffset,\r\nidx,\r\nbase_ch,\r\n*channel_mask);\r\nif (offset > addr) {\r\nsprintf(msg, "Can't calculate ch addr: TAD offset 0x%08Lx is too high for addr 0x%08Lx!",\r\noffset, addr);\r\nreturn -EINVAL;\r\n}\r\naddr -= offset;\r\nch_addr = addr & 0x7f;\r\naddr >>= 6;\r\naddr = div_u64(addr, sck_xch);\r\n#if 0\r\naddr = addr / ch_way;\r\n#endif\r\nch_addr |= addr << 6;\r\nfor (n_rir = 0; n_rir < MAX_RIR_RANGES; n_rir++) {\r\npci_read_config_dword(pvt->pci_tad[base_ch],\r\nrir_way_limit[n_rir],\r\n&reg);\r\nif (!IS_RIR_VALID(reg))\r\ncontinue;\r\nlimit = RIR_LIMIT(reg);\r\nmb = div_u64_rem(limit >> 20, 1000, &kb);\r\nedac_dbg(0, "RIR#%d, limit: %u.%03u GB (0x%016Lx), way: %d\n",\r\nn_rir,\r\nmb, kb,\r\nlimit,\r\n1 << RIR_WAY(reg));\r\nif (ch_addr <= limit)\r\nbreak;\r\n}\r\nif (n_rir == MAX_RIR_RANGES) {\r\nsprintf(msg, "Can't discover the memory rank for ch addr 0x%08Lx",\r\nch_addr);\r\nreturn -EINVAL;\r\n}\r\nrir_way = RIR_WAY(reg);\r\nif (pvt->is_close_pg)\r\nidx = (ch_addr >> 6);\r\nelse\r\nidx = (ch_addr >> 13);\r\nidx %= 1 << rir_way;\r\npci_read_config_dword(pvt->pci_tad[base_ch],\r\nrir_offset[n_rir][idx],\r\n&reg);\r\n*rank = RIR_RNK_TGT(reg);\r\nedac_dbg(0, "RIR#%d: channel address 0x%08Lx < 0x%08Lx, RIR interleave %d, index %d\n",\r\nn_rir,\r\nch_addr,\r\nlimit,\r\nrir_way,\r\nidx);\r\nreturn 0;\r\n}\r\nstatic void sbridge_put_devices(struct sbridge_dev *sbridge_dev)\r\n{\r\nint i;\r\nedac_dbg(0, "\n");\r\nfor (i = 0; i < sbridge_dev->n_devs; i++) {\r\nstruct pci_dev *pdev = sbridge_dev->pdev[i];\r\nif (!pdev)\r\ncontinue;\r\nedac_dbg(0, "Removing dev %02x:%02x.%d\n",\r\npdev->bus->number,\r\nPCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\r\npci_dev_put(pdev);\r\n}\r\n}\r\nstatic void sbridge_put_all_devices(void)\r\n{\r\nstruct sbridge_dev *sbridge_dev, *tmp;\r\nlist_for_each_entry_safe(sbridge_dev, tmp, &sbridge_edac_list, list) {\r\nsbridge_put_devices(sbridge_dev);\r\nfree_sbridge_dev(sbridge_dev);\r\n}\r\n}\r\nstatic int sbridge_get_onedevice(struct pci_dev **prev,\r\nu8 *num_mc,\r\nconst struct pci_id_table *table,\r\nconst unsigned devno)\r\n{\r\nstruct sbridge_dev *sbridge_dev;\r\nconst struct pci_id_descr *dev_descr = &table->descr[devno];\r\nstruct pci_dev *pdev = NULL;\r\nu8 bus = 0;\r\nsbridge_printk(KERN_INFO,\r\n"Seeking for: dev %02x.%d PCI ID %04x:%04x\n",\r\ndev_descr->dev, dev_descr->func,\r\nPCI_VENDOR_ID_INTEL, dev_descr->dev_id);\r\npdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\ndev_descr->dev_id, *prev);\r\nif (!pdev) {\r\nif (*prev) {\r\n*prev = pdev;\r\nreturn 0;\r\n}\r\nif (dev_descr->optional)\r\nreturn 0;\r\nif (devno == 0)\r\nreturn -ENODEV;\r\nsbridge_printk(KERN_INFO,\r\n"Device not found: dev %02x.%d PCI ID %04x:%04x\n",\r\ndev_descr->dev, dev_descr->func,\r\nPCI_VENDOR_ID_INTEL, dev_descr->dev_id);\r\nreturn -ENODEV;\r\n}\r\nbus = pdev->bus->number;\r\nsbridge_dev = get_sbridge_dev(bus);\r\nif (!sbridge_dev) {\r\nsbridge_dev = alloc_sbridge_dev(bus, table);\r\nif (!sbridge_dev) {\r\npci_dev_put(pdev);\r\nreturn -ENOMEM;\r\n}\r\n(*num_mc)++;\r\n}\r\nif (sbridge_dev->pdev[devno]) {\r\nsbridge_printk(KERN_ERR,\r\n"Duplicated device for "\r\n"dev %02x:%d.%d PCI ID %04x:%04x\n",\r\nbus, dev_descr->dev, dev_descr->func,\r\nPCI_VENDOR_ID_INTEL, dev_descr->dev_id);\r\npci_dev_put(pdev);\r\nreturn -ENODEV;\r\n}\r\nsbridge_dev->pdev[devno] = pdev;\r\nif (unlikely(PCI_SLOT(pdev->devfn) != dev_descr->dev ||\r\nPCI_FUNC(pdev->devfn) != dev_descr->func)) {\r\nsbridge_printk(KERN_ERR,\r\n"Device PCI ID %04x:%04x "\r\n"has dev %02x:%d.%d instead of dev %02x:%02x.%d\n",\r\nPCI_VENDOR_ID_INTEL, dev_descr->dev_id,\r\nbus, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),\r\nbus, dev_descr->dev, dev_descr->func);\r\nreturn -ENODEV;\r\n}\r\nif (unlikely(pci_enable_device(pdev) < 0)) {\r\nsbridge_printk(KERN_ERR,\r\n"Couldn't enable "\r\n"dev %02x:%d.%d PCI ID %04x:%04x\n",\r\nbus, dev_descr->dev, dev_descr->func,\r\nPCI_VENDOR_ID_INTEL, dev_descr->dev_id);\r\nreturn -ENODEV;\r\n}\r\nedac_dbg(0, "Detected dev %02x:%d.%d PCI ID %04x:%04x\n",\r\nbus, dev_descr->dev, dev_descr->func,\r\nPCI_VENDOR_ID_INTEL, dev_descr->dev_id);\r\npci_dev_get(pdev);\r\n*prev = pdev;\r\nreturn 0;\r\n}\r\nstatic int sbridge_get_all_devices(u8 *num_mc)\r\n{\r\nint i, rc;\r\nstruct pci_dev *pdev = NULL;\r\nconst struct pci_id_table *table = pci_dev_descr_sbridge_table;\r\nwhile (table && table->descr) {\r\nfor (i = 0; i < table->n_devs; i++) {\r\npdev = NULL;\r\ndo {\r\nrc = sbridge_get_onedevice(&pdev, num_mc,\r\ntable, i);\r\nif (rc < 0) {\r\nif (i == 0) {\r\ni = table->n_devs;\r\nbreak;\r\n}\r\nsbridge_put_all_devices();\r\nreturn -ENODEV;\r\n}\r\n} while (pdev);\r\n}\r\ntable++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mci_bind_devs(struct mem_ctl_info *mci,\r\nstruct sbridge_dev *sbridge_dev)\r\n{\r\nstruct sbridge_pvt *pvt = mci->pvt_info;\r\nstruct pci_dev *pdev;\r\nint i, func, slot;\r\nfor (i = 0; i < sbridge_dev->n_devs; i++) {\r\npdev = sbridge_dev->pdev[i];\r\nif (!pdev)\r\ncontinue;\r\nslot = PCI_SLOT(pdev->devfn);\r\nfunc = PCI_FUNC(pdev->devfn);\r\nswitch (slot) {\r\ncase 12:\r\nswitch (func) {\r\ncase 6:\r\npvt->pci_sad0 = pdev;\r\nbreak;\r\ncase 7:\r\npvt->pci_sad1 = pdev;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase 13:\r\nswitch (func) {\r\ncase 6:\r\npvt->pci_br = pdev;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase 14:\r\nswitch (func) {\r\ncase 0:\r\npvt->pci_ha0 = pdev;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase 15:\r\nswitch (func) {\r\ncase 0:\r\npvt->pci_ta = pdev;\r\nbreak;\r\ncase 1:\r\npvt->pci_ras = pdev;\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\ncase 5:\r\npvt->pci_tad[func - 2] = pdev;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase 17:\r\nswitch (func) {\r\ncase 0:\r\npvt->pci_ddrio = pdev;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nedac_dbg(0, "Associated PCI %02x.%02d.%d with dev = %p\n",\r\nsbridge_dev->bus,\r\nPCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),\r\npdev);\r\n}\r\nif (!pvt->pci_sad0 || !pvt->pci_sad1 || !pvt->pci_ha0 ||\r\n!pvt-> pci_tad || !pvt->pci_ras || !pvt->pci_ta ||\r\n!pvt->pci_ddrio)\r\ngoto enodev;\r\nfor (i = 0; i < NUM_CHANNELS; i++) {\r\nif (!pvt->pci_tad[i])\r\ngoto enodev;\r\n}\r\nreturn 0;\r\nenodev:\r\nsbridge_printk(KERN_ERR, "Some needed devices are missing\n");\r\nreturn -ENODEV;\r\nerror:\r\nsbridge_printk(KERN_ERR, "Device %d, function %d "\r\n"is out of the expected range\n",\r\nslot, func);\r\nreturn -EINVAL;\r\n}\r\nstatic void sbridge_mce_output_error(struct mem_ctl_info *mci,\r\nconst struct mce *m)\r\n{\r\nstruct mem_ctl_info *new_mci;\r\nstruct sbridge_pvt *pvt = mci->pvt_info;\r\nenum hw_event_mc_err_type tp_event;\r\nchar *type, *optype, msg[256];\r\nbool ripv = GET_BITFIELD(m->mcgstatus, 0, 0);\r\nbool overflow = GET_BITFIELD(m->status, 62, 62);\r\nbool uncorrected_error = GET_BITFIELD(m->status, 61, 61);\r\nbool recoverable = GET_BITFIELD(m->status, 56, 56);\r\nu32 core_err_cnt = GET_BITFIELD(m->status, 38, 52);\r\nu32 mscod = GET_BITFIELD(m->status, 16, 31);\r\nu32 errcode = GET_BITFIELD(m->status, 0, 15);\r\nu32 channel = GET_BITFIELD(m->status, 0, 3);\r\nu32 optypenum = GET_BITFIELD(m->status, 4, 6);\r\nlong channel_mask, first_channel;\r\nu8 rank, socket;\r\nint rc, dimm;\r\nchar *area_type = NULL;\r\nif (uncorrected_error) {\r\nif (ripv) {\r\ntype = "FATAL";\r\ntp_event = HW_EVENT_ERR_FATAL;\r\n} else {\r\ntype = "NON_FATAL";\r\ntp_event = HW_EVENT_ERR_UNCORRECTED;\r\n}\r\n} else {\r\ntype = "CORRECTED";\r\ntp_event = HW_EVENT_ERR_CORRECTED;\r\n}\r\nif (! ((errcode & 0xef80) == 0x80)) {\r\noptype = "Can't parse: it is not a mem";\r\n} else {\r\nswitch (optypenum) {\r\ncase 0:\r\noptype = "generic undef request error";\r\nbreak;\r\ncase 1:\r\noptype = "memory read error";\r\nbreak;\r\ncase 2:\r\noptype = "memory write error";\r\nbreak;\r\ncase 3:\r\noptype = "addr/cmd error";\r\nbreak;\r\ncase 4:\r\noptype = "memory scrubbing error";\r\nbreak;\r\ndefault:\r\noptype = "reserved";\r\nbreak;\r\n}\r\n}\r\nrc = get_memory_error_data(mci, m->addr, &socket,\r\n&channel_mask, &rank, &area_type, msg);\r\nif (rc < 0)\r\ngoto err_parsing;\r\nnew_mci = get_mci_for_node_id(socket);\r\nif (!new_mci) {\r\nstrcpy(msg, "Error: socket got corrupted!");\r\ngoto err_parsing;\r\n}\r\nmci = new_mci;\r\npvt = mci->pvt_info;\r\nfirst_channel = find_first_bit(&channel_mask, NUM_CHANNELS);\r\nif (rank < 4)\r\ndimm = 0;\r\nelse if (rank < 8)\r\ndimm = 1;\r\nelse\r\ndimm = 2;\r\nsnprintf(msg, sizeof(msg),\r\n"%s%s area:%s err_code:%04x:%04x socket:%d channel_mask:%ld rank:%d",\r\noverflow ? " OVERFLOW" : "",\r\n(uncorrected_error && recoverable) ? " recoverable" : "",\r\narea_type,\r\nmscod, errcode,\r\nsocket,\r\nchannel_mask,\r\nrank);\r\nedac_dbg(0, "%s\n", msg);\r\nedac_mc_handle_error(tp_event, mci, core_err_cnt,\r\nm->addr >> PAGE_SHIFT, m->addr & ~PAGE_MASK, 0,\r\nchannel, dimm, -1,\r\noptype, msg);\r\nreturn;\r\nerr_parsing:\r\nedac_mc_handle_error(tp_event, mci, core_err_cnt, 0, 0, 0,\r\n-1, -1, -1,\r\nmsg, "");\r\n}\r\nstatic void sbridge_check_error(struct mem_ctl_info *mci)\r\n{\r\nstruct sbridge_pvt *pvt = mci->pvt_info;\r\nint i;\r\nunsigned count = 0;\r\nstruct mce *m;\r\nsmp_rmb();\r\ncount = (pvt->mce_out + MCE_LOG_LEN - pvt->mce_in)\r\n% MCE_LOG_LEN;\r\nif (!count)\r\nreturn;\r\nm = pvt->mce_outentry;\r\nif (pvt->mce_in + count > MCE_LOG_LEN) {\r\nunsigned l = MCE_LOG_LEN - pvt->mce_in;\r\nmemcpy(m, &pvt->mce_entry[pvt->mce_in], sizeof(*m) * l);\r\nsmp_wmb();\r\npvt->mce_in = 0;\r\ncount -= l;\r\nm += l;\r\n}\r\nmemcpy(m, &pvt->mce_entry[pvt->mce_in], sizeof(*m) * count);\r\nsmp_wmb();\r\npvt->mce_in += count;\r\nsmp_rmb();\r\nif (pvt->mce_overrun) {\r\nsbridge_printk(KERN_ERR, "Lost %d memory errors\n",\r\npvt->mce_overrun);\r\nsmp_wmb();\r\npvt->mce_overrun = 0;\r\n}\r\nfor (i = 0; i < count; i++)\r\nsbridge_mce_output_error(mci, &pvt->mce_outentry[i]);\r\n}\r\nstatic int sbridge_mce_check_error(struct notifier_block *nb, unsigned long val,\r\nvoid *data)\r\n{\r\nstruct mce *mce = (struct mce *)data;\r\nstruct mem_ctl_info *mci;\r\nstruct sbridge_pvt *pvt;\r\nmci = get_mci_for_node_id(mce->socketid);\r\nif (!mci)\r\nreturn NOTIFY_BAD;\r\npvt = mci->pvt_info;\r\nif ((mce->status & 0xefff) >> 7 != 1)\r\nreturn NOTIFY_DONE;\r\nprintk("sbridge: HANDLING MCE MEMORY ERROR\n");\r\nprintk("CPU %d: Machine Check Exception: %Lx Bank %d: %016Lx\n",\r\nmce->extcpu, mce->mcgstatus, mce->bank, mce->status);\r\nprintk("TSC %llx ", mce->tsc);\r\nprintk("ADDR %llx ", mce->addr);\r\nprintk("MISC %llx ", mce->misc);\r\nprintk("PROCESSOR %u:%x TIME %llu SOCKET %u APIC %x\n",\r\nmce->cpuvendor, mce->cpuid, mce->time,\r\nmce->socketid, mce->apicid);\r\nif (cpu_data(mce->cpu).phys_proc_id != pvt->sbridge_dev->mc)\r\nreturn NOTIFY_DONE;\r\nsmp_rmb();\r\nif ((pvt->mce_out + 1) % MCE_LOG_LEN == pvt->mce_in) {\r\nsmp_wmb();\r\npvt->mce_overrun++;\r\nreturn NOTIFY_DONE;\r\n}\r\nmemcpy(&pvt->mce_entry[pvt->mce_out], mce, sizeof(*mce));\r\nsmp_wmb();\r\npvt->mce_out = (pvt->mce_out + 1) % MCE_LOG_LEN;\r\nif (mce->mcgstatus & 1)\r\nsbridge_check_error(mci);\r\nreturn NOTIFY_STOP;\r\n}\r\nstatic void sbridge_unregister_mci(struct sbridge_dev *sbridge_dev)\r\n{\r\nstruct mem_ctl_info *mci = sbridge_dev->mci;\r\nstruct sbridge_pvt *pvt;\r\nif (unlikely(!mci || !mci->pvt_info)) {\r\nedac_dbg(0, "MC: dev = %p\n", &sbridge_dev->pdev[0]->dev);\r\nsbridge_printk(KERN_ERR, "Couldn't find mci handler\n");\r\nreturn;\r\n}\r\npvt = mci->pvt_info;\r\nedac_dbg(0, "MC: mci = %p, dev = %p\n",\r\nmci, &sbridge_dev->pdev[0]->dev);\r\nedac_mc_del_mc(mci->pdev);\r\nedac_dbg(1, "%s: free mci struct\n", mci->ctl_name);\r\nkfree(mci->ctl_name);\r\nedac_mc_free(mci);\r\nsbridge_dev->mci = NULL;\r\n}\r\nstatic int sbridge_register_mci(struct sbridge_dev *sbridge_dev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nstruct sbridge_pvt *pvt;\r\nint rc;\r\nrc = check_if_ecc_is_active(sbridge_dev->bus);\r\nif (unlikely(rc < 0))\r\nreturn rc;\r\nlayers[0].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[0].size = NUM_CHANNELS;\r\nlayers[0].is_virt_csrow = false;\r\nlayers[1].type = EDAC_MC_LAYER_SLOT;\r\nlayers[1].size = MAX_DIMMS;\r\nlayers[1].is_virt_csrow = true;\r\nmci = edac_mc_alloc(sbridge_dev->mc, ARRAY_SIZE(layers), layers,\r\nsizeof(*pvt));\r\nif (unlikely(!mci))\r\nreturn -ENOMEM;\r\nedac_dbg(0, "MC: mci = %p, dev = %p\n",\r\nmci, &sbridge_dev->pdev[0]->dev);\r\npvt = mci->pvt_info;\r\nmemset(pvt, 0, sizeof(*pvt));\r\npvt->sbridge_dev = sbridge_dev;\r\nsbridge_dev->mci = mci;\r\nmci->mtype_cap = MEM_FLAG_DDR3;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE;\r\nmci->edac_cap = EDAC_FLAG_NONE;\r\nmci->mod_name = "sbridge_edac.c";\r\nmci->mod_ver = SBRIDGE_REVISION;\r\nmci->ctl_name = kasprintf(GFP_KERNEL, "Sandy Bridge Socket#%d", mci->mc_idx);\r\nmci->dev_name = pci_name(sbridge_dev->pdev[0]);\r\nmci->ctl_page_to_phys = NULL;\r\nmci->edac_check = sbridge_check_error;\r\nrc = mci_bind_devs(mci, sbridge_dev);\r\nif (unlikely(rc < 0))\r\ngoto fail0;\r\nget_dimm_config(mci);\r\nget_memory_layout(mci);\r\nmci->pdev = &sbridge_dev->pdev[0]->dev;\r\nif (unlikely(edac_mc_add_mc(mci))) {\r\nedac_dbg(0, "MC: failed edac_mc_add_mc()\n");\r\nrc = -EINVAL;\r\ngoto fail0;\r\n}\r\nreturn 0;\r\nfail0:\r\nkfree(mci->ctl_name);\r\nedac_mc_free(mci);\r\nsbridge_dev->mci = NULL;\r\nreturn rc;\r\n}\r\nstatic int __devinit sbridge_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint rc;\r\nu8 mc, num_mc = 0;\r\nstruct sbridge_dev *sbridge_dev;\r\nmutex_lock(&sbridge_edac_lock);\r\nif (unlikely(probed >= 1)) {\r\nmutex_unlock(&sbridge_edac_lock);\r\nreturn -ENODEV;\r\n}\r\nprobed++;\r\nrc = sbridge_get_all_devices(&num_mc);\r\nif (unlikely(rc < 0))\r\ngoto fail0;\r\nmc = 0;\r\nlist_for_each_entry(sbridge_dev, &sbridge_edac_list, list) {\r\nedac_dbg(0, "Registering MC#%d (%d of %d)\n",\r\nmc, mc + 1, num_mc);\r\nsbridge_dev->mc = mc++;\r\nrc = sbridge_register_mci(sbridge_dev);\r\nif (unlikely(rc < 0))\r\ngoto fail1;\r\n}\r\nsbridge_printk(KERN_INFO, "Driver loaded.\n");\r\nmutex_unlock(&sbridge_edac_lock);\r\nreturn 0;\r\nfail1:\r\nlist_for_each_entry(sbridge_dev, &sbridge_edac_list, list)\r\nsbridge_unregister_mci(sbridge_dev);\r\nsbridge_put_all_devices();\r\nfail0:\r\nmutex_unlock(&sbridge_edac_lock);\r\nreturn rc;\r\n}\r\nstatic void __devexit sbridge_remove(struct pci_dev *pdev)\r\n{\r\nstruct sbridge_dev *sbridge_dev;\r\nedac_dbg(0, "\n");\r\nmutex_lock(&sbridge_edac_lock);\r\nif (unlikely(!probed)) {\r\nmutex_unlock(&sbridge_edac_lock);\r\nreturn;\r\n}\r\nlist_for_each_entry(sbridge_dev, &sbridge_edac_list, list)\r\nsbridge_unregister_mci(sbridge_dev);\r\nsbridge_put_all_devices();\r\nprobed--;\r\nmutex_unlock(&sbridge_edac_lock);\r\n}\r\nstatic int __init sbridge_init(void)\r\n{\r\nint pci_rc;\r\nedac_dbg(2, "\n");\r\nopstate_init();\r\npci_rc = pci_register_driver(&sbridge_driver);\r\nif (pci_rc >= 0) {\r\nmce_register_decode_chain(&sbridge_mce_dec);\r\nreturn 0;\r\n}\r\nsbridge_printk(KERN_ERR, "Failed to register device with error %d.\n",\r\npci_rc);\r\nreturn pci_rc;\r\n}\r\nstatic void __exit sbridge_exit(void)\r\n{\r\nedac_dbg(2, "\n");\r\npci_unregister_driver(&sbridge_driver);\r\nmce_unregister_decode_chain(&sbridge_mce_dec);\r\n}
