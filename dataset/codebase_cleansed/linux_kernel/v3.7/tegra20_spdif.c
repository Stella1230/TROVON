static int tegra20_spdif_runtime_suspend(struct device *dev)\r\n{\r\nstruct tegra20_spdif *spdif = dev_get_drvdata(dev);\r\nclk_disable_unprepare(spdif->clk_spdif_out);\r\nreturn 0;\r\n}\r\nstatic int tegra20_spdif_runtime_resume(struct device *dev)\r\n{\r\nstruct tegra20_spdif *spdif = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(spdif->clk_spdif_out);\r\nif (ret) {\r\ndev_err(dev, "clk_enable failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra20_spdif_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct device *dev = dai->dev;\r\nstruct tegra20_spdif *spdif = snd_soc_dai_get_drvdata(dai);\r\nunsigned int mask, val;\r\nint ret, spdifclock;\r\nmask = TEGRA20_SPDIF_CTRL_PACK |\r\nTEGRA20_SPDIF_CTRL_BIT_MODE_MASK;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nval = TEGRA20_SPDIF_CTRL_PACK |\r\nTEGRA20_SPDIF_CTRL_BIT_MODE_16BIT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(spdif->regmap, TEGRA20_SPDIF_CTRL, mask, val);\r\nswitch (params_rate(params)) {\r\ncase 32000:\r\nspdifclock = 4096000;\r\nbreak;\r\ncase 44100:\r\nspdifclock = 5644800;\r\nbreak;\r\ncase 48000:\r\nspdifclock = 6144000;\r\nbreak;\r\ncase 88200:\r\nspdifclock = 11289600;\r\nbreak;\r\ncase 96000:\r\nspdifclock = 12288000;\r\nbreak;\r\ncase 176400:\r\nspdifclock = 22579200;\r\nbreak;\r\ncase 192000:\r\nspdifclock = 24576000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = clk_set_rate(spdif->clk_spdif_out, spdifclock);\r\nif (ret) {\r\ndev_err(dev, "Can't set SPDIF clock rate: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tegra20_spdif_start_playback(struct tegra20_spdif *spdif)\r\n{\r\nregmap_update_bits(spdif->regmap, TEGRA20_SPDIF_CTRL,\r\nTEGRA20_SPDIF_CTRL_TX_EN,\r\nTEGRA20_SPDIF_CTRL_TX_EN);\r\n}\r\nstatic void tegra20_spdif_stop_playback(struct tegra20_spdif *spdif)\r\n{\r\nregmap_update_bits(spdif->regmap, TEGRA20_SPDIF_CTRL,\r\nTEGRA20_SPDIF_CTRL_TX_EN, 0);\r\n}\r\nstatic int tegra20_spdif_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct tegra20_spdif *spdif = snd_soc_dai_get_drvdata(dai);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ntegra20_spdif_start_playback(spdif);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ntegra20_spdif_stop_playback(spdif);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra20_spdif_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct tegra20_spdif *spdif = snd_soc_dai_get_drvdata(dai);\r\ndai->capture_dma_data = NULL;\r\ndai->playback_dma_data = &spdif->playback_dma_data;\r\nreturn 0;\r\n}\r\nstatic bool tegra20_spdif_wr_rd_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TEGRA20_SPDIF_CTRL:\r\ncase TEGRA20_SPDIF_STATUS:\r\ncase TEGRA20_SPDIF_STROBE_CTRL:\r\ncase TEGRA20_SPDIF_DATA_FIFO_CSR:\r\ncase TEGRA20_SPDIF_DATA_OUT:\r\ncase TEGRA20_SPDIF_DATA_IN:\r\ncase TEGRA20_SPDIF_CH_STA_RX_A:\r\ncase TEGRA20_SPDIF_CH_STA_RX_B:\r\ncase TEGRA20_SPDIF_CH_STA_RX_C:\r\ncase TEGRA20_SPDIF_CH_STA_RX_D:\r\ncase TEGRA20_SPDIF_CH_STA_RX_E:\r\ncase TEGRA20_SPDIF_CH_STA_RX_F:\r\ncase TEGRA20_SPDIF_CH_STA_TX_A:\r\ncase TEGRA20_SPDIF_CH_STA_TX_B:\r\ncase TEGRA20_SPDIF_CH_STA_TX_C:\r\ncase TEGRA20_SPDIF_CH_STA_TX_D:\r\ncase TEGRA20_SPDIF_CH_STA_TX_E:\r\ncase TEGRA20_SPDIF_CH_STA_TX_F:\r\ncase TEGRA20_SPDIF_USR_STA_RX_A:\r\ncase TEGRA20_SPDIF_USR_DAT_TX_A:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n};\r\n}\r\nstatic bool tegra20_spdif_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TEGRA20_SPDIF_STATUS:\r\ncase TEGRA20_SPDIF_DATA_FIFO_CSR:\r\ncase TEGRA20_SPDIF_DATA_OUT:\r\ncase TEGRA20_SPDIF_DATA_IN:\r\ncase TEGRA20_SPDIF_CH_STA_RX_A:\r\ncase TEGRA20_SPDIF_CH_STA_RX_B:\r\ncase TEGRA20_SPDIF_CH_STA_RX_C:\r\ncase TEGRA20_SPDIF_CH_STA_RX_D:\r\ncase TEGRA20_SPDIF_CH_STA_RX_E:\r\ncase TEGRA20_SPDIF_CH_STA_RX_F:\r\ncase TEGRA20_SPDIF_USR_STA_RX_A:\r\ncase TEGRA20_SPDIF_USR_DAT_TX_A:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n};\r\n}\r\nstatic bool tegra20_spdif_precious_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TEGRA20_SPDIF_DATA_OUT:\r\ncase TEGRA20_SPDIF_DATA_IN:\r\ncase TEGRA20_SPDIF_USR_STA_RX_A:\r\ncase TEGRA20_SPDIF_USR_DAT_TX_A:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n};\r\n}\r\nstatic __devinit int tegra20_spdif_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra20_spdif *spdif;\r\nstruct resource *mem, *memregion, *dmareq;\r\nvoid __iomem *regs;\r\nint ret;\r\nspdif = devm_kzalloc(&pdev->dev, sizeof(struct tegra20_spdif),\r\nGFP_KERNEL);\r\nif (!spdif) {\r\ndev_err(&pdev->dev, "Can't allocate tegra20_spdif\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev_set_drvdata(&pdev->dev, spdif);\r\nspdif->clk_spdif_out = clk_get(&pdev->dev, "spdif_out");\r\nif (IS_ERR(spdif->clk_spdif_out)) {\r\npr_err("Can't retrieve spdif clock\n");\r\nret = PTR_ERR(spdif->clk_spdif_out);\r\ngoto err;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "No memory resource\n");\r\nret = -ENODEV;\r\ngoto err_clk_put;\r\n}\r\ndmareq = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!dmareq) {\r\ndev_err(&pdev->dev, "No DMA resource\n");\r\nret = -ENODEV;\r\ngoto err_clk_put;\r\n}\r\nmemregion = devm_request_mem_region(&pdev->dev, mem->start,\r\nresource_size(mem), DRV_NAME);\r\nif (!memregion) {\r\ndev_err(&pdev->dev, "Memory region already claimed\n");\r\nret = -EBUSY;\r\ngoto err_clk_put;\r\n}\r\nregs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));\r\nif (!regs) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err_clk_put;\r\n}\r\nspdif->regmap = devm_regmap_init_mmio(&pdev->dev, regs,\r\n&tegra20_spdif_regmap_config);\r\nif (IS_ERR(spdif->regmap)) {\r\ndev_err(&pdev->dev, "regmap init failed\n");\r\nret = PTR_ERR(spdif->regmap);\r\ngoto err_clk_put;\r\n}\r\nspdif->playback_dma_data.addr = mem->start + TEGRA20_SPDIF_DATA_OUT;\r\nspdif->playback_dma_data.wrap = 4;\r\nspdif->playback_dma_data.width = 32;\r\nspdif->playback_dma_data.req_sel = dmareq->start;\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = tegra20_spdif_runtime_resume(&pdev->dev);\r\nif (ret)\r\ngoto err_pm_disable;\r\n}\r\nret = snd_soc_register_dai(&pdev->dev, &tegra20_spdif_dai);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register DAI: %d\n", ret);\r\nret = -ENOMEM;\r\ngoto err_suspend;\r\n}\r\nret = tegra_pcm_platform_register(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register PCM: %d\n", ret);\r\ngoto err_unregister_dai;\r\n}\r\nreturn 0;\r\nerr_unregister_dai:\r\nsnd_soc_unregister_dai(&pdev->dev);\r\nerr_suspend:\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ntegra20_spdif_runtime_suspend(&pdev->dev);\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nerr_clk_put:\r\nclk_put(spdif->clk_spdif_out);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int __devexit tegra20_spdif_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra20_spdif *spdif = dev_get_drvdata(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ntegra20_spdif_runtime_suspend(&pdev->dev);\r\ntegra_pcm_platform_unregister(&pdev->dev);\r\nsnd_soc_unregister_dai(&pdev->dev);\r\nclk_put(spdif->clk_spdif_out);\r\nreturn 0;\r\n}
