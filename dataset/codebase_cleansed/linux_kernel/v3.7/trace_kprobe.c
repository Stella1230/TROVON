static __kprobes int trace_probe_is_return(struct trace_probe *tp)\r\n{\r\nreturn tp->rp.handler != NULL;\r\n}\r\nstatic __kprobes const char *trace_probe_symbol(struct trace_probe *tp)\r\n{\r\nreturn tp->symbol ? tp->symbol : "unknown";\r\n}\r\nstatic __kprobes unsigned long trace_probe_offset(struct trace_probe *tp)\r\n{\r\nreturn tp->rp.kp.offset;\r\n}\r\nstatic __kprobes bool trace_probe_is_enabled(struct trace_probe *tp)\r\n{\r\nreturn !!(tp->flags & (TP_FLAG_TRACE | TP_FLAG_PROFILE));\r\n}\r\nstatic __kprobes bool trace_probe_is_registered(struct trace_probe *tp)\r\n{\r\nreturn !!(tp->flags & TP_FLAG_REGISTERED);\r\n}\r\nstatic __kprobes bool trace_probe_has_gone(struct trace_probe *tp)\r\n{\r\nreturn !!(kprobe_gone(&tp->rp.kp));\r\n}\r\nstatic __kprobes bool trace_probe_within_module(struct trace_probe *tp,\r\nstruct module *mod)\r\n{\r\nint len = strlen(mod->name);\r\nconst char *name = trace_probe_symbol(tp);\r\nreturn strncmp(mod->name, name, len) == 0 && name[len] == ':';\r\n}\r\nstatic __kprobes bool trace_probe_is_on_module(struct trace_probe *tp)\r\n{\r\nreturn !!strchr(trace_probe_symbol(tp), ':');\r\n}\r\nstatic struct trace_probe *alloc_trace_probe(const char *group,\r\nconst char *event,\r\nvoid *addr,\r\nconst char *symbol,\r\nunsigned long offs,\r\nint nargs, bool is_return)\r\n{\r\nstruct trace_probe *tp;\r\nint ret = -ENOMEM;\r\ntp = kzalloc(SIZEOF_TRACE_PROBE(nargs), GFP_KERNEL);\r\nif (!tp)\r\nreturn ERR_PTR(ret);\r\nif (symbol) {\r\ntp->symbol = kstrdup(symbol, GFP_KERNEL);\r\nif (!tp->symbol)\r\ngoto error;\r\ntp->rp.kp.symbol_name = tp->symbol;\r\ntp->rp.kp.offset = offs;\r\n} else\r\ntp->rp.kp.addr = addr;\r\nif (is_return)\r\ntp->rp.handler = kretprobe_dispatcher;\r\nelse\r\ntp->rp.kp.pre_handler = kprobe_dispatcher;\r\nif (!event || !is_good_name(event)) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ntp->call.class = &tp->class;\r\ntp->call.name = kstrdup(event, GFP_KERNEL);\r\nif (!tp->call.name)\r\ngoto error;\r\nif (!group || !is_good_name(group)) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ntp->class.system = kstrdup(group, GFP_KERNEL);\r\nif (!tp->class.system)\r\ngoto error;\r\nINIT_LIST_HEAD(&tp->list);\r\nreturn tp;\r\nerror:\r\nkfree(tp->call.name);\r\nkfree(tp->symbol);\r\nkfree(tp);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void free_trace_probe(struct trace_probe *tp)\r\n{\r\nint i;\r\nfor (i = 0; i < tp->nr_args; i++)\r\ntraceprobe_free_probe_arg(&tp->args[i]);\r\nkfree(tp->call.class->system);\r\nkfree(tp->call.name);\r\nkfree(tp->symbol);\r\nkfree(tp);\r\n}\r\nstatic struct trace_probe *find_trace_probe(const char *event,\r\nconst char *group)\r\n{\r\nstruct trace_probe *tp;\r\nlist_for_each_entry(tp, &probe_list, list)\r\nif (strcmp(tp->call.name, event) == 0 &&\r\nstrcmp(tp->call.class->system, group) == 0)\r\nreturn tp;\r\nreturn NULL;\r\n}\r\nstatic int enable_trace_probe(struct trace_probe *tp, int flag)\r\n{\r\nint ret = 0;\r\ntp->flags |= flag;\r\nif (trace_probe_is_enabled(tp) && trace_probe_is_registered(tp) &&\r\n!trace_probe_has_gone(tp)) {\r\nif (trace_probe_is_return(tp))\r\nret = enable_kretprobe(&tp->rp);\r\nelse\r\nret = enable_kprobe(&tp->rp.kp);\r\n}\r\nreturn ret;\r\n}\r\nstatic void disable_trace_probe(struct trace_probe *tp, int flag)\r\n{\r\ntp->flags &= ~flag;\r\nif (!trace_probe_is_enabled(tp) && trace_probe_is_registered(tp)) {\r\nif (trace_probe_is_return(tp))\r\ndisable_kretprobe(&tp->rp);\r\nelse\r\ndisable_kprobe(&tp->rp.kp);\r\n}\r\n}\r\nstatic int __register_trace_probe(struct trace_probe *tp)\r\n{\r\nint i, ret;\r\nif (trace_probe_is_registered(tp))\r\nreturn -EINVAL;\r\nfor (i = 0; i < tp->nr_args; i++)\r\ntraceprobe_update_arg(&tp->args[i]);\r\nif (trace_probe_is_enabled(tp))\r\ntp->rp.kp.flags &= ~KPROBE_FLAG_DISABLED;\r\nelse\r\ntp->rp.kp.flags |= KPROBE_FLAG_DISABLED;\r\nif (trace_probe_is_return(tp))\r\nret = register_kretprobe(&tp->rp);\r\nelse\r\nret = register_kprobe(&tp->rp.kp);\r\nif (ret == 0)\r\ntp->flags |= TP_FLAG_REGISTERED;\r\nelse {\r\npr_warning("Could not insert probe at %s+%lu: %d\n",\r\ntrace_probe_symbol(tp), trace_probe_offset(tp), ret);\r\nif (ret == -ENOENT && trace_probe_is_on_module(tp)) {\r\npr_warning("This probe might be able to register after"\r\n"target module is loaded. Continue.\n");\r\nret = 0;\r\n} else if (ret == -EILSEQ) {\r\npr_warning("Probing address(0x%p) is not an "\r\n"instruction boundary.\n",\r\ntp->rp.kp.addr);\r\nret = -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __unregister_trace_probe(struct trace_probe *tp)\r\n{\r\nif (trace_probe_is_registered(tp)) {\r\nif (trace_probe_is_return(tp))\r\nunregister_kretprobe(&tp->rp);\r\nelse\r\nunregister_kprobe(&tp->rp.kp);\r\ntp->flags &= ~TP_FLAG_REGISTERED;\r\nif (tp->rp.kp.symbol_name)\r\ntp->rp.kp.addr = NULL;\r\n}\r\n}\r\nstatic int unregister_trace_probe(struct trace_probe *tp)\r\n{\r\nif (trace_probe_is_enabled(tp))\r\nreturn -EBUSY;\r\n__unregister_trace_probe(tp);\r\nlist_del(&tp->list);\r\nunregister_probe_event(tp);\r\nreturn 0;\r\n}\r\nstatic int register_trace_probe(struct trace_probe *tp)\r\n{\r\nstruct trace_probe *old_tp;\r\nint ret;\r\nmutex_lock(&probe_lock);\r\nold_tp = find_trace_probe(tp->call.name, tp->call.class->system);\r\nif (old_tp) {\r\nret = unregister_trace_probe(old_tp);\r\nif (ret < 0)\r\ngoto end;\r\nfree_trace_probe(old_tp);\r\n}\r\nret = register_probe_event(tp);\r\nif (ret) {\r\npr_warning("Failed to register probe event(%d)\n", ret);\r\ngoto end;\r\n}\r\nret = __register_trace_probe(tp);\r\nif (ret < 0)\r\nunregister_probe_event(tp);\r\nelse\r\nlist_add_tail(&tp->list, &probe_list);\r\nend:\r\nmutex_unlock(&probe_lock);\r\nreturn ret;\r\n}\r\nstatic int trace_probe_module_callback(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct module *mod = data;\r\nstruct trace_probe *tp;\r\nint ret;\r\nif (val != MODULE_STATE_COMING)\r\nreturn NOTIFY_DONE;\r\nmutex_lock(&probe_lock);\r\nlist_for_each_entry(tp, &probe_list, list) {\r\nif (trace_probe_within_module(tp, mod)) {\r\n__unregister_trace_probe(tp);\r\nret = __register_trace_probe(tp);\r\nif (ret)\r\npr_warning("Failed to re-register probe %s on"\r\n"%s: %d\n",\r\ntp->call.name, mod->name, ret);\r\n}\r\n}\r\nmutex_unlock(&probe_lock);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int create_trace_probe(int argc, char **argv)\r\n{\r\nstruct trace_probe *tp;\r\nint i, ret = 0;\r\nbool is_return = false, is_delete = false;\r\nchar *symbol = NULL, *event = NULL, *group = NULL;\r\nchar *arg;\r\nunsigned long offset = 0;\r\nvoid *addr = NULL;\r\nchar buf[MAX_EVENT_NAME_LEN];\r\nif (argv[0][0] == 'p')\r\nis_return = false;\r\nelse if (argv[0][0] == 'r')\r\nis_return = true;\r\nelse if (argv[0][0] == '-')\r\nis_delete = true;\r\nelse {\r\npr_info("Probe definition must be started with 'p', 'r' or"\r\n" '-'.\n");\r\nreturn -EINVAL;\r\n}\r\nif (argv[0][1] == ':') {\r\nevent = &argv[0][2];\r\nif (strchr(event, '/')) {\r\ngroup = event;\r\nevent = strchr(group, '/') + 1;\r\nevent[-1] = '\0';\r\nif (strlen(group) == 0) {\r\npr_info("Group name is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (strlen(event) == 0) {\r\npr_info("Event name is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!group)\r\ngroup = KPROBE_EVENT_SYSTEM;\r\nif (is_delete) {\r\nif (!event) {\r\npr_info("Delete command needs an event name.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&probe_lock);\r\ntp = find_trace_probe(event, group);\r\nif (!tp) {\r\nmutex_unlock(&probe_lock);\r\npr_info("Event %s/%s doesn't exist.\n", group, event);\r\nreturn -ENOENT;\r\n}\r\nret = unregister_trace_probe(tp);\r\nif (ret == 0)\r\nfree_trace_probe(tp);\r\nmutex_unlock(&probe_lock);\r\nreturn ret;\r\n}\r\nif (argc < 2) {\r\npr_info("Probe point is not specified.\n");\r\nreturn -EINVAL;\r\n}\r\nif (isdigit(argv[1][0])) {\r\nif (is_return) {\r\npr_info("Return probe point must be a symbol.\n");\r\nreturn -EINVAL;\r\n}\r\nret = strict_strtoul(&argv[1][0], 0, (unsigned long *)&addr);\r\nif (ret) {\r\npr_info("Failed to parse address.\n");\r\nreturn ret;\r\n}\r\n} else {\r\nsymbol = argv[1];\r\nret = traceprobe_split_symbol_offset(symbol, &offset);\r\nif (ret) {\r\npr_info("Failed to parse symbol.\n");\r\nreturn ret;\r\n}\r\nif (offset && is_return) {\r\npr_info("Return probe must be used without offset.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nargc -= 2; argv += 2;\r\nif (!event) {\r\nif (symbol)\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "%c_%s_%ld",\r\nis_return ? 'r' : 'p', symbol, offset);\r\nelse\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "%c_0x%p",\r\nis_return ? 'r' : 'p', addr);\r\nevent = buf;\r\n}\r\ntp = alloc_trace_probe(group, event, addr, symbol, offset, argc,\r\nis_return);\r\nif (IS_ERR(tp)) {\r\npr_info("Failed to allocate trace_probe.(%d)\n",\r\n(int)PTR_ERR(tp));\r\nreturn PTR_ERR(tp);\r\n}\r\nret = 0;\r\nfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\r\ntp->nr_args++;\r\narg = strchr(argv[i], '=');\r\nif (arg) {\r\n*arg++ = '\0';\r\ntp->args[i].name = kstrdup(argv[i], GFP_KERNEL);\r\n} else {\r\narg = argv[i];\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "arg%d", i + 1);\r\ntp->args[i].name = kstrdup(buf, GFP_KERNEL);\r\n}\r\nif (!tp->args[i].name) {\r\npr_info("Failed to allocate argument[%d] name.\n", i);\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (!is_good_name(tp->args[i].name)) {\r\npr_info("Invalid argument[%d] name: %s\n",\r\ni, tp->args[i].name);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (traceprobe_conflict_field_name(tp->args[i].name,\r\ntp->args, i)) {\r\npr_info("Argument[%d] name '%s' conflicts with "\r\n"another field.\n", i, argv[i]);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = traceprobe_parse_probe_arg(arg, &tp->size, &tp->args[i],\r\nis_return, true);\r\nif (ret) {\r\npr_info("Parse error at argument[%d]. (%d)\n", i, ret);\r\ngoto error;\r\n}\r\n}\r\nret = register_trace_probe(tp);\r\nif (ret)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nfree_trace_probe(tp);\r\nreturn ret;\r\n}\r\nstatic int release_all_trace_probes(void)\r\n{\r\nstruct trace_probe *tp;\r\nint ret = 0;\r\nmutex_lock(&probe_lock);\r\nlist_for_each_entry(tp, &probe_list, list)\r\nif (trace_probe_is_enabled(tp)) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nwhile (!list_empty(&probe_list)) {\r\ntp = list_entry(probe_list.next, struct trace_probe, list);\r\nunregister_trace_probe(tp);\r\nfree_trace_probe(tp);\r\n}\r\nend:\r\nmutex_unlock(&probe_lock);\r\nreturn ret;\r\n}\r\nstatic void *probes_seq_start(struct seq_file *m, loff_t *pos)\r\n{\r\nmutex_lock(&probe_lock);\r\nreturn seq_list_start(&probe_list, *pos);\r\n}\r\nstatic void *probes_seq_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nreturn seq_list_next(v, &probe_list, pos);\r\n}\r\nstatic void probes_seq_stop(struct seq_file *m, void *v)\r\n{\r\nmutex_unlock(&probe_lock);\r\n}\r\nstatic int probes_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_probe *tp = v;\r\nint i;\r\nseq_printf(m, "%c", trace_probe_is_return(tp) ? 'r' : 'p');\r\nseq_printf(m, ":%s/%s", tp->call.class->system, tp->call.name);\r\nif (!tp->symbol)\r\nseq_printf(m, " 0x%p", tp->rp.kp.addr);\r\nelse if (tp->rp.kp.offset)\r\nseq_printf(m, " %s+%u", trace_probe_symbol(tp),\r\ntp->rp.kp.offset);\r\nelse\r\nseq_printf(m, " %s", trace_probe_symbol(tp));\r\nfor (i = 0; i < tp->nr_args; i++)\r\nseq_printf(m, " %s=%s", tp->args[i].name, tp->args[i].comm);\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic int probes_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\r\nret = release_all_trace_probes();\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn seq_open(file, &probes_seq_op);\r\n}\r\nstatic ssize_t probes_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn traceprobe_probes_write(file, buffer, count, ppos,\r\ncreate_trace_probe);\r\n}\r\nstatic int probes_profile_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_probe *tp = v;\r\nseq_printf(m, " %-44s %15lu %15lu\n", tp->call.name, tp->nhit,\r\ntp->rp.kp.nmissed);\r\nreturn 0;\r\n}\r\nstatic int profile_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &profile_seq_op);\r\n}\r\nstatic __kprobes int __get_data_size(struct trace_probe *tp,\r\nstruct pt_regs *regs)\r\n{\r\nint i, ret = 0;\r\nu32 len;\r\nfor (i = 0; i < tp->nr_args; i++)\r\nif (unlikely(tp->args[i].fetch_size.fn)) {\r\ncall_fetch(&tp->args[i].fetch_size, regs, &len);\r\nret += len;\r\n}\r\nreturn ret;\r\n}\r\nstatic __kprobes void store_trace_args(int ent_size, struct trace_probe *tp,\r\nstruct pt_regs *regs,\r\nu8 *data, int maxlen)\r\n{\r\nint i;\r\nu32 end = tp->size;\r\nu32 *dl;\r\nfor (i = 0; i < tp->nr_args; i++) {\r\nif (unlikely(tp->args[i].fetch_size.fn)) {\r\ndl = (u32 *)(data + tp->args[i].offset);\r\n*dl = make_data_rloc(maxlen, end - tp->args[i].offset);\r\ncall_fetch(&tp->args[i].fetch, regs, dl);\r\nend += get_rloc_len(*dl);\r\nmaxlen -= get_rloc_len(*dl);\r\n*dl = convert_rloc_to_loc(*dl,\r\nent_size + tp->args[i].offset);\r\n} else\r\ncall_fetch(&tp->args[i].fetch, regs,\r\ndata + tp->args[i].offset);\r\n}\r\n}\r\nstatic __kprobes void kprobe_trace_func(struct kprobe *kp, struct pt_regs *regs)\r\n{\r\nstruct trace_probe *tp = container_of(kp, struct trace_probe, rp.kp);\r\nstruct kprobe_trace_entry_head *entry;\r\nstruct ring_buffer_event *event;\r\nstruct ring_buffer *buffer;\r\nint size, dsize, pc;\r\nunsigned long irq_flags;\r\nstruct ftrace_event_call *call = &tp->call;\r\ntp->nhit++;\r\nlocal_save_flags(irq_flags);\r\npc = preempt_count();\r\ndsize = __get_data_size(tp, regs);\r\nsize = sizeof(*entry) + tp->size + dsize;\r\nevent = trace_current_buffer_lock_reserve(&buffer, call->event.type,\r\nsize, irq_flags, pc);\r\nif (!event)\r\nreturn;\r\nentry = ring_buffer_event_data(event);\r\nentry->ip = (unsigned long)kp->addr;\r\nstore_trace_args(sizeof(*entry), tp, regs, (u8 *)&entry[1], dsize);\r\nif (!filter_current_check_discard(buffer, call, entry, event))\r\ntrace_nowake_buffer_unlock_commit_regs(buffer, event,\r\nirq_flags, pc, regs);\r\n}\r\nstatic __kprobes void kretprobe_trace_func(struct kretprobe_instance *ri,\r\nstruct pt_regs *regs)\r\n{\r\nstruct trace_probe *tp = container_of(ri->rp, struct trace_probe, rp);\r\nstruct kretprobe_trace_entry_head *entry;\r\nstruct ring_buffer_event *event;\r\nstruct ring_buffer *buffer;\r\nint size, pc, dsize;\r\nunsigned long irq_flags;\r\nstruct ftrace_event_call *call = &tp->call;\r\nlocal_save_flags(irq_flags);\r\npc = preempt_count();\r\ndsize = __get_data_size(tp, regs);\r\nsize = sizeof(*entry) + tp->size + dsize;\r\nevent = trace_current_buffer_lock_reserve(&buffer, call->event.type,\r\nsize, irq_flags, pc);\r\nif (!event)\r\nreturn;\r\nentry = ring_buffer_event_data(event);\r\nentry->func = (unsigned long)tp->rp.kp.addr;\r\nentry->ret_ip = (unsigned long)ri->ret_addr;\r\nstore_trace_args(sizeof(*entry), tp, regs, (u8 *)&entry[1], dsize);\r\nif (!filter_current_check_discard(buffer, call, entry, event))\r\ntrace_nowake_buffer_unlock_commit_regs(buffer, event,\r\nirq_flags, pc, regs);\r\n}\r\nenum print_line_t\r\nprint_kprobe_event(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct kprobe_trace_entry_head *field;\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_probe *tp;\r\nu8 *data;\r\nint i;\r\nfield = (struct kprobe_trace_entry_head *)iter->ent;\r\ntp = container_of(event, struct trace_probe, call.event);\r\nif (!trace_seq_printf(s, "%s: (", tp->call.name))\r\ngoto partial;\r\nif (!seq_print_ip_sym(s, field->ip, flags | TRACE_ITER_SYM_OFFSET))\r\ngoto partial;\r\nif (!trace_seq_puts(s, ")"))\r\ngoto partial;\r\ndata = (u8 *)&field[1];\r\nfor (i = 0; i < tp->nr_args; i++)\r\nif (!tp->args[i].type->print(s, tp->args[i].name,\r\ndata + tp->args[i].offset, field))\r\ngoto partial;\r\nif (!trace_seq_puts(s, "\n"))\r\ngoto partial;\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nenum print_line_t\r\nprint_kretprobe_event(struct trace_iterator *iter, int flags,\r\nstruct trace_event *event)\r\n{\r\nstruct kretprobe_trace_entry_head *field;\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_probe *tp;\r\nu8 *data;\r\nint i;\r\nfield = (struct kretprobe_trace_entry_head *)iter->ent;\r\ntp = container_of(event, struct trace_probe, call.event);\r\nif (!trace_seq_printf(s, "%s: (", tp->call.name))\r\ngoto partial;\r\nif (!seq_print_ip_sym(s, field->ret_ip, flags | TRACE_ITER_SYM_OFFSET))\r\ngoto partial;\r\nif (!trace_seq_puts(s, " <- "))\r\ngoto partial;\r\nif (!seq_print_ip_sym(s, field->func, flags & ~TRACE_ITER_SYM_OFFSET))\r\ngoto partial;\r\nif (!trace_seq_puts(s, ")"))\r\ngoto partial;\r\ndata = (u8 *)&field[1];\r\nfor (i = 0; i < tp->nr_args; i++)\r\nif (!tp->args[i].type->print(s, tp->args[i].name,\r\ndata + tp->args[i].offset, field))\r\ngoto partial;\r\nif (!trace_seq_puts(s, "\n"))\r\ngoto partial;\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic int kprobe_event_define_fields(struct ftrace_event_call *event_call)\r\n{\r\nint ret, i;\r\nstruct kprobe_trace_entry_head field;\r\nstruct trace_probe *tp = (struct trace_probe *)event_call->data;\r\nDEFINE_FIELD(unsigned long, ip, FIELD_STRING_IP, 0);\r\nfor (i = 0; i < tp->nr_args; i++) {\r\nret = trace_define_field(event_call, tp->args[i].type->fmttype,\r\ntp->args[i].name,\r\nsizeof(field) + tp->args[i].offset,\r\ntp->args[i].type->size,\r\ntp->args[i].type->is_signed,\r\nFILTER_OTHER);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kretprobe_event_define_fields(struct ftrace_event_call *event_call)\r\n{\r\nint ret, i;\r\nstruct kretprobe_trace_entry_head field;\r\nstruct trace_probe *tp = (struct trace_probe *)event_call->data;\r\nDEFINE_FIELD(unsigned long, func, FIELD_STRING_FUNC, 0);\r\nDEFINE_FIELD(unsigned long, ret_ip, FIELD_STRING_RETIP, 0);\r\nfor (i = 0; i < tp->nr_args; i++) {\r\nret = trace_define_field(event_call, tp->args[i].type->fmttype,\r\ntp->args[i].name,\r\nsizeof(field) + tp->args[i].offset,\r\ntp->args[i].type->size,\r\ntp->args[i].type->is_signed,\r\nFILTER_OTHER);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __set_print_fmt(struct trace_probe *tp, char *buf, int len)\r\n{\r\nint i;\r\nint pos = 0;\r\nconst char *fmt, *arg;\r\nif (!trace_probe_is_return(tp)) {\r\nfmt = "(%lx)";\r\narg = "REC->" FIELD_STRING_IP;\r\n} else {\r\nfmt = "(%lx <- %lx)";\r\narg = "REC->" FIELD_STRING_FUNC ", REC->" FIELD_STRING_RETIP;\r\n}\r\n#define LEN_OR_ZERO (len ? len - pos : 0)\r\npos += snprintf(buf + pos, LEN_OR_ZERO, "\"%s", fmt);\r\nfor (i = 0; i < tp->nr_args; i++) {\r\npos += snprintf(buf + pos, LEN_OR_ZERO, " %s=%s",\r\ntp->args[i].name, tp->args[i].type->fmt);\r\n}\r\npos += snprintf(buf + pos, LEN_OR_ZERO, "\", %s", arg);\r\nfor (i = 0; i < tp->nr_args; i++) {\r\nif (strcmp(tp->args[i].type->name, "string") == 0)\r\npos += snprintf(buf + pos, LEN_OR_ZERO,\r\n", __get_str(%s)",\r\ntp->args[i].name);\r\nelse\r\npos += snprintf(buf + pos, LEN_OR_ZERO, ", REC->%s",\r\ntp->args[i].name);\r\n}\r\n#undef LEN_OR_ZERO\r\nreturn pos;\r\n}\r\nstatic int set_print_fmt(struct trace_probe *tp)\r\n{\r\nint len;\r\nchar *print_fmt;\r\nlen = __set_print_fmt(tp, NULL, 0);\r\nprint_fmt = kmalloc(len + 1, GFP_KERNEL);\r\nif (!print_fmt)\r\nreturn -ENOMEM;\r\n__set_print_fmt(tp, print_fmt, len + 1);\r\ntp->call.print_fmt = print_fmt;\r\nreturn 0;\r\n}\r\nstatic __kprobes void kprobe_perf_func(struct kprobe *kp,\r\nstruct pt_regs *regs)\r\n{\r\nstruct trace_probe *tp = container_of(kp, struct trace_probe, rp.kp);\r\nstruct ftrace_event_call *call = &tp->call;\r\nstruct kprobe_trace_entry_head *entry;\r\nstruct hlist_head *head;\r\nint size, __size, dsize;\r\nint rctx;\r\ndsize = __get_data_size(tp, regs);\r\n__size = sizeof(*entry) + tp->size + dsize;\r\nsize = ALIGN(__size + sizeof(u32), sizeof(u64));\r\nsize -= sizeof(u32);\r\nif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\r\n"profile buffer not large enough"))\r\nreturn;\r\nentry = perf_trace_buf_prepare(size, call->event.type, regs, &rctx);\r\nif (!entry)\r\nreturn;\r\nentry->ip = (unsigned long)kp->addr;\r\nmemset(&entry[1], 0, dsize);\r\nstore_trace_args(sizeof(*entry), tp, regs, (u8 *)&entry[1], dsize);\r\nhead = this_cpu_ptr(call->perf_events);\r\nperf_trace_buf_submit(entry, size, rctx,\r\nentry->ip, 1, regs, head, NULL);\r\n}\r\nstatic __kprobes void kretprobe_perf_func(struct kretprobe_instance *ri,\r\nstruct pt_regs *regs)\r\n{\r\nstruct trace_probe *tp = container_of(ri->rp, struct trace_probe, rp);\r\nstruct ftrace_event_call *call = &tp->call;\r\nstruct kretprobe_trace_entry_head *entry;\r\nstruct hlist_head *head;\r\nint size, __size, dsize;\r\nint rctx;\r\ndsize = __get_data_size(tp, regs);\r\n__size = sizeof(*entry) + tp->size + dsize;\r\nsize = ALIGN(__size + sizeof(u32), sizeof(u64));\r\nsize -= sizeof(u32);\r\nif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\r\n"profile buffer not large enough"))\r\nreturn;\r\nentry = perf_trace_buf_prepare(size, call->event.type, regs, &rctx);\r\nif (!entry)\r\nreturn;\r\nentry->func = (unsigned long)tp->rp.kp.addr;\r\nentry->ret_ip = (unsigned long)ri->ret_addr;\r\nstore_trace_args(sizeof(*entry), tp, regs, (u8 *)&entry[1], dsize);\r\nhead = this_cpu_ptr(call->perf_events);\r\nperf_trace_buf_submit(entry, size, rctx,\r\nentry->ret_ip, 1, regs, head, NULL);\r\n}\r\nstatic __kprobes\r\nint kprobe_register(struct ftrace_event_call *event,\r\nenum trace_reg type, void *data)\r\n{\r\nstruct trace_probe *tp = (struct trace_probe *)event->data;\r\nswitch (type) {\r\ncase TRACE_REG_REGISTER:\r\nreturn enable_trace_probe(tp, TP_FLAG_TRACE);\r\ncase TRACE_REG_UNREGISTER:\r\ndisable_trace_probe(tp, TP_FLAG_TRACE);\r\nreturn 0;\r\n#ifdef CONFIG_PERF_EVENTS\r\ncase TRACE_REG_PERF_REGISTER:\r\nreturn enable_trace_probe(tp, TP_FLAG_PROFILE);\r\ncase TRACE_REG_PERF_UNREGISTER:\r\ndisable_trace_probe(tp, TP_FLAG_PROFILE);\r\nreturn 0;\r\ncase TRACE_REG_PERF_OPEN:\r\ncase TRACE_REG_PERF_CLOSE:\r\ncase TRACE_REG_PERF_ADD:\r\ncase TRACE_REG_PERF_DEL:\r\nreturn 0;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic __kprobes\r\nint kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs)\r\n{\r\nstruct trace_probe *tp = container_of(kp, struct trace_probe, rp.kp);\r\nif (tp->flags & TP_FLAG_TRACE)\r\nkprobe_trace_func(kp, regs);\r\n#ifdef CONFIG_PERF_EVENTS\r\nif (tp->flags & TP_FLAG_PROFILE)\r\nkprobe_perf_func(kp, regs);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic __kprobes\r\nint kretprobe_dispatcher(struct kretprobe_instance *ri, struct pt_regs *regs)\r\n{\r\nstruct trace_probe *tp = container_of(ri->rp, struct trace_probe, rp);\r\nif (tp->flags & TP_FLAG_TRACE)\r\nkretprobe_trace_func(ri, regs);\r\n#ifdef CONFIG_PERF_EVENTS\r\nif (tp->flags & TP_FLAG_PROFILE)\r\nkretprobe_perf_func(ri, regs);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int register_probe_event(struct trace_probe *tp)\r\n{\r\nstruct ftrace_event_call *call = &tp->call;\r\nint ret;\r\nINIT_LIST_HEAD(&call->class->fields);\r\nif (trace_probe_is_return(tp)) {\r\ncall->event.funcs = &kretprobe_funcs;\r\ncall->class->define_fields = kretprobe_event_define_fields;\r\n} else {\r\ncall->event.funcs = &kprobe_funcs;\r\ncall->class->define_fields = kprobe_event_define_fields;\r\n}\r\nif (set_print_fmt(tp) < 0)\r\nreturn -ENOMEM;\r\nret = register_ftrace_event(&call->event);\r\nif (!ret) {\r\nkfree(call->print_fmt);\r\nreturn -ENODEV;\r\n}\r\ncall->flags = 0;\r\ncall->class->reg = kprobe_register;\r\ncall->data = tp;\r\nret = trace_add_event_call(call);\r\nif (ret) {\r\npr_info("Failed to register kprobe event: %s\n", call->name);\r\nkfree(call->print_fmt);\r\nunregister_ftrace_event(&call->event);\r\n}\r\nreturn ret;\r\n}\r\nstatic void unregister_probe_event(struct trace_probe *tp)\r\n{\r\ntrace_remove_event_call(&tp->call);\r\nkfree(tp->call.print_fmt);\r\n}\r\nstatic __init int init_kprobe_trace(void)\r\n{\r\nstruct dentry *d_tracer;\r\nstruct dentry *entry;\r\nif (register_module_notifier(&trace_probe_module_nb))\r\nreturn -EINVAL;\r\nd_tracer = tracing_init_dentry();\r\nif (!d_tracer)\r\nreturn 0;\r\nentry = debugfs_create_file("kprobe_events", 0644, d_tracer,\r\nNULL, &kprobe_events_ops);\r\nif (!entry)\r\npr_warning("Could not create debugfs "\r\n"'kprobe_events' entry\n");\r\nentry = debugfs_create_file("kprobe_profile", 0444, d_tracer,\r\nNULL, &kprobe_profile_ops);\r\nif (!entry)\r\npr_warning("Could not create debugfs "\r\n"'kprobe_profile' entry\n");\r\nreturn 0;\r\n}\r\nstatic __used int kprobe_trace_selftest_target(int a1, int a2, int a3,\r\nint a4, int a5, int a6)\r\n{\r\nreturn a1 + a2 + a3 + a4 + a5 + a6;\r\n}\r\nstatic __init int kprobe_trace_self_tests_init(void)\r\n{\r\nint ret, warn = 0;\r\nint (*target)(int, int, int, int, int, int);\r\nstruct trace_probe *tp;\r\ntarget = kprobe_trace_selftest_target;\r\npr_info("Testing kprobe tracing: ");\r\nret = traceprobe_command("p:testprobe kprobe_trace_selftest_target "\r\n"$stack $stack0 +0($stack)",\r\ncreate_trace_probe);\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warning("error on probing function entry.\n");\r\nwarn++;\r\n} else {\r\ntp = find_trace_probe("testprobe", KPROBE_EVENT_SYSTEM);\r\nif (WARN_ON_ONCE(tp == NULL)) {\r\npr_warning("error on getting new probe.\n");\r\nwarn++;\r\n} else\r\nenable_trace_probe(tp, TP_FLAG_TRACE);\r\n}\r\nret = traceprobe_command("r:testprobe2 kprobe_trace_selftest_target "\r\n"$retval", create_trace_probe);\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warning("error on probing function return.\n");\r\nwarn++;\r\n} else {\r\ntp = find_trace_probe("testprobe2", KPROBE_EVENT_SYSTEM);\r\nif (WARN_ON_ONCE(tp == NULL)) {\r\npr_warning("error on getting new probe.\n");\r\nwarn++;\r\n} else\r\nenable_trace_probe(tp, TP_FLAG_TRACE);\r\n}\r\nif (warn)\r\ngoto end;\r\nret = target(1, 2, 3, 4, 5, 6);\r\ntp = find_trace_probe("testprobe", KPROBE_EVENT_SYSTEM);\r\nif (WARN_ON_ONCE(tp == NULL)) {\r\npr_warning("error on getting test probe.\n");\r\nwarn++;\r\n} else\r\ndisable_trace_probe(tp, TP_FLAG_TRACE);\r\ntp = find_trace_probe("testprobe2", KPROBE_EVENT_SYSTEM);\r\nif (WARN_ON_ONCE(tp == NULL)) {\r\npr_warning("error on getting 2nd test probe.\n");\r\nwarn++;\r\n} else\r\ndisable_trace_probe(tp, TP_FLAG_TRACE);\r\nret = traceprobe_command("-:testprobe", create_trace_probe);\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warning("error on deleting a probe.\n");\r\nwarn++;\r\n}\r\nret = traceprobe_command("-:testprobe2", create_trace_probe);\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warning("error on deleting a probe.\n");\r\nwarn++;\r\n}\r\nend:\r\nrelease_all_trace_probes();\r\nif (warn)\r\npr_cont("NG: Some tests are failed. Please check them.\n");\r\nelse\r\npr_cont("OK\n");\r\nreturn 0;\r\n}
