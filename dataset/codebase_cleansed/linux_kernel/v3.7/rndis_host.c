void rndis_status(struct usbnet *dev, struct urb *urb)\r\n{\r\nnetdev_dbg(dev->net, "rndis status urb, len %d stat %d\n",\r\nurb->actual_length, urb->status);\r\n}\r\nstatic void rndis_msg_indicate(struct usbnet *dev, struct rndis_indicate *msg,\r\nint buflen)\r\n{\r\nstruct cdc_state *info = (void *)&dev->data;\r\nstruct device *udev = &info->control->dev;\r\nif (dev->driver_info->indication) {\r\ndev->driver_info->indication(dev, msg, buflen);\r\n} else {\r\nu32 status = le32_to_cpu(msg->status);\r\nswitch (status) {\r\ncase RNDIS_STATUS_MEDIA_CONNECT:\r\ndev_info(udev, "rndis media connect\n");\r\nbreak;\r\ncase RNDIS_STATUS_MEDIA_DISCONNECT:\r\ndev_info(udev, "rndis media disconnect\n");\r\nbreak;\r\ndefault:\r\ndev_info(udev, "rndis indication: 0x%08x\n", status);\r\n}\r\n}\r\n}\r\nint rndis_command(struct usbnet *dev, struct rndis_msg_hdr *buf, int buflen)\r\n{\r\nstruct cdc_state *info = (void *) &dev->data;\r\nstruct usb_cdc_notification notification;\r\nint master_ifnum;\r\nint retval;\r\nint partial;\r\nunsigned count;\r\nu32 xid = 0, msg_len, request_id, msg_type, rsp,\r\nstatus;\r\nmsg_type = le32_to_cpu(buf->msg_type);\r\nif (likely(msg_type != RNDIS_MSG_HALT && msg_type != RNDIS_MSG_RESET)) {\r\nxid = dev->xid++;\r\nif (!xid)\r\nxid = dev->xid++;\r\nbuf->request_id = (__force __le32) xid;\r\n}\r\nmaster_ifnum = info->control->cur_altsetting->desc.bInterfaceNumber;\r\nretval = usb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\nUSB_CDC_SEND_ENCAPSULATED_COMMAND,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, master_ifnum,\r\nbuf, le32_to_cpu(buf->msg_len),\r\nRNDIS_CONTROL_TIMEOUT_MS);\r\nif (unlikely(retval < 0 || xid == 0))\r\nreturn retval;\r\nif (dev->driver_info->data & RNDIS_DRIVER_DATA_POLL_STATUS) {\r\nretval = usb_interrupt_msg(\r\ndev->udev,\r\nusb_rcvintpipe(dev->udev,\r\ndev->status->desc.bEndpointAddress),\r\n&notification, sizeof(notification), &partial,\r\nRNDIS_CONTROL_TIMEOUT_MS);\r\nif (unlikely(retval < 0))\r\nreturn retval;\r\n}\r\nrsp = le32_to_cpu(buf->msg_type) | RNDIS_MSG_COMPLETION;\r\nfor (count = 0; count < 10; count++) {\r\nmemset(buf, 0, CONTROL_BUFFER_SIZE);\r\nretval = usb_control_msg(dev->udev,\r\nusb_rcvctrlpipe(dev->udev, 0),\r\nUSB_CDC_GET_ENCAPSULATED_RESPONSE,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, master_ifnum,\r\nbuf, buflen,\r\nRNDIS_CONTROL_TIMEOUT_MS);\r\nif (likely(retval >= 8)) {\r\nmsg_type = le32_to_cpu(buf->msg_type);\r\nmsg_len = le32_to_cpu(buf->msg_len);\r\nstatus = le32_to_cpu(buf->status);\r\nrequest_id = (__force u32) buf->request_id;\r\nif (likely(msg_type == rsp)) {\r\nif (likely(request_id == xid)) {\r\nif (unlikely(rsp == RNDIS_MSG_RESET_C))\r\nreturn 0;\r\nif (likely(RNDIS_STATUS_SUCCESS ==\r\nstatus))\r\nreturn 0;\r\ndev_dbg(&info->control->dev,\r\n"rndis reply status %08x\n",\r\nstatus);\r\nreturn -EL3RST;\r\n}\r\ndev_dbg(&info->control->dev,\r\n"rndis reply id %d expected %d\n",\r\nrequest_id, xid);\r\n} else switch (msg_type) {\r\ncase RNDIS_MSG_INDICATE:\r\nrndis_msg_indicate(dev, (void *)buf, buflen);\r\nbreak;\r\ncase RNDIS_MSG_KEEPALIVE: {\r\nstruct rndis_keepalive_c *msg = (void *)buf;\r\nmsg->msg_type = cpu_to_le32(RNDIS_MSG_KEEPALIVE_C);\r\nmsg->msg_len = cpu_to_le32(sizeof *msg);\r\nmsg->status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\r\nretval = usb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\nUSB_CDC_SEND_ENCAPSULATED_COMMAND,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, master_ifnum,\r\nmsg, sizeof *msg,\r\nRNDIS_CONTROL_TIMEOUT_MS);\r\nif (unlikely(retval < 0))\r\ndev_dbg(&info->control->dev,\r\n"rndis keepalive err %d\n",\r\nretval);\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&info->control->dev,\r\n"unexpected rndis msg %08x len %d\n",\r\nle32_to_cpu(buf->msg_type), msg_len);\r\n}\r\n} else {\r\ndev_dbg(&info->control->dev,\r\n"rndis response error, code %d\n", retval);\r\n}\r\nmsleep(20);\r\n}\r\ndev_dbg(&info->control->dev, "rndis response timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int rndis_query(struct usbnet *dev, struct usb_interface *intf,\r\nvoid *buf, u32 oid, u32 in_len,\r\nvoid **reply, int *reply_len)\r\n{\r\nint retval;\r\nunion {\r\nvoid *buf;\r\nstruct rndis_msg_hdr *header;\r\nstruct rndis_query *get;\r\nstruct rndis_query_c *get_c;\r\n} u;\r\nu32 off, len;\r\nu.buf = buf;\r\nmemset(u.get, 0, sizeof *u.get + in_len);\r\nu.get->msg_type = cpu_to_le32(RNDIS_MSG_QUERY);\r\nu.get->msg_len = cpu_to_le32(sizeof *u.get + in_len);\r\nu.get->oid = cpu_to_le32(oid);\r\nu.get->len = cpu_to_le32(in_len);\r\nu.get->offset = cpu_to_le32(20);\r\nretval = rndis_command(dev, u.header, CONTROL_BUFFER_SIZE);\r\nif (unlikely(retval < 0)) {\r\ndev_err(&intf->dev, "RNDIS_MSG_QUERY(0x%08x) failed, %d\n",\r\noid, retval);\r\nreturn retval;\r\n}\r\noff = le32_to_cpu(u.get_c->offset);\r\nlen = le32_to_cpu(u.get_c->len);\r\nif (unlikely((8 + off + len) > CONTROL_BUFFER_SIZE))\r\ngoto response_error;\r\nif (*reply_len != -1 && len != *reply_len)\r\ngoto response_error;\r\n*reply = (unsigned char *) &u.get_c->request_id + off;\r\n*reply_len = len;\r\nreturn retval;\r\nresponse_error:\r\ndev_err(&intf->dev, "RNDIS_MSG_QUERY(0x%08x) "\r\n"invalid response - off %d len %d\n",\r\noid, off, len);\r\nreturn -EDOM;\r\n}\r\nint\r\ngeneric_rndis_bind(struct usbnet *dev, struct usb_interface *intf, int flags)\r\n{\r\nint retval;\r\nstruct net_device *net = dev->net;\r\nstruct cdc_state *info = (void *) &dev->data;\r\nunion {\r\nvoid *buf;\r\nstruct rndis_msg_hdr *header;\r\nstruct rndis_init *init;\r\nstruct rndis_init_c *init_c;\r\nstruct rndis_query *get;\r\nstruct rndis_query_c *get_c;\r\nstruct rndis_set *set;\r\nstruct rndis_set_c *set_c;\r\nstruct rndis_halt *halt;\r\n} u;\r\nu32 tmp;\r\n__le32 phym_unspec, *phym;\r\nint reply_len;\r\nunsigned char *bp;\r\nu.buf = kmalloc(CONTROL_BUFFER_SIZE, GFP_KERNEL);\r\nif (!u.buf)\r\nreturn -ENOMEM;\r\nretval = usbnet_generic_cdc_bind(dev, intf);\r\nif (retval < 0)\r\ngoto fail;\r\nu.init->msg_type = cpu_to_le32(RNDIS_MSG_INIT);\r\nu.init->msg_len = cpu_to_le32(sizeof *u.init);\r\nu.init->major_version = cpu_to_le32(1);\r\nu.init->minor_version = cpu_to_le32(0);\r\nnet->hard_header_len += sizeof (struct rndis_data_hdr);\r\ndev->hard_mtu = net->mtu + net->hard_header_len;\r\ndev->maxpacket = usb_maxpacket(dev->udev, dev->out, 1);\r\nif (dev->maxpacket == 0) {\r\nnetif_dbg(dev, probe, dev->net,\r\n"dev->maxpacket can't be 0\n");\r\nretval = -EINVAL;\r\ngoto fail_and_release;\r\n}\r\ndev->rx_urb_size = dev->hard_mtu + (dev->maxpacket + 1);\r\ndev->rx_urb_size &= ~(dev->maxpacket - 1);\r\nu.init->max_transfer_size = cpu_to_le32(dev->rx_urb_size);\r\nnet->netdev_ops = &rndis_netdev_ops;\r\nretval = rndis_command(dev, u.header, CONTROL_BUFFER_SIZE);\r\nif (unlikely(retval < 0)) {\r\ndev_err(&intf->dev, "RNDIS init failed, %d\n", retval);\r\ngoto fail_and_release;\r\n}\r\ntmp = le32_to_cpu(u.init_c->max_transfer_size);\r\nif (tmp < dev->hard_mtu) {\r\nif (tmp <= net->hard_header_len) {\r\ndev_err(&intf->dev,\r\n"dev can't take %u byte packets (max %u)\n",\r\ndev->hard_mtu, tmp);\r\nretval = -EINVAL;\r\ngoto halt_fail_and_release;\r\n}\r\ndev_warn(&intf->dev,\r\n"dev can't take %u byte packets (max %u), "\r\n"adjusting MTU to %u\n",\r\ndev->hard_mtu, tmp, tmp - net->hard_header_len);\r\ndev->hard_mtu = tmp;\r\nnet->mtu = dev->hard_mtu - net->hard_header_len;\r\n}\r\ndev_dbg(&intf->dev,\r\n"hard mtu %u (%u from dev), rx buflen %Zu, align %d\n",\r\ndev->hard_mtu, tmp, dev->rx_urb_size,\r\n1 << le32_to_cpu(u.init_c->packet_alignment));\r\nif (dev->driver_info->early_init &&\r\ndev->driver_info->early_init(dev) != 0)\r\ngoto halt_fail_and_release;\r\nphym = NULL;\r\nreply_len = sizeof *phym;\r\nretval = rndis_query(dev, intf, u.buf,\r\nRNDIS_OID_GEN_PHYSICAL_MEDIUM,\r\n0, (void **) &phym, &reply_len);\r\nif (retval != 0 || !phym) {\r\nphym_unspec = cpu_to_le32(RNDIS_PHYSICAL_MEDIUM_UNSPECIFIED);\r\nphym = &phym_unspec;\r\n}\r\nif ((flags & FLAG_RNDIS_PHYM_WIRELESS) &&\r\nle32_to_cpup(phym) != RNDIS_PHYSICAL_MEDIUM_WIRELESS_LAN) {\r\nnetif_dbg(dev, probe, dev->net,\r\n"driver requires wireless physical medium, but device is not\n");\r\nretval = -ENODEV;\r\ngoto halt_fail_and_release;\r\n}\r\nif ((flags & FLAG_RNDIS_PHYM_NOT_WIRELESS) &&\r\nle32_to_cpup(phym) == RNDIS_PHYSICAL_MEDIUM_WIRELESS_LAN) {\r\nnetif_dbg(dev, probe, dev->net,\r\n"driver requires non-wireless physical medium, but device is wireless.\n");\r\nretval = -ENODEV;\r\ngoto halt_fail_and_release;\r\n}\r\nreply_len = ETH_ALEN;\r\nretval = rndis_query(dev, intf, u.buf,\r\nRNDIS_OID_802_3_PERMANENT_ADDRESS,\r\n48, (void **) &bp, &reply_len);\r\nif (unlikely(retval< 0)) {\r\ndev_err(&intf->dev, "rndis get ethaddr, %d\n", retval);\r\ngoto halt_fail_and_release;\r\n}\r\nmemcpy(net->dev_addr, bp, ETH_ALEN);\r\nmemcpy(net->perm_addr, bp, ETH_ALEN);\r\nmemset(u.set, 0, sizeof *u.set);\r\nu.set->msg_type = cpu_to_le32(RNDIS_MSG_SET);\r\nu.set->msg_len = cpu_to_le32(4 + sizeof *u.set);\r\nu.set->oid = cpu_to_le32(RNDIS_OID_GEN_CURRENT_PACKET_FILTER);\r\nu.set->len = cpu_to_le32(4);\r\nu.set->offset = cpu_to_le32((sizeof *u.set) - 8);\r\n*(__le32 *)(u.buf + sizeof *u.set) = cpu_to_le32(RNDIS_DEFAULT_FILTER);\r\nretval = rndis_command(dev, u.header, CONTROL_BUFFER_SIZE);\r\nif (unlikely(retval < 0)) {\r\ndev_err(&intf->dev, "rndis set packet filter, %d\n", retval);\r\ngoto halt_fail_and_release;\r\n}\r\nretval = 0;\r\nkfree(u.buf);\r\nreturn retval;\r\nhalt_fail_and_release:\r\nmemset(u.halt, 0, sizeof *u.halt);\r\nu.halt->msg_type = cpu_to_le32(RNDIS_MSG_HALT);\r\nu.halt->msg_len = cpu_to_le32(sizeof *u.halt);\r\n(void) rndis_command(dev, (void *)u.halt, CONTROL_BUFFER_SIZE);\r\nfail_and_release:\r\nusb_set_intfdata(info->data, NULL);\r\nusb_driver_release_interface(driver_of(intf), info->data);\r\ninfo->data = NULL;\r\nfail:\r\nkfree(u.buf);\r\nreturn retval;\r\n}\r\nstatic int rndis_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nreturn generic_rndis_bind(dev, intf, FLAG_RNDIS_PHYM_NOT_WIRELESS);\r\n}\r\nvoid rndis_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct rndis_halt *halt;\r\nhalt = kzalloc(CONTROL_BUFFER_SIZE, GFP_KERNEL);\r\nif (halt) {\r\nhalt->msg_type = cpu_to_le32(RNDIS_MSG_HALT);\r\nhalt->msg_len = cpu_to_le32(sizeof *halt);\r\n(void) rndis_command(dev, (void *)halt, CONTROL_BUFFER_SIZE);\r\nkfree(halt);\r\n}\r\nusbnet_cdc_unbind(dev, intf);\r\n}\r\nint rndis_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nwhile (likely(skb->len)) {\r\nstruct rndis_data_hdr *hdr = (void *)skb->data;\r\nstruct sk_buff *skb2;\r\nu32 msg_type, msg_len, data_offset, data_len;\r\nmsg_type = le32_to_cpu(hdr->msg_type);\r\nmsg_len = le32_to_cpu(hdr->msg_len);\r\ndata_offset = le32_to_cpu(hdr->data_offset);\r\ndata_len = le32_to_cpu(hdr->data_len);\r\nif (unlikely(msg_type != RNDIS_MSG_PACKET || skb->len < msg_len\r\n|| (data_offset + data_len + 8) > msg_len)) {\r\ndev->net->stats.rx_frame_errors++;\r\nnetdev_dbg(dev->net, "bad rndis message %d/%d/%d/%d, len %d\n",\r\nle32_to_cpu(hdr->msg_type),\r\nmsg_len, data_offset, data_len, skb->len);\r\nreturn 0;\r\n}\r\nskb_pull(skb, 8 + data_offset);\r\nif (likely((data_len - skb->len) <= sizeof *hdr)) {\r\nskb_trim(skb, data_len);\r\nbreak;\r\n}\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (unlikely(!skb2))\r\nbreak;\r\nskb_pull(skb, msg_len - sizeof *hdr);\r\nskb_trim(skb2, data_len);\r\nusbnet_skb_return(dev, skb2);\r\n}\r\nreturn 1;\r\n}\r\nstruct sk_buff *\r\nrndis_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\r\n{\r\nstruct rndis_data_hdr *hdr;\r\nstruct sk_buff *skb2;\r\nunsigned len = skb->len;\r\nif (likely(!skb_cloned(skb))) {\r\nint room = skb_headroom(skb);\r\nif (unlikely((sizeof *hdr) <= room))\r\ngoto fill;\r\nroom += skb_tailroom(skb);\r\nif (likely((sizeof *hdr) <= room)) {\r\nskb->data = memmove(skb->head + sizeof *hdr,\r\nskb->data, len);\r\nskb_set_tail_pointer(skb, len);\r\ngoto fill;\r\n}\r\n}\r\nskb2 = skb_copy_expand(skb, sizeof *hdr, 1, flags);\r\ndev_kfree_skb_any(skb);\r\nif (unlikely(!skb2))\r\nreturn skb2;\r\nskb = skb2;\r\nfill:\r\nhdr = (void *) __skb_push(skb, sizeof *hdr);\r\nmemset(hdr, 0, sizeof *hdr);\r\nhdr->msg_type = cpu_to_le32(RNDIS_MSG_PACKET);\r\nhdr->msg_len = cpu_to_le32(skb->len);\r\nhdr->data_offset = cpu_to_le32(sizeof(*hdr) - 8);\r\nhdr->data_len = cpu_to_le32(len);\r\nreturn skb;\r\n}
