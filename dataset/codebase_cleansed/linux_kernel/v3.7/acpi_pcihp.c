static acpi_status\r\ndecode_type0_hpx_record(union acpi_object *record, struct hotplug_params *hpx)\r\n{\r\nint i;\r\nunion acpi_object *fields = record->package.elements;\r\nu32 revision = fields[1].integer.value;\r\nswitch (revision) {\r\ncase 1:\r\nif (record->package.count != 6)\r\nreturn AE_ERROR;\r\nfor (i = 2; i < 6; i++)\r\nif (fields[i].type != ACPI_TYPE_INTEGER)\r\nreturn AE_ERROR;\r\nhpx->t0 = &hpx->type0_data;\r\nhpx->t0->revision = revision;\r\nhpx->t0->cache_line_size = fields[2].integer.value;\r\nhpx->t0->latency_timer = fields[3].integer.value;\r\nhpx->t0->enable_serr = fields[4].integer.value;\r\nhpx->t0->enable_perr = fields[5].integer.value;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"%s: Type 0 Revision %d record not supported\n",\r\n__func__, revision);\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status\r\ndecode_type1_hpx_record(union acpi_object *record, struct hotplug_params *hpx)\r\n{\r\nint i;\r\nunion acpi_object *fields = record->package.elements;\r\nu32 revision = fields[1].integer.value;\r\nswitch (revision) {\r\ncase 1:\r\nif (record->package.count != 5)\r\nreturn AE_ERROR;\r\nfor (i = 2; i < 5; i++)\r\nif (fields[i].type != ACPI_TYPE_INTEGER)\r\nreturn AE_ERROR;\r\nhpx->t1 = &hpx->type1_data;\r\nhpx->t1->revision = revision;\r\nhpx->t1->max_mem_read = fields[2].integer.value;\r\nhpx->t1->avg_max_split = fields[3].integer.value;\r\nhpx->t1->tot_max_split = fields[4].integer.value;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"%s: Type 1 Revision %d record not supported\n",\r\n__func__, revision);\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status\r\ndecode_type2_hpx_record(union acpi_object *record, struct hotplug_params *hpx)\r\n{\r\nint i;\r\nunion acpi_object *fields = record->package.elements;\r\nu32 revision = fields[1].integer.value;\r\nswitch (revision) {\r\ncase 1:\r\nif (record->package.count != 18)\r\nreturn AE_ERROR;\r\nfor (i = 2; i < 18; i++)\r\nif (fields[i].type != ACPI_TYPE_INTEGER)\r\nreturn AE_ERROR;\r\nhpx->t2 = &hpx->type2_data;\r\nhpx->t2->revision = revision;\r\nhpx->t2->unc_err_mask_and = fields[2].integer.value;\r\nhpx->t2->unc_err_mask_or = fields[3].integer.value;\r\nhpx->t2->unc_err_sever_and = fields[4].integer.value;\r\nhpx->t2->unc_err_sever_or = fields[5].integer.value;\r\nhpx->t2->cor_err_mask_and = fields[6].integer.value;\r\nhpx->t2->cor_err_mask_or = fields[7].integer.value;\r\nhpx->t2->adv_err_cap_and = fields[8].integer.value;\r\nhpx->t2->adv_err_cap_or = fields[9].integer.value;\r\nhpx->t2->pci_exp_devctl_and = fields[10].integer.value;\r\nhpx->t2->pci_exp_devctl_or = fields[11].integer.value;\r\nhpx->t2->pci_exp_lnkctl_and = fields[12].integer.value;\r\nhpx->t2->pci_exp_lnkctl_or = fields[13].integer.value;\r\nhpx->t2->sec_unc_err_sever_and = fields[14].integer.value;\r\nhpx->t2->sec_unc_err_sever_or = fields[15].integer.value;\r\nhpx->t2->sec_unc_err_mask_and = fields[16].integer.value;\r\nhpx->t2->sec_unc_err_mask_or = fields[17].integer.value;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"%s: Type 2 Revision %d record not supported\n",\r\n__func__, revision);\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status\r\nacpi_run_hpx(acpi_handle handle, struct hotplug_params *hpx)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\r\nunion acpi_object *package, *record, *fields;\r\nu32 type;\r\nint i;\r\nmemset(hpx, 0, sizeof(struct hotplug_params));\r\nstatus = acpi_evaluate_object(handle, "_HPX", NULL, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\npackage = (union acpi_object *)buffer.pointer;\r\nif (package->type != ACPI_TYPE_PACKAGE) {\r\nstatus = AE_ERROR;\r\ngoto exit;\r\n}\r\nfor (i = 0; i < package->package.count; i++) {\r\nrecord = &package->package.elements[i];\r\nif (record->type != ACPI_TYPE_PACKAGE) {\r\nstatus = AE_ERROR;\r\ngoto exit;\r\n}\r\nfields = record->package.elements;\r\nif (fields[0].type != ACPI_TYPE_INTEGER ||\r\nfields[1].type != ACPI_TYPE_INTEGER) {\r\nstatus = AE_ERROR;\r\ngoto exit;\r\n}\r\ntype = fields[0].integer.value;\r\nswitch (type) {\r\ncase 0:\r\nstatus = decode_type0_hpx_record(record, hpx);\r\nif (ACPI_FAILURE(status))\r\ngoto exit;\r\nbreak;\r\ncase 1:\r\nstatus = decode_type1_hpx_record(record, hpx);\r\nif (ACPI_FAILURE(status))\r\ngoto exit;\r\nbreak;\r\ncase 2:\r\nstatus = decode_type2_hpx_record(record, hpx);\r\nif (ACPI_FAILURE(status))\r\ngoto exit;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: Type %d record not supported\n",\r\n__func__, type);\r\nstatus = AE_ERROR;\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nkfree(buffer.pointer);\r\nreturn status;\r\n}\r\nstatic acpi_status\r\nacpi_run_hpp(acpi_handle handle, struct hotplug_params *hpp)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *package, *fields;\r\nint i;\r\nmemset(hpp, 0, sizeof(struct hotplug_params));\r\nstatus = acpi_evaluate_object(handle, "_HPP", NULL, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\npackage = (union acpi_object *) buffer.pointer;\r\nif (package->type != ACPI_TYPE_PACKAGE ||\r\npackage->package.count != 4) {\r\nstatus = AE_ERROR;\r\ngoto exit;\r\n}\r\nfields = package->package.elements;\r\nfor (i = 0; i < 4; i++) {\r\nif (fields[i].type != ACPI_TYPE_INTEGER) {\r\nstatus = AE_ERROR;\r\ngoto exit;\r\n}\r\n}\r\nhpp->t0 = &hpp->type0_data;\r\nhpp->t0->revision = 1;\r\nhpp->t0->cache_line_size = fields[0].integer.value;\r\nhpp->t0->latency_timer = fields[1].integer.value;\r\nhpp->t0->enable_serr = fields[2].integer.value;\r\nhpp->t0->enable_perr = fields[3].integer.value;\r\nexit:\r\nkfree(buffer.pointer);\r\nreturn status;\r\n}\r\nstatic acpi_status acpi_run_oshp(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer string = { ACPI_ALLOCATE_BUFFER, NULL };\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &string);\r\nstatus = acpi_evaluate_object(handle, METHOD_NAME_OSHP, NULL, NULL);\r\nif (ACPI_FAILURE(status))\r\nif (status != AE_NOT_FOUND)\r\nprintk(KERN_ERR "%s:%s OSHP fails=0x%x\n",\r\n__func__, (char *)string.pointer, status);\r\nelse\r\ndbg("%s:%s OSHP not found\n",\r\n__func__, (char *)string.pointer);\r\nelse\r\npr_debug("%s:%s OSHP passes\n", __func__,\r\n(char *)string.pointer);\r\nkfree(string.pointer);\r\nreturn status;\r\n}\r\nint pci_get_hp_params(struct pci_dev *dev, struct hotplug_params *hpp)\r\n{\r\nacpi_status status;\r\nacpi_handle handle, phandle;\r\nstruct pci_bus *pbus;\r\nhandle = NULL;\r\nfor (pbus = dev->bus; pbus; pbus = pbus->parent) {\r\nhandle = acpi_pci_get_bridge_handle(pbus);\r\nif (handle)\r\nbreak;\r\n}\r\nwhile (handle) {\r\nstatus = acpi_run_hpx(handle, hpp);\r\nif (ACPI_SUCCESS(status))\r\nreturn 0;\r\nstatus = acpi_run_hpp(handle, hpp);\r\nif (ACPI_SUCCESS(status))\r\nreturn 0;\r\nif (acpi_is_root_bridge(handle))\r\nbreak;\r\nstatus = acpi_get_parent(handle, &phandle);\r\nif (ACPI_FAILURE(status))\r\nbreak;\r\nhandle = phandle;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint acpi_get_hp_hw_control_from_firmware(struct pci_dev *pdev, u32 flags)\r\n{\r\nacpi_status status;\r\nacpi_handle chandle, handle;\r\nstruct acpi_buffer string = { ACPI_ALLOCATE_BUFFER, NULL };\r\nflags &= OSC_SHPC_NATIVE_HP_CONTROL;\r\nif (!flags) {\r\nerr("Invalid flags %u specified!\n", flags);\r\nreturn -EINVAL;\r\n}\r\nhandle = acpi_find_root_bridge_handle(pdev);\r\nif (handle) {\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &string);\r\ndbg("Trying to get hotplug control for %s\n",\r\n(char *)string.pointer);\r\nstatus = acpi_pci_osc_control_set(handle, &flags, flags);\r\nif (ACPI_SUCCESS(status))\r\ngoto got_one;\r\nif (status == AE_SUPPORT)\r\ngoto no_control;\r\nkfree(string.pointer);\r\nstring = (struct acpi_buffer){ ACPI_ALLOCATE_BUFFER, NULL };\r\n}\r\nhandle = DEVICE_ACPI_HANDLE(&pdev->dev);\r\nif (!handle) {\r\nstruct pci_bus *pbus;\r\nfor (pbus = pdev->bus; pbus; pbus = pbus->parent) {\r\nhandle = acpi_pci_get_bridge_handle(pbus);\r\nif (handle)\r\nbreak;\r\n}\r\n}\r\nwhile (handle) {\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &string);\r\ndbg("Trying to get hotplug control for %s \n",\r\n(char *)string.pointer);\r\nstatus = acpi_run_oshp(handle);\r\nif (ACPI_SUCCESS(status))\r\ngoto got_one;\r\nif (acpi_is_root_bridge(handle))\r\nbreak;\r\nchandle = handle;\r\nstatus = acpi_get_parent(chandle, &handle);\r\nif (ACPI_FAILURE(status))\r\nbreak;\r\n}\r\nno_control:\r\ndbg("Cannot get control of hotplug hardware for pci %s\n",\r\npci_name(pdev));\r\nkfree(string.pointer);\r\nreturn -ENODEV;\r\ngot_one:\r\ndbg("Gained control for hotplug HW for pci %s (%s)\n",\r\npci_name(pdev), (char *)string.pointer);\r\nkfree(string.pointer);\r\nreturn 0;\r\n}\r\nstatic int pcihp_is_ejectable(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nacpi_handle tmp;\r\nunsigned long long removable;\r\nstatus = acpi_get_handle(handle, "_ADR", &tmp);\r\nif (ACPI_FAILURE(status))\r\nreturn 0;\r\nstatus = acpi_get_handle(handle, "_EJ0", &tmp);\r\nif (ACPI_SUCCESS(status))\r\nreturn 1;\r\nstatus = acpi_evaluate_integer(handle, "_RMV", NULL, &removable);\r\nif (ACPI_SUCCESS(status) && removable)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint acpi_pci_check_ejectable(struct pci_bus *pbus, acpi_handle handle)\r\n{\r\nacpi_handle bridge_handle, parent_handle;\r\nif (!(bridge_handle = acpi_pci_get_bridge_handle(pbus)))\r\nreturn 0;\r\nif ((ACPI_FAILURE(acpi_get_parent(handle, &parent_handle))))\r\nreturn 0;\r\nif (bridge_handle != parent_handle)\r\nreturn 0;\r\nreturn pcihp_is_ejectable(handle);\r\n}\r\nstatic acpi_status\r\ncheck_hotplug(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nint *found = (int *)context;\r\nif (pcihp_is_ejectable(handle)) {\r\n*found = 1;\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nreturn AE_OK;\r\n}\r\nint acpi_pci_detect_ejectable(acpi_handle handle)\r\n{\r\nint found = 0;\r\nif (!handle)\r\nreturn found;\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,\r\ncheck_hotplug, NULL, (void *)&found, NULL);\r\nreturn found;\r\n}
