static int __init ccw_timeout_log_setup(char *unused)\r\n{\r\ntimeout_log_enabled = 1;\r\nreturn 1;\r\n}\r\nstatic void ccw_timeout_log(struct ccw_device *cdev)\r\n{\r\nstruct schib schib;\r\nstruct subchannel *sch;\r\nstruct io_subchannel_private *private;\r\nunion orb *orb;\r\nint cc;\r\nsch = to_subchannel(cdev->dev.parent);\r\nprivate = to_io_private(sch);\r\norb = &private->orb;\r\ncc = stsch_err(sch->schid, &schib);\r\nprintk(KERN_WARNING "cio: ccw device timeout occurred at %llx, "\r\n"device information:\n", get_clock());\r\nprintk(KERN_WARNING "cio: orb:\n");\r\nprint_hex_dump(KERN_WARNING, "cio: ", DUMP_PREFIX_NONE, 16, 1,\r\norb, sizeof(*orb), 0);\r\nprintk(KERN_WARNING "cio: ccw device bus id: %s\n",\r\ndev_name(&cdev->dev));\r\nprintk(KERN_WARNING "cio: subchannel bus id: %s\n",\r\ndev_name(&sch->dev));\r\nprintk(KERN_WARNING "cio: subchannel lpm: %02x, opm: %02x, "\r\n"vpm: %02x\n", sch->lpm, sch->opm, sch->vpm);\r\nif (orb->tm.b) {\r\nprintk(KERN_WARNING "cio: orb indicates transport mode\n");\r\nprintk(KERN_WARNING "cio: last tcw:\n");\r\nprint_hex_dump(KERN_WARNING, "cio: ", DUMP_PREFIX_NONE, 16, 1,\r\n(void *)(addr_t)orb->tm.tcw,\r\nsizeof(struct tcw), 0);\r\n} else {\r\nprintk(KERN_WARNING "cio: orb indicates command mode\n");\r\nif ((void *)(addr_t)orb->cmd.cpa == &private->sense_ccw ||\r\n(void *)(addr_t)orb->cmd.cpa == cdev->private->iccws)\r\nprintk(KERN_WARNING "cio: last channel program "\r\n"(intern):\n");\r\nelse\r\nprintk(KERN_WARNING "cio: last channel program:\n");\r\nprint_hex_dump(KERN_WARNING, "cio: ", DUMP_PREFIX_NONE, 16, 1,\r\n(void *)(addr_t)orb->cmd.cpa,\r\nsizeof(struct ccw1), 0);\r\n}\r\nprintk(KERN_WARNING "cio: ccw device state: %d\n",\r\ncdev->private->state);\r\nprintk(KERN_WARNING "cio: store subchannel returned: cc=%d\n", cc);\r\nprintk(KERN_WARNING "cio: schib:\n");\r\nprint_hex_dump(KERN_WARNING, "cio: ", DUMP_PREFIX_NONE, 16, 1,\r\n&schib, sizeof(schib), 0);\r\nprintk(KERN_WARNING "cio: ccw device flags:\n");\r\nprint_hex_dump(KERN_WARNING, "cio: ", DUMP_PREFIX_NONE, 16, 1,\r\n&cdev->private->flags, sizeof(cdev->private->flags), 0);\r\n}\r\nstatic void\r\nccw_device_timeout(unsigned long data)\r\n{\r\nstruct ccw_device *cdev;\r\ncdev = (struct ccw_device *) data;\r\nspin_lock_irq(cdev->ccwlock);\r\nif (timeout_log_enabled)\r\nccw_timeout_log(cdev);\r\ndev_fsm_event(cdev, DEV_EVENT_TIMEOUT);\r\nspin_unlock_irq(cdev->ccwlock);\r\n}\r\nvoid\r\nccw_device_set_timeout(struct ccw_device *cdev, int expires)\r\n{\r\nif (expires == 0) {\r\ndel_timer(&cdev->private->timer);\r\nreturn;\r\n}\r\nif (timer_pending(&cdev->private->timer)) {\r\nif (mod_timer(&cdev->private->timer, jiffies + expires))\r\nreturn;\r\n}\r\ncdev->private->timer.function = ccw_device_timeout;\r\ncdev->private->timer.data = (unsigned long) cdev;\r\ncdev->private->timer.expires = jiffies + expires;\r\nadd_timer(&cdev->private->timer);\r\n}\r\nint\r\nccw_device_cancel_halt_clear(struct ccw_device *cdev)\r\n{\r\nstruct subchannel *sch;\r\nint ret;\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (cio_update_schib(sch))\r\nreturn -ENODEV;\r\nif (!sch->schib.pmcw.ena)\r\nreturn 0;\r\nif (!(scsw_actl(&sch->schib.scsw) & SCSW_ACTL_HALT_PEND) &&\r\n!(scsw_actl(&sch->schib.scsw) & SCSW_ACTL_CLEAR_PEND)) {\r\nif (!scsw_is_tm(&sch->schib.scsw)) {\r\nret = cio_cancel(sch);\r\nif (ret != -EINVAL)\r\nreturn ret;\r\n}\r\ncdev->private->iretry = 3;\r\n}\r\nif (!(scsw_actl(&sch->schib.scsw) & SCSW_ACTL_CLEAR_PEND)) {\r\nif (cdev->private->iretry) {\r\ncdev->private->iretry--;\r\nret = cio_halt(sch);\r\nif (ret != -EBUSY)\r\nreturn (ret == 0) ? -EBUSY : ret;\r\n}\r\ncdev->private->iretry = 255;\r\n}\r\nif (cdev->private->iretry) {\r\ncdev->private->iretry--;\r\nret = cio_clear (sch);\r\nreturn (ret == 0) ? -EBUSY : ret;\r\n}\r\nCIO_MSG_EVENT(0, "0.%x.%04x: could not stop I/O\n",\r\ncdev->private->dev_id.ssid, cdev->private->dev_id.devno);\r\nreturn -EIO;\r\n}\r\nvoid ccw_device_update_sense_data(struct ccw_device *cdev)\r\n{\r\nmemset(&cdev->id, 0, sizeof(cdev->id));\r\ncdev->id.cu_type = cdev->private->senseid.cu_type;\r\ncdev->id.cu_model = cdev->private->senseid.cu_model;\r\ncdev->id.dev_type = cdev->private->senseid.dev_type;\r\ncdev->id.dev_model = cdev->private->senseid.dev_model;\r\n}\r\nint ccw_device_test_sense_data(struct ccw_device *cdev)\r\n{\r\nreturn cdev->id.cu_type == cdev->private->senseid.cu_type &&\r\ncdev->id.cu_model == cdev->private->senseid.cu_model &&\r\ncdev->id.dev_type == cdev->private->senseid.dev_type &&\r\ncdev->id.dev_model == cdev->private->senseid.dev_model;\r\n}\r\nstatic void\r\n__recover_lost_chpids(struct subchannel *sch, int old_lpm)\r\n{\r\nint mask, i;\r\nstruct chp_id chpid;\r\nchp_id_init(&chpid);\r\nfor (i = 0; i<8; i++) {\r\nmask = 0x80 >> i;\r\nif (!(sch->lpm & mask))\r\ncontinue;\r\nif (old_lpm & mask)\r\ncontinue;\r\nchpid.id = sch->schib.pmcw.chpid[i];\r\nif (!chp_is_registered(chpid))\r\ncss_schedule_eval_all();\r\n}\r\n}\r\nstatic void\r\nccw_device_recog_done(struct ccw_device *cdev, int state)\r\n{\r\nstruct subchannel *sch;\r\nint old_lpm;\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (cio_disable_subchannel(sch))\r\nstate = DEV_STATE_NOT_OPER;\r\nold_lpm = sch->lpm;\r\nif (cio_update_schib(sch))\r\nstate = DEV_STATE_NOT_OPER;\r\nelse\r\nsch->lpm = sch->schib.pmcw.pam & sch->opm;\r\nif (cdev->private->state == DEV_STATE_DISCONNECTED_SENSE_ID)\r\nold_lpm = 0;\r\nif (sch->lpm != old_lpm)\r\n__recover_lost_chpids(sch, old_lpm);\r\nif (cdev->private->state == DEV_STATE_DISCONNECTED_SENSE_ID &&\r\n(state == DEV_STATE_NOT_OPER || state == DEV_STATE_BOXED)) {\r\ncdev->private->flags.recog_done = 1;\r\ncdev->private->state = DEV_STATE_DISCONNECTED;\r\nwake_up(&cdev->private->wait_q);\r\nreturn;\r\n}\r\nif (cdev->private->flags.resuming) {\r\ncdev->private->state = state;\r\ncdev->private->flags.recog_done = 1;\r\nwake_up(&cdev->private->wait_q);\r\nreturn;\r\n}\r\nswitch (state) {\r\ncase DEV_STATE_NOT_OPER:\r\nbreak;\r\ncase DEV_STATE_OFFLINE:\r\nif (!cdev->online) {\r\nccw_device_update_sense_data(cdev);\r\nbreak;\r\n}\r\ncdev->private->state = DEV_STATE_OFFLINE;\r\ncdev->private->flags.recog_done = 1;\r\nif (ccw_device_test_sense_data(cdev)) {\r\ncdev->private->flags.donotify = 1;\r\nccw_device_online(cdev);\r\nwake_up(&cdev->private->wait_q);\r\n} else {\r\nccw_device_update_sense_data(cdev);\r\nccw_device_sched_todo(cdev, CDEV_TODO_REBIND);\r\n}\r\nreturn;\r\ncase DEV_STATE_BOXED:\r\nif (cdev->id.cu_type != 0) {\r\ncdev->private->flags.recog_done = 1;\r\ncdev->private->state = DEV_STATE_BOXED;\r\nwake_up(&cdev->private->wait_q);\r\nreturn;\r\n}\r\nbreak;\r\n}\r\ncdev->private->state = state;\r\nio_subchannel_recog_done(cdev);\r\nwake_up(&cdev->private->wait_q);\r\n}\r\nvoid\r\nccw_device_sense_id_done(struct ccw_device *cdev, int err)\r\n{\r\nswitch (err) {\r\ncase 0:\r\nccw_device_recog_done(cdev, DEV_STATE_OFFLINE);\r\nbreak;\r\ncase -ETIME:\r\nccw_device_recog_done(cdev, DEV_STATE_BOXED);\r\nbreak;\r\ndefault:\r\nccw_device_recog_done(cdev, DEV_STATE_NOT_OPER);\r\nbreak;\r\n}\r\n}\r\nint ccw_device_notify(struct ccw_device *cdev, int event)\r\n{\r\nint ret = -EINVAL;\r\nif (!cdev->drv)\r\ngoto out;\r\nif (!cdev->online)\r\ngoto out;\r\nCIO_MSG_EVENT(2, "notify called for 0.%x.%04x, event=%d\n",\r\ncdev->private->dev_id.ssid, cdev->private->dev_id.devno,\r\nevent);\r\nif (!cdev->drv->notify) {\r\nret = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (cdev->drv->notify(cdev, event))\r\nret = NOTIFY_OK;\r\nelse\r\nret = NOTIFY_BAD;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ccw_device_oper_notify(struct ccw_device *cdev)\r\n{\r\nstruct subchannel *sch = to_subchannel(cdev->dev.parent);\r\nif (ccw_device_notify(cdev, CIO_OPER) == NOTIFY_OK) {\r\nccw_device_sched_todo(cdev, CDEV_TODO_ENABLE_CMF);\r\ncdev->private->path_new_mask = sch->vpm;\r\nreturn;\r\n}\r\nccw_device_set_notoper(cdev);\r\nccw_device_sched_todo(cdev, CDEV_TODO_REBIND);\r\n}\r\nstatic void\r\nccw_device_done(struct ccw_device *cdev, int state)\r\n{\r\nstruct subchannel *sch;\r\nsch = to_subchannel(cdev->dev.parent);\r\nccw_device_set_timeout(cdev, 0);\r\nif (state != DEV_STATE_ONLINE)\r\ncio_disable_subchannel(sch);\r\nmemset(&cdev->private->irb, 0, sizeof(struct irb));\r\ncdev->private->state = state;\r\nswitch (state) {\r\ncase DEV_STATE_BOXED:\r\nCIO_MSG_EVENT(0, "Boxed device %04x on subchannel %04x\n",\r\ncdev->private->dev_id.devno, sch->schid.sch_no);\r\nif (cdev->online &&\r\nccw_device_notify(cdev, CIO_BOXED) != NOTIFY_OK)\r\nccw_device_sched_todo(cdev, CDEV_TODO_UNREG);\r\ncdev->private->flags.donotify = 0;\r\nbreak;\r\ncase DEV_STATE_NOT_OPER:\r\nCIO_MSG_EVENT(0, "Device %04x gone on subchannel %04x\n",\r\ncdev->private->dev_id.devno, sch->schid.sch_no);\r\nif (ccw_device_notify(cdev, CIO_GONE) != NOTIFY_OK)\r\nccw_device_sched_todo(cdev, CDEV_TODO_UNREG);\r\nelse\r\nccw_device_set_disconnected(cdev);\r\ncdev->private->flags.donotify = 0;\r\nbreak;\r\ncase DEV_STATE_DISCONNECTED:\r\nCIO_MSG_EVENT(0, "Disconnected device %04x on subchannel "\r\n"%04x\n", cdev->private->dev_id.devno,\r\nsch->schid.sch_no);\r\nif (ccw_device_notify(cdev, CIO_NO_PATH) != NOTIFY_OK) {\r\ncdev->private->state = DEV_STATE_NOT_OPER;\r\nccw_device_sched_todo(cdev, CDEV_TODO_UNREG);\r\n} else\r\nccw_device_set_disconnected(cdev);\r\ncdev->private->flags.donotify = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (cdev->private->flags.donotify) {\r\ncdev->private->flags.donotify = 0;\r\nccw_device_oper_notify(cdev);\r\n}\r\nwake_up(&cdev->private->wait_q);\r\n}\r\nvoid ccw_device_recognition(struct ccw_device *cdev)\r\n{\r\nstruct subchannel *sch = to_subchannel(cdev->dev.parent);\r\ncdev->private->flags.recog_done = 0;\r\ncdev->private->state = DEV_STATE_SENSE_ID;\r\nif (cio_enable_subchannel(sch, (u32) (addr_t) sch)) {\r\nccw_device_recog_done(cdev, DEV_STATE_NOT_OPER);\r\nreturn;\r\n}\r\nccw_device_sense_id_start(cdev);\r\n}\r\nstatic void ccw_device_request_event(struct ccw_device *cdev, enum dev_event e)\r\n{\r\nswitch (e) {\r\ncase DEV_EVENT_NOTOPER:\r\nccw_request_notoper(cdev);\r\nbreak;\r\ncase DEV_EVENT_INTERRUPT:\r\nccw_request_handler(cdev);\r\nbreak;\r\ncase DEV_EVENT_TIMEOUT:\r\nccw_request_timeout(cdev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ccw_device_report_path_events(struct ccw_device *cdev)\r\n{\r\nstruct subchannel *sch = to_subchannel(cdev->dev.parent);\r\nint path_event[8];\r\nint chp, mask;\r\nfor (chp = 0, mask = 0x80; chp < 8; chp++, mask >>= 1) {\r\npath_event[chp] = PE_NONE;\r\nif (mask & cdev->private->path_gone_mask & ~(sch->vpm))\r\npath_event[chp] |= PE_PATH_GONE;\r\nif (mask & cdev->private->path_new_mask & sch->vpm)\r\npath_event[chp] |= PE_PATH_AVAILABLE;\r\nif (mask & cdev->private->pgid_reset_mask & sch->vpm)\r\npath_event[chp] |= PE_PATHGROUP_ESTABLISHED;\r\n}\r\nif (cdev->online && cdev->drv->path_event)\r\ncdev->drv->path_event(cdev, path_event);\r\n}\r\nstatic void ccw_device_reset_path_events(struct ccw_device *cdev)\r\n{\r\ncdev->private->path_gone_mask = 0;\r\ncdev->private->path_new_mask = 0;\r\ncdev->private->pgid_reset_mask = 0;\r\n}\r\nstatic void create_fake_irb(struct irb *irb, int type)\r\n{\r\nmemset(irb, 0, sizeof(*irb));\r\nif (type == FAKE_CMD_IRB) {\r\nstruct cmd_scsw *scsw = &irb->scsw.cmd;\r\nscsw->cc = 1;\r\nscsw->fctl = SCSW_FCTL_START_FUNC;\r\nscsw->actl = SCSW_ACTL_START_PEND;\r\nscsw->stctl = SCSW_STCTL_STATUS_PEND;\r\n} else if (type == FAKE_TM_IRB) {\r\nstruct tm_scsw *scsw = &irb->scsw.tm;\r\nscsw->x = 1;\r\nscsw->cc = 1;\r\nscsw->fctl = SCSW_FCTL_START_FUNC;\r\nscsw->actl = SCSW_ACTL_START_PEND;\r\nscsw->stctl = SCSW_STCTL_STATUS_PEND;\r\n}\r\n}\r\nvoid ccw_device_verify_done(struct ccw_device *cdev, int err)\r\n{\r\nstruct subchannel *sch;\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (cio_update_schib(sch)) {\r\nerr = -ENODEV;\r\ngoto callback;\r\n}\r\nsch->lpm = sch->vpm;\r\nif (cdev->private->flags.doverify) {\r\nccw_device_verify_start(cdev);\r\nreturn;\r\n}\r\ncallback:\r\nswitch (err) {\r\ncase 0:\r\nccw_device_done(cdev, DEV_STATE_ONLINE);\r\nif (cdev->private->flags.fake_irb) {\r\ncreate_fake_irb(&cdev->private->irb,\r\ncdev->private->flags.fake_irb);\r\ncdev->private->flags.fake_irb = 0;\r\nif (cdev->handler)\r\ncdev->handler(cdev, cdev->private->intparm,\r\n&cdev->private->irb);\r\nmemset(&cdev->private->irb, 0, sizeof(struct irb));\r\n}\r\nccw_device_report_path_events(cdev);\r\nbreak;\r\ncase -ETIME:\r\ncase -EUSERS:\r\ncdev->private->flags.donotify = 0;\r\nccw_device_done(cdev, DEV_STATE_BOXED);\r\nbreak;\r\ncase -EACCES:\r\ncdev->private->flags.donotify = 0;\r\nccw_device_done(cdev, DEV_STATE_DISCONNECTED);\r\nbreak;\r\ndefault:\r\ncdev->private->flags.donotify = 0;\r\nccw_device_done(cdev, DEV_STATE_NOT_OPER);\r\nbreak;\r\n}\r\nccw_device_reset_path_events(cdev);\r\n}\r\nint\r\nccw_device_online(struct ccw_device *cdev)\r\n{\r\nstruct subchannel *sch;\r\nint ret;\r\nif ((cdev->private->state != DEV_STATE_OFFLINE) &&\r\n(cdev->private->state != DEV_STATE_BOXED))\r\nreturn -EINVAL;\r\nsch = to_subchannel(cdev->dev.parent);\r\nret = cio_enable_subchannel(sch, (u32)(addr_t)sch);\r\nif (ret != 0) {\r\nif (ret == -ENODEV)\r\ndev_fsm_event(cdev, DEV_EVENT_NOTOPER);\r\nreturn ret;\r\n}\r\ncdev->private->state = DEV_STATE_VERIFY;\r\nccw_device_verify_start(cdev);\r\nreturn 0;\r\n}\r\nvoid\r\nccw_device_disband_done(struct ccw_device *cdev, int err)\r\n{\r\nswitch (err) {\r\ncase 0:\r\nccw_device_done(cdev, DEV_STATE_OFFLINE);\r\nbreak;\r\ncase -ETIME:\r\nccw_device_done(cdev, DEV_STATE_BOXED);\r\nbreak;\r\ndefault:\r\ncdev->private->flags.donotify = 0;\r\nccw_device_done(cdev, DEV_STATE_NOT_OPER);\r\nbreak;\r\n}\r\n}\r\nint\r\nccw_device_offline(struct ccw_device *cdev)\r\n{\r\nstruct subchannel *sch;\r\nif (cdev->private->state == DEV_STATE_DISCONNECTED ||\r\ncdev->private->state == DEV_STATE_NOT_OPER) {\r\ncdev->private->flags.donotify = 0;\r\nccw_device_done(cdev, DEV_STATE_NOT_OPER);\r\nreturn 0;\r\n}\r\nif (cdev->private->state == DEV_STATE_BOXED) {\r\nccw_device_done(cdev, DEV_STATE_BOXED);\r\nreturn 0;\r\n}\r\nif (ccw_device_is_orphan(cdev)) {\r\nccw_device_done(cdev, DEV_STATE_OFFLINE);\r\nreturn 0;\r\n}\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (cio_update_schib(sch))\r\nreturn -ENODEV;\r\nif (scsw_actl(&sch->schib.scsw) != 0)\r\nreturn -EBUSY;\r\nif (cdev->private->state != DEV_STATE_ONLINE)\r\nreturn -EINVAL;\r\nif (!cdev->private->flags.pgroup) {\r\nccw_device_done(cdev, DEV_STATE_OFFLINE);\r\nreturn 0;\r\n}\r\ncdev->private->state = DEV_STATE_DISBAND_PGID;\r\nccw_device_disband_start(cdev);\r\nreturn 0;\r\n}\r\nstatic void ccw_device_generic_notoper(struct ccw_device *cdev,\r\nenum dev_event dev_event)\r\n{\r\nif (ccw_device_notify(cdev, CIO_GONE) != NOTIFY_OK)\r\nccw_device_sched_todo(cdev, CDEV_TODO_UNREG);\r\nelse\r\nccw_device_set_disconnected(cdev);\r\n}\r\nstatic void ccw_device_offline_verify(struct ccw_device *cdev,\r\nenum dev_event dev_event)\r\n{\r\nstruct subchannel *sch = to_subchannel(cdev->dev.parent);\r\ncss_schedule_eval(sch->schid);\r\n}\r\nstatic void\r\nccw_device_online_verify(struct ccw_device *cdev, enum dev_event dev_event)\r\n{\r\nstruct subchannel *sch;\r\nif (cdev->private->state == DEV_STATE_W4SENSE) {\r\ncdev->private->flags.doverify = 1;\r\nreturn;\r\n}\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (cio_update_schib(sch)) {\r\nccw_device_verify_done(cdev, -ENODEV);\r\nreturn;\r\n}\r\nif (scsw_actl(&sch->schib.scsw) != 0 ||\r\n(scsw_stctl(&sch->schib.scsw) & SCSW_STCTL_STATUS_PEND) ||\r\n(scsw_stctl(&cdev->private->irb.scsw) & SCSW_STCTL_STATUS_PEND)) {\r\ncdev->private->flags.doverify = 1;\r\nreturn;\r\n}\r\ncdev->private->state = DEV_STATE_VERIFY;\r\nccw_device_verify_start(cdev);\r\n}\r\nstatic void ccw_device_boxed_verify(struct ccw_device *cdev,\r\nenum dev_event dev_event)\r\n{\r\nstruct subchannel *sch = to_subchannel(cdev->dev.parent);\r\nif (cdev->online) {\r\nif (cio_enable_subchannel(sch, (u32) (addr_t) sch))\r\nccw_device_done(cdev, DEV_STATE_NOT_OPER);\r\nelse\r\nccw_device_online_verify(cdev, dev_event);\r\n} else\r\ncss_schedule_eval(sch->schid);\r\n}\r\nstatic void\r\nccw_device_irq(struct ccw_device *cdev, enum dev_event dev_event)\r\n{\r\nstruct irb *irb;\r\nint is_cmd;\r\nirb = (struct irb *)&S390_lowcore.irb;\r\nis_cmd = !scsw_is_tm(&irb->scsw);\r\nif (!scsw_is_solicited(&irb->scsw)) {\r\nif (is_cmd && (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) &&\r\n!irb->esw.esw0.erw.cons) {\r\nif (ccw_device_do_sense(cdev, irb) != 0)\r\ngoto call_handler_unsol;\r\nmemcpy(&cdev->private->irb, irb, sizeof(struct irb));\r\ncdev->private->state = DEV_STATE_W4SENSE;\r\ncdev->private->intparm = 0;\r\nreturn;\r\n}\r\ncall_handler_unsol:\r\nif (cdev->handler)\r\ncdev->handler (cdev, 0, irb);\r\nif (cdev->private->flags.doverify)\r\nccw_device_online_verify(cdev, 0);\r\nreturn;\r\n}\r\nccw_device_accumulate_irb(cdev, irb);\r\nif (is_cmd && cdev->private->flags.dosense) {\r\nif (ccw_device_do_sense(cdev, irb) == 0) {\r\ncdev->private->state = DEV_STATE_W4SENSE;\r\n}\r\nreturn;\r\n}\r\nif (ccw_device_call_handler(cdev) && cdev->private->flags.doverify)\r\nccw_device_online_verify(cdev, 0);\r\n}\r\nstatic void\r\nccw_device_online_timeout(struct ccw_device *cdev, enum dev_event dev_event)\r\n{\r\nint ret;\r\nccw_device_set_timeout(cdev, 0);\r\ncdev->private->iretry = 255;\r\nret = ccw_device_cancel_halt_clear(cdev);\r\nif (ret == -EBUSY) {\r\nccw_device_set_timeout(cdev, 3*HZ);\r\ncdev->private->state = DEV_STATE_TIMEOUT_KILL;\r\nreturn;\r\n}\r\nif (ret)\r\ndev_fsm_event(cdev, DEV_EVENT_NOTOPER);\r\nelse if (cdev->handler)\r\ncdev->handler(cdev, cdev->private->intparm,\r\nERR_PTR(-ETIMEDOUT));\r\n}\r\nstatic void\r\nccw_device_w4sense(struct ccw_device *cdev, enum dev_event dev_event)\r\n{\r\nstruct irb *irb;\r\nirb = (struct irb *)&S390_lowcore.irb;\r\nif (scsw_stctl(&irb->scsw) ==\r\n(SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) {\r\nif (scsw_cc(&irb->scsw) == 1)\r\nccw_device_do_sense(cdev, irb);\r\nelse {\r\nCIO_MSG_EVENT(0, "0.%x.%04x: unsolicited "\r\n"interrupt during w4sense...\n",\r\ncdev->private->dev_id.ssid,\r\ncdev->private->dev_id.devno);\r\nif (cdev->handler)\r\ncdev->handler (cdev, 0, irb);\r\n}\r\nreturn;\r\n}\r\nif (scsw_fctl(&irb->scsw) &\r\n(SCSW_FCTL_CLEAR_FUNC | SCSW_FCTL_HALT_FUNC)) {\r\ncdev->private->flags.dosense = 0;\r\nmemset(&cdev->private->irb, 0, sizeof(struct irb));\r\nccw_device_accumulate_irb(cdev, irb);\r\ngoto call_handler;\r\n}\r\nccw_device_accumulate_basic_sense(cdev, irb);\r\nif (cdev->private->flags.dosense) {\r\nccw_device_do_sense(cdev, irb);\r\nreturn;\r\n}\r\ncall_handler:\r\ncdev->private->state = DEV_STATE_ONLINE;\r\nwake_up(&cdev->private->wait_q);\r\nif (ccw_device_call_handler(cdev) && cdev->private->flags.doverify)\r\nccw_device_online_verify(cdev, 0);\r\n}\r\nstatic void\r\nccw_device_killing_irq(struct ccw_device *cdev, enum dev_event dev_event)\r\n{\r\nccw_device_set_timeout(cdev, 0);\r\nccw_device_online_verify(cdev, 0);\r\nif (cdev->handler)\r\ncdev->handler(cdev, cdev->private->intparm,\r\nERR_PTR(-EIO));\r\n}\r\nstatic void\r\nccw_device_killing_timeout(struct ccw_device *cdev, enum dev_event dev_event)\r\n{\r\nint ret;\r\nret = ccw_device_cancel_halt_clear(cdev);\r\nif (ret == -EBUSY) {\r\nccw_device_set_timeout(cdev, 3*HZ);\r\nreturn;\r\n}\r\nccw_device_online_verify(cdev, 0);\r\nif (cdev->handler)\r\ncdev->handler(cdev, cdev->private->intparm,\r\nERR_PTR(-EIO));\r\n}\r\nvoid ccw_device_kill_io(struct ccw_device *cdev)\r\n{\r\nint ret;\r\ncdev->private->iretry = 255;\r\nret = ccw_device_cancel_halt_clear(cdev);\r\nif (ret == -EBUSY) {\r\nccw_device_set_timeout(cdev, 3*HZ);\r\ncdev->private->state = DEV_STATE_TIMEOUT_KILL;\r\nreturn;\r\n}\r\nccw_device_online_verify(cdev, 0);\r\nif (cdev->handler)\r\ncdev->handler(cdev, cdev->private->intparm,\r\nERR_PTR(-EIO));\r\n}\r\nstatic void\r\nccw_device_delay_verify(struct ccw_device *cdev, enum dev_event dev_event)\r\n{\r\ncdev->private->flags.doverify = 1;\r\n}\r\nstatic void\r\nccw_device_start_id(struct ccw_device *cdev, enum dev_event dev_event)\r\n{\r\nstruct subchannel *sch;\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (cio_enable_subchannel(sch, (u32)(addr_t)sch) != 0)\r\nreturn;\r\ncdev->private->state = DEV_STATE_DISCONNECTED_SENSE_ID;\r\nccw_device_sense_id_start(cdev);\r\n}\r\nvoid ccw_device_trigger_reprobe(struct ccw_device *cdev)\r\n{\r\nstruct subchannel *sch;\r\nif (cdev->private->state != DEV_STATE_DISCONNECTED)\r\nreturn;\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (cio_update_schib(sch))\r\nreturn;\r\nsch->lpm = sch->schib.pmcw.pam & sch->opm;\r\nio_subchannel_init_config(sch);\r\nif (cio_commit_config(sch))\r\nreturn;\r\nif (sch->schib.pmcw.dev != cdev->private->dev_id.devno)\r\ncss_schedule_eval(sch->schid);\r\nelse\r\nccw_device_start_id(cdev, 0);\r\n}\r\nstatic void ccw_device_disabled_irq(struct ccw_device *cdev,\r\nenum dev_event dev_event)\r\n{\r\nstruct subchannel *sch;\r\nsch = to_subchannel(cdev->dev.parent);\r\ncio_disable_subchannel(sch);\r\n}\r\nstatic void\r\nccw_device_change_cmfstate(struct ccw_device *cdev, enum dev_event dev_event)\r\n{\r\nretry_set_schib(cdev);\r\ncdev->private->state = DEV_STATE_ONLINE;\r\ndev_fsm_event(cdev, dev_event);\r\n}\r\nstatic void ccw_device_update_cmfblock(struct ccw_device *cdev,\r\nenum dev_event dev_event)\r\n{\r\ncmf_retry_copy_block(cdev);\r\ncdev->private->state = DEV_STATE_ONLINE;\r\ndev_fsm_event(cdev, dev_event);\r\n}\r\nstatic void\r\nccw_device_quiesce_done(struct ccw_device *cdev, enum dev_event dev_event)\r\n{\r\nccw_device_set_timeout(cdev, 0);\r\ncdev->private->state = DEV_STATE_NOT_OPER;\r\nwake_up(&cdev->private->wait_q);\r\n}\r\nstatic void\r\nccw_device_quiesce_timeout(struct ccw_device *cdev, enum dev_event dev_event)\r\n{\r\nint ret;\r\nret = ccw_device_cancel_halt_clear(cdev);\r\nif (ret == -EBUSY) {\r\nccw_device_set_timeout(cdev, HZ/10);\r\n} else {\r\ncdev->private->state = DEV_STATE_NOT_OPER;\r\nwake_up(&cdev->private->wait_q);\r\n}\r\n}\r\nstatic void\r\nccw_device_nop(struct ccw_device *cdev, enum dev_event dev_event)\r\n{\r\n}
