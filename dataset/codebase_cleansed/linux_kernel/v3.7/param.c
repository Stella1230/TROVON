static int __devinit e1000_validate_option(unsigned int *value,\r\nconst struct e1000_option *opt,\r\nstruct e1000_adapter *adapter)\r\n{\r\nif (*value == OPTION_UNSET) {\r\n*value = opt->def;\r\nreturn 0;\r\n}\r\nswitch (opt->type) {\r\ncase enable_option:\r\nswitch (*value) {\r\ncase OPTION_ENABLED:\r\ndev_info(&adapter->pdev->dev, "%s Enabled\n",\r\nopt->name);\r\nreturn 0;\r\ncase OPTION_DISABLED:\r\ndev_info(&adapter->pdev->dev, "%s Disabled\n",\r\nopt->name);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase range_option:\r\nif (*value >= opt->arg.r.min && *value <= opt->arg.r.max) {\r\ndev_info(&adapter->pdev->dev, "%s set to %i\n",\r\nopt->name, *value);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase list_option: {\r\nint i;\r\nstruct e1000_opt_list *ent;\r\nfor (i = 0; i < opt->arg.l.nr; i++) {\r\nent = &opt->arg.l.p[i];\r\nif (*value == ent->i) {\r\nif (ent->str[0] != '\0')\r\ndev_info(&adapter->pdev->dev, "%s\n",\r\nent->str);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ndev_info(&adapter->pdev->dev, "Invalid %s value specified (%i) %s\n",\r\nopt->name, *value, opt->err);\r\n*value = opt->def;\r\nreturn -1;\r\n}\r\nvoid __devinit e1000e_check_options(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nint bd = adapter->bd_number;\r\nif (bd >= E1000_MAX_NIC) {\r\ndev_notice(&adapter->pdev->dev,\r\n"Warning: no configuration for board #%i\n", bd);\r\ndev_notice(&adapter->pdev->dev,\r\n"Using defaults for all values\n");\r\n}\r\n{\r\nstatic const struct e1000_option opt = {\r\n.type = range_option,\r\n.name = "Transmit Interrupt Delay",\r\n.err = "using default of "\r\n__MODULE_STRING(DEFAULT_TIDV),\r\n.def = DEFAULT_TIDV,\r\n.arg = { .r = { .min = MIN_TXDELAY,\r\n.max = MAX_TXDELAY } }\r\n};\r\nif (num_TxIntDelay > bd) {\r\nadapter->tx_int_delay = TxIntDelay[bd];\r\ne1000_validate_option(&adapter->tx_int_delay, &opt,\r\nadapter);\r\n} else {\r\nadapter->tx_int_delay = opt.def;\r\n}\r\n}\r\n{\r\nstatic const struct e1000_option opt = {\r\n.type = range_option,\r\n.name = "Transmit Absolute Interrupt Delay",\r\n.err = "using default of "\r\n__MODULE_STRING(DEFAULT_TADV),\r\n.def = DEFAULT_TADV,\r\n.arg = { .r = { .min = MIN_TXABSDELAY,\r\n.max = MAX_TXABSDELAY } }\r\n};\r\nif (num_TxAbsIntDelay > bd) {\r\nadapter->tx_abs_int_delay = TxAbsIntDelay[bd];\r\ne1000_validate_option(&adapter->tx_abs_int_delay, &opt,\r\nadapter);\r\n} else {\r\nadapter->tx_abs_int_delay = opt.def;\r\n}\r\n}\r\n{\r\nstatic struct e1000_option opt = {\r\n.type = range_option,\r\n.name = "Receive Interrupt Delay",\r\n.err = "using default of "\r\n__MODULE_STRING(DEFAULT_RDTR),\r\n.def = DEFAULT_RDTR,\r\n.arg = { .r = { .min = MIN_RXDELAY,\r\n.max = MAX_RXDELAY } }\r\n};\r\nif (num_RxIntDelay > bd) {\r\nadapter->rx_int_delay = RxIntDelay[bd];\r\ne1000_validate_option(&adapter->rx_int_delay, &opt,\r\nadapter);\r\n} else {\r\nadapter->rx_int_delay = opt.def;\r\n}\r\n}\r\n{\r\nstatic const struct e1000_option opt = {\r\n.type = range_option,\r\n.name = "Receive Absolute Interrupt Delay",\r\n.err = "using default of "\r\n__MODULE_STRING(DEFAULT_RADV),\r\n.def = DEFAULT_RADV,\r\n.arg = { .r = { .min = MIN_RXABSDELAY,\r\n.max = MAX_RXABSDELAY } }\r\n};\r\nif (num_RxAbsIntDelay > bd) {\r\nadapter->rx_abs_int_delay = RxAbsIntDelay[bd];\r\ne1000_validate_option(&adapter->rx_abs_int_delay, &opt,\r\nadapter);\r\n} else {\r\nadapter->rx_abs_int_delay = opt.def;\r\n}\r\n}\r\n{\r\nstatic const struct e1000_option opt = {\r\n.type = range_option,\r\n.name = "Interrupt Throttling Rate (ints/sec)",\r\n.err = "using default of "\r\n__MODULE_STRING(DEFAULT_ITR),\r\n.def = DEFAULT_ITR,\r\n.arg = { .r = { .min = MIN_ITR,\r\n.max = MAX_ITR } }\r\n};\r\nif (num_InterruptThrottleRate > bd) {\r\nadapter->itr = InterruptThrottleRate[bd];\r\nif ((adapter->itr > 4) &&\r\ne1000_validate_option(&adapter->itr, &opt, adapter))\r\nadapter->itr = opt.def;\r\n} else {\r\nadapter->itr = opt.def;\r\nif (adapter->itr > 4)\r\ndev_info(&adapter->pdev->dev,\r\n"%s set to default %d\n", opt.name,\r\nadapter->itr);\r\n}\r\nadapter->itr_setting = adapter->itr;\r\nswitch (adapter->itr) {\r\ncase 0:\r\ndev_info(&adapter->pdev->dev, "%s turned off\n",\r\nopt.name);\r\nbreak;\r\ncase 1:\r\ndev_info(&adapter->pdev->dev,\r\n"%s set to dynamic mode\n", opt.name);\r\nadapter->itr = 20000;\r\nbreak;\r\ncase 3:\r\ndev_info(&adapter->pdev->dev,\r\n"%s set to dynamic conservative mode\n",\r\nopt.name);\r\nadapter->itr = 20000;\r\nbreak;\r\ncase 4:\r\ndev_info(&adapter->pdev->dev,\r\n"%s set to simplified (2000-8000 ints) mode\n",\r\nopt.name);\r\nbreak;\r\ndefault:\r\nadapter->itr_setting &= ~3;\r\nbreak;\r\n}\r\n}\r\n{\r\nstatic struct e1000_option opt = {\r\n.type = range_option,\r\n.name = "Interrupt Mode",\r\n#ifndef CONFIG_PCI_MSI\r\n.err = "defaulting to 0 (legacy)",\r\n.def = E1000E_INT_MODE_LEGACY,\r\n.arg = { .r = { .min = 0,\r\n.max = 0 } }\r\n#endif\r\n};\r\n#ifdef CONFIG_PCI_MSI\r\nif (adapter->flags & FLAG_HAS_MSIX) {\r\nopt.err = kstrdup("defaulting to 2 (MSI-X)",\r\nGFP_KERNEL);\r\nopt.def = E1000E_INT_MODE_MSIX;\r\nopt.arg.r.max = E1000E_INT_MODE_MSIX;\r\n} else {\r\nopt.err = kstrdup("defaulting to 1 (MSI)", GFP_KERNEL);\r\nopt.def = E1000E_INT_MODE_MSI;\r\nopt.arg.r.max = E1000E_INT_MODE_MSI;\r\n}\r\nif (!opt.err) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to allocate memory\n");\r\nreturn;\r\n}\r\n#endif\r\nif (num_IntMode > bd) {\r\nunsigned int int_mode = IntMode[bd];\r\ne1000_validate_option(&int_mode, &opt, adapter);\r\nadapter->int_mode = int_mode;\r\n} else {\r\nadapter->int_mode = opt.def;\r\n}\r\n#ifdef CONFIG_PCI_MSI\r\nkfree(opt.err);\r\n#endif\r\n}\r\n{\r\nstatic const struct e1000_option opt = {\r\n.type = enable_option,\r\n.name = "PHY Smart Power Down",\r\n.err = "defaulting to Disabled",\r\n.def = OPTION_DISABLED\r\n};\r\nif (num_SmartPowerDownEnable > bd) {\r\nunsigned int spd = SmartPowerDownEnable[bd];\r\ne1000_validate_option(&spd, &opt, adapter);\r\nif ((adapter->flags & FLAG_HAS_SMART_POWER_DOWN)\r\n&& spd)\r\nadapter->flags |= FLAG_SMART_POWER_DOWN;\r\n}\r\n}\r\n{\r\nstatic const struct e1000_option opt = {\r\n.type = enable_option,\r\n.name = "CRC Stripping",\r\n.err = "defaulting to Enabled",\r\n.def = OPTION_ENABLED\r\n};\r\nif (num_CrcStripping > bd) {\r\nunsigned int crc_stripping = CrcStripping[bd];\r\ne1000_validate_option(&crc_stripping, &opt, adapter);\r\nif (crc_stripping == OPTION_ENABLED) {\r\nadapter->flags2 |= FLAG2_CRC_STRIPPING;\r\nadapter->flags2 |= FLAG2_DFLT_CRC_STRIPPING;\r\n}\r\n} else {\r\nadapter->flags2 |= FLAG2_CRC_STRIPPING;\r\nadapter->flags2 |= FLAG2_DFLT_CRC_STRIPPING;\r\n}\r\n}\r\n{\r\nstatic const struct e1000_option opt = {\r\n.type = enable_option,\r\n.name = "Kumeran Lock Loss Workaround",\r\n.err = "defaulting to Enabled",\r\n.def = OPTION_ENABLED\r\n};\r\nif (num_KumeranLockLoss > bd) {\r\nunsigned int kmrn_lock_loss = KumeranLockLoss[bd];\r\ne1000_validate_option(&kmrn_lock_loss, &opt, adapter);\r\nif (hw->mac.type == e1000_ich8lan)\r\ne1000e_set_kmrn_lock_loss_workaround_ich8lan(hw,\r\nkmrn_lock_loss);\r\n} else {\r\nif (hw->mac.type == e1000_ich8lan)\r\ne1000e_set_kmrn_lock_loss_workaround_ich8lan(hw,\r\nopt.def);\r\n}\r\n}\r\n{\r\nstatic const struct e1000_option opt = {\r\n.type = enable_option,\r\n.name = "Write-protect NVM",\r\n.err = "defaulting to Enabled",\r\n.def = OPTION_ENABLED\r\n};\r\nif (adapter->flags & FLAG_IS_ICH) {\r\nif (num_WriteProtectNVM > bd) {\r\nunsigned int write_protect_nvm = WriteProtectNVM[bd];\r\ne1000_validate_option(&write_protect_nvm, &opt,\r\nadapter);\r\nif (write_protect_nvm)\r\nadapter->flags |= FLAG_READ_ONLY_NVM;\r\n} else {\r\nif (opt.def)\r\nadapter->flags |= FLAG_READ_ONLY_NVM;\r\n}\r\n}\r\n}\r\n}
