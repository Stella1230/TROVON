static int tmp401_register_to_temp(u16 reg, u8 config)\r\n{\r\nint temp = reg;\r\nif (config & TMP401_CONFIG_RANGE)\r\ntemp -= 64 * 256;\r\nreturn (temp * 625 + 80) / 160;\r\n}\r\nstatic u16 tmp401_temp_to_register(long temp, u8 config)\r\n{\r\nif (config & TMP401_CONFIG_RANGE) {\r\ntemp = SENSORS_LIMIT(temp, -64000, 191000);\r\ntemp += 64000;\r\n} else\r\ntemp = SENSORS_LIMIT(temp, 0, 127000);\r\nreturn (temp * 160 + 312) / 625;\r\n}\r\nstatic int tmp401_crit_register_to_temp(u8 reg, u8 config)\r\n{\r\nint temp = reg;\r\nif (config & TMP401_CONFIG_RANGE)\r\ntemp -= 64;\r\nreturn temp * 1000;\r\n}\r\nstatic u8 tmp401_crit_temp_to_register(long temp, u8 config)\r\n{\r\nif (config & TMP401_CONFIG_RANGE) {\r\ntemp = SENSORS_LIMIT(temp, -64000, 191000);\r\ntemp += 64000;\r\n} else\r\ntemp = SENSORS_LIMIT(temp, 0, 127000);\r\nreturn (temp + 500) / 1000;\r\n}\r\nstatic struct tmp401_data *tmp401_update_device_reg16(\r\nstruct i2c_client *client, struct tmp401_data *data)\r\n{\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\ndata->temp[i] = i2c_smbus_read_byte_data(client,\r\nTMP401_TEMP_MSB[i]) << 8;\r\ndata->temp[i] |= i2c_smbus_read_byte_data(client,\r\nTMP401_TEMP_LSB[i]);\r\ndata->temp_low[i] = i2c_smbus_read_byte_data(client,\r\nTMP401_TEMP_LOW_LIMIT_MSB_READ[i]) << 8;\r\ndata->temp_low[i] |= i2c_smbus_read_byte_data(client,\r\nTMP401_TEMP_LOW_LIMIT_LSB[i]);\r\ndata->temp_high[i] = i2c_smbus_read_byte_data(client,\r\nTMP401_TEMP_HIGH_LIMIT_MSB_READ[i]) << 8;\r\ndata->temp_high[i] |= i2c_smbus_read_byte_data(client,\r\nTMP401_TEMP_HIGH_LIMIT_LSB[i]);\r\ndata->temp_crit[i] = i2c_smbus_read_byte_data(client,\r\nTMP401_TEMP_CRIT_LIMIT[i]);\r\nif (data->kind == tmp411) {\r\ndata->temp_lowest[i] = i2c_smbus_read_byte_data(client,\r\nTMP411_TEMP_LOWEST_MSB[i]) << 8;\r\ndata->temp_lowest[i] |= i2c_smbus_read_byte_data(\r\nclient, TMP411_TEMP_LOWEST_LSB[i]);\r\ndata->temp_highest[i] = i2c_smbus_read_byte_data(\r\nclient, TMP411_TEMP_HIGHEST_MSB[i]) << 8;\r\ndata->temp_highest[i] |= i2c_smbus_read_byte_data(\r\nclient, TMP411_TEMP_HIGHEST_LSB[i]);\r\n}\r\n}\r\nreturn data;\r\n}\r\nstatic struct tmp401_data *tmp401_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct tmp401_data *data = i2c_get_clientdata(client);\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\ndata->status = i2c_smbus_read_byte_data(client, TMP401_STATUS);\r\ndata->config = i2c_smbus_read_byte_data(client,\r\nTMP401_CONFIG_READ);\r\ntmp401_update_device_reg16(client, data);\r\ndata->temp_crit_hyst = i2c_smbus_read_byte_data(client,\r\nTMP401_TEMP_CRIT_HYST);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t show_temp_value(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\ntmp401_register_to_temp(data->temp[index], data->config));\r\n}\r\nstatic ssize_t show_temp_min(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\ntmp401_register_to_temp(data->temp_low[index], data->config));\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\ntmp401_register_to_temp(data->temp_high[index], data->config));\r\n}\r\nstatic ssize_t show_temp_crit(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\ntmp401_crit_register_to_temp(data->temp_crit[index],\r\ndata->config));\r\n}\r\nstatic ssize_t show_temp_crit_hyst(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint temp, index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nmutex_lock(&data->update_lock);\r\ntemp = tmp401_crit_register_to_temp(data->temp_crit[index],\r\ndata->config);\r\ntemp -= data->temp_crit_hyst * 1000;\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic ssize_t show_temp_lowest(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\ntmp401_register_to_temp(data->temp_lowest[index],\r\ndata->config));\r\n}\r\nstatic ssize_t show_temp_highest(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\ntmp401_register_to_temp(data->temp_highest[index],\r\ndata->config));\r\n}\r\nstatic ssize_t show_status(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint mask = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nif (data->status & mask)\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t store_temp_min(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nlong val;\r\nu16 reg;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nreg = tmp401_temp_to_register(val, data->config);\r\nmutex_lock(&data->update_lock);\r\ni2c_smbus_write_byte_data(to_i2c_client(dev),\r\nTMP401_TEMP_LOW_LIMIT_MSB_WRITE[index], reg >> 8);\r\ni2c_smbus_write_byte_data(to_i2c_client(dev),\r\nTMP401_TEMP_LOW_LIMIT_LSB[index], reg & 0xFF);\r\ndata->temp_low[index] = reg;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t store_temp_max(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nlong val;\r\nu16 reg;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nreg = tmp401_temp_to_register(val, data->config);\r\nmutex_lock(&data->update_lock);\r\ni2c_smbus_write_byte_data(to_i2c_client(dev),\r\nTMP401_TEMP_HIGH_LIMIT_MSB_WRITE[index], reg >> 8);\r\ni2c_smbus_write_byte_data(to_i2c_client(dev),\r\nTMP401_TEMP_HIGH_LIMIT_LSB[index], reg & 0xFF);\r\ndata->temp_high[index] = reg;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t store_temp_crit(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nlong val;\r\nu8 reg;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nreg = tmp401_crit_temp_to_register(val, data->config);\r\nmutex_lock(&data->update_lock);\r\ni2c_smbus_write_byte_data(to_i2c_client(dev),\r\nTMP401_TEMP_CRIT_LIMIT[index], reg);\r\ndata->temp_crit[index] = reg;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t store_temp_crit_hyst(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nint temp, index = to_sensor_dev_attr(devattr)->index;\r\nstruct tmp401_data *data = tmp401_update_device(dev);\r\nlong val;\r\nu8 reg;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nif (data->config & TMP401_CONFIG_RANGE)\r\nval = SENSORS_LIMIT(val, -64000, 191000);\r\nelse\r\nval = SENSORS_LIMIT(val, 0, 127000);\r\nmutex_lock(&data->update_lock);\r\ntemp = tmp401_crit_register_to_temp(data->temp_crit[index],\r\ndata->config);\r\nval = SENSORS_LIMIT(val, temp - 255000, temp);\r\nreg = ((temp - val) + 500) / 1000;\r\ni2c_smbus_write_byte_data(to_i2c_client(dev),\r\nTMP401_TEMP_CRIT_HYST, reg);\r\ndata->temp_crit_hyst = reg;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t reset_temp_history(struct device *dev,\r\nstruct device_attribute *devattr, const char *buf, size_t count)\r\n{\r\nlong val;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nif (val != 1) {\r\ndev_err(dev, "temp_reset_history value %ld not"\r\n" supported. Use 1 to reset the history!\n", val);\r\nreturn -EINVAL;\r\n}\r\ni2c_smbus_write_byte_data(to_i2c_client(dev),\r\nTMP411_TEMP_LOWEST_MSB[0], val);\r\nreturn count;\r\n}\r\nstatic void tmp401_init_client(struct i2c_client *client)\r\n{\r\nint config, config_orig;\r\ni2c_smbus_write_byte_data(client, TMP401_CONVERSION_RATE_WRITE, 5);\r\nconfig = i2c_smbus_read_byte_data(client, TMP401_CONFIG_READ);\r\nif (config < 0) {\r\ndev_warn(&client->dev, "Initialization failed!\n");\r\nreturn;\r\n}\r\nconfig_orig = config;\r\nconfig &= ~TMP401_CONFIG_SHUTDOWN;\r\nif (config != config_orig)\r\ni2c_smbus_write_byte_data(client, TMP401_CONFIG_WRITE, config);\r\n}\r\nstatic int tmp401_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nenum chips kind;\r\nstruct i2c_adapter *adapter = client->adapter;\r\nu8 reg;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, TMP401_MANUFACTURER_ID_REG);\r\nif (reg != TMP401_MANUFACTURER_ID)\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, TMP401_DEVICE_ID_REG);\r\nswitch (reg) {\r\ncase TMP401_DEVICE_ID:\r\nkind = tmp401;\r\nbreak;\r\ncase TMP411_DEVICE_ID:\r\nkind = tmp411;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nreg = i2c_smbus_read_byte_data(client, TMP401_CONFIG_READ);\r\nif (reg & 0x1b)\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, TMP401_CONVERSION_RATE_READ);\r\nif (reg > 15)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, tmp401_id[kind].name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int tmp401_remove(struct i2c_client *client)\r\n{\r\nstruct tmp401_data *data = i2c_get_clientdata(client);\r\nint i;\r\nif (data->hwmon_dev)\r\nhwmon_device_unregister(data->hwmon_dev);\r\nfor (i = 0; i < ARRAY_SIZE(tmp401_attr); i++)\r\ndevice_remove_file(&client->dev, &tmp401_attr[i].dev_attr);\r\nif (data->kind == tmp411) {\r\nfor (i = 0; i < ARRAY_SIZE(tmp411_attr); i++)\r\ndevice_remove_file(&client->dev,\r\n&tmp411_attr[i].dev_attr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tmp401_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint i, err = 0;\r\nstruct tmp401_data *data;\r\nconst char *names[] = { "TMP401", "TMP411" };\r\ndata = devm_kzalloc(&client->dev, sizeof(struct tmp401_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\ndata->kind = id->driver_data;\r\ntmp401_init_client(client);\r\nfor (i = 0; i < ARRAY_SIZE(tmp401_attr); i++) {\r\nerr = device_create_file(&client->dev,\r\n&tmp401_attr[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nif (data->kind == tmp411) {\r\nfor (i = 0; i < ARRAY_SIZE(tmp411_attr); i++) {\r\nerr = device_create_file(&client->dev,\r\n&tmp411_attr[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ndata->hwmon_dev = NULL;\r\ngoto exit_remove;\r\n}\r\ndev_info(&client->dev, "Detected TI %s chip\n", names[data->kind]);\r\nreturn 0;\r\nexit_remove:\r\ntmp401_remove(client);\r\nreturn err;\r\n}
