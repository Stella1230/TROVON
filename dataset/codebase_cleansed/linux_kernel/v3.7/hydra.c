static int __devinit hydra_init_one(struct zorro_dev *z,\r\nconst struct zorro_device_id *ent)\r\n{\r\nint err;\r\nif (!request_mem_region(z->resource.start, 0x10000, "Hydra"))\r\nreturn -EBUSY;\r\nif ((err = hydra_init(z))) {\r\nrelease_mem_region(z->resource.start, 0x10000);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit hydra_init(struct zorro_dev *z)\r\n{\r\nstruct net_device *dev;\r\nunsigned long board = ZTWO_VADDR(z->resource.start);\r\nunsigned long ioaddr = board+HYDRA_NIC_BASE;\r\nconst char name[] = "NE2000";\r\nint start_page, stop_page;\r\nint j;\r\nint err;\r\nstatic u32 hydra_offsets[16] = {\r\n0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e,\r\n0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,\r\n};\r\ndev = ____alloc_ei_netdev(0);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nfor (j = 0; j < ETH_ALEN; j++)\r\ndev->dev_addr[j] = *((u8 *)(board + HYDRA_ADDRPROM + 2*j));\r\nz_writeb(0x4b, ioaddr + NE_EN0_DCFG);\r\nstart_page = NESM_START_PG;\r\nstop_page = NESM_STOP_PG;\r\ndev->base_addr = ioaddr;\r\ndev->irq = IRQ_AMIGA_PORTS;\r\nif (request_irq(IRQ_AMIGA_PORTS, __ei_interrupt, IRQF_SHARED, "Hydra Ethernet",\r\ndev)) {\r\nfree_netdev(dev);\r\nreturn -EAGAIN;\r\n}\r\nei_status.name = name;\r\nei_status.tx_start_page = start_page;\r\nei_status.stop_page = stop_page;\r\nei_status.word16 = 1;\r\nei_status.bigendian = 1;\r\nei_status.rx_start_page = start_page + TX_PAGES;\r\nei_status.reset_8390 = hydra_reset_8390;\r\nei_status.block_input = hydra_block_input;\r\nei_status.block_output = hydra_block_output;\r\nei_status.get_8390_hdr = hydra_get_8390_hdr;\r\nei_status.reg_offset = hydra_offsets;\r\ndev->netdev_ops = &hydra_netdev_ops;\r\n__NS8390_init(dev, 0);\r\nerr = register_netdev(dev);\r\nif (err) {\r\nfree_irq(IRQ_AMIGA_PORTS, dev);\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nzorro_set_drvdata(z, dev);\r\npr_info("%s: Hydra at %pR, address %pM (hydra.c " HYDRA_VERSION ")\n",\r\ndev->name, &z->resource, dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic int hydra_open(struct net_device *dev)\r\n{\r\n__ei_open(dev);\r\nreturn 0;\r\n}\r\nstatic int hydra_close(struct net_device *dev)\r\n{\r\nif (ei_debug > 1)\r\nprintk(KERN_DEBUG "%s: Shutting down ethercard.\n", dev->name);\r\n__ei_close(dev);\r\nreturn 0;\r\n}\r\nstatic void hydra_reset_8390(struct net_device *dev)\r\n{\r\nprintk(KERN_INFO "Hydra hw reset not there\n");\r\n}\r\nstatic void hydra_get_8390_hdr(struct net_device *dev,\r\nstruct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nint nic_base = dev->base_addr;\r\nshort *ptrs;\r\nunsigned long hdr_start= (nic_base-HYDRA_NIC_BASE) +\r\n((ring_page - NESM_START_PG)<<8);\r\nptrs = (short *)hdr;\r\n*(ptrs++) = z_readw(hdr_start);\r\n*((short *)hdr) = WORDSWAP(*((short *)hdr));\r\nhdr_start += 2;\r\n*(ptrs++) = z_readw(hdr_start);\r\n*((short *)hdr+1) = WORDSWAP(*((short *)hdr+1));\r\n}\r\nstatic void hydra_block_input(struct net_device *dev, int count,\r\nstruct sk_buff *skb, int ring_offset)\r\n{\r\nunsigned long nic_base = dev->base_addr;\r\nunsigned long mem_base = nic_base - HYDRA_NIC_BASE;\r\nunsigned long xfer_start = mem_base + ring_offset - (NESM_START_PG<<8);\r\nif (count&1)\r\ncount++;\r\nif (xfer_start+count > mem_base + (NESM_STOP_PG<<8)) {\r\nint semi_count = (mem_base + (NESM_STOP_PG<<8)) - xfer_start;\r\nz_memcpy_fromio(skb->data,xfer_start,semi_count);\r\ncount -= semi_count;\r\nz_memcpy_fromio(skb->data+semi_count, mem_base, count);\r\n} else\r\nz_memcpy_fromio(skb->data, xfer_start,count);\r\n}\r\nstatic void hydra_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, int start_page)\r\n{\r\nunsigned long nic_base = dev->base_addr;\r\nunsigned long mem_base = nic_base - HYDRA_NIC_BASE;\r\nif (count&1)\r\ncount++;\r\nz_memcpy_toio(mem_base+((start_page - NESM_START_PG)<<8), buf, count);\r\n}\r\nstatic void __devexit hydra_remove_one(struct zorro_dev *z)\r\n{\r\nstruct net_device *dev = zorro_get_drvdata(z);\r\nunregister_netdev(dev);\r\nfree_irq(IRQ_AMIGA_PORTS, dev);\r\nrelease_mem_region(ZTWO_PADDR(dev->base_addr)-HYDRA_NIC_BASE, 0x10000);\r\nfree_netdev(dev);\r\n}\r\nstatic int __init hydra_init_module(void)\r\n{\r\nreturn zorro_register_driver(&hydra_driver);\r\n}\r\nstatic void __exit hydra_cleanup_module(void)\r\n{\r\nzorro_unregister_driver(&hydra_driver);\r\n}
