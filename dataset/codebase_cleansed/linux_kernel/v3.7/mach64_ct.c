u8 aty_ld_pll_ct(int offset, const struct atyfb_par *par)\r\n{\r\nu8 res;\r\naty_st_8(CLOCK_CNTL_ADDR, (offset << 2) & PLL_ADDR, par);\r\nres = aty_ld_8(CLOCK_CNTL_DATA, par);\r\nreturn res;\r\n}\r\nstatic void aty_st_pll_ct(int offset, u8 val, const struct atyfb_par *par)\r\n{\r\naty_st_8(CLOCK_CNTL_ADDR, ((offset << 2) & PLL_ADDR) | PLL_WR_EN, par);\r\naty_st_8(CLOCK_CNTL_DATA, val & PLL_DATA, par);\r\naty_st_8(CLOCK_CNTL_ADDR, ((offset << 2) & PLL_ADDR) & ~PLL_WR_EN, par);\r\n}\r\nstatic int aty_dsp_gt(const struct fb_info *info, u32 bpp, struct pll_ct *pll)\r\n{\r\nu32 dsp_off, dsp_on, dsp_xclks;\r\nu32 multiplier, divider, ras_multiplier, ras_divider, tmp;\r\nu8 vshift, xshift;\r\ns8 dsp_precision;\r\nmultiplier = ((u32)pll->mclk_fb_div) * pll->vclk_post_div_real;\r\ndivider = ((u32)pll->vclk_fb_div) * pll->xclk_ref_div;\r\nras_multiplier = pll->xclkmaxrasdelay;\r\nras_divider = 1;\r\nif (bpp>=8)\r\ndivider = divider * (bpp >> 2);\r\nvshift = (6 - 2) - pll->xclk_post_div;\r\nif (bpp == 0)\r\nvshift--;\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif (pll->xres != 0) {\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nmultiplier = multiplier * par->lcd_width;\r\ndivider = divider * pll->xres & ~7;\r\nras_multiplier = ras_multiplier * par->lcd_width;\r\nras_divider = ras_divider * pll->xres & ~7;\r\n}\r\n#endif\r\nwhile (((multiplier | divider) & 1) == 0) {\r\nmultiplier = multiplier >> 1;\r\ndivider = divider >> 1;\r\n}\r\ntmp = ((multiplier * pll->fifo_size) << vshift) / divider;\r\nfor (dsp_precision = -5; tmp; dsp_precision++)\r\ntmp >>= 1;\r\nif (dsp_precision < 0)\r\ndsp_precision = 0;\r\nelse if (dsp_precision > Maximum_DSP_PRECISION)\r\ndsp_precision = Maximum_DSP_PRECISION;\r\nxshift = 6 - dsp_precision;\r\nvshift += xshift;\r\ndsp_off = ((multiplier * (pll->fifo_size - 1)) << vshift) / divider -\r\n(1 << (vshift - xshift));\r\n{\r\ndsp_on = ((multiplier << vshift) + divider) / divider;\r\ntmp = ((ras_multiplier << xshift) + ras_divider) / ras_divider;\r\nif (dsp_on < tmp)\r\ndsp_on = tmp;\r\ndsp_on = dsp_on + (tmp * 2) + (pll->xclkpagefaultdelay << xshift);\r\n}\r\ntmp = ((1 << (Maximum_DSP_PRECISION - dsp_precision)) - 1) >> 1;\r\ndsp_on = ((dsp_on + tmp) / (tmp + 1)) * (tmp + 1);\r\nif (dsp_on >= ((dsp_off / (tmp + 1)) * (tmp + 1))) {\r\ndsp_on = dsp_off - (multiplier << vshift) / divider;\r\ndsp_on = (dsp_on / (tmp + 1)) * (tmp + 1);\r\n}\r\ndsp_xclks = ((multiplier << (vshift + 5)) + divider) / divider;\r\npll->dsp_on_off = (dsp_on << 16) + dsp_off;\r\npll->dsp_config = (dsp_precision << 20) | (pll->dsp_loop_latency << 16) | dsp_xclks;\r\n#ifdef DEBUG\r\nprintk("atyfb(%s): dsp_config 0x%08x, dsp_on_off 0x%08x\n",\r\n__func__, pll->dsp_config, pll->dsp_on_off);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int aty_valid_pll_ct(const struct fb_info *info, u32 vclk_per, struct pll_ct *pll)\r\n{\r\nu32 q;\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nint pllvclk;\r\nq = par->ref_clk_per * pll->pll_ref_div * 4 / vclk_per;\r\nif (q < 16*8 || q > 255*8) {\r\nprintk(KERN_CRIT "atyfb: vclk out of range\n");\r\nreturn -EINVAL;\r\n} else {\r\npll->vclk_post_div = (q < 128*8);\r\npll->vclk_post_div += (q < 64*8);\r\npll->vclk_post_div += (q < 32*8);\r\n}\r\npll->vclk_post_div_real = postdividers[pll->vclk_post_div];\r\npll->vclk_fb_div = q * pll->vclk_post_div_real / 8;\r\npllvclk = (1000000 * 2 * pll->vclk_fb_div) /\r\n(par->ref_clk_per * pll->pll_ref_div);\r\n#ifdef DEBUG\r\nprintk("atyfb(%s): pllvclk=%d MHz, vclk=%d MHz\n",\r\n__func__, pllvclk, pllvclk / pll->vclk_post_div_real);\r\n#endif\r\npll->pll_vclk_cntl = 0x03;\r\nif (par->pll_limits.ecp_max) {\r\nint ecp = pllvclk / pll->vclk_post_div_real;\r\nint ecp_div = 0;\r\nwhile (ecp > par->pll_limits.ecp_max && ecp_div < 2) {\r\necp >>= 1;\r\necp_div++;\r\n}\r\npll->pll_vclk_cntl |= ecp_div << 4;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aty_var_to_pll_ct(const struct fb_info *info, u32 vclk_per, u32 bpp, union aty_pll *pll)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nint err;\r\nif ((err = aty_valid_pll_ct(info, vclk_per, &pll->ct)))\r\nreturn err;\r\nif (M64_HAS(GTB_DSP) && (err = aty_dsp_gt(info, bpp, &pll->ct)))\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic u32 aty_pll_to_var_ct(const struct fb_info *info, const union aty_pll *pll)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 ret;\r\nret = par->ref_clk_per * pll->ct.pll_ref_div * pll->ct.vclk_post_div_real / pll->ct.vclk_fb_div / 2;\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif(pll->ct.xres > 0) {\r\nret *= par->lcd_width;\r\nret /= pll->ct.xres;\r\n}\r\n#endif\r\n#ifdef DEBUG\r\nprintk("atyfb(%s): calculated 0x%08X(%i)\n", __func__, ret, ret);\r\n#endif\r\nreturn ret;\r\n}\r\nvoid aty_set_pll_ct(const struct fb_info *info, const union aty_pll *pll)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 crtc_gen_cntl, lcd_gen_cntrl;\r\nu8 tmp, tmp2;\r\nlcd_gen_cntrl = 0;\r\n#ifdef DEBUG\r\nprintk("atyfb(%s): about to program:\n"\r\n"pll_ext_cntl=0x%02x pll_gen_cntl=0x%02x pll_vclk_cntl=0x%02x\n",\r\n__func__,\r\npll->ct.pll_ext_cntl, pll->ct.pll_gen_cntl, pll->ct.pll_vclk_cntl);\r\nprintk("atyfb(%s): setting clock %lu for FeedBackDivider %i, ReferenceDivider %i, PostDivider %i(%i)\n",\r\n__func__,\r\npar->clk_wr_offset, pll->ct.vclk_fb_div,\r\npll->ct.pll_ref_div, pll->ct.vclk_post_div, pll->ct.vclk_post_div_real);\r\n#endif\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif (par->lcd_table != 0) {\r\nlcd_gen_cntrl = aty_ld_lcd(LCD_GEN_CNTL, par);\r\naty_st_lcd(LCD_GEN_CNTL, lcd_gen_cntrl & ~LCD_ON, par);\r\n}\r\n#endif\r\naty_st_8(CLOCK_CNTL, par->clk_wr_offset | CLOCK_STROBE, par);\r\ncrtc_gen_cntl = aty_ld_le32(CRTC_GEN_CNTL, par);\r\nif (!(crtc_gen_cntl & CRTC_EXT_DISP_EN))\r\naty_st_le32(CRTC_GEN_CNTL, crtc_gen_cntl | CRTC_EXT_DISP_EN, par);\r\naty_st_pll_ct(PLL_VCLK_CNTL, pll->ct.pll_vclk_cntl, par);\r\ntmp2 = par->clk_wr_offset << 1;\r\ntmp = aty_ld_pll_ct(VCLK_POST_DIV, par);\r\ntmp &= ~(0x03U << tmp2);\r\ntmp |= ((pll->ct.vclk_post_div & 0x03U) << tmp2);\r\naty_st_pll_ct(VCLK_POST_DIV, tmp, par);\r\ntmp = aty_ld_pll_ct(PLL_EXT_CNTL, par);\r\ntmp &= ~(0x10U << par->clk_wr_offset);\r\ntmp &= 0xF0U;\r\ntmp |= pll->ct.pll_ext_cntl;\r\naty_st_pll_ct(PLL_EXT_CNTL, tmp, par);\r\ntmp = VCLK0_FB_DIV + par->clk_wr_offset;\r\naty_st_pll_ct(tmp, (pll->ct.vclk_fb_div & 0xFFU), par);\r\naty_st_pll_ct(PLL_GEN_CNTL, (pll->ct.pll_gen_cntl & (~(PLL_OVERRIDE | PLL_MCLK_RST))) | OSC_EN, par);\r\naty_st_pll_ct(PLL_VCLK_CNTL, pll->ct.pll_vclk_cntl & ~(PLL_VCLK_RST), par);\r\nmdelay(5);\r\naty_st_pll_ct(PLL_GEN_CNTL, pll->ct.pll_gen_cntl, par);\r\naty_st_pll_ct(PLL_VCLK_CNTL, pll->ct.pll_vclk_cntl, par);\r\nmdelay(1);\r\nif (!(crtc_gen_cntl & CRTC_EXT_DISP_EN))\r\naty_st_le32(CRTC_GEN_CNTL, crtc_gen_cntl, par);\r\nif (M64_HAS(GTB_DSP)) {\r\nu8 dll_cntl;\r\nif (M64_HAS(XL_DLL))\r\ndll_cntl = 0x80;\r\nelse if (par->ram_type >= SDRAM)\r\ndll_cntl = 0xa6;\r\nelse\r\ndll_cntl = 0xa0;\r\naty_st_pll_ct(DLL_CNTL, dll_cntl, par);\r\naty_st_pll_ct(VFC_CNTL, 0x1b, par);\r\naty_st_le32(DSP_CONFIG, pll->ct.dsp_config, par);\r\naty_st_le32(DSP_ON_OFF, pll->ct.dsp_on_off, par);\r\nmdelay(10);\r\naty_st_pll_ct(DLL_CNTL, dll_cntl, par);\r\nmdelay(10);\r\naty_st_pll_ct(DLL_CNTL, dll_cntl | 0x40, par);\r\nmdelay(10);\r\naty_st_pll_ct(DLL_CNTL, dll_cntl & ~0x40, par);\r\n}\r\n#ifdef CONFIG_FB_ATY_GENERIC_LCD\r\nif (par->lcd_table != 0) {\r\naty_st_lcd(LCD_GEN_CNTL, lcd_gen_cntrl, par);\r\n}\r\n#endif\r\n}\r\nstatic void __devinit aty_get_pll_ct(const struct fb_info *info,\r\nunion aty_pll *pll)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu8 tmp, clock;\r\nclock = aty_ld_8(CLOCK_CNTL, par) & 0x03U;\r\ntmp = clock << 1;\r\npll->ct.vclk_post_div = (aty_ld_pll_ct(VCLK_POST_DIV, par) >> tmp) & 0x03U;\r\npll->ct.pll_ext_cntl = aty_ld_pll_ct(PLL_EXT_CNTL, par) & 0x0FU;\r\npll->ct.vclk_fb_div = aty_ld_pll_ct(VCLK0_FB_DIV + clock, par) & 0xFFU;\r\npll->ct.pll_ref_div = aty_ld_pll_ct(PLL_REF_DIV, par);\r\npll->ct.mclk_fb_div = aty_ld_pll_ct(MCLK_FB_DIV, par);\r\npll->ct.pll_gen_cntl = aty_ld_pll_ct(PLL_GEN_CNTL, par);\r\npll->ct.pll_vclk_cntl = aty_ld_pll_ct(PLL_VCLK_CNTL, par);\r\nif (M64_HAS(GTB_DSP)) {\r\npll->ct.dsp_config = aty_ld_le32(DSP_CONFIG, par);\r\npll->ct.dsp_on_off = aty_ld_le32(DSP_ON_OFF, par);\r\n}\r\n}\r\nstatic int __devinit aty_init_pll_ct(const struct fb_info *info,\r\nunion aty_pll *pll)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu8 mpost_div, xpost_div, sclk_post_div_real;\r\nu32 q, memcntl, trp;\r\nu32 dsp_config, dsp_on_off, vga_dsp_config, vga_dsp_on_off;\r\n#ifdef DEBUG\r\nint pllmclk, pllsclk;\r\n#endif\r\npll->ct.pll_ext_cntl = aty_ld_pll_ct(PLL_EXT_CNTL, par);\r\npll->ct.xclk_post_div = pll->ct.pll_ext_cntl & 0x07;\r\npll->ct.xclk_ref_div = 1;\r\nswitch (pll->ct.xclk_post_div) {\r\ncase 0: case 1: case 2: case 3:\r\nbreak;\r\ncase 4:\r\npll->ct.xclk_ref_div = 3;\r\npll->ct.xclk_post_div = 0;\r\nbreak;\r\ndefault:\r\nprintk(KERN_CRIT "atyfb: Unsupported xclk source: %d.\n", pll->ct.xclk_post_div);\r\nreturn -EINVAL;\r\n}\r\npll->ct.mclk_fb_mult = 2;\r\nif(pll->ct.pll_ext_cntl & PLL_MFB_TIMES_4_2B) {\r\npll->ct.mclk_fb_mult = 4;\r\npll->ct.xclk_post_div -= 1;\r\n}\r\n#ifdef DEBUG\r\nprintk("atyfb(%s): mclk_fb_mult=%d, xclk_post_div=%d\n",\r\n__func__, pll->ct.mclk_fb_mult, pll->ct.xclk_post_div);\r\n#endif\r\nmemcntl = aty_ld_le32(MEM_CNTL, par);\r\ntrp = (memcntl & 0x300) >> 8;\r\npll->ct.xclkpagefaultdelay = ((memcntl & 0xc00) >> 10) + ((memcntl & 0x1000) >> 12) + trp + 2;\r\npll->ct.xclkmaxrasdelay = ((memcntl & 0x70000) >> 16) + trp + 2;\r\nif (M64_HAS(FIFO_32)) {\r\npll->ct.fifo_size = 32;\r\n} else {\r\npll->ct.fifo_size = 24;\r\npll->ct.xclkpagefaultdelay += 2;\r\npll->ct.xclkmaxrasdelay += 3;\r\n}\r\nswitch (par->ram_type) {\r\ncase DRAM:\r\nif (info->fix.smem_len<=ONE_MB) {\r\npll->ct.dsp_loop_latency = 10;\r\n} else {\r\npll->ct.dsp_loop_latency = 8;\r\npll->ct.xclkpagefaultdelay += 2;\r\n}\r\nbreak;\r\ncase EDO:\r\ncase PSEUDO_EDO:\r\nif (info->fix.smem_len<=ONE_MB) {\r\npll->ct.dsp_loop_latency = 9;\r\n} else {\r\npll->ct.dsp_loop_latency = 8;\r\npll->ct.xclkpagefaultdelay += 1;\r\n}\r\nbreak;\r\ncase SDRAM:\r\nif (info->fix.smem_len<=ONE_MB) {\r\npll->ct.dsp_loop_latency = 11;\r\n} else {\r\npll->ct.dsp_loop_latency = 10;\r\npll->ct.xclkpagefaultdelay += 1;\r\n}\r\nbreak;\r\ncase SGRAM:\r\npll->ct.dsp_loop_latency = 8;\r\npll->ct.xclkpagefaultdelay += 3;\r\nbreak;\r\ndefault:\r\npll->ct.dsp_loop_latency = 11;\r\npll->ct.xclkpagefaultdelay += 3;\r\nbreak;\r\n}\r\nif (pll->ct.xclkmaxrasdelay <= pll->ct.xclkpagefaultdelay)\r\npll->ct.xclkmaxrasdelay = pll->ct.xclkpagefaultdelay + 1;\r\ndsp_config = aty_ld_le32(DSP_CONFIG, par);\r\ndsp_on_off = aty_ld_le32(DSP_ON_OFF, par);\r\nvga_dsp_config = aty_ld_le32(VGA_DSP_CONFIG, par);\r\nvga_dsp_on_off = aty_ld_le32(VGA_DSP_ON_OFF, par);\r\nif (dsp_config)\r\npll->ct.dsp_loop_latency = (dsp_config & DSP_LOOP_LATENCY) >> 16;\r\n#if 0\r\nFIXME: is it relevant for us?\r\nif ((!dsp_on_off && !M64_HAS(RESET_3D)) ||\r\n((dsp_on_off == vga_dsp_on_off) &&\r\n(!dsp_config || !((dsp_config ^ vga_dsp_config) & DSP_XCLKS_PER_QW)))) {\r\nvga_dsp_on_off &= VGA_DSP_OFF;\r\nvga_dsp_config &= VGA_DSP_XCLKS_PER_QW;\r\nif (ATIDivide(vga_dsp_on_off, vga_dsp_config, 5, 1) > 24)\r\npll->ct.fifo_size = 32;\r\nelse\r\npll->ct.fifo_size = 24;\r\n}\r\n#endif\r\nif (par->mclk_per == 0) {\r\nu8 mclk_fb_div, pll_ext_cntl;\r\npll->ct.pll_ref_div = aty_ld_pll_ct(PLL_REF_DIV, par);\r\npll_ext_cntl = aty_ld_pll_ct(PLL_EXT_CNTL, par);\r\npll->ct.xclk_post_div_real = postdividers[pll_ext_cntl & 0x07];\r\nmclk_fb_div = aty_ld_pll_ct(MCLK_FB_DIV, par);\r\nif (pll_ext_cntl & PLL_MFB_TIMES_4_2B)\r\nmclk_fb_div <<= 1;\r\npll->ct.mclk_fb_div = mclk_fb_div;\r\nreturn 0;\r\n}\r\npll->ct.pll_ref_div = par->pll_per * 2 * 255 / par->ref_clk_per;\r\nq = par->ref_clk_per * pll->ct.pll_ref_div * 8 /\r\n(pll->ct.mclk_fb_mult * par->xclk_per);\r\nif (q < 16*8 || q > 255*8) {\r\nprintk(KERN_CRIT "atxfb: xclk out of range\n");\r\nreturn -EINVAL;\r\n} else {\r\nxpost_div = (q < 128*8);\r\nxpost_div += (q < 64*8);\r\nxpost_div += (q < 32*8);\r\n}\r\npll->ct.xclk_post_div_real = postdividers[xpost_div];\r\npll->ct.mclk_fb_div = q * pll->ct.xclk_post_div_real / 8;\r\n#ifdef CONFIG_PPC\r\nif (machine_is(powermac)) {\r\npll->ct.xclk_post_div = xpost_div;\r\npll->ct.xclk_ref_div = 1;\r\n}\r\n#endif\r\n#ifdef DEBUG\r\npllmclk = (1000000 * pll->ct.mclk_fb_mult * pll->ct.mclk_fb_div) /\r\n(par->ref_clk_per * pll->ct.pll_ref_div);\r\nprintk("atyfb(%s): pllmclk=%d MHz, xclk=%d MHz\n",\r\n__func__, pllmclk, pllmclk / pll->ct.xclk_post_div_real);\r\n#endif\r\nif (M64_HAS(SDRAM_MAGIC_PLL) && (par->ram_type >= SDRAM))\r\npll->ct.pll_gen_cntl = OSC_EN;\r\nelse\r\npll->ct.pll_gen_cntl = OSC_EN | DLL_PWDN ;\r\nif (M64_HAS(MAGIC_POSTDIV))\r\npll->ct.pll_ext_cntl = 0;\r\nelse\r\npll->ct.pll_ext_cntl = xpost_div;\r\nif (pll->ct.mclk_fb_mult == 4)\r\npll->ct.pll_ext_cntl |= PLL_MFB_TIMES_4_2B;\r\nif (par->mclk_per == par->xclk_per) {\r\npll->ct.pll_gen_cntl |= (xpost_div << 4);\r\n} else {\r\npll->ct.pll_gen_cntl |= (6 << 4);\r\nq = par->ref_clk_per * pll->ct.pll_ref_div * 4 / par->mclk_per;\r\nif (q < 16*8 || q > 255*8) {\r\nprintk(KERN_CRIT "atyfb: mclk out of range\n");\r\nreturn -EINVAL;\r\n} else {\r\nmpost_div = (q < 128*8);\r\nmpost_div += (q < 64*8);\r\nmpost_div += (q < 32*8);\r\n}\r\nsclk_post_div_real = postdividers[mpost_div];\r\npll->ct.sclk_fb_div = q * sclk_post_div_real / 8;\r\npll->ct.spll_cntl2 = mpost_div << 4;\r\n#ifdef DEBUG\r\npllsclk = (1000000 * 2 * pll->ct.sclk_fb_div) /\r\n(par->ref_clk_per * pll->ct.pll_ref_div);\r\nprintk("atyfb(%s): use sclk, pllsclk=%d MHz, sclk=mclk=%d MHz\n",\r\n__func__, pllsclk, pllsclk / sclk_post_div_real);\r\n#endif\r\n}\r\npll->ct.ext_vpll_cntl = aty_ld_pll_ct(EXT_VPLL_CNTL, par);\r\npll->ct.ext_vpll_cntl &= ~(EXT_VPLL_EN | EXT_VPLL_VGA_EN | EXT_VPLL_INSYNC);\r\nreturn 0;\r\n}\r\nstatic void aty_resume_pll_ct(const struct fb_info *info,\r\nunion aty_pll *pll)\r\n{\r\nstruct atyfb_par *par = info->par;\r\nif (par->mclk_per != par->xclk_per) {\r\naty_st_pll_ct(SCLK_FB_DIV, pll->ct.sclk_fb_div, par);\r\naty_st_pll_ct(SPLL_CNTL2, pll->ct.spll_cntl2, par);\r\nmdelay(5);\r\n}\r\naty_st_pll_ct(PLL_REF_DIV, pll->ct.pll_ref_div, par);\r\naty_st_pll_ct(PLL_GEN_CNTL, pll->ct.pll_gen_cntl, par);\r\naty_st_pll_ct(MCLK_FB_DIV, pll->ct.mclk_fb_div, par);\r\naty_st_pll_ct(PLL_EXT_CNTL, pll->ct.pll_ext_cntl, par);\r\naty_st_pll_ct(EXT_VPLL_CNTL, pll->ct.ext_vpll_cntl, par);\r\n}\r\nstatic int dummy(void)\r\n{\r\nreturn 0;\r\n}
