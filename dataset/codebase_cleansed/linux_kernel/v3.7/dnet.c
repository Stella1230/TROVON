static u16 dnet_readw_mac(struct dnet *bp, u16 reg)\r\n{\r\nu16 data_read;\r\ndnet_writel(bp, reg, MACREG_ADDR);\r\nndelay(500);\r\ndata_read = dnet_readl(bp, MACREG_DATA);\r\nreturn data_read;\r\n}\r\nstatic void dnet_writew_mac(struct dnet *bp, u16 reg, u16 val)\r\n{\r\ndnet_writel(bp, val, MACREG_DATA);\r\ndnet_writel(bp, reg | DNET_INTERNAL_WRITE, MACREG_ADDR);\r\nndelay(500);\r\n}\r\nstatic void __dnet_set_hwaddr(struct dnet *bp)\r\n{\r\nu16 tmp;\r\ntmp = be16_to_cpup((__be16 *)bp->dev->dev_addr);\r\ndnet_writew_mac(bp, DNET_INTERNAL_MAC_ADDR_0_REG, tmp);\r\ntmp = be16_to_cpup((__be16 *)(bp->dev->dev_addr + 2));\r\ndnet_writew_mac(bp, DNET_INTERNAL_MAC_ADDR_1_REG, tmp);\r\ntmp = be16_to_cpup((__be16 *)(bp->dev->dev_addr + 4));\r\ndnet_writew_mac(bp, DNET_INTERNAL_MAC_ADDR_2_REG, tmp);\r\n}\r\nstatic void __devinit dnet_get_hwaddr(struct dnet *bp)\r\n{\r\nu16 tmp;\r\nu8 addr[6];\r\ntmp = dnet_readw_mac(bp, DNET_INTERNAL_MAC_ADDR_0_REG);\r\n*((__be16 *)addr) = cpu_to_be16(tmp);\r\ntmp = dnet_readw_mac(bp, DNET_INTERNAL_MAC_ADDR_1_REG);\r\n*((__be16 *)(addr + 2)) = cpu_to_be16(tmp);\r\ntmp = dnet_readw_mac(bp, DNET_INTERNAL_MAC_ADDR_2_REG);\r\n*((__be16 *)(addr + 4)) = cpu_to_be16(tmp);\r\nif (is_valid_ether_addr(addr))\r\nmemcpy(bp->dev->dev_addr, addr, sizeof(addr));\r\n}\r\nstatic int dnet_mdio_read(struct mii_bus *bus, int mii_id, int regnum)\r\n{\r\nstruct dnet *bp = bus->priv;\r\nu16 value;\r\nwhile (!(dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG)\r\n& DNET_INTERNAL_GMII_MNG_CMD_FIN))\r\ncpu_relax();\r\nmii_id &= 0x1f;\r\nregnum &= 0x1f;\r\nvalue = (mii_id << 8);\r\nvalue |= regnum;\r\ndnet_writew_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG, value);\r\nwhile (!(dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG)\r\n& DNET_INTERNAL_GMII_MNG_CMD_FIN))\r\ncpu_relax();\r\nvalue = dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_DAT_REG);\r\npr_debug("mdio_read %02x:%02x <- %04x\n", mii_id, regnum, value);\r\nreturn value;\r\n}\r\nstatic int dnet_mdio_write(struct mii_bus *bus, int mii_id, int regnum,\r\nu16 value)\r\n{\r\nstruct dnet *bp = bus->priv;\r\nu16 tmp;\r\npr_debug("mdio_write %02x:%02x <- %04x\n", mii_id, regnum, value);\r\nwhile (!(dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG)\r\n& DNET_INTERNAL_GMII_MNG_CMD_FIN))\r\ncpu_relax();\r\ntmp = (1 << 13);\r\nmii_id &= 0x1f;\r\nregnum &= 0x1f;\r\nvalue &= 0xffff;\r\ntmp |= (mii_id << 8);\r\ntmp |= regnum;\r\ndnet_writew_mac(bp, DNET_INTERNAL_GMII_MNG_DAT_REG, value);\r\ndnet_writew_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG, tmp);\r\nwhile (!(dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG)\r\n& DNET_INTERNAL_GMII_MNG_CMD_FIN))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic int dnet_mdio_reset(struct mii_bus *bus)\r\n{\r\nreturn 0;\r\n}\r\nstatic void dnet_handle_link_change(struct net_device *dev)\r\n{\r\nstruct dnet *bp = netdev_priv(dev);\r\nstruct phy_device *phydev = bp->phy_dev;\r\nunsigned long flags;\r\nu32 mode_reg, ctl_reg;\r\nint status_change = 0;\r\nspin_lock_irqsave(&bp->lock, flags);\r\nmode_reg = dnet_readw_mac(bp, DNET_INTERNAL_MODE_REG);\r\nctl_reg = dnet_readw_mac(bp, DNET_INTERNAL_RXTX_CONTROL_REG);\r\nif (phydev->link) {\r\nif (bp->duplex != phydev->duplex) {\r\nif (phydev->duplex)\r\nctl_reg &=\r\n~(DNET_INTERNAL_RXTX_CONTROL_ENABLEHALFDUP);\r\nelse\r\nctl_reg |=\r\nDNET_INTERNAL_RXTX_CONTROL_ENABLEHALFDUP;\r\nbp->duplex = phydev->duplex;\r\nstatus_change = 1;\r\n}\r\nif (bp->speed != phydev->speed) {\r\nstatus_change = 1;\r\nswitch (phydev->speed) {\r\ncase 1000:\r\nmode_reg |= DNET_INTERNAL_MODE_GBITEN;\r\nbreak;\r\ncase 100:\r\ncase 10:\r\nmode_reg &= ~DNET_INTERNAL_MODE_GBITEN;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"%s: Ack! Speed (%d) is not "\r\n"10/100/1000!\n", dev->name,\r\nphydev->speed);\r\nbreak;\r\n}\r\nbp->speed = phydev->speed;\r\n}\r\n}\r\nif (phydev->link != bp->link) {\r\nif (phydev->link) {\r\nmode_reg |=\r\n(DNET_INTERNAL_MODE_RXEN | DNET_INTERNAL_MODE_TXEN);\r\n} else {\r\nmode_reg &=\r\n~(DNET_INTERNAL_MODE_RXEN |\r\nDNET_INTERNAL_MODE_TXEN);\r\nbp->speed = 0;\r\nbp->duplex = -1;\r\n}\r\nbp->link = phydev->link;\r\nstatus_change = 1;\r\n}\r\nif (status_change) {\r\ndnet_writew_mac(bp, DNET_INTERNAL_RXTX_CONTROL_REG, ctl_reg);\r\ndnet_writew_mac(bp, DNET_INTERNAL_MODE_REG, mode_reg);\r\n}\r\nspin_unlock_irqrestore(&bp->lock, flags);\r\nif (status_change) {\r\nif (phydev->link)\r\nprintk(KERN_INFO "%s: link up (%d/%s)\n",\r\ndev->name, phydev->speed,\r\nDUPLEX_FULL == phydev->duplex ? "Full" : "Half");\r\nelse\r\nprintk(KERN_INFO "%s: link down\n", dev->name);\r\n}\r\n}\r\nstatic int dnet_mii_probe(struct net_device *dev)\r\n{\r\nstruct dnet *bp = netdev_priv(dev);\r\nstruct phy_device *phydev = NULL;\r\nint phy_addr;\r\nfor (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {\r\nif (bp->mii_bus->phy_map[phy_addr]) {\r\nphydev = bp->mii_bus->phy_map[phy_addr];\r\nbreak;\r\n}\r\n}\r\nif (!phydev) {\r\nprintk(KERN_ERR "%s: no PHY found\n", dev->name);\r\nreturn -ENODEV;\r\n}\r\nif (bp->capabilities & DNET_HAS_RMII) {\r\nphydev = phy_connect(dev, dev_name(&phydev->dev),\r\n&dnet_handle_link_change, 0,\r\nPHY_INTERFACE_MODE_RMII);\r\n} else {\r\nphydev = phy_connect(dev, dev_name(&phydev->dev),\r\n&dnet_handle_link_change, 0,\r\nPHY_INTERFACE_MODE_MII);\r\n}\r\nif (IS_ERR(phydev)) {\r\nprintk(KERN_ERR "%s: Could not attach to PHY\n", dev->name);\r\nreturn PTR_ERR(phydev);\r\n}\r\nif (bp->capabilities & DNET_HAS_GIGABIT)\r\nphydev->supported &= PHY_GBIT_FEATURES;\r\nelse\r\nphydev->supported &= PHY_BASIC_FEATURES;\r\nphydev->supported |= SUPPORTED_Asym_Pause | SUPPORTED_Pause;\r\nphydev->advertising = phydev->supported;\r\nbp->link = 0;\r\nbp->speed = 0;\r\nbp->duplex = -1;\r\nbp->phy_dev = phydev;\r\nreturn 0;\r\n}\r\nstatic int dnet_mii_init(struct dnet *bp)\r\n{\r\nint err, i;\r\nbp->mii_bus = mdiobus_alloc();\r\nif (bp->mii_bus == NULL)\r\nreturn -ENOMEM;\r\nbp->mii_bus->name = "dnet_mii_bus";\r\nbp->mii_bus->read = &dnet_mdio_read;\r\nbp->mii_bus->write = &dnet_mdio_write;\r\nbp->mii_bus->reset = &dnet_mdio_reset;\r\nsnprintf(bp->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",\r\nbp->pdev->name, bp->pdev->id);\r\nbp->mii_bus->priv = bp;\r\nbp->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);\r\nif (!bp->mii_bus->irq) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nfor (i = 0; i < PHY_MAX_ADDR; i++)\r\nbp->mii_bus->irq[i] = PHY_POLL;\r\nif (mdiobus_register(bp->mii_bus)) {\r\nerr = -ENXIO;\r\ngoto err_out_free_mdio_irq;\r\n}\r\nif (dnet_mii_probe(bp->dev) != 0) {\r\nerr = -ENXIO;\r\ngoto err_out_unregister_bus;\r\n}\r\nreturn 0;\r\nerr_out_unregister_bus:\r\nmdiobus_unregister(bp->mii_bus);\r\nerr_out_free_mdio_irq:\r\nkfree(bp->mii_bus->irq);\r\nerr_out:\r\nmdiobus_free(bp->mii_bus);\r\nreturn err;\r\n}\r\nstatic int dnet_phy_marvell_fixup(struct phy_device *phydev)\r\n{\r\nreturn phy_write(phydev, 0x18, 0x4148);\r\n}\r\nstatic void dnet_update_stats(struct dnet *bp)\r\n{\r\nu32 __iomem *reg = bp->regs + DNET_RX_PKT_IGNR_CNT;\r\nu32 *p = &bp->hw_stats.rx_pkt_ignr;\r\nu32 *end = &bp->hw_stats.rx_byte + 1;\r\nWARN_ON((unsigned long)(end - p - 1) !=\r\n(DNET_RX_BYTE_CNT - DNET_RX_PKT_IGNR_CNT) / 4);\r\nfor (; p < end; p++, reg++)\r\n*p += readl(reg);\r\nreg = bp->regs + DNET_TX_UNICAST_CNT;\r\np = &bp->hw_stats.tx_unicast;\r\nend = &bp->hw_stats.tx_byte + 1;\r\nWARN_ON((unsigned long)(end - p - 1) !=\r\n(DNET_TX_BYTE_CNT - DNET_TX_UNICAST_CNT) / 4);\r\nfor (; p < end; p++, reg++)\r\n*p += readl(reg);\r\n}\r\nstatic int dnet_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct dnet *bp = container_of(napi, struct dnet, napi);\r\nstruct net_device *dev = bp->dev;\r\nint npackets = 0;\r\nunsigned int pkt_len;\r\nstruct sk_buff *skb;\r\nunsigned int *data_ptr;\r\nu32 int_enable;\r\nu32 cmd_word;\r\nint i;\r\nwhile (npackets < budget) {\r\nif (!(dnet_readl(bp, RX_FIFO_WCNT) >> 16)) {\r\nnapi_complete(napi);\r\nint_enable = dnet_readl(bp, INTR_ENB);\r\nint_enable |= DNET_INTR_SRC_RX_CMDFIFOAF;\r\ndnet_writel(bp, int_enable, INTR_ENB);\r\nreturn 0;\r\n}\r\ncmd_word = dnet_readl(bp, RX_LEN_FIFO);\r\npkt_len = cmd_word & 0xFFFF;\r\nif (cmd_word & 0xDF180000)\r\nprintk(KERN_ERR "%s packet receive error %x\n",\r\n__func__, cmd_word);\r\nskb = netdev_alloc_skb(dev, pkt_len + 5);\r\nif (skb != NULL) {\r\nskb_reserve(skb, 2);\r\ndata_ptr = (unsigned int *)skb_put(skb, pkt_len);\r\nfor (i = 0; i < (pkt_len + 3) >> 2; i++)\r\n*data_ptr++ = dnet_readl(bp, RX_DATA_FIFO);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_receive_skb(skb);\r\nnpackets++;\r\n} else\r\nprintk(KERN_NOTICE\r\n"%s: No memory to allocate a sk_buff of "\r\n"size %u.\n", dev->name, pkt_len);\r\n}\r\nbudget -= npackets;\r\nif (npackets < budget) {\r\nnapi_complete(napi);\r\nint_enable = dnet_readl(bp, INTR_ENB);\r\nint_enable |= DNET_INTR_SRC_RX_CMDFIFOAF;\r\ndnet_writel(bp, int_enable, INTR_ENB);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic irqreturn_t dnet_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct dnet *bp = netdev_priv(dev);\r\nu32 int_src, int_enable, int_current;\r\nunsigned long flags;\r\nunsigned int handled = 0;\r\nspin_lock_irqsave(&bp->lock, flags);\r\nint_src = dnet_readl(bp, INTR_SRC);\r\nint_enable = dnet_readl(bp, INTR_ENB);\r\nint_current = int_src & int_enable;\r\nif (int_current & DNET_INTR_SRC_TX_FIFOAE) {\r\nint_enable = dnet_readl(bp, INTR_ENB);\r\nint_enable &= ~DNET_INTR_ENB_TX_FIFOAE;\r\ndnet_writel(bp, int_enable, INTR_ENB);\r\nnetif_wake_queue(dev);\r\nhandled = 1;\r\n}\r\nif (int_current &\r\n(DNET_INTR_SRC_RX_CMDFIFOFF | DNET_INTR_SRC_RX_DATAFIFOFF)) {\r\nprintk(KERN_ERR "%s: RX fifo error %x, irq %x\n", __func__,\r\ndnet_readl(bp, RX_STATUS), int_current);\r\ndnet_writel(bp, DNET_SYS_CTL_RXFIFOFLUSH, SYS_CTL);\r\nndelay(500);\r\ndnet_writel(bp, 0, SYS_CTL);\r\nhandled = 1;\r\n}\r\nif (int_current &\r\n(DNET_INTR_SRC_TX_FIFOFULL | DNET_INTR_SRC_TX_DISCFRM)) {\r\nprintk(KERN_ERR "%s: TX fifo error %x, irq %x\n", __func__,\r\ndnet_readl(bp, TX_STATUS), int_current);\r\ndnet_writel(bp, DNET_SYS_CTL_TXFIFOFLUSH, SYS_CTL);\r\nndelay(500);\r\ndnet_writel(bp, 0, SYS_CTL);\r\nhandled = 1;\r\n}\r\nif (int_current & DNET_INTR_SRC_RX_CMDFIFOAF) {\r\nif (napi_schedule_prep(&bp->napi)) {\r\nint_enable = dnet_readl(bp, INTR_ENB);\r\nint_enable &= ~DNET_INTR_SRC_RX_CMDFIFOAF;\r\ndnet_writel(bp, int_enable, INTR_ENB);\r\n__napi_schedule(&bp->napi);\r\n}\r\nhandled = 1;\r\n}\r\nif (!handled)\r\npr_debug("%s: irq %x remains\n", __func__, int_current);\r\nspin_unlock_irqrestore(&bp->lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic inline void dnet_print_skb(struct sk_buff *skb)\r\n{\r\nint k;\r\nprintk(KERN_DEBUG PFX "data:");\r\nfor (k = 0; k < skb->len; k++)\r\nprintk(" %02x", (unsigned int)skb->data[k]);\r\nprintk("\n");\r\n}\r\nstatic netdev_tx_t dnet_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct dnet *bp = netdev_priv(dev);\r\nu32 tx_status, irq_enable;\r\nunsigned int len, i, tx_cmd, wrsz;\r\nunsigned long flags;\r\nunsigned int *bufp;\r\ntx_status = dnet_readl(bp, TX_STATUS);\r\npr_debug("start_xmit: len %u head %p data %p\n",\r\nskb->len, skb->head, skb->data);\r\ndnet_print_skb(skb);\r\nlen = (skb->len + 3) >> 2;\r\nspin_lock_irqsave(&bp->lock, flags);\r\ntx_status = dnet_readl(bp, TX_STATUS);\r\nbufp = (unsigned int *)(((unsigned long) skb->data) & ~0x3UL);\r\nwrsz = (u32) skb->len + 3;\r\nwrsz += ((unsigned long) skb->data) & 0x3;\r\nwrsz >>= 2;\r\ntx_cmd = ((((unsigned long)(skb->data)) & 0x03) << 16) | (u32) skb->len;\r\nif (wrsz < (DNET_FIFO_SIZE - dnet_readl(bp, TX_FIFO_WCNT))) {\r\nfor (i = 0; i < wrsz; i++)\r\ndnet_writel(bp, *bufp++, TX_DATA_FIFO);\r\ndnet_writel(bp, tx_cmd, TX_LEN_FIFO);\r\n}\r\nif (dnet_readl(bp, TX_FIFO_WCNT) > DNET_FIFO_TX_DATA_AF_TH) {\r\nnetif_stop_queue(dev);\r\ntx_status = dnet_readl(bp, INTR_SRC);\r\nirq_enable = dnet_readl(bp, INTR_ENB);\r\nirq_enable |= DNET_INTR_ENB_TX_FIFOAE;\r\ndnet_writel(bp, irq_enable, INTR_ENB);\r\n}\r\nskb_tx_timestamp(skb);\r\ndev_kfree_skb(skb);\r\nspin_unlock_irqrestore(&bp->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void dnet_reset_hw(struct dnet *bp)\r\n{\r\ndnet_writew_mac(bp, DNET_INTERNAL_MODE_REG, DNET_INTERNAL_MODE_FCEN);\r\ndnet_writel(bp, DNET_FIFO_RX_CMD_AF_TH, RX_FIFO_TH);\r\ndnet_writel(bp, DNET_FIFO_TX_DATA_AE_TH, TX_FIFO_TH);\r\ndnet_writel(bp, DNET_SYS_CTL_RXFIFOFLUSH | DNET_SYS_CTL_TXFIFOFLUSH,\r\nSYS_CTL);\r\nmsleep(1);\r\ndnet_writel(bp, 0, SYS_CTL);\r\n}\r\nstatic void dnet_init_hw(struct dnet *bp)\r\n{\r\nu32 config;\r\ndnet_reset_hw(bp);\r\n__dnet_set_hwaddr(bp);\r\nconfig = dnet_readw_mac(bp, DNET_INTERNAL_RXTX_CONTROL_REG);\r\nif (bp->dev->flags & IFF_PROMISC)\r\nconfig |= DNET_INTERNAL_RXTX_CONTROL_ENPROMISC;\r\nif (!(bp->dev->flags & IFF_BROADCAST))\r\nconfig |= DNET_INTERNAL_RXTX_CONTROL_RXMULTICAST;\r\nconfig |= DNET_INTERNAL_RXTX_CONTROL_RXPAUSE |\r\nDNET_INTERNAL_RXTX_CONTROL_RXBROADCAST |\r\nDNET_INTERNAL_RXTX_CONTROL_DROPCONTROL |\r\nDNET_INTERNAL_RXTX_CONTROL_DISCFXFCS;\r\ndnet_writew_mac(bp, DNET_INTERNAL_RXTX_CONTROL_REG, config);\r\nconfig = dnet_readl(bp, INTR_SRC);\r\ndnet_writel(bp, DNET_INTR_ENB_GLOBAL_ENABLE | DNET_INTR_ENB_RX_SUMMARY |\r\nDNET_INTR_ENB_TX_SUMMARY | DNET_INTR_ENB_RX_FIFOERR |\r\nDNET_INTR_ENB_RX_ERROR | DNET_INTR_ENB_RX_FIFOFULL |\r\nDNET_INTR_ENB_TX_FIFOFULL | DNET_INTR_ENB_TX_DISCFRM |\r\nDNET_INTR_ENB_RX_PKTRDY, INTR_ENB);\r\n}\r\nstatic int dnet_open(struct net_device *dev)\r\n{\r\nstruct dnet *bp = netdev_priv(dev);\r\nif (!bp->phy_dev)\r\nreturn -EAGAIN;\r\nif (!is_valid_ether_addr(dev->dev_addr))\r\nreturn -EADDRNOTAVAIL;\r\nnapi_enable(&bp->napi);\r\ndnet_init_hw(bp);\r\nphy_start_aneg(bp->phy_dev);\r\nphy_start(bp->phy_dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int dnet_close(struct net_device *dev)\r\n{\r\nstruct dnet *bp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&bp->napi);\r\nif (bp->phy_dev)\r\nphy_stop(bp->phy_dev);\r\ndnet_reset_hw(bp);\r\nnetif_carrier_off(dev);\r\nreturn 0;\r\n}\r\nstatic inline void dnet_print_pretty_hwstats(struct dnet_stats *hwstat)\r\n{\r\npr_debug("%s\n", __func__);\r\npr_debug("----------------------------- RX statistics "\r\n"-------------------------------\n");\r\npr_debug("RX_PKT_IGNR_CNT %-8x\n", hwstat->rx_pkt_ignr);\r\npr_debug("RX_LEN_CHK_ERR_CNT %-8x\n", hwstat->rx_len_chk_err);\r\npr_debug("RX_LNG_FRM_CNT %-8x\n", hwstat->rx_lng_frm);\r\npr_debug("RX_SHRT_FRM_CNT %-8x\n", hwstat->rx_shrt_frm);\r\npr_debug("RX_IPG_VIOL_CNT %-8x\n", hwstat->rx_ipg_viol);\r\npr_debug("RX_CRC_ERR_CNT %-8x\n", hwstat->rx_crc_err);\r\npr_debug("RX_OK_PKT_CNT %-8x\n", hwstat->rx_ok_pkt);\r\npr_debug("RX_CTL_FRM_CNT %-8x\n", hwstat->rx_ctl_frm);\r\npr_debug("RX_PAUSE_FRM_CNT %-8x\n", hwstat->rx_pause_frm);\r\npr_debug("RX_MULTICAST_CNT %-8x\n", hwstat->rx_multicast);\r\npr_debug("RX_BROADCAST_CNT %-8x\n", hwstat->rx_broadcast);\r\npr_debug("RX_VLAN_TAG_CNT %-8x\n", hwstat->rx_vlan_tag);\r\npr_debug("RX_PRE_SHRINK_CNT %-8x\n", hwstat->rx_pre_shrink);\r\npr_debug("RX_DRIB_NIB_CNT %-8x\n", hwstat->rx_drib_nib);\r\npr_debug("RX_UNSUP_OPCD_CNT %-8x\n", hwstat->rx_unsup_opcd);\r\npr_debug("RX_BYTE_CNT %-8x\n", hwstat->rx_byte);\r\npr_debug("----------------------------- TX statistics "\r\n"-------------------------------\n");\r\npr_debug("TX_UNICAST_CNT %-8x\n", hwstat->tx_unicast);\r\npr_debug("TX_PAUSE_FRM_CNT %-8x\n", hwstat->tx_pause_frm);\r\npr_debug("TX_MULTICAST_CNT %-8x\n", hwstat->tx_multicast);\r\npr_debug("TX_BRDCAST_CNT %-8x\n", hwstat->tx_brdcast);\r\npr_debug("TX_VLAN_TAG_CNT %-8x\n", hwstat->tx_vlan_tag);\r\npr_debug("TX_BAD_FCS_CNT %-8x\n", hwstat->tx_bad_fcs);\r\npr_debug("TX_JUMBO_CNT %-8x\n", hwstat->tx_jumbo);\r\npr_debug("TX_BYTE_CNT %-8x\n", hwstat->tx_byte);\r\n}\r\nstatic struct net_device_stats *dnet_get_stats(struct net_device *dev)\r\n{\r\nstruct dnet *bp = netdev_priv(dev);\r\nstruct net_device_stats *nstat = &dev->stats;\r\nstruct dnet_stats *hwstat = &bp->hw_stats;\r\ndnet_update_stats(bp);\r\nnstat->rx_errors = (hwstat->rx_len_chk_err +\r\nhwstat->rx_lng_frm + hwstat->rx_shrt_frm +\r\nhwstat->rx_crc_err +\r\nhwstat->rx_pre_shrink +\r\nhwstat->rx_drib_nib + hwstat->rx_unsup_opcd);\r\nnstat->tx_errors = hwstat->tx_bad_fcs;\r\nnstat->rx_length_errors = (hwstat->rx_len_chk_err +\r\nhwstat->rx_lng_frm +\r\nhwstat->rx_shrt_frm + hwstat->rx_pre_shrink);\r\nnstat->rx_crc_errors = hwstat->rx_crc_err;\r\nnstat->rx_frame_errors = hwstat->rx_pre_shrink + hwstat->rx_drib_nib;\r\nnstat->rx_packets = hwstat->rx_ok_pkt;\r\nnstat->tx_packets = (hwstat->tx_unicast +\r\nhwstat->tx_multicast + hwstat->tx_brdcast);\r\nnstat->rx_bytes = hwstat->rx_byte;\r\nnstat->tx_bytes = hwstat->tx_byte;\r\nnstat->multicast = hwstat->rx_multicast;\r\nnstat->rx_missed_errors = hwstat->rx_pkt_ignr;\r\ndnet_print_pretty_hwstats(hwstat);\r\nreturn nstat;\r\n}\r\nstatic int dnet_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct dnet *bp = netdev_priv(dev);\r\nstruct phy_device *phydev = bp->phy_dev;\r\nif (!phydev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_gset(phydev, cmd);\r\n}\r\nstatic int dnet_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct dnet *bp = netdev_priv(dev);\r\nstruct phy_device *phydev = bp->phy_dev;\r\nif (!phydev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_sset(phydev, cmd);\r\n}\r\nstatic int dnet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct dnet *bp = netdev_priv(dev);\r\nstruct phy_device *phydev = bp->phy_dev;\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nif (!phydev)\r\nreturn -ENODEV;\r\nreturn phy_mii_ioctl(phydev, rq, cmd);\r\n}\r\nstatic void dnet_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, "0", sizeof(info->bus_info));\r\n}\r\nstatic int __devinit dnet_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct net_device *dev;\r\nstruct dnet *bp;\r\nstruct phy_device *phydev;\r\nint err = -ENXIO;\r\nunsigned int mem_base, mem_size, irq;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no mmio resource defined\n");\r\ngoto err_out;\r\n}\r\nmem_base = res->start;\r\nmem_size = resource_size(res);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!request_mem_region(mem_base, mem_size, DRV_NAME)) {\r\ndev_err(&pdev->dev, "no memory region available\n");\r\nerr = -EBUSY;\r\ngoto err_out;\r\n}\r\nerr = -ENOMEM;\r\ndev = alloc_etherdev(sizeof(*bp));\r\nif (!dev)\r\ngoto err_out_release_mem;\r\ndev->features |= 0;\r\nbp = netdev_priv(dev);\r\nbp->dev = dev;\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nspin_lock_init(&bp->lock);\r\nbp->regs = ioremap(mem_base, mem_size);\r\nif (!bp->regs) {\r\ndev_err(&pdev->dev, "failed to map registers, aborting.\n");\r\nerr = -ENOMEM;\r\ngoto err_out_free_dev;\r\n}\r\ndev->irq = irq;\r\nerr = request_irq(dev->irq, dnet_interrupt, 0, DRV_NAME, dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Unable to request IRQ %d (error %d)\n",\r\nirq, err);\r\ngoto err_out_iounmap;\r\n}\r\ndev->netdev_ops = &dnet_netdev_ops;\r\nnetif_napi_add(dev, &bp->napi, dnet_poll, 64);\r\ndev->ethtool_ops = &dnet_ethtool_ops;\r\ndev->base_addr = (unsigned long)bp->regs;\r\nbp->capabilities = dnet_readl(bp, VERCAPS) & DNET_CAPS_MASK;\r\ndnet_get_hwaddr(bp);\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\neth_hw_addr_random(dev);\r\n__dnet_set_hwaddr(bp);\r\n}\r\nerr = register_netdev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot register net device, aborting.\n");\r\ngoto err_out_free_irq;\r\n}\r\nerr = phy_register_fixup_for_uid(0x01410cc0, 0xfffffff0,\r\ndnet_phy_marvell_fixup);\r\nif (err)\r\ndev_warn(&pdev->dev, "Cannot register PHY board fixup.\n");\r\nerr = dnet_mii_init(bp);\r\nif (err)\r\ngoto err_out_unregister_netdev;\r\ndev_info(&pdev->dev, "Dave DNET at 0x%p (0x%08x) irq %d %pM\n",\r\nbp->regs, mem_base, dev->irq, dev->dev_addr);\r\ndev_info(&pdev->dev, "has %smdio, %sirq, %sgigabit, %sdma\n",\r\n(bp->capabilities & DNET_HAS_MDIO) ? "" : "no ",\r\n(bp->capabilities & DNET_HAS_IRQ) ? "" : "no ",\r\n(bp->capabilities & DNET_HAS_GIGABIT) ? "" : "no ",\r\n(bp->capabilities & DNET_HAS_DMA) ? "" : "no ");\r\nphydev = bp->phy_dev;\r\ndev_info(&pdev->dev, "attached PHY driver [%s] "\r\n"(mii_bus:phy_addr=%s, irq=%d)\n",\r\nphydev->drv->name, dev_name(&phydev->dev), phydev->irq);\r\nreturn 0;\r\nerr_out_unregister_netdev:\r\nunregister_netdev(dev);\r\nerr_out_free_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_out_iounmap:\r\niounmap(bp->regs);\r\nerr_out_free_dev:\r\nfree_netdev(dev);\r\nerr_out_release_mem:\r\nrelease_mem_region(mem_base, mem_size);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int __devexit dnet_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct dnet *bp;\r\ndev = platform_get_drvdata(pdev);\r\nif (dev) {\r\nbp = netdev_priv(dev);\r\nif (bp->phy_dev)\r\nphy_disconnect(bp->phy_dev);\r\nmdiobus_unregister(bp->mii_bus);\r\nkfree(bp->mii_bus->irq);\r\nmdiobus_free(bp->mii_bus);\r\nunregister_netdev(dev);\r\nfree_irq(dev->irq, dev);\r\niounmap(bp->regs);\r\nfree_netdev(dev);\r\n}\r\nreturn 0;\r\n}
