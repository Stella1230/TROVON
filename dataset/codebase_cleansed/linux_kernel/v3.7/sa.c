static irqreturn_t aac_sa_intr(int irq, void *dev_id)\r\n{\r\nstruct aac_dev *dev = dev_id;\r\nunsigned short intstat, mask;\r\nintstat = sa_readw(dev, DoorbellReg_p);\r\nmask = ~(sa_readw(dev, SaDbCSR.PRISETIRQMASK));\r\nif (intstat & mask) {\r\nif (intstat & PrintfReady) {\r\naac_printf(dev, sa_readl(dev, Mailbox5));\r\nsa_writew(dev, DoorbellClrReg_p, PrintfReady);\r\nsa_writew(dev, DoorbellReg_s, PrintfDone);\r\n} else if (intstat & DOORBELL_1) {\r\nsa_writew(dev, DoorbellClrReg_p, DOORBELL_1);\r\naac_command_normal(&dev->queues->queue[HostNormCmdQueue]);\r\n} else if (intstat & DOORBELL_2) {\r\nsa_writew(dev, DoorbellClrReg_p, DOORBELL_2);\r\naac_response_normal(&dev->queues->queue[HostNormRespQueue]);\r\n} else if (intstat & DOORBELL_3) {\r\nsa_writew(dev, DoorbellClrReg_p, DOORBELL_3);\r\n} else if (intstat & DOORBELL_4) {\r\nsa_writew(dev, DoorbellClrReg_p, DOORBELL_4);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void aac_sa_disable_interrupt (struct aac_dev *dev)\r\n{\r\nsa_writew(dev, SaDbCSR.PRISETIRQMASK, 0xffff);\r\n}\r\nstatic void aac_sa_enable_interrupt (struct aac_dev *dev)\r\n{\r\nsa_writew(dev, SaDbCSR.PRICLEARIRQMASK, (PrintfReady | DOORBELL_1 |\r\nDOORBELL_2 | DOORBELL_3 | DOORBELL_4));\r\n}\r\nstatic void aac_sa_notify_adapter(struct aac_dev *dev, u32 event)\r\n{\r\nswitch (event) {\r\ncase AdapNormCmdQue:\r\nsa_writew(dev, DoorbellReg_s,DOORBELL_1);\r\nbreak;\r\ncase HostNormRespNotFull:\r\nsa_writew(dev, DoorbellReg_s,DOORBELL_4);\r\nbreak;\r\ncase AdapNormRespQue:\r\nsa_writew(dev, DoorbellReg_s,DOORBELL_2);\r\nbreak;\r\ncase HostNormCmdNotFull:\r\nsa_writew(dev, DoorbellReg_s,DOORBELL_3);\r\nbreak;\r\ncase HostShutdown:\r\nbreak;\r\ncase FastIo:\r\nsa_writew(dev, DoorbellReg_s,DOORBELL_6);\r\nbreak;\r\ncase AdapPrintfDone:\r\nsa_writew(dev, DoorbellReg_s,DOORBELL_5);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nstatic int sa_sync_cmd(struct aac_dev *dev, u32 command,\r\nu32 p1, u32 p2, u32 p3, u32 p4, u32 p5, u32 p6,\r\nu32 *ret, u32 *r1, u32 *r2, u32 *r3, u32 *r4)\r\n{\r\nunsigned long start;\r\nint ok;\r\nsa_writel(dev, Mailbox0, command);\r\nsa_writel(dev, Mailbox1, p1);\r\nsa_writel(dev, Mailbox2, p2);\r\nsa_writel(dev, Mailbox3, p3);\r\nsa_writel(dev, Mailbox4, p4);\r\nsa_writew(dev, DoorbellClrReg_p, DOORBELL_0);\r\nsa_writew(dev, DoorbellReg_s, DOORBELL_0);\r\nok = 0;\r\nstart = jiffies;\r\nwhile(time_before(jiffies, start+30*HZ))\r\n{\r\nudelay(5);\r\nif(sa_readw(dev, DoorbellReg_p) & DOORBELL_0) {\r\nok = 1;\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\nif (ok != 1)\r\nreturn -ETIMEDOUT;\r\nsa_writew(dev, DoorbellClrReg_p, DOORBELL_0);\r\nif (ret)\r\n*ret = sa_readl(dev, Mailbox0);\r\nif (r1)\r\n*r1 = sa_readl(dev, Mailbox1);\r\nif (r2)\r\n*r2 = sa_readl(dev, Mailbox2);\r\nif (r3)\r\n*r3 = sa_readl(dev, Mailbox3);\r\nif (r4)\r\n*r4 = sa_readl(dev, Mailbox4);\r\nreturn 0;\r\n}\r\nstatic void aac_sa_interrupt_adapter (struct aac_dev *dev)\r\n{\r\nsa_sync_cmd(dev, BREAKPOINT_REQUEST, 0, 0, 0, 0, 0, 0,\r\nNULL, NULL, NULL, NULL, NULL);\r\n}\r\nstatic void aac_sa_start_adapter(struct aac_dev *dev)\r\n{\r\nstruct aac_init *init;\r\ninit = dev->init;\r\ninit->HostElapsedSeconds = cpu_to_le32(get_seconds());\r\nsa_sync_cmd(dev, INIT_STRUCT_BASE_ADDRESS,\r\n(u32)(ulong)dev->init_pa, 0, 0, 0, 0, 0,\r\nNULL, NULL, NULL, NULL, NULL);\r\n}\r\nstatic int aac_sa_restart_adapter(struct aac_dev *dev, int bled)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int aac_sa_check_health(struct aac_dev *dev)\r\n{\r\nlong status = sa_readl(dev, Mailbox7);\r\nif (status & SELF_TEST_FAILED)\r\nreturn -1;\r\nif (status & KERNEL_PANIC)\r\nreturn -2;\r\nif (!(status & KERNEL_UP_AND_RUNNING))\r\nreturn -3;\r\nreturn 0;\r\n}\r\nstatic int aac_sa_ioremap(struct aac_dev * dev, u32 size)\r\n{\r\nif (!size) {\r\niounmap(dev->regs.sa);\r\nreturn 0;\r\n}\r\ndev->base = dev->regs.sa = ioremap(dev->base_start, size);\r\nreturn (dev->base == NULL) ? -1 : 0;\r\n}\r\nint aac_sa_init(struct aac_dev *dev)\r\n{\r\nunsigned long start;\r\nunsigned long status;\r\nint instance;\r\nconst char *name;\r\ninstance = dev->id;\r\nname = dev->name;\r\nif (aac_sa_ioremap(dev, dev->base_size)) {\r\nprintk(KERN_WARNING "%s: unable to map adapter.\n", name);\r\ngoto error_iounmap;\r\n}\r\nif (sa_readl(dev, Mailbox7) & SELF_TEST_FAILED) {\r\nprintk(KERN_WARNING "%s%d: adapter self-test failed.\n", name, instance);\r\ngoto error_iounmap;\r\n}\r\nif (sa_readl(dev, Mailbox7) & KERNEL_PANIC) {\r\nprintk(KERN_WARNING "%s%d: adapter kernel panic'd.\n", name, instance);\r\ngoto error_iounmap;\r\n}\r\nstart = jiffies;\r\nwhile (!(sa_readl(dev, Mailbox7) & KERNEL_UP_AND_RUNNING)) {\r\nif (time_after(jiffies, start+startup_timeout*HZ)) {\r\nstatus = sa_readl(dev, Mailbox7);\r\nprintk(KERN_WARNING "%s%d: adapter kernel failed to start, init status = %lx.\n",\r\nname, instance, status);\r\ngoto error_iounmap;\r\n}\r\nmsleep(1);\r\n}\r\ndev->a_ops.adapter_interrupt = aac_sa_interrupt_adapter;\r\ndev->a_ops.adapter_disable_int = aac_sa_disable_interrupt;\r\ndev->a_ops.adapter_enable_int = aac_sa_enable_interrupt;\r\ndev->a_ops.adapter_notify = aac_sa_notify_adapter;\r\ndev->a_ops.adapter_sync_cmd = sa_sync_cmd;\r\ndev->a_ops.adapter_check_health = aac_sa_check_health;\r\ndev->a_ops.adapter_restart = aac_sa_restart_adapter;\r\ndev->a_ops.adapter_intr = aac_sa_intr;\r\ndev->a_ops.adapter_deliver = aac_rx_deliver_producer;\r\ndev->a_ops.adapter_ioremap = aac_sa_ioremap;\r\naac_adapter_disable_int(dev);\r\naac_adapter_enable_int(dev);\r\nif(aac_init_adapter(dev) == NULL)\r\ngoto error_irq;\r\ndev->sync_mode = 0;\r\nif (request_irq(dev->pdev->irq, dev->a_ops.adapter_intr,\r\nIRQF_SHARED|IRQF_DISABLED,\r\n"aacraid", (void *)dev ) < 0) {\r\nprintk(KERN_WARNING "%s%d: Interrupt unavailable.\n",\r\nname, instance);\r\ngoto error_iounmap;\r\n}\r\ndev->dbg_base = dev->base_start;\r\ndev->dbg_base_mapped = dev->base;\r\ndev->dbg_size = dev->base_size;\r\naac_adapter_enable_int(dev);\r\naac_sa_start_adapter(dev);\r\nreturn 0;\r\nerror_irq:\r\naac_sa_disable_interrupt(dev);\r\nfree_irq(dev->pdev->irq, (void *)dev);\r\nerror_iounmap:\r\nreturn -1;\r\n}
