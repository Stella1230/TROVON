static int wacom_query_device(struct i2c_client *client,\r\nstruct wacom_features *features)\r\n{\r\nint ret;\r\nu8 cmd1[] = { WACOM_CMD_QUERY0, WACOM_CMD_QUERY1,\r\nWACOM_CMD_QUERY2, WACOM_CMD_QUERY3 };\r\nu8 cmd2[] = { WACOM_CMD_THROW0, WACOM_CMD_THROW1 };\r\nu8 data[WACOM_QUERY_SIZE];\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = sizeof(cmd1),\r\n.buf = cmd1,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = sizeof(cmd2),\r\n.buf = cmd2,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = sizeof(data),\r\n.buf = data,\r\n},\r\n};\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != ARRAY_SIZE(msgs))\r\nreturn -EIO;\r\nfeatures->x_max = get_unaligned_le16(&data[3]);\r\nfeatures->y_max = get_unaligned_le16(&data[5]);\r\nfeatures->pressure_max = get_unaligned_le16(&data[11]);\r\nfeatures->fw_version = get_unaligned_le16(&data[13]);\r\ndev_dbg(&client->dev,\r\n"x_max:%d, y_max:%d, pressure:%d, fw:%d\n",\r\nfeatures->x_max, features->y_max,\r\nfeatures->pressure_max, features->fw_version);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t wacom_i2c_irq(int irq, void *dev_id)\r\n{\r\nstruct wacom_i2c *wac_i2c = dev_id;\r\nstruct input_dev *input = wac_i2c->input;\r\nu8 *data = wac_i2c->data;\r\nunsigned int x, y, pressure;\r\nunsigned char tsw, f1, f2, ers;\r\nint error;\r\nerror = i2c_master_recv(wac_i2c->client,\r\nwac_i2c->data, sizeof(wac_i2c->data));\r\nif (error < 0)\r\ngoto out;\r\ntsw = data[3] & 0x01;\r\ners = data[3] & 0x04;\r\nf1 = data[3] & 0x02;\r\nf2 = data[3] & 0x10;\r\nx = le16_to_cpup((__le16 *)&data[4]);\r\ny = le16_to_cpup((__le16 *)&data[6]);\r\npressure = le16_to_cpup((__le16 *)&data[8]);\r\ninput_report_key(input, BTN_TOUCH, tsw || ers);\r\ninput_report_key(input, BTN_TOOL_PEN, tsw);\r\ninput_report_key(input, BTN_TOOL_RUBBER, ers);\r\ninput_report_key(input, BTN_STYLUS, f1);\r\ninput_report_key(input, BTN_STYLUS2, f2);\r\ninput_report_abs(input, ABS_X, x);\r\ninput_report_abs(input, ABS_Y, y);\r\ninput_report_abs(input, ABS_PRESSURE, pressure);\r\ninput_sync(input);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wacom_i2c_open(struct input_dev *dev)\r\n{\r\nstruct wacom_i2c *wac_i2c = input_get_drvdata(dev);\r\nstruct i2c_client *client = wac_i2c->client;\r\nenable_irq(client->irq);\r\nreturn 0;\r\n}\r\nstatic void wacom_i2c_close(struct input_dev *dev)\r\n{\r\nstruct wacom_i2c *wac_i2c = input_get_drvdata(dev);\r\nstruct i2c_client *client = wac_i2c->client;\r\ndisable_irq(client->irq);\r\n}\r\nstatic int __devinit wacom_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wacom_i2c *wac_i2c;\r\nstruct input_dev *input;\r\nstruct wacom_features features = { 0 };\r\nint error;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "i2c_check_functionality error\n");\r\nreturn -EIO;\r\n}\r\nerror = wacom_query_device(client, &features);\r\nif (error)\r\nreturn error;\r\nwac_i2c = kzalloc(sizeof(*wac_i2c), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!wac_i2c || !input) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nwac_i2c->client = client;\r\nwac_i2c->input = input;\r\ninput->name = "Wacom I2C Digitizer";\r\ninput->id.bustype = BUS_I2C;\r\ninput->id.vendor = 0x56a;\r\ninput->id.version = features.fw_version;\r\ninput->dev.parent = &client->dev;\r\ninput->open = wacom_i2c_open;\r\ninput->close = wacom_i2c_close;\r\ninput->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\n__set_bit(BTN_TOOL_PEN, input->keybit);\r\n__set_bit(BTN_TOOL_RUBBER, input->keybit);\r\n__set_bit(BTN_STYLUS, input->keybit);\r\n__set_bit(BTN_STYLUS2, input->keybit);\r\n__set_bit(BTN_TOUCH, input->keybit);\r\ninput_set_abs_params(input, ABS_X, 0, features.x_max, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, features.y_max, 0, 0);\r\ninput_set_abs_params(input, ABS_PRESSURE,\r\n0, features.pressure_max, 0, 0);\r\ninput_set_drvdata(input, wac_i2c);\r\nerror = request_threaded_irq(client->irq, NULL, wacom_i2c_irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"wacom_i2c", wac_i2c);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to enable IRQ, error: %d\n", error);\r\ngoto err_free_mem;\r\n}\r\ndisable_irq(client->irq);\r\nerror = input_register_device(wac_i2c->input);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to register input device, error: %d\n", error);\r\ngoto err_free_irq;\r\n}\r\ni2c_set_clientdata(client, wac_i2c);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(client->irq, wac_i2c);\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(wac_i2c);\r\nreturn error;\r\n}\r\nstatic int __devexit wacom_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct wacom_i2c *wac_i2c = i2c_get_clientdata(client);\r\nfree_irq(client->irq, wac_i2c);\r\ninput_unregister_device(wac_i2c->input);\r\nkfree(wac_i2c);\r\nreturn 0;\r\n}\r\nstatic int wacom_i2c_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\ndisable_irq(client->irq);\r\nreturn 0;\r\n}\r\nstatic int wacom_i2c_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nenable_irq(client->irq);\r\nreturn 0;\r\n}
