static int __stmpe_enable(struct stmpe *stmpe, unsigned int blocks)\r\n{\r\nreturn stmpe->variant->enable(stmpe, blocks, true);\r\n}\r\nstatic int __stmpe_disable(struct stmpe *stmpe, unsigned int blocks)\r\n{\r\nreturn stmpe->variant->enable(stmpe, blocks, false);\r\n}\r\nstatic int __stmpe_reg_read(struct stmpe *stmpe, u8 reg)\r\n{\r\nint ret;\r\nret = stmpe->ci->read_byte(stmpe, reg);\r\nif (ret < 0)\r\ndev_err(stmpe->dev, "failed to read reg %#x: %d\n", reg, ret);\r\ndev_vdbg(stmpe->dev, "rd: reg %#x => data %#x\n", reg, ret);\r\nreturn ret;\r\n}\r\nstatic int __stmpe_reg_write(struct stmpe *stmpe, u8 reg, u8 val)\r\n{\r\nint ret;\r\ndev_vdbg(stmpe->dev, "wr: reg %#x <= %#x\n", reg, val);\r\nret = stmpe->ci->write_byte(stmpe, reg, val);\r\nif (ret < 0)\r\ndev_err(stmpe->dev, "failed to write reg %#x: %d\n", reg, ret);\r\nreturn ret;\r\n}\r\nstatic int __stmpe_set_bits(struct stmpe *stmpe, u8 reg, u8 mask, u8 val)\r\n{\r\nint ret;\r\nret = __stmpe_reg_read(stmpe, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= ~mask;\r\nret |= val;\r\nreturn __stmpe_reg_write(stmpe, reg, ret);\r\n}\r\nstatic int __stmpe_block_read(struct stmpe *stmpe, u8 reg, u8 length,\r\nu8 *values)\r\n{\r\nint ret;\r\nret = stmpe->ci->read_block(stmpe, reg, length, values);\r\nif (ret < 0)\r\ndev_err(stmpe->dev, "failed to read regs %#x: %d\n", reg, ret);\r\ndev_vdbg(stmpe->dev, "rd: reg %#x (%d) => ret %#x\n", reg, length, ret);\r\nstmpe_dump_bytes("stmpe rd: ", values, length);\r\nreturn ret;\r\n}\r\nstatic int __stmpe_block_write(struct stmpe *stmpe, u8 reg, u8 length,\r\nconst u8 *values)\r\n{\r\nint ret;\r\ndev_vdbg(stmpe->dev, "wr: regs %#x (%d)\n", reg, length);\r\nstmpe_dump_bytes("stmpe wr: ", values, length);\r\nret = stmpe->ci->write_block(stmpe, reg, length, values);\r\nif (ret < 0)\r\ndev_err(stmpe->dev, "failed to write regs %#x: %d\n", reg, ret);\r\nreturn ret;\r\n}\r\nint stmpe_enable(struct stmpe *stmpe, unsigned int blocks)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_enable(stmpe, blocks);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_disable(struct stmpe *stmpe, unsigned int blocks)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_disable(stmpe, blocks);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_reg_read(struct stmpe *stmpe, u8 reg)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_reg_read(stmpe, reg);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_reg_write(struct stmpe *stmpe, u8 reg, u8 val)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_reg_write(stmpe, reg, val);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_set_bits(struct stmpe *stmpe, u8 reg, u8 mask, u8 val)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_set_bits(stmpe, reg, mask, val);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_block_read(struct stmpe *stmpe, u8 reg, u8 length, u8 *values)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_block_read(stmpe, reg, length, values);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_block_write(struct stmpe *stmpe, u8 reg, u8 length,\r\nconst u8 *values)\r\n{\r\nint ret;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_block_write(stmpe, reg, length, values);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nint stmpe_set_altfunc(struct stmpe *stmpe, u32 pins, enum stmpe_block block)\r\n{\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nu8 regaddr = stmpe->regs[STMPE_IDX_GPAFR_U_MSB];\r\nint af_bits = variant->af_bits;\r\nint numregs = DIV_ROUND_UP(stmpe->num_gpios * af_bits, 8);\r\nint mask = (1 << af_bits) - 1;\r\nu8 regs[numregs];\r\nint af, afperreg, ret;\r\nif (!variant->get_altfunc)\r\nreturn 0;\r\nafperreg = 8 / af_bits;\r\nmutex_lock(&stmpe->lock);\r\nret = __stmpe_enable(stmpe, STMPE_BLOCK_GPIO);\r\nif (ret < 0)\r\ngoto out;\r\nret = __stmpe_block_read(stmpe, regaddr, numregs, regs);\r\nif (ret < 0)\r\ngoto out;\r\naf = variant->get_altfunc(stmpe, block);\r\nwhile (pins) {\r\nint pin = __ffs(pins);\r\nint regoffset = numregs - (pin / afperreg) - 1;\r\nint pos = (pin % afperreg) * (8 / afperreg);\r\nregs[regoffset] &= ~(mask << pos);\r\nregs[regoffset] |= af << pos;\r\npins &= ~(1 << pin);\r\n}\r\nret = __stmpe_block_write(stmpe, regaddr, numregs, regs);\r\nout:\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nstatic int stmpe801_enable(struct stmpe *stmpe, unsigned int blocks,\r\nbool enable)\r\n{\r\nif (blocks & STMPE_BLOCK_GPIO)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int stmpe811_enable(struct stmpe *stmpe, unsigned int blocks,\r\nbool enable)\r\n{\r\nunsigned int mask = 0;\r\nif (blocks & STMPE_BLOCK_GPIO)\r\nmask |= STMPE811_SYS_CTRL2_GPIO_OFF;\r\nif (blocks & STMPE_BLOCK_ADC)\r\nmask |= STMPE811_SYS_CTRL2_ADC_OFF;\r\nif (blocks & STMPE_BLOCK_TOUCHSCREEN)\r\nmask |= STMPE811_SYS_CTRL2_TSC_OFF;\r\nreturn __stmpe_set_bits(stmpe, STMPE811_REG_SYS_CTRL2, mask,\r\nenable ? 0 : mask);\r\n}\r\nstatic int stmpe811_get_altfunc(struct stmpe *stmpe, enum stmpe_block block)\r\n{\r\nreturn block != STMPE_BLOCK_TOUCHSCREEN;\r\n}\r\nstatic int stmpe_round_timeout(int timeout)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(stmpe_autosleep_delay); i++) {\r\nif (stmpe_autosleep_delay[i] >= timeout)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int stmpe_autosleep(struct stmpe *stmpe, int autosleep_timeout)\r\n{\r\nint ret;\r\nif (!stmpe->variant->enable_autosleep)\r\nreturn -ENOSYS;\r\nmutex_lock(&stmpe->lock);\r\nret = stmpe->variant->enable_autosleep(stmpe, autosleep_timeout);\r\nmutex_unlock(&stmpe->lock);\r\nreturn ret;\r\n}\r\nstatic int stmpe1601_autosleep(struct stmpe *stmpe,\r\nint autosleep_timeout)\r\n{\r\nint ret, timeout;\r\ntimeout = stmpe_round_timeout(autosleep_timeout);\r\nif (timeout < 0) {\r\ndev_err(stmpe->dev, "invalid timeout\n");\r\nreturn timeout;\r\n}\r\nret = __stmpe_set_bits(stmpe, STMPE1601_REG_SYS_CTRL2,\r\nSTMPE1601_AUTOSLEEP_TIMEOUT_MASK,\r\ntimeout);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn __stmpe_set_bits(stmpe, STMPE1601_REG_SYS_CTRL2,\r\nSTPME1601_AUTOSLEEP_ENABLE,\r\nSTPME1601_AUTOSLEEP_ENABLE);\r\n}\r\nstatic int stmpe1601_enable(struct stmpe *stmpe, unsigned int blocks,\r\nbool enable)\r\n{\r\nunsigned int mask = 0;\r\nif (blocks & STMPE_BLOCK_GPIO)\r\nmask |= STMPE1601_SYS_CTRL_ENABLE_GPIO;\r\nif (blocks & STMPE_BLOCK_KEYPAD)\r\nmask |= STMPE1601_SYS_CTRL_ENABLE_KPC;\r\nreturn __stmpe_set_bits(stmpe, STMPE1601_REG_SYS_CTRL, mask,\r\nenable ? mask : 0);\r\n}\r\nstatic int stmpe1601_get_altfunc(struct stmpe *stmpe, enum stmpe_block block)\r\n{\r\nswitch (block) {\r\ncase STMPE_BLOCK_PWM:\r\nreturn 2;\r\ncase STMPE_BLOCK_KEYPAD:\r\nreturn 1;\r\ncase STMPE_BLOCK_GPIO:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int stmpe24xx_enable(struct stmpe *stmpe, unsigned int blocks,\r\nbool enable)\r\n{\r\nunsigned int mask = 0;\r\nif (blocks & STMPE_BLOCK_GPIO)\r\nmask |= STMPE24XX_SYS_CTRL_ENABLE_GPIO;\r\nif (blocks & STMPE_BLOCK_KEYPAD)\r\nmask |= STMPE24XX_SYS_CTRL_ENABLE_KPC;\r\nreturn __stmpe_set_bits(stmpe, STMPE24XX_REG_SYS_CTRL, mask,\r\nenable ? mask : 0);\r\n}\r\nstatic int stmpe24xx_get_altfunc(struct stmpe *stmpe, enum stmpe_block block)\r\n{\r\nswitch (block) {\r\ncase STMPE_BLOCK_ROTATOR:\r\nreturn 2;\r\ncase STMPE_BLOCK_KEYPAD:\r\nreturn 1;\r\ncase STMPE_BLOCK_GPIO:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic irqreturn_t stmpe_irq(int irq, void *data)\r\n{\r\nstruct stmpe *stmpe = data;\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nint num = DIV_ROUND_UP(variant->num_irqs, 8);\r\nu8 israddr = stmpe->regs[STMPE_IDX_ISR_MSB];\r\nu8 isr[num];\r\nint ret;\r\nint i;\r\nif (variant->id_val == STMPE801_ID) {\r\nhandle_nested_irq(stmpe->irq_base);\r\nreturn IRQ_HANDLED;\r\n}\r\nret = stmpe_block_read(stmpe, israddr, num, isr);\r\nif (ret < 0)\r\nreturn IRQ_NONE;\r\nfor (i = 0; i < num; i++) {\r\nint bank = num - i - 1;\r\nu8 status = isr[i];\r\nu8 clear;\r\nstatus &= stmpe->ier[bank];\r\nif (!status)\r\ncontinue;\r\nclear = status;\r\nwhile (status) {\r\nint bit = __ffs(status);\r\nint line = bank * 8 + bit;\r\nhandle_nested_irq(stmpe->irq_base + line);\r\nstatus &= ~(1 << bit);\r\n}\r\nstmpe_reg_write(stmpe, israddr + i, clear);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void stmpe_irq_lock(struct irq_data *data)\r\n{\r\nstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&stmpe->irq_lock);\r\n}\r\nstatic void stmpe_irq_sync_unlock(struct irq_data *data)\r\n{\r\nstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nint num = DIV_ROUND_UP(variant->num_irqs, 8);\r\nint i;\r\nfor (i = 0; i < num; i++) {\r\nu8 new = stmpe->ier[i];\r\nu8 old = stmpe->oldier[i];\r\nif (new == old)\r\ncontinue;\r\nstmpe->oldier[i] = new;\r\nstmpe_reg_write(stmpe, stmpe->regs[STMPE_IDX_IER_LSB] - i, new);\r\n}\r\nmutex_unlock(&stmpe->irq_lock);\r\n}\r\nstatic void stmpe_irq_mask(struct irq_data *data)\r\n{\r\nstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\r\nint offset = data->irq - stmpe->irq_base;\r\nint regoffset = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nstmpe->ier[regoffset] &= ~mask;\r\n}\r\nstatic void stmpe_irq_unmask(struct irq_data *data)\r\n{\r\nstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\r\nint offset = data->irq - stmpe->irq_base;\r\nint regoffset = offset / 8;\r\nint mask = 1 << (offset % 8);\r\nstmpe->ier[regoffset] |= mask;\r\n}\r\nstatic int __devinit stmpe_irq_init(struct stmpe *stmpe)\r\n{\r\nstruct irq_chip *chip = NULL;\r\nint num_irqs = stmpe->variant->num_irqs;\r\nint base = stmpe->irq_base;\r\nint irq;\r\nif (stmpe->variant->id_val != STMPE801_ID)\r\nchip = &stmpe_irq_chip;\r\nfor (irq = base; irq < base + num_irqs; irq++) {\r\nirq_set_chip_data(irq, stmpe);\r\nirq_set_chip_and_handler(irq, chip, handle_edge_irq);\r\nirq_set_nested_thread(irq, 1);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(irq);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic void stmpe_irq_remove(struct stmpe *stmpe)\r\n{\r\nint num_irqs = stmpe->variant->num_irqs;\r\nint base = stmpe->irq_base;\r\nint irq;\r\nfor (irq = base; irq < base + num_irqs; irq++) {\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, 0);\r\n#endif\r\nirq_set_chip_and_handler(irq, NULL, NULL);\r\nirq_set_chip_data(irq, NULL);\r\n}\r\n}\r\nstatic int __devinit stmpe_chip_init(struct stmpe *stmpe)\r\n{\r\nunsigned int irq_trigger = stmpe->pdata->irq_trigger;\r\nint autosleep_timeout = stmpe->pdata->autosleep_timeout;\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nu8 icr = 0;\r\nunsigned int id;\r\nu8 data[2];\r\nint ret;\r\nret = stmpe_block_read(stmpe, stmpe->regs[STMPE_IDX_CHIP_ID],\r\nARRAY_SIZE(data), data);\r\nif (ret < 0)\r\nreturn ret;\r\nid = (data[0] << 8) | data[1];\r\nif ((id & variant->id_mask) != variant->id_val) {\r\ndev_err(stmpe->dev, "unknown chip id: %#x\n", id);\r\nreturn -EINVAL;\r\n}\r\ndev_info(stmpe->dev, "%s detected, chip id: %#x\n", variant->name, id);\r\nret = stmpe_disable(stmpe, ~0);\r\nif (ret)\r\nreturn ret;\r\nif (stmpe->irq >= 0) {\r\nif (id == STMPE801_ID)\r\nicr = STMPE801_REG_SYS_CTRL_INT_EN;\r\nelse\r\nicr = STMPE_ICR_LSB_GIM;\r\nif (id != STMPE801_ID) {\r\nif (irq_trigger == IRQF_TRIGGER_FALLING ||\r\nirq_trigger == IRQF_TRIGGER_RISING)\r\nicr |= STMPE_ICR_LSB_EDGE;\r\n}\r\nif (irq_trigger == IRQF_TRIGGER_RISING ||\r\nirq_trigger == IRQF_TRIGGER_HIGH) {\r\nif (id == STMPE801_ID)\r\nicr |= STMPE801_REG_SYS_CTRL_INT_HI;\r\nelse\r\nicr |= STMPE_ICR_LSB_HIGH;\r\n}\r\nif (stmpe->pdata->irq_invert_polarity) {\r\nif (id == STMPE801_ID)\r\nicr ^= STMPE801_REG_SYS_CTRL_INT_HI;\r\nelse\r\nicr ^= STMPE_ICR_LSB_HIGH;\r\n}\r\n}\r\nif (stmpe->pdata->autosleep) {\r\nret = stmpe_autosleep(stmpe, autosleep_timeout);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn stmpe_reg_write(stmpe, stmpe->regs[STMPE_IDX_ICR_LSB], icr);\r\n}\r\nstatic int __devinit stmpe_add_device(struct stmpe *stmpe,\r\nstruct mfd_cell *cell, int irq)\r\n{\r\nreturn mfd_add_devices(stmpe->dev, stmpe->pdata->id, cell, 1,\r\nNULL, stmpe->irq_base + irq, NULL);\r\n}\r\nstatic int __devinit stmpe_devices_init(struct stmpe *stmpe)\r\n{\r\nstruct stmpe_variant_info *variant = stmpe->variant;\r\nunsigned int platform_blocks = stmpe->pdata->blocks;\r\nint ret = -EINVAL;\r\nint i;\r\nfor (i = 0; i < variant->num_blocks; i++) {\r\nstruct stmpe_variant_block *block = &variant->blocks[i];\r\nif (!(platform_blocks & block->block))\r\ncontinue;\r\nplatform_blocks &= ~block->block;\r\nret = stmpe_add_device(stmpe, block->cell, block->irq);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (platform_blocks)\r\ndev_warn(stmpe->dev,\r\n"platform wants blocks (%#x) not present on variant",\r\nplatform_blocks);\r\nreturn ret;\r\n}\r\nint __devinit stmpe_probe(struct stmpe_client_info *ci, int partnum)\r\n{\r\nstruct stmpe_platform_data *pdata = dev_get_platdata(ci->dev);\r\nstruct stmpe *stmpe;\r\nint ret;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nstmpe = kzalloc(sizeof(struct stmpe), GFP_KERNEL);\r\nif (!stmpe)\r\nreturn -ENOMEM;\r\nmutex_init(&stmpe->irq_lock);\r\nmutex_init(&stmpe->lock);\r\nstmpe->dev = ci->dev;\r\nstmpe->client = ci->client;\r\nstmpe->pdata = pdata;\r\nstmpe->irq_base = pdata->irq_base;\r\nstmpe->ci = ci;\r\nstmpe->partnum = partnum;\r\nstmpe->variant = stmpe_variant_info[partnum];\r\nstmpe->regs = stmpe->variant->regs;\r\nstmpe->num_gpios = stmpe->variant->num_gpios;\r\ndev_set_drvdata(stmpe->dev, stmpe);\r\nif (ci->init)\r\nci->init(stmpe);\r\nif (pdata->irq_over_gpio) {\r\nret = gpio_request_one(pdata->irq_gpio, GPIOF_DIR_IN, "stmpe");\r\nif (ret) {\r\ndev_err(stmpe->dev, "failed to request IRQ GPIO: %d\n",\r\nret);\r\ngoto out_free;\r\n}\r\nstmpe->irq = gpio_to_irq(pdata->irq_gpio);\r\n} else {\r\nstmpe->irq = ci->irq;\r\n}\r\nif (stmpe->irq < 0) {\r\ndev_info(stmpe->dev,\r\n"%s configured in no-irq mode by platform data\n",\r\nstmpe->variant->name);\r\nif (!stmpe_noirq_variant_info[stmpe->partnum]) {\r\ndev_err(stmpe->dev,\r\n"%s does not support no-irq mode!\n",\r\nstmpe->variant->name);\r\nret = -ENODEV;\r\ngoto free_gpio;\r\n}\r\nstmpe->variant = stmpe_noirq_variant_info[stmpe->partnum];\r\n}\r\nret = stmpe_chip_init(stmpe);\r\nif (ret)\r\ngoto free_gpio;\r\nif (stmpe->irq >= 0) {\r\nret = stmpe_irq_init(stmpe);\r\nif (ret)\r\ngoto free_gpio;\r\nret = request_threaded_irq(stmpe->irq, NULL, stmpe_irq,\r\npdata->irq_trigger | IRQF_ONESHOT,\r\n"stmpe", stmpe);\r\nif (ret) {\r\ndev_err(stmpe->dev, "failed to request IRQ: %d\n",\r\nret);\r\ngoto out_removeirq;\r\n}\r\n}\r\nret = stmpe_devices_init(stmpe);\r\nif (ret) {\r\ndev_err(stmpe->dev, "failed to add children\n");\r\ngoto out_removedevs;\r\n}\r\nreturn 0;\r\nout_removedevs:\r\nmfd_remove_devices(stmpe->dev);\r\nif (stmpe->irq >= 0)\r\nfree_irq(stmpe->irq, stmpe);\r\nout_removeirq:\r\nif (stmpe->irq >= 0)\r\nstmpe_irq_remove(stmpe);\r\nfree_gpio:\r\nif (pdata->irq_over_gpio)\r\ngpio_free(pdata->irq_gpio);\r\nout_free:\r\nkfree(stmpe);\r\nreturn ret;\r\n}\r\nint stmpe_remove(struct stmpe *stmpe)\r\n{\r\nmfd_remove_devices(stmpe->dev);\r\nif (stmpe->irq >= 0) {\r\nfree_irq(stmpe->irq, stmpe);\r\nstmpe_irq_remove(stmpe);\r\n}\r\nif (stmpe->pdata->irq_over_gpio)\r\ngpio_free(stmpe->pdata->irq_gpio);\r\nkfree(stmpe);\r\nreturn 0;\r\n}\r\nstatic int stmpe_suspend(struct device *dev)\r\n{\r\nstruct stmpe *stmpe = dev_get_drvdata(dev);\r\nif (stmpe->irq >= 0 && device_may_wakeup(dev))\r\nenable_irq_wake(stmpe->irq);\r\nreturn 0;\r\n}\r\nstatic int stmpe_resume(struct device *dev)\r\n{\r\nstruct stmpe *stmpe = dev_get_drvdata(dev);\r\nif (stmpe->irq >= 0 && device_may_wakeup(dev))\r\ndisable_irq_wake(stmpe->irq);\r\nreturn 0;\r\n}
