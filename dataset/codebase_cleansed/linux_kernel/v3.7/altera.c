static int altera_check_stack(int stack_ptr, int count, int *status)\r\n{\r\nif (stack_ptr < count) {\r\n*status = -EOVERFLOW;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void altera_export_int(char *key, s32 value)\r\n{\r\ndprintk("Export: key = \"%s\", value = %d\n", key, value);\r\n}\r\nstatic void altera_export_bool_array(char *key, u8 *data, s32 count)\r\n{\r\nchar string[HEX_LINE_CHARS + 1];\r\ns32 i, offset;\r\nu32 size, line, lines, linebits, value, j, k;\r\nif (count > HEX_LINE_BITS) {\r\ndprintk("Export: key = \"%s\", %d bits, value = HEX\n",\r\nkey, count);\r\nlines = (count + (HEX_LINE_BITS - 1)) / HEX_LINE_BITS;\r\nfor (line = 0; line < lines; ++line) {\r\nif (line < (lines - 1)) {\r\nlinebits = HEX_LINE_BITS;\r\nsize = HEX_LINE_CHARS;\r\noffset = count - ((line + 1) * HEX_LINE_BITS);\r\n} else {\r\nlinebits =\r\ncount - ((lines - 1) * HEX_LINE_BITS);\r\nsize = (linebits + 3) / 4;\r\noffset = 0L;\r\n}\r\nstring[size] = '\0';\r\nj = size - 1;\r\nvalue = 0;\r\nfor (k = 0; k < linebits; ++k) {\r\ni = k + offset;\r\nif (data[i >> 3] & (1 << (i & 7)))\r\nvalue |= (1 << (i & 3));\r\nif ((i & 3) == 3) {\r\nsprintf(&string[j], "%1x", value);\r\nvalue = 0;\r\n--j;\r\n}\r\n}\r\nif ((k & 3) > 0)\r\nsprintf(&string[j], "%1x", value);\r\ndprintk("%s\n", string);\r\n}\r\n} else {\r\nsize = (count + 3) / 4;\r\nstring[size] = '\0';\r\nj = size - 1;\r\nvalue = 0;\r\nfor (i = 0; i < count; ++i) {\r\nif (data[i >> 3] & (1 << (i & 7)))\r\nvalue |= (1 << (i & 3));\r\nif ((i & 3) == 3) {\r\nsprintf(&string[j], "%1x", value);\r\nvalue = 0;\r\n--j;\r\n}\r\n}\r\nif ((i & 3) > 0)\r\nsprintf(&string[j], "%1x", value);\r\ndprintk("Export: key = \"%s\", %d bits, value = HEX %s\n",\r\nkey, count, string);\r\n}\r\n}\r\nstatic int altera_execute(struct altera_state *astate,\r\nu8 *p,\r\ns32 program_size,\r\ns32 *error_address,\r\nint *exit_code,\r\nint *format_version)\r\n{\r\nstruct altera_config *aconf = astate->config;\r\nchar *msg_buff = astate->msg_buff;\r\nlong *stack = astate->stack;\r\nint status = 0;\r\nu32 first_word = 0L;\r\nu32 action_table = 0L;\r\nu32 proc_table = 0L;\r\nu32 str_table = 0L;\r\nu32 sym_table = 0L;\r\nu32 data_sect = 0L;\r\nu32 code_sect = 0L;\r\nu32 debug_sect = 0L;\r\nu32 action_count = 0L;\r\nu32 proc_count = 0L;\r\nu32 sym_count = 0L;\r\nlong *vars = NULL;\r\ns32 *var_size = NULL;\r\nchar *attrs = NULL;\r\nu8 *proc_attributes = NULL;\r\nu32 pc;\r\nu32 opcode_address;\r\nu32 args[3];\r\nu32 opcode;\r\nu32 name_id;\r\nu8 charbuf[4];\r\nlong long_tmp;\r\nu32 variable_id;\r\nu8 *charptr_tmp;\r\nu8 *charptr_tmp2;\r\nlong *longptr_tmp;\r\nint version = 0;\r\nint delta = 0;\r\nint stack_ptr = 0;\r\nu32 arg_count;\r\nint done = 0;\r\nint bad_opcode = 0;\r\nu32 count;\r\nu32 index;\r\nu32 index2;\r\ns32 long_count;\r\ns32 long_idx;\r\ns32 long_idx2;\r\nu32 i;\r\nu32 j;\r\nu32 uncomp_size;\r\nu32 offset;\r\nu32 value;\r\nint current_proc = 0;\r\nint reverse;\r\nchar *name;\r\ndprintk("%s\n", __func__);\r\nif (program_size > 52L) {\r\nfirst_word = get_unaligned_be32(&p[0]);\r\nversion = (first_word & 1L);\r\n*format_version = version + 1;\r\ndelta = version * 8;\r\naction_table = get_unaligned_be32(&p[4]);\r\nproc_table = get_unaligned_be32(&p[8]);\r\nstr_table = get_unaligned_be32(&p[4 + delta]);\r\nsym_table = get_unaligned_be32(&p[16 + delta]);\r\ndata_sect = get_unaligned_be32(&p[20 + delta]);\r\ncode_sect = get_unaligned_be32(&p[24 + delta]);\r\ndebug_sect = get_unaligned_be32(&p[28 + delta]);\r\naction_count = get_unaligned_be32(&p[40 + delta]);\r\nproc_count = get_unaligned_be32(&p[44 + delta]);\r\nsym_count = get_unaligned_be32(&p[48 + (2 * delta)]);\r\n}\r\nif ((first_word != 0x4A414D00L) && (first_word != 0x4A414D01L)) {\r\ndone = 1;\r\nstatus = -EIO;\r\ngoto exit_done;\r\n}\r\nif (sym_count <= 0)\r\ngoto exit_done;\r\nvars = kzalloc(sym_count * sizeof(long), GFP_KERNEL);\r\nif (vars == NULL)\r\nstatus = -ENOMEM;\r\nif (status == 0) {\r\nvar_size = kzalloc(sym_count * sizeof(s32), GFP_KERNEL);\r\nif (var_size == NULL)\r\nstatus = -ENOMEM;\r\n}\r\nif (status == 0) {\r\nattrs = kzalloc(sym_count, GFP_KERNEL);\r\nif (attrs == NULL)\r\nstatus = -ENOMEM;\r\n}\r\nif ((status == 0) && (version > 0)) {\r\nproc_attributes = kzalloc(proc_count, GFP_KERNEL);\r\nif (proc_attributes == NULL)\r\nstatus = -ENOMEM;\r\n}\r\nif (status != 0)\r\ngoto exit_done;\r\ndelta = version * 2;\r\nfor (i = 0; i < sym_count; ++i) {\r\noffset = (sym_table + ((11 + delta) * i));\r\nvalue = get_unaligned_be32(&p[offset + 3 + delta]);\r\nattrs[i] = p[offset];\r\nattrs[i] &= 0x7f;\r\nvar_size[i] = get_unaligned_be32(&p[offset + 7 + delta]);\r\nif ((attrs[i] & 0x0c) == 0x04)\r\nvars[i] = value;\r\nelse if ((attrs[i] & 0x1e) == 0x0e) {\r\nuncomp_size = get_unaligned_le32(&p[data_sect + value]);\r\nvars[i] = (long)kzalloc(uncomp_size, GFP_KERNEL);\r\nif (vars[i] == 0L)\r\nstatus = -ENOMEM;\r\nelse {\r\nattrs[i] |= 0x80;\r\nif (altera_shrink(&p[data_sect + value],\r\nvar_size[i],\r\n(u8 *)vars[i],\r\nuncomp_size,\r\nversion) != uncomp_size)\r\nstatus = -EIO;\r\nelse\r\nvar_size[i] = uncomp_size * 8L;\r\n}\r\n} else if ((attrs[i] & 0x1e) == 0x0c) {\r\nvars[i] = value + data_sect + (long)p;\r\n} else if ((attrs[i] & 0x1c) == 0x1c) {\r\nvars[i] = value + data_sect;\r\n} else if ((attrs[i] & 0x0c) == 0x08) {\r\nattrs[i] |= 0x80;\r\nif (var_size[i] > 0) {\r\nu32 size;\r\nif (attrs[i] & 0x10)\r\nsize = (var_size[i] * sizeof(s32));\r\nelse\r\nsize = ((var_size[i] + 7L) / 8L);\r\nvars[i] = (long)kzalloc(size, GFP_KERNEL);\r\nif (vars[i] == 0) {\r\nstatus = -ENOMEM;\r\n} else {\r\nfor (j = 0; j < size; ++j)\r\n((u8 *)(vars[i]))[j] = 0;\r\n}\r\n} else\r\nvars[i] = 0;\r\n} else\r\nvars[i] = 0;\r\n}\r\nexit_done:\r\nif (status != 0)\r\ndone = 1;\r\naltera_jinit(astate);\r\npc = code_sect;\r\nmsg_buff[0] = '\0';\r\nif (version > 0) {\r\nif (aconf->action == NULL) {\r\nstatus = -EINVAL;\r\ndone = 1;\r\n} else {\r\nint action_found = 0;\r\nfor (i = 0; (i < action_count) && !action_found; ++i) {\r\nname_id = get_unaligned_be32(&p[action_table +\r\n(12 * i)]);\r\nname = &p[str_table + name_id];\r\nif (strnicmp(aconf->action, name, strlen(name)) == 0) {\r\naction_found = 1;\r\ncurrent_proc =\r\nget_unaligned_be32(&p[action_table +\r\n(12 * i) + 8]);\r\n}\r\n}\r\nif (!action_found) {\r\nstatus = -EINVAL;\r\ndone = 1;\r\n}\r\n}\r\nif (status == 0) {\r\nint first_time = 1;\r\ni = current_proc;\r\nwhile ((i != 0) || first_time) {\r\nfirst_time = 0;\r\nproc_attributes[i] =\r\n(p[proc_table +\r\n(13 * i) + 8] &\r\n0x03);\r\ni = get_unaligned_be32(&p[proc_table +\r\n(13 * i) + 4]);\r\n}\r\ni = current_proc;\r\nwhile ((i != 0) &&\r\n((proc_attributes[i] == 1) ||\r\n((proc_attributes[i] & 0xc0) == 0x40))) {\r\ni = get_unaligned_be32(&p[proc_table +\r\n(13 * i) + 4]);\r\n}\r\nif ((i != 0) || ((i == 0) && (current_proc == 0) &&\r\n((proc_attributes[0] != 1) &&\r\n((proc_attributes[0] & 0xc0) != 0x40)))) {\r\ncurrent_proc = i;\r\npc = code_sect +\r\nget_unaligned_be32(&p[proc_table +\r\n(13 * i) + 9]);\r\nif ((pc < code_sect) || (pc >= debug_sect))\r\nstatus = -ERANGE;\r\n} else\r\ndone = 1;\r\n}\r\n}\r\nmsg_buff[0] = '\0';\r\nwhile (!done) {\r\nopcode = (p[pc] & 0xff);\r\nopcode_address = pc;\r\n++pc;\r\nif (debug > 1)\r\nprintk("opcode: %02x\n", opcode);\r\narg_count = (opcode >> 6) & 3;\r\nfor (i = 0; i < arg_count; ++i) {\r\nargs[i] = get_unaligned_be32(&p[pc]);\r\npc += 4;\r\n}\r\nswitch (opcode) {\r\ncase OP_NOP:\r\nbreak;\r\ncase OP_DUP:\r\nif (altera_check_stack(stack_ptr, 1, &status)) {\r\nstack[stack_ptr] = stack[stack_ptr - 1];\r\n++stack_ptr;\r\n}\r\nbreak;\r\ncase OP_SWP:\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\nlong_tmp = stack[stack_ptr - 2];\r\nstack[stack_ptr - 2] = stack[stack_ptr - 1];\r\nstack[stack_ptr - 1] = long_tmp;\r\n}\r\nbreak;\r\ncase OP_ADD:\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\n--stack_ptr;\r\nstack[stack_ptr - 1] += stack[stack_ptr];\r\n}\r\nbreak;\r\ncase OP_SUB:\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\n--stack_ptr;\r\nstack[stack_ptr - 1] -= stack[stack_ptr];\r\n}\r\nbreak;\r\ncase OP_MULT:\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\n--stack_ptr;\r\nstack[stack_ptr - 1] *= stack[stack_ptr];\r\n}\r\nbreak;\r\ncase OP_DIV:\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\n--stack_ptr;\r\nstack[stack_ptr - 1] /= stack[stack_ptr];\r\n}\r\nbreak;\r\ncase OP_MOD:\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\n--stack_ptr;\r\nstack[stack_ptr - 1] %= stack[stack_ptr];\r\n}\r\nbreak;\r\ncase OP_SHL:\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\n--stack_ptr;\r\nstack[stack_ptr - 1] <<= stack[stack_ptr];\r\n}\r\nbreak;\r\ncase OP_SHR:\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\n--stack_ptr;\r\nstack[stack_ptr - 1] >>= stack[stack_ptr];\r\n}\r\nbreak;\r\ncase OP_NOT:\r\nif (altera_check_stack(stack_ptr, 1, &status))\r\nstack[stack_ptr - 1] ^= (-1L);\r\nbreak;\r\ncase OP_AND:\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\n--stack_ptr;\r\nstack[stack_ptr - 1] &= stack[stack_ptr];\r\n}\r\nbreak;\r\ncase OP_OR:\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\n--stack_ptr;\r\nstack[stack_ptr - 1] |= stack[stack_ptr];\r\n}\r\nbreak;\r\ncase OP_XOR:\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\n--stack_ptr;\r\nstack[stack_ptr - 1] ^= stack[stack_ptr];\r\n}\r\nbreak;\r\ncase OP_INV:\r\nif (!altera_check_stack(stack_ptr, 1, &status))\r\nbreak;\r\nstack[stack_ptr - 1] = stack[stack_ptr - 1] ? 0L : 1L;\r\nbreak;\r\ncase OP_GT:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\n--stack_ptr;\r\nstack[stack_ptr - 1] =\r\n(stack[stack_ptr - 1] > stack[stack_ptr]) ?\r\n1L : 0L;\r\nbreak;\r\ncase OP_LT:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\n--stack_ptr;\r\nstack[stack_ptr - 1] =\r\n(stack[stack_ptr - 1] < stack[stack_ptr]) ?\r\n1L : 0L;\r\nbreak;\r\ncase OP_RET:\r\nif ((version > 0) && (stack_ptr == 0)) {\r\ni = get_unaligned_be32(&p[proc_table +\r\n(13 * current_proc) + 4]);\r\nwhile ((i != 0) &&\r\n((proc_attributes[i] == 1) ||\r\n((proc_attributes[i] & 0xc0) == 0x40)))\r\ni = get_unaligned_be32(&p[proc_table +\r\n(13 * i) + 4]);\r\nif (i == 0) {\r\ndone = 1;\r\n*exit_code = 0;\r\n} else {\r\ncurrent_proc = i;\r\npc = code_sect + get_unaligned_be32(\r\n&p[proc_table +\r\n(13 * i) + 9]);\r\nif ((pc < code_sect) ||\r\n(pc >= debug_sect))\r\nstatus = -ERANGE;\r\n}\r\n} else\r\nif (altera_check_stack(stack_ptr, 1, &status)) {\r\npc = stack[--stack_ptr] + code_sect;\r\nif ((pc <= code_sect) ||\r\n(pc >= debug_sect))\r\nstatus = -ERANGE;\r\n}\r\nbreak;\r\ncase OP_CMPS:\r\nif (altera_check_stack(stack_ptr, 4, &status)) {\r\ns32 a = stack[--stack_ptr];\r\ns32 b = stack[--stack_ptr];\r\nlong_tmp = stack[--stack_ptr];\r\ncount = stack[stack_ptr - 1];\r\nif ((count < 1) || (count > 32))\r\nstatus = -ERANGE;\r\nelse {\r\nlong_tmp &= ((-1L) >> (32 - count));\r\nstack[stack_ptr - 1] =\r\n((a & long_tmp) == (b & long_tmp))\r\n? 1L : 0L;\r\n}\r\n}\r\nbreak;\r\ncase OP_PINT:\r\nif (!altera_check_stack(stack_ptr, 1, &status))\r\nbreak;\r\nsprintf(&msg_buff[strlen(msg_buff)],\r\n"%ld", stack[--stack_ptr]);\r\nbreak;\r\ncase OP_PRNT:\r\nif (debug)\r\nprintk(msg_buff, "\n");\r\nmsg_buff[0] = '\0';\r\nbreak;\r\ncase OP_DSS:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\nlong_tmp = stack[--stack_ptr];\r\ncount = stack[--stack_ptr];\r\nput_unaligned_le32(long_tmp, &charbuf[0]);\r\nstatus = altera_drscan(astate, count, charbuf, 0);\r\nbreak;\r\ncase OP_DSSC:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\nlong_tmp = stack[--stack_ptr];\r\ncount = stack[stack_ptr - 1];\r\nput_unaligned_le32(long_tmp, &charbuf[0]);\r\nstatus = altera_swap_dr(astate, count, charbuf,\r\n0, charbuf, 0);\r\nstack[stack_ptr - 1] = get_unaligned_le32(&charbuf[0]);\r\nbreak;\r\ncase OP_ISS:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\nlong_tmp = stack[--stack_ptr];\r\ncount = stack[--stack_ptr];\r\nput_unaligned_le32(long_tmp, &charbuf[0]);\r\nstatus = altera_irscan(astate, count, charbuf, 0);\r\nbreak;\r\ncase OP_ISSC:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\nlong_tmp = stack[--stack_ptr];\r\ncount = stack[stack_ptr - 1];\r\nput_unaligned_le32(long_tmp, &charbuf[0]);\r\nstatus = altera_swap_ir(astate, count, charbuf,\r\n0, charbuf, 0);\r\nstack[stack_ptr - 1] = get_unaligned_le32(&charbuf[0]);\r\nbreak;\r\ncase OP_DPR:\r\nif (!altera_check_stack(stack_ptr, 1, &status))\r\nbreak;\r\ncount = stack[--stack_ptr];\r\nstatus = altera_set_dr_pre(&astate->js, count, 0, NULL);\r\nbreak;\r\ncase OP_DPRL:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\ncount = stack[--stack_ptr];\r\nlong_tmp = stack[--stack_ptr];\r\nput_unaligned_le32(long_tmp, &charbuf[0]);\r\nstatus = altera_set_dr_pre(&astate->js, count, 0,\r\ncharbuf);\r\nbreak;\r\ncase OP_DPO:\r\nif (altera_check_stack(stack_ptr, 1, &status)) {\r\ncount = stack[--stack_ptr];\r\nstatus = altera_set_dr_post(&astate->js, count,\r\n0, NULL);\r\n}\r\nbreak;\r\ncase OP_DPOL:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\ncount = stack[--stack_ptr];\r\nlong_tmp = stack[--stack_ptr];\r\nput_unaligned_le32(long_tmp, &charbuf[0]);\r\nstatus = altera_set_dr_post(&astate->js, count, 0,\r\ncharbuf);\r\nbreak;\r\ncase OP_IPR:\r\nif (altera_check_stack(stack_ptr, 1, &status)) {\r\ncount = stack[--stack_ptr];\r\nstatus = altera_set_ir_pre(&astate->js, count,\r\n0, NULL);\r\n}\r\nbreak;\r\ncase OP_IPRL:\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\ncount = stack[--stack_ptr];\r\nlong_tmp = stack[--stack_ptr];\r\nput_unaligned_le32(long_tmp, &charbuf[0]);\r\nstatus = altera_set_ir_pre(&astate->js, count,\r\n0, charbuf);\r\n}\r\nbreak;\r\ncase OP_IPO:\r\nif (altera_check_stack(stack_ptr, 1, &status)) {\r\ncount = stack[--stack_ptr];\r\nstatus = altera_set_ir_post(&astate->js, count,\r\n0, NULL);\r\n}\r\nbreak;\r\ncase OP_IPOL:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\ncount = stack[--stack_ptr];\r\nlong_tmp = stack[--stack_ptr];\r\nput_unaligned_le32(long_tmp, &charbuf[0]);\r\nstatus = altera_set_ir_post(&astate->js, count, 0,\r\ncharbuf);\r\nbreak;\r\ncase OP_PCHR:\r\nif (altera_check_stack(stack_ptr, 1, &status)) {\r\nu8 ch;\r\ncount = strlen(msg_buff);\r\nch = (char) stack[--stack_ptr];\r\nif ((ch < 1) || (ch > 127)) {\r\nch = 127;\r\n}\r\nmsg_buff[count] = ch;\r\nmsg_buff[count + 1] = '\0';\r\n}\r\nbreak;\r\ncase OP_EXIT:\r\nif (altera_check_stack(stack_ptr, 1, &status))\r\n*exit_code = stack[--stack_ptr];\r\ndone = 1;\r\nbreak;\r\ncase OP_EQU:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\n--stack_ptr;\r\nstack[stack_ptr - 1] =\r\n(stack[stack_ptr - 1] == stack[stack_ptr]) ?\r\n1L : 0L;\r\nbreak;\r\ncase OP_POPT:\r\nif (altera_check_stack(stack_ptr, 1, &status))\r\n--stack_ptr;\r\nbreak;\r\ncase OP_ABS:\r\nif (!altera_check_stack(stack_ptr, 1, &status))\r\nbreak;\r\nif (stack[stack_ptr - 1] < 0)\r\nstack[stack_ptr - 1] = 0 - stack[stack_ptr - 1];\r\nbreak;\r\ncase OP_BCH0:\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\nlong_tmp = stack[stack_ptr - 2];\r\nstack[stack_ptr - 2] = stack[stack_ptr - 1];\r\nstack[stack_ptr - 1] = long_tmp;\r\n}\r\nindex = 7 + 1;\r\nif (altera_check_stack(stack_ptr, index, &status)) {\r\nlong_tmp = stack[stack_ptr - index];\r\nstack[stack_ptr - index] = stack[stack_ptr - 1];\r\nstack[stack_ptr - 1] = long_tmp;\r\n}\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\nlong_tmp = stack[stack_ptr - 2];\r\nstack[stack_ptr - 2] = stack[stack_ptr - 1];\r\nstack[stack_ptr - 1] = long_tmp;\r\n}\r\nindex = 6 + 1;\r\nif (altera_check_stack(stack_ptr, index, &status)) {\r\nlong_tmp = stack[stack_ptr - index];\r\nstack[stack_ptr - index] = stack[stack_ptr - 1];\r\nstack[stack_ptr - 1] = long_tmp;\r\n}\r\nindex = 8 + 1;\r\nif (altera_check_stack(stack_ptr, index, &status)) {\r\nstack[stack_ptr] = stack[stack_ptr - index];\r\n++stack_ptr;\r\n}\r\nindex = 2 + 1;\r\nif (altera_check_stack(stack_ptr, index, &status)) {\r\nlong_tmp = stack[stack_ptr - index];\r\nstack[stack_ptr - index] = stack[stack_ptr - 1];\r\nstack[stack_ptr - 1] = long_tmp;\r\n}\r\nif (altera_check_stack(stack_ptr, 2, &status)) {\r\nlong_tmp = stack[stack_ptr - 2];\r\nstack[stack_ptr - 2] = stack[stack_ptr - 1];\r\nstack[stack_ptr - 1] = long_tmp;\r\n}\r\nindex = 6 + 1;\r\nif (altera_check_stack(stack_ptr, index, &status)) {\r\nstack[stack_ptr] = stack[stack_ptr - index];\r\n++stack_ptr;\r\n}\r\nindex = 6 + 1;\r\nif (altera_check_stack(stack_ptr, index, &status)) {\r\nstack[stack_ptr] = stack[stack_ptr - index];\r\n++stack_ptr;\r\n}\r\nbreak;\r\ncase OP_PSH0:\r\nstack[stack_ptr++] = 0;\r\nbreak;\r\ncase OP_PSHL:\r\nstack[stack_ptr++] = (s32) args[0];\r\nbreak;\r\ncase OP_PSHV:\r\nstack[stack_ptr++] = vars[args[0]];\r\nbreak;\r\ncase OP_JMP:\r\npc = args[0] + code_sect;\r\nif ((pc < code_sect) || (pc >= debug_sect))\r\nstatus = -ERANGE;\r\nbreak;\r\ncase OP_CALL:\r\nstack[stack_ptr++] = pc;\r\npc = args[0] + code_sect;\r\nif ((pc < code_sect) || (pc >= debug_sect))\r\nstatus = -ERANGE;\r\nbreak;\r\ncase OP_NEXT:\r\nif (altera_check_stack(stack_ptr, 3, &status)) {\r\ns32 step = stack[stack_ptr - 1];\r\ns32 end = stack[stack_ptr - 2];\r\ns32 top = stack[stack_ptr - 3];\r\ns32 iterator = vars[args[0]];\r\nint break_out = 0;\r\nif (step < 0) {\r\nif (iterator <= end)\r\nbreak_out = 1;\r\n} else if (iterator >= end)\r\nbreak_out = 1;\r\nif (break_out) {\r\nstack_ptr -= 3;\r\n} else {\r\nvars[args[0]] = iterator + step;\r\npc = top + code_sect;\r\nif ((pc < code_sect) ||\r\n(pc >= debug_sect))\r\nstatus = -ERANGE;\r\n}\r\n}\r\nbreak;\r\ncase OP_PSTR:\r\ncount = strlen(msg_buff);\r\nstrlcpy(&msg_buff[count],\r\n&p[str_table + args[0]],\r\nALTERA_MESSAGE_LENGTH - count);\r\nbreak;\r\ncase OP_SINT:\r\nstatus = altera_goto_jstate(astate, args[0]);\r\nbreak;\r\ncase OP_ST:\r\nstatus = altera_goto_jstate(astate, args[0]);\r\nbreak;\r\ncase OP_ISTP:\r\nstatus = altera_set_irstop(&astate->js, args[0]);\r\nbreak;\r\ncase OP_DSTP:\r\nstatus = altera_set_drstop(&astate->js, args[0]);\r\nbreak;\r\ncase OP_SWPN:\r\nindex = (args[0]) + 1;\r\nif (altera_check_stack(stack_ptr, index, &status)) {\r\nlong_tmp = stack[stack_ptr - index];\r\nstack[stack_ptr - index] = stack[stack_ptr - 1];\r\nstack[stack_ptr - 1] = long_tmp;\r\n}\r\nbreak;\r\ncase OP_DUPN:\r\nindex = (args[0]) + 1;\r\nif (altera_check_stack(stack_ptr, index, &status)) {\r\nstack[stack_ptr] = stack[stack_ptr - index];\r\n++stack_ptr;\r\n}\r\nbreak;\r\ncase OP_POPV:\r\nif (altera_check_stack(stack_ptr, 1, &status))\r\nvars[args[0]] = stack[--stack_ptr];\r\nbreak;\r\ncase OP_POPE:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\nvariable_id = args[0];\r\nif ((version > 0) &&\r\n((attrs[variable_id] & 0x9c) == 0x1c)) {\r\ncount = var_size[variable_id];\r\nlong_tmp = vars[variable_id];\r\nlongptr_tmp = kzalloc(count * sizeof(long),\r\nGFP_KERNEL);\r\nvars[variable_id] = (long)longptr_tmp;\r\nif (vars[variable_id] == 0) {\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nfor (i = 0; i < count; ++i) {\r\nlongptr_tmp[i] =\r\nget_unaligned_be32(&p[long_tmp]);\r\nlong_tmp += sizeof(long);\r\n}\r\nattrs[variable_id] |= 0x80;\r\nattrs[variable_id] &= ~0x04;\r\nattrs[variable_id] |= 0x01;\r\n}\r\nif ((attrs[variable_id] & 0x1c) != 0x18)\r\nstatus = -ERANGE;\r\nelse {\r\nlongptr_tmp = (long *)vars[variable_id];\r\nindex = stack[--stack_ptr];\r\nlongptr_tmp[index] = stack[--stack_ptr];\r\n}\r\nbreak;\r\ncase OP_POPA:\r\nif (!altera_check_stack(stack_ptr, 3, &status))\r\nbreak;\r\nvariable_id = args[0];\r\nif ((version > 0) &&\r\n((attrs[variable_id] & 0x9c) == 0x0c)) {\r\nlong_tmp =\r\n(var_size[variable_id] + 7L) >> 3L;\r\ncharptr_tmp2 = (u8 *)vars[variable_id];\r\ncharptr_tmp =\r\nkzalloc(long_tmp, GFP_KERNEL);\r\nvars[variable_id] = (long)charptr_tmp;\r\nif (vars[variable_id] == 0) {\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nfor (long_idx = 0L;\r\nlong_idx < long_tmp;\r\n++long_idx) {\r\ncharptr_tmp[long_idx] = 0;\r\n}\r\nfor (long_idx = 0L;\r\nlong_idx < var_size[variable_id];\r\n++long_idx) {\r\nlong_idx2 = long_idx;\r\nif (charptr_tmp2[long_idx2 >> 3] &\r\n(1 << (long_idx2 & 7))) {\r\ncharptr_tmp[long_idx >> 3] |=\r\n(1 << (long_idx & 7));\r\n}\r\n}\r\nattrs[variable_id] |= 0x80;\r\nattrs[variable_id] &= ~0x04;\r\nattrs[variable_id] |= 0x01;\r\n}\r\nif ((attrs[variable_id] & 0x1c) != 0x08) {\r\nstatus = -ERANGE;\r\nbreak;\r\n}\r\ncharptr_tmp = (u8 *)vars[variable_id];\r\nlong_count = stack[--stack_ptr];\r\nlong_idx = stack[--stack_ptr];\r\nreverse = 0;\r\nif (version > 0) {\r\nif (long_idx > long_count) {\r\nreverse = 1;\r\nlong_tmp = long_count;\r\nlong_count = 1 + long_idx -\r\nlong_count;\r\nlong_idx = long_tmp;\r\nstatus = -ERANGE;\r\nbreak;\r\n} else\r\nlong_count = 1 + long_count -\r\nlong_idx;\r\n}\r\nlong_tmp = stack[--stack_ptr];\r\nif (long_count < 1) {\r\nstatus = -ERANGE;\r\nbreak;\r\n}\r\nfor (i = 0; i < long_count; ++i) {\r\nif (long_tmp & (1L << (s32) i))\r\ncharptr_tmp[long_idx >> 3L] |=\r\n(1L << (long_idx & 7L));\r\nelse\r\ncharptr_tmp[long_idx >> 3L] &=\r\n~(1L << (long_idx & 7L));\r\n++long_idx;\r\n}\r\nbreak;\r\ncase OP_JMPZ:\r\nif (altera_check_stack(stack_ptr, 1, &status)) {\r\nif (stack[--stack_ptr] == 0) {\r\npc = args[0] + code_sect;\r\nif ((pc < code_sect) ||\r\n(pc >= debug_sect))\r\nstatus = -ERANGE;\r\n}\r\n}\r\nbreak;\r\ncase OP_DS:\r\ncase OP_IS:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\nlong_idx = stack[--stack_ptr];\r\nlong_count = stack[--stack_ptr];\r\nreverse = 0;\r\nif (version > 0) {\r\nlong_tmp = long_count;\r\nlong_count = stack[--stack_ptr];\r\nif (long_idx > long_tmp) {\r\nreverse = 1;\r\nlong_idx = long_tmp;\r\n}\r\n}\r\ncharptr_tmp = (u8 *)vars[args[0]];\r\nif (reverse) {\r\ncharptr_tmp2 = charptr_tmp;\r\ncharptr_tmp = kzalloc((long_count >> 3) + 1,\r\nGFP_KERNEL);\r\nif (charptr_tmp == NULL) {\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nlong_tmp = long_idx + long_count - 1;\r\nlong_idx2 = 0;\r\nwhile (long_idx2 < long_count) {\r\nif (charptr_tmp2[long_tmp >> 3] &\r\n(1 << (long_tmp & 7)))\r\ncharptr_tmp[long_idx2 >> 3] |=\r\n(1 << (long_idx2 & 7));\r\nelse\r\ncharptr_tmp[long_idx2 >> 3] &=\r\n~(1 << (long_idx2 & 7));\r\n--long_tmp;\r\n++long_idx2;\r\n}\r\n}\r\nif (opcode == 0x51)\r\nstatus = altera_drscan(astate, long_count,\r\ncharptr_tmp, long_idx);\r\nelse\r\nstatus = altera_irscan(astate, long_count,\r\ncharptr_tmp, long_idx);\r\nif (reverse)\r\nkfree(charptr_tmp);\r\nbreak;\r\ncase OP_DPRA:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\nindex = stack[--stack_ptr];\r\ncount = stack[--stack_ptr];\r\nif (version > 0)\r\ncount = 1 + count - index;\r\ncharptr_tmp = (u8 *)vars[args[0]];\r\nstatus = altera_set_dr_pre(&astate->js, count, index,\r\ncharptr_tmp);\r\nbreak;\r\ncase OP_DPOA:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\nindex = stack[--stack_ptr];\r\ncount = stack[--stack_ptr];\r\nif (version > 0)\r\ncount = 1 + count - index;\r\ncharptr_tmp = (u8 *)vars[args[0]];\r\nstatus = altera_set_dr_post(&astate->js, count, index,\r\ncharptr_tmp);\r\nbreak;\r\ncase OP_IPRA:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\nindex = stack[--stack_ptr];\r\ncount = stack[--stack_ptr];\r\nif (version > 0)\r\ncount = 1 + count - index;\r\ncharptr_tmp = (u8 *)vars[args[0]];\r\nstatus = altera_set_ir_pre(&astate->js, count, index,\r\ncharptr_tmp);\r\nbreak;\r\ncase OP_IPOA:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\nindex = stack[--stack_ptr];\r\ncount = stack[--stack_ptr];\r\nif (version > 0)\r\ncount = 1 + count - index;\r\ncharptr_tmp = (u8 *)vars[args[0]];\r\nstatus = altera_set_ir_post(&astate->js, count, index,\r\ncharptr_tmp);\r\nbreak;\r\ncase OP_EXPT:\r\nif (altera_check_stack(stack_ptr, 1, &status)) {\r\nname = &p[str_table + args[0]];\r\nlong_tmp = stack[--stack_ptr];\r\naltera_export_int(name, long_tmp);\r\n}\r\nbreak;\r\ncase OP_PSHE:\r\nif (!altera_check_stack(stack_ptr, 1, &status))\r\nbreak;\r\nvariable_id = args[0];\r\nindex = stack[stack_ptr - 1];\r\nif ((attrs[variable_id] & 0x1f) == 0x19) {\r\nlongptr_tmp = (long *)vars[variable_id];\r\nstack[stack_ptr - 1] = longptr_tmp[index];\r\n} else if ((attrs[variable_id] & 0x1f) == 0x1c) {\r\nlong_tmp = vars[variable_id] +\r\n(index * sizeof(long));\r\nstack[stack_ptr - 1] =\r\nget_unaligned_be32(&p[long_tmp]);\r\n} else\r\nstatus = -ERANGE;\r\nbreak;\r\ncase OP_PSHA:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\nvariable_id = args[0];\r\nif ((attrs[variable_id] & 0x18) != 0x08) {\r\nstatus = -ERANGE;\r\nbreak;\r\n}\r\ncharptr_tmp = (u8 *)vars[variable_id];\r\ncount = stack[--stack_ptr];\r\nindex = stack[stack_ptr - 1];\r\nif (version > 0)\r\ncount = 1 + count - index;\r\nif ((count < 1) || (count > 32)) {\r\nstatus = -ERANGE;\r\nbreak;\r\n}\r\nlong_tmp = 0L;\r\nfor (i = 0; i < count; ++i)\r\nif (charptr_tmp[(i + index) >> 3] &\r\n(1 << ((i + index) & 7)))\r\nlong_tmp |= (1L << i);\r\nstack[stack_ptr - 1] = long_tmp;\r\nbreak;\r\ncase OP_DYNA:\r\nif (!altera_check_stack(stack_ptr, 1, &status))\r\nbreak;\r\nvariable_id = args[0];\r\nlong_tmp = stack[--stack_ptr];\r\nif (long_tmp > var_size[variable_id]) {\r\nvar_size[variable_id] = long_tmp;\r\nif (attrs[variable_id] & 0x10)\r\nlong_tmp *= sizeof(long);\r\nelse\r\nlong_tmp = (long_tmp + 7) >> 3;\r\nif (attrs[variable_id] & 0x80) {\r\nkfree((void *)vars[variable_id]);\r\nvars[variable_id] = 0;\r\n}\r\nvars[variable_id] = (long)\r\nkzalloc(long_tmp, GFP_KERNEL);\r\nif (vars[variable_id] == 0) {\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nattrs[variable_id] |= 0x80;\r\ncount = ((var_size[variable_id] + 7L) /\r\n8L);\r\ncharptr_tmp = (u8 *)(vars[variable_id]);\r\nfor (index = 0; index < count; ++index)\r\ncharptr_tmp[index] = 0;\r\n}\r\nbreak;\r\ncase OP_EXPV:\r\nif (!altera_check_stack(stack_ptr, 3, &status))\r\nbreak;\r\nif (version == 0) {\r\nbad_opcode = 1;\r\nbreak;\r\n}\r\nname = &p[str_table + args[0]];\r\nvariable_id = stack[--stack_ptr];\r\nlong_idx = stack[--stack_ptr];\r\nlong_idx2 = stack[--stack_ptr];\r\nif (long_idx > long_idx2) {\r\nstatus = -ERANGE;\r\nbreak;\r\n}\r\nlong_count = 1 + long_idx2 - long_idx;\r\ncharptr_tmp = (u8 *)vars[variable_id];\r\ncharptr_tmp2 = NULL;\r\nif ((long_idx & 7L) != 0) {\r\ns32 k = long_idx;\r\ncharptr_tmp2 =\r\nkzalloc(((long_count + 7L) / 8L),\r\nGFP_KERNEL);\r\nif (charptr_tmp2 == NULL) {\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nfor (i = 0; i < long_count; ++i) {\r\nif (charptr_tmp[k >> 3] &\r\n(1 << (k & 7)))\r\ncharptr_tmp2[i >> 3] |=\r\n(1 << (i & 7));\r\nelse\r\ncharptr_tmp2[i >> 3] &=\r\n~(1 << (i & 7));\r\n++k;\r\n}\r\ncharptr_tmp = charptr_tmp2;\r\n} else if (long_idx != 0)\r\ncharptr_tmp = &charptr_tmp[long_idx >> 3];\r\naltera_export_bool_array(name, charptr_tmp,\r\nlong_count);\r\nif ((long_idx & 7L) != 0)\r\nkfree(charptr_tmp2);\r\nbreak;\r\ncase OP_COPY: {\r\ns32 copy_count;\r\ns32 copy_index;\r\ns32 copy_index2;\r\ns32 destleft;\r\ns32 src_count;\r\ns32 dest_count;\r\nint src_reverse = 0;\r\nint dest_reverse = 0;\r\nif (!altera_check_stack(stack_ptr, 3, &status))\r\nbreak;\r\ncopy_count = stack[--stack_ptr];\r\ncopy_index = stack[--stack_ptr];\r\ncopy_index2 = stack[--stack_ptr];\r\nreverse = 0;\r\nif (version > 0) {\r\ndestleft = stack[--stack_ptr];\r\nif (copy_count > copy_index) {\r\nsrc_reverse = 1;\r\nreverse = 1;\r\nsrc_count = 1 + copy_count - copy_index;\r\n} else {\r\nsrc_count = 1 + copy_index - copy_count;\r\ncopy_index = copy_count;\r\n}\r\nif (copy_index2 > destleft) {\r\ndest_reverse = 1;\r\nreverse = !reverse;\r\ndest_count = 1 + copy_index2 - destleft;\r\ncopy_index2 = destleft;\r\n} else\r\ndest_count = 1 + destleft - copy_index2;\r\ncopy_count = (src_count < dest_count) ?\r\nsrc_count : dest_count;\r\nif ((src_reverse || dest_reverse) &&\r\n(src_count != dest_count))\r\nstatus = -ERANGE;\r\n}\r\ncount = copy_count;\r\nindex = copy_index;\r\nindex2 = copy_index2;\r\nvariable_id = args[1];\r\nif ((version > 0) &&\r\n((attrs[variable_id] & 0x9c) == 0x0c)) {\r\nlong_tmp =\r\n(var_size[variable_id] + 7L) >> 3L;\r\ncharptr_tmp2 = (u8 *)vars[variable_id];\r\ncharptr_tmp =\r\nkzalloc(long_tmp, GFP_KERNEL);\r\nvars[variable_id] = (long)charptr_tmp;\r\nif (vars[variable_id] == 0) {\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nfor (long_idx = 0L; long_idx < long_tmp;\r\n++long_idx)\r\ncharptr_tmp[long_idx] = 0;\r\nfor (long_idx = 0L;\r\nlong_idx < var_size[variable_id];\r\n++long_idx) {\r\nlong_idx2 = long_idx;\r\nif (charptr_tmp2[long_idx2 >> 3] &\r\n(1 << (long_idx2 & 7)))\r\ncharptr_tmp[long_idx >> 3] |=\r\n(1 << (long_idx & 7));\r\n}\r\nattrs[variable_id] |= 0x80;\r\nattrs[variable_id] &= ~0x04;\r\nattrs[variable_id] |= 0x01;\r\n}\r\ncharptr_tmp = (u8 *)vars[args[1]];\r\ncharptr_tmp2 = (u8 *)vars[args[0]];\r\nif ((attrs[args[1]] & 0x1c) != 0x08) {\r\nstatus = -ERANGE;\r\nbreak;\r\n}\r\nif (count < 1) {\r\nstatus = -ERANGE;\r\nbreak;\r\n}\r\nif (reverse)\r\nindex2 += (count - 1);\r\nfor (i = 0; i < count; ++i) {\r\nif (charptr_tmp2[index >> 3] &\r\n(1 << (index & 7)))\r\ncharptr_tmp[index2 >> 3] |=\r\n(1 << (index2 & 7));\r\nelse\r\ncharptr_tmp[index2 >> 3] &=\r\n~(1 << (index2 & 7));\r\n++index;\r\nif (reverse)\r\n--index2;\r\nelse\r\n++index2;\r\n}\r\nbreak;\r\n}\r\ncase OP_DSC:\r\ncase OP_ISC: {\r\ns32 scan_right, scan_left;\r\ns32 capture_count = 0;\r\ns32 scan_count = 0;\r\ns32 capture_index;\r\ns32 scan_index;\r\nif (!altera_check_stack(stack_ptr, 3, &status))\r\nbreak;\r\ncapture_index = stack[--stack_ptr];\r\nscan_index = stack[--stack_ptr];\r\nif (version > 0) {\r\nscan_right = stack[--stack_ptr];\r\nscan_left = stack[--stack_ptr];\r\ncapture_count = 1 + scan_index - capture_index;\r\nscan_count = 1 + scan_left - scan_right;\r\nscan_index = scan_right;\r\n}\r\nlong_count = stack[--stack_ptr];\r\nvariable_id = args[1];\r\nif ((version > 0) &&\r\n((attrs[variable_id] & 0x9c) == 0x0c)) {\r\nlong_tmp =\r\n(var_size[variable_id] + 7L) >> 3L;\r\ncharptr_tmp2 = (u8 *)vars[variable_id];\r\ncharptr_tmp =\r\nkzalloc(long_tmp, GFP_KERNEL);\r\nvars[variable_id] = (long)charptr_tmp;\r\nif (vars[variable_id] == 0) {\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nfor (long_idx = 0L; long_idx < long_tmp;\r\n++long_idx)\r\ncharptr_tmp[long_idx] = 0;\r\nfor (long_idx = 0L;\r\nlong_idx < var_size[variable_id];\r\n++long_idx) {\r\nlong_idx2 = long_idx;\r\nif (charptr_tmp2[long_idx2 >> 3] &\r\n(1 << (long_idx2 & 7)))\r\ncharptr_tmp[long_idx >> 3] |=\r\n(1 << (long_idx & 7));\r\n}\r\nattrs[variable_id] |= 0x80;\r\nattrs[variable_id] &= ~0x04;\r\nattrs[variable_id] |= 0x01;\r\n}\r\ncharptr_tmp = (u8 *)vars[args[0]];\r\ncharptr_tmp2 = (u8 *)vars[args[1]];\r\nif ((version > 0) &&\r\n((long_count > capture_count) ||\r\n(long_count > scan_count))) {\r\nstatus = -ERANGE;\r\nbreak;\r\n}\r\nif ((attrs[args[1]] & 0x1c) != 0x08) {\r\nstatus = -ERANGE;\r\nbreak;\r\n}\r\nif (status == 0) {\r\nif (opcode == 0x82)\r\nstatus = altera_swap_dr(astate,\r\nlong_count,\r\ncharptr_tmp,\r\nscan_index,\r\ncharptr_tmp2,\r\ncapture_index);\r\nelse\r\nstatus = altera_swap_ir(astate,\r\nlong_count,\r\ncharptr_tmp,\r\nscan_index,\r\ncharptr_tmp2,\r\ncapture_index);\r\n}\r\nbreak;\r\n}\r\ncase OP_WAIT:\r\nif (!altera_check_stack(stack_ptr, 2, &status))\r\nbreak;\r\nlong_tmp = stack[--stack_ptr];\r\nif (long_tmp != 0L)\r\nstatus = altera_wait_cycles(astate, long_tmp,\r\nargs[0]);\r\nlong_tmp = stack[--stack_ptr];\r\nif ((status == 0) && (long_tmp != 0L))\r\nstatus = altera_wait_msecs(astate,\r\nlong_tmp,\r\nargs[0]);\r\nif ((status == 0) && (args[1] != args[0]))\r\nstatus = altera_goto_jstate(astate,\r\nargs[1]);\r\nif (version > 0) {\r\n--stack_ptr;\r\n--stack_ptr;\r\n}\r\nbreak;\r\ncase OP_CMPA: {\r\ns32 a, b;\r\nu8 *source1 = (u8 *)vars[args[0]];\r\nu8 *source2 = (u8 *)vars[args[1]];\r\nu8 *mask = (u8 *)vars[args[2]];\r\nu32 index1;\r\nu32 index2;\r\nu32 mask_index;\r\nif (!altera_check_stack(stack_ptr, 4, &status))\r\nbreak;\r\nindex1 = stack[--stack_ptr];\r\nindex2 = stack[--stack_ptr];\r\nmask_index = stack[--stack_ptr];\r\nlong_count = stack[--stack_ptr];\r\nif (version > 0) {\r\ns32 mask_right = stack[--stack_ptr];\r\ns32 mask_left = stack[--stack_ptr];\r\na = 1 + index2 - index1;\r\nb = 1 + long_count - mask_index;\r\na = (a < b) ? a : b;\r\nb = 1 + mask_left - mask_right;\r\na = (a < b) ? a : b;\r\nindex2 = mask_index;\r\nmask_index = mask_right;\r\nlong_count = a;\r\n}\r\nlong_tmp = 1L;\r\nif (long_count < 1)\r\nstatus = -ERANGE;\r\nelse {\r\ncount = long_count;\r\nfor (i = 0; i < count; ++i) {\r\nif (mask[mask_index >> 3] &\r\n(1 << (mask_index & 7))) {\r\na = source1[index1 >> 3] &\r\n(1 << (index1 & 7))\r\n? 1 : 0;\r\nb = source2[index2 >> 3] &\r\n(1 << (index2 & 7))\r\n? 1 : 0;\r\nif (a != b)\r\nlong_tmp = 0L;\r\n}\r\n++index1;\r\n++index2;\r\n++mask_index;\r\n}\r\n}\r\nstack[stack_ptr++] = long_tmp;\r\nbreak;\r\n}\r\ndefault:\r\nbad_opcode = 1;\r\nbreak;\r\n}\r\nif (bad_opcode)\r\nstatus = -ENOSYS;\r\nif ((stack_ptr < 0) || (stack_ptr >= ALTERA_STACK_SIZE))\r\nstatus = -EOVERFLOW;\r\nif (status != 0) {\r\ndone = 1;\r\n*error_address = (s32)(opcode_address - code_sect);\r\n}\r\n}\r\naltera_free_buffers(astate);\r\nif ((attrs != NULL) && (vars != NULL))\r\nfor (i = 0; i < sym_count; ++i)\r\nif (attrs[i] & 0x80)\r\nkfree((void *)vars[i]);\r\nkfree(vars);\r\nkfree(var_size);\r\nkfree(attrs);\r\nkfree(proc_attributes);\r\nreturn status;\r\n}\r\nstatic int altera_get_note(u8 *p, s32 program_size,\r\ns32 *offset, char *key, char *value, int length)\r\n{\r\nint status = -ENODATA;\r\nu32 note_strings = 0L;\r\nu32 note_table = 0L;\r\nu32 note_count = 0L;\r\nu32 first_word = 0L;\r\nint version = 0;\r\nint delta = 0;\r\nchar *key_ptr;\r\nchar *value_ptr;\r\nint i;\r\nif (program_size > 52L) {\r\nfirst_word = get_unaligned_be32(&p[0]);\r\nversion = (first_word & 1L);\r\ndelta = version * 8;\r\nnote_strings = get_unaligned_be32(&p[8 + delta]);\r\nnote_table = get_unaligned_be32(&p[12 + delta]);\r\nnote_count = get_unaligned_be32(&p[44 + (2 * delta)]);\r\n}\r\nif ((first_word != 0x4A414D00L) && (first_word != 0x4A414D01L))\r\nreturn -EIO;\r\nif (note_count <= 0L)\r\nreturn status;\r\nif (offset == NULL) {\r\nfor (i = 0; (i < note_count) &&\r\n(status != 0); ++i) {\r\nkey_ptr = &p[note_strings +\r\nget_unaligned_be32(\r\n&p[note_table + (8 * i)])];\r\nif ((strnicmp(key, key_ptr, strlen(key_ptr)) == 0) &&\r\n(key != NULL)) {\r\nstatus = 0;\r\nvalue_ptr = &p[note_strings +\r\nget_unaligned_be32(\r\n&p[note_table + (8 * i) + 4])];\r\nif (value != NULL)\r\nstrlcpy(value, value_ptr, length);\r\n}\r\n}\r\n} else {\r\ni = *offset;\r\nif ((i >= 0) && (i < note_count)) {\r\nstatus = 0;\r\nif (key != NULL)\r\nstrlcpy(key, &p[note_strings +\r\nget_unaligned_be32(\r\n&p[note_table + (8 * i)])],\r\nlength);\r\nif (value != NULL)\r\nstrlcpy(value, &p[note_strings +\r\nget_unaligned_be32(\r\n&p[note_table + (8 * i) + 4])],\r\nlength);\r\n*offset = i + 1;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int altera_check_crc(u8 *p, s32 program_size)\r\n{\r\nint status = 0;\r\nu16 local_expected = 0,\r\nlocal_actual = 0,\r\nshift_reg = 0xffff;\r\nint bit, feedback;\r\nu8 databyte;\r\nu32 i;\r\nu32 crc_section = 0L;\r\nu32 first_word = 0L;\r\nint version = 0;\r\nint delta = 0;\r\nif (program_size > 52L) {\r\nfirst_word = get_unaligned_be32(&p[0]);\r\nversion = (first_word & 1L);\r\ndelta = version * 8;\r\ncrc_section = get_unaligned_be32(&p[32 + delta]);\r\n}\r\nif ((first_word != 0x4A414D00L) && (first_word != 0x4A414D01L))\r\nstatus = -EIO;\r\nif (crc_section >= program_size)\r\nstatus = -EIO;\r\nif (status == 0) {\r\nlocal_expected = (u16)get_unaligned_be16(&p[crc_section]);\r\nfor (i = 0; i < crc_section; ++i) {\r\ndatabyte = p[i];\r\nfor (bit = 0; bit < 8; bit++) {\r\nfeedback = (databyte ^ shift_reg) & 0x01;\r\nshift_reg >>= 1;\r\nif (feedback)\r\nshift_reg ^= 0x8408;\r\ndatabyte >>= 1;\r\n}\r\n}\r\nlocal_actual = (u16)~shift_reg;\r\nif (local_expected != local_actual)\r\nstatus = -EILSEQ;\r\n}\r\nif (debug || status) {\r\nswitch (status) {\r\ncase 0:\r\nprintk(KERN_INFO "%s: CRC matched: %04x\n", __func__,\r\nlocal_actual);\r\nbreak;\r\ncase -EILSEQ:\r\nprintk(KERN_ERR "%s: CRC mismatch: expected %04x, "\r\n"actual %04x\n", __func__, local_expected,\r\nlocal_actual);\r\nbreak;\r\ncase -ENODATA:\r\nprintk(KERN_ERR "%s: expected CRC not found, "\r\n"actual CRC = %04x\n", __func__,\r\nlocal_actual);\r\nbreak;\r\ncase -EIO:\r\nprintk(KERN_ERR "%s: error: format isn't "\r\n"recognized.\n", __func__);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: CRC function returned error "\r\n"code %d\n", __func__, status);\r\nbreak;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int altera_get_file_info(u8 *p,\r\ns32 program_size,\r\nint *format_version,\r\nint *action_count,\r\nint *procedure_count)\r\n{\r\nint status = -EIO;\r\nu32 first_word = 0;\r\nint version = 0;\r\nif (program_size <= 52L)\r\nreturn status;\r\nfirst_word = get_unaligned_be32(&p[0]);\r\nif ((first_word == 0x4A414D00L) || (first_word == 0x4A414D01L)) {\r\nstatus = 0;\r\nversion = (first_word & 1L);\r\n*format_version = version + 1;\r\nif (version > 0) {\r\n*action_count = get_unaligned_be32(&p[48]);\r\n*procedure_count = get_unaligned_be32(&p[52]);\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int altera_get_act_info(u8 *p,\r\ns32 program_size,\r\nint index,\r\nchar **name,\r\nchar **description,\r\nstruct altera_procinfo **proc_list)\r\n{\r\nint status = -EIO;\r\nstruct altera_procinfo *procptr = NULL;\r\nstruct altera_procinfo *tmpptr = NULL;\r\nu32 first_word = 0L;\r\nu32 action_table = 0L;\r\nu32 proc_table = 0L;\r\nu32 str_table = 0L;\r\nu32 note_strings = 0L;\r\nu32 action_count = 0L;\r\nu32 proc_count = 0L;\r\nu32 act_name_id = 0L;\r\nu32 act_desc_id = 0L;\r\nu32 act_proc_id = 0L;\r\nu32 act_proc_name = 0L;\r\nu8 act_proc_attribute = 0;\r\nif (program_size <= 52L)\r\nreturn status;\r\nfirst_word = get_unaligned_be32(&p[0]);\r\nif (first_word != 0x4A414D01L)\r\nreturn status;\r\naction_table = get_unaligned_be32(&p[4]);\r\nproc_table = get_unaligned_be32(&p[8]);\r\nstr_table = get_unaligned_be32(&p[12]);\r\nnote_strings = get_unaligned_be32(&p[16]);\r\naction_count = get_unaligned_be32(&p[48]);\r\nproc_count = get_unaligned_be32(&p[52]);\r\nif (index >= action_count)\r\nreturn status;\r\nact_name_id = get_unaligned_be32(&p[action_table + (12 * index)]);\r\nact_desc_id = get_unaligned_be32(&p[action_table + (12 * index) + 4]);\r\nact_proc_id = get_unaligned_be32(&p[action_table + (12 * index) + 8]);\r\n*name = &p[str_table + act_name_id];\r\nif (act_desc_id < (note_strings - str_table))\r\n*description = &p[str_table + act_desc_id];\r\ndo {\r\nact_proc_name = get_unaligned_be32(\r\n&p[proc_table + (13 * act_proc_id)]);\r\nact_proc_attribute =\r\n(p[proc_table + (13 * act_proc_id) + 8] & 0x03);\r\nprocptr =\r\nkzalloc(sizeof(struct altera_procinfo),\r\nGFP_KERNEL);\r\nif (procptr == NULL)\r\nstatus = -ENOMEM;\r\nelse {\r\nprocptr->name = &p[str_table + act_proc_name];\r\nprocptr->attrs = act_proc_attribute;\r\nprocptr->next = NULL;\r\nif (*proc_list == NULL)\r\n*proc_list = procptr;\r\nelse {\r\ntmpptr = *proc_list;\r\nwhile (tmpptr->next != NULL)\r\ntmpptr = tmpptr->next;\r\ntmpptr->next = procptr;\r\n}\r\n}\r\nact_proc_id = get_unaligned_be32(\r\n&p[proc_table + (13 * act_proc_id) + 4]);\r\n} while ((act_proc_id != 0) && (act_proc_id < proc_count));\r\nreturn status;\r\n}\r\nint altera_init(struct altera_config *config, const struct firmware *fw)\r\n{\r\nstruct altera_state *astate = NULL;\r\nstruct altera_procinfo *proc_list = NULL;\r\nstruct altera_procinfo *procptr = NULL;\r\nchar *key = NULL;\r\nchar *value = NULL;\r\nchar *action_name = NULL;\r\nchar *description = NULL;\r\nint exec_result = 0;\r\nint exit_code = 0;\r\nint format_version = 0;\r\nint action_count = 0;\r\nint procedure_count = 0;\r\nint index = 0;\r\ns32 offset = 0L;\r\ns32 error_address = 0L;\r\nint retval = 0;\r\nkey = kzalloc(33, GFP_KERNEL);\r\nif (!key) {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nvalue = kzalloc(257, GFP_KERNEL);\r\nif (!value) {\r\nretval = -ENOMEM;\r\ngoto free_key;\r\n}\r\nastate = kzalloc(sizeof(struct altera_state), GFP_KERNEL);\r\nif (!astate) {\r\nretval = -ENOMEM;\r\ngoto free_value;\r\n}\r\nastate->config = config;\r\nif (!astate->config->jtag_io) {\r\ndprintk(KERN_INFO "%s: using byteblaster!\n", __func__);\r\nastate->config->jtag_io = netup_jtag_io_lpt;\r\n}\r\naltera_check_crc((u8 *)fw->data, fw->size);\r\nif (debug) {\r\naltera_get_file_info((u8 *)fw->data, fw->size, &format_version,\r\n&action_count, &procedure_count);\r\nprintk(KERN_INFO "%s: File format is %s ByteCode format\n",\r\n__func__, (format_version == 2) ? "Jam STAPL" :\r\n"pre-standardized Jam 1.1");\r\nwhile (altera_get_note((u8 *)fw->data, fw->size,\r\n&offset, key, value, 256) == 0)\r\nprintk(KERN_INFO "%s: NOTE \"%s\" = \"%s\"\n",\r\n__func__, key, value);\r\n}\r\nif (debug && (format_version == 2) && (action_count > 0)) {\r\nprintk(KERN_INFO "%s: Actions available:\n", __func__);\r\nfor (index = 0; index < action_count; ++index) {\r\naltera_get_act_info((u8 *)fw->data, fw->size,\r\nindex, &action_name,\r\n&description,\r\n&proc_list);\r\nif (description == NULL)\r\nprintk(KERN_INFO "%s: %s\n",\r\n__func__,\r\naction_name);\r\nelse\r\nprintk(KERN_INFO "%s: %s \"%s\"\n",\r\n__func__,\r\naction_name,\r\ndescription);\r\nprocptr = proc_list;\r\nwhile (procptr != NULL) {\r\nif (procptr->attrs != 0)\r\nprintk(KERN_INFO "%s: %s (%s)\n",\r\n__func__,\r\nprocptr->name,\r\n(procptr->attrs == 1) ?\r\n"optional" : "recommended");\r\nproc_list = procptr->next;\r\nkfree(procptr);\r\nprocptr = proc_list;\r\n}\r\n}\r\nprintk(KERN_INFO "\n");\r\n}\r\nexec_result = altera_execute(astate, (u8 *)fw->data, fw->size,\r\n&error_address, &exit_code, &format_version);\r\nif (exit_code)\r\nexec_result = -EREMOTEIO;\r\nif ((format_version == 2) && (exec_result == -EINVAL)) {\r\nif (astate->config->action == NULL)\r\nprintk(KERN_ERR "%s: error: no action specified for "\r\n"Jam STAPL file.\nprogram terminated.\n",\r\n__func__);\r\nelse\r\nprintk(KERN_ERR "%s: error: action \"%s\""\r\n" is not supported "\r\n"for this Jam STAPL file.\n"\r\n"Program terminated.\n", __func__,\r\nastate->config->action);\r\n} else if (exec_result)\r\nprintk(KERN_ERR "%s: error %d\n", __func__, exec_result);\r\nkfree(astate);\r\nfree_value:\r\nkfree(value);\r\nfree_key:\r\nkfree(key);\r\nout:\r\nreturn retval;\r\n}
