static u8 auto_voltage_bits(unsigned int millivolts)\r\n{\r\nif (millivolts < 1800)\r\nreturn 0x2f;\r\nif (millivolts > 3800)\r\nreturn 0xff;\r\nmillivolts -= 625;\r\nreturn millivolts / 25;\r\n}\r\nstatic u8 down_voltage_bits(unsigned int millivolts)\r\n{\r\nif (millivolts < 625)\r\nreturn 0;\r\nelse if (millivolts > 3000)\r\nreturn 0xff;\r\nmillivolts -= 625;\r\nreturn millivolts / 25;\r\n}\r\nstatic u8 ldo_voltage_bits(unsigned int millivolts)\r\n{\r\nif (millivolts < 900)\r\nreturn 0;\r\nelse if (millivolts > 3600)\r\nreturn 0x1f;\r\nmillivolts -= 900;\r\nreturn millivolts / 100;\r\n}\r\nstatic unsigned int auto_voltage_value(u8 bits)\r\n{\r\nif (bits < 0x2f)\r\nreturn 0;\r\nreturn 625 + (bits * 25);\r\n}\r\nstatic unsigned int down_voltage_value(u8 bits)\r\n{\r\nreturn 625 + (bits * 25);\r\n}\r\nstatic unsigned int ldo_voltage_value(u8 bits)\r\n{\r\nbits &= 0x1f;\r\nreturn 900 + (bits * 100);\r\n}\r\nstatic int pcf50633_regulator_map_voltage(struct regulator_dev *rdev,\r\nint min_uV, int max_uV)\r\n{\r\nstruct pcf50633 *pcf;\r\nint regulator_id, millivolts;\r\nu8 volt_bits;\r\npcf = rdev_get_drvdata(rdev);\r\nregulator_id = rdev_get_id(rdev);\r\nif (regulator_id >= PCF50633_NUM_REGULATORS)\r\nreturn -EINVAL;\r\nmillivolts = min_uV / 1000;\r\nswitch (regulator_id) {\r\ncase PCF50633_REGULATOR_AUTO:\r\nvolt_bits = auto_voltage_bits(millivolts);\r\nbreak;\r\ncase PCF50633_REGULATOR_DOWN1:\r\ncase PCF50633_REGULATOR_DOWN2:\r\nvolt_bits = down_voltage_bits(millivolts);\r\nbreak;\r\ncase PCF50633_REGULATOR_LDO1:\r\ncase PCF50633_REGULATOR_LDO2:\r\ncase PCF50633_REGULATOR_LDO3:\r\ncase PCF50633_REGULATOR_LDO4:\r\ncase PCF50633_REGULATOR_LDO5:\r\ncase PCF50633_REGULATOR_LDO6:\r\ncase PCF50633_REGULATOR_HCLDO:\r\ncase PCF50633_REGULATOR_MEMLDO:\r\nvolt_bits = ldo_voltage_bits(millivolts);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn volt_bits;\r\n}\r\nstatic int pcf50633_regulator_list_voltage(struct regulator_dev *rdev,\r\nunsigned int index)\r\n{\r\nint regulator_id = rdev_get_id(rdev);\r\nint millivolts;\r\nswitch (regulator_id) {\r\ncase PCF50633_REGULATOR_AUTO:\r\nmillivolts = auto_voltage_value(index);\r\nbreak;\r\ncase PCF50633_REGULATOR_DOWN1:\r\ncase PCF50633_REGULATOR_DOWN2:\r\nmillivolts = down_voltage_value(index);\r\nbreak;\r\ncase PCF50633_REGULATOR_LDO1:\r\ncase PCF50633_REGULATOR_LDO2:\r\ncase PCF50633_REGULATOR_LDO3:\r\ncase PCF50633_REGULATOR_LDO4:\r\ncase PCF50633_REGULATOR_LDO5:\r\ncase PCF50633_REGULATOR_LDO6:\r\ncase PCF50633_REGULATOR_HCLDO:\r\ncase PCF50633_REGULATOR_MEMLDO:\r\nmillivolts = ldo_voltage_value(index);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn millivolts * 1000;\r\n}\r\nstatic int __devinit pcf50633_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct regulator_dev *rdev;\r\nstruct pcf50633 *pcf;\r\nstruct regulator_config config = { };\r\npcf = dev_to_pcf50633(pdev->dev.parent);\r\nconfig.dev = &pdev->dev;\r\nconfig.init_data = pdev->dev.platform_data;\r\nconfig.driver_data = pcf;\r\nconfig.regmap = pcf->regmap;\r\nrdev = regulator_register(&regulators[pdev->id], &config);\r\nif (IS_ERR(rdev))\r\nreturn PTR_ERR(rdev);\r\nplatform_set_drvdata(pdev, rdev);\r\nif (pcf->pdata->regulator_registered)\r\npcf->pdata->regulator_registered(pcf, pdev->id);\r\nreturn 0;\r\n}\r\nstatic int __devexit pcf50633_regulator_remove(struct platform_device *pdev)\r\n{\r\nstruct regulator_dev *rdev = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nregulator_unregister(rdev);\r\nreturn 0;\r\n}\r\nstatic int __init pcf50633_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&pcf50633_regulator_driver);\r\n}\r\nstatic void __exit pcf50633_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&pcf50633_regulator_driver);\r\n}
