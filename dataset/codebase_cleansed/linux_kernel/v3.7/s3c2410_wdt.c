static int s3c2410wdt_keepalive(struct watchdog_device *wdd)\r\n{\r\nspin_lock(&wdt_lock);\r\nwritel(wdt_count, wdt_base + S3C2410_WTCNT);\r\nspin_unlock(&wdt_lock);\r\nreturn 0;\r\n}\r\nstatic void __s3c2410wdt_stop(void)\r\n{\r\nunsigned long wtcon;\r\nwtcon = readl(wdt_base + S3C2410_WTCON);\r\nwtcon &= ~(S3C2410_WTCON_ENABLE | S3C2410_WTCON_RSTEN);\r\nwritel(wtcon, wdt_base + S3C2410_WTCON);\r\n}\r\nstatic int s3c2410wdt_stop(struct watchdog_device *wdd)\r\n{\r\nspin_lock(&wdt_lock);\r\n__s3c2410wdt_stop();\r\nspin_unlock(&wdt_lock);\r\nreturn 0;\r\n}\r\nstatic int s3c2410wdt_start(struct watchdog_device *wdd)\r\n{\r\nunsigned long wtcon;\r\nspin_lock(&wdt_lock);\r\n__s3c2410wdt_stop();\r\nwtcon = readl(wdt_base + S3C2410_WTCON);\r\nwtcon |= S3C2410_WTCON_ENABLE | S3C2410_WTCON_DIV128;\r\nif (soft_noboot) {\r\nwtcon |= S3C2410_WTCON_INTEN;\r\nwtcon &= ~S3C2410_WTCON_RSTEN;\r\n} else {\r\nwtcon &= ~S3C2410_WTCON_INTEN;\r\nwtcon |= S3C2410_WTCON_RSTEN;\r\n}\r\nDBG("%s: wdt_count=0x%08x, wtcon=%08lx\n",\r\n__func__, wdt_count, wtcon);\r\nwritel(wdt_count, wdt_base + S3C2410_WTDAT);\r\nwritel(wdt_count, wdt_base + S3C2410_WTCNT);\r\nwritel(wtcon, wdt_base + S3C2410_WTCON);\r\nspin_unlock(&wdt_lock);\r\nreturn 0;\r\n}\r\nstatic inline int s3c2410wdt_is_running(void)\r\n{\r\nreturn readl(wdt_base + S3C2410_WTCON) & S3C2410_WTCON_ENABLE;\r\n}\r\nstatic int s3c2410wdt_set_heartbeat(struct watchdog_device *wdd, unsigned timeout)\r\n{\r\nunsigned long freq = clk_get_rate(wdt_clock);\r\nunsigned int count;\r\nunsigned int divisor = 1;\r\nunsigned long wtcon;\r\nif (timeout < 1)\r\nreturn -EINVAL;\r\nfreq /= 128;\r\ncount = timeout * freq;\r\nDBG("%s: count=%d, timeout=%d, freq=%lu\n",\r\n__func__, count, timeout, freq);\r\nif (count >= 0x10000) {\r\nfor (divisor = 1; divisor <= 0x100; divisor++) {\r\nif ((count / divisor) < 0x10000)\r\nbreak;\r\n}\r\nif ((count / divisor) >= 0x10000) {\r\ndev_err(wdt_dev, "timeout %d too big\n", timeout);\r\nreturn -EINVAL;\r\n}\r\n}\r\nDBG("%s: timeout=%d, divisor=%d, count=%d (%08x)\n",\r\n__func__, timeout, divisor, count, count/divisor);\r\ncount /= divisor;\r\nwdt_count = count;\r\nwtcon = readl(wdt_base + S3C2410_WTCON);\r\nwtcon &= ~S3C2410_WTCON_PRESCALE_MASK;\r\nwtcon |= S3C2410_WTCON_PRESCALE(divisor-1);\r\nwritel(count, wdt_base + S3C2410_WTDAT);\r\nwritel(wtcon, wdt_base + S3C2410_WTCON);\r\nwdd->timeout = (count * divisor) / freq;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t s3c2410wdt_irq(int irqno, void *param)\r\n{\r\ndev_info(wdt_dev, "watchdog timer expired (irq)\n");\r\ns3c2410wdt_keepalive(&s3c2410_wdd);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c2410wdt_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nint ret;\r\nif (!s3c2410wdt_is_running())\r\ngoto done;\r\nif (val == CPUFREQ_PRECHANGE) {\r\ns3c2410wdt_keepalive(&s3c2410_wdd);\r\n} else if (val == CPUFREQ_POSTCHANGE) {\r\ns3c2410wdt_stop(&s3c2410_wdd);\r\nret = s3c2410wdt_set_heartbeat(&s3c2410_wdd, s3c2410_wdd.timeout);\r\nif (ret >= 0)\r\ns3c2410wdt_start(&s3c2410_wdd);\r\nelse\r\ngoto err;\r\n}\r\ndone:\r\nreturn 0;\r\nerr:\r\ndev_err(wdt_dev, "cannot set new value for timeout %d\n",\r\ns3c2410_wdd.timeout);\r\nreturn ret;\r\n}\r\nstatic inline int s3c2410wdt_cpufreq_register(void)\r\n{\r\nreturn cpufreq_register_notifier(&s3c2410wdt_cpufreq_transition_nb,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline void s3c2410wdt_cpufreq_deregister(void)\r\n{\r\ncpufreq_unregister_notifier(&s3c2410wdt_cpufreq_transition_nb,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline int s3c2410wdt_cpufreq_register(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void s3c2410wdt_cpufreq_deregister(void)\r\n{\r\n}\r\nstatic int __devinit s3c2410wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev;\r\nunsigned int wtcon;\r\nint started = 0;\r\nint ret;\r\nint size;\r\nDBG("%s: probe=%p\n", __func__, pdev);\r\ndev = &pdev->dev;\r\nwdt_dev = &pdev->dev;\r\nwdt_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (wdt_mem == NULL) {\r\ndev_err(dev, "no memory resource specified\n");\r\nreturn -ENOENT;\r\n}\r\nwdt_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (wdt_irq == NULL) {\r\ndev_err(dev, "no irq resource specified\n");\r\nret = -ENOENT;\r\ngoto err;\r\n}\r\nsize = resource_size(wdt_mem);\r\nif (!request_mem_region(wdt_mem->start, size, pdev->name)) {\r\ndev_err(dev, "failed to get memory region\n");\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nwdt_base = ioremap(wdt_mem->start, size);\r\nif (wdt_base == NULL) {\r\ndev_err(dev, "failed to ioremap() region\n");\r\nret = -EINVAL;\r\ngoto err_req;\r\n}\r\nDBG("probe: mapped wdt_base=%p\n", wdt_base);\r\nwdt_clock = clk_get(&pdev->dev, "watchdog");\r\nif (IS_ERR(wdt_clock)) {\r\ndev_err(dev, "failed to find watchdog clock source\n");\r\nret = PTR_ERR(wdt_clock);\r\ngoto err_map;\r\n}\r\nclk_enable(wdt_clock);\r\nret = s3c2410wdt_cpufreq_register();\r\nif (ret < 0) {\r\npr_err("failed to register cpufreq\n");\r\ngoto err_clk;\r\n}\r\nif (s3c2410wdt_set_heartbeat(&s3c2410_wdd, tmr_margin)) {\r\nstarted = s3c2410wdt_set_heartbeat(&s3c2410_wdd,\r\nCONFIG_S3C2410_WATCHDOG_DEFAULT_TIME);\r\nif (started == 0)\r\ndev_info(dev,\r\n"tmr_margin value out of range, default %d used\n",\r\nCONFIG_S3C2410_WATCHDOG_DEFAULT_TIME);\r\nelse\r\ndev_info(dev, "default timer value is out of range, "\r\n"cannot start\n");\r\n}\r\nret = request_irq(wdt_irq->start, s3c2410wdt_irq, 0, pdev->name, pdev);\r\nif (ret != 0) {\r\ndev_err(dev, "failed to install irq (%d)\n", ret);\r\ngoto err_cpufreq;\r\n}\r\nwatchdog_set_nowayout(&s3c2410_wdd, nowayout);\r\nret = watchdog_register_device(&s3c2410_wdd);\r\nif (ret) {\r\ndev_err(dev, "cannot register watchdog (%d)\n", ret);\r\ngoto err_irq;\r\n}\r\nif (tmr_atboot && started == 0) {\r\ndev_info(dev, "starting watchdog timer\n");\r\ns3c2410wdt_start(&s3c2410_wdd);\r\n} else if (!tmr_atboot) {\r\ns3c2410wdt_stop(&s3c2410_wdd);\r\n}\r\nwtcon = readl(wdt_base + S3C2410_WTCON);\r\ndev_info(dev, "watchdog %sactive, reset %sabled, irq %sabled\n",\r\n(wtcon & S3C2410_WTCON_ENABLE) ? "" : "in",\r\n(wtcon & S3C2410_WTCON_RSTEN) ? "en" : "dis",\r\n(wtcon & S3C2410_WTCON_INTEN) ? "en" : "dis");\r\nreturn 0;\r\nerr_irq:\r\nfree_irq(wdt_irq->start, pdev);\r\nerr_cpufreq:\r\ns3c2410wdt_cpufreq_deregister();\r\nerr_clk:\r\nclk_disable(wdt_clock);\r\nclk_put(wdt_clock);\r\nwdt_clock = NULL;\r\nerr_map:\r\niounmap(wdt_base);\r\nerr_req:\r\nrelease_mem_region(wdt_mem->start, size);\r\nerr:\r\nwdt_irq = NULL;\r\nwdt_mem = NULL;\r\nreturn ret;\r\n}\r\nstatic int __devexit s3c2410wdt_remove(struct platform_device *dev)\r\n{\r\nwatchdog_unregister_device(&s3c2410_wdd);\r\nfree_irq(wdt_irq->start, dev);\r\ns3c2410wdt_cpufreq_deregister();\r\nclk_disable(wdt_clock);\r\nclk_put(wdt_clock);\r\nwdt_clock = NULL;\r\niounmap(wdt_base);\r\nrelease_mem_region(wdt_mem->start, resource_size(wdt_mem));\r\nwdt_irq = NULL;\r\nwdt_mem = NULL;\r\nreturn 0;\r\n}\r\nstatic void s3c2410wdt_shutdown(struct platform_device *dev)\r\n{\r\ns3c2410wdt_stop(&s3c2410_wdd);\r\n}\r\nstatic int s3c2410wdt_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nwtcon_save = readl(wdt_base + S3C2410_WTCON);\r\nwtdat_save = readl(wdt_base + S3C2410_WTDAT);\r\ns3c2410wdt_stop(&s3c2410_wdd);\r\nreturn 0;\r\n}\r\nstatic int s3c2410wdt_resume(struct platform_device *dev)\r\n{\r\nwritel(wtdat_save, wdt_base + S3C2410_WTDAT);\r\nwritel(wtdat_save, wdt_base + S3C2410_WTCNT);\r\nwritel(wtcon_save, wdt_base + S3C2410_WTCON);\r\npr_info("watchdog %sabled\n",\r\n(wtcon_save & S3C2410_WTCON_ENABLE) ? "en" : "dis");\r\nreturn 0;\r\n}
