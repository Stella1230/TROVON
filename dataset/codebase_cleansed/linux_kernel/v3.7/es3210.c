static int __init do_es_probe(struct net_device *dev)\r\n{\r\nunsigned short ioaddr = dev->base_addr;\r\nint irq = dev->irq;\r\nint mem_start = dev->mem_start;\r\nif (ioaddr > 0x1ff)\r\nreturn es_probe1(dev, ioaddr);\r\nelse if (ioaddr > 0)\r\nreturn -ENXIO;\r\nif (!EISA_bus) {\r\n#if ES_DEBUG & ES_D_PROBE\r\nprintk("es3210.c: Not EISA bus. Not probing high ports.\n");\r\n#endif\r\nreturn -ENXIO;\r\n}\r\nfor (ioaddr = 0x1000; ioaddr < 0x9000; ioaddr += 0x1000) {\r\nif (es_probe1(dev, ioaddr) == 0)\r\nreturn 0;\r\ndev->irq = irq;\r\ndev->mem_start = mem_start;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstruct net_device * __init es_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_ei_netdev();\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = do_es_probe(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init es_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nint i, retval;\r\nunsigned long eisa_id;\r\nif (!request_region(ioaddr + ES_SA_PROM, ES_IO_EXTENT, "es3210"))\r\nreturn -ENODEV;\r\n#if ES_DEBUG & ES_D_PROBE\r\nprintk("es3210.c: probe at %#x, ID %#8x\n", ioaddr, inl(ioaddr + ES_ID_PORT));\r\nprintk("es3210.c: config regs: %#x %#x %#x %#x %#x %#x\n",\r\ninb(ioaddr + ES_CFG1), inb(ioaddr + ES_CFG2), inb(ioaddr + ES_CFG3),\r\ninb(ioaddr + ES_CFG4), inb(ioaddr + ES_CFG5), inb(ioaddr + ES_CFG6));\r\n#endif\r\neisa_id = inl(ioaddr + ES_ID_PORT);\r\nif ((eisa_id != ES_EISA_ID1) && (eisa_id != ES_EISA_ID2)) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nfor (i = 0; i < ETH_ALEN ; i++)\r\ndev->dev_addr[i] = inb(ioaddr + ES_SA_PROM + i);\r\nif (dev->dev_addr[0] != ES_ADDR0 ||\r\ndev->dev_addr[1] != ES_ADDR1 ||\r\ndev->dev_addr[2] != ES_ADDR2) {\r\nprintk("es3210.c: card not found %pM (invalid_prefix).\n",\r\ndev->dev_addr);\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nprintk("es3210.c: ES3210 rev. %ld at %#x, node %pM",\r\neisa_id>>24, ioaddr, dev->dev_addr);\r\nif (dev->irq == 0) {\r\nunsigned char hi_irq = inb(ioaddr + ES_CFG2) & 0x07;\r\nunsigned char lo_irq = inb(ioaddr + ES_CFG1) & 0xfe;\r\nif (hi_irq != 0) {\r\ndev->irq = hi_irq_map[hi_irq - 1];\r\n} else {\r\nint i = 0;\r\nwhile (lo_irq > (1<<i)) i++;\r\ndev->irq = lo_irq_map[i];\r\n}\r\nprintk(" using IRQ %d", dev->irq);\r\n#if ES_DEBUG & ES_D_PROBE\r\nprintk("es3210.c: hi_irq %#x, lo_irq %#x, dev->irq = %d\n",\r\nhi_irq, lo_irq, dev->irq);\r\n#endif\r\n} else {\r\nif (dev->irq == 2)\r\ndev->irq = 9;\r\nprintk(" assigning IRQ %d", dev->irq);\r\n}\r\nif (request_irq(dev->irq, ei_interrupt, 0, "es3210", dev)) {\r\nprintk (" unable to get IRQ %d.\n", dev->irq);\r\nretval = -EAGAIN;\r\ngoto out;\r\n}\r\nif (dev->mem_start == 0) {\r\nunsigned char mem_enabled = inb(ioaddr + ES_CFG2) & 0xc0;\r\nunsigned char mem_bits = inb(ioaddr + ES_CFG3) & 0x07;\r\nif (mem_enabled != 0x80) {\r\nprintk(" shared mem disabled - giving up\n");\r\nretval = -ENXIO;\r\ngoto out1;\r\n}\r\ndev->mem_start = 0xC0000 + mem_bits*0x4000;\r\nprintk(" using ");\r\n} else {\r\nprintk(" assigning ");\r\n}\r\nei_status.mem = ioremap(dev->mem_start, (ES_STOP_PG - ES_START_PG)*256);\r\nif (!ei_status.mem) {\r\nprintk("ioremap failed - giving up\n");\r\nretval = -ENXIO;\r\ngoto out1;\r\n}\r\ndev->mem_end = dev->mem_start + (ES_STOP_PG - ES_START_PG)*256;\r\nprintk("mem %#lx-%#lx\n", dev->mem_start, dev->mem_end-1);\r\n#if ES_DEBUG & ES_D_PROBE\r\nif (inb(ioaddr + ES_CFG5))\r\nprintk("es3210: Warning - DMA channel enabled, but not used here.\n");\r\n#endif\r\ndev->base_addr = ioaddr + ES_NIC_OFFSET;\r\nei_status.name = "ES3210";\r\nei_status.tx_start_page = ES_START_PG;\r\nei_status.rx_start_page = ES_START_PG + TX_PAGES;\r\nei_status.stop_page = ES_STOP_PG;\r\nei_status.word16 = 1;\r\nif (ei_debug > 0)\r\nprintk(version);\r\nei_status.reset_8390 = &es_reset_8390;\r\nei_status.block_input = &es_block_input;\r\nei_status.block_output = &es_block_output;\r\nei_status.get_8390_hdr = &es_get_8390_hdr;\r\ndev->netdev_ops = &ei_netdev_ops;\r\nNS8390_init(dev, 0);\r\nretval = register_netdev(dev);\r\nif (retval)\r\ngoto out1;\r\nreturn 0;\r\nout1:\r\nfree_irq(dev->irq, dev);\r\nout:\r\nrelease_region(ioaddr + ES_SA_PROM, ES_IO_EXTENT);\r\nreturn retval;\r\n}\r\nstatic void es_reset_8390(struct net_device *dev)\r\n{\r\nunsigned short ioaddr = dev->base_addr;\r\nunsigned long end;\r\noutb(0x04, ioaddr + ES_RESET_PORT);\r\nif (ei_debug > 1) printk("%s: resetting the ES3210...", dev->name);\r\nend = jiffies + 2*HZ/100;\r\nwhile ((signed)(end - jiffies) > 0) continue;\r\nei_status.txing = 0;\r\noutb(0x01, ioaddr + ES_RESET_PORT);\r\nif (ei_debug > 1) printk("reset done\n");\r\n}\r\nstatic void\r\nes_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nvoid __iomem *hdr_start = ei_status.mem + ((ring_page - ES_START_PG)<<8);\r\nmemcpy_fromio(hdr, hdr_start, sizeof(struct e8390_pkt_hdr));\r\nhdr->count = (hdr->count + 3) & ~3;\r\n}\r\nstatic void es_block_input(struct net_device *dev, int count, struct sk_buff *skb,\r\nint ring_offset)\r\n{\r\nvoid __iomem *xfer_start = ei_status.mem + ring_offset - ES_START_PG*256;\r\nif (ring_offset + count > ES_STOP_PG*256) {\r\nint semi_count = ES_STOP_PG*256 - ring_offset;\r\nmemcpy_fromio(skb->data, xfer_start, semi_count);\r\ncount -= semi_count;\r\nmemcpy_fromio(skb->data + semi_count, ei_status.mem, count);\r\n} else {\r\nmemcpy_fromio(skb->data, xfer_start, count);\r\n}\r\n}\r\nstatic void es_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, int start_page)\r\n{\r\nvoid __iomem *shmem = ei_status.mem + ((start_page - ES_START_PG)<<8);\r\ncount = (count + 3) & ~3;\r\nmemcpy_toio(shmem, buf, count);\r\n}\r\nint __init init_module(void)\r\n{\r\nstruct net_device *dev;\r\nint this_dev, found = 0;\r\nfor (this_dev = 0; this_dev < MAX_ES_CARDS; this_dev++) {\r\nif (io[this_dev] == 0 && this_dev != 0)\r\nbreak;\r\ndev = alloc_ei_netdev();\r\nif (!dev)\r\nbreak;\r\ndev->irq = irq[this_dev];\r\ndev->base_addr = io[this_dev];\r\ndev->mem_start = mem[this_dev];\r\nif (do_es_probe(dev) == 0) {\r\ndev_es3210[found++] = dev;\r\ncontinue;\r\n}\r\nfree_netdev(dev);\r\nprintk(KERN_WARNING "es3210.c: No es3210 card found (i/o = 0x%x).\n", io[this_dev]);\r\nbreak;\r\n}\r\nif (found)\r\nreturn 0;\r\nreturn -ENXIO;\r\n}\r\nstatic void cleanup_card(struct net_device *dev)\r\n{\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr, ES_IO_EXTENT);\r\niounmap(ei_status.mem);\r\n}\r\nvoid __exit\r\ncleanup_module(void)\r\n{\r\nint this_dev;\r\nfor (this_dev = 0; this_dev < MAX_ES_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_es3210[this_dev];\r\nif (dev) {\r\nunregister_netdev(dev);\r\ncleanup_card(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
