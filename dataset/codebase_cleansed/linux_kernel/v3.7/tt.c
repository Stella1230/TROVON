bool iwl_tt_is_low_power_state(struct iwl_priv *priv)\r\n{\r\nstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\r\nif (tt->state >= IWL_TI_1)\r\nreturn true;\r\nreturn false;\r\n}\r\nu8 iwl_tt_current_power_mode(struct iwl_priv *priv)\r\n{\r\nstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\r\nreturn tt->tt_power_mode;\r\n}\r\nbool iwl_ht_enabled(struct iwl_priv *priv)\r\n{\r\nstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\r\nstruct iwl_tt_restriction *restriction;\r\nif (!priv->thermal_throttle.advanced_tt)\r\nreturn true;\r\nrestriction = tt->restriction + tt->state;\r\nreturn restriction->is_ht;\r\n}\r\nstatic bool iwl_within_ct_kill_margin(struct iwl_priv *priv)\r\n{\r\ns32 temp = priv->temperature;\r\nbool within_margin = false;\r\nif (!priv->thermal_throttle.advanced_tt)\r\nwithin_margin = ((temp + IWL_TT_CT_KILL_MARGIN) >=\r\nCT_KILL_THRESHOLD_LEGACY) ? true : false;\r\nelse\r\nwithin_margin = ((temp + IWL_TT_CT_KILL_MARGIN) >=\r\nCT_KILL_THRESHOLD) ? true : false;\r\nreturn within_margin;\r\n}\r\nbool iwl_check_for_ct_kill(struct iwl_priv *priv)\r\n{\r\nbool is_ct_kill = false;\r\nif (iwl_within_ct_kill_margin(priv)) {\r\niwl_tt_enter_ct_kill(priv);\r\nis_ct_kill = true;\r\n}\r\nreturn is_ct_kill;\r\n}\r\nenum iwl_antenna_ok iwl_tx_ant_restriction(struct iwl_priv *priv)\r\n{\r\nstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\r\nstruct iwl_tt_restriction *restriction;\r\nif (!priv->thermal_throttle.advanced_tt)\r\nreturn IWL_ANT_OK_MULTI;\r\nrestriction = tt->restriction + tt->state;\r\nreturn restriction->tx_stream;\r\n}\r\nenum iwl_antenna_ok iwl_rx_ant_restriction(struct iwl_priv *priv)\r\n{\r\nstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\r\nstruct iwl_tt_restriction *restriction;\r\nif (!priv->thermal_throttle.advanced_tt)\r\nreturn IWL_ANT_OK_MULTI;\r\nrestriction = tt->restriction + tt->state;\r\nreturn restriction->rx_stream;\r\n}\r\nstatic void iwl_tt_check_exit_ct_kill(unsigned long data)\r\n{\r\nstruct iwl_priv *priv = (struct iwl_priv *)data;\r\nstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\r\nunsigned long flags;\r\nif (test_bit(STATUS_EXIT_PENDING, &priv->status))\r\nreturn;\r\nif (tt->state == IWL_TI_CT_KILL) {\r\nif (priv->thermal_throttle.ct_kill_toggle) {\r\niwl_write32(priv->trans, CSR_UCODE_DRV_GP1_CLR,\r\nCSR_UCODE_DRV_GP1_REG_BIT_CT_KILL_EXIT);\r\npriv->thermal_throttle.ct_kill_toggle = false;\r\n} else {\r\niwl_write32(priv->trans, CSR_UCODE_DRV_GP1_SET,\r\nCSR_UCODE_DRV_GP1_REG_BIT_CT_KILL_EXIT);\r\npriv->thermal_throttle.ct_kill_toggle = true;\r\n}\r\niwl_read32(priv->trans, CSR_UCODE_DRV_GP1);\r\nspin_lock_irqsave(&priv->trans->reg_lock, flags);\r\nif (likely(iwl_grab_nic_access(priv->trans)))\r\niwl_release_nic_access(priv->trans);\r\nspin_unlock_irqrestore(&priv->trans->reg_lock, flags);\r\nIWL_DEBUG_TEMP(priv, "schedule ct_kill exit timer\n");\r\nmod_timer(&priv->thermal_throttle.ct_kill_exit_tm,\r\njiffies + CT_KILL_EXIT_DURATION * HZ);\r\n}\r\n}\r\nstatic void iwl_perform_ct_kill_task(struct iwl_priv *priv,\r\nbool stop)\r\n{\r\nif (stop) {\r\nIWL_DEBUG_TEMP(priv, "Stop all queues\n");\r\nif (priv->mac80211_registered)\r\nieee80211_stop_queues(priv->hw);\r\nIWL_DEBUG_TEMP(priv,\r\n"Schedule 5 seconds CT_KILL Timer\n");\r\nmod_timer(&priv->thermal_throttle.ct_kill_exit_tm,\r\njiffies + CT_KILL_EXIT_DURATION * HZ);\r\n} else {\r\nIWL_DEBUG_TEMP(priv, "Wake all queues\n");\r\nif (priv->mac80211_registered)\r\nieee80211_wake_queues(priv->hw);\r\n}\r\n}\r\nstatic void iwl_tt_ready_for_ct_kill(unsigned long data)\r\n{\r\nstruct iwl_priv *priv = (struct iwl_priv *)data;\r\nstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\r\nif (test_bit(STATUS_EXIT_PENDING, &priv->status))\r\nreturn;\r\nif (tt->state != IWL_TI_CT_KILL) {\r\nIWL_DEBUG_TEMP(priv, "entering CT_KILL state when "\r\n"temperature timer expired\n");\r\ntt->state = IWL_TI_CT_KILL;\r\nset_bit(STATUS_CT_KILL, &priv->status);\r\niwl_perform_ct_kill_task(priv, true);\r\n}\r\n}\r\nstatic void iwl_prepare_ct_kill_task(struct iwl_priv *priv)\r\n{\r\nIWL_DEBUG_TEMP(priv, "Prepare to enter IWL_TI_CT_KILL\n");\r\niwl_send_statistics_request(priv, CMD_SYNC, false);\r\nmod_timer(&priv->thermal_throttle.ct_kill_waiting_tm,\r\njiffies + msecs_to_jiffies(CT_KILL_WAITING_DURATION));\r\n}\r\nstatic void iwl_legacy_tt_handler(struct iwl_priv *priv, s32 temp, bool force)\r\n{\r\nstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\r\nenum iwl_tt_state old_state;\r\n#ifdef CONFIG_IWLWIFI_DEBUG\r\nif ((tt->tt_previous_temp) &&\r\n(temp > tt->tt_previous_temp) &&\r\n((temp - tt->tt_previous_temp) >\r\nIWL_TT_INCREASE_MARGIN)) {\r\nIWL_DEBUG_TEMP(priv,\r\n"Temperature increase %d degree Celsius\n",\r\n(temp - tt->tt_previous_temp));\r\n}\r\n#endif\r\nold_state = tt->state;\r\nif (temp >= IWL_MINIMAL_POWER_THRESHOLD)\r\ntt->state = IWL_TI_CT_KILL;\r\nelse if (temp >= IWL_REDUCED_PERFORMANCE_THRESHOLD_2)\r\ntt->state = IWL_TI_2;\r\nelse if (temp >= IWL_REDUCED_PERFORMANCE_THRESHOLD_1)\r\ntt->state = IWL_TI_1;\r\nelse\r\ntt->state = IWL_TI_0;\r\n#ifdef CONFIG_IWLWIFI_DEBUG\r\ntt->tt_previous_temp = temp;\r\n#endif\r\ndel_timer_sync(&priv->thermal_throttle.ct_kill_waiting_tm);\r\nif (tt->state != old_state) {\r\nswitch (tt->state) {\r\ncase IWL_TI_0:\r\nbreak;\r\ncase IWL_TI_1:\r\ntt->tt_power_mode = IWL_POWER_INDEX_3;\r\nbreak;\r\ncase IWL_TI_2:\r\ntt->tt_power_mode = IWL_POWER_INDEX_4;\r\nbreak;\r\ndefault:\r\ntt->tt_power_mode = IWL_POWER_INDEX_5;\r\nbreak;\r\n}\r\nmutex_lock(&priv->mutex);\r\nif (old_state == IWL_TI_CT_KILL)\r\nclear_bit(STATUS_CT_KILL, &priv->status);\r\nif (tt->state != IWL_TI_CT_KILL &&\r\niwl_power_update_mode(priv, true)) {\r\nif (old_state == IWL_TI_CT_KILL)\r\nset_bit(STATUS_CT_KILL, &priv->status);\r\ntt->state = old_state;\r\nIWL_ERR(priv, "Cannot update power mode, "\r\n"TT state not updated\n");\r\n} else {\r\nif (tt->state == IWL_TI_CT_KILL) {\r\nif (force) {\r\nset_bit(STATUS_CT_KILL, &priv->status);\r\niwl_perform_ct_kill_task(priv, true);\r\n} else {\r\niwl_prepare_ct_kill_task(priv);\r\ntt->state = old_state;\r\n}\r\n} else if (old_state == IWL_TI_CT_KILL &&\r\ntt->state != IWL_TI_CT_KILL)\r\niwl_perform_ct_kill_task(priv, false);\r\nIWL_DEBUG_TEMP(priv, "Temperature state changed %u\n",\r\ntt->state);\r\nIWL_DEBUG_TEMP(priv, "Power Index change to %u\n",\r\ntt->tt_power_mode);\r\n}\r\nmutex_unlock(&priv->mutex);\r\n}\r\n}\r\nstatic void iwl_advance_tt_handler(struct iwl_priv *priv, s32 temp, bool force)\r\n{\r\nstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\r\nint i;\r\nbool changed = false;\r\nenum iwl_tt_state old_state;\r\nstruct iwl_tt_trans *transaction;\r\nold_state = tt->state;\r\nfor (i = 0; i < IWL_TI_STATE_MAX - 1; i++) {\r\ntransaction = tt->transaction +\r\n((old_state * (IWL_TI_STATE_MAX - 1)) + i);\r\nif (temp >= transaction->tt_low &&\r\ntemp <= transaction->tt_high) {\r\n#ifdef CONFIG_IWLWIFI_DEBUG\r\nif ((tt->tt_previous_temp) &&\r\n(temp > tt->tt_previous_temp) &&\r\n((temp - tt->tt_previous_temp) >\r\nIWL_TT_INCREASE_MARGIN)) {\r\nIWL_DEBUG_TEMP(priv,\r\n"Temperature increase %d "\r\n"degree Celsius\n",\r\n(temp - tt->tt_previous_temp));\r\n}\r\ntt->tt_previous_temp = temp;\r\n#endif\r\nif (old_state !=\r\ntransaction->next_state) {\r\nchanged = true;\r\ntt->state =\r\ntransaction->next_state;\r\n}\r\nbreak;\r\n}\r\n}\r\ndel_timer_sync(&priv->thermal_throttle.ct_kill_waiting_tm);\r\nif (changed) {\r\nif (tt->state >= IWL_TI_1) {\r\ntt->tt_power_mode = IWL_POWER_INDEX_5;\r\nif (!iwl_ht_enabled(priv)) {\r\nstruct iwl_rxon_context *ctx;\r\nfor_each_context(priv, ctx) {\r\nstruct iwl_rxon_cmd *rxon;\r\nrxon = &ctx->staging;\r\nrxon->flags &= ~(\r\nRXON_FLG_CHANNEL_MODE_MSK |\r\nRXON_FLG_CTRL_CHANNEL_LOC_HI_MSK |\r\nRXON_FLG_HT40_PROT_MSK |\r\nRXON_FLG_HT_PROT_MSK);\r\n}\r\n} else {\r\niwl_set_rxon_ht(priv, &priv->current_ht_config);\r\n}\r\n} else {\r\niwl_set_rxon_ht(priv, &priv->current_ht_config);\r\n}\r\nmutex_lock(&priv->mutex);\r\nif (old_state == IWL_TI_CT_KILL)\r\nclear_bit(STATUS_CT_KILL, &priv->status);\r\nif (tt->state != IWL_TI_CT_KILL &&\r\niwl_power_update_mode(priv, true)) {\r\nIWL_ERR(priv, "Cannot update power mode, "\r\n"TT state not updated\n");\r\nif (old_state == IWL_TI_CT_KILL)\r\nset_bit(STATUS_CT_KILL, &priv->status);\r\ntt->state = old_state;\r\n} else {\r\nIWL_DEBUG_TEMP(priv,\r\n"Thermal Throttling to new state: %u\n",\r\ntt->state);\r\nif (old_state != IWL_TI_CT_KILL &&\r\ntt->state == IWL_TI_CT_KILL) {\r\nif (force) {\r\nIWL_DEBUG_TEMP(priv,\r\n"Enter IWL_TI_CT_KILL\n");\r\nset_bit(STATUS_CT_KILL, &priv->status);\r\niwl_perform_ct_kill_task(priv, true);\r\n} else {\r\niwl_prepare_ct_kill_task(priv);\r\ntt->state = old_state;\r\n}\r\n} else if (old_state == IWL_TI_CT_KILL &&\r\ntt->state != IWL_TI_CT_KILL) {\r\nIWL_DEBUG_TEMP(priv, "Exit IWL_TI_CT_KILL\n");\r\niwl_perform_ct_kill_task(priv, false);\r\n}\r\n}\r\nmutex_unlock(&priv->mutex);\r\n}\r\n}\r\nstatic void iwl_bg_ct_enter(struct work_struct *work)\r\n{\r\nstruct iwl_priv *priv = container_of(work, struct iwl_priv, ct_enter);\r\nstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\r\nif (test_bit(STATUS_EXIT_PENDING, &priv->status))\r\nreturn;\r\nif (!iwl_is_ready(priv))\r\nreturn;\r\nif (tt->state != IWL_TI_CT_KILL) {\r\nIWL_ERR(priv, "Device reached critical temperature "\r\n"- ucode going to sleep!\n");\r\nif (!priv->thermal_throttle.advanced_tt)\r\niwl_legacy_tt_handler(priv,\r\nIWL_MINIMAL_POWER_THRESHOLD,\r\ntrue);\r\nelse\r\niwl_advance_tt_handler(priv,\r\nCT_KILL_THRESHOLD + 1, true);\r\n}\r\n}\r\nstatic void iwl_bg_ct_exit(struct work_struct *work)\r\n{\r\nstruct iwl_priv *priv = container_of(work, struct iwl_priv, ct_exit);\r\nstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\r\nif (test_bit(STATUS_EXIT_PENDING, &priv->status))\r\nreturn;\r\nif (!iwl_is_ready(priv))\r\nreturn;\r\ndel_timer_sync(&priv->thermal_throttle.ct_kill_exit_tm);\r\nif (tt->state == IWL_TI_CT_KILL) {\r\nIWL_ERR(priv,\r\n"Device temperature below critical"\r\n"- ucode awake!\n");\r\npriv->temperature = 0;\r\nif (!priv->thermal_throttle.advanced_tt)\r\niwl_legacy_tt_handler(priv,\r\nIWL_REDUCED_PERFORMANCE_THRESHOLD_2,\r\ntrue);\r\nelse\r\niwl_advance_tt_handler(priv, CT_KILL_EXIT_THRESHOLD,\r\ntrue);\r\n}\r\n}\r\nvoid iwl_tt_enter_ct_kill(struct iwl_priv *priv)\r\n{\r\nif (test_bit(STATUS_EXIT_PENDING, &priv->status))\r\nreturn;\r\nIWL_DEBUG_TEMP(priv, "Queueing critical temperature enter.\n");\r\nqueue_work(priv->workqueue, &priv->ct_enter);\r\n}\r\nvoid iwl_tt_exit_ct_kill(struct iwl_priv *priv)\r\n{\r\nif (test_bit(STATUS_EXIT_PENDING, &priv->status))\r\nreturn;\r\nIWL_DEBUG_TEMP(priv, "Queueing critical temperature exit.\n");\r\nqueue_work(priv->workqueue, &priv->ct_exit);\r\n}\r\nstatic void iwl_bg_tt_work(struct work_struct *work)\r\n{\r\nstruct iwl_priv *priv = container_of(work, struct iwl_priv, tt_work);\r\ns32 temp = priv->temperature;\r\nif (test_bit(STATUS_EXIT_PENDING, &priv->status))\r\nreturn;\r\nif (!priv->thermal_throttle.advanced_tt)\r\niwl_legacy_tt_handler(priv, temp, false);\r\nelse\r\niwl_advance_tt_handler(priv, temp, false);\r\n}\r\nvoid iwl_tt_handler(struct iwl_priv *priv)\r\n{\r\nif (test_bit(STATUS_EXIT_PENDING, &priv->status))\r\nreturn;\r\nIWL_DEBUG_TEMP(priv, "Queueing thermal throttling work.\n");\r\nqueue_work(priv->workqueue, &priv->tt_work);\r\n}\r\nvoid iwl_tt_initialize(struct iwl_priv *priv)\r\n{\r\nstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\r\nint size = sizeof(struct iwl_tt_trans) * (IWL_TI_STATE_MAX - 1);\r\nstruct iwl_tt_trans *transaction;\r\nIWL_DEBUG_TEMP(priv, "Initialize Thermal Throttling\n");\r\nmemset(tt, 0, sizeof(struct iwl_tt_mgmt));\r\ntt->state = IWL_TI_0;\r\ninit_timer(&priv->thermal_throttle.ct_kill_exit_tm);\r\npriv->thermal_throttle.ct_kill_exit_tm.data = (unsigned long)priv;\r\npriv->thermal_throttle.ct_kill_exit_tm.function =\r\niwl_tt_check_exit_ct_kill;\r\ninit_timer(&priv->thermal_throttle.ct_kill_waiting_tm);\r\npriv->thermal_throttle.ct_kill_waiting_tm.data =\r\n(unsigned long)priv;\r\npriv->thermal_throttle.ct_kill_waiting_tm.function =\r\niwl_tt_ready_for_ct_kill;\r\nINIT_WORK(&priv->tt_work, iwl_bg_tt_work);\r\nINIT_WORK(&priv->ct_enter, iwl_bg_ct_enter);\r\nINIT_WORK(&priv->ct_exit, iwl_bg_ct_exit);\r\nif (priv->cfg->base_params->adv_thermal_throttle) {\r\nIWL_DEBUG_TEMP(priv, "Advanced Thermal Throttling\n");\r\ntt->restriction = kcalloc(IWL_TI_STATE_MAX,\r\nsizeof(struct iwl_tt_restriction),\r\nGFP_KERNEL);\r\ntt->transaction = kcalloc(IWL_TI_STATE_MAX *\r\n(IWL_TI_STATE_MAX - 1),\r\nsizeof(struct iwl_tt_trans),\r\nGFP_KERNEL);\r\nif (!tt->restriction || !tt->transaction) {\r\nIWL_ERR(priv, "Fallback to Legacy Throttling\n");\r\npriv->thermal_throttle.advanced_tt = false;\r\nkfree(tt->restriction);\r\ntt->restriction = NULL;\r\nkfree(tt->transaction);\r\ntt->transaction = NULL;\r\n} else {\r\ntransaction = tt->transaction +\r\n(IWL_TI_0 * (IWL_TI_STATE_MAX - 1));\r\nmemcpy(transaction, &tt_range_0[0], size);\r\ntransaction = tt->transaction +\r\n(IWL_TI_1 * (IWL_TI_STATE_MAX - 1));\r\nmemcpy(transaction, &tt_range_1[0], size);\r\ntransaction = tt->transaction +\r\n(IWL_TI_2 * (IWL_TI_STATE_MAX - 1));\r\nmemcpy(transaction, &tt_range_2[0], size);\r\ntransaction = tt->transaction +\r\n(IWL_TI_CT_KILL * (IWL_TI_STATE_MAX - 1));\r\nmemcpy(transaction, &tt_range_3[0], size);\r\nsize = sizeof(struct iwl_tt_restriction) *\r\nIWL_TI_STATE_MAX;\r\nmemcpy(tt->restriction,\r\n&restriction_range[0], size);\r\npriv->thermal_throttle.advanced_tt = true;\r\n}\r\n} else {\r\nIWL_DEBUG_TEMP(priv, "Legacy Thermal Throttling\n");\r\npriv->thermal_throttle.advanced_tt = false;\r\n}\r\n}\r\nvoid iwl_tt_exit(struct iwl_priv *priv)\r\n{\r\nstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;\r\ndel_timer_sync(&priv->thermal_throttle.ct_kill_exit_tm);\r\ndel_timer_sync(&priv->thermal_throttle.ct_kill_waiting_tm);\r\ncancel_work_sync(&priv->tt_work);\r\ncancel_work_sync(&priv->ct_enter);\r\ncancel_work_sync(&priv->ct_exit);\r\nif (priv->thermal_throttle.advanced_tt) {\r\nkfree(tt->restriction);\r\ntt->restriction = NULL;\r\nkfree(tt->transaction);\r\ntt->transaction = NULL;\r\n}\r\n}
