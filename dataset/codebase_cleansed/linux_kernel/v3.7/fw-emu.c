int\r\nofftime (unsigned long t, efi_time_t *tp)\r\n{\r\nconst unsigned short int __mon_yday[2][13] =\r\n{\r\n{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },\r\n{ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }\r\n};\r\nlong int days, rem, y;\r\nconst unsigned short int *ip;\r\ndays = t / SECS_PER_DAY;\r\nrem = t % SECS_PER_DAY;\r\nwhile (rem < 0) {\r\nrem += SECS_PER_DAY;\r\n--days;\r\n}\r\nwhile (rem >= SECS_PER_DAY) {\r\nrem -= SECS_PER_DAY;\r\n++days;\r\n}\r\ntp->hour = rem / SECS_PER_HOUR;\r\nrem %= SECS_PER_HOUR;\r\ntp->minute = rem / 60;\r\ntp->second = rem % 60;\r\ny = 1970;\r\n# define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))\r\n# define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))\r\n# define __isleap(year) \\r\n((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))\r\nwhile (days < 0 || days >= (__isleap (y) ? 366 : 365)) {\r\nlong int yg = y + days / 365 - (days % 365 < 0);\r\ndays -= ((yg - y) * 365 + LEAPS_THRU_END_OF (yg - 1)\r\n- LEAPS_THRU_END_OF (y - 1));\r\ny = yg;\r\n}\r\ntp->year = y;\r\nip = __mon_yday[__isleap(y)];\r\nfor (y = 11; days < (long int) ip[y]; --y)\r\ncontinue;\r\ndays -= ip[y];\r\ntp->month = y + 1;\r\ntp->day = days + 1;\r\nreturn 1;\r\n}\r\nstatic efi_status_t\r\nfw_efi_get_time (efi_time_t *tm, efi_time_cap_t *tc)\r\n{\r\n#if defined(CONFIG_IA64_HP_SIM) || defined(CONFIG_IA64_GENERIC)\r\nstruct {\r\nint tv_sec;\r\nint tv_usec;\r\n} tv32bits;\r\nssc((unsigned long) &tv32bits, 0, 0, 0, SSC_GET_TOD);\r\nmemset(tm, 0, sizeof(*tm));\r\nofftime(tv32bits.tv_sec, tm);\r\nif (tc)\r\nmemset(tc, 0, sizeof(*tc));\r\n#else\r\n# error Not implemented yet...\r\n#endif\r\nreturn EFI_SUCCESS;\r\n}\r\nstatic void\r\nefi_reset_system (int reset_type, efi_status_t status, unsigned long data_size, efi_char16_t *data)\r\n{\r\n#if defined(CONFIG_IA64_HP_SIM) || defined(CONFIG_IA64_GENERIC)\r\nssc(status, 0, 0, 0, SSC_EXIT);\r\n#else\r\n# error Not implemented yet...\r\n#endif\r\n}\r\nstatic efi_status_t\r\nefi_unimplemented (void)\r\n{\r\nreturn EFI_UNSUPPORTED;\r\n}\r\nstatic struct sal_ret_values\r\nsal_emulator (long index, unsigned long in1, unsigned long in2,\r\nunsigned long in3, unsigned long in4, unsigned long in5,\r\nunsigned long in6, unsigned long in7)\r\n{\r\nlong r9 = 0;\r\nlong r10 = 0;\r\nlong r11 = 0;\r\nlong status;\r\nstatus = 0;\r\nif (index == SAL_FREQ_BASE) {\r\nif (in1 == SAL_FREQ_BASE_PLATFORM)\r\nr9 = 200000000;\r\nelse if (in1 == SAL_FREQ_BASE_INTERVAL_TIMER) {\r\nr9 = 700000000;\r\n} else if (in1 == SAL_FREQ_BASE_REALTIME_CLOCK)\r\nr9 = 1;\r\nelse\r\nstatus = -1;\r\n} else if (index == SAL_SET_VECTORS) {\r\n;\r\n} else if (index == SAL_GET_STATE_INFO) {\r\n;\r\n} else if (index == SAL_GET_STATE_INFO_SIZE) {\r\n;\r\n} else if (index == SAL_CLEAR_STATE_INFO) {\r\n;\r\n} else if (index == SAL_MC_RENDEZ) {\r\n;\r\n} else if (index == SAL_MC_SET_PARAMS) {\r\n;\r\n} else if (index == SAL_CACHE_FLUSH) {\r\n;\r\n} else if (index == SAL_CACHE_INIT) {\r\n;\r\n#ifdef CONFIG_PCI\r\n} else if (index == SAL_PCI_CONFIG_READ) {\r\noutl(BUILD_CMD(in1), 0xCF8);\r\nif (in2 == 1)\r\nr9 = inb(0xCFC + ((REG_OFFSET(in1) & 3)));\r\nelse if (in2 == 2)\r\nr9 = inw(0xCFC + ((REG_OFFSET(in1) & 2)));\r\nelse\r\nr9 = inl(0xCFC);\r\nstatus = PCIBIOS_SUCCESSFUL;\r\n} else if (index == SAL_PCI_CONFIG_WRITE) {\r\noutl(BUILD_CMD(in1), 0xCF8);\r\nif (in2 == 1)\r\noutb(in3, 0xCFC + ((REG_OFFSET(in1) & 3)));\r\nelse if (in2 == 2)\r\noutw(in3, 0xCFC + ((REG_OFFSET(in1) & 2)));\r\nelse\r\noutl(in3, 0xCFC);\r\nstatus = PCIBIOS_SUCCESSFUL;\r\n#endif\r\n} else if (index == SAL_UPDATE_PAL) {\r\n;\r\n} else {\r\nstatus = -1;\r\n}\r\nreturn ((struct sal_ret_values) {status, r9, r10, r11});\r\n}\r\nstruct ia64_boot_param *\r\nsys_fw_init (const char *args, int arglen)\r\n{\r\nefi_system_table_t *efi_systab;\r\nefi_runtime_services_t *efi_runtime;\r\nefi_config_table_t *efi_tables;\r\nstruct ia64_sal_systab *sal_systab;\r\nefi_memory_desc_t *efi_memmap, *md;\r\nunsigned long *pal_desc, *sal_desc;\r\nstruct ia64_sal_desc_entry_point *sal_ed;\r\nstruct ia64_boot_param *bp;\r\nunsigned char checksum = 0;\r\nchar *cp, *cmd_line;\r\nint i = 0;\r\n# define MAKE_MD(typ, attr, start, end) \\r\ndo { \\r\nmd = efi_memmap + i++; \\r\nmd->type = typ; \\r\nmd->pad = 0; \\r\nmd->phys_addr = start; \\r\nmd->virt_addr = 0; \\r\nmd->num_pages = (end - start) >> 12; \\r\nmd->attribute = attr; \\r\n} while (0)\r\nmemset(fw_mem, 0, sizeof(fw_mem));\r\npal_desc = (unsigned long *) &pal_emulator_static;\r\nsal_desc = (unsigned long *) &sal_emulator;\r\ncp = fw_mem;\r\nefi_systab = (void *) cp; cp += sizeof(*efi_systab);\r\nefi_runtime = (void *) cp; cp += sizeof(*efi_runtime);\r\nefi_tables = (void *) cp; cp += sizeof(*efi_tables);\r\nsal_systab = (void *) cp; cp += sizeof(*sal_systab);\r\nsal_ed = (void *) cp; cp += sizeof(*sal_ed);\r\nefi_memmap = (void *) cp; cp += NUM_MEM_DESCS*sizeof(*efi_memmap);\r\nbp = (void *) cp; cp += sizeof(*bp);\r\ncmd_line = (void *) cp;\r\nif (args) {\r\nif (arglen >= 1024)\r\narglen = 1023;\r\nmemcpy(cmd_line, args, arglen);\r\n} else {\r\narglen = 0;\r\n}\r\ncmd_line[arglen] = '\0';\r\nmemset(efi_systab, 0, sizeof(*efi_systab));\r\nefi_systab->hdr.signature = EFI_SYSTEM_TABLE_SIGNATURE;\r\nefi_systab->hdr.revision = ((1 << 16) | 00);\r\nefi_systab->hdr.headersize = sizeof(efi_systab->hdr);\r\nefi_systab->fw_vendor = __pa("H\0e\0w\0l\0e\0t\0t\0-\0P\0a\0c\0k\0a\0r\0d\0\0");\r\nefi_systab->fw_revision = 1;\r\nefi_systab->runtime = (void *) __pa(efi_runtime);\r\nefi_systab->nr_tables = 1;\r\nefi_systab->tables = __pa(efi_tables);\r\nefi_runtime->hdr.signature = EFI_RUNTIME_SERVICES_SIGNATURE;\r\nefi_runtime->hdr.revision = EFI_RUNTIME_SERVICES_REVISION;\r\nefi_runtime->hdr.headersize = sizeof(efi_runtime->hdr);\r\nefi_runtime->get_time = __pa(&fw_efi_get_time);\r\nefi_runtime->set_time = __pa(&efi_unimplemented);\r\nefi_runtime->get_wakeup_time = __pa(&efi_unimplemented);\r\nefi_runtime->set_wakeup_time = __pa(&efi_unimplemented);\r\nefi_runtime->set_virtual_address_map = __pa(&efi_unimplemented);\r\nefi_runtime->get_variable = __pa(&efi_unimplemented);\r\nefi_runtime->get_next_variable = __pa(&efi_unimplemented);\r\nefi_runtime->set_variable = __pa(&efi_unimplemented);\r\nefi_runtime->get_next_high_mono_count = __pa(&efi_unimplemented);\r\nefi_runtime->reset_system = __pa(&efi_reset_system);\r\nefi_tables->guid = SAL_SYSTEM_TABLE_GUID;\r\nefi_tables->table = __pa(sal_systab);\r\nmemcpy(sal_systab->signature, "SST_", 4);\r\nsal_systab->size = sizeof(*sal_systab);\r\nsal_systab->sal_rev_minor = 1;\r\nsal_systab->sal_rev_major = 0;\r\nsal_systab->entry_count = 1;\r\n#ifdef CONFIG_IA64_GENERIC\r\nstrcpy(sal_systab->oem_id, "Generic");\r\nstrcpy(sal_systab->product_id, "IA-64 system");\r\n#endif\r\n#ifdef CONFIG_IA64_HP_SIM\r\nstrcpy(sal_systab->oem_id, "Hewlett-Packard");\r\nstrcpy(sal_systab->product_id, "HP-simulator");\r\n#endif\r\nsal_ed->type = SAL_DESC_ENTRY_POINT;\r\nsal_ed->pal_proc = __pa(pal_desc[0]);\r\nsal_ed->sal_proc = __pa(sal_desc[0]);\r\nsal_ed->gp = __pa(sal_desc[1]);\r\nfor (cp = (char *) sal_systab; cp < (char *) efi_memmap; ++cp)\r\nchecksum += *cp;\r\nsal_systab->checksum = -checksum;\r\n#if SIMPLE_MEMMAP\r\nMAKE_MD(EFI_BOOT_SERVICES_DATA, EFI_MEMORY_WB, 0*MB, 1*MB);\r\nMAKE_MD(EFI_PAL_CODE, EFI_MEMORY_WB, 1*MB, 2*MB);\r\nMAKE_MD(EFI_CONVENTIONAL_MEMORY, EFI_MEMORY_WB, 2*MB, 130*MB);\r\nMAKE_MD(EFI_CONVENTIONAL_MEMORY, EFI_MEMORY_WB, 4096*MB, 4128*MB);\r\n#else\r\nMAKE_MD( 4, 0x9, 0x0000000000000000, 0x0000000000001000);\r\nMAKE_MD( 7, 0x9, 0x0000000000001000, 0x000000000008a000);\r\nMAKE_MD( 4, 0x9, 0x000000000008a000, 0x00000000000a0000);\r\nMAKE_MD( 5, 0x8000000000000009, 0x00000000000c0000, 0x0000000000100000);\r\nMAKE_MD( 7, 0x9, 0x0000000000100000, 0x0000000004400000);\r\nMAKE_MD( 2, 0x9, 0x0000000004400000, 0x0000000004be5000);\r\nMAKE_MD( 7, 0x9, 0x0000000004be5000, 0x000000007f77e000);\r\nMAKE_MD( 6, 0x8000000000000009, 0x000000007f77e000, 0x000000007fb94000);\r\nMAKE_MD( 6, 0x8000000000000009, 0x000000007fb94000, 0x000000007fb95000);\r\nMAKE_MD( 6, 0x8000000000000009, 0x000000007fb95000, 0x000000007fc00000);\r\nMAKE_MD(13, 0x8000000000000009, 0x000000007fc00000, 0x000000007fc3a000);\r\nMAKE_MD( 7, 0x9, 0x000000007fc3a000, 0x000000007fea0000);\r\nMAKE_MD( 5, 0x8000000000000009, 0x000000007fea0000, 0x000000007fea8000);\r\nMAKE_MD( 7, 0x9, 0x000000007fea8000, 0x000000007feab000);\r\nMAKE_MD( 5, 0x8000000000000009, 0x000000007feab000, 0x000000007ffff000);\r\nMAKE_MD( 7, 0x9, 0x00000000ff400000, 0x0000000104000000);\r\n#endif\r\nbp->efi_systab = __pa(&fw_mem);\r\nbp->efi_memmap = __pa(efi_memmap);\r\nbp->efi_memmap_size = NUM_MEM_DESCS*sizeof(efi_memory_desc_t);\r\nbp->efi_memdesc_size = sizeof(efi_memory_desc_t);\r\nbp->efi_memdesc_version = 1;\r\nbp->command_line = __pa(cmd_line);\r\nbp->console_info.num_cols = 80;\r\nbp->console_info.num_rows = 25;\r\nbp->console_info.orig_x = 0;\r\nbp->console_info.orig_y = 24;\r\nbp->fpswa = 0;\r\nreturn bp;\r\n}
