static int nx_xcbc_set_key(struct crypto_shash *desc,\r\nconst u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct nx_crypto_ctx *nx_ctx = crypto_shash_ctx(desc);\r\nswitch (key_len) {\r\ncase AES_KEYSIZE_128:\r\nnx_ctx->ap = &nx_ctx->props[NX_PROPS_AES_128];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmemcpy(nx_ctx->priv.xcbc.key, in_key, key_len);\r\nreturn 0;\r\n}\r\nstatic int nx_xcbc_init(struct shash_desc *desc)\r\n{\r\nstruct xcbc_state *sctx = shash_desc_ctx(desc);\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&desc->tfm->base);\r\nstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\r\nstruct nx_sg *out_sg;\r\nnx_ctx_init(nx_ctx, HCOP_FC_AES);\r\nmemset(sctx, 0, sizeof *sctx);\r\nNX_CPB_SET_KEY_SIZE(csbcpb, NX_KS_AES_128);\r\ncsbcpb->cpb.hdr.mode = NX_MODE_AES_XCBC_MAC;\r\nmemcpy(csbcpb->cpb.aes_xcbc.key, nx_ctx->priv.xcbc.key, AES_BLOCK_SIZE);\r\nmemset(nx_ctx->priv.xcbc.key, 0, sizeof *nx_ctx->priv.xcbc.key);\r\nout_sg = nx_build_sg_list(nx_ctx->out_sg, (u8 *)sctx->state,\r\nAES_BLOCK_SIZE, nx_ctx->ap->sglen);\r\nnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\r\nreturn 0;\r\n}\r\nstatic int nx_xcbc_update(struct shash_desc *desc,\r\nconst u8 *data,\r\nunsigned int len)\r\n{\r\nstruct xcbc_state *sctx = shash_desc_ctx(desc);\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&desc->tfm->base);\r\nstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\r\nstruct nx_sg *in_sg;\r\nu32 to_process, leftover;\r\nint rc = 0;\r\nif (NX_CPB_FDM(csbcpb) & NX_FDM_CONTINUATION) {\r\nmemcpy(csbcpb->cpb.aes_xcbc.cv,\r\ncsbcpb->cpb.aes_xcbc.out_cv_mac, AES_BLOCK_SIZE);\r\n}\r\nif (len + sctx->count <= AES_BLOCK_SIZE) {\r\nmemcpy(sctx->buffer + sctx->count, data, len);\r\nsctx->count += len;\r\ngoto out;\r\n}\r\nto_process = (sctx->count + len) & ~(AES_BLOCK_SIZE - 1);\r\nleftover = (sctx->count + len) & (AES_BLOCK_SIZE - 1);\r\nif (!leftover) {\r\nto_process -= AES_BLOCK_SIZE;\r\nleftover = AES_BLOCK_SIZE;\r\n}\r\nif (sctx->count) {\r\nin_sg = nx_build_sg_list(nx_ctx->in_sg, sctx->buffer,\r\nsctx->count, nx_ctx->ap->sglen);\r\nin_sg = nx_build_sg_list(in_sg, (u8 *)data,\r\nto_process - sctx->count,\r\nnx_ctx->ap->sglen);\r\nnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) *\r\nsizeof(struct nx_sg);\r\n} else {\r\nin_sg = nx_build_sg_list(nx_ctx->in_sg, (u8 *)data, to_process,\r\nnx_ctx->ap->sglen);\r\nnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) *\r\nsizeof(struct nx_sg);\r\n}\r\nNX_CPB_FDM(csbcpb) |= NX_FDM_INTERMEDIATE;\r\nif (!nx_ctx->op.inlen || !nx_ctx->op.outlen) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = nx_hcall_sync(nx_ctx, &nx_ctx->op,\r\ndesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP);\r\nif (rc)\r\ngoto out;\r\natomic_inc(&(nx_ctx->stats->aes_ops));\r\nmemcpy(sctx->buffer, data + len - leftover, leftover);\r\nsctx->count = leftover;\r\nNX_CPB_FDM(csbcpb) |= NX_FDM_CONTINUATION;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int nx_xcbc_final(struct shash_desc *desc, u8 *out)\r\n{\r\nstruct xcbc_state *sctx = shash_desc_ctx(desc);\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&desc->tfm->base);\r\nstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\r\nstruct nx_sg *in_sg, *out_sg;\r\nint rc = 0;\r\nif (NX_CPB_FDM(csbcpb) & NX_FDM_CONTINUATION) {\r\nmemcpy(csbcpb->cpb.aes_xcbc.cv,\r\ncsbcpb->cpb.aes_xcbc.out_cv_mac, AES_BLOCK_SIZE);\r\n} else if (sctx->count == 0) {\r\nu8 data[] = { 0x75, 0xf0, 0x25, 0x1d, 0x52, 0x8a, 0xc0, 0x1c,\r\n0x45, 0x73, 0xdf, 0xd5, 0x84, 0xd7, 0x9f, 0x29 };\r\nmemcpy(out, data, sizeof(data));\r\ngoto out;\r\n}\r\nNX_CPB_FDM(csbcpb) &= ~NX_FDM_INTERMEDIATE;\r\nin_sg = nx_build_sg_list(nx_ctx->in_sg, (u8 *)sctx->buffer,\r\nsctx->count, nx_ctx->ap->sglen);\r\nout_sg = nx_build_sg_list(nx_ctx->out_sg, out, AES_BLOCK_SIZE,\r\nnx_ctx->ap->sglen);\r\nnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) * sizeof(struct nx_sg);\r\nnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\r\nif (!nx_ctx->op.outlen) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = nx_hcall_sync(nx_ctx, &nx_ctx->op,\r\ndesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP);\r\nif (rc)\r\ngoto out;\r\natomic_inc(&(nx_ctx->stats->aes_ops));\r\nmemcpy(out, csbcpb->cpb.aes_xcbc.out_cv_mac, AES_BLOCK_SIZE);\r\nout:\r\nreturn rc;\r\n}
