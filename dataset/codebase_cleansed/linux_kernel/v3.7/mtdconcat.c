static int\r\nconcat_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t * retlen, u_char * buf)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nint ret = 0, err;\r\nint i;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nstruct mtd_info *subdev = concat->subdev[i];\r\nsize_t size, retsize;\r\nif (from >= subdev->size) {\r\nsize = 0;\r\nfrom -= subdev->size;\r\ncontinue;\r\n}\r\nif (from + len > subdev->size)\r\nsize = subdev->size - from;\r\nelse\r\nsize = len;\r\nerr = mtd_read(subdev, from, size, &retsize, buf);\r\nif (unlikely(err)) {\r\nif (mtd_is_eccerr(err)) {\r\nmtd->ecc_stats.failed++;\r\nret = err;\r\n} else if (mtd_is_bitflip(err)) {\r\nmtd->ecc_stats.corrected++;\r\nif (!ret)\r\nret = err;\r\n} else\r\nreturn err;\r\n}\r\n*retlen += retsize;\r\nlen -= size;\r\nif (len == 0)\r\nreturn ret;\r\nbuf += size;\r\nfrom = 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nconcat_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t * retlen, const u_char * buf)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nint err = -EINVAL;\r\nint i;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nstruct mtd_info *subdev = concat->subdev[i];\r\nsize_t size, retsize;\r\nif (to >= subdev->size) {\r\nsize = 0;\r\nto -= subdev->size;\r\ncontinue;\r\n}\r\nif (to + len > subdev->size)\r\nsize = subdev->size - to;\r\nelse\r\nsize = len;\r\nerr = mtd_write(subdev, to, size, &retsize, buf);\r\nif (err)\r\nbreak;\r\n*retlen += retsize;\r\nlen -= size;\r\nif (len == 0)\r\nbreak;\r\nerr = -EINVAL;\r\nbuf += size;\r\nto = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nconcat_writev(struct mtd_info *mtd, const struct kvec *vecs,\r\nunsigned long count, loff_t to, size_t * retlen)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nstruct kvec *vecs_copy;\r\nunsigned long entry_low, entry_high;\r\nsize_t total_len = 0;\r\nint i;\r\nint err = -EINVAL;\r\nfor (i = 0; i < count; i++)\r\ntotal_len += vecs[i].iov_len;\r\nif (mtd->writesize > 1) {\r\nuint64_t __to = to;\r\nif (do_div(__to, mtd->writesize) || (total_len % mtd->writesize))\r\nreturn -EINVAL;\r\n}\r\nvecs_copy = kmemdup(vecs, sizeof(struct kvec) * count, GFP_KERNEL);\r\nif (!vecs_copy)\r\nreturn -ENOMEM;\r\nentry_low = 0;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nstruct mtd_info *subdev = concat->subdev[i];\r\nsize_t size, wsize, retsize, old_iov_len;\r\nif (to >= subdev->size) {\r\nto -= subdev->size;\r\ncontinue;\r\n}\r\nsize = min_t(uint64_t, total_len, subdev->size - to);\r\nwsize = size;\r\nentry_high = entry_low;\r\nwhile (entry_high < count) {\r\nif (size <= vecs_copy[entry_high].iov_len)\r\nbreak;\r\nsize -= vecs_copy[entry_high++].iov_len;\r\n}\r\nold_iov_len = vecs_copy[entry_high].iov_len;\r\nvecs_copy[entry_high].iov_len = size;\r\nerr = mtd_writev(subdev, &vecs_copy[entry_low],\r\nentry_high - entry_low + 1, to, &retsize);\r\nvecs_copy[entry_high].iov_len = old_iov_len - size;\r\nvecs_copy[entry_high].iov_base += size;\r\nentry_low = entry_high;\r\nif (err)\r\nbreak;\r\n*retlen += retsize;\r\ntotal_len -= wsize;\r\nif (total_len == 0)\r\nbreak;\r\nerr = -EINVAL;\r\nto = 0;\r\n}\r\nkfree(vecs_copy);\r\nreturn err;\r\n}\r\nstatic int\r\nconcat_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nstruct mtd_oob_ops devops = *ops;\r\nint i, err, ret = 0;\r\nops->retlen = ops->oobretlen = 0;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nstruct mtd_info *subdev = concat->subdev[i];\r\nif (from >= subdev->size) {\r\nfrom -= subdev->size;\r\ncontinue;\r\n}\r\nif (from + devops.len > subdev->size)\r\ndevops.len = subdev->size - from;\r\nerr = mtd_read_oob(subdev, from, &devops);\r\nops->retlen += devops.retlen;\r\nops->oobretlen += devops.oobretlen;\r\nif (unlikely(err)) {\r\nif (mtd_is_eccerr(err)) {\r\nmtd->ecc_stats.failed++;\r\nret = err;\r\n} else if (mtd_is_bitflip(err)) {\r\nmtd->ecc_stats.corrected++;\r\nif (!ret)\r\nret = err;\r\n} else\r\nreturn err;\r\n}\r\nif (devops.datbuf) {\r\ndevops.len = ops->len - ops->retlen;\r\nif (!devops.len)\r\nreturn ret;\r\ndevops.datbuf += devops.retlen;\r\n}\r\nif (devops.oobbuf) {\r\ndevops.ooblen = ops->ooblen - ops->oobretlen;\r\nif (!devops.ooblen)\r\nreturn ret;\r\ndevops.oobbuf += ops->oobretlen;\r\n}\r\nfrom = 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nconcat_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nstruct mtd_oob_ops devops = *ops;\r\nint i, err;\r\nif (!(mtd->flags & MTD_WRITEABLE))\r\nreturn -EROFS;\r\nops->retlen = ops->oobretlen = 0;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nstruct mtd_info *subdev = concat->subdev[i];\r\nif (to >= subdev->size) {\r\nto -= subdev->size;\r\ncontinue;\r\n}\r\nif (to + devops.len > subdev->size)\r\ndevops.len = subdev->size - to;\r\nerr = mtd_write_oob(subdev, to, &devops);\r\nops->retlen += devops.oobretlen;\r\nif (err)\r\nreturn err;\r\nif (devops.datbuf) {\r\ndevops.len = ops->len - ops->retlen;\r\nif (!devops.len)\r\nreturn 0;\r\ndevops.datbuf += devops.retlen;\r\n}\r\nif (devops.oobbuf) {\r\ndevops.ooblen = ops->ooblen - ops->oobretlen;\r\nif (!devops.ooblen)\r\nreturn 0;\r\ndevops.oobbuf += devops.oobretlen;\r\n}\r\nto = 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void concat_erase_callback(struct erase_info *instr)\r\n{\r\nwake_up((wait_queue_head_t *) instr->priv);\r\n}\r\nstatic int concat_dev_erase(struct mtd_info *mtd, struct erase_info *erase)\r\n{\r\nint err;\r\nwait_queue_head_t waitq;\r\nDECLARE_WAITQUEUE(wait, current);\r\ninit_waitqueue_head(&waitq);\r\nerase->mtd = mtd;\r\nerase->callback = concat_erase_callback;\r\nerase->priv = (unsigned long) &waitq;\r\nerr = mtd_erase(mtd, erase);\r\nif (!err) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&waitq, &wait);\r\nif (erase->state != MTD_ERASE_DONE\r\n&& erase->state != MTD_ERASE_FAILED)\r\nschedule();\r\nremove_wait_queue(&waitq, &wait);\r\nset_current_state(TASK_RUNNING);\r\nerr = (erase->state == MTD_ERASE_FAILED) ? -EIO : 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int concat_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nstruct mtd_info *subdev;\r\nint i, err;\r\nuint64_t length, offset = 0;\r\nstruct erase_info *erase;\r\nif (!concat->mtd.numeraseregions) {\r\nif (instr->addr & (concat->mtd.erasesize - 1))\r\nreturn -EINVAL;\r\nif (instr->len & (concat->mtd.erasesize - 1))\r\nreturn -EINVAL;\r\n} else {\r\nstruct mtd_erase_region_info *erase_regions =\r\nconcat->mtd.eraseregions;\r\nfor (i = 0; i < concat->mtd.numeraseregions &&\r\ninstr->addr >= erase_regions[i].offset; i++) ;\r\n--i;\r\nif (i < 0 || instr->addr & (erase_regions[i].erasesize - 1))\r\nreturn -EINVAL;\r\nfor (; i < concat->mtd.numeraseregions &&\r\n(instr->addr + instr->len) >= erase_regions[i].offset;\r\n++i) ;\r\n--i;\r\nif (i < 0 || ((instr->addr + instr->len) &\r\n(erase_regions[i].erasesize - 1)))\r\nreturn -EINVAL;\r\n}\r\nerase = kmalloc(sizeof (struct erase_info), GFP_KERNEL);\r\nif (!erase)\r\nreturn -ENOMEM;\r\n*erase = *instr;\r\nlength = instr->len;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nsubdev = concat->subdev[i];\r\nif (subdev->size <= erase->addr) {\r\nerase->addr -= subdev->size;\r\noffset += subdev->size;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nBUG_ON(i >= concat->num_subdev);\r\nerr = 0;\r\nfor (; length > 0; i++) {\r\nsubdev = concat->subdev[i];\r\nif (erase->addr + length > subdev->size)\r\nerase->len = subdev->size - erase->addr;\r\nelse\r\nerase->len = length;\r\nlength -= erase->len;\r\nif ((err = concat_dev_erase(subdev, erase))) {\r\nBUG_ON(err == -EINVAL);\r\nif (erase->fail_addr != MTD_FAIL_ADDR_UNKNOWN)\r\ninstr->fail_addr = erase->fail_addr + offset;\r\nbreak;\r\n}\r\nerase->addr = 0;\r\noffset += subdev->size;\r\n}\r\ninstr->state = erase->state;\r\nkfree(erase);\r\nif (err)\r\nreturn err;\r\nif (instr->callback)\r\ninstr->callback(instr);\r\nreturn 0;\r\n}\r\nstatic int concat_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nint i, err = -EINVAL;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nstruct mtd_info *subdev = concat->subdev[i];\r\nuint64_t size;\r\nif (ofs >= subdev->size) {\r\nsize = 0;\r\nofs -= subdev->size;\r\ncontinue;\r\n}\r\nif (ofs + len > subdev->size)\r\nsize = subdev->size - ofs;\r\nelse\r\nsize = len;\r\nerr = mtd_lock(subdev, ofs, size);\r\nif (err)\r\nbreak;\r\nlen -= size;\r\nif (len == 0)\r\nbreak;\r\nerr = -EINVAL;\r\nofs = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int concat_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nint i, err = 0;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nstruct mtd_info *subdev = concat->subdev[i];\r\nuint64_t size;\r\nif (ofs >= subdev->size) {\r\nsize = 0;\r\nofs -= subdev->size;\r\ncontinue;\r\n}\r\nif (ofs + len > subdev->size)\r\nsize = subdev->size - ofs;\r\nelse\r\nsize = len;\r\nerr = mtd_unlock(subdev, ofs, size);\r\nif (err)\r\nbreak;\r\nlen -= size;\r\nif (len == 0)\r\nbreak;\r\nerr = -EINVAL;\r\nofs = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic void concat_sync(struct mtd_info *mtd)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nint i;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nstruct mtd_info *subdev = concat->subdev[i];\r\nmtd_sync(subdev);\r\n}\r\n}\r\nstatic int concat_suspend(struct mtd_info *mtd)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nint i, rc = 0;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nstruct mtd_info *subdev = concat->subdev[i];\r\nif ((rc = mtd_suspend(subdev)) < 0)\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nstatic void concat_resume(struct mtd_info *mtd)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nint i;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nstruct mtd_info *subdev = concat->subdev[i];\r\nmtd_resume(subdev);\r\n}\r\n}\r\nstatic int concat_block_isbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nint i, res = 0;\r\nif (!mtd_can_have_bb(concat->subdev[0]))\r\nreturn res;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nstruct mtd_info *subdev = concat->subdev[i];\r\nif (ofs >= subdev->size) {\r\nofs -= subdev->size;\r\ncontinue;\r\n}\r\nres = mtd_block_isbad(subdev, ofs);\r\nbreak;\r\n}\r\nreturn res;\r\n}\r\nstatic int concat_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nint i, err = -EINVAL;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nstruct mtd_info *subdev = concat->subdev[i];\r\nif (ofs >= subdev->size) {\r\nofs -= subdev->size;\r\ncontinue;\r\n}\r\nerr = mtd_block_markbad(subdev, ofs);\r\nif (!err)\r\nmtd->ecc_stats.badblocks++;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic unsigned long concat_get_unmapped_area(struct mtd_info *mtd,\r\nunsigned long len,\r\nunsigned long offset,\r\nunsigned long flags)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nint i;\r\nfor (i = 0; i < concat->num_subdev; i++) {\r\nstruct mtd_info *subdev = concat->subdev[i];\r\nif (offset >= subdev->size) {\r\noffset -= subdev->size;\r\ncontinue;\r\n}\r\nreturn mtd_get_unmapped_area(subdev, len, offset, flags);\r\n}\r\nreturn (unsigned long) -ENOSYS;\r\n}\r\nstruct mtd_info *mtd_concat_create(struct mtd_info *subdev[],\r\nint num_devs,\r\nconst char *name)\r\n{\r\nint i;\r\nsize_t size;\r\nstruct mtd_concat *concat;\r\nuint32_t max_erasesize, curr_erasesize;\r\nint num_erase_region;\r\nint max_writebufsize = 0;\r\nprintk(KERN_NOTICE "Concatenating MTD devices:\n");\r\nfor (i = 0; i < num_devs; i++)\r\nprintk(KERN_NOTICE "(%d): \"%s\"\n", i, subdev[i]->name);\r\nprintk(KERN_NOTICE "into device \"%s\"\n", name);\r\nsize = SIZEOF_STRUCT_MTD_CONCAT(num_devs);\r\nconcat = kzalloc(size, GFP_KERNEL);\r\nif (!concat) {\r\nprintk\r\n("memory allocation error while creating concatenated device \"%s\"\n",\r\nname);\r\nreturn NULL;\r\n}\r\nconcat->subdev = (struct mtd_info **) (concat + 1);\r\nconcat->mtd.type = subdev[0]->type;\r\nconcat->mtd.flags = subdev[0]->flags;\r\nconcat->mtd.size = subdev[0]->size;\r\nconcat->mtd.erasesize = subdev[0]->erasesize;\r\nconcat->mtd.writesize = subdev[0]->writesize;\r\nfor (i = 0; i < num_devs; i++)\r\nif (max_writebufsize < subdev[i]->writebufsize)\r\nmax_writebufsize = subdev[i]->writebufsize;\r\nconcat->mtd.writebufsize = max_writebufsize;\r\nconcat->mtd.subpage_sft = subdev[0]->subpage_sft;\r\nconcat->mtd.oobsize = subdev[0]->oobsize;\r\nconcat->mtd.oobavail = subdev[0]->oobavail;\r\nif (subdev[0]->_writev)\r\nconcat->mtd._writev = concat_writev;\r\nif (subdev[0]->_read_oob)\r\nconcat->mtd._read_oob = concat_read_oob;\r\nif (subdev[0]->_write_oob)\r\nconcat->mtd._write_oob = concat_write_oob;\r\nif (subdev[0]->_block_isbad)\r\nconcat->mtd._block_isbad = concat_block_isbad;\r\nif (subdev[0]->_block_markbad)\r\nconcat->mtd._block_markbad = concat_block_markbad;\r\nconcat->mtd.ecc_stats.badblocks = subdev[0]->ecc_stats.badblocks;\r\nconcat->mtd.backing_dev_info = subdev[0]->backing_dev_info;\r\nconcat->subdev[0] = subdev[0];\r\nfor (i = 1; i < num_devs; i++) {\r\nif (concat->mtd.type != subdev[i]->type) {\r\nkfree(concat);\r\nprintk("Incompatible device type on \"%s\"\n",\r\nsubdev[i]->name);\r\nreturn NULL;\r\n}\r\nif (concat->mtd.flags != subdev[i]->flags) {\r\nif ((concat->mtd.flags ^ subdev[i]->\r\nflags) & ~MTD_WRITEABLE) {\r\nkfree(concat);\r\nprintk("Incompatible device flags on \"%s\"\n",\r\nsubdev[i]->name);\r\nreturn NULL;\r\n} else\r\nconcat->mtd.flags |=\r\nsubdev[i]->flags & MTD_WRITEABLE;\r\n}\r\nif (concat->mtd.backing_dev_info !=\r\nsubdev[i]->backing_dev_info)\r\nconcat->mtd.backing_dev_info =\r\n&default_backing_dev_info;\r\nconcat->mtd.size += subdev[i]->size;\r\nconcat->mtd.ecc_stats.badblocks +=\r\nsubdev[i]->ecc_stats.badblocks;\r\nif (concat->mtd.writesize != subdev[i]->writesize ||\r\nconcat->mtd.subpage_sft != subdev[i]->subpage_sft ||\r\nconcat->mtd.oobsize != subdev[i]->oobsize ||\r\n!concat->mtd._read_oob != !subdev[i]->_read_oob ||\r\n!concat->mtd._write_oob != !subdev[i]->_write_oob) {\r\nkfree(concat);\r\nprintk("Incompatible OOB or ECC data on \"%s\"\n",\r\nsubdev[i]->name);\r\nreturn NULL;\r\n}\r\nconcat->subdev[i] = subdev[i];\r\n}\r\nconcat->mtd.ecclayout = subdev[0]->ecclayout;\r\nconcat->num_subdev = num_devs;\r\nconcat->mtd.name = name;\r\nconcat->mtd._erase = concat_erase;\r\nconcat->mtd._read = concat_read;\r\nconcat->mtd._write = concat_write;\r\nconcat->mtd._sync = concat_sync;\r\nconcat->mtd._lock = concat_lock;\r\nconcat->mtd._unlock = concat_unlock;\r\nconcat->mtd._suspend = concat_suspend;\r\nconcat->mtd._resume = concat_resume;\r\nconcat->mtd._get_unmapped_area = concat_get_unmapped_area;\r\nmax_erasesize = curr_erasesize = subdev[0]->erasesize;\r\nnum_erase_region = 1;\r\nfor (i = 0; i < num_devs; i++) {\r\nif (subdev[i]->numeraseregions == 0) {\r\nif (subdev[i]->erasesize != curr_erasesize) {\r\n++num_erase_region;\r\ncurr_erasesize = subdev[i]->erasesize;\r\nif (curr_erasesize > max_erasesize)\r\nmax_erasesize = curr_erasesize;\r\n}\r\n} else {\r\nint j;\r\nfor (j = 0; j < subdev[i]->numeraseregions; j++) {\r\nif (subdev[i]->eraseregions[j].erasesize !=\r\ncurr_erasesize) {\r\n++num_erase_region;\r\ncurr_erasesize =\r\nsubdev[i]->eraseregions[j].\r\nerasesize;\r\nif (curr_erasesize > max_erasesize)\r\nmax_erasesize = curr_erasesize;\r\n}\r\n}\r\n}\r\n}\r\nif (num_erase_region == 1) {\r\nconcat->mtd.erasesize = curr_erasesize;\r\nconcat->mtd.numeraseregions = 0;\r\n} else {\r\nuint64_t tmp64;\r\nstruct mtd_erase_region_info *erase_region_p;\r\nuint64_t begin, position;\r\nconcat->mtd.erasesize = max_erasesize;\r\nconcat->mtd.numeraseregions = num_erase_region;\r\nconcat->mtd.eraseregions = erase_region_p =\r\nkmalloc(num_erase_region *\r\nsizeof (struct mtd_erase_region_info), GFP_KERNEL);\r\nif (!erase_region_p) {\r\nkfree(concat);\r\nprintk\r\n("memory allocation error while creating erase region list"\r\n" for device \"%s\"\n", name);\r\nreturn NULL;\r\n}\r\ncurr_erasesize = subdev[0]->erasesize;\r\nbegin = position = 0;\r\nfor (i = 0; i < num_devs; i++) {\r\nif (subdev[i]->numeraseregions == 0) {\r\nif (subdev[i]->erasesize != curr_erasesize) {\r\nerase_region_p->offset = begin;\r\nerase_region_p->erasesize =\r\ncurr_erasesize;\r\ntmp64 = position - begin;\r\ndo_div(tmp64, curr_erasesize);\r\nerase_region_p->numblocks = tmp64;\r\nbegin = position;\r\ncurr_erasesize = subdev[i]->erasesize;\r\n++erase_region_p;\r\n}\r\nposition += subdev[i]->size;\r\n} else {\r\nint j;\r\nfor (j = 0; j < subdev[i]->numeraseregions; j++) {\r\nif (subdev[i]->eraseregions[j].\r\nerasesize != curr_erasesize) {\r\nerase_region_p->offset = begin;\r\nerase_region_p->erasesize =\r\ncurr_erasesize;\r\ntmp64 = position - begin;\r\ndo_div(tmp64, curr_erasesize);\r\nerase_region_p->numblocks = tmp64;\r\nbegin = position;\r\ncurr_erasesize =\r\nsubdev[i]->eraseregions[j].\r\nerasesize;\r\n++erase_region_p;\r\n}\r\nposition +=\r\nsubdev[i]->eraseregions[j].\r\nnumblocks * (uint64_t)curr_erasesize;\r\n}\r\n}\r\n}\r\nerase_region_p->offset = begin;\r\nerase_region_p->erasesize = curr_erasesize;\r\ntmp64 = position - begin;\r\ndo_div(tmp64, curr_erasesize);\r\nerase_region_p->numblocks = tmp64;\r\n}\r\nreturn &concat->mtd;\r\n}\r\nvoid mtd_concat_destroy(struct mtd_info *mtd)\r\n{\r\nstruct mtd_concat *concat = CONCAT(mtd);\r\nif (concat->mtd.numeraseregions)\r\nkfree(concat->mtd.eraseregions);\r\nkfree(concat);\r\n}
