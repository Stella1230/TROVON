static void\r\nmlx4_en_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nstrlcpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, DRV_VERSION " (" DRV_RELDATE ")",\r\nsizeof(drvinfo->version));\r\nsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\r\n"%d.%d.%d",\r\n(u16) (mdev->dev->caps.fw_ver >> 32),\r\n(u16) ((mdev->dev->caps.fw_ver >> 16) & 0xffff),\r\n(u16) (mdev->dev->caps.fw_ver & 0xffff));\r\nstrlcpy(drvinfo->bus_info, pci_name(mdev->dev->pdev),\r\nsizeof(drvinfo->bus_info));\r\ndrvinfo->n_stats = 0;\r\ndrvinfo->regdump_len = 0;\r\ndrvinfo->eedump_len = 0;\r\n}\r\nstatic u32 mlx4_en_get_msglevel(struct net_device *dev)\r\n{\r\nreturn ((struct mlx4_en_priv *) netdev_priv(dev))->msg_enable;\r\n}\r\nstatic void mlx4_en_set_msglevel(struct net_device *dev, u32 val)\r\n{\r\n((struct mlx4_en_priv *) netdev_priv(dev))->msg_enable = val;\r\n}\r\nstatic void mlx4_en_get_wol(struct net_device *netdev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(netdev);\r\nint err = 0;\r\nu64 config = 0;\r\nu64 mask;\r\nif ((priv->port < 1) || (priv->port > 2)) {\r\nen_err(priv, "Failed to get WoL information\n");\r\nreturn;\r\n}\r\nmask = (priv->port == 1) ? MLX4_DEV_CAP_FLAG_WOL_PORT1 :\r\nMLX4_DEV_CAP_FLAG_WOL_PORT2;\r\nif (!(priv->mdev->dev->caps.flags & mask)) {\r\nwol->supported = 0;\r\nwol->wolopts = 0;\r\nreturn;\r\n}\r\nerr = mlx4_wol_read(priv->mdev->dev, &config, priv->port);\r\nif (err) {\r\nen_err(priv, "Failed to get WoL information\n");\r\nreturn;\r\n}\r\nif (config & MLX4_EN_WOL_MAGIC)\r\nwol->supported = WAKE_MAGIC;\r\nelse\r\nwol->supported = 0;\r\nif (config & MLX4_EN_WOL_ENABLED)\r\nwol->wolopts = WAKE_MAGIC;\r\nelse\r\nwol->wolopts = 0;\r\n}\r\nstatic int mlx4_en_set_wol(struct net_device *netdev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(netdev);\r\nu64 config = 0;\r\nint err = 0;\r\nu64 mask;\r\nif ((priv->port < 1) || (priv->port > 2))\r\nreturn -EOPNOTSUPP;\r\nmask = (priv->port == 1) ? MLX4_DEV_CAP_FLAG_WOL_PORT1 :\r\nMLX4_DEV_CAP_FLAG_WOL_PORT2;\r\nif (!(priv->mdev->dev->caps.flags & mask))\r\nreturn -EOPNOTSUPP;\r\nif (wol->supported & ~WAKE_MAGIC)\r\nreturn -EINVAL;\r\nerr = mlx4_wol_read(priv->mdev->dev, &config, priv->port);\r\nif (err) {\r\nen_err(priv, "Failed to get WoL info, unable to modify\n");\r\nreturn err;\r\n}\r\nif (wol->wolopts & WAKE_MAGIC) {\r\nconfig |= MLX4_EN_WOL_DO_MODIFY | MLX4_EN_WOL_ENABLED |\r\nMLX4_EN_WOL_MAGIC;\r\n} else {\r\nconfig &= ~(MLX4_EN_WOL_ENABLED | MLX4_EN_WOL_MAGIC);\r\nconfig |= MLX4_EN_WOL_DO_MODIFY;\r\n}\r\nerr = mlx4_wol_write(priv->mdev->dev, config, priv->port);\r\nif (err)\r\nen_err(priv, "Failed to set WoL information\n");\r\nreturn err;\r\n}\r\nstatic int mlx4_en_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nint bit_count = hweight64(priv->stats_bitmap);\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn (priv->stats_bitmap ? bit_count : NUM_ALL_STATS) +\r\n(priv->tx_ring_num + priv->rx_ring_num) * 2;\r\ncase ETH_SS_TEST:\r\nreturn MLX4_EN_NUM_SELF_TEST - !(priv->mdev->dev->caps.flags\r\n& MLX4_DEV_CAP_FLAG_UC_LOOPBACK) * 2;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void mlx4_en_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, uint64_t *data)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nint index = 0;\r\nint i, j = 0;\r\nspin_lock_bh(&priv->stats_lock);\r\nif (!(priv->stats_bitmap)) {\r\nfor (i = 0; i < NUM_MAIN_STATS; i++)\r\ndata[index++] =\r\n((unsigned long *) &priv->stats)[i];\r\nfor (i = 0; i < NUM_PORT_STATS; i++)\r\ndata[index++] =\r\n((unsigned long *) &priv->port_stats)[i];\r\nfor (i = 0; i < NUM_PKT_STATS; i++)\r\ndata[index++] =\r\n((unsigned long *) &priv->pkstats)[i];\r\n} else {\r\nfor (i = 0; i < NUM_MAIN_STATS; i++) {\r\nif ((priv->stats_bitmap >> j) & 1)\r\ndata[index++] =\r\n((unsigned long *) &priv->stats)[i];\r\nj++;\r\n}\r\nfor (i = 0; i < NUM_PORT_STATS; i++) {\r\nif ((priv->stats_bitmap >> j) & 1)\r\ndata[index++] =\r\n((unsigned long *) &priv->port_stats)[i];\r\nj++;\r\n}\r\n}\r\nfor (i = 0; i < priv->tx_ring_num; i++) {\r\ndata[index++] = priv->tx_ring[i].packets;\r\ndata[index++] = priv->tx_ring[i].bytes;\r\n}\r\nfor (i = 0; i < priv->rx_ring_num; i++) {\r\ndata[index++] = priv->rx_ring[i].packets;\r\ndata[index++] = priv->rx_ring[i].bytes;\r\n}\r\nspin_unlock_bh(&priv->stats_lock);\r\n}\r\nstatic void mlx4_en_self_test(struct net_device *dev,\r\nstruct ethtool_test *etest, u64 *buf)\r\n{\r\nmlx4_en_ex_selftest(dev, &etest->flags, buf);\r\n}\r\nstatic void mlx4_en_get_strings(struct net_device *dev,\r\nuint32_t stringset, uint8_t *data)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nint index = 0;\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_TEST:\r\nfor (i = 0; i < MLX4_EN_NUM_SELF_TEST - 2; i++)\r\nstrcpy(data + i * ETH_GSTRING_LEN, mlx4_en_test_names[i]);\r\nif (priv->mdev->dev->caps.flags & MLX4_DEV_CAP_FLAG_UC_LOOPBACK)\r\nfor (; i < MLX4_EN_NUM_SELF_TEST; i++)\r\nstrcpy(data + i * ETH_GSTRING_LEN, mlx4_en_test_names[i]);\r\nbreak;\r\ncase ETH_SS_STATS:\r\nif (!priv->stats_bitmap) {\r\nfor (i = 0; i < NUM_MAIN_STATS; i++)\r\nstrcpy(data + (index++) * ETH_GSTRING_LEN,\r\nmain_strings[i]);\r\nfor (i = 0; i < NUM_PORT_STATS; i++)\r\nstrcpy(data + (index++) * ETH_GSTRING_LEN,\r\nmain_strings[i +\r\nNUM_MAIN_STATS]);\r\nfor (i = 0; i < NUM_PKT_STATS; i++)\r\nstrcpy(data + (index++) * ETH_GSTRING_LEN,\r\nmain_strings[i +\r\nNUM_MAIN_STATS +\r\nNUM_PORT_STATS]);\r\n} else\r\nfor (i = 0; i < NUM_MAIN_STATS + NUM_PORT_STATS; i++) {\r\nif ((priv->stats_bitmap >> i) & 1) {\r\nstrcpy(data +\r\n(index++) * ETH_GSTRING_LEN,\r\nmain_strings[i]);\r\n}\r\nif (!(priv->stats_bitmap >> i))\r\nbreak;\r\n}\r\nfor (i = 0; i < priv->tx_ring_num; i++) {\r\nsprintf(data + (index++) * ETH_GSTRING_LEN,\r\n"tx%d_packets", i);\r\nsprintf(data + (index++) * ETH_GSTRING_LEN,\r\n"tx%d_bytes", i);\r\n}\r\nfor (i = 0; i < priv->rx_ring_num; i++) {\r\nsprintf(data + (index++) * ETH_GSTRING_LEN,\r\n"rx%d_packets", i);\r\nsprintf(data + (index++) * ETH_GSTRING_LEN,\r\n"rx%d_bytes", i);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int mlx4_en_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nint trans_type;\r\ncmd->autoneg = AUTONEG_DISABLE;\r\ncmd->supported = SUPPORTED_10000baseT_Full;\r\ncmd->advertising = ADVERTISED_10000baseT_Full;\r\nif (mlx4_en_QUERY_PORT(priv->mdev, priv->port))\r\nreturn -ENOMEM;\r\ntrans_type = priv->port_state.transciver;\r\nif (netif_carrier_ok(dev)) {\r\nethtool_cmd_speed_set(cmd, priv->port_state.link_speed);\r\ncmd->duplex = DUPLEX_FULL;\r\n} else {\r\nethtool_cmd_speed_set(cmd, -1);\r\ncmd->duplex = -1;\r\n}\r\nif (trans_type > 0 && trans_type <= 0xC) {\r\ncmd->port = PORT_FIBRE;\r\ncmd->transceiver = XCVR_EXTERNAL;\r\ncmd->supported |= SUPPORTED_FIBRE;\r\ncmd->advertising |= ADVERTISED_FIBRE;\r\n} else if (trans_type == 0x80 || trans_type == 0) {\r\ncmd->port = PORT_TP;\r\ncmd->transceiver = XCVR_INTERNAL;\r\ncmd->supported |= SUPPORTED_TP;\r\ncmd->advertising |= ADVERTISED_TP;\r\n} else {\r\ncmd->port = -1;\r\ncmd->transceiver = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nif ((cmd->autoneg == AUTONEG_ENABLE) ||\r\n(ethtool_cmd_speed(cmd) != SPEED_10000) ||\r\n(cmd->duplex != DUPLEX_FULL))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_get_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *coal)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\ncoal->tx_coalesce_usecs = priv->tx_usecs;\r\ncoal->tx_max_coalesced_frames = priv->tx_frames;\r\ncoal->rx_coalesce_usecs = priv->rx_usecs;\r\ncoal->rx_max_coalesced_frames = priv->rx_frames;\r\ncoal->pkt_rate_low = priv->pkt_rate_low;\r\ncoal->rx_coalesce_usecs_low = priv->rx_usecs_low;\r\ncoal->pkt_rate_high = priv->pkt_rate_high;\r\ncoal->rx_coalesce_usecs_high = priv->rx_usecs_high;\r\ncoal->rate_sample_interval = priv->sample_interval;\r\ncoal->use_adaptive_rx_coalesce = priv->adaptive_rx_coal;\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_set_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *coal)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nint err, i;\r\npriv->rx_frames = (coal->rx_max_coalesced_frames ==\r\nMLX4_EN_AUTO_CONF) ?\r\nMLX4_EN_RX_COAL_TARGET :\r\ncoal->rx_max_coalesced_frames;\r\npriv->rx_usecs = (coal->rx_coalesce_usecs ==\r\nMLX4_EN_AUTO_CONF) ?\r\nMLX4_EN_RX_COAL_TIME :\r\ncoal->rx_coalesce_usecs;\r\nif (coal->tx_coalesce_usecs != priv->tx_usecs ||\r\ncoal->tx_max_coalesced_frames != priv->tx_frames) {\r\npriv->tx_usecs = coal->tx_coalesce_usecs;\r\npriv->tx_frames = coal->tx_max_coalesced_frames;\r\nfor (i = 0; i < priv->tx_ring_num; i++) {\r\npriv->tx_cq[i].moder_cnt = priv->tx_frames;\r\npriv->tx_cq[i].moder_time = priv->tx_usecs;\r\nif (mlx4_en_set_cq_moder(priv, &priv->tx_cq[i])) {\r\nen_warn(priv, "Failed changing moderation "\r\n"for TX cq %d\n", i);\r\n}\r\n}\r\n}\r\npriv->pkt_rate_low = coal->pkt_rate_low;\r\npriv->rx_usecs_low = coal->rx_coalesce_usecs_low;\r\npriv->pkt_rate_high = coal->pkt_rate_high;\r\npriv->rx_usecs_high = coal->rx_coalesce_usecs_high;\r\npriv->sample_interval = coal->rate_sample_interval;\r\npriv->adaptive_rx_coal = coal->use_adaptive_rx_coalesce;\r\nif (priv->adaptive_rx_coal)\r\nreturn 0;\r\nfor (i = 0; i < priv->rx_ring_num; i++) {\r\npriv->rx_cq[i].moder_cnt = priv->rx_frames;\r\npriv->rx_cq[i].moder_time = priv->rx_usecs;\r\npriv->last_moder_time[i] = MLX4_EN_AUTO_CONF;\r\nerr = mlx4_en_set_cq_moder(priv, &priv->rx_cq[i]);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_set_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint err;\r\npriv->prof->tx_pause = pause->tx_pause != 0;\r\npriv->prof->rx_pause = pause->rx_pause != 0;\r\nerr = mlx4_SET_PORT_general(mdev->dev, priv->port,\r\npriv->rx_skb_size + ETH_FCS_LEN,\r\npriv->prof->tx_pause,\r\npriv->prof->tx_ppp,\r\npriv->prof->rx_pause,\r\npriv->prof->rx_ppp);\r\nif (err)\r\nen_err(priv, "Failed setting pause params\n");\r\nreturn err;\r\n}\r\nstatic void mlx4_en_get_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\npause->tx_pause = priv->prof->tx_pause;\r\npause->rx_pause = priv->prof->rx_pause;\r\n}\r\nstatic int mlx4_en_set_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *param)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nu32 rx_size, tx_size;\r\nint port_up = 0;\r\nint err = 0;\r\nint i;\r\nif (param->rx_jumbo_pending || param->rx_mini_pending)\r\nreturn -EINVAL;\r\nrx_size = roundup_pow_of_two(param->rx_pending);\r\nrx_size = max_t(u32, rx_size, MLX4_EN_MIN_RX_SIZE);\r\nrx_size = min_t(u32, rx_size, MLX4_EN_MAX_RX_SIZE);\r\ntx_size = roundup_pow_of_two(param->tx_pending);\r\ntx_size = max_t(u32, tx_size, MLX4_EN_MIN_TX_SIZE);\r\ntx_size = min_t(u32, tx_size, MLX4_EN_MAX_TX_SIZE);\r\nif (rx_size == (priv->port_up ? priv->rx_ring[0].actual_size :\r\npriv->rx_ring[0].size) &&\r\ntx_size == priv->tx_ring[0].size)\r\nreturn 0;\r\nmutex_lock(&mdev->state_lock);\r\nif (priv->port_up) {\r\nport_up = 1;\r\nmlx4_en_stop_port(dev);\r\n}\r\nmlx4_en_free_resources(priv);\r\npriv->prof->tx_ring_size = tx_size;\r\npriv->prof->rx_ring_size = rx_size;\r\nerr = mlx4_en_alloc_resources(priv);\r\nif (err) {\r\nen_err(priv, "Failed reallocating port resources\n");\r\ngoto out;\r\n}\r\nif (port_up) {\r\nerr = mlx4_en_start_port(dev);\r\nif (err)\r\nen_err(priv, "Failed starting port\n");\r\n}\r\nfor (i = 0; i < priv->rx_ring_num; i++) {\r\npriv->rx_cq[i].moder_cnt = priv->rx_frames;\r\npriv->rx_cq[i].moder_time = priv->rx_usecs;\r\npriv->last_moder_time[i] = MLX4_EN_AUTO_CONF;\r\nerr = mlx4_en_set_cq_moder(priv, &priv->rx_cq[i]);\r\nif (err)\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&mdev->state_lock);\r\nreturn err;\r\n}\r\nstatic void mlx4_en_get_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *param)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nmemset(param, 0, sizeof(*param));\r\nparam->rx_max_pending = MLX4_EN_MAX_RX_SIZE;\r\nparam->tx_max_pending = MLX4_EN_MAX_TX_SIZE;\r\nparam->rx_pending = priv->port_up ?\r\npriv->rx_ring[0].actual_size : priv->rx_ring[0].size;\r\nparam->tx_pending = priv->tx_ring[0].size;\r\n}\r\nstatic u32 mlx4_en_get_rxfh_indir_size(struct net_device *dev)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nreturn priv->rx_ring_num;\r\n}\r\nstatic int mlx4_en_get_rxfh_indir(struct net_device *dev, u32 *ring_index)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_rss_map *rss_map = &priv->rss_map;\r\nint rss_rings;\r\nsize_t n = priv->rx_ring_num;\r\nint err = 0;\r\nrss_rings = priv->prof->rss_rings ?: priv->rx_ring_num;\r\nwhile (n--) {\r\nring_index[n] = rss_map->qps[n % rss_rings].qpn -\r\nrss_map->base_qpn;\r\n}\r\nreturn err;\r\n}\r\nstatic int mlx4_en_set_rxfh_indir(struct net_device *dev,\r\nconst u32 *ring_index)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint port_up = 0;\r\nint err = 0;\r\nint i;\r\nint rss_rings = 0;\r\nfor (i = 0; i < priv->rx_ring_num; i++) {\r\nif (i > 0 && !ring_index[i] && !rss_rings)\r\nrss_rings = i;\r\nif (ring_index[i] != (i % (rss_rings ?: priv->rx_ring_num)))\r\nreturn -EINVAL;\r\n}\r\nif (!rss_rings)\r\nrss_rings = priv->rx_ring_num;\r\nif (!is_power_of_2(rss_rings))\r\nreturn -EINVAL;\r\nmutex_lock(&mdev->state_lock);\r\nif (priv->port_up) {\r\nport_up = 1;\r\nmlx4_en_stop_port(dev);\r\n}\r\npriv->prof->rss_rings = rss_rings;\r\nif (port_up) {\r\nerr = mlx4_en_start_port(dev);\r\nif (err)\r\nen_err(priv, "Failed starting port\n");\r\n}\r\nmutex_unlock(&mdev->state_lock);\r\nreturn err;\r\n}\r\nstatic int mlx4_en_validate_flow(struct net_device *dev,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nstruct ethtool_usrip4_spec *l3_mask;\r\nstruct ethtool_tcpip4_spec *l4_mask;\r\nstruct ethhdr *eth_mask;\r\nu64 full_mac = ~0ull;\r\nu64 zero_mac = 0;\r\nif (cmd->fs.location >= MAX_NUM_OF_FS_RULES)\r\nreturn -EINVAL;\r\nswitch (cmd->fs.flow_type & ~FLOW_EXT) {\r\ncase TCP_V4_FLOW:\r\ncase UDP_V4_FLOW:\r\nif (cmd->fs.m_u.tcp_ip4_spec.tos)\r\nreturn -EINVAL;\r\nl4_mask = &cmd->fs.m_u.tcp_ip4_spec;\r\nif (!all_zeros_or_all_ones(l4_mask->ip4src) ||\r\n!all_zeros_or_all_ones(l4_mask->ip4dst) ||\r\n!all_zeros_or_all_ones(l4_mask->psrc) ||\r\n!all_zeros_or_all_ones(l4_mask->pdst))\r\nreturn -EINVAL;\r\nbreak;\r\ncase IP_USER_FLOW:\r\nl3_mask = &cmd->fs.m_u.usr_ip4_spec;\r\nif (l3_mask->l4_4_bytes || l3_mask->tos || l3_mask->proto ||\r\ncmd->fs.h_u.usr_ip4_spec.ip_ver != ETH_RX_NFC_IP4 ||\r\n(!l3_mask->ip4src && !l3_mask->ip4dst) ||\r\n!all_zeros_or_all_ones(l3_mask->ip4src) ||\r\n!all_zeros_or_all_ones(l3_mask->ip4dst))\r\nreturn -EINVAL;\r\nbreak;\r\ncase ETHER_FLOW:\r\neth_mask = &cmd->fs.m_u.ether_spec;\r\nif (memcmp(eth_mask->h_source, &zero_mac, ETH_ALEN))\r\nreturn -EINVAL;\r\nif (memcmp(eth_mask->h_dest, &full_mac, ETH_ALEN))\r\nreturn -EINVAL;\r\nif (!all_zeros_or_all_ones(eth_mask->h_proto))\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((cmd->fs.flow_type & FLOW_EXT)) {\r\nif (cmd->fs.m_ext.vlan_etype ||\r\n!(cmd->fs.m_ext.vlan_tci == 0 ||\r\ncmd->fs.m_ext.vlan_tci == cpu_to_be16(0xfff)))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int add_ip_rule(struct mlx4_en_priv *priv,\r\nstruct ethtool_rxnfc *cmd,\r\nstruct list_head *list_h)\r\n{\r\nstruct mlx4_spec_list *spec_l3;\r\nstruct ethtool_usrip4_spec *l3_mask = &cmd->fs.m_u.usr_ip4_spec;\r\nspec_l3 = kzalloc(sizeof *spec_l3, GFP_KERNEL);\r\nif (!spec_l3) {\r\nen_err(priv, "Fail to alloc ethtool rule.\n");\r\nreturn -ENOMEM;\r\n}\r\nspec_l3->id = MLX4_NET_TRANS_RULE_ID_IPV4;\r\nspec_l3->ipv4.src_ip = cmd->fs.h_u.usr_ip4_spec.ip4src;\r\nif (l3_mask->ip4src)\r\nspec_l3->ipv4.src_ip_msk = EN_ETHTOOL_WORD_MASK;\r\nspec_l3->ipv4.dst_ip = cmd->fs.h_u.usr_ip4_spec.ip4dst;\r\nif (l3_mask->ip4dst)\r\nspec_l3->ipv4.dst_ip_msk = EN_ETHTOOL_WORD_MASK;\r\nlist_add_tail(&spec_l3->list, list_h);\r\nreturn 0;\r\n}\r\nstatic int add_tcp_udp_rule(struct mlx4_en_priv *priv,\r\nstruct ethtool_rxnfc *cmd,\r\nstruct list_head *list_h, int proto)\r\n{\r\nstruct mlx4_spec_list *spec_l3;\r\nstruct mlx4_spec_list *spec_l4;\r\nstruct ethtool_tcpip4_spec *l4_mask = &cmd->fs.m_u.tcp_ip4_spec;\r\nspec_l3 = kzalloc(sizeof *spec_l3, GFP_KERNEL);\r\nspec_l4 = kzalloc(sizeof *spec_l4, GFP_KERNEL);\r\nif (!spec_l4 || !spec_l3) {\r\nen_err(priv, "Fail to alloc ethtool rule.\n");\r\nkfree(spec_l3);\r\nkfree(spec_l4);\r\nreturn -ENOMEM;\r\n}\r\nspec_l3->id = MLX4_NET_TRANS_RULE_ID_IPV4;\r\nif (proto == TCP_V4_FLOW) {\r\nspec_l4->id = MLX4_NET_TRANS_RULE_ID_TCP;\r\nspec_l3->ipv4.src_ip = cmd->fs.h_u.tcp_ip4_spec.ip4src;\r\nspec_l3->ipv4.dst_ip = cmd->fs.h_u.tcp_ip4_spec.ip4dst;\r\nspec_l4->tcp_udp.src_port = cmd->fs.h_u.tcp_ip4_spec.psrc;\r\nspec_l4->tcp_udp.dst_port = cmd->fs.h_u.tcp_ip4_spec.pdst;\r\n} else {\r\nspec_l4->id = MLX4_NET_TRANS_RULE_ID_UDP;\r\nspec_l3->ipv4.src_ip = cmd->fs.h_u.udp_ip4_spec.ip4src;\r\nspec_l3->ipv4.dst_ip = cmd->fs.h_u.udp_ip4_spec.ip4dst;\r\nspec_l4->tcp_udp.src_port = cmd->fs.h_u.udp_ip4_spec.psrc;\r\nspec_l4->tcp_udp.dst_port = cmd->fs.h_u.udp_ip4_spec.pdst;\r\n}\r\nif (l4_mask->ip4src)\r\nspec_l3->ipv4.src_ip_msk = EN_ETHTOOL_WORD_MASK;\r\nif (l4_mask->ip4dst)\r\nspec_l3->ipv4.dst_ip_msk = EN_ETHTOOL_WORD_MASK;\r\nif (l4_mask->psrc)\r\nspec_l4->tcp_udp.src_port_msk = EN_ETHTOOL_SHORT_MASK;\r\nif (l4_mask->pdst)\r\nspec_l4->tcp_udp.dst_port_msk = EN_ETHTOOL_SHORT_MASK;\r\nlist_add_tail(&spec_l3->list, list_h);\r\nlist_add_tail(&spec_l4->list, list_h);\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_ethtool_to_net_trans_rule(struct net_device *dev,\r\nstruct ethtool_rxnfc *cmd,\r\nstruct list_head *rule_list_h)\r\n{\r\nint err;\r\nu64 mac;\r\n__be64 be_mac;\r\nstruct ethhdr *eth_spec;\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_spec_list *spec_l2;\r\n__be64 mac_msk = cpu_to_be64(MLX4_MAC_MASK << 16);\r\nerr = mlx4_en_validate_flow(dev, cmd);\r\nif (err)\r\nreturn err;\r\nspec_l2 = kzalloc(sizeof *spec_l2, GFP_KERNEL);\r\nif (!spec_l2)\r\nreturn -ENOMEM;\r\nmac = priv->mac & MLX4_MAC_MASK;\r\nbe_mac = cpu_to_be64(mac << 16);\r\nspec_l2->id = MLX4_NET_TRANS_RULE_ID_ETH;\r\nmemcpy(spec_l2->eth.dst_mac_msk, &mac_msk, ETH_ALEN);\r\nif ((cmd->fs.flow_type & ~FLOW_EXT) != ETHER_FLOW)\r\nmemcpy(spec_l2->eth.dst_mac, &be_mac, ETH_ALEN);\r\nif ((cmd->fs.flow_type & FLOW_EXT) && cmd->fs.m_ext.vlan_tci) {\r\nspec_l2->eth.vlan_id = cmd->fs.h_ext.vlan_tci;\r\nspec_l2->eth.vlan_id_msk = cpu_to_be16(0xfff);\r\n}\r\nlist_add_tail(&spec_l2->list, rule_list_h);\r\nswitch (cmd->fs.flow_type & ~FLOW_EXT) {\r\ncase ETHER_FLOW:\r\neth_spec = &cmd->fs.h_u.ether_spec;\r\nmemcpy(&spec_l2->eth.dst_mac, eth_spec->h_dest, ETH_ALEN);\r\nspec_l2->eth.ether_type = eth_spec->h_proto;\r\nif (eth_spec->h_proto)\r\nspec_l2->eth.ether_type_enable = 1;\r\nbreak;\r\ncase IP_USER_FLOW:\r\nerr = add_ip_rule(priv, cmd, rule_list_h);\r\nbreak;\r\ncase TCP_V4_FLOW:\r\nerr = add_tcp_udp_rule(priv, cmd, rule_list_h, TCP_V4_FLOW);\r\nbreak;\r\ncase UDP_V4_FLOW:\r\nerr = add_tcp_udp_rule(priv, cmd, rule_list_h, UDP_V4_FLOW);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int mlx4_en_flow_replace(struct net_device *dev,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nint err;\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct ethtool_flow_id *loc_rule;\r\nstruct mlx4_spec_list *spec, *tmp_spec;\r\nu32 qpn;\r\nu64 reg_id;\r\nstruct mlx4_net_trans_rule rule = {\r\n.queue_mode = MLX4_NET_TRANS_Q_FIFO,\r\n.exclusive = 0,\r\n.allow_loopback = 1,\r\n.promisc_mode = MLX4_FS_PROMISC_NONE,\r\n};\r\nrule.port = priv->port;\r\nrule.priority = MLX4_DOMAIN_ETHTOOL | cmd->fs.location;\r\nINIT_LIST_HEAD(&rule.list);\r\nif (cmd->fs.ring_cookie == RX_CLS_FLOW_DISC)\r\nqpn = priv->drop_qp.qpn;\r\nelse if (cmd->fs.ring_cookie & EN_ETHTOOL_QP_ATTACH) {\r\nqpn = cmd->fs.ring_cookie & (EN_ETHTOOL_QP_ATTACH - 1);\r\n} else {\r\nif (cmd->fs.ring_cookie >= priv->rx_ring_num) {\r\nen_warn(priv, "rxnfc: RX ring (%llu) doesn't exist.\n",\r\ncmd->fs.ring_cookie);\r\nreturn -EINVAL;\r\n}\r\nqpn = priv->rss_map.qps[cmd->fs.ring_cookie].qpn;\r\nif (!qpn) {\r\nen_warn(priv, "rxnfc: RX ring (%llu) is inactive.\n",\r\ncmd->fs.ring_cookie);\r\nreturn -EINVAL;\r\n}\r\n}\r\nrule.qpn = qpn;\r\nerr = mlx4_en_ethtool_to_net_trans_rule(dev, cmd, &rule.list);\r\nif (err)\r\ngoto out_free_list;\r\nloc_rule = &priv->ethtool_rules[cmd->fs.location];\r\nif (loc_rule->id) {\r\nerr = mlx4_flow_detach(priv->mdev->dev, loc_rule->id);\r\nif (err) {\r\nen_err(priv, "Fail to detach network rule at location %d. registration id = %llx\n",\r\ncmd->fs.location, loc_rule->id);\r\ngoto out_free_list;\r\n}\r\nloc_rule->id = 0;\r\nmemset(&loc_rule->flow_spec, 0,\r\nsizeof(struct ethtool_rx_flow_spec));\r\n}\r\nerr = mlx4_flow_attach(priv->mdev->dev, &rule, &reg_id);\r\nif (err) {\r\nen_err(priv, "Fail to attach network rule at location %d.\n",\r\ncmd->fs.location);\r\ngoto out_free_list;\r\n}\r\nloc_rule->id = reg_id;\r\nmemcpy(&loc_rule->flow_spec, &cmd->fs,\r\nsizeof(struct ethtool_rx_flow_spec));\r\nout_free_list:\r\nlist_for_each_entry_safe(spec, tmp_spec, &rule.list, list) {\r\nlist_del(&spec->list);\r\nkfree(spec);\r\n}\r\nreturn err;\r\n}\r\nstatic int mlx4_en_flow_detach(struct net_device *dev,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nint err = 0;\r\nstruct ethtool_flow_id *rule;\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nif (cmd->fs.location >= MAX_NUM_OF_FS_RULES)\r\nreturn -EINVAL;\r\nrule = &priv->ethtool_rules[cmd->fs.location];\r\nif (!rule->id) {\r\nerr = -ENOENT;\r\ngoto out;\r\n}\r\nerr = mlx4_flow_detach(priv->mdev->dev, rule->id);\r\nif (err) {\r\nen_err(priv, "Fail to detach network rule at location %d. registration id = 0x%llx\n",\r\ncmd->fs.location, rule->id);\r\ngoto out;\r\n}\r\nrule->id = 0;\r\nmemset(&rule->flow_spec, 0, sizeof(struct ethtool_rx_flow_spec));\r\nout:\r\nreturn err;\r\n}\r\nstatic int mlx4_en_get_flow(struct net_device *dev, struct ethtool_rxnfc *cmd,\r\nint loc)\r\n{\r\nint err = 0;\r\nstruct ethtool_flow_id *rule;\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nif (loc < 0 || loc >= MAX_NUM_OF_FS_RULES)\r\nreturn -EINVAL;\r\nrule = &priv->ethtool_rules[loc];\r\nif (rule->id)\r\nmemcpy(&cmd->fs, &rule->flow_spec,\r\nsizeof(struct ethtool_rx_flow_spec));\r\nelse\r\nerr = -ENOENT;\r\nreturn err;\r\n}\r\nstatic int mlx4_en_get_num_flows(struct mlx4_en_priv *priv)\r\n{\r\nint i, res = 0;\r\nfor (i = 0; i < MAX_NUM_OF_FS_RULES; i++) {\r\nif (priv->ethtool_rules[i].id)\r\nres++;\r\n}\r\nreturn res;\r\n}\r\nstatic int mlx4_en_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\r\nu32 *rule_locs)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint err = 0;\r\nint i = 0, priority = 0;\r\nif ((cmd->cmd == ETHTOOL_GRXCLSRLCNT ||\r\ncmd->cmd == ETHTOOL_GRXCLSRULE ||\r\ncmd->cmd == ETHTOOL_GRXCLSRLALL) &&\r\nmdev->dev->caps.steering_mode != MLX4_STEERING_MODE_DEVICE_MANAGED)\r\nreturn -EINVAL;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\ncmd->data = priv->rx_ring_num;\r\nbreak;\r\ncase ETHTOOL_GRXCLSRLCNT:\r\ncmd->rule_cnt = mlx4_en_get_num_flows(priv);\r\nbreak;\r\ncase ETHTOOL_GRXCLSRULE:\r\nerr = mlx4_en_get_flow(dev, cmd, cmd->fs.location);\r\nbreak;\r\ncase ETHTOOL_GRXCLSRLALL:\r\nwhile ((!err || err == -ENOENT) && priority < cmd->rule_cnt) {\r\nerr = mlx4_en_get_flow(dev, cmd, i);\r\nif (!err)\r\nrule_locs[priority++] = i;\r\ni++;\r\n}\r\nerr = 0;\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int mlx4_en_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\r\n{\r\nint err = 0;\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nif (mdev->dev->caps.steering_mode != MLX4_STEERING_MODE_DEVICE_MANAGED)\r\nreturn -EINVAL;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_SRXCLSRLINS:\r\nerr = mlx4_en_flow_replace(dev, cmd);\r\nbreak;\r\ncase ETHTOOL_SRXCLSRLDEL:\r\nerr = mlx4_en_flow_detach(dev, cmd);\r\nbreak;\r\ndefault:\r\nen_warn(priv, "Unsupported ethtool command. (%d)\n", cmd->cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}
