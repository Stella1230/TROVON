static const char *fit_type_name(unsigned char type)\r\n{\r\nstruct fit_type_map_t const *mapp;\r\nfor (mapp = fit_entry_types; mapp->type != 0xff; mapp++)\r\nif (type == mapp->type)\r\nreturn mapp->name;\r\nif ((type > FIT_ENTRY_PAL_A) && (type < FIT_ENTRY_UNUSED))\r\nreturn "OEM type";\r\nif ((type > FIT_ENTRY_PAL_B) && (type < FIT_ENTRY_PAL_A))\r\nreturn "Reserved";\r\nreturn "Unknown type";\r\n}\r\nstatic int\r\nget_fit_entry(unsigned long nasid, int index, unsigned long *fentry,\r\nchar *banner, int banlen)\r\n{\r\nreturn ia64_sn_get_fit_compt(nasid, index, fentry, banner, banlen);\r\n}\r\nstatic int dump_fit_entry(char *page, unsigned long *fentry)\r\n{\r\nunsigned type;\r\ntype = FIT_TYPE(fentry[1]);\r\nreturn sprintf(page, "%02x %-25s %x.%02x %016lx %u\n",\r\ntype,\r\nfit_type_name(type),\r\nFIT_MAJOR(fentry[1]), FIT_MINOR(fentry[1]),\r\nfentry[0],\r\n(unsigned)(fentry[1] & 0xffffff) * 16);\r\n}\r\nstatic int\r\ndump_fit(char *page, unsigned long nasid)\r\n{\r\nunsigned long fentry[2];\r\nint index;\r\nchar *p;\r\np = page;\r\nfor (index=0;;index++) {\r\nBUG_ON(index * 60 > PAGE_SIZE);\r\nif (get_fit_entry(nasid, index, fentry, NULL, 0))\r\nbreak;\r\np += dump_fit_entry(p, fentry);\r\n}\r\nreturn p - page;\r\n}\r\nstatic int\r\ndump_version(char *page, unsigned long nasid)\r\n{\r\nunsigned long fentry[2];\r\nchar banner[128];\r\nint index;\r\nint len;\r\nfor (index = 0; ; index++) {\r\nif (get_fit_entry(nasid, index, fentry, banner,\r\nsizeof(banner)))\r\nreturn 0;\r\nif (FIT_TYPE(fentry[1]) == FIT_ENTRY_SAL_A)\r\nbreak;\r\n}\r\nlen = sprintf(page, "%x.%02x\n", FIT_MAJOR(fentry[1]),\r\nFIT_MINOR(fentry[1]));\r\npage += len;\r\nif (banner[0])\r\nlen += snprintf(page, PAGE_SIZE-len, "%s\n", banner);\r\nreturn len;\r\n}\r\nstatic int\r\nproc_calc_metrics(char *page, char **start, off_t off, int count, int *eof,\r\nint len)\r\n{\r\nif (len <= off + count)\r\n*eof = 1;\r\n*start = page + off;\r\nlen -= off;\r\nif (len > count)\r\nlen = count;\r\nif (len < 0)\r\nlen = 0;\r\nreturn len;\r\n}\r\nstatic int\r\nread_version_entry(char *page, char **start, off_t off, int count, int *eof,\r\nvoid *data)\r\n{\r\nint len;\r\nlen = dump_version(page, (unsigned long)data);\r\nlen = proc_calc_metrics(page, start, off, count, eof, len);\r\nreturn len;\r\n}\r\nstatic int\r\nread_fit_entry(char *page, char **start, off_t off, int count, int *eof,\r\nvoid *data)\r\n{\r\nint len;\r\nlen = dump_fit(page, (unsigned long)data);\r\nlen = proc_calc_metrics(page, start, off, count, eof, len);\r\nreturn len;\r\n}\r\nint __init prominfo_init(void)\r\n{\r\nstruct proc_dir_entry **entp;\r\ncnodeid_t cnodeid;\r\nunsigned long nasid;\r\nint size;\r\nchar name[NODE_NAME_LEN];\r\nif (!ia64_platform_is("sn2"))\r\nreturn 0;\r\nsize = num_online_nodes() * sizeof(struct proc_dir_entry *);\r\nproc_entries = kzalloc(size, GFP_KERNEL);\r\nif (!proc_entries)\r\nreturn -ENOMEM;\r\nsgi_prominfo_entry = proc_mkdir("sgi_prominfo", NULL);\r\nentp = proc_entries;\r\nfor_each_online_node(cnodeid) {\r\nsprintf(name, "node%d", cnodeid);\r\n*entp = proc_mkdir(name, sgi_prominfo_entry);\r\nnasid = cnodeid_to_nasid(cnodeid);\r\ncreate_proc_read_entry("fit", 0, *entp, read_fit_entry,\r\n(void *)nasid);\r\ncreate_proc_read_entry("version", 0, *entp,\r\nread_version_entry, (void *)nasid);\r\nentp++;\r\n}\r\nreturn 0;\r\n}\r\nvoid __exit prominfo_exit(void)\r\n{\r\nstruct proc_dir_entry **entp;\r\nunsigned int cnodeid;\r\nchar name[NODE_NAME_LEN];\r\nentp = proc_entries;\r\nfor_each_online_node(cnodeid) {\r\nremove_proc_entry("fit", *entp);\r\nremove_proc_entry("version", *entp);\r\nsprintf(name, "node%d", cnodeid);\r\nremove_proc_entry(name, sgi_prominfo_entry);\r\nentp++;\r\n}\r\nremove_proc_entry("sgi_prominfo", NULL);\r\nkfree(proc_entries);\r\n}
