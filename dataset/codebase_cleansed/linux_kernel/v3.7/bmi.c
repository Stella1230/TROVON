int ath6kl_bmi_done(struct ath6kl *ar)\r\n{\r\nint ret;\r\nu32 cid = BMI_DONE;\r\nif (ar->bmi.done_sent) {\r\nath6kl_dbg(ATH6KL_DBG_BMI, "bmi done skipped\n");\r\nreturn 0;\r\n}\r\nar->bmi.done_sent = true;\r\nret = ath6kl_hif_bmi_write(ar, (u8 *)&cid, sizeof(cid));\r\nif (ret) {\r\nath6kl_err("Unable to send bmi done: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint ath6kl_bmi_get_target_info(struct ath6kl *ar,\r\nstruct ath6kl_bmi_target_info *targ_info)\r\n{\r\nint ret;\r\nu32 cid = BMI_GET_TARGET_INFO;\r\nif (ar->bmi.done_sent) {\r\nath6kl_err("bmi done sent already, cmd %d disallowed\n", cid);\r\nreturn -EACCES;\r\n}\r\nret = ath6kl_hif_bmi_write(ar, (u8 *)&cid, sizeof(cid));\r\nif (ret) {\r\nath6kl_err("Unable to send get target info: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (ar->hif_type == ATH6KL_HIF_TYPE_USB) {\r\nret = ath6kl_hif_bmi_read(ar, (u8 *)targ_info,\r\nsizeof(*targ_info));\r\n} else {\r\nret = ath6kl_hif_bmi_read(ar, (u8 *)&targ_info->version,\r\nsizeof(targ_info->version));\r\n}\r\nif (ret) {\r\nath6kl_err("Unable to recv target info: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (le32_to_cpu(targ_info->version) == TARGET_VERSION_SENTINAL) {\r\nret = ath6kl_hif_bmi_read(ar,\r\n(u8 *)&targ_info->byte_count,\r\nsizeof(targ_info->byte_count));\r\nif (ret) {\r\nath6kl_err("unable to read target info byte count: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (le32_to_cpu(targ_info->byte_count) != sizeof(*targ_info)) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nret = ath6kl_hif_bmi_read(ar,\r\n((u8 *)targ_info) +\r\nsizeof(targ_info->byte_count),\r\nsizeof(*targ_info) -\r\nsizeof(targ_info->byte_count));\r\nif (ret) {\r\nath6kl_err("Unable to read target info (%d bytes): %d\n",\r\ntarg_info->byte_count, ret);\r\nreturn ret;\r\n}\r\n}\r\nath6kl_dbg(ATH6KL_DBG_BMI, "target info (ver: 0x%x type: 0x%x)\n",\r\ntarg_info->version, targ_info->type);\r\nreturn 0;\r\n}\r\nint ath6kl_bmi_read(struct ath6kl *ar, u32 addr, u8 *buf, u32 len)\r\n{\r\nu32 cid = BMI_READ_MEMORY;\r\nint ret;\r\nu32 offset;\r\nu32 len_remain, rx_len;\r\nu16 size;\r\nif (ar->bmi.done_sent) {\r\nath6kl_err("bmi done sent already, cmd %d disallowed\n", cid);\r\nreturn -EACCES;\r\n}\r\nsize = ar->bmi.max_data_size + sizeof(cid) + sizeof(addr) + sizeof(len);\r\nif (size > ar->bmi.max_cmd_size) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nmemset(ar->bmi.cmd_buf, 0, size);\r\nath6kl_dbg(ATH6KL_DBG_BMI,\r\n"bmi read memory: device: addr: 0x%x, len: %d\n",\r\naddr, len);\r\nlen_remain = len;\r\nwhile (len_remain) {\r\nrx_len = (len_remain < ar->bmi.max_data_size) ?\r\nlen_remain : ar->bmi.max_data_size;\r\noffset = 0;\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\r\noffset += sizeof(addr);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &rx_len, sizeof(rx_len));\r\noffset += sizeof(len);\r\nret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\r\nif (ret) {\r\nath6kl_err("Unable to write to the device: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = ath6kl_hif_bmi_read(ar, ar->bmi.cmd_buf, rx_len);\r\nif (ret) {\r\nath6kl_err("Unable to read from the device: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nmemcpy(&buf[len - len_remain], ar->bmi.cmd_buf, rx_len);\r\nlen_remain -= rx_len; addr += rx_len;\r\n}\r\nreturn 0;\r\n}\r\nint ath6kl_bmi_write(struct ath6kl *ar, u32 addr, u8 *buf, u32 len)\r\n{\r\nu32 cid = BMI_WRITE_MEMORY;\r\nint ret;\r\nu32 offset;\r\nu32 len_remain, tx_len;\r\nconst u32 header = sizeof(cid) + sizeof(addr) + sizeof(len);\r\nu8 aligned_buf[400];\r\nu8 *src;\r\nif (ar->bmi.done_sent) {\r\nath6kl_err("bmi done sent already, cmd %d disallowed\n", cid);\r\nreturn -EACCES;\r\n}\r\nif ((ar->bmi.max_data_size + header) > ar->bmi.max_cmd_size) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nif (WARN_ON(ar->bmi.max_data_size > sizeof(aligned_buf)))\r\nreturn -E2BIG;\r\nmemset(ar->bmi.cmd_buf, 0, ar->bmi.max_data_size + header);\r\nath6kl_dbg(ATH6KL_DBG_BMI,\r\n"bmi write memory: addr: 0x%x, len: %d\n", addr, len);\r\nlen_remain = len;\r\nwhile (len_remain) {\r\nsrc = &buf[len - len_remain];\r\nif (len_remain < (ar->bmi.max_data_size - header)) {\r\nif (len_remain & 3) {\r\nlen_remain = len_remain +\r\n(4 - (len_remain & 3));\r\nmemcpy(aligned_buf, src, len_remain);\r\nsrc = aligned_buf;\r\n}\r\ntx_len = len_remain;\r\n} else {\r\ntx_len = (ar->bmi.max_data_size - header);\r\n}\r\noffset = 0;\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\r\noffset += sizeof(addr);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &tx_len, sizeof(tx_len));\r\noffset += sizeof(tx_len);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), src, tx_len);\r\noffset += tx_len;\r\nret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\r\nif (ret) {\r\nath6kl_err("Unable to write to the device: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nlen_remain -= tx_len; addr += tx_len;\r\n}\r\nreturn 0;\r\n}\r\nint ath6kl_bmi_execute(struct ath6kl *ar, u32 addr, u32 *param)\r\n{\r\nu32 cid = BMI_EXECUTE;\r\nint ret;\r\nu32 offset;\r\nu16 size;\r\nif (ar->bmi.done_sent) {\r\nath6kl_err("bmi done sent already, cmd %d disallowed\n", cid);\r\nreturn -EACCES;\r\n}\r\nsize = sizeof(cid) + sizeof(addr) + sizeof(param);\r\nif (size > ar->bmi.max_cmd_size) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nmemset(ar->bmi.cmd_buf, 0, size);\r\nath6kl_dbg(ATH6KL_DBG_BMI, "bmi execute: addr: 0x%x, param: %d)\n",\r\naddr, *param);\r\noffset = 0;\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\r\noffset += sizeof(addr);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), param, sizeof(*param));\r\noffset += sizeof(*param);\r\nret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\r\nif (ret) {\r\nath6kl_err("Unable to write to the device: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ath6kl_hif_bmi_read(ar, ar->bmi.cmd_buf, sizeof(*param));\r\nif (ret) {\r\nath6kl_err("Unable to read from the device: %d\n", ret);\r\nreturn ret;\r\n}\r\nmemcpy(param, ar->bmi.cmd_buf, sizeof(*param));\r\nreturn 0;\r\n}\r\nint ath6kl_bmi_set_app_start(struct ath6kl *ar, u32 addr)\r\n{\r\nu32 cid = BMI_SET_APP_START;\r\nint ret;\r\nu32 offset;\r\nu16 size;\r\nif (ar->bmi.done_sent) {\r\nath6kl_err("bmi done sent already, cmd %d disallowed\n", cid);\r\nreturn -EACCES;\r\n}\r\nsize = sizeof(cid) + sizeof(addr);\r\nif (size > ar->bmi.max_cmd_size) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nmemset(ar->bmi.cmd_buf, 0, size);\r\nath6kl_dbg(ATH6KL_DBG_BMI, "bmi set app start: addr: 0x%x\n", addr);\r\noffset = 0;\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\r\noffset += sizeof(addr);\r\nret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\r\nif (ret) {\r\nath6kl_err("Unable to write to the device: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint ath6kl_bmi_reg_read(struct ath6kl *ar, u32 addr, u32 *param)\r\n{\r\nu32 cid = BMI_READ_SOC_REGISTER;\r\nint ret;\r\nu32 offset;\r\nu16 size;\r\nif (ar->bmi.done_sent) {\r\nath6kl_err("bmi done sent already, cmd %d disallowed\n", cid);\r\nreturn -EACCES;\r\n}\r\nsize = sizeof(cid) + sizeof(addr);\r\nif (size > ar->bmi.max_cmd_size) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nmemset(ar->bmi.cmd_buf, 0, size);\r\nath6kl_dbg(ATH6KL_DBG_BMI, "bmi read SOC reg: addr: 0x%x\n", addr);\r\noffset = 0;\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\r\noffset += sizeof(addr);\r\nret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\r\nif (ret) {\r\nath6kl_err("Unable to write to the device: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ath6kl_hif_bmi_read(ar, ar->bmi.cmd_buf, sizeof(*param));\r\nif (ret) {\r\nath6kl_err("Unable to read from the device: %d\n", ret);\r\nreturn ret;\r\n}\r\nmemcpy(param, ar->bmi.cmd_buf, sizeof(*param));\r\nreturn 0;\r\n}\r\nint ath6kl_bmi_reg_write(struct ath6kl *ar, u32 addr, u32 param)\r\n{\r\nu32 cid = BMI_WRITE_SOC_REGISTER;\r\nint ret;\r\nu32 offset;\r\nu16 size;\r\nif (ar->bmi.done_sent) {\r\nath6kl_err("bmi done sent already, cmd %d disallowed\n", cid);\r\nreturn -EACCES;\r\n}\r\nsize = sizeof(cid) + sizeof(addr) + sizeof(param);\r\nif (size > ar->bmi.max_cmd_size) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nmemset(ar->bmi.cmd_buf, 0, size);\r\nath6kl_dbg(ATH6KL_DBG_BMI,\r\n"bmi write SOC reg: addr: 0x%x, param: %d\n",\r\naddr, param);\r\noffset = 0;\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\r\noffset += sizeof(addr);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &param, sizeof(param));\r\noffset += sizeof(param);\r\nret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\r\nif (ret) {\r\nath6kl_err("Unable to write to the device: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint ath6kl_bmi_lz_data(struct ath6kl *ar, u8 *buf, u32 len)\r\n{\r\nu32 cid = BMI_LZ_DATA;\r\nint ret;\r\nu32 offset;\r\nu32 len_remain, tx_len;\r\nconst u32 header = sizeof(cid) + sizeof(len);\r\nu16 size;\r\nif (ar->bmi.done_sent) {\r\nath6kl_err("bmi done sent already, cmd %d disallowed\n", cid);\r\nreturn -EACCES;\r\n}\r\nsize = ar->bmi.max_data_size + header;\r\nif (size > ar->bmi.max_cmd_size) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nmemset(ar->bmi.cmd_buf, 0, size);\r\nath6kl_dbg(ATH6KL_DBG_BMI, "bmi send LZ data: len: %d)\n",\r\nlen);\r\nlen_remain = len;\r\nwhile (len_remain) {\r\ntx_len = (len_remain < (ar->bmi.max_data_size - header)) ?\r\nlen_remain : (ar->bmi.max_data_size - header);\r\noffset = 0;\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &tx_len, sizeof(tx_len));\r\noffset += sizeof(tx_len);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &buf[len - len_remain],\r\ntx_len);\r\noffset += tx_len;\r\nret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\r\nif (ret) {\r\nath6kl_err("Unable to write to the device: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nlen_remain -= tx_len;\r\n}\r\nreturn 0;\r\n}\r\nint ath6kl_bmi_lz_stream_start(struct ath6kl *ar, u32 addr)\r\n{\r\nu32 cid = BMI_LZ_STREAM_START;\r\nint ret;\r\nu32 offset;\r\nu16 size;\r\nif (ar->bmi.done_sent) {\r\nath6kl_err("bmi done sent already, cmd %d disallowed\n", cid);\r\nreturn -EACCES;\r\n}\r\nsize = sizeof(cid) + sizeof(addr);\r\nif (size > ar->bmi.max_cmd_size) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nmemset(ar->bmi.cmd_buf, 0, size);\r\nath6kl_dbg(ATH6KL_DBG_BMI,\r\n"bmi LZ stream start: addr: 0x%x)\n",\r\naddr);\r\noffset = 0;\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\r\noffset += sizeof(cid);\r\nmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\r\noffset += sizeof(addr);\r\nret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\r\nif (ret) {\r\nath6kl_err("Unable to start LZ stream to the device: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint ath6kl_bmi_fast_download(struct ath6kl *ar, u32 addr, u8 *buf, u32 len)\r\n{\r\nint ret;\r\nu32 last_word = 0;\r\nu32 last_word_offset = len & ~0x3;\r\nu32 unaligned_bytes = len & 0x3;\r\nret = ath6kl_bmi_lz_stream_start(ar, addr);\r\nif (ret)\r\nreturn ret;\r\nif (unaligned_bytes) {\r\nmemcpy(&last_word, &buf[last_word_offset], unaligned_bytes);\r\n}\r\nret = ath6kl_bmi_lz_data(ar, buf, last_word_offset);\r\nif (ret)\r\nreturn ret;\r\nif (unaligned_bytes)\r\nret = ath6kl_bmi_lz_data(ar, (u8 *)&last_word, 4);\r\nif (!ret) {\r\nret = ath6kl_bmi_lz_stream_start(ar, 0x00);\r\n}\r\nreturn ret;\r\n}\r\nvoid ath6kl_bmi_reset(struct ath6kl *ar)\r\n{\r\nar->bmi.done_sent = false;\r\n}\r\nint ath6kl_bmi_init(struct ath6kl *ar)\r\n{\r\nif (WARN_ON(ar->bmi.max_data_size == 0))\r\nreturn -EINVAL;\r\nar->bmi.max_cmd_size = ar->bmi.max_data_size + (sizeof(u32) * 3);\r\nar->bmi.cmd_buf = kzalloc(ar->bmi.max_cmd_size, GFP_ATOMIC);\r\nif (!ar->bmi.cmd_buf)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid ath6kl_bmi_cleanup(struct ath6kl *ar)\r\n{\r\nkfree(ar->bmi.cmd_buf);\r\nar->bmi.cmd_buf = NULL;\r\n}
