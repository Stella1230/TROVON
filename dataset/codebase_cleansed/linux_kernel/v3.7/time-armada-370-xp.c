static u32 notrace armada_370_xp_read_sched_clock(void)\r\n{\r\nreturn ~readl(timer_base + TIMER0_VAL_OFF);\r\n}\r\nstatic int\r\narmada_370_xp_clkevt_next_event(unsigned long delta,\r\nstruct clock_event_device *dev)\r\n{\r\nu32 u;\r\nwritel(TIMER1_CLR_MASK, timer_base + TIMER_EVENTS_STATUS);\r\nwritel(delta, timer_base + TIMER1_VAL_OFF);\r\nu = readl(timer_base + TIMER_CTRL_OFF);\r\nu = ((u & ~TIMER1_RELOAD_EN) | TIMER1_EN |\r\nTIMER1_DIV(TIMER_DIVIDER_SHIFT));\r\nwritel(u, timer_base + TIMER_CTRL_OFF);\r\nreturn 0;\r\n}\r\nstatic void\r\narmada_370_xp_clkevt_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *dev)\r\n{\r\nu32 u;\r\nif (mode == CLOCK_EVT_MODE_PERIODIC) {\r\nwritel(ticks_per_jiffy - 1, timer_base + TIMER1_RELOAD_OFF);\r\nwritel(ticks_per_jiffy - 1, timer_base + TIMER1_VAL_OFF);\r\nu = readl(timer_base + TIMER_CTRL_OFF);\r\nwritel((u | TIMER1_EN | TIMER1_RELOAD_EN |\r\nTIMER1_DIV(TIMER_DIVIDER_SHIFT)),\r\ntimer_base + TIMER_CTRL_OFF);\r\n} else {\r\nu = readl(timer_base + TIMER_CTRL_OFF);\r\nwritel(u & ~TIMER1_EN, timer_base + TIMER_CTRL_OFF);\r\nwritel(TIMER1_CLR_MASK, timer_base + TIMER_EVENTS_STATUS);\r\n}\r\n}\r\nstatic irqreturn_t armada_370_xp_timer_interrupt(int irq, void *dev_id)\r\n{\r\nwritel(TIMER1_CLR_MASK, timer_base + TIMER_EVENTS_STATUS);\r\narmada_370_xp_clkevt.event_handler(&armada_370_xp_clkevt);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid __init armada_370_xp_timer_init(void)\r\n{\r\nu32 u;\r\nstruct device_node *np;\r\nunsigned int timer_clk;\r\nint ret;\r\nnp = of_find_compatible_node(NULL, NULL, "marvell,armada-370-xp-timer");\r\ntimer_base = of_iomap(np, 0);\r\nWARN_ON(!timer_base);\r\nif (of_find_property(np, "marvell,timer-25Mhz", NULL)) {\r\nu = readl(timer_base + TIMER_CTRL_OFF);\r\nwritel(u | TIMER0_25MHZ | TIMER1_25MHZ,\r\ntimer_base + TIMER_CTRL_OFF);\r\ntimer_clk = 25000000;\r\n} else {\r\nu32 clk = 0;\r\nret = of_property_read_u32(np, "clock-frequency", &clk);\r\nWARN_ON(!clk || ret < 0);\r\nu = readl(timer_base + TIMER_CTRL_OFF);\r\nwritel(u & ~(TIMER0_25MHZ | TIMER1_25MHZ),\r\ntimer_base + TIMER_CTRL_OFF);\r\ntimer_clk = clk / TIMER_DIVIDER;\r\n}\r\ntimer_irq = irq_of_parse_and_map(np, 1);\r\nticks_per_jiffy = (timer_clk + HZ / 2) / HZ;\r\nsetup_sched_clock(armada_370_xp_read_sched_clock, 32, timer_clk);\r\nwritel(0xffffffff, timer_base + TIMER0_VAL_OFF);\r\nwritel(0xffffffff, timer_base + TIMER0_RELOAD_OFF);\r\nu = readl(timer_base + TIMER_CTRL_OFF);\r\nwritel((u | TIMER0_EN | TIMER0_RELOAD_EN |\r\nTIMER0_DIV(TIMER_DIVIDER_SHIFT)), timer_base + TIMER_CTRL_OFF);\r\nclocksource_mmio_init(timer_base + TIMER0_VAL_OFF,\r\n"armada_370_xp_clocksource",\r\ntimer_clk, 300, 32, clocksource_mmio_readl_down);\r\nsetup_irq(timer_irq, &armada_370_xp_timer_irq);\r\narmada_370_xp_clkevt.cpumask = cpumask_of(0);\r\nclockevents_config_and_register(&armada_370_xp_clkevt,\r\ntimer_clk, 1, 0xfffffffe);\r\n}
