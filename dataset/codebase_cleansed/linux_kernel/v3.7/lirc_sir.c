static void on(void)\r\n{\r\nPPSR |= PPC_TXD2;\r\n}\r\nstatic void off(void)\r\n{\r\nPPSR &= ~PPC_TXD2;\r\n}\r\nstatic inline unsigned int sinp(int offset)\r\n{\r\nreturn inb(io + offset);\r\n}\r\nstatic inline void soutp(int offset, int value)\r\n{\r\noutb(value, io + offset);\r\n}\r\nstatic void safe_udelay(unsigned long usecs)\r\n{\r\nwhile (usecs > MAX_UDELAY_US) {\r\nudelay(MAX_UDELAY_US);\r\nusecs -= MAX_UDELAY_US;\r\n}\r\nudelay(usecs);\r\n}\r\nstatic unsigned int lirc_poll(struct file *file, poll_table *wait)\r\n{\r\npoll_wait(file, &lirc_read_queue, wait);\r\nif (rx_head != rx_tail)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic ssize_t lirc_read(struct file *file, char *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nint n = 0;\r\nint retval = 0;\r\nDECLARE_WAITQUEUE(wait, current);\r\nif (count % sizeof(int))\r\nreturn -EINVAL;\r\nadd_wait_queue(&lirc_read_queue, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (n < count) {\r\nif (rx_head != rx_tail) {\r\nif (copy_to_user((void *) buf + n,\r\n(void *) (rx_buf + rx_head),\r\nsizeof(int))) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nrx_head = (rx_head + 1) & (RBUF_LEN - 1);\r\nn += sizeof(int);\r\n} else {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nschedule();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n}\r\n}\r\nremove_wait_queue(&lirc_read_queue, &wait);\r\nset_current_state(TASK_RUNNING);\r\nreturn n ? n : retval;\r\n}\r\nstatic ssize_t lirc_write(struct file *file, const char *buf, size_t n,\r\nloff_t *pos)\r\n{\r\nunsigned long flags;\r\nint i, count;\r\nint *tx_buf;\r\ncount = n / sizeof(int);\r\nif (n % sizeof(int) || count % 2 == 0)\r\nreturn -EINVAL;\r\ntx_buf = memdup_user(buf, n);\r\nif (IS_ERR(tx_buf))\r\nreturn PTR_ERR(tx_buf);\r\ni = 0;\r\n#ifdef LIRC_ON_SA1100\r\nSer2UTCR3 = 0;\r\n#endif\r\nlocal_irq_save(flags);\r\nwhile (1) {\r\nif (i >= count)\r\nbreak;\r\nif (tx_buf[i])\r\nsend_pulse(tx_buf[i]);\r\ni++;\r\nif (i >= count)\r\nbreak;\r\nif (tx_buf[i])\r\nsend_space(tx_buf[i]);\r\ni++;\r\n}\r\nlocal_irq_restore(flags);\r\n#ifdef LIRC_ON_SA1100\r\noff();\r\nudelay(1000);\r\nSer2UTCR3 = 0;\r\nSer2UTSR0 &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);\r\nSer2UTCR3 = UTCR3_RXE|UTCR3_RIE;\r\n#endif\r\nkfree(tx_buf);\r\nreturn count;\r\n}\r\nstatic long lirc_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\r\n{\r\nint retval = 0;\r\n__u32 value = 0;\r\n#ifdef LIRC_ON_SA1100\r\nif (cmd == LIRC_GET_FEATURES)\r\nvalue = LIRC_CAN_SEND_PULSE |\r\nLIRC_CAN_SET_SEND_DUTY_CYCLE |\r\nLIRC_CAN_SET_SEND_CARRIER |\r\nLIRC_CAN_REC_MODE2;\r\nelse if (cmd == LIRC_GET_SEND_MODE)\r\nvalue = LIRC_MODE_PULSE;\r\nelse if (cmd == LIRC_GET_REC_MODE)\r\nvalue = LIRC_MODE_MODE2;\r\n#else\r\nif (cmd == LIRC_GET_FEATURES)\r\nvalue = LIRC_CAN_SEND_PULSE | LIRC_CAN_REC_MODE2;\r\nelse if (cmd == LIRC_GET_SEND_MODE)\r\nvalue = LIRC_MODE_PULSE;\r\nelse if (cmd == LIRC_GET_REC_MODE)\r\nvalue = LIRC_MODE_MODE2;\r\n#endif\r\nswitch (cmd) {\r\ncase LIRC_GET_FEATURES:\r\ncase LIRC_GET_SEND_MODE:\r\ncase LIRC_GET_REC_MODE:\r\nretval = put_user(value, (__u32 *) arg);\r\nbreak;\r\ncase LIRC_SET_SEND_MODE:\r\ncase LIRC_SET_REC_MODE:\r\nretval = get_user(value, (__u32 *) arg);\r\nbreak;\r\n#ifdef LIRC_ON_SA1100\r\ncase LIRC_SET_SEND_DUTY_CYCLE:\r\nretval = get_user(value, (__u32 *) arg);\r\nif (retval)\r\nreturn retval;\r\nif (value <= 0 || value > 100)\r\nreturn -EINVAL;\r\nduty_cycle = value;\r\npulse_width = (unsigned long) duty_cycle*10000/freq;\r\nspace_width = (unsigned long) 1000000L/freq-pulse_width;\r\nif (pulse_width >= LIRC_ON_SA1100_TRANSMITTER_LATENCY)\r\npulse_width -= LIRC_ON_SA1100_TRANSMITTER_LATENCY;\r\nif (space_width >= LIRC_ON_SA1100_TRANSMITTER_LATENCY)\r\nspace_width -= LIRC_ON_SA1100_TRANSMITTER_LATENCY;\r\nbreak;\r\ncase LIRC_SET_SEND_CARRIER:\r\nretval = get_user(value, (__u32 *) arg);\r\nif (retval)\r\nreturn retval;\r\nif (value > 500000 || value < 20000)\r\nreturn -EINVAL;\r\nfreq = value;\r\npulse_width = (unsigned long) duty_cycle*10000/freq;\r\nspace_width = (unsigned long) 1000000L/freq-pulse_width;\r\nif (pulse_width >= LIRC_ON_SA1100_TRANSMITTER_LATENCY)\r\npulse_width -= LIRC_ON_SA1100_TRANSMITTER_LATENCY;\r\nif (space_width >= LIRC_ON_SA1100_TRANSMITTER_LATENCY)\r\nspace_width -= LIRC_ON_SA1100_TRANSMITTER_LATENCY;\r\nbreak;\r\n#endif\r\ndefault:\r\nretval = -ENOIOCTLCMD;\r\n}\r\nif (retval)\r\nreturn retval;\r\nif (cmd == LIRC_SET_REC_MODE) {\r\nif (value != LIRC_MODE_MODE2)\r\nretval = -ENOSYS;\r\n} else if (cmd == LIRC_SET_SEND_MODE) {\r\nif (value != LIRC_MODE_PULSE)\r\nretval = -ENOSYS;\r\n}\r\nreturn retval;\r\n}\r\nstatic void add_read_queue(int flag, unsigned long val)\r\n{\r\nunsigned int new_rx_tail;\r\nint newval;\r\ndprintk("add flag %d with val %lu\n", flag, val);\r\nnewval = val & PULSE_MASK;\r\nif (flag) {\r\nif (newval > TIME_CONST/2)\r\nnewval -= TIME_CONST/2;\r\nelse\r\nnewval = 1;\r\nnewval |= PULSE_BIT;\r\n} else {\r\nnewval += TIME_CONST/2;\r\n}\r\nnew_rx_tail = (rx_tail + 1) & (RBUF_LEN - 1);\r\nif (new_rx_tail == rx_head) {\r\ndprintk("Buffer overrun.\n");\r\nreturn;\r\n}\r\nrx_buf[rx_tail] = newval;\r\nrx_tail = new_rx_tail;\r\nwake_up_interruptible(&lirc_read_queue);\r\n}\r\nstatic int set_use_inc(void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic void set_use_dec(void *data)\r\n{\r\n}\r\nstatic int init_chrdev(void)\r\n{\r\ndriver.dev = &lirc_sir_dev->dev;\r\ndriver.minor = lirc_register_driver(&driver);\r\nif (driver.minor < 0) {\r\nprintk(KERN_ERR LIRC_DRIVER_NAME ": init_chrdev() failed.\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void drop_chrdev(void)\r\n{\r\nlirc_unregister_driver(driver.minor);\r\n}\r\nstatic long delta(struct timeval *tv1, struct timeval *tv2)\r\n{\r\nunsigned long deltv;\r\ndeltv = tv2->tv_sec - tv1->tv_sec;\r\nif (deltv > 15)\r\ndeltv = 0xFFFFFF;\r\nelse\r\ndeltv = deltv*1000000 +\r\ntv2->tv_usec -\r\ntv1->tv_usec;\r\nreturn deltv;\r\n}\r\nstatic void sir_timeout(unsigned long data)\r\n{\r\nunsigned long flags;\r\nunsigned long pulse_end;\r\nspin_lock_irqsave(&timer_lock, flags);\r\nif (last_value) {\r\n#ifndef LIRC_ON_SA1100\r\noutb(UART_FCR_CLEAR_RCVR, io + UART_FCR);\r\n#endif\r\npulse_end = delta(&last_tv, &last_intr_tv);\r\ndprintk("timeout add %d for %lu usec\n", last_value, pulse_end);\r\nadd_read_queue(last_value, pulse_end);\r\nlast_value = 0;\r\nlast_tv = last_intr_tv;\r\n}\r\nspin_unlock_irqrestore(&timer_lock, flags);\r\n}\r\nstatic irqreturn_t sir_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned char data;\r\nstruct timeval curr_tv;\r\nstatic unsigned long deltv;\r\n#ifdef LIRC_ON_SA1100\r\nint status;\r\nstatic int n;\r\nstatus = Ser2UTSR0;\r\nwhile (status & UTSR0_EIF) {\r\nint bstat;\r\nif (debug) {\r\ndprintk("EIF\n");\r\nbstat = Ser2UTSR1;\r\nif (bstat & UTSR1_FRE)\r\ndprintk("frame error\n");\r\nif (bstat & UTSR1_ROR)\r\ndprintk("receive fifo overrun\n");\r\nif (bstat & UTSR1_PRE)\r\ndprintk("parity error\n");\r\n}\r\nbstat = Ser2UTDR;\r\nn++;\r\nstatus = Ser2UTSR0;\r\n}\r\nif (status & (UTSR0_RFS | UTSR0_RID)) {\r\ndo_gettimeofday(&curr_tv);\r\ndeltv = delta(&last_tv, &curr_tv);\r\ndo {\r\ndata = Ser2UTDR;\r\ndprintk("%d data: %u\n", n, (unsigned int) data);\r\nn++;\r\n} while (status & UTSR0_RID &&\r\nSer2UTSR1 & UTSR1_RNE);\r\nif (status&UTSR0_RID) {\r\nadd_read_queue(0 , deltv - n * TIME_CONST);\r\nadd_read_queue(1, n * TIME_CONST);\r\nn = 0;\r\nlast_tv = curr_tv;\r\n}\r\n}\r\nif (status & UTSR0_TFS)\r\nprintk(KERN_ERR "transmit fifo not full, shouldn't happen\n");\r\nstatus &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);\r\nif (status)\r\nSer2UTSR0 = status;\r\n#else\r\nunsigned long deltintrtv;\r\nunsigned long flags;\r\nint iir, lsr;\r\nwhile ((iir = inb(io + UART_IIR) & UART_IIR_ID)) {\r\nswitch (iir&UART_IIR_ID) {\r\ncase UART_IIR_MSI:\r\n(void) inb(io + UART_MSR);\r\nbreak;\r\ncase UART_IIR_RLSI:\r\n(void) inb(io + UART_LSR);\r\nbreak;\r\ncase UART_IIR_THRI:\r\n#if 0\r\nif (lsr & UART_LSR_THRE)\r\noutb(data, io + UART_TX)\r\n#endif\r\nbreak;\r\ncase UART_IIR_RDI:\r\nspin_lock_irqsave(&timer_lock, flags);\r\ndo {\r\ndel_timer(&timerlist);\r\ndata = inb(io + UART_RX);\r\ndo_gettimeofday(&curr_tv);\r\ndeltv = delta(&last_tv, &curr_tv);\r\ndeltintrtv = delta(&last_intr_tv, &curr_tv);\r\ndprintk("t %lu, d %d\n", deltintrtv, (int)data);\r\nif (deltintrtv > TIME_CONST * threshold) {\r\nif (last_value) {\r\ndprintk("GAP\n");\r\nadd_read_queue(last_value,\r\ndeltv -\r\ndeltintrtv);\r\nlast_value = 0;\r\nlast_tv.tv_sec =\r\nlast_intr_tv.tv_sec;\r\nlast_tv.tv_usec =\r\nlast_intr_tv.tv_usec;\r\ndeltv = deltintrtv;\r\n}\r\n}\r\ndata = 1;\r\nif (data ^ last_value) {\r\nadd_read_queue(last_value,\r\ndeltv-TIME_CONST);\r\nlast_value = data;\r\nlast_tv = curr_tv;\r\nif (last_tv.tv_usec >= TIME_CONST) {\r\nlast_tv.tv_usec -= TIME_CONST;\r\n} else {\r\nlast_tv.tv_sec--;\r\nlast_tv.tv_usec += 1000000 -\r\nTIME_CONST;\r\n}\r\n}\r\nlast_intr_tv = curr_tv;\r\nif (data) {\r\ntimerlist.expires = jiffies +\r\nSIR_TIMEOUT;\r\nadd_timer(&timerlist);\r\n}\r\nlsr = inb(io + UART_LSR);\r\n} while (lsr & UART_LSR_DR);\r\nspin_unlock_irqrestore(&timer_lock, flags);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n#endif\r\nreturn IRQ_RETVAL(IRQ_HANDLED);\r\n}\r\nstatic void send_pulse(unsigned long length)\r\n{\r\nunsigned long k, delay;\r\nint flag;\r\nif (length == 0)\r\nreturn;\r\nfor (k = flag = 0; k < length; k += delay, flag = !flag) {\r\nif (flag) {\r\noff();\r\ndelay = space_width;\r\n} else {\r\non();\r\ndelay = pulse_width;\r\n}\r\nsafe_udelay(delay);\r\n}\r\noff();\r\n}\r\nstatic void send_space(unsigned long length)\r\n{\r\nif (length == 0)\r\nreturn;\r\noff();\r\nsafe_udelay(length);\r\n}\r\nstatic void send_space(unsigned long len)\r\n{\r\nsafe_udelay(len);\r\n}\r\nstatic void send_pulse(unsigned long len)\r\n{\r\nlong bytes_out = len / TIME_CONST;\r\nif (bytes_out == 0)\r\nbytes_out++;\r\nwhile (bytes_out--) {\r\noutb(PULSE, io + UART_TX);\r\nwhile (!(inb(io + UART_LSR) & UART_LSR_THRE))\r\n;\r\n}\r\n}\r\nstatic int sa1100_irda_set_power_collie(int state)\r\n{\r\nif (state) {\r\nucb1200_set_io_direction(TC35143_GPIO_IR_ON,\r\nTC35143_IODIR_OUTPUT);\r\nucb1200_set_io(TC35143_GPIO_IR_ON, TC35143_IODAT_LOW);\r\nudelay(100);\r\n} else {\r\nucb1200_set_io_direction(TC35143_GPIO_IR_ON,\r\nTC35143_IODIR_OUTPUT);\r\nucb1200_set_io(TC35143_GPIO_IR_ON, TC35143_IODAT_HIGH);\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_hardware(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hardware_lock, flags);\r\n#ifdef LIRC_ON_SA1100\r\n#ifdef CONFIG_SA1100_BITSY\r\nif (machine_is_bitsy()) {\r\nprintk(KERN_INFO "Power on IR module\n");\r\nset_bitsy_egpio(EGPIO_BITSY_IR_ON);\r\n}\r\n#endif\r\n#ifdef CONFIG_SA1100_COLLIE\r\nsa1100_irda_set_power_collie(3);\r\n#endif\r\nsr.hscr0 = Ser2HSCR0;\r\nsr.utcr0 = Ser2UTCR0;\r\nsr.utcr1 = Ser2UTCR1;\r\nsr.utcr2 = Ser2UTCR2;\r\nsr.utcr3 = Ser2UTCR3;\r\nsr.utcr4 = Ser2UTCR4;\r\nsr.utdr = Ser2UTDR;\r\nsr.utsr0 = Ser2UTSR0;\r\nsr.utsr1 = Ser2UTSR1;\r\nPPDR |= PPC_TXD2;\r\nPSDR |= PPC_TXD2;\r\noff();\r\nSer2UTCR3 = 0;\r\nSer2HSCR0 = sr.hscr0 & (~HSCR0_HSSP);\r\nSer2UTSR0 &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);\r\nSer2UTCR0 = UTCR0_1StpBit|UTCR0_7BitData;\r\nSer2UTCR1 = 0;\r\nSer2UTCR2 = 1;\r\nSer2UTCR4 = UTCR4_HPSIR|UTCR4_Z1_6us;\r\nSer2UTCR3 = UTCR3_RXE|UTCR3_RIE;\r\nSer2UTSR0 &= (UTSR0_RID | UTSR0_RBB | UTSR0_REB);\r\n#elif defined(LIRC_SIR_TEKRAM)\r\nsoutp(UART_FCR,\r\nUART_FCR_CLEAR_RCVR|\r\nUART_FCR_CLEAR_XMIT|\r\nUART_FCR_TRIGGER_1);\r\nsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\r\nsoutp(UART_IER, sinp(UART_IER) &\r\n(~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));\r\nsoutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);\r\nsoutp(UART_DLM, 0);\r\nsoutp(UART_DLL, 12);\r\nsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\nsafe_udelay(50*1000);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_OUT2);\r\nudelay(1*1000);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\nudelay(100);\r\nsoutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);\r\nudelay(7);\r\nsoutp(UART_TX, TEKRAM_115200|TEKRAM_PW);\r\nudelay(1500);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\nudelay(50);\r\nudelay(1500);\r\nprintk(KERN_INFO LIRC_DRIVER_NAME\r\n": 0x%02x\n", sinp(UART_RX));\r\nsoutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);\r\nsoutp(UART_DLM, 0);\r\nsoutp(UART_DLL, 1);\r\nsoutp(UART_LCR, UART_LCR_WLEN8);\r\nsoutp(UART_IER, sinp(UART_IER)|UART_IER_RDI);\r\n#else\r\noutb(0, io + UART_MCR);\r\noutb(0, io + UART_IER);\r\noutb(UART_LCR_DLAB | UART_LCR_WLEN7, io + UART_LCR);\r\noutb(1, io + UART_DLL); outb(0, io + UART_DLM);\r\noutb(UART_LCR_WLEN7, io + UART_LCR);\r\noutb(UART_FCR_ENABLE_FIFO, io + UART_FCR);\r\noutb(UART_IER_RDI, io + UART_IER);\r\noutb(UART_MCR_DTR|UART_MCR_RTS|UART_MCR_OUT2, io + UART_MCR);\r\n#ifdef LIRC_SIR_ACTISYS_ACT200L\r\ninit_act200();\r\n#elif defined(LIRC_SIR_ACTISYS_ACT220L)\r\ninit_act220();\r\n#endif\r\n#endif\r\nspin_unlock_irqrestore(&hardware_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void drop_hardware(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hardware_lock, flags);\r\n#ifdef LIRC_ON_SA1100\r\nSer2UTCR3 = 0;\r\nSer2UTCR0 = sr.utcr0;\r\nSer2UTCR1 = sr.utcr1;\r\nSer2UTCR2 = sr.utcr2;\r\nSer2UTCR4 = sr.utcr4;\r\nSer2UTCR3 = sr.utcr3;\r\nSer2HSCR0 = sr.hscr0;\r\n#ifdef CONFIG_SA1100_BITSY\r\nif (machine_is_bitsy())\r\nclr_bitsy_egpio(EGPIO_BITSY_IR_ON);\r\n#endif\r\n#ifdef CONFIG_SA1100_COLLIE\r\nsa1100_irda_set_power_collie(0);\r\n#endif\r\n#else\r\noutb(0, io + UART_IER);\r\n#endif\r\nspin_unlock_irqrestore(&hardware_lock, flags);\r\n}\r\nstatic int init_port(void)\r\n{\r\nint retval;\r\n#ifndef LIRC_ON_SA1100\r\nif (request_region(io, 8, LIRC_DRIVER_NAME) == NULL) {\r\nprintk(KERN_ERR LIRC_DRIVER_NAME\r\n": i/o port 0x%.4x already in use.\n", io);\r\nreturn -EBUSY;\r\n}\r\n#endif\r\nretval = request_irq(irq, sir_interrupt, 0,\r\nLIRC_DRIVER_NAME, NULL);\r\nif (retval < 0) {\r\n# ifndef LIRC_ON_SA1100\r\nrelease_region(io, 8);\r\n# endif\r\nprintk(KERN_ERR LIRC_DRIVER_NAME\r\n": IRQ %d already in use.\n",\r\nirq);\r\nreturn retval;\r\n}\r\n#ifndef LIRC_ON_SA1100\r\nprintk(KERN_INFO LIRC_DRIVER_NAME\r\n": I/O port 0x%.4x, IRQ %d.\n",\r\nio, irq);\r\n#endif\r\ninit_timer(&timerlist);\r\ntimerlist.function = sir_timeout;\r\ntimerlist.data = 0xabadcafe;\r\nreturn 0;\r\n}\r\nstatic void drop_port(void)\r\n{\r\nfree_irq(irq, NULL);\r\ndel_timer_sync(&timerlist);\r\n#ifndef LIRC_ON_SA1100\r\nrelease_region(io, 8);\r\n#endif\r\n}\r\nstatic void init_act200(void)\r\n{\r\nint i;\r\n__u8 control[] = {\r\nACT200L_REG15,\r\nACT200L_REG13 | ACT200L_SHDW,\r\nACT200L_REG21 | ACT200L_EXCK | ACT200L_OSCL,\r\nACT200L_REG13,\r\nACT200L_REG7 | ACT200L_ENPOS,\r\nACT200L_REG6 | ACT200L_RS0 | ACT200L_RS1,\r\nACT200L_REG5 | ACT200L_RWIDL,\r\nACT200L_REG4 | ACT200L_OP0 | ACT200L_OP1 | ACT200L_BLKR,\r\nACT200L_REG3 | ACT200L_B0,\r\nACT200L_REG0 | ACT200L_TXEN | ACT200L_RXEN,\r\nACT200L_REG8 | (ACT200L_115200 & 0x0f),\r\nACT200L_REG9 | ((ACT200L_115200 >> 4) & 0x0f),\r\nACT200L_REG1 | ACT200L_LODB | ACT200L_WIDE\r\n};\r\nsoutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN8);\r\nsoutp(UART_DLM, 0);\r\nsoutp(UART_DLL, 12);\r\nsoutp(UART_LCR, UART_LCR_WLEN8);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\nfor (i = 0; i < 50; i++)\r\nsafe_udelay(1000);\r\nsoutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);\r\nfor (i = 0; i < 25; i++)\r\nudelay(1000);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\nudelay(100);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_OUT2);\r\nudelay(7);\r\nfor (i = 0; i < sizeof(control); i++) {\r\nsoutp(UART_TX, control[i]);\r\nudelay(1500);\r\n}\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\nudelay(50);\r\nudelay(1500);\r\nsoutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);\r\nsoutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN7);\r\nsoutp(UART_DLM, 0);\r\nsoutp(UART_DLL, 1);\r\nsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\r\nsoutp(UART_LCR, UART_LCR_WLEN7);\r\nsoutp(UART_IER, sinp(UART_IER)|UART_IER_RDI);\r\n}\r\nvoid init_act220(void)\r\n{\r\nint i;\r\nsoutp(UART_LCR, UART_LCR_DLAB|UART_LCR_WLEN7);\r\nsoutp(UART_DLM, 0);\r\nsoutp(UART_DLL, 12);\r\nsoutp(UART_LCR, UART_LCR_WLEN7);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_OUT2);\r\nudelay(10);\r\nsoutp(UART_MCR, UART_MCR_DTR|UART_MCR_RTS|UART_MCR_OUT2);\r\nfor (i = 0; i < 3; i++) {\r\nudelay(10);\r\nsoutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);\r\nudelay(10);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\n}\r\nudelay(1500);\r\nsoutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN7);\r\nsoutp(UART_DLM, 0);\r\nsoutp(UART_DLL, 1);\r\nsoutp(UART_LCR, UART_LCR_WLEN7);\r\nsoutp(UART_IER, UART_IER_RDI);\r\n}\r\nstatic int init_lirc_sir(void)\r\n{\r\nint retval;\r\ninit_waitqueue_head(&lirc_read_queue);\r\nretval = init_port();\r\nif (retval < 0)\r\nreturn retval;\r\ninit_hardware();\r\nprintk(KERN_INFO LIRC_DRIVER_NAME\r\n": Installed.\n");\r\nreturn 0;\r\n}\r\nstatic int __devinit lirc_sir_probe(struct platform_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __devexit lirc_sir_remove(struct platform_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init lirc_sir_init(void)\r\n{\r\nint retval;\r\nretval = platform_driver_register(&lirc_sir_driver);\r\nif (retval) {\r\nprintk(KERN_ERR LIRC_DRIVER_NAME ": Platform driver register "\r\n"failed!\n");\r\nreturn -ENODEV;\r\n}\r\nlirc_sir_dev = platform_device_alloc("lirc_dev", 0);\r\nif (!lirc_sir_dev) {\r\nprintk(KERN_ERR LIRC_DRIVER_NAME ": Platform device alloc "\r\n"failed!\n");\r\nretval = -ENOMEM;\r\ngoto pdev_alloc_fail;\r\n}\r\nretval = platform_device_add(lirc_sir_dev);\r\nif (retval) {\r\nprintk(KERN_ERR LIRC_DRIVER_NAME ": Platform device add "\r\n"failed!\n");\r\nretval = -ENODEV;\r\ngoto pdev_add_fail;\r\n}\r\nretval = init_chrdev();\r\nif (retval < 0)\r\ngoto fail;\r\nretval = init_lirc_sir();\r\nif (retval) {\r\ndrop_chrdev();\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nplatform_device_del(lirc_sir_dev);\r\npdev_add_fail:\r\nplatform_device_put(lirc_sir_dev);\r\npdev_alloc_fail:\r\nplatform_driver_unregister(&lirc_sir_driver);\r\nreturn retval;\r\n}\r\nstatic void __exit lirc_sir_exit(void)\r\n{\r\ndrop_hardware();\r\ndrop_chrdev();\r\ndrop_port();\r\nplatform_device_unregister(lirc_sir_dev);\r\nplatform_driver_unregister(&lirc_sir_driver);\r\nprintk(KERN_INFO LIRC_DRIVER_NAME ": Uninstalled.\n");\r\n}
