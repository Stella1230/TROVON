static inline bool check_tmds_chip(int device_id_subaddr, int device_id)\r\n{\r\nreturn tmds_register_read(device_id_subaddr) == device_id;\r\n}\r\nvoid __devinit viafb_init_dvi_size(struct tmds_chip_information *tmds_chip,\r\nstruct tmds_setting_information *tmds_setting)\r\n{\r\nDEBUG_MSG(KERN_INFO "viafb_init_dvi_size()\n");\r\nviafb_dvi_sense();\r\nif (viafb_dvi_query_EDID() == 1)\r\ndvi_get_panel_size_from_DDCv1(tmds_chip, tmds_setting);\r\nreturn;\r\n}\r\nbool __devinit viafb_tmds_trasmitter_identify(void)\r\n{\r\nunsigned char sr2a = 0, sr1e = 0, sr3e = 0;\r\nswitch (viaparinfo->chip_info->gfx_chip_name) {\r\ncase UNICHROME_K8M890:\r\nsr2a = viafb_read_reg(VIASR, SR2A);\r\nviafb_write_reg_mask(SR2A, VIASR, 0x03, BIT0 + BIT1);\r\nbreak;\r\ncase UNICHROME_P4M900:\r\ncase UNICHROME_P4M890:\r\nsr2a = viafb_read_reg(VIASR, SR2A);\r\nviafb_write_reg_mask(SR2A, VIASR, 0x03, BIT0 + BIT1);\r\nsr1e = viafb_read_reg(VIASR, SR1E);\r\nviafb_write_reg_mask(SR1E, VIASR, 0xC0, BIT6 + BIT7);\r\nbreak;\r\ndefault:\r\nsr1e = viafb_read_reg(VIASR, SR1E);\r\nviafb_write_reg_mask(SR1E, VIASR, 0xF0, BIT4 +\r\nBIT5 + BIT6 + BIT7);\r\nsr3e = viafb_read_reg(VIASR, SR3E);\r\nviafb_write_reg_mask(SR3E, VIASR, 0x0, BIT5);\r\nbreak;\r\n}\r\nviaparinfo->chip_info->tmds_chip_info.tmds_chip_name = VT1632_TMDS;\r\nviaparinfo->chip_info->\r\ntmds_chip_info.tmds_chip_slave_addr = VT1632_TMDS_I2C_ADDR;\r\nviaparinfo->chip_info->tmds_chip_info.i2c_port = VIA_PORT_31;\r\nif (check_tmds_chip(VT1632_DEVICE_ID_REG, VT1632_DEVICE_ID)) {\r\ntmds_register_write(0x08, 0x3b);\r\nDEBUG_MSG(KERN_INFO "\n VT1632 TMDS ! \n");\r\nDEBUG_MSG(KERN_INFO "\n %2d",\r\nviaparinfo->chip_info->tmds_chip_info.tmds_chip_name);\r\nDEBUG_MSG(KERN_INFO "\n %2d",\r\nviaparinfo->chip_info->tmds_chip_info.i2c_port);\r\nreturn true;\r\n} else {\r\nviaparinfo->chip_info->tmds_chip_info.i2c_port = VIA_PORT_2C;\r\nif (check_tmds_chip(VT1632_DEVICE_ID_REG, VT1632_DEVICE_ID)) {\r\ntmds_register_write(0x08, 0x3b);\r\nDEBUG_MSG(KERN_INFO "\n VT1632 TMDS ! \n");\r\nDEBUG_MSG(KERN_INFO "\n %2d",\r\nviaparinfo->chip_info->\r\ntmds_chip_info.tmds_chip_name);\r\nDEBUG_MSG(KERN_INFO "\n %2d",\r\nviaparinfo->chip_info->\r\ntmds_chip_info.i2c_port);\r\nreturn true;\r\n}\r\n}\r\nviaparinfo->chip_info->tmds_chip_info.tmds_chip_name = INTEGRATED_TMDS;\r\nif ((viaparinfo->chip_info->gfx_chip_name == UNICHROME_CX700) &&\r\n((viafb_display_hardware_layout == HW_LAYOUT_DVI_ONLY) ||\r\n(viafb_display_hardware_layout == HW_LAYOUT_LCD_DVI))) {\r\nDEBUG_MSG(KERN_INFO "\n Integrated TMDS ! \n");\r\nreturn true;\r\n}\r\nswitch (viaparinfo->chip_info->gfx_chip_name) {\r\ncase UNICHROME_K8M890:\r\nviafb_write_reg(SR2A, VIASR, sr2a);\r\nbreak;\r\ncase UNICHROME_P4M900:\r\ncase UNICHROME_P4M890:\r\nviafb_write_reg(SR2A, VIASR, sr2a);\r\nviafb_write_reg(SR1E, VIASR, sr1e);\r\nbreak;\r\ndefault:\r\nviafb_write_reg(SR1E, VIASR, sr1e);\r\nviafb_write_reg(SR3E, VIASR, sr3e);\r\nbreak;\r\n}\r\nviaparinfo->chip_info->\r\ntmds_chip_info.tmds_chip_name = NON_TMDS_TRANSMITTER;\r\nviaparinfo->chip_info->tmds_chip_info.\r\ntmds_chip_slave_addr = VT1632_TMDS_I2C_ADDR;\r\nreturn false;\r\n}\r\nstatic void tmds_register_write(int index, u8 data)\r\n{\r\nviafb_i2c_writebyte(viaparinfo->chip_info->tmds_chip_info.i2c_port,\r\nviaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr,\r\nindex, data);\r\n}\r\nstatic int tmds_register_read(int index)\r\n{\r\nu8 data;\r\nviafb_i2c_readbyte(viaparinfo->chip_info->tmds_chip_info.i2c_port,\r\n(u8) viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr,\r\n(u8) index, &data);\r\nreturn data;\r\n}\r\nstatic int tmds_register_read_bytes(int index, u8 *buff, int buff_len)\r\n{\r\nviafb_i2c_readbytes(viaparinfo->chip_info->tmds_chip_info.i2c_port,\r\n(u8) viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr,\r\n(u8) index, buff, buff_len);\r\nreturn 0;\r\n}\r\nvoid viafb_dvi_set_mode(const struct fb_var_screeninfo *var,\r\nu16 cxres, u16 cyres, int iga)\r\n{\r\nstruct fb_var_screeninfo dvi_var = *var;\r\nconst struct fb_videomode *rb_mode;\r\nint maxPixelClock;\r\nmaxPixelClock = viaparinfo->shared->tmds_setting_info.max_pixel_clock;\r\nif (maxPixelClock && PICOS2KHZ(var->pixclock) / 1000 > maxPixelClock) {\r\nrb_mode = viafb_get_best_rb_mode(var->xres, var->yres, 60);\r\nif (rb_mode)\r\nviafb_fill_var_timing_info(&dvi_var, rb_mode);\r\n}\r\nviafb_fill_crtc_timing(&dvi_var, cxres, cyres, iga);\r\n}\r\nint viafb_dvi_sense(void)\r\n{\r\nu8 RegSR1E = 0, RegSR3E = 0, RegCR6B = 0, RegCR91 = 0,\r\nRegCR93 = 0, RegCR9B = 0, data;\r\nint ret = false;\r\nDEBUG_MSG(KERN_INFO "viafb_dvi_sense!!\n");\r\nif (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266) {\r\nRegSR1E = viafb_read_reg(VIASR, SR1E);\r\nviafb_write_reg(SR1E, VIASR, RegSR1E | 0x30);\r\nRegCR6B = viafb_read_reg(VIACR, CR6B);\r\nviafb_write_reg(CR6B, VIACR, RegCR6B | 0x08);\r\nRegCR91 = viafb_read_reg(VIACR, CR91);\r\nviafb_write_reg(CR91, VIACR, 0x1D);\r\nRegCR93 = viafb_read_reg(VIACR, CR93);\r\nviafb_write_reg(CR93, VIACR, 0x01);\r\n} else {\r\nRegSR1E = viafb_read_reg(VIASR, SR1E);\r\nviafb_write_reg(SR1E, VIASR, RegSR1E | 0xF0);\r\nRegSR3E = viafb_read_reg(VIASR, SR3E);\r\nviafb_write_reg(SR3E, VIASR, RegSR3E & (~0x20));\r\nRegCR91 = viafb_read_reg(VIACR, CR91);\r\nviafb_write_reg(CR91, VIACR, 0x1D);\r\nRegCR9B = viafb_read_reg(VIACR, CR9B);\r\nviafb_write_reg(CR9B, VIACR, 0x01);\r\n}\r\ndata = (u8) tmds_register_read(0x09);\r\nif (data & 0x04)\r\nret = true;\r\nif (ret == false) {\r\nif (viafb_dvi_query_EDID())\r\nret = true;\r\n}\r\nviafb_write_reg(SR1E, VIASR, RegSR1E);\r\nviafb_write_reg(CR91, VIACR, RegCR91);\r\nif (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266) {\r\nviafb_write_reg(CR6B, VIACR, RegCR6B);\r\nviafb_write_reg(CR93, VIACR, RegCR93);\r\n} else {\r\nviafb_write_reg(SR3E, VIASR, RegSR3E);\r\nviafb_write_reg(CR9B, VIACR, RegCR9B);\r\n}\r\nreturn ret;\r\n}\r\nstatic int viafb_dvi_query_EDID(void)\r\n{\r\nu8 data0, data1;\r\nint restore;\r\nDEBUG_MSG(KERN_INFO "viafb_dvi_query_EDID!!\n");\r\nrestore = viaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr;\r\nviaparinfo->chip_info->tmds_chip_info.tmds_chip_slave_addr = 0xA0;\r\ndata0 = (u8) tmds_register_read(0x00);\r\ndata1 = (u8) tmds_register_read(0x01);\r\nif ((data0 == 0) && (data1 == 0xFF)) {\r\nviaparinfo->chip_info->\r\ntmds_chip_info.tmds_chip_slave_addr = restore;\r\nreturn EDID_VERSION_1;\r\n}\r\nreturn false;\r\n}\r\nstatic void __devinit dvi_get_panel_size_from_DDCv1(\r\nstruct tmds_chip_information *tmds_chip,\r\nstruct tmds_setting_information *tmds_setting)\r\n{\r\nint i, restore;\r\nunsigned char EDID_DATA[18];\r\nDEBUG_MSG(KERN_INFO "\n dvi_get_panel_size_from_DDCv1 \n");\r\nrestore = tmds_chip->tmds_chip_slave_addr;\r\ntmds_chip->tmds_chip_slave_addr = 0xA0;\r\nfor (i = 0x25; i < 0x6D; i++) {\r\nswitch (i) {\r\ncase 0x36:\r\ncase 0x48:\r\ncase 0x5A:\r\ncase 0x6C:\r\ntmds_register_read_bytes(i, EDID_DATA, 10);\r\nif (!(EDID_DATA[0] || EDID_DATA[1])) {\r\nif (EDID_DATA[3] == 0xFD) {\r\ntmds_setting->max_pixel_clock =\r\nEDID_DATA[9] * 10;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nDEBUG_MSG(KERN_INFO "DVI max pixelclock = %d\n",\r\ntmds_setting->max_pixel_clock);\r\ntmds_chip->tmds_chip_slave_addr = restore;\r\n}\r\nvoid viafb_dvi_disable(void)\r\n{\r\nif (viaparinfo->chip_info->\r\ntmds_chip_info.output_interface == INTERFACE_TMDS)\r\nviafb_write_reg(CRD2, VIACR,\r\nviafb_read_reg(VIACR, CRD2) | 0x08);\r\n}\r\nstatic void dvi_patch_skew_dvp0(void)\r\n{\r\nviafb_write_reg_mask(SR1B, VIASR, 0, BIT1);\r\nviafb_write_reg_mask(SR2A, VIASR, 0, BIT4);\r\nswitch (viaparinfo->chip_info->gfx_chip_name) {\r\ncase UNICHROME_P4M890:\r\n{\r\nif ((viaparinfo->tmds_setting_info->h_active == 1600) &&\r\n(viaparinfo->tmds_setting_info->v_active ==\r\n1200))\r\nviafb_write_reg_mask(CR96, VIACR, 0x03,\r\nBIT0 + BIT1 + BIT2);\r\nelse\r\nviafb_write_reg_mask(CR96, VIACR, 0x07,\r\nBIT0 + BIT1 + BIT2);\r\nbreak;\r\n}\r\ncase UNICHROME_P4M900:\r\n{\r\nviafb_write_reg_mask(CR96, VIACR, 0x07,\r\nBIT0 + BIT1 + BIT2 + BIT3);\r\nviafb_write_reg_mask(SR1B, VIASR, 0x02, BIT1);\r\nviafb_write_reg_mask(SR2A, VIASR, 0x10, BIT4);\r\nbreak;\r\n}\r\ndefault:\r\n{\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void dvi_patch_skew_dvp_low(void)\r\n{\r\nswitch (viaparinfo->chip_info->gfx_chip_name) {\r\ncase UNICHROME_K8M890:\r\n{\r\nviafb_write_reg_mask(CR99, VIACR, 0x03, BIT0 + BIT1);\r\nbreak;\r\n}\r\ncase UNICHROME_P4M900:\r\n{\r\nviafb_write_reg_mask(CR99, VIACR, 0x08,\r\nBIT0 + BIT1 + BIT2 + BIT3);\r\nbreak;\r\n}\r\ncase UNICHROME_P4M890:\r\n{\r\nviafb_write_reg_mask(CR99, VIACR, 0x0F,\r\nBIT0 + BIT1 + BIT2 + BIT3);\r\nbreak;\r\n}\r\ndefault:\r\n{\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid viafb_dvi_enable(void)\r\n{\r\nu8 data;\r\nswitch (viaparinfo->chip_info->tmds_chip_info.output_interface) {\r\ncase INTERFACE_DVP0:\r\nviafb_write_reg_mask(CR6B, VIACR, 0x01, BIT0);\r\nviafb_write_reg_mask(CR6C, VIACR, 0x21, BIT0 + BIT5);\r\ndvi_patch_skew_dvp0();\r\nif (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)\r\ntmds_register_write(0x88, 0x3b);\r\nelse\r\nvia_write_reg_mask(VIACR, 0x91, 0x00, 0x20);\r\nbreak;\r\ncase INTERFACE_DVP1:\r\nif (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)\r\nviafb_write_reg_mask(CR93, VIACR, 0x21, BIT0 + BIT5);\r\nif (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)\r\ntmds_register_write(0x88, 0x3b);\r\nelse\r\nvia_write_reg_mask(VIACR, 0x91, 0x00, 0x20);\r\nif (viafb_platform_epia_dvi == 1) {\r\nviafb_write_reg_mask(CR91, VIACR, 0x1f, 0x1f);\r\nviafb_write_reg_mask(CR88, VIACR, 0x00, BIT6 + BIT0);\r\nif (viafb_bus_width == 24) {\r\nif (viafb_device_lcd_dualedge == 1)\r\ndata = 0x3F;\r\nelse\r\ndata = 0x37;\r\nviafb_i2c_writebyte(viaparinfo->chip_info->\r\ntmds_chip_info.i2c_port,\r\nviaparinfo->chip_info->\r\ntmds_chip_info.tmds_chip_slave_addr,\r\n0x08, data);\r\n}\r\n}\r\nbreak;\r\ncase INTERFACE_DFP_HIGH:\r\nif (viaparinfo->chip_info->gfx_chip_name != UNICHROME_CLE266)\r\nvia_write_reg_mask(VIACR, CR97, 0x03, 0x03);\r\nvia_write_reg_mask(VIACR, 0x91, 0x00, 0x20);\r\nbreak;\r\ncase INTERFACE_DFP_LOW:\r\nif (viaparinfo->chip_info->gfx_chip_name == UNICHROME_CLE266)\r\nbreak;\r\ndvi_patch_skew_dvp_low();\r\nvia_write_reg_mask(VIACR, 0x91, 0x00, 0x20);\r\nbreak;\r\ncase INTERFACE_TMDS:\r\nviafb_write_reg_mask(CR91, VIACR, 0, BIT7);\r\nviafb_write_reg_mask(CRD2, VIACR, 0, BIT3);\r\nbreak;\r\n}\r\nif (viaparinfo->tmds_setting_info->iga_path == IGA2) {\r\nviafb_write_reg_mask(CR79, VIACR, 0x00, BIT0);\r\n}\r\n}
