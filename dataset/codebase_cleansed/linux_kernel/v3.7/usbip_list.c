void usbip_list_usage(void)\r\n{\r\nprintf("usage: %s", usbip_list_usage_string);\r\n}\r\nstatic int get_exported_devices(char *host, int sockfd)\r\n{\r\nchar product_name[100];\r\nchar class_name[100];\r\nstruct op_devlist_reply reply;\r\nuint16_t code = OP_REP_DEVLIST;\r\nstruct usbip_usb_device udev;\r\nstruct usbip_usb_interface uintf;\r\nunsigned int i;\r\nint j, rc;\r\nrc = usbip_net_send_op_common(sockfd, OP_REQ_DEVLIST, 0);\r\nif (rc < 0) {\r\ndbg("usbip_net_send_op_common failed");\r\nreturn -1;\r\n}\r\nrc = usbip_net_recv_op_common(sockfd, &code);\r\nif (rc < 0) {\r\ndbg("usbip_net_recv_op_common failed");\r\nreturn -1;\r\n}\r\nmemset(&reply, 0, sizeof(reply));\r\nrc = usbip_net_recv(sockfd, &reply, sizeof(reply));\r\nif (rc < 0) {\r\ndbg("usbip_net_recv_op_devlist failed");\r\nreturn -1;\r\n}\r\nPACK_OP_DEVLIST_REPLY(0, &reply);\r\ndbg("exportable devices: %d\n", reply.ndev);\r\nif (reply.ndev == 0) {\r\ninfo("no exportable devices found on %s", host);\r\nreturn 0;\r\n}\r\nprintf("Exportable USB devices\n");\r\nprintf("======================\n");\r\nprintf(" - %s\n", host);\r\nfor (i = 0; i < reply.ndev; i++) {\r\nmemset(&udev, 0, sizeof(udev));\r\nrc = usbip_net_recv(sockfd, &udev, sizeof(udev));\r\nif (rc < 0) {\r\ndbg("usbip_net_recv failed: usbip_usb_device[%d]", i);\r\nreturn -1;\r\n}\r\nusbip_net_pack_usb_device(0, &udev);\r\nusbip_names_get_product(product_name, sizeof(product_name),\r\nudev.idVendor, udev.idProduct);\r\nusbip_names_get_class(class_name, sizeof(class_name),\r\nudev.bDeviceClass, udev.bDeviceSubClass,\r\nudev.bDeviceProtocol);\r\nprintf("%11s: %s\n", udev.busid, product_name);\r\nprintf("%11s: %s\n", "", udev.path);\r\nprintf("%11s: %s\n", "", class_name);\r\nfor (j = 0; j < udev.bNumInterfaces; j++) {\r\nrc = usbip_net_recv(sockfd, &uintf, sizeof(uintf));\r\nif (rc < 0) {\r\ndbg("usbip_net_recv failed: usbip_usb_intf[%d]",\r\nj);\r\nreturn -1;\r\n}\r\nusbip_net_pack_usb_interface(0, &uintf);\r\nusbip_names_get_class(class_name, sizeof(class_name),\r\nuintf.bInterfaceClass,\r\nuintf.bInterfaceSubClass,\r\nuintf.bInterfaceProtocol);\r\nprintf("%11s: %2d - %s\n", "", j, class_name);\r\n}\r\nprintf("\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int list_exported_devices(char *host)\r\n{\r\nint rc;\r\nint sockfd;\r\nsockfd = usbip_net_tcp_connect(host, USBIP_PORT_STRING);\r\nif (sockfd < 0) {\r\nerr("could not connect to %s:%s: %s", host,\r\nUSBIP_PORT_STRING, gai_strerror(sockfd));\r\nreturn -1;\r\n}\r\ndbg("connected to %s:%s", host, USBIP_PORT_STRING);\r\nrc = get_exported_devices(host, sockfd);\r\nif (rc < 0) {\r\nerr("failed to get device list from %s", host);\r\nreturn -1;\r\n}\r\nclose(sockfd);\r\nreturn 0;\r\n}\r\nstatic void print_device(char *busid, char *vendor, char *product,\r\nbool parsable)\r\n{\r\nif (parsable)\r\nprintf("busid=%s#usbid=%.4s:%.4s#", busid, vendor, product);\r\nelse\r\nprintf(" - busid %s (%.4s:%.4s)\n", busid, vendor, product);\r\n}\r\nstatic void print_interface(char *busid, char *driver, bool parsable)\r\n{\r\nif (parsable)\r\nprintf("%s=%s#", busid, driver);\r\nelse\r\nprintf("%9s%s -> %s\n", "", busid, driver);\r\n}\r\nstatic int is_device(void *x)\r\n{\r\nstruct sysfs_attribute *devpath;\r\nstruct sysfs_device *dev = x;\r\nint ret = 0;\r\ndevpath = sysfs_get_device_attr(dev, "devpath");\r\nif (devpath && *devpath->value != '0')\r\nret = 1;\r\nreturn ret;\r\n}\r\nstatic int devcmp(void *a, void *b)\r\n{\r\nreturn strcmp(a, b);\r\n}\r\nstatic int list_devices(bool parsable)\r\n{\r\nchar bus_type[] = "usb";\r\nchar busid[SYSFS_BUS_ID_SIZE];\r\nstruct sysfs_bus *ubus;\r\nstruct sysfs_device *dev;\r\nstruct sysfs_device *intf;\r\nstruct sysfs_attribute *idVendor;\r\nstruct sysfs_attribute *idProduct;\r\nstruct sysfs_attribute *bConfValue;\r\nstruct sysfs_attribute *bNumIntfs;\r\nstruct dlist *devlist;\r\nint i;\r\nint ret = -1;\r\nubus = sysfs_open_bus(bus_type);\r\nif (!ubus) {\r\nerr("could not open %s bus: %s", bus_type, strerror(errno));\r\nreturn -1;\r\n}\r\ndevlist = sysfs_get_bus_devices(ubus);\r\nif (!devlist) {\r\nerr("could not get %s bus devices: %s", bus_type,\r\nstrerror(errno));\r\ngoto err_out;\r\n}\r\ndlist_filter_sort(devlist, is_device, devcmp);\r\nif (!parsable) {\r\nprintf("Local USB devices\n");\r\nprintf("=================\n");\r\n}\r\ndlist_for_each_data(devlist, dev, struct sysfs_device) {\r\nidVendor = sysfs_get_device_attr(dev, "idVendor");\r\nidProduct = sysfs_get_device_attr(dev, "idProduct");\r\nbConfValue = sysfs_get_device_attr(dev, "bConfigurationValue");\r\nbNumIntfs = sysfs_get_device_attr(dev, "bNumInterfaces");\r\nif (!idVendor || !idProduct || !bConfValue || !bNumIntfs) {\r\nerr("problem getting device attributes: %s",\r\nstrerror(errno));\r\ngoto err_out;\r\n}\r\nprint_device(dev->bus_id, idVendor->value, idProduct->value,\r\nparsable);\r\nfor (i = 0; i < atoi(bNumIntfs->value); i++) {\r\nsnprintf(busid, sizeof(busid), "%s:%.1s.%d",\r\ndev->bus_id, bConfValue->value, i);\r\nintf = sysfs_open_device(bus_type, busid);\r\nif (!intf) {\r\nerr("could not open device interface: %s",\r\nstrerror(errno));\r\ngoto err_out;\r\n}\r\nprint_interface(busid, intf->driver_name, parsable);\r\nsysfs_close_device(intf);\r\n}\r\nprintf("\n");\r\n}\r\nret = 0;\r\nerr_out:\r\nsysfs_close_bus(ubus);\r\nreturn ret;\r\n}\r\nint usbip_list(int argc, char *argv[])\r\n{\r\nstatic const struct option opts[] = {\r\n{ "parsable", no_argument, NULL, 'p' },\r\n{ "remote", required_argument, NULL, 'r' },\r\n{ "local", no_argument, NULL, 'l' },\r\n{ NULL, 0, NULL, 0 }\r\n};\r\nbool parsable = false;\r\nint opt;\r\nint ret = -1;\r\nif (usbip_names_init(USBIDS_FILE))\r\nerr("failed to open %s", USBIDS_FILE);\r\nfor (;;) {\r\nopt = getopt_long(argc, argv, "pr:l", opts, NULL);\r\nif (opt == -1)\r\nbreak;\r\nswitch (opt) {\r\ncase 'p':\r\nparsable = true;\r\nbreak;\r\ncase 'r':\r\nret = list_exported_devices(optarg);\r\ngoto out;\r\ncase 'l':\r\nret = list_devices(parsable);\r\ngoto out;\r\ndefault:\r\ngoto err_out;\r\n}\r\n}\r\nerr_out:\r\nusbip_list_usage();\r\nout:\r\nusbip_names_free();\r\nreturn ret;\r\n}
