int rwsem_is_locked(struct rw_semaphore *sem)\r\n{\r\nint ret = 1;\r\nunsigned long flags;\r\nif (raw_spin_trylock_irqsave(&sem->wait_lock, flags)) {\r\nret = (sem->activity != 0);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nvoid __init_rwsem(struct rw_semaphore *sem, const char *name,\r\nstruct lock_class_key *key)\r\n{\r\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\r\ndebug_check_no_locks_freed((void *)sem, sizeof(*sem));\r\nlockdep_init_map(&sem->dep_map, name, key, 0);\r\n#endif\r\nsem->activity = 0;\r\nraw_spin_lock_init(&sem->wait_lock);\r\nINIT_LIST_HEAD(&sem->wait_list);\r\n}\r\nstatic inline struct rw_semaphore *\r\n__rwsem_do_wake(struct rw_semaphore *sem, int wakewrite)\r\n{\r\nstruct rwsem_waiter *waiter;\r\nstruct task_struct *tsk;\r\nint woken;\r\nwaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\r\nif (!wakewrite) {\r\nif (waiter->flags & RWSEM_WAITING_FOR_WRITE)\r\ngoto out;\r\ngoto dont_wake_writers;\r\n}\r\nif (waiter->flags & RWSEM_WAITING_FOR_WRITE) {\r\nsem->activity = -1;\r\nlist_del(&waiter->list);\r\ntsk = waiter->task;\r\nsmp_mb();\r\nwaiter->task = NULL;\r\nwake_up_process(tsk);\r\nput_task_struct(tsk);\r\ngoto out;\r\n}\r\ndont_wake_writers:\r\nwoken = 0;\r\nwhile (waiter->flags & RWSEM_WAITING_FOR_READ) {\r\nstruct list_head *next = waiter->list.next;\r\nlist_del(&waiter->list);\r\ntsk = waiter->task;\r\nsmp_mb();\r\nwaiter->task = NULL;\r\nwake_up_process(tsk);\r\nput_task_struct(tsk);\r\nwoken++;\r\nif (list_empty(&sem->wait_list))\r\nbreak;\r\nwaiter = list_entry(next, struct rwsem_waiter, list);\r\n}\r\nsem->activity += woken;\r\nout:\r\nreturn sem;\r\n}\r\nstatic inline struct rw_semaphore *\r\n__rwsem_wake_one_writer(struct rw_semaphore *sem)\r\n{\r\nstruct rwsem_waiter *waiter;\r\nstruct task_struct *tsk;\r\nsem->activity = -1;\r\nwaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\r\nlist_del(&waiter->list);\r\ntsk = waiter->task;\r\nsmp_mb();\r\nwaiter->task = NULL;\r\nwake_up_process(tsk);\r\nput_task_struct(tsk);\r\nreturn sem;\r\n}\r\nvoid __sched __down_read(struct rw_semaphore *sem)\r\n{\r\nstruct rwsem_waiter waiter;\r\nstruct task_struct *tsk;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nif (sem->activity >= 0 && list_empty(&sem->wait_list)) {\r\nsem->activity++;\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\ngoto out;\r\n}\r\ntsk = current;\r\nset_task_state(tsk, TASK_UNINTERRUPTIBLE);\r\nwaiter.task = tsk;\r\nwaiter.flags = RWSEM_WAITING_FOR_READ;\r\nget_task_struct(tsk);\r\nlist_add_tail(&waiter.list, &sem->wait_list);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\nfor (;;) {\r\nif (!waiter.task)\r\nbreak;\r\nschedule();\r\nset_task_state(tsk, TASK_UNINTERRUPTIBLE);\r\n}\r\ntsk->state = TASK_RUNNING;\r\nout:\r\n;\r\n}\r\nint __down_read_trylock(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nif (sem->activity >= 0 && list_empty(&sem->wait_list)) {\r\nsem->activity++;\r\nret = 1;\r\n}\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\nreturn ret;\r\n}\r\nvoid __sched __down_write_nested(struct rw_semaphore *sem, int subclass)\r\n{\r\nstruct rwsem_waiter waiter;\r\nstruct task_struct *tsk;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nif (sem->activity == 0 && list_empty(&sem->wait_list)) {\r\nsem->activity = -1;\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\ngoto out;\r\n}\r\ntsk = current;\r\nset_task_state(tsk, TASK_UNINTERRUPTIBLE);\r\nwaiter.task = tsk;\r\nwaiter.flags = RWSEM_WAITING_FOR_WRITE;\r\nget_task_struct(tsk);\r\nlist_add_tail(&waiter.list, &sem->wait_list);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\nfor (;;) {\r\nif (!waiter.task)\r\nbreak;\r\nschedule();\r\nset_task_state(tsk, TASK_UNINTERRUPTIBLE);\r\n}\r\ntsk->state = TASK_RUNNING;\r\nout:\r\n;\r\n}\r\nvoid __sched __down_write(struct rw_semaphore *sem)\r\n{\r\n__down_write_nested(sem, 0);\r\n}\r\nint __down_write_trylock(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nif (sem->activity == 0 && list_empty(&sem->wait_list)) {\r\nsem->activity = -1;\r\nret = 1;\r\n}\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\nreturn ret;\r\n}\r\nvoid __up_read(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nif (--sem->activity == 0 && !list_empty(&sem->wait_list))\r\nsem = __rwsem_wake_one_writer(sem);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\n}\r\nvoid __up_write(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nsem->activity = 0;\r\nif (!list_empty(&sem->wait_list))\r\nsem = __rwsem_do_wake(sem, 1);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\n}\r\nvoid __downgrade_write(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nsem->activity = 1;\r\nif (!list_empty(&sem->wait_list))\r\nsem = __rwsem_do_wake(sem, 0);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\n}
