static int each_iommu_ctx(struct device *dev, void *data)\r\n{\r\nstruct iommu_ctx_iter_data *res = data;\r\nstruct msm_iommu_ctx_dev *c = dev->platform_data;\r\nif (!res || !c || !c->name || !res->name)\r\nreturn -EINVAL;\r\nif (!strcmp(res->name, c->name)) {\r\nres->dev = dev;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int each_iommu(struct device *dev, void *data)\r\n{\r\nreturn device_for_each_child(dev, data, each_iommu_ctx);\r\n}\r\nstruct device *msm_iommu_get_ctx(const char *ctx_name)\r\n{\r\nstruct iommu_ctx_iter_data r;\r\nint found;\r\nif (!msm_iommu_root_dev) {\r\npr_err("No root IOMMU device.\n");\r\ngoto fail;\r\n}\r\nr.name = ctx_name;\r\nfound = device_for_each_child(&msm_iommu_root_dev->dev, &r, each_iommu);\r\nif (!found) {\r\npr_err("Could not find context <%s>\n", ctx_name);\r\ngoto fail;\r\n}\r\nreturn r.dev;\r\nfail:\r\nreturn NULL;\r\n}\r\nstatic void msm_iommu_reset(void __iomem *base, int ncb)\r\n{\r\nint ctx;\r\nSET_RPUE(base, 0);\r\nSET_RPUEIE(base, 0);\r\nSET_ESRRESTORE(base, 0);\r\nSET_TBE(base, 0);\r\nSET_CR(base, 0);\r\nSET_SPDMBE(base, 0);\r\nSET_TESTBUSCR(base, 0);\r\nSET_TLBRSW(base, 0);\r\nSET_GLOBAL_TLBIALL(base, 0);\r\nSET_RPU_ACR(base, 0);\r\nSET_TLBLKCRWE(base, 1);\r\nfor (ctx = 0; ctx < ncb; ctx++) {\r\nSET_BPRCOSH(base, ctx, 0);\r\nSET_BPRCISH(base, ctx, 0);\r\nSET_BPRCNSH(base, ctx, 0);\r\nSET_BPSHCFG(base, ctx, 0);\r\nSET_BPMTCFG(base, ctx, 0);\r\nSET_ACTLR(base, ctx, 0);\r\nSET_SCTLR(base, ctx, 0);\r\nSET_FSRRESTORE(base, ctx, 0);\r\nSET_TTBR0(base, ctx, 0);\r\nSET_TTBR1(base, ctx, 0);\r\nSET_TTBCR(base, ctx, 0);\r\nSET_BFBCR(base, ctx, 0);\r\nSET_PAR(base, ctx, 0);\r\nSET_FAR(base, ctx, 0);\r\nSET_CTX_TLBIALL(base, ctx, 0);\r\nSET_TLBFLPTER(base, ctx, 0);\r\nSET_TLBSLPTER(base, ctx, 0);\r\nSET_TLBLKCR(base, ctx, 0);\r\nSET_PRRR(base, ctx, 0);\r\nSET_NMRR(base, ctx, 0);\r\nSET_CONTEXTIDR(base, ctx, 0);\r\n}\r\n}\r\nstatic int msm_iommu_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r, *r2;\r\nstruct clk *iommu_clk;\r\nstruct clk *iommu_pclk;\r\nstruct msm_iommu_drvdata *drvdata;\r\nstruct msm_iommu_dev *iommu_dev = pdev->dev.platform_data;\r\nvoid __iomem *regs_base;\r\nresource_size_t len;\r\nint ret, irq, par;\r\nif (pdev->id == -1) {\r\nmsm_iommu_root_dev = pdev;\r\nreturn 0;\r\n}\r\ndrvdata = kzalloc(sizeof(*drvdata), GFP_KERNEL);\r\nif (!drvdata) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nif (!iommu_dev) {\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\niommu_pclk = clk_get(NULL, "smmu_pclk");\r\nif (IS_ERR(iommu_pclk)) {\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\nret = clk_enable(iommu_pclk);\r\nif (ret)\r\ngoto fail_enable;\r\niommu_clk = clk_get(&pdev->dev, "iommu_clk");\r\nif (!IS_ERR(iommu_clk)) {\r\nif (clk_get_rate(iommu_clk) == 0)\r\nclk_set_min_rate(iommu_clk, 1);\r\nret = clk_enable(iommu_clk);\r\nif (ret) {\r\nclk_put(iommu_clk);\r\ngoto fail_pclk;\r\n}\r\n} else\r\niommu_clk = NULL;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "physbase");\r\nif (!r) {\r\nret = -ENODEV;\r\ngoto fail_clk;\r\n}\r\nlen = resource_size(r);\r\nr2 = request_mem_region(r->start, len, r->name);\r\nif (!r2) {\r\npr_err("Could not request memory region: start=%p, len=%d\n",\r\n(void *) r->start, len);\r\nret = -EBUSY;\r\ngoto fail_clk;\r\n}\r\nregs_base = ioremap(r2->start, len);\r\nif (!regs_base) {\r\npr_err("Could not ioremap: start=%p, len=%d\n",\r\n(void *) r2->start, len);\r\nret = -EBUSY;\r\ngoto fail_mem;\r\n}\r\nirq = platform_get_irq_byname(pdev, "secure_irq");\r\nif (irq < 0) {\r\nret = -ENODEV;\r\ngoto fail_io;\r\n}\r\nmsm_iommu_reset(regs_base, iommu_dev->ncb);\r\nSET_M(regs_base, 0, 1);\r\nSET_PAR(regs_base, 0, 0);\r\nSET_V2PCFG(regs_base, 0, 1);\r\nSET_V2PPR(regs_base, 0, 0);\r\npar = GET_PAR(regs_base, 0);\r\nSET_V2PCFG(regs_base, 0, 0);\r\nSET_M(regs_base, 0, 0);\r\nif (!par) {\r\npr_err("%s: Invalid PAR value detected\n", iommu_dev->name);\r\nret = -ENODEV;\r\ngoto fail_io;\r\n}\r\nret = request_irq(irq, msm_iommu_fault_handler, 0,\r\n"msm_iommu_secure_irpt_handler", drvdata);\r\nif (ret) {\r\npr_err("Request IRQ %d failed with ret=%d\n", irq, ret);\r\ngoto fail_io;\r\n}\r\ndrvdata->pclk = iommu_pclk;\r\ndrvdata->clk = iommu_clk;\r\ndrvdata->base = regs_base;\r\ndrvdata->irq = irq;\r\ndrvdata->ncb = iommu_dev->ncb;\r\npr_info("device %s mapped at %p, irq %d with %d ctx banks\n",\r\niommu_dev->name, regs_base, irq, iommu_dev->ncb);\r\nplatform_set_drvdata(pdev, drvdata);\r\nif (iommu_clk)\r\nclk_disable(iommu_clk);\r\nclk_disable(iommu_pclk);\r\nreturn 0;\r\nfail_io:\r\niounmap(regs_base);\r\nfail_mem:\r\nrelease_mem_region(r->start, len);\r\nfail_clk:\r\nif (iommu_clk) {\r\nclk_disable(iommu_clk);\r\nclk_put(iommu_clk);\r\n}\r\nfail_pclk:\r\nclk_disable(iommu_pclk);\r\nfail_enable:\r\nclk_put(iommu_pclk);\r\nfail:\r\nkfree(drvdata);\r\nreturn ret;\r\n}\r\nstatic int msm_iommu_remove(struct platform_device *pdev)\r\n{\r\nstruct msm_iommu_drvdata *drv = NULL;\r\ndrv = platform_get_drvdata(pdev);\r\nif (drv) {\r\nif (drv->clk)\r\nclk_put(drv->clk);\r\nclk_put(drv->pclk);\r\nmemset(drv, 0, sizeof(*drv));\r\nkfree(drv);\r\nplatform_set_drvdata(pdev, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm_iommu_ctx_probe(struct platform_device *pdev)\r\n{\r\nstruct msm_iommu_ctx_dev *c = pdev->dev.platform_data;\r\nstruct msm_iommu_drvdata *drvdata;\r\nstruct msm_iommu_ctx_drvdata *ctx_drvdata = NULL;\r\nint i, ret;\r\nif (!c || !pdev->dev.parent) {\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\ndrvdata = dev_get_drvdata(pdev->dev.parent);\r\nif (!drvdata) {\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\nctx_drvdata = kzalloc(sizeof(*ctx_drvdata), GFP_KERNEL);\r\nif (!ctx_drvdata) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nctx_drvdata->num = c->num;\r\nctx_drvdata->pdev = pdev;\r\nINIT_LIST_HEAD(&ctx_drvdata->attached_elm);\r\nplatform_set_drvdata(pdev, ctx_drvdata);\r\nret = clk_enable(drvdata->pclk);\r\nif (ret)\r\ngoto fail;\r\nif (drvdata->clk) {\r\nret = clk_enable(drvdata->clk);\r\nif (ret) {\r\nclk_disable(drvdata->pclk);\r\ngoto fail;\r\n}\r\n}\r\nfor (i = 0; i < MAX_NUM_MIDS; i++) {\r\nint mid = c->mids[i];\r\nif (mid == -1)\r\nbreak;\r\nSET_M2VCBR_N(drvdata->base, mid, 0);\r\nSET_CBACR_N(drvdata->base, c->num, 0);\r\nSET_VMID(drvdata->base, mid, 0);\r\nSET_CBNDX(drvdata->base, mid, c->num);\r\nSET_CBVMID(drvdata->base, c->num, 0);\r\nSET_CONTEXTIDR_ASID(drvdata->base, c->num, c->num);\r\nSET_NSCFG(drvdata->base, mid, 3);\r\n}\r\nif (drvdata->clk)\r\nclk_disable(drvdata->clk);\r\nclk_disable(drvdata->pclk);\r\ndev_info(&pdev->dev, "context %s using bank %d\n", c->name, c->num);\r\nreturn 0;\r\nfail:\r\nkfree(ctx_drvdata);\r\nreturn ret;\r\n}\r\nstatic int msm_iommu_ctx_remove(struct platform_device *pdev)\r\n{\r\nstruct msm_iommu_ctx_drvdata *drv = NULL;\r\ndrv = platform_get_drvdata(pdev);\r\nif (drv) {\r\nmemset(drv, 0, sizeof(struct msm_iommu_ctx_drvdata));\r\nkfree(drv);\r\nplatform_set_drvdata(pdev, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init msm_iommu_driver_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&msm_iommu_driver);\r\nif (ret != 0) {\r\npr_err("Failed to register IOMMU driver\n");\r\ngoto error;\r\n}\r\nret = platform_driver_register(&msm_iommu_ctx_driver);\r\nif (ret != 0) {\r\npr_err("Failed to register IOMMU context driver\n");\r\ngoto error;\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstatic void __exit msm_iommu_driver_exit(void)\r\n{\r\nplatform_driver_unregister(&msm_iommu_ctx_driver);\r\nplatform_driver_unregister(&msm_iommu_driver);\r\n}
