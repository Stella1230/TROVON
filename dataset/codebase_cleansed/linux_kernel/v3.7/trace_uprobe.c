static struct trace_uprobe *\r\nalloc_trace_uprobe(const char *group, const char *event, int nargs)\r\n{\r\nstruct trace_uprobe *tu;\r\nif (!event || !is_good_name(event))\r\nreturn ERR_PTR(-EINVAL);\r\nif (!group || !is_good_name(group))\r\nreturn ERR_PTR(-EINVAL);\r\ntu = kzalloc(SIZEOF_TRACE_UPROBE(nargs), GFP_KERNEL);\r\nif (!tu)\r\nreturn ERR_PTR(-ENOMEM);\r\ntu->call.class = &tu->class;\r\ntu->call.name = kstrdup(event, GFP_KERNEL);\r\nif (!tu->call.name)\r\ngoto error;\r\ntu->class.system = kstrdup(group, GFP_KERNEL);\r\nif (!tu->class.system)\r\ngoto error;\r\nINIT_LIST_HEAD(&tu->list);\r\nreturn tu;\r\nerror:\r\nkfree(tu->call.name);\r\nkfree(tu);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\r\n{\r\nint i;\r\nfor (i = 0; i < tu->nr_args; i++)\r\ntraceprobe_free_probe_arg(&tu->args[i]);\r\niput(tu->inode);\r\nkfree(tu->call.class->system);\r\nkfree(tu->call.name);\r\nkfree(tu->filename);\r\nkfree(tu);\r\n}\r\nstatic struct trace_uprobe *find_probe_event(const char *event, const char *group)\r\n{\r\nstruct trace_uprobe *tu;\r\nlist_for_each_entry(tu, &uprobe_list, list)\r\nif (strcmp(tu->call.name, event) == 0 &&\r\nstrcmp(tu->call.class->system, group) == 0)\r\nreturn tu;\r\nreturn NULL;\r\n}\r\nstatic void unregister_trace_uprobe(struct trace_uprobe *tu)\r\n{\r\nlist_del(&tu->list);\r\nunregister_uprobe_event(tu);\r\nfree_trace_uprobe(tu);\r\n}\r\nstatic int register_trace_uprobe(struct trace_uprobe *tu)\r\n{\r\nstruct trace_uprobe *old_tp;\r\nint ret;\r\nmutex_lock(&uprobe_lock);\r\nold_tp = find_probe_event(tu->call.name, tu->call.class->system);\r\nif (old_tp)\r\nunregister_trace_uprobe(old_tp);\r\nret = register_uprobe_event(tu);\r\nif (ret) {\r\npr_warning("Failed to register probe event(%d)\n", ret);\r\ngoto end;\r\n}\r\nlist_add_tail(&tu->list, &uprobe_list);\r\nend:\r\nmutex_unlock(&uprobe_lock);\r\nreturn ret;\r\n}\r\nstatic int create_trace_uprobe(int argc, char **argv)\r\n{\r\nstruct trace_uprobe *tu;\r\nstruct inode *inode;\r\nchar *arg, *event, *group, *filename;\r\nchar buf[MAX_EVENT_NAME_LEN];\r\nstruct path path;\r\nunsigned long offset;\r\nbool is_delete;\r\nint i, ret;\r\ninode = NULL;\r\nret = 0;\r\nis_delete = false;\r\nevent = NULL;\r\ngroup = NULL;\r\nif (argv[0][0] == '-')\r\nis_delete = true;\r\nelse if (argv[0][0] != 'p') {\r\npr_info("Probe definition must be started with 'p', 'r' or" " '-'.\n");\r\nreturn -EINVAL;\r\n}\r\nif (argv[0][1] == ':') {\r\nevent = &argv[0][2];\r\narg = strchr(event, '/');\r\nif (arg) {\r\ngroup = event;\r\nevent = arg + 1;\r\nevent[-1] = '\0';\r\nif (strlen(group) == 0) {\r\npr_info("Group name is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (strlen(event) == 0) {\r\npr_info("Event name is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!group)\r\ngroup = UPROBE_EVENT_SYSTEM;\r\nif (is_delete) {\r\nif (!event) {\r\npr_info("Delete command needs an event name.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&uprobe_lock);\r\ntu = find_probe_event(event, group);\r\nif (!tu) {\r\nmutex_unlock(&uprobe_lock);\r\npr_info("Event %s/%s doesn't exist.\n", group, event);\r\nreturn -ENOENT;\r\n}\r\nunregister_trace_uprobe(tu);\r\nmutex_unlock(&uprobe_lock);\r\nreturn 0;\r\n}\r\nif (argc < 2) {\r\npr_info("Probe point is not specified.\n");\r\nreturn -EINVAL;\r\n}\r\nif (isdigit(argv[1][0])) {\r\npr_info("probe point must be have a filename.\n");\r\nreturn -EINVAL;\r\n}\r\narg = strchr(argv[1], ':');\r\nif (!arg)\r\ngoto fail_address_parse;\r\n*arg++ = '\0';\r\nfilename = argv[1];\r\nret = kern_path(filename, LOOKUP_FOLLOW, &path);\r\nif (ret)\r\ngoto fail_address_parse;\r\nret = strict_strtoul(arg, 0, &offset);\r\nif (ret)\r\ngoto fail_address_parse;\r\ninode = igrab(path.dentry->d_inode);\r\nargc -= 2;\r\nargv += 2;\r\nif (!event) {\r\nchar *tail = strrchr(filename, '/');\r\nchar *ptr;\r\nptr = kstrdup((tail ? tail + 1 : filename), GFP_KERNEL);\r\nif (!ptr) {\r\nret = -ENOMEM;\r\ngoto fail_address_parse;\r\n}\r\ntail = ptr;\r\nptr = strpbrk(tail, ".-_");\r\nif (ptr)\r\n*ptr = '\0';\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "%c_%s_0x%lx", 'p', tail, offset);\r\nevent = buf;\r\nkfree(tail);\r\n}\r\ntu = alloc_trace_uprobe(group, event, argc);\r\nif (IS_ERR(tu)) {\r\npr_info("Failed to allocate trace_uprobe.(%d)\n", (int)PTR_ERR(tu));\r\nret = PTR_ERR(tu);\r\ngoto fail_address_parse;\r\n}\r\ntu->offset = offset;\r\ntu->inode = inode;\r\ntu->filename = kstrdup(filename, GFP_KERNEL);\r\nif (!tu->filename) {\r\npr_info("Failed to allocate filename.\n");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nret = 0;\r\nfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\r\ntu->nr_args++;\r\narg = strchr(argv[i], '=');\r\nif (arg) {\r\n*arg++ = '\0';\r\ntu->args[i].name = kstrdup(argv[i], GFP_KERNEL);\r\n} else {\r\narg = argv[i];\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "arg%d", i + 1);\r\ntu->args[i].name = kstrdup(buf, GFP_KERNEL);\r\n}\r\nif (!tu->args[i].name) {\r\npr_info("Failed to allocate argument[%d] name.\n", i);\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (!is_good_name(tu->args[i].name)) {\r\npr_info("Invalid argument[%d] name: %s\n", i, tu->args[i].name);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (traceprobe_conflict_field_name(tu->args[i].name, tu->args, i)) {\r\npr_info("Argument[%d] name '%s' conflicts with "\r\n"another field.\n", i, argv[i]);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = traceprobe_parse_probe_arg(arg, &tu->size, &tu->args[i], false, false);\r\nif (ret) {\r\npr_info("Parse error at argument[%d]. (%d)\n", i, ret);\r\ngoto error;\r\n}\r\n}\r\nret = register_trace_uprobe(tu);\r\nif (ret)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nfree_trace_uprobe(tu);\r\nreturn ret;\r\nfail_address_parse:\r\nif (inode)\r\niput(inode);\r\npr_info("Failed to parse address.\n");\r\nreturn ret;\r\n}\r\nstatic void cleanup_all_probes(void)\r\n{\r\nstruct trace_uprobe *tu;\r\nmutex_lock(&uprobe_lock);\r\nwhile (!list_empty(&uprobe_list)) {\r\ntu = list_entry(uprobe_list.next, struct trace_uprobe, list);\r\nunregister_trace_uprobe(tu);\r\n}\r\nmutex_unlock(&uprobe_lock);\r\n}\r\nstatic void *probes_seq_start(struct seq_file *m, loff_t *pos)\r\n{\r\nmutex_lock(&uprobe_lock);\r\nreturn seq_list_start(&uprobe_list, *pos);\r\n}\r\nstatic void *probes_seq_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nreturn seq_list_next(v, &uprobe_list, pos);\r\n}\r\nstatic void probes_seq_stop(struct seq_file *m, void *v)\r\n{\r\nmutex_unlock(&uprobe_lock);\r\n}\r\nstatic int probes_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_uprobe *tu = v;\r\nint i;\r\nseq_printf(m, "p:%s/%s", tu->call.class->system, tu->call.name);\r\nseq_printf(m, " %s:0x%p", tu->filename, (void *)tu->offset);\r\nfor (i = 0; i < tu->nr_args; i++)\r\nseq_printf(m, " %s=%s", tu->args[i].name, tu->args[i].comm);\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic int probes_open(struct inode *inode, struct file *file)\r\n{\r\nif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC))\r\ncleanup_all_probes();\r\nreturn seq_open(file, &probes_seq_op);\r\n}\r\nstatic ssize_t probes_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn traceprobe_probes_write(file, buffer, count, ppos, create_trace_uprobe);\r\n}\r\nstatic int probes_profile_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_uprobe *tu = v;\r\nseq_printf(m, " %s %-44s %15lu\n", tu->filename, tu->call.name, tu->nhit);\r\nreturn 0;\r\n}\r\nstatic int profile_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &profile_seq_op);\r\n}\r\nstatic void uprobe_trace_func(struct trace_uprobe *tu, struct pt_regs *regs)\r\n{\r\nstruct uprobe_trace_entry_head *entry;\r\nstruct ring_buffer_event *event;\r\nstruct ring_buffer *buffer;\r\nu8 *data;\r\nint size, i, pc;\r\nunsigned long irq_flags;\r\nstruct ftrace_event_call *call = &tu->call;\r\ntu->nhit++;\r\nlocal_save_flags(irq_flags);\r\npc = preempt_count();\r\nsize = sizeof(*entry) + tu->size;\r\nevent = trace_current_buffer_lock_reserve(&buffer, call->event.type,\r\nsize, irq_flags, pc);\r\nif (!event)\r\nreturn;\r\nentry = ring_buffer_event_data(event);\r\nentry->ip = uprobe_get_swbp_addr(task_pt_regs(current));\r\ndata = (u8 *)&entry[1];\r\nfor (i = 0; i < tu->nr_args; i++)\r\ncall_fetch(&tu->args[i].fetch, regs, data + tu->args[i].offset);\r\nif (!filter_current_check_discard(buffer, call, entry, event))\r\ntrace_buffer_unlock_commit(buffer, event, irq_flags, pc);\r\n}\r\nstatic enum print_line_t\r\nprint_uprobe_event(struct trace_iterator *iter, int flags, struct trace_event *event)\r\n{\r\nstruct uprobe_trace_entry_head *field;\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_uprobe *tu;\r\nu8 *data;\r\nint i;\r\nfield = (struct uprobe_trace_entry_head *)iter->ent;\r\ntu = container_of(event, struct trace_uprobe, call.event);\r\nif (!trace_seq_printf(s, "%s: (", tu->call.name))\r\ngoto partial;\r\nif (!seq_print_ip_sym(s, field->ip, flags | TRACE_ITER_SYM_OFFSET))\r\ngoto partial;\r\nif (!trace_seq_puts(s, ")"))\r\ngoto partial;\r\ndata = (u8 *)&field[1];\r\nfor (i = 0; i < tu->nr_args; i++) {\r\nif (!tu->args[i].type->print(s, tu->args[i].name,\r\ndata + tu->args[i].offset, field))\r\ngoto partial;\r\n}\r\nif (trace_seq_puts(s, "\n"))\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic int probe_event_enable(struct trace_uprobe *tu, int flag)\r\n{\r\nstruct uprobe_trace_consumer *utc;\r\nint ret = 0;\r\nif (!tu->inode || tu->consumer)\r\nreturn -EINTR;\r\nutc = kzalloc(sizeof(struct uprobe_trace_consumer), GFP_KERNEL);\r\nif (!utc)\r\nreturn -EINTR;\r\nutc->cons.handler = uprobe_dispatcher;\r\nutc->cons.filter = NULL;\r\nret = uprobe_register(tu->inode, tu->offset, &utc->cons);\r\nif (ret) {\r\nkfree(utc);\r\nreturn ret;\r\n}\r\ntu->flags |= flag;\r\nutc->tu = tu;\r\ntu->consumer = utc;\r\nreturn 0;\r\n}\r\nstatic void probe_event_disable(struct trace_uprobe *tu, int flag)\r\n{\r\nif (!tu->inode || !tu->consumer)\r\nreturn;\r\nuprobe_unregister(tu->inode, tu->offset, &tu->consumer->cons);\r\ntu->flags &= ~flag;\r\nkfree(tu->consumer);\r\ntu->consumer = NULL;\r\n}\r\nstatic int uprobe_event_define_fields(struct ftrace_event_call *event_call)\r\n{\r\nint ret, i;\r\nstruct uprobe_trace_entry_head field;\r\nstruct trace_uprobe *tu = (struct trace_uprobe *)event_call->data;\r\nDEFINE_FIELD(unsigned long, ip, FIELD_STRING_IP, 0);\r\nfor (i = 0; i < tu->nr_args; i++) {\r\nret = trace_define_field(event_call, tu->args[i].type->fmttype,\r\ntu->args[i].name,\r\nsizeof(field) + tu->args[i].offset,\r\ntu->args[i].type->size,\r\ntu->args[i].type->is_signed,\r\nFILTER_OTHER);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __set_print_fmt(struct trace_uprobe *tu, char *buf, int len)\r\n{\r\nconst char *fmt, *arg;\r\nint i;\r\nint pos = 0;\r\nfmt = "(%lx)";\r\narg = "REC->" FIELD_STRING_IP;\r\npos += snprintf(buf + pos, LEN_OR_ZERO, "\"%s", fmt);\r\nfor (i = 0; i < tu->nr_args; i++) {\r\npos += snprintf(buf + pos, LEN_OR_ZERO, " %s=%s",\r\ntu->args[i].name, tu->args[i].type->fmt);\r\n}\r\npos += snprintf(buf + pos, LEN_OR_ZERO, "\", %s", arg);\r\nfor (i = 0; i < tu->nr_args; i++) {\r\npos += snprintf(buf + pos, LEN_OR_ZERO, ", REC->%s",\r\ntu->args[i].name);\r\n}\r\nreturn pos;\r\n}\r\nstatic int set_print_fmt(struct trace_uprobe *tu)\r\n{\r\nchar *print_fmt;\r\nint len;\r\nlen = __set_print_fmt(tu, NULL, 0);\r\nprint_fmt = kmalloc(len + 1, GFP_KERNEL);\r\nif (!print_fmt)\r\nreturn -ENOMEM;\r\n__set_print_fmt(tu, print_fmt, len + 1);\r\ntu->call.print_fmt = print_fmt;\r\nreturn 0;\r\n}\r\nstatic void uprobe_perf_func(struct trace_uprobe *tu, struct pt_regs *regs)\r\n{\r\nstruct ftrace_event_call *call = &tu->call;\r\nstruct uprobe_trace_entry_head *entry;\r\nstruct hlist_head *head;\r\nu8 *data;\r\nint size, __size, i;\r\nint rctx;\r\n__size = sizeof(*entry) + tu->size;\r\nsize = ALIGN(__size + sizeof(u32), sizeof(u64));\r\nsize -= sizeof(u32);\r\nif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, "profile buffer not large enough"))\r\nreturn;\r\npreempt_disable();\r\nentry = perf_trace_buf_prepare(size, call->event.type, regs, &rctx);\r\nif (!entry)\r\ngoto out;\r\nentry->ip = uprobe_get_swbp_addr(task_pt_regs(current));\r\ndata = (u8 *)&entry[1];\r\nfor (i = 0; i < tu->nr_args; i++)\r\ncall_fetch(&tu->args[i].fetch, regs, data + tu->args[i].offset);\r\nhead = this_cpu_ptr(call->perf_events);\r\nperf_trace_buf_submit(entry, size, rctx, entry->ip, 1, regs, head, NULL);\r\nout:\r\npreempt_enable();\r\n}\r\nstatic\r\nint trace_uprobe_register(struct ftrace_event_call *event, enum trace_reg type, void *data)\r\n{\r\nstruct trace_uprobe *tu = (struct trace_uprobe *)event->data;\r\nswitch (type) {\r\ncase TRACE_REG_REGISTER:\r\nreturn probe_event_enable(tu, TP_FLAG_TRACE);\r\ncase TRACE_REG_UNREGISTER:\r\nprobe_event_disable(tu, TP_FLAG_TRACE);\r\nreturn 0;\r\n#ifdef CONFIG_PERF_EVENTS\r\ncase TRACE_REG_PERF_REGISTER:\r\nreturn probe_event_enable(tu, TP_FLAG_PROFILE);\r\ncase TRACE_REG_PERF_UNREGISTER:\r\nprobe_event_disable(tu, TP_FLAG_PROFILE);\r\nreturn 0;\r\n#endif\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs)\r\n{\r\nstruct uprobe_trace_consumer *utc;\r\nstruct trace_uprobe *tu;\r\nutc = container_of(con, struct uprobe_trace_consumer, cons);\r\ntu = utc->tu;\r\nif (!tu || tu->consumer != utc)\r\nreturn 0;\r\nif (tu->flags & TP_FLAG_TRACE)\r\nuprobe_trace_func(tu, regs);\r\n#ifdef CONFIG_PERF_EVENTS\r\nif (tu->flags & TP_FLAG_PROFILE)\r\nuprobe_perf_func(tu, regs);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int register_uprobe_event(struct trace_uprobe *tu)\r\n{\r\nstruct ftrace_event_call *call = &tu->call;\r\nint ret;\r\nINIT_LIST_HEAD(&call->class->fields);\r\ncall->event.funcs = &uprobe_funcs;\r\ncall->class->define_fields = uprobe_event_define_fields;\r\nif (set_print_fmt(tu) < 0)\r\nreturn -ENOMEM;\r\nret = register_ftrace_event(&call->event);\r\nif (!ret) {\r\nkfree(call->print_fmt);\r\nreturn -ENODEV;\r\n}\r\ncall->flags = 0;\r\ncall->class->reg = trace_uprobe_register;\r\ncall->data = tu;\r\nret = trace_add_event_call(call);\r\nif (ret) {\r\npr_info("Failed to register uprobe event: %s\n", call->name);\r\nkfree(call->print_fmt);\r\nunregister_ftrace_event(&call->event);\r\n}\r\nreturn ret;\r\n}\r\nstatic void unregister_uprobe_event(struct trace_uprobe *tu)\r\n{\r\ntrace_remove_event_call(&tu->call);\r\nkfree(tu->call.print_fmt);\r\ntu->call.print_fmt = NULL;\r\n}\r\nstatic __init int init_uprobe_trace(void)\r\n{\r\nstruct dentry *d_tracer;\r\nd_tracer = tracing_init_dentry();\r\nif (!d_tracer)\r\nreturn 0;\r\ntrace_create_file("uprobe_events", 0644, d_tracer,\r\nNULL, &uprobe_events_ops);\r\ntrace_create_file("uprobe_profile", 0444, d_tracer,\r\nNULL, &uprobe_profile_ops);\r\nreturn 0;\r\n}
