int dlm_modes_compat(int mode1, int mode2)\r\n{\r\nreturn __dlm_compat_matrix[mode1 + 1][mode2 + 1];\r\n}\r\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\r\n{\r\nprintk(KERN_ERR "lkb: nodeid %d id %x remid %x exflags %x flags %x "\r\n"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\n",\r\nlkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\r\nlkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\r\nlkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\r\n(unsigned long long)lkb->lkb_recover_seq);\r\n}\r\nstatic void dlm_print_rsb(struct dlm_rsb *r)\r\n{\r\nprintk(KERN_ERR "rsb: nodeid %d master %d dir %d flags %lx first %x "\r\n"rlc %d name %s\n",\r\nr->res_nodeid, r->res_master_nodeid, r->res_dir_nodeid,\r\nr->res_flags, r->res_first_lkid, r->res_recover_locks_count,\r\nr->res_name);\r\n}\r\nvoid dlm_dump_rsb(struct dlm_rsb *r)\r\n{\r\nstruct dlm_lkb *lkb;\r\ndlm_print_rsb(r);\r\nprintk(KERN_ERR "rsb: root_list empty %d recover_list empty %d\n",\r\nlist_empty(&r->res_root_list), list_empty(&r->res_recover_list));\r\nprintk(KERN_ERR "rsb lookup list\n");\r\nlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\r\ndlm_print_lkb(lkb);\r\nprintk(KERN_ERR "rsb grant queue:\n");\r\nlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\r\ndlm_print_lkb(lkb);\r\nprintk(KERN_ERR "rsb convert queue:\n");\r\nlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\r\ndlm_print_lkb(lkb);\r\nprintk(KERN_ERR "rsb wait queue:\n");\r\nlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\r\ndlm_print_lkb(lkb);\r\n}\r\nstatic inline void dlm_lock_recovery(struct dlm_ls *ls)\r\n{\r\ndown_read(&ls->ls_in_recovery);\r\n}\r\nvoid dlm_unlock_recovery(struct dlm_ls *ls)\r\n{\r\nup_read(&ls->ls_in_recovery);\r\n}\r\nint dlm_lock_recovery_try(struct dlm_ls *ls)\r\n{\r\nreturn down_read_trylock(&ls->ls_in_recovery);\r\n}\r\nstatic inline int can_be_queued(struct dlm_lkb *lkb)\r\n{\r\nreturn !(lkb->lkb_exflags & DLM_LKF_NOQUEUE);\r\n}\r\nstatic inline int force_blocking_asts(struct dlm_lkb *lkb)\r\n{\r\nreturn (lkb->lkb_exflags & DLM_LKF_NOQUEUEBAST);\r\n}\r\nstatic inline int is_demoted(struct dlm_lkb *lkb)\r\n{\r\nreturn (lkb->lkb_sbflags & DLM_SBF_DEMOTED);\r\n}\r\nstatic inline int is_altmode(struct dlm_lkb *lkb)\r\n{\r\nreturn (lkb->lkb_sbflags & DLM_SBF_ALTMODE);\r\n}\r\nstatic inline int is_granted(struct dlm_lkb *lkb)\r\n{\r\nreturn (lkb->lkb_status == DLM_LKSTS_GRANTED);\r\n}\r\nstatic inline int is_remote(struct dlm_rsb *r)\r\n{\r\nDLM_ASSERT(r->res_nodeid >= 0, dlm_print_rsb(r););\r\nreturn !!r->res_nodeid;\r\n}\r\nstatic inline int is_process_copy(struct dlm_lkb *lkb)\r\n{\r\nreturn (lkb->lkb_nodeid && !(lkb->lkb_flags & DLM_IFL_MSTCPY));\r\n}\r\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\r\n{\r\nreturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\r\n}\r\nstatic inline int middle_conversion(struct dlm_lkb *lkb)\r\n{\r\nif ((lkb->lkb_grmode==DLM_LOCK_PR && lkb->lkb_rqmode==DLM_LOCK_CW) ||\r\n(lkb->lkb_rqmode==DLM_LOCK_PR && lkb->lkb_grmode==DLM_LOCK_CW))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int down_conversion(struct dlm_lkb *lkb)\r\n{\r\nreturn (!middle_conversion(lkb) && lkb->lkb_rqmode < lkb->lkb_grmode);\r\n}\r\nstatic inline int is_overlap_unlock(struct dlm_lkb *lkb)\r\n{\r\nreturn lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;\r\n}\r\nstatic inline int is_overlap_cancel(struct dlm_lkb *lkb)\r\n{\r\nreturn lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;\r\n}\r\nstatic inline int is_overlap(struct dlm_lkb *lkb)\r\n{\r\nreturn (lkb->lkb_flags & (DLM_IFL_OVERLAP_UNLOCK |\r\nDLM_IFL_OVERLAP_CANCEL));\r\n}\r\nstatic void queue_cast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\r\n{\r\nif (is_master_copy(lkb))\r\nreturn;\r\ndel_timeout(lkb);\r\nDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););\r\nif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL)) {\r\nlkb->lkb_flags &= ~DLM_IFL_TIMEOUT_CANCEL;\r\nrv = -ETIMEDOUT;\r\n}\r\nif (rv == -DLM_ECANCEL && (lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL)) {\r\nlkb->lkb_flags &= ~DLM_IFL_DEADLOCK_CANCEL;\r\nrv = -EDEADLK;\r\n}\r\ndlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, lkb->lkb_sbflags);\r\n}\r\nstatic inline void queue_cast_overlap(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nqueue_cast(r, lkb,\r\nis_overlap_unlock(lkb) ? -DLM_EUNLOCK : -DLM_ECANCEL);\r\n}\r\nstatic void queue_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int rqmode)\r\n{\r\nif (is_master_copy(lkb)) {\r\nsend_bast(r, lkb, rqmode);\r\n} else {\r\ndlm_add_cb(lkb, DLM_CB_BAST, rqmode, 0, 0);\r\n}\r\n}\r\nstatic inline void hold_rsb(struct dlm_rsb *r)\r\n{\r\nkref_get(&r->res_ref);\r\n}\r\nvoid dlm_hold_rsb(struct dlm_rsb *r)\r\n{\r\nhold_rsb(r);\r\n}\r\nstatic void put_rsb(struct dlm_rsb *r)\r\n{\r\nstruct dlm_ls *ls = r->res_ls;\r\nuint32_t bucket = r->res_bucket;\r\nspin_lock(&ls->ls_rsbtbl[bucket].lock);\r\nkref_put(&r->res_ref, toss_rsb);\r\nspin_unlock(&ls->ls_rsbtbl[bucket].lock);\r\n}\r\nvoid dlm_put_rsb(struct dlm_rsb *r)\r\n{\r\nput_rsb(r);\r\n}\r\nstatic int pre_rsb_struct(struct dlm_ls *ls)\r\n{\r\nstruct dlm_rsb *r1, *r2;\r\nint count = 0;\r\nspin_lock(&ls->ls_new_rsb_spin);\r\nif (ls->ls_new_rsb_count > dlm_config.ci_new_rsb_count / 2) {\r\nspin_unlock(&ls->ls_new_rsb_spin);\r\nreturn 0;\r\n}\r\nspin_unlock(&ls->ls_new_rsb_spin);\r\nr1 = dlm_allocate_rsb(ls);\r\nr2 = dlm_allocate_rsb(ls);\r\nspin_lock(&ls->ls_new_rsb_spin);\r\nif (r1) {\r\nlist_add(&r1->res_hashchain, &ls->ls_new_rsb);\r\nls->ls_new_rsb_count++;\r\n}\r\nif (r2) {\r\nlist_add(&r2->res_hashchain, &ls->ls_new_rsb);\r\nls->ls_new_rsb_count++;\r\n}\r\ncount = ls->ls_new_rsb_count;\r\nspin_unlock(&ls->ls_new_rsb_spin);\r\nif (!count)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int get_rsb_struct(struct dlm_ls *ls, char *name, int len,\r\nstruct dlm_rsb **r_ret)\r\n{\r\nstruct dlm_rsb *r;\r\nint count;\r\nspin_lock(&ls->ls_new_rsb_spin);\r\nif (list_empty(&ls->ls_new_rsb)) {\r\ncount = ls->ls_new_rsb_count;\r\nspin_unlock(&ls->ls_new_rsb_spin);\r\nlog_debug(ls, "find_rsb retry %d %d %s",\r\ncount, dlm_config.ci_new_rsb_count, name);\r\nreturn -EAGAIN;\r\n}\r\nr = list_first_entry(&ls->ls_new_rsb, struct dlm_rsb, res_hashchain);\r\nlist_del(&r->res_hashchain);\r\nmemset(&r->res_hashnode, 0, sizeof(struct rb_node));\r\nls->ls_new_rsb_count--;\r\nspin_unlock(&ls->ls_new_rsb_spin);\r\nr->res_ls = ls;\r\nr->res_length = len;\r\nmemcpy(r->res_name, name, len);\r\nmutex_init(&r->res_mutex);\r\nINIT_LIST_HEAD(&r->res_lookup);\r\nINIT_LIST_HEAD(&r->res_grantqueue);\r\nINIT_LIST_HEAD(&r->res_convertqueue);\r\nINIT_LIST_HEAD(&r->res_waitqueue);\r\nINIT_LIST_HEAD(&r->res_root_list);\r\nINIT_LIST_HEAD(&r->res_recover_list);\r\n*r_ret = r;\r\nreturn 0;\r\n}\r\nstatic int rsb_cmp(struct dlm_rsb *r, const char *name, int nlen)\r\n{\r\nchar maxname[DLM_RESNAME_MAXLEN];\r\nmemset(maxname, 0, DLM_RESNAME_MAXLEN);\r\nmemcpy(maxname, name, nlen);\r\nreturn memcmp(r->res_name, maxname, DLM_RESNAME_MAXLEN);\r\n}\r\nint dlm_search_rsb_tree(struct rb_root *tree, char *name, int len,\r\nstruct dlm_rsb **r_ret)\r\n{\r\nstruct rb_node *node = tree->rb_node;\r\nstruct dlm_rsb *r;\r\nint rc;\r\nwhile (node) {\r\nr = rb_entry(node, struct dlm_rsb, res_hashnode);\r\nrc = rsb_cmp(r, name, len);\r\nif (rc < 0)\r\nnode = node->rb_left;\r\nelse if (rc > 0)\r\nnode = node->rb_right;\r\nelse\r\ngoto found;\r\n}\r\n*r_ret = NULL;\r\nreturn -EBADR;\r\nfound:\r\n*r_ret = r;\r\nreturn 0;\r\n}\r\nstatic int rsb_insert(struct dlm_rsb *rsb, struct rb_root *tree)\r\n{\r\nstruct rb_node **newn = &tree->rb_node;\r\nstruct rb_node *parent = NULL;\r\nint rc;\r\nwhile (*newn) {\r\nstruct dlm_rsb *cur = rb_entry(*newn, struct dlm_rsb,\r\nres_hashnode);\r\nparent = *newn;\r\nrc = rsb_cmp(cur, rsb->res_name, rsb->res_length);\r\nif (rc < 0)\r\nnewn = &parent->rb_left;\r\nelse if (rc > 0)\r\nnewn = &parent->rb_right;\r\nelse {\r\nlog_print("rsb_insert match");\r\ndlm_dump_rsb(rsb);\r\ndlm_dump_rsb(cur);\r\nreturn -EEXIST;\r\n}\r\n}\r\nrb_link_node(&rsb->res_hashnode, parent, newn);\r\nrb_insert_color(&rsb->res_hashnode, tree);\r\nreturn 0;\r\n}\r\nstatic int find_rsb_dir(struct dlm_ls *ls, char *name, int len,\r\nuint32_t hash, uint32_t b,\r\nint dir_nodeid, int from_nodeid,\r\nunsigned int flags, struct dlm_rsb **r_ret)\r\n{\r\nstruct dlm_rsb *r = NULL;\r\nint our_nodeid = dlm_our_nodeid();\r\nint from_local = 0;\r\nint from_other = 0;\r\nint from_dir = 0;\r\nint create = 0;\r\nint error;\r\nif (flags & R_RECEIVE_REQUEST) {\r\nif (from_nodeid == dir_nodeid)\r\nfrom_dir = 1;\r\nelse\r\nfrom_other = 1;\r\n} else if (flags & R_REQUEST) {\r\nfrom_local = 1;\r\n}\r\nif (from_local || from_dir ||\r\n(from_other && (dir_nodeid == our_nodeid))) {\r\ncreate = 1;\r\n}\r\nretry:\r\nif (create) {\r\nerror = pre_rsb_struct(ls);\r\nif (error < 0)\r\ngoto out;\r\n}\r\nspin_lock(&ls->ls_rsbtbl[b].lock);\r\nerror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\r\nif (error)\r\ngoto do_toss;\r\nkref_get(&r->res_ref);\r\nerror = 0;\r\ngoto out_unlock;\r\ndo_toss:\r\nerror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\r\nif (error)\r\ngoto do_new;\r\nif ((r->res_master_nodeid != our_nodeid) && from_other) {\r\nlog_debug(ls, "find_rsb toss from_other %d master %d dir %d %s",\r\nfrom_nodeid, r->res_master_nodeid, dir_nodeid,\r\nr->res_name);\r\nerror = -ENOTBLK;\r\ngoto out_unlock;\r\n}\r\nif ((r->res_master_nodeid != our_nodeid) && from_dir) {\r\nlog_error(ls, "find_rsb toss from_dir %d master %d",\r\nfrom_nodeid, r->res_master_nodeid);\r\ndlm_print_rsb(r);\r\nr->res_master_nodeid = our_nodeid;\r\nr->res_nodeid = 0;\r\nrsb_clear_flag(r, RSB_MASTER_UNCERTAIN);\r\nr->res_first_lkid = 0;\r\n}\r\nif (from_local && (r->res_master_nodeid != our_nodeid)) {\r\nrsb_set_flag(r, RSB_MASTER_UNCERTAIN);\r\nr->res_first_lkid = 0;\r\n}\r\nrb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\r\nerror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\r\ngoto out_unlock;\r\ndo_new:\r\nif (error == -EBADR && !create)\r\ngoto out_unlock;\r\nerror = get_rsb_struct(ls, name, len, &r);\r\nif (error == -EAGAIN) {\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\ngoto retry;\r\n}\r\nif (error)\r\ngoto out_unlock;\r\nr->res_hash = hash;\r\nr->res_bucket = b;\r\nr->res_dir_nodeid = dir_nodeid;\r\nkref_init(&r->res_ref);\r\nif (from_dir) {\r\nlog_debug(ls, "find_rsb new from_dir %d recreate %s",\r\nfrom_nodeid, r->res_name);\r\nr->res_master_nodeid = our_nodeid;\r\nr->res_nodeid = 0;\r\ngoto out_add;\r\n}\r\nif (from_other && (dir_nodeid != our_nodeid)) {\r\nlog_error(ls, "find_rsb new from_other %d dir %d our %d %s",\r\nfrom_nodeid, dir_nodeid, our_nodeid, r->res_name);\r\ndlm_free_rsb(r);\r\nerror = -ENOTBLK;\r\ngoto out_unlock;\r\n}\r\nif (from_other) {\r\nlog_debug(ls, "find_rsb new from_other %d dir %d %s",\r\nfrom_nodeid, dir_nodeid, r->res_name);\r\n}\r\nif (dir_nodeid == our_nodeid) {\r\nr->res_master_nodeid = our_nodeid;\r\nr->res_nodeid = 0;\r\n} else {\r\nr->res_master_nodeid = 0;\r\nr->res_nodeid = -1;\r\n}\r\nout_add:\r\nerror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\r\nout_unlock:\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nout:\r\n*r_ret = r;\r\nreturn error;\r\n}\r\nstatic int find_rsb_nodir(struct dlm_ls *ls, char *name, int len,\r\nuint32_t hash, uint32_t b,\r\nint dir_nodeid, int from_nodeid,\r\nunsigned int flags, struct dlm_rsb **r_ret)\r\n{\r\nstruct dlm_rsb *r = NULL;\r\nint our_nodeid = dlm_our_nodeid();\r\nint recover = (flags & R_RECEIVE_RECOVER);\r\nint error;\r\nretry:\r\nerror = pre_rsb_struct(ls);\r\nif (error < 0)\r\ngoto out;\r\nspin_lock(&ls->ls_rsbtbl[b].lock);\r\nerror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\r\nif (error)\r\ngoto do_toss;\r\nkref_get(&r->res_ref);\r\ngoto out_unlock;\r\ndo_toss:\r\nerror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\r\nif (error)\r\ngoto do_new;\r\nif (!recover && (r->res_master_nodeid != our_nodeid) && from_nodeid) {\r\nlog_error(ls, "find_rsb toss from_nodeid %d master %d dir %d",\r\nfrom_nodeid, r->res_master_nodeid, dir_nodeid);\r\ndlm_print_rsb(r);\r\nerror = -ENOTBLK;\r\ngoto out_unlock;\r\n}\r\nif (!recover && (r->res_master_nodeid != our_nodeid) &&\r\n(dir_nodeid == our_nodeid)) {\r\nlog_error(ls, "find_rsb toss our %d master %d dir %d",\r\nour_nodeid, r->res_master_nodeid, dir_nodeid);\r\ndlm_print_rsb(r);\r\nr->res_master_nodeid = our_nodeid;\r\nr->res_nodeid = 0;\r\n}\r\nrb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\r\nerror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\r\ngoto out_unlock;\r\ndo_new:\r\nerror = get_rsb_struct(ls, name, len, &r);\r\nif (error == -EAGAIN) {\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\ngoto retry;\r\n}\r\nif (error)\r\ngoto out_unlock;\r\nr->res_hash = hash;\r\nr->res_bucket = b;\r\nr->res_dir_nodeid = dir_nodeid;\r\nr->res_master_nodeid = dir_nodeid;\r\nr->res_nodeid = (dir_nodeid == our_nodeid) ? 0 : dir_nodeid;\r\nkref_init(&r->res_ref);\r\nerror = rsb_insert(r, &ls->ls_rsbtbl[b].keep);\r\nout_unlock:\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nout:\r\n*r_ret = r;\r\nreturn error;\r\n}\r\nstatic int find_rsb(struct dlm_ls *ls, char *name, int len, int from_nodeid,\r\nunsigned int flags, struct dlm_rsb **r_ret)\r\n{\r\nuint32_t hash, b;\r\nint dir_nodeid;\r\nif (len > DLM_RESNAME_MAXLEN)\r\nreturn -EINVAL;\r\nhash = jhash(name, len, 0);\r\nb = hash & (ls->ls_rsbtbl_size - 1);\r\ndir_nodeid = dlm_hash2nodeid(ls, hash);\r\nif (dlm_no_directory(ls))\r\nreturn find_rsb_nodir(ls, name, len, hash, b, dir_nodeid,\r\nfrom_nodeid, flags, r_ret);\r\nelse\r\nreturn find_rsb_dir(ls, name, len, hash, b, dir_nodeid,\r\nfrom_nodeid, flags, r_ret);\r\n}\r\nstatic int validate_master_nodeid(struct dlm_ls *ls, struct dlm_rsb *r,\r\nint from_nodeid)\r\n{\r\nif (dlm_no_directory(ls)) {\r\nlog_error(ls, "find_rsb keep from_nodeid %d master %d dir %d",\r\nfrom_nodeid, r->res_master_nodeid,\r\nr->res_dir_nodeid);\r\ndlm_print_rsb(r);\r\nreturn -ENOTBLK;\r\n}\r\nif (from_nodeid != r->res_dir_nodeid) {\r\nif (r->res_master_nodeid) {\r\nlog_debug(ls, "validate master from_other %d master %d "\r\n"dir %d first %x %s", from_nodeid,\r\nr->res_master_nodeid, r->res_dir_nodeid,\r\nr->res_first_lkid, r->res_name);\r\n}\r\nreturn -ENOTBLK;\r\n} else {\r\nif (r->res_master_nodeid) {\r\nlog_error(ls, "validate master from_dir %d master %d "\r\n"first %x %s",\r\nfrom_nodeid, r->res_master_nodeid,\r\nr->res_first_lkid, r->res_name);\r\n}\r\nr->res_master_nodeid = dlm_our_nodeid();\r\nr->res_nodeid = 0;\r\nreturn 0;\r\n}\r\n}\r\nint dlm_master_lookup(struct dlm_ls *ls, int from_nodeid, char *name, int len,\r\nunsigned int flags, int *r_nodeid, int *result)\r\n{\r\nstruct dlm_rsb *r = NULL;\r\nuint32_t hash, b;\r\nint from_master = (flags & DLM_LU_RECOVER_DIR);\r\nint fix_master = (flags & DLM_LU_RECOVER_MASTER);\r\nint our_nodeid = dlm_our_nodeid();\r\nint dir_nodeid, error, toss_list = 0;\r\nif (len > DLM_RESNAME_MAXLEN)\r\nreturn -EINVAL;\r\nif (from_nodeid == our_nodeid) {\r\nlog_error(ls, "dlm_master_lookup from our_nodeid %d flags %x",\r\nour_nodeid, flags);\r\nreturn -EINVAL;\r\n}\r\nhash = jhash(name, len, 0);\r\nb = hash & (ls->ls_rsbtbl_size - 1);\r\ndir_nodeid = dlm_hash2nodeid(ls, hash);\r\nif (dir_nodeid != our_nodeid) {\r\nlog_error(ls, "dlm_master_lookup from %d dir %d our %d h %x %d",\r\nfrom_nodeid, dir_nodeid, our_nodeid, hash,\r\nls->ls_num_nodes);\r\n*r_nodeid = -1;\r\nreturn -EINVAL;\r\n}\r\nretry:\r\nerror = pre_rsb_struct(ls);\r\nif (error < 0)\r\nreturn error;\r\nspin_lock(&ls->ls_rsbtbl[b].lock);\r\nerror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\r\nif (!error) {\r\nhold_rsb(r);\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nlock_rsb(r);\r\ngoto found;\r\n}\r\nerror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\r\nif (error)\r\ngoto not_found;\r\ntoss_list = 1;\r\nfound:\r\nif (r->res_dir_nodeid != our_nodeid) {\r\nlog_error(ls, "dlm_master_lookup res_dir %d our %d %s",\r\nr->res_dir_nodeid, our_nodeid, r->res_name);\r\nr->res_dir_nodeid = our_nodeid;\r\n}\r\nif (fix_master && dlm_is_removed(ls, r->res_master_nodeid)) {\r\nr->res_master_nodeid = from_nodeid;\r\nr->res_nodeid = from_nodeid;\r\nrsb_set_flag(r, RSB_NEW_MASTER);\r\nif (toss_list) {\r\nlog_error(ls, "dlm_master_lookup fix_master on toss");\r\ndlm_dump_rsb(r);\r\n}\r\n}\r\nif (from_master && (r->res_master_nodeid != from_nodeid)) {\r\nlog_limit(ls, "dlm_master_lookup from_master %d "\r\n"master_nodeid %d res_nodeid %d first %x %s",\r\nfrom_nodeid, r->res_master_nodeid, r->res_nodeid,\r\nr->res_first_lkid, r->res_name);\r\nif (r->res_master_nodeid == our_nodeid) {\r\nlog_error(ls, "from_master %d our_master", from_nodeid);\r\ndlm_dump_rsb(r);\r\ndlm_send_rcom_lookup_dump(r, from_nodeid);\r\ngoto out_found;\r\n}\r\nr->res_master_nodeid = from_nodeid;\r\nr->res_nodeid = from_nodeid;\r\nrsb_set_flag(r, RSB_NEW_MASTER);\r\n}\r\nif (!r->res_master_nodeid) {\r\nlog_debug(ls, "dlm_master_lookup master 0 to %d first %x %s",\r\nfrom_nodeid, r->res_first_lkid, r->res_name);\r\nr->res_master_nodeid = from_nodeid;\r\nr->res_nodeid = from_nodeid;\r\n}\r\nif (!from_master && !fix_master &&\r\n(r->res_master_nodeid == from_nodeid)) {\r\nlog_limit(ls, "dlm_master_lookup from master %d flags %x "\r\n"first %x %s", from_nodeid, flags,\r\nr->res_first_lkid, r->res_name);\r\n}\r\nout_found:\r\n*r_nodeid = r->res_master_nodeid;\r\nif (result)\r\n*result = DLM_LU_MATCH;\r\nif (toss_list) {\r\nr->res_toss_time = jiffies;\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\n} else {\r\nunlock_rsb(r);\r\nput_rsb(r);\r\n}\r\nreturn 0;\r\nnot_found:\r\nerror = get_rsb_struct(ls, name, len, &r);\r\nif (error == -EAGAIN) {\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\ngoto retry;\r\n}\r\nif (error)\r\ngoto out_unlock;\r\nr->res_hash = hash;\r\nr->res_bucket = b;\r\nr->res_dir_nodeid = our_nodeid;\r\nr->res_master_nodeid = from_nodeid;\r\nr->res_nodeid = from_nodeid;\r\nkref_init(&r->res_ref);\r\nr->res_toss_time = jiffies;\r\nerror = rsb_insert(r, &ls->ls_rsbtbl[b].toss);\r\nif (error) {\r\ndlm_free_rsb(r);\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\ngoto retry;\r\n}\r\nif (result)\r\n*result = DLM_LU_ADD;\r\n*r_nodeid = from_nodeid;\r\nerror = 0;\r\nout_unlock:\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nreturn error;\r\n}\r\nstatic void dlm_dump_rsb_hash(struct dlm_ls *ls, uint32_t hash)\r\n{\r\nstruct rb_node *n;\r\nstruct dlm_rsb *r;\r\nint i;\r\nfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\r\nspin_lock(&ls->ls_rsbtbl[i].lock);\r\nfor (n = rb_first(&ls->ls_rsbtbl[i].keep); n; n = rb_next(n)) {\r\nr = rb_entry(n, struct dlm_rsb, res_hashnode);\r\nif (r->res_hash == hash)\r\ndlm_dump_rsb(r);\r\n}\r\nspin_unlock(&ls->ls_rsbtbl[i].lock);\r\n}\r\n}\r\nvoid dlm_dump_rsb_name(struct dlm_ls *ls, char *name, int len)\r\n{\r\nstruct dlm_rsb *r = NULL;\r\nuint32_t hash, b;\r\nint error;\r\nhash = jhash(name, len, 0);\r\nb = hash & (ls->ls_rsbtbl_size - 1);\r\nspin_lock(&ls->ls_rsbtbl[b].lock);\r\nerror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\r\nif (!error)\r\ngoto out_dump;\r\nerror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\r\nif (error)\r\ngoto out;\r\nout_dump:\r\ndlm_dump_rsb(r);\r\nout:\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\n}\r\nstatic void toss_rsb(struct kref *kref)\r\n{\r\nstruct dlm_rsb *r = container_of(kref, struct dlm_rsb, res_ref);\r\nstruct dlm_ls *ls = r->res_ls;\r\nDLM_ASSERT(list_empty(&r->res_root_list), dlm_print_rsb(r););\r\nkref_init(&r->res_ref);\r\nrb_erase(&r->res_hashnode, &ls->ls_rsbtbl[r->res_bucket].keep);\r\nrsb_insert(r, &ls->ls_rsbtbl[r->res_bucket].toss);\r\nr->res_toss_time = jiffies;\r\nif (r->res_lvbptr) {\r\ndlm_free_lvb(r->res_lvbptr);\r\nr->res_lvbptr = NULL;\r\n}\r\n}\r\nstatic void unhold_rsb(struct dlm_rsb *r)\r\n{\r\nint rv;\r\nrv = kref_put(&r->res_ref, toss_rsb);\r\nDLM_ASSERT(!rv, dlm_dump_rsb(r););\r\n}\r\nstatic void kill_rsb(struct kref *kref)\r\n{\r\nstruct dlm_rsb *r = container_of(kref, struct dlm_rsb, res_ref);\r\nDLM_ASSERT(list_empty(&r->res_lookup), dlm_dump_rsb(r););\r\nDLM_ASSERT(list_empty(&r->res_grantqueue), dlm_dump_rsb(r););\r\nDLM_ASSERT(list_empty(&r->res_convertqueue), dlm_dump_rsb(r););\r\nDLM_ASSERT(list_empty(&r->res_waitqueue), dlm_dump_rsb(r););\r\nDLM_ASSERT(list_empty(&r->res_root_list), dlm_dump_rsb(r););\r\nDLM_ASSERT(list_empty(&r->res_recover_list), dlm_dump_rsb(r););\r\n}\r\nstatic void attach_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nhold_rsb(r);\r\nlkb->lkb_resource = r;\r\n}\r\nstatic void detach_lkb(struct dlm_lkb *lkb)\r\n{\r\nif (lkb->lkb_resource) {\r\nput_rsb(lkb->lkb_resource);\r\nlkb->lkb_resource = NULL;\r\n}\r\n}\r\nstatic int create_lkb(struct dlm_ls *ls, struct dlm_lkb **lkb_ret)\r\n{\r\nstruct dlm_lkb *lkb;\r\nint rv, id;\r\nlkb = dlm_allocate_lkb(ls);\r\nif (!lkb)\r\nreturn -ENOMEM;\r\nlkb->lkb_nodeid = -1;\r\nlkb->lkb_grmode = DLM_LOCK_IV;\r\nkref_init(&lkb->lkb_ref);\r\nINIT_LIST_HEAD(&lkb->lkb_ownqueue);\r\nINIT_LIST_HEAD(&lkb->lkb_rsb_lookup);\r\nINIT_LIST_HEAD(&lkb->lkb_time_list);\r\nINIT_LIST_HEAD(&lkb->lkb_cb_list);\r\nmutex_init(&lkb->lkb_cb_mutex);\r\nINIT_WORK(&lkb->lkb_cb_work, dlm_callback_work);\r\nretry:\r\nrv = idr_pre_get(&ls->ls_lkbidr, GFP_NOFS);\r\nif (!rv)\r\nreturn -ENOMEM;\r\nspin_lock(&ls->ls_lkbidr_spin);\r\nrv = idr_get_new_above(&ls->ls_lkbidr, lkb, 1, &id);\r\nif (!rv)\r\nlkb->lkb_id = id;\r\nspin_unlock(&ls->ls_lkbidr_spin);\r\nif (rv == -EAGAIN)\r\ngoto retry;\r\nif (rv < 0) {\r\nlog_error(ls, "create_lkb idr error %d", rv);\r\nreturn rv;\r\n}\r\n*lkb_ret = lkb;\r\nreturn 0;\r\n}\r\nstatic int find_lkb(struct dlm_ls *ls, uint32_t lkid, struct dlm_lkb **lkb_ret)\r\n{\r\nstruct dlm_lkb *lkb;\r\nspin_lock(&ls->ls_lkbidr_spin);\r\nlkb = idr_find(&ls->ls_lkbidr, lkid);\r\nif (lkb)\r\nkref_get(&lkb->lkb_ref);\r\nspin_unlock(&ls->ls_lkbidr_spin);\r\n*lkb_ret = lkb;\r\nreturn lkb ? 0 : -ENOENT;\r\n}\r\nstatic void kill_lkb(struct kref *kref)\r\n{\r\nstruct dlm_lkb *lkb = container_of(kref, struct dlm_lkb, lkb_ref);\r\nDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\r\n}\r\nstatic int __put_lkb(struct dlm_ls *ls, struct dlm_lkb *lkb)\r\n{\r\nuint32_t lkid = lkb->lkb_id;\r\nspin_lock(&ls->ls_lkbidr_spin);\r\nif (kref_put(&lkb->lkb_ref, kill_lkb)) {\r\nidr_remove(&ls->ls_lkbidr, lkid);\r\nspin_unlock(&ls->ls_lkbidr_spin);\r\ndetach_lkb(lkb);\r\nif (lkb->lkb_lvbptr && is_master_copy(lkb))\r\ndlm_free_lvb(lkb->lkb_lvbptr);\r\ndlm_free_lkb(lkb);\r\nreturn 1;\r\n} else {\r\nspin_unlock(&ls->ls_lkbidr_spin);\r\nreturn 0;\r\n}\r\n}\r\nint dlm_put_lkb(struct dlm_lkb *lkb)\r\n{\r\nstruct dlm_ls *ls;\r\nDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\r\nDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\r\nls = lkb->lkb_resource->res_ls;\r\nreturn __put_lkb(ls, lkb);\r\n}\r\nstatic inline void hold_lkb(struct dlm_lkb *lkb)\r\n{\r\nkref_get(&lkb->lkb_ref);\r\n}\r\nstatic inline void unhold_lkb(struct dlm_lkb *lkb)\r\n{\r\nint rv;\r\nrv = kref_put(&lkb->lkb_ref, kill_lkb);\r\nDLM_ASSERT(!rv, dlm_print_lkb(lkb););\r\n}\r\nstatic void lkb_add_ordered(struct list_head *new, struct list_head *head,\r\nint mode)\r\n{\r\nstruct dlm_lkb *lkb = NULL;\r\nlist_for_each_entry(lkb, head, lkb_statequeue)\r\nif (lkb->lkb_rqmode < mode)\r\nbreak;\r\n__list_add(new, lkb->lkb_statequeue.prev, &lkb->lkb_statequeue);\r\n}\r\nstatic void add_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int status)\r\n{\r\nkref_get(&lkb->lkb_ref);\r\nDLM_ASSERT(!lkb->lkb_status, dlm_print_lkb(lkb););\r\nlkb->lkb_timestamp = ktime_get();\r\nlkb->lkb_status = status;\r\nswitch (status) {\r\ncase DLM_LKSTS_WAITING:\r\nif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\r\nlist_add(&lkb->lkb_statequeue, &r->res_waitqueue);\r\nelse\r\nlist_add_tail(&lkb->lkb_statequeue, &r->res_waitqueue);\r\nbreak;\r\ncase DLM_LKSTS_GRANTED:\r\nlkb_add_ordered(&lkb->lkb_statequeue, &r->res_grantqueue,\r\nlkb->lkb_grmode);\r\nbreak;\r\ncase DLM_LKSTS_CONVERT:\r\nif (lkb->lkb_exflags & DLM_LKF_HEADQUE)\r\nlist_add(&lkb->lkb_statequeue, &r->res_convertqueue);\r\nelse\r\nlist_add_tail(&lkb->lkb_statequeue,\r\n&r->res_convertqueue);\r\nbreak;\r\ndefault:\r\nDLM_ASSERT(0, dlm_print_lkb(lkb); printk("sts=%d\n", status););\r\n}\r\n}\r\nstatic void del_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nlkb->lkb_status = 0;\r\nlist_del(&lkb->lkb_statequeue);\r\nunhold_lkb(lkb);\r\n}\r\nstatic void move_lkb(struct dlm_rsb *r, struct dlm_lkb *lkb, int sts)\r\n{\r\nhold_lkb(lkb);\r\ndel_lkb(r, lkb);\r\nadd_lkb(r, lkb, sts);\r\nunhold_lkb(lkb);\r\n}\r\nstatic int msg_reply_type(int mstype)\r\n{\r\nswitch (mstype) {\r\ncase DLM_MSG_REQUEST:\r\nreturn DLM_MSG_REQUEST_REPLY;\r\ncase DLM_MSG_CONVERT:\r\nreturn DLM_MSG_CONVERT_REPLY;\r\ncase DLM_MSG_UNLOCK:\r\nreturn DLM_MSG_UNLOCK_REPLY;\r\ncase DLM_MSG_CANCEL:\r\nreturn DLM_MSG_CANCEL_REPLY;\r\ncase DLM_MSG_LOOKUP:\r\nreturn DLM_MSG_LOOKUP_REPLY;\r\n}\r\nreturn -1;\r\n}\r\nstatic int nodeid_warned(int nodeid, int num_nodes, int *warned)\r\n{\r\nint i;\r\nfor (i = 0; i < num_nodes; i++) {\r\nif (!warned[i]) {\r\nwarned[i] = nodeid;\r\nreturn 0;\r\n}\r\nif (warned[i] == nodeid)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid dlm_scan_waiters(struct dlm_ls *ls)\r\n{\r\nstruct dlm_lkb *lkb;\r\nktime_t zero = ktime_set(0, 0);\r\ns64 us;\r\ns64 debug_maxus = 0;\r\nu32 debug_scanned = 0;\r\nu32 debug_expired = 0;\r\nint num_nodes = 0;\r\nint *warned = NULL;\r\nif (!dlm_config.ci_waitwarn_us)\r\nreturn;\r\nmutex_lock(&ls->ls_waiters_mutex);\r\nlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\r\nif (ktime_equal(lkb->lkb_wait_time, zero))\r\ncontinue;\r\ndebug_scanned++;\r\nus = ktime_to_us(ktime_sub(ktime_get(), lkb->lkb_wait_time));\r\nif (us < dlm_config.ci_waitwarn_us)\r\ncontinue;\r\nlkb->lkb_wait_time = zero;\r\ndebug_expired++;\r\nif (us > debug_maxus)\r\ndebug_maxus = us;\r\nif (!num_nodes) {\r\nnum_nodes = ls->ls_num_nodes;\r\nwarned = kzalloc(num_nodes * sizeof(int), GFP_KERNEL);\r\n}\r\nif (!warned)\r\ncontinue;\r\nif (nodeid_warned(lkb->lkb_wait_nodeid, num_nodes, warned))\r\ncontinue;\r\nlog_error(ls, "waitwarn %x %lld %d us check connection to "\r\n"node %d", lkb->lkb_id, (long long)us,\r\ndlm_config.ci_waitwarn_us, lkb->lkb_wait_nodeid);\r\n}\r\nmutex_unlock(&ls->ls_waiters_mutex);\r\nkfree(warned);\r\nif (debug_expired)\r\nlog_debug(ls, "scan_waiters %u warn %u over %d us max %lld us",\r\ndebug_scanned, debug_expired,\r\ndlm_config.ci_waitwarn_us, (long long)debug_maxus);\r\n}\r\nstatic int add_to_waiters(struct dlm_lkb *lkb, int mstype, int to_nodeid)\r\n{\r\nstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\r\nint error = 0;\r\nmutex_lock(&ls->ls_waiters_mutex);\r\nif (is_overlap_unlock(lkb) ||\r\n(is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL))) {\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\nif (lkb->lkb_wait_type || is_overlap_cancel(lkb)) {\r\nswitch (mstype) {\r\ncase DLM_MSG_UNLOCK:\r\nlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\r\nbreak;\r\ncase DLM_MSG_CANCEL:\r\nlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\r\nbreak;\r\ndefault:\r\nerror = -EBUSY;\r\ngoto out;\r\n}\r\nlkb->lkb_wait_count++;\r\nhold_lkb(lkb);\r\nlog_debug(ls, "addwait %x cur %d overlap %d count %d f %x",\r\nlkb->lkb_id, lkb->lkb_wait_type, mstype,\r\nlkb->lkb_wait_count, lkb->lkb_flags);\r\ngoto out;\r\n}\r\nDLM_ASSERT(!lkb->lkb_wait_count,\r\ndlm_print_lkb(lkb);\r\nprintk("wait_count %d\n", lkb->lkb_wait_count););\r\nlkb->lkb_wait_count++;\r\nlkb->lkb_wait_type = mstype;\r\nlkb->lkb_wait_time = ktime_get();\r\nlkb->lkb_wait_nodeid = to_nodeid;\r\nhold_lkb(lkb);\r\nlist_add(&lkb->lkb_wait_reply, &ls->ls_waiters);\r\nout:\r\nif (error)\r\nlog_error(ls, "addwait error %x %d flags %x %d %d %s",\r\nlkb->lkb_id, error, lkb->lkb_flags, mstype,\r\nlkb->lkb_wait_type, lkb->lkb_resource->res_name);\r\nmutex_unlock(&ls->ls_waiters_mutex);\r\nreturn error;\r\n}\r\nstatic int _remove_from_waiters(struct dlm_lkb *lkb, int mstype,\r\nstruct dlm_message *ms)\r\n{\r\nstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\r\nint overlap_done = 0;\r\nif (is_overlap_unlock(lkb) && (mstype == DLM_MSG_UNLOCK_REPLY)) {\r\nlog_debug(ls, "remwait %x unlock_reply overlap", lkb->lkb_id);\r\nlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\r\noverlap_done = 1;\r\ngoto out_del;\r\n}\r\nif (is_overlap_cancel(lkb) && (mstype == DLM_MSG_CANCEL_REPLY)) {\r\nlog_debug(ls, "remwait %x cancel_reply overlap", lkb->lkb_id);\r\nlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\r\noverlap_done = 1;\r\ngoto out_del;\r\n}\r\nif ((mstype == DLM_MSG_CANCEL_REPLY) &&\r\n(lkb->lkb_wait_type != DLM_MSG_CANCEL)) {\r\nlog_debug(ls, "remwait %x cancel_reply wait_type %d",\r\nlkb->lkb_id, lkb->lkb_wait_type);\r\nreturn -1;\r\n}\r\nif ((mstype == DLM_MSG_CONVERT_REPLY) &&\r\n(lkb->lkb_wait_type == DLM_MSG_CONVERT) &&\r\nis_overlap_cancel(lkb) && ms && !ms->m_result) {\r\nlog_debug(ls, "remwait %x convert_reply zap overlap_cancel",\r\nlkb->lkb_id);\r\nlkb->lkb_wait_type = 0;\r\nlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\r\nlkb->lkb_wait_count--;\r\ngoto out_del;\r\n}\r\nif (lkb->lkb_wait_type) {\r\nlkb->lkb_wait_type = 0;\r\ngoto out_del;\r\n}\r\nlog_error(ls, "remwait error %x remote %d %x msg %d flags %x no wait",\r\nlkb->lkb_id, ms ? ms->m_header.h_nodeid : 0, lkb->lkb_remid,\r\nmstype, lkb->lkb_flags);\r\nreturn -1;\r\nout_del:\r\nif (overlap_done && lkb->lkb_wait_type) {\r\nlog_error(ls, "remwait error %x reply %d wait_type %d overlap",\r\nlkb->lkb_id, mstype, lkb->lkb_wait_type);\r\nlkb->lkb_wait_count--;\r\nlkb->lkb_wait_type = 0;\r\n}\r\nDLM_ASSERT(lkb->lkb_wait_count, dlm_print_lkb(lkb););\r\nlkb->lkb_flags &= ~DLM_IFL_RESEND;\r\nlkb->lkb_wait_count--;\r\nif (!lkb->lkb_wait_count)\r\nlist_del_init(&lkb->lkb_wait_reply);\r\nunhold_lkb(lkb);\r\nreturn 0;\r\n}\r\nstatic int remove_from_waiters(struct dlm_lkb *lkb, int mstype)\r\n{\r\nstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\r\nint error;\r\nmutex_lock(&ls->ls_waiters_mutex);\r\nerror = _remove_from_waiters(lkb, mstype, NULL);\r\nmutex_unlock(&ls->ls_waiters_mutex);\r\nreturn error;\r\n}\r\nstatic int remove_from_waiters_ms(struct dlm_lkb *lkb, struct dlm_message *ms)\r\n{\r\nstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\r\nint error;\r\nif (ms->m_flags != DLM_IFL_STUB_MS)\r\nmutex_lock(&ls->ls_waiters_mutex);\r\nerror = _remove_from_waiters(lkb, ms->m_type, ms);\r\nif (ms->m_flags != DLM_IFL_STUB_MS)\r\nmutex_unlock(&ls->ls_waiters_mutex);\r\nreturn error;\r\n}\r\nstatic void wait_pending_remove(struct dlm_rsb *r)\r\n{\r\nstruct dlm_ls *ls = r->res_ls;\r\nrestart:\r\nspin_lock(&ls->ls_remove_spin);\r\nif (ls->ls_remove_len &&\r\n!rsb_cmp(r, ls->ls_remove_name, ls->ls_remove_len)) {\r\nlog_debug(ls, "delay lookup for remove dir %d %s",\r\nr->res_dir_nodeid, r->res_name);\r\nspin_unlock(&ls->ls_remove_spin);\r\nmsleep(1);\r\ngoto restart;\r\n}\r\nspin_unlock(&ls->ls_remove_spin);\r\n}\r\nstatic void shrink_bucket(struct dlm_ls *ls, int b)\r\n{\r\nstruct rb_node *n, *next;\r\nstruct dlm_rsb *r;\r\nchar *name;\r\nint our_nodeid = dlm_our_nodeid();\r\nint remote_count = 0;\r\nint i, len, rv;\r\nmemset(&ls->ls_remove_lens, 0, sizeof(int) * DLM_REMOVE_NAMES_MAX);\r\nspin_lock(&ls->ls_rsbtbl[b].lock);\r\nfor (n = rb_first(&ls->ls_rsbtbl[b].toss); n; n = next) {\r\nnext = rb_next(n);\r\nr = rb_entry(n, struct dlm_rsb, res_hashnode);\r\nif (!dlm_no_directory(ls) &&\r\n(r->res_master_nodeid != our_nodeid) &&\r\n(dlm_dir_nodeid(r) == our_nodeid)) {\r\ncontinue;\r\n}\r\nif (!time_after_eq(jiffies, r->res_toss_time +\r\ndlm_config.ci_toss_secs * HZ)) {\r\ncontinue;\r\n}\r\nif (!dlm_no_directory(ls) &&\r\n(r->res_master_nodeid == our_nodeid) &&\r\n(dlm_dir_nodeid(r) != our_nodeid)) {\r\nls->ls_remove_lens[remote_count] = r->res_length;\r\nmemcpy(ls->ls_remove_names[remote_count], r->res_name,\r\nDLM_RESNAME_MAXLEN);\r\nremote_count++;\r\nif (remote_count >= DLM_REMOVE_NAMES_MAX)\r\nbreak;\r\ncontinue;\r\n}\r\nif (!kref_put(&r->res_ref, kill_rsb)) {\r\nlog_error(ls, "tossed rsb in use %s", r->res_name);\r\ncontinue;\r\n}\r\nrb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\r\ndlm_free_rsb(r);\r\n}\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nfor (i = 0; i < remote_count; i++) {\r\nname = ls->ls_remove_names[i];\r\nlen = ls->ls_remove_lens[i];\r\nspin_lock(&ls->ls_rsbtbl[b].lock);\r\nrv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\r\nif (rv) {\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nlog_debug(ls, "remove_name not toss %s", name);\r\ncontinue;\r\n}\r\nif (r->res_master_nodeid != our_nodeid) {\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nlog_debug(ls, "remove_name master %d dir %d our %d %s",\r\nr->res_master_nodeid, r->res_dir_nodeid,\r\nour_nodeid, name);\r\ncontinue;\r\n}\r\nif (r->res_dir_nodeid == our_nodeid) {\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nlog_error(ls, "remove_name dir %d master %d our %d %s",\r\nr->res_dir_nodeid, r->res_master_nodeid,\r\nour_nodeid, name);\r\ncontinue;\r\n}\r\nif (!time_after_eq(jiffies, r->res_toss_time +\r\ndlm_config.ci_toss_secs * HZ)) {\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nlog_debug(ls, "remove_name toss_time %lu now %lu %s",\r\nr->res_toss_time, jiffies, name);\r\ncontinue;\r\n}\r\nif (!kref_put(&r->res_ref, kill_rsb)) {\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nlog_error(ls, "remove_name in use %s", name);\r\ncontinue;\r\n}\r\nrb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\r\nspin_lock(&ls->ls_remove_spin);\r\nls->ls_remove_len = len;\r\nmemcpy(ls->ls_remove_name, name, DLM_RESNAME_MAXLEN);\r\nspin_unlock(&ls->ls_remove_spin);\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nsend_remove(r);\r\nspin_lock(&ls->ls_remove_spin);\r\nls->ls_remove_len = 0;\r\nmemset(ls->ls_remove_name, 0, DLM_RESNAME_MAXLEN);\r\nspin_unlock(&ls->ls_remove_spin);\r\ndlm_free_rsb(r);\r\n}\r\n}\r\nvoid dlm_scan_rsbs(struct dlm_ls *ls)\r\n{\r\nint i;\r\nfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\r\nshrink_bucket(ls, i);\r\nif (dlm_locking_stopped(ls))\r\nbreak;\r\ncond_resched();\r\n}\r\n}\r\nstatic void add_timeout(struct dlm_lkb *lkb)\r\n{\r\nstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\r\nif (is_master_copy(lkb))\r\nreturn;\r\nif (test_bit(LSFL_TIMEWARN, &ls->ls_flags) &&\r\n!(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\r\nlkb->lkb_flags |= DLM_IFL_WATCH_TIMEWARN;\r\ngoto add_it;\r\n}\r\nif (lkb->lkb_exflags & DLM_LKF_TIMEOUT)\r\ngoto add_it;\r\nreturn;\r\nadd_it:\r\nDLM_ASSERT(list_empty(&lkb->lkb_time_list), dlm_print_lkb(lkb););\r\nmutex_lock(&ls->ls_timeout_mutex);\r\nhold_lkb(lkb);\r\nlist_add_tail(&lkb->lkb_time_list, &ls->ls_timeout);\r\nmutex_unlock(&ls->ls_timeout_mutex);\r\n}\r\nstatic void del_timeout(struct dlm_lkb *lkb)\r\n{\r\nstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\r\nmutex_lock(&ls->ls_timeout_mutex);\r\nif (!list_empty(&lkb->lkb_time_list)) {\r\nlist_del_init(&lkb->lkb_time_list);\r\nunhold_lkb(lkb);\r\n}\r\nmutex_unlock(&ls->ls_timeout_mutex);\r\n}\r\nvoid dlm_scan_timeout(struct dlm_ls *ls)\r\n{\r\nstruct dlm_rsb *r;\r\nstruct dlm_lkb *lkb;\r\nint do_cancel, do_warn;\r\ns64 wait_us;\r\nfor (;;) {\r\nif (dlm_locking_stopped(ls))\r\nbreak;\r\ndo_cancel = 0;\r\ndo_warn = 0;\r\nmutex_lock(&ls->ls_timeout_mutex);\r\nlist_for_each_entry(lkb, &ls->ls_timeout, lkb_time_list) {\r\nwait_us = ktime_to_us(ktime_sub(ktime_get(),\r\nlkb->lkb_timestamp));\r\nif ((lkb->lkb_exflags & DLM_LKF_TIMEOUT) &&\r\nwait_us >= (lkb->lkb_timeout_cs * 10000))\r\ndo_cancel = 1;\r\nif ((lkb->lkb_flags & DLM_IFL_WATCH_TIMEWARN) &&\r\nwait_us >= dlm_config.ci_timewarn_cs * 10000)\r\ndo_warn = 1;\r\nif (!do_cancel && !do_warn)\r\ncontinue;\r\nhold_lkb(lkb);\r\nbreak;\r\n}\r\nmutex_unlock(&ls->ls_timeout_mutex);\r\nif (!do_cancel && !do_warn)\r\nbreak;\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nif (do_warn) {\r\nlkb->lkb_flags &= ~DLM_IFL_WATCH_TIMEWARN;\r\nif (!(lkb->lkb_exflags & DLM_LKF_TIMEOUT))\r\ndel_timeout(lkb);\r\ndlm_timeout_warn(lkb);\r\n}\r\nif (do_cancel) {\r\nlog_debug(ls, "timeout cancel %x node %d %s",\r\nlkb->lkb_id, lkb->lkb_nodeid, r->res_name);\r\nlkb->lkb_flags &= ~DLM_IFL_WATCH_TIMEWARN;\r\nlkb->lkb_flags |= DLM_IFL_TIMEOUT_CANCEL;\r\ndel_timeout(lkb);\r\n_cancel_lock(r, lkb);\r\n}\r\nunlock_rsb(r);\r\nunhold_rsb(r);\r\ndlm_put_lkb(lkb);\r\n}\r\n}\r\nvoid dlm_adjust_timeouts(struct dlm_ls *ls)\r\n{\r\nstruct dlm_lkb *lkb;\r\nu64 adj_us = jiffies_to_usecs(jiffies - ls->ls_recover_begin);\r\nls->ls_recover_begin = 0;\r\nmutex_lock(&ls->ls_timeout_mutex);\r\nlist_for_each_entry(lkb, &ls->ls_timeout, lkb_time_list)\r\nlkb->lkb_timestamp = ktime_add_us(lkb->lkb_timestamp, adj_us);\r\nmutex_unlock(&ls->ls_timeout_mutex);\r\nif (!dlm_config.ci_waitwarn_us)\r\nreturn;\r\nmutex_lock(&ls->ls_waiters_mutex);\r\nlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\r\nif (ktime_to_us(lkb->lkb_wait_time))\r\nlkb->lkb_wait_time = ktime_get();\r\n}\r\nmutex_unlock(&ls->ls_waiters_mutex);\r\n}\r\nstatic void set_lvb_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nint b, len = r->res_ls->ls_lvblen;\r\nb = dlm_lvb_operations[lkb->lkb_grmode + 1][lkb->lkb_rqmode + 1];\r\nif (b == 1) {\r\nif (!lkb->lkb_lvbptr)\r\nreturn;\r\nif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\r\nreturn;\r\nif (!r->res_lvbptr)\r\nreturn;\r\nmemcpy(lkb->lkb_lvbptr, r->res_lvbptr, len);\r\nlkb->lkb_lvbseq = r->res_lvbseq;\r\n} else if (b == 0) {\r\nif (lkb->lkb_exflags & DLM_LKF_IVVALBLK) {\r\nrsb_set_flag(r, RSB_VALNOTVALID);\r\nreturn;\r\n}\r\nif (!lkb->lkb_lvbptr)\r\nreturn;\r\nif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\r\nreturn;\r\nif (!r->res_lvbptr)\r\nr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\r\nif (!r->res_lvbptr)\r\nreturn;\r\nmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, len);\r\nr->res_lvbseq++;\r\nlkb->lkb_lvbseq = r->res_lvbseq;\r\nrsb_clear_flag(r, RSB_VALNOTVALID);\r\n}\r\nif (rsb_flag(r, RSB_VALNOTVALID))\r\nlkb->lkb_sbflags |= DLM_SBF_VALNOTVALID;\r\n}\r\nstatic void set_lvb_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nif (lkb->lkb_grmode < DLM_LOCK_PW)\r\nreturn;\r\nif (lkb->lkb_exflags & DLM_LKF_IVVALBLK) {\r\nrsb_set_flag(r, RSB_VALNOTVALID);\r\nreturn;\r\n}\r\nif (!lkb->lkb_lvbptr)\r\nreturn;\r\nif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\r\nreturn;\r\nif (!r->res_lvbptr)\r\nr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\r\nif (!r->res_lvbptr)\r\nreturn;\r\nmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\r\nr->res_lvbseq++;\r\nrsb_clear_flag(r, RSB_VALNOTVALID);\r\n}\r\nstatic void set_lvb_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\r\nstruct dlm_message *ms)\r\n{\r\nint b;\r\nif (!lkb->lkb_lvbptr)\r\nreturn;\r\nif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\r\nreturn;\r\nb = dlm_lvb_operations[lkb->lkb_grmode + 1][lkb->lkb_rqmode + 1];\r\nif (b == 1) {\r\nint len = receive_extralen(ms);\r\nif (len > DLM_RESNAME_MAXLEN)\r\nlen = DLM_RESNAME_MAXLEN;\r\nmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\r\nlkb->lkb_lvbseq = ms->m_lvbseq;\r\n}\r\n}\r\nstatic void _remove_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\ndel_lkb(r, lkb);\r\nlkb->lkb_grmode = DLM_LOCK_IV;\r\nunhold_lkb(lkb);\r\n}\r\nstatic void remove_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nset_lvb_unlock(r, lkb);\r\n_remove_lock(r, lkb);\r\n}\r\nstatic void remove_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\n_remove_lock(r, lkb);\r\n}\r\nstatic int revert_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nint rv = 0;\r\nlkb->lkb_rqmode = DLM_LOCK_IV;\r\nswitch (lkb->lkb_status) {\r\ncase DLM_LKSTS_GRANTED:\r\nbreak;\r\ncase DLM_LKSTS_CONVERT:\r\nmove_lkb(r, lkb, DLM_LKSTS_GRANTED);\r\nrv = 1;\r\nbreak;\r\ncase DLM_LKSTS_WAITING:\r\ndel_lkb(r, lkb);\r\nlkb->lkb_grmode = DLM_LOCK_IV;\r\nunhold_lkb(lkb);\r\nrv = -1;\r\nbreak;\r\ndefault:\r\nlog_print("invalid status for revert %d", lkb->lkb_status);\r\n}\r\nreturn rv;\r\n}\r\nstatic int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nreturn revert_lock(r, lkb);\r\n}\r\nstatic void _grant_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nif (lkb->lkb_grmode != lkb->lkb_rqmode) {\r\nlkb->lkb_grmode = lkb->lkb_rqmode;\r\nif (lkb->lkb_status)\r\nmove_lkb(r, lkb, DLM_LKSTS_GRANTED);\r\nelse\r\nadd_lkb(r, lkb, DLM_LKSTS_GRANTED);\r\n}\r\nlkb->lkb_rqmode = DLM_LOCK_IV;\r\nlkb->lkb_highbast = 0;\r\n}\r\nstatic void grant_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nset_lvb_lock(r, lkb);\r\n_grant_lock(r, lkb);\r\n}\r\nstatic void grant_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb,\r\nstruct dlm_message *ms)\r\n{\r\nset_lvb_lock_pc(r, lkb, ms);\r\n_grant_lock(r, lkb);\r\n}\r\nstatic void grant_lock_pending(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\ngrant_lock(r, lkb);\r\nif (is_master_copy(lkb))\r\nsend_grant(r, lkb);\r\nelse\r\nqueue_cast(r, lkb, 0);\r\n}\r\nstatic void munge_demoted(struct dlm_lkb *lkb)\r\n{\r\nif (lkb->lkb_rqmode == DLM_LOCK_IV || lkb->lkb_grmode == DLM_LOCK_IV) {\r\nlog_print("munge_demoted %x invalid modes gr %d rq %d",\r\nlkb->lkb_id, lkb->lkb_grmode, lkb->lkb_rqmode);\r\nreturn;\r\n}\r\nlkb->lkb_grmode = DLM_LOCK_NL;\r\n}\r\nstatic void munge_altmode(struct dlm_lkb *lkb, struct dlm_message *ms)\r\n{\r\nif (ms->m_type != DLM_MSG_REQUEST_REPLY &&\r\nms->m_type != DLM_MSG_GRANT) {\r\nlog_print("munge_altmode %x invalid reply type %d",\r\nlkb->lkb_id, ms->m_type);\r\nreturn;\r\n}\r\nif (lkb->lkb_exflags & DLM_LKF_ALTPR)\r\nlkb->lkb_rqmode = DLM_LOCK_PR;\r\nelse if (lkb->lkb_exflags & DLM_LKF_ALTCW)\r\nlkb->lkb_rqmode = DLM_LOCK_CW;\r\nelse {\r\nlog_print("munge_altmode invalid exflags %x", lkb->lkb_exflags);\r\ndlm_print_lkb(lkb);\r\n}\r\n}\r\nstatic inline int first_in_list(struct dlm_lkb *lkb, struct list_head *head)\r\n{\r\nstruct dlm_lkb *first = list_entry(head->next, struct dlm_lkb,\r\nlkb_statequeue);\r\nif (lkb->lkb_id == first->lkb_id)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int queue_conflict(struct list_head *head, struct dlm_lkb *lkb)\r\n{\r\nstruct dlm_lkb *this;\r\nlist_for_each_entry(this, head, lkb_statequeue) {\r\nif (this == lkb)\r\ncontinue;\r\nif (!modes_compat(this, lkb))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int conversion_deadlock_detect(struct dlm_rsb *r, struct dlm_lkb *lkb2)\r\n{\r\nstruct dlm_lkb *lkb1;\r\nint lkb_is_ahead = 0;\r\nlist_for_each_entry(lkb1, &r->res_convertqueue, lkb_statequeue) {\r\nif (lkb1 == lkb2) {\r\nlkb_is_ahead = 1;\r\ncontinue;\r\n}\r\nif (!lkb_is_ahead) {\r\nif (!modes_compat(lkb2, lkb1))\r\nreturn 1;\r\n} else {\r\nif (!modes_compat(lkb2, lkb1) &&\r\n!modes_compat(lkb1, lkb2))\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int _can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\r\nint recover)\r\n{\r\nint8_t conv = (lkb->lkb_grmode != DLM_LOCK_IV);\r\nif (lkb->lkb_exflags & DLM_LKF_EXPEDITE)\r\nreturn 1;\r\nif (queue_conflict(&r->res_grantqueue, lkb))\r\nreturn 0;\r\nif (queue_conflict(&r->res_convertqueue, lkb))\r\nreturn 0;\r\nif (conv && recover)\r\nreturn 1;\r\nif (now && conv && !(lkb->lkb_exflags & DLM_LKF_QUECVT))\r\nreturn 1;\r\nif (now && conv && (lkb->lkb_exflags & DLM_LKF_QUECVT)) {\r\nif (list_empty(&r->res_convertqueue))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nif (lkb->lkb_exflags & DLM_LKF_NOORDER)\r\nreturn 1;\r\nif (!now && conv && first_in_list(lkb, &r->res_convertqueue))\r\nreturn 1;\r\nif (now && !conv && list_empty(&r->res_convertqueue) &&\r\nlist_empty(&r->res_waitqueue))\r\nreturn 1;\r\nif (!now && !conv && list_empty(&r->res_convertqueue) &&\r\nfirst_in_list(lkb, &r->res_waitqueue))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int can_be_granted(struct dlm_rsb *r, struct dlm_lkb *lkb, int now,\r\nint recover, int *err)\r\n{\r\nint rv;\r\nint8_t alt = 0, rqmode = lkb->lkb_rqmode;\r\nint8_t is_convert = (lkb->lkb_grmode != DLM_LOCK_IV);\r\nif (err)\r\n*err = 0;\r\nrv = _can_be_granted(r, lkb, now, recover);\r\nif (rv)\r\ngoto out;\r\nif (is_convert && can_be_queued(lkb) &&\r\nconversion_deadlock_detect(r, lkb)) {\r\nif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {\r\nlkb->lkb_grmode = DLM_LOCK_NL;\r\nlkb->lkb_sbflags |= DLM_SBF_DEMOTED;\r\n} else if (!(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {\r\nif (err)\r\n*err = -EDEADLK;\r\nelse {\r\nlog_print("can_be_granted deadlock %x now %d",\r\nlkb->lkb_id, now);\r\ndlm_dump_rsb(r);\r\n}\r\n}\r\ngoto out;\r\n}\r\nif (rqmode != DLM_LOCK_PR && (lkb->lkb_exflags & DLM_LKF_ALTPR))\r\nalt = DLM_LOCK_PR;\r\nelse if (rqmode != DLM_LOCK_CW && (lkb->lkb_exflags & DLM_LKF_ALTCW))\r\nalt = DLM_LOCK_CW;\r\nif (alt) {\r\nlkb->lkb_rqmode = alt;\r\nrv = _can_be_granted(r, lkb, now, 0);\r\nif (rv)\r\nlkb->lkb_sbflags |= DLM_SBF_ALTMODE;\r\nelse\r\nlkb->lkb_rqmode = rqmode;\r\n}\r\nout:\r\nreturn rv;\r\n}\r\nstatic int grant_pending_convert(struct dlm_rsb *r, int high, int *cw,\r\nunsigned int *count)\r\n{\r\nstruct dlm_lkb *lkb, *s;\r\nint recover = rsb_flag(r, RSB_RECOVER_GRANT);\r\nint hi, demoted, quit, grant_restart, demote_restart;\r\nint deadlk;\r\nquit = 0;\r\nrestart:\r\ngrant_restart = 0;\r\ndemote_restart = 0;\r\nhi = DLM_LOCK_IV;\r\nlist_for_each_entry_safe(lkb, s, &r->res_convertqueue, lkb_statequeue) {\r\ndemoted = is_demoted(lkb);\r\ndeadlk = 0;\r\nif (can_be_granted(r, lkb, 0, recover, &deadlk)) {\r\ngrant_lock_pending(r, lkb);\r\ngrant_restart = 1;\r\nif (count)\r\n(*count)++;\r\ncontinue;\r\n}\r\nif (!demoted && is_demoted(lkb)) {\r\nlog_print("WARN: pending demoted %x node %d %s",\r\nlkb->lkb_id, lkb->lkb_nodeid, r->res_name);\r\ndemote_restart = 1;\r\ncontinue;\r\n}\r\nif (deadlk) {\r\nlog_print("WARN: pending deadlock %x node %d %s",\r\nlkb->lkb_id, lkb->lkb_nodeid, r->res_name);\r\ndlm_dump_rsb(r);\r\ncontinue;\r\n}\r\nhi = max_t(int, lkb->lkb_rqmode, hi);\r\nif (cw && lkb->lkb_rqmode == DLM_LOCK_CW)\r\n*cw = 1;\r\n}\r\nif (grant_restart)\r\ngoto restart;\r\nif (demote_restart && !quit) {\r\nquit = 1;\r\ngoto restart;\r\n}\r\nreturn max_t(int, high, hi);\r\n}\r\nstatic int grant_pending_wait(struct dlm_rsb *r, int high, int *cw,\r\nunsigned int *count)\r\n{\r\nstruct dlm_lkb *lkb, *s;\r\nlist_for_each_entry_safe(lkb, s, &r->res_waitqueue, lkb_statequeue) {\r\nif (can_be_granted(r, lkb, 0, 0, NULL)) {\r\ngrant_lock_pending(r, lkb);\r\nif (count)\r\n(*count)++;\r\n} else {\r\nhigh = max_t(int, lkb->lkb_rqmode, high);\r\nif (lkb->lkb_rqmode == DLM_LOCK_CW)\r\n*cw = 1;\r\n}\r\n}\r\nreturn high;\r\n}\r\nstatic int lock_requires_bast(struct dlm_lkb *gr, int high, int cw)\r\n{\r\nif (gr->lkb_grmode == DLM_LOCK_PR && cw) {\r\nif (gr->lkb_highbast < DLM_LOCK_EX)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nif (gr->lkb_highbast < high &&\r\n!__dlm_compat_matrix[gr->lkb_grmode+1][high+1])\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void grant_pending_locks(struct dlm_rsb *r, unsigned int *count)\r\n{\r\nstruct dlm_lkb *lkb, *s;\r\nint high = DLM_LOCK_IV;\r\nint cw = 0;\r\nif (!is_master(r)) {\r\nlog_print("grant_pending_locks r nodeid %d", r->res_nodeid);\r\ndlm_dump_rsb(r);\r\nreturn;\r\n}\r\nhigh = grant_pending_convert(r, high, &cw, count);\r\nhigh = grant_pending_wait(r, high, &cw, count);\r\nif (high == DLM_LOCK_IV)\r\nreturn;\r\nlist_for_each_entry_safe(lkb, s, &r->res_grantqueue, lkb_statequeue) {\r\nif (lkb->lkb_bastfn && lock_requires_bast(lkb, high, cw)) {\r\nif (cw && high == DLM_LOCK_PR &&\r\nlkb->lkb_grmode == DLM_LOCK_PR)\r\nqueue_bast(r, lkb, DLM_LOCK_CW);\r\nelse\r\nqueue_bast(r, lkb, high);\r\nlkb->lkb_highbast = high;\r\n}\r\n}\r\n}\r\nstatic int modes_require_bast(struct dlm_lkb *gr, struct dlm_lkb *rq)\r\n{\r\nif ((gr->lkb_grmode == DLM_LOCK_PR && rq->lkb_rqmode == DLM_LOCK_CW) ||\r\n(gr->lkb_grmode == DLM_LOCK_CW && rq->lkb_rqmode == DLM_LOCK_PR)) {\r\nif (gr->lkb_highbast < DLM_LOCK_EX)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nif (gr->lkb_highbast < rq->lkb_rqmode && !modes_compat(gr, rq))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void send_bast_queue(struct dlm_rsb *r, struct list_head *head,\r\nstruct dlm_lkb *lkb)\r\n{\r\nstruct dlm_lkb *gr;\r\nlist_for_each_entry(gr, head, lkb_statequeue) {\r\nif (gr == lkb)\r\ncontinue;\r\nif (gr->lkb_bastfn && modes_require_bast(gr, lkb)) {\r\nqueue_bast(r, gr, lkb->lkb_rqmode);\r\ngr->lkb_highbast = lkb->lkb_rqmode;\r\n}\r\n}\r\n}\r\nstatic void send_blocking_asts(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nsend_bast_queue(r, &r->res_grantqueue, lkb);\r\n}\r\nstatic void send_blocking_asts_all(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nsend_bast_queue(r, &r->res_grantqueue, lkb);\r\nsend_bast_queue(r, &r->res_convertqueue, lkb);\r\n}\r\nstatic int set_master(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nint our_nodeid = dlm_our_nodeid();\r\nif (rsb_flag(r, RSB_MASTER_UNCERTAIN)) {\r\nrsb_clear_flag(r, RSB_MASTER_UNCERTAIN);\r\nr->res_first_lkid = lkb->lkb_id;\r\nlkb->lkb_nodeid = r->res_nodeid;\r\nreturn 0;\r\n}\r\nif (r->res_first_lkid && r->res_first_lkid != lkb->lkb_id) {\r\nlist_add_tail(&lkb->lkb_rsb_lookup, &r->res_lookup);\r\nreturn 1;\r\n}\r\nif (r->res_master_nodeid == our_nodeid) {\r\nlkb->lkb_nodeid = 0;\r\nreturn 0;\r\n}\r\nif (r->res_master_nodeid) {\r\nlkb->lkb_nodeid = r->res_master_nodeid;\r\nreturn 0;\r\n}\r\nif (dlm_dir_nodeid(r) == our_nodeid) {\r\nlog_debug(r->res_ls, "set_master %x self master %d dir %d %s",\r\nlkb->lkb_id, r->res_master_nodeid, r->res_dir_nodeid,\r\nr->res_name);\r\nr->res_master_nodeid = our_nodeid;\r\nr->res_nodeid = 0;\r\nlkb->lkb_nodeid = 0;\r\nreturn 0;\r\n}\r\nwait_pending_remove(r);\r\nr->res_first_lkid = lkb->lkb_id;\r\nsend_lookup(r, lkb);\r\nreturn 1;\r\n}\r\nstatic void process_lookup_list(struct dlm_rsb *r)\r\n{\r\nstruct dlm_lkb *lkb, *safe;\r\nlist_for_each_entry_safe(lkb, safe, &r->res_lookup, lkb_rsb_lookup) {\r\nlist_del_init(&lkb->lkb_rsb_lookup);\r\n_request_lock(r, lkb);\r\nschedule();\r\n}\r\n}\r\nstatic void confirm_master(struct dlm_rsb *r, int error)\r\n{\r\nstruct dlm_lkb *lkb;\r\nif (!r->res_first_lkid)\r\nreturn;\r\nswitch (error) {\r\ncase 0:\r\ncase -EINPROGRESS:\r\nr->res_first_lkid = 0;\r\nprocess_lookup_list(r);\r\nbreak;\r\ncase -EAGAIN:\r\ncase -EBADR:\r\ncase -ENOTBLK:\r\nr->res_first_lkid = 0;\r\nif (!list_empty(&r->res_lookup)) {\r\nlkb = list_entry(r->res_lookup.next, struct dlm_lkb,\r\nlkb_rsb_lookup);\r\nlist_del_init(&lkb->lkb_rsb_lookup);\r\nr->res_first_lkid = lkb->lkb_id;\r\n_request_lock(r, lkb);\r\n}\r\nbreak;\r\ndefault:\r\nlog_error(r->res_ls, "confirm_master unknown error %d", error);\r\n}\r\n}\r\nstatic int set_lock_args(int mode, struct dlm_lksb *lksb, uint32_t flags,\r\nint namelen, unsigned long timeout_cs,\r\nvoid (*ast) (void *astparam),\r\nvoid *astparam,\r\nvoid (*bast) (void *astparam, int mode),\r\nstruct dlm_args *args)\r\n{\r\nint rv = -EINVAL;\r\nif (mode < 0 || mode > DLM_LOCK_EX)\r\ngoto out;\r\nif (!(flags & DLM_LKF_CONVERT) && (namelen > DLM_RESNAME_MAXLEN))\r\ngoto out;\r\nif (flags & DLM_LKF_CANCEL)\r\ngoto out;\r\nif (flags & DLM_LKF_QUECVT && !(flags & DLM_LKF_CONVERT))\r\ngoto out;\r\nif (flags & DLM_LKF_CONVDEADLK && !(flags & DLM_LKF_CONVERT))\r\ngoto out;\r\nif (flags & DLM_LKF_CONVDEADLK && flags & DLM_LKF_NOQUEUE)\r\ngoto out;\r\nif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_CONVERT)\r\ngoto out;\r\nif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_QUECVT)\r\ngoto out;\r\nif (flags & DLM_LKF_EXPEDITE && flags & DLM_LKF_NOQUEUE)\r\ngoto out;\r\nif (flags & DLM_LKF_EXPEDITE && mode != DLM_LOCK_NL)\r\ngoto out;\r\nif (!ast || !lksb)\r\ngoto out;\r\nif (flags & DLM_LKF_VALBLK && !lksb->sb_lvbptr)\r\ngoto out;\r\nif (flags & DLM_LKF_CONVERT && !lksb->sb_lkid)\r\ngoto out;\r\nargs->flags = flags;\r\nargs->astfn = ast;\r\nargs->astparam = astparam;\r\nargs->bastfn = bast;\r\nargs->timeout = timeout_cs;\r\nargs->mode = mode;\r\nargs->lksb = lksb;\r\nrv = 0;\r\nout:\r\nreturn rv;\r\n}\r\nstatic int set_unlock_args(uint32_t flags, void *astarg, struct dlm_args *args)\r\n{\r\nif (flags & ~(DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK |\r\nDLM_LKF_FORCEUNLOCK))\r\nreturn -EINVAL;\r\nif (flags & DLM_LKF_CANCEL && flags & DLM_LKF_FORCEUNLOCK)\r\nreturn -EINVAL;\r\nargs->flags = flags;\r\nargs->astparam = astarg;\r\nreturn 0;\r\n}\r\nstatic int validate_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\r\nstruct dlm_args *args)\r\n{\r\nint rv = -EINVAL;\r\nif (args->flags & DLM_LKF_CONVERT) {\r\nif (lkb->lkb_flags & DLM_IFL_MSTCPY)\r\ngoto out;\r\nif (args->flags & DLM_LKF_QUECVT &&\r\n!__quecvt_compat_matrix[lkb->lkb_grmode+1][args->mode+1])\r\ngoto out;\r\nrv = -EBUSY;\r\nif (lkb->lkb_status != DLM_LKSTS_GRANTED)\r\ngoto out;\r\nif (lkb->lkb_wait_type)\r\ngoto out;\r\nif (is_overlap(lkb))\r\ngoto out;\r\n}\r\nlkb->lkb_exflags = args->flags;\r\nlkb->lkb_sbflags = 0;\r\nlkb->lkb_astfn = args->astfn;\r\nlkb->lkb_astparam = args->astparam;\r\nlkb->lkb_bastfn = args->bastfn;\r\nlkb->lkb_rqmode = args->mode;\r\nlkb->lkb_lksb = args->lksb;\r\nlkb->lkb_lvbptr = args->lksb->sb_lvbptr;\r\nlkb->lkb_ownpid = (int) current->pid;\r\nlkb->lkb_timeout_cs = args->timeout;\r\nrv = 0;\r\nout:\r\nif (rv)\r\nlog_debug(ls, "validate_lock_args %d %x %x %x %d %d %s",\r\nrv, lkb->lkb_id, lkb->lkb_flags, args->flags,\r\nlkb->lkb_status, lkb->lkb_wait_type,\r\nlkb->lkb_resource->res_name);\r\nreturn rv;\r\n}\r\nstatic int validate_unlock_args(struct dlm_lkb *lkb, struct dlm_args *args)\r\n{\r\nstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\r\nint rv = -EINVAL;\r\nif (lkb->lkb_flags & DLM_IFL_MSTCPY) {\r\nlog_error(ls, "unlock on MSTCPY %x", lkb->lkb_id);\r\ndlm_print_lkb(lkb);\r\ngoto out;\r\n}\r\nif (lkb->lkb_flags & DLM_IFL_ENDOFLIFE) {\r\nlog_debug(ls, "unlock on ENDOFLIFE %x", lkb->lkb_id);\r\nrv = -ENOENT;\r\ngoto out;\r\n}\r\nif (!list_empty(&lkb->lkb_rsb_lookup)) {\r\nif (args->flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)) {\r\nlog_debug(ls, "unlock on rsb_lookup %x", lkb->lkb_id);\r\nlist_del_init(&lkb->lkb_rsb_lookup);\r\nqueue_cast(lkb->lkb_resource, lkb,\r\nargs->flags & DLM_LKF_CANCEL ?\r\n-DLM_ECANCEL : -DLM_EUNLOCK);\r\nunhold_lkb(lkb);\r\n}\r\nrv = -EBUSY;\r\ngoto out;\r\n}\r\nif (args->flags & DLM_LKF_CANCEL) {\r\nif (lkb->lkb_exflags & DLM_LKF_CANCEL)\r\ngoto out;\r\nif (is_overlap(lkb))\r\ngoto out;\r\ndel_timeout(lkb);\r\nif (lkb->lkb_flags & DLM_IFL_RESEND) {\r\nlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\r\nrv = -EBUSY;\r\ngoto out;\r\n}\r\nif (lkb->lkb_status == DLM_LKSTS_GRANTED &&\r\n!lkb->lkb_wait_type) {\r\nrv = -EBUSY;\r\ngoto out;\r\n}\r\nswitch (lkb->lkb_wait_type) {\r\ncase DLM_MSG_LOOKUP:\r\ncase DLM_MSG_REQUEST:\r\nlkb->lkb_flags |= DLM_IFL_OVERLAP_CANCEL;\r\nrv = -EBUSY;\r\ngoto out;\r\ncase DLM_MSG_UNLOCK:\r\ncase DLM_MSG_CANCEL:\r\ngoto out;\r\n}\r\ngoto out_ok;\r\n}\r\nif (args->flags & DLM_LKF_FORCEUNLOCK) {\r\nif (lkb->lkb_exflags & DLM_LKF_FORCEUNLOCK)\r\ngoto out;\r\nif (is_overlap_unlock(lkb))\r\ngoto out;\r\ndel_timeout(lkb);\r\nif (lkb->lkb_flags & DLM_IFL_RESEND) {\r\nlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\r\nrv = -EBUSY;\r\ngoto out;\r\n}\r\nswitch (lkb->lkb_wait_type) {\r\ncase DLM_MSG_LOOKUP:\r\ncase DLM_MSG_REQUEST:\r\nlkb->lkb_flags |= DLM_IFL_OVERLAP_UNLOCK;\r\nrv = -EBUSY;\r\ngoto out;\r\ncase DLM_MSG_UNLOCK:\r\ngoto out;\r\n}\r\ngoto out_ok;\r\n}\r\nrv = -EBUSY;\r\nif (lkb->lkb_wait_type || lkb->lkb_wait_count)\r\ngoto out;\r\nout_ok:\r\nlkb->lkb_exflags |= args->flags;\r\nlkb->lkb_sbflags = 0;\r\nlkb->lkb_astparam = args->astparam;\r\nrv = 0;\r\nout:\r\nif (rv)\r\nlog_debug(ls, "validate_unlock_args %d %x %x %x %x %d %s", rv,\r\nlkb->lkb_id, lkb->lkb_flags, lkb->lkb_exflags,\r\nargs->flags, lkb->lkb_wait_type,\r\nlkb->lkb_resource->res_name);\r\nreturn rv;\r\n}\r\nstatic int do_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nint error = 0;\r\nif (can_be_granted(r, lkb, 1, 0, NULL)) {\r\ngrant_lock(r, lkb);\r\nqueue_cast(r, lkb, 0);\r\ngoto out;\r\n}\r\nif (can_be_queued(lkb)) {\r\nerror = -EINPROGRESS;\r\nadd_lkb(r, lkb, DLM_LKSTS_WAITING);\r\nadd_timeout(lkb);\r\ngoto out;\r\n}\r\nerror = -EAGAIN;\r\nqueue_cast(r, lkb, -EAGAIN);\r\nout:\r\nreturn error;\r\n}\r\nstatic void do_request_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\r\nint error)\r\n{\r\nswitch (error) {\r\ncase -EAGAIN:\r\nif (force_blocking_asts(lkb))\r\nsend_blocking_asts_all(r, lkb);\r\nbreak;\r\ncase -EINPROGRESS:\r\nsend_blocking_asts(r, lkb);\r\nbreak;\r\n}\r\n}\r\nstatic int do_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nint error = 0;\r\nint deadlk = 0;\r\nif (can_be_granted(r, lkb, 1, 0, &deadlk)) {\r\ngrant_lock(r, lkb);\r\nqueue_cast(r, lkb, 0);\r\ngoto out;\r\n}\r\nif (deadlk) {\r\nrevert_lock(r, lkb);\r\nqueue_cast(r, lkb, -EDEADLK);\r\nerror = -EDEADLK;\r\ngoto out;\r\n}\r\nif (is_demoted(lkb)) {\r\ngrant_pending_convert(r, DLM_LOCK_IV, NULL, NULL);\r\nif (_can_be_granted(r, lkb, 1, 0)) {\r\ngrant_lock(r, lkb);\r\nqueue_cast(r, lkb, 0);\r\ngoto out;\r\n}\r\n}\r\nif (can_be_queued(lkb)) {\r\nerror = -EINPROGRESS;\r\ndel_lkb(r, lkb);\r\nadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\r\nadd_timeout(lkb);\r\ngoto out;\r\n}\r\nerror = -EAGAIN;\r\nqueue_cast(r, lkb, -EAGAIN);\r\nout:\r\nreturn error;\r\n}\r\nstatic void do_convert_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\r\nint error)\r\n{\r\nswitch (error) {\r\ncase 0:\r\ngrant_pending_locks(r, NULL);\r\nbreak;\r\ncase -EAGAIN:\r\nif (force_blocking_asts(lkb))\r\nsend_blocking_asts_all(r, lkb);\r\nbreak;\r\ncase -EINPROGRESS:\r\nsend_blocking_asts(r, lkb);\r\nbreak;\r\n}\r\n}\r\nstatic int do_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nremove_lock(r, lkb);\r\nqueue_cast(r, lkb, -DLM_EUNLOCK);\r\nreturn -DLM_EUNLOCK;\r\n}\r\nstatic void do_unlock_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\r\nint error)\r\n{\r\ngrant_pending_locks(r, NULL);\r\n}\r\nstatic int do_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nint error;\r\nerror = revert_lock(r, lkb);\r\nif (error) {\r\nqueue_cast(r, lkb, -DLM_ECANCEL);\r\nreturn -DLM_ECANCEL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void do_cancel_effects(struct dlm_rsb *r, struct dlm_lkb *lkb,\r\nint error)\r\n{\r\nif (error)\r\ngrant_pending_locks(r, NULL);\r\n}\r\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nint error;\r\nerror = set_master(r, lkb);\r\nif (error < 0)\r\ngoto out;\r\nif (error) {\r\nerror = 0;\r\ngoto out;\r\n}\r\nif (is_remote(r)) {\r\nerror = send_request(r, lkb);\r\n} else {\r\nerror = do_request(r, lkb);\r\ndo_request_effects(r, lkb, error);\r\n}\r\nout:\r\nreturn error;\r\n}\r\nstatic int _convert_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nint error;\r\nif (is_remote(r)) {\r\nerror = send_convert(r, lkb);\r\n} else {\r\nerror = do_convert(r, lkb);\r\ndo_convert_effects(r, lkb, error);\r\n}\r\nreturn error;\r\n}\r\nstatic int _unlock_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nint error;\r\nif (is_remote(r)) {\r\nerror = send_unlock(r, lkb);\r\n} else {\r\nerror = do_unlock(r, lkb);\r\ndo_unlock_effects(r, lkb, error);\r\n}\r\nreturn error;\r\n}\r\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nint error;\r\nif (is_remote(r)) {\r\nerror = send_cancel(r, lkb);\r\n} else {\r\nerror = do_cancel(r, lkb);\r\ndo_cancel_effects(r, lkb, error);\r\n}\r\nreturn error;\r\n}\r\nstatic int request_lock(struct dlm_ls *ls, struct dlm_lkb *lkb, char *name,\r\nint len, struct dlm_args *args)\r\n{\r\nstruct dlm_rsb *r;\r\nint error;\r\nerror = validate_lock_args(ls, lkb, args);\r\nif (error)\r\nreturn error;\r\nerror = find_rsb(ls, name, len, 0, R_REQUEST, &r);\r\nif (error)\r\nreturn error;\r\nlock_rsb(r);\r\nattach_lkb(r, lkb);\r\nlkb->lkb_lksb->sb_lkid = lkb->lkb_id;\r\nerror = _request_lock(r, lkb);\r\nunlock_rsb(r);\r\nput_rsb(r);\r\nreturn error;\r\n}\r\nstatic int convert_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\r\nstruct dlm_args *args)\r\n{\r\nstruct dlm_rsb *r;\r\nint error;\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = validate_lock_args(ls, lkb, args);\r\nif (error)\r\ngoto out;\r\nerror = _convert_lock(r, lkb);\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\nreturn error;\r\n}\r\nstatic int unlock_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\r\nstruct dlm_args *args)\r\n{\r\nstruct dlm_rsb *r;\r\nint error;\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = validate_unlock_args(lkb, args);\r\nif (error)\r\ngoto out;\r\nerror = _unlock_lock(r, lkb);\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\nreturn error;\r\n}\r\nstatic int cancel_lock(struct dlm_ls *ls, struct dlm_lkb *lkb,\r\nstruct dlm_args *args)\r\n{\r\nstruct dlm_rsb *r;\r\nint error;\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = validate_unlock_args(lkb, args);\r\nif (error)\r\ngoto out;\r\nerror = _cancel_lock(r, lkb);\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\nreturn error;\r\n}\r\nint dlm_lock(dlm_lockspace_t *lockspace,\r\nint mode,\r\nstruct dlm_lksb *lksb,\r\nuint32_t flags,\r\nvoid *name,\r\nunsigned int namelen,\r\nuint32_t parent_lkid,\r\nvoid (*ast) (void *astarg),\r\nvoid *astarg,\r\nvoid (*bast) (void *astarg, int mode))\r\n{\r\nstruct dlm_ls *ls;\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_args args;\r\nint error, convert = flags & DLM_LKF_CONVERT;\r\nls = dlm_find_lockspace_local(lockspace);\r\nif (!ls)\r\nreturn -EINVAL;\r\ndlm_lock_recovery(ls);\r\nif (convert)\r\nerror = find_lkb(ls, lksb->sb_lkid, &lkb);\r\nelse\r\nerror = create_lkb(ls, &lkb);\r\nif (error)\r\ngoto out;\r\nerror = set_lock_args(mode, lksb, flags, namelen, 0, ast,\r\nastarg, bast, &args);\r\nif (error)\r\ngoto out_put;\r\nif (convert)\r\nerror = convert_lock(ls, lkb, &args);\r\nelse\r\nerror = request_lock(ls, lkb, name, namelen, &args);\r\nif (error == -EINPROGRESS)\r\nerror = 0;\r\nout_put:\r\nif (convert || error)\r\n__put_lkb(ls, lkb);\r\nif (error == -EAGAIN || error == -EDEADLK)\r\nerror = 0;\r\nout:\r\ndlm_unlock_recovery(ls);\r\ndlm_put_lockspace(ls);\r\nreturn error;\r\n}\r\nint dlm_unlock(dlm_lockspace_t *lockspace,\r\nuint32_t lkid,\r\nuint32_t flags,\r\nstruct dlm_lksb *lksb,\r\nvoid *astarg)\r\n{\r\nstruct dlm_ls *ls;\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_args args;\r\nint error;\r\nls = dlm_find_lockspace_local(lockspace);\r\nif (!ls)\r\nreturn -EINVAL;\r\ndlm_lock_recovery(ls);\r\nerror = find_lkb(ls, lkid, &lkb);\r\nif (error)\r\ngoto out;\r\nerror = set_unlock_args(flags, astarg, &args);\r\nif (error)\r\ngoto out_put;\r\nif (flags & DLM_LKF_CANCEL)\r\nerror = cancel_lock(ls, lkb, &args);\r\nelse\r\nerror = unlock_lock(ls, lkb, &args);\r\nif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\r\nerror = 0;\r\nif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\r\nerror = 0;\r\nout_put:\r\ndlm_put_lkb(lkb);\r\nout:\r\ndlm_unlock_recovery(ls);\r\ndlm_put_lockspace(ls);\r\nreturn error;\r\n}\r\nstatic int _create_message(struct dlm_ls *ls, int mb_len,\r\nint to_nodeid, int mstype,\r\nstruct dlm_message **ms_ret,\r\nstruct dlm_mhandle **mh_ret)\r\n{\r\nstruct dlm_message *ms;\r\nstruct dlm_mhandle *mh;\r\nchar *mb;\r\nmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\r\nif (!mh)\r\nreturn -ENOBUFS;\r\nmemset(mb, 0, mb_len);\r\nms = (struct dlm_message *) mb;\r\nms->m_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\r\nms->m_header.h_lockspace = ls->ls_global_id;\r\nms->m_header.h_nodeid = dlm_our_nodeid();\r\nms->m_header.h_length = mb_len;\r\nms->m_header.h_cmd = DLM_MSG;\r\nms->m_type = mstype;\r\n*mh_ret = mh;\r\n*ms_ret = ms;\r\nreturn 0;\r\n}\r\nstatic int create_message(struct dlm_rsb *r, struct dlm_lkb *lkb,\r\nint to_nodeid, int mstype,\r\nstruct dlm_message **ms_ret,\r\nstruct dlm_mhandle **mh_ret)\r\n{\r\nint mb_len = sizeof(struct dlm_message);\r\nswitch (mstype) {\r\ncase DLM_MSG_REQUEST:\r\ncase DLM_MSG_LOOKUP:\r\ncase DLM_MSG_REMOVE:\r\nmb_len += r->res_length;\r\nbreak;\r\ncase DLM_MSG_CONVERT:\r\ncase DLM_MSG_UNLOCK:\r\ncase DLM_MSG_REQUEST_REPLY:\r\ncase DLM_MSG_CONVERT_REPLY:\r\ncase DLM_MSG_GRANT:\r\nif (lkb && lkb->lkb_lvbptr)\r\nmb_len += r->res_ls->ls_lvblen;\r\nbreak;\r\n}\r\nreturn _create_message(r->res_ls, mb_len, to_nodeid, mstype,\r\nms_ret, mh_ret);\r\n}\r\nstatic int send_message(struct dlm_mhandle *mh, struct dlm_message *ms)\r\n{\r\ndlm_message_out(ms);\r\ndlm_lowcomms_commit_buffer(mh);\r\nreturn 0;\r\n}\r\nstatic void send_args(struct dlm_rsb *r, struct dlm_lkb *lkb,\r\nstruct dlm_message *ms)\r\n{\r\nms->m_nodeid = lkb->lkb_nodeid;\r\nms->m_pid = lkb->lkb_ownpid;\r\nms->m_lkid = lkb->lkb_id;\r\nms->m_remid = lkb->lkb_remid;\r\nms->m_exflags = lkb->lkb_exflags;\r\nms->m_sbflags = lkb->lkb_sbflags;\r\nms->m_flags = lkb->lkb_flags;\r\nms->m_lvbseq = lkb->lkb_lvbseq;\r\nms->m_status = lkb->lkb_status;\r\nms->m_grmode = lkb->lkb_grmode;\r\nms->m_rqmode = lkb->lkb_rqmode;\r\nms->m_hash = r->res_hash;\r\nif (lkb->lkb_bastfn)\r\nms->m_asts |= DLM_CB_BAST;\r\nif (lkb->lkb_astfn)\r\nms->m_asts |= DLM_CB_CAST;\r\nswitch (ms->m_type) {\r\ncase DLM_MSG_REQUEST:\r\ncase DLM_MSG_LOOKUP:\r\nmemcpy(ms->m_extra, r->res_name, r->res_length);\r\nbreak;\r\ncase DLM_MSG_CONVERT:\r\ncase DLM_MSG_UNLOCK:\r\ncase DLM_MSG_REQUEST_REPLY:\r\ncase DLM_MSG_CONVERT_REPLY:\r\ncase DLM_MSG_GRANT:\r\nif (!lkb->lkb_lvbptr)\r\nbreak;\r\nmemcpy(ms->m_extra, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\r\nbreak;\r\n}\r\n}\r\nstatic int send_common(struct dlm_rsb *r, struct dlm_lkb *lkb, int mstype)\r\n{\r\nstruct dlm_message *ms;\r\nstruct dlm_mhandle *mh;\r\nint to_nodeid, error;\r\nto_nodeid = r->res_nodeid;\r\nerror = add_to_waiters(lkb, mstype, to_nodeid);\r\nif (error)\r\nreturn error;\r\nerror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\r\nif (error)\r\ngoto fail;\r\nsend_args(r, lkb, ms);\r\nerror = send_message(mh, ms);\r\nif (error)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nremove_from_waiters(lkb, msg_reply_type(mstype));\r\nreturn error;\r\n}\r\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nreturn send_common(r, lkb, DLM_MSG_REQUEST);\r\n}\r\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nint error;\r\nerror = send_common(r, lkb, DLM_MSG_CONVERT);\r\nif (!error && down_conversion(lkb)) {\r\nremove_from_waiters(lkb, DLM_MSG_CONVERT_REPLY);\r\nr->res_ls->ls_stub_ms.m_flags = DLM_IFL_STUB_MS;\r\nr->res_ls->ls_stub_ms.m_type = DLM_MSG_CONVERT_REPLY;\r\nr->res_ls->ls_stub_ms.m_result = 0;\r\n__receive_convert_reply(r, lkb, &r->res_ls->ls_stub_ms);\r\n}\r\nreturn error;\r\n}\r\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nreturn send_common(r, lkb, DLM_MSG_UNLOCK);\r\n}\r\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nreturn send_common(r, lkb, DLM_MSG_CANCEL);\r\n}\r\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nstruct dlm_message *ms;\r\nstruct dlm_mhandle *mh;\r\nint to_nodeid, error;\r\nto_nodeid = lkb->lkb_nodeid;\r\nerror = create_message(r, lkb, to_nodeid, DLM_MSG_GRANT, &ms, &mh);\r\nif (error)\r\ngoto out;\r\nsend_args(r, lkb, ms);\r\nms->m_result = 0;\r\nerror = send_message(mh, ms);\r\nout:\r\nreturn error;\r\n}\r\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode)\r\n{\r\nstruct dlm_message *ms;\r\nstruct dlm_mhandle *mh;\r\nint to_nodeid, error;\r\nto_nodeid = lkb->lkb_nodeid;\r\nerror = create_message(r, NULL, to_nodeid, DLM_MSG_BAST, &ms, &mh);\r\nif (error)\r\ngoto out;\r\nsend_args(r, lkb, ms);\r\nms->m_bastmode = mode;\r\nerror = send_message(mh, ms);\r\nout:\r\nreturn error;\r\n}\r\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nstruct dlm_message *ms;\r\nstruct dlm_mhandle *mh;\r\nint to_nodeid, error;\r\nto_nodeid = dlm_dir_nodeid(r);\r\nerror = add_to_waiters(lkb, DLM_MSG_LOOKUP, to_nodeid);\r\nif (error)\r\nreturn error;\r\nerror = create_message(r, NULL, to_nodeid, DLM_MSG_LOOKUP, &ms, &mh);\r\nif (error)\r\ngoto fail;\r\nsend_args(r, lkb, ms);\r\nerror = send_message(mh, ms);\r\nif (error)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nremove_from_waiters(lkb, DLM_MSG_LOOKUP_REPLY);\r\nreturn error;\r\n}\r\nstatic int send_remove(struct dlm_rsb *r)\r\n{\r\nstruct dlm_message *ms;\r\nstruct dlm_mhandle *mh;\r\nint to_nodeid, error;\r\nto_nodeid = dlm_dir_nodeid(r);\r\nerror = create_message(r, NULL, to_nodeid, DLM_MSG_REMOVE, &ms, &mh);\r\nif (error)\r\ngoto out;\r\nmemcpy(ms->m_extra, r->res_name, r->res_length);\r\nms->m_hash = r->res_hash;\r\nerror = send_message(mh, ms);\r\nout:\r\nreturn error;\r\n}\r\nstatic int send_common_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\r\nint mstype, int rv)\r\n{\r\nstruct dlm_message *ms;\r\nstruct dlm_mhandle *mh;\r\nint to_nodeid, error;\r\nto_nodeid = lkb->lkb_nodeid;\r\nerror = create_message(r, lkb, to_nodeid, mstype, &ms, &mh);\r\nif (error)\r\ngoto out;\r\nsend_args(r, lkb, ms);\r\nms->m_result = rv;\r\nerror = send_message(mh, ms);\r\nout:\r\nreturn error;\r\n}\r\nstatic int send_request_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\r\n{\r\nreturn send_common_reply(r, lkb, DLM_MSG_REQUEST_REPLY, rv);\r\n}\r\nstatic int send_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\r\n{\r\nreturn send_common_reply(r, lkb, DLM_MSG_CONVERT_REPLY, rv);\r\n}\r\nstatic int send_unlock_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\r\n{\r\nreturn send_common_reply(r, lkb, DLM_MSG_UNLOCK_REPLY, rv);\r\n}\r\nstatic int send_cancel_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)\r\n{\r\nreturn send_common_reply(r, lkb, DLM_MSG_CANCEL_REPLY, rv);\r\n}\r\nstatic int send_lookup_reply(struct dlm_ls *ls, struct dlm_message *ms_in,\r\nint ret_nodeid, int rv)\r\n{\r\nstruct dlm_rsb *r = &ls->ls_stub_rsb;\r\nstruct dlm_message *ms;\r\nstruct dlm_mhandle *mh;\r\nint error, nodeid = ms_in->m_header.h_nodeid;\r\nerror = create_message(r, NULL, nodeid, DLM_MSG_LOOKUP_REPLY, &ms, &mh);\r\nif (error)\r\ngoto out;\r\nms->m_lkid = ms_in->m_lkid;\r\nms->m_result = rv;\r\nms->m_nodeid = ret_nodeid;\r\nerror = send_message(mh, ms);\r\nout:\r\nreturn error;\r\n}\r\nstatic void receive_flags(struct dlm_lkb *lkb, struct dlm_message *ms)\r\n{\r\nlkb->lkb_exflags = ms->m_exflags;\r\nlkb->lkb_sbflags = ms->m_sbflags;\r\nlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\r\n(ms->m_flags & 0x0000FFFF);\r\n}\r\nstatic void receive_flags_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\r\n{\r\nif (ms->m_flags == DLM_IFL_STUB_MS)\r\nreturn;\r\nlkb->lkb_sbflags = ms->m_sbflags;\r\nlkb->lkb_flags = (lkb->lkb_flags & 0xFFFF0000) |\r\n(ms->m_flags & 0x0000FFFF);\r\n}\r\nstatic int receive_extralen(struct dlm_message *ms)\r\n{\r\nreturn (ms->m_header.h_length - sizeof(struct dlm_message));\r\n}\r\nstatic int receive_lvb(struct dlm_ls *ls, struct dlm_lkb *lkb,\r\nstruct dlm_message *ms)\r\n{\r\nint len;\r\nif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\r\nif (!lkb->lkb_lvbptr)\r\nlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\r\nif (!lkb->lkb_lvbptr)\r\nreturn -ENOMEM;\r\nlen = receive_extralen(ms);\r\nif (len > DLM_RESNAME_MAXLEN)\r\nlen = DLM_RESNAME_MAXLEN;\r\nmemcpy(lkb->lkb_lvbptr, ms->m_extra, len);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fake_bastfn(void *astparam, int mode)\r\n{\r\nlog_print("fake_bastfn should not be called");\r\n}\r\nstatic void fake_astfn(void *astparam)\r\n{\r\nlog_print("fake_astfn should not be called");\r\n}\r\nstatic int receive_request_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\r\nstruct dlm_message *ms)\r\n{\r\nlkb->lkb_nodeid = ms->m_header.h_nodeid;\r\nlkb->lkb_ownpid = ms->m_pid;\r\nlkb->lkb_remid = ms->m_lkid;\r\nlkb->lkb_grmode = DLM_LOCK_IV;\r\nlkb->lkb_rqmode = ms->m_rqmode;\r\nlkb->lkb_bastfn = (ms->m_asts & DLM_CB_BAST) ? &fake_bastfn : NULL;\r\nlkb->lkb_astfn = (ms->m_asts & DLM_CB_CAST) ? &fake_astfn : NULL;\r\nif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\r\nlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\r\nif (!lkb->lkb_lvbptr)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int receive_convert_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\r\nstruct dlm_message *ms)\r\n{\r\nif (lkb->lkb_status != DLM_LKSTS_GRANTED)\r\nreturn -EBUSY;\r\nif (receive_lvb(ls, lkb, ms))\r\nreturn -ENOMEM;\r\nlkb->lkb_rqmode = ms->m_rqmode;\r\nlkb->lkb_lvbseq = ms->m_lvbseq;\r\nreturn 0;\r\n}\r\nstatic int receive_unlock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\r\nstruct dlm_message *ms)\r\n{\r\nif (receive_lvb(ls, lkb, ms))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void setup_stub_lkb(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nstruct dlm_lkb *lkb = &ls->ls_stub_lkb;\r\nlkb->lkb_nodeid = ms->m_header.h_nodeid;\r\nlkb->lkb_remid = ms->m_lkid;\r\n}\r\nstatic int validate_message(struct dlm_lkb *lkb, struct dlm_message *ms)\r\n{\r\nint from = ms->m_header.h_nodeid;\r\nint error = 0;\r\nswitch (ms->m_type) {\r\ncase DLM_MSG_CONVERT:\r\ncase DLM_MSG_UNLOCK:\r\ncase DLM_MSG_CANCEL:\r\nif (!is_master_copy(lkb) || lkb->lkb_nodeid != from)\r\nerror = -EINVAL;\r\nbreak;\r\ncase DLM_MSG_CONVERT_REPLY:\r\ncase DLM_MSG_UNLOCK_REPLY:\r\ncase DLM_MSG_CANCEL_REPLY:\r\ncase DLM_MSG_GRANT:\r\ncase DLM_MSG_BAST:\r\nif (!is_process_copy(lkb) || lkb->lkb_nodeid != from)\r\nerror = -EINVAL;\r\nbreak;\r\ncase DLM_MSG_REQUEST_REPLY:\r\nif (!is_process_copy(lkb))\r\nerror = -EINVAL;\r\nelse if (lkb->lkb_nodeid != -1 && lkb->lkb_nodeid != from)\r\nerror = -EINVAL;\r\nbreak;\r\ndefault:\r\nerror = -EINVAL;\r\n}\r\nif (error)\r\nlog_error(lkb->lkb_resource->res_ls,\r\n"ignore invalid message %d from %d %x %x %x %d",\r\nms->m_type, from, lkb->lkb_id, lkb->lkb_remid,\r\nlkb->lkb_flags, lkb->lkb_nodeid);\r\nreturn error;\r\n}\r\nstatic void send_repeat_remove(struct dlm_ls *ls, char *ms_name, int len)\r\n{\r\nchar name[DLM_RESNAME_MAXLEN + 1];\r\nstruct dlm_message *ms;\r\nstruct dlm_mhandle *mh;\r\nstruct dlm_rsb *r;\r\nuint32_t hash, b;\r\nint rv, dir_nodeid;\r\nmemset(name, 0, sizeof(name));\r\nmemcpy(name, ms_name, len);\r\nhash = jhash(name, len, 0);\r\nb = hash & (ls->ls_rsbtbl_size - 1);\r\ndir_nodeid = dlm_hash2nodeid(ls, hash);\r\nlog_error(ls, "send_repeat_remove dir %d %s", dir_nodeid, name);\r\nspin_lock(&ls->ls_rsbtbl[b].lock);\r\nrv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\r\nif (!rv) {\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nlog_error(ls, "repeat_remove on keep %s", name);\r\nreturn;\r\n}\r\nrv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\r\nif (!rv) {\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nlog_error(ls, "repeat_remove on toss %s", name);\r\nreturn;\r\n}\r\nspin_lock(&ls->ls_remove_spin);\r\nls->ls_remove_len = len;\r\nmemcpy(ls->ls_remove_name, name, DLM_RESNAME_MAXLEN);\r\nspin_unlock(&ls->ls_remove_spin);\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nrv = _create_message(ls, sizeof(struct dlm_message) + len,\r\ndir_nodeid, DLM_MSG_REMOVE, &ms, &mh);\r\nif (rv)\r\nreturn;\r\nmemcpy(ms->m_extra, name, len);\r\nms->m_hash = hash;\r\nsend_message(mh, ms);\r\nspin_lock(&ls->ls_remove_spin);\r\nls->ls_remove_len = 0;\r\nmemset(ls->ls_remove_name, 0, DLM_RESNAME_MAXLEN);\r\nspin_unlock(&ls->ls_remove_spin);\r\n}\r\nstatic int receive_request(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_rsb *r;\r\nint from_nodeid;\r\nint error, namelen = 0;\r\nfrom_nodeid = ms->m_header.h_nodeid;\r\nerror = create_lkb(ls, &lkb);\r\nif (error)\r\ngoto fail;\r\nreceive_flags(lkb, ms);\r\nlkb->lkb_flags |= DLM_IFL_MSTCPY;\r\nerror = receive_request_args(ls, lkb, ms);\r\nif (error) {\r\n__put_lkb(ls, lkb);\r\ngoto fail;\r\n}\r\nnamelen = receive_extralen(ms);\r\nerror = find_rsb(ls, ms->m_extra, namelen, from_nodeid,\r\nR_RECEIVE_REQUEST, &r);\r\nif (error) {\r\n__put_lkb(ls, lkb);\r\ngoto fail;\r\n}\r\nlock_rsb(r);\r\nif (r->res_master_nodeid != dlm_our_nodeid()) {\r\nerror = validate_master_nodeid(ls, r, from_nodeid);\r\nif (error) {\r\nunlock_rsb(r);\r\nput_rsb(r);\r\n__put_lkb(ls, lkb);\r\ngoto fail;\r\n}\r\n}\r\nattach_lkb(r, lkb);\r\nerror = do_request(r, lkb);\r\nsend_request_reply(r, lkb, error);\r\ndo_request_effects(r, lkb, error);\r\nunlock_rsb(r);\r\nput_rsb(r);\r\nif (error == -EINPROGRESS)\r\nerror = 0;\r\nif (error)\r\ndlm_put_lkb(lkb);\r\nreturn 0;\r\nfail:\r\nif (error != -ENOTBLK) {\r\nlog_limit(ls, "receive_request %x from %d %d",\r\nms->m_lkid, from_nodeid, error);\r\n}\r\nif (namelen && error == -EBADR) {\r\nsend_repeat_remove(ls, ms->m_extra, namelen);\r\nmsleep(1000);\r\n}\r\nsetup_stub_lkb(ls, ms);\r\nsend_request_reply(&ls->ls_stub_rsb, &ls->ls_stub_lkb, error);\r\nreturn error;\r\n}\r\nstatic int receive_convert(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_rsb *r;\r\nint error, reply = 1;\r\nerror = find_lkb(ls, ms->m_remid, &lkb);\r\nif (error)\r\ngoto fail;\r\nif (lkb->lkb_remid != ms->m_lkid) {\r\nlog_error(ls, "receive_convert %x remid %x recover_seq %llu "\r\n"remote %d %x", lkb->lkb_id, lkb->lkb_remid,\r\n(unsigned long long)lkb->lkb_recover_seq,\r\nms->m_header.h_nodeid, ms->m_lkid);\r\nerror = -ENOENT;\r\ngoto fail;\r\n}\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = validate_message(lkb, ms);\r\nif (error)\r\ngoto out;\r\nreceive_flags(lkb, ms);\r\nerror = receive_convert_args(ls, lkb, ms);\r\nif (error) {\r\nsend_convert_reply(r, lkb, error);\r\ngoto out;\r\n}\r\nreply = !down_conversion(lkb);\r\nerror = do_convert(r, lkb);\r\nif (reply)\r\nsend_convert_reply(r, lkb, error);\r\ndo_convert_effects(r, lkb, error);\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\ndlm_put_lkb(lkb);\r\nreturn 0;\r\nfail:\r\nsetup_stub_lkb(ls, ms);\r\nsend_convert_reply(&ls->ls_stub_rsb, &ls->ls_stub_lkb, error);\r\nreturn error;\r\n}\r\nstatic int receive_unlock(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_rsb *r;\r\nint error;\r\nerror = find_lkb(ls, ms->m_remid, &lkb);\r\nif (error)\r\ngoto fail;\r\nif (lkb->lkb_remid != ms->m_lkid) {\r\nlog_error(ls, "receive_unlock %x remid %x remote %d %x",\r\nlkb->lkb_id, lkb->lkb_remid,\r\nms->m_header.h_nodeid, ms->m_lkid);\r\nerror = -ENOENT;\r\ngoto fail;\r\n}\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = validate_message(lkb, ms);\r\nif (error)\r\ngoto out;\r\nreceive_flags(lkb, ms);\r\nerror = receive_unlock_args(ls, lkb, ms);\r\nif (error) {\r\nsend_unlock_reply(r, lkb, error);\r\ngoto out;\r\n}\r\nerror = do_unlock(r, lkb);\r\nsend_unlock_reply(r, lkb, error);\r\ndo_unlock_effects(r, lkb, error);\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\ndlm_put_lkb(lkb);\r\nreturn 0;\r\nfail:\r\nsetup_stub_lkb(ls, ms);\r\nsend_unlock_reply(&ls->ls_stub_rsb, &ls->ls_stub_lkb, error);\r\nreturn error;\r\n}\r\nstatic int receive_cancel(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_rsb *r;\r\nint error;\r\nerror = find_lkb(ls, ms->m_remid, &lkb);\r\nif (error)\r\ngoto fail;\r\nreceive_flags(lkb, ms);\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = validate_message(lkb, ms);\r\nif (error)\r\ngoto out;\r\nerror = do_cancel(r, lkb);\r\nsend_cancel_reply(r, lkb, error);\r\ndo_cancel_effects(r, lkb, error);\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\ndlm_put_lkb(lkb);\r\nreturn 0;\r\nfail:\r\nsetup_stub_lkb(ls, ms);\r\nsend_cancel_reply(&ls->ls_stub_rsb, &ls->ls_stub_lkb, error);\r\nreturn error;\r\n}\r\nstatic int receive_grant(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_rsb *r;\r\nint error;\r\nerror = find_lkb(ls, ms->m_remid, &lkb);\r\nif (error)\r\nreturn error;\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = validate_message(lkb, ms);\r\nif (error)\r\ngoto out;\r\nreceive_flags_reply(lkb, ms);\r\nif (is_altmode(lkb))\r\nmunge_altmode(lkb, ms);\r\ngrant_lock_pc(r, lkb, ms);\r\nqueue_cast(r, lkb, 0);\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\ndlm_put_lkb(lkb);\r\nreturn 0;\r\n}\r\nstatic int receive_bast(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_rsb *r;\r\nint error;\r\nerror = find_lkb(ls, ms->m_remid, &lkb);\r\nif (error)\r\nreturn error;\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = validate_message(lkb, ms);\r\nif (error)\r\ngoto out;\r\nqueue_bast(r, lkb, ms->m_bastmode);\r\nlkb->lkb_highbast = ms->m_bastmode;\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\ndlm_put_lkb(lkb);\r\nreturn 0;\r\n}\r\nstatic void receive_lookup(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nint len, error, ret_nodeid, from_nodeid, our_nodeid;\r\nfrom_nodeid = ms->m_header.h_nodeid;\r\nour_nodeid = dlm_our_nodeid();\r\nlen = receive_extralen(ms);\r\nerror = dlm_master_lookup(ls, from_nodeid, ms->m_extra, len, 0,\r\n&ret_nodeid, NULL);\r\nif (!error && ret_nodeid == our_nodeid) {\r\nreceive_request(ls, ms);\r\nreturn;\r\n}\r\nsend_lookup_reply(ls, ms, ret_nodeid, error);\r\n}\r\nstatic void receive_remove(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nchar name[DLM_RESNAME_MAXLEN+1];\r\nstruct dlm_rsb *r;\r\nuint32_t hash, b;\r\nint rv, len, dir_nodeid, from_nodeid;\r\nfrom_nodeid = ms->m_header.h_nodeid;\r\nlen = receive_extralen(ms);\r\nif (len > DLM_RESNAME_MAXLEN) {\r\nlog_error(ls, "receive_remove from %d bad len %d",\r\nfrom_nodeid, len);\r\nreturn;\r\n}\r\ndir_nodeid = dlm_hash2nodeid(ls, ms->m_hash);\r\nif (dir_nodeid != dlm_our_nodeid()) {\r\nlog_error(ls, "receive_remove from %d bad nodeid %d",\r\nfrom_nodeid, dir_nodeid);\r\nreturn;\r\n}\r\nmemset(name, 0, sizeof(name));\r\nmemcpy(name, ms->m_extra, len);\r\nhash = jhash(name, len, 0);\r\nb = hash & (ls->ls_rsbtbl_size - 1);\r\nspin_lock(&ls->ls_rsbtbl[b].lock);\r\nrv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\r\nif (rv) {\r\nrv = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\r\nif (rv) {\r\nlog_error(ls, "receive_remove from %d not found %s",\r\nfrom_nodeid, name);\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nreturn;\r\n}\r\nif (r->res_master_nodeid != from_nodeid) {\r\nlog_error(ls, "receive_remove keep from %d master %d",\r\nfrom_nodeid, r->res_master_nodeid);\r\ndlm_print_rsb(r);\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nreturn;\r\n}\r\nlog_debug(ls, "receive_remove from %d master %d first %x %s",\r\nfrom_nodeid, r->res_master_nodeid, r->res_first_lkid,\r\nname);\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nreturn;\r\n}\r\nif (r->res_master_nodeid != from_nodeid) {\r\nlog_error(ls, "receive_remove toss from %d master %d",\r\nfrom_nodeid, r->res_master_nodeid);\r\ndlm_print_rsb(r);\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\nreturn;\r\n}\r\nif (kref_put(&r->res_ref, kill_rsb)) {\r\nrb_erase(&r->res_hashnode, &ls->ls_rsbtbl[b].toss);\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\ndlm_free_rsb(r);\r\n} else {\r\nlog_error(ls, "receive_remove from %d rsb ref error",\r\nfrom_nodeid);\r\ndlm_print_rsb(r);\r\nspin_unlock(&ls->ls_rsbtbl[b].lock);\r\n}\r\n}\r\nstatic void receive_purge(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\ndo_purge(ls, ms->m_nodeid, ms->m_pid);\r\n}\r\nstatic int receive_request_reply(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_rsb *r;\r\nint error, mstype, result;\r\nint from_nodeid = ms->m_header.h_nodeid;\r\nerror = find_lkb(ls, ms->m_remid, &lkb);\r\nif (error)\r\nreturn error;\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = validate_message(lkb, ms);\r\nif (error)\r\ngoto out;\r\nmstype = lkb->lkb_wait_type;\r\nerror = remove_from_waiters(lkb, DLM_MSG_REQUEST_REPLY);\r\nif (error) {\r\nlog_error(ls, "receive_request_reply %x remote %d %x result %d",\r\nlkb->lkb_id, from_nodeid, ms->m_lkid, ms->m_result);\r\ndlm_dump_rsb(r);\r\ngoto out;\r\n}\r\nif (mstype == DLM_MSG_LOOKUP) {\r\nr->res_master_nodeid = from_nodeid;\r\nr->res_nodeid = from_nodeid;\r\nlkb->lkb_nodeid = from_nodeid;\r\n}\r\nresult = ms->m_result;\r\nswitch (result) {\r\ncase -EAGAIN:\r\nqueue_cast(r, lkb, -EAGAIN);\r\nconfirm_master(r, -EAGAIN);\r\nunhold_lkb(lkb);\r\nbreak;\r\ncase -EINPROGRESS:\r\ncase 0:\r\nreceive_flags_reply(lkb, ms);\r\nlkb->lkb_remid = ms->m_lkid;\r\nif (is_altmode(lkb))\r\nmunge_altmode(lkb, ms);\r\nif (result) {\r\nadd_lkb(r, lkb, DLM_LKSTS_WAITING);\r\nadd_timeout(lkb);\r\n} else {\r\ngrant_lock_pc(r, lkb, ms);\r\nqueue_cast(r, lkb, 0);\r\n}\r\nconfirm_master(r, result);\r\nbreak;\r\ncase -EBADR:\r\ncase -ENOTBLK:\r\nlog_limit(ls, "receive_request_reply %x from %d %d "\r\n"master %d dir %d first %x %s", lkb->lkb_id,\r\nfrom_nodeid, result, r->res_master_nodeid,\r\nr->res_dir_nodeid, r->res_first_lkid, r->res_name);\r\nif (r->res_dir_nodeid != dlm_our_nodeid() &&\r\nr->res_master_nodeid != dlm_our_nodeid()) {\r\nr->res_master_nodeid = 0;\r\nr->res_nodeid = -1;\r\nlkb->lkb_nodeid = -1;\r\n}\r\nif (is_overlap(lkb)) {\r\nqueue_cast_overlap(r, lkb);\r\nconfirm_master(r, result);\r\nunhold_lkb(lkb);\r\n} else {\r\n_request_lock(r, lkb);\r\nif (r->res_master_nodeid == dlm_our_nodeid())\r\nconfirm_master(r, 0);\r\n}\r\nbreak;\r\ndefault:\r\nlog_error(ls, "receive_request_reply %x error %d",\r\nlkb->lkb_id, result);\r\n}\r\nif (is_overlap_unlock(lkb) && (result == 0 || result == -EINPROGRESS)) {\r\nlog_debug(ls, "receive_request_reply %x result %d unlock",\r\nlkb->lkb_id, result);\r\nlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\r\nlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\r\nsend_unlock(r, lkb);\r\n} else if (is_overlap_cancel(lkb) && (result == -EINPROGRESS)) {\r\nlog_debug(ls, "receive_request_reply %x cancel", lkb->lkb_id);\r\nlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\r\nlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\r\nsend_cancel(r, lkb);\r\n} else {\r\nlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\r\nlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\r\n}\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\ndlm_put_lkb(lkb);\r\nreturn 0;\r\n}\r\nstatic void __receive_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb,\r\nstruct dlm_message *ms)\r\n{\r\nswitch (ms->m_result) {\r\ncase -EAGAIN:\r\nqueue_cast(r, lkb, -EAGAIN);\r\nbreak;\r\ncase -EDEADLK:\r\nreceive_flags_reply(lkb, ms);\r\nrevert_lock_pc(r, lkb);\r\nqueue_cast(r, lkb, -EDEADLK);\r\nbreak;\r\ncase -EINPROGRESS:\r\nreceive_flags_reply(lkb, ms);\r\nif (is_demoted(lkb))\r\nmunge_demoted(lkb);\r\ndel_lkb(r, lkb);\r\nadd_lkb(r, lkb, DLM_LKSTS_CONVERT);\r\nadd_timeout(lkb);\r\nbreak;\r\ncase 0:\r\nreceive_flags_reply(lkb, ms);\r\nif (is_demoted(lkb))\r\nmunge_demoted(lkb);\r\ngrant_lock_pc(r, lkb, ms);\r\nqueue_cast(r, lkb, 0);\r\nbreak;\r\ndefault:\r\nlog_error(r->res_ls, "receive_convert_reply %x remote %d %x %d",\r\nlkb->lkb_id, ms->m_header.h_nodeid, ms->m_lkid,\r\nms->m_result);\r\ndlm_print_rsb(r);\r\ndlm_print_lkb(lkb);\r\n}\r\n}\r\nstatic void _receive_convert_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\r\n{\r\nstruct dlm_rsb *r = lkb->lkb_resource;\r\nint error;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = validate_message(lkb, ms);\r\nif (error)\r\ngoto out;\r\nerror = remove_from_waiters_ms(lkb, ms);\r\nif (error)\r\ngoto out;\r\n__receive_convert_reply(r, lkb, ms);\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\n}\r\nstatic int receive_convert_reply(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nstruct dlm_lkb *lkb;\r\nint error;\r\nerror = find_lkb(ls, ms->m_remid, &lkb);\r\nif (error)\r\nreturn error;\r\n_receive_convert_reply(lkb, ms);\r\ndlm_put_lkb(lkb);\r\nreturn 0;\r\n}\r\nstatic void _receive_unlock_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\r\n{\r\nstruct dlm_rsb *r = lkb->lkb_resource;\r\nint error;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = validate_message(lkb, ms);\r\nif (error)\r\ngoto out;\r\nerror = remove_from_waiters_ms(lkb, ms);\r\nif (error)\r\ngoto out;\r\nswitch (ms->m_result) {\r\ncase -DLM_EUNLOCK:\r\nreceive_flags_reply(lkb, ms);\r\nremove_lock_pc(r, lkb);\r\nqueue_cast(r, lkb, -DLM_EUNLOCK);\r\nbreak;\r\ncase -ENOENT:\r\nbreak;\r\ndefault:\r\nlog_error(r->res_ls, "receive_unlock_reply %x error %d",\r\nlkb->lkb_id, ms->m_result);\r\n}\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\n}\r\nstatic int receive_unlock_reply(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nstruct dlm_lkb *lkb;\r\nint error;\r\nerror = find_lkb(ls, ms->m_remid, &lkb);\r\nif (error)\r\nreturn error;\r\n_receive_unlock_reply(lkb, ms);\r\ndlm_put_lkb(lkb);\r\nreturn 0;\r\n}\r\nstatic void _receive_cancel_reply(struct dlm_lkb *lkb, struct dlm_message *ms)\r\n{\r\nstruct dlm_rsb *r = lkb->lkb_resource;\r\nint error;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = validate_message(lkb, ms);\r\nif (error)\r\ngoto out;\r\nerror = remove_from_waiters_ms(lkb, ms);\r\nif (error)\r\ngoto out;\r\nswitch (ms->m_result) {\r\ncase -DLM_ECANCEL:\r\nreceive_flags_reply(lkb, ms);\r\nrevert_lock_pc(r, lkb);\r\nqueue_cast(r, lkb, -DLM_ECANCEL);\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nlog_error(r->res_ls, "receive_cancel_reply %x error %d",\r\nlkb->lkb_id, ms->m_result);\r\n}\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\n}\r\nstatic int receive_cancel_reply(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nstruct dlm_lkb *lkb;\r\nint error;\r\nerror = find_lkb(ls, ms->m_remid, &lkb);\r\nif (error)\r\nreturn error;\r\n_receive_cancel_reply(lkb, ms);\r\ndlm_put_lkb(lkb);\r\nreturn 0;\r\n}\r\nstatic void receive_lookup_reply(struct dlm_ls *ls, struct dlm_message *ms)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_rsb *r;\r\nint error, ret_nodeid;\r\nint do_lookup_list = 0;\r\nerror = find_lkb(ls, ms->m_lkid, &lkb);\r\nif (error) {\r\nlog_error(ls, "receive_lookup_reply no lkid %x", ms->m_lkid);\r\nreturn;\r\n}\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = remove_from_waiters(lkb, DLM_MSG_LOOKUP_REPLY);\r\nif (error)\r\ngoto out;\r\nret_nodeid = ms->m_nodeid;\r\nif (r->res_master_nodeid && (r->res_master_nodeid != ret_nodeid)) {\r\nlog_error(ls, "receive_lookup_reply %x from %d ret %d "\r\n"master %d dir %d our %d first %x %s",\r\nlkb->lkb_id, ms->m_header.h_nodeid, ret_nodeid,\r\nr->res_master_nodeid, r->res_dir_nodeid,\r\ndlm_our_nodeid(), r->res_first_lkid, r->res_name);\r\n}\r\nif (ret_nodeid == dlm_our_nodeid()) {\r\nr->res_master_nodeid = ret_nodeid;\r\nr->res_nodeid = 0;\r\ndo_lookup_list = 1;\r\nr->res_first_lkid = 0;\r\n} else if (ret_nodeid == -1) {\r\nlog_error(ls, "receive_lookup_reply %x from %d bad ret_nodeid",\r\nlkb->lkb_id, ms->m_header.h_nodeid);\r\nr->res_master_nodeid = 0;\r\nr->res_nodeid = -1;\r\nlkb->lkb_nodeid = -1;\r\n} else {\r\nr->res_master_nodeid = ret_nodeid;\r\nr->res_nodeid = ret_nodeid;\r\n}\r\nif (is_overlap(lkb)) {\r\nlog_debug(ls, "receive_lookup_reply %x unlock %x",\r\nlkb->lkb_id, lkb->lkb_flags);\r\nqueue_cast_overlap(r, lkb);\r\nunhold_lkb(lkb);\r\ngoto out_list;\r\n}\r\n_request_lock(r, lkb);\r\nout_list:\r\nif (do_lookup_list)\r\nprocess_lookup_list(r);\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\ndlm_put_lkb(lkb);\r\n}\r\nstatic void _receive_message(struct dlm_ls *ls, struct dlm_message *ms,\r\nuint32_t saved_seq)\r\n{\r\nint error = 0, noent = 0;\r\nif (!dlm_is_member(ls, ms->m_header.h_nodeid)) {\r\nlog_limit(ls, "receive %d from non-member %d %x %x %d",\r\nms->m_type, ms->m_header.h_nodeid, ms->m_lkid,\r\nms->m_remid, ms->m_result);\r\nreturn;\r\n}\r\nswitch (ms->m_type) {\r\ncase DLM_MSG_REQUEST:\r\nerror = receive_request(ls, ms);\r\nbreak;\r\ncase DLM_MSG_CONVERT:\r\nerror = receive_convert(ls, ms);\r\nbreak;\r\ncase DLM_MSG_UNLOCK:\r\nerror = receive_unlock(ls, ms);\r\nbreak;\r\ncase DLM_MSG_CANCEL:\r\nnoent = 1;\r\nerror = receive_cancel(ls, ms);\r\nbreak;\r\ncase DLM_MSG_REQUEST_REPLY:\r\nerror = receive_request_reply(ls, ms);\r\nbreak;\r\ncase DLM_MSG_CONVERT_REPLY:\r\nerror = receive_convert_reply(ls, ms);\r\nbreak;\r\ncase DLM_MSG_UNLOCK_REPLY:\r\nerror = receive_unlock_reply(ls, ms);\r\nbreak;\r\ncase DLM_MSG_CANCEL_REPLY:\r\nerror = receive_cancel_reply(ls, ms);\r\nbreak;\r\ncase DLM_MSG_GRANT:\r\nnoent = 1;\r\nerror = receive_grant(ls, ms);\r\nbreak;\r\ncase DLM_MSG_BAST:\r\nnoent = 1;\r\nerror = receive_bast(ls, ms);\r\nbreak;\r\ncase DLM_MSG_LOOKUP:\r\nreceive_lookup(ls, ms);\r\nbreak;\r\ncase DLM_MSG_REMOVE:\r\nreceive_remove(ls, ms);\r\nbreak;\r\ncase DLM_MSG_LOOKUP_REPLY:\r\nreceive_lookup_reply(ls, ms);\r\nbreak;\r\ncase DLM_MSG_PURGE:\r\nreceive_purge(ls, ms);\r\nbreak;\r\ndefault:\r\nlog_error(ls, "unknown message type %d", ms->m_type);\r\n}\r\nif (error == -ENOENT && noent) {\r\nlog_debug(ls, "receive %d no %x remote %d %x saved_seq %u",\r\nms->m_type, ms->m_remid, ms->m_header.h_nodeid,\r\nms->m_lkid, saved_seq);\r\n} else if (error == -ENOENT) {\r\nlog_error(ls, "receive %d no %x remote %d %x saved_seq %u",\r\nms->m_type, ms->m_remid, ms->m_header.h_nodeid,\r\nms->m_lkid, saved_seq);\r\nif (ms->m_type == DLM_MSG_CONVERT)\r\ndlm_dump_rsb_hash(ls, ms->m_hash);\r\n}\r\nif (error == -EINVAL) {\r\nlog_error(ls, "receive %d inval from %d lkid %x remid %x "\r\n"saved_seq %u",\r\nms->m_type, ms->m_header.h_nodeid,\r\nms->m_lkid, ms->m_remid, saved_seq);\r\n}\r\n}\r\nstatic void dlm_receive_message(struct dlm_ls *ls, struct dlm_message *ms,\r\nint nodeid)\r\n{\r\nif (dlm_locking_stopped(ls)) {\r\nif (!ls->ls_generation) {\r\nlog_limit(ls, "receive %d from %d ignore old gen",\r\nms->m_type, nodeid);\r\nreturn;\r\n}\r\ndlm_add_requestqueue(ls, nodeid, ms);\r\n} else {\r\ndlm_wait_requestqueue(ls);\r\n_receive_message(ls, ms, 0);\r\n}\r\n}\r\nvoid dlm_receive_message_saved(struct dlm_ls *ls, struct dlm_message *ms,\r\nuint32_t saved_seq)\r\n{\r\n_receive_message(ls, ms, saved_seq);\r\n}\r\nvoid dlm_receive_buffer(union dlm_packet *p, int nodeid)\r\n{\r\nstruct dlm_header *hd = &p->header;\r\nstruct dlm_ls *ls;\r\nint type = 0;\r\nswitch (hd->h_cmd) {\r\ncase DLM_MSG:\r\ndlm_message_in(&p->message);\r\ntype = p->message.m_type;\r\nbreak;\r\ncase DLM_RCOM:\r\ndlm_rcom_in(&p->rcom);\r\ntype = p->rcom.rc_type;\r\nbreak;\r\ndefault:\r\nlog_print("invalid h_cmd %d from %u", hd->h_cmd, nodeid);\r\nreturn;\r\n}\r\nif (hd->h_nodeid != nodeid) {\r\nlog_print("invalid h_nodeid %d from %d lockspace %x",\r\nhd->h_nodeid, nodeid, hd->h_lockspace);\r\nreturn;\r\n}\r\nls = dlm_find_lockspace_global(hd->h_lockspace);\r\nif (!ls) {\r\nif (dlm_config.ci_log_debug) {\r\nprintk_ratelimited(KERN_DEBUG "dlm: invalid lockspace "\r\n"%u from %d cmd %d type %d\n",\r\nhd->h_lockspace, nodeid, hd->h_cmd, type);\r\n}\r\nif (hd->h_cmd == DLM_RCOM && type == DLM_RCOM_STATUS)\r\ndlm_send_ls_not_ready(nodeid, &p->rcom);\r\nreturn;\r\n}\r\ndown_read(&ls->ls_recv_active);\r\nif (hd->h_cmd == DLM_MSG)\r\ndlm_receive_message(ls, &p->message, nodeid);\r\nelse\r\ndlm_receive_rcom(ls, &p->rcom, nodeid);\r\nup_read(&ls->ls_recv_active);\r\ndlm_put_lockspace(ls);\r\n}\r\nstatic void recover_convert_waiter(struct dlm_ls *ls, struct dlm_lkb *lkb,\r\nstruct dlm_message *ms_stub)\r\n{\r\nif (middle_conversion(lkb)) {\r\nhold_lkb(lkb);\r\nmemset(ms_stub, 0, sizeof(struct dlm_message));\r\nms_stub->m_flags = DLM_IFL_STUB_MS;\r\nms_stub->m_type = DLM_MSG_CONVERT_REPLY;\r\nms_stub->m_result = -EINPROGRESS;\r\nms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\r\n_receive_convert_reply(lkb, ms_stub);\r\nlkb->lkb_grmode = DLM_LOCK_IV;\r\nrsb_set_flag(lkb->lkb_resource, RSB_RECOVER_CONVERT);\r\nunhold_lkb(lkb);\r\n} else if (lkb->lkb_rqmode >= lkb->lkb_grmode) {\r\nlkb->lkb_flags |= DLM_IFL_RESEND;\r\n}\r\n}\r\nstatic int waiter_needs_recovery(struct dlm_ls *ls, struct dlm_lkb *lkb,\r\nint dir_nodeid)\r\n{\r\nif (dlm_no_directory(ls))\r\nreturn 1;\r\nif (dlm_is_removed(ls, lkb->lkb_wait_nodeid))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid dlm_recover_waiters_pre(struct dlm_ls *ls)\r\n{\r\nstruct dlm_lkb *lkb, *safe;\r\nstruct dlm_message *ms_stub;\r\nint wait_type, stub_unlock_result, stub_cancel_result;\r\nint dir_nodeid;\r\nms_stub = kmalloc(sizeof(struct dlm_message), GFP_KERNEL);\r\nif (!ms_stub) {\r\nlog_error(ls, "dlm_recover_waiters_pre no mem");\r\nreturn;\r\n}\r\nmutex_lock(&ls->ls_waiters_mutex);\r\nlist_for_each_entry_safe(lkb, safe, &ls->ls_waiters, lkb_wait_reply) {\r\ndir_nodeid = dlm_dir_nodeid(lkb->lkb_resource);\r\nif (lkb->lkb_wait_type != DLM_MSG_UNLOCK) {\r\nlog_debug(ls, "waiter %x remote %x msg %d r_nodeid %d "\r\n"lkb_nodeid %d wait_nodeid %d dir_nodeid %d",\r\nlkb->lkb_id,\r\nlkb->lkb_remid,\r\nlkb->lkb_wait_type,\r\nlkb->lkb_resource->res_nodeid,\r\nlkb->lkb_nodeid,\r\nlkb->lkb_wait_nodeid,\r\ndir_nodeid);\r\n}\r\nif (lkb->lkb_wait_type == DLM_MSG_LOOKUP) {\r\nlkb->lkb_flags |= DLM_IFL_RESEND;\r\ncontinue;\r\n}\r\nif (!waiter_needs_recovery(ls, lkb, dir_nodeid))\r\ncontinue;\r\nwait_type = lkb->lkb_wait_type;\r\nstub_unlock_result = -DLM_EUNLOCK;\r\nstub_cancel_result = -DLM_ECANCEL;\r\nif (!wait_type) {\r\nif (is_overlap_cancel(lkb)) {\r\nwait_type = DLM_MSG_CANCEL;\r\nif (lkb->lkb_grmode == DLM_LOCK_IV)\r\nstub_cancel_result = 0;\r\n}\r\nif (is_overlap_unlock(lkb)) {\r\nwait_type = DLM_MSG_UNLOCK;\r\nif (lkb->lkb_grmode == DLM_LOCK_IV)\r\nstub_unlock_result = -ENOENT;\r\n}\r\nlog_debug(ls, "rwpre overlap %x %x %d %d %d",\r\nlkb->lkb_id, lkb->lkb_flags, wait_type,\r\nstub_cancel_result, stub_unlock_result);\r\n}\r\nswitch (wait_type) {\r\ncase DLM_MSG_REQUEST:\r\nlkb->lkb_flags |= DLM_IFL_RESEND;\r\nbreak;\r\ncase DLM_MSG_CONVERT:\r\nrecover_convert_waiter(ls, lkb, ms_stub);\r\nbreak;\r\ncase DLM_MSG_UNLOCK:\r\nhold_lkb(lkb);\r\nmemset(ms_stub, 0, sizeof(struct dlm_message));\r\nms_stub->m_flags = DLM_IFL_STUB_MS;\r\nms_stub->m_type = DLM_MSG_UNLOCK_REPLY;\r\nms_stub->m_result = stub_unlock_result;\r\nms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\r\n_receive_unlock_reply(lkb, ms_stub);\r\ndlm_put_lkb(lkb);\r\nbreak;\r\ncase DLM_MSG_CANCEL:\r\nhold_lkb(lkb);\r\nmemset(ms_stub, 0, sizeof(struct dlm_message));\r\nms_stub->m_flags = DLM_IFL_STUB_MS;\r\nms_stub->m_type = DLM_MSG_CANCEL_REPLY;\r\nms_stub->m_result = stub_cancel_result;\r\nms_stub->m_header.h_nodeid = lkb->lkb_nodeid;\r\n_receive_cancel_reply(lkb, ms_stub);\r\ndlm_put_lkb(lkb);\r\nbreak;\r\ndefault:\r\nlog_error(ls, "invalid lkb wait_type %d %d",\r\nlkb->lkb_wait_type, wait_type);\r\n}\r\nschedule();\r\n}\r\nmutex_unlock(&ls->ls_waiters_mutex);\r\nkfree(ms_stub);\r\n}\r\nstatic struct dlm_lkb *find_resend_waiter(struct dlm_ls *ls)\r\n{\r\nstruct dlm_lkb *lkb;\r\nint found = 0;\r\nmutex_lock(&ls->ls_waiters_mutex);\r\nlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\r\nif (lkb->lkb_flags & DLM_IFL_RESEND) {\r\nhold_lkb(lkb);\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&ls->ls_waiters_mutex);\r\nif (!found)\r\nlkb = NULL;\r\nreturn lkb;\r\n}\r\nint dlm_recover_waiters_post(struct dlm_ls *ls)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_rsb *r;\r\nint error = 0, mstype, err, oc, ou;\r\nwhile (1) {\r\nif (dlm_locking_stopped(ls)) {\r\nlog_debug(ls, "recover_waiters_post aborted");\r\nerror = -EINTR;\r\nbreak;\r\n}\r\nlkb = find_resend_waiter(ls);\r\nif (!lkb)\r\nbreak;\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nmstype = lkb->lkb_wait_type;\r\noc = is_overlap_cancel(lkb);\r\nou = is_overlap_unlock(lkb);\r\nerr = 0;\r\nlog_debug(ls, "waiter %x remote %x msg %d r_nodeid %d "\r\n"lkb_nodeid %d wait_nodeid %d dir_nodeid %d "\r\n"overlap %d %d", lkb->lkb_id, lkb->lkb_remid, mstype,\r\nr->res_nodeid, lkb->lkb_nodeid, lkb->lkb_wait_nodeid,\r\ndlm_dir_nodeid(r), oc, ou);\r\nlkb->lkb_flags &= ~DLM_IFL_RESEND;\r\nlkb->lkb_flags &= ~DLM_IFL_OVERLAP_UNLOCK;\r\nlkb->lkb_flags &= ~DLM_IFL_OVERLAP_CANCEL;\r\nlkb->lkb_wait_type = 0;\r\nlkb->lkb_wait_count = 0;\r\nmutex_lock(&ls->ls_waiters_mutex);\r\nlist_del_init(&lkb->lkb_wait_reply);\r\nmutex_unlock(&ls->ls_waiters_mutex);\r\nunhold_lkb(lkb);\r\nif (oc || ou) {\r\nswitch (mstype) {\r\ncase DLM_MSG_LOOKUP:\r\ncase DLM_MSG_REQUEST:\r\nqueue_cast(r, lkb, ou ? -DLM_EUNLOCK :\r\n-DLM_ECANCEL);\r\nunhold_lkb(lkb);\r\nbreak;\r\ncase DLM_MSG_CONVERT:\r\nif (oc) {\r\nqueue_cast(r, lkb, -DLM_ECANCEL);\r\n} else {\r\nlkb->lkb_exflags |= DLM_LKF_FORCEUNLOCK;\r\n_unlock_lock(r, lkb);\r\n}\r\nbreak;\r\ndefault:\r\nerr = 1;\r\n}\r\n} else {\r\nswitch (mstype) {\r\ncase DLM_MSG_LOOKUP:\r\ncase DLM_MSG_REQUEST:\r\n_request_lock(r, lkb);\r\nif (is_master(r))\r\nconfirm_master(r, 0);\r\nbreak;\r\ncase DLM_MSG_CONVERT:\r\n_convert_lock(r, lkb);\r\nbreak;\r\ndefault:\r\nerr = 1;\r\n}\r\n}\r\nif (err) {\r\nlog_error(ls, "waiter %x msg %d r_nodeid %d "\r\n"dir_nodeid %d overlap %d %d",\r\nlkb->lkb_id, mstype, r->res_nodeid,\r\ndlm_dir_nodeid(r), oc, ou);\r\n}\r\nunlock_rsb(r);\r\nput_rsb(r);\r\ndlm_put_lkb(lkb);\r\n}\r\nreturn error;\r\n}\r\nstatic void purge_mstcpy_list(struct dlm_ls *ls, struct dlm_rsb *r,\r\nstruct list_head *list)\r\n{\r\nstruct dlm_lkb *lkb, *safe;\r\nlist_for_each_entry_safe(lkb, safe, list, lkb_statequeue) {\r\nif (!is_master_copy(lkb))\r\ncontinue;\r\nif (lkb->lkb_recover_seq == ls->ls_recover_seq)\r\ncontinue;\r\ndel_lkb(r, lkb);\r\nif (!dlm_put_lkb(lkb))\r\nlog_error(ls, "purged mstcpy lkb not released");\r\n}\r\n}\r\nvoid dlm_purge_mstcpy_locks(struct dlm_rsb *r)\r\n{\r\nstruct dlm_ls *ls = r->res_ls;\r\npurge_mstcpy_list(ls, r, &r->res_grantqueue);\r\npurge_mstcpy_list(ls, r, &r->res_convertqueue);\r\npurge_mstcpy_list(ls, r, &r->res_waitqueue);\r\n}\r\nstatic void purge_dead_list(struct dlm_ls *ls, struct dlm_rsb *r,\r\nstruct list_head *list,\r\nint nodeid_gone, unsigned int *count)\r\n{\r\nstruct dlm_lkb *lkb, *safe;\r\nlist_for_each_entry_safe(lkb, safe, list, lkb_statequeue) {\r\nif (!is_master_copy(lkb))\r\ncontinue;\r\nif ((lkb->lkb_nodeid == nodeid_gone) ||\r\ndlm_is_removed(ls, lkb->lkb_nodeid)) {\r\ndel_lkb(r, lkb);\r\nif (!dlm_put_lkb(lkb))\r\nlog_error(ls, "purged dead lkb not released");\r\nrsb_set_flag(r, RSB_RECOVER_GRANT);\r\n(*count)++;\r\n}\r\n}\r\n}\r\nvoid dlm_recover_purge(struct dlm_ls *ls)\r\n{\r\nstruct dlm_rsb *r;\r\nstruct dlm_member *memb;\r\nint nodes_count = 0;\r\nint nodeid_gone = 0;\r\nunsigned int lkb_count = 0;\r\nlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\r\nnodes_count++;\r\nnodeid_gone = memb->nodeid;\r\n}\r\nif (!nodes_count)\r\nreturn;\r\ndown_write(&ls->ls_root_sem);\r\nlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nif (is_master(r)) {\r\npurge_dead_list(ls, r, &r->res_grantqueue,\r\nnodeid_gone, &lkb_count);\r\npurge_dead_list(ls, r, &r->res_convertqueue,\r\nnodeid_gone, &lkb_count);\r\npurge_dead_list(ls, r, &r->res_waitqueue,\r\nnodeid_gone, &lkb_count);\r\n}\r\nunlock_rsb(r);\r\nunhold_rsb(r);\r\ncond_resched();\r\n}\r\nup_write(&ls->ls_root_sem);\r\nif (lkb_count)\r\nlog_debug(ls, "dlm_recover_purge %u locks for %u nodes",\r\nlkb_count, nodes_count);\r\n}\r\nstatic struct dlm_rsb *find_grant_rsb(struct dlm_ls *ls, int bucket)\r\n{\r\nstruct rb_node *n;\r\nstruct dlm_rsb *r;\r\nspin_lock(&ls->ls_rsbtbl[bucket].lock);\r\nfor (n = rb_first(&ls->ls_rsbtbl[bucket].keep); n; n = rb_next(n)) {\r\nr = rb_entry(n, struct dlm_rsb, res_hashnode);\r\nif (!rsb_flag(r, RSB_RECOVER_GRANT))\r\ncontinue;\r\nif (!is_master(r)) {\r\nrsb_clear_flag(r, RSB_RECOVER_GRANT);\r\ncontinue;\r\n}\r\nhold_rsb(r);\r\nspin_unlock(&ls->ls_rsbtbl[bucket].lock);\r\nreturn r;\r\n}\r\nspin_unlock(&ls->ls_rsbtbl[bucket].lock);\r\nreturn NULL;\r\n}\r\nvoid dlm_recover_grant(struct dlm_ls *ls)\r\n{\r\nstruct dlm_rsb *r;\r\nint bucket = 0;\r\nunsigned int count = 0;\r\nunsigned int rsb_count = 0;\r\nunsigned int lkb_count = 0;\r\nwhile (1) {\r\nr = find_grant_rsb(ls, bucket);\r\nif (!r) {\r\nif (bucket == ls->ls_rsbtbl_size - 1)\r\nbreak;\r\nbucket++;\r\ncontinue;\r\n}\r\nrsb_count++;\r\ncount = 0;\r\nlock_rsb(r);\r\ngrant_pending_locks(r, &count);\r\nrsb_clear_flag(r, RSB_RECOVER_GRANT);\r\nlkb_count += count;\r\nconfirm_master(r, 0);\r\nunlock_rsb(r);\r\nput_rsb(r);\r\ncond_resched();\r\n}\r\nif (lkb_count)\r\nlog_debug(ls, "dlm_recover_grant %u locks on %u resources",\r\nlkb_count, rsb_count);\r\n}\r\nstatic struct dlm_lkb *search_remid_list(struct list_head *head, int nodeid,\r\nuint32_t remid)\r\n{\r\nstruct dlm_lkb *lkb;\r\nlist_for_each_entry(lkb, head, lkb_statequeue) {\r\nif (lkb->lkb_nodeid == nodeid && lkb->lkb_remid == remid)\r\nreturn lkb;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct dlm_lkb *search_remid(struct dlm_rsb *r, int nodeid,\r\nuint32_t remid)\r\n{\r\nstruct dlm_lkb *lkb;\r\nlkb = search_remid_list(&r->res_grantqueue, nodeid, remid);\r\nif (lkb)\r\nreturn lkb;\r\nlkb = search_remid_list(&r->res_convertqueue, nodeid, remid);\r\nif (lkb)\r\nreturn lkb;\r\nlkb = search_remid_list(&r->res_waitqueue, nodeid, remid);\r\nif (lkb)\r\nreturn lkb;\r\nreturn NULL;\r\n}\r\nstatic int receive_rcom_lock_args(struct dlm_ls *ls, struct dlm_lkb *lkb,\r\nstruct dlm_rsb *r, struct dlm_rcom *rc)\r\n{\r\nstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\r\nlkb->lkb_nodeid = rc->rc_header.h_nodeid;\r\nlkb->lkb_ownpid = le32_to_cpu(rl->rl_ownpid);\r\nlkb->lkb_remid = le32_to_cpu(rl->rl_lkid);\r\nlkb->lkb_exflags = le32_to_cpu(rl->rl_exflags);\r\nlkb->lkb_flags = le32_to_cpu(rl->rl_flags) & 0x0000FFFF;\r\nlkb->lkb_flags |= DLM_IFL_MSTCPY;\r\nlkb->lkb_lvbseq = le32_to_cpu(rl->rl_lvbseq);\r\nlkb->lkb_rqmode = rl->rl_rqmode;\r\nlkb->lkb_grmode = rl->rl_grmode;\r\nlkb->lkb_bastfn = (rl->rl_asts & DLM_CB_BAST) ? &fake_bastfn : NULL;\r\nlkb->lkb_astfn = (rl->rl_asts & DLM_CB_CAST) ? &fake_astfn : NULL;\r\nif (lkb->lkb_exflags & DLM_LKF_VALBLK) {\r\nint lvblen = rc->rc_header.h_length - sizeof(struct dlm_rcom) -\r\nsizeof(struct rcom_lock);\r\nif (lvblen > ls->ls_lvblen)\r\nreturn -EINVAL;\r\nlkb->lkb_lvbptr = dlm_allocate_lvb(ls);\r\nif (!lkb->lkb_lvbptr)\r\nreturn -ENOMEM;\r\nmemcpy(lkb->lkb_lvbptr, rl->rl_lvb, lvblen);\r\n}\r\nif (rl->rl_wait_type == cpu_to_le16(DLM_MSG_CONVERT) &&\r\nmiddle_conversion(lkb)) {\r\nrl->rl_status = DLM_LKSTS_CONVERT;\r\nlkb->lkb_grmode = DLM_LOCK_IV;\r\nrsb_set_flag(r, RSB_RECOVER_CONVERT);\r\n}\r\nreturn 0;\r\n}\r\nint dlm_recover_master_copy(struct dlm_ls *ls, struct dlm_rcom *rc)\r\n{\r\nstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\r\nstruct dlm_rsb *r;\r\nstruct dlm_lkb *lkb;\r\nuint32_t remid = 0;\r\nint from_nodeid = rc->rc_header.h_nodeid;\r\nint error;\r\nif (rl->rl_parent_lkid) {\r\nerror = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nremid = le32_to_cpu(rl->rl_lkid);\r\nerror = find_rsb(ls, rl->rl_name, le16_to_cpu(rl->rl_namelen),\r\nfrom_nodeid, R_RECEIVE_RECOVER, &r);\r\nif (error)\r\ngoto out;\r\nlock_rsb(r);\r\nif (dlm_no_directory(ls) && (dlm_dir_nodeid(r) != dlm_our_nodeid())) {\r\nlog_error(ls, "dlm_recover_master_copy remote %d %x not dir",\r\nfrom_nodeid, remid);\r\nerror = -EBADR;\r\ngoto out_unlock;\r\n}\r\nlkb = search_remid(r, from_nodeid, remid);\r\nif (lkb) {\r\nerror = -EEXIST;\r\ngoto out_remid;\r\n}\r\nerror = create_lkb(ls, &lkb);\r\nif (error)\r\ngoto out_unlock;\r\nerror = receive_rcom_lock_args(ls, lkb, r, rc);\r\nif (error) {\r\n__put_lkb(ls, lkb);\r\ngoto out_unlock;\r\n}\r\nattach_lkb(r, lkb);\r\nadd_lkb(r, lkb, rl->rl_status);\r\nerror = 0;\r\nls->ls_recover_locks_in++;\r\nif (!list_empty(&r->res_waitqueue) || !list_empty(&r->res_convertqueue))\r\nrsb_set_flag(r, RSB_RECOVER_GRANT);\r\nout_remid:\r\nrl->rl_remid = cpu_to_le32(lkb->lkb_id);\r\nlkb->lkb_recover_seq = ls->ls_recover_seq;\r\nout_unlock:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\nout:\r\nif (error && error != -EEXIST)\r\nlog_debug(ls, "dlm_recover_master_copy remote %d %x error %d",\r\nfrom_nodeid, remid, error);\r\nrl->rl_result = cpu_to_le32(error);\r\nreturn error;\r\n}\r\nint dlm_recover_process_copy(struct dlm_ls *ls, struct dlm_rcom *rc)\r\n{\r\nstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\r\nstruct dlm_rsb *r;\r\nstruct dlm_lkb *lkb;\r\nuint32_t lkid, remid;\r\nint error, result;\r\nlkid = le32_to_cpu(rl->rl_lkid);\r\nremid = le32_to_cpu(rl->rl_remid);\r\nresult = le32_to_cpu(rl->rl_result);\r\nerror = find_lkb(ls, lkid, &lkb);\r\nif (error) {\r\nlog_error(ls, "dlm_recover_process_copy no %x remote %d %x %d",\r\nlkid, rc->rc_header.h_nodeid, remid, result);\r\nreturn error;\r\n}\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nif (!is_process_copy(lkb)) {\r\nlog_error(ls, "dlm_recover_process_copy bad %x remote %d %x %d",\r\nlkid, rc->rc_header.h_nodeid, remid, result);\r\ndlm_dump_rsb(r);\r\nunlock_rsb(r);\r\nput_rsb(r);\r\ndlm_put_lkb(lkb);\r\nreturn -EINVAL;\r\n}\r\nswitch (result) {\r\ncase -EBADR:\r\nlog_debug(ls, "dlm_recover_process_copy %x remote %d %x %d",\r\nlkid, rc->rc_header.h_nodeid, remid, result);\r\ndlm_send_rcom_lock(r, lkb);\r\ngoto out;\r\ncase -EEXIST:\r\ncase 0:\r\nlkb->lkb_remid = remid;\r\nbreak;\r\ndefault:\r\nlog_error(ls, "dlm_recover_process_copy %x remote %d %x %d unk",\r\nlkid, rc->rc_header.h_nodeid, remid, result);\r\n}\r\ndlm_recovered_lock(r);\r\nout:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\ndlm_put_lkb(lkb);\r\nreturn 0;\r\n}\r\nint dlm_user_request(struct dlm_ls *ls, struct dlm_user_args *ua,\r\nint mode, uint32_t flags, void *name, unsigned int namelen,\r\nunsigned long timeout_cs)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_args args;\r\nint error;\r\ndlm_lock_recovery(ls);\r\nerror = create_lkb(ls, &lkb);\r\nif (error) {\r\nkfree(ua);\r\ngoto out;\r\n}\r\nif (flags & DLM_LKF_VALBLK) {\r\nua->lksb.sb_lvbptr = kzalloc(DLM_USER_LVB_LEN, GFP_NOFS);\r\nif (!ua->lksb.sb_lvbptr) {\r\nkfree(ua);\r\n__put_lkb(ls, lkb);\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nerror = set_lock_args(mode, &ua->lksb, flags, namelen, timeout_cs,\r\nfake_astfn, ua, fake_bastfn, &args);\r\nlkb->lkb_flags |= DLM_IFL_USER;\r\nif (error) {\r\n__put_lkb(ls, lkb);\r\ngoto out;\r\n}\r\nerror = request_lock(ls, lkb, name, namelen, &args);\r\nswitch (error) {\r\ncase 0:\r\nbreak;\r\ncase -EINPROGRESS:\r\nerror = 0;\r\nbreak;\r\ncase -EAGAIN:\r\nerror = 0;\r\ndefault:\r\n__put_lkb(ls, lkb);\r\ngoto out;\r\n}\r\nspin_lock(&ua->proc->locks_spin);\r\nhold_lkb(lkb);\r\nlist_add_tail(&lkb->lkb_ownqueue, &ua->proc->locks);\r\nspin_unlock(&ua->proc->locks_spin);\r\nout:\r\ndlm_unlock_recovery(ls);\r\nreturn error;\r\n}\r\nint dlm_user_convert(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\r\nint mode, uint32_t flags, uint32_t lkid, char *lvb_in,\r\nunsigned long timeout_cs)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_args args;\r\nstruct dlm_user_args *ua;\r\nint error;\r\ndlm_lock_recovery(ls);\r\nerror = find_lkb(ls, lkid, &lkb);\r\nif (error)\r\ngoto out;\r\nua = lkb->lkb_ua;\r\nif (flags & DLM_LKF_VALBLK && !ua->lksb.sb_lvbptr) {\r\nua->lksb.sb_lvbptr = kzalloc(DLM_USER_LVB_LEN, GFP_NOFS);\r\nif (!ua->lksb.sb_lvbptr) {\r\nerror = -ENOMEM;\r\ngoto out_put;\r\n}\r\n}\r\nif (lvb_in && ua->lksb.sb_lvbptr)\r\nmemcpy(ua->lksb.sb_lvbptr, lvb_in, DLM_USER_LVB_LEN);\r\nua->xid = ua_tmp->xid;\r\nua->castparam = ua_tmp->castparam;\r\nua->castaddr = ua_tmp->castaddr;\r\nua->bastparam = ua_tmp->bastparam;\r\nua->bastaddr = ua_tmp->bastaddr;\r\nua->user_lksb = ua_tmp->user_lksb;\r\nerror = set_lock_args(mode, &ua->lksb, flags, 0, timeout_cs,\r\nfake_astfn, ua, fake_bastfn, &args);\r\nif (error)\r\ngoto out_put;\r\nerror = convert_lock(ls, lkb, &args);\r\nif (error == -EINPROGRESS || error == -EAGAIN || error == -EDEADLK)\r\nerror = 0;\r\nout_put:\r\ndlm_put_lkb(lkb);\r\nout:\r\ndlm_unlock_recovery(ls);\r\nkfree(ua_tmp);\r\nreturn error;\r\n}\r\nint dlm_user_unlock(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\r\nuint32_t flags, uint32_t lkid, char *lvb_in)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_args args;\r\nstruct dlm_user_args *ua;\r\nint error;\r\ndlm_lock_recovery(ls);\r\nerror = find_lkb(ls, lkid, &lkb);\r\nif (error)\r\ngoto out;\r\nua = lkb->lkb_ua;\r\nif (lvb_in && ua->lksb.sb_lvbptr)\r\nmemcpy(ua->lksb.sb_lvbptr, lvb_in, DLM_USER_LVB_LEN);\r\nif (ua_tmp->castparam)\r\nua->castparam = ua_tmp->castparam;\r\nua->user_lksb = ua_tmp->user_lksb;\r\nerror = set_unlock_args(flags, ua, &args);\r\nif (error)\r\ngoto out_put;\r\nerror = unlock_lock(ls, lkb, &args);\r\nif (error == -DLM_EUNLOCK)\r\nerror = 0;\r\nif (error == -EBUSY && (flags & DLM_LKF_FORCEUNLOCK))\r\nerror = 0;\r\nif (error)\r\ngoto out_put;\r\nspin_lock(&ua->proc->locks_spin);\r\nif (!list_empty(&lkb->lkb_ownqueue))\r\nlist_move(&lkb->lkb_ownqueue, &ua->proc->unlocking);\r\nspin_unlock(&ua->proc->locks_spin);\r\nout_put:\r\ndlm_put_lkb(lkb);\r\nout:\r\ndlm_unlock_recovery(ls);\r\nkfree(ua_tmp);\r\nreturn error;\r\n}\r\nint dlm_user_cancel(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\r\nuint32_t flags, uint32_t lkid)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_args args;\r\nstruct dlm_user_args *ua;\r\nint error;\r\ndlm_lock_recovery(ls);\r\nerror = find_lkb(ls, lkid, &lkb);\r\nif (error)\r\ngoto out;\r\nua = lkb->lkb_ua;\r\nif (ua_tmp->castparam)\r\nua->castparam = ua_tmp->castparam;\r\nua->user_lksb = ua_tmp->user_lksb;\r\nerror = set_unlock_args(flags, ua, &args);\r\nif (error)\r\ngoto out_put;\r\nerror = cancel_lock(ls, lkb, &args);\r\nif (error == -DLM_ECANCEL)\r\nerror = 0;\r\nif (error == -EBUSY)\r\nerror = 0;\r\nout_put:\r\ndlm_put_lkb(lkb);\r\nout:\r\ndlm_unlock_recovery(ls);\r\nkfree(ua_tmp);\r\nreturn error;\r\n}\r\nint dlm_user_deadlock(struct dlm_ls *ls, uint32_t flags, uint32_t lkid)\r\n{\r\nstruct dlm_lkb *lkb;\r\nstruct dlm_args args;\r\nstruct dlm_user_args *ua;\r\nstruct dlm_rsb *r;\r\nint error;\r\ndlm_lock_recovery(ls);\r\nerror = find_lkb(ls, lkid, &lkb);\r\nif (error)\r\ngoto out;\r\nua = lkb->lkb_ua;\r\nerror = set_unlock_args(flags, ua, &args);\r\nif (error)\r\ngoto out_put;\r\nr = lkb->lkb_resource;\r\nhold_rsb(r);\r\nlock_rsb(r);\r\nerror = validate_unlock_args(lkb, &args);\r\nif (error)\r\ngoto out_r;\r\nlkb->lkb_flags |= DLM_IFL_DEADLOCK_CANCEL;\r\nerror = _cancel_lock(r, lkb);\r\nout_r:\r\nunlock_rsb(r);\r\nput_rsb(r);\r\nif (error == -DLM_ECANCEL)\r\nerror = 0;\r\nif (error == -EBUSY)\r\nerror = 0;\r\nout_put:\r\ndlm_put_lkb(lkb);\r\nout:\r\ndlm_unlock_recovery(ls);\r\nreturn error;\r\n}\r\nstatic int orphan_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\r\n{\r\nstruct dlm_args args;\r\nint error;\r\nhold_lkb(lkb);\r\nmutex_lock(&ls->ls_orphans_mutex);\r\nlist_add_tail(&lkb->lkb_ownqueue, &ls->ls_orphans);\r\nmutex_unlock(&ls->ls_orphans_mutex);\r\nset_unlock_args(0, lkb->lkb_ua, &args);\r\nerror = cancel_lock(ls, lkb, &args);\r\nif (error == -DLM_ECANCEL)\r\nerror = 0;\r\nreturn error;\r\n}\r\nstatic int unlock_proc_lock(struct dlm_ls *ls, struct dlm_lkb *lkb)\r\n{\r\nstruct dlm_args args;\r\nint error;\r\nset_unlock_args(DLM_LKF_FORCEUNLOCK, lkb->lkb_ua, &args);\r\nerror = unlock_lock(ls, lkb, &args);\r\nif (error == -DLM_EUNLOCK)\r\nerror = 0;\r\nreturn error;\r\n}\r\nstatic struct dlm_lkb *del_proc_lock(struct dlm_ls *ls,\r\nstruct dlm_user_proc *proc)\r\n{\r\nstruct dlm_lkb *lkb = NULL;\r\nmutex_lock(&ls->ls_clear_proc_locks);\r\nif (list_empty(&proc->locks))\r\ngoto out;\r\nlkb = list_entry(proc->locks.next, struct dlm_lkb, lkb_ownqueue);\r\nlist_del_init(&lkb->lkb_ownqueue);\r\nif (lkb->lkb_exflags & DLM_LKF_PERSISTENT)\r\nlkb->lkb_flags |= DLM_IFL_ORPHAN;\r\nelse\r\nlkb->lkb_flags |= DLM_IFL_DEAD;\r\nout:\r\nmutex_unlock(&ls->ls_clear_proc_locks);\r\nreturn lkb;\r\n}\r\nvoid dlm_clear_proc_locks(struct dlm_ls *ls, struct dlm_user_proc *proc)\r\n{\r\nstruct dlm_lkb *lkb, *safe;\r\ndlm_lock_recovery(ls);\r\nwhile (1) {\r\nlkb = del_proc_lock(ls, proc);\r\nif (!lkb)\r\nbreak;\r\ndel_timeout(lkb);\r\nif (lkb->lkb_exflags & DLM_LKF_PERSISTENT)\r\norphan_proc_lock(ls, lkb);\r\nelse\r\nunlock_proc_lock(ls, lkb);\r\ndlm_put_lkb(lkb);\r\n}\r\nmutex_lock(&ls->ls_clear_proc_locks);\r\nlist_for_each_entry_safe(lkb, safe, &proc->unlocking, lkb_ownqueue) {\r\nlist_del_init(&lkb->lkb_ownqueue);\r\nlkb->lkb_flags |= DLM_IFL_DEAD;\r\ndlm_put_lkb(lkb);\r\n}\r\nlist_for_each_entry_safe(lkb, safe, &proc->asts, lkb_cb_list) {\r\nmemset(&lkb->lkb_callbacks, 0,\r\nsizeof(struct dlm_callback) * DLM_CALLBACKS_SIZE);\r\nlist_del_init(&lkb->lkb_cb_list);\r\ndlm_put_lkb(lkb);\r\n}\r\nmutex_unlock(&ls->ls_clear_proc_locks);\r\ndlm_unlock_recovery(ls);\r\n}\r\nstatic void purge_proc_locks(struct dlm_ls *ls, struct dlm_user_proc *proc)\r\n{\r\nstruct dlm_lkb *lkb, *safe;\r\nwhile (1) {\r\nlkb = NULL;\r\nspin_lock(&proc->locks_spin);\r\nif (!list_empty(&proc->locks)) {\r\nlkb = list_entry(proc->locks.next, struct dlm_lkb,\r\nlkb_ownqueue);\r\nlist_del_init(&lkb->lkb_ownqueue);\r\n}\r\nspin_unlock(&proc->locks_spin);\r\nif (!lkb)\r\nbreak;\r\nlkb->lkb_flags |= DLM_IFL_DEAD;\r\nunlock_proc_lock(ls, lkb);\r\ndlm_put_lkb(lkb);\r\n}\r\nspin_lock(&proc->locks_spin);\r\nlist_for_each_entry_safe(lkb, safe, &proc->unlocking, lkb_ownqueue) {\r\nlist_del_init(&lkb->lkb_ownqueue);\r\nlkb->lkb_flags |= DLM_IFL_DEAD;\r\ndlm_put_lkb(lkb);\r\n}\r\nspin_unlock(&proc->locks_spin);\r\nspin_lock(&proc->asts_spin);\r\nlist_for_each_entry_safe(lkb, safe, &proc->asts, lkb_cb_list) {\r\nmemset(&lkb->lkb_callbacks, 0,\r\nsizeof(struct dlm_callback) * DLM_CALLBACKS_SIZE);\r\nlist_del_init(&lkb->lkb_cb_list);\r\ndlm_put_lkb(lkb);\r\n}\r\nspin_unlock(&proc->asts_spin);\r\n}\r\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid)\r\n{\r\nstruct dlm_lkb *lkb, *safe;\r\nmutex_lock(&ls->ls_orphans_mutex);\r\nlist_for_each_entry_safe(lkb, safe, &ls->ls_orphans, lkb_ownqueue) {\r\nif (pid && lkb->lkb_ownpid != pid)\r\ncontinue;\r\nunlock_proc_lock(ls, lkb);\r\nlist_del_init(&lkb->lkb_ownqueue);\r\ndlm_put_lkb(lkb);\r\n}\r\nmutex_unlock(&ls->ls_orphans_mutex);\r\n}\r\nstatic int send_purge(struct dlm_ls *ls, int nodeid, int pid)\r\n{\r\nstruct dlm_message *ms;\r\nstruct dlm_mhandle *mh;\r\nint error;\r\nerror = _create_message(ls, sizeof(struct dlm_message), nodeid,\r\nDLM_MSG_PURGE, &ms, &mh);\r\nif (error)\r\nreturn error;\r\nms->m_nodeid = nodeid;\r\nms->m_pid = pid;\r\nreturn send_message(mh, ms);\r\n}\r\nint dlm_user_purge(struct dlm_ls *ls, struct dlm_user_proc *proc,\r\nint nodeid, int pid)\r\n{\r\nint error = 0;\r\nif (nodeid != dlm_our_nodeid()) {\r\nerror = send_purge(ls, nodeid, pid);\r\n} else {\r\ndlm_lock_recovery(ls);\r\nif (pid == current->pid)\r\npurge_proc_locks(ls, proc);\r\nelse\r\ndo_purge(ls, nodeid, pid);\r\ndlm_unlock_recovery(ls);\r\n}\r\nreturn error;\r\n}
