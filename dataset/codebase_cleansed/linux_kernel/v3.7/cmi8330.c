static int __devinit cmi8330_add_sb_mixers(struct snd_sb *chip)\r\n{\r\nint idx, err;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->mixer_lock, flags);\r\nsnd_sbmixer_write(chip, 0x00, 0x00);\r\nspin_unlock_irqrestore(&chip->mixer_lock, flags);\r\nfor (idx = 0; idx < ARRAY_SIZE(cmi8330_sb_init_values); idx++) {\r\nspin_lock_irqsave(&chip->mixer_lock, flags);\r\nsnd_sbmixer_write(chip, cmi8330_sb_init_values[idx][0],\r\ncmi8330_sb_init_values[idx][1]);\r\nspin_unlock_irqrestore(&chip->mixer_lock, flags);\r\n}\r\nfor (idx = 0; idx < ARRAY_SIZE(cmi8330_sb_mixers); idx++) {\r\nif ((err = snd_sbmixer_add_ctl_elem(chip, &cmi8330_sb_mixers[idx])) < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_cmi8330_mixer(struct snd_card *card, struct snd_cmi8330 *acard)\r\n{\r\nunsigned int idx;\r\nint err;\r\nstrcpy(card->mixername, (acard->type == CMI8329) ? "CMI8329" : "CMI8330/C3D");\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_cmi8330_controls); idx++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_cmi8330_controls[idx],\r\nacard->wss));\r\nif (err < 0)\r\nreturn err;\r\n}\r\n#ifdef ENABLE_SB_MIXER\r\nif ((err = cmi8330_add_sb_mixers(acard->sb)) < 0)\r\nreturn err;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_cmi8330_pnp(int dev, struct snd_cmi8330 *acard,\r\nstruct pnp_card_link *card,\r\nconst struct pnp_card_device_id *id)\r\n{\r\nstruct pnp_dev *pdev;\r\nint err;\r\nacard->type = (id->devs[3].id[0]) ? CMI8329 : CMI8330;\r\nacard->cap = pnp_request_card_device(card, id->devs[0].id, NULL);\r\nif (acard->cap == NULL)\r\nreturn -EBUSY;\r\nacard->play = pnp_request_card_device(card, id->devs[1].id, NULL);\r\nif (acard->play == NULL)\r\nreturn -EBUSY;\r\nacard->mpu = pnp_request_card_device(card, id->devs[2].id, NULL);\r\nif (acard->mpu == NULL)\r\nreturn -EBUSY;\r\npdev = acard->cap;\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "AD1848 PnP configure failure\n");\r\nreturn -EBUSY;\r\n}\r\nwssport[dev] = pnp_port_start(pdev, 0);\r\nwssdma[dev] = pnp_dma(pdev, 0);\r\nwssirq[dev] = pnp_irq(pdev, 0);\r\nif (pnp_port_start(pdev, 1))\r\nfmport[dev] = pnp_port_start(pdev, 1);\r\npdev = acard->play;\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "SB16 PnP configure failure\n");\r\nreturn -EBUSY;\r\n}\r\nsbport[dev] = pnp_port_start(pdev, 0);\r\nsbdma8[dev] = pnp_dma(pdev, 0);\r\nsbdma16[dev] = pnp_dma(pdev, 1);\r\nsbirq[dev] = pnp_irq(pdev, 0);\r\nif (fmport[dev] == SNDRV_AUTO_PORT) {\r\nif (pnp_port_start(pdev, 1))\r\nfmport[dev] = pnp_port_start(pdev, 1);\r\nelse\r\nfmport[dev] = 0x388;\r\n}\r\npdev = acard->mpu;\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0)\r\nsnd_printk(KERN_ERR "MPU-401 PnP configure failure: will be disabled\n");\r\nelse {\r\nmpuport[dev] = pnp_port_start(pdev, 0);\r\nmpuirq[dev] = pnp_irq(pdev, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cmi8330_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cmi8330 *chip = snd_pcm_substream_chip(substream);\r\nsubstream->private_data = chip->streams[SNDRV_PCM_STREAM_PLAYBACK].private_data;\r\nreturn chip->streams[SNDRV_PCM_STREAM_PLAYBACK].open(substream);\r\n}\r\nstatic int snd_cmi8330_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cmi8330 *chip = snd_pcm_substream_chip(substream);\r\nsubstream->private_data = chip->streams[SNDRV_PCM_STREAM_CAPTURE].private_data;\r\nreturn chip->streams[SNDRV_PCM_STREAM_CAPTURE].open(substream);\r\n}\r\nstatic int __devinit snd_cmi8330_pcm(struct snd_card *card, struct snd_cmi8330 *chip)\r\n{\r\nstruct snd_pcm *pcm;\r\nconst struct snd_pcm_ops *ops;\r\nint err;\r\nstatic snd_pcm_open_callback_t cmi_open_callbacks[2] = {\r\nsnd_cmi8330_playback_open,\r\nsnd_cmi8330_capture_open\r\n};\r\nif ((err = snd_pcm_new(card, (chip->type == CMI8329) ? "CMI8329" : "CMI8330", 0, 1, 1, &pcm)) < 0)\r\nreturn err;\r\nstrcpy(pcm->name, (chip->type == CMI8329) ? "CMI8329" : "CMI8330");\r\npcm->private_data = chip;\r\nops = snd_sb16dsp_get_pcm_ops(CMI_SB_STREAM);\r\nchip->streams[CMI_SB_STREAM].ops = *ops;\r\nchip->streams[CMI_SB_STREAM].open = ops->open;\r\nchip->streams[CMI_SB_STREAM].ops.open = cmi_open_callbacks[CMI_SB_STREAM];\r\nchip->streams[CMI_SB_STREAM].private_data = chip->sb;\r\nops = snd_wss_get_pcm_ops(CMI_AD_STREAM);\r\nchip->streams[CMI_AD_STREAM].ops = *ops;\r\nchip->streams[CMI_AD_STREAM].open = ops->open;\r\nchip->streams[CMI_AD_STREAM].ops.open = cmi_open_callbacks[CMI_AD_STREAM];\r\nchip->streams[CMI_AD_STREAM].private_data = chip->wss;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &chip->streams[SNDRV_PCM_STREAM_PLAYBACK].ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &chip->streams[SNDRV_PCM_STREAM_CAPTURE].ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_isa_data(),\r\n64*1024, 128*1024);\r\nchip->pcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_cmi8330_suspend(struct snd_card *card)\r\n{\r\nstruct snd_cmi8330 *acard = card->private_data;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(acard->pcm);\r\nacard->wss->suspend(acard->wss);\r\nsnd_sbmixer_suspend(acard->sb);\r\nreturn 0;\r\n}\r\nstatic int snd_cmi8330_resume(struct snd_card *card)\r\n{\r\nstruct snd_cmi8330 *acard = card->private_data;\r\nsnd_sbdsp_reset(acard->sb);\r\nsnd_sbmixer_suspend(acard->sb);\r\nacard->wss->resume(acard->wss);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int snd_cmi8330_card_new(int dev, struct snd_card **cardp)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_cmi8330 *acard;\r\nint err;\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct snd_cmi8330), &card);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR PFX "could not get a new card\n");\r\nreturn err;\r\n}\r\nacard = card->private_data;\r\nacard->card = card;\r\n*cardp = card;\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_cmi8330_probe(struct snd_card *card, int dev)\r\n{\r\nstruct snd_cmi8330 *acard;\r\nint i, err;\r\nstruct snd_opl3 *opl3;\r\nacard = card->private_data;\r\nerr = snd_wss_create(card, wssport[dev] + 4, -1,\r\nwssirq[dev],\r\nwssdma[dev], -1,\r\nWSS_HW_DETECT, 0, &acard->wss);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR PFX "AD1848 device busy??\n");\r\nreturn err;\r\n}\r\nif (acard->wss->hardware != WSS_HW_CMI8330) {\r\nsnd_printk(KERN_ERR PFX "AD1848 not found during probe\n");\r\nreturn -ENODEV;\r\n}\r\nif ((err = snd_sbdsp_create(card, sbport[dev],\r\nsbirq[dev],\r\nsnd_sb16dsp_interrupt,\r\nsbdma8[dev],\r\nsbdma16[dev],\r\nSB_HW_AUTO, &acard->sb)) < 0) {\r\nsnd_printk(KERN_ERR PFX "SB16 device busy??\n");\r\nreturn err;\r\n}\r\nif (acard->sb->hardware != SB_HW_16) {\r\nsnd_printk(KERN_ERR PFX "SB16 not found during probe\n");\r\nreturn err;\r\n}\r\nsnd_wss_out(acard->wss, CS4231_MISC_INFO, 0x40);\r\nfor (i = CMI8330_RMUX3D; i <= CMI8330_CDINGAIN; i++)\r\nsnd_wss_out(acard->wss, i,\r\nsnd_cmi8330_image[i - CMI8330_RMUX3D]);\r\nif ((err = snd_cmi8330_mixer(card, acard)) < 0) {\r\nsnd_printk(KERN_ERR PFX "failed to create mixers\n");\r\nreturn err;\r\n}\r\nif ((err = snd_cmi8330_pcm(card, acard)) < 0) {\r\nsnd_printk(KERN_ERR PFX "failed to create pcms\n");\r\nreturn err;\r\n}\r\nif (fmport[dev] != SNDRV_AUTO_PORT) {\r\nif (snd_opl3_create(card,\r\nfmport[dev], fmport[dev] + 2,\r\nOPL3_HW_AUTO, 0, &opl3) < 0) {\r\nsnd_printk(KERN_ERR PFX\r\n"no OPL device at 0x%lx-0x%lx ?\n",\r\nfmport[dev], fmport[dev] + 2);\r\n} else {\r\nerr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (mpuport[dev] != SNDRV_AUTO_PORT) {\r\nif (snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\r\nmpuport[dev], 0, mpuirq[dev],\r\nNULL) < 0)\r\nprintk(KERN_ERR PFX "no MPU-401 device at 0x%lx.\n",\r\nmpuport[dev]);\r\n}\r\nstrcpy(card->driver, (acard->type == CMI8329) ? "CMI8329" : "CMI8330/C3D");\r\nstrcpy(card->shortname, (acard->type == CMI8329) ? "C-Media CMI8329" : "C-Media CMI8330/C3D");\r\nsprintf(card->longname, "%s at 0x%lx, irq %d, dma %d",\r\ncard->shortname,\r\nacard->wss->port,\r\nwssirq[dev],\r\nwssdma[dev]);\r\nreturn snd_card_register(card);\r\n}\r\nstatic int __devinit snd_cmi8330_isa_match(struct device *pdev,\r\nunsigned int dev)\r\n{\r\nif (!enable[dev] || is_isapnp_selected(dev))\r\nreturn 0;\r\nif (wssport[dev] == SNDRV_AUTO_PORT) {\r\nsnd_printk(KERN_ERR PFX "specify wssport\n");\r\nreturn 0;\r\n}\r\nif (sbport[dev] == SNDRV_AUTO_PORT) {\r\nsnd_printk(KERN_ERR PFX "specify sbport\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __devinit snd_cmi8330_isa_probe(struct device *pdev,\r\nunsigned int dev)\r\n{\r\nstruct snd_card *card;\r\nint err;\r\nerr = snd_cmi8330_card_new(dev, &card);\r\nif (err < 0)\r\nreturn err;\r\nsnd_card_set_dev(card, pdev);\r\nif ((err = snd_cmi8330_probe(card, dev)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ndev_set_drvdata(pdev, card);\r\nreturn 0;\r\n}\r\nstatic int __devexit snd_cmi8330_isa_remove(struct device *devptr,\r\nunsigned int dev)\r\n{\r\nsnd_card_free(dev_get_drvdata(devptr));\r\ndev_set_drvdata(devptr, NULL);\r\nreturn 0;\r\n}\r\nstatic int snd_cmi8330_isa_suspend(struct device *dev, unsigned int n,\r\npm_message_t state)\r\n{\r\nreturn snd_cmi8330_suspend(dev_get_drvdata(dev));\r\n}\r\nstatic int snd_cmi8330_isa_resume(struct device *dev, unsigned int n)\r\n{\r\nreturn snd_cmi8330_resume(dev_get_drvdata(dev));\r\n}\r\nstatic int __devinit snd_cmi8330_pnp_detect(struct pnp_card_link *pcard,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nint res;\r\nfor ( ; dev < SNDRV_CARDS; dev++) {\r\nif (enable[dev] && isapnp[dev])\r\nbreak;\r\n}\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nres = snd_cmi8330_card_new(dev, &card);\r\nif (res < 0)\r\nreturn res;\r\nif ((res = snd_cmi8330_pnp(dev, card->private_data, pcard, pid)) < 0) {\r\nsnd_printk(KERN_ERR PFX "PnP detection failed\n");\r\nsnd_card_free(card);\r\nreturn res;\r\n}\r\nsnd_card_set_dev(card, &pcard->card->dev);\r\nif ((res = snd_cmi8330_probe(card, dev)) < 0) {\r\nsnd_card_free(card);\r\nreturn res;\r\n}\r\npnp_set_card_drvdata(pcard, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void __devexit snd_cmi8330_pnp_remove(struct pnp_card_link * pcard)\r\n{\r\nsnd_card_free(pnp_get_card_drvdata(pcard));\r\npnp_set_card_drvdata(pcard, NULL);\r\n}\r\nstatic int snd_cmi8330_pnp_suspend(struct pnp_card_link *pcard, pm_message_t state)\r\n{\r\nreturn snd_cmi8330_suspend(pnp_get_card_drvdata(pcard));\r\n}\r\nstatic int snd_cmi8330_pnp_resume(struct pnp_card_link *pcard)\r\n{\r\nreturn snd_cmi8330_resume(pnp_get_card_drvdata(pcard));\r\n}\r\nstatic int __init alsa_card_cmi8330_init(void)\r\n{\r\nint err;\r\nerr = isa_register_driver(&snd_cmi8330_driver, SNDRV_CARDS);\r\n#ifdef CONFIG_PNP\r\nif (!err)\r\nisa_registered = 1;\r\nerr = pnp_register_card_driver(&cmi8330_pnpc_driver);\r\nif (!err)\r\npnp_registered = 1;\r\nif (isa_registered)\r\nerr = 0;\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit alsa_card_cmi8330_exit(void)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (pnp_registered)\r\npnp_unregister_card_driver(&cmi8330_pnpc_driver);\r\nif (isa_registered)\r\n#endif\r\nisa_unregister_driver(&snd_cmi8330_driver);\r\n}
