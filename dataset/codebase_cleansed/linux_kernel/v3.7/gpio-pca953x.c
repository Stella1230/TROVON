static int pca953x_write_reg(struct pca953x_chip *chip, int reg, u32 val)\r\n{\r\nint ret = 0;\r\nif (chip->gpio_chip.ngpio <= 8)\r\nret = i2c_smbus_write_byte_data(chip->client, reg, val);\r\nelse if (chip->gpio_chip.ngpio == 24) {\r\ncpu_to_le32s(&val);\r\nret = i2c_smbus_write_i2c_block_data(chip->client,\r\n(reg << 2) | REG_ADDR_AI,\r\n3,\r\n(u8 *) &val);\r\n}\r\nelse {\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\nret = i2c_smbus_write_word_data(chip->client,\r\nreg << 1, val);\r\nbreak;\r\ncase PCA957X_TYPE:\r\nret = i2c_smbus_write_byte_data(chip->client, reg << 1,\r\nval & 0xff);\r\nif (ret < 0)\r\nbreak;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\n(reg << 1) + 1,\r\n(val & 0xff00) >> 8);\r\nbreak;\r\n}\r\n}\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "failed writing register\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pca953x_read_reg(struct pca953x_chip *chip, int reg, u32 *val)\r\n{\r\nint ret;\r\nif (chip->gpio_chip.ngpio <= 8) {\r\nret = i2c_smbus_read_byte_data(chip->client, reg);\r\n*val = ret;\r\n}\r\nelse if (chip->gpio_chip.ngpio == 24) {\r\n*val = 0;\r\nret = i2c_smbus_read_i2c_block_data(chip->client,\r\n(reg << 2) | REG_ADDR_AI,\r\n3,\r\n(u8 *) val);\r\nle32_to_cpus(val);\r\n} else {\r\nret = i2c_smbus_read_word_data(chip->client, reg << 1);\r\n*val = ret;\r\n}\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "failed reading register\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pca953x_gpio_direction_input(struct gpio_chip *gc, unsigned off)\r\n{\r\nstruct pca953x_chip *chip;\r\nuint reg_val;\r\nint ret, offset = 0;\r\nchip = container_of(gc, struct pca953x_chip, gpio_chip);\r\nmutex_lock(&chip->i2c_lock);\r\nreg_val = chip->reg_direction | (1u << off);\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_DIRECTION;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_CFG;\r\nbreak;\r\n}\r\nret = pca953x_write_reg(chip, offset, reg_val);\r\nif (ret)\r\ngoto exit;\r\nchip->reg_direction = reg_val;\r\nret = 0;\r\nexit:\r\nmutex_unlock(&chip->i2c_lock);\r\nreturn ret;\r\n}\r\nstatic int pca953x_gpio_direction_output(struct gpio_chip *gc,\r\nunsigned off, int val)\r\n{\r\nstruct pca953x_chip *chip;\r\nuint reg_val;\r\nint ret, offset = 0;\r\nchip = container_of(gc, struct pca953x_chip, gpio_chip);\r\nmutex_lock(&chip->i2c_lock);\r\nif (val)\r\nreg_val = chip->reg_output | (1u << off);\r\nelse\r\nreg_val = chip->reg_output & ~(1u << off);\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_OUTPUT;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_OUT;\r\nbreak;\r\n}\r\nret = pca953x_write_reg(chip, offset, reg_val);\r\nif (ret)\r\ngoto exit;\r\nchip->reg_output = reg_val;\r\nreg_val = chip->reg_direction & ~(1u << off);\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_DIRECTION;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_CFG;\r\nbreak;\r\n}\r\nret = pca953x_write_reg(chip, offset, reg_val);\r\nif (ret)\r\ngoto exit;\r\nchip->reg_direction = reg_val;\r\nret = 0;\r\nexit:\r\nmutex_unlock(&chip->i2c_lock);\r\nreturn ret;\r\n}\r\nstatic int pca953x_gpio_get_value(struct gpio_chip *gc, unsigned off)\r\n{\r\nstruct pca953x_chip *chip;\r\nu32 reg_val;\r\nint ret, offset = 0;\r\nchip = container_of(gc, struct pca953x_chip, gpio_chip);\r\nmutex_lock(&chip->i2c_lock);\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_INPUT;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_IN;\r\nbreak;\r\n}\r\nret = pca953x_read_reg(chip, offset, &reg_val);\r\nmutex_unlock(&chip->i2c_lock);\r\nif (ret < 0) {\r\nreturn 0;\r\n}\r\nreturn (reg_val & (1u << off)) ? 1 : 0;\r\n}\r\nstatic void pca953x_gpio_set_value(struct gpio_chip *gc, unsigned off, int val)\r\n{\r\nstruct pca953x_chip *chip;\r\nu32 reg_val;\r\nint ret, offset = 0;\r\nchip = container_of(gc, struct pca953x_chip, gpio_chip);\r\nmutex_lock(&chip->i2c_lock);\r\nif (val)\r\nreg_val = chip->reg_output | (1u << off);\r\nelse\r\nreg_val = chip->reg_output & ~(1u << off);\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_OUTPUT;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_OUT;\r\nbreak;\r\n}\r\nret = pca953x_write_reg(chip, offset, reg_val);\r\nif (ret)\r\ngoto exit;\r\nchip->reg_output = reg_val;\r\nexit:\r\nmutex_unlock(&chip->i2c_lock);\r\n}\r\nstatic void pca953x_setup_gpio(struct pca953x_chip *chip, int gpios)\r\n{\r\nstruct gpio_chip *gc;\r\ngc = &chip->gpio_chip;\r\ngc->direction_input = pca953x_gpio_direction_input;\r\ngc->direction_output = pca953x_gpio_direction_output;\r\ngc->get = pca953x_gpio_get_value;\r\ngc->set = pca953x_gpio_set_value;\r\ngc->can_sleep = 1;\r\ngc->base = chip->gpio_start;\r\ngc->ngpio = gpios;\r\ngc->label = chip->client->name;\r\ngc->dev = &chip->client->dev;\r\ngc->owner = THIS_MODULE;\r\ngc->names = chip->names;\r\n}\r\nstatic int pca953x_gpio_to_irq(struct gpio_chip *gc, unsigned off)\r\n{\r\nstruct pca953x_chip *chip;\r\nchip = container_of(gc, struct pca953x_chip, gpio_chip);\r\nreturn chip->irq_base + off;\r\n}\r\nstatic void pca953x_irq_mask(struct irq_data *d)\r\n{\r\nstruct pca953x_chip *chip = irq_data_get_irq_chip_data(d);\r\nchip->irq_mask &= ~(1 << (d->irq - chip->irq_base));\r\n}\r\nstatic void pca953x_irq_unmask(struct irq_data *d)\r\n{\r\nstruct pca953x_chip *chip = irq_data_get_irq_chip_data(d);\r\nchip->irq_mask |= 1 << (d->irq - chip->irq_base);\r\n}\r\nstatic void pca953x_irq_bus_lock(struct irq_data *d)\r\n{\r\nstruct pca953x_chip *chip = irq_data_get_irq_chip_data(d);\r\nmutex_lock(&chip->irq_lock);\r\n}\r\nstatic void pca953x_irq_bus_sync_unlock(struct irq_data *d)\r\n{\r\nstruct pca953x_chip *chip = irq_data_get_irq_chip_data(d);\r\nu32 new_irqs;\r\nu32 level;\r\nnew_irqs = chip->irq_trig_fall | chip->irq_trig_raise;\r\nnew_irqs &= ~chip->reg_direction;\r\nwhile (new_irqs) {\r\nlevel = __ffs(new_irqs);\r\npca953x_gpio_direction_input(&chip->gpio_chip, level);\r\nnew_irqs &= ~(1 << level);\r\n}\r\nmutex_unlock(&chip->irq_lock);\r\n}\r\nstatic int pca953x_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct pca953x_chip *chip = irq_data_get_irq_chip_data(d);\r\nu32 level = d->irq - chip->irq_base;\r\nu32 mask = 1 << level;\r\nif (!(type & IRQ_TYPE_EDGE_BOTH)) {\r\ndev_err(&chip->client->dev, "irq %d: unsupported type %d\n",\r\nd->irq, type);\r\nreturn -EINVAL;\r\n}\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nchip->irq_trig_fall |= mask;\r\nelse\r\nchip->irq_trig_fall &= ~mask;\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nchip->irq_trig_raise |= mask;\r\nelse\r\nchip->irq_trig_raise &= ~mask;\r\nreturn 0;\r\n}\r\nstatic u32 pca953x_irq_pending(struct pca953x_chip *chip)\r\n{\r\nu32 cur_stat;\r\nu32 old_stat;\r\nu32 pending;\r\nu32 trigger;\r\nint ret, offset = 0;\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_INPUT;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_IN;\r\nbreak;\r\n}\r\nret = pca953x_read_reg(chip, offset, &cur_stat);\r\nif (ret)\r\nreturn 0;\r\ncur_stat &= chip->reg_direction;\r\nold_stat = chip->irq_stat;\r\ntrigger = (cur_stat ^ old_stat) & chip->irq_mask;\r\nif (!trigger)\r\nreturn 0;\r\nchip->irq_stat = cur_stat;\r\npending = (old_stat & chip->irq_trig_fall) |\r\n(cur_stat & chip->irq_trig_raise);\r\npending &= trigger;\r\nreturn pending;\r\n}\r\nstatic irqreturn_t pca953x_irq_handler(int irq, void *devid)\r\n{\r\nstruct pca953x_chip *chip = devid;\r\nu32 pending;\r\nu32 level;\r\npending = pca953x_irq_pending(chip);\r\nif (!pending)\r\nreturn IRQ_HANDLED;\r\ndo {\r\nlevel = __ffs(pending);\r\nhandle_nested_irq(level + chip->irq_base);\r\npending &= ~(1 << level);\r\n} while (pending);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pca953x_irq_setup(struct pca953x_chip *chip,\r\nconst struct i2c_device_id *id,\r\nint irq_base)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nint ret, offset = 0;\r\nu32 temporary;\r\nif (irq_base != -1\r\n&& (id->driver_data & PCA_INT)) {\r\nint lvl;\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_INPUT;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_IN;\r\nbreak;\r\n}\r\nret = pca953x_read_reg(chip, offset, &temporary);\r\nchip->irq_stat = temporary;\r\nif (ret)\r\ngoto out_failed;\r\nchip->irq_stat &= chip->reg_direction;\r\nmutex_init(&chip->irq_lock);\r\nchip->irq_base = irq_alloc_descs(-1, irq_base, chip->gpio_chip.ngpio, -1);\r\nif (chip->irq_base < 0)\r\ngoto out_failed;\r\nfor (lvl = 0; lvl < chip->gpio_chip.ngpio; lvl++) {\r\nint irq = lvl + chip->irq_base;\r\nirq_clear_status_flags(irq, IRQ_NOREQUEST);\r\nirq_set_chip_data(irq, chip);\r\nirq_set_chip(irq, &pca953x_irq_chip);\r\nirq_set_nested_thread(irq, true);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(irq);\r\n#endif\r\n}\r\nret = request_threaded_irq(client->irq,\r\nNULL,\r\npca953x_irq_handler,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\ndev_name(&client->dev), chip);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to request irq %d\n",\r\nclient->irq);\r\ngoto out_failed;\r\n}\r\nchip->gpio_chip.to_irq = pca953x_gpio_to_irq;\r\n}\r\nreturn 0;\r\nout_failed:\r\nchip->irq_base = -1;\r\nreturn ret;\r\n}\r\nstatic void pca953x_irq_teardown(struct pca953x_chip *chip)\r\n{\r\nif (chip->irq_base != -1) {\r\nirq_free_descs(chip->irq_base, chip->gpio_chip.ngpio);\r\nfree_irq(chip->client->irq, chip);\r\n}\r\n}\r\nstatic int pca953x_irq_setup(struct pca953x_chip *chip,\r\nconst struct i2c_device_id *id,\r\nint irq_base)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nif (irq_base != -1 && (id->driver_data & PCA_INT))\r\ndev_warn(&client->dev, "interrupt support not compiled in\n");\r\nreturn 0;\r\n}\r\nstatic void pca953x_irq_teardown(struct pca953x_chip *chip)\r\n{\r\n}\r\nstatic void\r\npca953x_get_alt_pdata(struct i2c_client *client, int *gpio_base, u32 *invert)\r\n{\r\nstruct device_node *node;\r\nconst __be32 *val;\r\nint size;\r\nnode = client->dev.of_node;\r\nif (node == NULL)\r\nreturn;\r\n*gpio_base = -1;\r\nval = of_get_property(node, "linux,gpio-base", &size);\r\nWARN(val, "%s: device-tree property 'linux,gpio-base' is deprecated!", __func__);\r\nif (val) {\r\nif (size != sizeof(*val))\r\ndev_warn(&client->dev, "%s: wrong linux,gpio-base\n",\r\nnode->full_name);\r\nelse\r\n*gpio_base = be32_to_cpup(val);\r\n}\r\nval = of_get_property(node, "polarity", NULL);\r\nWARN(val, "%s: device-tree property 'polarity' is deprecated!", __func__);\r\nif (val)\r\n*invert = *val;\r\n}\r\nstatic void\r\npca953x_get_alt_pdata(struct i2c_client *client, int *gpio_base, u32 *invert)\r\n{\r\n*gpio_base = -1;\r\n}\r\nstatic int __devinit device_pca953x_init(struct pca953x_chip *chip, u32 invert)\r\n{\r\nint ret;\r\nret = pca953x_read_reg(chip, PCA953X_OUTPUT, &chip->reg_output);\r\nif (ret)\r\ngoto out;\r\nret = pca953x_read_reg(chip, PCA953X_DIRECTION,\r\n&chip->reg_direction);\r\nif (ret)\r\ngoto out;\r\nret = pca953x_write_reg(chip, PCA953X_INVERT, invert);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __devinit device_pca957x_init(struct pca953x_chip *chip, u32 invert)\r\n{\r\nint ret;\r\nu32 val = 0;\r\npca953x_write_reg(chip, PCA957X_PUPD, 0x0);\r\npca953x_write_reg(chip, PCA957X_CFG, 0xffff);\r\npca953x_write_reg(chip, PCA957X_OUT, 0x0);\r\nret = pca953x_read_reg(chip, PCA957X_IN, &val);\r\nif (ret)\r\ngoto out;\r\nret = pca953x_read_reg(chip, PCA957X_OUT, &chip->reg_output);\r\nif (ret)\r\ngoto out;\r\nret = pca953x_read_reg(chip, PCA957X_CFG, &chip->reg_direction);\r\nif (ret)\r\ngoto out;\r\npca953x_write_reg(chip, PCA957X_INVRT, invert);\r\npca953x_write_reg(chip, PCA957X_BKEN, 0x202);\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __devinit pca953x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pca953x_platform_data *pdata;\r\nstruct pca953x_chip *chip;\r\nint irq_base = 0;\r\nint ret;\r\nu32 invert = 0;\r\nchip = kzalloc(sizeof(struct pca953x_chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\npdata = client->dev.platform_data;\r\nif (pdata) {\r\nirq_base = pdata->irq_base;\r\nchip->gpio_start = pdata->gpio_base;\r\ninvert = pdata->invert;\r\nchip->names = pdata->names;\r\n} else {\r\npca953x_get_alt_pdata(client, &chip->gpio_start, &invert);\r\n#ifdef CONFIG_OF_GPIO\r\nif (of_find_property(client->dev.of_node, "interrupts", NULL) == NULL)\r\nirq_base = -1;\r\n#endif\r\n}\r\nchip->client = client;\r\nchip->chip_type = id->driver_data & (PCA953X_TYPE | PCA957X_TYPE);\r\nmutex_init(&chip->i2c_lock);\r\npca953x_setup_gpio(chip, id->driver_data & PCA_GPIO_MASK);\r\nif (chip->chip_type == PCA953X_TYPE)\r\nret = device_pca953x_init(chip, invert);\r\nelse\r\nret = device_pca957x_init(chip, invert);\r\nif (ret)\r\ngoto out_failed;\r\nret = pca953x_irq_setup(chip, id, irq_base);\r\nif (ret)\r\ngoto out_failed;\r\nret = gpiochip_add(&chip->gpio_chip);\r\nif (ret)\r\ngoto out_failed_irq;\r\nif (pdata && pdata->setup) {\r\nret = pdata->setup(client, chip->gpio_chip.base,\r\nchip->gpio_chip.ngpio, pdata->context);\r\nif (ret < 0)\r\ndev_warn(&client->dev, "setup failed, %d\n", ret);\r\n}\r\ni2c_set_clientdata(client, chip);\r\nreturn 0;\r\nout_failed_irq:\r\npca953x_irq_teardown(chip);\r\nout_failed:\r\nkfree(chip);\r\nreturn ret;\r\n}\r\nstatic int pca953x_remove(struct i2c_client *client)\r\n{\r\nstruct pca953x_platform_data *pdata = client->dev.platform_data;\r\nstruct pca953x_chip *chip = i2c_get_clientdata(client);\r\nint ret = 0;\r\nif (pdata && pdata->teardown) {\r\nret = pdata->teardown(client, chip->gpio_chip.base,\r\nchip->gpio_chip.ngpio, pdata->context);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "%s failed, %d\n",\r\n"teardown", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = gpiochip_remove(&chip->gpio_chip);\r\nif (ret) {\r\ndev_err(&client->dev, "%s failed, %d\n",\r\n"gpiochip_remove()", ret);\r\nreturn ret;\r\n}\r\npca953x_irq_teardown(chip);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int __init pca953x_init(void)\r\n{\r\nreturn i2c_add_driver(&pca953x_driver);\r\n}\r\nstatic void __exit pca953x_exit(void)\r\n{\r\ni2c_del_driver(&pca953x_driver);\r\n}
