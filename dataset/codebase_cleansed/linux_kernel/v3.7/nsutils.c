void\r\nacpi_ns_print_node_pathname(struct acpi_namespace_node *node,\r\nconst char *message)\r\n{\r\nstruct acpi_buffer buffer;\r\nacpi_status status;\r\nif (!node) {\r\nacpi_os_printf("[NULL NAME]");\r\nreturn;\r\n}\r\nbuffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\r\nstatus = acpi_ns_handle_to_pathname(node, &buffer);\r\nif (ACPI_SUCCESS(status)) {\r\nif (message) {\r\nacpi_os_printf("%s ", message);\r\n}\r\nacpi_os_printf("[%s] (Node %p)", (char *)buffer.pointer, node);\r\nACPI_FREE(buffer.pointer);\r\n}\r\n}\r\nu8 acpi_ns_valid_root_prefix(char prefix)\r\n{\r\nreturn ((u8) (prefix == '\\'));\r\n}\r\nstatic u8 acpi_ns_valid_path_separator(char sep)\r\n{\r\nreturn ((u8) (sep == '.'));\r\n}\r\nacpi_object_type acpi_ns_get_type(struct acpi_namespace_node * node)\r\n{\r\nACPI_FUNCTION_TRACE(ns_get_type);\r\nif (!node) {\r\nACPI_WARNING((AE_INFO, "Null Node parameter"));\r\nreturn_UINT32(ACPI_TYPE_ANY);\r\n}\r\nreturn_UINT32((acpi_object_type) node->type);\r\n}\r\nu32 acpi_ns_local(acpi_object_type type)\r\n{\r\nACPI_FUNCTION_TRACE(ns_local);\r\nif (!acpi_ut_valid_object_type(type)) {\r\nACPI_WARNING((AE_INFO, "Invalid Object Type 0x%X", type));\r\nreturn_UINT32(ACPI_NS_NORMAL);\r\n}\r\nreturn_UINT32((u32) acpi_gbl_ns_properties[type] & ACPI_NS_LOCAL);\r\n}\r\nvoid acpi_ns_get_internal_name_length(struct acpi_namestring_info *info)\r\n{\r\nconst char *next_external_char;\r\nu32 i;\r\nACPI_FUNCTION_ENTRY();\r\nnext_external_char = info->external_name;\r\ninfo->num_carats = 0;\r\ninfo->num_segments = 0;\r\ninfo->fully_qualified = FALSE;\r\nif (acpi_ns_valid_root_prefix(*next_external_char)) {\r\ninfo->fully_qualified = TRUE;\r\nnext_external_char++;\r\nwhile (acpi_ns_valid_root_prefix(*next_external_char)) {\r\nnext_external_char++;\r\n}\r\n} else {\r\nwhile (*next_external_char == '^') {\r\ninfo->num_carats++;\r\nnext_external_char++;\r\n}\r\n}\r\nif (*next_external_char) {\r\ninfo->num_segments = 1;\r\nfor (i = 0; next_external_char[i]; i++) {\r\nif (acpi_ns_valid_path_separator(next_external_char[i])) {\r\ninfo->num_segments++;\r\n}\r\n}\r\n}\r\ninfo->length = (ACPI_NAME_SIZE * info->num_segments) +\r\n4 + info->num_carats;\r\ninfo->next_external_char = next_external_char;\r\n}\r\nacpi_status acpi_ns_build_internal_name(struct acpi_namestring_info *info)\r\n{\r\nu32 num_segments = info->num_segments;\r\nchar *internal_name = info->internal_name;\r\nconst char *external_name = info->next_external_char;\r\nchar *result = NULL;\r\nu32 i;\r\nACPI_FUNCTION_TRACE(ns_build_internal_name);\r\nif (info->fully_qualified) {\r\ninternal_name[0] = '\\';\r\nif (num_segments <= 1) {\r\nresult = &internal_name[1];\r\n} else if (num_segments == 2) {\r\ninternal_name[1] = AML_DUAL_NAME_PREFIX;\r\nresult = &internal_name[2];\r\n} else {\r\ninternal_name[1] = AML_MULTI_NAME_PREFIX_OP;\r\ninternal_name[2] = (char)num_segments;\r\nresult = &internal_name[3];\r\n}\r\n} else {\r\ni = 0;\r\nif (info->num_carats) {\r\nfor (i = 0; i < info->num_carats; i++) {\r\ninternal_name[i] = '^';\r\n}\r\n}\r\nif (num_segments <= 1) {\r\nresult = &internal_name[i];\r\n} else if (num_segments == 2) {\r\ninternal_name[i] = AML_DUAL_NAME_PREFIX;\r\nresult = &internal_name[(acpi_size) i + 1];\r\n} else {\r\ninternal_name[i] = AML_MULTI_NAME_PREFIX_OP;\r\ninternal_name[(acpi_size) i + 1] = (char)num_segments;\r\nresult = &internal_name[(acpi_size) i + 2];\r\n}\r\n}\r\nfor (; num_segments; num_segments--) {\r\nfor (i = 0; i < ACPI_NAME_SIZE; i++) {\r\nif (acpi_ns_valid_path_separator(*external_name) ||\r\n(*external_name == 0)) {\r\nresult[i] = '_';\r\n} else {\r\nresult[i] =\r\n(char)ACPI_TOUPPER((int)*external_name);\r\nexternal_name++;\r\n}\r\n}\r\nif (!acpi_ns_valid_path_separator(*external_name) &&\r\n(*external_name != 0)) {\r\nreturn_ACPI_STATUS(AE_BAD_PATHNAME);\r\n}\r\nexternal_name++;\r\nresult += ACPI_NAME_SIZE;\r\n}\r\n*result = 0;\r\nif (info->fully_qualified) {\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Returning [%p] (abs) \"\\%s\"\n",\r\ninternal_name, internal_name));\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Returning [%p] (rel) \"%s\"\n",\r\ninternal_name, internal_name));\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ns_internalize_name(const char *external_name, char **converted_name)\r\n{\r\nchar *internal_name;\r\nstruct acpi_namestring_info info;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ns_internalize_name);\r\nif ((!external_name) || (*external_name == 0) || (!converted_name)) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\ninfo.external_name = external_name;\r\nacpi_ns_get_internal_name_length(&info);\r\ninternal_name = ACPI_ALLOCATE_ZEROED(info.length);\r\nif (!internal_name) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\ninfo.internal_name = internal_name;\r\nstatus = acpi_ns_build_internal_name(&info);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_FREE(internal_name);\r\nreturn_ACPI_STATUS(status);\r\n}\r\n*converted_name = internal_name;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ns_externalize_name(u32 internal_name_length,\r\nconst char *internal_name,\r\nu32 * converted_name_length, char **converted_name)\r\n{\r\nu32 names_index = 0;\r\nu32 num_segments = 0;\r\nu32 required_length;\r\nu32 prefix_length = 0;\r\nu32 i = 0;\r\nu32 j = 0;\r\nACPI_FUNCTION_TRACE(ns_externalize_name);\r\nif (!internal_name_length || !internal_name || !converted_name) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nswitch (internal_name[0]) {\r\ncase '\\':\r\nprefix_length = 1;\r\nbreak;\r\ncase '^':\r\nfor (i = 0; i < internal_name_length; i++) {\r\nif (internal_name[i] == '^') {\r\nprefix_length = i + 1;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nif (i == internal_name_length) {\r\nprefix_length = i;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (prefix_length < internal_name_length) {\r\nswitch (internal_name[prefix_length]) {\r\ncase AML_MULTI_NAME_PREFIX_OP:\r\nnames_index = prefix_length + 2;\r\nnum_segments = (u8)\r\ninternal_name[(acpi_size) prefix_length + 1];\r\nbreak;\r\ncase AML_DUAL_NAME_PREFIX:\r\nnames_index = prefix_length + 1;\r\nnum_segments = 2;\r\nbreak;\r\ncase 0:\r\nnames_index = 0;\r\nnum_segments = 0;\r\nbreak;\r\ndefault:\r\nnames_index = prefix_length;\r\nnum_segments = 1;\r\nbreak;\r\n}\r\n}\r\nrequired_length = prefix_length + (4 * num_segments) +\r\n((num_segments > 0) ? (num_segments - 1) : 0) + 1;\r\nif (required_length > internal_name_length) {\r\nACPI_ERROR((AE_INFO, "Invalid internal name"));\r\nreturn_ACPI_STATUS(AE_BAD_PATHNAME);\r\n}\r\n*converted_name = ACPI_ALLOCATE_ZEROED(required_length);\r\nif (!(*converted_name)) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nj = 0;\r\nfor (i = 0; i < prefix_length; i++) {\r\n(*converted_name)[j++] = internal_name[i];\r\n}\r\nif (num_segments > 0) {\r\nfor (i = 0; i < num_segments; i++) {\r\nif (i > 0) {\r\n(*converted_name)[j++] = '.';\r\n}\r\n(*converted_name)[j++] = internal_name[names_index++];\r\n(*converted_name)[j++] = internal_name[names_index++];\r\n(*converted_name)[j++] = internal_name[names_index++];\r\n(*converted_name)[j++] = internal_name[names_index++];\r\n}\r\n}\r\nif (converted_name_length) {\r\n*converted_name_length = (u32) required_length;\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nstruct acpi_namespace_node *acpi_ns_validate_handle(acpi_handle handle)\r\n{\r\nACPI_FUNCTION_ENTRY();\r\nif ((!handle) || (handle == ACPI_ROOT_OBJECT)) {\r\nreturn (acpi_gbl_root_node);\r\n}\r\nif (ACPI_GET_DESCRIPTOR_TYPE(handle) != ACPI_DESC_TYPE_NAMED) {\r\nreturn (NULL);\r\n}\r\nreturn (ACPI_CAST_PTR(struct acpi_namespace_node, handle));\r\n}\r\nvoid acpi_ns_terminate(void)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nACPI_FUNCTION_TRACE(ns_terminate);\r\nacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\r\nobj_desc = acpi_ns_get_attached_object(acpi_gbl_root_node);\r\nif (obj_desc) {\r\nacpi_ns_detach_object(acpi_gbl_root_node);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Namespace freed\n"));\r\nreturn_VOID;\r\n}\r\nu32 acpi_ns_opens_scope(acpi_object_type type)\r\n{\r\nACPI_FUNCTION_TRACE_STR(ns_opens_scope, acpi_ut_get_type_name(type));\r\nif (!acpi_ut_valid_object_type(type)) {\r\nACPI_WARNING((AE_INFO, "Invalid Object Type 0x%X", type));\r\nreturn_UINT32(ACPI_NS_NORMAL);\r\n}\r\nreturn_UINT32(((u32) acpi_gbl_ns_properties[type]) & ACPI_NS_NEWSCOPE);\r\n}\r\nacpi_status\r\nacpi_ns_get_node(struct acpi_namespace_node *prefix_node,\r\nconst char *pathname,\r\nu32 flags, struct acpi_namespace_node **return_node)\r\n{\r\nunion acpi_generic_state scope_info;\r\nacpi_status status;\r\nchar *internal_path;\r\nACPI_FUNCTION_TRACE_PTR(ns_get_node, ACPI_CAST_PTR(char, pathname));\r\nif (!pathname) {\r\n*return_node = prefix_node;\r\nif (!prefix_node) {\r\n*return_node = acpi_gbl_root_node;\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nstatus = acpi_ns_internalize_name(pathname, &internal_path);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\ngoto cleanup;\r\n}\r\nscope_info.scope.node = prefix_node;\r\nstatus = acpi_ns_lookup(&scope_info, internal_path, ACPI_TYPE_ANY,\r\nACPI_IMODE_EXECUTE,\r\n(flags | ACPI_NS_DONT_OPEN_SCOPE), NULL,\r\nreturn_node);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC, "%s, %s\n",\r\npathname, acpi_format_exception(status)));\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\ncleanup:\r\nACPI_FREE(internal_path);\r\nreturn_ACPI_STATUS(status);\r\n}
