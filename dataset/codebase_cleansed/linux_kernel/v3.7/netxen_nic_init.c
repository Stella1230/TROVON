static void crb_addr_transform_setup(void)\r\n{\r\ncrb_addr_transform(XDMA);\r\ncrb_addr_transform(TIMR);\r\ncrb_addr_transform(SRE);\r\ncrb_addr_transform(SQN3);\r\ncrb_addr_transform(SQN2);\r\ncrb_addr_transform(SQN1);\r\ncrb_addr_transform(SQN0);\r\ncrb_addr_transform(SQS3);\r\ncrb_addr_transform(SQS2);\r\ncrb_addr_transform(SQS1);\r\ncrb_addr_transform(SQS0);\r\ncrb_addr_transform(RPMX7);\r\ncrb_addr_transform(RPMX6);\r\ncrb_addr_transform(RPMX5);\r\ncrb_addr_transform(RPMX4);\r\ncrb_addr_transform(RPMX3);\r\ncrb_addr_transform(RPMX2);\r\ncrb_addr_transform(RPMX1);\r\ncrb_addr_transform(RPMX0);\r\ncrb_addr_transform(ROMUSB);\r\ncrb_addr_transform(SN);\r\ncrb_addr_transform(QMN);\r\ncrb_addr_transform(QMS);\r\ncrb_addr_transform(PGNI);\r\ncrb_addr_transform(PGND);\r\ncrb_addr_transform(PGN3);\r\ncrb_addr_transform(PGN2);\r\ncrb_addr_transform(PGN1);\r\ncrb_addr_transform(PGN0);\r\ncrb_addr_transform(PGSI);\r\ncrb_addr_transform(PGSD);\r\ncrb_addr_transform(PGS3);\r\ncrb_addr_transform(PGS2);\r\ncrb_addr_transform(PGS1);\r\ncrb_addr_transform(PGS0);\r\ncrb_addr_transform(PS);\r\ncrb_addr_transform(PH);\r\ncrb_addr_transform(NIU);\r\ncrb_addr_transform(I2Q);\r\ncrb_addr_transform(EG);\r\ncrb_addr_transform(MN);\r\ncrb_addr_transform(MS);\r\ncrb_addr_transform(CAS2);\r\ncrb_addr_transform(CAS1);\r\ncrb_addr_transform(CAS0);\r\ncrb_addr_transform(CAM);\r\ncrb_addr_transform(C2C1);\r\ncrb_addr_transform(C2C0);\r\ncrb_addr_transform(SMB);\r\ncrb_addr_transform(OCM0);\r\ncrb_addr_transform(I2C0);\r\n}\r\nvoid netxen_release_rx_buffers(struct netxen_adapter *adapter)\r\n{\r\nstruct netxen_recv_context *recv_ctx;\r\nstruct nx_host_rds_ring *rds_ring;\r\nstruct netxen_rx_buffer *rx_buf;\r\nint i, ring;\r\nrecv_ctx = &adapter->recv_ctx;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nfor (i = 0; i < rds_ring->num_desc; ++i) {\r\nrx_buf = &(rds_ring->rx_buf_arr[i]);\r\nif (rx_buf->state == NETXEN_BUFFER_FREE)\r\ncontinue;\r\npci_unmap_single(adapter->pdev,\r\nrx_buf->dma,\r\nrds_ring->dma_size,\r\nPCI_DMA_FROMDEVICE);\r\nif (rx_buf->skb != NULL)\r\ndev_kfree_skb_any(rx_buf->skb);\r\n}\r\n}\r\n}\r\nvoid netxen_release_tx_buffers(struct netxen_adapter *adapter)\r\n{\r\nstruct netxen_cmd_buffer *cmd_buf;\r\nstruct netxen_skb_frag *buffrag;\r\nint i, j;\r\nstruct nx_host_tx_ring *tx_ring = adapter->tx_ring;\r\ncmd_buf = tx_ring->cmd_buf_arr;\r\nfor (i = 0; i < tx_ring->num_desc; i++) {\r\nbuffrag = cmd_buf->frag_array;\r\nif (buffrag->dma) {\r\npci_unmap_single(adapter->pdev, buffrag->dma,\r\nbuffrag->length, PCI_DMA_TODEVICE);\r\nbuffrag->dma = 0ULL;\r\n}\r\nfor (j = 0; j < cmd_buf->frag_count; j++) {\r\nbuffrag++;\r\nif (buffrag->dma) {\r\npci_unmap_page(adapter->pdev, buffrag->dma,\r\nbuffrag->length,\r\nPCI_DMA_TODEVICE);\r\nbuffrag->dma = 0ULL;\r\n}\r\n}\r\nif (cmd_buf->skb) {\r\ndev_kfree_skb_any(cmd_buf->skb);\r\ncmd_buf->skb = NULL;\r\n}\r\ncmd_buf++;\r\n}\r\n}\r\nvoid netxen_free_sw_resources(struct netxen_adapter *adapter)\r\n{\r\nstruct netxen_recv_context *recv_ctx;\r\nstruct nx_host_rds_ring *rds_ring;\r\nstruct nx_host_tx_ring *tx_ring;\r\nint ring;\r\nrecv_ctx = &adapter->recv_ctx;\r\nif (recv_ctx->rds_rings == NULL)\r\ngoto skip_rds;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nvfree(rds_ring->rx_buf_arr);\r\nrds_ring->rx_buf_arr = NULL;\r\n}\r\nkfree(recv_ctx->rds_rings);\r\nskip_rds:\r\nif (adapter->tx_ring == NULL)\r\nreturn;\r\ntx_ring = adapter->tx_ring;\r\nvfree(tx_ring->cmd_buf_arr);\r\nkfree(tx_ring);\r\nadapter->tx_ring = NULL;\r\n}\r\nint netxen_alloc_sw_resources(struct netxen_adapter *adapter)\r\n{\r\nstruct netxen_recv_context *recv_ctx;\r\nstruct nx_host_rds_ring *rds_ring;\r\nstruct nx_host_sds_ring *sds_ring;\r\nstruct nx_host_tx_ring *tx_ring;\r\nstruct netxen_rx_buffer *rx_buf;\r\nint ring, i, size;\r\nstruct netxen_cmd_buffer *cmd_buf_arr;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nsize = sizeof(struct nx_host_tx_ring);\r\ntx_ring = kzalloc(size, GFP_KERNEL);\r\nif (tx_ring == NULL) {\r\ndev_err(&pdev->dev, "%s: failed to allocate tx ring struct\n",\r\nnetdev->name);\r\nreturn -ENOMEM;\r\n}\r\nadapter->tx_ring = tx_ring;\r\ntx_ring->num_desc = adapter->num_txd;\r\ntx_ring->txq = netdev_get_tx_queue(netdev, 0);\r\ncmd_buf_arr = vzalloc(TX_BUFF_RINGSIZE(tx_ring));\r\nif (cmd_buf_arr == NULL) {\r\ndev_err(&pdev->dev, "%s: failed to allocate cmd buffer ring\n",\r\nnetdev->name);\r\ngoto err_out;\r\n}\r\ntx_ring->cmd_buf_arr = cmd_buf_arr;\r\nrecv_ctx = &adapter->recv_ctx;\r\nsize = adapter->max_rds_rings * sizeof (struct nx_host_rds_ring);\r\nrds_ring = kzalloc(size, GFP_KERNEL);\r\nif (rds_ring == NULL) {\r\ndev_err(&pdev->dev, "%s: failed to allocate rds ring struct\n",\r\nnetdev->name);\r\ngoto err_out;\r\n}\r\nrecv_ctx->rds_rings = rds_ring;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nswitch (ring) {\r\ncase RCV_RING_NORMAL:\r\nrds_ring->num_desc = adapter->num_rxd;\r\nif (adapter->ahw.cut_through) {\r\nrds_ring->dma_size =\r\nNX_CT_DEFAULT_RX_BUF_LEN;\r\nrds_ring->skb_size =\r\nNX_CT_DEFAULT_RX_BUF_LEN;\r\n} else {\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nrds_ring->dma_size =\r\nNX_P3_RX_BUF_MAX_LEN;\r\nelse\r\nrds_ring->dma_size =\r\nNX_P2_RX_BUF_MAX_LEN;\r\nrds_ring->skb_size =\r\nrds_ring->dma_size + NET_IP_ALIGN;\r\n}\r\nbreak;\r\ncase RCV_RING_JUMBO:\r\nrds_ring->num_desc = adapter->num_jumbo_rxd;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nrds_ring->dma_size =\r\nNX_P3_RX_JUMBO_BUF_MAX_LEN;\r\nelse\r\nrds_ring->dma_size =\r\nNX_P2_RX_JUMBO_BUF_MAX_LEN;\r\nif (adapter->capabilities & NX_CAP0_HW_LRO)\r\nrds_ring->dma_size += NX_LRO_BUFFER_EXTRA;\r\nrds_ring->skb_size =\r\nrds_ring->dma_size + NET_IP_ALIGN;\r\nbreak;\r\ncase RCV_RING_LRO:\r\nrds_ring->num_desc = adapter->num_lro_rxd;\r\nrds_ring->dma_size = NX_RX_LRO_BUFFER_LENGTH;\r\nrds_ring->skb_size = rds_ring->dma_size + NET_IP_ALIGN;\r\nbreak;\r\n}\r\nrds_ring->rx_buf_arr = vzalloc(RCV_BUFF_RINGSIZE(rds_ring));\r\nif (rds_ring->rx_buf_arr == NULL)\r\ngoto err_out;\r\nINIT_LIST_HEAD(&rds_ring->free_list);\r\nrx_buf = rds_ring->rx_buf_arr;\r\nfor (i = 0; i < rds_ring->num_desc; i++) {\r\nlist_add_tail(&rx_buf->list,\r\n&rds_ring->free_list);\r\nrx_buf->ref_handle = i;\r\nrx_buf->state = NETXEN_BUFFER_FREE;\r\nrx_buf++;\r\n}\r\nspin_lock_init(&rds_ring->lock);\r\n}\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nsds_ring->irq = adapter->msix_entries[ring].vector;\r\nsds_ring->adapter = adapter;\r\nsds_ring->num_desc = adapter->num_rxd;\r\nfor (i = 0; i < NUM_RCV_DESC_RINGS; i++)\r\nINIT_LIST_HEAD(&sds_ring->free_list[i]);\r\n}\r\nreturn 0;\r\nerr_out:\r\nnetxen_free_sw_resources(adapter);\r\nreturn -ENOMEM;\r\n}\r\nstatic u32 netxen_decode_crb_addr(u32 addr)\r\n{\r\nint i;\r\nu32 base_addr, offset, pci_base;\r\ncrb_addr_transform_setup();\r\npci_base = NETXEN_ADDR_ERROR;\r\nbase_addr = addr & 0xfff00000;\r\noffset = addr & 0x000fffff;\r\nfor (i = 0; i < NETXEN_MAX_CRB_XFORM; i++) {\r\nif (crb_addr_xform[i] == base_addr) {\r\npci_base = i << 20;\r\nbreak;\r\n}\r\n}\r\nif (pci_base == NETXEN_ADDR_ERROR)\r\nreturn pci_base;\r\nelse\r\nreturn pci_base + offset;\r\n}\r\nstatic int netxen_wait_rom_done(struct netxen_adapter *adapter)\r\n{\r\nlong timeout = 0;\r\nlong done = 0;\r\ncond_resched();\r\nwhile (done == 0) {\r\ndone = NXRD32(adapter, NETXEN_ROMUSB_GLB_STATUS);\r\ndone &= 2;\r\nif (++timeout >= NETXEN_MAX_ROM_WAIT_USEC) {\r\ndev_err(&adapter->pdev->dev,\r\n"Timeout reached waiting for rom done");\r\nreturn -EIO;\r\n}\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_rom_fast_read(struct netxen_adapter *adapter,\r\nint addr, int *valp)\r\n{\r\nNXWR32(adapter, NETXEN_ROMUSB_ROM_ADDRESS, addr);\r\nNXWR32(adapter, NETXEN_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\r\nNXWR32(adapter, NETXEN_ROMUSB_ROM_ABYTE_CNT, 3);\r\nNXWR32(adapter, NETXEN_ROMUSB_ROM_INSTR_OPCODE, 0xb);\r\nif (netxen_wait_rom_done(adapter)) {\r\nprintk("Error waiting for rom done\n");\r\nreturn -EIO;\r\n}\r\nNXWR32(adapter, NETXEN_ROMUSB_ROM_ABYTE_CNT, 0);\r\nudelay(10);\r\nNXWR32(adapter, NETXEN_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\r\n*valp = NXRD32(adapter, NETXEN_ROMUSB_ROM_RDATA);\r\nreturn 0;\r\n}\r\nstatic int do_rom_fast_read_words(struct netxen_adapter *adapter, int addr,\r\nu8 *bytes, size_t size)\r\n{\r\nint addridx;\r\nint ret = 0;\r\nfor (addridx = addr; addridx < (addr + size); addridx += 4) {\r\nint v;\r\nret = do_rom_fast_read(adapter, addridx, &v);\r\nif (ret != 0)\r\nbreak;\r\n*(__le32 *)bytes = cpu_to_le32(v);\r\nbytes += 4;\r\n}\r\nreturn ret;\r\n}\r\nint\r\nnetxen_rom_fast_read_words(struct netxen_adapter *adapter, int addr,\r\nu8 *bytes, size_t size)\r\n{\r\nint ret;\r\nret = netxen_rom_lock(adapter);\r\nif (ret < 0)\r\nreturn ret;\r\nret = do_rom_fast_read_words(adapter, addr, bytes, size);\r\nnetxen_rom_unlock(adapter);\r\nreturn ret;\r\n}\r\nint netxen_rom_fast_read(struct netxen_adapter *adapter, int addr, int *valp)\r\n{\r\nint ret;\r\nif (netxen_rom_lock(adapter) != 0)\r\nreturn -EIO;\r\nret = do_rom_fast_read(adapter, addr, valp);\r\nnetxen_rom_unlock(adapter);\r\nreturn ret;\r\n}\r\nint netxen_pinit_from_rom(struct netxen_adapter *adapter)\r\n{\r\nint addr, val;\r\nint i, n, init_delay = 0;\r\nstruct crb_addr_pair *buf;\r\nunsigned offset;\r\nu32 off;\r\nnetxen_rom_lock(adapter);\r\nNXWR32(adapter, NETXEN_ROMUSB_GLB_SW_RESET, 0xfeffffff);\r\nnetxen_rom_unlock(adapter);\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\nif (netxen_rom_fast_read(adapter, 0, &n) != 0 ||\r\n(n != 0xcafecafe) ||\r\nnetxen_rom_fast_read(adapter, 4, &n) != 0) {\r\nprintk(KERN_ERR "%s: ERROR Reading crb_init area: "\r\n"n: %08x\n", netxen_nic_driver_name, n);\r\nreturn -EIO;\r\n}\r\noffset = n & 0xffffU;\r\nn = (n >> 16) & 0xffffU;\r\n} else {\r\nif (netxen_rom_fast_read(adapter, 0, &n) != 0 ||\r\n!(n & 0x80000000)) {\r\nprintk(KERN_ERR "%s: ERROR Reading crb_init area: "\r\n"n: %08x\n", netxen_nic_driver_name, n);\r\nreturn -EIO;\r\n}\r\noffset = 1;\r\nn &= ~0x80000000;\r\n}\r\nif (n >= 1024) {\r\nprintk(KERN_ERR "%s:n=0x%x Error! NetXen card flash not"\r\n" initialized.\n", __func__, n);\r\nreturn -EIO;\r\n}\r\nbuf = kcalloc(n, sizeof(struct crb_addr_pair), GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < n; i++) {\r\nif (netxen_rom_fast_read(adapter, 8*i + 4*offset, &val) != 0 ||\r\nnetxen_rom_fast_read(adapter, 8*i + 4*offset + 4, &addr) != 0) {\r\nkfree(buf);\r\nreturn -EIO;\r\n}\r\nbuf[i].addr = addr;\r\nbuf[i].data = val;\r\n}\r\nfor (i = 0; i < n; i++) {\r\noff = netxen_decode_crb_addr(buf[i].addr);\r\nif (off == NETXEN_ADDR_ERROR) {\r\nprintk(KERN_ERR"CRB init value out of range %x\n",\r\nbuf[i].addr);\r\ncontinue;\r\n}\r\noff += NETXEN_PCI_CRBSPACE;\r\nif (off & 1)\r\ncontinue;\r\nif (off == NETXEN_CAM_RAM(0x1fc))\r\ncontinue;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\nif (off == (NETXEN_CRB_I2C0 + 0x1c))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xbc))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xa8))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xc8))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0x24))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0x1c))\r\ncontinue;\r\nif ((off & 0x0ff00000) == NETXEN_CRB_DDR_NET)\r\ncontinue;\r\nif (off == (NETXEN_CRB_PEG_NET_1 + 0x18) &&\r\n!NX_IS_REVISION_P3P(adapter->ahw.revision_id))\r\nbuf[i].data = 0x1020;\r\nif (off == NETXEN_PCIE_REG(PCIE_SETUP_FUNCTION))\r\ncontinue;\r\nif (off == NETXEN_PCIE_REG(PCIE_SETUP_FUNCTION2))\r\ncontinue;\r\nif ((off & 0x0ff00000) == NETXEN_CRB_SMB)\r\ncontinue;\r\n}\r\ninit_delay = 1;\r\nif (off == NETXEN_ROMUSB_GLB_SW_RESET) {\r\ninit_delay = 1000;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nbuf[i].data = NETXEN_NIC_XDMA_RESET;\r\nbuf[i].data = 0x8000ff;\r\n}\r\n}\r\nNXWR32(adapter, off, buf[i].data);\r\nmsleep(init_delay);\r\n}\r\nkfree(buf);\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nval = NXRD32(adapter, NETXEN_ROMUSB_GLB_SW_RESET);\r\nNXWR32(adapter, NETXEN_ROMUSB_GLB_SW_RESET, (val & 0xffffff0f));\r\n}\r\nNXWR32(adapter, NETXEN_CRB_PEG_NET_D + 0xec, 0x1e);\r\nNXWR32(adapter, NETXEN_CRB_PEG_NET_D + 0x4c, 8);\r\nNXWR32(adapter, NETXEN_CRB_PEG_NET_I + 0x4c, 8);\r\nNXWR32(adapter, NETXEN_CRB_PEG_NET_0 + 0x8, 0);\r\nNXWR32(adapter, NETXEN_CRB_PEG_NET_0 + 0xc, 0);\r\nNXWR32(adapter, NETXEN_CRB_PEG_NET_1 + 0x8, 0);\r\nNXWR32(adapter, NETXEN_CRB_PEG_NET_1 + 0xc, 0);\r\nNXWR32(adapter, NETXEN_CRB_PEG_NET_2 + 0x8, 0);\r\nNXWR32(adapter, NETXEN_CRB_PEG_NET_2 + 0xc, 0);\r\nNXWR32(adapter, NETXEN_CRB_PEG_NET_3 + 0x8, 0);\r\nNXWR32(adapter, NETXEN_CRB_PEG_NET_3 + 0xc, 0);\r\nreturn 0;\r\n}\r\nstatic struct uni_table_desc *nx_get_table_desc(const u8 *unirom, int section)\r\n{\r\nuint32_t i;\r\nstruct uni_table_desc *directory = (struct uni_table_desc *) &unirom[0];\r\n__le32 entries = cpu_to_le32(directory->num_entries);\r\nfor (i = 0; i < entries; i++) {\r\n__le32 offs = cpu_to_le32(directory->findex) +\r\n(i * cpu_to_le32(directory->entry_size));\r\n__le32 tab_type = cpu_to_le32(*((u32 *)&unirom[offs] + 8));\r\nif (tab_type == section)\r\nreturn (struct uni_table_desc *) &unirom[offs];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nnetxen_nic_validate_header(struct netxen_adapter *adapter)\r\n{\r\nconst u8 *unirom = adapter->fw->data;\r\nstruct uni_table_desc *directory = (struct uni_table_desc *) &unirom[0];\r\nu32 fw_file_size = adapter->fw->size;\r\nu32 tab_size;\r\n__le32 entries;\r\n__le32 entry_size;\r\nif (fw_file_size < QLCNIC_FILEHEADER_SIZE)\r\nreturn -EINVAL;\r\nentries = cpu_to_le32(directory->num_entries);\r\nentry_size = cpu_to_le32(directory->entry_size);\r\ntab_size = cpu_to_le32(directory->findex) + (entries * entry_size);\r\nif (fw_file_size < tab_size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_nic_validate_bootld(struct netxen_adapter *adapter)\r\n{\r\nstruct uni_table_desc *tab_desc;\r\nstruct uni_data_desc *descr;\r\nconst u8 *unirom = adapter->fw->data;\r\n__le32 idx = cpu_to_le32(*((int *)&unirom[adapter->file_prd_off] +\r\nNX_UNI_BOOTLD_IDX_OFF));\r\nu32 offs;\r\nu32 tab_size;\r\nu32 data_size;\r\ntab_desc = nx_get_table_desc(unirom, NX_UNI_DIR_SECT_BOOTLD);\r\nif (!tab_desc)\r\nreturn -EINVAL;\r\ntab_size = cpu_to_le32(tab_desc->findex) +\r\n(cpu_to_le32(tab_desc->entry_size) * (idx + 1));\r\nif (adapter->fw->size < tab_size)\r\nreturn -EINVAL;\r\noffs = cpu_to_le32(tab_desc->findex) +\r\n(cpu_to_le32(tab_desc->entry_size) * (idx));\r\ndescr = (struct uni_data_desc *)&unirom[offs];\r\ndata_size = cpu_to_le32(descr->findex) + cpu_to_le32(descr->size);\r\nif (adapter->fw->size < data_size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_nic_validate_fw(struct netxen_adapter *adapter)\r\n{\r\nstruct uni_table_desc *tab_desc;\r\nstruct uni_data_desc *descr;\r\nconst u8 *unirom = adapter->fw->data;\r\n__le32 idx = cpu_to_le32(*((int *)&unirom[adapter->file_prd_off] +\r\nNX_UNI_FIRMWARE_IDX_OFF));\r\nu32 offs;\r\nu32 tab_size;\r\nu32 data_size;\r\ntab_desc = nx_get_table_desc(unirom, NX_UNI_DIR_SECT_FW);\r\nif (!tab_desc)\r\nreturn -EINVAL;\r\ntab_size = cpu_to_le32(tab_desc->findex) +\r\n(cpu_to_le32(tab_desc->entry_size) * (idx + 1));\r\nif (adapter->fw->size < tab_size)\r\nreturn -EINVAL;\r\noffs = cpu_to_le32(tab_desc->findex) +\r\n(cpu_to_le32(tab_desc->entry_size) * (idx));\r\ndescr = (struct uni_data_desc *)&unirom[offs];\r\ndata_size = cpu_to_le32(descr->findex) + cpu_to_le32(descr->size);\r\nif (adapter->fw->size < data_size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_nic_validate_product_offs(struct netxen_adapter *adapter)\r\n{\r\nstruct uni_table_desc *ptab_descr;\r\nconst u8 *unirom = adapter->fw->data;\r\nint mn_present = (NX_IS_REVISION_P2(adapter->ahw.revision_id)) ?\r\n1 : netxen_p3_has_mn(adapter);\r\n__le32 entries;\r\n__le32 entry_size;\r\nu32 tab_size;\r\nu32 i;\r\nptab_descr = nx_get_table_desc(unirom, NX_UNI_DIR_SECT_PRODUCT_TBL);\r\nif (ptab_descr == NULL)\r\nreturn -EINVAL;\r\nentries = cpu_to_le32(ptab_descr->num_entries);\r\nentry_size = cpu_to_le32(ptab_descr->entry_size);\r\ntab_size = cpu_to_le32(ptab_descr->findex) + (entries * entry_size);\r\nif (adapter->fw->size < tab_size)\r\nreturn -EINVAL;\r\nnomn:\r\nfor (i = 0; i < entries; i++) {\r\n__le32 flags, file_chiprev, offs;\r\nu8 chiprev = adapter->ahw.revision_id;\r\nuint32_t flagbit;\r\noffs = cpu_to_le32(ptab_descr->findex) +\r\n(i * cpu_to_le32(ptab_descr->entry_size));\r\nflags = cpu_to_le32(*((int *)&unirom[offs] + NX_UNI_FLAGS_OFF));\r\nfile_chiprev = cpu_to_le32(*((int *)&unirom[offs] +\r\nNX_UNI_CHIP_REV_OFF));\r\nflagbit = mn_present ? 1 : 2;\r\nif ((chiprev == file_chiprev) &&\r\n((1ULL << flagbit) & flags)) {\r\nadapter->file_prd_off = offs;\r\nreturn 0;\r\n}\r\n}\r\nif (mn_present && NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\nmn_present = 0;\r\ngoto nomn;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnetxen_nic_validate_unified_romimage(struct netxen_adapter *adapter)\r\n{\r\nif (netxen_nic_validate_header(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"unified image: header validation failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (netxen_nic_validate_product_offs(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"unified image: product validation failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (netxen_nic_validate_bootld(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"unified image: bootld validation failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (netxen_nic_validate_fw(adapter)) {\r\ndev_err(&adapter->pdev->dev,\r\n"unified image: firmware validation failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct uni_data_desc *nx_get_data_desc(struct netxen_adapter *adapter,\r\nu32 section, u32 idx_offset)\r\n{\r\nconst u8 *unirom = adapter->fw->data;\r\nint idx = cpu_to_le32(*((int *)&unirom[adapter->file_prd_off] +\r\nidx_offset));\r\nstruct uni_table_desc *tab_desc;\r\n__le32 offs;\r\ntab_desc = nx_get_table_desc(unirom, section);\r\nif (tab_desc == NULL)\r\nreturn NULL;\r\noffs = cpu_to_le32(tab_desc->findex) +\r\n(cpu_to_le32(tab_desc->entry_size) * idx);\r\nreturn (struct uni_data_desc *)&unirom[offs];\r\n}\r\nstatic u8 *\r\nnx_get_bootld_offs(struct netxen_adapter *adapter)\r\n{\r\nu32 offs = NETXEN_BOOTLD_START;\r\nif (adapter->fw_type == NX_UNIFIED_ROMIMAGE)\r\noffs = cpu_to_le32((nx_get_data_desc(adapter,\r\nNX_UNI_DIR_SECT_BOOTLD,\r\nNX_UNI_BOOTLD_IDX_OFF))->findex);\r\nreturn (u8 *)&adapter->fw->data[offs];\r\n}\r\nstatic u8 *\r\nnx_get_fw_offs(struct netxen_adapter *adapter)\r\n{\r\nu32 offs = NETXEN_IMAGE_START;\r\nif (adapter->fw_type == NX_UNIFIED_ROMIMAGE)\r\noffs = cpu_to_le32((nx_get_data_desc(adapter,\r\nNX_UNI_DIR_SECT_FW,\r\nNX_UNI_FIRMWARE_IDX_OFF))->findex);\r\nreturn (u8 *)&adapter->fw->data[offs];\r\n}\r\nstatic __le32\r\nnx_get_fw_size(struct netxen_adapter *adapter)\r\n{\r\nif (adapter->fw_type == NX_UNIFIED_ROMIMAGE)\r\nreturn cpu_to_le32((nx_get_data_desc(adapter,\r\nNX_UNI_DIR_SECT_FW,\r\nNX_UNI_FIRMWARE_IDX_OFF))->size);\r\nelse\r\nreturn cpu_to_le32(\r\n*(u32 *)&adapter->fw->data[NX_FW_SIZE_OFFSET]);\r\n}\r\nstatic __le32\r\nnx_get_fw_version(struct netxen_adapter *adapter)\r\n{\r\nstruct uni_data_desc *fw_data_desc;\r\nconst struct firmware *fw = adapter->fw;\r\n__le32 major, minor, sub;\r\nconst u8 *ver_str;\r\nint i, ret = 0;\r\nif (adapter->fw_type == NX_UNIFIED_ROMIMAGE) {\r\nfw_data_desc = nx_get_data_desc(adapter,\r\nNX_UNI_DIR_SECT_FW, NX_UNI_FIRMWARE_IDX_OFF);\r\nver_str = fw->data + cpu_to_le32(fw_data_desc->findex) +\r\ncpu_to_le32(fw_data_desc->size) - 17;\r\nfor (i = 0; i < 12; i++) {\r\nif (!strncmp(&ver_str[i], "REV=", 4)) {\r\nret = sscanf(&ver_str[i+4], "%u.%u.%u ",\r\n&major, &minor, &sub);\r\nbreak;\r\n}\r\n}\r\nif (ret != 3)\r\nreturn 0;\r\nreturn major + (minor << 8) + (sub << 16);\r\n} else\r\nreturn cpu_to_le32(*(u32 *)&fw->data[NX_FW_VERSION_OFFSET]);\r\n}\r\nstatic __le32\r\nnx_get_bios_version(struct netxen_adapter *adapter)\r\n{\r\nconst struct firmware *fw = adapter->fw;\r\n__le32 bios_ver, prd_off = adapter->file_prd_off;\r\nif (adapter->fw_type == NX_UNIFIED_ROMIMAGE) {\r\nbios_ver = cpu_to_le32(*((u32 *) (&fw->data[prd_off])\r\n+ NX_UNI_BIOS_VERSION_OFF));\r\nreturn (bios_ver << 16) + ((bios_ver >> 8) & 0xff00) +\r\n(bios_ver >> 24);\r\n} else\r\nreturn cpu_to_le32(*(u32 *)&fw->data[NX_BIOS_VERSION_OFFSET]);\r\n}\r\nint\r\nnetxen_need_fw_reset(struct netxen_adapter *adapter)\r\n{\r\nu32 count, old_count;\r\nu32 val, version, major, minor, build;\r\nint i, timeout;\r\nu8 fw_type;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn 1;\r\nif (adapter->need_fw_reset)\r\nreturn 1;\r\nif (NXRD32(adapter, CRB_CMDPEG_STATE) == PHAN_INITIALIZE_FAILED)\r\nreturn 1;\r\nold_count = NXRD32(adapter, NETXEN_PEG_ALIVE_COUNTER);\r\nfor (i = 0; i < 10; i++) {\r\ntimeout = msleep_interruptible(200);\r\nif (timeout) {\r\nNXWR32(adapter, CRB_CMDPEG_STATE,\r\nPHAN_INITIALIZE_FAILED);\r\nreturn -EINTR;\r\n}\r\ncount = NXRD32(adapter, NETXEN_PEG_ALIVE_COUNTER);\r\nif (count != old_count)\r\nbreak;\r\n}\r\nif (count == old_count)\r\nreturn 1;\r\nif (adapter->fw) {\r\nval = nx_get_fw_version(adapter);\r\nversion = NETXEN_DECODE_VERSION(val);\r\nmajor = NXRD32(adapter, NETXEN_FW_VERSION_MAJOR);\r\nminor = NXRD32(adapter, NETXEN_FW_VERSION_MINOR);\r\nbuild = NXRD32(adapter, NETXEN_FW_VERSION_SUB);\r\nif (version > NETXEN_VERSION_CODE(major, minor, build))\r\nreturn 1;\r\nif (version == NETXEN_VERSION_CODE(major, minor, build) &&\r\nadapter->fw_type != NX_UNIFIED_ROMIMAGE) {\r\nval = NXRD32(adapter, NETXEN_MIU_MN_CONTROL);\r\nfw_type = (val & 0x4) ?\r\nNX_P3_CT_ROMIMAGE : NX_P3_MN_ROMIMAGE;\r\nif (adapter->fw_type != fw_type)\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnetxen_check_flash_fw_compatibility(struct netxen_adapter *adapter)\r\n{\r\nu32 flash_fw_ver, min_fw_ver;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn 0;\r\nif (netxen_rom_fast_read(adapter,\r\nNX_FW_VERSION_OFFSET, (int *)&flash_fw_ver)) {\r\ndev_err(&adapter->pdev->dev, "Unable to read flash fw"\r\n"version\n");\r\nreturn -EIO;\r\n}\r\nflash_fw_ver = NETXEN_DECODE_VERSION(flash_fw_ver);\r\nmin_fw_ver = NETXEN_MIN_P3_FW_SUPP;\r\nif (flash_fw_ver >= min_fw_ver)\r\nreturn 0;\r\ndev_info(&adapter->pdev->dev, "Flash fw[%d.%d.%d] is < min fw supported"\r\n"[4.0.505]. Please update firmware on flash\n",\r\n_major(flash_fw_ver), _minor(flash_fw_ver),\r\n_build(flash_fw_ver));\r\nreturn -EINVAL;\r\n}\r\nint\r\nnetxen_load_firmware(struct netxen_adapter *adapter)\r\n{\r\nu64 *ptr64;\r\nu32 i, flashaddr, size;\r\nconst struct firmware *fw = adapter->fw;\r\nstruct pci_dev *pdev = adapter->pdev;\r\ndev_info(&pdev->dev, "loading firmware from %s\n",\r\nfw_name[adapter->fw_type]);\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nNXWR32(adapter, NETXEN_ROMUSB_GLB_CAS_RST, 1);\r\nif (fw) {\r\n__le64 data;\r\nsize = (NETXEN_IMAGE_START - NETXEN_BOOTLD_START) / 8;\r\nptr64 = (u64 *)nx_get_bootld_offs(adapter);\r\nflashaddr = NETXEN_BOOTLD_START;\r\nfor (i = 0; i < size; i++) {\r\ndata = cpu_to_le64(ptr64[i]);\r\nif (adapter->pci_mem_write(adapter, flashaddr, data))\r\nreturn -EIO;\r\nflashaddr += 8;\r\n}\r\nsize = (__force u32)nx_get_fw_size(adapter) / 8;\r\nptr64 = (u64 *)nx_get_fw_offs(adapter);\r\nflashaddr = NETXEN_IMAGE_START;\r\nfor (i = 0; i < size; i++) {\r\ndata = cpu_to_le64(ptr64[i]);\r\nif (adapter->pci_mem_write(adapter,\r\nflashaddr, data))\r\nreturn -EIO;\r\nflashaddr += 8;\r\n}\r\nsize = (__force u32)nx_get_fw_size(adapter) % 8;\r\nif (size) {\r\ndata = cpu_to_le64(ptr64[i]);\r\nif (adapter->pci_mem_write(adapter,\r\nflashaddr, data))\r\nreturn -EIO;\r\n}\r\n} else {\r\nu64 data;\r\nu32 hi, lo;\r\nsize = (NETXEN_IMAGE_START - NETXEN_BOOTLD_START) / 8;\r\nflashaddr = NETXEN_BOOTLD_START;\r\nfor (i = 0; i < size; i++) {\r\nif (netxen_rom_fast_read(adapter,\r\nflashaddr, (int *)&lo) != 0)\r\nreturn -EIO;\r\nif (netxen_rom_fast_read(adapter,\r\nflashaddr + 4, (int *)&hi) != 0)\r\nreturn -EIO;\r\ndata = (((u64)hi << 32) | lo);\r\nif (adapter->pci_mem_write(adapter,\r\nflashaddr, data))\r\nreturn -EIO;\r\nflashaddr += 8;\r\n}\r\n}\r\nmsleep(1);\r\nif (NX_IS_REVISION_P3P(adapter->ahw.revision_id)) {\r\nNXWR32(adapter, NETXEN_CRB_PEG_NET_0 + 0x18, 0x1020);\r\nNXWR32(adapter, NETXEN_ROMUSB_GLB_SW_RESET, 0x80001e);\r\n} else if (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nNXWR32(adapter, NETXEN_ROMUSB_GLB_SW_RESET, 0x80001d);\r\nelse {\r\nNXWR32(adapter, NETXEN_ROMUSB_GLB_CHIP_CLK_CTRL, 0x3fff);\r\nNXWR32(adapter, NETXEN_ROMUSB_GLB_CAS_RST, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_validate_firmware(struct netxen_adapter *adapter)\r\n{\r\n__le32 val;\r\n__le32 flash_fw_ver;\r\nu32 file_fw_ver, min_ver, bios;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nconst struct firmware *fw = adapter->fw;\r\nu8 fw_type = adapter->fw_type;\r\nu32 crbinit_fix_fw;\r\nif (fw_type == NX_UNIFIED_ROMIMAGE) {\r\nif (netxen_nic_validate_unified_romimage(adapter))\r\nreturn -EINVAL;\r\n} else {\r\nval = cpu_to_le32(*(u32 *)&fw->data[NX_FW_MAGIC_OFFSET]);\r\nif ((__force u32)val != NETXEN_BDINFO_MAGIC)\r\nreturn -EINVAL;\r\nif (fw->size < NX_FW_MIN_SIZE)\r\nreturn -EINVAL;\r\n}\r\nval = nx_get_fw_version(adapter);\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nmin_ver = NETXEN_MIN_P3_FW_SUPP;\r\nelse\r\nmin_ver = NETXEN_VERSION_CODE(3, 4, 216);\r\nfile_fw_ver = NETXEN_DECODE_VERSION(val);\r\nif ((_major(file_fw_ver) > _NETXEN_NIC_LINUX_MAJOR) ||\r\n(file_fw_ver < min_ver)) {\r\ndev_err(&pdev->dev,\r\n"%s: firmware version %d.%d.%d unsupported\n",\r\nfw_name[fw_type], _major(file_fw_ver), _minor(file_fw_ver),\r\n_build(file_fw_ver));\r\nreturn -EINVAL;\r\n}\r\nval = nx_get_bios_version(adapter);\r\nnetxen_rom_fast_read(adapter, NX_BIOS_VERSION_OFFSET, (int *)&bios);\r\nif ((__force u32)val != bios) {\r\ndev_err(&pdev->dev, "%s: firmware bios is incompatible\n",\r\nfw_name[fw_type]);\r\nreturn -EINVAL;\r\n}\r\nif (netxen_rom_fast_read(adapter,\r\nNX_FW_VERSION_OFFSET, (int *)&flash_fw_ver)) {\r\ndev_err(&pdev->dev, "Unable to read flash fw version\n");\r\nreturn -EIO;\r\n}\r\nflash_fw_ver = NETXEN_DECODE_VERSION(flash_fw_ver);\r\ncrbinit_fix_fw = NETXEN_VERSION_CODE(4, 0, 554);\r\nif (file_fw_ver >= crbinit_fix_fw && flash_fw_ver < crbinit_fix_fw &&\r\nNX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\ndev_err(&pdev->dev, "Incompatibility detected between driver "\r\n"and firmware version on flash. This configuration "\r\n"is not recommended. Please update the firmware on "\r\n"flash immediately\n");\r\nreturn -EINVAL;\r\n}\r\nif (!netxen_p3_has_mn(adapter) ||\r\nNX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nif (flash_fw_ver > file_fw_ver) {\r\ndev_info(&pdev->dev, "%s: firmware is older than flash\n",\r\nfw_name[fw_type]);\r\nreturn -EINVAL;\r\n}\r\n}\r\nNXWR32(adapter, NETXEN_CAM_RAM(0x1fc), NETXEN_BDINFO_MAGIC);\r\nreturn 0;\r\n}\r\nstatic void\r\nnx_get_next_fwtype(struct netxen_adapter *adapter)\r\n{\r\nu8 fw_type;\r\nswitch (adapter->fw_type) {\r\ncase NX_UNKNOWN_ROMIMAGE:\r\nfw_type = NX_UNIFIED_ROMIMAGE;\r\nbreak;\r\ncase NX_UNIFIED_ROMIMAGE:\r\nif (NX_IS_REVISION_P3P(adapter->ahw.revision_id))\r\nfw_type = NX_FLASH_ROMIMAGE;\r\nelse if (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nfw_type = NX_P2_MN_ROMIMAGE;\r\nelse if (netxen_p3_has_mn(adapter))\r\nfw_type = NX_P3_MN_ROMIMAGE;\r\nelse\r\nfw_type = NX_P3_CT_ROMIMAGE;\r\nbreak;\r\ncase NX_P3_MN_ROMIMAGE:\r\nfw_type = NX_P3_CT_ROMIMAGE;\r\nbreak;\r\ncase NX_P2_MN_ROMIMAGE:\r\ncase NX_P3_CT_ROMIMAGE:\r\ndefault:\r\nfw_type = NX_FLASH_ROMIMAGE;\r\nbreak;\r\n}\r\nadapter->fw_type = fw_type;\r\n}\r\nstatic int\r\nnetxen_p3_has_mn(struct netxen_adapter *adapter)\r\n{\r\nu32 capability, flashed_ver;\r\ncapability = 0;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn 1;\r\nnetxen_rom_fast_read(adapter,\r\nNX_FW_VERSION_OFFSET, (int *)&flashed_ver);\r\nflashed_ver = NETXEN_DECODE_VERSION(flashed_ver);\r\nif (flashed_ver >= NETXEN_VERSION_CODE(4, 0, 220)) {\r\ncapability = NXRD32(adapter, NX_PEG_TUNE_CAPABILITY);\r\nif (capability & NX_PEG_TUNE_MN_PRESENT)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid netxen_request_firmware(struct netxen_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint rc = 0;\r\nadapter->fw_type = NX_UNKNOWN_ROMIMAGE;\r\nnext:\r\nnx_get_next_fwtype(adapter);\r\nif (adapter->fw_type == NX_FLASH_ROMIMAGE) {\r\nadapter->fw = NULL;\r\n} else {\r\nrc = request_firmware(&adapter->fw,\r\nfw_name[adapter->fw_type], &pdev->dev);\r\nif (rc != 0)\r\ngoto next;\r\nrc = netxen_validate_firmware(adapter);\r\nif (rc != 0) {\r\nrelease_firmware(adapter->fw);\r\nmsleep(1);\r\ngoto next;\r\n}\r\n}\r\n}\r\nvoid\r\nnetxen_release_firmware(struct netxen_adapter *adapter)\r\n{\r\nrelease_firmware(adapter->fw);\r\nadapter->fw = NULL;\r\n}\r\nint netxen_init_dummy_dma(struct netxen_adapter *adapter)\r\n{\r\nu64 addr;\r\nu32 hi, lo;\r\nif (!NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn 0;\r\nadapter->dummy_dma.addr = pci_alloc_consistent(adapter->pdev,\r\nNETXEN_HOST_DUMMY_DMA_SIZE,\r\n&adapter->dummy_dma.phys_addr);\r\nif (adapter->dummy_dma.addr == NULL) {\r\ndev_err(&adapter->pdev->dev,\r\n"ERROR: Could not allocate dummy DMA memory\n");\r\nreturn -ENOMEM;\r\n}\r\naddr = (uint64_t) adapter->dummy_dma.phys_addr;\r\nhi = (addr >> 32) & 0xffffffff;\r\nlo = addr & 0xffffffff;\r\nNXWR32(adapter, CRB_HOST_DUMMY_BUF_ADDR_HI, hi);\r\nNXWR32(adapter, CRB_HOST_DUMMY_BUF_ADDR_LO, lo);\r\nreturn 0;\r\n}\r\nvoid netxen_free_dummy_dma(struct netxen_adapter *adapter)\r\n{\r\nint i = 100;\r\nu32 ctrl;\r\nif (!NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn;\r\nif (!adapter->dummy_dma.addr)\r\nreturn;\r\nctrl = NXRD32(adapter, NETXEN_DMA_WATCHDOG_CTRL);\r\nif ((ctrl & 0x1) != 0) {\r\nNXWR32(adapter, NETXEN_DMA_WATCHDOG_CTRL, (ctrl | 0x2));\r\nwhile ((ctrl & 0x1) != 0) {\r\nmsleep(50);\r\nctrl = NXRD32(adapter, NETXEN_DMA_WATCHDOG_CTRL);\r\nif (--i == 0)\r\nbreak;\r\n}\r\n}\r\nif (i) {\r\npci_free_consistent(adapter->pdev,\r\nNETXEN_HOST_DUMMY_DMA_SIZE,\r\nadapter->dummy_dma.addr,\r\nadapter->dummy_dma.phys_addr);\r\nadapter->dummy_dma.addr = NULL;\r\n} else\r\ndev_err(&adapter->pdev->dev, "dma_watchdog_shutdown failed\n");\r\n}\r\nint netxen_phantom_init(struct netxen_adapter *adapter, int pegtune_val)\r\n{\r\nu32 val = 0;\r\nint retries = 60;\r\nif (pegtune_val)\r\nreturn 0;\r\ndo {\r\nval = NXRD32(adapter, CRB_CMDPEG_STATE);\r\nswitch (val) {\r\ncase PHAN_INITIALIZE_COMPLETE:\r\ncase PHAN_INITIALIZE_ACK:\r\nreturn 0;\r\ncase PHAN_INITIALIZE_FAILED:\r\ngoto out_err;\r\ndefault:\r\nbreak;\r\n}\r\nmsleep(500);\r\n} while (--retries);\r\nNXWR32(adapter, CRB_CMDPEG_STATE, PHAN_INITIALIZE_FAILED);\r\nout_err:\r\ndev_warn(&adapter->pdev->dev, "firmware init failed\n");\r\nreturn -EIO;\r\n}\r\nstatic int\r\nnetxen_receive_peg_ready(struct netxen_adapter *adapter)\r\n{\r\nu32 val = 0;\r\nint retries = 2000;\r\ndo {\r\nval = NXRD32(adapter, CRB_RCVPEG_STATE);\r\nif (val == PHAN_PEG_RCV_INITIALIZED)\r\nreturn 0;\r\nmsleep(10);\r\n} while (--retries);\r\nif (!retries) {\r\nprintk(KERN_ERR "Receive Peg initialization not "\r\n"complete, state: 0x%x.\n", val);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint netxen_init_firmware(struct netxen_adapter *adapter)\r\n{\r\nint err;\r\nerr = netxen_receive_peg_ready(adapter);\r\nif (err)\r\nreturn err;\r\nNXWR32(adapter, CRB_NIC_CAPABILITIES_HOST, INTR_SCHEME_PERPORT);\r\nNXWR32(adapter, CRB_MPORT_MODE, MPORT_MULTI_FUNCTION_MODE);\r\nNXWR32(adapter, CRB_CMDPEG_STATE, PHAN_INITIALIZE_ACK);\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nNXWR32(adapter, CRB_NIC_MSI_MODE_HOST, MSI_MODE_MULTIFUNC);\r\nreturn err;\r\n}\r\nstatic void\r\nnetxen_handle_linkevent(struct netxen_adapter *adapter, nx_fw_msg_t *msg)\r\n{\r\nu32 cable_OUI;\r\nu16 cable_len;\r\nu16 link_speed;\r\nu8 link_status, module, duplex, autoneg;\r\nstruct net_device *netdev = adapter->netdev;\r\nadapter->has_link_events = 1;\r\ncable_OUI = msg->body[1] & 0xffffffff;\r\ncable_len = (msg->body[1] >> 32) & 0xffff;\r\nlink_speed = (msg->body[1] >> 48) & 0xffff;\r\nlink_status = msg->body[2] & 0xff;\r\nduplex = (msg->body[2] >> 16) & 0xff;\r\nautoneg = (msg->body[2] >> 24) & 0xff;\r\nmodule = (msg->body[2] >> 8) & 0xff;\r\nif (module == LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLE) {\r\nprintk(KERN_INFO "%s: unsupported cable: OUI 0x%x, length %d\n",\r\nnetdev->name, cable_OUI, cable_len);\r\n} else if (module == LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLELEN) {\r\nprintk(KERN_INFO "%s: unsupported cable length %d\n",\r\nnetdev->name, cable_len);\r\n}\r\nif (duplex == LINKEVENT_FULL_DUPLEX)\r\nadapter->link_duplex = DUPLEX_FULL;\r\nelse\r\nadapter->link_duplex = DUPLEX_HALF;\r\nadapter->module_type = module;\r\nadapter->link_autoneg = autoneg;\r\nadapter->link_speed = link_speed;\r\nnetxen_advert_link_change(adapter, link_status);\r\n}\r\nstatic void\r\nnetxen_handle_fw_message(int desc_cnt, int index,\r\nstruct nx_host_sds_ring *sds_ring)\r\n{\r\nnx_fw_msg_t msg;\r\nstruct status_desc *desc;\r\nint i = 0, opcode;\r\nwhile (desc_cnt > 0 && i < 8) {\r\ndesc = &sds_ring->desc_head[index];\r\nmsg.words[i++] = le64_to_cpu(desc->status_desc_data[0]);\r\nmsg.words[i++] = le64_to_cpu(desc->status_desc_data[1]);\r\nindex = get_next_index(index, sds_ring->num_desc);\r\ndesc_cnt--;\r\n}\r\nopcode = netxen_get_nic_msg_opcode(msg.body[0]);\r\nswitch (opcode) {\r\ncase NX_NIC_C2H_OPCODE_GET_LINKEVENT_RESPONSE:\r\nnetxen_handle_linkevent(sds_ring->adapter, &msg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nnetxen_alloc_rx_skb(struct netxen_adapter *adapter,\r\nstruct nx_host_rds_ring *rds_ring,\r\nstruct netxen_rx_buffer *buffer)\r\n{\r\nstruct sk_buff *skb;\r\ndma_addr_t dma;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nbuffer->skb = netdev_alloc_skb(adapter->netdev, rds_ring->skb_size);\r\nif (!buffer->skb)\r\nreturn 1;\r\nskb = buffer->skb;\r\nif (!adapter->ahw.cut_through)\r\nskb_reserve(skb, 2);\r\ndma = pci_map_single(pdev, skb->data,\r\nrds_ring->dma_size, PCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(pdev, dma)) {\r\ndev_kfree_skb_any(skb);\r\nbuffer->skb = NULL;\r\nreturn 1;\r\n}\r\nbuffer->skb = skb;\r\nbuffer->dma = dma;\r\nbuffer->state = NETXEN_BUFFER_BUSY;\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *netxen_process_rxbuf(struct netxen_adapter *adapter,\r\nstruct nx_host_rds_ring *rds_ring, u16 index, u16 cksum)\r\n{\r\nstruct netxen_rx_buffer *buffer;\r\nstruct sk_buff *skb;\r\nbuffer = &rds_ring->rx_buf_arr[index];\r\npci_unmap_single(adapter->pdev, buffer->dma, rds_ring->dma_size,\r\nPCI_DMA_FROMDEVICE);\r\nskb = buffer->skb;\r\nif (!skb)\r\ngoto no_skb;\r\nif (likely((adapter->netdev->features & NETIF_F_RXCSUM)\r\n&& cksum == STATUS_CKSUM_OK)) {\r\nadapter->stats.csummed++;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n} else\r\nskb->ip_summed = CHECKSUM_NONE;\r\nbuffer->skb = NULL;\r\nno_skb:\r\nbuffer->state = NETXEN_BUFFER_FREE;\r\nreturn skb;\r\n}\r\nstatic struct netxen_rx_buffer *\r\nnetxen_process_rcv(struct netxen_adapter *adapter,\r\nstruct nx_host_sds_ring *sds_ring,\r\nint ring, u64 sts_data0)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\nstruct netxen_rx_buffer *buffer;\r\nstruct sk_buff *skb;\r\nstruct nx_host_rds_ring *rds_ring;\r\nint index, length, cksum, pkt_offset;\r\nif (unlikely(ring >= adapter->max_rds_rings))\r\nreturn NULL;\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nindex = netxen_get_sts_refhandle(sts_data0);\r\nif (unlikely(index >= rds_ring->num_desc))\r\nreturn NULL;\r\nbuffer = &rds_ring->rx_buf_arr[index];\r\nlength = netxen_get_sts_totallength(sts_data0);\r\ncksum = netxen_get_sts_status(sts_data0);\r\npkt_offset = netxen_get_sts_pkt_offset(sts_data0);\r\nskb = netxen_process_rxbuf(adapter, rds_ring, index, cksum);\r\nif (!skb)\r\nreturn buffer;\r\nif (length > rds_ring->skb_size)\r\nskb_put(skb, rds_ring->skb_size);\r\nelse\r\nskb_put(skb, length);\r\nif (pkt_offset)\r\nskb_pull(skb, pkt_offset);\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nnapi_gro_receive(&sds_ring->napi, skb);\r\nadapter->stats.rx_pkts++;\r\nadapter->stats.rxbytes += length;\r\nreturn buffer;\r\n}\r\nstatic struct netxen_rx_buffer *\r\nnetxen_process_lro(struct netxen_adapter *adapter,\r\nstruct nx_host_sds_ring *sds_ring,\r\nint ring, u64 sts_data0, u64 sts_data1)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\nstruct netxen_rx_buffer *buffer;\r\nstruct sk_buff *skb;\r\nstruct nx_host_rds_ring *rds_ring;\r\nstruct iphdr *iph;\r\nstruct tcphdr *th;\r\nbool push, timestamp;\r\nint l2_hdr_offset, l4_hdr_offset;\r\nint index;\r\nu16 lro_length, length, data_offset;\r\nu32 seq_number;\r\nu8 vhdr_len = 0;\r\nif (unlikely(ring > adapter->max_rds_rings))\r\nreturn NULL;\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nindex = netxen_get_lro_sts_refhandle(sts_data0);\r\nif (unlikely(index > rds_ring->num_desc))\r\nreturn NULL;\r\nbuffer = &rds_ring->rx_buf_arr[index];\r\ntimestamp = netxen_get_lro_sts_timestamp(sts_data0);\r\nlro_length = netxen_get_lro_sts_length(sts_data0);\r\nl2_hdr_offset = netxen_get_lro_sts_l2_hdr_offset(sts_data0);\r\nl4_hdr_offset = netxen_get_lro_sts_l4_hdr_offset(sts_data0);\r\npush = netxen_get_lro_sts_push_flag(sts_data0);\r\nseq_number = netxen_get_lro_sts_seq_number(sts_data1);\r\nskb = netxen_process_rxbuf(adapter, rds_ring, index, STATUS_CKSUM_OK);\r\nif (!skb)\r\nreturn buffer;\r\nif (timestamp)\r\ndata_offset = l4_hdr_offset + TCP_TS_HDR_SIZE;\r\nelse\r\ndata_offset = l4_hdr_offset + TCP_HDR_SIZE;\r\nskb_put(skb, lro_length + data_offset);\r\nskb_pull(skb, l2_hdr_offset);\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nif (skb->protocol == htons(ETH_P_8021Q))\r\nvhdr_len = VLAN_HLEN;\r\niph = (struct iphdr *)(skb->data + vhdr_len);\r\nth = (struct tcphdr *)((skb->data + vhdr_len) + (iph->ihl << 2));\r\nlength = (iph->ihl << 2) + (th->doff << 2) + lro_length;\r\niph->tot_len = htons(length);\r\niph->check = 0;\r\niph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);\r\nth->psh = push;\r\nth->seq = htonl(seq_number);\r\nlength = skb->len;\r\nif (adapter->flags & NETXEN_FW_MSS_CAP)\r\nskb_shinfo(skb)->gso_size = netxen_get_lro_sts_mss(sts_data1);\r\nnetif_receive_skb(skb);\r\nadapter->stats.lro_pkts++;\r\nadapter->stats.rxbytes += length;\r\nreturn buffer;\r\n}\r\nint\r\nnetxen_process_rcv_ring(struct nx_host_sds_ring *sds_ring, int max)\r\n{\r\nstruct netxen_adapter *adapter = sds_ring->adapter;\r\nstruct list_head *cur;\r\nstruct status_desc *desc;\r\nstruct netxen_rx_buffer *rxbuf;\r\nu32 consumer = sds_ring->consumer;\r\nint count = 0;\r\nu64 sts_data0, sts_data1;\r\nint opcode, ring = 0, desc_cnt;\r\nwhile (count < max) {\r\ndesc = &sds_ring->desc_head[consumer];\r\nsts_data0 = le64_to_cpu(desc->status_desc_data[0]);\r\nif (!(sts_data0 & STATUS_OWNER_HOST))\r\nbreak;\r\ndesc_cnt = netxen_get_sts_desc_cnt(sts_data0);\r\nopcode = netxen_get_sts_opcode(sts_data0);\r\nswitch (opcode) {\r\ncase NETXEN_NIC_RXPKT_DESC:\r\ncase NETXEN_OLD_RXPKT_DESC:\r\ncase NETXEN_NIC_SYN_OFFLOAD:\r\nring = netxen_get_sts_type(sts_data0);\r\nrxbuf = netxen_process_rcv(adapter, sds_ring,\r\nring, sts_data0);\r\nbreak;\r\ncase NETXEN_NIC_LRO_DESC:\r\nring = netxen_get_lro_sts_type(sts_data0);\r\nsts_data1 = le64_to_cpu(desc->status_desc_data[1]);\r\nrxbuf = netxen_process_lro(adapter, sds_ring,\r\nring, sts_data0, sts_data1);\r\nbreak;\r\ncase NETXEN_NIC_RESPONSE_DESC:\r\nnetxen_handle_fw_message(desc_cnt, consumer, sds_ring);\r\ndefault:\r\ngoto skip;\r\n}\r\nWARN_ON(desc_cnt > 1);\r\nif (rxbuf)\r\nlist_add_tail(&rxbuf->list, &sds_ring->free_list[ring]);\r\nskip:\r\nfor (; desc_cnt > 0; desc_cnt--) {\r\ndesc = &sds_ring->desc_head[consumer];\r\ndesc->status_desc_data[0] =\r\ncpu_to_le64(STATUS_OWNER_PHANTOM);\r\nconsumer = get_next_index(consumer, sds_ring->num_desc);\r\n}\r\ncount++;\r\n}\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nstruct nx_host_rds_ring *rds_ring =\r\n&adapter->recv_ctx.rds_rings[ring];\r\nif (!list_empty(&sds_ring->free_list[ring])) {\r\nlist_for_each(cur, &sds_ring->free_list[ring]) {\r\nrxbuf = list_entry(cur,\r\nstruct netxen_rx_buffer, list);\r\nnetxen_alloc_rx_skb(adapter, rds_ring, rxbuf);\r\n}\r\nspin_lock(&rds_ring->lock);\r\nnetxen_merge_rx_buffers(&sds_ring->free_list[ring],\r\n&rds_ring->free_list);\r\nspin_unlock(&rds_ring->lock);\r\n}\r\nnetxen_post_rx_buffers_nodb(adapter, rds_ring);\r\n}\r\nif (count) {\r\nsds_ring->consumer = consumer;\r\nNXWRIO(adapter, sds_ring->crb_sts_consumer, consumer);\r\n}\r\nreturn count;\r\n}\r\nint netxen_process_cmd_ring(struct netxen_adapter *adapter)\r\n{\r\nu32 sw_consumer, hw_consumer;\r\nint count = 0, i;\r\nstruct netxen_cmd_buffer *buffer;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct netxen_skb_frag *frag;\r\nint done = 0;\r\nstruct nx_host_tx_ring *tx_ring = adapter->tx_ring;\r\nif (!spin_trylock(&adapter->tx_clean_lock))\r\nreturn 1;\r\nsw_consumer = tx_ring->sw_consumer;\r\nhw_consumer = le32_to_cpu(*(tx_ring->hw_consumer));\r\nwhile (sw_consumer != hw_consumer) {\r\nbuffer = &tx_ring->cmd_buf_arr[sw_consumer];\r\nif (buffer->skb) {\r\nfrag = &buffer->frag_array[0];\r\npci_unmap_single(pdev, frag->dma, frag->length,\r\nPCI_DMA_TODEVICE);\r\nfrag->dma = 0ULL;\r\nfor (i = 1; i < buffer->frag_count; i++) {\r\nfrag++;\r\npci_unmap_page(pdev, frag->dma, frag->length,\r\nPCI_DMA_TODEVICE);\r\nfrag->dma = 0ULL;\r\n}\r\nadapter->stats.xmitfinished++;\r\ndev_kfree_skb_any(buffer->skb);\r\nbuffer->skb = NULL;\r\n}\r\nsw_consumer = get_next_index(sw_consumer, tx_ring->num_desc);\r\nif (++count >= MAX_STATUS_HANDLE)\r\nbreak;\r\n}\r\nif (count && netif_running(netdev)) {\r\ntx_ring->sw_consumer = sw_consumer;\r\nsmp_mb();\r\nif (netif_queue_stopped(netdev) && netif_carrier_ok(netdev))\r\nif (netxen_tx_avail(tx_ring) > TX_STOP_THRESH)\r\nnetif_wake_queue(netdev);\r\nadapter->tx_timeo_cnt = 0;\r\n}\r\nhw_consumer = le32_to_cpu(*(tx_ring->hw_consumer));\r\ndone = (sw_consumer == hw_consumer);\r\nspin_unlock(&adapter->tx_clean_lock);\r\nreturn done;\r\n}\r\nvoid\r\nnetxen_post_rx_buffers(struct netxen_adapter *adapter, u32 ringid,\r\nstruct nx_host_rds_ring *rds_ring)\r\n{\r\nstruct rcv_desc *pdesc;\r\nstruct netxen_rx_buffer *buffer;\r\nint producer, count = 0;\r\nnetxen_ctx_msg msg = 0;\r\nstruct list_head *head;\r\nproducer = rds_ring->producer;\r\nhead = &rds_ring->free_list;\r\nwhile (!list_empty(head)) {\r\nbuffer = list_entry(head->next, struct netxen_rx_buffer, list);\r\nif (!buffer->skb) {\r\nif (netxen_alloc_rx_skb(adapter, rds_ring, buffer))\r\nbreak;\r\n}\r\ncount++;\r\nlist_del(&buffer->list);\r\npdesc = &rds_ring->desc_head[producer];\r\npdesc->addr_buffer = cpu_to_le64(buffer->dma);\r\npdesc->reference_handle = cpu_to_le16(buffer->ref_handle);\r\npdesc->buffer_length = cpu_to_le32(rds_ring->dma_size);\r\nproducer = get_next_index(producer, rds_ring->num_desc);\r\n}\r\nif (count) {\r\nrds_ring->producer = producer;\r\nNXWRIO(adapter, rds_ring->crb_rcv_producer,\r\n(producer-1) & (rds_ring->num_desc-1));\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nnetxen_set_msg_peg_id(msg, NETXEN_RCV_PEG_DB_ID);\r\nnetxen_set_msg_privid(msg);\r\nnetxen_set_msg_count(msg,\r\n((producer - 1) &\r\n(rds_ring->num_desc - 1)));\r\nnetxen_set_msg_ctxid(msg, adapter->portnum);\r\nnetxen_set_msg_opcode(msg, NETXEN_RCV_PRODUCER(ringid));\r\nNXWRIO(adapter, DB_NORMALIZE(adapter,\r\nNETXEN_RCV_PRODUCER_OFFSET), msg);\r\n}\r\n}\r\n}\r\nstatic void\r\nnetxen_post_rx_buffers_nodb(struct netxen_adapter *adapter,\r\nstruct nx_host_rds_ring *rds_ring)\r\n{\r\nstruct rcv_desc *pdesc;\r\nstruct netxen_rx_buffer *buffer;\r\nint producer, count = 0;\r\nstruct list_head *head;\r\nif (!spin_trylock(&rds_ring->lock))\r\nreturn;\r\nproducer = rds_ring->producer;\r\nhead = &rds_ring->free_list;\r\nwhile (!list_empty(head)) {\r\nbuffer = list_entry(head->next, struct netxen_rx_buffer, list);\r\nif (!buffer->skb) {\r\nif (netxen_alloc_rx_skb(adapter, rds_ring, buffer))\r\nbreak;\r\n}\r\ncount++;\r\nlist_del(&buffer->list);\r\npdesc = &rds_ring->desc_head[producer];\r\npdesc->reference_handle = cpu_to_le16(buffer->ref_handle);\r\npdesc->buffer_length = cpu_to_le32(rds_ring->dma_size);\r\npdesc->addr_buffer = cpu_to_le64(buffer->dma);\r\nproducer = get_next_index(producer, rds_ring->num_desc);\r\n}\r\nif (count) {\r\nrds_ring->producer = producer;\r\nNXWRIO(adapter, rds_ring->crb_rcv_producer,\r\n(producer - 1) & (rds_ring->num_desc - 1));\r\n}\r\nspin_unlock(&rds_ring->lock);\r\n}\r\nvoid netxen_nic_clear_stats(struct netxen_adapter *adapter)\r\n{\r\nmemset(&adapter->stats, 0, sizeof(adapter->stats));\r\n}
