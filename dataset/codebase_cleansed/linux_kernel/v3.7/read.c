struct nfs_read_header *nfs_readhdr_alloc(void)\r\n{\r\nstruct nfs_read_header *rhdr;\r\nrhdr = kmem_cache_zalloc(nfs_rdata_cachep, GFP_KERNEL);\r\nif (rhdr) {\r\nstruct nfs_pgio_header *hdr = &rhdr->header;\r\nINIT_LIST_HEAD(&hdr->pages);\r\nINIT_LIST_HEAD(&hdr->rpc_list);\r\nspin_lock_init(&hdr->lock);\r\natomic_set(&hdr->refcnt, 0);\r\n}\r\nreturn rhdr;\r\n}\r\nstatic struct nfs_read_data *nfs_readdata_alloc(struct nfs_pgio_header *hdr,\r\nunsigned int pagecount)\r\n{\r\nstruct nfs_read_data *data, *prealloc;\r\nprealloc = &container_of(hdr, struct nfs_read_header, header)->rpc_data;\r\nif (prealloc->header == NULL)\r\ndata = prealloc;\r\nelse\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\ngoto out;\r\nif (nfs_pgarray_set(&data->pages, pagecount)) {\r\ndata->header = hdr;\r\natomic_inc(&hdr->refcnt);\r\n} else {\r\nif (data != prealloc)\r\nkfree(data);\r\ndata = NULL;\r\n}\r\nout:\r\nreturn data;\r\n}\r\nvoid nfs_readhdr_free(struct nfs_pgio_header *hdr)\r\n{\r\nstruct nfs_read_header *rhdr = container_of(hdr, struct nfs_read_header, header);\r\nkmem_cache_free(nfs_rdata_cachep, rhdr);\r\n}\r\nvoid nfs_readdata_release(struct nfs_read_data *rdata)\r\n{\r\nstruct nfs_pgio_header *hdr = rdata->header;\r\nstruct nfs_read_header *read_header = container_of(hdr, struct nfs_read_header, header);\r\nput_nfs_open_context(rdata->args.context);\r\nif (rdata->pages.pagevec != rdata->pages.page_array)\r\nkfree(rdata->pages.pagevec);\r\nif (rdata != &read_header->rpc_data)\r\nkfree(rdata);\r\nelse\r\nrdata->header = NULL;\r\nif (atomic_dec_and_test(&hdr->refcnt))\r\nhdr->completion_ops->completion(hdr);\r\n}\r\nstatic\r\nint nfs_return_empty_page(struct page *page)\r\n{\r\nzero_user(page, 0, PAGE_CACHE_SIZE);\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\nreturn 0;\r\n}\r\nvoid nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\r\nstruct inode *inode,\r\nconst struct nfs_pgio_completion_ops *compl_ops)\r\n{\r\nnfs_pageio_init(pgio, inode, &nfs_pageio_read_ops, compl_ops,\r\nNFS_SERVER(inode)->rsize, 0);\r\n}\r\nvoid nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\r\n{\r\npgio->pg_ops = &nfs_pageio_read_ops;\r\npgio->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\r\n}\r\nint nfs_readpage_async(struct nfs_open_context *ctx, struct inode *inode,\r\nstruct page *page)\r\n{\r\nstruct nfs_page *new;\r\nunsigned int len;\r\nstruct nfs_pageio_descriptor pgio;\r\nlen = nfs_page_length(page);\r\nif (len == 0)\r\nreturn nfs_return_empty_page(page);\r\nnew = nfs_create_request(ctx, inode, page, 0, len);\r\nif (IS_ERR(new)) {\r\nunlock_page(page);\r\nreturn PTR_ERR(new);\r\n}\r\nif (len < PAGE_CACHE_SIZE)\r\nzero_user_segment(page, len, PAGE_CACHE_SIZE);\r\nNFS_PROTO(inode)->read_pageio_init(&pgio, inode, &nfs_async_read_completion_ops);\r\nnfs_pageio_add_request(&pgio, new);\r\nnfs_pageio_complete(&pgio);\r\nNFS_I(inode)->read_io += pgio.pg_bytes_written;\r\nreturn 0;\r\n}\r\nstatic void nfs_readpage_release(struct nfs_page *req)\r\n{\r\nstruct inode *d_inode = req->wb_context->dentry->d_inode;\r\nif (PageUptodate(req->wb_page))\r\nnfs_readpage_to_fscache(d_inode, req->wb_page, 0);\r\nunlock_page(req->wb_page);\r\ndprintk("NFS: read done (%s/%Ld %d@%Ld)\n",\r\nreq->wb_context->dentry->d_inode->i_sb->s_id,\r\n(long long)NFS_FILEID(req->wb_context->dentry->d_inode),\r\nreq->wb_bytes,\r\n(long long)req_offset(req));\r\nnfs_release_request(req);\r\n}\r\nstatic void nfs_read_completion(struct nfs_pgio_header *hdr)\r\n{\r\nunsigned long bytes = 0;\r\nif (test_bit(NFS_IOHDR_REDO, &hdr->flags))\r\ngoto out;\r\nwhile (!list_empty(&hdr->pages)) {\r\nstruct nfs_page *req = nfs_list_entry(hdr->pages.next);\r\nstruct page *page = req->wb_page;\r\nif (test_bit(NFS_IOHDR_EOF, &hdr->flags)) {\r\nif (bytes > hdr->good_bytes)\r\nzero_user(page, 0, PAGE_SIZE);\r\nelse if (hdr->good_bytes - bytes < PAGE_SIZE)\r\nzero_user_segment(page,\r\nhdr->good_bytes & ~PAGE_MASK,\r\nPAGE_SIZE);\r\n}\r\nbytes += req->wb_bytes;\r\nif (test_bit(NFS_IOHDR_ERROR, &hdr->flags)) {\r\nif (bytes <= hdr->good_bytes)\r\nSetPageUptodate(page);\r\n} else\r\nSetPageUptodate(page);\r\nnfs_list_remove_request(req);\r\nnfs_readpage_release(req);\r\n}\r\nout:\r\nhdr->release(hdr);\r\n}\r\nint nfs_initiate_read(struct rpc_clnt *clnt,\r\nstruct nfs_read_data *data,\r\nconst struct rpc_call_ops *call_ops, int flags)\r\n{\r\nstruct inode *inode = data->header->inode;\r\nint swap_flags = IS_SWAPFILE(inode) ? NFS_RPC_SWAPFLAGS : 0;\r\nstruct rpc_task *task;\r\nstruct rpc_message msg = {\r\n.rpc_argp = &data->args,\r\n.rpc_resp = &data->res,\r\n.rpc_cred = data->header->cred,\r\n};\r\nstruct rpc_task_setup task_setup_data = {\r\n.task = &data->task,\r\n.rpc_client = clnt,\r\n.rpc_message = &msg,\r\n.callback_ops = call_ops,\r\n.callback_data = data,\r\n.workqueue = nfsiod_workqueue,\r\n.flags = RPC_TASK_ASYNC | swap_flags | flags,\r\n};\r\nNFS_PROTO(inode)->read_setup(data, &msg);\r\ndprintk("NFS: %5u initiated read call (req %s/%lld, %u bytes @ "\r\n"offset %llu)\n",\r\ndata->task.tk_pid,\r\ninode->i_sb->s_id,\r\n(long long)NFS_FILEID(inode),\r\ndata->args.count,\r\n(unsigned long long)data->args.offset);\r\ntask = rpc_run_task(&task_setup_data);\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nrpc_put_task(task);\r\nreturn 0;\r\n}\r\nstatic void nfs_read_rpcsetup(struct nfs_read_data *data,\r\nunsigned int count, unsigned int offset)\r\n{\r\nstruct nfs_page *req = data->header->req;\r\ndata->args.fh = NFS_FH(data->header->inode);\r\ndata->args.offset = req_offset(req) + offset;\r\ndata->args.pgbase = req->wb_pgbase + offset;\r\ndata->args.pages = data->pages.pagevec;\r\ndata->args.count = count;\r\ndata->args.context = get_nfs_open_context(req->wb_context);\r\ndata->args.lock_context = req->wb_lock_context;\r\ndata->res.fattr = &data->fattr;\r\ndata->res.count = count;\r\ndata->res.eof = 0;\r\nnfs_fattr_init(&data->fattr);\r\n}\r\nstatic int nfs_do_read(struct nfs_read_data *data,\r\nconst struct rpc_call_ops *call_ops)\r\n{\r\nstruct inode *inode = data->header->inode;\r\nreturn nfs_initiate_read(NFS_CLIENT(inode), data, call_ops, 0);\r\n}\r\nstatic int\r\nnfs_do_multiple_reads(struct list_head *head,\r\nconst struct rpc_call_ops *call_ops)\r\n{\r\nstruct nfs_read_data *data;\r\nint ret = 0;\r\nwhile (!list_empty(head)) {\r\nint ret2;\r\ndata = list_first_entry(head, struct nfs_read_data, list);\r\nlist_del_init(&data->list);\r\nret2 = nfs_do_read(data, call_ops);\r\nif (ret == 0)\r\nret = ret2;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nnfs_async_read_error(struct list_head *head)\r\n{\r\nstruct nfs_page *req;\r\nwhile (!list_empty(head)) {\r\nreq = nfs_list_entry(head->next);\r\nnfs_list_remove_request(req);\r\nnfs_readpage_release(req);\r\n}\r\n}\r\nstatic void nfs_pagein_error(struct nfs_pageio_descriptor *desc,\r\nstruct nfs_pgio_header *hdr)\r\n{\r\nset_bit(NFS_IOHDR_REDO, &hdr->flags);\r\nwhile (!list_empty(&hdr->rpc_list)) {\r\nstruct nfs_read_data *data = list_first_entry(&hdr->rpc_list,\r\nstruct nfs_read_data, list);\r\nlist_del(&data->list);\r\nnfs_readdata_release(data);\r\n}\r\ndesc->pg_completion_ops->error_cleanup(&desc->pg_list);\r\n}\r\nstatic int nfs_pagein_multi(struct nfs_pageio_descriptor *desc,\r\nstruct nfs_pgio_header *hdr)\r\n{\r\nstruct nfs_page *req = hdr->req;\r\nstruct page *page = req->wb_page;\r\nstruct nfs_read_data *data;\r\nsize_t rsize = desc->pg_bsize, nbytes;\r\nunsigned int offset;\r\noffset = 0;\r\nnbytes = desc->pg_count;\r\ndo {\r\nsize_t len = min(nbytes,rsize);\r\ndata = nfs_readdata_alloc(hdr, 1);\r\nif (!data) {\r\nnfs_pagein_error(desc, hdr);\r\nreturn -ENOMEM;\r\n}\r\ndata->pages.pagevec[0] = page;\r\nnfs_read_rpcsetup(data, len, offset);\r\nlist_add(&data->list, &hdr->rpc_list);\r\nnbytes -= len;\r\noffset += len;\r\n} while (nbytes != 0);\r\nnfs_list_remove_request(req);\r\nnfs_list_add_request(req, &hdr->pages);\r\ndesc->pg_rpc_callops = &nfs_read_common_ops;\r\nreturn 0;\r\n}\r\nstatic int nfs_pagein_one(struct nfs_pageio_descriptor *desc,\r\nstruct nfs_pgio_header *hdr)\r\n{\r\nstruct nfs_page *req;\r\nstruct page **pages;\r\nstruct nfs_read_data *data;\r\nstruct list_head *head = &desc->pg_list;\r\ndata = nfs_readdata_alloc(hdr, nfs_page_array_len(desc->pg_base,\r\ndesc->pg_count));\r\nif (!data) {\r\nnfs_pagein_error(desc, hdr);\r\nreturn -ENOMEM;\r\n}\r\npages = data->pages.pagevec;\r\nwhile (!list_empty(head)) {\r\nreq = nfs_list_entry(head->next);\r\nnfs_list_remove_request(req);\r\nnfs_list_add_request(req, &hdr->pages);\r\n*pages++ = req->wb_page;\r\n}\r\nnfs_read_rpcsetup(data, desc->pg_count, 0);\r\nlist_add(&data->list, &hdr->rpc_list);\r\ndesc->pg_rpc_callops = &nfs_read_common_ops;\r\nreturn 0;\r\n}\r\nint nfs_generic_pagein(struct nfs_pageio_descriptor *desc,\r\nstruct nfs_pgio_header *hdr)\r\n{\r\nif (desc->pg_bsize < PAGE_CACHE_SIZE)\r\nreturn nfs_pagein_multi(desc, hdr);\r\nreturn nfs_pagein_one(desc, hdr);\r\n}\r\nstatic int nfs_generic_pg_readpages(struct nfs_pageio_descriptor *desc)\r\n{\r\nstruct nfs_read_header *rhdr;\r\nstruct nfs_pgio_header *hdr;\r\nint ret;\r\nrhdr = nfs_readhdr_alloc();\r\nif (!rhdr) {\r\ndesc->pg_completion_ops->error_cleanup(&desc->pg_list);\r\nreturn -ENOMEM;\r\n}\r\nhdr = &rhdr->header;\r\nnfs_pgheader_init(desc, hdr, nfs_readhdr_free);\r\natomic_inc(&hdr->refcnt);\r\nret = nfs_generic_pagein(desc, hdr);\r\nif (ret == 0)\r\nret = nfs_do_multiple_reads(&hdr->rpc_list,\r\ndesc->pg_rpc_callops);\r\nif (atomic_dec_and_test(&hdr->refcnt))\r\nhdr->completion_ops->completion(hdr);\r\nreturn ret;\r\n}\r\nint nfs_readpage_result(struct rpc_task *task, struct nfs_read_data *data)\r\n{\r\nstruct inode *inode = data->header->inode;\r\nint status;\r\ndprintk("NFS: %s: %5u, (status %d)\n", __func__, task->tk_pid,\r\ntask->tk_status);\r\nstatus = NFS_PROTO(inode)->read_done(task, data);\r\nif (status != 0)\r\nreturn status;\r\nnfs_add_stats(inode, NFSIOS_SERVERREADBYTES, data->res.count);\r\nif (task->tk_status == -ESTALE) {\r\nset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\r\nnfs_mark_for_revalidate(inode);\r\n}\r\nreturn 0;\r\n}\r\nstatic void nfs_readpage_retry(struct rpc_task *task, struct nfs_read_data *data)\r\n{\r\nstruct nfs_readargs *argp = &data->args;\r\nstruct nfs_readres *resp = &data->res;\r\nnfs_inc_stats(data->header->inode, NFSIOS_SHORTREAD);\r\nif (resp->count == 0) {\r\nnfs_set_pgio_error(data->header, -EIO, argp->offset);\r\nreturn;\r\n}\r\ndata->mds_offset += resp->count;\r\nargp->offset += resp->count;\r\nargp->pgbase += resp->count;\r\nargp->count -= resp->count;\r\nrpc_restart_call_prepare(task);\r\n}\r\nstatic void nfs_readpage_result_common(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs_read_data *data = calldata;\r\nstruct nfs_pgio_header *hdr = data->header;\r\nif (nfs_readpage_result(task, data) != 0)\r\nreturn;\r\nif (task->tk_status < 0)\r\nnfs_set_pgio_error(hdr, task->tk_status, data->args.offset);\r\nelse if (data->res.eof) {\r\nloff_t bound;\r\nbound = data->args.offset + data->res.count;\r\nspin_lock(&hdr->lock);\r\nif (bound < hdr->io_start + hdr->good_bytes) {\r\nset_bit(NFS_IOHDR_EOF, &hdr->flags);\r\nclear_bit(NFS_IOHDR_ERROR, &hdr->flags);\r\nhdr->good_bytes = bound - hdr->io_start;\r\n}\r\nspin_unlock(&hdr->lock);\r\n} else if (data->res.count != data->args.count)\r\nnfs_readpage_retry(task, data);\r\n}\r\nstatic void nfs_readpage_release_common(void *calldata)\r\n{\r\nnfs_readdata_release(calldata);\r\n}\r\nvoid nfs_read_prepare(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs_read_data *data = calldata;\r\nNFS_PROTO(data->header->inode)->read_rpc_prepare(task, data);\r\n}\r\nint nfs_readpage(struct file *file, struct page *page)\r\n{\r\nstruct nfs_open_context *ctx;\r\nstruct inode *inode = page_file_mapping(page)->host;\r\nint error;\r\ndprintk("NFS: nfs_readpage (%p %ld@%lu)\n",\r\npage, PAGE_CACHE_SIZE, page_file_index(page));\r\nnfs_inc_stats(inode, NFSIOS_VFSREADPAGE);\r\nnfs_add_stats(inode, NFSIOS_READPAGES, 1);\r\nerror = nfs_wb_page(inode, page);\r\nif (error)\r\ngoto out_unlock;\r\nif (PageUptodate(page))\r\ngoto out_unlock;\r\nerror = -ESTALE;\r\nif (NFS_STALE(inode))\r\ngoto out_unlock;\r\nif (file == NULL) {\r\nerror = -EBADF;\r\nctx = nfs_find_open_context(inode, NULL, FMODE_READ);\r\nif (ctx == NULL)\r\ngoto out_unlock;\r\n} else\r\nctx = get_nfs_open_context(nfs_file_open_context(file));\r\nif (!IS_SYNC(inode)) {\r\nerror = nfs_readpage_from_fscache(ctx, inode, page);\r\nif (error == 0)\r\ngoto out;\r\n}\r\nerror = nfs_readpage_async(ctx, inode, page);\r\nout:\r\nput_nfs_open_context(ctx);\r\nreturn error;\r\nout_unlock:\r\nunlock_page(page);\r\nreturn error;\r\n}\r\nstatic int\r\nreadpage_async_filler(void *data, struct page *page)\r\n{\r\nstruct nfs_readdesc *desc = (struct nfs_readdesc *)data;\r\nstruct inode *inode = page_file_mapping(page)->host;\r\nstruct nfs_page *new;\r\nunsigned int len;\r\nint error;\r\nlen = nfs_page_length(page);\r\nif (len == 0)\r\nreturn nfs_return_empty_page(page);\r\nnew = nfs_create_request(desc->ctx, inode, page, 0, len);\r\nif (IS_ERR(new))\r\ngoto out_error;\r\nif (len < PAGE_CACHE_SIZE)\r\nzero_user_segment(page, len, PAGE_CACHE_SIZE);\r\nif (!nfs_pageio_add_request(desc->pgio, new)) {\r\nerror = desc->pgio->pg_error;\r\ngoto out_unlock;\r\n}\r\nreturn 0;\r\nout_error:\r\nerror = PTR_ERR(new);\r\nout_unlock:\r\nunlock_page(page);\r\nreturn error;\r\n}\r\nint nfs_readpages(struct file *filp, struct address_space *mapping,\r\nstruct list_head *pages, unsigned nr_pages)\r\n{\r\nstruct nfs_pageio_descriptor pgio;\r\nstruct nfs_readdesc desc = {\r\n.pgio = &pgio,\r\n};\r\nstruct inode *inode = mapping->host;\r\nunsigned long npages;\r\nint ret = -ESTALE;\r\ndprintk("NFS: nfs_readpages (%s/%Ld %d)\n",\r\ninode->i_sb->s_id,\r\n(long long)NFS_FILEID(inode),\r\nnr_pages);\r\nnfs_inc_stats(inode, NFSIOS_VFSREADPAGES);\r\nif (NFS_STALE(inode))\r\ngoto out;\r\nif (filp == NULL) {\r\ndesc.ctx = nfs_find_open_context(inode, NULL, FMODE_READ);\r\nif (desc.ctx == NULL)\r\nreturn -EBADF;\r\n} else\r\ndesc.ctx = get_nfs_open_context(nfs_file_open_context(filp));\r\nret = nfs_readpages_from_fscache(desc.ctx, inode, mapping,\r\npages, &nr_pages);\r\nif (ret == 0)\r\ngoto read_complete;\r\nNFS_PROTO(inode)->read_pageio_init(&pgio, inode, &nfs_async_read_completion_ops);\r\nret = read_cache_pages(mapping, pages, readpage_async_filler, &desc);\r\nnfs_pageio_complete(&pgio);\r\nNFS_I(inode)->read_io += pgio.pg_bytes_written;\r\nnpages = (pgio.pg_bytes_written + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\r\nnfs_add_stats(inode, NFSIOS_READPAGES, npages);\r\nread_complete:\r\nput_nfs_open_context(desc.ctx);\r\nout:\r\nreturn ret;\r\n}\r\nint __init nfs_init_readpagecache(void)\r\n{\r\nnfs_rdata_cachep = kmem_cache_create("nfs_read_data",\r\nsizeof(struct nfs_read_header),\r\n0, SLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (nfs_rdata_cachep == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid nfs_destroy_readpagecache(void)\r\n{\r\nkmem_cache_destroy(nfs_rdata_cachep);\r\n}
