static void nforce2_set_reference(struct i2c_adapter *adap)\r\n{\r\nnforce2_smbus = adap;\r\n}\r\nstatic inline void nforce2_set_reference(struct i2c_adapter *adap) { }\r\nstatic void nforce2_abort(struct i2c_adapter *adap)\r\n{\r\nstruct nforce2_smbus *smbus = adap->algo_data;\r\nint timeout = 0;\r\nunsigned char temp;\r\ndev_dbg(&adap->dev, "Aborting current transaction\n");\r\noutb_p(NVIDIA_SMB_CTRL_ABORT, NVIDIA_SMB_CTRL);\r\ndo {\r\nmsleep(1);\r\ntemp = inb_p(NVIDIA_SMB_STATUS_ABRT);\r\n} while (!(temp & NVIDIA_SMB_STATUS_ABRT_STS) &&\r\n(timeout++ < MAX_TIMEOUT));\r\nif (!(temp & NVIDIA_SMB_STATUS_ABRT_STS))\r\ndev_err(&adap->dev, "Can't reset the smbus\n");\r\noutb_p(NVIDIA_SMB_STATUS_ABRT_STS, NVIDIA_SMB_STATUS_ABRT);\r\n}\r\nstatic int nforce2_check_status(struct i2c_adapter *adap)\r\n{\r\nstruct nforce2_smbus *smbus = adap->algo_data;\r\nint timeout = 0;\r\nunsigned char temp;\r\ndo {\r\nmsleep(1);\r\ntemp = inb_p(NVIDIA_SMB_STS);\r\n} while ((!temp) && (timeout++ < MAX_TIMEOUT));\r\nif (timeout > MAX_TIMEOUT) {\r\ndev_dbg(&adap->dev, "SMBus Timeout!\n");\r\nif (smbus->can_abort)\r\nnforce2_abort(adap);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!(temp & NVIDIA_SMB_STS_DONE) || (temp & NVIDIA_SMB_STS_STATUS)) {\r\ndev_dbg(&adap->dev, "Transaction failed (0x%02x)!\n", temp);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 nforce2_access(struct i2c_adapter * adap, u16 addr,\r\nunsigned short flags, char read_write,\r\nu8 command, int size, union i2c_smbus_data * data)\r\n{\r\nstruct nforce2_smbus *smbus = adap->algo_data;\r\nunsigned char protocol, pec;\r\nu8 len;\r\nint i, status;\r\nprotocol = (read_write == I2C_SMBUS_READ) ? NVIDIA_SMB_PRTCL_READ :\r\nNVIDIA_SMB_PRTCL_WRITE;\r\npec = (flags & I2C_CLIENT_PEC) ? NVIDIA_SMB_PRTCL_PEC : 0;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\nprotocol |= NVIDIA_SMB_PRTCL_QUICK;\r\nread_write = I2C_SMBUS_WRITE;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\nif (read_write == I2C_SMBUS_WRITE)\r\noutb_p(command, NVIDIA_SMB_CMD);\r\nprotocol |= NVIDIA_SMB_PRTCL_BYTE;\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\noutb_p(command, NVIDIA_SMB_CMD);\r\nif (read_write == I2C_SMBUS_WRITE)\r\noutb_p(data->byte, NVIDIA_SMB_DATA);\r\nprotocol |= NVIDIA_SMB_PRTCL_BYTE_DATA;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\noutb_p(command, NVIDIA_SMB_CMD);\r\nif (read_write == I2C_SMBUS_WRITE) {\r\noutb_p(data->word, NVIDIA_SMB_DATA);\r\noutb_p(data->word >> 8, NVIDIA_SMB_DATA+1);\r\n}\r\nprotocol |= NVIDIA_SMB_PRTCL_WORD_DATA | pec;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\noutb_p(command, NVIDIA_SMB_CMD);\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nlen = data->block[0];\r\nif ((len == 0) || (len > I2C_SMBUS_BLOCK_MAX)) {\r\ndev_err(&adap->dev,\r\n"Transaction failed "\r\n"(requested block size: %d)\n",\r\nlen);\r\nreturn -EINVAL;\r\n}\r\noutb_p(len, NVIDIA_SMB_BCNT);\r\nfor (i = 0; i < I2C_SMBUS_BLOCK_MAX; i++)\r\noutb_p(data->block[i + 1],\r\nNVIDIA_SMB_DATA+i);\r\n}\r\nprotocol |= NVIDIA_SMB_PRTCL_BLOCK_DATA | pec;\r\nbreak;\r\ndefault:\r\ndev_err(&adap->dev, "Unsupported transaction %d\n", size);\r\nreturn -EOPNOTSUPP;\r\n}\r\noutb_p((addr & 0x7f) << 1, NVIDIA_SMB_ADDR);\r\noutb_p(protocol, NVIDIA_SMB_PRTCL);\r\nstatus = nforce2_check_status(adap);\r\nif (status)\r\nreturn status;\r\nif (read_write == I2C_SMBUS_WRITE)\r\nreturn 0;\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE:\r\ncase I2C_SMBUS_BYTE_DATA:\r\ndata->byte = inb_p(NVIDIA_SMB_DATA);\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\ndata->word = inb_p(NVIDIA_SMB_DATA) | (inb_p(NVIDIA_SMB_DATA+1) << 8);\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nlen = inb_p(NVIDIA_SMB_BCNT);\r\nif ((len <= 0) || (len > I2C_SMBUS_BLOCK_MAX)) {\r\ndev_err(&adap->dev, "Transaction failed "\r\n"(received block size: 0x%02x)\n",\r\nlen);\r\nreturn -EPROTO;\r\n}\r\nfor (i = 0; i < len; i++)\r\ndata->block[i+1] = inb_p(NVIDIA_SMB_DATA + i);\r\ndata->block[0] = len;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 nforce2_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_PEC |\r\n(((struct nforce2_smbus*)adapter->algo_data)->blockops ?\r\nI2C_FUNC_SMBUS_BLOCK_DATA : 0);\r\n}\r\nstatic int __devinit nforce2_probe_smb (struct pci_dev *dev, int bar,\r\nint alt_reg, struct nforce2_smbus *smbus, const char *name)\r\n{\r\nint error;\r\nsmbus->base = pci_resource_start(dev, bar);\r\nif (smbus->base) {\r\nsmbus->size = pci_resource_len(dev, bar);\r\n} else {\r\nu16 iobase;\r\nif (pci_read_config_word(dev, alt_reg, &iobase)\r\n!= PCIBIOS_SUCCESSFUL) {\r\ndev_err(&dev->dev, "Error reading PCI config for %s\n",\r\nname);\r\nreturn -EIO;\r\n}\r\nsmbus->base = iobase & PCI_BASE_ADDRESS_IO_MASK;\r\nsmbus->size = 64;\r\n}\r\nerror = acpi_check_region(smbus->base, smbus->size,\r\nnforce2_driver.name);\r\nif (error)\r\nreturn error;\r\nif (!request_region(smbus->base, smbus->size, nforce2_driver.name)) {\r\ndev_err(&smbus->adapter.dev, "Error requesting region %02x .. %02X for %s\n",\r\nsmbus->base, smbus->base+smbus->size-1, name);\r\nreturn -EBUSY;\r\n}\r\nsmbus->adapter.owner = THIS_MODULE;\r\nsmbus->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nsmbus->adapter.algo = &smbus_algorithm;\r\nsmbus->adapter.algo_data = smbus;\r\nsmbus->adapter.dev.parent = &dev->dev;\r\nsnprintf(smbus->adapter.name, sizeof(smbus->adapter.name),\r\n"SMBus nForce2 adapter at %04x", smbus->base);\r\nerror = i2c_add_adapter(&smbus->adapter);\r\nif (error) {\r\ndev_err(&smbus->adapter.dev, "Failed to register adapter.\n");\r\nrelease_region(smbus->base, smbus->size);\r\nreturn error;\r\n}\r\ndev_info(&smbus->adapter.dev, "nForce2 SMBus adapter at %#x\n", smbus->base);\r\nreturn 0;\r\n}\r\nstatic int __devinit nforce2_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct nforce2_smbus *smbuses;\r\nint res1, res2;\r\nif (!(smbuses = kzalloc(2*sizeof(struct nforce2_smbus), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\npci_set_drvdata(dev, smbuses);\r\nswitch(dev->device) {\r\ncase PCI_DEVICE_ID_NVIDIA_NFORCE2_SMBUS:\r\ncase PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_SMBUS:\r\ncase PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_SMBUS:\r\nsmbuses[0].blockops = 1;\r\nsmbuses[1].blockops = 1;\r\nsmbuses[0].can_abort = 1;\r\nsmbuses[1].can_abort = 1;\r\n}\r\nres1 = nforce2_probe_smb(dev, 4, NFORCE_PCI_SMB1, &smbuses[0], "SMB1");\r\nif (res1 < 0)\r\nsmbuses[0].base = 0;\r\nif (dmi_check_system(nforce2_dmi_blacklist2)) {\r\ndev_err(&dev->dev, "Disabling SMB2 for safety reasons.\n");\r\nres2 = -EPERM;\r\nsmbuses[1].base = 0;\r\n} else {\r\nres2 = nforce2_probe_smb(dev, 5, NFORCE_PCI_SMB2, &smbuses[1],\r\n"SMB2");\r\nif (res2 < 0)\r\nsmbuses[1].base = 0;\r\n}\r\nif ((res1 < 0) && (res2 < 0)) {\r\nkfree(smbuses);\r\nreturn -ENODEV;\r\n}\r\nnforce2_set_reference(&smbuses[0].adapter);\r\nreturn 0;\r\n}\r\nstatic void __devexit nforce2_remove(struct pci_dev *dev)\r\n{\r\nstruct nforce2_smbus *smbuses = pci_get_drvdata(dev);\r\nnforce2_set_reference(NULL);\r\nif (smbuses[0].base) {\r\ni2c_del_adapter(&smbuses[0].adapter);\r\nrelease_region(smbuses[0].base, smbuses[0].size);\r\n}\r\nif (smbuses[1].base) {\r\ni2c_del_adapter(&smbuses[1].adapter);\r\nrelease_region(smbuses[1].base, smbuses[1].size);\r\n}\r\nkfree(smbuses);\r\n}
