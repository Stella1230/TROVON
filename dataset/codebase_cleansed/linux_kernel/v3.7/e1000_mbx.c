s32 igb_read_mbx(struct e1000_hw *hw, u32 *msg, u16 size, u16 mbx_id)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\ns32 ret_val = -E1000_ERR_MBX;\r\nif (size > mbx->size)\r\nsize = mbx->size;\r\nif (mbx->ops.read)\r\nret_val = mbx->ops.read(hw, msg, size, mbx_id);\r\nreturn ret_val;\r\n}\r\ns32 igb_write_mbx(struct e1000_hw *hw, u32 *msg, u16 size, u16 mbx_id)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\ns32 ret_val = 0;\r\nif (size > mbx->size)\r\nret_val = -E1000_ERR_MBX;\r\nelse if (mbx->ops.write)\r\nret_val = mbx->ops.write(hw, msg, size, mbx_id);\r\nreturn ret_val;\r\n}\r\ns32 igb_check_for_msg(struct e1000_hw *hw, u16 mbx_id)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\ns32 ret_val = -E1000_ERR_MBX;\r\nif (mbx->ops.check_for_msg)\r\nret_val = mbx->ops.check_for_msg(hw, mbx_id);\r\nreturn ret_val;\r\n}\r\ns32 igb_check_for_ack(struct e1000_hw *hw, u16 mbx_id)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\ns32 ret_val = -E1000_ERR_MBX;\r\nif (mbx->ops.check_for_ack)\r\nret_val = mbx->ops.check_for_ack(hw, mbx_id);\r\nreturn ret_val;\r\n}\r\ns32 igb_check_for_rst(struct e1000_hw *hw, u16 mbx_id)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\ns32 ret_val = -E1000_ERR_MBX;\r\nif (mbx->ops.check_for_rst)\r\nret_val = mbx->ops.check_for_rst(hw, mbx_id);\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_poll_for_msg(struct e1000_hw *hw, u16 mbx_id)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\nint countdown = mbx->timeout;\r\nif (!countdown || !mbx->ops.check_for_msg)\r\ngoto out;\r\nwhile (countdown && mbx->ops.check_for_msg(hw, mbx_id)) {\r\ncountdown--;\r\nif (!countdown)\r\nbreak;\r\nudelay(mbx->usec_delay);\r\n}\r\nif (!countdown)\r\nmbx->timeout = 0;\r\nout:\r\nreturn countdown ? 0 : -E1000_ERR_MBX;\r\n}\r\nstatic s32 igb_poll_for_ack(struct e1000_hw *hw, u16 mbx_id)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\nint countdown = mbx->timeout;\r\nif (!countdown || !mbx->ops.check_for_ack)\r\ngoto out;\r\nwhile (countdown && mbx->ops.check_for_ack(hw, mbx_id)) {\r\ncountdown--;\r\nif (!countdown)\r\nbreak;\r\nudelay(mbx->usec_delay);\r\n}\r\nif (!countdown)\r\nmbx->timeout = 0;\r\nout:\r\nreturn countdown ? 0 : -E1000_ERR_MBX;\r\n}\r\nstatic s32 igb_read_posted_mbx(struct e1000_hw *hw, u32 *msg, u16 size, u16 mbx_id)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\ns32 ret_val = -E1000_ERR_MBX;\r\nif (!mbx->ops.read)\r\ngoto out;\r\nret_val = igb_poll_for_msg(hw, mbx_id);\r\nif (!ret_val)\r\nret_val = mbx->ops.read(hw, msg, size, mbx_id);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_write_posted_mbx(struct e1000_hw *hw, u32 *msg, u16 size, u16 mbx_id)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\ns32 ret_val = -E1000_ERR_MBX;\r\nif (!mbx->ops.write || !mbx->timeout)\r\ngoto out;\r\nret_val = mbx->ops.write(hw, msg, size, mbx_id);\r\nif (!ret_val)\r\nret_val = igb_poll_for_ack(hw, mbx_id);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_check_for_bit_pf(struct e1000_hw *hw, u32 mask)\r\n{\r\nu32 mbvficr = rd32(E1000_MBVFICR);\r\ns32 ret_val = -E1000_ERR_MBX;\r\nif (mbvficr & mask) {\r\nret_val = 0;\r\nwr32(E1000_MBVFICR, mask);\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_check_for_msg_pf(struct e1000_hw *hw, u16 vf_number)\r\n{\r\ns32 ret_val = -E1000_ERR_MBX;\r\nif (!igb_check_for_bit_pf(hw, E1000_MBVFICR_VFREQ_VF1 << vf_number)) {\r\nret_val = 0;\r\nhw->mbx.stats.reqs++;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_check_for_ack_pf(struct e1000_hw *hw, u16 vf_number)\r\n{\r\ns32 ret_val = -E1000_ERR_MBX;\r\nif (!igb_check_for_bit_pf(hw, E1000_MBVFICR_VFACK_VF1 << vf_number)) {\r\nret_val = 0;\r\nhw->mbx.stats.acks++;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_check_for_rst_pf(struct e1000_hw *hw, u16 vf_number)\r\n{\r\nu32 vflre = rd32(E1000_VFLRE);\r\ns32 ret_val = -E1000_ERR_MBX;\r\nif (vflre & (1 << vf_number)) {\r\nret_val = 0;\r\nwr32(E1000_VFLRE, (1 << vf_number));\r\nhw->mbx.stats.rsts++;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_obtain_mbx_lock_pf(struct e1000_hw *hw, u16 vf_number)\r\n{\r\ns32 ret_val = -E1000_ERR_MBX;\r\nu32 p2v_mailbox;\r\nwr32(E1000_P2VMAILBOX(vf_number), E1000_P2VMAILBOX_PFU);\r\np2v_mailbox = rd32(E1000_P2VMAILBOX(vf_number));\r\nif (p2v_mailbox & E1000_P2VMAILBOX_PFU)\r\nret_val = 0;\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_write_mbx_pf(struct e1000_hw *hw, u32 *msg, u16 size,\r\nu16 vf_number)\r\n{\r\ns32 ret_val;\r\nu16 i;\r\nret_val = igb_obtain_mbx_lock_pf(hw, vf_number);\r\nif (ret_val)\r\ngoto out_no_write;\r\nigb_check_for_msg_pf(hw, vf_number);\r\nigb_check_for_ack_pf(hw, vf_number);\r\nfor (i = 0; i < size; i++)\r\narray_wr32(E1000_VMBMEM(vf_number), i, msg[i]);\r\nwr32(E1000_P2VMAILBOX(vf_number), E1000_P2VMAILBOX_STS);\r\nhw->mbx.stats.msgs_tx++;\r\nout_no_write:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_read_mbx_pf(struct e1000_hw *hw, u32 *msg, u16 size,\r\nu16 vf_number)\r\n{\r\ns32 ret_val;\r\nu16 i;\r\nret_val = igb_obtain_mbx_lock_pf(hw, vf_number);\r\nif (ret_val)\r\ngoto out_no_read;\r\nfor (i = 0; i < size; i++)\r\nmsg[i] = array_rd32(E1000_VMBMEM(vf_number), i);\r\nwr32(E1000_P2VMAILBOX(vf_number), E1000_P2VMAILBOX_ACK);\r\nhw->mbx.stats.msgs_rx++;\r\nout_no_read:\r\nreturn ret_val;\r\n}\r\ns32 igb_init_mbx_params_pf(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mbx_info *mbx = &hw->mbx;\r\nmbx->timeout = 0;\r\nmbx->usec_delay = 0;\r\nmbx->size = E1000_VFMAILBOX_SIZE;\r\nmbx->ops.read = igb_read_mbx_pf;\r\nmbx->ops.write = igb_write_mbx_pf;\r\nmbx->ops.read_posted = igb_read_posted_mbx;\r\nmbx->ops.write_posted = igb_write_posted_mbx;\r\nmbx->ops.check_for_msg = igb_check_for_msg_pf;\r\nmbx->ops.check_for_ack = igb_check_for_ack_pf;\r\nmbx->ops.check_for_rst = igb_check_for_rst_pf;\r\nmbx->stats.msgs_tx = 0;\r\nmbx->stats.msgs_rx = 0;\r\nmbx->stats.reqs = 0;\r\nmbx->stats.acks = 0;\r\nmbx->stats.rsts = 0;\r\nreturn 0;\r\n}
