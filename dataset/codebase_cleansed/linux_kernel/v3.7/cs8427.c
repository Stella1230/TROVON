int snd_cs8427_reg_write(struct snd_i2c_device *device, unsigned char reg,\r\nunsigned char val)\r\n{\r\nint err;\r\nunsigned char buf[2];\r\nbuf[0] = reg & 0x7f;\r\nbuf[1] = val;\r\nif ((err = snd_i2c_sendbytes(device, buf, 2)) != 2) {\r\nsnd_printk(KERN_ERR "unable to send bytes 0x%02x:0x%02x "\r\n"to CS8427 (%i)\n", buf[0], buf[1], err);\r\nreturn err < 0 ? err : -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cs8427_reg_read(struct snd_i2c_device *device, unsigned char reg)\r\n{\r\nint err;\r\nunsigned char buf;\r\nif ((err = snd_i2c_sendbytes(device, &reg, 1)) != 1) {\r\nsnd_printk(KERN_ERR "unable to send register 0x%x byte "\r\n"to CS8427\n", reg);\r\nreturn err < 0 ? err : -EIO;\r\n}\r\nif ((err = snd_i2c_readbytes(device, &buf, 1)) != 1) {\r\nsnd_printk(KERN_ERR "unable to read register 0x%x byte "\r\n"from CS8427\n", reg);\r\nreturn err < 0 ? err : -EIO;\r\n}\r\nreturn buf;\r\n}\r\nstatic int snd_cs8427_select_corudata(struct snd_i2c_device *device, int udata)\r\n{\r\nstruct cs8427 *chip = device->private_data;\r\nint err;\r\nudata = udata ? CS8427_BSEL : 0;\r\nif (udata != (chip->regmap[CS8427_REG_CSDATABUF] & udata)) {\r\nchip->regmap[CS8427_REG_CSDATABUF] &= ~CS8427_BSEL;\r\nchip->regmap[CS8427_REG_CSDATABUF] |= udata;\r\nerr = snd_cs8427_reg_write(device, CS8427_REG_CSDATABUF,\r\nchip->regmap[CS8427_REG_CSDATABUF]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cs8427_send_corudata(struct snd_i2c_device *device,\r\nint udata,\r\nunsigned char *ndata,\r\nint count)\r\n{\r\nstruct cs8427 *chip = device->private_data;\r\nchar *hw_data = udata ?\r\nchip->playback.hw_udata : chip->playback.hw_status;\r\nchar data[32];\r\nint err, idx;\r\nif (!memcmp(hw_data, ndata, count))\r\nreturn 0;\r\nif ((err = snd_cs8427_select_corudata(device, udata)) < 0)\r\nreturn err;\r\nmemcpy(hw_data, ndata, count);\r\nif (udata) {\r\nmemset(data, 0, sizeof(data));\r\nif (memcmp(hw_data, data, count) == 0) {\r\nchip->regmap[CS8427_REG_UDATABUF] &= ~CS8427_UBMMASK;\r\nchip->regmap[CS8427_REG_UDATABUF] |= CS8427_UBMZEROS |\r\nCS8427_EFTUI;\r\nerr = snd_cs8427_reg_write(device, CS8427_REG_UDATABUF,\r\nchip->regmap[CS8427_REG_UDATABUF]);\r\nreturn err < 0 ? err : 0;\r\n}\r\n}\r\ndata[0] = CS8427_REG_AUTOINC | CS8427_REG_CORU_DATABUF;\r\nfor (idx = 0; idx < count; idx++)\r\ndata[idx + 1] = bitrev8(ndata[idx]);\r\nif (snd_i2c_sendbytes(device, data, count + 1) != count + 1)\r\nreturn -EIO;\r\nreturn 1;\r\n}\r\nstatic void snd_cs8427_free(struct snd_i2c_device *device)\r\n{\r\nkfree(device->private_data);\r\n}\r\nint snd_cs8427_create(struct snd_i2c_bus *bus,\r\nunsigned char addr,\r\nunsigned int reset_timeout,\r\nstruct snd_i2c_device **r_cs8427)\r\n{\r\nstatic unsigned char initvals1[] = {\r\nCS8427_REG_CONTROL1 | CS8427_REG_AUTOINC,\r\nCS8427_SWCLK | CS8427_TCBLDIR,\r\n0x00,\r\nCS8427_TXDSERIAL | CS8427_SPDAES3RECEIVER,\r\nCS8427_RXDILRCK,\r\nCS8427_SIDEL | CS8427_SILRPOL,\r\nCS8427_SODEL | CS8427_SOLRPOL,\r\n};\r\nstatic unsigned char initvals2[] = {\r\nCS8427_REG_RECVERRMASK | CS8427_REG_AUTOINC,\r\n0xff,\r\nCS8427_CBMR | CS8427_DETCI,\r\nCS8427_UD | CS8427_EFTUI | CS8427_DETUI,\r\n};\r\nint err;\r\nstruct cs8427 *chip;\r\nstruct snd_i2c_device *device;\r\nunsigned char buf[24];\r\nif ((err = snd_i2c_device_create(bus, "CS8427",\r\nCS8427_ADDR | (addr & 7),\r\n&device)) < 0)\r\nreturn err;\r\nchip = device->private_data = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\nsnd_i2c_device_free(device);\r\nreturn -ENOMEM;\r\n}\r\ndevice->private_free = snd_cs8427_free;\r\nsnd_i2c_lock(bus);\r\nerr = snd_cs8427_reg_read(device, CS8427_REG_ID_AND_VER);\r\nif (err != CS8427_VER8427A) {\r\nsnd_printk(KERN_WARNING "invalid CS8427 signature 0x%x: "\r\n"let me try again...\n", err);\r\nerr = snd_cs8427_reg_read(device, CS8427_REG_ID_AND_VER);\r\n}\r\nif (err != CS8427_VER8427A) {\r\nsnd_i2c_unlock(bus);\r\nsnd_printk(KERN_ERR "unable to find CS8427 signature "\r\n"(expected 0x%x, read 0x%x),\n",\r\nCS8427_VER8427A, err);\r\nsnd_printk(KERN_ERR " initialization is not completed\n");\r\nreturn -EFAULT;\r\n}\r\nerr = snd_cs8427_reg_write(device, CS8427_REG_CLOCKSOURCE, 0x00);\r\nif (err < 0)\r\ngoto __fail;\r\nmemcpy(chip->regmap + (initvals1[0] & 0x7f), initvals1 + 1, 6);\r\nif ((err = snd_i2c_sendbytes(device, initvals1, 7)) != 7) {\r\nerr = err < 0 ? err : -EIO;\r\ngoto __fail;\r\n}\r\nmemset(buf, 0, 7);\r\nbuf[0] = 9;\r\nif ((err = snd_i2c_sendbytes(device, buf, 7)) != 7)\r\ngoto __fail;\r\nmemcpy(chip->regmap + (initvals2[0] & 0x7f), initvals2 + 1, 3);\r\nif ((err = snd_i2c_sendbytes(device, initvals2, 4)) != 4) {\r\nerr = err < 0 ? err : -EIO;\r\ngoto __fail;\r\n}\r\nput_unaligned_le32(SNDRV_PCM_DEFAULT_CON_SPDIF, buf);\r\nmemset(buf + 4, 0, 24 - 4);\r\nif (snd_cs8427_send_corudata(device, 0, buf, 24) < 0)\r\ngoto __fail;\r\nmemcpy(chip->playback.def_status, buf, 24);\r\nmemcpy(chip->playback.pcm_status, buf, 24);\r\nsnd_i2c_unlock(bus);\r\nif (reset_timeout < 1)\r\nreset_timeout = 1;\r\nchip->reset_timeout = reset_timeout;\r\nsnd_cs8427_reset(device);\r\n#if 0\r\n{\r\nchar buf[128];\r\nint xx;\r\nbuf[0] = 0x81;\r\nsnd_i2c_sendbytes(device, buf, 1);\r\nsnd_i2c_readbytes(device, buf, 127);\r\nfor (xx = 0; xx < 127; xx++)\r\nprintk(KERN_DEBUG "reg[0x%x] = 0x%x\n", xx+1, buf[xx]);\r\n}\r\n#endif\r\nif (r_cs8427)\r\n*r_cs8427 = device;\r\nreturn 0;\r\n__fail:\r\nsnd_i2c_unlock(bus);\r\nsnd_i2c_device_free(device);\r\nreturn err < 0 ? err : -EIO;\r\n}\r\nstatic void snd_cs8427_reset(struct snd_i2c_device *cs8427)\r\n{\r\nstruct cs8427 *chip;\r\nunsigned long end_time;\r\nint data, aes3input = 0;\r\nif (snd_BUG_ON(!cs8427))\r\nreturn;\r\nchip = cs8427->private_data;\r\nsnd_i2c_lock(cs8427->bus);\r\nif ((chip->regmap[CS8427_REG_CLOCKSOURCE] & CS8427_RXDAES3INPUT) ==\r\nCS8427_RXDAES3INPUT)\r\naes3input = 1;\r\nchip->regmap[CS8427_REG_CLOCKSOURCE] &= ~(CS8427_RUN | CS8427_RXDMASK);\r\nsnd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,\r\nchip->regmap[CS8427_REG_CLOCKSOURCE]);\r\nudelay(200);\r\nchip->regmap[CS8427_REG_CLOCKSOURCE] |= CS8427_RUN | CS8427_RXDILRCK;\r\nsnd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,\r\nchip->regmap[CS8427_REG_CLOCKSOURCE]);\r\nudelay(200);\r\nsnd_i2c_unlock(cs8427->bus);\r\nend_time = jiffies + chip->reset_timeout;\r\nwhile (time_after_eq(end_time, jiffies)) {\r\nsnd_i2c_lock(cs8427->bus);\r\ndata = snd_cs8427_reg_read(cs8427, CS8427_REG_RECVERRORS);\r\nsnd_i2c_unlock(cs8427->bus);\r\nif (!(data & CS8427_UNLOCK))\r\nbreak;\r\nschedule_timeout_uninterruptible(1);\r\n}\r\nsnd_i2c_lock(cs8427->bus);\r\nchip->regmap[CS8427_REG_CLOCKSOURCE] &= ~CS8427_RXDMASK;\r\nif (aes3input)\r\nchip->regmap[CS8427_REG_CLOCKSOURCE] |= CS8427_RXDAES3INPUT;\r\nsnd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,\r\nchip->regmap[CS8427_REG_CLOCKSOURCE]);\r\nsnd_i2c_unlock(cs8427->bus);\r\n}\r\nstatic int snd_cs8427_in_status_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 255;\r\nreturn 0;\r\n}\r\nstatic int snd_cs8427_in_status_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_i2c_device *device = snd_kcontrol_chip(kcontrol);\r\nint data;\r\nsnd_i2c_lock(device->bus);\r\ndata = snd_cs8427_reg_read(device, kcontrol->private_value);\r\nsnd_i2c_unlock(device->bus);\r\nif (data < 0)\r\nreturn data;\r\nucontrol->value.integer.value[0] = data;\r\nreturn 0;\r\n}\r\nstatic int snd_cs8427_qsubcode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = 10;\r\nreturn 0;\r\n}\r\nstatic int snd_cs8427_qsubcode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_i2c_device *device = snd_kcontrol_chip(kcontrol);\r\nunsigned char reg = CS8427_REG_QSUBCODE;\r\nint err;\r\nsnd_i2c_lock(device->bus);\r\nif ((err = snd_i2c_sendbytes(device, &reg, 1)) != 1) {\r\nsnd_printk(KERN_ERR "unable to send register 0x%x byte "\r\n"to CS8427\n", reg);\r\nsnd_i2c_unlock(device->bus);\r\nreturn err < 0 ? err : -EIO;\r\n}\r\nerr = snd_i2c_readbytes(device, ucontrol->value.bytes.data, 10);\r\nif (err != 10) {\r\nsnd_printk(KERN_ERR "unable to read Q-subcode bytes "\r\n"from CS8427\n");\r\nsnd_i2c_unlock(device->bus);\r\nreturn err < 0 ? err : -EIO;\r\n}\r\nsnd_i2c_unlock(device->bus);\r\nreturn 0;\r\n}\r\nstatic int snd_cs8427_spdif_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_cs8427_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_i2c_device *device = snd_kcontrol_chip(kcontrol);\r\nstruct cs8427 *chip = device->private_data;\r\nsnd_i2c_lock(device->bus);\r\nmemcpy(ucontrol->value.iec958.status, chip->playback.def_status, 24);\r\nsnd_i2c_unlock(device->bus);\r\nreturn 0;\r\n}\r\nstatic int snd_cs8427_spdif_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_i2c_device *device = snd_kcontrol_chip(kcontrol);\r\nstruct cs8427 *chip = device->private_data;\r\nunsigned char *status = kcontrol->private_value ?\r\nchip->playback.pcm_status : chip->playback.def_status;\r\nstruct snd_pcm_runtime *runtime = chip->playback.substream ?\r\nchip->playback.substream->runtime : NULL;\r\nint err, change;\r\nsnd_i2c_lock(device->bus);\r\nchange = memcmp(ucontrol->value.iec958.status, status, 24) != 0;\r\nmemcpy(status, ucontrol->value.iec958.status, 24);\r\nif (change && (kcontrol->private_value ?\r\nruntime != NULL : runtime == NULL)) {\r\nerr = snd_cs8427_send_corudata(device, 0, status, 24);\r\nif (err < 0)\r\nchange = err;\r\n}\r\nsnd_i2c_unlock(device->bus);\r\nreturn change;\r\n}\r\nstatic int snd_cs8427_spdif_mask_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_cs8427_spdif_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nmemset(ucontrol->value.iec958.status, 0xff, 24);\r\nreturn 0;\r\n}\r\nint snd_cs8427_iec958_build(struct snd_i2c_device *cs8427,\r\nstruct snd_pcm_substream *play_substream,\r\nstruct snd_pcm_substream *cap_substream)\r\n{\r\nstruct cs8427 *chip = cs8427->private_data;\r\nstruct snd_kcontrol *kctl;\r\nunsigned int idx;\r\nint err;\r\nif (snd_BUG_ON(!play_substream || !cap_substream))\r\nreturn -EINVAL;\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_cs8427_iec958_controls); idx++) {\r\nkctl = snd_ctl_new1(&snd_cs8427_iec958_controls[idx], cs8427);\r\nif (kctl == NULL)\r\nreturn -ENOMEM;\r\nkctl->id.device = play_substream->pcm->device;\r\nkctl->id.subdevice = play_substream->number;\r\nerr = snd_ctl_add(cs8427->bus->card, kctl);\r\nif (err < 0)\r\nreturn err;\r\nif (! strcmp(kctl->id.name,\r\nSNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM)))\r\nchip->playback.pcm_ctl = kctl;\r\n}\r\nchip->playback.substream = play_substream;\r\nchip->capture.substream = cap_substream;\r\nif (snd_BUG_ON(!chip->playback.pcm_ctl))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint snd_cs8427_iec958_active(struct snd_i2c_device *cs8427, int active)\r\n{\r\nstruct cs8427 *chip;\r\nif (snd_BUG_ON(!cs8427))\r\nreturn -ENXIO;\r\nchip = cs8427->private_data;\r\nif (active)\r\nmemcpy(chip->playback.pcm_status,\r\nchip->playback.def_status, 24);\r\nchip->playback.pcm_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(cs8427->bus->card,\r\nSNDRV_CTL_EVENT_MASK_VALUE | SNDRV_CTL_EVENT_MASK_INFO,\r\n&chip->playback.pcm_ctl->id);\r\nreturn 0;\r\n}\r\nint snd_cs8427_iec958_pcm(struct snd_i2c_device *cs8427, unsigned int rate)\r\n{\r\nstruct cs8427 *chip;\r\nchar *status;\r\nint err, reset;\r\nif (snd_BUG_ON(!cs8427))\r\nreturn -ENXIO;\r\nchip = cs8427->private_data;\r\nstatus = chip->playback.pcm_status;\r\nsnd_i2c_lock(cs8427->bus);\r\nif (status[0] & IEC958_AES0_PROFESSIONAL) {\r\nstatus[0] &= ~IEC958_AES0_PRO_FS;\r\nswitch (rate) {\r\ncase 32000: status[0] |= IEC958_AES0_PRO_FS_32000; break;\r\ncase 44100: status[0] |= IEC958_AES0_PRO_FS_44100; break;\r\ncase 48000: status[0] |= IEC958_AES0_PRO_FS_48000; break;\r\ndefault: status[0] |= IEC958_AES0_PRO_FS_NOTID; break;\r\n}\r\n} else {\r\nstatus[3] &= ~IEC958_AES3_CON_FS;\r\nswitch (rate) {\r\ncase 32000: status[3] |= IEC958_AES3_CON_FS_32000; break;\r\ncase 44100: status[3] |= IEC958_AES3_CON_FS_44100; break;\r\ncase 48000: status[3] |= IEC958_AES3_CON_FS_48000; break;\r\n}\r\n}\r\nerr = snd_cs8427_send_corudata(cs8427, 0, status, 24);\r\nif (err > 0)\r\nsnd_ctl_notify(cs8427->bus->card,\r\nSNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->playback.pcm_ctl->id);\r\nreset = chip->rate != rate;\r\nchip->rate = rate;\r\nsnd_i2c_unlock(cs8427->bus);\r\nif (reset)\r\nsnd_cs8427_reset(cs8427);\r\nreturn err < 0 ? err : 0;\r\n}\r\nstatic int __init alsa_cs8427_module_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_cs8427_module_exit(void)\r\n{\r\n}
