static struct pci_dev *next_northbridge(struct pci_dev *dev,\r\nconst struct pci_device_id *ids)\r\n{\r\ndo {\r\ndev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev);\r\nif (!dev)\r\nbreak;\r\n} while (!pci_match_id(ids, dev));\r\nreturn dev;\r\n}\r\nint amd_cache_northbridges(void)\r\n{\r\nu16 i = 0;\r\nstruct amd_northbridge *nb;\r\nstruct pci_dev *misc, *link;\r\nif (amd_nb_num())\r\nreturn 0;\r\nmisc = NULL;\r\nwhile ((misc = next_northbridge(misc, amd_nb_misc_ids)) != NULL)\r\ni++;\r\nif (i == 0)\r\nreturn 0;\r\nnb = kzalloc(i * sizeof(struct amd_northbridge), GFP_KERNEL);\r\nif (!nb)\r\nreturn -ENOMEM;\r\namd_northbridges.nb = nb;\r\namd_northbridges.num = i;\r\nlink = misc = NULL;\r\nfor (i = 0; i != amd_nb_num(); i++) {\r\nnode_to_amd_nb(i)->misc = misc =\r\nnext_northbridge(misc, amd_nb_misc_ids);\r\nnode_to_amd_nb(i)->link = link =\r\nnext_northbridge(link, amd_nb_link_ids);\r\n}\r\nif (boot_cpu_data.x86 == 0xf || boot_cpu_data.x86 == 0x10 ||\r\nboot_cpu_data.x86 == 0x15)\r\namd_northbridges.flags |= AMD_NB_GART;\r\nif (boot_cpu_data.x86 == 0x10 &&\r\nboot_cpu_data.x86_model >= 0x8 &&\r\n(boot_cpu_data.x86_model > 0x9 ||\r\nboot_cpu_data.x86_mask >= 0x1))\r\namd_northbridges.flags |= AMD_NB_L3_INDEX_DISABLE;\r\nif (boot_cpu_data.x86 == 0x15)\r\namd_northbridges.flags |= AMD_NB_L3_INDEX_DISABLE;\r\nif (boot_cpu_data.x86 == 0x15)\r\namd_northbridges.flags |= AMD_NB_L3_PARTITIONING;\r\nreturn 0;\r\n}\r\nbool __init early_is_amd_nb(u32 device)\r\n{\r\nconst struct pci_device_id *id;\r\nu32 vendor = device & 0xffff;\r\ndevice >>= 16;\r\nfor (id = amd_nb_misc_ids; id->vendor; id++)\r\nif (vendor == id->vendor && device == id->device)\r\nreturn true;\r\nreturn false;\r\n}\r\nstruct resource *amd_get_mmconfig_range(struct resource *res)\r\n{\r\nu32 address;\r\nu64 base, msr;\r\nunsigned segn_busn_bits;\r\nif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD)\r\nreturn NULL;\r\nif (boot_cpu_data.x86 < 0x10)\r\nreturn NULL;\r\naddress = MSR_FAM10H_MMIO_CONF_BASE;\r\nrdmsrl(address, msr);\r\nif (!(msr & FAM10H_MMIO_CONF_ENABLE))\r\nreturn NULL;\r\nbase = msr & (FAM10H_MMIO_CONF_BASE_MASK<<FAM10H_MMIO_CONF_BASE_SHIFT);\r\nsegn_busn_bits = (msr >> FAM10H_MMIO_CONF_BUSRANGE_SHIFT) &\r\nFAM10H_MMIO_CONF_BUSRANGE_MASK;\r\nres->flags = IORESOURCE_MEM;\r\nres->start = base;\r\nres->end = base + (1ULL<<(segn_busn_bits + 20)) - 1;\r\nreturn res;\r\n}\r\nint amd_get_subcaches(int cpu)\r\n{\r\nstruct pci_dev *link = node_to_amd_nb(amd_get_nb_id(cpu))->link;\r\nunsigned int mask;\r\nint cuid;\r\nif (!amd_nb_has_feature(AMD_NB_L3_PARTITIONING))\r\nreturn 0;\r\npci_read_config_dword(link, 0x1d4, &mask);\r\ncuid = cpu_data(cpu).compute_unit_id;\r\nreturn (mask >> (4 * cuid)) & 0xf;\r\n}\r\nint amd_set_subcaches(int cpu, int mask)\r\n{\r\nstatic unsigned int reset, ban;\r\nstruct amd_northbridge *nb = node_to_amd_nb(amd_get_nb_id(cpu));\r\nunsigned int reg;\r\nint cuid;\r\nif (!amd_nb_has_feature(AMD_NB_L3_PARTITIONING) || mask > 0xf)\r\nreturn -EINVAL;\r\nif (reset == 0) {\r\npci_read_config_dword(nb->link, 0x1d4, &reset);\r\npci_read_config_dword(nb->misc, 0x1b8, &ban);\r\nban &= 0x180000;\r\n}\r\nif (mask != 0xf) {\r\npci_read_config_dword(nb->misc, 0x1b8, &reg);\r\npci_write_config_dword(nb->misc, 0x1b8, reg & ~0x180000);\r\n}\r\ncuid = cpu_data(cpu).compute_unit_id;\r\nmask <<= 4 * cuid;\r\nmask |= (0xf ^ (1 << cuid)) << 26;\r\npci_write_config_dword(nb->link, 0x1d4, mask);\r\npci_read_config_dword(nb->link, 0x1d4, &reg);\r\nif (reg == reset) {\r\npci_read_config_dword(nb->misc, 0x1b8, &reg);\r\nreg &= ~0x180000;\r\npci_write_config_dword(nb->misc, 0x1b8, reg | ban);\r\n}\r\nreturn 0;\r\n}\r\nstatic int amd_cache_gart(void)\r\n{\r\nu16 i;\r\nif (!amd_nb_has_feature(AMD_NB_GART))\r\nreturn 0;\r\nflush_words = kmalloc(amd_nb_num() * sizeof(u32), GFP_KERNEL);\r\nif (!flush_words) {\r\namd_northbridges.flags &= ~AMD_NB_GART;\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i != amd_nb_num(); i++)\r\npci_read_config_dword(node_to_amd_nb(i)->misc, 0x9c,\r\n&flush_words[i]);\r\nreturn 0;\r\n}\r\nvoid amd_flush_garts(void)\r\n{\r\nint flushed, i;\r\nunsigned long flags;\r\nstatic DEFINE_SPINLOCK(gart_lock);\r\nif (!amd_nb_has_feature(AMD_NB_GART))\r\nreturn;\r\nspin_lock_irqsave(&gart_lock, flags);\r\nflushed = 0;\r\nfor (i = 0; i < amd_nb_num(); i++) {\r\npci_write_config_dword(node_to_amd_nb(i)->misc, 0x9c,\r\nflush_words[i] | 1);\r\nflushed++;\r\n}\r\nfor (i = 0; i < amd_nb_num(); i++) {\r\nu32 w;\r\nfor (;;) {\r\npci_read_config_dword(node_to_amd_nb(i)->misc,\r\n0x9c, &w);\r\nif (!(w & 1))\r\nbreak;\r\ncpu_relax();\r\n}\r\n}\r\nspin_unlock_irqrestore(&gart_lock, flags);\r\nif (!flushed)\r\npr_notice("nothing to flush?\n");\r\n}\r\nstatic __init int init_amd_nbs(void)\r\n{\r\nint err = 0;\r\nerr = amd_cache_northbridges();\r\nif (err < 0)\r\npr_notice("Cannot enumerate AMD northbridges\n");\r\nif (amd_cache_gart() < 0)\r\npr_notice("Cannot initialize GART flush words, GART support disabled\n");\r\nreturn err;\r\n}
