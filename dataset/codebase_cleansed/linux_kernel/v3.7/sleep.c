static void acpi_sleep_tts_switch(u32 acpi_state)\r\n{\r\nunion acpi_object in_arg = { ACPI_TYPE_INTEGER };\r\nstruct acpi_object_list arg_list = { 1, &in_arg };\r\nacpi_status status = AE_OK;\r\nin_arg.integer.value = acpi_state;\r\nstatus = acpi_evaluate_object(NULL, "\\_TTS", &arg_list, NULL);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nprintk(KERN_NOTICE "Failure in evaluating _TTS object\n");\r\n}\r\n}\r\nstatic int tts_notify_reboot(struct notifier_block *this,\r\nunsigned long code, void *x)\r\n{\r\nacpi_sleep_tts_switch(ACPI_STATE_S5);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int acpi_sleep_prepare(u32 acpi_state)\r\n{\r\n#ifdef CONFIG_ACPI_SLEEP\r\nif (acpi_state == ACPI_STATE_S3) {\r\nif (!acpi_wakeup_address)\r\nreturn -EFAULT;\r\nacpi_set_firmware_waking_vector(acpi_wakeup_address);\r\n}\r\nACPI_FLUSH_CPU_CACHE();\r\n#endif\r\nprintk(KERN_INFO PREFIX "Preparing to enter system sleep state S%d\n",\r\nacpi_state);\r\nacpi_enable_wakeup_devices(acpi_state);\r\nacpi_enter_sleep_state_prep(acpi_state);\r\nreturn 0;\r\n}\r\nvoid __init acpi_nvs_nosave(void)\r\n{\r\nnvs_nosave = true;\r\n}\r\nvoid __init acpi_old_suspend_ordering(void)\r\n{\r\nold_suspend_ordering = true;\r\n}\r\nstatic int acpi_pm_freeze(void)\r\n{\r\nacpi_disable_all_gpes();\r\nacpi_os_wait_events_complete();\r\nacpi_ec_block_transactions();\r\nreturn 0;\r\n}\r\nstatic int acpi_pm_pre_suspend(void)\r\n{\r\nacpi_pm_freeze();\r\nreturn suspend_nvs_save();\r\n}\r\nstatic int __acpi_pm_prepare(void)\r\n{\r\nint error = acpi_sleep_prepare(acpi_target_sleep_state);\r\nif (error)\r\nacpi_target_sleep_state = ACPI_STATE_S0;\r\nreturn error;\r\n}\r\nstatic int acpi_pm_prepare(void)\r\n{\r\nint error = __acpi_pm_prepare();\r\nif (!error)\r\nerror = acpi_pm_pre_suspend();\r\nreturn error;\r\n}\r\nstatic int find_powerf_dev(struct device *dev, void *data)\r\n{\r\nstruct acpi_device *device = to_acpi_device(dev);\r\nconst char *hid = acpi_device_hid(device);\r\nreturn !strcmp(hid, ACPI_BUTTON_HID_POWERF);\r\n}\r\nstatic void acpi_pm_finish(void)\r\n{\r\nstruct device *pwr_btn_dev;\r\nu32 acpi_state = acpi_target_sleep_state;\r\nacpi_ec_unblock_transactions();\r\nsuspend_nvs_free();\r\nif (acpi_state == ACPI_STATE_S0)\r\nreturn;\r\nprintk(KERN_INFO PREFIX "Waking up from system sleep state S%d\n",\r\nacpi_state);\r\nacpi_disable_wakeup_devices(acpi_state);\r\nacpi_leave_sleep_state(acpi_state);\r\nacpi_set_firmware_waking_vector((acpi_physical_address) 0);\r\nacpi_target_sleep_state = ACPI_STATE_S0;\r\nif (!pwr_btn_event_pending)\r\nreturn;\r\npwr_btn_event_pending = false;\r\npwr_btn_dev = bus_find_device(&acpi_bus_type, NULL, NULL,\r\nfind_powerf_dev);\r\nif (pwr_btn_dev) {\r\npm_wakeup_event(pwr_btn_dev, 0);\r\nput_device(pwr_btn_dev);\r\n}\r\n}\r\nstatic void acpi_pm_end(void)\r\n{\r\nacpi_target_sleep_state = ACPI_STATE_S0;\r\nacpi_sleep_tts_switch(acpi_target_sleep_state);\r\n}\r\nstatic int acpi_suspend_begin(suspend_state_t pm_state)\r\n{\r\nu32 acpi_state = acpi_suspend_states[pm_state];\r\nint error = 0;\r\nerror = nvs_nosave ? 0 : suspend_nvs_alloc();\r\nif (error)\r\nreturn error;\r\nif (sleep_states[acpi_state]) {\r\nacpi_target_sleep_state = acpi_state;\r\nacpi_sleep_tts_switch(acpi_target_sleep_state);\r\n} else {\r\nprintk(KERN_ERR "ACPI does not support this state: %d\n",\r\npm_state);\r\nerror = -ENOSYS;\r\n}\r\nreturn error;\r\n}\r\nstatic int acpi_suspend_enter(suspend_state_t pm_state)\r\n{\r\nacpi_status status = AE_OK;\r\nu32 acpi_state = acpi_target_sleep_state;\r\nint error;\r\nACPI_FLUSH_CPU_CACHE();\r\nswitch (acpi_state) {\r\ncase ACPI_STATE_S1:\r\nbarrier();\r\nstatus = acpi_enter_sleep_state(acpi_state);\r\nbreak;\r\ncase ACPI_STATE_S3:\r\nerror = acpi_suspend_lowlevel();\r\nif (error)\r\nreturn error;\r\npr_info(PREFIX "Low-level resume complete\n");\r\nbreak;\r\n}\r\nacpi_write_bit_register(ACPI_BITREG_SCI_ENABLE, 1);\r\nacpi_leave_sleep_state_prep(acpi_state);\r\nif (ACPI_SUCCESS(status) && (acpi_state == ACPI_STATE_S3)) {\r\nacpi_event_status pwr_btn_status;\r\nacpi_get_event_status(ACPI_EVENT_POWER_BUTTON, &pwr_btn_status);\r\nif (pwr_btn_status & ACPI_EVENT_FLAG_SET) {\r\nacpi_clear_event(ACPI_EVENT_POWER_BUTTON);\r\npwr_btn_event_pending = true;\r\n}\r\n}\r\nacpi_disable_all_gpes();\r\nacpi_ec_unblock_transactions_early();\r\nsuspend_nvs_restore();\r\nreturn ACPI_SUCCESS(status) ? 0 : -EFAULT;\r\n}\r\nstatic int acpi_suspend_state_valid(suspend_state_t pm_state)\r\n{\r\nu32 acpi_state;\r\nswitch (pm_state) {\r\ncase PM_SUSPEND_ON:\r\ncase PM_SUSPEND_STANDBY:\r\ncase PM_SUSPEND_MEM:\r\nacpi_state = acpi_suspend_states[pm_state];\r\nreturn sleep_states[acpi_state];\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int acpi_suspend_begin_old(suspend_state_t pm_state)\r\n{\r\nint error = acpi_suspend_begin(pm_state);\r\nif (!error)\r\nerror = __acpi_pm_prepare();\r\nreturn error;\r\n}\r\nstatic int __init init_old_suspend_ordering(const struct dmi_system_id *d)\r\n{\r\nold_suspend_ordering = true;\r\nreturn 0;\r\n}\r\nstatic int __init init_nvs_nosave(const struct dmi_system_id *d)\r\n{\r\nacpi_nvs_nosave();\r\nreturn 0;\r\n}\r\nvoid __init acpi_no_s4_hw_signature(void)\r\n{\r\nnosigcheck = true;\r\n}\r\nstatic int acpi_hibernation_begin(void)\r\n{\r\nint error;\r\nerror = nvs_nosave ? 0 : suspend_nvs_alloc();\r\nif (!error) {\r\nacpi_target_sleep_state = ACPI_STATE_S4;\r\nacpi_sleep_tts_switch(acpi_target_sleep_state);\r\n}\r\nreturn error;\r\n}\r\nstatic int acpi_hibernation_enter(void)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FLUSH_CPU_CACHE();\r\nstatus = acpi_enter_sleep_state(ACPI_STATE_S4);\r\nacpi_leave_sleep_state_prep(ACPI_STATE_S4);\r\nreturn ACPI_SUCCESS(status) ? 0 : -EFAULT;\r\n}\r\nstatic void acpi_hibernation_leave(void)\r\n{\r\nacpi_enable();\r\nacpi_leave_sleep_state_prep(ACPI_STATE_S4);\r\nif (facs && s4_hardware_signature != facs->hardware_signature) {\r\nprintk(KERN_EMERG "ACPI: Hardware changed while hibernated, "\r\n"cannot resume!\n");\r\npanic("ACPI S4 hardware signature mismatch");\r\n}\r\nsuspend_nvs_restore();\r\nacpi_ec_unblock_transactions_early();\r\n}\r\nstatic void acpi_pm_thaw(void)\r\n{\r\nacpi_ec_unblock_transactions();\r\nacpi_enable_all_runtime_gpes();\r\n}\r\nstatic int acpi_hibernation_begin_old(void)\r\n{\r\nint error;\r\nacpi_sleep_tts_switch(ACPI_STATE_S4);\r\nerror = acpi_sleep_prepare(ACPI_STATE_S4);\r\nif (!error) {\r\nif (!nvs_nosave)\r\nerror = suspend_nvs_alloc();\r\nif (!error)\r\nacpi_target_sleep_state = ACPI_STATE_S4;\r\n}\r\nreturn error;\r\n}\r\nint acpi_suspend(u32 acpi_state)\r\n{\r\nsuspend_state_t states[] = {\r\n[1] = PM_SUSPEND_STANDBY,\r\n[3] = PM_SUSPEND_MEM,\r\n[5] = PM_SUSPEND_MAX\r\n};\r\nif (acpi_state < 6 && states[acpi_state])\r\nreturn pm_suspend(states[acpi_state]);\r\nif (acpi_state == 4)\r\nreturn hibernate();\r\nreturn -EINVAL;\r\n}\r\nint acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)\r\n{\r\nacpi_handle handle = DEVICE_ACPI_HANDLE(dev);\r\nstruct acpi_device *adev;\r\nchar acpi_method[] = "_SxD";\r\nunsigned long long d_min, d_max;\r\nif (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3)\r\nreturn -EINVAL;\r\nif (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {\r\nprintk(KERN_DEBUG "ACPI handle has no context!\n");\r\nreturn -ENODEV;\r\n}\r\nacpi_method[2] = '0' + acpi_target_sleep_state;\r\nd_min = ACPI_STATE_D0;\r\nd_max = ACPI_STATE_D3;\r\nif (acpi_target_sleep_state > ACPI_STATE_S0)\r\nacpi_evaluate_integer(handle, acpi_method, NULL, &d_min);\r\nif (acpi_target_sleep_state == ACPI_STATE_S0 ||\r\n(device_may_wakeup(dev) && adev->wakeup.flags.valid &&\r\nadev->wakeup.sleep_state >= acpi_target_sleep_state)) {\r\nacpi_status status;\r\nacpi_method[3] = 'W';\r\nstatus = acpi_evaluate_integer(handle, acpi_method, NULL,\r\n&d_max);\r\nif (ACPI_FAILURE(status)) {\r\nif (acpi_target_sleep_state != ACPI_STATE_S0 ||\r\nstatus != AE_NOT_FOUND)\r\nd_max = d_min;\r\n} else if (d_max < d_min) {\r\nprintk(KERN_WARNING "ACPI: Wrong value from %s\n",\r\nacpi_method);\r\nd_min = d_max;\r\n}\r\n}\r\nif (d_max_in < d_min)\r\nreturn -EINVAL;\r\nif (d_min_p)\r\n*d_min_p = d_min;\r\nif (d_max > d_max_in) {\r\nfor (d_max = d_max_in; d_max > d_min; d_max--) {\r\nif (adev->power.states[d_max].flags.valid)\r\nbreak;\r\n}\r\n}\r\nreturn d_max;\r\n}\r\nint acpi_pm_device_run_wake(struct device *phys_dev, bool enable)\r\n{\r\nstruct acpi_device *dev;\r\nacpi_handle handle;\r\nif (!device_run_wake(phys_dev))\r\nreturn -EINVAL;\r\nhandle = DEVICE_ACPI_HANDLE(phys_dev);\r\nif (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &dev))) {\r\ndev_dbg(phys_dev, "ACPI handle has no context in %s!\n",\r\n__func__);\r\nreturn -ENODEV;\r\n}\r\nif (enable) {\r\nacpi_enable_wakeup_device_power(dev, ACPI_STATE_S0);\r\nacpi_enable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);\r\n} else {\r\nacpi_disable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);\r\nacpi_disable_wakeup_device_power(dev);\r\n}\r\nreturn 0;\r\n}\r\nint acpi_pm_device_sleep_wake(struct device *dev, bool enable)\r\n{\r\nacpi_handle handle;\r\nstruct acpi_device *adev;\r\nint error;\r\nif (!device_can_wakeup(dev))\r\nreturn -EINVAL;\r\nhandle = DEVICE_ACPI_HANDLE(dev);\r\nif (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &adev))) {\r\ndev_dbg(dev, "ACPI handle has no context in %s!\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nerror = enable ?\r\nacpi_enable_wakeup_device_power(adev, acpi_target_sleep_state) :\r\nacpi_disable_wakeup_device_power(adev);\r\nif (!error)\r\ndev_info(dev, "wake-up capability %s by ACPI\n",\r\nenable ? "enabled" : "disabled");\r\nreturn error;\r\n}\r\nstatic void acpi_power_off_prepare(void)\r\n{\r\nacpi_sleep_prepare(ACPI_STATE_S5);\r\nacpi_disable_all_gpes();\r\n}\r\nstatic void acpi_power_off(void)\r\n{\r\nprintk(KERN_DEBUG "%s called\n", __func__);\r\nlocal_irq_disable();\r\nacpi_enter_sleep_state(ACPI_STATE_S5);\r\n}\r\nint __init acpi_sleep_init(void)\r\n{\r\nacpi_status status;\r\nu8 type_a, type_b;\r\n#ifdef CONFIG_SUSPEND\r\nint i = 0;\r\ndmi_check_system(acpisleep_dmi_table);\r\n#endif\r\nif (acpi_disabled)\r\nreturn 0;\r\nsleep_states[ACPI_STATE_S0] = 1;\r\nprintk(KERN_INFO PREFIX "(supports S0");\r\n#ifdef CONFIG_SUSPEND\r\nfor (i = ACPI_STATE_S1; i < ACPI_STATE_S4; i++) {\r\nstatus = acpi_get_sleep_type_data(i, &type_a, &type_b);\r\nif (ACPI_SUCCESS(status)) {\r\nsleep_states[i] = 1;\r\nprintk(KERN_CONT " S%d", i);\r\n}\r\n}\r\nsuspend_set_ops(old_suspend_ordering ?\r\n&acpi_suspend_ops_old : &acpi_suspend_ops);\r\n#endif\r\n#ifdef CONFIG_HIBERNATION\r\nstatus = acpi_get_sleep_type_data(ACPI_STATE_S4, &type_a, &type_b);\r\nif (ACPI_SUCCESS(status)) {\r\nhibernation_set_ops(old_suspend_ordering ?\r\n&acpi_hibernation_ops_old : &acpi_hibernation_ops);\r\nsleep_states[ACPI_STATE_S4] = 1;\r\nprintk(KERN_CONT " S4");\r\nif (!nosigcheck) {\r\nacpi_get_table(ACPI_SIG_FACS, 1,\r\n(struct acpi_table_header **)&facs);\r\nif (facs)\r\ns4_hardware_signature =\r\nfacs->hardware_signature;\r\n}\r\n}\r\n#endif\r\nstatus = acpi_get_sleep_type_data(ACPI_STATE_S5, &type_a, &type_b);\r\nif (ACPI_SUCCESS(status)) {\r\nsleep_states[ACPI_STATE_S5] = 1;\r\nprintk(KERN_CONT " S5");\r\npm_power_off_prepare = acpi_power_off_prepare;\r\npm_power_off = acpi_power_off;\r\n}\r\nprintk(KERN_CONT ")\n");\r\nregister_reboot_notifier(&tts_notifier);\r\nreturn 0;\r\n}
