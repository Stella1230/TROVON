static void __ebus_dma_reset(struct ebus_dma_info *p, int no_drain)\r\n{\r\nint i;\r\nu32 val = 0;\r\nwritel(EBDMA_CSR_RESET, p->regs + EBDMA_CSR);\r\nudelay(1);\r\nif (no_drain)\r\nreturn;\r\nfor (i = EBUS_DMA_RESET_TIMEOUT; i > 0; i--) {\r\nval = readl(p->regs + EBDMA_CSR);\r\nif (!(val & (EBDMA_CSR_DRAIN | EBDMA_CSR_CYC_PEND)))\r\nbreak;\r\nudelay(10);\r\n}\r\n}\r\nstatic irqreturn_t ebus_dma_irq(int irq, void *dev_id)\r\n{\r\nstruct ebus_dma_info *p = dev_id;\r\nunsigned long flags;\r\nu32 csr = 0;\r\nspin_lock_irqsave(&p->lock, flags);\r\ncsr = readl(p->regs + EBDMA_CSR);\r\nwritel(csr, p->regs + EBDMA_CSR);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\nif (csr & EBDMA_CSR_ERR_PEND) {\r\nprintk(KERN_CRIT "ebus_dma(%s): DMA error!\n", p->name);\r\np->callback(p, EBUS_DMA_EVENT_ERROR, p->client_cookie);\r\nreturn IRQ_HANDLED;\r\n} else if (csr & EBDMA_CSR_INT_PEND) {\r\np->callback(p,\r\n(csr & EBDMA_CSR_TC) ?\r\nEBUS_DMA_EVENT_DMA : EBUS_DMA_EVENT_DEVICE,\r\np->client_cookie);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nint ebus_dma_register(struct ebus_dma_info *p)\r\n{\r\nu32 csr;\r\nif (!p->regs)\r\nreturn -EINVAL;\r\nif (p->flags & ~(EBUS_DMA_FLAG_USE_EBDMA_HANDLER |\r\nEBUS_DMA_FLAG_TCI_DISABLE))\r\nreturn -EINVAL;\r\nif ((p->flags & EBUS_DMA_FLAG_USE_EBDMA_HANDLER) && !p->callback)\r\nreturn -EINVAL;\r\nif (!strlen(p->name))\r\nreturn -EINVAL;\r\n__ebus_dma_reset(p, 1);\r\ncsr = EBDMA_CSR_BURST_SZ_16 | EBDMA_CSR_EN_CNT;\r\nif (p->flags & EBUS_DMA_FLAG_TCI_DISABLE)\r\ncsr |= EBDMA_CSR_TCI_DIS;\r\nwritel(csr, p->regs + EBDMA_CSR);\r\nreturn 0;\r\n}\r\nint ebus_dma_irq_enable(struct ebus_dma_info *p, int on)\r\n{\r\nunsigned long flags;\r\nu32 csr;\r\nif (on) {\r\nif (p->flags & EBUS_DMA_FLAG_USE_EBDMA_HANDLER) {\r\nif (request_irq(p->irq, ebus_dma_irq, IRQF_SHARED, p->name, p))\r\nreturn -EBUSY;\r\n}\r\nspin_lock_irqsave(&p->lock, flags);\r\ncsr = readl(p->regs + EBDMA_CSR);\r\ncsr |= EBDMA_CSR_INT_EN;\r\nwritel(csr, p->regs + EBDMA_CSR);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n} else {\r\nspin_lock_irqsave(&p->lock, flags);\r\ncsr = readl(p->regs + EBDMA_CSR);\r\ncsr &= ~EBDMA_CSR_INT_EN;\r\nwritel(csr, p->regs + EBDMA_CSR);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\nif (p->flags & EBUS_DMA_FLAG_USE_EBDMA_HANDLER) {\r\nfree_irq(p->irq, p);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid ebus_dma_unregister(struct ebus_dma_info *p)\r\n{\r\nunsigned long flags;\r\nu32 csr;\r\nint irq_on = 0;\r\nspin_lock_irqsave(&p->lock, flags);\r\ncsr = readl(p->regs + EBDMA_CSR);\r\nif (csr & EBDMA_CSR_INT_EN) {\r\ncsr &= ~EBDMA_CSR_INT_EN;\r\nwritel(csr, p->regs + EBDMA_CSR);\r\nirq_on = 1;\r\n}\r\nspin_unlock_irqrestore(&p->lock, flags);\r\nif (irq_on)\r\nfree_irq(p->irq, p);\r\n}\r\nint ebus_dma_request(struct ebus_dma_info *p, dma_addr_t bus_addr, size_t len)\r\n{\r\nunsigned long flags;\r\nu32 csr;\r\nint err;\r\nif (len >= (1 << 24))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&p->lock, flags);\r\ncsr = readl(p->regs + EBDMA_CSR);\r\nerr = -EINVAL;\r\nif (!(csr & EBDMA_CSR_EN_DMA))\r\ngoto out;\r\nerr = -EBUSY;\r\nif (csr & EBDMA_CSR_NA_LOADED)\r\ngoto out;\r\nwritel(len, p->regs + EBDMA_COUNT);\r\nwritel(bus_addr, p->regs + EBDMA_ADDR);\r\nerr = 0;\r\nout:\r\nspin_unlock_irqrestore(&p->lock, flags);\r\nreturn err;\r\n}\r\nvoid ebus_dma_prepare(struct ebus_dma_info *p, int write)\r\n{\r\nunsigned long flags;\r\nu32 csr;\r\nspin_lock_irqsave(&p->lock, flags);\r\n__ebus_dma_reset(p, 0);\r\ncsr = (EBDMA_CSR_INT_EN |\r\nEBDMA_CSR_EN_CNT |\r\nEBDMA_CSR_BURST_SZ_16 |\r\nEBDMA_CSR_EN_NEXT);\r\nif (write)\r\ncsr |= EBDMA_CSR_WRITE;\r\nif (p->flags & EBUS_DMA_FLAG_TCI_DISABLE)\r\ncsr |= EBDMA_CSR_TCI_DIS;\r\nwritel(csr, p->regs + EBDMA_CSR);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nunsigned int ebus_dma_residue(struct ebus_dma_info *p)\r\n{\r\nreturn readl(p->regs + EBDMA_COUNT);\r\n}\r\nunsigned int ebus_dma_addr(struct ebus_dma_info *p)\r\n{\r\nreturn readl(p->regs + EBDMA_ADDR);\r\n}\r\nvoid ebus_dma_enable(struct ebus_dma_info *p, int on)\r\n{\r\nunsigned long flags;\r\nu32 orig_csr, csr;\r\nspin_lock_irqsave(&p->lock, flags);\r\norig_csr = csr = readl(p->regs + EBDMA_CSR);\r\nif (on)\r\ncsr |= EBDMA_CSR_EN_DMA;\r\nelse\r\ncsr &= ~EBDMA_CSR_EN_DMA;\r\nif ((orig_csr & EBDMA_CSR_EN_DMA) !=\r\n(csr & EBDMA_CSR_EN_DMA))\r\nwritel(csr, p->regs + EBDMA_CSR);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}
