static struct cn_callback_entry *\r\ncn_queue_alloc_callback_entry(struct cn_queue_dev *dev, const char *name,\r\nstruct cb_id *id,\r\nvoid (*callback)(struct cn_msg *,\r\nstruct netlink_skb_parms *))\r\n{\r\nstruct cn_callback_entry *cbq;\r\ncbq = kzalloc(sizeof(*cbq), GFP_KERNEL);\r\nif (!cbq) {\r\npr_err("Failed to create new callback queue.\n");\r\nreturn NULL;\r\n}\r\natomic_set(&cbq->refcnt, 1);\r\natomic_inc(&dev->refcnt);\r\ncbq->pdev = dev;\r\nsnprintf(cbq->id.name, sizeof(cbq->id.name), "%s", name);\r\nmemcpy(&cbq->id.id, id, sizeof(struct cb_id));\r\ncbq->callback = callback;\r\nreturn cbq;\r\n}\r\nvoid cn_queue_release_callback(struct cn_callback_entry *cbq)\r\n{\r\nif (!atomic_dec_and_test(&cbq->refcnt))\r\nreturn;\r\natomic_dec(&cbq->pdev->refcnt);\r\nkfree(cbq);\r\n}\r\nint cn_cb_equal(struct cb_id *i1, struct cb_id *i2)\r\n{\r\nreturn ((i1->idx == i2->idx) && (i1->val == i2->val));\r\n}\r\nint cn_queue_add_callback(struct cn_queue_dev *dev, const char *name,\r\nstruct cb_id *id,\r\nvoid (*callback)(struct cn_msg *,\r\nstruct netlink_skb_parms *))\r\n{\r\nstruct cn_callback_entry *cbq, *__cbq;\r\nint found = 0;\r\ncbq = cn_queue_alloc_callback_entry(dev, name, id, callback);\r\nif (!cbq)\r\nreturn -ENOMEM;\r\nspin_lock_bh(&dev->queue_lock);\r\nlist_for_each_entry(__cbq, &dev->queue_list, callback_entry) {\r\nif (cn_cb_equal(&__cbq->id.id, id)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nlist_add_tail(&cbq->callback_entry, &dev->queue_list);\r\nspin_unlock_bh(&dev->queue_lock);\r\nif (found) {\r\ncn_queue_release_callback(cbq);\r\nreturn -EINVAL;\r\n}\r\ncbq->seq = 0;\r\ncbq->group = cbq->id.id.idx;\r\nreturn 0;\r\n}\r\nvoid cn_queue_del_callback(struct cn_queue_dev *dev, struct cb_id *id)\r\n{\r\nstruct cn_callback_entry *cbq, *n;\r\nint found = 0;\r\nspin_lock_bh(&dev->queue_lock);\r\nlist_for_each_entry_safe(cbq, n, &dev->queue_list, callback_entry) {\r\nif (cn_cb_equal(&cbq->id.id, id)) {\r\nlist_del(&cbq->callback_entry);\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&dev->queue_lock);\r\nif (found)\r\ncn_queue_release_callback(cbq);\r\n}\r\nstruct cn_queue_dev *cn_queue_alloc_dev(const char *name, struct sock *nls)\r\n{\r\nstruct cn_queue_dev *dev;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn NULL;\r\nsnprintf(dev->name, sizeof(dev->name), "%s", name);\r\natomic_set(&dev->refcnt, 0);\r\nINIT_LIST_HEAD(&dev->queue_list);\r\nspin_lock_init(&dev->queue_lock);\r\ndev->nls = nls;\r\nreturn dev;\r\n}\r\nvoid cn_queue_free_dev(struct cn_queue_dev *dev)\r\n{\r\nstruct cn_callback_entry *cbq, *n;\r\nspin_lock_bh(&dev->queue_lock);\r\nlist_for_each_entry_safe(cbq, n, &dev->queue_list, callback_entry)\r\nlist_del(&cbq->callback_entry);\r\nspin_unlock_bh(&dev->queue_lock);\r\nwhile (atomic_read(&dev->refcnt)) {\r\npr_info("Waiting for %s to become free: refcnt=%d.\n",\r\ndev->name, atomic_read(&dev->refcnt));\r\nmsleep(1000);\r\n}\r\nkfree(dev);\r\ndev = NULL;\r\n}
