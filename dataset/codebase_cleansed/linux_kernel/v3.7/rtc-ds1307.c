static s32 ds1307_read_block_data_once(const struct i2c_client *client,\r\nu8 command, u8 length, u8 *values)\r\n{\r\ns32 i, data;\r\nfor (i = 0; i < length; i++) {\r\ndata = i2c_smbus_read_byte_data(client, command + i);\r\nif (data < 0)\r\nreturn data;\r\nvalues[i] = data;\r\n}\r\nreturn i;\r\n}\r\nstatic s32 ds1307_read_block_data(const struct i2c_client *client, u8 command,\r\nu8 length, u8 *values)\r\n{\r\nu8 oldvalues[I2C_SMBUS_BLOCK_MAX];\r\ns32 ret;\r\nint tries = 0;\r\ndev_dbg(&client->dev, "ds1307_read_block_data (length=%d)\n", length);\r\nret = ds1307_read_block_data_once(client, command, length, values);\r\nif (ret < 0)\r\nreturn ret;\r\ndo {\r\nif (++tries > BLOCK_DATA_MAX_TRIES) {\r\ndev_err(&client->dev,\r\n"ds1307_read_block_data failed\n");\r\nreturn -EIO;\r\n}\r\nmemcpy(oldvalues, values, length);\r\nret = ds1307_read_block_data_once(client, command, length,\r\nvalues);\r\nif (ret < 0)\r\nreturn ret;\r\n} while (memcmp(oldvalues, values, length));\r\nreturn length;\r\n}\r\nstatic s32 ds1307_write_block_data(const struct i2c_client *client, u8 command,\r\nu8 length, const u8 *values)\r\n{\r\nu8 currvalues[I2C_SMBUS_BLOCK_MAX];\r\nint tries = 0;\r\ndev_dbg(&client->dev, "ds1307_write_block_data (length=%d)\n", length);\r\ndo {\r\ns32 i, ret;\r\nif (++tries > BLOCK_DATA_MAX_TRIES) {\r\ndev_err(&client->dev,\r\n"ds1307_write_block_data failed\n");\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < length; i++) {\r\nret = i2c_smbus_write_byte_data(client, command + i,\r\nvalues[i]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = ds1307_read_block_data_once(client, command, length,\r\ncurrvalues);\r\nif (ret < 0)\r\nreturn ret;\r\n} while (memcmp(currvalues, values, length));\r\nreturn length;\r\n}\r\nstatic void ds1307_work(struct work_struct *work)\r\n{\r\nstruct ds1307 *ds1307;\r\nstruct i2c_client *client;\r\nstruct mutex *lock;\r\nint stat, control;\r\nds1307 = container_of(work, struct ds1307, work);\r\nclient = ds1307->client;\r\nlock = &ds1307->rtc->ops_lock;\r\nmutex_lock(lock);\r\nstat = i2c_smbus_read_byte_data(client, DS1337_REG_STATUS);\r\nif (stat < 0)\r\ngoto out;\r\nif (stat & DS1337_BIT_A1I) {\r\nstat &= ~DS1337_BIT_A1I;\r\ni2c_smbus_write_byte_data(client, DS1337_REG_STATUS, stat);\r\ncontrol = i2c_smbus_read_byte_data(client, DS1337_REG_CONTROL);\r\nif (control < 0)\r\ngoto out;\r\ncontrol &= ~DS1337_BIT_A1IE;\r\ni2c_smbus_write_byte_data(client, DS1337_REG_CONTROL, control);\r\nrtc_update_irq(ds1307->rtc, 1, RTC_AF | RTC_IRQF);\r\n}\r\nout:\r\nif (test_bit(HAS_ALARM, &ds1307->flags))\r\nenable_irq(client->irq);\r\nmutex_unlock(lock);\r\n}\r\nstatic irqreturn_t ds1307_irq(int irq, void *dev_id)\r\n{\r\nstruct i2c_client *client = dev_id;\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\ndisable_irq_nosync(irq);\r\nschedule_work(&ds1307->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ds1307_get_time(struct device *dev, struct rtc_time *t)\r\n{\r\nstruct ds1307 *ds1307 = dev_get_drvdata(dev);\r\nint tmp;\r\ntmp = ds1307->read_block_data(ds1307->client,\r\nds1307->offset, 7, ds1307->regs);\r\nif (tmp != 7) {\r\ndev_err(dev, "%s error %d\n", "read", tmp);\r\nreturn -EIO;\r\n}\r\ndev_dbg(dev, "%s: %02x %02x %02x %02x %02x %02x %02x\n",\r\n"read",\r\nds1307->regs[0], ds1307->regs[1],\r\nds1307->regs[2], ds1307->regs[3],\r\nds1307->regs[4], ds1307->regs[5],\r\nds1307->regs[6]);\r\nt->tm_sec = bcd2bin(ds1307->regs[DS1307_REG_SECS] & 0x7f);\r\nt->tm_min = bcd2bin(ds1307->regs[DS1307_REG_MIN] & 0x7f);\r\ntmp = ds1307->regs[DS1307_REG_HOUR] & 0x3f;\r\nt->tm_hour = bcd2bin(tmp);\r\nt->tm_wday = bcd2bin(ds1307->regs[DS1307_REG_WDAY] & 0x07) - 1;\r\nt->tm_mday = bcd2bin(ds1307->regs[DS1307_REG_MDAY] & 0x3f);\r\ntmp = ds1307->regs[DS1307_REG_MONTH] & 0x1f;\r\nt->tm_mon = bcd2bin(tmp) - 1;\r\nt->tm_year = bcd2bin(ds1307->regs[DS1307_REG_YEAR]) + 100;\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n",\r\n"read", t->tm_sec, t->tm_min,\r\nt->tm_hour, t->tm_mday,\r\nt->tm_mon, t->tm_year, t->tm_wday);\r\nreturn rtc_valid_tm(t);\r\n}\r\nstatic int ds1307_set_time(struct device *dev, struct rtc_time *t)\r\n{\r\nstruct ds1307 *ds1307 = dev_get_drvdata(dev);\r\nint result;\r\nint tmp;\r\nu8 *buf = ds1307->regs;\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n",\r\n"write", t->tm_sec, t->tm_min,\r\nt->tm_hour, t->tm_mday,\r\nt->tm_mon, t->tm_year, t->tm_wday);\r\nbuf[DS1307_REG_SECS] = bin2bcd(t->tm_sec);\r\nbuf[DS1307_REG_MIN] = bin2bcd(t->tm_min);\r\nbuf[DS1307_REG_HOUR] = bin2bcd(t->tm_hour);\r\nbuf[DS1307_REG_WDAY] = bin2bcd(t->tm_wday + 1);\r\nbuf[DS1307_REG_MDAY] = bin2bcd(t->tm_mday);\r\nbuf[DS1307_REG_MONTH] = bin2bcd(t->tm_mon + 1);\r\ntmp = t->tm_year - 100;\r\nbuf[DS1307_REG_YEAR] = bin2bcd(tmp);\r\nswitch (ds1307->type) {\r\ncase ds_1337:\r\ncase ds_1339:\r\ncase ds_3231:\r\nbuf[DS1307_REG_MONTH] |= DS1337_BIT_CENTURY;\r\nbreak;\r\ncase ds_1340:\r\nbuf[DS1307_REG_HOUR] |= DS1340_BIT_CENTURY_EN\r\n| DS1340_BIT_CENTURY;\r\nbreak;\r\ncase mcp7941x:\r\nbuf[DS1307_REG_SECS] |= MCP7941X_BIT_ST;\r\nbuf[DS1307_REG_WDAY] |= MCP7941X_BIT_VBATEN;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndev_dbg(dev, "%s: %02x %02x %02x %02x %02x %02x %02x\n",\r\n"write", buf[0], buf[1], buf[2], buf[3],\r\nbuf[4], buf[5], buf[6]);\r\nresult = ds1307->write_block_data(ds1307->client,\r\nds1307->offset, 7, buf);\r\nif (result < 0) {\r\ndev_err(dev, "%s error %d\n", "write", result);\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds1337_read_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\nint ret;\r\nif (!test_bit(HAS_ALARM, &ds1307->flags))\r\nreturn -EINVAL;\r\nret = ds1307->read_block_data(client,\r\nDS1339_REG_ALARM1_SECS, 9, ds1307->regs);\r\nif (ret != 9) {\r\ndev_err(dev, "%s error %d\n", "alarm read", ret);\r\nreturn -EIO;\r\n}\r\ndev_dbg(dev, "%s: %02x %02x %02x %02x, %02x %02x %02x, %02x %02x\n",\r\n"alarm read",\r\nds1307->regs[0], ds1307->regs[1],\r\nds1307->regs[2], ds1307->regs[3],\r\nds1307->regs[4], ds1307->regs[5],\r\nds1307->regs[6], ds1307->regs[7],\r\nds1307->regs[8]);\r\nt->time.tm_sec = bcd2bin(ds1307->regs[0] & 0x7f);\r\nt->time.tm_min = bcd2bin(ds1307->regs[1] & 0x7f);\r\nt->time.tm_hour = bcd2bin(ds1307->regs[2] & 0x3f);\r\nt->time.tm_mday = bcd2bin(ds1307->regs[3] & 0x3f);\r\nt->time.tm_mon = -1;\r\nt->time.tm_year = -1;\r\nt->time.tm_wday = -1;\r\nt->time.tm_yday = -1;\r\nt->time.tm_isdst = -1;\r\nt->enabled = !!(ds1307->regs[7] & DS1337_BIT_A1IE);\r\nt->pending = !!(ds1307->regs[8] & DS1337_BIT_A1I);\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, enabled=%d, pending=%d\n",\r\n"alarm read", t->time.tm_sec, t->time.tm_min,\r\nt->time.tm_hour, t->time.tm_mday,\r\nt->enabled, t->pending);\r\nreturn 0;\r\n}\r\nstatic int ds1337_set_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\nunsigned char *buf = ds1307->regs;\r\nu8 control, status;\r\nint ret;\r\nif (!test_bit(HAS_ALARM, &ds1307->flags))\r\nreturn -EINVAL;\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, enabled=%d, pending=%d\n",\r\n"alarm set", t->time.tm_sec, t->time.tm_min,\r\nt->time.tm_hour, t->time.tm_mday,\r\nt->enabled, t->pending);\r\nret = ds1307->read_block_data(client,\r\nDS1339_REG_ALARM1_SECS, 9, buf);\r\nif (ret != 9) {\r\ndev_err(dev, "%s error %d\n", "alarm write", ret);\r\nreturn -EIO;\r\n}\r\ncontrol = ds1307->regs[7];\r\nstatus = ds1307->regs[8];\r\ndev_dbg(dev, "%s: %02x %02x %02x %02x, %02x %02x %02x, %02x %02x\n",\r\n"alarm set (old status)",\r\nds1307->regs[0], ds1307->regs[1],\r\nds1307->regs[2], ds1307->regs[3],\r\nds1307->regs[4], ds1307->regs[5],\r\nds1307->regs[6], control, status);\r\nbuf[0] = bin2bcd(t->time.tm_sec);\r\nbuf[1] = bin2bcd(t->time.tm_min);\r\nbuf[2] = bin2bcd(t->time.tm_hour);\r\nbuf[3] = bin2bcd(t->time.tm_mday);\r\nbuf[4] = 0;\r\nbuf[5] = 0;\r\nbuf[6] = 0;\r\nbuf[7] = control & ~(DS1337_BIT_A1IE | DS1337_BIT_A2IE);\r\nif (t->enabled) {\r\ndev_dbg(dev, "alarm IRQ armed\n");\r\nbuf[7] |= DS1337_BIT_A1IE;\r\n}\r\nbuf[8] = status & ~(DS1337_BIT_A1I | DS1337_BIT_A2I);\r\nret = ds1307->write_block_data(client,\r\nDS1339_REG_ALARM1_SECS, 9, buf);\r\nif (ret < 0) {\r\ndev_err(dev, "can't set alarm time\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds1307_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\nint ret;\r\nif (!test_bit(HAS_ALARM, &ds1307->flags))\r\nreturn -ENOTTY;\r\nret = i2c_smbus_read_byte_data(client, DS1337_REG_CONTROL);\r\nif (ret < 0)\r\nreturn ret;\r\nif (enabled)\r\nret |= DS1337_BIT_A1IE;\r\nelse\r\nret &= ~DS1337_BIT_A1IE;\r\nret = i2c_smbus_write_byte_data(client, DS1337_REG_CONTROL, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nds1307_nvram_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct i2c_client *client;\r\nstruct ds1307 *ds1307;\r\nint result;\r\nclient = kobj_to_i2c_client(kobj);\r\nds1307 = i2c_get_clientdata(client);\r\nif (unlikely(off >= ds1307->nvram->size))\r\nreturn 0;\r\nif ((off + count) > ds1307->nvram->size)\r\ncount = ds1307->nvram->size - off;\r\nif (unlikely(!count))\r\nreturn count;\r\nresult = ds1307->read_block_data(client, ds1307->nvram_offset + off,\r\ncount, buf);\r\nif (result < 0)\r\ndev_err(&client->dev, "%s error %d\n", "nvram read", result);\r\nreturn result;\r\n}\r\nstatic ssize_t\r\nds1307_nvram_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct i2c_client *client;\r\nstruct ds1307 *ds1307;\r\nint result;\r\nclient = kobj_to_i2c_client(kobj);\r\nds1307 = i2c_get_clientdata(client);\r\nif (unlikely(off >= ds1307->nvram->size))\r\nreturn -EFBIG;\r\nif ((off + count) > ds1307->nvram->size)\r\ncount = ds1307->nvram->size - off;\r\nif (unlikely(!count))\r\nreturn count;\r\nresult = ds1307->write_block_data(client, ds1307->nvram_offset + off,\r\ncount, buf);\r\nif (result < 0) {\r\ndev_err(&client->dev, "%s error %d\n", "nvram write", result);\r\nreturn result;\r\n}\r\nreturn count;\r\n}\r\nstatic int __devinit ds1307_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ds1307 *ds1307;\r\nint err = -ENODEV;\r\nint tmp;\r\nconst struct chip_desc *chip = &chips[id->driver_data];\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nint want_irq = false;\r\nunsigned char *buf;\r\nstruct ds1307_platform_data *pdata = client->dev.platform_data;\r\nstatic const int bbsqi_bitpos[] = {\r\n[ds_1337] = 0,\r\n[ds_1339] = DS1339_BIT_BBSQI,\r\n[ds_3231] = DS3231_BIT_BBSQW,\r\n};\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)\r\n&& !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn -EIO;\r\nds1307 = kzalloc(sizeof(struct ds1307), GFP_KERNEL);\r\nif (!ds1307)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, ds1307);\r\nds1307->client = client;\r\nds1307->type = id->driver_data;\r\nif (pdata && pdata->trickle_charger_setup && chip->trickle_charger_reg)\r\ni2c_smbus_write_byte_data(client, chip->trickle_charger_reg,\r\nDS13XX_TRICKLE_CHARGER_MAGIC | pdata->trickle_charger_setup);\r\nbuf = ds1307->regs;\r\nif (i2c_check_functionality(adapter, I2C_FUNC_SMBUS_I2C_BLOCK)) {\r\nds1307->read_block_data = i2c_smbus_read_i2c_block_data;\r\nds1307->write_block_data = i2c_smbus_write_i2c_block_data;\r\n} else {\r\nds1307->read_block_data = ds1307_read_block_data;\r\nds1307->write_block_data = ds1307_write_block_data;\r\n}\r\nswitch (ds1307->type) {\r\ncase ds_1337:\r\ncase ds_1339:\r\ncase ds_3231:\r\ntmp = ds1307->read_block_data(ds1307->client,\r\nDS1337_REG_CONTROL, 2, buf);\r\nif (tmp != 2) {\r\npr_debug("read error %d\n", tmp);\r\nerr = -EIO;\r\ngoto exit_free;\r\n}\r\nif (ds1307->regs[0] & DS1337_BIT_nEOSC)\r\nds1307->regs[0] &= ~DS1337_BIT_nEOSC;\r\nif (ds1307->client->irq > 0 && chip->alarm) {\r\nINIT_WORK(&ds1307->work, ds1307_work);\r\nds1307->regs[0] |= DS1337_BIT_INTCN\r\n| bbsqi_bitpos[ds1307->type];\r\nds1307->regs[0] &= ~(DS1337_BIT_A2IE | DS1337_BIT_A1IE);\r\nwant_irq = true;\r\n}\r\ni2c_smbus_write_byte_data(client, DS1337_REG_CONTROL,\r\nds1307->regs[0]);\r\nif (ds1307->regs[1] & DS1337_BIT_OSF) {\r\ni2c_smbus_write_byte_data(client, DS1337_REG_STATUS,\r\nds1307->regs[1] & ~DS1337_BIT_OSF);\r\ndev_warn(&client->dev, "SET TIME!\n");\r\n}\r\nbreak;\r\ncase rx_8025:\r\ntmp = i2c_smbus_read_i2c_block_data(ds1307->client,\r\nRX8025_REG_CTRL1 << 4 | 0x08, 2, buf);\r\nif (tmp != 2) {\r\npr_debug("read error %d\n", tmp);\r\nerr = -EIO;\r\ngoto exit_free;\r\n}\r\nif (!(ds1307->regs[1] & RX8025_BIT_XST)) {\r\nds1307->regs[1] |= RX8025_BIT_XST;\r\ni2c_smbus_write_byte_data(client,\r\nRX8025_REG_CTRL2 << 4 | 0x08,\r\nds1307->regs[1]);\r\ndev_warn(&client->dev,\r\n"oscillator stop detected - SET TIME!\n");\r\n}\r\nif (ds1307->regs[1] & RX8025_BIT_PON) {\r\nds1307->regs[1] &= ~RX8025_BIT_PON;\r\ni2c_smbus_write_byte_data(client,\r\nRX8025_REG_CTRL2 << 4 | 0x08,\r\nds1307->regs[1]);\r\ndev_warn(&client->dev, "power-on detected\n");\r\n}\r\nif (ds1307->regs[1] & RX8025_BIT_VDET) {\r\nds1307->regs[1] &= ~RX8025_BIT_VDET;\r\ni2c_smbus_write_byte_data(client,\r\nRX8025_REG_CTRL2 << 4 | 0x08,\r\nds1307->regs[1]);\r\ndev_warn(&client->dev, "voltage drop detected\n");\r\n}\r\nif (!(ds1307->regs[0] & RX8025_BIT_2412)) {\r\nu8 hour;\r\ni2c_smbus_write_byte_data(client,\r\nRX8025_REG_CTRL1 << 4 | 0x08,\r\nds1307->regs[0] |\r\nRX8025_BIT_2412);\r\ntmp = i2c_smbus_read_i2c_block_data(ds1307->client,\r\nRX8025_REG_CTRL1 << 4 | 0x08, 2, buf);\r\nif (tmp != 2) {\r\npr_debug("read error %d\n", tmp);\r\nerr = -EIO;\r\ngoto exit_free;\r\n}\r\nhour = bcd2bin(ds1307->regs[DS1307_REG_HOUR]);\r\nif (hour == 12)\r\nhour = 0;\r\nif (ds1307->regs[DS1307_REG_HOUR] & DS1307_BIT_PM)\r\nhour += 12;\r\ni2c_smbus_write_byte_data(client,\r\nDS1307_REG_HOUR << 4 | 0x08,\r\nhour);\r\n}\r\nbreak;\r\ncase ds_1388:\r\nds1307->offset = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nread_rtc:\r\ntmp = ds1307->read_block_data(ds1307->client, ds1307->offset, 8, buf);\r\nif (tmp != 8) {\r\npr_debug("read error %d\n", tmp);\r\nerr = -EIO;\r\ngoto exit_free;\r\n}\r\ntmp = ds1307->regs[DS1307_REG_SECS];\r\nswitch (ds1307->type) {\r\ncase ds_1307:\r\ncase m41t00:\r\nif (tmp & DS1307_BIT_CH) {\r\ni2c_smbus_write_byte_data(client, DS1307_REG_SECS, 0);\r\ndev_warn(&client->dev, "SET TIME!\n");\r\ngoto read_rtc;\r\n}\r\nbreak;\r\ncase ds_1338:\r\nif (tmp & DS1307_BIT_CH)\r\ni2c_smbus_write_byte_data(client, DS1307_REG_SECS, 0);\r\nif (ds1307->regs[DS1307_REG_CONTROL] & DS1338_BIT_OSF) {\r\ni2c_smbus_write_byte_data(client, DS1307_REG_CONTROL,\r\nds1307->regs[DS1307_REG_CONTROL]\r\n& ~DS1338_BIT_OSF);\r\ndev_warn(&client->dev, "SET TIME!\n");\r\ngoto read_rtc;\r\n}\r\nbreak;\r\ncase ds_1340:\r\nif (tmp & DS1340_BIT_nEOSC)\r\ni2c_smbus_write_byte_data(client, DS1307_REG_SECS, 0);\r\ntmp = i2c_smbus_read_byte_data(client, DS1340_REG_FLAG);\r\nif (tmp < 0) {\r\npr_debug("read error %d\n", tmp);\r\nerr = -EIO;\r\ngoto exit_free;\r\n}\r\nif (tmp & DS1340_BIT_OSF) {\r\ni2c_smbus_write_byte_data(client, DS1340_REG_FLAG, 0);\r\ndev_warn(&client->dev, "SET TIME!\n");\r\n}\r\nbreak;\r\ncase mcp7941x:\r\nif (!(ds1307->regs[DS1307_REG_WDAY] & MCP7941X_BIT_VBATEN)) {\r\ni2c_smbus_write_byte_data(client, DS1307_REG_WDAY,\r\nds1307->regs[DS1307_REG_WDAY]\r\n| MCP7941X_BIT_VBATEN);\r\n}\r\nif (!(tmp & MCP7941X_BIT_ST)) {\r\ni2c_smbus_write_byte_data(client, DS1307_REG_SECS,\r\nMCP7941X_BIT_ST);\r\ndev_warn(&client->dev, "SET TIME!\n");\r\ngoto read_rtc;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntmp = ds1307->regs[DS1307_REG_HOUR];\r\nswitch (ds1307->type) {\r\ncase ds_1340:\r\ncase m41t00:\r\nbreak;\r\ncase rx_8025:\r\nbreak;\r\ndefault:\r\nif (!(tmp & DS1307_BIT_12HR))\r\nbreak;\r\ntmp = bcd2bin(tmp & 0x1f);\r\nif (tmp == 12)\r\ntmp = 0;\r\nif (ds1307->regs[DS1307_REG_HOUR] & DS1307_BIT_PM)\r\ntmp += 12;\r\ni2c_smbus_write_byte_data(client,\r\nds1307->offset + DS1307_REG_HOUR,\r\nbin2bcd(tmp));\r\n}\r\nds1307->rtc = rtc_device_register(client->name, &client->dev,\r\n&ds13xx_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(ds1307->rtc)) {\r\nerr = PTR_ERR(ds1307->rtc);\r\ndev_err(&client->dev,\r\n"unable to register the class device\n");\r\ngoto exit_free;\r\n}\r\nif (want_irq) {\r\nerr = request_irq(client->irq, ds1307_irq, IRQF_SHARED,\r\nds1307->rtc->name, client);\r\nif (err) {\r\ndev_err(&client->dev,\r\n"unable to request IRQ!\n");\r\ngoto exit_irq;\r\n}\r\ndevice_set_wakeup_capable(&client->dev, 1);\r\nset_bit(HAS_ALARM, &ds1307->flags);\r\ndev_dbg(&client->dev, "got IRQ %d\n", client->irq);\r\n}\r\nif (chip->nvram_size) {\r\nds1307->nvram = kzalloc(sizeof(struct bin_attribute),\r\nGFP_KERNEL);\r\nif (!ds1307->nvram) {\r\nerr = -ENOMEM;\r\ngoto exit_nvram;\r\n}\r\nds1307->nvram->attr.name = "nvram";\r\nds1307->nvram->attr.mode = S_IRUGO | S_IWUSR;\r\nsysfs_bin_attr_init(ds1307->nvram);\r\nds1307->nvram->read = ds1307_nvram_read,\r\nds1307->nvram->write = ds1307_nvram_write,\r\nds1307->nvram->size = chip->nvram_size;\r\nds1307->nvram_offset = chip->nvram_offset;\r\nerr = sysfs_create_bin_file(&client->dev.kobj, ds1307->nvram);\r\nif (err) {\r\nkfree(ds1307->nvram);\r\ngoto exit_nvram;\r\n}\r\nset_bit(HAS_NVRAM, &ds1307->flags);\r\ndev_info(&client->dev, "%zu bytes nvram\n", ds1307->nvram->size);\r\n}\r\nreturn 0;\r\nexit_nvram:\r\nexit_irq:\r\nrtc_device_unregister(ds1307->rtc);\r\nexit_free:\r\nkfree(ds1307);\r\nreturn err;\r\n}\r\nstatic int __devexit ds1307_remove(struct i2c_client *client)\r\n{\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\nif (test_and_clear_bit(HAS_ALARM, &ds1307->flags)) {\r\nfree_irq(client->irq, client);\r\ncancel_work_sync(&ds1307->work);\r\n}\r\nif (test_and_clear_bit(HAS_NVRAM, &ds1307->flags)) {\r\nsysfs_remove_bin_file(&client->dev.kobj, ds1307->nvram);\r\nkfree(ds1307->nvram);\r\n}\r\nrtc_device_unregister(ds1307->rtc);\r\nkfree(ds1307);\r\nreturn 0;\r\n}
