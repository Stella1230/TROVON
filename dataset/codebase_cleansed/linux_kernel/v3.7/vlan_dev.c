static int vlan_dev_rebuild_header(struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nstruct vlan_ethhdr *veth = (struct vlan_ethhdr *)(skb->data);\r\nswitch (veth->h_vlan_encapsulated_proto) {\r\n#ifdef CONFIG_INET\r\ncase htons(ETH_P_IP):\r\nreturn arp_find(veth->h_dest, skb);\r\n#endif\r\ndefault:\r\npr_debug("%s: unable to resolve type %X addresses\n",\r\ndev->name, ntohs(veth->h_vlan_encapsulated_proto));\r\nmemcpy(veth->h_source, dev->dev_addr, ETH_ALEN);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u16\r\nvlan_dev_get_egress_qos_mask(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct vlan_priority_tci_mapping *mp;\r\nmp = vlan_dev_priv(dev)->egress_priority_map[(skb->priority & 0xF)];\r\nwhile (mp) {\r\nif (mp->priority == skb->priority) {\r\nreturn mp->vlan_qos;\r\n}\r\nmp = mp->next;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vlan_dev_hard_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type,\r\nconst void *daddr, const void *saddr,\r\nunsigned int len)\r\n{\r\nstruct vlan_hdr *vhdr;\r\nunsigned int vhdrlen = 0;\r\nu16 vlan_tci = 0;\r\nint rc;\r\nif (!(vlan_dev_priv(dev)->flags & VLAN_FLAG_REORDER_HDR)) {\r\nvhdr = (struct vlan_hdr *) skb_push(skb, VLAN_HLEN);\r\nvlan_tci = vlan_dev_priv(dev)->vlan_id;\r\nvlan_tci |= vlan_dev_get_egress_qos_mask(dev, skb);\r\nvhdr->h_vlan_TCI = htons(vlan_tci);\r\nif (type != ETH_P_802_3 && type != ETH_P_802_2)\r\nvhdr->h_vlan_encapsulated_proto = htons(type);\r\nelse\r\nvhdr->h_vlan_encapsulated_proto = htons(len);\r\nskb->protocol = htons(ETH_P_8021Q);\r\ntype = ETH_P_8021Q;\r\nvhdrlen = VLAN_HLEN;\r\n}\r\nif (saddr == NULL)\r\nsaddr = dev->dev_addr;\r\ndev = vlan_dev_priv(dev)->real_dev;\r\nrc = dev_hard_header(skb, dev, type, daddr, saddr, len + vhdrlen);\r\nif (rc > 0)\r\nrc += vhdrlen;\r\nreturn rc;\r\n}\r\nstatic inline netdev_tx_t vlan_netpoll_send_skb(struct vlan_dev_priv *vlan, struct sk_buff *skb)\r\n{\r\n#ifdef CONFIG_NET_POLL_CONTROLLER\r\nif (vlan->netpoll)\r\nnetpoll_send_skb(vlan->netpoll, skb);\r\n#else\r\nBUG();\r\n#endif\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic netdev_tx_t vlan_dev_hard_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\r\nstruct vlan_ethhdr *veth = (struct vlan_ethhdr *)(skb->data);\r\nunsigned int len;\r\nint ret;\r\nif (veth->h_vlan_proto != htons(ETH_P_8021Q) ||\r\nvlan->flags & VLAN_FLAG_REORDER_HDR) {\r\nu16 vlan_tci;\r\nvlan_tci = vlan->vlan_id;\r\nvlan_tci |= vlan_dev_get_egress_qos_mask(dev, skb);\r\nskb = __vlan_hwaccel_put_tag(skb, vlan_tci);\r\n}\r\nskb->dev = vlan->real_dev;\r\nlen = skb->len;\r\nif (unlikely(netpoll_tx_running(dev)))\r\nreturn vlan_netpoll_send_skb(vlan, skb);\r\nret = dev_queue_xmit(skb);\r\nif (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN)) {\r\nstruct vlan_pcpu_stats *stats;\r\nstats = this_cpu_ptr(vlan->vlan_pcpu_stats);\r\nu64_stats_update_begin(&stats->syncp);\r\nstats->tx_packets++;\r\nstats->tx_bytes += len;\r\nu64_stats_update_end(&stats->syncp);\r\n} else {\r\nthis_cpu_inc(vlan->vlan_pcpu_stats->tx_dropped);\r\n}\r\nreturn ret;\r\n}\r\nstatic int vlan_dev_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (vlan_dev_priv(dev)->real_dev->mtu < new_mtu)\r\nreturn -ERANGE;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nvoid vlan_dev_set_ingress_priority(const struct net_device *dev,\r\nu32 skb_prio, u16 vlan_prio)\r\n{\r\nstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\r\nif (vlan->ingress_priority_map[vlan_prio & 0x7] && !skb_prio)\r\nvlan->nr_ingress_mappings--;\r\nelse if (!vlan->ingress_priority_map[vlan_prio & 0x7] && skb_prio)\r\nvlan->nr_ingress_mappings++;\r\nvlan->ingress_priority_map[vlan_prio & 0x7] = skb_prio;\r\n}\r\nint vlan_dev_set_egress_priority(const struct net_device *dev,\r\nu32 skb_prio, u16 vlan_prio)\r\n{\r\nstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\r\nstruct vlan_priority_tci_mapping *mp = NULL;\r\nstruct vlan_priority_tci_mapping *np;\r\nu32 vlan_qos = (vlan_prio << VLAN_PRIO_SHIFT) & VLAN_PRIO_MASK;\r\nmp = vlan->egress_priority_map[skb_prio & 0xF];\r\nwhile (mp) {\r\nif (mp->priority == skb_prio) {\r\nif (mp->vlan_qos && !vlan_qos)\r\nvlan->nr_egress_mappings--;\r\nelse if (!mp->vlan_qos && vlan_qos)\r\nvlan->nr_egress_mappings++;\r\nmp->vlan_qos = vlan_qos;\r\nreturn 0;\r\n}\r\nmp = mp->next;\r\n}\r\nmp = vlan->egress_priority_map[skb_prio & 0xF];\r\nnp = kmalloc(sizeof(struct vlan_priority_tci_mapping), GFP_KERNEL);\r\nif (!np)\r\nreturn -ENOBUFS;\r\nnp->next = mp;\r\nnp->priority = skb_prio;\r\nnp->vlan_qos = vlan_qos;\r\nvlan->egress_priority_map[skb_prio & 0xF] = np;\r\nif (vlan_qos)\r\nvlan->nr_egress_mappings++;\r\nreturn 0;\r\n}\r\nint vlan_dev_change_flags(const struct net_device *dev, u32 flags, u32 mask)\r\n{\r\nstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\r\nu32 old_flags = vlan->flags;\r\nif (mask & ~(VLAN_FLAG_REORDER_HDR | VLAN_FLAG_GVRP |\r\nVLAN_FLAG_LOOSE_BINDING))\r\nreturn -EINVAL;\r\nvlan->flags = (old_flags & ~mask) | (flags & mask);\r\nif (netif_running(dev) && (vlan->flags ^ old_flags) & VLAN_FLAG_GVRP) {\r\nif (vlan->flags & VLAN_FLAG_GVRP)\r\nvlan_gvrp_request_join(dev);\r\nelse\r\nvlan_gvrp_request_leave(dev);\r\n}\r\nreturn 0;\r\n}\r\nvoid vlan_dev_get_realdev_name(const struct net_device *dev, char *result)\r\n{\r\nstrncpy(result, vlan_dev_priv(dev)->real_dev->name, 23);\r\n}\r\nstatic int vlan_dev_open(struct net_device *dev)\r\n{\r\nstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\r\nstruct net_device *real_dev = vlan->real_dev;\r\nint err;\r\nif (!(real_dev->flags & IFF_UP) &&\r\n!(vlan->flags & VLAN_FLAG_LOOSE_BINDING))\r\nreturn -ENETDOWN;\r\nif (!ether_addr_equal(dev->dev_addr, real_dev->dev_addr)) {\r\nerr = dev_uc_add(real_dev, dev->dev_addr);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nif (dev->flags & IFF_ALLMULTI) {\r\nerr = dev_set_allmulti(real_dev, 1);\r\nif (err < 0)\r\ngoto del_unicast;\r\n}\r\nif (dev->flags & IFF_PROMISC) {\r\nerr = dev_set_promiscuity(real_dev, 1);\r\nif (err < 0)\r\ngoto clear_allmulti;\r\n}\r\nmemcpy(vlan->real_dev_addr, real_dev->dev_addr, ETH_ALEN);\r\nif (vlan->flags & VLAN_FLAG_GVRP)\r\nvlan_gvrp_request_join(dev);\r\nif (netif_carrier_ok(real_dev))\r\nnetif_carrier_on(dev);\r\nreturn 0;\r\nclear_allmulti:\r\nif (dev->flags & IFF_ALLMULTI)\r\ndev_set_allmulti(real_dev, -1);\r\ndel_unicast:\r\nif (!ether_addr_equal(dev->dev_addr, real_dev->dev_addr))\r\ndev_uc_del(real_dev, dev->dev_addr);\r\nout:\r\nnetif_carrier_off(dev);\r\nreturn err;\r\n}\r\nstatic int vlan_dev_stop(struct net_device *dev)\r\n{\r\nstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\r\nstruct net_device *real_dev = vlan->real_dev;\r\ndev_mc_unsync(real_dev, dev);\r\ndev_uc_unsync(real_dev, dev);\r\nif (dev->flags & IFF_ALLMULTI)\r\ndev_set_allmulti(real_dev, -1);\r\nif (dev->flags & IFF_PROMISC)\r\ndev_set_promiscuity(real_dev, -1);\r\nif (!ether_addr_equal(dev->dev_addr, real_dev->dev_addr))\r\ndev_uc_del(real_dev, dev->dev_addr);\r\nnetif_carrier_off(dev);\r\nreturn 0;\r\n}\r\nstatic int vlan_dev_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\r\nstruct sockaddr *addr = p;\r\nint err;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nif (!(dev->flags & IFF_UP))\r\ngoto out;\r\nif (!ether_addr_equal(addr->sa_data, real_dev->dev_addr)) {\r\nerr = dev_uc_add(real_dev, addr->sa_data);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (!ether_addr_equal(dev->dev_addr, real_dev->dev_addr))\r\ndev_uc_del(real_dev, dev->dev_addr);\r\nout:\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int vlan_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\r\nconst struct net_device_ops *ops = real_dev->netdev_ops;\r\nstruct ifreq ifrr;\r\nint err = -EOPNOTSUPP;\r\nstrncpy(ifrr.ifr_name, real_dev->name, IFNAMSIZ);\r\nifrr.ifr_ifru = ifr->ifr_ifru;\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ncase SIOCGMIIREG:\r\ncase SIOCSMIIREG:\r\nif (netif_device_present(real_dev) && ops->ndo_do_ioctl)\r\nerr = ops->ndo_do_ioctl(real_dev, &ifrr, cmd);\r\nbreak;\r\n}\r\nif (!err)\r\nifr->ifr_ifru = ifrr.ifr_ifru;\r\nreturn err;\r\n}\r\nstatic int vlan_dev_neigh_setup(struct net_device *dev, struct neigh_parms *pa)\r\n{\r\nstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\r\nconst struct net_device_ops *ops = real_dev->netdev_ops;\r\nint err = 0;\r\nif (netif_device_present(real_dev) && ops->ndo_neigh_setup)\r\nerr = ops->ndo_neigh_setup(real_dev, pa);\r\nreturn err;\r\n}\r\nstatic int vlan_dev_fcoe_ddp_setup(struct net_device *dev, u16 xid,\r\nstruct scatterlist *sgl, unsigned int sgc)\r\n{\r\nstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\r\nconst struct net_device_ops *ops = real_dev->netdev_ops;\r\nint rc = 0;\r\nif (ops->ndo_fcoe_ddp_setup)\r\nrc = ops->ndo_fcoe_ddp_setup(real_dev, xid, sgl, sgc);\r\nreturn rc;\r\n}\r\nstatic int vlan_dev_fcoe_ddp_done(struct net_device *dev, u16 xid)\r\n{\r\nstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\r\nconst struct net_device_ops *ops = real_dev->netdev_ops;\r\nint len = 0;\r\nif (ops->ndo_fcoe_ddp_done)\r\nlen = ops->ndo_fcoe_ddp_done(real_dev, xid);\r\nreturn len;\r\n}\r\nstatic int vlan_dev_fcoe_enable(struct net_device *dev)\r\n{\r\nstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\r\nconst struct net_device_ops *ops = real_dev->netdev_ops;\r\nint rc = -EINVAL;\r\nif (ops->ndo_fcoe_enable)\r\nrc = ops->ndo_fcoe_enable(real_dev);\r\nreturn rc;\r\n}\r\nstatic int vlan_dev_fcoe_disable(struct net_device *dev)\r\n{\r\nstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\r\nconst struct net_device_ops *ops = real_dev->netdev_ops;\r\nint rc = -EINVAL;\r\nif (ops->ndo_fcoe_disable)\r\nrc = ops->ndo_fcoe_disable(real_dev);\r\nreturn rc;\r\n}\r\nstatic int vlan_dev_fcoe_get_wwn(struct net_device *dev, u64 *wwn, int type)\r\n{\r\nstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\r\nconst struct net_device_ops *ops = real_dev->netdev_ops;\r\nint rc = -EINVAL;\r\nif (ops->ndo_fcoe_get_wwn)\r\nrc = ops->ndo_fcoe_get_wwn(real_dev, wwn, type);\r\nreturn rc;\r\n}\r\nstatic int vlan_dev_fcoe_ddp_target(struct net_device *dev, u16 xid,\r\nstruct scatterlist *sgl, unsigned int sgc)\r\n{\r\nstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\r\nconst struct net_device_ops *ops = real_dev->netdev_ops;\r\nint rc = 0;\r\nif (ops->ndo_fcoe_ddp_target)\r\nrc = ops->ndo_fcoe_ddp_target(real_dev, xid, sgl, sgc);\r\nreturn rc;\r\n}\r\nstatic void vlan_dev_change_rx_flags(struct net_device *dev, int change)\r\n{\r\nstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\r\nif (dev->flags & IFF_UP) {\r\nif (change & IFF_ALLMULTI)\r\ndev_set_allmulti(real_dev, dev->flags & IFF_ALLMULTI ? 1 : -1);\r\nif (change & IFF_PROMISC)\r\ndev_set_promiscuity(real_dev, dev->flags & IFF_PROMISC ? 1 : -1);\r\n}\r\n}\r\nstatic void vlan_dev_set_rx_mode(struct net_device *vlan_dev)\r\n{\r\ndev_mc_sync(vlan_dev_priv(vlan_dev)->real_dev, vlan_dev);\r\ndev_uc_sync(vlan_dev_priv(vlan_dev)->real_dev, vlan_dev);\r\n}\r\nstatic void vlan_dev_set_lockdep_one(struct net_device *dev,\r\nstruct netdev_queue *txq,\r\nvoid *_subclass)\r\n{\r\nlockdep_set_class_and_subclass(&txq->_xmit_lock,\r\n&vlan_netdev_xmit_lock_key,\r\n*(int *)_subclass);\r\n}\r\nstatic void vlan_dev_set_lockdep_class(struct net_device *dev, int subclass)\r\n{\r\nlockdep_set_class_and_subclass(&dev->addr_list_lock,\r\n&vlan_netdev_addr_lock_key,\r\nsubclass);\r\nnetdev_for_each_tx_queue(dev, vlan_dev_set_lockdep_one, &subclass);\r\n}\r\nstatic int vlan_dev_init(struct net_device *dev)\r\n{\r\nstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\r\nint subclass = 0;\r\nnetif_carrier_off(dev);\r\ndev->flags = real_dev->flags & ~(IFF_UP | IFF_PROMISC | IFF_ALLMULTI |\r\nIFF_MASTER | IFF_SLAVE);\r\ndev->iflink = real_dev->ifindex;\r\ndev->state = (real_dev->state & ((1<<__LINK_STATE_NOCARRIER) |\r\n(1<<__LINK_STATE_DORMANT))) |\r\n(1<<__LINK_STATE_PRESENT);\r\ndev->hw_features = NETIF_F_ALL_CSUM | NETIF_F_SG |\r\nNETIF_F_FRAGLIST | NETIF_F_ALL_TSO |\r\nNETIF_F_HIGHDMA | NETIF_F_SCTP_CSUM |\r\nNETIF_F_ALL_FCOE;\r\ndev->features |= real_dev->vlan_features | NETIF_F_LLTX;\r\ndev->gso_max_size = real_dev->gso_max_size;\r\ndev->dev_id = real_dev->dev_id;\r\nif (is_zero_ether_addr(dev->dev_addr))\r\nmemcpy(dev->dev_addr, real_dev->dev_addr, dev->addr_len);\r\nif (is_zero_ether_addr(dev->broadcast))\r\nmemcpy(dev->broadcast, real_dev->broadcast, dev->addr_len);\r\n#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)\r\ndev->fcoe_ddp_xid = real_dev->fcoe_ddp_xid;\r\n#endif\r\ndev->needed_headroom = real_dev->needed_headroom;\r\nif (real_dev->features & NETIF_F_HW_VLAN_TX) {\r\ndev->header_ops = real_dev->header_ops;\r\ndev->hard_header_len = real_dev->hard_header_len;\r\n} else {\r\ndev->header_ops = &vlan_header_ops;\r\ndev->hard_header_len = real_dev->hard_header_len + VLAN_HLEN;\r\n}\r\ndev->netdev_ops = &vlan_netdev_ops;\r\nif (is_vlan_dev(real_dev))\r\nsubclass = 1;\r\nvlan_dev_set_lockdep_class(dev, subclass);\r\nvlan_dev_priv(dev)->vlan_pcpu_stats = alloc_percpu(struct vlan_pcpu_stats);\r\nif (!vlan_dev_priv(dev)->vlan_pcpu_stats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void vlan_dev_uninit(struct net_device *dev)\r\n{\r\nstruct vlan_priority_tci_mapping *pm;\r\nstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\r\nint i;\r\nfree_percpu(vlan->vlan_pcpu_stats);\r\nvlan->vlan_pcpu_stats = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(vlan->egress_priority_map); i++) {\r\nwhile ((pm = vlan->egress_priority_map[i]) != NULL) {\r\nvlan->egress_priority_map[i] = pm->next;\r\nkfree(pm);\r\n}\r\n}\r\n}\r\nstatic netdev_features_t vlan_dev_fix_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\r\nu32 old_features = features;\r\nfeatures &= real_dev->vlan_features;\r\nfeatures |= NETIF_F_RXCSUM;\r\nfeatures &= real_dev->features;\r\nfeatures |= old_features & NETIF_F_SOFT_FEATURES;\r\nfeatures |= NETIF_F_LLTX;\r\nreturn features;\r\n}\r\nstatic int vlan_ethtool_get_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nconst struct vlan_dev_priv *vlan = vlan_dev_priv(dev);\r\nreturn __ethtool_get_settings(vlan->real_dev, cmd);\r\n}\r\nstatic void vlan_ethtool_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrcpy(info->driver, vlan_fullname);\r\nstrcpy(info->version, vlan_version);\r\nstrcpy(info->fw_version, "N/A");\r\n}\r\nstatic struct rtnl_link_stats64 *vlan_dev_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\r\n{\r\nif (vlan_dev_priv(dev)->vlan_pcpu_stats) {\r\nstruct vlan_pcpu_stats *p;\r\nu32 rx_errors = 0, tx_dropped = 0;\r\nint i;\r\nfor_each_possible_cpu(i) {\r\nu64 rxpackets, rxbytes, rxmulticast, txpackets, txbytes;\r\nunsigned int start;\r\np = per_cpu_ptr(vlan_dev_priv(dev)->vlan_pcpu_stats, i);\r\ndo {\r\nstart = u64_stats_fetch_begin_bh(&p->syncp);\r\nrxpackets = p->rx_packets;\r\nrxbytes = p->rx_bytes;\r\nrxmulticast = p->rx_multicast;\r\ntxpackets = p->tx_packets;\r\ntxbytes = p->tx_bytes;\r\n} while (u64_stats_fetch_retry_bh(&p->syncp, start));\r\nstats->rx_packets += rxpackets;\r\nstats->rx_bytes += rxbytes;\r\nstats->multicast += rxmulticast;\r\nstats->tx_packets += txpackets;\r\nstats->tx_bytes += txbytes;\r\nrx_errors += p->rx_errors;\r\ntx_dropped += p->tx_dropped;\r\n}\r\nstats->rx_errors = rx_errors;\r\nstats->tx_dropped = tx_dropped;\r\n}\r\nreturn stats;\r\n}\r\nstatic void vlan_dev_poll_controller(struct net_device *dev)\r\n{\r\nreturn;\r\n}\r\nstatic int vlan_dev_netpoll_setup(struct net_device *dev, struct netpoll_info *npinfo,\r\ngfp_t gfp)\r\n{\r\nstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\r\nstruct net_device *real_dev = vlan->real_dev;\r\nstruct netpoll *netpoll;\r\nint err = 0;\r\nnetpoll = kzalloc(sizeof(*netpoll), gfp);\r\nerr = -ENOMEM;\r\nif (!netpoll)\r\ngoto out;\r\nerr = __netpoll_setup(netpoll, real_dev, gfp);\r\nif (err) {\r\nkfree(netpoll);\r\ngoto out;\r\n}\r\nvlan->netpoll = netpoll;\r\nout:\r\nreturn err;\r\n}\r\nstatic void vlan_dev_netpoll_cleanup(struct net_device *dev)\r\n{\r\nstruct vlan_dev_priv *vlan= vlan_dev_priv(dev);\r\nstruct netpoll *netpoll = vlan->netpoll;\r\nif (!netpoll)\r\nreturn;\r\nvlan->netpoll = NULL;\r\n__netpoll_free_rcu(netpoll);\r\n}\r\nvoid vlan_setup(struct net_device *dev)\r\n{\r\nether_setup(dev);\r\ndev->priv_flags |= IFF_802_1Q_VLAN;\r\ndev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\r\ndev->tx_queue_len = 0;\r\ndev->netdev_ops = &vlan_netdev_ops;\r\ndev->destructor = free_netdev;\r\ndev->ethtool_ops = &vlan_ethtool_ops;\r\nmemset(dev->broadcast, 0, ETH_ALEN);\r\n}
