static inline struct bonding *__get_bond_by_port(struct port *port)\r\n{\r\nif (port->slave == NULL)\r\nreturn NULL;\r\nreturn bond_get_bond_by_slave(port->slave);\r\n}\r\nstatic inline struct port *__get_first_port(struct bonding *bond)\r\n{\r\nif (bond->slave_cnt == 0)\r\nreturn NULL;\r\nreturn &(SLAVE_AD_INFO(bond->first_slave).port);\r\n}\r\nstatic inline struct port *__get_next_port(struct port *port)\r\n{\r\nstruct bonding *bond = __get_bond_by_port(port);\r\nstruct slave *slave = port->slave;\r\nif ((bond == NULL) || (slave->next == bond->first_slave))\r\nreturn NULL;\r\nreturn &(SLAVE_AD_INFO(slave->next).port);\r\n}\r\nstatic inline struct aggregator *__get_first_agg(struct port *port)\r\n{\r\nstruct bonding *bond = __get_bond_by_port(port);\r\nif ((bond == NULL) || (bond->slave_cnt == 0))\r\nreturn NULL;\r\nreturn &(SLAVE_AD_INFO(bond->first_slave).aggregator);\r\n}\r\nstatic inline struct aggregator *__get_next_agg(struct aggregator *aggregator)\r\n{\r\nstruct slave *slave = aggregator->slave;\r\nstruct bonding *bond = bond_get_bond_by_slave(slave);\r\nif ((bond == NULL) || (slave->next == bond->first_slave))\r\nreturn NULL;\r\nreturn &(SLAVE_AD_INFO(slave->next).aggregator);\r\n}\r\nstatic inline int __agg_has_partner(struct aggregator *agg)\r\n{\r\nreturn !is_zero_ether_addr(agg->partner_system.mac_addr_value);\r\n}\r\nstatic inline void __disable_port(struct port *port)\r\n{\r\nbond_set_slave_inactive_flags(port->slave);\r\n}\r\nstatic inline void __enable_port(struct port *port)\r\n{\r\nstruct slave *slave = port->slave;\r\nif ((slave->link == BOND_LINK_UP) && IS_UP(slave->dev))\r\nbond_set_slave_active_flags(slave);\r\n}\r\nstatic inline int __port_is_enabled(struct port *port)\r\n{\r\nreturn bond_is_active_slave(port->slave);\r\n}\r\nstatic inline u32 __get_agg_selection_mode(struct port *port)\r\n{\r\nstruct bonding *bond = __get_bond_by_port(port);\r\nif (bond == NULL)\r\nreturn BOND_AD_STABLE;\r\nreturn bond->params.ad_select;\r\n}\r\nstatic inline int __check_agg_selection_timer(struct port *port)\r\n{\r\nstruct bonding *bond = __get_bond_by_port(port);\r\nif (bond == NULL)\r\nreturn 0;\r\nreturn BOND_AD_INFO(bond).agg_select_timer ? 1 : 0;\r\n}\r\nstatic inline void __get_state_machine_lock(struct port *port)\r\n{\r\nspin_lock_bh(&(SLAVE_AD_INFO(port->slave).state_machine_lock));\r\n}\r\nstatic inline void __release_state_machine_lock(struct port *port)\r\n{\r\nspin_unlock_bh(&(SLAVE_AD_INFO(port->slave).state_machine_lock));\r\n}\r\nstatic u16 __get_link_speed(struct port *port)\r\n{\r\nstruct slave *slave = port->slave;\r\nu16 speed;\r\nif (slave->link != BOND_LINK_UP)\r\nspeed = 0;\r\nelse {\r\nswitch (slave->speed) {\r\ncase SPEED_10:\r\nspeed = AD_LINK_SPEED_BITMASK_10MBPS;\r\nbreak;\r\ncase SPEED_100:\r\nspeed = AD_LINK_SPEED_BITMASK_100MBPS;\r\nbreak;\r\ncase SPEED_1000:\r\nspeed = AD_LINK_SPEED_BITMASK_1000MBPS;\r\nbreak;\r\ncase SPEED_10000:\r\nspeed = AD_LINK_SPEED_BITMASK_10000MBPS;\r\nbreak;\r\ndefault:\r\nspeed = 0;\r\nbreak;\r\n}\r\n}\r\npr_debug("Port %d Received link speed %d update from adapter\n",\r\nport->actor_port_number, speed);\r\nreturn speed;\r\n}\r\nstatic u8 __get_duplex(struct port *port)\r\n{\r\nstruct slave *slave = port->slave;\r\nu8 retval;\r\nif (slave->link != BOND_LINK_UP)\r\nretval = 0x0;\r\nelse {\r\nswitch (slave->duplex) {\r\ncase DUPLEX_FULL:\r\nretval = 0x1;\r\npr_debug("Port %d Received status full duplex update from adapter\n",\r\nport->actor_port_number);\r\nbreak;\r\ncase DUPLEX_HALF:\r\ndefault:\r\nretval = 0x0;\r\npr_debug("Port %d Received status NOT full duplex update from adapter\n",\r\nport->actor_port_number);\r\nbreak;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic inline void __initialize_port_locks(struct port *port)\r\n{\r\nspin_lock_init(&(SLAVE_AD_INFO(port->slave).state_machine_lock));\r\n}\r\nstatic u16 __ad_timer_to_ticks(u16 timer_type, u16 par)\r\n{\r\nu16 retval = 0;\r\nswitch (timer_type) {\r\ncase AD_CURRENT_WHILE_TIMER:\r\nif (par)\r\nretval = (AD_SHORT_TIMEOUT_TIME*ad_ticks_per_sec);\r\nelse\r\nretval = (AD_LONG_TIMEOUT_TIME*ad_ticks_per_sec);\r\nbreak;\r\ncase AD_ACTOR_CHURN_TIMER:\r\nretval = (AD_CHURN_DETECTION_TIME*ad_ticks_per_sec);\r\nbreak;\r\ncase AD_PERIODIC_TIMER:\r\nretval = (par*ad_ticks_per_sec);\r\nbreak;\r\ncase AD_PARTNER_CHURN_TIMER:\r\nretval = (AD_CHURN_DETECTION_TIME*ad_ticks_per_sec);\r\nbreak;\r\ncase AD_WAIT_WHILE_TIMER:\r\nretval = (AD_AGGREGATE_WAIT_TIME*ad_ticks_per_sec);\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic void __choose_matched(struct lacpdu *lacpdu, struct port *port)\r\n{\r\nif (((ntohs(lacpdu->partner_port) == port->actor_port_number) &&\r\n(ntohs(lacpdu->partner_port_priority) == port->actor_port_priority) &&\r\n!MAC_ADDRESS_COMPARE(&(lacpdu->partner_system), &(port->actor_system)) &&\r\n(ntohs(lacpdu->partner_system_priority) == port->actor_system_priority) &&\r\n(ntohs(lacpdu->partner_key) == port->actor_oper_port_key) &&\r\n((lacpdu->partner_state & AD_STATE_AGGREGATION) == (port->actor_oper_port_state & AD_STATE_AGGREGATION))) ||\r\n((lacpdu->actor_state & AD_STATE_AGGREGATION) == 0)\r\n) {\r\nport->sm_vars |= AD_PORT_MATCHED;\r\n} else {\r\nport->sm_vars &= ~AD_PORT_MATCHED;\r\n}\r\n}\r\nstatic void __record_pdu(struct lacpdu *lacpdu, struct port *port)\r\n{\r\nif (lacpdu && port) {\r\nstruct port_params *partner = &port->partner_oper;\r\n__choose_matched(lacpdu, port);\r\npartner->port_number = ntohs(lacpdu->actor_port);\r\npartner->port_priority = ntohs(lacpdu->actor_port_priority);\r\npartner->system = lacpdu->actor_system;\r\npartner->system_priority = ntohs(lacpdu->actor_system_priority);\r\npartner->key = ntohs(lacpdu->actor_key);\r\npartner->port_state = lacpdu->actor_state;\r\nport->actor_oper_port_state &= ~AD_STATE_DEFAULTED;\r\nif ((port->sm_vars & AD_PORT_MATCHED)\r\n&& (lacpdu->actor_state & AD_STATE_SYNCHRONIZATION))\r\npartner->port_state |= AD_STATE_SYNCHRONIZATION;\r\nelse\r\npartner->port_state &= ~AD_STATE_SYNCHRONIZATION;\r\n}\r\n}\r\nstatic void __record_default(struct port *port)\r\n{\r\nif (port) {\r\nmemcpy(&port->partner_oper, &port->partner_admin,\r\nsizeof(struct port_params));\r\nport->actor_oper_port_state |= AD_STATE_DEFAULTED;\r\n}\r\n}\r\nstatic void __update_selected(struct lacpdu *lacpdu, struct port *port)\r\n{\r\nif (lacpdu && port) {\r\nconst struct port_params *partner = &port->partner_oper;\r\nif (ntohs(lacpdu->actor_port) != partner->port_number ||\r\nntohs(lacpdu->actor_port_priority) != partner->port_priority ||\r\nMAC_ADDRESS_COMPARE(&lacpdu->actor_system, &partner->system) ||\r\nntohs(lacpdu->actor_system_priority) != partner->system_priority ||\r\nntohs(lacpdu->actor_key) != partner->key ||\r\n(lacpdu->actor_state & AD_STATE_AGGREGATION) != (partner->port_state & AD_STATE_AGGREGATION)) {\r\nport->sm_vars &= ~AD_PORT_SELECTED;\r\n}\r\n}\r\n}\r\nstatic void __update_default_selected(struct port *port)\r\n{\r\nif (port) {\r\nconst struct port_params *admin = &port->partner_admin;\r\nconst struct port_params *oper = &port->partner_oper;\r\nif (admin->port_number != oper->port_number ||\r\nadmin->port_priority != oper->port_priority ||\r\nMAC_ADDRESS_COMPARE(&admin->system, &oper->system) ||\r\nadmin->system_priority != oper->system_priority ||\r\nadmin->key != oper->key ||\r\n(admin->port_state & AD_STATE_AGGREGATION)\r\n!= (oper->port_state & AD_STATE_AGGREGATION)) {\r\nport->sm_vars &= ~AD_PORT_SELECTED;\r\n}\r\n}\r\n}\r\nstatic void __update_ntt(struct lacpdu *lacpdu, struct port *port)\r\n{\r\nif (lacpdu && port) {\r\nif ((ntohs(lacpdu->partner_port) != port->actor_port_number) ||\r\n(ntohs(lacpdu->partner_port_priority) != port->actor_port_priority) ||\r\nMAC_ADDRESS_COMPARE(&(lacpdu->partner_system), &(port->actor_system)) ||\r\n(ntohs(lacpdu->partner_system_priority) != port->actor_system_priority) ||\r\n(ntohs(lacpdu->partner_key) != port->actor_oper_port_key) ||\r\n((lacpdu->partner_state & AD_STATE_LACP_ACTIVITY) != (port->actor_oper_port_state & AD_STATE_LACP_ACTIVITY)) ||\r\n((lacpdu->partner_state & AD_STATE_LACP_TIMEOUT) != (port->actor_oper_port_state & AD_STATE_LACP_TIMEOUT)) ||\r\n((lacpdu->partner_state & AD_STATE_SYNCHRONIZATION) != (port->actor_oper_port_state & AD_STATE_SYNCHRONIZATION)) ||\r\n((lacpdu->partner_state & AD_STATE_AGGREGATION) != (port->actor_oper_port_state & AD_STATE_AGGREGATION))\r\n) {\r\nport->ntt = true;\r\n}\r\n}\r\n}\r\nstatic void __attach_bond_to_agg(struct port *port)\r\n{\r\nport = NULL;\r\n}\r\nstatic void __detach_bond_from_agg(struct port *port)\r\n{\r\nport = NULL;\r\n}\r\nstatic int __agg_ports_are_ready(struct aggregator *aggregator)\r\n{\r\nstruct port *port;\r\nint retval = 1;\r\nif (aggregator) {\r\nfor (port = aggregator->lag_ports;\r\nport;\r\nport = port->next_port_in_aggregator) {\r\nif (!(port->sm_vars & AD_PORT_READY_N)) {\r\nretval = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic void __set_agg_ports_ready(struct aggregator *aggregator, int val)\r\n{\r\nstruct port *port;\r\nfor (port = aggregator->lag_ports; port;\r\nport = port->next_port_in_aggregator) {\r\nif (val)\r\nport->sm_vars |= AD_PORT_READY;\r\nelse\r\nport->sm_vars &= ~AD_PORT_READY;\r\n}\r\n}\r\nstatic u32 __get_agg_bandwidth(struct aggregator *aggregator)\r\n{\r\nu32 bandwidth = 0;\r\nif (aggregator->num_of_ports) {\r\nswitch (__get_link_speed(aggregator->lag_ports)) {\r\ncase AD_LINK_SPEED_BITMASK_1MBPS:\r\nbandwidth = aggregator->num_of_ports;\r\nbreak;\r\ncase AD_LINK_SPEED_BITMASK_10MBPS:\r\nbandwidth = aggregator->num_of_ports * 10;\r\nbreak;\r\ncase AD_LINK_SPEED_BITMASK_100MBPS:\r\nbandwidth = aggregator->num_of_ports * 100;\r\nbreak;\r\ncase AD_LINK_SPEED_BITMASK_1000MBPS:\r\nbandwidth = aggregator->num_of_ports * 1000;\r\nbreak;\r\ncase AD_LINK_SPEED_BITMASK_10000MBPS:\r\nbandwidth = aggregator->num_of_ports * 10000;\r\nbreak;\r\ndefault:\r\nbandwidth = 0;\r\n}\r\n}\r\nreturn bandwidth;\r\n}\r\nstatic struct aggregator *__get_active_agg(struct aggregator *aggregator)\r\n{\r\nstruct aggregator *retval = NULL;\r\nfor (; aggregator; aggregator = __get_next_agg(aggregator)) {\r\nif (aggregator->is_active) {\r\nretval = aggregator;\r\nbreak;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic inline void __update_lacpdu_from_port(struct port *port)\r\n{\r\nstruct lacpdu *lacpdu = &port->lacpdu;\r\nconst struct port_params *partner = &port->partner_oper;\r\nlacpdu->actor_system_priority = htons(port->actor_system_priority);\r\nlacpdu->actor_system = port->actor_system;\r\nlacpdu->actor_key = htons(port->actor_oper_port_key);\r\nlacpdu->actor_port_priority = htons(port->actor_port_priority);\r\nlacpdu->actor_port = htons(port->actor_port_number);\r\nlacpdu->actor_state = port->actor_oper_port_state;\r\nlacpdu->partner_system_priority = htons(partner->system_priority);\r\nlacpdu->partner_system = partner->system;\r\nlacpdu->partner_key = htons(partner->key);\r\nlacpdu->partner_port_priority = htons(partner->port_priority);\r\nlacpdu->partner_port = htons(partner->port_number);\r\nlacpdu->partner_state = partner->port_state;\r\n}\r\nstatic int ad_lacpdu_send(struct port *port)\r\n{\r\nstruct slave *slave = port->slave;\r\nstruct sk_buff *skb;\r\nstruct lacpdu_header *lacpdu_header;\r\nint length = sizeof(struct lacpdu_header);\r\nskb = dev_alloc_skb(length);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb->dev = slave->dev;\r\nskb_reset_mac_header(skb);\r\nskb->network_header = skb->mac_header + ETH_HLEN;\r\nskb->protocol = PKT_TYPE_LACPDU;\r\nskb->priority = TC_PRIO_CONTROL;\r\nlacpdu_header = (struct lacpdu_header *)skb_put(skb, length);\r\nmemcpy(lacpdu_header->hdr.h_dest, lacpdu_mcast_addr, ETH_ALEN);\r\nmemcpy(lacpdu_header->hdr.h_source, slave->perm_hwaddr, ETH_ALEN);\r\nlacpdu_header->hdr.h_proto = PKT_TYPE_LACPDU;\r\nlacpdu_header->lacpdu = port->lacpdu;\r\ndev_queue_xmit(skb);\r\nreturn 0;\r\n}\r\nstatic int ad_marker_send(struct port *port, struct bond_marker *marker)\r\n{\r\nstruct slave *slave = port->slave;\r\nstruct sk_buff *skb;\r\nstruct bond_marker_header *marker_header;\r\nint length = sizeof(struct bond_marker_header);\r\nskb = dev_alloc_skb(length + 16);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_reserve(skb, 16);\r\nskb->dev = slave->dev;\r\nskb_reset_mac_header(skb);\r\nskb->network_header = skb->mac_header + ETH_HLEN;\r\nskb->protocol = PKT_TYPE_LACPDU;\r\nmarker_header = (struct bond_marker_header *)skb_put(skb, length);\r\nmemcpy(marker_header->hdr.h_dest, lacpdu_mcast_addr, ETH_ALEN);\r\nmemcpy(marker_header->hdr.h_source, slave->perm_hwaddr, ETH_ALEN);\r\nmarker_header->hdr.h_proto = PKT_TYPE_LACPDU;\r\nmarker_header->marker = *marker;\r\ndev_queue_xmit(skb);\r\nreturn 0;\r\n}\r\nstatic void ad_mux_machine(struct port *port)\r\n{\r\nmux_states_t last_state;\r\nlast_state = port->sm_mux_state;\r\nif (port->sm_vars & AD_PORT_BEGIN) {\r\nport->sm_mux_state = AD_MUX_DETACHED;\r\n} else {\r\nswitch (port->sm_mux_state) {\r\ncase AD_MUX_DETACHED:\r\nif ((port->sm_vars & AD_PORT_SELECTED)\r\n|| (port->sm_vars & AD_PORT_STANDBY))\r\nport->sm_mux_state = AD_MUX_WAITING;\r\nbreak;\r\ncase AD_MUX_WAITING:\r\nif (!(port->sm_vars & AD_PORT_SELECTED)) {\r\nport->sm_vars &= ~AD_PORT_READY_N;\r\n__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));\r\nport->sm_mux_state = AD_MUX_DETACHED;\r\nbreak;\r\n}\r\nif (port->sm_mux_timer_counter\r\n&& !(--port->sm_mux_timer_counter))\r\nport->sm_vars |= AD_PORT_READY_N;\r\n__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));\r\nif ((port->sm_vars & AD_PORT_READY)\r\n&& !port->sm_mux_timer_counter)\r\nport->sm_mux_state = AD_MUX_ATTACHED;\r\nbreak;\r\ncase AD_MUX_ATTACHED:\r\nif ((port->sm_vars & AD_PORT_SELECTED) && (port->partner_oper.port_state & AD_STATE_SYNCHRONIZATION) && !__check_agg_selection_timer(port)) {\r\nport->sm_mux_state = AD_MUX_COLLECTING_DISTRIBUTING;\r\n} else if (!(port->sm_vars & AD_PORT_SELECTED) || (port->sm_vars & AD_PORT_STANDBY)) {\r\nport->sm_vars &= ~AD_PORT_READY_N;\r\n__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));\r\nport->sm_mux_state = AD_MUX_DETACHED;\r\n}\r\nbreak;\r\ncase AD_MUX_COLLECTING_DISTRIBUTING:\r\nif (!(port->sm_vars & AD_PORT_SELECTED) || (port->sm_vars & AD_PORT_STANDBY) ||\r\n!(port->partner_oper.port_state & AD_STATE_SYNCHRONIZATION)\r\n) {\r\nport->sm_mux_state = AD_MUX_ATTACHED;\r\n} else {\r\nif (port->aggregator &&\r\nport->aggregator->is_active &&\r\n!__port_is_enabled(port)) {\r\n__enable_port(port);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (port->sm_mux_state != last_state) {\r\npr_debug("Mux Machine: Port=%d, Last State=%d, Curr State=%d\n",\r\nport->actor_port_number, last_state,\r\nport->sm_mux_state);\r\nswitch (port->sm_mux_state) {\r\ncase AD_MUX_DETACHED:\r\n__detach_bond_from_agg(port);\r\nport->actor_oper_port_state &= ~AD_STATE_SYNCHRONIZATION;\r\nad_disable_collecting_distributing(port);\r\nport->actor_oper_port_state &= ~AD_STATE_COLLECTING;\r\nport->actor_oper_port_state &= ~AD_STATE_DISTRIBUTING;\r\nport->ntt = true;\r\nbreak;\r\ncase AD_MUX_WAITING:\r\nport->sm_mux_timer_counter = __ad_timer_to_ticks(AD_WAIT_WHILE_TIMER, 0);\r\nbreak;\r\ncase AD_MUX_ATTACHED:\r\n__attach_bond_to_agg(port);\r\nport->actor_oper_port_state |= AD_STATE_SYNCHRONIZATION;\r\nport->actor_oper_port_state &= ~AD_STATE_COLLECTING;\r\nport->actor_oper_port_state &= ~AD_STATE_DISTRIBUTING;\r\nad_disable_collecting_distributing(port);\r\nport->ntt = true;\r\nbreak;\r\ncase AD_MUX_COLLECTING_DISTRIBUTING:\r\nport->actor_oper_port_state |= AD_STATE_COLLECTING;\r\nport->actor_oper_port_state |= AD_STATE_DISTRIBUTING;\r\nad_enable_collecting_distributing(port);\r\nport->ntt = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ad_rx_machine(struct lacpdu *lacpdu, struct port *port)\r\n{\r\nrx_states_t last_state;\r\nlast_state = port->sm_rx_state;\r\nif (port->sm_vars & AD_PORT_BEGIN)\r\nport->sm_rx_state = AD_RX_INITIALIZE;\r\nelse if (!(port->sm_vars & AD_PORT_BEGIN)\r\n&& !port->is_enabled && !(port->sm_vars & AD_PORT_MOVED))\r\nport->sm_rx_state = AD_RX_PORT_DISABLED;\r\nelse if (lacpdu && ((port->sm_rx_state == AD_RX_EXPIRED) || (port->sm_rx_state == AD_RX_DEFAULTED) || (port->sm_rx_state == AD_RX_CURRENT))) {\r\nport->sm_rx_timer_counter = 0;\r\nport->sm_rx_state = AD_RX_CURRENT;\r\n} else {\r\nif (port->sm_rx_timer_counter && !(--port->sm_rx_timer_counter)) {\r\nswitch (port->sm_rx_state) {\r\ncase AD_RX_EXPIRED:\r\nport->sm_rx_state = AD_RX_DEFAULTED;\r\nbreak;\r\ncase AD_RX_CURRENT:\r\nport->sm_rx_state = AD_RX_EXPIRED;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nswitch (port->sm_rx_state) {\r\ncase AD_RX_PORT_DISABLED:\r\nif (port->sm_vars & AD_PORT_MOVED)\r\nport->sm_rx_state = AD_RX_INITIALIZE;\r\nelse if (port->is_enabled\r\n&& (port->sm_vars\r\n& AD_PORT_LACP_ENABLED))\r\nport->sm_rx_state = AD_RX_EXPIRED;\r\nelse if (port->is_enabled\r\n&& ((port->sm_vars\r\n& AD_PORT_LACP_ENABLED) == 0))\r\nport->sm_rx_state = AD_RX_LACP_DISABLED;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nif ((port->sm_rx_state != last_state) || (lacpdu)) {\r\npr_debug("Rx Machine: Port=%d, Last State=%d, Curr State=%d\n",\r\nport->actor_port_number, last_state,\r\nport->sm_rx_state);\r\nswitch (port->sm_rx_state) {\r\ncase AD_RX_INITIALIZE:\r\nif (!(port->actor_oper_port_key & AD_DUPLEX_KEY_BITS))\r\nport->sm_vars &= ~AD_PORT_LACP_ENABLED;\r\nelse\r\nport->sm_vars |= AD_PORT_LACP_ENABLED;\r\nport->sm_vars &= ~AD_PORT_SELECTED;\r\n__record_default(port);\r\nport->actor_oper_port_state &= ~AD_STATE_EXPIRED;\r\nport->sm_vars &= ~AD_PORT_MOVED;\r\nport->sm_rx_state = AD_RX_PORT_DISABLED;\r\ncase AD_RX_PORT_DISABLED:\r\nport->sm_vars &= ~AD_PORT_MATCHED;\r\nbreak;\r\ncase AD_RX_LACP_DISABLED:\r\nport->sm_vars &= ~AD_PORT_SELECTED;\r\n__record_default(port);\r\nport->partner_oper.port_state &= ~AD_STATE_AGGREGATION;\r\nport->sm_vars |= AD_PORT_MATCHED;\r\nport->actor_oper_port_state &= ~AD_STATE_EXPIRED;\r\nbreak;\r\ncase AD_RX_EXPIRED:\r\nport->partner_oper.port_state &= ~AD_STATE_SYNCHRONIZATION;\r\nport->sm_vars &= ~AD_PORT_MATCHED;\r\nport->partner_oper.port_state |=\r\nAD_STATE_LACP_ACTIVITY;\r\nport->sm_rx_timer_counter = __ad_timer_to_ticks(AD_CURRENT_WHILE_TIMER, (u16)(AD_SHORT_TIMEOUT));\r\nport->actor_oper_port_state |= AD_STATE_EXPIRED;\r\nbreak;\r\ncase AD_RX_DEFAULTED:\r\n__update_default_selected(port);\r\n__record_default(port);\r\nport->sm_vars |= AD_PORT_MATCHED;\r\nport->actor_oper_port_state &= ~AD_STATE_EXPIRED;\r\nbreak;\r\ncase AD_RX_CURRENT:\r\nif (!MAC_ADDRESS_COMPARE(&(lacpdu->actor_system), &(port->actor_system))) {\r\npr_err("%s: An illegal loopback occurred on adapter (%s).\n"\r\n"Check the configuration to verify that all adapters are connected to 802.3ad compliant switch ports\n",\r\nport->slave->dev->master->name, port->slave->dev->name);\r\nreturn;\r\n}\r\n__update_selected(lacpdu, port);\r\n__update_ntt(lacpdu, port);\r\n__record_pdu(lacpdu, port);\r\nport->sm_rx_timer_counter = __ad_timer_to_ticks(AD_CURRENT_WHILE_TIMER, (u16)(port->actor_oper_port_state & AD_STATE_LACP_TIMEOUT));\r\nport->actor_oper_port_state &= ~AD_STATE_EXPIRED;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ad_tx_machine(struct port *port)\r\n{\r\nif (port->sm_tx_timer_counter && !(--port->sm_tx_timer_counter)) {\r\nif (port->ntt && (port->sm_vars & AD_PORT_LACP_ENABLED)) {\r\n__update_lacpdu_from_port(port);\r\nif (ad_lacpdu_send(port) >= 0) {\r\npr_debug("Sent LACPDU on port %d\n",\r\nport->actor_port_number);\r\nport->ntt = false;\r\n}\r\n}\r\nport->sm_tx_timer_counter =\r\nad_ticks_per_sec/AD_MAX_TX_IN_SECOND;\r\n}\r\n}\r\nstatic void ad_periodic_machine(struct port *port)\r\n{\r\nperiodic_states_t last_state;\r\nlast_state = port->sm_periodic_state;\r\nif (((port->sm_vars & AD_PORT_BEGIN) || !(port->sm_vars & AD_PORT_LACP_ENABLED) || !port->is_enabled) ||\r\n(!(port->actor_oper_port_state & AD_STATE_LACP_ACTIVITY) && !(port->partner_oper.port_state & AD_STATE_LACP_ACTIVITY))\r\n) {\r\nport->sm_periodic_state = AD_NO_PERIODIC;\r\n}\r\nelse if (port->sm_periodic_timer_counter) {\r\nif (!(--port->sm_periodic_timer_counter)) {\r\nport->sm_periodic_state = AD_PERIODIC_TX;\r\n} else {\r\nswitch (port->sm_periodic_state) {\r\ncase AD_FAST_PERIODIC:\r\nif (!(port->partner_oper.port_state\r\n& AD_STATE_LACP_TIMEOUT))\r\nport->sm_periodic_state = AD_SLOW_PERIODIC;\r\nbreak;\r\ncase AD_SLOW_PERIODIC:\r\nif ((port->partner_oper.port_state & AD_STATE_LACP_TIMEOUT)) {\r\nport->sm_periodic_timer_counter = 0;\r\nport->sm_periodic_state = AD_PERIODIC_TX;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n} else {\r\nswitch (port->sm_periodic_state) {\r\ncase AD_NO_PERIODIC:\r\nport->sm_periodic_state = AD_FAST_PERIODIC;\r\nbreak;\r\ncase AD_PERIODIC_TX:\r\nif (!(port->partner_oper.port_state\r\n& AD_STATE_LACP_TIMEOUT))\r\nport->sm_periodic_state = AD_SLOW_PERIODIC;\r\nelse\r\nport->sm_periodic_state = AD_FAST_PERIODIC;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (port->sm_periodic_state != last_state) {\r\npr_debug("Periodic Machine: Port=%d, Last State=%d, Curr State=%d\n",\r\nport->actor_port_number, last_state,\r\nport->sm_periodic_state);\r\nswitch (port->sm_periodic_state) {\r\ncase AD_NO_PERIODIC:\r\nport->sm_periodic_timer_counter = 0;\r\nbreak;\r\ncase AD_FAST_PERIODIC:\r\nport->sm_periodic_timer_counter = __ad_timer_to_ticks(AD_PERIODIC_TIMER, (u16)(AD_FAST_PERIODIC_TIME))-1;\r\nbreak;\r\ncase AD_SLOW_PERIODIC:\r\nport->sm_periodic_timer_counter = __ad_timer_to_ticks(AD_PERIODIC_TIMER, (u16)(AD_SLOW_PERIODIC_TIME))-1;\r\nbreak;\r\ncase AD_PERIODIC_TX:\r\nport->ntt = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ad_port_selection_logic(struct port *port)\r\n{\r\nstruct aggregator *aggregator, *free_aggregator = NULL, *temp_aggregator;\r\nstruct port *last_port = NULL, *curr_port;\r\nint found = 0;\r\nif (port->sm_vars & AD_PORT_SELECTED)\r\nreturn;\r\nif (port->aggregator) {\r\ntemp_aggregator = port->aggregator;\r\nfor (curr_port = temp_aggregator->lag_ports; curr_port;\r\nlast_port = curr_port,\r\ncurr_port = curr_port->next_port_in_aggregator) {\r\nif (curr_port == port) {\r\ntemp_aggregator->num_of_ports--;\r\nif (!last_port) {\r\ntemp_aggregator->lag_ports =\r\nport->next_port_in_aggregator;\r\n} else {\r\nlast_port->next_port_in_aggregator =\r\nport->next_port_in_aggregator;\r\n}\r\nport->aggregator = NULL;\r\nport->next_port_in_aggregator = NULL;\r\nport->actor_port_aggregator_identifier = 0;\r\npr_debug("Port %d left LAG %d\n",\r\nport->actor_port_number,\r\ntemp_aggregator->aggregator_identifier);\r\nif (!temp_aggregator->lag_ports)\r\nad_clear_agg(temp_aggregator);\r\nbreak;\r\n}\r\n}\r\nif (!curr_port) {\r\npr_warning("%s: Warning: Port %d (on %s) was related to aggregator %d but was not on its port list\n",\r\nport->slave->dev->master->name,\r\nport->actor_port_number,\r\nport->slave->dev->name,\r\nport->aggregator->aggregator_identifier);\r\n}\r\n}\r\nfor (aggregator = __get_first_agg(port); aggregator;\r\naggregator = __get_next_agg(aggregator)) {\r\nif (!aggregator->lag_ports) {\r\nif (!free_aggregator)\r\nfree_aggregator = aggregator;\r\ncontinue;\r\n}\r\nif (((aggregator->actor_oper_aggregator_key == port->actor_oper_port_key) &&\r\n!MAC_ADDRESS_COMPARE(&(aggregator->partner_system), &(port->partner_oper.system)) &&\r\n(aggregator->partner_system_priority == port->partner_oper.system_priority) &&\r\n(aggregator->partner_oper_aggregator_key == port->partner_oper.key)\r\n) &&\r\n((MAC_ADDRESS_COMPARE(&(port->partner_oper.system), &(null_mac_addr)) &&\r\n!aggregator->is_individual)\r\n)\r\n) {\r\nport->aggregator = aggregator;\r\nport->actor_port_aggregator_identifier =\r\nport->aggregator->aggregator_identifier;\r\nport->next_port_in_aggregator = aggregator->lag_ports;\r\nport->aggregator->num_of_ports++;\r\naggregator->lag_ports = port;\r\npr_debug("Port %d joined LAG %d(existing LAG)\n",\r\nport->actor_port_number,\r\nport->aggregator->aggregator_identifier);\r\nport->sm_vars |= AD_PORT_SELECTED;\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nif (free_aggregator) {\r\nport->aggregator = free_aggregator;\r\nport->actor_port_aggregator_identifier =\r\nport->aggregator->aggregator_identifier;\r\nif (port->actor_oper_port_key & AD_DUPLEX_KEY_BITS)\r\nport->aggregator->is_individual = false;\r\nelse\r\nport->aggregator->is_individual = true;\r\nport->aggregator->actor_admin_aggregator_key = port->actor_admin_port_key;\r\nport->aggregator->actor_oper_aggregator_key = port->actor_oper_port_key;\r\nport->aggregator->partner_system =\r\nport->partner_oper.system;\r\nport->aggregator->partner_system_priority =\r\nport->partner_oper.system_priority;\r\nport->aggregator->partner_oper_aggregator_key = port->partner_oper.key;\r\nport->aggregator->receive_state = 1;\r\nport->aggregator->transmit_state = 1;\r\nport->aggregator->lag_ports = port;\r\nport->aggregator->num_of_ports++;\r\nport->sm_vars |= AD_PORT_SELECTED;\r\npr_debug("Port %d joined LAG %d(new LAG)\n",\r\nport->actor_port_number,\r\nport->aggregator->aggregator_identifier);\r\n} else {\r\npr_err("%s: Port %d (on %s) did not find a suitable aggregator\n",\r\nport->slave->dev->master->name,\r\nport->actor_port_number, port->slave->dev->name);\r\n}\r\n}\r\n__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));\r\naggregator = __get_first_agg(port);\r\nad_agg_selection_logic(aggregator);\r\n}\r\nstatic struct aggregator *ad_agg_selection_test(struct aggregator *best,\r\nstruct aggregator *curr)\r\n{\r\nif (!best)\r\nreturn curr;\r\nif (!curr->is_individual && best->is_individual)\r\nreturn curr;\r\nif (curr->is_individual && !best->is_individual)\r\nreturn best;\r\nif (__agg_has_partner(curr) && !__agg_has_partner(best))\r\nreturn curr;\r\nif (!__agg_has_partner(curr) && __agg_has_partner(best))\r\nreturn best;\r\nswitch (__get_agg_selection_mode(curr->lag_ports)) {\r\ncase BOND_AD_COUNT:\r\nif (curr->num_of_ports > best->num_of_ports)\r\nreturn curr;\r\nif (curr->num_of_ports < best->num_of_ports)\r\nreturn best;\r\ncase BOND_AD_STABLE:\r\ncase BOND_AD_BANDWIDTH:\r\nif (__get_agg_bandwidth(curr) > __get_agg_bandwidth(best))\r\nreturn curr;\r\nbreak;\r\ndefault:\r\npr_warning("%s: Impossible agg select mode %d\n",\r\ncurr->slave->dev->master->name,\r\n__get_agg_selection_mode(curr->lag_ports));\r\nbreak;\r\n}\r\nreturn best;\r\n}\r\nstatic int agg_device_up(const struct aggregator *agg)\r\n{\r\nstruct port *port = agg->lag_ports;\r\nif (!port)\r\nreturn 0;\r\nreturn (netif_running(port->slave->dev) &&\r\nnetif_carrier_ok(port->slave->dev));\r\n}\r\nstatic void ad_agg_selection_logic(struct aggregator *agg)\r\n{\r\nstruct aggregator *best, *active, *origin;\r\nstruct port *port;\r\norigin = agg;\r\nactive = __get_active_agg(agg);\r\nbest = (active && agg_device_up(active)) ? active : NULL;\r\ndo {\r\nagg->is_active = 0;\r\nif (agg->num_of_ports && agg_device_up(agg))\r\nbest = ad_agg_selection_test(best, agg);\r\n} while ((agg = __get_next_agg(agg)));\r\nif (best &&\r\n__get_agg_selection_mode(best->lag_ports) == BOND_AD_STABLE) {\r\nif (active && active->lag_ports &&\r\nactive->lag_ports->is_enabled &&\r\n(__agg_has_partner(active) ||\r\n(!__agg_has_partner(active) && !__agg_has_partner(best)))) {\r\nif (!(!active->actor_oper_aggregator_key &&\r\nbest->actor_oper_aggregator_key)) {\r\nbest = NULL;\r\nactive->is_active = 1;\r\n}\r\n}\r\n}\r\nif (best && (best == active)) {\r\nbest = NULL;\r\nactive->is_active = 1;\r\n}\r\nif (best) {\r\npr_debug("best Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\n",\r\nbest->aggregator_identifier, best->num_of_ports,\r\nbest->actor_oper_aggregator_key,\r\nbest->partner_oper_aggregator_key,\r\nbest->is_individual, best->is_active);\r\npr_debug("best ports %p slave %p %s\n",\r\nbest->lag_ports, best->slave,\r\nbest->slave ? best->slave->dev->name : "NULL");\r\nfor (agg = __get_first_agg(best->lag_ports); agg;\r\nagg = __get_next_agg(agg)) {\r\npr_debug("Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\n",\r\nagg->aggregator_identifier, agg->num_of_ports,\r\nagg->actor_oper_aggregator_key,\r\nagg->partner_oper_aggregator_key,\r\nagg->is_individual, agg->is_active);\r\n}\r\nif (best->is_individual) {\r\npr_warning("%s: Warning: No 802.3ad response from the link partner for any adapters in the bond\n",\r\nbest->slave ? best->slave->dev->master->name : "NULL");\r\n}\r\nbest->is_active = 1;\r\npr_debug("LAG %d chosen as the active LAG\n",\r\nbest->aggregator_identifier);\r\npr_debug("Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\n",\r\nbest->aggregator_identifier, best->num_of_ports,\r\nbest->actor_oper_aggregator_key,\r\nbest->partner_oper_aggregator_key,\r\nbest->is_individual, best->is_active);\r\nif (active) {\r\nfor (port = active->lag_ports; port;\r\nport = port->next_port_in_aggregator) {\r\n__disable_port(port);\r\n}\r\n}\r\n}\r\nactive = __get_active_agg(origin);\r\nif (active) {\r\nif (!__agg_has_partner(active)) {\r\nfor (port = active->lag_ports; port;\r\nport = port->next_port_in_aggregator) {\r\n__enable_port(port);\r\n}\r\n}\r\n}\r\nif (origin->slave) {\r\nstruct bonding *bond;\r\nbond = bond_get_bond_by_slave(origin->slave);\r\nif (bond)\r\nbond_3ad_set_carrier(bond);\r\n}\r\n}\r\nstatic void ad_clear_agg(struct aggregator *aggregator)\r\n{\r\nif (aggregator) {\r\naggregator->is_individual = false;\r\naggregator->actor_admin_aggregator_key = 0;\r\naggregator->actor_oper_aggregator_key = 0;\r\naggregator->partner_system = null_mac_addr;\r\naggregator->partner_system_priority = 0;\r\naggregator->partner_oper_aggregator_key = 0;\r\naggregator->receive_state = 0;\r\naggregator->transmit_state = 0;\r\naggregator->lag_ports = NULL;\r\naggregator->is_active = 0;\r\naggregator->num_of_ports = 0;\r\npr_debug("LAG %d was cleared\n",\r\naggregator->aggregator_identifier);\r\n}\r\n}\r\nstatic void ad_initialize_agg(struct aggregator *aggregator)\r\n{\r\nif (aggregator) {\r\nad_clear_agg(aggregator);\r\naggregator->aggregator_mac_address = null_mac_addr;\r\naggregator->aggregator_identifier = 0;\r\naggregator->slave = NULL;\r\n}\r\n}\r\nstatic void ad_initialize_port(struct port *port, int lacp_fast)\r\n{\r\nstatic const struct port_params tmpl = {\r\n.system_priority = 0xffff,\r\n.key = 1,\r\n.port_number = 1,\r\n.port_priority = 0xff,\r\n.port_state = 1,\r\n};\r\nstatic const struct lacpdu lacpdu = {\r\n.subtype = 0x01,\r\n.version_number = 0x01,\r\n.tlv_type_actor_info = 0x01,\r\n.actor_information_length = 0x14,\r\n.tlv_type_partner_info = 0x02,\r\n.partner_information_length = 0x14,\r\n.tlv_type_collector_info = 0x03,\r\n.collector_information_length = 0x10,\r\n.collector_max_delay = htons(AD_COLLECTOR_MAX_DELAY),\r\n};\r\nif (port) {\r\nport->actor_port_number = 1;\r\nport->actor_port_priority = 0xff;\r\nport->actor_system = null_mac_addr;\r\nport->actor_system_priority = 0xffff;\r\nport->actor_port_aggregator_identifier = 0;\r\nport->ntt = false;\r\nport->actor_admin_port_key = 1;\r\nport->actor_oper_port_key = 1;\r\nport->actor_admin_port_state = AD_STATE_AGGREGATION | AD_STATE_LACP_ACTIVITY;\r\nport->actor_oper_port_state = AD_STATE_AGGREGATION | AD_STATE_LACP_ACTIVITY;\r\nif (lacp_fast)\r\nport->actor_oper_port_state |= AD_STATE_LACP_TIMEOUT;\r\nmemcpy(&port->partner_admin, &tmpl, sizeof(tmpl));\r\nmemcpy(&port->partner_oper, &tmpl, sizeof(tmpl));\r\nport->is_enabled = true;\r\nport->sm_vars = 0x3;\r\nport->sm_rx_state = 0;\r\nport->sm_rx_timer_counter = 0;\r\nport->sm_periodic_state = 0;\r\nport->sm_periodic_timer_counter = 0;\r\nport->sm_mux_state = 0;\r\nport->sm_mux_timer_counter = 0;\r\nport->sm_tx_state = 0;\r\nport->sm_tx_timer_counter = 0;\r\nport->slave = NULL;\r\nport->aggregator = NULL;\r\nport->next_port_in_aggregator = NULL;\r\nport->transaction_id = 0;\r\nmemcpy(&port->lacpdu, &lacpdu, sizeof(lacpdu));\r\n}\r\n}\r\nstatic void ad_enable_collecting_distributing(struct port *port)\r\n{\r\nif (port->aggregator->is_active) {\r\npr_debug("Enabling port %d(LAG %d)\n",\r\nport->actor_port_number,\r\nport->aggregator->aggregator_identifier);\r\n__enable_port(port);\r\n}\r\n}\r\nstatic void ad_disable_collecting_distributing(struct port *port)\r\n{\r\nif (port->aggregator && MAC_ADDRESS_COMPARE(&(port->aggregator->partner_system), &(null_mac_addr))) {\r\npr_debug("Disabling port %d(LAG %d)\n",\r\nport->actor_port_number,\r\nport->aggregator->aggregator_identifier);\r\n__disable_port(port);\r\n}\r\n}\r\nstatic void ad_marker_info_received(struct bond_marker *marker_info,\r\nstruct port *port)\r\n{\r\nstruct bond_marker marker;\r\nmemcpy(&marker, marker_info, sizeof(struct bond_marker));\r\nmarker.tlv_type = AD_MARKER_RESPONSE_SUBTYPE;\r\nif (ad_marker_send(port, &marker) >= 0) {\r\npr_debug("Sent Marker Response on port %d\n",\r\nport->actor_port_number);\r\n}\r\n}\r\nstatic void ad_marker_response_received(struct bond_marker *marker,\r\nstruct port *port)\r\n{\r\nmarker = NULL;\r\nport = NULL;\r\n}\r\nvoid bond_3ad_initiate_agg_selection(struct bonding *bond, int timeout)\r\n{\r\nBOND_AD_INFO(bond).agg_select_timer = timeout;\r\n}\r\nvoid bond_3ad_initialize(struct bonding *bond, u16 tick_resolution)\r\n{\r\nif (MAC_ADDRESS_COMPARE(&(BOND_AD_INFO(bond).system.sys_mac_addr),\r\nbond->dev->dev_addr)) {\r\naggregator_identifier = 0;\r\nBOND_AD_INFO(bond).system.sys_priority = 0xFFFF;\r\nBOND_AD_INFO(bond).system.sys_mac_addr = *((struct mac_addr *)bond->dev->dev_addr);\r\nad_ticks_per_sec = tick_resolution;\r\nbond_3ad_initiate_agg_selection(bond,\r\nAD_AGGREGATOR_SELECTION_TIMER *\r\nad_ticks_per_sec);\r\n}\r\n}\r\nint bond_3ad_bind_slave(struct slave *slave)\r\n{\r\nstruct bonding *bond = bond_get_bond_by_slave(slave);\r\nstruct port *port;\r\nstruct aggregator *aggregator;\r\nif (bond == NULL) {\r\npr_err("%s: The slave %s is not attached to its bond\n",\r\nslave->dev->master->name, slave->dev->name);\r\nreturn -1;\r\n}\r\nif (SLAVE_AD_INFO(slave).port.slave != slave) {\r\nport = &(SLAVE_AD_INFO(slave).port);\r\nad_initialize_port(port, bond->params.lacp_fast);\r\nport->slave = slave;\r\nport->actor_port_number = SLAVE_AD_INFO(slave).id;\r\nport->actor_admin_port_key = 0;\r\nport->actor_admin_port_key |= __get_duplex(port);\r\nport->actor_admin_port_key |= (__get_link_speed(port) << 1);\r\nport->actor_oper_port_key = port->actor_admin_port_key;\r\nif (!(port->actor_oper_port_key & AD_DUPLEX_KEY_BITS))\r\nport->sm_vars &= ~AD_PORT_LACP_ENABLED;\r\nport->actor_system = BOND_AD_INFO(bond).system.sys_mac_addr;\r\nport->sm_tx_timer_counter = ad_ticks_per_sec/AD_MAX_TX_IN_SECOND;\r\nport->aggregator = NULL;\r\nport->next_port_in_aggregator = NULL;\r\n__disable_port(port);\r\n__initialize_port_locks(port);\r\naggregator = &(SLAVE_AD_INFO(slave).aggregator);\r\nad_initialize_agg(aggregator);\r\naggregator->aggregator_mac_address = *((struct mac_addr *)bond->dev->dev_addr);\r\naggregator->aggregator_identifier = (++aggregator_identifier);\r\naggregator->slave = slave;\r\naggregator->is_active = 0;\r\naggregator->num_of_ports = 0;\r\n}\r\nreturn 0;\r\n}\r\nvoid bond_3ad_unbind_slave(struct slave *slave)\r\n{\r\nstruct port *port, *prev_port, *temp_port;\r\nstruct aggregator *aggregator, *new_aggregator, *temp_aggregator;\r\nint select_new_active_agg = 0;\r\naggregator = &(SLAVE_AD_INFO(slave).aggregator);\r\nport = &(SLAVE_AD_INFO(slave).port);\r\nif (!port->slave) {\r\npr_warning("Warning: %s: Trying to unbind an uninitialized port on %s\n",\r\nslave->dev->master->name, slave->dev->name);\r\nreturn;\r\n}\r\npr_debug("Unbinding Link Aggregation Group %d\n",\r\naggregator->aggregator_identifier);\r\nport->actor_oper_port_state &= ~AD_STATE_AGGREGATION;\r\n__update_lacpdu_from_port(port);\r\nad_lacpdu_send(port);\r\nif (aggregator->lag_ports) {\r\nif ((aggregator->lag_ports != port) || (aggregator->lag_ports->next_port_in_aggregator)) {\r\nnew_aggregator = __get_first_agg(port);\r\nfor (; new_aggregator; new_aggregator = __get_next_agg(new_aggregator)) {\r\nif (!new_aggregator->lag_ports\r\n|| ((new_aggregator->lag_ports == port)\r\n&& !new_aggregator->lag_ports->next_port_in_aggregator))\r\nbreak;\r\n}\r\nif ((new_aggregator) && ((!new_aggregator->lag_ports) || ((new_aggregator->lag_ports == port) && !new_aggregator->lag_ports->next_port_in_aggregator))) {\r\npr_debug("Some port(s) related to LAG %d - replaceing with LAG %d\n",\r\naggregator->aggregator_identifier,\r\nnew_aggregator->aggregator_identifier);\r\nif ((new_aggregator->lag_ports == port) && new_aggregator->is_active) {\r\npr_info("%s: Removing an active aggregator\n",\r\naggregator->slave->dev->master->name);\r\nselect_new_active_agg = 1;\r\n}\r\nnew_aggregator->is_individual = aggregator->is_individual;\r\nnew_aggregator->actor_admin_aggregator_key = aggregator->actor_admin_aggregator_key;\r\nnew_aggregator->actor_oper_aggregator_key = aggregator->actor_oper_aggregator_key;\r\nnew_aggregator->partner_system = aggregator->partner_system;\r\nnew_aggregator->partner_system_priority = aggregator->partner_system_priority;\r\nnew_aggregator->partner_oper_aggregator_key = aggregator->partner_oper_aggregator_key;\r\nnew_aggregator->receive_state = aggregator->receive_state;\r\nnew_aggregator->transmit_state = aggregator->transmit_state;\r\nnew_aggregator->lag_ports = aggregator->lag_ports;\r\nnew_aggregator->is_active = aggregator->is_active;\r\nnew_aggregator->num_of_ports = aggregator->num_of_ports;\r\nfor (temp_port = aggregator->lag_ports; temp_port;\r\ntemp_port = temp_port->next_port_in_aggregator) {\r\ntemp_port->aggregator = new_aggregator;\r\ntemp_port->actor_port_aggregator_identifier = new_aggregator->aggregator_identifier;\r\n}\r\nad_clear_agg(aggregator);\r\nif (select_new_active_agg)\r\nad_agg_selection_logic(__get_first_agg(port));\r\n} else {\r\npr_warning("%s: Warning: unbinding aggregator, and could not find a new aggregator for its ports\n",\r\nslave->dev->master->name);\r\n}\r\n} else {\r\nselect_new_active_agg = aggregator->is_active;\r\nad_clear_agg(aggregator);\r\nif (select_new_active_agg) {\r\npr_info("%s: Removing an active aggregator\n",\r\nslave->dev->master->name);\r\nad_agg_selection_logic(__get_first_agg(port));\r\n}\r\n}\r\n}\r\npr_debug("Unbinding port %d\n", port->actor_port_number);\r\ntemp_aggregator = __get_first_agg(port);\r\nfor (; temp_aggregator; temp_aggregator = __get_next_agg(temp_aggregator)) {\r\nprev_port = NULL;\r\nfor (temp_port = temp_aggregator->lag_ports; temp_port;\r\nprev_port = temp_port,\r\ntemp_port = temp_port->next_port_in_aggregator) {\r\nif (temp_port == port) {\r\nif (prev_port)\r\nprev_port->next_port_in_aggregator = temp_port->next_port_in_aggregator;\r\nelse\r\ntemp_aggregator->lag_ports = temp_port->next_port_in_aggregator;\r\ntemp_aggregator->num_of_ports--;\r\nif (temp_aggregator->num_of_ports == 0) {\r\nselect_new_active_agg = temp_aggregator->is_active;\r\nad_clear_agg(temp_aggregator);\r\nif (select_new_active_agg) {\r\npr_info("%s: Removing an active aggregator\n",\r\nslave->dev->master->name);\r\nad_agg_selection_logic(__get_first_agg(port));\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nport->slave = NULL;\r\n}\r\nvoid bond_3ad_state_machine_handler(struct work_struct *work)\r\n{\r\nstruct bonding *bond = container_of(work, struct bonding,\r\nad_work.work);\r\nstruct port *port;\r\nstruct aggregator *aggregator;\r\nread_lock(&bond->lock);\r\nif (bond->slave_cnt == 0)\r\ngoto re_arm;\r\nif (BOND_AD_INFO(bond).agg_select_timer && !(--BOND_AD_INFO(bond).agg_select_timer)) {\r\nif ((port = __get_first_port(bond))) {\r\nif (!port->slave) {\r\npr_warning("%s: Warning: bond's first port is uninitialized\n",\r\nbond->dev->name);\r\ngoto re_arm;\r\n}\r\naggregator = __get_first_agg(port);\r\nad_agg_selection_logic(aggregator);\r\n}\r\nbond_3ad_set_carrier(bond);\r\n}\r\nfor (port = __get_first_port(bond); port; port = __get_next_port(port)) {\r\nif (!port->slave) {\r\npr_warning("%s: Warning: Found an uninitialized port\n",\r\nbond->dev->name);\r\ngoto re_arm;\r\n}\r\n__get_state_machine_lock(port);\r\nad_rx_machine(NULL, port);\r\nad_periodic_machine(port);\r\nad_port_selection_logic(port);\r\nad_mux_machine(port);\r\nad_tx_machine(port);\r\nif (port->sm_vars & AD_PORT_BEGIN)\r\nport->sm_vars &= ~AD_PORT_BEGIN;\r\n__release_state_machine_lock(port);\r\n}\r\nre_arm:\r\nqueue_delayed_work(bond->wq, &bond->ad_work, ad_delta_in_ticks);\r\nread_unlock(&bond->lock);\r\n}\r\nstatic int bond_3ad_rx_indication(struct lacpdu *lacpdu, struct slave *slave, u16 length)\r\n{\r\nstruct port *port;\r\nint ret = RX_HANDLER_ANOTHER;\r\nif (length >= sizeof(struct lacpdu)) {\r\nport = &(SLAVE_AD_INFO(slave).port);\r\nif (!port->slave) {\r\npr_warning("%s: Warning: port of slave %s is uninitialized\n",\r\nslave->dev->name, slave->dev->master->name);\r\nreturn ret;\r\n}\r\nswitch (lacpdu->subtype) {\r\ncase AD_TYPE_LACPDU:\r\nret = RX_HANDLER_CONSUMED;\r\npr_debug("Received LACPDU on port %d\n",\r\nport->actor_port_number);\r\n__get_state_machine_lock(port);\r\nad_rx_machine(lacpdu, port);\r\n__release_state_machine_lock(port);\r\nbreak;\r\ncase AD_TYPE_MARKER:\r\nret = RX_HANDLER_CONSUMED;\r\nswitch (((struct bond_marker *)lacpdu)->tlv_type) {\r\ncase AD_MARKER_INFORMATION_SUBTYPE:\r\npr_debug("Received Marker Information on port %d\n",\r\nport->actor_port_number);\r\nad_marker_info_received((struct bond_marker *)lacpdu, port);\r\nbreak;\r\ncase AD_MARKER_RESPONSE_SUBTYPE:\r\npr_debug("Received Marker Response on port %d\n",\r\nport->actor_port_number);\r\nad_marker_response_received((struct bond_marker *)lacpdu, port);\r\nbreak;\r\ndefault:\r\npr_debug("Received an unknown Marker subtype on slot %d\n",\r\nport->actor_port_number);\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid bond_3ad_adapter_speed_changed(struct slave *slave)\r\n{\r\nstruct port *port;\r\nport = &(SLAVE_AD_INFO(slave).port);\r\nif (!port->slave) {\r\npr_warning("Warning: %s: speed changed for uninitialized port on %s\n",\r\nslave->dev->master->name, slave->dev->name);\r\nreturn;\r\n}\r\nport->actor_admin_port_key &= ~AD_SPEED_KEY_BITS;\r\nport->actor_oper_port_key = port->actor_admin_port_key |=\r\n(__get_link_speed(port) << 1);\r\npr_debug("Port %d changed speed\n", port->actor_port_number);\r\nport->sm_vars |= AD_PORT_BEGIN;\r\n}\r\nvoid bond_3ad_adapter_duplex_changed(struct slave *slave)\r\n{\r\nstruct port *port;\r\nport = &(SLAVE_AD_INFO(slave).port);\r\nif (!port->slave) {\r\npr_warning("%s: Warning: duplex changed for uninitialized port on %s\n",\r\nslave->dev->master->name, slave->dev->name);\r\nreturn;\r\n}\r\nport->actor_admin_port_key &= ~AD_DUPLEX_KEY_BITS;\r\nport->actor_oper_port_key = port->actor_admin_port_key |=\r\n__get_duplex(port);\r\npr_debug("Port %d changed duplex\n", port->actor_port_number);\r\nport->sm_vars |= AD_PORT_BEGIN;\r\n}\r\nvoid bond_3ad_handle_link_change(struct slave *slave, char link)\r\n{\r\nstruct port *port;\r\nport = &(SLAVE_AD_INFO(slave).port);\r\nif (!port->slave) {\r\npr_warning("Warning: %s: link status changed for uninitialized port on %s\n",\r\nslave->dev->master->name, slave->dev->name);\r\nreturn;\r\n}\r\nif (link == BOND_LINK_UP) {\r\nport->is_enabled = true;\r\nport->actor_admin_port_key &= ~AD_DUPLEX_KEY_BITS;\r\nport->actor_oper_port_key = port->actor_admin_port_key |=\r\n__get_duplex(port);\r\nport->actor_admin_port_key &= ~AD_SPEED_KEY_BITS;\r\nport->actor_oper_port_key = port->actor_admin_port_key |=\r\n(__get_link_speed(port) << 1);\r\n} else {\r\nport->is_enabled = false;\r\nport->actor_admin_port_key &= ~AD_DUPLEX_KEY_BITS;\r\nport->actor_oper_port_key = (port->actor_admin_port_key &=\r\n~AD_SPEED_KEY_BITS);\r\n}\r\nport->sm_vars |= AD_PORT_BEGIN;\r\n}\r\nint bond_3ad_set_carrier(struct bonding *bond)\r\n{\r\nstruct aggregator *active;\r\nactive = __get_active_agg(&(SLAVE_AD_INFO(bond->first_slave).aggregator));\r\nif (active) {\r\nif (active->num_of_ports < bond->params.min_links) {\r\nif (netif_carrier_ok(bond->dev)) {\r\nnetif_carrier_off(bond->dev);\r\nreturn 1;\r\n}\r\n} else if (!netif_carrier_ok(bond->dev)) {\r\nnetif_carrier_on(bond->dev);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nif (netif_carrier_ok(bond->dev)) {\r\nnetif_carrier_off(bond->dev);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint bond_3ad_get_active_agg_info(struct bonding *bond, struct ad_info *ad_info)\r\n{\r\nstruct aggregator *aggregator = NULL;\r\nstruct port *port;\r\nfor (port = __get_first_port(bond); port; port = __get_next_port(port)) {\r\nif (port->aggregator && port->aggregator->is_active) {\r\naggregator = port->aggregator;\r\nbreak;\r\n}\r\n}\r\nif (aggregator) {\r\nad_info->aggregator_id = aggregator->aggregator_identifier;\r\nad_info->ports = aggregator->num_of_ports;\r\nad_info->actor_key = aggregator->actor_oper_aggregator_key;\r\nad_info->partner_key = aggregator->partner_oper_aggregator_key;\r\nmemcpy(ad_info->partner_system, aggregator->partner_system.mac_addr_value, ETH_ALEN);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nint bond_3ad_xmit_xor(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct slave *slave, *start_at;\r\nstruct bonding *bond = netdev_priv(dev);\r\nint slave_agg_no;\r\nint slaves_in_agg;\r\nint agg_id;\r\nint i;\r\nstruct ad_info ad_info;\r\nint res = 1;\r\nif (bond_3ad_get_active_agg_info(bond, &ad_info)) {\r\npr_debug("%s: Error: bond_3ad_get_active_agg_info failed\n",\r\ndev->name);\r\ngoto out;\r\n}\r\nslaves_in_agg = ad_info.ports;\r\nagg_id = ad_info.aggregator_id;\r\nif (slaves_in_agg == 0) {\r\npr_debug("%s: Error: active aggregator is empty\n", dev->name);\r\ngoto out;\r\n}\r\nslave_agg_no = bond->xmit_hash_policy(skb, slaves_in_agg);\r\nbond_for_each_slave(bond, slave, i) {\r\nstruct aggregator *agg = SLAVE_AD_INFO(slave).port.aggregator;\r\nif (agg && (agg->aggregator_identifier == agg_id)) {\r\nslave_agg_no--;\r\nif (slave_agg_no < 0)\r\nbreak;\r\n}\r\n}\r\nif (slave_agg_no >= 0) {\r\npr_err("%s: Error: Couldn't find a slave to tx on for aggregator ID %d\n",\r\ndev->name, agg_id);\r\ngoto out;\r\n}\r\nstart_at = slave;\r\nbond_for_each_slave_from(bond, slave, i, start_at) {\r\nint slave_agg_id = 0;\r\nstruct aggregator *agg = SLAVE_AD_INFO(slave).port.aggregator;\r\nif (agg)\r\nslave_agg_id = agg->aggregator_identifier;\r\nif (SLAVE_IS_OK(slave) && agg && (slave_agg_id == agg_id)) {\r\nres = bond_dev_queue_xmit(bond, skb, slave->dev);\r\nbreak;\r\n}\r\n}\r\nout:\r\nif (res) {\r\nkfree_skb(skb);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nint bond_3ad_lacpdu_recv(const struct sk_buff *skb, struct bonding *bond,\r\nstruct slave *slave)\r\n{\r\nint ret = RX_HANDLER_ANOTHER;\r\nstruct lacpdu *lacpdu, _lacpdu;\r\nif (skb->protocol != PKT_TYPE_LACPDU)\r\nreturn ret;\r\nlacpdu = skb_header_pointer(skb, 0, sizeof(_lacpdu), &_lacpdu);\r\nif (!lacpdu)\r\nreturn ret;\r\nread_lock(&bond->lock);\r\nret = bond_3ad_rx_indication(lacpdu, slave, skb->len);\r\nread_unlock(&bond->lock);\r\nreturn ret;\r\n}\r\nvoid bond_3ad_update_lacp_rate(struct bonding *bond)\r\n{\r\nint i;\r\nstruct slave *slave;\r\nstruct port *port = NULL;\r\nint lacp_fast;\r\nread_lock(&bond->lock);\r\nlacp_fast = bond->params.lacp_fast;\r\nbond_for_each_slave(bond, slave, i) {\r\nport = &(SLAVE_AD_INFO(slave).port);\r\n__get_state_machine_lock(port);\r\nif (lacp_fast)\r\nport->actor_oper_port_state |= AD_STATE_LACP_TIMEOUT;\r\nelse\r\nport->actor_oper_port_state &= ~AD_STATE_LACP_TIMEOUT;\r\n__release_state_machine_lock(port);\r\n}\r\nread_unlock(&bond->lock);\r\n}
