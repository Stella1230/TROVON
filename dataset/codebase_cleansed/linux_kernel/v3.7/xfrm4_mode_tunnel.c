int xfrm4_mode_tunnel_input_register(struct xfrm_tunnel *handler)\r\n{\r\nstruct xfrm_tunnel __rcu **pprev;\r\nstruct xfrm_tunnel *t;\r\nint ret = -EEXIST;\r\nint priority = handler->priority;\r\nmutex_lock(&xfrm4_mode_tunnel_input_mutex);\r\nfor (pprev = &rcv_notify_handlers;\r\n(t = rcu_dereference_protected(*pprev,\r\nlockdep_is_held(&xfrm4_mode_tunnel_input_mutex))) != NULL;\r\npprev = &t->next) {\r\nif (t->priority > priority)\r\nbreak;\r\nif (t->priority == priority)\r\ngoto err;\r\n}\r\nhandler->next = *pprev;\r\nrcu_assign_pointer(*pprev, handler);\r\nret = 0;\r\nerr:\r\nmutex_unlock(&xfrm4_mode_tunnel_input_mutex);\r\nreturn ret;\r\n}\r\nint xfrm4_mode_tunnel_input_deregister(struct xfrm_tunnel *handler)\r\n{\r\nstruct xfrm_tunnel __rcu **pprev;\r\nstruct xfrm_tunnel *t;\r\nint ret = -ENOENT;\r\nmutex_lock(&xfrm4_mode_tunnel_input_mutex);\r\nfor (pprev = &rcv_notify_handlers;\r\n(t = rcu_dereference_protected(*pprev,\r\nlockdep_is_held(&xfrm4_mode_tunnel_input_mutex))) != NULL;\r\npprev = &t->next) {\r\nif (t == handler) {\r\n*pprev = handler->next;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&xfrm4_mode_tunnel_input_mutex);\r\nsynchronize_net();\r\nreturn ret;\r\n}\r\nstatic inline void ipip_ecn_decapsulate(struct sk_buff *skb)\r\n{\r\nstruct iphdr *inner_iph = ipip_hdr(skb);\r\nif (INET_ECN_is_ce(XFRM_MODE_SKB_CB(skb)->tos))\r\nIP_ECN_set_ce(inner_iph);\r\n}\r\nstatic int xfrm4_mode_tunnel_output(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct iphdr *top_iph;\r\nint flags;\r\nskb_set_network_header(skb, -x->props.header_len);\r\nskb->mac_header = skb->network_header +\r\noffsetof(struct iphdr, protocol);\r\nskb->transport_header = skb->network_header + sizeof(*top_iph);\r\ntop_iph = ip_hdr(skb);\r\ntop_iph->ihl = 5;\r\ntop_iph->version = 4;\r\ntop_iph->protocol = xfrm_af2proto(skb_dst(skb)->ops->family);\r\ntop_iph->tos = INET_ECN_encapsulate(XFRM_MODE_SKB_CB(skb)->tos,\r\nXFRM_MODE_SKB_CB(skb)->tos);\r\nflags = x->props.flags;\r\nif (flags & XFRM_STATE_NOECN)\r\nIP_ECN_clear(top_iph);\r\ntop_iph->frag_off = (flags & XFRM_STATE_NOPMTUDISC) ?\r\n0 : (XFRM_MODE_SKB_CB(skb)->frag_off & htons(IP_DF));\r\nip_select_ident(top_iph, dst->child, NULL);\r\ntop_iph->ttl = ip4_dst_hoplimit(dst->child);\r\ntop_iph->saddr = x->props.saddr.a4;\r\ntop_iph->daddr = x->id.daddr.a4;\r\nreturn 0;\r\n}\r\nstatic int xfrm4_mode_tunnel_input(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nstruct xfrm_tunnel *handler;\r\nint err = -EINVAL;\r\nif (XFRM_MODE_SKB_CB(skb)->protocol != IPPROTO_IPIP)\r\ngoto out;\r\nif (!pskb_may_pull(skb, sizeof(struct iphdr)))\r\ngoto out;\r\nfor_each_input_rcu(rcv_notify_handlers, handler)\r\nhandler->handler(skb);\r\nif (skb_cloned(skb) &&\r\n(err = pskb_expand_head(skb, 0, 0, GFP_ATOMIC)))\r\ngoto out;\r\nif (x->props.flags & XFRM_STATE_DECAP_DSCP)\r\nipv4_copy_dscp(XFRM_MODE_SKB_CB(skb)->tos, ipip_hdr(skb));\r\nif (!(x->props.flags & XFRM_STATE_NOECN))\r\nipip_ecn_decapsulate(skb);\r\nskb_reset_network_header(skb);\r\nskb_mac_header_rebuild(skb);\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int __init xfrm4_mode_tunnel_init(void)\r\n{\r\nreturn xfrm_register_mode(&xfrm4_tunnel_mode, AF_INET);\r\n}\r\nstatic void __exit xfrm4_mode_tunnel_exit(void)\r\n{\r\nint err;\r\nerr = xfrm_unregister_mode(&xfrm4_tunnel_mode, AF_INET);\r\nBUG_ON(err);\r\n}
