static int srp_iu_pool_alloc(struct srp_queue *q, size_t max,\r\nstruct srp_buf **ring)\r\n{\r\nint i;\r\nstruct iu_entry *iue;\r\nq->pool = kcalloc(max, sizeof(struct iu_entry *), GFP_KERNEL);\r\nif (!q->pool)\r\nreturn -ENOMEM;\r\nq->items = kcalloc(max, sizeof(struct iu_entry), GFP_KERNEL);\r\nif (!q->items)\r\ngoto free_pool;\r\nspin_lock_init(&q->lock);\r\nkfifo_init(&q->queue, (void *) q->pool, max * sizeof(void *));\r\nfor (i = 0, iue = q->items; i < max; i++) {\r\nkfifo_in(&q->queue, (void *) &iue, sizeof(void *));\r\niue->sbuf = ring[i];\r\niue++;\r\n}\r\nreturn 0;\r\nkfree(q->items);\r\nfree_pool:\r\nkfree(q->pool);\r\nreturn -ENOMEM;\r\n}\r\nstatic void srp_iu_pool_free(struct srp_queue *q)\r\n{\r\nkfree(q->items);\r\nkfree(q->pool);\r\n}\r\nstatic struct srp_buf **srp_ring_alloc(struct device *dev,\r\nsize_t max, size_t size)\r\n{\r\nint i;\r\nstruct srp_buf **ring;\r\nring = kcalloc(max, sizeof(struct srp_buf *), GFP_KERNEL);\r\nif (!ring)\r\nreturn NULL;\r\nfor (i = 0; i < max; i++) {\r\nring[i] = kzalloc(sizeof(struct srp_buf), GFP_KERNEL);\r\nif (!ring[i])\r\ngoto out;\r\nring[i]->buf = dma_alloc_coherent(dev, size, &ring[i]->dma,\r\nGFP_KERNEL);\r\nif (!ring[i]->buf)\r\ngoto out;\r\n}\r\nreturn ring;\r\nout:\r\nfor (i = 0; i < max && ring[i]; i++) {\r\nif (ring[i]->buf)\r\ndma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);\r\nkfree(ring[i]);\r\n}\r\nkfree(ring);\r\nreturn NULL;\r\n}\r\nstatic void srp_ring_free(struct device *dev, struct srp_buf **ring, size_t max,\r\nsize_t size)\r\n{\r\nint i;\r\nfor (i = 0; i < max; i++) {\r\ndma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);\r\nkfree(ring[i]);\r\n}\r\nkfree(ring);\r\n}\r\nint srp_target_alloc(struct srp_target *target, struct device *dev,\r\nsize_t nr, size_t iu_size)\r\n{\r\nint err;\r\nspin_lock_init(&target->lock);\r\nINIT_LIST_HEAD(&target->cmd_queue);\r\ntarget->dev = dev;\r\ndev_set_drvdata(target->dev, target);\r\ntarget->srp_iu_size = iu_size;\r\ntarget->rx_ring_size = nr;\r\ntarget->rx_ring = srp_ring_alloc(target->dev, nr, iu_size);\r\nif (!target->rx_ring)\r\nreturn -ENOMEM;\r\nerr = srp_iu_pool_alloc(&target->iu_queue, nr, target->rx_ring);\r\nif (err)\r\ngoto free_ring;\r\nreturn 0;\r\nfree_ring:\r\nsrp_ring_free(target->dev, target->rx_ring, nr, iu_size);\r\nreturn -ENOMEM;\r\n}\r\nvoid srp_target_free(struct srp_target *target)\r\n{\r\nsrp_ring_free(target->dev, target->rx_ring, target->rx_ring_size,\r\ntarget->srp_iu_size);\r\nsrp_iu_pool_free(&target->iu_queue);\r\n}\r\nstruct iu_entry *srp_iu_get(struct srp_target *target)\r\n{\r\nstruct iu_entry *iue = NULL;\r\nif (kfifo_out_locked(&target->iu_queue.queue, (void *) &iue,\r\nsizeof(void *), &target->iu_queue.lock) != sizeof(void *)) {\r\nWARN_ONCE(1, "unexpected fifo state");\r\nreturn NULL;\r\n}\r\nif (!iue)\r\nreturn iue;\r\niue->target = target;\r\nINIT_LIST_HEAD(&iue->ilist);\r\niue->flags = 0;\r\nreturn iue;\r\n}\r\nvoid srp_iu_put(struct iu_entry *iue)\r\n{\r\nkfifo_in_locked(&iue->target->iu_queue.queue, (void *) &iue,\r\nsizeof(void *), &iue->target->iu_queue.lock);\r\n}\r\nstatic int srp_direct_data(struct scsi_cmnd *sc, struct srp_direct_buf *md,\r\nenum dma_data_direction dir, srp_rdma_t rdma_io,\r\nint dma_map, int ext_desc)\r\n{\r\nstruct iu_entry *iue = NULL;\r\nstruct scatterlist *sg = NULL;\r\nint err, nsg = 0, len;\r\nif (dma_map) {\r\niue = (struct iu_entry *) sc->SCp.ptr;\r\nsg = scsi_sglist(sc);\r\ndprintk("%p %u %u %d\n", iue, scsi_bufflen(sc),\r\nmd->len, scsi_sg_count(sc));\r\nnsg = dma_map_sg(iue->target->dev, sg, scsi_sg_count(sc),\r\nDMA_BIDIRECTIONAL);\r\nif (!nsg) {\r\nprintk("fail to map %p %d\n", iue, scsi_sg_count(sc));\r\nreturn 0;\r\n}\r\nlen = min(scsi_bufflen(sc), md->len);\r\n} else\r\nlen = md->len;\r\nerr = rdma_io(sc, sg, nsg, md, 1, dir, len);\r\nif (dma_map)\r\ndma_unmap_sg(iue->target->dev, sg, nsg, DMA_BIDIRECTIONAL);\r\nreturn err;\r\n}\r\nstatic int srp_indirect_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,\r\nstruct srp_indirect_buf *id,\r\nenum dma_data_direction dir, srp_rdma_t rdma_io,\r\nint dma_map, int ext_desc)\r\n{\r\nstruct iu_entry *iue = NULL;\r\nstruct srp_direct_buf *md = NULL;\r\nstruct scatterlist dummy, *sg = NULL;\r\ndma_addr_t token = 0;\r\nint err = 0;\r\nint nmd, nsg = 0, len;\r\nif (dma_map || ext_desc) {\r\niue = (struct iu_entry *) sc->SCp.ptr;\r\nsg = scsi_sglist(sc);\r\ndprintk("%p %u %u %d %d\n",\r\niue, scsi_bufflen(sc), id->len,\r\ncmd->data_in_desc_cnt, cmd->data_out_desc_cnt);\r\n}\r\nnmd = id->table_desc.len / sizeof(struct srp_direct_buf);\r\nif ((dir == DMA_FROM_DEVICE && nmd == cmd->data_in_desc_cnt) ||\r\n(dir == DMA_TO_DEVICE && nmd == cmd->data_out_desc_cnt)) {\r\nmd = &id->desc_list[0];\r\ngoto rdma;\r\n}\r\nif (ext_desc && dma_map) {\r\nmd = dma_alloc_coherent(iue->target->dev, id->table_desc.len,\r\n&token, GFP_KERNEL);\r\nif (!md) {\r\neprintk("Can't get dma memory %u\n", id->table_desc.len);\r\nreturn -ENOMEM;\r\n}\r\nsg_init_one(&dummy, md, id->table_desc.len);\r\nsg_dma_address(&dummy) = token;\r\nsg_dma_len(&dummy) = id->table_desc.len;\r\nerr = rdma_io(sc, &dummy, 1, &id->table_desc, 1, DMA_TO_DEVICE,\r\nid->table_desc.len);\r\nif (err) {\r\neprintk("Error copying indirect table %d\n", err);\r\ngoto free_mem;\r\n}\r\n} else {\r\neprintk("This command uses external indirect buffer\n");\r\nreturn -EINVAL;\r\n}\r\nrdma:\r\nif (dma_map) {\r\nnsg = dma_map_sg(iue->target->dev, sg, scsi_sg_count(sc),\r\nDMA_BIDIRECTIONAL);\r\nif (!nsg) {\r\neprintk("fail to map %p %d\n", iue, scsi_sg_count(sc));\r\nerr = -EIO;\r\ngoto free_mem;\r\n}\r\nlen = min(scsi_bufflen(sc), id->len);\r\n} else\r\nlen = id->len;\r\nerr = rdma_io(sc, sg, nsg, md, nmd, dir, len);\r\nif (dma_map)\r\ndma_unmap_sg(iue->target->dev, sg, nsg, DMA_BIDIRECTIONAL);\r\nfree_mem:\r\nif (token && dma_map)\r\ndma_free_coherent(iue->target->dev, id->table_desc.len, md, token);\r\nreturn err;\r\n}\r\nstatic int data_out_desc_size(struct srp_cmd *cmd)\r\n{\r\nint size = 0;\r\nu8 fmt = cmd->buf_fmt >> 4;\r\nswitch (fmt) {\r\ncase SRP_NO_DATA_DESC:\r\nbreak;\r\ncase SRP_DATA_DESC_DIRECT:\r\nsize = sizeof(struct srp_direct_buf);\r\nbreak;\r\ncase SRP_DATA_DESC_INDIRECT:\r\nsize = sizeof(struct srp_indirect_buf) +\r\nsizeof(struct srp_direct_buf) * cmd->data_out_desc_cnt;\r\nbreak;\r\ndefault:\r\neprintk("client error. Invalid data_out_format %x\n", fmt);\r\nbreak;\r\n}\r\nreturn size;\r\n}\r\nint srp_transfer_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,\r\nsrp_rdma_t rdma_io, int dma_map, int ext_desc)\r\n{\r\nstruct srp_direct_buf *md;\r\nstruct srp_indirect_buf *id;\r\nenum dma_data_direction dir;\r\nint offset, err = 0;\r\nu8 format;\r\noffset = cmd->add_cdb_len & ~3;\r\ndir = srp_cmd_direction(cmd);\r\nif (dir == DMA_FROM_DEVICE)\r\noffset += data_out_desc_size(cmd);\r\nif (dir == DMA_TO_DEVICE)\r\nformat = cmd->buf_fmt >> 4;\r\nelse\r\nformat = cmd->buf_fmt & ((1U << 4) - 1);\r\nswitch (format) {\r\ncase SRP_NO_DATA_DESC:\r\nbreak;\r\ncase SRP_DATA_DESC_DIRECT:\r\nmd = (struct srp_direct_buf *)\r\n(cmd->add_data + offset);\r\nerr = srp_direct_data(sc, md, dir, rdma_io, dma_map, ext_desc);\r\nbreak;\r\ncase SRP_DATA_DESC_INDIRECT:\r\nid = (struct srp_indirect_buf *)\r\n(cmd->add_data + offset);\r\nerr = srp_indirect_data(sc, cmd, id, dir, rdma_io, dma_map,\r\next_desc);\r\nbreak;\r\ndefault:\r\neprintk("Unknown format %d %x\n", dir, format);\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int vscsis_data_length(struct srp_cmd *cmd, enum dma_data_direction dir)\r\n{\r\nstruct srp_direct_buf *md;\r\nstruct srp_indirect_buf *id;\r\nint len = 0, offset = cmd->add_cdb_len & ~3;\r\nu8 fmt;\r\nif (dir == DMA_TO_DEVICE)\r\nfmt = cmd->buf_fmt >> 4;\r\nelse {\r\nfmt = cmd->buf_fmt & ((1U << 4) - 1);\r\noffset += data_out_desc_size(cmd);\r\n}\r\nswitch (fmt) {\r\ncase SRP_NO_DATA_DESC:\r\nbreak;\r\ncase SRP_DATA_DESC_DIRECT:\r\nmd = (struct srp_direct_buf *) (cmd->add_data + offset);\r\nlen = md->len;\r\nbreak;\r\ncase SRP_DATA_DESC_INDIRECT:\r\nid = (struct srp_indirect_buf *) (cmd->add_data + offset);\r\nlen = id->len;\r\nbreak;\r\ndefault:\r\neprintk("invalid data format %x\n", fmt);\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nint srp_cmd_queue(struct Scsi_Host *shost, struct srp_cmd *cmd, void *info,\r\nu64 itn_id, u64 addr)\r\n{\r\nenum dma_data_direction dir;\r\nstruct scsi_cmnd *sc;\r\nint tag, len, err;\r\nswitch (cmd->task_attr) {\r\ncase SRP_SIMPLE_TASK:\r\ntag = MSG_SIMPLE_TAG;\r\nbreak;\r\ncase SRP_ORDERED_TASK:\r\ntag = MSG_ORDERED_TAG;\r\nbreak;\r\ncase SRP_HEAD_TASK:\r\ntag = MSG_HEAD_TAG;\r\nbreak;\r\ndefault:\r\neprintk("Task attribute %d not supported\n", cmd->task_attr);\r\ntag = MSG_ORDERED_TAG;\r\n}\r\ndir = srp_cmd_direction(cmd);\r\nlen = vscsis_data_length(cmd, dir);\r\ndprintk("%p %x %lx %d %d %d %llx\n", info, cmd->cdb[0],\r\ncmd->lun, dir, len, tag, (unsigned long long) cmd->tag);\r\nsc = scsi_host_get_command(shost, dir, GFP_KERNEL);\r\nif (!sc)\r\nreturn -ENOMEM;\r\nsc->SCp.ptr = info;\r\nmemcpy(sc->cmnd, cmd->cdb, MAX_COMMAND_SIZE);\r\nsc->sdb.length = len;\r\nsc->sdb.table.sgl = (void *) (unsigned long) addr;\r\nsc->tag = tag;\r\nerr = scsi_tgt_queue_command(sc, itn_id, (struct scsi_lun *)&cmd->lun,\r\ncmd->tag);\r\nif (err)\r\nscsi_host_put_command(shost, sc);\r\nreturn err;\r\n}
