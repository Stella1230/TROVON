static int\r\nahc_linux_pci_dev_suspend(struct pci_dev *pdev, pm_message_t mesg)\r\n{\r\nstruct ahc_softc *ahc = pci_get_drvdata(pdev);\r\nint rc;\r\nif ((rc = ahc_suspend(ahc)))\r\nreturn rc;\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\nif (mesg.event & PM_EVENT_SLEEP)\r\npci_set_power_state(pdev, PCI_D3hot);\r\nreturn rc;\r\n}\r\nstatic int\r\nahc_linux_pci_dev_resume(struct pci_dev *pdev)\r\n{\r\nstruct ahc_softc *ahc = pci_get_drvdata(pdev);\r\nint rc;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nif ((rc = pci_enable_device(pdev))) {\r\ndev_printk(KERN_ERR, &pdev->dev,\r\n"failed to enable device after resume (%d)\n", rc);\r\nreturn rc;\r\n}\r\npci_set_master(pdev);\r\nahc_pci_resume(ahc);\r\nreturn (ahc_resume(ahc));\r\n}\r\nstatic void\r\nahc_linux_pci_dev_remove(struct pci_dev *pdev)\r\n{\r\nstruct ahc_softc *ahc = pci_get_drvdata(pdev);\r\nu_long s;\r\nif (ahc->platform_data && ahc->platform_data->host)\r\nscsi_remove_host(ahc->platform_data->host);\r\nahc_lock(ahc, &s);\r\nahc_intr_enable(ahc, FALSE);\r\nahc_unlock(ahc, &s);\r\nahc_free(ahc);\r\n}\r\nstatic void\r\nahc_linux_pci_inherit_flags(struct ahc_softc *ahc)\r\n{\r\nstruct pci_dev *pdev = ahc->dev_softc, *master_pdev;\r\nunsigned int master_devfn = PCI_DEVFN(PCI_SLOT(pdev->devfn), 0);\r\nmaster_pdev = pci_get_slot(pdev->bus, master_devfn);\r\nif (master_pdev) {\r\nstruct ahc_softc *master = pci_get_drvdata(master_pdev);\r\nif (master) {\r\nahc->flags &= ~AHC_BIOS_ENABLED;\r\nahc->flags |= master->flags & AHC_BIOS_ENABLED;\r\nahc->flags &= ~AHC_PRIMARY_CHANNEL;\r\nahc->flags |= master->flags & AHC_PRIMARY_CHANNEL;\r\n} else\r\nprintk(KERN_ERR "aic7xxx: no multichannel peer found!\n");\r\npci_dev_put(master_pdev);\r\n}\r\n}\r\nstatic int\r\nahc_linux_pci_dev_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nchar buf[80];\r\nconst uint64_t mask_39bit = 0x7FFFFFFFFFULL;\r\nstruct ahc_softc *ahc;\r\nahc_dev_softc_t pci;\r\nconst struct ahc_pci_identity *entry;\r\nchar *name;\r\nint error;\r\nstruct device *dev = &pdev->dev;\r\npci = pdev;\r\nentry = ahc_find_pci_device(pci);\r\nif (entry == NULL)\r\nreturn (-ENODEV);\r\nsprintf(buf, "ahc_pci:%d:%d:%d",\r\nahc_get_pci_bus(pci),\r\nahc_get_pci_slot(pci),\r\nahc_get_pci_function(pci));\r\nname = kmalloc(strlen(buf) + 1, GFP_ATOMIC);\r\nif (name == NULL)\r\nreturn (-ENOMEM);\r\nstrcpy(name, buf);\r\nahc = ahc_alloc(NULL, name);\r\nif (ahc == NULL)\r\nreturn (-ENOMEM);\r\nif (pci_enable_device(pdev)) {\r\nahc_free(ahc);\r\nreturn (-ENODEV);\r\n}\r\npci_set_master(pdev);\r\nif (sizeof(dma_addr_t) > 4\r\n&& ahc->features & AHC_LARGE_SCBS\r\n&& dma_set_mask(dev, mask_39bit) == 0\r\n&& dma_get_required_mask(dev) > DMA_BIT_MASK(32)) {\r\nahc->flags |= AHC_39BIT_ADDRESSING;\r\n} else {\r\nif (dma_set_mask(dev, DMA_BIT_MASK(32))) {\r\nahc_free(ahc);\r\nprintk(KERN_WARNING "aic7xxx: No suitable DMA available.\n");\r\nreturn (-ENODEV);\r\n}\r\n}\r\nahc->dev_softc = pci;\r\nerror = ahc_pci_config(ahc, entry);\r\nif (error != 0) {\r\nahc_free(ahc);\r\nreturn (-error);\r\n}\r\nif ((ahc->features & AHC_MULTI_FUNC) && PCI_FUNC(pdev->devfn) != 0)\r\nahc_linux_pci_inherit_flags(ahc);\r\npci_set_drvdata(pdev, ahc);\r\nahc_linux_register_host(ahc, &aic7xxx_driver_template);\r\nreturn (0);\r\n}\r\nuint32_t\r\nahc_pci_read_config(ahc_dev_softc_t pci, int reg, int width)\r\n{\r\nswitch (width) {\r\ncase 1:\r\n{\r\nuint8_t retval;\r\npci_read_config_byte(pci, reg, &retval);\r\nreturn (retval);\r\n}\r\ncase 2:\r\n{\r\nuint16_t retval;\r\npci_read_config_word(pci, reg, &retval);\r\nreturn (retval);\r\n}\r\ncase 4:\r\n{\r\nuint32_t retval;\r\npci_read_config_dword(pci, reg, &retval);\r\nreturn (retval);\r\n}\r\ndefault:\r\npanic("ahc_pci_read_config: Read size too big");\r\nreturn (0);\r\n}\r\n}\r\nvoid\r\nahc_pci_write_config(ahc_dev_softc_t pci, int reg, uint32_t value, int width)\r\n{\r\nswitch (width) {\r\ncase 1:\r\npci_write_config_byte(pci, reg, value);\r\nbreak;\r\ncase 2:\r\npci_write_config_word(pci, reg, value);\r\nbreak;\r\ncase 4:\r\npci_write_config_dword(pci, reg, value);\r\nbreak;\r\ndefault:\r\npanic("ahc_pci_write_config: Write size too big");\r\n}\r\n}\r\nint\r\nahc_linux_pci_init(void)\r\n{\r\nreturn pci_register_driver(&aic7xxx_pci_driver);\r\n}\r\nvoid\r\nahc_linux_pci_exit(void)\r\n{\r\npci_unregister_driver(&aic7xxx_pci_driver);\r\n}\r\nstatic int\r\nahc_linux_pci_reserve_io_region(struct ahc_softc *ahc, resource_size_t *base)\r\n{\r\nif (aic7xxx_allow_memio == 0)\r\nreturn (ENOMEM);\r\n*base = pci_resource_start(ahc->dev_softc, 0);\r\nif (*base == 0)\r\nreturn (ENOMEM);\r\nif (!request_region(*base, 256, "aic7xxx"))\r\nreturn (ENOMEM);\r\nreturn (0);\r\n}\r\nstatic int\r\nahc_linux_pci_reserve_mem_region(struct ahc_softc *ahc,\r\nresource_size_t *bus_addr,\r\nuint8_t __iomem **maddr)\r\n{\r\nresource_size_t start;\r\nint error;\r\nerror = 0;\r\nstart = pci_resource_start(ahc->dev_softc, 1);\r\nif (start != 0) {\r\n*bus_addr = start;\r\nif (!request_mem_region(start, 0x1000, "aic7xxx"))\r\nerror = ENOMEM;\r\nif (error == 0) {\r\n*maddr = ioremap_nocache(start, 256);\r\nif (*maddr == NULL) {\r\nerror = ENOMEM;\r\nrelease_mem_region(start, 0x1000);\r\n}\r\n}\r\n} else\r\nerror = ENOMEM;\r\nreturn (error);\r\n}\r\nint\r\nahc_pci_map_registers(struct ahc_softc *ahc)\r\n{\r\nuint32_t command;\r\nresource_size_t base;\r\nuint8_t __iomem *maddr;\r\nint error;\r\ncommand = ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, 4);\r\ncommand &= ~(PCIM_CMD_PORTEN|PCIM_CMD_MEMEN);\r\nbase = 0;\r\nmaddr = NULL;\r\nerror = ahc_linux_pci_reserve_mem_region(ahc, &base, &maddr);\r\nif (error == 0) {\r\nahc->platform_data->mem_busaddr = base;\r\nahc->tag = BUS_SPACE_MEMIO;\r\nahc->bsh.maddr = maddr;\r\nahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND,\r\ncommand | PCIM_CMD_MEMEN, 4);\r\nif (ahc_pci_test_register_access(ahc) != 0) {\r\nprintk("aic7xxx: PCI Device %d:%d:%d "\r\n"failed memory mapped test. Using PIO.\n",\r\nahc_get_pci_bus(ahc->dev_softc),\r\nahc_get_pci_slot(ahc->dev_softc),\r\nahc_get_pci_function(ahc->dev_softc));\r\niounmap(maddr);\r\nrelease_mem_region(ahc->platform_data->mem_busaddr,\r\n0x1000);\r\nahc->bsh.maddr = NULL;\r\nmaddr = NULL;\r\n} else\r\ncommand |= PCIM_CMD_MEMEN;\r\n} else {\r\nprintk("aic7xxx: PCI%d:%d:%d MEM region 0x%llx "\r\n"unavailable. Cannot memory map device.\n",\r\nahc_get_pci_bus(ahc->dev_softc),\r\nahc_get_pci_slot(ahc->dev_softc),\r\nahc_get_pci_function(ahc->dev_softc),\r\n(unsigned long long)base);\r\n}\r\nif (maddr == NULL) {\r\nerror = ahc_linux_pci_reserve_io_region(ahc, &base);\r\nif (error == 0) {\r\nahc->tag = BUS_SPACE_PIO;\r\nahc->bsh.ioport = (u_long)base;\r\ncommand |= PCIM_CMD_PORTEN;\r\n} else {\r\nprintk("aic7xxx: PCI%d:%d:%d IO region 0x%llx[0..255] "\r\n"unavailable. Cannot map device.\n",\r\nahc_get_pci_bus(ahc->dev_softc),\r\nahc_get_pci_slot(ahc->dev_softc),\r\nahc_get_pci_function(ahc->dev_softc),\r\n(unsigned long long)base);\r\n}\r\n}\r\nahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, command, 4);\r\nreturn (error);\r\n}\r\nint\r\nahc_pci_map_int(struct ahc_softc *ahc)\r\n{\r\nint error;\r\nerror = request_irq(ahc->dev_softc->irq, ahc_linux_isr,\r\nIRQF_SHARED, "aic7xxx", ahc);\r\nif (error == 0)\r\nahc->platform_data->irq = ahc->dev_softc->irq;\r\nreturn (-error);\r\n}
