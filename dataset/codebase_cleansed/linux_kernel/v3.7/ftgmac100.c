static void ftgmac100_set_rx_ring_base(struct ftgmac100 *priv, dma_addr_t addr)\r\n{\r\niowrite32(addr, priv->base + FTGMAC100_OFFSET_RXR_BADR);\r\n}\r\nstatic void ftgmac100_set_rx_buffer_size(struct ftgmac100 *priv,\r\nunsigned int size)\r\n{\r\nsize = FTGMAC100_RBSR_SIZE(size);\r\niowrite32(size, priv->base + FTGMAC100_OFFSET_RBSR);\r\n}\r\nstatic void ftgmac100_set_normal_prio_tx_ring_base(struct ftgmac100 *priv,\r\ndma_addr_t addr)\r\n{\r\niowrite32(addr, priv->base + FTGMAC100_OFFSET_NPTXR_BADR);\r\n}\r\nstatic void ftgmac100_txdma_normal_prio_start_polling(struct ftgmac100 *priv)\r\n{\r\niowrite32(1, priv->base + FTGMAC100_OFFSET_NPTXPD);\r\n}\r\nstatic int ftgmac100_reset_hw(struct ftgmac100 *priv)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nint i;\r\niowrite32(FTGMAC100_MACCR_SW_RST, priv->base + FTGMAC100_OFFSET_MACCR);\r\nfor (i = 0; i < 5; i++) {\r\nunsigned int maccr;\r\nmaccr = ioread32(priv->base + FTGMAC100_OFFSET_MACCR);\r\nif (!(maccr & FTGMAC100_MACCR_SW_RST))\r\nreturn 0;\r\nudelay(1000);\r\n}\r\nnetdev_err(netdev, "software reset failed\n");\r\nreturn -EIO;\r\n}\r\nstatic void ftgmac100_set_mac(struct ftgmac100 *priv, const unsigned char *mac)\r\n{\r\nunsigned int maddr = mac[0] << 8 | mac[1];\r\nunsigned int laddr = mac[2] << 24 | mac[3] << 16 | mac[4] << 8 | mac[5];\r\niowrite32(maddr, priv->base + FTGMAC100_OFFSET_MAC_MADR);\r\niowrite32(laddr, priv->base + FTGMAC100_OFFSET_MAC_LADR);\r\n}\r\nstatic void ftgmac100_init_hw(struct ftgmac100 *priv)\r\n{\r\nftgmac100_set_rx_ring_base(priv,\r\npriv->descs_dma_addr +\r\noffsetof(struct ftgmac100_descs, rxdes));\r\nftgmac100_set_normal_prio_tx_ring_base(priv,\r\npriv->descs_dma_addr +\r\noffsetof(struct ftgmac100_descs, txdes));\r\nftgmac100_set_rx_buffer_size(priv, RX_BUF_SIZE);\r\niowrite32(FTGMAC100_APTC_RXPOLL_CNT(1), priv->base + FTGMAC100_OFFSET_APTC);\r\nftgmac100_set_mac(priv, priv->netdev->dev_addr);\r\n}\r\nstatic void ftgmac100_start_hw(struct ftgmac100 *priv, int speed)\r\n{\r\nint maccr = MACCR_ENABLE_ALL;\r\nswitch (speed) {\r\ndefault:\r\ncase 10:\r\nbreak;\r\ncase 100:\r\nmaccr |= FTGMAC100_MACCR_FAST_MODE;\r\nbreak;\r\ncase 1000:\r\nmaccr |= FTGMAC100_MACCR_GIGA_MODE;\r\nbreak;\r\n}\r\niowrite32(maccr, priv->base + FTGMAC100_OFFSET_MACCR);\r\n}\r\nstatic void ftgmac100_stop_hw(struct ftgmac100 *priv)\r\n{\r\niowrite32(0, priv->base + FTGMAC100_OFFSET_MACCR);\r\n}\r\nstatic bool ftgmac100_rxdes_first_segment(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_FRS);\r\n}\r\nstatic bool ftgmac100_rxdes_last_segment(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_LRS);\r\n}\r\nstatic bool ftgmac100_rxdes_packet_ready(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_RXPKT_RDY);\r\n}\r\nstatic void ftgmac100_rxdes_set_dma_own(struct ftgmac100_rxdes *rxdes)\r\n{\r\nrxdes->rxdes0 &= cpu_to_le32(FTGMAC100_RXDES0_EDORR);\r\n}\r\nstatic bool ftgmac100_rxdes_rx_error(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_RX_ERR);\r\n}\r\nstatic bool ftgmac100_rxdes_crc_error(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_CRC_ERR);\r\n}\r\nstatic bool ftgmac100_rxdes_frame_too_long(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_FTL);\r\n}\r\nstatic bool ftgmac100_rxdes_runt(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_RUNT);\r\n}\r\nstatic bool ftgmac100_rxdes_odd_nibble(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_RX_ODD_NB);\r\n}\r\nstatic unsigned int ftgmac100_rxdes_data_length(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn le32_to_cpu(rxdes->rxdes0) & FTGMAC100_RXDES0_VDBC;\r\n}\r\nstatic bool ftgmac100_rxdes_multicast(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes0 & cpu_to_le32(FTGMAC100_RXDES0_MULTICAST);\r\n}\r\nstatic void ftgmac100_rxdes_set_end_of_ring(struct ftgmac100_rxdes *rxdes)\r\n{\r\nrxdes->rxdes0 |= cpu_to_le32(FTGMAC100_RXDES0_EDORR);\r\n}\r\nstatic void ftgmac100_rxdes_set_dma_addr(struct ftgmac100_rxdes *rxdes,\r\ndma_addr_t addr)\r\n{\r\nrxdes->rxdes3 = cpu_to_le32(addr);\r\n}\r\nstatic dma_addr_t ftgmac100_rxdes_get_dma_addr(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn le32_to_cpu(rxdes->rxdes3);\r\n}\r\nstatic bool ftgmac100_rxdes_is_tcp(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn (rxdes->rxdes1 & cpu_to_le32(FTGMAC100_RXDES1_PROT_MASK)) ==\r\ncpu_to_le32(FTGMAC100_RXDES1_PROT_TCPIP);\r\n}\r\nstatic bool ftgmac100_rxdes_is_udp(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn (rxdes->rxdes1 & cpu_to_le32(FTGMAC100_RXDES1_PROT_MASK)) ==\r\ncpu_to_le32(FTGMAC100_RXDES1_PROT_UDPIP);\r\n}\r\nstatic bool ftgmac100_rxdes_tcpcs_err(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes1 & cpu_to_le32(FTGMAC100_RXDES1_TCP_CHKSUM_ERR);\r\n}\r\nstatic bool ftgmac100_rxdes_udpcs_err(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes1 & cpu_to_le32(FTGMAC100_RXDES1_UDP_CHKSUM_ERR);\r\n}\r\nstatic bool ftgmac100_rxdes_ipcs_err(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn rxdes->rxdes1 & cpu_to_le32(FTGMAC100_RXDES1_IP_CHKSUM_ERR);\r\n}\r\nstatic void ftgmac100_rxdes_set_page(struct ftgmac100_rxdes *rxdes, struct page *page)\r\n{\r\nrxdes->rxdes2 = (unsigned int)page;\r\n}\r\nstatic struct page *ftgmac100_rxdes_get_page(struct ftgmac100_rxdes *rxdes)\r\n{\r\nreturn (struct page *)rxdes->rxdes2;\r\n}\r\nstatic int ftgmac100_next_rx_pointer(int pointer)\r\n{\r\nreturn (pointer + 1) & (RX_QUEUE_ENTRIES - 1);\r\n}\r\nstatic void ftgmac100_rx_pointer_advance(struct ftgmac100 *priv)\r\n{\r\npriv->rx_pointer = ftgmac100_next_rx_pointer(priv->rx_pointer);\r\n}\r\nstatic struct ftgmac100_rxdes *ftgmac100_current_rxdes(struct ftgmac100 *priv)\r\n{\r\nreturn &priv->descs->rxdes[priv->rx_pointer];\r\n}\r\nstatic struct ftgmac100_rxdes *\r\nftgmac100_rx_locate_first_segment(struct ftgmac100 *priv)\r\n{\r\nstruct ftgmac100_rxdes *rxdes = ftgmac100_current_rxdes(priv);\r\nwhile (ftgmac100_rxdes_packet_ready(rxdes)) {\r\nif (ftgmac100_rxdes_first_segment(rxdes))\r\nreturn rxdes;\r\nftgmac100_rxdes_set_dma_own(rxdes);\r\nftgmac100_rx_pointer_advance(priv);\r\nrxdes = ftgmac100_current_rxdes(priv);\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool ftgmac100_rx_packet_error(struct ftgmac100 *priv,\r\nstruct ftgmac100_rxdes *rxdes)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nbool error = false;\r\nif (unlikely(ftgmac100_rxdes_rx_error(rxdes))) {\r\nif (net_ratelimit())\r\nnetdev_info(netdev, "rx err\n");\r\nnetdev->stats.rx_errors++;\r\nerror = true;\r\n}\r\nif (unlikely(ftgmac100_rxdes_crc_error(rxdes))) {\r\nif (net_ratelimit())\r\nnetdev_info(netdev, "rx crc err\n");\r\nnetdev->stats.rx_crc_errors++;\r\nerror = true;\r\n} else if (unlikely(ftgmac100_rxdes_ipcs_err(rxdes))) {\r\nif (net_ratelimit())\r\nnetdev_info(netdev, "rx IP checksum err\n");\r\nerror = true;\r\n}\r\nif (unlikely(ftgmac100_rxdes_frame_too_long(rxdes))) {\r\nif (net_ratelimit())\r\nnetdev_info(netdev, "rx frame too long\n");\r\nnetdev->stats.rx_length_errors++;\r\nerror = true;\r\n} else if (unlikely(ftgmac100_rxdes_runt(rxdes))) {\r\nif (net_ratelimit())\r\nnetdev_info(netdev, "rx runt\n");\r\nnetdev->stats.rx_length_errors++;\r\nerror = true;\r\n} else if (unlikely(ftgmac100_rxdes_odd_nibble(rxdes))) {\r\nif (net_ratelimit())\r\nnetdev_info(netdev, "rx odd nibble\n");\r\nnetdev->stats.rx_length_errors++;\r\nerror = true;\r\n}\r\nreturn error;\r\n}\r\nstatic void ftgmac100_rx_drop_packet(struct ftgmac100 *priv)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nstruct ftgmac100_rxdes *rxdes = ftgmac100_current_rxdes(priv);\r\nbool done = false;\r\nif (net_ratelimit())\r\nnetdev_dbg(netdev, "drop packet %p\n", rxdes);\r\ndo {\r\nif (ftgmac100_rxdes_last_segment(rxdes))\r\ndone = true;\r\nftgmac100_rxdes_set_dma_own(rxdes);\r\nftgmac100_rx_pointer_advance(priv);\r\nrxdes = ftgmac100_current_rxdes(priv);\r\n} while (!done && ftgmac100_rxdes_packet_ready(rxdes));\r\nnetdev->stats.rx_dropped++;\r\n}\r\nstatic bool ftgmac100_rx_packet(struct ftgmac100 *priv, int *processed)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nstruct ftgmac100_rxdes *rxdes;\r\nstruct sk_buff *skb;\r\nbool done = false;\r\nrxdes = ftgmac100_rx_locate_first_segment(priv);\r\nif (!rxdes)\r\nreturn false;\r\nif (unlikely(ftgmac100_rx_packet_error(priv, rxdes))) {\r\nftgmac100_rx_drop_packet(priv);\r\nreturn true;\r\n}\r\nskb = netdev_alloc_skb_ip_align(netdev, 128);\r\nif (unlikely(!skb)) {\r\nif (net_ratelimit())\r\nnetdev_err(netdev, "rx skb alloc failed\n");\r\nftgmac100_rx_drop_packet(priv);\r\nreturn true;\r\n}\r\nif (unlikely(ftgmac100_rxdes_multicast(rxdes)))\r\nnetdev->stats.multicast++;\r\nif ((ftgmac100_rxdes_is_tcp(rxdes) && !ftgmac100_rxdes_tcpcs_err(rxdes)) ||\r\n(ftgmac100_rxdes_is_udp(rxdes) && !ftgmac100_rxdes_udpcs_err(rxdes)))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\ndo {\r\ndma_addr_t map = ftgmac100_rxdes_get_dma_addr(rxdes);\r\nstruct page *page = ftgmac100_rxdes_get_page(rxdes);\r\nunsigned int size;\r\ndma_unmap_page(priv->dev, map, RX_BUF_SIZE, DMA_FROM_DEVICE);\r\nsize = ftgmac100_rxdes_data_length(rxdes);\r\nskb_fill_page_desc(skb, skb_shinfo(skb)->nr_frags, page, 0, size);\r\nskb->len += size;\r\nskb->data_len += size;\r\nskb->truesize += PAGE_SIZE;\r\nif (ftgmac100_rxdes_last_segment(rxdes))\r\ndone = true;\r\nftgmac100_alloc_rx_page(priv, rxdes, GFP_ATOMIC);\r\nftgmac100_rx_pointer_advance(priv);\r\nrxdes = ftgmac100_current_rxdes(priv);\r\n} while (!done);\r\nif (skb->len <= 128) {\r\nskb->truesize -= PAGE_SIZE;\r\n__pskb_pull_tail(skb, skb->len);\r\n} else {\r\n__pskb_pull_tail(skb, ETH_HLEN);\r\n}\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nnetdev->stats.rx_packets++;\r\nnetdev->stats.rx_bytes += skb->len;\r\nnapi_gro_receive(&priv->napi, skb);\r\n(*processed)++;\r\nreturn true;\r\n}\r\nstatic void ftgmac100_txdes_reset(struct ftgmac100_txdes *txdes)\r\n{\r\ntxdes->txdes0 &= cpu_to_le32(FTGMAC100_TXDES0_EDOTR);\r\ntxdes->txdes1 = 0;\r\ntxdes->txdes2 = 0;\r\ntxdes->txdes3 = 0;\r\n}\r\nstatic bool ftgmac100_txdes_owned_by_dma(struct ftgmac100_txdes *txdes)\r\n{\r\nreturn txdes->txdes0 & cpu_to_le32(FTGMAC100_TXDES0_TXDMA_OWN);\r\n}\r\nstatic void ftgmac100_txdes_set_dma_own(struct ftgmac100_txdes *txdes)\r\n{\r\nwmb();\r\ntxdes->txdes0 |= cpu_to_le32(FTGMAC100_TXDES0_TXDMA_OWN);\r\n}\r\nstatic void ftgmac100_txdes_set_end_of_ring(struct ftgmac100_txdes *txdes)\r\n{\r\ntxdes->txdes0 |= cpu_to_le32(FTGMAC100_TXDES0_EDOTR);\r\n}\r\nstatic void ftgmac100_txdes_set_first_segment(struct ftgmac100_txdes *txdes)\r\n{\r\ntxdes->txdes0 |= cpu_to_le32(FTGMAC100_TXDES0_FTS);\r\n}\r\nstatic void ftgmac100_txdes_set_last_segment(struct ftgmac100_txdes *txdes)\r\n{\r\ntxdes->txdes0 |= cpu_to_le32(FTGMAC100_TXDES0_LTS);\r\n}\r\nstatic void ftgmac100_txdes_set_buffer_size(struct ftgmac100_txdes *txdes,\r\nunsigned int len)\r\n{\r\ntxdes->txdes0 |= cpu_to_le32(FTGMAC100_TXDES0_TXBUF_SIZE(len));\r\n}\r\nstatic void ftgmac100_txdes_set_txint(struct ftgmac100_txdes *txdes)\r\n{\r\ntxdes->txdes1 |= cpu_to_le32(FTGMAC100_TXDES1_TXIC);\r\n}\r\nstatic void ftgmac100_txdes_set_tcpcs(struct ftgmac100_txdes *txdes)\r\n{\r\ntxdes->txdes1 |= cpu_to_le32(FTGMAC100_TXDES1_TCP_CHKSUM);\r\n}\r\nstatic void ftgmac100_txdes_set_udpcs(struct ftgmac100_txdes *txdes)\r\n{\r\ntxdes->txdes1 |= cpu_to_le32(FTGMAC100_TXDES1_UDP_CHKSUM);\r\n}\r\nstatic void ftgmac100_txdes_set_ipcs(struct ftgmac100_txdes *txdes)\r\n{\r\ntxdes->txdes1 |= cpu_to_le32(FTGMAC100_TXDES1_IP_CHKSUM);\r\n}\r\nstatic void ftgmac100_txdes_set_dma_addr(struct ftgmac100_txdes *txdes,\r\ndma_addr_t addr)\r\n{\r\ntxdes->txdes3 = cpu_to_le32(addr);\r\n}\r\nstatic dma_addr_t ftgmac100_txdes_get_dma_addr(struct ftgmac100_txdes *txdes)\r\n{\r\nreturn le32_to_cpu(txdes->txdes3);\r\n}\r\nstatic void ftgmac100_txdes_set_skb(struct ftgmac100_txdes *txdes,\r\nstruct sk_buff *skb)\r\n{\r\ntxdes->txdes2 = (unsigned int)skb;\r\n}\r\nstatic struct sk_buff *ftgmac100_txdes_get_skb(struct ftgmac100_txdes *txdes)\r\n{\r\nreturn (struct sk_buff *)txdes->txdes2;\r\n}\r\nstatic int ftgmac100_next_tx_pointer(int pointer)\r\n{\r\nreturn (pointer + 1) & (TX_QUEUE_ENTRIES - 1);\r\n}\r\nstatic void ftgmac100_tx_pointer_advance(struct ftgmac100 *priv)\r\n{\r\npriv->tx_pointer = ftgmac100_next_tx_pointer(priv->tx_pointer);\r\n}\r\nstatic void ftgmac100_tx_clean_pointer_advance(struct ftgmac100 *priv)\r\n{\r\npriv->tx_clean_pointer = ftgmac100_next_tx_pointer(priv->tx_clean_pointer);\r\n}\r\nstatic struct ftgmac100_txdes *ftgmac100_current_txdes(struct ftgmac100 *priv)\r\n{\r\nreturn &priv->descs->txdes[priv->tx_pointer];\r\n}\r\nstatic struct ftgmac100_txdes *\r\nftgmac100_current_clean_txdes(struct ftgmac100 *priv)\r\n{\r\nreturn &priv->descs->txdes[priv->tx_clean_pointer];\r\n}\r\nstatic bool ftgmac100_tx_complete_packet(struct ftgmac100 *priv)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nstruct ftgmac100_txdes *txdes;\r\nstruct sk_buff *skb;\r\ndma_addr_t map;\r\nif (priv->tx_pending == 0)\r\nreturn false;\r\ntxdes = ftgmac100_current_clean_txdes(priv);\r\nif (ftgmac100_txdes_owned_by_dma(txdes))\r\nreturn false;\r\nskb = ftgmac100_txdes_get_skb(txdes);\r\nmap = ftgmac100_txdes_get_dma_addr(txdes);\r\nnetdev->stats.tx_packets++;\r\nnetdev->stats.tx_bytes += skb->len;\r\ndma_unmap_single(priv->dev, map, skb_headlen(skb), DMA_TO_DEVICE);\r\ndev_kfree_skb(skb);\r\nftgmac100_txdes_reset(txdes);\r\nftgmac100_tx_clean_pointer_advance(priv);\r\nspin_lock(&priv->tx_lock);\r\npriv->tx_pending--;\r\nspin_unlock(&priv->tx_lock);\r\nnetif_wake_queue(netdev);\r\nreturn true;\r\n}\r\nstatic void ftgmac100_tx_complete(struct ftgmac100 *priv)\r\n{\r\nwhile (ftgmac100_tx_complete_packet(priv))\r\n;\r\n}\r\nstatic int ftgmac100_xmit(struct ftgmac100 *priv, struct sk_buff *skb,\r\ndma_addr_t map)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nstruct ftgmac100_txdes *txdes;\r\nunsigned int len = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;\r\ntxdes = ftgmac100_current_txdes(priv);\r\nftgmac100_tx_pointer_advance(priv);\r\nftgmac100_txdes_set_skb(txdes, skb);\r\nftgmac100_txdes_set_dma_addr(txdes, map);\r\nftgmac100_txdes_set_buffer_size(txdes, len);\r\nftgmac100_txdes_set_first_segment(txdes);\r\nftgmac100_txdes_set_last_segment(txdes);\r\nftgmac100_txdes_set_txint(txdes);\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\n__be16 protocol = skb->protocol;\r\nif (protocol == cpu_to_be16(ETH_P_IP)) {\r\nu8 ip_proto = ip_hdr(skb)->protocol;\r\nftgmac100_txdes_set_ipcs(txdes);\r\nif (ip_proto == IPPROTO_TCP)\r\nftgmac100_txdes_set_tcpcs(txdes);\r\nelse if (ip_proto == IPPROTO_UDP)\r\nftgmac100_txdes_set_udpcs(txdes);\r\n}\r\n}\r\nspin_lock(&priv->tx_lock);\r\npriv->tx_pending++;\r\nif (priv->tx_pending == TX_QUEUE_ENTRIES)\r\nnetif_stop_queue(netdev);\r\nftgmac100_txdes_set_dma_own(txdes);\r\nspin_unlock(&priv->tx_lock);\r\nftgmac100_txdma_normal_prio_start_polling(priv);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ftgmac100_alloc_rx_page(struct ftgmac100 *priv,\r\nstruct ftgmac100_rxdes *rxdes, gfp_t gfp)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nstruct page *page;\r\ndma_addr_t map;\r\npage = alloc_page(gfp);\r\nif (!page) {\r\nif (net_ratelimit())\r\nnetdev_err(netdev, "failed to allocate rx page\n");\r\nreturn -ENOMEM;\r\n}\r\nmap = dma_map_page(priv->dev, page, 0, RX_BUF_SIZE, DMA_FROM_DEVICE);\r\nif (unlikely(dma_mapping_error(priv->dev, map))) {\r\nif (net_ratelimit())\r\nnetdev_err(netdev, "failed to map rx page\n");\r\n__free_page(page);\r\nreturn -ENOMEM;\r\n}\r\nftgmac100_rxdes_set_page(rxdes, page);\r\nftgmac100_rxdes_set_dma_addr(rxdes, map);\r\nftgmac100_rxdes_set_dma_own(rxdes);\r\nreturn 0;\r\n}\r\nstatic void ftgmac100_free_buffers(struct ftgmac100 *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < RX_QUEUE_ENTRIES; i++) {\r\nstruct ftgmac100_rxdes *rxdes = &priv->descs->rxdes[i];\r\nstruct page *page = ftgmac100_rxdes_get_page(rxdes);\r\ndma_addr_t map = ftgmac100_rxdes_get_dma_addr(rxdes);\r\nif (!page)\r\ncontinue;\r\ndma_unmap_page(priv->dev, map, RX_BUF_SIZE, DMA_FROM_DEVICE);\r\n__free_page(page);\r\n}\r\nfor (i = 0; i < TX_QUEUE_ENTRIES; i++) {\r\nstruct ftgmac100_txdes *txdes = &priv->descs->txdes[i];\r\nstruct sk_buff *skb = ftgmac100_txdes_get_skb(txdes);\r\ndma_addr_t map = ftgmac100_txdes_get_dma_addr(txdes);\r\nif (!skb)\r\ncontinue;\r\ndma_unmap_single(priv->dev, map, skb_headlen(skb), DMA_TO_DEVICE);\r\ndev_kfree_skb(skb);\r\n}\r\ndma_free_coherent(priv->dev, sizeof(struct ftgmac100_descs),\r\npriv->descs, priv->descs_dma_addr);\r\n}\r\nstatic int ftgmac100_alloc_buffers(struct ftgmac100 *priv)\r\n{\r\nint i;\r\npriv->descs = dma_alloc_coherent(priv->dev,\r\nsizeof(struct ftgmac100_descs),\r\n&priv->descs_dma_addr, GFP_KERNEL);\r\nif (!priv->descs)\r\nreturn -ENOMEM;\r\nmemset(priv->descs, 0, sizeof(struct ftgmac100_descs));\r\nftgmac100_rxdes_set_end_of_ring(&priv->descs->rxdes[RX_QUEUE_ENTRIES - 1]);\r\nfor (i = 0; i < RX_QUEUE_ENTRIES; i++) {\r\nstruct ftgmac100_rxdes *rxdes = &priv->descs->rxdes[i];\r\nif (ftgmac100_alloc_rx_page(priv, rxdes, GFP_KERNEL))\r\ngoto err;\r\n}\r\nftgmac100_txdes_set_end_of_ring(&priv->descs->txdes[TX_QUEUE_ENTRIES - 1]);\r\nreturn 0;\r\nerr:\r\nftgmac100_free_buffers(priv);\r\nreturn -ENOMEM;\r\n}\r\nstatic void ftgmac100_adjust_link(struct net_device *netdev)\r\n{\r\nstruct ftgmac100 *priv = netdev_priv(netdev);\r\nstruct phy_device *phydev = priv->phydev;\r\nint ier;\r\nif (phydev->speed == priv->old_speed)\r\nreturn;\r\npriv->old_speed = phydev->speed;\r\nier = ioread32(priv->base + FTGMAC100_OFFSET_IER);\r\niowrite32(0, priv->base + FTGMAC100_OFFSET_IER);\r\nnetif_stop_queue(netdev);\r\nftgmac100_stop_hw(priv);\r\nnetif_start_queue(netdev);\r\nftgmac100_init_hw(priv);\r\nftgmac100_start_hw(priv, phydev->speed);\r\niowrite32(ier, priv->base + FTGMAC100_OFFSET_IER);\r\n}\r\nstatic int ftgmac100_mii_probe(struct ftgmac100 *priv)\r\n{\r\nstruct net_device *netdev = priv->netdev;\r\nstruct phy_device *phydev = NULL;\r\nint i;\r\nfor (i = 0; i < PHY_MAX_ADDR; i++) {\r\nstruct phy_device *tmp = priv->mii_bus->phy_map[i];\r\nif (tmp) {\r\nphydev = tmp;\r\nbreak;\r\n}\r\n}\r\nif (!phydev) {\r\nnetdev_info(netdev, "%s: no PHY found\n", netdev->name);\r\nreturn -ENODEV;\r\n}\r\nphydev = phy_connect(netdev, dev_name(&phydev->dev),\r\n&ftgmac100_adjust_link, 0,\r\nPHY_INTERFACE_MODE_GMII);\r\nif (IS_ERR(phydev)) {\r\nnetdev_err(netdev, "%s: Could not attach to PHY\n", netdev->name);\r\nreturn PTR_ERR(phydev);\r\n}\r\npriv->phydev = phydev;\r\nreturn 0;\r\n}\r\nstatic int ftgmac100_mdiobus_read(struct mii_bus *bus, int phy_addr, int regnum)\r\n{\r\nstruct net_device *netdev = bus->priv;\r\nstruct ftgmac100 *priv = netdev_priv(netdev);\r\nunsigned int phycr;\r\nint i;\r\nphycr = ioread32(priv->base + FTGMAC100_OFFSET_PHYCR);\r\nphycr &= FTGMAC100_PHYCR_MDC_CYCTHR_MASK;\r\nphycr |= FTGMAC100_PHYCR_PHYAD(phy_addr) |\r\nFTGMAC100_PHYCR_REGAD(regnum) |\r\nFTGMAC100_PHYCR_MIIRD;\r\niowrite32(phycr, priv->base + FTGMAC100_OFFSET_PHYCR);\r\nfor (i = 0; i < 10; i++) {\r\nphycr = ioread32(priv->base + FTGMAC100_OFFSET_PHYCR);\r\nif ((phycr & FTGMAC100_PHYCR_MIIRD) == 0) {\r\nint data;\r\ndata = ioread32(priv->base + FTGMAC100_OFFSET_PHYDATA);\r\nreturn FTGMAC100_PHYDATA_MIIRDATA(data);\r\n}\r\nudelay(100);\r\n}\r\nnetdev_err(netdev, "mdio read timed out\n");\r\nreturn -EIO;\r\n}\r\nstatic int ftgmac100_mdiobus_write(struct mii_bus *bus, int phy_addr,\r\nint regnum, u16 value)\r\n{\r\nstruct net_device *netdev = bus->priv;\r\nstruct ftgmac100 *priv = netdev_priv(netdev);\r\nunsigned int phycr;\r\nint data;\r\nint i;\r\nphycr = ioread32(priv->base + FTGMAC100_OFFSET_PHYCR);\r\nphycr &= FTGMAC100_PHYCR_MDC_CYCTHR_MASK;\r\nphycr |= FTGMAC100_PHYCR_PHYAD(phy_addr) |\r\nFTGMAC100_PHYCR_REGAD(regnum) |\r\nFTGMAC100_PHYCR_MIIWR;\r\ndata = FTGMAC100_PHYDATA_MIIWDATA(value);\r\niowrite32(data, priv->base + FTGMAC100_OFFSET_PHYDATA);\r\niowrite32(phycr, priv->base + FTGMAC100_OFFSET_PHYCR);\r\nfor (i = 0; i < 10; i++) {\r\nphycr = ioread32(priv->base + FTGMAC100_OFFSET_PHYCR);\r\nif ((phycr & FTGMAC100_PHYCR_MIIWR) == 0)\r\nreturn 0;\r\nudelay(100);\r\n}\r\nnetdev_err(netdev, "mdio write timed out\n");\r\nreturn -EIO;\r\n}\r\nstatic int ftgmac100_mdiobus_reset(struct mii_bus *bus)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ftgmac100_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nstrcpy(info->bus_info, dev_name(&netdev->dev));\r\n}\r\nstatic int ftgmac100_get_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct ftgmac100 *priv = netdev_priv(netdev);\r\nreturn phy_ethtool_gset(priv->phydev, cmd);\r\n}\r\nstatic int ftgmac100_set_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct ftgmac100 *priv = netdev_priv(netdev);\r\nreturn phy_ethtool_sset(priv->phydev, cmd);\r\n}\r\nstatic irqreturn_t ftgmac100_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *netdev = dev_id;\r\nstruct ftgmac100 *priv = netdev_priv(netdev);\r\nif (likely(netif_running(netdev))) {\r\niowrite32(0, priv->base + FTGMAC100_OFFSET_IER);\r\nnapi_schedule(&priv->napi);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ftgmac100_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct ftgmac100 *priv = container_of(napi, struct ftgmac100, napi);\r\nstruct net_device *netdev = priv->netdev;\r\nunsigned int status;\r\nbool completed = true;\r\nint rx = 0;\r\nstatus = ioread32(priv->base + FTGMAC100_OFFSET_ISR);\r\niowrite32(status, priv->base + FTGMAC100_OFFSET_ISR);\r\nif (status & (FTGMAC100_INT_RPKT_BUF | FTGMAC100_INT_NO_RXBUF)) {\r\nbool retry;\r\ndo {\r\nretry = ftgmac100_rx_packet(priv, &rx);\r\n} while (retry && rx < budget);\r\nif (retry && rx == budget)\r\ncompleted = false;\r\n}\r\nif (status & (FTGMAC100_INT_XPKT_ETH | FTGMAC100_INT_XPKT_LOST)) {\r\nftgmac100_tx_complete(priv);\r\n}\r\nif (status & (FTGMAC100_INT_NO_RXBUF | FTGMAC100_INT_RPKT_LOST |\r\nFTGMAC100_INT_AHB_ERR | FTGMAC100_INT_PHYSTS_CHG)) {\r\nif (net_ratelimit())\r\nnetdev_info(netdev, "[ISR] = 0x%x: %s%s%s%s\n", status,\r\nstatus & FTGMAC100_INT_NO_RXBUF ? "NO_RXBUF " : "",\r\nstatus & FTGMAC100_INT_RPKT_LOST ? "RPKT_LOST " : "",\r\nstatus & FTGMAC100_INT_AHB_ERR ? "AHB_ERR " : "",\r\nstatus & FTGMAC100_INT_PHYSTS_CHG ? "PHYSTS_CHG" : "");\r\nif (status & FTGMAC100_INT_NO_RXBUF) {\r\nnetdev->stats.rx_over_errors++;\r\n}\r\nif (status & FTGMAC100_INT_RPKT_LOST) {\r\nnetdev->stats.rx_fifo_errors++;\r\n}\r\n}\r\nif (completed) {\r\nnapi_complete(napi);\r\niowrite32(INT_MASK_ALL_ENABLED, priv->base + FTGMAC100_OFFSET_IER);\r\n}\r\nreturn rx;\r\n}\r\nstatic int ftgmac100_open(struct net_device *netdev)\r\n{\r\nstruct ftgmac100 *priv = netdev_priv(netdev);\r\nint err;\r\nerr = ftgmac100_alloc_buffers(priv);\r\nif (err) {\r\nnetdev_err(netdev, "failed to allocate buffers\n");\r\ngoto err_alloc;\r\n}\r\nerr = request_irq(priv->irq, ftgmac100_interrupt, 0, netdev->name, netdev);\r\nif (err) {\r\nnetdev_err(netdev, "failed to request irq %d\n", priv->irq);\r\ngoto err_irq;\r\n}\r\npriv->rx_pointer = 0;\r\npriv->tx_clean_pointer = 0;\r\npriv->tx_pointer = 0;\r\npriv->tx_pending = 0;\r\nerr = ftgmac100_reset_hw(priv);\r\nif (err)\r\ngoto err_hw;\r\nftgmac100_init_hw(priv);\r\nftgmac100_start_hw(priv, 10);\r\nphy_start(priv->phydev);\r\nnapi_enable(&priv->napi);\r\nnetif_start_queue(netdev);\r\niowrite32(INT_MASK_ALL_ENABLED, priv->base + FTGMAC100_OFFSET_IER);\r\nreturn 0;\r\nerr_hw:\r\nfree_irq(priv->irq, netdev);\r\nerr_irq:\r\nftgmac100_free_buffers(priv);\r\nerr_alloc:\r\nreturn err;\r\n}\r\nstatic int ftgmac100_stop(struct net_device *netdev)\r\n{\r\nstruct ftgmac100 *priv = netdev_priv(netdev);\r\niowrite32(0, priv->base + FTGMAC100_OFFSET_IER);\r\nnetif_stop_queue(netdev);\r\nnapi_disable(&priv->napi);\r\nphy_stop(priv->phydev);\r\nftgmac100_stop_hw(priv);\r\nfree_irq(priv->irq, netdev);\r\nftgmac100_free_buffers(priv);\r\nreturn 0;\r\n}\r\nstatic int ftgmac100_hard_start_xmit(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct ftgmac100 *priv = netdev_priv(netdev);\r\ndma_addr_t map;\r\nif (unlikely(skb->len > MAX_PKT_SIZE)) {\r\nif (net_ratelimit())\r\nnetdev_dbg(netdev, "tx packet too big\n");\r\nnetdev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nmap = dma_map_single(priv->dev, skb->data, skb_headlen(skb), DMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(priv->dev, map))) {\r\nif (net_ratelimit())\r\nnetdev_err(netdev, "map socket buffer failed\n");\r\nnetdev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nreturn ftgmac100_xmit(priv, skb, map);\r\n}\r\nstatic int ftgmac100_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct ftgmac100 *priv = netdev_priv(netdev);\r\nreturn phy_mii_ioctl(priv->phydev, ifr, cmd);\r\n}\r\nstatic int ftgmac100_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint irq;\r\nstruct net_device *netdev;\r\nstruct ftgmac100 *priv;\r\nint err;\r\nint i;\r\nif (!pdev)\r\nreturn -ENODEV;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENXIO;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nnetdev = alloc_etherdev(sizeof(*priv));\r\nif (!netdev) {\r\nerr = -ENOMEM;\r\ngoto err_alloc_etherdev;\r\n}\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\nSET_ETHTOOL_OPS(netdev, &ftgmac100_ethtool_ops);\r\nnetdev->netdev_ops = &ftgmac100_netdev_ops;\r\nnetdev->features = NETIF_F_IP_CSUM | NETIF_F_GRO;\r\nplatform_set_drvdata(pdev, netdev);\r\npriv = netdev_priv(netdev);\r\npriv->netdev = netdev;\r\npriv->dev = &pdev->dev;\r\nspin_lock_init(&priv->tx_lock);\r\nnetif_napi_add(netdev, &priv->napi, ftgmac100_poll, 64);\r\npriv->res = request_mem_region(res->start, resource_size(res),\r\ndev_name(&pdev->dev));\r\nif (!priv->res) {\r\ndev_err(&pdev->dev, "Could not reserve memory region\n");\r\nerr = -ENOMEM;\r\ngoto err_req_mem;\r\n}\r\npriv->base = ioremap(res->start, resource_size(res));\r\nif (!priv->base) {\r\ndev_err(&pdev->dev, "Failed to ioremap ethernet registers\n");\r\nerr = -EIO;\r\ngoto err_ioremap;\r\n}\r\npriv->irq = irq;\r\npriv->mii_bus = mdiobus_alloc();\r\nif (!priv->mii_bus) {\r\nerr = -EIO;\r\ngoto err_alloc_mdiobus;\r\n}\r\npriv->mii_bus->name = "ftgmac100_mdio";\r\nsnprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "ftgmac100_mii");\r\npriv->mii_bus->priv = netdev;\r\npriv->mii_bus->read = ftgmac100_mdiobus_read;\r\npriv->mii_bus->write = ftgmac100_mdiobus_write;\r\npriv->mii_bus->reset = ftgmac100_mdiobus_reset;\r\npriv->mii_bus->irq = priv->phy_irq;\r\nfor (i = 0; i < PHY_MAX_ADDR; i++)\r\npriv->mii_bus->irq[i] = PHY_POLL;\r\nerr = mdiobus_register(priv->mii_bus);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot register MDIO bus!\n");\r\ngoto err_register_mdiobus;\r\n}\r\nerr = ftgmac100_mii_probe(priv);\r\nif (err) {\r\ndev_err(&pdev->dev, "MII Probe failed!\n");\r\ngoto err_mii_probe;\r\n}\r\nerr = register_netdev(netdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to register netdev\n");\r\ngoto err_register_netdev;\r\n}\r\nnetdev_info(netdev, "irq %d, mapped at %p\n", priv->irq, priv->base);\r\nif (!is_valid_ether_addr(netdev->dev_addr)) {\r\neth_hw_addr_random(netdev);\r\nnetdev_info(netdev, "generated random MAC address %pM\n",\r\nnetdev->dev_addr);\r\n}\r\nreturn 0;\r\nerr_register_netdev:\r\nphy_disconnect(priv->phydev);\r\nerr_mii_probe:\r\nmdiobus_unregister(priv->mii_bus);\r\nerr_register_mdiobus:\r\nmdiobus_free(priv->mii_bus);\r\nerr_alloc_mdiobus:\r\niounmap(priv->base);\r\nerr_ioremap:\r\nrelease_resource(priv->res);\r\nerr_req_mem:\r\nnetif_napi_del(&priv->napi);\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_netdev(netdev);\r\nerr_alloc_etherdev:\r\nreturn err;\r\n}\r\nstatic int __exit ftgmac100_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *netdev;\r\nstruct ftgmac100 *priv;\r\nnetdev = platform_get_drvdata(pdev);\r\npriv = netdev_priv(netdev);\r\nunregister_netdev(netdev);\r\nphy_disconnect(priv->phydev);\r\nmdiobus_unregister(priv->mii_bus);\r\nmdiobus_free(priv->mii_bus);\r\niounmap(priv->base);\r\nrelease_resource(priv->res);\r\nnetif_napi_del(&priv->napi);\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_netdev(netdev);\r\nreturn 0;\r\n}\r\nstatic int __init ftgmac100_init(void)\r\n{\r\npr_info("Loading version " DRV_VERSION " ...\n");\r\nreturn platform_driver_register(&ftgmac100_driver);\r\n}\r\nstatic void __exit ftgmac100_exit(void)\r\n{\r\nplatform_driver_unregister(&ftgmac100_driver);\r\n}
