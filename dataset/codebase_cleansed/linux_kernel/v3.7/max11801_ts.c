static u8 read_register(struct i2c_client *client, int addr)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, addr << 1);\r\n}\r\nstatic int max11801_write_reg(struct i2c_client *client, int addr, int data)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, addr << 1, data);\r\n}\r\nstatic irqreturn_t max11801_ts_interrupt(int irq, void *dev_id)\r\n{\r\nstruct max11801_data *data = dev_id;\r\nstruct i2c_client *client = data->client;\r\nint status, i, ret;\r\nu8 buf[XY_BUFSIZE];\r\nint x = -1;\r\nint y = -1;\r\nstatus = read_register(data->client, GENERNAL_STATUS_REG);\r\nif (status & (MAX11801_FIFO_INT | MAX11801_FIFO_OVERFLOW)) {\r\nstatus = read_register(data->client, GENERNAL_STATUS_REG);\r\nret = i2c_smbus_read_i2c_block_data(client, FIFO_RD_CMD,\r\nXY_BUFSIZE, buf);\r\nif (ret < XY_BUFSIZE)\r\ngoto out;\r\nfor (i = 0; i < XY_BUFSIZE; i += XY_BUFSIZE / 2) {\r\nif ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_X_TAG)\r\nx = (buf[i] << XY_BUF_OFFSET) +\r\n(buf[i + 1] >> XY_BUF_OFFSET);\r\nelse if ((buf[i + 1] & MEASURE_TAG_MASK) == MEASURE_Y_TAG)\r\ny = (buf[i] << XY_BUF_OFFSET) +\r\n(buf[i + 1] >> XY_BUF_OFFSET);\r\n}\r\nif ((buf[1] & EVENT_TAG_MASK) != (buf[3] & EVENT_TAG_MASK))\r\ngoto out;\r\nswitch (buf[1] & EVENT_TAG_MASK) {\r\ncase EVENT_INIT:\r\ncase EVENT_MIDDLE:\r\ninput_report_abs(data->input_dev, ABS_X, x);\r\ninput_report_abs(data->input_dev, ABS_Y, y);\r\ninput_event(data->input_dev, EV_KEY, BTN_TOUCH, 1);\r\ninput_sync(data->input_dev);\r\nbreak;\r\ncase EVENT_RELEASE:\r\ninput_event(data->input_dev, EV_KEY, BTN_TOUCH, 0);\r\ninput_sync(data->input_dev);\r\nbreak;\r\ncase EVENT_FIFO_END:\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __devinit max11801_ts_phy_init(struct max11801_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nmax11801_write_reg(client, MESURE_AVER_CONF_REG, 0xff);\r\nmax11801_write_reg(client, PANEL_SETUPTIME_CONF_REG, 0x11);\r\nmax11801_write_reg(client, TOUCH_DETECT_PULLUP_CONF_REG, 0x10);\r\nmax11801_write_reg(client, AUTO_MODE_TIME_CONF_REG, 0xaa);\r\nmax11801_write_reg(client, APERTURE_CONF_REG, 0x33);\r\nmax11801_write_reg(client, OP_MODE_CONF_REG, 0x36);\r\n}\r\nstatic int __devinit max11801_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct max11801_data *data;\r\nstruct input_dev *input_dev;\r\nint error;\r\ndata = kzalloc(sizeof(struct max11801_data), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!data || !input_dev) {\r\ndev_err(&client->dev, "Failed to allocate memory\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ndata->client = client;\r\ndata->input_dev = input_dev;\r\ninput_dev->name = "max11801_ts";\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = &client->dev;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_X, 0, MAX11801_MAX_X, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, MAX11801_MAX_Y, 0, 0);\r\ninput_set_drvdata(input_dev, data);\r\nmax11801_ts_phy_init(data);\r\nerror = request_threaded_irq(client->irq, NULL, max11801_ts_interrupt,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"max11801_ts", data);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\ngoto err_free_mem;\r\n}\r\nerror = input_register_device(data->input_dev);\r\nif (error)\r\ngoto err_free_irq;\r\ni2c_set_clientdata(client, data);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(client->irq, data);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(data);\r\nreturn error;\r\n}\r\nstatic __devexit int max11801_ts_remove(struct i2c_client *client)\r\n{\r\nstruct max11801_data *data = i2c_get_clientdata(client);\r\nfree_irq(client->irq, data);\r\ninput_unregister_device(data->input_dev);\r\nkfree(data);\r\nreturn 0;\r\n}
