static int em28xx_get_key_terratec(struct IR_i2c *ir, u32 *ir_key, u32 *ir_raw)\r\n{\r\nunsigned char b;\r\nif (1 != i2c_master_recv(ir->c, &b, 1)) {\r\ni2cdprintk("read error\n");\r\nreturn -EIO;\r\n}\r\ni2cdprintk("key %02x\n", b);\r\nif (b == 0xff)\r\nreturn 0;\r\nif (b == 0xfe)\r\nreturn 1;\r\n*ir_key = b;\r\n*ir_raw = b;\r\nreturn 1;\r\n}\r\nstatic int em28xx_get_key_em_haup(struct IR_i2c *ir, u32 *ir_key, u32 *ir_raw)\r\n{\r\nunsigned char buf[2];\r\nu16 code;\r\nint size;\r\nsize = i2c_master_recv(ir->c, buf, sizeof(buf));\r\nif (size != 2)\r\nreturn -EIO;\r\nif (buf[1] == 0xff)\r\nreturn 0;\r\nir->old = buf[1];\r\ncode =\r\n((buf[0] & 0x01) ? 0x0020 : 0) |\r\n((buf[0] & 0x02) ? 0x0010 : 0) |\r\n((buf[0] & 0x04) ? 0x0008 : 0) |\r\n((buf[0] & 0x08) ? 0x0004 : 0) |\r\n((buf[0] & 0x10) ? 0x0002 : 0) |\r\n((buf[0] & 0x20) ? 0x0001 : 0) |\r\n((buf[1] & 0x08) ? 0x1000 : 0) |\r\n((buf[1] & 0x10) ? 0x0800 : 0) |\r\n((buf[1] & 0x20) ? 0x0400 : 0) |\r\n((buf[1] & 0x40) ? 0x0200 : 0) |\r\n((buf[1] & 0x80) ? 0x0100 : 0);\r\ni2cdprintk("ir hauppauge (em2840): code=0x%02x (rcv=0x%02x%02x)\n",\r\ncode, buf[1], buf[0]);\r\n*ir_key = code;\r\n*ir_raw = code;\r\nreturn 1;\r\n}\r\nstatic int em28xx_get_key_pinnacle_usb_grey(struct IR_i2c *ir, u32 *ir_key,\r\nu32 *ir_raw)\r\n{\r\nunsigned char buf[3];\r\nif (3 != i2c_master_recv(ir->c, buf, 3)) {\r\ni2cdprintk("read error\n");\r\nreturn -EIO;\r\n}\r\ni2cdprintk("key %02x\n", buf[2]&0x3f);\r\nif (buf[0] != 0x00)\r\nreturn 0;\r\n*ir_key = buf[2]&0x3f;\r\n*ir_raw = buf[2]&0x3f;\r\nreturn 1;\r\n}\r\nstatic int em28xx_get_key_winfast_usbii_deluxe(struct IR_i2c *ir, u32 *ir_key,\r\nu32 *ir_raw)\r\n{\r\nunsigned char subaddr, keydetect, key;\r\nstruct i2c_msg msg[] = { { .addr = ir->c->addr, .flags = 0, .buf = &subaddr, .len = 1},\r\n{ .addr = ir->c->addr, .flags = I2C_M_RD, .buf = &keydetect, .len = 1} };\r\nsubaddr = 0x10;\r\nif (2 != i2c_transfer(ir->c->adapter, msg, 2)) {\r\ni2cdprintk("read error\n");\r\nreturn -EIO;\r\n}\r\nif (keydetect == 0x00)\r\nreturn 0;\r\nsubaddr = 0x00;\r\nmsg[1].buf = &key;\r\nif (2 != i2c_transfer(ir->c->adapter, msg, 2)) {\r\ni2cdprintk("read error\n");\r\nreturn -EIO;\r\n}\r\nif (key == 0x00)\r\nreturn 0;\r\n*ir_key = key;\r\n*ir_raw = key;\r\nreturn 1;\r\n}\r\nstatic int default_polling_getkey(struct em28xx_IR *ir,\r\nstruct em28xx_ir_poll_result *poll_result)\r\n{\r\nstruct em28xx *dev = ir->dev;\r\nint rc;\r\nu8 msg[3] = { 0, 0, 0 };\r\nrc = dev->em28xx_read_reg_req_len(dev, 0, EM28XX_R45_IR,\r\nmsg, sizeof(msg));\r\nif (rc < 0)\r\nreturn rc;\r\npoll_result->toggle_bit = (msg[0] >> 7);\r\npoll_result->read_count = (msg[0] & 0x7f);\r\npoll_result->rc_address = msg[1];\r\npoll_result->rc_data[0] = msg[2];\r\nreturn 0;\r\n}\r\nstatic int em2874_polling_getkey(struct em28xx_IR *ir,\r\nstruct em28xx_ir_poll_result *poll_result)\r\n{\r\nstruct em28xx *dev = ir->dev;\r\nint rc;\r\nu8 msg[5] = { 0, 0, 0, 0, 0 };\r\nrc = dev->em28xx_read_reg_req_len(dev, 0, EM2874_R51_IR,\r\nmsg, sizeof(msg));\r\nif (rc < 0)\r\nreturn rc;\r\npoll_result->toggle_bit = (msg[0] >> 7);\r\npoll_result->read_count = (msg[0] & 0x7f);\r\npoll_result->rc_address = msg[1];\r\npoll_result->rc_data[0] = msg[2];\r\npoll_result->rc_data[1] = msg[3];\r\npoll_result->rc_data[2] = msg[4];\r\nreturn 0;\r\n}\r\nstatic void em28xx_ir_handle_key(struct em28xx_IR *ir)\r\n{\r\nint result;\r\nstruct em28xx_ir_poll_result poll_result;\r\nresult = ir->get_key(ir, &poll_result);\r\nif (unlikely(result < 0)) {\r\ndprintk("ir->get_key() failed %d\n", result);\r\nreturn;\r\n}\r\nif (unlikely(poll_result.read_count != ir->last_readcount)) {\r\ndprintk("%s: toggle: %d, count: %d, key 0x%02x%02x\n", __func__,\r\npoll_result.toggle_bit, poll_result.read_count,\r\npoll_result.rc_address, poll_result.rc_data[0]);\r\nif (ir->full_code)\r\nrc_keydown(ir->rc,\r\npoll_result.rc_address << 8 |\r\npoll_result.rc_data[0],\r\npoll_result.toggle_bit);\r\nelse\r\nrc_keydown(ir->rc,\r\npoll_result.rc_data[0],\r\npoll_result.toggle_bit);\r\nif (ir->dev->chip_id == CHIP_ID_EM2874 ||\r\nir->dev->chip_id == CHIP_ID_EM2884)\r\nir->last_readcount = 0;\r\nelse\r\nir->last_readcount = poll_result.read_count;\r\n}\r\n}\r\nstatic void em28xx_ir_work(struct work_struct *work)\r\n{\r\nstruct em28xx_IR *ir = container_of(work, struct em28xx_IR, work.work);\r\nem28xx_ir_handle_key(ir);\r\nschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling));\r\n}\r\nstatic int em28xx_ir_start(struct rc_dev *rc)\r\n{\r\nstruct em28xx_IR *ir = rc->priv;\r\nINIT_DELAYED_WORK(&ir->work, em28xx_ir_work);\r\nschedule_delayed_work(&ir->work, 0);\r\nreturn 0;\r\n}\r\nstatic void em28xx_ir_stop(struct rc_dev *rc)\r\n{\r\nstruct em28xx_IR *ir = rc->priv;\r\ncancel_delayed_work_sync(&ir->work);\r\n}\r\nstatic int em28xx_ir_change_protocol(struct rc_dev *rc_dev, u64 rc_type)\r\n{\r\nint rc = 0;\r\nstruct em28xx_IR *ir = rc_dev->priv;\r\nstruct em28xx *dev = ir->dev;\r\nu8 ir_config = EM2874_IR_RC5;\r\nif (rc_type == RC_TYPE_RC5) {\r\ndev->board.xclk |= EM28XX_XCLK_IR_RC5_MODE;\r\nir->full_code = 1;\r\n} else if (rc_type == RC_TYPE_NEC) {\r\ndev->board.xclk &= ~EM28XX_XCLK_IR_RC5_MODE;\r\nir_config = EM2874_IR_NEC;\r\nir->full_code = 1;\r\n} else if (rc_type != RC_TYPE_UNKNOWN)\r\nrc = -EINVAL;\r\nem28xx_write_reg_bits(dev, EM28XX_R0F_XCLK, dev->board.xclk,\r\nEM28XX_XCLK_IR_RC5_MODE);\r\nswitch (dev->chip_id) {\r\ncase CHIP_ID_EM2860:\r\ncase CHIP_ID_EM2883:\r\nir->get_key = default_polling_getkey;\r\nbreak;\r\ncase CHIP_ID_EM2884:\r\ncase CHIP_ID_EM2874:\r\ncase CHIP_ID_EM28174:\r\nir->get_key = em2874_polling_getkey;\r\nem28xx_write_regs(dev, EM2874_R50_IR_CONFIG, &ir_config, 1);\r\nbreak;\r\ndefault:\r\nprintk("Unrecognized em28xx chip id 0x%02x: IR not supported\n",\r\ndev->chip_id);\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nstatic void em28xx_register_i2c_ir(struct em28xx *dev)\r\n{\r\nstruct i2c_board_info info;\r\nconst unsigned short addr_list[] = {\r\n0x1f, 0x30, 0x47, I2C_CLIENT_END\r\n};\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nmemset(&dev->init_data, 0, sizeof(dev->init_data));\r\nstrlcpy(info.type, "ir_video", I2C_NAME_SIZE);\r\nswitch (dev->model) {\r\ncase EM2800_BOARD_TERRATEC_CINERGY_200:\r\ncase EM2820_BOARD_TERRATEC_CINERGY_250:\r\ndev->init_data.ir_codes = RC_MAP_EM_TERRATEC;\r\ndev->init_data.get_key = em28xx_get_key_terratec;\r\ndev->init_data.name = "i2c IR (EM28XX Terratec)";\r\nbreak;\r\ncase EM2820_BOARD_PINNACLE_USB_2:\r\ndev->init_data.ir_codes = RC_MAP_PINNACLE_GREY;\r\ndev->init_data.get_key = em28xx_get_key_pinnacle_usb_grey;\r\ndev->init_data.name = "i2c IR (EM28XX Pinnacle PCTV)";\r\nbreak;\r\ncase EM2820_BOARD_HAUPPAUGE_WINTV_USB_2:\r\ndev->init_data.ir_codes = RC_MAP_HAUPPAUGE;\r\ndev->init_data.get_key = em28xx_get_key_em_haup;\r\ndev->init_data.name = "i2c IR (EM2840 Hauppauge)";\r\nbreak;\r\ncase EM2820_BOARD_LEADTEK_WINFAST_USBII_DELUXE:\r\ndev->init_data.ir_codes = RC_MAP_WINFAST_USBII_DELUXE;\r\ndev->init_data.get_key = em28xx_get_key_winfast_usbii_deluxe;\r\ndev->init_data.name = "i2c IR (EM2820 Winfast TV USBII Deluxe)";\r\nbreak;\r\n}\r\nif (dev->init_data.name)\r\ninfo.platform_data = &dev->init_data;\r\ni2c_new_probed_device(&dev->i2c_adap, &info, addr_list, NULL);\r\n}\r\nstatic void em28xx_query_sbutton(struct work_struct *work)\r\n{\r\nstruct em28xx *dev =\r\ncontainer_of(work, struct em28xx, sbutton_query_work.work);\r\nint ret;\r\nret = em28xx_read_reg(dev, EM28XX_R0C_USBSUSP);\r\nif (ret & EM28XX_R0C_USBSUSP_SNAPSHOT) {\r\nu8 cleared;\r\ncleared = ((u8) ret) & ~EM28XX_R0C_USBSUSP_SNAPSHOT;\r\nem28xx_write_regs(dev, EM28XX_R0C_USBSUSP, &cleared, 1);\r\ninput_report_key(dev->sbutton_input_dev, EM28XX_SNAPSHOT_KEY,\r\n1);\r\ninput_report_key(dev->sbutton_input_dev, EM28XX_SNAPSHOT_KEY,\r\n0);\r\n}\r\nschedule_delayed_work(&dev->sbutton_query_work,\r\nmsecs_to_jiffies(EM28XX_SBUTTON_QUERY_INTERVAL));\r\n}\r\nstatic void em28xx_register_snapshot_button(struct em28xx *dev)\r\n{\r\nstruct input_dev *input_dev;\r\nint err;\r\nem28xx_info("Registering snapshot button...\n");\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\nem28xx_errdev("input_allocate_device failed\n");\r\nreturn;\r\n}\r\nusb_make_path(dev->udev, dev->snapshot_button_path,\r\nsizeof(dev->snapshot_button_path));\r\nstrlcat(dev->snapshot_button_path, "/sbutton",\r\nsizeof(dev->snapshot_button_path));\r\nINIT_DELAYED_WORK(&dev->sbutton_query_work, em28xx_query_sbutton);\r\ninput_dev->name = "em28xx snapshot button";\r\ninput_dev->phys = dev->snapshot_button_path;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\r\nset_bit(EM28XX_SNAPSHOT_KEY, input_dev->keybit);\r\ninput_dev->keycodesize = 0;\r\ninput_dev->keycodemax = 0;\r\ninput_dev->id.bustype = BUS_USB;\r\ninput_dev->id.vendor = le16_to_cpu(dev->udev->descriptor.idVendor);\r\ninput_dev->id.product = le16_to_cpu(dev->udev->descriptor.idProduct);\r\ninput_dev->id.version = 1;\r\ninput_dev->dev.parent = &dev->udev->dev;\r\nerr = input_register_device(input_dev);\r\nif (err) {\r\nem28xx_errdev("input_register_device failed\n");\r\ninput_free_device(input_dev);\r\nreturn;\r\n}\r\ndev->sbutton_input_dev = input_dev;\r\nschedule_delayed_work(&dev->sbutton_query_work,\r\nmsecs_to_jiffies(EM28XX_SBUTTON_QUERY_INTERVAL));\r\nreturn;\r\n}\r\nstatic void em28xx_deregister_snapshot_button(struct em28xx *dev)\r\n{\r\nif (dev->sbutton_input_dev != NULL) {\r\nem28xx_info("Deregistering snapshot button\n");\r\ncancel_delayed_work_sync(&dev->sbutton_query_work);\r\ninput_unregister_device(dev->sbutton_input_dev);\r\ndev->sbutton_input_dev = NULL;\r\n}\r\nreturn;\r\n}\r\nstatic int em28xx_ir_init(struct em28xx *dev)\r\n{\r\nstruct em28xx_IR *ir;\r\nstruct rc_dev *rc;\r\nint err = -ENOMEM;\r\nif (dev->board.ir_codes == NULL) {\r\nem28xx_warn("Remote control support is not available for "\r\n"this card.\n");\r\nreturn 0;\r\n}\r\nir = kzalloc(sizeof(*ir), GFP_KERNEL);\r\nrc = rc_allocate_device();\r\nif (!ir || !rc)\r\ngoto err_out_free;\r\nir->dev = dev;\r\ndev->ir = ir;\r\nir->rc = rc;\r\nrc->allowed_protos = RC_TYPE_RC5 | RC_TYPE_NEC;\r\nrc->priv = ir;\r\nrc->change_protocol = em28xx_ir_change_protocol;\r\nrc->open = em28xx_ir_start;\r\nrc->close = em28xx_ir_stop;\r\nerr = em28xx_ir_change_protocol(rc, RC_TYPE_UNKNOWN);\r\nif (err)\r\ngoto err_out_free;\r\nir->polling = 100;\r\nsnprintf(ir->name, sizeof(ir->name), "em28xx IR (%s)",\r\ndev->name);\r\nusb_make_path(dev->udev, ir->phys, sizeof(ir->phys));\r\nstrlcat(ir->phys, "/input0", sizeof(ir->phys));\r\nrc->input_name = ir->name;\r\nrc->input_phys = ir->phys;\r\nrc->input_id.bustype = BUS_USB;\r\nrc->input_id.version = 1;\r\nrc->input_id.vendor = le16_to_cpu(dev->udev->descriptor.idVendor);\r\nrc->input_id.product = le16_to_cpu(dev->udev->descriptor.idProduct);\r\nrc->dev.parent = &dev->udev->dev;\r\nrc->map_name = dev->board.ir_codes;\r\nrc->driver_name = MODULE_NAME;\r\nerr = rc_register_device(rc);\r\nif (err)\r\ngoto err_out_stop;\r\nem28xx_register_i2c_ir(dev);\r\n#if defined(CONFIG_MODULES) && defined(MODULE)\r\nif (dev->board.has_ir_i2c)\r\nrequest_module("ir-kbd-i2c");\r\n#endif\r\nif (dev->board.has_snapshot_button)\r\nem28xx_register_snapshot_button(dev);\r\nreturn 0;\r\nerr_out_stop:\r\ndev->ir = NULL;\r\nerr_out_free:\r\nrc_free_device(rc);\r\nkfree(ir);\r\nreturn err;\r\n}\r\nstatic int em28xx_ir_fini(struct em28xx *dev)\r\n{\r\nstruct em28xx_IR *ir = dev->ir;\r\nem28xx_deregister_snapshot_button(dev);\r\nif (!ir)\r\nreturn 0;\r\nif (ir->rc)\r\nrc_unregister_device(ir->rc);\r\nkfree(ir);\r\ndev->ir = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init em28xx_rc_register(void)\r\n{\r\nreturn em28xx_register_extension(&rc_ops);\r\n}\r\nstatic void __exit em28xx_rc_unregister(void)\r\n{\r\nem28xx_unregister_extension(&rc_ops);\r\n}
