static int pmc551_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nstruct mypriv *priv = mtd->priv;\r\nu32 soff_hi, soff_lo;\r\nu32 eoff_hi, eoff_lo;\r\nunsigned long end;\r\nu_char *ptr;\r\nsize_t retlen;\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551_erase(pos:%ld, len:%ld)\n", (long)instr->addr,\r\n(long)instr->len);\r\n#endif\r\nend = instr->addr + instr->len - 1;\r\neoff_hi = end & ~(priv->asize - 1);\r\nsoff_hi = instr->addr & ~(priv->asize - 1);\r\neoff_lo = end & (priv->asize - 1);\r\nsoff_lo = instr->addr & (priv->asize - 1);\r\npmc551_point(mtd, instr->addr, instr->len, &retlen,\r\n(void **)&ptr, NULL);\r\nif (soff_hi == eoff_hi || mtd->size == priv->asize) {\r\nmemset(ptr, 0xff, instr->len);\r\n} else {\r\nwhile (soff_hi != eoff_hi) {\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551_erase() soff_hi: %ld, "\r\n"eoff_hi: %ld\n", (long)soff_hi, (long)eoff_hi);\r\n#endif\r\nmemset(ptr, 0xff, priv->asize);\r\nif (soff_hi + priv->asize >= mtd->size) {\r\ngoto out;\r\n}\r\nsoff_hi += priv->asize;\r\npmc551_point(mtd, (priv->base_map0 | soff_hi),\r\npriv->asize, &retlen,\r\n(void **)&ptr, NULL);\r\n}\r\nmemset(ptr, 0xff, eoff_lo);\r\n}\r\nout:\r\ninstr->state = MTD_ERASE_DONE;\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551_erase() done\n");\r\n#endif\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nstatic int pmc551_point(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, void **virt, resource_size_t *phys)\r\n{\r\nstruct mypriv *priv = mtd->priv;\r\nu32 soff_hi;\r\nu32 soff_lo;\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551_point(%ld, %ld)\n", (long)from, (long)len);\r\n#endif\r\nsoff_hi = from & ~(priv->asize - 1);\r\nsoff_lo = from & (priv->asize - 1);\r\nif (priv->curr_map0 != from) {\r\npci_write_config_dword(priv->dev, PMC551_PCI_MEM_MAP0,\r\n(priv->base_map0 | soff_hi));\r\npriv->curr_map0 = soff_hi;\r\n}\r\n*virt = priv->start + soff_lo;\r\n*retlen = len;\r\nreturn 0;\r\n}\r\nstatic int pmc551_unpoint(struct mtd_info *mtd, loff_t from, size_t len)\r\n{\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551_unpoint()\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int pmc551_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t * retlen, u_char * buf)\r\n{\r\nstruct mypriv *priv = mtd->priv;\r\nu32 soff_hi, soff_lo;\r\nu32 eoff_hi, eoff_lo;\r\nunsigned long end;\r\nu_char *ptr;\r\nu_char *copyto = buf;\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551_read(pos:%ld, len:%ld) asize: %ld\n",\r\n(long)from, (long)len, (long)priv->asize);\r\n#endif\r\nend = from + len - 1;\r\nsoff_hi = from & ~(priv->asize - 1);\r\neoff_hi = end & ~(priv->asize - 1);\r\nsoff_lo = from & (priv->asize - 1);\r\neoff_lo = end & (priv->asize - 1);\r\npmc551_point(mtd, from, len, retlen, (void **)&ptr, NULL);\r\nif (soff_hi == eoff_hi) {\r\nmemcpy(copyto, ptr, len);\r\ncopyto += len;\r\n} else {\r\nwhile (soff_hi != eoff_hi) {\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551_read() soff_hi: %ld, "\r\n"eoff_hi: %ld\n", (long)soff_hi, (long)eoff_hi);\r\n#endif\r\nmemcpy(copyto, ptr, priv->asize);\r\ncopyto += priv->asize;\r\nif (soff_hi + priv->asize >= mtd->size) {\r\ngoto out;\r\n}\r\nsoff_hi += priv->asize;\r\npmc551_point(mtd, soff_hi, priv->asize, retlen,\r\n(void **)&ptr, NULL);\r\n}\r\nmemcpy(copyto, ptr, eoff_lo);\r\ncopyto += eoff_lo;\r\n}\r\nout:\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551_read() done\n");\r\n#endif\r\n*retlen = copyto - buf;\r\nreturn 0;\r\n}\r\nstatic int pmc551_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t * retlen, const u_char * buf)\r\n{\r\nstruct mypriv *priv = mtd->priv;\r\nu32 soff_hi, soff_lo;\r\nu32 eoff_hi, eoff_lo;\r\nunsigned long end;\r\nu_char *ptr;\r\nconst u_char *copyfrom = buf;\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551_write(pos:%ld, len:%ld) asize:%ld\n",\r\n(long)to, (long)len, (long)priv->asize);\r\n#endif\r\nend = to + len - 1;\r\nsoff_hi = to & ~(priv->asize - 1);\r\neoff_hi = end & ~(priv->asize - 1);\r\nsoff_lo = to & (priv->asize - 1);\r\neoff_lo = end & (priv->asize - 1);\r\npmc551_point(mtd, to, len, retlen, (void **)&ptr, NULL);\r\nif (soff_hi == eoff_hi) {\r\nmemcpy(ptr, copyfrom, len);\r\ncopyfrom += len;\r\n} else {\r\nwhile (soff_hi != eoff_hi) {\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551_write() soff_hi: %ld, "\r\n"eoff_hi: %ld\n", (long)soff_hi, (long)eoff_hi);\r\n#endif\r\nmemcpy(ptr, copyfrom, priv->asize);\r\ncopyfrom += priv->asize;\r\nif (soff_hi >= mtd->size) {\r\ngoto out;\r\n}\r\nsoff_hi += priv->asize;\r\npmc551_point(mtd, soff_hi, priv->asize, retlen,\r\n(void **)&ptr, NULL);\r\n}\r\nmemcpy(ptr, copyfrom, eoff_lo);\r\ncopyfrom += eoff_lo;\r\n}\r\nout:\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551_write() done\n");\r\n#endif\r\n*retlen = copyfrom - buf;\r\nreturn 0;\r\n}\r\nstatic int fixup_pmc551(struct pci_dev *dev)\r\n{\r\n#ifdef CONFIG_MTD_PMC551_BUGFIX\r\nu32 dram_data;\r\n#endif\r\nu32 size, dcmd, cfg, dtmp;\r\nu16 cmd, tmp, i;\r\nu8 bcmd, counter;\r\nif (!dev) {\r\nreturn -ENODEV;\r\n}\r\ncounter = 0;\r\npci_write_config_byte(dev, PMC551_SYS_CTRL_REG, 0xA5);\r\npci_read_config_byte(dev, PMC551_SYS_CTRL_REG, &bcmd);\r\nfor (i = 0; i < 10; i++) {\r\ncounter = 0;\r\nbcmd &= ~0x80;\r\nwhile (counter++ < 100) {\r\npci_write_config_byte(dev, PMC551_SYS_CTRL_REG, bcmd);\r\n}\r\ncounter = 0;\r\nbcmd |= 0x80;\r\nwhile (counter++ < 100) {\r\npci_write_config_byte(dev, PMC551_SYS_CTRL_REG, bcmd);\r\n}\r\n}\r\nbcmd |= (0x40 | 0x20);\r\npci_write_config_byte(dev, PMC551_SYS_CTRL_REG, bcmd);\r\npci_read_config_word(dev, PCI_COMMAND, &cmd);\r\ntmp = cmd & ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\r\npci_write_config_word(dev, PCI_COMMAND, tmp);\r\npci_read_config_dword(dev, PMC551_PCI_MEM_MAP0, &dcmd);\r\ndtmp = (dcmd | PMC551_PCI_MEM_MAP_ENABLE | PMC551_PCI_MEM_MAP_REG_EN);\r\npci_write_config_dword(dev, PMC551_PCI_MEM_MAP0, dtmp);\r\npci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &cfg);\r\n#ifndef CONFIG_MTD_PMC551_BUGFIX\r\npci_write_config_dword(dev, PCI_BASE_ADDRESS_0, ~0);\r\npci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &size);\r\nsize = (size & PCI_BASE_ADDRESS_MEM_MASK);\r\nsize &= ~(size - 1);\r\npci_write_config_dword(dev, PCI_BASE_ADDRESS_0, cfg);\r\n#else\r\npci_read_config_dword(dev, PMC551_DRAM_BLK0, &dram_data);\r\nsize = PMC551_DRAM_BLK_GET_SIZE(dram_data);\r\ndram_data = PMC551_DRAM_BLK_SET_COL_MUX(dram_data, 0x5);\r\ndram_data = PMC551_DRAM_BLK_SET_ROW_MUX(dram_data, 0x9);\r\npci_write_config_dword(dev, PMC551_DRAM_BLK0, dram_data);\r\npci_read_config_dword(dev, PMC551_DRAM_BLK1, &dram_data);\r\nsize += PMC551_DRAM_BLK_GET_SIZE(dram_data);\r\ndram_data = PMC551_DRAM_BLK_SET_COL_MUX(dram_data, 0x5);\r\ndram_data = PMC551_DRAM_BLK_SET_ROW_MUX(dram_data, 0x9);\r\npci_write_config_dword(dev, PMC551_DRAM_BLK1, dram_data);\r\npci_read_config_dword(dev, PMC551_DRAM_BLK2, &dram_data);\r\nsize += PMC551_DRAM_BLK_GET_SIZE(dram_data);\r\ndram_data = PMC551_DRAM_BLK_SET_COL_MUX(dram_data, 0x5);\r\ndram_data = PMC551_DRAM_BLK_SET_ROW_MUX(dram_data, 0x9);\r\npci_write_config_dword(dev, PMC551_DRAM_BLK2, dram_data);\r\npci_read_config_dword(dev, PMC551_DRAM_BLK3, &dram_data);\r\nsize += PMC551_DRAM_BLK_GET_SIZE(dram_data);\r\ndram_data = PMC551_DRAM_BLK_SET_COL_MUX(dram_data, 0x5);\r\ndram_data = PMC551_DRAM_BLK_SET_ROW_MUX(dram_data, 0x9);\r\npci_write_config_dword(dev, PMC551_DRAM_BLK3, dram_data);\r\nif ((size &= PCI_BASE_ADDRESS_MEM_MASK) == 0) {\r\nreturn -ENODEV;\r\n}\r\n#endif\r\nif ((cfg & PCI_BASE_ADDRESS_SPACE) != PCI_BASE_ADDRESS_SPACE_MEMORY) {\r\nreturn -ENODEV;\r\n}\r\npci_write_config_word(dev, PMC551_SDRAM_MA, 0x0400);\r\npci_write_config_word(dev, PMC551_SDRAM_CMD, 0x00bf);\r\ndo {\r\npci_read_config_word(dev, PMC551_SDRAM_CMD, &cmd);\r\nif (counter++ > 100)\r\nbreak;\r\n} while ((PCI_COMMAND_IO) & cmd);\r\nfor (i = 1; i <= 8; i++) {\r\npci_write_config_word(dev, PMC551_SDRAM_CMD, 0x0df);\r\ncounter = 0;\r\ndo {\r\npci_read_config_word(dev, PMC551_SDRAM_CMD, &cmd);\r\nif (counter++ > 100)\r\nbreak;\r\n} while ((PCI_COMMAND_IO) & cmd);\r\n}\r\npci_write_config_word(dev, PMC551_SDRAM_MA, 0x0020);\r\npci_write_config_word(dev, PMC551_SDRAM_CMD, 0x0ff);\r\ncounter = 0;\r\ndo {\r\npci_read_config_word(dev, PMC551_SDRAM_CMD, &cmd);\r\nif (counter++ > 100)\r\nbreak;\r\n} while ((PCI_COMMAND_IO) & cmd);\r\npci_read_config_dword(dev, PMC551_DRAM_CFG, &dcmd);\r\ndcmd |= 0x02000000;\r\npci_write_config_dword(dev, PMC551_DRAM_CFG, dcmd);\r\npci_read_config_word(dev, PCI_STATUS, &cmd);\r\nif ((cmd & PCI_COMMAND_FAST_BACK) == 0) {\r\ncmd |= PCI_COMMAND_FAST_BACK;\r\npci_write_config_word(dev, PCI_STATUS, cmd);\r\n}\r\nif ((cmd & PCI_STATUS_DEVSEL_MASK) != 0x0) {\r\ncmd &= ~PCI_STATUS_DEVSEL_MASK;\r\npci_write_config_word(dev, PCI_STATUS, cmd);\r\n}\r\npci_write_config_word(dev, PCI_COMMAND,\r\nPCI_COMMAND_MEMORY | PCI_COMMAND_IO);\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551: %d%sB (0x%x) of %sprefetchable memory at "\r\n"0x%llx\n", (size < 1024) ? size : (size < 1048576) ?\r\nsize >> 10 : size >> 20,\r\n(size < 1024) ? "" : (size < 1048576) ? "Ki" : "Mi", size,\r\n((dcmd & (0x1 << 3)) == 0) ? "non-" : "",\r\n(unsigned long long)pci_resource_start(dev, 0));\r\npci_read_config_dword(dev, PMC551_DRAM_BLK0, &dcmd);\r\nprintk(KERN_DEBUG "pmc551: DRAM_BLK0 Flags: %s,%s\n"\r\n"pmc551: DRAM_BLK0 Size: %d at %d\n"\r\n"pmc551: DRAM_BLK0 Row MUX: %d, Col MUX: %d\n",\r\n(((0x1 << 1) & dcmd) == 0) ? "RW" : "RO",\r\n(((0x1 << 0) & dcmd) == 0) ? "Off" : "On",\r\nPMC551_DRAM_BLK_GET_SIZE(dcmd),\r\n((dcmd >> 20) & 0x7FF), ((dcmd >> 13) & 0x7),\r\n((dcmd >> 9) & 0xF));\r\npci_read_config_dword(dev, PMC551_DRAM_BLK1, &dcmd);\r\nprintk(KERN_DEBUG "pmc551: DRAM_BLK1 Flags: %s,%s\n"\r\n"pmc551: DRAM_BLK1 Size: %d at %d\n"\r\n"pmc551: DRAM_BLK1 Row MUX: %d, Col MUX: %d\n",\r\n(((0x1 << 1) & dcmd) == 0) ? "RW" : "RO",\r\n(((0x1 << 0) & dcmd) == 0) ? "Off" : "On",\r\nPMC551_DRAM_BLK_GET_SIZE(dcmd),\r\n((dcmd >> 20) & 0x7FF), ((dcmd >> 13) & 0x7),\r\n((dcmd >> 9) & 0xF));\r\npci_read_config_dword(dev, PMC551_DRAM_BLK2, &dcmd);\r\nprintk(KERN_DEBUG "pmc551: DRAM_BLK2 Flags: %s,%s\n"\r\n"pmc551: DRAM_BLK2 Size: %d at %d\n"\r\n"pmc551: DRAM_BLK2 Row MUX: %d, Col MUX: %d\n",\r\n(((0x1 << 1) & dcmd) == 0) ? "RW" : "RO",\r\n(((0x1 << 0) & dcmd) == 0) ? "Off" : "On",\r\nPMC551_DRAM_BLK_GET_SIZE(dcmd),\r\n((dcmd >> 20) & 0x7FF), ((dcmd >> 13) & 0x7),\r\n((dcmd >> 9) & 0xF));\r\npci_read_config_dword(dev, PMC551_DRAM_BLK3, &dcmd);\r\nprintk(KERN_DEBUG "pmc551: DRAM_BLK3 Flags: %s,%s\n"\r\n"pmc551: DRAM_BLK3 Size: %d at %d\n"\r\n"pmc551: DRAM_BLK3 Row MUX: %d, Col MUX: %d\n",\r\n(((0x1 << 1) & dcmd) == 0) ? "RW" : "RO",\r\n(((0x1 << 0) & dcmd) == 0) ? "Off" : "On",\r\nPMC551_DRAM_BLK_GET_SIZE(dcmd),\r\n((dcmd >> 20) & 0x7FF), ((dcmd >> 13) & 0x7),\r\n((dcmd >> 9) & 0xF));\r\npci_read_config_word(dev, PCI_COMMAND, &cmd);\r\nprintk(KERN_DEBUG "pmc551: Memory Access %s\n",\r\n(((0x1 << 1) & cmd) == 0) ? "off" : "on");\r\nprintk(KERN_DEBUG "pmc551: I/O Access %s\n",\r\n(((0x1 << 0) & cmd) == 0) ? "off" : "on");\r\npci_read_config_word(dev, PCI_STATUS, &cmd);\r\nprintk(KERN_DEBUG "pmc551: Devsel %s\n",\r\n((PCI_STATUS_DEVSEL_MASK & cmd) == 0x000) ? "Fast" :\r\n((PCI_STATUS_DEVSEL_MASK & cmd) == 0x200) ? "Medium" :\r\n((PCI_STATUS_DEVSEL_MASK & cmd) == 0x400) ? "Slow" : "Invalid");\r\nprintk(KERN_DEBUG "pmc551: %sFast Back-to-Back\n",\r\n((PCI_COMMAND_FAST_BACK & cmd) == 0) ? "Not " : "");\r\npci_read_config_byte(dev, PMC551_SYS_CTRL_REG, &bcmd);\r\nprintk(KERN_DEBUG "pmc551: EEPROM is under %s control\n"\r\n"pmc551: System Control Register is %slocked to PCI access\n"\r\n"pmc551: System Control Register is %slocked to EEPROM access\n",\r\n(bcmd & 0x1) ? "software" : "hardware",\r\n(bcmd & 0x20) ? "" : "un", (bcmd & 0x40) ? "" : "un");\r\n#endif\r\nreturn size;\r\n}\r\nstatic int __init init_pmc551(void)\r\n{\r\nstruct pci_dev *PCI_Device = NULL;\r\nstruct mypriv *priv;\r\nint found = 0;\r\nstruct mtd_info *mtd;\r\nint length = 0;\r\nif (msize) {\r\nmsize = (1 << (ffs(msize) - 1)) << 20;\r\nif (msize > (1 << 30)) {\r\nprintk(KERN_NOTICE "pmc551: Invalid memory size [%d]\n",\r\nmsize);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (asize) {\r\nasize = (1 << (ffs(asize) - 1)) << 20;\r\nif (asize > (1 << 30)) {\r\nprintk(KERN_NOTICE "pmc551: Invalid aperture size "\r\n"[%d]\n", asize);\r\nreturn -EINVAL;\r\n}\r\n}\r\nprintk(KERN_INFO PMC551_VERSION);\r\nfor (;;) {\r\nif ((PCI_Device = pci_get_device(PCI_VENDOR_ID_V3_SEMI,\r\nPCI_DEVICE_ID_V3_SEMI_V370PDC,\r\nPCI_Device)) == NULL) {\r\nbreak;\r\n}\r\nprintk(KERN_NOTICE "pmc551: Found PCI V370PDC at 0x%llx\n",\r\n(unsigned long long)pci_resource_start(PCI_Device, 0));\r\nif ((length = fixup_pmc551(PCI_Device)) <= 0) {\r\nprintk(KERN_NOTICE "pmc551: Cannot init SDRAM\n");\r\nbreak;\r\n}\r\nif (msize) {\r\nlength = msize;\r\nprintk(KERN_NOTICE "pmc551: Using specified memory "\r\n"size 0x%x\n", length);\r\n} else {\r\nmsize = length;\r\n}\r\nmtd = kzalloc(sizeof(struct mtd_info), GFP_KERNEL);\r\nif (!mtd) {\r\nprintk(KERN_NOTICE "pmc551: Cannot allocate new MTD "\r\n"device.\n");\r\nbreak;\r\n}\r\npriv = kzalloc(sizeof(struct mypriv), GFP_KERNEL);\r\nif (!priv) {\r\nprintk(KERN_NOTICE "pmc551: Cannot allocate new MTD "\r\n"device.\n");\r\nkfree(mtd);\r\nbreak;\r\n}\r\nmtd->priv = priv;\r\npriv->dev = PCI_Device;\r\nif (asize > length) {\r\nprintk(KERN_NOTICE "pmc551: reducing aperture size to "\r\n"fit %dM\n", length >> 20);\r\npriv->asize = asize = length;\r\n} else if (asize == 0 || asize == length) {\r\nprintk(KERN_NOTICE "pmc551: Using existing aperture "\r\n"size %dM\n", length >> 20);\r\npriv->asize = asize = length;\r\n} else {\r\nprintk(KERN_NOTICE "pmc551: Using specified aperture "\r\n"size %dM\n", asize >> 20);\r\npriv->asize = asize;\r\n}\r\npriv->start = pci_iomap(PCI_Device, 0, priv->asize);\r\nif (!priv->start) {\r\nprintk(KERN_NOTICE "pmc551: Unable to map IO space\n");\r\nkfree(mtd->priv);\r\nkfree(mtd);\r\nbreak;\r\n}\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551: setting aperture to %d\n",\r\nffs(priv->asize >> 20) - 1);\r\n#endif\r\npriv->base_map0 = (PMC551_PCI_MEM_MAP_REG_EN\r\n| PMC551_PCI_MEM_MAP_ENABLE\r\n| (ffs(priv->asize >> 20) - 1) << 4);\r\npriv->curr_map0 = priv->base_map0;\r\npci_write_config_dword(priv->dev, PMC551_PCI_MEM_MAP0,\r\npriv->curr_map0);\r\n#ifdef CONFIG_MTD_PMC551_DEBUG\r\nprintk(KERN_DEBUG "pmc551: aperture set to %d\n",\r\n(priv->base_map0 & 0xF0) >> 4);\r\n#endif\r\nmtd->size = msize;\r\nmtd->flags = MTD_CAP_RAM;\r\nmtd->_erase = pmc551_erase;\r\nmtd->_read = pmc551_read;\r\nmtd->_write = pmc551_write;\r\nmtd->_point = pmc551_point;\r\nmtd->_unpoint = pmc551_unpoint;\r\nmtd->type = MTD_RAM;\r\nmtd->name = "PMC551 RAM board";\r\nmtd->erasesize = 0x10000;\r\nmtd->writesize = 1;\r\nmtd->owner = THIS_MODULE;\r\nif (mtd_device_register(mtd, NULL, 0)) {\r\nprintk(KERN_NOTICE "pmc551: Failed to register new device\n");\r\npci_iounmap(PCI_Device, priv->start);\r\nkfree(mtd->priv);\r\nkfree(mtd);\r\nbreak;\r\n}\r\npci_dev_get(PCI_Device);\r\nprintk(KERN_NOTICE "Registered pmc551 memory device.\n");\r\nprintk(KERN_NOTICE "Mapped %dMiB of memory from 0x%p to 0x%p\n",\r\npriv->asize >> 20,\r\npriv->start, priv->start + priv->asize);\r\nprintk(KERN_NOTICE "Total memory is %d%sB\n",\r\n(length < 1024) ? length :\r\n(length < 1048576) ? length >> 10 : length >> 20,\r\n(length < 1024) ? "" : (length < 1048576) ? "Ki" : "Mi");\r\npriv->nextpmc551 = pmc551list;\r\npmc551list = mtd;\r\nfound++;\r\n}\r\nif (PCI_Device)\r\npci_dev_put(PCI_Device);\r\nif (!pmc551list) {\r\nprintk(KERN_NOTICE "pmc551: not detected\n");\r\nreturn -ENODEV;\r\n} else {\r\nprintk(KERN_NOTICE "pmc551: %d pmc551 devices loaded\n", found);\r\nreturn 0;\r\n}\r\n}\r\nstatic void __exit cleanup_pmc551(void)\r\n{\r\nint found = 0;\r\nstruct mtd_info *mtd;\r\nstruct mypriv *priv;\r\nwhile ((mtd = pmc551list)) {\r\npriv = mtd->priv;\r\npmc551list = priv->nextpmc551;\r\nif (priv->start) {\r\nprintk(KERN_DEBUG "pmc551: unmapping %dMiB starting at "\r\n"0x%p\n", priv->asize >> 20, priv->start);\r\npci_iounmap(priv->dev, priv->start);\r\n}\r\npci_dev_put(priv->dev);\r\nkfree(mtd->priv);\r\nmtd_device_unregister(mtd);\r\nkfree(mtd);\r\nfound++;\r\n}\r\nprintk(KERN_NOTICE "pmc551: %d pmc551 devices unloaded\n", found);\r\n}
