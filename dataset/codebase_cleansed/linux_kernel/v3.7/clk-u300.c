static void syscon_block_reset_enable(struct clk_syscon *sclk)\r\n{\r\nunsigned long iflags;\r\nu16 val;\r\nif (!sclk->res_reg)\r\nreturn;\r\nspin_lock_irqsave(&syscon_resetreg_lock, iflags);\r\nval = readw(sclk->res_reg);\r\nval |= BIT(sclk->res_bit);\r\nwritew(val, sclk->res_reg);\r\nspin_unlock_irqrestore(&syscon_resetreg_lock, iflags);\r\nsclk->reset = true;\r\n}\r\nstatic void syscon_block_reset_disable(struct clk_syscon *sclk)\r\n{\r\nunsigned long iflags;\r\nu16 val;\r\nif (!sclk->res_reg)\r\nreturn;\r\nspin_lock_irqsave(&syscon_resetreg_lock, iflags);\r\nval = readw(sclk->res_reg);\r\nval &= ~BIT(sclk->res_bit);\r\nwritew(val, sclk->res_reg);\r\nspin_unlock_irqrestore(&syscon_resetreg_lock, iflags);\r\nsclk->reset = false;\r\n}\r\nstatic int syscon_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nif (sclk->reset)\r\nsyscon_block_reset_disable(sclk);\r\nreturn 0;\r\n}\r\nstatic void syscon_clk_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nif (sclk->clk_val == U300_SYSCON_SBCER_UART_CLK_EN)\r\nreturn;\r\nif (!sclk->reset)\r\nsyscon_block_reset_enable(sclk);\r\n}\r\nstatic int syscon_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nif (sclk->hw_ctrld)\r\nreturn 0;\r\nif (sclk->clk_val == 0xFFFFU)\r\nreturn 0;\r\nwritew(sclk->clk_val, syscon_vbase + U300_SYSCON_SBCER);\r\nreturn 0;\r\n}\r\nstatic void syscon_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nif (sclk->hw_ctrld)\r\nreturn;\r\nif (sclk->clk_val == 0xFFFFU)\r\nreturn;\r\nif (sclk->clk_val == U300_SYSCON_SBCER_UART_CLK_EN)\r\nreturn;\r\nwritew(sclk->clk_val, syscon_vbase + U300_SYSCON_SBCDR);\r\n}\r\nstatic int syscon_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nu16 val;\r\nif (!sclk->en_reg)\r\nreturn 1;\r\nval = readw(sclk->en_reg);\r\nval &= BIT(sclk->en_bit);\r\nreturn val ? 1 : 0;\r\n}\r\nstatic u16 syscon_get_perf(void)\r\n{\r\nu16 val;\r\nval = readw(syscon_vbase + U300_SYSCON_CCR);\r\nval &= U300_SYSCON_CCR_CLKING_PERFORMANCE_MASK;\r\nreturn val;\r\n}\r\nstatic unsigned long\r\nsyscon_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nu16 perf = syscon_get_perf();\r\nswitch(sclk->clk_val) {\r\ncase U300_SYSCON_SBCER_FAST_BRIDGE_CLK_EN:\r\ncase U300_SYSCON_SBCER_I2C0_CLK_EN:\r\ncase U300_SYSCON_SBCER_I2C1_CLK_EN:\r\ncase U300_SYSCON_SBCER_MMC_CLK_EN:\r\ncase U300_SYSCON_SBCER_SPI_CLK_EN:\r\nswitch(perf) {\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW_POWER:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW:\r\nreturn 13000000;\r\ndefault:\r\nreturn parent_rate;\r\n}\r\ncase U300_SYSCON_SBCER_DMAC_CLK_EN:\r\ncase U300_SYSCON_SBCER_NANDIF_CLK_EN:\r\ncase U300_SYSCON_SBCER_XGAM_CLK_EN:\r\nswitch(perf) {\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW_POWER:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW:\r\nreturn 6500000;\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_INTERMEDIATE:\r\nreturn 26000000;\r\ndefault:\r\nreturn parent_rate;\r\n}\r\ncase U300_SYSCON_SBCER_SEMI_CLK_EN:\r\ncase U300_SYSCON_SBCER_EMIF_CLK_EN:\r\nswitch(perf) {\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW_POWER:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW:\r\nreturn 13000000;\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_INTERMEDIATE:\r\nreturn 52000000;\r\ndefault:\r\nreturn 104000000;\r\n}\r\ncase U300_SYSCON_SBCER_CPU_CLK_EN:\r\nswitch(perf) {\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW_POWER:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW:\r\nreturn 13000000;\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_INTERMEDIATE:\r\nreturn 52000000;\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_HIGH:\r\nreturn 104000000;\r\ndefault:\r\nreturn parent_rate;\r\n}\r\ndefault:\r\nreturn parent_rate;\r\n}\r\n}\r\nstatic long\r\nsyscon_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nif (sclk->clk_val != U300_SYSCON_SBCER_CPU_CLK_EN)\r\nreturn *prate;\r\nif (rate <= 13000000)\r\nreturn 13000000;\r\nif (rate <= 52000000)\r\nreturn 52000000;\r\nif (rate <= 104000000)\r\nreturn 104000000;\r\nreturn 208000000;\r\n}\r\nstatic int syscon_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nu16 val;\r\nif (sclk->clk_val != U300_SYSCON_SBCER_CPU_CLK_EN)\r\nreturn -EINVAL;\r\nswitch (rate) {\r\ncase 13000000:\r\nval = U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW_POWER;\r\nbreak;\r\ncase 52000000:\r\nval = U300_SYSCON_CCR_CLKING_PERFORMANCE_INTERMEDIATE;\r\nbreak;\r\ncase 104000000:\r\nval = U300_SYSCON_CCR_CLKING_PERFORMANCE_HIGH;\r\nbreak;\r\ncase 208000000:\r\nval = U300_SYSCON_CCR_CLKING_PERFORMANCE_BEST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval |= readw(syscon_vbase + U300_SYSCON_CCR) &\r\n~U300_SYSCON_CCR_CLKING_PERFORMANCE_MASK ;\r\nwritew(val, syscon_vbase + U300_SYSCON_CCR);\r\nreturn 0;\r\n}\r\nstatic struct clk * __init\r\nsyscon_clk_register(struct device *dev, const char *name,\r\nconst char *parent_name, unsigned long flags,\r\nbool hw_ctrld,\r\nvoid __iomem *res_reg, u8 res_bit,\r\nvoid __iomem *en_reg, u8 en_bit,\r\nu16 clk_val)\r\n{\r\nstruct clk *clk;\r\nstruct clk_syscon *sclk;\r\nstruct clk_init_data init;\r\nsclk = kzalloc(sizeof(struct clk_syscon), GFP_KERNEL);\r\nif (!sclk) {\r\npr_err("could not allocate syscon clock %s\n",\r\nname);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &syscon_clk_ops;\r\ninit.flags = flags;\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\nsclk->hw.init = &init;\r\nsclk->hw_ctrld = hw_ctrld;\r\nsclk->reset = true;\r\nsclk->res_reg = res_reg;\r\nsclk->res_bit = res_bit;\r\nsclk->en_reg = en_reg;\r\nsclk->en_bit = en_bit;\r\nsclk->clk_val = clk_val;\r\nclk = clk_register(dev, &sclk->hw);\r\nif (IS_ERR(clk))\r\nkfree(sclk);\r\nreturn clk;\r\n}\r\nstatic int mclk_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_mclk *mclk = to_mclk(hw);\r\nu16 val;\r\nif (!mclk->is_mspro) {\r\nwritew(0x0054U, syscon_vbase + U300_SYSCON_MMF0R);\r\nval = readw(syscon_vbase + U300_SYSCON_MMCR);\r\nval &= ~U300_SYSCON_MMCR_MMC_FB_CLK_SEL_ENABLE;\r\nval &= ~U300_SYSCON_MMCR_MSPRO_FREQSEL_ENABLE;\r\nwritew(val, syscon_vbase + U300_SYSCON_MMCR);\r\n} else {\r\nval = readw(syscon_vbase + U300_SYSCON_MMCR);\r\nval &= ~U300_SYSCON_MMCR_MMC_FB_CLK_SEL_ENABLE;\r\nval |= U300_SYSCON_MMCR_MSPRO_FREQSEL_ENABLE;\r\nwritew(val, syscon_vbase + U300_SYSCON_MMCR);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long\r\nmclk_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nu16 perf = syscon_get_perf();\r\nswitch (perf) {\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW_POWER:\r\nreturn 13000000;\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_INTERMEDIATE:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_HIGH:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_BEST:\r\n{\r\nu16 val = readw(syscon_vbase + U300_SYSCON_MMF0R) &\r\nU300_SYSCON_MMF0R_MASK;\r\nswitch (val) {\r\ncase 0x0054:\r\nreturn 18900000;\r\ncase 0x0044:\r\nreturn 20800000;\r\ncase 0x0043:\r\nreturn 23100000;\r\ncase 0x0033:\r\nreturn 26000000;\r\ncase 0x0032:\r\nreturn 29700000;\r\ncase 0x0022:\r\nreturn 34700000;\r\ncase 0x0021:\r\nreturn 41600000;\r\ncase 0x0011:\r\nreturn 52000000;\r\ncase 0x0000:\r\nreturn 104000000;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn parent_rate;\r\n}\r\nstatic long\r\nmclk_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nif (rate <= 18900000)\r\nreturn 18900000;\r\nif (rate <= 20800000)\r\nreturn 20800000;\r\nif (rate <= 23100000)\r\nreturn 23100000;\r\nif (rate <= 26000000)\r\nreturn 26000000;\r\nif (rate <= 29700000)\r\nreturn 29700000;\r\nif (rate <= 34700000)\r\nreturn 34700000;\r\nif (rate <= 41600000)\r\nreturn 41600000;\r\nreturn 52000000;\r\n}\r\nstatic int mclk_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nu16 val;\r\nu16 reg;\r\nswitch (rate) {\r\ncase 18900000:\r\nval = 0x0054;\r\nbreak;\r\ncase 20800000:\r\nval = 0x0044;\r\nbreak;\r\ncase 23100000:\r\nval = 0x0043;\r\nbreak;\r\ncase 26000000:\r\nval = 0x0033;\r\nbreak;\r\ncase 29700000:\r\nval = 0x0032;\r\nbreak;\r\ncase 34700000:\r\nval = 0x0022;\r\nbreak;\r\ncase 41600000:\r\nval = 0x0021;\r\nbreak;\r\ncase 52000000:\r\nval = 0x0011;\r\nbreak;\r\ncase 104000000:\r\nval = 0x0000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreg = readw(syscon_vbase + U300_SYSCON_MMF0R) &\r\n~U300_SYSCON_MMF0R_MASK;\r\nwritew(reg | val, syscon_vbase + U300_SYSCON_MMF0R);\r\nreturn 0;\r\n}\r\nstatic struct clk * __init\r\nmclk_clk_register(struct device *dev, const char *name,\r\nconst char *parent_name, bool is_mspro)\r\n{\r\nstruct clk *clk;\r\nstruct clk_mclk *mclk;\r\nstruct clk_init_data init;\r\nmclk = kzalloc(sizeof(struct clk_mclk), GFP_KERNEL);\r\nif (!mclk) {\r\npr_err("could not allocate MMC/SD clock %s\n",\r\nname);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = "mclk";\r\ninit.ops = &mclk_ops;\r\ninit.flags = 0;\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\nmclk->hw.init = &init;\r\nmclk->is_mspro = is_mspro;\r\nclk = clk_register(dev, &mclk->hw);\r\nif (IS_ERR(clk))\r\nkfree(mclk);\r\nreturn clk;\r\n}\r\nvoid __init u300_clk_init(void __iomem *base)\r\n{\r\nu16 val;\r\nstruct clk *clk;\r\nsyscon_vbase = base;\r\nval = readw(syscon_vbase + U300_SYSCON_CCR);\r\nval &= ~U300_SYSCON_CCR_CLKING_PERFORMANCE_MASK;\r\nwritew(val, syscon_vbase + U300_SYSCON_CCR);\r\nwhile (!(readw(syscon_vbase + U300_SYSCON_CSR) &\r\nU300_SYSCON_CSR_PLL208_LOCK_IND));\r\nval = readw(syscon_vbase + U300_SYSCON_PMCR);\r\nval |= U300_SYSCON_PMCR_PWR_MGNT_ENABLE;\r\nwritew(val, syscon_vbase + U300_SYSCON_PMCR);\r\nclk = clk_register_fixed_rate(NULL, "app_32_clk", NULL,\r\nCLK_IS_ROOT, 32768);\r\nclk_register_clkdev(clk, NULL, "coh901327_wdog");\r\nclk = clk_register_fixed_rate(NULL, "pll13", NULL,\r\nCLK_IS_ROOT, 13000000);\r\nclk = clk_register_fixed_rate(NULL, "pll208", NULL,\r\nCLK_IS_ROOT, 208000000);\r\nclk = clk_register_fixed_factor(NULL, "app_208_clk", "pll208",\r\n0, 1, 1);\r\nclk = clk_register_fixed_factor(NULL, "app_104_clk", "pll208",\r\n0, 1, 2);\r\nclk = clk_register_fixed_factor(NULL, "app_52_clk", "pll208",\r\n0, 1, 4);\r\nclk = clk_register_fixed_factor(NULL, "app_26_clk", "app_52_clk",\r\n0, 1, 2);\r\nclk = syscon_clk_register(NULL, "cpu_clk", "app_208_clk", 0, true,\r\nsyscon_vbase + U300_SYSCON_RRR, 3,\r\nsyscon_vbase + U300_SYSCON_CERR, 3,\r\nU300_SYSCON_SBCER_CPU_CLK_EN);\r\nclk = syscon_clk_register(NULL, "dmac_clk", "app_52_clk", 0, true,\r\nsyscon_vbase + U300_SYSCON_RRR, 4,\r\nsyscon_vbase + U300_SYSCON_CERR, 4,\r\nU300_SYSCON_SBCER_DMAC_CLK_EN);\r\nclk_register_clkdev(clk, NULL, "dma");\r\nclk = syscon_clk_register(NULL, "fsmc_clk", "app_52_clk", 0, false,\r\nsyscon_vbase + U300_SYSCON_RRR, 6,\r\nsyscon_vbase + U300_SYSCON_CERR, 6,\r\nU300_SYSCON_SBCER_NANDIF_CLK_EN);\r\nclk_register_clkdev(clk, NULL, "fsmc-nand");\r\nclk = syscon_clk_register(NULL, "xgam_clk", "app_52_clk", 0, true,\r\nsyscon_vbase + U300_SYSCON_RRR, 8,\r\nsyscon_vbase + U300_SYSCON_CERR, 8,\r\nU300_SYSCON_SBCER_XGAM_CLK_EN);\r\nclk_register_clkdev(clk, NULL, "xgam");\r\nclk = syscon_clk_register(NULL, "semi_clk", "app_104_clk", 0, false,\r\nsyscon_vbase + U300_SYSCON_RRR, 9,\r\nsyscon_vbase + U300_SYSCON_CERR, 9,\r\nU300_SYSCON_SBCER_SEMI_CLK_EN);\r\nclk_register_clkdev(clk, NULL, "semi");\r\nclk = syscon_clk_register(NULL, "ahb_subsys_clk", "app_52_clk", 0, true,\r\nsyscon_vbase + U300_SYSCON_RRR, 10,\r\nsyscon_vbase + U300_SYSCON_CERR, 10,\r\nU300_SYSCON_SBCER_AHB_SUBSYS_BRIDGE_CLK_EN);\r\nclk = syscon_clk_register(NULL, "intcon_clk", "ahb_subsys_clk", 0, false,\r\nsyscon_vbase + U300_SYSCON_RRR, 12,\r\nsyscon_vbase + U300_SYSCON_CERR, 12,\r\n0xFFFFU);\r\nclk_register_clkdev(clk, NULL, "intcon");\r\nclk = syscon_clk_register(NULL, "emif_clk", "ahb_subsys_clk", 0, false,\r\nsyscon_vbase + U300_SYSCON_RRR, 5,\r\nsyscon_vbase + U300_SYSCON_CERR, 5,\r\nU300_SYSCON_SBCER_EMIF_CLK_EN);\r\nclk_register_clkdev(clk, NULL, "pl172");\r\nclk = syscon_clk_register(NULL, "fast_clk", "app_26_clk", 0, true,\r\nsyscon_vbase + U300_SYSCON_RFR, 0,\r\nsyscon_vbase + U300_SYSCON_CEFR, 0,\r\nU300_SYSCON_SBCER_FAST_BRIDGE_CLK_EN);\r\nclk = syscon_clk_register(NULL, "i2c0_p_clk", "fast_clk", 0, false,\r\nsyscon_vbase + U300_SYSCON_RFR, 1,\r\nsyscon_vbase + U300_SYSCON_CEFR, 1,\r\nU300_SYSCON_SBCER_I2C0_CLK_EN);\r\nclk_register_clkdev(clk, NULL, "stu300.0");\r\nclk = syscon_clk_register(NULL, "i2c1_p_clk", "fast_clk", 0, false,\r\nsyscon_vbase + U300_SYSCON_RFR, 2,\r\nsyscon_vbase + U300_SYSCON_CEFR, 2,\r\nU300_SYSCON_SBCER_I2C1_CLK_EN);\r\nclk_register_clkdev(clk, NULL, "stu300.1");\r\nclk = syscon_clk_register(NULL, "mmc_p_clk", "fast_clk", 0, false,\r\nsyscon_vbase + U300_SYSCON_RFR, 5,\r\nsyscon_vbase + U300_SYSCON_CEFR, 5,\r\nU300_SYSCON_SBCER_MMC_CLK_EN);\r\nclk_register_clkdev(clk, "apb_pclk", "mmci");\r\nclk = syscon_clk_register(NULL, "spi_p_clk", "fast_clk", 0, false,\r\nsyscon_vbase + U300_SYSCON_RFR, 6,\r\nsyscon_vbase + U300_SYSCON_CEFR, 6,\r\nU300_SYSCON_SBCER_SPI_CLK_EN);\r\nclk_register_clkdev(clk, NULL, "pl022");\r\nclk_register_clkdev(clk, "apb_pclk", "pl022");\r\nclk = syscon_clk_register(NULL, "slow_clk", "pll13", 0, true,\r\nsyscon_vbase + U300_SYSCON_RSR, 0,\r\nsyscon_vbase + U300_SYSCON_CESR, 0,\r\nU300_SYSCON_SBCER_SLOW_BRIDGE_CLK_EN);\r\nclk = syscon_clk_register(NULL, "uart0_clk", "slow_clk", 0, false,\r\nsyscon_vbase + U300_SYSCON_RSR, 1,\r\nsyscon_vbase + U300_SYSCON_CESR, 1,\r\nU300_SYSCON_SBCER_UART_CLK_EN);\r\nclk_register_clkdev(clk, NULL, "uart0");\r\nclk_register_clkdev(clk, "apb_pclk", "uart0");\r\nclk = syscon_clk_register(NULL, "gpio_clk", "slow_clk", 0, false,\r\nsyscon_vbase + U300_SYSCON_RSR, 4,\r\nsyscon_vbase + U300_SYSCON_CESR, 4,\r\nU300_SYSCON_SBCER_GPIO_CLK_EN);\r\nclk_register_clkdev(clk, NULL, "u300-gpio");\r\nclk = syscon_clk_register(NULL, "keypad_clk", "slow_clk", 0, false,\r\nsyscon_vbase + U300_SYSCON_RSR, 5,\r\nsyscon_vbase + U300_SYSCON_CESR, 6,\r\nU300_SYSCON_SBCER_KEYPAD_CLK_EN);\r\nclk_register_clkdev(clk, NULL, "coh901461-keypad");\r\nclk = syscon_clk_register(NULL, "rtc_clk", "slow_clk", 0, true,\r\nsyscon_vbase + U300_SYSCON_RSR, 6,\r\nNULL, 0, 0xFFFFU);\r\nclk_register_clkdev(clk, NULL, "rtc-coh901331");\r\nclk = syscon_clk_register(NULL, "app_tmr_clk", "slow_clk", 0, false,\r\nsyscon_vbase + U300_SYSCON_RSR, 7,\r\nsyscon_vbase + U300_SYSCON_CESR, 7,\r\nU300_SYSCON_SBCER_APP_TMR_CLK_EN);\r\nclk_register_clkdev(clk, NULL, "apptimer");\r\nclk = syscon_clk_register(NULL, "acc_tmr_clk", "slow_clk", 0, false,\r\nsyscon_vbase + U300_SYSCON_RSR, 8,\r\nsyscon_vbase + U300_SYSCON_CESR, 8,\r\nU300_SYSCON_SBCER_ACC_TMR_CLK_EN);\r\nclk_register_clkdev(clk, NULL, "timer");\r\nclk = mclk_clk_register(NULL, "mmc_clk", "mmc_p_clk", false);\r\nclk_register_clkdev(clk, NULL, "mmci");\r\n}
