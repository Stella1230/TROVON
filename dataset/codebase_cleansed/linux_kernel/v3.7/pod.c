static void pod_mark_batch_all_dirty(struct usb_line6_pod *pod)\r\n{\r\nint i;\r\nfor (i = 0; i < POD_CONTROL_SIZE; i++)\r\nset_bit(i, pod->param_dirty);\r\n}\r\nstatic char *pod_alloc_sysex_buffer(struct usb_line6_pod *pod, int code,\r\nint size)\r\n{\r\nreturn line6_alloc_sysex_buffer(&pod->line6, POD_SYSEX_CODE, code,\r\nsize);\r\n}\r\nstatic void pod_dump(struct usb_line6_pod *pod, const unsigned char *data)\r\n{\r\nint size = 1 + sizeof(pod->prog_data);\r\nchar *sysex = pod_alloc_sysex_buffer(pod, POD_SYSEX_DUMP, size);\r\nif (!sysex)\r\nreturn;\r\nsysex[SYSEX_DATA_OFS] = 5;\r\nmemcpy(sysex + SYSEX_DATA_OFS + 1, data, sizeof(pod->prog_data));\r\nline6_send_sysex_message(&pod->line6, sysex, size);\r\nmemcpy(&pod->prog_data, data, sizeof(pod->prog_data));\r\npod_mark_batch_all_dirty(pod);\r\nkfree(sysex);\r\n}\r\nstatic void pod_store_parameter(struct usb_line6_pod *pod, int param, int value)\r\n{\r\npod->prog_data.control[param] = value;\r\nset_bit(param, pod->param_dirty);\r\npod->dirty = 1;\r\n}\r\nstatic void pod_save_button_pressed(struct usb_line6_pod *pod, int type,\r\nint index)\r\n{\r\npod->dirty = 0;\r\nset_bit(POD_SAVE_PRESSED, &pod->atomic_flags);\r\n}\r\nvoid line6_pod_process_message(struct usb_line6_pod *pod)\r\n{\r\nconst unsigned char *buf = pod->line6.buffer_message;\r\nswitch (buf[0] & 0xf0) {\r\ncase LINE6_PARAM_CHANGE:\r\ncase LINE6_PROGRAM_CHANGE:\r\ncase LINE6_SYSEX_BEGIN:\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nswitch (buf[0]) {\r\ncase LINE6_PARAM_CHANGE | LINE6_CHANNEL_DEVICE:\r\npod_store_parameter(pod, buf[1], buf[2]);\r\ncase LINE6_PARAM_CHANGE | LINE6_CHANNEL_HOST:\r\nif ((buf[1] == POD_amp_model_setup) ||\r\n(buf[1] == POD_effect_setup))\r\nline6_dump_request_async(&pod->dumpreq, &pod->line6, 0,\r\nLINE6_DUMP_CURRENT);\r\nbreak;\r\ncase LINE6_PROGRAM_CHANGE | LINE6_CHANNEL_DEVICE:\r\ncase LINE6_PROGRAM_CHANGE | LINE6_CHANNEL_HOST:\r\npod->channel_num = buf[1];\r\npod->dirty = 0;\r\nset_bit(POD_CHANNEL_DIRTY, &pod->atomic_flags);\r\nline6_dump_request_async(&pod->dumpreq, &pod->line6, 0,\r\nLINE6_DUMP_CURRENT);\r\nbreak;\r\ncase LINE6_SYSEX_BEGIN | LINE6_CHANNEL_DEVICE:\r\ncase LINE6_SYSEX_BEGIN | LINE6_CHANNEL_UNKNOWN:\r\nif (memcmp(buf + 1, line6_midi_id, sizeof(line6_midi_id)) == 0) {\r\nswitch (buf[5]) {\r\ncase POD_SYSEX_DUMP:\r\nif (pod->line6.message_length ==\r\nsizeof(pod->prog_data) + 7) {\r\nswitch (pod->dumpreq.in_progress) {\r\ncase LINE6_DUMP_CURRENT:\r\nmemcpy(&pod->prog_data, buf + 7,\r\nsizeof(pod->prog_data));\r\npod_mark_batch_all_dirty(pod);\r\nbreak;\r\ncase POD_DUMP_MEMORY:\r\nmemcpy(&pod->prog_data_buf,\r\nbuf + 7,\r\nsizeof\r\n(pod->prog_data_buf));\r\nbreak;\r\ndefault:\r\nDEBUG_MESSAGES(dev_err\r\n(pod->\r\nline6.ifcdev,\r\n"unknown dump code %02X\n",\r\npod->\r\ndumpreq.in_progress));\r\n}\r\nline6_dump_finished(&pod->dumpreq);\r\npod_startup3(pod);\r\n} else\r\nDEBUG_MESSAGES(dev_err\r\n(pod->line6.ifcdev,\r\n"wrong size of channel dump message (%d instead of %d)\n",\r\npod->\r\nline6.message_length,\r\n(int)\r\nsizeof(pod->prog_data) +\r\n7));\r\nbreak;\r\ncase POD_SYSEX_SYSTEM:{\r\nshort value =\r\n((int)buf[7] << 12) | ((int)buf[8]\r\n<< 8) |\r\n((int)buf[9] << 4) | (int)buf[10];\r\n#define PROCESS_SYSTEM_PARAM(x) \\r\ncase POD_ ## x: \\r\npod->x.value = value; \\r\nwake_up(&pod->x.wait); \\r\nbreak;\r\nswitch (buf[6]) {\r\nPROCESS_SYSTEM_PARAM\r\n(monitor_level);\r\nPROCESS_SYSTEM_PARAM(routing);\r\nPROCESS_SYSTEM_PARAM\r\n(tuner_mute);\r\nPROCESS_SYSTEM_PARAM\r\n(tuner_freq);\r\nPROCESS_SYSTEM_PARAM\r\n(tuner_note);\r\nPROCESS_SYSTEM_PARAM\r\n(tuner_pitch);\r\n#undef PROCESS_SYSTEM_PARAM\r\ndefault:\r\nDEBUG_MESSAGES(dev_err\r\n(pod->\r\nline6.ifcdev,\r\n"unknown tuner/system response %02X\n",\r\nbuf[6]));\r\n}\r\nbreak;\r\n}\r\ncase POD_SYSEX_FINISH:\r\nbreak;\r\ncase POD_SYSEX_SAVE:\r\npod_save_button_pressed(pod, buf[6], buf[7]);\r\nbreak;\r\ncase POD_SYSEX_CLIP:\r\nDEBUG_MESSAGES(dev_err\r\n(pod->line6.ifcdev,\r\n"audio clipped\n"));\r\npod->clipping.value = 1;\r\nwake_up(&pod->clipping.wait);\r\nbreak;\r\ncase POD_SYSEX_STORE:\r\nDEBUG_MESSAGES(dev_err\r\n(pod->line6.ifcdev,\r\n"message %02X not yet implemented\n",\r\nbuf[5]));\r\nbreak;\r\ndefault:\r\nDEBUG_MESSAGES(dev_err\r\n(pod->line6.ifcdev,\r\n"unknown sysex message %02X\n",\r\nbuf[5]));\r\n}\r\n} else\r\nif (memcmp\r\n(buf, pod_version_header,\r\nsizeof(pod_version_header)) == 0) {\r\npod->firmware_version =\r\nbuf[13] * 100 + buf[14] * 10 + buf[15];\r\npod->device_id =\r\n((int)buf[8] << 16) | ((int)buf[9] << 8) | (int)\r\nbuf[10];\r\npod_startup4(pod);\r\n} else\r\nDEBUG_MESSAGES(dev_err\r\n(pod->line6.ifcdev,\r\n"unknown sysex header\n"));\r\nbreak;\r\ncase LINE6_SYSEX_END:\r\nbreak;\r\ndefault:\r\nDEBUG_MESSAGES(dev_err\r\n(pod->line6.ifcdev,\r\n"POD: unknown message %02X\n", buf[0]));\r\n}\r\n}\r\nvoid line6_pod_midi_postprocess(struct usb_line6_pod *pod, unsigned char *data,\r\nint length)\r\n{\r\nint i;\r\nif (!pod->midi_postprocess)\r\nreturn;\r\nfor (i = 0; i < length; ++i) {\r\nif (data[i] == (LINE6_PROGRAM_CHANGE | LINE6_CHANNEL_HOST)) {\r\nline6_invalidate_current(&pod->dumpreq);\r\nbreak;\r\n} else\r\nif ((data[i] == (LINE6_PARAM_CHANGE | LINE6_CHANNEL_HOST))\r\n&& (i < length - 1))\r\nif ((data[i + 1] == POD_amp_model_setup)\r\n|| (data[i + 1] == POD_effect_setup)) {\r\nline6_invalidate_current(&pod->dumpreq);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void pod_send_channel(struct usb_line6_pod *pod, u8 value)\r\n{\r\nline6_invalidate_current(&pod->dumpreq);\r\nif (line6_send_program(&pod->line6, value) == 0)\r\npod->channel_num = value;\r\nelse\r\nline6_dump_finished(&pod->dumpreq);\r\n}\r\nvoid line6_pod_transmit_parameter(struct usb_line6_pod *pod, int param,\r\nu8 value)\r\n{\r\nif (line6_transmit_parameter(&pod->line6, param, value) == 0)\r\npod_store_parameter(pod, param, value);\r\nif ((param == POD_amp_model_setup) || (param == POD_effect_setup))\r\nline6_invalidate_current(&pod->dumpreq);\r\n}\r\nstatic int pod_resolve(const char *buf, short block0, short block1,\r\nunsigned char *location)\r\n{\r\nu8 value;\r\nshort block;\r\nint ret;\r\nret = kstrtou8(buf, 10, &value);\r\nif (ret)\r\nreturn ret;\r\nblock = (value < 0x40) ? block0 : block1;\r\nvalue &= 0x3f;\r\nlocation[0] = block >> 7;\r\nlocation[1] = value | (block & 0x7f);\r\nreturn 0;\r\n}\r\nstatic ssize_t pod_send_store_command(struct device *dev, const char *buf,\r\nsize_t count, short block0, short block1)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nint ret;\r\nint size = 3 + sizeof(pod->prog_data_buf);\r\nchar *sysex = pod_alloc_sysex_buffer(pod, POD_SYSEX_STORE, size);\r\nif (!sysex)\r\nreturn 0;\r\nsysex[SYSEX_DATA_OFS] = 5;\r\nret = pod_resolve(buf, block0, block1, sysex + SYSEX_DATA_OFS + 1);\r\nif (ret) {\r\nkfree(sysex);\r\nreturn ret;\r\n}\r\nmemcpy(sysex + SYSEX_DATA_OFS + 3, &pod->prog_data_buf,\r\nsizeof(pod->prog_data_buf));\r\nline6_send_sysex_message(&pod->line6, sysex, size);\r\nkfree(sysex);\r\nreturn count;\r\n}\r\nstatic ssize_t pod_send_retrieve_command(struct device *dev, const char *buf,\r\nsize_t count, short block0,\r\nshort block1)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nint ret;\r\nint size = 4;\r\nchar *sysex = pod_alloc_sysex_buffer(pod, POD_SYSEX_DUMPMEM, size);\r\nif (!sysex)\r\nreturn 0;\r\nret = pod_resolve(buf, block0, block1, sysex + SYSEX_DATA_OFS);\r\nif (ret) {\r\nkfree(sysex);\r\nreturn ret;\r\n}\r\nsysex[SYSEX_DATA_OFS + 2] = 0;\r\nsysex[SYSEX_DATA_OFS + 3] = 0;\r\nline6_dump_started(&pod->dumpreq, POD_DUMP_MEMORY);\r\nif (line6_send_sysex_message(&pod->line6, sysex, size) < size)\r\nline6_dump_finished(&pod->dumpreq);\r\nkfree(sysex);\r\nreturn count;\r\n}\r\nstatic ssize_t get_name_generic(struct usb_line6_pod *pod, const char *str,\r\nchar *buf)\r\n{\r\nint length = 0;\r\nconst char *p1;\r\nchar *p2;\r\nchar *last_non_space = buf;\r\nint retval = line6_dump_wait_interruptible(&pod->dumpreq);\r\nif (retval < 0)\r\nreturn retval;\r\nfor (p1 = str, p2 = buf; *p1; ++p1, ++p2) {\r\n*p2 = *p1;\r\nif (*p2 != ' ')\r\nlast_non_space = p2;\r\nif (++length == POD_NAME_LENGTH)\r\nbreak;\r\n}\r\n*(last_non_space + 1) = '\n';\r\nreturn last_non_space - buf + 2;\r\n}\r\nstatic ssize_t pod_get_channel(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nreturn sprintf(buf, "%d\n", pod->channel_num);\r\n}\r\nstatic ssize_t pod_set_channel(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nu8 value;\r\nint ret;\r\nret = kstrtou8(buf, 10, &value);\r\nif (ret)\r\nreturn ret;\r\npod_send_channel(pod, value);\r\nreturn count;\r\n}\r\nstatic ssize_t pod_get_name(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nreturn get_name_generic(pod, pod->prog_data.header + POD_NAME_OFFSET,\r\nbuf);\r\n}\r\nstatic ssize_t pod_get_name_buf(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nreturn get_name_generic(pod,\r\npod->prog_data_buf.header + POD_NAME_OFFSET,\r\nbuf);\r\n}\r\nstatic ssize_t pod_get_dump(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nint retval = line6_dump_wait_interruptible(&pod->dumpreq);\r\nif (retval < 0)\r\nreturn retval;\r\nmemcpy(buf, &pod->prog_data, sizeof(pod->prog_data));\r\nreturn sizeof(pod->prog_data);\r\n}\r\nstatic ssize_t pod_set_dump(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nif (count != sizeof(pod->prog_data)) {\r\ndev_err(pod->line6.ifcdev,\r\n"data block must be exactly %d bytes\n",\r\n(int)sizeof(pod->prog_data));\r\nreturn -EINVAL;\r\n}\r\npod_dump(pod, buf);\r\nreturn sizeof(pod->prog_data);\r\n}\r\nstatic bool pod_is_tuner(int code)\r\n{\r\nreturn\r\n(code == POD_tuner_mute) ||\r\n(code == POD_tuner_freq) ||\r\n(code == POD_tuner_note) || (code == POD_tuner_pitch);\r\n}\r\nstatic int pod_get_system_param_int(struct usb_line6_pod *pod, int *value,\r\nint code, struct ValueWait *param, int sign)\r\n{\r\nchar *sysex;\r\nstatic const int size = 1;\r\nint retval = 0;\r\nif (((pod->prog_data.control[POD_tuner] & 0x40) == 0)\r\n&& pod_is_tuner(code))\r\nreturn -ENODEV;\r\nparam->value = POD_system_invalid;\r\nsysex = pod_alloc_sysex_buffer(pod, POD_SYSEX_SYSTEMREQ, size);\r\nif (!sysex)\r\nreturn -ENOMEM;\r\nsysex[SYSEX_DATA_OFS] = code;\r\nline6_send_sysex_message(&pod->line6, sysex, size);\r\nkfree(sysex);\r\nretval =\r\nwait_event_interruptible(param->wait,\r\nparam->value != POD_system_invalid);\r\nif (retval < 0)\r\nreturn retval;\r\n*value = sign ? (int)(signed short)param->value : (int)(unsigned short)\r\nparam->value;\r\nif (*value == POD_system_invalid)\r\n*value = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t pod_get_system_param_string(struct usb_line6_pod *pod, char *buf,\r\nint code, struct ValueWait *param,\r\nint sign)\r\n{\r\nint retval, value = 0;\r\nretval = pod_get_system_param_int(pod, &value, code, param, sign);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic int pod_set_system_param_int(struct usb_line6_pod *pod, int value,\r\nint code)\r\n{\r\nchar *sysex;\r\nstatic const int size = 5;\r\nif (((pod->prog_data.control[POD_tuner] & 0x40) == 0)\r\n&& pod_is_tuner(code))\r\nreturn -EINVAL;\r\nsysex = pod_alloc_sysex_buffer(pod, POD_SYSEX_SYSTEM, size);\r\nif (!sysex)\r\nreturn -ENOMEM;\r\nsysex[SYSEX_DATA_OFS] = code;\r\nsysex[SYSEX_DATA_OFS + 1] = (value >> 12) & 0x0f;\r\nsysex[SYSEX_DATA_OFS + 2] = (value >> 8) & 0x0f;\r\nsysex[SYSEX_DATA_OFS + 3] = (value >> 4) & 0x0f;\r\nsysex[SYSEX_DATA_OFS + 4] = (value) & 0x0f;\r\nline6_send_sysex_message(&pod->line6, sysex, size);\r\nkfree(sysex);\r\nreturn 0;\r\n}\r\nstatic ssize_t pod_set_system_param_string(struct usb_line6_pod *pod,\r\nconst char *buf, int count, int code,\r\nunsigned short mask)\r\n{\r\nint retval;\r\nunsigned short value = simple_strtoul(buf, NULL, 10) & mask;\r\nretval = pod_set_system_param_int(pod, value, code);\r\nreturn (retval < 0) ? retval : count;\r\n}\r\nstatic ssize_t pod_get_dump_buf(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nint retval = line6_dump_wait_interruptible(&pod->dumpreq);\r\nif (retval < 0)\r\nreturn retval;\r\nmemcpy(buf, &pod->prog_data_buf, sizeof(pod->prog_data_buf));\r\nreturn sizeof(pod->prog_data_buf);\r\n}\r\nstatic ssize_t pod_set_dump_buf(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nif (count != sizeof(pod->prog_data)) {\r\ndev_err(pod->line6.ifcdev,\r\n"data block must be exactly %d bytes\n",\r\n(int)sizeof(pod->prog_data));\r\nreturn -EINVAL;\r\n}\r\nmemcpy(&pod->prog_data_buf, buf, sizeof(pod->prog_data));\r\nreturn sizeof(pod->prog_data);\r\n}\r\nstatic ssize_t pod_set_finish(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nint size = 0;\r\nchar *sysex = pod_alloc_sysex_buffer(pod, POD_SYSEX_FINISH, size);\r\nif (!sysex)\r\nreturn 0;\r\nline6_send_sysex_message(&pod->line6, sysex, size);\r\nkfree(sysex);\r\nreturn count;\r\n}\r\nstatic ssize_t pod_set_store_channel(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn pod_send_store_command(dev, buf, count, 0x0000, 0x00c0);\r\n}\r\nstatic ssize_t pod_set_store_effects_setup(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn pod_send_store_command(dev, buf, count, 0x0080, 0x0080);\r\n}\r\nstatic ssize_t pod_set_store_amp_setup(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn pod_send_store_command(dev, buf, count, 0x0040, 0x0100);\r\n}\r\nstatic ssize_t pod_set_retrieve_channel(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn pod_send_retrieve_command(dev, buf, count, 0x0000, 0x00c0);\r\n}\r\nstatic ssize_t pod_set_retrieve_effects_setup(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn pod_send_retrieve_command(dev, buf, count, 0x0080, 0x0080);\r\n}\r\nstatic ssize_t pod_set_retrieve_amp_setup(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn pod_send_retrieve_command(dev, buf, count, 0x0040, 0x0100);\r\n}\r\nstatic ssize_t pod_get_dirty(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nbuf[0] = pod->dirty ? '1' : '0';\r\nbuf[1] = '\n';\r\nreturn 2;\r\n}\r\nstatic ssize_t pod_get_midi_postprocess(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nreturn sprintf(buf, "%d\n", pod->midi_postprocess);\r\n}\r\nstatic ssize_t pod_set_midi_postprocess(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nu8 value;\r\nint ret;\r\nret = kstrtou8(buf, 10, &value);\r\nif (ret)\r\nreturn ret;\r\npod->midi_postprocess = value ? 1 : 0;\r\nreturn count;\r\n}\r\nstatic ssize_t pod_get_serial_number(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nreturn sprintf(buf, "%d\n", pod->serial_number);\r\n}\r\nstatic ssize_t pod_get_firmware_version(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nreturn sprintf(buf, "%d.%02d\n", pod->firmware_version / 100,\r\npod->firmware_version % 100);\r\n}\r\nstatic ssize_t pod_get_device_id(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nreturn sprintf(buf, "%d\n", pod->device_id);\r\n}\r\nstatic ssize_t pod_wait_for_clip(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *interface = to_usb_interface(dev);\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nreturn wait_event_interruptible(pod->clipping.wait,\r\npod->clipping.value != 0);\r\n}\r\nstatic void pod_startup1(struct usb_line6_pod *pod)\r\n{\r\nCHECK_STARTUP_PROGRESS(pod->startup_progress, POD_STARTUP_INIT);\r\nline6_start_timer(&pod->startup_timer, POD_STARTUP_DELAY, pod_startup2,\r\n(unsigned long)pod);\r\n}\r\nstatic void pod_startup2(unsigned long data)\r\n{\r\nstruct usb_line6_pod *pod = (struct usb_line6_pod *)data;\r\nif (pod->startup_progress >= POD_STARTUP_LAST)\r\nreturn;\r\npod->startup_progress = POD_STARTUP_DUMPREQ;\r\nline6_start_timer(&pod->startup_timer, POD_STARTUP_DELAY, pod_startup2,\r\n(unsigned long)pod);\r\nline6_dump_request_async(&pod->dumpreq, &pod->line6, 0,\r\nLINE6_DUMP_CURRENT);\r\n}\r\nstatic void pod_startup3(struct usb_line6_pod *pod)\r\n{\r\nstruct usb_line6 *line6 = &pod->line6;\r\nCHECK_STARTUP_PROGRESS(pod->startup_progress, POD_STARTUP_VERSIONREQ);\r\nline6_version_request_async(line6);\r\n}\r\nstatic void pod_startup4(struct usb_line6_pod *pod)\r\n{\r\nCHECK_STARTUP_PROGRESS(pod->startup_progress, POD_STARTUP_WORKQUEUE);\r\nschedule_work(&pod->startup_work);\r\n}\r\nstatic void pod_startup5(struct work_struct *work)\r\n{\r\nstruct usb_line6_pod *pod =\r\ncontainer_of(work, struct usb_line6_pod, startup_work);\r\nstruct usb_line6 *line6 = &pod->line6;\r\nCHECK_STARTUP_PROGRESS(pod->startup_progress, POD_STARTUP_SETUP);\r\nline6_read_serial_number(&pod->line6, &pod->serial_number);\r\nline6_register_audio(line6);\r\nline6_pod_create_files(pod->firmware_version,\r\nline6->properties->device_bit, line6->ifcdev);\r\n}\r\nstatic int snd_pod_control_monitor_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 65535;\r\nreturn 0;\r\n}\r\nstatic int snd_pod_control_monitor_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\r\nstruct usb_line6_pod *pod = (struct usb_line6_pod *)line6pcm->line6;\r\nucontrol->value.integer.value[0] = pod->monitor_level.value;\r\nreturn 0;\r\n}\r\nstatic int snd_pod_control_monitor_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);\r\nstruct usb_line6_pod *pod = (struct usb_line6_pod *)line6pcm->line6;\r\nif (ucontrol->value.integer.value[0] == pod->monitor_level.value)\r\nreturn 0;\r\npod->monitor_level.value = ucontrol->value.integer.value[0];\r\npod_set_system_param_int(pod, ucontrol->value.integer.value[0],\r\nPOD_monitor_level);\r\nreturn 1;\r\n}\r\nstatic void pod_destruct(struct usb_interface *interface)\r\n{\r\nstruct usb_line6_pod *pod = usb_get_intfdata(interface);\r\nif (pod == NULL)\r\nreturn;\r\nline6_cleanup_audio(&pod->line6);\r\ndel_timer(&pod->startup_timer);\r\ncancel_work_sync(&pod->startup_work);\r\nline6_dumpreq_destruct(&pod->dumpreq);\r\n}\r\nstatic int pod_create_files2(struct device *dev)\r\n{\r\nint err;\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_channel));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_clip));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_device_id));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_dirty));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_dump));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_dump_buf));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_finish));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_firmware_version));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_midi_postprocess));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_monitor_level));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_name));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_name_buf));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_retrieve_amp_setup));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_retrieve_channel));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_retrieve_effects_setup));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_routing));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_serial_number));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_store_amp_setup));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_store_channel));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_store_effects_setup));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_tuner_freq));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_tuner_mute));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_tuner_note));\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_tuner_pitch));\r\n#ifdef CONFIG_LINE6_USB_RAW\r\nCHECK_RETURN(device_create_file(dev, &dev_attr_raw));\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int pod_try_init(struct usb_interface *interface,\r\nstruct usb_line6_pod *pod)\r\n{\r\nint err;\r\nstruct usb_line6 *line6 = &pod->line6;\r\ninit_timer(&pod->startup_timer);\r\nINIT_WORK(&pod->startup_work, pod_startup5);\r\nif ((interface == NULL) || (pod == NULL))\r\nreturn -ENODEV;\r\npod->channel_num = 255;\r\ninit_waitqueue_head(&pod->monitor_level.wait);\r\ninit_waitqueue_head(&pod->routing.wait);\r\ninit_waitqueue_head(&pod->tuner_mute.wait);\r\ninit_waitqueue_head(&pod->tuner_freq.wait);\r\ninit_waitqueue_head(&pod->tuner_note.wait);\r\ninit_waitqueue_head(&pod->tuner_pitch.wait);\r\ninit_waitqueue_head(&pod->clipping.wait);\r\nmemset(pod->param_dirty, 0xff, sizeof(pod->param_dirty));\r\nerr = line6_dumpreq_init(&pod->dumpreq, pod_request_channel,\r\nsizeof(pod_request_channel));\r\nif (err < 0) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = pod_create_files2(&interface->dev);\r\nif (err < 0)\r\nreturn err;\r\nerr = line6_init_audio(line6);\r\nif (err < 0)\r\nreturn err;\r\nerr = line6_init_midi(line6);\r\nif (err < 0)\r\nreturn err;\r\nerr = line6_init_pcm(line6, &pod_pcm_properties);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(line6->card,\r\nsnd_ctl_new1(&pod_control_monitor, line6->line6pcm));\r\nif (err < 0)\r\nreturn err;\r\nif (pod->line6.properties->capabilities & LINE6_BIT_CONTROL) {\r\npod->monitor_level.value = POD_system_invalid;\r\npod_startup1(pod);\r\n}\r\nreturn 0;\r\n}\r\nint line6_pod_init(struct usb_interface *interface, struct usb_line6_pod *pod)\r\n{\r\nint err = pod_try_init(interface, pod);\r\nif (err < 0)\r\npod_destruct(interface);\r\nreturn err;\r\n}\r\nvoid line6_pod_disconnect(struct usb_interface *interface)\r\n{\r\nstruct usb_line6_pod *pod;\r\nif (interface == NULL)\r\nreturn;\r\npod = usb_get_intfdata(interface);\r\nif (pod != NULL) {\r\nstruct snd_line6_pcm *line6pcm = pod->line6.line6pcm;\r\nstruct device *dev = &interface->dev;\r\nif (line6pcm != NULL)\r\nline6_pcm_disconnect(line6pcm);\r\nif (dev != NULL) {\r\nline6_pod_remove_files(pod->firmware_version,\r\npod->line6.\r\nproperties->device_bit, dev);\r\ndevice_remove_file(dev, &dev_attr_channel);\r\ndevice_remove_file(dev, &dev_attr_clip);\r\ndevice_remove_file(dev, &dev_attr_device_id);\r\ndevice_remove_file(dev, &dev_attr_dirty);\r\ndevice_remove_file(dev, &dev_attr_dump);\r\ndevice_remove_file(dev, &dev_attr_dump_buf);\r\ndevice_remove_file(dev, &dev_attr_finish);\r\ndevice_remove_file(dev, &dev_attr_firmware_version);\r\ndevice_remove_file(dev, &dev_attr_midi_postprocess);\r\ndevice_remove_file(dev, &dev_attr_monitor_level);\r\ndevice_remove_file(dev, &dev_attr_name);\r\ndevice_remove_file(dev, &dev_attr_name_buf);\r\ndevice_remove_file(dev, &dev_attr_retrieve_amp_setup);\r\ndevice_remove_file(dev, &dev_attr_retrieve_channel);\r\ndevice_remove_file(dev,\r\n&dev_attr_retrieve_effects_setup);\r\ndevice_remove_file(dev, &dev_attr_routing);\r\ndevice_remove_file(dev, &dev_attr_serial_number);\r\ndevice_remove_file(dev, &dev_attr_store_amp_setup);\r\ndevice_remove_file(dev, &dev_attr_store_channel);\r\ndevice_remove_file(dev, &dev_attr_store_effects_setup);\r\ndevice_remove_file(dev, &dev_attr_tuner_freq);\r\ndevice_remove_file(dev, &dev_attr_tuner_mute);\r\ndevice_remove_file(dev, &dev_attr_tuner_note);\r\ndevice_remove_file(dev, &dev_attr_tuner_pitch);\r\n#ifdef CONFIG_LINE6_USB_RAW\r\ndevice_remove_file(dev, &dev_attr_raw);\r\n#endif\r\n}\r\n}\r\npod_destruct(interface);\r\n}
