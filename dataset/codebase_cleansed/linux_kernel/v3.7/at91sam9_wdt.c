static inline void at91_wdt_reset(void)\r\n{\r\nwdt_write(AT91_WDT_CR, AT91_WDT_KEY | AT91_WDT_WDRSTT);\r\n}\r\nstatic void at91_ping(unsigned long data)\r\n{\r\nif (time_before(jiffies, at91wdt_private.next_heartbeat) ||\r\n(!nowayout && !at91wdt_private.open)) {\r\nat91_wdt_reset();\r\nmod_timer(&at91wdt_private.timer, jiffies + WDT_TIMEOUT);\r\n} else\r\npr_crit("I will reset your machine !\n");\r\n}\r\nstatic int at91_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &at91wdt_private.open))\r\nreturn -EBUSY;\r\nat91wdt_private.next_heartbeat = jiffies + heartbeat * HZ;\r\nmod_timer(&at91wdt_private.timer, jiffies + WDT_TIMEOUT);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int at91_wdt_close(struct inode *inode, struct file *file)\r\n{\r\nclear_bit(0, &at91wdt_private.open);\r\nif (!at91wdt_private.expect_close)\r\ndel_timer(&at91wdt_private.timer);\r\nat91wdt_private.expect_close = 0;\r\nreturn 0;\r\n}\r\nstatic int at91_wdt_settimeout(unsigned int timeout)\r\n{\r\nunsigned int reg;\r\nunsigned int mr;\r\nmr = wdt_read(AT91_WDT_MR);\r\nif (mr & AT91_WDT_WDDIS) {\r\npr_err("sorry, watchdog is disabled\n");\r\nreturn -EIO;\r\n}\r\nreg = AT91_WDT_WDRSTEN\r\n| AT91_WDT_WDDBGHLT\r\n| AT91_WDT_WDD\r\n| (timeout & AT91_WDT_WDV);\r\nwdt_write(AT91_WDT_MR, reg);\r\nreturn 0;\r\n}\r\nstatic long at91_wdt_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint new_value;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &at91_wdt_info,\r\nsizeof(at91_wdt_info)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_KEEPALIVE:\r\nat91wdt_private.next_heartbeat = jiffies + heartbeat * HZ;\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_value, p))\r\nreturn -EFAULT;\r\nheartbeat = new_value;\r\nat91wdt_private.next_heartbeat = jiffies + heartbeat * HZ;\r\nreturn put_user(new_value, p);\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(heartbeat, p);\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic ssize_t at91_wdt_write(struct file *file, const char *data, size_t len,\r\nloff_t *ppos)\r\n{\r\nif (!len)\r\nreturn 0;\r\nif (!nowayout) {\r\nsize_t i;\r\nat91wdt_private.expect_close = 0;\r\nfor (i = 0; i < len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V') {\r\nat91wdt_private.expect_close = 42;\r\nbreak;\r\n}\r\n}\r\n}\r\nat91wdt_private.next_heartbeat = jiffies + heartbeat * HZ;\r\nreturn len;\r\n}\r\nstatic int __init at91wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r;\r\nint res;\r\nif (at91wdt_miscdev.parent)\r\nreturn -EBUSY;\r\nat91wdt_miscdev.parent = &pdev->dev;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r)\r\nreturn -ENODEV;\r\nat91wdt_private.base = ioremap(r->start, resource_size(r));\r\nif (!at91wdt_private.base) {\r\ndev_err(&pdev->dev, "failed to map registers, aborting.\n");\r\nreturn -ENOMEM;\r\n}\r\nres = at91_wdt_settimeout(ms_to_ticks(WDT_HW_TIMEOUT * 1000));\r\nif (res)\r\nreturn res;\r\nres = misc_register(&at91wdt_miscdev);\r\nif (res)\r\nreturn res;\r\nat91wdt_private.next_heartbeat = jiffies + heartbeat * HZ;\r\nsetup_timer(&at91wdt_private.timer, at91_ping, 0);\r\nmod_timer(&at91wdt_private.timer, jiffies + WDT_TIMEOUT);\r\npr_info("enabled (heartbeat=%d sec, nowayout=%d)\n",\r\nheartbeat, nowayout);\r\nreturn 0;\r\n}\r\nstatic int __exit at91wdt_remove(struct platform_device *pdev)\r\n{\r\nint res;\r\nres = misc_deregister(&at91wdt_miscdev);\r\nif (!res)\r\nat91wdt_miscdev.parent = NULL;\r\nreturn res;\r\n}\r\nstatic int __init at91sam_wdt_init(void)\r\n{\r\nreturn platform_driver_probe(&at91wdt_driver, at91wdt_probe);\r\n}\r\nstatic void __exit at91sam_wdt_exit(void)\r\n{\r\nplatform_driver_unregister(&at91wdt_driver);\r\n}
