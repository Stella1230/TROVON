static int mic_bias_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(w->codec, SGTL5000_CHIP_MIC_CTRL,\r\nSGTL5000_BIAS_R_MASK,\r\nSGTL5000_BIAS_R_4k << SGTL5000_BIAS_R_SHIFT);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(w->codec, SGTL5000_CHIP_MIC_CTRL,\r\nSGTL5000_BIAS_R_MASK, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int power_vag_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(w->codec, SGTL5000_CHIP_ANA_POWER,\r\nSGTL5000_VAG_POWERUP, SGTL5000_VAG_POWERUP);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(w->codec, SGTL5000_CHIP_ANA_POWER,\r\nSGTL5000_VAG_POWERUP, 0);\r\nmsleep(400);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dac_info_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0xfc - 0x3c;\r\nreturn 0;\r\n}\r\nstatic int dac_get_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint reg;\r\nint l;\r\nint r;\r\nreg = snd_soc_read(codec, SGTL5000_CHIP_DAC_VOL);\r\nl = (reg & SGTL5000_DAC_VOL_LEFT_MASK) >> SGTL5000_DAC_VOL_LEFT_SHIFT;\r\nr = (reg & SGTL5000_DAC_VOL_RIGHT_MASK) >> SGTL5000_DAC_VOL_RIGHT_SHIFT;\r\nl = clamp(l, 0x3c, 0xfc);\r\nr = clamp(r, 0x3c, 0xfc);\r\nl = 0xfc - l;\r\nr = 0xfc - r;\r\nucontrol->value.integer.value[0] = l;\r\nucontrol->value.integer.value[1] = r;\r\nreturn 0;\r\n}\r\nstatic int dac_put_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint reg;\r\nint l;\r\nint r;\r\nl = ucontrol->value.integer.value[0];\r\nr = ucontrol->value.integer.value[1];\r\nl = clamp(l, 0, 0xfc - 0x3c);\r\nr = clamp(r, 0, 0xfc - 0x3c);\r\nl = 0xfc - l;\r\nr = 0xfc - r;\r\nreg = l << SGTL5000_DAC_VOL_LEFT_SHIFT |\r\nr << SGTL5000_DAC_VOL_RIGHT_SHIFT;\r\nsnd_soc_write(codec, SGTL5000_CHIP_DAC_VOL, reg);\r\nreturn 0;\r\n}\r\nstatic int sgtl5000_digital_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 adcdac_ctrl = SGTL5000_DAC_MUTE_LEFT | SGTL5000_DAC_MUTE_RIGHT;\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_ADCDAC_CTRL,\r\nadcdac_ctrl, mute ? adcdac_ctrl : 0);\r\nreturn 0;\r\n}\r\nstatic int sgtl5000_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);\r\nu16 i2sctl = 0;\r\nsgtl5000->master = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ni2sctl |= SGTL5000_I2S_MASTER;\r\nsgtl5000->master = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ni2sctl |= SGTL5000_I2S_MODE_PCM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\ni2sctl |= SGTL5000_I2S_MODE_PCM;\r\ni2sctl |= SGTL5000_I2S_LRALIGN;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ni2sctl |= SGTL5000_I2S_MODE_I2S_LJ;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ni2sctl |= SGTL5000_I2S_MODE_RJ;\r\ni2sctl |= SGTL5000_I2S_LRPOL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ni2sctl |= SGTL5000_I2S_MODE_I2S_LJ;\r\ni2sctl |= SGTL5000_I2S_LRALIGN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsgtl5000->fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\ni2sctl |= SGTL5000_I2S_SCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, SGTL5000_CHIP_I2S_CTRL, i2sctl);\r\nreturn 0;\r\n}\r\nstatic int sgtl5000_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase SGTL5000_SYSCLK:\r\nsgtl5000->sysclk = freq;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sgtl5000_set_clock(struct snd_soc_codec *codec, int frame_rate)\r\n{\r\nstruct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);\r\nint clk_ctl = 0;\r\nint sys_fs;\r\nswitch (frame_rate) {\r\ncase 8000:\r\ncase 16000:\r\nsys_fs = 32000;\r\nbreak;\r\ncase 11025:\r\ncase 22050:\r\nsys_fs = 44100;\r\nbreak;\r\ndefault:\r\nsys_fs = frame_rate;\r\nbreak;\r\n}\r\nswitch (sys_fs / frame_rate) {\r\ncase 4:\r\nclk_ctl |= SGTL5000_RATE_MODE_DIV_4 << SGTL5000_RATE_MODE_SHIFT;\r\nbreak;\r\ncase 2:\r\nclk_ctl |= SGTL5000_RATE_MODE_DIV_2 << SGTL5000_RATE_MODE_SHIFT;\r\nbreak;\r\ncase 1:\r\nclk_ctl |= SGTL5000_RATE_MODE_DIV_1 << SGTL5000_RATE_MODE_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (sys_fs) {\r\ncase 32000:\r\nclk_ctl |= SGTL5000_SYS_FS_32k << SGTL5000_SYS_FS_SHIFT;\r\nbreak;\r\ncase 44100:\r\nclk_ctl |= SGTL5000_SYS_FS_44_1k << SGTL5000_SYS_FS_SHIFT;\r\nbreak;\r\ncase 48000:\r\nclk_ctl |= SGTL5000_SYS_FS_48k << SGTL5000_SYS_FS_SHIFT;\r\nbreak;\r\ncase 96000:\r\nclk_ctl |= SGTL5000_SYS_FS_96k << SGTL5000_SYS_FS_SHIFT;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "frame rate %d not supported\n",\r\nframe_rate);\r\nreturn -EINVAL;\r\n}\r\nswitch (sgtl5000->sysclk / sys_fs) {\r\ncase 256:\r\nclk_ctl |= SGTL5000_MCLK_FREQ_256FS <<\r\nSGTL5000_MCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 384:\r\nclk_ctl |= SGTL5000_MCLK_FREQ_384FS <<\r\nSGTL5000_MCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 512:\r\nclk_ctl |= SGTL5000_MCLK_FREQ_512FS <<\r\nSGTL5000_MCLK_FREQ_SHIFT;\r\nbreak;\r\ndefault:\r\nif (sgtl5000->master) {\r\nclk_ctl |= SGTL5000_MCLK_FREQ_PLL <<\r\nSGTL5000_MCLK_FREQ_SHIFT;\r\n} else {\r\ndev_err(codec->dev,\r\n"PLL not supported in slave mode\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif ((clk_ctl & SGTL5000_MCLK_FREQ_MASK) == SGTL5000_MCLK_FREQ_PLL) {\r\nu64 out, t;\r\nint div2;\r\nint pll_ctl;\r\nunsigned int in, int_div, frac_div;\r\nif (sgtl5000->sysclk > 17000000) {\r\ndiv2 = 1;\r\nin = sgtl5000->sysclk / 2;\r\n} else {\r\ndiv2 = 0;\r\nin = sgtl5000->sysclk;\r\n}\r\nif (sys_fs == 44100)\r\nout = 180633600;\r\nelse\r\nout = 196608000;\r\nt = do_div(out, in);\r\nint_div = out;\r\nt *= 2048;\r\ndo_div(t, in);\r\nfrac_div = t;\r\npll_ctl = int_div << SGTL5000_PLL_INT_DIV_SHIFT |\r\nfrac_div << SGTL5000_PLL_FRAC_DIV_SHIFT;\r\nsnd_soc_write(codec, SGTL5000_CHIP_PLL_CTRL, pll_ctl);\r\nif (div2)\r\nsnd_soc_update_bits(codec,\r\nSGTL5000_CHIP_CLK_TOP_CTRL,\r\nSGTL5000_INPUT_FREQ_DIV2,\r\nSGTL5000_INPUT_FREQ_DIV2);\r\nelse\r\nsnd_soc_update_bits(codec,\r\nSGTL5000_CHIP_CLK_TOP_CTRL,\r\nSGTL5000_INPUT_FREQ_DIV2,\r\n0);\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,\r\nSGTL5000_PLL_POWERUP | SGTL5000_VCOAMP_POWERUP,\r\nSGTL5000_PLL_POWERUP | SGTL5000_VCOAMP_POWERUP);\r\n} else {\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,\r\nSGTL5000_PLL_POWERUP | SGTL5000_VCOAMP_POWERUP,\r\n0);\r\n}\r\nsnd_soc_write(codec, SGTL5000_CHIP_CLK_CTRL, clk_ctl);\r\nreturn 0;\r\n}\r\nstatic int sgtl5000_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);\r\nint channels = params_channels(params);\r\nint i2s_ctl = 0;\r\nint stereo;\r\nint ret;\r\nif (!sgtl5000->sysclk) {\r\ndev_err(codec->dev, "%s: set sysclk first!\n", __func__);\r\nreturn -EFAULT;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nstereo = SGTL5000_DAC_STEREO;\r\nelse\r\nstereo = SGTL5000_ADC_STEREO;\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER, stereo,\r\nchannels == 1 ? 0 : stereo);\r\nret = sgtl5000_set_clock(codec, params_rate(params));\r\nif (ret)\r\nreturn ret;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nif (sgtl5000->fmt == SND_SOC_DAIFMT_RIGHT_J)\r\nreturn -EINVAL;\r\ni2s_ctl |= SGTL5000_I2S_DLEN_16 << SGTL5000_I2S_DLEN_SHIFT;\r\ni2s_ctl |= SGTL5000_I2S_SCLKFREQ_32FS <<\r\nSGTL5000_I2S_SCLKFREQ_SHIFT;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\ni2s_ctl |= SGTL5000_I2S_DLEN_20 << SGTL5000_I2S_DLEN_SHIFT;\r\ni2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<\r\nSGTL5000_I2S_SCLKFREQ_SHIFT;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ni2s_ctl |= SGTL5000_I2S_DLEN_24 << SGTL5000_I2S_DLEN_SHIFT;\r\ni2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<\r\nSGTL5000_I2S_SCLKFREQ_SHIFT;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nif (sgtl5000->fmt == SND_SOC_DAIFMT_RIGHT_J)\r\nreturn -EINVAL;\r\ni2s_ctl |= SGTL5000_I2S_DLEN_32 << SGTL5000_I2S_DLEN_SHIFT;\r\ni2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<\r\nSGTL5000_I2S_SCLKFREQ_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_I2S_CTRL,\r\nSGTL5000_I2S_DLEN_MASK | SGTL5000_I2S_SCLKFREQ_MASK,\r\ni2s_ctl);\r\nreturn 0;\r\n}\r\nstatic int ldo_regulator_is_enabled(struct regulator_dev *dev)\r\n{\r\nstruct ldo_regulator *ldo = rdev_get_drvdata(dev);\r\nreturn ldo->enabled;\r\n}\r\nstatic int ldo_regulator_enable(struct regulator_dev *dev)\r\n{\r\nstruct ldo_regulator *ldo = rdev_get_drvdata(dev);\r\nstruct snd_soc_codec *codec = (struct snd_soc_codec *)ldo->codec_data;\r\nint reg;\r\nif (ldo_regulator_is_enabled(dev))\r\nreturn 0;\r\nreg = (1600 - ldo->voltage / 1000) / 50;\r\nreg = clamp(reg, 0x0, 0xf);\r\nldo->voltage = (1600 - reg * 50) * 1000;\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_LINREG_CTRL,\r\nSGTL5000_LINREG_VDDD_MASK, reg);\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,\r\nSGTL5000_LINEREG_D_POWERUP,\r\nSGTL5000_LINEREG_D_POWERUP);\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,\r\nSGTL5000_LINREG_SIMPLE_POWERUP,\r\n0);\r\nldo->enabled = 1;\r\nreturn 0;\r\n}\r\nstatic int ldo_regulator_disable(struct regulator_dev *dev)\r\n{\r\nstruct ldo_regulator *ldo = rdev_get_drvdata(dev);\r\nstruct snd_soc_codec *codec = (struct snd_soc_codec *)ldo->codec_data;\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,\r\nSGTL5000_LINEREG_D_POWERUP,\r\n0);\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_LINREG_CTRL,\r\nSGTL5000_LINREG_VDDD_MASK, 0);\r\nldo->enabled = 0;\r\nreturn 0;\r\n}\r\nstatic int ldo_regulator_get_voltage(struct regulator_dev *dev)\r\n{\r\nstruct ldo_regulator *ldo = rdev_get_drvdata(dev);\r\nreturn ldo->voltage;\r\n}\r\nstatic int ldo_regulator_register(struct snd_soc_codec *codec,\r\nstruct regulator_init_data *init_data,\r\nint voltage)\r\n{\r\nstruct ldo_regulator *ldo;\r\nstruct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);\r\nstruct regulator_config config = { };\r\nldo = kzalloc(sizeof(struct ldo_regulator), GFP_KERNEL);\r\nif (!ldo) {\r\ndev_err(codec->dev, "failed to allocate ldo_regulator\n");\r\nreturn -ENOMEM;\r\n}\r\nldo->desc.name = kstrdup(dev_name(codec->dev), GFP_KERNEL);\r\nif (!ldo->desc.name) {\r\nkfree(ldo);\r\ndev_err(codec->dev, "failed to allocate decs name memory\n");\r\nreturn -ENOMEM;\r\n}\r\nldo->desc.type = REGULATOR_VOLTAGE;\r\nldo->desc.owner = THIS_MODULE;\r\nldo->desc.ops = &ldo_regulator_ops;\r\nldo->desc.n_voltages = 1;\r\nldo->codec_data = codec;\r\nldo->voltage = voltage;\r\nconfig.dev = codec->dev;\r\nconfig.driver_data = ldo;\r\nconfig.init_data = init_data;\r\nldo->dev = regulator_register(&ldo->desc, &config);\r\nif (IS_ERR(ldo->dev)) {\r\nint ret = PTR_ERR(ldo->dev);\r\ndev_err(codec->dev, "failed to register regulator\n");\r\nkfree(ldo->desc.name);\r\nkfree(ldo);\r\nreturn ret;\r\n}\r\nsgtl5000->ldo = ldo;\r\nreturn 0;\r\n}\r\nstatic int ldo_regulator_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);\r\nstruct ldo_regulator *ldo = sgtl5000->ldo;\r\nif (!ldo)\r\nreturn 0;\r\nregulator_unregister(ldo->dev);\r\nkfree(ldo->desc.name);\r\nkfree(ldo);\r\nreturn 0;\r\n}\r\nstatic int ldo_regulator_register(struct snd_soc_codec *codec,\r\nstruct regulator_init_data *init_data,\r\nint voltage)\r\n{\r\ndev_err(codec->dev, "this setup needs regulator support in the kernel\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int ldo_regulator_remove(struct snd_soc_codec *codec)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sgtl5000_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nint ret;\r\nstruct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regulator_bulk_enable(\r\nARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nif (ret)\r\nreturn ret;\r\nudelay(10);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int sgtl5000_volatile_register(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase SGTL5000_CHIP_ID:\r\ncase SGTL5000_CHIP_ADCDAC_CTRL:\r\ncase SGTL5000_CHIP_ANA_STATUS:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sgtl5000_suspend(struct snd_soc_codec *codec)\r\n{\r\nsgtl5000_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int sgtl5000_restore_regs(struct snd_soc_codec *codec)\r\n{\r\nu16 *cache = codec->reg_cache;\r\nu16 reg;\r\nfor (reg = 0; reg <= SGTL5000_CHIP_SHORT_CTRL; reg += 2) {\r\nif (reg == SGTL5000_CHIP_ANA_POWER ||\r\nreg == SGTL5000_CHIP_CLK_CTRL ||\r\nreg == SGTL5000_CHIP_LINREG_CTRL ||\r\nreg == SGTL5000_CHIP_LINE_OUT_CTRL ||\r\nreg == SGTL5000_CHIP_REF_CTRL)\r\ncontinue;\r\nsnd_soc_write(codec, reg, cache[reg]);\r\n}\r\nfor (reg = SGTL5000_DAP_REG_OFFSET; reg < SGTL5000_MAX_REG_OFFSET; reg += 2)\r\nsnd_soc_write(codec, reg, cache[reg]);\r\nsnd_soc_write(codec, SGTL5000_CHIP_LINREG_CTRL,\r\ncache[SGTL5000_CHIP_LINREG_CTRL]);\r\nsnd_soc_write(codec, SGTL5000_CHIP_ANA_POWER,\r\ncache[SGTL5000_CHIP_ANA_POWER]);\r\nsnd_soc_write(codec, SGTL5000_CHIP_CLK_CTRL,\r\ncache[SGTL5000_CHIP_CLK_CTRL]);\r\nsnd_soc_write(codec, SGTL5000_CHIP_REF_CTRL,\r\ncache[SGTL5000_CHIP_REF_CTRL]);\r\nsnd_soc_write(codec, SGTL5000_CHIP_LINE_OUT_CTRL,\r\ncache[SGTL5000_CHIP_LINE_OUT_CTRL]);\r\nreturn 0;\r\n}\r\nstatic int sgtl5000_resume(struct snd_soc_codec *codec)\r\n{\r\nsgtl5000_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nsgtl5000_restore_regs(codec);\r\nreturn 0;\r\n}\r\nstatic int sgtl5000_set_power_regs(struct snd_soc_codec *codec)\r\n{\r\nint vddd;\r\nint vdda;\r\nint vddio;\r\nu16 ana_pwr;\r\nu16 lreg_ctrl;\r\nint vag;\r\nstruct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);\r\nvdda = regulator_get_voltage(sgtl5000->supplies[VDDA].consumer);\r\nvddio = regulator_get_voltage(sgtl5000->supplies[VDDIO].consumer);\r\nvddd = regulator_get_voltage(sgtl5000->supplies[VDDD].consumer);\r\nvdda = vdda / 1000;\r\nvddio = vddio / 1000;\r\nvddd = vddd / 1000;\r\nif (vdda <= 0 || vddio <= 0 || vddd < 0) {\r\ndev_err(codec->dev, "regulator voltage not set correctly\n");\r\nreturn -EINVAL;\r\n}\r\nif (vdda > 3600 || vddio > 3600 || vddd > 1980) {\r\ndev_err(codec->dev,\r\n"exceed max voltage vdda %dmV vddio %dmV vddd %dmV\n",\r\nvdda, vddio, vddd);\r\nreturn -EINVAL;\r\n}\r\nana_pwr = snd_soc_read(codec, SGTL5000_CHIP_ANA_POWER);\r\nana_pwr |= SGTL5000_DAC_STEREO |\r\nSGTL5000_ADC_STEREO |\r\nSGTL5000_REFTOP_POWERUP;\r\nlreg_ctrl = snd_soc_read(codec, SGTL5000_CHIP_LINREG_CTRL);\r\nif (vddio < 3100 && vdda < 3100) {\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_CLK_TOP_CTRL,\r\nSGTL5000_INT_OSC_EN,\r\nSGTL5000_INT_OSC_EN);\r\nana_pwr |= SGTL5000_VDDC_CHRGPMP_POWERUP;\r\n} else if (vddio >= 3100 && vdda >= 3100) {\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,\r\nSGTL5000_VDDC_CHRGPMP_POWERUP, 0);\r\nlreg_ctrl |= SGTL5000_VDDC_ASSN_OVRD;\r\nlreg_ctrl |= SGTL5000_VDDC_MAN_ASSN_VDDIO <<\r\nSGTL5000_VDDC_MAN_ASSN_SHIFT;\r\n}\r\nsnd_soc_write(codec, SGTL5000_CHIP_LINREG_CTRL, lreg_ctrl);\r\nsnd_soc_write(codec, SGTL5000_CHIP_ANA_POWER, ana_pwr);\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_LINREG_CTRL,\r\nSGTL5000_LINREG_VDDD_MASK, 0x8);\r\nif (ana_pwr & SGTL5000_LINEREG_D_POWERUP)\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,\r\nSGTL5000_LINREG_SIMPLE_POWERUP,\r\n0);\r\nelse\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,\r\nSGTL5000_LINREG_SIMPLE_POWERUP |\r\nSGTL5000_STARTUP_POWERUP,\r\n0);\r\nvag = vdda / 2;\r\nif (vag <= SGTL5000_ANA_GND_BASE)\r\nvag = 0;\r\nelse if (vag >= SGTL5000_ANA_GND_BASE + SGTL5000_ANA_GND_STP *\r\n(SGTL5000_ANA_GND_MASK >> SGTL5000_ANA_GND_SHIFT))\r\nvag = SGTL5000_ANA_GND_MASK >> SGTL5000_ANA_GND_SHIFT;\r\nelse\r\nvag = (vag - SGTL5000_ANA_GND_BASE) / SGTL5000_ANA_GND_STP;\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_REF_CTRL,\r\nSGTL5000_ANA_GND_MASK, vag << SGTL5000_ANA_GND_SHIFT);\r\nvag = vddio / 2;\r\nif (vag <= SGTL5000_LINE_OUT_GND_BASE)\r\nvag = 0;\r\nelse if (vag >= SGTL5000_LINE_OUT_GND_BASE +\r\nSGTL5000_LINE_OUT_GND_STP * SGTL5000_LINE_OUT_GND_MAX)\r\nvag = SGTL5000_LINE_OUT_GND_MAX;\r\nelse\r\nvag = (vag - SGTL5000_LINE_OUT_GND_BASE) /\r\nSGTL5000_LINE_OUT_GND_STP;\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_LINE_OUT_CTRL,\r\nSGTL5000_LINE_OUT_CURRENT_MASK |\r\nSGTL5000_LINE_OUT_GND_MASK,\r\nvag << SGTL5000_LINE_OUT_GND_SHIFT |\r\nSGTL5000_LINE_OUT_CURRENT_360u <<\r\nSGTL5000_LINE_OUT_CURRENT_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int sgtl5000_replace_vddd_with_ldo(struct snd_soc_codec *codec)\r\n{\r\nstruct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = ldo_regulator_register(codec, &ldo_init_data, LDO_VOLTAGE);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to register vddd internal supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nsgtl5000->supplies[VDDD].supply = LDO_CONSUMER_NAME;\r\nret = regulator_bulk_get(codec->dev, ARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nif (ret) {\r\nldo_regulator_remove(codec);\r\ndev_err(codec->dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_info(codec->dev, "Using internal LDO instead of VDDD\n");\r\nreturn 0;\r\n}\r\nstatic int sgtl5000_enable_regulators(struct snd_soc_codec *codec)\r\n{\r\nu16 reg;\r\nint ret;\r\nint rev;\r\nint i;\r\nint external_vddd = 0;\r\nstruct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);\r\nfor (i = 0; i < ARRAY_SIZE(sgtl5000->supplies); i++)\r\nsgtl5000->supplies[i].supply = supply_names[i];\r\nret = regulator_bulk_get(codec->dev, ARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nif (!ret)\r\nexternal_vddd = 1;\r\nelse {\r\nret = sgtl5000_replace_vddd_with_ldo(codec);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nif (ret)\r\ngoto err_regulator_free;\r\nudelay(10);\r\nreg = snd_soc_read(codec, SGTL5000_CHIP_ID);\r\nif (((reg & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=\r\nSGTL5000_PARTID_PART_ID) {\r\ndev_err(codec->dev,\r\n"Device with ID register %x is not a sgtl5000\n", reg);\r\nret = -ENODEV;\r\ngoto err_regulator_disable;\r\n}\r\nrev = (reg & SGTL5000_REVID_MASK) >> SGTL5000_REVID_SHIFT;\r\ndev_info(codec->dev, "sgtl5000 revision 0x%x\n", rev);\r\nif (external_vddd && rev >= 0x11) {\r\nregulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nregulator_bulk_free(ARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nret = sgtl5000_replace_vddd_with_ldo(codec);\r\nif (ret)\r\nreturn ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nif (ret)\r\ngoto err_regulator_free;\r\nudelay(10);\r\n}\r\nreturn 0;\r\nerr_regulator_disable:\r\nregulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nerr_regulator_free:\r\nregulator_bulk_free(ARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nif (external_vddd)\r\nldo_regulator_remove(codec);\r\nreturn ret;\r\n}\r\nstatic int sgtl5000_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret;\r\nstruct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);\r\nret = snd_soc_codec_set_cache_io(codec, 16, 16, SND_SOC_I2C);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = sgtl5000_enable_regulators(codec);\r\nif (ret)\r\nreturn ret;\r\nret = sgtl5000_set_power_regs(codec);\r\nif (ret)\r\ngoto err;\r\nsnd_soc_update_bits(codec, SGTL5000_CHIP_REF_CTRL,\r\nSGTL5000_SMALL_POP,\r\nSGTL5000_SMALL_POP);\r\nsnd_soc_write(codec, SGTL5000_CHIP_SHORT_CTRL, 0);\r\nsnd_soc_write(codec, SGTL5000_CHIP_SSS_CTRL,\r\nSGTL5000_DAC_SEL_I2S_IN << SGTL5000_DAC_SEL_SHIFT);\r\nsnd_soc_write(codec, SGTL5000_CHIP_DIG_POWER,\r\nSGTL5000_ADC_EN | SGTL5000_DAC_EN);\r\nsnd_soc_write(codec, SGTL5000_CHIP_ADCDAC_CTRL,\r\nSGTL5000_DAC_VOL_RAMP_EN |\r\nSGTL5000_DAC_MUTE_RIGHT |\r\nSGTL5000_DAC_MUTE_LEFT);\r\nsnd_soc_write(codec, SGTL5000_CHIP_PAD_STRENGTH, 0x015f);\r\nsnd_soc_write(codec, SGTL5000_CHIP_ANA_CTRL,\r\nSGTL5000_HP_ZCD_EN |\r\nSGTL5000_ADC_ZCD_EN);\r\nsnd_soc_write(codec, SGTL5000_CHIP_MIC_CTRL, 0);\r\nsnd_soc_write(codec, SGTL5000_DAP_CTRL, 0);\r\nret = sgtl5000_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nregulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nregulator_bulk_free(ARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nldo_regulator_remove(codec);\r\nreturn ret;\r\n}\r\nstatic int sgtl5000_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct sgtl5000_priv *sgtl5000 = snd_soc_codec_get_drvdata(codec);\r\nsgtl5000_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nregulator_bulk_disable(ARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nregulator_bulk_free(ARRAY_SIZE(sgtl5000->supplies),\r\nsgtl5000->supplies);\r\nldo_regulator_remove(codec);\r\nreturn 0;\r\n}\r\nstatic __devinit int sgtl5000_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct sgtl5000_priv *sgtl5000;\r\nint ret;\r\nsgtl5000 = devm_kzalloc(&client->dev, sizeof(struct sgtl5000_priv),\r\nGFP_KERNEL);\r\nif (!sgtl5000)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, sgtl5000);\r\nret = snd_soc_register_codec(&client->dev,\r\n&sgtl5000_driver, &sgtl5000_dai, 1);\r\nreturn ret;\r\n}\r\nstatic __devexit int sgtl5000_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
