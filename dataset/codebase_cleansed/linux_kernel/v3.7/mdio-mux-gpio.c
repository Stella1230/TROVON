static int mdio_mux_gpio_switch_fn(int current_child, int desired_child,\r\nvoid *data)\r\n{\r\nint change;\r\nunsigned int n;\r\nstruct mdio_mux_gpio_state *s = data;\r\nif (current_child == desired_child)\r\nreturn 0;\r\nchange = current_child == -1 ? -1 : current_child ^ desired_child;\r\nfor (n = 0; n < s->num_gpios; n++) {\r\nif (change & 1)\r\ngpio_set_value_cansleep(s->gpio[n],\r\n(desired_child & 1) != 0);\r\nchange >>= 1;\r\ndesired_child >>= 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit mdio_mux_gpio_probe(struct platform_device *pdev)\r\n{\r\nenum of_gpio_flags f;\r\nstruct mdio_mux_gpio_state *s;\r\nunsigned int num_gpios;\r\nunsigned int n;\r\nint r;\r\nif (!pdev->dev.of_node)\r\nreturn -ENODEV;\r\nnum_gpios = of_gpio_count(pdev->dev.of_node);\r\nif (num_gpios == 0 || num_gpios > MDIO_MUX_GPIO_MAX_BITS)\r\nreturn -ENODEV;\r\ns = devm_kzalloc(&pdev->dev, sizeof(*s), GFP_KERNEL);\r\nif (!s)\r\nreturn -ENOMEM;\r\ns->num_gpios = num_gpios;\r\nfor (n = 0; n < num_gpios; ) {\r\nint gpio = of_get_gpio_flags(pdev->dev.of_node, n, &f);\r\nif (gpio < 0) {\r\nr = (gpio == -ENODEV) ? -EPROBE_DEFER : gpio;\r\ngoto err;\r\n}\r\ns->gpio[n] = gpio;\r\nn++;\r\nr = gpio_request(gpio, "mdio_mux_gpio");\r\nif (r)\r\ngoto err;\r\nr = gpio_direction_output(gpio, 0);\r\nif (r)\r\ngoto err;\r\n}\r\nr = mdio_mux_init(&pdev->dev,\r\nmdio_mux_gpio_switch_fn, &s->mux_handle, s);\r\nif (r == 0) {\r\npdev->dev.platform_data = s;\r\nreturn 0;\r\n}\r\nerr:\r\nwhile (n) {\r\nn--;\r\ngpio_free(s->gpio[n]);\r\n}\r\nreturn r;\r\n}\r\nstatic int __devexit mdio_mux_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct mdio_mux_gpio_state *s = pdev->dev.platform_data;\r\nmdio_mux_uninit(s->mux_handle);\r\nreturn 0;\r\n}
