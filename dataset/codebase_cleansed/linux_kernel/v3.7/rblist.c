int rblist__add_node(struct rblist *rblist, const void *new_entry)\r\n{\r\nstruct rb_node **p = &rblist->entries.rb_node;\r\nstruct rb_node *parent = NULL, *new_node;\r\nwhile (*p != NULL) {\r\nint rc;\r\nparent = *p;\r\nrc = rblist->node_cmp(parent, new_entry);\r\nif (rc > 0)\r\np = &(*p)->rb_left;\r\nelse if (rc < 0)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn -EEXIST;\r\n}\r\nnew_node = rblist->node_new(rblist, new_entry);\r\nif (new_node == NULL)\r\nreturn -ENOMEM;\r\nrb_link_node(new_node, parent, p);\r\nrb_insert_color(new_node, &rblist->entries);\r\n++rblist->nr_entries;\r\nreturn 0;\r\n}\r\nvoid rblist__remove_node(struct rblist *rblist, struct rb_node *rb_node)\r\n{\r\nrb_erase(rb_node, &rblist->entries);\r\nrblist->node_delete(rblist, rb_node);\r\n}\r\nstruct rb_node *rblist__find(struct rblist *rblist, const void *entry)\r\n{\r\nstruct rb_node **p = &rblist->entries.rb_node;\r\nstruct rb_node *parent = NULL;\r\nwhile (*p != NULL) {\r\nint rc;\r\nparent = *p;\r\nrc = rblist->node_cmp(parent, entry);\r\nif (rc > 0)\r\np = &(*p)->rb_left;\r\nelse if (rc < 0)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn parent;\r\n}\r\nreturn NULL;\r\n}\r\nvoid rblist__init(struct rblist *rblist)\r\n{\r\nif (rblist != NULL) {\r\nrblist->entries = RB_ROOT;\r\nrblist->nr_entries = 0;\r\n}\r\nreturn;\r\n}\r\nvoid rblist__delete(struct rblist *rblist)\r\n{\r\nif (rblist != NULL) {\r\nstruct rb_node *pos, *next = rb_first(&rblist->entries);\r\nwhile (next) {\r\npos = next;\r\nnext = rb_next(pos);\r\nrb_erase(pos, &rblist->entries);\r\nrblist->node_delete(rblist, pos);\r\n}\r\nfree(rblist);\r\n}\r\n}\r\nstruct rb_node *rblist__entry(const struct rblist *rblist, unsigned int idx)\r\n{\r\nstruct rb_node *node;\r\nfor (node = rb_first(&rblist->entries); node; node = rb_next(node)) {\r\nif (!idx--)\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}
