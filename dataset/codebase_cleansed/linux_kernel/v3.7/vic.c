static void vic_init2(void __iomem *base)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++) {\r\nvoid __iomem *reg = base + VIC_VECT_CNTL0 + (i * 4);\r\nwritel(VIC_VECT_CNTL_ENABLE | i, reg);\r\n}\r\nwritel(32, base + VIC_PL190_DEF_VECT_ADDR);\r\n}\r\nstatic void resume_one_vic(struct vic_device *vic)\r\n{\r\nvoid __iomem *base = vic->base;\r\nprintk(KERN_DEBUG "%s: resuming vic at %p\n", __func__, base);\r\nvic_init2(base);\r\nwritel(vic->int_select, base + VIC_INT_SELECT);\r\nwritel(vic->protect, base + VIC_PROTECT);\r\nwritel(vic->int_enable, base + VIC_INT_ENABLE);\r\nwritel(~vic->int_enable, base + VIC_INT_ENABLE_CLEAR);\r\nwritel(vic->soft_int, base + VIC_INT_SOFT);\r\nwritel(~vic->soft_int, base + VIC_INT_SOFT_CLEAR);\r\n}\r\nstatic void vic_resume(void)\r\n{\r\nint id;\r\nfor (id = vic_id - 1; id >= 0; id--)\r\nresume_one_vic(vic_devices + id);\r\n}\r\nstatic void suspend_one_vic(struct vic_device *vic)\r\n{\r\nvoid __iomem *base = vic->base;\r\nprintk(KERN_DEBUG "%s: suspending vic at %p\n", __func__, base);\r\nvic->int_select = readl(base + VIC_INT_SELECT);\r\nvic->int_enable = readl(base + VIC_INT_ENABLE);\r\nvic->soft_int = readl(base + VIC_INT_SOFT);\r\nvic->protect = readl(base + VIC_PROTECT);\r\nwritel(vic->resume_irqs, base + VIC_INT_ENABLE);\r\nwritel(~vic->resume_irqs, base + VIC_INT_ENABLE_CLEAR);\r\n}\r\nstatic int vic_suspend(void)\r\n{\r\nint id;\r\nfor (id = 0; id < vic_id; id++)\r\nsuspend_one_vic(vic_devices + id);\r\nreturn 0;\r\n}\r\nstatic int __init vic_pm_init(void)\r\n{\r\nif (vic_id > 0)\r\nregister_syscore_ops(&vic_syscore_ops);\r\nreturn 0;\r\n}\r\nstatic int vic_irqdomain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct vic_device *v = d->host_data;\r\nif (!(v->valid_sources & (1 << hwirq)))\r\nreturn -ENOTSUPP;\r\nirq_set_chip_and_handler(irq, &vic_chip, handle_level_irq);\r\nirq_set_chip_data(irq, v->base);\r\nset_irq_flags(irq, IRQF_VALID | IRQF_PROBE);\r\nreturn 0;\r\n}\r\nstatic void __init vic_register(void __iomem *base, unsigned int irq,\r\nu32 valid_sources, u32 resume_sources,\r\nstruct device_node *node)\r\n{\r\nstruct vic_device *v;\r\nif (vic_id >= ARRAY_SIZE(vic_devices)) {\r\nprintk(KERN_ERR "%s: too few VICs, increase CONFIG_ARM_VIC_NR\n", __func__);\r\nreturn;\r\n}\r\nv = &vic_devices[vic_id];\r\nv->base = base;\r\nv->valid_sources = valid_sources;\r\nv->resume_sources = resume_sources;\r\nv->irq = irq;\r\nvic_id++;\r\nv->domain = irq_domain_add_legacy(node, fls(valid_sources), irq, 0,\r\n&vic_irqdomain_ops, v);\r\n}\r\nstatic void vic_ack_irq(struct irq_data *d)\r\n{\r\nvoid __iomem *base = irq_data_get_irq_chip_data(d);\r\nunsigned int irq = d->hwirq;\r\nwritel(1 << irq, base + VIC_INT_ENABLE_CLEAR);\r\nwritel(1 << irq, base + VIC_INT_SOFT_CLEAR);\r\n}\r\nstatic void vic_mask_irq(struct irq_data *d)\r\n{\r\nvoid __iomem *base = irq_data_get_irq_chip_data(d);\r\nunsigned int irq = d->hwirq;\r\nwritel(1 << irq, base + VIC_INT_ENABLE_CLEAR);\r\n}\r\nstatic void vic_unmask_irq(struct irq_data *d)\r\n{\r\nvoid __iomem *base = irq_data_get_irq_chip_data(d);\r\nunsigned int irq = d->hwirq;\r\nwritel(1 << irq, base + VIC_INT_ENABLE);\r\n}\r\nstatic struct vic_device *vic_from_irq(unsigned int irq)\r\n{\r\nstruct vic_device *v = vic_devices;\r\nunsigned int base_irq = irq & ~31;\r\nint id;\r\nfor (id = 0; id < vic_id; id++, v++) {\r\nif (v->irq == base_irq)\r\nreturn v;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int vic_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct vic_device *v = vic_from_irq(d->irq);\r\nunsigned int off = d->hwirq;\r\nu32 bit = 1 << off;\r\nif (!v)\r\nreturn -EINVAL;\r\nif (!(bit & v->resume_sources))\r\nreturn -EINVAL;\r\nif (on)\r\nv->resume_irqs |= bit;\r\nelse\r\nv->resume_irqs &= ~bit;\r\nreturn 0;\r\n}\r\nstatic void __init vic_disable(void __iomem *base)\r\n{\r\nwritel(0, base + VIC_INT_SELECT);\r\nwritel(0, base + VIC_INT_ENABLE);\r\nwritel(~0, base + VIC_INT_ENABLE_CLEAR);\r\nwritel(0, base + VIC_ITCR);\r\nwritel(~0, base + VIC_INT_SOFT_CLEAR);\r\n}\r\nstatic void __init vic_clear_interrupts(void __iomem *base)\r\n{\r\nunsigned int i;\r\nwritel(0, base + VIC_PL190_VECT_ADDR);\r\nfor (i = 0; i < 19; i++) {\r\nunsigned int value;\r\nvalue = readl(base + VIC_PL190_VECT_ADDR);\r\nwritel(value, base + VIC_PL190_VECT_ADDR);\r\n}\r\n}\r\nstatic void __init vic_init_st(void __iomem *base, unsigned int irq_start,\r\nu32 vic_sources, struct device_node *node)\r\n{\r\nunsigned int i;\r\nint vic_2nd_block = ((unsigned long)base & ~PAGE_MASK) != 0;\r\nvic_disable(base);\r\nif (vic_2nd_block) {\r\nvic_clear_interrupts(base);\r\nfor (i = 0; i < 16; i++) {\r\nvoid __iomem *reg = base + VIC_VECT_CNTL0 + (i * 4);\r\nwritel(0, reg);\r\n}\r\nwritel(32, base + VIC_PL190_DEF_VECT_ADDR);\r\n}\r\nvic_register(base, irq_start, vic_sources, 0, node);\r\n}\r\nvoid __init __vic_init(void __iomem *base, unsigned int irq_start,\r\nu32 vic_sources, u32 resume_sources,\r\nstruct device_node *node)\r\n{\r\nunsigned int i;\r\nu32 cellid = 0;\r\nenum amba_vendor vendor;\r\nfor (i = 0; i < 4; i++) {\r\nvoid __iomem *addr;\r\naddr = (void __iomem *)((u32)base & PAGE_MASK) + 0xfe0 + (i * 4);\r\ncellid |= (readl(addr) & 0xff) << (8 * i);\r\n}\r\nvendor = (cellid >> 12) & 0xff;\r\nprintk(KERN_INFO "VIC @%p: id 0x%08x, vendor 0x%02x\n",\r\nbase, cellid, vendor);\r\nswitch(vendor) {\r\ncase AMBA_VENDOR_ST:\r\nvic_init_st(base, irq_start, vic_sources, node);\r\nreturn;\r\ndefault:\r\nprintk(KERN_WARNING "VIC: unknown vendor, continuing anyways\n");\r\ncase AMBA_VENDOR_ARM:\r\nbreak;\r\n}\r\nvic_disable(base);\r\nvic_clear_interrupts(base);\r\nvic_init2(base);\r\nvic_register(base, irq_start, vic_sources, resume_sources, node);\r\n}\r\nvoid __init vic_init(void __iomem *base, unsigned int irq_start,\r\nu32 vic_sources, u32 resume_sources)\r\n{\r\n__vic_init(base, irq_start, vic_sources, resume_sources, NULL);\r\n}\r\nint __init vic_of_init(struct device_node *node, struct device_node *parent)\r\n{\r\nvoid __iomem *regs;\r\nint irq_base;\r\nif (WARN(parent, "non-root VICs are not supported"))\r\nreturn -EINVAL;\r\nregs = of_iomap(node, 0);\r\nif (WARN_ON(!regs))\r\nreturn -EIO;\r\nirq_base = irq_alloc_descs(-1, 0, 32, numa_node_id());\r\nif (WARN_ON(irq_base < 0))\r\ngoto out_unmap;\r\n__vic_init(regs, irq_base, ~0, ~0, node);\r\nreturn 0;\r\nout_unmap:\r\niounmap(regs);\r\nreturn -EIO;\r\n}\r\nstatic int handle_one_vic(struct vic_device *vic, struct pt_regs *regs)\r\n{\r\nu32 stat, irq;\r\nint handled = 0;\r\nwhile ((stat = readl_relaxed(vic->base + VIC_IRQ_STATUS))) {\r\nirq = ffs(stat) - 1;\r\nhandle_IRQ(irq_find_mapping(vic->domain, irq), regs);\r\nhandled = 1;\r\n}\r\nreturn handled;\r\n}\r\nasmlinkage void __exception_irq_entry vic_handle_irq(struct pt_regs *regs)\r\n{\r\nint i, handled;\r\ndo {\r\nfor (i = 0, handled = 0; i < vic_id; ++i)\r\nhandled |= handle_one_vic(&vic_devices[i], regs);\r\n} while (handled);\r\n}
