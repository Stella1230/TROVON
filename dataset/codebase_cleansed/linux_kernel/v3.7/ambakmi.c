static irqreturn_t amba_kmi_int(int irq, void *dev_id)\r\n{\r\nstruct amba_kmi_port *kmi = dev_id;\r\nunsigned int status = readb(KMIIR);\r\nint handled = IRQ_NONE;\r\nwhile (status & KMIIR_RXINTR) {\r\nserio_interrupt(kmi->io, readb(KMIDATA), 0);\r\nstatus = readb(KMIIR);\r\nhandled = IRQ_HANDLED;\r\n}\r\nreturn handled;\r\n}\r\nstatic int amba_kmi_write(struct serio *io, unsigned char val)\r\n{\r\nstruct amba_kmi_port *kmi = io->port_data;\r\nunsigned int timeleft = 10000;\r\nwhile ((readb(KMISTAT) & KMISTAT_TXEMPTY) == 0 && --timeleft)\r\nudelay(10);\r\nif (timeleft)\r\nwriteb(val, KMIDATA);\r\nreturn timeleft ? 0 : SERIO_TIMEOUT;\r\n}\r\nstatic int amba_kmi_open(struct serio *io)\r\n{\r\nstruct amba_kmi_port *kmi = io->port_data;\r\nunsigned int divisor;\r\nint ret;\r\nret = clk_prepare_enable(kmi->clk);\r\nif (ret)\r\ngoto out;\r\ndivisor = clk_get_rate(kmi->clk) / 8000000 - 1;\r\nwriteb(divisor, KMICLKDIV);\r\nwriteb(KMICR_EN, KMICR);\r\nret = request_irq(kmi->irq, amba_kmi_int, 0, "kmi-pl050", kmi);\r\nif (ret) {\r\nprintk(KERN_ERR "kmi: failed to claim IRQ%d\n", kmi->irq);\r\nwriteb(0, KMICR);\r\ngoto clk_disable;\r\n}\r\nwriteb(KMICR_EN | KMICR_RXINTREN, KMICR);\r\nreturn 0;\r\nclk_disable:\r\nclk_disable_unprepare(kmi->clk);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void amba_kmi_close(struct serio *io)\r\n{\r\nstruct amba_kmi_port *kmi = io->port_data;\r\nwriteb(0, KMICR);\r\nfree_irq(kmi->irq, kmi);\r\nclk_disable_unprepare(kmi->clk);\r\n}\r\nstatic int __devinit amba_kmi_probe(struct amba_device *dev,\r\nconst struct amba_id *id)\r\n{\r\nstruct amba_kmi_port *kmi;\r\nstruct serio *io;\r\nint ret;\r\nret = amba_request_regions(dev, NULL);\r\nif (ret)\r\nreturn ret;\r\nkmi = kzalloc(sizeof(struct amba_kmi_port), GFP_KERNEL);\r\nio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!kmi || !io) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nio->id.type = SERIO_8042;\r\nio->write = amba_kmi_write;\r\nio->open = amba_kmi_open;\r\nio->close = amba_kmi_close;\r\nstrlcpy(io->name, dev_name(&dev->dev), sizeof(io->name));\r\nstrlcpy(io->phys, dev_name(&dev->dev), sizeof(io->phys));\r\nio->port_data = kmi;\r\nio->dev.parent = &dev->dev;\r\nkmi->io = io;\r\nkmi->base = ioremap(dev->res.start, resource_size(&dev->res));\r\nif (!kmi->base) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nkmi->clk = clk_get(&dev->dev, "KMIREFCLK");\r\nif (IS_ERR(kmi->clk)) {\r\nret = PTR_ERR(kmi->clk);\r\ngoto unmap;\r\n}\r\nkmi->irq = dev->irq[0];\r\namba_set_drvdata(dev, kmi);\r\nserio_register_port(kmi->io);\r\nreturn 0;\r\nunmap:\r\niounmap(kmi->base);\r\nout:\r\nkfree(kmi);\r\nkfree(io);\r\namba_release_regions(dev);\r\nreturn ret;\r\n}\r\nstatic int __devexit amba_kmi_remove(struct amba_device *dev)\r\n{\r\nstruct amba_kmi_port *kmi = amba_get_drvdata(dev);\r\namba_set_drvdata(dev, NULL);\r\nserio_unregister_port(kmi->io);\r\nclk_put(kmi->clk);\r\niounmap(kmi->base);\r\nkfree(kmi);\r\namba_release_regions(dev);\r\nreturn 0;\r\n}\r\nstatic int amba_kmi_resume(struct amba_device *dev)\r\n{\r\nstruct amba_kmi_port *kmi = amba_get_drvdata(dev);\r\nserio_reconnect(kmi->io);\r\nreturn 0;\r\n}
