static int asus_wmi_input_init(struct asus_wmi *asus)\r\n{\r\nint err;\r\nasus->inputdev = input_allocate_device();\r\nif (!asus->inputdev)\r\nreturn -ENOMEM;\r\nasus->inputdev->name = asus->driver->input_name;\r\nasus->inputdev->phys = asus->driver->input_phys;\r\nasus->inputdev->id.bustype = BUS_HOST;\r\nasus->inputdev->dev.parent = &asus->platform_device->dev;\r\nset_bit(EV_REP, asus->inputdev->evbit);\r\nerr = sparse_keymap_setup(asus->inputdev, asus->driver->keymap, NULL);\r\nif (err)\r\ngoto err_free_dev;\r\nerr = input_register_device(asus->inputdev);\r\nif (err)\r\ngoto err_free_keymap;\r\nreturn 0;\r\nerr_free_keymap:\r\nsparse_keymap_free(asus->inputdev);\r\nerr_free_dev:\r\ninput_free_device(asus->inputdev);\r\nreturn err;\r\n}\r\nstatic void asus_wmi_input_exit(struct asus_wmi *asus)\r\n{\r\nif (asus->inputdev) {\r\nsparse_keymap_free(asus->inputdev);\r\ninput_unregister_device(asus->inputdev);\r\n}\r\nasus->inputdev = NULL;\r\n}\r\nstatic int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1,\r\nu32 *retval)\r\n{\r\nstruct bios_args args = {\r\n.arg0 = arg0,\r\n.arg1 = arg1,\r\n};\r\nstruct acpi_buffer input = { (acpi_size) sizeof(args), &args };\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nacpi_status status;\r\nunion acpi_object *obj;\r\nu32 tmp;\r\nstatus = wmi_evaluate_method(ASUS_WMI_MGMT_GUID, 1, method_id,\r\n&input, &output);\r\nif (ACPI_FAILURE(status))\r\ngoto exit;\r\nobj = (union acpi_object *)output.pointer;\r\nif (obj && obj->type == ACPI_TYPE_INTEGER)\r\ntmp = (u32) obj->integer.value;\r\nelse\r\ntmp = 0;\r\nif (retval)\r\n*retval = tmp;\r\nkfree(obj);\r\nexit:\r\nif (ACPI_FAILURE(status))\r\nreturn -EIO;\r\nif (tmp == ASUS_WMI_UNSUPPORTED_METHOD)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int asus_wmi_get_devstate(struct asus_wmi *asus, u32 dev_id, u32 *retval)\r\n{\r\nreturn asus_wmi_evaluate_method(asus->dsts_id, dev_id, 0, retval);\r\n}\r\nstatic int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param,\r\nu32 *retval)\r\n{\r\nreturn asus_wmi_evaluate_method(ASUS_WMI_METHODID_DEVS, dev_id,\r\nctrl_param, retval);\r\n}\r\nstatic int asus_wmi_get_devstate_bits(struct asus_wmi *asus,\r\nu32 dev_id, u32 mask)\r\n{\r\nu32 retval = 0;\r\nint err;\r\nerr = asus_wmi_get_devstate(asus, dev_id, &retval);\r\nif (err < 0)\r\nreturn err;\r\nif (!(retval & ASUS_WMI_DSTS_PRESENCE_BIT))\r\nreturn -ENODEV;\r\nif (mask == ASUS_WMI_DSTS_STATUS_BIT) {\r\nif (retval & ASUS_WMI_DSTS_UNKNOWN_BIT)\r\nreturn -ENODEV;\r\n}\r\nreturn retval & mask;\r\n}\r\nstatic int asus_wmi_get_devstate_simple(struct asus_wmi *asus, u32 dev_id)\r\n{\r\nreturn asus_wmi_get_devstate_bits(asus, dev_id,\r\nASUS_WMI_DSTS_STATUS_BIT);\r\n}\r\nstatic void tpd_led_update(struct work_struct *work)\r\n{\r\nint ctrl_param;\r\nstruct asus_wmi *asus;\r\nasus = container_of(work, struct asus_wmi, tpd_led_work);\r\nctrl_param = asus->tpd_led_wk;\r\nasus_wmi_set_devstate(ASUS_WMI_DEVID_TOUCHPAD_LED, ctrl_param, NULL);\r\n}\r\nstatic void tpd_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct asus_wmi *asus;\r\nasus = container_of(led_cdev, struct asus_wmi, tpd_led);\r\nasus->tpd_led_wk = !!value;\r\nqueue_work(asus->led_workqueue, &asus->tpd_led_work);\r\n}\r\nstatic int read_tpd_led_state(struct asus_wmi *asus)\r\n{\r\nreturn asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_TOUCHPAD_LED);\r\n}\r\nstatic enum led_brightness tpd_led_get(struct led_classdev *led_cdev)\r\n{\r\nstruct asus_wmi *asus;\r\nasus = container_of(led_cdev, struct asus_wmi, tpd_led);\r\nreturn read_tpd_led_state(asus);\r\n}\r\nstatic void kbd_led_update(struct work_struct *work)\r\n{\r\nint ctrl_param = 0;\r\nstruct asus_wmi *asus;\r\nasus = container_of(work, struct asus_wmi, kbd_led_work);\r\nif (asus->kbd_led_wk > 0)\r\nctrl_param = 0x80 | (asus->kbd_led_wk & 0x7F);\r\nasus_wmi_set_devstate(ASUS_WMI_DEVID_KBD_BACKLIGHT, ctrl_param, NULL);\r\n}\r\nstatic int kbd_led_read(struct asus_wmi *asus, int *level, int *env)\r\n{\r\nint retval;\r\nretval = asus_wmi_get_devstate_bits(asus, ASUS_WMI_DEVID_KBD_BACKLIGHT,\r\n0xFFFF);\r\nif (retval == 0x8000)\r\nretval = 0;\r\nif (retval >= 0) {\r\nif (level)\r\n*level = retval & 0x7F;\r\nif (env)\r\n*env = (retval >> 8) & 0x7F;\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\nstatic void kbd_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct asus_wmi *asus;\r\nasus = container_of(led_cdev, struct asus_wmi, kbd_led);\r\nif (value > asus->kbd_led.max_brightness)\r\nvalue = asus->kbd_led.max_brightness;\r\nelse if (value < 0)\r\nvalue = 0;\r\nasus->kbd_led_wk = value;\r\nqueue_work(asus->led_workqueue, &asus->kbd_led_work);\r\n}\r\nstatic enum led_brightness kbd_led_get(struct led_classdev *led_cdev)\r\n{\r\nstruct asus_wmi *asus;\r\nint retval, value;\r\nasus = container_of(led_cdev, struct asus_wmi, kbd_led);\r\nretval = kbd_led_read(asus, &value, NULL);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn value;\r\n}\r\nstatic void asus_wmi_led_exit(struct asus_wmi *asus)\r\n{\r\nif (!IS_ERR_OR_NULL(asus->kbd_led.dev))\r\nled_classdev_unregister(&asus->kbd_led);\r\nif (!IS_ERR_OR_NULL(asus->tpd_led.dev))\r\nled_classdev_unregister(&asus->tpd_led);\r\nif (asus->led_workqueue)\r\ndestroy_workqueue(asus->led_workqueue);\r\n}\r\nstatic int asus_wmi_led_init(struct asus_wmi *asus)\r\n{\r\nint rv = 0;\r\nasus->led_workqueue = create_singlethread_workqueue("led_workqueue");\r\nif (!asus->led_workqueue)\r\nreturn -ENOMEM;\r\nif (read_tpd_led_state(asus) >= 0) {\r\nINIT_WORK(&asus->tpd_led_work, tpd_led_update);\r\nasus->tpd_led.name = "asus::touchpad";\r\nasus->tpd_led.brightness_set = tpd_led_set;\r\nasus->tpd_led.brightness_get = tpd_led_get;\r\nasus->tpd_led.max_brightness = 1;\r\nrv = led_classdev_register(&asus->platform_device->dev,\r\n&asus->tpd_led);\r\nif (rv)\r\ngoto error;\r\n}\r\nif (kbd_led_read(asus, NULL, NULL) >= 0) {\r\nINIT_WORK(&asus->kbd_led_work, kbd_led_update);\r\nasus->kbd_led.name = "asus::kbd_backlight";\r\nasus->kbd_led.brightness_set = kbd_led_set;\r\nasus->kbd_led.brightness_get = kbd_led_get;\r\nasus->kbd_led.max_brightness = 3;\r\nrv = led_classdev_register(&asus->platform_device->dev,\r\n&asus->kbd_led);\r\n}\r\nerror:\r\nif (rv)\r\nasus_wmi_led_exit(asus);\r\nreturn rv;\r\n}\r\nstatic bool asus_wlan_rfkill_blocked(struct asus_wmi *asus)\r\n{\r\nint result = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WLAN);\r\nif (result < 0)\r\nreturn false;\r\nreturn !result;\r\n}\r\nstatic void asus_rfkill_hotplug(struct asus_wmi *asus)\r\n{\r\nstruct pci_dev *dev;\r\nstruct pci_bus *bus;\r\nbool blocked;\r\nbool absent;\r\nu32 l;\r\nmutex_lock(&asus->wmi_lock);\r\nblocked = asus_wlan_rfkill_blocked(asus);\r\nmutex_unlock(&asus->wmi_lock);\r\nmutex_lock(&asus->hotplug_lock);\r\nif (asus->wlan.rfkill)\r\nrfkill_set_sw_state(asus->wlan.rfkill, blocked);\r\nif (asus->hotplug_slot) {\r\nbus = pci_find_bus(0, 1);\r\nif (!bus) {\r\npr_warn("Unable to find PCI bus 1?\n");\r\ngoto out_unlock;\r\n}\r\nif (pci_bus_read_config_dword(bus, 0, PCI_VENDOR_ID, &l)) {\r\npr_err("Unable to read PCI config space?\n");\r\ngoto out_unlock;\r\n}\r\nabsent = (l == 0xffffffff);\r\nif (blocked != absent) {\r\npr_warn("BIOS says wireless lan is %s, "\r\n"but the pci device is %s\n",\r\nblocked ? "blocked" : "unblocked",\r\nabsent ? "absent" : "present");\r\npr_warn("skipped wireless hotplug as probably "\r\n"inappropriate for this model\n");\r\ngoto out_unlock;\r\n}\r\nif (!blocked) {\r\ndev = pci_get_slot(bus, 0);\r\nif (dev) {\r\npci_dev_put(dev);\r\ngoto out_unlock;\r\n}\r\ndev = pci_scan_single_device(bus, 0);\r\nif (dev) {\r\npci_bus_assign_resources(bus);\r\nif (pci_bus_add_device(dev))\r\npr_err("Unable to hotplug wifi\n");\r\n}\r\n} else {\r\ndev = pci_get_slot(bus, 0);\r\nif (dev) {\r\npci_stop_and_remove_bus_device(dev);\r\npci_dev_put(dev);\r\n}\r\n}\r\n}\r\nout_unlock:\r\nmutex_unlock(&asus->hotplug_lock);\r\n}\r\nstatic void asus_rfkill_notify(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct asus_wmi *asus = data;\r\nif (event != ACPI_NOTIFY_BUS_CHECK)\r\nreturn;\r\nqueue_work(asus->hotplug_workqueue, &asus->hotplug_work);\r\n}\r\nstatic int asus_register_rfkill_notifier(struct asus_wmi *asus, char *node)\r\n{\r\nacpi_status status;\r\nacpi_handle handle;\r\nstatus = acpi_get_handle(NULL, node, &handle);\r\nif (ACPI_SUCCESS(status)) {\r\nstatus = acpi_install_notify_handler(handle,\r\nACPI_SYSTEM_NOTIFY,\r\nasus_rfkill_notify, asus);\r\nif (ACPI_FAILURE(status))\r\npr_warn("Failed to register notify on %s\n", node);\r\n} else\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void asus_unregister_rfkill_notifier(struct asus_wmi *asus, char *node)\r\n{\r\nacpi_status status = AE_OK;\r\nacpi_handle handle;\r\nstatus = acpi_get_handle(NULL, node, &handle);\r\nif (ACPI_SUCCESS(status)) {\r\nstatus = acpi_remove_notify_handler(handle,\r\nACPI_SYSTEM_NOTIFY,\r\nasus_rfkill_notify);\r\nif (ACPI_FAILURE(status))\r\npr_err("Error removing rfkill notify handler %s\n",\r\nnode);\r\n}\r\n}\r\nstatic int asus_get_adapter_status(struct hotplug_slot *hotplug_slot,\r\nu8 *value)\r\n{\r\nstruct asus_wmi *asus = hotplug_slot->private;\r\nint result = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WLAN);\r\nif (result < 0)\r\nreturn result;\r\n*value = !!result;\r\nreturn 0;\r\n}\r\nstatic void asus_cleanup_pci_hotplug(struct hotplug_slot *hotplug_slot)\r\n{\r\nkfree(hotplug_slot->info);\r\nkfree(hotplug_slot);\r\n}\r\nstatic void asus_hotplug_work(struct work_struct *work)\r\n{\r\nstruct asus_wmi *asus;\r\nasus = container_of(work, struct asus_wmi, hotplug_work);\r\nasus_rfkill_hotplug(asus);\r\n}\r\nstatic int asus_setup_pci_hotplug(struct asus_wmi *asus)\r\n{\r\nint ret = -ENOMEM;\r\nstruct pci_bus *bus = pci_find_bus(0, 1);\r\nif (!bus) {\r\npr_err("Unable to find wifi PCI bus\n");\r\nreturn -ENODEV;\r\n}\r\nasus->hotplug_workqueue =\r\ncreate_singlethread_workqueue("hotplug_workqueue");\r\nif (!asus->hotplug_workqueue)\r\ngoto error_workqueue;\r\nINIT_WORK(&asus->hotplug_work, asus_hotplug_work);\r\nasus->hotplug_slot = kzalloc(sizeof(struct hotplug_slot), GFP_KERNEL);\r\nif (!asus->hotplug_slot)\r\ngoto error_slot;\r\nasus->hotplug_slot->info = kzalloc(sizeof(struct hotplug_slot_info),\r\nGFP_KERNEL);\r\nif (!asus->hotplug_slot->info)\r\ngoto error_info;\r\nasus->hotplug_slot->private = asus;\r\nasus->hotplug_slot->release = &asus_cleanup_pci_hotplug;\r\nasus->hotplug_slot->ops = &asus_hotplug_slot_ops;\r\nasus_get_adapter_status(asus->hotplug_slot,\r\n&asus->hotplug_slot->info->adapter_status);\r\nret = pci_hp_register(asus->hotplug_slot, bus, 0, "asus-wifi");\r\nif (ret) {\r\npr_err("Unable to register hotplug slot - %d\n", ret);\r\ngoto error_register;\r\n}\r\nreturn 0;\r\nerror_register:\r\nkfree(asus->hotplug_slot->info);\r\nerror_info:\r\nkfree(asus->hotplug_slot);\r\nasus->hotplug_slot = NULL;\r\nerror_slot:\r\ndestroy_workqueue(asus->hotplug_workqueue);\r\nerror_workqueue:\r\nreturn ret;\r\n}\r\nstatic int asus_rfkill_set(void *data, bool blocked)\r\n{\r\nstruct asus_rfkill *priv = data;\r\nu32 ctrl_param = !blocked;\r\nu32 dev_id = priv->dev_id;\r\nif ((dev_id == ASUS_WMI_DEVID_WLAN) &&\r\npriv->asus->driver->wlan_ctrl_by_user)\r\ndev_id = ASUS_WMI_DEVID_WLAN_LED;\r\nreturn asus_wmi_set_devstate(dev_id, ctrl_param, NULL);\r\n}\r\nstatic void asus_rfkill_query(struct rfkill *rfkill, void *data)\r\n{\r\nstruct asus_rfkill *priv = data;\r\nint result;\r\nresult = asus_wmi_get_devstate_simple(priv->asus, priv->dev_id);\r\nif (result < 0)\r\nreturn;\r\nrfkill_set_sw_state(priv->rfkill, !result);\r\n}\r\nstatic int asus_rfkill_wlan_set(void *data, bool blocked)\r\n{\r\nstruct asus_rfkill *priv = data;\r\nstruct asus_wmi *asus = priv->asus;\r\nint ret;\r\nmutex_lock(&asus->wmi_lock);\r\nret = asus_rfkill_set(data, blocked);\r\nmutex_unlock(&asus->wmi_lock);\r\nreturn ret;\r\n}\r\nstatic int asus_new_rfkill(struct asus_wmi *asus,\r\nstruct asus_rfkill *arfkill,\r\nconst char *name, enum rfkill_type type, int dev_id)\r\n{\r\nint result = asus_wmi_get_devstate_simple(asus, dev_id);\r\nstruct rfkill **rfkill = &arfkill->rfkill;\r\nif (result < 0)\r\nreturn result;\r\narfkill->dev_id = dev_id;\r\narfkill->asus = asus;\r\nif (dev_id == ASUS_WMI_DEVID_WLAN &&\r\nasus->driver->quirks->hotplug_wireless)\r\n*rfkill = rfkill_alloc(name, &asus->platform_device->dev, type,\r\n&asus_rfkill_wlan_ops, arfkill);\r\nelse\r\n*rfkill = rfkill_alloc(name, &asus->platform_device->dev, type,\r\n&asus_rfkill_ops, arfkill);\r\nif (!*rfkill)\r\nreturn -EINVAL;\r\nrfkill_init_sw_state(*rfkill, !result);\r\nresult = rfkill_register(*rfkill);\r\nif (result) {\r\nrfkill_destroy(*rfkill);\r\n*rfkill = NULL;\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void asus_wmi_rfkill_exit(struct asus_wmi *asus)\r\n{\r\nasus_unregister_rfkill_notifier(asus, "\\_SB.PCI0.P0P5");\r\nasus_unregister_rfkill_notifier(asus, "\\_SB.PCI0.P0P6");\r\nasus_unregister_rfkill_notifier(asus, "\\_SB.PCI0.P0P7");\r\nif (asus->wlan.rfkill) {\r\nrfkill_unregister(asus->wlan.rfkill);\r\nrfkill_destroy(asus->wlan.rfkill);\r\nasus->wlan.rfkill = NULL;\r\n}\r\nasus_rfkill_hotplug(asus);\r\nif (asus->hotplug_slot)\r\npci_hp_deregister(asus->hotplug_slot);\r\nif (asus->hotplug_workqueue)\r\ndestroy_workqueue(asus->hotplug_workqueue);\r\nif (asus->bluetooth.rfkill) {\r\nrfkill_unregister(asus->bluetooth.rfkill);\r\nrfkill_destroy(asus->bluetooth.rfkill);\r\nasus->bluetooth.rfkill = NULL;\r\n}\r\nif (asus->wimax.rfkill) {\r\nrfkill_unregister(asus->wimax.rfkill);\r\nrfkill_destroy(asus->wimax.rfkill);\r\nasus->wimax.rfkill = NULL;\r\n}\r\nif (asus->wwan3g.rfkill) {\r\nrfkill_unregister(asus->wwan3g.rfkill);\r\nrfkill_destroy(asus->wwan3g.rfkill);\r\nasus->wwan3g.rfkill = NULL;\r\n}\r\nif (asus->gps.rfkill) {\r\nrfkill_unregister(asus->gps.rfkill);\r\nrfkill_destroy(asus->gps.rfkill);\r\nasus->gps.rfkill = NULL;\r\n}\r\nif (asus->uwb.rfkill) {\r\nrfkill_unregister(asus->uwb.rfkill);\r\nrfkill_destroy(asus->uwb.rfkill);\r\nasus->uwb.rfkill = NULL;\r\n}\r\n}\r\nstatic int asus_wmi_rfkill_init(struct asus_wmi *asus)\r\n{\r\nint result = 0;\r\nmutex_init(&asus->hotplug_lock);\r\nmutex_init(&asus->wmi_lock);\r\nresult = asus_new_rfkill(asus, &asus->wlan, "asus-wlan",\r\nRFKILL_TYPE_WLAN, ASUS_WMI_DEVID_WLAN);\r\nif (result && result != -ENODEV)\r\ngoto exit;\r\nresult = asus_new_rfkill(asus, &asus->bluetooth,\r\n"asus-bluetooth", RFKILL_TYPE_BLUETOOTH,\r\nASUS_WMI_DEVID_BLUETOOTH);\r\nif (result && result != -ENODEV)\r\ngoto exit;\r\nresult = asus_new_rfkill(asus, &asus->wimax, "asus-wimax",\r\nRFKILL_TYPE_WIMAX, ASUS_WMI_DEVID_WIMAX);\r\nif (result && result != -ENODEV)\r\ngoto exit;\r\nresult = asus_new_rfkill(asus, &asus->wwan3g, "asus-wwan3g",\r\nRFKILL_TYPE_WWAN, ASUS_WMI_DEVID_WWAN3G);\r\nif (result && result != -ENODEV)\r\ngoto exit;\r\nresult = asus_new_rfkill(asus, &asus->gps, "asus-gps",\r\nRFKILL_TYPE_GPS, ASUS_WMI_DEVID_GPS);\r\nif (result && result != -ENODEV)\r\ngoto exit;\r\nresult = asus_new_rfkill(asus, &asus->uwb, "asus-uwb",\r\nRFKILL_TYPE_UWB, ASUS_WMI_DEVID_UWB);\r\nif (result && result != -ENODEV)\r\ngoto exit;\r\nif (!asus->driver->quirks->hotplug_wireless)\r\ngoto exit;\r\nresult = asus_setup_pci_hotplug(asus);\r\nif (result == -EBUSY)\r\nresult = 0;\r\nasus_register_rfkill_notifier(asus, "\\_SB.PCI0.P0P5");\r\nasus_register_rfkill_notifier(asus, "\\_SB.PCI0.P0P6");\r\nasus_register_rfkill_notifier(asus, "\\_SB.PCI0.P0P7");\r\nasus_rfkill_hotplug(asus);\r\nexit:\r\nif (result && result != -ENODEV)\r\nasus_wmi_rfkill_exit(asus);\r\nif (result == -ENODEV)\r\nresult = 0;\r\nreturn result;\r\n}\r\nstatic ssize_t asus_hwmon_pwm1(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asus_wmi *asus = dev_get_drvdata(dev);\r\nu32 value;\r\nint err;\r\nerr = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_FAN_CTRL, &value);\r\nif (err < 0)\r\nreturn err;\r\nvalue &= 0xFF;\r\nif (value == 1)\r\nvalue = 85;\r\nelse if (value == 2)\r\nvalue = 170;\r\nelse if (value == 3)\r\nvalue = 255;\r\nelse if (value != 0) {\r\npr_err("Unknown fan speed %#x", value);\r\nvalue = -1;\r\n}\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic ssize_t asus_hwmon_temp1(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asus_wmi *asus = dev_get_drvdata(dev);\r\nu32 value;\r\nint err;\r\nerr = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_THERMAL_CTRL, &value);\r\nif (err < 0)\r\nreturn err;\r\nvalue = KELVIN_TO_CELSIUS((value & 0xFFFF)) * 1000;\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic ssize_t\r\nshow_name(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "asus\n");\r\n}\r\nstatic umode_t asus_hwmon_sysfs_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int idx)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct platform_device *pdev = to_platform_device(dev->parent);\r\nstruct asus_wmi *asus = platform_get_drvdata(pdev);\r\nbool ok = true;\r\nint dev_id = -1;\r\nu32 value = ASUS_WMI_UNSUPPORTED_METHOD;\r\nif (attr == &sensor_dev_attr_pwm1.dev_attr.attr)\r\ndev_id = ASUS_WMI_DEVID_FAN_CTRL;\r\nelse if (attr == &sensor_dev_attr_temp1_input.dev_attr.attr)\r\ndev_id = ASUS_WMI_DEVID_THERMAL_CTRL;\r\nif (dev_id != -1) {\r\nint err = asus_wmi_get_devstate(asus, dev_id, &value);\r\nif (err < 0)\r\nreturn 0;\r\n}\r\nif (dev_id == ASUS_WMI_DEVID_FAN_CTRL) {\r\nif (value == ASUS_WMI_UNSUPPORTED_METHOD || value & 0xFFF80000\r\n|| (!asus->sfun && !(value & ASUS_WMI_DSTS_PRESENCE_BIT)))\r\nok = false;\r\n} else if (dev_id == ASUS_WMI_DEVID_THERMAL_CTRL) {\r\nif (value == 0)\r\nok = false;\r\n}\r\nreturn ok ? attr->mode : 0;\r\n}\r\nstatic void asus_wmi_hwmon_exit(struct asus_wmi *asus)\r\n{\r\nstruct device *hwmon;\r\nhwmon = asus->hwmon_device;\r\nif (!hwmon)\r\nreturn;\r\nsysfs_remove_group(&hwmon->kobj, &hwmon_attribute_group);\r\nhwmon_device_unregister(hwmon);\r\nasus->hwmon_device = NULL;\r\n}\r\nstatic int asus_wmi_hwmon_init(struct asus_wmi *asus)\r\n{\r\nstruct device *hwmon;\r\nint result;\r\nhwmon = hwmon_device_register(&asus->platform_device->dev);\r\nif (IS_ERR(hwmon)) {\r\npr_err("Could not register asus hwmon device\n");\r\nreturn PTR_ERR(hwmon);\r\n}\r\ndev_set_drvdata(hwmon, asus);\r\nasus->hwmon_device = hwmon;\r\nresult = sysfs_create_group(&hwmon->kobj, &hwmon_attribute_group);\r\nif (result)\r\nasus_wmi_hwmon_exit(asus);\r\nreturn result;\r\n}\r\nstatic int read_backlight_power(struct asus_wmi *asus)\r\n{\r\nint ret;\r\nif (asus->driver->quirks->store_backlight_power)\r\nret = !asus->driver->panel_power;\r\nelse\r\nret = asus_wmi_get_devstate_simple(asus,\r\nASUS_WMI_DEVID_BACKLIGHT);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret ? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;\r\n}\r\nstatic int read_brightness_max(struct asus_wmi *asus)\r\n{\r\nu32 retval;\r\nint err;\r\nerr = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_BRIGHTNESS, &retval);\r\nif (err < 0)\r\nreturn err;\r\nretval = retval & ASUS_WMI_DSTS_MAX_BRIGTH_MASK;\r\nretval >>= 8;\r\nif (!retval)\r\nreturn -ENODEV;\r\nreturn retval;\r\n}\r\nstatic int read_brightness(struct backlight_device *bd)\r\n{\r\nstruct asus_wmi *asus = bl_get_data(bd);\r\nu32 retval;\r\nint err;\r\nerr = asus_wmi_get_devstate(asus, ASUS_WMI_DEVID_BRIGHTNESS, &retval);\r\nif (err < 0)\r\nreturn err;\r\nreturn retval & ASUS_WMI_DSTS_BRIGHTNESS_MASK;\r\n}\r\nstatic u32 get_scalar_command(struct backlight_device *bd)\r\n{\r\nstruct asus_wmi *asus = bl_get_data(bd);\r\nu32 ctrl_param = 0;\r\nif ((asus->driver->brightness < bd->props.brightness) ||\r\nbd->props.brightness == bd->props.max_brightness)\r\nctrl_param = 0x00008001;\r\nelse if ((asus->driver->brightness > bd->props.brightness) ||\r\nbd->props.brightness == 0)\r\nctrl_param = 0x00008000;\r\nasus->driver->brightness = bd->props.brightness;\r\nreturn ctrl_param;\r\n}\r\nstatic int update_bl_status(struct backlight_device *bd)\r\n{\r\nstruct asus_wmi *asus = bl_get_data(bd);\r\nu32 ctrl_param;\r\nint power, err = 0;\r\npower = read_backlight_power(asus);\r\nif (power != -ENODEV && bd->props.power != power) {\r\nctrl_param = !!(bd->props.power == FB_BLANK_UNBLANK);\r\nerr = asus_wmi_set_devstate(ASUS_WMI_DEVID_BACKLIGHT,\r\nctrl_param, NULL);\r\nif (asus->driver->quirks->store_backlight_power)\r\nasus->driver->panel_power = bd->props.power;\r\nif (asus->driver->quirks->scalar_panel_brightness)\r\nreturn err;\r\n}\r\nif (asus->driver->quirks->scalar_panel_brightness)\r\nctrl_param = get_scalar_command(bd);\r\nelse\r\nctrl_param = bd->props.brightness;\r\nerr = asus_wmi_set_devstate(ASUS_WMI_DEVID_BRIGHTNESS,\r\nctrl_param, NULL);\r\nreturn err;\r\n}\r\nstatic int asus_wmi_backlight_notify(struct asus_wmi *asus, int code)\r\n{\r\nstruct backlight_device *bd = asus->backlight_device;\r\nint old = bd->props.brightness;\r\nint new = old;\r\nif (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)\r\nnew = code - NOTIFY_BRNUP_MIN + 1;\r\nelse if (code >= NOTIFY_BRNDOWN_MIN && code <= NOTIFY_BRNDOWN_MAX)\r\nnew = code - NOTIFY_BRNDOWN_MIN;\r\nbd->props.brightness = new;\r\nbacklight_update_status(bd);\r\nbacklight_force_update(bd, BACKLIGHT_UPDATE_HOTKEY);\r\nreturn old;\r\n}\r\nstatic int asus_wmi_backlight_init(struct asus_wmi *asus)\r\n{\r\nstruct backlight_device *bd;\r\nstruct backlight_properties props;\r\nint max;\r\nint power;\r\nmax = read_brightness_max(asus);\r\nif (max == -ENODEV)\r\nmax = 0;\r\nelse if (max < 0)\r\nreturn max;\r\npower = read_backlight_power(asus);\r\nif (power == -ENODEV)\r\npower = FB_BLANK_UNBLANK;\r\nelse if (power < 0)\r\nreturn power;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = max;\r\nbd = backlight_device_register(asus->driver->name,\r\n&asus->platform_device->dev, asus,\r\n&asus_wmi_bl_ops, &props);\r\nif (IS_ERR(bd)) {\r\npr_err("Could not register backlight device\n");\r\nreturn PTR_ERR(bd);\r\n}\r\nasus->backlight_device = bd;\r\nif (asus->driver->quirks->store_backlight_power)\r\nasus->driver->panel_power = power;\r\nbd->props.brightness = read_brightness(bd);\r\nbd->props.power = power;\r\nbacklight_update_status(bd);\r\nasus->driver->brightness = bd->props.brightness;\r\nreturn 0;\r\n}\r\nstatic void asus_wmi_backlight_exit(struct asus_wmi *asus)\r\n{\r\nif (asus->backlight_device)\r\nbacklight_device_unregister(asus->backlight_device);\r\nasus->backlight_device = NULL;\r\n}\r\nstatic void asus_wmi_notify(u32 value, void *context)\r\n{\r\nstruct asus_wmi *asus = context;\r\nstruct acpi_buffer response = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nacpi_status status;\r\nint code;\r\nint orig_code;\r\nunsigned int key_value = 1;\r\nbool autorelease = 1;\r\nstatus = wmi_get_event_data(value, &response);\r\nif (status != AE_OK) {\r\npr_err("bad event status 0x%x\n", status);\r\nreturn;\r\n}\r\nobj = (union acpi_object *)response.pointer;\r\nif (!obj || obj->type != ACPI_TYPE_INTEGER)\r\ngoto exit;\r\ncode = obj->integer.value;\r\norig_code = code;\r\nif (asus->driver->key_filter) {\r\nasus->driver->key_filter(asus->driver, &code, &key_value,\r\n&autorelease);\r\nif (code == ASUS_WMI_KEY_IGNORE)\r\ngoto exit;\r\n}\r\nif (code >= NOTIFY_BRNUP_MIN && code <= NOTIFY_BRNUP_MAX)\r\ncode = NOTIFY_BRNUP_MIN;\r\nelse if (code >= NOTIFY_BRNDOWN_MIN &&\r\ncode <= NOTIFY_BRNDOWN_MAX)\r\ncode = NOTIFY_BRNDOWN_MIN;\r\nif (code == NOTIFY_BRNUP_MIN || code == NOTIFY_BRNDOWN_MIN) {\r\nif (!acpi_video_backlight_support())\r\nasus_wmi_backlight_notify(asus, orig_code);\r\n} else if (!sparse_keymap_report_event(asus->inputdev, code,\r\nkey_value, autorelease))\r\npr_info("Unknown key %x pressed\n", code);\r\nexit:\r\nkfree(obj);\r\n}\r\nstatic int parse_arg(const char *buf, unsigned long count, int *val)\r\n{\r\nif (!count)\r\nreturn 0;\r\nif (sscanf(buf, "%i", val) != 1)\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic ssize_t store_sys_wmi(struct asus_wmi *asus, int devid,\r\nconst char *buf, size_t count)\r\n{\r\nu32 retval;\r\nint rv, err, value;\r\nvalue = asus_wmi_get_devstate_simple(asus, devid);\r\nif (value == -ENODEV)\r\nreturn value;\r\nrv = parse_arg(buf, count, &value);\r\nerr = asus_wmi_set_devstate(devid, value, &retval);\r\nif (err < 0)\r\nreturn err;\r\nreturn rv;\r\n}\r\nstatic ssize_t show_sys_wmi(struct asus_wmi *asus, int devid, char *buf)\r\n{\r\nint value = asus_wmi_get_devstate_simple(asus, devid);\r\nif (value < 0)\r\nreturn value;\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic ssize_t store_cpufv(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint value, rv;\r\nif (!count || sscanf(buf, "%i", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < 0 || value > 2)\r\nreturn -EINVAL;\r\nrv = asus_wmi_evaluate_method(ASUS_WMI_METHODID_CFVS, value, 0, NULL);\r\nif (rv < 0)\r\nreturn rv;\r\nreturn count;\r\n}\r\nstatic umode_t asus_sysfs_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int idx)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct asus_wmi *asus = platform_get_drvdata(pdev);\r\nbool ok = true;\r\nint devid = -1;\r\nif (attr == &dev_attr_camera.attr)\r\ndevid = ASUS_WMI_DEVID_CAMERA;\r\nelse if (attr == &dev_attr_cardr.attr)\r\ndevid = ASUS_WMI_DEVID_CARDREADER;\r\nelse if (attr == &dev_attr_touchpad.attr)\r\ndevid = ASUS_WMI_DEVID_TOUCHPAD;\r\nelse if (attr == &dev_attr_lid_resume.attr)\r\ndevid = ASUS_WMI_DEVID_LID_RESUME;\r\nif (devid != -1)\r\nok = !(asus_wmi_get_devstate_simple(asus, devid) < 0);\r\nreturn ok ? attr->mode : 0;\r\n}\r\nstatic void asus_wmi_sysfs_exit(struct platform_device *device)\r\n{\r\nsysfs_remove_group(&device->dev.kobj, &platform_attribute_group);\r\n}\r\nstatic int asus_wmi_sysfs_init(struct platform_device *device)\r\n{\r\nreturn sysfs_create_group(&device->dev.kobj, &platform_attribute_group);\r\n}\r\nstatic int asus_wmi_platform_init(struct asus_wmi *asus)\r\n{\r\nint rv;\r\nif (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_INIT, 0, 0, &rv))\r\npr_info("Initialization: %#x", rv);\r\nif (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_SPEC, 0, 0x9, &rv)) {\r\npr_info("BIOS WMI version: %d.%d", rv >> 16, rv & 0xFF);\r\nasus->spec = rv;\r\n}\r\nif (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_SFUN, 0, 0, &rv)) {\r\npr_info("SFUN value: %#x", rv);\r\nasus->sfun = rv;\r\n}\r\nif (!asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS, 0, 0, NULL))\r\nasus->dsts_id = ASUS_WMI_METHODID_DSTS;\r\nelse\r\nasus->dsts_id = ASUS_WMI_METHODID_DSTS2;\r\nif (asus->driver->quirks->wapf >= 0)\r\nasus_wmi_set_devstate(ASUS_WMI_DEVID_CWAP,\r\nasus->driver->quirks->wapf, NULL);\r\nreturn asus_wmi_sysfs_init(asus->platform_device);\r\n}\r\nstatic void asus_wmi_platform_exit(struct asus_wmi *asus)\r\n{\r\nasus_wmi_sysfs_exit(asus->platform_device);\r\n}\r\nstatic int show_dsts(struct seq_file *m, void *data)\r\n{\r\nstruct asus_wmi *asus = m->private;\r\nint err;\r\nu32 retval = -1;\r\nerr = asus_wmi_get_devstate(asus, asus->debug.dev_id, &retval);\r\nif (err < 0)\r\nreturn err;\r\nseq_printf(m, "DSTS(%#x) = %#x\n", asus->debug.dev_id, retval);\r\nreturn 0;\r\n}\r\nstatic int show_devs(struct seq_file *m, void *data)\r\n{\r\nstruct asus_wmi *asus = m->private;\r\nint err;\r\nu32 retval = -1;\r\nerr = asus_wmi_set_devstate(asus->debug.dev_id, asus->debug.ctrl_param,\r\n&retval);\r\nif (err < 0)\r\nreturn err;\r\nseq_printf(m, "DEVS(%#x, %#x) = %#x\n", asus->debug.dev_id,\r\nasus->debug.ctrl_param, retval);\r\nreturn 0;\r\n}\r\nstatic int show_call(struct seq_file *m, void *data)\r\n{\r\nstruct asus_wmi *asus = m->private;\r\nstruct bios_args args = {\r\n.arg0 = asus->debug.dev_id,\r\n.arg1 = asus->debug.ctrl_param,\r\n};\r\nstruct acpi_buffer input = { (acpi_size) sizeof(args), &args };\r\nstruct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj;\r\nacpi_status status;\r\nstatus = wmi_evaluate_method(ASUS_WMI_MGMT_GUID,\r\n1, asus->debug.method_id,\r\n&input, &output);\r\nif (ACPI_FAILURE(status))\r\nreturn -EIO;\r\nobj = (union acpi_object *)output.pointer;\r\nif (obj && obj->type == ACPI_TYPE_INTEGER)\r\nseq_printf(m, "%#x(%#x, %#x) = %#x\n", asus->debug.method_id,\r\nasus->debug.dev_id, asus->debug.ctrl_param,\r\n(u32) obj->integer.value);\r\nelse\r\nseq_printf(m, "%#x(%#x, %#x) = t:%d\n", asus->debug.method_id,\r\nasus->debug.dev_id, asus->debug.ctrl_param,\r\nobj ? obj->type : -1);\r\nkfree(obj);\r\nreturn 0;\r\n}\r\nstatic int asus_wmi_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nstruct asus_wmi_debugfs_node *node = inode->i_private;\r\nreturn single_open(file, node->show, node->asus);\r\n}\r\nstatic void asus_wmi_debugfs_exit(struct asus_wmi *asus)\r\n{\r\ndebugfs_remove_recursive(asus->debug.root);\r\n}\r\nstatic int asus_wmi_debugfs_init(struct asus_wmi *asus)\r\n{\r\nstruct dentry *dent;\r\nint i;\r\nasus->debug.root = debugfs_create_dir(asus->driver->name, NULL);\r\nif (!asus->debug.root) {\r\npr_err("failed to create debugfs directory");\r\ngoto error_debugfs;\r\n}\r\ndent = debugfs_create_x32("method_id", S_IRUGO | S_IWUSR,\r\nasus->debug.root, &asus->debug.method_id);\r\nif (!dent)\r\ngoto error_debugfs;\r\ndent = debugfs_create_x32("dev_id", S_IRUGO | S_IWUSR,\r\nasus->debug.root, &asus->debug.dev_id);\r\nif (!dent)\r\ngoto error_debugfs;\r\ndent = debugfs_create_x32("ctrl_param", S_IRUGO | S_IWUSR,\r\nasus->debug.root, &asus->debug.ctrl_param);\r\nif (!dent)\r\ngoto error_debugfs;\r\nfor (i = 0; i < ARRAY_SIZE(asus_wmi_debug_files); i++) {\r\nstruct asus_wmi_debugfs_node *node = &asus_wmi_debug_files[i];\r\nnode->asus = asus;\r\ndent = debugfs_create_file(node->name, S_IFREG | S_IRUGO,\r\nasus->debug.root, node,\r\n&asus_wmi_debugfs_io_ops);\r\nif (!dent) {\r\npr_err("failed to create debug file: %s\n", node->name);\r\ngoto error_debugfs;\r\n}\r\n}\r\nreturn 0;\r\nerror_debugfs:\r\nasus_wmi_debugfs_exit(asus);\r\nreturn -ENOMEM;\r\n}\r\nstatic int asus_wmi_add(struct platform_device *pdev)\r\n{\r\nstruct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);\r\nstruct asus_wmi_driver *wdrv = to_asus_wmi_driver(pdrv);\r\nstruct asus_wmi *asus;\r\nacpi_status status;\r\nint err;\r\nu32 result;\r\nasus = kzalloc(sizeof(struct asus_wmi), GFP_KERNEL);\r\nif (!asus)\r\nreturn -ENOMEM;\r\nasus->driver = wdrv;\r\nasus->platform_device = pdev;\r\nwdrv->platform_device = pdev;\r\nplatform_set_drvdata(asus->platform_device, asus);\r\nif (wdrv->detect_quirks)\r\nwdrv->detect_quirks(asus->driver);\r\nerr = asus_wmi_platform_init(asus);\r\nif (err)\r\ngoto fail_platform;\r\nerr = asus_wmi_input_init(asus);\r\nif (err)\r\ngoto fail_input;\r\nerr = asus_wmi_hwmon_init(asus);\r\nif (err)\r\ngoto fail_hwmon;\r\nerr = asus_wmi_led_init(asus);\r\nif (err)\r\ngoto fail_leds;\r\nerr = asus_wmi_rfkill_init(asus);\r\nif (err)\r\ngoto fail_rfkill;\r\nif (asus->driver->quirks->wmi_backlight_power)\r\nacpi_video_dmi_promote_vendor();\r\nif (!acpi_video_backlight_support()) {\r\npr_info("Disabling ACPI video driver\n");\r\nacpi_video_unregister();\r\nerr = asus_wmi_backlight_init(asus);\r\nif (err && err != -ENODEV)\r\ngoto fail_backlight;\r\n} else\r\npr_info("Backlight controlled by ACPI video driver\n");\r\nstatus = wmi_install_notify_handler(asus->driver->event_guid,\r\nasus_wmi_notify, asus);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("Unable to register notify handler - %d\n", status);\r\nerr = -ENODEV;\r\ngoto fail_wmi_handler;\r\n}\r\nerr = asus_wmi_debugfs_init(asus);\r\nif (err)\r\ngoto fail_debugfs;\r\nasus_wmi_get_devstate(asus, ASUS_WMI_DEVID_WLAN, &result);\r\nif (result & (ASUS_WMI_DSTS_PRESENCE_BIT | ASUS_WMI_DSTS_USER_BIT))\r\nasus->driver->wlan_ctrl_by_user = 1;\r\nreturn 0;\r\nfail_debugfs:\r\nwmi_remove_notify_handler(asus->driver->event_guid);\r\nfail_wmi_handler:\r\nasus_wmi_backlight_exit(asus);\r\nfail_backlight:\r\nasus_wmi_rfkill_exit(asus);\r\nfail_rfkill:\r\nasus_wmi_led_exit(asus);\r\nfail_leds:\r\nasus_wmi_hwmon_exit(asus);\r\nfail_hwmon:\r\nasus_wmi_input_exit(asus);\r\nfail_input:\r\nasus_wmi_platform_exit(asus);\r\nfail_platform:\r\nkfree(asus);\r\nreturn err;\r\n}\r\nstatic int asus_wmi_remove(struct platform_device *device)\r\n{\r\nstruct asus_wmi *asus;\r\nasus = platform_get_drvdata(device);\r\nwmi_remove_notify_handler(asus->driver->event_guid);\r\nasus_wmi_backlight_exit(asus);\r\nasus_wmi_input_exit(asus);\r\nasus_wmi_hwmon_exit(asus);\r\nasus_wmi_led_exit(asus);\r\nasus_wmi_rfkill_exit(asus);\r\nasus_wmi_debugfs_exit(asus);\r\nasus_wmi_platform_exit(asus);\r\nkfree(asus);\r\nreturn 0;\r\n}\r\nstatic int asus_hotk_thaw(struct device *device)\r\n{\r\nstruct asus_wmi *asus = dev_get_drvdata(device);\r\nif (asus->wlan.rfkill) {\r\nbool wlan;\r\nwlan = asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WLAN);\r\nasus_wmi_set_devstate(ASUS_WMI_DEVID_WLAN, wlan, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int asus_hotk_restore(struct device *device)\r\n{\r\nstruct asus_wmi *asus = dev_get_drvdata(device);\r\nint bl;\r\nif (asus->wlan.rfkill)\r\nasus_rfkill_hotplug(asus);\r\nif (asus->bluetooth.rfkill) {\r\nbl = !asus_wmi_get_devstate_simple(asus,\r\nASUS_WMI_DEVID_BLUETOOTH);\r\nrfkill_set_sw_state(asus->bluetooth.rfkill, bl);\r\n}\r\nif (asus->wimax.rfkill) {\r\nbl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WIMAX);\r\nrfkill_set_sw_state(asus->wimax.rfkill, bl);\r\n}\r\nif (asus->wwan3g.rfkill) {\r\nbl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_WWAN3G);\r\nrfkill_set_sw_state(asus->wwan3g.rfkill, bl);\r\n}\r\nif (asus->gps.rfkill) {\r\nbl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_GPS);\r\nrfkill_set_sw_state(asus->gps.rfkill, bl);\r\n}\r\nif (asus->uwb.rfkill) {\r\nbl = !asus_wmi_get_devstate_simple(asus, ASUS_WMI_DEVID_UWB);\r\nrfkill_set_sw_state(asus->uwb.rfkill, bl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int asus_wmi_probe(struct platform_device *pdev)\r\n{\r\nstruct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);\r\nstruct asus_wmi_driver *wdrv = to_asus_wmi_driver(pdrv);\r\nint ret;\r\nif (!wmi_has_guid(ASUS_WMI_MGMT_GUID)) {\r\npr_warn("Management GUID not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (wdrv->event_guid && !wmi_has_guid(wdrv->event_guid)) {\r\npr_warn("Event GUID not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (wdrv->probe) {\r\nret = wdrv->probe(pdev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn asus_wmi_add(pdev);\r\n}\r\nint __init_or_module asus_wmi_register_driver(struct asus_wmi_driver *driver)\r\n{\r\nstruct platform_driver *platform_driver;\r\nstruct platform_device *platform_device;\r\nif (used)\r\nreturn -EBUSY;\r\nplatform_driver = &driver->platform_driver;\r\nplatform_driver->remove = asus_wmi_remove;\r\nplatform_driver->driver.owner = driver->owner;\r\nplatform_driver->driver.name = driver->name;\r\nplatform_driver->driver.pm = &asus_pm_ops;\r\nplatform_device = platform_create_bundle(platform_driver,\r\nasus_wmi_probe,\r\nNULL, 0, NULL, 0);\r\nif (IS_ERR(platform_device))\r\nreturn PTR_ERR(platform_device);\r\nused = true;\r\nreturn 0;\r\n}\r\nvoid asus_wmi_unregister_driver(struct asus_wmi_driver *driver)\r\n{\r\nplatform_device_unregister(driver->platform_device);\r\nplatform_driver_unregister(&driver->platform_driver);\r\nused = false;\r\n}\r\nstatic int __init asus_wmi_init(void)\r\n{\r\nif (!wmi_has_guid(ASUS_WMI_MGMT_GUID)) {\r\npr_info("Asus Management GUID not found");\r\nreturn -ENODEV;\r\n}\r\npr_info("ASUS WMI generic driver loaded");\r\nreturn 0;\r\n}\r\nstatic void __exit asus_wmi_exit(void)\r\n{\r\npr_info("ASUS WMI generic driver unloaded");\r\n}
