static inline struct task_struct *find_process_by_pid(pid_t pid)\r\n{\r\nreturn pid ? find_task_by_vpid(pid) : current;\r\n}\r\nstatic bool check_same_owner(struct task_struct *p)\r\n{\r\nconst struct cred *cred = current_cred(), *pcred;\r\nbool match;\r\nrcu_read_lock();\r\npcred = __task_cred(p);\r\nmatch = (cred->euid == pcred->euid ||\r\ncred->euid == pcred->uid);\r\nrcu_read_unlock();\r\nreturn match;\r\n}\r\nasmlinkage long mipsmt_sys_sched_setaffinity(pid_t pid, unsigned int len,\r\nunsigned long __user *user_mask_ptr)\r\n{\r\ncpumask_var_t cpus_allowed, new_mask, effective_mask;\r\nstruct thread_info *ti;\r\nstruct task_struct *p;\r\nint retval;\r\nif (len < sizeof(new_mask))\r\nreturn -EINVAL;\r\nif (copy_from_user(&new_mask, user_mask_ptr, sizeof(new_mask)))\r\nreturn -EFAULT;\r\nget_online_cpus();\r\nrcu_read_lock();\r\np = find_process_by_pid(pid);\r\nif (!p) {\r\nrcu_read_unlock();\r\nput_online_cpus();\r\nreturn -ESRCH;\r\n}\r\nget_task_struct(p);\r\nrcu_read_unlock();\r\nif (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) {\r\nretval = -ENOMEM;\r\ngoto out_put_task;\r\n}\r\nif (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) {\r\nretval = -ENOMEM;\r\ngoto out_free_cpus_allowed;\r\n}\r\nif (!alloc_cpumask_var(&effective_mask, GFP_KERNEL)) {\r\nretval = -ENOMEM;\r\ngoto out_free_new_mask;\r\n}\r\nretval = -EPERM;\r\nif (!check_same_owner(p) && !capable(CAP_SYS_NICE))\r\ngoto out_unlock;\r\nretval = security_task_setscheduler(p);\r\nif (retval)\r\ngoto out_unlock;\r\ncpumask_copy(&p->thread.user_cpus_allowed, new_mask);\r\nagain:\r\nti = task_thread_info(p);\r\nif (test_ti_thread_flag(ti, TIF_FPUBOUND) &&\r\ncpus_intersects(*new_mask, mt_fpu_cpumask)) {\r\ncpus_and(*effective_mask, *new_mask, mt_fpu_cpumask);\r\nretval = set_cpus_allowed_ptr(p, effective_mask);\r\n} else {\r\ncpumask_copy(effective_mask, new_mask);\r\nclear_ti_thread_flag(ti, TIF_FPUBOUND);\r\nretval = set_cpus_allowed_ptr(p, new_mask);\r\n}\r\nif (!retval) {\r\ncpuset_cpus_allowed(p, cpus_allowed);\r\nif (!cpumask_subset(effective_mask, cpus_allowed)) {\r\ncpumask_copy(new_mask, cpus_allowed);\r\ngoto again;\r\n}\r\n}\r\nout_unlock:\r\nfree_cpumask_var(effective_mask);\r\nout_free_new_mask:\r\nfree_cpumask_var(new_mask);\r\nout_free_cpus_allowed:\r\nfree_cpumask_var(cpus_allowed);\r\nout_put_task:\r\nput_task_struct(p);\r\nput_online_cpus();\r\nreturn retval;\r\n}\r\nasmlinkage long mipsmt_sys_sched_getaffinity(pid_t pid, unsigned int len,\r\nunsigned long __user *user_mask_ptr)\r\n{\r\nunsigned int real_len;\r\ncpumask_t mask;\r\nint retval;\r\nstruct task_struct *p;\r\nreal_len = sizeof(mask);\r\nif (len < real_len)\r\nreturn -EINVAL;\r\nget_online_cpus();\r\nread_lock(&tasklist_lock);\r\nretval = -ESRCH;\r\np = find_process_by_pid(pid);\r\nif (!p)\r\ngoto out_unlock;\r\nretval = security_task_getscheduler(p);\r\nif (retval)\r\ngoto out_unlock;\r\ncpumask_and(&mask, &p->thread.user_cpus_allowed, cpu_possible_mask);\r\nout_unlock:\r\nread_unlock(&tasklist_lock);\r\nput_online_cpus();\r\nif (retval)\r\nreturn retval;\r\nif (copy_to_user(user_mask_ptr, &mask, real_len))\r\nreturn -EFAULT;\r\nreturn real_len;\r\n}\r\nstatic int __init fpaff_thresh(char *str)\r\n{\r\nget_option(&str, &fpaff_threshold);\r\nreturn 1;\r\n}\r\nstatic __init int mt_fp_affinity_init(void)\r\n{\r\nif (fpaff_threshold >= 0) {\r\nmt_fpemul_threshold = fpaff_threshold;\r\n} else {\r\nmt_fpemul_threshold =\r\n(FPUSEFACTOR * (loops_per_jiffy/(500000/HZ))) / HZ;\r\n}\r\nprintk(KERN_DEBUG "FPU Affinity set after %ld emulations\n",\r\nmt_fpemul_threshold);\r\nreturn 0;\r\n}
