static\r\nint uwbd_event_handle_urc(struct uwb_event *evt)\r\n{\r\nint result = -EINVAL;\r\nstruct uwbd_evt_type_handler *type_table;\r\nuwbd_evt_handler_f handler;\r\nu8 type, context;\r\nu16 event;\r\ntype = evt->notif.rceb->bEventType;\r\nevent = le16_to_cpu(evt->notif.rceb->wEvent);\r\ncontext = evt->notif.rceb->bEventContext;\r\nif (type >= ARRAY_SIZE(uwbd_urc_evt_type_handlers))\r\ngoto out;\r\ntype_table = &uwbd_urc_evt_type_handlers[type];\r\nif (type_table->uwbd_events == NULL)\r\ngoto out;\r\nif (event >= type_table->size)\r\ngoto out;\r\nhandler = type_table->uwbd_events[event].handler;\r\nif (handler == NULL)\r\ngoto out;\r\nresult = (*handler)(evt);\r\nout:\r\nif (result < 0)\r\ndev_err(&evt->rc->uwb_dev.dev,\r\n"UWBD: event 0x%02x/%04x/%02x, handling failed: %d\n",\r\ntype, event, context, result);\r\nreturn result;\r\n}\r\nstatic void uwbd_event_handle_message(struct uwb_event *evt)\r\n{\r\nstruct uwb_rc *rc;\r\nint result;\r\nrc = evt->rc;\r\nif (evt->message < 0 || evt->message >= ARRAY_SIZE(uwbd_message_handlers)) {\r\ndev_err(&rc->uwb_dev.dev, "UWBD: invalid message type %d\n", evt->message);\r\nreturn;\r\n}\r\nresult = uwbd_message_handlers[evt->message].handler(evt);\r\nif (result < 0)\r\ndev_err(&rc->uwb_dev.dev, "UWBD: '%s' message failed: %d\n",\r\nuwbd_message_handlers[evt->message].name, result);\r\n}\r\nstatic void uwbd_event_handle(struct uwb_event *evt)\r\n{\r\nstruct uwb_rc *rc;\r\nint should_keep;\r\nrc = evt->rc;\r\nif (rc->ready) {\r\nswitch (evt->type) {\r\ncase UWB_EVT_TYPE_NOTIF:\r\nshould_keep = uwbd_event_handle_urc(evt);\r\nif (should_keep <= 0)\r\nkfree(evt->notif.rceb);\r\nbreak;\r\ncase UWB_EVT_TYPE_MSG:\r\nuwbd_event_handle_message(evt);\r\nbreak;\r\ndefault:\r\ndev_err(&rc->uwb_dev.dev, "UWBD: invalid event type %d\n", evt->type);\r\nbreak;\r\n}\r\n}\r\n__uwb_rc_put(rc);\r\n}\r\nstatic int uwbd(void *param)\r\n{\r\nstruct uwb_rc *rc = param;\r\nunsigned long flags;\r\nstruct uwb_event *evt;\r\nint should_stop = 0;\r\nwhile (1) {\r\nwait_event_interruptible_timeout(\r\nrc->uwbd.wq,\r\n!list_empty(&rc->uwbd.event_list)\r\n|| (should_stop = kthread_should_stop()),\r\nHZ);\r\nif (should_stop)\r\nbreak;\r\ntry_to_freeze();\r\nspin_lock_irqsave(&rc->uwbd.event_list_lock, flags);\r\nif (!list_empty(&rc->uwbd.event_list)) {\r\nevt = list_first_entry(&rc->uwbd.event_list, struct uwb_event, list_node);\r\nlist_del(&evt->list_node);\r\n} else\r\nevt = NULL;\r\nspin_unlock_irqrestore(&rc->uwbd.event_list_lock, flags);\r\nif (evt) {\r\nuwbd_event_handle(evt);\r\nkfree(evt);\r\n}\r\nuwb_beca_purge(rc);\r\n}\r\nreturn 0;\r\n}\r\nvoid uwbd_start(struct uwb_rc *rc)\r\n{\r\nrc->uwbd.task = kthread_run(uwbd, rc, "uwbd");\r\nif (rc->uwbd.task == NULL)\r\nprintk(KERN_ERR "UWB: Cannot start management daemon; "\r\n"UWB won't work\n");\r\nelse\r\nrc->uwbd.pid = rc->uwbd.task->pid;\r\n}\r\nvoid uwbd_stop(struct uwb_rc *rc)\r\n{\r\nkthread_stop(rc->uwbd.task);\r\nuwbd_flush(rc);\r\n}\r\nvoid uwbd_event_queue(struct uwb_event *evt)\r\n{\r\nstruct uwb_rc *rc = evt->rc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rc->uwbd.event_list_lock, flags);\r\nif (rc->uwbd.pid != 0) {\r\nlist_add(&evt->list_node, &rc->uwbd.event_list);\r\nwake_up_all(&rc->uwbd.wq);\r\n} else {\r\n__uwb_rc_put(evt->rc);\r\nif (evt->type == UWB_EVT_TYPE_NOTIF)\r\nkfree(evt->notif.rceb);\r\nkfree(evt);\r\n}\r\nspin_unlock_irqrestore(&rc->uwbd.event_list_lock, flags);\r\nreturn;\r\n}\r\nvoid uwbd_flush(struct uwb_rc *rc)\r\n{\r\nstruct uwb_event *evt, *nxt;\r\nspin_lock_irq(&rc->uwbd.event_list_lock);\r\nlist_for_each_entry_safe(evt, nxt, &rc->uwbd.event_list, list_node) {\r\nif (evt->rc == rc) {\r\n__uwb_rc_put(rc);\r\nlist_del(&evt->list_node);\r\nif (evt->type == UWB_EVT_TYPE_NOTIF)\r\nkfree(evt->notif.rceb);\r\nkfree(evt);\r\n}\r\n}\r\nspin_unlock_irq(&rc->uwbd.event_list_lock);\r\n}
