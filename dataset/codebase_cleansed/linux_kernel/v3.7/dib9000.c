static u16 to_fw_output_mode(u16 mode)\r\n{\r\nswitch (mode) {\r\ncase OUTMODE_HIGH_Z:\r\nreturn 0;\r\ncase OUTMODE_MPEG2_PAR_GATED_CLK:\r\nreturn 4;\r\ncase OUTMODE_MPEG2_PAR_CONT_CLK:\r\nreturn 8;\r\ncase OUTMODE_MPEG2_SERIAL:\r\nreturn 16;\r\ncase OUTMODE_DIVERSITY:\r\nreturn 128;\r\ncase OUTMODE_MPEG2_FIFO:\r\nreturn 2;\r\ncase OUTMODE_ANALOG_ADC:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic u16 dib9000_read16_attr(struct dib9000_state *state, u16 reg, u8 * b, u32 len, u16 attribute)\r\n{\r\nu32 chunk_size = 126;\r\nu32 l;\r\nint ret;\r\nif (state->platform.risc.fw_is_running && (reg < 1024))\r\nreturn dib9000_risc_apb_access_read(state, reg, attribute, NULL, 0, b, len);\r\nmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->i2c.i2c_addr >> 1;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 2;\r\nstate->msg[1].addr = state->i2c.i2c_addr >> 1;\r\nstate->msg[1].flags = I2C_M_RD;\r\nstate->msg[1].buf = b;\r\nstate->msg[1].len = len;\r\nstate->i2c_write_buffer[0] = reg >> 8;\r\nstate->i2c_write_buffer[1] = reg & 0xff;\r\nif (attribute & DATA_BUS_ACCESS_MODE_8BIT)\r\nstate->i2c_write_buffer[0] |= (1 << 5);\r\nif (attribute & DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT)\r\nstate->i2c_write_buffer[0] |= (1 << 4);\r\ndo {\r\nl = len < chunk_size ? len : chunk_size;\r\nstate->msg[1].len = l;\r\nstate->msg[1].buf = b;\r\nret = i2c_transfer(state->i2c.i2c_adap, state->msg, 2) != 2 ? -EREMOTEIO : 0;\r\nif (ret != 0) {\r\ndprintk("i2c read error on %d", reg);\r\nreturn -EREMOTEIO;\r\n}\r\nb += l;\r\nlen -= l;\r\nif (!(attribute & DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT))\r\nreg += l / 2;\r\n} while ((ret == 0) && len);\r\nreturn 0;\r\n}\r\nstatic u16 dib9000_i2c_read16(struct i2c_device *i2c, u16 reg)\r\n{\r\nstruct i2c_msg msg[2] = {\r\n{.addr = i2c->i2c_addr >> 1, .flags = 0,\r\n.buf = i2c->i2c_write_buffer, .len = 2},\r\n{.addr = i2c->i2c_addr >> 1, .flags = I2C_M_RD,\r\n.buf = i2c->i2c_read_buffer, .len = 2},\r\n};\r\ni2c->i2c_write_buffer[0] = reg >> 8;\r\ni2c->i2c_write_buffer[1] = reg & 0xff;\r\nif (i2c_transfer(i2c->i2c_adap, msg, 2) != 2) {\r\ndprintk("read register %x error", reg);\r\nreturn 0;\r\n}\r\nreturn (i2c->i2c_read_buffer[0] << 8) | i2c->i2c_read_buffer[1];\r\n}\r\nstatic inline u16 dib9000_read_word(struct dib9000_state *state, u16 reg)\r\n{\r\nif (dib9000_read16_attr(state, reg, state->i2c_read_buffer, 2, 0) != 0)\r\nreturn 0;\r\nreturn (state->i2c_read_buffer[0] << 8) | state->i2c_read_buffer[1];\r\n}\r\nstatic inline u16 dib9000_read_word_attr(struct dib9000_state *state, u16 reg, u16 attribute)\r\n{\r\nif (dib9000_read16_attr(state, reg, state->i2c_read_buffer, 2,\r\nattribute) != 0)\r\nreturn 0;\r\nreturn (state->i2c_read_buffer[0] << 8) | state->i2c_read_buffer[1];\r\n}\r\nstatic u16 dib9000_write16_attr(struct dib9000_state *state, u16 reg, const u8 * buf, u32 len, u16 attribute)\r\n{\r\nu32 chunk_size = 126;\r\nu32 l;\r\nint ret;\r\nif (state->platform.risc.fw_is_running && (reg < 1024)) {\r\nif (dib9000_risc_apb_access_write\r\n(state, reg, DATA_BUS_ACCESS_MODE_16BIT | DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT | attribute, buf, len) != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nmemset(&state->msg[0], 0, sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->i2c.i2c_addr >> 1;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = len + 2;\r\nstate->i2c_write_buffer[0] = (reg >> 8) & 0xff;\r\nstate->i2c_write_buffer[1] = (reg) & 0xff;\r\nif (attribute & DATA_BUS_ACCESS_MODE_8BIT)\r\nstate->i2c_write_buffer[0] |= (1 << 5);\r\nif (attribute & DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT)\r\nstate->i2c_write_buffer[0] |= (1 << 4);\r\ndo {\r\nl = len < chunk_size ? len : chunk_size;\r\nstate->msg[0].len = l + 2;\r\nmemcpy(&state->i2c_write_buffer[2], buf, l);\r\nret = i2c_transfer(state->i2c.i2c_adap, state->msg, 1) != 1 ? -EREMOTEIO : 0;\r\nbuf += l;\r\nlen -= l;\r\nif (!(attribute & DATA_BUS_ACCESS_MODE_NO_ADDRESS_INCREMENT))\r\nreg += l / 2;\r\n} while ((ret == 0) && len);\r\nreturn ret;\r\n}\r\nstatic int dib9000_i2c_write16(struct i2c_device *i2c, u16 reg, u16 val)\r\n{\r\nstruct i2c_msg msg = {\r\n.addr = i2c->i2c_addr >> 1, .flags = 0,\r\n.buf = i2c->i2c_write_buffer, .len = 4\r\n};\r\ni2c->i2c_write_buffer[0] = (reg >> 8) & 0xff;\r\ni2c->i2c_write_buffer[1] = reg & 0xff;\r\ni2c->i2c_write_buffer[2] = (val >> 8) & 0xff;\r\ni2c->i2c_write_buffer[3] = val & 0xff;\r\nreturn i2c_transfer(i2c->i2c_adap, &msg, 1) != 1 ? -EREMOTEIO : 0;\r\n}\r\nstatic inline int dib9000_write_word(struct dib9000_state *state, u16 reg, u16 val)\r\n{\r\nu8 b[2] = { val >> 8, val & 0xff };\r\nreturn dib9000_write16_attr(state, reg, b, 2, 0);\r\n}\r\nstatic inline int dib9000_write_word_attr(struct dib9000_state *state, u16 reg, u16 val, u16 attribute)\r\n{\r\nu8 b[2] = { val >> 8, val & 0xff };\r\nreturn dib9000_write16_attr(state, reg, b, 2, attribute);\r\n}\r\nstatic void dib9000_risc_mem_setup_cmd(struct dib9000_state *state, u32 addr, u32 len, u8 reading)\r\n{\r\nu8 b[14] = { 0 };\r\nb[1] = 1;\r\nb[4] = (u8) (addr >> 8);\r\nb[5] = (u8) (addr & 0xff);\r\nb[12] = (u8) (addr >> 8);\r\nb[13] = (u8) (addr & 0xff);\r\naddr += len;\r\nb[8] = (u8) (addr >> 8);\r\nb[9] = (u8) (addr & 0xff);\r\ndib9000_write(state, 1056, b, 14);\r\nif (reading)\r\ndib9000_write_word(state, 1056, (1 << 15) | 1);\r\nstate->platform.risc.memcmd = -1;\r\n}\r\nstatic void dib9000_risc_mem_setup(struct dib9000_state *state, u8 cmd)\r\n{\r\nstruct dib9000_fe_memory_map *m = &state->platform.risc.fe_mm[cmd & 0x7f];\r\nif (state->platform.risc.memcmd == cmd &&\r\n!(cmd & 0x80 && m->size < 67))\r\nreturn;\r\ndib9000_risc_mem_setup_cmd(state, m->addr, m->size, cmd & 0x80);\r\nstate->platform.risc.memcmd = cmd;\r\n}\r\nstatic int dib9000_risc_mem_read(struct dib9000_state *state, u8 cmd, u8 * b, u16 len)\r\n{\r\nif (!state->platform.risc.fw_is_running)\r\nreturn -EIO;\r\nif (mutex_lock_interruptible(&state->platform.risc.mem_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -EINTR;\r\n}\r\ndib9000_risc_mem_setup(state, cmd | 0x80);\r\ndib9000_risc_mem_read_chunks(state, b, len);\r\nmutex_unlock(&state->platform.risc.mem_lock);\r\nreturn 0;\r\n}\r\nstatic int dib9000_risc_mem_write(struct dib9000_state *state, u8 cmd, const u8 * b)\r\n{\r\nstruct dib9000_fe_memory_map *m = &state->platform.risc.fe_mm[cmd];\r\nif (!state->platform.risc.fw_is_running)\r\nreturn -EIO;\r\nif (mutex_lock_interruptible(&state->platform.risc.mem_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -EINTR;\r\n}\r\ndib9000_risc_mem_setup(state, cmd);\r\ndib9000_risc_mem_write_chunks(state, b, m->size);\r\nmutex_unlock(&state->platform.risc.mem_lock);\r\nreturn 0;\r\n}\r\nstatic int dib9000_firmware_download(struct dib9000_state *state, u8 risc_id, u16 key, const u8 * code, u32 len)\r\n{\r\nu16 offs;\r\nif (risc_id == 1)\r\noffs = 16;\r\nelse\r\noffs = 0;\r\ndib9000_write_word(state, 1024 + offs, 0x000f);\r\ndib9000_write_word(state, 1025 + offs, 0);\r\ndib9000_write_word(state, 1031 + offs, key);\r\ndprintk("going to download %dB of microcode", len);\r\nif (dib9000_write16_noinc(state, 1026 + offs, (u8 *) code, (u16) len) != 0) {\r\ndprintk("error while downloading microcode for RISC %c", 'A' + risc_id);\r\nreturn -EIO;\r\n}\r\ndprintk("Microcode for RISC %c loaded", 'A' + risc_id);\r\nreturn 0;\r\n}\r\nstatic int dib9000_mbx_host_init(struct dib9000_state *state, u8 risc_id)\r\n{\r\nu16 mbox_offs;\r\nu16 reset_reg;\r\nu16 tries = 1000;\r\nif (risc_id == 1)\r\nmbox_offs = 16;\r\nelse\r\nmbox_offs = 0;\r\ndib9000_write_word(state, 1027 + mbox_offs, 0x8000);\r\ndo {\r\nreset_reg = dib9000_read_word(state, 1027 + mbox_offs);\r\nmsleep(100);\r\n} while ((reset_reg & 0x8000) && --tries);\r\nif (reset_reg & 0x8000) {\r\ndprintk("MBX: init ERROR, no response from RISC %c", 'A' + risc_id);\r\nreturn -EIO;\r\n}\r\ndprintk("MBX: initialized");\r\nreturn 0;\r\n}\r\nstatic int dib9000_mbx_send_attr(struct dib9000_state *state, u8 id, u16 * data, u8 len, u16 attr)\r\n{\r\nu8 *d, b[2];\r\nu16 tmp;\r\nu16 size;\r\nu32 i;\r\nint ret = 0;\r\nif (!state->platform.risc.fw_is_running)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&state->platform.risc.mbx_if_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -EINTR;\r\n}\r\ntmp = MAX_MAILBOX_TRY;\r\ndo {\r\nsize = dib9000_read_word_attr(state, 1043, attr) & 0xff;\r\nif ((size + len + 1) > MBX_MAX_WORDS && --tmp) {\r\ndprintk("MBX: RISC mbx full, retrying");\r\nmsleep(100);\r\n} else\r\nbreak;\r\n} while (1);\r\nif (tmp == 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n#ifdef DUMP_MSG\r\ndprintk("--> %02x %d ", id, len + 1);\r\nfor (i = 0; i < len; i++)\r\ndprintk("%04x ", data[i]);\r\ndprintk("\n");\r\n#endif\r\nd = (u8 *) data;\r\nfor (i = 0; i < len; i++) {\r\ntmp = data[i];\r\n*d++ = tmp >> 8;\r\n*d++ = tmp & 0xff;\r\n}\r\nb[0] = id;\r\nb[1] = len + 1;\r\nif (dib9000_write16_noinc_attr(state, 1045, b, 2, attr) != 0 || dib9000_write16_noinc_attr(state, 1045, (u8 *) data, len * 2, attr) != 0) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nret = (u8) dib9000_write_word_attr(state, 1043, 1 << 14, attr);\r\nout:\r\nmutex_unlock(&state->platform.risc.mbx_if_lock);\r\nreturn ret;\r\n}\r\nstatic u8 dib9000_mbx_read(struct dib9000_state *state, u16 * data, u8 risc_id, u16 attr)\r\n{\r\n#ifdef DUMP_MSG\r\nu16 *d = data;\r\n#endif\r\nu16 tmp, i;\r\nu8 size;\r\nu8 mc_base;\r\nif (!state->platform.risc.fw_is_running)\r\nreturn 0;\r\nif (mutex_lock_interruptible(&state->platform.risc.mbx_if_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn 0;\r\n}\r\nif (risc_id == 1)\r\nmc_base = 16;\r\nelse\r\nmc_base = 0;\r\n*data = dib9000_read_word_attr(state, 1029 + mc_base, attr);\r\nsize = *data & 0xff;\r\nif (size <= MBX_MAX_WORDS) {\r\ndata++;\r\nsize--;\r\ndib9000_read16_noinc_attr(state, 1029 + mc_base, (u8 *) data, size * 2, attr);\r\nfor (i = 0; i < size; i++) {\r\ntmp = *data;\r\n*data = (tmp >> 8) | (tmp << 8);\r\ndata++;\r\n}\r\n#ifdef DUMP_MSG\r\ndprintk("<-- ");\r\nfor (i = 0; i < size + 1; i++)\r\ndprintk("%04x ", d[i]);\r\ndprintk("\n");\r\n#endif\r\n} else {\r\ndprintk("MBX: message is too big for message cache (%d), flushing message", size);\r\nsize--;\r\nwhile (size--)\r\ndib9000_read16_noinc_attr(state, 1029 + mc_base, (u8 *) data, 2, attr);\r\n}\r\ndib9000_write_word_attr(state, 1028 + mc_base, 1 << 14, attr);\r\nmutex_unlock(&state->platform.risc.mbx_if_lock);\r\nreturn size + 1;\r\n}\r\nstatic int dib9000_risc_debug_buf(struct dib9000_state *state, u16 * data, u8 size)\r\n{\r\nu32 ts = data[1] << 16 | data[0];\r\nchar *b = (char *)&data[2];\r\nb[2 * (size - 2) - 1] = '\0';\r\nif (*b == '~') {\r\nb++;\r\ndprintk(b);\r\n} else\r\ndprintk("RISC%d: %d.%04d %s", state->fe_id, ts / 10000, ts % 10000, *b ? b : "<emtpy>");\r\nreturn 1;\r\n}\r\nstatic int dib9000_mbx_fetch_to_cache(struct dib9000_state *state, u16 attr)\r\n{\r\nint i;\r\nu8 size;\r\nu16 *block;\r\nfor (i = 0; i < DIB9000_MSG_CACHE_SIZE; i++) {\r\nblock = state->platform.risc.message_cache[i];\r\nif (*block == 0) {\r\nsize = dib9000_mbx_read(state, block, 1, attr);\r\nswitch (*block >> 8) {\r\ncase IN_MSG_DEBUG_BUF:\r\ndib9000_risc_debug_buf(state, block + 1, size);\r\n*block = 0;\r\nbreak;\r\n#if 0\r\ncase IN_MSG_DATA:\r\ndib9000_risc_data_process(state, block + 1, size);\r\n*block = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\n}\r\ndprintk("MBX: no free cache-slot found for new message...");\r\nreturn -1;\r\n}\r\nstatic u8 dib9000_mbx_count(struct dib9000_state *state, u8 risc_id, u16 attr)\r\n{\r\nif (risc_id == 0)\r\nreturn (u8) (dib9000_read_word_attr(state, 1028, attr) >> 10) & 0x1f;\r\nelse\r\nreturn (u8) (dib9000_read_word_attr(state, 1044, attr) >> 8) & 0x7f;\r\n}\r\nstatic int dib9000_mbx_process(struct dib9000_state *state, u16 attr)\r\n{\r\nint ret = 0;\r\nif (!state->platform.risc.fw_is_running)\r\nreturn -1;\r\nif (mutex_lock_interruptible(&state->platform.risc.mbx_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -1;\r\n}\r\nif (dib9000_mbx_count(state, 1, attr))\r\nret = dib9000_mbx_fetch_to_cache(state, attr);\r\ndib9000_read_word_attr(state, 1229, attr);\r\nmutex_unlock(&state->platform.risc.mbx_lock);\r\nreturn ret;\r\n}\r\nstatic int dib9000_mbx_get_message_attr(struct dib9000_state *state, u16 id, u16 * msg, u8 * size, u16 attr)\r\n{\r\nu8 i;\r\nu16 *block;\r\nu16 timeout = 30;\r\n*msg = 0;\r\ndo {\r\nfor (i = 0; i < DIB9000_MSG_CACHE_SIZE; i++) {\r\nblock = state->platform.risc.message_cache[i];\r\nif ((*block >> 8) == id) {\r\n*size = (*block & 0xff) - 1;\r\nmemcpy(msg, block + 1, (*size) * 2);\r\n*block = 0;\r\ni = 0;\r\nbreak;\r\n}\r\n}\r\nif (i == 0)\r\nbreak;\r\nif (dib9000_mbx_process(state, attr) == -1)\r\nreturn -1;\r\n} while (--timeout);\r\nif (timeout == 0) {\r\ndprintk("waiting for message %d timed out", id);\r\nreturn -1;\r\n}\r\nreturn i == 0;\r\n}\r\nstatic int dib9000_risc_check_version(struct dib9000_state *state)\r\n{\r\nu8 r[4];\r\nu8 size;\r\nu16 fw_version = 0;\r\nif (dib9000_mbx_send(state, OUT_MSG_REQ_VERSION, &fw_version, 1) != 0)\r\nreturn -EIO;\r\nif (dib9000_mbx_get_message(state, IN_MSG_VERSION, (u16 *) r, &size) < 0)\r\nreturn -EIO;\r\nfw_version = (r[0] << 8) | r[1];\r\ndprintk("RISC: ver: %d.%02d (IC: %d)", fw_version >> 10, fw_version & 0x3ff, (r[2] << 8) | r[3]);\r\nif ((fw_version >> 10) != 7)\r\nreturn -EINVAL;\r\nswitch (fw_version & 0x3ff) {\r\ncase 11:\r\ncase 12:\r\ncase 14:\r\ncase 15:\r\ncase 16:\r\ncase 17:\r\nbreak;\r\ndefault:\r\ndprintk("RISC: invalid firmware version");\r\nreturn -EINVAL;\r\n}\r\ndprintk("RISC: valid firmware version");\r\nreturn 0;\r\n}\r\nstatic int dib9000_fw_boot(struct dib9000_state *state, const u8 * codeA, u32 lenA, const u8 * codeB, u32 lenB)\r\n{\r\ndib9000_write_word(state, 1225, 0x02);\r\ndib9000_write_word(state, 1226, 0x05);\r\ndib9000_write_word(state, 1542, 1);\r\ndib9000_write_word(state, 1074, 0);\r\ndib9000_write_word(state, 1075, 0);\r\ndib9000_write_word(state, 1237, 0);\r\nif (codeA != NULL)\r\ndib9000_write_word(state, 1024, 2);\r\nelse\r\ndib9000_write_word(state, 1024, 15);\r\nif (codeB != NULL)\r\ndib9000_write_word(state, 1040, 2);\r\nif (codeA != NULL)\r\ndib9000_firmware_download(state, 0, 0x1234, codeA, lenA);\r\nif (codeB != NULL)\r\ndib9000_firmware_download(state, 1, 0x1234, codeB, lenB);\r\nif (codeA != NULL)\r\ndib9000_write_word(state, 1024, 0);\r\nif (codeB != NULL)\r\ndib9000_write_word(state, 1040, 0);\r\nif (codeA != NULL)\r\nif (dib9000_mbx_host_init(state, 0) != 0)\r\nreturn -EIO;\r\nif (codeB != NULL)\r\nif (dib9000_mbx_host_init(state, 1) != 0)\r\nreturn -EIO;\r\nmsleep(100);\r\nstate->platform.risc.fw_is_running = 1;\r\nif (dib9000_risc_check_version(state) != 0)\r\nreturn -EINVAL;\r\nstate->platform.risc.memcmd = 0xff;\r\nreturn 0;\r\n}\r\nstatic u16 dib9000_identify(struct i2c_device *client)\r\n{\r\nu16 value;\r\nvalue = dib9000_i2c_read16(client, 896);\r\nif (value != 0x01b3) {\r\ndprintk("wrong Vendor ID (0x%x)", value);\r\nreturn 0;\r\n}\r\nvalue = dib9000_i2c_read16(client, 897);\r\nif (value != 0x4000 && value != 0x4001 && value != 0x4002 && value != 0x4003 && value != 0x4004 && value != 0x4005) {\r\ndprintk("wrong Device ID (0x%x)", value);\r\nreturn 0;\r\n}\r\nif (value == 0x4000 && dib9000_i2c_read16(client, 769) == 0x4000) {\r\ndprintk("this driver does not work with DiB7000PC");\r\nreturn 0;\r\n}\r\nswitch (value) {\r\ncase 0x4000:\r\ndprintk("found DiB7000MA/PA/MB/PB");\r\nbreak;\r\ncase 0x4001:\r\ndprintk("found DiB7000HC");\r\nbreak;\r\ncase 0x4002:\r\ndprintk("found DiB7000MC");\r\nbreak;\r\ncase 0x4003:\r\ndprintk("found DiB9000A");\r\nbreak;\r\ncase 0x4004:\r\ndprintk("found DiB9000H");\r\nbreak;\r\ncase 0x4005:\r\ndprintk("found DiB9000M");\r\nbreak;\r\n}\r\nreturn value;\r\n}\r\nstatic void dib9000_set_power_mode(struct dib9000_state *state, enum dib9000_power_mode mode)\r\n{\r\nu16 reg_903 = 0x3fff, reg_904 = 0xffff, reg_905 = 0xffff, reg_906;\r\nu8 offset;\r\nif (state->revision == 0x4003 || state->revision == 0x4004 || state->revision == 0x4005)\r\noffset = 1;\r\nelse\r\noffset = 0;\r\nreg_906 = dib9000_read_word(state, 906 + offset) | 0x3;\r\nswitch (mode) {\r\ncase DIB9000_POWER_ALL:\r\nreg_903 = 0x0000;\r\nreg_904 = 0x0000;\r\nreg_905 = 0x0000;\r\nreg_906 = 0x0000;\r\nbreak;\r\ncase DIB9000_POWER_INTERFACE_ONLY:\r\nreg_905 &= ~((1 << 7) | (1 << 6) | (1 << 5) | (1 << 2));\r\nbreak;\r\ncase DIB9000_POWER_INTERF_ANALOG_AGC:\r\nreg_903 &= ~((1 << 15) | (1 << 14) | (1 << 11) | (1 << 10));\r\nreg_905 &= ~((1 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (1 << 2));\r\nreg_906 &= ~((1 << 0));\r\nbreak;\r\ncase DIB9000_POWER_COR4_DINTLV_ICIRM_EQUAL_CFROD:\r\nreg_903 = 0x0000;\r\nreg_904 = 0x801f;\r\nreg_905 = 0x0000;\r\nreg_906 &= ~((1 << 0));\r\nbreak;\r\ncase DIB9000_POWER_COR4_CRY_ESRAM_MOUT_NUD:\r\nreg_903 = 0x0000;\r\nreg_904 = 0x8000;\r\nreg_905 = 0x010b;\r\nreg_906 &= ~((1 << 0));\r\nbreak;\r\ndefault:\r\ncase DIB9000_POWER_NO:\r\nbreak;\r\n}\r\nif (!state->platform.host.mobile_mode)\r\nreg_904 |= (1 << 7) | (1 << 6) | (1 << 4) | (1 << 2) | (1 << 1);\r\nif (state->revision != 0x4000)\r\nreg_906 <<= 1;\r\ndib9000_write_word(state, 903 + offset, reg_903);\r\ndib9000_write_word(state, 904 + offset, reg_904);\r\ndib9000_write_word(state, 905 + offset, reg_905);\r\ndib9000_write_word(state, 906 + offset, reg_906);\r\n}\r\nstatic int dib9000_fw_reset(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\ndib9000_write_word(state, 1817, 0x0003);\r\ndib9000_write_word(state, 1227, 1);\r\ndib9000_write_word(state, 1227, 0);\r\nswitch ((state->revision = dib9000_identify(&state->i2c))) {\r\ncase 0x4003:\r\ncase 0x4004:\r\ncase 0x4005:\r\nstate->reg_offs = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndibx000_reset_i2c_master(&state->i2c_master);\r\ndib9000_set_power_mode(state, DIB9000_POWER_ALL);\r\ndib9000_write_word(state, 1794, dib9000_read_word(state, 1794) & ~(1 << 1));\r\ndib9000_write_word(state, 1796, 0);\r\ndib9000_write_word(state, 1805, 0x805);\r\ndib9000_write_word(state, 898, 0xffff);\r\ndib9000_write_word(state, 899, 0xffff);\r\ndib9000_write_word(state, 900, 0x0001);\r\ndib9000_write_word(state, 901, 0xff19);\r\ndib9000_write_word(state, 902, 0x003c);\r\ndib9000_write_word(state, 898, 0);\r\ndib9000_write_word(state, 899, 0);\r\ndib9000_write_word(state, 900, 0);\r\ndib9000_write_word(state, 901, 0);\r\ndib9000_write_word(state, 902, 0);\r\ndib9000_write_word(state, 911, state->chip.d9.cfg.if_drives);\r\ndib9000_set_power_mode(state, DIB9000_POWER_INTERFACE_ONLY);\r\nreturn 0;\r\n}\r\nstatic int dib9000_risc_apb_access_read(struct dib9000_state *state, u32 address, u16 attribute, const u8 * tx, u32 txlen, u8 * b, u32 len)\r\n{\r\nu16 mb[10];\r\nu8 i, s;\r\nif (address >= 1024 || !state->platform.risc.fw_is_running)\r\nreturn -EINVAL;\r\nmb[0] = (u16) address;\r\nmb[1] = len / 2;\r\ndib9000_mbx_send_attr(state, OUT_MSG_BRIDGE_APB_R, mb, 2, attribute);\r\nswitch (dib9000_mbx_get_message_attr(state, IN_MSG_END_BRIDGE_APB_RW, mb, &s, attribute)) {\r\ncase 1:\r\ns--;\r\nfor (i = 0; i < s; i++) {\r\nb[i * 2] = (mb[i + 1] >> 8) & 0xff;\r\nb[i * 2 + 1] = (mb[i + 1]) & 0xff;\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EIO;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int dib9000_risc_apb_access_write(struct dib9000_state *state, u32 address, u16 attribute, const u8 * b, u32 len)\r\n{\r\nu16 mb[10];\r\nu8 s, i;\r\nif (address >= 1024 || !state->platform.risc.fw_is_running)\r\nreturn -EINVAL;\r\nmb[0] = (unsigned short)address;\r\nfor (i = 0; i < len && i < 20; i += 2)\r\nmb[1 + (i / 2)] = (b[i] << 8 | b[i + 1]);\r\ndib9000_mbx_send_attr(state, OUT_MSG_BRIDGE_APB_W, mb, 1 + len / 2, attribute);\r\nreturn dib9000_mbx_get_message_attr(state, IN_MSG_END_BRIDGE_APB_RW, mb, &s, attribute) == 1 ? 0 : -EINVAL;\r\n}\r\nstatic int dib9000_fw_memmbx_sync(struct dib9000_state *state, u8 i)\r\n{\r\nu8 index_loop = 10;\r\nif (!state->platform.risc.fw_is_running)\r\nreturn 0;\r\ndib9000_risc_mem_write(state, FE_MM_RW_SYNC, &i);\r\ndo {\r\ndib9000_risc_mem_read(state, FE_MM_RW_SYNC, state->i2c_read_buffer, 1);\r\n} while (state->i2c_read_buffer[0] && index_loop--);\r\nif (index_loop > 0)\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic int dib9000_fw_init(struct dib9000_state *state)\r\n{\r\nstruct dibGPIOFunction *f;\r\nu16 b[40] = { 0 };\r\nu8 i;\r\nu8 size;\r\nif (dib9000_fw_boot(state, NULL, 0, state->chip.d9.cfg.microcode_B_fe_buffer, state->chip.d9.cfg.microcode_B_fe_size) != 0)\r\nreturn -EIO;\r\nfor (i = 0; i < ARRAY_SIZE(state->chip.d9.cfg.gpio_function); i++) {\r\nf = &state->chip.d9.cfg.gpio_function[i];\r\nif (f->mask) {\r\nswitch (f->function) {\r\ncase BOARD_GPIO_FUNCTION_COMPONENT_ON:\r\nb[0] = (u16) f->mask;\r\nb[1] = (u16) f->direction;\r\nb[2] = (u16) f->value;\r\nbreak;\r\ncase BOARD_GPIO_FUNCTION_COMPONENT_OFF:\r\nb[3] = (u16) f->mask;\r\nb[4] = (u16) f->direction;\r\nb[5] = (u16) f->value;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (dib9000_mbx_send(state, OUT_MSG_CONF_GPIO, b, 15) != 0)\r\nreturn -EIO;\r\nb[0] = state->chip.d9.cfg.subband.size;\r\nfor (i = 0; i < state->chip.d9.cfg.subband.size; i++) {\r\nb[1 + i * 4] = state->chip.d9.cfg.subband.subband[i].f_mhz;\r\nb[2 + i * 4] = (u16) state->chip.d9.cfg.subband.subband[i].gpio.mask;\r\nb[3 + i * 4] = (u16) state->chip.d9.cfg.subband.subband[i].gpio.direction;\r\nb[4 + i * 4] = (u16) state->chip.d9.cfg.subband.subband[i].gpio.value;\r\n}\r\nb[1 + i * 4] = 0;\r\nif (dib9000_mbx_send(state, OUT_MSG_SUBBAND_SEL, b, 2 + 4 * i) != 0)\r\nreturn -EIO;\r\nb[0] = (0 << 8) | 1;\r\nb[1] = (0 << 8) | (0);\r\nb[2] = (u16) (((state->chip.d9.cfg.xtal_clock_khz * 1000) >> 16) & 0xffff);\r\nb[3] = (u16) (((state->chip.d9.cfg.xtal_clock_khz * 1000)) & 0xffff);\r\nb[4] = (u16) ((state->chip.d9.cfg.vcxo_timer >> 16) & 0xffff);\r\nb[5] = (u16) ((state->chip.d9.cfg.vcxo_timer) & 0xffff);\r\nb[6] = (u16) ((state->chip.d9.cfg.timing_frequency >> 16) & 0xffff);\r\nb[7] = (u16) ((state->chip.d9.cfg.timing_frequency) & 0xffff);\r\nb[29] = state->chip.d9.cfg.if_drives;\r\nif (dib9000_mbx_send(state, OUT_MSG_INIT_DEMOD, b, ARRAY_SIZE(b)) != 0)\r\nreturn -EIO;\r\nif (dib9000_mbx_send(state, OUT_MSG_FE_FW_DL, NULL, 0) != 0)\r\nreturn -EIO;\r\nif (dib9000_mbx_get_message(state, IN_MSG_FE_FW_DL_DONE, b, &size) < 0)\r\nreturn -EIO;\r\nif (size > ARRAY_SIZE(b)) {\r\ndprintk("error : firmware returned %dbytes needed but the used buffer has only %dbytes\n Firmware init ABORTED", size,\r\n(int)ARRAY_SIZE(b));\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < size; i += 2) {\r\nstate->platform.risc.fe_mm[i / 2].addr = b[i + 0];\r\nstate->platform.risc.fe_mm[i / 2].size = b[i + 1];\r\n}\r\nreturn 0;\r\n}\r\nstatic void dib9000_fw_set_channel_head(struct dib9000_state *state)\r\n{\r\nu8 b[9];\r\nu32 freq = state->fe[0]->dtv_property_cache.frequency / 1000;\r\nif (state->fe_id % 2)\r\nfreq += 101;\r\nb[0] = (u8) ((freq >> 0) & 0xff);\r\nb[1] = (u8) ((freq >> 8) & 0xff);\r\nb[2] = (u8) ((freq >> 16) & 0xff);\r\nb[3] = (u8) ((freq >> 24) & 0xff);\r\nb[4] = (u8) ((state->fe[0]->dtv_property_cache.bandwidth_hz / 1000 >> 0) & 0xff);\r\nb[5] = (u8) ((state->fe[0]->dtv_property_cache.bandwidth_hz / 1000 >> 8) & 0xff);\r\nb[6] = (u8) ((state->fe[0]->dtv_property_cache.bandwidth_hz / 1000 >> 16) & 0xff);\r\nb[7] = (u8) ((state->fe[0]->dtv_property_cache.bandwidth_hz / 1000 >> 24) & 0xff);\r\nb[8] = 0x80;\r\nif (state->fe[0]->dtv_property_cache.delivery_system == SYS_DVBT)\r\nb[8] |= 1;\r\ndib9000_risc_mem_write(state, FE_MM_W_CHANNEL_HEAD, b);\r\n}\r\nstatic int dib9000_fw_get_channel(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nstruct dibDVBTChannel {\r\ns8 spectrum_inversion;\r\ns8 nfft;\r\ns8 guard;\r\ns8 constellation;\r\ns8 hrch;\r\ns8 alpha;\r\ns8 code_rate_hp;\r\ns8 code_rate_lp;\r\ns8 select_hp;\r\ns8 intlv_native;\r\n};\r\nstruct dibDVBTChannel *ch;\r\nint ret = 0;\r\nif (mutex_lock_interruptible(&state->platform.risc.mem_mbx_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -EINTR;\r\n}\r\nif (dib9000_fw_memmbx_sync(state, FE_SYNC_CHANNEL) < 0) {\r\nret = -EIO;\r\ngoto error;\r\n}\r\ndib9000_risc_mem_read(state, FE_MM_R_CHANNEL_UNION,\r\nstate->i2c_read_buffer, sizeof(struct dibDVBTChannel));\r\nch = (struct dibDVBTChannel *)state->i2c_read_buffer;\r\nswitch (ch->spectrum_inversion & 0x7) {\r\ncase 1:\r\nstate->fe[0]->dtv_property_cache.inversion = INVERSION_ON;\r\nbreak;\r\ncase 0:\r\nstate->fe[0]->dtv_property_cache.inversion = INVERSION_OFF;\r\nbreak;\r\ndefault:\r\ncase -1:\r\nstate->fe[0]->dtv_property_cache.inversion = INVERSION_AUTO;\r\nbreak;\r\n}\r\nswitch (ch->nfft) {\r\ncase 0:\r\nstate->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 2:\r\nstate->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_4K;\r\nbreak;\r\ncase 1:\r\nstate->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\ndefault:\r\ncase -1:\r\nstate->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_AUTO;\r\nbreak;\r\n}\r\nswitch (ch->guard) {\r\ncase 0:\r\nstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\ndefault:\r\ncase -1:\r\nstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_AUTO;\r\nbreak;\r\n}\r\nswitch (ch->constellation) {\r\ncase 2:\r\nstate->fe[0]->dtv_property_cache.modulation = QAM_64;\r\nbreak;\r\ncase 1:\r\nstate->fe[0]->dtv_property_cache.modulation = QAM_16;\r\nbreak;\r\ncase 0:\r\nstate->fe[0]->dtv_property_cache.modulation = QPSK;\r\nbreak;\r\ndefault:\r\ncase -1:\r\nstate->fe[0]->dtv_property_cache.modulation = QAM_AUTO;\r\nbreak;\r\n}\r\nswitch (ch->hrch) {\r\ncase 0:\r\nstate->fe[0]->dtv_property_cache.hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\nstate->fe[0]->dtv_property_cache.hierarchy = HIERARCHY_1;\r\nbreak;\r\ndefault:\r\ncase -1:\r\nstate->fe[0]->dtv_property_cache.hierarchy = HIERARCHY_AUTO;\r\nbreak;\r\n}\r\nswitch (ch->code_rate_hp) {\r\ncase 1:\r\nstate->fe[0]->dtv_property_cache.code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 2:\r\nstate->fe[0]->dtv_property_cache.code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 3:\r\nstate->fe[0]->dtv_property_cache.code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 5:\r\nstate->fe[0]->dtv_property_cache.code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 7:\r\nstate->fe[0]->dtv_property_cache.code_rate_HP = FEC_7_8;\r\nbreak;\r\ndefault:\r\ncase -1:\r\nstate->fe[0]->dtv_property_cache.code_rate_HP = FEC_AUTO;\r\nbreak;\r\n}\r\nswitch (ch->code_rate_lp) {\r\ncase 1:\r\nstate->fe[0]->dtv_property_cache.code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 2:\r\nstate->fe[0]->dtv_property_cache.code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 3:\r\nstate->fe[0]->dtv_property_cache.code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 5:\r\nstate->fe[0]->dtv_property_cache.code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 7:\r\nstate->fe[0]->dtv_property_cache.code_rate_LP = FEC_7_8;\r\nbreak;\r\ndefault:\r\ncase -1:\r\nstate->fe[0]->dtv_property_cache.code_rate_LP = FEC_AUTO;\r\nbreak;\r\n}\r\nerror:\r\nmutex_unlock(&state->platform.risc.mem_mbx_lock);\r\nreturn ret;\r\n}\r\nstatic int dib9000_fw_set_channel_union(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nstruct dibDVBTChannel {\r\ns8 spectrum_inversion;\r\ns8 nfft;\r\ns8 guard;\r\ns8 constellation;\r\ns8 hrch;\r\ns8 alpha;\r\ns8 code_rate_hp;\r\ns8 code_rate_lp;\r\ns8 select_hp;\r\ns8 intlv_native;\r\n};\r\nstruct dibDVBTChannel ch;\r\nswitch (state->fe[0]->dtv_property_cache.inversion) {\r\ncase INVERSION_ON:\r\nch.spectrum_inversion = 1;\r\nbreak;\r\ncase INVERSION_OFF:\r\nch.spectrum_inversion = 0;\r\nbreak;\r\ndefault:\r\ncase INVERSION_AUTO:\r\nch.spectrum_inversion = -1;\r\nbreak;\r\n}\r\nswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nch.nfft = 0;\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nch.nfft = 2;\r\nbreak;\r\ncase TRANSMISSION_MODE_8K:\r\nch.nfft = 1;\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_AUTO:\r\nch.nfft = 1;\r\nbreak;\r\n}\r\nswitch (state->fe[0]->dtv_property_cache.guard_interval) {\r\ncase GUARD_INTERVAL_1_32:\r\nch.guard = 0;\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\nch.guard = 1;\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\nch.guard = 2;\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\nch.guard = 3;\r\nbreak;\r\ndefault:\r\ncase GUARD_INTERVAL_AUTO:\r\nch.guard = -1;\r\nbreak;\r\n}\r\nswitch (state->fe[0]->dtv_property_cache.modulation) {\r\ncase QAM_64:\r\nch.constellation = 2;\r\nbreak;\r\ncase QAM_16:\r\nch.constellation = 1;\r\nbreak;\r\ncase QPSK:\r\nch.constellation = 0;\r\nbreak;\r\ndefault:\r\ncase QAM_AUTO:\r\nch.constellation = -1;\r\nbreak;\r\n}\r\nswitch (state->fe[0]->dtv_property_cache.hierarchy) {\r\ncase HIERARCHY_NONE:\r\nch.hrch = 0;\r\nbreak;\r\ncase HIERARCHY_1:\r\ncase HIERARCHY_2:\r\ncase HIERARCHY_4:\r\nch.hrch = 1;\r\nbreak;\r\ndefault:\r\ncase HIERARCHY_AUTO:\r\nch.hrch = -1;\r\nbreak;\r\n}\r\nch.alpha = 1;\r\nswitch (state->fe[0]->dtv_property_cache.code_rate_HP) {\r\ncase FEC_1_2:\r\nch.code_rate_hp = 1;\r\nbreak;\r\ncase FEC_2_3:\r\nch.code_rate_hp = 2;\r\nbreak;\r\ncase FEC_3_4:\r\nch.code_rate_hp = 3;\r\nbreak;\r\ncase FEC_5_6:\r\nch.code_rate_hp = 5;\r\nbreak;\r\ncase FEC_7_8:\r\nch.code_rate_hp = 7;\r\nbreak;\r\ndefault:\r\ncase FEC_AUTO:\r\nch.code_rate_hp = -1;\r\nbreak;\r\n}\r\nswitch (state->fe[0]->dtv_property_cache.code_rate_LP) {\r\ncase FEC_1_2:\r\nch.code_rate_lp = 1;\r\nbreak;\r\ncase FEC_2_3:\r\nch.code_rate_lp = 2;\r\nbreak;\r\ncase FEC_3_4:\r\nch.code_rate_lp = 3;\r\nbreak;\r\ncase FEC_5_6:\r\nch.code_rate_lp = 5;\r\nbreak;\r\ncase FEC_7_8:\r\nch.code_rate_lp = 7;\r\nbreak;\r\ndefault:\r\ncase FEC_AUTO:\r\nch.code_rate_lp = -1;\r\nbreak;\r\n}\r\nch.select_hp = 1;\r\nch.intlv_native = 1;\r\ndib9000_risc_mem_write(state, FE_MM_W_CHANNEL_UNION, (u8 *) &ch);\r\nreturn 0;\r\n}\r\nstatic int dib9000_fw_tune(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nint ret = 10, search = state->channel_status.status == CHANNEL_STATUS_PARAMETERS_UNKNOWN;\r\ns8 i;\r\nswitch (state->tune_state) {\r\ncase CT_DEMOD_START:\r\ndib9000_fw_set_channel_head(state);\r\ndib9000_risc_mem_write(state, FE_MM_W_CHANNEL_CONTEXT, (u8 *) fe_info);\r\ndib9000_risc_mem_write(state, FE_MM_W_FE_INFO, (u8 *) fe_info);\r\nif (search)\r\ndib9000_mbx_send(state, OUT_MSG_FE_CHANNEL_SEARCH, NULL, 0);\r\nelse {\r\ndib9000_fw_set_channel_union(fe);\r\ndib9000_mbx_send(state, OUT_MSG_FE_CHANNEL_TUNE, NULL, 0);\r\n}\r\nstate->tune_state = CT_DEMOD_STEP_1;\r\nbreak;\r\ncase CT_DEMOD_STEP_1:\r\nif (search)\r\ndib9000_risc_mem_read(state, FE_MM_R_CHANNEL_SEARCH_STATE, state->i2c_read_buffer, 1);\r\nelse\r\ndib9000_risc_mem_read(state, FE_MM_R_CHANNEL_TUNE_STATE, state->i2c_read_buffer, 1);\r\ni = (s8)state->i2c_read_buffer[0];\r\nswitch (i) {\r\ncase 0:\r\nbreak;\r\ncase -2:\r\nif (search)\r\nstate->status = FE_STATUS_DEMOD_SUCCESS;\r\nelse {\r\nstate->tune_state = CT_DEMOD_STOP;\r\nstate->status = FE_STATUS_LOCKED;\r\n}\r\nbreak;\r\ndefault:\r\nstate->status = FE_STATUS_TUNE_FAILED;\r\nstate->tune_state = CT_DEMOD_STOP;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nret = FE_CALLBACK_TIME_NEVER;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dib9000_fw_set_diversity_in(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nu16 mode = (u16) onoff;\r\nreturn dib9000_mbx_send(state, OUT_MSG_ENABLE_DIVERSITY, &mode, 1);\r\n}\r\nstatic int dib9000_fw_set_output_mode(struct dvb_frontend *fe, int mode)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nu16 outreg, smo_mode;\r\ndprintk("setting output mode for demod %p to %d", fe, mode);\r\nswitch (mode) {\r\ncase OUTMODE_MPEG2_PAR_GATED_CLK:\r\noutreg = (1 << 10);\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_CONT_CLK:\r\noutreg = (1 << 10) | (1 << 6);\r\nbreak;\r\ncase OUTMODE_MPEG2_SERIAL:\r\noutreg = (1 << 10) | (2 << 6) | (0 << 1);\r\nbreak;\r\ncase OUTMODE_DIVERSITY:\r\noutreg = (1 << 10) | (4 << 6);\r\nbreak;\r\ncase OUTMODE_MPEG2_FIFO:\r\noutreg = (1 << 10) | (5 << 6);\r\nbreak;\r\ncase OUTMODE_HIGH_Z:\r\noutreg = 0;\r\nbreak;\r\ndefault:\r\ndprintk("Unhandled output_mode passed to be set for demod %p", &state->fe[0]);\r\nreturn -EINVAL;\r\n}\r\ndib9000_write_word(state, 1795, outreg);\r\nswitch (mode) {\r\ncase OUTMODE_MPEG2_PAR_GATED_CLK:\r\ncase OUTMODE_MPEG2_PAR_CONT_CLK:\r\ncase OUTMODE_MPEG2_SERIAL:\r\ncase OUTMODE_MPEG2_FIFO:\r\nsmo_mode = (dib9000_read_word(state, 295) & 0x0010) | (1 << 1);\r\nif (state->chip.d9.cfg.output_mpeg2_in_188_bytes)\r\nsmo_mode |= (1 << 5);\r\ndib9000_write_word(state, 295, smo_mode);\r\nbreak;\r\n}\r\noutreg = to_fw_output_mode(mode);\r\nreturn dib9000_mbx_send(state, OUT_MSG_SET_OUTPUT_MODE, &outreg, 1);\r\n}\r\nstatic int dib9000_tuner_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct dib9000_state *state = i2c_get_adapdata(i2c_adap);\r\nu16 i, len, t, index_msg;\r\nfor (index_msg = 0; index_msg < num; index_msg++) {\r\nif (msg[index_msg].flags & I2C_M_RD) {\r\nlen = msg[index_msg].len;\r\nif (len > 16)\r\nlen = 16;\r\nif (dib9000_read_word(state, 790) != 0)\r\ndprintk("TunerITF: read busy");\r\ndib9000_write_word(state, 784, (u16) (msg[index_msg].addr));\r\ndib9000_write_word(state, 787, (len / 2) - 1);\r\ndib9000_write_word(state, 786, 1);\r\ni = 1000;\r\nwhile (dib9000_read_word(state, 790) != (len / 2) && i)\r\ni--;\r\nif (i == 0)\r\ndprintk("TunerITF: read failed");\r\nfor (i = 0; i < len; i += 2) {\r\nt = dib9000_read_word(state, 785);\r\nmsg[index_msg].buf[i] = (t >> 8) & 0xff;\r\nmsg[index_msg].buf[i + 1] = (t) & 0xff;\r\n}\r\nif (dib9000_read_word(state, 790) != 0)\r\ndprintk("TunerITF: read more data than expected");\r\n} else {\r\ni = 1000;\r\nwhile (dib9000_read_word(state, 789) && i)\r\ni--;\r\nif (i == 0)\r\ndprintk("TunerITF: write busy");\r\nlen = msg[index_msg].len;\r\nif (len > 16)\r\nlen = 16;\r\nfor (i = 0; i < len; i += 2)\r\ndib9000_write_word(state, 785, (msg[index_msg].buf[i] << 8) | msg[index_msg].buf[i + 1]);\r\ndib9000_write_word(state, 784, (u16) msg[index_msg].addr);\r\ndib9000_write_word(state, 787, (len / 2) - 1);\r\ndib9000_write_word(state, 786, 0);\r\ni = 1000;\r\nwhile (dib9000_read_word(state, 791) > 0 && i)\r\ni--;\r\nif (i == 0)\r\ndprintk("TunerITF: write failed");\r\n}\r\n}\r\nreturn num;\r\n}\r\nint dib9000_fw_set_component_bus_speed(struct dvb_frontend *fe, u16 speed)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nstate->component_bus_speed = speed;\r\nreturn 0;\r\n}\r\nstatic int dib9000_fw_component_bus_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct dib9000_state *state = i2c_get_adapdata(i2c_adap);\r\nu8 type = 0;\r\nu8 port = DIBX000_I2C_INTERFACE_GPIO_3_4;\r\nu16 scl = state->component_bus_speed;\r\nstruct dib9000_fe_memory_map *m = &state->platform.risc.fe_mm[FE_MM_RW_COMPONENT_ACCESS_BUFFER];\r\nu8 p[13] = { 0 };\r\np[0] = type;\r\np[1] = port;\r\np[2] = msg[0].addr << 1;\r\np[3] = (u8) scl & 0xff;\r\np[4] = (u8) (scl >> 8);\r\np[7] = 0;\r\np[8] = 0;\r\np[9] = (u8) (msg[0].len);\r\np[10] = (u8) (msg[0].len >> 8);\r\nif ((num > 1) && (msg[1].flags & I2C_M_RD)) {\r\np[11] = (u8) (msg[1].len);\r\np[12] = (u8) (msg[1].len >> 8);\r\n} else {\r\np[11] = 0;\r\np[12] = 0;\r\n}\r\nif (mutex_lock_interruptible(&state->platform.risc.mem_mbx_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn 0;\r\n}\r\ndib9000_risc_mem_write(state, FE_MM_W_COMPONENT_ACCESS, p);\r\n{\r\ndib9000_risc_mem_setup_cmd(state, m->addr, msg[0].len, 0);\r\ndib9000_risc_mem_write_chunks(state, msg[0].buf, msg[0].len);\r\n}\r\nif (dib9000_fw_memmbx_sync(state, FE_SYNC_COMPONENT_ACCESS) < 0) {\r\nmutex_unlock(&state->platform.risc.mem_mbx_lock);\r\nreturn 0;\r\n}\r\nif ((num > 1) && (msg[1].flags & I2C_M_RD))\r\ndib9000_risc_mem_read(state, FE_MM_RW_COMPONENT_ACCESS_BUFFER, msg[1].buf, msg[1].len);\r\nmutex_unlock(&state->platform.risc.mem_mbx_lock);\r\nreturn num;\r\n}\r\nstatic u32 dib9000_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstruct i2c_adapter *dib9000_get_tuner_interface(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *st = fe->demodulator_priv;\r\nreturn &st->tuner_adap;\r\n}\r\nstruct i2c_adapter *dib9000_get_component_bus_interface(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *st = fe->demodulator_priv;\r\nreturn &st->component_bus;\r\n}\r\nstruct i2c_adapter *dib9000_get_i2c_master(struct dvb_frontend *fe, enum dibx000_i2c_interface intf, int gating)\r\n{\r\nstruct dib9000_state *st = fe->demodulator_priv;\r\nreturn dibx000_get_i2c_adapter(&st->i2c_master, intf, gating);\r\n}\r\nint dib9000_set_i2c_adapter(struct dvb_frontend *fe, struct i2c_adapter *i2c)\r\n{\r\nstruct dib9000_state *st = fe->demodulator_priv;\r\nst->i2c.i2c_adap = i2c;\r\nreturn 0;\r\n}\r\nstatic int dib9000_cfg_gpio(struct dib9000_state *st, u8 num, u8 dir, u8 val)\r\n{\r\nst->gpio_dir = dib9000_read_word(st, 773);\r\nst->gpio_dir &= ~(1 << num);\r\nst->gpio_dir |= (dir & 0x1) << num;\r\ndib9000_write_word(st, 773, st->gpio_dir);\r\nst->gpio_val = dib9000_read_word(st, 774);\r\nst->gpio_val &= ~(1 << num);\r\nst->gpio_val |= (val & 0x01) << num;\r\ndib9000_write_word(st, 774, st->gpio_val);\r\ndprintk("gpio dir: %04x: gpio val: %04x", st->gpio_dir, st->gpio_val);\r\nreturn 0;\r\n}\r\nint dib9000_set_gpio(struct dvb_frontend *fe, u8 num, u8 dir, u8 val)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nreturn dib9000_cfg_gpio(state, num, dir, val);\r\n}\r\nint dib9000_fw_pid_filter_ctrl(struct dvb_frontend *fe, u8 onoff)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nu16 val;\r\nint ret;\r\nif ((state->pid_ctrl_index != -2) && (state->pid_ctrl_index < 9)) {\r\ndprintk("pid filter cmd postpone");\r\nstate->pid_ctrl_index++;\r\nstate->pid_ctrl[state->pid_ctrl_index].cmd = DIB9000_PID_FILTER_CTRL;\r\nstate->pid_ctrl[state->pid_ctrl_index].onoff = onoff;\r\nreturn 0;\r\n}\r\nif (mutex_lock_interruptible(&state->demod_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -EINTR;\r\n}\r\nval = dib9000_read_word(state, 294 + 1) & 0xffef;\r\nval |= (onoff & 0x1) << 4;\r\ndprintk("PID filter enabled %d", onoff);\r\nret = dib9000_write_word(state, 294 + 1, val);\r\nmutex_unlock(&state->demod_lock);\r\nreturn ret;\r\n}\r\nint dib9000_fw_pid_filter(struct dvb_frontend *fe, u8 id, u16 pid, u8 onoff)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nint ret;\r\nif (state->pid_ctrl_index != -2) {\r\ndprintk("pid filter postpone");\r\nif (state->pid_ctrl_index < 9) {\r\nstate->pid_ctrl_index++;\r\nstate->pid_ctrl[state->pid_ctrl_index].cmd = DIB9000_PID_FILTER;\r\nstate->pid_ctrl[state->pid_ctrl_index].id = id;\r\nstate->pid_ctrl[state->pid_ctrl_index].pid = pid;\r\nstate->pid_ctrl[state->pid_ctrl_index].onoff = onoff;\r\n} else\r\ndprintk("can not add any more pid ctrl cmd");\r\nreturn 0;\r\n}\r\nif (mutex_lock_interruptible(&state->demod_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -EINTR;\r\n}\r\ndprintk("Index %x, PID %d, OnOff %d", id, pid, onoff);\r\nret = dib9000_write_word(state, 300 + 1 + id,\r\nonoff ? (1 << 13) | pid : 0);\r\nmutex_unlock(&state->demod_lock);\r\nreturn ret;\r\n}\r\nint dib9000_firmware_post_pll_init(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nreturn dib9000_fw_init(state);\r\n}\r\nstatic void dib9000_release(struct dvb_frontend *demod)\r\n{\r\nstruct dib9000_state *st = demod->demodulator_priv;\r\nu8 index_frontend;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (st->fe[index_frontend] != NULL); index_frontend++)\r\ndvb_frontend_detach(st->fe[index_frontend]);\r\ndibx000_exit_i2c_master(&st->i2c_master);\r\ni2c_del_adapter(&st->tuner_adap);\r\ni2c_del_adapter(&st->component_bus);\r\nkfree(st->fe[0]);\r\nkfree(st);\r\n}\r\nstatic int dib9000_wakeup(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dib9000_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nint ret = 0;\r\nif (mutex_lock_interruptible(&state->demod_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -EINTR;\r\n}\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nret = state->fe[index_frontend]->ops.sleep(state->fe[index_frontend]);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nret = dib9000_mbx_send(state, OUT_MSG_FE_SLEEP, NULL, 0);\r\nerror:\r\nmutex_unlock(&state->demod_lock);\r\nreturn ret;\r\n}\r\nstatic int dib9000_fe_get_tune_settings(struct dvb_frontend *fe, struct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic int dib9000_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nu8 index_frontend, sub_index_frontend;\r\nfe_status_t stat;\r\nint ret = 0;\r\nif (state->get_frontend_internal == 0) {\r\nif (mutex_lock_interruptible(&state->demod_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -EINTR;\r\n}\r\n}\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->ops.read_status(state->fe[index_frontend], &stat);\r\nif (stat & FE_HAS_SYNC) {\r\ndprintk("TPS lock on the slave%i", index_frontend);\r\nstate->fe[index_frontend]->ops.get_frontend(state->fe[index_frontend]);\r\nfor (sub_index_frontend = 0; (sub_index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[sub_index_frontend] != NULL);\r\nsub_index_frontend++) {\r\nif (sub_index_frontend != index_frontend) {\r\nstate->fe[sub_index_frontend]->dtv_property_cache.modulation =\r\nstate->fe[index_frontend]->dtv_property_cache.modulation;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.inversion =\r\nstate->fe[index_frontend]->dtv_property_cache.inversion;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.transmission_mode =\r\nstate->fe[index_frontend]->dtv_property_cache.transmission_mode;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.guard_interval =\r\nstate->fe[index_frontend]->dtv_property_cache.guard_interval;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.hierarchy =\r\nstate->fe[index_frontend]->dtv_property_cache.hierarchy;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.code_rate_HP =\r\nstate->fe[index_frontend]->dtv_property_cache.code_rate_HP;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.code_rate_LP =\r\nstate->fe[index_frontend]->dtv_property_cache.code_rate_LP;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.rolloff =\r\nstate->fe[index_frontend]->dtv_property_cache.rolloff;\r\n}\r\n}\r\nret = 0;\r\ngoto return_value;\r\n}\r\n}\r\nret = dib9000_fw_get_channel(fe);\r\nif (ret != 0)\r\ngoto return_value;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->dtv_property_cache.inversion = fe->dtv_property_cache.inversion;\r\nstate->fe[index_frontend]->dtv_property_cache.transmission_mode = fe->dtv_property_cache.transmission_mode;\r\nstate->fe[index_frontend]->dtv_property_cache.guard_interval = fe->dtv_property_cache.guard_interval;\r\nstate->fe[index_frontend]->dtv_property_cache.modulation = fe->dtv_property_cache.modulation;\r\nstate->fe[index_frontend]->dtv_property_cache.hierarchy = fe->dtv_property_cache.hierarchy;\r\nstate->fe[index_frontend]->dtv_property_cache.code_rate_HP = fe->dtv_property_cache.code_rate_HP;\r\nstate->fe[index_frontend]->dtv_property_cache.code_rate_LP = fe->dtv_property_cache.code_rate_LP;\r\nstate->fe[index_frontend]->dtv_property_cache.rolloff = fe->dtv_property_cache.rolloff;\r\n}\r\nret = 0;\r\nreturn_value:\r\nif (state->get_frontend_internal == 0)\r\nmutex_unlock(&state->demod_lock);\r\nreturn ret;\r\n}\r\nstatic int dib9000_set_tune_state(struct dvb_frontend *fe, enum frontend_tune_state tune_state)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nstate->tune_state = tune_state;\r\nif (tune_state == CT_DEMOD_START)\r\nstate->status = FE_STATUS_TUNE_PENDING;\r\nreturn 0;\r\n}\r\nstatic u32 dib9000_get_status(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nreturn state->status;\r\n}\r\nstatic int dib9000_set_channel_status(struct dvb_frontend *fe, struct dvb_frontend_parametersContext *channel_status)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nmemcpy(&state->channel_status, channel_status, sizeof(struct dvb_frontend_parametersContext));\r\nreturn 0;\r\n}\r\nstatic int dib9000_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nint sleep_time, sleep_time_slave;\r\nu32 frontend_status;\r\nu8 nbr_pending, exit_condition, index_frontend, index_frontend_success;\r\nstruct dvb_frontend_parametersContext channel_status;\r\nif (state->fe[0]->dtv_property_cache.frequency == 0) {\r\ndprintk("dib9000: must specify frequency ");\r\nreturn 0;\r\n}\r\nif (state->fe[0]->dtv_property_cache.bandwidth_hz == 0) {\r\ndprintk("dib9000: must specify bandwidth ");\r\nreturn 0;\r\n}\r\nstate->pid_ctrl_index = -1;\r\nif (mutex_lock_interruptible(&state->demod_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn 0;\r\n}\r\nfe->dtv_property_cache.delivery_system = SYS_DVBT;\r\nif (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO ||\r\nstate->fe[0]->dtv_property_cache.guard_interval == GUARD_INTERVAL_AUTO ||\r\nstate->fe[0]->dtv_property_cache.modulation == QAM_AUTO ||\r\nstate->fe[0]->dtv_property_cache.code_rate_HP == FEC_AUTO) {\r\nstate->channel_status.status = CHANNEL_STATUS_PARAMETERS_UNKNOWN;\r\n} else\r\nstate->channel_status.status = CHANNEL_STATUS_PARAMETERS_SET;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\ndib9000_fw_set_diversity_in(state->fe[index_frontend], 1);\r\nmemcpy(&state->fe[index_frontend]->dtv_property_cache, &fe->dtv_property_cache, sizeof(struct dtv_frontend_properties));\r\nstate->fe[index_frontend]->dtv_property_cache.delivery_system = SYS_DVBT;\r\ndib9000_fw_set_output_mode(state->fe[index_frontend], OUTMODE_HIGH_Z);\r\ndib9000_set_channel_status(state->fe[index_frontend], &state->channel_status);\r\ndib9000_set_tune_state(state->fe[index_frontend], CT_DEMOD_START);\r\n}\r\nexit_condition = 0;\r\nindex_frontend_success = 0;\r\ndo {\r\nsleep_time = dib9000_fw_tune(state->fe[0]);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nsleep_time_slave = dib9000_fw_tune(state->fe[index_frontend]);\r\nif (sleep_time == FE_CALLBACK_TIME_NEVER)\r\nsleep_time = sleep_time_slave;\r\nelse if ((sleep_time_slave != FE_CALLBACK_TIME_NEVER) && (sleep_time_slave > sleep_time))\r\nsleep_time = sleep_time_slave;\r\n}\r\nif (sleep_time != FE_CALLBACK_TIME_NEVER)\r\nmsleep(sleep_time / 10);\r\nelse\r\nbreak;\r\nnbr_pending = 0;\r\nexit_condition = 0;\r\nindex_frontend_success = 0;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nfrontend_status = -dib9000_get_status(state->fe[index_frontend]);\r\nif (frontend_status > -FE_STATUS_TUNE_PENDING) {\r\nexit_condition = 2;\r\nindex_frontend_success = index_frontend;\r\nbreak;\r\n}\r\nif (frontend_status == -FE_STATUS_TUNE_PENDING)\r\nnbr_pending++;\r\n}\r\nif ((exit_condition != 2) && (nbr_pending == 0))\r\nexit_condition = 1;\r\n} while (exit_condition == 0);\r\nif (exit_condition == 1) {\r\ndprintk("tune failed");\r\nmutex_unlock(&state->demod_lock);\r\nstate->pid_ctrl_index = -1;\r\nreturn 0;\r\n}\r\ndprintk("tune success on frontend%i", index_frontend_success);\r\nstate->get_frontend_internal = 1;\r\ndib9000_get_frontend(state->fe[0]);\r\nstate->get_frontend_internal = 0;\r\nchannel_status.status = CHANNEL_STATUS_PARAMETERS_SET;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nif (index_frontend != index_frontend_success) {\r\ndib9000_set_channel_status(state->fe[index_frontend], &channel_status);\r\ndib9000_set_tune_state(state->fe[index_frontend], CT_DEMOD_START);\r\n}\r\n}\r\ndo {\r\nsleep_time = FE_CALLBACK_TIME_NEVER;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nif (index_frontend != index_frontend_success) {\r\nsleep_time_slave = dib9000_fw_tune(state->fe[index_frontend]);\r\nif (sleep_time == FE_CALLBACK_TIME_NEVER)\r\nsleep_time = sleep_time_slave;\r\nelse if ((sleep_time_slave != FE_CALLBACK_TIME_NEVER) && (sleep_time_slave > sleep_time))\r\nsleep_time = sleep_time_slave;\r\n}\r\n}\r\nif (sleep_time != FE_CALLBACK_TIME_NEVER)\r\nmsleep(sleep_time / 10);\r\nelse\r\nbreak;\r\nnbr_pending = 0;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nif (index_frontend != index_frontend_success) {\r\nfrontend_status = -dib9000_get_status(state->fe[index_frontend]);\r\nif ((index_frontend != index_frontend_success) && (frontend_status == -FE_STATUS_TUNE_PENDING))\r\nnbr_pending++;\r\n}\r\n}\r\n} while (nbr_pending != 0);\r\ndib9000_fw_set_output_mode(state->fe[0], state->chip.d9.cfg.output_mode);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\ndib9000_fw_set_output_mode(state->fe[index_frontend], OUTMODE_DIVERSITY);\r\ndib9000_fw_set_diversity_in(state->fe[index_frontend - 1], 0);\r\nmutex_unlock(&state->demod_lock);\r\nif (state->pid_ctrl_index >= 0) {\r\nu8 index_pid_filter_cmd;\r\nu8 pid_ctrl_index = state->pid_ctrl_index;\r\nstate->pid_ctrl_index = -2;\r\nfor (index_pid_filter_cmd = 0;\r\nindex_pid_filter_cmd <= pid_ctrl_index;\r\nindex_pid_filter_cmd++) {\r\nif (state->pid_ctrl[index_pid_filter_cmd].cmd == DIB9000_PID_FILTER_CTRL)\r\ndib9000_fw_pid_filter_ctrl(state->fe[0],\r\nstate->pid_ctrl[index_pid_filter_cmd].onoff);\r\nelse if (state->pid_ctrl[index_pid_filter_cmd].cmd == DIB9000_PID_FILTER)\r\ndib9000_fw_pid_filter(state->fe[0],\r\nstate->pid_ctrl[index_pid_filter_cmd].id,\r\nstate->pid_ctrl[index_pid_filter_cmd].pid,\r\nstate->pid_ctrl[index_pid_filter_cmd].onoff);\r\n}\r\n}\r\nstate->pid_ctrl_index = -2;\r\nreturn 0;\r\n}\r\nstatic u16 dib9000_read_lock(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nreturn dib9000_read_word(state, 535);\r\n}\r\nstatic int dib9000_read_status(struct dvb_frontend *fe, fe_status_t * stat)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nu16 lock = 0, lock_slave = 0;\r\nif (mutex_lock_interruptible(&state->demod_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -EINTR;\r\n}\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\nlock_slave |= dib9000_read_lock(state->fe[index_frontend]);\r\nlock = dib9000_read_word(state, 535);\r\n*stat = 0;\r\nif ((lock & 0x8000) || (lock_slave & 0x8000))\r\n*stat |= FE_HAS_SIGNAL;\r\nif ((lock & 0x3000) || (lock_slave & 0x3000))\r\n*stat |= FE_HAS_CARRIER;\r\nif ((lock & 0x0100) || (lock_slave & 0x0100))\r\n*stat |= FE_HAS_VITERBI;\r\nif (((lock & 0x0038) == 0x38) || ((lock_slave & 0x0038) == 0x38))\r\n*stat |= FE_HAS_SYNC;\r\nif ((lock & 0x0008) || (lock_slave & 0x0008))\r\n*stat |= FE_HAS_LOCK;\r\nmutex_unlock(&state->demod_lock);\r\nreturn 0;\r\n}\r\nstatic int dib9000_read_ber(struct dvb_frontend *fe, u32 * ber)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nu16 *c;\r\nint ret = 0;\r\nif (mutex_lock_interruptible(&state->demod_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -EINTR;\r\n}\r\nif (mutex_lock_interruptible(&state->platform.risc.mem_mbx_lock) < 0) {\r\ndprintk("could not get the lock");\r\nret = -EINTR;\r\ngoto error;\r\n}\r\nif (dib9000_fw_memmbx_sync(state, FE_SYNC_CHANNEL) < 0) {\r\nmutex_unlock(&state->platform.risc.mem_mbx_lock);\r\nret = -EIO;\r\ngoto error;\r\n}\r\ndib9000_risc_mem_read(state, FE_MM_R_FE_MONITOR,\r\nstate->i2c_read_buffer, 16 * 2);\r\nmutex_unlock(&state->platform.risc.mem_mbx_lock);\r\nc = (u16 *)state->i2c_read_buffer;\r\n*ber = c[10] << 16 | c[11];\r\nerror:\r\nmutex_unlock(&state->demod_lock);\r\nreturn ret;\r\n}\r\nstatic int dib9000_read_signal_strength(struct dvb_frontend *fe, u16 * strength)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nu16 *c = (u16 *)state->i2c_read_buffer;\r\nu16 val;\r\nint ret = 0;\r\nif (mutex_lock_interruptible(&state->demod_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -EINTR;\r\n}\r\n*strength = 0;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->ops.read_signal_strength(state->fe[index_frontend], &val);\r\nif (val > 65535 - *strength)\r\n*strength = 65535;\r\nelse\r\n*strength += val;\r\n}\r\nif (mutex_lock_interruptible(&state->platform.risc.mem_mbx_lock) < 0) {\r\ndprintk("could not get the lock");\r\nret = -EINTR;\r\ngoto error;\r\n}\r\nif (dib9000_fw_memmbx_sync(state, FE_SYNC_CHANNEL) < 0) {\r\nmutex_unlock(&state->platform.risc.mem_mbx_lock);\r\nret = -EIO;\r\ngoto error;\r\n}\r\ndib9000_risc_mem_read(state, FE_MM_R_FE_MONITOR, (u8 *) c, 16 * 2);\r\nmutex_unlock(&state->platform.risc.mem_mbx_lock);\r\nval = 65535 - c[4];\r\nif (val > 65535 - *strength)\r\n*strength = 65535;\r\nelse\r\n*strength += val;\r\nerror:\r\nmutex_unlock(&state->demod_lock);\r\nreturn ret;\r\n}\r\nstatic u32 dib9000_get_snr(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nu16 *c = (u16 *)state->i2c_read_buffer;\r\nu32 n, s, exp;\r\nu16 val;\r\nif (mutex_lock_interruptible(&state->platform.risc.mem_mbx_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn 0;\r\n}\r\nif (dib9000_fw_memmbx_sync(state, FE_SYNC_CHANNEL) < 0) {\r\nmutex_unlock(&state->platform.risc.mem_mbx_lock);\r\nreturn 0;\r\n}\r\ndib9000_risc_mem_read(state, FE_MM_R_FE_MONITOR, (u8 *) c, 16 * 2);\r\nmutex_unlock(&state->platform.risc.mem_mbx_lock);\r\nval = c[7];\r\nn = (val >> 4) & 0xff;\r\nexp = ((val & 0xf) << 2);\r\nval = c[8];\r\nexp += ((val >> 14) & 0x3);\r\nif ((exp & 0x20) != 0)\r\nexp -= 0x40;\r\nn <<= exp + 16;\r\ns = (val >> 6) & 0xFF;\r\nexp = (val & 0x3F);\r\nif ((exp & 0x20) != 0)\r\nexp -= 0x40;\r\ns <<= exp + 16;\r\nif (n > 0) {\r\nu32 t = (s / n) << 16;\r\nreturn t + ((s << 16) - n * t) / n;\r\n}\r\nreturn 0xffffffff;\r\n}\r\nstatic int dib9000_read_snr(struct dvb_frontend *fe, u16 * snr)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nu32 snr_master;\r\nif (mutex_lock_interruptible(&state->demod_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -EINTR;\r\n}\r\nsnr_master = dib9000_get_snr(fe);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\nsnr_master += dib9000_get_snr(state->fe[index_frontend]);\r\nif ((snr_master >> 16) != 0) {\r\nsnr_master = 10 * intlog10(snr_master >> 16);\r\n*snr = snr_master / ((1 << 24) / 10);\r\n} else\r\n*snr = 0;\r\nmutex_unlock(&state->demod_lock);\r\nreturn 0;\r\n}\r\nstatic int dib9000_read_unc_blocks(struct dvb_frontend *fe, u32 * unc)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nu16 *c = (u16 *)state->i2c_read_buffer;\r\nint ret = 0;\r\nif (mutex_lock_interruptible(&state->demod_lock) < 0) {\r\ndprintk("could not get the lock");\r\nreturn -EINTR;\r\n}\r\nif (mutex_lock_interruptible(&state->platform.risc.mem_mbx_lock) < 0) {\r\ndprintk("could not get the lock");\r\nret = -EINTR;\r\ngoto error;\r\n}\r\nif (dib9000_fw_memmbx_sync(state, FE_SYNC_CHANNEL) < 0) {\r\nmutex_unlock(&state->platform.risc.mem_mbx_lock);\r\nret = -EIO;\r\ngoto error;\r\n}\r\ndib9000_risc_mem_read(state, FE_MM_R_FE_MONITOR, (u8 *) c, 16 * 2);\r\nmutex_unlock(&state->platform.risc.mem_mbx_lock);\r\n*unc = c[12];\r\nerror:\r\nmutex_unlock(&state->demod_lock);\r\nreturn ret;\r\n}\r\nint dib9000_i2c_enumeration(struct i2c_adapter *i2c, int no_of_demods, u8 default_addr, u8 first_addr)\r\n{\r\nint k = 0, ret = 0;\r\nu8 new_addr = 0;\r\nstruct i2c_device client = {.i2c_adap = i2c };\r\nclient.i2c_write_buffer = kzalloc(4 * sizeof(u8), GFP_KERNEL);\r\nif (!client.i2c_write_buffer) {\r\ndprintk("%s: not enough memory", __func__);\r\nreturn -ENOMEM;\r\n}\r\nclient.i2c_read_buffer = kzalloc(4 * sizeof(u8), GFP_KERNEL);\r\nif (!client.i2c_read_buffer) {\r\ndprintk("%s: not enough memory", __func__);\r\nret = -ENOMEM;\r\ngoto error_memory;\r\n}\r\nclient.i2c_addr = default_addr + 16;\r\ndib9000_i2c_write16(&client, 1796, 0x0);\r\nfor (k = no_of_demods - 1; k >= 0; k--) {\r\nnew_addr = first_addr + (k << 1);\r\nclient.i2c_addr = default_addr;\r\ndib9000_i2c_write16(&client, 1817, 3);\r\ndib9000_i2c_write16(&client, 1796, 0);\r\ndib9000_i2c_write16(&client, 1227, 1);\r\ndib9000_i2c_write16(&client, 1227, 0);\r\nclient.i2c_addr = new_addr;\r\ndib9000_i2c_write16(&client, 1817, 3);\r\ndib9000_i2c_write16(&client, 1796, 0);\r\ndib9000_i2c_write16(&client, 1227, 1);\r\ndib9000_i2c_write16(&client, 1227, 0);\r\nif (dib9000_identify(&client) == 0) {\r\nclient.i2c_addr = default_addr;\r\nif (dib9000_identify(&client) == 0) {\r\ndprintk("DiB9000 #%d: not identified", k);\r\nret = -EIO;\r\ngoto error;\r\n}\r\n}\r\ndib9000_i2c_write16(&client, 1795, (1 << 10) | (4 << 6));\r\ndib9000_i2c_write16(&client, 1794, (new_addr << 2) | 2);\r\ndprintk("IC %d initialized (to i2c_address 0x%x)", k, new_addr);\r\n}\r\nfor (k = 0; k < no_of_demods; k++) {\r\nnew_addr = first_addr | (k << 1);\r\nclient.i2c_addr = new_addr;\r\ndib9000_i2c_write16(&client, 1794, (new_addr << 2));\r\ndib9000_i2c_write16(&client, 1795, 0);\r\n}\r\nerror:\r\nkfree(client.i2c_read_buffer);\r\nerror_memory:\r\nkfree(client.i2c_write_buffer);\r\nreturn ret;\r\n}\r\nint dib9000_set_slave_frontend(struct dvb_frontend *fe, struct dvb_frontend *fe_slave)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nu8 index_frontend = 1;\r\nwhile ((index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL))\r\nindex_frontend++;\r\nif (index_frontend < MAX_NUMBER_OF_FRONTENDS) {\r\ndprintk("set slave fe %p to index %i", fe_slave, index_frontend);\r\nstate->fe[index_frontend] = fe_slave;\r\nreturn 0;\r\n}\r\ndprintk("too many slave frontend");\r\nreturn -ENOMEM;\r\n}\r\nint dib9000_remove_slave_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nu8 index_frontend = 1;\r\nwhile ((index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL))\r\nindex_frontend++;\r\nif (index_frontend != 1) {\r\ndprintk("remove slave fe %p (index %i)", state->fe[index_frontend - 1], index_frontend - 1);\r\nstate->fe[index_frontend] = NULL;\r\nreturn 0;\r\n}\r\ndprintk("no frontend to be removed");\r\nreturn -ENODEV;\r\n}\r\nstruct dvb_frontend *dib9000_get_slave_frontend(struct dvb_frontend *fe, int slave_index)\r\n{\r\nstruct dib9000_state *state = fe->demodulator_priv;\r\nif (slave_index >= MAX_NUMBER_OF_FRONTENDS)\r\nreturn NULL;\r\nreturn state->fe[slave_index];\r\n}\r\nstruct dvb_frontend *dib9000_attach(struct i2c_adapter *i2c_adap, u8 i2c_addr, const struct dib9000_config *cfg)\r\n{\r\nstruct dvb_frontend *fe;\r\nstruct dib9000_state *st;\r\nst = kzalloc(sizeof(struct dib9000_state), GFP_KERNEL);\r\nif (st == NULL)\r\nreturn NULL;\r\nfe = kzalloc(sizeof(struct dvb_frontend), GFP_KERNEL);\r\nif (fe == NULL) {\r\nkfree(st);\r\nreturn NULL;\r\n}\r\nmemcpy(&st->chip.d9.cfg, cfg, sizeof(struct dib9000_config));\r\nst->i2c.i2c_adap = i2c_adap;\r\nst->i2c.i2c_addr = i2c_addr;\r\nst->i2c.i2c_write_buffer = st->i2c_write_buffer;\r\nst->i2c.i2c_read_buffer = st->i2c_read_buffer;\r\nst->gpio_dir = DIB9000_GPIO_DEFAULT_DIRECTIONS;\r\nst->gpio_val = DIB9000_GPIO_DEFAULT_VALUES;\r\nst->gpio_pwm_pos = DIB9000_GPIO_DEFAULT_PWM_POS;\r\nmutex_init(&st->platform.risc.mbx_if_lock);\r\nmutex_init(&st->platform.risc.mbx_lock);\r\nmutex_init(&st->platform.risc.mem_lock);\r\nmutex_init(&st->platform.risc.mem_mbx_lock);\r\nmutex_init(&st->demod_lock);\r\nst->get_frontend_internal = 0;\r\nst->pid_ctrl_index = -2;\r\nst->fe[0] = fe;\r\nfe->demodulator_priv = st;\r\nmemcpy(&st->fe[0]->ops, &dib9000_ops, sizeof(struct dvb_frontend_ops));\r\nif ((st->chip.d9.cfg.output_mode != OUTMODE_MPEG2_SERIAL) && (st->chip.d9.cfg.output_mode != OUTMODE_MPEG2_PAR_GATED_CLK))\r\nst->chip.d9.cfg.output_mode = OUTMODE_MPEG2_FIFO;\r\nif (dib9000_identify(&st->i2c) == 0)\r\ngoto error;\r\ndibx000_init_i2c_master(&st->i2c_master, DIB7000MC, st->i2c.i2c_adap, st->i2c.i2c_addr);\r\nst->tuner_adap.dev.parent = i2c_adap->dev.parent;\r\nstrncpy(st->tuner_adap.name, "DIB9000_FW TUNER ACCESS", sizeof(st->tuner_adap.name));\r\nst->tuner_adap.algo = &dib9000_tuner_algo;\r\nst->tuner_adap.algo_data = NULL;\r\ni2c_set_adapdata(&st->tuner_adap, st);\r\nif (i2c_add_adapter(&st->tuner_adap) < 0)\r\ngoto error;\r\nst->component_bus.dev.parent = i2c_adap->dev.parent;\r\nstrncpy(st->component_bus.name, "DIB9000_FW COMPONENT BUS ACCESS", sizeof(st->component_bus.name));\r\nst->component_bus.algo = &dib9000_component_bus_algo;\r\nst->component_bus.algo_data = NULL;\r\nst->component_bus_speed = 340;\r\ni2c_set_adapdata(&st->component_bus, st);\r\nif (i2c_add_adapter(&st->component_bus) < 0)\r\ngoto component_bus_add_error;\r\ndib9000_fw_reset(fe);\r\nreturn fe;\r\ncomponent_bus_add_error:\r\ni2c_del_adapter(&st->tuner_adap);\r\nerror:\r\nkfree(st);\r\nreturn NULL;\r\n}
