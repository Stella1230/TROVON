static int msm_gpio_write(struct msm_gpio_chip *msm_chip,\r\nunsigned offset, unsigned on)\r\n{\r\nunsigned mask = BIT(offset);\r\nunsigned val;\r\nval = readl(msm_chip->regs.out);\r\nif (on)\r\nwritel(val | mask, msm_chip->regs.out);\r\nelse\r\nwritel(val & ~mask, msm_chip->regs.out);\r\nreturn 0;\r\n}\r\nstatic void msm_gpio_update_both_edge_detect(struct msm_gpio_chip *msm_chip)\r\n{\r\nint loop_limit = 100;\r\nunsigned pol, val, val2, intstat;\r\ndo {\r\nval = readl(msm_chip->regs.in);\r\npol = readl(msm_chip->regs.int_pos);\r\npol = (pol & ~msm_chip->both_edge_detect) |\r\n(~val & msm_chip->both_edge_detect);\r\nwritel(pol, msm_chip->regs.int_pos);\r\nintstat = readl(msm_chip->regs.int_status);\r\nval2 = readl(msm_chip->regs.in);\r\nif (((val ^ val2) & msm_chip->both_edge_detect & ~intstat) == 0)\r\nreturn;\r\n} while (loop_limit-- > 0);\r\nprintk(KERN_ERR "msm_gpio_update_both_edge_detect, "\r\n"failed to reach stable state %x != %x\n", val, val2);\r\n}\r\nstatic int msm_gpio_clear_detect_status(struct msm_gpio_chip *msm_chip,\r\nunsigned offset)\r\n{\r\nunsigned bit = BIT(offset);\r\n#if MSM_GPIO_BROKEN_INT_CLEAR\r\nmsm_chip->int_status_copy |= readl(msm_chip->regs.int_status);\r\nmsm_chip->int_status_copy &= ~bit;\r\n#endif\r\nwritel(bit, msm_chip->regs.int_clear);\r\nmsm_gpio_update_both_edge_detect(msm_chip);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct msm_gpio_chip *msm_chip;\r\nunsigned long irq_flags;\r\nmsm_chip = container_of(chip, struct msm_gpio_chip, chip);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nwritel(readl(msm_chip->regs.oe) & ~BIT(offset), msm_chip->regs.oe);\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nmsm_gpio_direction_output(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct msm_gpio_chip *msm_chip;\r\nunsigned long irq_flags;\r\nmsm_chip = container_of(chip, struct msm_gpio_chip, chip);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nmsm_gpio_write(msm_chip, offset, value);\r\nwritel(readl(msm_chip->regs.oe) | BIT(offset), msm_chip->regs.oe);\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct msm_gpio_chip *msm_chip;\r\nmsm_chip = container_of(chip, struct msm_gpio_chip, chip);\r\nreturn (readl(msm_chip->regs.in) & (1U << offset)) ? 1 : 0;\r\n}\r\nstatic void msm_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct msm_gpio_chip *msm_chip;\r\nunsigned long irq_flags;\r\nmsm_chip = container_of(chip, struct msm_gpio_chip, chip);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nmsm_gpio_write(msm_chip, offset, value);\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\n}\r\nstatic int msm_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn MSM_GPIO_TO_INT(chip->base + offset);\r\n}\r\nstatic int msm_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn msm_gpiomux_get(chip->base + offset);\r\n}\r\nstatic void msm_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nmsm_gpiomux_put(chip->base + offset);\r\n}\r\nstatic void msm_gpio_irq_ack(struct irq_data *d)\r\n{\r\nunsigned long irq_flags;\r\nstruct msm_gpio_chip *msm_chip = irq_data_get_irq_chip_data(d);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nmsm_gpio_clear_detect_status(msm_chip,\r\nd->irq - gpio_to_irq(msm_chip->chip.base));\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\n}\r\nstatic void msm_gpio_irq_mask(struct irq_data *d)\r\n{\r\nunsigned long irq_flags;\r\nstruct msm_gpio_chip *msm_chip = irq_data_get_irq_chip_data(d);\r\nunsigned offset = d->irq - gpio_to_irq(msm_chip->chip.base);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nif (!(readl(msm_chip->regs.int_edge) & BIT(offset)))\r\nmsm_gpio_clear_detect_status(msm_chip, offset);\r\nmsm_chip->int_enable[0] &= ~BIT(offset);\r\nwritel(msm_chip->int_enable[0], msm_chip->regs.int_en);\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\n}\r\nstatic void msm_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nunsigned long irq_flags;\r\nstruct msm_gpio_chip *msm_chip = irq_data_get_irq_chip_data(d);\r\nunsigned offset = d->irq - gpio_to_irq(msm_chip->chip.base);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nif (!(readl(msm_chip->regs.int_edge) & BIT(offset)))\r\nmsm_gpio_clear_detect_status(msm_chip, offset);\r\nmsm_chip->int_enable[0] |= BIT(offset);\r\nwritel(msm_chip->int_enable[0], msm_chip->regs.int_en);\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\n}\r\nstatic int msm_gpio_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nunsigned long irq_flags;\r\nstruct msm_gpio_chip *msm_chip = irq_data_get_irq_chip_data(d);\r\nunsigned offset = d->irq - gpio_to_irq(msm_chip->chip.base);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nif (on)\r\nmsm_chip->int_enable[1] |= BIT(offset);\r\nelse\r\nmsm_chip->int_enable[1] &= ~BIT(offset);\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nunsigned long irq_flags;\r\nstruct msm_gpio_chip *msm_chip = irq_data_get_irq_chip_data(d);\r\nunsigned offset = d->irq - gpio_to_irq(msm_chip->chip.base);\r\nunsigned val, mask = BIT(offset);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nval = readl(msm_chip->regs.int_edge);\r\nif (flow_type & IRQ_TYPE_EDGE_BOTH) {\r\nwritel(val | mask, msm_chip->regs.int_edge);\r\n__irq_set_handler_locked(d->irq, handle_edge_irq);\r\n} else {\r\nwritel(val & ~mask, msm_chip->regs.int_edge);\r\n__irq_set_handler_locked(d->irq, handle_level_irq);\r\n}\r\nif ((flow_type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {\r\nmsm_chip->both_edge_detect |= mask;\r\nmsm_gpio_update_both_edge_detect(msm_chip);\r\n} else {\r\nmsm_chip->both_edge_detect &= ~mask;\r\nval = readl(msm_chip->regs.int_pos);\r\nif (flow_type & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_HIGH))\r\nwritel(val | mask, msm_chip->regs.int_pos);\r\nelse\r\nwritel(val & ~mask, msm_chip->regs.int_pos);\r\n}\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic void msm_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nint i, j, mask;\r\nunsigned val;\r\nfor (i = 0; i < msm_gpio_count; i++) {\r\nstruct msm_gpio_chip *msm_chip = &msm_gpio_chips[i];\r\nval = readl(msm_chip->regs.int_status);\r\nval &= msm_chip->int_enable[0];\r\nwhile (val) {\r\nmask = val & -val;\r\nj = fls(mask) - 1;\r\nval &= ~mask;\r\ngeneric_handle_irq(FIRST_GPIO_IRQ +\r\nmsm_chip->chip.base + j);\r\n}\r\n}\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\n}\r\nstatic int __init msm_init_gpio(void)\r\n{\r\nint i, j = 0;\r\nif (cpu_is_msm7x01()) {\r\nmsm_gpio_chips = msm_gpio_chips_msm7x01;\r\nmsm_gpio_count = ARRAY_SIZE(msm_gpio_chips_msm7x01);\r\n} else if (cpu_is_msm7x30()) {\r\nmsm_gpio_chips = msm_gpio_chips_msm7x30;\r\nmsm_gpio_count = ARRAY_SIZE(msm_gpio_chips_msm7x30);\r\n} else if (cpu_is_qsd8x50()) {\r\nmsm_gpio_chips = msm_gpio_chips_qsd8x50;\r\nmsm_gpio_count = ARRAY_SIZE(msm_gpio_chips_qsd8x50);\r\n} else {\r\nreturn 0;\r\n}\r\nfor (i = FIRST_GPIO_IRQ; i < FIRST_GPIO_IRQ + NR_GPIO_IRQS; i++) {\r\nif (i - FIRST_GPIO_IRQ >=\r\nmsm_gpio_chips[j].chip.base +\r\nmsm_gpio_chips[j].chip.ngpio)\r\nj++;\r\nirq_set_chip_data(i, &msm_gpio_chips[j]);\r\nirq_set_chip_and_handler(i, &msm_gpio_irq_chip,\r\nhandle_edge_irq);\r\nset_irq_flags(i, IRQF_VALID);\r\n}\r\nfor (i = 0; i < msm_gpio_count; i++) {\r\nspin_lock_init(&msm_gpio_chips[i].lock);\r\nwritel(0, msm_gpio_chips[i].regs.int_en);\r\ngpiochip_add(&msm_gpio_chips[i].chip);\r\n}\r\nirq_set_chained_handler(INT_GPIO_GROUP1, msm_gpio_irq_handler);\r\nirq_set_chained_handler(INT_GPIO_GROUP2, msm_gpio_irq_handler);\r\nirq_set_irq_wake(INT_GPIO_GROUP1, 1);\r\nirq_set_irq_wake(INT_GPIO_GROUP2, 2);\r\nreturn 0;\r\n}
