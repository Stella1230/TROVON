static void cpwd_writew(u16 val, void __iomem *addr)\r\n{\r\nwritew(cpu_to_le16(val), addr);\r\n}\r\nstatic u16 cpwd_readw(void __iomem *addr)\r\n{\r\nu16 val = readw(addr);\r\nreturn le16_to_cpu(val);\r\n}\r\nstatic void cpwd_writeb(u8 val, void __iomem *addr)\r\n{\r\nwriteb(val, addr);\r\n}\r\nstatic u8 cpwd_readb(void __iomem *addr)\r\n{\r\nreturn readb(addr);\r\n}\r\nstatic void cpwd_toggleintr(struct cpwd *p, int index, int enable)\r\n{\r\nunsigned char curregs = cpwd_readb(p->regs + PLD_IMASK);\r\nunsigned char setregs =\r\n(index == -1) ?\r\n(WD0_INTR_MASK | WD1_INTR_MASK | WD2_INTR_MASK) :\r\n(p->devs[index].intr_mask);\r\nif (enable == WD_INTR_ON)\r\ncurregs &= ~setregs;\r\nelse\r\ncurregs |= setregs;\r\ncpwd_writeb(curregs, p->regs + PLD_IMASK);\r\n}\r\nstatic void cpwd_resetbrokentimer(struct cpwd *p, int index)\r\n{\r\ncpwd_toggleintr(p, index, WD_INTR_ON);\r\ncpwd_writew(WD_BLIMIT, p->devs[index].regs + WD_LIMIT);\r\n}\r\nstatic void cpwd_brokentimer(unsigned long data)\r\n{\r\nstruct cpwd *p = (struct cpwd *) data;\r\nint id, tripped = 0;\r\nif (timer_pending(&cpwd_timer))\r\ndel_timer(&cpwd_timer);\r\nfor (id = 0; id < WD_NUMDEVS; id++) {\r\nif (p->devs[id].runstatus & WD_STAT_BSTOP) {\r\n++tripped;\r\ncpwd_resetbrokentimer(p, id);\r\n}\r\n}\r\nif (tripped) {\r\ncpwd_timer.expires = WD_BTIMEOUT;\r\nadd_timer(&cpwd_timer);\r\n}\r\n}\r\nstatic void cpwd_pingtimer(struct cpwd *p, int index)\r\n{\r\nif (cpwd_readb(p->devs[index].regs + WD_STATUS) & WD_S_RUNNING)\r\ncpwd_readw(p->devs[index].regs + WD_DCNTR);\r\n}\r\nstatic void cpwd_stoptimer(struct cpwd *p, int index)\r\n{\r\nif (cpwd_readb(p->devs[index].regs + WD_STATUS) & WD_S_RUNNING) {\r\ncpwd_toggleintr(p, index, WD_INTR_OFF);\r\nif (p->broken) {\r\np->devs[index].runstatus |= WD_STAT_BSTOP;\r\ncpwd_brokentimer((unsigned long) p);\r\n}\r\n}\r\n}\r\nstatic void cpwd_starttimer(struct cpwd *p, int index)\r\n{\r\nif (p->broken)\r\np->devs[index].runstatus &= ~WD_STAT_BSTOP;\r\np->devs[index].runstatus &= ~WD_STAT_SVCD;\r\ncpwd_writew(p->devs[index].timeout, p->devs[index].regs + WD_LIMIT);\r\ncpwd_toggleintr(p, index, WD_INTR_ON);\r\n}\r\nstatic int cpwd_getstatus(struct cpwd *p, int index)\r\n{\r\nunsigned char stat = cpwd_readb(p->devs[index].regs + WD_STATUS);\r\nunsigned char intr = cpwd_readb(p->devs[index].regs + PLD_IMASK);\r\nunsigned char ret = WD_STOPPED;\r\nif (!stat)\r\nreturn ret;\r\nelse if (WD_S_EXPIRED & stat) {\r\nret = WD_EXPIRED;\r\n} else if (WD_S_RUNNING & stat) {\r\nif (intr & p->devs[index].intr_mask) {\r\nret = WD_FREERUN;\r\n} else {\r\nif (p->broken &&\r\n(p->devs[index].runstatus & WD_STAT_BSTOP)) {\r\nif (p->devs[index].runstatus & WD_STAT_SVCD) {\r\nret = WD_EXPIRED;\r\n} else {\r\nret = WD_FREERUN;\r\n}\r\n} else {\r\nret = WD_RUNNING;\r\n}\r\n}\r\n}\r\nif (p->devs[index].runstatus & WD_STAT_SVCD)\r\nret |= WD_SERVICED;\r\nreturn ret;\r\n}\r\nstatic irqreturn_t cpwd_interrupt(int irq, void *dev_id)\r\n{\r\nstruct cpwd *p = dev_id;\r\nspin_lock_irq(&p->lock);\r\ncpwd_stoptimer(p, WD0_ID);\r\np->devs[WD0_ID].runstatus |= WD_STAT_SVCD;\r\nspin_unlock_irq(&p->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cpwd_open(struct inode *inode, struct file *f)\r\n{\r\nstruct cpwd *p = cpwd_device;\r\nmutex_lock(&cpwd_mutex);\r\nswitch (iminor(inode)) {\r\ncase WD0_MINOR:\r\ncase WD1_MINOR:\r\ncase WD2_MINOR:\r\nbreak;\r\ndefault:\r\nmutex_unlock(&cpwd_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (!p->initialized) {\r\nif (request_irq(p->irq, &cpwd_interrupt,\r\nIRQF_SHARED, DRIVER_NAME, p)) {\r\npr_err("Cannot register IRQ %d\n", p->irq);\r\nmutex_unlock(&cpwd_mutex);\r\nreturn -EBUSY;\r\n}\r\np->initialized = true;\r\n}\r\nmutex_unlock(&cpwd_mutex);\r\nreturn nonseekable_open(inode, f);\r\n}\r\nstatic int cpwd_release(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic long cpwd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstatic const struct watchdog_info info = {\r\n.options = WDIOF_SETTIMEOUT,\r\n.firmware_version = 1,\r\n.identity = DRIVER_NAME,\r\n};\r\nvoid __user *argp = (void __user *)arg;\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nint index = iminor(inode) - WD0_MINOR;\r\nstruct cpwd *p = cpwd_device;\r\nint setopt = 0;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &info, sizeof(struct watchdog_info)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nif (put_user(0, (int __user *)argp))\r\nreturn -EFAULT;\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\ncpwd_pingtimer(p, index);\r\nbreak;\r\ncase WDIOC_SETOPTIONS:\r\nif (copy_from_user(&setopt, argp, sizeof(unsigned int)))\r\nreturn -EFAULT;\r\nif (setopt & WDIOS_DISABLECARD) {\r\nif (p->enabled)\r\nreturn -EINVAL;\r\ncpwd_stoptimer(p, index);\r\n} else if (setopt & WDIOS_ENABLECARD) {\r\ncpwd_starttimer(p, index);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase WIOCGSTAT:\r\nsetopt = cpwd_getstatus(p, index);\r\nif (copy_to_user(argp, &setopt, sizeof(unsigned int)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase WIOCSTART:\r\ncpwd_starttimer(p, index);\r\nbreak;\r\ncase WIOCSTOP:\r\nif (p->enabled)\r\nreturn -EINVAL;\r\ncpwd_stoptimer(p, index);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic long cpwd_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint rval = -ENOIOCTLCMD;\r\nswitch (cmd) {\r\ncase WIOCSTART:\r\ncase WIOCSTOP:\r\ncase WIOCGSTAT:\r\nmutex_lock(&cpwd_mutex);\r\nrval = cpwd_ioctl(file, cmd, arg);\r\nmutex_unlock(&cpwd_mutex);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn rval;\r\n}\r\nstatic ssize_t cpwd_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nstruct cpwd *p = cpwd_device;\r\nint index = iminor(inode);\r\nif (count) {\r\ncpwd_pingtimer(p, index);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t cpwd_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int __devinit cpwd_probe(struct platform_device *op)\r\n{\r\nstruct device_node *options;\r\nconst char *str_prop;\r\nconst void *prop_val;\r\nint i, err = -EINVAL;\r\nstruct cpwd *p;\r\nif (cpwd_device)\r\nreturn -EINVAL;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!p) {\r\npr_err("Unable to allocate struct cpwd\n");\r\ngoto out;\r\n}\r\np->irq = op->archdata.irqs[0];\r\nspin_lock_init(&p->lock);\r\np->regs = of_ioremap(&op->resource[0], 0,\r\n4 * WD_TIMER_REGSZ, DRIVER_NAME);\r\nif (!p->regs) {\r\npr_err("Unable to map registers\n");\r\ngoto out_free;\r\n}\r\noptions = of_find_node_by_path("/options");\r\nerr = -ENODEV;\r\nif (!options) {\r\npr_err("Unable to find /options node\n");\r\ngoto out_iounmap;\r\n}\r\nprop_val = of_get_property(options, "watchdog-enable?", NULL);\r\np->enabled = (prop_val ? true : false);\r\nprop_val = of_get_property(options, "watchdog-reboot?", NULL);\r\np->reboot = (prop_val ? true : false);\r\nstr_prop = of_get_property(options, "watchdog-timeout", NULL);\r\nif (str_prop)\r\np->timeout = simple_strtoul(str_prop, NULL, 10);\r\nstr_prop = of_get_property(op->dev.of_node, "model", NULL);\r\np->broken = (str_prop && !strcmp(str_prop, WD_BADMODEL));\r\nif (!p->enabled)\r\ncpwd_toggleintr(p, -1, WD_INTR_OFF);\r\nfor (i = 0; i < WD_NUMDEVS; i++) {\r\nstatic const char *cpwd_names[] = { "RIC", "XIR", "POR" };\r\nstatic int *parms[] = { &wd0_timeout,\r\n&wd1_timeout,\r\n&wd2_timeout };\r\nstruct miscdevice *mp = &p->devs[i].misc;\r\nmp->minor = WD0_MINOR + i;\r\nmp->name = cpwd_names[i];\r\nmp->fops = &cpwd_fops;\r\np->devs[i].regs = p->regs + (i * WD_TIMER_REGSZ);\r\np->devs[i].intr_mask = (WD0_INTR_MASK << i);\r\np->devs[i].runstatus &= ~WD_STAT_BSTOP;\r\np->devs[i].runstatus |= WD_STAT_INIT;\r\np->devs[i].timeout = p->timeout;\r\nif (*parms[i])\r\np->devs[i].timeout = *parms[i];\r\nerr = misc_register(&p->devs[i].misc);\r\nif (err) {\r\npr_err("Could not register misc device for dev %d\n",\r\ni);\r\ngoto out_unregister;\r\n}\r\n}\r\nif (p->broken) {\r\ninit_timer(&cpwd_timer);\r\ncpwd_timer.function = cpwd_brokentimer;\r\ncpwd_timer.data = (unsigned long) p;\r\ncpwd_timer.expires = WD_BTIMEOUT;\r\npr_info("PLD defect workaround enabled for model %s\n",\r\nWD_BADMODEL);\r\n}\r\ndev_set_drvdata(&op->dev, p);\r\ncpwd_device = p;\r\nerr = 0;\r\nout:\r\nreturn err;\r\nout_unregister:\r\nfor (i--; i >= 0; i--)\r\nmisc_deregister(&p->devs[i].misc);\r\nout_iounmap:\r\nof_iounmap(&op->resource[0], p->regs, 4 * WD_TIMER_REGSZ);\r\nout_free:\r\nkfree(p);\r\ngoto out;\r\n}\r\nstatic int __devexit cpwd_remove(struct platform_device *op)\r\n{\r\nstruct cpwd *p = dev_get_drvdata(&op->dev);\r\nint i;\r\nfor (i = 0; i < WD_NUMDEVS; i++) {\r\nmisc_deregister(&p->devs[i].misc);\r\nif (!p->enabled) {\r\ncpwd_stoptimer(p, i);\r\nif (p->devs[i].runstatus & WD_STAT_BSTOP)\r\ncpwd_resetbrokentimer(p, i);\r\n}\r\n}\r\nif (p->broken)\r\ndel_timer_sync(&cpwd_timer);\r\nif (p->initialized)\r\nfree_irq(p->irq, p);\r\nof_iounmap(&op->resource[0], p->regs, 4 * WD_TIMER_REGSZ);\r\nkfree(p);\r\ncpwd_device = NULL;\r\nreturn 0;\r\n}
