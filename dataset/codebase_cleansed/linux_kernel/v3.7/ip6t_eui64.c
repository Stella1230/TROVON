static bool\r\neui64_mt6(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nunsigned char eui64[8];\r\nif (!(skb_mac_header(skb) >= skb->head &&\r\nskb_mac_header(skb) + ETH_HLEN <= skb->data) &&\r\npar->fragoff != 0) {\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nmemset(eui64, 0, sizeof(eui64));\r\nif (eth_hdr(skb)->h_proto == htons(ETH_P_IPV6)) {\r\nif (ipv6_hdr(skb)->version == 0x6) {\r\nmemcpy(eui64, eth_hdr(skb)->h_source, 3);\r\nmemcpy(eui64 + 5, eth_hdr(skb)->h_source + 3, 3);\r\neui64[3] = 0xff;\r\neui64[4] = 0xfe;\r\neui64[0] ^= 0x02;\r\nif (!memcmp(ipv6_hdr(skb)->saddr.s6_addr + 8, eui64,\r\nsizeof(eui64)))\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int __init eui64_mt6_init(void)\r\n{\r\nreturn xt_register_match(&eui64_mt6_reg);\r\n}\r\nstatic void __exit eui64_mt6_exit(void)\r\n{\r\nxt_unregister_match(&eui64_mt6_reg);\r\n}
