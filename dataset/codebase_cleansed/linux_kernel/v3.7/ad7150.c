static int ad7150_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nint ret;\r\nstruct ad7150_chip_info *chip = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = i2c_smbus_read_word_data(chip->client,\r\nad7150_addresses[chan->channel][0]);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = swab16(ret);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_AVERAGE_RAW:\r\nret = i2c_smbus_read_word_data(chip->client,\r\nad7150_addresses[chan->channel][1]);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = swab16(ret);\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ad7150_read_event_config(struct iio_dev *indio_dev, u64 event_code)\r\n{\r\nint ret;\r\nu8 threshtype;\r\nbool adaptive;\r\nstruct ad7150_chip_info *chip = iio_priv(indio_dev);\r\nint rising = !!(IIO_EVENT_CODE_EXTRACT_DIR(event_code) ==\r\nIIO_EV_DIR_RISING);\r\nret = i2c_smbus_read_byte_data(chip->client, AD7150_CFG);\r\nif (ret < 0)\r\nreturn ret;\r\nthreshtype = (ret >> 5) & 0x03;\r\nadaptive = !!(ret & 0x80);\r\nswitch (IIO_EVENT_CODE_EXTRACT_TYPE(event_code)) {\r\ncase IIO_EV_TYPE_MAG_ADAPTIVE:\r\nif (rising)\r\nreturn adaptive && (threshtype == 0x1);\r\nelse\r\nreturn adaptive && (threshtype == 0x0);\r\ncase IIO_EV_TYPE_THRESH_ADAPTIVE:\r\nif (rising)\r\nreturn adaptive && (threshtype == 0x3);\r\nelse\r\nreturn adaptive && (threshtype == 0x2);\r\ncase IIO_EV_TYPE_THRESH:\r\nif (rising)\r\nreturn !adaptive && (threshtype == 0x1);\r\nelse\r\nreturn !adaptive && (threshtype == 0x0);\r\n};\r\nreturn -EINVAL;\r\n}\r\nstatic int ad7150_write_event_params(struct iio_dev *indio_dev, u64 event_code)\r\n{\r\nint ret;\r\nu16 value;\r\nu8 sens, timeout;\r\nstruct ad7150_chip_info *chip = iio_priv(indio_dev);\r\nint chan = IIO_EVENT_CODE_EXTRACT_CHAN(event_code);\r\nint rising = !!(IIO_EVENT_CODE_EXTRACT_DIR(event_code) ==\r\nIIO_EV_DIR_RISING);\r\nif (event_code != chip->current_event)\r\nreturn 0;\r\nswitch (IIO_EVENT_CODE_EXTRACT_TYPE(event_code)) {\r\ncase IIO_EV_TYPE_THRESH:\r\nvalue = chip->threshold[rising][chan];\r\nret = i2c_smbus_write_word_data(chip->client,\r\nad7150_addresses[chan][3],\r\nswab16(value));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\ncase IIO_EV_TYPE_MAG_ADAPTIVE:\r\nsens = chip->mag_sensitivity[rising][chan];\r\ntimeout = chip->mag_timeout[rising][chan];\r\nbreak;\r\ncase IIO_EV_TYPE_THRESH_ADAPTIVE:\r\nsens = chip->thresh_sensitivity[rising][chan];\r\ntimeout = chip->thresh_timeout[rising][chan];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nad7150_addresses[chan][4],\r\nsens);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nad7150_addresses[chan][5],\r\ntimeout);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ad7150_write_event_config(struct iio_dev *indio_dev,\r\nu64 event_code, int state)\r\n{\r\nu8 thresh_type, cfg, adaptive;\r\nint ret;\r\nstruct ad7150_chip_info *chip = iio_priv(indio_dev);\r\nint rising = !!(IIO_EVENT_CODE_EXTRACT_DIR(event_code) ==\r\nIIO_EV_DIR_RISING);\r\nif (state == 0)\r\nreturn -EINVAL;\r\nif (event_code == chip->current_event)\r\nreturn 0;\r\nmutex_lock(&chip->state_lock);\r\nret = i2c_smbus_read_byte_data(chip->client, AD7150_CFG);\r\nif (ret < 0)\r\ngoto error_ret;\r\ncfg = ret & ~((0x03 << 5) | (0x1 << 7));\r\nswitch (IIO_EVENT_CODE_EXTRACT_TYPE(event_code)) {\r\ncase IIO_EV_TYPE_MAG_ADAPTIVE:\r\nadaptive = 1;\r\nif (rising)\r\nthresh_type = 0x1;\r\nelse\r\nthresh_type = 0x0;\r\nbreak;\r\ncase IIO_EV_TYPE_THRESH_ADAPTIVE:\r\nadaptive = 1;\r\nif (rising)\r\nthresh_type = 0x3;\r\nelse\r\nthresh_type = 0x2;\r\nbreak;\r\ncase IIO_EV_TYPE_THRESH:\r\nadaptive = 0;\r\nif (rising)\r\nthresh_type = 0x1;\r\nelse\r\nthresh_type = 0x0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto error_ret;\r\n};\r\ncfg |= (!adaptive << 7) | (thresh_type << 5);\r\nret = i2c_smbus_write_byte_data(chip->client, AD7150_CFG, cfg);\r\nif (ret < 0)\r\ngoto error_ret;\r\nchip->current_event = event_code;\r\nret = ad7150_write_event_params(indio_dev, event_code);\r\nerror_ret:\r\nmutex_unlock(&chip->state_lock);\r\nreturn 0;\r\n}\r\nstatic int ad7150_read_event_value(struct iio_dev *indio_dev,\r\nu64 event_code,\r\nint *val)\r\n{\r\nint chan = IIO_EVENT_CODE_EXTRACT_CHAN(event_code);\r\nstruct ad7150_chip_info *chip = iio_priv(indio_dev);\r\nint rising = !!(IIO_EVENT_CODE_EXTRACT_DIR(event_code) ==\r\nIIO_EV_DIR_RISING);\r\nswitch (IIO_EVENT_CODE_EXTRACT_TYPE(event_code)) {\r\ncase IIO_EV_TYPE_MAG_ADAPTIVE:\r\n*val = chip->mag_sensitivity[rising][chan];\r\nreturn 0;\r\ncase IIO_EV_TYPE_THRESH_ADAPTIVE:\r\n*val = chip->thresh_sensitivity[rising][chan];\r\nreturn 0;\r\ncase IIO_EV_TYPE_THRESH:\r\n*val = chip->threshold[rising][chan];\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\n}\r\nstatic int ad7150_write_event_value(struct iio_dev *indio_dev,\r\nu64 event_code,\r\nint val)\r\n{\r\nint ret;\r\nstruct ad7150_chip_info *chip = iio_priv(indio_dev);\r\nint chan = IIO_EVENT_CODE_EXTRACT_CHAN(event_code);\r\nint rising = !!(IIO_EVENT_CODE_EXTRACT_DIR(event_code) ==\r\nIIO_EV_DIR_RISING);\r\nmutex_lock(&chip->state_lock);\r\nswitch (IIO_EVENT_CODE_EXTRACT_TYPE(event_code)) {\r\ncase IIO_EV_TYPE_MAG_ADAPTIVE:\r\nchip->mag_sensitivity[rising][chan] = val;\r\nbreak;\r\ncase IIO_EV_TYPE_THRESH_ADAPTIVE:\r\nchip->thresh_sensitivity[rising][chan] = val;\r\nbreak;\r\ncase IIO_EV_TYPE_THRESH:\r\nchip->threshold[rising][chan] = val;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto error_ret;\r\n};\r\nret = ad7150_write_event_params(indio_dev, event_code);\r\nerror_ret:\r\nmutex_unlock(&chip->state_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t ad7150_show_timeout(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7150_chip_info *chip = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nu8 value;\r\nint chan = IIO_EVENT_CODE_EXTRACT_CHAN(this_attr->address);\r\nint rising = !!(IIO_EVENT_CODE_EXTRACT_DIR(this_attr->address)\r\n== IIO_EV_DIR_RISING);\r\nswitch (IIO_EVENT_CODE_EXTRACT_TYPE(this_attr->address)) {\r\ncase IIO_EV_TYPE_MAG_ADAPTIVE:\r\nvalue = chip->mag_timeout[rising][chan];\r\nbreak;\r\ncase IIO_EV_TYPE_THRESH_ADAPTIVE:\r\nvalue = chip->thresh_timeout[rising][chan];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic ssize_t ad7150_store_timeout(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7150_chip_info *chip = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint chan = IIO_EVENT_CODE_EXTRACT_CHAN(this_attr->address);\r\nint rising = !!(IIO_EVENT_CODE_EXTRACT_DIR(this_attr->address) ==\r\nIIO_EV_DIR_RISING);\r\nu8 data;\r\nint ret;\r\nret = kstrtou8(buf, 10, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&chip->state_lock);\r\nswitch (IIO_EVENT_CODE_EXTRACT_TYPE(this_attr->address)) {\r\ncase IIO_EV_TYPE_MAG_ADAPTIVE:\r\nchip->mag_timeout[rising][chan] = data;\r\nbreak;\r\ncase IIO_EV_TYPE_THRESH_ADAPTIVE:\r\nchip->thresh_timeout[rising][chan] = data;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto error_ret;\r\n};\r\nret = ad7150_write_event_params(indio_dev, this_attr->address);\r\nerror_ret:\r\nmutex_unlock(&chip->state_lock);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic irqreturn_t ad7150_event_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct ad7150_chip_info *chip = iio_priv(indio_dev);\r\nu8 int_status;\r\ns64 timestamp = iio_get_time_ns();\r\nint ret;\r\nret = i2c_smbus_read_byte_data(chip->client, AD7150_STATUS);\r\nif (ret < 0)\r\nreturn IRQ_HANDLED;\r\nint_status = ret;\r\nif ((int_status & AD7150_STATUS_OUT1) &&\r\n!(chip->old_state & AD7150_STATUS_OUT1))\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_CAPACITANCE,\r\n0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\ntimestamp);\r\nelse if ((!(int_status & AD7150_STATUS_OUT1)) &&\r\n(chip->old_state & AD7150_STATUS_OUT1))\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_CAPACITANCE,\r\n0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\ntimestamp);\r\nif ((int_status & AD7150_STATUS_OUT2) &&\r\n!(chip->old_state & AD7150_STATUS_OUT2))\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_CAPACITANCE,\r\n1,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\ntimestamp);\r\nelse if ((!(int_status & AD7150_STATUS_OUT2)) &&\r\n(chip->old_state & AD7150_STATUS_OUT2))\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_CAPACITANCE,\r\n1,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\ntimestamp);\r\nchip->old_state = int_status;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit ad7150_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct ad7150_chip_info *chip;\r\nstruct iio_dev *indio_dev;\r\nindio_dev = iio_device_alloc(sizeof(*chip));\r\nif (indio_dev == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nchip = iio_priv(indio_dev);\r\nmutex_init(&chip->state_lock);\r\ni2c_set_clientdata(client, indio_dev);\r\nchip->client = client;\r\nindio_dev->name = id->name;\r\nindio_dev->channels = ad7150_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ad7150_channels);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->info = &ad7150_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nif (client->irq) {\r\nret = request_threaded_irq(client->irq,\r\nNULL,\r\n&ad7150_event_handler,\r\nIRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\n"ad7150_irq1",\r\nindio_dev);\r\nif (ret)\r\ngoto error_free_dev;\r\n}\r\nif (client->dev.platform_data) {\r\nret = request_threaded_irq(*(unsigned int *)\r\nclient->dev.platform_data,\r\nNULL,\r\n&ad7150_event_handler,\r\nIRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\n"ad7150_irq2",\r\nindio_dev);\r\nif (ret)\r\ngoto error_free_irq;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_free_irq2;\r\ndev_info(&client->dev, "%s capacitive sensor registered,irq: %d\n",\r\nid->name, client->irq);\r\nreturn 0;\r\nerror_free_irq2:\r\nif (client->dev.platform_data)\r\nfree_irq(*(unsigned int *)client->dev.platform_data,\r\nindio_dev);\r\nerror_free_irq:\r\nif (client->irq)\r\nfree_irq(client->irq, indio_dev);\r\nerror_free_dev:\r\niio_device_free(indio_dev);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int __devexit ad7150_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\niio_device_unregister(indio_dev);\r\nif (client->irq)\r\nfree_irq(client->irq, indio_dev);\r\nif (client->dev.platform_data)\r\nfree_irq(*(unsigned int *)client->dev.platform_data, indio_dev);\r\niio_device_free(indio_dev);\r\nreturn 0;\r\n}
