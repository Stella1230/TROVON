struct cflayer *cffrml_create(u16 phyid, bool use_fcs)\r\n{\r\nstruct cffrml *this = kzalloc(sizeof(struct cffrml), GFP_ATOMIC);\r\nif (!this)\r\nreturn NULL;\r\nthis->pcpu_refcnt = alloc_percpu(int);\r\nif (this->pcpu_refcnt == NULL) {\r\nkfree(this);\r\nreturn NULL;\r\n}\r\ncaif_assert(offsetof(struct cffrml, layer) == 0);\r\nthis->layer.receive = cffrml_receive;\r\nthis->layer.transmit = cffrml_transmit;\r\nthis->layer.ctrlcmd = cffrml_ctrlcmd;\r\nsnprintf(this->layer.name, CAIF_LAYER_NAME_SZ, "frm%d", phyid);\r\nthis->dofcs = use_fcs;\r\nthis->layer.id = phyid;\r\nreturn (struct cflayer *) this;\r\n}\r\nvoid cffrml_free(struct cflayer *layer)\r\n{\r\nstruct cffrml *this = container_obj(layer);\r\nfree_percpu(this->pcpu_refcnt);\r\nkfree(layer);\r\n}\r\nvoid cffrml_set_uplayer(struct cflayer *this, struct cflayer *up)\r\n{\r\nthis->up = up;\r\n}\r\nvoid cffrml_set_dnlayer(struct cflayer *this, struct cflayer *dn)\r\n{\r\nthis->dn = dn;\r\n}\r\nstatic u16 cffrml_checksum(u16 chks, void *buf, u16 len)\r\n{\r\nreturn crc_ccitt(chks, buf, len);\r\n}\r\nstatic int cffrml_receive(struct cflayer *layr, struct cfpkt *pkt)\r\n{\r\nu16 tmp;\r\nu16 len;\r\nu16 hdrchks;\r\nu16 pktchks;\r\nstruct cffrml *this;\r\nthis = container_obj(layr);\r\ncfpkt_extr_head(pkt, &tmp, 2);\r\nlen = le16_to_cpu(tmp);\r\nif (!this->dofcs)\r\nlen -= 2;\r\nif (cfpkt_setlen(pkt, len) < 0) {\r\n++cffrml_rcv_error;\r\npr_err("Framing length error (%d)\n", len);\r\ncfpkt_destroy(pkt);\r\nreturn -EPROTO;\r\n}\r\nif (this->dofcs) {\r\ncfpkt_extr_trail(pkt, &tmp, 2);\r\nhdrchks = le16_to_cpu(tmp);\r\npktchks = cfpkt_iterate(pkt, cffrml_checksum, 0xffff);\r\nif (pktchks != hdrchks) {\r\ncfpkt_add_trail(pkt, &tmp, 2);\r\n++cffrml_rcv_error;\r\n++cffrml_rcv_checsum_error;\r\npr_info("Frame checksum error (0x%x != 0x%x)\n",\r\nhdrchks, pktchks);\r\nreturn -EILSEQ;\r\n}\r\n}\r\nif (cfpkt_erroneous(pkt)) {\r\n++cffrml_rcv_error;\r\npr_err("Packet is erroneous!\n");\r\ncfpkt_destroy(pkt);\r\nreturn -EPROTO;\r\n}\r\nif (layr->up == NULL) {\r\npr_err("Layr up is missing!\n");\r\ncfpkt_destroy(pkt);\r\nreturn -EINVAL;\r\n}\r\nreturn layr->up->receive(layr->up, pkt);\r\n}\r\nstatic int cffrml_transmit(struct cflayer *layr, struct cfpkt *pkt)\r\n{\r\nu16 chks;\r\nu16 len;\r\n__le16 data;\r\nstruct cffrml *this = container_obj(layr);\r\nif (this->dofcs) {\r\nchks = cfpkt_iterate(pkt, cffrml_checksum, 0xffff);\r\ndata = cpu_to_le16(chks);\r\ncfpkt_add_trail(pkt, &data, 2);\r\n} else {\r\ncfpkt_pad_trail(pkt, 2);\r\n}\r\nlen = cfpkt_getlen(pkt);\r\ndata = cpu_to_le16(len);\r\ncfpkt_add_head(pkt, &data, 2);\r\ncfpkt_info(pkt)->hdr_len += 2;\r\nif (cfpkt_erroneous(pkt)) {\r\npr_err("Packet is erroneous!\n");\r\ncfpkt_destroy(pkt);\r\nreturn -EPROTO;\r\n}\r\nif (layr->dn == NULL) {\r\ncfpkt_destroy(pkt);\r\nreturn -ENODEV;\r\n}\r\nreturn layr->dn->transmit(layr->dn, pkt);\r\n}\r\nstatic void cffrml_ctrlcmd(struct cflayer *layr, enum caif_ctrlcmd ctrl,\r\nint phyid)\r\n{\r\nif (layr->up && layr->up->ctrlcmd)\r\nlayr->up->ctrlcmd(layr->up, ctrl, layr->id);\r\n}\r\nvoid cffrml_put(struct cflayer *layr)\r\n{\r\nstruct cffrml *this = container_obj(layr);\r\nif (layr != NULL && this->pcpu_refcnt != NULL)\r\nthis_cpu_dec(*this->pcpu_refcnt);\r\n}\r\nvoid cffrml_hold(struct cflayer *layr)\r\n{\r\nstruct cffrml *this = container_obj(layr);\r\nif (layr != NULL && this->pcpu_refcnt != NULL)\r\nthis_cpu_inc(*this->pcpu_refcnt);\r\n}\r\nint cffrml_refcnt_read(struct cflayer *layr)\r\n{\r\nint i, refcnt = 0;\r\nstruct cffrml *this = container_obj(layr);\r\nfor_each_possible_cpu(i)\r\nrefcnt += *per_cpu_ptr(this->pcpu_refcnt, i);\r\nreturn refcnt;\r\n}
