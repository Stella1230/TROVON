static int\r\nminstrel_ewma(int old, int new, int weight)\r\n{\r\nreturn (new * (100 - weight) + old * weight) / 100;\r\n}\r\nstatic int\r\nminstrel_ht_get_group_idx(struct ieee80211_tx_rate *rate)\r\n{\r\nreturn GROUP_IDX((rate->idx / MCS_GROUP_RATES) + 1,\r\n!!(rate->flags & IEEE80211_TX_RC_SHORT_GI),\r\n!!(rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH));\r\n}\r\nstatic inline struct minstrel_rate_stats *\r\nminstrel_get_ratestats(struct minstrel_ht_sta *mi, int index)\r\n{\r\nreturn &mi->groups[index / MCS_GROUP_RATES].rates[index % MCS_GROUP_RATES];\r\n}\r\nstatic void\r\nminstrel_calc_rate_ewma(struct minstrel_rate_stats *mr)\r\n{\r\nif (unlikely(mr->attempts > 0)) {\r\nmr->sample_skipped = 0;\r\nmr->cur_prob = MINSTREL_FRAC(mr->success, mr->attempts);\r\nif (!mr->att_hist)\r\nmr->probability = mr->cur_prob;\r\nelse\r\nmr->probability = minstrel_ewma(mr->probability,\r\nmr->cur_prob, EWMA_LEVEL);\r\nmr->att_hist += mr->attempts;\r\nmr->succ_hist += mr->success;\r\n} else {\r\nmr->sample_skipped++;\r\n}\r\nmr->last_success = mr->success;\r\nmr->last_attempts = mr->attempts;\r\nmr->success = 0;\r\nmr->attempts = 0;\r\n}\r\nstatic void\r\nminstrel_ht_calc_tp(struct minstrel_ht_sta *mi, int group, int rate)\r\n{\r\nstruct minstrel_rate_stats *mr;\r\nunsigned int usecs;\r\nmr = &mi->groups[group].rates[rate];\r\nif (mr->probability < MINSTREL_FRAC(1, 10)) {\r\nmr->cur_tp = 0;\r\nreturn;\r\n}\r\nusecs = mi->overhead / MINSTREL_TRUNC(mi->avg_ampdu_len);\r\nusecs += minstrel_mcs_groups[group].duration[rate];\r\nmr->cur_tp = MINSTREL_TRUNC((1000000 / usecs) * mr->probability);\r\n}\r\nstatic void\r\nminstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)\r\n{\r\nstruct minstrel_mcs_group_data *mg;\r\nstruct minstrel_rate_stats *mr;\r\nint cur_prob, cur_prob_tp, cur_tp, cur_tp2;\r\nint group, i, index;\r\nif (mi->ampdu_packets > 0) {\r\nmi->avg_ampdu_len = minstrel_ewma(mi->avg_ampdu_len,\r\nMINSTREL_FRAC(mi->ampdu_len, mi->ampdu_packets), EWMA_LEVEL);\r\nmi->ampdu_len = 0;\r\nmi->ampdu_packets = 0;\r\n}\r\nmi->sample_slow = 0;\r\nmi->sample_count = 0;\r\nmi->max_tp_rate = 0;\r\nmi->max_tp_rate2 = 0;\r\nmi->max_prob_rate = 0;\r\nfor (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {\r\ncur_prob = 0;\r\ncur_prob_tp = 0;\r\ncur_tp = 0;\r\ncur_tp2 = 0;\r\nmg = &mi->groups[group];\r\nif (!mg->supported)\r\ncontinue;\r\nmg->max_tp_rate = 0;\r\nmg->max_tp_rate2 = 0;\r\nmg->max_prob_rate = 0;\r\nmi->sample_count++;\r\nfor (i = 0; i < MCS_GROUP_RATES; i++) {\r\nif (!(mg->supported & BIT(i)))\r\ncontinue;\r\nmr = &mg->rates[i];\r\nmr->retry_updated = false;\r\nindex = MCS_GROUP_RATES * group + i;\r\nminstrel_calc_rate_ewma(mr);\r\nminstrel_ht_calc_tp(mi, group, i);\r\nif (!mr->cur_tp)\r\ncontinue;\r\nif (!i && minstrel_mcs_groups[group].streams == 1)\r\ncontinue;\r\nif ((mr->cur_tp > cur_prob_tp && mr->probability >\r\nMINSTREL_FRAC(3, 4)) || mr->probability > cur_prob) {\r\nmg->max_prob_rate = index;\r\ncur_prob = mr->probability;\r\ncur_prob_tp = mr->cur_tp;\r\n}\r\nif (mr->cur_tp > cur_tp) {\r\nswap(index, mg->max_tp_rate);\r\ncur_tp = mr->cur_tp;\r\nmr = minstrel_get_ratestats(mi, index);\r\n}\r\nif (index >= mg->max_tp_rate)\r\ncontinue;\r\nif (mr->cur_tp > cur_tp2) {\r\nmg->max_tp_rate2 = index;\r\ncur_tp2 = mr->cur_tp;\r\n}\r\n}\r\n}\r\nmi->sample_count *= 4;\r\ncur_prob = 0;\r\ncur_prob_tp = 0;\r\ncur_tp = 0;\r\ncur_tp2 = 0;\r\nfor (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {\r\nmg = &mi->groups[group];\r\nif (!mg->supported)\r\ncontinue;\r\nmr = minstrel_get_ratestats(mi, mg->max_prob_rate);\r\nif (cur_prob_tp < mr->cur_tp &&\r\nminstrel_mcs_groups[group].streams == 1) {\r\nmi->max_prob_rate = mg->max_prob_rate;\r\ncur_prob = mr->cur_prob;\r\ncur_prob_tp = mr->cur_tp;\r\n}\r\nmr = minstrel_get_ratestats(mi, mg->max_tp_rate);\r\nif (cur_tp < mr->cur_tp) {\r\nmi->max_tp_rate2 = mi->max_tp_rate;\r\ncur_tp2 = cur_tp;\r\nmi->max_tp_rate = mg->max_tp_rate;\r\ncur_tp = mr->cur_tp;\r\n}\r\nmr = minstrel_get_ratestats(mi, mg->max_tp_rate2);\r\nif (cur_tp2 < mr->cur_tp) {\r\nmi->max_tp_rate2 = mg->max_tp_rate2;\r\ncur_tp2 = mr->cur_tp;\r\n}\r\n}\r\nmi->stats_update = jiffies;\r\n}\r\nstatic bool\r\nminstrel_ht_txstat_valid(struct ieee80211_tx_rate *rate)\r\n{\r\nif (rate->idx < 0)\r\nreturn false;\r\nif (!rate->count)\r\nreturn false;\r\nreturn !!(rate->flags & IEEE80211_TX_RC_MCS);\r\n}\r\nstatic void\r\nminstrel_next_sample_idx(struct minstrel_ht_sta *mi)\r\n{\r\nstruct minstrel_mcs_group_data *mg;\r\nfor (;;) {\r\nmi->sample_group++;\r\nmi->sample_group %= ARRAY_SIZE(minstrel_mcs_groups);\r\nmg = &mi->groups[mi->sample_group];\r\nif (!mg->supported)\r\ncontinue;\r\nif (++mg->index >= MCS_GROUP_RATES) {\r\nmg->index = 0;\r\nif (++mg->column >= ARRAY_SIZE(sample_table))\r\nmg->column = 0;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nminstrel_downgrade_rate(struct minstrel_ht_sta *mi, unsigned int *idx,\r\nbool primary)\r\n{\r\nint group, orig_group;\r\norig_group = group = *idx / MCS_GROUP_RATES;\r\nwhile (group > 0) {\r\ngroup--;\r\nif (!mi->groups[group].supported)\r\ncontinue;\r\nif (minstrel_mcs_groups[group].streams >\r\nminstrel_mcs_groups[orig_group].streams)\r\ncontinue;\r\nif (primary)\r\n*idx = mi->groups[group].max_tp_rate;\r\nelse\r\n*idx = mi->groups[group].max_tp_rate2;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nminstrel_aggr_check(struct ieee80211_sta *pubsta, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\nu16 tid;\r\nif (unlikely(!ieee80211_is_data_qos(hdr->frame_control)))\r\nreturn;\r\nif (unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE)))\r\nreturn;\r\ntid = *ieee80211_get_qos_ctl(hdr) & IEEE80211_QOS_CTL_TID_MASK;\r\nif (likely(sta->ampdu_mlme.tid_tx[tid]))\r\nreturn;\r\nif (skb_get_queue_mapping(skb) == IEEE80211_AC_VO)\r\nreturn;\r\nieee80211_start_tx_ba_session(pubsta, tid, 5000);\r\n}\r\nstatic void\r\nminstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *priv_sta,\r\nstruct sk_buff *skb)\r\n{\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nstruct minstrel_ht_sta *mi = &msp->ht;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_tx_rate *ar = info->status.rates;\r\nstruct minstrel_rate_stats *rate, *rate2;\r\nstruct minstrel_priv *mp = priv;\r\nbool last = false;\r\nint group;\r\nint i = 0;\r\nif (!msp->is_ht)\r\nreturn mac80211_minstrel.tx_status(priv, sband, sta, &msp->legacy, skb);\r\nif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\r\n!(info->flags & IEEE80211_TX_STAT_AMPDU))\r\nreturn;\r\nif (!(info->flags & IEEE80211_TX_STAT_AMPDU)) {\r\ninfo->status.ampdu_ack_len =\r\n(info->flags & IEEE80211_TX_STAT_ACK ? 1 : 0);\r\ninfo->status.ampdu_len = 1;\r\n}\r\nmi->ampdu_packets++;\r\nmi->ampdu_len += info->status.ampdu_len;\r\nif (!mi->sample_wait && !mi->sample_tries && mi->sample_count > 0) {\r\nmi->sample_wait = 16 + 2 * MINSTREL_TRUNC(mi->avg_ampdu_len);\r\nmi->sample_tries = 2;\r\nmi->sample_count--;\r\n}\r\nif (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)\r\nmi->sample_packets += info->status.ampdu_len;\r\nfor (i = 0; !last; i++) {\r\nlast = (i == IEEE80211_TX_MAX_RATES - 1) ||\r\n!minstrel_ht_txstat_valid(&ar[i + 1]);\r\nif (!minstrel_ht_txstat_valid(&ar[i]))\r\nbreak;\r\ngroup = minstrel_ht_get_group_idx(&ar[i]);\r\nrate = &mi->groups[group].rates[ar[i].idx % 8];\r\nif (last)\r\nrate->success += info->status.ampdu_ack_len;\r\nrate->attempts += ar[i].count * info->status.ampdu_len;\r\n}\r\nrate = minstrel_get_ratestats(mi, mi->max_tp_rate);\r\nif (rate->attempts > 30 &&\r\nMINSTREL_FRAC(rate->success, rate->attempts) <\r\nMINSTREL_FRAC(20, 100))\r\nminstrel_downgrade_rate(mi, &mi->max_tp_rate, true);\r\nrate2 = minstrel_get_ratestats(mi, mi->max_tp_rate2);\r\nif (rate2->attempts > 30 &&\r\nMINSTREL_FRAC(rate2->success, rate2->attempts) <\r\nMINSTREL_FRAC(20, 100))\r\nminstrel_downgrade_rate(mi, &mi->max_tp_rate2, false);\r\nif (time_after(jiffies, mi->stats_update + (mp->update_interval / 2 * HZ) / 1000)) {\r\nminstrel_ht_update_stats(mp, mi);\r\nif (!(info->flags & IEEE80211_TX_CTL_AMPDU))\r\nminstrel_aggr_check(sta, skb);\r\n}\r\n}\r\nstatic void\r\nminstrel_calc_retransmit(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\r\nint index)\r\n{\r\nstruct minstrel_rate_stats *mr;\r\nconst struct mcs_group *group;\r\nunsigned int tx_time, tx_time_rtscts, tx_time_data;\r\nunsigned int cw = mp->cw_min;\r\nunsigned int ctime = 0;\r\nunsigned int t_slot = 9;\r\nunsigned int ampdu_len = MINSTREL_TRUNC(mi->avg_ampdu_len);\r\nmr = minstrel_get_ratestats(mi, index);\r\nif (mr->probability < MINSTREL_FRAC(1, 10)) {\r\nmr->retry_count = 1;\r\nmr->retry_count_rtscts = 1;\r\nreturn;\r\n}\r\nmr->retry_count = 2;\r\nmr->retry_count_rtscts = 2;\r\nmr->retry_updated = true;\r\ngroup = &minstrel_mcs_groups[index / MCS_GROUP_RATES];\r\ntx_time_data = group->duration[index % MCS_GROUP_RATES] * ampdu_len;\r\nctime = (t_slot * cw) >> 1;\r\ncw = min((cw << 1) | 1, mp->cw_max);\r\nctime += (t_slot * cw) >> 1;\r\ncw = min((cw << 1) | 1, mp->cw_max);\r\ntx_time = ctime + 2 * (mi->overhead + tx_time_data);\r\ntx_time_rtscts = ctime + 2 * (mi->overhead_rtscts + tx_time_data);\r\ndo {\r\nctime = (t_slot * cw) >> 1;\r\ncw = min((cw << 1) | 1, mp->cw_max);\r\ntx_time += ctime + mi->overhead + tx_time_data;\r\ntx_time_rtscts += ctime + mi->overhead_rtscts + tx_time_data;\r\nif (tx_time_rtscts < mp->segment_size)\r\nmr->retry_count_rtscts++;\r\n} while ((tx_time < mp->segment_size) &&\r\n(++mr->retry_count < mp->max_retry));\r\n}\r\nstatic void\r\nminstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\r\nstruct ieee80211_tx_rate *rate, int index,\r\nbool sample, bool rtscts)\r\n{\r\nconst struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];\r\nstruct minstrel_rate_stats *mr;\r\nmr = minstrel_get_ratestats(mi, index);\r\nif (!mr->retry_updated)\r\nminstrel_calc_retransmit(mp, mi, index);\r\nif (sample)\r\nrate->count = 1;\r\nelse if (mr->probability < MINSTREL_FRAC(20, 100))\r\nrate->count = 2;\r\nelse if (rtscts)\r\nrate->count = mr->retry_count_rtscts;\r\nelse\r\nrate->count = mr->retry_count;\r\nrate->flags = IEEE80211_TX_RC_MCS | group->flags;\r\nif (rtscts)\r\nrate->flags |= IEEE80211_TX_RC_USE_RTS_CTS;\r\nrate->idx = index % MCS_GROUP_RATES + (group->streams - 1) * MCS_GROUP_RATES;\r\n}\r\nstatic inline int\r\nminstrel_get_duration(int index)\r\n{\r\nconst struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];\r\nreturn group->duration[index % MCS_GROUP_RATES];\r\n}\r\nstatic int\r\nminstrel_get_sample_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)\r\n{\r\nstruct minstrel_rate_stats *mr;\r\nstruct minstrel_mcs_group_data *mg;\r\nint sample_idx = 0;\r\nif (mi->sample_wait > 0) {\r\nmi->sample_wait--;\r\nreturn -1;\r\n}\r\nif (!mi->sample_tries)\r\nreturn -1;\r\nmi->sample_tries--;\r\nmg = &mi->groups[mi->sample_group];\r\nsample_idx = sample_table[mg->column][mg->index];\r\nmr = &mg->rates[sample_idx];\r\nsample_idx += mi->sample_group * MCS_GROUP_RATES;\r\nminstrel_next_sample_idx(mi);\r\nif (sample_idx == mi->max_tp_rate)\r\nreturn -1;\r\nif (!mp->has_mrr && (mr->probability > MINSTREL_FRAC(95, 100)))\r\nreturn -1;\r\nif (minstrel_get_duration(sample_idx) >\r\nminstrel_get_duration(mi->max_tp_rate)) {\r\nif (mr->sample_skipped < 20)\r\nreturn -1;\r\nif (mi->sample_slow++ > 2)\r\nreturn -1;\r\n}\r\nreturn sample_idx;\r\n}\r\nstatic void\r\nminstrel_ht_get_rate(void *priv, struct ieee80211_sta *sta, void *priv_sta,\r\nstruct ieee80211_tx_rate_control *txrc)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(txrc->skb);\r\nstruct ieee80211_tx_rate *ar = info->status.rates;\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nstruct minstrel_ht_sta *mi = &msp->ht;\r\nstruct minstrel_priv *mp = priv;\r\nint sample_idx;\r\nbool sample = false;\r\nif (rate_control_send_low(sta, priv_sta, txrc))\r\nreturn;\r\nif (!msp->is_ht)\r\nreturn mac80211_minstrel.get_rate(priv, sta, &msp->legacy, txrc);\r\ninfo->flags |= mi->tx_flags;\r\nif (mp->hw->max_rates == 1 &&\r\ntxrc->skb->protocol == cpu_to_be16(ETH_P_PAE))\r\nsample_idx = -1;\r\nelse\r\nsample_idx = minstrel_get_sample_rate(mp, mi);\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nif (mp->fixed_rate_idx != -1) {\r\nmi->max_tp_rate = mp->fixed_rate_idx;\r\nmi->max_tp_rate2 = mp->fixed_rate_idx;\r\nmi->max_prob_rate = mp->fixed_rate_idx;\r\nsample_idx = -1;\r\n}\r\n#endif\r\nif (sample_idx >= 0) {\r\nsample = true;\r\nminstrel_ht_set_rate(mp, mi, &ar[0], sample_idx,\r\ntrue, false);\r\ninfo->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;\r\n} else {\r\nminstrel_ht_set_rate(mp, mi, &ar[0], mi->max_tp_rate,\r\nfalse, false);\r\n}\r\nif (mp->hw->max_rates >= 3) {\r\nif (sample_idx >= 0)\r\nminstrel_ht_set_rate(mp, mi, &ar[1], mi->max_tp_rate,\r\nfalse, false);\r\nelse\r\nminstrel_ht_set_rate(mp, mi, &ar[1], mi->max_tp_rate2,\r\nfalse, true);\r\nminstrel_ht_set_rate(mp, mi, &ar[2], mi->max_prob_rate,\r\nfalse, !sample);\r\nar[3].count = 0;\r\nar[3].idx = -1;\r\n} else if (mp->hw->max_rates == 2) {\r\nminstrel_ht_set_rate(mp, mi, &ar[1], mi->max_prob_rate,\r\nfalse, !sample);\r\nar[2].count = 0;\r\nar[2].idx = -1;\r\n} else {\r\nar[1].count = 0;\r\nar[1].idx = -1;\r\n}\r\nmi->total_packets++;\r\nif (mi->total_packets == ~0) {\r\nmi->total_packets = 0;\r\nmi->sample_packets = 0;\r\n}\r\n}\r\nstatic void\r\nminstrel_ht_update_caps(void *priv, struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nstruct minstrel_priv *mp = priv;\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nstruct minstrel_ht_sta *mi = &msp->ht;\r\nstruct ieee80211_mcs_info *mcs = &sta->ht_cap.mcs;\r\nu16 sta_cap = sta->ht_cap.cap;\r\nint n_supported = 0;\r\nint ack_dur;\r\nint stbc;\r\nint i;\r\nunsigned int smps;\r\nif (!sta->ht_cap.ht_supported)\r\ngoto use_legacy;\r\nBUILD_BUG_ON(ARRAY_SIZE(minstrel_mcs_groups) !=\r\nMINSTREL_MAX_STREAMS * MINSTREL_STREAM_GROUPS);\r\nmsp->is_ht = true;\r\nmemset(mi, 0, sizeof(*mi));\r\nmi->stats_update = jiffies;\r\nack_dur = ieee80211_frame_duration(sband->band, 10, 60, 1, 1);\r\nmi->overhead = ieee80211_frame_duration(sband->band, 0, 60, 1, 1) + ack_dur;\r\nmi->overhead_rtscts = mi->overhead + 2 * ack_dur;\r\nmi->avg_ampdu_len = MINSTREL_FRAC(1, 1);\r\nif (mp->has_mrr) {\r\nmi->sample_count = 16;\r\nmi->sample_wait = 0;\r\n} else {\r\nmi->sample_count = 8;\r\nmi->sample_wait = 8;\r\n}\r\nmi->sample_tries = 4;\r\nstbc = (sta_cap & IEEE80211_HT_CAP_RX_STBC) >>\r\nIEEE80211_HT_CAP_RX_STBC_SHIFT;\r\nmi->tx_flags |= stbc << IEEE80211_TX_CTL_STBC_SHIFT;\r\nif (sta_cap & IEEE80211_HT_CAP_LDPC_CODING)\r\nmi->tx_flags |= IEEE80211_TX_CTL_LDPC;\r\nsmps = (sta_cap & IEEE80211_HT_CAP_SM_PS) >>\r\nIEEE80211_HT_CAP_SM_PS_SHIFT;\r\nfor (i = 0; i < ARRAY_SIZE(mi->groups); i++) {\r\nu16 req = 0;\r\nmi->groups[i].supported = 0;\r\nif (minstrel_mcs_groups[i].flags & IEEE80211_TX_RC_SHORT_GI) {\r\nif (minstrel_mcs_groups[i].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\r\nreq |= IEEE80211_HT_CAP_SGI_40;\r\nelse\r\nreq |= IEEE80211_HT_CAP_SGI_20;\r\n}\r\nif (minstrel_mcs_groups[i].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\r\nreq |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\r\nif ((sta_cap & req) != req)\r\ncontinue;\r\nif (smps == WLAN_HT_CAP_SM_PS_STATIC &&\r\nminstrel_mcs_groups[i].streams > 1)\r\ncontinue;\r\nmi->groups[i].supported =\r\nmcs->rx_mask[minstrel_mcs_groups[i].streams - 1];\r\nif (mi->groups[i].supported)\r\nn_supported++;\r\n}\r\nif (!n_supported)\r\ngoto use_legacy;\r\nreturn;\r\nuse_legacy:\r\nmsp->is_ht = false;\r\nmemset(&msp->legacy, 0, sizeof(msp->legacy));\r\nmsp->legacy.r = msp->ratelist;\r\nmsp->legacy.sample_table = msp->sample_table;\r\nreturn mac80211_minstrel.rate_init(priv, sband, sta, &msp->legacy);\r\n}\r\nstatic void\r\nminstrel_ht_rate_init(void *priv, struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nminstrel_ht_update_caps(priv, sband, sta, priv_sta);\r\n}\r\nstatic void\r\nminstrel_ht_rate_update(void *priv, struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *priv_sta,\r\nu32 changed)\r\n{\r\nminstrel_ht_update_caps(priv, sband, sta, priv_sta);\r\n}\r\nstatic void *\r\nminstrel_ht_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nstruct minstrel_ht_sta_priv *msp;\r\nstruct minstrel_priv *mp = priv;\r\nstruct ieee80211_hw *hw = mp->hw;\r\nint max_rates = 0;\r\nint i;\r\nfor (i = 0; i < IEEE80211_NUM_BANDS; i++) {\r\nsband = hw->wiphy->bands[i];\r\nif (sband && sband->n_bitrates > max_rates)\r\nmax_rates = sband->n_bitrates;\r\n}\r\nmsp = kzalloc(sizeof(*msp), gfp);\r\nif (!msp)\r\nreturn NULL;\r\nmsp->ratelist = kzalloc(sizeof(struct minstrel_rate) * max_rates, gfp);\r\nif (!msp->ratelist)\r\ngoto error;\r\nmsp->sample_table = kmalloc(SAMPLE_COLUMNS * max_rates, gfp);\r\nif (!msp->sample_table)\r\ngoto error1;\r\nreturn msp;\r\nerror1:\r\nkfree(msp->ratelist);\r\nerror:\r\nkfree(msp);\r\nreturn NULL;\r\n}\r\nstatic void\r\nminstrel_ht_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nkfree(msp->sample_table);\r\nkfree(msp->ratelist);\r\nkfree(msp);\r\n}\r\nstatic void *\r\nminstrel_ht_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)\r\n{\r\nreturn mac80211_minstrel.alloc(hw, debugfsdir);\r\n}\r\nstatic void\r\nminstrel_ht_free(void *priv)\r\n{\r\nmac80211_minstrel.free(priv);\r\n}\r\nstatic void\r\ninit_sample_table(void)\r\n{\r\nint col, i, new_idx;\r\nu8 rnd[MCS_GROUP_RATES];\r\nmemset(sample_table, 0xff, sizeof(sample_table));\r\nfor (col = 0; col < SAMPLE_COLUMNS; col++) {\r\nfor (i = 0; i < MCS_GROUP_RATES; i++) {\r\nget_random_bytes(rnd, sizeof(rnd));\r\nnew_idx = (i + rnd[i]) % MCS_GROUP_RATES;\r\nwhile (sample_table[col][new_idx] != 0xff)\r\nnew_idx = (new_idx + 1) % MCS_GROUP_RATES;\r\nsample_table[col][new_idx] = i;\r\n}\r\n}\r\n}\r\nint __init\r\nrc80211_minstrel_ht_init(void)\r\n{\r\ninit_sample_table();\r\nreturn ieee80211_rate_control_register(&mac80211_minstrel_ht);\r\n}\r\nvoid\r\nrc80211_minstrel_ht_exit(void)\r\n{\r\nieee80211_rate_control_unregister(&mac80211_minstrel_ht);\r\n}
