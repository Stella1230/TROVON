static inline size_t w1_f23_fix_count(loff_t off, size_t count, size_t size)\r\n{\r\nif (off > size)\r\nreturn 0;\r\nif ((off + count) > size)\r\nreturn (size - off);\r\nreturn count;\r\n}\r\nstatic int w1_f23_refresh_block(struct w1_slave *sl, struct w1_f23_data *data,\r\nint block)\r\n{\r\nu8 wrbuf[3];\r\nint off = block * W1_PAGE_SIZE;\r\nif (data->validcrc & (1 << block))\r\nreturn 0;\r\nif (w1_reset_select_slave(sl)) {\r\ndata->validcrc = 0;\r\nreturn -EIO;\r\n}\r\nwrbuf[0] = W1_F23_READ_EEPROM;\r\nwrbuf[1] = off & 0xff;\r\nwrbuf[2] = off >> 8;\r\nw1_write_block(sl->master, wrbuf, 3);\r\nw1_read_block(sl->master, &data->memory[off], W1_PAGE_SIZE);\r\nif (crc16(CRC16_INIT, &data->memory[off], W1_PAGE_SIZE) == CRC16_VALID)\r\ndata->validcrc |= (1 << block);\r\nreturn 0;\r\n}\r\nstatic ssize_t w1_f23_read_bin(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct w1_slave *sl = kobj_to_w1_slave(kobj);\r\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\r\nstruct w1_f23_data *data = sl->family_data;\r\nint i, min_page, max_page;\r\n#else\r\nu8 wrbuf[3];\r\n#endif\r\nif ((count = w1_f23_fix_count(off, count, W1_EEPROM_SIZE)) == 0)\r\nreturn 0;\r\nmutex_lock(&sl->master->bus_mutex);\r\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\r\nmin_page = (off >> W1_PAGE_BITS);\r\nmax_page = (off + count - 1) >> W1_PAGE_BITS;\r\nfor (i = min_page; i <= max_page; i++) {\r\nif (w1_f23_refresh_block(sl, data, i)) {\r\ncount = -EIO;\r\ngoto out_up;\r\n}\r\n}\r\nmemcpy(buf, &data->memory[off], count);\r\n#else\r\nif (w1_reset_select_slave(sl)) {\r\ncount = -EIO;\r\ngoto out_up;\r\n}\r\nwrbuf[0] = W1_F23_READ_EEPROM;\r\nwrbuf[1] = off & 0xff;\r\nwrbuf[2] = off >> 8;\r\nw1_write_block(sl->master, wrbuf, 3);\r\nw1_read_block(sl->master, buf, count);\r\n#endif\r\nout_up:\r\nmutex_unlock(&sl->master->bus_mutex);\r\nreturn count;\r\n}\r\nstatic int w1_f23_write(struct w1_slave *sl, int addr, int len, const u8 *data)\r\n{\r\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\r\nstruct w1_f23_data *f23 = sl->family_data;\r\n#endif\r\nu8 wrbuf[4];\r\nu8 rdbuf[W1_PAGE_SIZE + 3];\r\nu8 es = (addr + len - 1) & 0x1f;\r\nif (w1_reset_select_slave(sl))\r\nreturn -1;\r\nwrbuf[0] = W1_F23_WRITE_SCRATCH;\r\nwrbuf[1] = addr & 0xff;\r\nwrbuf[2] = addr >> 8;\r\nw1_write_block(sl->master, wrbuf, 3);\r\nw1_write_block(sl->master, data, len);\r\nif (w1_reset_select_slave(sl))\r\nreturn -1;\r\nw1_write_8(sl->master, W1_F23_READ_SCRATCH);\r\nw1_read_block(sl->master, rdbuf, len + 3);\r\nif ((rdbuf[0] != wrbuf[1]) || (rdbuf[1] != wrbuf[2]) ||\r\n(rdbuf[2] != es) || (memcmp(data, &rdbuf[3], len) != 0))\r\nreturn -1;\r\nif (w1_reset_select_slave(sl))\r\nreturn -1;\r\nwrbuf[0] = W1_F23_COPY_SCRATCH;\r\nwrbuf[3] = es;\r\nw1_write_block(sl->master, wrbuf, 4);\r\nmsleep(5);\r\nw1_reset_bus(sl->master);\r\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\r\nf23->validcrc &= ~(1 << (addr >> W1_PAGE_BITS));\r\n#endif\r\nreturn 0;\r\n}\r\nstatic ssize_t w1_f23_write_bin(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct w1_slave *sl = kobj_to_w1_slave(kobj);\r\nint addr, len, idx;\r\nif ((count = w1_f23_fix_count(off, count, W1_EEPROM_SIZE)) == 0)\r\nreturn 0;\r\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\r\nif ((off & W1_PAGE_MASK) || (count & W1_PAGE_MASK)) {\r\ndev_err(&sl->dev, "invalid offset/count off=%d cnt=%zd\n",\r\n(int)off, count);\r\nreturn -EINVAL;\r\n}\r\nfor (idx = 0; idx < count; idx += W1_PAGE_SIZE) {\r\nif (crc16(CRC16_INIT, &buf[idx], W1_PAGE_SIZE) != CRC16_VALID) {\r\ndev_err(&sl->dev, "bad CRC at offset %d\n", (int)off);\r\nreturn -EINVAL;\r\n}\r\n}\r\n#endif\r\nmutex_lock(&sl->master->bus_mutex);\r\nidx = 0;\r\nwhile (idx < count) {\r\naddr = off + idx;\r\nlen = W1_PAGE_SIZE - (addr & W1_PAGE_MASK);\r\nif (len > (count - idx))\r\nlen = count - idx;\r\nif (w1_f23_write(sl, addr, len, &buf[idx]) < 0) {\r\ncount = -EIO;\r\ngoto out_up;\r\n}\r\nidx += len;\r\n}\r\nout_up:\r\nmutex_unlock(&sl->master->bus_mutex);\r\nreturn count;\r\n}\r\nstatic int w1_f23_add_slave(struct w1_slave *sl)\r\n{\r\nint err;\r\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\r\nstruct w1_f23_data *data;\r\ndata = kzalloc(sizeof(struct w1_f23_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nsl->family_data = data;\r\n#endif\r\nerr = sysfs_create_bin_file(&sl->dev.kobj, &w1_f23_bin_attr);\r\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\r\nif (err)\r\nkfree(data);\r\n#endif\r\nreturn err;\r\n}\r\nstatic void w1_f23_remove_slave(struct w1_slave *sl)\r\n{\r\n#ifdef CONFIG_W1_SLAVE_DS2433_CRC\r\nkfree(sl->family_data);\r\nsl->family_data = NULL;\r\n#endif\r\nsysfs_remove_bin_file(&sl->dev.kobj, &w1_f23_bin_attr);\r\n}\r\nstatic int __init w1_f23_init(void)\r\n{\r\nreturn w1_register_family(&w1_family_23);\r\n}\r\nstatic void __exit w1_f23_fini(void)\r\n{\r\nw1_unregister_family(&w1_family_23);\r\n}
