static int ebt_log_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nstruct ebt_log_info *info = par->targinfo;\r\nif (info->bitmask & ~EBT_LOG_MASK)\r\nreturn -EINVAL;\r\nif (info->loglevel >= 8)\r\nreturn -EINVAL;\r\ninfo->prefix[EBT_LOG_PREFIX_SIZE - 1] = '\0';\r\nreturn 0;\r\n}\r\nstatic void\r\nprint_ports(const struct sk_buff *skb, uint8_t protocol, int offset)\r\n{\r\nif (protocol == IPPROTO_TCP ||\r\nprotocol == IPPROTO_UDP ||\r\nprotocol == IPPROTO_UDPLITE ||\r\nprotocol == IPPROTO_SCTP ||\r\nprotocol == IPPROTO_DCCP) {\r\nconst struct tcpudphdr *pptr;\r\nstruct tcpudphdr _ports;\r\npptr = skb_header_pointer(skb, offset,\r\nsizeof(_ports), &_ports);\r\nif (pptr == NULL) {\r\nprintk(" INCOMPLETE TCP/UDP header");\r\nreturn;\r\n}\r\nprintk(" SPT=%u DPT=%u", ntohs(pptr->src), ntohs(pptr->dst));\r\n}\r\n}\r\nstatic void\r\nebt_log_packet(u_int8_t pf, unsigned int hooknum,\r\nconst struct sk_buff *skb, const struct net_device *in,\r\nconst struct net_device *out, const struct nf_loginfo *loginfo,\r\nconst char *prefix)\r\n{\r\nunsigned int bitmask;\r\nspin_lock_bh(&ebt_log_lock);\r\nprintk(KERN_SOH "%c%s IN=%s OUT=%s MAC source = %pM MAC dest = %pM proto = 0x%04x",\r\n'0' + loginfo->u.log.level, prefix,\r\nin ? in->name : "", out ? out->name : "",\r\neth_hdr(skb)->h_source, eth_hdr(skb)->h_dest,\r\nntohs(eth_hdr(skb)->h_proto));\r\nif (loginfo->type == NF_LOG_TYPE_LOG)\r\nbitmask = loginfo->u.log.logflags;\r\nelse\r\nbitmask = NF_LOG_MASK;\r\nif ((bitmask & EBT_LOG_IP) && eth_hdr(skb)->h_proto ==\r\nhtons(ETH_P_IP)){\r\nconst struct iphdr *ih;\r\nstruct iphdr _iph;\r\nih = skb_header_pointer(skb, 0, sizeof(_iph), &_iph);\r\nif (ih == NULL) {\r\nprintk(" INCOMPLETE IP header");\r\ngoto out;\r\n}\r\nprintk(" IP SRC=%pI4 IP DST=%pI4, IP tos=0x%02X, IP proto=%d",\r\n&ih->saddr, &ih->daddr, ih->tos, ih->protocol);\r\nprint_ports(skb, ih->protocol, ih->ihl*4);\r\ngoto out;\r\n}\r\n#if IS_ENABLED(CONFIG_BRIDGE_EBT_IP6)\r\nif ((bitmask & EBT_LOG_IP6) && eth_hdr(skb)->h_proto ==\r\nhtons(ETH_P_IPV6)) {\r\nconst struct ipv6hdr *ih;\r\nstruct ipv6hdr _iph;\r\nuint8_t nexthdr;\r\n__be16 frag_off;\r\nint offset_ph;\r\nih = skb_header_pointer(skb, 0, sizeof(_iph), &_iph);\r\nif (ih == NULL) {\r\nprintk(" INCOMPLETE IPv6 header");\r\ngoto out;\r\n}\r\nprintk(" IPv6 SRC=%pI6 IPv6 DST=%pI6, IPv6 priority=0x%01X, Next Header=%d",\r\n&ih->saddr, &ih->daddr, ih->priority, ih->nexthdr);\r\nnexthdr = ih->nexthdr;\r\noffset_ph = ipv6_skip_exthdr(skb, sizeof(_iph), &nexthdr, &frag_off);\r\nif (offset_ph == -1)\r\ngoto out;\r\nprint_ports(skb, nexthdr, offset_ph);\r\ngoto out;\r\n}\r\n#endif\r\nif ((bitmask & EBT_LOG_ARP) &&\r\n((eth_hdr(skb)->h_proto == htons(ETH_P_ARP)) ||\r\n(eth_hdr(skb)->h_proto == htons(ETH_P_RARP)))) {\r\nconst struct arphdr *ah;\r\nstruct arphdr _arph;\r\nah = skb_header_pointer(skb, 0, sizeof(_arph), &_arph);\r\nif (ah == NULL) {\r\nprintk(" INCOMPLETE ARP header");\r\ngoto out;\r\n}\r\nprintk(" ARP HTYPE=%d, PTYPE=0x%04x, OPCODE=%d",\r\nntohs(ah->ar_hrd), ntohs(ah->ar_pro),\r\nntohs(ah->ar_op));\r\nif (ah->ar_hrd == htons(1) &&\r\nah->ar_hln == ETH_ALEN &&\r\nah->ar_pln == sizeof(__be32)) {\r\nconst struct arppayload *ap;\r\nstruct arppayload _arpp;\r\nap = skb_header_pointer(skb, sizeof(_arph),\r\nsizeof(_arpp), &_arpp);\r\nif (ap == NULL) {\r\nprintk(" INCOMPLETE ARP payload");\r\ngoto out;\r\n}\r\nprintk(" ARP MAC SRC=%pM ARP IP SRC=%pI4 ARP MAC DST=%pM ARP IP DST=%pI4",\r\nap->mac_src, ap->ip_src, ap->mac_dst, ap->ip_dst);\r\n}\r\n}\r\nout:\r\nprintk("\n");\r\nspin_unlock_bh(&ebt_log_lock);\r\n}\r\nstatic unsigned int\r\nebt_log_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct ebt_log_info *info = par->targinfo;\r\nstruct nf_loginfo li;\r\nli.type = NF_LOG_TYPE_LOG;\r\nli.u.log.level = info->loglevel;\r\nli.u.log.logflags = info->bitmask;\r\nif (info->bitmask & EBT_LOG_NFLOG)\r\nnf_log_packet(NFPROTO_BRIDGE, par->hooknum, skb, par->in,\r\npar->out, &li, "%s", info->prefix);\r\nelse\r\nebt_log_packet(NFPROTO_BRIDGE, par->hooknum, skb, par->in,\r\npar->out, &li, info->prefix);\r\nreturn EBT_CONTINUE;\r\n}\r\nstatic int __init ebt_log_init(void)\r\n{\r\nint ret;\r\nret = xt_register_target(&ebt_log_tg_reg);\r\nif (ret < 0)\r\nreturn ret;\r\nnf_log_register(NFPROTO_BRIDGE, &ebt_log_logger);\r\nreturn 0;\r\n}\r\nstatic void __exit ebt_log_fini(void)\r\n{\r\nnf_log_unregister(&ebt_log_logger);\r\nxt_unregister_target(&ebt_log_tg_reg);\r\n}
