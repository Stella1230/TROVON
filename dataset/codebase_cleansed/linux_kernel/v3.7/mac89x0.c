static inline int\r\nreadreg_io(struct net_device *dev, int portno)\r\n{\r\nnubus_writew(swab16(portno), dev->base_addr + ADD_PORT);\r\nreturn swab16(nubus_readw(dev->base_addr + DATA_PORT));\r\n}\r\nstatic inline void\r\nwritereg_io(struct net_device *dev, int portno, int value)\r\n{\r\nnubus_writew(swab16(portno), dev->base_addr + ADD_PORT);\r\nnubus_writew(swab16(value), dev->base_addr + DATA_PORT);\r\n}\r\nstatic inline int\r\nreadreg(struct net_device *dev, int portno)\r\n{\r\nreturn swab16(nubus_readw(dev->mem_start + portno));\r\n}\r\nstatic inline void\r\nwritereg(struct net_device *dev, int portno, int value)\r\n{\r\nnubus_writew(swab16(value), dev->mem_start + portno);\r\n}\r\nstruct net_device * __init mac89x0_probe(int unit)\r\n{\r\nstruct net_device *dev;\r\nstatic int once_is_enough;\r\nstruct net_local *lp;\r\nstatic unsigned version_printed;\r\nint i, slot;\r\nunsigned rev_type = 0;\r\nunsigned long ioaddr;\r\nunsigned short sig;\r\nint err = -ENODEV;\r\nif (!MACH_IS_MAC)\r\nreturn ERR_PTR(-ENODEV);\r\ndev = alloc_etherdev(sizeof(struct net_local));\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\n}\r\nif (once_is_enough)\r\ngoto out;\r\nonce_is_enough = 1;\r\nslot = 0xE;\r\nif (nubus_find_slot(slot, NULL) != NULL)\r\ngoto out;\r\nioaddr = (unsigned long)\r\nnubus_slot_addr(slot) | (((slot&0xf) << 20) + DEFAULTIOBASE);\r\n{\r\nunsigned long flags;\r\nint card_present;\r\nlocal_irq_save(flags);\r\ncard_present = (hwreg_present((void*) ioaddr+4) &&\r\nhwreg_present((void*) ioaddr + DATA_PORT));\r\nlocal_irq_restore(flags);\r\nif (!card_present)\r\ngoto out;\r\n}\r\nnubus_writew(0, ioaddr + ADD_PORT);\r\nsig = nubus_readw(ioaddr + DATA_PORT);\r\nif (sig != swab16(CHIP_EISA_ID_SIG))\r\ngoto out;\r\nlp = netdev_priv(dev);\r\ndev->base_addr = ioaddr;\r\ndev->mem_start = (unsigned long)\r\nnubus_slot_addr(slot) | (((slot&0xf) << 20) + MMIOBASE);\r\ndev->mem_end = dev->mem_start + 0x1000;\r\nwritereg_io(dev, PP_BusCTL, MEMORY_ON);\r\nrev_type = readreg(dev, PRODUCT_ID_ADD);\r\nlp->chip_type = rev_type &~ REVISON_BITS;\r\nlp->chip_revision = ((rev_type & REVISON_BITS) >> 8) + 'A';\r\nlp->send_cmd = TX_AFTER_381;\r\nif (lp->chip_type == CS8900 && lp->chip_revision >= 'F')\r\nlp->send_cmd = TX_NOW;\r\nif (lp->chip_type != CS8900 && lp->chip_revision >= 'C')\r\nlp->send_cmd = TX_NOW;\r\nif (net_debug && version_printed++ == 0)\r\nprintk(version);\r\nprintk(KERN_INFO "%s: cs89%c0%s rev %c found at %#8lx",\r\ndev->name,\r\nlp->chip_type==CS8900?'0':'2',\r\nlp->chip_type==CS8920M?"M":"",\r\nlp->chip_revision,\r\ndev->base_addr);\r\nif ((readreg(dev, PP_SelfST) & (EEPROM_PRESENT | EEPROM_OK)) == 0) {\r\nprintk("\nmac89x0: No EEPROM, giving up now.\n");\r\ngoto out1;\r\n} else {\r\nfor (i = 0; i < ETH_ALEN; i += 2) {\r\nunsigned short s = readreg(dev, PP_IA + i);\r\ndev->dev_addr[i] = s >> 8;\r\ndev->dev_addr[i+1] = s & 0xff;\r\n}\r\n}\r\ndev->irq = SLOT2IRQ(slot);\r\nprintk(" IRQ %d ADDR %pM\n", dev->irq, dev->dev_addr);\r\ndev->netdev_ops = &mac89x0_netdev_ops;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out1;\r\nreturn NULL;\r\nout1:\r\nnubus_writew(0, dev->base_addr + ADD_PORT);\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int\r\nnet_open(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint i;\r\nwritereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL) & ~ENABLE_IRQ);\r\nif (request_irq(dev->irq, net_interrupt, 0, "cs89x0", dev))\r\nreturn -EAGAIN;\r\nif (lp->chip_type == CS8900)\r\nwritereg(dev, PP_CS8900_ISAINT, 0);\r\nelse\r\nwritereg(dev, PP_CS8920_ISAINT, 0);\r\nfor (i=0; i < ETH_ALEN/2; i++)\r\nwritereg(dev, PP_IA+i*2, dev->dev_addr[i*2] | (dev->dev_addr[i*2+1] << 8));\r\nwritereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) | SERIAL_RX_ON | SERIAL_TX_ON);\r\nlp->rx_mode = 0;\r\nwritereg(dev, PP_RxCTL, DEF_RX_ACCEPT);\r\nlp->curr_rx_cfg = RX_OK_ENBL | RX_CRC_ERROR_ENBL;\r\nwritereg(dev, PP_RxCFG, lp->curr_rx_cfg);\r\nwritereg(dev, PP_TxCFG, TX_LOST_CRS_ENBL | TX_SQE_ERROR_ENBL | TX_OK_ENBL |\r\nTX_LATE_COL_ENBL | TX_JBR_ENBL | TX_ANY_COL_ENBL | TX_16_COL_ENBL);\r\nwritereg(dev, PP_BufCFG, READY_FOR_TX_ENBL | RX_MISS_COUNT_OVRFLOW_ENBL |\r\nTX_COL_COUNT_OVRFLOW_ENBL | TX_UNDERRUN_ENBL);\r\nwritereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL) | ENABLE_IRQ);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nnet_send_packet(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nif (net_debug > 3)\r\nprintk("%s: sent %d byte packet of type %x\n",\r\ndev->name, skb->len,\r\n(skb->data[ETH_ALEN+ETH_ALEN] << 8)\r\n| skb->data[ETH_ALEN+ETH_ALEN+1]);\r\nlocal_irq_save(flags);\r\nnetif_stop_queue(dev);\r\nwritereg(dev, PP_TxCMD, lp->send_cmd);\r\nwritereg(dev, PP_TxLength, skb->len);\r\nif ((readreg(dev, PP_BusST) & READY_FOR_TX_NOW) == 0) {\r\nlocal_irq_restore(flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nskb_copy_from_linear_data(skb, (void *)(dev->mem_start + PP_TxFrame),\r\nskb->len+1);\r\nlocal_irq_restore(flags);\r\ndev_kfree_skb (skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t net_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct net_local *lp;\r\nint ioaddr, status;\r\nif (dev == NULL) {\r\nprintk ("net_interrupt(): irq %d for unknown device.\n", irq);\r\nreturn IRQ_NONE;\r\n}\r\nioaddr = dev->base_addr;\r\nlp = netdev_priv(dev);\r\nwhile ((status = swab16(nubus_readw(dev->base_addr + ISQ_PORT)))) {\r\nif (net_debug > 4)printk("%s: event=%04x\n", dev->name, status);\r\nswitch(status & ISQ_EVENT_MASK) {\r\ncase ISQ_RECEIVER_EVENT:\r\nnet_rx(dev);\r\nbreak;\r\ncase ISQ_TRANSMITTER_EVENT:\r\ndev->stats.tx_packets++;\r\nnetif_wake_queue(dev);\r\nif ((status & TX_OK) == 0)\r\ndev->stats.tx_errors++;\r\nif (status & TX_LOST_CRS)\r\ndev->stats.tx_carrier_errors++;\r\nif (status & TX_SQE_ERROR)\r\ndev->stats.tx_heartbeat_errors++;\r\nif (status & TX_LATE_COL)\r\ndev->stats.tx_window_errors++;\r\nif (status & TX_16_COL)\r\ndev->stats.tx_aborted_errors++;\r\nbreak;\r\ncase ISQ_BUFFER_EVENT:\r\nif (status & READY_FOR_TX) {\r\nnetif_wake_queue(dev);\r\n}\r\nif (status & TX_UNDERRUN) {\r\nif (net_debug > 0) printk("%s: transmit underrun\n", dev->name);\r\nlp->send_underrun++;\r\nif (lp->send_underrun == 3) lp->send_cmd = TX_AFTER_381;\r\nelse if (lp->send_underrun == 6) lp->send_cmd = TX_AFTER_ALL;\r\n}\r\nbreak;\r\ncase ISQ_RX_MISS_EVENT:\r\ndev->stats.rx_missed_errors += (status >> 6);\r\nbreak;\r\ncase ISQ_TX_COL_EVENT:\r\ndev->stats.collisions += (status >> 6);\r\nbreak;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nnet_rx(struct net_device *dev)\r\n{\r\nstruct sk_buff *skb;\r\nint status, length;\r\nstatus = readreg(dev, PP_RxStatus);\r\nif ((status & RX_OK) == 0) {\r\ndev->stats.rx_errors++;\r\nif (status & RX_RUNT)\r\ndev->stats.rx_length_errors++;\r\nif (status & RX_EXTRA_DATA)\r\ndev->stats.rx_length_errors++;\r\nif ((status & RX_CRC_ERROR) &&\r\n!(status & (RX_EXTRA_DATA|RX_RUNT)))\r\ndev->stats.rx_crc_errors++;\r\nif (status & RX_DRIBBLE)\r\ndev->stats.rx_frame_errors++;\r\nreturn;\r\n}\r\nlength = readreg(dev, PP_RxLength);\r\nskb = alloc_skb(length, GFP_ATOMIC);\r\nif (skb == NULL) {\r\nprintk("%s: Memory squeeze, dropping packet.\n", dev->name);\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_put(skb, length);\r\nskb_copy_to_linear_data(skb, (void *)(dev->mem_start + PP_RxFrame),\r\nlength);\r\nif (net_debug > 3)printk("%s: received %d byte packet of type %x\n",\r\ndev->name, length,\r\n(skb->data[ETH_ALEN+ETH_ALEN] << 8)\r\n| skb->data[ETH_ALEN+ETH_ALEN+1]);\r\nskb->protocol=eth_type_trans(skb,dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += length;\r\n}\r\nstatic int\r\nnet_close(struct net_device *dev)\r\n{\r\nwritereg(dev, PP_RxCFG, 0);\r\nwritereg(dev, PP_TxCFG, 0);\r\nwritereg(dev, PP_BufCFG, 0);\r\nwritereg(dev, PP_BusCTL, 0);\r\nnetif_stop_queue(dev);\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *\r\nnet_get_stats(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ndev->stats.rx_missed_errors += (readreg(dev, PP_RxMiss) >> 6);\r\ndev->stats.collisions += (readreg(dev, PP_TxCol) >> 6);\r\nlocal_irq_restore(flags);\r\nreturn &dev->stats;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nif(dev->flags&IFF_PROMISC)\r\n{\r\nlp->rx_mode = RX_ALL_ACCEPT;\r\n} else if ((dev->flags & IFF_ALLMULTI) || !netdev_mc_empty(dev)) {\r\nlp->rx_mode = RX_MULTCAST_ACCEPT;\r\n}\r\nelse\r\nlp->rx_mode = 0;\r\nwritereg(dev, PP_RxCTL, DEF_RX_ACCEPT | lp->rx_mode);\r\nwritereg(dev, PP_RxCFG, lp->curr_rx_cfg |\r\n(lp->rx_mode == RX_ALL_ACCEPT? (RX_CRC_ERROR_ENBL|RX_RUNT_ENBL|RX_EXTRA_DATA_ENBL) : 0));\r\n}\r\nstatic int set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *saddr = addr;\r\nint i;\r\nif (!is_valid_ether_addr(saddr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, saddr->sa_data, ETH_ALEN);\r\nprintk("%s: Setting MAC address to %pM\n", dev->name, dev->dev_addr);\r\nfor (i=0; i < ETH_ALEN/2; i++)\r\nwritereg(dev, PP_IA+i*2, dev->dev_addr[i*2] | (dev->dev_addr[i*2+1] << 8));\r\nreturn 0;\r\n}\r\nint __init\r\ninit_module(void)\r\n{\r\nnet_debug = debug;\r\ndev_cs89x0 = mac89x0_probe(-1);\r\nif (IS_ERR(dev_cs89x0)) {\r\nprintk(KERN_WARNING "mac89x0.c: No card found\n");\r\nreturn PTR_ERR(dev_cs89x0);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\ncleanup_module(void)\r\n{\r\nunregister_netdev(dev_cs89x0);\r\nnubus_writew(0, dev_cs89x0->base_addr + ADD_PORT);\r\nfree_netdev(dev_cs89x0);\r\n}
