static int cid_of_response(char *s)\r\n{\r\nint cid;\r\nint rc;\r\nif (s[-1] != ';')\r\nreturn 0;\r\nrc = kstrtoint(s, 10, &cid);\r\nif (rc)\r\nreturn 0;\r\nif (cid < 1 || cid > 65535)\r\nreturn -1;\r\nreturn cid;\r\n}\r\nvoid gigaset_handle_modem_response(struct cardstate *cs)\r\n{\r\nunsigned char *argv[MAX_REC_PARAMS + 1];\r\nint params;\r\nint i, j;\r\nconst struct resp_type_t *rt;\r\nconst struct zsau_resp_t *zr;\r\nint curarg;\r\nunsigned long flags;\r\nunsigned next, tail, head;\r\nstruct event_t *event;\r\nint resp_code;\r\nint param_type;\r\nint abort;\r\nsize_t len;\r\nint cid;\r\nint rawstring;\r\nlen = cs->cbytes;\r\nif (!len) {\r\ngig_dbg(DEBUG_MCMD, "skipped EOL [%02X]", cs->respdata[len]);\r\nreturn;\r\n}\r\ncs->respdata[len] = 0;\r\nargv[0] = cs->respdata;\r\nparams = 1;\r\nif (cs->at_state.getstring) {\r\ncs->at_state.getstring = 0;\r\nrawstring = 1;\r\ncid = 0;\r\n} else {\r\nfor (i = 0; i < len; i++)\r\nswitch (cs->respdata[i]) {\r\ncase ';':\r\ncase ',':\r\ncase '=':\r\nif (params > MAX_REC_PARAMS) {\r\ndev_warn(cs->dev,\r\n"too many parameters in response\n");\r\nparams--;\r\n}\r\nargv[params++] = cs->respdata + i + 1;\r\n}\r\nrawstring = 0;\r\ncid = params > 1 ? cid_of_response(argv[params - 1]) : 0;\r\nif (cid < 0) {\r\ngigaset_add_event(cs, &cs->at_state, RSP_INVAL,\r\nNULL, 0, NULL);\r\nreturn;\r\n}\r\nfor (j = 1; j < params; ++j)\r\nargv[j][-1] = 0;\r\ngig_dbg(DEBUG_EVENT, "CMD received: %s", argv[0]);\r\nif (cid) {\r\n--params;\r\ngig_dbg(DEBUG_EVENT, "CID: %s", argv[params]);\r\n}\r\ngig_dbg(DEBUG_EVENT, "available params: %d", params - 1);\r\nfor (j = 1; j < params; j++)\r\ngig_dbg(DEBUG_EVENT, "param %d: %s", j, argv[j]);\r\n}\r\nspin_lock_irqsave(&cs->ev_lock, flags);\r\nhead = cs->ev_head;\r\ntail = cs->ev_tail;\r\nabort = 1;\r\ncurarg = 0;\r\nwhile (curarg < params) {\r\nnext = (tail + 1) % MAX_EVENTS;\r\nif (unlikely(next == head)) {\r\ndev_err(cs->dev, "event queue full\n");\r\nbreak;\r\n}\r\nevent = cs->events + tail;\r\nevent->at_state = NULL;\r\nevent->cid = cid;\r\nevent->ptr = NULL;\r\nevent->arg = NULL;\r\ntail = next;\r\nif (rawstring) {\r\nresp_code = RSP_STRING;\r\nparam_type = RT_STRING;\r\n} else {\r\nfor (rt = resp_type; rt->response; ++rt)\r\nif (!strcmp(argv[curarg], rt->response))\r\nbreak;\r\nif (!rt->response) {\r\nevent->type = RSP_NONE;\r\ngig_dbg(DEBUG_EVENT,\r\n"unknown modem response: '%s'\n",\r\nargv[curarg]);\r\nbreak;\r\n}\r\nresp_code = rt->resp_code;\r\nparam_type = rt->type;\r\n++curarg;\r\n}\r\nevent->type = resp_code;\r\nswitch (param_type) {\r\ncase RT_NOTHING:\r\nbreak;\r\ncase RT_RING:\r\nif (!cid) {\r\ndev_err(cs->dev,\r\n"received RING without CID!\n");\r\nevent->type = RSP_INVAL;\r\nabort = 1;\r\n} else {\r\nevent->cid = 0;\r\nevent->parameter = cid;\r\nabort = 0;\r\n}\r\nbreak;\r\ncase RT_ZSAU:\r\nif (curarg >= params) {\r\nevent->parameter = ZSAU_NONE;\r\nbreak;\r\n}\r\nfor (zr = zsau_resp; zr->str; ++zr)\r\nif (!strcmp(argv[curarg], zr->str))\r\nbreak;\r\nevent->parameter = zr->code;\r\nif (!zr->str)\r\ndev_warn(cs->dev,\r\n"%s: unknown parameter %s after ZSAU\n",\r\n__func__, argv[curarg]);\r\n++curarg;\r\nbreak;\r\ncase RT_STRING:\r\nif (curarg < params) {\r\nevent->ptr = kstrdup(argv[curarg], GFP_ATOMIC);\r\nif (!event->ptr)\r\ndev_err(cs->dev, "out of memory\n");\r\n++curarg;\r\n}\r\ngig_dbg(DEBUG_EVENT, "string==%s",\r\nevent->ptr ? (char *) event->ptr : "NULL");\r\nbreak;\r\ncase RT_ZCAU:\r\nevent->parameter = -1;\r\nif (curarg + 1 < params) {\r\nu8 type, value;\r\ni = kstrtou8(argv[curarg++], 16, &type);\r\nj = kstrtou8(argv[curarg++], 16, &value);\r\nif (i == 0 && j == 0)\r\nevent->parameter = (type << 8) | value;\r\n} else\r\ncurarg = params - 1;\r\nbreak;\r\ncase RT_NUMBER:\r\nif (curarg >= params ||\r\nkstrtoint(argv[curarg++], 10, &event->parameter))\r\nevent->parameter = -1;\r\ngig_dbg(DEBUG_EVENT, "parameter==%d", event->parameter);\r\nbreak;\r\n}\r\nif (resp_code == RSP_ZDLE)\r\ncs->dle = event->parameter;\r\nif (abort)\r\nbreak;\r\n}\r\ncs->ev_tail = tail;\r\nspin_unlock_irqrestore(&cs->ev_lock, flags);\r\nif (curarg != params)\r\ngig_dbg(DEBUG_EVENT,\r\n"invalid number of processed parameters: %d/%d",\r\ncurarg, params);\r\n}\r\nstatic void disconnect(struct at_state_t **at_state_p)\r\n{\r\nunsigned long flags;\r\nstruct bc_state *bcs = (*at_state_p)->bcs;\r\nstruct cardstate *cs = (*at_state_p)->cs;\r\nspin_lock_irqsave(&cs->lock, flags);\r\n++(*at_state_p)->seq_index;\r\nif (!cs->cidmode) {\r\ncs->at_state.pending_commands |= PC_UMMODE;\r\ngig_dbg(DEBUG_EVENT, "Scheduling PC_UMMODE");\r\ncs->commands_pending = 1;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nif (bcs) {\r\ncs->ops->close_bchannel(bcs);\r\nif (bcs->chstate & (CHS_D_UP | CHS_NOTIFY_LL)) {\r\nbcs->chstate &= ~(CHS_D_UP | CHS_NOTIFY_LL);\r\ngigaset_isdn_hupD(bcs);\r\n}\r\n} else {\r\nspin_lock_irqsave(&cs->lock, flags);\r\nlist_del(&(*at_state_p)->list);\r\nkfree(*at_state_p);\r\n*at_state_p = NULL;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\n}\r\n}\r\nstatic inline struct at_state_t *get_free_channel(struct cardstate *cs,\r\nint cid)\r\n{\r\nunsigned long flags;\r\nint i;\r\nstruct at_state_t *ret;\r\nfor (i = 0; i < cs->channels; ++i)\r\nif (gigaset_get_channel(cs->bcs + i) >= 0) {\r\nret = &cs->bcs[i].at_state;\r\nret->cid = cid;\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&cs->lock, flags);\r\nret = kmalloc(sizeof(struct at_state_t), GFP_ATOMIC);\r\nif (ret) {\r\ngigaset_at_init(ret, NULL, cs, cid);\r\nlist_add(&ret->list, &cs->temp_at_states);\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void init_failed(struct cardstate *cs, int mode)\r\n{\r\nint i;\r\nstruct at_state_t *at_state;\r\ncs->at_state.pending_commands &= ~PC_INIT;\r\ncs->mode = mode;\r\ncs->mstate = MS_UNINITIALIZED;\r\ngigaset_free_channels(cs);\r\nfor (i = 0; i < cs->channels; ++i) {\r\nat_state = &cs->bcs[i].at_state;\r\nif (at_state->pending_commands & PC_CID) {\r\nat_state->pending_commands &= ~PC_CID;\r\nat_state->pending_commands |= PC_NOCID;\r\ncs->commands_pending = 1;\r\n}\r\n}\r\n}\r\nstatic void schedule_init(struct cardstate *cs, int state)\r\n{\r\nif (cs->at_state.pending_commands & PC_INIT) {\r\ngig_dbg(DEBUG_EVENT, "not scheduling PC_INIT again");\r\nreturn;\r\n}\r\ncs->mstate = state;\r\ncs->mode = M_UNKNOWN;\r\ngigaset_block_channels(cs);\r\ncs->at_state.pending_commands |= PC_INIT;\r\ngig_dbg(DEBUG_EVENT, "Scheduling PC_INIT");\r\ncs->commands_pending = 1;\r\n}\r\nstatic void send_command(struct cardstate *cs, const char *cmd, int cid,\r\nint dle, gfp_t kmallocflags)\r\n{\r\nstruct cmdbuf_t *cb;\r\nsize_t buflen;\r\nbuflen = strlen(cmd) + 12;\r\ncb = kmalloc(sizeof(struct cmdbuf_t) + buflen, kmallocflags);\r\nif (!cb) {\r\ndev_err(cs->dev, "%s: out of memory\n", __func__);\r\nreturn;\r\n}\r\nif (cid > 0 && cid <= 65535)\r\ncb->len = snprintf(cb->buf, buflen,\r\ndle ? "\020(AT%d%s\020)" : "AT%d%s",\r\ncid, cmd);\r\nelse\r\ncb->len = snprintf(cb->buf, buflen,\r\ndle ? "\020(AT%s\020)" : "AT%s",\r\ncmd);\r\ncb->offset = 0;\r\ncb->next = NULL;\r\ncb->wake_tasklet = NULL;\r\ncs->ops->write_cmd(cs, cb);\r\n}\r\nstatic struct at_state_t *at_state_from_cid(struct cardstate *cs, int cid)\r\n{\r\nstruct at_state_t *at_state;\r\nint i;\r\nunsigned long flags;\r\nif (cid == 0)\r\nreturn &cs->at_state;\r\nfor (i = 0; i < cs->channels; ++i)\r\nif (cid == cs->bcs[i].at_state.cid)\r\nreturn &cs->bcs[i].at_state;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nlist_for_each_entry(at_state, &cs->temp_at_states, list)\r\nif (cid == at_state->cid) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn at_state;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn NULL;\r\n}\r\nstatic void bchannel_down(struct bc_state *bcs)\r\n{\r\nif (bcs->chstate & CHS_B_UP) {\r\nbcs->chstate &= ~CHS_B_UP;\r\ngigaset_isdn_hupB(bcs);\r\n}\r\nif (bcs->chstate & (CHS_D_UP | CHS_NOTIFY_LL)) {\r\nbcs->chstate &= ~(CHS_D_UP | CHS_NOTIFY_LL);\r\ngigaset_isdn_hupD(bcs);\r\n}\r\ngigaset_free_channel(bcs);\r\ngigaset_bcs_reinit(bcs);\r\n}\r\nstatic void bchannel_up(struct bc_state *bcs)\r\n{\r\nif (bcs->chstate & CHS_B_UP) {\r\ndev_notice(bcs->cs->dev, "%s: B channel already up\n",\r\n__func__);\r\nreturn;\r\n}\r\nbcs->chstate |= CHS_B_UP;\r\ngigaset_isdn_connB(bcs);\r\n}\r\nstatic void start_dial(struct at_state_t *at_state, void *data,\r\nunsigned seq_index)\r\n{\r\nstruct bc_state *bcs = at_state->bcs;\r\nstruct cardstate *cs = at_state->cs;\r\nchar **commands = data;\r\nunsigned long flags;\r\nint i;\r\nbcs->chstate |= CHS_NOTIFY_LL;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (at_state->seq_index != seq_index) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ngoto error;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nfor (i = 0; i < AT_NUM; ++i) {\r\nkfree(bcs->commands[i]);\r\nbcs->commands[i] = commands[i];\r\n}\r\nat_state->pending_commands |= PC_CID;\r\ngig_dbg(DEBUG_EVENT, "Scheduling PC_CID");\r\ncs->commands_pending = 1;\r\nreturn;\r\nerror:\r\nfor (i = 0; i < AT_NUM; ++i) {\r\nkfree(commands[i]);\r\ncommands[i] = NULL;\r\n}\r\nat_state->pending_commands |= PC_NOCID;\r\ngig_dbg(DEBUG_EVENT, "Scheduling PC_NOCID");\r\ncs->commands_pending = 1;\r\nreturn;\r\n}\r\nstatic void start_accept(struct at_state_t *at_state)\r\n{\r\nstruct cardstate *cs = at_state->cs;\r\nstruct bc_state *bcs = at_state->bcs;\r\nint i;\r\nfor (i = 0; i < AT_NUM; ++i) {\r\nkfree(bcs->commands[i]);\r\nbcs->commands[i] = NULL;\r\n}\r\nbcs->commands[AT_PROTO] = kmalloc(9, GFP_ATOMIC);\r\nbcs->commands[AT_ISO] = kmalloc(9, GFP_ATOMIC);\r\nif (!bcs->commands[AT_PROTO] || !bcs->commands[AT_ISO]) {\r\ndev_err(at_state->cs->dev, "out of memory\n");\r\nat_state->pending_commands |= PC_HUP;\r\ngig_dbg(DEBUG_EVENT, "Scheduling PC_HUP");\r\ncs->commands_pending = 1;\r\nreturn;\r\n}\r\nsnprintf(bcs->commands[AT_PROTO], 9, "^SBPR=%u\r", bcs->proto2);\r\nsnprintf(bcs->commands[AT_ISO], 9, "^SISO=%u\r", bcs->channel + 1);\r\nat_state->pending_commands |= PC_ACCEPT;\r\ngig_dbg(DEBUG_EVENT, "Scheduling PC_ACCEPT");\r\ncs->commands_pending = 1;\r\n}\r\nstatic void do_start(struct cardstate *cs)\r\n{\r\ngigaset_free_channels(cs);\r\nif (cs->mstate != MS_LOCKED)\r\nschedule_init(cs, MS_INIT);\r\ncs->isdn_up = 1;\r\ngigaset_isdn_start(cs);\r\ncs->waiting = 0;\r\nwake_up(&cs->waitqueue);\r\n}\r\nstatic void finish_shutdown(struct cardstate *cs)\r\n{\r\nif (cs->mstate != MS_LOCKED) {\r\ncs->mstate = MS_UNINITIALIZED;\r\ncs->mode = M_UNKNOWN;\r\n}\r\nif (cs->isdn_up) {\r\ncs->isdn_up = 0;\r\ngigaset_isdn_stop(cs);\r\n}\r\ncs->cmd_result = -ENODEV;\r\ncs->waiting = 0;\r\nwake_up(&cs->waitqueue);\r\n}\r\nstatic void do_shutdown(struct cardstate *cs)\r\n{\r\ngigaset_block_channels(cs);\r\nif (cs->mstate == MS_READY) {\r\ncs->mstate = MS_SHUTDOWN;\r\ncs->at_state.pending_commands |= PC_SHUTDOWN;\r\ngig_dbg(DEBUG_EVENT, "Scheduling PC_SHUTDOWN");\r\ncs->commands_pending = 1;\r\n} else\r\nfinish_shutdown(cs);\r\n}\r\nstatic void do_stop(struct cardstate *cs)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->connected = 0;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ndo_shutdown(cs);\r\n}\r\nstatic int reinit_and_retry(struct cardstate *cs, int channel)\r\n{\r\nint i;\r\nif (--cs->retry_count <= 0)\r\nreturn -EFAULT;\r\nfor (i = 0; i < cs->channels; ++i)\r\nif (cs->bcs[i].at_state.cid > 0)\r\nreturn -EBUSY;\r\nif (channel < 0)\r\ndev_warn(cs->dev,\r\n"Could not enter cid mode. Reinit device and try again.\n");\r\nelse {\r\ndev_warn(cs->dev,\r\n"Could not get a call id. Reinit device and try again.\n");\r\ncs->bcs[channel].at_state.pending_commands |= PC_CID;\r\n}\r\nschedule_init(cs, MS_INIT);\r\nreturn 0;\r\n}\r\nstatic int at_state_invalid(struct cardstate *cs,\r\nstruct at_state_t *test_ptr)\r\n{\r\nunsigned long flags;\r\nunsigned channel;\r\nstruct at_state_t *at_state;\r\nint retval = 0;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (test_ptr == &cs->at_state)\r\ngoto exit;\r\nlist_for_each_entry(at_state, &cs->temp_at_states, list)\r\nif (at_state == test_ptr)\r\ngoto exit;\r\nfor (channel = 0; channel < cs->channels; ++channel)\r\nif (&cs->bcs[channel].at_state == test_ptr)\r\ngoto exit;\r\nretval = 1;\r\nexit:\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void handle_icall(struct cardstate *cs, struct bc_state *bcs,\r\nstruct at_state_t **p_at_state)\r\n{\r\nint retval;\r\nstruct at_state_t *at_state = *p_at_state;\r\nretval = gigaset_isdn_icall(at_state);\r\nswitch (retval) {\r\ncase ICALL_ACCEPT:\r\nbreak;\r\ndefault:\r\ndev_err(cs->dev, "internal error: disposition=%d\n", retval);\r\ncase ICALL_IGNORE:\r\ncase ICALL_REJECT:\r\nat_state->pending_commands |= PC_HUP;\r\ncs->commands_pending = 1;\r\nbreak;\r\n}\r\n}\r\nstatic int do_lock(struct cardstate *cs)\r\n{\r\nint mode;\r\nint i;\r\nswitch (cs->mstate) {\r\ncase MS_UNINITIALIZED:\r\ncase MS_READY:\r\nif (cs->cur_at_seq || !list_empty(&cs->temp_at_states) ||\r\ncs->at_state.pending_commands)\r\nreturn -EBUSY;\r\nfor (i = 0; i < cs->channels; ++i)\r\nif (cs->bcs[i].at_state.pending_commands)\r\nreturn -EBUSY;\r\nif (gigaset_get_channels(cs) < 0)\r\nreturn -EBUSY;\r\nbreak;\r\ncase MS_LOCKED:\r\nbreak;\r\ndefault:\r\nreturn -EBUSY;\r\n}\r\nmode = cs->mode;\r\ncs->mstate = MS_LOCKED;\r\ncs->mode = M_UNKNOWN;\r\nreturn mode;\r\n}\r\nstatic int do_unlock(struct cardstate *cs)\r\n{\r\nif (cs->mstate != MS_LOCKED)\r\nreturn -EINVAL;\r\ncs->mstate = MS_UNINITIALIZED;\r\ncs->mode = M_UNKNOWN;\r\ngigaset_free_channels(cs);\r\nif (cs->connected)\r\nschedule_init(cs, MS_INIT);\r\nreturn 0;\r\n}\r\nstatic void do_action(int action, struct cardstate *cs,\r\nstruct bc_state *bcs,\r\nstruct at_state_t **p_at_state, char **pp_command,\r\nint *p_genresp, int *p_resp_code,\r\nstruct event_t *ev)\r\n{\r\nstruct at_state_t *at_state = *p_at_state;\r\nstruct at_state_t *at_state2;\r\nunsigned long flags;\r\nint channel;\r\nunsigned char *s, *e;\r\nint i;\r\nunsigned long val;\r\nswitch (action) {\r\ncase ACT_NOTHING:\r\nbreak;\r\ncase ACT_TIMEOUT:\r\nat_state->waiting = 1;\r\nbreak;\r\ncase ACT_INIT:\r\ncs->at_state.pending_commands &= ~PC_INIT;\r\ncs->cur_at_seq = SEQ_NONE;\r\ncs->mode = M_UNIMODEM;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (!cs->cidmode) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ngigaset_free_channels(cs);\r\ncs->mstate = MS_READY;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ncs->at_state.pending_commands |= PC_CIDMODE;\r\ngig_dbg(DEBUG_EVENT, "Scheduling PC_CIDMODE");\r\ncs->commands_pending = 1;\r\nbreak;\r\ncase ACT_FAILINIT:\r\ndev_warn(cs->dev, "Could not initialize the device.\n");\r\ncs->dle = 0;\r\ninit_failed(cs, M_UNKNOWN);\r\ncs->cur_at_seq = SEQ_NONE;\r\nbreak;\r\ncase ACT_CONFIGMODE:\r\ninit_failed(cs, M_CONFIG);\r\ncs->cur_at_seq = SEQ_NONE;\r\nbreak;\r\ncase ACT_SETDLE1:\r\ncs->dle = 1;\r\ncs->inbuf[0].inputstate &=\r\n~(INS_command | INS_DLE_command);\r\nbreak;\r\ncase ACT_SETDLE0:\r\ncs->dle = 0;\r\ncs->inbuf[0].inputstate =\r\n(cs->inbuf[0].inputstate & ~INS_DLE_command)\r\n| INS_command;\r\nbreak;\r\ncase ACT_CMODESET:\r\nif (cs->mstate == MS_INIT || cs->mstate == MS_RECOVER) {\r\ngigaset_free_channels(cs);\r\ncs->mstate = MS_READY;\r\n}\r\ncs->mode = M_CID;\r\ncs->cur_at_seq = SEQ_NONE;\r\nbreak;\r\ncase ACT_UMODESET:\r\ncs->mode = M_UNIMODEM;\r\ncs->cur_at_seq = SEQ_NONE;\r\nbreak;\r\ncase ACT_FAILCMODE:\r\ncs->cur_at_seq = SEQ_NONE;\r\nif (cs->mstate == MS_INIT || cs->mstate == MS_RECOVER) {\r\ninit_failed(cs, M_UNKNOWN);\r\nbreak;\r\n}\r\nif (reinit_and_retry(cs, -1) < 0)\r\nschedule_init(cs, MS_RECOVER);\r\nbreak;\r\ncase ACT_FAILUMODE:\r\ncs->cur_at_seq = SEQ_NONE;\r\nschedule_init(cs, MS_RECOVER);\r\nbreak;\r\ncase ACT_HUPMODEM:\r\nif (cs->connected) {\r\nstruct cmdbuf_t *cb;\r\ncb = kmalloc(sizeof(struct cmdbuf_t) + 3, GFP_ATOMIC);\r\nif (!cb) {\r\ndev_err(cs->dev, "%s: out of memory\n",\r\n__func__);\r\nreturn;\r\n}\r\nmemcpy(cb->buf, "+++", 3);\r\ncb->len = 3;\r\ncb->offset = 0;\r\ncb->next = NULL;\r\ncb->wake_tasklet = NULL;\r\ncs->ops->write_cmd(cs, cb);\r\n}\r\nbreak;\r\ncase ACT_RING:\r\nat_state2 = get_free_channel(cs, ev->parameter);\r\nif (!at_state2) {\r\ndev_warn(cs->dev,\r\n"RING ignored: could not allocate channel structure\n");\r\nbreak;\r\n}\r\nat_state2->ConState = 700;\r\nfor (i = 0; i < STR_NUM; ++i) {\r\nkfree(at_state2->str_var[i]);\r\nat_state2->str_var[i] = NULL;\r\n}\r\nat_state2->int_var[VAR_ZCTP] = -1;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nat_state2->timer_expires = RING_TIMEOUT;\r\nat_state2->timer_active = 1;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase ACT_ICALL:\r\nhandle_icall(cs, bcs, p_at_state);\r\nbreak;\r\ncase ACT_FAILSDOWN:\r\ndev_warn(cs->dev, "Could not shut down the device.\n");\r\ncase ACT_FAKESDOWN:\r\ncase ACT_SDOWN:\r\ncs->cur_at_seq = SEQ_NONE;\r\nfinish_shutdown(cs);\r\nbreak;\r\ncase ACT_CONNECT:\r\nif (cs->onechannel) {\r\nat_state->pending_commands |= PC_DLE1;\r\ncs->commands_pending = 1;\r\nbreak;\r\n}\r\nbcs->chstate |= CHS_D_UP;\r\ngigaset_isdn_connD(bcs);\r\ncs->ops->init_bchannel(bcs);\r\nbreak;\r\ncase ACT_DLE1:\r\ncs->cur_at_seq = SEQ_NONE;\r\nbcs = cs->bcs + cs->curchannel;\r\nbcs->chstate |= CHS_D_UP;\r\ngigaset_isdn_connD(bcs);\r\ncs->ops->init_bchannel(bcs);\r\nbreak;\r\ncase ACT_FAKEHUP:\r\nat_state->int_var[VAR_ZSAU] = ZSAU_NULL;\r\ncase ACT_DISCONNECT:\r\ncs->cur_at_seq = SEQ_NONE;\r\nat_state->cid = -1;\r\nif (bcs && cs->onechannel && cs->dle) {\r\nat_state->pending_commands |= PC_DLE0;\r\ncs->commands_pending = 1;\r\n} else\r\ndisconnect(p_at_state);\r\nbreak;\r\ncase ACT_FAKEDLE0:\r\nat_state->int_var[VAR_ZDLE] = 0;\r\ncs->dle = 0;\r\ncase ACT_DLE0:\r\ncs->cur_at_seq = SEQ_NONE;\r\nat_state2 = &cs->bcs[cs->curchannel].at_state;\r\ndisconnect(&at_state2);\r\nbreak;\r\ncase ACT_ABORTHUP:\r\ncs->cur_at_seq = SEQ_NONE;\r\ndev_warn(cs->dev, "Could not hang up.\n");\r\nat_state->cid = -1;\r\nif (bcs && cs->onechannel)\r\nat_state->pending_commands |= PC_DLE0;\r\nelse\r\ndisconnect(p_at_state);\r\nschedule_init(cs, MS_RECOVER);\r\nbreak;\r\ncase ACT_FAILDLE0:\r\ncs->cur_at_seq = SEQ_NONE;\r\ndev_warn(cs->dev, "Could not leave DLE mode.\n");\r\nat_state2 = &cs->bcs[cs->curchannel].at_state;\r\ndisconnect(&at_state2);\r\nschedule_init(cs, MS_RECOVER);\r\nbreak;\r\ncase ACT_FAILDLE1:\r\ncs->cur_at_seq = SEQ_NONE;\r\ndev_warn(cs->dev,\r\n"Could not enter DLE mode. Trying to hang up.\n");\r\nchannel = cs->curchannel;\r\ncs->bcs[channel].at_state.pending_commands |= PC_HUP;\r\ncs->commands_pending = 1;\r\nbreak;\r\ncase ACT_CID:\r\ncs->cur_at_seq = SEQ_NONE;\r\nchannel = cs->curchannel;\r\nif (ev->parameter > 0 && ev->parameter <= 65535) {\r\ncs->bcs[channel].at_state.cid = ev->parameter;\r\ncs->bcs[channel].at_state.pending_commands |=\r\nPC_DIAL;\r\ncs->commands_pending = 1;\r\nbreak;\r\n}\r\ncase ACT_FAILCID:\r\ncs->cur_at_seq = SEQ_NONE;\r\nchannel = cs->curchannel;\r\nif (reinit_and_retry(cs, channel) < 0) {\r\ndev_warn(cs->dev,\r\n"Could not get a call ID. Cannot dial.\n");\r\nat_state2 = &cs->bcs[channel].at_state;\r\ndisconnect(&at_state2);\r\n}\r\nbreak;\r\ncase ACT_ABORTCID:\r\ncs->cur_at_seq = SEQ_NONE;\r\nat_state2 = &cs->bcs[cs->curchannel].at_state;\r\ndisconnect(&at_state2);\r\nbreak;\r\ncase ACT_DIALING:\r\ncase ACT_ACCEPTED:\r\ncs->cur_at_seq = SEQ_NONE;\r\nbreak;\r\ncase ACT_ABORTACCEPT:\r\ndisconnect(p_at_state);\r\nbreak;\r\ncase ACT_ABORTDIAL:\r\ncs->cur_at_seq = SEQ_NONE;\r\nat_state->pending_commands |= PC_HUP;\r\ncs->commands_pending = 1;\r\nbreak;\r\ncase ACT_REMOTEREJECT:\r\ncase ACT_CONNTIMEOUT:\r\ncase ACT_REMOTEHUP:\r\nat_state->pending_commands |= PC_HUP;\r\ncs->commands_pending = 1;\r\nbreak;\r\ncase ACT_GETSTRING:\r\nat_state->getstring = 1;\r\nbreak;\r\ncase ACT_SETVER:\r\nif (!ev->ptr) {\r\n*p_genresp = 1;\r\n*p_resp_code = RSP_ERROR;\r\nbreak;\r\n}\r\ns = ev->ptr;\r\nif (!strcmp(s, "OK")) {\r\n*p_genresp = 1;\r\n*p_resp_code = RSP_NONE;\r\nbreak;\r\n}\r\nfor (i = 0; i < 4; ++i) {\r\nval = simple_strtoul(s, (char **) &e, 10);\r\nif (val > INT_MAX || e == s)\r\nbreak;\r\nif (i == 3) {\r\nif (*e)\r\nbreak;\r\n} else if (*e != '.')\r\nbreak;\r\nelse\r\ns = e + 1;\r\ncs->fwver[i] = val;\r\n}\r\nif (i != 4) {\r\n*p_genresp = 1;\r\n*p_resp_code = RSP_ERROR;\r\nbreak;\r\n}\r\ncs->gotfwver = 0;\r\nbreak;\r\ncase ACT_GOTVER:\r\nif (cs->gotfwver == 0) {\r\ncs->gotfwver = 1;\r\ngig_dbg(DEBUG_EVENT,\r\n"firmware version %02d.%03d.%02d.%02d",\r\ncs->fwver[0], cs->fwver[1],\r\ncs->fwver[2], cs->fwver[3]);\r\nbreak;\r\n}\r\ncase ACT_FAILVER:\r\ncs->gotfwver = -1;\r\ndev_err(cs->dev, "could not read firmware version.\n");\r\nbreak;\r\ncase ACT_ERROR:\r\ngig_dbg(DEBUG_ANY, "%s: ERROR response in ConState %d",\r\n__func__, at_state->ConState);\r\ncs->cur_at_seq = SEQ_NONE;\r\nbreak;\r\ncase ACT_DEBUG:\r\ngig_dbg(DEBUG_ANY, "%s: resp_code %d in ConState %d",\r\n__func__, ev->type, at_state->ConState);\r\nbreak;\r\ncase ACT_WARN:\r\ndev_warn(cs->dev, "%s: resp_code %d in ConState %d!\n",\r\n__func__, ev->type, at_state->ConState);\r\nbreak;\r\ncase ACT_ZCAU:\r\ndev_warn(cs->dev, "cause code %04x in connection state %d.\n",\r\nev->parameter, at_state->ConState);\r\nbreak;\r\ncase ACT_DIAL:\r\nstart_dial(at_state, ev->ptr, ev->parameter);\r\nbreak;\r\ncase ACT_ACCEPT:\r\nstart_accept(at_state);\r\nbreak;\r\ncase ACT_HUP:\r\nat_state->pending_commands |= PC_HUP;\r\ngig_dbg(DEBUG_EVENT, "Scheduling PC_HUP");\r\ncs->commands_pending = 1;\r\nbreak;\r\ncase ACT_STOP:\r\ndo_stop(cs);\r\nbreak;\r\ncase ACT_START:\r\ndo_start(cs);\r\nbreak;\r\ncase ACT_IF_LOCK:\r\ncs->cmd_result = ev->parameter ? do_lock(cs) : do_unlock(cs);\r\ncs->waiting = 0;\r\nwake_up(&cs->waitqueue);\r\nbreak;\r\ncase ACT_IF_VER:\r\nif (ev->parameter != 0)\r\ncs->cmd_result = -EINVAL;\r\nelse if (cs->gotfwver != 1) {\r\ncs->cmd_result = -ENOENT;\r\n} else {\r\nmemcpy(ev->arg, cs->fwver, sizeof cs->fwver);\r\ncs->cmd_result = 0;\r\n}\r\ncs->waiting = 0;\r\nwake_up(&cs->waitqueue);\r\nbreak;\r\ncase ACT_PROC_CIDMODE:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (ev->parameter != cs->cidmode) {\r\ncs->cidmode = ev->parameter;\r\nif (ev->parameter) {\r\ncs->at_state.pending_commands |= PC_CIDMODE;\r\ngig_dbg(DEBUG_EVENT, "Scheduling PC_CIDMODE");\r\n} else {\r\ncs->at_state.pending_commands |= PC_UMMODE;\r\ngig_dbg(DEBUG_EVENT, "Scheduling PC_UMMODE");\r\n}\r\ncs->commands_pending = 1;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ncs->waiting = 0;\r\nwake_up(&cs->waitqueue);\r\nbreak;\r\ncase ACT_NOTIFY_BC_DOWN:\r\nbchannel_down(bcs);\r\nbreak;\r\ncase ACT_NOTIFY_BC_UP:\r\nbchannel_up(bcs);\r\nbreak;\r\ncase ACT_SHUTDOWN:\r\ndo_shutdown(cs);\r\nbreak;\r\ndefault:\r\nif (action >= ACT_CMD && action < ACT_CMD + AT_NUM) {\r\n*pp_command = at_state->bcs->commands[action - ACT_CMD];\r\nif (!*pp_command) {\r\n*p_genresp = 1;\r\n*p_resp_code = RSP_NULL;\r\n}\r\n} else\r\ndev_err(cs->dev, "%s: action==%d!\n", __func__, action);\r\n}\r\n}\r\nstatic void process_event(struct cardstate *cs, struct event_t *ev)\r\n{\r\nstruct bc_state *bcs;\r\nchar *p_command = NULL;\r\nstruct reply_t *rep;\r\nint rcode;\r\nint genresp = 0;\r\nint resp_code = RSP_ERROR;\r\nint sendcid;\r\nstruct at_state_t *at_state;\r\nint index;\r\nint curact;\r\nunsigned long flags;\r\nif (ev->cid >= 0) {\r\nat_state = at_state_from_cid(cs, ev->cid);\r\nif (!at_state) {\r\ngig_dbg(DEBUG_EVENT, "event %d for invalid cid %d",\r\nev->type, ev->cid);\r\ngigaset_add_event(cs, &cs->at_state, RSP_WRONG_CID,\r\nNULL, 0, NULL);\r\nreturn;\r\n}\r\n} else {\r\nat_state = ev->at_state;\r\nif (at_state_invalid(cs, at_state)) {\r\ngig_dbg(DEBUG_EVENT, "event for invalid at_state %p",\r\nat_state);\r\nreturn;\r\n}\r\n}\r\ngig_dbg(DEBUG_EVENT, "connection state %d, event %d",\r\nat_state->ConState, ev->type);\r\nbcs = at_state->bcs;\r\nsendcid = at_state->cid;\r\nrep = at_state->replystruct;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (ev->type == EV_TIMEOUT) {\r\nif (ev->parameter != at_state->timer_index\r\n|| !at_state->timer_active) {\r\nev->type = RSP_NONE;\r\ngig_dbg(DEBUG_EVENT, "old timeout");\r\n} else if (!at_state->waiting)\r\ngig_dbg(DEBUG_EVENT, "timeout occurred");\r\nelse\r\ngig_dbg(DEBUG_EVENT, "stopped waiting");\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nif (ev->type >= RSP_VAR && ev->type < RSP_VAR + VAR_NUM) {\r\nindex = ev->type - RSP_VAR;\r\nat_state->int_var[index] = ev->parameter;\r\n} else if (ev->type >= RSP_STR && ev->type < RSP_STR + STR_NUM) {\r\nindex = ev->type - RSP_STR;\r\nkfree(at_state->str_var[index]);\r\nat_state->str_var[index] = ev->ptr;\r\nev->ptr = NULL;\r\n}\r\nif (ev->type == EV_TIMEOUT || ev->type == RSP_STRING)\r\nat_state->getstring = 0;\r\nfor (;; rep++) {\r\nrcode = rep->resp_code;\r\nif (rcode == RSP_LAST) {\r\ndev_warn(cs->dev, "%s: rcode=RSP_LAST: "\r\n"resp_code %d in ConState %d!\n",\r\n__func__, ev->type, at_state->ConState);\r\nreturn;\r\n}\r\nif ((rcode == RSP_ANY || rcode == ev->type)\r\n&& ((int) at_state->ConState >= rep->min_ConState)\r\n&& (rep->max_ConState < 0\r\n|| (int) at_state->ConState <= rep->max_ConState)\r\n&& (rep->parameter < 0 || rep->parameter == ev->parameter))\r\nbreak;\r\n}\r\np_command = rep->command;\r\nat_state->waiting = 0;\r\nfor (curact = 0; curact < MAXACT; ++curact) {\r\ndo_action(rep->action[curact], cs, bcs, &at_state, &p_command,\r\n&genresp, &resp_code, ev);\r\nif (!at_state)\r\nbreak;\r\n}\r\nif (at_state) {\r\nif (rep->new_ConState >= 0)\r\nat_state->ConState = rep->new_ConState;\r\nif (genresp) {\r\nspin_lock_irqsave(&cs->lock, flags);\r\nat_state->timer_expires = 0;\r\nat_state->timer_active = 0;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ngigaset_add_event(cs, at_state, resp_code,\r\nNULL, 0, NULL);\r\n} else {\r\nif (p_command) {\r\nif (cs->connected)\r\nsend_command(cs, p_command,\r\nsendcid, cs->dle,\r\nGFP_ATOMIC);\r\nelse\r\ngigaset_add_event(cs, at_state,\r\nRSP_NODEV,\r\nNULL, 0, NULL);\r\n}\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (!rep->timeout) {\r\nat_state->timer_expires = 0;\r\nat_state->timer_active = 0;\r\n} else if (rep->timeout > 0) {\r\nat_state->timer_expires = rep->timeout * 10;\r\nat_state->timer_active = 1;\r\n++at_state->timer_index;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\n}\r\n}\r\n}\r\nstatic void schedule_sequence(struct cardstate *cs,\r\nstruct at_state_t *at_state, int sequence)\r\n{\r\ncs->cur_at_seq = sequence;\r\ngigaset_add_event(cs, at_state, RSP_INIT, NULL, sequence, NULL);\r\n}\r\nstatic void process_command_flags(struct cardstate *cs)\r\n{\r\nstruct at_state_t *at_state = NULL;\r\nstruct bc_state *bcs;\r\nint i;\r\nint sequence;\r\nunsigned long flags;\r\ncs->commands_pending = 0;\r\nif (cs->cur_at_seq) {\r\ngig_dbg(DEBUG_EVENT, "not searching scheduled commands: busy");\r\nreturn;\r\n}\r\ngig_dbg(DEBUG_EVENT, "searching scheduled commands");\r\nsequence = SEQ_NONE;\r\nif (cs->at_state.pending_commands & PC_SHUTDOWN) {\r\ncs->at_state.pending_commands &= ~PC_CIDMODE;\r\nfor (i = 0; i < cs->channels; ++i) {\r\nbcs = cs->bcs + i;\r\nat_state = &bcs->at_state;\r\nat_state->pending_commands &=\r\n~(PC_DLE1 | PC_ACCEPT | PC_DIAL);\r\nif (at_state->cid > 0)\r\nat_state->pending_commands |= PC_HUP;\r\nif (at_state->pending_commands & PC_CID) {\r\nat_state->pending_commands |= PC_NOCID;\r\nat_state->pending_commands &= ~PC_CID;\r\n}\r\n}\r\n}\r\nif (cs->at_state.pending_commands & PC_INIT) {\r\ncs->at_state.pending_commands &= ~PC_CIDMODE;\r\nfor (i = 0; i < cs->channels; ++i) {\r\nbcs = cs->bcs + i;\r\nat_state = &bcs->at_state;\r\nat_state->pending_commands &=\r\n~(PC_DLE1 | PC_ACCEPT | PC_DIAL);\r\nif (at_state->cid > 0)\r\nat_state->pending_commands |= PC_HUP;\r\nif (cs->mstate == MS_RECOVER) {\r\nif (at_state->pending_commands & PC_CID) {\r\nat_state->pending_commands |= PC_NOCID;\r\nat_state->pending_commands &= ~PC_CID;\r\n}\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->at_state.pending_commands == PC_UMMODE\r\n&& !cs->cidmode\r\n&& list_empty(&cs->temp_at_states)\r\n&& cs->mode == M_CID) {\r\nsequence = SEQ_UMMODE;\r\nat_state = &cs->at_state;\r\nfor (i = 0; i < cs->channels; ++i) {\r\nbcs = cs->bcs + i;\r\nif (bcs->at_state.pending_commands ||\r\nbcs->at_state.cid > 0) {\r\nsequence = SEQ_NONE;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ncs->at_state.pending_commands &= ~PC_UMMODE;\r\nif (sequence != SEQ_NONE) {\r\nschedule_sequence(cs, at_state, sequence);\r\nreturn;\r\n}\r\nfor (i = 0; i < cs->channels; ++i) {\r\nbcs = cs->bcs + i;\r\nif (bcs->at_state.pending_commands & PC_HUP) {\r\nbcs->at_state.pending_commands &= ~PC_HUP;\r\nif (bcs->at_state.pending_commands & PC_CID) {\r\nbcs->at_state.pending_commands |= PC_NOCID;\r\nbcs->at_state.pending_commands &= ~PC_CID;\r\n} else {\r\nschedule_sequence(cs, &bcs->at_state, SEQ_HUP);\r\nreturn;\r\n}\r\n}\r\nif (bcs->at_state.pending_commands & PC_NOCID) {\r\nbcs->at_state.pending_commands &= ~PC_NOCID;\r\ncs->curchannel = bcs->channel;\r\nschedule_sequence(cs, &cs->at_state, SEQ_NOCID);\r\nreturn;\r\n} else if (bcs->at_state.pending_commands & PC_DLE0) {\r\nbcs->at_state.pending_commands &= ~PC_DLE0;\r\ncs->curchannel = bcs->channel;\r\nschedule_sequence(cs, &cs->at_state, SEQ_DLE0);\r\nreturn;\r\n}\r\n}\r\nlist_for_each_entry(at_state, &cs->temp_at_states, list)\r\nif (at_state->pending_commands & PC_HUP) {\r\nat_state->pending_commands &= ~PC_HUP;\r\nschedule_sequence(cs, at_state, SEQ_HUP);\r\nreturn;\r\n}\r\nif (cs->at_state.pending_commands & PC_INIT) {\r\ncs->at_state.pending_commands &= ~PC_INIT;\r\ncs->dle = 0;\r\ncs->inbuf->inputstate = INS_command;\r\nschedule_sequence(cs, &cs->at_state, SEQ_INIT);\r\nreturn;\r\n}\r\nif (cs->at_state.pending_commands & PC_SHUTDOWN) {\r\ncs->at_state.pending_commands &= ~PC_SHUTDOWN;\r\nschedule_sequence(cs, &cs->at_state, SEQ_SHUTDOWN);\r\nreturn;\r\n}\r\nif (cs->at_state.pending_commands & PC_CIDMODE) {\r\ncs->at_state.pending_commands &= ~PC_CIDMODE;\r\nif (cs->mode == M_UNIMODEM) {\r\ncs->retry_count = 1;\r\nschedule_sequence(cs, &cs->at_state, SEQ_CIDMODE);\r\nreturn;\r\n}\r\n}\r\nfor (i = 0; i < cs->channels; ++i) {\r\nbcs = cs->bcs + i;\r\nif (bcs->at_state.pending_commands & PC_DLE1) {\r\nbcs->at_state.pending_commands &= ~PC_DLE1;\r\ncs->curchannel = bcs->channel;\r\nschedule_sequence(cs, &cs->at_state, SEQ_DLE1);\r\nreturn;\r\n}\r\nif (bcs->at_state.pending_commands & PC_ACCEPT) {\r\nbcs->at_state.pending_commands &= ~PC_ACCEPT;\r\nschedule_sequence(cs, &bcs->at_state, SEQ_ACCEPT);\r\nreturn;\r\n}\r\nif (bcs->at_state.pending_commands & PC_DIAL) {\r\nbcs->at_state.pending_commands &= ~PC_DIAL;\r\nschedule_sequence(cs, &bcs->at_state, SEQ_DIAL);\r\nreturn;\r\n}\r\nif (bcs->at_state.pending_commands & PC_CID) {\r\nswitch (cs->mode) {\r\ncase M_UNIMODEM:\r\ncs->at_state.pending_commands |= PC_CIDMODE;\r\ngig_dbg(DEBUG_EVENT, "Scheduling PC_CIDMODE");\r\ncs->commands_pending = 1;\r\nreturn;\r\ncase M_UNKNOWN:\r\nschedule_init(cs, MS_INIT);\r\nreturn;\r\n}\r\nbcs->at_state.pending_commands &= ~PC_CID;\r\ncs->curchannel = bcs->channel;\r\ncs->retry_count = 2;\r\nschedule_sequence(cs, &cs->at_state, SEQ_CID);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void process_events(struct cardstate *cs)\r\n{\r\nstruct event_t *ev;\r\nunsigned head, tail;\r\nint i;\r\nint check_flags = 0;\r\nint was_busy;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cs->ev_lock, flags);\r\nhead = cs->ev_head;\r\nfor (i = 0; i < 2 * MAX_EVENTS; ++i) {\r\ntail = cs->ev_tail;\r\nif (tail == head) {\r\nif (!check_flags && !cs->commands_pending)\r\nbreak;\r\ncheck_flags = 0;\r\nspin_unlock_irqrestore(&cs->ev_lock, flags);\r\nprocess_command_flags(cs);\r\nspin_lock_irqsave(&cs->ev_lock, flags);\r\ntail = cs->ev_tail;\r\nif (tail == head) {\r\nif (!cs->commands_pending)\r\nbreak;\r\ncontinue;\r\n}\r\n}\r\nev = cs->events + head;\r\nwas_busy = cs->cur_at_seq != SEQ_NONE;\r\nspin_unlock_irqrestore(&cs->ev_lock, flags);\r\nprocess_event(cs, ev);\r\nspin_lock_irqsave(&cs->ev_lock, flags);\r\nkfree(ev->ptr);\r\nev->ptr = NULL;\r\nif (was_busy && cs->cur_at_seq == SEQ_NONE)\r\ncheck_flags = 1;\r\nhead = (head + 1) % MAX_EVENTS;\r\ncs->ev_head = head;\r\n}\r\nspin_unlock_irqrestore(&cs->ev_lock, flags);\r\nif (i == 2 * MAX_EVENTS) {\r\ndev_err(cs->dev,\r\n"infinite loop in process_events; aborting.\n");\r\n}\r\n}\r\nvoid gigaset_handle_event(unsigned long data)\r\n{\r\nstruct cardstate *cs = (struct cardstate *) data;\r\nif (cs->inbuf->head != cs->inbuf->tail) {\r\ngig_dbg(DEBUG_INTR, "processing new data");\r\ncs->ops->handle_input(cs->inbuf);\r\n}\r\nprocess_events(cs);\r\n}
