static int call_home_on_panic(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\nstrncat(data, init_utsname()->nodename,\r\nsizeof(init_utsname()->nodename));\r\nsclp_async_send_wait(data);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int proc_handler_callhome(struct ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *count,\r\nloff_t *ppos)\r\n{\r\nunsigned long val;\r\nint len, rc;\r\nchar buf[3];\r\nif (!*count || (*ppos && !write)) {\r\n*count = 0;\r\nreturn 0;\r\n}\r\nif (!write) {\r\nlen = snprintf(buf, sizeof(buf), "%d\n", callhome_enabled);\r\nrc = copy_to_user(buffer, buf, sizeof(buf));\r\nif (rc != 0)\r\nreturn -EFAULT;\r\n} else {\r\nlen = *count;\r\nrc = kstrtoul_from_user(buffer, len, 0, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val != 0 && val != 1)\r\nreturn -EINVAL;\r\ncallhome_enabled = val;\r\n}\r\n*count = len;\r\n*ppos += len;\r\nreturn 0;\r\n}\r\nstatic int sclp_async_send_wait(char *message)\r\n{\r\nstruct async_evbuf *evb;\r\nint rc;\r\nunsigned long flags;\r\nif (!callhome_enabled)\r\nreturn 0;\r\nsccb->evbuf.header.type = EVTYP_ASYNC;\r\nsccb->evbuf.rtype = 0xA5;\r\nsccb->evbuf.otype = 0x00;\r\nevb = &sccb->evbuf;\r\nrequest->command = SCLP_CMDW_WRITE_EVENT_DATA;\r\nrequest->sccb = sccb;\r\nrequest->status = SCLP_REQ_FILLED;\r\nstrncpy(sccb->evbuf.data, message, sizeof(sccb->evbuf.data));\r\nstrncpy(sccb->evbuf.comp_id, "000000000", sizeof(sccb->evbuf.comp_id));\r\nsccb->evbuf.header.length = sizeof(sccb->evbuf);\r\nsccb->header.length = sizeof(sccb->evbuf) + sizeof(sccb->header);\r\nsccb->header.function_code = SCLP_NORMAL_WRITE;\r\nrc = sclp_add_request(request);\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&sclp_async_lock, flags);\r\nwhile (request->status != SCLP_REQ_DONE &&\r\nrequest->status != SCLP_REQ_FAILED) {\r\nsclp_sync_wait();\r\n}\r\nspin_unlock_irqrestore(&sclp_async_lock, flags);\r\nif (request->status != SCLP_REQ_DONE)\r\nreturn -EIO;\r\nrc = ((struct sclp_async_sccb *)\r\nrequest->sccb)->header.response_code;\r\nif (rc != 0x0020)\r\nreturn -EIO;\r\nif (evb->header.flags != 0x80)\r\nreturn -EIO;\r\nreturn rc;\r\n}\r\nstatic int __init sclp_async_init(void)\r\n{\r\nint rc;\r\nrc = sclp_register(&sclp_async_register);\r\nif (rc)\r\nreturn rc;\r\nrc = -EOPNOTSUPP;\r\nif (!(sclp_async_register.sclp_receive_mask & EVTYP_ASYNC_MASK))\r\ngoto out_sclp;\r\nrc = -ENOMEM;\r\ncallhome_sysctl_header = register_sysctl_table(kern_dir_table);\r\nif (!callhome_sysctl_header)\r\ngoto out_sclp;\r\nrequest = kzalloc(sizeof(struct sclp_req), GFP_KERNEL);\r\nsccb = (struct sclp_async_sccb *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!request || !sccb)\r\ngoto out_mem;\r\nrc = atomic_notifier_chain_register(&panic_notifier_list,\r\n&call_home_panic_nb);\r\nif (!rc)\r\ngoto out;\r\nout_mem:\r\nkfree(request);\r\nfree_page((unsigned long) sccb);\r\nunregister_sysctl_table(callhome_sysctl_header);\r\nout_sclp:\r\nsclp_unregister(&sclp_async_register);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit sclp_async_exit(void)\r\n{\r\natomic_notifier_chain_unregister(&panic_notifier_list,\r\n&call_home_panic_nb);\r\nunregister_sysctl_table(callhome_sysctl_header);\r\nsclp_unregister(&sclp_async_register);\r\nfree_page((unsigned long) sccb);\r\nkfree(request);\r\n}
