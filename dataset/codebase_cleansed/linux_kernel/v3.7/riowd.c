static void riowd_writereg(struct riowd *p, u8 val, int index)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->lock, flags);\r\nwriteb(index, p->regs + 0);\r\nwriteb(val, p->regs + 1);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic int riowd_open(struct inode *inode, struct file *filp)\r\n{\r\nnonseekable_open(inode, filp);\r\nreturn 0;\r\n}\r\nstatic int riowd_release(struct inode *inode, struct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic long riowd_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nstatic const struct watchdog_info info = {\r\n.options = WDIOF_SETTIMEOUT,\r\n.firmware_version = 1,\r\n.identity = DRIVER_NAME,\r\n};\r\nvoid __user *argp = (void __user *)arg;\r\nstruct riowd *p = riowd_device;\r\nunsigned int options;\r\nint new_margin;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nif (put_user(0, (int __user *)argp))\r\nreturn -EFAULT;\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nriowd_writereg(p, riowd_timeout, WDTO_INDEX);\r\nbreak;\r\ncase WDIOC_SETOPTIONS:\r\nif (copy_from_user(&options, argp, sizeof(options)))\r\nreturn -EFAULT;\r\nif (options & WDIOS_DISABLECARD)\r\nriowd_writereg(p, 0, WDTO_INDEX);\r\nelse if (options & WDIOS_ENABLECARD)\r\nriowd_writereg(p, riowd_timeout, WDTO_INDEX);\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_margin, (int __user *)argp))\r\nreturn -EFAULT;\r\nif ((new_margin < 60) || (new_margin > (255 * 60)))\r\nreturn -EINVAL;\r\nriowd_timeout = (new_margin + 59) / 60;\r\nriowd_writereg(p, riowd_timeout, WDTO_INDEX);\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(riowd_timeout * 60, (int __user *)argp);\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\nreturn 0;\r\n}\r\nstatic ssize_t riowd_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct riowd *p = riowd_device;\r\nif (count) {\r\nriowd_writereg(p, riowd_timeout, WDTO_INDEX);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit riowd_probe(struct platform_device *op)\r\n{\r\nstruct riowd *p;\r\nint err = -EINVAL;\r\nif (riowd_device)\r\ngoto out;\r\nerr = -ENOMEM;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\ngoto out;\r\nspin_lock_init(&p->lock);\r\np->regs = of_ioremap(&op->resource[0], 0, 2, DRIVER_NAME);\r\nif (!p->regs) {\r\npr_err("Cannot map registers\n");\r\ngoto out_free;\r\n}\r\nriowd_device = p;\r\nerr = misc_register(&riowd_miscdev);\r\nif (err) {\r\npr_err("Cannot register watchdog misc device\n");\r\ngoto out_iounmap;\r\n}\r\npr_info("Hardware watchdog [%i minutes], regs at %p\n",\r\nriowd_timeout, p->regs);\r\ndev_set_drvdata(&op->dev, p);\r\nreturn 0;\r\nout_iounmap:\r\nriowd_device = NULL;\r\nof_iounmap(&op->resource[0], p->regs, 2);\r\nout_free:\r\nkfree(p);\r\nout:\r\nreturn err;\r\n}\r\nstatic int __devexit riowd_remove(struct platform_device *op)\r\n{\r\nstruct riowd *p = dev_get_drvdata(&op->dev);\r\nmisc_deregister(&riowd_miscdev);\r\nof_iounmap(&op->resource[0], p->regs, 2);\r\nkfree(p);\r\nreturn 0;\r\n}
