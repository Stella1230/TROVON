static void\r\n#ifdef HFC_REGISTER_DEBUG\r\nHFC_outb_pcimem(struct hfc_multi *hc, u_char reg, u_char val,\r\nconst char *function, int line)\r\n#else\r\nHFC_outb_pcimem(struct hfc_multi *hc, u_char reg, u_char val)\r\n#endif\r\n{\r\nwriteb(val, hc->pci_membase + reg);\r\n}\r\nstatic u_char\r\n#ifdef HFC_REGISTER_DEBUG\r\nHFC_inb_pcimem(struct hfc_multi *hc, u_char reg, const char *function, int line)\r\n#else\r\nHFC_inb_pcimem(struct hfc_multi *hc, u_char reg)\r\n#endif\r\n{\r\nreturn readb(hc->pci_membase + reg);\r\n}\r\nstatic u_short\r\n#ifdef HFC_REGISTER_DEBUG\r\nHFC_inw_pcimem(struct hfc_multi *hc, u_char reg, const char *function, int line)\r\n#else\r\nHFC_inw_pcimem(struct hfc_multi *hc, u_char reg)\r\n#endif\r\n{\r\nreturn readw(hc->pci_membase + reg);\r\n}\r\nstatic void\r\n#ifdef HFC_REGISTER_DEBUG\r\nHFC_wait_pcimem(struct hfc_multi *hc, const char *function, int line)\r\n#else\r\nHFC_wait_pcimem(struct hfc_multi *hc)\r\n#endif\r\n{\r\nwhile (readb(hc->pci_membase + R_STATUS) & V_BUSY)\r\ncpu_relax();\r\n}\r\nstatic void\r\n#ifdef HFC_REGISTER_DEBUG\r\nHFC_outb_regio(struct hfc_multi *hc, u_char reg, u_char val,\r\nconst char *function, int line)\r\n#else\r\nHFC_outb_regio(struct hfc_multi *hc, u_char reg, u_char val)\r\n#endif\r\n{\r\noutb(reg, hc->pci_iobase + 4);\r\noutb(val, hc->pci_iobase);\r\n}\r\nstatic u_char\r\n#ifdef HFC_REGISTER_DEBUG\r\nHFC_inb_regio(struct hfc_multi *hc, u_char reg, const char *function, int line)\r\n#else\r\nHFC_inb_regio(struct hfc_multi *hc, u_char reg)\r\n#endif\r\n{\r\noutb(reg, hc->pci_iobase + 4);\r\nreturn inb(hc->pci_iobase);\r\n}\r\nstatic u_short\r\n#ifdef HFC_REGISTER_DEBUG\r\nHFC_inw_regio(struct hfc_multi *hc, u_char reg, const char *function, int line)\r\n#else\r\nHFC_inw_regio(struct hfc_multi *hc, u_char reg)\r\n#endif\r\n{\r\noutb(reg, hc->pci_iobase + 4);\r\nreturn inw(hc->pci_iobase);\r\n}\r\nstatic void\r\n#ifdef HFC_REGISTER_DEBUG\r\nHFC_wait_regio(struct hfc_multi *hc, const char *function, int line)\r\n#else\r\nHFC_wait_regio(struct hfc_multi *hc)\r\n#endif\r\n{\r\noutb(R_STATUS, hc->pci_iobase + 4);\r\nwhile (inb(hc->pci_iobase) & V_BUSY)\r\ncpu_relax();\r\n}\r\nstatic void\r\nHFC_outb_debug(struct hfc_multi *hc, u_char reg, u_char val,\r\nconst char *function, int line)\r\n{\r\nchar regname[256] = "", bits[9] = "xxxxxxxx";\r\nint i;\r\ni = -1;\r\nwhile (hfc_register_names[++i].name) {\r\nif (hfc_register_names[i].reg == reg)\r\nstrcat(regname, hfc_register_names[i].name);\r\n}\r\nif (regname[0] == '\0')\r\nstrcpy(regname, "register");\r\nbits[7] = '0' + (!!(val & 1));\r\nbits[6] = '0' + (!!(val & 2));\r\nbits[5] = '0' + (!!(val & 4));\r\nbits[4] = '0' + (!!(val & 8));\r\nbits[3] = '0' + (!!(val & 16));\r\nbits[2] = '0' + (!!(val & 32));\r\nbits[1] = '0' + (!!(val & 64));\r\nbits[0] = '0' + (!!(val & 128));\r\nprintk(KERN_DEBUG\r\n"HFC_outb(chip %d, %02x=%s, 0x%02x=%s); in %s() line %d\n",\r\nhc->id, reg, regname, val, bits, function, line);\r\nHFC_outb_nodebug(hc, reg, val);\r\n}\r\nstatic u_char\r\nHFC_inb_debug(struct hfc_multi *hc, u_char reg, const char *function, int line)\r\n{\r\nchar regname[256] = "", bits[9] = "xxxxxxxx";\r\nu_char val = HFC_inb_nodebug(hc, reg);\r\nint i;\r\ni = 0;\r\nwhile (hfc_register_names[i++].name)\r\n;\r\nwhile (hfc_register_names[++i].name) {\r\nif (hfc_register_names[i].reg == reg)\r\nstrcat(regname, hfc_register_names[i].name);\r\n}\r\nif (regname[0] == '\0')\r\nstrcpy(regname, "register");\r\nbits[7] = '0' + (!!(val & 1));\r\nbits[6] = '0' + (!!(val & 2));\r\nbits[5] = '0' + (!!(val & 4));\r\nbits[4] = '0' + (!!(val & 8));\r\nbits[3] = '0' + (!!(val & 16));\r\nbits[2] = '0' + (!!(val & 32));\r\nbits[1] = '0' + (!!(val & 64));\r\nbits[0] = '0' + (!!(val & 128));\r\nprintk(KERN_DEBUG\r\n"HFC_inb(chip %d, %02x=%s) = 0x%02x=%s; in %s() line %d\n",\r\nhc->id, reg, regname, val, bits, function, line);\r\nreturn val;\r\n}\r\nstatic u_short\r\nHFC_inw_debug(struct hfc_multi *hc, u_char reg, const char *function, int line)\r\n{\r\nchar regname[256] = "";\r\nu_short val = HFC_inw_nodebug(hc, reg);\r\nint i;\r\ni = 0;\r\nwhile (hfc_register_names[i++].name)\r\n;\r\nwhile (hfc_register_names[++i].name) {\r\nif (hfc_register_names[i].reg == reg)\r\nstrcat(regname, hfc_register_names[i].name);\r\n}\r\nif (regname[0] == '\0')\r\nstrcpy(regname, "register");\r\nprintk(KERN_DEBUG\r\n"HFC_inw(chip %d, %02x=%s) = 0x%04x; in %s() line %d\n",\r\nhc->id, reg, regname, val, function, line);\r\nreturn val;\r\n}\r\nstatic void\r\nHFC_wait_debug(struct hfc_multi *hc, const char *function, int line)\r\n{\r\nprintk(KERN_DEBUG "HFC_wait(chip %d); in %s() line %d\n",\r\nhc->id, function, line);\r\nHFC_wait_nodebug(hc);\r\n}\r\nstatic void\r\nwrite_fifo_regio(struct hfc_multi *hc, u_char *data, int len)\r\n{\r\noutb(A_FIFO_DATA0, (hc->pci_iobase) + 4);\r\nwhile (len >> 2) {\r\noutl(cpu_to_le32(*(u32 *)data), hc->pci_iobase);\r\ndata += 4;\r\nlen -= 4;\r\n}\r\nwhile (len >> 1) {\r\noutw(cpu_to_le16(*(u16 *)data), hc->pci_iobase);\r\ndata += 2;\r\nlen -= 2;\r\n}\r\nwhile (len) {\r\noutb(*data, hc->pci_iobase);\r\ndata++;\r\nlen--;\r\n}\r\n}\r\nstatic void\r\nwrite_fifo_pcimem(struct hfc_multi *hc, u_char *data, int len)\r\n{\r\nwhile (len >> 2) {\r\nwritel(cpu_to_le32(*(u32 *)data),\r\nhc->pci_membase + A_FIFO_DATA0);\r\ndata += 4;\r\nlen -= 4;\r\n}\r\nwhile (len >> 1) {\r\nwritew(cpu_to_le16(*(u16 *)data),\r\nhc->pci_membase + A_FIFO_DATA0);\r\ndata += 2;\r\nlen -= 2;\r\n}\r\nwhile (len) {\r\nwriteb(*data, hc->pci_membase + A_FIFO_DATA0);\r\ndata++;\r\nlen--;\r\n}\r\n}\r\nstatic void\r\nread_fifo_regio(struct hfc_multi *hc, u_char *data, int len)\r\n{\r\noutb(A_FIFO_DATA0, (hc->pci_iobase) + 4);\r\nwhile (len >> 2) {\r\n*(u32 *)data = le32_to_cpu(inl(hc->pci_iobase));\r\ndata += 4;\r\nlen -= 4;\r\n}\r\nwhile (len >> 1) {\r\n*(u16 *)data = le16_to_cpu(inw(hc->pci_iobase));\r\ndata += 2;\r\nlen -= 2;\r\n}\r\nwhile (len) {\r\n*data = inb(hc->pci_iobase);\r\ndata++;\r\nlen--;\r\n}\r\n}\r\nstatic void\r\nread_fifo_pcimem(struct hfc_multi *hc, u_char *data, int len)\r\n{\r\nwhile (len >> 2) {\r\n*(u32 *)data =\r\nle32_to_cpu(readl(hc->pci_membase + A_FIFO_DATA0));\r\ndata += 4;\r\nlen -= 4;\r\n}\r\nwhile (len >> 1) {\r\n*(u16 *)data =\r\nle16_to_cpu(readw(hc->pci_membase + A_FIFO_DATA0));\r\ndata += 2;\r\nlen -= 2;\r\n}\r\nwhile (len) {\r\n*data = readb(hc->pci_membase + A_FIFO_DATA0);\r\ndata++;\r\nlen--;\r\n}\r\n}\r\nstatic void\r\nenable_hwirq(struct hfc_multi *hc)\r\n{\r\nhc->hw.r_irq_ctrl |= V_GLOB_IRQ_EN;\r\nHFC_outb(hc, R_IRQ_CTRL, hc->hw.r_irq_ctrl);\r\n}\r\nstatic void\r\ndisable_hwirq(struct hfc_multi *hc)\r\n{\r\nhc->hw.r_irq_ctrl &= ~((u_char)V_GLOB_IRQ_EN);\r\nHFC_outb(hc, R_IRQ_CTRL, hc->hw.r_irq_ctrl);\r\n}\r\ninline void\r\nenablepcibridge(struct hfc_multi *c)\r\n{\r\nHFC_outb(c, R_BRG_PCM_CFG, (0x0 << 6) | 0x3);\r\n}\r\ninline void\r\ndisablepcibridge(struct hfc_multi *c)\r\n{\r\nHFC_outb(c, R_BRG_PCM_CFG, (0x0 << 6) | 0x2);\r\n}\r\ninline unsigned char\r\nreadpcibridge(struct hfc_multi *hc, unsigned char address)\r\n{\r\nunsigned short cipv;\r\nunsigned char data;\r\nif (!hc->pci_iobase)\r\nreturn 0;\r\nHFC_outb(hc, R_CTRL, 0x4);\r\nif (address == 0)\r\ncipv = 0x4000;\r\nelse\r\ncipv = 0x5800;\r\noutw(cipv, hc->pci_iobase + 4);\r\ndata = inb(hc->pci_iobase);\r\nHFC_outb(hc, R_CTRL, 0x0);\r\nreturn data;\r\n}\r\ninline void\r\nwritepcibridge(struct hfc_multi *hc, unsigned char address, unsigned char data)\r\n{\r\nunsigned short cipv;\r\nunsigned int datav;\r\nif (!hc->pci_iobase)\r\nreturn;\r\nif (address == 0)\r\ncipv = 0x4000;\r\nelse\r\ncipv = 0x5800;\r\noutw(cipv, hc->pci_iobase + 4);\r\ndatav = data | ((__u32) data << 8) | ((__u32) data << 16) |\r\n((__u32) data << 24);\r\noutl(datav, hc->pci_iobase);\r\n}\r\ninline void\r\ncpld_set_reg(struct hfc_multi *hc, unsigned char reg)\r\n{\r\nHFC_outb(hc, R_GPIO_OUT1, reg);\r\n}\r\ninline void\r\ncpld_write_reg(struct hfc_multi *hc, unsigned char reg, unsigned char val)\r\n{\r\ncpld_set_reg(hc, reg);\r\nenablepcibridge(hc);\r\nwritepcibridge(hc, 1, val);\r\ndisablepcibridge(hc);\r\nreturn;\r\n}\r\ninline unsigned char\r\ncpld_read_reg(struct hfc_multi *hc, unsigned char reg)\r\n{\r\nunsigned char bytein;\r\ncpld_set_reg(hc, reg);\r\nHFC_outb(hc, R_GPIO_OUT1, reg);\r\nenablepcibridge(hc);\r\nbytein = readpcibridge(hc, 1);\r\ndisablepcibridge(hc);\r\nreturn bytein;\r\n}\r\ninline void\r\nvpm_write_address(struct hfc_multi *hc, unsigned short addr)\r\n{\r\ncpld_write_reg(hc, 0, 0xff & addr);\r\ncpld_write_reg(hc, 1, 0x01 & (addr >> 8));\r\n}\r\ninline unsigned short\r\nvpm_read_address(struct hfc_multi *c)\r\n{\r\nunsigned short addr;\r\nunsigned short highbit;\r\naddr = cpld_read_reg(c, 0);\r\nhighbit = cpld_read_reg(c, 1);\r\naddr = addr | (highbit << 8);\r\nreturn addr & 0x1ff;\r\n}\r\ninline unsigned char\r\nvpm_in(struct hfc_multi *c, int which, unsigned short addr)\r\n{\r\nunsigned char res;\r\nvpm_write_address(c, addr);\r\nif (!which)\r\ncpld_set_reg(c, 2);\r\nelse\r\ncpld_set_reg(c, 3);\r\nenablepcibridge(c);\r\nres = readpcibridge(c, 1);\r\ndisablepcibridge(c);\r\ncpld_set_reg(c, 0);\r\nreturn res;\r\n}\r\ninline void\r\nvpm_out(struct hfc_multi *c, int which, unsigned short addr,\r\nunsigned char data)\r\n{\r\nvpm_write_address(c, addr);\r\nenablepcibridge(c);\r\nif (!which)\r\ncpld_set_reg(c, 2);\r\nelse\r\ncpld_set_reg(c, 3);\r\nwritepcibridge(c, 1, data);\r\ncpld_set_reg(c, 0);\r\ndisablepcibridge(c);\r\n{\r\nunsigned char regin;\r\nregin = vpm_in(c, which, addr);\r\nif (regin != data)\r\nprintk(KERN_DEBUG "Wrote 0x%x to register 0x%x but got back "\r\n"0x%x\n", data, addr, regin);\r\n}\r\n}\r\nstatic void\r\nvpm_init(struct hfc_multi *wc)\r\n{\r\nunsigned char reg;\r\nunsigned int mask;\r\nunsigned int i, x, y;\r\nunsigned int ver;\r\nfor (x = 0; x < NUM_EC; x++) {\r\nif (!x) {\r\nver = vpm_in(wc, x, 0x1a0);\r\nprintk(KERN_DEBUG "VPM: Chip %d: ver %02x\n", x, ver);\r\n}\r\nfor (y = 0; y < 4; y++) {\r\nvpm_out(wc, x, 0x1a8 + y, 0x00);\r\nvpm_out(wc, x, 0x1ac + y, 0x00);\r\nvpm_out(wc, x, 0x1b0 + y, 0x00);\r\n}\r\nreg = vpm_in(wc, x, 0x1a3);\r\nvpm_out(wc, x, 0x1a3, reg & ~2);\r\nvpm_out(wc, x, 0x022, 1);\r\nvpm_out(wc, x, 0x023, 0xff);\r\nvpm_out(wc, x, 0x02f, 0x00);\r\nmask = 0x02020202 << (x * 4);\r\nfor (i = 0; i < 4; i++)\r\nvpm_out(wc, x, 0x33 - i, (mask >> (i << 3)) & 0xff);\r\nprintk(KERN_DEBUG "VPM: A-law mode\n");\r\nreg = 0x00 | 0x10 | 0x01;\r\nvpm_out(wc, x, 0x20, reg);\r\nprintk(KERN_DEBUG "VPM reg 0x20 is %x\n", reg);\r\nvpm_out(wc, x, 0x24, 0x02);\r\nreg = vpm_in(wc, x, 0x24);\r\nprintk(KERN_DEBUG "NLP Thresh is set to %d (0x%x)\n", reg, reg);\r\nfor (i = 0; i < MAX_TDM_CHAN; i++) {\r\nif (mask & (0x00000001 << i))\r\nvpm_out(wc, x, i, 0x00);\r\n}\r\nudelay(2000);\r\nudelay(2000);\r\nudelay(2000);\r\nudelay(2000);\r\nudelay(2000);\r\nfor (i = 0; i < MAX_TDM_CHAN; i++) {\r\nif (mask & (0x00000001 << i))\r\nvpm_out(wc, x, i, 0x01);\r\n}\r\nfor (i = 0; i < MAX_TDM_CHAN; i++) {\r\nif (mask & (0x00000001 << i))\r\nvpm_out(wc, x, 0x78 + i, 0x01);\r\n}\r\n}\r\n}\r\nstatic void\r\nvpm_check(struct hfc_multi *hctmp)\r\n{\r\nunsigned char gpi2;\r\ngpi2 = HFC_inb(hctmp, R_GPI_IN2);\r\nif ((gpi2 & 0x3) != 0x3)\r\nprintk(KERN_DEBUG "Got interrupt 0x%x from VPM!\n", gpi2);\r\n}\r\nstatic void\r\nvpm_echocan_on(struct hfc_multi *hc, int ch, int taps)\r\n{\r\nunsigned int timeslot;\r\nunsigned int unit;\r\nstruct bchannel *bch = hc->chan[ch].bch;\r\n#ifdef TXADJ\r\nint txadj = -4;\r\nstruct sk_buff *skb;\r\n#endif\r\nif (hc->chan[ch].protocol != ISDN_P_B_RAW)\r\nreturn;\r\nif (!bch)\r\nreturn;\r\n#ifdef TXADJ\r\nskb = _alloc_mISDN_skb(PH_CONTROL_IND, HFC_VOL_CHANGE_TX,\r\nsizeof(int), &txadj, GFP_ATOMIC);\r\nif (skb)\r\nrecv_Bchannel_skb(bch, skb);\r\n#endif\r\ntimeslot = ((ch / 4) * 8) + ((ch % 4) * 4) + 1;\r\nunit = ch % 4;\r\nprintk(KERN_NOTICE "vpm_echocan_on called taps [%d] on timeslot %d\n",\r\ntaps, timeslot);\r\nvpm_out(hc, unit, timeslot, 0x7e);\r\n}\r\nstatic void\r\nvpm_echocan_off(struct hfc_multi *hc, int ch)\r\n{\r\nunsigned int timeslot;\r\nunsigned int unit;\r\nstruct bchannel *bch = hc->chan[ch].bch;\r\n#ifdef TXADJ\r\nint txadj = 0;\r\nstruct sk_buff *skb;\r\n#endif\r\nif (hc->chan[ch].protocol != ISDN_P_B_RAW)\r\nreturn;\r\nif (!bch)\r\nreturn;\r\n#ifdef TXADJ\r\nskb = _alloc_mISDN_skb(PH_CONTROL_IND, HFC_VOL_CHANGE_TX,\r\nsizeof(int), &txadj, GFP_ATOMIC);\r\nif (skb)\r\nrecv_Bchannel_skb(bch, skb);\r\n#endif\r\ntimeslot = ((ch / 4) * 8) + ((ch % 4) * 4) + 1;\r\nunit = ch % 4;\r\nprintk(KERN_NOTICE "vpm_echocan_off called on timeslot %d\n",\r\ntimeslot);\r\nvpm_out(hc, unit, timeslot, 0x01);\r\n}\r\nstatic inline void\r\nhfcmulti_resync(struct hfc_multi *locked, struct hfc_multi *newmaster, int rm)\r\n{\r\nstruct hfc_multi *hc, *next, *pcmmaster = NULL;\r\nvoid __iomem *plx_acc_32;\r\nu_int pv;\r\nu_long flags;\r\nspin_lock_irqsave(&HFClock, flags);\r\nspin_lock(&plx_lock);\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG "%s: RESYNC(syncmaster=0x%p)\n",\r\n__func__, syncmaster);\r\nif (newmaster) {\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG "using provided controller\n");\r\n} else {\r\nlist_for_each_entry_safe(hc, next, &HFClist, list) {\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nif (hc->syncronized) {\r\nnewmaster = hc;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nlist_for_each_entry_safe(hc, next, &HFClist, list) {\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nplx_acc_32 = hc->plx_membase + PLX_GPIOC;\r\npv = readl(plx_acc_32);\r\npv &= ~PLX_SYNC_O_EN;\r\nwritel(pv, plx_acc_32);\r\nif (test_bit(HFC_CHIP_PCM_MASTER, &hc->chip)) {\r\npcmmaster = hc;\r\nif (hc->ctype == HFC_TYPE_E1) {\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG\r\n"Schedule SYNC_I\n");\r\nhc->e1_resync |= 1;\r\n}\r\n}\r\n}\r\n}\r\nif (newmaster) {\r\nhc = newmaster;\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG "id=%d (0x%p) = syncronized with "\r\n"interface.\n", hc->id, hc);\r\nplx_acc_32 = hc->plx_membase + PLX_GPIOC;\r\npv = readl(plx_acc_32);\r\npv |= PLX_SYNC_O_EN;\r\nwritel(pv, plx_acc_32);\r\nif (hc->ctype == HFC_TYPE_E1\r\n&& !test_bit(HFC_CHIP_RX_SYNC, &hc->chip)) {\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG "Schedule jatt PLL\n");\r\nhc->e1_resync |= 2;\r\n}\r\n} else {\r\nif (pcmmaster) {\r\nhc = pcmmaster;\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG\r\n"id=%d (0x%p) = PCM master syncronized "\r\n"with QUARTZ\n", hc->id, hc);\r\nif (hc->ctype == HFC_TYPE_E1) {\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG\r\n"Schedule QUARTZ for HFC-E1\n");\r\nhc->e1_resync |= 4;\r\n} else {\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG\r\n"QUARTZ is automatically "\r\n"enabled by HFC-%dS\n", hc->ctype);\r\n}\r\nplx_acc_32 = hc->plx_membase + PLX_GPIOC;\r\npv = readl(plx_acc_32);\r\npv |= PLX_SYNC_O_EN;\r\nwritel(pv, plx_acc_32);\r\n} else\r\nif (!rm)\r\nprintk(KERN_ERR "%s no pcm master, this MUST "\r\n"not happen!\n", __func__);\r\n}\r\nsyncmaster = newmaster;\r\nspin_unlock(&plx_lock);\r\nspin_unlock_irqrestore(&HFClock, flags);\r\n}\r\ninline void\r\nplxsd_checksync(struct hfc_multi *hc, int rm)\r\n{\r\nif (hc->syncronized) {\r\nif (syncmaster == NULL) {\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG "%s: GOT sync on card %d"\r\n" (id=%d)\n", __func__, hc->id + 1,\r\nhc->id);\r\nhfcmulti_resync(hc, hc, rm);\r\n}\r\n} else {\r\nif (syncmaster == hc) {\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG "%s: LOST sync on card %d"\r\n" (id=%d)\n", __func__, hc->id + 1,\r\nhc->id);\r\nhfcmulti_resync(hc, NULL, rm);\r\n}\r\n}\r\n}\r\nstatic void\r\nrelease_io_hfcmulti(struct hfc_multi *hc)\r\n{\r\nvoid __iomem *plx_acc_32;\r\nu_int pv;\r\nu_long plx_flags;\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: entered\n", __func__);\r\nhc->hw.r_cirm |= V_SRES;\r\nHFC_outb(hc, R_CIRM, hc->hw.r_cirm);\r\nudelay(1000);\r\nhc->hw.r_cirm &= ~V_SRES;\r\nHFC_outb(hc, R_CIRM, hc->hw.r_cirm);\r\nudelay(1000);\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip) && hc->plx_membase) {\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG "%s: release PLXSD card %d\n",\r\n__func__, hc->id + 1);\r\nspin_lock_irqsave(&plx_lock, plx_flags);\r\nplx_acc_32 = hc->plx_membase + PLX_GPIOC;\r\nwritel(PLX_GPIOC_INIT, plx_acc_32);\r\npv = readl(plx_acc_32);\r\npv &= ~PLX_TERM_ON;\r\npv |= PLX_SLAVE_EN_N;\r\npv &= ~PLX_MASTER_EN;\r\npv &= ~PLX_SYNC_O_EN;\r\npv &= ~PLX_DSP_RES_N;\r\nwritel(pv, plx_acc_32);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: PCM off: PLX_GPIO=%x\n",\r\n__func__, pv);\r\nspin_unlock_irqrestore(&plx_lock, plx_flags);\r\n}\r\ntest_and_clear_bit(HFC_CHIP_PLXSD, &hc->chip);\r\nif (hc->pci_dev)\r\npci_write_config_word(hc->pci_dev, PCI_COMMAND, 0);\r\nif (hc->pci_membase)\r\niounmap(hc->pci_membase);\r\nif (hc->plx_membase)\r\niounmap(hc->plx_membase);\r\nif (hc->pci_iobase)\r\nrelease_region(hc->pci_iobase, 8);\r\nif (hc->xhfc_membase)\r\niounmap((void *)hc->xhfc_membase);\r\nif (hc->pci_dev) {\r\npci_disable_device(hc->pci_dev);\r\npci_set_drvdata(hc->pci_dev, NULL);\r\n}\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: done\n", __func__);\r\n}\r\nstatic int\r\ninit_chip(struct hfc_multi *hc)\r\n{\r\nu_long flags, val, val2 = 0, rev;\r\nint i, err = 0;\r\nu_char r_conf_en, rval;\r\nvoid __iomem *plx_acc_32;\r\nu_int pv;\r\nu_long plx_flags, hfc_flags;\r\nint plx_count;\r\nstruct hfc_multi *pos, *next, *plx_last_hc;\r\nspin_lock_irqsave(&hc->lock, flags);\r\nmemset(&hc->hw, 0, sizeof(struct hfcm_hw));\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: entered\n", __func__);\r\nval = HFC_inb(hc, R_CHIP_ID);\r\nif ((val >> 4) != 0x8 && (val >> 4) != 0xc && (val >> 4) != 0xe &&\r\n(val >> 1) != 0x31) {\r\nprintk(KERN_INFO "HFC_multi: unknown CHIP_ID:%x\n", (u_int)val);\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nrev = HFC_inb(hc, R_CHIP_RV);\r\nprintk(KERN_INFO\r\n"HFC_multi: detected HFC with chip ID=0x%lx revision=%ld%s\n",\r\nval, rev, (rev == 0 && (hc->ctype != HFC_TYPE_XHFC)) ?\r\n" (old FIFO handling)" : "");\r\nif (hc->ctype != HFC_TYPE_XHFC && rev == 0) {\r\ntest_and_set_bit(HFC_CHIP_REVISION0, &hc->chip);\r\nprintk(KERN_WARNING\r\n"HFC_multi: NOTE: Your chip is revision 0, "\r\n"ask Cologne Chip for update. Newer chips "\r\n"have a better FIFO handling. Old chips "\r\n"still work but may have slightly lower "\r\n"HDLC transmit performance.\n");\r\n}\r\nif (rev > 1) {\r\nprintk(KERN_WARNING "HFC_multi: WARNING: This driver doesn't "\r\n"consider chip revision = %ld. The chip / "\r\n"bridge may not work.\n", rev);\r\n}\r\nhc->Flen = 0x10;\r\nhc->Zmin = 0x80;\r\nhc->Zlen = 384;\r\nhc->DTMFbase = 0x1000;\r\nif (test_bit(HFC_CHIP_EXRAM_128, &hc->chip)) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: changing to 128K external RAM\n",\r\n__func__);\r\nhc->hw.r_ctrl |= V_EXT_RAM;\r\nhc->hw.r_ram_sz = 1;\r\nhc->Flen = 0x20;\r\nhc->Zmin = 0xc0;\r\nhc->Zlen = 1856;\r\nhc->DTMFbase = 0x2000;\r\n}\r\nif (test_bit(HFC_CHIP_EXRAM_512, &hc->chip)) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: changing to 512K external RAM\n",\r\n__func__);\r\nhc->hw.r_ctrl |= V_EXT_RAM;\r\nhc->hw.r_ram_sz = 2;\r\nhc->Flen = 0x20;\r\nhc->Zmin = 0xc0;\r\nhc->Zlen = 8000;\r\nhc->DTMFbase = 0x2000;\r\n}\r\nif (hc->ctype == HFC_TYPE_XHFC) {\r\nhc->Flen = 0x8;\r\nhc->Zmin = 0x0;\r\nhc->Zlen = 64;\r\nhc->DTMFbase = 0x0;\r\n}\r\nhc->max_trans = poll << 1;\r\nif (hc->max_trans > hc->Zlen)\r\nhc->max_trans = hc->Zlen;\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG "%s: initializing PLXSD card %d\n",\r\n__func__, hc->id + 1);\r\nspin_lock_irqsave(&plx_lock, plx_flags);\r\nplx_acc_32 = hc->plx_membase + PLX_GPIOC;\r\nwritel(PLX_GPIOC_INIT, plx_acc_32);\r\npv = readl(plx_acc_32);\r\npv |= PLX_TERM_ON;\r\npv |= PLX_SLAVE_EN_N;\r\npv &= ~PLX_MASTER_EN;\r\npv &= ~PLX_SYNC_O_EN;\r\npv &= ~PLX_DSP_RES_N;\r\nwritel(pv, plx_acc_32);\r\nspin_unlock_irqrestore(&plx_lock, plx_flags);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: slave/term: PLX_GPIO=%x\n",\r\n__func__, pv);\r\nspin_lock_irqsave(&HFClock, hfc_flags);\r\nplx_count = 0;\r\nplx_last_hc = NULL;\r\nlist_for_each_entry_safe(pos, next, &HFClist, list) {\r\nif (test_bit(HFC_CHIP_PLXSD, &pos->chip)) {\r\nplx_count++;\r\nif (pos != hc)\r\nplx_last_hc = pos;\r\n}\r\n}\r\nif (plx_count >= 3) {\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG "%s: card %d is between, so "\r\n"we disable termination\n",\r\n__func__, plx_last_hc->id + 1);\r\nspin_lock_irqsave(&plx_lock, plx_flags);\r\nplx_acc_32 = plx_last_hc->plx_membase + PLX_GPIOC;\r\npv = readl(plx_acc_32);\r\npv &= ~PLX_TERM_ON;\r\nwritel(pv, plx_acc_32);\r\nspin_unlock_irqrestore(&plx_lock, plx_flags);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: term off: PLX_GPIO=%x\n",\r\n__func__, pv);\r\n}\r\nspin_unlock_irqrestore(&HFClock, hfc_flags);\r\nhc->hw.r_pcm_md0 = V_F0_LEN;\r\n}\r\nif (test_bit(HFC_CHIP_EMBSD, &hc->chip))\r\nhc->hw.r_pcm_md0 = V_F0_LEN;\r\nif (!test_bit(HFC_CHIP_REVISION0, &hc->chip))\r\nhc->hw.r_ram_sz |= V_FZ_MD;\r\nif (test_bit(HFC_CHIP_PCM_SLAVE, &hc->chip)) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: setting PCM into slave mode\n",\r\n__func__);\r\n} else\r\nif (test_bit(HFC_CHIP_PCM_MASTER, &hc->chip) && !plxsd_master) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: setting PCM into master mode\n",\r\n__func__);\r\nhc->hw.r_pcm_md0 |= V_PCM_MD;\r\n} else {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: performing PCM auto detect\n",\r\n__func__);\r\n}\r\nHFC_outb(hc, R_CTRL, hc->hw.r_ctrl);\r\nif (hc->ctype == HFC_TYPE_XHFC)\r\nHFC_outb(hc, 0x0C ,\r\n0x11 );\r\nelse\r\nHFC_outb(hc, R_RAM_SZ, hc->hw.r_ram_sz);\r\nHFC_outb(hc, R_FIFO_MD, 0);\r\nif (hc->ctype == HFC_TYPE_XHFC)\r\nhc->hw.r_cirm = V_SRES | V_HFCRES | V_PCMRES | V_STRES;\r\nelse\r\nhc->hw.r_cirm = V_SRES | V_HFCRES | V_PCMRES | V_STRES\r\n| V_RLD_EPR;\r\nHFC_outb(hc, R_CIRM, hc->hw.r_cirm);\r\nudelay(100);\r\nhc->hw.r_cirm = 0;\r\nHFC_outb(hc, R_CIRM, hc->hw.r_cirm);\r\nudelay(100);\r\nif (hc->ctype != HFC_TYPE_XHFC)\r\nHFC_outb(hc, R_RAM_SZ, hc->hw.r_ram_sz);\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nspin_lock_irqsave(&plx_lock, plx_flags);\r\nplx_acc_32 = hc->plx_membase + PLX_GPIOC;\r\npv = readl(plx_acc_32);\r\nif (hc->hw.r_pcm_md0 & V_PCM_MD) {\r\npv |= PLX_MASTER_EN | PLX_SLAVE_EN_N;\r\npv |= PLX_SYNC_O_EN;\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: master: PLX_GPIO=%x\n",\r\n__func__, pv);\r\n} else {\r\npv &= ~(PLX_MASTER_EN | PLX_SLAVE_EN_N);\r\npv &= ~PLX_SYNC_O_EN;\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: slave: PLX_GPIO=%x\n",\r\n__func__, pv);\r\n}\r\nwritel(pv, plx_acc_32);\r\nspin_unlock_irqrestore(&plx_lock, plx_flags);\r\n}\r\nHFC_outb(hc, R_PCM_MD0, hc->hw.r_pcm_md0 | 0x90);\r\nif (hc->slots == 32)\r\nHFC_outb(hc, R_PCM_MD1, 0x00);\r\nif (hc->slots == 64)\r\nHFC_outb(hc, R_PCM_MD1, 0x10);\r\nif (hc->slots == 128)\r\nHFC_outb(hc, R_PCM_MD1, 0x20);\r\nHFC_outb(hc, R_PCM_MD0, hc->hw.r_pcm_md0 | 0xa0);\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip))\r\nHFC_outb(hc, R_PCM_MD2, V_SYNC_SRC);\r\nelse if (test_bit(HFC_CHIP_EMBSD, &hc->chip))\r\nHFC_outb(hc, R_PCM_MD2, 0x10);\r\nelse\r\nHFC_outb(hc, R_PCM_MD2, 0x00);\r\nHFC_outb(hc, R_PCM_MD0, hc->hw.r_pcm_md0 | 0x00);\r\nfor (i = 0; i < 256; i++) {\r\nHFC_outb_nodebug(hc, R_SLOT, i);\r\nHFC_outb_nodebug(hc, A_SL_CFG, 0);\r\nif (hc->ctype != HFC_TYPE_XHFC)\r\nHFC_outb_nodebug(hc, A_CONF, 0);\r\nhc->slot_owner[i] = -1;\r\n}\r\nif (test_bit(HFC_CHIP_CLOCK2, &hc->chip)) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: setting double clock\n", __func__);\r\nHFC_outb(hc, R_BRG_PCM_CFG, V_PCM_CLK);\r\n}\r\nif (test_bit(HFC_CHIP_EMBSD, &hc->chip))\r\nHFC_outb(hc, 0x02 , 0x40 );\r\nif (test_bit(HFC_CHIP_B410P, &hc->chip)) {\r\nprintk(KERN_NOTICE "Setting GPIOs\n");\r\nHFC_outb(hc, R_GPIO_SEL, 0x30);\r\nHFC_outb(hc, R_GPIO_EN1, 0x3);\r\nudelay(1000);\r\nprintk(KERN_NOTICE "calling vpm_init\n");\r\nvpm_init(hc);\r\n}\r\nval = HFC_inb(hc, R_F0_CNTL);\r\nval += HFC_inb(hc, R_F0_CNTH) << 8;\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"HFC_multi F0_CNT %ld after reset\n", val);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout((HZ / 100) ? : 1);\r\nspin_lock_irqsave(&hc->lock, flags);\r\nval2 = HFC_inb(hc, R_F0_CNTL);\r\nval2 += HFC_inb(hc, R_F0_CNTH) << 8;\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"HFC_multi F0_CNT %ld after 10 ms (1st try)\n",\r\nval2);\r\nif (val2 >= val + 8) {\r\nif (test_bit(HFC_CHIP_PCM_MASTER, &hc->chip))\r\nprintk(KERN_INFO "controller is PCM bus MASTER\n");\r\nelse\r\nif (test_bit(HFC_CHIP_PCM_SLAVE, &hc->chip))\r\nprintk(KERN_INFO "controller is PCM bus SLAVE\n");\r\nelse {\r\ntest_and_set_bit(HFC_CHIP_PCM_SLAVE, &hc->chip);\r\nprintk(KERN_INFO "controller is PCM bus SLAVE "\r\n"(auto detected)\n");\r\n}\r\n} else {\r\nif (test_bit(HFC_CHIP_PCM_MASTER, &hc->chip)) {\r\ncontroller_fail:\r\nprintk(KERN_ERR "HFC_multi ERROR, getting no 125us "\r\n"pulse. Seems that controller fails.\n");\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nif (test_bit(HFC_CHIP_PCM_SLAVE, &hc->chip)) {\r\nprintk(KERN_INFO "controller is PCM bus SLAVE "\r\n"(ignoring missing PCM clock)\n");\r\n} else {\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)\r\n&& plxsd_master) {\r\nprintk(KERN_ERR "HFC_multi ERROR, no clock "\r\n"on another Speech Design card found. "\r\n"Please be sure to connect PCM cable.\n");\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nspin_lock_irqsave(&plx_lock, plx_flags);\r\nplx_acc_32 = hc->plx_membase + PLX_GPIOC;\r\npv = readl(plx_acc_32);\r\npv |= PLX_MASTER_EN | PLX_SLAVE_EN_N;\r\npv |= PLX_SYNC_O_EN;\r\nwritel(pv, plx_acc_32);\r\nspin_unlock_irqrestore(&plx_lock, plx_flags);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: master: "\r\n"PLX_GPIO=%x\n", __func__, pv);\r\n}\r\nhc->hw.r_pcm_md0 |= V_PCM_MD;\r\nHFC_outb(hc, R_PCM_MD0, hc->hw.r_pcm_md0 | 0x00);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout((HZ / 100) ?: 1);\r\nspin_lock_irqsave(&hc->lock, flags);\r\nval2 = HFC_inb(hc, R_F0_CNTL);\r\nval2 += HFC_inb(hc, R_F0_CNTH) << 8;\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "HFC_multi F0_CNT %ld after "\r\n"10 ms (2nd try)\n", val2);\r\nif (val2 >= val + 8) {\r\ntest_and_set_bit(HFC_CHIP_PCM_MASTER,\r\n&hc->chip);\r\nprintk(KERN_INFO "controller is PCM bus MASTER "\r\n"(auto detected)\n");\r\n} else\r\ngoto controller_fail;\r\n}\r\n}\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nif (test_bit(HFC_CHIP_PCM_MASTER, &hc->chip))\r\nplxsd_master = 1;\r\nspin_lock_irqsave(&plx_lock, plx_flags);\r\nplx_acc_32 = hc->plx_membase + PLX_GPIOC;\r\npv = readl(plx_acc_32);\r\npv |= PLX_DSP_RES_N;\r\nwritel(pv, plx_acc_32);\r\nspin_unlock_irqrestore(&plx_lock, plx_flags);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: reset off: PLX_GPIO=%x\n",\r\n__func__, pv);\r\n}\r\nif (hc->pcm)\r\nprintk(KERN_INFO "controller has given PCM BUS ID %d\n",\r\nhc->pcm);\r\nelse {\r\nif (test_bit(HFC_CHIP_PCM_MASTER, &hc->chip)\r\n|| test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nPCM_cnt++;\r\n}\r\nhc->pcm = PCM_cnt;\r\nprintk(KERN_INFO "controller has PCM BUS ID %d "\r\n"(auto selected)\n", hc->pcm);\r\n}\r\nHFC_outb(hc, R_TI_WD, poll_timer);\r\nhc->hw.r_irqmsk_misc |= V_TI_IRQMSK;\r\nif (hc->ctype == HFC_TYPE_E1)\r\nhc->hw.r_irqmsk_misc |= V_STA_IRQMSK;\r\nif (test_bit(HFC_CHIP_DTMF, &hc->chip)) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: enabling DTMF detection "\r\n"for all B-channel\n", __func__);\r\nhc->hw.r_dtmf = V_DTMF_EN | V_DTMF_STOP;\r\nif (test_bit(HFC_CHIP_ULAW, &hc->chip))\r\nhc->hw.r_dtmf |= V_ULAW_SEL;\r\nHFC_outb(hc, R_DTMF_N, 102 - 1);\r\nhc->hw.r_irqmsk_misc |= V_DTMF_IRQMSK;\r\n}\r\nif (test_bit(HFC_CHIP_ULAW, &hc->chip))\r\nr_conf_en = V_CONF_EN | V_ULAW;\r\nelse\r\nr_conf_en = V_CONF_EN;\r\nif (hc->ctype != HFC_TYPE_XHFC)\r\nHFC_outb(hc, R_CONF_EN, r_conf_en);\r\nswitch (hc->leds) {\r\ncase 1:\r\nif (test_bit(HFC_CHIP_WATCHDOG, &hc->chip))\r\nHFC_outb(hc, R_GPIO_SEL, 0x32);\r\nelse\r\nHFC_outb(hc, R_GPIO_SEL, 0x30);\r\nHFC_outb(hc, R_GPIO_EN1, 0x0f);\r\nHFC_outb(hc, R_GPIO_OUT1, 0x00);\r\nHFC_outb(hc, R_GPIO_EN0, V_GPIO_EN2 | V_GPIO_EN3);\r\nbreak;\r\ncase 2:\r\ncase 3:\r\nHFC_outb(hc, R_GPIO_SEL, 0xf0);\r\nHFC_outb(hc, R_GPIO_EN1, 0xff);\r\nHFC_outb(hc, R_GPIO_OUT1, 0x00);\r\nbreak;\r\n}\r\nif (test_bit(HFC_CHIP_EMBSD, &hc->chip)) {\r\nhc->hw.r_st_sync = 0x10;\r\nHFC_outb(hc, R_ST_SYNC, hc->hw.r_st_sync);\r\n}\r\nif (hc->masterclk >= 0) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: setting ST master clock "\r\n"to port %d (0..%d)\n",\r\n__func__, hc->masterclk, hc->ports - 1);\r\nhc->hw.r_st_sync |= (hc->masterclk | V_AUTO_SYNC);\r\nHFC_outb(hc, R_ST_SYNC, hc->hw.r_st_sync);\r\n}\r\nHFC_outb(hc, R_IRQMSK_MISC, hc->hw.r_irqmsk_misc);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "r_irqmsk_misc.2: 0x%x\n",\r\nhc->hw.r_irqmsk_misc);\r\nHFC_outb(hc, R_RAM_ADDR0, 0);\r\nHFC_outb(hc, R_RAM_ADDR1, 0);\r\nHFC_outb(hc, R_RAM_ADDR2, 0);\r\nfor (i = 0; i < 256; i++) {\r\nHFC_outb_nodebug(hc, R_RAM_ADDR0, i);\r\nHFC_outb_nodebug(hc, R_RAM_DATA, ((i * 3) & 0xff));\r\n}\r\nfor (i = 0; i < 256; i++) {\r\nHFC_outb_nodebug(hc, R_RAM_ADDR0, i);\r\nHFC_inb_nodebug(hc, R_RAM_DATA);\r\nrval = HFC_inb_nodebug(hc, R_INT_DATA);\r\nif (rval != ((i * 3) & 0xff)) {\r\nprintk(KERN_DEBUG\r\n"addr:%x val:%x should:%x\n", i, rval,\r\n(i * 3) & 0xff);\r\nerr++;\r\n}\r\n}\r\nif (err) {\r\nprintk(KERN_DEBUG "aborting - %d RAM access errors\n", err);\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: done\n", __func__);\r\nout:\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nreturn err;\r\n}\r\nstatic void\r\nhfcmulti_watchdog(struct hfc_multi *hc)\r\n{\r\nhc->wdcount++;\r\nif (hc->wdcount > 10) {\r\nhc->wdcount = 0;\r\nhc->wdbyte = hc->wdbyte == V_GPIO_OUT2 ?\r\nV_GPIO_OUT3 : V_GPIO_OUT2;\r\nHFC_outb(hc, R_GPIO_EN0, V_GPIO_EN2 | V_GPIO_EN3);\r\nHFC_outb(hc, R_GPIO_OUT0, hc->wdbyte);\r\n}\r\n}\r\nstatic void\r\nhfcmulti_leds(struct hfc_multi *hc)\r\n{\r\nunsigned long lled;\r\nunsigned long leddw;\r\nint i, state, active, leds;\r\nstruct dchannel *dch;\r\nint led[4];\r\nswitch (hc->leds) {\r\ncase 1:\r\nled[0] = 0;\r\nled[1] = 0;\r\nled[2] = 0;\r\nled[3] = 0;\r\ndch = hc->chan[hc->dnum[0]].dch;\r\nif (dch) {\r\nif (hc->chan[hc->dnum[0]].los)\r\nled[1] = 1;\r\nif (hc->e1_state != 1) {\r\nled[0] = 1;\r\nhc->flash[2] = 0;\r\nhc->flash[3] = 0;\r\n} else {\r\nled[2] = 1;\r\nled[3] = 1;\r\nif (!hc->flash[2] && hc->activity_tx)\r\nhc->flash[2] = poll;\r\nif (!hc->flash[3] && hc->activity_rx)\r\nhc->flash[3] = poll;\r\nif (hc->flash[2] && hc->flash[2] < 1024)\r\nled[2] = 0;\r\nif (hc->flash[3] && hc->flash[3] < 1024)\r\nled[3] = 0;\r\nif (hc->flash[2] >= 2048)\r\nhc->flash[2] = 0;\r\nif (hc->flash[3] >= 2048)\r\nhc->flash[3] = 0;\r\nif (hc->flash[2])\r\nhc->flash[2] += poll;\r\nif (hc->flash[3])\r\nhc->flash[3] += poll;\r\n}\r\n}\r\nleds = (led[0] | (led[1]<<2) | (led[2]<<1) | (led[3]<<3))^0xF;\r\nif (leds != (int)hc->ledstate) {\r\nHFC_outb_nodebug(hc, R_GPIO_OUT1, leds);\r\nhc->ledstate = leds;\r\n}\r\nbreak;\r\ncase 2:\r\nfor (i = 0; i < 4; i++) {\r\nstate = 0;\r\nactive = -1;\r\ndch = hc->chan[(i << 2) | 2].dch;\r\nif (dch) {\r\nstate = dch->state;\r\nif (dch->dev.D.protocol == ISDN_P_NT_S0)\r\nactive = 3;\r\nelse\r\nactive = 7;\r\n}\r\nif (state) {\r\nif (state == active) {\r\nled[i] = 1;\r\nhc->activity_tx |= hc->activity_rx;\r\nif (!hc->flash[i] &&\r\n(hc->activity_tx & (1 << i)))\r\nhc->flash[i] = poll;\r\nif (hc->flash[i] && hc->flash[i] < 1024)\r\nled[i] = 0;\r\nif (hc->flash[i] >= 2048)\r\nhc->flash[i] = 0;\r\nif (hc->flash[i])\r\nhc->flash[i] += poll;\r\n} else {\r\nled[i] = 2;\r\nhc->flash[i] = 0;\r\n}\r\n} else\r\nled[i] = 0;\r\n}\r\nif (test_bit(HFC_CHIP_B410P, &hc->chip)) {\r\nleds = 0;\r\nfor (i = 0; i < 4; i++) {\r\nif (led[i] == 1) {\r\nleds |= (0x2 << (i * 2));\r\n} else if (led[i] == 2) {\r\nleds |= (0x1 << (i * 2));\r\n}\r\n}\r\nif (leds != (int)hc->ledstate) {\r\nvpm_out(hc, 0, 0x1a8 + 3, leds);\r\nhc->ledstate = leds;\r\n}\r\n} else {\r\nleds = ((led[3] > 0) << 0) | ((led[1] > 0) << 1) |\r\n((led[0] > 0) << 2) | ((led[2] > 0) << 3) |\r\n((led[3] & 1) << 4) | ((led[1] & 1) << 5) |\r\n((led[0] & 1) << 6) | ((led[2] & 1) << 7);\r\nif (leds != (int)hc->ledstate) {\r\nHFC_outb_nodebug(hc, R_GPIO_EN1, leds & 0x0F);\r\nHFC_outb_nodebug(hc, R_GPIO_OUT1, leds >> 4);\r\nhc->ledstate = leds;\r\n}\r\n}\r\nbreak;\r\ncase 3:\r\nfor (i = 0; i < 2; i++) {\r\nstate = 0;\r\nactive = -1;\r\ndch = hc->chan[(i << 2) | 2].dch;\r\nif (dch) {\r\nstate = dch->state;\r\nif (dch->dev.D.protocol == ISDN_P_NT_S0)\r\nactive = 3;\r\nelse\r\nactive = 7;\r\n}\r\nif (state) {\r\nif (state == active) {\r\nled[i] = 1;\r\nhc->activity_tx |= hc->activity_rx;\r\nif (!hc->flash[i] &&\r\n(hc->activity_tx & (1 << i)))\r\nhc->flash[i] = poll;\r\nif (hc->flash[i] < 1024)\r\nled[i] = 0;\r\nif (hc->flash[i] >= 2048)\r\nhc->flash[i] = 0;\r\nif (hc->flash[i])\r\nhc->flash[i] += poll;\r\n} else {\r\nled[i] = 2;\r\nhc->flash[i] = 0;\r\n}\r\n} else\r\nled[i] = 0;\r\n}\r\nleds = (led[0] > 0) | ((led[1] > 0) << 1) | ((led[0]&1) << 2)\r\n| ((led[1]&1) << 3);\r\nif (leds != (int)hc->ledstate) {\r\nHFC_outb_nodebug(hc, R_GPIO_EN1,\r\n((led[0] > 0) << 2) | ((led[1] > 0) << 3));\r\nHFC_outb_nodebug(hc, R_GPIO_OUT1,\r\n((led[0] & 1) << 2) | ((led[1] & 1) << 3));\r\nhc->ledstate = leds;\r\n}\r\nbreak;\r\ncase 8:\r\nlled = 0xff;\r\nfor (i = 0; i < 8; i++) {\r\nstate = 0;\r\nactive = -1;\r\ndch = hc->chan[(i << 2) | 2].dch;\r\nif (dch) {\r\nstate = dch->state;\r\nif (dch->dev.D.protocol == ISDN_P_NT_S0)\r\nactive = 3;\r\nelse\r\nactive = 7;\r\n}\r\nif (state) {\r\nif (state == active) {\r\nlled &= ~(1 << i);\r\nhc->activity_tx |= hc->activity_rx;\r\nif (!hc->flash[i] &&\r\n(hc->activity_tx & (1 << i)))\r\nhc->flash[i] = poll;\r\nif (hc->flash[i] < 1024)\r\nlled |= 1 << i;\r\nif (hc->flash[i] >= 2048)\r\nhc->flash[i] = 0;\r\nif (hc->flash[i])\r\nhc->flash[i] += poll;\r\n} else\r\nhc->flash[i] = 0;\r\n}\r\n}\r\nleddw = lled << 24 | lled << 16 | lled << 8 | lled;\r\nif (leddw != hc->ledstate) {\r\nHFC_outb_nodebug(hc, R_BRG_PCM_CFG, 1 | V_PCM_CLK);\r\noutw(0x4000, hc->pci_iobase + 4);\r\noutl(leddw, hc->pci_iobase);\r\nHFC_outb_nodebug(hc, R_BRG_PCM_CFG, V_PCM_CLK);\r\nhc->ledstate = leddw;\r\n}\r\nbreak;\r\n}\r\nhc->activity_tx = 0;\r\nhc->activity_rx = 0;\r\n}\r\nstatic void\r\nhfcmulti_dtmf(struct hfc_multi *hc)\r\n{\r\ns32 *coeff;\r\nu_int mantissa;\r\nint co, ch;\r\nstruct bchannel *bch = NULL;\r\nu8 exponent;\r\nint dtmf = 0;\r\nint addr;\r\nu16 w_float;\r\nstruct sk_buff *skb;\r\nstruct mISDNhead *hh;\r\nif (debug & DEBUG_HFCMULTI_DTMF)\r\nprintk(KERN_DEBUG "%s: dtmf detection irq\n", __func__);\r\nfor (ch = 0; ch <= 31; ch++) {\r\nbch = hc->chan[ch].bch;\r\nif (!bch)\r\ncontinue;\r\nif (!hc->created[hc->chan[ch].port])\r\ncontinue;\r\nif (!test_bit(FLG_TRANSPARENT, &bch->Flags))\r\ncontinue;\r\nif (debug & DEBUG_HFCMULTI_DTMF)\r\nprintk(KERN_DEBUG "%s: dtmf channel %d:",\r\n__func__, ch);\r\ncoeff = &(hc->chan[ch].coeff[hc->chan[ch].coeff_count * 16]);\r\ndtmf = 1;\r\nfor (co = 0; co < 8; co++) {\r\naddr = hc->DTMFbase + ((co << 7) | (ch << 2));\r\nHFC_outb_nodebug(hc, R_RAM_ADDR0, addr);\r\nHFC_outb_nodebug(hc, R_RAM_ADDR1, addr >> 8);\r\nHFC_outb_nodebug(hc, R_RAM_ADDR2, (addr >> 16)\r\n| V_ADDR_INC);\r\nw_float = HFC_inb_nodebug(hc, R_RAM_DATA);\r\nw_float |= (HFC_inb_nodebug(hc, R_RAM_DATA) << 8);\r\nif (debug & DEBUG_HFCMULTI_DTMF)\r\nprintk(" %04x", w_float);\r\nmantissa = w_float & 0x0fff;\r\nif (w_float & 0x8000)\r\nmantissa |= 0xfffff000;\r\nexponent = (w_float >> 12) & 0x7;\r\nif (exponent) {\r\nmantissa ^= 0x1000;\r\nmantissa <<= (exponent - 1);\r\n}\r\ncoeff[co << 1] = mantissa;\r\nw_float = HFC_inb_nodebug(hc, R_RAM_DATA);\r\nw_float |= (HFC_inb_nodebug(hc, R_RAM_DATA) << 8);\r\nif (debug & DEBUG_HFCMULTI_DTMF)\r\nprintk(" %04x", w_float);\r\nmantissa = w_float & 0x0fff;\r\nif (w_float & 0x8000)\r\nmantissa |= 0xfffff000;\r\nexponent = (w_float >> 12) & 0x7;\r\nif (exponent) {\r\nmantissa ^= 0x1000;\r\nmantissa <<= (exponent - 1);\r\n}\r\ncoeff[(co << 1) | 1] = mantissa;\r\n}\r\nif (debug & DEBUG_HFCMULTI_DTMF)\r\nprintk(" DTMF ready %08x %08x %08x %08x "\r\n"%08x %08x %08x %08x\n",\r\ncoeff[0], coeff[1], coeff[2], coeff[3],\r\ncoeff[4], coeff[5], coeff[6], coeff[7]);\r\nhc->chan[ch].coeff_count++;\r\nif (hc->chan[ch].coeff_count == 8) {\r\nhc->chan[ch].coeff_count = 0;\r\nskb = mI_alloc_skb(512, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_DEBUG "%s: No memory for skb\n",\r\n__func__);\r\ncontinue;\r\n}\r\nhh = mISDN_HEAD_P(skb);\r\nhh->prim = PH_CONTROL_IND;\r\nhh->id = DTMF_HFC_COEF;\r\nmemcpy(skb_put(skb, 512), hc->chan[ch].coeff, 512);\r\nrecv_Bchannel_skb(bch, skb);\r\n}\r\n}\r\nhc->dtmf = dtmf;\r\nif (dtmf)\r\nHFC_outb_nodebug(hc, R_DTMF, hc->hw.r_dtmf | V_RST_DTMF);\r\n}\r\nstatic void\r\nhfcmulti_tx(struct hfc_multi *hc, int ch)\r\n{\r\nint i, ii, temp, len = 0;\r\nint Zspace, z1, z2;\r\nint Fspace, f1, f2;\r\nu_char *d;\r\nint *txpending, slot_tx;\r\nstruct bchannel *bch;\r\nstruct dchannel *dch;\r\nstruct sk_buff **sp = NULL;\r\nint *idxp;\r\nbch = hc->chan[ch].bch;\r\ndch = hc->chan[ch].dch;\r\nif ((!dch) && (!bch))\r\nreturn;\r\ntxpending = &hc->chan[ch].txpending;\r\nslot_tx = hc->chan[ch].slot_tx;\r\nif (dch) {\r\nif (!test_bit(FLG_ACTIVE, &dch->Flags))\r\nreturn;\r\nsp = &dch->tx_skb;\r\nidxp = &dch->tx_idx;\r\n} else {\r\nif (!test_bit(FLG_ACTIVE, &bch->Flags))\r\nreturn;\r\nsp = &bch->tx_skb;\r\nidxp = &bch->tx_idx;\r\n}\r\nif (*sp)\r\nlen = (*sp)->len;\r\nif ((!len) && *txpending != 1)\r\nreturn;\r\nif (test_bit(HFC_CHIP_B410P, &hc->chip) &&\r\n(hc->chan[ch].protocol == ISDN_P_B_RAW) &&\r\n(hc->chan[ch].slot_rx < 0) &&\r\n(hc->chan[ch].slot_tx < 0))\r\nHFC_outb_nodebug(hc, R_FIFO, 0x20 | (ch << 1));\r\nelse\r\nHFC_outb_nodebug(hc, R_FIFO, ch << 1);\r\nHFC_wait_nodebug(hc);\r\nif (*txpending == 2) {\r\nHFC_outb_nodebug(hc, R_INC_RES_FIFO, V_RES_F);\r\nHFC_wait_nodebug(hc);\r\nHFC_outb(hc, A_SUBCH_CFG, 0);\r\n*txpending = 1;\r\n}\r\nnext_frame:\r\nif (dch || test_bit(FLG_HDLC, &bch->Flags)) {\r\nf1 = HFC_inb_nodebug(hc, A_F1);\r\nf2 = HFC_inb_nodebug(hc, A_F2);\r\nwhile (f2 != (temp = HFC_inb_nodebug(hc, A_F2))) {\r\nif (debug & DEBUG_HFCMULTI_FIFO)\r\nprintk(KERN_DEBUG\r\n"%s(card %d): reread f2 because %d!=%d\n",\r\n__func__, hc->id + 1, temp, f2);\r\nf2 = temp;\r\n}\r\nFspace = f2 - f1 - 1;\r\nif (Fspace < 0)\r\nFspace += hc->Flen;\r\nif (test_bit(HFC_CHIP_REVISION0, &hc->chip)) {\r\nif (f1 != f2)\r\nFspace = 0;\r\nelse\r\nFspace = 1;\r\n}\r\nif (hc->ctype != HFC_TYPE_E1 && dch) {\r\nif (f1 != f2)\r\nFspace = 0;\r\n}\r\nif (Fspace == 0)\r\nreturn;\r\n}\r\nz1 = HFC_inw_nodebug(hc, A_Z1) - hc->Zmin;\r\nz2 = HFC_inw_nodebug(hc, A_Z2) - hc->Zmin;\r\nwhile (z2 != (temp = (HFC_inw_nodebug(hc, A_Z2) - hc->Zmin))) {\r\nif (debug & DEBUG_HFCMULTI_FIFO)\r\nprintk(KERN_DEBUG "%s(card %d): reread z2 because "\r\n"%d!=%d\n", __func__, hc->id + 1, temp, z2);\r\nz2 = temp;\r\n}\r\nhc->chan[ch].Zfill = z1 - z2;\r\nif (hc->chan[ch].Zfill < 0)\r\nhc->chan[ch].Zfill += hc->Zlen;\r\nZspace = z2 - z1;\r\nif (Zspace <= 0)\r\nZspace += hc->Zlen;\r\nZspace -= 4;\r\nif (bch && test_bit(FLG_TRANSPARENT, &bch->Flags))\r\nZspace = Zspace - hc->Zlen + hc->max_trans;\r\nif (Zspace <= 0)\r\nreturn;\r\nif (!len) {\r\nif (z1 == z2) {\r\nif (bch && (!test_bit(FLG_HDLC, &bch->Flags)) &&\r\n*txpending && slot_tx >= 0) {\r\nif (debug & DEBUG_HFCMULTI_MODE)\r\nprintk(KERN_DEBUG\r\n"%s: reconnecting PCM due to no "\r\n"more FIFO data: channel %d "\r\n"slot_tx %d\n",\r\n__func__, ch, slot_tx);\r\nif (hc->ctype == HFC_TYPE_XHFC)\r\nHFC_outb(hc, A_CON_HDLC, 0xc0\r\n| 0x07 << 2 | V_HDLC_TRP | V_IFF);\r\nelse\r\nHFC_outb(hc, A_CON_HDLC, 0xc0 | 0x00 |\r\nV_HDLC_TRP | V_IFF);\r\nHFC_outb_nodebug(hc, R_FIFO, ch << 1 | 1);\r\nHFC_wait_nodebug(hc);\r\nif (hc->ctype == HFC_TYPE_XHFC)\r\nHFC_outb(hc, A_CON_HDLC, 0xc0\r\n| 0x07 << 2 | V_HDLC_TRP | V_IFF);\r\nelse\r\nHFC_outb(hc, A_CON_HDLC, 0xc0 | 0x00 |\r\nV_HDLC_TRP | V_IFF);\r\nHFC_outb_nodebug(hc, R_FIFO, ch << 1);\r\nHFC_wait_nodebug(hc);\r\n}\r\n*txpending = 0;\r\n}\r\nreturn;\r\n}\r\nif (bch && test_bit(FLG_FILLEMPTY, &bch->Flags)\r\n&& !test_bit(FLG_HDLC, &bch->Flags) && z2 == z1) {\r\nif (debug & DEBUG_HFCMULTI_FILL)\r\nprintk(KERN_DEBUG "%s: buffer empty, so we have "\r\n"underrun\n", __func__);\r\nhc->write_fifo(hc, hc->silence_data, poll >> 1);\r\nZspace -= (poll >> 1);\r\n}\r\nif (bch && (!test_bit(FLG_HDLC, &bch->Flags)) && (!*txpending)\r\n&& slot_tx >= 0) {\r\nif (debug & DEBUG_HFCMULTI_MODE)\r\nprintk(KERN_DEBUG "%s: disconnecting PCM due to "\r\n"FIFO data: channel %d slot_tx %d\n",\r\n__func__, ch, slot_tx);\r\nif (hc->ctype == HFC_TYPE_XHFC)\r\nHFC_outb(hc, A_CON_HDLC, 0x80\r\n| 0x07 << 2 | V_HDLC_TRP | V_IFF);\r\nelse\r\nHFC_outb(hc, A_CON_HDLC, 0x80 | 0x00 |\r\nV_HDLC_TRP | V_IFF);\r\nHFC_outb_nodebug(hc, R_FIFO, ch << 1 | 1);\r\nHFC_wait_nodebug(hc);\r\nif (hc->ctype == HFC_TYPE_XHFC)\r\nHFC_outb(hc, A_CON_HDLC, 0x80\r\n| 0x07 << 2 | V_HDLC_TRP | V_IFF);\r\nelse\r\nHFC_outb(hc, A_CON_HDLC, 0x80 | 0x00 |\r\nV_HDLC_TRP | V_IFF);\r\nHFC_outb_nodebug(hc, R_FIFO, ch << 1);\r\nHFC_wait_nodebug(hc);\r\n}\r\n*txpending = 1;\r\nif (dch)\r\nhc->activity_tx |= 1 << hc->chan[ch].port;\r\nii = len;\r\nif (dch || test_bit(FLG_HDLC, &bch->Flags))\r\ntemp = 1;\r\nelse\r\ntemp = 0;\r\ni = *idxp;\r\nd = (*sp)->data + i;\r\nif (ii - i > Zspace)\r\nii = Zspace + i;\r\nif (debug & DEBUG_HFCMULTI_FIFO)\r\nprintk(KERN_DEBUG "%s(card %d): fifo(%d) has %d bytes space "\r\n"left (z1=%04x, z2=%04x) sending %d of %d bytes %s\n",\r\n__func__, hc->id + 1, ch, Zspace, z1, z2, ii-i, len-i,\r\ntemp ? "HDLC" : "TRANS");\r\nhc->write_fifo(hc, d, ii - i);\r\nhc->chan[ch].Zfill += ii - i;\r\n*idxp = ii;\r\nif (ii != len) {\r\nreturn;\r\n}\r\nif (dch || test_bit(FLG_HDLC, &bch->Flags)) {\r\nHFC_outb_nodebug(hc, R_INC_RES_FIFO, V_INC_F);\r\nHFC_wait_nodebug(hc);\r\n}\r\ndev_kfree_skb(*sp);\r\nif (bch && get_next_bframe(bch)) {\r\nlen = (*sp)->len;\r\ngoto next_frame;\r\n}\r\nif (dch && get_next_dframe(dch)) {\r\nlen = (*sp)->len;\r\ngoto next_frame;\r\n}\r\nif (bch && test_bit(FLG_TRANSPARENT, &bch->Flags))\r\nHFC_outb_nodebug(hc, A_FIFO_DATA0_NOINC, hc->silence);\r\n}\r\nstatic void\r\nhfcmulti_rx(struct hfc_multi *hc, int ch)\r\n{\r\nint temp;\r\nint Zsize, z1, z2 = 0;\r\nint f1 = 0, f2 = 0;\r\nint again = 0;\r\nstruct bchannel *bch;\r\nstruct dchannel *dch = NULL;\r\nstruct sk_buff *skb, **sp = NULL;\r\nint maxlen;\r\nbch = hc->chan[ch].bch;\r\nif (bch) {\r\nif (!test_bit(FLG_ACTIVE, &bch->Flags))\r\nreturn;\r\n} else if (hc->chan[ch].dch) {\r\ndch = hc->chan[ch].dch;\r\nif (!test_bit(FLG_ACTIVE, &dch->Flags))\r\nreturn;\r\n} else {\r\nreturn;\r\n}\r\nnext_frame:\r\nif (test_bit(HFC_CHIP_B410P, &hc->chip) &&\r\n(hc->chan[ch].protocol == ISDN_P_B_RAW) &&\r\n(hc->chan[ch].slot_rx < 0) &&\r\n(hc->chan[ch].slot_tx < 0))\r\nHFC_outb_nodebug(hc, R_FIFO, 0x20 | (ch << 1) | 1);\r\nelse\r\nHFC_outb_nodebug(hc, R_FIFO, (ch << 1) | 1);\r\nHFC_wait_nodebug(hc);\r\nif (hc->chan[ch].rx_off) {\r\nif (bch)\r\nbch->dropcnt += poll;\r\nreturn;\r\n}\r\nif (dch || test_bit(FLG_HDLC, &bch->Flags)) {\r\nf1 = HFC_inb_nodebug(hc, A_F1);\r\nwhile (f1 != (temp = HFC_inb_nodebug(hc, A_F1))) {\r\nif (debug & DEBUG_HFCMULTI_FIFO)\r\nprintk(KERN_DEBUG\r\n"%s(card %d): reread f1 because %d!=%d\n",\r\n__func__, hc->id + 1, temp, f1);\r\nf1 = temp;\r\n}\r\nf2 = HFC_inb_nodebug(hc, A_F2);\r\n}\r\nz1 = HFC_inw_nodebug(hc, A_Z1) - hc->Zmin;\r\nwhile (z1 != (temp = (HFC_inw_nodebug(hc, A_Z1) - hc->Zmin))) {\r\nif (debug & DEBUG_HFCMULTI_FIFO)\r\nprintk(KERN_DEBUG "%s(card %d): reread z2 because "\r\n"%d!=%d\n", __func__, hc->id + 1, temp, z2);\r\nz1 = temp;\r\n}\r\nz2 = HFC_inw_nodebug(hc, A_Z2) - hc->Zmin;\r\nZsize = z1 - z2;\r\nif ((dch || test_bit(FLG_HDLC, &bch->Flags)) && f1 != f2)\r\nZsize++;\r\nif (Zsize < 0)\r\nZsize += hc->Zlen;\r\nif (Zsize <= 0)\r\nreturn;\r\nif (bch) {\r\nmaxlen = bchannel_get_rxbuf(bch, Zsize);\r\nif (maxlen < 0) {\r\npr_warning("card%d.B%d: No bufferspace for %d bytes\n",\r\nhc->id + 1, bch->nr, Zsize);\r\nreturn;\r\n}\r\nsp = &bch->rx_skb;\r\nmaxlen = bch->maxlen;\r\n} else {\r\nsp = &dch->rx_skb;\r\nmaxlen = dch->maxlen + 3;\r\nif (*sp == NULL) {\r\n*sp = mI_alloc_skb(maxlen, GFP_ATOMIC);\r\nif (*sp == NULL) {\r\npr_warning("card%d: No mem for dch rx_skb\n",\r\nhc->id + 1);\r\nreturn;\r\n}\r\n}\r\n}\r\nif (dch)\r\nhc->activity_rx |= 1 << hc->chan[ch].port;\r\nif (dch || test_bit(FLG_HDLC, &bch->Flags)) {\r\nif (debug & DEBUG_HFCMULTI_FIFO)\r\nprintk(KERN_DEBUG "%s(card %d): fifo(%d) reading %d "\r\n"bytes (z1=%04x, z2=%04x) HDLC %s (f1=%d, f2=%d) "\r\n"got=%d (again %d)\n", __func__, hc->id + 1, ch,\r\nZsize, z1, z2, (f1 == f2) ? "fragment" : "COMPLETE",\r\nf1, f2, Zsize + (*sp)->len, again);\r\nif ((Zsize + (*sp)->len) > maxlen) {\r\nif (debug & DEBUG_HFCMULTI_FIFO)\r\nprintk(KERN_DEBUG\r\n"%s(card %d): hdlc-frame too large.\n",\r\n__func__, hc->id + 1);\r\nskb_trim(*sp, 0);\r\nHFC_outb_nodebug(hc, R_INC_RES_FIFO, V_RES_F);\r\nHFC_wait_nodebug(hc);\r\nreturn;\r\n}\r\nhc->read_fifo(hc, skb_put(*sp, Zsize), Zsize);\r\nif (f1 != f2) {\r\nHFC_outb_nodebug(hc, R_INC_RES_FIFO, V_INC_F);\r\nHFC_wait_nodebug(hc);\r\nif ((*sp)->len < 4) {\r\nif (debug & DEBUG_HFCMULTI_FIFO)\r\nprintk(KERN_DEBUG\r\n"%s(card %d): Frame below minimum "\r\n"size\n", __func__, hc->id + 1);\r\nskb_trim(*sp, 0);\r\ngoto next_frame;\r\n}\r\nif ((*sp)->data[(*sp)->len - 1]) {\r\nif (debug & DEBUG_HFCMULTI_CRC)\r\nprintk(KERN_DEBUG\r\n"%s: CRC-error\n", __func__);\r\nskb_trim(*sp, 0);\r\ngoto next_frame;\r\n}\r\nskb_trim(*sp, (*sp)->len - 3);\r\nif ((*sp)->len < MISDN_COPY_SIZE) {\r\nskb = *sp;\r\n*sp = mI_alloc_skb(skb->len, GFP_ATOMIC);\r\nif (*sp) {\r\nmemcpy(skb_put(*sp, skb->len),\r\nskb->data, skb->len);\r\nskb_trim(skb, 0);\r\n} else {\r\nprintk(KERN_DEBUG "%s: No mem\n",\r\n__func__);\r\n*sp = skb;\r\nskb = NULL;\r\n}\r\n} else {\r\nskb = NULL;\r\n}\r\nif (debug & DEBUG_HFCMULTI_FIFO) {\r\nprintk(KERN_DEBUG "%s(card %d):",\r\n__func__, hc->id + 1);\r\ntemp = 0;\r\nwhile (temp < (*sp)->len)\r\nprintk(" %02x", (*sp)->data[temp++]);\r\nprintk("\n");\r\n}\r\nif (dch)\r\nrecv_Dchannel(dch);\r\nelse\r\nrecv_Bchannel(bch, MISDN_ID_ANY, false);\r\n*sp = skb;\r\nagain++;\r\ngoto next_frame;\r\n}\r\n} else {\r\nhc->read_fifo(hc, skb_put(*sp, Zsize), Zsize);\r\nif (debug & DEBUG_HFCMULTI_FIFO)\r\nprintk(KERN_DEBUG\r\n"%s(card %d): fifo(%d) reading %d bytes "\r\n"(z1=%04x, z2=%04x) TRANS\n",\r\n__func__, hc->id + 1, ch, Zsize, z1, z2);\r\nrecv_Bchannel(bch, hc->chan[ch].Zfill, false);\r\n}\r\n}\r\nstatic void\r\nsignal_state_up(struct dchannel *dch, int info, char *msg)\r\n{\r\nstruct sk_buff *skb;\r\nint id, data = info;\r\nif (debug & DEBUG_HFCMULTI_STATE)\r\nprintk(KERN_DEBUG "%s: %s\n", __func__, msg);\r\nid = TEI_SAPI | (GROUP_TEI << 8);\r\nskb = _alloc_mISDN_skb(MPH_INFORMATION_IND, id, sizeof(data), &data,\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nrecv_Dchannel_skb(dch, skb);\r\n}\r\nstatic inline void\r\nhandle_timer_irq(struct hfc_multi *hc)\r\n{\r\nint ch, temp;\r\nstruct dchannel *dch;\r\nu_long flags;\r\nif (hc->e1_resync) {\r\nspin_lock_irqsave(&HFClock, flags);\r\nif (hc->e1_resync & 1) {\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG "Enable SYNC_I\n");\r\nHFC_outb(hc, R_SYNC_CTRL, V_EXT_CLK_SYNC);\r\nif (test_bit(HFC_CHIP_RX_SYNC, &hc->chip))\r\nHFC_outb(hc, R_SYNC_OUT, V_SYNC_E1_RX);\r\n}\r\nif (hc->e1_resync & 2) {\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG "Enable jatt PLL\n");\r\nHFC_outb(hc, R_SYNC_CTRL, V_SYNC_OFFS);\r\n}\r\nif (hc->e1_resync & 4) {\r\nif (debug & DEBUG_HFCMULTI_PLXSD)\r\nprintk(KERN_DEBUG\r\n"Enable QUARTZ for HFC-E1\n");\r\nHFC_outb(hc, R_SYNC_CTRL, V_EXT_CLK_SYNC\r\n| V_JATT_OFF);\r\nHFC_outb(hc, R_SYNC_OUT, 0);\r\n}\r\nhc->e1_resync = 0;\r\nspin_unlock_irqrestore(&HFClock, flags);\r\n}\r\nif (hc->ctype != HFC_TYPE_E1 || hc->e1_state == 1)\r\nfor (ch = 0; ch <= 31; ch++) {\r\nif (hc->created[hc->chan[ch].port]) {\r\nhfcmulti_tx(hc, ch);\r\nhfcmulti_rx(hc, ch);\r\nif (hc->chan[ch].dch &&\r\nhc->chan[ch].nt_timer > -1) {\r\ndch = hc->chan[ch].dch;\r\nif (!(--hc->chan[ch].nt_timer)) {\r\nschedule_event(dch,\r\nFLG_PHCHANGE);\r\nif (debug &\r\nDEBUG_HFCMULTI_STATE)\r\nprintk(KERN_DEBUG\r\n"%s: nt_timer at "\r\n"state %x\n",\r\n__func__,\r\ndch->state);\r\n}\r\n}\r\n}\r\n}\r\nif (hc->ctype == HFC_TYPE_E1 && hc->created[0]) {\r\ndch = hc->chan[hc->dnum[0]].dch;\r\ntemp = HFC_inb_nodebug(hc, R_SYNC_STA) & V_SIG_LOS;\r\nhc->chan[hc->dnum[0]].los = temp;\r\nif (test_bit(HFC_CFG_REPORT_LOS, &hc->chan[hc->dnum[0]].cfg)) {\r\nif (!temp && hc->chan[hc->dnum[0]].los)\r\nsignal_state_up(dch, L1_SIGNAL_LOS_ON,\r\n"LOS detected");\r\nif (temp && !hc->chan[hc->dnum[0]].los)\r\nsignal_state_up(dch, L1_SIGNAL_LOS_OFF,\r\n"LOS gone");\r\n}\r\nif (test_bit(HFC_CFG_REPORT_AIS, &hc->chan[hc->dnum[0]].cfg)) {\r\ntemp = HFC_inb_nodebug(hc, R_SYNC_STA) & V_AIS;\r\nif (!temp && hc->chan[hc->dnum[0]].ais)\r\nsignal_state_up(dch, L1_SIGNAL_AIS_ON,\r\n"AIS detected");\r\nif (temp && !hc->chan[hc->dnum[0]].ais)\r\nsignal_state_up(dch, L1_SIGNAL_AIS_OFF,\r\n"AIS gone");\r\nhc->chan[hc->dnum[0]].ais = temp;\r\n}\r\nif (test_bit(HFC_CFG_REPORT_SLIP, &hc->chan[hc->dnum[0]].cfg)) {\r\ntemp = HFC_inb_nodebug(hc, R_SLIP) & V_FOSLIP_RX;\r\nif (!temp && hc->chan[hc->dnum[0]].slip_rx)\r\nsignal_state_up(dch, L1_SIGNAL_SLIP_RX,\r\n" bit SLIP detected RX");\r\nhc->chan[hc->dnum[0]].slip_rx = temp;\r\ntemp = HFC_inb_nodebug(hc, R_SLIP) & V_FOSLIP_TX;\r\nif (!temp && hc->chan[hc->dnum[0]].slip_tx)\r\nsignal_state_up(dch, L1_SIGNAL_SLIP_TX,\r\n" bit SLIP detected TX");\r\nhc->chan[hc->dnum[0]].slip_tx = temp;\r\n}\r\nif (test_bit(HFC_CFG_REPORT_RDI, &hc->chan[hc->dnum[0]].cfg)) {\r\ntemp = HFC_inb_nodebug(hc, R_RX_SL0_0) & V_A;\r\nif (!temp && hc->chan[hc->dnum[0]].rdi)\r\nsignal_state_up(dch, L1_SIGNAL_RDI_ON,\r\n"RDI detected");\r\nif (temp && !hc->chan[hc->dnum[0]].rdi)\r\nsignal_state_up(dch, L1_SIGNAL_RDI_OFF,\r\n"RDI gone");\r\nhc->chan[hc->dnum[0]].rdi = temp;\r\n}\r\ntemp = HFC_inb_nodebug(hc, R_JATT_DIR);\r\nswitch (hc->chan[hc->dnum[0]].sync) {\r\ncase 0:\r\nif ((temp & 0x60) == 0x60) {\r\nif (debug & DEBUG_HFCMULTI_SYNC)\r\nprintk(KERN_DEBUG\r\n"%s: (id=%d) E1 now "\r\n"in clock sync\n",\r\n__func__, hc->id);\r\nHFC_outb(hc, R_RX_OFF,\r\nhc->chan[hc->dnum[0]].jitter | V_RX_INIT);\r\nHFC_outb(hc, R_TX_OFF,\r\nhc->chan[hc->dnum[0]].jitter | V_RX_INIT);\r\nhc->chan[hc->dnum[0]].sync = 1;\r\ngoto check_framesync;\r\n}\r\nbreak;\r\ncase 1:\r\nif ((temp & 0x60) != 0x60) {\r\nif (debug & DEBUG_HFCMULTI_SYNC)\r\nprintk(KERN_DEBUG\r\n"%s: (id=%d) E1 "\r\n"lost clock sync\n",\r\n__func__, hc->id);\r\nhc->chan[hc->dnum[0]].sync = 0;\r\nbreak;\r\n}\r\ncheck_framesync:\r\ntemp = HFC_inb_nodebug(hc, R_SYNC_STA);\r\nif (temp == 0x27) {\r\nif (debug & DEBUG_HFCMULTI_SYNC)\r\nprintk(KERN_DEBUG\r\n"%s: (id=%d) E1 "\r\n"now in frame sync\n",\r\n__func__, hc->id);\r\nhc->chan[hc->dnum[0]].sync = 2;\r\n}\r\nbreak;\r\ncase 2:\r\nif ((temp & 0x60) != 0x60) {\r\nif (debug & DEBUG_HFCMULTI_SYNC)\r\nprintk(KERN_DEBUG\r\n"%s: (id=%d) E1 lost "\r\n"clock & frame sync\n",\r\n__func__, hc->id);\r\nhc->chan[hc->dnum[0]].sync = 0;\r\nbreak;\r\n}\r\ntemp = HFC_inb_nodebug(hc, R_SYNC_STA);\r\nif (temp != 0x27) {\r\nif (debug & DEBUG_HFCMULTI_SYNC)\r\nprintk(KERN_DEBUG\r\n"%s: (id=%d) E1 "\r\n"lost frame sync\n",\r\n__func__, hc->id);\r\nhc->chan[hc->dnum[0]].sync = 1;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (test_bit(HFC_CHIP_WATCHDOG, &hc->chip))\r\nhfcmulti_watchdog(hc);\r\nif (hc->leds)\r\nhfcmulti_leds(hc);\r\n}\r\nstatic void\r\nph_state_irq(struct hfc_multi *hc, u_char r_irq_statech)\r\n{\r\nstruct dchannel *dch;\r\nint ch;\r\nint active;\r\nu_char st_status, temp;\r\nfor (ch = 0; ch <= 31; ch++) {\r\nif (hc->chan[ch].dch) {\r\ndch = hc->chan[ch].dch;\r\nif (r_irq_statech & 1) {\r\nHFC_outb_nodebug(hc, R_ST_SEL,\r\nhc->chan[ch].port);\r\nudelay(1);\r\nst_status = HFC_inb_nodebug(hc, A_ST_RD_STATE);\r\nwhile (st_status != (temp =\r\nHFC_inb_nodebug(hc, A_ST_RD_STATE))) {\r\nif (debug & DEBUG_HFCMULTI_STATE)\r\nprintk(KERN_DEBUG "%s: reread "\r\n"STATE because %d!=%d\n",\r\n__func__, temp,\r\nst_status);\r\nst_status = temp;\r\n}\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip) &&\r\ndch->dev.D.protocol == ISDN_P_TE_S0) {\r\nif (st_status & V_FR_SYNC_ST)\r\nhc->syncronized |=\r\n(1 << hc->chan[ch].port);\r\nelse\r\nhc->syncronized &=\r\n~(1 << hc->chan[ch].port);\r\n}\r\ndch->state = st_status & 0x0f;\r\nif (dch->dev.D.protocol == ISDN_P_NT_S0)\r\nactive = 3;\r\nelse\r\nactive = 7;\r\nif (dch->state == active) {\r\nHFC_outb_nodebug(hc, R_FIFO,\r\n(ch << 1) | 1);\r\nHFC_wait_nodebug(hc);\r\nHFC_outb_nodebug(hc,\r\nR_INC_RES_FIFO, V_RES_F);\r\nHFC_wait_nodebug(hc);\r\ndch->tx_idx = 0;\r\n}\r\nschedule_event(dch, FLG_PHCHANGE);\r\nif (debug & DEBUG_HFCMULTI_STATE)\r\nprintk(KERN_DEBUG\r\n"%s: S/T newstate %x port %d\n",\r\n__func__, dch->state,\r\nhc->chan[ch].port);\r\n}\r\nr_irq_statech >>= 1;\r\n}\r\n}\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip))\r\nplxsd_checksync(hc, 0);\r\n}\r\nstatic void\r\nfifo_irq(struct hfc_multi *hc, int block)\r\n{\r\nint ch, j;\r\nstruct dchannel *dch;\r\nstruct bchannel *bch;\r\nu_char r_irq_fifo_bl;\r\nr_irq_fifo_bl = HFC_inb_nodebug(hc, R_IRQ_FIFO_BL0 + block);\r\nj = 0;\r\nwhile (j < 8) {\r\nch = (block << 2) + (j >> 1);\r\ndch = hc->chan[ch].dch;\r\nbch = hc->chan[ch].bch;\r\nif (((!dch) && (!bch)) || (!hc->created[hc->chan[ch].port])) {\r\nj += 2;\r\ncontinue;\r\n}\r\nif (dch && (r_irq_fifo_bl & (1 << j)) &&\r\ntest_bit(FLG_ACTIVE, &dch->Flags)) {\r\nhfcmulti_tx(hc, ch);\r\nHFC_outb_nodebug(hc, R_FIFO, 0);\r\nHFC_wait_nodebug(hc);\r\n}\r\nif (bch && (r_irq_fifo_bl & (1 << j)) &&\r\ntest_bit(FLG_ACTIVE, &bch->Flags)) {\r\nhfcmulti_tx(hc, ch);\r\nHFC_outb_nodebug(hc, R_FIFO, 0);\r\nHFC_wait_nodebug(hc);\r\n}\r\nj++;\r\nif (dch && (r_irq_fifo_bl & (1 << j)) &&\r\ntest_bit(FLG_ACTIVE, &dch->Flags)) {\r\nhfcmulti_rx(hc, ch);\r\n}\r\nif (bch && (r_irq_fifo_bl & (1 << j)) &&\r\ntest_bit(FLG_ACTIVE, &bch->Flags)) {\r\nhfcmulti_rx(hc, ch);\r\n}\r\nj++;\r\n}\r\n}\r\nstatic irqreturn_t\r\nhfcmulti_interrupt(int intno, void *dev_id)\r\n{\r\n#ifdef IRQCOUNT_DEBUG\r\nstatic int iq1 = 0, iq2 = 0, iq3 = 0, iq4 = 0,\r\niq5 = 0, iq6 = 0, iqcnt = 0;\r\n#endif\r\nstruct hfc_multi *hc = dev_id;\r\nstruct dchannel *dch;\r\nu_char r_irq_statech, status, r_irq_misc, r_irq_oview;\r\nint i;\r\nvoid __iomem *plx_acc;\r\nu_short wval;\r\nu_char e1_syncsta, temp, temp2;\r\nu_long flags;\r\nif (!hc) {\r\nprintk(KERN_ERR "HFC-multi: Spurious interrupt!\n");\r\nreturn IRQ_NONE;\r\n}\r\nspin_lock(&hc->lock);\r\n#ifdef IRQ_DEBUG\r\nif (irqsem)\r\nprintk(KERN_ERR "irq for card %d during irq from "\r\n"card %d, this is no bug.\n", hc->id + 1, irqsem);\r\nirqsem = hc->id + 1;\r\n#endif\r\n#ifdef CONFIG_MISDN_HFCMULTI_8xx\r\nif (hc->immap->im_cpm.cp_pbdat & hc->pb_irqmsk)\r\ngoto irq_notforus;\r\n#endif\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nspin_lock_irqsave(&plx_lock, flags);\r\nplx_acc = hc->plx_membase + PLX_INTCSR;\r\nwval = readw(plx_acc);\r\nspin_unlock_irqrestore(&plx_lock, flags);\r\nif (!(wval & PLX_INTCSR_LINTI1_STATUS))\r\ngoto irq_notforus;\r\n}\r\nstatus = HFC_inb_nodebug(hc, R_STATUS);\r\nr_irq_statech = HFC_inb_nodebug(hc, R_IRQ_STATECH);\r\n#ifdef IRQCOUNT_DEBUG\r\nif (r_irq_statech)\r\niq1++;\r\nif (status & V_DTMF_STA)\r\niq2++;\r\nif (status & V_LOST_STA)\r\niq3++;\r\nif (status & V_EXT_IRQSTA)\r\niq4++;\r\nif (status & V_MISC_IRQSTA)\r\niq5++;\r\nif (status & V_FR_IRQSTA)\r\niq6++;\r\nif (iqcnt++ > 5000) {\r\nprintk(KERN_ERR "iq1:%x iq2:%x iq3:%x iq4:%x iq5:%x iq6:%x\n",\r\niq1, iq2, iq3, iq4, iq5, iq6);\r\niqcnt = 0;\r\n}\r\n#endif\r\nif (!r_irq_statech &&\r\n!(status & (V_DTMF_STA | V_LOST_STA | V_EXT_IRQSTA |\r\nV_MISC_IRQSTA | V_FR_IRQSTA))) {\r\ngoto irq_notforus;\r\n}\r\nhc->irqcnt++;\r\nif (r_irq_statech) {\r\nif (hc->ctype != HFC_TYPE_E1)\r\nph_state_irq(hc, r_irq_statech);\r\n}\r\nif (status & V_EXT_IRQSTA)\r\n;\r\nif (status & V_LOST_STA) {\r\nHFC_outb(hc, R_INC_RES_FIFO, V_RES_LOST);\r\n}\r\nif (status & V_MISC_IRQSTA) {\r\nr_irq_misc = HFC_inb_nodebug(hc, R_IRQ_MISC);\r\nr_irq_misc &= hc->hw.r_irqmsk_misc;\r\nif (r_irq_misc & V_STA_IRQ) {\r\nif (hc->ctype == HFC_TYPE_E1) {\r\ndch = hc->chan[hc->dnum[0]].dch;\r\ne1_syncsta = HFC_inb_nodebug(hc, R_SYNC_STA);\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)\r\n&& hc->e1_getclock) {\r\nif (e1_syncsta & V_FR_SYNC_E1)\r\nhc->syncronized = 1;\r\nelse\r\nhc->syncronized = 0;\r\n}\r\ntemp = HFC_inb_nodebug(hc, R_E1_RD_STA);\r\nwhile (temp != (temp2 =\r\nHFC_inb_nodebug(hc, R_E1_RD_STA))) {\r\nif (debug & DEBUG_HFCMULTI_STATE)\r\nprintk(KERN_DEBUG "%s: reread "\r\n"STATE because %d!=%d\n",\r\n__func__, temp, temp2);\r\ntemp = temp2;\r\n}\r\nif (debug & DEBUG_HFCMULTI_STATE)\r\nprintk(KERN_DEBUG\r\n"%s: E1 (id=%d) newstate %x\n",\r\n__func__, hc->id, temp & 0x7);\r\nfor (i = 0; i < hc->ports; i++) {\r\ndch = hc->chan[hc->dnum[i]].dch;\r\ndch->state = temp & 0x7;\r\nschedule_event(dch, FLG_PHCHANGE);\r\n}\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip))\r\nplxsd_checksync(hc, 0);\r\n}\r\n}\r\nif (r_irq_misc & V_TI_IRQ) {\r\nif (hc->iclock_on)\r\nmISDN_clock_update(hc->iclock, poll, NULL);\r\nhandle_timer_irq(hc);\r\n}\r\nif (r_irq_misc & V_DTMF_IRQ)\r\nhfcmulti_dtmf(hc);\r\nif (r_irq_misc & V_IRQ_PROC) {\r\nstatic int irq_proc_cnt;\r\nif (!irq_proc_cnt++)\r\nprintk(KERN_DEBUG "%s: got V_IRQ_PROC -"\r\n" this should not happen\n", __func__);\r\n}\r\n}\r\nif (status & V_FR_IRQSTA) {\r\nr_irq_oview = HFC_inb_nodebug(hc, R_IRQ_OVIEW);\r\nfor (i = 0; i < 8; i++) {\r\nif (r_irq_oview & (1 << i))\r\nfifo_irq(hc, i);\r\n}\r\n}\r\n#ifdef IRQ_DEBUG\r\nirqsem = 0;\r\n#endif\r\nspin_unlock(&hc->lock);\r\nreturn IRQ_HANDLED;\r\nirq_notforus:\r\n#ifdef IRQ_DEBUG\r\nirqsem = 0;\r\n#endif\r\nspin_unlock(&hc->lock);\r\nreturn IRQ_NONE;\r\n}\r\nstatic void\r\nhfcmulti_dbusy_timer(struct hfc_multi *hc)\r\n{\r\n}\r\nstatic int\r\nmode_hfcmulti(struct hfc_multi *hc, int ch, int protocol, int slot_tx,\r\nint bank_tx, int slot_rx, int bank_rx)\r\n{\r\nint flow_tx = 0, flow_rx = 0, routing = 0;\r\nint oslot_tx, oslot_rx;\r\nint conf;\r\nif (ch < 0 || ch > 31)\r\nreturn -EINVAL;\r\noslot_tx = hc->chan[ch].slot_tx;\r\noslot_rx = hc->chan[ch].slot_rx;\r\nconf = hc->chan[ch].conf;\r\nif (debug & DEBUG_HFCMULTI_MODE)\r\nprintk(KERN_DEBUG\r\n"%s: card %d channel %d protocol %x slot old=%d new=%d "\r\n"bank new=%d (TX) slot old=%d new=%d bank new=%d (RX)\n",\r\n__func__, hc->id, ch, protocol, oslot_tx, slot_tx,\r\nbank_tx, oslot_rx, slot_rx, bank_rx);\r\nif (oslot_tx >= 0 && slot_tx != oslot_tx) {\r\nif (debug & DEBUG_HFCMULTI_MODE)\r\nprintk(KERN_DEBUG "%s: remove from slot %d (TX)\n",\r\n__func__, oslot_tx);\r\nif (hc->slot_owner[oslot_tx << 1] == ch) {\r\nHFC_outb(hc, R_SLOT, oslot_tx << 1);\r\nHFC_outb(hc, A_SL_CFG, 0);\r\nif (hc->ctype != HFC_TYPE_XHFC)\r\nHFC_outb(hc, A_CONF, 0);\r\nhc->slot_owner[oslot_tx << 1] = -1;\r\n} else {\r\nif (debug & DEBUG_HFCMULTI_MODE)\r\nprintk(KERN_DEBUG\r\n"%s: we are not owner of this tx slot "\r\n"anymore, channel %d is.\n",\r\n__func__, hc->slot_owner[oslot_tx << 1]);\r\n}\r\n}\r\nif (oslot_rx >= 0 && slot_rx != oslot_rx) {\r\nif (debug & DEBUG_HFCMULTI_MODE)\r\nprintk(KERN_DEBUG\r\n"%s: remove from slot %d (RX)\n",\r\n__func__, oslot_rx);\r\nif (hc->slot_owner[(oslot_rx << 1) | 1] == ch) {\r\nHFC_outb(hc, R_SLOT, (oslot_rx << 1) | V_SL_DIR);\r\nHFC_outb(hc, A_SL_CFG, 0);\r\nhc->slot_owner[(oslot_rx << 1) | 1] = -1;\r\n} else {\r\nif (debug & DEBUG_HFCMULTI_MODE)\r\nprintk(KERN_DEBUG\r\n"%s: we are not owner of this rx slot "\r\n"anymore, channel %d is.\n",\r\n__func__,\r\nhc->slot_owner[(oslot_rx << 1) | 1]);\r\n}\r\n}\r\nif (slot_tx < 0) {\r\nflow_tx = 0x80;\r\nhc->chan[ch].slot_tx = -1;\r\nhc->chan[ch].bank_tx = 0;\r\n} else {\r\nif (hc->chan[ch].txpending)\r\nflow_tx = 0x80;\r\nelse\r\nflow_tx = 0xc0;\r\nrouting = bank_tx ? 0xc0 : 0x80;\r\nif (conf >= 0 || bank_tx > 1)\r\nrouting = 0x40;\r\nif (debug & DEBUG_HFCMULTI_MODE)\r\nprintk(KERN_DEBUG "%s: put channel %d to slot %d bank"\r\n" %d flow %02x routing %02x conf %d (TX)\n",\r\n__func__, ch, slot_tx, bank_tx,\r\nflow_tx, routing, conf);\r\nHFC_outb(hc, R_SLOT, slot_tx << 1);\r\nHFC_outb(hc, A_SL_CFG, (ch << 1) | routing);\r\nif (hc->ctype != HFC_TYPE_XHFC)\r\nHFC_outb(hc, A_CONF,\r\n(conf < 0) ? 0 : (conf | V_CONF_SL));\r\nhc->slot_owner[slot_tx << 1] = ch;\r\nhc->chan[ch].slot_tx = slot_tx;\r\nhc->chan[ch].bank_tx = bank_tx;\r\n}\r\nif (slot_rx < 0) {\r\nflow_rx = 0x80;\r\nhc->chan[ch].slot_rx = -1;\r\nhc->chan[ch].bank_rx = 0;\r\n} else {\r\nif (hc->chan[ch].txpending)\r\nflow_rx = 0x80;\r\nelse\r\nflow_rx = 0xc0;\r\nrouting = bank_rx ? 0x80 : 0xc0;\r\nif (conf >= 0 || bank_rx > 1)\r\nrouting = 0x40;\r\nif (debug & DEBUG_HFCMULTI_MODE)\r\nprintk(KERN_DEBUG "%s: put channel %d to slot %d bank"\r\n" %d flow %02x routing %02x conf %d (RX)\n",\r\n__func__, ch, slot_rx, bank_rx,\r\nflow_rx, routing, conf);\r\nHFC_outb(hc, R_SLOT, (slot_rx << 1) | V_SL_DIR);\r\nHFC_outb(hc, A_SL_CFG, (ch << 1) | V_CH_DIR | routing);\r\nhc->slot_owner[(slot_rx << 1) | 1] = ch;\r\nhc->chan[ch].slot_rx = slot_rx;\r\nhc->chan[ch].bank_rx = bank_rx;\r\n}\r\nswitch (protocol) {\r\ncase (ISDN_P_NONE):\r\nHFC_outb(hc, R_FIFO, ch << 1);\r\nHFC_wait(hc);\r\nHFC_outb(hc, A_CON_HDLC, flow_tx | 0x00 | V_IFF);\r\nHFC_outb(hc, A_SUBCH_CFG, 0);\r\nHFC_outb(hc, A_IRQ_MSK, 0);\r\nHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\r\nHFC_wait(hc);\r\nHFC_outb(hc, R_FIFO, (ch << 1) | 1);\r\nHFC_wait(hc);\r\nHFC_outb(hc, A_CON_HDLC, flow_rx | 0x00);\r\nHFC_outb(hc, A_SUBCH_CFG, 0);\r\nHFC_outb(hc, A_IRQ_MSK, 0);\r\nHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\r\nHFC_wait(hc);\r\nif (hc->chan[ch].bch && hc->ctype != HFC_TYPE_E1) {\r\nhc->hw.a_st_ctrl0[hc->chan[ch].port] &=\r\n((ch & 0x3) == 0) ? ~V_B1_EN : ~V_B2_EN;\r\nHFC_outb(hc, R_ST_SEL, hc->chan[ch].port);\r\nudelay(1);\r\nHFC_outb(hc, A_ST_CTRL0,\r\nhc->hw.a_st_ctrl0[hc->chan[ch].port]);\r\n}\r\nif (hc->chan[ch].bch) {\r\ntest_and_clear_bit(FLG_HDLC, &hc->chan[ch].bch->Flags);\r\ntest_and_clear_bit(FLG_TRANSPARENT,\r\n&hc->chan[ch].bch->Flags);\r\n}\r\nbreak;\r\ncase (ISDN_P_B_RAW):\r\nif (test_bit(HFC_CHIP_B410P, &hc->chip) &&\r\n(hc->chan[ch].slot_rx < 0) &&\r\n(hc->chan[ch].slot_tx < 0)) {\r\nprintk(KERN_DEBUG\r\n"Setting B-channel %d to echo cancelable "\r\n"state on PCM slot %d\n", ch,\r\n((ch / 4) * 8) + ((ch % 4) * 4) + 1);\r\nprintk(KERN_DEBUG\r\n"Enabling pass through for channel\n");\r\nvpm_out(hc, ch, ((ch / 4) * 8) +\r\n((ch % 4) * 4) + 1, 0x01);\r\nHFC_outb(hc, R_FIFO, (ch << 1));\r\nHFC_wait(hc);\r\nHFC_outb(hc, A_CON_HDLC, 0xc0 | V_HDLC_TRP | V_IFF);\r\nHFC_outb(hc, R_SLOT, (((ch / 4) * 8) +\r\n((ch % 4) * 4) + 1) << 1);\r\nHFC_outb(hc, A_SL_CFG, 0x80 | (ch << 1));\r\nHFC_outb(hc, R_FIFO, 0x20 | (ch << 1) | 1);\r\nHFC_wait(hc);\r\nHFC_outb(hc, A_CON_HDLC, 0x20 | V_HDLC_TRP | V_IFF);\r\nHFC_outb(hc, A_SUBCH_CFG, 0);\r\nHFC_outb(hc, A_IRQ_MSK, 0);\r\nif (hc->chan[ch].protocol != protocol) {\r\nHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\r\nHFC_wait(hc);\r\n}\r\nHFC_outb(hc, R_SLOT, ((((ch / 4) * 8) +\r\n((ch % 4) * 4) + 1) << 1) | 1);\r\nHFC_outb(hc, A_SL_CFG, 0x80 | 0x20 | (ch << 1) | 1);\r\nHFC_outb(hc, R_FIFO, (ch << 1) | 1);\r\nHFC_wait(hc);\r\nHFC_outb(hc, A_CON_HDLC, 0xc0 | V_HDLC_TRP | V_IFF);\r\nHFC_outb(hc, R_SLOT, ((((ch / 4) * 8) +\r\n((ch % 4) * 4)) << 1) | 1);\r\nHFC_outb(hc, A_SL_CFG, 0x80 | 0x40 | (ch << 1) | 1);\r\nHFC_outb(hc, R_FIFO, 0x20 | (ch << 1));\r\nHFC_wait(hc);\r\nHFC_outb(hc, A_CON_HDLC, 0x20 | V_HDLC_TRP | V_IFF);\r\nHFC_outb(hc, A_SUBCH_CFG, 0);\r\nHFC_outb(hc, A_IRQ_MSK, 0);\r\nif (hc->chan[ch].protocol != protocol) {\r\nHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\r\nHFC_wait(hc);\r\n}\r\nHFC_outb_nodebug(hc, A_FIFO_DATA0_NOINC, hc->silence);\r\nHFC_outb(hc, R_SLOT, (((ch / 4) * 8) +\r\n((ch % 4) * 4)) << 1);\r\nHFC_outb(hc, A_SL_CFG, 0x80 | 0x20 | (ch << 1));\r\n} else {\r\nHFC_outb(hc, R_FIFO, ch << 1);\r\nHFC_wait(hc);\r\nif (hc->ctype == HFC_TYPE_XHFC)\r\nHFC_outb(hc, A_CON_HDLC, flow_tx | 0x07 << 2 |\r\nV_HDLC_TRP | V_IFF);\r\nelse\r\nHFC_outb(hc, A_CON_HDLC, flow_tx | 0x00 |\r\nV_HDLC_TRP | V_IFF);\r\nHFC_outb(hc, A_SUBCH_CFG, 0);\r\nHFC_outb(hc, A_IRQ_MSK, 0);\r\nif (hc->chan[ch].protocol != protocol) {\r\nHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\r\nHFC_wait(hc);\r\n}\r\nHFC_outb_nodebug(hc, A_FIFO_DATA0_NOINC, hc->silence);\r\nHFC_outb(hc, R_FIFO, (ch << 1) | 1);\r\nHFC_wait(hc);\r\nif (hc->ctype == HFC_TYPE_XHFC)\r\nHFC_outb(hc, A_CON_HDLC, flow_rx | 0x07 << 2 |\r\nV_HDLC_TRP);\r\nelse\r\nHFC_outb(hc, A_CON_HDLC, flow_rx | 0x00 |\r\nV_HDLC_TRP);\r\nHFC_outb(hc, A_SUBCH_CFG, 0);\r\nHFC_outb(hc, A_IRQ_MSK, 0);\r\nif (hc->chan[ch].protocol != protocol) {\r\nHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\r\nHFC_wait(hc);\r\n}\r\n}\r\nif (hc->ctype != HFC_TYPE_E1) {\r\nhc->hw.a_st_ctrl0[hc->chan[ch].port] |=\r\n((ch & 0x3) == 0) ? V_B1_EN : V_B2_EN;\r\nHFC_outb(hc, R_ST_SEL, hc->chan[ch].port);\r\nudelay(1);\r\nHFC_outb(hc, A_ST_CTRL0,\r\nhc->hw.a_st_ctrl0[hc->chan[ch].port]);\r\n}\r\nif (hc->chan[ch].bch)\r\ntest_and_set_bit(FLG_TRANSPARENT,\r\n&hc->chan[ch].bch->Flags);\r\nbreak;\r\ncase (ISDN_P_B_HDLC):\r\ncase (ISDN_P_TE_S0):\r\ncase (ISDN_P_NT_S0):\r\ncase (ISDN_P_TE_E1):\r\ncase (ISDN_P_NT_E1):\r\nHFC_outb(hc, R_FIFO, ch << 1);\r\nHFC_wait(hc);\r\nif (hc->ctype == HFC_TYPE_E1 || hc->chan[ch].bch) {\r\nHFC_outb(hc, A_CON_HDLC, flow_tx | 0x04);\r\nHFC_outb(hc, A_SUBCH_CFG, 0);\r\n} else {\r\nHFC_outb(hc, A_CON_HDLC, flow_tx | 0x04 | V_IFF);\r\nHFC_outb(hc, A_SUBCH_CFG, 2);\r\n}\r\nHFC_outb(hc, A_IRQ_MSK, V_IRQ);\r\nHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\r\nHFC_wait(hc);\r\nHFC_outb(hc, R_FIFO, (ch << 1) | 1);\r\nHFC_wait(hc);\r\nHFC_outb(hc, A_CON_HDLC, flow_rx | 0x04);\r\nif (hc->ctype == HFC_TYPE_E1 || hc->chan[ch].bch)\r\nHFC_outb(hc, A_SUBCH_CFG, 0);\r\nelse\r\nHFC_outb(hc, A_SUBCH_CFG, 2);\r\nHFC_outb(hc, A_IRQ_MSK, V_IRQ);\r\nHFC_outb(hc, R_INC_RES_FIFO, V_RES_F);\r\nHFC_wait(hc);\r\nif (hc->chan[ch].bch) {\r\ntest_and_set_bit(FLG_HDLC, &hc->chan[ch].bch->Flags);\r\nif (hc->ctype != HFC_TYPE_E1) {\r\nhc->hw.a_st_ctrl0[hc->chan[ch].port] |=\r\n((ch & 0x3) == 0) ? V_B1_EN : V_B2_EN;\r\nHFC_outb(hc, R_ST_SEL, hc->chan[ch].port);\r\nudelay(1);\r\nHFC_outb(hc, A_ST_CTRL0,\r\nhc->hw.a_st_ctrl0[hc->chan[ch].port]);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "%s: protocol not known %x\n",\r\n__func__, protocol);\r\nhc->chan[ch].protocol = ISDN_P_NONE;\r\nreturn -ENOPROTOOPT;\r\n}\r\nhc->chan[ch].protocol = protocol;\r\nreturn 0;\r\n}\r\nstatic void\r\nhfcmulti_pcm(struct hfc_multi *hc, int ch, int slot_tx, int bank_tx,\r\nint slot_rx, int bank_rx)\r\n{\r\nif (slot_tx < 0 || slot_rx < 0 || bank_tx < 0 || bank_rx < 0) {\r\nmode_hfcmulti(hc, ch, hc->chan[ch].protocol, -1, 0, -1, 0);\r\nreturn;\r\n}\r\nmode_hfcmulti(hc, ch, hc->chan[ch].protocol, slot_tx, bank_tx,\r\nslot_rx, bank_rx);\r\n}\r\nstatic void\r\nhfcmulti_conf(struct hfc_multi *hc, int ch, int num)\r\n{\r\nif (num >= 0 && num <= 7)\r\nhc->chan[ch].conf = num;\r\nelse\r\nhc->chan[ch].conf = -1;\r\nmode_hfcmulti(hc, ch, hc->chan[ch].protocol, hc->chan[ch].slot_tx,\r\nhc->chan[ch].bank_tx, hc->chan[ch].slot_rx,\r\nhc->chan[ch].bank_rx);\r\n}\r\nstatic int\r\nhfcm_l1callback(struct dchannel *dch, u_int cmd)\r\n{\r\nstruct hfc_multi *hc = dch->hw;\r\nu_long flags;\r\nswitch (cmd) {\r\ncase INFO3_P8:\r\ncase INFO3_P10:\r\nbreak;\r\ncase HW_RESET_REQ:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nif (hc->ctype == HFC_TYPE_E1) {\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG\r\n"%s: HW_RESET_REQ no BRI\n",\r\n__func__);\r\n} else {\r\nHFC_outb(hc, R_ST_SEL, hc->chan[dch->slot].port);\r\nudelay(1);\r\nHFC_outb(hc, A_ST_WR_STATE, V_ST_LD_STA | 3);\r\nudelay(6);\r\nHFC_outb(hc, A_ST_WR_STATE, 3);\r\nHFC_outb(hc, A_ST_WR_STATE, 3 | (V_ST_ACT * 3));\r\n}\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nl1_event(dch->l1, HW_POWERUP_IND);\r\nbreak;\r\ncase HW_DEACT_REQ:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nif (hc->ctype == HFC_TYPE_E1) {\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG\r\n"%s: HW_DEACT_REQ no BRI\n",\r\n__func__);\r\n} else {\r\nHFC_outb(hc, R_ST_SEL, hc->chan[dch->slot].port);\r\nudelay(1);\r\nHFC_outb(hc, A_ST_WR_STATE, V_ST_ACT * 2);\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nhc->syncronized &=\r\n~(1 << hc->chan[dch->slot].port);\r\nplxsd_checksync(hc, 0);\r\n}\r\n}\r\nskb_queue_purge(&dch->squeue);\r\nif (dch->tx_skb) {\r\ndev_kfree_skb(dch->tx_skb);\r\ndch->tx_skb = NULL;\r\n}\r\ndch->tx_idx = 0;\r\nif (dch->rx_skb) {\r\ndev_kfree_skb(dch->rx_skb);\r\ndch->rx_skb = NULL;\r\n}\r\ntest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\r\nif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\r\ndel_timer(&dch->timer);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nbreak;\r\ncase HW_POWERUP_REQ:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nif (hc->ctype == HFC_TYPE_E1) {\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG\r\n"%s: HW_POWERUP_REQ no BRI\n",\r\n__func__);\r\n} else {\r\nHFC_outb(hc, R_ST_SEL, hc->chan[dch->slot].port);\r\nudelay(1);\r\nHFC_outb(hc, A_ST_WR_STATE, 3 | 0x10);\r\nudelay(6);\r\nHFC_outb(hc, A_ST_WR_STATE, 3);\r\n}\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nbreak;\r\ncase PH_ACTIVATE_IND:\r\ntest_and_set_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\r\nGFP_ATOMIC);\r\nbreak;\r\ncase PH_DEACTIVATE_IND:\r\ntest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\r\nGFP_ATOMIC);\r\nbreak;\r\ndefault:\r\nif (dch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: unknown command %x\n",\r\n__func__, cmd);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nhandle_dmsg(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct hfc_multi *hc = dch->hw;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nint ret = -EINVAL;\r\nunsigned int id;\r\nu_long flags;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nif (skb->len < 1)\r\nbreak;\r\nspin_lock_irqsave(&hc->lock, flags);\r\nret = dchannel_senddata(dch, skb);\r\nif (ret > 0) {\r\nid = hh->id;\r\nhfcmulti_tx(hc, dch->slot);\r\nret = 0;\r\nHFC_outb(hc, R_FIFO, 0);\r\nHFC_wait(hc);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nqueue_ch_frame(ch, PH_DATA_CNF, id, NULL);\r\n} else\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nreturn ret;\r\ncase PH_ACTIVATE_REQ:\r\nif (dch->dev.D.protocol != ISDN_P_TE_S0) {\r\nspin_lock_irqsave(&hc->lock, flags);\r\nret = 0;\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG\r\n"%s: PH_ACTIVATE port %d (0..%d)\n",\r\n__func__, hc->chan[dch->slot].port,\r\nhc->ports - 1);\r\nif (hc->ctype == HFC_TYPE_E1) {\r\nph_state_change(dch);\r\nif (debug & DEBUG_HFCMULTI_STATE)\r\nprintk(KERN_DEBUG\r\n"%s: E1 report state %x \n",\r\n__func__, dch->state);\r\n} else {\r\nHFC_outb(hc, R_ST_SEL,\r\nhc->chan[dch->slot].port);\r\nudelay(1);\r\nHFC_outb(hc, A_ST_WR_STATE, V_ST_LD_STA | 1);\r\nudelay(6);\r\nHFC_outb(hc, A_ST_WR_STATE, 1);\r\nHFC_outb(hc, A_ST_WR_STATE, 1 |\r\n(V_ST_ACT * 3));\r\ndch->state = 1;\r\n}\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\n} else\r\nret = l1_event(dch->l1, hh->prim);\r\nbreak;\r\ncase PH_DEACTIVATE_REQ:\r\ntest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\r\nif (dch->dev.D.protocol != ISDN_P_TE_S0) {\r\nspin_lock_irqsave(&hc->lock, flags);\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG\r\n"%s: PH_DEACTIVATE port %d (0..%d)\n",\r\n__func__, hc->chan[dch->slot].port,\r\nhc->ports - 1);\r\nif (hc->ctype == HFC_TYPE_E1) {\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG\r\n"%s: PH_DEACTIVATE no BRI\n",\r\n__func__);\r\n} else {\r\nHFC_outb(hc, R_ST_SEL,\r\nhc->chan[dch->slot].port);\r\nudelay(1);\r\nHFC_outb(hc, A_ST_WR_STATE, V_ST_ACT * 2);\r\ndch->state = 1;\r\n}\r\nskb_queue_purge(&dch->squeue);\r\nif (dch->tx_skb) {\r\ndev_kfree_skb(dch->tx_skb);\r\ndch->tx_skb = NULL;\r\n}\r\ndch->tx_idx = 0;\r\nif (dch->rx_skb) {\r\ndev_kfree_skb(dch->rx_skb);\r\ndch->rx_skb = NULL;\r\n}\r\ntest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\r\nif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\r\ndel_timer(&dch->timer);\r\n#ifdef FIXME\r\nif (test_and_clear_bit(FLG_L1_BUSY, &dch->Flags))\r\ndchannel_sched_event(&hc->dch, D_CLEARBUSY);\r\n#endif\r\nret = 0;\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\n} else\r\nret = l1_event(dch->l1, hh->prim);\r\nbreak;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic void\r\ndeactivate_bchannel(struct bchannel *bch)\r\n{\r\nstruct hfc_multi *hc = bch->hw;\r\nu_long flags;\r\nspin_lock_irqsave(&hc->lock, flags);\r\nmISDN_clear_bchannel(bch);\r\nhc->chan[bch->slot].coeff_count = 0;\r\nhc->chan[bch->slot].rx_off = 0;\r\nhc->chan[bch->slot].conf = -1;\r\nmode_hfcmulti(hc, bch->slot, ISDN_P_NONE, -1, 0, -1, 0);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\n}\r\nstatic int\r\nhandle_bmsg(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct hfc_multi *hc = bch->hw;\r\nint ret = -EINVAL;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nunsigned long flags;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nif (!skb->len)\r\nbreak;\r\nspin_lock_irqsave(&hc->lock, flags);\r\nret = bchannel_senddata(bch, skb);\r\nif (ret > 0) {\r\nhfcmulti_tx(hc, bch->slot);\r\nret = 0;\r\nHFC_outb_nodebug(hc, R_FIFO, 0);\r\nHFC_wait_nodebug(hc);\r\n}\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nreturn ret;\r\ncase PH_ACTIVATE_REQ:\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG "%s: PH_ACTIVATE ch %d (0..32)\n",\r\n__func__, bch->slot);\r\nspin_lock_irqsave(&hc->lock, flags);\r\nif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags)) {\r\nhc->chan[bch->slot].txpending = 0;\r\nret = mode_hfcmulti(hc, bch->slot,\r\nch->protocol,\r\nhc->chan[bch->slot].slot_tx,\r\nhc->chan[bch->slot].bank_tx,\r\nhc->chan[bch->slot].slot_rx,\r\nhc->chan[bch->slot].bank_rx);\r\nif (!ret) {\r\nif (ch->protocol == ISDN_P_B_RAW && !hc->dtmf\r\n&& test_bit(HFC_CHIP_DTMF, &hc->chip)) {\r\nhc->dtmf = 1;\r\nif (debug & DEBUG_HFCMULTI_DTMF)\r\nprintk(KERN_DEBUG\r\n"%s: start dtmf decoder\n",\r\n__func__);\r\nHFC_outb(hc, R_DTMF, hc->hw.r_dtmf |\r\nV_RST_DTMF);\r\n}\r\n}\r\n} else\r\nret = 0;\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nif (!ret)\r\n_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0, NULL,\r\nGFP_KERNEL);\r\nbreak;\r\ncase PH_CONTROL_REQ:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nswitch (hh->id) {\r\ncase HFC_SPL_LOOP_ON:\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG\r\n"%s: HFC_SPL_LOOP_ON (len = %d)\n",\r\n__func__, skb->len);\r\nret = 0;\r\nbreak;\r\ncase HFC_SPL_LOOP_OFF:\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG "%s: HFC_SPL_LOOP_OFF\n",\r\n__func__);\r\nret = 0;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR\r\n"%s: unknown PH_CONTROL_REQ info %x\n",\r\n__func__, hh->id);\r\nret = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nbreak;\r\ncase PH_DEACTIVATE_REQ:\r\ndeactivate_bchannel(bch);\r\n_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0, NULL,\r\nGFP_KERNEL);\r\nret = 0;\r\nbreak;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int\r\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\r\n{\r\nint ret = 0;\r\nstruct dsp_features *features =\r\n(struct dsp_features *)(*((u_long *)&cq->p1));\r\nstruct hfc_multi *hc = bch->hw;\r\nint slot_tx;\r\nint bank_tx;\r\nint slot_rx;\r\nint bank_rx;\r\nint num;\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\nret = mISDN_ctrl_bchannel(bch, cq);\r\ncq->op |= MISDN_CTRL_HFC_OP | MISDN_CTRL_HW_FEATURES_OP;\r\nbreak;\r\ncase MISDN_CTRL_RX_OFF:\r\nret = mISDN_ctrl_bchannel(bch, cq);\r\nhc->chan[bch->slot].rx_off = !!cq->p1;\r\nif (!hc->chan[bch->slot].rx_off) {\r\nHFC_outb_nodebug(hc, R_FIFO, (bch->slot << 1) | 1);\r\nHFC_wait_nodebug(hc);\r\nHFC_outb_nodebug(hc, R_INC_RES_FIFO, V_RES_F);\r\nHFC_wait_nodebug(hc);\r\n}\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG "%s: RX_OFF request (nr=%d off=%d)\n",\r\n__func__, bch->nr, hc->chan[bch->slot].rx_off);\r\nbreak;\r\ncase MISDN_CTRL_FILL_EMPTY:\r\nret = mISDN_ctrl_bchannel(bch, cq);\r\nhc->silence = bch->fill[0];\r\nmemset(hc->silence_data, hc->silence, sizeof(hc->silence_data));\r\nbreak;\r\ncase MISDN_CTRL_HW_FEATURES:\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG "%s: HW_FEATURE request\n",\r\n__func__);\r\nfeatures->hfc_id = hc->id;\r\nif (test_bit(HFC_CHIP_DTMF, &hc->chip))\r\nfeatures->hfc_dtmf = 1;\r\nif (test_bit(HFC_CHIP_CONF, &hc->chip))\r\nfeatures->hfc_conf = 1;\r\nfeatures->hfc_loops = 0;\r\nif (test_bit(HFC_CHIP_B410P, &hc->chip)) {\r\nfeatures->hfc_echocanhw = 1;\r\n} else {\r\nfeatures->pcm_id = hc->pcm;\r\nfeatures->pcm_slots = hc->slots;\r\nfeatures->pcm_banks = 2;\r\n}\r\nbreak;\r\ncase MISDN_CTRL_HFC_PCM_CONN:\r\nslot_tx = cq->p1 & 0xff;\r\nbank_tx = cq->p1 >> 8;\r\nslot_rx = cq->p2 & 0xff;\r\nbank_rx = cq->p2 >> 8;\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG\r\n"%s: HFC_PCM_CONN slot %d bank %d (TX) "\r\n"slot %d bank %d (RX)\n",\r\n__func__, slot_tx, bank_tx,\r\nslot_rx, bank_rx);\r\nif (slot_tx < hc->slots && bank_tx <= 2 &&\r\nslot_rx < hc->slots && bank_rx <= 2)\r\nhfcmulti_pcm(hc, bch->slot,\r\nslot_tx, bank_tx, slot_rx, bank_rx);\r\nelse {\r\nprintk(KERN_WARNING\r\n"%s: HFC_PCM_CONN slot %d bank %d (TX) "\r\n"slot %d bank %d (RX) out of range\n",\r\n__func__, slot_tx, bank_tx,\r\nslot_rx, bank_rx);\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase MISDN_CTRL_HFC_PCM_DISC:\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG "%s: HFC_PCM_DISC\n",\r\n__func__);\r\nhfcmulti_pcm(hc, bch->slot, -1, 0, -1, 0);\r\nbreak;\r\ncase MISDN_CTRL_HFC_CONF_JOIN:\r\nnum = cq->p1 & 0xff;\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG "%s: HFC_CONF_JOIN conf %d\n",\r\n__func__, num);\r\nif (num <= 7)\r\nhfcmulti_conf(hc, bch->slot, num);\r\nelse {\r\nprintk(KERN_WARNING\r\n"%s: HW_CONF_JOIN conf %d out of range\n",\r\n__func__, num);\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase MISDN_CTRL_HFC_CONF_SPLIT:\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG "%s: HFC_CONF_SPLIT\n", __func__);\r\nhfcmulti_conf(hc, bch->slot, -1);\r\nbreak;\r\ncase MISDN_CTRL_HFC_ECHOCAN_ON:\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG "%s: HFC_ECHOCAN_ON\n", __func__);\r\nif (test_bit(HFC_CHIP_B410P, &hc->chip))\r\nvpm_echocan_on(hc, bch->slot, cq->p1);\r\nelse\r\nret = -EINVAL;\r\nbreak;\r\ncase MISDN_CTRL_HFC_ECHOCAN_OFF:\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG "%s: HFC_ECHOCAN_OFF\n",\r\n__func__);\r\nif (test_bit(HFC_CHIP_B410P, &hc->chip))\r\nvpm_echocan_off(hc, bch->slot);\r\nelse\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nret = mISDN_ctrl_bchannel(bch, cq);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nhfcm_bctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct hfc_multi *hc = bch->hw;\r\nint err = -EINVAL;\r\nu_long flags;\r\nif (bch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: cmd:%x %p\n",\r\n__func__, cmd, arg);\r\nswitch (cmd) {\r\ncase CLOSE_CHANNEL:\r\ntest_and_clear_bit(FLG_OPEN, &bch->Flags);\r\ndeactivate_bchannel(bch);\r\nch->protocol = ISDN_P_NONE;\r\nch->peer = NULL;\r\nmodule_put(THIS_MODULE);\r\nerr = 0;\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nerr = channel_bctrl(bch, arg);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: unknown prim(%x)\n",\r\n__func__, cmd);\r\n}\r\nreturn err;\r\n}\r\nstatic void\r\nph_state_change(struct dchannel *dch)\r\n{\r\nstruct hfc_multi *hc;\r\nint ch, i;\r\nif (!dch) {\r\nprintk(KERN_WARNING "%s: ERROR given dch is NULL\n", __func__);\r\nreturn;\r\n}\r\nhc = dch->hw;\r\nch = dch->slot;\r\nif (hc->ctype == HFC_TYPE_E1) {\r\nif (dch->dev.D.protocol == ISDN_P_TE_E1) {\r\nif (debug & DEBUG_HFCMULTI_STATE)\r\nprintk(KERN_DEBUG\r\n"%s: E1 TE (id=%d) newstate %x\n",\r\n__func__, hc->id, dch->state);\r\n} else {\r\nif (debug & DEBUG_HFCMULTI_STATE)\r\nprintk(KERN_DEBUG\r\n"%s: E1 NT (id=%d) newstate %x\n",\r\n__func__, hc->id, dch->state);\r\n}\r\nswitch (dch->state) {\r\ncase (1):\r\nif (hc->e1_state != 1) {\r\nfor (i = 1; i <= 31; i++) {\r\nHFC_outb_nodebug(hc, R_FIFO,\r\n(i << 1) | 1);\r\nHFC_wait_nodebug(hc);\r\nHFC_outb_nodebug(hc, R_INC_RES_FIFO,\r\nV_RES_F);\r\nHFC_wait_nodebug(hc);\r\n}\r\n}\r\ntest_and_set_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, PH_ACTIVATE_IND,\r\nMISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\r\nbreak;\r\ndefault:\r\nif (hc->e1_state != 1)\r\nreturn;\r\ntest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, PH_DEACTIVATE_IND,\r\nMISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\r\n}\r\nhc->e1_state = dch->state;\r\n} else {\r\nif (dch->dev.D.protocol == ISDN_P_TE_S0) {\r\nif (debug & DEBUG_HFCMULTI_STATE)\r\nprintk(KERN_DEBUG\r\n"%s: S/T TE newstate %x\n",\r\n__func__, dch->state);\r\nswitch (dch->state) {\r\ncase (0):\r\nl1_event(dch->l1, HW_RESET_IND);\r\nbreak;\r\ncase (3):\r\nl1_event(dch->l1, HW_DEACT_IND);\r\nbreak;\r\ncase (5):\r\ncase (8):\r\nl1_event(dch->l1, ANYSIGNAL);\r\nbreak;\r\ncase (6):\r\nl1_event(dch->l1, INFO2);\r\nbreak;\r\ncase (7):\r\nl1_event(dch->l1, INFO4_P8);\r\nbreak;\r\n}\r\n} else {\r\nif (debug & DEBUG_HFCMULTI_STATE)\r\nprintk(KERN_DEBUG "%s: S/T NT newstate %x\n",\r\n__func__, dch->state);\r\nswitch (dch->state) {\r\ncase (2):\r\nif (hc->chan[ch].nt_timer == 0) {\r\nhc->chan[ch].nt_timer = -1;\r\nHFC_outb(hc, R_ST_SEL,\r\nhc->chan[ch].port);\r\nudelay(1);\r\nHFC_outb(hc, A_ST_WR_STATE, 4 |\r\nV_ST_LD_STA);\r\nudelay(6);\r\nHFC_outb(hc, A_ST_WR_STATE, 4);\r\ndch->state = 4;\r\n} else {\r\nhc->chan[ch].nt_timer =\r\nnt_t1_count[poll_timer] + 1;\r\nHFC_outb(hc, R_ST_SEL,\r\nhc->chan[ch].port);\r\nudelay(1);\r\nHFC_outb(hc, A_ST_WR_STATE, 2 |\r\nV_SET_G2_G3);\r\n}\r\nbreak;\r\ncase (1):\r\nhc->chan[ch].nt_timer = -1;\r\ntest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, PH_DEACTIVATE_IND,\r\nMISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\r\nbreak;\r\ncase (4):\r\nhc->chan[ch].nt_timer = -1;\r\nbreak;\r\ncase (3):\r\nhc->chan[ch].nt_timer = -1;\r\ntest_and_set_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, PH_ACTIVATE_IND,\r\nMISDN_ID_ANY, 0, NULL, GFP_ATOMIC);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nhfcmulti_initmode(struct dchannel *dch)\r\n{\r\nstruct hfc_multi *hc = dch->hw;\r\nu_char a_st_wr_state, r_e1_wr_sta;\r\nint i, pt;\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: entered\n", __func__);\r\ni = dch->slot;\r\npt = hc->chan[i].port;\r\nif (hc->ctype == HFC_TYPE_E1) {\r\nhc->chan[hc->dnum[pt]].slot_tx = -1;\r\nhc->chan[hc->dnum[pt]].slot_rx = -1;\r\nhc->chan[hc->dnum[pt]].conf = -1;\r\nif (hc->dnum[pt]) {\r\nmode_hfcmulti(hc, dch->slot, dch->dev.D.protocol,\r\n-1, 0, -1, 0);\r\ndch->timer.function = (void *) hfcmulti_dbusy_timer;\r\ndch->timer.data = (long) dch;\r\ninit_timer(&dch->timer);\r\n}\r\nfor (i = 1; i <= 31; i++) {\r\nif (!((1 << i) & hc->bmask[pt]))\r\ncontinue;\r\nhc->chan[i].slot_tx = -1;\r\nhc->chan[i].slot_rx = -1;\r\nhc->chan[i].conf = -1;\r\nmode_hfcmulti(hc, i, ISDN_P_NONE, -1, 0, -1, 0);\r\n}\r\n}\r\nif (hc->ctype == HFC_TYPE_E1 && pt == 0) {\r\ndch = hc->chan[hc->dnum[0]].dch;\r\nif (test_bit(HFC_CFG_REPORT_LOS, &hc->chan[hc->dnum[0]].cfg)) {\r\nHFC_outb(hc, R_LOS0, 255);\r\nHFC_outb(hc, R_LOS1, 255);\r\n}\r\nif (test_bit(HFC_CFG_OPTICAL, &hc->chan[hc->dnum[0]].cfg)) {\r\nHFC_outb(hc, R_RX0, 0);\r\nhc->hw.r_tx0 = 0 | V_OUT_EN;\r\n} else {\r\nHFC_outb(hc, R_RX0, 1);\r\nhc->hw.r_tx0 = 1 | V_OUT_EN;\r\n}\r\nhc->hw.r_tx1 = V_ATX | V_NTRI;\r\nHFC_outb(hc, R_TX0, hc->hw.r_tx0);\r\nHFC_outb(hc, R_TX1, hc->hw.r_tx1);\r\nHFC_outb(hc, R_TX_FR0, 0x00);\r\nHFC_outb(hc, R_TX_FR1, 0xf8);\r\nif (test_bit(HFC_CFG_CRC4, &hc->chan[hc->dnum[0]].cfg))\r\nHFC_outb(hc, R_TX_FR2, V_TX_MF | V_TX_E | V_NEG_E);\r\nHFC_outb(hc, R_RX_FR0, V_AUTO_RESYNC | V_AUTO_RECO | 0);\r\nif (test_bit(HFC_CFG_CRC4, &hc->chan[hc->dnum[0]].cfg))\r\nHFC_outb(hc, R_RX_FR1, V_RX_MF | V_RX_MF_SYNC);\r\nif (dch->dev.D.protocol == ISDN_P_NT_E1) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: E1 port is NT-mode\n",\r\n__func__);\r\nr_e1_wr_sta = 0;\r\nhc->e1_getclock = 0;\r\n} else {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: E1 port is TE-mode\n",\r\n__func__);\r\nr_e1_wr_sta = 0;\r\nhc->e1_getclock = 1;\r\n}\r\nif (test_bit(HFC_CHIP_RX_SYNC, &hc->chip))\r\nHFC_outb(hc, R_SYNC_OUT, V_SYNC_E1_RX);\r\nelse\r\nHFC_outb(hc, R_SYNC_OUT, 0);\r\nif (test_bit(HFC_CHIP_E1CLOCK_GET, &hc->chip))\r\nhc->e1_getclock = 1;\r\nif (test_bit(HFC_CHIP_E1CLOCK_PUT, &hc->chip))\r\nhc->e1_getclock = 0;\r\nif (test_bit(HFC_CHIP_PCM_SLAVE, &hc->chip)) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: E1 port is clock master "\r\n"(clock from PCM)\n", __func__);\r\nHFC_outb(hc, R_SYNC_CTRL, V_EXT_CLK_SYNC | V_PCM_SYNC);\r\n} else {\r\nif (hc->e1_getclock) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: E1 port is clock slave "\r\n"(clock to PCM)\n", __func__);\r\nHFC_outb(hc, R_SYNC_CTRL, V_SYNC_OFFS);\r\n} else {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: E1 port is "\r\n"clock master "\r\n"(clock from QUARTZ)\n",\r\n__func__);\r\nHFC_outb(hc, R_SYNC_CTRL, V_EXT_CLK_SYNC |\r\nV_PCM_SYNC | V_JATT_OFF);\r\nHFC_outb(hc, R_SYNC_OUT, 0);\r\n}\r\n}\r\nHFC_outb(hc, R_JATT_ATT, 0x9c);\r\nHFC_outb(hc, R_PWM_MD, V_PWM0_MD);\r\nHFC_outb(hc, R_PWM0, 0x50);\r\nHFC_outb(hc, R_PWM1, 0xff);\r\nHFC_outb(hc, R_E1_WR_STA, r_e1_wr_sta | V_E1_LD_STA);\r\nudelay(6);\r\nHFC_outb(hc, R_E1_WR_STA, r_e1_wr_sta);\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nhc->syncronized = 0;\r\nplxsd_checksync(hc, 0);\r\n}\r\n}\r\nif (hc->ctype != HFC_TYPE_E1) {\r\nhc->chan[i].slot_tx = -1;\r\nhc->chan[i].slot_rx = -1;\r\nhc->chan[i].conf = -1;\r\nmode_hfcmulti(hc, i, dch->dev.D.protocol, -1, 0, -1, 0);\r\ndch->timer.function = (void *) hfcmulti_dbusy_timer;\r\ndch->timer.data = (long) dch;\r\ninit_timer(&dch->timer);\r\nhc->chan[i - 2].slot_tx = -1;\r\nhc->chan[i - 2].slot_rx = -1;\r\nhc->chan[i - 2].conf = -1;\r\nmode_hfcmulti(hc, i - 2, ISDN_P_NONE, -1, 0, -1, 0);\r\nhc->chan[i - 1].slot_tx = -1;\r\nhc->chan[i - 1].slot_rx = -1;\r\nhc->chan[i - 1].conf = -1;\r\nmode_hfcmulti(hc, i - 1, ISDN_P_NONE, -1, 0, -1, 0);\r\nHFC_outb(hc, R_ST_SEL, pt);\r\nudelay(1);\r\nif (dch->dev.D.protocol == ISDN_P_NT_S0) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: ST port %d is NT-mode\n",\r\n__func__, pt);\r\nHFC_outb(hc, A_ST_CLK_DLY, clockdelay_nt);\r\na_st_wr_state = 1;\r\nhc->hw.a_st_ctrl0[pt] = V_ST_MD;\r\n} else {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: ST port %d is TE-mode\n",\r\n__func__, pt);\r\nHFC_outb(hc, A_ST_CLK_DLY, clockdelay_te);\r\na_st_wr_state = 2;\r\nhc->hw.a_st_ctrl0[pt] = 0;\r\n}\r\nif (!test_bit(HFC_CFG_NONCAP_TX, &hc->chan[i].cfg))\r\nhc->hw.a_st_ctrl0[pt] |= V_TX_LI;\r\nif (hc->ctype == HFC_TYPE_XHFC) {\r\nhc->hw.a_st_ctrl0[pt] |= 0x40 ;\r\nHFC_outb(hc, 0x35 ,\r\n0x7c << 1 );\r\n}\r\nHFC_outb(hc, A_ST_CTRL0, hc->hw.a_st_ctrl0[pt]);\r\nif ((dch->dev.D.protocol == ISDN_P_NT_S0) ||\r\ntest_bit(HFC_CFG_DIS_ECHANNEL, &hc->chan[i].cfg))\r\nHFC_outb(hc, A_ST_CTRL1, V_E_IGNO);\r\nelse\r\nHFC_outb(hc, A_ST_CTRL1, 0);\r\nHFC_outb(hc, A_ST_CTRL2, V_B1_RX_EN | V_B2_RX_EN);\r\nHFC_outb(hc, A_ST_WR_STATE, a_st_wr_state | V_ST_LD_STA);\r\nudelay(6);\r\nHFC_outb(hc, A_ST_WR_STATE, a_st_wr_state);\r\nhc->hw.r_sci_msk |= 1 << pt;\r\nHFC_outb(hc, R_SCI_MSK, hc->hw.r_sci_msk);\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nhc->syncronized &=\r\n~(1 << hc->chan[dch->slot].port);\r\nplxsd_checksync(hc, 0);\r\n}\r\n}\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk("%s: done\n", __func__);\r\n}\r\nstatic int\r\nopen_dchannel(struct hfc_multi *hc, struct dchannel *dch,\r\nstruct channel_req *rq)\r\n{\r\nint err = 0;\r\nu_long flags;\r\nif (debug & DEBUG_HW_OPEN)\r\nprintk(KERN_DEBUG "%s: dev(%d) open from %p\n", __func__,\r\ndch->dev.id, __builtin_return_address(0));\r\nif (rq->protocol == ISDN_P_NONE)\r\nreturn -EINVAL;\r\nif ((dch->dev.D.protocol != ISDN_P_NONE) &&\r\n(dch->dev.D.protocol != rq->protocol)) {\r\nif (debug & DEBUG_HFCMULTI_MODE)\r\nprintk(KERN_DEBUG "%s: change protocol %x to %x\n",\r\n__func__, dch->dev.D.protocol, rq->protocol);\r\n}\r\nif ((dch->dev.D.protocol == ISDN_P_TE_S0) &&\r\n(rq->protocol != ISDN_P_TE_S0))\r\nl1_event(dch->l1, CLOSE_CHANNEL);\r\nif (dch->dev.D.protocol != rq->protocol) {\r\nif (rq->protocol == ISDN_P_TE_S0) {\r\nerr = create_l1(dch, hfcm_l1callback);\r\nif (err)\r\nreturn err;\r\n}\r\ndch->dev.D.protocol = rq->protocol;\r\nspin_lock_irqsave(&hc->lock, flags);\r\nhfcmulti_initmode(dch);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\n}\r\nif (test_bit(FLG_ACTIVE, &dch->Flags))\r\n_queue_data(&dch->dev.D, PH_ACTIVATE_IND, MISDN_ID_ANY,\r\n0, NULL, GFP_KERNEL);\r\nrq->ch = &dch->dev.D;\r\nif (!try_module_get(THIS_MODULE))\r\nprintk(KERN_WARNING "%s:cannot get module\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int\r\nopen_bchannel(struct hfc_multi *hc, struct dchannel *dch,\r\nstruct channel_req *rq)\r\n{\r\nstruct bchannel *bch;\r\nint ch;\r\nif (!test_channelmap(rq->adr.channel, dch->dev.channelmap))\r\nreturn -EINVAL;\r\nif (rq->protocol == ISDN_P_NONE)\r\nreturn -EINVAL;\r\nif (hc->ctype == HFC_TYPE_E1)\r\nch = rq->adr.channel;\r\nelse\r\nch = (rq->adr.channel - 1) + (dch->slot - 2);\r\nbch = hc->chan[ch].bch;\r\nif (!bch) {\r\nprintk(KERN_ERR "%s:internal error ch %d has no bch\n",\r\n__func__, ch);\r\nreturn -EINVAL;\r\n}\r\nif (test_and_set_bit(FLG_OPEN, &bch->Flags))\r\nreturn -EBUSY;\r\nbch->ch.protocol = rq->protocol;\r\nhc->chan[ch].rx_off = 0;\r\nrq->ch = &bch->ch;\r\nif (!try_module_get(THIS_MODULE))\r\nprintk(KERN_WARNING "%s:cannot get module\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int\r\nchannel_dctrl(struct dchannel *dch, struct mISDN_ctrl_req *cq)\r\n{\r\nstruct hfc_multi *hc = dch->hw;\r\nint ret = 0;\r\nint wd_mode, wd_cnt;\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\ncq->op = MISDN_CTRL_HFC_OP | MISDN_CTRL_L1_TIMER3;\r\nbreak;\r\ncase MISDN_CTRL_HFC_WD_INIT:\r\nwd_cnt = cq->p1 & 0xf;\r\nwd_mode = !!(cq->p1 >> 4);\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG "%s: MISDN_CTRL_HFC_WD_INIT mode %s"\r\n", counter 0x%x\n", __func__,\r\nwd_mode ? "AUTO" : "MANUAL", wd_cnt);\r\nHFC_outb(hc, R_TI_WD, poll_timer | (wd_cnt << 4));\r\nhc->hw.r_bert_wd_md = (wd_mode ? V_AUTO_WD_RES : 0);\r\nif (hc->ctype == HFC_TYPE_XHFC)\r\nhc->hw.r_bert_wd_md |= 0x40 ;\r\nHFC_outb(hc, R_BERT_WD_MD, hc->hw.r_bert_wd_md | V_WD_RES);\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nHFC_outb(hc, R_GPIO_SEL, V_GPIO_SEL7);\r\nHFC_outb(hc, R_GPIO_EN1, V_GPIO_EN15);\r\nHFC_outb(hc, R_GPIO_OUT1, 0);\r\nHFC_outb(hc, R_GPIO_OUT1, V_GPIO_OUT15);\r\n}\r\nbreak;\r\ncase MISDN_CTRL_HFC_WD_RESET:\r\nif (debug & DEBUG_HFCMULTI_MSG)\r\nprintk(KERN_DEBUG "%s: MISDN_CTRL_HFC_WD_RESET\n",\r\n__func__);\r\nHFC_outb(hc, R_BERT_WD_MD, hc->hw.r_bert_wd_md | V_WD_RES);\r\nbreak;\r\ncase MISDN_CTRL_L1_TIMER3:\r\nret = l1_event(dch->l1, HW_TIMER3_VALUE | (cq->p1 & 0xff));\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: unknown Op %x\n",\r\n__func__, cq->op);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nhfcm_dctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct hfc_multi *hc = dch->hw;\r\nstruct channel_req *rq;\r\nint err = 0;\r\nu_long flags;\r\nif (dch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: cmd:%x %p\n",\r\n__func__, cmd, arg);\r\nswitch (cmd) {\r\ncase OPEN_CHANNEL:\r\nrq = arg;\r\nswitch (rq->protocol) {\r\ncase ISDN_P_TE_S0:\r\ncase ISDN_P_NT_S0:\r\nif (hc->ctype == HFC_TYPE_E1) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nerr = open_dchannel(hc, dch, rq);\r\nbreak;\r\ncase ISDN_P_TE_E1:\r\ncase ISDN_P_NT_E1:\r\nif (hc->ctype != HFC_TYPE_E1) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nerr = open_dchannel(hc, dch, rq);\r\nbreak;\r\ndefault:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nerr = open_bchannel(hc, dch, rq);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\n}\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\nif (debug & DEBUG_HW_OPEN)\r\nprintk(KERN_DEBUG "%s: dev(%d) close from %p\n",\r\n__func__, dch->dev.id,\r\n__builtin_return_address(0));\r\nmodule_put(THIS_MODULE);\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nspin_lock_irqsave(&hc->lock, flags);\r\nerr = channel_dctrl(dch, arg);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nbreak;\r\ndefault:\r\nif (dch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: unknown command %x\n",\r\n__func__, cmd);\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nclockctl(void *priv, int enable)\r\n{\r\nstruct hfc_multi *hc = priv;\r\nhc->iclock_on = enable;\r\nreturn 0;\r\n}\r\nstatic int\r\ninit_card(struct hfc_multi *hc)\r\n{\r\nint err = -EIO;\r\nu_long flags;\r\nvoid __iomem *plx_acc;\r\nu_long plx_flags;\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: entered\n", __func__);\r\nspin_lock_irqsave(&hc->lock, flags);\r\nhc->hw.r_irq_ctrl = V_FIFO_IRQ;\r\ndisable_hwirq(hc);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nif (request_irq(hc->irq, hfcmulti_interrupt, IRQF_SHARED,\r\n"HFC-multi", hc)) {\r\nprintk(KERN_WARNING "mISDN: Could not get interrupt %d.\n",\r\nhc->irq);\r\nhc->irq = 0;\r\nreturn -EIO;\r\n}\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nspin_lock_irqsave(&plx_lock, plx_flags);\r\nplx_acc = hc->plx_membase + PLX_INTCSR;\r\nwritew((PLX_INTCSR_PCIINT_ENABLE | PLX_INTCSR_LINTI1_ENABLE),\r\nplx_acc);\r\nspin_unlock_irqrestore(&plx_lock, plx_flags);\r\n}\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: IRQ %d count %d\n",\r\n__func__, hc->irq, hc->irqcnt);\r\nerr = init_chip(hc);\r\nif (err)\r\ngoto error;\r\nspin_lock_irqsave(&hc->lock, flags);\r\nenable_hwirq(hc);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout((100 * HZ) / 1000);\r\nspin_lock_irqsave(&hc->lock, flags);\r\ndisable_hwirq(hc);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: IRQ %d count %d\n",\r\n__func__, hc->irq, hc->irqcnt);\r\nif (hc->irqcnt) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: done\n", __func__);\r\nreturn 0;\r\n}\r\nif (test_bit(HFC_CHIP_PCM_SLAVE, &hc->chip)) {\r\nprintk(KERN_INFO "ignoring missing interrupts\n");\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "HFC PCI: IRQ(%d) getting no interrupts during init.\n",\r\nhc->irq);\r\nerr = -EIO;\r\nerror:\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nspin_lock_irqsave(&plx_lock, plx_flags);\r\nplx_acc = hc->plx_membase + PLX_INTCSR;\r\nwritew(0x00, plx_acc);\r\nspin_unlock_irqrestore(&plx_lock, plx_flags);\r\n}\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: free irq %d\n", __func__, hc->irq);\r\nif (hc->irq) {\r\nfree_irq(hc->irq, hc);\r\nhc->irq = 0;\r\n}\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: done (err=%d)\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic int\r\nsetup_pci(struct hfc_multi *hc, struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct hm_map *m = (struct hm_map *)ent->driver_data;\r\nprintk(KERN_INFO\r\n"HFC-multi: card manufacturer: '%s' card name: '%s' clock: %s\n",\r\nm->vendor_name, m->card_name, m->clock2 ? "double" : "normal");\r\nhc->pci_dev = pdev;\r\nif (m->clock2)\r\ntest_and_set_bit(HFC_CHIP_CLOCK2, &hc->chip);\r\nif (ent->device == 0xB410) {\r\ntest_and_set_bit(HFC_CHIP_B410P, &hc->chip);\r\ntest_and_set_bit(HFC_CHIP_PCM_MASTER, &hc->chip);\r\ntest_and_clear_bit(HFC_CHIP_PCM_SLAVE, &hc->chip);\r\nhc->slots = 32;\r\n}\r\nif (hc->pci_dev->irq <= 0) {\r\nprintk(KERN_WARNING "HFC-multi: No IRQ for PCI card found.\n");\r\nreturn -EIO;\r\n}\r\nif (pci_enable_device(hc->pci_dev)) {\r\nprintk(KERN_WARNING "HFC-multi: Error enabling PCI card.\n");\r\nreturn -EIO;\r\n}\r\nhc->leds = m->leds;\r\nhc->ledstate = 0xAFFEAFFE;\r\nhc->opticalsupport = m->opticalsupport;\r\nhc->pci_iobase = 0;\r\nhc->pci_membase = NULL;\r\nhc->plx_membase = NULL;\r\nif (m->io_mode)\r\nhc->io_mode = m->io_mode;\r\nswitch (hc->io_mode) {\r\ncase HFC_IO_MODE_PLXSD:\r\ntest_and_set_bit(HFC_CHIP_PLXSD, &hc->chip);\r\nhc->slots = 128;\r\nhc->HFC_outb = HFC_outb_pcimem;\r\nhc->HFC_inb = HFC_inb_pcimem;\r\nhc->HFC_inw = HFC_inw_pcimem;\r\nhc->HFC_wait = HFC_wait_pcimem;\r\nhc->read_fifo = read_fifo_pcimem;\r\nhc->write_fifo = write_fifo_pcimem;\r\nhc->plx_origmembase = hc->pci_dev->resource[0].start;\r\nif (!hc->plx_origmembase) {\r\nprintk(KERN_WARNING\r\n"HFC-multi: No IO-Memory for PCI PLX bridge found\n");\r\npci_disable_device(hc->pci_dev);\r\nreturn -EIO;\r\n}\r\nhc->plx_membase = ioremap(hc->plx_origmembase, 0x80);\r\nif (!hc->plx_membase) {\r\nprintk(KERN_WARNING\r\n"HFC-multi: failed to remap plx address space. "\r\n"(internal error)\n");\r\npci_disable_device(hc->pci_dev);\r\nreturn -EIO;\r\n}\r\nprintk(KERN_INFO\r\n"HFC-multi: plx_membase:%#lx plx_origmembase:%#lx\n",\r\n(u_long)hc->plx_membase, hc->plx_origmembase);\r\nhc->pci_origmembase = hc->pci_dev->resource[2].start;\r\nif (!hc->pci_origmembase) {\r\nprintk(KERN_WARNING\r\n"HFC-multi: No IO-Memory for PCI card found\n");\r\npci_disable_device(hc->pci_dev);\r\nreturn -EIO;\r\n}\r\nhc->pci_membase = ioremap(hc->pci_origmembase, 0x400);\r\nif (!hc->pci_membase) {\r\nprintk(KERN_WARNING "HFC-multi: failed to remap io "\r\n"address space. (internal error)\n");\r\npci_disable_device(hc->pci_dev);\r\nreturn -EIO;\r\n}\r\nprintk(KERN_INFO\r\n"card %d: defined at MEMBASE %#lx (%#lx) IRQ %d HZ %d "\r\n"leds-type %d\n",\r\nhc->id, (u_long)hc->pci_membase, hc->pci_origmembase,\r\nhc->pci_dev->irq, HZ, hc->leds);\r\npci_write_config_word(hc->pci_dev, PCI_COMMAND, PCI_ENA_MEMIO);\r\nbreak;\r\ncase HFC_IO_MODE_PCIMEM:\r\nhc->HFC_outb = HFC_outb_pcimem;\r\nhc->HFC_inb = HFC_inb_pcimem;\r\nhc->HFC_inw = HFC_inw_pcimem;\r\nhc->HFC_wait = HFC_wait_pcimem;\r\nhc->read_fifo = read_fifo_pcimem;\r\nhc->write_fifo = write_fifo_pcimem;\r\nhc->pci_origmembase = hc->pci_dev->resource[1].start;\r\nif (!hc->pci_origmembase) {\r\nprintk(KERN_WARNING\r\n"HFC-multi: No IO-Memory for PCI card found\n");\r\npci_disable_device(hc->pci_dev);\r\nreturn -EIO;\r\n}\r\nhc->pci_membase = ioremap(hc->pci_origmembase, 256);\r\nif (!hc->pci_membase) {\r\nprintk(KERN_WARNING\r\n"HFC-multi: failed to remap io address space. "\r\n"(internal error)\n");\r\npci_disable_device(hc->pci_dev);\r\nreturn -EIO;\r\n}\r\nprintk(KERN_INFO "card %d: defined at MEMBASE %#lx (%#lx) IRQ "\r\n"%d HZ %d leds-type %d\n", hc->id, (u_long)hc->pci_membase,\r\nhc->pci_origmembase, hc->pci_dev->irq, HZ, hc->leds);\r\npci_write_config_word(hc->pci_dev, PCI_COMMAND, PCI_ENA_MEMIO);\r\nbreak;\r\ncase HFC_IO_MODE_REGIO:\r\nhc->HFC_outb = HFC_outb_regio;\r\nhc->HFC_inb = HFC_inb_regio;\r\nhc->HFC_inw = HFC_inw_regio;\r\nhc->HFC_wait = HFC_wait_regio;\r\nhc->read_fifo = read_fifo_regio;\r\nhc->write_fifo = write_fifo_regio;\r\nhc->pci_iobase = (u_int) hc->pci_dev->resource[0].start;\r\nif (!hc->pci_iobase) {\r\nprintk(KERN_WARNING\r\n"HFC-multi: No IO for PCI card found\n");\r\npci_disable_device(hc->pci_dev);\r\nreturn -EIO;\r\n}\r\nif (!request_region(hc->pci_iobase, 8, "hfcmulti")) {\r\nprintk(KERN_WARNING "HFC-multi: failed to request "\r\n"address space at 0x%08lx (internal error)\n",\r\nhc->pci_iobase);\r\npci_disable_device(hc->pci_dev);\r\nreturn -EIO;\r\n}\r\nprintk(KERN_INFO\r\n"%s %s: defined at IOBASE %#x IRQ %d HZ %d leds-type %d\n",\r\nm->vendor_name, m->card_name, (u_int) hc->pci_iobase,\r\nhc->pci_dev->irq, HZ, hc->leds);\r\npci_write_config_word(hc->pci_dev, PCI_COMMAND, PCI_ENA_REGIO);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "HFC-multi: Invalid IO mode.\n");\r\npci_disable_device(hc->pci_dev);\r\nreturn -EIO;\r\n}\r\npci_set_drvdata(hc->pci_dev, hc);\r\nreturn 0;\r\n}\r\nstatic void\r\nrelease_port(struct hfc_multi *hc, struct dchannel *dch)\r\n{\r\nint pt, ci, i = 0;\r\nu_long flags;\r\nstruct bchannel *pb;\r\nci = dch->slot;\r\npt = hc->chan[ci].port;\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: entered for port %d\n",\r\n__func__, pt + 1);\r\nif (pt >= hc->ports) {\r\nprintk(KERN_WARNING "%s: ERROR port out of range (%d).\n",\r\n__func__, pt + 1);\r\nreturn;\r\n}\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: releasing port=%d\n",\r\n__func__, pt + 1);\r\nif (dch->dev.D.protocol == ISDN_P_TE_S0)\r\nl1_event(dch->l1, CLOSE_CHANNEL);\r\nhc->chan[ci].dch = NULL;\r\nif (hc->created[pt]) {\r\nhc->created[pt] = 0;\r\nmISDN_unregister_device(&dch->dev);\r\n}\r\nspin_lock_irqsave(&hc->lock, flags);\r\nif (dch->timer.function) {\r\ndel_timer(&dch->timer);\r\ndch->timer.function = NULL;\r\n}\r\nif (hc->ctype == HFC_TYPE_E1) {\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nhc->syncronized = 0;\r\nplxsd_checksync(hc, 1);\r\n}\r\nfor (i = 0; i <= 31; i++) {\r\nif (!((1 << i) & hc->bmask[pt]))\r\ncontinue;\r\nif (hc->chan[i].bch) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: free port %d channel %d\n",\r\n__func__, hc->chan[i].port + 1, i);\r\npb = hc->chan[i].bch;\r\nhc->chan[i].bch = NULL;\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nmISDN_freebchannel(pb);\r\nkfree(pb);\r\nkfree(hc->chan[i].coeff);\r\nspin_lock_irqsave(&hc->lock, flags);\r\n}\r\n}\r\n} else {\r\nif (test_bit(HFC_CHIP_PLXSD, &hc->chip)) {\r\nhc->syncronized &=\r\n~(1 << hc->chan[ci].port);\r\nplxsd_checksync(hc, 1);\r\n}\r\nif (hc->chan[ci - 2].bch) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: free port %d channel %d\n",\r\n__func__, hc->chan[ci - 2].port + 1,\r\nci - 2);\r\npb = hc->chan[ci - 2].bch;\r\nhc->chan[ci - 2].bch = NULL;\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nmISDN_freebchannel(pb);\r\nkfree(pb);\r\nkfree(hc->chan[ci - 2].coeff);\r\nspin_lock_irqsave(&hc->lock, flags);\r\n}\r\nif (hc->chan[ci - 1].bch) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: free port %d channel %d\n",\r\n__func__, hc->chan[ci - 1].port + 1,\r\nci - 1);\r\npb = hc->chan[ci - 1].bch;\r\nhc->chan[ci - 1].bch = NULL;\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nmISDN_freebchannel(pb);\r\nkfree(pb);\r\nkfree(hc->chan[ci - 1].coeff);\r\nspin_lock_irqsave(&hc->lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: free port %d channel D(%d)\n", __func__,\r\npt+1, ci);\r\nmISDN_freedchannel(dch);\r\nkfree(dch);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: done!\n", __func__);\r\n}\r\nstatic void\r\nrelease_card(struct hfc_multi *hc)\r\n{\r\nu_long flags;\r\nint ch;\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: release card (%d) entered\n",\r\n__func__, hc->id);\r\nif (hc->iclock)\r\nmISDN_unregister_clock(hc->iclock);\r\nspin_lock_irqsave(&hc->lock, flags);\r\ndisable_hwirq(hc);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nudelay(1000);\r\nif (hc->irq) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: free irq %d (hc=%p)\n",\r\n__func__, hc->irq, hc);\r\nfree_irq(hc->irq, hc);\r\nhc->irq = 0;\r\n}\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: disable all channels (d and b)\n",\r\n__func__);\r\nfor (ch = 0; ch <= 31; ch++) {\r\nif (hc->chan[ch].dch)\r\nrelease_port(hc, hc->chan[ch].dch);\r\n}\r\nif (hc->leds)\r\nhfcmulti_leds(hc);\r\nrelease_io_hfcmulti(hc);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: remove instance from list\n",\r\n__func__);\r\nlist_del(&hc->list);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: delete instance\n", __func__);\r\nif (hc == syncmaster)\r\nsyncmaster = NULL;\r\nkfree(hc);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: card successfully removed\n",\r\n__func__);\r\n}\r\nstatic void\r\ninit_e1_port_hw(struct hfc_multi *hc, struct hm_map *m)\r\n{\r\nif (port[Port_cnt] & 0x001) {\r\nif (!m->opticalsupport) {\r\nprintk(KERN_INFO\r\n"This board has no optical "\r\n"support\n");\r\n} else {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: PORT set optical "\r\n"interfacs: card(%d) "\r\n"port(%d)\n",\r\n__func__,\r\nHFC_cnt + 1, 1);\r\ntest_and_set_bit(HFC_CFG_OPTICAL,\r\n&hc->chan[hc->dnum[0]].cfg);\r\n}\r\n}\r\nif (port[Port_cnt] & 0x004) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: PORT set "\r\n"LOS report: card(%d) port(%d)\n",\r\n__func__, HFC_cnt + 1, 1);\r\ntest_and_set_bit(HFC_CFG_REPORT_LOS,\r\n&hc->chan[hc->dnum[0]].cfg);\r\n}\r\nif (port[Port_cnt] & 0x008) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: PORT set "\r\n"AIS report: card(%d) port(%d)\n",\r\n__func__, HFC_cnt + 1, 1);\r\ntest_and_set_bit(HFC_CFG_REPORT_AIS,\r\n&hc->chan[hc->dnum[0]].cfg);\r\n}\r\nif (port[Port_cnt] & 0x010) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: PORT set SLIP report: "\r\n"card(%d) port(%d)\n",\r\n__func__, HFC_cnt + 1, 1);\r\ntest_and_set_bit(HFC_CFG_REPORT_SLIP,\r\n&hc->chan[hc->dnum[0]].cfg);\r\n}\r\nif (port[Port_cnt] & 0x020) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: PORT set RDI report: "\r\n"card(%d) port(%d)\n",\r\n__func__, HFC_cnt + 1, 1);\r\ntest_and_set_bit(HFC_CFG_REPORT_RDI,\r\n&hc->chan[hc->dnum[0]].cfg);\r\n}\r\nif (!(port[Port_cnt] & 0x100)) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: PORT turn on CRC4 report:"\r\n" card(%d) port(%d)\n",\r\n__func__, HFC_cnt + 1, 1);\r\ntest_and_set_bit(HFC_CFG_CRC4,\r\n&hc->chan[hc->dnum[0]].cfg);\r\n} else {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: PORT turn off CRC4"\r\n" report: card(%d) port(%d)\n",\r\n__func__, HFC_cnt + 1, 1);\r\n}\r\nif (port[Port_cnt] & 0x0200) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: PORT force getting clock from "\r\n"E1: card(%d) port(%d)\n",\r\n__func__, HFC_cnt + 1, 1);\r\ntest_and_set_bit(HFC_CHIP_E1CLOCK_GET, &hc->chip);\r\n} else\r\nif (port[Port_cnt] & 0x0400) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: PORT force putting clock to "\r\n"E1: card(%d) port(%d)\n",\r\n__func__, HFC_cnt + 1, 1);\r\ntest_and_set_bit(HFC_CHIP_E1CLOCK_PUT, &hc->chip);\r\n}\r\nif (port[Port_cnt] & 0x0800) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: PORT disable JATT PLL on "\r\n"E1: card(%d) port(%d)\n",\r\n__func__, HFC_cnt + 1, 1);\r\ntest_and_set_bit(HFC_CHIP_RX_SYNC, &hc->chip);\r\n}\r\nif (port[Port_cnt] & 0x3000) {\r\nhc->chan[hc->dnum[0]].jitter = (port[Port_cnt]>>12) & 0x3;\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: PORT set elastic "\r\n"buffer to %d: card(%d) port(%d)\n",\r\n__func__, hc->chan[hc->dnum[0]].jitter,\r\nHFC_cnt + 1, 1);\r\n} else\r\nhc->chan[hc->dnum[0]].jitter = 2;\r\n}\r\nstatic int\r\ninit_e1_port(struct hfc_multi *hc, struct hm_map *m, int pt)\r\n{\r\nstruct dchannel *dch;\r\nstruct bchannel *bch;\r\nint ch, ret = 0;\r\nchar name[MISDN_MAX_IDLEN];\r\nint bcount = 0;\r\ndch = kzalloc(sizeof(struct dchannel), GFP_KERNEL);\r\nif (!dch)\r\nreturn -ENOMEM;\r\ndch->debug = debug;\r\nmISDN_initdchannel(dch, MAX_DFRAME_LEN_L1, ph_state_change);\r\ndch->hw = hc;\r\ndch->dev.Dprotocols = (1 << ISDN_P_TE_E1) | (1 << ISDN_P_NT_E1);\r\ndch->dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\r\n(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\r\ndch->dev.D.send = handle_dmsg;\r\ndch->dev.D.ctrl = hfcm_dctrl;\r\ndch->slot = hc->dnum[pt];\r\nhc->chan[hc->dnum[pt]].dch = dch;\r\nhc->chan[hc->dnum[pt]].port = pt;\r\nhc->chan[hc->dnum[pt]].nt_timer = -1;\r\nfor (ch = 1; ch <= 31; ch++) {\r\nif (!((1 << ch) & hc->bmask[pt]))\r\ncontinue;\r\nbch = kzalloc(sizeof(struct bchannel), GFP_KERNEL);\r\nif (!bch) {\r\nprintk(KERN_ERR "%s: no memory for bchannel\n",\r\n__func__);\r\nret = -ENOMEM;\r\ngoto free_chan;\r\n}\r\nhc->chan[ch].coeff = kzalloc(512, GFP_KERNEL);\r\nif (!hc->chan[ch].coeff) {\r\nprintk(KERN_ERR "%s: no memory for coeffs\n",\r\n__func__);\r\nret = -ENOMEM;\r\nkfree(bch);\r\ngoto free_chan;\r\n}\r\nbch->nr = ch;\r\nbch->slot = ch;\r\nbch->debug = debug;\r\nmISDN_initbchannel(bch, MAX_DATA_MEM, poll >> 1);\r\nbch->hw = hc;\r\nbch->ch.send = handle_bmsg;\r\nbch->ch.ctrl = hfcm_bctrl;\r\nbch->ch.nr = ch;\r\nlist_add(&bch->ch.list, &dch->dev.bchannels);\r\nhc->chan[ch].bch = bch;\r\nhc->chan[ch].port = pt;\r\nset_channelmap(bch->nr, dch->dev.channelmap);\r\nbcount++;\r\n}\r\ndch->dev.nrbchan = bcount;\r\nif (pt == 0)\r\ninit_e1_port_hw(hc, m);\r\nif (hc->ports > 1)\r\nsnprintf(name, MISDN_MAX_IDLEN - 1, "hfc-e1.%d-%d",\r\nHFC_cnt + 1, pt+1);\r\nelse\r\nsnprintf(name, MISDN_MAX_IDLEN - 1, "hfc-e1.%d", HFC_cnt + 1);\r\nret = mISDN_register_device(&dch->dev, &hc->pci_dev->dev, name);\r\nif (ret)\r\ngoto free_chan;\r\nhc->created[pt] = 1;\r\nreturn ret;\r\nfree_chan:\r\nrelease_port(hc, dch);\r\nreturn ret;\r\n}\r\nstatic int\r\ninit_multi_port(struct hfc_multi *hc, int pt)\r\n{\r\nstruct dchannel *dch;\r\nstruct bchannel *bch;\r\nint ch, i, ret = 0;\r\nchar name[MISDN_MAX_IDLEN];\r\ndch = kzalloc(sizeof(struct dchannel), GFP_KERNEL);\r\nif (!dch)\r\nreturn -ENOMEM;\r\ndch->debug = debug;\r\nmISDN_initdchannel(dch, MAX_DFRAME_LEN_L1, ph_state_change);\r\ndch->hw = hc;\r\ndch->dev.Dprotocols = (1 << ISDN_P_TE_S0) | (1 << ISDN_P_NT_S0);\r\ndch->dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\r\n(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\r\ndch->dev.D.send = handle_dmsg;\r\ndch->dev.D.ctrl = hfcm_dctrl;\r\ndch->dev.nrbchan = 2;\r\ni = pt << 2;\r\ndch->slot = i + 2;\r\nhc->chan[i + 2].dch = dch;\r\nhc->chan[i + 2].port = pt;\r\nhc->chan[i + 2].nt_timer = -1;\r\nfor (ch = 0; ch < dch->dev.nrbchan; ch++) {\r\nbch = kzalloc(sizeof(struct bchannel), GFP_KERNEL);\r\nif (!bch) {\r\nprintk(KERN_ERR "%s: no memory for bchannel\n",\r\n__func__);\r\nret = -ENOMEM;\r\ngoto free_chan;\r\n}\r\nhc->chan[i + ch].coeff = kzalloc(512, GFP_KERNEL);\r\nif (!hc->chan[i + ch].coeff) {\r\nprintk(KERN_ERR "%s: no memory for coeffs\n",\r\n__func__);\r\nret = -ENOMEM;\r\nkfree(bch);\r\ngoto free_chan;\r\n}\r\nbch->nr = ch + 1;\r\nbch->slot = i + ch;\r\nbch->debug = debug;\r\nmISDN_initbchannel(bch, MAX_DATA_MEM, poll >> 1);\r\nbch->hw = hc;\r\nbch->ch.send = handle_bmsg;\r\nbch->ch.ctrl = hfcm_bctrl;\r\nbch->ch.nr = ch + 1;\r\nlist_add(&bch->ch.list, &dch->dev.bchannels);\r\nhc->chan[i + ch].bch = bch;\r\nhc->chan[i + ch].port = pt;\r\nset_channelmap(bch->nr, dch->dev.channelmap);\r\n}\r\nif (port[Port_cnt] & 0x001) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: PROTOCOL set master clock: "\r\n"card(%d) port(%d)\n",\r\n__func__, HFC_cnt + 1, pt + 1);\r\nif (dch->dev.D.protocol != ISDN_P_TE_S0) {\r\nprintk(KERN_ERR "Error: Master clock "\r\n"for port(%d) of card(%d) is only"\r\n" possible with TE-mode\n",\r\npt + 1, HFC_cnt + 1);\r\nret = -EINVAL;\r\ngoto free_chan;\r\n}\r\nif (hc->masterclk >= 0) {\r\nprintk(KERN_ERR "Error: Master clock "\r\n"for port(%d) of card(%d) already "\r\n"defined for port(%d)\n",\r\npt + 1, HFC_cnt + 1, hc->masterclk + 1);\r\nret = -EINVAL;\r\ngoto free_chan;\r\n}\r\nhc->masterclk = pt;\r\n}\r\nif (port[Port_cnt] & 0x002) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: PROTOCOL set non capacitive "\r\n"transmitter: card(%d) port(%d)\n",\r\n__func__, HFC_cnt + 1, pt + 1);\r\ntest_and_set_bit(HFC_CFG_NONCAP_TX,\r\n&hc->chan[i + 2].cfg);\r\n}\r\nif (port[Port_cnt] & 0x004) {\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: PROTOCOL disable E-channel: "\r\n"card(%d) port(%d)\n",\r\n__func__, HFC_cnt + 1, pt + 1);\r\ntest_and_set_bit(HFC_CFG_DIS_ECHANNEL,\r\n&hc->chan[i + 2].cfg);\r\n}\r\nif (hc->ctype == HFC_TYPE_XHFC) {\r\nsnprintf(name, MISDN_MAX_IDLEN - 1, "xhfc.%d-%d",\r\nHFC_cnt + 1, pt + 1);\r\nret = mISDN_register_device(&dch->dev, NULL, name);\r\n} else {\r\nsnprintf(name, MISDN_MAX_IDLEN - 1, "hfc-%ds.%d-%d",\r\nhc->ctype, HFC_cnt + 1, pt + 1);\r\nret = mISDN_register_device(&dch->dev, &hc->pci_dev->dev, name);\r\n}\r\nif (ret)\r\ngoto free_chan;\r\nhc->created[pt] = 1;\r\nreturn ret;\r\nfree_chan:\r\nrelease_port(hc, dch);\r\nreturn ret;\r\n}\r\nstatic int\r\nhfcmulti_init(struct hm_map *m, struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint ret_err = 0;\r\nint pt;\r\nstruct hfc_multi *hc;\r\nu_long flags;\r\nu_char dips = 0, pmj = 0;\r\nint i, ch;\r\nu_int maskcheck;\r\nif (HFC_cnt >= MAX_CARDS) {\r\nprintk(KERN_ERR "too many cards (max=%d).\n",\r\nMAX_CARDS);\r\nreturn -EINVAL;\r\n}\r\nif ((type[HFC_cnt] & 0xff) && (type[HFC_cnt] & 0xff) != m->type) {\r\nprintk(KERN_WARNING "HFC-MULTI: Card '%s:%s' type %d found but "\r\n"type[%d] %d was supplied as module parameter\n",\r\nm->vendor_name, m->card_name, m->type, HFC_cnt,\r\ntype[HFC_cnt] & 0xff);\r\nprintk(KERN_WARNING "HFC-MULTI: Load module without parameters "\r\n"first, to see cards and their types.");\r\nreturn -EINVAL;\r\n}\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: Registering %s:%s chip type %d (0x%x)\n",\r\n__func__, m->vendor_name, m->card_name, m->type,\r\ntype[HFC_cnt]);\r\nhc = kzalloc(sizeof(struct hfc_multi), GFP_KERNEL);\r\nif (!hc) {\r\nprintk(KERN_ERR "No kmem for HFC-Multi card\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&hc->lock);\r\nhc->mtyp = m;\r\nhc->ctype = m->type;\r\nhc->ports = m->ports;\r\nhc->id = HFC_cnt;\r\nhc->pcm = pcm[HFC_cnt];\r\nhc->io_mode = iomode[HFC_cnt];\r\nif (hc->ctype == HFC_TYPE_E1 && dmask[E1_cnt]) {\r\npt = 0;\r\nmaskcheck = 0;\r\nfor (ch = 0; ch <= 31; ch++) {\r\nif (!((1 << ch) & dmask[E1_cnt]))\r\ncontinue;\r\nhc->dnum[pt] = ch;\r\nhc->bmask[pt] = bmask[bmask_cnt++];\r\nif ((maskcheck & hc->bmask[pt])\r\n|| (dmask[E1_cnt] & hc->bmask[pt])) {\r\nprintk(KERN_INFO\r\n"HFC-E1 #%d has overlapping B-channels on fragment #%d\n",\r\nE1_cnt + 1, pt);\r\nkfree(hc);\r\nreturn -EINVAL;\r\n}\r\nmaskcheck |= hc->bmask[pt];\r\nprintk(KERN_INFO\r\n"HFC-E1 #%d uses D-channel on slot %d and a B-channel map of 0x%08x\n",\r\nE1_cnt + 1, ch, hc->bmask[pt]);\r\npt++;\r\n}\r\nhc->ports = pt;\r\n}\r\nif (hc->ctype == HFC_TYPE_E1 && !dmask[E1_cnt]) {\r\nhc->dnum[0] = 16;\r\nhc->bmask[0] = 0xfffefffe;\r\nhc->ports = 1;\r\n}\r\nhc->masterclk = -1;\r\nif (type[HFC_cnt] & 0x100) {\r\ntest_and_set_bit(HFC_CHIP_ULAW, &hc->chip);\r\nhc->silence = 0xff;\r\n} else\r\nhc->silence = 0x2a;\r\nif ((poll >> 1) > sizeof(hc->silence_data)) {\r\nprintk(KERN_ERR "HFCMULTI error: silence_data too small, "\r\n"please fix\n");\r\nkfree(hc);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < (poll >> 1); i++)\r\nhc->silence_data[i] = hc->silence;\r\nif (hc->ctype != HFC_TYPE_XHFC) {\r\nif (!(type[HFC_cnt] & 0x200))\r\ntest_and_set_bit(HFC_CHIP_DTMF, &hc->chip);\r\ntest_and_set_bit(HFC_CHIP_CONF, &hc->chip);\r\n}\r\nif (type[HFC_cnt] & 0x800)\r\ntest_and_set_bit(HFC_CHIP_PCM_SLAVE, &hc->chip);\r\nif (type[HFC_cnt] & 0x1000) {\r\ntest_and_set_bit(HFC_CHIP_PCM_MASTER, &hc->chip);\r\ntest_and_clear_bit(HFC_CHIP_PCM_SLAVE, &hc->chip);\r\n}\r\nif (type[HFC_cnt] & 0x4000)\r\ntest_and_set_bit(HFC_CHIP_EXRAM_128, &hc->chip);\r\nif (type[HFC_cnt] & 0x8000)\r\ntest_and_set_bit(HFC_CHIP_EXRAM_512, &hc->chip);\r\nhc->slots = 32;\r\nif (type[HFC_cnt] & 0x10000)\r\nhc->slots = 64;\r\nif (type[HFC_cnt] & 0x20000)\r\nhc->slots = 128;\r\nif (type[HFC_cnt] & 0x80000) {\r\ntest_and_set_bit(HFC_CHIP_WATCHDOG, &hc->chip);\r\nhc->wdcount = 0;\r\nhc->wdbyte = V_GPIO_OUT2;\r\nprintk(KERN_NOTICE "Watchdog enabled\n");\r\n}\r\nif (pdev && ent)\r\nret_err = setup_pci(hc, pdev, ent);\r\nelse\r\n#ifdef CONFIG_MISDN_HFCMULTI_8xx\r\nret_err = setup_embedded(hc, m);\r\n#else\r\n{\r\nprintk(KERN_WARNING "Embedded IO Mode not selected\n");\r\nret_err = -EIO;\r\n}\r\n#endif\r\nif (ret_err) {\r\nif (hc == syncmaster)\r\nsyncmaster = NULL;\r\nkfree(hc);\r\nreturn ret_err;\r\n}\r\nhc->HFC_outb_nodebug = hc->HFC_outb;\r\nhc->HFC_inb_nodebug = hc->HFC_inb;\r\nhc->HFC_inw_nodebug = hc->HFC_inw;\r\nhc->HFC_wait_nodebug = hc->HFC_wait;\r\n#ifdef HFC_REGISTER_DEBUG\r\nhc->HFC_outb = HFC_outb_debug;\r\nhc->HFC_inb = HFC_inb_debug;\r\nhc->HFC_inw = HFC_inw_debug;\r\nhc->HFC_wait = HFC_wait_debug;\r\n#endif\r\nfor (pt = 0; pt < hc->ports; pt++) {\r\nif (Port_cnt >= MAX_PORTS) {\r\nprintk(KERN_ERR "too many ports (max=%d).\n",\r\nMAX_PORTS);\r\nret_err = -EINVAL;\r\ngoto free_card;\r\n}\r\nif (hc->ctype == HFC_TYPE_E1)\r\nret_err = init_e1_port(hc, m, pt);\r\nelse\r\nret_err = init_multi_port(hc, pt);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG\r\n"%s: Registering D-channel, card(%d) port(%d) "\r\n"result %d\n",\r\n__func__, HFC_cnt + 1, pt + 1, ret_err);\r\nif (ret_err) {\r\nwhile (pt) {\r\npt--;\r\nif (hc->ctype == HFC_TYPE_E1)\r\nrelease_port(hc,\r\nhc->chan[hc->dnum[pt]].dch);\r\nelse\r\nrelease_port(hc,\r\nhc->chan[(pt << 2) + 2].dch);\r\n}\r\ngoto free_card;\r\n}\r\nif (hc->ctype != HFC_TYPE_E1)\r\nPort_cnt++;\r\n}\r\nif (hc->ctype == HFC_TYPE_E1) {\r\nPort_cnt++;\r\nE1_cnt++;\r\n}\r\nswitch (m->dip_type) {\r\ncase DIP_4S:\r\ndips = ((~HFC_inb(hc, R_GPIO_IN1) & 0xE0) >> 5) |\r\n((~HFC_inb(hc, R_GPI_IN2) & 0x80) >> 3) |\r\n(~HFC_inb(hc, R_GPI_IN2) & 0x08);\r\npmj = ((HFC_inb(hc, R_GPI_IN3) >> 4) & 0xf);\r\nif (test_bit(HFC_CHIP_B410P, &hc->chip))\r\npmj = ~pmj & 0xf;\r\nprintk(KERN_INFO "%s: %s DIPs(0x%x) jumpers(0x%x)\n",\r\nm->vendor_name, m->card_name, dips, pmj);\r\nbreak;\r\ncase DIP_8S:\r\nHFC_outb(hc, R_BRG_PCM_CFG, 1 | V_PCM_CLK);\r\noutw(0x4000, hc->pci_iobase + 4);\r\ndips = inb(hc->pci_iobase);\r\ndips = inb(hc->pci_iobase);\r\ndips = inb(hc->pci_iobase);\r\ndips = ~inb(hc->pci_iobase) & 0x3F;\r\noutw(0x0, hc->pci_iobase + 4);\r\nHFC_outb(hc, R_BRG_PCM_CFG, V_PCM_CLK);\r\nprintk(KERN_INFO "%s: %s DIPs(0x%x)\n",\r\nm->vendor_name, m->card_name, dips);\r\nbreak;\r\ncase DIP_E1:\r\ndips = (~HFC_inb(hc, R_GPI_IN0) & 0xF0) >> 4;\r\nprintk(KERN_INFO "%s: %s DIPs(0x%x)\n",\r\nm->vendor_name, m->card_name, dips);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&HFClock, flags);\r\nlist_add_tail(&hc->list, &HFClist);\r\nspin_unlock_irqrestore(&HFClock, flags);\r\nif (clock == HFC_cnt + 1)\r\nhc->iclock = mISDN_register_clock("HFCMulti", 0, clockctl, hc);\r\nhc->irq = (m->irq) ? : hc->pci_dev->irq;\r\nret_err = init_card(hc);\r\nif (ret_err) {\r\nprintk(KERN_ERR "init card returns %d\n", ret_err);\r\nrelease_card(hc);\r\nreturn ret_err;\r\n}\r\nspin_lock_irqsave(&hc->lock, flags);\r\nenable_hwirq(hc);\r\nspin_unlock_irqrestore(&hc->lock, flags);\r\nreturn 0;\r\nfree_card:\r\nrelease_io_hfcmulti(hc);\r\nif (hc == syncmaster)\r\nsyncmaster = NULL;\r\nkfree(hc);\r\nreturn ret_err;\r\n}\r\nstatic void __devexit hfc_remove_pci(struct pci_dev *pdev)\r\n{\r\nstruct hfc_multi *card = pci_get_drvdata(pdev);\r\nu_long flags;\r\nif (debug)\r\nprintk(KERN_INFO "removing hfc_multi card vendor:%x "\r\n"device:%x subvendor:%x subdevice:%x\n",\r\npdev->vendor, pdev->device,\r\npdev->subsystem_vendor, pdev->subsystem_device);\r\nif (card) {\r\nspin_lock_irqsave(&HFClock, flags);\r\nrelease_card(card);\r\nspin_unlock_irqrestore(&HFClock, flags);\r\n} else {\r\nif (debug)\r\nprintk(KERN_DEBUG "%s: drvdata already removed\n",\r\n__func__);\r\n}\r\n}\r\nstatic int\r\nhfcmulti_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct hm_map *m = (struct hm_map *)ent->driver_data;\r\nint ret;\r\nif (m == NULL && ent->vendor == PCI_VENDOR_ID_CCD && (\r\nent->device == PCI_DEVICE_ID_CCD_HFC4S ||\r\nent->device == PCI_DEVICE_ID_CCD_HFC8S ||\r\nent->device == PCI_DEVICE_ID_CCD_HFCE1)) {\r\nprintk(KERN_ERR\r\n"Unknown HFC multiport controller (vendor:%04x device:%04x "\r\n"subvendor:%04x subdevice:%04x)\n", pdev->vendor,\r\npdev->device, pdev->subsystem_vendor,\r\npdev->subsystem_device);\r\nprintk(KERN_ERR\r\n"Please contact the driver maintainer for support.\n");\r\nreturn -ENODEV;\r\n}\r\nret = hfcmulti_init(m, pdev, ent);\r\nif (ret)\r\nreturn ret;\r\nHFC_cnt++;\r\nprintk(KERN_INFO "%d devices registered\n", HFC_cnt);\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nHFCmulti_cleanup(void)\r\n{\r\nstruct hfc_multi *card, *next;\r\nlist_for_each_entry_safe(card, next, &HFClist, list)\r\nrelease_card(card);\r\npci_unregister_driver(&hfcmultipci_driver);\r\n}\r\nstatic int __init\r\nHFCmulti_init(void)\r\n{\r\nint err;\r\nint i, xhfc = 0;\r\nstruct hm_map m;\r\nprintk(KERN_INFO "mISDN: HFC-multi driver %s\n", HFC_MULTI_VERSION);\r\n#ifdef IRQ_DEBUG\r\nprintk(KERN_DEBUG "%s: IRQ_DEBUG IS ENABLED!\n", __func__);\r\n#endif\r\nspin_lock_init(&HFClock);\r\nspin_lock_init(&plx_lock);\r\nif (debug & DEBUG_HFCMULTI_INIT)\r\nprintk(KERN_DEBUG "%s: init entered\n", __func__);\r\nswitch (poll) {\r\ncase 0:\r\npoll_timer = 6;\r\npoll = 128;\r\nbreak;\r\ncase 8:\r\npoll_timer = 2;\r\nbreak;\r\ncase 16:\r\npoll_timer = 3;\r\nbreak;\r\ncase 32:\r\npoll_timer = 4;\r\nbreak;\r\ncase 64:\r\npoll_timer = 5;\r\nbreak;\r\ncase 128:\r\npoll_timer = 6;\r\nbreak;\r\ncase 256:\r\npoll_timer = 7;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR\r\n"%s: Wrong poll value (%d).\n", __func__, poll);\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nif (!clock)\r\nclock = 1;\r\nswitch (hwid) {\r\ncase HWID_MINIP4:\r\nxhfc = 1;\r\nm = hfcm_map[31];\r\nbreak;\r\ncase HWID_MINIP8:\r\nxhfc = 2;\r\nm = hfcm_map[31];\r\nbreak;\r\ncase HWID_MINIP16:\r\nxhfc = 4;\r\nm = hfcm_map[31];\r\nbreak;\r\ndefault:\r\nxhfc = 0;\r\n}\r\nfor (i = 0; i < xhfc; ++i) {\r\nerr = hfcmulti_init(&m, NULL, NULL);\r\nif (err) {\r\nprintk(KERN_ERR "error registering embedded driver: "\r\n"%x\n", err);\r\nreturn err;\r\n}\r\nHFC_cnt++;\r\nprintk(KERN_INFO "%d devices registered\n", HFC_cnt);\r\n}\r\nerr = pci_register_driver(&hfcmultipci_driver);\r\nif (err < 0) {\r\nprintk(KERN_ERR "error registering pci driver: %x\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
