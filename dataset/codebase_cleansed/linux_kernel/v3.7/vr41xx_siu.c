void vr41xx_select_siu_interface(siu_interface_t interface)\r\n{\r\nstruct uart_port *port;\r\nunsigned long flags;\r\nuint8_t irsel;\r\nport = &siu_uart_ports[0];\r\nspin_lock_irqsave(&port->lock, flags);\r\nirsel = siu_read(port, SIUIRSEL);\r\nif (interface == SIU_INTERFACE_IRDA)\r\nirsel |= SIRSEL;\r\nelse\r\nirsel &= ~SIRSEL;\r\nsiu_write(port, SIUIRSEL, irsel);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nvoid vr41xx_use_irda(irda_use_t use)\r\n{\r\nstruct uart_port *port;\r\nunsigned long flags;\r\nuint8_t irsel;\r\nport = &siu_uart_ports[0];\r\nspin_lock_irqsave(&port->lock, flags);\r\nirsel = siu_read(port, SIUIRSEL);\r\nif (use == FIR_USE_IRDA)\r\nirsel |= IRUSESEL;\r\nelse\r\nirsel &= ~IRUSESEL;\r\nsiu_write(port, SIUIRSEL, irsel);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nvoid vr41xx_select_irda_module(irda_module_t module, irda_speed_t speed)\r\n{\r\nstruct uart_port *port;\r\nunsigned long flags;\r\nuint8_t irsel;\r\nport = &siu_uart_ports[0];\r\nspin_lock_irqsave(&port->lock, flags);\r\nirsel = siu_read(port, SIUIRSEL);\r\nirsel &= ~(IRMSEL | TMICTX | TMICMODE);\r\nswitch (module) {\r\ncase SHARP_IRDA:\r\nirsel |= IRMSEL_SHARP;\r\nbreak;\r\ncase TEMIC_IRDA:\r\nirsel |= IRMSEL_TEMIC | TMICMODE;\r\nif (speed == IRDA_TX_4MBPS)\r\nirsel |= TMICTX;\r\nbreak;\r\ncase HP_IRDA:\r\nirsel |= IRMSEL_HP;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsiu_write(port, SIUIRSEL, irsel);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic inline void siu_clear_fifo(struct uart_port *port)\r\n{\r\nsiu_write(port, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nsiu_write(port, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR |\r\nUART_FCR_CLEAR_XMIT);\r\nsiu_write(port, UART_FCR, 0);\r\n}\r\nstatic inline unsigned long siu_port_size(struct uart_port *port)\r\n{\r\nswitch (port->type) {\r\ncase PORT_VR41XX_SIU:\r\nreturn 11UL;\r\ncase PORT_VR41XX_DSIU:\r\nreturn 8UL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned int siu_check_type(struct uart_port *port)\r\n{\r\nif (port->line == 0)\r\nreturn PORT_VR41XX_SIU;\r\nif (port->line == 1 && port->irq)\r\nreturn PORT_VR41XX_DSIU;\r\nreturn PORT_UNKNOWN;\r\n}\r\nstatic inline const char *siu_type_name(struct uart_port *port)\r\n{\r\nswitch (port->type) {\r\ncase PORT_VR41XX_SIU:\r\nreturn "SIU";\r\ncase PORT_VR41XX_DSIU:\r\nreturn "DSIU";\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned int siu_tx_empty(struct uart_port *port)\r\n{\r\nuint8_t lsr;\r\nlsr = siu_read(port, UART_LSR);\r\nif (lsr & UART_LSR_TEMT)\r\nreturn TIOCSER_TEMT;\r\nreturn 0;\r\n}\r\nstatic void siu_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nuint8_t mcr = 0;\r\nif (mctrl & TIOCM_DTR)\r\nmcr |= UART_MCR_DTR;\r\nif (mctrl & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (mctrl & TIOCM_OUT1)\r\nmcr |= UART_MCR_OUT1;\r\nif (mctrl & TIOCM_OUT2)\r\nmcr |= UART_MCR_OUT2;\r\nif (mctrl & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nsiu_write(port, UART_MCR, mcr);\r\n}\r\nstatic unsigned int siu_get_mctrl(struct uart_port *port)\r\n{\r\nuint8_t msr;\r\nunsigned int mctrl = 0;\r\nmsr = siu_read(port, UART_MSR);\r\nif (msr & UART_MSR_DCD)\r\nmctrl |= TIOCM_CAR;\r\nif (msr & UART_MSR_RI)\r\nmctrl |= TIOCM_RNG;\r\nif (msr & UART_MSR_DSR)\r\nmctrl |= TIOCM_DSR;\r\nif (msr & UART_MSR_CTS)\r\nmctrl |= TIOCM_CTS;\r\nreturn mctrl;\r\n}\r\nstatic void siu_stop_tx(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nuint8_t ier;\r\nspin_lock_irqsave(&port->lock, flags);\r\nier = siu_read(port, UART_IER);\r\nier &= ~UART_IER_THRI;\r\nsiu_write(port, UART_IER, ier);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void siu_start_tx(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nuint8_t ier;\r\nspin_lock_irqsave(&port->lock, flags);\r\nier = siu_read(port, UART_IER);\r\nier |= UART_IER_THRI;\r\nsiu_write(port, UART_IER, ier);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void siu_stop_rx(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nuint8_t ier;\r\nspin_lock_irqsave(&port->lock, flags);\r\nier = siu_read(port, UART_IER);\r\nier &= ~UART_IER_RLSI;\r\nsiu_write(port, UART_IER, ier);\r\nport->read_status_mask &= ~UART_LSR_DR;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void siu_enable_ms(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nuint8_t ier;\r\nspin_lock_irqsave(&port->lock, flags);\r\nier = siu_read(port, UART_IER);\r\nier |= UART_IER_MSI;\r\nsiu_write(port, UART_IER, ier);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void siu_break_ctl(struct uart_port *port, int ctl)\r\n{\r\nunsigned long flags;\r\nuint8_t lcr;\r\nspin_lock_irqsave(&port->lock, flags);\r\nlcr = siu_read(port, UART_LCR);\r\nif (ctl == -1)\r\nlcr |= UART_LCR_SBC;\r\nelse\r\nlcr &= ~UART_LCR_SBC;\r\nsiu_write(port, UART_LCR, lcr);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic inline void receive_chars(struct uart_port *port, uint8_t *status)\r\n{\r\nstruct tty_struct *tty;\r\nuint8_t lsr, ch;\r\nchar flag;\r\nint max_count = RX_MAX_COUNT;\r\ntty = port->state->port.tty;\r\nlsr = *status;\r\ndo {\r\nch = siu_read(port, UART_RX);\r\nport->icount.rx++;\r\nflag = TTY_NORMAL;\r\n#ifdef CONFIG_SERIAL_VR41XX_CONSOLE\r\nlsr |= lsr_break_flag[port->line];\r\nlsr_break_flag[port->line] = 0;\r\n#endif\r\nif (unlikely(lsr & (UART_LSR_BI | UART_LSR_FE |\r\nUART_LSR_PE | UART_LSR_OE))) {\r\nif (lsr & UART_LSR_BI) {\r\nlsr &= ~(UART_LSR_FE | UART_LSR_PE);\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ngoto ignore_char;\r\n}\r\nif (lsr & UART_LSR_FE)\r\nport->icount.frame++;\r\nif (lsr & UART_LSR_PE)\r\nport->icount.parity++;\r\nif (lsr & UART_LSR_OE)\r\nport->icount.overrun++;\r\nlsr &= port->read_status_mask;\r\nif (lsr & UART_LSR_BI)\r\nflag = TTY_BREAK;\r\nif (lsr & UART_LSR_FE)\r\nflag = TTY_FRAME;\r\nif (lsr & UART_LSR_PE)\r\nflag = TTY_PARITY;\r\n}\r\nif (uart_handle_sysrq_char(port, ch))\r\ngoto ignore_char;\r\nuart_insert_char(port, lsr, UART_LSR_OE, ch, flag);\r\nignore_char:\r\nlsr = siu_read(port, UART_LSR);\r\n} while ((lsr & UART_LSR_DR) && (max_count-- > 0));\r\ntty_flip_buffer_push(tty);\r\n*status = lsr;\r\n}\r\nstatic inline void check_modem_status(struct uart_port *port)\r\n{\r\nuint8_t msr;\r\nmsr = siu_read(port, UART_MSR);\r\nif ((msr & UART_MSR_ANY_DELTA) == 0)\r\nreturn;\r\nif (msr & UART_MSR_DDCD)\r\nuart_handle_dcd_change(port, msr & UART_MSR_DCD);\r\nif (msr & UART_MSR_TERI)\r\nport->icount.rng++;\r\nif (msr & UART_MSR_DDSR)\r\nport->icount.dsr++;\r\nif (msr & UART_MSR_DCTS)\r\nuart_handle_cts_change(port, msr & UART_MSR_CTS);\r\nwake_up_interruptible(&port->state->port.delta_msr_wait);\r\n}\r\nstatic inline void transmit_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit;\r\nint max_count = TX_MAX_COUNT;\r\nxmit = &port->state->xmit;\r\nif (port->x_char) {\r\nsiu_write(port, UART_TX, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nsiu_stop_tx(port);\r\nreturn;\r\n}\r\ndo {\r\nsiu_write(port, UART_TX, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (max_count-- > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\nsiu_stop_tx(port);\r\n}\r\nstatic irqreturn_t siu_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port;\r\nuint8_t iir, lsr;\r\nport = (struct uart_port *)dev_id;\r\niir = siu_read(port, UART_IIR);\r\nif (iir & UART_IIR_NO_INT)\r\nreturn IRQ_NONE;\r\nlsr = siu_read(port, UART_LSR);\r\nif (lsr & UART_LSR_DR)\r\nreceive_chars(port, &lsr);\r\ncheck_modem_status(port);\r\nif (lsr & UART_LSR_THRE)\r\ntransmit_chars(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int siu_startup(struct uart_port *port)\r\n{\r\nint retval;\r\nif (port->membase == NULL)\r\nreturn -ENODEV;\r\nsiu_clear_fifo(port);\r\n(void)siu_read(port, UART_LSR);\r\n(void)siu_read(port, UART_RX);\r\n(void)siu_read(port, UART_IIR);\r\n(void)siu_read(port, UART_MSR);\r\nif (siu_read(port, UART_LSR) == 0xff)\r\nreturn -ENODEV;\r\nretval = request_irq(port->irq, siu_interrupt, 0, siu_type_name(port), port);\r\nif (retval)\r\nreturn retval;\r\nif (port->type == PORT_VR41XX_DSIU)\r\nvr41xx_enable_dsiuint(DSIUINT_ALL);\r\nsiu_write(port, UART_LCR, UART_LCR_WLEN8);\r\nspin_lock_irq(&port->lock);\r\nsiu_set_mctrl(port, port->mctrl);\r\nspin_unlock_irq(&port->lock);\r\nsiu_write(port, UART_IER, UART_IER_RLSI | UART_IER_RDI);\r\n(void)siu_read(port, UART_LSR);\r\n(void)siu_read(port, UART_RX);\r\n(void)siu_read(port, UART_IIR);\r\n(void)siu_read(port, UART_MSR);\r\nreturn 0;\r\n}\r\nstatic void siu_shutdown(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nuint8_t lcr;\r\nsiu_write(port, UART_IER, 0);\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->mctrl &= ~TIOCM_OUT2;\r\nsiu_set_mctrl(port, port->mctrl);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nlcr = siu_read(port, UART_LCR);\r\nlcr &= ~UART_LCR_SBC;\r\nsiu_write(port, UART_LCR, lcr);\r\nsiu_clear_fifo(port);\r\n(void)siu_read(port, UART_RX);\r\nif (port->type == PORT_VR41XX_DSIU)\r\nvr41xx_disable_dsiuint(DSIUINT_ALL);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void siu_set_termios(struct uart_port *port, struct ktermios *new,\r\nstruct ktermios *old)\r\n{\r\ntcflag_t c_cflag, c_iflag;\r\nuint8_t lcr, fcr, ier;\r\nunsigned int baud, quot;\r\nunsigned long flags;\r\nc_cflag = new->c_cflag;\r\nswitch (c_cflag & CSIZE) {\r\ncase CS5:\r\nlcr = UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\nlcr = UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\nlcr = UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\nlcr = UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nif (c_cflag & CSTOPB)\r\nlcr |= UART_LCR_STOP;\r\nif (c_cflag & PARENB)\r\nlcr |= UART_LCR_PARITY;\r\nif ((c_cflag & PARODD) != PARODD)\r\nlcr |= UART_LCR_EPAR;\r\nif (c_cflag & CMSPAR)\r\nlcr |= UART_LCR_SPAR;\r\nbaud = uart_get_baud_rate(port, new, old, 0, port->uartclk/16);\r\nquot = uart_get_divisor(port, baud);\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10;\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, c_cflag, baud);\r\nc_iflag = new->c_iflag;\r\nport->read_status_mask = UART_LSR_THRE | UART_LSR_OE | UART_LSR_DR;\r\nif (c_iflag & INPCK)\r\nport->read_status_mask |= UART_LSR_FE | UART_LSR_PE;\r\nif (c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= UART_LSR_BI;\r\nport->ignore_status_mask = 0;\r\nif (c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UART_LSR_FE | UART_LSR_PE;\r\nif (c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= UART_LSR_BI;\r\nif (c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UART_LSR_OE;\r\n}\r\nif ((c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= UART_LSR_DR;\r\nier = siu_read(port, UART_IER);\r\nier &= ~UART_IER_MSI;\r\nif (UART_ENABLE_MS(port, c_cflag))\r\nier |= UART_IER_MSI;\r\nsiu_write(port, UART_IER, ier);\r\nsiu_write(port, UART_LCR, lcr | UART_LCR_DLAB);\r\nsiu_write(port, UART_DLL, (uint8_t)quot);\r\nsiu_write(port, UART_DLM, (uint8_t)(quot >> 8));\r\nsiu_write(port, UART_LCR, lcr);\r\nsiu_write(port, UART_FCR, fcr);\r\nsiu_set_mctrl(port, port->mctrl);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void siu_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)\r\n{\r\nswitch (state) {\r\ncase 0:\r\nswitch (port->type) {\r\ncase PORT_VR41XX_SIU:\r\nvr41xx_supply_clock(SIU_CLOCK);\r\nbreak;\r\ncase PORT_VR41XX_DSIU:\r\nvr41xx_supply_clock(DSIU_CLOCK);\r\nbreak;\r\n}\r\nbreak;\r\ncase 3:\r\nswitch (port->type) {\r\ncase PORT_VR41XX_SIU:\r\nvr41xx_mask_clock(SIU_CLOCK);\r\nbreak;\r\ncase PORT_VR41XX_DSIU:\r\nvr41xx_mask_clock(DSIU_CLOCK);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic const char *siu_type(struct uart_port *port)\r\n{\r\nreturn siu_type_name(port);\r\n}\r\nstatic void siu_release_port(struct uart_port *port)\r\n{\r\nunsigned long size;\r\nif (port->flags & UPF_IOREMAP) {\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nsize = siu_port_size(port);\r\nrelease_mem_region(port->mapbase, size);\r\n}\r\nstatic int siu_request_port(struct uart_port *port)\r\n{\r\nunsigned long size;\r\nstruct resource *res;\r\nsize = siu_port_size(port);\r\nres = request_mem_region(port->mapbase, size, siu_type_name(port));\r\nif (res == NULL)\r\nreturn -EBUSY;\r\nif (port->flags & UPF_IOREMAP) {\r\nport->membase = ioremap(port->mapbase, size);\r\nif (port->membase == NULL) {\r\nrelease_resource(res);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void siu_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = siu_check_type(port);\r\n(void)siu_request_port(port);\r\n}\r\n}\r\nstatic int siu_verify_port(struct uart_port *port, struct serial_struct *serial)\r\n{\r\nif (port->type != PORT_VR41XX_SIU && port->type != PORT_VR41XX_DSIU)\r\nreturn -EINVAL;\r\nif (port->irq != serial->irq)\r\nreturn -EINVAL;\r\nif (port->iotype != serial->io_type)\r\nreturn -EINVAL;\r\nif (port->mapbase != (unsigned long)serial->iomem_base)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int siu_init_ports(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port;\r\nstruct resource *res;\r\nint *type = pdev->dev.platform_data;\r\nint i;\r\nif (!type)\r\nreturn 0;\r\nport = siu_uart_ports;\r\nfor (i = 0; i < SIU_PORTS_MAX; i++) {\r\nport->type = type[i];\r\nif (port->type == PORT_UNKNOWN)\r\ncontinue;\r\nport->irq = platform_get_irq(pdev, i);\r\nport->uartclk = SIU_BAUD_BASE * 16;\r\nport->fifosize = 16;\r\nport->regshift = 0;\r\nport->iotype = UPIO_MEM;\r\nport->flags = UPF_IOREMAP | UPF_BOOT_AUTOCONF;\r\nport->line = i;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nport->mapbase = res->start;\r\nport++;\r\n}\r\nreturn i;\r\n}\r\nstatic void wait_for_xmitr(struct uart_port *port)\r\n{\r\nint timeout = 10000;\r\nuint8_t lsr, msr;\r\ndo {\r\nlsr = siu_read(port, UART_LSR);\r\nif (lsr & UART_LSR_BI)\r\nlsr_break_flag[port->line] = UART_LSR_BI;\r\nif ((lsr & BOTH_EMPTY) == BOTH_EMPTY)\r\nbreak;\r\n} while (timeout-- > 0);\r\nif (port->flags & UPF_CONS_FLOW) {\r\ntimeout = 1000000;\r\ndo {\r\nmsr = siu_read(port, UART_MSR);\r\nif ((msr & UART_MSR_CTS) != 0)\r\nbreak;\r\n} while (timeout-- > 0);\r\n}\r\n}\r\nstatic void siu_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwait_for_xmitr(port);\r\nsiu_write(port, UART_TX, ch);\r\n}\r\nstatic void siu_console_write(struct console *con, const char *s, unsigned count)\r\n{\r\nstruct uart_port *port;\r\nuint8_t ier;\r\nport = &siu_uart_ports[con->index];\r\nier = siu_read(port, UART_IER);\r\nsiu_write(port, UART_IER, 0);\r\nuart_console_write(port, s, count, siu_console_putchar);\r\nwait_for_xmitr(port);\r\nsiu_write(port, UART_IER, ier);\r\n}\r\nstatic int __init siu_console_setup(struct console *con, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 9600;\r\nint parity = 'n';\r\nint bits = 8;\r\nint flow = 'n';\r\nif (con->index >= SIU_PORTS_MAX)\r\ncon->index = 0;\r\nport = &siu_uart_ports[con->index];\r\nif (port->membase == NULL) {\r\nif (port->mapbase == 0)\r\nreturn -ENODEV;\r\nport->membase = ioremap(port->mapbase, siu_port_size(port));\r\n}\r\nif (port->type == PORT_VR41XX_SIU)\r\nvr41xx_select_siu_interface(SIU_INTERFACE_RS232C);\r\nif (options != NULL)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, con, baud, parity, bits, flow);\r\n}\r\nstatic int __devinit siu_console_init(void)\r\n{\r\nstruct uart_port *port;\r\nint i;\r\nfor (i = 0; i < SIU_PORTS_MAX; i++) {\r\nport = &siu_uart_ports[i];\r\nport->ops = &siu_uart_ops;\r\n}\r\nregister_console(&siu_console);\r\nreturn 0;\r\n}\r\nvoid __init vr41xx_siu_early_setup(struct uart_port *port)\r\n{\r\nif (port->type == PORT_UNKNOWN)\r\nreturn;\r\nsiu_uart_ports[port->line].line = port->line;\r\nsiu_uart_ports[port->line].type = port->type;\r\nsiu_uart_ports[port->line].uartclk = SIU_BAUD_BASE * 16;\r\nsiu_uart_ports[port->line].mapbase = port->mapbase;\r\nsiu_uart_ports[port->line].mapbase = port->mapbase;\r\nsiu_uart_ports[port->line].ops = &siu_uart_ops;\r\n}\r\nstatic int __devinit siu_probe(struct platform_device *dev)\r\n{\r\nstruct uart_port *port;\r\nint num, i, retval;\r\nnum = siu_init_ports(dev);\r\nif (num <= 0)\r\nreturn -ENODEV;\r\nsiu_uart_driver.nr = num;\r\nretval = uart_register_driver(&siu_uart_driver);\r\nif (retval)\r\nreturn retval;\r\nfor (i = 0; i < num; i++) {\r\nport = &siu_uart_ports[i];\r\nport->ops = &siu_uart_ops;\r\nport->dev = &dev->dev;\r\nretval = uart_add_one_port(&siu_uart_driver, port);\r\nif (retval < 0) {\r\nport->dev = NULL;\r\nbreak;\r\n}\r\n}\r\nif (i == 0 && retval < 0) {\r\nuart_unregister_driver(&siu_uart_driver);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devexit siu_remove(struct platform_device *dev)\r\n{\r\nstruct uart_port *port;\r\nint i;\r\nfor (i = 0; i < siu_uart_driver.nr; i++) {\r\nport = &siu_uart_ports[i];\r\nif (port->dev == &dev->dev) {\r\nuart_remove_one_port(&siu_uart_driver, port);\r\nport->dev = NULL;\r\n}\r\n}\r\nuart_unregister_driver(&siu_uart_driver);\r\nreturn 0;\r\n}\r\nstatic int siu_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct uart_port *port;\r\nint i;\r\nfor (i = 0; i < siu_uart_driver.nr; i++) {\r\nport = &siu_uart_ports[i];\r\nif ((port->type == PORT_VR41XX_SIU ||\r\nport->type == PORT_VR41XX_DSIU) && port->dev == &dev->dev)\r\nuart_suspend_port(&siu_uart_driver, port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int siu_resume(struct platform_device *dev)\r\n{\r\nstruct uart_port *port;\r\nint i;\r\nfor (i = 0; i < siu_uart_driver.nr; i++) {\r\nport = &siu_uart_ports[i];\r\nif ((port->type == PORT_VR41XX_SIU ||\r\nport->type == PORT_VR41XX_DSIU) && port->dev == &dev->dev)\r\nuart_resume_port(&siu_uart_driver, port);\r\n}\r\nreturn 0;\r\n}
