static void *vb2_dma_sg_alloc(void *alloc_ctx, unsigned long size)\r\n{\r\nstruct vb2_dma_sg_buf *buf;\r\nint i;\r\nbuf = kzalloc(sizeof *buf, GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->vaddr = NULL;\r\nbuf->write = 0;\r\nbuf->offset = 0;\r\nbuf->sg_desc.size = size;\r\nbuf->sg_desc.num_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nbuf->sg_desc.sglist = vzalloc(buf->sg_desc.num_pages *\r\nsizeof(*buf->sg_desc.sglist));\r\nif (!buf->sg_desc.sglist)\r\ngoto fail_sglist_alloc;\r\nsg_init_table(buf->sg_desc.sglist, buf->sg_desc.num_pages);\r\nbuf->pages = kzalloc(buf->sg_desc.num_pages * sizeof(struct page *),\r\nGFP_KERNEL);\r\nif (!buf->pages)\r\ngoto fail_pages_array_alloc;\r\nfor (i = 0; i < buf->sg_desc.num_pages; ++i) {\r\nbuf->pages[i] = alloc_page(GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN);\r\nif (NULL == buf->pages[i])\r\ngoto fail_pages_alloc;\r\nsg_set_page(&buf->sg_desc.sglist[i],\r\nbuf->pages[i], PAGE_SIZE, 0);\r\n}\r\nbuf->handler.refcount = &buf->refcount;\r\nbuf->handler.put = vb2_dma_sg_put;\r\nbuf->handler.arg = buf;\r\natomic_inc(&buf->refcount);\r\nprintk(KERN_DEBUG "%s: Allocated buffer of %d pages\n",\r\n__func__, buf->sg_desc.num_pages);\r\nreturn buf;\r\nfail_pages_alloc:\r\nwhile (--i >= 0)\r\n__free_page(buf->pages[i]);\r\nkfree(buf->pages);\r\nfail_pages_array_alloc:\r\nvfree(buf->sg_desc.sglist);\r\nfail_sglist_alloc:\r\nkfree(buf);\r\nreturn NULL;\r\n}\r\nstatic void vb2_dma_sg_put(void *buf_priv)\r\n{\r\nstruct vb2_dma_sg_buf *buf = buf_priv;\r\nint i = buf->sg_desc.num_pages;\r\nif (atomic_dec_and_test(&buf->refcount)) {\r\nprintk(KERN_DEBUG "%s: Freeing buffer of %d pages\n", __func__,\r\nbuf->sg_desc.num_pages);\r\nif (buf->vaddr)\r\nvm_unmap_ram(buf->vaddr, buf->sg_desc.num_pages);\r\nvfree(buf->sg_desc.sglist);\r\nwhile (--i >= 0)\r\n__free_page(buf->pages[i]);\r\nkfree(buf->pages);\r\nkfree(buf);\r\n}\r\n}\r\nstatic void *vb2_dma_sg_get_userptr(void *alloc_ctx, unsigned long vaddr,\r\nunsigned long size, int write)\r\n{\r\nstruct vb2_dma_sg_buf *buf;\r\nunsigned long first, last;\r\nint num_pages_from_user, i;\r\nbuf = kzalloc(sizeof *buf, GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->vaddr = NULL;\r\nbuf->write = write;\r\nbuf->offset = vaddr & ~PAGE_MASK;\r\nbuf->sg_desc.size = size;\r\nfirst = (vaddr & PAGE_MASK) >> PAGE_SHIFT;\r\nlast = ((vaddr + size - 1) & PAGE_MASK) >> PAGE_SHIFT;\r\nbuf->sg_desc.num_pages = last - first + 1;\r\nbuf->sg_desc.sglist = vzalloc(\r\nbuf->sg_desc.num_pages * sizeof(*buf->sg_desc.sglist));\r\nif (!buf->sg_desc.sglist)\r\ngoto userptr_fail_sglist_alloc;\r\nsg_init_table(buf->sg_desc.sglist, buf->sg_desc.num_pages);\r\nbuf->pages = kzalloc(buf->sg_desc.num_pages * sizeof(struct page *),\r\nGFP_KERNEL);\r\nif (!buf->pages)\r\ngoto userptr_fail_pages_array_alloc;\r\nnum_pages_from_user = get_user_pages(current, current->mm,\r\nvaddr & PAGE_MASK,\r\nbuf->sg_desc.num_pages,\r\nwrite,\r\n1,\r\nbuf->pages,\r\nNULL);\r\nif (num_pages_from_user != buf->sg_desc.num_pages)\r\ngoto userptr_fail_get_user_pages;\r\nsg_set_page(&buf->sg_desc.sglist[0], buf->pages[0],\r\nPAGE_SIZE - buf->offset, buf->offset);\r\nsize -= PAGE_SIZE - buf->offset;\r\nfor (i = 1; i < buf->sg_desc.num_pages; ++i) {\r\nsg_set_page(&buf->sg_desc.sglist[i], buf->pages[i],\r\nmin_t(size_t, PAGE_SIZE, size), 0);\r\nsize -= min_t(size_t, PAGE_SIZE, size);\r\n}\r\nreturn buf;\r\nuserptr_fail_get_user_pages:\r\nprintk(KERN_DEBUG "get_user_pages requested/got: %d/%d]\n",\r\nnum_pages_from_user, buf->sg_desc.num_pages);\r\nwhile (--num_pages_from_user >= 0)\r\nput_page(buf->pages[num_pages_from_user]);\r\nkfree(buf->pages);\r\nuserptr_fail_pages_array_alloc:\r\nvfree(buf->sg_desc.sglist);\r\nuserptr_fail_sglist_alloc:\r\nkfree(buf);\r\nreturn NULL;\r\n}\r\nstatic void vb2_dma_sg_put_userptr(void *buf_priv)\r\n{\r\nstruct vb2_dma_sg_buf *buf = buf_priv;\r\nint i = buf->sg_desc.num_pages;\r\nprintk(KERN_DEBUG "%s: Releasing userspace buffer of %d pages\n",\r\n__func__, buf->sg_desc.num_pages);\r\nif (buf->vaddr)\r\nvm_unmap_ram(buf->vaddr, buf->sg_desc.num_pages);\r\nwhile (--i >= 0) {\r\nif (buf->write)\r\nset_page_dirty_lock(buf->pages[i]);\r\nput_page(buf->pages[i]);\r\n}\r\nvfree(buf->sg_desc.sglist);\r\nkfree(buf->pages);\r\nkfree(buf);\r\n}\r\nstatic void *vb2_dma_sg_vaddr(void *buf_priv)\r\n{\r\nstruct vb2_dma_sg_buf *buf = buf_priv;\r\nBUG_ON(!buf);\r\nif (!buf->vaddr)\r\nbuf->vaddr = vm_map_ram(buf->pages,\r\nbuf->sg_desc.num_pages,\r\n-1,\r\nPAGE_KERNEL);\r\nreturn buf->vaddr + buf->offset;\r\n}\r\nstatic unsigned int vb2_dma_sg_num_users(void *buf_priv)\r\n{\r\nstruct vb2_dma_sg_buf *buf = buf_priv;\r\nreturn atomic_read(&buf->refcount);\r\n}\r\nstatic int vb2_dma_sg_mmap(void *buf_priv, struct vm_area_struct *vma)\r\n{\r\nstruct vb2_dma_sg_buf *buf = buf_priv;\r\nunsigned long uaddr = vma->vm_start;\r\nunsigned long usize = vma->vm_end - vma->vm_start;\r\nint i = 0;\r\nif (!buf) {\r\nprintk(KERN_ERR "No memory to map\n");\r\nreturn -EINVAL;\r\n}\r\ndo {\r\nint ret;\r\nret = vm_insert_page(vma, uaddr, buf->pages[i++]);\r\nif (ret) {\r\nprintk(KERN_ERR "Remapping memory, error: %d\n", ret);\r\nreturn ret;\r\n}\r\nuaddr += PAGE_SIZE;\r\nusize -= PAGE_SIZE;\r\n} while (usize > 0);\r\nvma->vm_private_data = &buf->handler;\r\nvma->vm_ops = &vb2_common_vm_ops;\r\nvma->vm_ops->open(vma);\r\nreturn 0;\r\n}\r\nstatic void *vb2_dma_sg_cookie(void *buf_priv)\r\n{\r\nstruct vb2_dma_sg_buf *buf = buf_priv;\r\nreturn &buf->sg_desc;\r\n}
