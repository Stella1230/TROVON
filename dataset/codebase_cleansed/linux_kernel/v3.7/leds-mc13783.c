static void mc13783_led_work(struct work_struct *work)\r\n{\r\nstruct mc13783_led *led = container_of(work, struct mc13783_led, work);\r\nint reg = 0;\r\nint mask = 0;\r\nint value = 0;\r\nint bank, off, shift;\r\nswitch (led->id) {\r\ncase MC13783_LED_MD:\r\nreg = MC13783_REG_LED_CONTROL_2;\r\nmask = MC13783_LED_C2_BL_P_MASK << MC13783_LED_C2_MD_P;\r\nvalue = (led->new_brightness >> 4) << MC13783_LED_C2_MD_P;\r\nbreak;\r\ncase MC13783_LED_AD:\r\nreg = MC13783_REG_LED_CONTROL_2;\r\nmask = MC13783_LED_C2_BL_P_MASK << MC13783_LED_C2_AD_P;\r\nvalue = (led->new_brightness >> 4) << MC13783_LED_C2_AD_P;\r\nbreak;\r\ncase MC13783_LED_KP:\r\nreg = MC13783_REG_LED_CONTROL_2;\r\nmask = MC13783_LED_C2_BL_P_MASK << MC13783_LED_C2_KP_P;\r\nvalue = (led->new_brightness >> 4) << MC13783_LED_C2_KP_P;\r\nbreak;\r\ncase MC13783_LED_R1:\r\ncase MC13783_LED_G1:\r\ncase MC13783_LED_B1:\r\ncase MC13783_LED_R2:\r\ncase MC13783_LED_G2:\r\ncase MC13783_LED_B2:\r\ncase MC13783_LED_R3:\r\ncase MC13783_LED_G3:\r\ncase MC13783_LED_B3:\r\noff = led->id - MC13783_LED_R1;\r\nbank = off/3;\r\nreg = MC13783_REG_LED_CONTROL_3 + off/3;\r\nshift = (off - bank * 3) * 5 + MC13783_LED_C3_TC_P;\r\nvalue = (led->new_brightness >> 3) << shift;\r\nmask = MC13783_LED_C3_TC_P_MASK << shift;\r\nbreak;\r\n}\r\nmc13xxx_lock(led->master);\r\nmc13xxx_reg_rmw(led->master, reg, mask, value);\r\nmc13xxx_unlock(led->master);\r\n}\r\nstatic void mc13783_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct mc13783_led *led;\r\nled = container_of(led_cdev, struct mc13783_led, cdev);\r\nled->new_brightness = value;\r\nschedule_work(&led->work);\r\n}\r\nstatic int __devinit mc13783_led_setup(struct mc13783_led *led, int max_current)\r\n{\r\nint shift = 0;\r\nint mask = 0;\r\nint value = 0;\r\nint reg = 0;\r\nint ret, bank;\r\nswitch (led->id) {\r\ncase MC13783_LED_MD:\r\nshift = MC13783_LED_C2_MD_C;\r\nmask = MC13783_LED_C2_BL_C_MASK;\r\nvalue = max_current & MC13783_LED_C2_BL_C_MASK;\r\nreg = MC13783_REG_LED_CONTROL_2;\r\nbreak;\r\ncase MC13783_LED_AD:\r\nshift = MC13783_LED_C2_AD_C;\r\nmask = MC13783_LED_C2_BL_C_MASK;\r\nvalue = max_current & MC13783_LED_C2_BL_C_MASK;\r\nreg = MC13783_REG_LED_CONTROL_2;\r\nbreak;\r\ncase MC13783_LED_KP:\r\nshift = MC13783_LED_C2_KP_C;\r\nmask = MC13783_LED_C2_BL_C_MASK;\r\nvalue = max_current & MC13783_LED_C2_BL_C_MASK;\r\nreg = MC13783_REG_LED_CONTROL_2;\r\nbreak;\r\ncase MC13783_LED_R1:\r\ncase MC13783_LED_G1:\r\ncase MC13783_LED_B1:\r\ncase MC13783_LED_R2:\r\ncase MC13783_LED_G2:\r\ncase MC13783_LED_B2:\r\ncase MC13783_LED_R3:\r\ncase MC13783_LED_G3:\r\ncase MC13783_LED_B3:\r\nbank = (led->id - MC13783_LED_R1)/3;\r\nreg = MC13783_REG_LED_CONTROL_3 + bank;\r\nshift = ((led->id - MC13783_LED_R1) - bank * 3) * 2;\r\nmask = MC13783_LED_Cx_TC_C_MASK;\r\nvalue = max_current & MC13783_LED_Cx_TC_C_MASK;\r\nbreak;\r\n}\r\nmc13xxx_lock(led->master);\r\nret = mc13xxx_reg_rmw(led->master, reg, mask << shift,\r\nvalue << shift);\r\nmc13xxx_unlock(led->master);\r\nreturn ret;\r\n}\r\nstatic int __devinit mc13783_leds_prepare(struct platform_device *pdev)\r\n{\r\nstruct mc13xxx_leds_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct mc13xxx *dev = dev_get_drvdata(pdev->dev.parent);\r\nint ret = 0;\r\nint reg = 0;\r\nmc13xxx_lock(dev);\r\nif (pdata->flags & MC13783_LED_TC1HALF)\r\nreg |= MC13783_LED_C1_TC1HALF_BIT;\r\nif (pdata->flags & MC13783_LED_SLEWLIMTC)\r\nreg |= MC13783_LED_Cx_SLEWLIM_BIT;\r\nret = mc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_1, reg);\r\nif (ret)\r\ngoto out;\r\nreg = (pdata->bl_period & MC13783_LED_Cx_PERIOD_MASK) <<\r\nMC13783_LED_Cx_PERIOD;\r\nif (pdata->flags & MC13783_LED_SLEWLIMBL)\r\nreg |= MC13783_LED_Cx_SLEWLIM_BIT;\r\nret = mc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_2, reg);\r\nif (ret)\r\ngoto out;\r\nreg = (pdata->tc1_period & MC13783_LED_Cx_PERIOD_MASK) <<\r\nMC13783_LED_Cx_PERIOD;\r\nif (pdata->flags & MC13783_LED_TRIODE_TC1)\r\nreg |= MC13783_LED_Cx_TRIODE_TC_BIT;\r\nret = mc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_3, reg);\r\nif (ret)\r\ngoto out;\r\nreg = (pdata->tc2_period & MC13783_LED_Cx_PERIOD_MASK) <<\r\nMC13783_LED_Cx_PERIOD;\r\nif (pdata->flags & MC13783_LED_TRIODE_TC2)\r\nreg |= MC13783_LED_Cx_TRIODE_TC_BIT;\r\nret = mc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_4, reg);\r\nif (ret)\r\ngoto out;\r\nreg = (pdata->tc3_period & MC13783_LED_Cx_PERIOD_MASK) <<\r\nMC13783_LED_Cx_PERIOD;\r\nif (pdata->flags & MC13783_LED_TRIODE_TC3)\r\nreg |= MC13783_LED_Cx_TRIODE_TC_BIT;\r\nret = mc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_5, reg);\r\nif (ret)\r\ngoto out;\r\nreg = MC13783_LED_C0_ENABLE_BIT;\r\nif (pdata->flags & MC13783_LED_TRIODE_MD)\r\nreg |= MC13783_LED_C0_TRIODE_MD_BIT;\r\nif (pdata->flags & MC13783_LED_TRIODE_AD)\r\nreg |= MC13783_LED_C0_TRIODE_AD_BIT;\r\nif (pdata->flags & MC13783_LED_TRIODE_KP)\r\nreg |= MC13783_LED_C0_TRIODE_KP_BIT;\r\nif (pdata->flags & MC13783_LED_BOOST_EN)\r\nreg |= MC13783_LED_C0_BOOST_BIT;\r\nreg |= (pdata->abmode & MC13783_LED_C0_ABMODE_MASK) <<\r\nMC13783_LED_C0_ABMODE;\r\nreg |= (pdata->abref & MC13783_LED_C0_ABREF_MASK) <<\r\nMC13783_LED_C0_ABREF;\r\nret = mc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_0, reg);\r\nout:\r\nmc13xxx_unlock(dev);\r\nreturn ret;\r\n}\r\nstatic int __devinit mc13783_led_probe(struct platform_device *pdev)\r\n{\r\nstruct mc13xxx_leds_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct mc13xxx_led_platform_data *led_cur;\r\nstruct mc13783_led *led, *led_dat;\r\nint ret, i;\r\nint init_led = 0;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "missing platform data\n");\r\nreturn -ENODEV;\r\n}\r\nif (pdata->num_leds < 1 || pdata->num_leds > (MC13783_LED_MAX + 1)) {\r\ndev_err(&pdev->dev, "Invalid led count %d\n", pdata->num_leds);\r\nreturn -EINVAL;\r\n}\r\nled = devm_kzalloc(&pdev->dev, pdata->num_leds * sizeof(*led),\r\nGFP_KERNEL);\r\nif (led == NULL) {\r\ndev_err(&pdev->dev, "failed to alloc memory\n");\r\nreturn -ENOMEM;\r\n}\r\nret = mc13783_leds_prepare(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to init led driver\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < pdata->num_leds; i++) {\r\nled_dat = &led[i];\r\nled_cur = &pdata->led[i];\r\nif (led_cur->id > MC13783_LED_MAX || led_cur->id < 0) {\r\ndev_err(&pdev->dev, "invalid id %d\n", led_cur->id);\r\nret = -EINVAL;\r\ngoto err_register;\r\n}\r\nif (init_led & (1 << led_cur->id)) {\r\ndev_err(&pdev->dev, "led %d already initialized\n",\r\nled_cur->id);\r\nret = -EINVAL;\r\ngoto err_register;\r\n}\r\ninit_led |= 1 << led_cur->id;\r\nled_dat->cdev.name = led_cur->name;\r\nled_dat->cdev.default_trigger = led_cur->default_trigger;\r\nled_dat->cdev.brightness_set = mc13783_led_set;\r\nled_dat->cdev.brightness = LED_OFF;\r\nled_dat->id = led_cur->id;\r\nled_dat->master = dev_get_drvdata(pdev->dev.parent);\r\nINIT_WORK(&led_dat->work, mc13783_led_work);\r\nret = led_classdev_register(pdev->dev.parent, &led_dat->cdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register led %d\n",\r\nled_dat->id);\r\ngoto err_register;\r\n}\r\nret = mc13783_led_setup(led_dat, led_cur->max_current);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to init led %d\n",\r\nled_dat->id);\r\ni++;\r\ngoto err_register;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, led);\r\nreturn 0;\r\nerr_register:\r\nfor (i = i - 1; i >= 0; i--) {\r\nled_classdev_unregister(&led[i].cdev);\r\ncancel_work_sync(&led[i].work);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devexit mc13783_led_remove(struct platform_device *pdev)\r\n{\r\nstruct mc13xxx_leds_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct mc13783_led *led = platform_get_drvdata(pdev);\r\nstruct mc13xxx *dev = dev_get_drvdata(pdev->dev.parent);\r\nint i;\r\nfor (i = 0; i < pdata->num_leds; i++) {\r\nled_classdev_unregister(&led[i].cdev);\r\ncancel_work_sync(&led[i].work);\r\n}\r\nmc13xxx_lock(dev);\r\nmc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_0, 0);\r\nmc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_1, 0);\r\nmc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_2, 0);\r\nmc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_3, 0);\r\nmc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_4, 0);\r\nmc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_5, 0);\r\nmc13xxx_unlock(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
