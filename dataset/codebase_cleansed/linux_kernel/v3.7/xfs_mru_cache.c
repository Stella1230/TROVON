STATIC unsigned long\r\n_xfs_mru_cache_migrate(\r\nxfs_mru_cache_t *mru,\r\nunsigned long now)\r\n{\r\nunsigned int grp;\r\nunsigned int migrated = 0;\r\nstruct list_head *lru_list;\r\nif (!mru->time_zero)\r\nreturn 0;\r\nwhile (mru->time_zero <= now - mru->grp_count * mru->grp_time) {\r\nlru_list = mru->lists + mru->lru_grp;\r\nif (!list_empty(lru_list))\r\nlist_splice_init(lru_list, mru->reap_list.prev);\r\nmru->lru_grp = (mru->lru_grp + 1) % mru->grp_count;\r\nmru->time_zero += mru->grp_time;\r\nif (++migrated == mru->grp_count) {\r\nmru->lru_grp = 0;\r\nmru->time_zero = 0;\r\nreturn 0;\r\n}\r\n}\r\nfor (grp = 0; grp < mru->grp_count; grp++) {\r\nlru_list = mru->lists + ((mru->lru_grp + grp) % mru->grp_count);\r\nif (!list_empty(lru_list))\r\nreturn mru->time_zero +\r\n(mru->grp_count + grp) * mru->grp_time;\r\n}\r\nmru->lru_grp = 0;\r\nmru->time_zero = 0;\r\nreturn 0;\r\n}\r\nSTATIC void\r\n_xfs_mru_cache_list_insert(\r\nxfs_mru_cache_t *mru,\r\nxfs_mru_cache_elem_t *elem)\r\n{\r\nunsigned int grp = 0;\r\nunsigned long now = jiffies;\r\nif (!_xfs_mru_cache_migrate(mru, now)) {\r\nmru->time_zero = now;\r\nif (!mru->queued) {\r\nmru->queued = 1;\r\nqueue_delayed_work(xfs_mru_reap_wq, &mru->work,\r\nmru->grp_count * mru->grp_time);\r\n}\r\n} else {\r\ngrp = (now - mru->time_zero) / mru->grp_time;\r\ngrp = (mru->lru_grp + grp) % mru->grp_count;\r\n}\r\nlist_add_tail(&elem->list_node, mru->lists + grp);\r\n}\r\nSTATIC void\r\n_xfs_mru_cache_clear_reap_list(\r\nxfs_mru_cache_t *mru) __releases(mru->lock) __acquires(mru->lock)\r\n{\r\nxfs_mru_cache_elem_t *elem, *next;\r\nstruct list_head tmp;\r\nINIT_LIST_HEAD(&tmp);\r\nlist_for_each_entry_safe(elem, next, &mru->reap_list, list_node) {\r\nradix_tree_delete(&mru->store, elem->key);\r\nlist_move(&elem->list_node, &tmp);\r\n}\r\nspin_unlock(&mru->lock);\r\nlist_for_each_entry_safe(elem, next, &tmp, list_node) {\r\nlist_del_init(&elem->list_node);\r\nmru->free_func(elem->key, elem->value);\r\nkmem_zone_free(xfs_mru_elem_zone, elem);\r\n}\r\nspin_lock(&mru->lock);\r\n}\r\nSTATIC void\r\n_xfs_mru_cache_reap(\r\nstruct work_struct *work)\r\n{\r\nxfs_mru_cache_t *mru = container_of(work, xfs_mru_cache_t, work.work);\r\nunsigned long now, next;\r\nASSERT(mru && mru->lists);\r\nif (!mru || !mru->lists)\r\nreturn;\r\nspin_lock(&mru->lock);\r\nnext = _xfs_mru_cache_migrate(mru, jiffies);\r\n_xfs_mru_cache_clear_reap_list(mru);\r\nmru->queued = next;\r\nif ((mru->queued > 0)) {\r\nnow = jiffies;\r\nif (next <= now)\r\nnext = 0;\r\nelse\r\nnext -= now;\r\nqueue_delayed_work(xfs_mru_reap_wq, &mru->work, next);\r\n}\r\nspin_unlock(&mru->lock);\r\n}\r\nint\r\nxfs_mru_cache_init(void)\r\n{\r\nxfs_mru_elem_zone = kmem_zone_init(sizeof(xfs_mru_cache_elem_t),\r\n"xfs_mru_cache_elem");\r\nif (!xfs_mru_elem_zone)\r\ngoto out;\r\nxfs_mru_reap_wq = alloc_workqueue("xfs_mru_cache", WQ_MEM_RECLAIM, 1);\r\nif (!xfs_mru_reap_wq)\r\ngoto out_destroy_mru_elem_zone;\r\nreturn 0;\r\nout_destroy_mru_elem_zone:\r\nkmem_zone_destroy(xfs_mru_elem_zone);\r\nout:\r\nreturn -ENOMEM;\r\n}\r\nvoid\r\nxfs_mru_cache_uninit(void)\r\n{\r\ndestroy_workqueue(xfs_mru_reap_wq);\r\nkmem_zone_destroy(xfs_mru_elem_zone);\r\n}\r\nint\r\nxfs_mru_cache_create(\r\nxfs_mru_cache_t **mrup,\r\nunsigned int lifetime_ms,\r\nunsigned int grp_count,\r\nxfs_mru_cache_free_func_t free_func)\r\n{\r\nxfs_mru_cache_t *mru = NULL;\r\nint err = 0, grp;\r\nunsigned int grp_time;\r\nif (mrup)\r\n*mrup = NULL;\r\nif (!mrup || !grp_count || !lifetime_ms || !free_func)\r\nreturn EINVAL;\r\nif (!(grp_time = msecs_to_jiffies(lifetime_ms) / grp_count))\r\nreturn EINVAL;\r\nif (!(mru = kmem_zalloc(sizeof(*mru), KM_SLEEP)))\r\nreturn ENOMEM;\r\nmru->grp_count = grp_count + 1;\r\nmru->lists = kmem_zalloc(mru->grp_count * sizeof(*mru->lists), KM_SLEEP);\r\nif (!mru->lists) {\r\nerr = ENOMEM;\r\ngoto exit;\r\n}\r\nfor (grp = 0; grp < mru->grp_count; grp++)\r\nINIT_LIST_HEAD(mru->lists + grp);\r\nINIT_RADIX_TREE(&mru->store, GFP_ATOMIC);\r\nINIT_LIST_HEAD(&mru->reap_list);\r\nspin_lock_init(&mru->lock);\r\nINIT_DELAYED_WORK(&mru->work, _xfs_mru_cache_reap);\r\nmru->grp_time = grp_time;\r\nmru->free_func = free_func;\r\n*mrup = mru;\r\nexit:\r\nif (err && mru && mru->lists)\r\nkmem_free(mru->lists);\r\nif (err && mru)\r\nkmem_free(mru);\r\nreturn err;\r\n}\r\nstatic void\r\nxfs_mru_cache_flush(\r\nxfs_mru_cache_t *mru)\r\n{\r\nif (!mru || !mru->lists)\r\nreturn;\r\nspin_lock(&mru->lock);\r\nif (mru->queued) {\r\nspin_unlock(&mru->lock);\r\ncancel_delayed_work_sync(&mru->work);\r\nspin_lock(&mru->lock);\r\n}\r\n_xfs_mru_cache_migrate(mru, jiffies + mru->grp_count * mru->grp_time);\r\n_xfs_mru_cache_clear_reap_list(mru);\r\nspin_unlock(&mru->lock);\r\n}\r\nvoid\r\nxfs_mru_cache_destroy(\r\nxfs_mru_cache_t *mru)\r\n{\r\nif (!mru || !mru->lists)\r\nreturn;\r\nxfs_mru_cache_flush(mru);\r\nkmem_free(mru->lists);\r\nkmem_free(mru);\r\n}\r\nint\r\nxfs_mru_cache_insert(\r\nxfs_mru_cache_t *mru,\r\nunsigned long key,\r\nvoid *value)\r\n{\r\nxfs_mru_cache_elem_t *elem;\r\nASSERT(mru && mru->lists);\r\nif (!mru || !mru->lists)\r\nreturn EINVAL;\r\nelem = kmem_zone_zalloc(xfs_mru_elem_zone, KM_SLEEP);\r\nif (!elem)\r\nreturn ENOMEM;\r\nif (radix_tree_preload(GFP_KERNEL)) {\r\nkmem_zone_free(xfs_mru_elem_zone, elem);\r\nreturn ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&elem->list_node);\r\nelem->key = key;\r\nelem->value = value;\r\nspin_lock(&mru->lock);\r\nradix_tree_insert(&mru->store, key, elem);\r\nradix_tree_preload_end();\r\n_xfs_mru_cache_list_insert(mru, elem);\r\nspin_unlock(&mru->lock);\r\nreturn 0;\r\n}\r\nvoid *\r\nxfs_mru_cache_remove(\r\nxfs_mru_cache_t *mru,\r\nunsigned long key)\r\n{\r\nxfs_mru_cache_elem_t *elem;\r\nvoid *value = NULL;\r\nASSERT(mru && mru->lists);\r\nif (!mru || !mru->lists)\r\nreturn NULL;\r\nspin_lock(&mru->lock);\r\nelem = radix_tree_delete(&mru->store, key);\r\nif (elem) {\r\nvalue = elem->value;\r\nlist_del(&elem->list_node);\r\n}\r\nspin_unlock(&mru->lock);\r\nif (elem)\r\nkmem_zone_free(xfs_mru_elem_zone, elem);\r\nreturn value;\r\n}\r\nvoid\r\nxfs_mru_cache_delete(\r\nxfs_mru_cache_t *mru,\r\nunsigned long key)\r\n{\r\nvoid *value = xfs_mru_cache_remove(mru, key);\r\nif (value)\r\nmru->free_func(key, value);\r\n}\r\nvoid *\r\nxfs_mru_cache_lookup(\r\nxfs_mru_cache_t *mru,\r\nunsigned long key)\r\n{\r\nxfs_mru_cache_elem_t *elem;\r\nASSERT(mru && mru->lists);\r\nif (!mru || !mru->lists)\r\nreturn NULL;\r\nspin_lock(&mru->lock);\r\nelem = radix_tree_lookup(&mru->store, key);\r\nif (elem) {\r\nlist_del(&elem->list_node);\r\n_xfs_mru_cache_list_insert(mru, elem);\r\n__release(mru_lock);\r\n} else\r\nspin_unlock(&mru->lock);\r\nreturn elem ? elem->value : NULL;\r\n}\r\nvoid\r\nxfs_mru_cache_done(\r\nxfs_mru_cache_t *mru) __releases(mru->lock)\r\n{\r\nspin_unlock(&mru->lock);\r\n}
