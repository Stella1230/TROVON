static int __devinit ohci_au1xxx_start(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nint ret;\r\nohci_dbg(ohci, "ohci_au1xxx_start, ohci:%p", ohci);\r\nif ((ret = ohci_init(ohci)) < 0)\r\nreturn ret;\r\nif ((ret = ohci_run(ohci)) < 0) {\r\ndev_err(hcd->self.controller, "can't start %s",\r\nhcd->self.bus_name);\r\nohci_stop(hcd);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ohci_hcd_au1xxx_drv_probe(struct platform_device *pdev)\r\n{\r\nint ret, unit;\r\nstruct usb_hcd *hcd;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nif (pdev->resource[1].flags != IORESOURCE_IRQ) {\r\npr_debug("resource[1] is not IORESOURCE_IRQ\n");\r\nreturn -ENOMEM;\r\n}\r\nhcd = usb_create_hcd(&ohci_au1xxx_hc_driver, &pdev->dev, "au1xxx");\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nhcd->rsrc_start = pdev->resource[0].start;\r\nhcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;\r\nif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {\r\npr_debug("request_mem_region failed\n");\r\nret = -EBUSY;\r\ngoto err1;\r\n}\r\nhcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);\r\nif (!hcd->regs) {\r\npr_debug("ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err2;\r\n}\r\nunit = (hcd->rsrc_start == AU1300_USB_OHCI1_PHYS_ADDR) ?\r\nALCHEMY_USB_OHCI1 : ALCHEMY_USB_OHCI0;\r\nif (alchemy_usb_control(unit, 1)) {\r\nprintk(KERN_INFO "%s: controller init failed!\n", pdev->name);\r\nret = -ENODEV;\r\ngoto err3;\r\n}\r\nohci_hcd_init(hcd_to_ohci(hcd));\r\nret = usb_add_hcd(hcd, pdev->resource[1].start,\r\nIRQF_SHARED);\r\nif (ret == 0) {\r\nplatform_set_drvdata(pdev, hcd);\r\nreturn ret;\r\n}\r\nalchemy_usb_control(unit, 0);\r\nerr3:\r\niounmap(hcd->regs);\r\nerr2:\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nerr1:\r\nusb_put_hcd(hcd);\r\nreturn ret;\r\n}\r\nstatic int ohci_hcd_au1xxx_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nint unit;\r\nunit = (hcd->rsrc_start == AU1300_USB_OHCI1_PHYS_ADDR) ?\r\nALCHEMY_USB_OHCI1 : ALCHEMY_USB_OHCI0;\r\nusb_remove_hcd(hcd);\r\nalchemy_usb_control(unit, 0);\r\niounmap(hcd->regs);\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nusb_put_hcd(hcd);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int ohci_hcd_au1xxx_drv_suspend(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nunsigned long flags;\r\nint rc;\r\nrc = 0;\r\nspin_lock_irqsave(&ohci->lock, flags);\r\nif (ohci->rh_state != OHCI_RH_SUSPENDED) {\r\nrc = -EINVAL;\r\ngoto bail;\r\n}\r\nohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);\r\n(void)ohci_readl(ohci, &ohci->regs->intrdisable);\r\nclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nalchemy_usb_control(ALCHEMY_USB_OHCI0, 0);\r\nbail:\r\nspin_unlock_irqrestore(&ohci->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int ohci_hcd_au1xxx_drv_resume(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nalchemy_usb_control(ALCHEMY_USB_OHCI0, 1);\r\nset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nohci_finish_controller_resume(hcd);\r\nreturn 0;\r\n}
