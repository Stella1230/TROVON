static inline struct lp5521_led *cdev_to_led(struct led_classdev *cdev)\r\n{\r\nreturn container_of(cdev, struct lp5521_led, cdev);\r\n}\r\nstatic inline struct lp5521_chip *engine_to_lp5521(struct lp5521_engine *engine)\r\n{\r\nreturn container_of(engine, struct lp5521_chip,\r\nengines[engine->id - 1]);\r\n}\r\nstatic inline struct lp5521_chip *led_to_lp5521(struct lp5521_led *led)\r\n{\r\nreturn container_of(led, struct lp5521_chip,\r\nleds[led->id]);\r\n}\r\nstatic inline int lp5521_write(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic int lp5521_read(struct i2c_client *client, u8 reg, u8 *buf)\r\n{\r\ns32 ret;\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0)\r\nreturn -EIO;\r\n*buf = ret;\r\nreturn 0;\r\n}\r\nstatic int lp5521_set_engine_mode(struct lp5521_engine *engine, u8 mode)\r\n{\r\nstruct lp5521_chip *chip = engine_to_lp5521(engine);\r\nstruct i2c_client *client = chip->client;\r\nint ret;\r\nu8 engine_state;\r\nif (mode == LP5521_CMD_LOAD)\r\nreturn 0;\r\nif (mode == LP5521_CMD_DISABLED)\r\nmode = LP5521_CMD_DIRECT;\r\nret = lp5521_read(client, LP5521_REG_OP_MODE, &engine_state);\r\nif (ret < 0)\r\nreturn ret;\r\nengine_state &= ~(engine->engine_mask);\r\nmode &= engine->engine_mask;\r\nengine_state |= mode;\r\nreturn lp5521_write(client, LP5521_REG_OP_MODE, engine_state);\r\n}\r\nstatic int lp5521_load_program(struct lp5521_engine *eng, const u8 *pattern)\r\n{\r\nstruct lp5521_chip *chip = engine_to_lp5521(eng);\r\nstruct i2c_client *client = chip->client;\r\nint ret;\r\nint addr;\r\nu8 mode;\r\nret = lp5521_set_engine_mode(eng, LP5521_CMD_DIRECT);\r\nif (ret)\r\nreturn ret;\r\nusleep_range(1000, 2000);\r\nret = lp5521_read(client, LP5521_REG_OP_MODE, &mode);\r\nif (ret)\r\nreturn ret;\r\nlp5521_write(client, LP5521_REG_OP_MODE, LP5521_CMD_DIRECT);\r\nusleep_range(1000, 2000);\r\nlp5521_write(client, LP5521_REG_OP_MODE, LP5521_CMD_LOAD);\r\nusleep_range(1000, 2000);\r\naddr = LP5521_PROG_MEM_BASE + eng->prog_page * LP5521_PROG_MEM_SIZE;\r\ni2c_smbus_write_i2c_block_data(client,\r\naddr,\r\nLP5521_PROG_MEM_SIZE,\r\npattern);\r\nreturn lp5521_write(client, LP5521_REG_OP_MODE, mode);\r\n}\r\nstatic int lp5521_set_led_current(struct lp5521_chip *chip, int led, u8 curr)\r\n{\r\nreturn lp5521_write(chip->client,\r\nLP5521_REG_LED_CURRENT_BASE + chip->leds[led].chan_nr,\r\ncurr);\r\n}\r\nstatic void lp5521_init_engine(struct lp5521_chip *chip)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(chip->engines); i++) {\r\nchip->engines[i].id = i + 1;\r\nchip->engines[i].engine_mask = LP5521_ENG_MASK_BASE >> (i * 2);\r\nchip->engines[i].prog_page = i;\r\n}\r\n}\r\nstatic int lp5521_configure(struct i2c_client *client)\r\n{\r\nstruct lp5521_chip *chip = i2c_get_clientdata(client);\r\nint ret;\r\nu8 cfg;\r\nlp5521_init_engine(chip);\r\nret = lp5521_write(client, LP5521_REG_OP_MODE, LP5521_CMD_DIRECT);\r\ncfg = chip->pdata->update_config ?\r\n: (LP5521_PWRSAVE_EN | LP5521_CP_MODE_AUTO | LP5521_R_TO_BATT);\r\nret |= lp5521_write(client, LP5521_REG_CONFIG, cfg);\r\nret |= lp5521_write(client, LP5521_REG_R_PWM, 0);\r\nret |= lp5521_write(client, LP5521_REG_G_PWM, 0);\r\nret |= lp5521_write(client, LP5521_REG_B_PWM, 0);\r\nret |= lp5521_write(client, LP5521_REG_ENABLE,\r\nLP5521_ENABLE_RUN_PROGRAM);\r\nusleep_range(1000, 2000);\r\nreturn ret;\r\n}\r\nstatic int lp5521_run_selftest(struct lp5521_chip *chip, char *buf)\r\n{\r\nint ret;\r\nu8 status;\r\nret = lp5521_read(chip->client, LP5521_REG_STATUS, &status);\r\nif (ret < 0)\r\nreturn ret;\r\nif (chip->pdata && chip->pdata->clock_mode == LP5521_CLOCK_EXT)\r\nif ((status & LP5521_EXT_CLK_USED) == 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void lp5521_set_brightness(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct lp5521_led *led = cdev_to_led(cdev);\r\nled->brightness = (u8)brightness;\r\nschedule_work(&led->brightness_work);\r\n}\r\nstatic void lp5521_led_brightness_work(struct work_struct *work)\r\n{\r\nstruct lp5521_led *led = container_of(work,\r\nstruct lp5521_led,\r\nbrightness_work);\r\nstruct lp5521_chip *chip = led_to_lp5521(led);\r\nstruct i2c_client *client = chip->client;\r\nmutex_lock(&chip->lock);\r\nlp5521_write(client, LP5521_REG_LED_PWM_BASE + led->chan_nr,\r\nled->brightness);\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic int lp5521_detect(struct i2c_client *client)\r\n{\r\nint ret;\r\nu8 buf;\r\nret = lp5521_write(client, LP5521_REG_ENABLE, LP5521_ENABLE_DEFAULT);\r\nif (ret)\r\nreturn ret;\r\nusleep_range(1000, 2000);\r\nret = lp5521_read(client, LP5521_REG_ENABLE, &buf);\r\nif (ret)\r\nreturn ret;\r\nif (buf != LP5521_ENABLE_DEFAULT)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int lp5521_set_mode(struct lp5521_engine *engine, u8 mode)\r\n{\r\nint ret = 0;\r\nif (mode == engine->mode && mode != LP5521_CMD_RUN)\r\nreturn 0;\r\nif (mode == LP5521_CMD_RUN) {\r\nret = lp5521_set_engine_mode(engine, LP5521_CMD_RUN);\r\n} else if (mode == LP5521_CMD_LOAD) {\r\nlp5521_set_engine_mode(engine, LP5521_CMD_DISABLED);\r\nlp5521_set_engine_mode(engine, LP5521_CMD_LOAD);\r\n} else if (mode == LP5521_CMD_DISABLED) {\r\nlp5521_set_engine_mode(engine, LP5521_CMD_DISABLED);\r\n}\r\nengine->mode = mode;\r\nreturn ret;\r\n}\r\nstatic int lp5521_do_store_load(struct lp5521_engine *engine,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lp5521_chip *chip = engine_to_lp5521(engine);\r\nstruct i2c_client *client = chip->client;\r\nint ret, nrchars, offset = 0, i = 0;\r\nchar c[3];\r\nunsigned cmd;\r\nu8 pattern[LP5521_PROGRAM_LENGTH] = {0};\r\nwhile ((offset < len - 1) && (i < LP5521_PROGRAM_LENGTH)) {\r\nret = sscanf(buf + offset, "%2s%n ", c, &nrchars);\r\nif (ret != 2)\r\ngoto fail;\r\nret = sscanf(c, "%2x", &cmd);\r\nif (ret != 1)\r\ngoto fail;\r\npattern[i] = (u8)cmd;\r\noffset += nrchars;\r\ni++;\r\n}\r\nif (i % 2)\r\ngoto fail;\r\nmutex_lock(&chip->lock);\r\nif (engine->mode == LP5521_CMD_LOAD)\r\nret = lp5521_load_program(engine, pattern);\r\nelse\r\nret = -EINVAL;\r\nmutex_unlock(&chip->lock);\r\nif (ret) {\r\ndev_err(&client->dev, "failed loading pattern\n");\r\nreturn ret;\r\n}\r\nreturn len;\r\nfail:\r\ndev_err(&client->dev, "wrong pattern format\n");\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t store_engine_load(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len, int nr)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lp5521_chip *chip = i2c_get_clientdata(client);\r\nreturn lp5521_do_store_load(&chip->engines[nr - 1], buf, len);\r\n}\r\nstatic ssize_t show_engine_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf, int nr)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lp5521_chip *chip = i2c_get_clientdata(client);\r\nswitch (chip->engines[nr - 1].mode) {\r\ncase LP5521_CMD_RUN:\r\nreturn sprintf(buf, "run\n");\r\ncase LP5521_CMD_LOAD:\r\nreturn sprintf(buf, "load\n");\r\ncase LP5521_CMD_DISABLED:\r\nreturn sprintf(buf, "disabled\n");\r\ndefault:\r\nreturn sprintf(buf, "disabled\n");\r\n}\r\n}\r\nstatic ssize_t store_engine_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len, int nr)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lp5521_chip *chip = i2c_get_clientdata(client);\r\nstruct lp5521_engine *engine = &chip->engines[nr - 1];\r\nmutex_lock(&chip->lock);\r\nif (!strncmp(buf, "run", 3))\r\nlp5521_set_mode(engine, LP5521_CMD_RUN);\r\nelse if (!strncmp(buf, "load", 4))\r\nlp5521_set_mode(engine, LP5521_CMD_LOAD);\r\nelse if (!strncmp(buf, "disabled", 8))\r\nlp5521_set_mode(engine, LP5521_CMD_DISABLED);\r\nmutex_unlock(&chip->lock);\r\nreturn len;\r\n}\r\nstatic ssize_t show_max_current(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lp5521_led *led = cdev_to_led(led_cdev);\r\nreturn sprintf(buf, "%d\n", led->max_current);\r\n}\r\nstatic ssize_t show_current(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lp5521_led *led = cdev_to_led(led_cdev);\r\nreturn sprintf(buf, "%d\n", led->led_current);\r\n}\r\nstatic ssize_t store_current(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lp5521_led *led = cdev_to_led(led_cdev);\r\nstruct lp5521_chip *chip = led_to_lp5521(led);\r\nssize_t ret;\r\nunsigned long curr;\r\nif (kstrtoul(buf, 0, &curr))\r\nreturn -EINVAL;\r\nif (curr > led->max_current)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->lock);\r\nret = lp5521_set_led_current(chip, led->id, curr);\r\nmutex_unlock(&chip->lock);\r\nif (ret < 0)\r\nreturn ret;\r\nled->led_current = (u8)curr;\r\nreturn len;\r\n}\r\nstatic ssize_t lp5521_selftest(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lp5521_chip *chip = i2c_get_clientdata(client);\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nret = lp5521_run_selftest(chip, buf);\r\nmutex_unlock(&chip->lock);\r\nreturn sprintf(buf, "%s\n", ret ? "FAIL" : "OK");\r\n}\r\nstatic void lp5521_clear_program_memory(struct i2c_client *cl)\r\n{\r\nint i;\r\nu8 rgb_mem[] = {\r\nLP5521_REG_R_PROG_MEM,\r\nLP5521_REG_G_PROG_MEM,\r\nLP5521_REG_B_PROG_MEM,\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(rgb_mem); i++) {\r\nlp5521_write(cl, rgb_mem[i], 0);\r\nlp5521_write(cl, rgb_mem[i] + 1, 0);\r\n}\r\n}\r\nstatic void lp5521_write_program_memory(struct i2c_client *cl,\r\nu8 base, u8 *rgb, int size)\r\n{\r\nint i;\r\nif (!rgb || size <= 0)\r\nreturn;\r\nfor (i = 0; i < size; i++)\r\nlp5521_write(cl, base + i, *(rgb + i));\r\nlp5521_write(cl, base + i, 0);\r\nlp5521_write(cl, base + i + 1, 0);\r\n}\r\nstatic inline struct lp5521_led_pattern *lp5521_get_pattern\r\n(struct lp5521_chip *chip, u8 offset)\r\n{\r\nstruct lp5521_led_pattern *ptn;\r\nptn = chip->pdata->patterns + (offset - 1);\r\nreturn ptn;\r\n}\r\nstatic void lp5521_run_led_pattern(int mode, struct lp5521_chip *chip)\r\n{\r\nstruct lp5521_led_pattern *ptn;\r\nstruct i2c_client *cl = chip->client;\r\nint num_patterns = chip->pdata->num_patterns;\r\nif (mode > num_patterns || !(chip->pdata->patterns))\r\nreturn;\r\nif (mode == PATTERN_OFF) {\r\nlp5521_write(cl, LP5521_REG_ENABLE, LP5521_ENABLE_DEFAULT);\r\nusleep_range(1000, 2000);\r\nlp5521_write(cl, LP5521_REG_OP_MODE, LP5521_CMD_DIRECT);\r\n} else {\r\nptn = lp5521_get_pattern(chip, mode);\r\nif (!ptn)\r\nreturn;\r\nlp5521_write(cl, LP5521_REG_OP_MODE, LP5521_CMD_LOAD);\r\nusleep_range(1000, 2000);\r\nlp5521_clear_program_memory(cl);\r\nlp5521_write_program_memory(cl, LP5521_REG_R_PROG_MEM,\r\nptn->r, ptn->size_r);\r\nlp5521_write_program_memory(cl, LP5521_REG_G_PROG_MEM,\r\nptn->g, ptn->size_g);\r\nlp5521_write_program_memory(cl, LP5521_REG_B_PROG_MEM,\r\nptn->b, ptn->size_b);\r\nlp5521_write(cl, LP5521_REG_OP_MODE, LP5521_CMD_RUN);\r\nusleep_range(1000, 2000);\r\nlp5521_write(cl, LP5521_REG_ENABLE, LP5521_ENABLE_RUN_PROGRAM);\r\n}\r\n}\r\nstatic ssize_t store_led_pattern(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lp5521_chip *chip = i2c_get_clientdata(to_i2c_client(dev));\r\nunsigned long val;\r\nint ret;\r\nret = strict_strtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nlp5521_run_led_pattern(val, chip);\r\nreturn len;\r\n}\r\nstatic int lp5521_register_sysfs(struct i2c_client *client)\r\n{\r\nstruct device *dev = &client->dev;\r\nreturn sysfs_create_group(&dev->kobj, &lp5521_group);\r\n}\r\nstatic void lp5521_unregister_sysfs(struct i2c_client *client)\r\n{\r\nstruct lp5521_chip *chip = i2c_get_clientdata(client);\r\nstruct device *dev = &client->dev;\r\nint i;\r\nsysfs_remove_group(&dev->kobj, &lp5521_group);\r\nfor (i = 0; i < chip->num_leds; i++)\r\nsysfs_remove_group(&chip->leds[i].cdev.dev->kobj,\r\n&lp5521_led_attribute_group);\r\n}\r\nstatic int __devinit lp5521_init_led(struct lp5521_led *led,\r\nstruct i2c_client *client,\r\nint chan, struct lp5521_platform_data *pdata)\r\n{\r\nstruct device *dev = &client->dev;\r\nchar name[32];\r\nint res;\r\nif (chan >= LP5521_MAX_LEDS)\r\nreturn -EINVAL;\r\nif (pdata->led_config[chan].led_current == 0)\r\nreturn 0;\r\nled->led_current = pdata->led_config[chan].led_current;\r\nled->max_current = pdata->led_config[chan].max_current;\r\nled->chan_nr = pdata->led_config[chan].chan_nr;\r\nif (led->chan_nr >= LP5521_MAX_LEDS) {\r\ndev_err(dev, "Use channel numbers between 0 and %d\n",\r\nLP5521_MAX_LEDS - 1);\r\nreturn -EINVAL;\r\n}\r\nled->cdev.brightness_set = lp5521_set_brightness;\r\nif (pdata->led_config[chan].name) {\r\nled->cdev.name = pdata->led_config[chan].name;\r\n} else {\r\nsnprintf(name, sizeof(name), "%s:channel%d",\r\npdata->label ?: client->name, chan);\r\nled->cdev.name = name;\r\n}\r\nres = led_classdev_register(dev, &led->cdev);\r\nif (res < 0) {\r\ndev_err(dev, "couldn't register led on channel %d\n", chan);\r\nreturn res;\r\n}\r\nres = sysfs_create_group(&led->cdev.dev->kobj,\r\n&lp5521_led_attribute_group);\r\nif (res < 0) {\r\ndev_err(dev, "couldn't register current attribute\n");\r\nled_classdev_unregister(&led->cdev);\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit lp5521_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lp5521_chip *chip;\r\nstruct lp5521_platform_data *pdata;\r\nint ret, i, led;\r\nu8 buf;\r\nchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, chip);\r\nchip->client = client;\r\npdata = client->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&client->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_init(&chip->lock);\r\nchip->pdata = pdata;\r\nif (pdata->setup_resources) {\r\nret = pdata->setup_resources();\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (pdata->enable) {\r\npdata->enable(0);\r\nusleep_range(1000, 2000);\r\npdata->enable(1);\r\nusleep_range(1000, 2000);\r\n}\r\nlp5521_write(client, LP5521_REG_RESET, 0xff);\r\nusleep_range(10000, 20000);\r\nret = lp5521_read(client, LP5521_REG_R_CURRENT, &buf);\r\nif (ret || buf != LP5521_REG_R_CURR_DEFAULT) {\r\ndev_err(&client->dev, "error in resetting chip\n");\r\ngoto fail2;\r\n}\r\nusleep_range(10000, 20000);\r\nret = lp5521_detect(client);\r\nif (ret) {\r\ndev_err(&client->dev, "Chip not found\n");\r\ngoto fail2;\r\n}\r\ndev_info(&client->dev, "%s programmable led chip found\n", id->name);\r\nret = lp5521_configure(client);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "error configuring chip\n");\r\ngoto fail1;\r\n}\r\nchip->num_channels = pdata->num_channels;\r\nchip->num_leds = 0;\r\nled = 0;\r\nfor (i = 0; i < pdata->num_channels; i++) {\r\nif (pdata->led_config[i].led_current == 0)\r\ncontinue;\r\nret = lp5521_init_led(&chip->leds[led], client, i, pdata);\r\nif (ret) {\r\ndev_err(&client->dev, "error initializing leds\n");\r\ngoto fail2;\r\n}\r\nchip->num_leds++;\r\nchip->leds[led].id = led;\r\nlp5521_set_led_current(chip, led,\r\nchip->leds[led].led_current);\r\nINIT_WORK(&(chip->leds[led].brightness_work),\r\nlp5521_led_brightness_work);\r\nled++;\r\n}\r\nret = lp5521_register_sysfs(client);\r\nif (ret) {\r\ndev_err(&client->dev, "registering sysfs failed\n");\r\ngoto fail2;\r\n}\r\nreturn ret;\r\nfail2:\r\nfor (i = 0; i < chip->num_leds; i++) {\r\nled_classdev_unregister(&chip->leds[i].cdev);\r\ncancel_work_sync(&chip->leds[i].brightness_work);\r\n}\r\nfail1:\r\nif (pdata->enable)\r\npdata->enable(0);\r\nif (pdata->release_resources)\r\npdata->release_resources();\r\nreturn ret;\r\n}\r\nstatic int __devexit lp5521_remove(struct i2c_client *client)\r\n{\r\nstruct lp5521_chip *chip = i2c_get_clientdata(client);\r\nint i;\r\nlp5521_run_led_pattern(PATTERN_OFF, chip);\r\nlp5521_unregister_sysfs(client);\r\nfor (i = 0; i < chip->num_leds; i++) {\r\nled_classdev_unregister(&chip->leds[i].cdev);\r\ncancel_work_sync(&chip->leds[i].brightness_work);\r\n}\r\nif (chip->pdata->enable)\r\nchip->pdata->enable(0);\r\nif (chip->pdata->release_resources)\r\nchip->pdata->release_resources();\r\nreturn 0;\r\n}
