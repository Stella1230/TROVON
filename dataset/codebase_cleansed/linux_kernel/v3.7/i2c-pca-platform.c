static int i2c_pca_pf_readbyte8(void *pd, int reg)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\nreturn ioread8(i2c->reg_base + reg);\r\n}\r\nstatic int i2c_pca_pf_readbyte16(void *pd, int reg)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\nreturn ioread8(i2c->reg_base + reg * 2);\r\n}\r\nstatic int i2c_pca_pf_readbyte32(void *pd, int reg)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\nreturn ioread8(i2c->reg_base + reg * 4);\r\n}\r\nstatic void i2c_pca_pf_writebyte8(void *pd, int reg, int val)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\niowrite8(val, i2c->reg_base + reg);\r\n}\r\nstatic void i2c_pca_pf_writebyte16(void *pd, int reg, int val)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\niowrite8(val, i2c->reg_base + reg * 2);\r\n}\r\nstatic void i2c_pca_pf_writebyte32(void *pd, int reg, int val)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\niowrite8(val, i2c->reg_base + reg * 4);\r\n}\r\nstatic int i2c_pca_pf_waitforcompletion(void *pd)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\nunsigned long timeout;\r\nlong ret;\r\nif (i2c->irq) {\r\nret = wait_event_timeout(i2c->wait,\r\ni2c->algo_data.read_byte(i2c, I2C_PCA_CON)\r\n& I2C_PCA_CON_SI, i2c->adap.timeout);\r\n} else {\r\ntimeout = jiffies + i2c->adap.timeout;\r\ndo {\r\nret = time_before(jiffies, timeout);\r\nif (i2c->algo_data.read_byte(i2c, I2C_PCA_CON)\r\n& I2C_PCA_CON_SI)\r\nbreak;\r\nudelay(100);\r\n} while (ret);\r\n}\r\nreturn ret > 0;\r\n}\r\nstatic void i2c_pca_pf_dummyreset(void *pd)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\nprintk(KERN_WARNING "%s: No reset-pin found. Chip may get stuck!\n",\r\ni2c->adap.name);\r\n}\r\nstatic void i2c_pca_pf_resetchip(void *pd)\r\n{\r\nstruct i2c_pca_pf_data *i2c = pd;\r\ngpio_set_value(i2c->gpio, 0);\r\nndelay(100);\r\ngpio_set_value(i2c->gpio, 1);\r\n}\r\nstatic irqreturn_t i2c_pca_pf_handler(int this_irq, void *dev_id)\r\n{\r\nstruct i2c_pca_pf_data *i2c = dev_id;\r\nif ((i2c->algo_data.read_byte(i2c, I2C_PCA_CON) & I2C_PCA_CON_SI) == 0)\r\nreturn IRQ_NONE;\r\nwake_up(&i2c->wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit i2c_pca_pf_probe(struct platform_device *pdev)\r\n{\r\nstruct i2c_pca_pf_data *i2c;\r\nstruct resource *res;\r\nstruct i2c_pca9564_pf_platform_data *platform_data =\r\npdev->dev.platform_data;\r\nint ret = 0;\r\nint irq;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (res == NULL) {\r\nret = -ENODEV;\r\ngoto e_print;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res), res->name)) {\r\nret = -ENOMEM;\r\ngoto e_print;\r\n}\r\ni2c = kzalloc(sizeof(struct i2c_pca_pf_data), GFP_KERNEL);\r\nif (!i2c) {\r\nret = -ENOMEM;\r\ngoto e_alloc;\r\n}\r\ninit_waitqueue_head(&i2c->wait);\r\ni2c->reg_base = ioremap(res->start, resource_size(res));\r\nif (!i2c->reg_base) {\r\nret = -ENOMEM;\r\ngoto e_remap;\r\n}\r\ni2c->io_base = res->start;\r\ni2c->io_size = resource_size(res);\r\ni2c->irq = irq;\r\ni2c->adap.nr = pdev->id;\r\ni2c->adap.owner = THIS_MODULE;\r\nsnprintf(i2c->adap.name, sizeof(i2c->adap.name),\r\n"PCA9564/PCA9665 at 0x%08lx",\r\n(unsigned long) res->start);\r\ni2c->adap.algo_data = &i2c->algo_data;\r\ni2c->adap.dev.parent = &pdev->dev;\r\nif (platform_data) {\r\ni2c->adap.timeout = platform_data->timeout;\r\ni2c->algo_data.i2c_clock = platform_data->i2c_clock_speed;\r\ni2c->gpio = platform_data->gpio;\r\n} else {\r\ni2c->adap.timeout = HZ;\r\ni2c->algo_data.i2c_clock = 59000;\r\ni2c->gpio = -1;\r\n}\r\ni2c->algo_data.data = i2c;\r\ni2c->algo_data.wait_for_completion = i2c_pca_pf_waitforcompletion;\r\ni2c->algo_data.reset_chip = i2c_pca_pf_dummyreset;\r\nswitch (res->flags & IORESOURCE_MEM_TYPE_MASK) {\r\ncase IORESOURCE_MEM_32BIT:\r\ni2c->algo_data.write_byte = i2c_pca_pf_writebyte32;\r\ni2c->algo_data.read_byte = i2c_pca_pf_readbyte32;\r\nbreak;\r\ncase IORESOURCE_MEM_16BIT:\r\ni2c->algo_data.write_byte = i2c_pca_pf_writebyte16;\r\ni2c->algo_data.read_byte = i2c_pca_pf_readbyte16;\r\nbreak;\r\ncase IORESOURCE_MEM_8BIT:\r\ndefault:\r\ni2c->algo_data.write_byte = i2c_pca_pf_writebyte8;\r\ni2c->algo_data.read_byte = i2c_pca_pf_readbyte8;\r\nbreak;\r\n}\r\nif (i2c->gpio > -1) {\r\nret = gpio_request(i2c->gpio, i2c->adap.name);\r\nif (ret == 0) {\r\ngpio_direction_output(i2c->gpio, 1);\r\ni2c->algo_data.reset_chip = i2c_pca_pf_resetchip;\r\n} else {\r\nprintk(KERN_WARNING "%s: Registering gpio failed!\n",\r\ni2c->adap.name);\r\ni2c->gpio = ret;\r\n}\r\n}\r\nif (irq) {\r\nret = request_irq(irq, i2c_pca_pf_handler,\r\nIRQF_TRIGGER_FALLING, pdev->name, i2c);\r\nif (ret)\r\ngoto e_reqirq;\r\n}\r\nif (i2c_pca_add_numbered_bus(&i2c->adap) < 0) {\r\nret = -ENODEV;\r\ngoto e_adapt;\r\n}\r\nplatform_set_drvdata(pdev, i2c);\r\nprintk(KERN_INFO "%s registered.\n", i2c->adap.name);\r\nreturn 0;\r\ne_adapt:\r\nif (irq)\r\nfree_irq(irq, i2c);\r\ne_reqirq:\r\nif (i2c->gpio > -1)\r\ngpio_free(i2c->gpio);\r\niounmap(i2c->reg_base);\r\ne_remap:\r\nkfree(i2c);\r\ne_alloc:\r\nrelease_mem_region(res->start, resource_size(res));\r\ne_print:\r\nprintk(KERN_ERR "Registering PCA9564/PCA9665 FAILED! (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic int __devexit i2c_pca_pf_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_pca_pf_data *i2c = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\ni2c_del_adapter(&i2c->adap);\r\nif (i2c->irq)\r\nfree_irq(i2c->irq, i2c);\r\nif (i2c->gpio > -1)\r\ngpio_free(i2c->gpio);\r\niounmap(i2c->reg_base);\r\nrelease_mem_region(i2c->io_base, i2c->io_size);\r\nkfree(i2c);\r\nreturn 0;\r\n}
