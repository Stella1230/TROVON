static inline enum Gi_Counting_Mode_Reg_Bits Gi_Alternate_Sync_Bit(enum\r\nni_gpct_variant\r\nvariant)\r\n{\r\nswitch (variant) {\r\ncase ni_gpct_variant_e_series:\r\nreturn 0;\r\nbreak;\r\ncase ni_gpct_variant_m_series:\r\nreturn Gi_M_Series_Alternate_Sync_Bit;\r\nbreak;\r\ncase ni_gpct_variant_660x:\r\nreturn Gi_660x_Alternate_Sync_Bit;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X2_Bit(enum\r\nni_gpct_variant\r\nvariant)\r\n{\r\nswitch (variant) {\r\ncase ni_gpct_variant_e_series:\r\nreturn 0;\r\nbreak;\r\ncase ni_gpct_variant_m_series:\r\nreturn Gi_M_Series_Prescale_X2_Bit;\r\nbreak;\r\ncase ni_gpct_variant_660x:\r\nreturn Gi_660x_Prescale_X2_Bit;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline enum Gi_Counting_Mode_Reg_Bits Gi_Prescale_X8_Bit(enum\r\nni_gpct_variant\r\nvariant)\r\n{\r\nswitch (variant) {\r\ncase ni_gpct_variant_e_series:\r\nreturn 0;\r\nbreak;\r\ncase ni_gpct_variant_m_series:\r\nreturn Gi_M_Series_Prescale_X8_Bit;\r\nbreak;\r\ncase ni_gpct_variant_660x:\r\nreturn Gi_660x_Prescale_X8_Bit;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline enum Gi_Counting_Mode_Reg_Bits Gi_HW_Arm_Select_Mask(enum\r\nni_gpct_variant\r\nvariant)\r\n{\r\nswitch (variant) {\r\ncase ni_gpct_variant_e_series:\r\nreturn 0;\r\nbreak;\r\ncase ni_gpct_variant_m_series:\r\nreturn Gi_M_Series_HW_Arm_Select_Mask;\r\nbreak;\r\ncase ni_gpct_variant_660x:\r\nreturn Gi_660x_HW_Arm_Select_Mask;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned NI_660x_RTSI_Clock(unsigned n)\r\n{\r\nBUG_ON(n > ni_660x_max_rtsi_channel);\r\nreturn 0xb + n;\r\n}\r\nstatic inline unsigned NI_660x_Source_Pin_Clock(unsigned n)\r\n{\r\nBUG_ON(n > ni_660x_max_source_pin);\r\nreturn 0x2 + n;\r\n}\r\nstatic inline unsigned NI_M_Series_PFI_Clock(unsigned n)\r\n{\r\nBUG_ON(n > ni_m_series_max_pfi_channel);\r\nif (n < 10)\r\nreturn 1 + n;\r\nelse\r\nreturn 0xb + n;\r\n}\r\nstatic inline unsigned NI_M_Series_RTSI_Clock(unsigned n)\r\n{\r\nBUG_ON(n > ni_m_series_max_rtsi_channel);\r\nif (n == 7)\r\nreturn 0x1b;\r\nelse\r\nreturn 0xb + n;\r\n}\r\nstatic inline unsigned NI_660x_Gate_Pin_Gate_Select(unsigned n)\r\n{\r\nBUG_ON(n > ni_660x_max_gate_pin);\r\nreturn 0x2 + n;\r\n}\r\nstatic inline unsigned NI_660x_RTSI_Gate_Select(unsigned n)\r\n{\r\nBUG_ON(n > ni_660x_max_rtsi_channel);\r\nreturn 0xb + n;\r\n}\r\nstatic inline unsigned NI_M_Series_RTSI_Gate_Select(unsigned n)\r\n{\r\nBUG_ON(n > ni_m_series_max_rtsi_channel);\r\nif (n == 7)\r\nreturn 0x1b;\r\nreturn 0xb + n;\r\n}\r\nstatic inline unsigned NI_M_Series_PFI_Gate_Select(unsigned n)\r\n{\r\nBUG_ON(n > ni_m_series_max_pfi_channel);\r\nif (n < 10)\r\nreturn 1 + n;\r\nreturn 0xb + n;\r\n}\r\nstatic inline unsigned Gi_Source_Select_Bits(unsigned source)\r\n{\r\nreturn (source << Gi_Source_Select_Shift) & Gi_Source_Select_Mask;\r\n}\r\nstatic inline unsigned Gi_Gate_Select_Bits(unsigned gate_select)\r\n{\r\nreturn (gate_select << Gi_Gate_Select_Shift) & Gi_Gate_Select_Mask;\r\n}\r\nstatic inline unsigned NI_660x_Up_Down_Pin_Second_Gate_Select(unsigned n)\r\n{\r\nBUG_ON(n > ni_660x_max_up_down_pin);\r\nreturn 0x2 + n;\r\n}\r\nstatic inline unsigned NI_660x_RTSI_Second_Gate_Select(unsigned n)\r\n{\r\nBUG_ON(n > ni_660x_max_rtsi_channel);\r\nreturn 0xb + n;\r\n}\r\nstatic int __init ni_tio_init_module(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit ni_tio_cleanup_module(void)\r\n{\r\n}\r\nstruct ni_gpct_device *ni_gpct_device_construct(struct comedi_device *dev,\r\nvoid (*write_register) (struct\r\nni_gpct\r\n*\r\ncounter,\r\nunsigned\r\nbits,\r\nenum\r\nni_gpct_register\r\nreg),\r\nunsigned (*read_register)\r\n(struct ni_gpct *counter,\r\nenum ni_gpct_register reg),\r\nenum ni_gpct_variant variant,\r\nunsigned num_counters)\r\n{\r\nunsigned i;\r\nstruct ni_gpct_device *counter_dev =\r\nkzalloc(sizeof(struct ni_gpct_device), GFP_KERNEL);\r\nif (counter_dev == NULL)\r\nreturn NULL;\r\ncounter_dev->dev = dev;\r\ncounter_dev->write_register = write_register;\r\ncounter_dev->read_register = read_register;\r\ncounter_dev->variant = variant;\r\nspin_lock_init(&counter_dev->regs_lock);\r\nBUG_ON(num_counters == 0);\r\ncounter_dev->counters =\r\nkzalloc(sizeof(struct ni_gpct) * num_counters, GFP_KERNEL);\r\nif (counter_dev->counters == NULL) {\r\nkfree(counter_dev);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < num_counters; ++i) {\r\ncounter_dev->counters[i].counter_dev = counter_dev;\r\nspin_lock_init(&counter_dev->counters[i].lock);\r\n}\r\ncounter_dev->num_counters = num_counters;\r\nreturn counter_dev;\r\n}\r\nvoid ni_gpct_device_destroy(struct ni_gpct_device *counter_dev)\r\n{\r\nif (counter_dev->counters == NULL)\r\nreturn;\r\nkfree(counter_dev->counters);\r\nkfree(counter_dev);\r\n}\r\nstatic int ni_tio_second_gate_registers_present(const struct ni_gpct_device\r\n*counter_dev)\r\n{\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\nreturn 0;\r\nbreak;\r\ncase ni_gpct_variant_m_series:\r\ncase ni_gpct_variant_660x:\r\nreturn 1;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)\r\n{\r\nwrite_register(counter, Gi_Reset_Bit(counter->counter_index),\r\nNITIO_Gxx_Joint_Reset_Reg(counter->counter_index));\r\n}\r\nvoid ni_tio_init_counter(struct ni_gpct *counter)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nni_tio_reset_count_and_disarm(counter);\r\ncounter_dev->regs[NITIO_Gi_Autoincrement_Reg(counter->counter_index)] =\r\n0x0;\r\nwrite_register(counter,\r\ncounter_dev->\r\nregs[NITIO_Gi_Autoincrement_Reg(counter->counter_index)],\r\nNITIO_Gi_Autoincrement_Reg(counter->counter_index));\r\nni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),\r\n~0, Gi_Synchronize_Gate_Bit);\r\nni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index), ~0,\r\n0);\r\ncounter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)] = 0x0;\r\nwrite_register(counter,\r\ncounter_dev->\r\nregs[NITIO_Gi_LoadA_Reg(counter->counter_index)],\r\nNITIO_Gi_LoadA_Reg(counter->counter_index));\r\ncounter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)] = 0x0;\r\nwrite_register(counter,\r\ncounter_dev->\r\nregs[NITIO_Gi_LoadB_Reg(counter->counter_index)],\r\nNITIO_Gi_LoadB_Reg(counter->counter_index));\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Input_Select_Reg(counter->counter_index), ~0,\r\n0);\r\nif (ni_tio_counting_mode_registers_present(counter_dev)) {\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Counting_Mode_Reg(counter->\r\ncounter_index), ~0,\r\n0);\r\n}\r\nif (ni_tio_second_gate_registers_present(counter_dev)) {\r\ncounter_dev->\r\nregs[NITIO_Gi_Second_Gate_Reg(counter->counter_index)] =\r\n0x0;\r\nwrite_register(counter,\r\ncounter_dev->\r\nregs[NITIO_Gi_Second_Gate_Reg\r\n(counter->counter_index)],\r\nNITIO_Gi_Second_Gate_Reg(counter->\r\ncounter_index));\r\n}\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_DMA_Config_Reg(counter->counter_index), ~0,\r\n0x0);\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),\r\n~0, 0x0);\r\n}\r\nstatic unsigned int ni_tio_counter_status(struct ni_gpct *counter)\r\n{\r\nunsigned int status = 0;\r\nconst unsigned bits = read_register(counter,\r\nNITIO_Gxx_Status_Reg(counter->\r\ncounter_index));\r\nif (bits & Gi_Armed_Bit(counter->counter_index)) {\r\nstatus |= COMEDI_COUNTER_ARMED;\r\nif (bits & Gi_Counting_Bit(counter->counter_index))\r\nstatus |= COMEDI_COUNTER_COUNTING;\r\n}\r\nreturn status;\r\n}\r\nstatic void ni_tio_set_sync_mode(struct ni_gpct *counter, int force_alt_sync)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nconst unsigned counting_mode_reg =\r\nNITIO_Gi_Counting_Mode_Reg(counter->counter_index);\r\nstatic const uint64_t min_normal_sync_period_ps = 25000;\r\nconst uint64_t clock_period_ps = ni_tio_clock_period_ps(counter,\r\nni_tio_generic_clock_src_select\r\n(counter));\r\nif (ni_tio_counting_mode_registers_present(counter_dev) == 0)\r\nreturn;\r\nswitch (ni_tio_get_soft_copy(counter, counting_mode_reg) & Gi_Counting_Mode_Mask) {\r\ncase Gi_Counting_Mode_QuadratureX1_Bits:\r\ncase Gi_Counting_Mode_QuadratureX2_Bits:\r\ncase Gi_Counting_Mode_QuadratureX4_Bits:\r\ncase Gi_Counting_Mode_Sync_Source_Bits:\r\nforce_alt_sync = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (force_alt_sync ||\r\n(clock_period_ps && clock_period_ps < min_normal_sync_period_ps)) {\r\nni_tio_set_bits(counter, counting_mode_reg,\r\nGi_Alternate_Sync_Bit(counter_dev->variant),\r\nGi_Alternate_Sync_Bit(counter_dev->variant));\r\n} else {\r\nni_tio_set_bits(counter, counting_mode_reg,\r\nGi_Alternate_Sync_Bit(counter_dev->variant),\r\n0x0);\r\n}\r\n}\r\nstatic int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned mode)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned mode_reg_mask;\r\nunsigned mode_reg_values;\r\nunsigned input_select_bits = 0;\r\nstatic const unsigned mode_reg_direct_mask =\r\nNI_GPCT_GATE_ON_BOTH_EDGES_BIT | NI_GPCT_EDGE_GATE_MODE_MASK |\r\nNI_GPCT_STOP_MODE_MASK | NI_GPCT_OUTPUT_MODE_MASK |\r\nNI_GPCT_HARDWARE_DISARM_MASK | NI_GPCT_LOADING_ON_TC_BIT |\r\nNI_GPCT_LOADING_ON_GATE_BIT | NI_GPCT_LOAD_B_SELECT_BIT;\r\nmode_reg_mask = mode_reg_direct_mask | Gi_Reload_Source_Switching_Bit;\r\nmode_reg_values = mode & mode_reg_direct_mask;\r\nswitch (mode & NI_GPCT_RELOAD_SOURCE_MASK) {\r\ncase NI_GPCT_RELOAD_SOURCE_FIXED_BITS:\r\nbreak;\r\ncase NI_GPCT_RELOAD_SOURCE_SWITCHING_BITS:\r\nmode_reg_values |= Gi_Reload_Source_Switching_Bit;\r\nbreak;\r\ncase NI_GPCT_RELOAD_SOURCE_GATE_SELECT_BITS:\r\ninput_select_bits |= Gi_Gate_Select_Load_Source_Bit;\r\nmode_reg_mask |= Gi_Gating_Mode_Mask;\r\nmode_reg_values |= Gi_Level_Gating_Bits;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index),\r\nmode_reg_mask, mode_reg_values);\r\nif (ni_tio_counting_mode_registers_present(counter_dev)) {\r\nunsigned counting_mode_bits = 0;\r\ncounting_mode_bits |=\r\n(mode >> NI_GPCT_COUNTING_MODE_SHIFT) &\r\nGi_Counting_Mode_Mask;\r\ncounting_mode_bits |=\r\n((mode >> NI_GPCT_INDEX_PHASE_BITSHIFT) <<\r\nGi_Index_Phase_Bitshift) & Gi_Index_Phase_Mask;\r\nif (mode & NI_GPCT_INDEX_ENABLE_BIT)\r\ncounting_mode_bits |= Gi_Index_Mode_Bit;\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Counting_Mode_Reg(counter->\r\ncounter_index),\r\nGi_Counting_Mode_Mask | Gi_Index_Phase_Mask |\r\nGi_Index_Mode_Bit, counting_mode_bits);\r\nni_tio_set_sync_mode(counter, 0);\r\n}\r\nni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),\r\nGi_Up_Down_Mask,\r\n(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT) <<\r\nGi_Up_Down_Shift);\r\nif (mode & NI_GPCT_OR_GATE_BIT)\r\ninput_select_bits |= Gi_Or_Gate_Bit;\r\nif (mode & NI_GPCT_INVERT_OUTPUT_BIT)\r\ninput_select_bits |= Gi_Output_Polarity_Bit;\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Input_Select_Reg(counter->counter_index),\r\nGi_Gate_Select_Load_Source_Bit | Gi_Or_Gate_Bit |\r\nGi_Output_Polarity_Bit, input_select_bits);\r\nreturn 0;\r\n}\r\nint ni_tio_arm(struct ni_gpct *counter, int arm, unsigned start_trigger)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned command_transient_bits = 0;\r\nif (arm) {\r\nswitch (start_trigger) {\r\ncase NI_GPCT_ARM_IMMEDIATE:\r\ncommand_transient_bits |= Gi_Arm_Bit;\r\nbreak;\r\ncase NI_GPCT_ARM_PAIRED_IMMEDIATE:\r\ncommand_transient_bits |= Gi_Arm_Bit | Gi_Arm_Copy_Bit;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ni_tio_counting_mode_registers_present(counter_dev)) {\r\nunsigned counting_mode_bits = 0;\r\nswitch (start_trigger) {\r\ncase NI_GPCT_ARM_IMMEDIATE:\r\ncase NI_GPCT_ARM_PAIRED_IMMEDIATE:\r\nbreak;\r\ndefault:\r\nif (start_trigger & NI_GPCT_ARM_UNKNOWN) {\r\nunsigned hw_arm_select_bits =\r\n(start_trigger <<\r\nGi_HW_Arm_Select_Shift) &\r\nGi_HW_Arm_Select_Mask\r\n(counter_dev->variant);\r\ncounting_mode_bits |=\r\nGi_HW_Arm_Enable_Bit |\r\nhw_arm_select_bits;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Counting_Mode_Reg\r\n(counter->counter_index),\r\nGi_HW_Arm_Select_Mask\r\n(counter_dev->variant) |\r\nGi_HW_Arm_Enable_Bit,\r\ncounting_mode_bits);\r\n}\r\n} else {\r\ncommand_transient_bits |= Gi_Disarm_Bit;\r\n}\r\nni_tio_set_bits_transient(counter,\r\nNITIO_Gi_Command_Reg(counter->counter_index),\r\n0, 0, command_transient_bits);\r\nreturn 0;\r\n}\r\nstatic unsigned ni_660x_source_select_bits(unsigned int clock_source)\r\n{\r\nunsigned ni_660x_clock;\r\nunsigned i;\r\nconst unsigned clock_select_bits =\r\nclock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;\r\nswitch (clock_select_bits) {\r\ncase NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660x_Timebase_1_Clock;\r\nbreak;\r\ncase NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660x_Timebase_2_Clock;\r\nbreak;\r\ncase NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660x_Timebase_3_Clock;\r\nbreak;\r\ncase NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660x_Logic_Low_Clock;\r\nbreak;\r\ncase NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660x_Source_Pin_i_Clock;\r\nbreak;\r\ncase NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660x_Next_Gate_Clock;\r\nbreak;\r\ncase NI_GPCT_NEXT_TC_CLOCK_SRC_BITS:\r\nni_660x_clock = NI_660x_Next_TC_Clock;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {\r\nif (clock_select_bits == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {\r\nni_660x_clock = NI_660x_RTSI_Clock(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_660x_max_rtsi_channel)\r\nbreak;\r\nfor (i = 0; i <= ni_660x_max_source_pin; ++i) {\r\nif (clock_select_bits ==\r\nNI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i)) {\r\nni_660x_clock = NI_660x_Source_Pin_Clock(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_660x_max_source_pin)\r\nbreak;\r\nni_660x_clock = 0;\r\nBUG();\r\nbreak;\r\n}\r\nreturn Gi_Source_Select_Bits(ni_660x_clock);\r\n}\r\nstatic unsigned ni_m_series_source_select_bits(unsigned int clock_source)\r\n{\r\nunsigned ni_m_series_clock;\r\nunsigned i;\r\nconst unsigned clock_select_bits =\r\nclock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;\r\nswitch (clock_select_bits) {\r\ncase NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_Series_Timebase_1_Clock;\r\nbreak;\r\ncase NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_Series_Timebase_2_Clock;\r\nbreak;\r\ncase NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_Series_Timebase_3_Clock;\r\nbreak;\r\ncase NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_Series_Logic_Low_Clock;\r\nbreak;\r\ncase NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_Series_Next_Gate_Clock;\r\nbreak;\r\ncase NI_GPCT_NEXT_TC_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_Series_Next_TC_Clock;\r\nbreak;\r\ncase NI_GPCT_PXI10_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_Series_PXI10_Clock;\r\nbreak;\r\ncase NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_Series_PXI_Star_Trigger_Clock;\r\nbreak;\r\ncase NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS:\r\nni_m_series_clock = NI_M_Series_Analog_Trigger_Out_Clock;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {\r\nif (clock_select_bits == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {\r\nni_m_series_clock = NI_M_Series_RTSI_Clock(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_m_series_max_rtsi_channel)\r\nbreak;\r\nfor (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {\r\nif (clock_select_bits == NI_GPCT_PFI_CLOCK_SRC_BITS(i)) {\r\nni_m_series_clock = NI_M_Series_PFI_Clock(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_m_series_max_pfi_channel)\r\nbreak;\r\nprintk(KERN_ERR "invalid clock source 0x%lx\n",\r\n(unsigned long)clock_source);\r\nBUG();\r\nni_m_series_clock = 0;\r\nbreak;\r\n}\r\nreturn Gi_Source_Select_Bits(ni_m_series_clock);\r\n}\r\nstatic void ni_tio_set_source_subselect(struct ni_gpct *counter,\r\nunsigned int clock_source)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nconst unsigned second_gate_reg =\r\nNITIO_Gi_Second_Gate_Reg(counter->counter_index);\r\nif (counter_dev->variant != ni_gpct_variant_m_series)\r\nreturn;\r\nswitch (clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK) {\r\ncase NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:\r\ncase NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:\r\ncounter_dev->regs[second_gate_reg] &= ~Gi_Source_Subselect_Bit;\r\nbreak;\r\ncase NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS:\r\ncase NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS:\r\ncounter_dev->regs[second_gate_reg] |= Gi_Source_Subselect_Bit;\r\nbreak;\r\ndefault:\r\nreturn;\r\nbreak;\r\n}\r\nwrite_register(counter, counter_dev->regs[second_gate_reg],\r\nsecond_gate_reg);\r\n}\r\nstatic int ni_tio_set_clock_src(struct ni_gpct *counter,\r\nunsigned int clock_source,\r\nunsigned int period_ns)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned input_select_bits = 0;\r\nstatic const uint64_t pico_per_nano = 1000;\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_660x:\r\ninput_select_bits |= ni_660x_source_select_bits(clock_source);\r\nbreak;\r\ncase ni_gpct_variant_e_series:\r\ncase ni_gpct_variant_m_series:\r\ninput_select_bits |=\r\nni_m_series_source_select_bits(clock_source);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nif (clock_source & NI_GPCT_INVERT_CLOCK_SRC_BIT)\r\ninput_select_bits |= Gi_Source_Polarity_Bit;\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Input_Select_Reg(counter->counter_index),\r\nGi_Source_Select_Mask | Gi_Source_Polarity_Bit,\r\ninput_select_bits);\r\nni_tio_set_source_subselect(counter, clock_source);\r\nif (ni_tio_counting_mode_registers_present(counter_dev)) {\r\nconst unsigned prescaling_mode =\r\nclock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK;\r\nunsigned counting_mode_bits = 0;\r\nswitch (prescaling_mode) {\r\ncase NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS:\r\nbreak;\r\ncase NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:\r\ncounting_mode_bits |=\r\nGi_Prescale_X2_Bit(counter_dev->variant);\r\nbreak;\r\ncase NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:\r\ncounting_mode_bits |=\r\nGi_Prescale_X8_Bit(counter_dev->variant);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Counting_Mode_Reg(counter->\r\ncounter_index),\r\nGi_Prescale_X2_Bit(counter_dev->variant) |\r\nGi_Prescale_X8_Bit(counter_dev->variant),\r\ncounting_mode_bits);\r\n}\r\ncounter->clock_period_ps = pico_per_nano * period_ns;\r\nni_tio_set_sync_mode(counter, 0);\r\nreturn 0;\r\n}\r\nstatic unsigned ni_tio_clock_src_modifiers(const struct ni_gpct *counter)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nconst unsigned counting_mode_bits = ni_tio_get_soft_copy(counter,\r\nNITIO_Gi_Counting_Mode_Reg\r\n(counter->\r\ncounter_index));\r\nunsigned bits = 0;\r\nif (ni_tio_get_soft_copy(counter,\r\nNITIO_Gi_Input_Select_Reg\r\n(counter->counter_index)) &\r\nGi_Source_Polarity_Bit)\r\nbits |= NI_GPCT_INVERT_CLOCK_SRC_BIT;\r\nif (counting_mode_bits & Gi_Prescale_X2_Bit(counter_dev->variant))\r\nbits |= NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS;\r\nif (counting_mode_bits & Gi_Prescale_X8_Bit(counter_dev->variant))\r\nbits |= NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS;\r\nreturn bits;\r\n}\r\nstatic unsigned ni_m_series_clock_src_select(const struct ni_gpct *counter)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nconst unsigned second_gate_reg =\r\nNITIO_Gi_Second_Gate_Reg(counter->counter_index);\r\nunsigned clock_source = 0;\r\nunsigned i;\r\nconst unsigned input_select = (ni_tio_get_soft_copy(counter,\r\nNITIO_Gi_Input_Select_Reg\r\n(counter->counter_index))\r\n& Gi_Source_Select_Mask) >>\r\nGi_Source_Select_Shift;\r\nswitch (input_select) {\r\ncase NI_M_Series_Timebase_1_Clock:\r\nclock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_M_Series_Timebase_2_Clock:\r\nclock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_M_Series_Timebase_3_Clock:\r\nif (counter_dev->regs[second_gate_reg] &\r\nGi_Source_Subselect_Bit)\r\nclock_source =\r\nNI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS;\r\nelse\r\nclock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_M_Series_Logic_Low_Clock:\r\nclock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_M_Series_Next_Gate_Clock:\r\nif (counter_dev->regs[second_gate_reg] &\r\nGi_Source_Subselect_Bit)\r\nclock_source = NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS;\r\nelse\r\nclock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_M_Series_PXI10_Clock:\r\nclock_source = NI_GPCT_PXI10_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_M_Series_Next_TC_Clock:\r\nclock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {\r\nif (input_select == NI_M_Series_RTSI_Clock(i)) {\r\nclock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_m_series_max_rtsi_channel)\r\nbreak;\r\nfor (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {\r\nif (input_select == NI_M_Series_PFI_Clock(i)) {\r\nclock_source = NI_GPCT_PFI_CLOCK_SRC_BITS(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_m_series_max_pfi_channel)\r\nbreak;\r\nBUG();\r\nbreak;\r\n}\r\nclock_source |= ni_tio_clock_src_modifiers(counter);\r\nreturn clock_source;\r\n}\r\nstatic unsigned ni_660x_clock_src_select(const struct ni_gpct *counter)\r\n{\r\nunsigned clock_source = 0;\r\nunsigned i;\r\nconst unsigned input_select = (ni_tio_get_soft_copy(counter,\r\nNITIO_Gi_Input_Select_Reg\r\n(counter->counter_index))\r\n& Gi_Source_Select_Mask) >>\r\nGi_Source_Select_Shift;\r\nswitch (input_select) {\r\ncase NI_660x_Timebase_1_Clock:\r\nclock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_660x_Timebase_2_Clock:\r\nclock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_660x_Timebase_3_Clock:\r\nclock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_660x_Logic_Low_Clock:\r\nclock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_660x_Source_Pin_i_Clock:\r\nclock_source = NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_660x_Next_Gate_Clock:\r\nclock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;\r\nbreak;\r\ncase NI_660x_Next_TC_Clock:\r\nclock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {\r\nif (input_select == NI_660x_RTSI_Clock(i)) {\r\nclock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_660x_max_rtsi_channel)\r\nbreak;\r\nfor (i = 0; i <= ni_660x_max_source_pin; ++i) {\r\nif (input_select == NI_660x_Source_Pin_Clock(i)) {\r\nclock_source =\r\nNI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_660x_max_source_pin)\r\nbreak;\r\nBUG();\r\nbreak;\r\n}\r\nclock_source |= ni_tio_clock_src_modifiers(counter);\r\nreturn clock_source;\r\n}\r\nstatic unsigned ni_tio_generic_clock_src_select(const struct ni_gpct *counter)\r\n{\r\nswitch (counter->counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\ncase ni_gpct_variant_m_series:\r\nreturn ni_m_series_clock_src_select(counter);\r\nbreak;\r\ncase ni_gpct_variant_660x:\r\nreturn ni_660x_clock_src_select(counter);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic uint64_t ni_tio_clock_period_ps(const struct ni_gpct *counter,\r\nunsigned generic_clock_source)\r\n{\r\nuint64_t clock_period_ps;\r\nswitch (generic_clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK) {\r\ncase NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:\r\nclock_period_ps = 50000;\r\nbreak;\r\ncase NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:\r\nclock_period_ps = 10000000;\r\nbreak;\r\ncase NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:\r\nclock_period_ps = 12500;\r\nbreak;\r\ncase NI_GPCT_PXI10_CLOCK_SRC_BITS:\r\nclock_period_ps = 100000;\r\nbreak;\r\ndefault:\r\nreturn counter->clock_period_ps;\r\nbreak;\r\n}\r\nswitch (generic_clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK) {\r\ncase NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS:\r\nbreak;\r\ncase NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:\r\nclock_period_ps *= 2;\r\nbreak;\r\ncase NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:\r\nclock_period_ps *= 8;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nreturn clock_period_ps;\r\n}\r\nstatic void ni_tio_get_clock_src(struct ni_gpct *counter,\r\nunsigned int *clock_source,\r\nunsigned int *period_ns)\r\n{\r\nstatic const unsigned pico_per_nano = 1000;\r\nuint64_t temp64;\r\n*clock_source = ni_tio_generic_clock_src_select(counter);\r\ntemp64 = ni_tio_clock_period_ps(counter, *clock_source);\r\ndo_div(temp64, pico_per_nano);\r\n*period_ns = temp64;\r\n}\r\nstatic void ni_tio_set_first_gate_modifiers(struct ni_gpct *counter,\r\nunsigned int gate_source)\r\n{\r\nconst unsigned mode_mask = Gi_Gate_Polarity_Bit | Gi_Gating_Mode_Mask;\r\nunsigned mode_values = 0;\r\nif (gate_source & CR_INVERT)\r\nmode_values |= Gi_Gate_Polarity_Bit;\r\nif (gate_source & CR_EDGE)\r\nmode_values |= Gi_Rising_Edge_Gating_Bits;\r\nelse\r\nmode_values |= Gi_Level_Gating_Bits;\r\nni_tio_set_bits(counter, NITIO_Gi_Mode_Reg(counter->counter_index),\r\nmode_mask, mode_values);\r\n}\r\nstatic int ni_660x_set_first_gate(struct ni_gpct *counter,\r\nunsigned int gate_source)\r\n{\r\nconst unsigned selected_gate = CR_CHAN(gate_source);\r\nconst unsigned selected_gate_mask = 0x1f;\r\nunsigned ni_660x_gate_select;\r\nunsigned i;\r\nswitch (selected_gate) {\r\ncase NI_GPCT_NEXT_SOURCE_GATE_SELECT:\r\nni_660x_gate_select = NI_660x_Next_SRC_Gate_Select;\r\nbreak;\r\ncase NI_GPCT_NEXT_OUT_GATE_SELECT:\r\ncase NI_GPCT_LOGIC_LOW_GATE_SELECT:\r\ncase NI_GPCT_SOURCE_PIN_i_GATE_SELECT:\r\ncase NI_GPCT_GATE_PIN_i_GATE_SELECT:\r\nni_660x_gate_select = selected_gate & selected_gate_mask;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {\r\nif (selected_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {\r\nni_660x_gate_select =\r\nselected_gate & selected_gate_mask;\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_660x_max_rtsi_channel)\r\nbreak;\r\nfor (i = 0; i <= ni_660x_max_gate_pin; ++i) {\r\nif (selected_gate == NI_GPCT_GATE_PIN_GATE_SELECT(i)) {\r\nni_660x_gate_select =\r\nselected_gate & selected_gate_mask;\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_660x_max_gate_pin)\r\nbreak;\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Input_Select_Reg(counter->counter_index),\r\nGi_Gate_Select_Mask,\r\nGi_Gate_Select_Bits(ni_660x_gate_select));\r\nreturn 0;\r\n}\r\nstatic int ni_m_series_set_first_gate(struct ni_gpct *counter,\r\nunsigned int gate_source)\r\n{\r\nconst unsigned selected_gate = CR_CHAN(gate_source);\r\nconst unsigned selected_gate_mask = 0x1f;\r\nunsigned ni_m_series_gate_select;\r\nunsigned i;\r\nswitch (selected_gate) {\r\ncase NI_GPCT_TIMESTAMP_MUX_GATE_SELECT:\r\ncase NI_GPCT_AI_START2_GATE_SELECT:\r\ncase NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT:\r\ncase NI_GPCT_NEXT_OUT_GATE_SELECT:\r\ncase NI_GPCT_AI_START1_GATE_SELECT:\r\ncase NI_GPCT_NEXT_SOURCE_GATE_SELECT:\r\ncase NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT:\r\ncase NI_GPCT_LOGIC_LOW_GATE_SELECT:\r\nni_m_series_gate_select = selected_gate & selected_gate_mask;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {\r\nif (selected_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {\r\nni_m_series_gate_select =\r\nselected_gate & selected_gate_mask;\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_m_series_max_rtsi_channel)\r\nbreak;\r\nfor (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {\r\nif (selected_gate == NI_GPCT_PFI_GATE_SELECT(i)) {\r\nni_m_series_gate_select =\r\nselected_gate & selected_gate_mask;\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_m_series_max_pfi_channel)\r\nbreak;\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Input_Select_Reg(counter->counter_index),\r\nGi_Gate_Select_Mask,\r\nGi_Gate_Select_Bits(ni_m_series_gate_select));\r\nreturn 0;\r\n}\r\nstatic int ni_660x_set_second_gate(struct ni_gpct *counter,\r\nunsigned int gate_source)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nconst unsigned second_gate_reg =\r\nNITIO_Gi_Second_Gate_Reg(counter->counter_index);\r\nconst unsigned selected_second_gate = CR_CHAN(gate_source);\r\nstatic const unsigned selected_second_gate_mask = 0x1f;\r\nunsigned ni_660x_second_gate_select;\r\nunsigned i;\r\nswitch (selected_second_gate) {\r\ncase NI_GPCT_SOURCE_PIN_i_GATE_SELECT:\r\ncase NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT:\r\ncase NI_GPCT_SELECTED_GATE_GATE_SELECT:\r\ncase NI_GPCT_NEXT_OUT_GATE_SELECT:\r\ncase NI_GPCT_LOGIC_LOW_GATE_SELECT:\r\nni_660x_second_gate_select =\r\nselected_second_gate & selected_second_gate_mask;\r\nbreak;\r\ncase NI_GPCT_NEXT_SOURCE_GATE_SELECT:\r\nni_660x_second_gate_select =\r\nNI_660x_Next_SRC_Second_Gate_Select;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {\r\nif (selected_second_gate == NI_GPCT_RTSI_GATE_SELECT(i)) {\r\nni_660x_second_gate_select =\r\nselected_second_gate &\r\nselected_second_gate_mask;\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_660x_max_rtsi_channel)\r\nbreak;\r\nfor (i = 0; i <= ni_660x_max_up_down_pin; ++i) {\r\nif (selected_second_gate ==\r\nNI_GPCT_UP_DOWN_PIN_GATE_SELECT(i)) {\r\nni_660x_second_gate_select =\r\nselected_second_gate &\r\nselected_second_gate_mask;\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_660x_max_up_down_pin)\r\nbreak;\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\ncounter_dev->regs[second_gate_reg] |= Gi_Second_Gate_Mode_Bit;\r\ncounter_dev->regs[second_gate_reg] &= ~Gi_Second_Gate_Select_Mask;\r\ncounter_dev->regs[second_gate_reg] |=\r\nGi_Second_Gate_Select_Bits(ni_660x_second_gate_select);\r\nwrite_register(counter, counter_dev->regs[second_gate_reg],\r\nsecond_gate_reg);\r\nreturn 0;\r\n}\r\nstatic int ni_m_series_set_second_gate(struct ni_gpct *counter,\r\nunsigned int gate_source)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nconst unsigned second_gate_reg =\r\nNITIO_Gi_Second_Gate_Reg(counter->counter_index);\r\nconst unsigned selected_second_gate = CR_CHAN(gate_source);\r\nstatic const unsigned selected_second_gate_mask = 0x1f;\r\nunsigned ni_m_series_second_gate_select;\r\nswitch (selected_second_gate) {\r\ndefault:\r\nni_m_series_second_gate_select =\r\nselected_second_gate & selected_second_gate_mask;\r\nbreak;\r\n}\r\ncounter_dev->regs[second_gate_reg] |= Gi_Second_Gate_Mode_Bit;\r\ncounter_dev->regs[second_gate_reg] &= ~Gi_Second_Gate_Select_Mask;\r\ncounter_dev->regs[second_gate_reg] |=\r\nGi_Second_Gate_Select_Bits(ni_m_series_second_gate_select);\r\nwrite_register(counter, counter_dev->regs[second_gate_reg],\r\nsecond_gate_reg);\r\nreturn 0;\r\n}\r\nint ni_tio_set_gate_src(struct ni_gpct *counter, unsigned gate_index,\r\nunsigned int gate_source)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nconst unsigned second_gate_reg =\r\nNITIO_Gi_Second_Gate_Reg(counter->counter_index);\r\nswitch (gate_index) {\r\ncase 0:\r\nif (CR_CHAN(gate_source) == NI_GPCT_DISABLED_GATE_SELECT) {\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Mode_Reg(counter->\r\ncounter_index),\r\nGi_Gating_Mode_Mask,\r\nGi_Gating_Disabled_Bits);\r\nreturn 0;\r\n}\r\nni_tio_set_first_gate_modifiers(counter, gate_source);\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\ncase ni_gpct_variant_m_series:\r\nreturn ni_m_series_set_first_gate(counter, gate_source);\r\nbreak;\r\ncase ni_gpct_variant_660x:\r\nreturn ni_660x_set_first_gate(counter, gate_source);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nbreak;\r\ncase 1:\r\nif (ni_tio_second_gate_registers_present(counter_dev) == 0)\r\nreturn -EINVAL;\r\nif (CR_CHAN(gate_source) == NI_GPCT_DISABLED_GATE_SELECT) {\r\ncounter_dev->regs[second_gate_reg] &=\r\n~Gi_Second_Gate_Mode_Bit;\r\nwrite_register(counter,\r\ncounter_dev->regs[second_gate_reg],\r\nsecond_gate_reg);\r\nreturn 0;\r\n}\r\nif (gate_source & CR_INVERT) {\r\ncounter_dev->regs[second_gate_reg] |=\r\nGi_Second_Gate_Polarity_Bit;\r\n} else {\r\ncounter_dev->regs[second_gate_reg] &=\r\n~Gi_Second_Gate_Polarity_Bit;\r\n}\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_m_series:\r\nreturn ni_m_series_set_second_gate(counter,\r\ngate_source);\r\nbreak;\r\ncase ni_gpct_variant_660x:\r\nreturn ni_660x_set_second_gate(counter, gate_source);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ni_tio_set_other_src(struct ni_gpct *counter, unsigned index,\r\nunsigned int source)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nif (counter_dev->variant == ni_gpct_variant_m_series) {\r\nunsigned int abz_reg, shift, mask;\r\nabz_reg = NITIO_Gi_ABZ_Reg(counter->counter_index);\r\nswitch (index) {\r\ncase NI_GPCT_SOURCE_ENCODER_A:\r\nshift = 10;\r\nbreak;\r\ncase NI_GPCT_SOURCE_ENCODER_B:\r\nshift = 5;\r\nbreak;\r\ncase NI_GPCT_SOURCE_ENCODER_Z:\r\nshift = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nmask = 0x1f << shift;\r\nif (source > 0x1f) {\r\nsource = 0x1f;\r\n}\r\ncounter_dev->regs[abz_reg] &= ~mask;\r\ncounter_dev->regs[abz_reg] |= (source << shift) & mask;\r\nwrite_register(counter, counter_dev->regs[abz_reg], abz_reg);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned ni_660x_first_gate_to_generic_gate_source(unsigned\r\nni_660x_gate_select)\r\n{\r\nunsigned i;\r\nswitch (ni_660x_gate_select) {\r\ncase NI_660x_Source_Pin_i_Gate_Select:\r\nreturn NI_GPCT_SOURCE_PIN_i_GATE_SELECT;\r\nbreak;\r\ncase NI_660x_Gate_Pin_i_Gate_Select:\r\nreturn NI_GPCT_GATE_PIN_i_GATE_SELECT;\r\nbreak;\r\ncase NI_660x_Next_SRC_Gate_Select:\r\nreturn NI_GPCT_NEXT_SOURCE_GATE_SELECT;\r\nbreak;\r\ncase NI_660x_Next_Out_Gate_Select:\r\nreturn NI_GPCT_NEXT_OUT_GATE_SELECT;\r\nbreak;\r\ncase NI_660x_Logic_Low_Gate_Select:\r\nreturn NI_GPCT_LOGIC_LOW_GATE_SELECT;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {\r\nif (ni_660x_gate_select == NI_660x_RTSI_Gate_Select(i)) {\r\nreturn NI_GPCT_RTSI_GATE_SELECT(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_660x_max_rtsi_channel)\r\nbreak;\r\nfor (i = 0; i <= ni_660x_max_gate_pin; ++i) {\r\nif (ni_660x_gate_select ==\r\nNI_660x_Gate_Pin_Gate_Select(i)) {\r\nreturn NI_GPCT_GATE_PIN_GATE_SELECT(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_660x_max_gate_pin)\r\nbreak;\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned ni_m_series_first_gate_to_generic_gate_source(unsigned\r\nni_m_series_gate_select)\r\n{\r\nunsigned i;\r\nswitch (ni_m_series_gate_select) {\r\ncase NI_M_Series_Timestamp_Mux_Gate_Select:\r\nreturn NI_GPCT_TIMESTAMP_MUX_GATE_SELECT;\r\nbreak;\r\ncase NI_M_Series_AI_START2_Gate_Select:\r\nreturn NI_GPCT_AI_START2_GATE_SELECT;\r\nbreak;\r\ncase NI_M_Series_PXI_Star_Trigger_Gate_Select:\r\nreturn NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT;\r\nbreak;\r\ncase NI_M_Series_Next_Out_Gate_Select:\r\nreturn NI_GPCT_NEXT_OUT_GATE_SELECT;\r\nbreak;\r\ncase NI_M_Series_AI_START1_Gate_Select:\r\nreturn NI_GPCT_AI_START1_GATE_SELECT;\r\nbreak;\r\ncase NI_M_Series_Next_SRC_Gate_Select:\r\nreturn NI_GPCT_NEXT_SOURCE_GATE_SELECT;\r\nbreak;\r\ncase NI_M_Series_Analog_Trigger_Out_Gate_Select:\r\nreturn NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT;\r\nbreak;\r\ncase NI_M_Series_Logic_Low_Gate_Select:\r\nreturn NI_GPCT_LOGIC_LOW_GATE_SELECT;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= ni_m_series_max_rtsi_channel; ++i) {\r\nif (ni_m_series_gate_select ==\r\nNI_M_Series_RTSI_Gate_Select(i)) {\r\nreturn NI_GPCT_RTSI_GATE_SELECT(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_m_series_max_rtsi_channel)\r\nbreak;\r\nfor (i = 0; i <= ni_m_series_max_pfi_channel; ++i) {\r\nif (ni_m_series_gate_select ==\r\nNI_M_Series_PFI_Gate_Select(i)) {\r\nreturn NI_GPCT_PFI_GATE_SELECT(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_m_series_max_pfi_channel)\r\nbreak;\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned ni_660x_second_gate_to_generic_gate_source(unsigned\r\nni_660x_gate_select)\r\n{\r\nunsigned i;\r\nswitch (ni_660x_gate_select) {\r\ncase NI_660x_Source_Pin_i_Second_Gate_Select:\r\nreturn NI_GPCT_SOURCE_PIN_i_GATE_SELECT;\r\nbreak;\r\ncase NI_660x_Up_Down_Pin_i_Second_Gate_Select:\r\nreturn NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT;\r\nbreak;\r\ncase NI_660x_Next_SRC_Second_Gate_Select:\r\nreturn NI_GPCT_NEXT_SOURCE_GATE_SELECT;\r\nbreak;\r\ncase NI_660x_Next_Out_Second_Gate_Select:\r\nreturn NI_GPCT_NEXT_OUT_GATE_SELECT;\r\nbreak;\r\ncase NI_660x_Selected_Gate_Second_Gate_Select:\r\nreturn NI_GPCT_SELECTED_GATE_GATE_SELECT;\r\nbreak;\r\ncase NI_660x_Logic_Low_Second_Gate_Select:\r\nreturn NI_GPCT_LOGIC_LOW_GATE_SELECT;\r\nbreak;\r\ndefault:\r\nfor (i = 0; i <= ni_660x_max_rtsi_channel; ++i) {\r\nif (ni_660x_gate_select ==\r\nNI_660x_RTSI_Second_Gate_Select(i)) {\r\nreturn NI_GPCT_RTSI_GATE_SELECT(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_660x_max_rtsi_channel)\r\nbreak;\r\nfor (i = 0; i <= ni_660x_max_up_down_pin; ++i) {\r\nif (ni_660x_gate_select ==\r\nNI_660x_Up_Down_Pin_Second_Gate_Select(i)) {\r\nreturn NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i);\r\nbreak;\r\n}\r\n}\r\nif (i <= ni_660x_max_up_down_pin)\r\nbreak;\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned ni_m_series_second_gate_to_generic_gate_source(unsigned\r\nni_m_series_gate_select)\r\n{\r\nswitch (ni_m_series_gate_select) {\r\ndefault:\r\nreturn ni_m_series_gate_select;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned gate_index,\r\nunsigned int *gate_source)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nconst unsigned mode_bits = ni_tio_get_soft_copy(counter,\r\nNITIO_Gi_Mode_Reg\r\n(counter->\r\ncounter_index));\r\nconst unsigned second_gate_reg =\r\nNITIO_Gi_Second_Gate_Reg(counter->counter_index);\r\nunsigned gate_select_bits;\r\nswitch (gate_index) {\r\ncase 0:\r\nif ((mode_bits & Gi_Gating_Mode_Mask) ==\r\nGi_Gating_Disabled_Bits) {\r\n*gate_source = NI_GPCT_DISABLED_GATE_SELECT;\r\nreturn 0;\r\n} else {\r\ngate_select_bits =\r\n(ni_tio_get_soft_copy(counter,\r\nNITIO_Gi_Input_Select_Reg\r\n(counter->counter_index)) &\r\nGi_Gate_Select_Mask) >> Gi_Gate_Select_Shift;\r\n}\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\ncase ni_gpct_variant_m_series:\r\n*gate_source =\r\nni_m_series_first_gate_to_generic_gate_source\r\n(gate_select_bits);\r\nbreak;\r\ncase ni_gpct_variant_660x:\r\n*gate_source =\r\nni_660x_first_gate_to_generic_gate_source\r\n(gate_select_bits);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nif (mode_bits & Gi_Gate_Polarity_Bit)\r\n*gate_source |= CR_INVERT;\r\nif ((mode_bits & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits)\r\n*gate_source |= CR_EDGE;\r\nbreak;\r\ncase 1:\r\nif ((mode_bits & Gi_Gating_Mode_Mask) == Gi_Gating_Disabled_Bits\r\n|| (counter_dev->regs[second_gate_reg] &\r\nGi_Second_Gate_Mode_Bit)\r\n== 0) {\r\n*gate_source = NI_GPCT_DISABLED_GATE_SELECT;\r\nreturn 0;\r\n} else {\r\ngate_select_bits =\r\n(counter_dev->regs[second_gate_reg] &\r\nGi_Second_Gate_Select_Mask) >>\r\nGi_Second_Gate_Select_Shift;\r\n}\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\ncase ni_gpct_variant_m_series:\r\n*gate_source =\r\nni_m_series_second_gate_to_generic_gate_source\r\n(gate_select_bits);\r\nbreak;\r\ncase ni_gpct_variant_660x:\r\n*gate_source =\r\nni_660x_second_gate_to_generic_gate_source\r\n(gate_select_bits);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nif (counter_dev->regs[second_gate_reg] &\r\nGi_Second_Gate_Polarity_Bit) {\r\n*gate_source |= CR_INVERT;\r\n}\r\nif ((mode_bits & Gi_Gating_Mode_Mask) != Gi_Level_Gating_Bits)\r\n*gate_source |= CR_EDGE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint ni_tio_insn_config(struct ni_gpct *counter,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_SET_COUNTER_MODE:\r\nreturn ni_tio_set_counter_mode(counter, data[1]);\r\nbreak;\r\ncase INSN_CONFIG_ARM:\r\nreturn ni_tio_arm(counter, 1, data[1]);\r\nbreak;\r\ncase INSN_CONFIG_DISARM:\r\nni_tio_arm(counter, 0, 0);\r\nreturn 0;\r\nbreak;\r\ncase INSN_CONFIG_GET_COUNTER_STATUS:\r\ndata[1] = ni_tio_counter_status(counter);\r\ndata[2] = counter_status_mask;\r\nreturn 0;\r\nbreak;\r\ncase INSN_CONFIG_SET_CLOCK_SRC:\r\nreturn ni_tio_set_clock_src(counter, data[1], data[2]);\r\nbreak;\r\ncase INSN_CONFIG_GET_CLOCK_SRC:\r\nni_tio_get_clock_src(counter, &data[1], &data[2]);\r\nreturn 0;\r\nbreak;\r\ncase INSN_CONFIG_SET_GATE_SRC:\r\nreturn ni_tio_set_gate_src(counter, data[1], data[2]);\r\nbreak;\r\ncase INSN_CONFIG_GET_GATE_SRC:\r\nreturn ni_tio_get_gate_src(counter, data[1], &data[2]);\r\nbreak;\r\ncase INSN_CONFIG_SET_OTHER_SRC:\r\nreturn ni_tio_set_other_src(counter, data[1], data[2]);\r\nbreak;\r\ncase INSN_CONFIG_RESET:\r\nni_tio_reset_count_and_disarm(counter);\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint ni_tio_rinsn(struct ni_gpct *counter, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nconst unsigned channel = CR_CHAN(insn->chanspec);\r\nunsigned first_read;\r\nunsigned second_read;\r\nunsigned correct_read;\r\nif (insn->n < 1)\r\nreturn 0;\r\nswitch (channel) {\r\ncase 0:\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Command_Reg(counter->counter_index),\r\nGi_Save_Trace_Bit, 0);\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Command_Reg(counter->counter_index),\r\nGi_Save_Trace_Bit, Gi_Save_Trace_Bit);\r\nfirst_read =\r\nread_register(counter,\r\nNITIO_Gi_SW_Save_Reg(counter->counter_index));\r\nsecond_read =\r\nread_register(counter,\r\nNITIO_Gi_SW_Save_Reg(counter->counter_index));\r\nif (first_read != second_read)\r\ncorrect_read =\r\nread_register(counter,\r\nNITIO_Gi_SW_Save_Reg(counter->\r\ncounter_index));\r\nelse\r\ncorrect_read = first_read;\r\ndata[0] = correct_read;\r\nreturn 0;\r\nbreak;\r\ncase 1:\r\ndata[0] =\r\ncounter_dev->\r\nregs[NITIO_Gi_LoadA_Reg(counter->counter_index)];\r\nbreak;\r\ncase 2:\r\ndata[0] =\r\ncounter_dev->\r\nregs[NITIO_Gi_LoadB_Reg(counter->counter_index)];\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned ni_tio_next_load_register(struct ni_gpct *counter)\r\n{\r\nconst unsigned bits = read_register(counter,\r\nNITIO_Gxx_Status_Reg(counter->\r\ncounter_index));\r\nif (bits & Gi_Next_Load_Source_Bit(counter->counter_index))\r\nreturn NITIO_Gi_LoadB_Reg(counter->counter_index);\r\nelse\r\nreturn NITIO_Gi_LoadA_Reg(counter->counter_index);\r\n}\r\nint ni_tio_winsn(struct ni_gpct *counter, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nconst unsigned channel = CR_CHAN(insn->chanspec);\r\nunsigned load_reg;\r\nif (insn->n < 1)\r\nreturn 0;\r\nswitch (channel) {\r\ncase 0:\r\nload_reg = ni_tio_next_load_register(counter);\r\nwrite_register(counter, data[0], load_reg);\r\nni_tio_set_bits_transient(counter,\r\nNITIO_Gi_Command_Reg(counter->\r\ncounter_index),\r\n0, 0, Gi_Load_Bit);\r\nwrite_register(counter, counter_dev->regs[load_reg], load_reg);\r\nbreak;\r\ncase 1:\r\ncounter_dev->regs[NITIO_Gi_LoadA_Reg(counter->counter_index)] =\r\ndata[0];\r\nwrite_register(counter, data[0],\r\nNITIO_Gi_LoadA_Reg(counter->counter_index));\r\nbreak;\r\ncase 2:\r\ncounter_dev->regs[NITIO_Gi_LoadB_Reg(counter->counter_index)] =\r\ndata[0];\r\nwrite_register(counter, data[0],\r\nNITIO_Gi_LoadB_Reg(counter->counter_index));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}
