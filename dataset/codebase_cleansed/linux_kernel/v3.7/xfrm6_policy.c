static struct dst_entry *xfrm6_dst_lookup(struct net *net, int tos,\r\nconst xfrm_address_t *saddr,\r\nconst xfrm_address_t *daddr)\r\n{\r\nstruct flowi6 fl6;\r\nstruct dst_entry *dst;\r\nint err;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nmemcpy(&fl6.daddr, daddr, sizeof(fl6.daddr));\r\nif (saddr)\r\nmemcpy(&fl6.saddr, saddr, sizeof(fl6.saddr));\r\ndst = ip6_route_output(net, NULL, &fl6);\r\nerr = dst->error;\r\nif (dst->error) {\r\ndst_release(dst);\r\ndst = ERR_PTR(err);\r\n}\r\nreturn dst;\r\n}\r\nstatic int xfrm6_get_saddr(struct net *net,\r\nxfrm_address_t *saddr, xfrm_address_t *daddr)\r\n{\r\nstruct dst_entry *dst;\r\nstruct net_device *dev;\r\ndst = xfrm6_dst_lookup(net, 0, NULL, daddr);\r\nif (IS_ERR(dst))\r\nreturn -EHOSTUNREACH;\r\ndev = ip6_dst_idev(dst)->dev;\r\nipv6_dev_get_saddr(dev_net(dev), dev,\r\n(struct in6_addr *)&daddr->a6, 0,\r\n(struct in6_addr *)&saddr->a6);\r\ndst_release(dst);\r\nreturn 0;\r\n}\r\nstatic int xfrm6_get_tos(const struct flowi *fl)\r\n{\r\nreturn 0;\r\n}\r\nstatic void xfrm6_init_dst(struct net *net, struct xfrm_dst *xdst)\r\n{\r\nstruct rt6_info *rt = (struct rt6_info *)xdst;\r\nrt6_init_peer(rt, net->ipv6.peers);\r\n}\r\nstatic int xfrm6_init_path(struct xfrm_dst *path, struct dst_entry *dst,\r\nint nfheader_len)\r\n{\r\nif (dst->ops->family == AF_INET6) {\r\nstruct rt6_info *rt = (struct rt6_info*)dst;\r\nif (rt->rt6i_node)\r\npath->path_cookie = rt->rt6i_node->fn_sernum;\r\n}\r\npath->u.rt6.rt6i_nfheader_len = nfheader_len;\r\nreturn 0;\r\n}\r\nstatic int xfrm6_fill_dst(struct xfrm_dst *xdst, struct net_device *dev,\r\nconst struct flowi *fl)\r\n{\r\nstruct rt6_info *rt = (struct rt6_info*)xdst->route;\r\nxdst->u.dst.dev = dev;\r\ndev_hold(dev);\r\nxdst->u.rt6.rt6i_idev = in6_dev_get(dev);\r\nif (!xdst->u.rt6.rt6i_idev)\r\nreturn -ENODEV;\r\nrt6_transfer_peer(&xdst->u.rt6, rt);\r\nxdst->u.rt6.n = neigh_clone(rt->n);\r\nxdst->u.rt6.rt6i_flags = rt->rt6i_flags & (RTF_ANYCAST |\r\nRTF_LOCAL);\r\nxdst->u.rt6.rt6i_metric = rt->rt6i_metric;\r\nxdst->u.rt6.rt6i_node = rt->rt6i_node;\r\nif (rt->rt6i_node)\r\nxdst->route_cookie = rt->rt6i_node->fn_sernum;\r\nxdst->u.rt6.rt6i_gateway = rt->rt6i_gateway;\r\nxdst->u.rt6.rt6i_dst = rt->rt6i_dst;\r\nxdst->u.rt6.rt6i_src = rt->rt6i_src;\r\nreturn 0;\r\n}\r\nstatic inline void\r\n_decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)\r\n{\r\nstruct flowi6 *fl6 = &fl->u.ip6;\r\nint onlyproto = 0;\r\nu16 offset = skb_network_header_len(skb);\r\nconst struct ipv6hdr *hdr = ipv6_hdr(skb);\r\nstruct ipv6_opt_hdr *exthdr;\r\nconst unsigned char *nh = skb_network_header(skb);\r\nu8 nexthdr = nh[IP6CB(skb)->nhoff];\r\nmemset(fl6, 0, sizeof(struct flowi6));\r\nfl6->flowi6_mark = skb->mark;\r\nfl6->daddr = reverse ? hdr->saddr : hdr->daddr;\r\nfl6->saddr = reverse ? hdr->daddr : hdr->saddr;\r\nwhile (nh + offset + 1 < skb->data ||\r\npskb_may_pull(skb, nh + offset + 1 - skb->data)) {\r\nnh = skb_network_header(skb);\r\nexthdr = (struct ipv6_opt_hdr *)(nh + offset);\r\nswitch (nexthdr) {\r\ncase NEXTHDR_FRAGMENT:\r\nonlyproto = 1;\r\ncase NEXTHDR_ROUTING:\r\ncase NEXTHDR_HOP:\r\ncase NEXTHDR_DEST:\r\noffset += ipv6_optlen(exthdr);\r\nnexthdr = exthdr->nexthdr;\r\nexthdr = (struct ipv6_opt_hdr *)(nh + offset);\r\nbreak;\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE:\r\ncase IPPROTO_TCP:\r\ncase IPPROTO_SCTP:\r\ncase IPPROTO_DCCP:\r\nif (!onlyproto && (nh + offset + 4 < skb->data ||\r\npskb_may_pull(skb, nh + offset + 4 - skb->data))) {\r\n__be16 *ports = (__be16 *)exthdr;\r\nfl6->fl6_sport = ports[!!reverse];\r\nfl6->fl6_dport = ports[!reverse];\r\n}\r\nfl6->flowi6_proto = nexthdr;\r\nreturn;\r\ncase IPPROTO_ICMPV6:\r\nif (!onlyproto && pskb_may_pull(skb, nh + offset + 2 - skb->data)) {\r\nu8 *icmp = (u8 *)exthdr;\r\nfl6->fl6_icmp_type = icmp[0];\r\nfl6->fl6_icmp_code = icmp[1];\r\n}\r\nfl6->flowi6_proto = nexthdr;\r\nreturn;\r\n#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\r\ncase IPPROTO_MH:\r\nif (!onlyproto && pskb_may_pull(skb, nh + offset + 3 - skb->data)) {\r\nstruct ip6_mh *mh;\r\nmh = (struct ip6_mh *)exthdr;\r\nfl6->fl6_mh_type = mh->ip6mh_type;\r\n}\r\nfl6->flowi6_proto = nexthdr;\r\nreturn;\r\n#endif\r\ncase IPPROTO_AH:\r\ncase IPPROTO_ESP:\r\ncase IPPROTO_COMP:\r\ndefault:\r\nfl6->fl6_ipsec_spi = 0;\r\nfl6->flowi6_proto = nexthdr;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic inline int xfrm6_garbage_collect(struct dst_ops *ops)\r\n{\r\nstruct net *net = container_of(ops, struct net, xfrm.xfrm6_dst_ops);\r\nxfrm6_policy_afinfo.garbage_collect(net);\r\nreturn dst_entries_get_fast(ops) > ops->gc_thresh * 2;\r\n}\r\nstatic void xfrm6_update_pmtu(struct dst_entry *dst, struct sock *sk,\r\nstruct sk_buff *skb, u32 mtu)\r\n{\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nstruct dst_entry *path = xdst->route;\r\npath->ops->update_pmtu(path, sk, skb, mtu);\r\n}\r\nstatic void xfrm6_redirect(struct dst_entry *dst, struct sock *sk,\r\nstruct sk_buff *skb)\r\n{\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nstruct dst_entry *path = xdst->route;\r\npath->ops->redirect(path, sk, skb);\r\n}\r\nstatic void xfrm6_dst_destroy(struct dst_entry *dst)\r\n{\r\nstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\r\nif (likely(xdst->u.rt6.rt6i_idev))\r\nin6_dev_put(xdst->u.rt6.rt6i_idev);\r\ndst_destroy_metrics_generic(dst);\r\nif (rt6_has_peer(&xdst->u.rt6)) {\r\nstruct inet_peer *peer = rt6_peer_ptr(&xdst->u.rt6);\r\ninet_putpeer(peer);\r\n}\r\nxfrm_dst_destroy(xdst);\r\n}\r\nstatic void xfrm6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,\r\nint unregister)\r\n{\r\nstruct xfrm_dst *xdst;\r\nif (!unregister)\r\nreturn;\r\nxdst = (struct xfrm_dst *)dst;\r\nif (xdst->u.rt6.rt6i_idev->dev == dev) {\r\nstruct inet6_dev *loopback_idev =\r\nin6_dev_get(dev_net(dev)->loopback_dev);\r\nBUG_ON(!loopback_idev);\r\ndo {\r\nin6_dev_put(xdst->u.rt6.rt6i_idev);\r\nxdst->u.rt6.rt6i_idev = loopback_idev;\r\nin6_dev_hold(loopback_idev);\r\nxdst = (struct xfrm_dst *)xdst->u.dst.child;\r\n} while (xdst->u.dst.xfrm);\r\n__in6_dev_put(loopback_idev);\r\n}\r\nxfrm_dst_ifdown(dst, dev);\r\n}\r\nstatic int __init xfrm6_policy_init(void)\r\n{\r\nreturn xfrm_policy_register_afinfo(&xfrm6_policy_afinfo);\r\n}\r\nstatic void xfrm6_policy_fini(void)\r\n{\r\nxfrm_policy_unregister_afinfo(&xfrm6_policy_afinfo);\r\n}\r\nint __init xfrm6_init(void)\r\n{\r\nint ret;\r\nunsigned int gc_thresh;\r\ngc_thresh = FIB6_TABLE_HASHSZ * 8;\r\nxfrm6_dst_ops.gc_thresh = (gc_thresh < 1024) ? 1024 : gc_thresh;\r\ndst_entries_init(&xfrm6_dst_ops);\r\nret = xfrm6_policy_init();\r\nif (ret) {\r\ndst_entries_destroy(&xfrm6_dst_ops);\r\ngoto out;\r\n}\r\nret = xfrm6_state_init();\r\nif (ret)\r\ngoto out_policy;\r\n#ifdef CONFIG_SYSCTL\r\nsysctl_hdr = register_net_sysctl(&init_net, "net/ipv6",\r\nxfrm6_policy_table);\r\n#endif\r\nout:\r\nreturn ret;\r\nout_policy:\r\nxfrm6_policy_fini();\r\ngoto out;\r\n}\r\nvoid xfrm6_fini(void)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nif (sysctl_hdr)\r\nunregister_net_sysctl_table(sysctl_hdr);\r\n#endif\r\nxfrm6_policy_fini();\r\nxfrm6_state_fini();\r\ndst_entries_destroy(&xfrm6_dst_ops);\r\n}
