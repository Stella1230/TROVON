void phy_device_free(struct phy_device *phydev)\r\n{\r\nkfree(phydev);\r\n}\r\nstatic void phy_device_release(struct device *dev)\r\n{\r\nphy_device_free(to_phy_device(dev));\r\n}\r\nint phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,\r\nint (*run)(struct phy_device *))\r\n{\r\nstruct phy_fixup *fixup;\r\nfixup = kzalloc(sizeof(struct phy_fixup), GFP_KERNEL);\r\nif (!fixup)\r\nreturn -ENOMEM;\r\nstrlcpy(fixup->bus_id, bus_id, sizeof(fixup->bus_id));\r\nfixup->phy_uid = phy_uid;\r\nfixup->phy_uid_mask = phy_uid_mask;\r\nfixup->run = run;\r\nmutex_lock(&phy_fixup_lock);\r\nlist_add_tail(&fixup->list, &phy_fixup_list);\r\nmutex_unlock(&phy_fixup_lock);\r\nreturn 0;\r\n}\r\nint phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,\r\nint (*run)(struct phy_device *))\r\n{\r\nreturn phy_register_fixup(PHY_ANY_ID, phy_uid, phy_uid_mask, run);\r\n}\r\nint phy_register_fixup_for_id(const char *bus_id,\r\nint (*run)(struct phy_device *))\r\n{\r\nreturn phy_register_fixup(bus_id, PHY_ANY_UID, 0xffffffff, run);\r\n}\r\nstatic int phy_needs_fixup(struct phy_device *phydev, struct phy_fixup *fixup)\r\n{\r\nif (strcmp(fixup->bus_id, dev_name(&phydev->dev)) != 0)\r\nif (strcmp(fixup->bus_id, PHY_ANY_ID) != 0)\r\nreturn 0;\r\nif ((fixup->phy_uid & fixup->phy_uid_mask) !=\r\n(phydev->phy_id & fixup->phy_uid_mask))\r\nif (fixup->phy_uid != PHY_ANY_UID)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint phy_scan_fixups(struct phy_device *phydev)\r\n{\r\nstruct phy_fixup *fixup;\r\nmutex_lock(&phy_fixup_lock);\r\nlist_for_each_entry(fixup, &phy_fixup_list, list) {\r\nif (phy_needs_fixup(phydev, fixup)) {\r\nint err;\r\nerr = fixup->run(phydev);\r\nif (err < 0) {\r\nmutex_unlock(&phy_fixup_lock);\r\nreturn err;\r\n}\r\n}\r\n}\r\nmutex_unlock(&phy_fixup_lock);\r\nreturn 0;\r\n}\r\nstruct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,\r\nbool is_c45, struct phy_c45_device_ids *c45_ids)\r\n{\r\nstruct phy_device *dev;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (NULL == dev)\r\nreturn (struct phy_device*) PTR_ERR((void*)-ENOMEM);\r\ndev->dev.release = phy_device_release;\r\ndev->speed = 0;\r\ndev->duplex = -1;\r\ndev->pause = dev->asym_pause = 0;\r\ndev->link = 1;\r\ndev->interface = PHY_INTERFACE_MODE_GMII;\r\ndev->autoneg = AUTONEG_ENABLE;\r\ndev->is_c45 = is_c45;\r\ndev->addr = addr;\r\ndev->phy_id = phy_id;\r\nif (c45_ids)\r\ndev->c45_ids = *c45_ids;\r\ndev->bus = bus;\r\ndev->dev.parent = bus->parent;\r\ndev->dev.bus = &mdio_bus_type;\r\ndev->irq = bus->irq != NULL ? bus->irq[addr] : PHY_POLL;\r\ndev_set_name(&dev->dev, PHY_ID_FMT, bus->id, addr);\r\ndev->state = PHY_DOWN;\r\nmutex_init(&dev->lock);\r\nINIT_DELAYED_WORK(&dev->state_queue, phy_state_machine);\r\nrequest_module(MDIO_MODULE_PREFIX MDIO_ID_FMT, MDIO_ID_ARGS(phy_id));\r\nreturn dev;\r\n}\r\nstatic int get_phy_c45_ids(struct mii_bus *bus, int addr, u32 *phy_id,\r\nstruct phy_c45_device_ids *c45_ids) {\r\nint phy_reg;\r\nint i, reg_addr;\r\nconst int num_ids = ARRAY_SIZE(c45_ids->device_ids);\r\nfor (i = 1;\r\ni < num_ids && c45_ids->devices_in_package == 0;\r\ni++) {\r\nreg_addr = MII_ADDR_C45 | i << 16 | 6;\r\nphy_reg = mdiobus_read(bus, addr, reg_addr);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\nc45_ids->devices_in_package = (phy_reg & 0xffff) << 16;\r\nreg_addr = MII_ADDR_C45 | i << 16 | 5;\r\nphy_reg = mdiobus_read(bus, addr, reg_addr);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\nc45_ids->devices_in_package |= (phy_reg & 0xffff);\r\nif ((c45_ids->devices_in_package & 0x1fffffff) == 0x1fffffff) {\r\n*phy_id = 0xffffffff;\r\nreturn 0;\r\n}\r\n}\r\nfor (i = 1; i < num_ids; i++) {\r\nif (!(c45_ids->devices_in_package & (1 << i)))\r\ncontinue;\r\nreg_addr = MII_ADDR_C45 | i << 16 | MII_PHYSID1;\r\nphy_reg = mdiobus_read(bus, addr, reg_addr);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\nc45_ids->device_ids[i] = (phy_reg & 0xffff) << 16;\r\nreg_addr = MII_ADDR_C45 | i << 16 | MII_PHYSID2;\r\nphy_reg = mdiobus_read(bus, addr, reg_addr);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\nc45_ids->device_ids[i] |= (phy_reg & 0xffff);\r\n}\r\n*phy_id = 0;\r\nreturn 0;\r\n}\r\nstatic int get_phy_id(struct mii_bus *bus, int addr, u32 *phy_id,\r\nbool is_c45, struct phy_c45_device_ids *c45_ids)\r\n{\r\nint phy_reg;\r\nif (is_c45)\r\nreturn get_phy_c45_ids(bus, addr, phy_id, c45_ids);\r\nphy_reg = mdiobus_read(bus, addr, MII_PHYSID1);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\n*phy_id = (phy_reg & 0xffff) << 16;\r\nphy_reg = mdiobus_read(bus, addr, MII_PHYSID2);\r\nif (phy_reg < 0)\r\nreturn -EIO;\r\n*phy_id |= (phy_reg & 0xffff);\r\nreturn 0;\r\n}\r\nstruct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45)\r\n{\r\nstruct phy_c45_device_ids c45_ids = {0};\r\nstruct phy_device *dev = NULL;\r\nu32 phy_id = 0;\r\nint r;\r\nr = get_phy_id(bus, addr, &phy_id, is_c45, &c45_ids);\r\nif (r)\r\nreturn ERR_PTR(r);\r\nif ((phy_id & 0x1fffffff) == 0x1fffffff)\r\nreturn NULL;\r\ndev = phy_device_create(bus, addr, phy_id, is_c45, &c45_ids);\r\nreturn dev;\r\n}\r\nint phy_device_register(struct phy_device *phydev)\r\n{\r\nint err;\r\nif (phydev->bus->phy_map[phydev->addr])\r\nreturn -EINVAL;\r\nphydev->bus->phy_map[phydev->addr] = phydev;\r\nphy_scan_fixups(phydev);\r\nerr = device_register(&phydev->dev);\r\nif (err) {\r\npr_err("phy %d failed to register\n", phydev->addr);\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nphydev->bus->phy_map[phydev->addr] = NULL;\r\nreturn err;\r\n}\r\nstruct phy_device *phy_find_first(struct mii_bus *bus)\r\n{\r\nint addr;\r\nfor (addr = 0; addr < PHY_MAX_ADDR; addr++) {\r\nif (bus->phy_map[addr])\r\nreturn bus->phy_map[addr];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void phy_prepare_link(struct phy_device *phydev,\r\nvoid (*handler)(struct net_device *))\r\n{\r\nphydev->adjust_link = handler;\r\n}\r\nint phy_connect_direct(struct net_device *dev, struct phy_device *phydev,\r\nvoid (*handler)(struct net_device *), u32 flags,\r\nphy_interface_t interface)\r\n{\r\nint rc;\r\nrc = phy_attach_direct(dev, phydev, flags, interface);\r\nif (rc)\r\nreturn rc;\r\nphy_prepare_link(phydev, handler);\r\nphy_start_machine(phydev, NULL);\r\nif (phydev->irq > 0)\r\nphy_start_interrupts(phydev);\r\nreturn 0;\r\n}\r\nstruct phy_device * phy_connect(struct net_device *dev, const char *bus_id,\r\nvoid (*handler)(struct net_device *), u32 flags,\r\nphy_interface_t interface)\r\n{\r\nstruct phy_device *phydev;\r\nstruct device *d;\r\nint rc;\r\nd = bus_find_device_by_name(&mdio_bus_type, NULL, bus_id);\r\nif (!d) {\r\npr_err("PHY %s not found\n", bus_id);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nphydev = to_phy_device(d);\r\nrc = phy_connect_direct(dev, phydev, handler, flags, interface);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nreturn phydev;\r\n}\r\nvoid phy_disconnect(struct phy_device *phydev)\r\n{\r\nif (phydev->irq > 0)\r\nphy_stop_interrupts(phydev);\r\nphy_stop_machine(phydev);\r\nphydev->adjust_link = NULL;\r\nphy_detach(phydev);\r\n}\r\nint phy_init_hw(struct phy_device *phydev)\r\n{\r\nint ret;\r\nif (!phydev->drv || !phydev->drv->config_init)\r\nreturn 0;\r\nret = phy_scan_fixups(phydev);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn phydev->drv->config_init(phydev);\r\n}\r\nstatic int phy_attach_direct(struct net_device *dev, struct phy_device *phydev,\r\nu32 flags, phy_interface_t interface)\r\n{\r\nstruct device *d = &phydev->dev;\r\nint err;\r\nif (NULL == d->driver) {\r\nif (phydev->is_c45) {\r\npr_err("No driver for phy %x\n", phydev->phy_id);\r\nreturn -ENODEV;\r\n}\r\nd->driver = &genphy_driver.driver;\r\nerr = d->driver->probe(d);\r\nif (err >= 0)\r\nerr = device_bind_driver(d);\r\nif (err)\r\nreturn err;\r\n}\r\nif (phydev->attached_dev) {\r\ndev_err(&dev->dev, "PHY already attached\n");\r\nreturn -EBUSY;\r\n}\r\nphydev->attached_dev = dev;\r\ndev->phydev = phydev;\r\nphydev->dev_flags = flags;\r\nphydev->interface = interface;\r\nphydev->state = PHY_READY;\r\nerr = phy_init_hw(phydev);\r\nif (err)\r\nphy_detach(phydev);\r\nreturn err;\r\n}\r\nstruct phy_device *phy_attach(struct net_device *dev,\r\nconst char *bus_id, u32 flags, phy_interface_t interface)\r\n{\r\nstruct bus_type *bus = &mdio_bus_type;\r\nstruct phy_device *phydev;\r\nstruct device *d;\r\nint rc;\r\nd = bus_find_device_by_name(bus, NULL, bus_id);\r\nif (!d) {\r\npr_err("PHY %s not found\n", bus_id);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nphydev = to_phy_device(d);\r\nrc = phy_attach_direct(dev, phydev, flags, interface);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nreturn phydev;\r\n}\r\nvoid phy_detach(struct phy_device *phydev)\r\n{\r\nphydev->attached_dev->phydev = NULL;\r\nphydev->attached_dev = NULL;\r\nif (phydev->dev.driver == &genphy_driver.driver)\r\ndevice_release_driver(&phydev->dev);\r\n}\r\nstatic int genphy_config_advert(struct phy_device *phydev)\r\n{\r\nu32 advertise;\r\nint oldadv, adv;\r\nint err, changed = 0;\r\nphydev->advertising &= phydev->supported;\r\nadvertise = phydev->advertising;\r\noldadv = adv = phy_read(phydev, MII_ADVERTISE);\r\nif (adv < 0)\r\nreturn adv;\r\nadv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4 | ADVERTISE_PAUSE_CAP |\r\nADVERTISE_PAUSE_ASYM);\r\nadv |= ethtool_adv_to_mii_adv_t(advertise);\r\nif (adv != oldadv) {\r\nerr = phy_write(phydev, MII_ADVERTISE, adv);\r\nif (err < 0)\r\nreturn err;\r\nchanged = 1;\r\n}\r\nif (phydev->supported & (SUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full)) {\r\noldadv = adv = phy_read(phydev, MII_CTRL1000);\r\nif (adv < 0)\r\nreturn adv;\r\nadv &= ~(ADVERTISE_1000FULL | ADVERTISE_1000HALF);\r\nadv |= ethtool_adv_to_mii_ctrl1000_t(advertise);\r\nif (adv != oldadv) {\r\nerr = phy_write(phydev, MII_CTRL1000, adv);\r\nif (err < 0)\r\nreturn err;\r\nchanged = 1;\r\n}\r\n}\r\nreturn changed;\r\n}\r\nstatic int genphy_setup_forced(struct phy_device *phydev)\r\n{\r\nint err;\r\nint ctl = 0;\r\nphydev->pause = phydev->asym_pause = 0;\r\nif (SPEED_1000 == phydev->speed)\r\nctl |= BMCR_SPEED1000;\r\nelse if (SPEED_100 == phydev->speed)\r\nctl |= BMCR_SPEED100;\r\nif (DUPLEX_FULL == phydev->duplex)\r\nctl |= BMCR_FULLDPLX;\r\nerr = phy_write(phydev, MII_BMCR, ctl);\r\nreturn err;\r\n}\r\nint genphy_restart_aneg(struct phy_device *phydev)\r\n{\r\nint ctl;\r\nctl = phy_read(phydev, MII_BMCR);\r\nif (ctl < 0)\r\nreturn ctl;\r\nctl |= (BMCR_ANENABLE | BMCR_ANRESTART);\r\nctl &= ~(BMCR_ISOLATE);\r\nctl = phy_write(phydev, MII_BMCR, ctl);\r\nreturn ctl;\r\n}\r\nint genphy_config_aneg(struct phy_device *phydev)\r\n{\r\nint result;\r\nif (AUTONEG_ENABLE != phydev->autoneg)\r\nreturn genphy_setup_forced(phydev);\r\nresult = genphy_config_advert(phydev);\r\nif (result < 0)\r\nreturn result;\r\nif (result == 0) {\r\nint ctl = phy_read(phydev, MII_BMCR);\r\nif (ctl < 0)\r\nreturn ctl;\r\nif (!(ctl & BMCR_ANENABLE) || (ctl & BMCR_ISOLATE))\r\nresult = 1;\r\n}\r\nif (result > 0)\r\nresult = genphy_restart_aneg(phydev);\r\nreturn result;\r\n}\r\nint genphy_update_link(struct phy_device *phydev)\r\n{\r\nint status;\r\nstatus = phy_read(phydev, MII_BMSR);\r\nif (status < 0)\r\nreturn status;\r\nstatus = phy_read(phydev, MII_BMSR);\r\nif (status < 0)\r\nreturn status;\r\nif ((status & BMSR_LSTATUS) == 0)\r\nphydev->link = 0;\r\nelse\r\nphydev->link = 1;\r\nreturn 0;\r\n}\r\nint genphy_read_status(struct phy_device *phydev)\r\n{\r\nint adv;\r\nint err;\r\nint lpa;\r\nint lpagb = 0;\r\nerr = genphy_update_link(phydev);\r\nif (err)\r\nreturn err;\r\nif (AUTONEG_ENABLE == phydev->autoneg) {\r\nif (phydev->supported & (SUPPORTED_1000baseT_Half\r\n| SUPPORTED_1000baseT_Full)) {\r\nlpagb = phy_read(phydev, MII_STAT1000);\r\nif (lpagb < 0)\r\nreturn lpagb;\r\nadv = phy_read(phydev, MII_CTRL1000);\r\nif (adv < 0)\r\nreturn adv;\r\nlpagb &= adv << 2;\r\n}\r\nlpa = phy_read(phydev, MII_LPA);\r\nif (lpa < 0)\r\nreturn lpa;\r\nadv = phy_read(phydev, MII_ADVERTISE);\r\nif (adv < 0)\r\nreturn adv;\r\nlpa &= adv;\r\nphydev->speed = SPEED_10;\r\nphydev->duplex = DUPLEX_HALF;\r\nphydev->pause = phydev->asym_pause = 0;\r\nif (lpagb & (LPA_1000FULL | LPA_1000HALF)) {\r\nphydev->speed = SPEED_1000;\r\nif (lpagb & LPA_1000FULL)\r\nphydev->duplex = DUPLEX_FULL;\r\n} else if (lpa & (LPA_100FULL | LPA_100HALF)) {\r\nphydev->speed = SPEED_100;\r\nif (lpa & LPA_100FULL)\r\nphydev->duplex = DUPLEX_FULL;\r\n} else\r\nif (lpa & LPA_10FULL)\r\nphydev->duplex = DUPLEX_FULL;\r\nif (phydev->duplex == DUPLEX_FULL){\r\nphydev->pause = lpa & LPA_PAUSE_CAP ? 1 : 0;\r\nphydev->asym_pause = lpa & LPA_PAUSE_ASYM ? 1 : 0;\r\n}\r\n} else {\r\nint bmcr = phy_read(phydev, MII_BMCR);\r\nif (bmcr < 0)\r\nreturn bmcr;\r\nif (bmcr & BMCR_FULLDPLX)\r\nphydev->duplex = DUPLEX_FULL;\r\nelse\r\nphydev->duplex = DUPLEX_HALF;\r\nif (bmcr & BMCR_SPEED1000)\r\nphydev->speed = SPEED_1000;\r\nelse if (bmcr & BMCR_SPEED100)\r\nphydev->speed = SPEED_100;\r\nelse\r\nphydev->speed = SPEED_10;\r\nphydev->pause = phydev->asym_pause = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int genphy_config_init(struct phy_device *phydev)\r\n{\r\nint val;\r\nu32 features;\r\nfeatures = (SUPPORTED_TP | SUPPORTED_MII\r\n| SUPPORTED_AUI | SUPPORTED_FIBRE |\r\nSUPPORTED_BNC);\r\nval = phy_read(phydev, MII_BMSR);\r\nif (val < 0)\r\nreturn val;\r\nif (val & BMSR_ANEGCAPABLE)\r\nfeatures |= SUPPORTED_Autoneg;\r\nif (val & BMSR_100FULL)\r\nfeatures |= SUPPORTED_100baseT_Full;\r\nif (val & BMSR_100HALF)\r\nfeatures |= SUPPORTED_100baseT_Half;\r\nif (val & BMSR_10FULL)\r\nfeatures |= SUPPORTED_10baseT_Full;\r\nif (val & BMSR_10HALF)\r\nfeatures |= SUPPORTED_10baseT_Half;\r\nif (val & BMSR_ESTATEN) {\r\nval = phy_read(phydev, MII_ESTATUS);\r\nif (val < 0)\r\nreturn val;\r\nif (val & ESTATUS_1000_TFULL)\r\nfeatures |= SUPPORTED_1000baseT_Full;\r\nif (val & ESTATUS_1000_THALF)\r\nfeatures |= SUPPORTED_1000baseT_Half;\r\n}\r\nphydev->supported = features;\r\nphydev->advertising = features;\r\nreturn 0;\r\n}\r\nint genphy_suspend(struct phy_device *phydev)\r\n{\r\nint value;\r\nmutex_lock(&phydev->lock);\r\nvalue = phy_read(phydev, MII_BMCR);\r\nphy_write(phydev, MII_BMCR, (value | BMCR_PDOWN));\r\nmutex_unlock(&phydev->lock);\r\nreturn 0;\r\n}\r\nint genphy_resume(struct phy_device *phydev)\r\n{\r\nint value;\r\nmutex_lock(&phydev->lock);\r\nvalue = phy_read(phydev, MII_BMCR);\r\nphy_write(phydev, MII_BMCR, (value & ~BMCR_PDOWN));\r\nmutex_unlock(&phydev->lock);\r\nreturn 0;\r\n}\r\nstatic int phy_probe(struct device *dev)\r\n{\r\nstruct phy_device *phydev;\r\nstruct phy_driver *phydrv;\r\nstruct device_driver *drv;\r\nint err = 0;\r\nphydev = to_phy_device(dev);\r\ndrv = phydev->dev.driver;\r\nphydrv = to_phy_driver(drv);\r\nphydev->drv = phydrv;\r\nif (!(phydrv->flags & PHY_HAS_INTERRUPT))\r\nphydev->irq = PHY_POLL;\r\nmutex_lock(&phydev->lock);\r\nphydev->supported = phydrv->features;\r\nphydev->advertising = phydrv->features;\r\nphydev->state = PHY_READY;\r\nif (phydev->drv->probe)\r\nerr = phydev->drv->probe(phydev);\r\nmutex_unlock(&phydev->lock);\r\nreturn err;\r\n}\r\nstatic int phy_remove(struct device *dev)\r\n{\r\nstruct phy_device *phydev;\r\nphydev = to_phy_device(dev);\r\nmutex_lock(&phydev->lock);\r\nphydev->state = PHY_DOWN;\r\nmutex_unlock(&phydev->lock);\r\nif (phydev->drv->remove)\r\nphydev->drv->remove(phydev);\r\nphydev->drv = NULL;\r\nreturn 0;\r\n}\r\nint phy_driver_register(struct phy_driver *new_driver)\r\n{\r\nint retval;\r\nnew_driver->driver.name = new_driver->name;\r\nnew_driver->driver.bus = &mdio_bus_type;\r\nnew_driver->driver.probe = phy_probe;\r\nnew_driver->driver.remove = phy_remove;\r\nretval = driver_register(&new_driver->driver);\r\nif (retval) {\r\npr_err("%s: Error %d in registering driver\n",\r\nnew_driver->name, retval);\r\nreturn retval;\r\n}\r\npr_debug("%s: Registered new driver\n", new_driver->name);\r\nreturn 0;\r\n}\r\nint phy_drivers_register(struct phy_driver *new_driver, int n)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; i < n; i++) {\r\nret = phy_driver_register(new_driver + i);\r\nif (ret) {\r\nwhile (i-- > 0)\r\nphy_driver_unregister(new_driver + i);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid phy_driver_unregister(struct phy_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}\r\nvoid phy_drivers_unregister(struct phy_driver *drv, int n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; i++) {\r\nphy_driver_unregister(drv + i);\r\n}\r\n}\r\nstatic int __init phy_init(void)\r\n{\r\nint rc;\r\nrc = mdio_bus_init();\r\nif (rc)\r\nreturn rc;\r\nrc = phy_driver_register(&genphy_driver);\r\nif (rc)\r\nmdio_bus_exit();\r\nreturn rc;\r\n}\r\nstatic void __exit phy_exit(void)\r\n{\r\nphy_driver_unregister(&genphy_driver);\r\nmdio_bus_exit();\r\n}
