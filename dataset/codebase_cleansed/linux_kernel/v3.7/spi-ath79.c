static inline u32 ath79_spi_rr(struct ath79_spi *sp, unsigned reg)\r\n{\r\nreturn ioread32(sp->base + reg);\r\n}\r\nstatic inline void ath79_spi_wr(struct ath79_spi *sp, unsigned reg, u32 val)\r\n{\r\niowrite32(val, sp->base + reg);\r\n}\r\nstatic inline struct ath79_spi *ath79_spidev_to_sp(struct spi_device *spi)\r\n{\r\nreturn spi_master_get_devdata(spi->master);\r\n}\r\nstatic void ath79_spi_chipselect(struct spi_device *spi, int is_active)\r\n{\r\nstruct ath79_spi *sp = ath79_spidev_to_sp(spi);\r\nint cs_high = (spi->mode & SPI_CS_HIGH) ? is_active : !is_active;\r\nif (is_active) {\r\nif (spi->mode & SPI_CPOL)\r\nsp->ioc_base |= AR71XX_SPI_IOC_CLK;\r\nelse\r\nsp->ioc_base &= ~AR71XX_SPI_IOC_CLK;\r\nath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);\r\n}\r\nif (spi->chip_select) {\r\nstruct ath79_spi_controller_data *cdata = spi->controller_data;\r\ngpio_set_value(cdata->gpio, cs_high);\r\n} else {\r\nif (cs_high)\r\nsp->ioc_base |= AR71XX_SPI_IOC_CS0;\r\nelse\r\nsp->ioc_base &= ~AR71XX_SPI_IOC_CS0;\r\nath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);\r\n}\r\n}\r\nstatic int ath79_spi_setup_cs(struct spi_device *spi)\r\n{\r\nstruct ath79_spi *sp = ath79_spidev_to_sp(spi);\r\nstruct ath79_spi_controller_data *cdata;\r\ncdata = spi->controller_data;\r\nif (spi->chip_select && !cdata)\r\nreturn -EINVAL;\r\nath79_spi_wr(sp, AR71XX_SPI_REG_FS, AR71XX_SPI_FS_GPIO);\r\nsp->reg_ctrl = ath79_spi_rr(sp, AR71XX_SPI_REG_CTRL);\r\nsp->ioc_base = ath79_spi_rr(sp, AR71XX_SPI_REG_IOC);\r\nath79_spi_wr(sp, AR71XX_SPI_REG_CTRL, 0x43);\r\nif (spi->chip_select) {\r\nint status = 0;\r\nstatus = gpio_request(cdata->gpio, dev_name(&spi->dev));\r\nif (status)\r\nreturn status;\r\nstatus = gpio_direction_output(cdata->gpio,\r\nspi->mode & SPI_CS_HIGH);\r\nif (status) {\r\ngpio_free(cdata->gpio);\r\nreturn status;\r\n}\r\n} else {\r\nif (spi->mode & SPI_CS_HIGH)\r\nsp->ioc_base |= AR71XX_SPI_IOC_CS0;\r\nelse\r\nsp->ioc_base &= ~AR71XX_SPI_IOC_CS0;\r\nath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ath79_spi_cleanup_cs(struct spi_device *spi)\r\n{\r\nstruct ath79_spi *sp = ath79_spidev_to_sp(spi);\r\nif (spi->chip_select) {\r\nstruct ath79_spi_controller_data *cdata = spi->controller_data;\r\ngpio_free(cdata->gpio);\r\n}\r\nath79_spi_wr(sp, AR71XX_SPI_REG_CTRL, sp->reg_ctrl);\r\nath79_spi_wr(sp, AR71XX_SPI_REG_FS, 0);\r\n}\r\nstatic int ath79_spi_setup(struct spi_device *spi)\r\n{\r\nint status = 0;\r\nif (spi->bits_per_word > 32)\r\nreturn -EINVAL;\r\nif (!spi->controller_state) {\r\nstatus = ath79_spi_setup_cs(spi);\r\nif (status)\r\nreturn status;\r\n}\r\nstatus = spi_bitbang_setup(spi);\r\nif (status && !spi->controller_state)\r\nath79_spi_cleanup_cs(spi);\r\nreturn status;\r\n}\r\nstatic void ath79_spi_cleanup(struct spi_device *spi)\r\n{\r\nath79_spi_cleanup_cs(spi);\r\nspi_bitbang_cleanup(spi);\r\n}\r\nstatic u32 ath79_spi_txrx_mode0(struct spi_device *spi, unsigned nsecs,\r\nu32 word, u8 bits)\r\n{\r\nstruct ath79_spi *sp = ath79_spidev_to_sp(spi);\r\nu32 ioc = sp->ioc_base;\r\nfor (word <<= (32 - bits); likely(bits); bits--) {\r\nu32 out;\r\nif (word & (1 << 31))\r\nout = ioc | AR71XX_SPI_IOC_DO;\r\nelse\r\nout = ioc & ~AR71XX_SPI_IOC_DO;\r\nath79_spi_wr(sp, AR71XX_SPI_REG_IOC, out);\r\nath79_spi_wr(sp, AR71XX_SPI_REG_IOC, out | AR71XX_SPI_IOC_CLK);\r\nword <<= 1;\r\n}\r\nreturn ath79_spi_rr(sp, AR71XX_SPI_REG_RDS);\r\n}\r\nstatic __devinit int ath79_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct ath79_spi *sp;\r\nstruct ath79_spi_platform_data *pdata;\r\nstruct resource *r;\r\nint ret;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*sp));\r\nif (master == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate spi master\n");\r\nreturn -ENOMEM;\r\n}\r\nsp = spi_master_get_devdata(master);\r\nplatform_set_drvdata(pdev, sp);\r\npdata = pdev->dev.platform_data;\r\nmaster->setup = ath79_spi_setup;\r\nmaster->cleanup = ath79_spi_cleanup;\r\nif (pdata) {\r\nmaster->bus_num = pdata->bus_num;\r\nmaster->num_chipselect = pdata->num_chipselect;\r\n}\r\nsp->bitbang.master = spi_master_get(master);\r\nsp->bitbang.chipselect = ath79_spi_chipselect;\r\nsp->bitbang.txrx_word[SPI_MODE_0] = ath79_spi_txrx_mode0;\r\nsp->bitbang.setup_transfer = spi_bitbang_setup_transfer;\r\nsp->bitbang.flags = SPI_CS_HIGH;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\nret = -ENOENT;\r\ngoto err_put_master;\r\n}\r\nsp->base = ioremap(r->start, resource_size(r));\r\nif (!sp->base) {\r\nret = -ENXIO;\r\ngoto err_put_master;\r\n}\r\nret = spi_bitbang_start(&sp->bitbang);\r\nif (ret)\r\ngoto err_unmap;\r\nreturn 0;\r\nerr_unmap:\r\niounmap(sp->base);\r\nerr_put_master:\r\nplatform_set_drvdata(pdev, NULL);\r\nspi_master_put(sp->bitbang.master);\r\nreturn ret;\r\n}\r\nstatic __devexit int ath79_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct ath79_spi *sp = platform_get_drvdata(pdev);\r\nspi_bitbang_stop(&sp->bitbang);\r\niounmap(sp->base);\r\nplatform_set_drvdata(pdev, NULL);\r\nspi_master_put(sp->bitbang.master);\r\nreturn 0;\r\n}
