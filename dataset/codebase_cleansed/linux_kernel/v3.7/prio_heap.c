int heap_init(struct ptr_heap *heap, size_t size, gfp_t gfp_mask,\r\nint (*gt)(void *, void *))\r\n{\r\nheap->ptrs = kmalloc(size, gfp_mask);\r\nif (!heap->ptrs)\r\nreturn -ENOMEM;\r\nheap->size = 0;\r\nheap->max = size / sizeof(void *);\r\nheap->gt = gt;\r\nreturn 0;\r\n}\r\nvoid heap_free(struct ptr_heap *heap)\r\n{\r\nkfree(heap->ptrs);\r\n}\r\nvoid *heap_insert(struct ptr_heap *heap, void *p)\r\n{\r\nvoid *res;\r\nvoid **ptrs = heap->ptrs;\r\nint pos;\r\nif (heap->size < heap->max) {\r\npos = heap->size++;\r\nwhile (pos > 0 && heap->gt(p, ptrs[(pos-1)/2])) {\r\nptrs[pos] = ptrs[(pos-1)/2];\r\npos = (pos-1)/2;\r\n}\r\nptrs[pos] = p;\r\nreturn NULL;\r\n}\r\nif (heap->gt(p, ptrs[0]))\r\nreturn p;\r\nres = ptrs[0];\r\nptrs[0] = p;\r\npos = 0;\r\nwhile (1) {\r\nint left = 2 * pos + 1;\r\nint right = 2 * pos + 2;\r\nint largest = pos;\r\nif (left < heap->size && heap->gt(ptrs[left], p))\r\nlargest = left;\r\nif (right < heap->size && heap->gt(ptrs[right], ptrs[largest]))\r\nlargest = right;\r\nif (largest == pos)\r\nbreak;\r\nptrs[pos] = ptrs[largest];\r\nptrs[largest] = p;\r\npos = largest;\r\n}\r\nreturn res;\r\n}
