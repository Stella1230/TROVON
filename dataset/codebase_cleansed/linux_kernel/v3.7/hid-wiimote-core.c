static ssize_t wiimote_hid_send(struct hid_device *hdev, __u8 *buffer,\r\nsize_t count)\r\n{\r\n__u8 *buf;\r\nssize_t ret;\r\nif (!hdev->hid_output_raw_report)\r\nreturn -ENODEV;\r\nbuf = kmemdup(buffer, count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hdev->hid_output_raw_report(hdev, buf, count, HID_OUTPUT_REPORT);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void wiimote_worker(struct work_struct *work)\r\n{\r\nstruct wiimote_data *wdata = container_of(work, struct wiimote_data,\r\nworker);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->qlock, flags);\r\nwhile (wdata->head != wdata->tail) {\r\nspin_unlock_irqrestore(&wdata->qlock, flags);\r\nwiimote_hid_send(wdata->hdev, wdata->outq[wdata->tail].data,\r\nwdata->outq[wdata->tail].size);\r\nspin_lock_irqsave(&wdata->qlock, flags);\r\nwdata->tail = (wdata->tail + 1) % WIIMOTE_BUFSIZE;\r\n}\r\nspin_unlock_irqrestore(&wdata->qlock, flags);\r\n}\r\nstatic void wiimote_queue(struct wiimote_data *wdata, const __u8 *buffer,\r\nsize_t count)\r\n{\r\nunsigned long flags;\r\n__u8 newhead;\r\nif (count > HID_MAX_BUFFER_SIZE) {\r\nhid_warn(wdata->hdev, "Sending too large output report\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&wdata->qlock, flags);\r\nmemcpy(wdata->outq[wdata->head].data, buffer, count);\r\nwdata->outq[wdata->head].size = count;\r\nnewhead = (wdata->head + 1) % WIIMOTE_BUFSIZE;\r\nif (wdata->head == wdata->tail) {\r\nwdata->head = newhead;\r\nschedule_work(&wdata->worker);\r\n} else if (newhead != wdata->tail) {\r\nwdata->head = newhead;\r\n} else {\r\nhid_warn(wdata->hdev, "Output queue is full");\r\n}\r\nspin_unlock_irqrestore(&wdata->qlock, flags);\r\n}\r\nstatic inline void wiiproto_keep_rumble(struct wiimote_data *wdata, __u8 *cmd1)\r\n{\r\nif (wdata->state.flags & WIIPROTO_FLAG_RUMBLE)\r\n*cmd1 |= 0x01;\r\n}\r\nstatic void wiiproto_req_rumble(struct wiimote_data *wdata, __u8 rumble)\r\n{\r\n__u8 cmd[2];\r\nrumble = !!rumble;\r\nif (rumble == !!(wdata->state.flags & WIIPROTO_FLAG_RUMBLE))\r\nreturn;\r\nif (rumble)\r\nwdata->state.flags |= WIIPROTO_FLAG_RUMBLE;\r\nelse\r\nwdata->state.flags &= ~WIIPROTO_FLAG_RUMBLE;\r\ncmd[0] = WIIPROTO_REQ_RUMBLE;\r\ncmd[1] = 0;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nstatic void wiiproto_req_leds(struct wiimote_data *wdata, int leds)\r\n{\r\n__u8 cmd[2];\r\nleds &= WIIPROTO_FLAGS_LEDS;\r\nif ((wdata->state.flags & WIIPROTO_FLAGS_LEDS) == leds)\r\nreturn;\r\nwdata->state.flags = (wdata->state.flags & ~WIIPROTO_FLAGS_LEDS) | leds;\r\ncmd[0] = WIIPROTO_REQ_LED;\r\ncmd[1] = 0;\r\nif (leds & WIIPROTO_FLAG_LED1)\r\ncmd[1] |= 0x10;\r\nif (leds & WIIPROTO_FLAG_LED2)\r\ncmd[1] |= 0x20;\r\nif (leds & WIIPROTO_FLAG_LED3)\r\ncmd[1] |= 0x40;\r\nif (leds & WIIPROTO_FLAG_LED4)\r\ncmd[1] |= 0x80;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nstatic __u8 select_drm(struct wiimote_data *wdata)\r\n{\r\n__u8 ir = wdata->state.flags & WIIPROTO_FLAGS_IR;\r\nbool ext = wiiext_active(wdata);\r\nif (ir == WIIPROTO_FLAG_IR_BASIC) {\r\nif (wdata->state.flags & WIIPROTO_FLAG_ACCEL)\r\nreturn WIIPROTO_REQ_DRM_KAIE;\r\nelse\r\nreturn WIIPROTO_REQ_DRM_KIE;\r\n} else if (ir == WIIPROTO_FLAG_IR_EXT) {\r\nreturn WIIPROTO_REQ_DRM_KAI;\r\n} else if (ir == WIIPROTO_FLAG_IR_FULL) {\r\nreturn WIIPROTO_REQ_DRM_SKAI1;\r\n} else {\r\nif (wdata->state.flags & WIIPROTO_FLAG_ACCEL) {\r\nif (ext)\r\nreturn WIIPROTO_REQ_DRM_KAE;\r\nelse\r\nreturn WIIPROTO_REQ_DRM_KA;\r\n} else {\r\nif (ext)\r\nreturn WIIPROTO_REQ_DRM_KE;\r\nelse\r\nreturn WIIPROTO_REQ_DRM_K;\r\n}\r\n}\r\n}\r\nvoid wiiproto_req_drm(struct wiimote_data *wdata, __u8 drm)\r\n{\r\n__u8 cmd[3];\r\nif (drm == WIIPROTO_REQ_NULL)\r\ndrm = select_drm(wdata);\r\ncmd[0] = WIIPROTO_REQ_DRM;\r\ncmd[1] = 0;\r\ncmd[2] = drm;\r\nwdata->state.drm = drm;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nstatic void wiiproto_req_status(struct wiimote_data *wdata)\r\n{\r\n__u8 cmd[2];\r\ncmd[0] = WIIPROTO_REQ_SREQ;\r\ncmd[1] = 0;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nstatic void wiiproto_req_accel(struct wiimote_data *wdata, __u8 accel)\r\n{\r\naccel = !!accel;\r\nif (accel == !!(wdata->state.flags & WIIPROTO_FLAG_ACCEL))\r\nreturn;\r\nif (accel)\r\nwdata->state.flags |= WIIPROTO_FLAG_ACCEL;\r\nelse\r\nwdata->state.flags &= ~WIIPROTO_FLAG_ACCEL;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\n}\r\nstatic void wiiproto_req_ir1(struct wiimote_data *wdata, __u8 flags)\r\n{\r\n__u8 cmd[2];\r\ncmd[0] = WIIPROTO_REQ_IR1;\r\ncmd[1] = flags;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nstatic void wiiproto_req_ir2(struct wiimote_data *wdata, __u8 flags)\r\n{\r\n__u8 cmd[2];\r\ncmd[0] = WIIPROTO_REQ_IR2;\r\ncmd[1] = flags;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nstatic void wiiproto_req_wmem(struct wiimote_data *wdata, bool eeprom,\r\n__u32 offset, const __u8 *buf, __u8 size)\r\n{\r\n__u8 cmd[22];\r\nif (size > 16 || size == 0) {\r\nhid_warn(wdata->hdev, "Invalid length %d wmem request\n", size);\r\nreturn;\r\n}\r\nmemset(cmd, 0, sizeof(cmd));\r\ncmd[0] = WIIPROTO_REQ_WMEM;\r\ncmd[2] = (offset >> 16) & 0xff;\r\ncmd[3] = (offset >> 8) & 0xff;\r\ncmd[4] = offset & 0xff;\r\ncmd[5] = size;\r\nmemcpy(&cmd[6], buf, size);\r\nif (!eeprom)\r\ncmd[1] |= 0x04;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nvoid wiiproto_req_rmem(struct wiimote_data *wdata, bool eeprom, __u32 offset,\r\n__u16 size)\r\n{\r\n__u8 cmd[7];\r\nif (size == 0) {\r\nhid_warn(wdata->hdev, "Invalid length %d rmem request\n", size);\r\nreturn;\r\n}\r\ncmd[0] = WIIPROTO_REQ_RMEM;\r\ncmd[1] = 0;\r\ncmd[2] = (offset >> 16) & 0xff;\r\ncmd[3] = (offset >> 8) & 0xff;\r\ncmd[4] = offset & 0xff;\r\ncmd[5] = (size >> 8) & 0xff;\r\ncmd[6] = size & 0xff;\r\nif (!eeprom)\r\ncmd[1] |= 0x04;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nint wiimote_cmd_write(struct wiimote_data *wdata, __u32 offset,\r\nconst __u8 *wmem, __u8 size)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiimote_cmd_set(wdata, WIIPROTO_REQ_WMEM, 0);\r\nwiiproto_req_wreg(wdata, offset, wmem, size);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nret = wiimote_cmd_wait(wdata);\r\nif (!ret && wdata->state.cmd_err)\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nssize_t wiimote_cmd_read(struct wiimote_data *wdata, __u32 offset, __u8 *rmem,\r\n__u8 size)\r\n{\r\nunsigned long flags;\r\nssize_t ret;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.cmd_read_size = size;\r\nwdata->state.cmd_read_buf = rmem;\r\nwiimote_cmd_set(wdata, WIIPROTO_REQ_RMEM, offset & 0xffff);\r\nwiiproto_req_rreg(wdata, offset, size);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nret = wiimote_cmd_wait(wdata);\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.cmd_read_buf = NULL;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nif (!ret) {\r\nif (wdata->state.cmd_read_size == 0)\r\nret = -EIO;\r\nelse\r\nret = wdata->state.cmd_read_size;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wiimote_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct wiimote_data *wdata = container_of(psy,\r\nstruct wiimote_data, battery);\r\nint ret = 0, state;\r\nunsigned long flags;\r\nif (psp == POWER_SUPPLY_PROP_SCOPE) {\r\nval->intval = POWER_SUPPLY_SCOPE_DEVICE;\r\nreturn 0;\r\n}\r\nret = wiimote_cmd_acquire(wdata);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiimote_cmd_set(wdata, WIIPROTO_REQ_SREQ, 0);\r\nwiiproto_req_status(wdata);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nret = wiimote_cmd_wait(wdata);\r\nstate = wdata->state.cmd_battery;\r\nwiimote_cmd_release(wdata);\r\nif (ret)\r\nreturn ret;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nval->intval = state * 100 / 255;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wiimote_init_ir(struct wiimote_data *wdata, __u16 mode)\r\n{\r\nint ret;\r\nunsigned long flags;\r\n__u8 format = 0;\r\nstatic const __u8 data_enable[] = { 0x01 };\r\nstatic const __u8 data_sens1[] = { 0x02, 0x00, 0x00, 0x71, 0x01,\r\n0x00, 0xaa, 0x00, 0x64 };\r\nstatic const __u8 data_sens2[] = { 0x63, 0x03 };\r\nstatic const __u8 data_fin[] = { 0x08 };\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nif (mode == (wdata->state.flags & WIIPROTO_FLAGS_IR)) {\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nif (mode == 0) {\r\nwdata->state.flags &= ~WIIPROTO_FLAGS_IR;\r\nwiiproto_req_ir1(wdata, 0);\r\nwiiproto_req_ir2(wdata, 0);\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nret = wiimote_cmd_acquire(wdata);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiimote_cmd_set(wdata, WIIPROTO_REQ_IR1, 0);\r\nwiiproto_req_ir1(wdata, 0x06);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nret = wiimote_cmd_wait(wdata);\r\nif (ret)\r\ngoto unlock;\r\nif (wdata->state.cmd_err) {\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiimote_cmd_set(wdata, WIIPROTO_REQ_IR2, 0);\r\nwiiproto_req_ir2(wdata, 0x06);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nret = wiimote_cmd_wait(wdata);\r\nif (ret)\r\ngoto unlock;\r\nif (wdata->state.cmd_err) {\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\nret = wiimote_cmd_write(wdata, 0xb00030, data_enable,\r\nsizeof(data_enable));\r\nif (ret)\r\ngoto unlock;\r\nret = wiimote_cmd_write(wdata, 0xb00000, data_sens1,\r\nsizeof(data_sens1));\r\nif (ret)\r\ngoto unlock;\r\nret = wiimote_cmd_write(wdata, 0xb0001a, data_sens2,\r\nsizeof(data_sens2));\r\nif (ret)\r\ngoto unlock;\r\nswitch (mode) {\r\ncase WIIPROTO_FLAG_IR_FULL:\r\nformat = 5;\r\nbreak;\r\ncase WIIPROTO_FLAG_IR_EXT:\r\nformat = 3;\r\nbreak;\r\ncase WIIPROTO_FLAG_IR_BASIC:\r\nformat = 1;\r\nbreak;\r\n}\r\nret = wiimote_cmd_write(wdata, 0xb00033, &format, sizeof(format));\r\nif (ret)\r\ngoto unlock;\r\nret = wiimote_cmd_write(wdata, 0xb00030, data_fin, sizeof(data_fin));\r\nif (ret)\r\ngoto unlock;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags &= ~WIIPROTO_FLAGS_IR;\r\nwdata->state.flags |= mode & WIIPROTO_FLAGS_IR;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nunlock:\r\nwiimote_cmd_release(wdata);\r\nreturn ret;\r\n}\r\nstatic enum led_brightness wiimote_leds_get(struct led_classdev *led_dev)\r\n{\r\nstruct wiimote_data *wdata;\r\nstruct device *dev = led_dev->dev->parent;\r\nint i;\r\nunsigned long flags;\r\nbool value = false;\r\nwdata = hid_get_drvdata(container_of(dev, struct hid_device, dev));\r\nfor (i = 0; i < 4; ++i) {\r\nif (wdata->leds[i] == led_dev) {\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nvalue = wdata->state.flags & WIIPROTO_FLAG_LED(i + 1);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nbreak;\r\n}\r\n}\r\nreturn value ? LED_FULL : LED_OFF;\r\n}\r\nstatic void wiimote_leds_set(struct led_classdev *led_dev,\r\nenum led_brightness value)\r\n{\r\nstruct wiimote_data *wdata;\r\nstruct device *dev = led_dev->dev->parent;\r\nint i;\r\nunsigned long flags;\r\n__u8 state, flag;\r\nwdata = hid_get_drvdata(container_of(dev, struct hid_device, dev));\r\nfor (i = 0; i < 4; ++i) {\r\nif (wdata->leds[i] == led_dev) {\r\nflag = WIIPROTO_FLAG_LED(i + 1);\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nstate = wdata->state.flags;\r\nif (value == LED_OFF)\r\nwiiproto_req_leds(wdata, state & ~flag);\r\nelse\r\nwiiproto_req_leds(wdata, state | flag);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int wiimote_ff_play(struct input_dev *dev, void *data,\r\nstruct ff_effect *eff)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\n__u8 value;\r\nunsigned long flags;\r\nif (eff->u.rumble.strong_magnitude || eff->u.rumble.weak_magnitude)\r\nvalue = 1;\r\nelse\r\nvalue = 0;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiiproto_req_rumble(wdata, value);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nstatic int wiimote_input_open(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nreturn hid_hw_open(wdata->hdev);\r\n}\r\nstatic void wiimote_input_close(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nhid_hw_close(wdata->hdev);\r\n}\r\nstatic int wiimote_accel_open(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nint ret;\r\nunsigned long flags;\r\nret = hid_hw_open(wdata->hdev);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiiproto_req_accel(wdata, true);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void wiimote_accel_close(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiiproto_req_accel(wdata, false);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nhid_hw_close(wdata->hdev);\r\n}\r\nstatic int wiimote_ir_open(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nint ret;\r\nret = hid_hw_open(wdata->hdev);\r\nif (ret)\r\nreturn ret;\r\nret = wiimote_init_ir(wdata, WIIPROTO_FLAG_IR_BASIC);\r\nif (ret) {\r\nhid_hw_close(wdata->hdev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void wiimote_ir_close(struct input_dev *dev)\r\n{\r\nstruct wiimote_data *wdata = input_get_drvdata(dev);\r\nwiimote_init_ir(wdata, 0);\r\nhid_hw_close(wdata->hdev);\r\n}\r\nstatic void handler_keys(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\ninput_report_key(wdata->input, wiiproto_keymap[WIIPROTO_KEY_LEFT],\r\n!!(payload[0] & 0x01));\r\ninput_report_key(wdata->input, wiiproto_keymap[WIIPROTO_KEY_RIGHT],\r\n!!(payload[0] & 0x02));\r\ninput_report_key(wdata->input, wiiproto_keymap[WIIPROTO_KEY_DOWN],\r\n!!(payload[0] & 0x04));\r\ninput_report_key(wdata->input, wiiproto_keymap[WIIPROTO_KEY_UP],\r\n!!(payload[0] & 0x08));\r\ninput_report_key(wdata->input, wiiproto_keymap[WIIPROTO_KEY_PLUS],\r\n!!(payload[0] & 0x10));\r\ninput_report_key(wdata->input, wiiproto_keymap[WIIPROTO_KEY_TWO],\r\n!!(payload[1] & 0x01));\r\ninput_report_key(wdata->input, wiiproto_keymap[WIIPROTO_KEY_ONE],\r\n!!(payload[1] & 0x02));\r\ninput_report_key(wdata->input, wiiproto_keymap[WIIPROTO_KEY_B],\r\n!!(payload[1] & 0x04));\r\ninput_report_key(wdata->input, wiiproto_keymap[WIIPROTO_KEY_A],\r\n!!(payload[1] & 0x08));\r\ninput_report_key(wdata->input, wiiproto_keymap[WIIPROTO_KEY_MINUS],\r\n!!(payload[1] & 0x10));\r\ninput_report_key(wdata->input, wiiproto_keymap[WIIPROTO_KEY_HOME],\r\n!!(payload[1] & 0x80));\r\ninput_sync(wdata->input);\r\n}\r\nstatic void handler_accel(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\n__u16 x, y, z;\r\nif (!(wdata->state.flags & WIIPROTO_FLAG_ACCEL))\r\nreturn;\r\nx = payload[2] << 2;\r\ny = payload[3] << 2;\r\nz = payload[4] << 2;\r\nx |= (payload[0] >> 5) & 0x3;\r\ny |= (payload[1] >> 4) & 0x2;\r\nz |= (payload[1] >> 5) & 0x2;\r\ninput_report_abs(wdata->accel, ABS_RX, x - 0x200);\r\ninput_report_abs(wdata->accel, ABS_RY, y - 0x200);\r\ninput_report_abs(wdata->accel, ABS_RZ, z - 0x200);\r\ninput_sync(wdata->accel);\r\n}\r\nstatic void __ir_to_input(struct wiimote_data *wdata, const __u8 *ir,\r\nbool packed, __u8 xid, __u8 yid)\r\n{\r\n__u16 x, y;\r\nif (!(wdata->state.flags & WIIPROTO_FLAGS_IR))\r\nreturn;\r\nif (packed) {\r\nx = ir[1] | ((ir[0] & 0x03) << 8);\r\ny = ir[2] | ((ir[0] & 0x0c) << 6);\r\n} else {\r\nx = ir[0] | ((ir[2] & 0x30) << 4);\r\ny = ir[1] | ((ir[2] & 0xc0) << 2);\r\n}\r\ninput_report_abs(wdata->ir, xid, x);\r\ninput_report_abs(wdata->ir, yid, y);\r\n}\r\nstatic void handler_status(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\nwiiext_event(wdata, payload[2] & 0x02);\r\nif (wiimote_cmd_pending(wdata, WIIPROTO_REQ_SREQ, 0)) {\r\nwdata->state.cmd_battery = payload[5];\r\nwiimote_cmd_complete(wdata);\r\n}\r\n}\r\nstatic void handler_data(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\n__u16 offset = payload[3] << 8 | payload[4];\r\n__u8 size = (payload[2] >> 4) + 1;\r\n__u8 err = payload[2] & 0x0f;\r\nhandler_keys(wdata, payload);\r\nif (wiimote_cmd_pending(wdata, WIIPROTO_REQ_RMEM, offset)) {\r\nif (err)\r\nsize = 0;\r\nelse if (size > wdata->state.cmd_read_size)\r\nsize = wdata->state.cmd_read_size;\r\nwdata->state.cmd_read_size = size;\r\nif (wdata->state.cmd_read_buf)\r\nmemcpy(wdata->state.cmd_read_buf, &payload[5], size);\r\nwiimote_cmd_complete(wdata);\r\n}\r\n}\r\nstatic void handler_return(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\n__u8 err = payload[3];\r\n__u8 cmd = payload[2];\r\nhandler_keys(wdata, payload);\r\nif (wiimote_cmd_pending(wdata, cmd, 0)) {\r\nwdata->state.cmd_err = err;\r\nwiimote_cmd_complete(wdata);\r\n} else if (err) {\r\nhid_warn(wdata->hdev, "Remote error %hhu on req %hhu\n", err,\r\ncmd);\r\n}\r\n}\r\nstatic void handler_drm_KA(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nhandler_accel(wdata, payload);\r\n}\r\nstatic void handler_drm_KE(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nwiiext_handle(wdata, &payload[2]);\r\n}\r\nstatic void handler_drm_KAI(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nhandler_accel(wdata, payload);\r\nir_to_input0(wdata, &payload[5], false);\r\nir_to_input1(wdata, &payload[8], false);\r\nir_to_input2(wdata, &payload[11], false);\r\nir_to_input3(wdata, &payload[14], false);\r\ninput_sync(wdata->ir);\r\n}\r\nstatic void handler_drm_KEE(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nwiiext_handle(wdata, &payload[2]);\r\n}\r\nstatic void handler_drm_KIE(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nir_to_input0(wdata, &payload[2], false);\r\nir_to_input1(wdata, &payload[4], true);\r\nir_to_input2(wdata, &payload[7], false);\r\nir_to_input3(wdata, &payload[9], true);\r\ninput_sync(wdata->ir);\r\nwiiext_handle(wdata, &payload[12]);\r\n}\r\nstatic void handler_drm_KAE(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nhandler_accel(wdata, payload);\r\nwiiext_handle(wdata, &payload[5]);\r\n}\r\nstatic void handler_drm_KAIE(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nhandler_accel(wdata, payload);\r\nir_to_input0(wdata, &payload[5], false);\r\nir_to_input1(wdata, &payload[7], true);\r\nir_to_input2(wdata, &payload[10], false);\r\nir_to_input3(wdata, &payload[12], true);\r\ninput_sync(wdata->ir);\r\nwiiext_handle(wdata, &payload[15]);\r\n}\r\nstatic void handler_drm_E(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nwiiext_handle(wdata, payload);\r\n}\r\nstatic void handler_drm_SKAI1(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nwdata->state.accel_split[0] = payload[2];\r\nwdata->state.accel_split[1] = (payload[0] >> 1) & (0x10 | 0x20);\r\nwdata->state.accel_split[1] |= (payload[1] << 1) & (0x40 | 0x80);\r\nir_to_input0(wdata, &payload[3], false);\r\nir_to_input1(wdata, &payload[12], false);\r\ninput_sync(wdata->ir);\r\n}\r\nstatic void handler_drm_SKAI2(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\n__u8 buf[5];\r\nhandler_keys(wdata, payload);\r\nwdata->state.accel_split[1] |= (payload[0] >> 5) & (0x01 | 0x02);\r\nwdata->state.accel_split[1] |= (payload[1] >> 3) & (0x04 | 0x08);\r\nbuf[0] = 0;\r\nbuf[1] = 0;\r\nbuf[2] = wdata->state.accel_split[0];\r\nbuf[3] = payload[2];\r\nbuf[4] = wdata->state.accel_split[1];\r\nhandler_accel(wdata, buf);\r\nir_to_input2(wdata, &payload[3], false);\r\nir_to_input3(wdata, &payload[12], false);\r\ninput_sync(wdata->ir);\r\n}\r\nstatic int wiimote_hid_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *raw_data, int size)\r\n{\r\nstruct wiimote_data *wdata = hid_get_drvdata(hdev);\r\nstruct wiiproto_handler *h;\r\nint i;\r\nunsigned long flags;\r\nbool handled = false;\r\nif (size < 1)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nfor (i = 0; handlers[i].id; ++i) {\r\nh = &handlers[i];\r\nif (h->id == raw_data[0] && h->size < size) {\r\nh->func(wdata, &raw_data[1]);\r\nhandled = true;\r\n}\r\n}\r\nif (!handled)\r\nhid_warn(hdev, "Unhandled report %hhu size %d\n", raw_data[0],\r\nsize);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void wiimote_leds_destroy(struct wiimote_data *wdata)\r\n{\r\nint i;\r\nstruct led_classdev *led;\r\nfor (i = 0; i < 4; ++i) {\r\nif (wdata->leds[i]) {\r\nled = wdata->leds[i];\r\nwdata->leds[i] = NULL;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\n}\r\n}\r\nstatic int wiimote_leds_create(struct wiimote_data *wdata)\r\n{\r\nint i, ret;\r\nstruct device *dev = &wdata->hdev->dev;\r\nsize_t namesz = strlen(dev_name(dev)) + 9;\r\nstruct led_classdev *led;\r\nchar *name;\r\nfor (i = 0; i < 4; ++i) {\r\nled = kzalloc(sizeof(struct led_classdev) + namesz, GFP_KERNEL);\r\nif (!led) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nname = (void*)&led[1];\r\nsnprintf(name, namesz, "%s:blue:p%d", dev_name(dev), i);\r\nled->name = name;\r\nled->brightness = 0;\r\nled->max_brightness = 1;\r\nled->brightness_get = wiimote_leds_get;\r\nled->brightness_set = wiimote_leds_set;\r\nret = led_classdev_register(dev, led);\r\nif (ret) {\r\nkfree(led);\r\ngoto err;\r\n}\r\nwdata->leds[i] = led;\r\n}\r\nreturn 0;\r\nerr:\r\nwiimote_leds_destroy(wdata);\r\nreturn ret;\r\n}\r\nstatic struct wiimote_data *wiimote_create(struct hid_device *hdev)\r\n{\r\nstruct wiimote_data *wdata;\r\nint i;\r\nwdata = kzalloc(sizeof(*wdata), GFP_KERNEL);\r\nif (!wdata)\r\nreturn NULL;\r\nwdata->input = input_allocate_device();\r\nif (!wdata->input)\r\ngoto err;\r\nwdata->hdev = hdev;\r\nhid_set_drvdata(hdev, wdata);\r\ninput_set_drvdata(wdata->input, wdata);\r\nwdata->input->open = wiimote_input_open;\r\nwdata->input->close = wiimote_input_close;\r\nwdata->input->dev.parent = &wdata->hdev->dev;\r\nwdata->input->id.bustype = wdata->hdev->bus;\r\nwdata->input->id.vendor = wdata->hdev->vendor;\r\nwdata->input->id.product = wdata->hdev->product;\r\nwdata->input->id.version = wdata->hdev->version;\r\nwdata->input->name = WIIMOTE_NAME;\r\nset_bit(EV_KEY, wdata->input->evbit);\r\nfor (i = 0; i < WIIPROTO_KEY_COUNT; ++i)\r\nset_bit(wiiproto_keymap[i], wdata->input->keybit);\r\nset_bit(FF_RUMBLE, wdata->input->ffbit);\r\nif (input_ff_create_memless(wdata->input, NULL, wiimote_ff_play))\r\ngoto err_input;\r\nwdata->accel = input_allocate_device();\r\nif (!wdata->accel)\r\ngoto err_input;\r\ninput_set_drvdata(wdata->accel, wdata);\r\nwdata->accel->open = wiimote_accel_open;\r\nwdata->accel->close = wiimote_accel_close;\r\nwdata->accel->dev.parent = &wdata->hdev->dev;\r\nwdata->accel->id.bustype = wdata->hdev->bus;\r\nwdata->accel->id.vendor = wdata->hdev->vendor;\r\nwdata->accel->id.product = wdata->hdev->product;\r\nwdata->accel->id.version = wdata->hdev->version;\r\nwdata->accel->name = WIIMOTE_NAME " Accelerometer";\r\nset_bit(EV_ABS, wdata->accel->evbit);\r\nset_bit(ABS_RX, wdata->accel->absbit);\r\nset_bit(ABS_RY, wdata->accel->absbit);\r\nset_bit(ABS_RZ, wdata->accel->absbit);\r\ninput_set_abs_params(wdata->accel, ABS_RX, -500, 500, 2, 4);\r\ninput_set_abs_params(wdata->accel, ABS_RY, -500, 500, 2, 4);\r\ninput_set_abs_params(wdata->accel, ABS_RZ, -500, 500, 2, 4);\r\nwdata->ir = input_allocate_device();\r\nif (!wdata->ir)\r\ngoto err_ir;\r\ninput_set_drvdata(wdata->ir, wdata);\r\nwdata->ir->open = wiimote_ir_open;\r\nwdata->ir->close = wiimote_ir_close;\r\nwdata->ir->dev.parent = &wdata->hdev->dev;\r\nwdata->ir->id.bustype = wdata->hdev->bus;\r\nwdata->ir->id.vendor = wdata->hdev->vendor;\r\nwdata->ir->id.product = wdata->hdev->product;\r\nwdata->ir->id.version = wdata->hdev->version;\r\nwdata->ir->name = WIIMOTE_NAME " IR";\r\nset_bit(EV_ABS, wdata->ir->evbit);\r\nset_bit(ABS_HAT0X, wdata->ir->absbit);\r\nset_bit(ABS_HAT0Y, wdata->ir->absbit);\r\nset_bit(ABS_HAT1X, wdata->ir->absbit);\r\nset_bit(ABS_HAT1Y, wdata->ir->absbit);\r\nset_bit(ABS_HAT2X, wdata->ir->absbit);\r\nset_bit(ABS_HAT2Y, wdata->ir->absbit);\r\nset_bit(ABS_HAT3X, wdata->ir->absbit);\r\nset_bit(ABS_HAT3Y, wdata->ir->absbit);\r\ninput_set_abs_params(wdata->ir, ABS_HAT0X, 0, 1023, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT0Y, 0, 767, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT1X, 0, 1023, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT1Y, 0, 767, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT2X, 0, 1023, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT2Y, 0, 767, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT3X, 0, 1023, 2, 4);\r\ninput_set_abs_params(wdata->ir, ABS_HAT3Y, 0, 767, 2, 4);\r\nspin_lock_init(&wdata->qlock);\r\nINIT_WORK(&wdata->worker, wiimote_worker);\r\nspin_lock_init(&wdata->state.lock);\r\ninit_completion(&wdata->state.ready);\r\nmutex_init(&wdata->state.sync);\r\nwdata->state.drm = WIIPROTO_REQ_DRM_K;\r\nreturn wdata;\r\nerr_ir:\r\ninput_free_device(wdata->accel);\r\nerr_input:\r\ninput_free_device(wdata->input);\r\nerr:\r\nkfree(wdata);\r\nreturn NULL;\r\n}\r\nstatic void wiimote_destroy(struct wiimote_data *wdata)\r\n{\r\nwiidebug_deinit(wdata);\r\nwiiext_deinit(wdata);\r\nwiimote_leds_destroy(wdata);\r\npower_supply_unregister(&wdata->battery);\r\ninput_unregister_device(wdata->accel);\r\ninput_unregister_device(wdata->ir);\r\ninput_unregister_device(wdata->input);\r\ncancel_work_sync(&wdata->worker);\r\nhid_hw_stop(wdata->hdev);\r\nkfree(wdata);\r\n}\r\nstatic int wiimote_hid_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nstruct wiimote_data *wdata;\r\nint ret;\r\nhdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\r\nwdata = wiimote_create(hdev);\r\nif (!wdata) {\r\nhid_err(hdev, "Can't alloc device\n");\r\nreturn -ENOMEM;\r\n}\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "HID parse failed\n");\r\ngoto err;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\r\nif (ret) {\r\nhid_err(hdev, "HW start failed\n");\r\ngoto err;\r\n}\r\nret = input_register_device(wdata->accel);\r\nif (ret) {\r\nhid_err(hdev, "Cannot register input device\n");\r\ngoto err_stop;\r\n}\r\nret = input_register_device(wdata->ir);\r\nif (ret) {\r\nhid_err(hdev, "Cannot register input device\n");\r\ngoto err_ir;\r\n}\r\nret = input_register_device(wdata->input);\r\nif (ret) {\r\nhid_err(hdev, "Cannot register input device\n");\r\ngoto err_input;\r\n}\r\nwdata->battery.properties = wiimote_battery_props;\r\nwdata->battery.num_properties = ARRAY_SIZE(wiimote_battery_props);\r\nwdata->battery.get_property = wiimote_battery_get_property;\r\nwdata->battery.name = "wiimote_battery";\r\nwdata->battery.type = POWER_SUPPLY_TYPE_BATTERY;\r\nwdata->battery.use_for_apm = 0;\r\nret = power_supply_register(&wdata->hdev->dev, &wdata->battery);\r\nif (ret) {\r\nhid_err(hdev, "Cannot register battery device\n");\r\ngoto err_battery;\r\n}\r\npower_supply_powers(&wdata->battery, &hdev->dev);\r\nret = wiimote_leds_create(wdata);\r\nif (ret)\r\ngoto err_free;\r\nret = wiiext_init(wdata);\r\nif (ret)\r\ngoto err_free;\r\nret = wiidebug_init(wdata);\r\nif (ret)\r\ngoto err_free;\r\nhid_info(hdev, "New device registered\n");\r\nspin_lock_irq(&wdata->state.lock);\r\nwiiproto_req_leds(wdata, WIIPROTO_FLAG_LED1);\r\nspin_unlock_irq(&wdata->state.lock);\r\nreturn 0;\r\nerr_free:\r\nwiimote_destroy(wdata);\r\nreturn ret;\r\nerr_battery:\r\ninput_unregister_device(wdata->input);\r\nwdata->input = NULL;\r\nerr_input:\r\ninput_unregister_device(wdata->ir);\r\nwdata->ir = NULL;\r\nerr_ir:\r\ninput_unregister_device(wdata->accel);\r\nwdata->accel = NULL;\r\nerr_stop:\r\nhid_hw_stop(hdev);\r\nerr:\r\ninput_free_device(wdata->ir);\r\ninput_free_device(wdata->accel);\r\ninput_free_device(wdata->input);\r\nkfree(wdata);\r\nreturn ret;\r\n}\r\nstatic void wiimote_hid_remove(struct hid_device *hdev)\r\n{\r\nstruct wiimote_data *wdata = hid_get_drvdata(hdev);\r\nhid_info(hdev, "Device removed\n");\r\nwiimote_destroy(wdata);\r\n}\r\nstatic int __init wiimote_init(void)\r\n{\r\nint ret;\r\nret = hid_register_driver(&wiimote_hid_driver);\r\nif (ret)\r\npr_err("Can't register wiimote hid driver\n");\r\nreturn ret;\r\n}\r\nstatic void __exit wiimote_exit(void)\r\n{\r\nhid_unregister_driver(&wiimote_hid_driver);\r\n}
