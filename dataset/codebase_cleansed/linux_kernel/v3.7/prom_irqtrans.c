static unsigned long psycho_pcislot_imap_offset(unsigned long ino)\r\n{\r\nunsigned int bus = (ino & 0x10) >> 4;\r\nunsigned int slot = (ino & 0x0c) >> 2;\r\nif (bus == 0)\r\nreturn PSYCHO_IMAP_A_SLOT0 + (slot * 8);\r\nelse\r\nreturn PSYCHO_IMAP_B_SLOT0 + (slot * 8);\r\n}\r\nstatic unsigned int psycho_irq_build(struct device_node *dp,\r\nunsigned int ino,\r\nvoid *_data)\r\n{\r\nunsigned long controller_regs = (unsigned long) _data;\r\nunsigned long imap, iclr;\r\nunsigned long imap_off, iclr_off;\r\nint inofixup = 0;\r\nino &= 0x3f;\r\nif (ino < PSYCHO_ONBOARD_IRQ_BASE) {\r\nimap_off = psycho_pcislot_imap_offset(ino);\r\n} else {\r\nimap_off = psycho_onboard_imap_offset(ino);\r\n}\r\nimap = controller_regs + imap_off;\r\niclr_off = psycho_iclr_offset(ino);\r\niclr = controller_regs + iclr_off;\r\nif ((ino & 0x20) == 0)\r\ninofixup = ino & 0x03;\r\nreturn build_irq(inofixup, iclr, imap);\r\n}\r\nstatic void __init psycho_irq_trans_init(struct device_node *dp)\r\n{\r\nconst struct linux_prom64_registers *regs;\r\ndp->irq_trans = prom_early_alloc(sizeof(struct of_irq_controller));\r\ndp->irq_trans->irq_build = psycho_irq_build;\r\nregs = of_get_property(dp, "reg", NULL);\r\ndp->irq_trans->data = (void *) regs[2].phys_addr;\r\n}\r\nstatic void sabre_wsync_handler(unsigned int ino, void *_arg1, void *_arg2)\r\n{\r\nunsigned int phys_hi = (unsigned int) (unsigned long) _arg1;\r\nstruct sabre_irq_data *irq_data = _arg2;\r\nunsigned long controller_regs = irq_data->controller_regs;\r\nunsigned long sync_reg = controller_regs + SABRE_WRSYNC;\r\nunsigned long config_space = controller_regs + SABRE_CONFIGSPACE;\r\nunsigned int bus, devfn;\r\nu16 _unused;\r\nconfig_space = SABRE_CONFIG_BASE(config_space);\r\nbus = (phys_hi >> 16) & 0xff;\r\ndevfn = (phys_hi >> 8) & 0xff;\r\nconfig_space |= SABRE_CONFIG_ENCODE(bus, devfn, 0x00);\r\n__asm__ __volatile__("membar #Sync\n\t"\r\n"lduha [%1] %2, %0\n\t"\r\n"membar #Sync"\r\n: "=r" (_unused)\r\n: "r" ((u16 *) config_space),\r\n"i" (ASI_PHYS_BYPASS_EC_E_L)\r\n: "memory");\r\nsabre_read(sync_reg);\r\n}\r\nstatic unsigned long sabre_pcislot_imap_offset(unsigned long ino)\r\n{\r\nunsigned int bus = (ino & 0x10) >> 4;\r\nunsigned int slot = (ino & 0x0c) >> 2;\r\nif (bus == 0)\r\nreturn SABRE_IMAP_A_SLOT0 + (slot * 8);\r\nelse\r\nreturn SABRE_IMAP_B_SLOT0 + (slot * 8);\r\n}\r\nstatic int sabre_device_needs_wsync(struct device_node *dp)\r\n{\r\nstruct device_node *parent = dp->parent;\r\nconst char *parent_model, *parent_compat;\r\nwhile (parent) {\r\nif (!strcmp(parent->type, "pci"))\r\nbreak;\r\nparent = parent->parent;\r\n}\r\nif (!parent)\r\nreturn 0;\r\nparent_model = of_get_property(parent,\r\n"model", NULL);\r\nif (parent_model &&\r\n(!strcmp(parent_model, "SUNW,sabre") ||\r\n!strcmp(parent_model, "SUNW,simba")))\r\nreturn 0;\r\nparent_compat = of_get_property(parent,\r\n"compatible", NULL);\r\nif (parent_compat &&\r\n(!strcmp(parent_compat, "pci108e,a000") ||\r\n!strcmp(parent_compat, "pci108e,a001")))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic unsigned int sabre_irq_build(struct device_node *dp,\r\nunsigned int ino,\r\nvoid *_data)\r\n{\r\nstruct sabre_irq_data *irq_data = _data;\r\nunsigned long controller_regs = irq_data->controller_regs;\r\nconst struct linux_prom_pci_registers *regs;\r\nunsigned long imap, iclr;\r\nunsigned long imap_off, iclr_off;\r\nint inofixup = 0;\r\nint irq;\r\nino &= 0x3f;\r\nif (ino < SABRE_ONBOARD_IRQ_BASE) {\r\nimap_off = sabre_pcislot_imap_offset(ino);\r\n} else {\r\nimap_off = sabre_onboard_imap_offset(ino);\r\n}\r\nimap = controller_regs + imap_off;\r\niclr_off = sabre_iclr_offset(ino);\r\niclr = controller_regs + iclr_off;\r\nif ((ino & 0x20) == 0)\r\ninofixup = ino & 0x03;\r\nirq = build_irq(inofixup, iclr, imap);\r\nregs = of_get_property(dp, "reg", NULL);\r\nif (regs && sabre_device_needs_wsync(dp)) {\r\nirq_install_pre_handler(irq,\r\nsabre_wsync_handler,\r\n(void *) (long) regs->phys_hi,\r\n(void *) irq_data);\r\n}\r\nreturn irq;\r\n}\r\nstatic void __init sabre_irq_trans_init(struct device_node *dp)\r\n{\r\nconst struct linux_prom64_registers *regs;\r\nstruct sabre_irq_data *irq_data;\r\nconst u32 *busrange;\r\ndp->irq_trans = prom_early_alloc(sizeof(struct of_irq_controller));\r\ndp->irq_trans->irq_build = sabre_irq_build;\r\nirq_data = prom_early_alloc(sizeof(struct sabre_irq_data));\r\nregs = of_get_property(dp, "reg", NULL);\r\nirq_data->controller_regs = regs[0].phys_addr;\r\nbusrange = of_get_property(dp, "bus-range", NULL);\r\nirq_data->pci_first_busno = busrange[0];\r\ndp->irq_trans->data = irq_data;\r\n}\r\nstatic unsigned long schizo_imap_offset(unsigned long ino)\r\n{\r\nreturn SCHIZO_IMAP_BASE + (ino * 8UL);\r\n}\r\nstatic unsigned long schizo_iclr_offset(unsigned long ino)\r\n{\r\nreturn SCHIZO_ICLR_BASE + (ino * 8UL);\r\n}\r\nstatic unsigned long schizo_ino_to_iclr(unsigned long pbm_regs,\r\nunsigned int ino)\r\n{\r\nreturn pbm_regs + schizo_iclr_offset(ino);\r\n}\r\nstatic unsigned long schizo_ino_to_imap(unsigned long pbm_regs,\r\nunsigned int ino)\r\n{\r\nreturn pbm_regs + schizo_imap_offset(ino);\r\n}\r\nstatic void tomatillo_wsync_handler(unsigned int ino, void *_arg1, void *_arg2)\r\n{\r\nunsigned long sync_reg = (unsigned long) _arg2;\r\nu64 mask = 1UL << (ino & IMAP_INO);\r\nu64 val;\r\nint limit;\r\nschizo_write(sync_reg, mask);\r\nlimit = 100000;\r\nval = 0;\r\nwhile (--limit) {\r\nval = schizo_read(sync_reg);\r\nif (!(val & mask))\r\nbreak;\r\n}\r\nif (limit <= 0) {\r\nprintk("tomatillo_wsync_handler: DMA won't sync [%llx:%llx]\n",\r\nval, mask);\r\n}\r\nif (_arg1) {\r\nstatic unsigned char cacheline[64]\r\n__attribute__ ((aligned (64)));\r\n__asm__ __volatile__("rd %%fprs, %0\n\t"\r\n"or %0, %4, %1\n\t"\r\n"wr %1, 0x0, %%fprs\n\t"\r\n"stda %%f0, [%5] %6\n\t"\r\n"wr %0, 0x0, %%fprs\n\t"\r\n"membar #Sync"\r\n: "=&r" (mask), "=&r" (val)\r\n: "0" (mask), "1" (val),\r\n"i" (FPRS_FEF), "r" (&cacheline[0]),\r\n"i" (ASI_BLK_COMMIT_P));\r\n}\r\n}\r\nstatic unsigned int schizo_irq_build(struct device_node *dp,\r\nunsigned int ino,\r\nvoid *_data)\r\n{\r\nstruct schizo_irq_data *irq_data = _data;\r\nunsigned long pbm_regs = irq_data->pbm_regs;\r\nunsigned long imap, iclr;\r\nint ign_fixup;\r\nint irq;\r\nint is_tomatillo;\r\nino &= 0x3f;\r\nimap = schizo_ino_to_imap(pbm_regs, ino);\r\niclr = schizo_ino_to_iclr(pbm_regs, ino);\r\nign_fixup = 0;\r\nis_tomatillo = (irq_data->sync_reg != 0UL);\r\nif (is_tomatillo) {\r\nif (irq_data->portid & 1)\r\nign_fixup = (1 << 6);\r\n}\r\nirq = build_irq(ign_fixup, iclr, imap);\r\nif (is_tomatillo) {\r\nirq_install_pre_handler(irq,\r\ntomatillo_wsync_handler,\r\n((irq_data->chip_version <= 4) ?\r\n(void *) 1 : (void *) 0),\r\n(void *) irq_data->sync_reg);\r\n}\r\nreturn irq;\r\n}\r\nstatic void __init __schizo_irq_trans_init(struct device_node *dp,\r\nint is_tomatillo)\r\n{\r\nconst struct linux_prom64_registers *regs;\r\nstruct schizo_irq_data *irq_data;\r\ndp->irq_trans = prom_early_alloc(sizeof(struct of_irq_controller));\r\ndp->irq_trans->irq_build = schizo_irq_build;\r\nirq_data = prom_early_alloc(sizeof(struct schizo_irq_data));\r\nregs = of_get_property(dp, "reg", NULL);\r\ndp->irq_trans->data = irq_data;\r\nirq_data->pbm_regs = regs[0].phys_addr;\r\nif (is_tomatillo)\r\nirq_data->sync_reg = regs[3].phys_addr + 0x1a18UL;\r\nelse\r\nirq_data->sync_reg = 0UL;\r\nirq_data->portid = of_getintprop_default(dp, "portid", 0);\r\nirq_data->chip_version = of_getintprop_default(dp, "version#", 0);\r\n}\r\nstatic void __init schizo_irq_trans_init(struct device_node *dp)\r\n{\r\n__schizo_irq_trans_init(dp, 0);\r\n}\r\nstatic void __init tomatillo_irq_trans_init(struct device_node *dp)\r\n{\r\n__schizo_irq_trans_init(dp, 1);\r\n}\r\nstatic unsigned int pci_sun4v_irq_build(struct device_node *dp,\r\nunsigned int devino,\r\nvoid *_data)\r\n{\r\nu32 devhandle = (u32) (unsigned long) _data;\r\nreturn sun4v_build_irq(devhandle, devino);\r\n}\r\nstatic void __init pci_sun4v_irq_trans_init(struct device_node *dp)\r\n{\r\nconst struct linux_prom64_registers *regs;\r\ndp->irq_trans = prom_early_alloc(sizeof(struct of_irq_controller));\r\ndp->irq_trans->irq_build = pci_sun4v_irq_build;\r\nregs = of_get_property(dp, "reg", NULL);\r\ndp->irq_trans->data = (void *) (unsigned long)\r\n((regs->phys_addr >> 32UL) & 0x0fffffff);\r\n}\r\nstatic unsigned long fire_imap_offset(unsigned long ino)\r\n{\r\nreturn FIRE_IMAP_BASE + (ino * 8UL);\r\n}\r\nstatic unsigned long fire_iclr_offset(unsigned long ino)\r\n{\r\nreturn FIRE_ICLR_BASE + (ino * 8UL);\r\n}\r\nstatic unsigned long fire_ino_to_iclr(unsigned long pbm_regs,\r\nunsigned int ino)\r\n{\r\nreturn pbm_regs + fire_iclr_offset(ino);\r\n}\r\nstatic unsigned long fire_ino_to_imap(unsigned long pbm_regs,\r\nunsigned int ino)\r\n{\r\nreturn pbm_regs + fire_imap_offset(ino);\r\n}\r\nstatic unsigned int fire_irq_build(struct device_node *dp,\r\nunsigned int ino,\r\nvoid *_data)\r\n{\r\nstruct fire_irq_data *irq_data = _data;\r\nunsigned long pbm_regs = irq_data->pbm_regs;\r\nunsigned long imap, iclr;\r\nunsigned long int_ctrlr;\r\nino &= 0x3f;\r\nimap = fire_ino_to_imap(pbm_regs, ino);\r\niclr = fire_ino_to_iclr(pbm_regs, ino);\r\nint_ctrlr = 1 << 6;\r\nupa_writeq(int_ctrlr, imap);\r\nino |= (irq_data->portid << 6);\r\nino -= int_ctrlr;\r\nreturn build_irq(ino, iclr, imap);\r\n}\r\nstatic void __init fire_irq_trans_init(struct device_node *dp)\r\n{\r\nconst struct linux_prom64_registers *regs;\r\nstruct fire_irq_data *irq_data;\r\ndp->irq_trans = prom_early_alloc(sizeof(struct of_irq_controller));\r\ndp->irq_trans->irq_build = fire_irq_build;\r\nirq_data = prom_early_alloc(sizeof(struct fire_irq_data));\r\nregs = of_get_property(dp, "reg", NULL);\r\ndp->irq_trans->data = irq_data;\r\nirq_data->pbm_regs = regs[0].phys_addr;\r\nirq_data->portid = of_getintprop_default(dp, "portid", 0);\r\n}\r\nstatic unsigned long sysio_imap_to_iclr(unsigned long imap)\r\n{\r\nunsigned long diff = SYSIO_ICLR_UNUSED0 - SYSIO_IMAP_SLOT0;\r\nreturn imap + diff;\r\n}\r\nstatic unsigned int sbus_of_build_irq(struct device_node *dp,\r\nunsigned int ino,\r\nvoid *_data)\r\n{\r\nunsigned long reg_base = (unsigned long) _data;\r\nconst struct linux_prom_registers *regs;\r\nunsigned long imap, iclr;\r\nint sbus_slot = 0;\r\nint sbus_level = 0;\r\nino &= 0x3f;\r\nregs = of_get_property(dp, "reg", NULL);\r\nif (regs)\r\nsbus_slot = regs->which_io;\r\nif (ino < 0x20)\r\nino += (sbus_slot * 8);\r\nimap = sysio_irq_offsets[ino];\r\nif (imap == ((unsigned long)-1)) {\r\nprom_printf("get_irq_translations: Bad SYSIO INO[%x]\n",\r\nino);\r\nprom_halt();\r\n}\r\nimap += reg_base;\r\nif (ino >= 0x20) {\r\niclr = sysio_imap_to_iclr(imap);\r\n} else {\r\nsbus_level = ino & 0x7;\r\nswitch(sbus_slot) {\r\ncase 0:\r\niclr = reg_base + SYSIO_ICLR_SLOT0;\r\nbreak;\r\ncase 1:\r\niclr = reg_base + SYSIO_ICLR_SLOT1;\r\nbreak;\r\ncase 2:\r\niclr = reg_base + SYSIO_ICLR_SLOT2;\r\nbreak;\r\ndefault:\r\ncase 3:\r\niclr = reg_base + SYSIO_ICLR_SLOT3;\r\nbreak;\r\n}\r\niclr += ((unsigned long)sbus_level - 1UL) * 8UL;\r\n}\r\nreturn build_irq(sbus_level, iclr, imap);\r\n}\r\nstatic void __init sbus_irq_trans_init(struct device_node *dp)\r\n{\r\nconst struct linux_prom64_registers *regs;\r\ndp->irq_trans = prom_early_alloc(sizeof(struct of_irq_controller));\r\ndp->irq_trans->irq_build = sbus_of_build_irq;\r\nregs = of_get_property(dp, "reg", NULL);\r\ndp->irq_trans->data = (void *) (unsigned long) regs->phys_addr;\r\n}\r\nstatic unsigned int central_build_irq(struct device_node *dp,\r\nunsigned int ino,\r\nvoid *_data)\r\n{\r\nstruct device_node *central_dp = _data;\r\nstruct platform_device *central_op = of_find_device_by_node(central_dp);\r\nstruct resource *res;\r\nunsigned long imap, iclr;\r\nu32 tmp;\r\nif (!strcmp(dp->name, "eeprom")) {\r\nres = &central_op->resource[5];\r\n} else if (!strcmp(dp->name, "zs")) {\r\nres = &central_op->resource[4];\r\n} else if (!strcmp(dp->name, "clock-board")) {\r\nres = &central_op->resource[3];\r\n} else {\r\nreturn ino;\r\n}\r\nimap = res->start + 0x00UL;\r\niclr = res->start + 0x10UL;\r\nupa_writel(0, iclr);\r\nupa_readl(iclr);\r\ntmp = upa_readl(imap);\r\ntmp &= ~0x80000000;\r\nupa_writel(tmp, imap);\r\nreturn build_irq(0, iclr, imap);\r\n}\r\nstatic void __init central_irq_trans_init(struct device_node *dp)\r\n{\r\ndp->irq_trans = prom_early_alloc(sizeof(struct of_irq_controller));\r\ndp->irq_trans->irq_build = central_build_irq;\r\ndp->irq_trans->data = dp;\r\n}\r\nstatic unsigned int sun4v_vdev_irq_build(struct device_node *dp,\r\nunsigned int devino,\r\nvoid *_data)\r\n{\r\nu32 devhandle = (u32) (unsigned long) _data;\r\nreturn sun4v_build_irq(devhandle, devino);\r\n}\r\nstatic void __init sun4v_vdev_irq_trans_init(struct device_node *dp)\r\n{\r\nconst struct linux_prom64_registers *regs;\r\ndp->irq_trans = prom_early_alloc(sizeof(struct of_irq_controller));\r\ndp->irq_trans->irq_build = sun4v_vdev_irq_build;\r\nregs = of_get_property(dp, "reg", NULL);\r\ndp->irq_trans->data = (void *) (unsigned long)\r\n((regs->phys_addr >> 32UL) & 0x0fffffff);\r\n}\r\nvoid __init irq_trans_init(struct device_node *dp)\r\n{\r\n#ifdef CONFIG_PCI\r\nconst char *model;\r\nint i;\r\n#endif\r\n#ifdef CONFIG_PCI\r\nmodel = of_get_property(dp, "model", NULL);\r\nif (!model)\r\nmodel = of_get_property(dp, "compatible", NULL);\r\nif (model) {\r\nfor (i = 0; i < ARRAY_SIZE(pci_irq_trans_table); i++) {\r\nstruct irq_trans *t = &pci_irq_trans_table[i];\r\nif (!strcmp(model, t->name)) {\r\nt->init(dp);\r\nreturn;\r\n}\r\n}\r\n}\r\n#endif\r\n#ifdef CONFIG_SBUS\r\nif (!strcmp(dp->name, "sbus") ||\r\n!strcmp(dp->name, "sbi")) {\r\nsbus_irq_trans_init(dp);\r\nreturn;\r\n}\r\n#endif\r\nif (!strcmp(dp->name, "fhc") &&\r\n!strcmp(dp->parent->name, "central")) {\r\ncentral_irq_trans_init(dp);\r\nreturn;\r\n}\r\nif (!strcmp(dp->name, "virtual-devices") ||\r\n!strcmp(dp->name, "niu")) {\r\nsun4v_vdev_irq_trans_init(dp);\r\nreturn;\r\n}\r\n}
