static inline void fbcon_map_override(void)\r\n{\r\nmap_override = 1;\r\n}\r\nstatic inline void fbcon_map_override(void)\r\n{\r\n}\r\nstatic inline void fbcon_set_rotation(struct fb_info *info)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nif (!(info->flags & FBINFO_MISC_TILEBLITTING) &&\r\nops->p->con_rotate < 4)\r\nops->rotate = ops->p->con_rotate;\r\nelse\r\nops->rotate = 0;\r\n}\r\nstatic void fbcon_rotate(struct fb_info *info, u32 rotate)\r\n{\r\nstruct fbcon_ops *ops= info->fbcon_par;\r\nstruct fb_info *fb_info;\r\nif (!ops || ops->currcon == -1)\r\nreturn;\r\nfb_info = registered_fb[con2fb_map[ops->currcon]];\r\nif (info == fb_info) {\r\nstruct display *p = &fb_display[ops->currcon];\r\nif (rotate < 4)\r\np->con_rotate = rotate;\r\nelse\r\np->con_rotate = 0;\r\nfbcon_modechanged(info);\r\n}\r\n}\r\nstatic void fbcon_rotate_all(struct fb_info *info, u32 rotate)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct vc_data *vc;\r\nstruct display *p;\r\nint i;\r\nif (!ops || ops->currcon < 0 || rotate > 3)\r\nreturn;\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nvc = vc_cons[i].d;\r\nif (!vc || vc->vc_mode != KD_TEXT ||\r\nregistered_fb[con2fb_map[i]] != info)\r\ncontinue;\r\np = &fb_display[vc->vc_num];\r\np->con_rotate = rotate;\r\n}\r\nfbcon_set_all_vcs(info);\r\n}\r\nstatic inline void fbcon_set_rotation(struct fb_info *info)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nops->rotate = FB_ROTATE_UR;\r\n}\r\nstatic void fbcon_rotate(struct fb_info *info, u32 rotate)\r\n{\r\nreturn;\r\n}\r\nstatic void fbcon_rotate_all(struct fb_info *info, u32 rotate)\r\n{\r\nreturn;\r\n}\r\nstatic int fbcon_get_rotate(struct fb_info *info)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nreturn (ops) ? ops->rotate : 0;\r\n}\r\nstatic inline int fbcon_is_inactive(struct vc_data *vc, struct fb_info *info)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nreturn (info->state != FBINFO_STATE_RUNNING ||\r\nvc->vc_mode != KD_TEXT || ops->graphics) &&\r\n!vt_force_oops_output(vc);\r\n}\r\nstatic int get_color(struct vc_data *vc, struct fb_info *info,\r\nu16 c, int is_fg)\r\n{\r\nint depth = fb_get_color_depth(&info->var, &info->fix);\r\nint color = 0;\r\nif (console_blanked) {\r\nunsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\r\nc = vc->vc_video_erase_char & charmask;\r\n}\r\nif (depth != 1)\r\ncolor = (is_fg) ? attr_fgcol((vc->vc_hi_font_mask) ? 9 : 8, c)\r\n: attr_bgcol((vc->vc_hi_font_mask) ? 13 : 12, c);\r\nswitch (depth) {\r\ncase 1:\r\n{\r\nint col = mono_col(info);\r\nint fg = (info->fix.visual != FB_VISUAL_MONO01) ? col : 0;\r\nint bg = (info->fix.visual != FB_VISUAL_MONO01) ? 0 : col;\r\nif (console_blanked)\r\nfg = bg;\r\ncolor = (is_fg) ? fg : bg;\r\nbreak;\r\n}\r\ncase 2:\r\nswitch (color) {\r\ncase 0:\r\ncolor = 0;\r\nbreak;\r\ncase 1 ... 6:\r\ncolor = 2;\r\nbreak;\r\ncase 7 ... 8:\r\ncolor = 1;\r\nbreak;\r\ndefault:\r\ncolor = 3;\r\nbreak;\r\n}\r\nbreak;\r\ncase 3:\r\ncolor &= 7;\r\nbreak;\r\n}\r\nreturn color;\r\n}\r\nstatic void fbcon_update_softback(struct vc_data *vc)\r\n{\r\nint l = fbcon_softback_size / vc->vc_size_row;\r\nif (l > 5)\r\nsoftback_end = softback_buf + l * vc->vc_size_row;\r\nelse\r\nsoftback_top = 0;\r\n}\r\nstatic void fb_flashcursor(struct work_struct *work)\r\n{\r\nstruct fb_info *info = container_of(work, struct fb_info, queue);\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct vc_data *vc = NULL;\r\nint c;\r\nint mode;\r\nint ret;\r\nret = console_trylock();\r\nif (ret == 0)\r\nreturn;\r\nif (ops && ops->currcon != -1)\r\nvc = vc_cons[ops->currcon].d;\r\nif (!vc || !CON_IS_VISIBLE(vc) ||\r\nregistered_fb[con2fb_map[vc->vc_num]] != info ||\r\nvc->vc_deccm != 1) {\r\nconsole_unlock();\r\nreturn;\r\n}\r\nc = scr_readw((u16 *) vc->vc_pos);\r\nmode = (!ops->cursor_flash || ops->cursor_state.enable) ?\r\nCM_ERASE : CM_DRAW;\r\nops->cursor(vc, info, mode, softback_lines, get_color(vc, info, c, 1),\r\nget_color(vc, info, c, 0));\r\nconsole_unlock();\r\n}\r\nstatic void cursor_timer_handler(unsigned long dev_addr)\r\n{\r\nstruct fb_info *info = (struct fb_info *) dev_addr;\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nschedule_work(&info->queue);\r\nmod_timer(&ops->cursor_timer, jiffies + HZ/5);\r\n}\r\nstatic void fbcon_add_cursor_timer(struct fb_info *info)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nif ((!info->queue.func || info->queue.func == fb_flashcursor) &&\r\n!(ops->flags & FBCON_FLAGS_CURSOR_TIMER) &&\r\n!fbcon_cursor_noblink) {\r\nif (!info->queue.func)\r\nINIT_WORK(&info->queue, fb_flashcursor);\r\ninit_timer(&ops->cursor_timer);\r\nops->cursor_timer.function = cursor_timer_handler;\r\nops->cursor_timer.expires = jiffies + HZ / 5;\r\nops->cursor_timer.data = (unsigned long ) info;\r\nadd_timer(&ops->cursor_timer);\r\nops->flags |= FBCON_FLAGS_CURSOR_TIMER;\r\n}\r\n}\r\nstatic void fbcon_del_cursor_timer(struct fb_info *info)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nif (info->queue.func == fb_flashcursor &&\r\nops->flags & FBCON_FLAGS_CURSOR_TIMER) {\r\ndel_timer_sync(&ops->cursor_timer);\r\nops->flags &= ~FBCON_FLAGS_CURSOR_TIMER;\r\n}\r\n}\r\nstatic int __init fb_console_setup(char *this_opt)\r\n{\r\nchar *options;\r\nint i, j;\r\nif (!this_opt || !*this_opt)\r\nreturn 1;\r\nwhile ((options = strsep(&this_opt, ",")) != NULL) {\r\nif (!strncmp(options, "font:", 5))\r\nstrlcpy(fontname, options + 5, sizeof(fontname));\r\nif (!strncmp(options, "scrollback:", 11)) {\r\noptions += 11;\r\nif (*options) {\r\nfbcon_softback_size = simple_strtoul(options, &options, 0);\r\nif (*options == 'k' || *options == 'K') {\r\nfbcon_softback_size *= 1024;\r\noptions++;\r\n}\r\nif (*options != ',')\r\nreturn 1;\r\noptions++;\r\n} else\r\nreturn 1;\r\n}\r\nif (!strncmp(options, "map:", 4)) {\r\noptions += 4;\r\nif (*options) {\r\nfor (i = 0, j = 0; i < MAX_NR_CONSOLES; i++) {\r\nif (!options[j])\r\nj = 0;\r\ncon2fb_map_boot[i] =\r\n(options[j++]-'0') % FB_MAX;\r\n}\r\nfbcon_map_override();\r\n}\r\nreturn 1;\r\n}\r\nif (!strncmp(options, "vc:", 3)) {\r\noptions += 3;\r\nif (*options)\r\nfirst_fb_vc = simple_strtoul(options, &options, 10) - 1;\r\nif (first_fb_vc < 0)\r\nfirst_fb_vc = 0;\r\nif (*options++ == '-')\r\nlast_fb_vc = simple_strtoul(options, &options, 10) - 1;\r\nfbcon_is_default = 0;\r\n}\r\nif (!strncmp(options, "rotate:", 7)) {\r\noptions += 7;\r\nif (*options)\r\ninitial_rotation = simple_strtoul(options, &options, 0);\r\nif (initial_rotation > 3)\r\ninitial_rotation = 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int search_fb_in_map(int idx)\r\n{\r\nint i, retval = 0;\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nif (con2fb_map[i] == idx)\r\nretval = 1;\r\n}\r\nreturn retval;\r\n}\r\nstatic int search_for_mapped_con(void)\r\n{\r\nint i, retval = 0;\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nif (con2fb_map[i] != -1)\r\nretval = 1;\r\n}\r\nreturn retval;\r\n}\r\nstatic int fbcon_takeover(int show_logo)\r\n{\r\nint err, i;\r\nif (!num_registered_fb)\r\nreturn -ENODEV;\r\nif (!show_logo)\r\nlogo_shown = FBCON_LOGO_DONTSHOW;\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++)\r\ncon2fb_map[i] = info_idx;\r\nerr = take_over_console(&fb_con, first_fb_vc, last_fb_vc,\r\nfbcon_is_default);\r\nif (err) {\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\ncon2fb_map[i] = -1;\r\n}\r\ninfo_idx = -1;\r\n} else {\r\nfbcon_has_console_bind = 1;\r\n}\r\nreturn err;\r\n}\r\nstatic void fbcon_prepare_logo(struct vc_data *vc, struct fb_info *info,\r\nint cols, int rows, int new_cols, int new_rows)\r\n{\r\nlogo_shown = FBCON_LOGO_DONTSHOW;\r\n}\r\nstatic void fbcon_prepare_logo(struct vc_data *vc, struct fb_info *info,\r\nint cols, int rows, int new_cols, int new_rows)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nint cnt, erase = vc->vc_video_erase_char, step;\r\nunsigned short *save = NULL, *r, *q;\r\nint logo_height;\r\nif (info->flags & FBINFO_MODULE) {\r\nlogo_shown = FBCON_LOGO_DONTSHOW;\r\nreturn;\r\n}\r\nif (fb_get_color_depth(&info->var, &info->fix) == 1)\r\nerase &= ~0x400;\r\nlogo_height = fb_prepare_logo(info, ops->rotate);\r\nlogo_lines = DIV_ROUND_UP(logo_height, vc->vc_font.height);\r\nq = (unsigned short *) (vc->vc_origin +\r\nvc->vc_size_row * rows);\r\nstep = logo_lines * cols;\r\nfor (r = q - logo_lines * cols; r < q; r++)\r\nif (scr_readw(r) != vc->vc_video_erase_char)\r\nbreak;\r\nif (r != q && new_rows >= rows + logo_lines) {\r\nsave = kmalloc(logo_lines * new_cols * 2, GFP_KERNEL);\r\nif (save) {\r\nint i = cols < new_cols ? cols : new_cols;\r\nscr_memsetw(save, erase, logo_lines * new_cols * 2);\r\nr = q - step;\r\nfor (cnt = 0; cnt < logo_lines; cnt++, r += i)\r\nscr_memcpyw(save + cnt * new_cols, r, 2 * i);\r\nr = q;\r\n}\r\n}\r\nif (r == q) {\r\nr = q - step - cols;\r\nfor (cnt = rows - logo_lines; cnt > 0; cnt--) {\r\nscr_memcpyw(r + step, r, vc->vc_size_row);\r\nr -= cols;\r\n}\r\nif (!save) {\r\nint lines;\r\nif (vc->vc_y + logo_lines >= rows)\r\nlines = rows - vc->vc_y - 1;\r\nelse\r\nlines = logo_lines;\r\nvc->vc_y += lines;\r\nvc->vc_pos += lines * vc->vc_size_row;\r\n}\r\n}\r\nscr_memsetw((unsigned short *) vc->vc_origin,\r\nerase,\r\nvc->vc_size_row * logo_lines);\r\nif (CON_IS_VISIBLE(vc) && vc->vc_mode == KD_TEXT) {\r\nfbcon_clear_margins(vc, 0);\r\nupdate_screen(vc);\r\n}\r\nif (save) {\r\nq = (unsigned short *) (vc->vc_origin +\r\nvc->vc_size_row *\r\nrows);\r\nscr_memcpyw(q, save, logo_lines * new_cols * 2);\r\nvc->vc_y += logo_lines;\r\nvc->vc_pos += logo_lines * vc->vc_size_row;\r\nkfree(save);\r\n}\r\nif (logo_lines > vc->vc_bottom) {\r\nlogo_shown = FBCON_LOGO_CANSHOW;\r\nprintk(KERN_INFO\r\n"fbcon_init: disable boot-logo (boot-logo bigger than screen).\n");\r\n} else if (logo_shown != FBCON_LOGO_DONTSHOW) {\r\nlogo_shown = FBCON_LOGO_DRAW;\r\nvc->vc_top = logo_lines;\r\n}\r\n}\r\nstatic void set_blitting_type(struct vc_data *vc, struct fb_info *info)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nops->p = &fb_display[vc->vc_num];\r\nif ((info->flags & FBINFO_MISC_TILEBLITTING))\r\nfbcon_set_tileops(vc, info);\r\nelse {\r\nfbcon_set_rotation(info);\r\nfbcon_set_bitops(ops);\r\n}\r\n}\r\nstatic int fbcon_invalid_charcount(struct fb_info *info, unsigned charcount)\r\n{\r\nint err = 0;\r\nif (info->flags & FBINFO_MISC_TILEBLITTING &&\r\ninfo->tileops->fb_get_tilemax(info) < charcount)\r\nerr = 1;\r\nreturn err;\r\n}\r\nstatic void set_blitting_type(struct vc_data *vc, struct fb_info *info)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\ninfo->flags &= ~FBINFO_MISC_TILEBLITTING;\r\nops->p = &fb_display[vc->vc_num];\r\nfbcon_set_rotation(info);\r\nfbcon_set_bitops(ops);\r\n}\r\nstatic int fbcon_invalid_charcount(struct fb_info *info, unsigned charcount)\r\n{\r\nreturn 0;\r\n}\r\nstatic int con2fb_acquire_newinfo(struct vc_data *vc, struct fb_info *info,\r\nint unit, int oldidx)\r\n{\r\nstruct fbcon_ops *ops = NULL;\r\nint err = 0;\r\nif (!try_module_get(info->fbops->owner))\r\nerr = -ENODEV;\r\nif (!err && info->fbops->fb_open &&\r\ninfo->fbops->fb_open(info, 0))\r\nerr = -ENODEV;\r\nif (!err) {\r\nops = kzalloc(sizeof(struct fbcon_ops), GFP_KERNEL);\r\nif (!ops)\r\nerr = -ENOMEM;\r\n}\r\nif (!err) {\r\ninfo->fbcon_par = ops;\r\nif (vc)\r\nset_blitting_type(vc, info);\r\n}\r\nif (err) {\r\ncon2fb_map[unit] = oldidx;\r\nmodule_put(info->fbops->owner);\r\n}\r\nreturn err;\r\n}\r\nstatic int con2fb_release_oldinfo(struct vc_data *vc, struct fb_info *oldinfo,\r\nstruct fb_info *newinfo, int unit,\r\nint oldidx, int found)\r\n{\r\nstruct fbcon_ops *ops = oldinfo->fbcon_par;\r\nint err = 0, ret;\r\nif (oldinfo->fbops->fb_release &&\r\noldinfo->fbops->fb_release(oldinfo, 0)) {\r\ncon2fb_map[unit] = oldidx;\r\nif (!found && newinfo->fbops->fb_release)\r\nnewinfo->fbops->fb_release(newinfo, 0);\r\nif (!found)\r\nmodule_put(newinfo->fbops->owner);\r\nerr = -ENODEV;\r\n}\r\nif (!err) {\r\nfbcon_del_cursor_timer(oldinfo);\r\nkfree(ops->cursor_state.mask);\r\nkfree(ops->cursor_data);\r\nkfree(ops->fontbuffer);\r\nkfree(oldinfo->fbcon_par);\r\noldinfo->fbcon_par = NULL;\r\nmodule_put(oldinfo->fbops->owner);\r\nif (newinfo->fbops->fb_set_par) {\r\nret = newinfo->fbops->fb_set_par(newinfo);\r\nif (ret)\r\nprintk(KERN_ERR "con2fb_release_oldinfo: "\r\n"detected unhandled fb_set_par error, "\r\n"error code %d\n", ret);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void con2fb_init_display(struct vc_data *vc, struct fb_info *info,\r\nint unit, int show_logo)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nint ret;\r\nops->currcon = fg_console;\r\nif (info->fbops->fb_set_par && !(ops->flags & FBCON_FLAGS_INIT)) {\r\nret = info->fbops->fb_set_par(info);\r\nif (ret)\r\nprintk(KERN_ERR "con2fb_init_display: detected "\r\n"unhandled fb_set_par error, "\r\n"error code %d\n", ret);\r\n}\r\nops->flags |= FBCON_FLAGS_INIT;\r\nops->graphics = 0;\r\nfbcon_set_disp(info, &info->var, unit);\r\nif (show_logo) {\r\nstruct vc_data *fg_vc = vc_cons[fg_console].d;\r\nstruct fb_info *fg_info =\r\nregistered_fb[con2fb_map[fg_console]];\r\nfbcon_prepare_logo(fg_vc, fg_info, fg_vc->vc_cols,\r\nfg_vc->vc_rows, fg_vc->vc_cols,\r\nfg_vc->vc_rows);\r\n}\r\nupdate_screen(vc_cons[fg_console].d);\r\n}\r\nstatic int set_con2fb_map(int unit, int newidx, int user)\r\n{\r\nstruct vc_data *vc = vc_cons[unit].d;\r\nint oldidx = con2fb_map[unit];\r\nstruct fb_info *info = registered_fb[newidx];\r\nstruct fb_info *oldinfo = NULL;\r\nint found, err = 0;\r\nif (oldidx == newidx)\r\nreturn 0;\r\nif (!info)\r\nreturn -EINVAL;\r\nif (!search_for_mapped_con() || !con_is_bound(&fb_con)) {\r\ninfo_idx = newidx;\r\nreturn fbcon_takeover(0);\r\n}\r\nif (oldidx != -1)\r\noldinfo = registered_fb[oldidx];\r\nfound = search_fb_in_map(newidx);\r\nconsole_lock();\r\ncon2fb_map[unit] = newidx;\r\nif (!err && !found)\r\nerr = con2fb_acquire_newinfo(vc, info, unit, oldidx);\r\nif (!err && oldinfo && !search_fb_in_map(oldidx))\r\nerr = con2fb_release_oldinfo(vc, oldinfo, info, unit, oldidx,\r\nfound);\r\nif (!err) {\r\nint show_logo = (fg_console == 0 && !user &&\r\nlogo_shown != FBCON_LOGO_DONTSHOW);\r\nif (!found)\r\nfbcon_add_cursor_timer(info);\r\ncon2fb_map_boot[unit] = newidx;\r\ncon2fb_init_display(vc, info, unit, show_logo);\r\n}\r\nif (!search_fb_in_map(info_idx))\r\ninfo_idx = newidx;\r\nconsole_unlock();\r\nreturn err;\r\n}\r\nstatic int var_to_display(struct display *disp,\r\nstruct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\ndisp->xres_virtual = var->xres_virtual;\r\ndisp->yres_virtual = var->yres_virtual;\r\ndisp->bits_per_pixel = var->bits_per_pixel;\r\ndisp->grayscale = var->grayscale;\r\ndisp->nonstd = var->nonstd;\r\ndisp->accel_flags = var->accel_flags;\r\ndisp->height = var->height;\r\ndisp->width = var->width;\r\ndisp->red = var->red;\r\ndisp->green = var->green;\r\ndisp->blue = var->blue;\r\ndisp->transp = var->transp;\r\ndisp->rotate = var->rotate;\r\ndisp->mode = fb_match_mode(var, &info->modelist);\r\nif (disp->mode == NULL)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void display_to_var(struct fb_var_screeninfo *var,\r\nstruct display *disp)\r\n{\r\nfb_videomode_to_var(var, disp->mode);\r\nvar->xres_virtual = disp->xres_virtual;\r\nvar->yres_virtual = disp->yres_virtual;\r\nvar->bits_per_pixel = disp->bits_per_pixel;\r\nvar->grayscale = disp->grayscale;\r\nvar->nonstd = disp->nonstd;\r\nvar->accel_flags = disp->accel_flags;\r\nvar->height = disp->height;\r\nvar->width = disp->width;\r\nvar->red = disp->red;\r\nvar->green = disp->green;\r\nvar->blue = disp->blue;\r\nvar->transp = disp->transp;\r\nvar->rotate = disp->rotate;\r\n}\r\nstatic const char *fbcon_startup(void)\r\n{\r\nconst char *display_desc = "frame buffer device";\r\nstruct display *p = &fb_display[fg_console];\r\nstruct vc_data *vc = vc_cons[fg_console].d;\r\nconst struct font_desc *font = NULL;\r\nstruct module *owner;\r\nstruct fb_info *info = NULL;\r\nstruct fbcon_ops *ops;\r\nint rows, cols;\r\nif (!num_registered_fb || info_idx == -1)\r\nreturn display_desc;\r\ninfo = registered_fb[info_idx];\r\nif (!info)\r\nreturn NULL;\r\nowner = info->fbops->owner;\r\nif (!try_module_get(owner))\r\nreturn NULL;\r\nif (info->fbops->fb_open && info->fbops->fb_open(info, 0)) {\r\nmodule_put(owner);\r\nreturn NULL;\r\n}\r\nops = kzalloc(sizeof(struct fbcon_ops), GFP_KERNEL);\r\nif (!ops) {\r\nmodule_put(owner);\r\nreturn NULL;\r\n}\r\nops->currcon = -1;\r\nops->graphics = 1;\r\nops->cur_rotate = -1;\r\ninfo->fbcon_par = ops;\r\np->con_rotate = initial_rotation;\r\nset_blitting_type(vc, info);\r\nif (info->fix.type != FB_TYPE_TEXT) {\r\nif (fbcon_softback_size) {\r\nif (!softback_buf) {\r\nsoftback_buf =\r\n(unsigned long)\r\nkmalloc(fbcon_softback_size,\r\nGFP_KERNEL);\r\nif (!softback_buf) {\r\nfbcon_softback_size = 0;\r\nsoftback_top = 0;\r\n}\r\n}\r\n} else {\r\nif (softback_buf) {\r\nkfree((void *) softback_buf);\r\nsoftback_buf = 0;\r\nsoftback_top = 0;\r\n}\r\n}\r\nif (softback_buf)\r\nsoftback_in = softback_top = softback_curr =\r\nsoftback_buf;\r\nsoftback_lines = 0;\r\n}\r\nif (!p->fontdata) {\r\nif (!fontname[0] || !(font = find_font(fontname)))\r\nfont = get_default_font(info->var.xres,\r\ninfo->var.yres,\r\ninfo->pixmap.blit_x,\r\ninfo->pixmap.blit_y);\r\nvc->vc_font.width = font->width;\r\nvc->vc_font.height = font->height;\r\nvc->vc_font.data = (void *)(p->fontdata = font->data);\r\nvc->vc_font.charcount = 256;\r\n}\r\ncols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\r\nrows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\r\ncols /= vc->vc_font.width;\r\nrows /= vc->vc_font.height;\r\nvc_resize(vc, cols, rows);\r\nDPRINTK("mode: %s\n", info->fix.id);\r\nDPRINTK("visual: %d\n", info->fix.visual);\r\nDPRINTK("res: %dx%d-%d\n", info->var.xres,\r\ninfo->var.yres,\r\ninfo->var.bits_per_pixel);\r\nfbcon_add_cursor_timer(info);\r\nfbcon_has_exited = 0;\r\nreturn display_desc;\r\n}\r\nstatic void fbcon_init(struct vc_data *vc, int init)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops;\r\nstruct vc_data **default_mode = vc->vc_display_fg;\r\nstruct vc_data *svc = *default_mode;\r\nstruct display *t, *p = &fb_display[vc->vc_num];\r\nint logo = 1, new_rows, new_cols, rows, cols, charcnt = 256;\r\nint cap, ret;\r\nif (info_idx == -1 || info == NULL)\r\nreturn;\r\ncap = info->flags;\r\nif (vc != svc || logo_shown == FBCON_LOGO_DONTSHOW ||\r\n(info->fix.type == FB_TYPE_TEXT))\r\nlogo = 0;\r\nif (var_to_display(p, &info->var, info))\r\nreturn;\r\nif (!info->fbcon_par)\r\ncon2fb_acquire_newinfo(vc, info, vc->vc_num, -1);\r\nt = &fb_display[fg_console];\r\nif (!p->fontdata) {\r\nif (t->fontdata) {\r\nstruct vc_data *fvc = vc_cons[fg_console].d;\r\nvc->vc_font.data = (void *)(p->fontdata =\r\nfvc->vc_font.data);\r\nvc->vc_font.width = fvc->vc_font.width;\r\nvc->vc_font.height = fvc->vc_font.height;\r\np->userfont = t->userfont;\r\nif (p->userfont)\r\nREFCOUNT(p->fontdata)++;\r\n} else {\r\nconst struct font_desc *font = NULL;\r\nif (!fontname[0] || !(font = find_font(fontname)))\r\nfont = get_default_font(info->var.xres,\r\ninfo->var.yres,\r\ninfo->pixmap.blit_x,\r\ninfo->pixmap.blit_y);\r\nvc->vc_font.width = font->width;\r\nvc->vc_font.height = font->height;\r\nvc->vc_font.data = (void *)(p->fontdata = font->data);\r\nvc->vc_font.charcount = 256;\r\n}\r\n}\r\nif (p->userfont)\r\ncharcnt = FNTCHARCNT(p->fontdata);\r\nvc->vc_panic_force_write = !!(info->flags & FBINFO_CAN_FORCE_OUTPUT);\r\nvc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);\r\nvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;\r\nif (charcnt == 256) {\r\nvc->vc_hi_font_mask = 0;\r\n} else {\r\nvc->vc_hi_font_mask = 0x100;\r\nif (vc->vc_can_do_color)\r\nvc->vc_complement_mask <<= 1;\r\n}\r\nif (!*svc->vc_uni_pagedir_loc)\r\ncon_set_default_unimap(svc);\r\nif (!*vc->vc_uni_pagedir_loc)\r\ncon_copy_unimap(vc, svc);\r\nops = info->fbcon_par;\r\np->con_rotate = initial_rotation;\r\nset_blitting_type(vc, info);\r\ncols = vc->vc_cols;\r\nrows = vc->vc_rows;\r\nnew_cols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\r\nnew_rows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\r\nnew_cols /= vc->vc_font.width;\r\nnew_rows /= vc->vc_font.height;\r\nif (CON_IS_VISIBLE(vc) && vc->vc_mode == KD_TEXT) {\r\nif (info->fbops->fb_set_par &&\r\n!(ops->flags & FBCON_FLAGS_INIT)) {\r\nret = info->fbops->fb_set_par(info);\r\nif (ret)\r\nprintk(KERN_ERR "fbcon_init: detected "\r\n"unhandled fb_set_par error, "\r\n"error code %d\n", ret);\r\n}\r\nops->flags |= FBCON_FLAGS_INIT;\r\n}\r\nops->graphics = 0;\r\nif ((cap & FBINFO_HWACCEL_COPYAREA) &&\r\n!(cap & FBINFO_HWACCEL_DISABLED))\r\np->scrollmode = SCROLL_MOVE;\r\nelse\r\np->scrollmode = SCROLL_REDRAW;\r\nif (init) {\r\nvc->vc_cols = new_cols;\r\nvc->vc_rows = new_rows;\r\n} else\r\nvc_resize(vc, new_cols, new_rows);\r\nif (logo)\r\nfbcon_prepare_logo(vc, info, cols, rows, new_cols, new_rows);\r\nif (vc == svc && softback_buf)\r\nfbcon_update_softback(vc);\r\nif (ops->rotate_font && ops->rotate_font(info, vc)) {\r\nops->rotate = FB_ROTATE_UR;\r\nset_blitting_type(vc, info);\r\n}\r\nops->p = &fb_display[fg_console];\r\n}\r\nstatic void fbcon_free_font(struct display *p)\r\n{\r\nif (p->userfont && p->fontdata && (--REFCOUNT(p->fontdata) == 0))\r\nkfree(p->fontdata - FONT_EXTRA_WORDS * sizeof(int));\r\np->fontdata = NULL;\r\np->userfont = 0;\r\n}\r\nstatic void fbcon_deinit(struct vc_data *vc)\r\n{\r\nstruct display *p = &fb_display[vc->vc_num];\r\nstruct fb_info *info;\r\nstruct fbcon_ops *ops;\r\nint idx;\r\nfbcon_free_font(p);\r\nidx = con2fb_map[vc->vc_num];\r\nif (idx == -1)\r\ngoto finished;\r\ninfo = registered_fb[idx];\r\nif (!info)\r\ngoto finished;\r\nops = info->fbcon_par;\r\nif (!ops)\r\ngoto finished;\r\nif (CON_IS_VISIBLE(vc))\r\nfbcon_del_cursor_timer(info);\r\nops->flags &= ~FBCON_FLAGS_INIT;\r\nfinished:\r\nif (!con_is_bound(&fb_con))\r\nfbcon_exit();\r\nreturn;\r\n}\r\nstatic void fbcon_clear(struct vc_data *vc, int sy, int sx, int height,\r\nint width)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct display *p = &fb_display[vc->vc_num];\r\nu_int y_break;\r\nif (fbcon_is_inactive(vc, info))\r\nreturn;\r\nif (!height || !width)\r\nreturn;\r\nif (sy < vc->vc_top && vc->vc_top == logo_lines)\r\nvc->vc_top = 0;\r\ny_break = p->vrows - p->yscroll;\r\nif (sy < y_break && sy + height - 1 >= y_break) {\r\nu_int b = y_break - sy;\r\nops->clear(vc, info, real_y(p, sy), sx, b, width);\r\nops->clear(vc, info, real_y(p, sy + b), sx, height - b,\r\nwidth);\r\n} else\r\nops->clear(vc, info, real_y(p, sy), sx, height, width);\r\n}\r\nstatic void fbcon_putcs(struct vc_data *vc, const unsigned short *s,\r\nint count, int ypos, int xpos)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct display *p = &fb_display[vc->vc_num];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nif (!fbcon_is_inactive(vc, info))\r\nops->putcs(vc, info, s, count, real_y(p, ypos), xpos,\r\nget_color(vc, info, scr_readw(s), 1),\r\nget_color(vc, info, scr_readw(s), 0));\r\n}\r\nstatic void fbcon_putc(struct vc_data *vc, int c, int ypos, int xpos)\r\n{\r\nunsigned short chr;\r\nscr_writew(c, &chr);\r\nfbcon_putcs(vc, &chr, 1, ypos, xpos);\r\n}\r\nstatic void fbcon_clear_margins(struct vc_data *vc, int bottom_only)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nif (!fbcon_is_inactive(vc, info))\r\nops->clear_margins(vc, info, bottom_only);\r\n}\r\nstatic void fbcon_cursor(struct vc_data *vc, int mode)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nint y;\r\nint c = scr_readw((u16 *) vc->vc_pos);\r\nif (fbcon_is_inactive(vc, info) || vc->vc_deccm != 1)\r\nreturn;\r\nif (vc->vc_cursor_type & 0x10)\r\nfbcon_del_cursor_timer(info);\r\nelse\r\nfbcon_add_cursor_timer(info);\r\nops->cursor_flash = (mode == CM_ERASE) ? 0 : 1;\r\nif (mode & CM_SOFTBACK) {\r\nmode &= ~CM_SOFTBACK;\r\ny = softback_lines;\r\n} else {\r\nif (softback_lines)\r\nfbcon_set_origin(vc);\r\ny = 0;\r\n}\r\nops->cursor(vc, info, mode, y, get_color(vc, info, c, 1),\r\nget_color(vc, info, c, 0));\r\nvbl_cursor_cnt = CURSOR_DRAW_DELAY;\r\n}\r\nstatic void fbcon_set_disp(struct fb_info *info, struct fb_var_screeninfo *var,\r\nint unit)\r\n{\r\nstruct display *p, *t;\r\nstruct vc_data **default_mode, *vc;\r\nstruct vc_data *svc;\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nint rows, cols, charcnt = 256;\r\np = &fb_display[unit];\r\nif (var_to_display(p, var, info))\r\nreturn;\r\nvc = vc_cons[unit].d;\r\nif (!vc)\r\nreturn;\r\ndefault_mode = vc->vc_display_fg;\r\nsvc = *default_mode;\r\nt = &fb_display[svc->vc_num];\r\nif (!vc->vc_font.data) {\r\nvc->vc_font.data = (void *)(p->fontdata = t->fontdata);\r\nvc->vc_font.width = (*default_mode)->vc_font.width;\r\nvc->vc_font.height = (*default_mode)->vc_font.height;\r\np->userfont = t->userfont;\r\nif (p->userfont)\r\nREFCOUNT(p->fontdata)++;\r\n}\r\nif (p->userfont)\r\ncharcnt = FNTCHARCNT(p->fontdata);\r\nvar->activate = FB_ACTIVATE_NOW;\r\ninfo->var.activate = var->activate;\r\nvar->yoffset = info->var.yoffset;\r\nvar->xoffset = info->var.xoffset;\r\nfb_set_var(info, var);\r\nops->var = info->var;\r\nvc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);\r\nvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;\r\nif (charcnt == 256) {\r\nvc->vc_hi_font_mask = 0;\r\n} else {\r\nvc->vc_hi_font_mask = 0x100;\r\nif (vc->vc_can_do_color)\r\nvc->vc_complement_mask <<= 1;\r\n}\r\nif (!*svc->vc_uni_pagedir_loc)\r\ncon_set_default_unimap(svc);\r\nif (!*vc->vc_uni_pagedir_loc)\r\ncon_copy_unimap(vc, svc);\r\ncols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\r\nrows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\r\ncols /= vc->vc_font.width;\r\nrows /= vc->vc_font.height;\r\nvc_resize(vc, cols, rows);\r\nif (CON_IS_VISIBLE(vc)) {\r\nupdate_screen(vc);\r\nif (softback_buf)\r\nfbcon_update_softback(vc);\r\n}\r\n}\r\nstatic __inline__ void ywrap_up(struct vc_data *vc, int count)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct display *p = &fb_display[vc->vc_num];\r\np->yscroll += count;\r\nif (p->yscroll >= p->vrows)\r\np->yscroll -= p->vrows;\r\nops->var.xoffset = 0;\r\nops->var.yoffset = p->yscroll * vc->vc_font.height;\r\nops->var.vmode |= FB_VMODE_YWRAP;\r\nops->update_start(info);\r\nscrollback_max += count;\r\nif (scrollback_max > scrollback_phys_max)\r\nscrollback_max = scrollback_phys_max;\r\nscrollback_current = 0;\r\n}\r\nstatic __inline__ void ywrap_down(struct vc_data *vc, int count)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct display *p = &fb_display[vc->vc_num];\r\np->yscroll -= count;\r\nif (p->yscroll < 0)\r\np->yscroll += p->vrows;\r\nops->var.xoffset = 0;\r\nops->var.yoffset = p->yscroll * vc->vc_font.height;\r\nops->var.vmode |= FB_VMODE_YWRAP;\r\nops->update_start(info);\r\nscrollback_max -= count;\r\nif (scrollback_max < 0)\r\nscrollback_max = 0;\r\nscrollback_current = 0;\r\n}\r\nstatic __inline__ void ypan_up(struct vc_data *vc, int count)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct display *p = &fb_display[vc->vc_num];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\np->yscroll += count;\r\nif (p->yscroll > p->vrows - vc->vc_rows) {\r\nops->bmove(vc, info, p->vrows - vc->vc_rows,\r\n0, 0, 0, vc->vc_rows, vc->vc_cols);\r\np->yscroll -= p->vrows - vc->vc_rows;\r\n}\r\nops->var.xoffset = 0;\r\nops->var.yoffset = p->yscroll * vc->vc_font.height;\r\nops->var.vmode &= ~FB_VMODE_YWRAP;\r\nops->update_start(info);\r\nfbcon_clear_margins(vc, 1);\r\nscrollback_max += count;\r\nif (scrollback_max > scrollback_phys_max)\r\nscrollback_max = scrollback_phys_max;\r\nscrollback_current = 0;\r\n}\r\nstatic __inline__ void ypan_up_redraw(struct vc_data *vc, int t, int count)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct display *p = &fb_display[vc->vc_num];\r\np->yscroll += count;\r\nif (p->yscroll > p->vrows - vc->vc_rows) {\r\np->yscroll -= p->vrows - vc->vc_rows;\r\nfbcon_redraw_move(vc, p, t + count, vc->vc_rows - count, t);\r\n}\r\nops->var.xoffset = 0;\r\nops->var.yoffset = p->yscroll * vc->vc_font.height;\r\nops->var.vmode &= ~FB_VMODE_YWRAP;\r\nops->update_start(info);\r\nfbcon_clear_margins(vc, 1);\r\nscrollback_max += count;\r\nif (scrollback_max > scrollback_phys_max)\r\nscrollback_max = scrollback_phys_max;\r\nscrollback_current = 0;\r\n}\r\nstatic __inline__ void ypan_down(struct vc_data *vc, int count)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct display *p = &fb_display[vc->vc_num];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\np->yscroll -= count;\r\nif (p->yscroll < 0) {\r\nops->bmove(vc, info, 0, 0, p->vrows - vc->vc_rows,\r\n0, vc->vc_rows, vc->vc_cols);\r\np->yscroll += p->vrows - vc->vc_rows;\r\n}\r\nops->var.xoffset = 0;\r\nops->var.yoffset = p->yscroll * vc->vc_font.height;\r\nops->var.vmode &= ~FB_VMODE_YWRAP;\r\nops->update_start(info);\r\nfbcon_clear_margins(vc, 1);\r\nscrollback_max -= count;\r\nif (scrollback_max < 0)\r\nscrollback_max = 0;\r\nscrollback_current = 0;\r\n}\r\nstatic __inline__ void ypan_down_redraw(struct vc_data *vc, int t, int count)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct display *p = &fb_display[vc->vc_num];\r\np->yscroll -= count;\r\nif (p->yscroll < 0) {\r\np->yscroll += p->vrows - vc->vc_rows;\r\nfbcon_redraw_move(vc, p, t, vc->vc_rows - count, t + count);\r\n}\r\nops->var.xoffset = 0;\r\nops->var.yoffset = p->yscroll * vc->vc_font.height;\r\nops->var.vmode &= ~FB_VMODE_YWRAP;\r\nops->update_start(info);\r\nfbcon_clear_margins(vc, 1);\r\nscrollback_max -= count;\r\nif (scrollback_max < 0)\r\nscrollback_max = 0;\r\nscrollback_current = 0;\r\n}\r\nstatic void fbcon_redraw_softback(struct vc_data *vc, struct display *p,\r\nlong delta)\r\n{\r\nint count = vc->vc_rows;\r\nunsigned short *d, *s;\r\nunsigned long n;\r\nint line = 0;\r\nd = (u16 *) softback_curr;\r\nif (d == (u16 *) softback_in)\r\nd = (u16 *) vc->vc_origin;\r\nn = softback_curr + delta * vc->vc_size_row;\r\nsoftback_lines -= delta;\r\nif (delta < 0) {\r\nif (softback_curr < softback_top && n < softback_buf) {\r\nn += softback_end - softback_buf;\r\nif (n < softback_top) {\r\nsoftback_lines -=\r\n(softback_top - n) / vc->vc_size_row;\r\nn = softback_top;\r\n}\r\n} else if (softback_curr >= softback_top\r\n&& n < softback_top) {\r\nsoftback_lines -=\r\n(softback_top - n) / vc->vc_size_row;\r\nn = softback_top;\r\n}\r\n} else {\r\nif (softback_curr > softback_in && n >= softback_end) {\r\nn += softback_buf - softback_end;\r\nif (n > softback_in) {\r\nn = softback_in;\r\nsoftback_lines = 0;\r\n}\r\n} else if (softback_curr <= softback_in && n > softback_in) {\r\nn = softback_in;\r\nsoftback_lines = 0;\r\n}\r\n}\r\nif (n == softback_curr)\r\nreturn;\r\nsoftback_curr = n;\r\ns = (u16 *) softback_curr;\r\nif (s == (u16 *) softback_in)\r\ns = (u16 *) vc->vc_origin;\r\nwhile (count--) {\r\nunsigned short *start;\r\nunsigned short *le;\r\nunsigned short c;\r\nint x = 0;\r\nunsigned short attr = 1;\r\nstart = s;\r\nle = advance_row(s, 1);\r\ndo {\r\nc = scr_readw(s);\r\nif (attr != (c & 0xff00)) {\r\nattr = c & 0xff00;\r\nif (s > start) {\r\nfbcon_putcs(vc, start, s - start,\r\nline, x);\r\nx += s - start;\r\nstart = s;\r\n}\r\n}\r\nif (c == scr_readw(d)) {\r\nif (s > start) {\r\nfbcon_putcs(vc, start, s - start,\r\nline, x);\r\nx += s - start + 1;\r\nstart = s + 1;\r\n} else {\r\nx++;\r\nstart++;\r\n}\r\n}\r\ns++;\r\nd++;\r\n} while (s < le);\r\nif (s > start)\r\nfbcon_putcs(vc, start, s - start, line, x);\r\nline++;\r\nif (d == (u16 *) softback_end)\r\nd = (u16 *) softback_buf;\r\nif (d == (u16 *) softback_in)\r\nd = (u16 *) vc->vc_origin;\r\nif (s == (u16 *) softback_end)\r\ns = (u16 *) softback_buf;\r\nif (s == (u16 *) softback_in)\r\ns = (u16 *) vc->vc_origin;\r\n}\r\n}\r\nstatic void fbcon_redraw_move(struct vc_data *vc, struct display *p,\r\nint line, int count, int dy)\r\n{\r\nunsigned short *s = (unsigned short *)\r\n(vc->vc_origin + vc->vc_size_row * line);\r\nwhile (count--) {\r\nunsigned short *start = s;\r\nunsigned short *le = advance_row(s, 1);\r\nunsigned short c;\r\nint x = 0;\r\nunsigned short attr = 1;\r\ndo {\r\nc = scr_readw(s);\r\nif (attr != (c & 0xff00)) {\r\nattr = c & 0xff00;\r\nif (s > start) {\r\nfbcon_putcs(vc, start, s - start,\r\ndy, x);\r\nx += s - start;\r\nstart = s;\r\n}\r\n}\r\nconsole_conditional_schedule();\r\ns++;\r\n} while (s < le);\r\nif (s > start)\r\nfbcon_putcs(vc, start, s - start, dy, x);\r\nconsole_conditional_schedule();\r\ndy++;\r\n}\r\n}\r\nstatic void fbcon_redraw_blit(struct vc_data *vc, struct fb_info *info,\r\nstruct display *p, int line, int count, int ycount)\r\n{\r\nint offset = ycount * vc->vc_cols;\r\nunsigned short *d = (unsigned short *)\r\n(vc->vc_origin + vc->vc_size_row * line);\r\nunsigned short *s = d + offset;\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nwhile (count--) {\r\nunsigned short *start = s;\r\nunsigned short *le = advance_row(s, 1);\r\nunsigned short c;\r\nint x = 0;\r\ndo {\r\nc = scr_readw(s);\r\nif (c == scr_readw(d)) {\r\nif (s > start) {\r\nops->bmove(vc, info, line + ycount, x,\r\nline, x, 1, s-start);\r\nx += s - start + 1;\r\nstart = s + 1;\r\n} else {\r\nx++;\r\nstart++;\r\n}\r\n}\r\nscr_writew(c, d);\r\nconsole_conditional_schedule();\r\ns++;\r\nd++;\r\n} while (s < le);\r\nif (s > start)\r\nops->bmove(vc, info, line + ycount, x, line, x, 1,\r\ns-start);\r\nconsole_conditional_schedule();\r\nif (ycount > 0)\r\nline++;\r\nelse {\r\nline--;\r\ns -= vc->vc_size_row;\r\nd -= vc->vc_size_row;\r\n}\r\n}\r\n}\r\nstatic void fbcon_redraw(struct vc_data *vc, struct display *p,\r\nint line, int count, int offset)\r\n{\r\nunsigned short *d = (unsigned short *)\r\n(vc->vc_origin + vc->vc_size_row * line);\r\nunsigned short *s = d + offset;\r\nwhile (count--) {\r\nunsigned short *start = s;\r\nunsigned short *le = advance_row(s, 1);\r\nunsigned short c;\r\nint x = 0;\r\nunsigned short attr = 1;\r\ndo {\r\nc = scr_readw(s);\r\nif (attr != (c & 0xff00)) {\r\nattr = c & 0xff00;\r\nif (s > start) {\r\nfbcon_putcs(vc, start, s - start,\r\nline, x);\r\nx += s - start;\r\nstart = s;\r\n}\r\n}\r\nif (c == scr_readw(d)) {\r\nif (s > start) {\r\nfbcon_putcs(vc, start, s - start,\r\nline, x);\r\nx += s - start + 1;\r\nstart = s + 1;\r\n} else {\r\nx++;\r\nstart++;\r\n}\r\n}\r\nscr_writew(c, d);\r\nconsole_conditional_schedule();\r\ns++;\r\nd++;\r\n} while (s < le);\r\nif (s > start)\r\nfbcon_putcs(vc, start, s - start, line, x);\r\nconsole_conditional_schedule();\r\nif (offset > 0)\r\nline++;\r\nelse {\r\nline--;\r\ns -= vc->vc_size_row;\r\nd -= vc->vc_size_row;\r\n}\r\n}\r\n}\r\nstatic inline void fbcon_softback_note(struct vc_data *vc, int t,\r\nint count)\r\n{\r\nunsigned short *p;\r\nif (vc->vc_num != fg_console)\r\nreturn;\r\np = (unsigned short *) (vc->vc_origin + t * vc->vc_size_row);\r\nwhile (count) {\r\nscr_memcpyw((u16 *) softback_in, p, vc->vc_size_row);\r\ncount--;\r\np = advance_row(p, 1);\r\nsoftback_in += vc->vc_size_row;\r\nif (softback_in == softback_end)\r\nsoftback_in = softback_buf;\r\nif (softback_in == softback_top) {\r\nsoftback_top += vc->vc_size_row;\r\nif (softback_top == softback_end)\r\nsoftback_top = softback_buf;\r\n}\r\n}\r\nsoftback_curr = softback_in;\r\n}\r\nstatic int fbcon_scroll(struct vc_data *vc, int t, int b, int dir,\r\nint count)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct display *p = &fb_display[vc->vc_num];\r\nint scroll_partial = info->flags & FBINFO_PARTIAL_PAN_OK;\r\nif (fbcon_is_inactive(vc, info))\r\nreturn -EINVAL;\r\nfbcon_cursor(vc, CM_ERASE);\r\nswitch (dir) {\r\ncase SM_UP:\r\nif (count > vc->vc_rows)\r\ncount = vc->vc_rows;\r\nif (softback_top)\r\nfbcon_softback_note(vc, t, count);\r\nif (logo_shown >= 0)\r\ngoto redraw_up;\r\nswitch (p->scrollmode) {\r\ncase SCROLL_MOVE:\r\nfbcon_redraw_blit(vc, info, p, t, b - t - count,\r\ncount);\r\nfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\r\nscr_memsetw((unsigned short *) (vc->vc_origin +\r\nvc->vc_size_row *\r\n(b - count)),\r\nvc->vc_video_erase_char,\r\nvc->vc_size_row * count);\r\nreturn 1;\r\nbreak;\r\ncase SCROLL_WRAP_MOVE:\r\nif (b - t - count > 3 * vc->vc_rows >> 2) {\r\nif (t > 0)\r\nfbcon_bmove(vc, 0, 0, count, 0, t,\r\nvc->vc_cols);\r\nywrap_up(vc, count);\r\nif (vc->vc_rows - b > 0)\r\nfbcon_bmove(vc, b - count, 0, b, 0,\r\nvc->vc_rows - b,\r\nvc->vc_cols);\r\n} else if (info->flags & FBINFO_READS_FAST)\r\nfbcon_bmove(vc, t + count, 0, t, 0,\r\nb - t - count, vc->vc_cols);\r\nelse\r\ngoto redraw_up;\r\nfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\r\nbreak;\r\ncase SCROLL_PAN_REDRAW:\r\nif ((p->yscroll + count <=\r\n2 * (p->vrows - vc->vc_rows))\r\n&& ((!scroll_partial && (b - t == vc->vc_rows))\r\n|| (scroll_partial\r\n&& (b - t - count >\r\n3 * vc->vc_rows >> 2)))) {\r\nif (t > 0)\r\nfbcon_redraw_move(vc, p, 0, t, count);\r\nypan_up_redraw(vc, t, count);\r\nif (vc->vc_rows - b > 0)\r\nfbcon_redraw_move(vc, p, b,\r\nvc->vc_rows - b, b);\r\n} else\r\nfbcon_redraw_move(vc, p, t + count, b - t - count, t);\r\nfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\r\nbreak;\r\ncase SCROLL_PAN_MOVE:\r\nif ((p->yscroll + count <=\r\n2 * (p->vrows - vc->vc_rows))\r\n&& ((!scroll_partial && (b - t == vc->vc_rows))\r\n|| (scroll_partial\r\n&& (b - t - count >\r\n3 * vc->vc_rows >> 2)))) {\r\nif (t > 0)\r\nfbcon_bmove(vc, 0, 0, count, 0, t,\r\nvc->vc_cols);\r\nypan_up(vc, count);\r\nif (vc->vc_rows - b > 0)\r\nfbcon_bmove(vc, b - count, 0, b, 0,\r\nvc->vc_rows - b,\r\nvc->vc_cols);\r\n} else if (info->flags & FBINFO_READS_FAST)\r\nfbcon_bmove(vc, t + count, 0, t, 0,\r\nb - t - count, vc->vc_cols);\r\nelse\r\ngoto redraw_up;\r\nfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\r\nbreak;\r\ncase SCROLL_REDRAW:\r\nredraw_up:\r\nfbcon_redraw(vc, p, t, b - t - count,\r\ncount * vc->vc_cols);\r\nfbcon_clear(vc, b - count, 0, count, vc->vc_cols);\r\nscr_memsetw((unsigned short *) (vc->vc_origin +\r\nvc->vc_size_row *\r\n(b - count)),\r\nvc->vc_video_erase_char,\r\nvc->vc_size_row * count);\r\nreturn 1;\r\n}\r\nbreak;\r\ncase SM_DOWN:\r\nif (count > vc->vc_rows)\r\ncount = vc->vc_rows;\r\nif (logo_shown >= 0)\r\ngoto redraw_down;\r\nswitch (p->scrollmode) {\r\ncase SCROLL_MOVE:\r\nfbcon_redraw_blit(vc, info, p, b - 1, b - t - count,\r\n-count);\r\nfbcon_clear(vc, t, 0, count, vc->vc_cols);\r\nscr_memsetw((unsigned short *) (vc->vc_origin +\r\nvc->vc_size_row *\r\nt),\r\nvc->vc_video_erase_char,\r\nvc->vc_size_row * count);\r\nreturn 1;\r\nbreak;\r\ncase SCROLL_WRAP_MOVE:\r\nif (b - t - count > 3 * vc->vc_rows >> 2) {\r\nif (vc->vc_rows - b > 0)\r\nfbcon_bmove(vc, b, 0, b - count, 0,\r\nvc->vc_rows - b,\r\nvc->vc_cols);\r\nywrap_down(vc, count);\r\nif (t > 0)\r\nfbcon_bmove(vc, count, 0, 0, 0, t,\r\nvc->vc_cols);\r\n} else if (info->flags & FBINFO_READS_FAST)\r\nfbcon_bmove(vc, t, 0, t + count, 0,\r\nb - t - count, vc->vc_cols);\r\nelse\r\ngoto redraw_down;\r\nfbcon_clear(vc, t, 0, count, vc->vc_cols);\r\nbreak;\r\ncase SCROLL_PAN_MOVE:\r\nif ((count - p->yscroll <= p->vrows - vc->vc_rows)\r\n&& ((!scroll_partial && (b - t == vc->vc_rows))\r\n|| (scroll_partial\r\n&& (b - t - count >\r\n3 * vc->vc_rows >> 2)))) {\r\nif (vc->vc_rows - b > 0)\r\nfbcon_bmove(vc, b, 0, b - count, 0,\r\nvc->vc_rows - b,\r\nvc->vc_cols);\r\nypan_down(vc, count);\r\nif (t > 0)\r\nfbcon_bmove(vc, count, 0, 0, 0, t,\r\nvc->vc_cols);\r\n} else if (info->flags & FBINFO_READS_FAST)\r\nfbcon_bmove(vc, t, 0, t + count, 0,\r\nb - t - count, vc->vc_cols);\r\nelse\r\ngoto redraw_down;\r\nfbcon_clear(vc, t, 0, count, vc->vc_cols);\r\nbreak;\r\ncase SCROLL_PAN_REDRAW:\r\nif ((count - p->yscroll <= p->vrows - vc->vc_rows)\r\n&& ((!scroll_partial && (b - t == vc->vc_rows))\r\n|| (scroll_partial\r\n&& (b - t - count >\r\n3 * vc->vc_rows >> 2)))) {\r\nif (vc->vc_rows - b > 0)\r\nfbcon_redraw_move(vc, p, b, vc->vc_rows - b,\r\nb - count);\r\nypan_down_redraw(vc, t, count);\r\nif (t > 0)\r\nfbcon_redraw_move(vc, p, count, t, 0);\r\n} else\r\nfbcon_redraw_move(vc, p, t, b - t - count, t + count);\r\nfbcon_clear(vc, t, 0, count, vc->vc_cols);\r\nbreak;\r\ncase SCROLL_REDRAW:\r\nredraw_down:\r\nfbcon_redraw(vc, p, b - 1, b - t - count,\r\n-count * vc->vc_cols);\r\nfbcon_clear(vc, t, 0, count, vc->vc_cols);\r\nscr_memsetw((unsigned short *) (vc->vc_origin +\r\nvc->vc_size_row *\r\nt),\r\nvc->vc_video_erase_char,\r\nvc->vc_size_row * count);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void fbcon_bmove(struct vc_data *vc, int sy, int sx, int dy, int dx,\r\nint height, int width)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct display *p = &fb_display[vc->vc_num];\r\nif (fbcon_is_inactive(vc, info))\r\nreturn;\r\nif (!width || !height)\r\nreturn;\r\nfbcon_bmove_rec(vc, p, sy, sx, dy, dx, height, width,\r\np->vrows - p->yscroll);\r\n}\r\nstatic void fbcon_bmove_rec(struct vc_data *vc, struct display *p, int sy, int sx,\r\nint dy, int dx, int height, int width, u_int y_break)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nu_int b;\r\nif (sy < y_break && sy + height > y_break) {\r\nb = y_break - sy;\r\nif (dy < sy) {\r\nfbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,\r\ny_break);\r\nfbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,\r\nheight - b, width, y_break);\r\n} else {\r\nfbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,\r\nheight - b, width, y_break);\r\nfbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,\r\ny_break);\r\n}\r\nreturn;\r\n}\r\nif (dy < y_break && dy + height > y_break) {\r\nb = y_break - dy;\r\nif (dy < sy) {\r\nfbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,\r\ny_break);\r\nfbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,\r\nheight - b, width, y_break);\r\n} else {\r\nfbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,\r\nheight - b, width, y_break);\r\nfbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,\r\ny_break);\r\n}\r\nreturn;\r\n}\r\nops->bmove(vc, info, real_y(p, sy), sx, real_y(p, dy), dx,\r\nheight, width);\r\n}\r\nstatic void updatescrollmode(struct display *p,\r\nstruct fb_info *info,\r\nstruct vc_data *vc)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nint fh = vc->vc_font.height;\r\nint cap = info->flags;\r\nu16 t = 0;\r\nint ypan = FBCON_SWAP(ops->rotate, info->fix.ypanstep,\r\ninfo->fix.xpanstep);\r\nint ywrap = FBCON_SWAP(ops->rotate, info->fix.ywrapstep, t);\r\nint yres = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\r\nint vyres = FBCON_SWAP(ops->rotate, info->var.yres_virtual,\r\ninfo->var.xres_virtual);\r\nint good_pan = (cap & FBINFO_HWACCEL_YPAN) &&\r\ndivides(ypan, vc->vc_font.height) && vyres > yres;\r\nint good_wrap = (cap & FBINFO_HWACCEL_YWRAP) &&\r\ndivides(ywrap, vc->vc_font.height) &&\r\ndivides(vc->vc_font.height, vyres) &&\r\ndivides(vc->vc_font.height, yres);\r\nint reading_fast = cap & FBINFO_READS_FAST;\r\nint fast_copyarea = (cap & FBINFO_HWACCEL_COPYAREA) &&\r\n!(cap & FBINFO_HWACCEL_DISABLED);\r\nint fast_imageblit = (cap & FBINFO_HWACCEL_IMAGEBLIT) &&\r\n!(cap & FBINFO_HWACCEL_DISABLED);\r\np->vrows = vyres/fh;\r\nif (yres > (fh * (vc->vc_rows + 1)))\r\np->vrows -= (yres - (fh * vc->vc_rows)) / fh;\r\nif ((yres % fh) && (vyres % fh < yres % fh))\r\np->vrows--;\r\nif (good_wrap || good_pan) {\r\nif (reading_fast || fast_copyarea)\r\np->scrollmode = good_wrap ?\r\nSCROLL_WRAP_MOVE : SCROLL_PAN_MOVE;\r\nelse\r\np->scrollmode = good_wrap ? SCROLL_REDRAW :\r\nSCROLL_PAN_REDRAW;\r\n} else {\r\nif (reading_fast || (fast_copyarea && !fast_imageblit))\r\np->scrollmode = SCROLL_MOVE;\r\nelse\r\np->scrollmode = SCROLL_REDRAW;\r\n}\r\n}\r\nstatic int fbcon_resize(struct vc_data *vc, unsigned int width,\r\nunsigned int height, unsigned int user)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct display *p = &fb_display[vc->vc_num];\r\nstruct fb_var_screeninfo var = info->var;\r\nint x_diff, y_diff, virt_w, virt_h, virt_fw, virt_fh;\r\nvirt_w = FBCON_SWAP(ops->rotate, width, height);\r\nvirt_h = FBCON_SWAP(ops->rotate, height, width);\r\nvirt_fw = FBCON_SWAP(ops->rotate, vc->vc_font.width,\r\nvc->vc_font.height);\r\nvirt_fh = FBCON_SWAP(ops->rotate, vc->vc_font.height,\r\nvc->vc_font.width);\r\nvar.xres = virt_w * virt_fw;\r\nvar.yres = virt_h * virt_fh;\r\nx_diff = info->var.xres - var.xres;\r\ny_diff = info->var.yres - var.yres;\r\nif (x_diff < 0 || x_diff > virt_fw ||\r\ny_diff < 0 || y_diff > virt_fh) {\r\nconst struct fb_videomode *mode;\r\nDPRINTK("attempting resize %ix%i\n", var.xres, var.yres);\r\nmode = fb_find_best_mode(&var, &info->modelist);\r\nif (mode == NULL)\r\nreturn -EINVAL;\r\ndisplay_to_var(&var, p);\r\nfb_videomode_to_var(&var, mode);\r\nif (virt_w > var.xres/virt_fw || virt_h > var.yres/virt_fh)\r\nreturn -EINVAL;\r\nDPRINTK("resize now %ix%i\n", var.xres, var.yres);\r\nif (CON_IS_VISIBLE(vc)) {\r\nvar.activate = FB_ACTIVATE_NOW |\r\nFB_ACTIVATE_FORCE;\r\nfb_set_var(info, &var);\r\n}\r\nvar_to_display(p, &info->var, info);\r\nops->var = info->var;\r\n}\r\nupdatescrollmode(p, info, vc);\r\nreturn 0;\r\n}\r\nstatic int fbcon_switch(struct vc_data *vc)\r\n{\r\nstruct fb_info *info, *old_info = NULL;\r\nstruct fbcon_ops *ops;\r\nstruct display *p = &fb_display[vc->vc_num];\r\nstruct fb_var_screeninfo var;\r\nint i, ret, prev_console, charcnt = 256;\r\ninfo = registered_fb[con2fb_map[vc->vc_num]];\r\nops = info->fbcon_par;\r\nif (softback_top) {\r\nif (softback_lines)\r\nfbcon_set_origin(vc);\r\nsoftback_top = softback_curr = softback_in = softback_buf;\r\nsoftback_lines = 0;\r\nfbcon_update_softback(vc);\r\n}\r\nif (logo_shown >= 0) {\r\nstruct vc_data *conp2 = vc_cons[logo_shown].d;\r\nif (conp2->vc_top == logo_lines\r\n&& conp2->vc_bottom == conp2->vc_rows)\r\nconp2->vc_top = 0;\r\nlogo_shown = FBCON_LOGO_CANSHOW;\r\n}\r\nprev_console = ops->currcon;\r\nif (prev_console != -1)\r\nold_info = registered_fb[con2fb_map[prev_console]];\r\nfor (i = 0; i < FB_MAX; i++) {\r\nif (registered_fb[i] != NULL && registered_fb[i]->fbcon_par) {\r\nstruct fbcon_ops *o = registered_fb[i]->fbcon_par;\r\no->currcon = vc->vc_num;\r\n}\r\n}\r\nmemset(&var, 0, sizeof(struct fb_var_screeninfo));\r\ndisplay_to_var(&var, p);\r\nvar.activate = FB_ACTIVATE_NOW;\r\ninfo->var.activate = var.activate;\r\nvar.vmode |= info->var.vmode & ~FB_VMODE_MASK;\r\nfb_set_var(info, &var);\r\nops->var = info->var;\r\nif (old_info != NULL && (old_info != info ||\r\ninfo->flags & FBINFO_MISC_ALWAYS_SETPAR)) {\r\nif (info->fbops->fb_set_par) {\r\nret = info->fbops->fb_set_par(info);\r\nif (ret)\r\nprintk(KERN_ERR "fbcon_switch: detected "\r\n"unhandled fb_set_par error, "\r\n"error code %d\n", ret);\r\n}\r\nif (old_info != info)\r\nfbcon_del_cursor_timer(old_info);\r\n}\r\nif (fbcon_is_inactive(vc, info) ||\r\nops->blank_state != FB_BLANK_UNBLANK)\r\nfbcon_del_cursor_timer(info);\r\nelse\r\nfbcon_add_cursor_timer(info);\r\nset_blitting_type(vc, info);\r\nops->cursor_reset = 1;\r\nif (ops->rotate_font && ops->rotate_font(info, vc)) {\r\nops->rotate = FB_ROTATE_UR;\r\nset_blitting_type(vc, info);\r\n}\r\nvc->vc_can_do_color = (fb_get_color_depth(&info->var, &info->fix)!=1);\r\nvc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;\r\nif (p->userfont)\r\ncharcnt = FNTCHARCNT(vc->vc_font.data);\r\nif (charcnt > 256)\r\nvc->vc_complement_mask <<= 1;\r\nupdatescrollmode(p, info, vc);\r\nswitch (p->scrollmode) {\r\ncase SCROLL_WRAP_MOVE:\r\nscrollback_phys_max = p->vrows - vc->vc_rows;\r\nbreak;\r\ncase SCROLL_PAN_MOVE:\r\ncase SCROLL_PAN_REDRAW:\r\nscrollback_phys_max = p->vrows - 2 * vc->vc_rows;\r\nif (scrollback_phys_max < 0)\r\nscrollback_phys_max = 0;\r\nbreak;\r\ndefault:\r\nscrollback_phys_max = 0;\r\nbreak;\r\n}\r\nscrollback_max = 0;\r\nscrollback_current = 0;\r\nif (!fbcon_is_inactive(vc, info)) {\r\nops->var.xoffset = ops->var.yoffset = p->yscroll = 0;\r\nops->update_start(info);\r\n}\r\nfbcon_set_palette(vc, color_table);\r\nfbcon_clear_margins(vc, 0);\r\nif (logo_shown == FBCON_LOGO_DRAW) {\r\nlogo_shown = fg_console;\r\nfb_show_logo(info, ops->rotate);\r\nupdate_region(vc,\r\nvc->vc_origin + vc->vc_size_row * vc->vc_top,\r\nvc->vc_size_row * (vc->vc_bottom -\r\nvc->vc_top) / 2);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void fbcon_generic_blank(struct vc_data *vc, struct fb_info *info,\r\nint blank)\r\n{\r\nstruct fb_event event;\r\nif (blank) {\r\nunsigned short charmask = vc->vc_hi_font_mask ?\r\n0x1ff : 0xff;\r\nunsigned short oldc;\r\noldc = vc->vc_video_erase_char;\r\nvc->vc_video_erase_char &= charmask;\r\nfbcon_clear(vc, 0, 0, vc->vc_rows, vc->vc_cols);\r\nvc->vc_video_erase_char = oldc;\r\n}\r\nif (!lock_fb_info(info))\r\nreturn;\r\nevent.info = info;\r\nevent.data = &blank;\r\nfb_notifier_call_chain(FB_EVENT_CONBLANK, &event);\r\nunlock_fb_info(info);\r\n}\r\nstatic int fbcon_blank(struct vc_data *vc, int blank, int mode_switch)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nif (mode_switch) {\r\nstruct fb_var_screeninfo var = info->var;\r\nops->graphics = 1;\r\nif (!blank) {\r\nvar.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;\r\nfb_set_var(info, &var);\r\nops->graphics = 0;\r\nops->var = info->var;\r\n}\r\n}\r\nif (!fbcon_is_inactive(vc, info)) {\r\nif (ops->blank_state != blank) {\r\nops->blank_state = blank;\r\nfbcon_cursor(vc, blank ? CM_ERASE : CM_DRAW);\r\nops->cursor_flash = (!blank);\r\nif (!(info->flags & FBINFO_MISC_USEREVENT))\r\nif (fb_blank(info, blank))\r\nfbcon_generic_blank(vc, info, blank);\r\n}\r\nif (!blank)\r\nupdate_screen(vc);\r\n}\r\nif (mode_switch || fbcon_is_inactive(vc, info) ||\r\nops->blank_state != FB_BLANK_UNBLANK)\r\nfbcon_del_cursor_timer(info);\r\nelse\r\nfbcon_add_cursor_timer(info);\r\nreturn 0;\r\n}\r\nstatic int fbcon_debug_enter(struct vc_data *vc)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nops->save_graphics = ops->graphics;\r\nops->graphics = 0;\r\nif (info->fbops->fb_debug_enter)\r\ninfo->fbops->fb_debug_enter(info);\r\nfbcon_set_palette(vc, color_table);\r\nreturn 0;\r\n}\r\nstatic int fbcon_debug_leave(struct vc_data *vc)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nops->graphics = ops->save_graphics;\r\nif (info->fbops->fb_debug_leave)\r\ninfo->fbops->fb_debug_leave(info);\r\nreturn 0;\r\n}\r\nstatic int fbcon_get_font(struct vc_data *vc, struct console_font *font)\r\n{\r\nu8 *fontdata = vc->vc_font.data;\r\nu8 *data = font->data;\r\nint i, j;\r\nfont->width = vc->vc_font.width;\r\nfont->height = vc->vc_font.height;\r\nfont->charcount = vc->vc_hi_font_mask ? 512 : 256;\r\nif (!font->data)\r\nreturn 0;\r\nif (font->width <= 8) {\r\nj = vc->vc_font.height;\r\nfor (i = 0; i < font->charcount; i++) {\r\nmemcpy(data, fontdata, j);\r\nmemset(data + j, 0, 32 - j);\r\ndata += 32;\r\nfontdata += j;\r\n}\r\n} else if (font->width <= 16) {\r\nj = vc->vc_font.height * 2;\r\nfor (i = 0; i < font->charcount; i++) {\r\nmemcpy(data, fontdata, j);\r\nmemset(data + j, 0, 64 - j);\r\ndata += 64;\r\nfontdata += j;\r\n}\r\n} else if (font->width <= 24) {\r\nfor (i = 0; i < font->charcount; i++) {\r\nfor (j = 0; j < vc->vc_font.height; j++) {\r\n*data++ = fontdata[0];\r\n*data++ = fontdata[1];\r\n*data++ = fontdata[2];\r\nfontdata += sizeof(u32);\r\n}\r\nmemset(data, 0, 3 * (32 - j));\r\ndata += 3 * (32 - j);\r\n}\r\n} else {\r\nj = vc->vc_font.height * 4;\r\nfor (i = 0; i < font->charcount; i++) {\r\nmemcpy(data, fontdata, j);\r\nmemset(data + j, 0, 128 - j);\r\ndata += 128;\r\nfontdata += j;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fbcon_do_set_font(struct vc_data *vc, int w, int h,\r\nconst u8 * data, int userfont)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct display *p = &fb_display[vc->vc_num];\r\nint resize;\r\nint cnt;\r\nchar *old_data = NULL;\r\nif (CON_IS_VISIBLE(vc) && softback_lines)\r\nfbcon_set_origin(vc);\r\nresize = (w != vc->vc_font.width) || (h != vc->vc_font.height);\r\nif (p->userfont)\r\nold_data = vc->vc_font.data;\r\nif (userfont)\r\ncnt = FNTCHARCNT(data);\r\nelse\r\ncnt = 256;\r\nvc->vc_font.data = (void *)(p->fontdata = data);\r\nif ((p->userfont = userfont))\r\nREFCOUNT(data)++;\r\nvc->vc_font.width = w;\r\nvc->vc_font.height = h;\r\nif (vc->vc_hi_font_mask && cnt == 256) {\r\nvc->vc_hi_font_mask = 0;\r\nif (vc->vc_can_do_color) {\r\nvc->vc_complement_mask >>= 1;\r\nvc->vc_s_complement_mask >>= 1;\r\n}\r\nif (vc->vc_can_do_color) {\r\nunsigned short *cp =\r\n(unsigned short *) vc->vc_origin;\r\nint count = vc->vc_screenbuf_size / 2;\r\nunsigned short c;\r\nfor (; count > 0; count--, cp++) {\r\nc = scr_readw(cp);\r\nscr_writew(((c & 0xfe00) >> 1) |\r\n(c & 0xff), cp);\r\n}\r\nc = vc->vc_video_erase_char;\r\nvc->vc_video_erase_char =\r\n((c & 0xfe00) >> 1) | (c & 0xff);\r\nvc->vc_attr >>= 1;\r\n}\r\n} else if (!vc->vc_hi_font_mask && cnt == 512) {\r\nvc->vc_hi_font_mask = 0x100;\r\nif (vc->vc_can_do_color) {\r\nvc->vc_complement_mask <<= 1;\r\nvc->vc_s_complement_mask <<= 1;\r\n}\r\n{\r\nunsigned short *cp =\r\n(unsigned short *) vc->vc_origin;\r\nint count = vc->vc_screenbuf_size / 2;\r\nunsigned short c;\r\nfor (; count > 0; count--, cp++) {\r\nunsigned short newc;\r\nc = scr_readw(cp);\r\nif (vc->vc_can_do_color)\r\nnewc =\r\n((c & 0xff00) << 1) | (c &\r\n0xff);\r\nelse\r\nnewc = c & ~0x100;\r\nscr_writew(newc, cp);\r\n}\r\nc = vc->vc_video_erase_char;\r\nif (vc->vc_can_do_color) {\r\nvc->vc_video_erase_char =\r\n((c & 0xff00) << 1) | (c & 0xff);\r\nvc->vc_attr <<= 1;\r\n} else\r\nvc->vc_video_erase_char = c & ~0x100;\r\n}\r\n}\r\nif (resize) {\r\nint cols, rows;\r\ncols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\r\nrows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\r\ncols /= w;\r\nrows /= h;\r\nvc_resize(vc, cols, rows);\r\nif (CON_IS_VISIBLE(vc) && softback_buf)\r\nfbcon_update_softback(vc);\r\n} else if (CON_IS_VISIBLE(vc)\r\n&& vc->vc_mode == KD_TEXT) {\r\nfbcon_clear_margins(vc, 0);\r\nupdate_screen(vc);\r\n}\r\nif (old_data && (--REFCOUNT(old_data) == 0))\r\nkfree(old_data - FONT_EXTRA_WORDS * sizeof(int));\r\nreturn 0;\r\n}\r\nstatic int fbcon_copy_font(struct vc_data *vc, int con)\r\n{\r\nstruct display *od = &fb_display[con];\r\nstruct console_font *f = &vc->vc_font;\r\nif (od->fontdata == f->data)\r\nreturn 0;\r\nreturn fbcon_do_set_font(vc, f->width, f->height, od->fontdata, od->userfont);\r\n}\r\nstatic int fbcon_set_font(struct vc_data *vc, struct console_font *font, unsigned flags)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nunsigned charcount = font->charcount;\r\nint w = font->width;\r\nint h = font->height;\r\nint size;\r\nint i, csum;\r\nu8 *new_data, *data = font->data;\r\nint pitch = (font->width+7) >> 3;\r\nif (charcount != 256 && charcount != 512)\r\nreturn -EINVAL;\r\nif (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||\r\n!(info->pixmap.blit_y & (1 << (font->height - 1))))\r\nreturn -EINVAL;\r\nif (fbcon_invalid_charcount(info, charcount))\r\nreturn -EINVAL;\r\nsize = h * pitch * charcount;\r\nnew_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);\r\nif (!new_data)\r\nreturn -ENOMEM;\r\nnew_data += FONT_EXTRA_WORDS * sizeof(int);\r\nFNTSIZE(new_data) = size;\r\nFNTCHARCNT(new_data) = charcount;\r\nREFCOUNT(new_data) = 0;\r\nfor (i=0; i< charcount; i++) {\r\nmemcpy(new_data + i*h*pitch, data + i*32*pitch, h*pitch);\r\n}\r\ncsum = crc32(0, new_data, size);\r\nFNTSUM(new_data) = csum;\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nstruct vc_data *tmp = vc_cons[i].d;\r\nif (fb_display[i].userfont &&\r\nfb_display[i].fontdata &&\r\nFNTSUM(fb_display[i].fontdata) == csum &&\r\nFNTSIZE(fb_display[i].fontdata) == size &&\r\ntmp->vc_font.width == w &&\r\n!memcmp(fb_display[i].fontdata, new_data, size)) {\r\nkfree(new_data - FONT_EXTRA_WORDS * sizeof(int));\r\nnew_data = (u8 *)fb_display[i].fontdata;\r\nbreak;\r\n}\r\n}\r\nreturn fbcon_do_set_font(vc, font->width, font->height, new_data, 1);\r\n}\r\nstatic int fbcon_set_def_font(struct vc_data *vc, struct console_font *font, char *name)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nconst struct font_desc *f;\r\nif (!name)\r\nf = get_default_font(info->var.xres, info->var.yres,\r\ninfo->pixmap.blit_x, info->pixmap.blit_y);\r\nelse if (!(f = find_font(name)))\r\nreturn -ENOENT;\r\nfont->width = f->width;\r\nfont->height = f->height;\r\nreturn fbcon_do_set_font(vc, f->width, f->height, f->data, 0);\r\n}\r\nstatic int fbcon_set_palette(struct vc_data *vc, unsigned char *table)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];\r\nint i, j, k, depth;\r\nu8 val;\r\nif (fbcon_is_inactive(vc, info))\r\nreturn -EINVAL;\r\nif (!CON_IS_VISIBLE(vc))\r\nreturn 0;\r\ndepth = fb_get_color_depth(&info->var, &info->fix);\r\nif (depth > 3) {\r\nfor (i = j = 0; i < 16; i++) {\r\nk = table[i];\r\nval = vc->vc_palette[j++];\r\npalette_red[k] = (val << 8) | val;\r\nval = vc->vc_palette[j++];\r\npalette_green[k] = (val << 8) | val;\r\nval = vc->vc_palette[j++];\r\npalette_blue[k] = (val << 8) | val;\r\n}\r\npalette_cmap.len = 16;\r\npalette_cmap.start = 0;\r\n} else\r\nfb_copy_cmap(fb_default_cmap(1 << depth), &palette_cmap);\r\nreturn fb_set_cmap(&palette_cmap, info);\r\n}\r\nstatic u16 *fbcon_screen_pos(struct vc_data *vc, int offset)\r\n{\r\nunsigned long p;\r\nint line;\r\nif (vc->vc_num != fg_console || !softback_lines)\r\nreturn (u16 *) (vc->vc_origin + offset);\r\nline = offset / vc->vc_size_row;\r\nif (line >= softback_lines)\r\nreturn (u16 *) (vc->vc_origin + offset -\r\nsoftback_lines * vc->vc_size_row);\r\np = softback_curr + offset;\r\nif (p >= softback_end)\r\np += softback_buf - softback_end;\r\nreturn (u16 *) p;\r\n}\r\nstatic unsigned long fbcon_getxy(struct vc_data *vc, unsigned long pos,\r\nint *px, int *py)\r\n{\r\nunsigned long ret;\r\nint x, y;\r\nif (pos >= vc->vc_origin && pos < vc->vc_scr_end) {\r\nunsigned long offset = (pos - vc->vc_origin) / 2;\r\nx = offset % vc->vc_cols;\r\ny = offset / vc->vc_cols;\r\nif (vc->vc_num == fg_console)\r\ny += softback_lines;\r\nret = pos + (vc->vc_cols - x) * 2;\r\n} else if (vc->vc_num == fg_console && softback_lines) {\r\nunsigned long offset = pos - softback_curr;\r\nif (pos < softback_curr)\r\noffset += softback_end - softback_buf;\r\noffset /= 2;\r\nx = offset % vc->vc_cols;\r\ny = offset / vc->vc_cols;\r\nret = pos + (vc->vc_cols - x) * 2;\r\nif (ret == softback_end)\r\nret = softback_buf;\r\nif (ret == softback_in)\r\nret = vc->vc_origin;\r\n} else {\r\nx = y = 0;\r\nret = vc->vc_origin;\r\n}\r\nif (px)\r\n*px = x;\r\nif (py)\r\n*py = y;\r\nreturn ret;\r\n}\r\nstatic void fbcon_invert_region(struct vc_data *vc, u16 * p, int cnt)\r\n{\r\nwhile (cnt--) {\r\nu16 a = scr_readw(p);\r\nif (!vc->vc_can_do_color)\r\na ^= 0x0800;\r\nelse if (vc->vc_hi_font_mask == 0x100)\r\na = ((a) & 0x11ff) | (((a) & 0xe000) >> 4) |\r\n(((a) & 0x0e00) << 4);\r\nelse\r\na = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) |\r\n(((a) & 0x0700) << 4);\r\nscr_writew(a, p++);\r\nif (p == (u16 *) softback_end)\r\np = (u16 *) softback_buf;\r\nif (p == (u16 *) softback_in)\r\np = (u16 *) vc->vc_origin;\r\n}\r\n}\r\nstatic int fbcon_scrolldelta(struct vc_data *vc, int lines)\r\n{\r\nstruct fb_info *info = registered_fb[con2fb_map[fg_console]];\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct display *disp = &fb_display[fg_console];\r\nint offset, limit, scrollback_old;\r\nif (softback_top) {\r\nif (vc->vc_num != fg_console)\r\nreturn 0;\r\nif (vc->vc_mode != KD_TEXT || !lines)\r\nreturn 0;\r\nif (logo_shown >= 0) {\r\nstruct vc_data *conp2 = vc_cons[logo_shown].d;\r\nif (conp2->vc_top == logo_lines\r\n&& conp2->vc_bottom == conp2->vc_rows)\r\nconp2->vc_top = 0;\r\nif (logo_shown == vc->vc_num) {\r\nunsigned long p, q;\r\nint i;\r\np = softback_in;\r\nq = vc->vc_origin +\r\nlogo_lines * vc->vc_size_row;\r\nfor (i = 0; i < logo_lines; i++) {\r\nif (p == softback_top)\r\nbreak;\r\nif (p == softback_buf)\r\np = softback_end;\r\np -= vc->vc_size_row;\r\nq -= vc->vc_size_row;\r\nscr_memcpyw((u16 *) q, (u16 *) p,\r\nvc->vc_size_row);\r\n}\r\nsoftback_in = softback_curr = p;\r\nupdate_region(vc, vc->vc_origin,\r\nlogo_lines * vc->vc_cols);\r\n}\r\nlogo_shown = FBCON_LOGO_CANSHOW;\r\n}\r\nfbcon_cursor(vc, CM_ERASE | CM_SOFTBACK);\r\nfbcon_redraw_softback(vc, disp, lines);\r\nfbcon_cursor(vc, CM_DRAW | CM_SOFTBACK);\r\nreturn 0;\r\n}\r\nif (!scrollback_phys_max)\r\nreturn -ENOSYS;\r\nscrollback_old = scrollback_current;\r\nscrollback_current -= lines;\r\nif (scrollback_current < 0)\r\nscrollback_current = 0;\r\nelse if (scrollback_current > scrollback_max)\r\nscrollback_current = scrollback_max;\r\nif (scrollback_current == scrollback_old)\r\nreturn 0;\r\nif (fbcon_is_inactive(vc, info))\r\nreturn 0;\r\nfbcon_cursor(vc, CM_ERASE);\r\noffset = disp->yscroll - scrollback_current;\r\nlimit = disp->vrows;\r\nswitch (disp->scrollmode) {\r\ncase SCROLL_WRAP_MOVE:\r\ninfo->var.vmode |= FB_VMODE_YWRAP;\r\nbreak;\r\ncase SCROLL_PAN_MOVE:\r\ncase SCROLL_PAN_REDRAW:\r\nlimit -= vc->vc_rows;\r\ninfo->var.vmode &= ~FB_VMODE_YWRAP;\r\nbreak;\r\n}\r\nif (offset < 0)\r\noffset += limit;\r\nelse if (offset >= limit)\r\noffset -= limit;\r\nops->var.xoffset = 0;\r\nops->var.yoffset = offset * vc->vc_font.height;\r\nops->update_start(info);\r\nif (!scrollback_current)\r\nfbcon_cursor(vc, CM_DRAW);\r\nreturn 0;\r\n}\r\nstatic int fbcon_set_origin(struct vc_data *vc)\r\n{\r\nif (softback_lines)\r\nfbcon_scrolldelta(vc, softback_lines);\r\nreturn 0;\r\n}\r\nstatic void fbcon_suspended(struct fb_info *info)\r\n{\r\nstruct vc_data *vc = NULL;\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nif (!ops || ops->currcon < 0)\r\nreturn;\r\nvc = vc_cons[ops->currcon].d;\r\nfbcon_cursor(vc, CM_ERASE);\r\n}\r\nstatic void fbcon_resumed(struct fb_info *info)\r\n{\r\nstruct vc_data *vc;\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nif (!ops || ops->currcon < 0)\r\nreturn;\r\nvc = vc_cons[ops->currcon].d;\r\nupdate_screen(vc);\r\n}\r\nstatic void fbcon_modechanged(struct fb_info *info)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct vc_data *vc;\r\nstruct display *p;\r\nint rows, cols;\r\nif (!ops || ops->currcon < 0)\r\nreturn;\r\nvc = vc_cons[ops->currcon].d;\r\nif (vc->vc_mode != KD_TEXT ||\r\nregistered_fb[con2fb_map[ops->currcon]] != info)\r\nreturn;\r\np = &fb_display[vc->vc_num];\r\nset_blitting_type(vc, info);\r\nif (CON_IS_VISIBLE(vc)) {\r\nvar_to_display(p, &info->var, info);\r\ncols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\r\nrows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\r\ncols /= vc->vc_font.width;\r\nrows /= vc->vc_font.height;\r\nvc_resize(vc, cols, rows);\r\nupdatescrollmode(p, info, vc);\r\nscrollback_max = 0;\r\nscrollback_current = 0;\r\nif (!fbcon_is_inactive(vc, info)) {\r\nops->var.xoffset = ops->var.yoffset = p->yscroll = 0;\r\nops->update_start(info);\r\n}\r\nfbcon_set_palette(vc, color_table);\r\nupdate_screen(vc);\r\nif (softback_buf)\r\nfbcon_update_softback(vc);\r\n}\r\n}\r\nstatic void fbcon_set_all_vcs(struct fb_info *info)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct vc_data *vc;\r\nstruct display *p;\r\nint i, rows, cols, fg = -1;\r\nif (!ops || ops->currcon < 0)\r\nreturn;\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nvc = vc_cons[i].d;\r\nif (!vc || vc->vc_mode != KD_TEXT ||\r\nregistered_fb[con2fb_map[i]] != info)\r\ncontinue;\r\nif (CON_IS_VISIBLE(vc)) {\r\nfg = i;\r\ncontinue;\r\n}\r\np = &fb_display[vc->vc_num];\r\nset_blitting_type(vc, info);\r\nvar_to_display(p, &info->var, info);\r\ncols = FBCON_SWAP(ops->rotate, info->var.xres, info->var.yres);\r\nrows = FBCON_SWAP(ops->rotate, info->var.yres, info->var.xres);\r\ncols /= vc->vc_font.width;\r\nrows /= vc->vc_font.height;\r\nvc_resize(vc, cols, rows);\r\n}\r\nif (fg != -1)\r\nfbcon_modechanged(info);\r\n}\r\nstatic int fbcon_mode_deleted(struct fb_info *info,\r\nstruct fb_videomode *mode)\r\n{\r\nstruct fb_info *fb_info;\r\nstruct display *p;\r\nint i, j, found = 0;\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nj = con2fb_map[i];\r\nif (j == -1)\r\ncontinue;\r\nfb_info = registered_fb[j];\r\nif (fb_info != info)\r\ncontinue;\r\np = &fb_display[i];\r\nif (!p || !p->mode)\r\ncontinue;\r\nif (fb_mode_is_equal(p->mode, mode)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nreturn found;\r\n}\r\nstatic int fbcon_unbind(void)\r\n{\r\nint ret;\r\nret = unbind_con_driver(&fb_con, first_fb_vc, last_fb_vc,\r\nfbcon_is_default);\r\nif (!ret)\r\nfbcon_has_console_bind = 0;\r\nreturn ret;\r\n}\r\nstatic inline int fbcon_unbind(void)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int fbcon_fb_unbind(int idx)\r\n{\r\nint i, new_idx = -1, ret = 0;\r\nif (!fbcon_has_console_bind)\r\nreturn 0;\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nif (con2fb_map[i] != idx &&\r\ncon2fb_map[i] != -1) {\r\nnew_idx = i;\r\nbreak;\r\n}\r\n}\r\nif (new_idx != -1) {\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nif (con2fb_map[i] == idx)\r\nset_con2fb_map(i, new_idx, 0);\r\n}\r\n} else\r\nret = fbcon_unbind();\r\nreturn ret;\r\n}\r\nstatic int fbcon_fb_unregistered(struct fb_info *info)\r\n{\r\nint i, idx;\r\nidx = info->node;\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nif (con2fb_map[i] == idx)\r\ncon2fb_map[i] = -1;\r\n}\r\nif (idx == info_idx) {\r\ninfo_idx = -1;\r\nfor (i = 0; i < FB_MAX; i++) {\r\nif (registered_fb[i] != NULL) {\r\ninfo_idx = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (info_idx != -1) {\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nif (con2fb_map[i] == -1)\r\ncon2fb_map[i] = info_idx;\r\n}\r\n}\r\nif (primary_device == idx)\r\nprimary_device = -1;\r\nif (!num_registered_fb)\r\nunregister_con_driver(&fb_con);\r\nreturn 0;\r\n}\r\nstatic void fbcon_remap_all(int idx)\r\n{\r\nint i;\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++)\r\nset_con2fb_map(i, idx, 0);\r\nif (con_is_bound(&fb_con)) {\r\nprintk(KERN_INFO "fbcon: Remapping primary device, "\r\n"fb%i, to tty %i-%i\n", idx,\r\nfirst_fb_vc + 1, last_fb_vc + 1);\r\ninfo_idx = idx;\r\n}\r\n}\r\nstatic void fbcon_select_primary(struct fb_info *info)\r\n{\r\nif (!map_override && primary_device == -1 &&\r\nfb_is_primary_device(info)) {\r\nint i;\r\nprintk(KERN_INFO "fbcon: %s (fb%i) is primary device\n",\r\ninfo->fix.id, info->node);\r\nprimary_device = info->node;\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++)\r\ncon2fb_map_boot[i] = primary_device;\r\nif (con_is_bound(&fb_con)) {\r\nprintk(KERN_INFO "fbcon: Remapping primary device, "\r\n"fb%i, to tty %i-%i\n", info->node,\r\nfirst_fb_vc + 1, last_fb_vc + 1);\r\ninfo_idx = primary_device;\r\n}\r\n}\r\n}\r\nstatic inline void fbcon_select_primary(struct fb_info *info)\r\n{\r\nreturn;\r\n}\r\nstatic int fbcon_fb_registered(struct fb_info *info)\r\n{\r\nint ret = 0, i, idx;\r\nidx = info->node;\r\nfbcon_select_primary(info);\r\nif (info_idx == -1) {\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nif (con2fb_map_boot[i] == idx) {\r\ninfo_idx = idx;\r\nbreak;\r\n}\r\n}\r\nif (info_idx != -1)\r\nret = fbcon_takeover(1);\r\n} else {\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nif (con2fb_map_boot[i] == idx)\r\nset_con2fb_map(i, idx, 0);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void fbcon_fb_blanked(struct fb_info *info, int blank)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nstruct vc_data *vc;\r\nif (!ops || ops->currcon < 0)\r\nreturn;\r\nvc = vc_cons[ops->currcon].d;\r\nif (vc->vc_mode != KD_TEXT ||\r\nregistered_fb[con2fb_map[ops->currcon]] != info)\r\nreturn;\r\nif (CON_IS_VISIBLE(vc)) {\r\nif (blank)\r\ndo_blank_screen(0);\r\nelse\r\ndo_unblank_screen(0);\r\n}\r\nops->blank_state = blank;\r\n}\r\nstatic void fbcon_new_modelist(struct fb_info *info)\r\n{\r\nint i;\r\nstruct vc_data *vc;\r\nstruct fb_var_screeninfo var;\r\nconst struct fb_videomode *mode;\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nif (registered_fb[con2fb_map[i]] != info)\r\ncontinue;\r\nif (!fb_display[i].mode)\r\ncontinue;\r\nvc = vc_cons[i].d;\r\ndisplay_to_var(&var, &fb_display[i]);\r\nmode = fb_find_nearest_mode(fb_display[i].mode,\r\n&info->modelist);\r\nfb_videomode_to_var(&var, mode);\r\nfbcon_set_disp(info, &var, vc->vc_num);\r\n}\r\n}\r\nstatic void fbcon_get_requirement(struct fb_info *info,\r\nstruct fb_blit_caps *caps)\r\n{\r\nstruct vc_data *vc;\r\nstruct display *p;\r\nif (caps->flags) {\r\nint i, charcnt;\r\nfor (i = first_fb_vc; i <= last_fb_vc; i++) {\r\nvc = vc_cons[i].d;\r\nif (vc && vc->vc_mode == KD_TEXT &&\r\ninfo->node == con2fb_map[i]) {\r\np = &fb_display[i];\r\ncaps->x |= 1 << (vc->vc_font.width - 1);\r\ncaps->y |= 1 << (vc->vc_font.height - 1);\r\ncharcnt = (p->userfont) ?\r\nFNTCHARCNT(p->fontdata) : 256;\r\nif (caps->len < charcnt)\r\ncaps->len = charcnt;\r\n}\r\n}\r\n} else {\r\nvc = vc_cons[fg_console].d;\r\nif (vc && vc->vc_mode == KD_TEXT &&\r\ninfo->node == con2fb_map[fg_console]) {\r\np = &fb_display[fg_console];\r\ncaps->x = 1 << (vc->vc_font.width - 1);\r\ncaps->y = 1 << (vc->vc_font.height - 1);\r\ncaps->len = (p->userfont) ?\r\nFNTCHARCNT(p->fontdata) : 256;\r\n}\r\n}\r\n}\r\nstatic int fbcon_event_notify(struct notifier_block *self,\r\nunsigned long action, void *data)\r\n{\r\nstruct fb_event *event = data;\r\nstruct fb_info *info = event->info;\r\nstruct fb_videomode *mode;\r\nstruct fb_con2fbmap *con2fb;\r\nstruct fb_blit_caps *caps;\r\nint idx, ret = 0;\r\nif (fbcon_has_exited && !(action == FB_EVENT_FB_REGISTERED ||\r\naction == FB_EVENT_FB_UNREGISTERED))\r\ngoto done;\r\nswitch(action) {\r\ncase FB_EVENT_SUSPEND:\r\nfbcon_suspended(info);\r\nbreak;\r\ncase FB_EVENT_RESUME:\r\nfbcon_resumed(info);\r\nbreak;\r\ncase FB_EVENT_MODE_CHANGE:\r\nfbcon_modechanged(info);\r\nbreak;\r\ncase FB_EVENT_MODE_CHANGE_ALL:\r\nfbcon_set_all_vcs(info);\r\nbreak;\r\ncase FB_EVENT_MODE_DELETE:\r\nmode = event->data;\r\nret = fbcon_mode_deleted(info, mode);\r\nbreak;\r\ncase FB_EVENT_FB_UNBIND:\r\nidx = info->node;\r\nret = fbcon_fb_unbind(idx);\r\nbreak;\r\ncase FB_EVENT_FB_REGISTERED:\r\nret = fbcon_fb_registered(info);\r\nbreak;\r\ncase FB_EVENT_FB_UNREGISTERED:\r\nret = fbcon_fb_unregistered(info);\r\nbreak;\r\ncase FB_EVENT_SET_CONSOLE_MAP:\r\ncon2fb = event->data;\r\nret = set_con2fb_map(con2fb->console - 1,\r\ncon2fb->framebuffer, 1);\r\nbreak;\r\ncase FB_EVENT_GET_CONSOLE_MAP:\r\ncon2fb = event->data;\r\ncon2fb->framebuffer = con2fb_map[con2fb->console - 1];\r\nbreak;\r\ncase FB_EVENT_BLANK:\r\nfbcon_fb_blanked(info, *(int *)event->data);\r\nbreak;\r\ncase FB_EVENT_NEW_MODELIST:\r\nfbcon_new_modelist(info);\r\nbreak;\r\ncase FB_EVENT_GET_REQ:\r\ncaps = event->data;\r\nfbcon_get_requirement(info, caps);\r\nbreak;\r\ncase FB_EVENT_REMAP_ALL_CONSOLE:\r\nidx = info->node;\r\nfbcon_remap_all(idx);\r\nbreak;\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nstatic ssize_t store_rotate(struct device *device,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct fb_info *info;\r\nint rotate, idx;\r\nchar **last = NULL;\r\nif (fbcon_has_exited)\r\nreturn count;\r\nconsole_lock();\r\nidx = con2fb_map[fg_console];\r\nif (idx == -1 || registered_fb[idx] == NULL)\r\ngoto err;\r\ninfo = registered_fb[idx];\r\nrotate = simple_strtoul(buf, last, 0);\r\nfbcon_rotate(info, rotate);\r\nerr:\r\nconsole_unlock();\r\nreturn count;\r\n}\r\nstatic ssize_t store_rotate_all(struct device *device,\r\nstruct device_attribute *attr,const char *buf,\r\nsize_t count)\r\n{\r\nstruct fb_info *info;\r\nint rotate, idx;\r\nchar **last = NULL;\r\nif (fbcon_has_exited)\r\nreturn count;\r\nconsole_lock();\r\nidx = con2fb_map[fg_console];\r\nif (idx == -1 || registered_fb[idx] == NULL)\r\ngoto err;\r\ninfo = registered_fb[idx];\r\nrotate = simple_strtoul(buf, last, 0);\r\nfbcon_rotate_all(info, rotate);\r\nerr:\r\nconsole_unlock();\r\nreturn count;\r\n}\r\nstatic ssize_t show_rotate(struct device *device,\r\nstruct device_attribute *attr,char *buf)\r\n{\r\nstruct fb_info *info;\r\nint rotate = 0, idx;\r\nif (fbcon_has_exited)\r\nreturn 0;\r\nconsole_lock();\r\nidx = con2fb_map[fg_console];\r\nif (idx == -1 || registered_fb[idx] == NULL)\r\ngoto err;\r\ninfo = registered_fb[idx];\r\nrotate = fbcon_get_rotate(info);\r\nerr:\r\nconsole_unlock();\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", rotate);\r\n}\r\nstatic ssize_t show_cursor_blink(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info;\r\nstruct fbcon_ops *ops;\r\nint idx, blink = -1;\r\nif (fbcon_has_exited)\r\nreturn 0;\r\nconsole_lock();\r\nidx = con2fb_map[fg_console];\r\nif (idx == -1 || registered_fb[idx] == NULL)\r\ngoto err;\r\ninfo = registered_fb[idx];\r\nops = info->fbcon_par;\r\nif (!ops)\r\ngoto err;\r\nblink = (ops->flags & FBCON_FLAGS_CURSOR_TIMER) ? 1 : 0;\r\nerr:\r\nconsole_unlock();\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", blink);\r\n}\r\nstatic ssize_t store_cursor_blink(struct device *device,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *info;\r\nint blink, idx;\r\nchar **last = NULL;\r\nif (fbcon_has_exited)\r\nreturn count;\r\nconsole_lock();\r\nidx = con2fb_map[fg_console];\r\nif (idx == -1 || registered_fb[idx] == NULL)\r\ngoto err;\r\ninfo = registered_fb[idx];\r\nif (!info->fbcon_par)\r\ngoto err;\r\nblink = simple_strtoul(buf, last, 0);\r\nif (blink) {\r\nfbcon_cursor_noblink = 0;\r\nfbcon_add_cursor_timer(info);\r\n} else {\r\nfbcon_cursor_noblink = 1;\r\nfbcon_del_cursor_timer(info);\r\n}\r\nerr:\r\nconsole_unlock();\r\nreturn count;\r\n}\r\nstatic int fbcon_init_device(void)\r\n{\r\nint i, error = 0;\r\nfbcon_has_sysfs = 1;\r\nfor (i = 0; i < ARRAY_SIZE(device_attrs); i++) {\r\nerror = device_create_file(fbcon_device, &device_attrs[i]);\r\nif (error)\r\nbreak;\r\n}\r\nif (error) {\r\nwhile (--i >= 0)\r\ndevice_remove_file(fbcon_device, &device_attrs[i]);\r\nfbcon_has_sysfs = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fbcon_start(void)\r\n{\r\nif (num_registered_fb) {\r\nint i;\r\nconsole_lock();\r\nfor (i = 0; i < FB_MAX; i++) {\r\nif (registered_fb[i] != NULL) {\r\ninfo_idx = i;\r\nbreak;\r\n}\r\n}\r\nconsole_unlock();\r\nfbcon_takeover(0);\r\n}\r\n}\r\nstatic void fbcon_exit(void)\r\n{\r\nstruct fb_info *info;\r\nint i, j, mapped;\r\nif (fbcon_has_exited)\r\nreturn;\r\nkfree((void *)softback_buf);\r\nsoftback_buf = 0UL;\r\nfor (i = 0; i < FB_MAX; i++) {\r\nint pending = 0;\r\nmapped = 0;\r\ninfo = registered_fb[i];\r\nif (info == NULL)\r\ncontinue;\r\nif (info->queue.func)\r\npending = cancel_work_sync(&info->queue);\r\nDPRINTK("fbcon: %s pending work\n", (pending ? "canceled" :\r\n"no"));\r\nfor (j = first_fb_vc; j <= last_fb_vc; j++) {\r\nif (con2fb_map[j] == i)\r\nmapped = 1;\r\n}\r\nif (mapped) {\r\nif (info->fbops->fb_release)\r\ninfo->fbops->fb_release(info, 0);\r\nmodule_put(info->fbops->owner);\r\nif (info->fbcon_par) {\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nfbcon_del_cursor_timer(info);\r\nkfree(ops->cursor_src);\r\nkfree(info->fbcon_par);\r\ninfo->fbcon_par = NULL;\r\n}\r\nif (info->queue.func == fb_flashcursor)\r\ninfo->queue.func = NULL;\r\n}\r\n}\r\nfbcon_has_exited = 1;\r\n}\r\nstatic int __init fb_console_init(void)\r\n{\r\nint i;\r\nconsole_lock();\r\nfb_register_client(&fbcon_event_notifier);\r\nfbcon_device = device_create(fb_class, NULL, MKDEV(0, 0), NULL,\r\n"fbcon");\r\nif (IS_ERR(fbcon_device)) {\r\nprintk(KERN_WARNING "Unable to create device "\r\n"for fbcon; errno = %ld\n",\r\nPTR_ERR(fbcon_device));\r\nfbcon_device = NULL;\r\n} else\r\nfbcon_init_device();\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++)\r\ncon2fb_map[i] = -1;\r\nconsole_unlock();\r\nfbcon_start();\r\nreturn 0;\r\n}\r\nstatic void __exit fbcon_deinit_device(void)\r\n{\r\nint i;\r\nif (fbcon_has_sysfs) {\r\nfor (i = 0; i < ARRAY_SIZE(device_attrs); i++)\r\ndevice_remove_file(fbcon_device, &device_attrs[i]);\r\nfbcon_has_sysfs = 0;\r\n}\r\n}\r\nstatic void __exit fb_console_exit(void)\r\n{\r\nconsole_lock();\r\nfb_unregister_client(&fbcon_event_notifier);\r\nfbcon_deinit_device();\r\ndevice_destroy(fb_class, MKDEV(0, 0));\r\nfbcon_exit();\r\nconsole_unlock();\r\nunregister_con_driver(&fb_con);\r\n}
