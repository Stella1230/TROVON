static inline u16\r\nad1889_readw(struct snd_ad1889 *chip, unsigned reg)\r\n{\r\nreturn readw(chip->iobase + reg);\r\n}\r\nstatic inline void\r\nad1889_writew(struct snd_ad1889 *chip, unsigned reg, u16 val)\r\n{\r\nwritew(val, chip->iobase + reg);\r\n}\r\nstatic inline u32\r\nad1889_readl(struct snd_ad1889 *chip, unsigned reg)\r\n{\r\nreturn readl(chip->iobase + reg);\r\n}\r\nstatic inline void\r\nad1889_writel(struct snd_ad1889 *chip, unsigned reg, u32 val)\r\n{\r\nwritel(val, chip->iobase + reg);\r\n}\r\nstatic inline void\r\nad1889_unmute(struct snd_ad1889 *chip)\r\n{\r\nu16 st;\r\nst = ad1889_readw(chip, AD_DS_WADA) &\r\n~(AD_DS_WADA_RWAM | AD_DS_WADA_LWAM);\r\nad1889_writew(chip, AD_DS_WADA, st);\r\nad1889_readw(chip, AD_DS_WADA);\r\n}\r\nstatic inline void\r\nad1889_mute(struct snd_ad1889 *chip)\r\n{\r\nu16 st;\r\nst = ad1889_readw(chip, AD_DS_WADA) | AD_DS_WADA_RWAM | AD_DS_WADA_LWAM;\r\nad1889_writew(chip, AD_DS_WADA, st);\r\nad1889_readw(chip, AD_DS_WADA);\r\n}\r\nstatic inline void\r\nad1889_load_adc_buffer_address(struct snd_ad1889 *chip, u32 address)\r\n{\r\nad1889_writel(chip, AD_DMA_ADCBA, address);\r\nad1889_writel(chip, AD_DMA_ADCCA, address);\r\n}\r\nstatic inline void\r\nad1889_load_adc_buffer_count(struct snd_ad1889 *chip, u32 count)\r\n{\r\nad1889_writel(chip, AD_DMA_ADCBC, count);\r\nad1889_writel(chip, AD_DMA_ADCCC, count);\r\n}\r\nstatic inline void\r\nad1889_load_adc_interrupt_count(struct snd_ad1889 *chip, u32 count)\r\n{\r\nad1889_writel(chip, AD_DMA_ADCIB, count);\r\nad1889_writel(chip, AD_DMA_ADCIC, count);\r\n}\r\nstatic inline void\r\nad1889_load_wave_buffer_address(struct snd_ad1889 *chip, u32 address)\r\n{\r\nad1889_writel(chip, AD_DMA_WAVBA, address);\r\nad1889_writel(chip, AD_DMA_WAVCA, address);\r\n}\r\nstatic inline void\r\nad1889_load_wave_buffer_count(struct snd_ad1889 *chip, u32 count)\r\n{\r\nad1889_writel(chip, AD_DMA_WAVBC, count);\r\nad1889_writel(chip, AD_DMA_WAVCC, count);\r\n}\r\nstatic inline void\r\nad1889_load_wave_interrupt_count(struct snd_ad1889 *chip, u32 count)\r\n{\r\nad1889_writel(chip, AD_DMA_WAVIB, count);\r\nad1889_writel(chip, AD_DMA_WAVIC, count);\r\n}\r\nstatic void\r\nad1889_channel_reset(struct snd_ad1889 *chip, unsigned int channel)\r\n{\r\nu16 reg;\r\nif (channel & AD_CHAN_WAV) {\r\nreg = ad1889_readw(chip, AD_DS_WSMC) & ~AD_DS_WSMC_WAEN;\r\nad1889_writew(chip, AD_DS_WSMC, reg);\r\nchip->wave.reg = reg;\r\nreg = ad1889_readw(chip, AD_DMA_WAV);\r\nreg &= AD_DMA_IM_DIS;\r\nreg &= ~AD_DMA_LOOP;\r\nad1889_writew(chip, AD_DMA_WAV, reg);\r\nad1889_load_wave_buffer_address(chip, 0x0);\r\nad1889_load_wave_buffer_count(chip, 0x0);\r\nad1889_load_wave_interrupt_count(chip, 0x0);\r\nad1889_readw(chip, AD_DMA_WAV);\r\n}\r\nif (channel & AD_CHAN_ADC) {\r\nreg = ad1889_readw(chip, AD_DS_RAMC) & ~AD_DS_RAMC_ADEN;\r\nad1889_writew(chip, AD_DS_RAMC, reg);\r\nchip->ramc.reg = reg;\r\nreg = ad1889_readw(chip, AD_DMA_ADC);\r\nreg &= AD_DMA_IM_DIS;\r\nreg &= ~AD_DMA_LOOP;\r\nad1889_writew(chip, AD_DMA_ADC, reg);\r\nad1889_load_adc_buffer_address(chip, 0x0);\r\nad1889_load_adc_buffer_count(chip, 0x0);\r\nad1889_load_adc_interrupt_count(chip, 0x0);\r\nad1889_readw(chip, AD_DMA_ADC);\r\n}\r\n}\r\nstatic u16\r\nsnd_ad1889_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nstruct snd_ad1889 *chip = ac97->private_data;\r\nreturn ad1889_readw(chip, AD_AC97_BASE + reg);\r\n}\r\nstatic void\r\nsnd_ad1889_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)\r\n{\r\nstruct snd_ad1889 *chip = ac97->private_data;\r\nad1889_writew(chip, AD_AC97_BASE + reg, val);\r\n}\r\nstatic int\r\nsnd_ad1889_ac97_ready(struct snd_ad1889 *chip)\r\n{\r\nint retry = 400;\r\nwhile (!(ad1889_readw(chip, AD_AC97_ACIC) & AD_AC97_ACIC_ACRDY)\r\n&& --retry)\r\nmdelay(1);\r\nif (!retry) {\r\nsnd_printk(KERN_ERR PFX "[%s] Link is not ready.\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\nad1889_debug("[%s] ready after %d ms\n", __func__, 400 - retry);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_ad1889_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int\r\nsnd_ad1889_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int\r\nsnd_ad1889_playback_open(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\r\nstruct snd_pcm_runtime *rt = ss->runtime;\r\nchip->psubs = ss;\r\nrt->hw = snd_ad1889_playback_hw;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_ad1889_capture_open(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\r\nstruct snd_pcm_runtime *rt = ss->runtime;\r\nchip->csubs = ss;\r\nrt->hw = snd_ad1889_capture_hw;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_ad1889_playback_close(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\r\nchip->psubs = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_ad1889_capture_close(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\r\nchip->csubs = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_ad1889_playback_prepare(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\r\nstruct snd_pcm_runtime *rt = ss->runtime;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(ss);\r\nunsigned int count = snd_pcm_lib_period_bytes(ss);\r\nu16 reg;\r\nad1889_channel_reset(chip, AD_CHAN_WAV);\r\nreg = ad1889_readw(chip, AD_DS_WSMC);\r\nreg &= ~(AD_DS_WSMC_WA16 | AD_DS_WSMC_WAST);\r\nif (snd_pcm_format_width(rt->format) == 16)\r\nreg |= AD_DS_WSMC_WA16;\r\nif (rt->channels > 1)\r\nreg |= AD_DS_WSMC_WAST;\r\nspin_lock_irq(&chip->lock);\r\nchip->wave.size = size;\r\nchip->wave.reg = reg;\r\nchip->wave.addr = rt->dma_addr;\r\nad1889_writew(chip, AD_DS_WSMC, chip->wave.reg);\r\nad1889_writew(chip, AD_DS_WAS, rt->rate);\r\nad1889_load_wave_buffer_address(chip, chip->wave.addr);\r\nad1889_load_wave_buffer_count(chip, size);\r\nad1889_load_wave_interrupt_count(chip, count);\r\nad1889_readw(chip, AD_DS_WSMC);\r\nspin_unlock_irq(&chip->lock);\r\nad1889_debug("prepare playback: addr = 0x%x, count = %u, "\r\n"size = %u, reg = 0x%x, rate = %u\n", chip->wave.addr,\r\ncount, size, reg, rt->rate);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_ad1889_capture_prepare(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\r\nstruct snd_pcm_runtime *rt = ss->runtime;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(ss);\r\nunsigned int count = snd_pcm_lib_period_bytes(ss);\r\nu16 reg;\r\nad1889_channel_reset(chip, AD_CHAN_ADC);\r\nreg = ad1889_readw(chip, AD_DS_RAMC);\r\nreg &= ~(AD_DS_RAMC_AD16 | AD_DS_RAMC_ADST);\r\nif (snd_pcm_format_width(rt->format) == 16)\r\nreg |= AD_DS_RAMC_AD16;\r\nif (rt->channels > 1)\r\nreg |= AD_DS_RAMC_ADST;\r\nspin_lock_irq(&chip->lock);\r\nchip->ramc.size = size;\r\nchip->ramc.reg = reg;\r\nchip->ramc.addr = rt->dma_addr;\r\nad1889_writew(chip, AD_DS_RAMC, chip->ramc.reg);\r\nad1889_load_adc_buffer_address(chip, chip->ramc.addr);\r\nad1889_load_adc_buffer_count(chip, size);\r\nad1889_load_adc_interrupt_count(chip, count);\r\nad1889_readw(chip, AD_DS_RAMC);\r\nspin_unlock_irq(&chip->lock);\r\nad1889_debug("prepare capture: addr = 0x%x, count = %u, "\r\n"size = %u, reg = 0x%x, rate = %u\n", chip->ramc.addr,\r\ncount, size, reg, rt->rate);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_ad1889_playback_trigger(struct snd_pcm_substream *ss, int cmd)\r\n{\r\nu16 wsmc;\r\nstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\r\nwsmc = ad1889_readw(chip, AD_DS_WSMC);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nad1889_writew(chip, AD_DMA_WAV, AD_DMA_LOOP | AD_DMA_IM_CNT);\r\nwsmc |= AD_DS_WSMC_WAEN;\r\nad1889_writel(chip, AD_DMA_CHSS, AD_DMA_CHSS_WAVS);\r\nad1889_unmute(chip);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nad1889_mute(chip);\r\nwsmc &= ~AD_DS_WSMC_WAEN;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nchip->wave.reg = wsmc;\r\nad1889_writew(chip, AD_DS_WSMC, wsmc);\r\nad1889_readw(chip, AD_DS_WSMC);\r\nif (cmd == SNDRV_PCM_TRIGGER_STOP)\r\nad1889_channel_reset(chip, AD_CHAN_WAV);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_ad1889_capture_trigger(struct snd_pcm_substream *ss, int cmd)\r\n{\r\nu16 ramc;\r\nstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\r\nramc = ad1889_readw(chip, AD_DS_RAMC);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nad1889_writew(chip, AD_DMA_ADC, AD_DMA_LOOP | AD_DMA_IM_CNT);\r\nramc |= AD_DS_RAMC_ADEN;\r\nad1889_writel(chip, AD_DMA_CHSS, AD_DMA_CHSS_ADCS);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nramc &= ~AD_DS_RAMC_ADEN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nchip->ramc.reg = ramc;\r\nad1889_writew(chip, AD_DS_RAMC, ramc);\r\nad1889_readw(chip, AD_DS_RAMC);\r\nif (cmd == SNDRV_PCM_TRIGGER_STOP)\r\nad1889_channel_reset(chip, AD_CHAN_ADC);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_ad1889_playback_pointer(struct snd_pcm_substream *ss)\r\n{\r\nsize_t ptr = 0;\r\nstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\r\nif (unlikely(!(chip->wave.reg & AD_DS_WSMC_WAEN)))\r\nreturn 0;\r\nptr = ad1889_readl(chip, AD_DMA_WAVCA);\r\nptr -= chip->wave.addr;\r\nif (snd_BUG_ON(ptr >= chip->wave.size))\r\nreturn 0;\r\nreturn bytes_to_frames(ss->runtime, ptr);\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_ad1889_capture_pointer(struct snd_pcm_substream *ss)\r\n{\r\nsize_t ptr = 0;\r\nstruct snd_ad1889 *chip = snd_pcm_substream_chip(ss);\r\nif (unlikely(!(chip->ramc.reg & AD_DS_RAMC_ADEN)))\r\nreturn 0;\r\nptr = ad1889_readl(chip, AD_DMA_ADCCA);\r\nptr -= chip->ramc.addr;\r\nif (snd_BUG_ON(ptr >= chip->ramc.size))\r\nreturn 0;\r\nreturn bytes_to_frames(ss->runtime, ptr);\r\n}\r\nstatic irqreturn_t\r\nsnd_ad1889_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned long st;\r\nstruct snd_ad1889 *chip = dev_id;\r\nst = ad1889_readl(chip, AD_DMA_DISR);\r\nad1889_writel(chip, AD_DMA_DISR, st);\r\nst &= AD_INTR_MASK;\r\nif (unlikely(!st))\r\nreturn IRQ_NONE;\r\nif (st & (AD_DMA_DISR_PMAI|AD_DMA_DISR_PTAI))\r\nad1889_debug("Unexpected master or target abort interrupt!\n");\r\nif ((st & AD_DMA_DISR_WAVI) && chip->psubs)\r\nsnd_pcm_period_elapsed(chip->psubs);\r\nif ((st & AD_DMA_DISR_ADCI) && chip->csubs)\r\nsnd_pcm_period_elapsed(chip->csubs);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit\r\nsnd_ad1889_pcm_init(struct snd_ad1889 *chip, int device, struct snd_pcm **rpcm)\r\n{\r\nint err;\r\nstruct snd_pcm *pcm;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nerr = snd_pcm_new(chip->card, chip->card->driver, device, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_ad1889_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_ad1889_capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcm = pcm;\r\nchip->psubs = NULL;\r\nchip->csubs = NULL;\r\nerr = snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nBUFFER_BYTES_MAX / 2,\r\nBUFFER_BYTES_MAX);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR PFX "buffer allocation error: %d\n", err);\r\nreturn err;\r\n}\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_ad1889_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\r\n{\r\nstruct snd_ad1889 *chip = entry->private_data;\r\nu16 reg;\r\nint tmp;\r\nreg = ad1889_readw(chip, AD_DS_WSMC);\r\nsnd_iprintf(buffer, "Wave output: %s\n",\r\n(reg & AD_DS_WSMC_WAEN) ? "enabled" : "disabled");\r\nsnd_iprintf(buffer, "Wave Channels: %s\n",\r\n(reg & AD_DS_WSMC_WAST) ? "stereo" : "mono");\r\nsnd_iprintf(buffer, "Wave Quality: %d-bit linear\n",\r\n(reg & AD_DS_WSMC_WA16) ? 16 : 8);\r\ntmp = (reg & AD_DS_WSMC_WARQ) ?\r\n(((reg & AD_DS_WSMC_WARQ >> 12) & 0x01) ? 12 : 18) : 4;\r\ntmp /= (reg & AD_DS_WSMC_WAST) ? 2 : 1;\r\nsnd_iprintf(buffer, "Wave FIFO: %d %s words\n\n", tmp,\r\n(reg & AD_DS_WSMC_WAST) ? "stereo" : "mono");\r\nsnd_iprintf(buffer, "Synthesis output: %s\n",\r\nreg & AD_DS_WSMC_SYEN ? "enabled" : "disabled");\r\ntmp = (reg & AD_DS_WSMC_SYRQ) ?\r\n(((reg & AD_DS_WSMC_SYRQ >> 4) & 0x01) ? 12 : 18) : 4;\r\ntmp /= (reg & AD_DS_WSMC_WAST) ? 2 : 1;\r\nsnd_iprintf(buffer, "Synthesis FIFO: %d %s words\n\n", tmp,\r\n(reg & AD_DS_WSMC_WAST) ? "stereo" : "mono");\r\nreg = ad1889_readw(chip, AD_DS_RAMC);\r\nsnd_iprintf(buffer, "ADC input: %s\n",\r\n(reg & AD_DS_RAMC_ADEN) ? "enabled" : "disabled");\r\nsnd_iprintf(buffer, "ADC Channels: %s\n",\r\n(reg & AD_DS_RAMC_ADST) ? "stereo" : "mono");\r\nsnd_iprintf(buffer, "ADC Quality: %d-bit linear\n",\r\n(reg & AD_DS_RAMC_AD16) ? 16 : 8);\r\ntmp = (reg & AD_DS_RAMC_ACRQ) ?\r\n(((reg & AD_DS_RAMC_ACRQ >> 4) & 0x01) ? 12 : 18) : 4;\r\ntmp /= (reg & AD_DS_RAMC_ADST) ? 2 : 1;\r\nsnd_iprintf(buffer, "ADC FIFO: %d %s words\n\n", tmp,\r\n(reg & AD_DS_RAMC_ADST) ? "stereo" : "mono");\r\nsnd_iprintf(buffer, "Resampler input: %s\n",\r\nreg & AD_DS_RAMC_REEN ? "enabled" : "disabled");\r\ntmp = (reg & AD_DS_RAMC_RERQ) ?\r\n(((reg & AD_DS_RAMC_RERQ >> 12) & 0x01) ? 12 : 18) : 4;\r\ntmp /= (reg & AD_DS_RAMC_ADST) ? 2 : 1;\r\nsnd_iprintf(buffer, "Resampler FIFO: %d %s words\n\n", tmp,\r\n(reg & AD_DS_WSMC_WAST) ? "stereo" : "mono");\r\nreg = ad1889_readw(chip, AD_DS_WADA);\r\nsnd_iprintf(buffer, "Left: %s, -%d dB\n",\r\n(reg & AD_DS_WADA_LWAM) ? "mute" : "unmute",\r\n((reg & AD_DS_WADA_LWAA) >> 8) * 3);\r\nreg = ad1889_readw(chip, AD_DS_WADA);\r\nsnd_iprintf(buffer, "Right: %s, -%d dB\n",\r\n(reg & AD_DS_WADA_RWAM) ? "mute" : "unmute",\r\n((reg & AD_DS_WADA_RWAA) >> 8) * 3);\r\nreg = ad1889_readw(chip, AD_DS_WAS);\r\nsnd_iprintf(buffer, "Wave samplerate: %u Hz\n", reg);\r\nreg = ad1889_readw(chip, AD_DS_RES);\r\nsnd_iprintf(buffer, "Resampler samplerate: %u Hz\n", reg);\r\n}\r\nstatic void __devinit\r\nsnd_ad1889_proc_init(struct snd_ad1889 *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(chip->card, chip->card->driver, &entry))\r\nsnd_info_set_text_ops(entry, chip, snd_ad1889_proc_read);\r\n}\r\nstatic void __devinit\r\nsnd_ad1889_ac97_xinit(struct snd_ad1889 *chip)\r\n{\r\nu16 reg;\r\nreg = ad1889_readw(chip, AD_AC97_ACIC);\r\nreg |= AD_AC97_ACIC_ACRD;\r\nad1889_writew(chip, AD_AC97_ACIC, reg);\r\nad1889_readw(chip, AD_AC97_ACIC);\r\nudelay(10);\r\nreg |= AD_AC97_ACIC_ACIE;\r\nad1889_writew(chip, AD_AC97_ACIC, reg);\r\nsnd_ad1889_ac97_ready(chip);\r\nreg = ad1889_readw(chip, AD_AC97_ACIC);\r\nreg |= AD_AC97_ACIC_ASOE | AD_AC97_ACIC_VSRM;\r\nad1889_writew(chip, AD_AC97_ACIC, reg);\r\nad1889_readw(chip, AD_AC97_ACIC);\r\n}\r\nstatic void\r\nsnd_ad1889_ac97_bus_free(struct snd_ac97_bus *bus)\r\n{\r\nstruct snd_ad1889 *chip = bus->private_data;\r\nchip->ac97_bus = NULL;\r\n}\r\nstatic void\r\nsnd_ad1889_ac97_free(struct snd_ac97 *ac97)\r\n{\r\nstruct snd_ad1889 *chip = ac97->private_data;\r\nchip->ac97 = NULL;\r\n}\r\nstatic int __devinit\r\nsnd_ad1889_ac97_init(struct snd_ad1889 *chip, const char *quirk_override)\r\n{\r\nint err;\r\nstruct snd_ac97_template ac97;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_ad1889_ac97_write,\r\n.read = snd_ad1889_ac97_read,\r\n};\r\nsnd_ad1889_ac97_xinit(chip);\r\nerr = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus);\r\nif (err < 0)\r\nreturn err;\r\nchip->ac97_bus->private_free = snd_ad1889_ac97_bus_free;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nac97.private_free = snd_ad1889_ac97_free;\r\nac97.pci = chip->pci;\r\nerr = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97);\r\nif (err < 0)\r\nreturn err;\r\nsnd_ac97_tune_hardware(chip->ac97, ac97_quirks, quirk_override);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_ad1889_free(struct snd_ad1889 *chip)\r\n{\r\nif (chip->irq < 0)\r\ngoto skip_hw;\r\nspin_lock_irq(&chip->lock);\r\nad1889_mute(chip);\r\nad1889_channel_reset(chip, AD_CHAN_WAV | AD_CHAN_ADC);\r\nad1889_writel(chip, AD_DMA_DISR, AD_DMA_DISR_PTAI | AD_DMA_DISR_PMAI);\r\nad1889_readl(chip, AD_DMA_DISR);\r\nspin_unlock_irq(&chip->lock);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\nskip_hw:\r\nif (chip->iobase)\r\niounmap(chip->iobase);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_ad1889_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_ad1889 *chip = device->device_data;\r\nreturn snd_ad1889_free(chip);\r\n}\r\nstatic int __devinit\r\nsnd_ad1889_init(struct snd_ad1889 *chip)\r\n{\r\nad1889_writew(chip, AD_DS_CCS, AD_DS_CCS_CLKEN);\r\nad1889_readw(chip, AD_DS_CCS);\r\nmdelay(10);\r\nad1889_writel(chip, AD_DMA_DISR, AD_DMA_DISR_PMAE | AD_DMA_DISR_PTAE);\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\nsnd_ad1889_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nstruct snd_ad1889 **rchip)\r\n{\r\nint err;\r\nstruct snd_ad1889 *chip;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_ad1889_dev_free,\r\n};\r\n*rchip = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(32)) < 0 ||\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(32)) < 0) {\r\nprintk(KERN_ERR PFX "error setting 32-bit DMA mask.\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\nif ((chip = kzalloc(sizeof(*chip), GFP_KERNEL)) == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nchip->card = card;\r\ncard->private_data = chip;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nif ((err = pci_request_regions(pci, card->driver)) < 0)\r\ngoto free_and_ret;\r\nchip->bar = pci_resource_start(pci, 0);\r\nchip->iobase = pci_ioremap_bar(pci, 0);\r\nif (chip->iobase == NULL) {\r\nprintk(KERN_ERR PFX "unable to reserve region.\n");\r\nerr = -EBUSY;\r\ngoto free_and_ret;\r\n}\r\npci_set_master(pci);\r\nspin_lock_init(&chip->lock);\r\nif (request_irq(pci->irq, snd_ad1889_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME, chip)) {\r\nprintk(KERN_ERR PFX "cannot obtain IRQ %d\n", pci->irq);\r\nsnd_ad1889_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\nsynchronize_irq(chip->irq);\r\nif ((err = snd_ad1889_init(chip)) < 0) {\r\nsnd_ad1889_free(chip);\r\nreturn err;\r\n}\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_ad1889_free(chip);\r\nreturn err;\r\n}\r\nsnd_card_set_dev(card, &pci->dev);\r\n*rchip = chip;\r\nreturn 0;\r\nfree_and_ret:\r\nkfree(chip);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nstatic int __devinit\r\nsnd_ad1889_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nint err;\r\nstatic int devno;\r\nstruct snd_card *card;\r\nstruct snd_ad1889 *chip;\r\nif (devno >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[devno]) {\r\ndevno++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[devno], id[devno], THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nstrcpy(card->driver, "AD1889");\r\nstrcpy(card->shortname, "Analog Devices AD1889");\r\nerr = snd_ad1889_create(card, pci, &chip);\r\nif (err < 0)\r\ngoto free_and_ret;\r\nsprintf(card->longname, "%s at 0x%lx irq %i",\r\ncard->shortname, chip->bar, chip->irq);\r\nerr = snd_ad1889_ac97_init(chip, ac97_quirk[devno]);\r\nif (err < 0)\r\ngoto free_and_ret;\r\nerr = snd_ad1889_pcm_init(chip, 0, NULL);\r\nif (err < 0)\r\ngoto free_and_ret;\r\nsnd_ad1889_proc_init(chip);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto free_and_ret;\r\npci_set_drvdata(pci, card);\r\ndevno++;\r\nreturn 0;\r\nfree_and_ret:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void __devexit\r\nsnd_ad1889_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}
