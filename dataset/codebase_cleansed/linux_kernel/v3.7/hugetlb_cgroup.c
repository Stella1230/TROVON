static inline\r\nstruct hugetlb_cgroup *hugetlb_cgroup_from_css(struct cgroup_subsys_state *s)\r\n{\r\nreturn container_of(s, struct hugetlb_cgroup, css);\r\n}\r\nstatic inline\r\nstruct hugetlb_cgroup *hugetlb_cgroup_from_cgroup(struct cgroup *cgroup)\r\n{\r\nreturn hugetlb_cgroup_from_css(cgroup_subsys_state(cgroup,\r\nhugetlb_subsys_id));\r\n}\r\nstatic inline\r\nstruct hugetlb_cgroup *hugetlb_cgroup_from_task(struct task_struct *task)\r\n{\r\nreturn hugetlb_cgroup_from_css(task_subsys_state(task,\r\nhugetlb_subsys_id));\r\n}\r\nstatic inline bool hugetlb_cgroup_is_root(struct hugetlb_cgroup *h_cg)\r\n{\r\nreturn (h_cg == root_h_cgroup);\r\n}\r\nstatic inline struct hugetlb_cgroup *parent_hugetlb_cgroup(struct cgroup *cg)\r\n{\r\nif (!cg->parent)\r\nreturn NULL;\r\nreturn hugetlb_cgroup_from_cgroup(cg->parent);\r\n}\r\nstatic inline bool hugetlb_cgroup_have_usage(struct cgroup *cg)\r\n{\r\nint idx;\r\nstruct hugetlb_cgroup *h_cg = hugetlb_cgroup_from_cgroup(cg);\r\nfor (idx = 0; idx < hugetlb_max_hstate; idx++) {\r\nif ((res_counter_read_u64(&h_cg->hugepage[idx], RES_USAGE)) > 0)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic struct cgroup_subsys_state *hugetlb_cgroup_create(struct cgroup *cgroup)\r\n{\r\nint idx;\r\nstruct cgroup *parent_cgroup;\r\nstruct hugetlb_cgroup *h_cgroup, *parent_h_cgroup;\r\nh_cgroup = kzalloc(sizeof(*h_cgroup), GFP_KERNEL);\r\nif (!h_cgroup)\r\nreturn ERR_PTR(-ENOMEM);\r\nparent_cgroup = cgroup->parent;\r\nif (parent_cgroup) {\r\nparent_h_cgroup = hugetlb_cgroup_from_cgroup(parent_cgroup);\r\nfor (idx = 0; idx < HUGE_MAX_HSTATE; idx++)\r\nres_counter_init(&h_cgroup->hugepage[idx],\r\n&parent_h_cgroup->hugepage[idx]);\r\n} else {\r\nroot_h_cgroup = h_cgroup;\r\nfor (idx = 0; idx < HUGE_MAX_HSTATE; idx++)\r\nres_counter_init(&h_cgroup->hugepage[idx], NULL);\r\n}\r\nreturn &h_cgroup->css;\r\n}\r\nstatic void hugetlb_cgroup_destroy(struct cgroup *cgroup)\r\n{\r\nstruct hugetlb_cgroup *h_cgroup;\r\nh_cgroup = hugetlb_cgroup_from_cgroup(cgroup);\r\nkfree(h_cgroup);\r\n}\r\nstatic void hugetlb_cgroup_move_parent(int idx, struct cgroup *cgroup,\r\nstruct page *page)\r\n{\r\nint csize;\r\nstruct res_counter *counter;\r\nstruct res_counter *fail_res;\r\nstruct hugetlb_cgroup *page_hcg;\r\nstruct hugetlb_cgroup *h_cg = hugetlb_cgroup_from_cgroup(cgroup);\r\nstruct hugetlb_cgroup *parent = parent_hugetlb_cgroup(cgroup);\r\npage_hcg = hugetlb_cgroup_from_page(page);\r\nif (!page_hcg || page_hcg != h_cg)\r\ngoto out;\r\ncsize = PAGE_SIZE << compound_order(page);\r\nif (!parent) {\r\nparent = root_h_cgroup;\r\nres_counter_charge_nofail(&parent->hugepage[idx],\r\ncsize, &fail_res);\r\n}\r\ncounter = &h_cg->hugepage[idx];\r\nres_counter_uncharge_until(counter, counter->parent, csize);\r\nset_hugetlb_cgroup(page, parent);\r\nout:\r\nreturn;\r\n}\r\nstatic int hugetlb_cgroup_pre_destroy(struct cgroup *cgroup)\r\n{\r\nstruct hstate *h;\r\nstruct page *page;\r\nint ret = 0, idx = 0;\r\ndo {\r\nif (cgroup_task_count(cgroup) ||\r\n!list_empty(&cgroup->children)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nfor_each_hstate(h) {\r\nspin_lock(&hugetlb_lock);\r\nlist_for_each_entry(page, &h->hugepage_activelist, lru)\r\nhugetlb_cgroup_move_parent(idx, cgroup, page);\r\nspin_unlock(&hugetlb_lock);\r\nidx++;\r\n}\r\ncond_resched();\r\n} while (hugetlb_cgroup_have_usage(cgroup));\r\nout:\r\nreturn ret;\r\n}\r\nint hugetlb_cgroup_charge_cgroup(int idx, unsigned long nr_pages,\r\nstruct hugetlb_cgroup **ptr)\r\n{\r\nint ret = 0;\r\nstruct res_counter *fail_res;\r\nstruct hugetlb_cgroup *h_cg = NULL;\r\nunsigned long csize = nr_pages * PAGE_SIZE;\r\nif (hugetlb_cgroup_disabled())\r\ngoto done;\r\nif (huge_page_order(&hstates[idx]) < HUGETLB_CGROUP_MIN_ORDER)\r\ngoto done;\r\nagain:\r\nrcu_read_lock();\r\nh_cg = hugetlb_cgroup_from_task(current);\r\nif (!css_tryget(&h_cg->css)) {\r\nrcu_read_unlock();\r\ngoto again;\r\n}\r\nrcu_read_unlock();\r\nret = res_counter_charge(&h_cg->hugepage[idx], csize, &fail_res);\r\ncss_put(&h_cg->css);\r\ndone:\r\n*ptr = h_cg;\r\nreturn ret;\r\n}\r\nvoid hugetlb_cgroup_commit_charge(int idx, unsigned long nr_pages,\r\nstruct hugetlb_cgroup *h_cg,\r\nstruct page *page)\r\n{\r\nif (hugetlb_cgroup_disabled() || !h_cg)\r\nreturn;\r\nset_hugetlb_cgroup(page, h_cg);\r\nreturn;\r\n}\r\nvoid hugetlb_cgroup_uncharge_page(int idx, unsigned long nr_pages,\r\nstruct page *page)\r\n{\r\nstruct hugetlb_cgroup *h_cg;\r\nunsigned long csize = nr_pages * PAGE_SIZE;\r\nif (hugetlb_cgroup_disabled())\r\nreturn;\r\nVM_BUG_ON(!spin_is_locked(&hugetlb_lock));\r\nh_cg = hugetlb_cgroup_from_page(page);\r\nif (unlikely(!h_cg))\r\nreturn;\r\nset_hugetlb_cgroup(page, NULL);\r\nres_counter_uncharge(&h_cg->hugepage[idx], csize);\r\nreturn;\r\n}\r\nvoid hugetlb_cgroup_uncharge_cgroup(int idx, unsigned long nr_pages,\r\nstruct hugetlb_cgroup *h_cg)\r\n{\r\nunsigned long csize = nr_pages * PAGE_SIZE;\r\nif (hugetlb_cgroup_disabled() || !h_cg)\r\nreturn;\r\nif (huge_page_order(&hstates[idx]) < HUGETLB_CGROUP_MIN_ORDER)\r\nreturn;\r\nres_counter_uncharge(&h_cg->hugepage[idx], csize);\r\nreturn;\r\n}\r\nstatic ssize_t hugetlb_cgroup_read(struct cgroup *cgroup, struct cftype *cft,\r\nstruct file *file, char __user *buf,\r\nsize_t nbytes, loff_t *ppos)\r\n{\r\nu64 val;\r\nchar str[64];\r\nint idx, name, len;\r\nstruct hugetlb_cgroup *h_cg = hugetlb_cgroup_from_cgroup(cgroup);\r\nidx = MEMFILE_IDX(cft->private);\r\nname = MEMFILE_ATTR(cft->private);\r\nval = res_counter_read_u64(&h_cg->hugepage[idx], name);\r\nlen = scnprintf(str, sizeof(str), "%llu\n", (unsigned long long)val);\r\nreturn simple_read_from_buffer(buf, nbytes, ppos, str, len);\r\n}\r\nstatic int hugetlb_cgroup_write(struct cgroup *cgroup, struct cftype *cft,\r\nconst char *buffer)\r\n{\r\nint idx, name, ret;\r\nunsigned long long val;\r\nstruct hugetlb_cgroup *h_cg = hugetlb_cgroup_from_cgroup(cgroup);\r\nidx = MEMFILE_IDX(cft->private);\r\nname = MEMFILE_ATTR(cft->private);\r\nswitch (name) {\r\ncase RES_LIMIT:\r\nif (hugetlb_cgroup_is_root(h_cg)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = res_counter_memparse_write_strategy(buffer, &val);\r\nif (ret)\r\nbreak;\r\nret = res_counter_set_limit(&h_cg->hugepage[idx], val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int hugetlb_cgroup_reset(struct cgroup *cgroup, unsigned int event)\r\n{\r\nint idx, name, ret = 0;\r\nstruct hugetlb_cgroup *h_cg = hugetlb_cgroup_from_cgroup(cgroup);\r\nidx = MEMFILE_IDX(event);\r\nname = MEMFILE_ATTR(event);\r\nswitch (name) {\r\ncase RES_MAX_USAGE:\r\nres_counter_reset_max(&h_cg->hugepage[idx]);\r\nbreak;\r\ncase RES_FAILCNT:\r\nres_counter_reset_failcnt(&h_cg->hugepage[idx]);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic char *mem_fmt(char *buf, int size, unsigned long hsize)\r\n{\r\nif (hsize >= (1UL << 30))\r\nsnprintf(buf, size, "%luGB", hsize >> 30);\r\nelse if (hsize >= (1UL << 20))\r\nsnprintf(buf, size, "%luMB", hsize >> 20);\r\nelse\r\nsnprintf(buf, size, "%luKB", hsize >> 10);\r\nreturn buf;\r\n}\r\nint __init hugetlb_cgroup_file_init(int idx)\r\n{\r\nchar buf[32];\r\nstruct cftype *cft;\r\nstruct hstate *h = &hstates[idx];\r\nmem_fmt(buf, 32, huge_page_size(h));\r\ncft = &h->cgroup_files[0];\r\nsnprintf(cft->name, MAX_CFTYPE_NAME, "%s.limit_in_bytes", buf);\r\ncft->private = MEMFILE_PRIVATE(idx, RES_LIMIT);\r\ncft->read = hugetlb_cgroup_read;\r\ncft->write_string = hugetlb_cgroup_write;\r\ncft = &h->cgroup_files[1];\r\nsnprintf(cft->name, MAX_CFTYPE_NAME, "%s.usage_in_bytes", buf);\r\ncft->private = MEMFILE_PRIVATE(idx, RES_USAGE);\r\ncft->read = hugetlb_cgroup_read;\r\ncft = &h->cgroup_files[2];\r\nsnprintf(cft->name, MAX_CFTYPE_NAME, "%s.max_usage_in_bytes", buf);\r\ncft->private = MEMFILE_PRIVATE(idx, RES_MAX_USAGE);\r\ncft->trigger = hugetlb_cgroup_reset;\r\ncft->read = hugetlb_cgroup_read;\r\ncft = &h->cgroup_files[3];\r\nsnprintf(cft->name, MAX_CFTYPE_NAME, "%s.failcnt", buf);\r\ncft->private = MEMFILE_PRIVATE(idx, RES_FAILCNT);\r\ncft->trigger = hugetlb_cgroup_reset;\r\ncft->read = hugetlb_cgroup_read;\r\ncft = &h->cgroup_files[4];\r\nmemset(cft, 0, sizeof(*cft));\r\nWARN_ON(cgroup_add_cftypes(&hugetlb_subsys, h->cgroup_files));\r\nreturn 0;\r\n}\r\nvoid hugetlb_cgroup_migrate(struct page *oldhpage, struct page *newhpage)\r\n{\r\nstruct hugetlb_cgroup *h_cg;\r\nstruct hstate *h = page_hstate(oldhpage);\r\nif (hugetlb_cgroup_disabled())\r\nreturn;\r\nVM_BUG_ON(!PageHuge(oldhpage));\r\nspin_lock(&hugetlb_lock);\r\nh_cg = hugetlb_cgroup_from_page(oldhpage);\r\nset_hugetlb_cgroup(oldhpage, NULL);\r\nset_hugetlb_cgroup(newhpage, h_cg);\r\nlist_move(&newhpage->lru, &h->hugepage_activelist);\r\nspin_unlock(&hugetlb_lock);\r\nreturn;\r\n}
