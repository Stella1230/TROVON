static inline void pch_can_bit_set(void __iomem *addr, u32 mask)\r\n{\r\niowrite32(ioread32(addr) | mask, addr);\r\n}\r\nstatic inline void pch_can_bit_clear(void __iomem *addr, u32 mask)\r\n{\r\niowrite32(ioread32(addr) & ~mask, addr);\r\n}\r\nstatic void pch_can_set_run_mode(struct pch_can_priv *priv,\r\nenum pch_can_mode mode)\r\n{\r\nswitch (mode) {\r\ncase PCH_CAN_RUN:\r\npch_can_bit_clear(&priv->regs->cont, PCH_CTRL_INIT);\r\nbreak;\r\ncase PCH_CAN_STOP:\r\npch_can_bit_set(&priv->regs->cont, PCH_CTRL_INIT);\r\nbreak;\r\ndefault:\r\nnetdev_err(priv->ndev, "%s -> Invalid Mode.\n", __func__);\r\nbreak;\r\n}\r\n}\r\nstatic void pch_can_set_optmode(struct pch_can_priv *priv)\r\n{\r\nu32 reg_val = ioread32(&priv->regs->opt);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\nreg_val |= PCH_OPT_SILENT;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\r\nreg_val |= PCH_OPT_LBACK;\r\npch_can_bit_set(&priv->regs->cont, PCH_CTRL_OPT);\r\niowrite32(reg_val, &priv->regs->opt);\r\n}\r\nstatic void pch_can_rw_msg_obj(void __iomem *creq_addr, u32 num)\r\n{\r\nint counter = PCH_COUNTER_LIMIT;\r\nu32 ifx_creq;\r\niowrite32(num, creq_addr);\r\nwhile (counter) {\r\nifx_creq = ioread32(creq_addr) & PCH_IF_CREQ_BUSY;\r\nif (!ifx_creq)\r\nbreak;\r\ncounter--;\r\nudelay(1);\r\n}\r\nif (!counter)\r\npr_err("%s:IF1 BUSY Flag is set forever.\n", __func__);\r\n}\r\nstatic void pch_can_set_int_enables(struct pch_can_priv *priv,\r\nenum pch_can_mode interrupt_no)\r\n{\r\nswitch (interrupt_no) {\r\ncase PCH_CAN_DISABLE:\r\npch_can_bit_clear(&priv->regs->cont, PCH_CTRL_IE);\r\nbreak;\r\ncase PCH_CAN_ALL:\r\npch_can_bit_set(&priv->regs->cont, PCH_CTRL_IE_SIE_EIE);\r\nbreak;\r\ncase PCH_CAN_NONE:\r\npch_can_bit_clear(&priv->regs->cont, PCH_CTRL_IE_SIE_EIE);\r\nbreak;\r\ndefault:\r\nnetdev_err(priv->ndev, "Invalid interrupt number.\n");\r\nbreak;\r\n}\r\n}\r\nstatic void pch_can_set_rxtx(struct pch_can_priv *priv, u32 buff_num,\r\nint set, enum pch_ifreg dir)\r\n{\r\nu32 ie;\r\nif (dir)\r\nie = PCH_IF_MCONT_TXIE;\r\nelse\r\nie = PCH_IF_MCONT_RXIE;\r\niowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[dir].cmask);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[dir].creq, buff_num);\r\niowrite32(PCH_CMASK_RDWR | PCH_CMASK_ARB | PCH_CMASK_CTRL,\r\n&priv->regs->ifregs[dir].cmask);\r\nif (set) {\r\npch_can_bit_set(&priv->regs->ifregs[dir].mcont, ie);\r\npch_can_bit_set(&priv->regs->ifregs[dir].id2, PCH_ID_MSGVAL);\r\n} else {\r\npch_can_bit_clear(&priv->regs->ifregs[dir].mcont, ie);\r\npch_can_bit_clear(&priv->regs->ifregs[dir].id2, PCH_ID_MSGVAL);\r\n}\r\npch_can_rw_msg_obj(&priv->regs->ifregs[dir].creq, buff_num);\r\n}\r\nstatic void pch_can_set_rx_all(struct pch_can_priv *priv, int set)\r\n{\r\nint i;\r\nfor (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++)\r\npch_can_set_rxtx(priv, i, set, PCH_RX_IFREG);\r\n}\r\nstatic void pch_can_set_tx_all(struct pch_can_priv *priv, int set)\r\n{\r\nint i;\r\nfor (i = PCH_TX_OBJ_START; i <= PCH_TX_OBJ_END; i++)\r\npch_can_set_rxtx(priv, i, set, PCH_TX_IFREG);\r\n}\r\nstatic u32 pch_can_int_pending(struct pch_can_priv *priv)\r\n{\r\nreturn ioread32(&priv->regs->intr) & 0xffff;\r\n}\r\nstatic void pch_can_clear_if_buffers(struct pch_can_priv *priv)\r\n{\r\nint i;\r\nfor (i = PCH_RX_OBJ_START; i <= PCH_TX_OBJ_END; i++) {\r\niowrite32(PCH_CMASK_RX_TX_SET, &priv->regs->ifregs[0].cmask);\r\niowrite32(0xffff, &priv->regs->ifregs[0].mask1);\r\niowrite32(0xffff, &priv->regs->ifregs[0].mask2);\r\niowrite32(0x0, &priv->regs->ifregs[0].id1);\r\niowrite32(0x0, &priv->regs->ifregs[0].id2);\r\niowrite32(0x0, &priv->regs->ifregs[0].mcont);\r\niowrite32(0x0, &priv->regs->ifregs[0].data[0]);\r\niowrite32(0x0, &priv->regs->ifregs[0].data[1]);\r\niowrite32(0x0, &priv->regs->ifregs[0].data[2]);\r\niowrite32(0x0, &priv->regs->ifregs[0].data[3]);\r\niowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK |\r\nPCH_CMASK_ARB | PCH_CMASK_CTRL,\r\n&priv->regs->ifregs[0].cmask);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, i);\r\n}\r\n}\r\nstatic void pch_can_config_rx_tx_buffers(struct pch_can_priv *priv)\r\n{\r\nint i;\r\nfor (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {\r\niowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, i);\r\niowrite32(0x0, &priv->regs->ifregs[0].id1);\r\niowrite32(0x0, &priv->regs->ifregs[0].id2);\r\npch_can_bit_set(&priv->regs->ifregs[0].mcont,\r\nPCH_IF_MCONT_UMASK);\r\nif (i == PCH_RX_OBJ_END)\r\npch_can_bit_set(&priv->regs->ifregs[0].mcont,\r\nPCH_IF_MCONT_EOB);\r\nelse\r\npch_can_bit_clear(&priv->regs->ifregs[0].mcont,\r\nPCH_IF_MCONT_EOB);\r\niowrite32(0, &priv->regs->ifregs[0].mask1);\r\npch_can_bit_clear(&priv->regs->ifregs[0].mask2,\r\n0x1fff | PCH_MASK2_MDIR_MXTD);\r\niowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK | PCH_CMASK_ARB |\r\nPCH_CMASK_CTRL, &priv->regs->ifregs[0].cmask);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, i);\r\n}\r\nfor (i = PCH_TX_OBJ_START; i <= PCH_TX_OBJ_END; i++) {\r\niowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[1].cmask);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, i);\r\niowrite32(0x0, &priv->regs->ifregs[1].id1);\r\niowrite32(PCH_ID2_DIR, &priv->regs->ifregs[1].id2);\r\niowrite32(PCH_IF_MCONT_EOB | PCH_IF_MCONT_UMASK,\r\n&priv->regs->ifregs[1].mcont);\r\niowrite32(0, &priv->regs->ifregs[1].mask1);\r\npch_can_bit_clear(&priv->regs->ifregs[1].mask2, 0x1fff);\r\niowrite32(PCH_CMASK_RDWR | PCH_CMASK_MASK | PCH_CMASK_ARB |\r\nPCH_CMASK_CTRL, &priv->regs->ifregs[1].cmask);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, i);\r\n}\r\n}\r\nstatic void pch_can_init(struct pch_can_priv *priv)\r\n{\r\npch_can_set_run_mode(priv, PCH_CAN_STOP);\r\npch_can_clear_if_buffers(priv);\r\npch_can_config_rx_tx_buffers(priv);\r\npch_can_set_int_enables(priv, PCH_CAN_ALL);\r\n}\r\nstatic void pch_can_release(struct pch_can_priv *priv)\r\n{\r\npch_can_set_run_mode(priv, PCH_CAN_STOP);\r\npch_can_set_int_enables(priv, PCH_CAN_NONE);\r\npch_can_set_rx_all(priv, 0);\r\npch_can_set_tx_all(priv, 0);\r\n}\r\nstatic void pch_can_int_clr(struct pch_can_priv *priv, u32 mask)\r\n{\r\nif ((mask >= PCH_RX_OBJ_START) && (mask <= PCH_RX_OBJ_END)) {\r\niowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL | PCH_CMASK_ARB,\r\n&priv->regs->ifregs[0].cmask);\r\npch_can_bit_clear(&priv->regs->ifregs[0].id2, PCH_ID2_DIR);\r\npch_can_bit_clear(&priv->regs->ifregs[0].mcont,\r\nPCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, mask);\r\n} else if ((mask >= PCH_TX_OBJ_START) && (mask <= PCH_TX_OBJ_END)) {\r\niowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL | PCH_CMASK_ARB,\r\n&priv->regs->ifregs[1].cmask);\r\npch_can_bit_set(&priv->regs->ifregs[1].id2,\r\nPCH_ID2_DIR | (0x7ff << 2));\r\niowrite32(0x0, &priv->regs->ifregs[1].id1);\r\npch_can_bit_clear(&priv->regs->ifregs[1].mcont,\r\nPCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_INTPND |\r\nPCH_IF_MCONT_TXRQXT);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, mask);\r\n}\r\n}\r\nstatic void pch_can_reset(struct pch_can_priv *priv)\r\n{\r\niowrite32(1, &priv->regs->srst);\r\niowrite32(0, &priv->regs->srst);\r\n}\r\nstatic void pch_can_error(struct net_device *ndev, u32 status)\r\n{\r\nstruct sk_buff *skb;\r\nstruct pch_can_priv *priv = netdev_priv(ndev);\r\nstruct can_frame *cf;\r\nu32 errc, lec;\r\nstruct net_device_stats *stats = &(priv->ndev->stats);\r\nenum can_state state = priv->can.state;\r\nskb = alloc_can_err_skb(ndev, &cf);\r\nif (!skb)\r\nreturn;\r\nif (status & PCH_BUS_OFF) {\r\npch_can_set_tx_all(priv, 0);\r\npch_can_set_rx_all(priv, 0);\r\nstate = CAN_STATE_BUS_OFF;\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\ncan_bus_off(ndev);\r\n}\r\nerrc = ioread32(&priv->regs->errc);\r\nif (status & PCH_EWARN) {\r\nstate = CAN_STATE_ERROR_WARNING;\r\npriv->can.can_stats.error_warning++;\r\ncf->can_id |= CAN_ERR_CRTL;\r\nif (((errc & PCH_REC) >> 8) > 96)\r\ncf->data[1] |= CAN_ERR_CRTL_RX_WARNING;\r\nif ((errc & PCH_TEC) > 96)\r\ncf->data[1] |= CAN_ERR_CRTL_TX_WARNING;\r\nnetdev_dbg(ndev,\r\n"%s -> Error Counter is more than 96.\n", __func__);\r\n}\r\nif (status & PCH_EPASSIV) {\r\npriv->can.can_stats.error_passive++;\r\nstate = CAN_STATE_ERROR_PASSIVE;\r\ncf->can_id |= CAN_ERR_CRTL;\r\nif (errc & PCH_RP)\r\ncf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\r\nif ((errc & PCH_TEC) > 127)\r\ncf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;\r\nnetdev_dbg(ndev,\r\n"%s -> CAN controller is ERROR PASSIVE .\n", __func__);\r\n}\r\nlec = status & PCH_LEC_ALL;\r\nswitch (lec) {\r\ncase PCH_STUF_ERR:\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\nbreak;\r\ncase PCH_FORM_ERR:\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\nbreak;\r\ncase PCH_ACK_ERR:\r\ncf->can_id |= CAN_ERR_ACK;\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\nbreak;\r\ncase PCH_BIT1_ERR:\r\ncase PCH_BIT0_ERR:\r\ncf->data[2] |= CAN_ERR_PROT_BIT;\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\nbreak;\r\ncase PCH_CRC_ERR:\r\ncf->data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |\r\nCAN_ERR_PROT_LOC_CRC_DEL;\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\nbreak;\r\ncase PCH_LEC_ALL:\r\nbreak;\r\n}\r\ncf->data[6] = errc & PCH_TEC;\r\ncf->data[7] = (errc & PCH_REC) >> 8;\r\npriv->can.state = state;\r\nnetif_receive_skb(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\n}\r\nstatic irqreturn_t pch_can_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *ndev = (struct net_device *)dev_id;\r\nstruct pch_can_priv *priv = netdev_priv(ndev);\r\nif (!pch_can_int_pending(priv))\r\nreturn IRQ_NONE;\r\npch_can_set_int_enables(priv, PCH_CAN_NONE);\r\nnapi_schedule(&priv->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pch_fifo_thresh(struct pch_can_priv *priv, int obj_id)\r\n{\r\nif (obj_id < PCH_FIFO_THRESH) {\r\niowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL |\r\nPCH_CMASK_ARB, &priv->regs->ifregs[0].cmask);\r\npch_can_bit_clear(&priv->regs->ifregs[0].id2, PCH_ID2_DIR);\r\npch_can_bit_clear(&priv->regs->ifregs[0].mcont,\r\nPCH_IF_MCONT_INTPND);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, obj_id);\r\n} else if (obj_id > PCH_FIFO_THRESH) {\r\npch_can_int_clr(priv, obj_id);\r\n} else if (obj_id == PCH_FIFO_THRESH) {\r\nint cnt;\r\nfor (cnt = 0; cnt < PCH_FIFO_THRESH; cnt++)\r\npch_can_int_clr(priv, cnt + 1);\r\n}\r\n}\r\nstatic void pch_can_rx_msg_lost(struct net_device *ndev, int obj_id)\r\n{\r\nstruct pch_can_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &(priv->ndev->stats);\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nnetdev_dbg(priv->ndev, "Msg Obj is overwritten.\n");\r\npch_can_bit_clear(&priv->regs->ifregs[0].mcont,\r\nPCH_IF_MCONT_MSGLOST);\r\niowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL,\r\n&priv->regs->ifregs[0].cmask);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, obj_id);\r\nskb = alloc_can_err_skb(ndev, &cf);\r\nif (!skb)\r\nreturn;\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\nnetif_receive_skb(skb);\r\n}\r\nstatic int pch_can_rx_normal(struct net_device *ndev, u32 obj_num, int quota)\r\n{\r\nu32 reg;\r\ncanid_t id;\r\nint rcv_pkts = 0;\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nstruct pch_can_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &(priv->ndev->stats);\r\nint i;\r\nu32 id2;\r\nu16 data_reg;\r\ndo {\r\niowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, obj_num);\r\nreg = ioread32(&priv->regs->ifregs[0].mcont);\r\nif (reg & PCH_IF_MCONT_EOB)\r\nbreak;\r\nif (reg & PCH_IF_MCONT_MSGLOST) {\r\npch_can_rx_msg_lost(ndev, obj_num);\r\nrcv_pkts++;\r\nquota--;\r\nobj_num++;\r\ncontinue;\r\n} else if (!(reg & PCH_IF_MCONT_NEWDAT)) {\r\nobj_num++;\r\ncontinue;\r\n}\r\nskb = alloc_can_skb(priv->ndev, &cf);\r\nif (!skb) {\r\nnetdev_err(ndev, "alloc_can_skb Failed\n");\r\nreturn rcv_pkts;\r\n}\r\nid2 = ioread32(&priv->regs->ifregs[0].id2);\r\nif (id2 & PCH_ID2_XTD) {\r\nid = (ioread32(&priv->regs->ifregs[0].id1) & 0xffff);\r\nid |= (((id2) & 0x1fff) << 16);\r\ncf->can_id = id | CAN_EFF_FLAG;\r\n} else {\r\nid = (id2 >> 2) & CAN_SFF_MASK;\r\ncf->can_id = id;\r\n}\r\nif (id2 & PCH_ID2_DIR)\r\ncf->can_id |= CAN_RTR_FLAG;\r\ncf->can_dlc = get_can_dlc((ioread32(&priv->regs->\r\nifregs[0].mcont)) & 0xF);\r\nfor (i = 0; i < cf->can_dlc; i += 2) {\r\ndata_reg = ioread16(&priv->regs->ifregs[0].data[i / 2]);\r\ncf->data[i] = data_reg;\r\ncf->data[i + 1] = data_reg >> 8;\r\n}\r\nnetif_receive_skb(skb);\r\nrcv_pkts++;\r\nstats->rx_packets++;\r\nquota--;\r\nstats->rx_bytes += cf->can_dlc;\r\npch_fifo_thresh(priv, obj_num);\r\nobj_num++;\r\n} while (quota > 0);\r\nreturn rcv_pkts;\r\n}\r\nstatic void pch_can_tx_complete(struct net_device *ndev, u32 int_stat)\r\n{\r\nstruct pch_can_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &(priv->ndev->stats);\r\nu32 dlc;\r\ncan_get_echo_skb(ndev, int_stat - PCH_RX_OBJ_END - 1);\r\niowrite32(PCH_CMASK_RX_TX_GET | PCH_CMASK_CLRINTPND,\r\n&priv->regs->ifregs[1].cmask);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, int_stat);\r\ndlc = get_can_dlc(ioread32(&priv->regs->ifregs[1].mcont) &\r\nPCH_IF_MCONT_DLC);\r\nstats->tx_bytes += dlc;\r\nstats->tx_packets++;\r\nif (int_stat == PCH_TX_OBJ_END)\r\nnetif_wake_queue(ndev);\r\n}\r\nstatic int pch_can_poll(struct napi_struct *napi, int quota)\r\n{\r\nstruct net_device *ndev = napi->dev;\r\nstruct pch_can_priv *priv = netdev_priv(ndev);\r\nu32 int_stat;\r\nu32 reg_stat;\r\nint quota_save = quota;\r\nint_stat = pch_can_int_pending(priv);\r\nif (!int_stat)\r\ngoto end;\r\nif (int_stat == PCH_STATUS_INT) {\r\nreg_stat = ioread32(&priv->regs->stat);\r\nif ((reg_stat & (PCH_BUS_OFF | PCH_LEC_ALL)) &&\r\n((reg_stat & PCH_LEC_ALL) != PCH_LEC_ALL)) {\r\npch_can_error(ndev, reg_stat);\r\nquota--;\r\n}\r\nif (reg_stat & (PCH_TX_OK | PCH_RX_OK))\r\npch_can_bit_clear(&priv->regs->stat,\r\nreg_stat & (PCH_TX_OK | PCH_RX_OK));\r\nint_stat = pch_can_int_pending(priv);\r\n}\r\nif (quota == 0)\r\ngoto end;\r\nif ((int_stat >= PCH_RX_OBJ_START) && (int_stat <= PCH_RX_OBJ_END)) {\r\nquota -= pch_can_rx_normal(ndev, int_stat, quota);\r\n} else if ((int_stat >= PCH_TX_OBJ_START) &&\r\n(int_stat <= PCH_TX_OBJ_END)) {\r\npch_can_tx_complete(ndev, int_stat);\r\n}\r\nend:\r\nnapi_complete(napi);\r\npch_can_set_int_enables(priv, PCH_CAN_ALL);\r\nreturn quota_save - quota;\r\n}\r\nstatic int pch_set_bittiming(struct net_device *ndev)\r\n{\r\nstruct pch_can_priv *priv = netdev_priv(ndev);\r\nconst struct can_bittiming *bt = &priv->can.bittiming;\r\nu32 canbit;\r\nu32 bepe;\r\npch_can_bit_set(&priv->regs->cont, PCH_CTRL_CCE);\r\ncanbit = (bt->brp - 1) & PCH_MSK_BITT_BRP;\r\ncanbit |= (bt->sjw - 1) << PCH_BIT_SJW_SHIFT;\r\ncanbit |= (bt->phase_seg1 + bt->prop_seg - 1) << PCH_BIT_TSEG1_SHIFT;\r\ncanbit |= (bt->phase_seg2 - 1) << PCH_BIT_TSEG2_SHIFT;\r\nbepe = ((bt->brp - 1) & PCH_MSK_BRPE_BRPE) >> PCH_BIT_BRPE_BRPE_SHIFT;\r\niowrite32(canbit, &priv->regs->bitt);\r\niowrite32(bepe, &priv->regs->brpe);\r\npch_can_bit_clear(&priv->regs->cont, PCH_CTRL_CCE);\r\nreturn 0;\r\n}\r\nstatic void pch_can_start(struct net_device *ndev)\r\n{\r\nstruct pch_can_priv *priv = netdev_priv(ndev);\r\nif (priv->can.state != CAN_STATE_STOPPED)\r\npch_can_reset(priv);\r\npch_set_bittiming(ndev);\r\npch_can_set_optmode(priv);\r\npch_can_set_tx_all(priv, 1);\r\npch_can_set_rx_all(priv, 1);\r\npch_can_set_run_mode(priv, PCH_CAN_RUN);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn;\r\n}\r\nstatic int pch_can_do_set_mode(struct net_device *ndev, enum can_mode mode)\r\n{\r\nint ret = 0;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\npch_can_start(ndev);\r\nnetif_wake_queue(ndev);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pch_can_open(struct net_device *ndev)\r\n{\r\nstruct pch_can_priv *priv = netdev_priv(ndev);\r\nint retval;\r\nretval = request_irq(priv->dev->irq, pch_can_interrupt, IRQF_SHARED,\r\nndev->name, ndev);\r\nif (retval) {\r\nnetdev_err(ndev, "request_irq failed.\n");\r\ngoto req_irq_err;\r\n}\r\nretval = open_candev(ndev);\r\nif (retval) {\r\nnetdev_err(ndev, "open_candev() failed %d\n", retval);\r\ngoto err_open_candev;\r\n}\r\npch_can_init(priv);\r\npch_can_start(ndev);\r\nnapi_enable(&priv->napi);\r\nnetif_start_queue(ndev);\r\nreturn 0;\r\nerr_open_candev:\r\nfree_irq(priv->dev->irq, ndev);\r\nreq_irq_err:\r\npch_can_release(priv);\r\nreturn retval;\r\n}\r\nstatic int pch_close(struct net_device *ndev)\r\n{\r\nstruct pch_can_priv *priv = netdev_priv(ndev);\r\nnetif_stop_queue(ndev);\r\nnapi_disable(&priv->napi);\r\npch_can_release(priv);\r\nfree_irq(priv->dev->irq, ndev);\r\nclose_candev(ndev);\r\npriv->can.state = CAN_STATE_STOPPED;\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t pch_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nstruct pch_can_priv *priv = netdev_priv(ndev);\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nint tx_obj_no;\r\nint i;\r\nu32 id2;\r\nif (can_dropped_invalid_skb(ndev, skb))\r\nreturn NETDEV_TX_OK;\r\ntx_obj_no = priv->tx_obj;\r\nif (priv->tx_obj == PCH_TX_OBJ_END) {\r\nif (ioread32(&priv->regs->treq2) & PCH_TREQ2_TX_MASK)\r\nnetif_stop_queue(ndev);\r\npriv->tx_obj = PCH_TX_OBJ_START;\r\n} else {\r\npriv->tx_obj++;\r\n}\r\npch_can_bit_set(&priv->regs->ifregs[1].cmask, PCH_CMASK_ALL);\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\niowrite32(cf->can_id & 0xffff, &priv->regs->ifregs[1].id1);\r\nid2 = ((cf->can_id >> 16) & 0x1fff) | PCH_ID2_XTD;\r\n} else {\r\niowrite32(0, &priv->regs->ifregs[1].id1);\r\nid2 = (cf->can_id & CAN_SFF_MASK) << 2;\r\n}\r\nid2 |= PCH_ID_MSGVAL;\r\nif (!(cf->can_id & CAN_RTR_FLAG))\r\nid2 |= PCH_ID2_DIR;\r\niowrite32(id2, &priv->regs->ifregs[1].id2);\r\nfor (i = 0; i < cf->can_dlc; i += 2) {\r\niowrite16(cf->data[i] | (cf->data[i + 1] << 8),\r\n&priv->regs->ifregs[1].data[i / 2]);\r\n}\r\ncan_put_echo_skb(skb, ndev, tx_obj_no - PCH_RX_OBJ_END - 1);\r\niowrite32(cf->can_dlc | PCH_IF_MCONT_NEWDAT | PCH_IF_MCONT_TXRQXT |\r\nPCH_IF_MCONT_TXIE, &priv->regs->ifregs[1].mcont);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[1].creq, tx_obj_no);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void __devexit pch_can_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *ndev = pci_get_drvdata(pdev);\r\nstruct pch_can_priv *priv = netdev_priv(ndev);\r\nunregister_candev(priv->ndev);\r\nif (priv->use_msi)\r\npci_disable_msi(priv->dev);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\npch_can_reset(priv);\r\npci_iounmap(pdev, priv->regs);\r\nfree_candev(priv->ndev);\r\n}\r\nstatic void pch_can_set_int_custom(struct pch_can_priv *priv)\r\n{\r\npch_can_bit_clear(&priv->regs->cont, PCH_CTRL_IE_SIE_EIE);\r\npch_can_bit_set(&priv->regs->cont,\r\n((priv->int_enables & PCH_MSK_CTRL_IE_SIE_EIE) << 1));\r\n}\r\nstatic u32 pch_can_get_int_enables(struct pch_can_priv *priv)\r\n{\r\nreturn (ioread32(&priv->regs->cont) & PCH_CTRL_IE_SIE_EIE) >> 1;\r\n}\r\nstatic u32 pch_can_get_rxtx_ir(struct pch_can_priv *priv, u32 buff_num,\r\nenum pch_ifreg dir)\r\n{\r\nu32 ie, enable;\r\nif (dir)\r\nie = PCH_IF_MCONT_RXIE;\r\nelse\r\nie = PCH_IF_MCONT_TXIE;\r\niowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[dir].cmask);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[dir].creq, buff_num);\r\nif (((ioread32(&priv->regs->ifregs[dir].id2)) & PCH_ID_MSGVAL) &&\r\n((ioread32(&priv->regs->ifregs[dir].mcont)) & ie))\r\nenable = 1;\r\nelse\r\nenable = 0;\r\nreturn enable;\r\n}\r\nstatic void pch_can_set_rx_buffer_link(struct pch_can_priv *priv,\r\nu32 buffer_num, int set)\r\n{\r\niowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, buffer_num);\r\niowrite32(PCH_CMASK_RDWR | PCH_CMASK_CTRL,\r\n&priv->regs->ifregs[0].cmask);\r\nif (set)\r\npch_can_bit_clear(&priv->regs->ifregs[0].mcont,\r\nPCH_IF_MCONT_EOB);\r\nelse\r\npch_can_bit_set(&priv->regs->ifregs[0].mcont, PCH_IF_MCONT_EOB);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, buffer_num);\r\n}\r\nstatic u32 pch_can_get_rx_buffer_link(struct pch_can_priv *priv, u32 buffer_num)\r\n{\r\nu32 link;\r\niowrite32(PCH_CMASK_RX_TX_GET, &priv->regs->ifregs[0].cmask);\r\npch_can_rw_msg_obj(&priv->regs->ifregs[0].creq, buffer_num);\r\nif (ioread32(&priv->regs->ifregs[0].mcont) & PCH_IF_MCONT_EOB)\r\nlink = 0;\r\nelse\r\nlink = 1;\r\nreturn link;\r\n}\r\nstatic int pch_can_get_buffer_status(struct pch_can_priv *priv)\r\n{\r\nreturn (ioread32(&priv->regs->treq1) & 0xffff) |\r\n(ioread32(&priv->regs->treq2) << 16);\r\n}\r\nstatic int pch_can_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nint i;\r\nint retval;\r\nu32 buf_stat;\r\nint counter = PCH_COUNTER_LIMIT;\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct pch_can_priv *priv = netdev_priv(dev);\r\npch_can_set_run_mode(priv, PCH_CAN_STOP);\r\npriv->can.state = CAN_STATE_STOPPED;\r\nwhile (counter) {\r\nbuf_stat = pch_can_get_buffer_status(priv);\r\nif (!buf_stat)\r\nbreak;\r\ncounter--;\r\nudelay(1);\r\n}\r\nif (!counter)\r\ndev_err(&pdev->dev, "%s -> Transmission time out.\n", __func__);\r\npriv->int_enables = pch_can_get_int_enables(priv);\r\npch_can_set_int_enables(priv, PCH_CAN_DISABLE);\r\nfor (i = PCH_TX_OBJ_START; i <= PCH_TX_OBJ_END; i++)\r\npriv->tx_enable[i - 1] = pch_can_get_rxtx_ir(priv, i,\r\nPCH_TX_IFREG);\r\npch_can_set_tx_all(priv, 0);\r\nfor (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {\r\npriv->rx_enable[i - 1] = pch_can_get_rxtx_ir(priv, i,\r\nPCH_RX_IFREG);\r\npriv->rx_link[i - 1] = pch_can_get_rx_buffer_link(priv, i);\r\n}\r\npch_can_set_rx_all(priv, 0);\r\nretval = pci_save_state(pdev);\r\nif (retval) {\r\ndev_err(&pdev->dev, "pci_save_state failed.\n");\r\n} else {\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\n}\r\nreturn retval;\r\n}\r\nstatic int pch_can_resume(struct pci_dev *pdev)\r\n{\r\nint i;\r\nint retval;\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct pch_can_priv *priv = netdev_priv(dev);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nretval = pci_enable_device(pdev);\r\nif (retval) {\r\ndev_err(&pdev->dev, "pci_enable_device failed.\n");\r\nreturn retval;\r\n}\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\npch_can_set_int_enables(priv, PCH_CAN_DISABLE);\r\npch_can_set_run_mode(priv, PCH_CAN_STOP);\r\npch_can_config_rx_tx_buffers(priv);\r\npch_set_bittiming(dev);\r\npch_can_set_optmode(priv);\r\nfor (i = PCH_TX_OBJ_START; i <= PCH_TX_OBJ_END; i++)\r\npch_can_set_rxtx(priv, i, priv->tx_enable[i - 1], PCH_TX_IFREG);\r\nfor (i = PCH_RX_OBJ_START; i <= PCH_RX_OBJ_END; i++) {\r\npch_can_set_rx_buffer_link(priv, i, priv->rx_link[i - 1]);\r\npch_can_set_rxtx(priv, i, priv->rx_enable[i - 1], PCH_RX_IFREG);\r\n}\r\npch_can_set_int_custom(priv);\r\npch_can_set_run_mode(priv, PCH_CAN_RUN);\r\nreturn retval;\r\n}\r\nstatic int pch_can_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct pch_can_priv *priv = netdev_priv(dev);\r\nu32 errc = ioread32(&priv->regs->errc);\r\nbec->txerr = errc & PCH_TEC;\r\nbec->rxerr = (errc & PCH_REC) >> 8;\r\nreturn 0;\r\n}\r\nstatic int __devinit pch_can_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct net_device *ndev;\r\nstruct pch_can_priv *priv;\r\nint rc;\r\nvoid __iomem *addr;\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Failed pci_enable_device %d\n", rc);\r\ngoto probe_exit_endev;\r\n}\r\nrc = pci_request_regions(pdev, KBUILD_MODNAME);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Failed pci_request_regions %d\n", rc);\r\ngoto probe_exit_pcireq;\r\n}\r\naddr = pci_iomap(pdev, 1, 0);\r\nif (!addr) {\r\nrc = -EIO;\r\ndev_err(&pdev->dev, "Failed pci_iomap\n");\r\ngoto probe_exit_ipmap;\r\n}\r\nndev = alloc_candev(sizeof(struct pch_can_priv), PCH_TX_OBJ_END);\r\nif (!ndev) {\r\nrc = -ENOMEM;\r\ndev_err(&pdev->dev, "Failed alloc_candev\n");\r\ngoto probe_exit_alloc_candev;\r\n}\r\npriv = netdev_priv(ndev);\r\npriv->ndev = ndev;\r\npriv->regs = addr;\r\npriv->dev = pdev;\r\npriv->can.bittiming_const = &pch_can_bittiming_const;\r\npriv->can.do_set_mode = pch_can_do_set_mode;\r\npriv->can.do_get_berr_counter = pch_can_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_LISTENONLY |\r\nCAN_CTRLMODE_LOOPBACK;\r\npriv->tx_obj = PCH_TX_OBJ_START;\r\nndev->irq = pdev->irq;\r\nndev->flags |= IFF_ECHO;\r\npci_set_drvdata(pdev, ndev);\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nndev->netdev_ops = &pch_can_netdev_ops;\r\npriv->can.clock.freq = PCH_CAN_CLK;\r\nnetif_napi_add(ndev, &priv->napi, pch_can_poll, PCH_RX_OBJ_END);\r\nrc = pci_enable_msi(priv->dev);\r\nif (rc) {\r\nnetdev_err(ndev, "PCH CAN opened without MSI\n");\r\npriv->use_msi = 0;\r\n} else {\r\nnetdev_err(ndev, "PCH CAN opened with MSI\n");\r\npci_set_master(pdev);\r\npriv->use_msi = 1;\r\n}\r\nrc = register_candev(ndev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Failed register_candev %d\n", rc);\r\ngoto probe_exit_reg_candev;\r\n}\r\nreturn 0;\r\nprobe_exit_reg_candev:\r\nif (priv->use_msi)\r\npci_disable_msi(priv->dev);\r\nfree_candev(ndev);\r\nprobe_exit_alloc_candev:\r\npci_iounmap(pdev, addr);\r\nprobe_exit_ipmap:\r\npci_release_regions(pdev);\r\nprobe_exit_pcireq:\r\npci_disable_device(pdev);\r\nprobe_exit_endev:\r\nreturn rc;\r\n}
