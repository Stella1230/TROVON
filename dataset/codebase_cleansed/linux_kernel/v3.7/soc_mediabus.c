int soc_mbus_samples_per_pixel(const struct soc_mbus_pixelfmt *mf,\r\nunsigned int *numerator, unsigned int *denominator)\r\n{\r\nswitch (mf->packing) {\r\ncase SOC_MBUS_PACKING_NONE:\r\ncase SOC_MBUS_PACKING_EXTEND16:\r\n*numerator = 1;\r\n*denominator = 1;\r\nreturn 0;\r\ncase SOC_MBUS_PACKING_2X8_PADHI:\r\ncase SOC_MBUS_PACKING_2X8_PADLO:\r\n*numerator = 2;\r\n*denominator = 1;\r\nreturn 0;\r\ncase SOC_MBUS_PACKING_1_5X8:\r\n*numerator = 3;\r\n*denominator = 2;\r\nreturn 0;\r\ncase SOC_MBUS_PACKING_VARIABLE:\r\n*numerator = 0;\r\n*denominator = 1;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\ns32 soc_mbus_bytes_per_line(u32 width, const struct soc_mbus_pixelfmt *mf)\r\n{\r\nif (mf->fourcc == V4L2_PIX_FMT_JPEG)\r\nreturn 0;\r\nif (mf->layout != SOC_MBUS_LAYOUT_PACKED)\r\nreturn width * mf->bits_per_sample / 8;\r\nswitch (mf->packing) {\r\ncase SOC_MBUS_PACKING_NONE:\r\nreturn width * mf->bits_per_sample / 8;\r\ncase SOC_MBUS_PACKING_2X8_PADHI:\r\ncase SOC_MBUS_PACKING_2X8_PADLO:\r\ncase SOC_MBUS_PACKING_EXTEND16:\r\nreturn width * 2;\r\ncase SOC_MBUS_PACKING_1_5X8:\r\nreturn width * 3 / 2;\r\ncase SOC_MBUS_PACKING_VARIABLE:\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\ns32 soc_mbus_image_size(const struct soc_mbus_pixelfmt *mf,\r\nu32 bytes_per_line, u32 height)\r\n{\r\nif (mf->fourcc == V4L2_PIX_FMT_JPEG)\r\nreturn 0;\r\nif (mf->layout == SOC_MBUS_LAYOUT_PACKED)\r\nreturn bytes_per_line * height;\r\nswitch (mf->packing) {\r\ncase SOC_MBUS_PACKING_2X8_PADHI:\r\ncase SOC_MBUS_PACKING_2X8_PADLO:\r\nreturn bytes_per_line * height * 2;\r\ncase SOC_MBUS_PACKING_1_5X8:\r\nreturn bytes_per_line * height * 3 / 2;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nconst struct soc_mbus_pixelfmt *soc_mbus_find_fmtdesc(\r\nenum v4l2_mbus_pixelcode code,\r\nconst struct soc_mbus_lookup *lookup,\r\nint n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; i++)\r\nif (lookup[i].code == code)\r\nreturn &lookup[i].fmt;\r\nreturn NULL;\r\n}\r\nconst struct soc_mbus_pixelfmt *soc_mbus_get_fmtdesc(\r\nenum v4l2_mbus_pixelcode code)\r\n{\r\nreturn soc_mbus_find_fmtdesc(code, mbus_fmt, ARRAY_SIZE(mbus_fmt));\r\n}\r\nunsigned int soc_mbus_config_compatible(const struct v4l2_mbus_config *cfg,\r\nunsigned int flags)\r\n{\r\nunsigned long common_flags;\r\nbool hsync = true, vsync = true, pclk, data, mode;\r\nbool mipi_lanes, mipi_clock;\r\ncommon_flags = cfg->flags & flags;\r\nswitch (cfg->type) {\r\ncase V4L2_MBUS_PARALLEL:\r\nhsync = common_flags & (V4L2_MBUS_HSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_HSYNC_ACTIVE_LOW);\r\nvsync = common_flags & (V4L2_MBUS_VSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_VSYNC_ACTIVE_LOW);\r\ncase V4L2_MBUS_BT656:\r\npclk = common_flags & (V4L2_MBUS_PCLK_SAMPLE_RISING |\r\nV4L2_MBUS_PCLK_SAMPLE_FALLING);\r\ndata = common_flags & (V4L2_MBUS_DATA_ACTIVE_HIGH |\r\nV4L2_MBUS_DATA_ACTIVE_LOW);\r\nmode = common_flags & (V4L2_MBUS_MASTER | V4L2_MBUS_SLAVE);\r\nreturn (!hsync || !vsync || !pclk || !data || !mode) ?\r\n0 : common_flags;\r\ncase V4L2_MBUS_CSI2:\r\nmipi_lanes = common_flags & V4L2_MBUS_CSI2_LANES;\r\nmipi_clock = common_flags & (V4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK |\r\nV4L2_MBUS_CSI2_CONTINUOUS_CLOCK);\r\nreturn (!mipi_lanes || !mipi_clock) ? 0 : common_flags;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init soc_mbus_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit soc_mbus_exit(void)\r\n{\r\n}
