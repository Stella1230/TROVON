static int da9052_rtc_enable_alarm(struct da9052 *da9052, bool enable)\r\n{\r\nint ret;\r\nif (enable) {\r\nret = da9052_reg_update(da9052, DA9052_ALARM_Y_REG,\r\nDA9052_ALARM_Y_ALARM_ON,\r\nDA9052_ALARM_Y_ALARM_ON);\r\nif (ret != 0)\r\nrtc_err(da9052, "Failed to enable ALM: %d\n", ret);\r\n} else {\r\nret = da9052_reg_update(da9052, DA9052_ALARM_Y_REG,\r\nDA9052_ALARM_Y_ALARM_ON, 0);\r\nif (ret != 0)\r\nrtc_err(da9052, "Write error: %d\n", ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t da9052_rtc_irq(int irq, void *data)\r\n{\r\nstruct da9052_rtc *rtc = data;\r\nint ret;\r\nret = da9052_reg_read(rtc->da9052, DA9052_ALARM_MI_REG);\r\nif (ret < 0) {\r\nrtc_err(rtc->da9052, "Read error: %d\n", ret);\r\nreturn IRQ_NONE;\r\n}\r\nif (ret & DA9052_ALARMMI_ALARMTYPE) {\r\nda9052_rtc_enable_alarm(rtc->da9052, 0);\r\nrtc_update_irq(rtc->rtc, 1, RTC_IRQF | RTC_AF);\r\n} else\r\nrtc_update_irq(rtc->rtc, 1, RTC_IRQF | RTC_PF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int da9052_read_alarm(struct da9052 *da9052, struct rtc_time *rtc_tm)\r\n{\r\nint ret;\r\nuint8_t v[5];\r\nret = da9052_group_read(da9052, DA9052_ALARM_MI_REG, 5, v);\r\nif (ret != 0) {\r\nrtc_err(da9052, "Failed to group read ALM: %d\n", ret);\r\nreturn ret;\r\n}\r\nrtc_tm->tm_year = (v[4] & DA9052_RTC_YEAR) + 100;\r\nrtc_tm->tm_mon = (v[3] & DA9052_RTC_MONTH) - 1;\r\nrtc_tm->tm_mday = v[2] & DA9052_RTC_DAY;\r\nrtc_tm->tm_hour = v[1] & DA9052_RTC_HOUR;\r\nrtc_tm->tm_min = v[0] & DA9052_RTC_MIN;\r\nret = rtc_valid_tm(rtc_tm);\r\nif (ret != 0)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int da9052_set_alarm(struct da9052 *da9052, struct rtc_time *rtc_tm)\r\n{\r\nint ret;\r\nuint8_t v[3];\r\nrtc_tm->tm_year -= 100;\r\nrtc_tm->tm_mon += 1;\r\nret = da9052_reg_update(da9052, DA9052_ALARM_MI_REG,\r\nDA9052_RTC_MIN, rtc_tm->tm_min);\r\nif (ret != 0) {\r\nrtc_err(da9052, "Failed to write ALRM MIN: %d\n", ret);\r\nreturn ret;\r\n}\r\nv[0] = rtc_tm->tm_hour;\r\nv[1] = rtc_tm->tm_mday;\r\nv[2] = rtc_tm->tm_mon;\r\nret = da9052_group_write(da9052, DA9052_ALARM_H_REG, 3, v);\r\nif (ret < 0)\r\nreturn ret;\r\nret = da9052_reg_update(da9052, DA9052_ALARM_Y_REG,\r\nDA9052_RTC_YEAR, rtc_tm->tm_year);\r\nif (ret != 0)\r\nrtc_err(da9052, "Failed to write ALRM YEAR: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int da9052_rtc_get_alarm_status(struct da9052 *da9052)\r\n{\r\nint ret;\r\nret = da9052_reg_read(da9052, DA9052_ALARM_Y_REG);\r\nif (ret < 0) {\r\nrtc_err(da9052, "Failed to read ALM: %d\n", ret);\r\nreturn ret;\r\n}\r\nret &= DA9052_ALARM_Y_ALARM_ON;\r\nreturn (ret > 0) ? 1 : 0;\r\n}\r\nstatic int da9052_rtc_read_time(struct device *dev, struct rtc_time *rtc_tm)\r\n{\r\nstruct da9052_rtc *rtc = dev_get_drvdata(dev);\r\nuint8_t v[6];\r\nint ret;\r\nret = da9052_group_read(rtc->da9052, DA9052_COUNT_S_REG, 6, v);\r\nif (ret < 0) {\r\nrtc_err(rtc->da9052, "Failed to read RTC time : %d\n", ret);\r\nreturn ret;\r\n}\r\nrtc_tm->tm_year = (v[5] & DA9052_RTC_YEAR) + 100;\r\nrtc_tm->tm_mon = (v[4] & DA9052_RTC_MONTH) - 1;\r\nrtc_tm->tm_mday = v[3] & DA9052_RTC_DAY;\r\nrtc_tm->tm_hour = v[2] & DA9052_RTC_HOUR;\r\nrtc_tm->tm_min = v[1] & DA9052_RTC_MIN;\r\nrtc_tm->tm_sec = v[0] & DA9052_RTC_SEC;\r\nret = rtc_valid_tm(rtc_tm);\r\nif (ret != 0) {\r\nrtc_err(rtc->da9052, "rtc_valid_tm failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int da9052_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct da9052_rtc *rtc;\r\nuint8_t v[6];\r\nrtc = dev_get_drvdata(dev);\r\nv[0] = tm->tm_sec;\r\nv[1] = tm->tm_min;\r\nv[2] = tm->tm_hour;\r\nv[3] = tm->tm_mday;\r\nv[4] = tm->tm_mon + 1;\r\nv[5] = tm->tm_year - 100;\r\nreturn da9052_group_write(rtc->da9052, DA9052_COUNT_S_REG, 6, v);\r\n}\r\nstatic int da9052_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nint ret;\r\nstruct rtc_time *tm = &alrm->time;\r\nstruct da9052_rtc *rtc = dev_get_drvdata(dev);\r\nret = da9052_read_alarm(rtc->da9052, tm);\r\nif (ret)\r\nreturn ret;\r\nalrm->enabled = da9052_rtc_get_alarm_status(rtc->da9052);\r\nreturn 0;\r\n}\r\nstatic int da9052_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nint ret;\r\nstruct rtc_time *tm = &alrm->time;\r\nstruct da9052_rtc *rtc = dev_get_drvdata(dev);\r\nret = da9052_rtc_enable_alarm(rtc->da9052, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = da9052_set_alarm(rtc->da9052, tm);\r\nif (ret)\r\nreturn ret;\r\nret = da9052_rtc_enable_alarm(rtc->da9052, 1);\r\nreturn ret;\r\n}\r\nstatic int da9052_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct da9052_rtc *rtc = dev_get_drvdata(dev);\r\nreturn da9052_rtc_enable_alarm(rtc->da9052, enabled);\r\n}\r\nstatic int __devinit da9052_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct da9052_rtc *rtc;\r\nint ret;\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(struct da9052_rtc), GFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nrtc->da9052 = dev_get_drvdata(pdev->dev.parent);\r\nplatform_set_drvdata(pdev, rtc);\r\nrtc->irq = platform_get_irq_byname(pdev, "ALM");\r\nret = request_threaded_irq(rtc->irq, NULL, da9052_rtc_irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"ALM", rtc);\r\nif (ret != 0) {\r\nrtc_err(rtc->da9052, "irq registration failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nrtc->rtc = rtc_device_register(pdev->name, &pdev->dev,\r\n&da9052_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtc)) {\r\nret = PTR_ERR(rtc->rtc);\r\ngoto err_free_irq;\r\n}\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(rtc->irq, rtc);\r\nreturn ret;\r\n}\r\nstatic int __devexit da9052_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct da9052_rtc *rtc = pdev->dev.platform_data;\r\nrtc_device_unregister(rtc->rtc);\r\nfree_irq(rtc->irq, rtc);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
