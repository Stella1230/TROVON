static struct sk_buff *tipc_disc_init_msg(u32 type,\r\nu32 dest_domain,\r\nstruct tipc_bearer *b_ptr)\r\n{\r\nstruct sk_buff *buf = tipc_buf_acquire(INT_H_SIZE);\r\nstruct tipc_msg *msg;\r\nif (buf) {\r\nmsg = buf_msg(buf);\r\ntipc_msg_init(msg, LINK_CONFIG, type, INT_H_SIZE, dest_domain);\r\nmsg_set_non_seq(msg, 1);\r\nmsg_set_node_sig(msg, tipc_random);\r\nmsg_set_dest_domain(msg, dest_domain);\r\nmsg_set_bc_netid(msg, tipc_net_id);\r\nb_ptr->media->addr2msg(&b_ptr->addr, msg_media_addr(msg));\r\n}\r\nreturn buf;\r\n}\r\nstatic void disc_dupl_alert(struct tipc_bearer *b_ptr, u32 node_addr,\r\nstruct tipc_media_addr *media_addr)\r\n{\r\nchar node_addr_str[16];\r\nchar media_addr_str[64];\r\ntipc_addr_string_fill(node_addr_str, node_addr);\r\ntipc_media_addr_printf(media_addr_str, sizeof(media_addr_str),\r\nmedia_addr);\r\npr_warn("Duplicate %s using %s seen on <%s>\n", node_addr_str,\r\nmedia_addr_str, b_ptr->name);\r\n}\r\nvoid tipc_disc_recv_msg(struct sk_buff *buf, struct tipc_bearer *b_ptr)\r\n{\r\nstruct tipc_node *n_ptr;\r\nstruct tipc_link *link;\r\nstruct tipc_media_addr media_addr;\r\nstruct sk_buff *rbuf;\r\nstruct tipc_msg *msg = buf_msg(buf);\r\nu32 dest = msg_dest_domain(msg);\r\nu32 orig = msg_prevnode(msg);\r\nu32 net_id = msg_bc_netid(msg);\r\nu32 type = msg_type(msg);\r\nu32 signature = msg_node_sig(msg);\r\nint addr_mismatch;\r\nint link_fully_up;\r\nmedia_addr.broadcast = 1;\r\nb_ptr->media->msg2addr(&media_addr, msg_media_addr(msg));\r\nkfree_skb(buf);\r\nif (net_id != tipc_net_id)\r\nreturn;\r\nif (media_addr.broadcast)\r\nreturn;\r\nif (!tipc_addr_domain_valid(dest))\r\nreturn;\r\nif (!tipc_addr_node_valid(orig))\r\nreturn;\r\nif (orig == tipc_own_addr) {\r\nif (memcmp(&media_addr, &b_ptr->addr, sizeof(media_addr)))\r\ndisc_dupl_alert(b_ptr, tipc_own_addr, &media_addr);\r\nreturn;\r\n}\r\nif (!tipc_in_scope(dest, tipc_own_addr))\r\nreturn;\r\nif (!tipc_in_scope(b_ptr->link_req->domain, orig))\r\nreturn;\r\nn_ptr = tipc_node_find(orig);\r\nif (!n_ptr) {\r\nn_ptr = tipc_node_create(orig);\r\nif (!n_ptr)\r\nreturn;\r\n}\r\ntipc_node_lock(n_ptr);\r\nlink = n_ptr->links[b_ptr->identity];\r\naddr_mismatch = (link != NULL) &&\r\nmemcmp(&link->media_addr, &media_addr, sizeof(media_addr));\r\nif (signature != n_ptr->signature) {\r\nif (n_ptr->working_links == 0) {\r\nstruct tipc_link *curr_link;\r\nint i;\r\nfor (i = 0; i < MAX_BEARERS; i++) {\r\ncurr_link = n_ptr->links[i];\r\nif (curr_link) {\r\nmemset(&curr_link->media_addr, 0,\r\nsizeof(media_addr));\r\ntipc_link_reset(curr_link);\r\n}\r\n}\r\naddr_mismatch = (link != NULL);\r\n} else if (tipc_link_is_up(link) && !addr_mismatch) {\r\n} else {\r\ndisc_dupl_alert(b_ptr, orig, &media_addr);\r\ntipc_node_unlock(n_ptr);\r\nreturn;\r\n}\r\nn_ptr->signature = signature;\r\n}\r\nif (addr_mismatch) {\r\nif (tipc_link_is_up(link)) {\r\ndisc_dupl_alert(b_ptr, orig, &media_addr);\r\ntipc_node_unlock(n_ptr);\r\nreturn;\r\n} else {\r\nmemcpy(&link->media_addr, &media_addr,\r\nsizeof(media_addr));\r\ntipc_link_reset(link);\r\n}\r\n}\r\nif (!link) {\r\nlink = tipc_link_create(n_ptr, b_ptr, &media_addr);\r\nif (!link) {\r\ntipc_node_unlock(n_ptr);\r\nreturn;\r\n}\r\n}\r\nlink_fully_up = link_working_working(link);\r\nif ((type == DSC_REQ_MSG) && !link_fully_up && !b_ptr->blocked) {\r\nrbuf = tipc_disc_init_msg(DSC_RESP_MSG, orig, b_ptr);\r\nif (rbuf) {\r\nb_ptr->media->send_msg(rbuf, b_ptr, &media_addr);\r\nkfree_skb(rbuf);\r\n}\r\n}\r\ntipc_node_unlock(n_ptr);\r\n}\r\nstatic void disc_update(struct tipc_link_req *req)\r\n{\r\nif (!req->num_nodes) {\r\nif ((req->timer_intv == TIPC_LINK_REQ_INACTIVE) ||\r\n(req->timer_intv > TIPC_LINK_REQ_FAST)) {\r\nreq->timer_intv = TIPC_LINK_REQ_INIT;\r\nk_start_timer(&req->timer, req->timer_intv);\r\n}\r\n}\r\n}\r\nvoid tipc_disc_add_dest(struct tipc_link_req *req)\r\n{\r\nreq->num_nodes++;\r\n}\r\nvoid tipc_disc_remove_dest(struct tipc_link_req *req)\r\n{\r\nreq->num_nodes--;\r\ndisc_update(req);\r\n}\r\nstatic void disc_send_msg(struct tipc_link_req *req)\r\n{\r\nif (!req->bearer->blocked)\r\ntipc_bearer_send(req->bearer, req->buf, &req->dest);\r\n}\r\nstatic void disc_timeout(struct tipc_link_req *req)\r\n{\r\nint max_delay;\r\nspin_lock_bh(&req->bearer->lock);\r\nif (tipc_node(req->domain) && req->num_nodes) {\r\nreq->timer_intv = TIPC_LINK_REQ_INACTIVE;\r\ngoto exit;\r\n}\r\ndisc_send_msg(req);\r\nreq->timer_intv *= 2;\r\nif (req->num_nodes)\r\nmax_delay = TIPC_LINK_REQ_SLOW;\r\nelse\r\nmax_delay = TIPC_LINK_REQ_FAST;\r\nif (req->timer_intv > max_delay)\r\nreq->timer_intv = max_delay;\r\nk_start_timer(&req->timer, req->timer_intv);\r\nexit:\r\nspin_unlock_bh(&req->bearer->lock);\r\n}\r\nint tipc_disc_create(struct tipc_bearer *b_ptr,\r\nstruct tipc_media_addr *dest, u32 dest_domain)\r\n{\r\nstruct tipc_link_req *req;\r\nreq = kmalloc(sizeof(*req), GFP_ATOMIC);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->buf = tipc_disc_init_msg(DSC_REQ_MSG, dest_domain, b_ptr);\r\nif (!req->buf) {\r\nkfree(req);\r\nreturn -ENOMSG;\r\n}\r\nmemcpy(&req->dest, dest, sizeof(*dest));\r\nreq->bearer = b_ptr;\r\nreq->domain = dest_domain;\r\nreq->num_nodes = 0;\r\nreq->timer_intv = TIPC_LINK_REQ_INIT;\r\nk_init_timer(&req->timer, (Handler)disc_timeout, (unsigned long)req);\r\nk_start_timer(&req->timer, req->timer_intv);\r\nb_ptr->link_req = req;\r\ndisc_send_msg(req);\r\nreturn 0;\r\n}\r\nvoid tipc_disc_delete(struct tipc_link_req *req)\r\n{\r\nk_cancel_timer(&req->timer);\r\nk_term_timer(&req->timer);\r\nkfree_skb(req->buf);\r\nkfree(req);\r\n}
