static void __bm_print_lock_info(struct drbd_conf *mdev, const char *func)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nif (!__ratelimit(&drbd_ratelimit_state))\r\nreturn;\r\ndev_err(DEV, "FIXME %s in %s, bitmap locked for '%s' by %s\n",\r\ncurrent == mdev->receiver.task ? "receiver" :\r\ncurrent == mdev->asender.task ? "asender" :\r\ncurrent == mdev->worker.task ? "worker" : current->comm,\r\nfunc, b->bm_why ?: "?",\r\nb->bm_task == mdev->receiver.task ? "receiver" :\r\nb->bm_task == mdev->asender.task ? "asender" :\r\nb->bm_task == mdev->worker.task ? "worker" : "?");\r\n}\r\nvoid drbd_bm_lock(struct drbd_conf *mdev, char *why, enum bm_flag flags)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nint trylock_failed;\r\nif (!b) {\r\ndev_err(DEV, "FIXME no bitmap in drbd_bm_lock!?\n");\r\nreturn;\r\n}\r\ntrylock_failed = !mutex_trylock(&b->bm_change);\r\nif (trylock_failed) {\r\ndev_warn(DEV, "%s going to '%s' but bitmap already locked for '%s' by %s\n",\r\ncurrent == mdev->receiver.task ? "receiver" :\r\ncurrent == mdev->asender.task ? "asender" :\r\ncurrent == mdev->worker.task ? "worker" : current->comm,\r\nwhy, b->bm_why ?: "?",\r\nb->bm_task == mdev->receiver.task ? "receiver" :\r\nb->bm_task == mdev->asender.task ? "asender" :\r\nb->bm_task == mdev->worker.task ? "worker" : "?");\r\nmutex_lock(&b->bm_change);\r\n}\r\nif (BM_LOCKED_MASK & b->bm_flags)\r\ndev_err(DEV, "FIXME bitmap already locked in bm_lock\n");\r\nb->bm_flags |= flags & BM_LOCKED_MASK;\r\nb->bm_why = why;\r\nb->bm_task = current;\r\n}\r\nvoid drbd_bm_unlock(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nif (!b) {\r\ndev_err(DEV, "FIXME no bitmap in drbd_bm_unlock!?\n");\r\nreturn;\r\n}\r\nif (!(BM_LOCKED_MASK & mdev->bitmap->bm_flags))\r\ndev_err(DEV, "FIXME bitmap not locked in bm_unlock\n");\r\nb->bm_flags &= ~BM_LOCKED_MASK;\r\nb->bm_why = NULL;\r\nb->bm_task = NULL;\r\nmutex_unlock(&b->bm_change);\r\n}\r\nstatic void bm_store_page_idx(struct page *page, unsigned long idx)\r\n{\r\nBUG_ON(0 != (idx & ~BM_PAGE_IDX_MASK));\r\nset_page_private(page, idx);\r\n}\r\nstatic unsigned long bm_page_to_idx(struct page *page)\r\n{\r\nreturn page_private(page) & BM_PAGE_IDX_MASK;\r\n}\r\nstatic void bm_page_lock_io(struct drbd_conf *mdev, int page_nr)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nvoid *addr = &page_private(b->bm_pages[page_nr]);\r\nwait_event(b->bm_io_wait, !test_and_set_bit(BM_PAGE_IO_LOCK, addr));\r\n}\r\nstatic void bm_page_unlock_io(struct drbd_conf *mdev, int page_nr)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nvoid *addr = &page_private(b->bm_pages[page_nr]);\r\nclear_bit(BM_PAGE_IO_LOCK, addr);\r\nsmp_mb__after_clear_bit();\r\nwake_up(&mdev->bitmap->bm_io_wait);\r\n}\r\nstatic void bm_set_page_unchanged(struct page *page)\r\n{\r\nclear_bit(BM_PAGE_NEED_WRITEOUT, &page_private(page));\r\nclear_bit(BM_PAGE_LAZY_WRITEOUT, &page_private(page));\r\n}\r\nstatic void bm_set_page_need_writeout(struct page *page)\r\n{\r\nset_bit(BM_PAGE_NEED_WRITEOUT, &page_private(page));\r\n}\r\nstatic int bm_test_page_unchanged(struct page *page)\r\n{\r\nvolatile const unsigned long *addr = &page_private(page);\r\nreturn (*addr & ((1UL<<BM_PAGE_NEED_WRITEOUT)|(1UL<<BM_PAGE_LAZY_WRITEOUT))) == 0;\r\n}\r\nstatic void bm_set_page_io_err(struct page *page)\r\n{\r\nset_bit(BM_PAGE_IO_ERROR, &page_private(page));\r\n}\r\nstatic void bm_clear_page_io_err(struct page *page)\r\n{\r\nclear_bit(BM_PAGE_IO_ERROR, &page_private(page));\r\n}\r\nstatic void bm_set_page_lazy_writeout(struct page *page)\r\n{\r\nset_bit(BM_PAGE_LAZY_WRITEOUT, &page_private(page));\r\n}\r\nstatic int bm_test_page_lazy_writeout(struct page *page)\r\n{\r\nreturn test_bit(BM_PAGE_LAZY_WRITEOUT, &page_private(page));\r\n}\r\nstatic unsigned int bm_word_to_page_idx(struct drbd_bitmap *b, unsigned long long_nr)\r\n{\r\nunsigned int page_nr = long_nr >> (PAGE_SHIFT - LN2_BPL + 3);\r\nBUG_ON(page_nr >= b->bm_number_of_pages);\r\nreturn page_nr;\r\n}\r\nstatic unsigned int bm_bit_to_page_idx(struct drbd_bitmap *b, u64 bitnr)\r\n{\r\nunsigned int page_nr = bitnr >> (PAGE_SHIFT + 3);\r\nBUG_ON(page_nr >= b->bm_number_of_pages);\r\nreturn page_nr;\r\n}\r\nstatic unsigned long *__bm_map_pidx(struct drbd_bitmap *b, unsigned int idx)\r\n{\r\nstruct page *page = b->bm_pages[idx];\r\nreturn (unsigned long *) kmap_atomic(page);\r\n}\r\nstatic unsigned long *bm_map_pidx(struct drbd_bitmap *b, unsigned int idx)\r\n{\r\nreturn __bm_map_pidx(b, idx);\r\n}\r\nstatic void __bm_unmap(unsigned long *p_addr)\r\n{\r\nkunmap_atomic(p_addr);\r\n}\r\nstatic void bm_unmap(unsigned long *p_addr)\r\n{\r\nreturn __bm_unmap(p_addr);\r\n}\r\nstatic void bm_free_pages(struct page **pages, unsigned long number)\r\n{\r\nunsigned long i;\r\nif (!pages)\r\nreturn;\r\nfor (i = 0; i < number; i++) {\r\nif (!pages[i]) {\r\nprintk(KERN_ALERT "drbd: bm_free_pages tried to free "\r\n"a NULL pointer; i=%lu n=%lu\n",\r\ni, number);\r\ncontinue;\r\n}\r\n__free_page(pages[i]);\r\npages[i] = NULL;\r\n}\r\n}\r\nstatic void bm_vk_free(void *ptr, int v)\r\n{\r\nif (v)\r\nvfree(ptr);\r\nelse\r\nkfree(ptr);\r\n}\r\nstatic struct page **bm_realloc_pages(struct drbd_bitmap *b, unsigned long want)\r\n{\r\nstruct page **old_pages = b->bm_pages;\r\nstruct page **new_pages, *page;\r\nunsigned int i, bytes, vmalloced = 0;\r\nunsigned long have = b->bm_number_of_pages;\r\nBUG_ON(have == 0 && old_pages != NULL);\r\nBUG_ON(have != 0 && old_pages == NULL);\r\nif (have == want)\r\nreturn old_pages;\r\nbytes = sizeof(struct page *)*want;\r\nnew_pages = kzalloc(bytes, GFP_KERNEL);\r\nif (!new_pages) {\r\nnew_pages = vzalloc(bytes);\r\nif (!new_pages)\r\nreturn NULL;\r\nvmalloced = 1;\r\n}\r\nif (want >= have) {\r\nfor (i = 0; i < have; i++)\r\nnew_pages[i] = old_pages[i];\r\nfor (; i < want; i++) {\r\npage = alloc_page(GFP_HIGHUSER);\r\nif (!page) {\r\nbm_free_pages(new_pages + have, i - have);\r\nbm_vk_free(new_pages, vmalloced);\r\nreturn NULL;\r\n}\r\nbm_store_page_idx(page, i);\r\nnew_pages[i] = page;\r\n}\r\n} else {\r\nfor (i = 0; i < want; i++)\r\nnew_pages[i] = old_pages[i];\r\n}\r\nif (vmalloced)\r\nb->bm_flags |= BM_P_VMALLOCED;\r\nelse\r\nb->bm_flags &= ~BM_P_VMALLOCED;\r\nreturn new_pages;\r\n}\r\nint drbd_bm_init(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nWARN_ON(b != NULL);\r\nb = kzalloc(sizeof(struct drbd_bitmap), GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nspin_lock_init(&b->bm_lock);\r\nmutex_init(&b->bm_change);\r\ninit_waitqueue_head(&b->bm_io_wait);\r\nmdev->bitmap = b;\r\nreturn 0;\r\n}\r\nsector_t drbd_bm_capacity(struct drbd_conf *mdev)\r\n{\r\nERR_IF(!mdev->bitmap) return 0;\r\nreturn mdev->bitmap->bm_dev_capacity;\r\n}\r\nvoid drbd_bm_cleanup(struct drbd_conf *mdev)\r\n{\r\nERR_IF (!mdev->bitmap) return;\r\nbm_free_pages(mdev->bitmap->bm_pages, mdev->bitmap->bm_number_of_pages);\r\nbm_vk_free(mdev->bitmap->bm_pages, (BM_P_VMALLOCED & mdev->bitmap->bm_flags));\r\nkfree(mdev->bitmap);\r\nmdev->bitmap = NULL;\r\n}\r\nstatic int bm_clear_surplus(struct drbd_bitmap *b)\r\n{\r\nunsigned long mask;\r\nunsigned long *p_addr, *bm;\r\nint tmp;\r\nint cleared = 0;\r\ntmp = (b->bm_bits & BITS_PER_PAGE_MASK);\r\nmask = (1UL << (tmp & BITS_PER_LONG_MASK)) -1;\r\nmask = cpu_to_lel(mask);\r\np_addr = bm_map_pidx(b, b->bm_number_of_pages - 1);\r\nbm = p_addr + (tmp/BITS_PER_LONG);\r\nif (mask) {\r\ncleared = hweight_long(*bm & ~mask);\r\n*bm &= mask;\r\nbm++;\r\n}\r\nif (BITS_PER_LONG == 32 && ((bm - p_addr) & 1) == 1) {\r\ncleared += hweight_long(*bm);\r\n*bm = 0;\r\n}\r\nbm_unmap(p_addr);\r\nreturn cleared;\r\n}\r\nstatic void bm_set_surplus(struct drbd_bitmap *b)\r\n{\r\nunsigned long mask;\r\nunsigned long *p_addr, *bm;\r\nint tmp;\r\ntmp = (b->bm_bits & BITS_PER_PAGE_MASK);\r\nmask = (1UL << (tmp & BITS_PER_LONG_MASK)) -1;\r\nmask = cpu_to_lel(mask);\r\np_addr = bm_map_pidx(b, b->bm_number_of_pages - 1);\r\nbm = p_addr + (tmp/BITS_PER_LONG);\r\nif (mask) {\r\n*bm |= ~mask;\r\nbm++;\r\n}\r\nif (BITS_PER_LONG == 32 && ((bm - p_addr) & 1) == 1) {\r\n*bm = ~0UL;\r\n}\r\nbm_unmap(p_addr);\r\n}\r\nstatic unsigned long bm_count_bits(struct drbd_bitmap *b)\r\n{\r\nunsigned long *p_addr;\r\nunsigned long bits = 0;\r\nunsigned long mask = (1UL << (b->bm_bits & BITS_PER_LONG_MASK)) -1;\r\nint idx, i, last_word;\r\nfor (idx = 0; idx < b->bm_number_of_pages - 1; idx++) {\r\np_addr = __bm_map_pidx(b, idx);\r\nfor (i = 0; i < LWPP; i++)\r\nbits += hweight_long(p_addr[i]);\r\n__bm_unmap(p_addr);\r\ncond_resched();\r\n}\r\nlast_word = ((b->bm_bits - 1) & BITS_PER_PAGE_MASK) >> LN2_BPL;\r\np_addr = __bm_map_pidx(b, idx);\r\nfor (i = 0; i < last_word; i++)\r\nbits += hweight_long(p_addr[i]);\r\np_addr[last_word] &= cpu_to_lel(mask);\r\nbits += hweight_long(p_addr[last_word]);\r\nif (BITS_PER_LONG == 32 && (last_word & 1) == 0)\r\np_addr[last_word+1] = 0;\r\n__bm_unmap(p_addr);\r\nreturn bits;\r\n}\r\nstatic void bm_memset(struct drbd_bitmap *b, size_t offset, int c, size_t len)\r\n{\r\nunsigned long *p_addr, *bm;\r\nunsigned int idx;\r\nsize_t do_now, end;\r\nend = offset + len;\r\nif (end > b->bm_words) {\r\nprintk(KERN_ALERT "drbd: bm_memset end > bm_words\n");\r\nreturn;\r\n}\r\nwhile (offset < end) {\r\ndo_now = min_t(size_t, ALIGN(offset + 1, LWPP), end) - offset;\r\nidx = bm_word_to_page_idx(b, offset);\r\np_addr = bm_map_pidx(b, idx);\r\nbm = p_addr + MLPP(offset);\r\nif (bm+do_now > p_addr + LWPP) {\r\nprintk(KERN_ALERT "drbd: BUG BUG BUG! p_addr:%p bm:%p do_now:%d\n",\r\np_addr, bm, (int)do_now);\r\n} else\r\nmemset(bm, c, do_now * sizeof(long));\r\nbm_unmap(p_addr);\r\nbm_set_page_need_writeout(b->bm_pages[idx]);\r\noffset += do_now;\r\n}\r\n}\r\nint drbd_bm_resize(struct drbd_conf *mdev, sector_t capacity, int set_new_bits)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nunsigned long bits, words, owords, obits;\r\nunsigned long want, have, onpages;\r\nstruct page **npages, **opages = NULL;\r\nint err = 0, growing;\r\nint opages_vmalloced;\r\nERR_IF(!b) return -ENOMEM;\r\ndrbd_bm_lock(mdev, "resize", BM_LOCKED_MASK);\r\ndev_info(DEV, "drbd_bm_resize called with capacity == %llu\n",\r\n(unsigned long long)capacity);\r\nif (capacity == b->bm_dev_capacity)\r\ngoto out;\r\nopages_vmalloced = (BM_P_VMALLOCED & b->bm_flags);\r\nif (capacity == 0) {\r\nspin_lock_irq(&b->bm_lock);\r\nopages = b->bm_pages;\r\nonpages = b->bm_number_of_pages;\r\nowords = b->bm_words;\r\nb->bm_pages = NULL;\r\nb->bm_number_of_pages =\r\nb->bm_set =\r\nb->bm_bits =\r\nb->bm_words =\r\nb->bm_dev_capacity = 0;\r\nspin_unlock_irq(&b->bm_lock);\r\nbm_free_pages(opages, onpages);\r\nbm_vk_free(opages, opages_vmalloced);\r\ngoto out;\r\n}\r\nbits = BM_SECT_TO_BIT(ALIGN(capacity, BM_SECT_PER_BIT));\r\nwords = ALIGN(bits, 64) >> LN2_BPL;\r\nif (get_ldev(mdev)) {\r\nu64 bits_on_disk = ((u64)mdev->ldev->md.md_size_sect-MD_BM_OFFSET) << 12;\r\nput_ldev(mdev);\r\nif (bits > bits_on_disk) {\r\ndev_info(DEV, "bits = %lu\n", bits);\r\ndev_info(DEV, "bits_on_disk = %llu\n", bits_on_disk);\r\nerr = -ENOSPC;\r\ngoto out;\r\n}\r\n}\r\nwant = ALIGN(words*sizeof(long), PAGE_SIZE) >> PAGE_SHIFT;\r\nhave = b->bm_number_of_pages;\r\nif (want == have) {\r\nD_ASSERT(b->bm_pages != NULL);\r\nnpages = b->bm_pages;\r\n} else {\r\nif (drbd_insert_fault(mdev, DRBD_FAULT_BM_ALLOC))\r\nnpages = NULL;\r\nelse\r\nnpages = bm_realloc_pages(b, want);\r\n}\r\nif (!npages) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nspin_lock_irq(&b->bm_lock);\r\nopages = b->bm_pages;\r\nowords = b->bm_words;\r\nobits = b->bm_bits;\r\ngrowing = bits > obits;\r\nif (opages && growing && set_new_bits)\r\nbm_set_surplus(b);\r\nb->bm_pages = npages;\r\nb->bm_number_of_pages = want;\r\nb->bm_bits = bits;\r\nb->bm_words = words;\r\nb->bm_dev_capacity = capacity;\r\nif (growing) {\r\nif (set_new_bits) {\r\nbm_memset(b, owords, 0xff, words-owords);\r\nb->bm_set += bits - obits;\r\n} else\r\nbm_memset(b, owords, 0x00, words-owords);\r\n}\r\nif (want < have) {\r\nbm_free_pages(opages + want, have - want);\r\n}\r\n(void)bm_clear_surplus(b);\r\nspin_unlock_irq(&b->bm_lock);\r\nif (opages != npages)\r\nbm_vk_free(opages, opages_vmalloced);\r\nif (!growing)\r\nb->bm_set = bm_count_bits(b);\r\ndev_info(DEV, "resync bitmap: bits=%lu words=%lu pages=%lu\n", bits, words, want);\r\nout:\r\ndrbd_bm_unlock(mdev);\r\nreturn err;\r\n}\r\nunsigned long _drbd_bm_total_weight(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nunsigned long s;\r\nunsigned long flags;\r\nERR_IF(!b) return 0;\r\nERR_IF(!b->bm_pages) return 0;\r\nspin_lock_irqsave(&b->bm_lock, flags);\r\ns = b->bm_set;\r\nspin_unlock_irqrestore(&b->bm_lock, flags);\r\nreturn s;\r\n}\r\nunsigned long drbd_bm_total_weight(struct drbd_conf *mdev)\r\n{\r\nunsigned long s;\r\nif (!get_ldev_if_state(mdev, D_NEGOTIATING))\r\nreturn 0;\r\ns = _drbd_bm_total_weight(mdev);\r\nput_ldev(mdev);\r\nreturn s;\r\n}\r\nsize_t drbd_bm_words(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nERR_IF(!b) return 0;\r\nERR_IF(!b->bm_pages) return 0;\r\nreturn b->bm_words;\r\n}\r\nunsigned long drbd_bm_bits(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nERR_IF(!b) return 0;\r\nreturn b->bm_bits;\r\n}\r\nvoid drbd_bm_merge_lel(struct drbd_conf *mdev, size_t offset, size_t number,\r\nunsigned long *buffer)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nunsigned long *p_addr, *bm;\r\nunsigned long word, bits;\r\nunsigned int idx;\r\nsize_t end, do_now;\r\nend = offset + number;\r\nERR_IF(!b) return;\r\nERR_IF(!b->bm_pages) return;\r\nif (number == 0)\r\nreturn;\r\nWARN_ON(offset >= b->bm_words);\r\nWARN_ON(end > b->bm_words);\r\nspin_lock_irq(&b->bm_lock);\r\nwhile (offset < end) {\r\ndo_now = min_t(size_t, ALIGN(offset+1, LWPP), end) - offset;\r\nidx = bm_word_to_page_idx(b, offset);\r\np_addr = bm_map_pidx(b, idx);\r\nbm = p_addr + MLPP(offset);\r\noffset += do_now;\r\nwhile (do_now--) {\r\nbits = hweight_long(*bm);\r\nword = *bm | *buffer++;\r\n*bm++ = word;\r\nb->bm_set += hweight_long(word) - bits;\r\n}\r\nbm_unmap(p_addr);\r\nbm_set_page_need_writeout(b->bm_pages[idx]);\r\n}\r\nif (end == b->bm_words)\r\nb->bm_set -= bm_clear_surplus(b);\r\nspin_unlock_irq(&b->bm_lock);\r\n}\r\nvoid drbd_bm_get_lel(struct drbd_conf *mdev, size_t offset, size_t number,\r\nunsigned long *buffer)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nunsigned long *p_addr, *bm;\r\nsize_t end, do_now;\r\nend = offset + number;\r\nERR_IF(!b) return;\r\nERR_IF(!b->bm_pages) return;\r\nspin_lock_irq(&b->bm_lock);\r\nif ((offset >= b->bm_words) ||\r\n(end > b->bm_words) ||\r\n(number <= 0))\r\ndev_err(DEV, "offset=%lu number=%lu bm_words=%lu\n",\r\n(unsigned long) offset,\r\n(unsigned long) number,\r\n(unsigned long) b->bm_words);\r\nelse {\r\nwhile (offset < end) {\r\ndo_now = min_t(size_t, ALIGN(offset+1, LWPP), end) - offset;\r\np_addr = bm_map_pidx(b, bm_word_to_page_idx(b, offset));\r\nbm = p_addr + MLPP(offset);\r\noffset += do_now;\r\nwhile (do_now--)\r\n*buffer++ = *bm++;\r\nbm_unmap(p_addr);\r\n}\r\n}\r\nspin_unlock_irq(&b->bm_lock);\r\n}\r\nvoid drbd_bm_set_all(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nERR_IF(!b) return;\r\nERR_IF(!b->bm_pages) return;\r\nspin_lock_irq(&b->bm_lock);\r\nbm_memset(b, 0, 0xff, b->bm_words);\r\n(void)bm_clear_surplus(b);\r\nb->bm_set = b->bm_bits;\r\nspin_unlock_irq(&b->bm_lock);\r\n}\r\nvoid drbd_bm_clear_all(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nERR_IF(!b) return;\r\nERR_IF(!b->bm_pages) return;\r\nspin_lock_irq(&b->bm_lock);\r\nbm_memset(b, 0, 0, b->bm_words);\r\nb->bm_set = 0;\r\nspin_unlock_irq(&b->bm_lock);\r\n}\r\nstatic void bm_aio_ctx_destroy(struct kref *kref)\r\n{\r\nstruct bm_aio_ctx *ctx = container_of(kref, struct bm_aio_ctx, kref);\r\nput_ldev(ctx->mdev);\r\nkfree(ctx);\r\n}\r\nstatic void bm_async_io_complete(struct bio *bio, int error)\r\n{\r\nstruct bm_aio_ctx *ctx = bio->bi_private;\r\nstruct drbd_conf *mdev = ctx->mdev;\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nunsigned int idx = bm_page_to_idx(bio->bi_io_vec[0].bv_page);\r\nint uptodate = bio_flagged(bio, BIO_UPTODATE);\r\nif (!error && !uptodate)\r\nerror = -EIO;\r\nif ((ctx->flags & BM_AIO_COPY_PAGES) == 0 &&\r\n!bm_test_page_unchanged(b->bm_pages[idx]))\r\ndev_warn(DEV, "bitmap page idx %u changed during IO!\n", idx);\r\nif (error) {\r\nctx->error = error;\r\nbm_set_page_io_err(b->bm_pages[idx]);\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_err(DEV, "IO ERROR %d on bitmap page idx %u\n",\r\nerror, idx);\r\n} else {\r\nbm_clear_page_io_err(b->bm_pages[idx]);\r\ndynamic_dev_dbg(DEV, "bitmap page idx %u completed\n", idx);\r\n}\r\nbm_page_unlock_io(mdev, idx);\r\nif (ctx->flags & BM_AIO_COPY_PAGES)\r\nmempool_free(bio->bi_io_vec[0].bv_page, drbd_md_io_page_pool);\r\nbio_put(bio);\r\nif (atomic_dec_and_test(&ctx->in_flight)) {\r\nctx->done = 1;\r\nwake_up(&mdev->misc_wait);\r\nkref_put(&ctx->kref, &bm_aio_ctx_destroy);\r\n}\r\n}\r\nstatic void bm_page_io_async(struct bm_aio_ctx *ctx, int page_nr, int rw) __must_hold(local)\r\n{\r\nstruct bio *bio = bio_alloc_drbd(GFP_NOIO);\r\nstruct drbd_conf *mdev = ctx->mdev;\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nstruct page *page;\r\nunsigned int len;\r\nsector_t on_disk_sector =\r\nmdev->ldev->md.md_offset + mdev->ldev->md.bm_offset;\r\non_disk_sector += ((sector_t)page_nr) << (PAGE_SHIFT-9);\r\nlen = min_t(unsigned int, PAGE_SIZE,\r\n(drbd_md_last_sector(mdev->ldev) - on_disk_sector + 1)<<9);\r\nbm_page_lock_io(mdev, page_nr);\r\nbm_set_page_unchanged(b->bm_pages[page_nr]);\r\nif (ctx->flags & BM_AIO_COPY_PAGES) {\r\nvoid *src, *dest;\r\npage = mempool_alloc(drbd_md_io_page_pool, __GFP_HIGHMEM|__GFP_WAIT);\r\ndest = kmap_atomic(page);\r\nsrc = kmap_atomic(b->bm_pages[page_nr]);\r\nmemcpy(dest, src, PAGE_SIZE);\r\nkunmap_atomic(src);\r\nkunmap_atomic(dest);\r\nbm_store_page_idx(page, page_nr);\r\n} else\r\npage = b->bm_pages[page_nr];\r\nbio->bi_bdev = mdev->ldev->md_bdev;\r\nbio->bi_sector = on_disk_sector;\r\nbio_add_page(bio, page, len, 0);\r\nbio->bi_private = ctx;\r\nbio->bi_end_io = bm_async_io_complete;\r\nif (drbd_insert_fault(mdev, (rw & WRITE) ? DRBD_FAULT_MD_WR : DRBD_FAULT_MD_RD)) {\r\nbio->bi_rw |= rw;\r\nbio_endio(bio, -EIO);\r\n} else {\r\nsubmit_bio(rw, bio);\r\natomic_add(len >> 9, &mdev->rs_sect_ev);\r\n}\r\n}\r\nstatic int bm_rw(struct drbd_conf *mdev, int rw, unsigned flags, unsigned lazy_writeout_upper_idx) __must_hold(local)\r\n{\r\nstruct bm_aio_ctx *ctx;\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nint num_pages, i, count = 0;\r\nunsigned long now;\r\nchar ppb[10];\r\nint err = 0;\r\nctx = kmalloc(sizeof(struct bm_aio_ctx), GFP_NOIO);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\n*ctx = (struct bm_aio_ctx) {\r\n.mdev = mdev,\r\n.in_flight = ATOMIC_INIT(1),\r\n.done = 0,\r\n.flags = flags,\r\n.error = 0,\r\n.kref = { ATOMIC_INIT(2) },\r\n};\r\nif (!get_ldev_if_state(mdev, D_ATTACHING)) {\r\ndev_err(DEV, "ASSERT FAILED: get_ldev_if_state() == 1 in bm_rw()\n");\r\nkfree(ctx);\r\nreturn -ENODEV;\r\n}\r\nif (!ctx->flags)\r\nWARN_ON(!(BM_LOCKED_MASK & b->bm_flags));\r\nnum_pages = b->bm_number_of_pages;\r\nnow = jiffies;\r\nfor (i = 0; i < num_pages; i++) {\r\nif (lazy_writeout_upper_idx && i == lazy_writeout_upper_idx)\r\nbreak;\r\nif (rw & WRITE) {\r\nif (!(flags & BM_WRITE_ALL_PAGES) &&\r\nbm_test_page_unchanged(b->bm_pages[i])) {\r\ndynamic_dev_dbg(DEV, "skipped bm write for idx %u\n", i);\r\ncontinue;\r\n}\r\nif (lazy_writeout_upper_idx &&\r\n!bm_test_page_lazy_writeout(b->bm_pages[i])) {\r\ndynamic_dev_dbg(DEV, "skipped bm lazy write for idx %u\n", i);\r\ncontinue;\r\n}\r\n}\r\natomic_inc(&ctx->in_flight);\r\nbm_page_io_async(ctx, i, rw);\r\n++count;\r\ncond_resched();\r\n}\r\nif (!atomic_dec_and_test(&ctx->in_flight))\r\nwait_until_done_or_disk_failure(mdev, mdev->ldev, &ctx->done);\r\nelse\r\nkref_put(&ctx->kref, &bm_aio_ctx_destroy);\r\ndev_info(DEV, "bitmap %s of %u pages took %lu jiffies\n",\r\nrw == WRITE ? "WRITE" : "READ",\r\ncount, jiffies - now);\r\nif (ctx->error) {\r\ndev_alert(DEV, "we had at least one MD IO ERROR during bitmap IO\n");\r\ndrbd_chk_io_error(mdev, 1, DRBD_META_IO_ERROR);\r\nerr = -EIO;\r\n}\r\nif (atomic_read(&ctx->in_flight))\r\nerr = -EIO;\r\nnow = jiffies;\r\nif (rw == WRITE) {\r\ndrbd_md_flush(mdev);\r\n} else {\r\nb->bm_set = bm_count_bits(b);\r\ndev_info(DEV, "recounting of set bits took additional %lu jiffies\n",\r\njiffies - now);\r\n}\r\nnow = b->bm_set;\r\ndev_info(DEV, "%s (%lu bits) marked out-of-sync by on disk bit-map.\n",\r\nppsize(ppb, now << (BM_BLOCK_SHIFT-10)), now);\r\nkref_put(&ctx->kref, &bm_aio_ctx_destroy);\r\nreturn err;\r\n}\r\nint drbd_bm_read(struct drbd_conf *mdev) __must_hold(local)\r\n{\r\nreturn bm_rw(mdev, READ, 0, 0);\r\n}\r\nint drbd_bm_write(struct drbd_conf *mdev) __must_hold(local)\r\n{\r\nreturn bm_rw(mdev, WRITE, 0, 0);\r\n}\r\nint drbd_bm_write_all(struct drbd_conf *mdev) __must_hold(local)\r\n{\r\nreturn bm_rw(mdev, WRITE, BM_WRITE_ALL_PAGES, 0);\r\n}\r\nint drbd_bm_write_lazy(struct drbd_conf *mdev, unsigned upper_idx) __must_hold(local)\r\n{\r\nreturn bm_rw(mdev, WRITE, BM_AIO_COPY_PAGES, upper_idx);\r\n}\r\nint drbd_bm_write_copy_pages(struct drbd_conf *mdev) __must_hold(local)\r\n{\r\nreturn bm_rw(mdev, WRITE, BM_AIO_COPY_PAGES, 0);\r\n}\r\nint drbd_bm_write_page(struct drbd_conf *mdev, unsigned int idx) __must_hold(local)\r\n{\r\nstruct bm_aio_ctx *ctx;\r\nint err;\r\nif (bm_test_page_unchanged(mdev->bitmap->bm_pages[idx])) {\r\ndynamic_dev_dbg(DEV, "skipped bm page write for idx %u\n", idx);\r\nreturn 0;\r\n}\r\nctx = kmalloc(sizeof(struct bm_aio_ctx), GFP_NOIO);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\n*ctx = (struct bm_aio_ctx) {\r\n.mdev = mdev,\r\n.in_flight = ATOMIC_INIT(1),\r\n.done = 0,\r\n.flags = BM_AIO_COPY_PAGES,\r\n.error = 0,\r\n.kref = { ATOMIC_INIT(2) },\r\n};\r\nif (!get_ldev_if_state(mdev, D_ATTACHING)) {\r\ndev_err(DEV, "ASSERT FAILED: get_ldev_if_state() == 1 in drbd_bm_write_page()\n");\r\nkfree(ctx);\r\nreturn -ENODEV;\r\n}\r\nbm_page_io_async(ctx, idx, WRITE_SYNC);\r\nwait_until_done_or_disk_failure(mdev, mdev->ldev, &ctx->done);\r\nif (ctx->error)\r\ndrbd_chk_io_error(mdev, 1, DRBD_META_IO_ERROR);\r\nmdev->bm_writ_cnt++;\r\nerr = atomic_read(&ctx->in_flight) ? -EIO : ctx->error;\r\nkref_put(&ctx->kref, &bm_aio_ctx_destroy);\r\nreturn err;\r\n}\r\nstatic unsigned long __bm_find_next(struct drbd_conf *mdev, unsigned long bm_fo,\r\nconst int find_zero_bit)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nunsigned long *p_addr;\r\nunsigned long bit_offset;\r\nunsigned i;\r\nif (bm_fo > b->bm_bits) {\r\ndev_err(DEV, "bm_fo=%lu bm_bits=%lu\n", bm_fo, b->bm_bits);\r\nbm_fo = DRBD_END_OF_BITMAP;\r\n} else {\r\nwhile (bm_fo < b->bm_bits) {\r\nbit_offset = bm_fo & ~BITS_PER_PAGE_MASK;\r\np_addr = __bm_map_pidx(b, bm_bit_to_page_idx(b, bm_fo));\r\nif (find_zero_bit)\r\ni = find_next_zero_bit_le(p_addr,\r\nPAGE_SIZE*8, bm_fo & BITS_PER_PAGE_MASK);\r\nelse\r\ni = find_next_bit_le(p_addr,\r\nPAGE_SIZE*8, bm_fo & BITS_PER_PAGE_MASK);\r\n__bm_unmap(p_addr);\r\nif (i < PAGE_SIZE*8) {\r\nbm_fo = bit_offset + i;\r\nif (bm_fo >= b->bm_bits)\r\nbreak;\r\ngoto found;\r\n}\r\nbm_fo = bit_offset + PAGE_SIZE*8;\r\n}\r\nbm_fo = DRBD_END_OF_BITMAP;\r\n}\r\nfound:\r\nreturn bm_fo;\r\n}\r\nstatic unsigned long bm_find_next(struct drbd_conf *mdev,\r\nunsigned long bm_fo, const int find_zero_bit)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nunsigned long i = DRBD_END_OF_BITMAP;\r\nERR_IF(!b) return i;\r\nERR_IF(!b->bm_pages) return i;\r\nspin_lock_irq(&b->bm_lock);\r\nif (BM_DONT_TEST & b->bm_flags)\r\nbm_print_lock_info(mdev);\r\ni = __bm_find_next(mdev, bm_fo, find_zero_bit);\r\nspin_unlock_irq(&b->bm_lock);\r\nreturn i;\r\n}\r\nunsigned long drbd_bm_find_next(struct drbd_conf *mdev, unsigned long bm_fo)\r\n{\r\nreturn bm_find_next(mdev, bm_fo, 0);\r\n}\r\nunsigned long _drbd_bm_find_next(struct drbd_conf *mdev, unsigned long bm_fo)\r\n{\r\nreturn __bm_find_next(mdev, bm_fo, 0);\r\n}\r\nunsigned long _drbd_bm_find_next_zero(struct drbd_conf *mdev, unsigned long bm_fo)\r\n{\r\nreturn __bm_find_next(mdev, bm_fo, 1);\r\n}\r\nstatic int __bm_change_bits_to(struct drbd_conf *mdev, const unsigned long s,\r\nunsigned long e, int val)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nunsigned long *p_addr = NULL;\r\nunsigned long bitnr;\r\nunsigned int last_page_nr = -1U;\r\nint c = 0;\r\nint changed_total = 0;\r\nif (e >= b->bm_bits) {\r\ndev_err(DEV, "ASSERT FAILED: bit_s=%lu bit_e=%lu bm_bits=%lu\n",\r\ns, e, b->bm_bits);\r\ne = b->bm_bits ? b->bm_bits -1 : 0;\r\n}\r\nfor (bitnr = s; bitnr <= e; bitnr++) {\r\nunsigned int page_nr = bm_bit_to_page_idx(b, bitnr);\r\nif (page_nr != last_page_nr) {\r\nif (p_addr)\r\n__bm_unmap(p_addr);\r\nif (c < 0)\r\nbm_set_page_lazy_writeout(b->bm_pages[last_page_nr]);\r\nelse if (c > 0)\r\nbm_set_page_need_writeout(b->bm_pages[last_page_nr]);\r\nchanged_total += c;\r\nc = 0;\r\np_addr = __bm_map_pidx(b, page_nr);\r\nlast_page_nr = page_nr;\r\n}\r\nif (val)\r\nc += (0 == __test_and_set_bit_le(bitnr & BITS_PER_PAGE_MASK, p_addr));\r\nelse\r\nc -= (0 != __test_and_clear_bit_le(bitnr & BITS_PER_PAGE_MASK, p_addr));\r\n}\r\nif (p_addr)\r\n__bm_unmap(p_addr);\r\nif (c < 0)\r\nbm_set_page_lazy_writeout(b->bm_pages[last_page_nr]);\r\nelse if (c > 0)\r\nbm_set_page_need_writeout(b->bm_pages[last_page_nr]);\r\nchanged_total += c;\r\nb->bm_set += changed_total;\r\nreturn changed_total;\r\n}\r\nstatic int bm_change_bits_to(struct drbd_conf *mdev, const unsigned long s,\r\nconst unsigned long e, int val)\r\n{\r\nunsigned long flags;\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nint c = 0;\r\nERR_IF(!b) return 1;\r\nERR_IF(!b->bm_pages) return 0;\r\nspin_lock_irqsave(&b->bm_lock, flags);\r\nif ((val ? BM_DONT_SET : BM_DONT_CLEAR) & b->bm_flags)\r\nbm_print_lock_info(mdev);\r\nc = __bm_change_bits_to(mdev, s, e, val);\r\nspin_unlock_irqrestore(&b->bm_lock, flags);\r\nreturn c;\r\n}\r\nint drbd_bm_set_bits(struct drbd_conf *mdev, const unsigned long s, const unsigned long e)\r\n{\r\nreturn bm_change_bits_to(mdev, s, e, 1);\r\n}\r\nint drbd_bm_clear_bits(struct drbd_conf *mdev, const unsigned long s, const unsigned long e)\r\n{\r\nreturn -bm_change_bits_to(mdev, s, e, 0);\r\n}\r\nstatic inline void bm_set_full_words_within_one_page(struct drbd_bitmap *b,\r\nint page_nr, int first_word, int last_word)\r\n{\r\nint i;\r\nint bits;\r\nunsigned long *paddr = kmap_atomic(b->bm_pages[page_nr]);\r\nfor (i = first_word; i < last_word; i++) {\r\nbits = hweight_long(paddr[i]);\r\npaddr[i] = ~0UL;\r\nb->bm_set += BITS_PER_LONG - bits;\r\n}\r\nkunmap_atomic(paddr);\r\n}\r\nvoid _drbd_bm_set_bits(struct drbd_conf *mdev, const unsigned long s, const unsigned long e)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nunsigned long sl = ALIGN(s,BITS_PER_LONG);\r\nunsigned long el = (e+1) & ~((unsigned long)BITS_PER_LONG-1);\r\nint first_page;\r\nint last_page;\r\nint page_nr;\r\nint first_word;\r\nint last_word;\r\nif (e - s <= 3*BITS_PER_LONG) {\r\nspin_lock_irq(&b->bm_lock);\r\n__bm_change_bits_to(mdev, s, e, 1);\r\nspin_unlock_irq(&b->bm_lock);\r\nreturn;\r\n}\r\nspin_lock_irq(&b->bm_lock);\r\nif (sl)\r\n__bm_change_bits_to(mdev, s, sl-1, 1);\r\nfirst_page = sl >> (3 + PAGE_SHIFT);\r\nlast_page = el >> (3 + PAGE_SHIFT);\r\nfirst_word = MLPP(sl >> LN2_BPL);\r\nlast_word = LWPP;\r\nfor (page_nr = first_page; page_nr < last_page; page_nr++) {\r\nbm_set_full_words_within_one_page(mdev->bitmap, page_nr, first_word, last_word);\r\nspin_unlock_irq(&b->bm_lock);\r\ncond_resched();\r\nfirst_word = 0;\r\nspin_lock_irq(&b->bm_lock);\r\n}\r\nlast_word = MLPP(el >> LN2_BPL);\r\nif (last_word)\r\nbm_set_full_words_within_one_page(mdev->bitmap, last_page, first_word, last_word);\r\nif (el <= e)\r\n__bm_change_bits_to(mdev, el, e, 1);\r\nspin_unlock_irq(&b->bm_lock);\r\n}\r\nint drbd_bm_test_bit(struct drbd_conf *mdev, const unsigned long bitnr)\r\n{\r\nunsigned long flags;\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nunsigned long *p_addr;\r\nint i;\r\nERR_IF(!b) return 0;\r\nERR_IF(!b->bm_pages) return 0;\r\nspin_lock_irqsave(&b->bm_lock, flags);\r\nif (BM_DONT_TEST & b->bm_flags)\r\nbm_print_lock_info(mdev);\r\nif (bitnr < b->bm_bits) {\r\np_addr = bm_map_pidx(b, bm_bit_to_page_idx(b, bitnr));\r\ni = test_bit_le(bitnr & BITS_PER_PAGE_MASK, p_addr) ? 1 : 0;\r\nbm_unmap(p_addr);\r\n} else if (bitnr == b->bm_bits) {\r\ni = -1;\r\n} else {\r\ndev_err(DEV, "bitnr=%lu > bm_bits=%lu\n", bitnr, b->bm_bits);\r\ni = 0;\r\n}\r\nspin_unlock_irqrestore(&b->bm_lock, flags);\r\nreturn i;\r\n}\r\nint drbd_bm_count_bits(struct drbd_conf *mdev, const unsigned long s, const unsigned long e)\r\n{\r\nunsigned long flags;\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nunsigned long *p_addr = NULL;\r\nunsigned long bitnr;\r\nunsigned int page_nr = -1U;\r\nint c = 0;\r\nERR_IF(!b) return 1;\r\nERR_IF(!b->bm_pages) return 1;\r\nspin_lock_irqsave(&b->bm_lock, flags);\r\nif (BM_DONT_TEST & b->bm_flags)\r\nbm_print_lock_info(mdev);\r\nfor (bitnr = s; bitnr <= e; bitnr++) {\r\nunsigned int idx = bm_bit_to_page_idx(b, bitnr);\r\nif (page_nr != idx) {\r\npage_nr = idx;\r\nif (p_addr)\r\nbm_unmap(p_addr);\r\np_addr = bm_map_pidx(b, idx);\r\n}\r\nERR_IF (bitnr >= b->bm_bits) {\r\ndev_err(DEV, "bitnr=%lu bm_bits=%lu\n", bitnr, b->bm_bits);\r\n} else {\r\nc += (0 != test_bit_le(bitnr - (page_nr << (PAGE_SHIFT+3)), p_addr));\r\n}\r\n}\r\nif (p_addr)\r\nbm_unmap(p_addr);\r\nspin_unlock_irqrestore(&b->bm_lock, flags);\r\nreturn c;\r\n}\r\nint drbd_bm_e_weight(struct drbd_conf *mdev, unsigned long enr)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nint count, s, e;\r\nunsigned long flags;\r\nunsigned long *p_addr, *bm;\r\nERR_IF(!b) return 0;\r\nERR_IF(!b->bm_pages) return 0;\r\nspin_lock_irqsave(&b->bm_lock, flags);\r\nif (BM_DONT_TEST & b->bm_flags)\r\nbm_print_lock_info(mdev);\r\ns = S2W(enr);\r\ne = min((size_t)S2W(enr+1), b->bm_words);\r\ncount = 0;\r\nif (s < b->bm_words) {\r\nint n = e-s;\r\np_addr = bm_map_pidx(b, bm_word_to_page_idx(b, s));\r\nbm = p_addr + MLPP(s);\r\nwhile (n--)\r\ncount += hweight_long(*bm++);\r\nbm_unmap(p_addr);\r\n} else {\r\ndev_err(DEV, "start offset (%d) too large in drbd_bm_e_weight\n", s);\r\n}\r\nspin_unlock_irqrestore(&b->bm_lock, flags);\r\nreturn count;\r\n}\r\nunsigned long drbd_bm_ALe_set_all(struct drbd_conf *mdev, unsigned long al_enr)\r\n{\r\nstruct drbd_bitmap *b = mdev->bitmap;\r\nunsigned long *p_addr, *bm;\r\nunsigned long weight;\r\nunsigned long s, e;\r\nint count, i, do_now;\r\nERR_IF(!b) return 0;\r\nERR_IF(!b->bm_pages) return 0;\r\nspin_lock_irq(&b->bm_lock);\r\nif (BM_DONT_SET & b->bm_flags)\r\nbm_print_lock_info(mdev);\r\nweight = b->bm_set;\r\ns = al_enr * BM_WORDS_PER_AL_EXT;\r\ne = min_t(size_t, s + BM_WORDS_PER_AL_EXT, b->bm_words);\r\nD_ASSERT((e-1) >> (PAGE_SHIFT - LN2_BPL + 3)\r\n== s >> (PAGE_SHIFT - LN2_BPL + 3));\r\ncount = 0;\r\nif (s < b->bm_words) {\r\ni = do_now = e-s;\r\np_addr = bm_map_pidx(b, bm_word_to_page_idx(b, s));\r\nbm = p_addr + MLPP(s);\r\nwhile (i--) {\r\ncount += hweight_long(*bm);\r\n*bm = -1UL;\r\nbm++;\r\n}\r\nbm_unmap(p_addr);\r\nb->bm_set += do_now*BITS_PER_LONG - count;\r\nif (e == b->bm_words)\r\nb->bm_set -= bm_clear_surplus(b);\r\n} else {\r\ndev_err(DEV, "start offset (%lu) too large in drbd_bm_ALe_set_all\n", s);\r\n}\r\nweight = b->bm_set - weight;\r\nspin_unlock_irq(&b->bm_lock);\r\nreturn weight;\r\n}
