static size_t regmap_calc_reg_len(int max_val, char *buf, size_t buf_size)\r\n{\r\nsnprintf(buf, buf_size, "%x", max_val);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t regmap_name_read_file(struct file *file,\r\nchar __user *user_buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct regmap *map = file->private_data;\r\nint ret;\r\nchar *buf;\r\nbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = snprintf(buf, PAGE_SIZE, "%s\n", map->dev->driver->name);\r\nif (ret < 0) {\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint reg_len, val_len, tot_len;\r\nsize_t buf_pos = 0;\r\nloff_t p = 0;\r\nssize_t ret;\r\nint i;\r\nstruct regmap *map = file->private_data;\r\nchar *buf;\r\nunsigned int val;\r\nif (*ppos < 0 || !count)\r\nreturn -EINVAL;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nreg_len = regmap_calc_reg_len(map->max_register, buf, count);\r\nval_len = 2 * map->format.val_bytes;\r\ntot_len = reg_len + val_len + 3;\r\nfor (i = 0; i <= map->max_register; i += map->reg_stride) {\r\nif (!regmap_readable(map, i))\r\ncontinue;\r\nif (regmap_precious(map, i))\r\ncontinue;\r\nif (p >= *ppos) {\r\nif (buf_pos >= count - 1 - tot_len)\r\nbreak;\r\nsnprintf(buf + buf_pos, count - buf_pos, "%.*x: ",\r\nreg_len, i);\r\nbuf_pos += reg_len + 2;\r\nret = regmap_read(map, i, &val);\r\nif (ret == 0)\r\nsnprintf(buf + buf_pos, count - buf_pos,\r\n"%.*x", val_len, val);\r\nelse\r\nmemset(buf + buf_pos, 'X', val_len);\r\nbuf_pos += 2 * map->format.val_bytes;\r\nbuf[buf_pos++] = '\n';\r\n}\r\np += tot_len;\r\n}\r\nret = buf_pos;\r\nif (copy_to_user(user_buf, buf, buf_pos)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n*ppos += buf_pos;\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t regmap_map_write_file(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar buf[32];\r\nsize_t buf_size;\r\nchar *start = buf;\r\nunsigned long reg, value;\r\nstruct regmap *map = file->private_data;\r\nbuf_size = min(count, (sizeof(buf)-1));\r\nif (copy_from_user(buf, user_buf, buf_size))\r\nreturn -EFAULT;\r\nbuf[buf_size] = 0;\r\nwhile (*start == ' ')\r\nstart++;\r\nreg = simple_strtoul(start, &start, 16);\r\nwhile (*start == ' ')\r\nstart++;\r\nif (strict_strtoul(start, 16, &value))\r\nreturn -EINVAL;\r\nadd_taint(TAINT_USER);\r\nregmap_write(map, reg, value);\r\nreturn buf_size;\r\n}\r\nstatic ssize_t regmap_access_read_file(struct file *file,\r\nchar __user *user_buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nint reg_len, tot_len;\r\nsize_t buf_pos = 0;\r\nloff_t p = 0;\r\nssize_t ret;\r\nint i;\r\nstruct regmap *map = file->private_data;\r\nchar *buf;\r\nif (*ppos < 0 || !count)\r\nreturn -EINVAL;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nreg_len = regmap_calc_reg_len(map->max_register, buf, count);\r\ntot_len = reg_len + 10;\r\nfor (i = 0; i <= map->max_register; i += map->reg_stride) {\r\nif (!regmap_readable(map, i) && !regmap_writeable(map, i))\r\ncontinue;\r\nif (p >= *ppos) {\r\nif (buf_pos >= count - 1 - tot_len)\r\nbreak;\r\nsnprintf(buf + buf_pos, count - buf_pos,\r\n"%.*x: %c %c %c %c\n",\r\nreg_len, i,\r\nregmap_readable(map, i) ? 'y' : 'n',\r\nregmap_writeable(map, i) ? 'y' : 'n',\r\nregmap_volatile(map, i) ? 'y' : 'n',\r\nregmap_precious(map, i) ? 'y' : 'n');\r\nbuf_pos += tot_len;\r\n}\r\np += tot_len;\r\n}\r\nret = buf_pos;\r\nif (copy_to_user(user_buf, buf, buf_pos)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n*ppos += buf_pos;\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nvoid regmap_debugfs_init(struct regmap *map, const char *name)\r\n{\r\nif (name) {\r\nmap->debugfs_name = kasprintf(GFP_KERNEL, "%s-%s",\r\ndev_name(map->dev), name);\r\nname = map->debugfs_name;\r\n} else {\r\nname = dev_name(map->dev);\r\n}\r\nmap->debugfs = debugfs_create_dir(name, regmap_debugfs_root);\r\nif (!map->debugfs) {\r\ndev_warn(map->dev, "Failed to create debugfs directory\n");\r\nreturn;\r\n}\r\ndebugfs_create_file("name", 0400, map->debugfs,\r\nmap, &regmap_name_fops);\r\nif (map->max_register) {\r\ndebugfs_create_file("registers", 0400, map->debugfs,\r\nmap, &regmap_map_fops);\r\ndebugfs_create_file("access", 0400, map->debugfs,\r\nmap, &regmap_access_fops);\r\n}\r\nif (map->cache_type) {\r\ndebugfs_create_bool("cache_only", 0400, map->debugfs,\r\n&map->cache_only);\r\ndebugfs_create_bool("cache_dirty", 0400, map->debugfs,\r\n&map->cache_dirty);\r\ndebugfs_create_bool("cache_bypass", 0400, map->debugfs,\r\n&map->cache_bypass);\r\n}\r\n}\r\nvoid regmap_debugfs_exit(struct regmap *map)\r\n{\r\ndebugfs_remove_recursive(map->debugfs);\r\nkfree(map->debugfs_name);\r\n}\r\nvoid regmap_debugfs_initcall(void)\r\n{\r\nregmap_debugfs_root = debugfs_create_dir("regmap", NULL);\r\nif (!regmap_debugfs_root) {\r\npr_warn("regmap: Failed to create debugfs root\n");\r\nreturn;\r\n}\r\n}
