static int pcrypt_do_parallel(struct padata_priv *padata, unsigned int *cb_cpu,\r\nstruct padata_pcrypt *pcrypt)\r\n{\r\nunsigned int cpu_index, cpu, i;\r\nstruct pcrypt_cpumask *cpumask;\r\ncpu = *cb_cpu;\r\nrcu_read_lock_bh();\r\ncpumask = rcu_dereference(pcrypt->cb_cpumask);\r\nif (cpumask_test_cpu(cpu, cpumask->mask))\r\ngoto out;\r\nif (!cpumask_weight(cpumask->mask))\r\ngoto out;\r\ncpu_index = cpu % cpumask_weight(cpumask->mask);\r\ncpu = cpumask_first(cpumask->mask);\r\nfor (i = 0; i < cpu_index; i++)\r\ncpu = cpumask_next(cpu, cpumask->mask);\r\n*cb_cpu = cpu;\r\nout:\r\nrcu_read_unlock_bh();\r\nreturn padata_do_parallel(pcrypt->pinst, padata, cpu);\r\n}\r\nstatic int pcrypt_aead_setkey(struct crypto_aead *parent,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct pcrypt_aead_ctx *ctx = crypto_aead_ctx(parent);\r\nreturn crypto_aead_setkey(ctx->child, key, keylen);\r\n}\r\nstatic int pcrypt_aead_setauthsize(struct crypto_aead *parent,\r\nunsigned int authsize)\r\n{\r\nstruct pcrypt_aead_ctx *ctx = crypto_aead_ctx(parent);\r\nreturn crypto_aead_setauthsize(ctx->child, authsize);\r\n}\r\nstatic void pcrypt_aead_serial(struct padata_priv *padata)\r\n{\r\nstruct pcrypt_request *preq = pcrypt_padata_request(padata);\r\nstruct aead_request *req = pcrypt_request_ctx(preq);\r\naead_request_complete(req->base.data, padata->info);\r\n}\r\nstatic void pcrypt_aead_giv_serial(struct padata_priv *padata)\r\n{\r\nstruct pcrypt_request *preq = pcrypt_padata_request(padata);\r\nstruct aead_givcrypt_request *req = pcrypt_request_ctx(preq);\r\naead_request_complete(req->areq.base.data, padata->info);\r\n}\r\nstatic void pcrypt_aead_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nstruct pcrypt_request *preq = aead_request_ctx(req);\r\nstruct padata_priv *padata = pcrypt_request_padata(preq);\r\npadata->info = err;\r\nreq->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\npadata_do_serial(padata);\r\n}\r\nstatic void pcrypt_aead_enc(struct padata_priv *padata)\r\n{\r\nstruct pcrypt_request *preq = pcrypt_padata_request(padata);\r\nstruct aead_request *req = pcrypt_request_ctx(preq);\r\npadata->info = crypto_aead_encrypt(req);\r\nif (padata->info == -EINPROGRESS)\r\nreturn;\r\npadata_do_serial(padata);\r\n}\r\nstatic int pcrypt_aead_encrypt(struct aead_request *req)\r\n{\r\nint err;\r\nstruct pcrypt_request *preq = aead_request_ctx(req);\r\nstruct aead_request *creq = pcrypt_request_ctx(preq);\r\nstruct padata_priv *padata = pcrypt_request_padata(preq);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct pcrypt_aead_ctx *ctx = crypto_aead_ctx(aead);\r\nu32 flags = aead_request_flags(req);\r\nmemset(padata, 0, sizeof(struct padata_priv));\r\npadata->parallel = pcrypt_aead_enc;\r\npadata->serial = pcrypt_aead_serial;\r\naead_request_set_tfm(creq, ctx->child);\r\naead_request_set_callback(creq, flags & ~CRYPTO_TFM_REQ_MAY_SLEEP,\r\npcrypt_aead_done, req);\r\naead_request_set_crypt(creq, req->src, req->dst,\r\nreq->cryptlen, req->iv);\r\naead_request_set_assoc(creq, req->assoc, req->assoclen);\r\nerr = pcrypt_do_parallel(padata, &ctx->cb_cpu, &pencrypt);\r\nif (!err)\r\nreturn -EINPROGRESS;\r\nreturn err;\r\n}\r\nstatic void pcrypt_aead_dec(struct padata_priv *padata)\r\n{\r\nstruct pcrypt_request *preq = pcrypt_padata_request(padata);\r\nstruct aead_request *req = pcrypt_request_ctx(preq);\r\npadata->info = crypto_aead_decrypt(req);\r\nif (padata->info == -EINPROGRESS)\r\nreturn;\r\npadata_do_serial(padata);\r\n}\r\nstatic int pcrypt_aead_decrypt(struct aead_request *req)\r\n{\r\nint err;\r\nstruct pcrypt_request *preq = aead_request_ctx(req);\r\nstruct aead_request *creq = pcrypt_request_ctx(preq);\r\nstruct padata_priv *padata = pcrypt_request_padata(preq);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct pcrypt_aead_ctx *ctx = crypto_aead_ctx(aead);\r\nu32 flags = aead_request_flags(req);\r\nmemset(padata, 0, sizeof(struct padata_priv));\r\npadata->parallel = pcrypt_aead_dec;\r\npadata->serial = pcrypt_aead_serial;\r\naead_request_set_tfm(creq, ctx->child);\r\naead_request_set_callback(creq, flags & ~CRYPTO_TFM_REQ_MAY_SLEEP,\r\npcrypt_aead_done, req);\r\naead_request_set_crypt(creq, req->src, req->dst,\r\nreq->cryptlen, req->iv);\r\naead_request_set_assoc(creq, req->assoc, req->assoclen);\r\nerr = pcrypt_do_parallel(padata, &ctx->cb_cpu, &pdecrypt);\r\nif (!err)\r\nreturn -EINPROGRESS;\r\nreturn err;\r\n}\r\nstatic void pcrypt_aead_givenc(struct padata_priv *padata)\r\n{\r\nstruct pcrypt_request *preq = pcrypt_padata_request(padata);\r\nstruct aead_givcrypt_request *req = pcrypt_request_ctx(preq);\r\npadata->info = crypto_aead_givencrypt(req);\r\nif (padata->info == -EINPROGRESS)\r\nreturn;\r\npadata_do_serial(padata);\r\n}\r\nstatic int pcrypt_aead_givencrypt(struct aead_givcrypt_request *req)\r\n{\r\nint err;\r\nstruct aead_request *areq = &req->areq;\r\nstruct pcrypt_request *preq = aead_request_ctx(areq);\r\nstruct aead_givcrypt_request *creq = pcrypt_request_ctx(preq);\r\nstruct padata_priv *padata = pcrypt_request_padata(preq);\r\nstruct crypto_aead *aead = aead_givcrypt_reqtfm(req);\r\nstruct pcrypt_aead_ctx *ctx = crypto_aead_ctx(aead);\r\nu32 flags = aead_request_flags(areq);\r\nmemset(padata, 0, sizeof(struct padata_priv));\r\npadata->parallel = pcrypt_aead_givenc;\r\npadata->serial = pcrypt_aead_giv_serial;\r\naead_givcrypt_set_tfm(creq, ctx->child);\r\naead_givcrypt_set_callback(creq, flags & ~CRYPTO_TFM_REQ_MAY_SLEEP,\r\npcrypt_aead_done, areq);\r\naead_givcrypt_set_crypt(creq, areq->src, areq->dst,\r\nareq->cryptlen, areq->iv);\r\naead_givcrypt_set_assoc(creq, areq->assoc, areq->assoclen);\r\naead_givcrypt_set_giv(creq, req->giv, req->seq);\r\nerr = pcrypt_do_parallel(padata, &ctx->cb_cpu, &pencrypt);\r\nif (!err)\r\nreturn -EINPROGRESS;\r\nreturn err;\r\n}\r\nstatic int pcrypt_aead_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nint cpu, cpu_index;\r\nstruct crypto_instance *inst = crypto_tfm_alg_instance(tfm);\r\nstruct pcrypt_instance_ctx *ictx = crypto_instance_ctx(inst);\r\nstruct pcrypt_aead_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_aead *cipher;\r\nictx->tfm_count++;\r\ncpu_index = ictx->tfm_count % cpumask_weight(cpu_online_mask);\r\nctx->cb_cpu = cpumask_first(cpu_online_mask);\r\nfor (cpu = 0; cpu < cpu_index; cpu++)\r\nctx->cb_cpu = cpumask_next(ctx->cb_cpu, cpu_online_mask);\r\ncipher = crypto_spawn_aead(crypto_instance_ctx(inst));\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\ntfm->crt_aead.reqsize = sizeof(struct pcrypt_request)\r\n+ sizeof(struct aead_givcrypt_request)\r\n+ crypto_aead_reqsize(cipher);\r\nreturn 0;\r\n}\r\nstatic void pcrypt_aead_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct pcrypt_aead_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_aead(ctx->child);\r\n}\r\nstatic struct crypto_instance *pcrypt_alloc_instance(struct crypto_alg *alg)\r\n{\r\nstruct crypto_instance *inst;\r\nstruct pcrypt_instance_ctx *ctx;\r\nint err;\r\ninst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\r\nif (!inst) {\r\ninst = ERR_PTR(-ENOMEM);\r\ngoto out;\r\n}\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"pcrypt(%s)", alg->cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\r\ngoto out_free_inst;\r\nmemcpy(inst->alg.cra_name, alg->cra_name, CRYPTO_MAX_ALG_NAME);\r\nctx = crypto_instance_ctx(inst);\r\nerr = crypto_init_spawn(&ctx->spawn, alg, inst,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (err)\r\ngoto out_free_inst;\r\ninst->alg.cra_priority = alg->cra_priority + 100;\r\ninst->alg.cra_blocksize = alg->cra_blocksize;\r\ninst->alg.cra_alignmask = alg->cra_alignmask;\r\nout:\r\nreturn inst;\r\nout_free_inst:\r\nkfree(inst);\r\ninst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic struct crypto_instance *pcrypt_alloc_aead(struct rtattr **tb,\r\nu32 type, u32 mask)\r\n{\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *alg;\r\nalg = crypto_get_attr_alg(tb, type, (mask & CRYPTO_ALG_TYPE_MASK));\r\nif (IS_ERR(alg))\r\nreturn ERR_CAST(alg);\r\ninst = pcrypt_alloc_instance(alg);\r\nif (IS_ERR(inst))\r\ngoto out_put_alg;\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC;\r\ninst->alg.cra_type = &crypto_aead_type;\r\ninst->alg.cra_aead.ivsize = alg->cra_aead.ivsize;\r\ninst->alg.cra_aead.geniv = alg->cra_aead.geniv;\r\ninst->alg.cra_aead.maxauthsize = alg->cra_aead.maxauthsize;\r\ninst->alg.cra_ctxsize = sizeof(struct pcrypt_aead_ctx);\r\ninst->alg.cra_init = pcrypt_aead_init_tfm;\r\ninst->alg.cra_exit = pcrypt_aead_exit_tfm;\r\ninst->alg.cra_aead.setkey = pcrypt_aead_setkey;\r\ninst->alg.cra_aead.setauthsize = pcrypt_aead_setauthsize;\r\ninst->alg.cra_aead.encrypt = pcrypt_aead_encrypt;\r\ninst->alg.cra_aead.decrypt = pcrypt_aead_decrypt;\r\ninst->alg.cra_aead.givencrypt = pcrypt_aead_givencrypt;\r\nout_put_alg:\r\ncrypto_mod_put(alg);\r\nreturn inst;\r\n}\r\nstatic struct crypto_instance *pcrypt_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn ERR_CAST(algt);\r\nswitch (algt->type & algt->mask & CRYPTO_ALG_TYPE_MASK) {\r\ncase CRYPTO_ALG_TYPE_AEAD:\r\nreturn pcrypt_alloc_aead(tb, algt->type, algt->mask);\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic void pcrypt_free(struct crypto_instance *inst)\r\n{\r\nstruct pcrypt_instance_ctx *ctx = crypto_instance_ctx(inst);\r\ncrypto_drop_spawn(&ctx->spawn);\r\nkfree(inst);\r\n}\r\nstatic int pcrypt_cpumask_change_notify(struct notifier_block *self,\r\nunsigned long val, void *data)\r\n{\r\nstruct padata_pcrypt *pcrypt;\r\nstruct pcrypt_cpumask *new_mask, *old_mask;\r\nstruct padata_cpumask *cpumask = (struct padata_cpumask *)data;\r\nif (!(val & PADATA_CPU_SERIAL))\r\nreturn 0;\r\npcrypt = container_of(self, struct padata_pcrypt, nblock);\r\nnew_mask = kmalloc(sizeof(*new_mask), GFP_KERNEL);\r\nif (!new_mask)\r\nreturn -ENOMEM;\r\nif (!alloc_cpumask_var(&new_mask->mask, GFP_KERNEL)) {\r\nkfree(new_mask);\r\nreturn -ENOMEM;\r\n}\r\nold_mask = pcrypt->cb_cpumask;\r\ncpumask_copy(new_mask->mask, cpumask->cbcpu);\r\nrcu_assign_pointer(pcrypt->cb_cpumask, new_mask);\r\nsynchronize_rcu_bh();\r\nfree_cpumask_var(old_mask->mask);\r\nkfree(old_mask);\r\nreturn 0;\r\n}\r\nstatic int pcrypt_sysfs_add(struct padata_instance *pinst, const char *name)\r\n{\r\nint ret;\r\npinst->kobj.kset = pcrypt_kset;\r\nret = kobject_add(&pinst->kobj, NULL, name);\r\nif (!ret)\r\nkobject_uevent(&pinst->kobj, KOBJ_ADD);\r\nreturn ret;\r\n}\r\nstatic int pcrypt_init_padata(struct padata_pcrypt *pcrypt,\r\nconst char *name)\r\n{\r\nint ret = -ENOMEM;\r\nstruct pcrypt_cpumask *mask;\r\nget_online_cpus();\r\npcrypt->wq = alloc_workqueue(name,\r\nWQ_MEM_RECLAIM | WQ_CPU_INTENSIVE, 1);\r\nif (!pcrypt->wq)\r\ngoto err;\r\npcrypt->pinst = padata_alloc_possible(pcrypt->wq);\r\nif (!pcrypt->pinst)\r\ngoto err_destroy_workqueue;\r\nmask = kmalloc(sizeof(*mask), GFP_KERNEL);\r\nif (!mask)\r\ngoto err_free_padata;\r\nif (!alloc_cpumask_var(&mask->mask, GFP_KERNEL)) {\r\nkfree(mask);\r\ngoto err_free_padata;\r\n}\r\ncpumask_and(mask->mask, cpu_possible_mask, cpu_online_mask);\r\nrcu_assign_pointer(pcrypt->cb_cpumask, mask);\r\npcrypt->nblock.notifier_call = pcrypt_cpumask_change_notify;\r\nret = padata_register_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);\r\nif (ret)\r\ngoto err_free_cpumask;\r\nret = pcrypt_sysfs_add(pcrypt->pinst, name);\r\nif (ret)\r\ngoto err_unregister_notifier;\r\nput_online_cpus();\r\nreturn ret;\r\nerr_unregister_notifier:\r\npadata_unregister_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);\r\nerr_free_cpumask:\r\nfree_cpumask_var(mask->mask);\r\nkfree(mask);\r\nerr_free_padata:\r\npadata_free(pcrypt->pinst);\r\nerr_destroy_workqueue:\r\ndestroy_workqueue(pcrypt->wq);\r\nerr:\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)\r\n{\r\nfree_cpumask_var(pcrypt->cb_cpumask->mask);\r\nkfree(pcrypt->cb_cpumask);\r\npadata_stop(pcrypt->pinst);\r\npadata_unregister_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);\r\ndestroy_workqueue(pcrypt->wq);\r\npadata_free(pcrypt->pinst);\r\n}\r\nstatic int __init pcrypt_init(void)\r\n{\r\nint err = -ENOMEM;\r\npcrypt_kset = kset_create_and_add("pcrypt", NULL, kernel_kobj);\r\nif (!pcrypt_kset)\r\ngoto err;\r\nerr = pcrypt_init_padata(&pencrypt, "pencrypt");\r\nif (err)\r\ngoto err_unreg_kset;\r\nerr = pcrypt_init_padata(&pdecrypt, "pdecrypt");\r\nif (err)\r\ngoto err_deinit_pencrypt;\r\npadata_start(pencrypt.pinst);\r\npadata_start(pdecrypt.pinst);\r\nreturn crypto_register_template(&pcrypt_tmpl);\r\nerr_deinit_pencrypt:\r\npcrypt_fini_padata(&pencrypt);\r\nerr_unreg_kset:\r\nkset_unregister(pcrypt_kset);\r\nerr:\r\nreturn err;\r\n}\r\nstatic void __exit pcrypt_exit(void)\r\n{\r\npcrypt_fini_padata(&pencrypt);\r\npcrypt_fini_padata(&pdecrypt);\r\nkset_unregister(pcrypt_kset);\r\ncrypto_unregister_template(&pcrypt_tmpl);\r\n}
