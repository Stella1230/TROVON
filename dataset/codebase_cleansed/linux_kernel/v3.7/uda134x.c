static inline unsigned int uda134x_read_reg_cache(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nu8 *cache = codec->reg_cache;\r\nif (reg >= UDA134X_REGS_NUM)\r\nreturn -1;\r\nreturn cache[reg];\r\n}\r\nstatic inline void uda134x_write_reg_cache(struct snd_soc_codec *codec,\r\nu8 reg, unsigned int value)\r\n{\r\nu8 *cache = codec->reg_cache;\r\nif (reg >= UDA134X_REGS_NUM)\r\nreturn;\r\ncache[reg] = value;\r\n}\r\nstatic int uda134x_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nint ret;\r\nu8 addr;\r\nu8 data = value;\r\nstruct uda134x_platform_data *pd = codec->control_data;\r\npr_debug("%s reg: %02X, value:%02X\n", __func__, reg, value);\r\nif (reg >= UDA134X_REGS_NUM) {\r\nprintk(KERN_ERR "%s unknown register: reg: %u",\r\n__func__, reg);\r\nreturn -EINVAL;\r\n}\r\nuda134x_write_reg_cache(codec, reg, value);\r\nswitch (reg) {\r\ncase UDA134X_STATUS0:\r\ncase UDA134X_STATUS1:\r\naddr = UDA134X_STATUS_ADDR;\r\nbreak;\r\ncase UDA134X_DATA000:\r\ncase UDA134X_DATA001:\r\ncase UDA134X_DATA010:\r\ncase UDA134X_DATA011:\r\naddr = UDA134X_DATA0_ADDR;\r\nbreak;\r\ncase UDA134X_DATA1:\r\naddr = UDA134X_DATA1_ADDR;\r\nbreak;\r\ndefault:\r\naddr = (reg | UDA134X_EXTADDR_PREFIX);\r\nret = l3_write(&pd->l3,\r\nUDA134X_DATA0_ADDR, &addr, 1);\r\nif (ret != 1)\r\nreturn -EIO;\r\naddr = UDA134X_DATA0_ADDR;\r\ndata = (value | UDA134X_EXTDATA_PREFIX);\r\nbreak;\r\n}\r\nret = l3_write(&pd->l3,\r\naddr, &data, 1);\r\nif (ret != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic inline void uda134x_reset(struct snd_soc_codec *codec)\r\n{\r\nu8 reset_reg = uda134x_read_reg_cache(codec, UDA134X_STATUS0);\r\nuda134x_write(codec, UDA134X_STATUS0, reset_reg | (1<<6));\r\nmsleep(1);\r\nuda134x_write(codec, UDA134X_STATUS0, reset_reg & ~(1<<6));\r\n}\r\nstatic int uda134x_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 mute_reg = uda134x_read_reg_cache(codec, UDA134X_DATA010);\r\npr_debug("%s mute: %d\n", __func__, mute);\r\nif (mute)\r\nmute_reg |= (1<<2);\r\nelse\r\nmute_reg &= ~(1<<2);\r\nuda134x_write(codec, UDA134X_DATA010, mute_reg);\r\nreturn 0;\r\n}\r\nstatic int uda134x_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_pcm_runtime *master_runtime;\r\nif (uda134x->master_substream) {\r\nmaster_runtime = uda134x->master_substream->runtime;\r\npr_debug("%s constraining to %d bits at %d\n", __func__,\r\nmaster_runtime->sample_bits,\r\nmaster_runtime->rate);\r\nsnd_pcm_hw_constraint_minmax(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nmaster_runtime->rate,\r\nmaster_runtime->rate);\r\nsnd_pcm_hw_constraint_minmax(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_SAMPLE_BITS,\r\nmaster_runtime->sample_bits,\r\nmaster_runtime->sample_bits);\r\nuda134x->slave_substream = substream;\r\n} else\r\nuda134x->master_substream = substream;\r\nreturn 0;\r\n}\r\nstatic void uda134x_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\nif (uda134x->master_substream == substream)\r\nuda134x->master_substream = uda134x->slave_substream;\r\nuda134x->slave_substream = NULL;\r\n}\r\nstatic int uda134x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\nu8 hw_params;\r\nif (substream == uda134x->slave_substream) {\r\npr_debug("%s ignoring hw_params for slave substream\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nhw_params = uda134x_read_reg_cache(codec, UDA134X_STATUS0);\r\nhw_params &= STATUS0_SYSCLK_MASK;\r\nhw_params &= STATUS0_DAIFMT_MASK;\r\npr_debug("%s sysclk: %d, rate:%d\n", __func__,\r\nuda134x->sysclk, params_rate(params));\r\nswitch (uda134x->sysclk / params_rate(params)) {\r\ncase 512:\r\nbreak;\r\ncase 384:\r\nhw_params |= (1<<4);\r\nbreak;\r\ncase 256:\r\nhw_params |= (1<<5);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s unsupported fs\n", __func__);\r\nreturn -EINVAL;\r\n}\r\npr_debug("%s dai_fmt: %d, params_format:%d\n", __func__,\r\nuda134x->dai_fmt, params_format(params));\r\nswitch (uda134x->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nhw_params |= (1<<1);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S18_3LE:\r\nhw_params |= (1<<2);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nhw_params |= ((1<<2) | (1<<1));\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s unsupported format (right)\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nhw_params |= (1<<3);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s unsupported format\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nuda134x_write(codec, UDA134X_STATUS0, hw_params);\r\nreturn 0;\r\n}\r\nstatic int uda134x_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\npr_debug("%s clk_id: %d, freq: %u, dir: %d\n", __func__,\r\nclk_id, freq, dir);\r\nif ((freq >= (256 * 8000)) && (freq <= (512 * 48000))) {\r\nuda134x->sysclk = freq;\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "%s unsupported sysclk\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstatic int uda134x_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\npr_debug("%s fmt: %08X\n", __func__, fmt);\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS) {\r\nprintk(KERN_ERR "%s unsupported slave mode\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF) {\r\nprintk(KERN_ERR "%s unsupported clock inversion\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nuda134x->dai_fmt = fmt;\r\nreturn 0;\r\n}\r\nstatic int uda134x_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nu8 reg;\r\nstruct uda134x_platform_data *pd = codec->control_data;\r\nint i;\r\nu8 *cache = codec->reg_cache;\r\npr_debug("%s bias level %d\n", __func__, level);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nswitch (pd->model) {\r\ncase UDA134X_UDA1340:\r\ncase UDA134X_UDA1344:\r\ncase UDA134X_UDA1345:\r\nreg = uda134x_read_reg_cache(codec, UDA134X_DATA011);\r\nuda134x_write(codec, UDA134X_DATA011, reg | 0x03);\r\nbreak;\r\ncase UDA134X_UDA1341:\r\nreg = uda134x_read_reg_cache(codec, UDA134X_STATUS1);\r\nuda134x_write(codec, UDA134X_STATUS1, reg | 0x03);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "UDA134X SoC codec: "\r\n"unsupported model %d\n", pd->model);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (pd->power) {\r\npd->power(1);\r\nfor (i = 0; i < ARRAY_SIZE(uda134x_reg); i++)\r\ncodec->driver->write(codec, i, *cache++);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nswitch (pd->model) {\r\ncase UDA134X_UDA1340:\r\ncase UDA134X_UDA1344:\r\ncase UDA134X_UDA1345:\r\nreg = uda134x_read_reg_cache(codec, UDA134X_DATA011);\r\nuda134x_write(codec, UDA134X_DATA011, reg & ~(0x03));\r\nbreak;\r\ncase UDA134X_UDA1341:\r\nreg = uda134x_read_reg_cache(codec, UDA134X_STATUS1);\r\nuda134x_write(codec, UDA134X_STATUS1, reg & ~(0x03));\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "UDA134X SoC codec: "\r\n"unsupported model %d\n", pd->model);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (pd->power)\r\npd->power(0);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int uda134x_soc_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct uda134x_priv *uda134x;\r\nstruct uda134x_platform_data *pd = codec->card->dev->platform_data;\r\nint ret;\r\nprintk(KERN_INFO "UDA134X SoC Audio Codec\n");\r\nif (!pd) {\r\nprintk(KERN_ERR "UDA134X SoC codec: "\r\n"missing L3 bitbang function\n");\r\nreturn -ENODEV;\r\n}\r\nswitch (pd->model) {\r\ncase UDA134X_UDA1340:\r\ncase UDA134X_UDA1341:\r\ncase UDA134X_UDA1344:\r\ncase UDA134X_UDA1345:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "UDA134X SoC codec: "\r\n"unsupported model %d\n",\r\npd->model);\r\nreturn -EINVAL;\r\n}\r\nuda134x = kzalloc(sizeof(struct uda134x_priv), GFP_KERNEL);\r\nif (uda134x == NULL)\r\nreturn -ENOMEM;\r\nsnd_soc_codec_set_drvdata(codec, uda134x);\r\ncodec->control_data = pd;\r\nif (pd->power)\r\npd->power(1);\r\nuda134x_reset(codec);\r\nif (pd->is_powered_on_standby)\r\nuda134x_set_bias_level(codec, SND_SOC_BIAS_ON);\r\nelse\r\nuda134x_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nswitch (pd->model) {\r\ncase UDA134X_UDA1340:\r\ncase UDA134X_UDA1344:\r\nret = snd_soc_add_codec_controls(codec, uda1340_snd_controls,\r\nARRAY_SIZE(uda1340_snd_controls));\r\nbreak;\r\ncase UDA134X_UDA1341:\r\nret = snd_soc_add_codec_controls(codec, uda1341_snd_controls,\r\nARRAY_SIZE(uda1341_snd_controls));\r\nbreak;\r\ncase UDA134X_UDA1345:\r\nret = snd_soc_add_codec_controls(codec, uda1345_snd_controls,\r\nARRAY_SIZE(uda1345_snd_controls));\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s unknown codec type: %d",\r\n__func__, pd->model);\r\nkfree(uda134x);\r\nreturn -EINVAL;\r\n}\r\nif (ret < 0) {\r\nprintk(KERN_ERR "UDA134X: failed to register controls\n");\r\nkfree(uda134x);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uda134x_soc_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct uda134x_priv *uda134x = snd_soc_codec_get_drvdata(codec);\r\nuda134x_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nuda134x_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nkfree(uda134x);\r\nreturn 0;\r\n}\r\nstatic int uda134x_soc_suspend(struct snd_soc_codec *codec)\r\n{\r\nuda134x_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nuda134x_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int uda134x_soc_resume(struct snd_soc_codec *codec)\r\n{\r\nuda134x_set_bias_level(codec, SND_SOC_BIAS_PREPARE);\r\nuda134x_set_bias_level(codec, SND_SOC_BIAS_ON);\r\nreturn 0;\r\n}\r\nstatic int __devinit uda134x_codec_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_codec(&pdev->dev,\r\n&soc_codec_dev_uda134x, &uda134x_dai, 1);\r\n}\r\nstatic int __devexit uda134x_codec_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
