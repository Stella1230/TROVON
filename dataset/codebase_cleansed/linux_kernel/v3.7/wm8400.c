static inline unsigned int wm8400_read(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nstruct wm8400_priv *wm8400 = snd_soc_codec_get_drvdata(codec);\r\nif (reg == WM8400_INTDRIVBITS)\r\nreturn wm8400->fake_register;\r\nelse\r\nreturn wm8400_reg_read(wm8400->wm8400, reg);\r\n}\r\nstatic int wm8400_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct wm8400_priv *wm8400 = snd_soc_codec_get_drvdata(codec);\r\nif (reg == WM8400_INTDRIVBITS) {\r\nwm8400->fake_register = value;\r\nreturn 0;\r\n} else\r\nreturn wm8400_set_bits(wm8400->wm8400, reg, 0xffff, value);\r\n}\r\nstatic void wm8400_codec_reset(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8400_priv *wm8400 = snd_soc_codec_get_drvdata(codec);\r\nwm8400_reset_codec_reg_cache(wm8400->wm8400);\r\n}\r\nstatic int wm8400_outpga_put_volsw_vu(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nint reg = mc->reg;\r\nint ret;\r\nu16 val;\r\nret = snd_soc_put_volsw(kcontrol, ucontrol);\r\nif (ret < 0)\r\nreturn ret;\r\nval = snd_soc_read(codec, reg);\r\nreturn snd_soc_write(codec, reg, val | 0x0100);\r\n}\r\nstatic int inmixer_event (struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nu16 reg, fakepower;\r\nreg = snd_soc_read(w->codec, WM8400_POWER_MANAGEMENT_2);\r\nfakepower = snd_soc_read(w->codec, WM8400_INTDRIVBITS);\r\nif (fakepower & ((1 << WM8400_INMIXL_PWR) |\r\n(1 << WM8400_AINLMUX_PWR))) {\r\nreg |= WM8400_AINL_ENA;\r\n} else {\r\nreg &= ~WM8400_AINL_ENA;\r\n}\r\nif (fakepower & ((1 << WM8400_INMIXR_PWR) |\r\n(1 << WM8400_AINRMUX_PWR))) {\r\nreg |= WM8400_AINR_ENA;\r\n} else {\r\nreg &= ~WM8400_AINR_ENA;\r\n}\r\nsnd_soc_write(w->codec, WM8400_POWER_MANAGEMENT_2, reg);\r\nreturn 0;\r\n}\r\nstatic int outmixer_event (struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol * kcontrol, int event)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nu32 reg_shift = mc->shift;\r\nint ret = 0;\r\nu16 reg;\r\nswitch (reg_shift) {\r\ncase WM8400_SPEAKER_MIXER | (WM8400_LDSPK << 8) :\r\nreg = snd_soc_read(w->codec, WM8400_OUTPUT_MIXER1);\r\nif (reg & WM8400_LDLO) {\r\nprintk(KERN_WARNING\r\n"Cannot set as Output Mixer 1 LDLO Set\n");\r\nret = -1;\r\n}\r\nbreak;\r\ncase WM8400_SPEAKER_MIXER | (WM8400_RDSPK << 8):\r\nreg = snd_soc_read(w->codec, WM8400_OUTPUT_MIXER2);\r\nif (reg & WM8400_RDRO) {\r\nprintk(KERN_WARNING\r\n"Cannot set as Output Mixer 2 RDRO Set\n");\r\nret = -1;\r\n}\r\nbreak;\r\ncase WM8400_OUTPUT_MIXER1 | (WM8400_LDLO << 8):\r\nreg = snd_soc_read(w->codec, WM8400_SPEAKER_MIXER);\r\nif (reg & WM8400_LDSPK) {\r\nprintk(KERN_WARNING\r\n"Cannot set as Speaker Mixer LDSPK Set\n");\r\nret = -1;\r\n}\r\nbreak;\r\ncase WM8400_OUTPUT_MIXER2 | (WM8400_RDRO << 8):\r\nreg = snd_soc_read(w->codec, WM8400_SPEAKER_MIXER);\r\nif (reg & WM8400_RDSPK) {\r\nprintk(KERN_WARNING\r\n"Cannot set as Speaker Mixer RDSPK Set\n");\r\nret = -1;\r\n}\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wm8400_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8400_priv *wm8400 = snd_soc_codec_get_drvdata(codec);\r\nwm8400->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int fll_factors(struct wm8400_priv *wm8400, struct fll_factors *factors,\r\nunsigned int Fref, unsigned int Fout)\r\n{\r\nu64 Kpart;\r\nunsigned int K, Nmod, target;\r\nfactors->outdiv = 2;\r\nwhile (Fout * factors->outdiv < 90000000 ||\r\nFout * factors->outdiv > 100000000) {\r\nfactors->outdiv *= 2;\r\nif (factors->outdiv > 32) {\r\ndev_err(wm8400->wm8400->dev,\r\n"Unsupported FLL output frequency %uHz\n",\r\nFout);\r\nreturn -EINVAL;\r\n}\r\n}\r\ntarget = Fout * factors->outdiv;\r\nfactors->outdiv = factors->outdiv >> 2;\r\nif (Fref < 48000)\r\nfactors->freq_ref = 1;\r\nelse\r\nfactors->freq_ref = 0;\r\nif (Fref < 1000000)\r\nfactors->fratio = 9;\r\nelse\r\nfactors->fratio = 0;\r\ndo {\r\nif (Fref < 1000000)\r\nfactors->fratio--;\r\nelse\r\nfactors->fratio++;\r\nif (factors->fratio < 1 || factors->fratio > 8) {\r\ndev_err(wm8400->wm8400->dev,\r\n"Unable to calculate FRATIO\n");\r\nreturn -EINVAL;\r\n}\r\nfactors->n = target / (Fref * factors->fratio);\r\nNmod = target % (Fref * factors->fratio);\r\n} while (Nmod == 0);\r\nKpart = FIXED_FLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, (Fref * factors->fratio));\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nfactors->k = K / 10;\r\ndev_dbg(wm8400->wm8400->dev,\r\n"FLL: Fref=%u Fout=%u N=%x K=%x, FRATIO=%x OUTDIV=%x\n",\r\nFref, Fout,\r\nfactors->n, factors->k, factors->fratio, factors->outdiv);\r\nreturn 0;\r\n}\r\nstatic int wm8400_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int freq_in,\r\nunsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8400_priv *wm8400 = snd_soc_codec_get_drvdata(codec);\r\nstruct fll_factors factors;\r\nint ret;\r\nu16 reg;\r\nif (freq_in == wm8400->fll_in && freq_out == wm8400->fll_out)\r\nreturn 0;\r\nif (freq_out) {\r\nret = fll_factors(wm8400, &factors, freq_in, freq_out);\r\nif (ret != 0)\r\nreturn ret;\r\n} else {\r\nmemset(&factors, 0, sizeof(factors));\r\n}\r\nwm8400->fll_out = freq_out;\r\nwm8400->fll_in = freq_in;\r\nreg = snd_soc_read(codec, WM8400_POWER_MANAGEMENT_2);\r\nreg &= ~WM8400_FLL_ENA;\r\nsnd_soc_write(codec, WM8400_POWER_MANAGEMENT_2, reg);\r\nreg = snd_soc_read(codec, WM8400_FLL_CONTROL_1);\r\nreg &= ~WM8400_FLL_OSC_ENA;\r\nsnd_soc_write(codec, WM8400_FLL_CONTROL_1, reg);\r\nif (!freq_out)\r\nreturn 0;\r\nreg &= ~(WM8400_FLL_REF_FREQ | WM8400_FLL_FRATIO_MASK);\r\nreg |= WM8400_FLL_FRAC | factors.fratio;\r\nreg |= factors.freq_ref << WM8400_FLL_REF_FREQ_SHIFT;\r\nsnd_soc_write(codec, WM8400_FLL_CONTROL_1, reg);\r\nsnd_soc_write(codec, WM8400_FLL_CONTROL_2, factors.k);\r\nsnd_soc_write(codec, WM8400_FLL_CONTROL_3, factors.n);\r\nreg = snd_soc_read(codec, WM8400_FLL_CONTROL_4);\r\nreg &= ~WM8400_FLL_OUTDIV_MASK;\r\nreg |= factors.outdiv;\r\nsnd_soc_write(codec, WM8400_FLL_CONTROL_4, reg);\r\nreturn 0;\r\n}\r\nstatic int wm8400_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 audio1, audio3;\r\naudio1 = snd_soc_read(codec, WM8400_AUDIO_INTERFACE_1);\r\naudio3 = snd_soc_read(codec, WM8400_AUDIO_INTERFACE_3);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\naudio3 &= ~WM8400_AIF_MSTR1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naudio3 |= WM8400_AIF_MSTR1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\naudio1 &= ~WM8400_AIF_FMT_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\naudio1 |= WM8400_AIF_FMT_I2S;\r\naudio1 &= ~WM8400_AIF_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\naudio1 |= WM8400_AIF_FMT_RIGHTJ;\r\naudio1 &= ~WM8400_AIF_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naudio1 |= WM8400_AIF_FMT_LEFTJ;\r\naudio1 &= ~WM8400_AIF_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naudio1 |= WM8400_AIF_FMT_DSP;\r\naudio1 &= ~WM8400_AIF_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naudio1 |= WM8400_AIF_FMT_DSP | WM8400_AIF_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8400_AUDIO_INTERFACE_1, audio1);\r\nsnd_soc_write(codec, WM8400_AUDIO_INTERFACE_3, audio3);\r\nreturn 0;\r\n}\r\nstatic int wm8400_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\r\nint div_id, int div)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 reg;\r\nswitch (div_id) {\r\ncase WM8400_MCLK_DIV:\r\nreg = snd_soc_read(codec, WM8400_CLOCKING_2) &\r\n~WM8400_MCLK_DIV_MASK;\r\nsnd_soc_write(codec, WM8400_CLOCKING_2, reg | div);\r\nbreak;\r\ncase WM8400_DACCLK_DIV:\r\nreg = snd_soc_read(codec, WM8400_CLOCKING_2) &\r\n~WM8400_DAC_CLKDIV_MASK;\r\nsnd_soc_write(codec, WM8400_CLOCKING_2, reg | div);\r\nbreak;\r\ncase WM8400_ADCCLK_DIV:\r\nreg = snd_soc_read(codec, WM8400_CLOCKING_2) &\r\n~WM8400_ADC_CLKDIV_MASK;\r\nsnd_soc_write(codec, WM8400_CLOCKING_2, reg | div);\r\nbreak;\r\ncase WM8400_BCLK_DIV:\r\nreg = snd_soc_read(codec, WM8400_CLOCKING_1) &\r\n~WM8400_BCLK_DIV_MASK;\r\nsnd_soc_write(codec, WM8400_CLOCKING_1, reg | div);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8400_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 audio1 = snd_soc_read(codec, WM8400_AUDIO_INTERFACE_1);\r\naudio1 &= ~WM8400_AIF_WL_MASK;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\naudio1 |= WM8400_AIF_WL_20BITS;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\naudio1 |= WM8400_AIF_WL_24BITS;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\naudio1 |= WM8400_AIF_WL_32BITS;\r\nbreak;\r\n}\r\nsnd_soc_write(codec, WM8400_AUDIO_INTERFACE_1, audio1);\r\nreturn 0;\r\n}\r\nstatic int wm8400_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 val = snd_soc_read(codec, WM8400_DAC_CTRL) & ~WM8400_DAC_MUTE;\r\nif (mute)\r\nsnd_soc_write(codec, WM8400_DAC_CTRL, val | WM8400_DAC_MUTE);\r\nelse\r\nsnd_soc_write(codec, WM8400_DAC_CTRL, val);\r\nreturn 0;\r\n}\r\nstatic int wm8400_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm8400_priv *wm8400 = snd_soc_codec_get_drvdata(codec);\r\nu16 val;\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nval = snd_soc_read(codec, WM8400_POWER_MANAGEMENT_1) &\r\n~WM8400_VMID_MODE_MASK;\r\nsnd_soc_write(codec, WM8400_POWER_MANAGEMENT_1, val | 0x2);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(power),\r\n&power[0]);\r\nif (ret != 0) {\r\ndev_err(wm8400->wm8400->dev,\r\n"Failed to enable regulators: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nsnd_soc_write(codec, WM8400_POWER_MANAGEMENT_1,\r\nWM8400_CODEC_ENA | WM8400_SYSCLK_ENA);\r\nsnd_soc_write(codec, WM8400_ANTIPOP2, WM8400_SOFTST |\r\nWM8400_BUFDCOPEN | WM8400_POBCTRL);\r\nmsleep(50);\r\nval = snd_soc_read(codec, WM8400_POWER_MANAGEMENT_1);\r\nval |= 0x2 | WM8400_VREF_ENA;\r\nsnd_soc_write(codec, WM8400_POWER_MANAGEMENT_1, val);\r\nsnd_soc_write(codec, WM8400_ANTIPOP2, WM8400_SOFTST |\r\nWM8400_BUFDCOPEN | WM8400_POBCTRL |\r\nWM8400_BUFIOEN);\r\nsnd_soc_write(codec, WM8400_ANTIPOP2, WM8400_BUFIOEN);\r\n}\r\nval = snd_soc_read(codec, WM8400_POWER_MANAGEMENT_1) &\r\n~WM8400_VMID_MODE_MASK;\r\nsnd_soc_write(codec, WM8400_POWER_MANAGEMENT_1, val | 0x4);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_write(codec, WM8400_ANTIPOP2, WM8400_SOFTST |\r\nWM8400_POBCTRL | WM8400_BUFIOEN);\r\nsnd_soc_write(codec, WM8400_ANTIPOP2, WM8400_SOFTST |\r\nWM8400_BUFDCOPEN | WM8400_POBCTRL |\r\nWM8400_BUFIOEN);\r\nval = snd_soc_read(codec, WM8400_DAC_CTRL);\r\nsnd_soc_write(codec, WM8400_DAC_CTRL, val | WM8400_DAC_MUTE);\r\nval = snd_soc_read(codec, WM8400_POWER_MANAGEMENT_1);\r\nval |= WM8400_SPK_ENA | WM8400_OUT3_ENA |\r\nWM8400_OUT4_ENA | WM8400_LOUT_ENA |\r\nWM8400_ROUT_ENA;\r\nsnd_soc_write(codec, WM8400_POWER_MANAGEMENT_1, val);\r\nval &= ~WM8400_VMID_MODE_MASK;\r\nsnd_soc_write(codec, WM8400_POWER_MANAGEMENT_1, val);\r\nmsleep(300);\r\nsnd_soc_write(codec, WM8400_ANTIPOP1, WM8400_DIS_LLINE |\r\nWM8400_DIS_RLINE | WM8400_DIS_OUT3 |\r\nWM8400_DIS_OUT4 | WM8400_DIS_LOUT |\r\nWM8400_DIS_ROUT);\r\nval &= ~WM8400_VREF_ENA;\r\nsnd_soc_write(codec, WM8400_POWER_MANAGEMENT_1, val);\r\nsnd_soc_write(codec, WM8400_ANTIPOP2, 0x0);\r\nret = regulator_bulk_disable(ARRAY_SIZE(power),\r\n&power[0]);\r\nif (ret != 0)\r\nreturn ret;\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8400_suspend(struct snd_soc_codec *codec)\r\n{\r\nwm8400_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8400_resume(struct snd_soc_codec *codec)\r\n{\r\nwm8400_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic void wm8400_probe_deferred(struct work_struct *work)\r\n{\r\nstruct wm8400_priv *priv = container_of(work, struct wm8400_priv,\r\nwork);\r\nstruct snd_soc_codec *codec = priv->codec;\r\nwm8400_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\n}\r\nstatic int wm8400_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8400 *wm8400 = dev_get_platdata(codec->dev);\r\nstruct wm8400_priv *priv;\r\nint ret;\r\nu16 reg;\r\npriv = devm_kzalloc(codec->dev, sizeof(struct wm8400_priv),\r\nGFP_KERNEL);\r\nif (priv == NULL)\r\nreturn -ENOMEM;\r\nsnd_soc_codec_set_drvdata(codec, priv);\r\ncodec->control_data = priv->wm8400 = wm8400;\r\npriv->codec = codec;\r\nret = regulator_bulk_get(wm8400->dev,\r\nARRAY_SIZE(power), &power[0]);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to get regulators: %d\n", ret);\r\nreturn ret;\r\n}\r\nINIT_WORK(&priv->work, wm8400_probe_deferred);\r\nwm8400_codec_reset(codec);\r\nreg = snd_soc_read(codec, WM8400_POWER_MANAGEMENT_1);\r\nsnd_soc_write(codec, WM8400_POWER_MANAGEMENT_1, reg | WM8400_CODEC_ENA);\r\nreg = snd_soc_read(codec, WM8400_LEFT_LINE_INPUT_1_2_VOLUME);\r\nsnd_soc_write(codec, WM8400_LEFT_LINE_INPUT_1_2_VOLUME,\r\nreg & WM8400_IPVU);\r\nreg = snd_soc_read(codec, WM8400_RIGHT_LINE_INPUT_1_2_VOLUME);\r\nsnd_soc_write(codec, WM8400_RIGHT_LINE_INPUT_1_2_VOLUME,\r\nreg & WM8400_IPVU);\r\nsnd_soc_write(codec, WM8400_LEFT_OUTPUT_VOLUME, 0x50 | (1<<8));\r\nsnd_soc_write(codec, WM8400_RIGHT_OUTPUT_VOLUME, 0x50 | (1<<8));\r\nif (!schedule_work(&priv->work)) {\r\nret = -EINVAL;\r\ngoto err_regulator;\r\n}\r\nreturn 0;\r\nerr_regulator:\r\nregulator_bulk_free(ARRAY_SIZE(power), power);\r\nreturn ret;\r\n}\r\nstatic int wm8400_codec_remove(struct snd_soc_codec *codec)\r\n{\r\nu16 reg;\r\nreg = snd_soc_read(codec, WM8400_POWER_MANAGEMENT_1);\r\nsnd_soc_write(codec, WM8400_POWER_MANAGEMENT_1,\r\nreg & (~WM8400_CODEC_ENA));\r\nregulator_bulk_free(ARRAY_SIZE(power), power);\r\nreturn 0;\r\n}\r\nstatic int __devinit wm8400_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_codec(&pdev->dev, &soc_codec_dev_wm8400,\r\n&wm8400_dai, 1);\r\n}\r\nstatic int __devexit wm8400_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
