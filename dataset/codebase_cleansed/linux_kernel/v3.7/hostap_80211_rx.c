void hostap_dump_rx_80211(const char *name, struct sk_buff *skb,\r\nstruct hostap_80211_rx_status *rx_stats)\r\n{\r\nstruct ieee80211_hdr *hdr;\r\nu16 fc;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nprintk(KERN_DEBUG "%s: RX signal=%d noise=%d rate=%d len=%d "\r\n"jiffies=%ld\n",\r\nname, rx_stats->signal, rx_stats->noise, rx_stats->rate,\r\nskb->len, jiffies);\r\nif (skb->len < 2)\r\nreturn;\r\nfc = le16_to_cpu(hdr->frame_control);\r\nprintk(KERN_DEBUG " FC=0x%04x (type=%d:%d)%s%s",\r\nfc, (fc & IEEE80211_FCTL_FTYPE) >> 2,\r\n(fc & IEEE80211_FCTL_STYPE) >> 4,\r\nfc & IEEE80211_FCTL_TODS ? " [ToDS]" : "",\r\nfc & IEEE80211_FCTL_FROMDS ? " [FromDS]" : "");\r\nif (skb->len < IEEE80211_DATA_HDR3_LEN) {\r\nprintk("\n");\r\nreturn;\r\n}\r\nprintk(" dur=0x%04x seq=0x%04x\n", le16_to_cpu(hdr->duration_id),\r\nle16_to_cpu(hdr->seq_ctrl));\r\nprintk(KERN_DEBUG " A1=%pM", hdr->addr1);\r\nprintk(" A2=%pM", hdr->addr2);\r\nprintk(" A3=%pM", hdr->addr3);\r\nif (skb->len >= 30)\r\nprintk(" A4=%pM", hdr->addr4);\r\nprintk("\n");\r\n}\r\nint prism2_rx_80211(struct net_device *dev, struct sk_buff *skb,\r\nstruct hostap_80211_rx_status *rx_stats, int type)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nint hdrlen, phdrlen, head_need, tail_need;\r\nu16 fc;\r\nint prism_header, ret;\r\nstruct ieee80211_hdr *fhdr;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (dev->type == ARPHRD_IEEE80211_PRISM) {\r\nif (local->monitor_type == PRISM2_MONITOR_PRISM) {\r\nprism_header = 1;\r\nphdrlen = sizeof(struct linux_wlan_ng_prism_hdr);\r\n} else {\r\nprism_header = 2;\r\nphdrlen = sizeof(struct linux_wlan_ng_cap_hdr);\r\n}\r\n} else if (dev->type == ARPHRD_IEEE80211_RADIOTAP) {\r\nprism_header = 3;\r\nphdrlen = sizeof(struct hostap_radiotap_rx);\r\n} else {\r\nprism_header = 0;\r\nphdrlen = 0;\r\n}\r\nfhdr = (struct ieee80211_hdr *) skb->data;\r\nfc = le16_to_cpu(fhdr->frame_control);\r\nif (type == PRISM2_RX_MGMT && (fc & IEEE80211_FCTL_VERS)) {\r\nprintk(KERN_DEBUG "%s: dropped management frame with header "\r\n"version %d\n", dev->name, fc & IEEE80211_FCTL_VERS);\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nhdrlen = hostap_80211_get_hdrlen(fhdr->frame_control);\r\nhead_need = phdrlen;\r\ntail_need = 0;\r\n#ifdef PRISM2_ADD_BOGUS_CRC\r\ntail_need += 4;\r\n#endif\r\nhead_need -= skb_headroom(skb);\r\ntail_need -= skb_tailroom(skb);\r\nif (head_need > 0 || tail_need > 0) {\r\nif (pskb_expand_head(skb, head_need > 0 ? head_need : 0,\r\ntail_need > 0 ? tail_need : 0,\r\nGFP_ATOMIC)) {\r\nprintk(KERN_DEBUG "%s: prism2_rx_80211 failed to "\r\n"reallocate skb buffer\n", dev->name);\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\n}\r\n#ifdef PRISM2_ADD_BOGUS_CRC\r\nmemset(skb_put(skb, 4), 0xff, 4);\r\n#endif\r\nif (prism_header == 1) {\r\nstruct linux_wlan_ng_prism_hdr *hdr;\r\nhdr = (struct linux_wlan_ng_prism_hdr *)\r\nskb_push(skb, phdrlen);\r\nmemset(hdr, 0, phdrlen);\r\nhdr->msgcode = LWNG_CAP_DID_BASE;\r\nhdr->msglen = sizeof(*hdr);\r\nmemcpy(hdr->devname, dev->name, sizeof(hdr->devname));\r\n#define LWNG_SETVAL(f,i,s,l,d) \\r\nhdr->f.did = LWNG_CAP_DID_BASE | (i << 12); \\r\nhdr->f.status = s; hdr->f.len = l; hdr->f.data = d\r\nLWNG_SETVAL(hosttime, 1, 0, 4, jiffies);\r\nLWNG_SETVAL(mactime, 2, 0, 4, rx_stats->mac_time);\r\nLWNG_SETVAL(channel, 3, 1 , 4, 0);\r\nLWNG_SETVAL(rssi, 4, 1 , 4, 0);\r\nLWNG_SETVAL(sq, 5, 1 , 4, 0);\r\nLWNG_SETVAL(signal, 6, 0, 4, rx_stats->signal);\r\nLWNG_SETVAL(noise, 7, 0, 4, rx_stats->noise);\r\nLWNG_SETVAL(rate, 8, 0, 4, rx_stats->rate / 5);\r\nLWNG_SETVAL(istx, 9, 0, 4, 0);\r\nLWNG_SETVAL(frmlen, 10, 0, 4, skb->len - phdrlen);\r\n#undef LWNG_SETVAL\r\n} else if (prism_header == 2) {\r\nstruct linux_wlan_ng_cap_hdr *hdr;\r\nhdr = (struct linux_wlan_ng_cap_hdr *)\r\nskb_push(skb, phdrlen);\r\nmemset(hdr, 0, phdrlen);\r\nhdr->version = htonl(LWNG_CAPHDR_VERSION);\r\nhdr->length = htonl(phdrlen);\r\nhdr->mactime = __cpu_to_be64(rx_stats->mac_time);\r\nhdr->hosttime = __cpu_to_be64(jiffies);\r\nhdr->phytype = htonl(4);\r\nhdr->channel = htonl(local->channel);\r\nhdr->datarate = htonl(rx_stats->rate);\r\nhdr->antenna = htonl(0);\r\nhdr->priority = htonl(0);\r\nhdr->ssi_type = htonl(3);\r\nhdr->ssi_signal = htonl(rx_stats->signal);\r\nhdr->ssi_noise = htonl(rx_stats->noise);\r\nhdr->preamble = htonl(0);\r\nhdr->encoding = htonl(1);\r\n} else if (prism_header == 3) {\r\nstruct hostap_radiotap_rx *hdr;\r\nhdr = (struct hostap_radiotap_rx *)skb_push(skb, phdrlen);\r\nmemset(hdr, 0, phdrlen);\r\nhdr->hdr.it_len = cpu_to_le16(phdrlen);\r\nhdr->hdr.it_present =\r\ncpu_to_le32((1 << IEEE80211_RADIOTAP_TSFT) |\r\n(1 << IEEE80211_RADIOTAP_CHANNEL) |\r\n(1 << IEEE80211_RADIOTAP_RATE) |\r\n(1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |\r\n(1 << IEEE80211_RADIOTAP_DBM_ANTNOISE));\r\nhdr->tsft = cpu_to_le64(rx_stats->mac_time);\r\nhdr->chan_freq = cpu_to_le16(freq_list[local->channel - 1]);\r\nhdr->chan_flags = cpu_to_le16(IEEE80211_CHAN_CCK |\r\nIEEE80211_CHAN_2GHZ);\r\nhdr->rate = rx_stats->rate / 5;\r\nhdr->dbm_antsignal = rx_stats->signal;\r\nhdr->dbm_antnoise = rx_stats->noise;\r\n}\r\nret = skb->len - phdrlen;\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, hdrlen);\r\nif (prism_header)\r\nskb_pull(skb, phdrlen);\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = cpu_to_be16(ETH_P_802_2);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\nreturn ret;\r\n}\r\nstatic void monitor_rx(struct net_device *dev, struct sk_buff *skb,\r\nstruct hostap_80211_rx_status *rx_stats)\r\n{\r\nint len;\r\nlen = prism2_rx_80211(dev, skb, rx_stats, PRISM2_RX_MONITOR);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\n}\r\nstatic struct prism2_frag_entry *\r\nprism2_frag_cache_find(local_info_t *local, unsigned int seq,\r\nunsigned int frag, u8 *src, u8 *dst)\r\n{\r\nstruct prism2_frag_entry *entry;\r\nint i;\r\nfor (i = 0; i < PRISM2_FRAG_CACHE_LEN; i++) {\r\nentry = &local->frag_cache[i];\r\nif (entry->skb != NULL &&\r\ntime_after(jiffies, entry->first_frag_time + 2 * HZ)) {\r\nprintk(KERN_DEBUG "%s: expiring fragment cache entry "\r\n"seq=%u last_frag=%u\n",\r\nlocal->dev->name, entry->seq, entry->last_frag);\r\ndev_kfree_skb(entry->skb);\r\nentry->skb = NULL;\r\n}\r\nif (entry->skb != NULL && entry->seq == seq &&\r\n(entry->last_frag + 1 == frag || frag == -1) &&\r\nmemcmp(entry->src_addr, src, ETH_ALEN) == 0 &&\r\nmemcmp(entry->dst_addr, dst, ETH_ALEN) == 0)\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sk_buff *\r\nprism2_frag_cache_get(local_info_t *local, struct ieee80211_hdr *hdr)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nu16 sc;\r\nunsigned int frag, seq;\r\nstruct prism2_frag_entry *entry;\r\nsc = le16_to_cpu(hdr->seq_ctrl);\r\nfrag = sc & IEEE80211_SCTL_FRAG;\r\nseq = (sc & IEEE80211_SCTL_SEQ) >> 4;\r\nif (frag == 0) {\r\nskb = dev_alloc_skb(local->dev->mtu +\r\nsizeof(struct ieee80211_hdr) +\r\n8 +\r\n2 +\r\n8 + ETH_ALEN );\r\nif (skb == NULL)\r\nreturn NULL;\r\nentry = &local->frag_cache[local->frag_next_idx];\r\nlocal->frag_next_idx++;\r\nif (local->frag_next_idx >= PRISM2_FRAG_CACHE_LEN)\r\nlocal->frag_next_idx = 0;\r\nif (entry->skb != NULL)\r\ndev_kfree_skb(entry->skb);\r\nentry->first_frag_time = jiffies;\r\nentry->seq = seq;\r\nentry->last_frag = frag;\r\nentry->skb = skb;\r\nmemcpy(entry->src_addr, hdr->addr2, ETH_ALEN);\r\nmemcpy(entry->dst_addr, hdr->addr1, ETH_ALEN);\r\n} else {\r\nentry = prism2_frag_cache_find(local, seq, frag, hdr->addr2,\r\nhdr->addr1);\r\nif (entry != NULL) {\r\nentry->last_frag = frag;\r\nskb = entry->skb;\r\n}\r\n}\r\nreturn skb;\r\n}\r\nstatic int prism2_frag_cache_invalidate(local_info_t *local,\r\nstruct ieee80211_hdr *hdr)\r\n{\r\nu16 sc;\r\nunsigned int seq;\r\nstruct prism2_frag_entry *entry;\r\nsc = le16_to_cpu(hdr->seq_ctrl);\r\nseq = (sc & IEEE80211_SCTL_SEQ) >> 4;\r\nentry = prism2_frag_cache_find(local, seq, -1, hdr->addr2, hdr->addr1);\r\nif (entry == NULL) {\r\nprintk(KERN_DEBUG "%s: could not invalidate fragment cache "\r\n"entry (seq=%u)\n",\r\nlocal->dev->name, seq);\r\nreturn -1;\r\n}\r\nentry->skb = NULL;\r\nreturn 0;\r\n}\r\nstatic struct hostap_bss_info *__hostap_get_bss(local_info_t *local, u8 *bssid,\r\nu8 *ssid, size_t ssid_len)\r\n{\r\nstruct list_head *ptr;\r\nstruct hostap_bss_info *bss;\r\nlist_for_each(ptr, &local->bss_list) {\r\nbss = list_entry(ptr, struct hostap_bss_info, list);\r\nif (memcmp(bss->bssid, bssid, ETH_ALEN) == 0 &&\r\n(ssid == NULL ||\r\n(ssid_len == bss->ssid_len &&\r\nmemcmp(ssid, bss->ssid, ssid_len) == 0))) {\r\nlist_move(&bss->list, &local->bss_list);\r\nreturn bss;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hostap_bss_info *__hostap_add_bss(local_info_t *local, u8 *bssid,\r\nu8 *ssid, size_t ssid_len)\r\n{\r\nstruct hostap_bss_info *bss;\r\nif (local->num_bss_info >= HOSTAP_MAX_BSS_COUNT) {\r\nbss = list_entry(local->bss_list.prev,\r\nstruct hostap_bss_info, list);\r\nlist_del(&bss->list);\r\nlocal->num_bss_info--;\r\n} else {\r\nbss = kmalloc(sizeof(*bss), GFP_ATOMIC);\r\nif (bss == NULL)\r\nreturn NULL;\r\n}\r\nmemset(bss, 0, sizeof(*bss));\r\nmemcpy(bss->bssid, bssid, ETH_ALEN);\r\nmemcpy(bss->ssid, ssid, ssid_len);\r\nbss->ssid_len = ssid_len;\r\nlocal->num_bss_info++;\r\nlist_add(&bss->list, &local->bss_list);\r\nreturn bss;\r\n}\r\nstatic void __hostap_expire_bss(local_info_t *local)\r\n{\r\nstruct hostap_bss_info *bss;\r\nwhile (local->num_bss_info > 0) {\r\nbss = list_entry(local->bss_list.prev,\r\nstruct hostap_bss_info, list);\r\nif (!time_after(jiffies, bss->last_update + 60 * HZ))\r\nbreak;\r\nlist_del(&bss->list);\r\nlocal->num_bss_info--;\r\nkfree(bss);\r\n}\r\n}\r\nstatic void hostap_rx_sta_beacon(local_info_t *local, struct sk_buff *skb,\r\nint stype)\r\n{\r\nstruct hostap_ieee80211_mgmt *mgmt;\r\nint left, chan = 0;\r\nu8 *pos;\r\nu8 *ssid = NULL, *wpa = NULL, *rsn = NULL;\r\nsize_t ssid_len = 0, wpa_len = 0, rsn_len = 0;\r\nstruct hostap_bss_info *bss;\r\nif (skb->len < IEEE80211_MGMT_HDR_LEN + sizeof(mgmt->u.beacon))\r\nreturn;\r\nmgmt = (struct hostap_ieee80211_mgmt *) skb->data;\r\npos = mgmt->u.beacon.variable;\r\nleft = skb->len - (pos - skb->data);\r\nwhile (left >= 2) {\r\nif (2 + pos[1] > left)\r\nreturn;\r\nswitch (*pos) {\r\ncase WLAN_EID_SSID:\r\nssid = pos + 2;\r\nssid_len = pos[1];\r\nbreak;\r\ncase WLAN_EID_GENERIC:\r\nif (pos[1] >= 4 &&\r\npos[2] == 0x00 && pos[3] == 0x50 &&\r\npos[4] == 0xf2 && pos[5] == 1) {\r\nwpa = pos;\r\nwpa_len = pos[1] + 2;\r\n}\r\nbreak;\r\ncase WLAN_EID_RSN:\r\nrsn = pos;\r\nrsn_len = pos[1] + 2;\r\nbreak;\r\ncase WLAN_EID_DS_PARAMS:\r\nif (pos[1] >= 1)\r\nchan = pos[2];\r\nbreak;\r\n}\r\nleft -= 2 + pos[1];\r\npos += 2 + pos[1];\r\n}\r\nif (wpa_len > MAX_WPA_IE_LEN)\r\nwpa_len = MAX_WPA_IE_LEN;\r\nif (rsn_len > MAX_WPA_IE_LEN)\r\nrsn_len = MAX_WPA_IE_LEN;\r\nif (ssid_len > sizeof(bss->ssid))\r\nssid_len = sizeof(bss->ssid);\r\nspin_lock(&local->lock);\r\nbss = __hostap_get_bss(local, mgmt->bssid, ssid, ssid_len);\r\nif (bss == NULL)\r\nbss = __hostap_add_bss(local, mgmt->bssid, ssid, ssid_len);\r\nif (bss) {\r\nbss->last_update = jiffies;\r\nbss->count++;\r\nbss->capab_info = le16_to_cpu(mgmt->u.beacon.capab_info);\r\nif (wpa) {\r\nmemcpy(bss->wpa_ie, wpa, wpa_len);\r\nbss->wpa_ie_len = wpa_len;\r\n} else\r\nbss->wpa_ie_len = 0;\r\nif (rsn) {\r\nmemcpy(bss->rsn_ie, rsn, rsn_len);\r\nbss->rsn_ie_len = rsn_len;\r\n} else\r\nbss->rsn_ie_len = 0;\r\nbss->chan = chan;\r\n}\r\n__hostap_expire_bss(local);\r\nspin_unlock(&local->lock);\r\n}\r\nstatic int\r\nhostap_rx_frame_mgmt(local_info_t *local, struct sk_buff *skb,\r\nstruct hostap_80211_rx_status *rx_stats, u16 type,\r\nu16 stype)\r\n{\r\nif (local->iw_mode == IW_MODE_MASTER)\r\nhostap_update_sta_ps(local, (struct ieee80211_hdr *) skb->data);\r\nif (local->hostapd && type == IEEE80211_FTYPE_MGMT) {\r\nif (stype == IEEE80211_STYPE_BEACON &&\r\nlocal->iw_mode == IW_MODE_MASTER) {\r\nstruct sk_buff *skb2;\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (skb2)\r\nhostap_rx(skb2->dev, skb2, rx_stats);\r\n}\r\nlocal->apdevstats.rx_packets++;\r\nlocal->apdevstats.rx_bytes += skb->len;\r\nif (local->apdev == NULL)\r\nreturn -1;\r\nprism2_rx_80211(local->apdev, skb, rx_stats, PRISM2_RX_MGMT);\r\nreturn 0;\r\n}\r\nif (local->iw_mode == IW_MODE_MASTER) {\r\nif (type != IEEE80211_FTYPE_MGMT &&\r\ntype != IEEE80211_FTYPE_CTL) {\r\nprintk(KERN_DEBUG "%s: unknown management frame "\r\n"(type=0x%02x, stype=0x%02x) dropped\n",\r\nskb->dev->name, type >> 2, stype >> 4);\r\nreturn -1;\r\n}\r\nhostap_rx(skb->dev, skb, rx_stats);\r\nreturn 0;\r\n} else if (type == IEEE80211_FTYPE_MGMT &&\r\n(stype == IEEE80211_STYPE_BEACON ||\r\nstype == IEEE80211_STYPE_PROBE_RESP)) {\r\nhostap_rx_sta_beacon(local, skb, stype);\r\nreturn -1;\r\n} else if (type == IEEE80211_FTYPE_MGMT &&\r\n(stype == IEEE80211_STYPE_ASSOC_RESP ||\r\nstype == IEEE80211_STYPE_REASSOC_RESP)) {\r\nreturn -1;\r\n} else {\r\nprintk(KERN_DEBUG "%s: hostap_rx_frame_mgmt: dropped unhandled"\r\n" management frame in non-Host AP mode (type=%d:%d)\n",\r\nskb->dev->name, type >> 2, stype >> 4);\r\nreturn -1;\r\n}\r\n}\r\nstatic struct net_device *prism2_rx_get_wds(local_info_t *local,\r\nu8 *addr)\r\n{\r\nstruct hostap_interface *iface = NULL;\r\nstruct list_head *ptr;\r\nread_lock_bh(&local->iface_lock);\r\nlist_for_each(ptr, &local->hostap_interfaces) {\r\niface = list_entry(ptr, struct hostap_interface, list);\r\nif (iface->type == HOSTAP_INTERFACE_WDS &&\r\nmemcmp(iface->u.wds.remote_addr, addr, ETH_ALEN) == 0)\r\nbreak;\r\niface = NULL;\r\n}\r\nread_unlock_bh(&local->iface_lock);\r\nreturn iface ? iface->dev : NULL;\r\n}\r\nstatic int\r\nhostap_rx_frame_wds(local_info_t *local, struct ieee80211_hdr *hdr, u16 fc,\r\nstruct net_device **wds)\r\n{\r\nif ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) !=\r\n(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS) &&\r\n(local->iw_mode != IW_MODE_MASTER || !(fc & IEEE80211_FCTL_TODS)))\r\nreturn 0;\r\nif (memcmp(hdr->addr1, local->dev->dev_addr, ETH_ALEN) != 0 &&\r\n(hdr->addr1[0] != 0xff || hdr->addr1[1] != 0xff ||\r\nhdr->addr1[2] != 0xff || hdr->addr1[3] != 0xff ||\r\nhdr->addr1[4] != 0xff || hdr->addr1[5] != 0xff)) {\r\nPDEBUG(DEBUG_EXTRA2, "%s: received WDS frame with "\r\n"not own or broadcast %s=%pM\n",\r\nlocal->dev->name,\r\nfc & IEEE80211_FCTL_FROMDS ? "RA" : "BSSID",\r\nhdr->addr1);\r\nreturn -1;\r\n}\r\n*wds = prism2_rx_get_wds(local, hdr->addr2);\r\nif (*wds == NULL && fc & IEEE80211_FCTL_FROMDS &&\r\n(local->iw_mode != IW_MODE_INFRA ||\r\n!(local->wds_type & HOSTAP_WDS_AP_CLIENT) ||\r\nmemcmp(hdr->addr2, local->bssid, ETH_ALEN) != 0)) {\r\nPDEBUG(DEBUG_EXTRA, "%s: received WDS[4 addr] frame "\r\n"from unknown TA=%pM\n",\r\nlocal->dev->name, hdr->addr2);\r\nif (local->ap && local->ap->autom_ap_wds)\r\nhostap_wds_link_oper(local, hdr->addr2, WDS_ADD);\r\nreturn -1;\r\n}\r\nif (*wds && !(fc & IEEE80211_FCTL_FROMDS) && local->ap &&\r\nhostap_is_sta_assoc(local->ap, hdr->addr2)) {\r\n*wds = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hostap_is_eapol_frame(local_info_t *local, struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = local->dev;\r\nu16 fc, ethertype;\r\nstruct ieee80211_hdr *hdr;\r\nu8 *pos;\r\nif (skb->len < 24)\r\nreturn 0;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nfc = le16_to_cpu(hdr->frame_control);\r\nif ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\r\nIEEE80211_FCTL_TODS &&\r\nmemcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0 &&\r\nmemcmp(hdr->addr3, dev->dev_addr, ETH_ALEN) == 0) {\r\n} else if ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\r\nIEEE80211_FCTL_FROMDS &&\r\nmemcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0) {\r\n} else\r\nreturn 0;\r\nif (skb->len < 24 + 8)\r\nreturn 0;\r\npos = skb->data + 24;\r\nethertype = (pos[6] << 8) | pos[7];\r\nif (ethertype == ETH_P_PAE)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nhostap_rx_frame_decrypt(local_info_t *local, struct sk_buff *skb,\r\nstruct lib80211_crypt_data *crypt)\r\n{\r\nstruct ieee80211_hdr *hdr;\r\nint res, hdrlen;\r\nif (crypt == NULL || crypt->ops->decrypt_mpdu == NULL)\r\nreturn 0;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nhdrlen = hostap_80211_get_hdrlen(hdr->frame_control);\r\nif (local->tkip_countermeasures &&\r\nstrcmp(crypt->ops->name, "TKIP") == 0) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "%s: TKIP countermeasures: dropped "\r\n"received packet from %pM\n",\r\nlocal->dev->name, hdr->addr2);\r\n}\r\nreturn -1;\r\n}\r\natomic_inc(&crypt->refcnt);\r\nres = crypt->ops->decrypt_mpdu(skb, hdrlen, crypt->priv);\r\natomic_dec(&crypt->refcnt);\r\nif (res < 0) {\r\nprintk(KERN_DEBUG "%s: decryption failed (SA=%pM) res=%d\n",\r\nlocal->dev->name, hdr->addr2, res);\r\nlocal->comm_tallies.rx_discards_wep_undecryptable++;\r\nreturn -1;\r\n}\r\nreturn res;\r\n}\r\nstatic int\r\nhostap_rx_frame_decrypt_msdu(local_info_t *local, struct sk_buff *skb,\r\nint keyidx, struct lib80211_crypt_data *crypt)\r\n{\r\nstruct ieee80211_hdr *hdr;\r\nint res, hdrlen;\r\nif (crypt == NULL || crypt->ops->decrypt_msdu == NULL)\r\nreturn 0;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nhdrlen = hostap_80211_get_hdrlen(hdr->frame_control);\r\natomic_inc(&crypt->refcnt);\r\nres = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv);\r\natomic_dec(&crypt->refcnt);\r\nif (res < 0) {\r\nprintk(KERN_DEBUG "%s: MSDU decryption/MIC verification failed"\r\n" (SA=%pM keyidx=%d)\n",\r\nlocal->dev->name, hdr->addr2, keyidx);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid hostap_80211_rx(struct net_device *dev, struct sk_buff *skb,\r\nstruct hostap_80211_rx_status *rx_stats)\r\n{\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\nstruct ieee80211_hdr *hdr;\r\nsize_t hdrlen;\r\nu16 fc, type, stype, sc;\r\nstruct net_device *wds = NULL;\r\nunsigned int frag;\r\nu8 *payload;\r\nstruct sk_buff *skb2 = NULL;\r\nu16 ethertype;\r\nint frame_authorized = 0;\r\nint from_assoc_ap = 0;\r\nu8 dst[ETH_ALEN];\r\nu8 src[ETH_ALEN];\r\nstruct lib80211_crypt_data *crypt = NULL;\r\nvoid *sta = NULL;\r\nint keyidx = 0;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\niface->stats.rx_packets++;\r\niface->stats.rx_bytes += skb->len;\r\ndev = local->ddev;\r\niface = netdev_priv(dev);\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nif (skb->len < 10)\r\ngoto rx_dropped;\r\nfc = le16_to_cpu(hdr->frame_control);\r\ntype = fc & IEEE80211_FCTL_FTYPE;\r\nstype = fc & IEEE80211_FCTL_STYPE;\r\nsc = le16_to_cpu(hdr->seq_ctrl);\r\nfrag = sc & IEEE80211_SCTL_FRAG;\r\nhdrlen = hostap_80211_get_hdrlen(hdr->frame_control);\r\n#ifdef IW_WIRELESS_SPY\r\nif (iface->spy_data.spy_number > 0) {\r\nstruct iw_quality wstats;\r\nwstats.level = rx_stats->signal;\r\nwstats.noise = rx_stats->noise;\r\nwstats.updated = IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_UPDATED\r\n| IW_QUAL_QUAL_INVALID | IW_QUAL_DBM;\r\nwireless_spy_update(dev, hdr->addr2, &wstats);\r\n}\r\n#endif\r\nhostap_update_rx_stats(local->ap, hdr, rx_stats);\r\nif (local->iw_mode == IW_MODE_MONITOR) {\r\nmonitor_rx(dev, skb, rx_stats);\r\nreturn;\r\n}\r\nif (local->host_decrypt) {\r\nint idx = 0;\r\nif (skb->len >= hdrlen + 3)\r\nidx = skb->data[hdrlen + 3] >> 6;\r\ncrypt = local->crypt_info.crypt[idx];\r\nsta = NULL;\r\nif (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)\r\n(void) hostap_handle_sta_crypto(local, hdr, &crypt,\r\n&sta);\r\nif (crypt && (crypt->ops == NULL ||\r\ncrypt->ops->decrypt_mpdu == NULL))\r\ncrypt = NULL;\r\nif (!crypt && (fc & IEEE80211_FCTL_PROTECTED)) {\r\n#if 0\r\nprintk(KERN_DEBUG "%s: WEP decryption failed (not set)"\r\n" (SA=%pM)\n",\r\nlocal->dev->name, hdr->addr2);\r\n#endif\r\nlocal->comm_tallies.rx_discards_wep_undecryptable++;\r\ngoto rx_dropped;\r\n}\r\n}\r\nif (type != IEEE80211_FTYPE_DATA) {\r\nif (type == IEEE80211_FTYPE_MGMT &&\r\nstype == IEEE80211_STYPE_AUTH &&\r\nfc & IEEE80211_FCTL_PROTECTED && local->host_decrypt &&\r\n(keyidx = hostap_rx_frame_decrypt(local, skb, crypt)) < 0)\r\n{\r\nprintk(KERN_DEBUG "%s: failed to decrypt mgmt::auth "\r\n"from %pM\n", dev->name, hdr->addr2);\r\ngoto rx_dropped;\r\n}\r\nif (hostap_rx_frame_mgmt(local, skb, rx_stats, type, stype))\r\ngoto rx_dropped;\r\nelse\r\ngoto rx_exit;\r\n}\r\nif (skb->len < IEEE80211_DATA_HDR3_LEN)\r\ngoto rx_dropped;\r\nswitch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\r\ncase IEEE80211_FCTL_FROMDS:\r\nmemcpy(dst, hdr->addr1, ETH_ALEN);\r\nmemcpy(src, hdr->addr3, ETH_ALEN);\r\nbreak;\r\ncase IEEE80211_FCTL_TODS:\r\nmemcpy(dst, hdr->addr3, ETH_ALEN);\r\nmemcpy(src, hdr->addr2, ETH_ALEN);\r\nbreak;\r\ncase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\r\nif (skb->len < IEEE80211_DATA_HDR4_LEN)\r\ngoto rx_dropped;\r\nmemcpy(dst, hdr->addr3, ETH_ALEN);\r\nmemcpy(src, hdr->addr4, ETH_ALEN);\r\nbreak;\r\ncase 0:\r\nmemcpy(dst, hdr->addr1, ETH_ALEN);\r\nmemcpy(src, hdr->addr2, ETH_ALEN);\r\nbreak;\r\n}\r\nif (hostap_rx_frame_wds(local, hdr, fc, &wds))\r\ngoto rx_dropped;\r\nif (wds)\r\nskb->dev = dev = wds;\r\nif (local->iw_mode == IW_MODE_MASTER && !wds &&\r\n(fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\r\nIEEE80211_FCTL_FROMDS &&\r\nlocal->stadev &&\r\nmemcmp(hdr->addr2, local->assoc_ap_addr, ETH_ALEN) == 0) {\r\nskb->dev = dev = local->stadev;\r\nfrom_assoc_ap = 1;\r\n}\r\nif ((local->iw_mode == IW_MODE_MASTER ||\r\nlocal->iw_mode == IW_MODE_REPEAT) &&\r\n!from_assoc_ap) {\r\nswitch (hostap_handle_sta_rx(local, dev, skb, rx_stats,\r\nwds != NULL)) {\r\ncase AP_RX_CONTINUE_NOT_AUTHORIZED:\r\nframe_authorized = 0;\r\nbreak;\r\ncase AP_RX_CONTINUE:\r\nframe_authorized = 1;\r\nbreak;\r\ncase AP_RX_DROP:\r\ngoto rx_dropped;\r\ncase AP_RX_EXIT:\r\ngoto rx_exit;\r\n}\r\n}\r\nif (stype != IEEE80211_STYPE_DATA &&\r\nstype != IEEE80211_STYPE_DATA_CFACK &&\r\nstype != IEEE80211_STYPE_DATA_CFPOLL &&\r\nstype != IEEE80211_STYPE_DATA_CFACKPOLL) {\r\nif (stype != IEEE80211_STYPE_NULLFUNC)\r\nprintk(KERN_DEBUG "%s: RX: dropped data frame "\r\n"with no data (type=0x%02x, subtype=0x%02x)\n",\r\ndev->name, type >> 2, stype >> 4);\r\ngoto rx_dropped;\r\n}\r\nif (local->host_decrypt && (fc & IEEE80211_FCTL_PROTECTED) &&\r\n(keyidx = hostap_rx_frame_decrypt(local, skb, crypt)) < 0)\r\ngoto rx_dropped;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nif (local->host_decrypt && (fc & IEEE80211_FCTL_PROTECTED) &&\r\n(frag != 0 || (fc & IEEE80211_FCTL_MOREFRAGS))) {\r\nint flen;\r\nstruct sk_buff *frag_skb =\r\nprism2_frag_cache_get(local, hdr);\r\nif (!frag_skb) {\r\nprintk(KERN_DEBUG "%s: Rx cannot get skb from "\r\n"fragment cache (morefrag=%d seq=%u frag=%u)\n",\r\ndev->name, (fc & IEEE80211_FCTL_MOREFRAGS) != 0,\r\n(sc & IEEE80211_SCTL_SEQ) >> 4, frag);\r\ngoto rx_dropped;\r\n}\r\nflen = skb->len;\r\nif (frag != 0)\r\nflen -= hdrlen;\r\nif (frag_skb->tail + flen > frag_skb->end) {\r\nprintk(KERN_WARNING "%s: host decrypted and "\r\n"reassembled frame did not fit skb\n",\r\ndev->name);\r\nprism2_frag_cache_invalidate(local, hdr);\r\ngoto rx_dropped;\r\n}\r\nif (frag == 0) {\r\nskb_copy_from_linear_data(skb, skb_put(frag_skb, flen),\r\nflen);\r\n} else {\r\nskb_copy_from_linear_data_offset(skb, hdrlen,\r\nskb_put(frag_skb,\r\nflen), flen);\r\n}\r\ndev_kfree_skb(skb);\r\nskb = NULL;\r\nif (fc & IEEE80211_FCTL_MOREFRAGS) {\r\ngoto rx_exit;\r\n}\r\nskb = frag_skb;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nprism2_frag_cache_invalidate(local, hdr);\r\n}\r\nif (local->host_decrypt && (fc & IEEE80211_FCTL_PROTECTED) &&\r\nhostap_rx_frame_decrypt_msdu(local, skb, keyidx, crypt))\r\ngoto rx_dropped;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !local->open_wep) {\r\nif (local->ieee_802_1x &&\r\nhostap_is_eapol_frame(local, skb)) {\r\nPDEBUG(DEBUG_EXTRA2, "%s: RX: IEEE 802.1X - passing "\r\n"unencrypted EAPOL frame\n", local->dev->name);\r\n} else {\r\nprintk(KERN_DEBUG "%s: encryption configured, but RX "\r\n"frame not encrypted (SA=%pM)\n",\r\nlocal->dev->name, hdr->addr2);\r\ngoto rx_dropped;\r\n}\r\n}\r\nif (local->drop_unencrypted && !(fc & IEEE80211_FCTL_PROTECTED) &&\r\n!hostap_is_eapol_frame(local, skb)) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "%s: dropped unencrypted RX data "\r\n"frame from %pM (drop_unencrypted=1)\n",\r\ndev->name, hdr->addr2);\r\n}\r\ngoto rx_dropped;\r\n}\r\npayload = skb->data + hdrlen;\r\nethertype = (payload[6] << 8) | payload[7];\r\nif (local->ieee_802_1x && local->iw_mode == IW_MODE_MASTER) {\r\nif (ethertype == ETH_P_PAE) {\r\nPDEBUG(DEBUG_EXTRA2, "%s: RX: IEEE 802.1X frame\n",\r\ndev->name);\r\nif (local->hostapd && local->apdev) {\r\nprism2_rx_80211(local->apdev, skb, rx_stats,\r\nPRISM2_RX_MGMT);\r\nlocal->apdevstats.rx_packets++;\r\nlocal->apdevstats.rx_bytes += skb->len;\r\ngoto rx_exit;\r\n}\r\n} else if (!frame_authorized) {\r\nprintk(KERN_DEBUG "%s: dropped frame from "\r\n"unauthorized port (IEEE 802.1X): "\r\n"ethertype=0x%04x\n",\r\ndev->name, ethertype);\r\ngoto rx_dropped;\r\n}\r\n}\r\nif (skb->len - hdrlen >= 8 &&\r\n((memcmp(payload, rfc1042_header, 6) == 0 &&\r\nethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\r\nmemcmp(payload, bridge_tunnel_header, 6) == 0)) {\r\nskb_pull(skb, hdrlen + 6);\r\nmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\r\nmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\r\n} else {\r\n__be16 len;\r\nskb_pull(skb, hdrlen);\r\nlen = htons(skb->len);\r\nmemcpy(skb_push(skb, 2), &len, 2);\r\nmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\r\nmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\r\n}\r\nif (wds && ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\r\nIEEE80211_FCTL_TODS) &&\r\nskb->len >= ETH_HLEN + ETH_ALEN) {\r\nskb_copy_from_linear_data_offset(skb, skb->len - ETH_ALEN,\r\nskb->data + ETH_ALEN,\r\nETH_ALEN);\r\nskb_trim(skb, skb->len - ETH_ALEN);\r\n}\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nif (local->iw_mode == IW_MODE_MASTER && !wds &&\r\nlocal->ap->bridge_packets) {\r\nif (dst[0] & 0x01) {\r\nlocal->ap->bridged_multicast++;\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (skb2 == NULL)\r\nprintk(KERN_DEBUG "%s: skb_clone failed for "\r\n"multicast frame\n", dev->name);\r\n} else if (hostap_is_sta_authorized(local->ap, dst)) {\r\nlocal->ap->bridged_unicast++;\r\nskb2 = skb;\r\nskb = NULL;\r\n}\r\n}\r\nif (skb2 != NULL) {\r\nskb2->dev = dev;\r\nskb2->protocol = cpu_to_be16(ETH_P_802_3);\r\nskb_reset_mac_header(skb2);\r\nskb_reset_network_header(skb2);\r\ndev_queue_xmit(skb2);\r\n}\r\nif (skb) {\r\nskb->protocol = eth_type_trans(skb, dev);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\n}\r\nrx_exit:\r\nif (sta)\r\nhostap_handle_sta_release(sta);\r\nreturn;\r\nrx_dropped:\r\ndev_kfree_skb(skb);\r\ndev->stats.rx_dropped++;\r\ngoto rx_exit;\r\n}
