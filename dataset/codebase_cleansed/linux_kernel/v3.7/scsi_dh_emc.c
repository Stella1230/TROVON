static inline struct clariion_dh_data\r\n*get_clariion_data(struct scsi_device *sdev)\r\n{\r\nstruct scsi_dh_data *scsi_dh_data = sdev->scsi_dh_data;\r\nBUG_ON(scsi_dh_data == NULL);\r\nreturn ((struct clariion_dh_data *) scsi_dh_data->buf);\r\n}\r\nstatic int trespass_endio(struct scsi_device *sdev, char *sense)\r\n{\r\nint err = SCSI_DH_IO;\r\nstruct scsi_sense_hdr sshdr;\r\nif (!scsi_normalize_sense(sense, SCSI_SENSE_BUFFERSIZE, &sshdr)) {\r\nsdev_printk(KERN_ERR, sdev, "%s: Found valid sense data 0x%2x, "\r\n"0x%2x, 0x%2x while sending CLARiiON trespass "\r\n"command.\n", CLARIION_NAME, sshdr.sense_key,\r\nsshdr.asc, sshdr.ascq);\r\nif ((sshdr.sense_key == 0x05) && (sshdr.asc == 0x04) &&\r\n(sshdr.ascq == 0x00)) {\r\nsdev_printk(KERN_INFO, sdev, "%s: Array Based Copy in "\r\n"progress while sending CLARiiON trespass "\r\n"command.\n", CLARIION_NAME);\r\nerr = SCSI_DH_DEV_TEMP_BUSY;\r\n} else if ((sshdr.sense_key == 0x02) && (sshdr.asc == 0x04) &&\r\n(sshdr.ascq == 0x03)) {\r\nsdev_printk(KERN_INFO, sdev, "%s: Detected in-progress "\r\n"ucode upgrade NDU operation while sending "\r\n"CLARiiON trespass command.\n", CLARIION_NAME);\r\nerr = SCSI_DH_DEV_TEMP_BUSY;\r\n} else\r\nerr = SCSI_DH_DEV_FAILED;\r\n} else {\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: failed to send MODE SELECT, no sense available\n",\r\nCLARIION_NAME);\r\n}\r\nreturn err;\r\n}\r\nstatic int parse_sp_info_reply(struct scsi_device *sdev,\r\nstruct clariion_dh_data *csdev)\r\n{\r\nint err = SCSI_DH_OK;\r\nif (csdev->buffer[48] != 0) {\r\nsdev_printk(KERN_NOTICE, sdev, "%s: Detected in-progress "\r\n"ucode upgrade NDU operation while finding "\r\n"current active SP.", CLARIION_NAME);\r\nerr = SCSI_DH_DEV_TEMP_BUSY;\r\ngoto out;\r\n}\r\nif (csdev->buffer[4] > 2) {\r\nsdev_printk(KERN_NOTICE, sdev,\r\n"%s: invalid VPD page 0xC0 format\n",\r\nCLARIION_NAME);\r\nerr = SCSI_DH_NOSYS;\r\ngoto out;\r\n}\r\nswitch (csdev->buffer[28] & 0x0f) {\r\ncase 6:\r\nsdev_printk(KERN_NOTICE, sdev,\r\n"%s: ALUA failover mode detected\n",\r\nCLARIION_NAME);\r\nbreak;\r\ncase 4:\r\nbreak;\r\ndefault:\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: Invalid failover mode %d\n",\r\nCLARIION_NAME, csdev->buffer[28] & 0x0f);\r\nerr = SCSI_DH_NOSYS;\r\ngoto out;\r\n}\r\ncsdev->default_sp = csdev->buffer[5];\r\ncsdev->lun_state = csdev->buffer[4];\r\ncsdev->current_sp = csdev->buffer[8];\r\ncsdev->port = csdev->buffer[7];\r\nout:\r\nreturn err;\r\n}\r\nstatic char * parse_sp_model(struct scsi_device *sdev, unsigned char *buffer)\r\n{\r\nunsigned char len = buffer[4] + 5;\r\nchar *sp_model = NULL;\r\nunsigned char sp_len, serial_len;\r\nif (len < 160) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: Invalid information section length %d\n",\r\nCLARIION_NAME, len);\r\nif (!strncmp(buffer + 8, "DGC", 3)) {\r\nsp_model = emc_default_str;\r\n}\r\ngoto out;\r\n}\r\nserial_len = buffer[160];\r\nif (serial_len == 0 || serial_len + 161 > len) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: Invalid array serial number length %d\n",\r\nCLARIION_NAME, serial_len);\r\ngoto out;\r\n}\r\nsp_len = buffer[99];\r\nif (sp_len == 0 || serial_len + sp_len + 161 > len) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: Invalid model number length %d\n",\r\nCLARIION_NAME, sp_len);\r\ngoto out;\r\n}\r\nsp_model = &buffer[serial_len + 161];\r\nwhile (sp_len > 1 && sp_model[sp_len - 1] == ' ')\r\nsp_len--;\r\nsp_model[sp_len] = '\0';\r\nout:\r\nreturn sp_model;\r\n}\r\nstatic struct request *get_req(struct scsi_device *sdev, int cmd,\r\nunsigned char *buffer)\r\n{\r\nstruct request *rq;\r\nint len = 0;\r\nrq = blk_get_request(sdev->request_queue,\r\n(cmd != INQUIRY) ? WRITE : READ, GFP_NOIO);\r\nif (!rq) {\r\nsdev_printk(KERN_INFO, sdev, "get_req: blk_get_request failed");\r\nreturn NULL;\r\n}\r\nrq->cmd_len = COMMAND_SIZE(cmd);\r\nrq->cmd[0] = cmd;\r\nswitch (cmd) {\r\ncase MODE_SELECT:\r\nlen = sizeof(short_trespass);\r\nrq->cmd[1] = 0x10;\r\nrq->cmd[4] = len;\r\nbreak;\r\ncase MODE_SELECT_10:\r\nlen = sizeof(long_trespass);\r\nrq->cmd[1] = 0x10;\r\nrq->cmd[8] = len;\r\nbreak;\r\ncase INQUIRY:\r\nlen = CLARIION_BUFFER_SIZE;\r\nrq->cmd[4] = len;\r\nmemset(buffer, 0, len);\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\nbreak;\r\n}\r\nrq->cmd_type = REQ_TYPE_BLOCK_PC;\r\nrq->cmd_flags |= REQ_FAILFAST_DEV | REQ_FAILFAST_TRANSPORT |\r\nREQ_FAILFAST_DRIVER;\r\nrq->timeout = CLARIION_TIMEOUT;\r\nrq->retries = CLARIION_RETRIES;\r\nif (blk_rq_map_kern(rq->q, rq, buffer, len, GFP_NOIO)) {\r\nblk_put_request(rq);\r\nreturn NULL;\r\n}\r\nreturn rq;\r\n}\r\nstatic int send_inquiry_cmd(struct scsi_device *sdev, int page,\r\nstruct clariion_dh_data *csdev)\r\n{\r\nstruct request *rq = get_req(sdev, INQUIRY, csdev->buffer);\r\nint err;\r\nif (!rq)\r\nreturn SCSI_DH_RES_TEMP_UNAVAIL;\r\nrq->sense = csdev->sense;\r\nmemset(rq->sense, 0, SCSI_SENSE_BUFFERSIZE);\r\nrq->sense_len = csdev->senselen = 0;\r\nrq->cmd[0] = INQUIRY;\r\nif (page != 0) {\r\nrq->cmd[1] = 1;\r\nrq->cmd[2] = page;\r\n}\r\nerr = blk_execute_rq(sdev->request_queue, NULL, rq, 1);\r\nif (err == -EIO) {\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: failed to send %s INQUIRY: %x\n",\r\nCLARIION_NAME, page?"EVPD":"standard",\r\nrq->errors);\r\ncsdev->senselen = rq->sense_len;\r\nerr = SCSI_DH_IO;\r\n}\r\nblk_put_request(rq);\r\nreturn err;\r\n}\r\nstatic int send_trespass_cmd(struct scsi_device *sdev,\r\nstruct clariion_dh_data *csdev)\r\n{\r\nstruct request *rq;\r\nunsigned char *page22;\r\nint err, len, cmd;\r\nif (csdev->flags & CLARIION_SHORT_TRESPASS) {\r\npage22 = short_trespass;\r\nif (!(csdev->flags & CLARIION_HONOR_RESERVATIONS))\r\npage22[6] |= 0x80;\r\nlen = sizeof(short_trespass);\r\ncmd = MODE_SELECT;\r\n} else {\r\npage22 = long_trespass;\r\nif (!(csdev->flags & CLARIION_HONOR_RESERVATIONS))\r\npage22[10] |= 0x80;\r\nlen = sizeof(long_trespass);\r\ncmd = MODE_SELECT_10;\r\n}\r\nBUG_ON((len > CLARIION_BUFFER_SIZE));\r\nmemcpy(csdev->buffer, page22, len);\r\nrq = get_req(sdev, cmd, csdev->buffer);\r\nif (!rq)\r\nreturn SCSI_DH_RES_TEMP_UNAVAIL;\r\nrq->sense = csdev->sense;\r\nmemset(rq->sense, 0, SCSI_SENSE_BUFFERSIZE);\r\nrq->sense_len = csdev->senselen = 0;\r\nerr = blk_execute_rq(sdev->request_queue, NULL, rq, 1);\r\nif (err == -EIO) {\r\nif (rq->sense_len) {\r\nerr = trespass_endio(sdev, csdev->sense);\r\n} else {\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: failed to send MODE SELECT: %x\n",\r\nCLARIION_NAME, rq->errors);\r\n}\r\n}\r\nblk_put_request(rq);\r\nreturn err;\r\n}\r\nstatic int clariion_check_sense(struct scsi_device *sdev,\r\nstruct scsi_sense_hdr *sense_hdr)\r\n{\r\nswitch (sense_hdr->sense_key) {\r\ncase NOT_READY:\r\nif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x03)\r\nreturn SUCCESS;\r\nbreak;\r\ncase ILLEGAL_REQUEST:\r\nif (sense_hdr->asc == 0x25 && sense_hdr->ascq == 0x01)\r\nreturn SUCCESS;\r\nbreak;\r\ncase UNIT_ATTENTION:\r\nif (sense_hdr->asc == 0x29 && sense_hdr->ascq == 0x00)\r\nreturn ADD_TO_MLQUEUE;\r\nbreak;\r\n}\r\nreturn SCSI_RETURN_NOT_HANDLED;\r\n}\r\nstatic int clariion_prep_fn(struct scsi_device *sdev, struct request *req)\r\n{\r\nstruct clariion_dh_data *h = get_clariion_data(sdev);\r\nint ret = BLKPREP_OK;\r\nif (h->lun_state != CLARIION_LUN_OWNED) {\r\nret = BLKPREP_KILL;\r\nreq->cmd_flags |= REQ_QUIET;\r\n}\r\nreturn ret;\r\n}\r\nstatic int clariion_std_inquiry(struct scsi_device *sdev,\r\nstruct clariion_dh_data *csdev)\r\n{\r\nint err;\r\nchar *sp_model;\r\nerr = send_inquiry_cmd(sdev, 0, csdev);\r\nif (err != SCSI_DH_OK && csdev->senselen) {\r\nstruct scsi_sense_hdr sshdr;\r\nif (scsi_normalize_sense(csdev->sense, SCSI_SENSE_BUFFERSIZE,\r\n&sshdr)) {\r\nsdev_printk(KERN_ERR, sdev, "%s: INQUIRY sense code "\r\n"%02x/%02x/%02x\n", CLARIION_NAME,\r\nsshdr.sense_key, sshdr.asc, sshdr.ascq);\r\n}\r\nerr = SCSI_DH_IO;\r\ngoto out;\r\n}\r\nsp_model = parse_sp_model(sdev, csdev->buffer);\r\nif (!sp_model) {\r\nerr = SCSI_DH_DEV_UNSUPP;\r\ngoto out;\r\n}\r\nif (!strlen(sp_model) || !strncmp(sp_model, "FC",2))\r\ncsdev->flags |= CLARIION_SHORT_TRESPASS;\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: detected Clariion %s, flags %x\n",\r\nCLARIION_NAME, sp_model, csdev->flags);\r\nout:\r\nreturn err;\r\n}\r\nstatic int clariion_send_inquiry(struct scsi_device *sdev,\r\nstruct clariion_dh_data *csdev)\r\n{\r\nint err, retry = CLARIION_RETRIES;\r\nretry:\r\nerr = send_inquiry_cmd(sdev, 0xC0, csdev);\r\nif (err != SCSI_DH_OK && csdev->senselen) {\r\nstruct scsi_sense_hdr sshdr;\r\nerr = scsi_normalize_sense(csdev->sense, SCSI_SENSE_BUFFERSIZE,\r\n&sshdr);\r\nif (!err)\r\nreturn SCSI_DH_IO;\r\nerr = clariion_check_sense(sdev, &sshdr);\r\nif (retry > 0 && err == ADD_TO_MLQUEUE) {\r\nretry--;\r\ngoto retry;\r\n}\r\nsdev_printk(KERN_ERR, sdev, "%s: INQUIRY sense code "\r\n"%02x/%02x/%02x\n", CLARIION_NAME,\r\nsshdr.sense_key, sshdr.asc, sshdr.ascq);\r\nerr = SCSI_DH_IO;\r\n} else {\r\nerr = parse_sp_info_reply(sdev, csdev);\r\n}\r\nreturn err;\r\n}\r\nstatic int clariion_activate(struct scsi_device *sdev,\r\nactivate_complete fn, void *data)\r\n{\r\nstruct clariion_dh_data *csdev = get_clariion_data(sdev);\r\nint result;\r\nresult = clariion_send_inquiry(sdev, csdev);\r\nif (result != SCSI_DH_OK)\r\ngoto done;\r\nif (csdev->lun_state == CLARIION_LUN_OWNED)\r\ngoto done;\r\nresult = send_trespass_cmd(sdev, csdev);\r\nif (result != SCSI_DH_OK)\r\ngoto done;\r\nsdev_printk(KERN_INFO, sdev,"%s: %s trespass command sent\n",\r\nCLARIION_NAME,\r\ncsdev->flags&CLARIION_SHORT_TRESPASS?"short":"long" );\r\nresult = clariion_send_inquiry(sdev, csdev);\r\nif (result != SCSI_DH_OK)\r\ngoto done;\r\ndone:\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: at SP %c Port %d (%s, default SP %c)\n",\r\nCLARIION_NAME, csdev->current_sp + 'A',\r\ncsdev->port, lun_state[csdev->lun_state],\r\ncsdev->default_sp + 'A');\r\nif (fn)\r\nfn(data, result);\r\nreturn 0;\r\n}\r\nstatic int clariion_set_params(struct scsi_device *sdev, const char *params)\r\n{\r\nstruct clariion_dh_data *csdev = get_clariion_data(sdev);\r\nunsigned int hr = 0, st = 0, argc;\r\nconst char *p = params;\r\nint result = SCSI_DH_OK;\r\nif ((sscanf(params, "%u", &argc) != 1) || (argc != 2))\r\nreturn -EINVAL;\r\nwhile (*p++)\r\n;\r\nif ((sscanf(p, "%u", &st) != 1) || (st > 1))\r\nreturn -EINVAL;\r\nwhile (*p++)\r\n;\r\nif ((sscanf(p, "%u", &hr) != 1) || (hr > 1))\r\nreturn -EINVAL;\r\nif (st)\r\ncsdev->flags |= CLARIION_SHORT_TRESPASS;\r\nelse\r\ncsdev->flags &= ~CLARIION_SHORT_TRESPASS;\r\nif (hr)\r\ncsdev->flags |= CLARIION_HONOR_RESERVATIONS;\r\nelse\r\ncsdev->flags &= ~CLARIION_HONOR_RESERVATIONS;\r\nif (csdev->lun_state != CLARIION_LUN_OWNED)\r\ngoto done;\r\ncsdev->lun_state = CLARIION_LUN_UNINITIALIZED;\r\nresult = send_trespass_cmd(sdev, csdev);\r\nif (result != SCSI_DH_OK)\r\ngoto done;\r\nresult = clariion_send_inquiry(sdev, csdev);\r\ndone:\r\nreturn result;\r\n}\r\nstatic bool clariion_match(struct scsi_device *sdev)\r\n{\r\nint i;\r\nif (scsi_device_tpgs(sdev))\r\nreturn false;\r\nfor (i = 0; clariion_dev_list[i].vendor; i++) {\r\nif (!strncmp(sdev->vendor, clariion_dev_list[i].vendor,\r\nstrlen(clariion_dev_list[i].vendor)) &&\r\n!strncmp(sdev->model, clariion_dev_list[i].model,\r\nstrlen(clariion_dev_list[i].model))) {\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int clariion_bus_attach(struct scsi_device *sdev)\r\n{\r\nstruct scsi_dh_data *scsi_dh_data;\r\nstruct clariion_dh_data *h;\r\nunsigned long flags;\r\nint err;\r\nscsi_dh_data = kzalloc(sizeof(*scsi_dh_data)\r\n+ sizeof(*h) , GFP_KERNEL);\r\nif (!scsi_dh_data) {\r\nsdev_printk(KERN_ERR, sdev, "%s: Attach failed\n",\r\nCLARIION_NAME);\r\nreturn -ENOMEM;\r\n}\r\nscsi_dh_data->scsi_dh = &clariion_dh;\r\nh = (struct clariion_dh_data *) scsi_dh_data->buf;\r\nh->lun_state = CLARIION_LUN_UNINITIALIZED;\r\nh->default_sp = CLARIION_UNBOUND_LU;\r\nh->current_sp = CLARIION_UNBOUND_LU;\r\nerr = clariion_std_inquiry(sdev, h);\r\nif (err != SCSI_DH_OK)\r\ngoto failed;\r\nerr = clariion_send_inquiry(sdev, h);\r\nif (err != SCSI_DH_OK)\r\ngoto failed;\r\nif (!try_module_get(THIS_MODULE))\r\ngoto failed;\r\nspin_lock_irqsave(sdev->request_queue->queue_lock, flags);\r\nsdev->scsi_dh_data = scsi_dh_data;\r\nspin_unlock_irqrestore(sdev->request_queue->queue_lock, flags);\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: connected to SP %c Port %d (%s, default SP %c)\n",\r\nCLARIION_NAME, h->current_sp + 'A',\r\nh->port, lun_state[h->lun_state],\r\nh->default_sp + 'A');\r\nreturn 0;\r\nfailed:\r\nkfree(scsi_dh_data);\r\nsdev_printk(KERN_ERR, sdev, "%s: not attached\n",\r\nCLARIION_NAME);\r\nreturn -EINVAL;\r\n}\r\nstatic void clariion_bus_detach(struct scsi_device *sdev)\r\n{\r\nstruct scsi_dh_data *scsi_dh_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(sdev->request_queue->queue_lock, flags);\r\nscsi_dh_data = sdev->scsi_dh_data;\r\nsdev->scsi_dh_data = NULL;\r\nspin_unlock_irqrestore(sdev->request_queue->queue_lock, flags);\r\nsdev_printk(KERN_NOTICE, sdev, "%s: Detached\n",\r\nCLARIION_NAME);\r\nkfree(scsi_dh_data);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int __init clariion_init(void)\r\n{\r\nint r;\r\nr = scsi_register_device_handler(&clariion_dh);\r\nif (r != 0)\r\nprintk(KERN_ERR "%s: Failed to register scsi device handler.",\r\nCLARIION_NAME);\r\nreturn r;\r\n}\r\nstatic void __exit clariion_exit(void)\r\n{\r\nscsi_unregister_device_handler(&clariion_dh);\r\n}
