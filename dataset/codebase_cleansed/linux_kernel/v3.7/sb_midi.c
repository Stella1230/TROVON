static int sb_midi_open(int dev, int mode,\r\nvoid (*input) (int dev, unsigned char data),\r\nvoid (*output) (int dev)\r\n)\r\n{\r\nsb_devc *devc = midi_devs[dev]->devc;\r\nunsigned long flags;\r\nif (devc == NULL)\r\nreturn -ENXIO;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nif (devc->opened)\r\n{\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\nreturn -EBUSY;\r\n}\r\ndevc->opened = 1;\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\ndevc->irq_mode = IMODE_MIDI;\r\ndevc->midi_broken = 0;\r\nsb_dsp_reset(devc);\r\nif (!sb_dsp_command(devc, 0x35))\r\n{\r\ndevc->opened = 0;\r\nreturn -EIO;\r\n}\r\ndevc->intr_active = 1;\r\nif (mode & OPEN_READ)\r\n{\r\ndevc->input_opened = 1;\r\ndevc->midi_input_intr = input;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sb_midi_close(int dev)\r\n{\r\nsb_devc *devc = midi_devs[dev]->devc;\r\nunsigned long flags;\r\nif (devc == NULL)\r\nreturn;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nsb_dsp_reset(devc);\r\ndevc->intr_active = 0;\r\ndevc->input_opened = 0;\r\ndevc->opened = 0;\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\n}\r\nstatic int sb_midi_out(int dev, unsigned char midi_byte)\r\n{\r\nsb_devc *devc = midi_devs[dev]->devc;\r\nif (devc == NULL)\r\nreturn 1;\r\nif (devc->midi_broken)\r\nreturn 1;\r\nif (!sb_dsp_command(devc, midi_byte))\r\n{\r\ndevc->midi_broken = 1;\r\nreturn 1;\r\n}\r\nreturn 1;\r\n}\r\nstatic int sb_midi_start_read(int dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sb_midi_end_read(int dev)\r\n{\r\nsb_devc *devc = midi_devs[dev]->devc;\r\nif (devc == NULL)\r\nreturn -ENXIO;\r\nsb_dsp_reset(devc);\r\ndevc->intr_active = 0;\r\nreturn 0;\r\n}\r\nstatic int sb_midi_ioctl(int dev, unsigned cmd, void __user *arg)\r\n{\r\nreturn -EINVAL;\r\n}\r\nvoid sb_midi_interrupt(sb_devc * devc)\r\n{\r\nunsigned long flags;\r\nunsigned char data;\r\nif (devc == NULL)\r\nreturn;\r\nspin_lock_irqsave(&devc->lock, flags);\r\ndata = inb(DSP_READ);\r\nif (devc->input_opened)\r\ndevc->midi_input_intr(devc->my_mididev, data);\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\n}\r\nvoid sb_dsp_midi_init(sb_devc * devc, struct module *owner)\r\n{\r\nint dev;\r\nif (devc->model < 2)\r\nreturn;\r\ndev = sound_alloc_mididev();\r\nif (dev == -1)\r\n{\r\nprintk(KERN_ERR "sb_midi: too many MIDI devices detected\n");\r\nreturn;\r\n}\r\nstd_midi_synth.midi_dev = devc->my_mididev = dev;\r\nmidi_devs[dev] = kmalloc(sizeof(struct midi_operations), GFP_KERNEL);\r\nif (midi_devs[dev] == NULL)\r\n{\r\nprintk(KERN_WARNING "Sound Blaster: failed to allocate MIDI memory.\n");\r\nsound_unload_mididev(dev);\r\nreturn;\r\n}\r\nmemcpy((char *) midi_devs[dev], (char *) &sb_midi_operations,\r\nsizeof(struct midi_operations));\r\nif (owner)\r\nmidi_devs[dev]->owner = owner;\r\nmidi_devs[dev]->devc = devc;\r\nmidi_devs[dev]->converter = kmalloc(sizeof(struct synth_operations), GFP_KERNEL);\r\nif (midi_devs[dev]->converter == NULL)\r\n{\r\nprintk(KERN_WARNING "Sound Blaster: failed to allocate MIDI memory.\n");\r\nkfree(midi_devs[dev]);\r\nsound_unload_mididev(dev);\r\nreturn;\r\n}\r\nmemcpy((char *) midi_devs[dev]->converter, (char *) &std_midi_synth,\r\nsizeof(struct synth_operations));\r\nmidi_devs[dev]->converter->id = "SBMIDI";\r\nsequencer_init();\r\n}
