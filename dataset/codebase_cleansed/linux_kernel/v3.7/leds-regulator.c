static inline int led_regulator_get_max_brightness(struct regulator *supply)\r\n{\r\nint ret;\r\nint voltage = regulator_list_voltage(supply, 0);\r\nif (voltage <= 0)\r\nreturn 1;\r\nret = regulator_set_voltage(supply, voltage, voltage);\r\nif (ret < 0)\r\nreturn 1;\r\nreturn regulator_count_voltages(supply);\r\n}\r\nstatic int led_regulator_get_voltage(struct regulator *supply,\r\nenum led_brightness brightness)\r\n{\r\nif (brightness == 0)\r\nreturn -EINVAL;\r\nreturn regulator_list_voltage(supply, brightness - 1);\r\n}\r\nstatic void regulator_led_enable(struct regulator_led *led)\r\n{\r\nint ret;\r\nif (led->enabled)\r\nreturn;\r\nret = regulator_enable(led->vcc);\r\nif (ret != 0) {\r\ndev_err(led->cdev.dev, "Failed to enable vcc: %d\n", ret);\r\nreturn;\r\n}\r\nled->enabled = 1;\r\n}\r\nstatic void regulator_led_disable(struct regulator_led *led)\r\n{\r\nint ret;\r\nif (!led->enabled)\r\nreturn;\r\nret = regulator_disable(led->vcc);\r\nif (ret != 0) {\r\ndev_err(led->cdev.dev, "Failed to disable vcc: %d\n", ret);\r\nreturn;\r\n}\r\nled->enabled = 0;\r\n}\r\nstatic void regulator_led_set_value(struct regulator_led *led)\r\n{\r\nint voltage;\r\nint ret;\r\nmutex_lock(&led->mutex);\r\nif (led->value == LED_OFF) {\r\nregulator_led_disable(led);\r\ngoto out;\r\n}\r\nif (led->cdev.max_brightness > 1) {\r\nvoltage = led_regulator_get_voltage(led->vcc, led->value);\r\ndev_dbg(led->cdev.dev, "brightness: %d voltage: %d\n",\r\nled->value, voltage);\r\nret = regulator_set_voltage(led->vcc, voltage, voltage);\r\nif (ret != 0)\r\ndev_err(led->cdev.dev, "Failed to set voltage %d: %d\n",\r\nvoltage, ret);\r\n}\r\nregulator_led_enable(led);\r\nout:\r\nmutex_unlock(&led->mutex);\r\n}\r\nstatic void led_work(struct work_struct *work)\r\n{\r\nstruct regulator_led *led;\r\nled = container_of(work, struct regulator_led, work);\r\nregulator_led_set_value(led);\r\n}\r\nstatic void regulator_led_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct regulator_led *led = to_regulator_led(led_cdev);\r\nled->value = value;\r\nschedule_work(&led->work);\r\n}\r\nstatic int __devinit regulator_led_probe(struct platform_device *pdev)\r\n{\r\nstruct led_regulator_platform_data *pdata = pdev->dev.platform_data;\r\nstruct regulator_led *led;\r\nstruct regulator *vcc;\r\nint ret = 0;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nreturn -ENODEV;\r\n}\r\nvcc = regulator_get_exclusive(&pdev->dev, "vled");\r\nif (IS_ERR(vcc)) {\r\ndev_err(&pdev->dev, "Cannot get vcc for %s\n", pdata->name);\r\nreturn PTR_ERR(vcc);\r\n}\r\nled = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);\r\nif (led == NULL) {\r\nret = -ENOMEM;\r\ngoto err_vcc;\r\n}\r\nled->cdev.max_brightness = led_regulator_get_max_brightness(vcc);\r\nif (pdata->brightness > led->cdev.max_brightness) {\r\ndev_err(&pdev->dev, "Invalid default brightness %d\n",\r\npdata->brightness);\r\nret = -EINVAL;\r\ngoto err_vcc;\r\n}\r\nled->value = pdata->brightness;\r\nled->cdev.brightness_set = regulator_led_brightness_set;\r\nled->cdev.name = pdata->name;\r\nled->cdev.flags |= LED_CORE_SUSPENDRESUME;\r\nled->vcc = vcc;\r\nif (regulator_is_enabled(led->vcc))\r\nled->enabled = 1;\r\nmutex_init(&led->mutex);\r\nINIT_WORK(&led->work, led_work);\r\nplatform_set_drvdata(pdev, led);\r\nret = led_classdev_register(&pdev->dev, &led->cdev);\r\nif (ret < 0) {\r\ncancel_work_sync(&led->work);\r\ngoto err_vcc;\r\n}\r\nled->cdev.brightness = led->value;\r\nregulator_led_set_value(led);\r\nreturn 0;\r\nerr_vcc:\r\nregulator_put(vcc);\r\nreturn ret;\r\n}\r\nstatic int __devexit regulator_led_remove(struct platform_device *pdev)\r\n{\r\nstruct regulator_led *led = platform_get_drvdata(pdev);\r\nled_classdev_unregister(&led->cdev);\r\ncancel_work_sync(&led->work);\r\nregulator_led_disable(led);\r\nregulator_put(led->vcc);\r\nreturn 0;\r\n}
