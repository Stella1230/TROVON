void __init_rwsem(struct rw_semaphore *sem, const char *name,\r\nstruct lock_class_key *key)\r\n{\r\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\r\ndebug_check_no_locks_freed((void *)sem, sizeof(*sem));\r\nlockdep_init_map(&sem->dep_map, name, key, 0);\r\n#endif\r\nsem->count = RWSEM_UNLOCKED_VALUE;\r\nraw_spin_lock_init(&sem->wait_lock);\r\nINIT_LIST_HEAD(&sem->wait_list);\r\n}\r\nstatic struct rw_semaphore *\r\n__rwsem_do_wake(struct rw_semaphore *sem, int wake_type)\r\n{\r\nstruct rwsem_waiter *waiter;\r\nstruct task_struct *tsk;\r\nstruct list_head *next;\r\nsigned long oldcount, woken, loop, adjustment;\r\nwaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\r\nif (!(waiter->flags & RWSEM_WAITING_FOR_WRITE))\r\ngoto readers_only;\r\nif (wake_type == RWSEM_WAKE_READ_OWNED)\r\ngoto out;\r\nadjustment = RWSEM_ACTIVE_WRITE_BIAS;\r\nif (waiter->list.next == &sem->wait_list)\r\nadjustment -= RWSEM_WAITING_BIAS;\r\ntry_again_write:\r\noldcount = rwsem_atomic_update(adjustment, sem) - adjustment;\r\nif (oldcount & RWSEM_ACTIVE_MASK)\r\ngoto undo_write;\r\nlist_del(&waiter->list);\r\ntsk = waiter->task;\r\nsmp_mb();\r\nwaiter->task = NULL;\r\nwake_up_process(tsk);\r\nput_task_struct(tsk);\r\ngoto out;\r\nreaders_only:\r\nif (wake_type == RWSEM_WAKE_ANY &&\r\nrwsem_atomic_update(0, sem) < RWSEM_WAITING_BIAS)\r\ngoto out;\r\nwoken = 0;\r\ndo {\r\nwoken++;\r\nif (waiter->list.next == &sem->wait_list)\r\nbreak;\r\nwaiter = list_entry(waiter->list.next,\r\nstruct rwsem_waiter, list);\r\n} while (waiter->flags & RWSEM_WAITING_FOR_READ);\r\nadjustment = woken * RWSEM_ACTIVE_READ_BIAS;\r\nif (waiter->flags & RWSEM_WAITING_FOR_READ)\r\nadjustment -= RWSEM_WAITING_BIAS;\r\nrwsem_atomic_add(adjustment, sem);\r\nnext = sem->wait_list.next;\r\nfor (loop = woken; loop > 0; loop--) {\r\nwaiter = list_entry(next, struct rwsem_waiter, list);\r\nnext = waiter->list.next;\r\ntsk = waiter->task;\r\nsmp_mb();\r\nwaiter->task = NULL;\r\nwake_up_process(tsk);\r\nput_task_struct(tsk);\r\n}\r\nsem->wait_list.next = next;\r\nnext->prev = &sem->wait_list;\r\nout:\r\nreturn sem;\r\nundo_write:\r\nif (rwsem_atomic_update(-adjustment, sem) & RWSEM_ACTIVE_MASK)\r\ngoto out;\r\ngoto try_again_write;\r\n}\r\nstatic struct rw_semaphore __sched *\r\nrwsem_down_failed_common(struct rw_semaphore *sem,\r\nunsigned int flags, signed long adjustment)\r\n{\r\nstruct rwsem_waiter waiter;\r\nstruct task_struct *tsk = current;\r\nsigned long count;\r\nset_task_state(tsk, TASK_UNINTERRUPTIBLE);\r\nraw_spin_lock_irq(&sem->wait_lock);\r\nwaiter.task = tsk;\r\nwaiter.flags = flags;\r\nget_task_struct(tsk);\r\nif (list_empty(&sem->wait_list))\r\nadjustment += RWSEM_WAITING_BIAS;\r\nlist_add_tail(&waiter.list, &sem->wait_list);\r\ncount = rwsem_atomic_update(adjustment, sem);\r\nif (count == RWSEM_WAITING_BIAS)\r\nsem = __rwsem_do_wake(sem, RWSEM_WAKE_NO_ACTIVE);\r\nelse if (count > RWSEM_WAITING_BIAS &&\r\nadjustment == -RWSEM_ACTIVE_WRITE_BIAS)\r\nsem = __rwsem_do_wake(sem, RWSEM_WAKE_READ_OWNED);\r\nraw_spin_unlock_irq(&sem->wait_lock);\r\nfor (;;) {\r\nif (!waiter.task)\r\nbreak;\r\nschedule();\r\nset_task_state(tsk, TASK_UNINTERRUPTIBLE);\r\n}\r\ntsk->state = TASK_RUNNING;\r\nreturn sem;\r\n}\r\nstruct rw_semaphore __sched *rwsem_down_read_failed(struct rw_semaphore *sem)\r\n{\r\nreturn rwsem_down_failed_common(sem, RWSEM_WAITING_FOR_READ,\r\n-RWSEM_ACTIVE_READ_BIAS);\r\n}\r\nstruct rw_semaphore __sched *rwsem_down_write_failed(struct rw_semaphore *sem)\r\n{\r\nreturn rwsem_down_failed_common(sem, RWSEM_WAITING_FOR_WRITE,\r\n-RWSEM_ACTIVE_WRITE_BIAS);\r\n}\r\nstruct rw_semaphore *rwsem_wake(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nif (!list_empty(&sem->wait_list))\r\nsem = __rwsem_do_wake(sem, RWSEM_WAKE_ANY);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\nreturn sem;\r\n}\r\nstruct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nif (!list_empty(&sem->wait_list))\r\nsem = __rwsem_do_wake(sem, RWSEM_WAKE_READ_OWNED);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\nreturn sem;\r\n}
