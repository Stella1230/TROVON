static void __activate_col(const struct matrix_keypad_platform_data *pdata,\r\nint col, bool on)\r\n{\r\nbool level_on = !pdata->active_low;\r\nif (on) {\r\ngpio_direction_output(pdata->col_gpios[col], level_on);\r\n} else {\r\ngpio_set_value_cansleep(pdata->col_gpios[col], !level_on);\r\ngpio_direction_input(pdata->col_gpios[col]);\r\n}\r\n}\r\nstatic void activate_col(const struct matrix_keypad_platform_data *pdata,\r\nint col, bool on)\r\n{\r\n__activate_col(pdata, col, on);\r\nif (on && pdata->col_scan_delay_us)\r\nudelay(pdata->col_scan_delay_us);\r\n}\r\nstatic void activate_all_cols(const struct matrix_keypad_platform_data *pdata,\r\nbool on)\r\n{\r\nint col;\r\nfor (col = 0; col < pdata->num_col_gpios; col++)\r\n__activate_col(pdata, col, on);\r\n}\r\nstatic bool row_asserted(const struct matrix_keypad_platform_data *pdata,\r\nint row)\r\n{\r\nreturn gpio_get_value_cansleep(pdata->row_gpios[row]) ?\r\n!pdata->active_low : pdata->active_low;\r\n}\r\nstatic void enable_row_irqs(struct matrix_keypad *keypad)\r\n{\r\nconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\r\nint i;\r\nif (pdata->clustered_irq > 0)\r\nenable_irq(pdata->clustered_irq);\r\nelse {\r\nfor (i = 0; i < pdata->num_row_gpios; i++)\r\nenable_irq(gpio_to_irq(pdata->row_gpios[i]));\r\n}\r\n}\r\nstatic void disable_row_irqs(struct matrix_keypad *keypad)\r\n{\r\nconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\r\nint i;\r\nif (pdata->clustered_irq > 0)\r\ndisable_irq_nosync(pdata->clustered_irq);\r\nelse {\r\nfor (i = 0; i < pdata->num_row_gpios; i++)\r\ndisable_irq_nosync(gpio_to_irq(pdata->row_gpios[i]));\r\n}\r\n}\r\nstatic void matrix_keypad_scan(struct work_struct *work)\r\n{\r\nstruct matrix_keypad *keypad =\r\ncontainer_of(work, struct matrix_keypad, work.work);\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\r\nuint32_t new_state[MATRIX_MAX_COLS];\r\nint row, col, code;\r\nactivate_all_cols(pdata, false);\r\nmemset(new_state, 0, sizeof(new_state));\r\nfor (col = 0; col < pdata->num_col_gpios; col++) {\r\nactivate_col(pdata, col, true);\r\nfor (row = 0; row < pdata->num_row_gpios; row++)\r\nnew_state[col] |=\r\nrow_asserted(pdata, row) ? (1 << row) : 0;\r\nactivate_col(pdata, col, false);\r\n}\r\nfor (col = 0; col < pdata->num_col_gpios; col++) {\r\nuint32_t bits_changed;\r\nbits_changed = keypad->last_key_state[col] ^ new_state[col];\r\nif (bits_changed == 0)\r\ncontinue;\r\nfor (row = 0; row < pdata->num_row_gpios; row++) {\r\nif ((bits_changed & (1 << row)) == 0)\r\ncontinue;\r\ncode = MATRIX_SCAN_CODE(row, col, keypad->row_shift);\r\ninput_event(input_dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input_dev,\r\nkeypad->keycodes[code],\r\nnew_state[col] & (1 << row));\r\n}\r\n}\r\ninput_sync(input_dev);\r\nmemcpy(keypad->last_key_state, new_state, sizeof(new_state));\r\nactivate_all_cols(pdata, true);\r\nspin_lock_irq(&keypad->lock);\r\nkeypad->scan_pending = false;\r\nenable_row_irqs(keypad);\r\nspin_unlock_irq(&keypad->lock);\r\n}\r\nstatic irqreturn_t matrix_keypad_interrupt(int irq, void *id)\r\n{\r\nstruct matrix_keypad *keypad = id;\r\nunsigned long flags;\r\nspin_lock_irqsave(&keypad->lock, flags);\r\nif (unlikely(keypad->scan_pending || keypad->stopped))\r\ngoto out;\r\ndisable_row_irqs(keypad);\r\nkeypad->scan_pending = true;\r\nschedule_delayed_work(&keypad->work,\r\nmsecs_to_jiffies(keypad->pdata->debounce_ms));\r\nout:\r\nspin_unlock_irqrestore(&keypad->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int matrix_keypad_start(struct input_dev *dev)\r\n{\r\nstruct matrix_keypad *keypad = input_get_drvdata(dev);\r\nkeypad->stopped = false;\r\nmb();\r\nschedule_delayed_work(&keypad->work, 0);\r\nreturn 0;\r\n}\r\nstatic void matrix_keypad_stop(struct input_dev *dev)\r\n{\r\nstruct matrix_keypad *keypad = input_get_drvdata(dev);\r\nkeypad->stopped = true;\r\nmb();\r\nflush_work(&keypad->work.work);\r\ndisable_row_irqs(keypad);\r\n}\r\nstatic void matrix_keypad_enable_wakeup(struct matrix_keypad *keypad)\r\n{\r\nconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\r\nunsigned int gpio;\r\nint i;\r\nif (pdata->clustered_irq > 0) {\r\nif (enable_irq_wake(pdata->clustered_irq) == 0)\r\nkeypad->gpio_all_disabled = true;\r\n} else {\r\nfor (i = 0; i < pdata->num_row_gpios; i++) {\r\nif (!test_bit(i, keypad->disabled_gpios)) {\r\ngpio = pdata->row_gpios[i];\r\nif (enable_irq_wake(gpio_to_irq(gpio)) == 0)\r\n__set_bit(i, keypad->disabled_gpios);\r\n}\r\n}\r\n}\r\n}\r\nstatic void matrix_keypad_disable_wakeup(struct matrix_keypad *keypad)\r\n{\r\nconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\r\nunsigned int gpio;\r\nint i;\r\nif (pdata->clustered_irq > 0) {\r\nif (keypad->gpio_all_disabled) {\r\ndisable_irq_wake(pdata->clustered_irq);\r\nkeypad->gpio_all_disabled = false;\r\n}\r\n} else {\r\nfor (i = 0; i < pdata->num_row_gpios; i++) {\r\nif (test_and_clear_bit(i, keypad->disabled_gpios)) {\r\ngpio = pdata->row_gpios[i];\r\ndisable_irq_wake(gpio_to_irq(gpio));\r\n}\r\n}\r\n}\r\n}\r\nstatic int matrix_keypad_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct matrix_keypad *keypad = platform_get_drvdata(pdev);\r\nmatrix_keypad_stop(keypad->input_dev);\r\nif (device_may_wakeup(&pdev->dev))\r\nmatrix_keypad_enable_wakeup(keypad);\r\nreturn 0;\r\n}\r\nstatic int matrix_keypad_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct matrix_keypad *keypad = platform_get_drvdata(pdev);\r\nif (device_may_wakeup(&pdev->dev))\r\nmatrix_keypad_disable_wakeup(keypad);\r\nmatrix_keypad_start(keypad->input_dev);\r\nreturn 0;\r\n}\r\nstatic int __devinit matrix_keypad_init_gpio(struct platform_device *pdev,\r\nstruct matrix_keypad *keypad)\r\n{\r\nconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\r\nint i, err;\r\nfor (i = 0; i < pdata->num_col_gpios; i++) {\r\nerr = gpio_request(pdata->col_gpios[i], "matrix_kbd_col");\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"failed to request GPIO%d for COL%d\n",\r\npdata->col_gpios[i], i);\r\ngoto err_free_cols;\r\n}\r\ngpio_direction_output(pdata->col_gpios[i], !pdata->active_low);\r\n}\r\nfor (i = 0; i < pdata->num_row_gpios; i++) {\r\nerr = gpio_request(pdata->row_gpios[i], "matrix_kbd_row");\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"failed to request GPIO%d for ROW%d\n",\r\npdata->row_gpios[i], i);\r\ngoto err_free_rows;\r\n}\r\ngpio_direction_input(pdata->row_gpios[i]);\r\n}\r\nif (pdata->clustered_irq > 0) {\r\nerr = request_irq(pdata->clustered_irq,\r\nmatrix_keypad_interrupt,\r\npdata->clustered_irq_flags,\r\n"matrix-keypad", keypad);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Unable to acquire clustered interrupt\n");\r\ngoto err_free_rows;\r\n}\r\n} else {\r\nfor (i = 0; i < pdata->num_row_gpios; i++) {\r\nerr = request_irq(gpio_to_irq(pdata->row_gpios[i]),\r\nmatrix_keypad_interrupt,\r\nIRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING,\r\n"matrix-keypad", keypad);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Unable to acquire interrupt for GPIO line %i\n",\r\npdata->row_gpios[i]);\r\ngoto err_free_irqs;\r\n}\r\n}\r\n}\r\ndisable_row_irqs(keypad);\r\nreturn 0;\r\nerr_free_irqs:\r\nwhile (--i >= 0)\r\nfree_irq(gpio_to_irq(pdata->row_gpios[i]), keypad);\r\ni = pdata->num_row_gpios;\r\nerr_free_rows:\r\nwhile (--i >= 0)\r\ngpio_free(pdata->row_gpios[i]);\r\ni = pdata->num_col_gpios;\r\nerr_free_cols:\r\nwhile (--i >= 0)\r\ngpio_free(pdata->col_gpios[i]);\r\nreturn err;\r\n}\r\nstatic void matrix_keypad_free_gpio(struct matrix_keypad *keypad)\r\n{\r\nconst struct matrix_keypad_platform_data *pdata = keypad->pdata;\r\nint i;\r\nif (pdata->clustered_irq > 0) {\r\nfree_irq(pdata->clustered_irq, keypad);\r\n} else {\r\nfor (i = 0; i < pdata->num_row_gpios; i++)\r\nfree_irq(gpio_to_irq(pdata->row_gpios[i]), keypad);\r\n}\r\nfor (i = 0; i < pdata->num_row_gpios; i++)\r\ngpio_free(pdata->row_gpios[i]);\r\nfor (i = 0; i < pdata->num_col_gpios; i++)\r\ngpio_free(pdata->col_gpios[i]);\r\n}\r\nstatic int __devinit matrix_keypad_probe(struct platform_device *pdev)\r\n{\r\nconst struct matrix_keypad_platform_data *pdata;\r\nconst struct matrix_keymap_data *keymap_data;\r\nstruct matrix_keypad *keypad;\r\nstruct input_dev *input_dev;\r\nunsigned int row_shift;\r\nsize_t keymap_size;\r\nint err;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\nkeymap_data = pdata->keymap_data;\r\nif (!keymap_data) {\r\ndev_err(&pdev->dev, "no keymap data defined\n");\r\nreturn -EINVAL;\r\n}\r\nrow_shift = get_count_order(pdata->num_col_gpios);\r\nkeymap_size = (pdata->num_row_gpios << row_shift) *\r\nsizeof(keypad->keycodes[0]);\r\nkeypad = kzalloc(sizeof(struct matrix_keypad) + keymap_size,\r\nGFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!keypad || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nkeypad->input_dev = input_dev;\r\nkeypad->pdata = pdata;\r\nkeypad->row_shift = row_shift;\r\nkeypad->stopped = true;\r\nINIT_DELAYED_WORK(&keypad->work, matrix_keypad_scan);\r\nspin_lock_init(&keypad->lock);\r\ninput_dev->name = pdev->name;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->open = matrix_keypad_start;\r\ninput_dev->close = matrix_keypad_stop;\r\nerr = matrix_keypad_build_keymap(keymap_data, NULL,\r\npdata->num_row_gpios,\r\npdata->num_col_gpios,\r\nkeypad->keycodes, input_dev);\r\nif (err)\r\ngoto err_free_mem;\r\nif (!pdata->no_autorepeat)\r\n__set_bit(EV_REP, input_dev->evbit);\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(input_dev, keypad);\r\nerr = matrix_keypad_init_gpio(pdev, keypad);\r\nif (err)\r\ngoto err_free_mem;\r\nerr = input_register_device(keypad->input_dev);\r\nif (err)\r\ngoto err_free_gpio;\r\ndevice_init_wakeup(&pdev->dev, pdata->wakeup);\r\nplatform_set_drvdata(pdev, keypad);\r\nreturn 0;\r\nerr_free_gpio:\r\nmatrix_keypad_free_gpio(keypad);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(keypad);\r\nreturn err;\r\n}\r\nstatic int __devexit matrix_keypad_remove(struct platform_device *pdev)\r\n{\r\nstruct matrix_keypad *keypad = platform_get_drvdata(pdev);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nmatrix_keypad_free_gpio(keypad);\r\ninput_unregister_device(keypad->input_dev);\r\nkfree(keypad);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
