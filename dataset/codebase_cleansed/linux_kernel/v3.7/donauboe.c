static int\r\ntoshoboe_checkfcs (unsigned char *buf, int len)\r\n{\r\nint i;\r\nunion\r\n{\r\n__u16 value;\r\n__u8 bytes[2];\r\n}\r\nfcs;\r\nfcs.value = INIT_FCS;\r\nfor (i = 0; i < len; ++i)\r\nfcs.value = irda_fcs (fcs.value, *(buf++));\r\nreturn fcs.value == GOOD_FCS;\r\n}\r\nstatic void\r\n_dumpbufs (unsigned char *data, int len, char tete)\r\n{\r\nint i,j;\r\nchar head=tete;\r\nfor (i=0;i<len;i+=16) {\r\nfor (j=0;j<16 && i+j<len;j++) { sprintf(&dump[3*j],"%02x.",data[i+j]); }\r\ndump [3*j]=0;\r\nIRDA_DEBUG (2, "%c%s\n",head , dump);\r\nhead='+';\r\n}\r\n}\r\nstatic void\r\ntoshoboe_dumpregs (struct toshoboe_cb *self)\r\n{\r\n__u32 ringbase;\r\nIRDA_DEBUG (4, "%s()\n", __func__);\r\nringbase = INB (OBOE_RING_BASE0) << 10;\r\nringbase |= INB (OBOE_RING_BASE1) << 18;\r\nringbase |= INB (OBOE_RING_BASE2) << 26;\r\nprintk (KERN_ERR DRIVER_NAME ": Register dump:\n");\r\nprintk (KERN_ERR "Interrupts: Tx:%d Rx:%d TxUnder:%d RxOver:%d Sip:%d\n",\r\nself->int_tx, self->int_rx, self->int_txunder, self->int_rxover,\r\nself->int_sip);\r\nprintk (KERN_ERR "RX %02x TX %02x RingBase %08x\n",\r\nINB (OBOE_RXSLOT), INB (OBOE_TXSLOT), ringbase);\r\nprintk (KERN_ERR "RING_SIZE %02x IER %02x ISR %02x\n",\r\nINB (OBOE_RING_SIZE), INB (OBOE_IER), INB (OBOE_ISR));\r\nprintk (KERN_ERR "CONFIG1 %02x STATUS %02x\n",\r\nINB (OBOE_CONFIG1), INB (OBOE_STATUS));\r\nprintk (KERN_ERR "CONFIG0 %02x%02x ENABLE %02x%02x\n",\r\nINB (OBOE_CONFIG0H), INB (OBOE_CONFIG0L),\r\nINB (OBOE_ENABLEH), INB (OBOE_ENABLEL));\r\nprintk (KERN_ERR "NEW_PCONFIG %02x%02x CURR_PCONFIG %02x%02x\n",\r\nINB (OBOE_NEW_PCONFIGH), INB (OBOE_NEW_PCONFIGL),\r\nINB (OBOE_CURR_PCONFIGH), INB (OBOE_CURR_PCONFIGL));\r\nprintk (KERN_ERR "MAXLEN %02x%02x RXCOUNT %02x%02x\n",\r\nINB (OBOE_MAXLENH), INB (OBOE_MAXLENL),\r\nINB (OBOE_RXCOUNTL), INB (OBOE_RXCOUNTH));\r\nif (self->ring)\r\n{\r\nint i;\r\nringbase = virt_to_bus (self->ring);\r\nprintk (KERN_ERR "Ring at %08x:\n", ringbase);\r\nprintk (KERN_ERR "RX:");\r\nfor (i = 0; i < RX_SLOTS; ++i)\r\nprintk (" (%d,%02x)",self->ring->rx[i].len,self->ring->rx[i].control);\r\nprintk ("\n");\r\nprintk (KERN_ERR "TX:");\r\nfor (i = 0; i < RX_SLOTS; ++i)\r\nprintk (" (%d,%02x)",self->ring->tx[i].len,self->ring->tx[i].control);\r\nprintk ("\n");\r\n}\r\n}\r\nstatic void\r\ntoshoboe_disablebm (struct toshoboe_cb *self)\r\n{\r\n__u8 command;\r\nIRDA_DEBUG (4, "%s()\n", __func__);\r\npci_read_config_byte (self->pdev, PCI_COMMAND, &command);\r\ncommand &= ~PCI_COMMAND_MASTER;\r\npci_write_config_byte (self->pdev, PCI_COMMAND, command);\r\n}\r\nstatic void\r\ntoshoboe_stopchip (struct toshoboe_cb *self)\r\n{\r\nIRDA_DEBUG (4, "%s()\n", __func__);\r\nOUTB (0x0, OBOE_IER);\r\nOUTB (CONFIG0H_DMA_OFF, OBOE_CONFIG0H);\r\nOUTB (0x00, OBOE_ENABLEH);\r\nOUTB (0x3f, OBOE_RING_BASE2);\r\nOUTB (0xff, OBOE_RING_BASE1);\r\nOUTB (0xff, OBOE_RING_BASE0);\r\nOUTB (RX_LEN >> 8, OBOE_MAXLENH);\r\nOUTB (RX_LEN & 0xff, OBOE_MAXLENL);\r\nOUTB (0xff, OBOE_ISR);\r\nOUTB (OBOE_ENABLEH_PHYANDCLOCK, OBOE_ENABLEH);\r\nOUTB (OBOE_CONFIG1_OFF, OBOE_CONFIG1);\r\ntoshoboe_disablebm (self);\r\n}\r\nstatic void\r\ntoshoboe_start_DMA (struct toshoboe_cb *self, int opts)\r\n{\r\nOUTB (0x0, OBOE_ENABLEH);\r\nOUTB (CONFIG0H_DMA_ON | opts, OBOE_CONFIG0H);\r\nOUTB (OBOE_ENABLEH_PHYANDCLOCK, OBOE_ENABLEH);\r\nPROMPT;\r\n}\r\nstatic void\r\ntoshoboe_setbaud (struct toshoboe_cb *self)\r\n{\r\n__u16 pconfig = 0;\r\n__u8 config0l = 0;\r\nIRDA_DEBUG (2, "%s(%d/%d)\n", __func__, self->speed, self->io.speed);\r\nswitch (self->speed)\r\n{\r\ncase 2400:\r\ncase 4800:\r\ncase 9600:\r\ncase 19200:\r\ncase 38400:\r\ncase 57600:\r\ncase 115200:\r\n#ifdef USE_MIR\r\ncase 1152000:\r\n#endif\r\ncase 4000000:\r\nbreak;\r\ndefault:\r\nprintk (KERN_ERR DRIVER_NAME ": switch to unsupported baudrate %d\n",\r\nself->speed);\r\nreturn;\r\n}\r\nswitch (self->speed)\r\n{\r\ncase 2400:\r\npconfig |= 47 << OBOE_PCONFIG_BAUDSHIFT;\r\npconfig |= 25 << OBOE_PCONFIG_WIDTHSHIFT;\r\nbreak;\r\ncase 4800:\r\npconfig |= 23 << OBOE_PCONFIG_BAUDSHIFT;\r\npconfig |= 25 << OBOE_PCONFIG_WIDTHSHIFT;\r\nbreak;\r\ncase 9600:\r\npconfig |= 11 << OBOE_PCONFIG_BAUDSHIFT;\r\npconfig |= 25 << OBOE_PCONFIG_WIDTHSHIFT;\r\nbreak;\r\ncase 19200:\r\npconfig |= 5 << OBOE_PCONFIG_BAUDSHIFT;\r\npconfig |= 25 << OBOE_PCONFIG_WIDTHSHIFT;\r\nbreak;\r\ncase 38400:\r\npconfig |= 2 << OBOE_PCONFIG_BAUDSHIFT;\r\npconfig |= 25 << OBOE_PCONFIG_WIDTHSHIFT;\r\nbreak;\r\ncase 57600:\r\npconfig |= 1 << OBOE_PCONFIG_BAUDSHIFT;\r\npconfig |= 25 << OBOE_PCONFIG_WIDTHSHIFT;\r\nbreak;\r\ncase 115200:\r\npconfig |= 0 << OBOE_PCONFIG_BAUDSHIFT;\r\npconfig |= 25 << OBOE_PCONFIG_WIDTHSHIFT;\r\nbreak;\r\ndefault:\r\nOUTB (RX_LEN >> 8, OBOE_MAXLENH);\r\nOUTB (RX_LEN & 0xff, OBOE_MAXLENL);\r\nbreak;\r\n}\r\nswitch (self->speed)\r\n{\r\ncase 2400:\r\ncase 4800:\r\ncase 9600:\r\ncase 19200:\r\ncase 38400:\r\ncase 57600:\r\ncase 115200:\r\nconfig0l = OBOE_CONFIG0L_ENSIR;\r\nif (self->async)\r\n{\r\nOUTB (0x01, OBOE_MAXLENH);\r\nOUTB (0x01, OBOE_MAXLENL);\r\nOUTB (0x00, OBOE_MAXLENH);\r\n}\r\nelse\r\n{\r\nconfig0l |= OBOE_CONFIG0L_ENSIRF;\r\nOUTB (RX_LEN >> 8, OBOE_MAXLENH);\r\nOUTB (RX_LEN & 0xff, OBOE_MAXLENL);\r\n}\r\nbreak;\r\n#ifdef USE_MIR\r\ncase 1152000:\r\npconfig |= 0 << OBOE_PCONFIG_BAUDSHIFT;\r\npconfig |= 8 << OBOE_PCONFIG_WIDTHSHIFT;\r\npconfig |= 1 << OBOE_PCONFIG_PREAMBLESHIFT;\r\nconfig0l = OBOE_CONFIG0L_CRC16 | OBOE_CONFIG0L_ENMIR;\r\nbreak;\r\n#endif\r\ncase 4000000:\r\npconfig |= 0 << OBOE_PCONFIG_BAUDSHIFT;\r\npconfig |= 15 << OBOE_PCONFIG_PREAMBLESHIFT;\r\nconfig0l = OBOE_CONFIG0L_ENFIR;\r\nbreak;\r\n}\r\nOUTBP (pconfig >> 8, OBOE_NEW_PCONFIGH);\r\nOUTB (pconfig & 0xff, OBOE_NEW_PCONFIGL);\r\nOUTB (config0l, OBOE_CONFIG0L);\r\nOUTB (0x0, OBOE_ENABLEH);\r\nOUTB (OBOE_ENABLEH_PHYANDCLOCK, OBOE_ENABLEH);\r\nPROMPT;\r\nself->new_speed = 0;\r\nself->io.speed = self->speed;\r\n}\r\nstatic void\r\ntoshoboe_enablebm (struct toshoboe_cb *self)\r\n{\r\nIRDA_DEBUG (4, "%s()\n", __func__);\r\npci_set_master (self->pdev);\r\n}\r\nstatic void\r\ntoshoboe_initring (struct toshoboe_cb *self)\r\n{\r\nint i;\r\nIRDA_DEBUG (4, "%s()\n", __func__);\r\nfor (i = 0; i < TX_SLOTS; ++i)\r\n{\r\nself->ring->tx[i].len = 0;\r\nself->ring->tx[i].control = 0x00;\r\nself->ring->tx[i].address = virt_to_bus (self->tx_bufs[i]);\r\n}\r\nfor (i = 0; i < RX_SLOTS; ++i)\r\n{\r\nself->ring->rx[i].len = RX_LEN;\r\nself->ring->rx[i].len = 0;\r\nself->ring->rx[i].address = virt_to_bus (self->rx_bufs[i]);\r\nself->ring->rx[i].control = OBOE_CTL_RX_HW_OWNS;\r\n}\r\n}\r\nstatic void\r\ntoshoboe_resetptrs (struct toshoboe_cb *self)\r\n{\r\nOUTB (0x0, OBOE_ENABLEH);\r\nOUTBP (CONFIG0H_DMA_OFF, OBOE_CONFIG0H);\r\nOUTB (OBOE_ENABLEH_PHYANDCLOCK, OBOE_ENABLEH);\r\nself->rxs = inb_p (OBOE_RXSLOT) & OBOE_SLOT_MASK;\r\nself->txs = inb_p (OBOE_TXSLOT) & OBOE_SLOT_MASK;\r\n}\r\nstatic void\r\ntoshoboe_initptrs (struct toshoboe_cb *self)\r\n{\r\ntoshoboe_resetptrs (self);\r\nOUTB (0x0, OBOE_ENABLEH);\r\nOUTB (CONFIG0H_DMA_ON, OBOE_CONFIG0H);\r\nOUTB (OBOE_ENABLEH_PHYANDCLOCK, OBOE_ENABLEH);\r\nself->txpending = 0;\r\n}\r\nstatic void\r\ntoshoboe_startchip (struct toshoboe_cb *self)\r\n{\r\n__u32 physaddr;\r\nIRDA_DEBUG (4, "%s()\n", __func__);\r\ntoshoboe_initring (self);\r\ntoshoboe_enablebm (self);\r\nOUTBP (OBOE_CONFIG1_RESET, OBOE_CONFIG1);\r\nOUTBP (OBOE_CONFIG1_ON, OBOE_CONFIG1);\r\nOUTB (0, OBOE_ENABLEH);\r\nOUTB (RING_SIZE, OBOE_RING_SIZE);\r\nOUTB (0xff, OBOE_ISR);\r\nOUTB (OBOE_INT_TXDONE | OBOE_INT_RXDONE |\r\nOBOE_INT_TXUNDER | OBOE_INT_RXOVER | OBOE_INT_SIP , OBOE_IER);\r\nOUTB (0xff, OBOE_ISR);\r\nOUTB (RX_LEN >> 8, OBOE_MAXLENH);\r\nOUTB (RX_LEN & 0xff, OBOE_MAXLENL);\r\nOUTB (CONFIG0H_DMA_OFF, OBOE_CONFIG0H);\r\nphysaddr = virt_to_bus (self->ring);\r\nIRDA_ASSERT ((physaddr & 0x3ff) == 0,\r\nprintk (KERN_ERR DRIVER_NAME "ring not correctly aligned\n");\r\nreturn;);\r\nOUTB ((physaddr >> 10) & 0xff, OBOE_RING_BASE0);\r\nOUTB ((physaddr >> 18) & 0xff, OBOE_RING_BASE1);\r\nOUTB ((physaddr >> 26) & 0x3f, OBOE_RING_BASE2);\r\nOUTB (CONFIG0H_DMA_ON, OBOE_CONFIG0H);\r\nOUTB (OBOE_ENABLEH_PHYANDCLOCK, OBOE_ENABLEH);\r\nself->speed = 9600;\r\ntoshoboe_setbaud (self);\r\ntoshoboe_initptrs (self);\r\n}\r\nstatic void\r\ntoshoboe_isntstuck (struct toshoboe_cb *self)\r\n{\r\n}\r\nstatic void\r\ntoshoboe_checkstuck (struct toshoboe_cb *self)\r\n{\r\nunsigned long flags;\r\nif (0)\r\n{\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nprintk (KERN_ERR DRIVER_NAME ": Resetting chip\n");\r\ntoshoboe_stopchip (self);\r\ntoshoboe_startchip (self);\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\n}\r\n}\r\nstatic int\r\ntoshoboe_makemttpacket (struct toshoboe_cb *self, void *buf, int mtt)\r\n{\r\nint xbofs;\r\nxbofs = ((int) (mtt/100)) * (int) (self->speed);\r\nxbofs=xbofs/80000;\r\nxbofs++;\r\nIRDA_DEBUG (2, DRIVER_NAME\r\n": generated mtt of %d bytes for %d us at %d baud\n"\r\n, xbofs,mtt,self->speed);\r\nif (xbofs > TX_LEN)\r\n{\r\nprintk (KERN_ERR DRIVER_NAME ": wanted %d bytes MTT but TX_LEN is %d\n",\r\nxbofs, TX_LEN);\r\nxbofs = TX_LEN;\r\n}\r\nmemset (buf, XBOF, xbofs);\r\nreturn xbofs;\r\n}\r\nstatic void\r\ntoshoboe_dumptx (struct toshoboe_cb *self)\r\n{\r\nint i;\r\nPROBE_DEBUG(KERN_WARNING "TX:");\r\nfor (i = 0; i < RX_SLOTS; ++i)\r\nPROBE_DEBUG(" (%d,%02x)",self->ring->tx[i].len,self->ring->tx[i].control);\r\nPROBE_DEBUG(" [%d]\n",self->speed);\r\n}\r\nstatic void\r\ntoshoboe_dumprx (struct toshoboe_cb *self, int score)\r\n{\r\nint i;\r\nPROBE_DEBUG(" %d\nRX:",score);\r\nfor (i = 0; i < RX_SLOTS; ++i)\r\nPROBE_DEBUG(" (%d,%02x)",self->ring->rx[i].len,self->ring->rx[i].control);\r\nPROBE_DEBUG("\n");\r\n}\r\nstatic inline int\r\nstuff_byte (__u8 byte, __u8 * buf)\r\n{\r\nswitch (byte)\r\n{\r\ncase BOF:\r\ncase EOF:\r\ncase CE:\r\nbuf[0] = CE;\r\nbuf[1] = byte ^ IRDA_TRANS;\r\nreturn 2;\r\ndefault:\r\nbuf[0] = byte;\r\nreturn 1;\r\n}\r\n}\r\nstatic irqreturn_t\r\ntoshoboe_probeinterrupt (int irq, void *dev_id)\r\n{\r\nstruct toshoboe_cb *self = dev_id;\r\n__u8 irqstat;\r\nirqstat = INB (OBOE_ISR);\r\nif (!(irqstat & OBOE_INT_MASK))\r\nreturn IRQ_NONE;\r\nOUTB (irqstat, OBOE_ISR);\r\nif (irqstat & OBOE_INT_TXDONE)\r\n{\r\nint txp;\r\nself->int_tx++;\r\nPROBE_DEBUG("T");\r\ntxp = INB (OBOE_TXSLOT) & OBOE_SLOT_MASK;\r\nif (self->ring->tx[txp].control & OBOE_CTL_TX_HW_OWNS)\r\n{\r\nself->int_tx+=100;\r\nPROBE_DEBUG("S");\r\ntoshoboe_start_DMA(self, OBOE_CONFIG0H_ENTX | OBOE_CONFIG0H_LOOP);\r\n}\r\n}\r\nif (irqstat & OBOE_INT_RXDONE) {\r\nself->int_rx++;\r\nPROBE_DEBUG("R"); }\r\nif (irqstat & OBOE_INT_TXUNDER) {\r\nself->int_txunder++;\r\nPROBE_DEBUG("U"); }\r\nif (irqstat & OBOE_INT_RXOVER) {\r\nself->int_rxover++;\r\nPROBE_DEBUG("O"); }\r\nif (irqstat & OBOE_INT_SIP) {\r\nself->int_sip++;\r\nPROBE_DEBUG("I"); }\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\ntoshoboe_maketestpacket (unsigned char *buf, int badcrc, int fir)\r\n{\r\nint i;\r\nint len = 0;\r\nunion\r\n{\r\n__u16 value;\r\n__u8 bytes[2];\r\n}\r\nfcs;\r\nif (fir)\r\n{\r\nmemset (buf, 0, TT_LEN);\r\nreturn TT_LEN;\r\n}\r\nfcs.value = INIT_FCS;\r\nmemset (buf, XBOF, 10);\r\nlen += 10;\r\nbuf[len++] = BOF;\r\nfor (i = 0; i < TT_LEN; ++i)\r\n{\r\nlen += stuff_byte (i, buf + len);\r\nfcs.value = irda_fcs (fcs.value, i);\r\n}\r\nlen += stuff_byte (fcs.bytes[0] ^ badcrc, buf + len);\r\nlen += stuff_byte (fcs.bytes[1] ^ badcrc, buf + len);\r\nbuf[len++] = EOF;\r\nlen++;\r\nreturn len;\r\n}\r\nstatic int\r\ntoshoboe_probefail (struct toshoboe_cb *self, char *msg)\r\n{\r\nprintk (KERN_ERR DRIVER_NAME "probe(%d) failed %s\n",self-> speed, msg);\r\ntoshoboe_dumpregs (self);\r\ntoshoboe_stopchip (self);\r\nfree_irq (self->io.irq, (void *) self);\r\nreturn 0;\r\n}\r\nstatic int\r\ntoshoboe_numvalidrcvs (struct toshoboe_cb *self)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; i < RX_SLOTS; ++i)\r\nif ((self->ring->rx[i].control & 0xe0) == 0)\r\nret++;\r\nreturn ret;\r\n}\r\nstatic int\r\ntoshoboe_numrcvs (struct toshoboe_cb *self)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; i < RX_SLOTS; ++i)\r\nif (!(self->ring->rx[i].control & OBOE_CTL_RX_HW_OWNS))\r\nret++;\r\nreturn ret;\r\n}\r\nstatic int\r\ntoshoboe_probe (struct toshoboe_cb *self)\r\n{\r\nint i, j, n;\r\n#ifdef USE_MIR\r\nstatic const int bauds[] = { 9600, 115200, 4000000, 1152000 };\r\n#else\r\nstatic const int bauds[] = { 9600, 115200, 4000000 };\r\n#endif\r\nunsigned long flags;\r\nIRDA_DEBUG (4, "%s()\n", __func__);\r\nif (request_irq (self->io.irq, toshoboe_probeinterrupt,\r\nself->io.irqflags, "toshoboe", (void *) self))\r\n{\r\nprintk (KERN_ERR DRIVER_NAME ": probe failed to allocate irq %d\n",\r\nself->io.irq);\r\nreturn 0;\r\n}\r\nfor (j = 0; j < ARRAY_SIZE(bauds); ++j)\r\n{\r\nint fir = (j > 1);\r\ntoshoboe_stopchip (self);\r\nspin_lock_irqsave(&self->spinlock, flags);\r\ntoshoboe_startchip (self);\r\nself->int_rx = self->int_tx = 0;\r\nself->speed = bauds[j];\r\ntoshoboe_setbaud (self);\r\ntoshoboe_initptrs (self);\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nself->ring->tx[self->txs].control =\r\n(fir) ? OBOE_CTL_TX_HW_OWNS | OBOE_CTL_TX_RTCENTX\r\n: OBOE_CTL_TX_HW_OWNS ;\r\nself->ring->tx[self->txs].len =\r\ntoshoboe_maketestpacket (self->tx_bufs[self->txs], 0, fir);\r\nself->txs++;\r\nself->txs %= TX_SLOTS;\r\nself->ring->tx[self->txs].control =\r\n(fir) ? OBOE_CTL_TX_HW_OWNS | OBOE_CTL_TX_SIP\r\n: OBOE_CTL_TX_HW_OWNS | OBOE_CTL_TX_RTCENTX ;\r\nself->ring->tx[self->txs].len =\r\ntoshoboe_maketestpacket (self->tx_bufs[self->txs], 0, fir);\r\nself->txs++;\r\nself->txs %= TX_SLOTS;\r\nself->ring->tx[self->txs].control =\r\n(fir) ? OBOE_CTL_TX_HW_OWNS | OBOE_CTL_TX_RTCENTX\r\n: OBOE_CTL_TX_HW_OWNS ;\r\nself->ring->tx[self->txs].len =\r\ntoshoboe_maketestpacket (self->tx_bufs[self->txs], 0, fir);\r\nself->txs++;\r\nself->txs %= TX_SLOTS;\r\nself->ring->tx[self->txs].control =\r\n(fir) ? OBOE_CTL_TX_HW_OWNS | OBOE_CTL_TX_RTCENTX\r\n| OBOE_CTL_TX_SIP | OBOE_CTL_TX_BAD_CRC\r\n: OBOE_CTL_TX_HW_OWNS | OBOE_CTL_TX_RTCENTX ;\r\nself->ring->tx[self->txs].len =\r\ntoshoboe_maketestpacket (self->tx_bufs[self->txs], 0, fir);\r\nself->txs++;\r\nself->txs %= TX_SLOTS;\r\ntoshoboe_dumptx (self);\r\ntoshoboe_start_DMA(self, OBOE_CONFIG0H_ENTX | OBOE_CONFIG0H_LOOP);\r\ni = 0;\r\nn = fir ? 1 : 4;\r\nwhile (toshoboe_numvalidrcvs (self) != n)\r\n{\r\nif (i > 4800)\r\nreturn toshoboe_probefail (self, "filter test");\r\nudelay ((9600*(TT_LEN+16))/self->speed);\r\ni++;\r\n}\r\nn = fir ? 203 : 102;\r\nwhile ((toshoboe_numrcvs(self) != self->int_rx) || (self->int_tx != n))\r\n{\r\nif (i > 4800)\r\nreturn toshoboe_probefail (self, "interrupt test");\r\nudelay ((9600*(TT_LEN+16))/self->speed);\r\ni++;\r\n}\r\ntoshoboe_dumprx (self,i);\r\n}\r\ntoshoboe_stopchip (self);\r\nself->int_rx = self->int_tx = 0;\r\nspin_lock_irqsave(&self->spinlock, flags);\r\ntoshoboe_startchip (self);\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nself->async = 1;\r\nself->speed = 115200;\r\ntoshoboe_setbaud (self);\r\nself->ring->tx[self->txs].control =\r\nOBOE_CTL_TX_RTCENTX | OBOE_CTL_TX_HW_OWNS;\r\nself->ring->tx[self->txs].len = 4;\r\n((unsigned char *) self->tx_bufs[self->txs])[0] = 'f';\r\n((unsigned char *) self->tx_bufs[self->txs])[1] = 'i';\r\n((unsigned char *) self->tx_bufs[self->txs])[2] = 's';\r\n((unsigned char *) self->tx_bufs[self->txs])[3] = 'h';\r\ntoshoboe_dumptx (self);\r\ntoshoboe_start_DMA(self, OBOE_CONFIG0H_ENTX | OBOE_CONFIG0H_LOOP);\r\ni = 0;\r\nwhile (toshoboe_numvalidrcvs (self) != 4)\r\n{\r\nif (i > 100)\r\nreturn toshoboe_probefail (self, "Async test");\r\nudelay (100);\r\ni++;\r\n}\r\nwhile ((toshoboe_numrcvs (self) != self->int_rx) || (self->int_tx != 1))\r\n{\r\nif (i > 100)\r\nreturn toshoboe_probefail (self, "Async interrupt test");\r\nudelay (100);\r\ni++;\r\n}\r\ntoshoboe_dumprx (self,i);\r\nself->async = 0;\r\nself->speed = 9600;\r\ntoshoboe_setbaud (self);\r\ntoshoboe_stopchip (self);\r\nfree_irq (self->io.irq, (void *) self);\r\nprintk (KERN_WARNING DRIVER_NAME ": Self test passed ok\n");\r\nreturn 1;\r\n}\r\nstatic netdev_tx_t\r\ntoshoboe_hard_xmit (struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct toshoboe_cb *self;\r\n__s32 speed;\r\nint mtt, len, ctl;\r\nunsigned long flags;\r\nstruct irda_skb_cb *cb = (struct irda_skb_cb *) skb->cb;\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT (self != NULL, return NETDEV_TX_OK; );\r\nIRDA_DEBUG (1, "%s.tx:%x(%x)%x\n", __func__\r\n,skb->len,self->txpending,INB (OBOE_ENABLEH));\r\nif (!cb->magic) {\r\nIRDA_DEBUG (2, "%s.Not IrLAP:%x\n", __func__, cb->magic);\r\n#ifdef DUMP_PACKETS\r\n_dumpbufs(skb->data,skb->len,'>');\r\n#endif\r\n}\r\nif (self->new_speed)\r\nreturn NETDEV_TX_BUSY;\r\nif (self->stopped)\r\nreturn NETDEV_TX_BUSY;\r\ntoshoboe_checkstuck (self);\r\nspeed=irda_get_next_speed(skb);\r\nif ((speed != self->io.speed) && (speed != -1))\r\n{\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nif (self->txpending || skb->len)\r\n{\r\nself->new_speed = speed;\r\nIRDA_DEBUG (1, "%s: Queued TxDone scheduled speed change %d\n" ,\r\n__func__, speed);\r\nif (!skb->len)\r\n{\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\ndev_kfree_skb (skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\n}\r\nelse\r\n{\r\nself->speed = speed;\r\ntoshoboe_setbaud (self);\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\ndev_kfree_skb (skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\n}\r\nif ((mtt = irda_get_mtt(skb)))\r\n{\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nif (self->txpending)\r\n{\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nmtt = toshoboe_makemttpacket (self, self->tx_bufs[self->txs], mtt);\r\nIRDA_DEBUG (1, "%s.mtt:%x(%x)%d\n", __func__\r\n,skb->len,mtt,self->txpending);\r\nif (mtt)\r\n{\r\nself->ring->tx[self->txs].len = mtt & 0xfff;\r\nctl = OBOE_CTL_TX_HW_OWNS | OBOE_CTL_TX_RTCENTX;\r\nif (INB (OBOE_ENABLEH) & OBOE_ENABLEH_FIRON)\r\n{\r\nctl |= OBOE_CTL_TX_BAD_CRC | OBOE_CTL_TX_SIP ;\r\n}\r\n#ifdef USE_MIR\r\nelse if (INB (OBOE_ENABLEH) & OBOE_ENABLEH_MIRON)\r\n{\r\nctl |= OBOE_CTL_TX_BAD_CRC;\r\n}\r\n#endif\r\nself->ring->tx[self->txs].control = ctl;\r\nOUTB (0x0, OBOE_ENABLEH);\r\ntoshoboe_start_DMA(self, OBOE_CONFIG0H_ENTX | OBOE_CONFIG0H_LOOP);\r\nself->txpending++;\r\nself->txs++;\r\nself->txs %= TX_SLOTS;\r\n}\r\nelse\r\n{\r\nprintk(KERN_ERR DRIVER_NAME ": problem with mtt packet - ignored\n");\r\n}\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\n}\r\n#ifdef DUMP_PACKETS\r\ndumpbufs(skb->data,skb->len,'>');\r\n#endif\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nif (self->ring->tx[self->txs].control & OBOE_CTL_TX_HW_OWNS)\r\n{\r\nIRDA_DEBUG (0, "%s.ful:%x(%x)%x\n", __func__\r\n,skb->len, self->ring->tx[self->txs].control, self->txpending);\r\ntoshoboe_start_DMA(self, OBOE_CONFIG0H_ENTX);\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (INB (OBOE_ENABLEH) & OBOE_ENABLEH_SIRON)\r\n{\r\nlen = async_wrap_skb (skb, self->tx_bufs[self->txs], TX_BUF_SZ);\r\n}\r\nelse\r\n{\r\nlen = skb->len;\r\nskb_copy_from_linear_data(skb, self->tx_bufs[self->txs], len);\r\n}\r\nself->ring->tx[self->txs].len = len & 0x0fff;\r\nctl = OBOE_CTL_TX_HW_OWNS | OBOE_CTL_TX_RTCENTX;\r\nif (INB (OBOE_ENABLEH) & OBOE_ENABLEH_FIRON)\r\n{\r\nctl |= OBOE_CTL_TX_SIP ;\r\n}\r\nself->ring->tx[self->txs].control = ctl;\r\nif (!self->txpending)\r\ntoshoboe_start_DMA(self, OBOE_CONFIG0H_ENTX);\r\nself->txpending++;\r\nself->txs++;\r\nself->txs %= TX_SLOTS;\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\ndev_kfree_skb (skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t\r\ntoshoboe_interrupt (int irq, void *dev_id)\r\n{\r\nstruct toshoboe_cb *self = dev_id;\r\n__u8 irqstat;\r\nstruct sk_buff *skb = NULL;\r\nirqstat = INB (OBOE_ISR);\r\nif (!(irqstat & OBOE_INT_MASK))\r\nreturn IRQ_NONE;\r\nOUTB (irqstat, OBOE_ISR);\r\ntoshoboe_isntstuck (self);\r\nif (irqstat & OBOE_INT_TXDONE)\r\n{\r\nint txp, txpc;\r\nint i;\r\ntxp = self->txpending;\r\nself->txpending = 0;\r\nfor (i = 0; i < TX_SLOTS; ++i)\r\n{\r\nif (self->ring->tx[i].control & OBOE_CTL_TX_HW_OWNS)\r\nself->txpending++;\r\n}\r\nIRDA_DEBUG (1, "%s.txd(%x)%x/%x\n", __func__\r\n,irqstat,txp,self->txpending);\r\ntxp = INB (OBOE_TXSLOT) & OBOE_SLOT_MASK;\r\nif (self->ring->tx[txp].control & OBOE_CTL_TX_HW_OWNS)\r\n{\r\ntxpc = txp;\r\n#ifdef OPTIMIZE_TX\r\nwhile (self->ring->tx[txpc].control & OBOE_CTL_TX_HW_OWNS)\r\n{\r\ntxp = txpc;\r\ntxpc++;\r\ntxpc %= TX_SLOTS;\r\nself->netdev->stats.tx_packets++;\r\nif (self->ring->tx[txpc].control & OBOE_CTL_TX_HW_OWNS)\r\nself->ring->tx[txp].control &= ~OBOE_CTL_TX_RTCENTX;\r\n}\r\nself->netdev->stats.tx_packets--;\r\n#else\r\nself->netdev->stats.tx_packets++;\r\n#endif\r\ntoshoboe_start_DMA(self, OBOE_CONFIG0H_ENTX);\r\n}\r\nif ((!self->txpending) && (self->new_speed))\r\n{\r\nself->speed = self->new_speed;\r\nIRDA_DEBUG (1, "%s: Executed TxDone scheduled speed change %d\n",\r\n__func__, self->speed);\r\ntoshoboe_setbaud (self);\r\n}\r\nif (!self->new_speed)\r\nnetif_wake_queue(self->netdev);\r\n}\r\nif (irqstat & OBOE_INT_RXDONE)\r\n{\r\nwhile (!(self->ring->rx[self->rxs].control & OBOE_CTL_RX_HW_OWNS))\r\n{\r\nint len = self->ring->rx[self->rxs].len;\r\nskb = NULL;\r\nIRDA_DEBUG (3, "%s.rcv:%x(%x)\n", __func__\r\n,len,self->ring->rx[self->rxs].control);\r\n#ifdef DUMP_PACKETS\r\ndumpbufs(self->rx_bufs[self->rxs],len,'<');\r\n#endif\r\nif (self->ring->rx[self->rxs].control == 0)\r\n{\r\n__u8 enable = INB (OBOE_ENABLEH);\r\nif (enable & OBOE_ENABLEH_SIRON)\r\n{\r\nif (!toshoboe_checkfcs (self->rx_bufs[self->rxs], len))\r\nlen = 0;\r\nif (len > 1)\r\nlen -= 2;\r\nelse\r\nlen = 0;\r\nIRDA_DEBUG (1, "%s.SIR:%x(%x)\n", __func__, len,enable);\r\n}\r\n#ifdef USE_MIR\r\nelse if (enable & OBOE_ENABLEH_MIRON)\r\n{\r\nif (len > 1)\r\nlen -= 2;\r\nelse\r\nlen = 0;\r\nIRDA_DEBUG (2, "%s.MIR:%x(%x)\n", __func__, len,enable);\r\n}\r\n#endif\r\nelse if (enable & OBOE_ENABLEH_FIRON)\r\n{\r\nif (len > 3)\r\nlen -= 4;\r\nelse\r\nlen = 0;\r\nIRDA_DEBUG (1, "%s.FIR:%x(%x)\n", __func__, len,enable);\r\n}\r\nelse\r\nIRDA_DEBUG (0, "%s.?IR:%x(%x)\n", __func__, len,enable);\r\nif (len)\r\n{\r\nskb = dev_alloc_skb (len + 1);\r\nif (skb)\r\n{\r\nskb_reserve (skb, 1);\r\nskb_put (skb, len);\r\nskb_copy_to_linear_data(skb, self->rx_bufs[self->rxs],\r\nlen);\r\nself->netdev->stats.rx_packets++;\r\nskb->dev = self->netdev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons (ETH_P_IRDA);\r\n}\r\nelse\r\n{\r\nprintk (KERN_INFO\r\n"%s(), memory squeeze, dropping frame.\n",\r\n__func__);\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nIRDA_DEBUG (0, "%s.err:%x(%x)\n", __func__\r\n,len,self->ring->rx[self->rxs].control);\r\n}\r\nself->ring->rx[self->rxs].len = 0x0;\r\nself->ring->rx[self->rxs].control = OBOE_CTL_RX_HW_OWNS;\r\nself->rxs++;\r\nself->rxs %= RX_SLOTS;\r\nif (skb)\r\nnetif_rx (skb);\r\n}\r\n}\r\nif (irqstat & OBOE_INT_TXUNDER)\r\n{\r\nprintk (KERN_WARNING DRIVER_NAME ": tx fifo underflow\n");\r\n}\r\nif (irqstat & OBOE_INT_RXOVER)\r\n{\r\nprintk (KERN_WARNING DRIVER_NAME ": rx fifo overflow\n");\r\n}\r\nif (irqstat & OBOE_INT_SIP)\r\n{\r\nself->int_sip++;\r\nIRDA_DEBUG (1, "%s.sip:%x(%x)%x\n", __func__\r\n,self->int_sip,irqstat,self->txpending);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\ntoshoboe_net_open (struct net_device *dev)\r\n{\r\nstruct toshoboe_cb *self;\r\nunsigned long flags;\r\nint rc;\r\nIRDA_DEBUG (4, "%s()\n", __func__);\r\nself = netdev_priv(dev);\r\nif (self->async)\r\nreturn -EBUSY;\r\nif (self->stopped)\r\nreturn 0;\r\nrc = request_irq (self->io.irq, toshoboe_interrupt,\r\nIRQF_SHARED | IRQF_DISABLED, dev->name, self);\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&self->spinlock, flags);\r\ntoshoboe_startchip (self);\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nnetif_start_queue(dev);\r\nself->irlap = irlap_open (dev, &self->qos, driver_name);\r\nself->irdad = 1;\r\nreturn 0;\r\n}\r\nstatic int\r\ntoshoboe_net_close (struct net_device *dev)\r\n{\r\nstruct toshoboe_cb *self;\r\nIRDA_DEBUG (4, "%s()\n", __func__);\r\nIRDA_ASSERT (dev != NULL, return -1; );\r\nself = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nif (self->irlap)\r\nirlap_close (self->irlap);\r\nself->irlap = NULL;\r\nself->irdad = 0;\r\nfree_irq (self->io.irq, (void *) self);\r\nif (!self->stopped)\r\n{\r\ntoshoboe_stopchip (self);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ntoshoboe_net_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct if_irda_req *irq = (struct if_irda_req *) rq;\r\nstruct toshoboe_cb *self;\r\nunsigned long flags;\r\nint ret = 0;\r\nIRDA_ASSERT (dev != NULL, return -1; );\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT (self != NULL, return -1; );\r\nIRDA_DEBUG (5, "%s(), %s, (cmd=0x%X)\n", __func__, dev->name, cmd);\r\nspin_lock_irqsave(&self->spinlock, flags);\r\nswitch (cmd)\r\n{\r\ncase SIOCSBANDWIDTH:\r\nIRDA_DEBUG (1, "%s(BANDWIDTH), %s, (%X/%ld\n", __func__\r\n,dev->name, INB (OBOE_STATUS), irq->ifr_baudrate );\r\nif (!in_interrupt () && !capable (CAP_NET_ADMIN)) {\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nself->new_speed = irq->ifr_baudrate;\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nIRDA_DEBUG (1, "%s(MEDIABUSY), %s, (%X/%x)\n", __func__\r\n,dev->name, INB (OBOE_STATUS), capable (CAP_NET_ADMIN) );\r\nif (!capable (CAP_NET_ADMIN)) {\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nirda_device_set_media_busy (self->netdev, TRUE);\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nirq->ifr_receiving = (INB (OBOE_STATUS) & OBOE_STATUS_RXBUSY) ? 1 : 0;\r\nIRDA_DEBUG (3, "%s(RECEIVING), %s, (%X/%x)\n", __func__\r\n,dev->name, INB (OBOE_STATUS), irq->ifr_receiving );\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG (1, "%s(?), %s, (cmd=0x%X)\n", __func__, dev->name, cmd);\r\nret = -EOPNOTSUPP;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nreturn ret;\r\n}\r\nstatic void\r\ntoshoboe_close (struct pci_dev *pci_dev)\r\n{\r\nint i;\r\nstruct toshoboe_cb *self = (struct toshoboe_cb*)pci_get_drvdata(pci_dev);\r\nIRDA_DEBUG (4, "%s()\n", __func__);\r\nIRDA_ASSERT (self != NULL, return; );\r\nif (!self->stopped)\r\n{\r\ntoshoboe_stopchip (self);\r\n}\r\nrelease_region (self->io.fir_base, self->io.fir_ext);\r\nfor (i = 0; i < TX_SLOTS; ++i)\r\n{\r\nkfree (self->tx_bufs[i]);\r\nself->tx_bufs[i] = NULL;\r\n}\r\nfor (i = 0; i < RX_SLOTS; ++i)\r\n{\r\nkfree (self->rx_bufs[i]);\r\nself->rx_bufs[i] = NULL;\r\n}\r\nunregister_netdev(self->netdev);\r\nkfree (self->ringbuf);\r\nself->ringbuf = NULL;\r\nself->ring = NULL;\r\nfree_netdev(self->netdev);\r\n}\r\nstatic int\r\ntoshoboe_open (struct pci_dev *pci_dev, const struct pci_device_id *pdid)\r\n{\r\nstruct toshoboe_cb *self;\r\nstruct net_device *dev;\r\nint i = 0;\r\nint ok = 0;\r\nint err;\r\nIRDA_DEBUG (4, "%s()\n", __func__);\r\nif ((err=pci_enable_device(pci_dev)))\r\nreturn err;\r\ndev = alloc_irdadev(sizeof (struct toshoboe_cb));\r\nif (dev == NULL)\r\n{\r\nprintk (KERN_ERR DRIVER_NAME ": can't allocate memory for "\r\n"IrDA control block\n");\r\nreturn -ENOMEM;\r\n}\r\nself = netdev_priv(dev);\r\nself->netdev = dev;\r\nself->pdev = pci_dev;\r\nself->base = pci_resource_start(pci_dev,0);\r\nself->io.fir_base = self->base;\r\nself->io.fir_ext = OBOE_IO_EXTENT;\r\nself->io.irq = pci_dev->irq;\r\nself->io.irqflags = IRQF_SHARED | IRQF_DISABLED;\r\nself->speed = self->io.speed = 9600;\r\nself->async = 0;\r\nif (NULL==request_region (self->io.fir_base, self->io.fir_ext, driver_name))\r\n{\r\nprintk (KERN_ERR DRIVER_NAME ": can't get iobase of 0x%03x\n"\r\n,self->io.fir_base);\r\nerr = -EBUSY;\r\ngoto freeself;\r\n}\r\nspin_lock_init(&self->spinlock);\r\nirda_init_max_qos_capabilies (&self->qos);\r\nself->qos.baud_rate.bits = 0;\r\nif (max_baud >= 2400)\r\nself->qos.baud_rate.bits |= IR_2400;\r\nif (max_baud >= 9600)\r\nself->qos.baud_rate.bits |= IR_9600;\r\nif (max_baud >= 19200)\r\nself->qos.baud_rate.bits |= IR_19200;\r\nif (max_baud >= 115200)\r\nself->qos.baud_rate.bits |= IR_115200;\r\n#ifdef USE_MIR\r\nif (max_baud >= 1152000)\r\n{\r\nself->qos.baud_rate.bits |= IR_1152000;\r\n}\r\n#endif\r\nif (max_baud >= 4000000)\r\n{\r\nself->qos.baud_rate.bits |= (IR_4000000 << 8);\r\n}\r\nself->qos.min_turn_time.bits = 0xff;\r\nirda_qos_bits_to_value (&self->qos);\r\nself->ringbuf = kmalloc(OBOE_RING_LEN << 1, GFP_KERNEL);\r\nif (!self->ringbuf)\r\n{\r\nerr = -ENOMEM;\r\ngoto freeregion;\r\n}\r\n#if (BITS_PER_LONG == 64)\r\n#error broken on 64-bit: casts pointer to 32-bit, and then back to pointer.\r\n#endif\r\n{\r\nunsigned long addr;\r\naddr = (__u32) self->ringbuf;\r\naddr &= ~(OBOE_RING_LEN - 1);\r\naddr += OBOE_RING_LEN;\r\nself->ring = (struct OboeRing *) addr;\r\n}\r\nmemset (self->ring, 0, OBOE_RING_LEN);\r\nself->io.mem_base = (__u32) self->ring;\r\nok = 1;\r\nfor (i = 0; i < TX_SLOTS; ++i)\r\n{\r\nself->tx_bufs[i] = kmalloc (TX_BUF_SZ, GFP_KERNEL);\r\nif (!self->tx_bufs[i])\r\nok = 0;\r\n}\r\nfor (i = 0; i < RX_SLOTS; ++i)\r\n{\r\nself->rx_bufs[i] = kmalloc (RX_BUF_SZ, GFP_KERNEL);\r\nif (!self->rx_bufs[i])\r\nok = 0;\r\n}\r\nif (!ok)\r\n{\r\nerr = -ENOMEM;\r\ngoto freebufs;\r\n}\r\n#ifdef USE_PROBE\r\nif (do_probe)\r\nif (!toshoboe_probe (self))\r\n{\r\nerr = -ENODEV;\r\ngoto freebufs;\r\n}\r\n#endif\r\nSET_NETDEV_DEV(dev, &pci_dev->dev);\r\ndev->netdev_ops = &toshoboe_netdev_ops;\r\nerr = register_netdev(dev);\r\nif (err)\r\n{\r\nprintk (KERN_ERR DRIVER_NAME ": register_netdev() failed\n");\r\nerr = -ENOMEM;\r\ngoto freebufs;\r\n}\r\nprintk (KERN_INFO "IrDA: Registered device %s\n", dev->name);\r\npci_set_drvdata(pci_dev,self);\r\nprintk (KERN_INFO DRIVER_NAME ": Using multiple tasks\n");\r\nreturn 0;\r\nfreebufs:\r\nfor (i = 0; i < TX_SLOTS; ++i)\r\nkfree (self->tx_bufs[i]);\r\nfor (i = 0; i < RX_SLOTS; ++i)\r\nkfree (self->rx_bufs[i]);\r\nkfree(self->ringbuf);\r\nfreeregion:\r\nrelease_region (self->io.fir_base, self->io.fir_ext);\r\nfreeself:\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic int\r\ntoshoboe_gotosleep (struct pci_dev *pci_dev, pm_message_t crap)\r\n{\r\nstruct toshoboe_cb *self = (struct toshoboe_cb*)pci_get_drvdata(pci_dev);\r\nunsigned long flags;\r\nint i = 10;\r\nIRDA_DEBUG (4, "%s()\n", __func__);\r\nif (!self || self->stopped)\r\nreturn 0;\r\nif ((!self->irdad) && (!self->async))\r\nreturn 0;\r\nwhile ((i--) && (self->txpending))\r\nmsleep(10);\r\nspin_lock_irqsave(&self->spinlock, flags);\r\ntoshoboe_stopchip (self);\r\nself->stopped = 1;\r\nself->txpending = 0;\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\ntoshoboe_wakeup (struct pci_dev *pci_dev)\r\n{\r\nstruct toshoboe_cb *self = (struct toshoboe_cb*)pci_get_drvdata(pci_dev);\r\nunsigned long flags;\r\nIRDA_DEBUG (4, "%s()\n", __func__);\r\nif (!self || !self->stopped)\r\nreturn 0;\r\nif ((!self->irdad) && (!self->async))\r\nreturn 0;\r\nspin_lock_irqsave(&self->spinlock, flags);\r\ntoshoboe_startchip (self);\r\nself->stopped = 0;\r\nnetif_wake_queue(self->netdev);\r\nspin_unlock_irqrestore(&self->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init\r\ndonauboe_init (void)\r\n{\r\nreturn pci_register_driver(&donauboe_pci_driver);\r\n}\r\nstatic void __exit\r\ndonauboe_cleanup (void)\r\n{\r\npci_unregister_driver(&donauboe_pci_driver);\r\n}
