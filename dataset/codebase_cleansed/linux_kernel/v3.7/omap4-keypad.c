static int kbd_readl(struct omap4_keypad *keypad_data, u32 offset)\r\n{\r\nreturn __raw_readl(keypad_data->base +\r\nkeypad_data->reg_offset + offset);\r\n}\r\nstatic void kbd_writel(struct omap4_keypad *keypad_data, u32 offset, u32 value)\r\n{\r\n__raw_writel(value,\r\nkeypad_data->base + keypad_data->reg_offset + offset);\r\n}\r\nstatic int kbd_read_irqreg(struct omap4_keypad *keypad_data, u32 offset)\r\n{\r\nreturn __raw_readl(keypad_data->base +\r\nkeypad_data->irqreg_offset + offset);\r\n}\r\nstatic void kbd_write_irqreg(struct omap4_keypad *keypad_data,\r\nu32 offset, u32 value)\r\n{\r\n__raw_writel(value,\r\nkeypad_data->base + keypad_data->irqreg_offset + offset);\r\n}\r\nstatic irqreturn_t omap4_keypad_interrupt(int irq, void *dev_id)\r\n{\r\nstruct omap4_keypad *keypad_data = dev_id;\r\nstruct input_dev *input_dev = keypad_data->input;\r\nunsigned char key_state[ARRAY_SIZE(keypad_data->key_state)];\r\nunsigned int col, row, code, changed;\r\nu32 *new_state = (u32 *) key_state;\r\nkbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,\r\nOMAP4_VAL_IRQDISABLE);\r\n*new_state = kbd_readl(keypad_data, OMAP4_KBD_FULLCODE31_0);\r\n*(new_state + 1) = kbd_readl(keypad_data, OMAP4_KBD_FULLCODE63_32);\r\nfor (row = 0; row < keypad_data->rows; row++) {\r\nchanged = key_state[row] ^ keypad_data->key_state[row];\r\nif (!changed)\r\ncontinue;\r\nfor (col = 0; col < keypad_data->cols; col++) {\r\nif (changed & (1 << col)) {\r\ncode = MATRIX_SCAN_CODE(row, col,\r\nkeypad_data->row_shift);\r\ninput_event(input_dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input_dev,\r\nkeypad_data->keymap[code],\r\nkey_state[row] & (1 << col));\r\n}\r\n}\r\n}\r\ninput_sync(input_dev);\r\nmemcpy(keypad_data->key_state, key_state,\r\nsizeof(keypad_data->key_state));\r\nkbd_write_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS,\r\nkbd_read_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS));\r\nkbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,\r\nOMAP4_DEF_IRQENABLE_EVENTEN |\r\nOMAP4_DEF_IRQENABLE_LONGKEY);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int omap4_keypad_open(struct input_dev *input)\r\n{\r\nstruct omap4_keypad *keypad_data = input_get_drvdata(input);\r\npm_runtime_get_sync(input->dev.parent);\r\ndisable_irq(keypad_data->irq);\r\nkbd_writel(keypad_data, OMAP4_KBD_CTRL,\r\nOMAP4_VAL_FUNCTIONALCFG);\r\nkbd_writel(keypad_data, OMAP4_KBD_DEBOUNCINGTIME,\r\nOMAP4_VAL_DEBOUNCINGTIME);\r\nkbd_write_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS,\r\nOMAP4_VAL_IRQDISABLE);\r\nkbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,\r\nOMAP4_DEF_IRQENABLE_EVENTEN |\r\nOMAP4_DEF_IRQENABLE_LONGKEY);\r\nkbd_writel(keypad_data, OMAP4_KBD_WAKEUPENABLE,\r\nOMAP4_DEF_WUP_EVENT_ENA | OMAP4_DEF_WUP_LONG_KEY_ENA);\r\nenable_irq(keypad_data->irq);\r\nreturn 0;\r\n}\r\nstatic void omap4_keypad_close(struct input_dev *input)\r\n{\r\nstruct omap4_keypad *keypad_data = input_get_drvdata(input);\r\ndisable_irq(keypad_data->irq);\r\nkbd_write_irqreg(keypad_data, OMAP4_KBD_IRQENABLE,\r\nOMAP4_VAL_IRQDISABLE);\r\nkbd_write_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS,\r\nkbd_read_irqreg(keypad_data, OMAP4_KBD_IRQSTATUS));\r\nenable_irq(keypad_data->irq);\r\npm_runtime_put_sync(input->dev.parent);\r\n}\r\nstatic int __devinit omap4_keypad_parse_dt(struct device *dev,\r\nstruct omap4_keypad *keypad_data)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nif (!np) {\r\ndev_err(dev, "missing DT data");\r\nreturn -EINVAL;\r\n}\r\nof_property_read_u32(np, "keypad,num-rows", &keypad_data->rows);\r\nof_property_read_u32(np, "keypad,num-columns", &keypad_data->cols);\r\nif (!keypad_data->rows || !keypad_data->cols) {\r\ndev_err(dev, "number of keypad rows/columns not specified\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_get_property(np, "linux,input-no-autorepeat", NULL))\r\nkeypad_data->no_autorepeat = true;\r\nreturn 0;\r\n}\r\nstatic inline int omap4_keypad_parse_dt(struct device *dev,\r\nstruct omap4_keypad *keypad_data)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int __devinit omap4_keypad_probe(struct platform_device *pdev)\r\n{\r\nconst struct omap4_keypad_platform_data *pdata =\r\ndev_get_platdata(&pdev->dev);\r\nconst struct matrix_keymap_data *keymap_data =\r\npdata ? pdata->keymap_data : NULL;\r\nstruct omap4_keypad *keypad_data;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nunsigned int max_keys;\r\nint rev;\r\nint irq;\r\nint error;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no base address specified\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "no keyboard irq assigned\n");\r\nreturn -EINVAL;\r\n}\r\nkeypad_data = kzalloc(sizeof(struct omap4_keypad), GFP_KERNEL);\r\nif (!keypad_data) {\r\ndev_err(&pdev->dev, "keypad_data memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nkeypad_data->irq = irq;\r\nif (pdata) {\r\nkeypad_data->rows = pdata->rows;\r\nkeypad_data->cols = pdata->cols;\r\n} else {\r\nerror = omap4_keypad_parse_dt(&pdev->dev, keypad_data);\r\nif (error)\r\nreturn error;\r\n}\r\nres = request_mem_region(res->start, resource_size(res), pdev->name);\r\nif (!res) {\r\ndev_err(&pdev->dev, "can't request mem region\n");\r\nerror = -EBUSY;\r\ngoto err_free_keypad;\r\n}\r\nkeypad_data->base = ioremap(res->start, resource_size(res));\r\nif (!keypad_data->base) {\r\ndev_err(&pdev->dev, "can't ioremap mem resource\n");\r\nerror = -ENOMEM;\r\ngoto err_release_mem;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nerror = pm_runtime_get_sync(&pdev->dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "pm_runtime_get_sync() failed\n");\r\ngoto err_unmap;\r\n}\r\nrev = __raw_readl(keypad_data->base + OMAP4_KBD_REVISION);\r\nrev &= 0x03 << 30;\r\nrev >>= 30;\r\nswitch (rev) {\r\ncase KBD_REVISION_OMAP4:\r\nkeypad_data->reg_offset = 0x00;\r\nkeypad_data->irqreg_offset = 0x00;\r\nbreak;\r\ncase KBD_REVISION_OMAP5:\r\nkeypad_data->reg_offset = 0x10;\r\nkeypad_data->irqreg_offset = 0x0c;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev,\r\n"Keypad reports unsupported revision %d", rev);\r\nerror = -EINVAL;\r\ngoto err_pm_put_sync;\r\n}\r\nkeypad_data->input = input_dev = input_allocate_device();\r\nif (!input_dev) {\r\nerror = -ENOMEM;\r\ngoto err_pm_put_sync;\r\n}\r\ninput_dev->name = pdev->name;\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->id.vendor = 0x0001;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0001;\r\ninput_dev->open = omap4_keypad_open;\r\ninput_dev->close = omap4_keypad_close;\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\nif (!keypad_data->no_autorepeat)\r\n__set_bit(EV_REP, input_dev->evbit);\r\ninput_set_drvdata(input_dev, keypad_data);\r\nkeypad_data->row_shift = get_count_order(keypad_data->cols);\r\nmax_keys = keypad_data->rows << keypad_data->row_shift;\r\nkeypad_data->keymap = kzalloc(max_keys * sizeof(keypad_data->keymap[0]),\r\nGFP_KERNEL);\r\nif (!keypad_data->keymap) {\r\ndev_err(&pdev->dev, "Not enough memory for keymap\n");\r\nerror = -ENOMEM;\r\ngoto err_free_input;\r\n}\r\nerror = matrix_keypad_build_keymap(keymap_data, NULL,\r\nkeypad_data->rows, keypad_data->cols,\r\nkeypad_data->keymap, input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to build keymap\n");\r\ngoto err_free_keymap;\r\n}\r\nerror = request_irq(keypad_data->irq, omap4_keypad_interrupt,\r\nIRQF_TRIGGER_RISING,\r\n"omap4-keypad", keypad_data);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register interrupt\n");\r\ngoto err_free_input;\r\n}\r\npm_runtime_put_sync(&pdev->dev);\r\nerror = input_register_device(keypad_data->input);\r\nif (error < 0) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\ngoto err_pm_disable;\r\n}\r\nplatform_set_drvdata(pdev, keypad_data);\r\nreturn 0;\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nfree_irq(keypad_data->irq, keypad_data);\r\nerr_free_keymap:\r\nkfree(keypad_data->keymap);\r\nerr_free_input:\r\ninput_free_device(input_dev);\r\nerr_pm_put_sync:\r\npm_runtime_put_sync(&pdev->dev);\r\nerr_unmap:\r\niounmap(keypad_data->base);\r\nerr_release_mem:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_free_keypad:\r\nkfree(keypad_data);\r\nreturn error;\r\n}\r\nstatic int __devexit omap4_keypad_remove(struct platform_device *pdev)\r\n{\r\nstruct omap4_keypad *keypad_data = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nfree_irq(keypad_data->irq, keypad_data);\r\npm_runtime_disable(&pdev->dev);\r\ninput_unregister_device(keypad_data->input);\r\niounmap(keypad_data->base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(keypad_data->keymap);\r\nkfree(keypad_data);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
