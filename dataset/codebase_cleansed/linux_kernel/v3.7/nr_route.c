static struct nr_node *nr_node_get(ax25_address *callsign)\r\n{\r\nstruct nr_node *found = NULL;\r\nstruct nr_node *nr_node;\r\nstruct hlist_node *node;\r\nspin_lock_bh(&nr_node_list_lock);\r\nnr_node_for_each(nr_node, node, &nr_node_list)\r\nif (ax25cmp(callsign, &nr_node->callsign) == 0) {\r\nnr_node_hold(nr_node);\r\nfound = nr_node;\r\nbreak;\r\n}\r\nspin_unlock_bh(&nr_node_list_lock);\r\nreturn found;\r\n}\r\nstatic struct nr_neigh *nr_neigh_get_dev(ax25_address *callsign,\r\nstruct net_device *dev)\r\n{\r\nstruct nr_neigh *found = NULL;\r\nstruct nr_neigh *nr_neigh;\r\nstruct hlist_node *node;\r\nspin_lock_bh(&nr_neigh_list_lock);\r\nnr_neigh_for_each(nr_neigh, node, &nr_neigh_list)\r\nif (ax25cmp(callsign, &nr_neigh->callsign) == 0 &&\r\nnr_neigh->dev == dev) {\r\nnr_neigh_hold(nr_neigh);\r\nfound = nr_neigh;\r\nbreak;\r\n}\r\nspin_unlock_bh(&nr_neigh_list_lock);\r\nreturn found;\r\n}\r\nstatic int __must_check nr_add_node(ax25_address *nr, const char *mnemonic,\r\nax25_address *ax25, ax25_digi *ax25_digi, struct net_device *dev,\r\nint quality, int obs_count)\r\n{\r\nstruct nr_node *nr_node;\r\nstruct nr_neigh *nr_neigh;\r\nstruct nr_route nr_route;\r\nint i, found;\r\nstruct net_device *odev;\r\nif ((odev=nr_dev_get(nr)) != NULL) {\r\ndev_put(odev);\r\nreturn -EINVAL;\r\n}\r\nnr_node = nr_node_get(nr);\r\nnr_neigh = nr_neigh_get_dev(ax25, dev);\r\nif (nr_neigh != NULL && nr_neigh->failed != 0 && quality == 0) {\r\nstruct nr_node *nr_nodet;\r\nstruct hlist_node *node;\r\nspin_lock_bh(&nr_node_list_lock);\r\nnr_node_for_each(nr_nodet, node, &nr_node_list) {\r\nnr_node_lock(nr_nodet);\r\nfor (i = 0; i < nr_nodet->count; i++)\r\nif (nr_nodet->routes[i].neighbour == nr_neigh)\r\nif (i < nr_nodet->which)\r\nnr_nodet->which = i;\r\nnr_node_unlock(nr_nodet);\r\n}\r\nspin_unlock_bh(&nr_node_list_lock);\r\n}\r\nif (nr_neigh != NULL)\r\nnr_neigh->failed = 0;\r\nif (quality == 0 && nr_neigh != NULL && nr_node != NULL) {\r\nnr_neigh_put(nr_neigh);\r\nnr_node_put(nr_node);\r\nreturn 0;\r\n}\r\nif (nr_neigh == NULL) {\r\nif ((nr_neigh = kmalloc(sizeof(*nr_neigh), GFP_ATOMIC)) == NULL) {\r\nif (nr_node)\r\nnr_node_put(nr_node);\r\nreturn -ENOMEM;\r\n}\r\nnr_neigh->callsign = *ax25;\r\nnr_neigh->digipeat = NULL;\r\nnr_neigh->ax25 = NULL;\r\nnr_neigh->dev = dev;\r\nnr_neigh->quality = sysctl_netrom_default_path_quality;\r\nnr_neigh->locked = 0;\r\nnr_neigh->count = 0;\r\nnr_neigh->number = nr_neigh_no++;\r\nnr_neigh->failed = 0;\r\natomic_set(&nr_neigh->refcount, 1);\r\nif (ax25_digi != NULL && ax25_digi->ndigi > 0) {\r\nnr_neigh->digipeat = kmemdup(ax25_digi,\r\nsizeof(*ax25_digi),\r\nGFP_KERNEL);\r\nif (nr_neigh->digipeat == NULL) {\r\nkfree(nr_neigh);\r\nif (nr_node)\r\nnr_node_put(nr_node);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nspin_lock_bh(&nr_neigh_list_lock);\r\nhlist_add_head(&nr_neigh->neigh_node, &nr_neigh_list);\r\nnr_neigh_hold(nr_neigh);\r\nspin_unlock_bh(&nr_neigh_list_lock);\r\n}\r\nif (quality != 0 && ax25cmp(nr, ax25) == 0 && !nr_neigh->locked)\r\nnr_neigh->quality = quality;\r\nif (nr_node == NULL) {\r\nif ((nr_node = kmalloc(sizeof(*nr_node), GFP_ATOMIC)) == NULL) {\r\nif (nr_neigh)\r\nnr_neigh_put(nr_neigh);\r\nreturn -ENOMEM;\r\n}\r\nnr_node->callsign = *nr;\r\nstrcpy(nr_node->mnemonic, mnemonic);\r\nnr_node->which = 0;\r\nnr_node->count = 1;\r\natomic_set(&nr_node->refcount, 1);\r\nspin_lock_init(&nr_node->node_lock);\r\nnr_node->routes[0].quality = quality;\r\nnr_node->routes[0].obs_count = obs_count;\r\nnr_node->routes[0].neighbour = nr_neigh;\r\nnr_neigh_hold(nr_neigh);\r\nnr_neigh->count++;\r\nspin_lock_bh(&nr_node_list_lock);\r\nhlist_add_head(&nr_node->node_node, &nr_node_list);\r\nspin_unlock_bh(&nr_node_list_lock);\r\nreturn 0;\r\n}\r\nnr_node_lock(nr_node);\r\nif (quality != 0)\r\nstrcpy(nr_node->mnemonic, mnemonic);\r\nfor (found = 0, i = 0; i < nr_node->count; i++) {\r\nif (nr_node->routes[i].neighbour == nr_neigh) {\r\nnr_node->routes[i].quality = quality;\r\nnr_node->routes[i].obs_count = obs_count;\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nif (nr_node->count < 3) {\r\nnr_node->routes[2] = nr_node->routes[1];\r\nnr_node->routes[1] = nr_node->routes[0];\r\nnr_node->routes[0].quality = quality;\r\nnr_node->routes[0].obs_count = obs_count;\r\nnr_node->routes[0].neighbour = nr_neigh;\r\nnr_node->which++;\r\nnr_node->count++;\r\nnr_neigh_hold(nr_neigh);\r\nnr_neigh->count++;\r\n} else {\r\nif (quality > nr_node->routes[2].quality) {\r\nnr_node->routes[2].neighbour->count--;\r\nnr_neigh_put(nr_node->routes[2].neighbour);\r\nif (nr_node->routes[2].neighbour->count == 0 && !nr_node->routes[2].neighbour->locked)\r\nnr_remove_neigh(nr_node->routes[2].neighbour);\r\nnr_node->routes[2].quality = quality;\r\nnr_node->routes[2].obs_count = obs_count;\r\nnr_node->routes[2].neighbour = nr_neigh;\r\nnr_neigh_hold(nr_neigh);\r\nnr_neigh->count++;\r\n}\r\n}\r\n}\r\nswitch (nr_node->count) {\r\ncase 3:\r\nif (nr_node->routes[1].quality > nr_node->routes[0].quality) {\r\nswitch (nr_node->which) {\r\ncase 0:\r\nnr_node->which = 1;\r\nbreak;\r\ncase 1:\r\nnr_node->which = 0;\r\nbreak;\r\n}\r\nnr_route = nr_node->routes[0];\r\nnr_node->routes[0] = nr_node->routes[1];\r\nnr_node->routes[1] = nr_route;\r\n}\r\nif (nr_node->routes[2].quality > nr_node->routes[1].quality) {\r\nswitch (nr_node->which) {\r\ncase 1: nr_node->which = 2;\r\nbreak;\r\ncase 2: nr_node->which = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nnr_route = nr_node->routes[1];\r\nnr_node->routes[1] = nr_node->routes[2];\r\nnr_node->routes[2] = nr_route;\r\n}\r\ncase 2:\r\nif (nr_node->routes[1].quality > nr_node->routes[0].quality) {\r\nswitch (nr_node->which) {\r\ncase 0: nr_node->which = 1;\r\nbreak;\r\ncase 1: nr_node->which = 0;\r\nbreak;\r\ndefault: break;\r\n}\r\nnr_route = nr_node->routes[0];\r\nnr_node->routes[0] = nr_node->routes[1];\r\nnr_node->routes[1] = nr_route;\r\n}\r\ncase 1:\r\nbreak;\r\n}\r\nfor (i = 0; i < nr_node->count; i++) {\r\nif (nr_node->routes[i].neighbour == nr_neigh) {\r\nif (i < nr_node->which)\r\nnr_node->which = i;\r\nbreak;\r\n}\r\n}\r\nnr_neigh_put(nr_neigh);\r\nnr_node_unlock(nr_node);\r\nnr_node_put(nr_node);\r\nreturn 0;\r\n}\r\nstatic inline void __nr_remove_node(struct nr_node *nr_node)\r\n{\r\nhlist_del_init(&nr_node->node_node);\r\nnr_node_put(nr_node);\r\n}\r\nstatic void nr_remove_node(struct nr_node *nr_node)\r\n{\r\nspin_lock_bh(&nr_node_list_lock);\r\n__nr_remove_node(nr_node);\r\nspin_unlock_bh(&nr_node_list_lock);\r\n}\r\nstatic inline void __nr_remove_neigh(struct nr_neigh *nr_neigh)\r\n{\r\nhlist_del_init(&nr_neigh->neigh_node);\r\nnr_neigh_put(nr_neigh);\r\n}\r\nstatic void nr_remove_neigh(struct nr_neigh *nr_neigh)\r\n{\r\nspin_lock_bh(&nr_neigh_list_lock);\r\n__nr_remove_neigh(nr_neigh);\r\nspin_unlock_bh(&nr_neigh_list_lock);\r\n}\r\nstatic int nr_del_node(ax25_address *callsign, ax25_address *neighbour, struct net_device *dev)\r\n{\r\nstruct nr_node *nr_node;\r\nstruct nr_neigh *nr_neigh;\r\nint i;\r\nnr_node = nr_node_get(callsign);\r\nif (nr_node == NULL)\r\nreturn -EINVAL;\r\nnr_neigh = nr_neigh_get_dev(neighbour, dev);\r\nif (nr_neigh == NULL) {\r\nnr_node_put(nr_node);\r\nreturn -EINVAL;\r\n}\r\nnr_node_lock(nr_node);\r\nfor (i = 0; i < nr_node->count; i++) {\r\nif (nr_node->routes[i].neighbour == nr_neigh) {\r\nnr_neigh->count--;\r\nnr_neigh_put(nr_neigh);\r\nif (nr_neigh->count == 0 && !nr_neigh->locked)\r\nnr_remove_neigh(nr_neigh);\r\nnr_neigh_put(nr_neigh);\r\nnr_node->count--;\r\nif (nr_node->count == 0) {\r\nnr_remove_node(nr_node);\r\n} else {\r\nswitch (i) {\r\ncase 0:\r\nnr_node->routes[0] = nr_node->routes[1];\r\ncase 1:\r\nnr_node->routes[1] = nr_node->routes[2];\r\ncase 2:\r\nbreak;\r\n}\r\nnr_node_put(nr_node);\r\n}\r\nnr_node_unlock(nr_node);\r\nreturn 0;\r\n}\r\n}\r\nnr_neigh_put(nr_neigh);\r\nnr_node_unlock(nr_node);\r\nnr_node_put(nr_node);\r\nreturn -EINVAL;\r\n}\r\nstatic int __must_check nr_add_neigh(ax25_address *callsign,\r\nax25_digi *ax25_digi, struct net_device *dev, unsigned int quality)\r\n{\r\nstruct nr_neigh *nr_neigh;\r\nnr_neigh = nr_neigh_get_dev(callsign, dev);\r\nif (nr_neigh) {\r\nnr_neigh->quality = quality;\r\nnr_neigh->locked = 1;\r\nnr_neigh_put(nr_neigh);\r\nreturn 0;\r\n}\r\nif ((nr_neigh = kmalloc(sizeof(*nr_neigh), GFP_ATOMIC)) == NULL)\r\nreturn -ENOMEM;\r\nnr_neigh->callsign = *callsign;\r\nnr_neigh->digipeat = NULL;\r\nnr_neigh->ax25 = NULL;\r\nnr_neigh->dev = dev;\r\nnr_neigh->quality = quality;\r\nnr_neigh->locked = 1;\r\nnr_neigh->count = 0;\r\nnr_neigh->number = nr_neigh_no++;\r\nnr_neigh->failed = 0;\r\natomic_set(&nr_neigh->refcount, 1);\r\nif (ax25_digi != NULL && ax25_digi->ndigi > 0) {\r\nnr_neigh->digipeat = kmemdup(ax25_digi, sizeof(*ax25_digi),\r\nGFP_KERNEL);\r\nif (nr_neigh->digipeat == NULL) {\r\nkfree(nr_neigh);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nspin_lock_bh(&nr_neigh_list_lock);\r\nhlist_add_head(&nr_neigh->neigh_node, &nr_neigh_list);\r\nspin_unlock_bh(&nr_neigh_list_lock);\r\nreturn 0;\r\n}\r\nstatic int nr_del_neigh(ax25_address *callsign, struct net_device *dev, unsigned int quality)\r\n{\r\nstruct nr_neigh *nr_neigh;\r\nnr_neigh = nr_neigh_get_dev(callsign, dev);\r\nif (nr_neigh == NULL) return -EINVAL;\r\nnr_neigh->quality = quality;\r\nnr_neigh->locked = 0;\r\nif (nr_neigh->count == 0)\r\nnr_remove_neigh(nr_neigh);\r\nnr_neigh_put(nr_neigh);\r\nreturn 0;\r\n}\r\nstatic int nr_dec_obs(void)\r\n{\r\nstruct nr_neigh *nr_neigh;\r\nstruct nr_node *s;\r\nstruct hlist_node *node, *nodet;\r\nint i;\r\nspin_lock_bh(&nr_node_list_lock);\r\nnr_node_for_each_safe(s, node, nodet, &nr_node_list) {\r\nnr_node_lock(s);\r\nfor (i = 0; i < s->count; i++) {\r\nswitch (s->routes[i].obs_count) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nnr_neigh = s->routes[i].neighbour;\r\nnr_neigh->count--;\r\nnr_neigh_put(nr_neigh);\r\nif (nr_neigh->count == 0 && !nr_neigh->locked)\r\nnr_remove_neigh(nr_neigh);\r\ns->count--;\r\nswitch (i) {\r\ncase 0:\r\ns->routes[0] = s->routes[1];\r\ncase 1:\r\ns->routes[1] = s->routes[2];\r\ncase 2:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ns->routes[i].obs_count--;\r\nbreak;\r\n}\r\n}\r\nif (s->count <= 0)\r\nnr_remove_node_locked(s);\r\nnr_node_unlock(s);\r\n}\r\nspin_unlock_bh(&nr_node_list_lock);\r\nreturn 0;\r\n}\r\nvoid nr_rt_device_down(struct net_device *dev)\r\n{\r\nstruct nr_neigh *s;\r\nstruct hlist_node *node, *nodet, *node2, *node2t;\r\nstruct nr_node *t;\r\nint i;\r\nspin_lock_bh(&nr_neigh_list_lock);\r\nnr_neigh_for_each_safe(s, node, nodet, &nr_neigh_list) {\r\nif (s->dev == dev) {\r\nspin_lock_bh(&nr_node_list_lock);\r\nnr_node_for_each_safe(t, node2, node2t, &nr_node_list) {\r\nnr_node_lock(t);\r\nfor (i = 0; i < t->count; i++) {\r\nif (t->routes[i].neighbour == s) {\r\nt->count--;\r\nswitch (i) {\r\ncase 0:\r\nt->routes[0] = t->routes[1];\r\ncase 1:\r\nt->routes[1] = t->routes[2];\r\ncase 2:\r\nbreak;\r\n}\r\n}\r\n}\r\nif (t->count <= 0)\r\nnr_remove_node_locked(t);\r\nnr_node_unlock(t);\r\n}\r\nspin_unlock_bh(&nr_node_list_lock);\r\nnr_remove_neigh_locked(s);\r\n}\r\n}\r\nspin_unlock_bh(&nr_neigh_list_lock);\r\n}\r\nstatic struct net_device *nr_ax25_dev_get(char *devname)\r\n{\r\nstruct net_device *dev;\r\nif ((dev = dev_get_by_name(&init_net, devname)) == NULL)\r\nreturn NULL;\r\nif ((dev->flags & IFF_UP) && dev->type == ARPHRD_AX25)\r\nreturn dev;\r\ndev_put(dev);\r\nreturn NULL;\r\n}\r\nstruct net_device *nr_dev_first(void)\r\n{\r\nstruct net_device *dev, *first = NULL;\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(&init_net, dev) {\r\nif ((dev->flags & IFF_UP) && dev->type == ARPHRD_NETROM)\r\nif (first == NULL || strncmp(dev->name, first->name, 3) < 0)\r\nfirst = dev;\r\n}\r\nif (first)\r\ndev_hold(first);\r\nrcu_read_unlock();\r\nreturn first;\r\n}\r\nstruct net_device *nr_dev_get(ax25_address *addr)\r\n{\r\nstruct net_device *dev;\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(&init_net, dev) {\r\nif ((dev->flags & IFF_UP) && dev->type == ARPHRD_NETROM &&\r\nax25cmp(addr, (ax25_address *)dev->dev_addr) == 0) {\r\ndev_hold(dev);\r\ngoto out;\r\n}\r\n}\r\ndev = NULL;\r\nout:\r\nrcu_read_unlock();\r\nreturn dev;\r\n}\r\nstatic ax25_digi *nr_call_to_digi(ax25_digi *digi, int ndigis,\r\nax25_address *digipeaters)\r\n{\r\nint i;\r\nif (ndigis == 0)\r\nreturn NULL;\r\nfor (i = 0; i < ndigis; i++) {\r\ndigi->calls[i] = digipeaters[i];\r\ndigi->repeated[i] = 0;\r\n}\r\ndigi->ndigi = ndigis;\r\ndigi->lastrepeat = -1;\r\nreturn digi;\r\n}\r\nint nr_rt_ioctl(unsigned int cmd, void __user *arg)\r\n{\r\nstruct nr_route_struct nr_route;\r\nstruct net_device *dev;\r\nax25_digi digi;\r\nint ret;\r\nswitch (cmd) {\r\ncase SIOCADDRT:\r\nif (copy_from_user(&nr_route, arg, sizeof(struct nr_route_struct)))\r\nreturn -EFAULT;\r\nif (nr_route.ndigis > AX25_MAX_DIGIS)\r\nreturn -EINVAL;\r\nif ((dev = nr_ax25_dev_get(nr_route.device)) == NULL)\r\nreturn -EINVAL;\r\nswitch (nr_route.type) {\r\ncase NETROM_NODE:\r\nif (strnlen(nr_route.mnemonic, 7) == 7) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = nr_add_node(&nr_route.callsign,\r\nnr_route.mnemonic,\r\n&nr_route.neighbour,\r\nnr_call_to_digi(&digi, nr_route.ndigis,\r\nnr_route.digipeaters),\r\ndev, nr_route.quality,\r\nnr_route.obs_count);\r\nbreak;\r\ncase NETROM_NEIGH:\r\nret = nr_add_neigh(&nr_route.callsign,\r\nnr_call_to_digi(&digi, nr_route.ndigis,\r\nnr_route.digipeaters),\r\ndev, nr_route.quality);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\ndev_put(dev);\r\nreturn ret;\r\ncase SIOCDELRT:\r\nif (copy_from_user(&nr_route, arg, sizeof(struct nr_route_struct)))\r\nreturn -EFAULT;\r\nif ((dev = nr_ax25_dev_get(nr_route.device)) == NULL)\r\nreturn -EINVAL;\r\nswitch (nr_route.type) {\r\ncase NETROM_NODE:\r\nret = nr_del_node(&nr_route.callsign,\r\n&nr_route.neighbour, dev);\r\nbreak;\r\ncase NETROM_NEIGH:\r\nret = nr_del_neigh(&nr_route.callsign,\r\ndev, nr_route.quality);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\ndev_put(dev);\r\nreturn ret;\r\ncase SIOCNRDECOBS:\r\nreturn nr_dec_obs();\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid nr_link_failed(ax25_cb *ax25, int reason)\r\n{\r\nstruct nr_neigh *s, *nr_neigh = NULL;\r\nstruct hlist_node *node;\r\nstruct nr_node *nr_node = NULL;\r\nspin_lock_bh(&nr_neigh_list_lock);\r\nnr_neigh_for_each(s, node, &nr_neigh_list) {\r\nif (s->ax25 == ax25) {\r\nnr_neigh_hold(s);\r\nnr_neigh = s;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&nr_neigh_list_lock);\r\nif (nr_neigh == NULL)\r\nreturn;\r\nnr_neigh->ax25 = NULL;\r\nax25_cb_put(ax25);\r\nif (++nr_neigh->failed < sysctl_netrom_link_fails_count) {\r\nnr_neigh_put(nr_neigh);\r\nreturn;\r\n}\r\nspin_lock_bh(&nr_node_list_lock);\r\nnr_node_for_each(nr_node, node, &nr_node_list) {\r\nnr_node_lock(nr_node);\r\nif (nr_node->which < nr_node->count &&\r\nnr_node->routes[nr_node->which].neighbour == nr_neigh)\r\nnr_node->which++;\r\nnr_node_unlock(nr_node);\r\n}\r\nspin_unlock_bh(&nr_node_list_lock);\r\nnr_neigh_put(nr_neigh);\r\n}\r\nint nr_route_frame(struct sk_buff *skb, ax25_cb *ax25)\r\n{\r\nax25_address *nr_src, *nr_dest;\r\nstruct nr_neigh *nr_neigh;\r\nstruct nr_node *nr_node;\r\nstruct net_device *dev;\r\nunsigned char *dptr;\r\nax25_cb *ax25s;\r\nint ret;\r\nstruct sk_buff *skbn;\r\nnr_src = (ax25_address *)(skb->data + 0);\r\nnr_dest = (ax25_address *)(skb->data + 7);\r\nif (ax25 != NULL) {\r\nret = nr_add_node(nr_src, "", &ax25->dest_addr, ax25->digipeat,\r\nax25->ax25_dev->dev, 0,\r\nsysctl_netrom_obsolescence_count_initialiser);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif ((dev = nr_dev_get(nr_dest)) != NULL) {\r\nif (ax25 == NULL)\r\nret = nr_loopback_queue(skb);\r\nelse\r\nret = nr_rx_frame(skb, dev);\r\ndev_put(dev);\r\nreturn ret;\r\n}\r\nif (!sysctl_netrom_routing_control && ax25 != NULL)\r\nreturn 0;\r\nif (skb->data[14] == 1) {\r\nreturn 0;\r\n}\r\nnr_node = nr_node_get(nr_dest);\r\nif (nr_node == NULL)\r\nreturn 0;\r\nnr_node_lock(nr_node);\r\nif (nr_node->which >= nr_node->count) {\r\nnr_node_unlock(nr_node);\r\nnr_node_put(nr_node);\r\nreturn 0;\r\n}\r\nnr_neigh = nr_node->routes[nr_node->which].neighbour;\r\nif ((dev = nr_dev_first()) == NULL) {\r\nnr_node_unlock(nr_node);\r\nnr_node_put(nr_node);\r\nreturn 0;\r\n}\r\nif ((skbn=skb_copy_expand(skb, dev->hard_header_len, 0, GFP_ATOMIC)) == NULL) {\r\nnr_node_unlock(nr_node);\r\nnr_node_put(nr_node);\r\ndev_put(dev);\r\nreturn 0;\r\n}\r\nkfree_skb(skb);\r\nskb=skbn;\r\nskb->data[14]--;\r\ndptr = skb_push(skb, 1);\r\n*dptr = AX25_P_NETROM;\r\nax25s = nr_neigh->ax25;\r\nnr_neigh->ax25 = ax25_send_frame(skb, 256,\r\n(ax25_address *)dev->dev_addr,\r\n&nr_neigh->callsign,\r\nnr_neigh->digipeat, nr_neigh->dev);\r\nif (ax25s)\r\nax25_cb_put(ax25s);\r\ndev_put(dev);\r\nret = (nr_neigh->ax25 != NULL);\r\nnr_node_unlock(nr_node);\r\nnr_node_put(nr_node);\r\nreturn ret;\r\n}\r\nstatic void *nr_node_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nspin_lock_bh(&nr_node_list_lock);\r\nreturn seq_hlist_start_head(&nr_node_list, *pos);\r\n}\r\nstatic void *nr_node_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nreturn seq_hlist_next(v, &nr_node_list, pos);\r\n}\r\nstatic void nr_node_stop(struct seq_file *seq, void *v)\r\n{\r\nspin_unlock_bh(&nr_node_list_lock);\r\n}\r\nstatic int nr_node_show(struct seq_file *seq, void *v)\r\n{\r\nchar buf[11];\r\nint i;\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq,\r\n"callsign mnemonic w n qual obs neigh qual obs neigh qual obs neigh\n");\r\nelse {\r\nstruct nr_node *nr_node = hlist_entry(v, struct nr_node,\r\nnode_node);\r\nnr_node_lock(nr_node);\r\nseq_printf(seq, "%-9s %-7s %d %d",\r\nax2asc(buf, &nr_node->callsign),\r\n(nr_node->mnemonic[0] == '\0') ? "*" : nr_node->mnemonic,\r\nnr_node->which + 1,\r\nnr_node->count);\r\nfor (i = 0; i < nr_node->count; i++) {\r\nseq_printf(seq, " %3d %d %05d",\r\nnr_node->routes[i].quality,\r\nnr_node->routes[i].obs_count,\r\nnr_node->routes[i].neighbour->number);\r\n}\r\nnr_node_unlock(nr_node);\r\nseq_puts(seq, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int nr_node_info_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &nr_node_seqops);\r\n}\r\nstatic void *nr_neigh_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nspin_lock_bh(&nr_neigh_list_lock);\r\nreturn seq_hlist_start_head(&nr_neigh_list, *pos);\r\n}\r\nstatic void *nr_neigh_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nreturn seq_hlist_next(v, &nr_neigh_list, pos);\r\n}\r\nstatic void nr_neigh_stop(struct seq_file *seq, void *v)\r\n{\r\nspin_unlock_bh(&nr_neigh_list_lock);\r\n}\r\nstatic int nr_neigh_show(struct seq_file *seq, void *v)\r\n{\r\nchar buf[11];\r\nint i;\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq, "addr callsign dev qual lock count failed digipeaters\n");\r\nelse {\r\nstruct nr_neigh *nr_neigh;\r\nnr_neigh = hlist_entry(v, struct nr_neigh, neigh_node);\r\nseq_printf(seq, "%05d %-9s %-4s %3d %d %3d %3d",\r\nnr_neigh->number,\r\nax2asc(buf, &nr_neigh->callsign),\r\nnr_neigh->dev ? nr_neigh->dev->name : "???",\r\nnr_neigh->quality,\r\nnr_neigh->locked,\r\nnr_neigh->count,\r\nnr_neigh->failed);\r\nif (nr_neigh->digipeat != NULL) {\r\nfor (i = 0; i < nr_neigh->digipeat->ndigi; i++)\r\nseq_printf(seq, " %s",\r\nax2asc(buf, &nr_neigh->digipeat->calls[i]));\r\n}\r\nseq_puts(seq, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int nr_neigh_info_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &nr_neigh_seqops);\r\n}\r\nvoid __exit nr_rt_free(void)\r\n{\r\nstruct nr_neigh *s = NULL;\r\nstruct nr_node *t = NULL;\r\nstruct hlist_node *node, *nodet;\r\nspin_lock_bh(&nr_neigh_list_lock);\r\nspin_lock_bh(&nr_node_list_lock);\r\nnr_node_for_each_safe(t, node, nodet, &nr_node_list) {\r\nnr_node_lock(t);\r\nnr_remove_node_locked(t);\r\nnr_node_unlock(t);\r\n}\r\nnr_neigh_for_each_safe(s, node, nodet, &nr_neigh_list) {\r\nwhile(s->count) {\r\ns->count--;\r\nnr_neigh_put(s);\r\n}\r\nnr_remove_neigh_locked(s);\r\n}\r\nspin_unlock_bh(&nr_node_list_lock);\r\nspin_unlock_bh(&nr_neigh_list_lock);\r\n}
