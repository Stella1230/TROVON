static int __isl29003_read_reg(struct i2c_client *client,\r\nu32 reg, u8 mask, u8 shift)\r\n{\r\nstruct isl29003_data *data = i2c_get_clientdata(client);\r\nreturn (data->reg_cache[reg] & mask) >> shift;\r\n}\r\nstatic int __isl29003_write_reg(struct i2c_client *client,\r\nu32 reg, u8 mask, u8 shift, u8 val)\r\n{\r\nstruct isl29003_data *data = i2c_get_clientdata(client);\r\nint ret = 0;\r\nu8 tmp;\r\nif (reg >= ISL29003_NUM_CACHABLE_REGS)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\ntmp = data->reg_cache[reg];\r\ntmp &= ~mask;\r\ntmp |= val << shift;\r\nret = i2c_smbus_write_byte_data(client, reg, tmp);\r\nif (!ret)\r\ndata->reg_cache[reg] = tmp;\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int isl29003_get_range(struct i2c_client *client)\r\n{\r\nreturn __isl29003_read_reg(client, ISL29003_REG_CONTROL,\r\nISL29003_RANGE_MASK, ISL29003_RANGE_SHIFT);\r\n}\r\nstatic int isl29003_set_range(struct i2c_client *client, int range)\r\n{\r\nreturn __isl29003_write_reg(client, ISL29003_REG_CONTROL,\r\nISL29003_RANGE_MASK, ISL29003_RANGE_SHIFT, range);\r\n}\r\nstatic int isl29003_get_resolution(struct i2c_client *client)\r\n{\r\nreturn __isl29003_read_reg(client, ISL29003_REG_COMMAND,\r\nISL29003_RES_MASK, ISL29003_RES_SHIFT);\r\n}\r\nstatic int isl29003_set_resolution(struct i2c_client *client, int res)\r\n{\r\nreturn __isl29003_write_reg(client, ISL29003_REG_COMMAND,\r\nISL29003_RES_MASK, ISL29003_RES_SHIFT, res);\r\n}\r\nstatic int isl29003_get_mode(struct i2c_client *client)\r\n{\r\nreturn __isl29003_read_reg(client, ISL29003_REG_COMMAND,\r\nISL29003_RES_MASK, ISL29003_RES_SHIFT);\r\n}\r\nstatic int isl29003_set_mode(struct i2c_client *client, int mode)\r\n{\r\nreturn __isl29003_write_reg(client, ISL29003_REG_COMMAND,\r\nISL29003_RES_MASK, ISL29003_RES_SHIFT, mode);\r\n}\r\nstatic int isl29003_set_power_state(struct i2c_client *client, int state)\r\n{\r\nreturn __isl29003_write_reg(client, ISL29003_REG_COMMAND,\r\nISL29003_ADC_ENABLED | ISL29003_ADC_PD, 0,\r\nstate ? ISL29003_ADC_ENABLED : ISL29003_ADC_PD);\r\n}\r\nstatic int isl29003_get_power_state(struct i2c_client *client)\r\n{\r\nstruct isl29003_data *data = i2c_get_clientdata(client);\r\nu8 cmdreg = data->reg_cache[ISL29003_REG_COMMAND];\r\nreturn ~cmdreg & ISL29003_ADC_PD;\r\n}\r\nstatic int isl29003_get_adc_value(struct i2c_client *client)\r\n{\r\nstruct isl29003_data *data = i2c_get_clientdata(client);\r\nint lsb, msb, range, bitdepth;\r\nmutex_lock(&data->lock);\r\nlsb = i2c_smbus_read_byte_data(client, ISL29003_REG_LSB_SENSOR);\r\nif (lsb < 0) {\r\nmutex_unlock(&data->lock);\r\nreturn lsb;\r\n}\r\nmsb = i2c_smbus_read_byte_data(client, ISL29003_REG_MSB_SENSOR);\r\nmutex_unlock(&data->lock);\r\nif (msb < 0)\r\nreturn msb;\r\nrange = isl29003_get_range(client);\r\nbitdepth = (4 - isl29003_get_resolution(client)) * 4;\r\nreturn (((msb << 8) | lsb) * gain_range[range]) >> bitdepth;\r\n}\r\nstatic ssize_t isl29003_show_range(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nreturn sprintf(buf, "%i\n", isl29003_get_range(client));\r\n}\r\nstatic ssize_t isl29003_store_range(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nunsigned long val;\r\nint ret;\r\nif ((strict_strtoul(buf, 10, &val) < 0) || (val > 3))\r\nreturn -EINVAL;\r\nret = isl29003_set_range(client, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t isl29003_show_resolution(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nreturn sprintf(buf, "%d\n", isl29003_get_resolution(client));\r\n}\r\nstatic ssize_t isl29003_store_resolution(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nunsigned long val;\r\nint ret;\r\nif ((strict_strtoul(buf, 10, &val) < 0) || (val > 3))\r\nreturn -EINVAL;\r\nret = isl29003_set_resolution(client, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t isl29003_show_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nreturn sprintf(buf, "%d\n", isl29003_get_mode(client));\r\n}\r\nstatic ssize_t isl29003_store_mode(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nunsigned long val;\r\nint ret;\r\nif ((strict_strtoul(buf, 10, &val) < 0) || (val > 2))\r\nreturn -EINVAL;\r\nret = isl29003_set_mode(client, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t isl29003_show_power_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nreturn sprintf(buf, "%d\n", isl29003_get_power_state(client));\r\n}\r\nstatic ssize_t isl29003_store_power_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nunsigned long val;\r\nint ret;\r\nif ((strict_strtoul(buf, 10, &val) < 0) || (val > 1))\r\nreturn -EINVAL;\r\nret = isl29003_set_power_state(client, val);\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t isl29003_show_lux(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (!isl29003_get_power_state(client))\r\nreturn -EBUSY;\r\nreturn sprintf(buf, "%d\n", isl29003_get_adc_value(client));\r\n}\r\nstatic int isl29003_init_client(struct i2c_client *client)\r\n{\r\nstruct isl29003_data *data = i2c_get_clientdata(client);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(data->reg_cache); i++) {\r\nint v = i2c_smbus_read_byte_data(client, i);\r\nif (v < 0)\r\nreturn -ENODEV;\r\ndata->reg_cache[i] = v;\r\n}\r\nisl29003_set_range(client, 0);\r\nisl29003_set_resolution(client, 0);\r\nisl29003_set_mode(client, 0);\r\nisl29003_set_power_state(client, 0);\r\nreturn 0;\r\n}\r\nstatic int __devinit isl29003_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct isl29003_data *data;\r\nint err = 0;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))\r\nreturn -EIO;\r\ndata = kzalloc(sizeof(struct isl29003_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->client = client;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->lock);\r\nerr = isl29003_init_client(client);\r\nif (err)\r\ngoto exit_kfree;\r\nerr = sysfs_create_group(&client->dev.kobj, &isl29003_attr_group);\r\nif (err)\r\ngoto exit_kfree;\r\ndev_info(&client->dev, "driver version %s enabled\n", DRIVER_VERSION);\r\nreturn 0;\r\nexit_kfree:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int __devexit isl29003_remove(struct i2c_client *client)\r\n{\r\nsysfs_remove_group(&client->dev.kobj, &isl29003_attr_group);\r\nisl29003_set_power_state(client, 0);\r\nkfree(i2c_get_clientdata(client));\r\nreturn 0;\r\n}\r\nstatic int isl29003_suspend(struct i2c_client *client, pm_message_t mesg)\r\n{\r\nstruct isl29003_data *data = i2c_get_clientdata(client);\r\ndata->power_state_before_suspend = isl29003_get_power_state(client);\r\nreturn isl29003_set_power_state(client, 0);\r\n}\r\nstatic int isl29003_resume(struct i2c_client *client)\r\n{\r\nint i;\r\nstruct isl29003_data *data = i2c_get_clientdata(client);\r\nfor (i = 0; i < ARRAY_SIZE(data->reg_cache); i++)\r\nif (i2c_smbus_write_byte_data(client, i, data->reg_cache[i]))\r\nreturn -EIO;\r\nreturn isl29003_set_power_state(client,\r\ndata->power_state_before_suspend);\r\n}
