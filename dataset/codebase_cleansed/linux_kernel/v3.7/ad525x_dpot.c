static inline int dpot_read_d8(struct dpot_data *dpot)\r\n{\r\nreturn dpot->bdata.bops->read_d8(dpot->bdata.client);\r\n}\r\nstatic inline int dpot_read_r8d8(struct dpot_data *dpot, u8 reg)\r\n{\r\nreturn dpot->bdata.bops->read_r8d8(dpot->bdata.client, reg);\r\n}\r\nstatic inline int dpot_read_r8d16(struct dpot_data *dpot, u8 reg)\r\n{\r\nreturn dpot->bdata.bops->read_r8d16(dpot->bdata.client, reg);\r\n}\r\nstatic inline int dpot_write_d8(struct dpot_data *dpot, u8 val)\r\n{\r\nreturn dpot->bdata.bops->write_d8(dpot->bdata.client, val);\r\n}\r\nstatic inline int dpot_write_r8d8(struct dpot_data *dpot, u8 reg, u16 val)\r\n{\r\nreturn dpot->bdata.bops->write_r8d8(dpot->bdata.client, reg, val);\r\n}\r\nstatic inline int dpot_write_r8d16(struct dpot_data *dpot, u8 reg, u16 val)\r\n{\r\nreturn dpot->bdata.bops->write_r8d16(dpot->bdata.client, reg, val);\r\n}\r\nstatic s32 dpot_read_spi(struct dpot_data *dpot, u8 reg)\r\n{\r\nunsigned ctrl = 0;\r\nint value;\r\nif (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD))) {\r\nif (dpot->feat & F_RDACS_WONLY)\r\nreturn dpot->rdac_cache[reg & DPOT_RDAC_MASK];\r\nif (dpot->uid == DPOT_UID(AD5291_ID) ||\r\ndpot->uid == DPOT_UID(AD5292_ID) ||\r\ndpot->uid == DPOT_UID(AD5293_ID)) {\r\nvalue = dpot_read_r8d8(dpot,\r\nDPOT_AD5291_READ_RDAC << 2);\r\nif (dpot->uid == DPOT_UID(AD5291_ID))\r\nvalue = value >> 2;\r\nreturn value;\r\n} else if (dpot->uid == DPOT_UID(AD5270_ID) ||\r\ndpot->uid == DPOT_UID(AD5271_ID)) {\r\nvalue = dpot_read_r8d8(dpot,\r\nDPOT_AD5270_1_2_4_READ_RDAC << 2);\r\nif (value < 0)\r\nreturn value;\r\nif (dpot->uid == DPOT_UID(AD5271_ID))\r\nvalue = value >> 2;\r\nreturn value;\r\n}\r\nctrl = DPOT_SPI_READ_RDAC;\r\n} else if (reg & DPOT_ADDR_EEPROM) {\r\nctrl = DPOT_SPI_READ_EEPROM;\r\n}\r\nif (dpot->feat & F_SPI_16BIT)\r\nreturn dpot_read_r8d8(dpot, ctrl);\r\nelse if (dpot->feat & F_SPI_24BIT)\r\nreturn dpot_read_r8d16(dpot, ctrl);\r\nreturn -EFAULT;\r\n}\r\nstatic s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)\r\n{\r\nint value;\r\nunsigned ctrl = 0;\r\nswitch (dpot->uid) {\r\ncase DPOT_UID(AD5246_ID):\r\ncase DPOT_UID(AD5247_ID):\r\nreturn dpot_read_d8(dpot);\r\ncase DPOT_UID(AD5245_ID):\r\ncase DPOT_UID(AD5241_ID):\r\ncase DPOT_UID(AD5242_ID):\r\ncase DPOT_UID(AD5243_ID):\r\ncase DPOT_UID(AD5248_ID):\r\ncase DPOT_UID(AD5280_ID):\r\ncase DPOT_UID(AD5282_ID):\r\nctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?\r\n0 : DPOT_AD5282_RDAC_AB;\r\nreturn dpot_read_r8d8(dpot, ctrl);\r\ncase DPOT_UID(AD5170_ID):\r\ncase DPOT_UID(AD5171_ID):\r\ncase DPOT_UID(AD5273_ID):\r\nreturn dpot_read_d8(dpot);\r\ncase DPOT_UID(AD5172_ID):\r\ncase DPOT_UID(AD5173_ID):\r\nctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?\r\n0 : DPOT_AD5172_3_A0;\r\nreturn dpot_read_r8d8(dpot, ctrl);\r\ncase DPOT_UID(AD5272_ID):\r\ncase DPOT_UID(AD5274_ID):\r\ndpot_write_r8d8(dpot,\r\n(DPOT_AD5270_1_2_4_READ_RDAC << 2), 0);\r\nvalue = dpot_read_r8d16(dpot,\r\nDPOT_AD5270_1_2_4_RDAC << 2);\r\nif (value < 0)\r\nreturn value;\r\nvalue = swab16(value);\r\nif (dpot->uid == DPOT_UID(AD5271_ID))\r\nvalue = value >> 2;\r\nreturn value;\r\ndefault:\r\nif ((reg & DPOT_REG_TOL) || (dpot->max_pos > 256))\r\nreturn dpot_read_r8d16(dpot, (reg & 0xF8) |\r\n((reg & 0x7) << 1));\r\nelse\r\nreturn dpot_read_r8d8(dpot, reg);\r\n}\r\n}\r\nstatic s32 dpot_read(struct dpot_data *dpot, u8 reg)\r\n{\r\nif (dpot->feat & F_SPI)\r\nreturn dpot_read_spi(dpot, reg);\r\nelse\r\nreturn dpot_read_i2c(dpot, reg);\r\n}\r\nstatic s32 dpot_write_spi(struct dpot_data *dpot, u8 reg, u16 value)\r\n{\r\nunsigned val = 0;\r\nif (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD | DPOT_ADDR_OTP))) {\r\nif (dpot->feat & F_RDACS_WONLY)\r\ndpot->rdac_cache[reg & DPOT_RDAC_MASK] = value;\r\nif (dpot->feat & F_AD_APPDATA) {\r\nif (dpot->feat & F_SPI_8BIT) {\r\nval = ((reg & DPOT_RDAC_MASK) <<\r\nDPOT_MAX_POS(dpot->devid)) |\r\nvalue;\r\nreturn dpot_write_d8(dpot, val);\r\n} else if (dpot->feat & F_SPI_16BIT) {\r\nval = ((reg & DPOT_RDAC_MASK) <<\r\nDPOT_MAX_POS(dpot->devid)) |\r\nvalue;\r\nreturn dpot_write_r8d8(dpot, val >> 8,\r\nval & 0xFF);\r\n} else\r\nBUG();\r\n} else {\r\nif (dpot->uid == DPOT_UID(AD5291_ID) ||\r\ndpot->uid == DPOT_UID(AD5292_ID) ||\r\ndpot->uid == DPOT_UID(AD5293_ID)) {\r\ndpot_write_r8d8(dpot, DPOT_AD5291_CTRLREG << 2,\r\nDPOT_AD5291_UNLOCK_CMD);\r\nif (dpot->uid == DPOT_UID(AD5291_ID))\r\nvalue = value << 2;\r\nreturn dpot_write_r8d8(dpot,\r\n(DPOT_AD5291_RDAC << 2) |\r\n(value >> 8), value & 0xFF);\r\n} else if (dpot->uid == DPOT_UID(AD5270_ID) ||\r\ndpot->uid == DPOT_UID(AD5271_ID)) {\r\ndpot_write_r8d8(dpot,\r\nDPOT_AD5270_1_2_4_CTRLREG << 2,\r\nDPOT_AD5270_1_2_4_UNLOCK_CMD);\r\nif (dpot->uid == DPOT_UID(AD5271_ID))\r\nvalue = value << 2;\r\nreturn dpot_write_r8d8(dpot,\r\n(DPOT_AD5270_1_2_4_RDAC << 2) |\r\n(value >> 8), value & 0xFF);\r\n}\r\nval = DPOT_SPI_RDAC | (reg & DPOT_RDAC_MASK);\r\n}\r\n} else if (reg & DPOT_ADDR_EEPROM) {\r\nval = DPOT_SPI_EEPROM | (reg & DPOT_RDAC_MASK);\r\n} else if (reg & DPOT_ADDR_CMD) {\r\nswitch (reg) {\r\ncase DPOT_DEC_ALL_6DB:\r\nval = DPOT_SPI_DEC_ALL_6DB;\r\nbreak;\r\ncase DPOT_INC_ALL_6DB:\r\nval = DPOT_SPI_INC_ALL_6DB;\r\nbreak;\r\ncase DPOT_DEC_ALL:\r\nval = DPOT_SPI_DEC_ALL;\r\nbreak;\r\ncase DPOT_INC_ALL:\r\nval = DPOT_SPI_INC_ALL;\r\nbreak;\r\n}\r\n} else if (reg & DPOT_ADDR_OTP) {\r\nif (dpot->uid == DPOT_UID(AD5291_ID) ||\r\ndpot->uid == DPOT_UID(AD5292_ID)) {\r\nreturn dpot_write_r8d8(dpot,\r\nDPOT_AD5291_STORE_XTPM << 2, 0);\r\n} else if (dpot->uid == DPOT_UID(AD5270_ID) ||\r\ndpot->uid == DPOT_UID(AD5271_ID)) {\r\nreturn dpot_write_r8d8(dpot,\r\nDPOT_AD5270_1_2_4_STORE_XTPM << 2, 0);\r\n}\r\n} else\r\nBUG();\r\nif (dpot->feat & F_SPI_16BIT)\r\nreturn dpot_write_r8d8(dpot, val, value);\r\nelse if (dpot->feat & F_SPI_24BIT)\r\nreturn dpot_write_r8d16(dpot, val, value);\r\nreturn -EFAULT;\r\n}\r\nstatic s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)\r\n{\r\nunsigned tmp = 0, ctrl = 0;\r\nswitch (dpot->uid) {\r\ncase DPOT_UID(AD5246_ID):\r\ncase DPOT_UID(AD5247_ID):\r\nreturn dpot_write_d8(dpot, value);\r\nbreak;\r\ncase DPOT_UID(AD5245_ID):\r\ncase DPOT_UID(AD5241_ID):\r\ncase DPOT_UID(AD5242_ID):\r\ncase DPOT_UID(AD5243_ID):\r\ncase DPOT_UID(AD5248_ID):\r\ncase DPOT_UID(AD5280_ID):\r\ncase DPOT_UID(AD5282_ID):\r\nctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?\r\n0 : DPOT_AD5282_RDAC_AB;\r\nreturn dpot_write_r8d8(dpot, ctrl, value);\r\nbreak;\r\ncase DPOT_UID(AD5171_ID):\r\ncase DPOT_UID(AD5273_ID):\r\nif (reg & DPOT_ADDR_OTP) {\r\ntmp = dpot_read_d8(dpot);\r\nif (tmp >> 6)\r\nreturn -EFAULT;\r\nctrl = DPOT_AD5273_FUSE;\r\n}\r\nreturn dpot_write_r8d8(dpot, ctrl, value);\r\nbreak;\r\ncase DPOT_UID(AD5172_ID):\r\ncase DPOT_UID(AD5173_ID):\r\nctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?\r\n0 : DPOT_AD5172_3_A0;\r\nif (reg & DPOT_ADDR_OTP) {\r\ntmp = dpot_read_r8d16(dpot, ctrl);\r\nif (tmp >> 14)\r\nreturn -EFAULT;\r\nctrl |= DPOT_AD5170_2_3_FUSE;\r\n}\r\nreturn dpot_write_r8d8(dpot, ctrl, value);\r\nbreak;\r\ncase DPOT_UID(AD5170_ID):\r\nif (reg & DPOT_ADDR_OTP) {\r\ntmp = dpot_read_r8d16(dpot, tmp);\r\nif (tmp >> 14)\r\nreturn -EFAULT;\r\nctrl = DPOT_AD5170_2_3_FUSE;\r\n}\r\nreturn dpot_write_r8d8(dpot, ctrl, value);\r\nbreak;\r\ncase DPOT_UID(AD5272_ID):\r\ncase DPOT_UID(AD5274_ID):\r\ndpot_write_r8d8(dpot, DPOT_AD5270_1_2_4_CTRLREG << 2,\r\nDPOT_AD5270_1_2_4_UNLOCK_CMD);\r\nif (reg & DPOT_ADDR_OTP)\r\nreturn dpot_write_r8d8(dpot,\r\nDPOT_AD5270_1_2_4_STORE_XTPM << 2, 0);\r\nif (dpot->uid == DPOT_UID(AD5274_ID))\r\nvalue = value << 2;\r\nreturn dpot_write_r8d8(dpot, (DPOT_AD5270_1_2_4_RDAC << 2) |\r\n(value >> 8), value & 0xFF);\r\nbreak;\r\ndefault:\r\nif (reg & DPOT_ADDR_CMD)\r\nreturn dpot_write_d8(dpot, reg);\r\nif (dpot->max_pos > 256)\r\nreturn dpot_write_r8d16(dpot, (reg & 0xF8) |\r\n((reg & 0x7) << 1), value);\r\nelse\r\nreturn dpot_write_r8d8(dpot, reg, value);\r\n}\r\n}\r\nstatic s32 dpot_write(struct dpot_data *dpot, u8 reg, u16 value)\r\n{\r\nif (dpot->feat & F_SPI)\r\nreturn dpot_write_spi(dpot, reg, value);\r\nelse\r\nreturn dpot_write_i2c(dpot, reg, value);\r\n}\r\nstatic ssize_t sysfs_show_reg(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf, u32 reg)\r\n{\r\nstruct dpot_data *data = dev_get_drvdata(dev);\r\ns32 value;\r\nif (reg & DPOT_ADDR_OTP_EN)\r\nreturn sprintf(buf, "%s\n",\r\ntest_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask) ?\r\n"enabled" : "disabled");\r\nmutex_lock(&data->update_lock);\r\nvalue = dpot_read(data, reg);\r\nmutex_unlock(&data->update_lock);\r\nif (value < 0)\r\nreturn -EINVAL;\r\nif (reg & DPOT_REG_TOL)\r\nreturn sprintf(buf, "0x%04x\n", value & 0xFFFF);\r\nelse\r\nreturn sprintf(buf, "%u\n", value & data->rdac_mask);\r\n}\r\nstatic ssize_t sysfs_set_reg(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count, u32 reg)\r\n{\r\nstruct dpot_data *data = dev_get_drvdata(dev);\r\nunsigned long value;\r\nint err;\r\nif (reg & DPOT_ADDR_OTP_EN) {\r\nif (!strncmp(buf, "enabled", sizeof("enabled")))\r\nset_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask);\r\nelse\r\nclear_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask);\r\nreturn count;\r\n}\r\nif ((reg & DPOT_ADDR_OTP) &&\r\n!test_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask))\r\nreturn -EPERM;\r\nerr = strict_strtoul(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nif (value > data->rdac_mask)\r\nvalue = data->rdac_mask;\r\nmutex_lock(&data->update_lock);\r\ndpot_write(data, reg, value);\r\nif (reg & DPOT_ADDR_EEPROM)\r\nmsleep(26);\r\nelse if (reg & DPOT_ADDR_OTP)\r\nmsleep(400);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t sysfs_do_cmd(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count, u32 reg)\r\n{\r\nstruct dpot_data *data = dev_get_drvdata(dev);\r\nmutex_lock(&data->update_lock);\r\ndpot_write(data, reg, 0);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\n__devinit int ad_dpot_add_files(struct device *dev,\r\nunsigned features, unsigned rdac)\r\n{\r\nint err = sysfs_create_file(&dev->kobj,\r\ndpot_attrib_wipers[rdac]);\r\nif (features & F_CMD_EEP)\r\nerr |= sysfs_create_file(&dev->kobj,\r\ndpot_attrib_eeprom[rdac]);\r\nif (features & F_CMD_TOL)\r\nerr |= sysfs_create_file(&dev->kobj,\r\ndpot_attrib_tolerance[rdac]);\r\nif (features & F_CMD_OTP) {\r\nerr |= sysfs_create_file(&dev->kobj,\r\ndpot_attrib_otp_en[rdac]);\r\nerr |= sysfs_create_file(&dev->kobj,\r\ndpot_attrib_otp[rdac]);\r\n}\r\nif (err)\r\ndev_err(dev, "failed to register sysfs hooks for RDAC%d\n",\r\nrdac);\r\nreturn err;\r\n}\r\ninline void ad_dpot_remove_files(struct device *dev,\r\nunsigned features, unsigned rdac)\r\n{\r\nsysfs_remove_file(&dev->kobj,\r\ndpot_attrib_wipers[rdac]);\r\nif (features & F_CMD_EEP)\r\nsysfs_remove_file(&dev->kobj,\r\ndpot_attrib_eeprom[rdac]);\r\nif (features & F_CMD_TOL)\r\nsysfs_remove_file(&dev->kobj,\r\ndpot_attrib_tolerance[rdac]);\r\nif (features & F_CMD_OTP) {\r\nsysfs_remove_file(&dev->kobj,\r\ndpot_attrib_otp_en[rdac]);\r\nsysfs_remove_file(&dev->kobj,\r\ndpot_attrib_otp[rdac]);\r\n}\r\n}\r\nint __devinit ad_dpot_probe(struct device *dev,\r\nstruct ad_dpot_bus_data *bdata, unsigned long devid,\r\nconst char *name)\r\n{\r\nstruct dpot_data *data;\r\nint i, err = 0;\r\ndata = kzalloc(sizeof(struct dpot_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ndev_set_drvdata(dev, data);\r\nmutex_init(&data->update_lock);\r\ndata->bdata = *bdata;\r\ndata->devid = devid;\r\ndata->max_pos = 1 << DPOT_MAX_POS(devid);\r\ndata->rdac_mask = data->max_pos - 1;\r\ndata->feat = DPOT_FEAT(devid);\r\ndata->uid = DPOT_UID(devid);\r\ndata->wipers = DPOT_WIPERS(devid);\r\nfor (i = DPOT_RDAC0; i < MAX_RDACS; i++)\r\nif (data->wipers & (1 << i)) {\r\nerr = ad_dpot_add_files(dev, data->feat, i);\r\nif (err)\r\ngoto exit_remove_files;\r\nif (data->feat & F_RDACS_WONLY)\r\ndata->rdac_cache[i] = data->max_pos / 2;\r\n}\r\nif (data->feat & F_CMD_INC)\r\nerr = sysfs_create_group(&dev->kobj, &ad525x_group_commands);\r\nif (err) {\r\ndev_err(dev, "failed to register sysfs hooks\n");\r\ngoto exit_free;\r\n}\r\ndev_info(dev, "%s %d-Position Digital Potentiometer registered\n",\r\nname, data->max_pos);\r\nreturn 0;\r\nexit_remove_files:\r\nfor (i = DPOT_RDAC0; i < MAX_RDACS; i++)\r\nif (data->wipers & (1 << i))\r\nad_dpot_remove_files(dev, data->feat, i);\r\nexit_free:\r\nkfree(data);\r\ndev_set_drvdata(dev, NULL);\r\nexit:\r\ndev_err(dev, "failed to create client for %s ID 0x%lX\n",\r\nname, devid);\r\nreturn err;\r\n}\r\nint ad_dpot_remove(struct device *dev)\r\n{\r\nstruct dpot_data *data = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = DPOT_RDAC0; i < MAX_RDACS; i++)\r\nif (data->wipers & (1 << i))\r\nad_dpot_remove_files(dev, data->feat, i);\r\nkfree(data);\r\nreturn 0;\r\n}
