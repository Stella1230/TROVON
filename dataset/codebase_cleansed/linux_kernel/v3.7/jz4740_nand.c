static inline struct jz_nand *mtd_to_jz_nand(struct mtd_info *mtd)\r\n{\r\nreturn container_of(mtd, struct jz_nand, mtd);\r\n}\r\nstatic void jz_nand_select_chip(struct mtd_info *mtd, int chipnr)\r\n{\r\nstruct jz_nand *nand = mtd_to_jz_nand(mtd);\r\nstruct nand_chip *chip = mtd->priv;\r\nuint32_t ctrl;\r\nint banknr;\r\nctrl = readl(nand->base + JZ_REG_NAND_CTRL);\r\nctrl &= ~JZ_NAND_CTRL_ASSERT_CHIP_MASK;\r\nif (chipnr == -1) {\r\nbanknr = -1;\r\n} else {\r\nbanknr = nand->banks[chipnr] - 1;\r\nchip->IO_ADDR_R = nand->bank_base[banknr];\r\nchip->IO_ADDR_W = nand->bank_base[banknr];\r\n}\r\nwritel(ctrl, nand->base + JZ_REG_NAND_CTRL);\r\nnand->selected_bank = banknr;\r\n}\r\nstatic void jz_nand_cmd_ctrl(struct mtd_info *mtd, int dat, unsigned int ctrl)\r\n{\r\nstruct jz_nand *nand = mtd_to_jz_nand(mtd);\r\nstruct nand_chip *chip = mtd->priv;\r\nuint32_t reg;\r\nvoid __iomem *bank_base = nand->bank_base[nand->selected_bank];\r\nBUG_ON(nand->selected_bank < 0);\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nBUG_ON((ctrl & NAND_ALE) && (ctrl & NAND_CLE));\r\nif (ctrl & NAND_ALE)\r\nbank_base += JZ_NAND_MEM_ADDR_OFFSET;\r\nelse if (ctrl & NAND_CLE)\r\nbank_base += JZ_NAND_MEM_CMD_OFFSET;\r\nchip->IO_ADDR_W = bank_base;\r\nreg = readl(nand->base + JZ_REG_NAND_CTRL);\r\nif (ctrl & NAND_NCE)\r\nreg |= JZ_NAND_CTRL_ASSERT_CHIP(nand->selected_bank);\r\nelse\r\nreg &= ~JZ_NAND_CTRL_ASSERT_CHIP(nand->selected_bank);\r\nwritel(reg, nand->base + JZ_REG_NAND_CTRL);\r\n}\r\nif (dat != NAND_CMD_NONE)\r\nwriteb(dat, chip->IO_ADDR_W);\r\n}\r\nstatic int jz_nand_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct jz_nand *nand = mtd_to_jz_nand(mtd);\r\nreturn gpio_get_value_cansleep(nand->pdata->busy_gpio);\r\n}\r\nstatic void jz_nand_hwctl(struct mtd_info *mtd, int mode)\r\n{\r\nstruct jz_nand *nand = mtd_to_jz_nand(mtd);\r\nuint32_t reg;\r\nwritel(0, nand->base + JZ_REG_NAND_IRQ_STAT);\r\nreg = readl(nand->base + JZ_REG_NAND_ECC_CTRL);\r\nreg |= JZ_NAND_ECC_CTRL_RESET;\r\nreg |= JZ_NAND_ECC_CTRL_ENABLE;\r\nreg |= JZ_NAND_ECC_CTRL_RS;\r\nswitch (mode) {\r\ncase NAND_ECC_READ:\r\nreg &= ~JZ_NAND_ECC_CTRL_ENCODING;\r\nnand->is_reading = true;\r\nbreak;\r\ncase NAND_ECC_WRITE:\r\nreg |= JZ_NAND_ECC_CTRL_ENCODING;\r\nnand->is_reading = false;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwritel(reg, nand->base + JZ_REG_NAND_ECC_CTRL);\r\n}\r\nstatic int jz_nand_calculate_ecc_rs(struct mtd_info *mtd, const uint8_t *dat,\r\nuint8_t *ecc_code)\r\n{\r\nstruct jz_nand *nand = mtd_to_jz_nand(mtd);\r\nuint32_t reg, status;\r\nint i;\r\nunsigned int timeout = 1000;\r\nstatic uint8_t empty_block_ecc[] = {0xcd, 0x9d, 0x90, 0x58, 0xf4,\r\n0x8b, 0xff, 0xb7, 0x6f};\r\nif (nand->is_reading)\r\nreturn 0;\r\ndo {\r\nstatus = readl(nand->base + JZ_REG_NAND_IRQ_STAT);\r\n} while (!(status & JZ_NAND_STATUS_ENC_FINISH) && --timeout);\r\nif (timeout == 0)\r\nreturn -1;\r\nreg = readl(nand->base + JZ_REG_NAND_ECC_CTRL);\r\nreg &= ~JZ_NAND_ECC_CTRL_ENABLE;\r\nwritel(reg, nand->base + JZ_REG_NAND_ECC_CTRL);\r\nfor (i = 0; i < 9; ++i)\r\necc_code[i] = readb(nand->base + JZ_REG_NAND_PAR0 + i);\r\nif (memcmp(ecc_code, empty_block_ecc, 9) == 0)\r\nmemset(ecc_code, 0xff, 9);\r\nreturn 0;\r\n}\r\nstatic void jz_nand_correct_data(uint8_t *dat, int index, int mask)\r\n{\r\nint offset = index & 0x7;\r\nuint16_t data;\r\nindex += (index >> 3);\r\ndata = dat[index];\r\ndata |= dat[index+1] << 8;\r\nmask ^= (data >> offset) & 0x1ff;\r\ndata &= ~(0x1ff << offset);\r\ndata |= (mask << offset);\r\ndat[index] = data & 0xff;\r\ndat[index+1] = (data >> 8) & 0xff;\r\n}\r\nstatic int jz_nand_correct_ecc_rs(struct mtd_info *mtd, uint8_t *dat,\r\nuint8_t *read_ecc, uint8_t *calc_ecc)\r\n{\r\nstruct jz_nand *nand = mtd_to_jz_nand(mtd);\r\nint i, error_count, index;\r\nuint32_t reg, status, error;\r\nuint32_t t;\r\nunsigned int timeout = 1000;\r\nt = read_ecc[0];\r\nif (t == 0xff) {\r\nfor (i = 1; i < 9; ++i)\r\nt &= read_ecc[i];\r\nt &= dat[0];\r\nt &= dat[nand->chip.ecc.size / 2];\r\nt &= dat[nand->chip.ecc.size - 1];\r\nif (t == 0xff) {\r\nfor (i = 1; i < nand->chip.ecc.size - 1; ++i)\r\nt &= dat[i];\r\nif (t == 0xff)\r\nreturn 0;\r\n}\r\n}\r\nfor (i = 0; i < 9; ++i)\r\nwriteb(read_ecc[i], nand->base + JZ_REG_NAND_PAR0 + i);\r\nreg = readl(nand->base + JZ_REG_NAND_ECC_CTRL);\r\nreg |= JZ_NAND_ECC_CTRL_PAR_READY;\r\nwritel(reg, nand->base + JZ_REG_NAND_ECC_CTRL);\r\ndo {\r\nstatus = readl(nand->base + JZ_REG_NAND_IRQ_STAT);\r\n} while (!(status & JZ_NAND_STATUS_DEC_FINISH) && --timeout);\r\nif (timeout == 0)\r\nreturn -1;\r\nreg = readl(nand->base + JZ_REG_NAND_ECC_CTRL);\r\nreg &= ~JZ_NAND_ECC_CTRL_ENABLE;\r\nwritel(reg, nand->base + JZ_REG_NAND_ECC_CTRL);\r\nif (status & JZ_NAND_STATUS_ERROR) {\r\nif (status & JZ_NAND_STATUS_UNCOR_ERROR)\r\nreturn -1;\r\nerror_count = (status & JZ_NAND_STATUS_ERR_COUNT) >> 29;\r\nfor (i = 0; i < error_count; ++i) {\r\nerror = readl(nand->base + JZ_REG_NAND_ERR(i));\r\nindex = ((error >> 16) & 0x1ff) - 1;\r\nif (index >= 0 && index < 512)\r\njz_nand_correct_data(dat, index, error & 0x1ff);\r\n}\r\nreturn error_count;\r\n}\r\nreturn 0;\r\n}\r\nstatic int jz_nand_ioremap_resource(struct platform_device *pdev,\r\nconst char *name, struct resource **res, void *__iomem *base)\r\n{\r\nint ret;\r\n*res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);\r\nif (!*res) {\r\ndev_err(&pdev->dev, "Failed to get platform %s memory\n", name);\r\nret = -ENXIO;\r\ngoto err;\r\n}\r\n*res = request_mem_region((*res)->start, resource_size(*res),\r\npdev->name);\r\nif (!*res) {\r\ndev_err(&pdev->dev, "Failed to request %s memory region\n", name);\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\n*base = ioremap((*res)->start, resource_size(*res));\r\nif (!*base) {\r\ndev_err(&pdev->dev, "Failed to ioremap %s memory region\n", name);\r\nret = -EBUSY;\r\ngoto err_release_mem;\r\n}\r\nreturn 0;\r\nerr_release_mem:\r\nrelease_mem_region((*res)->start, resource_size(*res));\r\nerr:\r\n*res = NULL;\r\n*base = NULL;\r\nreturn ret;\r\n}\r\nstatic inline void jz_nand_iounmap_resource(struct resource *res, void __iomem *base)\r\n{\r\niounmap(base);\r\nrelease_mem_region(res->start, resource_size(res));\r\n}\r\nstatic int __devinit jz_nand_detect_bank(struct platform_device *pdev, struct jz_nand *nand, unsigned char bank, size_t chipnr, uint8_t *nand_maf_id, uint8_t *nand_dev_id) {\r\nint ret;\r\nint gpio;\r\nchar gpio_name[9];\r\nchar res_name[6];\r\nuint32_t ctrl;\r\nstruct mtd_info *mtd = &nand->mtd;\r\nstruct nand_chip *chip = &nand->chip;\r\ngpio = JZ_GPIO_MEM_CS0 + bank - 1;\r\nsprintf(gpio_name, "NAND CS%d", bank);\r\nret = gpio_request(gpio, gpio_name);\r\nif (ret) {\r\ndev_warn(&pdev->dev,\r\n"Failed to request %s gpio %d: %d\n",\r\ngpio_name, gpio, ret);\r\ngoto notfound_gpio;\r\n}\r\nsprintf(res_name, "bank%d", bank);\r\nret = jz_nand_ioremap_resource(pdev, res_name,\r\n&nand->bank_mem[bank - 1],\r\n&nand->bank_base[bank - 1]);\r\nif (ret)\r\ngoto notfound_resource;\r\njz_gpio_set_function(gpio, JZ_GPIO_FUNC_MEM_CS0);\r\nctrl = readl(nand->base + JZ_REG_NAND_CTRL);\r\nctrl |= JZ_NAND_CTRL_ENABLE_CHIP(bank - 1);\r\nwritel(ctrl, nand->base + JZ_REG_NAND_CTRL);\r\nif (chipnr == 0) {\r\nret = nand_scan_ident(mtd, 1, NULL);\r\nif (ret)\r\ngoto notfound_id;\r\nchip->select_chip(mtd, 0);\r\nchip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);\r\n*nand_maf_id = chip->read_byte(mtd);\r\n*nand_dev_id = chip->read_byte(mtd);\r\n} else {\r\nchip->select_chip(mtd, chipnr);\r\nchip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);\r\nif (*nand_maf_id != chip->read_byte(mtd)\r\n|| *nand_dev_id != chip->read_byte(mtd)) {\r\nret = -ENODEV;\r\ngoto notfound_id;\r\n}\r\nchip->numchips++;\r\nmtd->size += chip->chipsize;\r\n}\r\ndev_info(&pdev->dev, "Found chip %i on bank %i\n", chipnr, bank);\r\nreturn 0;\r\nnotfound_id:\r\ndev_info(&pdev->dev, "No chip found on bank %i\n", bank);\r\nctrl &= ~(JZ_NAND_CTRL_ENABLE_CHIP(bank - 1));\r\nwritel(ctrl, nand->base + JZ_REG_NAND_CTRL);\r\njz_gpio_set_function(gpio, JZ_GPIO_FUNC_NONE);\r\njz_nand_iounmap_resource(nand->bank_mem[bank - 1],\r\nnand->bank_base[bank - 1]);\r\nnotfound_resource:\r\ngpio_free(gpio);\r\nnotfound_gpio:\r\nreturn ret;\r\n}\r\nstatic int __devinit jz_nand_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct jz_nand *nand;\r\nstruct nand_chip *chip;\r\nstruct mtd_info *mtd;\r\nstruct jz_nand_platform_data *pdata = pdev->dev.platform_data;\r\nsize_t chipnr, bank_idx;\r\nuint8_t nand_maf_id = 0, nand_dev_id = 0;\r\nnand = kzalloc(sizeof(*nand), GFP_KERNEL);\r\nif (!nand) {\r\ndev_err(&pdev->dev, "Failed to allocate device structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nret = jz_nand_ioremap_resource(pdev, "mmio", &nand->mem, &nand->base);\r\nif (ret)\r\ngoto err_free;\r\nif (pdata && gpio_is_valid(pdata->busy_gpio)) {\r\nret = gpio_request(pdata->busy_gpio, "NAND busy pin");\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Failed to request busy gpio %d: %d\n",\r\npdata->busy_gpio, ret);\r\ngoto err_iounmap_mmio;\r\n}\r\n}\r\nmtd = &nand->mtd;\r\nchip = &nand->chip;\r\nmtd->priv = chip;\r\nmtd->owner = THIS_MODULE;\r\nmtd->name = "jz4740-nand";\r\nchip->ecc.hwctl = jz_nand_hwctl;\r\nchip->ecc.calculate = jz_nand_calculate_ecc_rs;\r\nchip->ecc.correct = jz_nand_correct_ecc_rs;\r\nchip->ecc.mode = NAND_ECC_HW_OOB_FIRST;\r\nchip->ecc.size = 512;\r\nchip->ecc.bytes = 9;\r\nchip->ecc.strength = 4;\r\nif (pdata)\r\nchip->ecc.layout = pdata->ecc_layout;\r\nchip->chip_delay = 50;\r\nchip->cmd_ctrl = jz_nand_cmd_ctrl;\r\nchip->select_chip = jz_nand_select_chip;\r\nif (pdata && gpio_is_valid(pdata->busy_gpio))\r\nchip->dev_ready = jz_nand_dev_ready;\r\nnand->pdata = pdata;\r\nplatform_set_drvdata(pdev, nand);\r\nchipnr = 0;\r\nfor (bank_idx = 0; bank_idx < JZ_NAND_NUM_BANKS; bank_idx++) {\r\nunsigned char bank;\r\nbank = pdata ? pdata->banks[bank_idx] : bank_idx ^ 1;\r\nif (bank == 0)\r\nbreak;\r\nif (bank > JZ_NAND_NUM_BANKS) {\r\ndev_warn(&pdev->dev,\r\n"Skipping non-existing bank: %d\n", bank);\r\ncontinue;\r\n}\r\nnand->banks[chipnr] = bank;\r\nif (jz_nand_detect_bank(pdev, nand, bank, chipnr,\r\n&nand_maf_id, &nand_dev_id) == 0)\r\nchipnr++;\r\nelse\r\nnand->banks[chipnr] = 0;\r\n}\r\nif (chipnr == 0) {\r\ndev_err(&pdev->dev, "No NAND chips found\n");\r\ngoto err_gpio_busy;\r\n}\r\nif (pdata && pdata->ident_callback) {\r\npdata->ident_callback(pdev, chip, &pdata->partitions,\r\n&pdata->num_partitions);\r\n}\r\nret = nand_scan_tail(mtd);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to scan NAND\n");\r\ngoto err_unclaim_banks;\r\n}\r\nret = mtd_device_parse_register(mtd, NULL, NULL,\r\npdata ? pdata->partitions : NULL,\r\npdata ? pdata->num_partitions : 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to add mtd device\n");\r\ngoto err_nand_release;\r\n}\r\ndev_info(&pdev->dev, "Successfully registered JZ4740 NAND driver\n");\r\nreturn 0;\r\nerr_nand_release:\r\nnand_release(mtd);\r\nerr_unclaim_banks:\r\nwhile (chipnr--) {\r\nunsigned char bank = nand->banks[chipnr];\r\ngpio_free(JZ_GPIO_MEM_CS0 + bank - 1);\r\njz_nand_iounmap_resource(nand->bank_mem[bank - 1],\r\nnand->bank_base[bank - 1]);\r\n}\r\nwritel(0, nand->base + JZ_REG_NAND_CTRL);\r\nerr_gpio_busy:\r\nif (pdata && gpio_is_valid(pdata->busy_gpio))\r\ngpio_free(pdata->busy_gpio);\r\nplatform_set_drvdata(pdev, NULL);\r\nerr_iounmap_mmio:\r\njz_nand_iounmap_resource(nand->mem, nand->base);\r\nerr_free:\r\nkfree(nand);\r\nreturn ret;\r\n}\r\nstatic int __devexit jz_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct jz_nand *nand = platform_get_drvdata(pdev);\r\nstruct jz_nand_platform_data *pdata = pdev->dev.platform_data;\r\nsize_t i;\r\nnand_release(&nand->mtd);\r\nwritel(0, nand->base + JZ_REG_NAND_CTRL);\r\nfor (i = 0; i < JZ_NAND_NUM_BANKS; ++i) {\r\nunsigned char bank = nand->banks[i];\r\nif (bank != 0) {\r\njz_nand_iounmap_resource(nand->bank_mem[bank - 1],\r\nnand->bank_base[bank - 1]);\r\ngpio_free(JZ_GPIO_MEM_CS0 + bank - 1);\r\n}\r\n}\r\nif (pdata && gpio_is_valid(pdata->busy_gpio))\r\ngpio_free(pdata->busy_gpio);\r\njz_nand_iounmap_resource(nand->mem, nand->base);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(nand);\r\nreturn 0;\r\n}
