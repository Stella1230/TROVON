static int pas202bcb_init(struct sn9c102_device* cam)\r\n{\r\nint err = 0;\r\nswitch (sn9c102_get_bridge(cam)) {\r\ncase BRIDGE_SN9C101:\r\ncase BRIDGE_SN9C102:\r\nerr = sn9c102_write_const_regs(cam, {0x00, 0x10}, {0x00, 0x11},\r\n{0x00, 0x14}, {0x20, 0x17},\r\n{0x30, 0x19}, {0x09, 0x18});\r\nbreak;\r\ncase BRIDGE_SN9C103:\r\nerr = sn9c102_write_const_regs(cam, {0x00, 0x02}, {0x00, 0x03},\r\n{0x1a, 0x04}, {0x20, 0x05},\r\n{0x20, 0x06}, {0x20, 0x07},\r\n{0x00, 0x10}, {0x00, 0x11},\r\n{0x00, 0x14}, {0x20, 0x17},\r\n{0x30, 0x19}, {0x09, 0x18},\r\n{0x02, 0x1c}, {0x03, 0x1d},\r\n{0x0f, 0x1e}, {0x0c, 0x1f},\r\n{0x00, 0x20}, {0x10, 0x21},\r\n{0x20, 0x22}, {0x30, 0x23},\r\n{0x40, 0x24}, {0x50, 0x25},\r\n{0x60, 0x26}, {0x70, 0x27},\r\n{0x80, 0x28}, {0x90, 0x29},\r\n{0xa0, 0x2a}, {0xb0, 0x2b},\r\n{0xc0, 0x2c}, {0xd0, 0x2d},\r\n{0xe0, 0x2e}, {0xf0, 0x2f},\r\n{0xff, 0x30});\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nerr += sn9c102_i2c_write(cam, 0x02, 0x14);\r\nerr += sn9c102_i2c_write(cam, 0x03, 0x40);\r\nerr += sn9c102_i2c_write(cam, 0x0d, 0x2c);\r\nerr += sn9c102_i2c_write(cam, 0x0e, 0x01);\r\nerr += sn9c102_i2c_write(cam, 0x0f, 0xa9);\r\nerr += sn9c102_i2c_write(cam, 0x10, 0x08);\r\nerr += sn9c102_i2c_write(cam, 0x13, 0x63);\r\nerr += sn9c102_i2c_write(cam, 0x15, 0x70);\r\nerr += sn9c102_i2c_write(cam, 0x11, 0x01);\r\nmsleep(400);\r\nreturn err;\r\n}\r\nstatic int pas202bcb_get_ctrl(struct sn9c102_device* cam,\r\nstruct v4l2_control* ctrl)\r\n{\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_EXPOSURE:\r\n{\r\nint r1 = sn9c102_i2c_read(cam, 0x04),\r\nr2 = sn9c102_i2c_read(cam, 0x05);\r\nif (r1 < 0 || r2 < 0)\r\nreturn -EIO;\r\nctrl->value = (r1 << 6) | (r2 & 0x3f);\r\n}\r\nreturn 0;\r\ncase V4L2_CID_RED_BALANCE:\r\nif ((ctrl->value = sn9c102_i2c_read(cam, 0x09)) < 0)\r\nreturn -EIO;\r\nctrl->value &= 0x0f;\r\nreturn 0;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nif ((ctrl->value = sn9c102_i2c_read(cam, 0x07)) < 0)\r\nreturn -EIO;\r\nctrl->value &= 0x0f;\r\nreturn 0;\r\ncase V4L2_CID_GAIN:\r\nif ((ctrl->value = sn9c102_i2c_read(cam, 0x10)) < 0)\r\nreturn -EIO;\r\nctrl->value &= 0x1f;\r\nreturn 0;\r\ncase SN9C102_V4L2_CID_GREEN_BALANCE:\r\nif ((ctrl->value = sn9c102_i2c_read(cam, 0x08)) < 0)\r\nreturn -EIO;\r\nctrl->value &= 0x0f;\r\nreturn 0;\r\ncase SN9C102_V4L2_CID_DAC_MAGNITUDE:\r\nif ((ctrl->value = sn9c102_i2c_read(cam, 0x0c)) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int pas202bcb_set_pix_format(struct sn9c102_device* cam,\r\nconst struct v4l2_pix_format* pix)\r\n{\r\nint err = 0;\r\nif (pix->pixelformat == V4L2_PIX_FMT_SN9C10X)\r\nerr += sn9c102_write_reg(cam, 0x28, 0x17);\r\nelse\r\nerr += sn9c102_write_reg(cam, 0x20, 0x17);\r\nreturn err;\r\n}\r\nstatic int pas202bcb_set_ctrl(struct sn9c102_device* cam,\r\nconst struct v4l2_control* ctrl)\r\n{\r\nint err = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_EXPOSURE:\r\nerr += sn9c102_i2c_write(cam, 0x04, ctrl->value >> 6);\r\nerr += sn9c102_i2c_write(cam, 0x05, ctrl->value & 0x3f);\r\nbreak;\r\ncase V4L2_CID_RED_BALANCE:\r\nerr += sn9c102_i2c_write(cam, 0x09, ctrl->value);\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nerr += sn9c102_i2c_write(cam, 0x07, ctrl->value);\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nerr += sn9c102_i2c_write(cam, 0x10, ctrl->value);\r\nbreak;\r\ncase SN9C102_V4L2_CID_GREEN_BALANCE:\r\nerr += sn9c102_i2c_write(cam, 0x08, ctrl->value);\r\nbreak;\r\ncase SN9C102_V4L2_CID_DAC_MAGNITUDE:\r\nerr += sn9c102_i2c_write(cam, 0x0c, ctrl->value);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr += sn9c102_i2c_write(cam, 0x11, 0x01);\r\nreturn err ? -EIO : 0;\r\n}\r\nstatic int pas202bcb_set_crop(struct sn9c102_device* cam,\r\nconst struct v4l2_rect* rect)\r\n{\r\nstruct sn9c102_sensor* s = sn9c102_get_sensor(cam);\r\nint err = 0;\r\nu8 h_start = 0,\r\nv_start = (u8)(rect->top - s->cropcap.bounds.top) + 3;\r\nswitch (sn9c102_get_bridge(cam)) {\r\ncase BRIDGE_SN9C101:\r\ncase BRIDGE_SN9C102:\r\nh_start = (u8)(rect->left - s->cropcap.bounds.left) + 4;\r\nbreak;\r\ncase BRIDGE_SN9C103:\r\nh_start = (u8)(rect->left - s->cropcap.bounds.left) + 3;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nerr += sn9c102_write_reg(cam, h_start, 0x12);\r\nerr += sn9c102_write_reg(cam, v_start, 0x13);\r\nreturn err;\r\n}\r\nint sn9c102_probe_pas202bcb(struct sn9c102_device* cam)\r\n{\r\nint r0 = 0, r1 = 0, err = 0;\r\nunsigned int pid = 0;\r\nswitch (sn9c102_get_bridge(cam)) {\r\ncase BRIDGE_SN9C101:\r\ncase BRIDGE_SN9C102:\r\nerr = sn9c102_write_const_regs(cam,\r\n{0x01, 0x01},\r\n{0x40, 0x01},\r\n{0x28, 0x17});\r\nbreak;\r\ncase BRIDGE_SN9C103:\r\nerr = sn9c102_write_const_regs(cam, {0x09, 0x01}, {0x44, 0x01},\r\n{0x44, 0x02}, {0x29, 0x17});\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nr0 = sn9c102_i2c_try_read(cam, &pas202bcb, 0x00);\r\nr1 = sn9c102_i2c_try_read(cam, &pas202bcb, 0x01);\r\nif (err || r0 < 0 || r1 < 0)\r\nreturn -EIO;\r\npid = (r0 << 4) | ((r1 & 0xf0) >> 4);\r\nif (pid != 0x017)\r\nreturn -ENODEV;\r\nsn9c102_attach_sensor(cam, &pas202bcb);\r\nreturn 0;\r\n}
