static void set_vbus_draw(struct gpio_vbus_data *gpio_vbus, unsigned mA)\r\n{\r\nstruct regulator *vbus_draw = gpio_vbus->vbus_draw;\r\nint enabled;\r\nif (!vbus_draw)\r\nreturn;\r\nenabled = gpio_vbus->vbus_draw_enabled;\r\nif (mA) {\r\nregulator_set_current_limit(vbus_draw, 0, 1000 * mA);\r\nif (!enabled) {\r\nregulator_enable(vbus_draw);\r\ngpio_vbus->vbus_draw_enabled = 1;\r\n}\r\n} else {\r\nif (enabled) {\r\nregulator_disable(vbus_draw);\r\ngpio_vbus->vbus_draw_enabled = 0;\r\n}\r\n}\r\ngpio_vbus->mA = mA;\r\n}\r\nstatic int is_vbus_powered(struct gpio_vbus_mach_info *pdata)\r\n{\r\nint vbus;\r\nvbus = gpio_get_value(pdata->gpio_vbus);\r\nif (pdata->gpio_vbus_inverted)\r\nvbus = !vbus;\r\nreturn vbus;\r\n}\r\nstatic void gpio_vbus_work(struct work_struct *work)\r\n{\r\nstruct gpio_vbus_data *gpio_vbus =\r\ncontainer_of(work, struct gpio_vbus_data, work.work);\r\nstruct gpio_vbus_mach_info *pdata = gpio_vbus->dev->platform_data;\r\nint gpio, status, vbus;\r\nif (!gpio_vbus->phy.otg->gadget)\r\nreturn;\r\nvbus = is_vbus_powered(pdata);\r\nif ((vbus ^ gpio_vbus->vbus) == 0)\r\nreturn;\r\ngpio_vbus->vbus = vbus;\r\ngpio = pdata->gpio_pullup;\r\nif (vbus) {\r\nstatus = USB_EVENT_VBUS;\r\ngpio_vbus->phy.state = OTG_STATE_B_PERIPHERAL;\r\ngpio_vbus->phy.last_event = status;\r\nusb_gadget_vbus_connect(gpio_vbus->phy.otg->gadget);\r\nset_vbus_draw(gpio_vbus, 100);\r\nif (gpio_is_valid(gpio))\r\ngpio_set_value(gpio, !pdata->gpio_pullup_inverted);\r\natomic_notifier_call_chain(&gpio_vbus->phy.notifier,\r\nstatus, gpio_vbus->phy.otg->gadget);\r\n} else {\r\nif (gpio_is_valid(gpio))\r\ngpio_set_value(gpio, pdata->gpio_pullup_inverted);\r\nset_vbus_draw(gpio_vbus, 0);\r\nusb_gadget_vbus_disconnect(gpio_vbus->phy.otg->gadget);\r\nstatus = USB_EVENT_NONE;\r\ngpio_vbus->phy.state = OTG_STATE_B_IDLE;\r\ngpio_vbus->phy.last_event = status;\r\natomic_notifier_call_chain(&gpio_vbus->phy.notifier,\r\nstatus, gpio_vbus->phy.otg->gadget);\r\n}\r\n}\r\nstatic irqreturn_t gpio_vbus_irq(int irq, void *data)\r\n{\r\nstruct platform_device *pdev = data;\r\nstruct gpio_vbus_mach_info *pdata = pdev->dev.platform_data;\r\nstruct gpio_vbus_data *gpio_vbus = platform_get_drvdata(pdev);\r\nstruct usb_otg *otg = gpio_vbus->phy.otg;\r\ndev_dbg(&pdev->dev, "VBUS %s (gadget: %s)\n",\r\nis_vbus_powered(pdata) ? "supplied" : "inactive",\r\notg->gadget ? otg->gadget->name : "none");\r\nif (otg->gadget)\r\nschedule_delayed_work(&gpio_vbus->work, msecs_to_jiffies(100));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int gpio_vbus_set_peripheral(struct usb_otg *otg,\r\nstruct usb_gadget *gadget)\r\n{\r\nstruct gpio_vbus_data *gpio_vbus;\r\nstruct gpio_vbus_mach_info *pdata;\r\nstruct platform_device *pdev;\r\nint gpio;\r\ngpio_vbus = container_of(otg->phy, struct gpio_vbus_data, phy);\r\npdev = to_platform_device(gpio_vbus->dev);\r\npdata = gpio_vbus->dev->platform_data;\r\ngpio = pdata->gpio_pullup;\r\nif (!gadget) {\r\ndev_dbg(&pdev->dev, "unregistering gadget '%s'\n",\r\notg->gadget->name);\r\nif (gpio_is_valid(gpio))\r\ngpio_set_value(gpio, pdata->gpio_pullup_inverted);\r\nset_vbus_draw(gpio_vbus, 0);\r\nusb_gadget_vbus_disconnect(otg->gadget);\r\notg->phy->state = OTG_STATE_UNDEFINED;\r\notg->gadget = NULL;\r\nreturn 0;\r\n}\r\notg->gadget = gadget;\r\ndev_dbg(&pdev->dev, "registered gadget '%s'\n", gadget->name);\r\ngpio_vbus->vbus = 0;\r\ngpio_vbus_irq(gpio_vbus->irq, pdev);\r\nreturn 0;\r\n}\r\nstatic int gpio_vbus_set_power(struct usb_phy *phy, unsigned mA)\r\n{\r\nstruct gpio_vbus_data *gpio_vbus;\r\ngpio_vbus = container_of(phy, struct gpio_vbus_data, phy);\r\nif (phy->state == OTG_STATE_B_PERIPHERAL)\r\nset_vbus_draw(gpio_vbus, mA);\r\nreturn 0;\r\n}\r\nstatic int gpio_vbus_set_suspend(struct usb_phy *phy, int suspend)\r\n{\r\nstruct gpio_vbus_data *gpio_vbus;\r\ngpio_vbus = container_of(phy, struct gpio_vbus_data, phy);\r\nreturn gpio_vbus_set_power(phy, suspend ? 0 : gpio_vbus->mA);\r\n}\r\nstatic int __init gpio_vbus_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_vbus_mach_info *pdata = pdev->dev.platform_data;\r\nstruct gpio_vbus_data *gpio_vbus;\r\nstruct resource *res;\r\nint err, gpio, irq;\r\nunsigned long irqflags;\r\nif (!pdata || !gpio_is_valid(pdata->gpio_vbus))\r\nreturn -EINVAL;\r\ngpio = pdata->gpio_vbus;\r\ngpio_vbus = kzalloc(sizeof(struct gpio_vbus_data), GFP_KERNEL);\r\nif (!gpio_vbus)\r\nreturn -ENOMEM;\r\ngpio_vbus->phy.otg = kzalloc(sizeof(struct usb_otg), GFP_KERNEL);\r\nif (!gpio_vbus->phy.otg) {\r\nkfree(gpio_vbus);\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, gpio_vbus);\r\ngpio_vbus->dev = &pdev->dev;\r\ngpio_vbus->phy.label = "gpio-vbus";\r\ngpio_vbus->phy.set_power = gpio_vbus_set_power;\r\ngpio_vbus->phy.set_suspend = gpio_vbus_set_suspend;\r\ngpio_vbus->phy.state = OTG_STATE_UNDEFINED;\r\ngpio_vbus->phy.otg->phy = &gpio_vbus->phy;\r\ngpio_vbus->phy.otg->set_peripheral = gpio_vbus_set_peripheral;\r\nerr = gpio_request(gpio, "vbus_detect");\r\nif (err) {\r\ndev_err(&pdev->dev, "can't request vbus gpio %d, err: %d\n",\r\ngpio, err);\r\ngoto err_gpio;\r\n}\r\ngpio_direction_input(gpio);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res) {\r\nirq = res->start;\r\nirqflags = (res->flags & IRQF_TRIGGER_MASK) | IRQF_SHARED;\r\n} else {\r\nirq = gpio_to_irq(gpio);\r\nirqflags = VBUS_IRQ_FLAGS;\r\n}\r\ngpio_vbus->irq = irq;\r\ngpio = pdata->gpio_pullup;\r\nif (gpio_is_valid(gpio)) {\r\nerr = gpio_request(gpio, "udc_pullup");\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"can't request pullup gpio %d, err: %d\n",\r\ngpio, err);\r\ngpio_free(pdata->gpio_vbus);\r\ngoto err_gpio;\r\n}\r\ngpio_direction_output(gpio, pdata->gpio_pullup_inverted);\r\n}\r\nerr = request_irq(irq, gpio_vbus_irq, irqflags, "vbus_detect", pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "can't request irq %i, err: %d\n",\r\nirq, err);\r\ngoto err_irq;\r\n}\r\nATOMIC_INIT_NOTIFIER_HEAD(&gpio_vbus->phy.notifier);\r\nINIT_DELAYED_WORK(&gpio_vbus->work, gpio_vbus_work);\r\ngpio_vbus->vbus_draw = regulator_get(&pdev->dev, "vbus_draw");\r\nif (IS_ERR(gpio_vbus->vbus_draw)) {\r\ndev_dbg(&pdev->dev, "can't get vbus_draw regulator, err: %ld\n",\r\nPTR_ERR(gpio_vbus->vbus_draw));\r\ngpio_vbus->vbus_draw = NULL;\r\n}\r\nerr = usb_add_phy(&gpio_vbus->phy, USB_PHY_TYPE_USB2);\r\nif (err) {\r\ndev_err(&pdev->dev, "can't register transceiver, err: %d\n",\r\nerr);\r\ngoto err_otg;\r\n}\r\ndevice_init_wakeup(&pdev->dev, pdata->wakeup);\r\nreturn 0;\r\nerr_otg:\r\nregulator_put(gpio_vbus->vbus_draw);\r\nfree_irq(irq, pdev);\r\nerr_irq:\r\nif (gpio_is_valid(pdata->gpio_pullup))\r\ngpio_free(pdata->gpio_pullup);\r\ngpio_free(pdata->gpio_vbus);\r\nerr_gpio:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(gpio_vbus->phy.otg);\r\nkfree(gpio_vbus);\r\nreturn err;\r\n}\r\nstatic int __exit gpio_vbus_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_vbus_data *gpio_vbus = platform_get_drvdata(pdev);\r\nstruct gpio_vbus_mach_info *pdata = pdev->dev.platform_data;\r\nint gpio = pdata->gpio_vbus;\r\ndevice_init_wakeup(&pdev->dev, 0);\r\ncancel_delayed_work_sync(&gpio_vbus->work);\r\nregulator_put(gpio_vbus->vbus_draw);\r\nusb_remove_phy(&gpio_vbus->phy);\r\nfree_irq(gpio_vbus->irq, pdev);\r\nif (gpio_is_valid(pdata->gpio_pullup))\r\ngpio_free(pdata->gpio_pullup);\r\ngpio_free(gpio);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(gpio_vbus->phy.otg);\r\nkfree(gpio_vbus);\r\nreturn 0;\r\n}\r\nstatic int gpio_vbus_pm_suspend(struct device *dev)\r\n{\r\nstruct gpio_vbus_data *gpio_vbus = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(gpio_vbus->irq);\r\nreturn 0;\r\n}\r\nstatic int gpio_vbus_pm_resume(struct device *dev)\r\n{\r\nstruct gpio_vbus_data *gpio_vbus = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(gpio_vbus->irq);\r\nreturn 0;\r\n}\r\nstatic int __init gpio_vbus_init(void)\r\n{\r\nreturn platform_driver_probe(&gpio_vbus_driver, gpio_vbus_probe);\r\n}\r\nstatic void __exit gpio_vbus_exit(void)\r\n{\r\nplatform_driver_unregister(&gpio_vbus_driver);\r\n}
