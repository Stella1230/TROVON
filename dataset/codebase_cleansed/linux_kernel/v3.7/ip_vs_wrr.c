static int ip_vs_wrr_gcd_weight(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_dest *dest;\r\nint weight;\r\nint g = 0;\r\nlist_for_each_entry(dest, &svc->destinations, n_list) {\r\nweight = atomic_read(&dest->weight);\r\nif (weight > 0) {\r\nif (g > 0)\r\ng = gcd(weight, g);\r\nelse\r\ng = weight;\r\n}\r\n}\r\nreturn g ? g : 1;\r\n}\r\nstatic int ip_vs_wrr_max_weight(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_dest *dest;\r\nint new_weight, weight = 0;\r\nlist_for_each_entry(dest, &svc->destinations, n_list) {\r\nnew_weight = atomic_read(&dest->weight);\r\nif (new_weight > weight)\r\nweight = new_weight;\r\n}\r\nreturn weight;\r\n}\r\nstatic int ip_vs_wrr_init_svc(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_wrr_mark *mark;\r\nmark = kmalloc(sizeof(struct ip_vs_wrr_mark), GFP_KERNEL);\r\nif (mark == NULL)\r\nreturn -ENOMEM;\r\nmark->cl = &svc->destinations;\r\nmark->cw = 0;\r\nmark->mw = ip_vs_wrr_max_weight(svc);\r\nmark->di = ip_vs_wrr_gcd_weight(svc);\r\nsvc->sched_data = mark;\r\nreturn 0;\r\n}\r\nstatic int ip_vs_wrr_done_svc(struct ip_vs_service *svc)\r\n{\r\nkfree(svc->sched_data);\r\nreturn 0;\r\n}\r\nstatic int ip_vs_wrr_update_svc(struct ip_vs_service *svc)\r\n{\r\nstruct ip_vs_wrr_mark *mark = svc->sched_data;\r\nmark->cl = &svc->destinations;\r\nmark->mw = ip_vs_wrr_max_weight(svc);\r\nmark->di = ip_vs_wrr_gcd_weight(svc);\r\nif (mark->cw > mark->mw)\r\nmark->cw = 0;\r\nreturn 0;\r\n}\r\nstatic struct ip_vs_dest *\r\nip_vs_wrr_schedule(struct ip_vs_service *svc, const struct sk_buff *skb)\r\n{\r\nstruct ip_vs_dest *dest;\r\nstruct ip_vs_wrr_mark *mark = svc->sched_data;\r\nstruct list_head *p;\r\nIP_VS_DBG(6, "%s(): Scheduling...\n", __func__);\r\nwrite_lock(&svc->sched_lock);\r\np = mark->cl;\r\nwhile (1) {\r\nif (mark->cl == &svc->destinations) {\r\nif (mark->cl == mark->cl->next) {\r\nip_vs_scheduler_err(svc,\r\n"no destination available: "\r\n"no destinations present");\r\ndest = NULL;\r\ngoto out;\r\n}\r\nmark->cl = svc->destinations.next;\r\nmark->cw -= mark->di;\r\nif (mark->cw <= 0) {\r\nmark->cw = mark->mw;\r\nif (mark->cw == 0) {\r\nmark->cl = &svc->destinations;\r\nip_vs_scheduler_err(svc,\r\n"no destination available");\r\ndest = NULL;\r\ngoto out;\r\n}\r\n}\r\n} else\r\nmark->cl = mark->cl->next;\r\nif (mark->cl != &svc->destinations) {\r\ndest = list_entry(mark->cl, struct ip_vs_dest, n_list);\r\nif (!(dest->flags & IP_VS_DEST_F_OVERLOAD) &&\r\natomic_read(&dest->weight) >= mark->cw) {\r\nbreak;\r\n}\r\n}\r\nif (mark->cl == p && mark->cw == mark->di) {\r\ndest = NULL;\r\nip_vs_scheduler_err(svc,\r\n"no destination available: "\r\n"all destinations are overloaded");\r\ngoto out;\r\n}\r\n}\r\nIP_VS_DBG_BUF(6, "WRR: server %s:%u "\r\n"activeconns %d refcnt %d weight %d\n",\r\nIP_VS_DBG_ADDR(svc->af, &dest->addr), ntohs(dest->port),\r\natomic_read(&dest->activeconns),\r\natomic_read(&dest->refcnt),\r\natomic_read(&dest->weight));\r\nout:\r\nwrite_unlock(&svc->sched_lock);\r\nreturn dest;\r\n}\r\nstatic int __init ip_vs_wrr_init(void)\r\n{\r\nreturn register_ip_vs_scheduler(&ip_vs_wrr_scheduler) ;\r\n}\r\nstatic void __exit ip_vs_wrr_cleanup(void)\r\n{\r\nunregister_ip_vs_scheduler(&ip_vs_wrr_scheduler);\r\n}
