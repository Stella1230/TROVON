static ssize_t\r\nbsr_size_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct bsr_dev *bsr_dev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", bsr_dev->bsr_bytes);\r\n}\r\nstatic ssize_t\r\nbsr_stride_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct bsr_dev *bsr_dev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", bsr_dev->bsr_stride);\r\n}\r\nstatic ssize_t\r\nbsr_len_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct bsr_dev *bsr_dev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%llu\n", bsr_dev->bsr_len);\r\n}\r\nstatic int bsr_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nunsigned long size = vma->vm_end - vma->vm_start;\r\nstruct bsr_dev *dev = filp->private_data;\r\nint ret;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nif (dev->bsr_len < PAGE_SIZE && size == PAGE_SIZE)\r\nret = remap_4k_pfn(vma, vma->vm_start, dev->bsr_addr >> 12,\r\nvma->vm_page_prot);\r\nelse if (size <= dev->bsr_len)\r\nret = io_remap_pfn_range(vma, vma->vm_start,\r\ndev->bsr_addr >> PAGE_SHIFT,\r\nsize, vma->vm_page_prot);\r\nelse\r\nreturn -EINVAL;\r\nif (ret)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int bsr_open(struct inode * inode, struct file * filp)\r\n{\r\nstruct cdev *cdev = inode->i_cdev;\r\nstruct bsr_dev *dev = container_of(cdev, struct bsr_dev, bsr_cdev);\r\nfilp->private_data = dev;\r\nreturn 0;\r\n}\r\nstatic void bsr_cleanup_devs(void)\r\n{\r\nstruct bsr_dev *cur, *n;\r\nlist_for_each_entry_safe(cur, n, &bsr_devs, bsr_list) {\r\nif (cur->bsr_device) {\r\ncdev_del(&cur->bsr_cdev);\r\ndevice_del(cur->bsr_device);\r\n}\r\nlist_del(&cur->bsr_list);\r\nkfree(cur);\r\n}\r\n}\r\nstatic int bsr_add_node(struct device_node *bn)\r\n{\r\nint bsr_stride_len, bsr_bytes_len, num_bsr_devs;\r\nconst u32 *bsr_stride;\r\nconst u32 *bsr_bytes;\r\nunsigned i;\r\nint ret = -ENODEV;\r\nbsr_stride = of_get_property(bn, "ibm,lock-stride", &bsr_stride_len);\r\nbsr_bytes = of_get_property(bn, "ibm,#lock-bytes", &bsr_bytes_len);\r\nif (!bsr_stride || !bsr_bytes ||\r\n(bsr_stride_len != bsr_bytes_len)) {\r\nprintk(KERN_ERR "bsr of-node has missing/incorrect property\n");\r\nreturn ret;\r\n}\r\nnum_bsr_devs = bsr_bytes_len / sizeof(u32);\r\nfor (i = 0 ; i < num_bsr_devs; i++) {\r\nstruct bsr_dev *cur = kzalloc(sizeof(struct bsr_dev),\r\nGFP_KERNEL);\r\nstruct resource res;\r\nint result;\r\nif (!cur) {\r\nprintk(KERN_ERR "Unable to alloc bsr dev\n");\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\nresult = of_address_to_resource(bn, i, &res);\r\nif (result < 0) {\r\nprintk(KERN_ERR "bsr of-node has invalid reg property, skipping\n");\r\nkfree(cur);\r\ncontinue;\r\n}\r\ncur->bsr_minor = i + total_bsr_devs;\r\ncur->bsr_addr = res.start;\r\ncur->bsr_len = resource_size(&res);\r\ncur->bsr_bytes = bsr_bytes[i];\r\ncur->bsr_stride = bsr_stride[i];\r\ncur->bsr_dev = MKDEV(bsr_major, i + total_bsr_devs);\r\nif (cur->bsr_len > 4096 && cur->bsr_len < PAGE_SIZE)\r\ncur->bsr_len = 4096;\r\nswitch(cur->bsr_bytes) {\r\ncase 8:\r\ncur->bsr_type = BSR_8;\r\nbreak;\r\ncase 16:\r\ncur->bsr_type = BSR_16;\r\nbreak;\r\ncase 64:\r\ncur->bsr_type = BSR_64;\r\nbreak;\r\ncase 128:\r\ncur->bsr_type = BSR_128;\r\nbreak;\r\ncase 4096:\r\ncur->bsr_type = BSR_4096;\r\nbreak;\r\ndefault:\r\ncur->bsr_type = BSR_UNKNOWN;\r\n}\r\ncur->bsr_num = bsr_types[cur->bsr_type];\r\nsnprintf(cur->bsr_name, 32, "bsr%d_%d",\r\ncur->bsr_bytes, cur->bsr_num);\r\ncdev_init(&cur->bsr_cdev, &bsr_fops);\r\nresult = cdev_add(&cur->bsr_cdev, cur->bsr_dev, 1);\r\nif (result) {\r\nkfree(cur);\r\ngoto out_err;\r\n}\r\ncur->bsr_device = device_create(bsr_class, NULL, cur->bsr_dev,\r\ncur, cur->bsr_name);\r\nif (IS_ERR(cur->bsr_device)) {\r\nprintk(KERN_ERR "device_create failed for %s\n",\r\ncur->bsr_name);\r\ncdev_del(&cur->bsr_cdev);\r\nkfree(cur);\r\ngoto out_err;\r\n}\r\nbsr_types[cur->bsr_type] = cur->bsr_num + 1;\r\nlist_add_tail(&cur->bsr_list, &bsr_devs);\r\n}\r\ntotal_bsr_devs += num_bsr_devs;\r\nreturn 0;\r\nout_err:\r\nbsr_cleanup_devs();\r\nreturn ret;\r\n}\r\nstatic int bsr_create_devs(struct device_node *bn)\r\n{\r\nint ret;\r\nwhile (bn) {\r\nret = bsr_add_node(bn);\r\nif (ret) {\r\nof_node_put(bn);\r\nreturn ret;\r\n}\r\nbn = of_find_compatible_node(bn, NULL, "ibm,bsr");\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init bsr_init(void)\r\n{\r\nstruct device_node *np;\r\ndev_t bsr_dev;\r\nint ret = -ENODEV;\r\nnp = of_find_compatible_node(NULL, NULL, "ibm,bsr");\r\nif (!np)\r\ngoto out_err;\r\nbsr_class = class_create(THIS_MODULE, "bsr");\r\nif (IS_ERR(bsr_class)) {\r\nprintk(KERN_ERR "class_create() failed for bsr_class\n");\r\nret = PTR_ERR(bsr_class);\r\ngoto out_err_1;\r\n}\r\nbsr_class->dev_attrs = bsr_dev_attrs;\r\nret = alloc_chrdev_region(&bsr_dev, 0, BSR_MAX_DEVS, "bsr");\r\nbsr_major = MAJOR(bsr_dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "alloc_chrdev_region() failed for bsr\n");\r\ngoto out_err_2;\r\n}\r\nif ((ret = bsr_create_devs(np)) < 0) {\r\nnp = NULL;\r\ngoto out_err_3;\r\n}\r\nreturn 0;\r\nout_err_3:\r\nunregister_chrdev_region(bsr_dev, BSR_MAX_DEVS);\r\nout_err_2:\r\nclass_destroy(bsr_class);\r\nout_err_1:\r\nof_node_put(np);\r\nout_err:\r\nreturn ret;\r\n}\r\nstatic void __exit bsr_exit(void)\r\n{\r\nbsr_cleanup_devs();\r\nif (bsr_class)\r\nclass_destroy(bsr_class);\r\nif (bsr_major)\r\nunregister_chrdev_region(MKDEV(bsr_major, 0), BSR_MAX_DEVS);\r\n}
