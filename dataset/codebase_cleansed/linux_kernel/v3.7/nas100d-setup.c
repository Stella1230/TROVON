static void nas100d_power_off(void)\r\n{\r\ngpio_line_config(NAS100D_PO_GPIO, IXP4XX_GPIO_OUT);\r\ngpio_line_set(NAS100D_PO_GPIO, IXP4XX_GPIO_HIGH);\r\n}\r\nstatic void nas100d_power_handler(unsigned long data)\r\n{\r\nif (gpio_get_value(NAS100D_PB_GPIO)) {\r\nif (power_button_countdown > 0)\r\npower_button_countdown--;\r\n} else {\r\nif (power_button_countdown == 0) {\r\nctrl_alt_del();\r\ngpio_line_set(NAS100D_LED_PWR_GPIO, IXP4XX_GPIO_LOW);\r\n} else {\r\npower_button_countdown = PBUTTON_HOLDDOWN_COUNT;\r\n}\r\n}\r\nmod_timer(&nas100d_power_timer, jiffies + msecs_to_jiffies(500));\r\n}\r\nstatic irqreturn_t nas100d_reset_handler(int irq, void *dev_id)\r\n{\r\nmachine_power_off();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __init nas100d_init(void)\r\n{\r\nuint8_t __iomem *f;\r\nint i;\r\nixp4xx_sys_init();\r\n*IXP4XX_GPIO_GPCLKR = 0;\r\nnas100d_flash_resource.start = IXP4XX_EXP_BUS_BASE(0);\r\nnas100d_flash_resource.end =\r\nIXP4XX_EXP_BUS_BASE(0) + ixp4xx_exp_bus_size - 1;\r\ni2c_register_board_info(0, nas100d_i2c_board_info,\r\nARRAY_SIZE(nas100d_i2c_board_info));\r\n(void)platform_device_register(&nas100d_uart);\r\nplatform_add_devices(nas100d_devices, ARRAY_SIZE(nas100d_devices));\r\npm_power_off = nas100d_power_off;\r\nif (request_irq(gpio_to_irq(NAS100D_RB_GPIO), &nas100d_reset_handler,\r\nIRQF_DISABLED | IRQF_TRIGGER_LOW,\r\n"NAS100D reset button", NULL) < 0) {\r\nprintk(KERN_DEBUG "Reset Button IRQ %d not available\n",\r\ngpio_to_irq(NAS100D_RB_GPIO));\r\n}\r\ngpio_line_config(NAS100D_PB_GPIO, IXP4XX_GPIO_IN);\r\npower_button_countdown = PBUTTON_HOLDDOWN_COUNT;\r\nmod_timer(&nas100d_power_timer, jiffies + msecs_to_jiffies(500));\r\nf = ioremap(IXP4XX_EXP_BUS_BASE(0), 0x1000000);\r\nif (f) {\r\nfor (i = 0; i < 6; i++)\r\n#ifdef __ARMEB__\r\nnas100d_plat_eth[0].hwaddr[i] = readb(f + 0xFC0FD8 + i);\r\n#else\r\nnas100d_plat_eth[0].hwaddr[i] = readb(f + 0xFC0FD8 + (i^3));\r\n#endif\r\niounmap(f);\r\n}\r\nprintk(KERN_INFO "NAS100D: Using MAC address %pM for port 0\n",\r\nnas100d_plat_eth[0].hwaddr);\r\n}
