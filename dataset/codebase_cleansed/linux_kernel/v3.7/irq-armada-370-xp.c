static void armada_370_xp_irq_mask(struct irq_data *d)\r\n{\r\nwritel(irqd_to_hwirq(d),\r\nper_cpu_int_base + ARMADA_370_XP_INT_SET_MASK_OFFS);\r\n}\r\nstatic void armada_370_xp_irq_unmask(struct irq_data *d)\r\n{\r\nwritel(irqd_to_hwirq(d),\r\nper_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\n}\r\nstatic int armada_370_xp_mpic_irq_map(struct irq_domain *h,\r\nunsigned int virq, irq_hw_number_t hw)\r\n{\r\narmada_370_xp_irq_mask(irq_get_irq_data(virq));\r\nwritel(hw, main_int_base + ARMADA_370_XP_INT_SET_ENABLE_OFFS);\r\nirq_set_chip_and_handler(virq, &armada_370_xp_irq_chip,\r\nhandle_level_irq);\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nset_irq_flags(virq, IRQF_VALID | IRQF_PROBE);\r\nreturn 0;\r\n}\r\nstatic int __init armada_370_xp_mpic_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nu32 control;\r\nmain_int_base = of_iomap(node, 0);\r\nper_cpu_int_base = of_iomap(node, 1);\r\nBUG_ON(!main_int_base);\r\nBUG_ON(!per_cpu_int_base);\r\ncontrol = readl(main_int_base + ARMADA_370_XP_INT_CONTROL);\r\narmada_370_xp_mpic_domain =\r\nirq_domain_add_linear(node, (control >> 2) & 0x3ff,\r\n&armada_370_xp_mpic_irq_ops, NULL);\r\nif (!armada_370_xp_mpic_domain)\r\npanic("Unable to add Armada_370_Xp MPIC irq domain (DT)\n");\r\nirq_set_default_host(armada_370_xp_mpic_domain);\r\nreturn 0;\r\n}\r\nasmlinkage void __exception_irq_entry armada_370_xp_handle_irq(struct pt_regs\r\n*regs)\r\n{\r\nu32 irqstat, irqnr;\r\ndo {\r\nirqstat = readl_relaxed(per_cpu_int_base +\r\nARMADA_370_XP_CPU_INTACK_OFFS);\r\nirqnr = irqstat & 0x3FF;\r\nif (irqnr < 1023) {\r\nirqnr =\r\nirq_find_mapping(armada_370_xp_mpic_domain, irqnr);\r\nhandle_IRQ(irqnr, regs);\r\ncontinue;\r\n}\r\nbreak;\r\n} while (1);\r\n}\r\nvoid __init armada_370_xp_init_irq(void)\r\n{\r\nof_irq_init(mpic_of_match);\r\n}
