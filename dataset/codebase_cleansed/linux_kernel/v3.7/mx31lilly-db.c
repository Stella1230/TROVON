static int mxc_mmc1_get_ro(struct device *dev)\r\n{\r\nreturn gpio_get_value(IOMUX_TO_GPIO(MX31_PIN_LCS0));\r\n}\r\nstatic int mxc_mmc1_init(struct device *dev,\r\nirq_handler_t detect_irq, void *data)\r\n{\r\nint ret;\r\ngpio_det = IOMUX_TO_GPIO(MX31_PIN_GPIO1_1);\r\ngpio_wp = IOMUX_TO_GPIO(MX31_PIN_LCS0);\r\nmxc_iomux_set_pad(MX31_PIN_SD1_DATA0, MMC_PAD_CFG);\r\nmxc_iomux_set_pad(MX31_PIN_SD1_DATA1, MMC_PAD_CFG);\r\nmxc_iomux_set_pad(MX31_PIN_SD1_DATA2, MMC_PAD_CFG);\r\nmxc_iomux_set_pad(MX31_PIN_SD1_DATA3, MMC_PAD_CFG);\r\nmxc_iomux_set_pad(MX31_PIN_SD1_CLK, MMC_PAD_CFG);\r\nmxc_iomux_set_pad(MX31_PIN_SD1_CMD, MMC_PAD_CFG);\r\nret = gpio_request(gpio_det, "MMC detect");\r\nif (ret)\r\nreturn ret;\r\nret = gpio_request(gpio_wp, "MMC w/p");\r\nif (ret)\r\ngoto exit_free_det;\r\ngpio_direction_input(gpio_det);\r\ngpio_direction_input(gpio_wp);\r\nret = request_irq(gpio_to_irq(IOMUX_TO_GPIO(MX31_PIN_GPIO1_1)),\r\ndetect_irq,\r\nIRQF_DISABLED | IRQF_TRIGGER_FALLING,\r\n"MMC detect", data);\r\nif (ret)\r\ngoto exit_free_wp;\r\nreturn 0;\r\nexit_free_wp:\r\ngpio_free(gpio_wp);\r\nexit_free_det:\r\ngpio_free(gpio_det);\r\nreturn ret;\r\n}\r\nstatic void mxc_mmc1_exit(struct device *dev, void *data)\r\n{\r\ngpio_free(gpio_det);\r\ngpio_free(gpio_wp);\r\nfree_irq(gpio_to_irq(IOMUX_TO_GPIO(MX31_PIN_GPIO1_1)), data);\r\n}\r\nstatic void __init mx31lilly_init_fb(void)\r\n{\r\nif (gpio_request(LCD_VCC_EN_GPIO, "LCD enable") != 0) {\r\nprintk(KERN_WARNING "unable to request LCD_VCC_EN pin.\n");\r\nreturn;\r\n}\r\nimx31_add_ipu_core();\r\nimx31_add_mx3_sdc_fb(&fb_pdata);\r\ngpio_direction_output(LCD_VCC_EN_GPIO, 1);\r\n}\r\nvoid __init mx31lilly_db_init(void)\r\n{\r\nmxc_iomux_setup_multiple_pins(lilly_db_board_pins,\r\nARRAY_SIZE(lilly_db_board_pins),\r\n"development board pins");\r\nimx31_add_imx_uart0(&uart_pdata);\r\nimx31_add_imx_uart1(&uart_pdata);\r\nimx31_add_imx_uart2(&uart_pdata);\r\nimx31_add_mxc_mmc(0, &mmc_pdata);\r\nmx31lilly_init_fb();\r\n}
