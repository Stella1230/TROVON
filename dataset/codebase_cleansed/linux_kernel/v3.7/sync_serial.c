static int __init etrax_sync_serial_init(void)\r\n{\r\nports[0].enabled = 0;\r\nports[1].enabled = 0;\r\n#if defined(CONFIG_ETRAX_SYNCHRONOUS_SERIAL_PORT0)\r\nif (cris_request_io_interface(if_sync_serial_1, "sync_ser1")) {\r\nprintk(KERN_CRIT "ETRAX100LX sync_serial: "\r\n"Could not allocate IO group for port %d\n", 0);\r\nreturn -EBUSY;\r\n}\r\n#endif\r\n#if defined(CONFIG_ETRAX_SYNCHRONOUS_SERIAL_PORT1)\r\nif (cris_request_io_interface(if_sync_serial_3, "sync_ser3")) {\r\n#if defined(CONFIG_ETRAX_SYNCHRONOUS_SERIAL_PORT0)\r\ncris_free_io_interface(if_sync_serial_1);\r\n#endif\r\nprintk(KERN_CRIT "ETRAX100LX sync_serial: "\r\n"Could not allocate IO group for port %d\n", 1);\r\nreturn -EBUSY;\r\n}\r\n#endif\r\nif (register_chrdev(SYNC_SERIAL_MAJOR, "sync serial",\r\n&sync_serial_fops) < 0) {\r\n#if defined(CONFIG_ETRAX_SYNCHRONOUS_SERIAL_PORT1)\r\ncris_free_io_interface(if_sync_serial_3);\r\n#endif\r\n#if defined(CONFIG_ETRAX_SYNCHRONOUS_SERIAL_PORT0)\r\ncris_free_io_interface(if_sync_serial_1);\r\n#endif\r\nprintk("unable to get major for synchronous serial port\n");\r\nreturn -EBUSY;\r\n}\r\nSETS(gen_config_ii_shadow, R_GEN_CONFIG_II, sermode1, async);\r\nSETS(gen_config_ii_shadow, R_GEN_CONFIG_II, sermode3, async);\r\n*R_GEN_CONFIG_II = gen_config_ii_shadow;\r\n#if defined(CONFIG_ETRAX_SYNCHRONOUS_SERIAL_PORT0)\r\nports[0].enabled = 1;\r\nSETS(port_pb_i2c_shadow, R_PORT_PB_I2C, syncser1, ss1extra);\r\nSETS(gen_config_ii_shadow, R_GEN_CONFIG_II, sermode1, sync);\r\n#if defined(CONFIG_ETRAX_SYNCHRONOUS_SERIAL0_DMA)\r\nports[0].use_dma = 1;\r\n#else\r\nports[0].use_dma = 0;\r\n#endif\r\ninitialize_port(0);\r\n#endif\r\n#if defined(CONFIG_ETRAX_SYNCHRONOUS_SERIAL_PORT1)\r\nports[1].enabled = 1;\r\nSETS(port_pb_i2c_shadow, R_PORT_PB_I2C, syncser3, ss3extra);\r\nSETS(gen_config_ii_shadow, R_GEN_CONFIG_II, sermode3, sync);\r\n#if defined(CONFIG_ETRAX_SYNCHRONOUS_SERIAL1_DMA)\r\nports[1].use_dma = 1;\r\n#else\r\nports[1].use_dma = 0;\r\n#endif\r\ninitialize_port(1);\r\n#endif\r\n*R_PORT_PB_I2C = port_pb_i2c_shadow;\r\n*R_SYNC_SERIAL_PRESCALE = sync_serial_prescale_shadow = (\r\nIO_STATE(R_SYNC_SERIAL_PRESCALE, clk_sel_u1, codec) |\r\nIO_STATE(R_SYNC_SERIAL_PRESCALE, word_stb_sel_u1, external) |\r\nIO_STATE(R_SYNC_SERIAL_PRESCALE, clk_sel_u3, codec) |\r\nIO_STATE(R_SYNC_SERIAL_PRESCALE, word_stb_sel_u3, external) |\r\nIO_STATE(R_SYNC_SERIAL_PRESCALE, prescaler, div4) |\r\nIO_FIELD(R_SYNC_SERIAL_PRESCALE, frame_rate,\r\nDEFAULT_FRAME_RATE) |\r\nIO_FIELD(R_SYNC_SERIAL_PRESCALE, word_rate, DEFAULT_WORD_RATE) |\r\nIO_STATE(R_SYNC_SERIAL_PRESCALE, warp_mode, normal));\r\n*R_GEN_CONFIG_II = gen_config_ii_shadow;\r\nprintk(KERN_INFO "ETRAX 100LX synchronous serial port driver\n");\r\nreturn 0;\r\n}\r\nstatic void __init initialize_port(int portnbr)\r\n{\r\nstruct sync_port *port = &ports[portnbr];\r\nDEBUG(printk(KERN_DEBUG "Init sync serial port %d\n", portnbr));\r\nport->started = 0;\r\nport->port_nbr = portnbr;\r\nport->busy = 0;\r\nport->tr_running = 0;\r\nport->out_count = 0;\r\nport->outp = port->out_buffer;\r\nport->readp = port->flip;\r\nport->writep = port->flip;\r\nport->in_buffer_size = IN_BUFFER_SIZE;\r\nport->inbufchunk = IN_DESCR_SIZE;\r\nport->next_rx_desc = &port->in_descr[0];\r\nport->prev_rx_desc = &port->in_descr[NUM_IN_DESCR-1];\r\nport->prev_rx_desc->ctrl = d_eol;\r\ninit_waitqueue_head(&port->out_wait_q);\r\ninit_waitqueue_head(&port->in_wait_q);\r\nport->ctrl_data_shadow =\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, tr_baud, c115k2Hz) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, mode, master_output) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, error, ignore) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, rec_enable, disable) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, f_synctype, normal) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, f_syncsize, word) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, f_sync, on) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, clk_mode, normal) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, clk_halt, stopped) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, bitorder, msb) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, tr_enable, disable) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, wordsize, size8bit) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, buf_empty, lmt_8) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, buf_full, lmt_8) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, flow_ctrl, enabled) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, clk_polarity, neg) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, frame_polarity, normal)|\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, status_polarity, inverted)|\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, clk_driver, normal) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, frame_driver, normal) |\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, status_driver, normal)|\r\nIO_STATE(R_SYNC_SERIAL1_CTRL, def_out0, high);\r\nif (port->use_dma)\r\nport->ctrl_data_shadow |= IO_STATE(R_SYNC_SERIAL1_CTRL,\r\ndma_enable, on);\r\nelse\r\nport->ctrl_data_shadow |= IO_STATE(R_SYNC_SERIAL1_CTRL,\r\ndma_enable, off);\r\n*port->ctrl_data = port->ctrl_data_shadow;\r\n}\r\nstatic inline int sync_data_avail(struct sync_port *port)\r\n{\r\nint avail;\r\nunsigned char *start;\r\nunsigned char *end;\r\nstart = (unsigned char *)port->readp;\r\nend = (unsigned char *)port->writep;\r\nif (end >= start)\r\navail = end - start;\r\nelse\r\navail = port->in_buffer_size - (start - end);\r\nreturn avail;\r\n}\r\nstatic inline int sync_data_avail_to_end(struct sync_port *port)\r\n{\r\nint avail;\r\nunsigned char *start;\r\nunsigned char *end;\r\nstart = (unsigned char *)port->readp;\r\nend = (unsigned char *)port->writep;\r\nif (end >= start)\r\navail = end - start;\r\nelse\r\navail = port->flip + port->in_buffer_size - start;\r\nreturn avail;\r\n}\r\nstatic int sync_serial_open(struct inode *inode, struct file *file)\r\n{\r\nint dev = MINOR(inode->i_rdev);\r\nstruct sync_port *port;\r\nint mode;\r\nint err = -EBUSY;\r\nmutex_lock(&sync_serial_mutex);\r\nDEBUG(printk(KERN_DEBUG "Open sync serial port %d\n", dev));\r\nif (dev < 0 || dev >= NUMBER_OF_PORTS || !ports[dev].enabled) {\r\nDEBUG(printk(KERN_DEBUG "Invalid minor %d\n", dev));\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nport = &ports[dev];\r\nif (port->busy == 2) {\r\nDEBUG(printk(KERN_DEBUG "Device is busy.. \n"));\r\ngoto out;\r\n}\r\nif (port->init_irqs) {\r\nif (port->use_dma) {\r\nif (port == &ports[0]) {\r\n#ifdef SYNC_SER_DMA\r\nif (request_irq(24, tr_interrupt, 0,\r\n"synchronous serial 1 dma tr",\r\n&ports[0])) {\r\nprintk(KERN_CRIT "Can't alloc "\r\n"sync serial port 1 IRQ");\r\ngoto out;\r\n} else if (request_irq(25, rx_interrupt, 0,\r\n"synchronous serial 1 dma rx",\r\n&ports[0])) {\r\nfree_irq(24, &port[0]);\r\nprintk(KERN_CRIT "Can't alloc "\r\n"sync serial port 1 IRQ");\r\ngoto out;\r\n} else if (cris_request_dma(8,\r\n"synchronous serial 1 dma tr",\r\nDMA_VERBOSE_ON_ERROR,\r\ndma_ser1)) {\r\nfree_irq(24, &port[0]);\r\nfree_irq(25, &port[0]);\r\nprintk(KERN_CRIT "Can't alloc "\r\n"sync serial port 1 "\r\n"TX DMA channel");\r\ngoto out;\r\n} else if (cris_request_dma(9,\r\n"synchronous serial 1 dma rec",\r\nDMA_VERBOSE_ON_ERROR,\r\ndma_ser1)) {\r\ncris_free_dma(8, NULL);\r\nfree_irq(24, &port[0]);\r\nfree_irq(25, &port[0]);\r\nprintk(KERN_CRIT "Can't alloc "\r\n"sync serial port 1 "\r\n"RX DMA channel");\r\ngoto out;\r\n}\r\n#endif\r\nRESET_DMA(8); WAIT_DMA(8);\r\nRESET_DMA(9); WAIT_DMA(9);\r\n*R_DMA_CH8_CLR_INTR =\r\nIO_STATE(R_DMA_CH8_CLR_INTR, clr_eop,\r\ndo) |\r\nIO_STATE(R_DMA_CH8_CLR_INTR, clr_descr,\r\ndo);\r\n*R_DMA_CH9_CLR_INTR =\r\nIO_STATE(R_DMA_CH9_CLR_INTR, clr_eop,\r\ndo) |\r\nIO_STATE(R_DMA_CH9_CLR_INTR, clr_descr,\r\ndo);\r\n*R_IRQ_MASK2_SET =\r\nIO_STATE(R_IRQ_MASK2_SET, dma8_eop,\r\nset) |\r\nIO_STATE(R_IRQ_MASK2_SET, dma9_descr,\r\nset);\r\n} else if (port == &ports[1]) {\r\n#ifdef SYNC_SER_DMA\r\nif (request_irq(20, tr_interrupt, 0,\r\n"synchronous serial 3 dma tr",\r\n&ports[1])) {\r\nprintk(KERN_CRIT "Can't alloc "\r\n"sync serial port 3 IRQ");\r\ngoto out;\r\n} else if (request_irq(21, rx_interrupt, 0,\r\n"synchronous serial 3 dma rx",\r\n&ports[1])) {\r\nfree_irq(20, &ports[1]);\r\nprintk(KERN_CRIT "Can't alloc "\r\n"sync serial port 3 IRQ");\r\ngoto out;\r\n} else if (cris_request_dma(4,\r\n"synchronous serial 3 dma tr",\r\nDMA_VERBOSE_ON_ERROR,\r\ndma_ser3)) {\r\nfree_irq(21, &ports[1]);\r\nfree_irq(20, &ports[1]);\r\nprintk(KERN_CRIT "Can't alloc "\r\n"sync serial port 3 "\r\n"TX DMA channel");\r\ngoto out;\r\n} else if (cris_request_dma(5,\r\n"synchronous serial 3 dma rec",\r\nDMA_VERBOSE_ON_ERROR,\r\ndma_ser3)) {\r\ncris_free_dma(4, NULL);\r\nfree_irq(21, &ports[1]);\r\nfree_irq(20, &ports[1]);\r\nprintk(KERN_CRIT "Can't alloc "\r\n"sync serial port 3 "\r\n"RX DMA channel");\r\ngoto out;\r\n}\r\n#endif\r\nRESET_DMA(4); WAIT_DMA(4);\r\nRESET_DMA(5); WAIT_DMA(5);\r\n*R_DMA_CH4_CLR_INTR =\r\nIO_STATE(R_DMA_CH4_CLR_INTR, clr_eop,\r\ndo) |\r\nIO_STATE(R_DMA_CH4_CLR_INTR, clr_descr,\r\ndo);\r\n*R_DMA_CH5_CLR_INTR =\r\nIO_STATE(R_DMA_CH5_CLR_INTR, clr_eop,\r\ndo) |\r\nIO_STATE(R_DMA_CH5_CLR_INTR, clr_descr,\r\ndo);\r\n*R_IRQ_MASK2_SET =\r\nIO_STATE(R_IRQ_MASK2_SET, dma4_eop,\r\nset) |\r\nIO_STATE(R_IRQ_MASK2_SET, dma5_descr,\r\nset);\r\n}\r\nstart_dma_in(port);\r\nport->init_irqs = 0;\r\n} else {\r\n#ifdef SYNC_SER_MANUAL\r\nif (port == &ports[0]) {\r\nif (request_irq(8,\r\nmanual_interrupt,\r\nIRQF_SHARED | IRQF_DISABLED,\r\n"synchronous serial manual irq",\r\n&ports[0])) {\r\nprintk(KERN_CRIT "Can't alloc "\r\n"sync serial manual irq");\r\ngoto out;\r\n}\r\n} else if (port == &ports[1]) {\r\nif (request_irq(8,\r\nmanual_interrupt,\r\nIRQF_SHARED | IRQF_DISABLED,\r\n"synchronous serial manual irq",\r\n&ports[1])) {\r\nprintk(KERN_CRIT "Can't alloc "\r\n"sync serial manual irq");\r\ngoto out;\r\n}\r\n}\r\nport->init_irqs = 0;\r\n#else\r\npanic("sync_serial: Manual mode not supported.\n");\r\n#endif\r\n}\r\n}\r\nport->busy++;\r\nmode = IO_EXTRACT(R_SYNC_SERIAL1_CTRL, mode, port->ctrl_data_shadow);\r\nif (mode == IO_STATE_VALUE(R_SYNC_SERIAL1_CTRL, mode, master_input) ||\r\nmode == IO_STATE_VALUE(R_SYNC_SERIAL1_CTRL, mode, slave_input) ||\r\nmode == IO_STATE_VALUE(R_SYNC_SERIAL1_CTRL, mode, master_bidir) ||\r\nmode == IO_STATE_VALUE(R_SYNC_SERIAL1_CTRL, mode, slave_bidir)) {\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, clk_halt,\r\nrunning);\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, tr_enable,\r\nenable);\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, rec_enable,\r\nenable);\r\nport->started = 1;\r\n*port->ctrl_data = port->ctrl_data_shadow;\r\nif (!port->use_dma)\r\n*R_IRQ_MASK1_SET = 1 << port->data_avail_bit;\r\nDEBUG(printk(KERN_DEBUG "sser%d rec started\n", dev));\r\n}\r\nerr = 0;\r\nout:\r\nmutex_unlock(&sync_serial_mutex);\r\nreturn err;\r\n}\r\nstatic int sync_serial_release(struct inode *inode, struct file *file)\r\n{\r\nint dev = MINOR(inode->i_rdev);\r\nstruct sync_port *port;\r\nif (dev < 0 || dev >= NUMBER_OF_PORTS || !ports[dev].enabled) {\r\nDEBUG(printk(KERN_DEBUG "Invalid minor %d\n", dev));\r\nreturn -ENODEV;\r\n}\r\nport = &ports[dev];\r\nif (port->busy)\r\nport->busy--;\r\nif (!port->busy)\r\n*R_IRQ_MASK1_CLR = ((1 << port->data_avail_bit) |\r\n(1 << port->transmitter_ready_bit));\r\nreturn 0;\r\n}\r\nstatic unsigned int sync_serial_poll(struct file *file, poll_table *wait)\r\n{\r\nint dev = MINOR(file->f_dentry->d_inode->i_rdev);\r\nunsigned int mask = 0;\r\nstruct sync_port *port;\r\nDEBUGPOLL(static unsigned int prev_mask = 0);\r\nport = &ports[dev];\r\npoll_wait(file, &port->out_wait_q, wait);\r\npoll_wait(file, &port->in_wait_q, wait);\r\nif (port->out_count < OUT_BUFFER_SIZE)\r\nmask |= POLLOUT | POLLWRNORM;\r\nif (sync_data_avail(port) >= port->inbufchunk)\r\nmask |= POLLIN | POLLRDNORM;\r\nDEBUGPOLL(if (mask != prev_mask)\r\nprintk(KERN_DEBUG "sync_serial_poll: mask 0x%08X %s %s\n",\r\nmask,\r\nmask & POLLOUT ? "POLLOUT" : "",\r\nmask & POLLIN ? "POLLIN" : "");\r\nprev_mask = mask;\r\n);\r\nreturn mask;\r\n}\r\nstatic int sync_serial_ioctl_unlocked(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint return_val = 0;\r\nunsigned long flags;\r\nint dev = MINOR(file->f_dentry->d_inode->i_rdev);\r\nstruct sync_port *port;\r\nif (dev < 0 || dev >= NUMBER_OF_PORTS || !ports[dev].enabled) {\r\nDEBUG(printk(KERN_DEBUG "Invalid minor %d\n", dev));\r\nreturn -1;\r\n}\r\nport = &ports[dev];\r\nlocal_irq_save(flags);\r\nif (dev) {\r\nif (port->use_dma) {\r\nRESET_DMA(4); WAIT_DMA(4);\r\nport->tr_running = 0;\r\nport->out_count = 0;\r\nport->outp = port->out_buffer;\r\n*R_DMA_CH4_CLR_INTR =\r\nIO_STATE(R_DMA_CH4_CLR_INTR, clr_eop, do) |\r\nIO_STATE(R_DMA_CH4_CLR_INTR, clr_descr, do);\r\n}\r\nSETS(gen_config_ii_shadow, R_GEN_CONFIG_II, sermode3, async);\r\n} else {\r\nif (port->use_dma) {\r\nRESET_DMA(8); WAIT_DMA(8);\r\nport->tr_running = 0;\r\nport->out_count = 0;\r\nport->outp = port->out_buffer;\r\n*R_DMA_CH8_CLR_INTR =\r\nIO_STATE(R_DMA_CH8_CLR_INTR, clr_eop, do) |\r\nIO_STATE(R_DMA_CH8_CLR_INTR, clr_descr, do);\r\n}\r\nSETS(gen_config_ii_shadow, R_GEN_CONFIG_II, sermode1, async);\r\n}\r\n*R_GEN_CONFIG_II = gen_config_ii_shadow;\r\nlocal_irq_restore(flags);\r\nswitch (cmd) {\r\ncase SSP_SPEED:\r\nif (GET_SPEED(arg) == CODEC) {\r\nif (dev)\r\nSETS(sync_serial_prescale_shadow,\r\nR_SYNC_SERIAL_PRESCALE, clk_sel_u3,\r\ncodec);\r\nelse\r\nSETS(sync_serial_prescale_shadow,\r\nR_SYNC_SERIAL_PRESCALE, clk_sel_u1,\r\ncodec);\r\nSETF(sync_serial_prescale_shadow,\r\nR_SYNC_SERIAL_PRESCALE, prescaler,\r\nGET_FREQ(arg));\r\nSETF(sync_serial_prescale_shadow,\r\nR_SYNC_SERIAL_PRESCALE, frame_rate,\r\nGET_FRAME_RATE(arg));\r\nSETF(sync_serial_prescale_shadow,\r\nR_SYNC_SERIAL_PRESCALE, word_rate,\r\nGET_WORD_RATE(arg));\r\n} else {\r\nSETF(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\ntr_baud, GET_SPEED(arg));\r\nif (dev)\r\nSETS(sync_serial_prescale_shadow,\r\nR_SYNC_SERIAL_PRESCALE, clk_sel_u3,\r\nbaudrate);\r\nelse\r\nSETS(sync_serial_prescale_shadow,\r\nR_SYNC_SERIAL_PRESCALE, clk_sel_u1,\r\nbaudrate);\r\n}\r\nbreak;\r\ncase SSP_MODE:\r\nif (arg > 5)\r\nreturn -EINVAL;\r\nif (arg == MASTER_OUTPUT || arg == SLAVE_OUTPUT)\r\n*R_IRQ_MASK1_CLR = 1 << port->data_avail_bit;\r\nelse if (!port->use_dma)\r\n*R_IRQ_MASK1_SET = 1 << port->data_avail_bit;\r\nSETF(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, mode, arg);\r\nbreak;\r\ncase SSP_FRAME_SYNC:\r\nif (arg & NORMAL_SYNC)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nf_synctype, normal);\r\nelse if (arg & EARLY_SYNC)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nf_synctype, early);\r\nif (arg & BIT_SYNC)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nf_syncsize, bit);\r\nelse if (arg & WORD_SYNC)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nf_syncsize, word);\r\nelse if (arg & EXTENDED_SYNC)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nf_syncsize, extended);\r\nif (arg & SYNC_ON)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nf_sync, on);\r\nelse if (arg & SYNC_OFF)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nf_sync, off);\r\nif (arg & WORD_SIZE_8)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nwordsize, size8bit);\r\nelse if (arg & WORD_SIZE_12)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nwordsize, size12bit);\r\nelse if (arg & WORD_SIZE_16)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nwordsize, size16bit);\r\nelse if (arg & WORD_SIZE_24)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nwordsize, size24bit);\r\nelse if (arg & WORD_SIZE_32)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nwordsize, size32bit);\r\nif (arg & BIT_ORDER_MSB)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nbitorder, msb);\r\nelse if (arg & BIT_ORDER_LSB)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nbitorder, lsb);\r\nif (arg & FLOW_CONTROL_ENABLE)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nflow_ctrl, enabled);\r\nelse if (arg & FLOW_CONTROL_DISABLE)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nflow_ctrl, disabled);\r\nif (arg & CLOCK_NOT_GATED)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nclk_mode, normal);\r\nelse if (arg & CLOCK_GATED)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nclk_mode, gated);\r\nbreak;\r\ncase SSP_IPOLARITY:\r\nif (arg & CLOCK_NORMAL)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nclk_polarity, neg);\r\nelse if (arg & CLOCK_INVERT)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nclk_polarity, pos);\r\nif (arg & FRAME_NORMAL)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nframe_polarity, normal);\r\nelse if (arg & FRAME_INVERT)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nframe_polarity, inverted);\r\nif (arg & STATUS_NORMAL)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nstatus_polarity, normal);\r\nelse if (arg & STATUS_INVERT)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nstatus_polarity, inverted);\r\nbreak;\r\ncase SSP_OPOLARITY:\r\nif (arg & CLOCK_NORMAL)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nclk_driver, normal);\r\nelse if (arg & CLOCK_INVERT)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nclk_driver, inverted);\r\nif (arg & FRAME_NORMAL)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nframe_driver, normal);\r\nelse if (arg & FRAME_INVERT)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nframe_driver, inverted);\r\nif (arg & STATUS_NORMAL)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nstatus_driver, normal);\r\nelse if (arg & STATUS_INVERT)\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nstatus_driver, inverted);\r\nbreak;\r\ncase SSP_SPI:\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, flow_ctrl,\r\ndisabled);\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, bitorder,\r\nmsb);\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, wordsize,\r\nsize8bit);\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, f_sync, on);\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, f_syncsize,\r\nword);\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, f_synctype,\r\nnormal);\r\nif (arg & SPI_SLAVE) {\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nframe_polarity, inverted);\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nclk_polarity, neg);\r\nSETF(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nmode, SLAVE_INPUT);\r\n} else {\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nframe_driver, inverted);\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nclk_driver, inverted);\r\nSETF(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL,\r\nmode, MASTER_OUTPUT);\r\n}\r\nbreak;\r\ncase SSP_INBUFCHUNK:\r\n#if 0\r\nif (arg > port->in_buffer_size/NUM_IN_DESCR)\r\nreturn -EINVAL;\r\nport->inbufchunk = arg;\r\nport->in_buffer_size =\r\n(port->in_buffer_size/port->inbufchunk) *\r\nport->inbufchunk;\r\nDEBUG(printk(KERN_DEBUG "inbufchunk %i in_buffer_size: %i\n",\r\nport->inbufchunk, port->in_buffer_size));\r\nif (port->use_dma) {\r\nif (port->port_nbr == 0) {\r\nRESET_DMA(9);\r\nWAIT_DMA(9);\r\n} else {\r\nRESET_DMA(5);\r\nWAIT_DMA(5);\r\n}\r\nstart_dma_in(port);\r\n}\r\n#endif\r\nbreak;\r\ndefault:\r\nreturn_val = -1;\r\n}\r\nlocal_irq_save(flags);\r\n*port->ctrl_data = port->ctrl_data_shadow;\r\nnop(); nop(); nop(); nop();\r\n*R_SYNC_SERIAL_PRESCALE = sync_serial_prescale_shadow;\r\nnop(); nop(); nop(); nop();\r\nif (dev)\r\nSETS(gen_config_ii_shadow, R_GEN_CONFIG_II, sermode3, sync);\r\nelse\r\nSETS(gen_config_ii_shadow, R_GEN_CONFIG_II, sermode1, sync);\r\n*R_GEN_CONFIG_II = gen_config_ii_shadow;\r\nif (port->use_dma) {\r\nif (port->port_nbr == 0) {\r\nRESET_DMA(9);\r\nWAIT_DMA(9);\r\n} else {\r\nRESET_DMA(5);\r\nWAIT_DMA(5);\r\n}\r\nstart_dma_in(port);\r\n}\r\nlocal_irq_restore(flags);\r\nreturn return_val;\r\n}\r\nstatic long sync_serial_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nlong ret;\r\nmutex_lock(&sync_serial_mutex);\r\nret = sync_serial_ioctl_unlocked(file, cmd, arg);\r\nmutex_unlock(&sync_serial_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t sync_serial_write(struct file *file, const char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint dev = MINOR(file->f_dentry->d_inode->i_rdev);\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct sync_port *port;\r\nunsigned long flags;\r\nunsigned long c, c1;\r\nunsigned long free_outp;\r\nunsigned long outp;\r\nunsigned long out_buffer;\r\nif (dev < 0 || dev >= NUMBER_OF_PORTS || !ports[dev].enabled) {\r\nDEBUG(printk(KERN_DEBUG "Invalid minor %d\n", dev));\r\nreturn -ENODEV;\r\n}\r\nport = &ports[dev];\r\nDEBUGWRITE(printk(KERN_DEBUG "W d%d c %lu (%d/%d)\n",\r\nport->port_nbr, count, port->out_count, OUT_BUFFER_SIZE));\r\nlocal_irq_save(flags);\r\nif (count > OUT_BUFFER_SIZE - port->out_count)\r\ncount = OUT_BUFFER_SIZE - port->out_count;\r\noutp = (unsigned long)port->outp;\r\nfree_outp = outp + port->out_count;\r\nlocal_irq_restore(flags);\r\nout_buffer = (unsigned long)port->out_buffer;\r\nif (free_outp >= out_buffer + OUT_BUFFER_SIZE)\r\nfree_outp -= OUT_BUFFER_SIZE;\r\nif (free_outp >= outp)\r\nc = out_buffer + OUT_BUFFER_SIZE - free_outp;\r\nelse\r\nc = outp - free_outp;\r\nif (c > count)\r\nc = count;\r\nDEBUGWRITE(printk(KERN_DEBUG "w op %08lX fop %08lX c %lu\n",\r\noutp, free_outp, c));\r\nif (copy_from_user((void *)free_outp, buf, c))\r\nreturn -EFAULT;\r\nif (c != count) {\r\nbuf += c;\r\nc1 = count - c;\r\nDEBUGWRITE(printk(KERN_DEBUG "w2 fi %lu c %lu c1 %lu\n",\r\nfree_outp-out_buffer, c, c1));\r\nif (copy_from_user((void *)out_buffer, buf, c1))\r\nreturn -EFAULT;\r\n}\r\nlocal_irq_save(flags);\r\nport->out_count += count;\r\nlocal_irq_restore(flags);\r\nif (!port->started) {\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, clk_halt,\r\nrunning);\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, tr_enable,\r\nenable);\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, rec_enable,\r\nenable);\r\nport->started = 1;\r\n}\r\n*port->ctrl_data = port->ctrl_data_shadow;\r\nif (file->f_flags & O_NONBLOCK) {\r\nlocal_irq_save(flags);\r\nif (!port->tr_running) {\r\nif (!port->use_dma) {\r\nsend_word(port);\r\n*R_IRQ_MASK1_SET = 1 <<\r\nport->transmitter_ready_bit;\r\n} else\r\nstart_dma(port,\r\n(unsigned char *volatile)port->outp, c);\r\n}\r\nlocal_irq_restore(flags);\r\nDEBUGWRITE(printk(KERN_DEBUG "w d%d c %lu NB\n",\r\nport->port_nbr, count));\r\nreturn count;\r\n}\r\nadd_wait_queue(&port->out_wait_q, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nlocal_irq_save(flags);\r\nif (!port->tr_running) {\r\nif (!port->use_dma) {\r\nsend_word(port);\r\n*R_IRQ_MASK1_SET = 1 << port->transmitter_ready_bit;\r\n} else\r\nstart_dma(port, port->outp, c);\r\n}\r\nlocal_irq_restore(flags);\r\nschedule();\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&port->out_wait_q, &wait);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nDEBUGWRITE(printk(KERN_DEBUG "w d%d c %lu\n", port->port_nbr, count));\r\nreturn count;\r\n}\r\nstatic ssize_t sync_serial_read(struct file *file, char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint dev = MINOR(file->f_dentry->d_inode->i_rdev);\r\nint avail;\r\nstruct sync_port *port;\r\nunsigned char *start;\r\nunsigned char *end;\r\nunsigned long flags;\r\nif (dev < 0 || dev >= NUMBER_OF_PORTS || !ports[dev].enabled) {\r\nDEBUG(printk(KERN_DEBUG "Invalid minor %d\n", dev));\r\nreturn -ENODEV;\r\n}\r\nport = &ports[dev];\r\nDEBUGREAD(printk(KERN_DEBUG "R%d c %d ri %lu wi %lu /%lu\n",\r\ndev, count, port->readp - port->flip,\r\nport->writep - port->flip, port->in_buffer_size));\r\nif (!port->started) {\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, clk_halt,\r\nrunning);\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, tr_enable,\r\nenable);\r\nSETS(port->ctrl_data_shadow, R_SYNC_SERIAL1_CTRL, rec_enable,\r\nenable);\r\nport->started = 1;\r\n}\r\n*port->ctrl_data = port->ctrl_data_shadow;\r\nlocal_irq_save(flags);\r\nstart = (unsigned char *)port->readp;\r\nend = (unsigned char *)port->writep;\r\nlocal_irq_restore(flags);\r\nwhile (start == end && !port->full) {\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\ninterruptible_sleep_on(&port->in_wait_q);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nlocal_irq_save(flags);\r\nstart = (unsigned char *)port->readp;\r\nend = (unsigned char *)port->writep;\r\nlocal_irq_restore(flags);\r\n}\r\nif (port->full)\r\navail = port->in_buffer_size;\r\nelse if (end > start)\r\navail = end - start;\r\nelse\r\navail = port->flip + port->in_buffer_size - start;\r\ncount = count > avail ? avail : count;\r\nif (copy_to_user(buf, start, count))\r\nreturn -EFAULT;\r\nlocal_irq_save(flags);\r\nport->readp += count;\r\nif (port->readp >= port->flip + port->in_buffer_size)\r\nport->readp = port->flip;\r\nport->full = 0;\r\nlocal_irq_restore(flags);\r\nDEBUGREAD(printk(KERN_DEBUG "r %d\n", count));\r\nreturn count;\r\n}\r\nstatic void send_word(struct sync_port *port)\r\n{\r\nswitch (IO_EXTRACT(R_SYNC_SERIAL1_CTRL, wordsize,\r\nport->ctrl_data_shadow)) {\r\ncase IO_STATE_VALUE(R_SYNC_SERIAL1_CTRL, wordsize, size8bit):\r\nport->out_count--;\r\n*port->data_out = *port->outp++;\r\nif (port->outp >= port->out_buffer + OUT_BUFFER_SIZE)\r\nport->outp = port->out_buffer;\r\nbreak;\r\ncase IO_STATE_VALUE(R_SYNC_SERIAL1_CTRL, wordsize, size12bit):\r\n{\r\nint data = (*port->outp++) << 8;\r\ndata |= *port->outp++;\r\nport->out_count -= 2;\r\n*port->data_out = data;\r\nif (port->outp >= port->out_buffer + OUT_BUFFER_SIZE)\r\nport->outp = port->out_buffer;\r\nbreak;\r\n}\r\ncase IO_STATE_VALUE(R_SYNC_SERIAL1_CTRL, wordsize, size16bit):\r\nport->out_count -= 2;\r\n*port->data_out = *(unsigned short *)port->outp;\r\nport->outp += 2;\r\nif (port->outp >= port->out_buffer + OUT_BUFFER_SIZE)\r\nport->outp = port->out_buffer;\r\nbreak;\r\ncase IO_STATE_VALUE(R_SYNC_SERIAL1_CTRL, wordsize, size24bit):\r\nport->out_count -= 3;\r\n*port->data_out = *(unsigned int *)port->outp;\r\nport->outp += 3;\r\nif (port->outp >= port->out_buffer + OUT_BUFFER_SIZE)\r\nport->outp = port->out_buffer;\r\nbreak;\r\ncase IO_STATE_VALUE(R_SYNC_SERIAL1_CTRL, wordsize, size32bit):\r\nport->out_count -= 4;\r\n*port->data_out = *(unsigned int *)port->outp;\r\nport->outp += 4;\r\nif (port->outp >= port->out_buffer + OUT_BUFFER_SIZE)\r\nport->outp = port->out_buffer;\r\nbreak;\r\n}\r\n}\r\nstatic void start_dma(struct sync_port *port, const char *data, int count)\r\n{\r\nport->tr_running = 1;\r\nport->out_descr.hw_len = 0;\r\nport->out_descr.next = 0;\r\nport->out_descr.ctrl = d_eol | d_eop;\r\nport->out_descr.sw_len = count;\r\nport->out_descr.buf = virt_to_phys(data);\r\nport->out_descr.status = 0;\r\n*port->output_dma_first = virt_to_phys(&port->out_descr);\r\n*port->output_dma_cmd = IO_STATE(R_DMA_CH0_CMD, cmd, start);\r\nDEBUGTXINT(printk(KERN_DEBUG "dma %08lX c %d\n",\r\n(unsigned long)data, count));\r\n}\r\nstatic void start_dma_in(struct sync_port *port)\r\n{\r\nint i;\r\nunsigned long buf;\r\nport->writep = port->flip;\r\nif (port->writep > port->flip + port->in_buffer_size) {\r\npanic("Offset too large in sync serial driver\n");\r\nreturn;\r\n}\r\nbuf = virt_to_phys(port->in_buffer);\r\nfor (i = 0; i < NUM_IN_DESCR; i++) {\r\nport->in_descr[i].sw_len = port->inbufchunk;\r\nport->in_descr[i].ctrl = d_int;\r\nport->in_descr[i].next = virt_to_phys(&port->in_descr[i+1]);\r\nport->in_descr[i].buf = buf;\r\nport->in_descr[i].hw_len = 0;\r\nport->in_descr[i].status = 0;\r\nport->in_descr[i].fifo_len = 0;\r\nbuf += port->inbufchunk;\r\nprepare_rx_descriptor(&port->in_descr[i]);\r\n}\r\nport->in_descr[i-1].next = virt_to_phys(&port->in_descr[0]);\r\nport->in_descr[i-1].ctrl |= d_eol;\r\nport->next_rx_desc = &port->in_descr[0];\r\nport->prev_rx_desc = &port->in_descr[NUM_IN_DESCR - 1];\r\n*port->input_dma_first = virt_to_phys(port->next_rx_desc);\r\n*port->input_dma_cmd = IO_STATE(R_DMA_CH0_CMD, cmd, start);\r\n}\r\nstatic irqreturn_t tr_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned long ireg = *R_IRQ_MASK2_RD;\r\nstruct etrax_dma_descr *descr;\r\nunsigned int sentl;\r\nint handled = 0;\r\nint i;\r\nfor (i = 0; i < NUMBER_OF_PORTS; i++) {\r\nstruct sync_port *port = &ports[i];\r\nif (!port->enabled || !port->use_dma)\r\ncontinue;\r\nif (!(ireg & (1 << port->output_dma_bit)))\r\ncontinue;\r\nhandled = 1;\r\n*port->output_dma_clr_irq =\r\nIO_STATE(R_DMA_CH0_CLR_INTR, clr_eop, do) |\r\nIO_STATE(R_DMA_CH0_CLR_INTR, clr_descr, do);\r\ndescr = &port->out_descr;\r\nif (!(descr->status & d_stop))\r\nsentl = descr->sw_len;\r\nelse\r\nsentl = descr->hw_len;\r\nport->out_count -= sentl;\r\nport->outp += sentl;\r\nif (port->outp >= port->out_buffer + OUT_BUFFER_SIZE)\r\nport->outp = port->out_buffer;\r\nif (port->out_count) {\r\nint c = port->out_buffer + OUT_BUFFER_SIZE - port->outp;\r\nif (c > port->out_count)\r\nc = port->out_count;\r\nDEBUGTXINT(printk(KERN_DEBUG\r\n"tx_int DMAWRITE %i %i\n", sentl, c));\r\nstart_dma(port, port->outp, c);\r\n} else {\r\nDEBUGTXINT(printk(KERN_DEBUG\r\n"tx_int DMA stop %i\n", sentl));\r\nport->tr_running = 0;\r\n}\r\nwake_up_interruptible(&port->out_wait_q);\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic irqreturn_t rx_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned long ireg = *R_IRQ_MASK2_RD;\r\nint i;\r\nint handled = 0;\r\nfor (i = 0; i < NUMBER_OF_PORTS; i++) {\r\nstruct sync_port *port = &ports[i];\r\nif (!port->enabled || !port->use_dma)\r\ncontinue;\r\nif (!(ireg & (1 << port->input_dma_descr_bit)))\r\ncontinue;\r\nhandled = 1;\r\nwhile (*port->input_dma_descr !=\r\nvirt_to_phys(port->next_rx_desc)) {\r\nif (port->writep + port->inbufchunk > port->flip +\r\nport->in_buffer_size) {\r\nint first_size = port->flip +\r\nport->in_buffer_size - port->writep;\r\nmemcpy(port->writep,\r\nphys_to_virt(port->next_rx_desc->buf),\r\nfirst_size);\r\nmemcpy(port->flip,\r\nphys_to_virt(port->next_rx_desc->buf +\r\nfirst_size),\r\nport->inbufchunk - first_size);\r\nport->writep = port->flip +\r\nport->inbufchunk - first_size;\r\n} else {\r\nmemcpy(port->writep,\r\nphys_to_virt(port->next_rx_desc->buf),\r\nport->inbufchunk);\r\nport->writep += port->inbufchunk;\r\nif (port->writep >= port->flip\r\n+ port->in_buffer_size)\r\nport->writep = port->flip;\r\n}\r\nif (port->writep == port->readp)\r\nport->full = 1;\r\nprepare_rx_descriptor(port->next_rx_desc);\r\nport->next_rx_desc->ctrl |= d_eol;\r\nport->prev_rx_desc->ctrl &= ~d_eol;\r\nport->prev_rx_desc = phys_to_virt((unsigned)\r\nport->next_rx_desc);\r\nport->next_rx_desc = phys_to_virt((unsigned)\r\nport->next_rx_desc->next);\r\nwake_up_interruptible(&port->in_wait_q);\r\n*port->input_dma_cmd = IO_STATE(R_DMA_CH1_CMD,\r\ncmd, restart);\r\n*port->input_dma_clr_irq = IO_STATE(R_DMA_CH0_CLR_INTR,\r\nclr_descr, do);\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic irqreturn_t manual_interrupt(int irq, void *dev_id)\r\n{\r\nint i;\r\nint handled = 0;\r\nfor (i = 0; i < NUMBER_OF_PORTS; i++) {\r\nstruct sync_port *port = &ports[i];\r\nif (!port->enabled || port->use_dma)\r\ncontinue;\r\nif (*R_IRQ_MASK1_RD & (1 << port->data_avail_bit)) {\r\nhandled = 1;\r\nswitch (port->ctrl_data_shadow &\r\nIO_MASK(R_SYNC_SERIAL1_CTRL, wordsize)) {\r\ncase IO_STATE(R_SYNC_SERIAL1_CTRL, wordsize, size8bit):\r\n*port->writep++ =\r\n*(volatile char *)port->data_in;\r\nbreak;\r\ncase IO_STATE(R_SYNC_SERIAL1_CTRL, wordsize, size12bit):\r\n{\r\nint data = *(unsigned short *)port->data_in;\r\n*port->writep = (data & 0x0ff0) >> 4;\r\n*(port->writep + 1) = data & 0x0f;\r\nport->writep += 2;\r\nbreak;\r\n}\r\ncase IO_STATE(R_SYNC_SERIAL1_CTRL, wordsize, size16bit):\r\n*(unsigned short *)port->writep =\r\n*(volatile unsigned short *)port->data_in;\r\nport->writep += 2;\r\nbreak;\r\ncase IO_STATE(R_SYNC_SERIAL1_CTRL, wordsize, size24bit):\r\n*(unsigned int *)port->writep = *port->data_in;\r\nport->writep += 3;\r\nbreak;\r\ncase IO_STATE(R_SYNC_SERIAL1_CTRL, wordsize, size32bit):\r\n*(unsigned int *)port->writep = *port->data_in;\r\nport->writep += 4;\r\nbreak;\r\n}\r\nif (port->writep >= port->flip + port->in_buffer_size)\r\nport->writep = port->flip;\r\nif (port->writep == port->readp) {\r\nport->readp++;\r\nif (port->readp >= port->flip +\r\nport->in_buffer_size)\r\nport->readp = port->flip;\r\n}\r\nif (sync_data_avail(port) >= port->inbufchunk) {\r\nwake_up_interruptible(&port->in_wait_q);\r\n}\r\n}\r\nif (*R_IRQ_MASK1_RD & (1 << port->transmitter_ready_bit)) {\r\nif (port->out_count > 0) {\r\nsend_word(port);\r\n} else {\r\n*R_IRQ_MASK1_CLR = 1 <<\r\nport->transmitter_ready_bit;\r\nwake_up_interruptible(&port->out_wait_q);\r\n}\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}
