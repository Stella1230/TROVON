static int\r\nmk_conf_addr(struct pci_bus *bus_dev, unsigned int device_fn, int where,\r\nunsigned long *pci_addr, unsigned char *type1)\r\n{\r\nu8 bus = bus_dev->number;\r\n*type1 = (bus != 0);\r\n*pci_addr = (bus << 16) | (device_fn << 8) | where;\r\nDBGC(("mk_conf_addr(bus=%d ,device_fn=0x%x, where=0x%x,"\r\n" returning address 0x%p\n"\r\nbus, device_fn, where, *pci_addr));\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nconf_read(unsigned long addr, unsigned char type1)\r\n{\r\nunsigned long flags;\r\nint stat0, value;\r\nint cia_cfg = 0;\r\nDBGC(("conf_read(addr=0x%lx, type1=%d) ", addr, type1));\r\nlocal_irq_save(flags);\r\nstat0 = *(vip)CIA_IOC_CIA_ERR;\r\n*(vip)CIA_IOC_CIA_ERR = stat0;\r\nmb();\r\n*(vip)CIA_IOC_CIA_ERR;\r\nif (type1) {\r\ncia_cfg = *(vip)CIA_IOC_CFG;\r\n*(vip)CIA_IOC_CFG = (cia_cfg & ~3) | 1;\r\nmb();\r\n*(vip)CIA_IOC_CFG;\r\n}\r\nmb();\r\ndraina();\r\nmcheck_expected(0) = 1;\r\nmcheck_taken(0) = 0;\r\nmb();\r\nvalue = *(vip)addr;\r\nmb();\r\nmb();\r\nif (mcheck_taken(0)) {\r\nmcheck_taken(0) = 0;\r\nvalue = 0xffffffff;\r\nmb();\r\n}\r\nmcheck_expected(0) = 0;\r\nmb();\r\nif (type1) {\r\n*(vip)CIA_IOC_CFG = cia_cfg;\r\nmb();\r\n*(vip)CIA_IOC_CFG;\r\n}\r\nlocal_irq_restore(flags);\r\nDBGC(("done\n"));\r\nreturn value;\r\n}\r\nstatic void\r\nconf_write(unsigned long addr, unsigned int value, unsigned char type1)\r\n{\r\nunsigned long flags;\r\nint stat0, cia_cfg = 0;\r\nDBGC(("conf_write(addr=0x%lx, type1=%d) ", addr, type1));\r\nlocal_irq_save(flags);\r\nstat0 = *(vip)CIA_IOC_CIA_ERR;\r\n*(vip)CIA_IOC_CIA_ERR = stat0;\r\nmb();\r\n*(vip)CIA_IOC_CIA_ERR;\r\nif (type1) {\r\ncia_cfg = *(vip)CIA_IOC_CFG;\r\n*(vip)CIA_IOC_CFG = (cia_cfg & ~3) | 1;\r\nmb();\r\n*(vip)CIA_IOC_CFG;\r\n}\r\nmb();\r\ndraina();\r\nmcheck_expected(0) = 1;\r\nmcheck_taken(0) = 0;\r\nmb();\r\n*(vip)addr = value;\r\nmb();\r\n*(vip)addr;\r\nmcheck_expected(0) = 0;\r\nmb();\r\nif (type1) {\r\n*(vip)CIA_IOC_CFG = cia_cfg;\r\nmb();\r\n*(vip)CIA_IOC_CFG;\r\n}\r\nlocal_irq_restore(flags);\r\nDBGC(("done\n"));\r\n}\r\nstatic int\r\ncia_read_config(struct pci_bus *bus, unsigned int devfn, int where, int size,\r\nu32 *value)\r\n{\r\nunsigned long addr, pci_addr;\r\nlong mask;\r\nunsigned char type1;\r\nint shift;\r\nif (mk_conf_addr(bus, devfn, where, &pci_addr, &type1))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nmask = (size - 1) * 8;\r\nshift = (where & 3) * 8;\r\naddr = (pci_addr << 5) + mask + CIA_CONF;\r\n*value = conf_read(addr, type1) >> (shift);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\ncia_write_config(struct pci_bus *bus, unsigned int devfn, int where, int size,\r\nu32 value)\r\n{\r\nunsigned long addr, pci_addr;\r\nlong mask;\r\nunsigned char type1;\r\nif (mk_conf_addr(bus, devfn, where, &pci_addr, &type1))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nmask = (size - 1) * 8;\r\naddr = (pci_addr << 5) + mask + CIA_CONF;\r\nconf_write(addr, value << ((where & 3) * 8), type1);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nvoid\r\ncia_pci_tbi(struct pci_controller *hose, dma_addr_t start, dma_addr_t end)\r\n{\r\nwmb();\r\n*(vip)CIA_IOC_PCI_TBIA = 3;\r\nmb();\r\n*(vip)CIA_IOC_PCI_TBIA;\r\n}\r\nvoid\r\ncia_pci_tbi_try2(struct pci_controller *hose,\r\ndma_addr_t start, dma_addr_t end)\r\n{\r\nvoid __iomem *bus_addr;\r\nint ctrl;\r\nmb();\r\nctrl = *(vip)CIA_IOC_CIA_CTRL;\r\n*(vip)CIA_IOC_CIA_CTRL = ctrl | CIA_CTRL_PCI_LOOP_EN;\r\nmb();\r\n*(vip)CIA_IOC_CIA_CTRL;\r\nmb();\r\nbus_addr = cia_ioremap(CIA_BROKEN_TBIA_BASE, 32768 * 4);\r\ncia_readl(bus_addr + 0x00000);\r\ncia_readl(bus_addr + 0x08000);\r\ncia_readl(bus_addr + 0x10000);\r\ncia_readl(bus_addr + 0x18000);\r\ncia_iounmap(bus_addr);\r\nmb();\r\n*(vip)CIA_IOC_CIA_CTRL = ctrl;\r\nmb();\r\n*(vip)CIA_IOC_CIA_CTRL;\r\nmb();\r\n}\r\nstatic inline void\r\ncia_prepare_tbia_workaround(int window)\r\n{\r\nunsigned long *ppte, pte;\r\nlong i;\r\nppte = __alloc_bootmem(CIA_BROKEN_TBIA_SIZE, 32768, 0);\r\npte = (virt_to_phys(ppte) >> (PAGE_SHIFT - 1)) | 1;\r\nfor (i = 0; i < CIA_BROKEN_TBIA_SIZE / sizeof(unsigned long); ++i)\r\nppte[i] = pte;\r\n*(vip)CIA_IOC_PCI_Wn_BASE(window) = CIA_BROKEN_TBIA_BASE | 3;\r\n*(vip)CIA_IOC_PCI_Wn_MASK(window)\r\n= (CIA_BROKEN_TBIA_SIZE*1024 - 1) & 0xfff00000;\r\n*(vip)CIA_IOC_PCI_Tn_BASE(window) = virt_to_phys(ppte) >> 2;\r\n}\r\nstatic void __init\r\nverify_tb_operation(void)\r\n{\r\nstatic int page[PAGE_SIZE/4]\r\n__attribute__((aligned(PAGE_SIZE)))\r\n__initdata = { 0 };\r\nstruct pci_iommu_arena *arena = pci_isa_hose->sg_isa;\r\nint ctrl, addr0, tag0, pte0, data0;\r\nint temp, use_tbia_try2 = 0;\r\nvoid __iomem *bus_addr;\r\nif (pci_isa_hose->dense_io_base)\r\nuse_tbia_try2 = 1;\r\nmb();\r\nctrl = *(vip)CIA_IOC_CIA_CTRL;\r\n*(vip)CIA_IOC_CIA_CTRL = ctrl | CIA_CTRL_PCI_LOOP_EN;\r\nmb();\r\n*(vip)CIA_IOC_CIA_CTRL;\r\nmb();\r\naddr0 = arena->dma_base;\r\ntag0 = addr0 | 1;\r\npte0 = (virt_to_phys(page) >> (PAGE_SHIFT - 1)) | 1;\r\n*(vip)CIA_IOC_TB_TAGn(0) = tag0;\r\n*(vip)CIA_IOC_TB_TAGn(1) = 0;\r\n*(vip)CIA_IOC_TB_TAGn(2) = 0;\r\n*(vip)CIA_IOC_TB_TAGn(3) = 0;\r\n*(vip)CIA_IOC_TB_TAGn(4) = 0;\r\n*(vip)CIA_IOC_TB_TAGn(5) = 0;\r\n*(vip)CIA_IOC_TB_TAGn(6) = 0;\r\n*(vip)CIA_IOC_TB_TAGn(7) = 0;\r\n*(vip)CIA_IOC_TBn_PAGEm(0,0) = pte0;\r\n*(vip)CIA_IOC_TBn_PAGEm(0,1) = 0;\r\n*(vip)CIA_IOC_TBn_PAGEm(0,2) = 0;\r\n*(vip)CIA_IOC_TBn_PAGEm(0,3) = 0;\r\nmb();\r\nbus_addr = cia_ioremap(addr0, 8*PAGE_SIZE);\r\ntemp = *(vip)CIA_IOC_TB_TAGn(0);\r\nif (temp != tag0) {\r\nprintk("pci: failed tb register update test "\r\n"(tag0 %#x != %#x)\n", temp, tag0);\r\ngoto failed;\r\n}\r\ntemp = *(vip)CIA_IOC_TB_TAGn(1);\r\nif (temp != 0) {\r\nprintk("pci: failed tb register update test "\r\n"(tag1 %#x != 0)\n", temp);\r\ngoto failed;\r\n}\r\ntemp = *(vip)CIA_IOC_TBn_PAGEm(0,0);\r\nif (temp != pte0) {\r\nprintk("pci: failed tb register update test "\r\n"(pte0 %#x != %#x)\n", temp, pte0);\r\ngoto failed;\r\n}\r\nprintk("pci: passed tb register update test\n");\r\ndata0 = 0xdeadbeef;\r\npage[0] = data0;\r\nmcheck_expected(0) = 1;\r\nmcheck_taken(0) = 0;\r\nmb();\r\ntemp = cia_readl(bus_addr);\r\nmb();\r\nmcheck_expected(0) = 0;\r\nmb();\r\nif (mcheck_taken(0)) {\r\nprintk("pci: failed sg loopback i/o read test (mcheck)\n");\r\ngoto failed;\r\n}\r\nif (temp != data0) {\r\nprintk("pci: failed sg loopback i/o read test "\r\n"(%#x != %#x)\n", temp, data0);\r\ngoto failed;\r\n}\r\nprintk("pci: passed sg loopback i/o read test\n");\r\nif (! use_tbia_try2) {\r\ncia_pci_tbi(arena->hose, 0, -1);\r\ntemp = *(vip)CIA_IOC_TB_TAGn(0);\r\nif (temp & 1) {\r\nuse_tbia_try2 = 1;\r\nprintk("pci: failed tbia test; workaround available\n");\r\n} else {\r\nprintk("pci: passed tbia test\n");\r\n}\r\n}\r\ndata0 = 0x5adda15e;\r\npage[0] = data0;\r\narena->ptes[4] = pte0;\r\nmcheck_expected(0) = 1;\r\nmcheck_taken(0) = 0;\r\nmb();\r\ntemp = cia_readl(bus_addr + 4*PAGE_SIZE);\r\nmb();\r\nmcheck_expected(0) = 0;\r\nmb();\r\nif (mcheck_taken(0)) {\r\nprintk("pci: failed pte write cache snoop test (mcheck)\n");\r\ngoto failed;\r\n}\r\nif (temp != data0) {\r\nprintk("pci: failed pte write cache snoop test "\r\n"(%#x != %#x)\n", temp, data0);\r\ngoto failed;\r\n}\r\nprintk("pci: passed pte write cache snoop test\n");\r\ndata0 = 0xabcdef12;\r\npage[0] = data0;\r\narena->ptes[5] = pte0;\r\nmcheck_expected(0) = 1;\r\nmcheck_taken(0) = 0;\r\nmb();\r\ntemp = cia_readl(bus_addr + 5*PAGE_SIZE);\r\nmb();\r\nmcheck_expected(0) = 0;\r\nmb();\r\nif (mcheck_taken(0)) {\r\nprintk("pci: failed valid tag invalid pte reload test "\r\n"(mcheck; workaround available)\n");\r\narena->align_entry = 4;\r\n} else if (temp != data0) {\r\nprintk("pci: failed valid tag invalid pte reload test "\r\n"(%#x != %#x)\n", temp, data0);\r\ngoto failed;\r\n} else {\r\nprintk("pci: passed valid tag invalid pte reload test\n");\r\n}\r\nmcheck_expected(0) = 1;\r\nmcheck_taken(0) = 0;\r\nmb();\r\ntemp = cia_readl(bus_addr + 6*PAGE_SIZE);\r\nmb();\r\nmcheck_expected(0) = 0;\r\nmb();\r\nprintk("pci: %s pci machine check test\n",\r\nmcheck_taken(0) ? "passed" : "failed");\r\narena->ptes[4] = 0;\r\narena->ptes[5] = 0;\r\nif (use_tbia_try2) {\r\nalpha_mv.mv_pci_tbi = cia_pci_tbi_try2;\r\nwmb();\r\n*(vip)CIA_IOC_TB_TAGn(0) = 2;\r\n*(vip)CIA_IOC_TB_TAGn(1) = 2;\r\n*(vip)CIA_IOC_TB_TAGn(2) = 2;\r\n*(vip)CIA_IOC_TB_TAGn(3) = 2;\r\nprintk("pci: tbia workaround enabled\n");\r\n}\r\nalpha_mv.mv_pci_tbi(arena->hose, 0, -1);\r\nexit:\r\ncia_iounmap(bus_addr);\r\nmb();\r\n*(vip)CIA_IOC_CIA_CTRL = ctrl;\r\nmb();\r\n*(vip)CIA_IOC_CIA_CTRL;\r\nmb();\r\nreturn;\r\nfailed:\r\nprintk("pci: disabling sg translation window\n");\r\n*(vip)CIA_IOC_PCI_W0_BASE = 0;\r\n*(vip)CIA_IOC_PCI_W1_BASE = 0;\r\npci_isa_hose->sg_isa = NULL;\r\nalpha_mv.mv_pci_tbi = NULL;\r\ngoto exit;\r\n}\r\nvoid\r\ncia_save_srm_settings(int is_pyxis)\r\n{\r\nint i;\r\nsaved_config.err_mask = *(vip)CIA_IOC_ERR_MASK;\r\nsaved_config.cia_ctrl = *(vip)CIA_IOC_CIA_CTRL;\r\nsaved_config.hae_mem = *(vip)CIA_IOC_HAE_MEM;\r\nsaved_config.hae_io = *(vip)CIA_IOC_HAE_IO;\r\nsaved_config.pci_dac_offset = *(vip)CIA_IOC_PCI_W_DAC;\r\nif (is_pyxis)\r\nsaved_config.cia_cnfg = *(vip)CIA_IOC_CIA_CNFG;\r\nelse\r\nsaved_config.cia_cnfg = 0;\r\nfor (i = 0; i < 4; i++) {\r\nsaved_config.window[i].w_base = *(vip)CIA_IOC_PCI_Wn_BASE(i);\r\nsaved_config.window[i].w_mask = *(vip)CIA_IOC_PCI_Wn_MASK(i);\r\nsaved_config.window[i].t_base = *(vip)CIA_IOC_PCI_Tn_BASE(i);\r\n}\r\nmb();\r\n}\r\nvoid\r\ncia_restore_srm_settings(void)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\n*(vip)CIA_IOC_PCI_Wn_BASE(i) = saved_config.window[i].w_base;\r\n*(vip)CIA_IOC_PCI_Wn_MASK(i) = saved_config.window[i].w_mask;\r\n*(vip)CIA_IOC_PCI_Tn_BASE(i) = saved_config.window[i].t_base;\r\n}\r\n*(vip)CIA_IOC_HAE_MEM = saved_config.hae_mem;\r\n*(vip)CIA_IOC_HAE_IO = saved_config.hae_io;\r\n*(vip)CIA_IOC_PCI_W_DAC = saved_config.pci_dac_offset;\r\n*(vip)CIA_IOC_ERR_MASK = saved_config.err_mask;\r\n*(vip)CIA_IOC_CIA_CTRL = saved_config.cia_ctrl;\r\nif (saved_config.cia_cnfg)\r\n*(vip)CIA_IOC_CIA_CNFG = saved_config.cia_cnfg;\r\nmb();\r\n}\r\nstatic void __init\r\ndo_init_arch(int is_pyxis)\r\n{\r\nstruct pci_controller *hose;\r\nint temp, cia_rev, tbia_window;\r\ncia_rev = *(vip)CIA_IOC_CIA_REV & CIA_REV_MASK;\r\nprintk("pci: cia revision %d%s\n",\r\ncia_rev, is_pyxis ? " (pyxis)" : "");\r\nif (alpha_using_srm)\r\ncia_save_srm_settings(is_pyxis);\r\ntemp = *(vip)CIA_IOC_ERR_MASK;\r\ntemp &= ~(CIA_ERR_CPU_PE | CIA_ERR_MEM_NEM | CIA_ERR_PA_PTE_INV\r\n| CIA_ERR_RCVD_MAS_ABT | CIA_ERR_RCVD_TAR_ABT);\r\n*(vip)CIA_IOC_ERR_MASK = temp;\r\ntemp = *(vip)CIA_IOC_CIA_ERR;\r\n*(vip)CIA_IOC_CIA_ERR = temp;\r\ntemp = *(vip)CIA_IOC_CIA_CTRL;\r\ntemp |= CIA_CTRL_FILL_ERR_EN | CIA_CTRL_MCHK_ERR_EN;\r\n*(vip)CIA_IOC_CIA_CTRL = temp;\r\n*(vip)CIA_IOC_CFG = 0;\r\n*(vip)CIA_IOC_HAE_MEM = 0;\r\n*(vip)CIA_IOC_HAE_IO = 0;\r\nif (is_pyxis) {\r\ntemp = *(vip)CIA_IOC_CIA_CNFG;\r\ntemp |= CIA_CNFG_IOA_BWEN | CIA_CNFG_PCI_MWEN;\r\n*(vip)CIA_IOC_CIA_CNFG = temp;\r\n}\r\nmb();\r\n*(vip)CIA_IOC_CIA_REV;\r\npci_isa_hose = hose = alloc_pci_controller();\r\nhose->io_space = &ioport_resource;\r\nhose->mem_space = &iomem_resource;\r\nhose->index = 0;\r\nif (! is_pyxis) {\r\nstruct resource *hae_mem = alloc_resource();\r\nhose->mem_space = hae_mem;\r\nhae_mem->start = 0;\r\nhae_mem->end = CIA_MEM_R1_MASK;\r\nhae_mem->name = pci_hae0_name;\r\nhae_mem->flags = IORESOURCE_MEM;\r\nif (request_resource(&iomem_resource, hae_mem) < 0)\r\nprintk(KERN_ERR "Failed to request HAE_MEM\n");\r\nhose->sparse_mem_base = CIA_SPARSE_MEM - IDENT_ADDR;\r\nhose->dense_mem_base = CIA_DENSE_MEM - IDENT_ADDR;\r\nhose->sparse_io_base = CIA_IO - IDENT_ADDR;\r\nhose->dense_io_base = 0;\r\n} else {\r\nhose->sparse_mem_base = 0;\r\nhose->dense_mem_base = CIA_BW_MEM - IDENT_ADDR;\r\nhose->sparse_io_base = 0;\r\nhose->dense_io_base = CIA_BW_IO - IDENT_ADDR;\r\n}\r\nhose->sg_pci = NULL;\r\nhose->sg_isa = iommu_arena_new(hose, 0x00800000, 0x00800000, 32768);\r\n__direct_map_base = 0x80000000;\r\n__direct_map_size = 0x80000000;\r\n*(vip)CIA_IOC_PCI_W0_BASE = hose->sg_isa->dma_base | 3;\r\n*(vip)CIA_IOC_PCI_W0_MASK = (hose->sg_isa->size - 1) & 0xfff00000;\r\n*(vip)CIA_IOC_PCI_T0_BASE = virt_to_phys(hose->sg_isa->ptes) >> 2;\r\n*(vip)CIA_IOC_PCI_W2_BASE = __direct_map_base | 1;\r\n*(vip)CIA_IOC_PCI_W2_MASK = (__direct_map_size - 1) & 0xfff00000;\r\n*(vip)CIA_IOC_PCI_T2_BASE = 0 >> 2;\r\ntbia_window = 1;\r\nif (is_pyxis) {\r\n*(vip)CIA_IOC_PCI_W3_BASE = 0;\r\n} else if (cia_rev == 1) {\r\n*(vip)CIA_IOC_PCI_W1_BASE = 0;\r\ntbia_window = 3;\r\n} else if (max_low_pfn > (0x100000000UL >> PAGE_SHIFT)) {\r\n*(vip)CIA_IOC_PCI_W3_BASE = 0;\r\n} else {\r\n*(vip)CIA_IOC_PCI_W3_BASE = 0x00000000 | 1 | 8;\r\n*(vip)CIA_IOC_PCI_W3_MASK = 0xfff00000;\r\n*(vip)CIA_IOC_PCI_T3_BASE = 0 >> 2;\r\nalpha_mv.pci_dac_offset = 0x200000000UL;\r\n*(vip)CIA_IOC_PCI_W_DAC = alpha_mv.pci_dac_offset >> 32;\r\n}\r\ncia_prepare_tbia_workaround(tbia_window);\r\n}\r\nvoid __init\r\ncia_init_arch(void)\r\n{\r\ndo_init_arch(0);\r\n}\r\nvoid __init\r\npyxis_init_arch(void)\r\n{\r\nunsigned int cc0, cc1;\r\nunsigned long pyxis_cc;\r\n__asm__ __volatile__ ("rpcc %0" : "=r"(cc0));\r\npyxis_cc = *(vulp)PYXIS_RT_COUNT;\r\ndo { } while(*(vulp)PYXIS_RT_COUNT - pyxis_cc < 4096);\r\n__asm__ __volatile__ ("rpcc %0" : "=r"(cc1));\r\ncc1 -= cc0;\r\nhwrpb->cycle_freq = ((cc1 >> 11) * 100000000UL) / 3;\r\nhwrpb_update_checksum(hwrpb);\r\ndo_init_arch(1);\r\n}\r\nvoid\r\ncia_kill_arch(int mode)\r\n{\r\nif (alpha_using_srm)\r\ncia_restore_srm_settings();\r\n}\r\nvoid __init\r\ncia_init_pci(void)\r\n{\r\nverify_tb_operation();\r\ncommon_init_pci();\r\n}\r\nstatic inline void\r\ncia_pci_clr_err(void)\r\n{\r\nint jd;\r\njd = *(vip)CIA_IOC_CIA_ERR;\r\n*(vip)CIA_IOC_CIA_ERR = jd;\r\nmb();\r\n*(vip)CIA_IOC_CIA_ERR;\r\n}\r\nstatic void\r\ncia_decode_pci_error(struct el_CIA_sysdata_mcheck *cia, const char *msg)\r\n{\r\nstatic const char * const pci_cmd_desc[16] = {\r\n"Interrupt Acknowledge", "Special Cycle", "I/O Read",\r\n"I/O Write", "Reserved 0x4", "Reserved 0x5", "Memory Read",\r\n"Memory Write", "Reserved 0x8", "Reserved 0x9",\r\n"Configuration Read", "Configuration Write",\r\n"Memory Read Multiple", "Dual Address Cycle",\r\n"Memory Read Line", "Memory Write and Invalidate"\r\n};\r\nif (cia->cia_err & (CIA_ERR_COR_ERR\r\n| CIA_ERR_UN_COR_ERR\r\n| CIA_ERR_MEM_NEM\r\n| CIA_ERR_PA_PTE_INV)) {\r\nstatic const char * const window_desc[6] = {\r\n"No window active", "Window 0 hit", "Window 1 hit",\r\n"Window 2 hit", "Window 3 hit", "Monster window hit"\r\n};\r\nconst char *window;\r\nconst char *cmd;\r\nunsigned long addr, tmp;\r\nint lock, dac;\r\ncmd = pci_cmd_desc[cia->pci_err0 & 0x7];\r\nlock = (cia->pci_err0 >> 4) & 1;\r\ndac = (cia->pci_err0 >> 5) & 1;\r\ntmp = (cia->pci_err0 >> 8) & 0x1F;\r\ntmp = ffs(tmp);\r\nwindow = window_desc[tmp];\r\naddr = cia->pci_err1;\r\nif (dac) {\r\ntmp = *(vip)CIA_IOC_PCI_W_DAC & 0xFFUL;\r\naddr |= tmp << 32;\r\n}\r\nprintk(KERN_CRIT "CIA machine check: %s\n", msg);\r\nprintk(KERN_CRIT " DMA command: %s\n", cmd);\r\nprintk(KERN_CRIT " PCI address: %#010lx\n", addr);\r\nprintk(KERN_CRIT " %s, Lock: %d, DAC: %d\n",\r\nwindow, lock, dac);\r\n} else if (cia->cia_err & (CIA_ERR_PERR\r\n| CIA_ERR_PCI_ADDR_PE\r\n| CIA_ERR_RCVD_MAS_ABT\r\n| CIA_ERR_RCVD_TAR_ABT\r\n| CIA_ERR_IOA_TIMEOUT)) {\r\nstatic const char * const master_st_desc[16] = {\r\n"Idle", "Drive bus", "Address step cycle",\r\n"Address cycle", "Data cycle", "Last read data cycle",\r\n"Last write data cycle", "Read stop cycle",\r\n"Write stop cycle", "Read turnaround cycle",\r\n"Write turnaround cycle", "Reserved 0xB",\r\n"Reserved 0xC", "Reserved 0xD", "Reserved 0xE",\r\n"Unknown state"\r\n};\r\nstatic const char * const target_st_desc[16] = {\r\n"Idle", "Busy", "Read data cycle", "Write data cycle",\r\n"Read stop cycle", "Write stop cycle",\r\n"Read turnaround cycle", "Write turnaround cycle",\r\n"Read wait cycle", "Write wait cycle",\r\n"Reserved 0xA", "Reserved 0xB", "Reserved 0xC",\r\n"Reserved 0xD", "Reserved 0xE", "Unknown state"\r\n};\r\nconst char *cmd;\r\nconst char *master, *target;\r\nunsigned long addr, tmp;\r\nint dac;\r\nmaster = master_st_desc[(cia->pci_err0 >> 16) & 0xF];\r\ntarget = target_st_desc[(cia->pci_err0 >> 20) & 0xF];\r\ncmd = pci_cmd_desc[(cia->pci_err0 >> 24) & 0xF];\r\ndac = (cia->pci_err0 >> 28) & 1;\r\naddr = cia->pci_err2;\r\nif (dac) {\r\ntmp = *(volatile int *)CIA_IOC_PCI_W_DAC & 0xFFUL;\r\naddr |= tmp << 32;\r\n}\r\nprintk(KERN_CRIT "CIA machine check: %s\n", msg);\r\nprintk(KERN_CRIT " PCI command: %s\n", cmd);\r\nprintk(KERN_CRIT " Master state: %s, Target state: %s\n",\r\nmaster, target);\r\nprintk(KERN_CRIT " PCI address: %#010lx, DAC: %d\n",\r\naddr, dac);\r\n} else {\r\nprintk(KERN_CRIT "CIA machine check: %s\n", msg);\r\nprintk(KERN_CRIT " Unknown PCI error\n");\r\nprintk(KERN_CRIT " PCI_ERR0 = %#08lx", cia->pci_err0);\r\nprintk(KERN_CRIT " PCI_ERR1 = %#08lx", cia->pci_err1);\r\nprintk(KERN_CRIT " PCI_ERR2 = %#08lx", cia->pci_err2);\r\n}\r\n}\r\nstatic void\r\ncia_decode_mem_error(struct el_CIA_sysdata_mcheck *cia, const char *msg)\r\n{\r\nunsigned long mem_port_addr;\r\nunsigned long mem_port_mask;\r\nconst char *mem_port_cmd;\r\nconst char *seq_state;\r\nconst char *set_select;\r\nunsigned long tmp;\r\nif ((cia->mem_err1 >> 20) & 1)\r\ncia_decode_pci_error(cia, msg);\r\nelse\r\nprintk(KERN_CRIT "CIA machine check: %s\n", msg);\r\nmem_port_addr = cia->mem_err0 & 0xfffffff0;\r\nmem_port_addr |= (cia->mem_err1 & 0x83UL) << 32;\r\nmem_port_mask = (cia->mem_err1 >> 12) & 0xF;\r\ntmp = (cia->mem_err1 >> 8) & 0xF;\r\ntmp |= ((cia->mem_err1 >> 20) & 1) << 4;\r\nif ((tmp & 0x1E) == 0x06)\r\nmem_port_cmd = "WRITE BLOCK or WRITE BLOCK LOCK";\r\nelse if ((tmp & 0x1C) == 0x08)\r\nmem_port_cmd = "READ MISS or READ MISS MODIFY";\r\nelse if (tmp == 0x1C)\r\nmem_port_cmd = "BC VICTIM";\r\nelse if ((tmp & 0x1E) == 0x0E)\r\nmem_port_cmd = "READ MISS MODIFY";\r\nelse if ((tmp & 0x1C) == 0x18)\r\nmem_port_cmd = "DMA READ or DMA READ MODIFY";\r\nelse if ((tmp & 0x1E) == 0x12)\r\nmem_port_cmd = "DMA WRITE";\r\nelse\r\nmem_port_cmd = "Unknown";\r\ntmp = (cia->mem_err1 >> 16) & 0xF;\r\nswitch (tmp) {\r\ncase 0x0:\r\nseq_state = "Idle";\r\nbreak;\r\ncase 0x1:\r\nseq_state = "DMA READ or DMA WRITE";\r\nbreak;\r\ncase 0x2: case 0x3:\r\nseq_state = "READ MISS (or READ MISS MODIFY) with victim";\r\nbreak;\r\ncase 0x4: case 0x5: case 0x6:\r\nseq_state = "READ MISS (or READ MISS MODIFY) with no victim";\r\nbreak;\r\ncase 0x8: case 0x9: case 0xB:\r\nseq_state = "Refresh";\r\nbreak;\r\ncase 0xC:\r\nseq_state = "Idle, waiting for DMA pending read";\r\nbreak;\r\ncase 0xE: case 0xF:\r\nseq_state = "Idle, ras precharge";\r\nbreak;\r\ndefault:\r\nseq_state = "Unknown";\r\nbreak;\r\n}\r\ntmp = (cia->mem_err1 >> 24) & 0x1F;\r\nswitch (tmp) {\r\ncase 0x00: set_select = "Set 0 selected"; break;\r\ncase 0x01: set_select = "Set 1 selected"; break;\r\ncase 0x02: set_select = "Set 2 selected"; break;\r\ncase 0x03: set_select = "Set 3 selected"; break;\r\ncase 0x04: set_select = "Set 4 selected"; break;\r\ncase 0x05: set_select = "Set 5 selected"; break;\r\ncase 0x06: set_select = "Set 6 selected"; break;\r\ncase 0x07: set_select = "Set 7 selected"; break;\r\ncase 0x08: set_select = "Set 8 selected"; break;\r\ncase 0x09: set_select = "Set 9 selected"; break;\r\ncase 0x0A: set_select = "Set A selected"; break;\r\ncase 0x0B: set_select = "Set B selected"; break;\r\ncase 0x0C: set_select = "Set C selected"; break;\r\ncase 0x0D: set_select = "Set D selected"; break;\r\ncase 0x0E: set_select = "Set E selected"; break;\r\ncase 0x0F: set_select = "Set F selected"; break;\r\ncase 0x10: set_select = "No set selected"; break;\r\ncase 0x1F: set_select = "Refresh cycle"; break;\r\ndefault: set_select = "Unknown"; break;\r\n}\r\nprintk(KERN_CRIT " Memory port command: %s\n", mem_port_cmd);\r\nprintk(KERN_CRIT " Memory port address: %#010lx, mask: %#lx\n",\r\nmem_port_addr, mem_port_mask);\r\nprintk(KERN_CRIT " Memory sequencer state: %s\n", seq_state);\r\nprintk(KERN_CRIT " Memory set: %s\n", set_select);\r\n}\r\nstatic void\r\ncia_decode_ecc_error(struct el_CIA_sysdata_mcheck *cia, const char *msg)\r\n{\r\nlong syn;\r\nlong i;\r\nconst char *fmt;\r\ncia_decode_mem_error(cia, msg);\r\nsyn = cia->cia_syn & 0xff;\r\nif (syn == (syn & -syn)) {\r\nfmt = KERN_CRIT " ECC syndrome %#x -- check bit %d\n";\r\ni = ffs(syn) - 1;\r\n} else {\r\nstatic unsigned char const data_bit[64] = {\r\n0xCE, 0xCB, 0xD3, 0xD5,\r\n0xD6, 0xD9, 0xDA, 0xDC,\r\n0x23, 0x25, 0x26, 0x29,\r\n0x2A, 0x2C, 0x31, 0x34,\r\n0x0E, 0x0B, 0x13, 0x15,\r\n0x16, 0x19, 0x1A, 0x1C,\r\n0xE3, 0xE5, 0xE6, 0xE9,\r\n0xEA, 0xEC, 0xF1, 0xF4,\r\n0x4F, 0x4A, 0x52, 0x54,\r\n0x57, 0x58, 0x5B, 0x5D,\r\n0xA2, 0xA4, 0xA7, 0xA8,\r\n0xAB, 0xAD, 0xB0, 0xB5,\r\n0x8F, 0x8A, 0x92, 0x94,\r\n0x97, 0x98, 0x9B, 0x9D,\r\n0x62, 0x64, 0x67, 0x68,\r\n0x6B, 0x6D, 0x70, 0x75\r\n};\r\nfor (i = 0; i < 64; ++i)\r\nif (data_bit[i] == syn)\r\nbreak;\r\nif (i < 64)\r\nfmt = KERN_CRIT " ECC syndrome %#x -- data bit %d\n";\r\nelse\r\nfmt = KERN_CRIT " ECC syndrome %#x -- unknown bit\n";\r\n}\r\nprintk (fmt, syn, i);\r\n}\r\nstatic void\r\ncia_decode_parity_error(struct el_CIA_sysdata_mcheck *cia)\r\n{\r\nstatic const char * const cmd_desc[16] = {\r\n"NOP", "LOCK", "FETCH", "FETCH_M", "MEMORY BARRIER",\r\n"SET DIRTY", "WRITE BLOCK", "WRITE BLOCK LOCK",\r\n"READ MISS0", "READ MISS1", "READ MISS MOD0",\r\n"READ MISS MOD1", "BCACHE VICTIM", "Spare",\r\n"READ MISS MOD STC0", "READ MISS MOD STC1"\r\n};\r\nunsigned long addr;\r\nunsigned long mask;\r\nconst char *cmd;\r\nint par;\r\naddr = cia->cpu_err0 & 0xfffffff0;\r\naddr |= (cia->cpu_err1 & 0x83UL) << 32;\r\ncmd = cmd_desc[(cia->cpu_err1 >> 8) & 0xF];\r\nmask = (cia->cpu_err1 >> 12) & 0xF;\r\npar = (cia->cpu_err1 >> 21) & 1;\r\nprintk(KERN_CRIT "CIA machine check: System bus parity error\n");\r\nprintk(KERN_CRIT " Command: %s, Parity bit: %d\n", cmd, par);\r\nprintk(KERN_CRIT " Address: %#010lx, Mask: %#lx\n", addr, mask);\r\n}\r\nstatic int\r\ncia_decode_mchk(unsigned long la_ptr)\r\n{\r\nstruct el_common *com;\r\nstruct el_CIA_sysdata_mcheck *cia;\r\ncom = (void *)la_ptr;\r\ncia = (void *)(la_ptr + com->sys_offset);\r\nif ((cia->cia_err & CIA_ERR_VALID) == 0)\r\nreturn 0;\r\n#ifdef CONFIG_VERBOSE_MCHECK\r\nif (!alpha_verbose_mcheck)\r\nreturn 1;\r\nswitch (ffs(cia->cia_err & 0xfff) - 1) {\r\ncase 0:\r\ncia_decode_ecc_error(cia, "Corrected ECC error");\r\nbreak;\r\ncase 1:\r\ncia_decode_ecc_error(cia, "Uncorrected ECC error");\r\nbreak;\r\ncase 2:\r\ncia_decode_parity_error(cia);\r\nbreak;\r\ncase 3:\r\ncia_decode_mem_error(cia, "Access to nonexistent memory");\r\nbreak;\r\ncase 4:\r\ncia_decode_pci_error(cia, "PCI bus system error");\r\nbreak;\r\ncase 5:\r\ncia_decode_pci_error(cia, "PCI data parity error");\r\nbreak;\r\ncase 6:\r\ncia_decode_pci_error(cia, "PCI address parity error");\r\nbreak;\r\ncase 7:\r\ncia_decode_pci_error(cia, "PCI master abort");\r\nbreak;\r\ncase 8:\r\ncia_decode_pci_error(cia, "PCI target abort");\r\nbreak;\r\ncase 9:\r\ncia_decode_pci_error(cia, "PCI invalid PTE");\r\nbreak;\r\ncase 10:\r\ncia_decode_mem_error(cia, "Write to flash ROM attempted");\r\nbreak;\r\ncase 11:\r\ncia_decode_pci_error(cia, "I/O timeout");\r\nbreak;\r\n}\r\nif (cia->cia_err & CIA_ERR_LOST_CORR_ERR)\r\nprintk(KERN_CRIT "CIA lost machine check: "\r\n"Correctable ECC error\n");\r\nif (cia->cia_err & CIA_ERR_LOST_UN_CORR_ERR)\r\nprintk(KERN_CRIT "CIA lost machine check: "\r\n"Uncorrectable ECC error\n");\r\nif (cia->cia_err & CIA_ERR_LOST_CPU_PE)\r\nprintk(KERN_CRIT "CIA lost machine check: "\r\n"System bus parity error\n");\r\nif (cia->cia_err & CIA_ERR_LOST_MEM_NEM)\r\nprintk(KERN_CRIT "CIA lost machine check: "\r\n"Access to nonexistent memory\n");\r\nif (cia->cia_err & CIA_ERR_LOST_PERR)\r\nprintk(KERN_CRIT "CIA lost machine check: "\r\n"PCI data parity error\n");\r\nif (cia->cia_err & CIA_ERR_LOST_PCI_ADDR_PE)\r\nprintk(KERN_CRIT "CIA lost machine check: "\r\n"PCI address parity error\n");\r\nif (cia->cia_err & CIA_ERR_LOST_RCVD_MAS_ABT)\r\nprintk(KERN_CRIT "CIA lost machine check: "\r\n"PCI master abort\n");\r\nif (cia->cia_err & CIA_ERR_LOST_RCVD_TAR_ABT)\r\nprintk(KERN_CRIT "CIA lost machine check: "\r\n"PCI target abort\n");\r\nif (cia->cia_err & CIA_ERR_LOST_PA_PTE_INV)\r\nprintk(KERN_CRIT "CIA lost machine check: "\r\n"PCI invalid PTE\n");\r\nif (cia->cia_err & CIA_ERR_LOST_FROM_WRT_ERR)\r\nprintk(KERN_CRIT "CIA lost machine check: "\r\n"Write to flash ROM attempted\n");\r\nif (cia->cia_err & CIA_ERR_LOST_IOA_TIMEOUT)\r\nprintk(KERN_CRIT "CIA lost machine check: "\r\n"I/O timeout\n");\r\n#endif\r\nreturn 1;\r\n}\r\nvoid\r\ncia_machine_check(unsigned long vector, unsigned long la_ptr)\r\n{\r\nint expected;\r\nmb();\r\nmb();\r\ndraina();\r\ncia_pci_clr_err();\r\nwrmces(rdmces());\r\nmb();\r\nexpected = mcheck_expected(0);\r\nif (!expected && vector == 0x660)\r\nexpected = cia_decode_mchk(la_ptr);\r\nprocess_mcheck_info(vector, la_ptr, "CIA", expected);\r\n}
