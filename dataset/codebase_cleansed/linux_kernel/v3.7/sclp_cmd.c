static int __init sclp_cmd_sync_early(sclp_cmdw_t cmd, void *sccb)\r\n{\r\nint rc;\r\n__ctl_set_bit(0, 9);\r\nrc = sclp_service_call(cmd, sccb);\r\nif (rc)\r\ngoto out;\r\n__load_psw_mask(PSW_DEFAULT_KEY | PSW_MASK_BASE | PSW_MASK_EA |\r\nPSW_MASK_BA | PSW_MASK_EXT | PSW_MASK_WAIT);\r\nlocal_irq_disable();\r\nout:\r\nbarrier();\r\n__ctl_clear_bit(0, 9);\r\nreturn rc;\r\n}\r\nstatic void __init sclp_read_info_early(void)\r\n{\r\nint rc;\r\nint i;\r\nstruct read_info_sccb *sccb;\r\nsclp_cmdw_t commands[] = {SCLP_CMDW_READ_SCP_INFO_FORCED,\r\nSCLP_CMDW_READ_SCP_INFO};\r\nsccb = &early_read_info_sccb;\r\nfor (i = 0; i < ARRAY_SIZE(commands); i++) {\r\ndo {\r\nmemset(sccb, 0, sizeof(*sccb));\r\nsccb->header.length = sizeof(*sccb);\r\nsccb->header.function_code = 0x80;\r\nsccb->header.control_mask[2] = 0x80;\r\nrc = sclp_cmd_sync_early(commands[i], sccb);\r\n} while (rc == -EBUSY);\r\nif (rc)\r\nbreak;\r\nif (sccb->header.response_code == 0x10) {\r\nearly_read_info_sccb_valid = 1;\r\nbreak;\r\n}\r\nif (sccb->header.response_code != 0x1f0)\r\nbreak;\r\n}\r\n}\r\nstatic void __init sclp_event_mask_early(void)\r\n{\r\nstruct init_sccb *sccb = &early_event_mask_sccb;\r\nint rc;\r\ndo {\r\nmemset(sccb, 0, sizeof(*sccb));\r\nsccb->header.length = sizeof(*sccb);\r\nsccb->mask_length = sizeof(sccb_mask_t);\r\nrc = sclp_cmd_sync_early(SCLP_CMDW_WRITE_EVENT_MASK, sccb);\r\n} while (rc == -EBUSY);\r\n}\r\nvoid __init sclp_facilities_detect(void)\r\n{\r\nstruct read_info_sccb *sccb;\r\nsclp_read_info_early();\r\nif (!early_read_info_sccb_valid)\r\nreturn;\r\nsccb = &early_read_info_sccb;\r\nsclp_facilities = sccb->facilities;\r\nsclp_fac84 = sccb->fac84;\r\nsclp_fac85 = sccb->fac85;\r\nrnmax = sccb->rnmax ? sccb->rnmax : sccb->rnmax2;\r\nrzm = sccb->rnsize ? sccb->rnsize : sccb->rnsize2;\r\nrzm <<= 20;\r\nsclp_event_mask_early();\r\n}\r\nbool __init sclp_has_linemode(void)\r\n{\r\nstruct init_sccb *sccb = &early_event_mask_sccb;\r\nif (sccb->header.response_code != 0x20)\r\nreturn 0;\r\nif (sccb->sclp_send_mask & (EVTYP_MSG_MASK | EVTYP_PMSGCMD_MASK))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nbool __init sclp_has_vt220(void)\r\n{\r\nstruct init_sccb *sccb = &early_event_mask_sccb;\r\nif (sccb->header.response_code != 0x20)\r\nreturn 0;\r\nif (sccb->sclp_send_mask & EVTYP_VT220MSG_MASK)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nunsigned long long sclp_get_rnmax(void)\r\n{\r\nreturn rnmax;\r\n}\r\nunsigned long long sclp_get_rzm(void)\r\n{\r\nreturn rzm;\r\n}\r\nu8 sclp_get_fac85(void)\r\n{\r\nreturn sclp_fac85;\r\n}\r\nvoid __init sclp_get_ipl_info(struct sclp_ipl_info *info)\r\n{\r\nstruct read_info_sccb *sccb;\r\nif (!early_read_info_sccb_valid)\r\nreturn;\r\nsccb = &early_read_info_sccb;\r\ninfo->is_valid = 1;\r\nif (sccb->flags & 0x2)\r\ninfo->has_dump = 1;\r\nmemcpy(&info->loadparm, &sccb->loadparm, LOADPARM_LEN);\r\n}\r\nstatic void sclp_sync_callback(struct sclp_req *req, void *data)\r\n{\r\nstruct completion *completion = data;\r\ncomplete(completion);\r\n}\r\nstatic int do_sync_request(sclp_cmdw_t cmd, void *sccb)\r\n{\r\nstruct completion completion;\r\nstruct sclp_req *request;\r\nint rc;\r\nrequest = kzalloc(sizeof(*request), GFP_KERNEL);\r\nif (!request)\r\nreturn -ENOMEM;\r\nrequest->command = cmd;\r\nrequest->sccb = sccb;\r\nrequest->status = SCLP_REQ_FILLED;\r\nrequest->callback = sclp_sync_callback;\r\nrequest->callback_data = &completion;\r\ninit_completion(&completion);\r\nrc = sclp_add_request(request);\r\nif (rc)\r\ngoto out;\r\nwait_for_completion(&completion);\r\nif (request->status != SCLP_REQ_DONE) {\r\npr_warning("sync request failed (cmd=0x%08x, "\r\n"status=0x%02x)\n", cmd, request->status);\r\nrc = -EIO;\r\n}\r\nout:\r\nkfree(request);\r\nreturn rc;\r\n}\r\nstatic void sclp_fill_cpu_info(struct sclp_cpu_info *info,\r\nstruct read_cpu_info_sccb *sccb)\r\n{\r\nchar *page = (char *) sccb;\r\nmemset(info, 0, sizeof(*info));\r\ninfo->configured = sccb->nr_configured;\r\ninfo->standby = sccb->nr_standby;\r\ninfo->combined = sccb->nr_configured + sccb->nr_standby;\r\ninfo->has_cpu_type = sclp_fac84 & 0x1;\r\nmemcpy(&info->cpu, page + sccb->offset_configured,\r\ninfo->combined * sizeof(struct sclp_cpu_entry));\r\n}\r\nint sclp_get_cpu_info(struct sclp_cpu_info *info)\r\n{\r\nint rc;\r\nstruct read_cpu_info_sccb *sccb;\r\nif (!SCLP_HAS_CPU_INFO)\r\nreturn -EOPNOTSUPP;\r\nsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\nreturn -ENOMEM;\r\nsccb->header.length = sizeof(*sccb);\r\nrc = do_sync_request(SCLP_CMDW_READ_CPU_INFO, sccb);\r\nif (rc)\r\ngoto out;\r\nif (sccb->header.response_code != 0x0010) {\r\npr_warning("readcpuinfo failed (response=0x%04x)\n",\r\nsccb->header.response_code);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nsclp_fill_cpu_info(info, sccb);\r\nout:\r\nfree_page((unsigned long) sccb);\r\nreturn rc;\r\n}\r\nstatic int do_cpu_configure(sclp_cmdw_t cmd)\r\n{\r\nstruct cpu_configure_sccb *sccb;\r\nint rc;\r\nif (!SCLP_HAS_CPU_RECONFIG)\r\nreturn -EOPNOTSUPP;\r\nsccb = kzalloc(sizeof(*sccb), GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\nreturn -ENOMEM;\r\nsccb->header.length = sizeof(*sccb);\r\nrc = do_sync_request(cmd, sccb);\r\nif (rc)\r\ngoto out;\r\nswitch (sccb->header.response_code) {\r\ncase 0x0020:\r\ncase 0x0120:\r\nbreak;\r\ndefault:\r\npr_warning("configure cpu failed (cmd=0x%08x, "\r\n"response=0x%04x)\n", cmd,\r\nsccb->header.response_code);\r\nrc = -EIO;\r\nbreak;\r\n}\r\nout:\r\nkfree(sccb);\r\nreturn rc;\r\n}\r\nint sclp_cpu_configure(u8 cpu)\r\n{\r\nreturn do_cpu_configure(SCLP_CMDW_CONFIGURE_CPU | cpu << 8);\r\n}\r\nint sclp_cpu_deconfigure(u8 cpu)\r\n{\r\nreturn do_cpu_configure(SCLP_CMDW_DECONFIGURE_CPU | cpu << 8);\r\n}\r\nint arch_get_memory_phys_device(unsigned long start_pfn)\r\n{\r\nif (!rzm)\r\nreturn 0;\r\nreturn PFN_PHYS(start_pfn) >> ilog2(rzm);\r\n}\r\nstatic unsigned long long rn2addr(u16 rn)\r\n{\r\nreturn (unsigned long long) (rn - 1) * rzm;\r\n}\r\nstatic int do_assign_storage(sclp_cmdw_t cmd, u16 rn)\r\n{\r\nstruct assign_storage_sccb *sccb;\r\nint rc;\r\nsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\nreturn -ENOMEM;\r\nsccb->header.length = PAGE_SIZE;\r\nsccb->rn = rn;\r\nrc = do_sync_request(cmd, sccb);\r\nif (rc)\r\ngoto out;\r\nswitch (sccb->header.response_code) {\r\ncase 0x0020:\r\ncase 0x0120:\r\nbreak;\r\ndefault:\r\npr_warning("assign storage failed (cmd=0x%08x, "\r\n"response=0x%04x, rn=0x%04x)\n", cmd,\r\nsccb->header.response_code, rn);\r\nrc = -EIO;\r\nbreak;\r\n}\r\nout:\r\nfree_page((unsigned long) sccb);\r\nreturn rc;\r\n}\r\nstatic int sclp_assign_storage(u16 rn)\r\n{\r\nunsigned long long start, address;\r\nint rc;\r\nrc = do_assign_storage(0x000d0001, rn);\r\nif (rc)\r\ngoto out;\r\nstart = address = rn2addr(rn);\r\nfor (; address < start + rzm; address += PAGE_SIZE)\r\npage_set_storage_key(address, PAGE_DEFAULT_KEY, 0);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int sclp_unassign_storage(u16 rn)\r\n{\r\nreturn do_assign_storage(0x000c0001, rn);\r\n}\r\nstatic int sclp_attach_storage(u8 id)\r\n{\r\nstruct attach_storage_sccb *sccb;\r\nint rc;\r\nint i;\r\nsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\nreturn -ENOMEM;\r\nsccb->header.length = PAGE_SIZE;\r\nrc = do_sync_request(0x00080001 | id << 8, sccb);\r\nif (rc)\r\ngoto out;\r\nswitch (sccb->header.response_code) {\r\ncase 0x0020:\r\nset_bit(id, sclp_storage_ids);\r\nfor (i = 0; i < sccb->assigned; i++) {\r\nif (sccb->entries[i])\r\nsclp_unassign_storage(sccb->entries[i] >> 16);\r\n}\r\nbreak;\r\ndefault:\r\nrc = -EIO;\r\nbreak;\r\n}\r\nout:\r\nfree_page((unsigned long) sccb);\r\nreturn rc;\r\n}\r\nstatic int sclp_mem_change_state(unsigned long start, unsigned long size,\r\nint online)\r\n{\r\nstruct memory_increment *incr;\r\nunsigned long long istart;\r\nint rc = 0;\r\nlist_for_each_entry(incr, &sclp_mem_list, list) {\r\nistart = rn2addr(incr->rn);\r\nif (start + size - 1 < istart)\r\nbreak;\r\nif (start > istart + rzm - 1)\r\ncontinue;\r\nif (online) {\r\nif (incr->usecount++)\r\ncontinue;\r\nrc |= sclp_assign_storage(incr->rn);\r\n} else {\r\nif (--incr->usecount)\r\ncontinue;\r\nsclp_unassign_storage(incr->rn);\r\n}\r\n}\r\nreturn rc ? -EIO : 0;\r\n}\r\nstatic int sclp_mem_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nunsigned long start, size;\r\nstruct memory_notify *arg;\r\nunsigned char id;\r\nint rc = 0;\r\narg = data;\r\nstart = arg->start_pfn << PAGE_SHIFT;\r\nsize = arg->nr_pages << PAGE_SHIFT;\r\nmutex_lock(&sclp_mem_mutex);\r\nfor_each_clear_bit(id, sclp_storage_ids, sclp_max_storage_id + 1)\r\nsclp_attach_storage(id);\r\nswitch (action) {\r\ncase MEM_ONLINE:\r\ncase MEM_GOING_OFFLINE:\r\ncase MEM_CANCEL_OFFLINE:\r\nbreak;\r\ncase MEM_GOING_ONLINE:\r\nrc = sclp_mem_change_state(start, size, 1);\r\nbreak;\r\ncase MEM_CANCEL_ONLINE:\r\nsclp_mem_change_state(start, size, 0);\r\nbreak;\r\ncase MEM_OFFLINE:\r\nsclp_mem_change_state(start, size, 0);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nif (!rc)\r\nsclp_mem_state_changed = 1;\r\nmutex_unlock(&sclp_mem_mutex);\r\nreturn rc ? NOTIFY_BAD : NOTIFY_OK;\r\n}\r\nstatic void __init add_memory_merged(u16 rn)\r\n{\r\nstatic u16 first_rn, num;\r\nunsigned long long start, size;\r\nif (rn && first_rn && (first_rn + num == rn)) {\r\nnum++;\r\nreturn;\r\n}\r\nif (!first_rn)\r\ngoto skip_add;\r\nstart = rn2addr(first_rn);\r\nsize = (unsigned long long ) num * rzm;\r\nif (start >= VMEM_MAX_PHYS)\r\ngoto skip_add;\r\nif (start + size > VMEM_MAX_PHYS)\r\nsize = VMEM_MAX_PHYS - start;\r\nif (memory_end_set && (start >= memory_end))\r\ngoto skip_add;\r\nif (memory_end_set && (start + size > memory_end))\r\nsize = memory_end - start;\r\nadd_memory(0, start, size);\r\nskip_add:\r\nfirst_rn = rn;\r\nnum = 1;\r\n}\r\nstatic void __init sclp_add_standby_memory(void)\r\n{\r\nstruct memory_increment *incr;\r\nlist_for_each_entry(incr, &sclp_mem_list, list)\r\nif (incr->standby)\r\nadd_memory_merged(incr->rn);\r\nadd_memory_merged(0);\r\n}\r\nstatic void __init insert_increment(u16 rn, int standby, int assigned)\r\n{\r\nstruct memory_increment *incr, *new_incr;\r\nstruct list_head *prev;\r\nu16 last_rn;\r\nnew_incr = kzalloc(sizeof(*new_incr), GFP_KERNEL);\r\nif (!new_incr)\r\nreturn;\r\nnew_incr->rn = rn;\r\nnew_incr->standby = standby;\r\nif (!standby)\r\nnew_incr->usecount = 1;\r\nlast_rn = 0;\r\nprev = &sclp_mem_list;\r\nlist_for_each_entry(incr, &sclp_mem_list, list) {\r\nif (assigned && incr->rn > rn)\r\nbreak;\r\nif (!assigned && incr->rn - last_rn > 1)\r\nbreak;\r\nlast_rn = incr->rn;\r\nprev = &incr->list;\r\n}\r\nif (!assigned)\r\nnew_incr->rn = last_rn + 1;\r\nif (new_incr->rn > rnmax) {\r\nkfree(new_incr);\r\nreturn;\r\n}\r\nlist_add(&new_incr->list, prev);\r\n}\r\nstatic int sclp_mem_freeze(struct device *dev)\r\n{\r\nif (!sclp_mem_state_changed)\r\nreturn 0;\r\npr_err("Memory hotplug state changed, suspend refused.\n");\r\nreturn -EPERM;\r\n}\r\nstatic int __init sclp_detect_standby_memory(void)\r\n{\r\nstruct platform_device *sclp_pdev;\r\nstruct read_storage_sccb *sccb;\r\nint i, id, assigned, rc;\r\nif (!early_read_info_sccb_valid)\r\nreturn 0;\r\nif ((sclp_facilities & 0xe00000000000ULL) != 0xe00000000000ULL)\r\nreturn 0;\r\nrc = -ENOMEM;\r\nsccb = (void *) __get_free_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\ngoto out;\r\nassigned = 0;\r\nfor (id = 0; id <= sclp_max_storage_id; id++) {\r\nmemset(sccb, 0, PAGE_SIZE);\r\nsccb->header.length = PAGE_SIZE;\r\nrc = do_sync_request(0x00040001 | id << 8, sccb);\r\nif (rc)\r\ngoto out;\r\nswitch (sccb->header.response_code) {\r\ncase 0x0010:\r\nset_bit(id, sclp_storage_ids);\r\nfor (i = 0; i < sccb->assigned; i++) {\r\nif (!sccb->entries[i])\r\ncontinue;\r\nassigned++;\r\ninsert_increment(sccb->entries[i] >> 16, 0, 1);\r\n}\r\nbreak;\r\ncase 0x0310:\r\nbreak;\r\ncase 0x0410:\r\nfor (i = 0; i < sccb->assigned; i++) {\r\nif (!sccb->entries[i])\r\ncontinue;\r\nassigned++;\r\ninsert_increment(sccb->entries[i] >> 16, 1, 1);\r\n}\r\nbreak;\r\ndefault:\r\nrc = -EIO;\r\nbreak;\r\n}\r\nif (!rc)\r\nsclp_max_storage_id = sccb->max_id;\r\n}\r\nif (rc || list_empty(&sclp_mem_list))\r\ngoto out;\r\nfor (i = 1; i <= rnmax - assigned; i++)\r\ninsert_increment(0, 1, 0);\r\nrc = register_memory_notifier(&sclp_mem_nb);\r\nif (rc)\r\ngoto out;\r\nrc = platform_driver_register(&sclp_mem_pdrv);\r\nif (rc)\r\ngoto out;\r\nsclp_pdev = platform_device_register_simple("sclp_mem", -1, NULL, 0);\r\nrc = IS_ERR(sclp_pdev) ? PTR_ERR(sclp_pdev) : 0;\r\nif (rc)\r\ngoto out_driver;\r\nsclp_add_standby_memory();\r\ngoto out;\r\nout_driver:\r\nplatform_driver_unregister(&sclp_mem_pdrv);\r\nout:\r\nfree_page((unsigned long) sccb);\r\nreturn rc;\r\n}\r\nstatic int do_chp_configure(sclp_cmdw_t cmd)\r\n{\r\nstruct chp_cfg_sccb *sccb;\r\nint rc;\r\nif (!SCLP_HAS_CHP_RECONFIG)\r\nreturn -EOPNOTSUPP;\r\nsccb = (struct chp_cfg_sccb *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\nreturn -ENOMEM;\r\nsccb->header.length = sizeof(*sccb);\r\nrc = do_sync_request(cmd, sccb);\r\nif (rc)\r\ngoto out;\r\nswitch (sccb->header.response_code) {\r\ncase 0x0020:\r\ncase 0x0120:\r\ncase 0x0440:\r\ncase 0x0450:\r\nbreak;\r\ndefault:\r\npr_warning("configure channel-path failed "\r\n"(cmd=0x%08x, response=0x%04x)\n", cmd,\r\nsccb->header.response_code);\r\nrc = -EIO;\r\nbreak;\r\n}\r\nout:\r\nfree_page((unsigned long) sccb);\r\nreturn rc;\r\n}\r\nint sclp_chp_configure(struct chp_id chpid)\r\n{\r\nreturn do_chp_configure(SCLP_CMDW_CONFIGURE_CHPATH | chpid.id << 8);\r\n}\r\nint sclp_chp_deconfigure(struct chp_id chpid)\r\n{\r\nreturn do_chp_configure(SCLP_CMDW_DECONFIGURE_CHPATH | chpid.id << 8);\r\n}\r\nint sclp_chp_read_info(struct sclp_chp_info *info)\r\n{\r\nstruct chp_info_sccb *sccb;\r\nint rc;\r\nif (!SCLP_HAS_CHP_INFO)\r\nreturn -EOPNOTSUPP;\r\nsccb = (struct chp_info_sccb *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\nreturn -ENOMEM;\r\nsccb->header.length = sizeof(*sccb);\r\nrc = do_sync_request(SCLP_CMDW_READ_CHPATH_INFORMATION, sccb);\r\nif (rc)\r\ngoto out;\r\nif (sccb->header.response_code != 0x0010) {\r\npr_warning("read channel-path info failed "\r\n"(response=0x%04x)\n", sccb->header.response_code);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nmemcpy(info->recognized, sccb->recognized, SCLP_CHP_INFO_MASK_SIZE);\r\nmemcpy(info->standby, sccb->standby, SCLP_CHP_INFO_MASK_SIZE);\r\nmemcpy(info->configured, sccb->configured, SCLP_CHP_INFO_MASK_SIZE);\r\nout:\r\nfree_page((unsigned long) sccb);\r\nreturn rc;\r\n}
