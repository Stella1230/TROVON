static inline void\r\nsnd_pmac_burgundy_busy_wait(struct snd_pmac *chip)\r\n{\r\nint timeout = 50;\r\nwhile ((in_le32(&chip->awacs->codec_ctrl) & MASK_NEWECMD) && timeout--)\r\nudelay(1);\r\nif (timeout < 0)\r\nprintk(KERN_DEBUG "burgundy_busy_wait: timeout\n");\r\n}\r\nstatic inline void\r\nsnd_pmac_burgundy_extend_wait(struct snd_pmac *chip)\r\n{\r\nint timeout;\r\ntimeout = 50;\r\nwhile (!(in_le32(&chip->awacs->codec_stat) & MASK_EXTEND) && timeout--)\r\nudelay(1);\r\nif (timeout < 0)\r\nprintk(KERN_DEBUG "burgundy_extend_wait: timeout #1\n");\r\ntimeout = 50;\r\nwhile ((in_le32(&chip->awacs->codec_stat) & MASK_EXTEND) && timeout--)\r\nudelay(1);\r\nif (timeout < 0)\r\nprintk(KERN_DEBUG "burgundy_extend_wait: timeout #2\n");\r\n}\r\nstatic void\r\nsnd_pmac_burgundy_wcw(struct snd_pmac *chip, unsigned addr, unsigned val)\r\n{\r\nout_le32(&chip->awacs->codec_ctrl, addr + 0x200c00 + (val & 0xff));\r\nsnd_pmac_burgundy_busy_wait(chip);\r\nout_le32(&chip->awacs->codec_ctrl, addr + 0x200d00 +((val>>8) & 0xff));\r\nsnd_pmac_burgundy_busy_wait(chip);\r\nout_le32(&chip->awacs->codec_ctrl, addr + 0x200e00 +((val>>16) & 0xff));\r\nsnd_pmac_burgundy_busy_wait(chip);\r\nout_le32(&chip->awacs->codec_ctrl, addr + 0x200f00 +((val>>24) & 0xff));\r\nsnd_pmac_burgundy_busy_wait(chip);\r\n}\r\nstatic unsigned\r\nsnd_pmac_burgundy_rcw(struct snd_pmac *chip, unsigned addr)\r\n{\r\nunsigned val = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nout_le32(&chip->awacs->codec_ctrl, addr + 0x100000);\r\nsnd_pmac_burgundy_busy_wait(chip);\r\nsnd_pmac_burgundy_extend_wait(chip);\r\nval += (in_le32(&chip->awacs->codec_stat) >> 4) & 0xff;\r\nout_le32(&chip->awacs->codec_ctrl, addr + 0x100100);\r\nsnd_pmac_burgundy_busy_wait(chip);\r\nsnd_pmac_burgundy_extend_wait(chip);\r\nval += ((in_le32(&chip->awacs->codec_stat)>>4) & 0xff) <<8;\r\nout_le32(&chip->awacs->codec_ctrl, addr + 0x100200);\r\nsnd_pmac_burgundy_busy_wait(chip);\r\nsnd_pmac_burgundy_extend_wait(chip);\r\nval += ((in_le32(&chip->awacs->codec_stat)>>4) & 0xff) <<16;\r\nout_le32(&chip->awacs->codec_ctrl, addr + 0x100300);\r\nsnd_pmac_burgundy_busy_wait(chip);\r\nsnd_pmac_burgundy_extend_wait(chip);\r\nval += ((in_le32(&chip->awacs->codec_stat)>>4) & 0xff) <<24;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn val;\r\n}\r\nstatic void\r\nsnd_pmac_burgundy_wcb(struct snd_pmac *chip, unsigned int addr,\r\nunsigned int val)\r\n{\r\nout_le32(&chip->awacs->codec_ctrl, addr + 0x300000 + (val & 0xff));\r\nsnd_pmac_burgundy_busy_wait(chip);\r\n}\r\nstatic unsigned\r\nsnd_pmac_burgundy_rcb(struct snd_pmac *chip, unsigned int addr)\r\n{\r\nunsigned val = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nout_le32(&chip->awacs->codec_ctrl, addr + 0x100000);\r\nsnd_pmac_burgundy_busy_wait(chip);\r\nsnd_pmac_burgundy_extend_wait(chip);\r\nval += (in_le32(&chip->awacs->codec_stat) >> 4) & 0xff;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn val;\r\n}\r\nstatic void\r\nsnd_pmac_burgundy_write_volume(struct snd_pmac *chip, unsigned int address,\r\nlong *volume, int shift)\r\n{\r\nint hardvolume, lvolume, rvolume;\r\nif (volume[0] < 0 || volume[0] > 100 ||\r\nvolume[1] < 0 || volume[1] > 100)\r\nreturn;\r\nlvolume = volume[0] ? volume[0] + BURGUNDY_VOLUME_OFFSET : 0;\r\nrvolume = volume[1] ? volume[1] + BURGUNDY_VOLUME_OFFSET : 0;\r\nhardvolume = lvolume + (rvolume << shift);\r\nif (shift == 8)\r\nhardvolume |= hardvolume << 16;\r\nsnd_pmac_burgundy_wcw(chip, address, hardvolume);\r\n}\r\nstatic void\r\nsnd_pmac_burgundy_read_volume(struct snd_pmac *chip, unsigned int address,\r\nlong *volume, int shift)\r\n{\r\nint wvolume;\r\nwvolume = snd_pmac_burgundy_rcw(chip, address);\r\nvolume[0] = wvolume & 0xff;\r\nif (volume[0] >= BURGUNDY_VOLUME_OFFSET)\r\nvolume[0] -= BURGUNDY_VOLUME_OFFSET;\r\nelse\r\nvolume[0] = 0;\r\nvolume[1] = (wvolume >> shift) & 0xff;\r\nif (volume[1] >= BURGUNDY_VOLUME_OFFSET)\r\nvolume[1] -= BURGUNDY_VOLUME_OFFSET;\r\nelse\r\nvolume[1] = 0;\r\n}\r\nstatic int snd_pmac_burgundy_info_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 100;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_burgundy_get_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int addr = BASE2ADDR(kcontrol->private_value & 0xff);\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nsnd_pmac_burgundy_read_volume(chip, addr,\r\nucontrol->value.integer.value, shift);\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_burgundy_put_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int addr = BASE2ADDR(kcontrol->private_value & 0xff);\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nlong nvoices[2];\r\nsnd_pmac_burgundy_write_volume(chip, addr,\r\nucontrol->value.integer.value, shift);\r\nsnd_pmac_burgundy_read_volume(chip, addr, nvoices, shift);\r\nreturn (nvoices[0] != ucontrol->value.integer.value[0] ||\r\nnvoices[1] != ucontrol->value.integer.value[1]);\r\n}\r\nstatic void\r\nsnd_pmac_burgundy_write_volume_2b(struct snd_pmac *chip, unsigned int address,\r\nlong *volume, int off)\r\n{\r\nint lvolume, rvolume;\r\noff |= off << 2;\r\nlvolume = volume[0] ? volume[0] + BURGUNDY_VOLUME_OFFSET : 0;\r\nrvolume = volume[1] ? volume[1] + BURGUNDY_VOLUME_OFFSET : 0;\r\nsnd_pmac_burgundy_wcb(chip, address + off, lvolume);\r\nsnd_pmac_burgundy_wcb(chip, address + off + 0x500, rvolume);\r\n}\r\nstatic void\r\nsnd_pmac_burgundy_read_volume_2b(struct snd_pmac *chip, unsigned int address,\r\nlong *volume, int off)\r\n{\r\nvolume[0] = snd_pmac_burgundy_rcb(chip, address + off);\r\nif (volume[0] >= BURGUNDY_VOLUME_OFFSET)\r\nvolume[0] -= BURGUNDY_VOLUME_OFFSET;\r\nelse\r\nvolume[0] = 0;\r\nvolume[1] = snd_pmac_burgundy_rcb(chip, address + off + 0x100);\r\nif (volume[1] >= BURGUNDY_VOLUME_OFFSET)\r\nvolume[1] -= BURGUNDY_VOLUME_OFFSET;\r\nelse\r\nvolume[1] = 0;\r\n}\r\nstatic int snd_pmac_burgundy_info_volume_2b(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 100;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_burgundy_get_volume_2b(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int addr = BASE2ADDR(kcontrol->private_value & 0xff);\r\nint off = kcontrol->private_value & 0x300;\r\nsnd_pmac_burgundy_read_volume_2b(chip, addr,\r\nucontrol->value.integer.value, off);\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_burgundy_put_volume_2b(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int addr = BASE2ADDR(kcontrol->private_value & 0xff);\r\nint off = kcontrol->private_value & 0x300;\r\nlong nvoices[2];\r\nsnd_pmac_burgundy_write_volume_2b(chip, addr,\r\nucontrol->value.integer.value, off);\r\nsnd_pmac_burgundy_read_volume_2b(chip, addr, nvoices, off);\r\nreturn (nvoices[0] != ucontrol->value.integer.value[0] ||\r\nnvoices[1] != ucontrol->value.integer.value[1]);\r\n}\r\nstatic int snd_pmac_burgundy_info_gain(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint stereo = (kcontrol->private_value >> 24) & 1;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = stereo + 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 15;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_burgundy_get_gain(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int addr = BASE2ADDR(kcontrol->private_value & 0xff);\r\nint stereo = (kcontrol->private_value >> 24) & 1;\r\nint atten = (kcontrol->private_value >> 25) & 1;\r\nint oval;\r\noval = snd_pmac_burgundy_rcb(chip, addr);\r\nif (atten)\r\noval = ~oval & 0xff;\r\nucontrol->value.integer.value[0] = oval & 0xf;\r\nif (stereo)\r\nucontrol->value.integer.value[1] = (oval >> 4) & 0xf;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_burgundy_put_gain(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int addr = BASE2ADDR(kcontrol->private_value & 0xff);\r\nint stereo = (kcontrol->private_value >> 24) & 1;\r\nint atten = (kcontrol->private_value >> 25) & 1;\r\nint oval, val;\r\noval = snd_pmac_burgundy_rcb(chip, addr);\r\nif (atten)\r\noval = ~oval & 0xff;\r\nval = ucontrol->value.integer.value[0];\r\nif (stereo)\r\nval |= ucontrol->value.integer.value[1] << 4;\r\nelse\r\nval |= ucontrol->value.integer.value[0] << 4;\r\nif (atten)\r\nval = ~val & 0xff;\r\nsnd_pmac_burgundy_wcb(chip, addr, val);\r\nreturn val != oval;\r\n}\r\nstatic int snd_pmac_burgundy_info_switch_w(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint stereo = (kcontrol->private_value >> 24) & 1;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = stereo + 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_burgundy_get_switch_w(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int addr = BASE2ADDR((kcontrol->private_value >> 16) & 0xff);\r\nint lmask = 1 << (kcontrol->private_value & 0xff);\r\nint rmask = 1 << ((kcontrol->private_value >> 8) & 0xff);\r\nint stereo = (kcontrol->private_value >> 24) & 1;\r\nint val = snd_pmac_burgundy_rcw(chip, addr);\r\nucontrol->value.integer.value[0] = (val & lmask) ? 1 : 0;\r\nif (stereo)\r\nucontrol->value.integer.value[1] = (val & rmask) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_burgundy_put_switch_w(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int addr = BASE2ADDR((kcontrol->private_value >> 16) & 0xff);\r\nint lmask = 1 << (kcontrol->private_value & 0xff);\r\nint rmask = 1 << ((kcontrol->private_value >> 8) & 0xff);\r\nint stereo = (kcontrol->private_value >> 24) & 1;\r\nint val, oval;\r\noval = snd_pmac_burgundy_rcw(chip, addr);\r\nval = oval & ~(lmask | (stereo ? rmask : 0));\r\nif (ucontrol->value.integer.value[0])\r\nval |= lmask;\r\nif (stereo && ucontrol->value.integer.value[1])\r\nval |= rmask;\r\nsnd_pmac_burgundy_wcw(chip, addr, val);\r\nreturn val != oval;\r\n}\r\nstatic int snd_pmac_burgundy_info_switch_b(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint stereo = (kcontrol->private_value >> 24) & 1;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = stereo + 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_burgundy_get_switch_b(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int addr = BASE2ADDR((kcontrol->private_value >> 16) & 0xff);\r\nint lmask = kcontrol->private_value & 0xff;\r\nint rmask = (kcontrol->private_value >> 8) & 0xff;\r\nint stereo = (kcontrol->private_value >> 24) & 1;\r\nint val = snd_pmac_burgundy_rcb(chip, addr);\r\nucontrol->value.integer.value[0] = (val & lmask) ? 1 : 0;\r\nif (stereo)\r\nucontrol->value.integer.value[1] = (val & rmask) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_burgundy_put_switch_b(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int addr = BASE2ADDR((kcontrol->private_value >> 16) & 0xff);\r\nint lmask = kcontrol->private_value & 0xff;\r\nint rmask = (kcontrol->private_value >> 8) & 0xff;\r\nint stereo = (kcontrol->private_value >> 24) & 1;\r\nint val, oval;\r\noval = snd_pmac_burgundy_rcb(chip, addr);\r\nval = oval & ~(lmask | rmask);\r\nif (ucontrol->value.integer.value[0])\r\nval |= lmask;\r\nif (stereo && ucontrol->value.integer.value[1])\r\nval |= rmask;\r\nsnd_pmac_burgundy_wcb(chip, addr, val);\r\nreturn val != oval;\r\n}\r\nstatic int snd_pmac_burgundy_detect_headphone(struct snd_pmac *chip)\r\n{\r\nreturn (in_le32(&chip->awacs->codec_stat) & chip->hp_stat_mask) ? 1 : 0;\r\n}\r\nstatic void snd_pmac_burgundy_update_automute(struct snd_pmac *chip, int do_notify)\r\n{\r\nif (chip->auto_mute) {\r\nint imac = of_machine_is_compatible("iMac");\r\nint reg, oreg;\r\nreg = oreg = snd_pmac_burgundy_rcb(chip,\r\nMASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES);\r\nreg &= imac ? ~(BURGUNDY_OUTPUT_LEFT | BURGUNDY_OUTPUT_RIGHT\r\n| BURGUNDY_HP_LEFT | BURGUNDY_HP_RIGHT)\r\n: ~(BURGUNDY_OUTPUT_LEFT | BURGUNDY_OUTPUT_RIGHT\r\n| BURGUNDY_OUTPUT_INTERN);\r\nif (snd_pmac_burgundy_detect_headphone(chip))\r\nreg |= imac ? (BURGUNDY_HP_LEFT | BURGUNDY_HP_RIGHT)\r\n: (BURGUNDY_OUTPUT_LEFT\r\n| BURGUNDY_OUTPUT_RIGHT);\r\nelse\r\nreg |= imac ? (BURGUNDY_OUTPUT_LEFT\r\n| BURGUNDY_OUTPUT_RIGHT)\r\n: (BURGUNDY_OUTPUT_INTERN);\r\nif (do_notify && reg == oreg)\r\nreturn;\r\nsnd_pmac_burgundy_wcb(chip,\r\nMASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES, reg);\r\nif (do_notify) {\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->master_sw_ctl->id);\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->speaker_sw_ctl->id);\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->hp_detect_ctl->id);\r\n}\r\n}\r\n}\r\nint __devinit snd_pmac_burgundy_init(struct snd_pmac *chip)\r\n{\r\nint imac = of_machine_is_compatible("iMac");\r\nint i, err;\r\nif ((in_le32(&chip->awacs->codec_ctrl) & MASK_ERRCODE) == 0xf0000) {\r\nprintk(KERN_WARNING "pmac burgundy: disabled by MacOS :-(\n");\r\nreturn 1;\r\n}\r\nsnd_pmac_burgundy_wcw(chip, MASK_ADDR_BURGUNDY_OUTPUTENABLES,\r\nDEF_BURGUNDY_OUTPUTENABLES);\r\nsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES,\r\nDEF_BURGUNDY_MORE_OUTPUTENABLES);\r\nsnd_pmac_burgundy_wcw(chip, MASK_ADDR_BURGUNDY_OUTPUTSELECTS,\r\nDEF_BURGUNDY_OUTPUTSELECTS);\r\nsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_INPSEL21,\r\nDEF_BURGUNDY_INPSEL21);\r\nsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_INPSEL3,\r\nimac ? DEF_BURGUNDY_INPSEL3_IMAC\r\n: DEF_BURGUNDY_INPSEL3_PMAC);\r\nsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_GAINCD,\r\nDEF_BURGUNDY_GAINCD);\r\nsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_GAINLINE,\r\nDEF_BURGUNDY_GAINLINE);\r\nsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_GAINMIC,\r\nDEF_BURGUNDY_GAINMIC);\r\nsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_GAINMODEM,\r\nDEF_BURGUNDY_GAINMODEM);\r\nsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_ATTENSPEAKER,\r\nDEF_BURGUNDY_ATTENSPEAKER);\r\nsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_ATTENLINEOUT,\r\nDEF_BURGUNDY_ATTENLINEOUT);\r\nsnd_pmac_burgundy_wcb(chip, MASK_ADDR_BURGUNDY_ATTENHP,\r\nDEF_BURGUNDY_ATTENHP);\r\nsnd_pmac_burgundy_wcw(chip, MASK_ADDR_BURGUNDY_MASTER_VOLUME,\r\nDEF_BURGUNDY_MASTER_VOLUME);\r\nsnd_pmac_burgundy_wcw(chip, MASK_ADDR_BURGUNDY_VOLCD,\r\nDEF_BURGUNDY_VOLCD);\r\nsnd_pmac_burgundy_wcw(chip, MASK_ADDR_BURGUNDY_VOLLINE,\r\nDEF_BURGUNDY_VOLLINE);\r\nsnd_pmac_burgundy_wcw(chip, MASK_ADDR_BURGUNDY_VOLMIC,\r\nDEF_BURGUNDY_VOLMIC);\r\nif (chip->hp_stat_mask == 0) {\r\nif (imac)\r\nchip->hp_stat_mask = BURGUNDY_HPDETECT_IMAC_UPPER\r\n| BURGUNDY_HPDETECT_IMAC_LOWER\r\n| BURGUNDY_HPDETECT_IMAC_SIDE;\r\nelse\r\nchip->hp_stat_mask = BURGUNDY_HPDETECT_PMAC_BACK;\r\n}\r\nstrcpy(chip->card->mixername, "PowerMac Burgundy");\r\nfor (i = 0; i < ARRAY_SIZE(snd_pmac_burgundy_mixers); i++) {\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&snd_pmac_burgundy_mixers[i], chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < (imac ? ARRAY_SIZE(snd_pmac_burgundy_mixers_imac)\r\n: ARRAY_SIZE(snd_pmac_burgundy_mixers_pmac)); i++) {\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(imac ? &snd_pmac_burgundy_mixers_imac[i]\r\n: &snd_pmac_burgundy_mixers_pmac[i], chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nchip->master_sw_ctl = snd_ctl_new1(imac\r\n? &snd_pmac_burgundy_master_sw_imac\r\n: &snd_pmac_burgundy_master_sw_pmac, chip);\r\nerr = snd_ctl_add(chip->card, chip->master_sw_ctl);\r\nif (err < 0)\r\nreturn err;\r\nchip->master_sw_ctl = snd_ctl_new1(imac\r\n? &snd_pmac_burgundy_line_sw_imac\r\n: &snd_pmac_burgundy_line_sw_pmac, chip);\r\nerr = snd_ctl_add(chip->card, chip->master_sw_ctl);\r\nif (err < 0)\r\nreturn err;\r\nif (imac) {\r\nchip->master_sw_ctl = snd_ctl_new1(\r\n&snd_pmac_burgundy_hp_sw_imac, chip);\r\nerr = snd_ctl_add(chip->card, chip->master_sw_ctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nchip->speaker_sw_ctl = snd_ctl_new1(imac\r\n? &snd_pmac_burgundy_speaker_sw_imac\r\n: &snd_pmac_burgundy_speaker_sw_pmac, chip);\r\nerr = snd_ctl_add(chip->card, chip->speaker_sw_ctl);\r\nif (err < 0)\r\nreturn err;\r\n#ifdef PMAC_SUPPORT_AUTOMUTE\r\nerr = snd_pmac_add_automute(chip);\r\nif (err < 0)\r\nreturn err;\r\nchip->detect_headphone = snd_pmac_burgundy_detect_headphone;\r\nchip->update_automute = snd_pmac_burgundy_update_automute;\r\nsnd_pmac_burgundy_update_automute(chip, 0);\r\n#endif\r\nreturn 0;\r\n}
