void fhci_start_sof_timer(struct fhci_hcd *fhci)\r\n{\r\nfhci_dbg(fhci, "-> %s\n", __func__);\r\nout_be16(&fhci->pram->frame_num, 0);\r\nout_be16(&fhci->regs->usb_ussft, 0);\r\nsetbits8(&fhci->regs->usb_usmod, USB_MODE_SFTE);\r\nfhci_dbg(fhci, "<- %s\n", __func__);\r\n}\r\nvoid fhci_stop_sof_timer(struct fhci_hcd *fhci)\r\n{\r\nfhci_dbg(fhci, "-> %s\n", __func__);\r\nclrbits8(&fhci->regs->usb_usmod, USB_MODE_SFTE);\r\ngtm_stop_timer16(fhci->timer);\r\nfhci_dbg(fhci, "<- %s\n", __func__);\r\n}\r\nu16 fhci_get_sof_timer_count(struct fhci_usb *usb)\r\n{\r\nreturn be16_to_cpu(in_be16(&usb->fhci->regs->usb_ussft) / 12);\r\n}\r\nstatic u32 endpoint_zero_init(struct fhci_usb *usb,\r\nenum fhci_mem_alloc data_mem,\r\nu32 ring_len)\r\n{\r\nu32 rc;\r\nrc = fhci_create_ep(usb, data_mem, ring_len);\r\nif (rc)\r\nreturn rc;\r\nfhci_init_ep_registers(usb, usb->ep0, data_mem);\r\nreturn 0;\r\n}\r\nvoid fhci_usb_enable_interrupt(struct fhci_usb *usb)\r\n{\r\nstruct fhci_hcd *fhci = usb->fhci;\r\nif (usb->intr_nesting_cnt == 1) {\r\nenable_irq(fhci_to_hcd(fhci)->irq);\r\nout_be16(&usb->fhci->regs->usb_usber, 0xffff);\r\nout_be16(&usb->fhci->regs->usb_usbmr, usb->saved_msk);\r\nenable_irq(fhci->timer->irq);\r\n} else if (usb->intr_nesting_cnt > 1)\r\nfhci_info(fhci, "unbalanced USB interrupts nesting\n");\r\nusb->intr_nesting_cnt--;\r\n}\r\nvoid fhci_usb_disable_interrupt(struct fhci_usb *usb)\r\n{\r\nstruct fhci_hcd *fhci = usb->fhci;\r\nif (usb->intr_nesting_cnt == 0) {\r\ndisable_irq_nosync(fhci->timer->irq);\r\ndisable_irq_nosync(fhci_to_hcd(fhci)->irq);\r\nout_be16(&usb->fhci->regs->usb_usbmr, 0);\r\n}\r\nusb->intr_nesting_cnt++;\r\n}\r\nstatic u32 fhci_usb_enable(struct fhci_hcd *fhci)\r\n{\r\nstruct fhci_usb *usb = fhci->usb_lld;\r\nout_be16(&usb->fhci->regs->usb_usber, 0xffff);\r\nout_be16(&usb->fhci->regs->usb_usbmr, usb->saved_msk);\r\nsetbits8(&usb->fhci->regs->usb_usmod, USB_MODE_EN);\r\nmdelay(100);\r\nreturn 0;\r\n}\r\nstatic u32 fhci_usb_disable(struct fhci_hcd *fhci)\r\n{\r\nstruct fhci_usb *usb = fhci->usb_lld;\r\nfhci_usb_disable_interrupt(usb);\r\nfhci_port_disable(fhci);\r\nif (usb->port_status == FHCI_PORT_FULL ||\r\nusb->port_status == FHCI_PORT_LOW)\r\nfhci_device_disconnected_interrupt(fhci);\r\nclrbits8(&usb->fhci->regs->usb_usmod, USB_MODE_EN);\r\nreturn 0;\r\n}\r\nint fhci_ioports_check_bus_state(struct fhci_hcd *fhci)\r\n{\r\nu8 bits = 0;\r\nif (!gpio_get_value(fhci->gpios[GPIO_USBOE]))\r\nreturn -1;\r\nif (gpio_get_value(fhci->gpios[GPIO_USBRP]))\r\nbits |= 0x2;\r\nif (gpio_get_value(fhci->gpios[GPIO_USBRN]))\r\nbits |= 0x1;\r\nreturn bits;\r\n}\r\nstatic void fhci_mem_free(struct fhci_hcd *fhci)\r\n{\r\nstruct ed *ed;\r\nstruct ed *next_ed;\r\nstruct td *td;\r\nstruct td *next_td;\r\nlist_for_each_entry_safe(ed, next_ed, &fhci->empty_eds, node) {\r\nlist_del(&ed->node);\r\nkfree(ed);\r\n}\r\nlist_for_each_entry_safe(td, next_td, &fhci->empty_tds, node) {\r\nlist_del(&td->node);\r\nkfree(td);\r\n}\r\nkfree(fhci->vroot_hub);\r\nfhci->vroot_hub = NULL;\r\nkfree(fhci->hc_list);\r\nfhci->hc_list = NULL;\r\n}\r\nstatic int fhci_mem_init(struct fhci_hcd *fhci)\r\n{\r\nint i;\r\nfhci->hc_list = kzalloc(sizeof(*fhci->hc_list), GFP_KERNEL);\r\nif (!fhci->hc_list)\r\ngoto err;\r\nINIT_LIST_HEAD(&fhci->hc_list->ctrl_list);\r\nINIT_LIST_HEAD(&fhci->hc_list->bulk_list);\r\nINIT_LIST_HEAD(&fhci->hc_list->iso_list);\r\nINIT_LIST_HEAD(&fhci->hc_list->intr_list);\r\nINIT_LIST_HEAD(&fhci->hc_list->done_list);\r\nfhci->vroot_hub = kzalloc(sizeof(*fhci->vroot_hub), GFP_KERNEL);\r\nif (!fhci->vroot_hub)\r\ngoto err;\r\nINIT_LIST_HEAD(&fhci->empty_eds);\r\nINIT_LIST_HEAD(&fhci->empty_tds);\r\nfhci_tasklet.data = (unsigned long)fhci;\r\nfhci->process_done_task = &fhci_tasklet;\r\nfor (i = 0; i < MAX_TDS; i++) {\r\nstruct td *td;\r\ntd = kmalloc(sizeof(*td), GFP_KERNEL);\r\nif (!td)\r\ngoto err;\r\nfhci_recycle_empty_td(fhci, td);\r\n}\r\nfor (i = 0; i < MAX_EDS; i++) {\r\nstruct ed *ed;\r\ned = kmalloc(sizeof(*ed), GFP_KERNEL);\r\nif (!ed)\r\ngoto err;\r\nfhci_recycle_empty_ed(fhci, ed);\r\n}\r\nfhci->active_urbs = 0;\r\nreturn 0;\r\nerr:\r\nfhci_mem_free(fhci);\r\nreturn -ENOMEM;\r\n}\r\nstatic void fhci_usb_free(void *lld)\r\n{\r\nstruct fhci_usb *usb = lld;\r\nstruct fhci_hcd *fhci;\r\nif (usb) {\r\nfhci = usb->fhci;\r\nfhci_config_transceiver(fhci, FHCI_PORT_POWER_OFF);\r\nfhci_ep0_free(usb);\r\nkfree(usb->actual_frame);\r\nkfree(usb);\r\n}\r\n}\r\nstatic int fhci_usb_init(struct fhci_hcd *fhci)\r\n{\r\nstruct fhci_usb *usb = fhci->usb_lld;\r\nmemset_io(usb->fhci->pram, 0, FHCI_PRAM_SIZE);\r\nusb->port_status = FHCI_PORT_DISABLED;\r\nusb->max_frame_usage = FRAME_TIME_USAGE;\r\nusb->sw_transaction_time = SW_FIX_TIME_BETWEEN_TRANSACTION;\r\nusb->actual_frame = kzalloc(sizeof(*usb->actual_frame), GFP_KERNEL);\r\nif (!usb->actual_frame) {\r\nfhci_usb_free(usb);\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&usb->actual_frame->tds_list);\r\nout_be16(&fhci->pram->frame_num, 0);\r\nout_be32(&fhci->pram->rx_state, 0);\r\nusb->saved_msk = (USB_E_TXB_MASK |\r\nUSB_E_TXE1_MASK |\r\nUSB_E_IDLE_MASK |\r\nUSB_E_RESET_MASK | USB_E_SFT_MASK | USB_E_MSF_MASK);\r\nout_8(&usb->fhci->regs->usb_usmod, USB_MODE_HOST | USB_MODE_EN);\r\nout_be16(&usb->fhci->regs->usb_usbmr, 0);\r\nout_be16(&usb->fhci->regs->usb_usber, 0xffff);\r\nif (endpoint_zero_init(usb, DEFAULT_DATA_MEM, DEFAULT_RING_LEN) != 0) {\r\nfhci_usb_free(usb);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct fhci_usb *fhci_create_lld(struct fhci_hcd *fhci)\r\n{\r\nstruct fhci_usb *usb;\r\nusb = kzalloc(sizeof(*usb), GFP_KERNEL);\r\nif (!usb) {\r\nfhci_err(fhci, "no memory for SCC data struct\n");\r\nreturn NULL;\r\n}\r\nusb->fhci = fhci;\r\nusb->hc_list = fhci->hc_list;\r\nusb->vroot_hub = fhci->vroot_hub;\r\nusb->transfer_confirm = fhci_transfer_confirm_callback;\r\nreturn usb;\r\n}\r\nstatic int fhci_start(struct usb_hcd *hcd)\r\n{\r\nint ret;\r\nstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\r\nret = fhci_mem_init(fhci);\r\nif (ret) {\r\nfhci_err(fhci, "failed to allocate memory\n");\r\ngoto err;\r\n}\r\nfhci->usb_lld = fhci_create_lld(fhci);\r\nif (!fhci->usb_lld) {\r\nfhci_err(fhci, "low level driver config failed\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nret = fhci_usb_init(fhci);\r\nif (ret) {\r\nfhci_err(fhci, "low level driver initialize failed\n");\r\ngoto err;\r\n}\r\nspin_lock_init(&fhci->lock);\r\nfhci->vroot_hub->dev_num = 1;\r\nfhci->vroot_hub->hub.wHubStatus = 0;\r\nfhci->vroot_hub->hub.wHubChange = 0;\r\nfhci->vroot_hub->port.wPortStatus = 0;\r\nfhci->vroot_hub->port.wPortChange = 0;\r\nhcd->state = HC_STATE_RUNNING;\r\nfhci_usb_enable(fhci);\r\nreturn 0;\r\nerr:\r\nfhci_mem_free(fhci);\r\nreturn ret;\r\n}\r\nstatic void fhci_stop(struct usb_hcd *hcd)\r\n{\r\nstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\r\nfhci_usb_disable_interrupt(fhci->usb_lld);\r\nfhci_usb_disable(fhci);\r\nfhci_usb_free(fhci->usb_lld);\r\nfhci->usb_lld = NULL;\r\nfhci_mem_free(fhci);\r\n}\r\nstatic int fhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\r\nu32 pipe = urb->pipe;\r\nint ret;\r\nint i;\r\nint size = 0;\r\nstruct urb_priv *urb_priv;\r\nunsigned long flags;\r\nswitch (usb_pipetype(pipe)) {\r\ncase PIPE_CONTROL:\r\nsize = 2;\r\ncase PIPE_BULK:\r\nsize += urb->transfer_buffer_length / 4096;\r\nif ((urb->transfer_buffer_length % 4096) != 0)\r\nsize++;\r\nif (size == 0)\r\nsize++;\r\nelse if ((urb->transfer_flags & URB_ZERO_PACKET) != 0\r\n&& (urb->transfer_buffer_length\r\n% usb_maxpacket(urb->dev, pipe,\r\nusb_pipeout(pipe))) != 0)\r\nsize++;\r\nbreak;\r\ncase PIPE_ISOCHRONOUS:\r\nsize = urb->number_of_packets;\r\nif (size <= 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nurb->iso_frame_desc[i].actual_length = 0;\r\nurb->iso_frame_desc[i].status = (u32) (-EXDEV);\r\n}\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\nsize = 1;\r\n}\r\nurb_priv = kzalloc(sizeof(*urb_priv), mem_flags);\r\nif (!urb_priv)\r\nreturn -ENOMEM;\r\nurb_priv->tds = kcalloc(size, sizeof(*urb_priv->tds), mem_flags);\r\nif (!urb_priv->tds) {\r\nkfree(urb_priv);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&fhci->lock, flags);\r\nret = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (ret)\r\ngoto err;\r\nurb_priv->num_of_tds = size;\r\nurb->status = -EINPROGRESS;\r\nurb->actual_length = 0;\r\nurb->error_count = 0;\r\nurb->hcpriv = urb_priv;\r\nfhci_queue_urb(fhci, urb);\r\nerr:\r\nif (ret) {\r\nkfree(urb_priv->tds);\r\nkfree(urb_priv);\r\n}\r\nspin_unlock_irqrestore(&fhci->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int fhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\r\nstruct fhci_usb *usb = fhci->usb_lld;\r\nint ret = -EINVAL;\r\nunsigned long flags;\r\nif (!urb || !urb->dev || !urb->dev->bus)\r\ngoto out;\r\nspin_lock_irqsave(&fhci->lock, flags);\r\nret = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (ret)\r\ngoto out2;\r\nif (usb->port_status != FHCI_PORT_DISABLED) {\r\nstruct urb_priv *urb_priv;\r\nurb_priv = urb->hcpriv;\r\nif (!urb_priv || (urb_priv->state == URB_DEL))\r\ngoto out2;\r\nurb_priv->state = URB_DEL;\r\nurb_priv->ed->state = FHCI_ED_URB_DEL;\r\n} else {\r\nfhci_urb_complete_free(fhci, urb);\r\n}\r\nout2:\r\nspin_unlock_irqrestore(&fhci->lock, flags);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void fhci_endpoint_disable(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct fhci_hcd *fhci;\r\nstruct ed *ed;\r\nunsigned long flags;\r\nfhci = hcd_to_fhci(hcd);\r\nspin_lock_irqsave(&fhci->lock, flags);\r\ned = ep->hcpriv;\r\nif (ed) {\r\nwhile (ed->td_head != NULL) {\r\nstruct td *td = fhci_remove_td_from_ed(ed);\r\nfhci_urb_complete_free(fhci, td->urb);\r\n}\r\nfhci_recycle_empty_ed(fhci, ed);\r\nep->hcpriv = NULL;\r\n}\r\nspin_unlock_irqrestore(&fhci->lock, flags);\r\n}\r\nstatic int fhci_get_frame_number(struct usb_hcd *hcd)\r\n{\r\nstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\r\nreturn get_frame_num(fhci);\r\n}\r\nstatic int __devinit of_fhci_probe(struct platform_device *ofdev)\r\n{\r\nstruct device *dev = &ofdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct usb_hcd *hcd;\r\nstruct fhci_hcd *fhci;\r\nstruct resource usb_regs;\r\nunsigned long pram_addr;\r\nunsigned int usb_irq;\r\nconst char *sprop;\r\nconst u32 *iprop;\r\nint size;\r\nint ret;\r\nint i;\r\nint j;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nsprop = of_get_property(node, "mode", NULL);\r\nif (sprop && strcmp(sprop, "host"))\r\nreturn -ENODEV;\r\nhcd = usb_create_hcd(&fhci_driver, dev, dev_name(dev));\r\nif (!hcd) {\r\ndev_err(dev, "could not create hcd\n");\r\nreturn -ENOMEM;\r\n}\r\nfhci = hcd_to_fhci(hcd);\r\nhcd->self.controller = dev;\r\ndev_set_drvdata(dev, hcd);\r\niprop = of_get_property(node, "hub-power-budget", &size);\r\nif (iprop && size == sizeof(*iprop))\r\nhcd->power_budget = *iprop;\r\nret = of_address_to_resource(node, 0, &usb_regs);\r\nif (ret) {\r\ndev_err(dev, "could not get regs\n");\r\ngoto err_regs;\r\n}\r\nhcd->regs = ioremap(usb_regs.start, resource_size(&usb_regs));\r\nif (!hcd->regs) {\r\ndev_err(dev, "could not ioremap regs\n");\r\nret = -ENOMEM;\r\ngoto err_regs;\r\n}\r\nfhci->regs = hcd->regs;\r\niprop = of_get_property(node, "reg", &size);\r\nif (!iprop || size < sizeof(*iprop) * 4) {\r\ndev_err(dev, "can't get pram offset\n");\r\nret = -EINVAL;\r\ngoto err_pram;\r\n}\r\npram_addr = cpm_muram_alloc(FHCI_PRAM_SIZE, 64);\r\nif (IS_ERR_VALUE(pram_addr)) {\r\ndev_err(dev, "failed to allocate usb pram\n");\r\nret = -ENOMEM;\r\ngoto err_pram;\r\n}\r\nqe_issue_cmd(QE_ASSIGN_PAGE_TO_DEVICE, QE_CR_SUBBLOCK_USB,\r\nQE_CR_PROTOCOL_UNSPECIFIED, pram_addr);\r\nfhci->pram = cpm_muram_addr(pram_addr);\r\nfor (i = 0; i < NUM_GPIOS; i++) {\r\nint gpio;\r\nenum of_gpio_flags flags;\r\ngpio = of_get_gpio_flags(node, i, &flags);\r\nfhci->gpios[i] = gpio;\r\nfhci->alow_gpios[i] = flags & OF_GPIO_ACTIVE_LOW;\r\nif (!gpio_is_valid(gpio)) {\r\nif (i < GPIO_SPEED) {\r\ndev_err(dev, "incorrect GPIO%d: %d\n",\r\ni, gpio);\r\ngoto err_gpios;\r\n} else {\r\ndev_info(dev, "assuming board doesn't have "\r\n"%s gpio\n", i == GPIO_SPEED ?\r\n"speed" : "power");\r\ncontinue;\r\n}\r\n}\r\nret = gpio_request(gpio, dev_name(dev));\r\nif (ret) {\r\ndev_err(dev, "failed to request gpio %d", i);\r\ngoto err_gpios;\r\n}\r\nif (i >= GPIO_SPEED) {\r\nret = gpio_direction_output(gpio, 0);\r\nif (ret) {\r\ndev_err(dev, "failed to set gpio %d as "\r\n"an output\n", i);\r\ni++;\r\ngoto err_gpios;\r\n}\r\n}\r\n}\r\nfor (j = 0; j < NUM_PINS; j++) {\r\nfhci->pins[j] = qe_pin_request(node, j);\r\nif (IS_ERR(fhci->pins[j])) {\r\nret = PTR_ERR(fhci->pins[j]);\r\ndev_err(dev, "can't get pin %d: %d\n", j, ret);\r\ngoto err_pins;\r\n}\r\n}\r\nfhci->timer = gtm_get_timer16();\r\nif (IS_ERR(fhci->timer)) {\r\nret = PTR_ERR(fhci->timer);\r\ndev_err(dev, "failed to request qe timer: %i", ret);\r\ngoto err_get_timer;\r\n}\r\nret = request_irq(fhci->timer->irq, fhci_frame_limit_timer_irq,\r\n0, "qe timer (usb)", hcd);\r\nif (ret) {\r\ndev_err(dev, "failed to request timer irq");\r\ngoto err_timer_irq;\r\n}\r\nusb_irq = irq_of_parse_and_map(node, 0);\r\nif (usb_irq == NO_IRQ) {\r\ndev_err(dev, "could not get usb irq\n");\r\nret = -EINVAL;\r\ngoto err_usb_irq;\r\n}\r\nsprop = of_get_property(node, "fsl,fullspeed-clock", NULL);\r\nif (sprop) {\r\nfhci->fullspeed_clk = qe_clock_source(sprop);\r\nif (fhci->fullspeed_clk == QE_CLK_DUMMY) {\r\ndev_err(dev, "wrong fullspeed-clock\n");\r\nret = -EINVAL;\r\ngoto err_clocks;\r\n}\r\n}\r\nsprop = of_get_property(node, "fsl,lowspeed-clock", NULL);\r\nif (sprop) {\r\nfhci->lowspeed_clk = qe_clock_source(sprop);\r\nif (fhci->lowspeed_clk == QE_CLK_DUMMY) {\r\ndev_err(dev, "wrong lowspeed-clock\n");\r\nret = -EINVAL;\r\ngoto err_clocks;\r\n}\r\n}\r\nif (fhci->fullspeed_clk == QE_CLK_NONE &&\r\nfhci->lowspeed_clk == QE_CLK_NONE) {\r\ndev_err(dev, "no clocks specified\n");\r\nret = -EINVAL;\r\ngoto err_clocks;\r\n}\r\ndev_info(dev, "at 0x%p, irq %d\n", hcd->regs, usb_irq);\r\nfhci_config_transceiver(fhci, FHCI_PORT_POWER_OFF);\r\nif (fhci->fullspeed_clk != QE_CLK_NONE) {\r\nfhci_config_transceiver(fhci, FHCI_PORT_FULL);\r\nqe_usb_clock_set(fhci->fullspeed_clk, USB_CLOCK);\r\n} else {\r\nfhci_config_transceiver(fhci, FHCI_PORT_LOW);\r\nqe_usb_clock_set(fhci->lowspeed_clk, USB_CLOCK >> 3);\r\n}\r\nout_be16(&fhci->regs->usb_usber, 0xffff);\r\nout_be16(&fhci->regs->usb_usbmr, 0);\r\nret = usb_add_hcd(hcd, usb_irq, 0);\r\nif (ret < 0)\r\ngoto err_add_hcd;\r\nfhci_dfs_create(fhci);\r\nreturn 0;\r\nerr_add_hcd:\r\nerr_clocks:\r\nirq_dispose_mapping(usb_irq);\r\nerr_usb_irq:\r\nfree_irq(fhci->timer->irq, hcd);\r\nerr_timer_irq:\r\ngtm_put_timer16(fhci->timer);\r\nerr_get_timer:\r\nerr_pins:\r\nwhile (--j >= 0)\r\nqe_pin_free(fhci->pins[j]);\r\nerr_gpios:\r\nwhile (--i >= 0) {\r\nif (gpio_is_valid(fhci->gpios[i]))\r\ngpio_free(fhci->gpios[i]);\r\n}\r\ncpm_muram_free(pram_addr);\r\nerr_pram:\r\niounmap(hcd->regs);\r\nerr_regs:\r\nusb_put_hcd(hcd);\r\nreturn ret;\r\n}\r\nstatic int __devexit fhci_remove(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\r\nint i;\r\nint j;\r\nusb_remove_hcd(hcd);\r\nfree_irq(fhci->timer->irq, hcd);\r\ngtm_put_timer16(fhci->timer);\r\ncpm_muram_free(cpm_muram_offset(fhci->pram));\r\nfor (i = 0; i < NUM_GPIOS; i++) {\r\nif (!gpio_is_valid(fhci->gpios[i]))\r\ncontinue;\r\ngpio_free(fhci->gpios[i]);\r\n}\r\nfor (j = 0; j < NUM_PINS; j++)\r\nqe_pin_free(fhci->pins[j]);\r\nfhci_dfs_destroy(fhci);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic int __devexit of_fhci_remove(struct platform_device *ofdev)\r\n{\r\nreturn fhci_remove(&ofdev->dev);\r\n}
