static void kvm_get_pal_call_data(struct kvm_vcpu *vcpu,\r\nu64 *gr28, u64 *gr29, u64 *gr30, u64 *gr31) {\r\nstruct exit_ctl_data *p;\r\nif (vcpu) {\r\np = &vcpu->arch.exit_data;\r\nif (p->exit_reason == EXIT_REASON_PAL_CALL) {\r\n*gr28 = p->u.pal_data.gr28;\r\n*gr29 = p->u.pal_data.gr29;\r\n*gr30 = p->u.pal_data.gr30;\r\n*gr31 = p->u.pal_data.gr31;\r\nreturn ;\r\n}\r\n}\r\nprintk(KERN_DEBUG"Failed to get vcpu pal data!!!\n");\r\n}\r\nstatic void set_pal_result(struct kvm_vcpu *vcpu,\r\nstruct ia64_pal_retval result) {\r\nstruct exit_ctl_data *p;\r\np = kvm_get_exit_data(vcpu);\r\nif (p->exit_reason == EXIT_REASON_PAL_CALL) {\r\np->u.pal_data.ret = result;\r\nreturn ;\r\n}\r\nINIT_PAL_STATUS_UNIMPLEMENTED(p->u.pal_data.ret);\r\n}\r\nstatic void set_sal_result(struct kvm_vcpu *vcpu,\r\nstruct sal_ret_values result) {\r\nstruct exit_ctl_data *p;\r\np = kvm_get_exit_data(vcpu);\r\nif (p->exit_reason == EXIT_REASON_SAL_CALL) {\r\np->u.sal_data.ret = result;\r\nreturn ;\r\n}\r\nprintk(KERN_WARNING"Failed to set sal result!!\n");\r\n}\r\nstatic void remote_pal_cache_flush(void *data)\r\n{\r\nstruct cache_flush_args *args = data;\r\nlong status;\r\nu64 progress = args->progress;\r\nstatus = ia64_pal_cache_flush(args->cache_type, args->operation,\r\n&progress, NULL);\r\nif (status != 0)\r\nargs->status = status;\r\n}\r\nstatic struct ia64_pal_retval pal_cache_flush(struct kvm_vcpu *vcpu)\r\n{\r\nu64 gr28, gr29, gr30, gr31;\r\nstruct ia64_pal_retval result = {0, 0, 0, 0};\r\nstruct cache_flush_args args = {0, 0, 0, 0};\r\nlong psr;\r\ngr28 = gr29 = gr30 = gr31 = 0;\r\nkvm_get_pal_call_data(vcpu, &gr28, &gr29, &gr30, &gr31);\r\nif (gr31 != 0)\r\nprintk(KERN_ERR"vcpu:%p called cache_flush error!\n", vcpu);\r\ngr30 &= ~PAL_CACHE_FLUSH_CHK_INTRS;\r\nargs.cache_type = gr29;\r\nargs.operation = gr30;\r\nsmp_call_function(remote_pal_cache_flush,\r\n(void *)&args, 1);\r\nif (args.status != 0)\r\nprintk(KERN_ERR"pal_cache_flush error!,"\r\n"status:0x%lx\n", args.status);\r\nlocal_irq_save(psr);\r\nresult.status = ia64_pal_cache_flush(gr29, gr30, &result.v1,\r\n&result.v0);\r\nlocal_irq_restore(psr);\r\nif (result.status != 0)\r\nprintk(KERN_ERR"vcpu:%p crashed due to cache_flush err:%ld"\r\n"in1:%lx,in2:%lx\n",\r\nvcpu, result.status, gr29, gr30);\r\n#if 0\r\nif (gr29 == PAL_CACHE_TYPE_COHERENT) {\r\ncpus_setall(vcpu->arch.cache_coherent_map);\r\ncpu_clear(vcpu->cpu, vcpu->arch.cache_coherent_map);\r\ncpus_setall(cpu_cache_coherent_map);\r\ncpu_clear(vcpu->cpu, cpu_cache_coherent_map);\r\n}\r\n#endif\r\nreturn result;\r\n}\r\nstruct ia64_pal_retval pal_cache_summary(struct kvm_vcpu *vcpu)\r\n{\r\nstruct ia64_pal_retval result;\r\nPAL_CALL(result, PAL_CACHE_SUMMARY, 0, 0, 0);\r\nreturn result;\r\n}\r\nstatic struct ia64_pal_retval pal_freq_base(struct kvm_vcpu *vcpu)\r\n{\r\nstruct ia64_pal_retval result;\r\nPAL_CALL(result, PAL_FREQ_BASE, 0, 0, 0);\r\nif (result.v0 == 0) {\r\nresult.status = ia64_sal_freq_base(SAL_FREQ_BASE_PLATFORM,\r\n&result.v0,\r\n&result.v1);\r\nresult.v2 = 0;\r\n}\r\nreturn result;\r\n}\r\nstatic void sn2_patch_itc_freq_ratios(struct ia64_pal_retval *result)\r\n{\r\nstruct pal_freq_ratio *ratio;\r\nunsigned long sal_freq, sal_drift, factor;\r\nresult->status = ia64_sal_freq_base(SAL_FREQ_BASE_PLATFORM,\r\n&sal_freq, &sal_drift);\r\nratio = (struct pal_freq_ratio *)&result->v2;\r\nfactor = ((sal_freq * 3) + (sn_rtc_cycles_per_second / 2)) /\r\nsn_rtc_cycles_per_second;\r\nratio->num = 3;\r\nratio->den = factor;\r\n}\r\nstatic struct ia64_pal_retval pal_freq_ratios(struct kvm_vcpu *vcpu)\r\n{\r\nstruct ia64_pal_retval result;\r\nPAL_CALL(result, PAL_FREQ_RATIOS, 0, 0, 0);\r\nif (vcpu->kvm->arch.is_sn2)\r\nsn2_patch_itc_freq_ratios(&result);\r\nreturn result;\r\n}\r\nstatic struct ia64_pal_retval pal_logical_to_physica(struct kvm_vcpu *vcpu)\r\n{\r\nstruct ia64_pal_retval result;\r\nINIT_PAL_STATUS_UNIMPLEMENTED(result);\r\nreturn result;\r\n}\r\nstatic struct ia64_pal_retval pal_platform_addr(struct kvm_vcpu *vcpu)\r\n{\r\nstruct ia64_pal_retval result;\r\nINIT_PAL_STATUS_SUCCESS(result);\r\nreturn result;\r\n}\r\nstatic struct ia64_pal_retval pal_proc_get_features(struct kvm_vcpu *vcpu)\r\n{\r\nstruct ia64_pal_retval result = {0, 0, 0, 0};\r\nlong in0, in1, in2, in3;\r\nkvm_get_pal_call_data(vcpu, &in0, &in1, &in2, &in3);\r\nresult.status = ia64_pal_proc_get_features(&result.v0, &result.v1,\r\n&result.v2, in2);\r\nreturn result;\r\n}\r\nstatic struct ia64_pal_retval pal_register_info(struct kvm_vcpu *vcpu)\r\n{\r\nstruct ia64_pal_retval result = {0, 0, 0, 0};\r\nlong in0, in1, in2, in3;\r\nkvm_get_pal_call_data(vcpu, &in0, &in1, &in2, &in3);\r\nresult.status = ia64_pal_register_info(in1, &result.v1, &result.v2);\r\nreturn result;\r\n}\r\nstatic struct ia64_pal_retval pal_cache_info(struct kvm_vcpu *vcpu)\r\n{\r\npal_cache_config_info_t ci;\r\nlong status;\r\nunsigned long in0, in1, in2, in3, r9, r10;\r\nkvm_get_pal_call_data(vcpu, &in0, &in1, &in2, &in3);\r\nstatus = ia64_pal_cache_config_info(in1, in2, &ci);\r\nr9 = ci.pcci_info_1.pcci1_data;\r\nr10 = ci.pcci_info_2.pcci2_data;\r\nreturn ((struct ia64_pal_retval){status, r9, r10, 0});\r\n}\r\nstatic struct ia64_pal_retval pal_vm_summary(struct kvm_vcpu *vcpu)\r\n{\r\npal_vm_info_1_u_t vminfo1;\r\npal_vm_info_2_u_t vminfo2;\r\nstruct ia64_pal_retval result;\r\nPAL_CALL(result, PAL_VM_SUMMARY, 0, 0, 0);\r\nif (!result.status) {\r\nvminfo1.pvi1_val = result.v0;\r\nvminfo1.pal_vm_info_1_s.max_itr_entry = 8;\r\nvminfo1.pal_vm_info_1_s.max_dtr_entry = 8;\r\nresult.v0 = vminfo1.pvi1_val;\r\nvminfo2.pal_vm_info_2_s.impl_va_msb = GUEST_IMPL_VA_MSB;\r\nvminfo2.pal_vm_info_2_s.rid_size = GUEST_RID_BITS;\r\nresult.v1 = vminfo2.pvi2_val;\r\n}\r\nreturn result;\r\n}\r\nstatic struct ia64_pal_retval pal_vm_info(struct kvm_vcpu *vcpu)\r\n{\r\nstruct ia64_pal_retval result;\r\nunsigned long in0, in1, in2, in3;\r\nkvm_get_pal_call_data(vcpu, &in0, &in1, &in2, &in3);\r\nresult.status = ia64_pal_vm_info(in1, in2,\r\n(pal_tc_info_u_t *)&result.v1, &result.v2);\r\nreturn result;\r\n}\r\nstatic u64 kvm_get_pal_call_index(struct kvm_vcpu *vcpu)\r\n{\r\nu64 index = 0;\r\nstruct exit_ctl_data *p;\r\np = kvm_get_exit_data(vcpu);\r\nif (p->exit_reason == EXIT_REASON_PAL_CALL)\r\nindex = p->u.pal_data.gr28;\r\nreturn index;\r\n}\r\nstatic void prepare_for_halt(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->arch.timer_pending = 1;\r\nvcpu->arch.timer_fired = 0;\r\n}\r\nstatic struct ia64_pal_retval pal_perf_mon_info(struct kvm_vcpu *vcpu)\r\n{\r\nlong status;\r\nunsigned long in0, in1, in2, in3, r9;\r\nunsigned long pm_buffer[16];\r\nkvm_get_pal_call_data(vcpu, &in0, &in1, &in2, &in3);\r\nstatus = ia64_pal_perf_mon_info(pm_buffer,\r\n(pal_perf_mon_info_u_t *) &r9);\r\nif (status != 0) {\r\nprintk(KERN_DEBUG"PAL_PERF_MON_INFO fails ret=%ld\n", status);\r\n} else {\r\nif (in1)\r\nmemcpy((void *)in1, pm_buffer, sizeof(pm_buffer));\r\nelse {\r\nstatus = PAL_STATUS_EINVAL;\r\nprintk(KERN_WARNING"Invalid parameters "\r\n"for PAL call:0x%lx!\n", in0);\r\n}\r\n}\r\nreturn (struct ia64_pal_retval){status, r9, 0, 0};\r\n}\r\nstatic struct ia64_pal_retval pal_halt_info(struct kvm_vcpu *vcpu)\r\n{\r\nunsigned long in0, in1, in2, in3;\r\nlong status;\r\nunsigned long res = 1000UL | (1000UL << 16) | (10UL << 32)\r\n| (1UL << 61) | (1UL << 60);\r\nkvm_get_pal_call_data(vcpu, &in0, &in1, &in2, &in3);\r\nif (in1) {\r\nmemcpy((void *)in1, &res, sizeof(res));\r\nstatus = 0;\r\n} else{\r\nstatus = PAL_STATUS_EINVAL;\r\nprintk(KERN_WARNING"Invalid parameters "\r\n"for PAL call:0x%lx!\n", in0);\r\n}\r\nreturn (struct ia64_pal_retval){status, 0, 0, 0};\r\n}\r\nstatic struct ia64_pal_retval pal_mem_attrib(struct kvm_vcpu *vcpu)\r\n{\r\nunsigned long r9;\r\nlong status;\r\nstatus = ia64_pal_mem_attrib(&r9);\r\nreturn (struct ia64_pal_retval){status, r9, 0, 0};\r\n}\r\nstatic void remote_pal_prefetch_visibility(void *v)\r\n{\r\ns64 trans_type = (s64)v;\r\nia64_pal_prefetch_visibility(trans_type);\r\n}\r\nstatic struct ia64_pal_retval pal_prefetch_visibility(struct kvm_vcpu *vcpu)\r\n{\r\nstruct ia64_pal_retval result = {0, 0, 0, 0};\r\nunsigned long in0, in1, in2, in3;\r\nkvm_get_pal_call_data(vcpu, &in0, &in1, &in2, &in3);\r\nresult.status = ia64_pal_prefetch_visibility(in1);\r\nif (result.status == 0) {\r\nsmp_call_function(remote_pal_prefetch_visibility,\r\n(void *)in1, 1);\r\nresult.status = 1;\r\n}\r\nreturn result;\r\n}\r\nstatic void remote_pal_mc_drain(void *v)\r\n{\r\nia64_pal_mc_drain();\r\n}\r\nstatic struct ia64_pal_retval pal_get_brand_info(struct kvm_vcpu *vcpu)\r\n{\r\nstruct ia64_pal_retval result = {0, 0, 0, 0};\r\nunsigned long in0, in1, in2, in3;\r\nkvm_get_pal_call_data(vcpu, &in0, &in1, &in2, &in3);\r\nif (in1 == 0 && in2) {\r\nchar brand_info[128];\r\nresult.status = ia64_pal_get_brand_info(brand_info);\r\nif (result.status == PAL_STATUS_SUCCESS)\r\nmemcpy((void *)in2, brand_info, 128);\r\n} else {\r\nresult.status = PAL_STATUS_REQUIRES_MEMORY;\r\nprintk(KERN_WARNING"Invalid parameters for "\r\n"PAL call:0x%lx!\n", in0);\r\n}\r\nreturn result;\r\n}\r\nint kvm_pal_emul(struct kvm_vcpu *vcpu, struct kvm_run *run)\r\n{\r\nu64 gr28;\r\nstruct ia64_pal_retval result;\r\nint ret = 1;\r\ngr28 = kvm_get_pal_call_index(vcpu);\r\nswitch (gr28) {\r\ncase PAL_CACHE_FLUSH:\r\nresult = pal_cache_flush(vcpu);\r\nbreak;\r\ncase PAL_MEM_ATTRIB:\r\nresult = pal_mem_attrib(vcpu);\r\nbreak;\r\ncase PAL_CACHE_SUMMARY:\r\nresult = pal_cache_summary(vcpu);\r\nbreak;\r\ncase PAL_PERF_MON_INFO:\r\nresult = pal_perf_mon_info(vcpu);\r\nbreak;\r\ncase PAL_HALT_INFO:\r\nresult = pal_halt_info(vcpu);\r\nbreak;\r\ncase PAL_HALT_LIGHT:\r\n{\r\nINIT_PAL_STATUS_SUCCESS(result);\r\nprepare_for_halt(vcpu);\r\nif (kvm_highest_pending_irq(vcpu) == -1)\r\nret = kvm_emulate_halt(vcpu);\r\n}\r\nbreak;\r\ncase PAL_PREFETCH_VISIBILITY:\r\nresult = pal_prefetch_visibility(vcpu);\r\nbreak;\r\ncase PAL_MC_DRAIN:\r\nresult.status = ia64_pal_mc_drain();\r\nsmp_call_function(remote_pal_mc_drain, NULL, 1);\r\nbreak;\r\ncase PAL_FREQ_RATIOS:\r\nresult = pal_freq_ratios(vcpu);\r\nbreak;\r\ncase PAL_FREQ_BASE:\r\nresult = pal_freq_base(vcpu);\r\nbreak;\r\ncase PAL_LOGICAL_TO_PHYSICAL :\r\nresult = pal_logical_to_physica(vcpu);\r\nbreak;\r\ncase PAL_VM_SUMMARY :\r\nresult = pal_vm_summary(vcpu);\r\nbreak;\r\ncase PAL_VM_INFO :\r\nresult = pal_vm_info(vcpu);\r\nbreak;\r\ncase PAL_PLATFORM_ADDR :\r\nresult = pal_platform_addr(vcpu);\r\nbreak;\r\ncase PAL_CACHE_INFO:\r\nresult = pal_cache_info(vcpu);\r\nbreak;\r\ncase PAL_PTCE_INFO:\r\nINIT_PAL_STATUS_SUCCESS(result);\r\nresult.v1 = (1L << 32) | 1L;\r\nbreak;\r\ncase PAL_REGISTER_INFO:\r\nresult = pal_register_info(vcpu);\r\nbreak;\r\ncase PAL_VM_PAGE_SIZE:\r\nresult.status = ia64_pal_vm_page_size(&result.v0,\r\n&result.v1);\r\nbreak;\r\ncase PAL_RSE_INFO:\r\nresult.status = ia64_pal_rse_info(&result.v0,\r\n(pal_hints_u_t *)&result.v1);\r\nbreak;\r\ncase PAL_PROC_GET_FEATURES:\r\nresult = pal_proc_get_features(vcpu);\r\nbreak;\r\ncase PAL_DEBUG_INFO:\r\nresult.status = ia64_pal_debug_info(&result.v0,\r\n&result.v1);\r\nbreak;\r\ncase PAL_VERSION:\r\nresult.status = ia64_pal_version(\r\n(pal_version_u_t *)&result.v0,\r\n(pal_version_u_t *)&result.v1);\r\nbreak;\r\ncase PAL_FIXED_ADDR:\r\nresult.status = PAL_STATUS_SUCCESS;\r\nresult.v0 = vcpu->vcpu_id;\r\nbreak;\r\ncase PAL_BRAND_INFO:\r\nresult = pal_get_brand_info(vcpu);\r\nbreak;\r\ncase PAL_GET_PSTATE:\r\ncase PAL_CACHE_SHARED_INFO:\r\nINIT_PAL_STATUS_UNIMPLEMENTED(result);\r\nbreak;\r\ndefault:\r\nINIT_PAL_STATUS_UNIMPLEMENTED(result);\r\nprintk(KERN_WARNING"kvm: Unsupported pal call,"\r\n" index:0x%lx\n", gr28);\r\n}\r\nset_pal_result(vcpu, result);\r\nreturn ret;\r\n}\r\nstatic struct sal_ret_values sal_emulator(struct kvm *kvm,\r\nlong index, unsigned long in1,\r\nunsigned long in2, unsigned long in3,\r\nunsigned long in4, unsigned long in5,\r\nunsigned long in6, unsigned long in7)\r\n{\r\nunsigned long r9 = 0;\r\nunsigned long r10 = 0;\r\nlong r11 = 0;\r\nlong status;\r\nstatus = 0;\r\nswitch (index) {\r\ncase SAL_FREQ_BASE:\r\nstatus = ia64_sal_freq_base(in1, &r9, &r10);\r\nbreak;\r\ncase SAL_PCI_CONFIG_READ:\r\nprintk(KERN_WARNING"kvm: Not allowed to call here!"\r\n" SAL_PCI_CONFIG_READ\n");\r\nbreak;\r\ncase SAL_PCI_CONFIG_WRITE:\r\nprintk(KERN_WARNING"kvm: Not allowed to call here!"\r\n" SAL_PCI_CONFIG_WRITE\n");\r\nbreak;\r\ncase SAL_SET_VECTORS:\r\nif (in1 == SAL_VECTOR_OS_BOOT_RENDEZ) {\r\nif (in4 != 0 || in5 != 0 || in6 != 0 || in7 != 0) {\r\nstatus = -2;\r\n} else {\r\nkvm->arch.rdv_sal_data.boot_ip = in2;\r\nkvm->arch.rdv_sal_data.boot_gp = in3;\r\n}\r\nprintk("Rendvous called! iip:%lx\n\n", in2);\r\n} else\r\nprintk(KERN_WARNING"kvm: CALLED SAL_SET_VECTORS %lu."\r\n"ignored...\n", in1);\r\nbreak;\r\ncase SAL_GET_STATE_INFO:\r\nstatus = -5;\r\nr9 = 0;\r\nbreak;\r\ncase SAL_GET_STATE_INFO_SIZE:\r\nstatus = 0;\r\nr9 = 128;\r\nbreak;\r\ncase SAL_CLEAR_STATE_INFO:\r\nbreak;\r\ncase SAL_MC_RENDEZ:\r\nprintk(KERN_WARNING\r\n"kvm: called SAL_MC_RENDEZ. ignored...\n");\r\nbreak;\r\ncase SAL_MC_SET_PARAMS:\r\nprintk(KERN_WARNING\r\n"kvm: called SAL_MC_SET_PARAMS.ignored!\n");\r\nbreak;\r\ncase SAL_CACHE_FLUSH:\r\nif (1) {\r\nstatus = ia64_sal_cache_flush(in1);\r\n} else {\r\nstatus = 0;\r\n}\r\nbreak;\r\ncase SAL_CACHE_INIT:\r\nprintk(KERN_WARNING\r\n"kvm: called SAL_CACHE_INIT. ignored...\n");\r\nbreak;\r\ncase SAL_UPDATE_PAL:\r\nprintk(KERN_WARNING\r\n"kvm: CALLED SAL_UPDATE_PAL. ignored...\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING"kvm: called SAL_CALL with unknown index."\r\n" index:%ld\n", index);\r\nstatus = -1;\r\nbreak;\r\n}\r\nreturn ((struct sal_ret_values) {status, r9, r10, r11});\r\n}\r\nstatic void kvm_get_sal_call_data(struct kvm_vcpu *vcpu, u64 *in0, u64 *in1,\r\nu64 *in2, u64 *in3, u64 *in4, u64 *in5, u64 *in6, u64 *in7){\r\nstruct exit_ctl_data *p;\r\np = kvm_get_exit_data(vcpu);\r\nif (p->exit_reason == EXIT_REASON_SAL_CALL) {\r\n*in0 = p->u.sal_data.in0;\r\n*in1 = p->u.sal_data.in1;\r\n*in2 = p->u.sal_data.in2;\r\n*in3 = p->u.sal_data.in3;\r\n*in4 = p->u.sal_data.in4;\r\n*in5 = p->u.sal_data.in5;\r\n*in6 = p->u.sal_data.in6;\r\n*in7 = p->u.sal_data.in7;\r\nreturn ;\r\n}\r\n*in0 = 0;\r\n}\r\nvoid kvm_sal_emul(struct kvm_vcpu *vcpu)\r\n{\r\nstruct sal_ret_values result;\r\nu64 index, in1, in2, in3, in4, in5, in6, in7;\r\nkvm_get_sal_call_data(vcpu, &index, &in1, &in2,\r\n&in3, &in4, &in5, &in6, &in7);\r\nresult = sal_emulator(vcpu->kvm, index, in1, in2, in3,\r\nin4, in5, in6, in7);\r\nset_sal_result(vcpu, result);\r\n}
