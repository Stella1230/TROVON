static void rate_control_pid_event(struct rc_pid_event_buffer *buf,\r\nenum rc_pid_event_type type,\r\nunion rc_pid_event_data *data)\r\n{\r\nstruct rc_pid_event *ev;\r\nunsigned long status;\r\nspin_lock_irqsave(&buf->lock, status);\r\nev = &(buf->ring[buf->next_entry]);\r\nbuf->next_entry = (buf->next_entry + 1) % RC_PID_EVENT_RING_SIZE;\r\nev->timestamp = jiffies;\r\nev->id = buf->ev_count++;\r\nev->type = type;\r\nev->data = *data;\r\nspin_unlock_irqrestore(&buf->lock, status);\r\nwake_up_all(&buf->waitqueue);\r\n}\r\nvoid rate_control_pid_event_tx_status(struct rc_pid_event_buffer *buf,\r\nstruct ieee80211_tx_info *stat)\r\n{\r\nunion rc_pid_event_data evd;\r\nevd.flags = stat->flags;\r\nmemcpy(&evd.tx_status, stat, sizeof(struct ieee80211_tx_info));\r\nrate_control_pid_event(buf, RC_PID_EVENT_TYPE_TX_STATUS, &evd);\r\n}\r\nvoid rate_control_pid_event_rate_change(struct rc_pid_event_buffer *buf,\r\nint index, int rate)\r\n{\r\nunion rc_pid_event_data evd;\r\nevd.index = index;\r\nevd.rate = rate;\r\nrate_control_pid_event(buf, RC_PID_EVENT_TYPE_RATE_CHANGE, &evd);\r\n}\r\nvoid rate_control_pid_event_tx_rate(struct rc_pid_event_buffer *buf,\r\nint index, int rate)\r\n{\r\nunion rc_pid_event_data evd;\r\nevd.index = index;\r\nevd.rate = rate;\r\nrate_control_pid_event(buf, RC_PID_EVENT_TYPE_TX_RATE, &evd);\r\n}\r\nvoid rate_control_pid_event_pf_sample(struct rc_pid_event_buffer *buf,\r\ns32 pf_sample, s32 prop_err,\r\ns32 int_err, s32 der_err)\r\n{\r\nunion rc_pid_event_data evd;\r\nevd.pf_sample = pf_sample;\r\nevd.prop_err = prop_err;\r\nevd.int_err = int_err;\r\nevd.der_err = der_err;\r\nrate_control_pid_event(buf, RC_PID_EVENT_TYPE_PF_SAMPLE, &evd);\r\n}\r\nstatic int rate_control_pid_events_open(struct inode *inode, struct file *file)\r\n{\r\nstruct rc_pid_sta_info *sinfo = inode->i_private;\r\nstruct rc_pid_event_buffer *events = &sinfo->events;\r\nstruct rc_pid_events_file_info *file_info;\r\nunsigned long status;\r\nfile_info = kmalloc(sizeof(*file_info), GFP_KERNEL);\r\nif (file_info == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&events->lock, status);\r\nfile_info->next_entry = events->next_entry;\r\nfile_info->events = events;\r\nspin_unlock_irqrestore(&events->lock, status);\r\nfile->private_data = file_info;\r\nreturn 0;\r\n}\r\nstatic int rate_control_pid_events_release(struct inode *inode,\r\nstruct file *file)\r\n{\r\nstruct rc_pid_events_file_info *file_info = file->private_data;\r\nkfree(file_info);\r\nreturn 0;\r\n}\r\nstatic unsigned int rate_control_pid_events_poll(struct file *file,\r\npoll_table *wait)\r\n{\r\nstruct rc_pid_events_file_info *file_info = file->private_data;\r\npoll_wait(file, &file_info->events->waitqueue, wait);\r\nreturn POLLIN | POLLRDNORM;\r\n}\r\nstatic ssize_t rate_control_pid_events_read(struct file *file, char __user *buf,\r\nsize_t length, loff_t *offset)\r\n{\r\nstruct rc_pid_events_file_info *file_info = file->private_data;\r\nstruct rc_pid_event_buffer *events = file_info->events;\r\nstruct rc_pid_event *ev;\r\nchar pb[RC_PID_PRINT_BUF_SIZE];\r\nint ret;\r\nint p;\r\nunsigned long status;\r\nif (events->next_entry == file_info->next_entry) {\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible(events->waitqueue,\r\nevents->next_entry != file_info->next_entry);\r\nif (ret)\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&events->lock, status);\r\nev = &(events->ring[file_info->next_entry]);\r\nfile_info->next_entry = (file_info->next_entry + 1) %\r\nRC_PID_EVENT_RING_SIZE;\r\nlength = length < RC_PID_PRINT_BUF_SIZE ?\r\nlength : RC_PID_PRINT_BUF_SIZE;\r\np = snprintf(pb, length, "%u %lu ", ev->id, ev->timestamp);\r\nswitch (ev->type) {\r\ncase RC_PID_EVENT_TYPE_TX_STATUS:\r\np += snprintf(pb + p, length - p, "tx_status %u %u",\r\n!(ev->data.flags & IEEE80211_TX_STAT_ACK),\r\nev->data.tx_status.status.rates[0].idx);\r\nbreak;\r\ncase RC_PID_EVENT_TYPE_RATE_CHANGE:\r\np += snprintf(pb + p, length - p, "rate_change %d %d",\r\nev->data.index, ev->data.rate);\r\nbreak;\r\ncase RC_PID_EVENT_TYPE_TX_RATE:\r\np += snprintf(pb + p, length - p, "tx_rate %d %d",\r\nev->data.index, ev->data.rate);\r\nbreak;\r\ncase RC_PID_EVENT_TYPE_PF_SAMPLE:\r\np += snprintf(pb + p, length - p,\r\n"pf_sample %d %d %d %d",\r\nev->data.pf_sample, ev->data.prop_err,\r\nev->data.int_err, ev->data.der_err);\r\nbreak;\r\n}\r\np += snprintf(pb + p, length - p, "\n");\r\nspin_unlock_irqrestore(&events->lock, status);\r\nif (copy_to_user(buf, pb, p))\r\nreturn -EFAULT;\r\nreturn p;\r\n}\r\nvoid rate_control_pid_add_sta_debugfs(void *priv, void *priv_sta,\r\nstruct dentry *dir)\r\n{\r\nstruct rc_pid_sta_info *spinfo = priv_sta;\r\nspinfo->events_entry = debugfs_create_file("rc_pid_events", S_IRUGO,\r\ndir, spinfo,\r\n&rc_pid_fop_events);\r\n}\r\nvoid rate_control_pid_remove_sta_debugfs(void *priv, void *priv_sta)\r\n{\r\nstruct rc_pid_sta_info *spinfo = priv_sta;\r\ndebugfs_remove(spinfo->events_entry);\r\n}
