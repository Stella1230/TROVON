static void pcm043_ac97_warm_reset(struct snd_ac97 *ac97)\r\n{\r\niomux_v3_cfg_t txfs_gpio = MX35_PAD_STXFS4__GPIO2_31;\r\niomux_v3_cfg_t txfs = MX35_PAD_STXFS4__AUDMUX_AUD4_TXFS;\r\nint ret;\r\nret = gpio_request(AC97_GPIO_TXFS, "SSI");\r\nif (ret) {\r\nprintk("failed to get GPIO_TXFS: %d\n", ret);\r\nreturn;\r\n}\r\nmxc_iomux_v3_setup_pad(txfs_gpio);\r\ngpio_direction_output(AC97_GPIO_TXFS, 1);\r\nudelay(2);\r\ngpio_set_value(AC97_GPIO_TXFS, 0);\r\ngpio_free(AC97_GPIO_TXFS);\r\nmxc_iomux_v3_setup_pad(txfs);\r\n}\r\nstatic void pcm043_ac97_cold_reset(struct snd_ac97 *ac97)\r\n{\r\niomux_v3_cfg_t txfs_gpio = MX35_PAD_STXFS4__GPIO2_31;\r\niomux_v3_cfg_t txfs = MX35_PAD_STXFS4__AUDMUX_AUD4_TXFS;\r\niomux_v3_cfg_t txd_gpio = MX35_PAD_STXD4__GPIO2_28;\r\niomux_v3_cfg_t txd = MX35_PAD_STXD4__AUDMUX_AUD4_TXD;\r\niomux_v3_cfg_t reset_gpio = MX35_PAD_SD2_CMD__GPIO2_0;\r\nint ret;\r\nret = gpio_request(AC97_GPIO_TXFS, "SSI");\r\nif (ret)\r\ngoto err1;\r\nret = gpio_request(AC97_GPIO_TXD, "SSI");\r\nif (ret)\r\ngoto err2;\r\nret = gpio_request(AC97_GPIO_RESET, "SSI");\r\nif (ret)\r\ngoto err3;\r\nmxc_iomux_v3_setup_pad(txfs_gpio);\r\nmxc_iomux_v3_setup_pad(txd_gpio);\r\nmxc_iomux_v3_setup_pad(reset_gpio);\r\ngpio_direction_output(AC97_GPIO_TXFS, 0);\r\ngpio_direction_output(AC97_GPIO_TXD, 0);\r\ngpio_direction_output(AC97_GPIO_RESET, 0);\r\nudelay(10);\r\ngpio_direction_output(AC97_GPIO_RESET, 1);\r\nmxc_iomux_v3_setup_pad(txd);\r\nmxc_iomux_v3_setup_pad(txfs);\r\ngpio_free(AC97_GPIO_RESET);\r\nerr3:\r\ngpio_free(AC97_GPIO_TXD);\r\nerr2:\r\ngpio_free(AC97_GPIO_TXFS);\r\nerr1:\r\nif (ret)\r\nprintk("%s failed with %d\n", __func__, ret);\r\nmdelay(1);\r\n}\r\nstatic int pcm043_otg_init(struct platform_device *pdev)\r\n{\r\nreturn mx35_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_DIFF_UNI);\r\n}\r\nstatic int pcm043_usbh1_init(struct platform_device *pdev)\r\n{\r\nreturn mx35_initialize_usb_hw(pdev->id, MXC_EHCI_INTERFACE_SINGLE_UNI |\r\nMXC_EHCI_INTERNAL_PHY | MXC_EHCI_IPPUE_DOWN);\r\n}\r\nstatic int __init pcm043_otg_mode(char *options)\r\n{\r\nif (!strcmp(options, "host"))\r\notg_mode_host = true;\r\nelse if (!strcmp(options, "device"))\r\notg_mode_host = false;\r\nelse\r\npr_info("otg_mode neither \"host\" nor \"device\". "\r\n"Defaulting to device\n");\r\nreturn 1;\r\n}\r\nstatic void __init pcm043_init(void)\r\n{\r\nimx35_soc_init();\r\nmxc_iomux_v3_setup_multiple_pads(pcm043_pads, ARRAY_SIZE(pcm043_pads));\r\nimx35_add_fec(NULL);\r\nplatform_add_devices(devices, ARRAY_SIZE(devices));\r\nimx35_add_imx2_wdt();\r\nimx35_add_imx_uart0(&uart_pdata);\r\nimx35_add_mxc_nand(&pcm037_nand_board_info);\r\nimx35_add_imx_ssi(0, &pcm043_ssi_pdata);\r\nimx35_add_imx_uart1(&uart_pdata);\r\ni2c_register_board_info(0, pcm043_i2c_devices,\r\nARRAY_SIZE(pcm043_i2c_devices));\r\nimx35_add_imx_i2c0(&pcm043_i2c0_data);\r\nimx35_add_ipu_core();\r\nimx35_add_mx3_sdc_fb(&mx3fb_pdata);\r\nif (otg_mode_host) {\r\notg_pdata.otg = imx_otg_ulpi_create(ULPI_OTG_DRVVBUS |\r\nULPI_OTG_DRVVBUS_EXT);\r\nif (otg_pdata.otg)\r\nimx35_add_mxc_ehci_otg(&otg_pdata);\r\n}\r\nimx35_add_mxc_ehci_hs(&usbh1_pdata);\r\nif (!otg_mode_host)\r\nimx35_add_fsl_usb2_udc(&otg_device_pdata);\r\nimx35_add_flexcan1(NULL);\r\nimx35_add_sdhci_esdhc_imx(0, &sd1_pdata);\r\n}\r\nstatic void __init pcm043_timer_init(void)\r\n{\r\nmx35_clocks_init();\r\n}
