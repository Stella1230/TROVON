int\r\nconvert_sme_error(CsrResult error)\r\n{\r\nswitch (error) {\r\ncase CSR_RESULT_SUCCESS:\r\nreturn 0;\r\ncase CSR_RESULT_FAILURE:\r\ncase CSR_WIFI_RESULT_NOT_FOUND:\r\ncase CSR_WIFI_RESULT_TIMED_OUT:\r\ncase CSR_WIFI_RESULT_CANCELLED:\r\ncase CSR_WIFI_RESULT_UNAVAILABLE:\r\nreturn -EIO;\r\ncase CSR_WIFI_RESULT_NO_ROOM:\r\nreturn -EBUSY;\r\ncase CSR_WIFI_RESULT_INVALID_PARAMETER:\r\nreturn -EINVAL;\r\ncase CSR_WIFI_RESULT_UNSUPPORTED:\r\nreturn -EOPNOTSUPP;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nvoid\r\nsme_log_event(ul_client_t *pcli,\r\nconst u8 *signal, int signal_len,\r\nconst bulk_data_param_t *bulkdata,\r\nint dir)\r\n{\r\nunifi_priv_t *priv;\r\nCSR_SIGNAL unpacked_signal;\r\nCsrWifiSmeDataBlock mlmeCommand;\r\nCsrWifiSmeDataBlock dataref1;\r\nCsrWifiSmeDataBlock dataref2;\r\nCsrResult result = CSR_RESULT_SUCCESS;\r\nint r;\r\nfunc_enter();\r\nif ((signal == NULL) || (signal_len <= 0)) {\r\nfunc_exit();\r\nreturn;\r\n}\r\npriv = uf_find_instance(pcli->instance);\r\nif (!priv) {\r\nunifi_error(priv, "sme_log_event: invalid priv\n");\r\nfunc_exit();\r\nreturn;\r\n}\r\nif (priv->smepriv == NULL) {\r\nunifi_error(priv, "sme_log_event: invalid smepriv\n");\r\nfunc_exit();\r\nreturn;\r\n}\r\nunifi_trace(priv, UDBG3,\r\n"sme_log_event: Process signal 0x%.4X\n",\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN(signal));\r\nr = read_unpack_signal(signal, &unpacked_signal);\r\nif (r == CSR_RESULT_SUCCESS) {\r\nif ((unpacked_signal.SignalPrimitiveHeader.SignalId == CSR_DEBUG_STRING_INDICATION_ID) ||\r\n(unpacked_signal.SignalPrimitiveHeader.SignalId == CSR_DEBUG_WORD16_INDICATION_ID))\r\n{\r\nfunc_exit();\r\nreturn;\r\n}\r\nif (unpacked_signal.SignalPrimitiveHeader.SignalId == CSR_MA_PACKET_INDICATION_ID)\r\n{\r\nu16 frmCtrl;\r\nu8 unicastPdu = TRUE;\r\nu8 *macHdrLocation;\r\nu8 *raddr = NULL, *taddr = NULL;\r\nCsrWifiMacAddress peerMacAddress;\r\nCSR_MA_PACKET_INDICATION *ind = &unpacked_signal.u.MaPacketIndication;\r\nmacHdrLocation = (u8 *) bulkdata->d[0].os_data_ptr;\r\nfrmCtrl = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(macHdrLocation);\r\nraddr = macHdrLocation + MAC_HEADER_ADDR1_OFFSET;\r\ntaddr = macHdrLocation + MAC_HEADER_ADDR2_OFFSET;\r\nmemcpy(peerMacAddress.a, taddr, ETH_ALEN);\r\nif(ind->ReceptionStatus == CSR_MICHAEL_MIC_ERROR)\r\n{\r\nif (*raddr & 0x1)\r\nunicastPdu = FALSE;\r\nCsrWifiRouterCtrlMicFailureIndSend (priv->CSR_WIFI_SME_IFACEQUEUE, 0,\r\n(ind->VirtualInterfaceIdentifier & 0xff),peerMacAddress,\r\nunicastPdu);\r\nreturn;\r\n}\r\nelse\r\n{\r\nif(ind->ReceptionStatus == CSR_RX_SUCCESS)\r\n{\r\nu8 pmBit = (frmCtrl & 0x1000)?0x01:0x00;\r\nu16 interfaceTag = (ind->VirtualInterfaceIdentifier & 0xff);\r\nCsrWifiRouterCtrlStaInfo_t *srcStaInfo = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv,taddr,interfaceTag);\r\nif((srcStaInfo != NULL) && (uf_check_broadcast_bssid(priv, bulkdata)== FALSE))\r\n{\r\nuf_process_pm_bit_for_peer(priv,srcStaInfo,pmBit,interfaceTag);\r\nsrcStaInfo->activity_flag = TRUE;\r\n}\r\n}\r\n}\r\n}\r\nif (unpacked_signal.SignalPrimitiveHeader.SignalId == CSR_MA_PACKET_CONFIRM_ID)\r\n{\r\nCSR_MA_PACKET_CONFIRM *cfm = &unpacked_signal.u.MaPacketConfirm;\r\nu16 interfaceTag = (cfm->VirtualInterfaceIdentifier & 0xff);\r\nnetInterface_priv_t *interfacePriv;\r\nCSR_MA_PACKET_REQUEST *req;\r\nCsrWifiMacAddress peerMacAddress;\r\nif (interfaceTag >= CSR_WIFI_NUM_INTERFACES)\r\n{\r\nunifi_error(priv, "Bad MA_PACKET_CONFIRM interfaceTag %d\n", interfaceTag);\r\nfunc_exit();\r\nreturn;\r\n}\r\nunifi_trace(priv,UDBG1,"MA-PACKET Confirm (%x, %x)\n", cfm->HostTag, cfm->TransmissionStatus);\r\ninterfacePriv = priv->interfacePriv[interfaceTag];\r\n#ifdef CSR_SUPPORT_SME\r\nif(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||\r\ninterfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) {\r\nif(cfm->HostTag == interfacePriv->multicastPduHostTag){\r\nuf_process_ma_pkt_cfm_for_ap(priv ,interfaceTag, cfm);\r\n}\r\n}\r\n#endif\r\nreq = &interfacePriv->m4_signal.u.MaPacketRequest;\r\nif(cfm->HostTag & 0x80000000)\r\n{\r\nif (cfm->TransmissionStatus != CSR_TX_SUCCESSFUL)\r\n{\r\nresult = CSR_RESULT_FAILURE;\r\n}\r\n#ifdef CSR_SUPPORT_SME\r\nmemcpy(peerMacAddress.a, req->Ra.x, ETH_ALEN);\r\nif (interfacePriv->m4_sent && (cfm->HostTag == interfacePriv->m4_hostTag))\r\n{\r\nunifi_trace(priv, UDBG1, "%s: Sending M4 Transmit CFM\n", __FUNCTION__);\r\nCsrWifiRouterCtrlM4TransmittedIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, 0,\r\ninterfaceTag,\r\npeerMacAddress,\r\nresult);\r\ninterfacePriv->m4_sent = FALSE;\r\ninterfacePriv->m4_hostTag = 0xffffffff;\r\n}\r\n#endif\r\nif((cfm->HostTag & 0x80000000) != CSR_WIFI_EAPOL_M4_HOST_TAG) {\r\nCsrWifiRouterMaPacketCfmSend((u16)signal[2],\r\ncfm->VirtualInterfaceIdentifier,\r\nresult,\r\n(cfm->HostTag & 0x3fffffff), cfm->Rate);\r\n} else {\r\nunifi_trace(priv, UDBG1, "%s: M4 received from netdevice\n", __FUNCTION__);\r\n}\r\nfunc_exit();\r\nreturn;\r\n}\r\n}\r\n}\r\nmlmeCommand.length = signal_len;\r\nmlmeCommand.data = (u8*)signal;\r\ndataref1.length = bulkdata->d[0].data_length;\r\nif (dataref1.length > 0) {\r\ndataref1.data = (u8 *) bulkdata->d[0].os_data_ptr;\r\n} else\r\n{\r\ndataref1.data = NULL;\r\n}\r\ndataref2.length = bulkdata->d[1].data_length;\r\nif (dataref2.length > 0) {\r\ndataref2.data = (u8 *) bulkdata->d[1].os_data_ptr;\r\n} else\r\n{\r\ndataref2.data = NULL;\r\n}\r\nCsrWifiRouterCtrlHipIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, mlmeCommand.length, mlmeCommand.data,\r\ndataref1.length, dataref1.data,\r\ndataref2.length, dataref2.data);\r\nfunc_exit();\r\n}\r\nCsrWifiRouterCtrlPortAction\r\nuf_sme_port_state(unifi_priv_t *priv, unsigned char *address, int queue, u16 interfaceTag)\r\n{\r\nint i;\r\nunifi_port_config_t *port;\r\nnetInterface_priv_t *interfacePriv;\r\nif (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {\r\nunifi_error(priv, "uf_sme_port_state: bad interfaceTag\n");\r\nreturn CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD;\r\n}\r\ninterfacePriv = priv->interfacePriv[interfaceTag];\r\nif (queue == UF_CONTROLLED_PORT_Q) {\r\nport = &interfacePriv->controlled_data_port;\r\n} else {\r\nport = &interfacePriv->uncontrolled_data_port;\r\n}\r\nif (!port->entries_in_use) {\r\nunifi_trace(priv, UDBG5, "No port configurations, return Discard.\n");\r\nreturn CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD;\r\n}\r\nif (port->overide_action == UF_DATA_PORT_OVERIDE) {\r\nunifi_trace(priv, UDBG5, "Single port configuration (%d).\n",\r\nport->port_cfg[0].port_action);\r\nreturn port->port_cfg[0].port_action;\r\n}\r\nunifi_trace(priv, UDBG5, "Multiple (%d) port configurations.\n", port->entries_in_use);\r\nfor (i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {\r\nif (port->port_cfg[i].in_use &&\r\nmemcmp(address, port->port_cfg[i].mac_address.a, ETH_ALEN) == 0) {\r\nreturn port->port_cfg[i].port_action;\r\n}\r\n}\r\nunifi_trace(priv, UDBG5, "port configuration not found, return Open.\n");\r\nreturn CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_OPEN;\r\n}\r\nunifi_port_cfg_t*\r\nuf_sme_port_config_handle(unifi_priv_t *priv, unsigned char *address, int queue, u16 interfaceTag)\r\n{\r\nint i;\r\nunifi_port_config_t *port;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nif (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {\r\nunifi_error(priv, "uf_sme_port_config_handle: bad interfaceTag\n");\r\nreturn NULL;\r\n}\r\nif (queue == UF_CONTROLLED_PORT_Q) {\r\nport = &interfacePriv->controlled_data_port;\r\n} else {\r\nport = &interfacePriv->uncontrolled_data_port;\r\n}\r\nif (!port->entries_in_use) {\r\nunifi_trace(priv, UDBG5, "No port configurations, return Discard.\n");\r\nreturn NULL;\r\n}\r\nif (port->overide_action == UF_DATA_PORT_OVERIDE) {\r\nunifi_trace(priv, UDBG5, "Single port configuration (%d).\n",\r\nport->port_cfg[0].port_action);\r\nif (address) {\r\nunifi_trace(priv, UDBG5, "addr[0] = %x, addr[1] = %x, addr[2] = %x, addr[3] = %x\n", address[0], address[1], address[2], address[3]);\r\n}\r\nreturn &port->port_cfg[0];\r\n}\r\nunifi_trace(priv, UDBG5, "Multiple port configurations.\n");\r\nfor (i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {\r\nif (port->port_cfg[i].in_use &&\r\nmemcmp(address, port->port_cfg[i].mac_address.a, ETH_ALEN) == 0) {\r\nreturn &port->port_cfg[i];\r\n}\r\n}\r\nunifi_trace(priv, UDBG5, "port configuration not found, returning NULL (debug).\n");\r\nreturn NULL;\r\n}\r\nvoid\r\nuf_multicast_list_wq(struct work_struct *work)\r\n{\r\nunifi_priv_t *priv = container_of(work, unifi_priv_t,\r\nmulticast_list_task);\r\nint i;\r\nu16 interfaceTag = 0;\r\nCsrWifiMacAddress* multicast_address_list = NULL;\r\nint mc_count;\r\nu8 *mc_list;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nif (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {\r\nunifi_error(priv, "uf_multicast_list_wq: bad interfaceTag\n");\r\nreturn;\r\n}\r\nunifi_trace(priv, UDBG5,\r\n"uf_multicast_list_wq: list count = %d\n",\r\ninterfacePriv->mc_list_count);\r\nCsrWifiRouterCtrlMulticastAddressIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0, interfaceTag, CSR_WIFI_SME_LIST_ACTION_FLUSH, 0, NULL);\r\nmc_count = interfacePriv->mc_list_count;\r\nmc_list = interfacePriv->mc_list;\r\nmulticast_address_list = kmalloc(mc_count * sizeof(CsrWifiMacAddress), GFP_KERNEL);\r\nif (multicast_address_list == NULL) {\r\nreturn;\r\n}\r\nfor (i = 0; i < mc_count; i++) {\r\nmemcpy(multicast_address_list[i].a, mc_list, ETH_ALEN);\r\nmc_list += ETH_ALEN;\r\n}\r\nif (priv->smepriv == NULL) {\r\nkfree(multicast_address_list);\r\nreturn;\r\n}\r\nCsrWifiRouterCtrlMulticastAddressIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0,\r\ninterfaceTag,\r\nCSR_WIFI_SME_LIST_ACTION_ADD,\r\nmc_count, multicast_address_list);\r\nkfree(multicast_address_list);\r\n}\r\nint unifi_cfg_power(unifi_priv_t *priv, unsigned char *arg)\r\n{\r\nunifi_cfg_power_t cfg_power;\r\nint rc;\r\nint wol;\r\nif (get_user(cfg_power, (unifi_cfg_power_t*)(((unifi_cfg_command_t*)arg) + 1))) {\r\nunifi_error(priv, "UNIFI_CFG: Failed to get the argument\n");\r\nreturn -EFAULT;\r\n}\r\nswitch (cfg_power) {\r\ncase UNIFI_CFG_POWER_OFF:\r\npriv->wol_suspend = (enable_wol == UNIFI_WOL_OFF) ? FALSE : TRUE;\r\nrc = sme_sys_suspend(priv);\r\nif (rc) {\r\nreturn rc;\r\n}\r\nbreak;\r\ncase UNIFI_CFG_POWER_ON:\r\nwol = priv->wol_suspend;\r\nrc = sme_sys_resume(priv);\r\nif (rc) {\r\nreturn rc;\r\n}\r\nif (wol) {\r\nunifi_send_signal(priv->card, NULL, 0, NULL);\r\n}\r\nbreak;\r\ndefault:\r\nunifi_error(priv, "WIFI POWER: Unknown value.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint unifi_cfg_power_save(unifi_priv_t *priv, unsigned char *arg)\r\n{\r\nunifi_cfg_powersave_t cfg_power_save;\r\nCsrWifiSmePowerConfig powerConfig;\r\nint rc;\r\nif (get_user(cfg_power_save, (unifi_cfg_powersave_t*)(((unifi_cfg_command_t*)arg) + 1))) {\r\nunifi_error(priv, "UNIFI_CFG: Failed to get the argument\n");\r\nreturn -EFAULT;\r\n}\r\nrc = sme_mgt_power_config_get(priv, &powerConfig);\r\nif (rc) {\r\nunifi_error(priv, "UNIFI_CFG: Get unifi_PowerConfigValue failed.\n");\r\nreturn rc;\r\n}\r\nswitch (cfg_power_save) {\r\ncase UNIFI_CFG_POWERSAVE_NONE:\r\npowerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_LOW;\r\nbreak;\r\ncase UNIFI_CFG_POWERSAVE_FAST:\r\npowerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_MED;\r\nbreak;\r\ncase UNIFI_CFG_POWERSAVE_FULL:\r\npowerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_HIGH;\r\nbreak;\r\ncase UNIFI_CFG_POWERSAVE_AUTO:\r\npowerConfig.powerSaveLevel = CSR_WIFI_SME_POWER_SAVE_LEVEL_AUTO;\r\nbreak;\r\ndefault:\r\nunifi_error(priv, "POWERSAVE: Unknown value.\n");\r\nreturn -EINVAL;\r\n}\r\nrc = sme_mgt_power_config_set(priv, &powerConfig);\r\nif (rc) {\r\nunifi_error(priv, "UNIFI_CFG: Set unifi_PowerConfigValue failed.\n");\r\n}\r\nreturn rc;\r\n}\r\nint unifi_cfg_power_supply(unifi_priv_t *priv, unsigned char *arg)\r\n{\r\nunifi_cfg_powersupply_t cfg_power_supply;\r\nCsrWifiSmeHostConfig hostConfig;\r\nint rc;\r\nif (get_user(cfg_power_supply, (unifi_cfg_powersupply_t*)(((unifi_cfg_command_t*)arg) + 1))) {\r\nunifi_error(priv, "UNIFI_CFG: Failed to get the argument\n");\r\nreturn -EFAULT;\r\n}\r\nrc = sme_mgt_host_config_get(priv, &hostConfig);\r\nif (rc) {\r\nunifi_error(priv, "UNIFI_CFG: Get unifi_HostConfigValue failed.\n");\r\nreturn rc;\r\n}\r\nswitch (cfg_power_supply) {\r\ncase UNIFI_CFG_POWERSUPPLY_MAINS:\r\nhostConfig.powerMode = CSR_WIFI_SME_HOST_POWER_MODE_ACTIVE;\r\nbreak;\r\ncase UNIFI_CFG_POWERSUPPLY_BATTERIES:\r\nhostConfig.powerMode = CSR_WIFI_SME_HOST_POWER_MODE_POWER_SAVE;\r\nbreak;\r\ndefault:\r\nunifi_error(priv, "POWERSUPPLY: Unknown value.\n");\r\nreturn -EINVAL;\r\n}\r\nrc = sme_mgt_host_config_set(priv, &hostConfig);\r\nif (rc) {\r\nunifi_error(priv, "UNIFI_CFG: Set unifi_HostConfigValue failed.\n");\r\n}\r\nreturn rc;\r\n}\r\nint unifi_cfg_packet_filters(unifi_priv_t *priv, unsigned char *arg)\r\n{\r\nunsigned char *tclas_buffer;\r\nunsigned int tclas_buffer_length;\r\ntclas_t *dhcp_tclas;\r\nint rc;\r\nif (priv->packet_filters.tclas_ies_length) {\r\nkfree(priv->filter_tclas_ies);\r\npriv->filter_tclas_ies = NULL;\r\n}\r\ntclas_buffer = ((unsigned char*)arg) + sizeof(unifi_cfg_command_t) + sizeof(unsigned int);\r\nif (copy_from_user(&priv->packet_filters, (void*)tclas_buffer,\r\nsizeof(uf_cfg_bcast_packet_filter_t))) {\r\nunifi_error(priv, "UNIFI_CFG: Failed to get the filter struct\n");\r\nreturn -EFAULT;\r\n}\r\ntclas_buffer_length = priv->packet_filters.tclas_ies_length;\r\nif (priv->packet_filters.dhcp_filter) {\r\npriv->packet_filters.tclas_ies_length += sizeof(tclas_t);\r\n}\r\nif (priv->packet_filters.tclas_ies_length > 0) {\r\npriv->filter_tclas_ies = kmalloc(priv->packet_filters.tclas_ies_length, GFP_KERNEL);\r\nif (priv->filter_tclas_ies == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nif (tclas_buffer_length) {\r\ntclas_buffer += sizeof(uf_cfg_bcast_packet_filter_t) - sizeof(unsigned char*);\r\nif (copy_from_user(priv->filter_tclas_ies,\r\ntclas_buffer,\r\ntclas_buffer_length)) {\r\nunifi_error(priv, "UNIFI_CFG: Failed to get the TCLAS buffer\n");\r\nreturn -EFAULT;\r\n}\r\n}\r\n}\r\nif(priv->packet_filters.dhcp_filter)\r\n{\r\ndhcp_tclas = (tclas_t*)(priv->filter_tclas_ies + tclas_buffer_length);\r\nmemset(dhcp_tclas, 0, sizeof(tclas_t));\r\ndhcp_tclas->element_id = 14;\r\ndhcp_tclas->length = sizeof(tcpip_clsfr_t) + 1;\r\ndhcp_tclas->user_priority = 0;\r\ndhcp_tclas->tcp_ip_cls_fr.cls_fr_type = 1;\r\ndhcp_tclas->tcp_ip_cls_fr.version = 4;\r\n((u8*)(&dhcp_tclas->tcp_ip_cls_fr.source_port))[0] = 0x00;\r\n((u8*)(&dhcp_tclas->tcp_ip_cls_fr.source_port))[1] = 0x44;\r\n((u8*)(&dhcp_tclas->tcp_ip_cls_fr.dest_port))[0] = 0x00;\r\n((u8*)(&dhcp_tclas->tcp_ip_cls_fr.dest_port))[1] = 0x43;\r\ndhcp_tclas->tcp_ip_cls_fr.protocol = 0x11;\r\ndhcp_tclas->tcp_ip_cls_fr.cls_fr_mask = 0x58;\r\n}\r\nrc = sme_mgt_packet_filter_set(priv);\r\nreturn rc;\r\n}\r\nint unifi_cfg_wmm_qos_info(unifi_priv_t *priv, unsigned char *arg)\r\n{\r\nu8 wmm_qos_info;\r\nint rc = 0;\r\nif (get_user(wmm_qos_info, (u8*)(((unifi_cfg_command_t*)arg) + 1))) {\r\nunifi_error(priv, "UNIFI_CFG: Failed to get the argument\n");\r\nreturn -EFAULT;\r\n}\r\npriv->connection_config.wmmQosInfo = wmm_qos_info;\r\nreturn rc;\r\n}\r\nint unifi_cfg_wmm_addts(unifi_priv_t *priv, unsigned char *arg)\r\n{\r\nu32 addts_tid;\r\nu8 addts_ie_length;\r\nu8 *addts_ie;\r\nu8 *addts_params;\r\nCsrWifiSmeDataBlock tspec;\r\nCsrWifiSmeDataBlock tclas;\r\nint rc;\r\naddts_params = (u8*)(((unifi_cfg_command_t*)arg) + 1);\r\nif (get_user(addts_tid, (u32*)addts_params)) {\r\nunifi_error(priv, "unifi_cfg_wmm_addts: Failed to get the argument\n");\r\nreturn -EFAULT;\r\n}\r\naddts_params += sizeof(u32);\r\nif (get_user(addts_ie_length, (u8*)addts_params)) {\r\nunifi_error(priv, "unifi_cfg_wmm_addts: Failed to get the argument\n");\r\nreturn -EFAULT;\r\n}\r\nunifi_trace(priv, UDBG4, "addts: tid = 0x%x ie_length = %d\n",\r\naddts_tid, addts_ie_length);\r\naddts_ie = kmalloc(addts_ie_length, GFP_KERNEL);\r\nif (addts_ie == NULL) {\r\nunifi_error(priv,\r\n"unifi_cfg_wmm_addts: Failed to malloc %d bytes for addts_ie buffer\n",\r\naddts_ie_length);\r\nreturn -ENOMEM;\r\n}\r\naddts_params += sizeof(u8);\r\nrc = copy_from_user(addts_ie, addts_params, addts_ie_length);\r\nif (rc) {\r\nunifi_error(priv, "unifi_cfg_wmm_addts: Failed to get the addts buffer\n");\r\nkfree(addts_ie);\r\nreturn -EFAULT;\r\n}\r\ntspec.data = addts_ie;\r\ntspec.length = addts_ie_length;\r\ntclas.data = NULL;\r\ntclas.length = 0;\r\nrc = sme_mgt_tspec(priv, CSR_WIFI_SME_LIST_ACTION_ADD, addts_tid,\r\n&tspec, &tclas);\r\nkfree(addts_ie);\r\nreturn rc;\r\n}\r\nint unifi_cfg_wmm_delts(unifi_priv_t *priv, unsigned char *arg)\r\n{\r\nu32 delts_tid;\r\nu8 *delts_params;\r\nCsrWifiSmeDataBlock tspec;\r\nCsrWifiSmeDataBlock tclas;\r\nint rc;\r\ndelts_params = (u8*)(((unifi_cfg_command_t*)arg) + 1);\r\nif (get_user(delts_tid, (u32*)delts_params)) {\r\nunifi_error(priv, "unifi_cfg_wmm_delts: Failed to get the argument\n");\r\nreturn -EFAULT;\r\n}\r\nunifi_trace(priv, UDBG4, "delts: tid = 0x%x\n", delts_tid);\r\ntspec.data = tclas.data = NULL;\r\ntspec.length = tclas.length = 0;\r\nrc = sme_mgt_tspec(priv, CSR_WIFI_SME_LIST_ACTION_REMOVE, delts_tid,\r\n&tspec, &tclas);\r\nreturn rc;\r\n}\r\nint unifi_cfg_strict_draft_n(unifi_priv_t *priv, unsigned char *arg)\r\n{\r\nu8 strict_draft_n;\r\nu8 *strict_draft_n_params;\r\nint rc;\r\nCsrWifiSmeStaConfig staConfig;\r\nCsrWifiSmeDeviceConfig deviceConfig;\r\nstrict_draft_n_params = (u8*)(((unifi_cfg_command_t*)arg) + 1);\r\nif (get_user(strict_draft_n, (u8*)strict_draft_n_params)) {\r\nunifi_error(priv, "unifi_cfg_strict_draft_n: Failed to get the argument\n");\r\nreturn -EFAULT;\r\n}\r\nunifi_trace(priv, UDBG4, "strict_draft_n: = %s\n", ((strict_draft_n) ? "yes":"no"));\r\nrc = sme_mgt_sme_config_get(priv, &staConfig, &deviceConfig);\r\nif (rc) {\r\nunifi_warning(priv, "unifi_cfg_strict_draft_n: Get unifi_SMEConfigValue failed.\n");\r\nreturn -EFAULT;\r\n}\r\ndeviceConfig.enableStrictDraftN = strict_draft_n;\r\nrc = sme_mgt_sme_config_set(priv, &staConfig, &deviceConfig);\r\nif (rc) {\r\nunifi_warning(priv, "unifi_cfg_strict_draft_n: Set unifi_SMEConfigValue failed.\n");\r\nrc = -EFAULT;\r\n}\r\nreturn rc;\r\n}\r\nint unifi_cfg_enable_okc(unifi_priv_t *priv, unsigned char *arg)\r\n{\r\nu8 enable_okc;\r\nu8 *enable_okc_params;\r\nint rc;\r\nCsrWifiSmeStaConfig staConfig;\r\nCsrWifiSmeDeviceConfig deviceConfig;\r\nenable_okc_params = (u8*)(((unifi_cfg_command_t*)arg) + 1);\r\nif (get_user(enable_okc, (u8*)enable_okc_params)) {\r\nunifi_error(priv, "unifi_cfg_enable_okc: Failed to get the argument\n");\r\nreturn -EFAULT;\r\n}\r\nunifi_trace(priv, UDBG4, "enable_okc: = %s\n", ((enable_okc) ? "yes":"no"));\r\nrc = sme_mgt_sme_config_get(priv, &staConfig, &deviceConfig);\r\nif (rc) {\r\nunifi_warning(priv, "unifi_cfg_enable_okc: Get unifi_SMEConfigValue failed.\n");\r\nreturn -EFAULT;\r\n}\r\nstaConfig.enableOpportunisticKeyCaching = enable_okc;\r\nrc = sme_mgt_sme_config_set(priv, &staConfig, &deviceConfig);\r\nif (rc) {\r\nunifi_warning(priv, "unifi_cfg_enable_okc: Set unifi_SMEConfigValue failed.\n");\r\nrc = -EFAULT;\r\n}\r\nreturn rc;\r\n}\r\nint unifi_cfg_get_info(unifi_priv_t *priv, unsigned char *arg)\r\n{\r\nunifi_cfg_get_t get_cmd;\r\nchar inst_name[IFNAMSIZ];\r\nint rc;\r\nif (get_user(get_cmd, (unifi_cfg_get_t*)(((unifi_cfg_command_t*)arg) + 1))) {\r\nunifi_error(priv, "UNIFI_CFG: Failed to get the argument\n");\r\nreturn -EFAULT;\r\n}\r\nswitch (get_cmd) {\r\ncase UNIFI_CFG_GET_COEX:\r\n{\r\nCsrWifiSmeCoexInfo coexInfo;\r\nrc = sme_mgt_coex_info_get(priv, &coexInfo);\r\nif (rc) {\r\nunifi_error(priv, "UNIFI_CFG: Get unifi_CoexInfoValue failed.\n");\r\nreturn rc;\r\n}\r\nif (copy_to_user((void*)arg,\r\n&coexInfo,\r\nsizeof(CsrWifiSmeCoexInfo))) {\r\nunifi_error(priv, "UNIFI_CFG: Failed to copy the coex info\n");\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase UNIFI_CFG_GET_POWER_MODE:\r\n{\r\nCsrWifiSmePowerConfig powerConfig;\r\nrc = sme_mgt_power_config_get(priv, &powerConfig);\r\nif (rc) {\r\nunifi_error(priv, "UNIFI_CFG: Get unifi_PowerConfigValue failed.\n");\r\nreturn rc;\r\n}\r\nif (copy_to_user((void*)arg,\r\n&powerConfig.powerSaveLevel,\r\nsizeof(CsrWifiSmePowerSaveLevel))) {\r\nunifi_error(priv, "UNIFI_CFG: Failed to copy the power save info\n");\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase UNIFI_CFG_GET_POWER_SUPPLY:\r\n{\r\nCsrWifiSmeHostConfig hostConfig;\r\nrc = sme_mgt_host_config_get(priv, &hostConfig);\r\nif (rc) {\r\nunifi_error(priv, "UNIFI_CFG: Get unifi_HostConfigValue failed.\n");\r\nreturn rc;\r\n}\r\nif (copy_to_user((void*)arg,\r\n&hostConfig.powerMode,\r\nsizeof(CsrWifiSmeHostPowerMode))) {\r\nunifi_error(priv, "UNIFI_CFG: Failed to copy the host power mode\n");\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\n}\r\ncase UNIFI_CFG_GET_VERSIONS:\r\nbreak;\r\ncase UNIFI_CFG_GET_INSTANCE:\r\n{\r\nu16 InterfaceId=0;\r\nuf_net_get_name(priv->netdev[InterfaceId], &inst_name[0], sizeof(inst_name));\r\nif (copy_to_user((void*)arg,\r\n&inst_name[0],\r\nsizeof(inst_name))) {\r\nunifi_error(priv, "UNIFI_CFG: Failed to copy the instance name\n");\r\nreturn -EFAULT;\r\n}\r\n}\r\nbreak;\r\ncase UNIFI_CFG_GET_AP_CONFIG:\r\n{\r\n#ifdef CSR_SUPPORT_WEXT_AP\r\nuf_cfg_ap_config_t cfg_ap_config;\r\ncfg_ap_config.channel = priv->ap_config.channel;\r\ncfg_ap_config.beaconInterval = priv->ap_mac_config.beaconInterval;\r\ncfg_ap_config.wmmEnabled = priv->ap_mac_config.wmmEnabled;\r\ncfg_ap_config.dtimPeriod = priv->ap_mac_config.dtimPeriod;\r\ncfg_ap_config.phySupportedBitmap = priv->ap_mac_config.phySupportedBitmap;\r\nif (copy_to_user((void*)arg,\r\n&cfg_ap_config,\r\nsizeof(uf_cfg_ap_config_t))) {\r\nunifi_error(priv, "UNIFI_CFG: Failed to copy the AP configuration\n");\r\nreturn -EFAULT;\r\n}\r\n#else\r\nreturn -EPERM;\r\n#endif\r\n}\r\nbreak;\r\ndefault:\r\nunifi_error(priv, "unifi_cfg_get_info: Unknown value.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nuf_configure_supported_rates(u8 * supportedRates, u8 phySupportedBitmap)\r\n{\r\nint i=0;\r\nu8 b=FALSE, g = FALSE, n = FALSE;\r\nb = phySupportedBitmap & CSR_WIFI_SME_AP_PHY_SUPPORT_B;\r\nn = phySupportedBitmap & CSR_WIFI_SME_AP_PHY_SUPPORT_N;\r\ng = phySupportedBitmap & CSR_WIFI_SME_AP_PHY_SUPPORT_G;\r\nif(b || g) {\r\nsupportedRates[i++]=0x82;\r\nsupportedRates[i++]=0x84;\r\nsupportedRates[i++]=0x8b;\r\nsupportedRates[i++]=0x96;\r\n} else if(n) {\r\nsupportedRates[i++]=0x02;\r\nsupportedRates[i++]=0x04;\r\nsupportedRates[i++]=0x0b;\r\nsupportedRates[i++]=0x16;\r\nsupportedRates[i++]=0x0c;\r\nsupportedRates[i++]=0x12;\r\nsupportedRates[i++]=0x18;\r\nsupportedRates[i++]=0x24;\r\nsupportedRates[i++]=0x30;\r\nsupportedRates[i++]=0x48;\r\nsupportedRates[i++]=0x60;\r\nsupportedRates[i++]=0x6c;\r\n}\r\nif(g) {\r\nif(!b) {\r\nsupportedRates[i++]=0x8c;\r\nsupportedRates[i++]=0x98;\r\nsupportedRates[i++]=0xb0;\r\n} else {\r\nsupportedRates[i++]=0x0c;\r\nsupportedRates[i++]=0x18;\r\nsupportedRates[i++]=0x30;\r\n}\r\nsupportedRates[i++]=0x48;\r\nsupportedRates[i++]=0x12;\r\nsupportedRates[i++]=0x24;\r\nsupportedRates[i++]=0x60;\r\nsupportedRates[i++]=0x6c;\r\n}\r\nreturn i;\r\n}\r\nint unifi_cfg_set_ap_config(unifi_priv_t * priv,unsigned char* arg)\r\n{\r\nuf_cfg_ap_config_t cfg_ap_config;\r\nchar *buffer;\r\nbuffer = ((unsigned char*)arg) + sizeof(unifi_cfg_command_t) + sizeof(unsigned int);\r\nif (copy_from_user(&cfg_ap_config, (void*)buffer,\r\nsizeof(uf_cfg_ap_config_t))) {\r\nunifi_error(priv, "UNIFI_CFG: Failed to get the ap config struct\n");\r\nreturn -EFAULT;\r\n}\r\npriv->ap_config.channel = cfg_ap_config.channel;\r\npriv->ap_mac_config.dtimPeriod = cfg_ap_config.dtimPeriod;\r\npriv->ap_mac_config.beaconInterval = cfg_ap_config.beaconInterval;\r\npriv->group_sec_config.apGroupkeyTimeout = cfg_ap_config.groupkeyTimeout;\r\npriv->group_sec_config.apStrictGtkRekey = cfg_ap_config.strictGtkRekeyEnabled;\r\npriv->group_sec_config.apGmkTimeout = cfg_ap_config.gmkTimeout;\r\npriv->group_sec_config.apResponseTimeout = cfg_ap_config.responseTimeout;\r\npriv->group_sec_config.apRetransLimit = cfg_ap_config.retransLimit;\r\npriv->ap_mac_config.shortSlotTimeEnabled = cfg_ap_config.shortSlotTimeEnabled;\r\npriv->ap_mac_config.ctsProtectionType=cfg_ap_config.ctsProtectionType;\r\npriv->ap_mac_config.wmmEnabled = cfg_ap_config.wmmEnabled;\r\npriv->ap_mac_config.apHtParams.rxStbc=cfg_ap_config.rxStbc;\r\npriv->ap_mac_config.apHtParams.rifsModeAllowed=cfg_ap_config.rifsModeAllowed;\r\npriv->ap_mac_config.phySupportedBitmap = cfg_ap_config.phySupportedBitmap;\r\npriv->ap_mac_config.maxListenInterval=cfg_ap_config.maxListenInterval;\r\npriv->ap_mac_config.supportedRatesCount= uf_configure_supported_rates(priv->ap_mac_config.supportedRates,priv->ap_mac_config.phySupportedBitmap);\r\nreturn 0;\r\n}\r\nvoid\r\nuf_sme_config_wq(struct work_struct *work)\r\n{\r\nCsrWifiSmeStaConfig staConfig;\r\nCsrWifiSmeDeviceConfig deviceConfig;\r\nunifi_priv_t *priv = container_of(work, unifi_priv_t, sme_config_task);\r\nCsrWifiSmeEventMaskSetReqSend(0,\r\nCSR_WIFI_SME_INDICATIONS_WIFIOFF | CSR_WIFI_SME_INDICATIONS_CONNECTIONQUALITY |\r\nCSR_WIFI_SME_INDICATIONS_MEDIASTATUS | CSR_WIFI_SME_INDICATIONS_MICFAILURE);\r\nif (sme_mgt_sme_config_get(priv, &staConfig, &deviceConfig)) {\r\nunifi_warning(priv, "uf_sme_config_wq: Get unifi_SMEConfigValue failed.\n");\r\nreturn;\r\n}\r\nif (priv->if_index == CSR_INDEX_5G) {\r\nstaConfig.ifIndex = CSR_WIFI_SME_RADIO_IF_GHZ_5_0;\r\n} else {\r\nstaConfig.ifIndex = CSR_WIFI_SME_RADIO_IF_GHZ_2_4;\r\n}\r\ndeviceConfig.trustLevel = (CsrWifiSme80211dTrustLevel)tl_80211d;\r\nif (sme_mgt_sme_config_set(priv, &staConfig, &deviceConfig)) {\r\nunifi_warning(priv,\r\n"SME config for 802.11d Trust Level and Radio Band failed.\n");\r\nreturn;\r\n}\r\n}\r\nvoid\r\nuf_ta_ind_wq(struct work_struct *work)\r\n{\r\nstruct ta_ind *ind = container_of(work, struct ta_ind, task);\r\nunifi_priv_t *priv = container_of(ind, unifi_priv_t, ta_ind_work);\r\nu16 interfaceTag = 0;\r\nCsrWifiRouterCtrlTrafficProtocolIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0,\r\ninterfaceTag,\r\nind->packet_type,\r\nind->direction,\r\nind->src_addr);\r\nind->in_use = 0;\r\n}\r\nvoid\r\nuf_ta_sample_ind_wq(struct work_struct *work)\r\n{\r\nstruct ta_sample_ind *ind = container_of(work, struct ta_sample_ind, task);\r\nunifi_priv_t *priv = container_of(ind, unifi_priv_t, ta_sample_ind_work);\r\nu16 interfaceTag = 0;\r\nunifi_trace(priv, UDBG5, "rxtcp %d txtcp %d rxudp %d txudp %d prio %d\n",\r\npriv->rxTcpThroughput,\r\npriv->txTcpThroughput,\r\npriv->rxUdpThroughput,\r\npriv->txUdpThroughput,\r\npriv->bh_thread.prio);\r\nif(priv->rxTcpThroughput > 1000)\r\n{\r\nif (bh_priority == -1 && priv->bh_thread.prio != 1)\r\n{\r\nstruct sched_param param;\r\npriv->bh_thread.prio = 1;\r\nunifi_trace(priv, UDBG1, "%s new thread (RT) priority = %d\n",\r\npriv->bh_thread.name, priv->bh_thread.prio);\r\nparam.sched_priority = priv->bh_thread.prio;\r\nsched_setscheduler(priv->bh_thread.thread_task, SCHED_FIFO, &param);\r\n}\r\n} else\r\n{\r\nif (bh_priority == -1 && priv->bh_thread.prio != DEFAULT_PRIO)\r\n{\r\nstruct sched_param param;\r\nparam.sched_priority = 0;\r\nsched_setscheduler(priv->bh_thread.thread_task, SCHED_NORMAL, &param);\r\npriv->bh_thread.prio = DEFAULT_PRIO;\r\nunifi_trace(priv, UDBG1, "%s new thread priority = %d\n",\r\npriv->bh_thread.name, priv->bh_thread.prio);\r\nset_user_nice(priv->bh_thread.thread_task, PRIO_TO_NICE(priv->bh_thread.prio));\r\n}\r\n}\r\nCsrWifiRouterCtrlTrafficSampleIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0, interfaceTag, ind->stats);\r\nind->in_use = 0;\r\n}\r\nvoid\r\nuf_send_m4_ready_wq(struct work_struct *work)\r\n{\r\nnetInterface_priv_t *InterfacePriv = container_of(work, netInterface_priv_t, send_m4_ready_task);\r\nu16 iface = InterfacePriv->InterfaceTag;\r\nunifi_priv_t *priv = InterfacePriv->privPtr;\r\nCSR_MA_PACKET_REQUEST *req = &InterfacePriv->m4_signal.u.MaPacketRequest;\r\nCsrWifiMacAddress peer;\r\nunsigned long flags;\r\nfunc_enter();\r\nspin_lock_irqsave(&priv->m4_lock, flags);\r\nmemcpy(peer.a, req->Ra.x, sizeof(peer.a));\r\nspin_unlock_irqrestore(&priv->m4_lock, flags);\r\nCsrWifiRouterCtrlM4ReadyToSendIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, 0, iface, peer);\r\nunifi_trace(priv, UDBG1, "M4ReadyToSendInd sent for peer %pMF\n",\r\npeer.a);\r\nfunc_exit();\r\n}\r\nvoid uf_send_pkt_to_encrypt(struct work_struct *work)\r\n{\r\nnetInterface_priv_t *interfacePriv = container_of(work, netInterface_priv_t, send_pkt_to_encrypt);\r\nu16 interfaceTag = interfacePriv->InterfaceTag;\r\nunifi_priv_t *priv = interfacePriv->privPtr;\r\nu32 pktBulkDataLength;\r\nu8 *pktBulkData;\r\nunsigned long flags;\r\nif (interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_STA) {\r\nfunc_enter();\r\npktBulkDataLength = interfacePriv->wapi_unicast_bulk_data.data_length;\r\nif (pktBulkDataLength > 0) {\r\npktBulkData = kmalloc(pktBulkDataLength, GFP_KERNEL);\r\nmemset(pktBulkData, 0, pktBulkDataLength);\r\n} else {\r\nunifi_error(priv, "uf_send_pkt_to_encrypt() : invalid buffer\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&priv->wapi_lock, flags);\r\nmemcpy(pktBulkData, (u8*)interfacePriv->wapi_unicast_bulk_data.os_data_ptr, pktBulkDataLength);\r\nunifi_net_data_free(priv, &interfacePriv->wapi_unicast_bulk_data);\r\ninterfacePriv->wapi_unicast_bulk_data.net_buf_length = 0;\r\ninterfacePriv->wapi_unicast_bulk_data.data_length = 0;\r\ninterfacePriv->wapi_unicast_bulk_data.os_data_ptr = interfacePriv->wapi_unicast_bulk_data.os_net_buf_ptr = NULL;\r\nspin_unlock_irqrestore(&priv->wapi_lock, flags);\r\nCsrWifiRouterCtrlWapiUnicastTxEncryptIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, 0, interfaceTag, pktBulkDataLength, pktBulkData);\r\nunifi_trace(priv, UDBG1, "WapiUnicastTxEncryptInd sent to SME\n");\r\nkfree(pktBulkData);\r\nfunc_exit();\r\n} else {\r\nunifi_warning(priv, "uf_send_pkt_to_encrypt() is NOT applicable for interface mode - %d\n",interfacePriv->interfaceMode);\r\n}\r\n}
