int\r\nsnd_seq_oss_read(struct seq_oss_devinfo *dp, char __user *buf, int count)\r\n{\r\nstruct seq_oss_readq *readq = dp->readq;\r\nint result = 0, err = 0;\r\nint ev_len;\r\nunion evrec rec;\r\nunsigned long flags;\r\nif (readq == NULL || ! is_read_mode(dp->file_mode))\r\nreturn -ENXIO;\r\nwhile (count >= SHORT_EVENT_SIZE) {\r\nsnd_seq_oss_readq_lock(readq, flags);\r\nerr = snd_seq_oss_readq_pick(readq, &rec);\r\nif (err == -EAGAIN &&\r\n!is_nonblock_mode(dp->file_mode) && result == 0) {\r\nsnd_seq_oss_readq_unlock(readq, flags);\r\nsnd_seq_oss_readq_wait(readq);\r\nsnd_seq_oss_readq_lock(readq, flags);\r\nif (signal_pending(current))\r\nerr = -ERESTARTSYS;\r\nelse\r\nerr = snd_seq_oss_readq_pick(readq, &rec);\r\n}\r\nif (err < 0) {\r\nsnd_seq_oss_readq_unlock(readq, flags);\r\nbreak;\r\n}\r\nev_len = ev_length(&rec);\r\nif (ev_len < count) {\r\nsnd_seq_oss_readq_unlock(readq, flags);\r\nbreak;\r\n}\r\nsnd_seq_oss_readq_free(readq);\r\nsnd_seq_oss_readq_unlock(readq, flags);\r\nif (copy_to_user(buf, &rec, ev_len)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nresult += ev_len;\r\nbuf += ev_len;\r\ncount -= ev_len;\r\n}\r\nreturn result > 0 ? result : err;\r\n}\r\nint\r\nsnd_seq_oss_write(struct seq_oss_devinfo *dp, const char __user *buf, int count, struct file *opt)\r\n{\r\nint result = 0, err = 0;\r\nint ev_size, fmt;\r\nunion evrec rec;\r\nif (! is_write_mode(dp->file_mode) || dp->writeq == NULL)\r\nreturn -ENXIO;\r\nwhile (count >= SHORT_EVENT_SIZE) {\r\nif (copy_from_user(&rec, buf, SHORT_EVENT_SIZE)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (rec.s.code == SEQ_FULLSIZE) {\r\nif (result > 0) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nfmt = (*(unsigned short *)rec.c) & 0xffff;\r\nreturn snd_seq_oss_synth_load_patch(dp, rec.s.dev,\r\nfmt, buf, 0, count);\r\n}\r\nif (ev_is_long(&rec)) {\r\nif (rec.s.code == SEQ_EXTENDED &&\r\ndp->seq_mode == SNDRV_SEQ_OSS_MODE_MUSIC) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nev_size = LONG_EVENT_SIZE;\r\nif (count < ev_size)\r\nbreak;\r\nif (copy_from_user(rec.c + SHORT_EVENT_SIZE,\r\nbuf + SHORT_EVENT_SIZE,\r\nLONG_EVENT_SIZE - SHORT_EVENT_SIZE)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\n} else {\r\nif (dp->seq_mode == SNDRV_SEQ_OSS_MODE_MUSIC) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nev_size = SHORT_EVENT_SIZE;\r\n}\r\nif ((err = insert_queue(dp, &rec, opt)) < 0)\r\nbreak;\r\nresult += ev_size;\r\nbuf += ev_size;\r\ncount -= ev_size;\r\n}\r\nreturn result > 0 ? result : err;\r\n}\r\nstatic int\r\ninsert_queue(struct seq_oss_devinfo *dp, union evrec *rec, struct file *opt)\r\n{\r\nint rc = 0;\r\nstruct snd_seq_event event;\r\nif (snd_seq_oss_process_timer_event(dp->timer, rec))\r\nreturn 0;\r\nmemset(&event, 0, sizeof(event));\r\nevent.type = SNDRV_SEQ_EVENT_NOTEOFF;\r\nsnd_seq_oss_fill_addr(dp, &event, dp->addr.port, dp->addr.client);\r\nif (snd_seq_oss_process_event(dp, rec, &event))\r\nreturn 0;\r\nevent.time.tick = snd_seq_oss_timer_cur_tick(dp->timer);\r\nif (dp->timer->realtime || !dp->timer->running) {\r\nsnd_seq_oss_dispatch(dp, &event, 0, 0);\r\n} else {\r\nif (is_nonblock_mode(dp->file_mode))\r\nrc = snd_seq_kernel_client_enqueue(dp->cseq, &event, 0, 0);\r\nelse\r\nrc = snd_seq_kernel_client_enqueue_blocking(dp->cseq, &event, opt, 0, 0);\r\n}\r\nreturn rc;\r\n}\r\nunsigned int\r\nsnd_seq_oss_poll(struct seq_oss_devinfo *dp, struct file *file, poll_table * wait)\r\n{\r\nunsigned int mask = 0;\r\nif (dp->readq && is_read_mode(dp->file_mode)) {\r\nif (snd_seq_oss_readq_poll(dp->readq, file, wait))\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nif (dp->writeq && is_write_mode(dp->file_mode)) {\r\nif (snd_seq_kernel_client_write_poll(dp->cseq, file, wait))\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\nreturn mask;\r\n}
