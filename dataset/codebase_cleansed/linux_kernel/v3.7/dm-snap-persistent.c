static int alloc_area(struct pstore *ps)\r\n{\r\nint r = -ENOMEM;\r\nsize_t len;\r\nlen = ps->store->chunk_size << SECTOR_SHIFT;\r\nps->area = vmalloc(len);\r\nif (!ps->area)\r\ngoto err_area;\r\nps->zero_area = vzalloc(len);\r\nif (!ps->zero_area)\r\ngoto err_zero_area;\r\nps->header_area = vmalloc(len);\r\nif (!ps->header_area)\r\ngoto err_header_area;\r\nreturn 0;\r\nerr_header_area:\r\nvfree(ps->zero_area);\r\nerr_zero_area:\r\nvfree(ps->area);\r\nerr_area:\r\nreturn r;\r\n}\r\nstatic void free_area(struct pstore *ps)\r\n{\r\nif (ps->area)\r\nvfree(ps->area);\r\nps->area = NULL;\r\nif (ps->zero_area)\r\nvfree(ps->zero_area);\r\nps->zero_area = NULL;\r\nif (ps->header_area)\r\nvfree(ps->header_area);\r\nps->header_area = NULL;\r\n}\r\nstatic void do_metadata(struct work_struct *work)\r\n{\r\nstruct mdata_req *req = container_of(work, struct mdata_req, work);\r\nreq->result = dm_io(req->io_req, 1, req->where, NULL);\r\n}\r\nstatic int chunk_io(struct pstore *ps, void *area, chunk_t chunk, int rw,\r\nint metadata)\r\n{\r\nstruct dm_io_region where = {\r\n.bdev = dm_snap_cow(ps->store->snap)->bdev,\r\n.sector = ps->store->chunk_size * chunk,\r\n.count = ps->store->chunk_size,\r\n};\r\nstruct dm_io_request io_req = {\r\n.bi_rw = rw,\r\n.mem.type = DM_IO_VMA,\r\n.mem.ptr.vma = area,\r\n.client = ps->io_client,\r\n.notify.fn = NULL,\r\n};\r\nstruct mdata_req req;\r\nif (!metadata)\r\nreturn dm_io(&io_req, 1, &where, NULL);\r\nreq.where = &where;\r\nreq.io_req = &io_req;\r\nINIT_WORK_ONSTACK(&req.work, do_metadata);\r\nqueue_work(ps->metadata_wq, &req.work);\r\nflush_work(&req.work);\r\nreturn req.result;\r\n}\r\nstatic chunk_t area_location(struct pstore *ps, chunk_t area)\r\n{\r\nreturn NUM_SNAPSHOT_HDR_CHUNKS + ((ps->exceptions_per_area + 1) * area);\r\n}\r\nstatic int area_io(struct pstore *ps, int rw)\r\n{\r\nint r;\r\nchunk_t chunk;\r\nchunk = area_location(ps, ps->current_area);\r\nr = chunk_io(ps, ps->area, chunk, rw, 0);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic void zero_memory_area(struct pstore *ps)\r\n{\r\nmemset(ps->area, 0, ps->store->chunk_size << SECTOR_SHIFT);\r\n}\r\nstatic int zero_disk_area(struct pstore *ps, chunk_t area)\r\n{\r\nreturn chunk_io(ps, ps->zero_area, area_location(ps, area), WRITE, 0);\r\n}\r\nstatic int read_header(struct pstore *ps, int *new_snapshot)\r\n{\r\nint r;\r\nstruct disk_header *dh;\r\nunsigned chunk_size;\r\nint chunk_size_supplied = 1;\r\nchar *chunk_err;\r\nif (!ps->store->chunk_size) {\r\nps->store->chunk_size = max(DM_CHUNK_SIZE_DEFAULT_SECTORS,\r\nbdev_logical_block_size(dm_snap_cow(ps->store->snap)->\r\nbdev) >> 9);\r\nps->store->chunk_mask = ps->store->chunk_size - 1;\r\nps->store->chunk_shift = ffs(ps->store->chunk_size) - 1;\r\nchunk_size_supplied = 0;\r\n}\r\nps->io_client = dm_io_client_create();\r\nif (IS_ERR(ps->io_client))\r\nreturn PTR_ERR(ps->io_client);\r\nr = alloc_area(ps);\r\nif (r)\r\nreturn r;\r\nr = chunk_io(ps, ps->header_area, 0, READ, 1);\r\nif (r)\r\ngoto bad;\r\ndh = ps->header_area;\r\nif (le32_to_cpu(dh->magic) == 0) {\r\n*new_snapshot = 1;\r\nreturn 0;\r\n}\r\nif (le32_to_cpu(dh->magic) != SNAP_MAGIC) {\r\nDMWARN("Invalid or corrupt snapshot");\r\nr = -ENXIO;\r\ngoto bad;\r\n}\r\n*new_snapshot = 0;\r\nps->valid = le32_to_cpu(dh->valid);\r\nps->version = le32_to_cpu(dh->version);\r\nchunk_size = le32_to_cpu(dh->chunk_size);\r\nif (ps->store->chunk_size == chunk_size)\r\nreturn 0;\r\nif (chunk_size_supplied)\r\nDMWARN("chunk size %u in device metadata overrides "\r\n"table chunk size of %u.",\r\nchunk_size, ps->store->chunk_size);\r\nfree_area(ps);\r\nr = dm_exception_store_set_chunk_size(ps->store, chunk_size,\r\n&chunk_err);\r\nif (r) {\r\nDMERR("invalid on-disk chunk size %u: %s.",\r\nchunk_size, chunk_err);\r\nreturn r;\r\n}\r\nr = alloc_area(ps);\r\nreturn r;\r\nbad:\r\nfree_area(ps);\r\nreturn r;\r\n}\r\nstatic int write_header(struct pstore *ps)\r\n{\r\nstruct disk_header *dh;\r\nmemset(ps->header_area, 0, ps->store->chunk_size << SECTOR_SHIFT);\r\ndh = ps->header_area;\r\ndh->magic = cpu_to_le32(SNAP_MAGIC);\r\ndh->valid = cpu_to_le32(ps->valid);\r\ndh->version = cpu_to_le32(ps->version);\r\ndh->chunk_size = cpu_to_le32(ps->store->chunk_size);\r\nreturn chunk_io(ps, ps->header_area, 0, WRITE, 1);\r\n}\r\nstatic struct disk_exception *get_exception(struct pstore *ps, uint32_t index)\r\n{\r\nBUG_ON(index >= ps->exceptions_per_area);\r\nreturn ((struct disk_exception *) ps->area) + index;\r\n}\r\nstatic void read_exception(struct pstore *ps,\r\nuint32_t index, struct core_exception *result)\r\n{\r\nstruct disk_exception *de = get_exception(ps, index);\r\nresult->old_chunk = le64_to_cpu(de->old_chunk);\r\nresult->new_chunk = le64_to_cpu(de->new_chunk);\r\n}\r\nstatic void write_exception(struct pstore *ps,\r\nuint32_t index, struct core_exception *e)\r\n{\r\nstruct disk_exception *de = get_exception(ps, index);\r\nde->old_chunk = cpu_to_le64(e->old_chunk);\r\nde->new_chunk = cpu_to_le64(e->new_chunk);\r\n}\r\nstatic void clear_exception(struct pstore *ps, uint32_t index)\r\n{\r\nstruct disk_exception *de = get_exception(ps, index);\r\nde->old_chunk = 0;\r\nde->new_chunk = 0;\r\n}\r\nstatic int insert_exceptions(struct pstore *ps,\r\nint (*callback)(void *callback_context,\r\nchunk_t old, chunk_t new),\r\nvoid *callback_context,\r\nint *full)\r\n{\r\nint r;\r\nunsigned int i;\r\nstruct core_exception e;\r\n*full = 1;\r\nfor (i = 0; i < ps->exceptions_per_area; i++) {\r\nread_exception(ps, i, &e);\r\nif (e.new_chunk == 0LL) {\r\nps->current_committed = i;\r\n*full = 0;\r\nbreak;\r\n}\r\nif (ps->next_free <= e.new_chunk)\r\nps->next_free = e.new_chunk + 1;\r\nr = callback(callback_context, e.old_chunk, e.new_chunk);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_exceptions(struct pstore *ps,\r\nint (*callback)(void *callback_context, chunk_t old,\r\nchunk_t new),\r\nvoid *callback_context)\r\n{\r\nint r, full = 1;\r\nfor (ps->current_area = 0; full; ps->current_area++) {\r\nr = area_io(ps, READ);\r\nif (r)\r\nreturn r;\r\nr = insert_exceptions(ps, callback, callback_context, &full);\r\nif (r)\r\nreturn r;\r\n}\r\nps->current_area--;\r\nreturn 0;\r\n}\r\nstatic struct pstore *get_info(struct dm_exception_store *store)\r\n{\r\nreturn (struct pstore *) store->context;\r\n}\r\nstatic void persistent_usage(struct dm_exception_store *store,\r\nsector_t *total_sectors,\r\nsector_t *sectors_allocated,\r\nsector_t *metadata_sectors)\r\n{\r\nstruct pstore *ps = get_info(store);\r\n*sectors_allocated = ps->next_free * store->chunk_size;\r\n*total_sectors = get_dev_size(dm_snap_cow(store->snap)->bdev);\r\n*metadata_sectors = (ps->current_area + 1 + NUM_SNAPSHOT_HDR_CHUNKS) *\r\nstore->chunk_size;\r\n}\r\nstatic void persistent_dtr(struct dm_exception_store *store)\r\n{\r\nstruct pstore *ps = get_info(store);\r\ndestroy_workqueue(ps->metadata_wq);\r\nif (ps->io_client)\r\ndm_io_client_destroy(ps->io_client);\r\nfree_area(ps);\r\nif (ps->callbacks)\r\nvfree(ps->callbacks);\r\nkfree(ps);\r\n}\r\nstatic int persistent_read_metadata(struct dm_exception_store *store,\r\nint (*callback)(void *callback_context,\r\nchunk_t old, chunk_t new),\r\nvoid *callback_context)\r\n{\r\nint r, uninitialized_var(new_snapshot);\r\nstruct pstore *ps = get_info(store);\r\nr = read_header(ps, &new_snapshot);\r\nif (r)\r\nreturn r;\r\nps->exceptions_per_area = (ps->store->chunk_size << SECTOR_SHIFT) /\r\nsizeof(struct disk_exception);\r\nps->callbacks = dm_vcalloc(ps->exceptions_per_area,\r\nsizeof(*ps->callbacks));\r\nif (!ps->callbacks)\r\nreturn -ENOMEM;\r\nif (new_snapshot) {\r\nr = write_header(ps);\r\nif (r) {\r\nDMWARN("write_header failed");\r\nreturn r;\r\n}\r\nps->current_area = 0;\r\nzero_memory_area(ps);\r\nr = zero_disk_area(ps, 0);\r\nif (r)\r\nDMWARN("zero_disk_area(0) failed");\r\nreturn r;\r\n}\r\nif (ps->version != SNAPSHOT_DISK_VERSION) {\r\nDMWARN("unable to handle snapshot disk version %d",\r\nps->version);\r\nreturn -EINVAL;\r\n}\r\nif (!ps->valid)\r\nreturn 1;\r\nr = read_exceptions(ps, callback, callback_context);\r\nreturn r;\r\n}\r\nstatic int persistent_prepare_exception(struct dm_exception_store *store,\r\nstruct dm_exception *e)\r\n{\r\nstruct pstore *ps = get_info(store);\r\nuint32_t stride;\r\nchunk_t next_free;\r\nsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\r\nif (size < ((ps->next_free + 1) * store->chunk_size))\r\nreturn -ENOSPC;\r\ne->new_chunk = ps->next_free;\r\nstride = (ps->exceptions_per_area + 1);\r\nnext_free = ++ps->next_free;\r\nif (sector_div(next_free, stride) == 1)\r\nps->next_free++;\r\natomic_inc(&ps->pending_count);\r\nreturn 0;\r\n}\r\nstatic void persistent_commit_exception(struct dm_exception_store *store,\r\nstruct dm_exception *e,\r\nvoid (*callback) (void *, int success),\r\nvoid *callback_context)\r\n{\r\nunsigned int i;\r\nstruct pstore *ps = get_info(store);\r\nstruct core_exception ce;\r\nstruct commit_callback *cb;\r\nce.old_chunk = e->old_chunk;\r\nce.new_chunk = e->new_chunk;\r\nwrite_exception(ps, ps->current_committed++, &ce);\r\ncb = ps->callbacks + ps->callback_count++;\r\ncb->callback = callback;\r\ncb->context = callback_context;\r\nif (!atomic_dec_and_test(&ps->pending_count) &&\r\n(ps->current_committed != ps->exceptions_per_area))\r\nreturn;\r\nif ((ps->current_committed == ps->exceptions_per_area) &&\r\nzero_disk_area(ps, ps->current_area + 1))\r\nps->valid = 0;\r\nif (ps->valid && area_io(ps, WRITE_FLUSH_FUA))\r\nps->valid = 0;\r\nif (ps->current_committed == ps->exceptions_per_area) {\r\nps->current_committed = 0;\r\nps->current_area++;\r\nzero_memory_area(ps);\r\n}\r\nfor (i = 0; i < ps->callback_count; i++) {\r\ncb = ps->callbacks + i;\r\ncb->callback(cb->context, ps->valid);\r\n}\r\nps->callback_count = 0;\r\n}\r\nstatic int persistent_prepare_merge(struct dm_exception_store *store,\r\nchunk_t *last_old_chunk,\r\nchunk_t *last_new_chunk)\r\n{\r\nstruct pstore *ps = get_info(store);\r\nstruct core_exception ce;\r\nint nr_consecutive;\r\nint r;\r\nif (!ps->current_committed) {\r\nif (!ps->current_area)\r\nreturn 0;\r\nps->current_area--;\r\nr = area_io(ps, READ);\r\nif (r < 0)\r\nreturn r;\r\nps->current_committed = ps->exceptions_per_area;\r\n}\r\nread_exception(ps, ps->current_committed - 1, &ce);\r\n*last_old_chunk = ce.old_chunk;\r\n*last_new_chunk = ce.new_chunk;\r\nfor (nr_consecutive = 1; nr_consecutive < ps->current_committed;\r\nnr_consecutive++) {\r\nread_exception(ps, ps->current_committed - 1 - nr_consecutive,\r\n&ce);\r\nif (ce.old_chunk != *last_old_chunk - nr_consecutive ||\r\nce.new_chunk != *last_new_chunk - nr_consecutive)\r\nbreak;\r\n}\r\nreturn nr_consecutive;\r\n}\r\nstatic int persistent_commit_merge(struct dm_exception_store *store,\r\nint nr_merged)\r\n{\r\nint r, i;\r\nstruct pstore *ps = get_info(store);\r\nBUG_ON(nr_merged > ps->current_committed);\r\nfor (i = 0; i < nr_merged; i++)\r\nclear_exception(ps, ps->current_committed - 1 - i);\r\nr = area_io(ps, WRITE_FLUSH_FUA);\r\nif (r < 0)\r\nreturn r;\r\nps->current_committed -= nr_merged;\r\nps->next_free = area_location(ps, ps->current_area) +\r\nps->current_committed + 1;\r\nreturn 0;\r\n}\r\nstatic void persistent_drop_snapshot(struct dm_exception_store *store)\r\n{\r\nstruct pstore *ps = get_info(store);\r\nps->valid = 0;\r\nif (write_header(ps))\r\nDMWARN("write header failed");\r\n}\r\nstatic int persistent_ctr(struct dm_exception_store *store,\r\nunsigned argc, char **argv)\r\n{\r\nstruct pstore *ps;\r\nps = kzalloc(sizeof(*ps), GFP_KERNEL);\r\nif (!ps)\r\nreturn -ENOMEM;\r\nps->store = store;\r\nps->valid = 1;\r\nps->version = SNAPSHOT_DISK_VERSION;\r\nps->area = NULL;\r\nps->zero_area = NULL;\r\nps->header_area = NULL;\r\nps->next_free = NUM_SNAPSHOT_HDR_CHUNKS + 1;\r\nps->current_committed = 0;\r\nps->callback_count = 0;\r\natomic_set(&ps->pending_count, 0);\r\nps->callbacks = NULL;\r\nps->metadata_wq = alloc_workqueue("ksnaphd", WQ_MEM_RECLAIM, 0);\r\nif (!ps->metadata_wq) {\r\nkfree(ps);\r\nDMERR("couldn't start header metadata update thread");\r\nreturn -ENOMEM;\r\n}\r\nstore->context = ps;\r\nreturn 0;\r\n}\r\nstatic unsigned persistent_status(struct dm_exception_store *store,\r\nstatus_type_t status, char *result,\r\nunsigned maxlen)\r\n{\r\nunsigned sz = 0;\r\nswitch (status) {\r\ncase STATUSTYPE_INFO:\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT(" P %llu", (unsigned long long)store->chunk_size);\r\n}\r\nreturn sz;\r\n}\r\nint dm_persistent_snapshot_init(void)\r\n{\r\nint r;\r\nr = dm_exception_store_type_register(&_persistent_type);\r\nif (r) {\r\nDMERR("Unable to register persistent exception store type");\r\nreturn r;\r\n}\r\nr = dm_exception_store_type_register(&_persistent_compat_type);\r\nif (r) {\r\nDMERR("Unable to register old-style persistent exception "\r\n"store type");\r\ndm_exception_store_type_unregister(&_persistent_type);\r\nreturn r;\r\n}\r\nreturn r;\r\n}\r\nvoid dm_persistent_snapshot_exit(void)\r\n{\r\ndm_exception_store_type_unregister(&_persistent_type);\r\ndm_exception_store_type_unregister(&_persistent_compat_type);\r\n}
