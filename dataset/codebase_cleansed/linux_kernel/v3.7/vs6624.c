static inline struct vs6624 *to_vs6624(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct vs6624, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct vs6624, hdl)->sd;\r\n}\r\nstatic int vs6624_read(struct v4l2_subdev *sd, u16 index)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 buf[2];\r\nbuf[0] = index >> 8;\r\nbuf[1] = index;\r\ni2c_master_send(client, buf, 2);\r\ni2c_master_recv(client, buf, 1);\r\nreturn buf[0];\r\n}\r\nstatic int vs6624_write(struct v4l2_subdev *sd, u16 index,\r\nu8 value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 buf[3];\r\nbuf[0] = index >> 8;\r\nbuf[1] = index;\r\nbuf[2] = value;\r\nreturn i2c_master_send(client, buf, 3);\r\n}\r\nstatic int vs6624_writeregs(struct v4l2_subdev *sd, const u16 *regs)\r\n{\r\nu16 reg;\r\nu8 data;\r\nwhile (*regs != 0x00) {\r\nreg = *regs++;\r\ndata = *regs++;\r\nvs6624_write(sd, reg, data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vs6624_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_CONTRAST:\r\nvs6624_write(sd, VS6624_CONTRAST0, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nvs6624_write(sd, VS6624_SATURATION0, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nvs6624_write(sd, VS6624_HMIRROR0, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nvs6624_write(sd, VS6624_VFLIP0, ctrl->val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vs6624_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index >= ARRAY_SIZE(vs6624_formats))\r\nreturn -EINVAL;\r\n*code = vs6624_formats[index].mbus_code;\r\nreturn 0;\r\n}\r\nstatic int vs6624_try_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nint index;\r\nfor (index = 0; index < ARRAY_SIZE(vs6624_formats); index++)\r\nif (vs6624_formats[index].mbus_code == fmt->code)\r\nbreak;\r\nif (index >= ARRAY_SIZE(vs6624_formats)) {\r\nindex = 0;\r\nfmt->code = vs6624_formats[0].mbus_code;\r\n}\r\nif (fmt->width > VGA_WIDTH)\r\nfmt->width = VGA_WIDTH;\r\nif (fmt->height > VGA_HEIGHT)\r\nfmt->height = VGA_HEIGHT;\r\nfmt->width = fmt->width & (~3);\r\nfmt->height = fmt->height & (~3);\r\nfmt->field = V4L2_FIELD_NONE;\r\nfmt->colorspace = vs6624_formats[index].colorspace;\r\nreturn 0;\r\n}\r\nstatic int vs6624_s_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct vs6624 *sensor = to_vs6624(sd);\r\nint ret;\r\nret = vs6624_try_mbus_fmt(sd, fmt);\r\nif (ret)\r\nreturn ret;\r\nswitch (fmt->code) {\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\nvs6624_write(sd, VS6624_IMG_FMT0, 0x0);\r\nvs6624_write(sd, VS6624_YUV_SETUP, 0x1);\r\nbreak;\r\ncase V4L2_MBUS_FMT_YUYV8_2X8:\r\nvs6624_write(sd, VS6624_IMG_FMT0, 0x0);\r\nvs6624_write(sd, VS6624_YUV_SETUP, 0x3);\r\nbreak;\r\ncase V4L2_MBUS_FMT_RGB565_2X8_LE:\r\nvs6624_write(sd, VS6624_IMG_FMT0, 0x4);\r\nvs6624_write(sd, VS6624_RGB_SETUP, 0x0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((fmt->width == VGA_WIDTH) && (fmt->height == VGA_HEIGHT))\r\nvs6624_write(sd, VS6624_IMAGE_SIZE0, 0x2);\r\nelse if ((fmt->width == QVGA_WIDTH) && (fmt->height == QVGA_HEIGHT))\r\nvs6624_write(sd, VS6624_IMAGE_SIZE0, 0x4);\r\nelse if ((fmt->width == QQVGA_WIDTH) && (fmt->height == QQVGA_HEIGHT))\r\nvs6624_write(sd, VS6624_IMAGE_SIZE0, 0x6);\r\nelse if ((fmt->width == CIF_WIDTH) && (fmt->height == CIF_HEIGHT))\r\nvs6624_write(sd, VS6624_IMAGE_SIZE0, 0x3);\r\nelse if ((fmt->width == QCIF_WIDTH) && (fmt->height == QCIF_HEIGHT))\r\nvs6624_write(sd, VS6624_IMAGE_SIZE0, 0x5);\r\nelse if ((fmt->width == QQCIF_WIDTH) && (fmt->height == QQCIF_HEIGHT))\r\nvs6624_write(sd, VS6624_IMAGE_SIZE0, 0x7);\r\nelse {\r\nvs6624_write(sd, VS6624_IMAGE_SIZE0, 0x8);\r\nvs6624_write(sd, VS6624_MAN_HSIZE0_MSB, fmt->width >> 8);\r\nvs6624_write(sd, VS6624_MAN_HSIZE0_LSB, fmt->width & 0xFF);\r\nvs6624_write(sd, VS6624_MAN_VSIZE0_MSB, fmt->height >> 8);\r\nvs6624_write(sd, VS6624_MAN_VSIZE0_LSB, fmt->height & 0xFF);\r\nvs6624_write(sd, VS6624_CROP_CTRL0, 0x1);\r\n}\r\nsensor->fmt = *fmt;\r\nreturn 0;\r\n}\r\nstatic int vs6624_g_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct vs6624 *sensor = to_vs6624(sd);\r\n*fmt = sensor->fmt;\r\nreturn 0;\r\n}\r\nstatic int vs6624_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)\r\n{\r\nstruct vs6624 *sensor = to_vs6624(sd);\r\nstruct v4l2_captureparm *cp = &parms->parm.capture;\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmemset(cp, 0, sizeof(*cp));\r\ncp->capability = V4L2_CAP_TIMEPERFRAME;\r\ncp->timeperframe.numerator = sensor->frame_rate.denominator;\r\ncp->timeperframe.denominator = sensor->frame_rate.numerator;\r\nreturn 0;\r\n}\r\nstatic int vs6624_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)\r\n{\r\nstruct vs6624 *sensor = to_vs6624(sd);\r\nstruct v4l2_captureparm *cp = &parms->parm.capture;\r\nstruct v4l2_fract *tpf = &cp->timeperframe;\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (cp->extendedmode != 0)\r\nreturn -EINVAL;\r\nif (tpf->numerator == 0 || tpf->denominator == 0\r\n|| (tpf->denominator > tpf->numerator * MAX_FRAME_RATE)) {\r\ntpf->numerator = 1;\r\ntpf->denominator = MAX_FRAME_RATE;\r\n}\r\nsensor->frame_rate.numerator = tpf->denominator;\r\nsensor->frame_rate.denominator = tpf->numerator;\r\nvs6624_write(sd, VS6624_DISABLE_FR_DAMPER, 0x0);\r\nvs6624_write(sd, VS6624_FR_NUM_MSB,\r\nsensor->frame_rate.numerator >> 8);\r\nvs6624_write(sd, VS6624_FR_NUM_LSB,\r\nsensor->frame_rate.numerator & 0xFF);\r\nvs6624_write(sd, VS6624_FR_DEN,\r\nsensor->frame_rate.denominator & 0xFF);\r\nreturn 0;\r\n}\r\nstatic int vs6624_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nif (enable)\r\nvs6624_write(sd, VS6624_USER_CMD, 0x2);\r\nelse\r\nvs6624_write(sd, VS6624_USER_CMD, 0x4);\r\nudelay(100);\r\nreturn 0;\r\n}\r\nstatic int vs6624_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nint rev;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nrev = (vs6624_read(sd, VS6624_FW_VSN_MAJOR) << 8)\r\n| vs6624_read(sd, VS6624_FW_VSN_MINOR);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_VS6624, rev);\r\n}\r\nstatic int vs6624_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreg->val = vs6624_read(sd, reg->reg & 0xffff);\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int vs6624_s_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nvs6624_write(sd, reg->reg & 0xffff, reg->val & 0xff);\r\nreturn 0;\r\n}\r\nstatic int __devinit vs6624_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct vs6624 *sensor;\r\nstruct v4l2_subdev *sd;\r\nstruct v4l2_ctrl_handler *hdl;\r\nconst unsigned *ce;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nreturn -EIO;\r\nce = client->dev.platform_data;\r\nif (ce == NULL)\r\nreturn -EINVAL;\r\nret = gpio_request(*ce, "VS6624 Chip Enable");\r\nif (ret) {\r\nv4l_err(client, "failed to request GPIO %d\n", *ce);\r\nreturn ret;\r\n}\r\ngpio_direction_output(*ce, 1);\r\nmdelay(100);\r\nsensor = kzalloc(sizeof(*sensor), GFP_KERNEL);\r\nif (sensor == NULL) {\r\ngpio_free(*ce);\r\nreturn -ENOMEM;\r\n}\r\nsd = &sensor->sd;\r\nv4l2_i2c_subdev_init(sd, client, &vs6624_ops);\r\nvs6624_writeregs(sd, vs6624_p1);\r\nvs6624_write(sd, VS6624_MICRO_EN, 0x2);\r\nvs6624_write(sd, VS6624_DIO_EN, 0x1);\r\nmdelay(10);\r\nvs6624_writeregs(sd, vs6624_p2);\r\nvs6624_writeregs(sd, vs6624_default);\r\nvs6624_write(sd, VS6624_HSYNC_SETUP, 0xF);\r\nvs6624_writeregs(sd, vs6624_run_setup);\r\nsensor->frame_rate.numerator = MAX_FRAME_RATE;\r\nsensor->frame_rate.denominator = 1;\r\nvs6624_write(sd, VS6624_DISABLE_FR_DAMPER, 0x0);\r\nvs6624_write(sd, VS6624_FR_NUM_MSB,\r\nsensor->frame_rate.numerator >> 8);\r\nvs6624_write(sd, VS6624_FR_NUM_LSB,\r\nsensor->frame_rate.numerator & 0xFF);\r\nvs6624_write(sd, VS6624_FR_DEN,\r\nsensor->frame_rate.denominator & 0xFF);\r\nsensor->fmt = vs6624_default_fmt;\r\nsensor->ce_pin = *ce;\r\nv4l_info(client, "chip found @ 0x%02x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nhdl = &sensor->hdl;\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nv4l2_ctrl_new_std(hdl, &vs6624_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 0xFF, 1, 0x87);\r\nv4l2_ctrl_new_std(hdl, &vs6624_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 0xFF, 1, 0x78);\r\nv4l2_ctrl_new_std(hdl, &vs6624_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &vs6624_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nint err = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nkfree(sensor);\r\ngpio_free(*ce);\r\nreturn err;\r\n}\r\nret = v4l2_ctrl_handler_setup(hdl);\r\nif (ret) {\r\nv4l2_ctrl_handler_free(hdl);\r\nkfree(sensor);\r\ngpio_free(*ce);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devexit vs6624_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct vs6624 *sensor = to_vs6624(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\ngpio_free(sensor->ce_pin);\r\nkfree(sensor);\r\nreturn 0;\r\n}\r\nstatic __init int vs6624_init(void)\r\n{\r\nreturn i2c_add_driver(&vs6624_driver);\r\n}\r\nstatic __exit void vs6624_exit(void)\r\n{\r\ni2c_del_driver(&vs6624_driver);\r\n}
