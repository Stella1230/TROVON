static void sas_end_task(struct scsi_cmnd *sc, struct sas_task *task)\r\n{\r\nstruct task_status_struct *ts = &task->task_status;\r\nint hs = 0, stat = 0;\r\nif (ts->resp == SAS_TASK_UNDELIVERED) {\r\nhs = DID_NO_CONNECT;\r\n} else {\r\nswitch (ts->stat) {\r\ncase SAS_DEV_NO_RESPONSE:\r\ncase SAS_INTERRUPTED:\r\ncase SAS_PHY_DOWN:\r\ncase SAS_NAK_R_ERR:\r\ncase SAS_OPEN_TO:\r\nhs = DID_NO_CONNECT;\r\nbreak;\r\ncase SAS_DATA_UNDERRUN:\r\nscsi_set_resid(sc, ts->residual);\r\nif (scsi_bufflen(sc) - scsi_get_resid(sc) < sc->underflow)\r\nhs = DID_ERROR;\r\nbreak;\r\ncase SAS_DATA_OVERRUN:\r\nhs = DID_ERROR;\r\nbreak;\r\ncase SAS_QUEUE_FULL:\r\nhs = DID_SOFT_ERROR;\r\nbreak;\r\ncase SAS_DEVICE_UNKNOWN:\r\nhs = DID_BAD_TARGET;\r\nbreak;\r\ncase SAS_SG_ERR:\r\nhs = DID_PARITY;\r\nbreak;\r\ncase SAS_OPEN_REJECT:\r\nif (ts->open_rej_reason == SAS_OREJ_RSVD_RETRY)\r\nhs = DID_SOFT_ERROR;\r\nelse\r\nhs = DID_ERROR;\r\nbreak;\r\ncase SAS_PROTO_RESPONSE:\r\nSAS_DPRINTK("LLDD:%s sent SAS_PROTO_RESP for an SSP "\r\n"task; please report this\n",\r\ntask->dev->port->ha->sas_ha_name);\r\nbreak;\r\ncase SAS_ABORTED_TASK:\r\nhs = DID_ABORT;\r\nbreak;\r\ncase SAM_STAT_CHECK_CONDITION:\r\nmemcpy(sc->sense_buffer, ts->buf,\r\nmin(SCSI_SENSE_BUFFERSIZE, ts->buf_valid_size));\r\nstat = SAM_STAT_CHECK_CONDITION;\r\nbreak;\r\ndefault:\r\nstat = ts->stat;\r\nbreak;\r\n}\r\n}\r\nsc->result = (hs << 16) | stat;\r\nASSIGN_SAS_TASK(sc, NULL);\r\nlist_del_init(&task->list);\r\nsas_free_task(task);\r\n}\r\nstatic void sas_scsi_task_done(struct sas_task *task)\r\n{\r\nstruct scsi_cmnd *sc = task->uldd_task;\r\nstruct domain_device *dev = task->dev;\r\nstruct sas_ha_struct *ha = dev->port->ha;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->done_lock, flags);\r\nif (test_bit(SAS_HA_FROZEN, &ha->state))\r\ntask = NULL;\r\nelse\r\nASSIGN_SAS_TASK(sc, NULL);\r\nspin_unlock_irqrestore(&dev->done_lock, flags);\r\nif (unlikely(!task)) {\r\nSAS_DPRINTK("task done but aborted\n");\r\nreturn;\r\n}\r\nif (unlikely(!sc)) {\r\nSAS_DPRINTK("task_done called with non existing SCSI cmnd!\n");\r\nlist_del_init(&task->list);\r\nsas_free_task(task);\r\nreturn;\r\n}\r\nsas_end_task(sc, task);\r\nsc->scsi_done(sc);\r\n}\r\nstatic struct sas_task *sas_create_task(struct scsi_cmnd *cmd,\r\nstruct domain_device *dev,\r\ngfp_t gfp_flags)\r\n{\r\nstruct sas_task *task = sas_alloc_task(gfp_flags);\r\nstruct scsi_lun lun;\r\nif (!task)\r\nreturn NULL;\r\ntask->uldd_task = cmd;\r\nASSIGN_SAS_TASK(cmd, task);\r\ntask->dev = dev;\r\ntask->task_proto = task->dev->tproto;\r\ntask->ssp_task.retry_count = 1;\r\nint_to_scsilun(cmd->device->lun, &lun);\r\nmemcpy(task->ssp_task.LUN, &lun.scsi_lun, 8);\r\ntask->ssp_task.task_attr = TASK_ATTR_SIMPLE;\r\nmemcpy(task->ssp_task.cdb, cmd->cmnd, 16);\r\ntask->scatter = scsi_sglist(cmd);\r\ntask->num_scatter = scsi_sg_count(cmd);\r\ntask->total_xfer_len = scsi_bufflen(cmd);\r\ntask->data_dir = cmd->sc_data_direction;\r\ntask->task_done = sas_scsi_task_done;\r\nreturn task;\r\n}\r\nint sas_queue_up(struct sas_task *task)\r\n{\r\nstruct sas_ha_struct *sas_ha = task->dev->port->ha;\r\nstruct scsi_core *core = &sas_ha->core;\r\nunsigned long flags;\r\nLIST_HEAD(list);\r\nspin_lock_irqsave(&core->task_queue_lock, flags);\r\nif (sas_ha->lldd_queue_size < core->task_queue_size + 1) {\r\nspin_unlock_irqrestore(&core->task_queue_lock, flags);\r\nreturn -SAS_QUEUE_FULL;\r\n}\r\nlist_add_tail(&task->list, &core->task_queue);\r\ncore->task_queue_size += 1;\r\nspin_unlock_irqrestore(&core->task_queue_lock, flags);\r\nwake_up_process(core->queue_thread);\r\nreturn 0;\r\n}\r\nint sas_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)\r\n{\r\nstruct sas_internal *i = to_sas_internal(host->transportt);\r\nstruct domain_device *dev = cmd_to_domain_dev(cmd);\r\nstruct sas_ha_struct *sas_ha = dev->port->ha;\r\nstruct sas_task *task;\r\nint res = 0;\r\nif (test_bit(SAS_DEV_GONE, &dev->state)) {\r\ncmd->result = DID_BAD_TARGET << 16;\r\ngoto out_done;\r\n}\r\nif (dev_is_sata(dev)) {\r\nspin_lock_irq(dev->sata_dev.ap->lock);\r\nres = ata_sas_queuecmd(cmd, dev->sata_dev.ap);\r\nspin_unlock_irq(dev->sata_dev.ap->lock);\r\nreturn res;\r\n}\r\ntask = sas_create_task(cmd, dev, GFP_ATOMIC);\r\nif (!task)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nif (sas_ha->lldd_max_execute_num < 2)\r\nres = i->dft->lldd_execute_task(task, 1, GFP_ATOMIC);\r\nelse\r\nres = sas_queue_up(task);\r\nif (res)\r\ngoto out_free_task;\r\nreturn 0;\r\nout_free_task:\r\nSAS_DPRINTK("lldd_execute_task returned: %d\n", res);\r\nASSIGN_SAS_TASK(cmd, NULL);\r\nsas_free_task(task);\r\nif (res == -SAS_QUEUE_FULL)\r\ncmd->result = DID_SOFT_ERROR << 16;\r\nelse\r\ncmd->result = DID_ERROR << 16;\r\nout_done:\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\nstatic void sas_eh_finish_cmd(struct scsi_cmnd *cmd)\r\n{\r\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd->device->host);\r\nstruct sas_task *task = TO_SAS_TASK(cmd);\r\nsas_end_task(cmd, task);\r\nscsi_eh_finish_cmd(cmd, &sas_ha->eh_done_q);\r\n}\r\nstatic void sas_eh_defer_cmd(struct scsi_cmnd *cmd)\r\n{\r\nstruct domain_device *dev = cmd_to_domain_dev(cmd);\r\nstruct sas_ha_struct *ha = dev->port->ha;\r\nstruct sas_task *task = TO_SAS_TASK(cmd);\r\nif (!dev_is_sata(dev)) {\r\nsas_eh_finish_cmd(cmd);\r\nreturn;\r\n}\r\nsas_end_task(cmd, task);\r\nlist_move_tail(&cmd->eh_entry, &ha->eh_ata_q);\r\n}\r\nstatic void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\r\n{\r\nstruct scsi_cmnd *cmd, *n;\r\nlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\r\nif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\r\ncmd->device->lun == my_cmd->device->lun)\r\nsas_eh_defer_cmd(cmd);\r\n}\r\n}\r\nstatic void sas_scsi_clear_queue_I_T(struct list_head *error_q,\r\nstruct domain_device *dev)\r\n{\r\nstruct scsi_cmnd *cmd, *n;\r\nlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\r\nstruct domain_device *x = cmd_to_domain_dev(cmd);\r\nif (x == dev)\r\nsas_eh_finish_cmd(cmd);\r\n}\r\n}\r\nstatic void sas_scsi_clear_queue_port(struct list_head *error_q,\r\nstruct asd_sas_port *port)\r\n{\r\nstruct scsi_cmnd *cmd, *n;\r\nlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\r\nstruct domain_device *dev = cmd_to_domain_dev(cmd);\r\nstruct asd_sas_port *x = dev->port;\r\nif (x == port)\r\nsas_eh_finish_cmd(cmd);\r\n}\r\n}\r\nstatic enum task_disposition sas_scsi_find_task(struct sas_task *task)\r\n{\r\nstruct sas_ha_struct *ha = task->dev->port->ha;\r\nunsigned long flags;\r\nint i, res;\r\nstruct sas_internal *si =\r\nto_sas_internal(task->dev->port->ha->core.shost->transportt);\r\nif (ha->lldd_max_execute_num > 1) {\r\nstruct scsi_core *core = &ha->core;\r\nstruct sas_task *t, *n;\r\nmutex_lock(&core->task_queue_flush);\r\nspin_lock_irqsave(&core->task_queue_lock, flags);\r\nlist_for_each_entry_safe(t, n, &core->task_queue, list)\r\nif (task == t) {\r\nlist_del_init(&t->list);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&core->task_queue_lock, flags);\r\nmutex_unlock(&core->task_queue_flush);\r\nif (task == t)\r\nreturn TASK_IS_NOT_AT_HA;\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nSAS_DPRINTK("%s: aborting task 0x%p\n", __func__, task);\r\nres = si->dft->lldd_abort_task(task);\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (task->task_state_flags & SAS_TASK_STATE_DONE) {\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nSAS_DPRINTK("%s: task 0x%p is done\n", __func__,\r\ntask);\r\nreturn TASK_IS_DONE;\r\n}\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nif (res == TMF_RESP_FUNC_COMPLETE) {\r\nSAS_DPRINTK("%s: task 0x%p is aborted\n",\r\n__func__, task);\r\nreturn TASK_IS_ABORTED;\r\n} else if (si->dft->lldd_query_task) {\r\nSAS_DPRINTK("%s: querying task 0x%p\n",\r\n__func__, task);\r\nres = si->dft->lldd_query_task(task);\r\nswitch (res) {\r\ncase TMF_RESP_FUNC_SUCC:\r\nSAS_DPRINTK("%s: task 0x%p at LU\n",\r\n__func__, task);\r\nreturn TASK_IS_AT_LU;\r\ncase TMF_RESP_FUNC_COMPLETE:\r\nSAS_DPRINTK("%s: task 0x%p not at LU\n",\r\n__func__, task);\r\nreturn TASK_IS_NOT_AT_LU;\r\ncase TMF_RESP_FUNC_FAILED:\r\nSAS_DPRINTK("%s: task 0x%p failed to abort\n",\r\n__func__, task);\r\nreturn TASK_ABORT_FAILED;\r\n}\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic int sas_recover_lu(struct domain_device *dev, struct scsi_cmnd *cmd)\r\n{\r\nint res = TMF_RESP_FUNC_FAILED;\r\nstruct scsi_lun lun;\r\nstruct sas_internal *i =\r\nto_sas_internal(dev->port->ha->core.shost->transportt);\r\nint_to_scsilun(cmd->device->lun, &lun);\r\nSAS_DPRINTK("eh: device %llx LUN %x has the task\n",\r\nSAS_ADDR(dev->sas_addr),\r\ncmd->device->lun);\r\nif (i->dft->lldd_abort_task_set)\r\nres = i->dft->lldd_abort_task_set(dev, lun.scsi_lun);\r\nif (res == TMF_RESP_FUNC_FAILED) {\r\nif (i->dft->lldd_clear_task_set)\r\nres = i->dft->lldd_clear_task_set(dev, lun.scsi_lun);\r\n}\r\nif (res == TMF_RESP_FUNC_FAILED) {\r\nif (i->dft->lldd_lu_reset)\r\nres = i->dft->lldd_lu_reset(dev, lun.scsi_lun);\r\n}\r\nreturn res;\r\n}\r\nstatic int sas_recover_I_T(struct domain_device *dev)\r\n{\r\nint res = TMF_RESP_FUNC_FAILED;\r\nstruct sas_internal *i =\r\nto_sas_internal(dev->port->ha->core.shost->transportt);\r\nSAS_DPRINTK("I_T nexus reset for dev %016llx\n",\r\nSAS_ADDR(dev->sas_addr));\r\nif (i->dft->lldd_I_T_nexus_reset)\r\nres = i->dft->lldd_I_T_nexus_reset(dev);\r\nreturn res;\r\n}\r\nstruct sas_phy *sas_get_local_phy(struct domain_device *dev)\r\n{\r\nstruct sas_ha_struct *ha = dev->port->ha;\r\nstruct sas_phy *phy;\r\nunsigned long flags;\r\nBUG_ON(!dev->phy);\r\nspin_lock_irqsave(&ha->phy_port_lock, flags);\r\nphy = dev->phy;\r\nget_device(&phy->dev);\r\nspin_unlock_irqrestore(&ha->phy_port_lock, flags);\r\nreturn phy;\r\n}\r\nstatic void sas_wait_eh(struct domain_device *dev)\r\n{\r\nstruct sas_ha_struct *ha = dev->port->ha;\r\nDEFINE_WAIT(wait);\r\nif (dev_is_sata(dev)) {\r\nata_port_wait_eh(dev->sata_dev.ap);\r\nreturn;\r\n}\r\nretry:\r\nspin_lock_irq(&ha->lock);\r\nwhile (test_bit(SAS_DEV_EH_PENDING, &dev->state)) {\r\nprepare_to_wait(&ha->eh_wait_q, &wait, TASK_UNINTERRUPTIBLE);\r\nspin_unlock_irq(&ha->lock);\r\nschedule();\r\nspin_lock_irq(&ha->lock);\r\n}\r\nfinish_wait(&ha->eh_wait_q, &wait);\r\nspin_unlock_irq(&ha->lock);\r\nif (scsi_host_in_recovery(ha->core.shost)) {\r\nmsleep(10);\r\ngoto retry;\r\n}\r\n}\r\nstatic int sas_queue_reset(struct domain_device *dev, int reset_type, int lun, int wait)\r\n{\r\nstruct sas_ha_struct *ha = dev->port->ha;\r\nint scheduled = 0, tries = 100;\r\nif (dev_is_sata(dev)) {\r\nsas_ata_schedule_reset(dev);\r\nif (wait)\r\nsas_ata_wait_eh(dev);\r\nreturn SUCCESS;\r\n}\r\nwhile (!scheduled && tries--) {\r\nspin_lock_irq(&ha->lock);\r\nif (!test_bit(SAS_DEV_EH_PENDING, &dev->state) &&\r\n!test_bit(reset_type, &dev->state)) {\r\nscheduled = 1;\r\nha->eh_active++;\r\nlist_add_tail(&dev->ssp_dev.eh_list_node, &ha->eh_dev_q);\r\nset_bit(SAS_DEV_EH_PENDING, &dev->state);\r\nset_bit(reset_type, &dev->state);\r\nint_to_scsilun(lun, &dev->ssp_dev.reset_lun);\r\nscsi_schedule_eh(ha->core.shost);\r\n}\r\nspin_unlock_irq(&ha->lock);\r\nif (wait)\r\nsas_wait_eh(dev);\r\nif (scheduled)\r\nreturn SUCCESS;\r\n}\r\nSAS_DPRINTK("%s reset of %s failed\n",\r\nreset_type == SAS_DEV_LU_RESET ? "LUN" : "Bus",\r\ndev_name(&dev->rphy->dev));\r\nreturn FAILED;\r\n}\r\nint sas_eh_abort_handler(struct scsi_cmnd *cmd)\r\n{\r\nint res;\r\nstruct sas_task *task = TO_SAS_TASK(cmd);\r\nstruct Scsi_Host *host = cmd->device->host;\r\nstruct sas_internal *i = to_sas_internal(host->transportt);\r\nif (current != host->ehandler)\r\nreturn FAILED;\r\nif (!i->dft->lldd_abort_task)\r\nreturn FAILED;\r\nres = i->dft->lldd_abort_task(task);\r\nif (res == TMF_RESP_FUNC_SUCC || res == TMF_RESP_FUNC_COMPLETE)\r\nreturn SUCCESS;\r\nreturn FAILED;\r\n}\r\nint sas_eh_device_reset_handler(struct scsi_cmnd *cmd)\r\n{\r\nint res;\r\nstruct scsi_lun lun;\r\nstruct Scsi_Host *host = cmd->device->host;\r\nstruct domain_device *dev = cmd_to_domain_dev(cmd);\r\nstruct sas_internal *i = to_sas_internal(host->transportt);\r\nif (current != host->ehandler)\r\nreturn sas_queue_reset(dev, SAS_DEV_LU_RESET, cmd->device->lun, 0);\r\nint_to_scsilun(cmd->device->lun, &lun);\r\nif (!i->dft->lldd_lu_reset)\r\nreturn FAILED;\r\nres = i->dft->lldd_lu_reset(dev, lun.scsi_lun);\r\nif (res == TMF_RESP_FUNC_SUCC || res == TMF_RESP_FUNC_COMPLETE)\r\nreturn SUCCESS;\r\nreturn FAILED;\r\n}\r\nint sas_eh_bus_reset_handler(struct scsi_cmnd *cmd)\r\n{\r\nint res;\r\nstruct Scsi_Host *host = cmd->device->host;\r\nstruct domain_device *dev = cmd_to_domain_dev(cmd);\r\nstruct sas_internal *i = to_sas_internal(host->transportt);\r\nif (current != host->ehandler)\r\nreturn sas_queue_reset(dev, SAS_DEV_RESET, 0, 0);\r\nif (!i->dft->lldd_I_T_nexus_reset)\r\nreturn FAILED;\r\nres = i->dft->lldd_I_T_nexus_reset(dev);\r\nif (res == TMF_RESP_FUNC_SUCC || res == TMF_RESP_FUNC_COMPLETE ||\r\nres == -ENODEV)\r\nreturn SUCCESS;\r\nreturn FAILED;\r\n}\r\nstatic int try_to_reset_cmd_device(struct scsi_cmnd *cmd)\r\n{\r\nint res;\r\nstruct Scsi_Host *shost = cmd->device->host;\r\nif (!shost->hostt->eh_device_reset_handler)\r\ngoto try_bus_reset;\r\nres = shost->hostt->eh_device_reset_handler(cmd);\r\nif (res == SUCCESS)\r\nreturn res;\r\ntry_bus_reset:\r\nif (shost->hostt->eh_bus_reset_handler)\r\nreturn shost->hostt->eh_bus_reset_handler(cmd);\r\nreturn FAILED;\r\n}\r\nstatic void sas_eh_handle_sas_errors(struct Scsi_Host *shost, struct list_head *work_q)\r\n{\r\nstruct scsi_cmnd *cmd, *n;\r\nenum task_disposition res = TASK_IS_DONE;\r\nint tmf_resp, need_reset;\r\nstruct sas_internal *i = to_sas_internal(shost->transportt);\r\nunsigned long flags;\r\nstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\r\nLIST_HEAD(done);\r\nlist_for_each_entry_safe(cmd, n, work_q, eh_entry) {\r\nstruct domain_device *dev = cmd_to_domain_dev(cmd);\r\nstruct sas_task *task;\r\nspin_lock_irqsave(&dev->done_lock, flags);\r\ntask = TO_SAS_TASK(cmd);\r\nspin_unlock_irqrestore(&dev->done_lock, flags);\r\nif (!task)\r\nlist_move_tail(&cmd->eh_entry, &done);\r\n}\r\nAgain:\r\nlist_for_each_entry_safe(cmd, n, work_q, eh_entry) {\r\nstruct sas_task *task = TO_SAS_TASK(cmd);\r\nlist_del_init(&cmd->eh_entry);\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nneed_reset = task->task_state_flags & SAS_TASK_NEED_DEV_RESET;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nif (need_reset) {\r\nSAS_DPRINTK("%s: task 0x%p requests reset\n",\r\n__func__, task);\r\ngoto reset;\r\n}\r\nSAS_DPRINTK("trying to find task 0x%p\n", task);\r\nres = sas_scsi_find_task(task);\r\ncmd->eh_eflags = 0;\r\nswitch (res) {\r\ncase TASK_IS_NOT_AT_HA:\r\nSAS_DPRINTK("%s: task 0x%p is not at ha: %s\n",\r\n__func__, task,\r\ncmd->retries ? "retry" : "aborted");\r\nif (cmd->retries)\r\ncmd->retries--;\r\nsas_eh_finish_cmd(cmd);\r\ncontinue;\r\ncase TASK_IS_DONE:\r\nSAS_DPRINTK("%s: task 0x%p is done\n", __func__,\r\ntask);\r\nsas_eh_defer_cmd(cmd);\r\ncontinue;\r\ncase TASK_IS_ABORTED:\r\nSAS_DPRINTK("%s: task 0x%p is aborted\n",\r\n__func__, task);\r\nsas_eh_defer_cmd(cmd);\r\ncontinue;\r\ncase TASK_IS_AT_LU:\r\nSAS_DPRINTK("task 0x%p is at LU: lu recover\n", task);\r\nreset:\r\ntmf_resp = sas_recover_lu(task->dev, cmd);\r\nif (tmf_resp == TMF_RESP_FUNC_COMPLETE) {\r\nSAS_DPRINTK("dev %016llx LU %x is "\r\n"recovered\n",\r\nSAS_ADDR(task->dev),\r\ncmd->device->lun);\r\nsas_eh_defer_cmd(cmd);\r\nsas_scsi_clear_queue_lu(work_q, cmd);\r\ngoto Again;\r\n}\r\ncase TASK_IS_NOT_AT_LU:\r\ncase TASK_ABORT_FAILED:\r\nSAS_DPRINTK("task 0x%p is not at LU: I_T recover\n",\r\ntask);\r\ntmf_resp = sas_recover_I_T(task->dev);\r\nif (tmf_resp == TMF_RESP_FUNC_COMPLETE ||\r\ntmf_resp == -ENODEV) {\r\nstruct domain_device *dev = task->dev;\r\nSAS_DPRINTK("I_T %016llx recovered\n",\r\nSAS_ADDR(task->dev->sas_addr));\r\nsas_eh_finish_cmd(cmd);\r\nsas_scsi_clear_queue_I_T(work_q, dev);\r\ngoto Again;\r\n}\r\ntry_to_reset_cmd_device(cmd);\r\nif (i->dft->lldd_clear_nexus_port) {\r\nstruct asd_sas_port *port = task->dev->port;\r\nSAS_DPRINTK("clearing nexus for port:%d\n",\r\nport->id);\r\nres = i->dft->lldd_clear_nexus_port(port);\r\nif (res == TMF_RESP_FUNC_COMPLETE) {\r\nSAS_DPRINTK("clear nexus port:%d "\r\n"succeeded\n", port->id);\r\nsas_eh_finish_cmd(cmd);\r\nsas_scsi_clear_queue_port(work_q,\r\nport);\r\ngoto Again;\r\n}\r\n}\r\nif (i->dft->lldd_clear_nexus_ha) {\r\nSAS_DPRINTK("clear nexus ha\n");\r\nres = i->dft->lldd_clear_nexus_ha(ha);\r\nif (res == TMF_RESP_FUNC_COMPLETE) {\r\nSAS_DPRINTK("clear nexus ha "\r\n"succeeded\n");\r\nsas_eh_finish_cmd(cmd);\r\ngoto clear_q;\r\n}\r\n}\r\nSAS_DPRINTK("error from device %llx, LUN %x "\r\n"couldn't be recovered in any way\n",\r\nSAS_ADDR(task->dev->sas_addr),\r\ncmd->device->lun);\r\nsas_eh_finish_cmd(cmd);\r\ngoto clear_q;\r\n}\r\n}\r\nout:\r\nlist_splice_tail(&done, work_q);\r\nlist_splice_tail_init(&ha->eh_ata_q, work_q);\r\nreturn;\r\nclear_q:\r\nSAS_DPRINTK("--- Exit %s -- clear_q\n", __func__);\r\nlist_for_each_entry_safe(cmd, n, work_q, eh_entry)\r\nsas_eh_finish_cmd(cmd);\r\ngoto out;\r\n}\r\nstatic void sas_eh_handle_resets(struct Scsi_Host *shost)\r\n{\r\nstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\r\nstruct sas_internal *i = to_sas_internal(shost->transportt);\r\nspin_lock_irq(&ha->lock);\r\nwhile (!list_empty(&ha->eh_dev_q)) {\r\nstruct domain_device *dev;\r\nstruct ssp_device *ssp;\r\nssp = list_entry(ha->eh_dev_q.next, typeof(*ssp), eh_list_node);\r\nlist_del_init(&ssp->eh_list_node);\r\ndev = container_of(ssp, typeof(*dev), ssp_dev);\r\nkref_get(&dev->kref);\r\nWARN_ONCE(dev_is_sata(dev), "ssp reset to ata device?\n");\r\nspin_unlock_irq(&ha->lock);\r\nif (test_and_clear_bit(SAS_DEV_LU_RESET, &dev->state))\r\ni->dft->lldd_lu_reset(dev, ssp->reset_lun.scsi_lun);\r\nif (test_and_clear_bit(SAS_DEV_RESET, &dev->state))\r\ni->dft->lldd_I_T_nexus_reset(dev);\r\nsas_put_device(dev);\r\nspin_lock_irq(&ha->lock);\r\nclear_bit(SAS_DEV_EH_PENDING, &dev->state);\r\nha->eh_active--;\r\n}\r\nspin_unlock_irq(&ha->lock);\r\n}\r\nvoid sas_scsi_recover_host(struct Scsi_Host *shost)\r\n{\r\nstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\r\nLIST_HEAD(eh_work_q);\r\nint tries = 0;\r\nbool retry;\r\nretry:\r\ntries++;\r\nretry = true;\r\nspin_lock_irq(shost->host_lock);\r\nlist_splice_init(&shost->eh_cmd_q, &eh_work_q);\r\nspin_unlock_irq(shost->host_lock);\r\nSAS_DPRINTK("Enter %s busy: %d failed: %d\n",\r\n__func__, shost->host_busy, shost->host_failed);\r\nset_bit(SAS_HA_FROZEN, &ha->state);\r\nsas_eh_handle_sas_errors(shost, &eh_work_q);\r\nclear_bit(SAS_HA_FROZEN, &ha->state);\r\nif (list_empty(&eh_work_q))\r\ngoto out;\r\nsas_ata_eh(shost, &eh_work_q, &ha->eh_done_q);\r\nif (!scsi_eh_get_sense(&eh_work_q, &ha->eh_done_q))\r\nscsi_eh_ready_devs(shost, &eh_work_q, &ha->eh_done_q);\r\nout:\r\nif (ha->lldd_max_execute_num > 1)\r\nwake_up_process(ha->core.queue_thread);\r\nsas_eh_handle_resets(shost);\r\nsas_ata_strategy_handler(shost);\r\nscsi_eh_flush_done_q(&ha->eh_done_q);\r\nspin_lock_irq(&ha->lock);\r\nif (ha->eh_active == 0) {\r\nshost->host_eh_scheduled = 0;\r\nretry = false;\r\n}\r\nspin_unlock_irq(&ha->lock);\r\nif (retry)\r\ngoto retry;\r\nSAS_DPRINTK("--- Exit %s: busy: %d failed: %d tries: %d\n",\r\n__func__, shost->host_busy, shost->host_failed, tries);\r\n}\r\nenum blk_eh_timer_return sas_scsi_timed_out(struct scsi_cmnd *cmd)\r\n{\r\nscmd_printk(KERN_DEBUG, cmd, "command %p timed out\n", cmd);\r\nreturn BLK_EH_NOT_HANDLED;\r\n}\r\nint sas_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\r\n{\r\nstruct domain_device *dev = sdev_to_domain_dev(sdev);\r\nif (dev_is_sata(dev))\r\nreturn ata_sas_scsi_ioctl(dev->sata_dev.ap, sdev, cmd, arg);\r\nreturn -EINVAL;\r\n}\r\nstruct domain_device *sas_find_dev_by_rphy(struct sas_rphy *rphy)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(rphy->dev.parent);\r\nstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\r\nstruct domain_device *found_dev = NULL;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->phy_port_lock, flags);\r\nfor (i = 0; i < ha->num_phys; i++) {\r\nstruct asd_sas_port *port = ha->sas_port[i];\r\nstruct domain_device *dev;\r\nspin_lock(&port->dev_list_lock);\r\nlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\r\nif (rphy == dev->rphy) {\r\nfound_dev = dev;\r\nspin_unlock(&port->dev_list_lock);\r\ngoto found;\r\n}\r\n}\r\nspin_unlock(&port->dev_list_lock);\r\n}\r\nfound:\r\nspin_unlock_irqrestore(&ha->phy_port_lock, flags);\r\nreturn found_dev;\r\n}\r\nint sas_target_alloc(struct scsi_target *starget)\r\n{\r\nstruct sas_rphy *rphy = dev_to_rphy(starget->dev.parent);\r\nstruct domain_device *found_dev = sas_find_dev_by_rphy(rphy);\r\nif (!found_dev)\r\nreturn -ENODEV;\r\nkref_get(&found_dev->kref);\r\nstarget->hostdata = found_dev;\r\nreturn 0;\r\n}\r\nint sas_slave_configure(struct scsi_device *scsi_dev)\r\n{\r\nstruct domain_device *dev = sdev_to_domain_dev(scsi_dev);\r\nstruct sas_ha_struct *sas_ha;\r\nBUG_ON(dev->rphy->identify.device_type != SAS_END_DEVICE);\r\nif (dev_is_sata(dev)) {\r\nata_sas_slave_configure(scsi_dev, dev->sata_dev.ap);\r\nreturn 0;\r\n}\r\nsas_ha = dev->port->ha;\r\nsas_read_port_mode_page(scsi_dev);\r\nif (scsi_dev->tagged_supported) {\r\nscsi_set_tag_type(scsi_dev, MSG_SIMPLE_TAG);\r\nscsi_activate_tcq(scsi_dev, SAS_DEF_QD);\r\n} else {\r\nSAS_DPRINTK("device %llx, LUN %x doesn't support "\r\n"TCQ\n", SAS_ADDR(dev->sas_addr),\r\nscsi_dev->lun);\r\nscsi_dev->tagged_supported = 0;\r\nscsi_set_tag_type(scsi_dev, 0);\r\nscsi_deactivate_tcq(scsi_dev, 1);\r\n}\r\nscsi_dev->allow_restart = 1;\r\nreturn 0;\r\n}\r\nint sas_change_queue_depth(struct scsi_device *sdev, int depth, int reason)\r\n{\r\nstruct domain_device *dev = sdev_to_domain_dev(sdev);\r\nif (dev_is_sata(dev))\r\nreturn __ata_change_queue_depth(dev->sata_dev.ap, sdev, depth,\r\nreason);\r\nswitch (reason) {\r\ncase SCSI_QDEPTH_DEFAULT:\r\ncase SCSI_QDEPTH_RAMP_UP:\r\nif (!sdev->tagged_supported)\r\ndepth = 1;\r\nscsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);\r\nbreak;\r\ncase SCSI_QDEPTH_QFULL:\r\nscsi_track_queue_full(sdev, depth);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn depth;\r\n}\r\nint sas_change_queue_type(struct scsi_device *scsi_dev, int qt)\r\n{\r\nstruct domain_device *dev = sdev_to_domain_dev(scsi_dev);\r\nif (dev_is_sata(dev))\r\nreturn -EINVAL;\r\nif (!scsi_dev->tagged_supported)\r\nreturn 0;\r\nscsi_deactivate_tcq(scsi_dev, 1);\r\nscsi_set_tag_type(scsi_dev, qt);\r\nscsi_activate_tcq(scsi_dev, scsi_dev->queue_depth);\r\nreturn qt;\r\n}\r\nint sas_bios_param(struct scsi_device *scsi_dev,\r\nstruct block_device *bdev,\r\nsector_t capacity, int *hsc)\r\n{\r\nhsc[0] = 255;\r\nhsc[1] = 63;\r\nsector_div(capacity, 255*63);\r\nhsc[2] = capacity;\r\nreturn 0;\r\n}\r\nstatic void sas_queue(struct sas_ha_struct *sas_ha)\r\n{\r\nstruct scsi_core *core = &sas_ha->core;\r\nunsigned long flags;\r\nLIST_HEAD(q);\r\nint can_queue;\r\nint res;\r\nstruct sas_internal *i = to_sas_internal(core->shost->transportt);\r\nmutex_lock(&core->task_queue_flush);\r\nspin_lock_irqsave(&core->task_queue_lock, flags);\r\nwhile (!kthread_should_stop() &&\r\n!list_empty(&core->task_queue) &&\r\n!test_bit(SAS_HA_FROZEN, &sas_ha->state)) {\r\ncan_queue = sas_ha->lldd_queue_size - core->task_queue_size;\r\nif (can_queue >= 0) {\r\ncan_queue = core->task_queue_size;\r\nlist_splice_init(&core->task_queue, &q);\r\n} else {\r\nstruct list_head *a, *n;\r\ncan_queue = sas_ha->lldd_queue_size;\r\nlist_for_each_safe(a, n, &core->task_queue) {\r\nlist_move_tail(a, &q);\r\nif (--can_queue == 0)\r\nbreak;\r\n}\r\ncan_queue = sas_ha->lldd_queue_size;\r\n}\r\ncore->task_queue_size -= can_queue;\r\nspin_unlock_irqrestore(&core->task_queue_lock, flags);\r\n{\r\nstruct sas_task *task = list_entry(q.next,\r\nstruct sas_task,\r\nlist);\r\nlist_del_init(&q);\r\nres = i->dft->lldd_execute_task(task, can_queue,\r\nGFP_KERNEL);\r\nif (unlikely(res))\r\n__list_add(&q, task->list.prev, &task->list);\r\n}\r\nspin_lock_irqsave(&core->task_queue_lock, flags);\r\nif (res) {\r\nlist_splice_init(&q, &core->task_queue);\r\ncore->task_queue_size += can_queue;\r\n}\r\n}\r\nspin_unlock_irqrestore(&core->task_queue_lock, flags);\r\nmutex_unlock(&core->task_queue_flush);\r\n}\r\nstatic int sas_queue_thread(void *_sas_ha)\r\n{\r\nstruct sas_ha_struct *sas_ha = _sas_ha;\r\nwhile (1) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\nsas_queue(sas_ha);\r\nif (kthread_should_stop())\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint sas_init_queue(struct sas_ha_struct *sas_ha)\r\n{\r\nstruct scsi_core *core = &sas_ha->core;\r\nspin_lock_init(&core->task_queue_lock);\r\nmutex_init(&core->task_queue_flush);\r\ncore->task_queue_size = 0;\r\nINIT_LIST_HEAD(&core->task_queue);\r\ncore->queue_thread = kthread_run(sas_queue_thread, sas_ha,\r\n"sas_queue_%d", core->shost->host_no);\r\nif (IS_ERR(core->queue_thread))\r\nreturn PTR_ERR(core->queue_thread);\r\nreturn 0;\r\n}\r\nvoid sas_shutdown_queue(struct sas_ha_struct *sas_ha)\r\n{\r\nunsigned long flags;\r\nstruct scsi_core *core = &sas_ha->core;\r\nstruct sas_task *task, *n;\r\nkthread_stop(core->queue_thread);\r\nif (!list_empty(&core->task_queue))\r\nSAS_DPRINTK("HA: %llx: scsi core task queue is NOT empty!?\n",\r\nSAS_ADDR(sas_ha->sas_addr));\r\nspin_lock_irqsave(&core->task_queue_lock, flags);\r\nlist_for_each_entry_safe(task, n, &core->task_queue, list) {\r\nstruct scsi_cmnd *cmd = task->uldd_task;\r\nlist_del_init(&task->list);\r\nASSIGN_SAS_TASK(cmd, NULL);\r\nsas_free_task(task);\r\ncmd->result = DID_ABORT << 16;\r\ncmd->scsi_done(cmd);\r\n}\r\nspin_unlock_irqrestore(&core->task_queue_lock, flags);\r\n}\r\nvoid sas_task_abort(struct sas_task *task)\r\n{\r\nstruct scsi_cmnd *sc = task->uldd_task;\r\nif (!sc) {\r\nstruct sas_task_slow *slow = task->slow_task;\r\nif (!slow)\r\nreturn;\r\nif (!del_timer(&slow->timer))\r\nreturn;\r\nslow->timer.function(slow->timer.data);\r\nreturn;\r\n}\r\nif (dev_is_sata(task->dev)) {\r\nsas_ata_task_abort(task);\r\n} else {\r\nstruct request_queue *q = sc->device->request_queue;\r\nunsigned long flags;\r\nspin_lock_irqsave(q->queue_lock, flags);\r\nblk_abort_request(sc->request);\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\n}\r\n}\r\nvoid sas_target_destroy(struct scsi_target *starget)\r\n{\r\nstruct domain_device *found_dev = starget->hostdata;\r\nif (!found_dev)\r\nreturn;\r\nstarget->hostdata = NULL;\r\nsas_put_device(found_dev);\r\n}\r\nstatic void sas_parse_addr(u8 *sas_addr, const char *p)\r\n{\r\nint i;\r\nfor (i = 0; i < SAS_ADDR_SIZE; i++) {\r\nu8 h, l;\r\nif (!*p)\r\nbreak;\r\nh = isdigit(*p) ? *p-'0' : toupper(*p)-'A'+10;\r\np++;\r\nl = isdigit(*p) ? *p-'0' : toupper(*p)-'A'+10;\r\np++;\r\nsas_addr[i] = (h<<4) | l;\r\n}\r\n}\r\nint sas_request_addr(struct Scsi_Host *shost, u8 *addr)\r\n{\r\nint res;\r\nconst struct firmware *fw;\r\nres = request_firmware(&fw, "sas_addr", &shost->shost_gendev);\r\nif (res)\r\nreturn res;\r\nif (fw->size < SAS_STRING_ADDR_SIZE) {\r\nres = -ENODEV;\r\ngoto out;\r\n}\r\nsas_parse_addr(addr, fw->data);\r\nout:\r\nrelease_firmware(fw);\r\nreturn res;\r\n}
