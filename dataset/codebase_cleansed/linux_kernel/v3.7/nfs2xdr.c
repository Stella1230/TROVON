static void prepare_reply_buffer(struct rpc_rqst *req, struct page **pages,\r\nunsigned int base, unsigned int len,\r\nunsigned int bufsize)\r\n{\r\nstruct rpc_auth *auth = req->rq_cred->cr_auth;\r\nunsigned int replen;\r\nreplen = RPC_REPHDRSIZE + auth->au_rslack + bufsize;\r\nxdr_inline_pages(&req->rq_rcv_buf, replen << 2, pages, base, len);\r\n}\r\nstatic void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\r\n{\r\ndprintk("NFS: %s prematurely hit the end of our receive buffer. "\r\n"Remaining buffer length is %tu words.\n",\r\nfunc, xdr->end - xdr->p);\r\n}\r\nstatic int decode_nfsdata(struct xdr_stream *xdr, struct nfs_readres *result)\r\n{\r\nu32 recvd, count;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\ncount = be32_to_cpup(p);\r\nrecvd = xdr_read_pages(xdr, count);\r\nif (unlikely(count > recvd))\r\ngoto out_cheating;\r\nout:\r\nresult->eof = 0;\r\nresult->count = count;\r\nreturn count;\r\nout_cheating:\r\ndprintk("NFS: server cheating in read result: "\r\n"count %u > recvd %u\n", count, recvd);\r\ncount = recvd;\r\ngoto out;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic int decode_stat(struct xdr_stream *xdr, enum nfs_stat *status)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\n*status = be32_to_cpup(p);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic __be32 *xdr_decode_ftype(__be32 *p, u32 *type)\r\n{\r\n*type = be32_to_cpup(p++);\r\nif (unlikely(*type > NF2FIFO))\r\n*type = NFBAD;\r\nreturn p;\r\n}\r\nstatic void encode_fhandle(struct xdr_stream *xdr, const struct nfs_fh *fh)\r\n{\r\n__be32 *p;\r\nBUG_ON(fh->size != NFS2_FHSIZE);\r\np = xdr_reserve_space(xdr, NFS2_FHSIZE);\r\nmemcpy(p, fh->data, NFS2_FHSIZE);\r\n}\r\nstatic int decode_fhandle(struct xdr_stream *xdr, struct nfs_fh *fh)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, NFS2_FHSIZE);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nfh->size = NFS2_FHSIZE;\r\nmemcpy(fh->data, p, NFS2_FHSIZE);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic __be32 *xdr_encode_time(__be32 *p, const struct timespec *timep)\r\n{\r\n*p++ = cpu_to_be32(timep->tv_sec);\r\nif (timep->tv_nsec != 0)\r\n*p++ = cpu_to_be32(timep->tv_nsec / NSEC_PER_USEC);\r\nelse\r\n*p++ = cpu_to_be32(0);\r\nreturn p;\r\n}\r\nstatic __be32 *xdr_encode_current_server_time(__be32 *p,\r\nconst struct timespec *timep)\r\n{\r\n*p++ = cpu_to_be32(timep->tv_sec);\r\n*p++ = cpu_to_be32(1000000);\r\nreturn p;\r\n}\r\nstatic __be32 *xdr_decode_time(__be32 *p, struct timespec *timep)\r\n{\r\ntimep->tv_sec = be32_to_cpup(p++);\r\ntimep->tv_nsec = be32_to_cpup(p++) * NSEC_PER_USEC;\r\nreturn p;\r\n}\r\nstatic int decode_fattr(struct xdr_stream *xdr, struct nfs_fattr *fattr)\r\n{\r\nu32 rdev, type;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, NFS_fattr_sz << 2);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nfattr->valid |= NFS_ATTR_FATTR_V2;\r\np = xdr_decode_ftype(p, &type);\r\nfattr->mode = be32_to_cpup(p++);\r\nfattr->nlink = be32_to_cpup(p++);\r\nfattr->uid = be32_to_cpup(p++);\r\nfattr->gid = be32_to_cpup(p++);\r\nfattr->size = be32_to_cpup(p++);\r\nfattr->du.nfs2.blocksize = be32_to_cpup(p++);\r\nrdev = be32_to_cpup(p++);\r\nfattr->rdev = new_decode_dev(rdev);\r\nif (type == (u32)NFCHR && rdev == (u32)NFS2_FIFO_DEV) {\r\nfattr->mode = (fattr->mode & ~S_IFMT) | S_IFIFO;\r\nfattr->rdev = 0;\r\n}\r\nfattr->du.nfs2.blocks = be32_to_cpup(p++);\r\nfattr->fsid.major = be32_to_cpup(p++);\r\nfattr->fsid.minor = 0;\r\nfattr->fileid = be32_to_cpup(p++);\r\np = xdr_decode_time(p, &fattr->atime);\r\np = xdr_decode_time(p, &fattr->mtime);\r\nxdr_decode_time(p, &fattr->ctime);\r\nfattr->change_attr = nfs_timespec_to_change_attr(&fattr->ctime);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic __be32 *xdr_time_not_set(__be32 *p)\r\n{\r\n*p++ = cpu_to_be32(NFS2_SATTR_NOT_SET);\r\n*p++ = cpu_to_be32(NFS2_SATTR_NOT_SET);\r\nreturn p;\r\n}\r\nstatic void encode_sattr(struct xdr_stream *xdr, const struct iattr *attr)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, NFS_sattr_sz << 2);\r\nif (attr->ia_valid & ATTR_MODE)\r\n*p++ = cpu_to_be32(attr->ia_mode);\r\nelse\r\n*p++ = cpu_to_be32(NFS2_SATTR_NOT_SET);\r\nif (attr->ia_valid & ATTR_UID)\r\n*p++ = cpu_to_be32(attr->ia_uid);\r\nelse\r\n*p++ = cpu_to_be32(NFS2_SATTR_NOT_SET);\r\nif (attr->ia_valid & ATTR_GID)\r\n*p++ = cpu_to_be32(attr->ia_gid);\r\nelse\r\n*p++ = cpu_to_be32(NFS2_SATTR_NOT_SET);\r\nif (attr->ia_valid & ATTR_SIZE)\r\n*p++ = cpu_to_be32((u32)attr->ia_size);\r\nelse\r\n*p++ = cpu_to_be32(NFS2_SATTR_NOT_SET);\r\nif (attr->ia_valid & ATTR_ATIME_SET)\r\np = xdr_encode_time(p, &attr->ia_atime);\r\nelse if (attr->ia_valid & ATTR_ATIME)\r\np = xdr_encode_current_server_time(p, &attr->ia_atime);\r\nelse\r\np = xdr_time_not_set(p);\r\nif (attr->ia_valid & ATTR_MTIME_SET)\r\nxdr_encode_time(p, &attr->ia_mtime);\r\nelse if (attr->ia_valid & ATTR_MTIME)\r\nxdr_encode_current_server_time(p, &attr->ia_mtime);\r\nelse\r\nxdr_time_not_set(p);\r\n}\r\nstatic void encode_filename(struct xdr_stream *xdr,\r\nconst char *name, u32 length)\r\n{\r\n__be32 *p;\r\nBUG_ON(length > NFS2_MAXNAMLEN);\r\np = xdr_reserve_space(xdr, 4 + length);\r\nxdr_encode_opaque(p, name, length);\r\n}\r\nstatic int decode_filename_inline(struct xdr_stream *xdr,\r\nconst char **name, u32 *length)\r\n{\r\n__be32 *p;\r\nu32 count;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\ncount = be32_to_cpup(p);\r\nif (count > NFS3_MAXNAMLEN)\r\ngoto out_nametoolong;\r\np = xdr_inline_decode(xdr, count);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\n*name = (const char *)p;\r\n*length = count;\r\nreturn 0;\r\nout_nametoolong:\r\ndprintk("NFS: returned filename too long: %u\n", count);\r\nreturn -ENAMETOOLONG;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_path(struct xdr_stream *xdr, struct page **pages, u32 length)\r\n{\r\n__be32 *p;\r\nBUG_ON(length > NFS2_MAXPATHLEN);\r\np = xdr_reserve_space(xdr, 4);\r\n*p = cpu_to_be32(length);\r\nxdr_write_pages(xdr, pages, 0, length);\r\n}\r\nstatic int decode_path(struct xdr_stream *xdr)\r\n{\r\nu32 length, recvd;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nlength = be32_to_cpup(p);\r\nif (unlikely(length >= xdr->buf->page_len || length > NFS_MAXPATHLEN))\r\ngoto out_size;\r\nrecvd = xdr_read_pages(xdr, length);\r\nif (unlikely(length > recvd))\r\ngoto out_cheating;\r\nxdr_terminate_string(xdr->buf, length);\r\nreturn 0;\r\nout_size:\r\ndprintk("NFS: returned pathname too long: %u\n", length);\r\nreturn -ENAMETOOLONG;\r\nout_cheating:\r\ndprintk("NFS: server cheating in pathname result: "\r\n"length %u > received %u\n", length, recvd);\r\nreturn -EIO;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic int decode_attrstat(struct xdr_stream *xdr, struct nfs_fattr *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_stat(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS_OK)\r\ngoto out_default;\r\nerror = decode_fattr(xdr, result);\r\nout:\r\nreturn error;\r\nout_default:\r\nreturn nfs_stat_to_errno(status);\r\n}\r\nstatic void encode_diropargs(struct xdr_stream *xdr, const struct nfs_fh *fh,\r\nconst char *name, u32 length)\r\n{\r\nencode_fhandle(xdr, fh);\r\nencode_filename(xdr, name, length);\r\n}\r\nstatic int decode_diropok(struct xdr_stream *xdr, struct nfs_diropok *result)\r\n{\r\nint error;\r\nerror = decode_fhandle(xdr, result->fh);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_fattr(xdr, result->fattr);\r\nout:\r\nreturn error;\r\n}\r\nstatic int decode_diropres(struct xdr_stream *xdr, struct nfs_diropok *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_stat(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS_OK)\r\ngoto out_default;\r\nerror = decode_diropok(xdr, result);\r\nout:\r\nreturn error;\r\nout_default:\r\nreturn nfs_stat_to_errno(status);\r\n}\r\nstatic void nfs2_xdr_enc_fhandle(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_fh *fh)\r\n{\r\nencode_fhandle(xdr, fh);\r\n}\r\nstatic void nfs2_xdr_enc_sattrargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_sattrargs *args)\r\n{\r\nencode_fhandle(xdr, args->fh);\r\nencode_sattr(xdr, args->sattr);\r\n}\r\nstatic void nfs2_xdr_enc_diropargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_diropargs *args)\r\n{\r\nencode_diropargs(xdr, args->fh, args->name, args->len);\r\n}\r\nstatic void nfs2_xdr_enc_readlinkargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_readlinkargs *args)\r\n{\r\nencode_fhandle(xdr, args->fh);\r\nprepare_reply_buffer(req, args->pages, args->pgbase,\r\nargs->pglen, NFS_readlinkres_sz);\r\n}\r\nstatic void encode_readargs(struct xdr_stream *xdr,\r\nconst struct nfs_readargs *args)\r\n{\r\nu32 offset = args->offset;\r\nu32 count = args->count;\r\n__be32 *p;\r\nencode_fhandle(xdr, args->fh);\r\np = xdr_reserve_space(xdr, 4 + 4 + 4);\r\n*p++ = cpu_to_be32(offset);\r\n*p++ = cpu_to_be32(count);\r\n*p = cpu_to_be32(count);\r\n}\r\nstatic void nfs2_xdr_enc_readargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_readargs *args)\r\n{\r\nencode_readargs(xdr, args);\r\nprepare_reply_buffer(req, args->pages, args->pgbase,\r\nargs->count, NFS_readres_sz);\r\nreq->rq_rcv_buf.flags |= XDRBUF_READ;\r\n}\r\nstatic void encode_writeargs(struct xdr_stream *xdr,\r\nconst struct nfs_writeargs *args)\r\n{\r\nu32 offset = args->offset;\r\nu32 count = args->count;\r\n__be32 *p;\r\nencode_fhandle(xdr, args->fh);\r\np = xdr_reserve_space(xdr, 4 + 4 + 4 + 4);\r\n*p++ = cpu_to_be32(offset);\r\n*p++ = cpu_to_be32(offset);\r\n*p++ = cpu_to_be32(count);\r\n*p = cpu_to_be32(count);\r\nxdr_write_pages(xdr, args->pages, args->pgbase, count);\r\n}\r\nstatic void nfs2_xdr_enc_writeargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_writeargs *args)\r\n{\r\nencode_writeargs(xdr, args);\r\nxdr->buf->flags |= XDRBUF_WRITE;\r\n}\r\nstatic void nfs2_xdr_enc_createargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_createargs *args)\r\n{\r\nencode_diropargs(xdr, args->fh, args->name, args->len);\r\nencode_sattr(xdr, args->sattr);\r\n}\r\nstatic void nfs2_xdr_enc_removeargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_removeargs *args)\r\n{\r\nencode_diropargs(xdr, args->fh, args->name.name, args->name.len);\r\n}\r\nstatic void nfs2_xdr_enc_renameargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_renameargs *args)\r\n{\r\nconst struct qstr *old = args->old_name;\r\nconst struct qstr *new = args->new_name;\r\nencode_diropargs(xdr, args->old_dir, old->name, old->len);\r\nencode_diropargs(xdr, args->new_dir, new->name, new->len);\r\n}\r\nstatic void nfs2_xdr_enc_linkargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_linkargs *args)\r\n{\r\nencode_fhandle(xdr, args->fromfh);\r\nencode_diropargs(xdr, args->tofh, args->toname, args->tolen);\r\n}\r\nstatic void nfs2_xdr_enc_symlinkargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_symlinkargs *args)\r\n{\r\nencode_diropargs(xdr, args->fromfh, args->fromname, args->fromlen);\r\nencode_path(xdr, args->pages, args->pathlen);\r\nencode_sattr(xdr, args->sattr);\r\n}\r\nstatic void encode_readdirargs(struct xdr_stream *xdr,\r\nconst struct nfs_readdirargs *args)\r\n{\r\n__be32 *p;\r\nencode_fhandle(xdr, args->fh);\r\np = xdr_reserve_space(xdr, 4 + 4);\r\n*p++ = cpu_to_be32(args->cookie);\r\n*p = cpu_to_be32(args->count);\r\n}\r\nstatic void nfs2_xdr_enc_readdirargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_readdirargs *args)\r\n{\r\nencode_readdirargs(xdr, args);\r\nprepare_reply_buffer(req, args->pages, 0,\r\nargs->count, NFS_readdirres_sz);\r\n}\r\nstatic int nfs2_xdr_dec_stat(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nvoid *__unused)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_stat(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS_OK)\r\ngoto out_default;\r\nout:\r\nreturn error;\r\nout_default:\r\nreturn nfs_stat_to_errno(status);\r\n}\r\nstatic int nfs2_xdr_dec_attrstat(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nstruct nfs_fattr *result)\r\n{\r\nreturn decode_attrstat(xdr, result);\r\n}\r\nstatic int nfs2_xdr_dec_diropres(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nstruct nfs_diropok *result)\r\n{\r\nreturn decode_diropres(xdr, result);\r\n}\r\nstatic int nfs2_xdr_dec_readlinkres(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr, void *__unused)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_stat(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS_OK)\r\ngoto out_default;\r\nerror = decode_path(xdr);\r\nout:\r\nreturn error;\r\nout_default:\r\nreturn nfs_stat_to_errno(status);\r\n}\r\nstatic int nfs2_xdr_dec_readres(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nstruct nfs_readres *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_stat(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS_OK)\r\ngoto out_default;\r\nerror = decode_fattr(xdr, result->fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_nfsdata(xdr, result);\r\nout:\r\nreturn error;\r\nout_default:\r\nreturn nfs_stat_to_errno(status);\r\n}\r\nstatic int nfs2_xdr_dec_writeres(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nstruct nfs_writeres *result)\r\n{\r\nresult->verf->committed = NFS_FILE_SYNC;\r\nreturn decode_attrstat(xdr, result->fattr);\r\n}\r\nint nfs2_decode_dirent(struct xdr_stream *xdr, struct nfs_entry *entry,\r\nint plus)\r\n{\r\n__be32 *p;\r\nint error;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nif (*p++ == xdr_zero) {\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nif (*p++ == xdr_zero)\r\nreturn -EAGAIN;\r\nentry->eof = 1;\r\nreturn -EBADCOOKIE;\r\n}\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nentry->ino = be32_to_cpup(p);\r\nerror = decode_filename_inline(xdr, &entry->name, &entry->len);\r\nif (unlikely(error))\r\nreturn error;\r\nentry->prev_cookie = entry->cookie;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nentry->cookie = be32_to_cpup(p);\r\nentry->d_type = DT_UNKNOWN;\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EAGAIN;\r\n}\r\nstatic int decode_readdirok(struct xdr_stream *xdr)\r\n{\r\nreturn xdr_read_pages(xdr, xdr->buf->page_len);\r\n}\r\nstatic int nfs2_xdr_dec_readdirres(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr, void *__unused)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_stat(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS_OK)\r\ngoto out_default;\r\nerror = decode_readdirok(xdr);\r\nout:\r\nreturn error;\r\nout_default:\r\nreturn nfs_stat_to_errno(status);\r\n}\r\nstatic int decode_info(struct xdr_stream *xdr, struct nfs2_fsstat *result)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, NFS_info_sz << 2);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nresult->tsize = be32_to_cpup(p++);\r\nresult->bsize = be32_to_cpup(p++);\r\nresult->blocks = be32_to_cpup(p++);\r\nresult->bfree = be32_to_cpup(p++);\r\nresult->bavail = be32_to_cpup(p);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic int nfs2_xdr_dec_statfsres(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nstruct nfs2_fsstat *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_stat(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS_OK)\r\ngoto out_default;\r\nerror = decode_info(xdr, result);\r\nout:\r\nreturn error;\r\nout_default:\r\nreturn nfs_stat_to_errno(status);\r\n}\r\nstatic int nfs_stat_to_errno(enum nfs_stat status)\r\n{\r\nint i;\r\nfor (i = 0; nfs_errtbl[i].stat != -1; i++) {\r\nif (nfs_errtbl[i].stat == (int)status)\r\nreturn nfs_errtbl[i].errno;\r\n}\r\ndprintk("NFS: Unrecognized nfs status value: %u\n", status);\r\nreturn nfs_errtbl[i].errno;\r\n}
