static u32\r\nacpi_ps_get_next_package_length(struct acpi_parse_state *parser_state)\r\n{\r\nu8 *aml = parser_state->aml;\r\nu32 package_length = 0;\r\nu32 byte_count;\r\nu8 byte_zero_mask = 0x3F;\r\nACPI_FUNCTION_TRACE(ps_get_next_package_length);\r\nbyte_count = (aml[0] >> 6);\r\nparser_state->aml += ((acpi_size) byte_count + 1);\r\nwhile (byte_count) {\r\npackage_length |= (aml[byte_count] << ((byte_count << 3) - 4));\r\nbyte_zero_mask = 0x0F;\r\nbyte_count--;\r\n}\r\npackage_length |= (aml[0] & byte_zero_mask);\r\nreturn_UINT32(package_length);\r\n}\r\nu8 *acpi_ps_get_next_package_end(struct acpi_parse_state *parser_state)\r\n{\r\nu8 *start = parser_state->aml;\r\nu32 package_length;\r\nACPI_FUNCTION_TRACE(ps_get_next_package_end);\r\npackage_length = acpi_ps_get_next_package_length(parser_state);\r\nreturn_PTR(start + package_length);\r\n}\r\nchar *acpi_ps_get_next_namestring(struct acpi_parse_state *parser_state)\r\n{\r\nu8 *start = parser_state->aml;\r\nu8 *end = parser_state->aml;\r\nACPI_FUNCTION_TRACE(ps_get_next_namestring);\r\nwhile (acpi_ps_is_prefix_char(*end)) {\r\nend++;\r\n}\r\nswitch (*end) {\r\ncase 0:\r\nif (end == start) {\r\nstart = NULL;\r\n}\r\nend++;\r\nbreak;\r\ncase AML_DUAL_NAME_PREFIX:\r\nend += 1 + (2 * ACPI_NAME_SIZE);\r\nbreak;\r\ncase AML_MULTI_NAME_PREFIX_OP:\r\nend += 2 + (*(end + 1) * ACPI_NAME_SIZE);\r\nbreak;\r\ndefault:\r\nend += ACPI_NAME_SIZE;\r\nbreak;\r\n}\r\nparser_state->aml = end;\r\nreturn_PTR((char *)start);\r\n}\r\nacpi_status\r\nacpi_ps_get_next_namepath(struct acpi_walk_state *walk_state,\r\nstruct acpi_parse_state *parser_state,\r\nunion acpi_parse_object *arg, u8 possible_method_call)\r\n{\r\nacpi_status status;\r\nchar *path;\r\nunion acpi_parse_object *name_op;\r\nunion acpi_operand_object *method_desc;\r\nstruct acpi_namespace_node *node;\r\nu8 *start = parser_state->aml;\r\nACPI_FUNCTION_TRACE(ps_get_next_namepath);\r\npath = acpi_ps_get_next_namestring(parser_state);\r\nacpi_ps_init_op(arg, AML_INT_NAMEPATH_OP);\r\nif (!path) {\r\narg->common.value.name = path;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nstatus = acpi_ns_lookup(walk_state->scope_info, path,\r\nACPI_TYPE_ANY, ACPI_IMODE_EXECUTE,\r\nACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE,\r\nNULL, &node);\r\nif (ACPI_SUCCESS(status) &&\r\npossible_method_call && (node->type == ACPI_TYPE_METHOD)) {\r\nif (walk_state->opcode == AML_UNLOAD_OP) {\r\nwalk_state->parser_state.aml = start;\r\nwalk_state->arg_count = 1;\r\nacpi_ps_init_op(arg, AML_INT_METHODCALL_OP);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nmethod_desc = acpi_ns_get_attached_object(node);\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE,\r\n"Control Method - %p Desc %p Path=%p\n", node,\r\nmethod_desc, path));\r\nname_op = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP);\r\nif (!name_op) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nacpi_ps_init_op(arg, AML_INT_METHODCALL_OP);\r\nname_op->common.value.name = path;\r\nname_op->common.node = node;\r\nacpi_ps_append_arg(arg, name_op);\r\nif (!method_desc) {\r\nACPI_ERROR((AE_INFO,\r\n"Control Method %p has no attached object",\r\nnode));\r\nreturn_ACPI_STATUS(AE_AML_INTERNAL);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_PARSE,\r\n"Control Method - %p Args %X\n",\r\nnode, method_desc->method.param_count));\r\nwalk_state->arg_count = method_desc->method.param_count;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nif (status == AE_NOT_FOUND) {\r\nif ((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) !=\r\nACPI_PARSE_EXECUTE) {\r\nstatus = AE_OK;\r\n}\r\nelse if (walk_state->op->common.aml_opcode ==\r\nAML_COND_REF_OF_OP) {\r\nstatus = AE_OK;\r\n}\r\nelse if ((arg->common.parent) &&\r\n((arg->common.parent->common.aml_opcode ==\r\nAML_PACKAGE_OP)\r\n|| (arg->common.parent->common.aml_opcode ==\r\nAML_VAR_PACKAGE_OP))) {\r\nstatus = AE_OK;\r\n}\r\n}\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR_NAMESPACE(path, status);\r\nif ((walk_state->parse_flags & ACPI_PARSE_MODE_MASK) ==\r\nACPI_PARSE_EXECUTE) {\r\nstatus = acpi_ds_method_error(status, walk_state);\r\n}\r\n}\r\narg->common.value.name = path;\r\nreturn_ACPI_STATUS(status);\r\n}\r\nvoid\r\nacpi_ps_get_next_simple_arg(struct acpi_parse_state *parser_state,\r\nu32 arg_type, union acpi_parse_object *arg)\r\n{\r\nu32 length;\r\nu16 opcode;\r\nu8 *aml = parser_state->aml;\r\nACPI_FUNCTION_TRACE_U32(ps_get_next_simple_arg, arg_type);\r\nswitch (arg_type) {\r\ncase ARGP_BYTEDATA:\r\nopcode = AML_BYTE_OP;\r\narg->common.value.integer = (u64) *aml;\r\nlength = 1;\r\nbreak;\r\ncase ARGP_WORDDATA:\r\nopcode = AML_WORD_OP;\r\nACPI_MOVE_16_TO_64(&arg->common.value.integer, aml);\r\nlength = 2;\r\nbreak;\r\ncase ARGP_DWORDDATA:\r\nopcode = AML_DWORD_OP;\r\nACPI_MOVE_32_TO_64(&arg->common.value.integer, aml);\r\nlength = 4;\r\nbreak;\r\ncase ARGP_QWORDDATA:\r\nopcode = AML_QWORD_OP;\r\nACPI_MOVE_64_TO_64(&arg->common.value.integer, aml);\r\nlength = 8;\r\nbreak;\r\ncase ARGP_CHARLIST:\r\nopcode = AML_STRING_OP;\r\narg->common.value.string = ACPI_CAST_PTR(char, aml);\r\nlength = 0;\r\nwhile (aml[length]) {\r\nlength++;\r\n}\r\nlength++;\r\nbreak;\r\ncase ARGP_NAME:\r\ncase ARGP_NAMESTRING:\r\nacpi_ps_init_op(arg, AML_INT_NAMEPATH_OP);\r\narg->common.value.name =\r\nacpi_ps_get_next_namestring(parser_state);\r\nreturn_VOID;\r\ndefault:\r\nACPI_ERROR((AE_INFO, "Invalid ArgType 0x%X", arg_type));\r\nreturn_VOID;\r\n}\r\nacpi_ps_init_op(arg, opcode);\r\nparser_state->aml += length;\r\nreturn_VOID;\r\n}\r\nstatic union acpi_parse_object *acpi_ps_get_next_field(struct acpi_parse_state\r\n*parser_state)\r\n{\r\nu32 aml_offset;\r\nunion acpi_parse_object *field;\r\nunion acpi_parse_object *arg = NULL;\r\nu16 opcode;\r\nu32 name;\r\nu8 access_type;\r\nu8 access_attribute;\r\nu8 access_length;\r\nu32 pkg_length;\r\nu8 *pkg_end;\r\nu32 buffer_length;\r\nACPI_FUNCTION_TRACE(ps_get_next_field);\r\naml_offset =\r\n(u32)ACPI_PTR_DIFF(parser_state->aml, parser_state->aml_start);\r\nswitch (ACPI_GET8(parser_state->aml)) {\r\ncase AML_FIELD_OFFSET_OP:\r\nopcode = AML_INT_RESERVEDFIELD_OP;\r\nparser_state->aml++;\r\nbreak;\r\ncase AML_FIELD_ACCESS_OP:\r\nopcode = AML_INT_ACCESSFIELD_OP;\r\nparser_state->aml++;\r\nbreak;\r\ncase AML_FIELD_CONNECTION_OP:\r\nopcode = AML_INT_CONNECTION_OP;\r\nparser_state->aml++;\r\nbreak;\r\ncase AML_FIELD_EXT_ACCESS_OP:\r\nopcode = AML_INT_EXTACCESSFIELD_OP;\r\nparser_state->aml++;\r\nbreak;\r\ndefault:\r\nopcode = AML_INT_NAMEDFIELD_OP;\r\nbreak;\r\n}\r\nfield = acpi_ps_alloc_op(opcode);\r\nif (!field) {\r\nreturn_PTR(NULL);\r\n}\r\nfield->common.aml_offset = aml_offset;\r\nswitch (opcode) {\r\ncase AML_INT_NAMEDFIELD_OP:\r\nACPI_MOVE_32_TO_32(&name, parser_state->aml);\r\nacpi_ps_set_name(field, name);\r\nparser_state->aml += ACPI_NAME_SIZE;\r\nfield->common.value.size =\r\nacpi_ps_get_next_package_length(parser_state);\r\nbreak;\r\ncase AML_INT_RESERVEDFIELD_OP:\r\nfield->common.value.size =\r\nacpi_ps_get_next_package_length(parser_state);\r\nbreak;\r\ncase AML_INT_ACCESSFIELD_OP:\r\ncase AML_INT_EXTACCESSFIELD_OP:\r\naccess_type = ACPI_GET8(parser_state->aml);\r\nparser_state->aml++;\r\naccess_attribute = ACPI_GET8(parser_state->aml);\r\nparser_state->aml++;\r\nfield->common.value.integer = (u8)access_type;\r\nfield->common.value.integer |= (u16)(access_attribute << 8);\r\nif (opcode == AML_INT_EXTACCESSFIELD_OP) {\r\naccess_length = ACPI_GET8(parser_state->aml);\r\nparser_state->aml++;\r\nfield->common.value.integer |=\r\n(u32)(access_length << 16);\r\n}\r\nbreak;\r\ncase AML_INT_CONNECTION_OP:\r\nif (ACPI_GET8(parser_state->aml) == AML_BUFFER_OP) {\r\nparser_state->aml++;\r\npkg_end = parser_state->aml;\r\npkg_length =\r\nacpi_ps_get_next_package_length(parser_state);\r\npkg_end += pkg_length;\r\nif (parser_state->aml < pkg_end) {\r\narg = acpi_ps_alloc_op(AML_INT_BYTELIST_OP);\r\nif (!arg) {\r\nacpi_ps_free_op(field);\r\nreturn_PTR(NULL);\r\n}\r\nopcode = ACPI_GET8(parser_state->aml);\r\nparser_state->aml++;\r\nswitch (opcode) {\r\ncase AML_BYTE_OP:\r\nbuffer_length =\r\nACPI_GET8(parser_state->aml);\r\nparser_state->aml += 1;\r\nbreak;\r\ncase AML_WORD_OP:\r\nbuffer_length =\r\nACPI_GET16(parser_state->aml);\r\nparser_state->aml += 2;\r\nbreak;\r\ncase AML_DWORD_OP:\r\nbuffer_length =\r\nACPI_GET32(parser_state->aml);\r\nparser_state->aml += 4;\r\nbreak;\r\ndefault:\r\nbuffer_length = 0;\r\nbreak;\r\n}\r\narg->named.value.size = buffer_length;\r\narg->named.data = parser_state->aml;\r\n}\r\nparser_state->aml = pkg_end;\r\n} else {\r\narg = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP);\r\nif (!arg) {\r\nacpi_ps_free_op(field);\r\nreturn_PTR(NULL);\r\n}\r\narg->common.value.name =\r\nacpi_ps_get_next_namestring(parser_state);\r\n}\r\nacpi_ps_append_arg(field, arg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn_PTR(field);\r\n}\r\nacpi_status\r\nacpi_ps_get_next_arg(struct acpi_walk_state *walk_state,\r\nstruct acpi_parse_state *parser_state,\r\nu32 arg_type, union acpi_parse_object **return_arg)\r\n{\r\nunion acpi_parse_object *arg = NULL;\r\nunion acpi_parse_object *prev = NULL;\r\nunion acpi_parse_object *field;\r\nu32 subop;\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE_PTR(ps_get_next_arg, parser_state);\r\nswitch (arg_type) {\r\ncase ARGP_BYTEDATA:\r\ncase ARGP_WORDDATA:\r\ncase ARGP_DWORDDATA:\r\ncase ARGP_CHARLIST:\r\ncase ARGP_NAME:\r\ncase ARGP_NAMESTRING:\r\narg = acpi_ps_alloc_op(AML_BYTE_OP);\r\nif (!arg) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nacpi_ps_get_next_simple_arg(parser_state, arg_type, arg);\r\nbreak;\r\ncase ARGP_PKGLENGTH:\r\nparser_state->pkg_end =\r\nacpi_ps_get_next_package_end(parser_state);\r\nbreak;\r\ncase ARGP_FIELDLIST:\r\nif (parser_state->aml < parser_state->pkg_end) {\r\nwhile (parser_state->aml < parser_state->pkg_end) {\r\nfield = acpi_ps_get_next_field(parser_state);\r\nif (!field) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nif (prev) {\r\nprev->common.next = field;\r\n} else {\r\narg = field;\r\n}\r\nprev = field;\r\n}\r\nparser_state->aml = parser_state->pkg_end;\r\n}\r\nbreak;\r\ncase ARGP_BYTELIST:\r\nif (parser_state->aml < parser_state->pkg_end) {\r\narg = acpi_ps_alloc_op(AML_INT_BYTELIST_OP);\r\nif (!arg) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\narg->common.value.size = (u32)\r\nACPI_PTR_DIFF(parser_state->pkg_end,\r\nparser_state->aml);\r\narg->named.data = parser_state->aml;\r\nparser_state->aml = parser_state->pkg_end;\r\n}\r\nbreak;\r\ncase ARGP_TARGET:\r\ncase ARGP_SUPERNAME:\r\ncase ARGP_SIMPLENAME:\r\nsubop = acpi_ps_peek_opcode(parser_state);\r\nif (subop == 0 ||\r\nacpi_ps_is_leading_char(subop) ||\r\nacpi_ps_is_prefix_char(subop)) {\r\narg = acpi_ps_alloc_op(AML_INT_NAMEPATH_OP);\r\nif (!arg) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nif (walk_state->opcode == AML_UNLOAD_OP) {\r\nstatus =\r\nacpi_ps_get_next_namepath(walk_state,\r\nparser_state, arg,\r\n1);\r\nif (arg->common.aml_opcode ==\r\nAML_INT_METHODCALL_OP) {\r\nacpi_ps_free_op(arg);\r\narg = NULL;\r\n}\r\n} else {\r\nstatus =\r\nacpi_ps_get_next_namepath(walk_state,\r\nparser_state, arg,\r\n0);\r\n}\r\n} else {\r\nwalk_state->arg_count = 1;\r\n}\r\nbreak;\r\ncase ARGP_DATAOBJ:\r\ncase ARGP_TERMARG:\r\nwalk_state->arg_count = 1;\r\nbreak;\r\ncase ARGP_DATAOBJLIST:\r\ncase ARGP_TERMLIST:\r\ncase ARGP_OBJLIST:\r\nif (parser_state->aml < parser_state->pkg_end) {\r\nwalk_state->arg_count = ACPI_VAR_ARGS;\r\n}\r\nbreak;\r\ndefault:\r\nACPI_ERROR((AE_INFO, "Invalid ArgType: 0x%X", arg_type));\r\nstatus = AE_AML_OPERAND_TYPE;\r\nbreak;\r\n}\r\n*return_arg = arg;\r\nreturn_ACPI_STATUS(status);\r\n}
