static void free_imon_context(struct imon_context *context)\r\n{\r\nstruct device *dev = context->driver->dev;\r\nusb_free_urb(context->tx_urb);\r\nusb_free_urb(context->rx_urb);\r\nlirc_buffer_free(context->driver->rbuf);\r\nkfree(context->driver->rbuf);\r\nkfree(context->driver);\r\nkfree(context);\r\ndev_dbg(dev, "%s: iMON context freed\n", __func__);\r\n}\r\nstatic void deregister_from_lirc(struct imon_context *context)\r\n{\r\nint retval;\r\nint minor = context->driver->minor;\r\nretval = lirc_unregister_driver(minor);\r\nif (retval)\r\nprintk(KERN_ERR KBUILD_MODNAME\r\n": %s: unable to deregister from lirc(%d)",\r\n__func__, retval);\r\nelse\r\nprintk(KERN_INFO MOD_NAME ": Deregistered iMON driver "\r\n"(minor:%d)\n", minor);\r\n}\r\nstatic int display_open(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_interface *interface;\r\nstruct imon_context *context = NULL;\r\nint subminor;\r\nint retval = 0;\r\nmutex_lock(&driver_lock);\r\nsubminor = iminor(inode);\r\ninterface = usb_find_interface(&imon_driver, subminor);\r\nif (!interface) {\r\nprintk(KERN_ERR KBUILD_MODNAME\r\n": %s: could not find interface for minor %d\n",\r\n__func__, subminor);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\ncontext = usb_get_intfdata(interface);\r\nif (!context) {\r\ndev_err(&interface->dev,\r\n"%s: no context found for minor %d\n",\r\n__func__, subminor);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nmutex_lock(&context->ctx_lock);\r\nif (!context->display) {\r\ndev_err(&interface->dev,\r\n"%s: display not supported by device\n", __func__);\r\nretval = -ENODEV;\r\n} else if (context->display_isopen) {\r\ndev_err(&interface->dev,\r\n"%s: display port is already open\n", __func__);\r\nretval = -EBUSY;\r\n} else {\r\ncontext->display_isopen = 1;\r\nfile->private_data = context;\r\ndev_info(context->driver->dev, "display port opened\n");\r\n}\r\nmutex_unlock(&context->ctx_lock);\r\nexit:\r\nmutex_unlock(&driver_lock);\r\nreturn retval;\r\n}\r\nstatic int display_close(struct inode *inode, struct file *file)\r\n{\r\nstruct imon_context *context = NULL;\r\nint retval = 0;\r\ncontext = file->private_data;\r\nif (!context) {\r\nprintk(KERN_ERR KBUILD_MODNAME\r\n"%s: no context for device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&context->ctx_lock);\r\nif (!context->display) {\r\ndev_err(&context->usbdev->dev,\r\n"%s: display not supported by device\n", __func__);\r\nretval = -ENODEV;\r\n} else if (!context->display_isopen) {\r\ndev_err(&context->usbdev->dev,\r\n"%s: display is not open\n", __func__);\r\nretval = -EIO;\r\n} else {\r\ncontext->display_isopen = 0;\r\ndev_info(context->driver->dev, "display port closed\n");\r\nif (!context->dev_present && !context->ir_isopen) {\r\nmutex_unlock(&context->ctx_lock);\r\nfree_imon_context(context);\r\nreturn retval;\r\n}\r\n}\r\nmutex_unlock(&context->ctx_lock);\r\nreturn retval;\r\n}\r\nstatic int send_packet(struct imon_context *context)\r\n{\r\nunsigned int pipe;\r\nint interval = 0;\r\nint retval = 0;\r\npipe = usb_sndintpipe(context->usbdev,\r\ncontext->tx_endpoint->bEndpointAddress);\r\ninterval = context->tx_endpoint->bInterval;\r\nusb_fill_int_urb(context->tx_urb, context->usbdev, pipe,\r\ncontext->usb_tx_buf,\r\nsizeof(context->usb_tx_buf),\r\nusb_tx_callback, context, interval);\r\ncontext->tx_urb->actual_length = 0;\r\ninit_completion(&context->tx.finished);\r\natomic_set(&(context->tx.busy), 1);\r\nretval = usb_submit_urb(context->tx_urb, GFP_KERNEL);\r\nif (retval) {\r\natomic_set(&(context->tx.busy), 0);\r\ndev_err(&context->usbdev->dev,\r\n"%s: error submitting urb(%d)\n", __func__, retval);\r\n} else {\r\nmutex_unlock(&context->ctx_lock);\r\nretval = wait_for_completion_interruptible(\r\n&context->tx.finished);\r\nif (retval)\r\ndev_err(&context->usbdev->dev,\r\n"%s: task interrupted\n", __func__);\r\nmutex_lock(&context->ctx_lock);\r\nretval = context->tx.status;\r\nif (retval)\r\ndev_err(&context->usbdev->dev,\r\n"%s: packet tx failed (%d)\n",\r\n__func__, retval);\r\n}\r\nreturn retval;\r\n}\r\nstatic ssize_t vfd_write(struct file *file, const char __user *buf,\r\nsize_t n_bytes, loff_t *pos)\r\n{\r\nint i;\r\nint offset;\r\nint seq;\r\nint retval = 0;\r\nstruct imon_context *context;\r\nconst unsigned char vfd_packet6[] = {\r\n0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF };\r\nint *data_buf = NULL;\r\ncontext = file->private_data;\r\nif (!context) {\r\nprintk(KERN_ERR KBUILD_MODNAME\r\n"%s: no context for device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&context->ctx_lock);\r\nif (!context->dev_present) {\r\ndev_err(&context->usbdev->dev,\r\n"%s: no iMON device present\n", __func__);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (n_bytes <= 0 || n_bytes > IMON_DATA_BUF_SZ - 3) {\r\ndev_err(&context->usbdev->dev,\r\n"%s: invalid payload size\n", __func__);\r\nretval = -EINVAL;\r\ngoto exit;\r\n}\r\ndata_buf = memdup_user(buf, n_bytes);\r\nif (IS_ERR(data_buf)) {\r\nretval = PTR_ERR(data_buf);\r\ngoto exit;\r\n}\r\nmemcpy(context->tx.data_buf, data_buf, n_bytes);\r\nfor (i = n_bytes; i < IMON_DATA_BUF_SZ - 3; ++i)\r\ncontext->tx.data_buf[i] = ' ';\r\nfor (i = IMON_DATA_BUF_SZ - 3; i < IMON_DATA_BUF_SZ; ++i)\r\ncontext->tx.data_buf[i] = 0xFF;\r\noffset = 0;\r\nseq = 0;\r\ndo {\r\nmemcpy(context->usb_tx_buf, context->tx.data_buf + offset, 7);\r\ncontext->usb_tx_buf[7] = (unsigned char) seq;\r\nretval = send_packet(context);\r\nif (retval) {\r\ndev_err(&context->usbdev->dev,\r\n"%s: send packet failed for packet #%d\n",\r\n__func__, seq/2);\r\ngoto exit;\r\n} else {\r\nseq += 2;\r\noffset += 7;\r\n}\r\n} while (offset < IMON_DATA_BUF_SZ);\r\nif (context->vfd_proto_6p) {\r\nmemcpy(context->usb_tx_buf, &vfd_packet6, sizeof(vfd_packet6));\r\ncontext->usb_tx_buf[7] = (unsigned char) seq;\r\nretval = send_packet(context);\r\nif (retval)\r\ndev_err(&context->usbdev->dev,\r\n"%s: send packet failed for packet #%d\n",\r\n__func__, seq/2);\r\n}\r\nexit:\r\nmutex_unlock(&context->ctx_lock);\r\nkfree(data_buf);\r\nreturn (!retval) ? n_bytes : retval;\r\n}\r\nstatic void usb_tx_callback(struct urb *urb)\r\n{\r\nstruct imon_context *context;\r\nif (!urb)\r\nreturn;\r\ncontext = (struct imon_context *)urb->context;\r\nif (!context)\r\nreturn;\r\ncontext->tx.status = urb->status;\r\natomic_set(&context->tx.busy, 0);\r\ncomplete(&context->tx.finished);\r\nreturn;\r\n}\r\nstatic int ir_open(void *data)\r\n{\r\nint retval = 0;\r\nstruct imon_context *context;\r\nmutex_lock(&driver_lock);\r\ncontext = (struct imon_context *)data;\r\ncontext->rx.count = 0;\r\ncontext->rx.initial_space = 1;\r\ncontext->rx.prev_bit = 0;\r\ncontext->ir_isopen = 1;\r\ndev_info(context->driver->dev, "IR port opened\n");\r\nmutex_unlock(&driver_lock);\r\nreturn retval;\r\n}\r\nstatic void ir_close(void *data)\r\n{\r\nstruct imon_context *context;\r\ncontext = (struct imon_context *)data;\r\nif (!context) {\r\nprintk(KERN_ERR KBUILD_MODNAME\r\n"%s: no context for device\n", __func__);\r\nreturn;\r\n}\r\nmutex_lock(&context->ctx_lock);\r\ncontext->ir_isopen = 0;\r\ndev_info(context->driver->dev, "IR port closed\n");\r\nif (!context->dev_present) {\r\nderegister_from_lirc(context);\r\nif (!context->display_isopen) {\r\nmutex_unlock(&context->ctx_lock);\r\nfree_imon_context(context);\r\nreturn;\r\n}\r\n}\r\nmutex_unlock(&context->ctx_lock);\r\nreturn;\r\n}\r\nstatic void submit_data(struct imon_context *context)\r\n{\r\nunsigned char buf[4];\r\nint value = context->rx.count;\r\nint i;\r\ndev_dbg(context->driver->dev, "submitting data to LIRC\n");\r\nvalue *= BIT_DURATION;\r\nvalue &= PULSE_MASK;\r\nif (context->rx.prev_bit)\r\nvalue |= PULSE_BIT;\r\nfor (i = 0; i < 4; ++i)\r\nbuf[i] = value>>(i*8);\r\nlirc_buffer_write(context->driver->rbuf, buf);\r\nwake_up(&context->driver->rbuf->wait_poll);\r\nreturn;\r\n}\r\nstatic inline int tv2int(const struct timeval *a, const struct timeval *b)\r\n{\r\nint usecs = 0;\r\nint sec = 0;\r\nif (b->tv_usec > a->tv_usec) {\r\nusecs = 1000000;\r\nsec--;\r\n}\r\nusecs += a->tv_usec - b->tv_usec;\r\nsec += a->tv_sec - b->tv_sec;\r\nsec *= 1000;\r\nusecs /= 1000;\r\nsec += usecs;\r\nif (sec < 0)\r\nsec = 1000;\r\nreturn sec;\r\n}\r\nstatic void imon_incoming_packet(struct imon_context *context,\r\nstruct urb *urb, int intf)\r\n{\r\nint len = urb->actual_length;\r\nunsigned char *buf = urb->transfer_buffer;\r\nstruct device *dev = context->driver->dev;\r\nint octet, bit;\r\nunsigned char mask;\r\nint i;\r\nif (!context->ir_isopen)\r\nreturn;\r\nif (len != 8) {\r\ndev_warn(dev, "imon %s: invalid incoming packet "\r\n"size (len = %d, intf%d)\n", __func__, len, intf);\r\nreturn;\r\n}\r\nif (debug) {\r\nprintk(KERN_INFO "raw packet: ");\r\nfor (i = 0; i < len; ++i)\r\nprintk("%02x ", buf[i]);\r\nprintk("\n");\r\n}\r\nif (buf[7] == 1 && context->rx.initial_space) {\r\ncontext->rx.prev_bit = 0;\r\ncontext->rx.count = 4;\r\nsubmit_data(context);\r\ncontext->rx.count = 0;\r\n}\r\nfor (octet = 0; octet < 5; ++octet) {\r\nmask = 0x80;\r\nfor (bit = 0; bit < 8; ++bit) {\r\nint curr_bit = !(buf[octet] & mask);\r\nif (curr_bit != context->rx.prev_bit) {\r\nif (context->rx.count) {\r\nsubmit_data(context);\r\ncontext->rx.count = 0;\r\n}\r\ncontext->rx.prev_bit = curr_bit;\r\n}\r\n++context->rx.count;\r\nmask >>= 1;\r\n}\r\n}\r\nif (buf[7] == 10) {\r\nif (context->rx.count) {\r\nsubmit_data(context);\r\ncontext->rx.count = 0;\r\n}\r\ncontext->rx.initial_space = context->rx.prev_bit;\r\n}\r\n}\r\nstatic void usb_rx_callback(struct urb *urb)\r\n{\r\nstruct imon_context *context;\r\nint intfnum = 0;\r\nif (!urb)\r\nreturn;\r\ncontext = (struct imon_context *)urb->context;\r\nif (!context)\r\nreturn;\r\nswitch (urb->status) {\r\ncase -ENOENT:\r\nreturn;\r\ncase 0:\r\nimon_incoming_packet(context, urb, intfnum);\r\nbreak;\r\ndefault:\r\ndev_warn(context->driver->dev, "imon %s: status(%d): ignored\n",\r\n__func__, urb->status);\r\nbreak;\r\n}\r\nusb_submit_urb(context->rx_urb, GFP_ATOMIC);\r\nreturn;\r\n}\r\nstatic int imon_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *usbdev = NULL;\r\nstruct usb_host_interface *iface_desc = NULL;\r\nstruct usb_endpoint_descriptor *rx_endpoint = NULL;\r\nstruct usb_endpoint_descriptor *tx_endpoint = NULL;\r\nstruct urb *rx_urb = NULL;\r\nstruct urb *tx_urb = NULL;\r\nstruct lirc_driver *driver = NULL;\r\nstruct lirc_buffer *rbuf = NULL;\r\nstruct device *dev = &interface->dev;\r\nint ifnum;\r\nint lirc_minor = 0;\r\nint num_endpts;\r\nint retval = 0;\r\nint display_ep_found = 0;\r\nint ir_ep_found = 0;\r\nint alloc_status = 0;\r\nint vfd_proto_6p = 0;\r\nstruct imon_context *context = NULL;\r\nint i;\r\nu16 vendor, product;\r\nmutex_lock(&driver_lock);\r\ncontext = kzalloc(sizeof(struct imon_context), GFP_KERNEL);\r\nif (!context) {\r\ndev_err(dev, "%s: kzalloc failed for context\n", __func__);\r\nalloc_status = 1;\r\ngoto alloc_status_switch;\r\n}\r\nif (usb_match_id(interface, ir_only_list))\r\ncontext->display = 0;\r\nelse\r\ncontext->display = 1;\r\nusbdev = usb_get_dev(interface_to_usbdev(interface));\r\niface_desc = interface->cur_altsetting;\r\nnum_endpts = iface_desc->desc.bNumEndpoints;\r\nifnum = iface_desc->desc.bInterfaceNumber;\r\nvendor = le16_to_cpu(usbdev->descriptor.idVendor);\r\nproduct = le16_to_cpu(usbdev->descriptor.idProduct);\r\ndev_dbg(dev, "%s: found iMON device (%04x:%04x, intf%d)\n",\r\n__func__, vendor, product, ifnum);\r\nfor (i = 0; i < num_endpts && !(ir_ep_found && display_ep_found); ++i) {\r\nstruct usb_endpoint_descriptor *ep;\r\nint ep_dir;\r\nint ep_type;\r\nep = &iface_desc->endpoint[i].desc;\r\nep_dir = ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK;\r\nep_type = ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\r\nif (!ir_ep_found &&\r\nep_dir == USB_DIR_IN &&\r\nep_type == USB_ENDPOINT_XFER_INT) {\r\nrx_endpoint = ep;\r\nir_ep_found = 1;\r\ndev_dbg(dev, "%s: found IR endpoint\n", __func__);\r\n} else if (!display_ep_found && ep_dir == USB_DIR_OUT &&\r\nep_type == USB_ENDPOINT_XFER_INT) {\r\ntx_endpoint = ep;\r\ndisplay_ep_found = 1;\r\ndev_dbg(dev, "%s: found display endpoint\n", __func__);\r\n}\r\n}\r\nif (context->display == 0) {\r\ndisplay_ep_found = 0;\r\ndev_dbg(dev, "%s: device has no display\n", __func__);\r\n}\r\nif (!ir_ep_found) {\r\ndev_err(dev, "%s: no valid input (IR) endpoint found.\n", __func__);\r\nretval = -ENODEV;\r\nalloc_status = 2;\r\ngoto alloc_status_switch;\r\n}\r\nif (display_ep_found) {\r\nif (usb_match_id(interface, vfd_proto_6p_list))\r\nvfd_proto_6p = 1;\r\ndev_dbg(dev, "%s: vfd_proto_6p: %d\n",\r\n__func__, vfd_proto_6p);\r\n}\r\ndriver = kzalloc(sizeof(struct lirc_driver), GFP_KERNEL);\r\nif (!driver) {\r\ndev_err(dev, "%s: kzalloc failed for lirc_driver\n", __func__);\r\nalloc_status = 2;\r\ngoto alloc_status_switch;\r\n}\r\nrbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL);\r\nif (!rbuf) {\r\ndev_err(dev, "%s: kmalloc failed for lirc_buffer\n", __func__);\r\nalloc_status = 3;\r\ngoto alloc_status_switch;\r\n}\r\nif (lirc_buffer_init(rbuf, BUF_CHUNK_SIZE, BUF_SIZE)) {\r\ndev_err(dev, "%s: lirc_buffer_init failed\n", __func__);\r\nalloc_status = 4;\r\ngoto alloc_status_switch;\r\n}\r\nrx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!rx_urb) {\r\ndev_err(dev, "%s: usb_alloc_urb failed for IR urb\n", __func__);\r\nalloc_status = 5;\r\ngoto alloc_status_switch;\r\n}\r\ntx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!tx_urb) {\r\ndev_err(dev, "%s: usb_alloc_urb failed for display urb\n",\r\n__func__);\r\nalloc_status = 6;\r\ngoto alloc_status_switch;\r\n}\r\nmutex_init(&context->ctx_lock);\r\ncontext->vfd_proto_6p = vfd_proto_6p;\r\nstrcpy(driver->name, MOD_NAME);\r\ndriver->minor = -1;\r\ndriver->code_length = BUF_CHUNK_SIZE * 8;\r\ndriver->sample_rate = 0;\r\ndriver->features = LIRC_CAN_REC_MODE2;\r\ndriver->data = context;\r\ndriver->rbuf = rbuf;\r\ndriver->set_use_inc = ir_open;\r\ndriver->set_use_dec = ir_close;\r\ndriver->dev = &interface->dev;\r\ndriver->owner = THIS_MODULE;\r\nmutex_lock(&context->ctx_lock);\r\ncontext->driver = driver;\r\nlirc_minor = lirc_register_driver(driver);\r\nif (lirc_minor < 0) {\r\ndev_err(dev, "%s: lirc_register_driver failed\n", __func__);\r\nalloc_status = 7;\r\ngoto unlock;\r\n} else\r\ndev_info(dev, "Registered iMON driver "\r\n"(lirc minor: %d)\n", lirc_minor);\r\ndriver->minor = lirc_minor;\r\ncontext->usbdev = usbdev;\r\ncontext->dev_present = 1;\r\ncontext->rx_endpoint = rx_endpoint;\r\ncontext->rx_urb = rx_urb;\r\ncontext->tx_endpoint = tx_endpoint;\r\ncontext->tx_urb = tx_urb;\r\nif (display_ep_found)\r\ncontext->display = 1;\r\nusb_fill_int_urb(context->rx_urb, context->usbdev,\r\nusb_rcvintpipe(context->usbdev,\r\ncontext->rx_endpoint->bEndpointAddress),\r\ncontext->usb_rx_buf, sizeof(context->usb_rx_buf),\r\nusb_rx_callback, context,\r\ncontext->rx_endpoint->bInterval);\r\nretval = usb_submit_urb(context->rx_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(dev, "%s: usb_submit_urb failed for intf0 (%d)\n",\r\n__func__, retval);\r\nmutex_unlock(&context->ctx_lock);\r\ngoto exit;\r\n}\r\nusb_set_intfdata(interface, context);\r\nif (context->display && ifnum == 0) {\r\ndev_dbg(dev, "%s: Registering iMON display with sysfs\n",\r\n__func__);\r\nif (usb_register_dev(interface, &imon_class)) {\r\ndev_info(dev, "%s: could not get a minor number for "\r\n"display\n", __func__);\r\n}\r\n}\r\ndev_info(dev, "iMON device (%04x:%04x, intf%d) on "\r\n"usb<%d:%d> initialized\n", vendor, product, ifnum,\r\nusbdev->bus->busnum, usbdev->devnum);\r\nunlock:\r\nmutex_unlock(&context->ctx_lock);\r\nalloc_status_switch:\r\nswitch (alloc_status) {\r\ncase 7:\r\nusb_free_urb(tx_urb);\r\ncase 6:\r\nusb_free_urb(rx_urb);\r\ncase 5:\r\nif (rbuf)\r\nlirc_buffer_free(rbuf);\r\ncase 4:\r\nkfree(rbuf);\r\ncase 3:\r\nkfree(driver);\r\ncase 2:\r\nkfree(context);\r\ncontext = NULL;\r\ncase 1:\r\nif (retval != -ENODEV)\r\nretval = -ENOMEM;\r\nbreak;\r\ncase 0:\r\nretval = 0;\r\n}\r\nexit:\r\nmutex_unlock(&driver_lock);\r\nreturn retval;\r\n}\r\nstatic void imon_disconnect(struct usb_interface *interface)\r\n{\r\nstruct imon_context *context;\r\nint ifnum;\r\nmutex_lock(&driver_lock);\r\ncontext = usb_get_intfdata(interface);\r\nifnum = interface->cur_altsetting->desc.bInterfaceNumber;\r\nmutex_lock(&context->ctx_lock);\r\nusb_set_intfdata(interface, NULL);\r\nif (atomic_read(&context->tx.busy)) {\r\nusb_kill_urb(context->tx_urb);\r\ncomplete_all(&context->tx.finished);\r\n}\r\ncontext->dev_present = 0;\r\nusb_kill_urb(context->rx_urb);\r\nif (context->display)\r\nusb_deregister_dev(interface, &imon_class);\r\nif (!context->ir_isopen && !context->dev_present) {\r\nderegister_from_lirc(context);\r\nmutex_unlock(&context->ctx_lock);\r\nif (!context->display_isopen)\r\nfree_imon_context(context);\r\n} else\r\nmutex_unlock(&context->ctx_lock);\r\nmutex_unlock(&driver_lock);\r\nprintk(KERN_INFO "%s: iMON device (intf%d) disconnected\n",\r\n__func__, ifnum);\r\n}\r\nstatic int imon_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct imon_context *context = usb_get_intfdata(intf);\r\nusb_kill_urb(context->rx_urb);\r\nreturn 0;\r\n}\r\nstatic int imon_resume(struct usb_interface *intf)\r\n{\r\nint rc = 0;\r\nstruct imon_context *context = usb_get_intfdata(intf);\r\nusb_fill_int_urb(context->rx_urb, context->usbdev,\r\nusb_rcvintpipe(context->usbdev,\r\ncontext->rx_endpoint->bEndpointAddress),\r\ncontext->usb_rx_buf, sizeof(context->usb_rx_buf),\r\nusb_rx_callback, context,\r\ncontext->rx_endpoint->bInterval);\r\nrc = usb_submit_urb(context->rx_urb, GFP_ATOMIC);\r\nreturn rc;\r\n}
