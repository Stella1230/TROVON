static void rtlx_dispatch(void)\r\n{\r\ndo_IRQ(MIPS_CPU_IRQ_BASE + MIPS_CPU_RTLX_IRQ);\r\n}\r\nstatic irqreturn_t rtlx_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned int vpeflags;\r\nunsigned long flags;\r\nint i;\r\nlocal_irq_save(flags);\r\nvpeflags = dvpe();\r\nset_c0_status(0x100 << MIPS_CPU_RTLX_IRQ);\r\nirq_enable_hazard();\r\nevpe(vpeflags);\r\nlocal_irq_restore(flags);\r\nfor (i = 0; i < RTLX_CHANNELS; i++) {\r\nwake_up(&channel_wqs[i].lx_queue);\r\nwake_up(&channel_wqs[i].rt_queue);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __used dump_rtlx(void)\r\n{\r\nint i;\r\nprintk("id 0x%lx state %d\n", rtlx->id, rtlx->state);\r\nfor (i = 0; i < RTLX_CHANNELS; i++) {\r\nstruct rtlx_channel *chan = &rtlx->channel[i];\r\nprintk(" rt_state %d lx_state %d buffer_size %d\n",\r\nchan->rt_state, chan->lx_state, chan->buffer_size);\r\nprintk(" rt_read %d rt_write %d\n",\r\nchan->rt_read, chan->rt_write);\r\nprintk(" lx_read %d lx_write %d\n",\r\nchan->lx_read, chan->lx_write);\r\nprintk(" rt_buffer <%s>\n", chan->rt_buffer);\r\nprintk(" lx_buffer <%s>\n", chan->lx_buffer);\r\n}\r\n}\r\nstatic int rtlx_init(struct rtlx_info *rtlxi)\r\n{\r\nif (rtlxi->id != RTLX_ID) {\r\nprintk(KERN_ERR "no valid RTLX id at 0x%p 0x%lx\n",\r\nrtlxi, rtlxi->id);\r\nreturn -ENOEXEC;\r\n}\r\nrtlx = rtlxi;\r\nreturn 0;\r\n}\r\nstatic void starting(int vpe)\r\n{\r\nint i;\r\nsp_stopping = 0;\r\nrtlx=NULL;\r\nfor (i = 0; i < RTLX_CHANNELS; i++)\r\nwake_up_interruptible(&channel_wqs[i].lx_queue);\r\n}\r\nstatic void stopping(int vpe)\r\n{\r\nint i;\r\nsp_stopping = 1;\r\nfor (i = 0; i < RTLX_CHANNELS; i++)\r\nwake_up_interruptible(&channel_wqs[i].lx_queue);\r\n}\r\nint rtlx_open(int index, int can_sleep)\r\n{\r\nstruct rtlx_info **p;\r\nstruct rtlx_channel *chan;\r\nenum rtlx_state state;\r\nint ret = 0;\r\nif (index >= RTLX_CHANNELS) {\r\nprintk(KERN_DEBUG "rtlx_open index out of range\n");\r\nreturn -ENOSYS;\r\n}\r\nif (atomic_inc_return(&channel_wqs[index].in_open) > 1) {\r\nprintk(KERN_DEBUG "rtlx_open channel %d already opened\n",\r\nindex);\r\nret = -EBUSY;\r\ngoto out_fail;\r\n}\r\nif (rtlx == NULL) {\r\nif( (p = vpe_get_shared(tclimit)) == NULL) {\r\nif (can_sleep) {\r\n__wait_event_interruptible(channel_wqs[index].lx_queue,\r\n(p = vpe_get_shared(tclimit)), ret);\r\nif (ret)\r\ngoto out_fail;\r\n} else {\r\nprintk(KERN_DEBUG "No SP program loaded, and device "\r\n"opened with O_NONBLOCK\n");\r\nret = -ENOSYS;\r\ngoto out_fail;\r\n}\r\n}\r\nsmp_rmb();\r\nif (*p == NULL) {\r\nif (can_sleep) {\r\nDEFINE_WAIT(wait);\r\nfor (;;) {\r\nprepare_to_wait(\r\n&channel_wqs[index].lx_queue,\r\n&wait, TASK_INTERRUPTIBLE);\r\nsmp_rmb();\r\nif (*p != NULL)\r\nbreak;\r\nif (!signal_pending(current)) {\r\nschedule();\r\ncontinue;\r\n}\r\nret = -ERESTARTSYS;\r\ngoto out_fail;\r\n}\r\nfinish_wait(&channel_wqs[index].lx_queue, &wait);\r\n} else {\r\npr_err(" *vpe_get_shared is NULL. "\r\n"Has an SP program been loaded?\n");\r\nret = -ENOSYS;\r\ngoto out_fail;\r\n}\r\n}\r\nif ((unsigned int)*p < KSEG0) {\r\nprintk(KERN_WARNING "vpe_get_shared returned an "\r\n"invalid pointer maybe an error code %d\n",\r\n(int)*p);\r\nret = -ENOSYS;\r\ngoto out_fail;\r\n}\r\nif ((ret = rtlx_init(*p)) < 0)\r\ngoto out_ret;\r\n}\r\nchan = &rtlx->channel[index];\r\nstate = xchg(&chan->lx_state, RTLX_STATE_OPENED);\r\nif (state == RTLX_STATE_OPENED) {\r\nret = -EBUSY;\r\ngoto out_fail;\r\n}\r\nout_fail:\r\nsmp_mb();\r\natomic_dec(&channel_wqs[index].in_open);\r\nsmp_mb();\r\nout_ret:\r\nreturn ret;\r\n}\r\nint rtlx_release(int index)\r\n{\r\nif (rtlx == NULL) {\r\npr_err("rtlx_release() with null rtlx\n");\r\nreturn 0;\r\n}\r\nrtlx->channel[index].lx_state = RTLX_STATE_UNUSED;\r\nreturn 0;\r\n}\r\nunsigned int rtlx_read_poll(int index, int can_sleep)\r\n{\r\nstruct rtlx_channel *chan;\r\nif (rtlx == NULL)\r\nreturn 0;\r\nchan = &rtlx->channel[index];\r\nif (chan->lx_read == chan->lx_write) {\r\nif (can_sleep) {\r\nint ret = 0;\r\n__wait_event_interruptible(channel_wqs[index].lx_queue,\r\n(chan->lx_read != chan->lx_write) ||\r\nsp_stopping, ret);\r\nif (ret)\r\nreturn ret;\r\nif (sp_stopping)\r\nreturn 0;\r\n} else\r\nreturn 0;\r\n}\r\nreturn (chan->lx_write + chan->buffer_size - chan->lx_read)\r\n% chan->buffer_size;\r\n}\r\nstatic inline int write_spacefree(int read, int write, int size)\r\n{\r\nif (read == write) {\r\nreturn size - 1;\r\n}\r\nreturn ((read + size - write) % size) - 1;\r\n}\r\nunsigned int rtlx_write_poll(int index)\r\n{\r\nstruct rtlx_channel *chan = &rtlx->channel[index];\r\nreturn write_spacefree(chan->rt_read, chan->rt_write,\r\nchan->buffer_size);\r\n}\r\nssize_t rtlx_read(int index, void __user *buff, size_t count)\r\n{\r\nsize_t lx_write, fl = 0L;\r\nstruct rtlx_channel *lx;\r\nunsigned long failed;\r\nif (rtlx == NULL)\r\nreturn -ENOSYS;\r\nlx = &rtlx->channel[index];\r\nmutex_lock(&channel_wqs[index].mutex);\r\nsmp_rmb();\r\nlx_write = lx->lx_write;\r\ncount = min(count,\r\n(size_t)(lx_write + lx->buffer_size - lx->lx_read)\r\n% lx->buffer_size);\r\nfl = min(count, (size_t)lx->buffer_size - lx->lx_read);\r\nfailed = copy_to_user(buff, lx->lx_buffer + lx->lx_read, fl);\r\nif (failed)\r\ngoto out;\r\nif (count - fl)\r\nfailed = copy_to_user(buff + fl, lx->lx_buffer, count - fl);\r\nout:\r\ncount -= failed;\r\nsmp_wmb();\r\nlx->lx_read = (lx->lx_read + count) % lx->buffer_size;\r\nsmp_wmb();\r\nmutex_unlock(&channel_wqs[index].mutex);\r\nreturn count;\r\n}\r\nssize_t rtlx_write(int index, const void __user *buffer, size_t count)\r\n{\r\nstruct rtlx_channel *rt;\r\nunsigned long failed;\r\nsize_t rt_read;\r\nsize_t fl;\r\nif (rtlx == NULL)\r\nreturn(-ENOSYS);\r\nrt = &rtlx->channel[index];\r\nmutex_lock(&channel_wqs[index].mutex);\r\nsmp_rmb();\r\nrt_read = rt->rt_read;\r\ncount = min(count, (size_t)write_spacefree(rt_read, rt->rt_write,\r\nrt->buffer_size));\r\nfl = min(count, (size_t) rt->buffer_size - rt->rt_write);\r\nfailed = copy_from_user(rt->rt_buffer + rt->rt_write, buffer, fl);\r\nif (failed)\r\ngoto out;\r\nif (count - fl) {\r\nfailed = copy_from_user(rt->rt_buffer, buffer + fl, count - fl);\r\n}\r\nout:\r\ncount -= failed;\r\nsmp_wmb();\r\nrt->rt_write = (rt->rt_write + count) % rt->buffer_size;\r\nsmp_wmb();\r\nmutex_unlock(&channel_wqs[index].mutex);\r\nreturn count;\r\n}\r\nstatic int file_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn rtlx_open(iminor(inode), (filp->f_flags & O_NONBLOCK) ? 0 : 1);\r\n}\r\nstatic int file_release(struct inode *inode, struct file *filp)\r\n{\r\nreturn rtlx_release(iminor(inode));\r\n}\r\nstatic unsigned int file_poll(struct file *file, poll_table * wait)\r\n{\r\nint minor;\r\nunsigned int mask = 0;\r\nminor = iminor(file->f_path.dentry->d_inode);\r\npoll_wait(file, &channel_wqs[minor].rt_queue, wait);\r\npoll_wait(file, &channel_wqs[minor].lx_queue, wait);\r\nif (rtlx == NULL)\r\nreturn 0;\r\nif (rtlx_read_poll(minor, 0))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (rtlx_write_poll(minor))\r\nmask |= POLLOUT | POLLWRNORM;\r\nreturn mask;\r\n}\r\nstatic ssize_t file_read(struct file *file, char __user * buffer, size_t count,\r\nloff_t * ppos)\r\n{\r\nint minor = iminor(file->f_path.dentry->d_inode);\r\nif (!rtlx_read_poll(minor, (file->f_flags & O_NONBLOCK) ? 0 : 1)) {\r\nreturn 0;\r\n}\r\nreturn rtlx_read(minor, buffer, count);\r\n}\r\nstatic ssize_t file_write(struct file *file, const char __user * buffer,\r\nsize_t count, loff_t * ppos)\r\n{\r\nint minor;\r\nstruct rtlx_channel *rt;\r\nminor = iminor(file->f_path.dentry->d_inode);\r\nrt = &rtlx->channel[minor];\r\nif (!rtlx_write_poll(minor)) {\r\nint ret = 0;\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\n__wait_event_interruptible(channel_wqs[minor].rt_queue,\r\nrtlx_write_poll(minor),\r\nret);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn rtlx_write(minor, buffer, count);\r\n}\r\nstatic int __init rtlx_module_init(void)\r\n{\r\nstruct device *dev;\r\nint i, err;\r\nif (!cpu_has_mipsmt) {\r\nprintk("VPE loader: not a MIPS MT capable processor\n");\r\nreturn -ENODEV;\r\n}\r\nif (tclimit == 0) {\r\nprintk(KERN_WARNING "No TCs reserved for AP/SP, not "\r\n"initializing RTLX.\nPass maxtcs=<n> argument as kernel "\r\n"argument\n");\r\nreturn -ENODEV;\r\n}\r\nmajor = register_chrdev(0, module_name, &rtlx_fops);\r\nif (major < 0) {\r\nprintk(register_chrdev_failed);\r\nreturn major;\r\n}\r\nfor (i = 0; i < RTLX_CHANNELS; i++) {\r\ninit_waitqueue_head(&channel_wqs[i].rt_queue);\r\ninit_waitqueue_head(&channel_wqs[i].lx_queue);\r\natomic_set(&channel_wqs[i].in_open, 0);\r\nmutex_init(&channel_wqs[i].mutex);\r\ndev = device_create(mt_class, NULL, MKDEV(major, i), NULL,\r\n"%s%d", module_name, i);\r\nif (IS_ERR(dev)) {\r\nerr = PTR_ERR(dev);\r\ngoto out_chrdev;\r\n}\r\n}\r\nnotify.start = starting;\r\nnotify.stop = stopping;\r\nvpe_notify(tclimit, &notify);\r\nif (cpu_has_vint)\r\nset_vi_handler(MIPS_CPU_RTLX_IRQ, rtlx_dispatch);\r\nelse {\r\npr_err("APRP RTLX init on non-vectored-interrupt processor\n");\r\nerr = -ENODEV;\r\ngoto out_chrdev;\r\n}\r\nrtlx_irq.dev_id = rtlx;\r\nsetup_irq(rtlx_irq_num, &rtlx_irq);\r\nreturn 0;\r\nout_chrdev:\r\nfor (i = 0; i < RTLX_CHANNELS; i++)\r\ndevice_destroy(mt_class, MKDEV(major, i));\r\nreturn err;\r\n}\r\nstatic void __exit rtlx_module_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < RTLX_CHANNELS; i++)\r\ndevice_destroy(mt_class, MKDEV(major, i));\r\nunregister_chrdev(major, module_name);\r\n}
