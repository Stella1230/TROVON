static __be32 nfs4_callback_null(struct svc_rqst *rqstp, void *argp, void *resp)\r\n{\r\nreturn htonl(NFS4_OK);\r\n}\r\nstatic int nfs4_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\r\n{\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nstatic int nfs4_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\r\n{\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, nbytes);\r\nif (unlikely(p == NULL))\r\nprintk(KERN_WARNING "NFS: NFSv4 callback reply buffer overflowed!\n");\r\nreturn p;\r\n}\r\nstatic __be32 decode_string(struct xdr_stream *xdr, unsigned int *len, const char **str)\r\n{\r\n__be32 *p;\r\np = read_buf(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\n*len = ntohl(*p);\r\nif (*len != 0) {\r\np = read_buf(xdr, *len);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\n*str = (const char *)p;\r\n} else\r\n*str = NULL;\r\nreturn 0;\r\n}\r\nstatic __be32 decode_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\r\n{\r\n__be32 *p;\r\np = read_buf(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\nfh->size = ntohl(*p);\r\nif (fh->size > NFS4_FHSIZE)\r\nreturn htonl(NFS4ERR_BADHANDLE);\r\np = read_buf(xdr, fh->size);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\nmemcpy(&fh->data[0], p, fh->size);\r\nmemset(&fh->data[fh->size], 0, sizeof(fh->data) - fh->size);\r\nreturn 0;\r\n}\r\nstatic __be32 decode_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\r\n{\r\n__be32 *p;\r\nunsigned int attrlen;\r\np = read_buf(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\nattrlen = ntohl(*p);\r\np = read_buf(xdr, attrlen << 2);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\nif (likely(attrlen > 0))\r\nbitmap[0] = ntohl(*p++);\r\nif (attrlen > 1)\r\nbitmap[1] = ntohl(*p);\r\nreturn 0;\r\n}\r\nstatic __be32 decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\r\n{\r\n__be32 *p;\r\np = read_buf(xdr, NFS4_STATEID_SIZE);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\nmemcpy(stateid, p, NFS4_STATEID_SIZE);\r\nreturn 0;\r\n}\r\nstatic __be32 decode_compound_hdr_arg(struct xdr_stream *xdr, struct cb_compound_hdr_arg *hdr)\r\n{\r\n__be32 *p;\r\n__be32 status;\r\nstatus = decode_string(xdr, &hdr->taglen, &hdr->tag);\r\nif (unlikely(status != 0))\r\nreturn status;\r\nif (hdr->taglen > CB_OP_TAGLEN_MAXSZ - 12) {\r\nprintk("NFS: NFSv4 CALLBACK %s: client sent tag of length %u\n",\r\n__func__, hdr->taglen);\r\nreturn htonl(NFS4ERR_RESOURCE);\r\n}\r\np = read_buf(xdr, 12);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\nhdr->minorversion = ntohl(*p++);\r\nif (hdr->minorversion <= 1) {\r\nhdr->cb_ident = ntohl(*p++);\r\n} else {\r\npr_warn_ratelimited("NFS: %s: NFSv4 server callback with "\r\n"illegal minor version %u!\n",\r\n__func__, hdr->minorversion);\r\nreturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\r\n}\r\nhdr->nops = ntohl(*p);\r\ndprintk("%s: minorversion %d nops %d\n", __func__,\r\nhdr->minorversion, hdr->nops);\r\nreturn 0;\r\n}\r\nstatic __be32 decode_op_hdr(struct xdr_stream *xdr, unsigned int *op)\r\n{\r\n__be32 *p;\r\np = read_buf(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE_HDR);\r\n*op = ntohl(*p);\r\nreturn 0;\r\n}\r\nstatic __be32 decode_getattr_args(struct svc_rqst *rqstp, struct xdr_stream *xdr, struct cb_getattrargs *args)\r\n{\r\n__be32 status;\r\nstatus = decode_fh(xdr, &args->fh);\r\nif (unlikely(status != 0))\r\ngoto out;\r\nargs->addr = svc_addr(rqstp);\r\nstatus = decode_bitmap(xdr, args->bitmap);\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(status));\r\nreturn status;\r\n}\r\nstatic __be32 decode_recall_args(struct svc_rqst *rqstp, struct xdr_stream *xdr, struct cb_recallargs *args)\r\n{\r\n__be32 *p;\r\n__be32 status;\r\nargs->addr = svc_addr(rqstp);\r\nstatus = decode_stateid(xdr, &args->stateid);\r\nif (unlikely(status != 0))\r\ngoto out;\r\np = read_buf(xdr, 4);\r\nif (unlikely(p == NULL)) {\r\nstatus = htonl(NFS4ERR_RESOURCE);\r\ngoto out;\r\n}\r\nargs->truncate = ntohl(*p);\r\nstatus = decode_fh(xdr, &args->fh);\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(status));\r\nreturn status;\r\n}\r\nstatic __be32 decode_layoutrecall_args(struct svc_rqst *rqstp,\r\nstruct xdr_stream *xdr,\r\nstruct cb_layoutrecallargs *args)\r\n{\r\n__be32 *p;\r\n__be32 status = 0;\r\nuint32_t iomode;\r\nargs->cbl_addr = svc_addr(rqstp);\r\np = read_buf(xdr, 4 * sizeof(uint32_t));\r\nif (unlikely(p == NULL)) {\r\nstatus = htonl(NFS4ERR_BADXDR);\r\ngoto out;\r\n}\r\nargs->cbl_layout_type = ntohl(*p++);\r\niomode = ntohl(*p++);\r\nargs->cbl_layoutchanged = ntohl(*p++);\r\nargs->cbl_recall_type = ntohl(*p++);\r\nif (args->cbl_recall_type == RETURN_FILE) {\r\nargs->cbl_range.iomode = iomode;\r\nstatus = decode_fh(xdr, &args->cbl_fh);\r\nif (unlikely(status != 0))\r\ngoto out;\r\np = read_buf(xdr, 2 * sizeof(uint64_t));\r\nif (unlikely(p == NULL)) {\r\nstatus = htonl(NFS4ERR_BADXDR);\r\ngoto out;\r\n}\r\np = xdr_decode_hyper(p, &args->cbl_range.offset);\r\np = xdr_decode_hyper(p, &args->cbl_range.length);\r\nstatus = decode_stateid(xdr, &args->cbl_stateid);\r\nif (unlikely(status != 0))\r\ngoto out;\r\n} else if (args->cbl_recall_type == RETURN_FSID) {\r\np = read_buf(xdr, 2 * sizeof(uint64_t));\r\nif (unlikely(p == NULL)) {\r\nstatus = htonl(NFS4ERR_BADXDR);\r\ngoto out;\r\n}\r\np = xdr_decode_hyper(p, &args->cbl_fsid.major);\r\np = xdr_decode_hyper(p, &args->cbl_fsid.minor);\r\n} else if (args->cbl_recall_type != RETURN_ALL) {\r\nstatus = htonl(NFS4ERR_BADXDR);\r\ngoto out;\r\n}\r\ndprintk("%s: ltype 0x%x iomode %d changed %d recall_type %d\n",\r\n__func__,\r\nargs->cbl_layout_type, iomode,\r\nargs->cbl_layoutchanged, args->cbl_recall_type);\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(status));\r\nreturn status;\r\n}\r\nstatic\r\n__be32 decode_devicenotify_args(struct svc_rqst *rqstp,\r\nstruct xdr_stream *xdr,\r\nstruct cb_devicenotifyargs *args)\r\n{\r\n__be32 *p;\r\n__be32 status = 0;\r\nu32 tmp;\r\nint n, i;\r\nargs->ndevs = 0;\r\np = read_buf(xdr, sizeof(uint32_t));\r\nif (unlikely(p == NULL)) {\r\nstatus = htonl(NFS4ERR_BADXDR);\r\ngoto out;\r\n}\r\nn = ntohl(*p++);\r\nif (n <= 0)\r\ngoto out;\r\nif (n > ULONG_MAX / sizeof(*args->devs)) {\r\nstatus = htonl(NFS4ERR_BADXDR);\r\ngoto out;\r\n}\r\nargs->devs = kmalloc(n * sizeof(*args->devs), GFP_KERNEL);\r\nif (!args->devs) {\r\nstatus = htonl(NFS4ERR_DELAY);\r\ngoto out;\r\n}\r\nfor (i = 0; i < n; i++) {\r\nstruct cb_devicenotifyitem *dev = &args->devs[i];\r\np = read_buf(xdr, (4 * sizeof(uint32_t)) + NFS4_DEVICEID4_SIZE);\r\nif (unlikely(p == NULL)) {\r\nstatus = htonl(NFS4ERR_BADXDR);\r\ngoto err;\r\n}\r\ntmp = ntohl(*p++);\r\nif (tmp != 1) {\r\nstatus = htonl(NFS4ERR_INVAL);\r\ngoto err;\r\n}\r\ndev->cbd_notify_type = ntohl(*p++);\r\nif (dev->cbd_notify_type != NOTIFY_DEVICEID4_CHANGE &&\r\ndev->cbd_notify_type != NOTIFY_DEVICEID4_DELETE) {\r\nstatus = htonl(NFS4ERR_INVAL);\r\ngoto err;\r\n}\r\ntmp = ntohl(*p++);\r\nif (((dev->cbd_notify_type == NOTIFY_DEVICEID4_CHANGE) &&\r\n(tmp != NFS4_DEVICEID4_SIZE + 8)) ||\r\n((dev->cbd_notify_type == NOTIFY_DEVICEID4_DELETE) &&\r\n(tmp != NFS4_DEVICEID4_SIZE + 4))) {\r\nstatus = htonl(NFS4ERR_INVAL);\r\ngoto err;\r\n}\r\ndev->cbd_layout_type = ntohl(*p++);\r\nmemcpy(dev->cbd_dev_id.data, p, NFS4_DEVICEID4_SIZE);\r\np += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\r\nif (dev->cbd_layout_type == NOTIFY_DEVICEID4_CHANGE) {\r\np = read_buf(xdr, sizeof(uint32_t));\r\nif (unlikely(p == NULL)) {\r\nstatus = htonl(NFS4ERR_BADXDR);\r\ngoto err;\r\n}\r\ndev->cbd_immediate = ntohl(*p++);\r\n} else {\r\ndev->cbd_immediate = 0;\r\n}\r\nargs->ndevs++;\r\ndprintk("%s: type %d layout 0x%x immediate %d\n",\r\n__func__, dev->cbd_notify_type, dev->cbd_layout_type,\r\ndev->cbd_immediate);\r\n}\r\nout:\r\ndprintk("%s: status %d ndevs %d\n",\r\n__func__, ntohl(status), args->ndevs);\r\nreturn status;\r\nerr:\r\nkfree(args->devs);\r\ngoto out;\r\n}\r\nstatic __be32 decode_sessionid(struct xdr_stream *xdr,\r\nstruct nfs4_sessionid *sid)\r\n{\r\n__be32 *p;\r\nint len = NFS4_MAX_SESSIONID_LEN;\r\np = read_buf(xdr, len);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\nmemcpy(sid->data, p, len);\r\nreturn 0;\r\n}\r\nstatic __be32 decode_rc_list(struct xdr_stream *xdr,\r\nstruct referring_call_list *rc_list)\r\n{\r\n__be32 *p;\r\nint i;\r\n__be32 status;\r\nstatus = decode_sessionid(xdr, &rc_list->rcl_sessionid);\r\nif (status)\r\ngoto out;\r\nstatus = htonl(NFS4ERR_RESOURCE);\r\np = read_buf(xdr, sizeof(uint32_t));\r\nif (unlikely(p == NULL))\r\ngoto out;\r\nrc_list->rcl_nrefcalls = ntohl(*p++);\r\nif (rc_list->rcl_nrefcalls) {\r\np = read_buf(xdr,\r\nrc_list->rcl_nrefcalls * 2 * sizeof(uint32_t));\r\nif (unlikely(p == NULL))\r\ngoto out;\r\nrc_list->rcl_refcalls = kmalloc(rc_list->rcl_nrefcalls *\r\nsizeof(*rc_list->rcl_refcalls),\r\nGFP_KERNEL);\r\nif (unlikely(rc_list->rcl_refcalls == NULL))\r\ngoto out;\r\nfor (i = 0; i < rc_list->rcl_nrefcalls; i++) {\r\nrc_list->rcl_refcalls[i].rc_sequenceid = ntohl(*p++);\r\nrc_list->rcl_refcalls[i].rc_slotid = ntohl(*p++);\r\n}\r\n}\r\nstatus = 0;\r\nout:\r\nreturn status;\r\n}\r\nstatic __be32 decode_cb_sequence_args(struct svc_rqst *rqstp,\r\nstruct xdr_stream *xdr,\r\nstruct cb_sequenceargs *args)\r\n{\r\n__be32 *p;\r\nint i;\r\n__be32 status;\r\nstatus = decode_sessionid(xdr, &args->csa_sessionid);\r\nif (status)\r\ngoto out;\r\nstatus = htonl(NFS4ERR_RESOURCE);\r\np = read_buf(xdr, 5 * sizeof(uint32_t));\r\nif (unlikely(p == NULL))\r\ngoto out;\r\nargs->csa_addr = svc_addr(rqstp);\r\nargs->csa_sequenceid = ntohl(*p++);\r\nargs->csa_slotid = ntohl(*p++);\r\nargs->csa_highestslotid = ntohl(*p++);\r\nargs->csa_cachethis = ntohl(*p++);\r\nargs->csa_nrclists = ntohl(*p++);\r\nargs->csa_rclists = NULL;\r\nif (args->csa_nrclists) {\r\nargs->csa_rclists = kmalloc_array(args->csa_nrclists,\r\nsizeof(*args->csa_rclists),\r\nGFP_KERNEL);\r\nif (unlikely(args->csa_rclists == NULL))\r\ngoto out;\r\nfor (i = 0; i < args->csa_nrclists; i++) {\r\nstatus = decode_rc_list(xdr, &args->csa_rclists[i]);\r\nif (status)\r\ngoto out_free;\r\n}\r\n}\r\nstatus = 0;\r\ndprintk("%s: sessionid %x:%x:%x:%x sequenceid %u slotid %u "\r\n"highestslotid %u cachethis %d nrclists %u\n",\r\n__func__,\r\n((u32 *)&args->csa_sessionid)[0],\r\n((u32 *)&args->csa_sessionid)[1],\r\n((u32 *)&args->csa_sessionid)[2],\r\n((u32 *)&args->csa_sessionid)[3],\r\nargs->csa_sequenceid, args->csa_slotid,\r\nargs->csa_highestslotid, args->csa_cachethis,\r\nargs->csa_nrclists);\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(status));\r\nreturn status;\r\nout_free:\r\nfor (i = 0; i < args->csa_nrclists; i++)\r\nkfree(args->csa_rclists[i].rcl_refcalls);\r\nkfree(args->csa_rclists);\r\ngoto out;\r\n}\r\nstatic __be32 decode_recallany_args(struct svc_rqst *rqstp,\r\nstruct xdr_stream *xdr,\r\nstruct cb_recallanyargs *args)\r\n{\r\nuint32_t bitmap[2];\r\n__be32 *p, status;\r\nargs->craa_addr = svc_addr(rqstp);\r\np = read_buf(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_BADXDR);\r\nargs->craa_objs_to_keep = ntohl(*p++);\r\nstatus = decode_bitmap(xdr, bitmap);\r\nif (unlikely(status))\r\nreturn status;\r\nargs->craa_type_mask = bitmap[0];\r\nreturn 0;\r\n}\r\nstatic __be32 decode_recallslot_args(struct svc_rqst *rqstp,\r\nstruct xdr_stream *xdr,\r\nstruct cb_recallslotargs *args)\r\n{\r\n__be32 *p;\r\nargs->crsa_addr = svc_addr(rqstp);\r\np = read_buf(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_BADXDR);\r\nargs->crsa_target_max_slots = ntohl(*p++);\r\nreturn 0;\r\n}\r\nstatic __be32 encode_string(struct xdr_stream *xdr, unsigned int len, const char *str)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 4 + len);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\nxdr_encode_opaque(p, str, len);\r\nreturn 0;\r\n}\r\nstatic __be32 encode_attr_bitmap(struct xdr_stream *xdr, const uint32_t *bitmap, __be32 **savep)\r\n{\r\n__be32 bm[2];\r\n__be32 *p;\r\nbm[0] = htonl(bitmap[0] & CB_SUPPORTED_ATTR0);\r\nbm[1] = htonl(bitmap[1] & CB_SUPPORTED_ATTR1);\r\nif (bm[1] != 0) {\r\np = xdr_reserve_space(xdr, 16);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\n*p++ = htonl(2);\r\n*p++ = bm[0];\r\n*p++ = bm[1];\r\n} else if (bm[0] != 0) {\r\np = xdr_reserve_space(xdr, 12);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\n*p++ = htonl(1);\r\n*p++ = bm[0];\r\n} else {\r\np = xdr_reserve_space(xdr, 8);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\n*p++ = htonl(0);\r\n}\r\n*savep = p;\r\nreturn 0;\r\n}\r\nstatic __be32 encode_attr_change(struct xdr_stream *xdr, const uint32_t *bitmap, uint64_t change)\r\n{\r\n__be32 *p;\r\nif (!(bitmap[0] & FATTR4_WORD0_CHANGE))\r\nreturn 0;\r\np = xdr_reserve_space(xdr, 8);\r\nif (unlikely(!p))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\np = xdr_encode_hyper(p, change);\r\nreturn 0;\r\n}\r\nstatic __be32 encode_attr_size(struct xdr_stream *xdr, const uint32_t *bitmap, uint64_t size)\r\n{\r\n__be32 *p;\r\nif (!(bitmap[0] & FATTR4_WORD0_SIZE))\r\nreturn 0;\r\np = xdr_reserve_space(xdr, 8);\r\nif (unlikely(!p))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\np = xdr_encode_hyper(p, size);\r\nreturn 0;\r\n}\r\nstatic __be32 encode_attr_time(struct xdr_stream *xdr, const struct timespec *time)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 12);\r\nif (unlikely(!p))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\np = xdr_encode_hyper(p, time->tv_sec);\r\n*p = htonl(time->tv_nsec);\r\nreturn 0;\r\n}\r\nstatic __be32 encode_attr_ctime(struct xdr_stream *xdr, const uint32_t *bitmap, const struct timespec *time)\r\n{\r\nif (!(bitmap[1] & FATTR4_WORD1_TIME_METADATA))\r\nreturn 0;\r\nreturn encode_attr_time(xdr,time);\r\n}\r\nstatic __be32 encode_attr_mtime(struct xdr_stream *xdr, const uint32_t *bitmap, const struct timespec *time)\r\n{\r\nif (!(bitmap[1] & FATTR4_WORD1_TIME_MODIFY))\r\nreturn 0;\r\nreturn encode_attr_time(xdr,time);\r\n}\r\nstatic __be32 encode_compound_hdr_res(struct xdr_stream *xdr, struct cb_compound_hdr_res *hdr)\r\n{\r\n__be32 status;\r\nhdr->status = xdr_reserve_space(xdr, 4);\r\nif (unlikely(hdr->status == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\nstatus = encode_string(xdr, hdr->taglen, hdr->tag);\r\nif (unlikely(status != 0))\r\nreturn status;\r\nhdr->nops = xdr_reserve_space(xdr, 4);\r\nif (unlikely(hdr->nops == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\nreturn 0;\r\n}\r\nstatic __be32 encode_op_hdr(struct xdr_stream *xdr, uint32_t op, __be32 res)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 8);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE_HDR);\r\n*p++ = htonl(op);\r\n*p = res;\r\nreturn 0;\r\n}\r\nstatic __be32 encode_getattr_res(struct svc_rqst *rqstp, struct xdr_stream *xdr, const struct cb_getattrres *res)\r\n{\r\n__be32 *savep = NULL;\r\n__be32 status = res->status;\r\nif (unlikely(status != 0))\r\ngoto out;\r\nstatus = encode_attr_bitmap(xdr, res->bitmap, &savep);\r\nif (unlikely(status != 0))\r\ngoto out;\r\nstatus = encode_attr_change(xdr, res->bitmap, res->change_attr);\r\nif (unlikely(status != 0))\r\ngoto out;\r\nstatus = encode_attr_size(xdr, res->bitmap, res->size);\r\nif (unlikely(status != 0))\r\ngoto out;\r\nstatus = encode_attr_ctime(xdr, res->bitmap, &res->ctime);\r\nif (unlikely(status != 0))\r\ngoto out;\r\nstatus = encode_attr_mtime(xdr, res->bitmap, &res->mtime);\r\n*savep = htonl((unsigned int)((char *)xdr->p - (char *)(savep+1)));\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(status));\r\nreturn status;\r\n}\r\nstatic __be32 encode_sessionid(struct xdr_stream *xdr,\r\nconst struct nfs4_sessionid *sid)\r\n{\r\n__be32 *p;\r\nint len = NFS4_MAX_SESSIONID_LEN;\r\np = xdr_reserve_space(xdr, len);\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\nmemcpy(p, sid, len);\r\nreturn 0;\r\n}\r\nstatic __be32 encode_cb_sequence_res(struct svc_rqst *rqstp,\r\nstruct xdr_stream *xdr,\r\nconst struct cb_sequenceres *res)\r\n{\r\n__be32 *p;\r\n__be32 status = res->csr_status;\r\nif (unlikely(status != 0))\r\ngoto out;\r\nencode_sessionid(xdr, &res->csr_sessionid);\r\np = xdr_reserve_space(xdr, 4 * sizeof(uint32_t));\r\nif (unlikely(p == NULL))\r\nreturn htonl(NFS4ERR_RESOURCE);\r\n*p++ = htonl(res->csr_sequenceid);\r\n*p++ = htonl(res->csr_slotid);\r\n*p++ = htonl(res->csr_highestslotid);\r\n*p++ = htonl(res->csr_target_highestslotid);\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(status));\r\nreturn status;\r\n}\r\nstatic __be32\r\npreprocess_nfs41_op(int nop, unsigned int op_nr, struct callback_op **op)\r\n{\r\nif (op_nr == OP_CB_SEQUENCE) {\r\nif (nop != 0)\r\nreturn htonl(NFS4ERR_SEQUENCE_POS);\r\n} else {\r\nif (nop == 0)\r\nreturn htonl(NFS4ERR_OP_NOT_IN_SESSION);\r\n}\r\nswitch (op_nr) {\r\ncase OP_CB_GETATTR:\r\ncase OP_CB_RECALL:\r\ncase OP_CB_SEQUENCE:\r\ncase OP_CB_RECALL_ANY:\r\ncase OP_CB_RECALL_SLOT:\r\ncase OP_CB_LAYOUTRECALL:\r\ncase OP_CB_NOTIFY_DEVICEID:\r\n*op = &callback_ops[op_nr];\r\nbreak;\r\ncase OP_CB_NOTIFY:\r\ncase OP_CB_PUSH_DELEG:\r\ncase OP_CB_RECALLABLE_OBJ_AVAIL:\r\ncase OP_CB_WANTS_CANCELLED:\r\ncase OP_CB_NOTIFY_LOCK:\r\nreturn htonl(NFS4ERR_NOTSUPP);\r\ndefault:\r\nreturn htonl(NFS4ERR_OP_ILLEGAL);\r\n}\r\nreturn htonl(NFS_OK);\r\n}\r\nstatic void nfs4_callback_free_slot(struct nfs4_session *session)\r\n{\r\nstruct nfs4_slot_table *tbl = &session->bc_slot_table;\r\nspin_lock(&tbl->slot_tbl_lock);\r\ntbl->highest_used_slotid = NFS4_NO_SLOT;\r\nnfs4_check_drain_bc_complete(session);\r\nspin_unlock(&tbl->slot_tbl_lock);\r\n}\r\nstatic void nfs4_cb_free_slot(struct cb_process_state *cps)\r\n{\r\nif (cps->slotid != NFS4_NO_SLOT)\r\nnfs4_callback_free_slot(cps->clp->cl_session);\r\n}\r\nstatic __be32\r\npreprocess_nfs41_op(int nop, unsigned int op_nr, struct callback_op **op)\r\n{\r\nreturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\r\n}\r\nstatic void nfs4_cb_free_slot(struct cb_process_state *cps)\r\n{\r\n}\r\nstatic __be32\r\npreprocess_nfs4_op(unsigned int op_nr, struct callback_op **op)\r\n{\r\nswitch (op_nr) {\r\ncase OP_CB_GETATTR:\r\ncase OP_CB_RECALL:\r\n*op = &callback_ops[op_nr];\r\nbreak;\r\ndefault:\r\nreturn htonl(NFS4ERR_OP_ILLEGAL);\r\n}\r\nreturn htonl(NFS_OK);\r\n}\r\nstatic __be32 process_op(uint32_t minorversion, int nop,\r\nstruct svc_rqst *rqstp,\r\nstruct xdr_stream *xdr_in, void *argp,\r\nstruct xdr_stream *xdr_out, void *resp,\r\nstruct cb_process_state *cps)\r\n{\r\nstruct callback_op *op = &callback_ops[0];\r\nunsigned int op_nr;\r\n__be32 status;\r\nlong maxlen;\r\n__be32 res;\r\ndprintk("%s: start\n", __func__);\r\nstatus = decode_op_hdr(xdr_in, &op_nr);\r\nif (unlikely(status))\r\nreturn status;\r\ndprintk("%s: minorversion=%d nop=%d op_nr=%u\n",\r\n__func__, minorversion, nop, op_nr);\r\nstatus = minorversion ? preprocess_nfs41_op(nop, op_nr, &op) :\r\npreprocess_nfs4_op(op_nr, &op);\r\nif (status == htonl(NFS4ERR_OP_ILLEGAL))\r\nop_nr = OP_CB_ILLEGAL;\r\nif (status)\r\ngoto encode_hdr;\r\nif (cps->drc_status) {\r\nstatus = cps->drc_status;\r\ngoto encode_hdr;\r\n}\r\nmaxlen = xdr_out->end - xdr_out->p;\r\nif (maxlen > 0 && maxlen < PAGE_SIZE) {\r\nstatus = op->decode_args(rqstp, xdr_in, argp);\r\nif (likely(status == 0))\r\nstatus = op->process_op(argp, resp, cps);\r\n} else\r\nstatus = htonl(NFS4ERR_RESOURCE);\r\nencode_hdr:\r\nres = encode_op_hdr(xdr_out, op_nr, status);\r\nif (unlikely(res))\r\nreturn res;\r\nif (op->encode_res != NULL && status == 0)\r\nstatus = op->encode_res(rqstp, xdr_out, resp);\r\ndprintk("%s: done, status = %d\n", __func__, ntohl(status));\r\nreturn status;\r\n}\r\nstatic __be32 nfs4_callback_compound(struct svc_rqst *rqstp, void *argp, void *resp)\r\n{\r\nstruct cb_compound_hdr_arg hdr_arg = { 0 };\r\nstruct cb_compound_hdr_res hdr_res = { NULL };\r\nstruct xdr_stream xdr_in, xdr_out;\r\n__be32 *p, status;\r\nstruct cb_process_state cps = {\r\n.drc_status = 0,\r\n.clp = NULL,\r\n.slotid = NFS4_NO_SLOT,\r\n.net = SVC_NET(rqstp),\r\n};\r\nunsigned int nops = 0;\r\ndprintk("%s: start\n", __func__);\r\nxdr_init_decode(&xdr_in, &rqstp->rq_arg, rqstp->rq_arg.head[0].iov_base);\r\np = (__be32*)((char *)rqstp->rq_res.head[0].iov_base + rqstp->rq_res.head[0].iov_len);\r\nxdr_init_encode(&xdr_out, &rqstp->rq_res, p);\r\nstatus = decode_compound_hdr_arg(&xdr_in, &hdr_arg);\r\nif (status == __constant_htonl(NFS4ERR_RESOURCE))\r\nreturn rpc_garbage_args;\r\nif (hdr_arg.minorversion == 0) {\r\ncps.clp = nfs4_find_client_ident(SVC_NET(rqstp), hdr_arg.cb_ident);\r\nif (!cps.clp || !check_gss_callback_principal(cps.clp, rqstp))\r\nreturn rpc_drop_reply;\r\n}\r\nhdr_res.taglen = hdr_arg.taglen;\r\nhdr_res.tag = hdr_arg.tag;\r\nif (encode_compound_hdr_res(&xdr_out, &hdr_res) != 0)\r\nreturn rpc_system_err;\r\nwhile (status == 0 && nops != hdr_arg.nops) {\r\nstatus = process_op(hdr_arg.minorversion, nops, rqstp,\r\n&xdr_in, argp, &xdr_out, resp, &cps);\r\nnops++;\r\n}\r\nif (unlikely(status == htonl(NFS4ERR_RESOURCE_HDR))) {\r\nstatus = htonl(NFS4ERR_RESOURCE);\r\nnops--;\r\n}\r\n*hdr_res.status = status;\r\n*hdr_res.nops = htonl(nops);\r\nnfs4_cb_free_slot(&cps);\r\nnfs_put_client(cps.clp);\r\ndprintk("%s: done, status = %u\n", __func__, ntohl(status));\r\nreturn rpc_success;\r\n}
