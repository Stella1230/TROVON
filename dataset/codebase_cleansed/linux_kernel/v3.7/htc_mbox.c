static void ath6kl_credit_deposit(struct ath6kl_htc_credit_info *cred_info,\r\nstruct htc_endpoint_credit_dist *ep_dist,\r\nint credits)\r\n{\r\nath6kl_dbg(ATH6KL_DBG_CREDIT, "credit deposit ep %d credits %d\n",\r\nep_dist->endpoint, credits);\r\nep_dist->credits += credits;\r\nep_dist->cred_assngd += credits;\r\ncred_info->cur_free_credits -= credits;\r\n}\r\nstatic void ath6kl_credit_init(struct ath6kl_htc_credit_info *cred_info,\r\nstruct list_head *ep_list,\r\nint tot_credits)\r\n{\r\nstruct htc_endpoint_credit_dist *cur_ep_dist;\r\nint count;\r\nath6kl_dbg(ATH6KL_DBG_CREDIT, "credit init total %d\n", tot_credits);\r\ncred_info->cur_free_credits = tot_credits;\r\ncred_info->total_avail_credits = tot_credits;\r\nlist_for_each_entry(cur_ep_dist, ep_list, list) {\r\nif (cur_ep_dist->endpoint == ENDPOINT_0)\r\ncontinue;\r\ncur_ep_dist->cred_min = cur_ep_dist->cred_per_msg;\r\nif (tot_credits > 4) {\r\nif ((cur_ep_dist->svc_id == WMI_DATA_BK_SVC) ||\r\n(cur_ep_dist->svc_id == WMI_DATA_BE_SVC)) {\r\nath6kl_credit_deposit(cred_info,\r\ncur_ep_dist,\r\ncur_ep_dist->cred_min);\r\ncur_ep_dist->dist_flags |= HTC_EP_ACTIVE;\r\n}\r\n}\r\nif (cur_ep_dist->svc_id == WMI_CONTROL_SVC) {\r\nath6kl_credit_deposit(cred_info, cur_ep_dist,\r\ncur_ep_dist->cred_min);\r\ncur_ep_dist->dist_flags |= HTC_EP_ACTIVE;\r\n}\r\n}\r\ncred_info->lowestpri_ep_dist = cur_ep_dist->list;\r\nWARN_ON(cred_info->cur_free_credits <= 0);\r\nlist_for_each_entry(cur_ep_dist, ep_list, list) {\r\nif (cur_ep_dist->endpoint == ENDPOINT_0)\r\ncontinue;\r\nif (cur_ep_dist->svc_id == WMI_CONTROL_SVC)\r\ncur_ep_dist->cred_norm = cur_ep_dist->cred_per_msg;\r\nelse {\r\ncount = (cred_info->cur_free_credits /\r\ncur_ep_dist->cred_per_msg)\r\n* cur_ep_dist->cred_per_msg;\r\ncount = (count * 3) >> 2;\r\ncount = max(count, cur_ep_dist->cred_per_msg);\r\ncur_ep_dist->cred_norm = count;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_CREDIT,\r\n"credit ep %d svc_id %d credits %d per_msg %d norm %d min %d\n",\r\ncur_ep_dist->endpoint,\r\ncur_ep_dist->svc_id,\r\ncur_ep_dist->credits,\r\ncur_ep_dist->cred_per_msg,\r\ncur_ep_dist->cred_norm,\r\ncur_ep_dist->cred_min);\r\n}\r\n}\r\nstatic int ath6kl_htc_mbox_credit_setup(struct htc_target *htc_target,\r\nstruct ath6kl_htc_credit_info *cred_info)\r\n{\r\nu16 servicepriority[5];\r\nmemset(cred_info, 0, sizeof(struct ath6kl_htc_credit_info));\r\nservicepriority[0] = WMI_CONTROL_SVC;\r\nservicepriority[1] = WMI_DATA_VO_SVC;\r\nservicepriority[2] = WMI_DATA_VI_SVC;\r\nservicepriority[3] = WMI_DATA_BE_SVC;\r\nservicepriority[4] = WMI_DATA_BK_SVC;\r\nath6kl_htc_set_credit_dist(htc_target, cred_info, servicepriority, 5);\r\nreturn 0;\r\n}\r\nstatic void ath6kl_credit_reduce(struct ath6kl_htc_credit_info *cred_info,\r\nstruct htc_endpoint_credit_dist *ep_dist,\r\nint limit)\r\n{\r\nint credits;\r\nath6kl_dbg(ATH6KL_DBG_CREDIT, "credit reduce ep %d limit %d\n",\r\nep_dist->endpoint, limit);\r\nep_dist->cred_assngd = limit;\r\nif (ep_dist->credits <= limit)\r\nreturn;\r\ncredits = ep_dist->credits - limit;\r\nep_dist->credits -= credits;\r\ncred_info->cur_free_credits += credits;\r\n}\r\nstatic void ath6kl_credit_update(struct ath6kl_htc_credit_info *cred_info,\r\nstruct list_head *epdist_list)\r\n{\r\nstruct htc_endpoint_credit_dist *cur_list;\r\nlist_for_each_entry(cur_list, epdist_list, list) {\r\nif (cur_list->endpoint == ENDPOINT_0)\r\ncontinue;\r\nif (cur_list->cred_to_dist > 0) {\r\ncur_list->credits += cur_list->cred_to_dist;\r\ncur_list->cred_to_dist = 0;\r\nif (cur_list->credits > cur_list->cred_assngd)\r\nath6kl_credit_reduce(cred_info,\r\ncur_list,\r\ncur_list->cred_assngd);\r\nif (cur_list->credits > cur_list->cred_norm)\r\nath6kl_credit_reduce(cred_info, cur_list,\r\ncur_list->cred_norm);\r\nif (!(cur_list->dist_flags & HTC_EP_ACTIVE)) {\r\nif (cur_list->txq_depth == 0)\r\nath6kl_credit_reduce(cred_info,\r\ncur_list, 0);\r\n}\r\n}\r\n}\r\n}\r\nstatic void ath6kl_credit_seek(struct ath6kl_htc_credit_info *cred_info,\r\nstruct htc_endpoint_credit_dist *ep_dist)\r\n{\r\nstruct htc_endpoint_credit_dist *curdist_list;\r\nint credits = 0;\r\nint need;\r\nif (ep_dist->svc_id == WMI_CONTROL_SVC)\r\ngoto out;\r\nif ((ep_dist->svc_id == WMI_DATA_VI_SVC) ||\r\n(ep_dist->svc_id == WMI_DATA_VO_SVC))\r\nif ((ep_dist->cred_assngd >= ep_dist->cred_norm))\r\ngoto out;\r\ncredits = min(cred_info->cur_free_credits, ep_dist->seek_cred);\r\nif (credits >= ep_dist->seek_cred)\r\ngoto out;\r\nlist_for_each_entry_reverse(curdist_list,\r\n&cred_info->lowestpri_ep_dist,\r\nlist) {\r\nif (curdist_list == ep_dist)\r\nbreak;\r\nneed = ep_dist->seek_cred - cred_info->cur_free_credits;\r\nif ((curdist_list->cred_assngd - need) >=\r\ncurdist_list->cred_min) {\r\nath6kl_credit_reduce(cred_info, curdist_list,\r\ncurdist_list->cred_assngd - need);\r\nif (cred_info->cur_free_credits >=\r\nep_dist->seek_cred)\r\nbreak;\r\n}\r\nif (curdist_list->endpoint == ENDPOINT_0)\r\nbreak;\r\n}\r\ncredits = min(cred_info->cur_free_credits, ep_dist->seek_cred);\r\nout:\r\nif (credits)\r\nath6kl_credit_deposit(cred_info, ep_dist, credits);\r\nep_dist->seek_cred = 0;\r\n}\r\nstatic void ath6kl_credit_redistribute(struct ath6kl_htc_credit_info *info,\r\nstruct list_head *ep_dist_list)\r\n{\r\nstruct htc_endpoint_credit_dist *curdist_list;\r\nlist_for_each_entry(curdist_list, ep_dist_list, list) {\r\nif (curdist_list->endpoint == ENDPOINT_0)\r\ncontinue;\r\nif ((curdist_list->svc_id == WMI_DATA_BK_SVC) ||\r\n(curdist_list->svc_id == WMI_DATA_BE_SVC))\r\ncurdist_list->dist_flags |= HTC_EP_ACTIVE;\r\nif ((curdist_list->svc_id != WMI_CONTROL_SVC) &&\r\n!(curdist_list->dist_flags & HTC_EP_ACTIVE)) {\r\nif (curdist_list->txq_depth == 0)\r\nath6kl_credit_reduce(info, curdist_list, 0);\r\nelse\r\nath6kl_credit_reduce(info,\r\ncurdist_list,\r\ncurdist_list->cred_min);\r\n}\r\n}\r\n}\r\nstatic void ath6kl_credit_distribute(struct ath6kl_htc_credit_info *cred_info,\r\nstruct list_head *ep_dist_list,\r\nenum htc_credit_dist_reason reason)\r\n{\r\nswitch (reason) {\r\ncase HTC_CREDIT_DIST_SEND_COMPLETE:\r\nath6kl_credit_update(cred_info, ep_dist_list);\r\nbreak;\r\ncase HTC_CREDIT_DIST_ACTIVITY_CHANGE:\r\nath6kl_credit_redistribute(cred_info, ep_dist_list);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nWARN_ON(cred_info->cur_free_credits > cred_info->total_avail_credits);\r\nWARN_ON(cred_info->cur_free_credits < 0);\r\n}\r\nstatic void ath6kl_htc_tx_buf_align(u8 **buf, unsigned long len)\r\n{\r\nu8 *align_addr;\r\nif (!IS_ALIGNED((unsigned long) *buf, 4)) {\r\nalign_addr = PTR_ALIGN(*buf - 4, 4);\r\nmemmove(align_addr, *buf, len);\r\n*buf = align_addr;\r\n}\r\n}\r\nstatic void ath6kl_htc_tx_prep_pkt(struct htc_packet *packet, u8 flags,\r\nint ctrl0, int ctrl1)\r\n{\r\nstruct htc_frame_hdr *hdr;\r\npacket->buf -= HTC_HDR_LENGTH;\r\nhdr = (struct htc_frame_hdr *)packet->buf;\r\nput_unaligned((u16)packet->act_len, &hdr->payld_len);\r\nhdr->flags = flags;\r\nhdr->eid = packet->endpoint;\r\nhdr->ctrl[0] = ctrl0;\r\nhdr->ctrl[1] = ctrl1;\r\n}\r\nstatic void htc_reclaim_txctrl_buf(struct htc_target *target,\r\nstruct htc_packet *pkt)\r\n{\r\nspin_lock_bh(&target->htc_lock);\r\nlist_add_tail(&pkt->list, &target->free_ctrl_txbuf);\r\nspin_unlock_bh(&target->htc_lock);\r\n}\r\nstatic struct htc_packet *htc_get_control_buf(struct htc_target *target,\r\nbool tx)\r\n{\r\nstruct htc_packet *packet = NULL;\r\nstruct list_head *buf_list;\r\nbuf_list = tx ? &target->free_ctrl_txbuf : &target->free_ctrl_rxbuf;\r\nspin_lock_bh(&target->htc_lock);\r\nif (list_empty(buf_list)) {\r\nspin_unlock_bh(&target->htc_lock);\r\nreturn NULL;\r\n}\r\npacket = list_first_entry(buf_list, struct htc_packet, list);\r\nlist_del(&packet->list);\r\nspin_unlock_bh(&target->htc_lock);\r\nif (tx)\r\npacket->buf = packet->buf_start + HTC_HDR_LENGTH;\r\nreturn packet;\r\n}\r\nstatic void htc_tx_comp_update(struct htc_target *target,\r\nstruct htc_endpoint *endpoint,\r\nstruct htc_packet *packet)\r\n{\r\npacket->completion = NULL;\r\npacket->buf += HTC_HDR_LENGTH;\r\nif (!packet->status)\r\nreturn;\r\nath6kl_err("req failed (status:%d, ep:%d, len:%d creds:%d)\n",\r\npacket->status, packet->endpoint, packet->act_len,\r\npacket->info.tx.cred_used);\r\nspin_lock_bh(&target->tx_lock);\r\nendpoint->cred_dist.cred_to_dist +=\r\npacket->info.tx.cred_used;\r\nendpoint->cred_dist.txq_depth = get_queue_depth(&endpoint->txq);\r\nath6kl_dbg(ATH6KL_DBG_HTC, "htc tx ctxt 0x%p dist 0x%p\n",\r\ntarget->credit_info, &target->cred_dist_list);\r\nath6kl_credit_distribute(target->credit_info,\r\n&target->cred_dist_list,\r\nHTC_CREDIT_DIST_SEND_COMPLETE);\r\nspin_unlock_bh(&target->tx_lock);\r\n}\r\nstatic void htc_tx_complete(struct htc_endpoint *endpoint,\r\nstruct list_head *txq)\r\n{\r\nif (list_empty(txq))\r\nreturn;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc tx complete ep %d pkts %d\n",\r\nendpoint->eid, get_queue_depth(txq));\r\nath6kl_tx_complete(endpoint->target, txq);\r\n}\r\nstatic void htc_tx_comp_handler(struct htc_target *target,\r\nstruct htc_packet *packet)\r\n{\r\nstruct htc_endpoint *endpoint = &target->endpoint[packet->endpoint];\r\nstruct list_head container;\r\nath6kl_dbg(ATH6KL_DBG_HTC, "htc tx complete seqno %d\n",\r\npacket->info.tx.seqno);\r\nhtc_tx_comp_update(target, endpoint, packet);\r\nINIT_LIST_HEAD(&container);\r\nlist_add_tail(&packet->list, &container);\r\nhtc_tx_complete(endpoint, &container);\r\n}\r\nstatic void htc_async_tx_scat_complete(struct htc_target *target,\r\nstruct hif_scatter_req *scat_req)\r\n{\r\nstruct htc_endpoint *endpoint;\r\nstruct htc_packet *packet;\r\nstruct list_head tx_compq;\r\nint i;\r\nINIT_LIST_HEAD(&tx_compq);\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc tx scat complete len %d entries %d\n",\r\nscat_req->len, scat_req->scat_entries);\r\nif (scat_req->status)\r\nath6kl_err("send scatter req failed: %d\n", scat_req->status);\r\npacket = scat_req->scat_list[0].packet;\r\nendpoint = &target->endpoint[packet->endpoint];\r\nfor (i = 0; i < scat_req->scat_entries; i++) {\r\npacket = scat_req->scat_list[i].packet;\r\nif (!packet) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\npacket->status = scat_req->status;\r\nhtc_tx_comp_update(target, endpoint, packet);\r\nlist_add_tail(&packet->list, &tx_compq);\r\n}\r\nhif_scatter_req_add(target->dev->ar, scat_req);\r\nhtc_tx_complete(endpoint, &tx_compq);\r\n}\r\nstatic int ath6kl_htc_tx_issue(struct htc_target *target,\r\nstruct htc_packet *packet)\r\n{\r\nint status;\r\nbool sync = false;\r\nu32 padded_len, send_len;\r\nif (!packet->completion)\r\nsync = true;\r\nsend_len = packet->act_len + HTC_HDR_LENGTH;\r\npadded_len = CALC_TXRX_PADDED_LEN(target, send_len);\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc tx issue len %d seqno %d padded_len %d mbox 0x%X %s\n",\r\nsend_len, packet->info.tx.seqno, padded_len,\r\ntarget->dev->ar->mbox_info.htc_addr,\r\nsync ? "sync" : "async");\r\nif (sync) {\r\nstatus = hif_read_write_sync(target->dev->ar,\r\ntarget->dev->ar->mbox_info.htc_addr,\r\npacket->buf, padded_len,\r\nHIF_WR_SYNC_BLOCK_INC);\r\npacket->status = status;\r\npacket->buf += HTC_HDR_LENGTH;\r\n} else\r\nstatus = hif_write_async(target->dev->ar,\r\ntarget->dev->ar->mbox_info.htc_addr,\r\npacket->buf, padded_len,\r\nHIF_WR_ASYNC_BLOCK_INC, packet);\r\nreturn status;\r\n}\r\nstatic int htc_check_credits(struct htc_target *target,\r\nstruct htc_endpoint *ep, u8 *flags,\r\nenum htc_endpoint_id eid, unsigned int len,\r\nint *req_cred)\r\n{\r\n*req_cred = (len > target->tgt_cred_sz) ?\r\nDIV_ROUND_UP(len, target->tgt_cred_sz) : 1;\r\nath6kl_dbg(ATH6KL_DBG_CREDIT, "credit check need %d got %d\n",\r\n*req_cred, ep->cred_dist.credits);\r\nif (ep->cred_dist.credits < *req_cred) {\r\nif (eid == ENDPOINT_0)\r\nreturn -EINVAL;\r\nep->cred_dist.seek_cred = *req_cred - ep->cred_dist.credits;\r\nath6kl_credit_seek(target->credit_info, &ep->cred_dist);\r\nep->cred_dist.seek_cred = 0;\r\nif (ep->cred_dist.credits < *req_cred) {\r\nath6kl_dbg(ATH6KL_DBG_CREDIT,\r\n"credit not found for ep %d\n",\r\neid);\r\nreturn -EINVAL;\r\n}\r\n}\r\nep->cred_dist.credits -= *req_cred;\r\nep->ep_st.cred_cosumd += *req_cred;\r\nif (ep->cred_dist.credits < ep->cred_dist.cred_per_msg) {\r\nep->cred_dist.seek_cred =\r\nep->cred_dist.cred_per_msg - ep->cred_dist.credits;\r\nath6kl_credit_seek(target->credit_info, &ep->cred_dist);\r\nif (ep->cred_dist.credits < ep->cred_dist.cred_per_msg) {\r\n*flags |= HTC_FLAGS_NEED_CREDIT_UPDATE;\r\nep->ep_st.cred_low_indicate += 1;\r\nath6kl_dbg(ATH6KL_DBG_CREDIT,\r\n"credit we need credits asap\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ath6kl_htc_tx_pkts_get(struct htc_target *target,\r\nstruct htc_endpoint *endpoint,\r\nstruct list_head *queue)\r\n{\r\nint req_cred;\r\nu8 flags;\r\nstruct htc_packet *packet;\r\nunsigned int len;\r\nwhile (true) {\r\nflags = 0;\r\nif (list_empty(&endpoint->txq))\r\nbreak;\r\npacket = list_first_entry(&endpoint->txq, struct htc_packet,\r\nlist);\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc tx got packet 0x%p queue depth %d\n",\r\npacket, get_queue_depth(&endpoint->txq));\r\nlen = CALC_TXRX_PADDED_LEN(target,\r\npacket->act_len + HTC_HDR_LENGTH);\r\nif (htc_check_credits(target, endpoint, &flags,\r\npacket->endpoint, len, &req_cred))\r\nbreak;\r\npacket = list_first_entry(&endpoint->txq, struct htc_packet,\r\nlist);\r\nlist_move_tail(&packet->list, queue);\r\npacket->info.tx.cred_used = req_cred;\r\npacket->completion = htc_tx_comp_handler;\r\npacket->context = target;\r\nendpoint->ep_st.tx_issued += 1;\r\npacket->info.tx.flags = flags;\r\npacket->info.tx.seqno = endpoint->seqno;\r\nendpoint->seqno++;\r\n}\r\n}\r\nstatic int htc_get_credit_padding(unsigned int cred_sz, int *len,\r\nstruct htc_endpoint *ep)\r\n{\r\nint rem_cred, cred_pad;\r\nrem_cred = *len % cred_sz;\r\nif (!rem_cred)\r\nreturn 0;\r\nif (!(ep->conn_flags & HTC_FLGS_TX_BNDL_PAD_EN))\r\nreturn -1;\r\ncred_pad = *len < cred_sz ? (cred_sz - *len) : rem_cred;\r\nif ((cred_pad > 0) && (cred_pad <= 255))\r\n*len += cred_pad;\r\nelse\r\nreturn -1;\r\nreturn cred_pad;\r\n}\r\nstatic int ath6kl_htc_tx_setup_scat_list(struct htc_target *target,\r\nstruct htc_endpoint *endpoint,\r\nstruct hif_scatter_req *scat_req,\r\nint n_scat,\r\nstruct list_head *queue)\r\n{\r\nstruct htc_packet *packet;\r\nint i, len, rem_scat, cred_pad;\r\nint status = 0;\r\nu8 flags;\r\nrem_scat = target->max_tx_bndl_sz;\r\nfor (i = 0; i < n_scat; i++) {\r\nscat_req->scat_list[i].packet = NULL;\r\nif (list_empty(queue))\r\nbreak;\r\npacket = list_first_entry(queue, struct htc_packet, list);\r\nlen = CALC_TXRX_PADDED_LEN(target,\r\npacket->act_len + HTC_HDR_LENGTH);\r\ncred_pad = htc_get_credit_padding(target->tgt_cred_sz,\r\n&len, endpoint);\r\nif (cred_pad < 0 || rem_scat < len) {\r\nstatus = -ENOSPC;\r\nbreak;\r\n}\r\nrem_scat -= len;\r\nlist_del(&packet->list);\r\nscat_req->scat_list[i].packet = packet;\r\nflags = packet->info.tx.flags | HTC_FLAGS_SEND_BUNDLE;\r\nath6kl_htc_tx_prep_pkt(packet, flags,\r\ncred_pad, packet->info.tx.seqno);\r\nath6kl_htc_tx_buf_align(&packet->buf,\r\npacket->act_len + HTC_HDR_LENGTH);\r\nscat_req->scat_list[i].buf = packet->buf;\r\nscat_req->scat_list[i].len = len;\r\nscat_req->len += len;\r\nscat_req->scat_entries++;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc tx adding (%d) pkt 0x%p seqno %d len %d remaining %d\n",\r\ni, packet, packet->info.tx.seqno, len, rem_scat);\r\n}\r\nif (scat_req->scat_entries < HTC_MIN_HTC_MSGS_TO_BUNDLE) {\r\nfor (i = scat_req->scat_entries - 1; i >= 0; i--) {\r\npacket = scat_req->scat_list[i].packet;\r\nif (packet) {\r\npacket->buf += HTC_HDR_LENGTH;\r\nlist_add(&packet->list, queue);\r\n}\r\n}\r\nreturn -EAGAIN;\r\n}\r\nreturn status;\r\n}\r\nstatic void ath6kl_htc_tx_bundle(struct htc_endpoint *endpoint,\r\nstruct list_head *queue,\r\nint *sent_bundle, int *n_bundle_pkts)\r\n{\r\nstruct htc_target *target = endpoint->target;\r\nstruct hif_scatter_req *scat_req = NULL;\r\nint n_scat, n_sent_bundle = 0, tot_pkts_bundle = 0;\r\nint status;\r\nu32 txb_mask;\r\nu8 ac = WMM_NUM_AC;\r\nif ((HTC_CTRL_RSVD_SVC != endpoint->svc_id) &&\r\n(WMI_CONTROL_SVC != endpoint->svc_id))\r\nac = target->dev->ar->ep2ac_map[endpoint->eid];\r\nwhile (true) {\r\nstatus = 0;\r\nn_scat = get_queue_depth(queue);\r\nn_scat = min(n_scat, target->msg_per_bndl_max);\r\nif (n_scat < HTC_MIN_HTC_MSGS_TO_BUNDLE)\r\nbreak;\r\nscat_req = hif_scatter_req_get(target->dev->ar);\r\nif (!scat_req) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc tx no more scatter resources\n");\r\nbreak;\r\n}\r\nif ((ac < WMM_NUM_AC) && (ac != WMM_AC_BK)) {\r\nif (WMM_AC_BE == ac)\r\ntxb_mask = (1 << WMM_AC_BK);\r\nelse\r\ntxb_mask = ((1 << ac) - 1);\r\nif (scat_req->scat_q_depth < ATH6KL_SCATTER_REQS)\r\ntarget->tx_bndl_mask &= ~txb_mask;\r\nelse\r\ntarget->tx_bndl_mask |= txb_mask;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_HTC, "htc tx pkts to scatter: %d\n",\r\nn_scat);\r\nscat_req->len = 0;\r\nscat_req->scat_entries = 0;\r\nstatus = ath6kl_htc_tx_setup_scat_list(target, endpoint,\r\nscat_req, n_scat,\r\nqueue);\r\nif (status == -EAGAIN) {\r\nhif_scatter_req_add(target->dev->ar, scat_req);\r\nbreak;\r\n}\r\nscat_req->complete = htc_async_tx_scat_complete;\r\nn_sent_bundle++;\r\ntot_pkts_bundle += scat_req->scat_entries;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc tx scatter bytes %d entries %d\n",\r\nscat_req->len, scat_req->scat_entries);\r\nath6kl_hif_submit_scat_req(target->dev, scat_req, false);\r\nif (status)\r\nbreak;\r\n}\r\n*sent_bundle = n_sent_bundle;\r\n*n_bundle_pkts = tot_pkts_bundle;\r\nath6kl_dbg(ATH6KL_DBG_HTC, "htc tx bundle sent %d pkts\n",\r\nn_sent_bundle);\r\nreturn;\r\n}\r\nstatic void ath6kl_htc_tx_from_queue(struct htc_target *target,\r\nstruct htc_endpoint *endpoint)\r\n{\r\nstruct list_head txq;\r\nstruct htc_packet *packet;\r\nint bundle_sent;\r\nint n_pkts_bundle;\r\nu8 ac = WMM_NUM_AC;\r\nint status;\r\nspin_lock_bh(&target->tx_lock);\r\nendpoint->tx_proc_cnt++;\r\nif (endpoint->tx_proc_cnt > 1) {\r\nendpoint->tx_proc_cnt--;\r\nspin_unlock_bh(&target->tx_lock);\r\nath6kl_dbg(ATH6KL_DBG_HTC, "htc tx busy\n");\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&txq);\r\nif ((HTC_CTRL_RSVD_SVC != endpoint->svc_id) &&\r\n(WMI_CONTROL_SVC != endpoint->svc_id))\r\nac = target->dev->ar->ep2ac_map[endpoint->eid];\r\nwhile (true) {\r\nif (list_empty(&endpoint->txq))\r\nbreak;\r\nath6kl_htc_tx_pkts_get(target, endpoint, &txq);\r\nif (list_empty(&txq))\r\nbreak;\r\nspin_unlock_bh(&target->tx_lock);\r\nbundle_sent = 0;\r\nn_pkts_bundle = 0;\r\nwhile (true) {\r\nif ((target->tx_bndl_mask) &&\r\n(get_queue_depth(&txq) >=\r\nHTC_MIN_HTC_MSGS_TO_BUNDLE)) {\r\nint temp1 = 0, temp2 = 0;\r\nif (target->tx_bndl_mask & (1 << ac)) {\r\nath6kl_htc_tx_bundle(endpoint, &txq,\r\n&temp1, &temp2);\r\nbundle_sent += temp1;\r\nn_pkts_bundle += temp2;\r\n}\r\n}\r\nif (list_empty(&txq))\r\nbreak;\r\npacket = list_first_entry(&txq, struct htc_packet,\r\nlist);\r\nlist_del(&packet->list);\r\nath6kl_htc_tx_prep_pkt(packet, packet->info.tx.flags,\r\n0, packet->info.tx.seqno);\r\nstatus = ath6kl_htc_tx_issue(target, packet);\r\nif (status) {\r\npacket->status = status;\r\npacket->completion(packet->context, packet);\r\n}\r\n}\r\nspin_lock_bh(&target->tx_lock);\r\nendpoint->ep_st.tx_bundles += bundle_sent;\r\nendpoint->ep_st.tx_pkt_bundled += n_pkts_bundle;\r\nif (!bundle_sent) {\r\nif (!(target->tx_bndl_mask & (1 << ac)) &&\r\n(ac < WMM_NUM_AC)) {\r\nif (++target->ac_tx_count[ac] >=\r\nTX_RESUME_BUNDLE_THRESHOLD) {\r\ntarget->ac_tx_count[ac] = 0;\r\ntarget->tx_bndl_mask |= (1 << ac);\r\n}\r\n}\r\n} else {\r\nif (ac < WMM_NUM_AC)\r\ntarget->ac_tx_count[ac] = 0;\r\n}\r\n}\r\nendpoint->tx_proc_cnt = 0;\r\nspin_unlock_bh(&target->tx_lock);\r\n}\r\nstatic bool ath6kl_htc_tx_try(struct htc_target *target,\r\nstruct htc_endpoint *endpoint,\r\nstruct htc_packet *tx_pkt)\r\n{\r\nstruct htc_ep_callbacks ep_cb;\r\nint txq_depth;\r\nbool overflow = false;\r\nep_cb = endpoint->ep_cb;\r\nspin_lock_bh(&target->tx_lock);\r\ntxq_depth = get_queue_depth(&endpoint->txq);\r\nspin_unlock_bh(&target->tx_lock);\r\nif (txq_depth >= endpoint->max_txq_depth)\r\noverflow = true;\r\nif (overflow)\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc tx overflow ep %d depth %d max %d\n",\r\nendpoint->eid, txq_depth,\r\nendpoint->max_txq_depth);\r\nif (overflow && ep_cb.tx_full) {\r\nif (ep_cb.tx_full(endpoint->target, tx_pkt) ==\r\nHTC_SEND_FULL_DROP) {\r\nendpoint->ep_st.tx_dropped += 1;\r\nreturn false;\r\n}\r\n}\r\nspin_lock_bh(&target->tx_lock);\r\nlist_add_tail(&tx_pkt->list, &endpoint->txq);\r\nspin_unlock_bh(&target->tx_lock);\r\nath6kl_htc_tx_from_queue(target, endpoint);\r\nreturn true;\r\n}\r\nstatic void htc_chk_ep_txq(struct htc_target *target)\r\n{\r\nstruct htc_endpoint *endpoint;\r\nstruct htc_endpoint_credit_dist *cred_dist;\r\nlist_for_each_entry(cred_dist, &target->cred_dist_list, list) {\r\nendpoint = cred_dist->htc_ep;\r\nspin_lock_bh(&target->tx_lock);\r\nif (!list_empty(&endpoint->txq)) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc creds ep %d credits %d pkts %d\n",\r\ncred_dist->endpoint,\r\nendpoint->cred_dist.credits,\r\nget_queue_depth(&endpoint->txq));\r\nspin_unlock_bh(&target->tx_lock);\r\nath6kl_htc_tx_from_queue(target, endpoint);\r\nspin_lock_bh(&target->tx_lock);\r\n}\r\nspin_unlock_bh(&target->tx_lock);\r\n}\r\n}\r\nstatic int htc_setup_tx_complete(struct htc_target *target)\r\n{\r\nstruct htc_packet *send_pkt = NULL;\r\nint status;\r\nsend_pkt = htc_get_control_buf(target, true);\r\nif (!send_pkt)\r\nreturn -ENOMEM;\r\nif (target->htc_tgt_ver >= HTC_VERSION_2P1) {\r\nstruct htc_setup_comp_ext_msg *setup_comp_ext;\r\nu32 flags = 0;\r\nsetup_comp_ext =\r\n(struct htc_setup_comp_ext_msg *)send_pkt->buf;\r\nmemset(setup_comp_ext, 0, sizeof(*setup_comp_ext));\r\nsetup_comp_ext->msg_id =\r\ncpu_to_le16(HTC_MSG_SETUP_COMPLETE_EX_ID);\r\nif (target->msg_per_bndl_max > 0) {\r\nflags |= HTC_SETUP_COMP_FLG_RX_BNDL_EN;\r\nsetup_comp_ext->msg_per_rxbndl =\r\ntarget->msg_per_bndl_max;\r\n}\r\nmemcpy(&setup_comp_ext->flags, &flags,\r\nsizeof(setup_comp_ext->flags));\r\nset_htc_pkt_info(send_pkt, NULL, (u8 *) setup_comp_ext,\r\nsizeof(struct htc_setup_comp_ext_msg),\r\nENDPOINT_0, HTC_SERVICE_TX_PACKET_TAG);\r\n} else {\r\nstruct htc_setup_comp_msg *setup_comp;\r\nsetup_comp = (struct htc_setup_comp_msg *)send_pkt->buf;\r\nmemset(setup_comp, 0, sizeof(struct htc_setup_comp_msg));\r\nsetup_comp->msg_id = cpu_to_le16(HTC_MSG_SETUP_COMPLETE_ID);\r\nset_htc_pkt_info(send_pkt, NULL, (u8 *) setup_comp,\r\nsizeof(struct htc_setup_comp_msg),\r\nENDPOINT_0, HTC_SERVICE_TX_PACKET_TAG);\r\n}\r\nsend_pkt->completion = NULL;\r\nath6kl_htc_tx_prep_pkt(send_pkt, 0, 0, 0);\r\nstatus = ath6kl_htc_tx_issue(target, send_pkt);\r\nif (send_pkt != NULL)\r\nhtc_reclaim_txctrl_buf(target, send_pkt);\r\nreturn status;\r\n}\r\nstatic void ath6kl_htc_set_credit_dist(struct htc_target *target,\r\nstruct ath6kl_htc_credit_info *credit_info,\r\nu16 srvc_pri_order[], int list_len)\r\n{\r\nstruct htc_endpoint *endpoint;\r\nint i, ep;\r\ntarget->credit_info = credit_info;\r\nlist_add_tail(&target->endpoint[ENDPOINT_0].cred_dist.list,\r\n&target->cred_dist_list);\r\nfor (i = 0; i < list_len; i++) {\r\nfor (ep = ENDPOINT_1; ep < ENDPOINT_MAX; ep++) {\r\nendpoint = &target->endpoint[ep];\r\nif (endpoint->svc_id == srvc_pri_order[i]) {\r\nlist_add_tail(&endpoint->cred_dist.list,\r\n&target->cred_dist_list);\r\nbreak;\r\n}\r\n}\r\nif (ep >= ENDPOINT_MAX) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int ath6kl_htc_mbox_tx(struct htc_target *target,\r\nstruct htc_packet *packet)\r\n{\r\nstruct htc_endpoint *endpoint;\r\nstruct list_head queue;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc tx ep id %d buf 0x%p len %d\n",\r\npacket->endpoint, packet->buf, packet->act_len);\r\nif (packet->endpoint >= ENDPOINT_MAX) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nendpoint = &target->endpoint[packet->endpoint];\r\nif (!ath6kl_htc_tx_try(target, endpoint, packet)) {\r\npacket->status = (target->htc_flags & HTC_OP_STATE_STOPPING) ?\r\n-ECANCELED : -ENOSPC;\r\nINIT_LIST_HEAD(&queue);\r\nlist_add(&packet->list, &queue);\r\nhtc_tx_complete(endpoint, &queue);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ath6kl_htc_mbox_flush_txep(struct htc_target *target,\r\nenum htc_endpoint_id eid, u16 tag)\r\n{\r\nstruct htc_packet *packet, *tmp_pkt;\r\nstruct list_head discard_q, container;\r\nstruct htc_endpoint *endpoint = &target->endpoint[eid];\r\nif (!endpoint->svc_id) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&discard_q);\r\nspin_lock_bh(&target->tx_lock);\r\nlist_for_each_entry_safe(packet, tmp_pkt, &endpoint->txq, list) {\r\nif ((tag == HTC_TX_PACKET_TAG_ALL) ||\r\n(tag == packet->info.tx.tag))\r\nlist_move_tail(&packet->list, &discard_q);\r\n}\r\nspin_unlock_bh(&target->tx_lock);\r\nlist_for_each_entry_safe(packet, tmp_pkt, &discard_q, list) {\r\npacket->status = -ECANCELED;\r\nlist_del(&packet->list);\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc tx flushing pkt 0x%p len %d ep %d tag 0x%x\n",\r\npacket, packet->act_len,\r\npacket->endpoint, packet->info.tx.tag);\r\nINIT_LIST_HEAD(&container);\r\nlist_add_tail(&packet->list, &container);\r\nhtc_tx_complete(endpoint, &container);\r\n}\r\n}\r\nstatic void ath6kl_htc_flush_txep_all(struct htc_target *target)\r\n{\r\nstruct htc_endpoint *endpoint;\r\nint i;\r\ndump_cred_dist_stats(target);\r\nfor (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {\r\nendpoint = &target->endpoint[i];\r\nif (endpoint->svc_id == 0)\r\ncontinue;\r\nath6kl_htc_mbox_flush_txep(target, i, HTC_TX_PACKET_TAG_ALL);\r\n}\r\n}\r\nstatic void ath6kl_htc_mbox_activity_changed(struct htc_target *target,\r\nenum htc_endpoint_id eid,\r\nbool active)\r\n{\r\nstruct htc_endpoint *endpoint = &target->endpoint[eid];\r\nbool dist = false;\r\nif (endpoint->svc_id == 0) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nspin_lock_bh(&target->tx_lock);\r\nif (active) {\r\nif (!(endpoint->cred_dist.dist_flags & HTC_EP_ACTIVE)) {\r\nendpoint->cred_dist.dist_flags |= HTC_EP_ACTIVE;\r\ndist = true;\r\n}\r\n} else {\r\nif (endpoint->cred_dist.dist_flags & HTC_EP_ACTIVE) {\r\nendpoint->cred_dist.dist_flags &= ~HTC_EP_ACTIVE;\r\ndist = true;\r\n}\r\n}\r\nif (dist) {\r\nendpoint->cred_dist.txq_depth =\r\nget_queue_depth(&endpoint->txq);\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc tx activity ctxt 0x%p dist 0x%p\n",\r\ntarget->credit_info, &target->cred_dist_list);\r\nath6kl_credit_distribute(target->credit_info,\r\n&target->cred_dist_list,\r\nHTC_CREDIT_DIST_ACTIVITY_CHANGE);\r\n}\r\nspin_unlock_bh(&target->tx_lock);\r\nif (dist && !active)\r\nhtc_chk_ep_txq(target);\r\n}\r\nstatic inline void ath6kl_htc_rx_update_stats(struct htc_endpoint *endpoint,\r\nint n_look_ahds)\r\n{\r\nendpoint->ep_st.rx_pkts++;\r\nif (n_look_ahds == 1)\r\nendpoint->ep_st.rx_lkahds++;\r\nelse if (n_look_ahds > 1)\r\nendpoint->ep_st.rx_bundle_lkahd++;\r\n}\r\nstatic inline bool htc_valid_rx_frame_len(struct htc_target *target,\r\nenum htc_endpoint_id eid, int len)\r\n{\r\nreturn (eid == target->dev->ar->ctrl_ep) ?\r\nlen <= ATH6KL_BUFFER_SIZE : len <= ATH6KL_AMSDU_BUFFER_SIZE;\r\n}\r\nstatic int htc_add_rxbuf(struct htc_target *target, struct htc_packet *packet)\r\n{\r\nstruct list_head queue;\r\nINIT_LIST_HEAD(&queue);\r\nlist_add_tail(&packet->list, &queue);\r\nreturn ath6kl_htc_mbox_add_rxbuf_multiple(target, &queue);\r\n}\r\nstatic void htc_reclaim_rxbuf(struct htc_target *target,\r\nstruct htc_packet *packet,\r\nstruct htc_endpoint *ep)\r\n{\r\nif (packet->info.rx.rx_flags & HTC_RX_PKT_NO_RECYCLE) {\r\nhtc_rxpkt_reset(packet);\r\npacket->status = -ECANCELED;\r\nep->ep_cb.rx(ep->target, packet);\r\n} else {\r\nhtc_rxpkt_reset(packet);\r\nhtc_add_rxbuf((void *)(target), packet);\r\n}\r\n}\r\nstatic void reclaim_rx_ctrl_buf(struct htc_target *target,\r\nstruct htc_packet *packet)\r\n{\r\nspin_lock_bh(&target->htc_lock);\r\nlist_add_tail(&packet->list, &target->free_ctrl_rxbuf);\r\nspin_unlock_bh(&target->htc_lock);\r\n}\r\nstatic int ath6kl_htc_rx_packet(struct htc_target *target,\r\nstruct htc_packet *packet,\r\nu32 rx_len)\r\n{\r\nstruct ath6kl_device *dev = target->dev;\r\nu32 padded_len;\r\nint status;\r\npadded_len = CALC_TXRX_PADDED_LEN(target, rx_len);\r\nif (padded_len > packet->buf_len) {\r\nath6kl_err("not enough receive space for packet - padlen %d recvlen %d bufferlen %d\n",\r\npadded_len, rx_len, packet->buf_len);\r\nreturn -ENOMEM;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc rx 0x%p hdr 0x%x len %d mbox 0x%x\n",\r\npacket, packet->info.rx.exp_hdr,\r\npadded_len, dev->ar->mbox_info.htc_addr);\r\nstatus = hif_read_write_sync(dev->ar,\r\ndev->ar->mbox_info.htc_addr,\r\npacket->buf, padded_len,\r\nHIF_RD_SYNC_BLOCK_FIX);\r\npacket->status = status;\r\nreturn status;\r\n}\r\nstatic void ath6kl_htc_rx_set_indicate(u32 lk_ahd,\r\nstruct htc_endpoint *endpoint,\r\nstruct htc_packet *packet)\r\n{\r\nstruct htc_frame_hdr *htc_hdr = (struct htc_frame_hdr *)&lk_ahd;\r\nif (htc_hdr->eid == packet->endpoint) {\r\nif (!list_empty(&endpoint->rx_bufq))\r\npacket->info.rx.indicat_flags |=\r\nHTC_RX_FLAGS_INDICATE_MORE_PKTS;\r\n}\r\n}\r\nstatic void ath6kl_htc_rx_chk_water_mark(struct htc_endpoint *endpoint)\r\n{\r\nstruct htc_ep_callbacks ep_cb = endpoint->ep_cb;\r\nif (ep_cb.rx_refill_thresh > 0) {\r\nspin_lock_bh(&endpoint->target->rx_lock);\r\nif (get_queue_depth(&endpoint->rx_bufq)\r\n< ep_cb.rx_refill_thresh) {\r\nspin_unlock_bh(&endpoint->target->rx_lock);\r\nep_cb.rx_refill(endpoint->target, endpoint->eid);\r\nreturn;\r\n}\r\nspin_unlock_bh(&endpoint->target->rx_lock);\r\n}\r\n}\r\nstatic int ath6kl_htc_rx_setup(struct htc_target *target,\r\nstruct htc_endpoint *ep,\r\nu32 *lk_ahds, struct list_head *queue, int n_msg)\r\n{\r\nstruct htc_packet *packet;\r\nstruct htc_frame_hdr *htc_hdr = (struct htc_frame_hdr *)lk_ahds;\r\nstruct htc_ep_callbacks ep_cb;\r\nint status = 0, j, full_len;\r\nbool no_recycle;\r\nfull_len = CALC_TXRX_PADDED_LEN(target,\r\nle16_to_cpu(htc_hdr->payld_len) +\r\nsizeof(*htc_hdr));\r\nif (!htc_valid_rx_frame_len(target, ep->eid, full_len)) {\r\nath6kl_warn("Rx buffer requested with invalid length htc_hdr:eid %d, flags 0x%x, len %d\n",\r\nhtc_hdr->eid, htc_hdr->flags,\r\nle16_to_cpu(htc_hdr->payld_len));\r\nreturn -EINVAL;\r\n}\r\nep_cb = ep->ep_cb;\r\nfor (j = 0; j < n_msg; j++) {\r\nno_recycle = false;\r\nif (ep_cb.rx_allocthresh &&\r\n(full_len > ep_cb.rx_alloc_thresh)) {\r\nep->ep_st.rx_alloc_thresh_hit += 1;\r\nep->ep_st.rxalloc_thresh_byte +=\r\nle16_to_cpu(htc_hdr->payld_len);\r\nspin_unlock_bh(&target->rx_lock);\r\nno_recycle = true;\r\npacket = ep_cb.rx_allocthresh(ep->target, ep->eid,\r\nfull_len);\r\nspin_lock_bh(&target->rx_lock);\r\n} else {\r\nif (list_empty(&ep->rx_bufq)) {\r\nif (ep_cb.rx_refill) {\r\nspin_unlock_bh(&target->rx_lock);\r\nep_cb.rx_refill(ep->target, ep->eid);\r\nspin_lock_bh(&target->rx_lock);\r\n}\r\n}\r\nif (list_empty(&ep->rx_bufq))\r\npacket = NULL;\r\nelse {\r\npacket = list_first_entry(&ep->rx_bufq,\r\nstruct htc_packet, list);\r\nlist_del(&packet->list);\r\n}\r\n}\r\nif (!packet) {\r\ntarget->rx_st_flags |= HTC_RECV_WAIT_BUFFERS;\r\ntarget->ep_waiting = ep->eid;\r\nreturn -ENOSPC;\r\n}\r\npacket->info.rx.rx_flags = 0;\r\npacket->info.rx.indicat_flags = 0;\r\npacket->status = 0;\r\nif (no_recycle)\r\npacket->info.rx.rx_flags |= HTC_RX_PKT_NO_RECYCLE;\r\nlist_add_tail(&packet->list, queue);\r\nif (target->htc_flags & HTC_OP_STATE_STOPPING) {\r\nstatus = -ECANCELED;\r\nbreak;\r\n}\r\nif (j) {\r\npacket->info.rx.rx_flags |= HTC_RX_PKT_REFRESH_HDR;\r\npacket->info.rx.exp_hdr = 0xFFFFFFFF;\r\n} else\r\npacket->info.rx.exp_hdr = *lk_ahds;\r\npacket->act_len = le16_to_cpu(htc_hdr->payld_len) +\r\nHTC_HDR_LENGTH;\r\n}\r\nreturn status;\r\n}\r\nstatic int ath6kl_htc_rx_alloc(struct htc_target *target,\r\nu32 lk_ahds[], int msg,\r\nstruct htc_endpoint *endpoint,\r\nstruct list_head *queue)\r\n{\r\nint status = 0;\r\nstruct htc_packet *packet, *tmp_pkt;\r\nstruct htc_frame_hdr *htc_hdr;\r\nint i, n_msg;\r\nspin_lock_bh(&target->rx_lock);\r\nfor (i = 0; i < msg; i++) {\r\nhtc_hdr = (struct htc_frame_hdr *)&lk_ahds[i];\r\nif (htc_hdr->eid >= ENDPOINT_MAX) {\r\nath6kl_err("invalid ep in look-ahead: %d\n",\r\nhtc_hdr->eid);\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nif (htc_hdr->eid != endpoint->eid) {\r\nath6kl_err("invalid ep in look-ahead: %d should be : %d (index:%d)\n",\r\nhtc_hdr->eid, endpoint->eid, i);\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nif (le16_to_cpu(htc_hdr->payld_len) > HTC_MAX_PAYLOAD_LENGTH) {\r\nath6kl_err("payload len %d exceeds max htc : %d !\n",\r\nhtc_hdr->payld_len,\r\n(u32) HTC_MAX_PAYLOAD_LENGTH);\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nif (endpoint->svc_id == 0) {\r\nath6kl_err("ep %d is not connected !\n", htc_hdr->eid);\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nif (htc_hdr->flags & HTC_FLG_RX_BNDL_CNT) {\r\nn_msg = (htc_hdr->flags & HTC_FLG_RX_BNDL_CNT) >>\r\nHTC_FLG_RX_BNDL_CNT_S;\r\nn_msg++;\r\nif (n_msg > target->msg_per_bndl_max) {\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nendpoint->ep_st.rx_bundle_from_hdr += 1;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc rx bundle pkts %d\n",\r\nn_msg);\r\n} else\r\nn_msg = 1;\r\nstatus = ath6kl_htc_rx_setup(target, endpoint, &lk_ahds[i],\r\nqueue, n_msg);\r\nif (status == -ENOSPC) {\r\nspin_unlock_bh(&target->rx_lock);\r\nreturn 0;\r\n}\r\nif (status)\r\nbreak;\r\n}\r\nspin_unlock_bh(&target->rx_lock);\r\nif (status) {\r\nlist_for_each_entry_safe(packet, tmp_pkt, queue, list) {\r\nlist_del(&packet->list);\r\nhtc_reclaim_rxbuf(target, packet,\r\n&target->endpoint[packet->endpoint]);\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic void htc_ctrl_rx(struct htc_target *context, struct htc_packet *packets)\r\n{\r\nif (packets->endpoint != ENDPOINT_0) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nif (packets->status == -ECANCELED) {\r\nreclaim_rx_ctrl_buf(context, packets);\r\nreturn;\r\n}\r\nif (packets->act_len > 0) {\r\nath6kl_err("htc_ctrl_rx, got message with len:%zu\n",\r\npackets->act_len + HTC_HDR_LENGTH);\r\nath6kl_dbg_dump(ATH6KL_DBG_HTC,\r\n"htc rx unexpected endpoint 0 message", "",\r\npackets->buf - HTC_HDR_LENGTH,\r\npackets->act_len + HTC_HDR_LENGTH);\r\n}\r\nhtc_reclaim_rxbuf(context, packets, &context->endpoint[0]);\r\n}\r\nstatic void htc_proc_cred_rpt(struct htc_target *target,\r\nstruct htc_credit_report *rpt,\r\nint n_entries,\r\nenum htc_endpoint_id from_ep)\r\n{\r\nstruct htc_endpoint *endpoint;\r\nint tot_credits = 0, i;\r\nbool dist = false;\r\nspin_lock_bh(&target->tx_lock);\r\nfor (i = 0; i < n_entries; i++, rpt++) {\r\nif (rpt->eid >= ENDPOINT_MAX) {\r\nWARN_ON(1);\r\nspin_unlock_bh(&target->tx_lock);\r\nreturn;\r\n}\r\nendpoint = &target->endpoint[rpt->eid];\r\nath6kl_dbg(ATH6KL_DBG_CREDIT,\r\n"credit report ep %d credits %d\n",\r\nrpt->eid, rpt->credits);\r\nendpoint->ep_st.tx_cred_rpt += 1;\r\nendpoint->ep_st.cred_retnd += rpt->credits;\r\nif (from_ep == rpt->eid) {\r\nendpoint->ep_st.cred_from_rx += rpt->credits;\r\nendpoint->ep_st.cred_rpt_from_rx += 1;\r\n} else if (from_ep == ENDPOINT_0) {\r\nendpoint->ep_st.cred_from_ep0 += rpt->credits;\r\nendpoint->ep_st.cred_rpt_ep0 += 1;\r\n} else {\r\nendpoint->ep_st.cred_from_other += rpt->credits;\r\nendpoint->ep_st.cred_rpt_from_other += 1;\r\n}\r\nif (rpt->eid == ENDPOINT_0)\r\nendpoint->cred_dist.credits += rpt->credits;\r\nelse {\r\nendpoint->cred_dist.cred_to_dist += rpt->credits;\r\ndist = true;\r\n}\r\nendpoint->cred_dist.txq_depth =\r\nget_queue_depth(&endpoint->txq);\r\ntot_credits += rpt->credits;\r\n}\r\nif (dist) {\r\nath6kl_credit_distribute(target->credit_info,\r\n&target->cred_dist_list,\r\nHTC_CREDIT_DIST_SEND_COMPLETE);\r\n}\r\nspin_unlock_bh(&target->tx_lock);\r\nif (tot_credits)\r\nhtc_chk_ep_txq(target);\r\n}\r\nstatic int htc_parse_trailer(struct htc_target *target,\r\nstruct htc_record_hdr *record,\r\nu8 *record_buf, u32 *next_lk_ahds,\r\nenum htc_endpoint_id endpoint,\r\nint *n_lk_ahds)\r\n{\r\nstruct htc_bundle_lkahd_rpt *bundle_lkahd_rpt;\r\nstruct htc_lookahead_report *lk_ahd;\r\nint len;\r\nswitch (record->rec_id) {\r\ncase HTC_RECORD_CREDITS:\r\nlen = record->len / sizeof(struct htc_credit_report);\r\nif (!len) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nhtc_proc_cred_rpt(target,\r\n(struct htc_credit_report *) record_buf,\r\nlen, endpoint);\r\nbreak;\r\ncase HTC_RECORD_LOOKAHEAD:\r\nlen = record->len / sizeof(*lk_ahd);\r\nif (!len) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nlk_ahd = (struct htc_lookahead_report *) record_buf;\r\nif ((lk_ahd->pre_valid == ((~lk_ahd->post_valid) & 0xFF)) &&\r\nnext_lk_ahds) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc rx lk_ahd found pre_valid 0x%x post_valid 0x%x\n",\r\nlk_ahd->pre_valid, lk_ahd->post_valid);\r\nmemcpy((u8 *)&next_lk_ahds[0], lk_ahd->lk_ahd, 4);\r\nath6kl_dbg_dump(ATH6KL_DBG_HTC,\r\n"htc rx next look ahead",\r\n"", next_lk_ahds, 4);\r\n*n_lk_ahds = 1;\r\n}\r\nbreak;\r\ncase HTC_RECORD_LOOKAHEAD_BUNDLE:\r\nlen = record->len / sizeof(*bundle_lkahd_rpt);\r\nif (!len || (len > HTC_HOST_MAX_MSG_PER_BUNDLE)) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nif (next_lk_ahds) {\r\nint i;\r\nbundle_lkahd_rpt =\r\n(struct htc_bundle_lkahd_rpt *) record_buf;\r\nath6kl_dbg_dump(ATH6KL_DBG_HTC, "htc rx bundle lk_ahd",\r\n"", record_buf, record->len);\r\nfor (i = 0; i < len; i++) {\r\nmemcpy((u8 *)&next_lk_ahds[i],\r\nbundle_lkahd_rpt->lk_ahd, 4);\r\nbundle_lkahd_rpt++;\r\n}\r\n*n_lk_ahds = i;\r\n}\r\nbreak;\r\ndefault:\r\nath6kl_err("unhandled record: id:%d len:%d\n",\r\nrecord->rec_id, record->len);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int htc_proc_trailer(struct htc_target *target,\r\nu8 *buf, int len, u32 *next_lk_ahds,\r\nint *n_lk_ahds, enum htc_endpoint_id endpoint)\r\n{\r\nstruct htc_record_hdr *record;\r\nint orig_len;\r\nint status;\r\nu8 *record_buf;\r\nu8 *orig_buf;\r\nath6kl_dbg(ATH6KL_DBG_HTC, "htc rx trailer len %d\n", len);\r\nath6kl_dbg_dump(ATH6KL_DBG_HTC, NULL, "", buf, len);\r\norig_buf = buf;\r\norig_len = len;\r\nstatus = 0;\r\nwhile (len > 0) {\r\nif (len < sizeof(struct htc_record_hdr)) {\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nrecord = (struct htc_record_hdr *) buf;\r\nlen -= sizeof(struct htc_record_hdr);\r\nbuf += sizeof(struct htc_record_hdr);\r\nif (record->len > len) {\r\nath6kl_err("invalid record len: %d (id:%d) buf has: %d bytes left\n",\r\nrecord->len, record->rec_id, len);\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nrecord_buf = buf;\r\nstatus = htc_parse_trailer(target, record, record_buf,\r\nnext_lk_ahds, endpoint, n_lk_ahds);\r\nif (status)\r\nbreak;\r\nbuf += record->len;\r\nlen -= record->len;\r\n}\r\nif (status)\r\nath6kl_dbg_dump(ATH6KL_DBG_HTC, "htc rx bad trailer",\r\n"", orig_buf, orig_len);\r\nreturn status;\r\n}\r\nstatic int ath6kl_htc_rx_process_hdr(struct htc_target *target,\r\nstruct htc_packet *packet,\r\nu32 *next_lkahds, int *n_lkahds)\r\n{\r\nint status = 0;\r\nu16 payload_len;\r\nu32 lk_ahd;\r\nstruct htc_frame_hdr *htc_hdr = (struct htc_frame_hdr *)packet->buf;\r\nif (n_lkahds != NULL)\r\n*n_lkahds = 0;\r\npayload_len = le16_to_cpu(get_unaligned(&htc_hdr->payld_len));\r\nmemcpy((u8 *)&lk_ahd, packet->buf, sizeof(lk_ahd));\r\nif (packet->info.rx.rx_flags & HTC_RX_PKT_REFRESH_HDR) {\r\npacket->info.rx.exp_hdr = lk_ahd;\r\npacket->act_len = payload_len + HTC_HDR_LENGTH;\r\nif (packet->act_len > packet->buf_len) {\r\nath6kl_err("refreshed hdr payload len (%d) in bundled recv is invalid (hdr: 0x%X)\n",\r\npayload_len, lk_ahd);\r\npacket->act_len = min(packet->act_len, packet->buf_len);\r\nstatus = -ENOMEM;\r\ngoto fail_rx;\r\n}\r\nif (packet->endpoint != htc_hdr->eid) {\r\nath6kl_err("refreshed hdr ep (%d) does not match expected ep (%d)\n",\r\nhtc_hdr->eid, packet->endpoint);\r\nstatus = -ENOMEM;\r\ngoto fail_rx;\r\n}\r\n}\r\nif (lk_ahd != packet->info.rx.exp_hdr) {\r\nath6kl_err("%s(): lk_ahd mismatch! (pPkt:0x%p flags:0x%X)\n",\r\n__func__, packet, packet->info.rx.rx_flags);\r\nath6kl_dbg_dump(ATH6KL_DBG_HTC, "htc rx expected lk_ahd",\r\n"", &packet->info.rx.exp_hdr, 4);\r\nath6kl_dbg_dump(ATH6KL_DBG_HTC, "htc rx current header",\r\n"", (u8 *)&lk_ahd, sizeof(lk_ahd));\r\nstatus = -ENOMEM;\r\ngoto fail_rx;\r\n}\r\nif (htc_hdr->flags & HTC_FLG_RX_TRAILER) {\r\nif (htc_hdr->ctrl[0] < sizeof(struct htc_record_hdr) ||\r\nhtc_hdr->ctrl[0] > payload_len) {\r\nath6kl_err("%s(): invalid hdr (payload len should be :%d, CB[0] is:%d)\n",\r\n__func__, payload_len, htc_hdr->ctrl[0]);\r\nstatus = -ENOMEM;\r\ngoto fail_rx;\r\n}\r\nif (packet->info.rx.rx_flags & HTC_RX_PKT_IGNORE_LOOKAHEAD) {\r\nnext_lkahds = NULL;\r\nn_lkahds = NULL;\r\n}\r\nstatus = htc_proc_trailer(target, packet->buf + HTC_HDR_LENGTH\r\n+ payload_len - htc_hdr->ctrl[0],\r\nhtc_hdr->ctrl[0], next_lkahds,\r\nn_lkahds, packet->endpoint);\r\nif (status)\r\ngoto fail_rx;\r\npacket->act_len -= htc_hdr->ctrl[0];\r\n}\r\npacket->buf += HTC_HDR_LENGTH;\r\npacket->act_len -= HTC_HDR_LENGTH;\r\nfail_rx:\r\nif (status)\r\nath6kl_dbg_dump(ATH6KL_DBG_HTC, "htc rx bad packet",\r\n"", packet->buf, packet->act_len);\r\nreturn status;\r\n}\r\nstatic void ath6kl_htc_rx_complete(struct htc_endpoint *endpoint,\r\nstruct htc_packet *packet)\r\n{\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc rx complete ep %d packet 0x%p\n",\r\nendpoint->eid, packet);\r\nendpoint->ep_cb.rx(endpoint->target, packet);\r\n}\r\nstatic int ath6kl_htc_rx_bundle(struct htc_target *target,\r\nstruct list_head *rxq,\r\nstruct list_head *sync_compq,\r\nint *n_pkt_fetched, bool part_bundle)\r\n{\r\nstruct hif_scatter_req *scat_req;\r\nstruct htc_packet *packet;\r\nint rem_space = target->max_rx_bndl_sz;\r\nint n_scat_pkt, status = 0, i, len;\r\nn_scat_pkt = get_queue_depth(rxq);\r\nn_scat_pkt = min(n_scat_pkt, target->msg_per_bndl_max);\r\nif ((get_queue_depth(rxq) - n_scat_pkt) > 0) {\r\npart_bundle = true;\r\nath6kl_warn("%s(): partial bundle detected num:%d , %d\n",\r\n__func__, get_queue_depth(rxq), n_scat_pkt);\r\n}\r\nlen = 0;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc rx bundle depth %d pkts %d\n",\r\nget_queue_depth(rxq), n_scat_pkt);\r\nscat_req = hif_scatter_req_get(target->dev->ar);\r\nif (scat_req == NULL)\r\ngoto fail_rx_pkt;\r\nfor (i = 0; i < n_scat_pkt; i++) {\r\nint pad_len;\r\npacket = list_first_entry(rxq, struct htc_packet, list);\r\nlist_del(&packet->list);\r\npad_len = CALC_TXRX_PADDED_LEN(target,\r\npacket->act_len);\r\nif ((rem_space - pad_len) < 0) {\r\nlist_add(&packet->list, rxq);\r\nbreak;\r\n}\r\nrem_space -= pad_len;\r\nif (part_bundle || (i < (n_scat_pkt - 1)))\r\npacket->info.rx.rx_flags |=\r\nHTC_RX_PKT_IGNORE_LOOKAHEAD;\r\nscat_req->scat_list[i].buf = packet->buf;\r\nscat_req->scat_list[i].len = pad_len;\r\npacket->info.rx.rx_flags |= HTC_RX_PKT_PART_OF_BUNDLE;\r\nlist_add_tail(&packet->list, sync_compq);\r\nWARN_ON(!scat_req->scat_list[i].len);\r\nlen += scat_req->scat_list[i].len;\r\n}\r\nscat_req->len = len;\r\nscat_req->scat_entries = i;\r\nstatus = ath6kl_hif_submit_scat_req(target->dev, scat_req, true);\r\nif (!status)\r\n*n_pkt_fetched = i;\r\nhif_scatter_req_add(target->dev->ar, scat_req);\r\nfail_rx_pkt:\r\nreturn status;\r\n}\r\nstatic int ath6kl_htc_rx_process_packets(struct htc_target *target,\r\nstruct list_head *comp_pktq,\r\nu32 lk_ahds[],\r\nint *n_lk_ahd)\r\n{\r\nstruct htc_packet *packet, *tmp_pkt;\r\nstruct htc_endpoint *ep;\r\nint status = 0;\r\nlist_for_each_entry_safe(packet, tmp_pkt, comp_pktq, list) {\r\nep = &target->endpoint[packet->endpoint];\r\nstatus = ath6kl_htc_rx_process_hdr(target, packet, lk_ahds,\r\nn_lk_ahd);\r\nif (status)\r\nreturn status;\r\nlist_del(&packet->list);\r\nif (list_empty(comp_pktq)) {\r\nif (*n_lk_ahd > 0)\r\nath6kl_htc_rx_set_indicate(lk_ahds[0],\r\nep, packet);\r\n} else\r\npacket->info.rx.indicat_flags |=\r\nHTC_RX_FLAGS_INDICATE_MORE_PKTS;\r\nath6kl_htc_rx_update_stats(ep, *n_lk_ahd);\r\nif (packet->info.rx.rx_flags & HTC_RX_PKT_PART_OF_BUNDLE)\r\nep->ep_st.rx_bundl += 1;\r\nath6kl_htc_rx_complete(ep, packet);\r\n}\r\nreturn status;\r\n}\r\nstatic int ath6kl_htc_rx_fetch(struct htc_target *target,\r\nstruct list_head *rx_pktq,\r\nstruct list_head *comp_pktq)\r\n{\r\nint fetched_pkts;\r\nbool part_bundle = false;\r\nint status = 0;\r\nstruct list_head tmp_rxq;\r\nstruct htc_packet *packet, *tmp_pkt;\r\nwhile (!list_empty(rx_pktq)) {\r\nfetched_pkts = 0;\r\nINIT_LIST_HEAD(&tmp_rxq);\r\nif (target->rx_bndl_enable && (get_queue_depth(rx_pktq) > 1)) {\r\nstatus = ath6kl_htc_rx_bundle(target, rx_pktq,\r\n&tmp_rxq,\r\n&fetched_pkts,\r\npart_bundle);\r\nif (status)\r\ngoto fail_rx;\r\nif (!list_empty(rx_pktq))\r\npart_bundle = true;\r\nlist_splice_tail_init(&tmp_rxq, comp_pktq);\r\n}\r\nif (!fetched_pkts) {\r\npacket = list_first_entry(rx_pktq, struct htc_packet,\r\nlist);\r\npacket->completion = NULL;\r\nif (!list_is_singular(rx_pktq))\r\npacket->info.rx.rx_flags |=\r\nHTC_RX_PKT_IGNORE_LOOKAHEAD;\r\nstatus = ath6kl_htc_rx_packet(target, packet,\r\npacket->act_len);\r\nlist_move_tail(&packet->list, &tmp_rxq);\r\nif (status)\r\ngoto fail_rx;\r\nlist_splice_tail_init(&tmp_rxq, comp_pktq);\r\n}\r\n}\r\nreturn 0;\r\nfail_rx:\r\nlist_for_each_entry_safe(packet, tmp_pkt, rx_pktq, list) {\r\nlist_del(&packet->list);\r\nhtc_reclaim_rxbuf(target, packet,\r\n&target->endpoint[packet->endpoint]);\r\n}\r\nlist_for_each_entry_safe(packet, tmp_pkt, &tmp_rxq, list) {\r\nlist_del(&packet->list);\r\nhtc_reclaim_rxbuf(target, packet,\r\n&target->endpoint[packet->endpoint]);\r\n}\r\nreturn status;\r\n}\r\nint ath6kl_htc_rxmsg_pending_handler(struct htc_target *target,\r\nu32 msg_look_ahead, int *num_pkts)\r\n{\r\nstruct htc_packet *packets, *tmp_pkt;\r\nstruct htc_endpoint *endpoint;\r\nstruct list_head rx_pktq, comp_pktq;\r\nint status = 0;\r\nu32 look_aheads[HTC_HOST_MAX_MSG_PER_BUNDLE];\r\nint num_look_ahead = 1;\r\nenum htc_endpoint_id id;\r\nint n_fetched = 0;\r\nINIT_LIST_HEAD(&comp_pktq);\r\n*num_pkts = 0;\r\nlook_aheads[0] = msg_look_ahead;\r\nwhile (true) {\r\nid = ((struct htc_frame_hdr *)&look_aheads[0])->eid;\r\nendpoint = &target->endpoint[id];\r\nif (id >= ENDPOINT_MAX) {\r\nath6kl_err("MsgPend, invalid endpoint in look-ahead: %d\n",\r\nid);\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\nINIT_LIST_HEAD(&rx_pktq);\r\nINIT_LIST_HEAD(&comp_pktq);\r\nstatus = ath6kl_htc_rx_alloc(target, look_aheads,\r\nnum_look_ahead, endpoint,\r\n&rx_pktq);\r\nif (status)\r\nbreak;\r\nif (get_queue_depth(&rx_pktq) >= 2)\r\ntarget->chk_irq_status_cnt = 1;\r\nn_fetched += get_queue_depth(&rx_pktq);\r\nnum_look_ahead = 0;\r\nstatus = ath6kl_htc_rx_fetch(target, &rx_pktq, &comp_pktq);\r\nif (!status)\r\nath6kl_htc_rx_chk_water_mark(endpoint);\r\nstatus = ath6kl_htc_rx_process_packets(target, &comp_pktq,\r\nlook_aheads,\r\n&num_look_ahead);\r\nif (!num_look_ahead || status)\r\nbreak;\r\ntarget->chk_irq_status_cnt = 1;\r\n}\r\nif (status) {\r\nath6kl_err("failed to get pending recv messages: %d\n",\r\nstatus);\r\nlist_for_each_entry_safe(packets, tmp_pkt, &comp_pktq, list) {\r\nlist_del(&packets->list);\r\nhtc_reclaim_rxbuf(target, packets,\r\n&target->endpoint[packets->endpoint]);\r\n}\r\nif (target->htc_flags & HTC_OP_STATE_STOPPING) {\r\nath6kl_warn("host is going to stop blocking receiver for htc_stop\n");\r\nath6kl_hif_rx_control(target->dev, false);\r\n}\r\n}\r\nif (target->rx_st_flags & HTC_RECV_WAIT_BUFFERS) {\r\nath6kl_warn("host has no rx buffers blocking receiver to prevent overrun\n");\r\nath6kl_hif_rx_control(target->dev, false);\r\n}\r\n*num_pkts = n_fetched;\r\nreturn status;\r\n}\r\nstatic struct htc_packet *htc_wait_for_ctrl_msg(struct htc_target *target)\r\n{\r\nstruct htc_packet *packet = NULL;\r\nstruct htc_frame_hdr *htc_hdr;\r\nu32 look_ahead;\r\nif (ath6kl_hif_poll_mboxmsg_rx(target->dev, &look_ahead,\r\nHTC_TARGET_RESPONSE_TIMEOUT))\r\nreturn NULL;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc rx wait ctrl look_ahead 0x%X\n", look_ahead);\r\nhtc_hdr = (struct htc_frame_hdr *)&look_ahead;\r\nif (htc_hdr->eid != ENDPOINT_0)\r\nreturn NULL;\r\npacket = htc_get_control_buf(target, false);\r\nif (!packet)\r\nreturn NULL;\r\npacket->info.rx.rx_flags = 0;\r\npacket->info.rx.exp_hdr = look_ahead;\r\npacket->act_len = le16_to_cpu(htc_hdr->payld_len) + HTC_HDR_LENGTH;\r\nif (packet->act_len > packet->buf_len)\r\ngoto fail_ctrl_rx;\r\npacket->completion = NULL;\r\nif (ath6kl_htc_rx_packet(target, packet, packet->act_len))\r\ngoto fail_ctrl_rx;\r\npacket->status = ath6kl_htc_rx_process_hdr(target, packet, NULL, NULL);\r\nif (packet->status) {\r\nath6kl_err("htc_wait_for_ctrl_msg, ath6kl_htc_rx_process_hdr failed (status = %d)\n",\r\npacket->status);\r\ngoto fail_ctrl_rx;\r\n}\r\nreturn packet;\r\nfail_ctrl_rx:\r\nif (packet != NULL) {\r\nhtc_rxpkt_reset(packet);\r\nreclaim_rx_ctrl_buf(target, packet);\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ath6kl_htc_mbox_add_rxbuf_multiple(struct htc_target *target,\r\nstruct list_head *pkt_queue)\r\n{\r\nstruct htc_endpoint *endpoint;\r\nstruct htc_packet *first_pkt;\r\nbool rx_unblock = false;\r\nint status = 0, depth;\r\nif (list_empty(pkt_queue))\r\nreturn -ENOMEM;\r\nfirst_pkt = list_first_entry(pkt_queue, struct htc_packet, list);\r\nif (first_pkt->endpoint >= ENDPOINT_MAX)\r\nreturn status;\r\ndepth = get_queue_depth(pkt_queue);\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc rx add multiple ep id %d cnt %d len %d\n",\r\nfirst_pkt->endpoint, depth, first_pkt->buf_len);\r\nendpoint = &target->endpoint[first_pkt->endpoint];\r\nif (target->htc_flags & HTC_OP_STATE_STOPPING) {\r\nstruct htc_packet *packet, *tmp_pkt;\r\nlist_for_each_entry_safe(packet, tmp_pkt, pkt_queue, list) {\r\npacket->status = -ECANCELED;\r\nlist_del(&packet->list);\r\nath6kl_htc_rx_complete(endpoint, packet);\r\n}\r\nreturn status;\r\n}\r\nspin_lock_bh(&target->rx_lock);\r\nlist_splice_tail_init(pkt_queue, &endpoint->rx_bufq);\r\nif (target->rx_st_flags & HTC_RECV_WAIT_BUFFERS) {\r\nif (target->ep_waiting == first_pkt->endpoint) {\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc rx blocked on ep %d, unblocking\n",\r\ntarget->ep_waiting);\r\ntarget->rx_st_flags &= ~HTC_RECV_WAIT_BUFFERS;\r\ntarget->ep_waiting = ENDPOINT_MAX;\r\nrx_unblock = true;\r\n}\r\n}\r\nspin_unlock_bh(&target->rx_lock);\r\nif (rx_unblock && !(target->htc_flags & HTC_OP_STATE_STOPPING))\r\nath6kl_hif_rx_control(target->dev, true);\r\nreturn status;\r\n}\r\nstatic void ath6kl_htc_mbox_flush_rx_buf(struct htc_target *target)\r\n{\r\nstruct htc_endpoint *endpoint;\r\nstruct htc_packet *packet, *tmp_pkt;\r\nint i;\r\nfor (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {\r\nendpoint = &target->endpoint[i];\r\nif (!endpoint->svc_id)\r\ncontinue;\r\nspin_lock_bh(&target->rx_lock);\r\nlist_for_each_entry_safe(packet, tmp_pkt,\r\n&endpoint->rx_bufq, list) {\r\nlist_del(&packet->list);\r\nspin_unlock_bh(&target->rx_lock);\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc rx flush pkt 0x%p len %d ep %d\n",\r\npacket, packet->buf_len,\r\npacket->endpoint);\r\nif (packet->endpoint == ENDPOINT_0) {\r\nkfree(packet->buf_start);\r\nkfree(packet);\r\n} else {\r\ndev_kfree_skb(packet->pkt_cntxt);\r\n}\r\nspin_lock_bh(&target->rx_lock);\r\n}\r\nspin_unlock_bh(&target->rx_lock);\r\n}\r\n}\r\nstatic int ath6kl_htc_mbox_conn_service(struct htc_target *target,\r\nstruct htc_service_connect_req *conn_req,\r\nstruct htc_service_connect_resp *conn_resp)\r\n{\r\nstruct htc_packet *rx_pkt = NULL;\r\nstruct htc_packet *tx_pkt = NULL;\r\nstruct htc_conn_service_resp *resp_msg;\r\nstruct htc_conn_service_msg *conn_msg;\r\nstruct htc_endpoint *endpoint;\r\nenum htc_endpoint_id assigned_ep = ENDPOINT_MAX;\r\nunsigned int max_msg_sz = 0;\r\nint status = 0;\r\nu16 msg_id;\r\nath6kl_dbg(ATH6KL_DBG_HTC,\r\n"htc connect service target 0x%p service id 0x%x\n",\r\ntarget, conn_req->svc_id);\r\nif (conn_req->svc_id == HTC_CTRL_RSVD_SVC) {\r\nassigned_ep = ENDPOINT_0;\r\nmax_msg_sz = HTC_MAX_CTRL_MSG_LEN;\r\n} else {\r\ntx_pkt = htc_get_control_buf(target, true);\r\nif (!tx_pkt)\r\nreturn -ENOMEM;\r\nconn_msg = (struct htc_conn_service_msg *)tx_pkt->buf;\r\nmemset(conn_msg, 0, sizeof(*conn_msg));\r\nconn_msg->msg_id = cpu_to_le16(HTC_MSG_CONN_SVC_ID);\r\nconn_msg->svc_id = cpu_to_le16(conn_req->svc_id);\r\nconn_msg->conn_flags = cpu_to_le16(conn_req->conn_flags);\r\nset_htc_pkt_info(tx_pkt, NULL, (u8 *) conn_msg,\r\nsizeof(*conn_msg) + conn_msg->svc_meta_len,\r\nENDPOINT_0, HTC_SERVICE_TX_PACKET_TAG);\r\ntx_pkt->completion = NULL;\r\nath6kl_htc_tx_prep_pkt(tx_pkt, 0, 0, 0);\r\nstatus = ath6kl_htc_tx_issue(target, tx_pkt);\r\nif (status)\r\ngoto fail_tx;\r\nrx_pkt = htc_wait_for_ctrl_msg(target);\r\nif (!rx_pkt) {\r\nstatus = -ENOMEM;\r\ngoto fail_tx;\r\n}\r\nresp_msg = (struct htc_conn_service_resp *)rx_pkt->buf;\r\nmsg_id = le16_to_cpu(resp_msg->msg_id);\r\nif ((msg_id != HTC_MSG_CONN_SVC_RESP_ID) ||\r\n(rx_pkt->act_len < sizeof(*resp_msg))) {\r\nstatus = -ENOMEM;\r\ngoto fail_tx;\r\n}\r\nconn_resp->resp_code = resp_msg->status;\r\nif (resp_msg->status != HTC_SERVICE_SUCCESS) {\r\nath6kl_err("target failed service 0x%X connect request (status:%d)\n",\r\nresp_msg->svc_id, resp_msg->status);\r\nstatus = -ENOMEM;\r\ngoto fail_tx;\r\n}\r\nassigned_ep = (enum htc_endpoint_id)resp_msg->eid;\r\nmax_msg_sz = le16_to_cpu(resp_msg->max_msg_sz);\r\n}\r\nif (assigned_ep >= ENDPOINT_MAX || !max_msg_sz) {\r\nstatus = -ENOMEM;\r\ngoto fail_tx;\r\n}\r\nendpoint = &target->endpoint[assigned_ep];\r\nendpoint->eid = assigned_ep;\r\nif (endpoint->svc_id) {\r\nstatus = -ENOMEM;\r\ngoto fail_tx;\r\n}\r\nconn_resp->endpoint = assigned_ep;\r\nconn_resp->len_max = max_msg_sz;\r\nendpoint->svc_id = conn_req->svc_id;\r\nendpoint->max_txq_depth = conn_req->max_txq_depth;\r\nendpoint->len_max = max_msg_sz;\r\nendpoint->ep_cb = conn_req->ep_cb;\r\nendpoint->cred_dist.svc_id = conn_req->svc_id;\r\nendpoint->cred_dist.htc_ep = endpoint;\r\nendpoint->cred_dist.endpoint = assigned_ep;\r\nendpoint->cred_dist.cred_sz = target->tgt_cred_sz;\r\nswitch (endpoint->svc_id) {\r\ncase WMI_DATA_BK_SVC:\r\nendpoint->tx_drop_packet_threshold = MAX_DEF_COOKIE_NUM / 3;\r\nbreak;\r\ndefault:\r\nendpoint->tx_drop_packet_threshold = MAX_HI_COOKIE_NUM;\r\nbreak;\r\n}\r\nif (conn_req->max_rxmsg_sz) {\r\nif (conn_req->max_rxmsg_sz > max_msg_sz) {\r\nstatus = -ENOMEM;\r\ngoto fail_tx;\r\n}\r\nendpoint->cred_dist.cred_per_msg =\r\nconn_req->max_rxmsg_sz / target->tgt_cred_sz;\r\n} else\r\nendpoint->cred_dist.cred_per_msg =\r\nmax_msg_sz / target->tgt_cred_sz;\r\nif (!endpoint->cred_dist.cred_per_msg)\r\nendpoint->cred_dist.cred_per_msg = 1;\r\nendpoint->conn_flags = conn_req->flags;\r\nfail_tx:\r\nif (tx_pkt)\r\nhtc_reclaim_txctrl_buf(target, tx_pkt);\r\nif (rx_pkt) {\r\nhtc_rxpkt_reset(rx_pkt);\r\nreclaim_rx_ctrl_buf(target, rx_pkt);\r\n}\r\nreturn status;\r\n}\r\nstatic void reset_ep_state(struct htc_target *target)\r\n{\r\nstruct htc_endpoint *endpoint;\r\nint i;\r\nfor (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {\r\nendpoint = &target->endpoint[i];\r\nmemset(&endpoint->cred_dist, 0, sizeof(endpoint->cred_dist));\r\nendpoint->svc_id = 0;\r\nendpoint->len_max = 0;\r\nendpoint->max_txq_depth = 0;\r\nmemset(&endpoint->ep_st, 0,\r\nsizeof(endpoint->ep_st));\r\nINIT_LIST_HEAD(&endpoint->rx_bufq);\r\nINIT_LIST_HEAD(&endpoint->txq);\r\nendpoint->target = target;\r\n}\r\nINIT_LIST_HEAD(&target->cred_dist_list);\r\n}\r\nstatic int ath6kl_htc_mbox_get_rxbuf_num(struct htc_target *target,\r\nenum htc_endpoint_id endpoint)\r\n{\r\nint num;\r\nspin_lock_bh(&target->rx_lock);\r\nnum = get_queue_depth(&(target->endpoint[endpoint].rx_bufq));\r\nspin_unlock_bh(&target->rx_lock);\r\nreturn num;\r\n}\r\nstatic void htc_setup_msg_bndl(struct htc_target *target)\r\n{\r\ntarget->msg_per_bndl_max = min(HTC_HOST_MAX_MSG_PER_BUNDLE,\r\ntarget->msg_per_bndl_max);\r\nif (ath6kl_hif_enable_scatter(target->dev->ar)) {\r\ntarget->msg_per_bndl_max = 0;\r\nreturn;\r\n}\r\ntarget->msg_per_bndl_max = min(target->max_scat_entries,\r\ntarget->msg_per_bndl_max);\r\nath6kl_dbg(ATH6KL_DBG_BOOT,\r\n"htc bundling allowed msg_per_bndl_max %d\n",\r\ntarget->msg_per_bndl_max);\r\ntarget->max_rx_bndl_sz = target->max_xfer_szper_scatreq;\r\ntarget->max_tx_bndl_sz = min(HIF_MBOX0_EXT_WIDTH,\r\ntarget->max_xfer_szper_scatreq);\r\nath6kl_dbg(ATH6KL_DBG_BOOT, "htc max_rx_bndl_sz %d max_tx_bndl_sz %d\n",\r\ntarget->max_rx_bndl_sz, target->max_tx_bndl_sz);\r\nif (target->max_tx_bndl_sz)\r\ntarget->tx_bndl_mask = (1 << WMM_NUM_AC) - 1;\r\nif (target->max_rx_bndl_sz)\r\ntarget->rx_bndl_enable = true;\r\nif ((target->tgt_cred_sz % target->block_sz) != 0) {\r\nath6kl_warn("credit size: %d is not block aligned! Disabling send bundling\n",\r\ntarget->tgt_cred_sz);\r\ntarget->tx_bndl_mask = 0;\r\n}\r\n}\r\nstatic int ath6kl_htc_mbox_wait_target(struct htc_target *target)\r\n{\r\nstruct htc_packet *packet = NULL;\r\nstruct htc_ready_ext_msg *rdy_msg;\r\nstruct htc_service_connect_req connect;\r\nstruct htc_service_connect_resp resp;\r\nint status;\r\nif (target->dev->ar->hif_type == ATH6KL_HIF_TYPE_USB) {\r\nath6kl_err("HTC doesn't support USB yet. Patience!\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\npacket = htc_wait_for_ctrl_msg(target);\r\nif (!packet)\r\nreturn -ENOMEM;\r\nrdy_msg = (struct htc_ready_ext_msg *)packet->buf;\r\nif ((le16_to_cpu(rdy_msg->ver2_0_info.msg_id) != HTC_MSG_READY_ID) ||\r\n(packet->act_len < sizeof(struct htc_ready_msg))) {\r\nstatus = -ENOMEM;\r\ngoto fail_wait_target;\r\n}\r\nif (!rdy_msg->ver2_0_info.cred_cnt || !rdy_msg->ver2_0_info.cred_sz) {\r\nstatus = -ENOMEM;\r\ngoto fail_wait_target;\r\n}\r\ntarget->tgt_creds = le16_to_cpu(rdy_msg->ver2_0_info.cred_cnt);\r\ntarget->tgt_cred_sz = le16_to_cpu(rdy_msg->ver2_0_info.cred_sz);\r\nath6kl_dbg(ATH6KL_DBG_BOOT,\r\n"htc target ready credits %d size %d\n",\r\ntarget->tgt_creds, target->tgt_cred_sz);\r\nif (packet->act_len >= sizeof(struct htc_ready_ext_msg)) {\r\ntarget->htc_tgt_ver = rdy_msg->htc_ver;\r\ntarget->msg_per_bndl_max = rdy_msg->msg_per_htc_bndl;\r\n} else {\r\ntarget->htc_tgt_ver = HTC_VERSION_2P0;\r\ntarget->msg_per_bndl_max = 0;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_BOOT, "htc using protocol %s (%d)\n",\r\n(target->htc_tgt_ver == HTC_VERSION_2P0) ? "2.0" : ">= 2.1",\r\ntarget->htc_tgt_ver);\r\nif (target->msg_per_bndl_max > 0)\r\nhtc_setup_msg_bndl(target);\r\nmemset(&connect, 0, sizeof(connect));\r\nmemset(&resp, 0, sizeof(resp));\r\nconnect.ep_cb.rx = htc_ctrl_rx;\r\nconnect.ep_cb.rx_refill = NULL;\r\nconnect.ep_cb.tx_full = NULL;\r\nconnect.max_txq_depth = NUM_CONTROL_BUFFERS;\r\nconnect.svc_id = HTC_CTRL_RSVD_SVC;\r\nstatus = ath6kl_htc_mbox_conn_service((void *)target, &connect, &resp);\r\nif (status)\r\nath6kl_hif_cleanup_scatter(target->dev->ar);\r\nfail_wait_target:\r\nif (packet) {\r\nhtc_rxpkt_reset(packet);\r\nreclaim_rx_ctrl_buf(target, packet);\r\n}\r\nreturn status;\r\n}\r\nstatic int ath6kl_htc_mbox_start(struct htc_target *target)\r\n{\r\nstruct htc_packet *packet;\r\nint status;\r\nmemset(&target->dev->irq_proc_reg, 0,\r\nsizeof(target->dev->irq_proc_reg));\r\nath6kl_hif_disable_intrs(target->dev);\r\ntarget->htc_flags = 0;\r\ntarget->rx_st_flags = 0;\r\nwhile ((packet = htc_get_control_buf(target, false)) != NULL) {\r\nstatus = htc_add_rxbuf(target, packet);\r\nif (status)\r\nreturn status;\r\n}\r\nath6kl_credit_init(target->credit_info, &target->cred_dist_list,\r\ntarget->tgt_creds);\r\ndump_cred_dist_stats(target);\r\nstatus = htc_setup_tx_complete(target);\r\nif (status)\r\nreturn status;\r\nstatus = ath6kl_hif_unmask_intrs(target->dev);\r\nif (status)\r\nath6kl_htc_mbox_stop(target);\r\nreturn status;\r\n}\r\nstatic int ath6kl_htc_reset(struct htc_target *target)\r\n{\r\nu32 block_size, ctrl_bufsz;\r\nstruct htc_packet *packet;\r\nint i;\r\nreset_ep_state(target);\r\nblock_size = target->dev->ar->mbox_info.block_size;\r\nctrl_bufsz = (block_size > HTC_MAX_CTRL_MSG_LEN) ?\r\n(block_size + HTC_HDR_LENGTH) :\r\n(HTC_MAX_CTRL_MSG_LEN + HTC_HDR_LENGTH);\r\nfor (i = 0; i < NUM_CONTROL_BUFFERS; i++) {\r\npacket = kzalloc(sizeof(*packet), GFP_KERNEL);\r\nif (!packet)\r\nreturn -ENOMEM;\r\npacket->buf_start = kzalloc(ctrl_bufsz, GFP_KERNEL);\r\nif (!packet->buf_start) {\r\nkfree(packet);\r\nreturn -ENOMEM;\r\n}\r\npacket->buf_len = ctrl_bufsz;\r\nif (i < NUM_CONTROL_RX_BUFFERS) {\r\npacket->act_len = 0;\r\npacket->buf = packet->buf_start;\r\npacket->endpoint = ENDPOINT_0;\r\nlist_add_tail(&packet->list, &target->free_ctrl_rxbuf);\r\n} else\r\nlist_add_tail(&packet->list, &target->free_ctrl_txbuf);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ath6kl_htc_mbox_stop(struct htc_target *target)\r\n{\r\nspin_lock_bh(&target->htc_lock);\r\ntarget->htc_flags |= HTC_OP_STATE_STOPPING;\r\nspin_unlock_bh(&target->htc_lock);\r\nath6kl_hif_mask_intrs(target->dev);\r\nath6kl_htc_flush_txep_all(target);\r\nath6kl_htc_mbox_flush_rx_buf(target);\r\nath6kl_htc_reset(target);\r\n}\r\nstatic void *ath6kl_htc_mbox_create(struct ath6kl *ar)\r\n{\r\nstruct htc_target *target = NULL;\r\nint status = 0;\r\ntarget = kzalloc(sizeof(*target), GFP_KERNEL);\r\nif (!target) {\r\nath6kl_err("unable to allocate memory\n");\r\nreturn NULL;\r\n}\r\ntarget->dev = kzalloc(sizeof(*target->dev), GFP_KERNEL);\r\nif (!target->dev) {\r\nath6kl_err("unable to allocate memory\n");\r\nstatus = -ENOMEM;\r\ngoto err_htc_cleanup;\r\n}\r\nspin_lock_init(&target->htc_lock);\r\nspin_lock_init(&target->rx_lock);\r\nspin_lock_init(&target->tx_lock);\r\nINIT_LIST_HEAD(&target->free_ctrl_txbuf);\r\nINIT_LIST_HEAD(&target->free_ctrl_rxbuf);\r\nINIT_LIST_HEAD(&target->cred_dist_list);\r\ntarget->dev->ar = ar;\r\ntarget->dev->htc_cnxt = target;\r\ntarget->ep_waiting = ENDPOINT_MAX;\r\nstatus = ath6kl_hif_setup(target->dev);\r\nif (status)\r\ngoto err_htc_cleanup;\r\nstatus = ath6kl_htc_reset(target);\r\nif (status)\r\ngoto err_htc_cleanup;\r\nreturn target;\r\nerr_htc_cleanup:\r\nath6kl_htc_mbox_cleanup(target);\r\nreturn NULL;\r\n}\r\nstatic void ath6kl_htc_mbox_cleanup(struct htc_target *target)\r\n{\r\nstruct htc_packet *packet, *tmp_packet;\r\nif (target->dev->ar->hif_type != ATH6KL_HIF_TYPE_USB)\r\nath6kl_hif_cleanup_scatter(target->dev->ar);\r\nlist_for_each_entry_safe(packet, tmp_packet,\r\n&target->free_ctrl_txbuf, list) {\r\nlist_del(&packet->list);\r\nkfree(packet->buf_start);\r\nkfree(packet);\r\n}\r\nlist_for_each_entry_safe(packet, tmp_packet,\r\n&target->free_ctrl_rxbuf, list) {\r\nlist_del(&packet->list);\r\nkfree(packet->buf_start);\r\nkfree(packet);\r\n}\r\nkfree(target->dev);\r\nkfree(target);\r\n}\r\nvoid ath6kl_htc_mbox_attach(struct ath6kl *ar)\r\n{\r\nar->htc_ops = &ath6kl_htc_mbox_ops;\r\n}
