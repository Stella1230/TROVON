static int\r\nxfs_initxattrs(\r\nstruct inode *inode,\r\nconst struct xattr *xattr_array,\r\nvoid *fs_info)\r\n{\r\nconst struct xattr *xattr;\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nint error = 0;\r\nfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\r\nerror = xfs_attr_set(ip, xattr->name, xattr->value,\r\nxattr->value_len, ATTR_SECURE);\r\nif (error < 0)\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_init_security(\r\nstruct inode *inode,\r\nstruct inode *dir,\r\nconst struct qstr *qstr)\r\n{\r\nreturn security_inode_init_security(inode, dir, qstr,\r\n&xfs_initxattrs, NULL);\r\n}\r\nstatic void\r\nxfs_dentry_to_name(\r\nstruct xfs_name *namep,\r\nstruct dentry *dentry)\r\n{\r\nnamep->name = dentry->d_name.name;\r\nnamep->len = dentry->d_name.len;\r\n}\r\nSTATIC void\r\nxfs_cleanup_inode(\r\nstruct inode *dir,\r\nstruct inode *inode,\r\nstruct dentry *dentry)\r\n{\r\nstruct xfs_name teardown;\r\nxfs_dentry_to_name(&teardown, dentry);\r\nxfs_remove(XFS_I(dir), &teardown, XFS_I(inode));\r\niput(inode);\r\n}\r\nSTATIC int\r\nxfs_vn_mknod(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\numode_t mode,\r\ndev_t rdev)\r\n{\r\nstruct inode *inode;\r\nstruct xfs_inode *ip = NULL;\r\nstruct posix_acl *default_acl = NULL;\r\nstruct xfs_name name;\r\nint error;\r\nif (S_ISCHR(mode) || S_ISBLK(mode)) {\r\nif (unlikely(!sysv_valid_dev(rdev) || MAJOR(rdev) & ~0x1ff))\r\nreturn -EINVAL;\r\nrdev = sysv_encode_dev(rdev);\r\n} else {\r\nrdev = 0;\r\n}\r\nif (IS_POSIXACL(dir)) {\r\ndefault_acl = xfs_get_acl(dir, ACL_TYPE_DEFAULT);\r\nif (IS_ERR(default_acl))\r\nreturn PTR_ERR(default_acl);\r\nif (!default_acl)\r\nmode &= ~current_umask();\r\n}\r\nxfs_dentry_to_name(&name, dentry);\r\nerror = xfs_create(XFS_I(dir), &name, mode, rdev, &ip);\r\nif (unlikely(error))\r\ngoto out_free_acl;\r\ninode = VFS_I(ip);\r\nerror = xfs_init_security(inode, dir, &dentry->d_name);\r\nif (unlikely(error))\r\ngoto out_cleanup_inode;\r\nif (default_acl) {\r\nerror = -xfs_inherit_acl(inode, default_acl);\r\ndefault_acl = NULL;\r\nif (unlikely(error))\r\ngoto out_cleanup_inode;\r\n}\r\nd_instantiate(dentry, inode);\r\nreturn -error;\r\nout_cleanup_inode:\r\nxfs_cleanup_inode(dir, inode, dentry);\r\nout_free_acl:\r\nposix_acl_release(default_acl);\r\nreturn -error;\r\n}\r\nSTATIC int\r\nxfs_vn_create(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\numode_t mode,\r\nbool flags)\r\n{\r\nreturn xfs_vn_mknod(dir, dentry, mode, 0);\r\n}\r\nSTATIC int\r\nxfs_vn_mkdir(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\numode_t mode)\r\n{\r\nreturn xfs_vn_mknod(dir, dentry, mode|S_IFDIR, 0);\r\n}\r\nSTATIC struct dentry *\r\nxfs_vn_lookup(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\nunsigned int flags)\r\n{\r\nstruct xfs_inode *cip;\r\nstruct xfs_name name;\r\nint error;\r\nif (dentry->d_name.len >= MAXNAMELEN)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nxfs_dentry_to_name(&name, dentry);\r\nerror = xfs_lookup(XFS_I(dir), &name, &cip, NULL);\r\nif (unlikely(error)) {\r\nif (unlikely(error != ENOENT))\r\nreturn ERR_PTR(-error);\r\nd_add(dentry, NULL);\r\nreturn NULL;\r\n}\r\nreturn d_splice_alias(VFS_I(cip), dentry);\r\n}\r\nSTATIC struct dentry *\r\nxfs_vn_ci_lookup(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\nunsigned int flags)\r\n{\r\nstruct xfs_inode *ip;\r\nstruct xfs_name xname;\r\nstruct xfs_name ci_name;\r\nstruct qstr dname;\r\nint error;\r\nif (dentry->d_name.len >= MAXNAMELEN)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nxfs_dentry_to_name(&xname, dentry);\r\nerror = xfs_lookup(XFS_I(dir), &xname, &ip, &ci_name);\r\nif (unlikely(error)) {\r\nif (unlikely(error != ENOENT))\r\nreturn ERR_PTR(-error);\r\nreturn NULL;\r\n}\r\nif (!ci_name.name)\r\nreturn d_splice_alias(VFS_I(ip), dentry);\r\ndname.name = ci_name.name;\r\ndname.len = ci_name.len;\r\ndentry = d_add_ci(dentry, VFS_I(ip), &dname);\r\nkmem_free(ci_name.name);\r\nreturn dentry;\r\n}\r\nSTATIC int\r\nxfs_vn_link(\r\nstruct dentry *old_dentry,\r\nstruct inode *dir,\r\nstruct dentry *dentry)\r\n{\r\nstruct inode *inode = old_dentry->d_inode;\r\nstruct xfs_name name;\r\nint error;\r\nxfs_dentry_to_name(&name, dentry);\r\nerror = xfs_link(XFS_I(dir), XFS_I(inode), &name);\r\nif (unlikely(error))\r\nreturn -error;\r\nihold(inode);\r\nd_instantiate(dentry, inode);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_vn_unlink(\r\nstruct inode *dir,\r\nstruct dentry *dentry)\r\n{\r\nstruct xfs_name name;\r\nint error;\r\nxfs_dentry_to_name(&name, dentry);\r\nerror = -xfs_remove(XFS_I(dir), &name, XFS_I(dentry->d_inode));\r\nif (error)\r\nreturn error;\r\nif (xfs_sb_version_hasasciici(&XFS_M(dir->i_sb)->m_sb))\r\nd_invalidate(dentry);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_vn_symlink(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\nconst char *symname)\r\n{\r\nstruct inode *inode;\r\nstruct xfs_inode *cip = NULL;\r\nstruct xfs_name name;\r\nint error;\r\numode_t mode;\r\nmode = S_IFLNK |\r\n(irix_symlink_mode ? 0777 & ~current_umask() : S_IRWXUGO);\r\nxfs_dentry_to_name(&name, dentry);\r\nerror = xfs_symlink(XFS_I(dir), &name, symname, mode, &cip);\r\nif (unlikely(error))\r\ngoto out;\r\ninode = VFS_I(cip);\r\nerror = xfs_init_security(inode, dir, &dentry->d_name);\r\nif (unlikely(error))\r\ngoto out_cleanup_inode;\r\nd_instantiate(dentry, inode);\r\nreturn 0;\r\nout_cleanup_inode:\r\nxfs_cleanup_inode(dir, inode, dentry);\r\nout:\r\nreturn -error;\r\n}\r\nSTATIC int\r\nxfs_vn_rename(\r\nstruct inode *odir,\r\nstruct dentry *odentry,\r\nstruct inode *ndir,\r\nstruct dentry *ndentry)\r\n{\r\nstruct inode *new_inode = ndentry->d_inode;\r\nstruct xfs_name oname;\r\nstruct xfs_name nname;\r\nxfs_dentry_to_name(&oname, odentry);\r\nxfs_dentry_to_name(&nname, ndentry);\r\nreturn -xfs_rename(XFS_I(odir), &oname, XFS_I(odentry->d_inode),\r\nXFS_I(ndir), &nname, new_inode ?\r\nXFS_I(new_inode) : NULL);\r\n}\r\nSTATIC void *\r\nxfs_vn_follow_link(\r\nstruct dentry *dentry,\r\nstruct nameidata *nd)\r\n{\r\nchar *link;\r\nint error = -ENOMEM;\r\nlink = kmalloc(MAXPATHLEN+1, GFP_KERNEL);\r\nif (!link)\r\ngoto out_err;\r\nerror = -xfs_readlink(XFS_I(dentry->d_inode), link);\r\nif (unlikely(error))\r\ngoto out_kfree;\r\nnd_set_link(nd, link);\r\nreturn NULL;\r\nout_kfree:\r\nkfree(link);\r\nout_err:\r\nnd_set_link(nd, ERR_PTR(error));\r\nreturn NULL;\r\n}\r\nSTATIC void\r\nxfs_vn_put_link(\r\nstruct dentry *dentry,\r\nstruct nameidata *nd,\r\nvoid *p)\r\n{\r\nchar *s = nd_get_link(nd);\r\nif (!IS_ERR(s))\r\nkfree(s);\r\n}\r\nSTATIC int\r\nxfs_vn_getattr(\r\nstruct vfsmount *mnt,\r\nstruct dentry *dentry,\r\nstruct kstat *stat)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nstruct xfs_mount *mp = ip->i_mount;\r\ntrace_xfs_getattr(ip);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn -XFS_ERROR(EIO);\r\nstat->size = XFS_ISIZE(ip);\r\nstat->dev = inode->i_sb->s_dev;\r\nstat->mode = ip->i_d.di_mode;\r\nstat->nlink = ip->i_d.di_nlink;\r\nstat->uid = ip->i_d.di_uid;\r\nstat->gid = ip->i_d.di_gid;\r\nstat->ino = ip->i_ino;\r\nstat->atime = inode->i_atime;\r\nstat->mtime = inode->i_mtime;\r\nstat->ctime = inode->i_ctime;\r\nstat->blocks =\r\nXFS_FSB_TO_BB(mp, ip->i_d.di_nblocks + ip->i_delayed_blks);\r\nswitch (inode->i_mode & S_IFMT) {\r\ncase S_IFBLK:\r\ncase S_IFCHR:\r\nstat->blksize = BLKDEV_IOSIZE;\r\nstat->rdev = MKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,\r\nsysv_minor(ip->i_df.if_u2.if_rdev));\r\nbreak;\r\ndefault:\r\nif (XFS_IS_REALTIME_INODE(ip)) {\r\nstat->blksize =\r\nxfs_get_extsz_hint(ip) << mp->m_sb.sb_blocklog;\r\n} else\r\nstat->blksize = xfs_preferred_iosize(mp);\r\nstat->rdev = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_setattr_nonsize(\r\nstruct xfs_inode *ip,\r\nstruct iattr *iattr,\r\nint flags)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nstruct inode *inode = VFS_I(ip);\r\nint mask = iattr->ia_valid;\r\nxfs_trans_t *tp;\r\nint error;\r\nuid_t uid = 0, iuid = 0;\r\ngid_t gid = 0, igid = 0;\r\nstruct xfs_dquot *udqp = NULL, *gdqp = NULL;\r\nstruct xfs_dquot *olddquot1 = NULL, *olddquot2 = NULL;\r\ntrace_xfs_setattr(ip);\r\nif (mp->m_flags & XFS_MOUNT_RDONLY)\r\nreturn XFS_ERROR(EROFS);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn XFS_ERROR(EIO);\r\nerror = -inode_change_ok(inode, iattr);\r\nif (error)\r\nreturn XFS_ERROR(error);\r\nASSERT((mask & ATTR_SIZE) == 0);\r\nif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\r\nuint qflags = 0;\r\nif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\r\nuid = iattr->ia_uid;\r\nqflags |= XFS_QMOPT_UQUOTA;\r\n} else {\r\nuid = ip->i_d.di_uid;\r\n}\r\nif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\r\ngid = iattr->ia_gid;\r\nqflags |= XFS_QMOPT_GQUOTA;\r\n} else {\r\ngid = ip->i_d.di_gid;\r\n}\r\nASSERT(udqp == NULL);\r\nASSERT(gdqp == NULL);\r\nerror = xfs_qm_vop_dqalloc(ip, uid, gid, xfs_get_projid(ip),\r\nqflags, &udqp, &gdqp);\r\nif (error)\r\nreturn error;\r\n}\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\r\nerror = xfs_trans_reserve(tp, 0, XFS_ICHANGE_LOG_RES(mp), 0, 0, 0);\r\nif (error)\r\ngoto out_dqrele;\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nif (mask & (ATTR_UID|ATTR_GID)) {\r\niuid = ip->i_d.di_uid;\r\nigid = ip->i_d.di_gid;\r\ngid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\r\nuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\r\nif (XFS_IS_QUOTA_RUNNING(mp) &&\r\n((XFS_IS_UQUOTA_ON(mp) && iuid != uid) ||\r\n(XFS_IS_GQUOTA_ON(mp) && igid != gid))) {\r\nASSERT(tp);\r\nerror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\r\ncapable(CAP_FOWNER) ?\r\nXFS_QMOPT_FORCE_RES : 0);\r\nif (error)\r\ngoto out_trans_cancel;\r\n}\r\n}\r\nxfs_trans_ijoin(tp, ip, 0);\r\nif (mask & (ATTR_UID|ATTR_GID)) {\r\nif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\r\n!capable(CAP_FSETID))\r\nip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\r\nif (iuid != uid) {\r\nif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\r\nASSERT(mask & ATTR_UID);\r\nASSERT(udqp);\r\nolddquot1 = xfs_qm_vop_chown(tp, ip,\r\n&ip->i_udquot, udqp);\r\n}\r\nip->i_d.di_uid = uid;\r\ninode->i_uid = uid;\r\n}\r\nif (igid != gid) {\r\nif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\r\nASSERT(!XFS_IS_PQUOTA_ON(mp));\r\nASSERT(mask & ATTR_GID);\r\nASSERT(gdqp);\r\nolddquot2 = xfs_qm_vop_chown(tp, ip,\r\n&ip->i_gdquot, gdqp);\r\n}\r\nip->i_d.di_gid = gid;\r\ninode->i_gid = gid;\r\n}\r\n}\r\nif (mask & ATTR_MODE) {\r\numode_t mode = iattr->ia_mode;\r\nif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\r\nmode &= ~S_ISGID;\r\nip->i_d.di_mode &= S_IFMT;\r\nip->i_d.di_mode |= mode & ~S_IFMT;\r\ninode->i_mode &= S_IFMT;\r\ninode->i_mode |= mode & ~S_IFMT;\r\n}\r\nif (mask & ATTR_ATIME) {\r\ninode->i_atime = iattr->ia_atime;\r\nip->i_d.di_atime.t_sec = iattr->ia_atime.tv_sec;\r\nip->i_d.di_atime.t_nsec = iattr->ia_atime.tv_nsec;\r\n}\r\nif (mask & ATTR_CTIME) {\r\ninode->i_ctime = iattr->ia_ctime;\r\nip->i_d.di_ctime.t_sec = iattr->ia_ctime.tv_sec;\r\nip->i_d.di_ctime.t_nsec = iattr->ia_ctime.tv_nsec;\r\n}\r\nif (mask & ATTR_MTIME) {\r\ninode->i_mtime = iattr->ia_mtime;\r\nip->i_d.di_mtime.t_sec = iattr->ia_mtime.tv_sec;\r\nip->i_d.di_mtime.t_nsec = iattr->ia_mtime.tv_nsec;\r\n}\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nXFS_STATS_INC(xs_ig_attrchg);\r\nif (mp->m_flags & XFS_MOUNT_WSYNC)\r\nxfs_trans_set_sync(tp);\r\nerror = xfs_trans_commit(tp, 0);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nxfs_qm_dqrele(olddquot1);\r\nxfs_qm_dqrele(olddquot2);\r\nxfs_qm_dqrele(udqp);\r\nxfs_qm_dqrele(gdqp);\r\nif (error)\r\nreturn XFS_ERROR(error);\r\nif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\r\nerror = -xfs_acl_chmod(inode);\r\nif (error)\r\nreturn XFS_ERROR(error);\r\n}\r\nreturn 0;\r\nout_trans_cancel:\r\nxfs_trans_cancel(tp, 0);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nout_dqrele:\r\nxfs_qm_dqrele(udqp);\r\nxfs_qm_dqrele(gdqp);\r\nreturn error;\r\n}\r\nint\r\nxfs_setattr_size(\r\nstruct xfs_inode *ip,\r\nstruct iattr *iattr,\r\nint flags)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct inode *inode = VFS_I(ip);\r\nint mask = iattr->ia_valid;\r\nxfs_off_t oldsize, newsize;\r\nstruct xfs_trans *tp;\r\nint error;\r\nuint lock_flags = 0;\r\nuint commit_flags = 0;\r\ntrace_xfs_setattr(ip);\r\nif (mp->m_flags & XFS_MOUNT_RDONLY)\r\nreturn XFS_ERROR(EROFS);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn XFS_ERROR(EIO);\r\nerror = -inode_change_ok(inode, iattr);\r\nif (error)\r\nreturn XFS_ERROR(error);\r\nASSERT(S_ISREG(ip->i_d.di_mode));\r\nASSERT((mask & (ATTR_MODE|ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\r\nATTR_MTIME_SET|ATTR_KILL_SUID|ATTR_KILL_SGID|\r\nATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\r\nif (!(flags & XFS_ATTR_NOLOCK)) {\r\nlock_flags |= XFS_IOLOCK_EXCL;\r\nxfs_ilock(ip, lock_flags);\r\n}\r\noldsize = inode->i_size;\r\nnewsize = iattr->ia_size;\r\nif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\r\nif (!(mask & (ATTR_CTIME|ATTR_MTIME)))\r\ngoto out_unlock;\r\nxfs_iunlock(ip, lock_flags);\r\niattr->ia_valid &= ~ATTR_SIZE;\r\nreturn xfs_setattr_nonsize(ip, iattr, 0);\r\n}\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\ngoto out_unlock;\r\nif (newsize > oldsize) {\r\nerror = xfs_zero_eof(ip, newsize, oldsize);\r\nif (error)\r\ngoto out_unlock;\r\n}\r\nif (oldsize != ip->i_d.di_size && newsize > ip->i_d.di_size) {\r\nerror = xfs_flush_pages(ip, ip->i_d.di_size, newsize, 0,\r\nFI_NONE);\r\nif (error)\r\ngoto out_unlock;\r\n}\r\ninode_dio_wait(inode);\r\nerror = -block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);\r\nif (error)\r\ngoto out_unlock;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_SIZE);\r\nerror = xfs_trans_reserve(tp, 0, XFS_ITRUNCATE_LOG_RES(mp), 0,\r\nXFS_TRANS_PERM_LOG_RES,\r\nXFS_ITRUNCATE_LOG_COUNT);\r\nif (error)\r\ngoto out_trans_cancel;\r\ntruncate_setsize(inode, newsize);\r\ncommit_flags = XFS_TRANS_RELEASE_LOG_RES;\r\nlock_flags |= XFS_ILOCK_EXCL;\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, 0);\r\nif (newsize != oldsize && (!(mask & (ATTR_CTIME | ATTR_MTIME)))) {\r\niattr->ia_ctime = iattr->ia_mtime =\r\ncurrent_fs_time(inode->i_sb);\r\nmask |= ATTR_CTIME | ATTR_MTIME;\r\n}\r\nip->i_d.di_size = newsize;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nif (newsize <= oldsize) {\r\nerror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\r\nif (error)\r\ngoto out_trans_abort;\r\nxfs_iflags_set(ip, XFS_ITRUNCATED);\r\n}\r\nif (mask & ATTR_CTIME) {\r\ninode->i_ctime = iattr->ia_ctime;\r\nip->i_d.di_ctime.t_sec = iattr->ia_ctime.tv_sec;\r\nip->i_d.di_ctime.t_nsec = iattr->ia_ctime.tv_nsec;\r\n}\r\nif (mask & ATTR_MTIME) {\r\ninode->i_mtime = iattr->ia_mtime;\r\nip->i_d.di_mtime.t_sec = iattr->ia_mtime.tv_sec;\r\nip->i_d.di_mtime.t_nsec = iattr->ia_mtime.tv_nsec;\r\n}\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nXFS_STATS_INC(xs_ig_attrchg);\r\nif (mp->m_flags & XFS_MOUNT_WSYNC)\r\nxfs_trans_set_sync(tp);\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nout_unlock:\r\nif (lock_flags)\r\nxfs_iunlock(ip, lock_flags);\r\nreturn error;\r\nout_trans_abort:\r\ncommit_flags |= XFS_TRANS_ABORT;\r\nout_trans_cancel:\r\nxfs_trans_cancel(tp, commit_flags);\r\ngoto out_unlock;\r\n}\r\nSTATIC int\r\nxfs_vn_setattr(\r\nstruct dentry *dentry,\r\nstruct iattr *iattr)\r\n{\r\nif (iattr->ia_valid & ATTR_SIZE)\r\nreturn -xfs_setattr_size(XFS_I(dentry->d_inode), iattr, 0);\r\nreturn -xfs_setattr_nonsize(XFS_I(dentry->d_inode), iattr, 0);\r\n}\r\nSTATIC int\r\nxfs_vn_update_time(\r\nstruct inode *inode,\r\nstruct timespec *now,\r\nint flags)\r\n{\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct xfs_trans *tp;\r\nint error;\r\ntrace_xfs_update_time(ip);\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_FSYNC_TS);\r\nerror = xfs_trans_reserve(tp, 0, XFS_FSYNC_TS_LOG_RES(mp), 0, 0, 0);\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\nreturn -error;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nif (flags & S_CTIME) {\r\ninode->i_ctime = *now;\r\nip->i_d.di_ctime.t_sec = (__int32_t)now->tv_sec;\r\nip->i_d.di_ctime.t_nsec = (__int32_t)now->tv_nsec;\r\n}\r\nif (flags & S_MTIME) {\r\ninode->i_mtime = *now;\r\nip->i_d.di_mtime.t_sec = (__int32_t)now->tv_sec;\r\nip->i_d.di_mtime.t_nsec = (__int32_t)now->tv_nsec;\r\n}\r\nif (flags & S_ATIME) {\r\ninode->i_atime = *now;\r\nip->i_d.di_atime.t_sec = (__int32_t)now->tv_sec;\r\nip->i_d.di_atime.t_nsec = (__int32_t)now->tv_nsec;\r\n}\r\nxfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_TIMESTAMP);\r\nreturn -xfs_trans_commit(tp, 0);\r\n}\r\nSTATIC int\r\nxfs_fiemap_format(\r\nvoid **arg,\r\nstruct getbmapx *bmv,\r\nint *full)\r\n{\r\nint error;\r\nstruct fiemap_extent_info *fieinfo = *arg;\r\nu32 fiemap_flags = 0;\r\nu64 logical, physical, length;\r\nif (bmv->bmv_block == -1LL)\r\nreturn 0;\r\nlogical = BBTOB(bmv->bmv_offset);\r\nphysical = BBTOB(bmv->bmv_block);\r\nlength = BBTOB(bmv->bmv_length);\r\nif (bmv->bmv_oflags & BMV_OF_PREALLOC)\r\nfiemap_flags |= FIEMAP_EXTENT_UNWRITTEN;\r\nelse if (bmv->bmv_oflags & BMV_OF_DELALLOC) {\r\nfiemap_flags |= FIEMAP_EXTENT_DELALLOC;\r\nphysical = 0;\r\n}\r\nif (bmv->bmv_oflags & BMV_OF_LAST)\r\nfiemap_flags |= FIEMAP_EXTENT_LAST;\r\nerror = fiemap_fill_next_extent(fieinfo, logical, physical,\r\nlength, fiemap_flags);\r\nif (error > 0) {\r\nerror = 0;\r\n*full = 1;\r\n}\r\nreturn -error;\r\n}\r\nSTATIC int\r\nxfs_vn_fiemap(\r\nstruct inode *inode,\r\nstruct fiemap_extent_info *fieinfo,\r\nu64 start,\r\nu64 length)\r\n{\r\nxfs_inode_t *ip = XFS_I(inode);\r\nstruct getbmapx bm;\r\nint error;\r\nerror = fiemap_check_flags(fieinfo, XFS_FIEMAP_FLAGS);\r\nif (error)\r\nreturn error;\r\nbm.bmv_offset = BTOBB(start);\r\nif (length == FIEMAP_MAX_OFFSET)\r\nbm.bmv_length = -1LL;\r\nelse\r\nbm.bmv_length = BTOBB(length);\r\nbm.bmv_count = !fieinfo->fi_extents_max ? MAXEXTNUM :\r\nfieinfo->fi_extents_max + 1;\r\nbm.bmv_count = min_t(__s32, bm.bmv_count,\r\n(PAGE_SIZE * 16 / sizeof(struct getbmapx)));\r\nbm.bmv_iflags = BMV_IF_PREALLOC | BMV_IF_NO_HOLES;\r\nif (fieinfo->fi_flags & FIEMAP_FLAG_XATTR)\r\nbm.bmv_iflags |= BMV_IF_ATTRFORK;\r\nif (!(fieinfo->fi_flags & FIEMAP_FLAG_SYNC))\r\nbm.bmv_iflags |= BMV_IF_DELALLOC;\r\nerror = xfs_getbmap(ip, &bm, xfs_fiemap_format, fieinfo);\r\nif (error)\r\nreturn -error;\r\nreturn 0;\r\n}\r\nSTATIC void\r\nxfs_diflags_to_iflags(\r\nstruct inode *inode,\r\nstruct xfs_inode *ip)\r\n{\r\nif (ip->i_d.di_flags & XFS_DIFLAG_IMMUTABLE)\r\ninode->i_flags |= S_IMMUTABLE;\r\nelse\r\ninode->i_flags &= ~S_IMMUTABLE;\r\nif (ip->i_d.di_flags & XFS_DIFLAG_APPEND)\r\ninode->i_flags |= S_APPEND;\r\nelse\r\ninode->i_flags &= ~S_APPEND;\r\nif (ip->i_d.di_flags & XFS_DIFLAG_SYNC)\r\ninode->i_flags |= S_SYNC;\r\nelse\r\ninode->i_flags &= ~S_SYNC;\r\nif (ip->i_d.di_flags & XFS_DIFLAG_NOATIME)\r\ninode->i_flags |= S_NOATIME;\r\nelse\r\ninode->i_flags &= ~S_NOATIME;\r\n}\r\nvoid\r\nxfs_setup_inode(\r\nstruct xfs_inode *ip)\r\n{\r\nstruct inode *inode = &ip->i_vnode;\r\ninode->i_ino = ip->i_ino;\r\ninode->i_state = I_NEW;\r\ninode_sb_list_add(inode);\r\nhlist_add_fake(&inode->i_hash);\r\ninode->i_mode = ip->i_d.di_mode;\r\nset_nlink(inode, ip->i_d.di_nlink);\r\ninode->i_uid = ip->i_d.di_uid;\r\ninode->i_gid = ip->i_d.di_gid;\r\nswitch (inode->i_mode & S_IFMT) {\r\ncase S_IFBLK:\r\ncase S_IFCHR:\r\ninode->i_rdev =\r\nMKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,\r\nsysv_minor(ip->i_df.if_u2.if_rdev));\r\nbreak;\r\ndefault:\r\ninode->i_rdev = 0;\r\nbreak;\r\n}\r\ninode->i_generation = ip->i_d.di_gen;\r\ni_size_write(inode, ip->i_d.di_size);\r\ninode->i_atime.tv_sec = ip->i_d.di_atime.t_sec;\r\ninode->i_atime.tv_nsec = ip->i_d.di_atime.t_nsec;\r\ninode->i_mtime.tv_sec = ip->i_d.di_mtime.t_sec;\r\ninode->i_mtime.tv_nsec = ip->i_d.di_mtime.t_nsec;\r\ninode->i_ctime.tv_sec = ip->i_d.di_ctime.t_sec;\r\ninode->i_ctime.tv_nsec = ip->i_d.di_ctime.t_nsec;\r\nxfs_diflags_to_iflags(inode, ip);\r\nswitch (inode->i_mode & S_IFMT) {\r\ncase S_IFREG:\r\ninode->i_op = &xfs_inode_operations;\r\ninode->i_fop = &xfs_file_operations;\r\ninode->i_mapping->a_ops = &xfs_address_space_operations;\r\nbreak;\r\ncase S_IFDIR:\r\nif (xfs_sb_version_hasasciici(&XFS_M(inode->i_sb)->m_sb))\r\ninode->i_op = &xfs_dir_ci_inode_operations;\r\nelse\r\ninode->i_op = &xfs_dir_inode_operations;\r\ninode->i_fop = &xfs_dir_file_operations;\r\nbreak;\r\ncase S_IFLNK:\r\ninode->i_op = &xfs_symlink_inode_operations;\r\nif (!(ip->i_df.if_flags & XFS_IFINLINE))\r\ninode->i_mapping->a_ops = &xfs_address_space_operations;\r\nbreak;\r\ndefault:\r\ninode->i_op = &xfs_inode_operations;\r\ninit_special_inode(inode, inode->i_mode, inode->i_rdev);\r\nbreak;\r\n}\r\nif (!XFS_IFORK_Q(ip)) {\r\ninode_has_no_xattr(inode);\r\ncache_no_acl(inode);\r\n}\r\nxfs_iflags_clear(ip, XFS_INEW);\r\nbarrier();\r\nunlock_new_inode(inode);\r\n}
