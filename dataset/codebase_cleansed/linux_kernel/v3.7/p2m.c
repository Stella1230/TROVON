int solo_p2m_dma(struct solo_dev *solo_dev, u8 id, int wr,\r\nvoid *sys_addr, u32 ext_addr, u32 size)\r\n{\r\ndma_addr_t dma_addr;\r\nint ret;\r\nWARN_ON(!size);\r\nBUG_ON(id >= SOLO_NR_P2M);\r\nif (!size)\r\nreturn -EINVAL;\r\ndma_addr = pci_map_single(solo_dev->pdev, sys_addr, size,\r\nwr ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE);\r\nret = solo_p2m_dma_t(solo_dev, id, wr, dma_addr, ext_addr, size);\r\npci_unmap_single(solo_dev->pdev, dma_addr, size,\r\nwr ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE);\r\nreturn ret;\r\n}\r\nint solo_p2m_dma_t(struct solo_dev *solo_dev, u8 id, int wr,\r\ndma_addr_t dma_addr, u32 ext_addr, u32 size)\r\n{\r\nstruct p2m_desc *desc = kzalloc(sizeof(*desc) * 2, GFP_DMA);\r\nint ret;\r\nif (desc == NULL)\r\nreturn -ENOMEM;\r\nsolo_p2m_push_desc(&desc[1], wr, dma_addr, ext_addr, size, 0, 0);\r\nret = solo_p2m_dma_desc(solo_dev, id, desc, 2);\r\nkfree(desc);\r\nreturn ret;\r\n}\r\nvoid solo_p2m_push_desc(struct p2m_desc *desc, int wr, dma_addr_t dma_addr,\r\nu32 ext_addr, u32 size, int repeat, u32 ext_size)\r\n{\r\ndesc->ta = cpu_to_le32(dma_addr);\r\ndesc->fa = cpu_to_le32(ext_addr);\r\ndesc->ext = cpu_to_le32(SOLO_P2M_COPY_SIZE(size >> 2));\r\ndesc->ctrl = cpu_to_le32(SOLO_P2M_BURST_SIZE(SOLO_P2M_BURST_256) |\r\n(wr ? SOLO_P2M_WRITE : 0) | SOLO_P2M_TRANS_ON);\r\nif (repeat) {\r\ndesc->ext |= cpu_to_le32(SOLO_P2M_EXT_INC(ext_size >> 2));\r\ndesc->ctrl |= cpu_to_le32(SOLO_P2M_PCI_INC(size >> 2) |\r\nSOLO_P2M_REPEAT(repeat));\r\n}\r\n}\r\nint solo_p2m_dma_desc(struct solo_dev *solo_dev, u8 id,\r\nstruct p2m_desc *desc, int desc_count)\r\n{\r\nstruct solo_p2m_dev *p2m_dev;\r\nunsigned int timeout;\r\nint ret = 0;\r\nu32 config = 0;\r\ndma_addr_t desc_dma = 0;\r\nBUG_ON(id >= SOLO_NR_P2M);\r\nBUG_ON(!desc_count || desc_count > SOLO_NR_P2M_DESC);\r\np2m_dev = &solo_dev->p2m_dev[id];\r\nmutex_lock(&p2m_dev->mutex);\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(id), 0);\r\nINIT_COMPLETION(p2m_dev->completion);\r\np2m_dev->error = 0;\r\nconfig = solo_reg_read(solo_dev, SOLO_P2M_CONFIG(id));\r\ndesc_dma = pci_map_single(solo_dev->pdev, desc,\r\ndesc_count * sizeof(*desc),\r\nPCI_DMA_TODEVICE);\r\nsolo_reg_write(solo_dev, SOLO_P2M_DES_ADR(id), desc_dma);\r\nsolo_reg_write(solo_dev, SOLO_P2M_DESC_ID(id), desc_count - 1);\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONFIG(id), config |\r\nSOLO_P2M_DESC_MODE);\r\ntimeout = wait_for_completion_timeout(&p2m_dev->completion, HZ);\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(id), 0);\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONFIG(id), config);\r\nsolo_reg_write(solo_dev, SOLO_P2M_DESC_ID(id), 0);\r\nsolo_reg_write(solo_dev, SOLO_P2M_DES_ADR(id), 0);\r\npci_unmap_single(solo_dev->pdev, desc_dma,\r\ndesc_count * sizeof(*desc),\r\nPCI_DMA_TODEVICE);\r\nif (p2m_dev->error)\r\nret = -EIO;\r\nelse if (timeout == 0)\r\nret = -EAGAIN;\r\nmutex_unlock(&p2m_dev->mutex);\r\nWARN_ON_ONCE(ret);\r\nreturn ret;\r\n}\r\nint solo_p2m_dma_sg(struct solo_dev *solo_dev, u8 id,\r\nstruct p2m_desc *pdesc, int wr,\r\nstruct scatterlist *sg, u32 sg_off,\r\nu32 ext_addr, u32 size)\r\n{\r\nint i;\r\nint idx;\r\nBUG_ON(id >= SOLO_NR_P2M);\r\nif (WARN_ON_ONCE(!size))\r\nreturn -EINVAL;\r\nmemset(pdesc, 0, sizeof(*pdesc));\r\nfor (i = 0, idx = 1; idx < SOLO_NR_P2M_DESC && sg && size > 0;\r\ni++, sg = sg_next(sg)) {\r\nstruct p2m_desc *desc = &pdesc[idx];\r\nu32 sg_len = sg_dma_len(sg);\r\nu32 len;\r\nif (sg_off >= sg_len) {\r\nsg_off -= sg_len;\r\ncontinue;\r\n}\r\nsg_len -= sg_off;\r\nlen = min(sg_len, size);\r\nsolo_p2m_push_desc(desc, wr, sg_dma_address(sg) + sg_off,\r\next_addr, len, 0, 0);\r\nsize -= len;\r\next_addr += len;\r\nidx++;\r\nsg_off = 0;\r\n}\r\nWARN_ON_ONCE(size || i >= SOLO_NR_P2M_DESC);\r\nreturn solo_p2m_dma_desc(solo_dev, id, pdesc, idx);\r\n}\r\nstatic unsigned long long p2m_test(struct solo_dev *solo_dev, u8 id,\r\nu32 base, int size)\r\n{\r\nu8 *wr_buf;\r\nu8 *rd_buf;\r\nint i;\r\nunsigned long long err_cnt = 0;\r\nwr_buf = kmalloc(size, GFP_KERNEL);\r\nif (!wr_buf) {\r\nprintk(SOLO6X10_NAME ": Failed to malloc for p2m_test\n");\r\nreturn size;\r\n}\r\nrd_buf = kmalloc(size, GFP_KERNEL);\r\nif (!rd_buf) {\r\nprintk(SOLO6X10_NAME ": Failed to malloc for p2m_test\n");\r\nkfree(wr_buf);\r\nreturn size;\r\n}\r\nmemset(wr_buf, P2M_TEST_CHAR, size);\r\nmemset(rd_buf, P2M_TEST_CHAR + 1, size);\r\nsolo_p2m_dma(solo_dev, id, 1, wr_buf, base, size);\r\nsolo_p2m_dma(solo_dev, id, 0, rd_buf, base, size);\r\nfor (i = 0; i < size; i++)\r\nif (wr_buf[i] != rd_buf[i])\r\nerr_cnt++;\r\nkfree(wr_buf);\r\nkfree(rd_buf);\r\nreturn err_cnt;\r\n}\r\nstatic void run_p2m_test(struct solo_dev *solo_dev)\r\n{\r\nunsigned long long errs = 0;\r\nu32 size = SOLO_JPEG_EXT_ADDR(solo_dev) + SOLO_JPEG_EXT_SIZE(solo_dev);\r\nint i, d;\r\nprintk(KERN_WARNING "%s: Testing %u bytes of external ram\n",\r\nSOLO6X10_NAME, size);\r\nfor (i = 0; i < size; i += TEST_CHUNK_SIZE)\r\nfor (d = 0; d < 4; d++)\r\nerrs += p2m_test(solo_dev, d, i, TEST_CHUNK_SIZE);\r\nprintk(KERN_WARNING "%s: Found %llu errors during p2m test\n",\r\nSOLO6X10_NAME, errs);\r\nreturn;\r\n}\r\nvoid solo_p2m_isr(struct solo_dev *solo_dev, int id)\r\n{\r\nstruct solo_p2m_dev *p2m_dev = &solo_dev->p2m_dev[id];\r\nsolo_reg_write(solo_dev, SOLO_IRQ_STAT, SOLO_IRQ_P2M(id));\r\ncomplete(&p2m_dev->completion);\r\n}\r\nvoid solo_p2m_error_isr(struct solo_dev *solo_dev, u32 status)\r\n{\r\nstruct solo_p2m_dev *p2m_dev;\r\nint i;\r\nif (!(status & SOLO_PCI_ERR_P2M))\r\nreturn;\r\nfor (i = 0; i < SOLO_NR_P2M; i++) {\r\np2m_dev = &solo_dev->p2m_dev[i];\r\np2m_dev->error = 1;\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(i), 0);\r\ncomplete(&p2m_dev->completion);\r\n}\r\n}\r\nvoid solo_p2m_exit(struct solo_dev *solo_dev)\r\n{\r\nint i;\r\nfor (i = 0; i < SOLO_NR_P2M; i++)\r\nsolo_irq_off(solo_dev, SOLO_IRQ_P2M(i));\r\n}\r\nint solo_p2m_init(struct solo_dev *solo_dev)\r\n{\r\nstruct solo_p2m_dev *p2m_dev;\r\nint i;\r\nfor (i = 0; i < SOLO_NR_P2M; i++) {\r\np2m_dev = &solo_dev->p2m_dev[i];\r\nmutex_init(&p2m_dev->mutex);\r\ninit_completion(&p2m_dev->completion);\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONTROL(i), 0);\r\nsolo_reg_write(solo_dev, SOLO_P2M_CONFIG(i),\r\nSOLO_P2M_CSC_16BIT_565 |\r\nSOLO_P2M_DMA_INTERVAL(3) |\r\nSOLO_P2M_DESC_INTR_OPT |\r\nSOLO_P2M_PCI_MASTER_MODE);\r\nsolo_irq_on(solo_dev, SOLO_IRQ_P2M(i));\r\n}\r\nrun_p2m_test(solo_dev);\r\nreturn 0;\r\n}
