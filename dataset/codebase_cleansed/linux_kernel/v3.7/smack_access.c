int smk_access_entry(char *subject_label, char *object_label,\r\nstruct list_head *rule_list)\r\n{\r\nint may = -ENOENT;\r\nstruct smack_rule *srp;\r\nlist_for_each_entry_rcu(srp, rule_list, list) {\r\nif (srp->smk_object == object_label &&\r\nsrp->smk_subject == subject_label) {\r\nmay = srp->smk_access;\r\nbreak;\r\n}\r\n}\r\nreturn may;\r\n}\r\nint smk_access(char *subject_label, char *object_label, int request,\r\nstruct smk_audit_info *a)\r\n{\r\nstruct smack_known *skp;\r\nint may = MAY_NOT;\r\nint rc = 0;\r\nif (subject_label == smack_known_star.smk_known) {\r\nrc = -EACCES;\r\ngoto out_audit;\r\n}\r\nif (object_label == smack_known_web.smk_known ||\r\nsubject_label == smack_known_web.smk_known)\r\ngoto out_audit;\r\nif (object_label == smack_known_star.smk_known)\r\ngoto out_audit;\r\nif (subject_label == object_label)\r\ngoto out_audit;\r\nif ((request & MAY_ANYREAD) == request) {\r\nif (object_label == smack_known_floor.smk_known)\r\ngoto out_audit;\r\nif (subject_label == smack_known_hat.smk_known)\r\ngoto out_audit;\r\n}\r\nskp = smk_find_entry(subject_label);\r\nrcu_read_lock();\r\nmay = smk_access_entry(subject_label, object_label, &skp->smk_rules);\r\nrcu_read_unlock();\r\nif (may > 0 && (request & may) == request)\r\ngoto out_audit;\r\nrc = -EACCES;\r\nout_audit:\r\n#ifdef CONFIG_AUDIT\r\nif (a)\r\nsmack_log(subject_label, object_label, request, rc, a);\r\n#endif\r\nreturn rc;\r\n}\r\nint smk_curacc(char *obj_label, u32 mode, struct smk_audit_info *a)\r\n{\r\nstruct task_smack *tsp = current_security();\r\nchar *sp = smk_of_task(tsp);\r\nint may;\r\nint rc;\r\nrc = smk_access(sp, obj_label, mode, NULL);\r\nif (rc == 0) {\r\nmay = smk_access_entry(sp, obj_label, &tsp->smk_rules);\r\nif (may < 0)\r\ngoto out_audit;\r\nif ((mode & may) == mode)\r\ngoto out_audit;\r\nrc = -EACCES;\r\n}\r\nif (rc != 0 && smack_privileged(CAP_MAC_OVERRIDE))\r\nrc = 0;\r\nout_audit:\r\n#ifdef CONFIG_AUDIT\r\nif (a)\r\nsmack_log(sp, obj_label, mode, rc, a);\r\n#endif\r\nreturn rc;\r\n}\r\nstatic inline void smack_str_from_perm(char *string, int access)\r\n{\r\nint i = 0;\r\nif (access & MAY_READ)\r\nstring[i++] = 'r';\r\nif (access & MAY_WRITE)\r\nstring[i++] = 'w';\r\nif (access & MAY_EXEC)\r\nstring[i++] = 'x';\r\nif (access & MAY_APPEND)\r\nstring[i++] = 'a';\r\nstring[i] = '\0';\r\n}\r\nstatic void smack_log_callback(struct audit_buffer *ab, void *a)\r\n{\r\nstruct common_audit_data *ad = a;\r\nstruct smack_audit_data *sad = ad->smack_audit_data;\r\naudit_log_format(ab, "lsm=SMACK fn=%s action=%s",\r\nad->smack_audit_data->function,\r\nsad->result ? "denied" : "granted");\r\naudit_log_format(ab, " subject=");\r\naudit_log_untrustedstring(ab, sad->subject);\r\naudit_log_format(ab, " object=");\r\naudit_log_untrustedstring(ab, sad->object);\r\naudit_log_format(ab, " requested=%s", sad->request);\r\n}\r\nvoid smack_log(char *subject_label, char *object_label, int request,\r\nint result, struct smk_audit_info *ad)\r\n{\r\nchar request_buffer[SMK_NUM_ACCESS_TYPE + 1];\r\nstruct smack_audit_data *sad;\r\nstruct common_audit_data *a = &ad->a;\r\nif (result != 0 && (log_policy & SMACK_AUDIT_DENIED) == 0)\r\nreturn;\r\nif (result == 0 && (log_policy & SMACK_AUDIT_ACCEPT) == 0)\r\nreturn;\r\nsad = a->smack_audit_data;\r\nif (sad->function == NULL)\r\nsad->function = "unknown";\r\nsmack_str_from_perm(request_buffer, request);\r\nsad->subject = subject_label;\r\nsad->object = object_label;\r\nsad->request = request_buffer;\r\nsad->result = result;\r\ncommon_lsm_audit(a, smack_log_callback, NULL);\r\n}\r\nvoid smack_log(char *subject_label, char *object_label, int request,\r\nint result, struct smk_audit_info *ad)\r\n{\r\n}\r\nstruct smack_known *smk_find_entry(const char *string)\r\n{\r\nstruct smack_known *skp;\r\nlist_for_each_entry_rcu(skp, &smack_known_list, list) {\r\nif (strcmp(skp->smk_known, string) == 0)\r\nreturn skp;\r\n}\r\nreturn NULL;\r\n}\r\nchar *smk_parse_smack(const char *string, int len)\r\n{\r\nchar *smack;\r\nint i;\r\nif (len <= 0)\r\nlen = strlen(string) + 1;\r\nif (string[0] == '-')\r\nreturn NULL;\r\nfor (i = 0; i < len; i++)\r\nif (string[i] > '~' || string[i] <= ' ' || string[i] == '/' ||\r\nstring[i] == '"' || string[i] == '\\' || string[i] == '\'')\r\nbreak;\r\nif (i == 0 || i >= SMK_LONGLABEL)\r\nreturn NULL;\r\nsmack = kzalloc(i + 1, GFP_KERNEL);\r\nif (smack != NULL) {\r\nstrncpy(smack, string, i + 1);\r\nsmack[i] = '\0';\r\n}\r\nreturn smack;\r\n}\r\nint smk_netlbl_mls(int level, char *catset, struct netlbl_lsm_secattr *sap,\r\nint len)\r\n{\r\nunsigned char *cp;\r\nunsigned char m;\r\nint cat;\r\nint rc;\r\nint byte;\r\nsap->flags |= NETLBL_SECATTR_MLS_CAT;\r\nsap->attr.mls.lvl = level;\r\nsap->attr.mls.cat = netlbl_secattr_catmap_alloc(GFP_ATOMIC);\r\nsap->attr.mls.cat->startbit = 0;\r\nfor (cat = 1, cp = catset, byte = 0; byte < len; cp++, byte++)\r\nfor (m = 0x80; m != 0; m >>= 1, cat++) {\r\nif ((m & *cp) == 0)\r\ncontinue;\r\nrc = netlbl_secattr_catmap_setbit(sap->attr.mls.cat,\r\ncat, GFP_ATOMIC);\r\nif (rc < 0) {\r\nnetlbl_secattr_catmap_free(sap->attr.mls.cat);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstruct smack_known *smk_import_entry(const char *string, int len)\r\n{\r\nstruct smack_known *skp;\r\nchar *smack;\r\nint slen;\r\nint rc;\r\nsmack = smk_parse_smack(string, len);\r\nif (smack == NULL)\r\nreturn NULL;\r\nmutex_lock(&smack_known_lock);\r\nskp = smk_find_entry(smack);\r\nif (skp != NULL)\r\ngoto freeout;\r\nskp = kzalloc(sizeof(*skp), GFP_KERNEL);\r\nif (skp == NULL)\r\ngoto freeout;\r\nskp->smk_known = smack;\r\nskp->smk_secid = smack_next_secid++;\r\nskp->smk_netlabel.domain = skp->smk_known;\r\nskp->smk_netlabel.flags =\r\nNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\r\nslen = strlen(smack);\r\nif (slen < SMK_CIPSOLEN)\r\nrc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\r\n&skp->smk_netlabel, slen);\r\nelse\r\nrc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\r\n&skp->smk_netlabel, sizeof(skp->smk_secid));\r\nif (rc >= 0) {\r\nINIT_LIST_HEAD(&skp->smk_rules);\r\nmutex_init(&skp->smk_rules_lock);\r\nlist_add_rcu(&skp->list, &smack_known_list);\r\ngoto unlockout;\r\n}\r\nkfree(skp);\r\nskp = NULL;\r\nfreeout:\r\nkfree(smack);\r\nunlockout:\r\nmutex_unlock(&smack_known_lock);\r\nreturn skp;\r\n}\r\nchar *smk_import(const char *string, int len)\r\n{\r\nstruct smack_known *skp;\r\nif (string[0] == '-')\r\nreturn NULL;\r\nskp = smk_import_entry(string, len);\r\nif (skp == NULL)\r\nreturn NULL;\r\nreturn skp->smk_known;\r\n}\r\nchar *smack_from_secid(const u32 secid)\r\n{\r\nstruct smack_known *skp;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(skp, &smack_known_list, list) {\r\nif (skp->smk_secid == secid) {\r\nrcu_read_unlock();\r\nreturn skp->smk_known;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn smack_known_invalid.smk_known;\r\n}\r\nu32 smack_to_secid(const char *smack)\r\n{\r\nstruct smack_known *skp = smk_find_entry(smack);\r\nif (skp == NULL)\r\nreturn 0;\r\nreturn skp->smk_secid;\r\n}
