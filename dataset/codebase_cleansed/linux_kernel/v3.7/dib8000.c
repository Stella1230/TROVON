static u16 dib8000_i2c_read16(struct i2c_device *i2c, u16 reg)\r\n{\r\nu16 ret;\r\nstruct i2c_msg msg[2] = {\r\n{.addr = i2c->addr >> 1, .flags = 0, .len = 2},\r\n{.addr = i2c->addr >> 1, .flags = I2C_M_RD, .len = 2},\r\n};\r\nif (mutex_lock_interruptible(i2c->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn 0;\r\n}\r\nmsg[0].buf = i2c->i2c_write_buffer;\r\nmsg[0].buf[0] = reg >> 8;\r\nmsg[0].buf[1] = reg & 0xff;\r\nmsg[1].buf = i2c->i2c_read_buffer;\r\nif (i2c_transfer(i2c->adap, msg, 2) != 2)\r\ndprintk("i2c read error on %d", reg);\r\nret = (msg[1].buf[0] << 8) | msg[1].buf[1];\r\nmutex_unlock(i2c->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic u16 dib8000_read_word(struct dib8000_state *state, u16 reg)\r\n{\r\nu16 ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn 0;\r\n}\r\nstate->i2c_write_buffer[0] = reg >> 8;\r\nstate->i2c_write_buffer[1] = reg & 0xff;\r\nmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->i2c.addr >> 1;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 2;\r\nstate->msg[1].addr = state->i2c.addr >> 1;\r\nstate->msg[1].flags = I2C_M_RD;\r\nstate->msg[1].buf = state->i2c_read_buffer;\r\nstate->msg[1].len = 2;\r\nif (i2c_transfer(state->i2c.adap, state->msg, 2) != 2)\r\ndprintk("i2c read error on %d", reg);\r\nret = (state->i2c_read_buffer[0] << 8) | state->i2c_read_buffer[1];\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic u32 dib8000_read32(struct dib8000_state *state, u16 reg)\r\n{\r\nu16 rw[2];\r\nrw[0] = dib8000_read_word(state, reg + 0);\r\nrw[1] = dib8000_read_word(state, reg + 1);\r\nreturn ((rw[0] << 16) | (rw[1]));\r\n}\r\nstatic int dib8000_i2c_write16(struct i2c_device *i2c, u16 reg, u16 val)\r\n{\r\nstruct i2c_msg msg = {.addr = i2c->addr >> 1, .flags = 0, .len = 4};\r\nint ret = 0;\r\nif (mutex_lock_interruptible(i2c->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn -EINVAL;\r\n}\r\nmsg.buf = i2c->i2c_write_buffer;\r\nmsg.buf[0] = (reg >> 8) & 0xff;\r\nmsg.buf[1] = reg & 0xff;\r\nmsg.buf[2] = (val >> 8) & 0xff;\r\nmsg.buf[3] = val & 0xff;\r\nret = i2c_transfer(i2c->adap, &msg, 1) != 1 ? -EREMOTEIO : 0;\r\nmutex_unlock(i2c->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic int dib8000_write_word(struct dib8000_state *state, u16 reg, u16 val)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn -EINVAL;\r\n}\r\nstate->i2c_write_buffer[0] = (reg >> 8) & 0xff;\r\nstate->i2c_write_buffer[1] = reg & 0xff;\r\nstate->i2c_write_buffer[2] = (val >> 8) & 0xff;\r\nstate->i2c_write_buffer[3] = val & 0xff;\r\nmemset(&state->msg[0], 0, sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->i2c.addr >> 1;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 4;\r\nret = (i2c_transfer(state->i2c.adap, state->msg, 1) != 1 ?\r\n-EREMOTEIO : 0);\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic u16 fft_to_mode(struct dib8000_state *state)\r\n{\r\nu16 mode;\r\nswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nmode = 1;\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nmode = 2;\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_AUTO:\r\ncase TRANSMISSION_MODE_8K:\r\nmode = 3;\r\nbreak;\r\n}\r\nreturn mode;\r\n}\r\nstatic void dib8000_set_acquisition_mode(struct dib8000_state *state)\r\n{\r\nu16 nud = dib8000_read_word(state, 298);\r\nnud |= (1 << 3) | (1 << 0);\r\ndprintk("acquisition mode activated");\r\ndib8000_write_word(state, 298, nud);\r\n}\r\nstatic int dib8000_set_output_mode(struct dvb_frontend *fe, int mode)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 outreg, fifo_threshold, smo_mode, sram = 0x0205;\r\noutreg = 0;\r\nfifo_threshold = 1792;\r\nsmo_mode = (dib8000_read_word(state, 299) & 0x0050) | (1 << 1);\r\ndprintk("-I- Setting output mode for demod %p to %d",\r\n&state->fe[0], mode);\r\nswitch (mode) {\r\ncase OUTMODE_MPEG2_PAR_GATED_CLK:\r\noutreg = (1 << 10);\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_CONT_CLK:\r\noutreg = (1 << 10) | (1 << 6);\r\nbreak;\r\ncase OUTMODE_MPEG2_SERIAL:\r\noutreg = (1 << 10) | (2 << 6) | (0 << 1);\r\nbreak;\r\ncase OUTMODE_DIVERSITY:\r\nif (state->cfg.hostbus_diversity) {\r\noutreg = (1 << 10) | (4 << 6);\r\nsram &= 0xfdff;\r\n} else\r\nsram |= 0x0c00;\r\nbreak;\r\ncase OUTMODE_MPEG2_FIFO:\r\nsmo_mode |= (3 << 1);\r\nfifo_threshold = 512;\r\noutreg = (1 << 10) | (5 << 6);\r\nbreak;\r\ncase OUTMODE_HIGH_Z:\r\noutreg = 0;\r\nbreak;\r\ncase OUTMODE_ANALOG_ADC:\r\noutreg = (1 << 10) | (3 << 6);\r\ndib8000_set_acquisition_mode(state);\r\nbreak;\r\ndefault:\r\ndprintk("Unhandled output_mode passed to be set for demod %p",\r\n&state->fe[0]);\r\nreturn -EINVAL;\r\n}\r\nif (state->cfg.output_mpeg2_in_188_bytes)\r\nsmo_mode |= (1 << 5);\r\ndib8000_write_word(state, 299, smo_mode);\r\ndib8000_write_word(state, 300, fifo_threshold);\r\ndib8000_write_word(state, 1286, outreg);\r\ndib8000_write_word(state, 1291, sram);\r\nreturn 0;\r\n}\r\nstatic int dib8000_set_diversity_in(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 sync_wait = dib8000_read_word(state, 273) & 0xfff0;\r\nif (!state->differential_constellation) {\r\ndib8000_write_word(state, 272, 1 << 9);\r\ndib8000_write_word(state, 273, sync_wait | (1 << 2) | 2);\r\n} else {\r\ndib8000_write_word(state, 272, 0);\r\ndib8000_write_word(state, 273, sync_wait);\r\n}\r\nstate->diversity_onoff = onoff;\r\nswitch (onoff) {\r\ncase 0:\r\ndib8000_write_word(state, 270, 1);\r\ndib8000_write_word(state, 271, 0);\r\nbreak;\r\ncase 1:\r\ndib8000_write_word(state, 270, 6);\r\ndib8000_write_word(state, 271, 6);\r\nbreak;\r\ncase 2:\r\ndib8000_write_word(state, 270, 0);\r\ndib8000_write_word(state, 271, 1);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dib8000_set_power_mode(struct dib8000_state *state, enum dib8000_power_mode mode)\r\n{\r\nu16 reg_774 = 0x3fff, reg_775 = 0xffff, reg_776 = 0xffff,\r\nreg_900 = (dib8000_read_word(state, 900) & 0xfffc) | 0x3,\r\nreg_1280;\r\nif (state->revision != 0x8090)\r\nreg_1280 = (dib8000_read_word(state, 1280) & 0x00ff) | 0xff00;\r\nelse\r\nreg_1280 = (dib8000_read_word(state, 1280) & 0x707f) | 0x8f80;\r\nswitch (mode) {\r\ncase DIB8000_POWER_ALL:\r\nreg_774 = 0x0000;\r\nreg_775 = 0x0000;\r\nreg_776 = 0x0000;\r\nreg_900 &= 0xfffc;\r\nif (state->revision != 0x8090)\r\nreg_1280 &= 0x00ff;\r\nelse\r\nreg_1280 &= 0x707f;\r\nbreak;\r\ncase DIB8000_POWER_INTERFACE_ONLY:\r\nif (state->revision != 0x8090)\r\nreg_1280 &= 0x00ff;\r\nelse\r\nreg_1280 &= 0xfa7b;\r\nbreak;\r\n}\r\ndprintk("powermode : 774 : %x ; 775 : %x; 776 : %x ; 900 : %x; 1280 : %x", reg_774, reg_775, reg_776, reg_900, reg_1280);\r\ndib8000_write_word(state, 774, reg_774);\r\ndib8000_write_word(state, 775, reg_775);\r\ndib8000_write_word(state, 776, reg_776);\r\ndib8000_write_word(state, 900, reg_900);\r\ndib8000_write_word(state, 1280, reg_1280);\r\n}\r\nstatic int dib8000_init_sdram(struct dib8000_state *state)\r\n{\r\nu16 reg = 0;\r\ndprintk("Init sdram");\r\nreg = dib8000_read_word(state, 274)&0xfff0;\r\ndib8000_write_word(state, 274, reg | 0x7);\r\ndib8000_write_word(state, 1803, (7<<2));\r\nreg = dib8000_read_word(state, 1280);\r\ndib8000_write_word(state, 1280, reg | (1<<2));\r\ndib8000_write_word(state, 1280, reg);\r\nreturn 0;\r\n}\r\nstatic int dib8000_set_adc_state(struct dib8000_state *state, enum dibx000_adc_states no)\r\n{\r\nint ret = 0;\r\nu16 reg, reg_907 = dib8000_read_word(state, 907);\r\nu16 reg_908 = dib8000_read_word(state, 908);\r\nswitch (no) {\r\ncase DIBX000_SLOW_ADC_ON:\r\nif (state->revision != 0x8090) {\r\nreg_908 |= (1 << 1) | (1 << 0);\r\nret |= dib8000_write_word(state, 908, reg_908);\r\nreg_908 &= ~(1 << 1);\r\n} else {\r\nreg = dib8000_read_word(state, 1925);\r\ndib8000_write_word(state, 1925, reg |\r\n(1<<4) | (1<<2));\r\nreg = dib8000_read_word(state, 1925);\r\nmsleep(20);\r\ndib8000_write_word(state, 1925, reg & ~(1<<4));\r\nreg = dib8000_read_word(state, 921) & ~((0x3 << 14)\r\n| (0x3 << 12));\r\ndib8000_write_word(state, 921, reg | (1 << 14)\r\n| (3 << 12));\r\n}\r\nbreak;\r\ncase DIBX000_SLOW_ADC_OFF:\r\nif (state->revision == 0x8090) {\r\nreg = dib8000_read_word(state, 1925);\r\ndib8000_write_word(state, 1925,\r\n(reg & ~(1<<2)) | (1<<4));\r\n}\r\nreg_908 |= (1 << 1) | (1 << 0);\r\nbreak;\r\ncase DIBX000_ADC_ON:\r\nreg_907 &= 0x0fff;\r\nreg_908 &= 0x0003;\r\nbreak;\r\ncase DIBX000_ADC_OFF:\r\nreg_907 |= (1 << 14) | (1 << 13) | (1 << 12);\r\nreg_908 |= (1 << 5) | (1 << 4) | (1 << 3) | (1 << 2);\r\nbreak;\r\ncase DIBX000_VBG_ENABLE:\r\nreg_907 &= ~(1 << 15);\r\nbreak;\r\ncase DIBX000_VBG_DISABLE:\r\nreg_907 |= (1 << 15);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret |= dib8000_write_word(state, 907, reg_907);\r\nret |= dib8000_write_word(state, 908, reg_908);\r\nreturn ret;\r\n}\r\nstatic int dib8000_set_bandwidth(struct dvb_frontend *fe, u32 bw)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu32 timf;\r\nif (bw == 0)\r\nbw = 6000;\r\nif (state->timf == 0) {\r\ndprintk("using default timf");\r\ntimf = state->timf_default;\r\n} else {\r\ndprintk("using updated timf");\r\ntimf = state->timf;\r\n}\r\ndib8000_write_word(state, 29, (u16) ((timf >> 16) & 0xffff));\r\ndib8000_write_word(state, 30, (u16) ((timf) & 0xffff));\r\nreturn 0;\r\n}\r\nstatic int dib8000_sad_calib(struct dib8000_state *state)\r\n{\r\nif (state->revision == 0x8090) {\r\ndprintk("%s: the sad calibration is not needed for the dib8096P",\r\n__func__);\r\nreturn 0;\r\n}\r\ndib8000_write_word(state, 923, (0 << 1) | (0 << 0));\r\ndib8000_write_word(state, 924, 776);\r\ndib8000_write_word(state, 923, (1 << 0));\r\ndib8000_write_word(state, 923, (0 << 0));\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nint dib8000_set_wbd_ref(struct dvb_frontend *fe, u16 value)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif (value > 4095)\r\nvalue = 4095;\r\nstate->wbd_ref = value;\r\nreturn dib8000_write_word(state, 106, value);\r\n}\r\nstatic void dib8000_reset_pll_common(struct dib8000_state *state, const struct dibx000_bandwidth_config *bw)\r\n{\r\ndprintk("ifreq: %d %x, inversion: %d", bw->ifreq, bw->ifreq, bw->ifreq >> 25);\r\nif (state->revision != 0x8090) {\r\ndib8000_write_word(state, 23,\r\n(u16) (((bw->internal * 1000) >> 16) & 0xffff));\r\ndib8000_write_word(state, 24,\r\n(u16) ((bw->internal * 1000) & 0xffff));\r\n} else {\r\ndib8000_write_word(state, 23, (u16) (((bw->internal / 2 * 1000) >> 16) & 0xffff));\r\ndib8000_write_word(state, 24,\r\n(u16) ((bw->internal / 2 * 1000) & 0xffff));\r\n}\r\ndib8000_write_word(state, 27, (u16) ((bw->ifreq >> 16) & 0x01ff));\r\ndib8000_write_word(state, 28, (u16) (bw->ifreq & 0xffff));\r\ndib8000_write_word(state, 26, (u16) ((bw->ifreq >> 25) & 0x0003));\r\nif (state->revision != 0x8090)\r\ndib8000_write_word(state, 922, bw->sad_cfg);\r\n}\r\nstatic void dib8000_reset_pll(struct dib8000_state *state)\r\n{\r\nconst struct dibx000_bandwidth_config *pll = state->cfg.pll;\r\nu16 clk_cfg1, reg;\r\nif (state->revision != 0x8090) {\r\ndib8000_write_word(state, 901,\r\n(pll->pll_prediv << 8) | (pll->pll_ratio << 0));\r\nclk_cfg1 = (1 << 10) | (0 << 9) | (pll->IO_CLK_en_core << 8) |\r\n(pll->bypclk_div << 5) | (pll->enable_refdiv << 4) |\r\n(1 << 3) | (pll->pll_range << 1) |\r\n(pll->pll_reset << 0);\r\ndib8000_write_word(state, 902, clk_cfg1);\r\nclk_cfg1 = (clk_cfg1 & 0xfff7) | (pll->pll_bypass << 3);\r\ndib8000_write_word(state, 902, clk_cfg1);\r\ndprintk("clk_cfg1: 0x%04x", clk_cfg1);\r\nif (state->cfg.pll->ADClkSrc == 0)\r\ndib8000_write_word(state, 904,\r\n(0 << 15) | (0 << 12) | (0 << 10) |\r\n(pll->modulo << 8) |\r\n(pll->ADClkSrc << 7) | (0 << 1));\r\nelse if (state->cfg.refclksel != 0)\r\ndib8000_write_word(state, 904, (0 << 15) | (1 << 12) |\r\n((state->cfg.refclksel & 0x3) << 10) |\r\n(pll->modulo << 8) |\r\n(pll->ADClkSrc << 7) | (0 << 1));\r\nelse\r\ndib8000_write_word(state, 904, (0 << 15) | (1 << 12) |\r\n(3 << 10) | (pll->modulo << 8) |\r\n(pll->ADClkSrc << 7) | (0 << 1));\r\n} else {\r\ndib8000_write_word(state, 1856, (!pll->pll_reset<<13) |\r\n(pll->pll_range<<12) | (pll->pll_ratio<<6) |\r\n(pll->pll_prediv));\r\nreg = dib8000_read_word(state, 1857);\r\ndib8000_write_word(state, 1857, reg|(!pll->pll_bypass<<15));\r\nreg = dib8000_read_word(state, 1858);\r\ndib8000_write_word(state, 1858, reg | 1);\r\ndib8000_write_word(state, 904, (pll->modulo << 8));\r\n}\r\ndib8000_reset_pll_common(state, pll);\r\n}\r\nint dib8000_update_pll(struct dvb_frontend *fe,\r\nstruct dibx000_bandwidth_config *pll)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 reg_1857, reg_1856 = dib8000_read_word(state, 1856);\r\nu8 loopdiv, prediv;\r\nu32 internal, xtal;\r\nprediv = reg_1856 & 0x3f;\r\nloopdiv = (reg_1856 >> 6) & 0x3f;\r\nif ((pll != NULL) && (pll->pll_prediv != prediv ||\r\npll->pll_ratio != loopdiv)) {\r\ndprintk("Updating pll (prediv: old = %d new = %d ; loopdiv : old = %d new = %d)", prediv, pll->pll_prediv, loopdiv, pll->pll_ratio);\r\nreg_1856 &= 0xf000;\r\nreg_1857 = dib8000_read_word(state, 1857);\r\ndib8000_write_word(state, 1857, reg_1857 & ~(1 << 15));\r\ndib8000_write_word(state, 1856, reg_1856 |\r\n((pll->pll_ratio & 0x3f) << 6) |\r\n(pll->pll_prediv & 0x3f));\r\ninternal = dib8000_read32(state, 23) / 1000;\r\ndprintk("Old Internal = %d", internal);\r\nxtal = 2 * (internal / loopdiv) * prediv;\r\ninternal = 1000 * (xtal/pll->pll_prediv) * pll->pll_ratio;\r\ndprintk("Xtal = %d , New Fmem = %d New Fdemod = %d, New Fsampling = %d", xtal, internal/1000, internal/2000, internal/8000);\r\ndprintk("New Internal = %d", internal);\r\ndib8000_write_word(state, 23,\r\n(u16) (((internal / 2) >> 16) & 0xffff));\r\ndib8000_write_word(state, 24, (u16) ((internal / 2) & 0xffff));\r\ndib8000_write_word(state, 1857, reg_1857 | (1 << 15));\r\nwhile (((dib8000_read_word(state, 1856)>>15)&0x1) != 1)\r\ndprintk("Waiting for PLL to lock");\r\nreg_1856 = dib8000_read_word(state, 1856);\r\ndprintk("PLL Updated with prediv = %d and loopdiv = %d",\r\nreg_1856&0x3f, (reg_1856>>6)&0x3f);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int dib8000_reset_gpio(struct dib8000_state *st)\r\n{\r\ndib8000_write_word(st, 1029, st->cfg.gpio_dir);\r\ndib8000_write_word(st, 1030, st->cfg.gpio_val);\r\ndib8000_write_word(st, 1032, st->cfg.gpio_pwm_pos);\r\ndib8000_write_word(st, 1037, st->cfg.pwm_freq_div);\r\nreturn 0;\r\n}\r\nstatic int dib8000_cfg_gpio(struct dib8000_state *st, u8 num, u8 dir, u8 val)\r\n{\r\nst->cfg.gpio_dir = dib8000_read_word(st, 1029);\r\nst->cfg.gpio_dir &= ~(1 << num);\r\nst->cfg.gpio_dir |= (dir & 0x1) << num;\r\ndib8000_write_word(st, 1029, st->cfg.gpio_dir);\r\nst->cfg.gpio_val = dib8000_read_word(st, 1030);\r\nst->cfg.gpio_val &= ~(1 << num);\r\nst->cfg.gpio_val |= (val & 0x01) << num;\r\ndib8000_write_word(st, 1030, st->cfg.gpio_val);\r\ndprintk("gpio dir: %x: gpio val: %x", st->cfg.gpio_dir, st->cfg.gpio_val);\r\nreturn 0;\r\n}\r\nint dib8000_set_gpio(struct dvb_frontend *fe, u8 num, u8 dir, u8 val)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nreturn dib8000_cfg_gpio(state, num, dir, val);\r\n}\r\nstatic u16 dib8000_identify(struct i2c_device *client)\r\n{\r\nu16 value;\r\nvalue = dib8000_i2c_read16(client, 896);\r\nif ((value = dib8000_i2c_read16(client, 896)) != 0x01b3) {\r\ndprintk("wrong Vendor ID (read=0x%x)", value);\r\nreturn 0;\r\n}\r\nvalue = dib8000_i2c_read16(client, 897);\r\nif (value != 0x8000 && value != 0x8001 &&\r\nvalue != 0x8002 && value != 0x8090) {\r\ndprintk("wrong Device ID (%x)", value);\r\nreturn 0;\r\n}\r\nswitch (value) {\r\ncase 0x8000:\r\ndprintk("found DiB8000A");\r\nbreak;\r\ncase 0x8001:\r\ndprintk("found DiB8000B");\r\nbreak;\r\ncase 0x8002:\r\ndprintk("found DiB8000C");\r\nbreak;\r\ncase 0x8090:\r\ndprintk("found DiB8096P");\r\nbreak;\r\n}\r\nreturn value;\r\n}\r\nstatic int dib8000_reset(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif ((state->revision = dib8000_identify(&state->i2c)) == 0)\r\nreturn -EINVAL;\r\nif (state->revision != 0x8090)\r\ndib8000_write_word(state, 1287, 0x0003);\r\nif (state->revision == 0x8000)\r\ndprintk("error : dib8000 MA not supported");\r\ndibx000_reset_i2c_master(&state->i2c_master);\r\ndib8000_set_power_mode(state, DIB8000_POWER_ALL);\r\ndib8000_set_adc_state(state, DIBX000_VBG_ENABLE);\r\ndib8000_write_word(state, 770, 0xffff);\r\ndib8000_write_word(state, 771, 0xffff);\r\ndib8000_write_word(state, 772, 0xfffc);\r\nif (state->revision == 0x8090)\r\ndib8000_write_word(state, 1280, 0x0045);\r\nelse\r\ndib8000_write_word(state, 1280, 0x004d);\r\ndib8000_write_word(state, 1281, 0x000c);\r\ndib8000_write_word(state, 770, 0x0000);\r\ndib8000_write_word(state, 771, 0x0000);\r\ndib8000_write_word(state, 772, 0x0000);\r\ndib8000_write_word(state, 898, 0x0004);\r\ndib8000_write_word(state, 1280, 0x0000);\r\ndib8000_write_word(state, 1281, 0x0000);\r\nif (state->revision != 0x8090) {\r\nif (state->cfg.drives)\r\ndib8000_write_word(state, 906, state->cfg.drives);\r\nelse {\r\ndprintk("using standard PAD-drive-settings, please adjust settings in config-struct to be optimal.");\r\ndib8000_write_word(state, 906, 0x2d98);\r\n}\r\n}\r\ndib8000_reset_pll(state);\r\nif (state->revision != 0x8090)\r\ndib8000_write_word(state, 898, 0x0004);\r\nif (dib8000_reset_gpio(state) != 0)\r\ndprintk("GPIO reset was not successful.");\r\nif ((state->revision != 0x8090) &&\r\n(dib8000_set_output_mode(fe, OUTMODE_HIGH_Z) != 0))\r\ndprintk("OUTPUT_MODE could not be resetted.");\r\nstate->current_agc = NULL;\r\nif (state->cfg.pll->ifreq == 0)\r\ndib8000_write_word(state, 40, 0x0755);\r\nelse\r\ndib8000_write_word(state, 40, 0x1f55);\r\n{\r\nu16 l = 0, r;\r\nconst u16 *n;\r\nn = dib8000_defaults;\r\nl = *n++;\r\nwhile (l) {\r\nr = *n++;\r\ndo {\r\ndib8000_write_word(state, r, *n++);\r\nr++;\r\n} while (--l);\r\nl = *n++;\r\n}\r\n}\r\nif (state->revision != 0x8090)\r\ndib8000_write_word(state, 903, (0 << 4) | 2);\r\nstate->isdbt_cfg_loaded = 0;\r\nif (state->cfg.div_cfg != 0)\r\ndib8000_write_word(state, 903, state->cfg.div_cfg);\r\ndib8000_write_word(state, 1285, dib8000_read_word(state, 1285) & ~(1 << 1));\r\ndib8000_set_bandwidth(fe, 6000);\r\ndib8000_set_adc_state(state, DIBX000_SLOW_ADC_ON);\r\nif (state->revision != 0x8090) {\r\ndib8000_sad_calib(state);\r\ndib8000_set_adc_state(state, DIBX000_SLOW_ADC_OFF);\r\n}\r\ndib8000_set_power_mode(state, DIB8000_POWER_INTERFACE_ONLY);\r\nreturn 0;\r\n}\r\nstatic void dib8000_restart_agc(struct dib8000_state *state)\r\n{\r\ndib8000_write_word(state, 770, 0x0a00);\r\ndib8000_write_word(state, 770, 0x0000);\r\n}\r\nstatic int dib8000_update_lna(struct dib8000_state *state)\r\n{\r\nu16 dyn_gain;\r\nif (state->cfg.update_lna) {\r\ndyn_gain = dib8000_read_word(state, 390);\r\nif (state->cfg.update_lna(state->fe[0], dyn_gain)) {\r\ndib8000_restart_agc(state);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_set_agc_config(struct dib8000_state *state, u8 band)\r\n{\r\nstruct dibx000_agc_config *agc = NULL;\r\nint i;\r\nu16 reg;\r\nif (state->current_band == band && state->current_agc != NULL)\r\nreturn 0;\r\nstate->current_band = band;\r\nfor (i = 0; i < state->cfg.agc_config_count; i++)\r\nif (state->cfg.agc[i].band_caps & band) {\r\nagc = &state->cfg.agc[i];\r\nbreak;\r\n}\r\nif (agc == NULL) {\r\ndprintk("no valid AGC configuration found for band 0x%02x", band);\r\nreturn -EINVAL;\r\n}\r\nstate->current_agc = agc;\r\ndib8000_write_word(state, 76, agc->setup);\r\ndib8000_write_word(state, 77, agc->inv_gain);\r\ndib8000_write_word(state, 78, agc->time_stabiliz);\r\ndib8000_write_word(state, 101, (agc->alpha_level << 12) | agc->thlock);\r\ndib8000_write_word(state, 102, (agc->alpha_mant << 5) | agc->alpha_exp);\r\ndib8000_write_word(state, 103, (agc->beta_mant << 6) | agc->beta_exp);\r\ndprintk("WBD: ref: %d, sel: %d, active: %d, alpha: %d",\r\nstate->wbd_ref != 0 ? state->wbd_ref : agc->wbd_ref, agc->wbd_sel, !agc->perform_agc_softsplit, agc->wbd_sel);\r\nif (state->wbd_ref != 0)\r\ndib8000_write_word(state, 106, state->wbd_ref);\r\nelse\r\ndib8000_write_word(state, 106, agc->wbd_ref);\r\nif (state->revision == 0x8090) {\r\nreg = dib8000_read_word(state, 922) & (0x3 << 2);\r\ndib8000_write_word(state, 922, reg | (agc->wbd_sel << 2));\r\n}\r\ndib8000_write_word(state, 107, (agc->wbd_alpha << 9) | (agc->perform_agc_softsplit << 8));\r\ndib8000_write_word(state, 108, agc->agc1_max);\r\ndib8000_write_word(state, 109, agc->agc1_min);\r\ndib8000_write_word(state, 110, agc->agc2_max);\r\ndib8000_write_word(state, 111, agc->agc2_min);\r\ndib8000_write_word(state, 112, (agc->agc1_pt1 << 8) | agc->agc1_pt2);\r\ndib8000_write_word(state, 113, (agc->agc1_slope1 << 8) | agc->agc1_slope2);\r\ndib8000_write_word(state, 114, (agc->agc2_pt1 << 8) | agc->agc2_pt2);\r\ndib8000_write_word(state, 115, (agc->agc2_slope1 << 8) | agc->agc2_slope2);\r\ndib8000_write_word(state, 75, agc->agc1_pt3);\r\nif (state->revision != 0x8090)\r\ndib8000_write_word(state, 923,\r\n(dib8000_read_word(state, 923) & 0xffe3) |\r\n(agc->wbd_inv << 4) | (agc->wbd_sel << 2));\r\nreturn 0;\r\n}\r\nvoid dib8000_pwm_agc_reset(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\ndib8000_set_adc_state(state, DIBX000_ADC_ON);\r\ndib8000_set_agc_config(state, (unsigned char)(BAND_OF_FREQUENCY(fe->dtv_property_cache.frequency / 1000)));\r\n}\r\nstatic int dib8000_agc_soft_split(struct dib8000_state *state)\r\n{\r\nu16 agc, split_offset;\r\nif (!state->current_agc || !state->current_agc->perform_agc_softsplit || state->current_agc->split.max == 0)\r\nreturn FE_CALLBACK_TIME_NEVER;\r\nagc = dib8000_read_word(state, 390);\r\nif (agc > state->current_agc->split.min_thres)\r\nsplit_offset = state->current_agc->split.min;\r\nelse if (agc < state->current_agc->split.max_thres)\r\nsplit_offset = state->current_agc->split.max;\r\nelse\r\nsplit_offset = state->current_agc->split.max *\r\n(agc - state->current_agc->split.min_thres) /\r\n(state->current_agc->split.max_thres - state->current_agc->split.min_thres);\r\ndprintk("AGC split_offset: %d", split_offset);\r\ndib8000_write_word(state, 107, (dib8000_read_word(state, 107) & 0xff00) | split_offset);\r\nreturn 5000;\r\n}\r\nstatic int dib8000_agc_startup(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nenum frontend_tune_state *tune_state = &state->tune_state;\r\nint ret = 0;\r\nu16 reg, upd_demod_gain_period = 0x8000;\r\nswitch (*tune_state) {\r\ncase CT_AGC_START:\r\nif (state->revision != 0x8090)\r\ndib8000_set_adc_state(state, DIBX000_ADC_ON);\r\nelse {\r\ndib8000_set_power_mode(state, DIB8000_POWER_ALL);\r\nreg = dib8000_read_word(state, 1947)&0xff00;\r\ndib8000_write_word(state, 1946,\r\nupd_demod_gain_period & 0xFFFF);\r\ndib8000_write_word(state, 1947, reg | (1<<14) |\r\n((upd_demod_gain_period >> 16) & 0xFF));\r\nreg = dib8000_read_word(state, 1920);\r\ndib8000_write_word(state, 1920, (reg | 0x3) &\r\n(~(1 << 7)));\r\n}\r\nif (dib8000_set_agc_config(state, (unsigned char)(BAND_OF_FREQUENCY(fe->dtv_property_cache.frequency / 1000))) != 0) {\r\n*tune_state = CT_AGC_STOP;\r\nstate->status = FE_STATUS_TUNE_FAILED;\r\nbreak;\r\n}\r\nret = 70;\r\n*tune_state = CT_AGC_STEP_0;\r\nbreak;\r\ncase CT_AGC_STEP_0:\r\nif (state->cfg.agc_control)\r\nstate->cfg.agc_control(fe, 1);\r\ndib8000_restart_agc(state);\r\nret = 50;\r\n*tune_state = CT_AGC_STEP_1;\r\nbreak;\r\ncase CT_AGC_STEP_1:\r\nret = 70;\r\nif (dib8000_update_lna(state))\r\nret = 50;\r\nelse\r\n*tune_state = CT_AGC_STEP_2;\r\nbreak;\r\ncase CT_AGC_STEP_2:\r\ndib8000_agc_soft_split(state);\r\nif (state->cfg.agc_control)\r\nstate->cfg.agc_control(fe, 0);\r\n*tune_state = CT_AGC_STOP;\r\nbreak;\r\ndefault:\r\nret = dib8000_agc_soft_split(state);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void dib8096p_host_bus_drive(struct dib8000_state *state, u8 drive)\r\n{\r\nu16 reg;\r\ndrive &= 0x7;\r\nreg = dib8000_read_word(state, 1798) &\r\n~(0x7 | (0x7 << 6) | (0x7 << 12));\r\nreg |= (drive<<12) | (drive<<6) | drive;\r\ndib8000_write_word(state, 1798, reg);\r\nreg = dib8000_read_word(state, 1799) & ~((0x7 << 2) | (0x7 << 8));\r\nreg |= (drive<<8) | (drive<<2);\r\ndib8000_write_word(state, 1799, reg);\r\nreg = dib8000_read_word(state, 1800) &\r\n~(0x7 | (0x7 << 6) | (0x7 << 12));\r\nreg |= (drive<<12) | (drive<<6) | drive;\r\ndib8000_write_word(state, 1800, reg);\r\nreg = dib8000_read_word(state, 1801) & ~((0x7 << 2) | (0x7 << 8));\r\nreg |= (drive<<8) | (drive<<2);\r\ndib8000_write_word(state, 1801, reg);\r\nreg = dib8000_read_word(state, 1802) &\r\n~(0x7 | (0x7 << 6) | (0x7 << 12));\r\nreg |= (drive<<12) | (drive<<6) | drive;\r\ndib8000_write_word(state, 1802, reg);\r\n}\r\nstatic u32 dib8096p_calcSyncFreq(u32 P_Kin, u32 P_Kout,\r\nu32 insertExtSynchro, u32 syncSize)\r\n{\r\nu32 quantif = 3;\r\nu32 nom = (insertExtSynchro * P_Kin+syncSize);\r\nu32 denom = P_Kout;\r\nu32 syncFreq = ((nom << quantif) / denom);\r\nif ((syncFreq & ((1 << quantif) - 1)) != 0)\r\nsyncFreq = (syncFreq >> quantif) + 1;\r\nelse\r\nsyncFreq = (syncFreq >> quantif);\r\nif (syncFreq != 0)\r\nsyncFreq = syncFreq - 1;\r\nreturn syncFreq;\r\n}\r\nstatic void dib8096p_cfg_DibTx(struct dib8000_state *state, u32 P_Kin,\r\nu32 P_Kout, u32 insertExtSynchro, u32 synchroMode,\r\nu32 syncWord, u32 syncSize)\r\n{\r\ndprintk("Configure DibStream Tx");\r\ndib8000_write_word(state, 1615, 1);\r\ndib8000_write_word(state, 1603, P_Kin);\r\ndib8000_write_word(state, 1605, P_Kout);\r\ndib8000_write_word(state, 1606, insertExtSynchro);\r\ndib8000_write_word(state, 1608, synchroMode);\r\ndib8000_write_word(state, 1609, (syncWord >> 16) & 0xffff);\r\ndib8000_write_word(state, 1610, syncWord & 0xffff);\r\ndib8000_write_word(state, 1612, syncSize);\r\ndib8000_write_word(state, 1615, 0);\r\n}\r\nstatic void dib8096p_cfg_DibRx(struct dib8000_state *state, u32 P_Kin,\r\nu32 P_Kout, u32 synchroMode, u32 insertExtSynchro,\r\nu32 syncWord, u32 syncSize, u32 dataOutRate)\r\n{\r\nu32 syncFreq;\r\ndprintk("Configure DibStream Rx synchroMode = %d", synchroMode);\r\nif ((P_Kin != 0) && (P_Kout != 0)) {\r\nsyncFreq = dib8096p_calcSyncFreq(P_Kin, P_Kout,\r\ninsertExtSynchro, syncSize);\r\ndib8000_write_word(state, 1542, syncFreq);\r\n}\r\ndib8000_write_word(state, 1554, 1);\r\ndib8000_write_word(state, 1536, P_Kin);\r\ndib8000_write_word(state, 1537, P_Kout);\r\ndib8000_write_word(state, 1539, synchroMode);\r\ndib8000_write_word(state, 1540, (syncWord >> 16) & 0xffff);\r\ndib8000_write_word(state, 1541, syncWord & 0xffff);\r\ndib8000_write_word(state, 1543, syncSize);\r\ndib8000_write_word(state, 1544, dataOutRate);\r\ndib8000_write_word(state, 1554, 0);\r\n}\r\nstatic void dib8096p_enMpegMux(struct dib8000_state *state, int onoff)\r\n{\r\nu16 reg_1287;\r\nreg_1287 = dib8000_read_word(state, 1287);\r\nswitch (onoff) {\r\ncase 1:\r\nreg_1287 &= ~(1 << 8);\r\nbreak;\r\ncase 0:\r\nreg_1287 |= (1 << 8);\r\nbreak;\r\n}\r\ndib8000_write_word(state, 1287, reg_1287);\r\n}\r\nstatic void dib8096p_configMpegMux(struct dib8000_state *state,\r\nu16 pulseWidth, u16 enSerialMode, u16 enSerialClkDiv2)\r\n{\r\nu16 reg_1287;\r\ndprintk("Enable Mpeg mux");\r\ndib8096p_enMpegMux(state, 0);\r\nif ((enSerialMode == 1) && (state->input_mode_mpeg == 1))\r\nenSerialClkDiv2 = 0;\r\nreg_1287 = ((pulseWidth & 0x1f) << 3) |\r\n((enSerialMode & 0x1) << 2) | (enSerialClkDiv2 & 0x1);\r\ndib8000_write_word(state, 1287, reg_1287);\r\ndib8096p_enMpegMux(state, 1);\r\n}\r\nstatic void dib8096p_setDibTxMux(struct dib8000_state *state, int mode)\r\n{\r\nu16 reg_1288 = dib8000_read_word(state, 1288) & ~(0x7 << 7);\r\nswitch (mode) {\r\ncase MPEG_ON_DIBTX:\r\ndprintk("SET MPEG ON DIBSTREAM TX");\r\ndib8096p_cfg_DibTx(state, 8, 5, 0, 0, 0, 0);\r\nreg_1288 |= (1 << 9); break;\r\ncase DIV_ON_DIBTX:\r\ndprintk("SET DIV_OUT ON DIBSTREAM TX");\r\ndib8096p_cfg_DibTx(state, 5, 5, 0, 0, 0, 0);\r\nreg_1288 |= (1 << 8); break;\r\ncase ADC_ON_DIBTX:\r\ndprintk("SET ADC_OUT ON DIBSTREAM TX");\r\ndib8096p_cfg_DibTx(state, 20, 5, 10, 0, 0, 0);\r\nreg_1288 |= (1 << 7); break;\r\ndefault:\r\nbreak;\r\n}\r\ndib8000_write_word(state, 1288, reg_1288);\r\n}\r\nstatic void dib8096p_setHostBusMux(struct dib8000_state *state, int mode)\r\n{\r\nu16 reg_1288 = dib8000_read_word(state, 1288) & ~(0x7 << 4);\r\nswitch (mode) {\r\ncase DEMOUT_ON_HOSTBUS:\r\ndprintk("SET DEM OUT OLD INTERF ON HOST BUS");\r\ndib8096p_enMpegMux(state, 0);\r\nreg_1288 |= (1 << 6);\r\nbreak;\r\ncase DIBTX_ON_HOSTBUS:\r\ndprintk("SET DIBSTREAM TX ON HOST BUS");\r\ndib8096p_enMpegMux(state, 0);\r\nreg_1288 |= (1 << 5);\r\nbreak;\r\ncase MPEG_ON_HOSTBUS:\r\ndprintk("SET MPEG MUX ON HOST BUS");\r\nreg_1288 |= (1 << 4);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndib8000_write_word(state, 1288, reg_1288);\r\n}\r\nstatic int dib8096p_set_diversity_in(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 reg_1287;\r\nswitch (onoff) {\r\ncase 0:\r\ndprintk("%s mode OFF : by default Enable Mpeg INPUT",\r\n__func__);\r\ndib8096p_cfg_DibRx(state, 8, 5, 0, 0, 0, 8, 0);\r\nreg_1287 = dib8000_read_word(state, 1287);\r\nif ((reg_1287 & 0x1) == 1) {\r\nreg_1287 &= ~0x1;\r\ndib8000_write_word(state, 1287, reg_1287);\r\n}\r\nstate->input_mode_mpeg = 1;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ndprintk("%s ON : Enable diversity INPUT", __func__);\r\ndib8096p_cfg_DibRx(state, 5, 5, 0, 0, 0, 0, 0);\r\nstate->input_mode_mpeg = 0;\r\nbreak;\r\n}\r\ndib8000_set_diversity_in(state->fe[0], onoff);\r\nreturn 0;\r\n}\r\nstatic int dib8096p_set_output_mode(struct dvb_frontend *fe, int mode)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 outreg, smo_mode, fifo_threshold;\r\nu8 prefer_mpeg_mux_use = 1;\r\nint ret = 0;\r\ndib8096p_host_bus_drive(state, 1);\r\nfifo_threshold = 1792;\r\nsmo_mode = (dib8000_read_word(state, 299) & 0x0050) | (1 << 1);\r\noutreg = dib8000_read_word(state, 1286) &\r\n~((1 << 10) | (0x7 << 6) | (1 << 1));\r\nswitch (mode) {\r\ncase OUTMODE_HIGH_Z:\r\noutreg = 0;\r\nbreak;\r\ncase OUTMODE_MPEG2_SERIAL:\r\nif (prefer_mpeg_mux_use) {\r\ndprintk("dib8096P setting output mode TS_SERIAL using Mpeg Mux");\r\ndib8096p_configMpegMux(state, 3, 1, 1);\r\ndib8096p_setHostBusMux(state, MPEG_ON_HOSTBUS);\r\n} else {\r\ndprintk("dib8096P setting output mode TS_SERIAL using Smooth bloc");\r\ndib8096p_setHostBusMux(state,\r\nDEMOUT_ON_HOSTBUS);\r\noutreg |= (2 << 6) | (0 << 1);\r\n}\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_GATED_CLK:\r\nif (prefer_mpeg_mux_use) {\r\ndprintk("dib8096P setting output mode TS_PARALLEL_GATED using Mpeg Mux");\r\ndib8096p_configMpegMux(state, 2, 0, 0);\r\ndib8096p_setHostBusMux(state, MPEG_ON_HOSTBUS);\r\n} else {\r\ndprintk("dib8096P setting output mode TS_PARALLEL_GATED using Smooth block");\r\ndib8096p_setHostBusMux(state,\r\nDEMOUT_ON_HOSTBUS);\r\noutreg |= (0 << 6);\r\n}\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_CONT_CLK:\r\ndprintk("dib8096P setting output mode TS_PARALLEL_CONT using Smooth block");\r\ndib8096p_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\r\noutreg |= (1 << 6);\r\nbreak;\r\ncase OUTMODE_MPEG2_FIFO:\r\ndprintk("dib8096P setting output mode TS_FIFO using Smooth block");\r\ndib8096p_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\r\noutreg |= (5 << 6);\r\nsmo_mode |= (3 << 1);\r\nfifo_threshold = 512;\r\nbreak;\r\ncase OUTMODE_DIVERSITY:\r\ndprintk("dib8096P setting output mode MODE_DIVERSITY");\r\ndib8096p_setDibTxMux(state, DIV_ON_DIBTX);\r\ndib8096p_setHostBusMux(state, DIBTX_ON_HOSTBUS);\r\nbreak;\r\ncase OUTMODE_ANALOG_ADC:\r\ndprintk("dib8096P setting output mode MODE_ANALOG_ADC");\r\ndib8096p_setDibTxMux(state, ADC_ON_DIBTX);\r\ndib8096p_setHostBusMux(state, DIBTX_ON_HOSTBUS);\r\nbreak;\r\n}\r\nif (mode != OUTMODE_HIGH_Z)\r\noutreg |= (1<<10);\r\ndprintk("output_mpeg2_in_188_bytes = %d",\r\nstate->cfg.output_mpeg2_in_188_bytes);\r\nif (state->cfg.output_mpeg2_in_188_bytes)\r\nsmo_mode |= (1 << 5);\r\nret |= dib8000_write_word(state, 299, smo_mode);\r\nret |= dib8000_write_word(state, 299 + 1, fifo_threshold);\r\nret |= dib8000_write_word(state, 1286, outreg);\r\nreturn ret;\r\n}\r\nstatic int map_addr_to_serpar_number(struct i2c_msg *msg)\r\n{\r\nif (msg->buf[0] <= 15)\r\nmsg->buf[0] -= 1;\r\nelse if (msg->buf[0] == 17)\r\nmsg->buf[0] = 15;\r\nelse if (msg->buf[0] == 16)\r\nmsg->buf[0] = 17;\r\nelse if (msg->buf[0] == 19)\r\nmsg->buf[0] = 16;\r\nelse if (msg->buf[0] >= 21 && msg->buf[0] <= 25)\r\nmsg->buf[0] -= 3;\r\nelse if (msg->buf[0] == 28)\r\nmsg->buf[0] = 23;\r\nelse if (msg->buf[0] == 99)\r\nmsg->buf[0] = 99;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int dib8096p_tuner_write_serpar(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dib8000_state *state = i2c_get_adapdata(i2c_adap);\r\nu8 n_overflow = 1;\r\nu16 i = 1000;\r\nu16 serpar_num = msg[0].buf[0];\r\nwhile (n_overflow == 1 && i) {\r\nn_overflow = (dib8000_read_word(state, 1984) >> 1) & 0x1;\r\ni--;\r\nif (i == 0)\r\ndprintk("Tuner ITF: write busy (overflow)");\r\n}\r\ndib8000_write_word(state, 1985, (1 << 6) | (serpar_num & 0x3f));\r\ndib8000_write_word(state, 1986, (msg[0].buf[1] << 8) | msg[0].buf[2]);\r\nreturn num;\r\n}\r\nstatic int dib8096p_tuner_read_serpar(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dib8000_state *state = i2c_get_adapdata(i2c_adap);\r\nu8 n_overflow = 1, n_empty = 1;\r\nu16 i = 1000;\r\nu16 serpar_num = msg[0].buf[0];\r\nu16 read_word;\r\nwhile (n_overflow == 1 && i) {\r\nn_overflow = (dib8000_read_word(state, 1984) >> 1) & 0x1;\r\ni--;\r\nif (i == 0)\r\ndprintk("TunerITF: read busy (overflow)");\r\n}\r\ndib8000_write_word(state, 1985, (0<<6) | (serpar_num&0x3f));\r\ni = 1000;\r\nwhile (n_empty == 1 && i) {\r\nn_empty = dib8000_read_word(state, 1984)&0x1;\r\ni--;\r\nif (i == 0)\r\ndprintk("TunerITF: read busy (empty)");\r\n}\r\nread_word = dib8000_read_word(state, 1987);\r\nmsg[1].buf[0] = (read_word >> 8) & 0xff;\r\nmsg[1].buf[1] = (read_word) & 0xff;\r\nreturn num;\r\n}\r\nstatic int dib8096p_tuner_rw_serpar(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nif (map_addr_to_serpar_number(&msg[0]) == 0) {\r\nif (num == 1)\r\nreturn dib8096p_tuner_write_serpar(i2c_adap, msg, 1);\r\nelse\r\nreturn dib8096p_tuner_read_serpar(i2c_adap, msg, 2);\r\n}\r\nreturn num;\r\n}\r\nstatic int dib8096p_rw_on_apb(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num, u16 apb_address)\r\n{\r\nstruct dib8000_state *state = i2c_get_adapdata(i2c_adap);\r\nu16 word;\r\nif (num == 1) {\r\ndib8000_write_word(state, apb_address,\r\n((msg[0].buf[1] << 8) | (msg[0].buf[2])));\r\n} else {\r\nword = dib8000_read_word(state, apb_address);\r\nmsg[1].buf[0] = (word >> 8) & 0xff;\r\nmsg[1].buf[1] = (word) & 0xff;\r\n}\r\nreturn num;\r\n}\r\nstatic int dib8096p_tuner_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dib8000_state *state = i2c_get_adapdata(i2c_adap);\r\nu16 apb_address = 0, word;\r\nint i = 0;\r\nswitch (msg[0].buf[0]) {\r\ncase 0x12:\r\napb_address = 1920;\r\nbreak;\r\ncase 0x14:\r\napb_address = 1921;\r\nbreak;\r\ncase 0x24:\r\napb_address = 1922;\r\nbreak;\r\ncase 0x1a:\r\napb_address = 1923;\r\nbreak;\r\ncase 0x22:\r\napb_address = 1924;\r\nbreak;\r\ncase 0x33:\r\napb_address = 1926;\r\nbreak;\r\ncase 0x34:\r\napb_address = 1927;\r\nbreak;\r\ncase 0x35:\r\napb_address = 1928;\r\nbreak;\r\ncase 0x36:\r\napb_address = 1929;\r\nbreak;\r\ncase 0x37:\r\napb_address = 1930;\r\nbreak;\r\ncase 0x38:\r\napb_address = 1931;\r\nbreak;\r\ncase 0x39:\r\napb_address = 1932;\r\nbreak;\r\ncase 0x2a:\r\napb_address = 1935;\r\nbreak;\r\ncase 0x2b:\r\napb_address = 1936;\r\nbreak;\r\ncase 0x2c:\r\napb_address = 1937;\r\nbreak;\r\ncase 0x2d:\r\napb_address = 1938;\r\nbreak;\r\ncase 0x2e:\r\napb_address = 1939;\r\nbreak;\r\ncase 0x2f:\r\napb_address = 1940;\r\nbreak;\r\ncase 0x30:\r\napb_address = 1941;\r\nbreak;\r\ncase 0x31:\r\napb_address = 1942;\r\nbreak;\r\ncase 0x32:\r\napb_address = 1943;\r\nbreak;\r\ncase 0x3e:\r\napb_address = 1944;\r\nbreak;\r\ncase 0x3f:\r\napb_address = 1945;\r\nbreak;\r\ncase 0x40:\r\napb_address = 1948;\r\nbreak;\r\ncase 0x25:\r\napb_address = 936;\r\nbreak;\r\ncase 0x26:\r\napb_address = 937;\r\nbreak;\r\ncase 0x27:\r\napb_address = 938;\r\nbreak;\r\ncase 0x28:\r\napb_address = 939;\r\nbreak;\r\ncase 0x1d:\r\ni = ((dib8000_read_word(state, 921) >> 12)&0x3);\r\nword = dib8000_read_word(state, 924+i);\r\nmsg[1].buf[0] = (word >> 8) & 0xff;\r\nmsg[1].buf[1] = (word) & 0xff;\r\nreturn num;\r\ncase 0x1f:\r\nif (num == 1) {\r\nword = (u16) ((msg[0].buf[1] << 8) |\r\nmsg[0].buf[2]);\r\nword &= 0x3;\r\nword = (dib8000_read_word(state, 921) &\r\n~(3<<12)) | (word<<12);\r\ndib8000_write_word(state, 921, word);\r\nreturn num;\r\n}\r\n}\r\nif (apb_address != 0)\r\nreturn dib8096p_rw_on_apb(i2c_adap, msg, num, apb_address);\r\nelse\r\nreturn dib8096p_tuner_rw_serpar(i2c_adap, msg, num);\r\nreturn 0;\r\n}\r\nstatic u32 dib8096p_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstruct i2c_adapter *dib8096p_get_i2c_tuner(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\nreturn &st->dib8096p_tuner_adap;\r\n}\r\nint dib8096p_tuner_sleep(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 en_cur_state;\r\ndprintk("sleep dib8096p: %d", onoff);\r\nen_cur_state = dib8000_read_word(state, 1922);\r\nif (en_cur_state > 0xff)\r\nstate->tuner_enable = en_cur_state ;\r\nif (onoff)\r\nen_cur_state &= 0x00ff;\r\nelse {\r\nif (state->tuner_enable != 0)\r\nen_cur_state = state->tuner_enable;\r\n}\r\ndib8000_write_word(state, 1922, en_cur_state);\r\nreturn 0;\r\n}\r\ns32 dib8000_get_adc_power(struct dvb_frontend *fe, u8 mode)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu32 ix = 0, tmp_val = 0, exp = 0, mant = 0;\r\ns32 val;\r\nval = dib8000_read32(state, 384);\r\nif (mode) {\r\ntmp_val = val;\r\nwhile (tmp_val >>= 1)\r\nexp++;\r\nmant = (val * 1000 / (1<<exp));\r\nix = (u8)((mant-1000)/100);\r\nval = (lut_1000ln_mant[ix] + 693*(exp-20) - 6908);\r\nval = (val*256)/1000;\r\n}\r\nreturn val;\r\n}\r\nint dib8090p_get_dc_power(struct dvb_frontend *fe, u8 IQ)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nint val = 0;\r\nswitch (IQ) {\r\ncase 1:\r\nval = dib8000_read_word(state, 403);\r\nbreak;\r\ncase 0:\r\nval = dib8000_read_word(state, 404);\r\nbreak;\r\n}\r\nif (val & 0x200)\r\nval -= 1024;\r\nreturn val;\r\n}\r\nstatic void dib8000_update_timf(struct dib8000_state *state)\r\n{\r\nu32 timf = state->timf = dib8000_read32(state, 435);\r\ndib8000_write_word(state, 29, (u16) (timf >> 16));\r\ndib8000_write_word(state, 30, (u16) (timf & 0xffff));\r\ndprintk("Updated timing frequency: %d (default: %d)", state->timf, state->timf_default);\r\n}\r\nu32 dib8000_ctrl_timf(struct dvb_frontend *fe, uint8_t op, uint32_t timf)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nswitch (op) {\r\ncase DEMOD_TIMF_SET:\r\nstate->timf = timf;\r\nbreak;\r\ncase DEMOD_TIMF_UPDATE:\r\ndib8000_update_timf(state);\r\nbreak;\r\ncase DEMOD_TIMF_GET:\r\nbreak;\r\n}\r\ndib8000_set_bandwidth(state->fe[0], 6000);\r\nreturn state->timf;\r\n}\r\nstatic void dib8000_set_channel(struct dib8000_state *state, u8 seq, u8 autosearching)\r\n{\r\nu16 mode, max_constellation, seg_diff_mask = 0, nbseg_diff = 0;\r\nu8 guard, crate, constellation, timeI;\r\nu16 i, coeff[4], P_cfr_left_edge = 0, P_cfr_right_edge = 0, seg_mask13 = 0x1fff;\r\nconst s16 *ncoeff = NULL, *ana_fe;\r\nu16 tmcc_pow = 0;\r\nu16 coff_pow = 0x2800;\r\nu16 init_prbs = 0xfff;\r\nu16 ana_gain = 0;\r\nif (state->revision == 0x8090)\r\ndib8000_init_sdram(state);\r\nif (state->ber_monitored_layer != LAYER_ALL)\r\ndib8000_write_word(state, 285, (dib8000_read_word(state, 285) & 0x60) | state->ber_monitored_layer);\r\nelse\r\ndib8000_write_word(state, 285, dib8000_read_word(state, 285) & 0x60);\r\ni = dib8000_read_word(state, 26) & 1;\r\ndib8000_write_word(state, 26, state->fe[0]->dtv_property_cache.inversion^i);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode) {\r\nint seg_offset =\r\nstate->fe[0]->dtv_property_cache.isdbt_sb_segment_idx -\r\n(state->fe[0]->dtv_property_cache.isdbt_sb_segment_count / 2) -\r\n(state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2);\r\nint clk = state->cfg.pll->internal;\r\nu32 segtodds = ((u32) (430 << 23) / clk) << 3;\r\nint dds_offset = seg_offset * segtodds;\r\nint new_dds, sub_channel;\r\nif ((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2) == 0)\r\ndds_offset -= (int)(segtodds / 2);\r\nif (state->cfg.pll->ifreq == 0) {\r\nif ((state->fe[0]->dtv_property_cache.inversion ^ i) == 0) {\r\ndib8000_write_word(state, 26, dib8000_read_word(state, 26) | 1);\r\nnew_dds = dds_offset;\r\n} else\r\nnew_dds = dds_offset;\r\nif ((state->fe[0]->dtv_property_cache.delivery_system == SYS_ISDBT)\r\n&& (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1)\r\n&& (((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2)\r\n&& (state->fe[0]->dtv_property_cache.isdbt_sb_segment_idx ==\r\n((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count / 2) + 1)))\r\n|| (((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2) == 0)\r\n&& (state->fe[0]->dtv_property_cache.isdbt_sb_segment_idx == (state->fe[0]->dtv_property_cache.isdbt_sb_segment_count / 2)))\r\n|| (((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2) == 0)\r\n&& (state->fe[0]->dtv_property_cache.isdbt_sb_segment_idx ==\r\n((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count / 2) + 1)))\r\n)) {\r\nnew_dds -= ((u32) (850 << 22) / clk) << 4;\r\n}\r\n} else {\r\nif ((state->fe[0]->dtv_property_cache.inversion ^ i) == 0)\r\nnew_dds = state->cfg.pll->ifreq - dds_offset;\r\nelse\r\nnew_dds = state->cfg.pll->ifreq + dds_offset;\r\n}\r\ndib8000_write_word(state, 27, (u16) ((new_dds >> 16) & 0x01ff));\r\ndib8000_write_word(state, 28, (u16) (new_dds & 0xffff));\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2)\r\nsub_channel = ((state->fe[0]->dtv_property_cache.isdbt_sb_subchannel + (3 * seg_offset) + 1) % 41) / 3;\r\nelse\r\nsub_channel = ((state->fe[0]->dtv_property_cache.isdbt_sb_subchannel + (3 * seg_offset)) % 41) / 3;\r\nsub_channel -= 6;\r\nif (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_2K\r\n|| state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_4K) {\r\ndib8000_write_word(state, 219, dib8000_read_word(state, 219) | 0x1);\r\ndib8000_write_word(state, 190, dib8000_read_word(state, 190) | (0x1 << 14));\r\n} else {\r\ndib8000_write_word(state, 219, dib8000_read_word(state, 219) & 0xfffe);\r\ndib8000_write_word(state, 190, dib8000_read_word(state, 190) & 0xbfff);\r\n}\r\nswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nswitch (sub_channel) {\r\ncase -6:\r\ninit_prbs = 0x0;\r\nbreak;\r\ncase -5:\r\ninit_prbs = 0x423;\r\nbreak;\r\ncase -4:\r\ninit_prbs = 0x9;\r\nbreak;\r\ncase -3:\r\ninit_prbs = 0x5C7;\r\nbreak;\r\ncase -2:\r\ninit_prbs = 0x7A6;\r\nbreak;\r\ncase -1:\r\ninit_prbs = 0x3D8;\r\nbreak;\r\ncase 0:\r\ninit_prbs = 0x527;\r\nbreak;\r\ncase 1:\r\ninit_prbs = 0x7FF;\r\nbreak;\r\ncase 2:\r\ninit_prbs = 0x79B;\r\nbreak;\r\ncase 3:\r\ninit_prbs = 0x3D6;\r\nbreak;\r\ncase 4:\r\ninit_prbs = 0x3A2;\r\nbreak;\r\ncase 5:\r\ninit_prbs = 0x53B;\r\nbreak;\r\ncase 6:\r\ninit_prbs = 0x2F4;\r\nbreak;\r\ndefault:\r\ncase 7:\r\ninit_prbs = 0x213;\r\nbreak;\r\n}\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nswitch (sub_channel) {\r\ncase -6:\r\ninit_prbs = 0x0;\r\nbreak;\r\ncase -5:\r\ninit_prbs = 0x208;\r\nbreak;\r\ncase -4:\r\ninit_prbs = 0xC3;\r\nbreak;\r\ncase -3:\r\ninit_prbs = 0x7B9;\r\nbreak;\r\ncase -2:\r\ninit_prbs = 0x423;\r\nbreak;\r\ncase -1:\r\ninit_prbs = 0x5C7;\r\nbreak;\r\ncase 0:\r\ninit_prbs = 0x3D8;\r\nbreak;\r\ncase 1:\r\ninit_prbs = 0x7FF;\r\nbreak;\r\ncase 2:\r\ninit_prbs = 0x3D6;\r\nbreak;\r\ncase 3:\r\ninit_prbs = 0x53B;\r\nbreak;\r\ncase 4:\r\ninit_prbs = 0x213;\r\nbreak;\r\ncase 5:\r\ninit_prbs = 0x29;\r\nbreak;\r\ncase 6:\r\ninit_prbs = 0xD0;\r\nbreak;\r\ndefault:\r\ncase 7:\r\ninit_prbs = 0x48E;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_8K:\r\nswitch (sub_channel) {\r\ncase -6:\r\ninit_prbs = 0x0;\r\nbreak;\r\ncase -5:\r\ninit_prbs = 0x740;\r\nbreak;\r\ncase -4:\r\ninit_prbs = 0x069;\r\nbreak;\r\ncase -3:\r\ninit_prbs = 0x7DD;\r\nbreak;\r\ncase -2:\r\ninit_prbs = 0x208;\r\nbreak;\r\ncase -1:\r\ninit_prbs = 0x7B9;\r\nbreak;\r\ncase 0:\r\ninit_prbs = 0x5C7;\r\nbreak;\r\ncase 1:\r\ninit_prbs = 0x7FF;\r\nbreak;\r\ncase 2:\r\ninit_prbs = 0x53B;\r\nbreak;\r\ncase 3:\r\ninit_prbs = 0x29;\r\nbreak;\r\ncase 4:\r\ninit_prbs = 0x48E;\r\nbreak;\r\ncase 5:\r\ninit_prbs = 0x4C4;\r\nbreak;\r\ncase 6:\r\ninit_prbs = 0x367;\r\nbreak;\r\ndefault:\r\ncase 7:\r\ninit_prbs = 0x684;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n} else {\r\ndib8000_write_word(state, 27, (u16) ((state->cfg.pll->ifreq >> 16) & 0x01ff));\r\ndib8000_write_word(state, 28, (u16) (state->cfg.pll->ifreq & 0xffff));\r\ndib8000_write_word(state, 26, (u16) ((state->cfg.pll->ifreq >> 25) & 0x0003));\r\n}\r\ndib8000_write_word(state, 10, (seq << 4));\r\nswitch (state->fe[0]->dtv_property_cache.guard_interval) {\r\ncase GUARD_INTERVAL_1_32:\r\nguard = 0;\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\nguard = 1;\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\nguard = 2;\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\ndefault:\r\nguard = 3;\r\nbreak;\r\n}\r\ndib8000_write_word(state, 1, (init_prbs << 2) | (guard & 0x3));\r\nmax_constellation = DQPSK;\r\nfor (i = 0; i < 3; i++) {\r\nswitch (state->fe[0]->dtv_property_cache.layer[i].modulation) {\r\ncase DQPSK:\r\nconstellation = 0;\r\nbreak;\r\ncase QPSK:\r\nconstellation = 1;\r\nbreak;\r\ncase QAM_16:\r\nconstellation = 2;\r\nbreak;\r\ncase QAM_64:\r\ndefault:\r\nconstellation = 3;\r\nbreak;\r\n}\r\nswitch (state->fe[0]->dtv_property_cache.layer[i].fec) {\r\ncase FEC_1_2:\r\ncrate = 1;\r\nbreak;\r\ncase FEC_2_3:\r\ncrate = 2;\r\nbreak;\r\ncase FEC_3_4:\r\ncrate = 3;\r\nbreak;\r\ncase FEC_5_6:\r\ncrate = 5;\r\nbreak;\r\ncase FEC_7_8:\r\ndefault:\r\ncrate = 7;\r\nbreak;\r\n}\r\nif ((state->fe[0]->dtv_property_cache.layer[i].interleaving > 0) &&\r\n((state->fe[0]->dtv_property_cache.layer[i].interleaving <= 3) ||\r\n(state->fe[0]->dtv_property_cache.layer[i].interleaving == 4 && state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1))\r\n)\r\ntimeI = state->fe[0]->dtv_property_cache.layer[i].interleaving;\r\nelse\r\ntimeI = 0;\r\ndib8000_write_word(state, 2 + i, (constellation << 10) | ((state->fe[0]->dtv_property_cache.layer[i].segment_count & 0xf) << 6) |\r\n(crate << 3) | timeI);\r\nif (state->fe[0]->dtv_property_cache.layer[i].segment_count > 0) {\r\nswitch (max_constellation) {\r\ncase DQPSK:\r\ncase QPSK:\r\nif (state->fe[0]->dtv_property_cache.layer[i].modulation == QAM_16 ||\r\nstate->fe[0]->dtv_property_cache.layer[i].modulation == QAM_64)\r\nmax_constellation = state->fe[0]->dtv_property_cache.layer[i].modulation;\r\nbreak;\r\ncase QAM_16:\r\nif (state->fe[0]->dtv_property_cache.layer[i].modulation == QAM_64)\r\nmax_constellation = state->fe[0]->dtv_property_cache.layer[i].modulation;\r\nbreak;\r\n}\r\n}\r\n}\r\nmode = fft_to_mode(state);\r\ndib8000_write_word(state, 274, (dib8000_read_word(state, 274) & 0xffcf) |\r\n((state->fe[0]->dtv_property_cache.isdbt_partial_reception & 1) << 5) | ((state->fe[0]->dtv_property_cache.\r\nisdbt_sb_mode & 1) << 4));\r\ndprintk("mode = %d ; guard = %d", mode, state->fe[0]->dtv_property_cache.guard_interval);\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception) {\r\nseg_diff_mask = (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK) << permu_seg[0];\r\nfor (i = 1; i < 3; i++)\r\nnbseg_diff +=\r\n(state->fe[0]->dtv_property_cache.layer[i].modulation == DQPSK) * state->fe[0]->dtv_property_cache.layer[i].segment_count;\r\nfor (i = 0; i < nbseg_diff; i++)\r\nseg_diff_mask |= 1 << permu_seg[i + 1];\r\n} else {\r\nfor (i = 0; i < 3; i++)\r\nnbseg_diff +=\r\n(state->fe[0]->dtv_property_cache.layer[i].modulation == DQPSK) * state->fe[0]->dtv_property_cache.layer[i].segment_count;\r\nfor (i = 0; i < nbseg_diff; i++)\r\nseg_diff_mask |= 1 << permu_seg[i];\r\n}\r\ndprintk("nbseg_diff = %X (%d)", seg_diff_mask, seg_diff_mask);\r\nstate->differential_constellation = (seg_diff_mask != 0);\r\nif (state->revision != 0x8090)\r\ndib8000_set_diversity_in(state->fe[0], state->diversity_onoff);\r\nelse\r\ndib8096p_set_diversity_in(state->fe[0], state->diversity_onoff);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 1)\r\nseg_mask13 = 0x00E0;\r\nelse\r\nseg_mask13 = 0x0040;\r\n} else\r\nseg_mask13 = 0x1fff;\r\ndib8000_write_word(state, 0, (mode << 13) | seg_diff_mask);\r\nif ((seg_diff_mask) || (state->fe[0]->dtv_property_cache.isdbt_sb_mode))\r\ndib8000_write_word(state, 268, (dib8000_read_word(state, 268) & 0xF9FF) | 0x0200);\r\nelse\r\ndib8000_write_word(state, 268, (2 << 9) | 39);\r\ndib8000_write_word(state, 352, seg_diff_mask);\r\ndib8000_write_word(state, 353, seg_mask13);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\nswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {\r\nif (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK)\r\nncoeff = coeff_2k_sb_1seg_dqpsk;\r\nelse\r\nncoeff = coeff_2k_sb_1seg;\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK) {\r\nif (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK)\r\nncoeff = coeff_2k_sb_3seg_0dqpsk_1dqpsk;\r\nelse\r\nncoeff = coeff_2k_sb_3seg_0dqpsk;\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK)\r\nncoeff = coeff_2k_sb_3seg_1dqpsk;\r\nelse\r\nncoeff = coeff_2k_sb_3seg;\r\n}\r\n}\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {\r\nif (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK)\r\nncoeff = coeff_4k_sb_1seg_dqpsk;\r\nelse\r\nncoeff = coeff_4k_sb_1seg;\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK) {\r\nif (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK) {\r\nncoeff = coeff_4k_sb_3seg_0dqpsk_1dqpsk;\r\n} else {\r\nncoeff = coeff_4k_sb_3seg_0dqpsk;\r\n}\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK) {\r\nncoeff = coeff_4k_sb_3seg_1dqpsk;\r\n} else\r\nncoeff = coeff_4k_sb_3seg;\r\n}\r\n}\r\nbreak;\r\ncase TRANSMISSION_MODE_AUTO:\r\ncase TRANSMISSION_MODE_8K:\r\ndefault:\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {\r\nif (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK)\r\nncoeff = coeff_8k_sb_1seg_dqpsk;\r\nelse\r\nncoeff = coeff_8k_sb_1seg;\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK) {\r\nif (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK) {\r\nncoeff = coeff_8k_sb_3seg_0dqpsk_1dqpsk;\r\n} else {\r\nncoeff = coeff_8k_sb_3seg_0dqpsk;\r\n}\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK) {\r\nncoeff = coeff_8k_sb_3seg_1dqpsk;\r\n} else\r\nncoeff = coeff_8k_sb_3seg;\r\n}\r\n}\r\nbreak;\r\n}\r\nfor (i = 0; i < 8; i++)\r\ndib8000_write_word(state, 343 + i, ncoeff[i]);\r\n}\r\ndib8000_write_word(state, 351,\r\n(state->fe[0]->dtv_property_cache.isdbt_sb_mode << 9) | (state->fe[0]->dtv_property_cache.isdbt_sb_mode << 8) | (13 << 4) | 5);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\ndib8000_write_word(state, 187,\r\n(4 << 12) | (0 << 11) | (63 << 5) | (0x3 << 3) | ((~state->fe[0]->dtv_property_cache.isdbt_partial_reception & 1) << 2)\r\n| 0x3);\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {\r\nif (mode == 3)\r\ndib8000_write_word(state, 180, 0x1fcf | ((mode - 1) << 14));\r\nelse\r\ndib8000_write_word(state, 180, 0x0fcf | ((mode - 1) << 14));\r\ndib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (5 << 5) | 4);\r\ndib8000_write_word(state, 340, (16 << 6) | (8 << 0));\r\ndib8000_write_word(state, 341, (6 << 3) | (1 << 2) | (1 << 1) | (1 << 0));\r\ndib8000_write_word(state, 181, 300);\r\ndib8000_write_word(state, 182, 150);\r\ndib8000_write_word(state, 183, 80);\r\ndib8000_write_word(state, 184, 300);\r\ndib8000_write_word(state, 185, 150);\r\ndib8000_write_word(state, 186, 80);\r\n} else {\r\ndib8000_write_word(state, 180, 0x1fcf | (1 << 14));\r\ndib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (4 << 5) | 4);\r\ndib8000_write_word(state, 340, (16 << 6) | (8 << 0));\r\ndib8000_write_word(state, 341, (6 << 3) | (1 << 2) | (1 << 1) | (1 << 0));\r\ndib8000_write_word(state, 181, 350);\r\ndib8000_write_word(state, 182, 300);\r\ndib8000_write_word(state, 183, 250);\r\ndib8000_write_word(state, 184, 350);\r\ndib8000_write_word(state, 185, 300);\r\ndib8000_write_word(state, 186, 250);\r\n}\r\n} else if (state->isdbt_cfg_loaded == 0) {\r\ndib8000_write_word(state, 180, (16 << 6) | 9);\r\ndib8000_write_word(state, 187, (4 << 12) | (8 << 5) | 0x2);\r\ncoff_pow = 0x2800;\r\nfor (i = 0; i < 6; i++)\r\ndib8000_write_word(state, 181 + i, coff_pow);\r\ndib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (3 << 5) | 1);\r\ndib8000_write_word(state, 340, (8 << 6) | (6 << 0));\r\ndib8000_write_word(state, 341, (4 << 3) | (1 << 2) | (1 << 1) | (1 << 0));\r\n}\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1 && state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0)\r\ndib8000_write_word(state, 178, 64);\r\nelse\r\ndib8000_write_word(state, 178, 32);\r\ndib8000_write_word(state, 189, ~seg_mask13 | seg_diff_mask);\r\ndib8000_write_word(state, 192, ~seg_mask13 | seg_diff_mask);\r\ndib8000_write_word(state, 225, ~seg_mask13 | seg_diff_mask);\r\nif ((!state->fe[0]->dtv_property_cache.isdbt_sb_mode) && (state->cfg.pll->ifreq == 0))\r\ndib8000_write_word(state, 266, ~seg_mask13 | seg_diff_mask | 0x40);\r\nelse\r\ndib8000_write_word(state, 266, ~seg_mask13 | seg_diff_mask);\r\ndib8000_write_word(state, 287, ~seg_mask13 | 0x1000);\r\nif (!autosearching)\r\ndib8000_write_word(state, 288, (~seg_mask13 | seg_diff_mask) & 0x1fff);\r\nelse\r\ndib8000_write_word(state, 288, 0x1fff);\r\ndprintk("287 = %X (%d)", ~seg_mask13 | 0x1000, ~seg_mask13 | 0x1000);\r\ndib8000_write_word(state, 211, seg_mask13 & (~seg_diff_mask));\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0)\r\ndib8000_write_word(state, 32, ((11 - mode) << 12) | (6 << 8) | 0x40);\r\nelse\r\ndib8000_write_word(state, 32, ((10 - mode) << 12) | (6 << 8) | 0x60);\r\n} else\r\ndib8000_write_word(state, 32, ((9 - mode) << 12) | (6 << 8) | 0x80);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0)\r\ndib8000_write_word(state, 37, (3 << 5) | (0 << 4) | (10 - mode));\r\nelse\r\ndib8000_write_word(state, 37, (3 << 5) | (0 << 4) | (9 - mode));\r\n} else\r\ndib8000_write_word(state, 37, (3 << 5) | (0 << 4) | (8 - mode));\r\nswitch (state->fe[0]->dtv_property_cache.transmission_mode) {\r\ncase TRANSMISSION_MODE_8K:\r\nmode = 256;\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nmode = 128;\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_2K:\r\nmode = 64;\r\nbreak;\r\n}\r\nif (state->cfg.diversity_delay == 0)\r\nmode = (mode * (1 << (guard)) * 3) / 2 + 48;\r\nelse\r\nmode = (mode * (1 << (guard)) * 3) / 2 + state->cfg.diversity_delay;\r\nmode <<= 4;\r\ndib8000_write_word(state, 273, (dib8000_read_word(state, 273) & 0x000f) | mode);\r\nswitch (max_constellation) {\r\ncase QAM_64:\r\nana_gain = 0x7;\r\ncoeff[0] = 0x0148;\r\ncoeff[1] = 0xfff0;\r\ncoeff[2] = 0x00a4;\r\ncoeff[3] = 0xfff8;\r\nbreak;\r\ncase QAM_16:\r\nana_gain = 0x7;\r\ncoeff[0] = 0x023d;\r\ncoeff[1] = 0xffdf;\r\ncoeff[2] = 0x00a4;\r\ncoeff[3] = 0xfff0;\r\nbreak;\r\ndefault:\r\nana_gain = 0;\r\ncoeff[0] = 0x099a;\r\ncoeff[1] = 0xffae;\r\ncoeff[2] = 0x0333;\r\ncoeff[3] = 0xfff8;\r\nbreak;\r\n}\r\nfor (mode = 0; mode < 4; mode++)\r\ndib8000_write_word(state, 215 + mode, coeff[mode]);\r\ndib8000_write_word(state, 116, ana_gain);\r\nif (ana_gain) {\r\nfor (i = 0; i < 10; i++)\r\ndib8000_write_word(state, 80 + i, adc_target_16dB[i]);\r\n} else {\r\nfor (i = 0; i < 10; i++)\r\ndib8000_write_word(state, 80 + i, adc_target_16dB[i] - 355);\r\n}\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 1)\r\nana_fe = ana_fe_coeff_3seg;\r\nelse\r\nana_fe = ana_fe_coeff_1seg;\r\n} else\r\nana_fe = ana_fe_coeff_13seg;\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1 || state->isdbt_cfg_loaded == 0)\r\nfor (mode = 0; mode < 24; mode++)\r\ndib8000_write_word(state, 117 + mode, ana_fe[mode]);\r\nfor (i = 0; i < 13; i++) {\r\nif ((((~seg_diff_mask) >> i) & 1) == 1) {\r\nP_cfr_left_edge += (1 << i) * ((i == 0) || ((((seg_mask13 & (~seg_diff_mask)) >> (i - 1)) & 1) == 0));\r\nP_cfr_right_edge += (1 << i) * ((i == 12) || ((((seg_mask13 & (~seg_diff_mask)) >> (i + 1)) & 1) == 0));\r\n}\r\n}\r\ndib8000_write_word(state, 222, P_cfr_left_edge);\r\ndib8000_write_word(state, 223, P_cfr_right_edge);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\ndib8000_write_word(state, 228, 1);\r\ndib8000_write_word(state, 205, dib8000_read_word(state, 205) & 0xfff0);\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0\r\n&& state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_2K) {\r\ndib8000_write_word(state, 265, 15);\r\n}\r\n} else if (state->isdbt_cfg_loaded == 0) {\r\ndib8000_write_word(state, 228, 0);\r\ndib8000_write_word(state, 265, 31);\r\ndib8000_write_word(state, 205, 0x200f);\r\n}\r\nfor (i = 0; i < 3; i++)\r\ntmcc_pow +=\r\n(((state->fe[0]->dtv_property_cache.layer[i].modulation == DQPSK) * 4 + 1) * state->fe[0]->dtv_property_cache.layer[i].segment_count);\r\ntmcc_pow *= (1 << (9 - 2));\r\ndib8000_write_word(state, 290, tmcc_pow);\r\ndib8000_write_word(state, 291, tmcc_pow);\r\ndib8000_write_word(state, 292, tmcc_pow);\r\nif (state->isdbt_cfg_loaded == 0)\r\ndib8000_write_word(state, 250, 3285);\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1)\r\nstate->isdbt_cfg_loaded = 0;\r\nelse\r\nstate->isdbt_cfg_loaded = 1;\r\n}\r\nstatic int dib8000_autosearch_start(struct dvb_frontend *fe)\r\n{\r\nu8 factor;\r\nu32 value;\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nint slist = 0;\r\nstate->fe[0]->dtv_property_cache.inversion = 0;\r\nif (!state->fe[0]->dtv_property_cache.isdbt_sb_mode)\r\nstate->fe[0]->dtv_property_cache.layer[0].segment_count = 13;\r\nstate->fe[0]->dtv_property_cache.layer[0].modulation = QAM_64;\r\nstate->fe[0]->dtv_property_cache.layer[0].fec = FEC_2_3;\r\nstate->fe[0]->dtv_property_cache.layer[0].interleaving = 0;\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode) {\r\nstate->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_8K;\r\nstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_8;\r\nslist = 7;\r\ndib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.guard_interval == GUARD_INTERVAL_AUTO) {\r\nif (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO) {\r\nslist = 7;\r\ndib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));\r\n} else\r\nslist = 3;\r\n} else {\r\nif (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO) {\r\nslist = 2;\r\ndib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));\r\n} else\r\nslist = 0;\r\n}\r\nif (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO)\r\nstate->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_8K;\r\nif (state->fe[0]->dtv_property_cache.guard_interval == GUARD_INTERVAL_AUTO)\r\nstate->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_8;\r\ndprintk("using list for autosearch : %d", slist);\r\ndib8000_set_channel(state, (unsigned char)slist, 1);\r\nfactor = 1;\r\ndib8000_write_word(state, 6, 0x4);\r\ndib8000_write_word(state, 7, 0x8);\r\ndib8000_write_word(state, 8, 0x1000);\r\nvalue = 50 * state->cfg.pll->internal * factor;\r\ndib8000_write_word(state, 11, (u16) ((value >> 16) & 0xffff));\r\ndib8000_write_word(state, 12, (u16) (value & 0xffff));\r\nvalue = 100 * state->cfg.pll->internal * factor;\r\ndib8000_write_word(state, 13, (u16) ((value >> 16) & 0xffff));\r\ndib8000_write_word(state, 14, (u16) (value & 0xffff));\r\nvalue = 1000 * state->cfg.pll->internal * factor;\r\ndib8000_write_word(state, 15, (u16) ((value >> 16) & 0xffff));\r\ndib8000_write_word(state, 16, (u16) (value & 0xffff));\r\nvalue = dib8000_read_word(state, 0);\r\ndib8000_write_word(state, 0, (u16) ((1 << 15) | value));\r\ndib8000_read_word(state, 1284);\r\ndib8000_write_word(state, 0, (u16) value);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_autosearch_irq(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 irq_pending = dib8000_read_word(state, 1284);\r\nif (irq_pending & 0x1) {\r\ndprintk("dib8000_autosearch_irq failed");\r\nreturn 1;\r\n}\r\nif (irq_pending & 0x2) {\r\ndprintk("dib8000_autosearch_irq succeeded");\r\nreturn 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_tune(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nint ret = 0;\r\nu16 lock, value, mode;\r\nif (state == NULL)\r\nreturn -EINVAL;\r\nmode = fft_to_mode(state);\r\ndib8000_set_bandwidth(fe, state->fe[0]->dtv_property_cache.bandwidth_hz / 1000);\r\ndib8000_set_channel(state, 0, 0);\r\nret |= dib8000_write_word(state, 770, 0x4000);\r\nret |= dib8000_write_word(state, 770, 0x0000);\r\nmsleep(45);\r\nif (state->timf == 0) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0)\r\nmsleep(300);\r\nelse\r\nmsleep(500);\r\n} else\r\nmsleep(200);\r\n}\r\nif (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {\r\nif (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {\r\ndib8000_write_word(state, 32, ((13 - mode) << 12) | (6 << 8) | 0x40);\r\nret |= dib8000_write_word(state, 37, (12 - mode) | ((5 + mode) << 5));\r\n} else {\r\ndib8000_write_word(state, 32, ((12 - mode) << 12) | (6 << 8) | 0x60);\r\nret |= dib8000_write_word(state, 37, (11 - mode) | ((5 + mode) << 5));\r\n}\r\n} else {\r\ndib8000_write_word(state, 32, ((11 - mode) << 12) | (6 << 8) | 0x80);\r\nret |= dib8000_write_word(state, 37, (10 - mode) | ((5 + mode) << 5));\r\n}\r\nif (state->revision != 0x8090)\r\nlock = dib8000_read_word(state, 568);\r\nelse\r\nlock = dib8000_read_word(state, 570);\r\nif ((lock >> 11) & 0x1)\r\ndib8000_update_timf(state);\r\ndib8000_write_word(state, 6, 0x200);\r\nif (state->revision == 0x8002) {\r\nvalue = dib8000_read_word(state, 903);\r\ndib8000_write_word(state, 903, value & ~(1 << 3));\r\nmsleep(1);\r\ndib8000_write_word(state, 903, value | (1 << 3));\r\n}\r\nreturn ret;\r\n}\r\nstatic int dib8000_wakeup(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nint ret;\r\ndib8000_set_power_mode(state, DIB8000_POWER_ALL);\r\ndib8000_set_adc_state(state, DIBX000_ADC_ON);\r\nif (dib8000_set_adc_state(state, DIBX000_SLOW_ADC_ON) != 0)\r\ndprintk("could not start Slow ADC");\r\nif (state->revision != 0x8090)\r\ndib8000_sad_calib(state);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nret = state->fe[index_frontend]->ops.init(state->fe[index_frontend]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nint ret;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nret = state->fe[index_frontend]->ops.sleep(state->fe[index_frontend]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (state->revision != 0x8090)\r\ndib8000_set_output_mode(fe, OUTMODE_HIGH_Z);\r\ndib8000_set_power_mode(state, DIB8000_POWER_INTERFACE_ONLY);\r\nreturn dib8000_set_adc_state(state, DIBX000_SLOW_ADC_OFF) | dib8000_set_adc_state(state, DIBX000_ADC_OFF);\r\n}\r\nenum frontend_tune_state dib8000_get_tune_state(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nreturn state->tune_state;\r\n}\r\nint dib8000_set_tune_state(struct dvb_frontend *fe, enum frontend_tune_state tune_state)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nstate->tune_state = tune_state;\r\nreturn 0;\r\n}\r\nstatic int dib8000_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 i, val = 0;\r\nfe_status_t stat;\r\nu8 index_frontend, sub_index_frontend;\r\nfe->dtv_property_cache.bandwidth_hz = 6000000;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->ops.read_status(state->fe[index_frontend], &stat);\r\nif (stat&FE_HAS_SYNC) {\r\ndprintk("TMCC lock on the slave%i", index_frontend);\r\nstate->fe[index_frontend]->ops.get_frontend(state->fe[index_frontend]);\r\nfor (sub_index_frontend = 0; (sub_index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[sub_index_frontend] != NULL); sub_index_frontend++) {\r\nif (sub_index_frontend != index_frontend) {\r\nstate->fe[sub_index_frontend]->dtv_property_cache.isdbt_sb_mode = state->fe[index_frontend]->dtv_property_cache.isdbt_sb_mode;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.inversion = state->fe[index_frontend]->dtv_property_cache.inversion;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.transmission_mode = state->fe[index_frontend]->dtv_property_cache.transmission_mode;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.guard_interval = state->fe[index_frontend]->dtv_property_cache.guard_interval;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.isdbt_partial_reception = state->fe[index_frontend]->dtv_property_cache.isdbt_partial_reception;\r\nfor (i = 0; i < 3; i++) {\r\nstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].segment_count = state->fe[index_frontend]->dtv_property_cache.layer[i].segment_count;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].interleaving = state->fe[index_frontend]->dtv_property_cache.layer[i].interleaving;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].fec = state->fe[index_frontend]->dtv_property_cache.layer[i].fec;\r\nstate->fe[sub_index_frontend]->dtv_property_cache.layer[i].modulation = state->fe[index_frontend]->dtv_property_cache.layer[i].modulation;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\n}\r\nfe->dtv_property_cache.isdbt_sb_mode = dib8000_read_word(state, 508) & 0x1;\r\nif (state->revision == 0x8090)\r\nval = dib8000_read_word(state, 572);\r\nelse\r\nval = dib8000_read_word(state, 570);\r\nfe->dtv_property_cache.inversion = (val & 0x40) >> 6;\r\nswitch ((val & 0x30) >> 4) {\r\ncase 1:\r\nfe->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nfe->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\n}\r\nswitch (val & 0x3) {\r\ncase 0:\r\nfe->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_32;\r\ndprintk("dib8000_get_frontend GI = 1/32 ");\r\nbreak;\r\ncase 1:\r\nfe->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_16;\r\ndprintk("dib8000_get_frontend GI = 1/16 ");\r\nbreak;\r\ncase 2:\r\ndprintk("dib8000_get_frontend GI = 1/8 ");\r\nfe->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\ndprintk("dib8000_get_frontend GI = 1/4 ");\r\nfe->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nval = dib8000_read_word(state, 505);\r\nfe->dtv_property_cache.isdbt_partial_reception = val & 1;\r\ndprintk("dib8000_get_frontend : partial_reception = %d ", fe->dtv_property_cache.isdbt_partial_reception);\r\nfor (i = 0; i < 3; i++) {\r\nval = dib8000_read_word(state, 493 + i);\r\nfe->dtv_property_cache.layer[i].segment_count = val & 0x0F;\r\ndprintk("dib8000_get_frontend : Layer %d segments = %d ", i, fe->dtv_property_cache.layer[i].segment_count);\r\nval = dib8000_read_word(state, 499 + i);\r\nfe->dtv_property_cache.layer[i].interleaving = val & 0x3;\r\ndprintk("dib8000_get_frontend : Layer %d time_intlv = %d ", i, fe->dtv_property_cache.layer[i].interleaving);\r\nval = dib8000_read_word(state, 481 + i);\r\nswitch (val & 0x7) {\r\ncase 1:\r\nfe->dtv_property_cache.layer[i].fec = FEC_1_2;\r\ndprintk("dib8000_get_frontend : Layer %d Code Rate = 1/2 ", i);\r\nbreak;\r\ncase 2:\r\nfe->dtv_property_cache.layer[i].fec = FEC_2_3;\r\ndprintk("dib8000_get_frontend : Layer %d Code Rate = 2/3 ", i);\r\nbreak;\r\ncase 3:\r\nfe->dtv_property_cache.layer[i].fec = FEC_3_4;\r\ndprintk("dib8000_get_frontend : Layer %d Code Rate = 3/4 ", i);\r\nbreak;\r\ncase 5:\r\nfe->dtv_property_cache.layer[i].fec = FEC_5_6;\r\ndprintk("dib8000_get_frontend : Layer %d Code Rate = 5/6 ", i);\r\nbreak;\r\ndefault:\r\nfe->dtv_property_cache.layer[i].fec = FEC_7_8;\r\ndprintk("dib8000_get_frontend : Layer %d Code Rate = 7/8 ", i);\r\nbreak;\r\n}\r\nval = dib8000_read_word(state, 487 + i);\r\nswitch (val & 0x3) {\r\ncase 0:\r\ndprintk("dib8000_get_frontend : Layer %d DQPSK ", i);\r\nfe->dtv_property_cache.layer[i].modulation = DQPSK;\r\nbreak;\r\ncase 1:\r\nfe->dtv_property_cache.layer[i].modulation = QPSK;\r\ndprintk("dib8000_get_frontend : Layer %d QPSK ", i);\r\nbreak;\r\ncase 2:\r\nfe->dtv_property_cache.layer[i].modulation = QAM_16;\r\ndprintk("dib8000_get_frontend : Layer %d QAM16 ", i);\r\nbreak;\r\ncase 3:\r\ndefault:\r\ndprintk("dib8000_get_frontend : Layer %d QAM64 ", i);\r\nfe->dtv_property_cache.layer[i].modulation = QAM_64;\r\nbreak;\r\n}\r\n}\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->dtv_property_cache.isdbt_sb_mode = fe->dtv_property_cache.isdbt_sb_mode;\r\nstate->fe[index_frontend]->dtv_property_cache.inversion = fe->dtv_property_cache.inversion;\r\nstate->fe[index_frontend]->dtv_property_cache.transmission_mode = fe->dtv_property_cache.transmission_mode;\r\nstate->fe[index_frontend]->dtv_property_cache.guard_interval = fe->dtv_property_cache.guard_interval;\r\nstate->fe[index_frontend]->dtv_property_cache.isdbt_partial_reception = fe->dtv_property_cache.isdbt_partial_reception;\r\nfor (i = 0; i < 3; i++) {\r\nstate->fe[index_frontend]->dtv_property_cache.layer[i].segment_count = fe->dtv_property_cache.layer[i].segment_count;\r\nstate->fe[index_frontend]->dtv_property_cache.layer[i].interleaving = fe->dtv_property_cache.layer[i].interleaving;\r\nstate->fe[index_frontend]->dtv_property_cache.layer[i].fec = fe->dtv_property_cache.layer[i].fec;\r\nstate->fe[index_frontend]->dtv_property_cache.layer[i].modulation = fe->dtv_property_cache.layer[i].modulation;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 nbr_pending, exit_condition, index_frontend;\r\ns8 index_frontend_success = -1;\r\nint time, ret;\r\nint time_slave = FE_CALLBACK_TIME_NEVER;\r\nif (state->fe[0]->dtv_property_cache.frequency == 0) {\r\ndprintk("dib8000: must at least specify frequency ");\r\nreturn 0;\r\n}\r\nif (state->fe[0]->dtv_property_cache.bandwidth_hz == 0) {\r\ndprintk("dib8000: no bandwidth specified, set to default ");\r\nstate->fe[0]->dtv_property_cache.bandwidth_hz = 6000000;\r\n}\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->dtv_property_cache.delivery_system = SYS_ISDBT;\r\nmemcpy(&state->fe[index_frontend]->dtv_property_cache, &fe->dtv_property_cache, sizeof(struct dtv_frontend_properties));\r\nif (state->revision != 0x8090)\r\ndib8000_set_output_mode(state->fe[index_frontend],\r\nOUTMODE_HIGH_Z);\r\nelse\r\ndib8096p_set_output_mode(state->fe[index_frontend],\r\nOUTMODE_HIGH_Z);\r\nif (state->fe[index_frontend]->ops.tuner_ops.set_params)\r\nstate->fe[index_frontend]->ops.tuner_ops.set_params(state->fe[index_frontend]);\r\ndib8000_set_tune_state(state->fe[index_frontend], CT_AGC_START);\r\n}\r\ndo {\r\ntime = dib8000_agc_startup(state->fe[0]);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\ntime_slave = dib8000_agc_startup(state->fe[index_frontend]);\r\nif (time == FE_CALLBACK_TIME_NEVER)\r\ntime = time_slave;\r\nelse if ((time_slave != FE_CALLBACK_TIME_NEVER) && (time_slave > time))\r\ntime = time_slave;\r\n}\r\nif (time != FE_CALLBACK_TIME_NEVER)\r\nmsleep(time / 10);\r\nelse\r\nbreak;\r\nexit_condition = 1;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nif (dib8000_get_tune_state(state->fe[index_frontend]) != CT_AGC_STOP) {\r\nexit_condition = 0;\r\nbreak;\r\n}\r\n}\r\n} while (exit_condition == 0);\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\ndib8000_set_tune_state(state->fe[index_frontend], CT_DEMOD_START);\r\nif ((state->fe[0]->dtv_property_cache.delivery_system != SYS_ISDBT) ||\r\n(state->fe[0]->dtv_property_cache.inversion == INVERSION_AUTO) ||\r\n(state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO) ||\r\n(state->fe[0]->dtv_property_cache.guard_interval == GUARD_INTERVAL_AUTO) ||\r\n(((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (1 << 0)) != 0) &&\r\n(state->fe[0]->dtv_property_cache.layer[0].segment_count != 0xff) &&\r\n(state->fe[0]->dtv_property_cache.layer[0].segment_count != 0) &&\r\n((state->fe[0]->dtv_property_cache.layer[0].modulation == QAM_AUTO) ||\r\n(state->fe[0]->dtv_property_cache.layer[0].fec == FEC_AUTO))) ||\r\n(((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (1 << 1)) != 0) &&\r\n(state->fe[0]->dtv_property_cache.layer[1].segment_count != 0xff) &&\r\n(state->fe[0]->dtv_property_cache.layer[1].segment_count != 0) &&\r\n((state->fe[0]->dtv_property_cache.layer[1].modulation == QAM_AUTO) ||\r\n(state->fe[0]->dtv_property_cache.layer[1].fec == FEC_AUTO))) ||\r\n(((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (1 << 2)) != 0) &&\r\n(state->fe[0]->dtv_property_cache.layer[2].segment_count != 0xff) &&\r\n(state->fe[0]->dtv_property_cache.layer[2].segment_count != 0) &&\r\n((state->fe[0]->dtv_property_cache.layer[2].modulation == QAM_AUTO) ||\r\n(state->fe[0]->dtv_property_cache.layer[2].fec == FEC_AUTO))) ||\r\n(((state->fe[0]->dtv_property_cache.layer[0].segment_count == 0) ||\r\n((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (1 << 0)) == 0)) &&\r\n((state->fe[0]->dtv_property_cache.layer[1].segment_count == 0) ||\r\n((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (2 << 0)) == 0)) &&\r\n((state->fe[0]->dtv_property_cache.layer[2].segment_count == 0) || ((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (3 << 0)) == 0)))) {\r\nint i = 100;\r\nu8 found = 0;\r\nu8 tune_failed = 0;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\ndib8000_set_bandwidth(state->fe[index_frontend], fe->dtv_property_cache.bandwidth_hz / 1000);\r\ndib8000_autosearch_start(state->fe[index_frontend]);\r\n}\r\ndo {\r\nmsleep(20);\r\nnbr_pending = 0;\r\nexit_condition = 0;\r\nfor (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nif (((tune_failed >> index_frontend) & 0x1) == 0) {\r\nfound = dib8000_autosearch_irq(state->fe[index_frontend]);\r\nswitch (found) {\r\ncase 0:\r\nnbr_pending++;\r\nbreak;\r\ncase 2:\r\ndprintk("autosearch succeed on the frontend%i", index_frontend);\r\nexit_condition = 2;\r\nindex_frontend_success = index_frontend;\r\nbreak;\r\ndefault:\r\ndprintk("unhandled autosearch result");\r\ncase 1:\r\ntune_failed |= (1 << index_frontend);\r\ndprintk("autosearch failed for the frontend%i", index_frontend);\r\nbreak;\r\n}\r\n}\r\n}\r\nif ((nbr_pending == 0) && (exit_condition == 0))\r\nexit_condition = 1;\r\n} while ((exit_condition == 0) && i--);\r\nif (exit_condition == 1) {\r\ndprintk("tune failed");\r\nreturn 0;\r\n}\r\ndprintk("tune success on frontend%i", index_frontend_success);\r\ndib8000_get_frontend(fe);\r\n}\r\nfor (index_frontend = 0, ret = 0; (ret >= 0) && (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\nret = dib8000_tune(state->fe[index_frontend]);\r\nif (state->revision != 0x8090) {\r\ndib8000_set_output_mode(state->fe[0], state->cfg.output_mode);\r\nfor (index_frontend = 1;\r\n(index_frontend < MAX_NUMBER_OF_FRONTENDS) &&\r\n(state->fe[index_frontend] != NULL);\r\nindex_frontend++) {\r\ndib8000_set_output_mode(state->fe[index_frontend],\r\nOUTMODE_DIVERSITY);\r\ndib8000_set_diversity_in(state->fe[index_frontend-1], 1);\r\n}\r\ndib8000_set_diversity_in(state->fe[index_frontend-1], 0);\r\n} else {\r\ndib8096p_set_output_mode(state->fe[0], state->cfg.output_mode);\r\nif (state->cfg.enMpegOutput == 0) {\r\ndib8096p_setDibTxMux(state, MPEG_ON_DIBTX);\r\ndib8096p_setHostBusMux(state, DIBTX_ON_HOSTBUS);\r\n}\r\nfor (index_frontend = 1;\r\n(index_frontend < MAX_NUMBER_OF_FRONTENDS) &&\r\n(state->fe[index_frontend] != NULL);\r\nindex_frontend++) {\r\ndib8096p_set_output_mode(state->fe[index_frontend],\r\nOUTMODE_DIVERSITY);\r\ndib8096p_set_diversity_in(state->fe[index_frontend-1], 1);\r\n}\r\ndib8096p_set_diversity_in(state->fe[index_frontend-1], 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic u16 dib8000_read_lock(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif (state->revision == 0x8090)\r\nreturn dib8000_read_word(state, 570);\r\nreturn dib8000_read_word(state, 568);\r\n}\r\nstatic int dib8000_read_status(struct dvb_frontend *fe, fe_status_t * stat)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu16 lock_slave = 0, lock;\r\nu8 index_frontend;\r\nif (state->revision == 0x8090)\r\nlock = dib8000_read_word(state, 570);\r\nelse\r\nlock = dib8000_read_word(state, 568);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\nlock_slave |= dib8000_read_lock(state->fe[index_frontend]);\r\n*stat = 0;\r\nif (((lock >> 13) & 1) || ((lock_slave >> 13) & 1))\r\n*stat |= FE_HAS_SIGNAL;\r\nif (((lock >> 8) & 1) || ((lock_slave >> 8) & 1))\r\n*stat |= FE_HAS_CARRIER;\r\nif ((((lock >> 1) & 0xf) == 0xf) || (((lock_slave >> 1) & 0xf) == 0xf))\r\n*stat |= FE_HAS_SYNC;\r\nif ((((lock >> 12) & 1) || ((lock_slave >> 12) & 1)) && ((lock >> 5) & 7))\r\n*stat |= FE_HAS_LOCK;\r\nif (((lock >> 12) & 1) || ((lock_slave >> 12) & 1)) {\r\nlock = dib8000_read_word(state, 554);\r\nif (lock & 0x01)\r\n*stat |= FE_HAS_VITERBI;\r\nlock = dib8000_read_word(state, 555);\r\nif (lock & 0x01)\r\n*stat |= FE_HAS_VITERBI;\r\nlock = dib8000_read_word(state, 556);\r\nif (lock & 0x01)\r\n*stat |= FE_HAS_VITERBI;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib8000_read_ber(struct dvb_frontend *fe, u32 * ber)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif (state->revision == 0x8090)\r\n*ber = (dib8000_read_word(state, 562) << 16) |\r\ndib8000_read_word(state, 563);\r\nelse\r\n*ber = (dib8000_read_word(state, 560) << 16) |\r\ndib8000_read_word(state, 561);\r\nreturn 0;\r\n}\r\nstatic int dib8000_read_unc_blocks(struct dvb_frontend *fe, u32 * unc)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif (state->revision == 0x8090)\r\n*unc = dib8000_read_word(state, 567);\r\nelse\r\n*unc = dib8000_read_word(state, 565);\r\nreturn 0;\r\n}\r\nstatic int dib8000_read_signal_strength(struct dvb_frontend *fe, u16 * strength)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nu16 val;\r\n*strength = 0;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {\r\nstate->fe[index_frontend]->ops.read_signal_strength(state->fe[index_frontend], &val);\r\nif (val > 65535 - *strength)\r\n*strength = 65535;\r\nelse\r\n*strength += val;\r\n}\r\nval = 65535 - dib8000_read_word(state, 390);\r\nif (val > 65535 - *strength)\r\n*strength = 65535;\r\nelse\r\n*strength += val;\r\nreturn 0;\r\n}\r\nstatic u32 dib8000_get_snr(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu32 n, s, exp;\r\nu16 val;\r\nif (state->revision != 0x8090)\r\nval = dib8000_read_word(state, 542);\r\nelse\r\nval = dib8000_read_word(state, 544);\r\nn = (val >> 6) & 0xff;\r\nexp = (val & 0x3f);\r\nif ((exp & 0x20) != 0)\r\nexp -= 0x40;\r\nn <<= exp+16;\r\nif (state->revision != 0x8090)\r\nval = dib8000_read_word(state, 543);\r\nelse\r\nval = dib8000_read_word(state, 545);\r\ns = (val >> 6) & 0xff;\r\nexp = (val & 0x3f);\r\nif ((exp & 0x20) != 0)\r\nexp -= 0x40;\r\ns <<= exp+16;\r\nif (n > 0) {\r\nu32 t = (s/n) << 16;\r\nreturn t + ((s << 16) - n*t) / n;\r\n}\r\nreturn 0xffffffff;\r\n}\r\nstatic int dib8000_read_snr(struct dvb_frontend *fe, u16 * snr)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend;\r\nu32 snr_master;\r\nsnr_master = dib8000_get_snr(fe);\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)\r\nsnr_master += dib8000_get_snr(state->fe[index_frontend]);\r\nif ((snr_master >> 16) != 0) {\r\nsnr_master = 10*intlog10(snr_master>>16);\r\n*snr = snr_master / ((1 << 24) / 10);\r\n}\r\nelse\r\n*snr = 0;\r\nreturn 0;\r\n}\r\nint dib8000_set_slave_frontend(struct dvb_frontend *fe, struct dvb_frontend *fe_slave)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend = 1;\r\nwhile ((index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL))\r\nindex_frontend++;\r\nif (index_frontend < MAX_NUMBER_OF_FRONTENDS) {\r\ndprintk("set slave fe %p to index %i", fe_slave, index_frontend);\r\nstate->fe[index_frontend] = fe_slave;\r\nreturn 0;\r\n}\r\ndprintk("too many slave frontend");\r\nreturn -ENOMEM;\r\n}\r\nint dib8000_remove_slave_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nu8 index_frontend = 1;\r\nwhile ((index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL))\r\nindex_frontend++;\r\nif (index_frontend != 1) {\r\ndprintk("remove slave fe %p (index %i)", state->fe[index_frontend-1], index_frontend-1);\r\nstate->fe[index_frontend] = NULL;\r\nreturn 0;\r\n}\r\ndprintk("no frontend to be removed");\r\nreturn -ENODEV;\r\n}\r\nstruct dvb_frontend *dib8000_get_slave_frontend(struct dvb_frontend *fe, int slave_index)\r\n{\r\nstruct dib8000_state *state = fe->demodulator_priv;\r\nif (slave_index >= MAX_NUMBER_OF_FRONTENDS)\r\nreturn NULL;\r\nreturn state->fe[slave_index];\r\n}\r\nint dib8000_i2c_enumeration(struct i2c_adapter *host, int no_of_demods,\r\nu8 default_addr, u8 first_addr, u8 is_dib8096p)\r\n{\r\nint k = 0, ret = 0;\r\nu8 new_addr = 0;\r\nstruct i2c_device client = {.adap = host };\r\nclient.i2c_write_buffer = kzalloc(4 * sizeof(u8), GFP_KERNEL);\r\nif (!client.i2c_write_buffer) {\r\ndprintk("%s: not enough memory", __func__);\r\nreturn -ENOMEM;\r\n}\r\nclient.i2c_read_buffer = kzalloc(4 * sizeof(u8), GFP_KERNEL);\r\nif (!client.i2c_read_buffer) {\r\ndprintk("%s: not enough memory", __func__);\r\nret = -ENOMEM;\r\ngoto error_memory_read;\r\n}\r\nclient.i2c_buffer_lock = kzalloc(sizeof(struct mutex), GFP_KERNEL);\r\nif (!client.i2c_buffer_lock) {\r\ndprintk("%s: not enough memory", __func__);\r\nret = -ENOMEM;\r\ngoto error_memory_lock;\r\n}\r\nmutex_init(client.i2c_buffer_lock);\r\nfor (k = no_of_demods - 1; k >= 0; k--) {\r\nnew_addr = first_addr + (k << 1);\r\nclient.addr = new_addr;\r\nif (!is_dib8096p)\r\ndib8000_i2c_write16(&client, 1287, 0x0003);\r\nif (dib8000_identify(&client) == 0) {\r\nif (!is_dib8096p)\r\ndib8000_i2c_write16(&client, 1287, 0x0003);\r\nclient.addr = default_addr;\r\nif (dib8000_identify(&client) == 0) {\r\ndprintk("#%d: not identified", k);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\n}\r\ndib8000_i2c_write16(&client, 1286, (1 << 10) | (4 << 6));\r\ndib8000_i2c_write16(&client, 1285, (new_addr << 2) | 0x2);\r\nclient.addr = new_addr;\r\ndib8000_identify(&client);\r\ndprintk("IC %d initialized (to i2c_address 0x%x)", k, new_addr);\r\n}\r\nfor (k = 0; k < no_of_demods; k++) {\r\nnew_addr = first_addr | (k << 1);\r\nclient.addr = new_addr;\r\ndib8000_i2c_write16(&client, 1285, new_addr << 2);\r\ndib8000_i2c_write16(&client, 1286, 0);\r\n}\r\nerror:\r\nkfree(client.i2c_buffer_lock);\r\nerror_memory_lock:\r\nkfree(client.i2c_read_buffer);\r\nerror_memory_read:\r\nkfree(client.i2c_write_buffer);\r\nreturn ret;\r\n}\r\nstatic int dib8000_fe_get_tune_settings(struct dvb_frontend *fe, struct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\ntune->step_size = 0;\r\ntune->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic void dib8000_release(struct dvb_frontend *fe)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\nu8 index_frontend;\r\nfor (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (st->fe[index_frontend] != NULL); index_frontend++)\r\ndvb_frontend_detach(st->fe[index_frontend]);\r\ndibx000_exit_i2c_master(&st->i2c_master);\r\ni2c_del_adapter(&st->dib8096p_tuner_adap);\r\nkfree(st->fe[0]);\r\nkfree(st);\r\n}\r\nstruct i2c_adapter *dib8000_get_i2c_master(struct dvb_frontend *fe, enum dibx000_i2c_interface intf, int gating)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\nreturn dibx000_get_i2c_adapter(&st->i2c_master, intf, gating);\r\n}\r\nint dib8000_pid_filter_ctrl(struct dvb_frontend *fe, u8 onoff)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\nu16 val = dib8000_read_word(st, 299) & 0xffef;\r\nval |= (onoff & 0x1) << 4;\r\ndprintk("pid filter enabled %d", onoff);\r\nreturn dib8000_write_word(st, 299, val);\r\n}\r\nint dib8000_pid_filter(struct dvb_frontend *fe, u8 id, u16 pid, u8 onoff)\r\n{\r\nstruct dib8000_state *st = fe->demodulator_priv;\r\ndprintk("Index %x, PID %d, OnOff %d", id, pid, onoff);\r\nreturn dib8000_write_word(st, 305 + id, onoff ? (1 << 13) | pid : 0);\r\n}\r\nstruct dvb_frontend *dib8000_attach(struct i2c_adapter *i2c_adap, u8 i2c_addr, struct dib8000_config *cfg)\r\n{\r\nstruct dvb_frontend *fe;\r\nstruct dib8000_state *state;\r\ndprintk("dib8000_attach");\r\nstate = kzalloc(sizeof(struct dib8000_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn NULL;\r\nfe = kzalloc(sizeof(struct dvb_frontend), GFP_KERNEL);\r\nif (fe == NULL)\r\ngoto error;\r\nmemcpy(&state->cfg, cfg, sizeof(struct dib8000_config));\r\nstate->i2c.adap = i2c_adap;\r\nstate->i2c.addr = i2c_addr;\r\nstate->i2c.i2c_write_buffer = state->i2c_write_buffer;\r\nstate->i2c.i2c_read_buffer = state->i2c_read_buffer;\r\nmutex_init(&state->i2c_buffer_lock);\r\nstate->i2c.i2c_buffer_lock = &state->i2c_buffer_lock;\r\nstate->gpio_val = cfg->gpio_val;\r\nstate->gpio_dir = cfg->gpio_dir;\r\nif ((state->cfg.output_mode != OUTMODE_MPEG2_SERIAL) && (state->cfg.output_mode != OUTMODE_MPEG2_PAR_GATED_CLK))\r\nstate->cfg.output_mode = OUTMODE_MPEG2_FIFO;\r\nstate->fe[0] = fe;\r\nfe->demodulator_priv = state;\r\nmemcpy(&state->fe[0]->ops, &dib8000_ops, sizeof(struct dvb_frontend_ops));\r\nstate->timf_default = cfg->pll->timf;\r\nif (dib8000_identify(&state->i2c) == 0)\r\ngoto error;\r\ndibx000_init_i2c_master(&state->i2c_master, DIB8000, state->i2c.adap, state->i2c.addr);\r\nstrncpy(state->dib8096p_tuner_adap.name, "DiB8096P tuner interface",\r\nsizeof(state->dib8096p_tuner_adap.name));\r\nstate->dib8096p_tuner_adap.algo = &dib8096p_tuner_xfer_algo;\r\nstate->dib8096p_tuner_adap.algo_data = NULL;\r\nstate->dib8096p_tuner_adap.dev.parent = state->i2c.adap->dev.parent;\r\ni2c_set_adapdata(&state->dib8096p_tuner_adap, state);\r\ni2c_add_adapter(&state->dib8096p_tuner_adap);\r\ndib8000_reset(fe);\r\ndib8000_write_word(state, 285, (dib8000_read_word(state, 285) & ~0x60) | (3 << 5));\r\nreturn fe;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
