static ssize_t modalias_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct rpmsg_channel *rpdev = to_rpmsg_channel(dev);\r\nreturn sprintf(buf, RPMSG_DEVICE_MODALIAS_FMT "\n", rpdev->id.name);\r\n}\r\nstatic inline int rpmsg_id_match(const struct rpmsg_channel *rpdev,\r\nconst struct rpmsg_device_id *id)\r\n{\r\nreturn strncmp(id->name, rpdev->id.name, RPMSG_NAME_SIZE) == 0;\r\n}\r\nstatic int rpmsg_dev_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct rpmsg_channel *rpdev = to_rpmsg_channel(dev);\r\nstruct rpmsg_driver *rpdrv = to_rpmsg_driver(drv);\r\nconst struct rpmsg_device_id *ids = rpdrv->id_table;\r\nunsigned int i;\r\nfor (i = 0; ids[i].name[0]; i++)\r\nif (rpmsg_id_match(rpdev, &ids[i]))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int rpmsg_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct rpmsg_channel *rpdev = to_rpmsg_channel(dev);\r\nreturn add_uevent_var(env, "MODALIAS=" RPMSG_DEVICE_MODALIAS_FMT,\r\nrpdev->id.name);\r\n}\r\nstatic void __ept_release(struct kref *kref)\r\n{\r\nstruct rpmsg_endpoint *ept = container_of(kref, struct rpmsg_endpoint,\r\nrefcount);\r\nkfree(ept);\r\n}\r\nstatic struct rpmsg_endpoint *__rpmsg_create_ept(struct virtproc_info *vrp,\r\nstruct rpmsg_channel *rpdev, rpmsg_rx_cb_t cb,\r\nvoid *priv, u32 addr)\r\n{\r\nint err, tmpaddr, request;\r\nstruct rpmsg_endpoint *ept;\r\nstruct device *dev = rpdev ? &rpdev->dev : &vrp->vdev->dev;\r\nif (!idr_pre_get(&vrp->endpoints, GFP_KERNEL))\r\nreturn NULL;\r\nept = kzalloc(sizeof(*ept), GFP_KERNEL);\r\nif (!ept) {\r\ndev_err(dev, "failed to kzalloc a new ept\n");\r\nreturn NULL;\r\n}\r\nkref_init(&ept->refcount);\r\nmutex_init(&ept->cb_lock);\r\nept->rpdev = rpdev;\r\nept->cb = cb;\r\nept->priv = priv;\r\nrequest = addr == RPMSG_ADDR_ANY ? RPMSG_RESERVED_ADDRESSES : addr;\r\nmutex_lock(&vrp->endpoints_lock);\r\nerr = idr_get_new_above(&vrp->endpoints, ept, request, &tmpaddr);\r\nif (err) {\r\ndev_err(dev, "idr_get_new_above failed: %d\n", err);\r\ngoto free_ept;\r\n}\r\nif (addr != RPMSG_ADDR_ANY && tmpaddr != addr) {\r\ndev_err(dev, "address 0x%x already in use\n", addr);\r\ngoto rem_idr;\r\n}\r\nept->addr = tmpaddr;\r\nmutex_unlock(&vrp->endpoints_lock);\r\nreturn ept;\r\nrem_idr:\r\nidr_remove(&vrp->endpoints, request);\r\nfree_ept:\r\nmutex_unlock(&vrp->endpoints_lock);\r\nkref_put(&ept->refcount, __ept_release);\r\nreturn NULL;\r\n}\r\nstruct rpmsg_endpoint *rpmsg_create_ept(struct rpmsg_channel *rpdev,\r\nrpmsg_rx_cb_t cb, void *priv, u32 addr)\r\n{\r\nreturn __rpmsg_create_ept(rpdev->vrp, rpdev, cb, priv, addr);\r\n}\r\nstatic void\r\n__rpmsg_destroy_ept(struct virtproc_info *vrp, struct rpmsg_endpoint *ept)\r\n{\r\nmutex_lock(&vrp->endpoints_lock);\r\nidr_remove(&vrp->endpoints, ept->addr);\r\nmutex_unlock(&vrp->endpoints_lock);\r\nmutex_lock(&ept->cb_lock);\r\nept->cb = NULL;\r\nmutex_unlock(&ept->cb_lock);\r\nkref_put(&ept->refcount, __ept_release);\r\n}\r\nvoid rpmsg_destroy_ept(struct rpmsg_endpoint *ept)\r\n{\r\n__rpmsg_destroy_ept(ept->rpdev->vrp, ept);\r\n}\r\nstatic int rpmsg_dev_probe(struct device *dev)\r\n{\r\nstruct rpmsg_channel *rpdev = to_rpmsg_channel(dev);\r\nstruct rpmsg_driver *rpdrv = to_rpmsg_driver(rpdev->dev.driver);\r\nstruct virtproc_info *vrp = rpdev->vrp;\r\nstruct rpmsg_endpoint *ept;\r\nint err;\r\nept = rpmsg_create_ept(rpdev, rpdrv->callback, NULL, rpdev->src);\r\nif (!ept) {\r\ndev_err(dev, "failed to create endpoint\n");\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nrpdev->ept = ept;\r\nrpdev->src = ept->addr;\r\nerr = rpdrv->probe(rpdev);\r\nif (err) {\r\ndev_err(dev, "%s: failed: %d\n", __func__, err);\r\nrpmsg_destroy_ept(ept);\r\ngoto out;\r\n}\r\nif (rpdev->announce &&\r\nvirtio_has_feature(vrp->vdev, VIRTIO_RPMSG_F_NS)) {\r\nstruct rpmsg_ns_msg nsm;\r\nstrncpy(nsm.name, rpdev->id.name, RPMSG_NAME_SIZE);\r\nnsm.addr = rpdev->src;\r\nnsm.flags = RPMSG_NS_CREATE;\r\nerr = rpmsg_sendto(rpdev, &nsm, sizeof(nsm), RPMSG_NS_ADDR);\r\nif (err)\r\ndev_err(dev, "failed to announce service %d\n", err);\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int rpmsg_dev_remove(struct device *dev)\r\n{\r\nstruct rpmsg_channel *rpdev = to_rpmsg_channel(dev);\r\nstruct rpmsg_driver *rpdrv = to_rpmsg_driver(rpdev->dev.driver);\r\nstruct virtproc_info *vrp = rpdev->vrp;\r\nint err = 0;\r\nif (rpdev->announce &&\r\nvirtio_has_feature(vrp->vdev, VIRTIO_RPMSG_F_NS)) {\r\nstruct rpmsg_ns_msg nsm;\r\nstrncpy(nsm.name, rpdev->id.name, RPMSG_NAME_SIZE);\r\nnsm.addr = rpdev->src;\r\nnsm.flags = RPMSG_NS_DESTROY;\r\nerr = rpmsg_sendto(rpdev, &nsm, sizeof(nsm), RPMSG_NS_ADDR);\r\nif (err)\r\ndev_err(dev, "failed to announce service %d\n", err);\r\n}\r\nrpdrv->remove(rpdev);\r\nrpmsg_destroy_ept(rpdev->ept);\r\nreturn err;\r\n}\r\nint register_rpmsg_driver(struct rpmsg_driver *rpdrv)\r\n{\r\nrpdrv->drv.bus = &rpmsg_bus;\r\nreturn driver_register(&rpdrv->drv);\r\n}\r\nvoid unregister_rpmsg_driver(struct rpmsg_driver *rpdrv)\r\n{\r\ndriver_unregister(&rpdrv->drv);\r\n}\r\nstatic void rpmsg_release_device(struct device *dev)\r\n{\r\nstruct rpmsg_channel *rpdev = to_rpmsg_channel(dev);\r\nkfree(rpdev);\r\n}\r\nstatic int rpmsg_channel_match(struct device *dev, void *data)\r\n{\r\nstruct rpmsg_channel_info *chinfo = data;\r\nstruct rpmsg_channel *rpdev = to_rpmsg_channel(dev);\r\nif (chinfo->src != RPMSG_ADDR_ANY && chinfo->src != rpdev->src)\r\nreturn 0;\r\nif (chinfo->dst != RPMSG_ADDR_ANY && chinfo->dst != rpdev->dst)\r\nreturn 0;\r\nif (strncmp(chinfo->name, rpdev->id.name, RPMSG_NAME_SIZE))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic struct rpmsg_channel *rpmsg_create_channel(struct virtproc_info *vrp,\r\nstruct rpmsg_channel_info *chinfo)\r\n{\r\nstruct rpmsg_channel *rpdev;\r\nstruct device *tmp, *dev = &vrp->vdev->dev;\r\nint ret;\r\ntmp = device_find_child(dev, chinfo, rpmsg_channel_match);\r\nif (tmp) {\r\nput_device(tmp);\r\ndev_err(dev, "channel %s:%x:%x already exist\n",\r\nchinfo->name, chinfo->src, chinfo->dst);\r\nreturn NULL;\r\n}\r\nrpdev = kzalloc(sizeof(struct rpmsg_channel), GFP_KERNEL);\r\nif (!rpdev) {\r\npr_err("kzalloc failed\n");\r\nreturn NULL;\r\n}\r\nrpdev->vrp = vrp;\r\nrpdev->src = chinfo->src;\r\nrpdev->dst = chinfo->dst;\r\nrpdev->announce = rpdev->src != RPMSG_ADDR_ANY ? true : false;\r\nstrncpy(rpdev->id.name, chinfo->name, RPMSG_NAME_SIZE);\r\ndev_set_name(&rpdev->dev, "rpmsg%d", rpmsg_dev_index++);\r\nrpdev->dev.parent = &vrp->vdev->dev;\r\nrpdev->dev.bus = &rpmsg_bus;\r\nrpdev->dev.release = rpmsg_release_device;\r\nret = device_register(&rpdev->dev);\r\nif (ret) {\r\ndev_err(dev, "device_register failed: %d\n", ret);\r\nput_device(&rpdev->dev);\r\nreturn NULL;\r\n}\r\nreturn rpdev;\r\n}\r\nstatic int rpmsg_destroy_channel(struct virtproc_info *vrp,\r\nstruct rpmsg_channel_info *chinfo)\r\n{\r\nstruct virtio_device *vdev = vrp->vdev;\r\nstruct device *dev;\r\ndev = device_find_child(&vdev->dev, chinfo, rpmsg_channel_match);\r\nif (!dev)\r\nreturn -EINVAL;\r\ndevice_unregister(dev);\r\nput_device(dev);\r\nreturn 0;\r\n}\r\nstatic void *get_a_tx_buf(struct virtproc_info *vrp)\r\n{\r\nunsigned int len;\r\nvoid *ret;\r\nmutex_lock(&vrp->tx_lock);\r\nif (vrp->last_sbuf < RPMSG_NUM_BUFS / 2)\r\nret = vrp->sbufs + RPMSG_BUF_SIZE * vrp->last_sbuf++;\r\nelse\r\nret = virtqueue_get_buf(vrp->svq, &len);\r\nmutex_unlock(&vrp->tx_lock);\r\nreturn ret;\r\n}\r\nstatic void rpmsg_upref_sleepers(struct virtproc_info *vrp)\r\n{\r\nmutex_lock(&vrp->tx_lock);\r\nif (atomic_inc_return(&vrp->sleepers) == 1)\r\nvirtqueue_enable_cb(vrp->svq);\r\nmutex_unlock(&vrp->tx_lock);\r\n}\r\nstatic void rpmsg_downref_sleepers(struct virtproc_info *vrp)\r\n{\r\nmutex_lock(&vrp->tx_lock);\r\nif (atomic_dec_and_test(&vrp->sleepers))\r\nvirtqueue_disable_cb(vrp->svq);\r\nmutex_unlock(&vrp->tx_lock);\r\n}\r\nint rpmsg_send_offchannel_raw(struct rpmsg_channel *rpdev, u32 src, u32 dst,\r\nvoid *data, int len, bool wait)\r\n{\r\nstruct virtproc_info *vrp = rpdev->vrp;\r\nstruct device *dev = &rpdev->dev;\r\nstruct scatterlist sg;\r\nstruct rpmsg_hdr *msg;\r\nint err;\r\nif (src == RPMSG_ADDR_ANY || dst == RPMSG_ADDR_ANY) {\r\ndev_err(dev, "invalid addr (src 0x%x, dst 0x%x)\n", src, dst);\r\nreturn -EINVAL;\r\n}\r\nif (len > RPMSG_BUF_SIZE - sizeof(struct rpmsg_hdr)) {\r\ndev_err(dev, "message is too big (%d)\n", len);\r\nreturn -EMSGSIZE;\r\n}\r\nmsg = get_a_tx_buf(vrp);\r\nif (!msg && !wait)\r\nreturn -ENOMEM;\r\nwhile (!msg) {\r\nrpmsg_upref_sleepers(vrp);\r\nerr = wait_event_interruptible_timeout(vrp->sendq,\r\n(msg = get_a_tx_buf(vrp)),\r\nmsecs_to_jiffies(15000));\r\nrpmsg_downref_sleepers(vrp);\r\nif (!err) {\r\ndev_err(dev, "timeout waiting for a tx buffer\n");\r\nreturn -ERESTARTSYS;\r\n}\r\n}\r\nmsg->len = len;\r\nmsg->flags = 0;\r\nmsg->src = src;\r\nmsg->dst = dst;\r\nmsg->reserved = 0;\r\nmemcpy(msg->data, data, len);\r\ndev_dbg(dev, "TX From 0x%x, To 0x%x, Len %d, Flags %d, Reserved %d\n",\r\nmsg->src, msg->dst, msg->len,\r\nmsg->flags, msg->reserved);\r\nprint_hex_dump(KERN_DEBUG, "rpmsg_virtio TX: ", DUMP_PREFIX_NONE, 16, 1,\r\nmsg, sizeof(*msg) + msg->len, true);\r\nsg_init_one(&sg, msg, sizeof(*msg) + len);\r\nmutex_lock(&vrp->tx_lock);\r\nerr = virtqueue_add_buf(vrp->svq, &sg, 1, 0, msg, GFP_KERNEL);\r\nif (err < 0) {\r\ndev_err(dev, "virtqueue_add_buf failed: %d\n", err);\r\ngoto out;\r\n}\r\nvirtqueue_kick(vrp->svq);\r\nerr = 0;\r\nout:\r\nmutex_unlock(&vrp->tx_lock);\r\nreturn err;\r\n}\r\nstatic void rpmsg_recv_done(struct virtqueue *rvq)\r\n{\r\nstruct rpmsg_hdr *msg;\r\nunsigned int len;\r\nstruct rpmsg_endpoint *ept;\r\nstruct scatterlist sg;\r\nstruct virtproc_info *vrp = rvq->vdev->priv;\r\nstruct device *dev = &rvq->vdev->dev;\r\nint err;\r\nmsg = virtqueue_get_buf(rvq, &len);\r\nif (!msg) {\r\ndev_err(dev, "uhm, incoming signal, but no used buffer ?\n");\r\nreturn;\r\n}\r\ndev_dbg(dev, "From: 0x%x, To: 0x%x, Len: %d, Flags: %d, Reserved: %d\n",\r\nmsg->src, msg->dst, msg->len,\r\nmsg->flags, msg->reserved);\r\nprint_hex_dump(KERN_DEBUG, "rpmsg_virtio RX: ", DUMP_PREFIX_NONE, 16, 1,\r\nmsg, sizeof(*msg) + msg->len, true);\r\nif (len > RPMSG_BUF_SIZE ||\r\nmsg->len > (len - sizeof(struct rpmsg_hdr))) {\r\ndev_warn(dev, "inbound msg too big: (%d, %d)\n", len, msg->len);\r\nreturn;\r\n}\r\nmutex_lock(&vrp->endpoints_lock);\r\nept = idr_find(&vrp->endpoints, msg->dst);\r\nif (ept)\r\nkref_get(&ept->refcount);\r\nmutex_unlock(&vrp->endpoints_lock);\r\nif (ept) {\r\nmutex_lock(&ept->cb_lock);\r\nif (ept->cb)\r\nept->cb(ept->rpdev, msg->data, msg->len, ept->priv,\r\nmsg->src);\r\nmutex_unlock(&ept->cb_lock);\r\nkref_put(&ept->refcount, __ept_release);\r\n} else\r\ndev_warn(dev, "msg received with no recepient\n");\r\nsg_init_one(&sg, msg, RPMSG_BUF_SIZE);\r\nerr = virtqueue_add_buf(vrp->rvq, &sg, 0, 1, msg, GFP_KERNEL);\r\nif (err < 0) {\r\ndev_err(dev, "failed to add a virtqueue buffer: %d\n", err);\r\nreturn;\r\n}\r\nvirtqueue_kick(vrp->rvq);\r\n}\r\nstatic void rpmsg_xmit_done(struct virtqueue *svq)\r\n{\r\nstruct virtproc_info *vrp = svq->vdev->priv;\r\ndev_dbg(&svq->vdev->dev, "%s\n", __func__);\r\nwake_up_interruptible(&vrp->sendq);\r\n}\r\nstatic void rpmsg_ns_cb(struct rpmsg_channel *rpdev, void *data, int len,\r\nvoid *priv, u32 src)\r\n{\r\nstruct rpmsg_ns_msg *msg = data;\r\nstruct rpmsg_channel *newch;\r\nstruct rpmsg_channel_info chinfo;\r\nstruct virtproc_info *vrp = priv;\r\nstruct device *dev = &vrp->vdev->dev;\r\nint ret;\r\nprint_hex_dump(KERN_DEBUG, "NS announcement: ",\r\nDUMP_PREFIX_NONE, 16, 1,\r\ndata, len, true);\r\nif (len != sizeof(*msg)) {\r\ndev_err(dev, "malformed ns msg (%d)\n", len);\r\nreturn;\r\n}\r\nif (rpdev) {\r\ndev_err(dev, "anomaly: ns ept has an rpdev handle\n");\r\nreturn;\r\n}\r\nmsg->name[RPMSG_NAME_SIZE - 1] = '\0';\r\ndev_info(dev, "%sing channel %s addr 0x%x\n",\r\nmsg->flags & RPMSG_NS_DESTROY ? "destroy" : "creat",\r\nmsg->name, msg->addr);\r\nstrncpy(chinfo.name, msg->name, sizeof(chinfo.name));\r\nchinfo.src = RPMSG_ADDR_ANY;\r\nchinfo.dst = msg->addr;\r\nif (msg->flags & RPMSG_NS_DESTROY) {\r\nret = rpmsg_destroy_channel(vrp, &chinfo);\r\nif (ret)\r\ndev_err(dev, "rpmsg_destroy_channel failed: %d\n", ret);\r\n} else {\r\nnewch = rpmsg_create_channel(vrp, &chinfo);\r\nif (!newch)\r\ndev_err(dev, "rpmsg_create_channel failed\n");\r\n}\r\n}\r\nstatic int rpmsg_probe(struct virtio_device *vdev)\r\n{\r\nvq_callback_t *vq_cbs[] = { rpmsg_recv_done, rpmsg_xmit_done };\r\nconst char *names[] = { "input", "output" };\r\nstruct virtqueue *vqs[2];\r\nstruct virtproc_info *vrp;\r\nvoid *bufs_va;\r\nint err = 0, i;\r\nvrp = kzalloc(sizeof(*vrp), GFP_KERNEL);\r\nif (!vrp)\r\nreturn -ENOMEM;\r\nvrp->vdev = vdev;\r\nidr_init(&vrp->endpoints);\r\nmutex_init(&vrp->endpoints_lock);\r\nmutex_init(&vrp->tx_lock);\r\ninit_waitqueue_head(&vrp->sendq);\r\nerr = vdev->config->find_vqs(vdev, 2, vqs, vq_cbs, names);\r\nif (err)\r\ngoto free_vrp;\r\nvrp->rvq = vqs[0];\r\nvrp->svq = vqs[1];\r\nbufs_va = dma_alloc_coherent(vdev->dev.parent->parent,\r\nRPMSG_TOTAL_BUF_SPACE,\r\n&vrp->bufs_dma, GFP_KERNEL);\r\nif (!bufs_va)\r\ngoto vqs_del;\r\ndev_dbg(&vdev->dev, "buffers: va %p, dma 0x%llx\n", bufs_va,\r\n(unsigned long long)vrp->bufs_dma);\r\nvrp->rbufs = bufs_va;\r\nvrp->sbufs = bufs_va + RPMSG_TOTAL_BUF_SPACE / 2;\r\nfor (i = 0; i < RPMSG_NUM_BUFS / 2; i++) {\r\nstruct scatterlist sg;\r\nvoid *cpu_addr = vrp->rbufs + i * RPMSG_BUF_SIZE;\r\nsg_init_one(&sg, cpu_addr, RPMSG_BUF_SIZE);\r\nerr = virtqueue_add_buf(vrp->rvq, &sg, 0, 1, cpu_addr,\r\nGFP_KERNEL);\r\nWARN_ON(err < 0);\r\n}\r\nvirtqueue_disable_cb(vrp->svq);\r\nvdev->priv = vrp;\r\nif (virtio_has_feature(vdev, VIRTIO_RPMSG_F_NS)) {\r\nvrp->ns_ept = __rpmsg_create_ept(vrp, NULL, rpmsg_ns_cb,\r\nvrp, RPMSG_NS_ADDR);\r\nif (!vrp->ns_ept) {\r\ndev_err(&vdev->dev, "failed to create the ns ept\n");\r\nerr = -ENOMEM;\r\ngoto free_coherent;\r\n}\r\n}\r\nvirtqueue_kick(vrp->rvq);\r\ndev_info(&vdev->dev, "rpmsg host is online\n");\r\nreturn 0;\r\nfree_coherent:\r\ndma_free_coherent(vdev->dev.parent->parent, RPMSG_TOTAL_BUF_SPACE,\r\nbufs_va, vrp->bufs_dma);\r\nvqs_del:\r\nvdev->config->del_vqs(vrp->vdev);\r\nfree_vrp:\r\nkfree(vrp);\r\nreturn err;\r\n}\r\nstatic int rpmsg_remove_device(struct device *dev, void *data)\r\n{\r\ndevice_unregister(dev);\r\nreturn 0;\r\n}\r\nstatic void __devexit rpmsg_remove(struct virtio_device *vdev)\r\n{\r\nstruct virtproc_info *vrp = vdev->priv;\r\nint ret;\r\nvdev->config->reset(vdev);\r\nret = device_for_each_child(&vdev->dev, NULL, rpmsg_remove_device);\r\nif (ret)\r\ndev_warn(&vdev->dev, "can't remove rpmsg device: %d\n", ret);\r\nif (vrp->ns_ept)\r\n__rpmsg_destroy_ept(vrp, vrp->ns_ept);\r\nidr_remove_all(&vrp->endpoints);\r\nidr_destroy(&vrp->endpoints);\r\nvdev->config->del_vqs(vrp->vdev);\r\ndma_free_coherent(vdev->dev.parent->parent, RPMSG_TOTAL_BUF_SPACE,\r\nvrp->rbufs, vrp->bufs_dma);\r\nkfree(vrp);\r\n}\r\nstatic int __init rpmsg_init(void)\r\n{\r\nint ret;\r\nret = bus_register(&rpmsg_bus);\r\nif (ret) {\r\npr_err("failed to register rpmsg bus: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = register_virtio_driver(&virtio_ipc_driver);\r\nif (ret) {\r\npr_err("failed to register virtio driver: %d\n", ret);\r\nbus_unregister(&rpmsg_bus);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit rpmsg_fini(void)\r\n{\r\nunregister_virtio_driver(&virtio_ipc_driver);\r\nbus_unregister(&rpmsg_bus);\r\n}
