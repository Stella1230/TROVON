static int i2c_readn(struct i2c_adapter *adapter, u8 adr, u8 *data, int len)\r\n{\r\nstruct i2c_msg msgs[1] = {{.addr = adr, .flags = I2C_M_RD,\r\n.buf = data, .len = len} };\r\nreturn (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;\r\n}\r\nstatic int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)\r\n{\r\nstruct i2c_msg msg = {.addr = adr, .flags = 0,\r\n.buf = data, .len = len};\r\nif (i2c_transfer(adap, &msg, 1) != 1) {\r\nprintk(KERN_ERR "tda18271c2dd: i2c write error at addr %i\n", adr);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int WriteRegs(struct tda_state *state,\r\nu8 SubAddr, u8 *Regs, u16 nRegs)\r\n{\r\nu8 data[nRegs+1];\r\ndata[0] = SubAddr;\r\nmemcpy(data + 1, Regs, nRegs);\r\nreturn i2c_write(state->i2c, state->adr, data, nRegs+1);\r\n}\r\nstatic int WriteReg(struct tda_state *state, u8 SubAddr, u8 Reg)\r\n{\r\nu8 msg[2] = {SubAddr, Reg};\r\nreturn i2c_write(state->i2c, state->adr, msg, 2);\r\n}\r\nstatic int Read(struct tda_state *state, u8 * Regs)\r\n{\r\nreturn i2c_readn(state->i2c, state->adr, Regs, 16);\r\n}\r\nstatic int ReadExtented(struct tda_state *state, u8 * Regs)\r\n{\r\nreturn i2c_readn(state->i2c, state->adr, Regs, NUM_REGS);\r\n}\r\nstatic int UpdateRegs(struct tda_state *state, u8 RegFrom, u8 RegTo)\r\n{\r\nreturn WriteRegs(state, RegFrom,\r\n&state->m_Regs[RegFrom], RegTo-RegFrom+1);\r\n}\r\nstatic int UpdateReg(struct tda_state *state, u8 Reg)\r\n{\r\nreturn WriteReg(state, Reg, state->m_Regs[Reg]);\r\n}\r\nstatic void reset(struct tda_state *state)\r\n{\r\nu32 ulIFLevelAnalog = 0;\r\nu32 ulIFLevelDigital = 2;\r\nu32 ulIFLevelDVBC = 7;\r\nu32 ulIFLevelDVBT = 6;\r\nu32 ulXTOut = 0;\r\nu32 ulStandbyMode = 0x06;\r\nu32 ulSlave = 0;\r\nu32 ulFMInput = 0;\r\nu32 ulSettlingTime = 100;\r\nstate->m_Frequency = 0;\r\nstate->m_SettlingTime = 100;\r\nstate->m_IFLevelAnalog = (ulIFLevelAnalog & 0x07) << 2;\r\nstate->m_IFLevelDigital = (ulIFLevelDigital & 0x07) << 2;\r\nstate->m_IFLevelDVBC = (ulIFLevelDVBC & 0x07) << 2;\r\nstate->m_IFLevelDVBT = (ulIFLevelDVBT & 0x07) << 2;\r\nstate->m_EP4 = 0x20;\r\nif (ulXTOut != 0)\r\nstate->m_EP4 |= 0x40;\r\nstate->m_EP3_Standby = ((ulStandbyMode & 0x07) << 5) | 0x0F;\r\nstate->m_bMaster = (ulSlave == 0);\r\nstate->m_SettlingTime = ulSettlingTime;\r\nstate->m_bFMInput = (ulFMInput == 2);\r\n}\r\nstatic bool SearchMap1(struct SMap Map[],\r\nu32 Frequency, u8 *pParam)\r\n{\r\nint i = 0;\r\nwhile ((Map[i].m_Frequency != 0) && (Frequency > Map[i].m_Frequency))\r\ni += 1;\r\nif (Map[i].m_Frequency == 0)\r\nreturn false;\r\n*pParam = Map[i].m_Param;\r\nreturn true;\r\n}\r\nstatic bool SearchMap2(struct SMapI Map[],\r\nu32 Frequency, s32 *pParam)\r\n{\r\nint i = 0;\r\nwhile ((Map[i].m_Frequency != 0) &&\r\n(Frequency > Map[i].m_Frequency))\r\ni += 1;\r\nif (Map[i].m_Frequency == 0)\r\nreturn false;\r\n*pParam = Map[i].m_Param;\r\nreturn true;\r\n}\r\nstatic bool SearchMap3(struct SMap2 Map[], u32 Frequency,\r\nu8 *pParam1, u8 *pParam2)\r\n{\r\nint i = 0;\r\nwhile ((Map[i].m_Frequency != 0) &&\r\n(Frequency > Map[i].m_Frequency))\r\ni += 1;\r\nif (Map[i].m_Frequency == 0)\r\nreturn false;\r\n*pParam1 = Map[i].m_Param1;\r\n*pParam2 = Map[i].m_Param2;\r\nreturn true;\r\n}\r\nstatic bool SearchMap4(struct SRFBandMap Map[],\r\nu32 Frequency, u8 *pRFBand)\r\n{\r\nint i = 0;\r\nwhile (i < 7 && (Frequency > Map[i].m_RF_max))\r\ni += 1;\r\nif (i == 7)\r\nreturn false;\r\n*pRFBand = i;\r\nreturn true;\r\n}\r\nstatic int ThermometerRead(struct tda_state *state, u8 *pTM_Value)\r\n{\r\nint status = 0;\r\ndo {\r\nu8 Regs[16];\r\nstate->m_Regs[TM] |= 0x10;\r\nstatus = UpdateReg(state, TM);\r\nif (status < 0)\r\nbreak;\r\nstatus = Read(state, Regs);\r\nif (status < 0)\r\nbreak;\r\nif (((Regs[TM] & 0x0F) == 0 && (Regs[TM] & 0x20) == 0x20) ||\r\n((Regs[TM] & 0x0F) == 8 && (Regs[TM] & 0x20) == 0x00)) {\r\nstate->m_Regs[TM] ^= 0x20;\r\nstatus = UpdateReg(state, TM);\r\nif (status < 0)\r\nbreak;\r\nmsleep(10);\r\nstatus = Read(state, Regs);\r\nif (status < 0)\r\nbreak;\r\n}\r\n*pTM_Value = (Regs[TM] & 0x20)\r\n? m_Thermometer_Map_2[Regs[TM] & 0x0F]\r\n: m_Thermometer_Map_1[Regs[TM] & 0x0F] ;\r\nstate->m_Regs[TM] &= ~0x10;\r\nstatus = UpdateReg(state, TM);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EP4] &= ~0x03;\r\nstatus = UpdateReg(state, EP4);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int StandBy(struct tda_state *state)\r\n{\r\nint status = 0;\r\ndo {\r\nstate->m_Regs[EB12] &= ~0x20;\r\nstatus = UpdateReg(state, EB12);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB18] &= ~0x83;\r\nstatus = UpdateReg(state, EB18);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB21] |= 0x03;\r\nstate->m_Regs[EP3] = state->m_EP3_Standby;\r\nstatus = UpdateReg(state, EP3);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB23] &= ~0x06;\r\nstatus = UpdateRegs(state, EB21, EB23);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int CalcMainPLL(struct tda_state *state, u32 freq)\r\n{\r\nu8 PostDiv;\r\nu8 Div;\r\nu64 OscFreq;\r\nu32 MainDiv;\r\nif (!SearchMap3(m_Main_PLL_Map, freq, &PostDiv, &Div))\r\nreturn -EINVAL;\r\nOscFreq = (u64) freq * (u64) Div;\r\nOscFreq *= (u64) 16384;\r\ndo_div(OscFreq, (u64)16000000);\r\nMainDiv = OscFreq;\r\nstate->m_Regs[MPD] = PostDiv & 0x77;\r\nstate->m_Regs[MD1] = ((MainDiv >> 16) & 0x7F);\r\nstate->m_Regs[MD2] = ((MainDiv >> 8) & 0xFF);\r\nstate->m_Regs[MD3] = (MainDiv & 0xFF);\r\nreturn UpdateRegs(state, MPD, MD3);\r\n}\r\nstatic int CalcCalPLL(struct tda_state *state, u32 freq)\r\n{\r\nu8 PostDiv;\r\nu8 Div;\r\nu64 OscFreq;\r\nu32 CalDiv;\r\nif (!SearchMap3(m_Cal_PLL_Map, freq, &PostDiv, &Div))\r\nreturn -EINVAL;\r\nOscFreq = (u64)freq * (u64)Div;\r\nOscFreq *= (u64)16384;\r\ndo_div(OscFreq, (u64)16000000);\r\nCalDiv = OscFreq;\r\nstate->m_Regs[CPD] = PostDiv;\r\nstate->m_Regs[CD1] = ((CalDiv >> 16) & 0xFF);\r\nstate->m_Regs[CD2] = ((CalDiv >> 8) & 0xFF);\r\nstate->m_Regs[CD3] = (CalDiv & 0xFF);\r\nreturn UpdateRegs(state, CPD, CD3);\r\n}\r\nstatic int CalibrateRF(struct tda_state *state,\r\nu8 RFBand, u32 freq, s32 *pCprog)\r\n{\r\nint status = 0;\r\nu8 Regs[NUM_REGS];\r\ndo {\r\nu8 BP_Filter = 0;\r\nu8 GainTaper = 0;\r\nu8 RFC_K = 0;\r\nu8 RFC_M = 0;\r\nstate->m_Regs[EP4] &= ~0x03;\r\nstatus = UpdateReg(state, EP4);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB18] |= 0x03;\r\nstatus = UpdateReg(state, EB18);\r\nif (status < 0)\r\nbreak;\r\nif (state->m_Regs[ID] != 0x83)\r\nstate->m_Regs[EP3] |= 0x40;\r\nif (!(SearchMap1(m_BP_Filter_Map, freq, &BP_Filter) &&\r\nSearchMap1(m_GainTaper_Map, freq, &GainTaper) &&\r\nSearchMap3(m_KM_Map, freq, &RFC_K, &RFC_M)))\r\nreturn -EINVAL;\r\nstate->m_Regs[EP1] = (state->m_Regs[EP1] & ~0x07) | BP_Filter;\r\nstate->m_Regs[EP2] = (RFBand << 5) | GainTaper;\r\nstate->m_Regs[EB13] = (state->m_Regs[EB13] & ~0x7C) | (RFC_K << 4) | (RFC_M << 2);\r\nstatus = UpdateRegs(state, EP1, EP3);\r\nif (status < 0)\r\nbreak;\r\nstatus = UpdateReg(state, EB13);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB4] |= 0x20;\r\nstatus = UpdateReg(state, EB4);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB7] |= 0x20;\r\nstatus = UpdateReg(state, EB7);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB14] = 0;\r\nstatus = UpdateReg(state, EB14);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB20] &= ~0x20;\r\nstatus = UpdateReg(state, EB20);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EP4] |= 0x03;\r\nstatus = UpdateRegs(state, EP4, EP5);\r\nif (status < 0)\r\nbreak;\r\nstatus = CalcCalPLL(state, freq);\r\nif (status < 0)\r\nbreak;\r\nstatus = CalcMainPLL(state, freq + 1000000);\r\nif (status < 0)\r\nbreak;\r\nmsleep(5);\r\nstatus = UpdateReg(state, EP2);\r\nif (status < 0)\r\nbreak;\r\nstatus = UpdateReg(state, EP1);\r\nif (status < 0)\r\nbreak;\r\nstatus = UpdateReg(state, EP2);\r\nif (status < 0)\r\nbreak;\r\nstatus = UpdateReg(state, EP1);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB4] &= ~0x20;\r\nstatus = UpdateReg(state, EB4);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB7] &= ~0x20;\r\nstatus = UpdateReg(state, EB7);\r\nif (status < 0)\r\nbreak;\r\nmsleep(10);\r\nstate->m_Regs[EB20] |= 0x20;\r\nstatus = UpdateReg(state, EB20);\r\nif (status < 0)\r\nbreak;\r\nmsleep(60);\r\nstate->m_Regs[EP4] &= ~0x03;\r\nstate->m_Regs[EP3] &= ~0x40;\r\nstate->m_Regs[EB18] &= ~0x03;\r\nstatus = UpdateReg(state, EB18);\r\nif (status < 0)\r\nbreak;\r\nstatus = UpdateRegs(state, EP3, EP4);\r\nif (status < 0)\r\nbreak;\r\nstatus = UpdateReg(state, EP1);\r\nif (status < 0)\r\nbreak;\r\nstatus = ReadExtented(state, Regs);\r\nif (status < 0)\r\nbreak;\r\n*pCprog = Regs[EB14];\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int RFTrackingFiltersInit(struct tda_state *state,\r\nu8 RFBand)\r\n{\r\nint status = 0;\r\nu32 RF1 = m_RF_Band_Map[RFBand].m_RF1_Default;\r\nu32 RF2 = m_RF_Band_Map[RFBand].m_RF2_Default;\r\nu32 RF3 = m_RF_Band_Map[RFBand].m_RF3_Default;\r\nbool bcal = false;\r\ns32 Cprog_cal1 = 0;\r\ns32 Cprog_table1 = 0;\r\ns32 Cprog_cal2 = 0;\r\ns32 Cprog_table2 = 0;\r\ns32 Cprog_cal3 = 0;\r\ns32 Cprog_table3 = 0;\r\nstate->m_RF_A1[RFBand] = 0;\r\nstate->m_RF_B1[RFBand] = 0;\r\nstate->m_RF_A2[RFBand] = 0;\r\nstate->m_RF_B2[RFBand] = 0;\r\ndo {\r\nstatus = PowerScan(state, RFBand, RF1, &RF1, &bcal);\r\nif (status < 0)\r\nbreak;\r\nif (bcal) {\r\nstatus = CalibrateRF(state, RFBand, RF1, &Cprog_cal1);\r\nif (status < 0)\r\nbreak;\r\n}\r\nSearchMap2(m_RF_Cal_Map, RF1, &Cprog_table1);\r\nif (!bcal)\r\nCprog_cal1 = Cprog_table1;\r\nstate->m_RF_B1[RFBand] = Cprog_cal1 - Cprog_table1;\r\nif (RF2 == 0)\r\nbreak;\r\nstatus = PowerScan(state, RFBand, RF2, &RF2, &bcal);\r\nif (status < 0)\r\nbreak;\r\nif (bcal) {\r\nstatus = CalibrateRF(state, RFBand, RF2, &Cprog_cal2);\r\nif (status < 0)\r\nbreak;\r\n}\r\nSearchMap2(m_RF_Cal_Map, RF2, &Cprog_table2);\r\nif (!bcal)\r\nCprog_cal2 = Cprog_table2;\r\nstate->m_RF_A1[RFBand] =\r\n(Cprog_cal2 - Cprog_table2 - Cprog_cal1 + Cprog_table1) /\r\n((s32)(RF2) - (s32)(RF1));\r\nif (RF3 == 0)\r\nbreak;\r\nstatus = PowerScan(state, RFBand, RF3, &RF3, &bcal);\r\nif (status < 0)\r\nbreak;\r\nif (bcal) {\r\nstatus = CalibrateRF(state, RFBand, RF3, &Cprog_cal3);\r\nif (status < 0)\r\nbreak;\r\n}\r\nSearchMap2(m_RF_Cal_Map, RF3, &Cprog_table3);\r\nif (!bcal)\r\nCprog_cal3 = Cprog_table3;\r\nstate->m_RF_A2[RFBand] = (Cprog_cal3 - Cprog_table3 - Cprog_cal2 + Cprog_table2) / ((s32)(RF3) - (s32)(RF2));\r\nstate->m_RF_B2[RFBand] = Cprog_cal2 - Cprog_table2;\r\n} while (0);\r\nstate->m_RF1[RFBand] = RF1;\r\nstate->m_RF2[RFBand] = RF2;\r\nstate->m_RF3[RFBand] = RF3;\r\n#if 0\r\nprintk(KERN_ERR "tda18271c2dd: %s %d RF1 = %d A1 = %d B1 = %d RF2 = %d A2 = %d B2 = %d RF3 = %d\n", __func__,\r\nRFBand, RF1, state->m_RF_A1[RFBand], state->m_RF_B1[RFBand], RF2,\r\nstate->m_RF_A2[RFBand], state->m_RF_B2[RFBand], RF3);\r\n#endif\r\nreturn status;\r\n}\r\nstatic int PowerScan(struct tda_state *state,\r\nu8 RFBand, u32 RF_in, u32 *pRF_Out, bool *pbcal)\r\n{\r\nint status = 0;\r\ndo {\r\nu8 Gain_Taper = 0;\r\ns32 RFC_Cprog = 0;\r\nu8 CID_Target = 0;\r\nu8 CountLimit = 0;\r\nu32 freq_MainPLL;\r\nu8 Regs[NUM_REGS];\r\nu8 CID_Gain;\r\ns32 Count = 0;\r\nint sign = 1;\r\nbool wait = false;\r\nif (!(SearchMap2(m_RF_Cal_Map, RF_in, &RFC_Cprog) &&\r\nSearchMap1(m_GainTaper_Map, RF_in, &Gain_Taper) &&\r\nSearchMap3(m_CID_Target_Map, RF_in, &CID_Target, &CountLimit))) {\r\nprintk(KERN_ERR "tda18271c2dd: %s Search map failed\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstate->m_Regs[EP2] = (RFBand << 5) | Gain_Taper;\r\nstate->m_Regs[EB14] = (RFC_Cprog);\r\nstatus = UpdateReg(state, EP2);\r\nif (status < 0)\r\nbreak;\r\nstatus = UpdateReg(state, EB14);\r\nif (status < 0)\r\nbreak;\r\nfreq_MainPLL = RF_in + 1000000;\r\nstatus = CalcMainPLL(state, freq_MainPLL);\r\nif (status < 0)\r\nbreak;\r\nmsleep(5);\r\nstate->m_Regs[EP4] = (state->m_Regs[EP4] & ~0x03) | 1;\r\nstatus = UpdateReg(state, EP4);\r\nif (status < 0)\r\nbreak;\r\nstatus = UpdateReg(state, EP2);\r\nif (status < 0)\r\nbreak;\r\nstatus = ReadExtented(state, Regs);\r\nif (status < 0)\r\nbreak;\r\nCID_Gain = Regs[EB10] & 0x3F;\r\nstate->m_Regs[ID] = Regs[ID];\r\n*pRF_Out = RF_in;\r\nwhile (CID_Gain < CID_Target) {\r\nfreq_MainPLL = RF_in + sign * Count + 1000000;\r\nstatus = CalcMainPLL(state, freq_MainPLL);\r\nif (status < 0)\r\nbreak;\r\nmsleep(wait ? 5 : 1);\r\nwait = false;\r\nstatus = UpdateReg(state, EP2);\r\nif (status < 0)\r\nbreak;\r\nstatus = ReadExtented(state, Regs);\r\nif (status < 0)\r\nbreak;\r\nCID_Gain = Regs[EB10] & 0x3F;\r\nCount += 200000;\r\nif (Count < CountLimit * 100000)\r\ncontinue;\r\nif (sign < 0)\r\nbreak;\r\nsign = -sign;\r\nCount = 200000;\r\nwait = true;\r\n}\r\nstatus = status;\r\nif (status < 0)\r\nbreak;\r\nif (CID_Gain >= CID_Target) {\r\n*pbcal = true;\r\n*pRF_Out = freq_MainPLL - 1000000;\r\n} else\r\n*pbcal = false;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int PowerScanInit(struct tda_state *state)\r\n{\r\nint status = 0;\r\ndo {\r\nstate->m_Regs[EP3] = (state->m_Regs[EP3] & ~0x1F) | 0x12;\r\nstate->m_Regs[EP4] = (state->m_Regs[EP4] & ~0x1F);\r\nstatus = UpdateRegs(state, EP3, EP4);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB18] = (state->m_Regs[EB18] & ~0x03);\r\nstatus = UpdateReg(state, EB18);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB21] = (state->m_Regs[EB21] & ~0x03);\r\nstate->m_Regs[EB23] = (state->m_Regs[EB23] | 0x06);\r\nstatus = UpdateRegs(state, EB21, EB23);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int CalcRFFilterCurve(struct tda_state *state)\r\n{\r\nint status = 0;\r\ndo {\r\nmsleep(200);\r\nstatus = PowerScanInit(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = RFTrackingFiltersInit(state, 0);\r\nif (status < 0)\r\nbreak;\r\nstatus = RFTrackingFiltersInit(state, 1);\r\nif (status < 0)\r\nbreak;\r\nstatus = RFTrackingFiltersInit(state, 2);\r\nif (status < 0)\r\nbreak;\r\nstatus = RFTrackingFiltersInit(state, 3);\r\nif (status < 0)\r\nbreak;\r\nstatus = RFTrackingFiltersInit(state, 4);\r\nif (status < 0)\r\nbreak;\r\nstatus = RFTrackingFiltersInit(state, 5);\r\nif (status < 0)\r\nbreak;\r\nstatus = RFTrackingFiltersInit(state, 6);\r\nif (status < 0)\r\nbreak;\r\nstatus = ThermometerRead(state, &state->m_TMValue_RFCal);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int FixedContentsI2CUpdate(struct tda_state *state)\r\n{\r\nstatic u8 InitRegs[] = {\r\n0x08, 0x80, 0xC6,\r\n0xDF, 0x16, 0x60, 0x80,\r\n0x80, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00,\r\n0xFC, 0x01, 0x84, 0x41,\r\n0x01, 0x84, 0x40, 0x07,\r\n0x00, 0x00, 0x96, 0x3F,\r\n0xC1, 0x00, 0x8F, 0x00,\r\n0x00, 0x8C, 0x00, 0x20,\r\n0xB3, 0x48, 0xB0,\r\n};\r\nint status = 0;\r\nmemcpy(&state->m_Regs[TM], InitRegs, EB23 - TM + 1);\r\ndo {\r\nstatus = UpdateRegs(state, TM, EB23);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB17] = 0x00;\r\nstatus = UpdateReg(state, EB17);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB17] = 0x03;\r\nstatus = UpdateReg(state, EB17);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB17] = 0x43;\r\nstatus = UpdateReg(state, EB17);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB17] = 0x4C;\r\nstatus = UpdateReg(state, EB17);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EP3] = 0x1F;\r\nstate->m_Regs[EP4] = 0x66;\r\nstate->m_Regs[EP5] = 0x81;\r\nstate->m_Regs[CPD] = 0xCC;\r\nstate->m_Regs[CD1] = 0x6C;\r\nstate->m_Regs[CD2] = 0x00;\r\nstate->m_Regs[CD3] = 0x00;\r\nstate->m_Regs[MPD] = 0xC5;\r\nstate->m_Regs[MD1] = 0x77;\r\nstate->m_Regs[MD2] = 0x08;\r\nstate->m_Regs[MD3] = 0x00;\r\nstatus = UpdateRegs(state, EP2, MD3);\r\nif (status < 0)\r\nbreak;\r\n#if 0\r\nstate->m_Regs[EB4] = 0x61;\r\nstatus = UpdateReg(state, EB4);\r\nif (status < 0)\r\nbreak;\r\nmsleep(1);\r\nstate->m_Regs[EB4] = 0x41;\r\nstatus = UpdateReg(state, EB4);\r\nif (status < 0)\r\nbreak;\r\n#endif\r\nmsleep(5);\r\nstatus = UpdateReg(state, EP1);\r\nif (status < 0)\r\nbreak;\r\nmsleep(5);\r\nstate->m_Regs[EP5] = 0x85;\r\nstate->m_Regs[CPD] = 0xCB;\r\nstate->m_Regs[CD1] = 0x66;\r\nstate->m_Regs[CD2] = 0x70;\r\nstatus = UpdateRegs(state, EP3, CD3);\r\nif (status < 0)\r\nbreak;\r\nmsleep(5);\r\nstatus = UpdateReg(state, EP2);\r\nif (status < 0)\r\nbreak;\r\nmsleep(30);\r\nstate->m_Regs[EP5] = 0x82;\r\nstate->m_Regs[CPD] = 0xA8;\r\nstate->m_Regs[CD2] = 0x00;\r\nstate->m_Regs[MPD] = 0xA1;\r\nstate->m_Regs[MD1] = 0x73;\r\nstate->m_Regs[MD2] = 0x1A;\r\nstatus = UpdateRegs(state, EP3, MD3);\r\nif (status < 0)\r\nbreak;\r\nmsleep(5);\r\nstatus = UpdateReg(state, EP1);\r\nif (status < 0)\r\nbreak;\r\nmsleep(5);\r\nstate->m_Regs[EP5] = 0x86;\r\nstate->m_Regs[CPD] = 0xA8;\r\nstate->m_Regs[CD1] = 0x66;\r\nstate->m_Regs[CD2] = 0xA0;\r\nstatus = UpdateRegs(state, EP3, CD3);\r\nif (status < 0)\r\nbreak;\r\nmsleep(5);\r\nstatus = UpdateReg(state, EP2);\r\nif (status < 0)\r\nbreak;\r\nmsleep(30);\r\nstate->m_Regs[EP5] = 0x83;\r\nstate->m_Regs[CPD] = 0x98;\r\nstate->m_Regs[CD1] = 0x65;\r\nstate->m_Regs[CD2] = 0x00;\r\nstate->m_Regs[MPD] = 0x91;\r\nstate->m_Regs[MD1] = 0x71;\r\nstate->m_Regs[MD2] = 0xCD;\r\nstatus = UpdateRegs(state, EP3, MD3);\r\nif (status < 0)\r\nbreak;\r\nmsleep(5);\r\nstatus = UpdateReg(state, EP1);\r\nif (status < 0)\r\nbreak;\r\nmsleep(5);\r\nstate->m_Regs[EP5] = 0x87;\r\nstate->m_Regs[CD1] = 0x65;\r\nstate->m_Regs[CD2] = 0x50;\r\nstatus = UpdateRegs(state, EP3, CD3);\r\nif (status < 0)\r\nbreak;\r\nmsleep(5);\r\nstatus = UpdateReg(state, EP2);\r\nif (status < 0)\r\nbreak;\r\nmsleep(30);\r\nstate->m_Regs[EP4] = 0x64;\r\nstatus = UpdateReg(state, EP4);\r\nif (status < 0)\r\nbreak;\r\nstatus = UpdateReg(state, EP1);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int InitCal(struct tda_state *state)\r\n{\r\nint status = 0;\r\ndo {\r\nstatus = FixedContentsI2CUpdate(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = CalcRFFilterCurve(state);\r\nif (status < 0)\r\nbreak;\r\nstatus = StandBy(state);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int RFTrackingFiltersCorrection(struct tda_state *state,\r\nu32 Frequency)\r\n{\r\nint status = 0;\r\ns32 Cprog_table;\r\nu8 RFBand;\r\nu8 dCoverdT;\r\nif (!SearchMap2(m_RF_Cal_Map, Frequency, &Cprog_table) ||\r\n!SearchMap4(m_RF_Band_Map, Frequency, &RFBand) ||\r\n!SearchMap1(m_RF_Cal_DC_Over_DT_Map, Frequency, &dCoverdT))\r\nreturn -EINVAL;\r\ndo {\r\nu8 TMValue_Current;\r\nu32 RF1 = state->m_RF1[RFBand];\r\nu32 RF2 = state->m_RF1[RFBand];\r\nu32 RF3 = state->m_RF1[RFBand];\r\ns32 RF_A1 = state->m_RF_A1[RFBand];\r\ns32 RF_B1 = state->m_RF_B1[RFBand];\r\ns32 RF_A2 = state->m_RF_A2[RFBand];\r\ns32 RF_B2 = state->m_RF_B2[RFBand];\r\ns32 Capprox = 0;\r\nint TComp;\r\nstate->m_Regs[EP3] &= ~0xE0;\r\nstatus = UpdateReg(state, EP3);\r\nif (status < 0)\r\nbreak;\r\nstatus = ThermometerRead(state, &TMValue_Current);\r\nif (status < 0)\r\nbreak;\r\nif (RF3 == 0 || Frequency < RF2)\r\nCapprox = RF_A1 * ((s32)(Frequency) - (s32)(RF1)) + RF_B1 + Cprog_table;\r\nelse\r\nCapprox = RF_A2 * ((s32)(Frequency) - (s32)(RF2)) + RF_B2 + Cprog_table;\r\nTComp = (int)(dCoverdT) * ((int)(TMValue_Current) - (int)(state->m_TMValue_RFCal))/1000;\r\nCapprox += TComp;\r\nif (Capprox < 0)\r\nCapprox = 0;\r\nelse if (Capprox > 255)\r\nCapprox = 255;\r\nstate->m_Regs[EB14] = Capprox;\r\nstatus = UpdateReg(state, EB14);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int ChannelConfiguration(struct tda_state *state,\r\nu32 Frequency, int Standard)\r\n{\r\ns32 IntermediateFrequency = m_StandardTable[Standard].m_IFFrequency;\r\nint status = 0;\r\nu8 BP_Filter = 0;\r\nu8 RF_Band = 0;\r\nu8 GainTaper = 0;\r\nu8 IR_Meas = 0;\r\nstate->IF = IntermediateFrequency;\r\nif (!(SearchMap1(m_BP_Filter_Map, Frequency, &BP_Filter) &&\r\nSearchMap1(m_GainTaper_Map, Frequency, &GainTaper) &&\r\nSearchMap1(m_IR_Meas_Map, Frequency, &IR_Meas) &&\r\nSearchMap4(m_RF_Band_Map, Frequency, &RF_Band))) {\r\nprintk(KERN_ERR "tda18271c2dd: %s SearchMap failed\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndo {\r\nstate->m_Regs[EP3] = (state->m_Regs[EP3] & ~0x1F) | m_StandardTable[Standard].m_EP3_4_0;\r\nstate->m_Regs[EP3] &= ~0x04;\r\nstate->m_Regs[EP4] = state->m_EP4 | ((Standard > HF_AnalogMax) ? state->m_IFLevelDigital : state->m_IFLevelAnalog);\r\nif (Standard <= HF_AnalogMax)\r\nstate->m_Regs[EP4] = state->m_EP4 | state->m_IFLevelAnalog;\r\nelse if (Standard <= HF_ATSC)\r\nstate->m_Regs[EP4] = state->m_EP4 | state->m_IFLevelDVBT;\r\nelse if (Standard <= HF_DVBC)\r\nstate->m_Regs[EP4] = state->m_EP4 | state->m_IFLevelDVBC;\r\nelse\r\nstate->m_Regs[EP4] = state->m_EP4 | state->m_IFLevelDigital;\r\nif ((Standard == HF_FM_Radio) && state->m_bFMInput)\r\nstate->m_Regs[EP4] |= 80;\r\nstate->m_Regs[MPD] &= ~0x80;\r\nif (Standard > HF_AnalogMax)\r\nstate->m_Regs[MPD] |= 0x80;\r\nstate->m_Regs[EB22] = m_StandardTable[Standard].m_EB22;\r\nif (Standard == HF_FM_Radio)\r\nstate->m_Regs[EB23] |= 0x06;\r\nelse\r\nstate->m_Regs[EB23] &= ~0x06;\r\nstatus = UpdateRegs(state, EB22, EB23);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EP1] = (state->m_Regs[EP1] & ~0x07) | 0x40 | BP_Filter;\r\nstate->m_Regs[EP5] = (state->m_Regs[EP5] & ~0x07) | IR_Meas;\r\nstate->m_Regs[EP2] = (RF_Band << 5) | GainTaper;\r\nstate->m_Regs[EB1] = (state->m_Regs[EB1] & ~0x07) |\r\n(state->m_bMaster ? 0x04 : 0x00);\r\nstatus = UpdateReg(state, EB1);\r\nif (status < 0)\r\nbreak;\r\nif (state->m_bMaster) {\r\nstatus = CalcMainPLL(state, Frequency + IntermediateFrequency);\r\nif (status < 0)\r\nbreak;\r\nstatus = UpdateRegs(state, TM, EP5);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB4] |= 0x20;\r\nstatus = UpdateReg(state, EB4);\r\nif (status < 0)\r\nbreak;\r\nmsleep(1);\r\nstate->m_Regs[EB4] &= ~0x20;\r\nstatus = UpdateReg(state, EB4);\r\nif (status < 0)\r\nbreak;\r\n} else {\r\nu8 PostDiv = 0;\r\nu8 Div;\r\nstatus = CalcCalPLL(state, Frequency + IntermediateFrequency);\r\nif (status < 0)\r\nbreak;\r\nSearchMap3(m_Cal_PLL_Map, Frequency + IntermediateFrequency, &PostDiv, &Div);\r\nstate->m_Regs[MPD] = (state->m_Regs[MPD] & ~0x7F) | (PostDiv & 0x77);\r\nstatus = UpdateReg(state, MPD);\r\nif (status < 0)\r\nbreak;\r\nstatus = UpdateRegs(state, TM, EP5);\r\nif (status < 0)\r\nbreak;\r\nstate->m_Regs[EB7] |= 0x20;\r\nstatus = UpdateReg(state, EB7);\r\nif (status < 0)\r\nbreak;\r\nmsleep(1);\r\nstate->m_Regs[EB7] &= ~0x20;\r\nstatus = UpdateReg(state, EB7);\r\nif (status < 0)\r\nbreak;\r\n}\r\nmsleep(20);\r\nif (Standard != HF_FM_Radio)\r\nstate->m_Regs[EP3] |= 0x04;\r\nstatus = UpdateReg(state, EP3);\r\nif (status < 0)\r\nbreak;\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int sleep(struct dvb_frontend *fe)\r\n{\r\nstruct tda_state *state = fe->tuner_priv;\r\nStandBy(state);\r\nreturn 0;\r\n}\r\nstatic int init(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int set_params(struct dvb_frontend *fe)\r\n{\r\nstruct tda_state *state = fe->tuner_priv;\r\nint status = 0;\r\nint Standard;\r\nu32 bw = fe->dtv_property_cache.bandwidth_hz;\r\nu32 delsys = fe->dtv_property_cache.delivery_system;\r\nstate->m_Frequency = fe->dtv_property_cache.frequency;\r\nswitch (delsys) {\r\ncase SYS_DVBT:\r\ncase SYS_DVBT2:\r\nswitch (bw) {\r\ncase 6000000:\r\nStandard = HF_DVBT_6MHZ;\r\nbreak;\r\ncase 7000000:\r\nStandard = HF_DVBT_7MHZ;\r\nbreak;\r\ncase 8000000:\r\nStandard = HF_DVBT_8MHZ;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase SYS_DVBC_ANNEX_A:\r\ncase SYS_DVBC_ANNEX_C:\r\nif (bw <= 6000000)\r\nStandard = HF_DVBC_6MHZ;\r\nelse if (bw <= 7000000)\r\nStandard = HF_DVBC_7MHZ;\r\nelse\r\nStandard = HF_DVBC_8MHZ;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndo {\r\nstatus = RFTrackingFiltersCorrection(state, state->m_Frequency);\r\nif (status < 0)\r\nbreak;\r\nstatus = ChannelConfiguration(state, state->m_Frequency,\r\nStandard);\r\nif (status < 0)\r\nbreak;\r\nmsleep(state->m_SettlingTime);\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic int get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct tda_state *state = fe->tuner_priv;\r\n*frequency = state->IF;\r\nreturn 0;\r\n}\r\nstatic int get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\r\n{\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *tda18271c2dd_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c, u8 adr)\r\n{\r\nstruct tda_state *state;\r\nstate = kzalloc(sizeof(struct tda_state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\nfe->tuner_priv = state;\r\nstate->adr = adr;\r\nstate->i2c = i2c;\r\nmemcpy(&fe->ops.tuner_ops, &tuner_ops, sizeof(struct dvb_tuner_ops));\r\nreset(state);\r\nInitCal(state);\r\nreturn fe;\r\n}
