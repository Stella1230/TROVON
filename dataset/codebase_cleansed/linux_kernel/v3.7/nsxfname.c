acpi_status\r\nacpi_get_handle(acpi_handle parent,\r\nacpi_string pathname, acpi_handle * ret_handle)\r\n{\r\nacpi_status status;\r\nstruct acpi_namespace_node *node = NULL;\r\nstruct acpi_namespace_node *prefix_node = NULL;\r\nACPI_FUNCTION_ENTRY();\r\nif (!ret_handle || !pathname) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nif (parent) {\r\nprefix_node = acpi_ns_validate_handle(parent);\r\nif (!prefix_node) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\n}\r\nif (acpi_ns_valid_root_prefix(pathname[0])) {\r\nif (!ACPI_STRCMP(pathname, ACPI_NS_ROOT_PATH)) {\r\n*ret_handle =\r\nACPI_CAST_PTR(acpi_handle, acpi_gbl_root_node);\r\nreturn (AE_OK);\r\n}\r\n} else if (!prefix_node) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nstatus =\r\nacpi_ns_get_node(prefix_node, pathname, ACPI_NS_NO_UPSEARCH, &node);\r\nif (ACPI_SUCCESS(status)) {\r\n*ret_handle = ACPI_CAST_PTR(acpi_handle, node);\r\n}\r\nreturn (status);\r\n}\r\nacpi_status\r\nacpi_get_name(acpi_handle handle, u32 name_type, struct acpi_buffer * buffer)\r\n{\r\nacpi_status status;\r\nstruct acpi_namespace_node *node;\r\nif (name_type > ACPI_NAME_TYPE_MAX) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_validate_buffer(buffer);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (name_type == ACPI_FULL_PATHNAME) {\r\nstatus = acpi_ns_handle_to_pathname(handle, buffer);\r\nreturn (status);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nnode = acpi_ns_validate_handle(handle);\r\nif (!node) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nstatus = acpi_ut_initialize_buffer(buffer, ACPI_PATH_SEGMENT_LENGTH);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\nACPI_STRNCPY(buffer->pointer, acpi_ut_get_node_name(node),\r\nACPI_NAME_SIZE);\r\n((char *)buffer->pointer)[ACPI_NAME_SIZE] = 0;\r\nstatus = AE_OK;\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn (status);\r\n}\r\nstatic char *acpi_ns_copy_device_id(struct acpica_device_id *dest,\r\nstruct acpica_device_id *source,\r\nchar *string_area)\r\n{\r\ndest->string = string_area;\r\ndest->length = source->length;\r\nACPI_MEMCPY(string_area, source->string, source->length);\r\nreturn (string_area + source->length);\r\n}\r\nacpi_status\r\nacpi_get_object_info(acpi_handle handle,\r\nstruct acpi_device_info **return_buffer)\r\n{\r\nstruct acpi_namespace_node *node;\r\nstruct acpi_device_info *info;\r\nstruct acpica_device_id_list *cid_list = NULL;\r\nstruct acpica_device_id *hid = NULL;\r\nstruct acpica_device_id *uid = NULL;\r\nchar *next_id_string;\r\nacpi_object_type type;\r\nacpi_name name;\r\nu8 param_count = 0;\r\nu8 valid = 0;\r\nu32 info_size;\r\nu32 i;\r\nacpi_status status;\r\nif (!handle || !return_buffer) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\ngoto cleanup;\r\n}\r\nnode = acpi_ns_validate_handle(handle);\r\nif (!node) {\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\ninfo_size = sizeof(struct acpi_device_info);\r\ntype = node->type;\r\nname = node->name.integer;\r\nif (node->type == ACPI_TYPE_METHOD) {\r\nparam_count = node->object->method.param_count;\r\n}\r\nstatus = acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif ((type == ACPI_TYPE_DEVICE) || (type == ACPI_TYPE_PROCESSOR)) {\r\nstatus = acpi_ut_execute_HID(node, &hid);\r\nif (ACPI_SUCCESS(status)) {\r\ninfo_size += hid->length;\r\nvalid |= ACPI_VALID_HID;\r\n}\r\nstatus = acpi_ut_execute_UID(node, &uid);\r\nif (ACPI_SUCCESS(status)) {\r\ninfo_size += uid->length;\r\nvalid |= ACPI_VALID_UID;\r\n}\r\nstatus = acpi_ut_execute_CID(node, &cid_list);\r\nif (ACPI_SUCCESS(status)) {\r\ninfo_size +=\r\n(cid_list->list_size -\r\nsizeof(struct acpica_device_id_list));\r\nvalid |= ACPI_VALID_CID;\r\n}\r\n}\r\ninfo = ACPI_ALLOCATE_ZEROED(info_size);\r\nif (!info) {\r\nstatus = AE_NO_MEMORY;\r\ngoto cleanup;\r\n}\r\nif ((type == ACPI_TYPE_DEVICE) || (type == ACPI_TYPE_PROCESSOR)) {\r\nstatus = acpi_ut_execute_STA(node, &info->current_status);\r\nif (ACPI_SUCCESS(status)) {\r\nvalid |= ACPI_VALID_STA;\r\n}\r\nstatus = acpi_ut_evaluate_numeric_object(METHOD_NAME__ADR, node,\r\n&info->address);\r\nif (ACPI_SUCCESS(status)) {\r\nvalid |= ACPI_VALID_ADR;\r\n}\r\nstatus = acpi_ut_execute_power_methods(node,\r\nacpi_gbl_lowest_dstate_names,\r\nACPI_NUM_sx_w_METHODS,\r\ninfo->lowest_dstates);\r\nif (ACPI_SUCCESS(status)) {\r\nvalid |= ACPI_VALID_SXWS;\r\n}\r\nstatus = acpi_ut_execute_power_methods(node,\r\nacpi_gbl_highest_dstate_names,\r\nACPI_NUM_sx_d_METHODS,\r\ninfo->highest_dstates);\r\nif (ACPI_SUCCESS(status)) {\r\nvalid |= ACPI_VALID_SXDS;\r\n}\r\n}\r\nnext_id_string = ACPI_CAST_PTR(char, info->compatible_id_list.ids);\r\nif (cid_list) {\r\nnext_id_string +=\r\n((acpi_size) cid_list->count *\r\nsizeof(struct acpica_device_id));\r\n}\r\nif (hid) {\r\nnext_id_string = acpi_ns_copy_device_id(&info->hardware_id,\r\nhid, next_id_string);\r\nif (acpi_ut_is_pci_root_bridge(hid->string)) {\r\ninfo->flags |= ACPI_PCI_ROOT_BRIDGE;\r\n}\r\n}\r\nif (uid) {\r\nnext_id_string = acpi_ns_copy_device_id(&info->unique_id,\r\nuid, next_id_string);\r\n}\r\nif (cid_list) {\r\ninfo->compatible_id_list.count = cid_list->count;\r\ninfo->compatible_id_list.list_size = cid_list->list_size;\r\nfor (i = 0; i < cid_list->count; i++) {\r\nnext_id_string =\r\nacpi_ns_copy_device_id(&info->compatible_id_list.\r\nids[i], &cid_list->ids[i],\r\nnext_id_string);\r\nif (acpi_ut_is_pci_root_bridge(cid_list->ids[i].string)) {\r\ninfo->flags |= ACPI_PCI_ROOT_BRIDGE;\r\n}\r\n}\r\n}\r\ninfo->info_size = info_size;\r\ninfo->type = type;\r\ninfo->name = name;\r\ninfo->param_count = param_count;\r\ninfo->valid = valid;\r\n*return_buffer = info;\r\nstatus = AE_OK;\r\ncleanup:\r\nif (hid) {\r\nACPI_FREE(hid);\r\n}\r\nif (uid) {\r\nACPI_FREE(uid);\r\n}\r\nif (cid_list) {\r\nACPI_FREE(cid_list);\r\n}\r\nreturn (status);\r\n}\r\nacpi_status acpi_install_method(u8 *buffer)\r\n{\r\nstruct acpi_table_header *table =\r\nACPI_CAST_PTR(struct acpi_table_header, buffer);\r\nu8 *aml_buffer;\r\nu8 *aml_start;\r\nchar *path;\r\nstruct acpi_namespace_node *node;\r\nunion acpi_operand_object *method_obj;\r\nstruct acpi_parse_state parser_state;\r\nu32 aml_length;\r\nu16 opcode;\r\nu8 method_flags;\r\nacpi_status status;\r\nif (!buffer) {\r\nreturn AE_BAD_PARAMETER;\r\n}\r\nif (!ACPI_COMPARE_NAME(table->signature, ACPI_SIG_DSDT) &&\r\n!ACPI_COMPARE_NAME(table->signature, ACPI_SIG_SSDT)) {\r\nreturn AE_BAD_HEADER;\r\n}\r\nparser_state.aml = buffer + sizeof(struct acpi_table_header);\r\nopcode = acpi_ps_peek_opcode(&parser_state);\r\nif (opcode != AML_METHOD_OP) {\r\nreturn AE_BAD_PARAMETER;\r\n}\r\nparser_state.aml += acpi_ps_get_opcode_size(opcode);\r\nparser_state.pkg_end = acpi_ps_get_next_package_end(&parser_state);\r\npath = acpi_ps_get_next_namestring(&parser_state);\r\nmethod_flags = *parser_state.aml++;\r\naml_start = parser_state.aml;\r\naml_length = ACPI_PTR_DIFF(parser_state.pkg_end, aml_start);\r\naml_buffer = ACPI_ALLOCATE(aml_length);\r\nif (!aml_buffer) {\r\nreturn AE_NO_MEMORY;\r\n}\r\nmethod_obj = acpi_ut_create_internal_object(ACPI_TYPE_METHOD);\r\nif (!method_obj) {\r\nACPI_FREE(aml_buffer);\r\nreturn AE_NO_MEMORY;\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nstatus =\r\nacpi_ns_lookup(NULL, path, ACPI_TYPE_METHOD, ACPI_IMODE_LOAD_PASS1,\r\nACPI_NS_DONT_OPEN_SCOPE | ACPI_NS_ERROR_IF_FOUND,\r\nNULL, &node);\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nif (status != AE_ALREADY_EXISTS) {\r\ngoto error_exit;\r\n}\r\nif (node->type != ACPI_TYPE_METHOD) {\r\nstatus = AE_TYPE;\r\ngoto error_exit;\r\n}\r\n}\r\nACPI_MEMCPY(aml_buffer, aml_start, aml_length);\r\nmethod_obj->method.aml_start = aml_buffer;\r\nmethod_obj->method.aml_length = aml_length;\r\nmethod_obj->method.param_count = (u8)\r\n(method_flags & AML_METHOD_ARG_COUNT);\r\nif (method_flags & AML_METHOD_SERIALIZED) {\r\nmethod_obj->method.info_flags = ACPI_METHOD_SERIALIZED;\r\nmethod_obj->method.sync_level = (u8)\r\n((method_flags & AML_METHOD_SYNC_LEVEL) >> 4);\r\n}\r\nstatus = acpi_ns_attach_object(node, method_obj, ACPI_TYPE_METHOD);\r\nnode->flags |= ANOBJ_ALLOCATED_BUFFER;\r\nacpi_ut_remove_reference(method_obj);\r\nreturn status;\r\nerror_exit:\r\nACPI_FREE(aml_buffer);\r\nACPI_FREE(method_obj);\r\nreturn status;\r\n}
