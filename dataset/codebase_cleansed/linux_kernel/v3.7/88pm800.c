static int __devinit device_gpadc_init(struct pm80x_chip *chip,\r\nstruct pm80x_platform_data *pdata)\r\n{\r\nstruct pm80x_subchip *subchip = chip->subchip;\r\nstruct regmap *map = subchip->regmap_gpadc;\r\nint data = 0, mask = 0, ret = 0;\r\nif (!map) {\r\ndev_warn(chip->dev,\r\n"Warning: gpadc regmap is not available!\n");\r\nreturn -EINVAL;\r\n}\r\nret = regmap_update_bits(map,\r\nPM800_GPADC_MISC_CONFIG2,\r\nPM800_GPADC_MISC_GPFSM_EN,\r\nPM800_GPADC_MISC_GPFSM_EN);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(map, PM800_GPADC_MEAS_EN1,\r\nPM800_MEAS_EN1_VBAT, PM800_MEAS_EN1_VBAT);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(map, PM800_GPADC_MEAS_EN2,\r\n(PM800_MEAS_EN2_RFTMP | PM800_MEAS_GP0_EN),\r\n(PM800_MEAS_EN2_RFTMP | PM800_MEAS_GP0_EN));\r\nif (ret < 0)\r\ngoto out;\r\nmask = (PM800_GPADC_GP_BIAS_EN0 | PM800_GPADC_GP_BIAS_EN1 |\r\nPM800_GPADC_GP_BIAS_EN2 | PM800_GPADC_GP_BIAS_EN3);\r\nif (pdata && (pdata->batt_det == 0))\r\ndata = (PM800_GPADC_GP_BIAS_EN0 | PM800_GPADC_GP_BIAS_EN1 |\r\nPM800_GPADC_GP_BIAS_EN2 | PM800_GPADC_GP_BIAS_EN3);\r\nelse\r\ndata = (PM800_GPADC_GP_BIAS_EN0 | PM800_GPADC_GP_BIAS_EN2 |\r\nPM800_GPADC_GP_BIAS_EN3);\r\nret = regmap_update_bits(map, PM800_GP_BIAS_ENA1, mask, data);\r\nif (ret < 0)\r\ngoto out;\r\ndev_info(chip->dev, "pm800 device_gpadc_init: Done\n");\r\nreturn 0;\r\nout:\r\ndev_info(chip->dev, "pm800 device_gpadc_init: Failed!\n");\r\nreturn ret;\r\n}\r\nstatic int __devinit device_irq_init_800(struct pm80x_chip *chip)\r\n{\r\nstruct regmap *map = chip->regmap;\r\nunsigned long flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;\r\nint data, mask, ret = -EINVAL;\r\nif (!map || !chip->irq) {\r\ndev_err(chip->dev, "incorrect parameters\n");\r\nreturn -EINVAL;\r\n}\r\nmask =\r\nPM800_WAKEUP2_INV_INT | PM800_WAKEUP2_INT_CLEAR |\r\nPM800_WAKEUP2_INT_MASK;\r\ndata = PM800_WAKEUP2_INT_CLEAR;\r\nret = regmap_update_bits(map, PM800_WAKEUP2, mask, data);\r\nif (ret < 0)\r\ngoto out;\r\nret =\r\nregmap_add_irq_chip(chip->regmap, chip->irq, flags, -1,\r\nchip->regmap_irq_chip, &chip->irq_data);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void device_irq_exit_800(struct pm80x_chip *chip)\r\n{\r\nregmap_del_irq_chip(chip->irq, chip->irq_data);\r\n}\r\nstatic int pm800_pages_init(struct pm80x_chip *chip)\r\n{\r\nstruct pm80x_subchip *subchip;\r\nstruct i2c_client *client = chip->client;\r\nsubchip = chip->subchip;\r\nif (subchip->power_page_addr) {\r\nsubchip->power_page =\r\ni2c_new_dummy(client->adapter, subchip->power_page_addr);\r\nsubchip->regmap_power =\r\ndevm_regmap_init_i2c(subchip->power_page,\r\n&pm80x_regmap_config);\r\ni2c_set_clientdata(subchip->power_page, chip);\r\n} else\r\ndev_info(chip->dev,\r\n"PM800 block power 0x31: No power_page_addr\n");\r\nif (subchip->gpadc_page_addr) {\r\nsubchip->gpadc_page = i2c_new_dummy(client->adapter,\r\nsubchip->gpadc_page_addr);\r\nsubchip->regmap_gpadc =\r\ndevm_regmap_init_i2c(subchip->gpadc_page,\r\n&pm80x_regmap_config);\r\ni2c_set_clientdata(subchip->gpadc_page, chip);\r\n} else\r\ndev_info(chip->dev,\r\n"PM800 block GPADC 0x32: No gpadc_page_addr\n");\r\nreturn 0;\r\n}\r\nstatic void pm800_pages_exit(struct pm80x_chip *chip)\r\n{\r\nstruct pm80x_subchip *subchip;\r\nregmap_exit(chip->regmap);\r\ni2c_unregister_device(chip->client);\r\nsubchip = chip->subchip;\r\nif (subchip->power_page) {\r\nregmap_exit(subchip->regmap_power);\r\ni2c_unregister_device(subchip->power_page);\r\n}\r\nif (subchip->gpadc_page) {\r\nregmap_exit(subchip->regmap_gpadc);\r\ni2c_unregister_device(subchip->gpadc_page);\r\n}\r\n}\r\nstatic int __devinit device_800_init(struct pm80x_chip *chip,\r\nstruct pm80x_platform_data *pdata)\r\n{\r\nint ret, pmic_id;\r\nunsigned int val;\r\nret = regmap_read(chip->regmap, PM800_CHIP_ID, &val);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to read CHIP ID: %d\n", ret);\r\ngoto out;\r\n}\r\npmic_id = val & PM80X_VERSION_MASK;\r\nif ((pmic_id >= PM800_CHIP_A0) && (pmic_id <= PM800_CHIP_END)) {\r\nchip->version = val;\r\ndev_info(chip->dev,\r\n"88PM80x:Marvell 88PM800 (ID:0x%x) detected\n", val);\r\n} else {\r\ndev_err(chip->dev,\r\n"Failed to detect Marvell 88PM800:ChipID[0x%x]\n", val);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = regmap_read(chip->regmap, PM800_RTC_CONTROL, &val);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to read RTC register: %d\n", ret);\r\ngoto out;\r\n}\r\nif (val & PM800_ALARM_WAKEUP) {\r\nif (pdata && pdata->rtc)\r\npdata->rtc->rtc_wakeup = 1;\r\n}\r\nret = device_gpadc_init(chip, pdata);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "[%s]Failed to init gpadc\n", __func__);\r\ngoto out;\r\n}\r\nchip->regmap_irq_chip = &pm800_irq_chip;\r\nret = device_irq_init_800(chip);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "[%s]Failed to init pm800 irq\n", __func__);\r\ngoto out;\r\n}\r\nret =\r\nmfd_add_devices(chip->dev, 0, &onkey_devs[0],\r\nARRAY_SIZE(onkey_devs), &onkey_resources[0], 0,\r\nNULL);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to add onkey subdev\n");\r\ngoto out_dev;\r\n} else\r\ndev_info(chip->dev, "[%s]:Added mfd onkey_devs\n", __func__);\r\nif (pdata && pdata->rtc) {\r\nrtc_devs[0].platform_data = pdata->rtc;\r\nrtc_devs[0].pdata_size = sizeof(struct pm80x_rtc_pdata);\r\nret = mfd_add_devices(chip->dev, 0, &rtc_devs[0],\r\nARRAY_SIZE(rtc_devs), NULL, 0, NULL);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to add rtc subdev\n");\r\ngoto out_dev;\r\n} else\r\ndev_info(chip->dev,\r\n"[%s]:Added mfd rtc_devs\n", __func__);\r\n}\r\nreturn 0;\r\nout_dev:\r\nmfd_remove_devices(chip->dev);\r\ndevice_irq_exit_800(chip);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __devinit pm800_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret = 0;\r\nstruct pm80x_chip *chip;\r\nstruct pm80x_platform_data *pdata = client->dev.platform_data;\r\nstruct pm80x_subchip *subchip;\r\nret = pm80x_init(client, id);\r\nif (ret) {\r\ndev_err(&client->dev, "pm800_init fail\n");\r\ngoto out_init;\r\n}\r\nchip = i2c_get_clientdata(client);\r\nsubchip =\r\ndevm_kzalloc(&client->dev, sizeof(struct pm80x_subchip),\r\nGFP_KERNEL);\r\nif (!subchip) {\r\nret = -ENOMEM;\r\ngoto err_subchip_alloc;\r\n}\r\nsubchip->power_page_addr = pdata->power_page_addr;\r\nsubchip->gpadc_page_addr = pdata->gpadc_page_addr;\r\nchip->subchip = subchip;\r\nret = device_800_init(chip, pdata);\r\nif (ret) {\r\ndev_err(chip->dev, "%s id 0x%x failed!\n", __func__, chip->id);\r\ngoto err_800_init;\r\n}\r\nret = pm800_pages_init(chip);\r\nif (ret) {\r\ndev_err(&client->dev, "pm800_pages_init failed!\n");\r\ngoto err_page_init;\r\n}\r\nif (pdata->plat_config)\r\npdata->plat_config(chip, pdata);\r\nerr_page_init:\r\nmfd_remove_devices(chip->dev);\r\ndevice_irq_exit_800(chip);\r\nerr_800_init:\r\ndevm_kfree(&client->dev, subchip);\r\nerr_subchip_alloc:\r\npm80x_deinit(client);\r\nout_init:\r\nreturn ret;\r\n}\r\nstatic int __devexit pm800_remove(struct i2c_client *client)\r\n{\r\nstruct pm80x_chip *chip = i2c_get_clientdata(client);\r\nmfd_remove_devices(chip->dev);\r\ndevice_irq_exit_800(chip);\r\npm800_pages_exit(chip);\r\ndevm_kfree(&client->dev, chip->subchip);\r\npm80x_deinit(client);\r\nreturn 0;\r\n}\r\nstatic int __init pm800_i2c_init(void)\r\n{\r\nreturn i2c_add_driver(&pm800_driver);\r\n}\r\nstatic void __exit pm800_i2c_exit(void)\r\n{\r\ni2c_del_driver(&pm800_driver);\r\n}
