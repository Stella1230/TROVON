static int SearchVcid(struct bcm_mini_adapter *Adapter,unsigned short usVcid)\r\n{\r\nint iIndex=0;\r\nfor(iIndex=(NO_OF_QUEUES-1);iIndex>=0;iIndex--)\r\nif(Adapter->PackInfo[iIndex].usVCID_Value == usVcid)\r\nreturn iIndex;\r\nreturn NO_OF_QUEUES+1;\r\n}\r\nstatic PUSB_RCB\r\nGetBulkInRcb(PS_INTERFACE_ADAPTER psIntfAdapter)\r\n{\r\nPUSB_RCB pRcb = NULL;\r\nUINT index = 0;\r\nif((atomic_read(&psIntfAdapter->uNumRcbUsed) < MAXIMUM_USB_RCB) &&\r\n(psIntfAdapter->psAdapter->StopAllXaction == FALSE))\r\n{\r\nindex = atomic_read(&psIntfAdapter->uCurrRcb);\r\npRcb = &psIntfAdapter->asUsbRcb[index];\r\npRcb->bUsed = TRUE;\r\npRcb->psIntfAdapter= psIntfAdapter;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL, "Got Rx desc %d used %d",\r\nindex, atomic_read(&psIntfAdapter->uNumRcbUsed));\r\nindex = (index + 1) % MAXIMUM_USB_RCB;\r\natomic_set(&psIntfAdapter->uCurrRcb, index);\r\natomic_inc(&psIntfAdapter->uNumRcbUsed);\r\n}\r\nreturn pRcb;\r\n}\r\nstatic void read_bulk_callback(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nBOOLEAN bHeaderSupressionEnabled = FALSE;\r\nint QueueIndex = NO_OF_QUEUES + 1;\r\nUINT uiIndex=0;\r\nint process_done = 1;\r\nPUSB_RCB pRcb = (PUSB_RCB)urb->context;\r\nPS_INTERFACE_ADAPTER psIntfAdapter = pRcb->psIntfAdapter;\r\nstruct bcm_mini_adapter *Adapter = psIntfAdapter->psAdapter;\r\nstruct bcm_leader *pLeader = urb->transfer_buffer;\r\nif (unlikely(netif_msg_rx_status(Adapter)))\r\npr_info(PFX "%s: rx urb status %d length %d\n",\r\nAdapter->dev->name, urb->status, urb->actual_length);\r\nif((Adapter->device_removed == TRUE) ||\r\n(TRUE == Adapter->bEndPointHalted) ||\r\n(0 == urb->actual_length)\r\n)\r\n{\r\npRcb->bUsed = FALSE;\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nreturn;\r\n}\r\nif(urb->status != STATUS_SUCCESS)\r\n{\r\nif(urb->status == -EPIPE)\r\n{\r\nAdapter->bEndPointHalted = TRUE ;\r\nwake_up(&Adapter->tx_packet_wait_queue);\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL,"Rx URB has got cancelled. status :%d", urb->status);\r\n}\r\npRcb->bUsed = FALSE;\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nurb->status = STATUS_SUCCESS ;\r\nreturn ;\r\n}\r\nif(Adapter->bDoSuspend && (Adapter->bPreparingForLowPowerMode))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL,"device is going in low power mode while PMU option selected..hence rx packet should not be process");\r\nreturn ;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL, "Read back done len %d\n", pLeader->PLength);\r\nif(!pLeader->PLength)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL, "Leader Length 0");\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nreturn;\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL, "Leader Status:0x%hX, Length:0x%hX, VCID:0x%hX", pLeader->Status,pLeader->PLength,pLeader->Vcid);\r\nif(MAX_CNTL_PKT_SIZE < pLeader->PLength)\r\n{\r\nif (netif_msg_rx_err(Adapter))\r\npr_info(PFX "%s: corrupted leader length...%d\n",\r\nAdapter->dev->name, pLeader->PLength);\r\n++Adapter->dev->stats.rx_dropped;\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nreturn;\r\n}\r\nQueueIndex = SearchVcid( Adapter,pLeader->Vcid);\r\nif(QueueIndex < NO_OF_QUEUES)\r\n{\r\nbHeaderSupressionEnabled =\r\nAdapter->PackInfo[QueueIndex].bHeaderSuppressionEnabled;\r\nbHeaderSupressionEnabled =\r\nbHeaderSupressionEnabled & Adapter->bPHSEnabled;\r\n}\r\nskb = dev_alloc_skb (pLeader->PLength + SKB_RESERVE_PHS_BYTES + SKB_RESERVE_ETHERNET_HEADER);\r\nif(!skb)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "NO SKBUFF!!! Dropping the Packet");\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nreturn;\r\n}\r\nif((ntohs(pLeader->Vcid) == VCID_CONTROL_PACKET) ||\r\n(!(pLeader->Status >= 0x20 && pLeader->Status <= 0x3F)))\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_RX, RX_CTRL, DBG_LVL_ALL, "Received control pkt...");\r\n*(PUSHORT)skb->data = pLeader->Status;\r\nmemcpy(skb->data+sizeof(USHORT), urb->transfer_buffer +\r\n(sizeof(struct bcm_leader)), pLeader->PLength);\r\nskb->len = pLeader->PLength + sizeof(USHORT);\r\nspin_lock(&Adapter->control_queue_lock);\r\nENQUEUEPACKET(Adapter->RxControlHead,Adapter->RxControlTail,skb);\r\nspin_unlock(&Adapter->control_queue_lock);\r\natomic_inc(&Adapter->cntrlpktCnt);\r\nwake_up(&Adapter->process_rx_cntrlpkt);\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_RX, RX_DATA, DBG_LVL_ALL, "Received Data pkt...");\r\nskb_reserve(skb, 2 + SKB_RESERVE_PHS_BYTES);\r\nmemcpy(skb->data+ETH_HLEN, (PUCHAR)urb->transfer_buffer + sizeof(struct bcm_leader), pLeader->PLength);\r\nskb->dev = Adapter->dev;\r\nskb_put (skb, pLeader->PLength + ETH_HLEN);\r\nAdapter->PackInfo[QueueIndex].uiTotalRxBytes+=pLeader->PLength;\r\nAdapter->PackInfo[QueueIndex].uiThisPeriodRxBytes+= pLeader->PLength;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_RX, RX_DATA, DBG_LVL_ALL, "Received Data pkt of len :0x%X", pLeader->PLength);\r\nif(netif_running(Adapter->dev))\r\n{\r\nskb_pull(skb, ETH_HLEN);\r\nPHSReceive(Adapter, pLeader->Vcid, skb, &skb->len,\r\nNULL,bHeaderSupressionEnabled);\r\nif(!Adapter->PackInfo[QueueIndex].bEthCSSupport)\r\n{\r\nskb_push(skb, ETH_HLEN);\r\nmemcpy(skb->data, skb->dev->dev_addr, 6);\r\nmemcpy(skb->data+6, skb->dev->dev_addr, 6);\r\n(*(skb->data+11))++;\r\n*(skb->data+12) = 0x08;\r\n*(skb->data+13) = 0x00;\r\npLeader->PLength+=ETH_HLEN;\r\n}\r\nskb->protocol = eth_type_trans(skb, Adapter->dev);\r\nprocess_done = netif_rx(skb);\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_RX, RX_DATA, DBG_LVL_ALL, "i/f not up hance freeing SKB...");\r\ndev_kfree_skb(skb);\r\n}\r\n++Adapter->dev->stats.rx_packets;\r\nAdapter->dev->stats.rx_bytes += pLeader->PLength;\r\nfor(uiIndex = 0 ; uiIndex < MIBS_MAX_HIST_ENTRIES ; uiIndex++)\r\n{\r\nif((pLeader->PLength <= MIBS_PKTSIZEHIST_RANGE*(uiIndex+1))\r\n&& (pLeader->PLength > MIBS_PKTSIZEHIST_RANGE*(uiIndex)))\r\nAdapter->aRxPktSizeHist[uiIndex]++;\r\n}\r\n}\r\nAdapter->PrevNumRecvDescs++;\r\npRcb->bUsed = FALSE;\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\n}\r\nstatic int ReceiveRcb(PS_INTERFACE_ADAPTER psIntfAdapter, PUSB_RCB pRcb)\r\n{\r\nstruct urb *urb = pRcb->urb;\r\nint retval = 0;\r\nusb_fill_bulk_urb(urb, psIntfAdapter->udev, usb_rcvbulkpipe(\r\npsIntfAdapter->udev, psIntfAdapter->sBulkIn.bulk_in_endpointAddr),\r\nurb->transfer_buffer, BCM_USB_MAX_READ_LENGTH, read_bulk_callback,\r\npRcb);\r\nif(FALSE == psIntfAdapter->psAdapter->device_removed &&\r\nFALSE == psIntfAdapter->psAdapter->bEndPointHalted &&\r\nFALSE == psIntfAdapter->bSuspended &&\r\nFALSE == psIntfAdapter->bPreparingForBusSuspend)\r\n{\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL, "failed submitting read urb, error %d", retval);\r\nif(retval == -EPIPE)\r\n{\r\npsIntfAdapter->psAdapter->bEndPointHalted = TRUE ;\r\nwake_up(&psIntfAdapter->psAdapter->tx_packet_wait_queue);\r\n}\r\n}\r\n}\r\nreturn retval;\r\n}\r\nBOOLEAN InterfaceRx (PS_INTERFACE_ADAPTER psIntfAdapter)\r\n{\r\nUSHORT RxDescCount = NUM_RX_DESC - atomic_read(&psIntfAdapter->uNumRcbUsed);\r\nPUSB_RCB pRcb = NULL;\r\nwhile(RxDescCount)\r\n{\r\npRcb = GetBulkInRcb(psIntfAdapter);\r\nif(pRcb == NULL)\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_PRINTK, 0, 0, "Unable to get Rcb pointer");\r\nreturn FALSE;\r\n}\r\nReceiveRcb(psIntfAdapter, pRcb);\r\nRxDescCount--;\r\n}\r\nreturn TRUE;\r\n}
