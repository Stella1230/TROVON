static inline void task_name(struct seq_file *m, struct task_struct *p)\r\n{\r\nint i;\r\nchar *buf, *end;\r\nchar *name;\r\nchar tcomm[sizeof(p->comm)];\r\nget_task_comm(tcomm, p);\r\nseq_puts(m, "Name:\t");\r\nend = m->buf + m->size;\r\nbuf = m->buf + m->count;\r\nname = tcomm;\r\ni = sizeof(tcomm);\r\nwhile (i && (buf < end)) {\r\nunsigned char c = *name;\r\nname++;\r\ni--;\r\n*buf = c;\r\nif (!c)\r\nbreak;\r\nif (c == '\\') {\r\nbuf++;\r\nif (buf < end)\r\n*buf++ = c;\r\ncontinue;\r\n}\r\nif (c == '\n') {\r\n*buf++ = '\\';\r\nif (buf < end)\r\n*buf++ = 'n';\r\ncontinue;\r\n}\r\nbuf++;\r\n}\r\nm->count = buf - m->buf;\r\nseq_putc(m, '\n');\r\n}\r\nstatic inline const char *get_task_state(struct task_struct *tsk)\r\n{\r\nunsigned int state = (tsk->state & TASK_REPORT) | tsk->exit_state;\r\nconst char * const *p = &task_state_array[0];\r\nBUILD_BUG_ON(1 + ilog2(TASK_STATE_MAX) != ARRAY_SIZE(task_state_array));\r\nwhile (state) {\r\np++;\r\nstate >>= 1;\r\n}\r\nreturn *p;\r\n}\r\nstatic inline void task_state(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *p)\r\n{\r\nstruct user_namespace *user_ns = current_user_ns();\r\nstruct group_info *group_info;\r\nint g;\r\nstruct fdtable *fdt = NULL;\r\nconst struct cred *cred;\r\npid_t ppid, tpid;\r\nrcu_read_lock();\r\nppid = pid_alive(p) ?\r\ntask_tgid_nr_ns(rcu_dereference(p->real_parent), ns) : 0;\r\ntpid = 0;\r\nif (pid_alive(p)) {\r\nstruct task_struct *tracer = ptrace_parent(p);\r\nif (tracer)\r\ntpid = task_pid_nr_ns(tracer, ns);\r\n}\r\ncred = get_task_cred(p);\r\nseq_printf(m,\r\n"State:\t%s\n"\r\n"Tgid:\t%d\n"\r\n"Pid:\t%d\n"\r\n"PPid:\t%d\n"\r\n"TracerPid:\t%d\n"\r\n"Uid:\t%d\t%d\t%d\t%d\n"\r\n"Gid:\t%d\t%d\t%d\t%d\n",\r\nget_task_state(p),\r\ntask_tgid_nr_ns(p, ns),\r\npid_nr_ns(pid, ns),\r\nppid, tpid,\r\nfrom_kuid_munged(user_ns, cred->uid),\r\nfrom_kuid_munged(user_ns, cred->euid),\r\nfrom_kuid_munged(user_ns, cred->suid),\r\nfrom_kuid_munged(user_ns, cred->fsuid),\r\nfrom_kgid_munged(user_ns, cred->gid),\r\nfrom_kgid_munged(user_ns, cred->egid),\r\nfrom_kgid_munged(user_ns, cred->sgid),\r\nfrom_kgid_munged(user_ns, cred->fsgid));\r\ntask_lock(p);\r\nif (p->files)\r\nfdt = files_fdtable(p->files);\r\nseq_printf(m,\r\n"FDSize:\t%d\n"\r\n"Groups:\t",\r\nfdt ? fdt->max_fds : 0);\r\nrcu_read_unlock();\r\ngroup_info = cred->group_info;\r\ntask_unlock(p);\r\nfor (g = 0; g < min(group_info->ngroups, NGROUPS_SMALL); g++)\r\nseq_printf(m, "%d ",\r\nfrom_kgid_munged(user_ns, GROUP_AT(group_info, g)));\r\nput_cred(cred);\r\nseq_putc(m, '\n');\r\n}\r\nstatic void render_sigset_t(struct seq_file *m, const char *header,\r\nsigset_t *set)\r\n{\r\nint i;\r\nseq_puts(m, header);\r\ni = _NSIG;\r\ndo {\r\nint x = 0;\r\ni -= 4;\r\nif (sigismember(set, i+1)) x |= 1;\r\nif (sigismember(set, i+2)) x |= 2;\r\nif (sigismember(set, i+3)) x |= 4;\r\nif (sigismember(set, i+4)) x |= 8;\r\nseq_printf(m, "%x", x);\r\n} while (i >= 4);\r\nseq_putc(m, '\n');\r\n}\r\nstatic void collect_sigign_sigcatch(struct task_struct *p, sigset_t *ign,\r\nsigset_t *catch)\r\n{\r\nstruct k_sigaction *k;\r\nint i;\r\nk = p->sighand->action;\r\nfor (i = 1; i <= _NSIG; ++i, ++k) {\r\nif (k->sa.sa_handler == SIG_IGN)\r\nsigaddset(ign, i);\r\nelse if (k->sa.sa_handler != SIG_DFL)\r\nsigaddset(catch, i);\r\n}\r\n}\r\nstatic inline void task_sig(struct seq_file *m, struct task_struct *p)\r\n{\r\nunsigned long flags;\r\nsigset_t pending, shpending, blocked, ignored, caught;\r\nint num_threads = 0;\r\nunsigned long qsize = 0;\r\nunsigned long qlim = 0;\r\nsigemptyset(&pending);\r\nsigemptyset(&shpending);\r\nsigemptyset(&blocked);\r\nsigemptyset(&ignored);\r\nsigemptyset(&caught);\r\nif (lock_task_sighand(p, &flags)) {\r\npending = p->pending.signal;\r\nshpending = p->signal->shared_pending.signal;\r\nblocked = p->blocked;\r\ncollect_sigign_sigcatch(p, &ignored, &caught);\r\nnum_threads = get_nr_threads(p);\r\nrcu_read_lock();\r\nqsize = atomic_read(&__task_cred(p)->user->sigpending);\r\nrcu_read_unlock();\r\nqlim = task_rlimit(p, RLIMIT_SIGPENDING);\r\nunlock_task_sighand(p, &flags);\r\n}\r\nseq_printf(m, "Threads:\t%d\n", num_threads);\r\nseq_printf(m, "SigQ:\t%lu/%lu\n", qsize, qlim);\r\nrender_sigset_t(m, "SigPnd:\t", &pending);\r\nrender_sigset_t(m, "ShdPnd:\t", &shpending);\r\nrender_sigset_t(m, "SigBlk:\t", &blocked);\r\nrender_sigset_t(m, "SigIgn:\t", &ignored);\r\nrender_sigset_t(m, "SigCgt:\t", &caught);\r\n}\r\nstatic void render_cap_t(struct seq_file *m, const char *header,\r\nkernel_cap_t *a)\r\n{\r\nunsigned __capi;\r\nseq_puts(m, header);\r\nCAP_FOR_EACH_U32(__capi) {\r\nseq_printf(m, "%08x",\r\na->cap[(_KERNEL_CAPABILITY_U32S-1) - __capi]);\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic inline void task_cap(struct seq_file *m, struct task_struct *p)\r\n{\r\nconst struct cred *cred;\r\nkernel_cap_t cap_inheritable, cap_permitted, cap_effective, cap_bset;\r\nrcu_read_lock();\r\ncred = __task_cred(p);\r\ncap_inheritable = cred->cap_inheritable;\r\ncap_permitted = cred->cap_permitted;\r\ncap_effective = cred->cap_effective;\r\ncap_bset = cred->cap_bset;\r\nrcu_read_unlock();\r\nrender_cap_t(m, "CapInh:\t", &cap_inheritable);\r\nrender_cap_t(m, "CapPrm:\t", &cap_permitted);\r\nrender_cap_t(m, "CapEff:\t", &cap_effective);\r\nrender_cap_t(m, "CapBnd:\t", &cap_bset);\r\n}\r\nstatic inline void task_context_switch_counts(struct seq_file *m,\r\nstruct task_struct *p)\r\n{\r\nseq_printf(m, "voluntary_ctxt_switches:\t%lu\n"\r\n"nonvoluntary_ctxt_switches:\t%lu\n",\r\np->nvcsw,\r\np->nivcsw);\r\n}\r\nstatic void task_cpus_allowed(struct seq_file *m, struct task_struct *task)\r\n{\r\nseq_puts(m, "Cpus_allowed:\t");\r\nseq_cpumask(m, &task->cpus_allowed);\r\nseq_putc(m, '\n');\r\nseq_puts(m, "Cpus_allowed_list:\t");\r\nseq_cpumask_list(m, &task->cpus_allowed);\r\nseq_putc(m, '\n');\r\n}\r\nint proc_pid_status(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task)\r\n{\r\nstruct mm_struct *mm = get_task_mm(task);\r\ntask_name(m, task);\r\ntask_state(m, ns, pid, task);\r\nif (mm) {\r\ntask_mem(m, mm);\r\nmmput(mm);\r\n}\r\ntask_sig(m, task);\r\ntask_cap(m, task);\r\ntask_cpus_allowed(m, task);\r\ncpuset_task_status_allowed(m, task);\r\ntask_context_switch_counts(m, task);\r\nreturn 0;\r\n}\r\nstatic int do_task_stat(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task, int whole)\r\n{\r\nunsigned long vsize, eip, esp, wchan = ~0UL;\r\nint priority, nice;\r\nint tty_pgrp = -1, tty_nr = 0;\r\nsigset_t sigign, sigcatch;\r\nchar state;\r\npid_t ppid = 0, pgid = -1, sid = -1;\r\nint num_threads = 0;\r\nint permitted;\r\nstruct mm_struct *mm;\r\nunsigned long long start_time;\r\nunsigned long cmin_flt = 0, cmaj_flt = 0;\r\nunsigned long min_flt = 0, maj_flt = 0;\r\ncputime_t cutime, cstime, utime, stime;\r\ncputime_t cgtime, gtime;\r\nunsigned long rsslim = 0;\r\nchar tcomm[sizeof(task->comm)];\r\nunsigned long flags;\r\nstate = *get_task_state(task);\r\nvsize = eip = esp = 0;\r\npermitted = ptrace_may_access(task, PTRACE_MODE_READ | PTRACE_MODE_NOAUDIT);\r\nmm = get_task_mm(task);\r\nif (mm) {\r\nvsize = task_vsize(mm);\r\nif (permitted) {\r\neip = KSTK_EIP(task);\r\nesp = KSTK_ESP(task);\r\n}\r\n}\r\nget_task_comm(tcomm, task);\r\nsigemptyset(&sigign);\r\nsigemptyset(&sigcatch);\r\ncutime = cstime = utime = stime = 0;\r\ncgtime = gtime = 0;\r\nif (lock_task_sighand(task, &flags)) {\r\nstruct signal_struct *sig = task->signal;\r\nif (sig->tty) {\r\nstruct pid *pgrp = tty_get_pgrp(sig->tty);\r\ntty_pgrp = pid_nr_ns(pgrp, ns);\r\nput_pid(pgrp);\r\ntty_nr = new_encode_dev(tty_devnum(sig->tty));\r\n}\r\nnum_threads = get_nr_threads(task);\r\ncollect_sigign_sigcatch(task, &sigign, &sigcatch);\r\ncmin_flt = sig->cmin_flt;\r\ncmaj_flt = sig->cmaj_flt;\r\ncutime = sig->cutime;\r\ncstime = sig->cstime;\r\ncgtime = sig->cgtime;\r\nrsslim = ACCESS_ONCE(sig->rlim[RLIMIT_RSS].rlim_cur);\r\nif (whole) {\r\nstruct task_struct *t = task;\r\ndo {\r\nmin_flt += t->min_flt;\r\nmaj_flt += t->maj_flt;\r\ngtime += t->gtime;\r\nt = next_thread(t);\r\n} while (t != task);\r\nmin_flt += sig->min_flt;\r\nmaj_flt += sig->maj_flt;\r\nthread_group_times(task, &utime, &stime);\r\ngtime += sig->gtime;\r\n}\r\nsid = task_session_nr_ns(task, ns);\r\nppid = task_tgid_nr_ns(task->real_parent, ns);\r\npgid = task_pgrp_nr_ns(task, ns);\r\nunlock_task_sighand(task, &flags);\r\n}\r\nif (permitted && (!whole || num_threads < 2))\r\nwchan = get_wchan(task);\r\nif (!whole) {\r\nmin_flt = task->min_flt;\r\nmaj_flt = task->maj_flt;\r\ntask_times(task, &utime, &stime);\r\ngtime = task->gtime;\r\n}\r\npriority = task_prio(task);\r\nnice = task_nice(task);\r\nstart_time =\r\n(unsigned long long)task->real_start_time.tv_sec * NSEC_PER_SEC\r\n+ task->real_start_time.tv_nsec;\r\nstart_time = nsec_to_clock_t(start_time);\r\nseq_printf(m, "%d (%s) %c", pid_nr_ns(pid, ns), tcomm, state);\r\nseq_put_decimal_ll(m, ' ', ppid);\r\nseq_put_decimal_ll(m, ' ', pgid);\r\nseq_put_decimal_ll(m, ' ', sid);\r\nseq_put_decimal_ll(m, ' ', tty_nr);\r\nseq_put_decimal_ll(m, ' ', tty_pgrp);\r\nseq_put_decimal_ull(m, ' ', task->flags);\r\nseq_put_decimal_ull(m, ' ', min_flt);\r\nseq_put_decimal_ull(m, ' ', cmin_flt);\r\nseq_put_decimal_ull(m, ' ', maj_flt);\r\nseq_put_decimal_ull(m, ' ', cmaj_flt);\r\nseq_put_decimal_ull(m, ' ', cputime_to_clock_t(utime));\r\nseq_put_decimal_ull(m, ' ', cputime_to_clock_t(stime));\r\nseq_put_decimal_ll(m, ' ', cputime_to_clock_t(cutime));\r\nseq_put_decimal_ll(m, ' ', cputime_to_clock_t(cstime));\r\nseq_put_decimal_ll(m, ' ', priority);\r\nseq_put_decimal_ll(m, ' ', nice);\r\nseq_put_decimal_ll(m, ' ', num_threads);\r\nseq_put_decimal_ull(m, ' ', 0);\r\nseq_put_decimal_ull(m, ' ', start_time);\r\nseq_put_decimal_ull(m, ' ', vsize);\r\nseq_put_decimal_ull(m, ' ', mm ? get_mm_rss(mm) : 0);\r\nseq_put_decimal_ull(m, ' ', rsslim);\r\nseq_put_decimal_ull(m, ' ', mm ? (permitted ? mm->start_code : 1) : 0);\r\nseq_put_decimal_ull(m, ' ', mm ? (permitted ? mm->end_code : 1) : 0);\r\nseq_put_decimal_ull(m, ' ', (permitted && mm) ? mm->start_stack : 0);\r\nseq_put_decimal_ull(m, ' ', esp);\r\nseq_put_decimal_ull(m, ' ', eip);\r\nseq_put_decimal_ull(m, ' ', task->pending.signal.sig[0] & 0x7fffffffUL);\r\nseq_put_decimal_ull(m, ' ', task->blocked.sig[0] & 0x7fffffffUL);\r\nseq_put_decimal_ull(m, ' ', sigign.sig[0] & 0x7fffffffUL);\r\nseq_put_decimal_ull(m, ' ', sigcatch.sig[0] & 0x7fffffffUL);\r\nseq_put_decimal_ull(m, ' ', wchan);\r\nseq_put_decimal_ull(m, ' ', 0);\r\nseq_put_decimal_ull(m, ' ', 0);\r\nseq_put_decimal_ll(m, ' ', task->exit_signal);\r\nseq_put_decimal_ll(m, ' ', task_cpu(task));\r\nseq_put_decimal_ull(m, ' ', task->rt_priority);\r\nseq_put_decimal_ull(m, ' ', task->policy);\r\nseq_put_decimal_ull(m, ' ', delayacct_blkio_ticks(task));\r\nseq_put_decimal_ull(m, ' ', cputime_to_clock_t(gtime));\r\nseq_put_decimal_ll(m, ' ', cputime_to_clock_t(cgtime));\r\nif (mm && permitted) {\r\nseq_put_decimal_ull(m, ' ', mm->start_data);\r\nseq_put_decimal_ull(m, ' ', mm->end_data);\r\nseq_put_decimal_ull(m, ' ', mm->start_brk);\r\nseq_put_decimal_ull(m, ' ', mm->arg_start);\r\nseq_put_decimal_ull(m, ' ', mm->arg_end);\r\nseq_put_decimal_ull(m, ' ', mm->env_start);\r\nseq_put_decimal_ull(m, ' ', mm->env_end);\r\n} else\r\nseq_printf(m, " 0 0 0 0 0 0 0");\r\nif (permitted)\r\nseq_put_decimal_ll(m, ' ', task->exit_code);\r\nelse\r\nseq_put_decimal_ll(m, ' ', 0);\r\nseq_putc(m, '\n');\r\nif (mm)\r\nmmput(mm);\r\nreturn 0;\r\n}\r\nint proc_tid_stat(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task)\r\n{\r\nreturn do_task_stat(m, ns, pid, task, 0);\r\n}\r\nint proc_tgid_stat(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task)\r\n{\r\nreturn do_task_stat(m, ns, pid, task, 1);\r\n}\r\nint proc_pid_statm(struct seq_file *m, struct pid_namespace *ns,\r\nstruct pid *pid, struct task_struct *task)\r\n{\r\nunsigned long size = 0, resident = 0, shared = 0, text = 0, data = 0;\r\nstruct mm_struct *mm = get_task_mm(task);\r\nif (mm) {\r\nsize = task_statm(mm, &shared, &text, &data, &resident);\r\nmmput(mm);\r\n}\r\nseq_put_decimal_ull(m, 0, size);\r\nseq_put_decimal_ull(m, ' ', resident);\r\nseq_put_decimal_ull(m, ' ', shared);\r\nseq_put_decimal_ull(m, ' ', text);\r\nseq_put_decimal_ull(m, ' ', 0);\r\nseq_put_decimal_ull(m, ' ', data);\r\nseq_put_decimal_ull(m, ' ', 0);\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic struct pid *\r\nget_children_pid(struct inode *inode, struct pid *pid_prev, loff_t pos)\r\n{\r\nstruct task_struct *start, *task;\r\nstruct pid *pid = NULL;\r\nread_lock(&tasklist_lock);\r\nstart = pid_task(proc_pid(inode), PIDTYPE_PID);\r\nif (!start)\r\ngoto out;\r\nif (pid_prev) {\r\ntask = pid_task(pid_prev, PIDTYPE_PID);\r\nif (task && task->real_parent == start &&\r\n!(list_empty(&task->sibling))) {\r\nif (list_is_last(&task->sibling, &start->children))\r\ngoto out;\r\ntask = list_first_entry(&task->sibling,\r\nstruct task_struct, sibling);\r\npid = get_pid(task_pid(task));\r\ngoto out;\r\n}\r\n}\r\nlist_for_each_entry(task, &start->children, sibling) {\r\nif (pos-- == 0) {\r\npid = get_pid(task_pid(task));\r\nbreak;\r\n}\r\n}\r\nout:\r\nread_unlock(&tasklist_lock);\r\nreturn pid;\r\n}\r\nstatic int children_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct inode *inode = seq->private;\r\npid_t pid;\r\npid = pid_nr_ns(v, inode->i_sb->s_fs_info);\r\nreturn seq_printf(seq, "%d ", pid);\r\n}\r\nstatic void *children_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn get_children_pid(seq->private, NULL, *pos);\r\n}\r\nstatic void *children_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct pid *pid;\r\npid = get_children_pid(seq->private, v, *pos + 1);\r\nput_pid(v);\r\n++*pos;\r\nreturn pid;\r\n}\r\nstatic void children_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nput_pid(v);\r\n}\r\nstatic int children_seq_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *m;\r\nint ret;\r\nret = seq_open(file, &children_seq_ops);\r\nif (ret)\r\nreturn ret;\r\nm = file->private_data;\r\nm->private = inode;\r\nreturn ret;\r\n}\r\nint children_seq_release(struct inode *inode, struct file *file)\r\n{\r\nseq_release(inode, file);\r\nreturn 0;\r\n}
