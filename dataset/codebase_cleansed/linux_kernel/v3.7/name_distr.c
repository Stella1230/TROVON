static void publ_to_item(struct distr_item *i, struct publication *p)\r\n{\r\ni->type = htonl(p->type);\r\ni->lower = htonl(p->lower);\r\ni->upper = htonl(p->upper);\r\ni->ref = htonl(p->ref);\r\ni->key = htonl(p->key);\r\n}\r\nstatic struct sk_buff *named_prepare_buf(u32 type, u32 size, u32 dest)\r\n{\r\nstruct sk_buff *buf = tipc_buf_acquire(INT_H_SIZE + size);\r\nstruct tipc_msg *msg;\r\nif (buf != NULL) {\r\nmsg = buf_msg(buf);\r\ntipc_msg_init(msg, NAME_DISTRIBUTOR, type, INT_H_SIZE, dest);\r\nmsg_set_size(msg, INT_H_SIZE + size);\r\n}\r\nreturn buf;\r\n}\r\nstatic void named_cluster_distribute(struct sk_buff *buf)\r\n{\r\nstruct sk_buff *buf_copy;\r\nstruct tipc_node *n_ptr;\r\nlist_for_each_entry(n_ptr, &tipc_node_list, list) {\r\nif (tipc_node_active_links(n_ptr)) {\r\nbuf_copy = skb_copy(buf, GFP_ATOMIC);\r\nif (!buf_copy)\r\nbreak;\r\nmsg_set_destnode(buf_msg(buf_copy), n_ptr->addr);\r\ntipc_link_send(buf_copy, n_ptr->addr, n_ptr->addr);\r\n}\r\n}\r\nkfree_skb(buf);\r\n}\r\nvoid tipc_named_publish(struct publication *publ)\r\n{\r\nstruct sk_buff *buf;\r\nstruct distr_item *item;\r\nlist_add_tail(&publ->local_list, &publ_lists[publ->scope]->list);\r\npubl_lists[publ->scope]->size++;\r\nif (publ->scope == TIPC_NODE_SCOPE)\r\nreturn;\r\nbuf = named_prepare_buf(PUBLICATION, ITEM_SIZE, 0);\r\nif (!buf) {\r\npr_warn("Publication distribution failure\n");\r\nreturn;\r\n}\r\nitem = (struct distr_item *)msg_data(buf_msg(buf));\r\npubl_to_item(item, publ);\r\nnamed_cluster_distribute(buf);\r\n}\r\nvoid tipc_named_withdraw(struct publication *publ)\r\n{\r\nstruct sk_buff *buf;\r\nstruct distr_item *item;\r\nlist_del(&publ->local_list);\r\npubl_lists[publ->scope]->size--;\r\nif (publ->scope == TIPC_NODE_SCOPE)\r\nreturn;\r\nbuf = named_prepare_buf(WITHDRAWAL, ITEM_SIZE, 0);\r\nif (!buf) {\r\npr_warn("Withdrawal distribution failure\n");\r\nreturn;\r\n}\r\nitem = (struct distr_item *)msg_data(buf_msg(buf));\r\npubl_to_item(item, publ);\r\nnamed_cluster_distribute(buf);\r\n}\r\nstatic void named_distribute(struct list_head *message_list, u32 node,\r\nstruct publ_list *pls, u32 max_item_buf)\r\n{\r\nstruct publication *publ;\r\nstruct sk_buff *buf = NULL;\r\nstruct distr_item *item = NULL;\r\nu32 left = 0;\r\nu32 rest = pls->size * ITEM_SIZE;\r\nlist_for_each_entry(publ, &pls->list, local_list) {\r\nif (!buf) {\r\nleft = (rest <= max_item_buf) ? rest : max_item_buf;\r\nrest -= left;\r\nbuf = named_prepare_buf(PUBLICATION, left, node);\r\nif (!buf) {\r\npr_warn("Bulk publication failure\n");\r\nreturn;\r\n}\r\nitem = (struct distr_item *)msg_data(buf_msg(buf));\r\n}\r\npubl_to_item(item, publ);\r\nitem++;\r\nleft -= ITEM_SIZE;\r\nif (!left) {\r\nlist_add_tail((struct list_head *)buf, message_list);\r\nbuf = NULL;\r\n}\r\n}\r\n}\r\nvoid tipc_named_node_up(unsigned long nodearg)\r\n{\r\nstruct tipc_node *n_ptr;\r\nstruct tipc_link *l_ptr;\r\nstruct list_head message_list;\r\nu32 node = (u32)nodearg;\r\nu32 max_item_buf = 0;\r\nread_lock_bh(&tipc_net_lock);\r\nn_ptr = tipc_node_find(node);\r\nif (n_ptr) {\r\ntipc_node_lock(n_ptr);\r\nl_ptr = n_ptr->active_links[0];\r\nif (l_ptr)\r\nmax_item_buf = ((l_ptr->max_pkt - INT_H_SIZE) /\r\nITEM_SIZE) * ITEM_SIZE;\r\ntipc_node_unlock(n_ptr);\r\n}\r\nread_unlock_bh(&tipc_net_lock);\r\nif (!max_item_buf)\r\nreturn;\r\nINIT_LIST_HEAD(&message_list);\r\nread_lock_bh(&tipc_nametbl_lock);\r\nnamed_distribute(&message_list, node, &publ_cluster, max_item_buf);\r\nnamed_distribute(&message_list, node, &publ_zone, max_item_buf);\r\nread_unlock_bh(&tipc_nametbl_lock);\r\ntipc_link_send_names(&message_list, (u32)node);\r\n}\r\nstatic void named_purge_publ(struct publication *publ)\r\n{\r\nstruct publication *p;\r\nwrite_lock_bh(&tipc_nametbl_lock);\r\np = tipc_nametbl_remove_publ(publ->type, publ->lower,\r\npubl->node, publ->ref, publ->key);\r\nif (p)\r\ntipc_nodesub_unsubscribe(&p->subscr);\r\nwrite_unlock_bh(&tipc_nametbl_lock);\r\nif (p != publ) {\r\npr_err("Unable to remove publication from failed node\n"\r\n" (type=%u, lower=%u, node=0x%x, ref=%u, key=%u)\n",\r\npubl->type, publ->lower, publ->node, publ->ref,\r\npubl->key);\r\n}\r\nkfree(p);\r\n}\r\nvoid tipc_named_recv(struct sk_buff *buf)\r\n{\r\nstruct publication *publ;\r\nstruct tipc_msg *msg = buf_msg(buf);\r\nstruct distr_item *item = (struct distr_item *)msg_data(msg);\r\nu32 count = msg_data_sz(msg) / ITEM_SIZE;\r\nwrite_lock_bh(&tipc_nametbl_lock);\r\nwhile (count--) {\r\nif (msg_type(msg) == PUBLICATION) {\r\npubl = tipc_nametbl_insert_publ(ntohl(item->type),\r\nntohl(item->lower),\r\nntohl(item->upper),\r\nTIPC_CLUSTER_SCOPE,\r\nmsg_orignode(msg),\r\nntohl(item->ref),\r\nntohl(item->key));\r\nif (publ) {\r\ntipc_nodesub_subscribe(&publ->subscr,\r\nmsg_orignode(msg),\r\npubl,\r\n(net_ev_handler)\r\nnamed_purge_publ);\r\n}\r\n} else if (msg_type(msg) == WITHDRAWAL) {\r\npubl = tipc_nametbl_remove_publ(ntohl(item->type),\r\nntohl(item->lower),\r\nmsg_orignode(msg),\r\nntohl(item->ref),\r\nntohl(item->key));\r\nif (publ) {\r\ntipc_nodesub_unsubscribe(&publ->subscr);\r\nkfree(publ);\r\n} else {\r\npr_err("Unable to remove publication by node 0x%x\n"\r\n" (type=%u, lower=%u, ref=%u, key=%u)\n",\r\nmsg_orignode(msg), ntohl(item->type),\r\nntohl(item->lower), ntohl(item->ref),\r\nntohl(item->key));\r\n}\r\n} else {\r\npr_warn("Unrecognized name table message received\n");\r\n}\r\nitem++;\r\n}\r\nwrite_unlock_bh(&tipc_nametbl_lock);\r\nkfree_skb(buf);\r\n}\r\nvoid tipc_named_reinit(void)\r\n{\r\nstruct publication *publ;\r\nint scope;\r\nwrite_lock_bh(&tipc_nametbl_lock);\r\nfor (scope = TIPC_ZONE_SCOPE; scope <= TIPC_NODE_SCOPE; scope++)\r\nlist_for_each_entry(publ, &publ_lists[scope]->list, local_list)\r\npubl->node = tipc_own_addr;\r\nwrite_unlock_bh(&tipc_nametbl_lock);\r\n}
