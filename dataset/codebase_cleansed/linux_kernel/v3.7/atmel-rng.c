static int atmel_trng_read(struct hwrng *rng, void *buf, size_t max,\r\nbool wait)\r\n{\r\nstruct atmel_trng *trng = container_of(rng, struct atmel_trng, rng);\r\nu32 *data = buf;\r\nif (readl(trng->base + TRNG_ISR) & 1) {\r\n*data = readl(trng->base + TRNG_ODATA);\r\nreadl(trng->base + TRNG_ISR);\r\nreturn 4;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int atmel_trng_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_trng *trng;\r\nstruct resource *res;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -EINVAL;\r\ntrng = devm_kzalloc(&pdev->dev, sizeof(*trng), GFP_KERNEL);\r\nif (!trng)\r\nreturn -ENOMEM;\r\nif (!devm_request_mem_region(&pdev->dev, res->start,\r\nresource_size(res), pdev->name))\r\nreturn -EBUSY;\r\ntrng->base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!trng->base)\r\nreturn -EBUSY;\r\ntrng->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(trng->clk))\r\nreturn PTR_ERR(trng->clk);\r\nret = clk_enable(trng->clk);\r\nif (ret)\r\ngoto err_enable;\r\nwritel(TRNG_KEY | 1, trng->base + TRNG_CR);\r\ntrng->rng.name = pdev->name;\r\ntrng->rng.read = atmel_trng_read;\r\nret = hwrng_register(&trng->rng);\r\nif (ret)\r\ngoto err_register;\r\nplatform_set_drvdata(pdev, trng);\r\nreturn 0;\r\nerr_register:\r\nclk_disable(trng->clk);\r\nerr_enable:\r\nclk_put(trng->clk);\r\nreturn ret;\r\n}\r\nstatic int __devexit atmel_trng_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_trng *trng = platform_get_drvdata(pdev);\r\nhwrng_unregister(&trng->rng);\r\nwritel(TRNG_KEY, trng->base + TRNG_CR);\r\nclk_disable(trng->clk);\r\nclk_put(trng->clk);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int atmel_trng_suspend(struct device *dev)\r\n{\r\nstruct atmel_trng *trng = dev_get_drvdata(dev);\r\nclk_disable(trng->clk);\r\nreturn 0;\r\n}\r\nstatic int atmel_trng_resume(struct device *dev)\r\n{\r\nstruct atmel_trng *trng = dev_get_drvdata(dev);\r\nreturn clk_enable(trng->clk);\r\n}
