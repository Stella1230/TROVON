int zlib_inflate_workspacesize(void)\r\n{\r\nreturn sizeof(struct inflate_workspace);\r\n}\r\nint zlib_inflateReset(z_streamp strm)\r\n{\r\nstruct inflate_state *state;\r\nif (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;\r\nstate = (struct inflate_state *)strm->state;\r\nstrm->total_in = strm->total_out = state->total = 0;\r\nstrm->msg = NULL;\r\nstrm->adler = 1;\r\nstate->mode = HEAD;\r\nstate->last = 0;\r\nstate->havedict = 0;\r\nstate->dmax = 32768U;\r\nstate->hold = 0;\r\nstate->bits = 0;\r\nstate->lencode = state->distcode = state->next = state->codes;\r\nstate->wsize = 1U << state->wbits;\r\nstate->write = 0;\r\nstate->whave = 0;\r\nreturn Z_OK;\r\n}\r\nint zlib_inflateInit2(z_streamp strm, int windowBits)\r\n{\r\nstruct inflate_state *state;\r\nif (strm == NULL) return Z_STREAM_ERROR;\r\nstrm->msg = NULL;\r\nstate = &WS(strm)->inflate_state;\r\nstrm->state = (struct internal_state *)state;\r\nif (windowBits < 0) {\r\nstate->wrap = 0;\r\nwindowBits = -windowBits;\r\n}\r\nelse {\r\nstate->wrap = (windowBits >> 4) + 1;\r\n}\r\nif (windowBits < 8 || windowBits > 15) {\r\nreturn Z_STREAM_ERROR;\r\n}\r\nstate->wbits = (unsigned)windowBits;\r\nstate->window = &WS(strm)->working_window[0];\r\nreturn zlib_inflateReset(strm);\r\n}\r\nstatic void zlib_fixedtables(struct inflate_state *state)\r\n{\r\n# include "inffixed.h"\r\nstate->lencode = lenfix;\r\nstate->lenbits = 9;\r\nstate->distcode = distfix;\r\nstate->distbits = 5;\r\n}\r\nstatic void zlib_updatewindow(z_streamp strm, unsigned out)\r\n{\r\nstruct inflate_state *state;\r\nunsigned copy, dist;\r\nstate = (struct inflate_state *)strm->state;\r\ncopy = out - strm->avail_out;\r\nif (copy >= state->wsize) {\r\nmemcpy(state->window, strm->next_out - state->wsize, state->wsize);\r\nstate->write = 0;\r\nstate->whave = state->wsize;\r\n}\r\nelse {\r\ndist = state->wsize - state->write;\r\nif (dist > copy) dist = copy;\r\nmemcpy(state->window + state->write, strm->next_out - copy, dist);\r\ncopy -= dist;\r\nif (copy) {\r\nmemcpy(state->window, strm->next_out - copy, copy);\r\nstate->write = copy;\r\nstate->whave = state->wsize;\r\n}\r\nelse {\r\nstate->write += dist;\r\nif (state->write == state->wsize) state->write = 0;\r\nif (state->whave < state->wsize) state->whave += dist;\r\n}\r\n}\r\n}\r\nstatic int zlib_inflateSyncPacket(z_streamp strm)\r\n{\r\nstruct inflate_state *state;\r\nif (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;\r\nstate = (struct inflate_state *)strm->state;\r\nif (state->mode == STORED && state->bits == 0) {\r\nstate->mode = TYPE;\r\nreturn Z_OK;\r\n}\r\nreturn Z_DATA_ERROR;\r\n}\r\nint zlib_inflate(z_streamp strm, int flush)\r\n{\r\nstruct inflate_state *state;\r\nconst unsigned char *next;\r\nunsigned char *put;\r\nunsigned have, left;\r\nunsigned long hold;\r\nunsigned bits;\r\nunsigned in, out;\r\nunsigned copy;\r\nunsigned char *from;\r\ncode this;\r\ncode last;\r\nunsigned len;\r\nint ret;\r\nstatic const unsigned short order[19] =\r\n{16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\r\nif (strm == NULL || strm->state == NULL ||\r\n(strm->next_in == NULL && strm->avail_in != 0))\r\nreturn Z_STREAM_ERROR;\r\nstate = (struct inflate_state *)strm->state;\r\nif (state->mode == TYPE) state->mode = TYPEDO;\r\nLOAD();\r\nin = have;\r\nout = left;\r\nret = Z_OK;\r\nfor (;;)\r\nswitch (state->mode) {\r\ncase HEAD:\r\nif (state->wrap == 0) {\r\nstate->mode = TYPEDO;\r\nbreak;\r\n}\r\nNEEDBITS(16);\r\nif (\r\n((BITS(8) << 8) + (hold >> 8)) % 31) {\r\nstrm->msg = (char *)"incorrect header check";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nif (BITS(4) != Z_DEFLATED) {\r\nstrm->msg = (char *)"unknown compression method";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nDROPBITS(4);\r\nlen = BITS(4) + 8;\r\nif (len > state->wbits) {\r\nstrm->msg = (char *)"invalid window size";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nstate->dmax = 1U << len;\r\nstrm->adler = state->check = zlib_adler32(0L, NULL, 0);\r\nstate->mode = hold & 0x200 ? DICTID : TYPE;\r\nINITBITS();\r\nbreak;\r\ncase DICTID:\r\nNEEDBITS(32);\r\nstrm->adler = state->check = REVERSE(hold);\r\nINITBITS();\r\nstate->mode = DICT;\r\ncase DICT:\r\nif (state->havedict == 0) {\r\nRESTORE();\r\nreturn Z_NEED_DICT;\r\n}\r\nstrm->adler = state->check = zlib_adler32(0L, NULL, 0);\r\nstate->mode = TYPE;\r\ncase TYPE:\r\nif (flush == Z_BLOCK) goto inf_leave;\r\ncase TYPEDO:\r\nif (state->last) {\r\nBYTEBITS();\r\nstate->mode = CHECK;\r\nbreak;\r\n}\r\nNEEDBITS(3);\r\nstate->last = BITS(1);\r\nDROPBITS(1);\r\nswitch (BITS(2)) {\r\ncase 0:\r\nstate->mode = STORED;\r\nbreak;\r\ncase 1:\r\nzlib_fixedtables(state);\r\nstate->mode = LEN;\r\nbreak;\r\ncase 2:\r\nstate->mode = TABLE;\r\nbreak;\r\ncase 3:\r\nstrm->msg = (char *)"invalid block type";\r\nstate->mode = BAD;\r\n}\r\nDROPBITS(2);\r\nbreak;\r\ncase STORED:\r\nBYTEBITS();\r\nNEEDBITS(32);\r\nif ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\r\nstrm->msg = (char *)"invalid stored block lengths";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nstate->length = (unsigned)hold & 0xffff;\r\nINITBITS();\r\nstate->mode = COPY;\r\ncase COPY:\r\ncopy = state->length;\r\nif (copy) {\r\nif (copy > have) copy = have;\r\nif (copy > left) copy = left;\r\nif (copy == 0) goto inf_leave;\r\nmemcpy(put, next, copy);\r\nhave -= copy;\r\nnext += copy;\r\nleft -= copy;\r\nput += copy;\r\nstate->length -= copy;\r\nbreak;\r\n}\r\nstate->mode = TYPE;\r\nbreak;\r\ncase TABLE:\r\nNEEDBITS(14);\r\nstate->nlen = BITS(5) + 257;\r\nDROPBITS(5);\r\nstate->ndist = BITS(5) + 1;\r\nDROPBITS(5);\r\nstate->ncode = BITS(4) + 4;\r\nDROPBITS(4);\r\n#ifndef PKZIP_BUG_WORKAROUND\r\nif (state->nlen > 286 || state->ndist > 30) {\r\nstrm->msg = (char *)"too many length or distance symbols";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\n#endif\r\nstate->have = 0;\r\nstate->mode = LENLENS;\r\ncase LENLENS:\r\nwhile (state->have < state->ncode) {\r\nNEEDBITS(3);\r\nstate->lens[order[state->have++]] = (unsigned short)BITS(3);\r\nDROPBITS(3);\r\n}\r\nwhile (state->have < 19)\r\nstate->lens[order[state->have++]] = 0;\r\nstate->next = state->codes;\r\nstate->lencode = (code const *)(state->next);\r\nstate->lenbits = 7;\r\nret = zlib_inflate_table(CODES, state->lens, 19, &(state->next),\r\n&(state->lenbits), state->work);\r\nif (ret) {\r\nstrm->msg = (char *)"invalid code lengths set";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nstate->have = 0;\r\nstate->mode = CODELENS;\r\ncase CODELENS:\r\nwhile (state->have < state->nlen + state->ndist) {\r\nfor (;;) {\r\nthis = state->lencode[BITS(state->lenbits)];\r\nif ((unsigned)(this.bits) <= bits) break;\r\nPULLBYTE();\r\n}\r\nif (this.val < 16) {\r\nNEEDBITS(this.bits);\r\nDROPBITS(this.bits);\r\nstate->lens[state->have++] = this.val;\r\n}\r\nelse {\r\nif (this.val == 16) {\r\nNEEDBITS(this.bits + 2);\r\nDROPBITS(this.bits);\r\nif (state->have == 0) {\r\nstrm->msg = (char *)"invalid bit length repeat";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nlen = state->lens[state->have - 1];\r\ncopy = 3 + BITS(2);\r\nDROPBITS(2);\r\n}\r\nelse if (this.val == 17) {\r\nNEEDBITS(this.bits + 3);\r\nDROPBITS(this.bits);\r\nlen = 0;\r\ncopy = 3 + BITS(3);\r\nDROPBITS(3);\r\n}\r\nelse {\r\nNEEDBITS(this.bits + 7);\r\nDROPBITS(this.bits);\r\nlen = 0;\r\ncopy = 11 + BITS(7);\r\nDROPBITS(7);\r\n}\r\nif (state->have + copy > state->nlen + state->ndist) {\r\nstrm->msg = (char *)"invalid bit length repeat";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nwhile (copy--)\r\nstate->lens[state->have++] = (unsigned short)len;\r\n}\r\n}\r\nif (state->mode == BAD) break;\r\nstate->next = state->codes;\r\nstate->lencode = (code const *)(state->next);\r\nstate->lenbits = 9;\r\nret = zlib_inflate_table(LENS, state->lens, state->nlen, &(state->next),\r\n&(state->lenbits), state->work);\r\nif (ret) {\r\nstrm->msg = (char *)"invalid literal/lengths set";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nstate->distcode = (code const *)(state->next);\r\nstate->distbits = 6;\r\nret = zlib_inflate_table(DISTS, state->lens + state->nlen, state->ndist,\r\n&(state->next), &(state->distbits), state->work);\r\nif (ret) {\r\nstrm->msg = (char *)"invalid distances set";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nstate->mode = LEN;\r\ncase LEN:\r\nif (have >= 6 && left >= 258) {\r\nRESTORE();\r\ninflate_fast(strm, out);\r\nLOAD();\r\nbreak;\r\n}\r\nfor (;;) {\r\nthis = state->lencode[BITS(state->lenbits)];\r\nif ((unsigned)(this.bits) <= bits) break;\r\nPULLBYTE();\r\n}\r\nif (this.op && (this.op & 0xf0) == 0) {\r\nlast = this;\r\nfor (;;) {\r\nthis = state->lencode[last.val +\r\n(BITS(last.bits + last.op) >> last.bits)];\r\nif ((unsigned)(last.bits + this.bits) <= bits) break;\r\nPULLBYTE();\r\n}\r\nDROPBITS(last.bits);\r\n}\r\nDROPBITS(this.bits);\r\nstate->length = (unsigned)this.val;\r\nif ((int)(this.op) == 0) {\r\nstate->mode = LIT;\r\nbreak;\r\n}\r\nif (this.op & 32) {\r\nstate->mode = TYPE;\r\nbreak;\r\n}\r\nif (this.op & 64) {\r\nstrm->msg = (char *)"invalid literal/length code";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nstate->extra = (unsigned)(this.op) & 15;\r\nstate->mode = LENEXT;\r\ncase LENEXT:\r\nif (state->extra) {\r\nNEEDBITS(state->extra);\r\nstate->length += BITS(state->extra);\r\nDROPBITS(state->extra);\r\n}\r\nstate->mode = DIST;\r\ncase DIST:\r\nfor (;;) {\r\nthis = state->distcode[BITS(state->distbits)];\r\nif ((unsigned)(this.bits) <= bits) break;\r\nPULLBYTE();\r\n}\r\nif ((this.op & 0xf0) == 0) {\r\nlast = this;\r\nfor (;;) {\r\nthis = state->distcode[last.val +\r\n(BITS(last.bits + last.op) >> last.bits)];\r\nif ((unsigned)(last.bits + this.bits) <= bits) break;\r\nPULLBYTE();\r\n}\r\nDROPBITS(last.bits);\r\n}\r\nDROPBITS(this.bits);\r\nif (this.op & 64) {\r\nstrm->msg = (char *)"invalid distance code";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nstate->offset = (unsigned)this.val;\r\nstate->extra = (unsigned)(this.op) & 15;\r\nstate->mode = DISTEXT;\r\ncase DISTEXT:\r\nif (state->extra) {\r\nNEEDBITS(state->extra);\r\nstate->offset += BITS(state->extra);\r\nDROPBITS(state->extra);\r\n}\r\n#ifdef INFLATE_STRICT\r\nif (state->offset > state->dmax) {\r\nstrm->msg = (char *)"invalid distance too far back";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\n#endif\r\nif (state->offset > state->whave + out - left) {\r\nstrm->msg = (char *)"invalid distance too far back";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nstate->mode = MATCH;\r\ncase MATCH:\r\nif (left == 0) goto inf_leave;\r\ncopy = out - left;\r\nif (state->offset > copy) {\r\ncopy = state->offset - copy;\r\nif (copy > state->write) {\r\ncopy -= state->write;\r\nfrom = state->window + (state->wsize - copy);\r\n}\r\nelse\r\nfrom = state->window + (state->write - copy);\r\nif (copy > state->length) copy = state->length;\r\n}\r\nelse {\r\nfrom = put - state->offset;\r\ncopy = state->length;\r\n}\r\nif (copy > left) copy = left;\r\nleft -= copy;\r\nstate->length -= copy;\r\ndo {\r\n*put++ = *from++;\r\n} while (--copy);\r\nif (state->length == 0) state->mode = LEN;\r\nbreak;\r\ncase LIT:\r\nif (left == 0) goto inf_leave;\r\n*put++ = (unsigned char)(state->length);\r\nleft--;\r\nstate->mode = LEN;\r\nbreak;\r\ncase CHECK:\r\nif (state->wrap) {\r\nNEEDBITS(32);\r\nout -= left;\r\nstrm->total_out += out;\r\nstate->total += out;\r\nif (out)\r\nstrm->adler = state->check =\r\nUPDATE(state->check, put - out, out);\r\nout = left;\r\nif ((\r\nREVERSE(hold)) != state->check) {\r\nstrm->msg = (char *)"incorrect data check";\r\nstate->mode = BAD;\r\nbreak;\r\n}\r\nINITBITS();\r\n}\r\nstate->mode = DONE;\r\ncase DONE:\r\nret = Z_STREAM_END;\r\ngoto inf_leave;\r\ncase BAD:\r\nret = Z_DATA_ERROR;\r\ngoto inf_leave;\r\ncase MEM:\r\nreturn Z_MEM_ERROR;\r\ncase SYNC:\r\ndefault:\r\nreturn Z_STREAM_ERROR;\r\n}\r\ninf_leave:\r\nRESTORE();\r\nif (state->wsize || (state->mode < CHECK && out != strm->avail_out))\r\nzlib_updatewindow(strm, out);\r\nin -= strm->avail_in;\r\nout -= strm->avail_out;\r\nstrm->total_in += in;\r\nstrm->total_out += out;\r\nstate->total += out;\r\nif (state->wrap && out)\r\nstrm->adler = state->check =\r\nUPDATE(state->check, strm->next_out - out, out);\r\nstrm->data_type = state->bits + (state->last ? 64 : 0) +\r\n(state->mode == TYPE ? 128 : 0);\r\nif (flush == Z_PACKET_FLUSH && ret == Z_OK &&\r\nstrm->avail_out != 0 && strm->avail_in == 0)\r\nreturn zlib_inflateSyncPacket(strm);\r\nif (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\r\nret = Z_BUF_ERROR;\r\nreturn ret;\r\n}\r\nint zlib_inflateEnd(z_streamp strm)\r\n{\r\nif (strm == NULL || strm->state == NULL)\r\nreturn Z_STREAM_ERROR;\r\nreturn Z_OK;\r\n}\r\nint zlib_inflateIncomp(z_stream *z)\r\n{\r\nstruct inflate_state *state = (struct inflate_state *)z->state;\r\nByte *saved_no = z->next_out;\r\nuInt saved_ao = z->avail_out;\r\nif (state->mode != TYPE && state->mode != HEAD)\r\nreturn Z_DATA_ERROR;\r\nz->avail_out = 0;\r\nz->next_out = (unsigned char*)z->next_in + z->avail_in;\r\nzlib_updatewindow(z, z->avail_in);\r\nz->avail_out = saved_ao;\r\nz->next_out = saved_no;\r\nz->adler = state->check =\r\nUPDATE(state->check, z->next_in, z->avail_in);\r\nz->total_out += z->avail_in;\r\nz->total_in += z->avail_in;\r\nz->next_in += z->avail_in;\r\nstate->total += z->avail_in;\r\nz->avail_in = 0;\r\nreturn Z_OK;\r\n}
