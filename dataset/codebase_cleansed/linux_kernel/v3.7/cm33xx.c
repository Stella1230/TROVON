static inline u32 am33xx_cm_read_reg(s16 inst, u16 idx)\r\n{\r\nreturn __raw_readl(cm_base + inst + idx);\r\n}\r\nstatic inline void am33xx_cm_write_reg(u32 val, s16 inst, u16 idx)\r\n{\r\n__raw_writel(val, cm_base + inst + idx);\r\n}\r\nstatic inline u32 am33xx_cm_rmw_reg_bits(u32 mask, u32 bits, s16 inst, s16 idx)\r\n{\r\nu32 v;\r\nv = am33xx_cm_read_reg(inst, idx);\r\nv &= ~mask;\r\nv |= bits;\r\nam33xx_cm_write_reg(v, inst, idx);\r\nreturn v;\r\n}\r\nstatic inline u32 am33xx_cm_set_reg_bits(u32 bits, s16 inst, s16 idx)\r\n{\r\nreturn am33xx_cm_rmw_reg_bits(bits, bits, inst, idx);\r\n}\r\nstatic inline u32 am33xx_cm_clear_reg_bits(u32 bits, s16 inst, s16 idx)\r\n{\r\nreturn am33xx_cm_rmw_reg_bits(bits, 0x0, inst, idx);\r\n}\r\nstatic inline u32 am33xx_cm_read_reg_bits(u16 inst, s16 idx, u32 mask)\r\n{\r\nu32 v;\r\nv = am33xx_cm_read_reg(inst, idx);\r\nv &= mask;\r\nv >>= __ffs(mask);\r\nreturn v;\r\n}\r\nstatic u32 _clkctrl_idlest(u16 inst, s16 cdoffs, u16 clkctrl_offs)\r\n{\r\nu32 v = am33xx_cm_read_reg(inst, clkctrl_offs);\r\nv &= AM33XX_IDLEST_MASK;\r\nv >>= AM33XX_IDLEST_SHIFT;\r\nreturn v;\r\n}\r\nstatic bool _is_module_ready(u16 inst, s16 cdoffs, u16 clkctrl_offs)\r\n{\r\nu32 v;\r\nv = _clkctrl_idlest(inst, cdoffs, clkctrl_offs);\r\nreturn (v == CLKCTRL_IDLEST_FUNCTIONAL ||\r\nv == CLKCTRL_IDLEST_INTERFACE_IDLE) ? true : false;\r\n}\r\nstatic void _clktrctrl_write(u8 c, s16 inst, u16 cdoffs)\r\n{\r\nu32 v;\r\nv = am33xx_cm_read_reg(inst, cdoffs);\r\nv &= ~AM33XX_CLKTRCTRL_MASK;\r\nv |= c << AM33XX_CLKTRCTRL_SHIFT;\r\nam33xx_cm_write_reg(v, inst, cdoffs);\r\n}\r\nbool am33xx_cm_is_clkdm_in_hwsup(s16 inst, u16 cdoffs)\r\n{\r\nu32 v;\r\nv = am33xx_cm_read_reg(inst, cdoffs);\r\nv &= AM33XX_CLKTRCTRL_MASK;\r\nv >>= AM33XX_CLKTRCTRL_SHIFT;\r\nreturn (v == OMAP34XX_CLKSTCTRL_ENABLE_AUTO) ? true : false;\r\n}\r\nvoid am33xx_cm_clkdm_enable_hwsup(s16 inst, u16 cdoffs)\r\n{\r\n_clktrctrl_write(OMAP34XX_CLKSTCTRL_ENABLE_AUTO, inst, cdoffs);\r\n}\r\nvoid am33xx_cm_clkdm_disable_hwsup(s16 inst, u16 cdoffs)\r\n{\r\n_clktrctrl_write(OMAP34XX_CLKSTCTRL_DISABLE_AUTO, inst, cdoffs);\r\n}\r\nvoid am33xx_cm_clkdm_force_sleep(s16 inst, u16 cdoffs)\r\n{\r\n_clktrctrl_write(OMAP34XX_CLKSTCTRL_FORCE_SLEEP, inst, cdoffs);\r\n}\r\nvoid am33xx_cm_clkdm_force_wakeup(s16 inst, u16 cdoffs)\r\n{\r\n_clktrctrl_write(OMAP34XX_CLKSTCTRL_FORCE_WAKEUP, inst, cdoffs);\r\n}\r\nint am33xx_cm_wait_module_ready(u16 inst, s16 cdoffs, u16 clkctrl_offs)\r\n{\r\nint i = 0;\r\nif (!clkctrl_offs)\r\nreturn 0;\r\nomap_test_timeout(_is_module_ready(inst, cdoffs, clkctrl_offs),\r\nMAX_MODULE_READY_TIME, i);\r\nreturn (i < MAX_MODULE_READY_TIME) ? 0 : -EBUSY;\r\n}\r\nint am33xx_cm_wait_module_idle(u16 inst, s16 cdoffs, u16 clkctrl_offs)\r\n{\r\nint i = 0;\r\nif (!clkctrl_offs)\r\nreturn 0;\r\nomap_test_timeout((_clkctrl_idlest(inst, cdoffs, clkctrl_offs) ==\r\nCLKCTRL_IDLEST_DISABLED),\r\nMAX_MODULE_READY_TIME, i);\r\nreturn (i < MAX_MODULE_READY_TIME) ? 0 : -EBUSY;\r\n}\r\nvoid am33xx_cm_module_enable(u8 mode, u16 inst, s16 cdoffs, u16 clkctrl_offs)\r\n{\r\nu32 v;\r\nv = am33xx_cm_read_reg(inst, clkctrl_offs);\r\nv &= ~AM33XX_MODULEMODE_MASK;\r\nv |= mode << AM33XX_MODULEMODE_SHIFT;\r\nam33xx_cm_write_reg(v, inst, clkctrl_offs);\r\n}\r\nvoid am33xx_cm_module_disable(u16 inst, s16 cdoffs, u16 clkctrl_offs)\r\n{\r\nu32 v;\r\nv = am33xx_cm_read_reg(inst, clkctrl_offs);\r\nv &= ~AM33XX_MODULEMODE_MASK;\r\nam33xx_cm_write_reg(v, inst, clkctrl_offs);\r\n}
