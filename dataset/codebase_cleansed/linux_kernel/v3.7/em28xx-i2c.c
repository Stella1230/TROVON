static int em2800_i2c_send_max4(struct em28xx *dev, unsigned char addr,\r\nchar *buf, int len)\r\n{\r\nint ret;\r\nint write_timeout;\r\nunsigned char b2[6];\r\nBUG_ON(len < 1 || len > 4);\r\nb2[5] = 0x80 + len - 1;\r\nb2[4] = addr;\r\nb2[3] = buf[0];\r\nif (len > 1)\r\nb2[2] = buf[1];\r\nif (len > 2)\r\nb2[1] = buf[2];\r\nif (len > 3)\r\nb2[0] = buf[3];\r\nret = dev->em28xx_write_regs(dev, 4 - len, &b2[4 - len], 2 + len);\r\nif (ret != 2 + len) {\r\nem28xx_warn("writing to i2c device failed (error=%i)\n", ret);\r\nreturn -EIO;\r\n}\r\nfor (write_timeout = EM2800_I2C_WRITE_TIMEOUT; write_timeout > 0;\r\nwrite_timeout -= 5) {\r\nret = dev->em28xx_read_reg(dev, 0x05);\r\nif (ret == 0x80 + len - 1)\r\nreturn len;\r\nmsleep(5);\r\n}\r\nem28xx_warn("i2c write timed out\n");\r\nreturn -EIO;\r\n}\r\nstatic int em2800_i2c_send_bytes(void *data, unsigned char addr, char *buf,\r\nshort len)\r\n{\r\nchar *bufPtr = buf;\r\nint ret;\r\nint wrcount = 0;\r\nint count;\r\nint maxLen = 4;\r\nstruct em28xx *dev = (struct em28xx *)data;\r\nwhile (len > 0) {\r\ncount = (len > maxLen) ? maxLen : len;\r\nret = em2800_i2c_send_max4(dev, addr, bufPtr, count);\r\nif (ret > 0) {\r\nlen -= count;\r\nbufPtr += count;\r\nwrcount += count;\r\n} else\r\nreturn (ret < 0) ? ret : -EFAULT;\r\n}\r\nreturn wrcount;\r\n}\r\nstatic int em2800_i2c_check_for_device(struct em28xx *dev, unsigned char addr)\r\n{\r\nchar msg;\r\nint ret;\r\nint write_timeout;\r\nmsg = addr;\r\nret = dev->em28xx_write_regs(dev, 0x04, &msg, 1);\r\nif (ret < 0) {\r\nem28xx_warn("setting i2c device address failed (error=%i)\n",\r\nret);\r\nreturn ret;\r\n}\r\nmsg = 0x84;\r\nret = dev->em28xx_write_regs(dev, 0x05, &msg, 1);\r\nif (ret < 0) {\r\nem28xx_warn("preparing i2c read failed (error=%i)\n", ret);\r\nreturn ret;\r\n}\r\nfor (write_timeout = EM2800_I2C_WRITE_TIMEOUT; write_timeout > 0;\r\nwrite_timeout -= 5) {\r\nunsigned reg = dev->em28xx_read_reg(dev, 0x5);\r\nif (reg == 0x94)\r\nreturn -ENODEV;\r\nelse if (reg == 0x84)\r\nreturn 0;\r\nmsleep(5);\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int em2800_i2c_recv_bytes(struct em28xx *dev, unsigned char addr,\r\nchar *buf, int len)\r\n{\r\nint ret;\r\nret = em2800_i2c_check_for_device(dev, addr);\r\nif (ret) {\r\nem28xx_warn\r\n("preparing read at i2c address 0x%x failed (error=%i)\n",\r\naddr, ret);\r\nreturn ret;\r\n}\r\nret = dev->em28xx_read_reg_req_len(dev, 0x0, 0x3, buf, len);\r\nif (ret < 0) {\r\nem28xx_warn("reading from i2c device at 0x%x failed (error=%i)",\r\naddr, ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int em28xx_i2c_send_bytes(void *data, unsigned char addr, char *buf,\r\nshort len, int stop)\r\n{\r\nint wrcount = 0;\r\nstruct em28xx *dev = (struct em28xx *)data;\r\nint write_timeout, ret;\r\nwrcount = dev->em28xx_write_regs_req(dev, stop ? 2 : 3, addr, buf, len);\r\nfor (write_timeout = EM2800_I2C_WRITE_TIMEOUT; write_timeout > 0;\r\nwrite_timeout -= 5) {\r\nret = dev->em28xx_read_reg(dev, 0x05);\r\nif (!ret)\r\nbreak;\r\nmsleep(5);\r\n}\r\nreturn wrcount;\r\n}\r\nstatic int em28xx_i2c_recv_bytes(struct em28xx *dev, unsigned char addr,\r\nchar *buf, int len)\r\n{\r\nint ret;\r\nret = dev->em28xx_read_reg_req_len(dev, 2, addr, buf, len);\r\nif (ret < 0) {\r\nem28xx_warn("reading i2c device failed (error=%i)\n", ret);\r\nreturn ret;\r\n}\r\nif (dev->em28xx_read_reg(dev, 0x5) != 0)\r\nreturn -ENODEV;\r\nreturn ret;\r\n}\r\nstatic int em28xx_i2c_check_for_device(struct em28xx *dev, unsigned char addr)\r\n{\r\nint ret;\r\nret = dev->em28xx_read_reg_req(dev, 2, addr);\r\nif (ret < 0) {\r\nem28xx_warn("reading from i2c device failed (error=%i)\n", ret);\r\nreturn ret;\r\n}\r\nif (dev->em28xx_read_reg(dev, 0x5) != 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int em28xx_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct em28xx *dev = i2c_adap->algo_data;\r\nint addr, rc, i, byte;\r\nif (num <= 0)\r\nreturn 0;\r\nfor (i = 0; i < num; i++) {\r\naddr = msgs[i].addr << 1;\r\ndprintk2(2, "%s %s addr=%x len=%d:",\r\n(msgs[i].flags & I2C_M_RD) ? "read" : "write",\r\ni == num - 1 ? "stop" : "nonstop", addr, msgs[i].len);\r\nif (!msgs[i].len) {\r\nif (dev->board.is_em2800)\r\nrc = em2800_i2c_check_for_device(dev, addr);\r\nelse\r\nrc = em28xx_i2c_check_for_device(dev, addr);\r\nif (rc < 0) {\r\ndprintk2(2, " no device\n");\r\nreturn rc;\r\n}\r\n} else if (msgs[i].flags & I2C_M_RD) {\r\nif (dev->board.is_em2800)\r\nrc = em2800_i2c_recv_bytes(dev, addr,\r\nmsgs[i].buf,\r\nmsgs[i].len);\r\nelse\r\nrc = em28xx_i2c_recv_bytes(dev, addr,\r\nmsgs[i].buf,\r\nmsgs[i].len);\r\nif (i2c_debug >= 2) {\r\nfor (byte = 0; byte < msgs[i].len; byte++)\r\nprintk(" %02x", msgs[i].buf[byte]);\r\n}\r\n} else {\r\nif (i2c_debug >= 2) {\r\nfor (byte = 0; byte < msgs[i].len; byte++)\r\nprintk(" %02x", msgs[i].buf[byte]);\r\n}\r\nif (dev->board.is_em2800)\r\nrc = em2800_i2c_send_bytes(dev, addr,\r\nmsgs[i].buf,\r\nmsgs[i].len);\r\nelse\r\nrc = em28xx_i2c_send_bytes(dev, addr,\r\nmsgs[i].buf,\r\nmsgs[i].len,\r\ni == num - 1);\r\n}\r\nif (rc < 0)\r\ngoto err;\r\nif (i2c_debug >= 2)\r\nprintk("\n");\r\n}\r\nreturn num;\r\nerr:\r\ndprintk2(2, " ERROR: %i\n", rc);\r\nreturn rc;\r\n}\r\nstatic inline unsigned long em28xx_hash_mem(char *buf, int length, int bits)\r\n{\r\nunsigned long hash = 0;\r\nunsigned long l = 0;\r\nint len = 0;\r\nunsigned char c;\r\ndo {\r\nif (len == length) {\r\nc = (char)len;\r\nlen = -1;\r\n} else\r\nc = *buf++;\r\nl = (l << 8) | c;\r\nlen++;\r\nif ((len & (32 / 8 - 1)) == 0)\r\nhash = ((hash^l) * 0x9e370001UL);\r\n} while (len);\r\nreturn (hash >> (32 - bits)) & 0xffffffffUL;\r\n}\r\nstatic int em28xx_i2c_eeprom(struct em28xx *dev, unsigned char *eedata, int len)\r\n{\r\nunsigned char buf, *p = eedata;\r\nstruct em28xx_eeprom *em_eeprom = (void *)eedata;\r\nint i, err, size = len, block;\r\nif (dev->chip_id == CHIP_ID_EM2874 ||\r\ndev->chip_id == CHIP_ID_EM28174 ||\r\ndev->chip_id == CHIP_ID_EM2884) {\r\nreturn 0;\r\n}\r\ndev->i2c_client.addr = 0xa0 >> 1;\r\nerr = i2c_master_recv(&dev->i2c_client, &buf, 0);\r\nif (err < 0) {\r\nem28xx_errdev("board has no eeprom\n");\r\nmemset(eedata, 0, len);\r\nreturn -ENODEV;\r\n}\r\nbuf = 0;\r\nerr = i2c_master_send(&dev->i2c_client, &buf, 1);\r\nif (err != 1) {\r\nprintk(KERN_INFO "%s: Huh, no eeprom present (err=%d)?\n",\r\ndev->name, err);\r\nreturn err;\r\n}\r\nwhile (size > 0) {\r\nif (size > 16)\r\nblock = 16;\r\nelse\r\nblock = size;\r\nif (block !=\r\n(err = i2c_master_recv(&dev->i2c_client, p, block))) {\r\nprintk(KERN_WARNING\r\n"%s: i2c eeprom read error (err=%d)\n",\r\ndev->name, err);\r\nreturn err;\r\n}\r\nsize -= block;\r\np += block;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nif (0 == (i % 16))\r\nprintk(KERN_INFO "%s: i2c eeprom %02x:", dev->name, i);\r\nprintk(" %02x", eedata[i]);\r\nif (15 == (i % 16))\r\nprintk("\n");\r\n}\r\nif (em_eeprom->id == 0x9567eb1a)\r\ndev->hash = em28xx_hash_mem(eedata, len, 32);\r\nprintk(KERN_INFO "%s: EEPROM ID= 0x%08x, EEPROM hash = 0x%08lx\n",\r\ndev->name, em_eeprom->id, dev->hash);\r\nprintk(KERN_INFO "%s: EEPROM info:\n", dev->name);\r\nswitch (em_eeprom->chip_conf >> 4 & 0x3) {\r\ncase 0:\r\nprintk(KERN_INFO "%s:\tNo audio on board.\n", dev->name);\r\nbreak;\r\ncase 1:\r\nprintk(KERN_INFO "%s:\tAC97 audio (5 sample rates)\n",\r\ndev->name);\r\nbreak;\r\ncase 2:\r\nprintk(KERN_INFO "%s:\tI2S audio, sample rate=32k\n",\r\ndev->name);\r\nbreak;\r\ncase 3:\r\nprintk(KERN_INFO "%s:\tI2S audio, 3 sample rates\n",\r\ndev->name);\r\nbreak;\r\n}\r\nif (em_eeprom->chip_conf & 1 << 3)\r\nprintk(KERN_INFO "%s:\tUSB Remote wakeup capable\n", dev->name);\r\nif (em_eeprom->chip_conf & 1 << 2)\r\nprintk(KERN_INFO "%s:\tUSB Self power capable\n", dev->name);\r\nswitch (em_eeprom->chip_conf & 0x3) {\r\ncase 0:\r\nprintk(KERN_INFO "%s:\t500mA max power\n", dev->name);\r\nbreak;\r\ncase 1:\r\nprintk(KERN_INFO "%s:\t400mA max power\n", dev->name);\r\nbreak;\r\ncase 2:\r\nprintk(KERN_INFO "%s:\t300mA max power\n", dev->name);\r\nbreak;\r\ncase 3:\r\nprintk(KERN_INFO "%s:\t200mA max power\n", dev->name);\r\nbreak;\r\n}\r\nprintk(KERN_INFO "%s:\tTable at 0x%02x, strings=0x%04x, 0x%04x, 0x%04x\n",\r\ndev->name,\r\nem_eeprom->string_idx_table,\r\nem_eeprom->string1,\r\nem_eeprom->string2,\r\nem_eeprom->string3);\r\nreturn 0;\r\n}\r\nstatic u32 functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_SMBUS_EMUL;\r\n}\r\nvoid em28xx_do_i2c_scan(struct em28xx *dev)\r\n{\r\nu8 i2c_devicelist[128];\r\nunsigned char buf;\r\nint i, rc;\r\nmemset(i2c_devicelist, 0, ARRAY_SIZE(i2c_devicelist));\r\nfor (i = 0; i < ARRAY_SIZE(i2c_devs); i++) {\r\ndev->i2c_client.addr = i;\r\nrc = i2c_master_recv(&dev->i2c_client, &buf, 0);\r\nif (rc < 0)\r\ncontinue;\r\ni2c_devicelist[i] = i;\r\nprintk(KERN_INFO "%s: found i2c device @ 0x%x [%s]\n",\r\ndev->name, i << 1, i2c_devs[i] ? i2c_devs[i] : "???");\r\n}\r\ndev->i2c_hash = em28xx_hash_mem(i2c_devicelist,\r\nARRAY_SIZE(i2c_devicelist), 32);\r\n}\r\nint em28xx_i2c_register(struct em28xx *dev)\r\n{\r\nint retval;\r\nBUG_ON(!dev->em28xx_write_regs || !dev->em28xx_read_reg);\r\nBUG_ON(!dev->em28xx_write_regs_req || !dev->em28xx_read_reg_req);\r\ndev->i2c_adap = em28xx_adap_template;\r\ndev->i2c_adap.dev.parent = &dev->udev->dev;\r\nstrcpy(dev->i2c_adap.name, dev->name);\r\ndev->i2c_adap.algo_data = dev;\r\ni2c_set_adapdata(&dev->i2c_adap, &dev->v4l2_dev);\r\nretval = i2c_add_adapter(&dev->i2c_adap);\r\nif (retval < 0) {\r\nem28xx_errdev("%s: i2c_add_adapter failed! retval [%d]\n",\r\n__func__, retval);\r\nreturn retval;\r\n}\r\ndev->i2c_client = em28xx_client_template;\r\ndev->i2c_client.adapter = &dev->i2c_adap;\r\nretval = em28xx_i2c_eeprom(dev, dev->eedata, sizeof(dev->eedata));\r\nif ((retval < 0) && (retval != -ENODEV)) {\r\nem28xx_errdev("%s: em28xx_i2_eeprom failed! retval [%d]\n",\r\n__func__, retval);\r\nreturn retval;\r\n}\r\nif (i2c_scan)\r\nem28xx_do_i2c_scan(dev);\r\nreturn 0;\r\n}\r\nint em28xx_i2c_unregister(struct em28xx *dev)\r\n{\r\ni2c_del_adapter(&dev->i2c_adap);\r\nreturn 0;\r\n}
