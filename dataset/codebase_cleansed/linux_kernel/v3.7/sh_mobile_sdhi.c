static int sh_mobile_sdhi_clk_enable(struct platform_device *pdev, unsigned int *f)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(&pdev->dev);\r\nstruct tmio_mmc_host *host = mmc_priv(mmc);\r\nstruct sh_mobile_sdhi *priv = container_of(host->pdata, struct sh_mobile_sdhi, mmc_data);\r\nint ret = clk_enable(priv->clk);\r\nif (ret < 0)\r\nreturn ret;\r\n*f = clk_get_rate(priv->clk);\r\nreturn 0;\r\n}\r\nstatic void sh_mobile_sdhi_clk_disable(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(&pdev->dev);\r\nstruct tmio_mmc_host *host = mmc_priv(mmc);\r\nstruct sh_mobile_sdhi *priv = container_of(host->pdata, struct sh_mobile_sdhi, mmc_data);\r\nclk_disable(priv->clk);\r\n}\r\nstatic void sh_mobile_sdhi_set_pwr(struct platform_device *pdev, int state)\r\n{\r\nstruct sh_mobile_sdhi_info *p = pdev->dev.platform_data;\r\np->set_pwr(pdev, state);\r\n}\r\nstatic int sh_mobile_sdhi_get_cd(struct platform_device *pdev)\r\n{\r\nstruct sh_mobile_sdhi_info *p = pdev->dev.platform_data;\r\nreturn p->get_cd(pdev);\r\n}\r\nstatic int sh_mobile_sdhi_wait_idle(struct tmio_mmc_host *host)\r\n{\r\nint timeout = 1000;\r\nwhile (--timeout && !(sd_ctrl_read16(host, CTL_STATUS2) & (1 << 13)))\r\nudelay(1);\r\nif (!timeout) {\r\ndev_warn(host->pdata->dev, "timeout waiting for SD bus idle\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_sdhi_write16_hook(struct tmio_mmc_host *host, int addr)\r\n{\r\nswitch (addr)\r\n{\r\ncase CTL_SD_CMD:\r\ncase CTL_STOP_INTERNAL_ACTION:\r\ncase CTL_XFER_BLK_COUNT:\r\ncase CTL_SD_CARD_CLK_CTL:\r\ncase CTL_SD_XFER_LEN:\r\ncase CTL_SD_MEM_CARD_OPT:\r\ncase CTL_TRANSACTION_CTL:\r\ncase CTL_DMA_ENABLE:\r\nreturn sh_mobile_sdhi_wait_idle(host);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sh_mobile_sdhi_cd_wakeup(const struct platform_device *pdev)\r\n{\r\nmmc_detect_change(dev_get_drvdata(&pdev->dev), msecs_to_jiffies(100));\r\n}\r\nstatic int __devinit sh_mobile_sdhi_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_mobile_sdhi *priv;\r\nstruct tmio_mmc_data *mmc_data;\r\nstruct sh_mobile_sdhi_info *p = pdev->dev.platform_data;\r\nstruct tmio_mmc_host *host;\r\nchar clk_name[8];\r\nint irq, ret, i = 0;\r\nbool multiplexed_isr = true;\r\npriv = kzalloc(sizeof(struct sh_mobile_sdhi), GFP_KERNEL);\r\nif (priv == NULL) {\r\ndev_err(&pdev->dev, "kzalloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmmc_data = &priv->mmc_data;\r\nif (p) {\r\np->pdata = mmc_data;\r\nif (p->init) {\r\nret = p->init(pdev, &sdhi_ops);\r\nif (ret)\r\ngoto einit;\r\n}\r\n}\r\nsnprintf(clk_name, sizeof(clk_name), "sdhi%d", pdev->id);\r\npriv->clk = clk_get(&pdev->dev, clk_name);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock \"%s\"\n", clk_name);\r\nret = PTR_ERR(priv->clk);\r\ngoto eclkget;\r\n}\r\nmmc_data->clk_enable = sh_mobile_sdhi_clk_enable;\r\nmmc_data->clk_disable = sh_mobile_sdhi_clk_disable;\r\nmmc_data->capabilities = MMC_CAP_MMC_HIGHSPEED;\r\nif (p) {\r\nmmc_data->flags = p->tmio_flags;\r\nif (mmc_data->flags & TMIO_MMC_HAS_IDLE_WAIT)\r\nmmc_data->write16_hook = sh_mobile_sdhi_write16_hook;\r\nmmc_data->ocr_mask = p->tmio_ocr_mask;\r\nmmc_data->capabilities |= p->tmio_caps;\r\nmmc_data->capabilities2 |= p->tmio_caps2;\r\nmmc_data->cd_gpio = p->cd_gpio;\r\nif (p->set_pwr)\r\nmmc_data->set_pwr = sh_mobile_sdhi_set_pwr;\r\nif (p->get_cd)\r\nmmc_data->get_cd = sh_mobile_sdhi_get_cd;\r\nif (p->dma_slave_tx > 0 && p->dma_slave_rx > 0) {\r\npriv->param_tx.shdma_slave.slave_id = p->dma_slave_tx;\r\npriv->param_rx.shdma_slave.slave_id = p->dma_slave_rx;\r\npriv->dma_priv.chan_priv_tx = &priv->param_tx.shdma_slave;\r\npriv->dma_priv.chan_priv_rx = &priv->param_rx.shdma_slave;\r\npriv->dma_priv.alignment_shift = 1;\r\nmmc_data->dma = &priv->dma_priv;\r\n}\r\n}\r\nmmc_data->flags |= TMIO_MMC_BLKSZ_2BYTES;\r\nmmc_data->flags |= TMIO_MMC_SDIO_IRQ;\r\nret = tmio_mmc_host_probe(&host, pdev, mmc_data);\r\nif (ret < 0)\r\ngoto eprobe;\r\nirq = platform_get_irq_byname(pdev, SH_MOBILE_SDHI_IRQ_CARD_DETECT);\r\nif (irq >= 0) {\r\nmultiplexed_isr = false;\r\nret = request_irq(irq, tmio_mmc_card_detect_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto eirq_card_detect;\r\n}\r\nirq = platform_get_irq_byname(pdev, SH_MOBILE_SDHI_IRQ_SDIO);\r\nif (irq >= 0) {\r\nmultiplexed_isr = false;\r\nret = request_irq(irq, tmio_mmc_sdio_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto eirq_sdio;\r\n}\r\nirq = platform_get_irq_byname(pdev, SH_MOBILE_SDHI_IRQ_SDCARD);\r\nif (irq >= 0) {\r\nmultiplexed_isr = false;\r\nret = request_irq(irq, tmio_mmc_sdcard_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto eirq_sdcard;\r\n} else if (!multiplexed_isr) {\r\ndev_err(&pdev->dev,\r\n"Principal SD-card IRQ is missing among named interrupts\n");\r\nret = irq;\r\ngoto eirq_sdcard;\r\n}\r\nif (multiplexed_isr) {\r\nwhile (1) {\r\nirq = platform_get_irq(pdev, i);\r\nif (irq < 0)\r\nbreak;\r\ni++;\r\nret = request_irq(irq, tmio_mmc_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto eirq_multiplexed;\r\n}\r\nif (!i)\r\ngoto eirq_multiplexed;\r\n}\r\ndev_info(&pdev->dev, "%s base at 0x%08lx clock rate %u MHz\n",\r\nmmc_hostname(host->mmc), (unsigned long)\r\n(platform_get_resource(pdev, IORESOURCE_MEM, 0)->start),\r\nmmc_data->hclk / 1000000);\r\nreturn ret;\r\neirq_multiplexed:\r\nwhile (i--) {\r\nirq = platform_get_irq(pdev, i);\r\nfree_irq(irq, host);\r\n}\r\neirq_sdcard:\r\nirq = platform_get_irq_byname(pdev, SH_MOBILE_SDHI_IRQ_SDIO);\r\nif (irq >= 0)\r\nfree_irq(irq, host);\r\neirq_sdio:\r\nirq = platform_get_irq_byname(pdev, SH_MOBILE_SDHI_IRQ_CARD_DETECT);\r\nif (irq >= 0)\r\nfree_irq(irq, host);\r\neirq_card_detect:\r\ntmio_mmc_host_remove(host);\r\neprobe:\r\nclk_put(priv->clk);\r\neclkget:\r\nif (p && p->cleanup)\r\np->cleanup(pdev);\r\neinit:\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic int sh_mobile_sdhi_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct tmio_mmc_host *host = mmc_priv(mmc);\r\nstruct sh_mobile_sdhi *priv = container_of(host->pdata, struct sh_mobile_sdhi, mmc_data);\r\nstruct sh_mobile_sdhi_info *p = pdev->dev.platform_data;\r\nint i = 0, irq;\r\nif (p)\r\np->pdata = NULL;\r\ntmio_mmc_host_remove(host);\r\nwhile (1) {\r\nirq = platform_get_irq(pdev, i++);\r\nif (irq < 0)\r\nbreak;\r\nfree_irq(irq, host);\r\n}\r\nclk_put(priv->clk);\r\nif (p && p->cleanup)\r\np->cleanup(pdev);\r\nkfree(priv);\r\nreturn 0;\r\n}
