int cycx_x25_wan_init(struct cycx_device *card, wandev_conf_t *conf)\r\n{\r\nstruct cycx_x25_config cfg;\r\nif (conf->config_id != WANCONFIG_X25) {\r\npr_info("%s: invalid configuration ID %u!\n",\r\ncard->devname, conf->config_id);\r\nreturn -EINVAL;\r\n}\r\ncard->mbox = card->hw.dpmbase + X25_MBOX_OFFS;\r\ncard->u.x.connection_keys = 0;\r\nspin_lock_init(&card->u.x.lock);\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.link = 0;\r\ncfg.clock = conf->clocking == WANOPT_EXTERNAL ? 8 : 55;\r\ncfg.speed = bps_to_speed_code(conf->bps);\r\ncfg.n3win = 7;\r\ncfg.n2win = 2;\r\ncfg.n2 = 5;\r\ncfg.nvc = 1;\r\ncfg.npvc = 1;\r\ncfg.flags = 0x02;\r\ncfg.t1 = 10;\r\ncfg.t2 = 29;\r\ncfg.t21 = 180;\r\ncfg.t23 = 180;\r\nif (!conf->mtu || conf->mtu >= 512)\r\ncard->wandev.mtu = 512;\r\nelse if (conf->mtu >= 256)\r\ncard->wandev.mtu = 256;\r\nelse if (conf->mtu >= 128)\r\ncard->wandev.mtu = 128;\r\nelse\r\ncard->wandev.mtu = 64;\r\ncfg.pktlen = cycx_log2(card->wandev.mtu);\r\nif (conf->station == WANOPT_DTE) {\r\ncfg.locaddr = 3;\r\ncfg.remaddr = 1;\r\n} else {\r\ncfg.locaddr = 1;\r\ncfg.remaddr = 3;\r\n}\r\nif (conf->interface == WANOPT_RS232)\r\ncfg.flags = 0;\r\nif (conf->u.x25.hi_pvc) {\r\ncard->u.x.hi_pvc = min_t(unsigned int, conf->u.x25.hi_pvc, 4095);\r\ncard->u.x.lo_pvc = min_t(unsigned int, conf->u.x25.lo_pvc, card->u.x.hi_pvc);\r\n}\r\nif (conf->u.x25.hi_svc) {\r\ncard->u.x.hi_svc = min_t(unsigned int, conf->u.x25.hi_svc, 4095);\r\ncard->u.x.lo_svc = min_t(unsigned int, conf->u.x25.lo_svc, card->u.x.hi_svc);\r\n}\r\nif (card->u.x.lo_pvc == 255)\r\ncfg.npvc = 0;\r\nelse\r\ncfg.npvc = card->u.x.hi_pvc - card->u.x.lo_pvc + 1;\r\ncfg.nvc = card->u.x.hi_svc - card->u.x.lo_svc + 1 + cfg.npvc;\r\nif (conf->u.x25.hdlc_window)\r\ncfg.n2win = min_t(unsigned int, conf->u.x25.hdlc_window, 7);\r\nif (conf->u.x25.pkt_window)\r\ncfg.n3win = min_t(unsigned int, conf->u.x25.pkt_window, 7);\r\nif (conf->u.x25.t1)\r\ncfg.t1 = min_t(unsigned int, conf->u.x25.t1, 30);\r\nif (conf->u.x25.t2)\r\ncfg.t2 = min_t(unsigned int, conf->u.x25.t2, 30);\r\nif (conf->u.x25.t11_t21)\r\ncfg.t21 = min_t(unsigned int, conf->u.x25.t11_t21, 30);\r\nif (conf->u.x25.t13_t23)\r\ncfg.t23 = min_t(unsigned int, conf->u.x25.t13_t23, 30);\r\nif (conf->u.x25.n2)\r\ncfg.n2 = min_t(unsigned int, conf->u.x25.n2, 30);\r\nif (cycx_x25_configure(card, &cfg))\r\nreturn -EIO;\r\ncard->wandev.bps = conf->bps;\r\ncard->wandev.interface = conf->interface;\r\ncard->wandev.clocking = conf->clocking;\r\ncard->wandev.station = conf->station;\r\ncard->isr = cycx_x25_irq_handler;\r\ncard->exec = NULL;\r\ncard->wandev.update = cycx_wan_update;\r\ncard->wandev.new_if = cycx_wan_new_if;\r\ncard->wandev.del_if = cycx_wan_del_if;\r\ncard->wandev.state = WAN_DISCONNECTED;\r\nreturn 0;\r\n}\r\nstatic int cycx_wan_update(struct wan_device *wandev)\r\n{\r\nif (!wandev || !wandev->private)\r\nreturn -EFAULT;\r\nif (wandev->state == WAN_UNCONFIGURED)\r\nreturn -ENODEV;\r\ncycx_x25_get_stats(wandev->private);\r\nreturn 0;\r\n}\r\nstatic int cycx_wan_new_if(struct wan_device *wandev, struct net_device *dev,\r\nwanif_conf_t *conf)\r\n{\r\nstruct cycx_device *card = wandev->private;\r\nstruct cycx_x25_channel *chan;\r\nint err = 0;\r\nif (!conf->name[0] || strlen(conf->name) > WAN_IFNAME_SZ) {\r\npr_info("%s: invalid interface name!\n", card->devname);\r\nreturn -EINVAL;\r\n}\r\ndev = alloc_netdev(sizeof(struct cycx_x25_channel), conf->name,\r\ncycx_x25_chan_setup);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nchan = netdev_priv(dev);\r\nstrcpy(chan->name, conf->name);\r\nchan->card = card;\r\nchan->link = conf->port;\r\nchan->protocol = conf->protocol ? ETH_P_X25 : ETH_P_IP;\r\nchan->rx_skb = NULL;\r\nchan->local_addr = NULL;\r\nif (conf->addr[0] == '@') {\r\nint len = strlen(conf->local_addr);\r\nif (len) {\r\nif (len > WAN_ADDRESS_SZ) {\r\npr_err("%s: %s local addr too long!\n",\r\nwandev->name, chan->name);\r\nerr = -EINVAL;\r\ngoto error;\r\n} else {\r\nchan->local_addr = kmalloc(len + 1, GFP_KERNEL);\r\nif (!chan->local_addr) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\nstrncpy(chan->local_addr, conf->local_addr,\r\nWAN_ADDRESS_SZ);\r\n}\r\nchan->svc = 1;\r\nstrncpy(chan->addr, &conf->addr[1], WAN_ADDRESS_SZ);\r\ninit_timer(&chan->timer);\r\nchan->timer.function = cycx_x25_chan_timer;\r\nchan->timer.data = (unsigned long)dev;\r\nchan->idle_tmout = conf->idle_timeout ? conf->idle_timeout : 90;\r\n} else if (isdigit(conf->addr[0])) {\r\ns16 lcn = dec_to_uint(conf->addr, 0);\r\nif (lcn >= card->u.x.lo_pvc && lcn <= card->u.x.hi_pvc)\r\nchan->lcn = lcn;\r\nelse {\r\npr_err("%s: PVC %u is out of range on interface %s!\n",\r\nwandev->name, lcn, chan->name);\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\n} else {\r\npr_err("%s: invalid media address on interface %s!\n",\r\nwandev->name, chan->name);\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic int cycx_wan_del_if(struct wan_device *wandev, struct net_device *dev)\r\n{\r\nstruct cycx_x25_channel *chan = netdev_priv(dev);\r\nif (chan->svc) {\r\nkfree(chan->local_addr);\r\nif (chan->state == WAN_CONNECTED)\r\ndel_timer(&chan->timer);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cycx_x25_chan_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &cycx_netdev_ops;\r\ndev->header_ops = &cycx_header_ops;\r\ndev->mtu = CYCX_X25_CHAN_MTU;\r\ndev->type = ARPHRD_HWX25;\r\ndev->hard_header_len = 0;\r\ndev->addr_len = 0;\r\n}\r\nstatic int cycx_netdevice_init(struct net_device *dev)\r\n{\r\nstruct cycx_x25_channel *chan = netdev_priv(dev);\r\nstruct cycx_device *card = chan->card;\r\nstruct wan_device *wandev = &card->wandev;\r\nif (!chan->svc)\r\n*(__be16*)dev->dev_addr = htons(chan->lcn);\r\ndev->irq = wandev->irq;\r\ndev->dma = wandev->dma;\r\ndev->base_addr = wandev->ioport;\r\ndev->mem_start = (unsigned long)wandev->maddr;\r\ndev->mem_end = (unsigned long)(wandev->maddr +\r\nwandev->msize - 1);\r\ndev->flags |= IFF_NOARP;\r\ndev->tx_queue_len = 10;\r\ncycx_x25_set_chan_state(dev, WAN_DISCONNECTED);\r\nreturn 0;\r\n}\r\nstatic int cycx_netdevice_open(struct net_device *dev)\r\n{\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int cycx_netdevice_stop(struct net_device *dev)\r\n{\r\nstruct cycx_x25_channel *chan = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nif (chan->state == WAN_CONNECTED || chan->state == WAN_CONNECTING)\r\ncycx_x25_chan_disconnect(dev);\r\nreturn 0;\r\n}\r\nstatic int cycx_netdevice_hard_header(struct sk_buff *skb,\r\nstruct net_device *dev, u16 type,\r\nconst void *daddr, const void *saddr,\r\nunsigned len)\r\n{\r\nskb->protocol = htons(type);\r\nreturn dev->hard_header_len;\r\n}\r\nstatic int cycx_netdevice_rebuild_header(struct sk_buff *skb)\r\n{\r\nreturn 1;\r\n}\r\nstatic netdev_tx_t cycx_netdevice_hard_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct cycx_x25_channel *chan = netdev_priv(dev);\r\nstruct cycx_device *card = chan->card;\r\nif (!chan->svc)\r\nchan->protocol = ntohs(skb->protocol);\r\nif (card->wandev.state != WAN_CONNECTED)\r\n++chan->ifstats.tx_dropped;\r\nelse if (chan->svc && chan->protocol &&\r\nchan->protocol != ntohs(skb->protocol)) {\r\npr_info("%s: unsupported Ethertype 0x%04X on interface %s!\n",\r\ncard->devname, ntohs(skb->protocol), dev->name);\r\n++chan->ifstats.tx_errors;\r\n} else if (chan->protocol == ETH_P_IP) {\r\nswitch (chan->state) {\r\ncase WAN_DISCONNECTED:\r\nif (cycx_x25_chan_connect(dev)) {\r\nnetif_stop_queue(dev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ncase WAN_CONNECTED:\r\nreset_timer(dev);\r\ndev->trans_start = jiffies;\r\nnetif_stop_queue(dev);\r\nif (cycx_x25_chan_send(dev, skb))\r\nreturn NETDEV_TX_BUSY;\r\nbreak;\r\ndefault:\r\n++chan->ifstats.tx_dropped;\r\n++card->wandev.stats.tx_dropped;\r\n}\r\n} else {\r\nswitch (skb->data[0]) {\r\ncase X25_IFACE_DATA:\r\nbreak;\r\ncase X25_IFACE_CONNECT:\r\ncycx_x25_chan_connect(dev);\r\ngoto free_packet;\r\ncase X25_IFACE_DISCONNECT:\r\ncycx_x25_chan_disconnect(dev);\r\ngoto free_packet;\r\ndefault:\r\npr_info("%s: unknown %d x25-iface request on %s!\n",\r\ncard->devname, skb->data[0], dev->name);\r\n++chan->ifstats.tx_errors;\r\ngoto free_packet;\r\n}\r\nskb_pull(skb, 1);\r\nreset_timer(dev);\r\ndev->trans_start = jiffies;\r\nnetif_stop_queue(dev);\r\nif (cycx_x25_chan_send(dev, skb)) {\r\nskb_push(skb, 1);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\n}\r\nfree_packet:\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *cycx_netdevice_get_stats(struct net_device *dev)\r\n{\r\nstruct cycx_x25_channel *chan = netdev_priv(dev);\r\nreturn chan ? &chan->ifstats : NULL;\r\n}\r\nstatic void cycx_x25_irq_handler(struct cycx_device *card)\r\n{\r\nstruct cycx_x25_cmd cmd;\r\nu16 z = 0;\r\ncard->in_isr = 1;\r\ncard->buff_int_mode_unbusy = 0;\r\ncycx_peek(&card->hw, X25_RXMBOX_OFFS, &cmd, sizeof(cmd));\r\nswitch (cmd.command) {\r\ncase X25_DATA_INDICATION:\r\ncycx_x25_irq_rx(card, &cmd);\r\nbreak;\r\ncase X25_ACK_FROM_VC:\r\ncycx_x25_irq_tx(card, &cmd);\r\nbreak;\r\ncase X25_LOG:\r\ncycx_x25_irq_log(card, &cmd);\r\nbreak;\r\ncase X25_STATISTIC:\r\ncycx_x25_irq_stat(card, &cmd);\r\nbreak;\r\ncase X25_CONNECT_CONFIRM:\r\ncycx_x25_irq_connect_confirm(card, &cmd);\r\nbreak;\r\ncase X25_CONNECT_INDICATION:\r\ncycx_x25_irq_connect(card, &cmd);\r\nbreak;\r\ncase X25_DISCONNECT_INDICATION:\r\ncycx_x25_irq_disconnect(card, &cmd);\r\nbreak;\r\ncase X25_DISCONNECT_CONFIRM:\r\ncycx_x25_irq_disconnect_confirm(card, &cmd);\r\nbreak;\r\ncase X25_LINE_ON:\r\ncycx_set_state(card, WAN_CONNECTED);\r\nbreak;\r\ncase X25_LINE_OFF:\r\ncycx_set_state(card, WAN_DISCONNECTED);\r\nbreak;\r\ndefault:\r\ncycx_x25_irq_spurious(card, &cmd);\r\nbreak;\r\n}\r\ncycx_poke(&card->hw, 0, &z, sizeof(z));\r\ncycx_poke(&card->hw, X25_RXMBOX_OFFS, &z, sizeof(z));\r\ncard->in_isr = 0;\r\n}\r\nstatic void cycx_x25_irq_tx(struct cycx_device *card, struct cycx_x25_cmd *cmd)\r\n{\r\nstruct net_device *dev;\r\nstruct wan_device *wandev = &card->wandev;\r\nu8 lcn;\r\ncycx_peek(&card->hw, cmd->buf, &lcn, sizeof(lcn));\r\ndev = cycx_x25_get_dev_by_lcn(wandev, lcn);\r\nif (dev) {\r\ncard->buff_int_mode_unbusy = 1;\r\nnetif_wake_queue(dev);\r\n} else\r\npr_err("%s:ackvc for inexistent lcn %d\n", card->devname, lcn);\r\n}\r\nstatic void cycx_x25_irq_rx(struct cycx_device *card, struct cycx_x25_cmd *cmd)\r\n{\r\nstruct wan_device *wandev = &card->wandev;\r\nstruct net_device *dev;\r\nstruct cycx_x25_channel *chan;\r\nstruct sk_buff *skb;\r\nu8 bitm, lcn;\r\nint pktlen = cmd->len - 5;\r\ncycx_peek(&card->hw, cmd->buf, &lcn, sizeof(lcn));\r\ncycx_peek(&card->hw, cmd->buf + 4, &bitm, sizeof(bitm));\r\nbitm &= 0x10;\r\ndev = cycx_x25_get_dev_by_lcn(wandev, lcn);\r\nif (!dev) {\r\npr_info("%s: receiving on orphaned LCN %d!\n",\r\ncard->devname, lcn);\r\nreturn;\r\n}\r\nchan = netdev_priv(dev);\r\nreset_timer(dev);\r\nif (chan->drop_sequence) {\r\nif (!bitm)\r\nchan->drop_sequence = 0;\r\nelse\r\nreturn;\r\n}\r\nif ((skb = chan->rx_skb) == NULL) {\r\nint bufsize = bitm ? dev->mtu : pktlen;\r\nif ((skb = dev_alloc_skb((chan->protocol == ETH_P_X25 ? 1 : 0) +\r\nbufsize +\r\ndev->hard_header_len)) == NULL) {\r\npr_info("%s: no socket buffers available!\n",\r\ncard->devname);\r\nchan->drop_sequence = 1;\r\n++chan->ifstats.rx_dropped;\r\nreturn;\r\n}\r\nif (chan->protocol == ETH_P_X25)\r\nskb_put(skb, 1);\r\nskb->dev = dev;\r\nskb->protocol = htons(chan->protocol);\r\nchan->rx_skb = skb;\r\n}\r\nif (skb_tailroom(skb) < pktlen) {\r\ndev_kfree_skb_irq(skb);\r\nchan->rx_skb = NULL;\r\nif (bitm)\r\nchan->drop_sequence = 1;\r\npr_info("%s: unexpectedly long packet sequence on interface %s!\n",\r\ncard->devname, dev->name);\r\n++chan->ifstats.rx_length_errors;\r\nreturn;\r\n}\r\ncycx_peek(&card->hw, cmd->buf + 5, skb_put(skb, pktlen), pktlen);\r\nif (bitm)\r\nreturn;\r\nchan->rx_skb = NULL;\r\n++chan->ifstats.rx_packets;\r\nchan->ifstats.rx_bytes += pktlen;\r\nskb_reset_mac_header(skb);\r\nnetif_rx(skb);\r\n}\r\nstatic void cycx_x25_irq_connect(struct cycx_device *card,\r\nstruct cycx_x25_cmd *cmd)\r\n{\r\nstruct wan_device *wandev = &card->wandev;\r\nstruct net_device *dev = NULL;\r\nstruct cycx_x25_channel *chan;\r\nu8 d[32],\r\nloc[24],\r\nrem[24];\r\nu8 lcn, sizeloc, sizerem;\r\ncycx_peek(&card->hw, cmd->buf, &lcn, sizeof(lcn));\r\ncycx_peek(&card->hw, cmd->buf + 5, &sizeloc, sizeof(sizeloc));\r\ncycx_peek(&card->hw, cmd->buf + 6, d, cmd->len - 6);\r\nsizerem = sizeloc >> 4;\r\nsizeloc &= 0x0F;\r\nloc[0] = rem[0] = '\0';\r\nif (sizeloc)\r\nnibble_to_byte(d, loc, sizeloc, 0);\r\nif (sizerem)\r\nnibble_to_byte(d + (sizeloc >> 1), rem, sizerem, sizeloc & 1);\r\ndprintk(1, KERN_INFO "%s:lcn=%d, local=%s, remote=%s\n",\r\n__func__, lcn, loc, rem);\r\ndev = cycx_x25_get_dev_by_dte_addr(wandev, rem);\r\nif (!dev) {\r\npr_info("%s: connect not expected: remote %s!\n",\r\ncard->devname, rem);\r\nreturn;\r\n}\r\nchan = netdev_priv(dev);\r\nchan->lcn = lcn;\r\ncycx_x25_connect_response(card, chan);\r\ncycx_x25_set_chan_state(dev, WAN_CONNECTED);\r\n}\r\nstatic void cycx_x25_irq_connect_confirm(struct cycx_device *card,\r\nstruct cycx_x25_cmd *cmd)\r\n{\r\nstruct wan_device *wandev = &card->wandev;\r\nstruct net_device *dev;\r\nstruct cycx_x25_channel *chan;\r\nu8 lcn, key;\r\ncycx_peek(&card->hw, cmd->buf, &lcn, sizeof(lcn));\r\ncycx_peek(&card->hw, cmd->buf + 1, &key, sizeof(key));\r\ndprintk(1, KERN_INFO "%s: %s:lcn=%d, key=%d\n",\r\ncard->devname, __func__, lcn, key);\r\ndev = cycx_x25_get_dev_by_lcn(wandev, -key);\r\nif (!dev) {\r\nclear_bit(--key, (void*)&card->u.x.connection_keys);\r\npr_info("%s: connect confirm not expected: lcn %d, key=%d!\n",\r\ncard->devname, lcn, key);\r\nreturn;\r\n}\r\nclear_bit(--key, (void*)&card->u.x.connection_keys);\r\nchan = netdev_priv(dev);\r\nchan->lcn = lcn;\r\ncycx_x25_set_chan_state(dev, WAN_CONNECTED);\r\n}\r\nstatic void cycx_x25_irq_disconnect_confirm(struct cycx_device *card,\r\nstruct cycx_x25_cmd *cmd)\r\n{\r\nstruct wan_device *wandev = &card->wandev;\r\nstruct net_device *dev;\r\nu8 lcn;\r\ncycx_peek(&card->hw, cmd->buf, &lcn, sizeof(lcn));\r\ndprintk(1, KERN_INFO "%s: %s:lcn=%d\n",\r\ncard->devname, __func__, lcn);\r\ndev = cycx_x25_get_dev_by_lcn(wandev, lcn);\r\nif (!dev) {\r\npr_info("%s:disconnect confirm not expected!:lcn %d\n",\r\ncard->devname, lcn);\r\nreturn;\r\n}\r\ncycx_x25_set_chan_state(dev, WAN_DISCONNECTED);\r\n}\r\nstatic void cycx_x25_irq_disconnect(struct cycx_device *card,\r\nstruct cycx_x25_cmd *cmd)\r\n{\r\nstruct wan_device *wandev = &card->wandev;\r\nstruct net_device *dev;\r\nu8 lcn;\r\ncycx_peek(&card->hw, cmd->buf, &lcn, sizeof(lcn));\r\ndprintk(1, KERN_INFO "%s:lcn=%d\n", __func__, lcn);\r\ndev = cycx_x25_get_dev_by_lcn(wandev, lcn);\r\nif (dev) {\r\nstruct cycx_x25_channel *chan = netdev_priv(dev);\r\ncycx_x25_disconnect_response(card, chan->link, lcn);\r\ncycx_x25_set_chan_state(dev, WAN_DISCONNECTED);\r\n} else\r\ncycx_x25_disconnect_response(card, 0, lcn);\r\n}\r\nstatic void cycx_x25_irq_log(struct cycx_device *card, struct cycx_x25_cmd *cmd)\r\n{\r\n#if CYCLOMX_X25_DEBUG\r\nchar bf[20];\r\nu16 size, toread, link, msg_code;\r\nu8 code, routine;\r\ncycx_peek(&card->hw, cmd->buf, &msg_code, sizeof(msg_code));\r\ncycx_peek(&card->hw, cmd->buf + 2, &link, sizeof(link));\r\ncycx_peek(&card->hw, cmd->buf + 4, &size, sizeof(size));\r\ntoread = size < 20 ? size : 20;\r\ncycx_peek(&card->hw, cmd->buf + 10, &bf, toread);\r\ncycx_peek(&card->hw, cmd->buf + 10 + toread, &code, 1);\r\ncycx_peek(&card->hw, cmd->buf + 10 + toread + 1, &routine, 1);\r\npr_info("cycx_x25_irq_handler: X25_LOG (0x4500) indic.:\n");\r\npr_info("cmd->buf=0x%X\n", cmd->buf);\r\npr_info("Log message code=0x%X\n", msg_code);\r\npr_info("Link=%d\n", link);\r\npr_info("log code=0x%X\n", code);\r\npr_info("log routine=0x%X\n", routine);\r\npr_info("Message size=%d\n", size);\r\nhex_dump("Message", bf, toread);\r\n#endif\r\n}\r\nstatic void cycx_x25_irq_stat(struct cycx_device *card,\r\nstruct cycx_x25_cmd *cmd)\r\n{\r\ncycx_peek(&card->hw, cmd->buf, &card->u.x.stats,\r\nsizeof(card->u.x.stats));\r\nhex_dump("cycx_x25_irq_stat", (unsigned char*)&card->u.x.stats,\r\nsizeof(card->u.x.stats));\r\ncycx_x25_dump_stats(&card->u.x.stats);\r\nwake_up_interruptible(&card->wait_stats);\r\n}\r\nstatic void cycx_x25_irq_spurious(struct cycx_device *card,\r\nstruct cycx_x25_cmd *cmd)\r\n{\r\npr_info("%s: spurious interrupt (0x%X)!\n",\r\ncard->devname, cmd->command);\r\n}\r\nstatic void hex_dump(char *msg, unsigned char *p, int len)\r\n{\r\nprint_hex_dump(KERN_INFO, msg, DUMP_PREFIX_OFFSET, 16, 1,\r\np, len, true);\r\n}\r\nstatic int x25_exec(struct cycx_device *card, int command, int link,\r\nvoid *d1, int len1, void *d2, int len2)\r\n{\r\nstruct cycx_x25_cmd c;\r\nunsigned long flags;\r\nu32 addr = 0x1200 + 0x2E0 * link + 0x1E2;\r\nu8 retry = CYCX_X25_MAX_CMD_RETRY;\r\nint err = 0;\r\nc.command = command;\r\nc.link = link;\r\nc.len = len1 + len2;\r\nspin_lock_irqsave(&card->u.x.lock, flags);\r\ncycx_poke(&card->hw, X25_MBOX_OFFS, &c, sizeof(c) - sizeof(c.buf));\r\nif (d1) {\r\ncycx_poke(&card->hw, addr, d1, len1);\r\nif (d2) {\r\nif (len2 > 254) {\r\nu32 addr1 = 0xA00 + 0x400 * link;\r\ncycx_poke(&card->hw, addr + len1, d2, 249);\r\ncycx_poke(&card->hw, addr1, ((u8*)d2) + 249,\r\nlen2 - 249);\r\n} else\r\ncycx_poke(&card->hw, addr + len1, d2, len2);\r\n}\r\n}\r\ncycx_intr(&card->hw);\r\ndo {\r\nerr = cycx_exec(card->mbox);\r\n} while (retry-- && err);\r\nspin_unlock_irqrestore(&card->u.x.lock, flags);\r\nreturn err;\r\n}\r\nstatic int cycx_x25_configure(struct cycx_device *card,\r\nstruct cycx_x25_config *conf)\r\n{\r\nstruct {\r\nu16 nlinks;\r\nstruct cycx_x25_config conf[2];\r\n} x25_cmd_conf;\r\nmemset(&x25_cmd_conf, 0, sizeof(x25_cmd_conf));\r\nx25_cmd_conf.nlinks = 2;\r\nx25_cmd_conf.conf[0] = *conf;\r\nx25_cmd_conf.conf[1] = *conf;\r\nx25_cmd_conf.conf[1].link = 1;\r\nx25_cmd_conf.conf[1].speed = 5;\r\nx25_cmd_conf.conf[1].clock = 8;\r\nx25_cmd_conf.conf[1].flags = 0;\r\ncycx_x25_dump_config(&x25_cmd_conf.conf[0]);\r\ncycx_x25_dump_config(&x25_cmd_conf.conf[1]);\r\nreturn x25_exec(card, X25_CONFIG, 0,\r\n&x25_cmd_conf, sizeof(x25_cmd_conf), NULL, 0);\r\n}\r\nstatic int cycx_x25_get_stats(struct cycx_device *card)\r\n{\r\nint err = x25_exec(card, X25_STATISTIC, 0, NULL, 20, NULL, 0);\r\nif (err)\r\nreturn err;\r\ninterruptible_sleep_on(&card->wait_stats);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\ncard->wandev.stats.rx_packets = card->u.x.stats.n2_rx_frames;\r\ncard->wandev.stats.rx_over_errors = card->u.x.stats.rx_over_errors;\r\ncard->wandev.stats.rx_crc_errors = card->u.x.stats.rx_crc_errors;\r\ncard->wandev.stats.rx_length_errors = 0;\r\ncard->wandev.stats.rx_frame_errors = 0;\r\ncard->wandev.stats.rx_missed_errors = card->u.x.stats.rx_aborts;\r\ncard->wandev.stats.rx_dropped = 0;\r\ncard->wandev.stats.rx_errors = 0;\r\ncard->wandev.stats.tx_packets = card->u.x.stats.n2_tx_frames;\r\ncard->wandev.stats.tx_aborted_errors = card->u.x.stats.tx_aborts;\r\ncard->wandev.stats.tx_dropped = 0;\r\ncard->wandev.stats.collisions = 0;\r\ncard->wandev.stats.tx_errors = 0;\r\ncycx_x25_dump_devs(&card->wandev);\r\nreturn 0;\r\n}\r\nstatic int byte_to_nibble(u8 *s, u8 *d, char *nibble)\r\n{\r\nint i = 0;\r\nif (*nibble && *s) {\r\nd[i] |= *s++ - '0';\r\n*nibble = 0;\r\n++i;\r\n}\r\nwhile (*s) {\r\nd[i] = (*s - '0') << 4;\r\nif (*(s + 1))\r\nd[i] |= *(s + 1) - '0';\r\nelse {\r\n*nibble = 1;\r\nbreak;\r\n}\r\n++i;\r\ns += 2;\r\n}\r\nreturn i;\r\n}\r\nstatic void nibble_to_byte(u8 *s, u8 *d, u8 len, u8 nibble)\r\n{\r\nif (nibble) {\r\n*d++ = '0' + (*s++ & 0x0F);\r\n--len;\r\n}\r\nwhile (len) {\r\n*d++ = '0' + (*s >> 4);\r\nif (--len) {\r\n*d++ = '0' + (*s & 0x0F);\r\n--len;\r\n} else break;\r\n++s;\r\n}\r\n*d = '\0';\r\n}\r\nstatic int x25_place_call(struct cycx_device *card,\r\nstruct cycx_x25_channel *chan)\r\n{\r\nint err = 0,\r\nlen;\r\nchar d[64],\r\nnibble = 0,\r\nmylen = chan->local_addr ? strlen(chan->local_addr) : 0,\r\nremotelen = strlen(chan->addr);\r\nu8 key;\r\nif (card->u.x.connection_keys == ~0U) {\r\npr_info("%s: too many simultaneous connection requests!\n",\r\ncard->devname);\r\nreturn -EAGAIN;\r\n}\r\nkey = ffz(card->u.x.connection_keys);\r\nset_bit(key, (void*)&card->u.x.connection_keys);\r\n++key;\r\ndprintk(1, KERN_INFO "%s:x25_place_call:key=%d\n", card->devname, key);\r\nmemset(d, 0, sizeof(d));\r\nd[1] = key;\r\nd[2] = 0x10;\r\nd[4] = 0x0B;\r\nlen = byte_to_nibble(chan->addr, d + 6, &nibble);\r\nif (chan->local_addr)\r\nlen += byte_to_nibble(chan->local_addr, d + 6 + len, &nibble);\r\nif (nibble)\r\n++len;\r\nd[5] = mylen << 4 | remotelen;\r\nd[6 + len + 1] = 0xCC;\r\nif ((err = x25_exec(card, X25_CONNECT_REQUEST, chan->link,\r\n&d, 7 + len + 1, NULL, 0)) != 0)\r\nclear_bit(--key, (void*)&card->u.x.connection_keys);\r\nelse\r\nchan->lcn = -key;\r\nreturn err;\r\n}\r\nstatic int cycx_x25_connect_response(struct cycx_device *card,\r\nstruct cycx_x25_channel *chan)\r\n{\r\nu8 d[8];\r\nmemset(d, 0, sizeof(d));\r\nd[0] = d[3] = chan->lcn;\r\nd[2] = 0x10;\r\nd[4] = 0x0F;\r\nd[7] = 0xCC;\r\nreturn x25_exec(card, X25_CONNECT_RESPONSE, chan->link, &d, 8, NULL, 0);\r\n}\r\nstatic int cycx_x25_disconnect_response(struct cycx_device *card, u8 link,\r\nu8 lcn)\r\n{\r\nchar d[5];\r\nmemset(d, 0, sizeof(d));\r\nd[0] = d[3] = lcn;\r\nd[2] = 0x10;\r\nd[4] = 0x17;\r\nreturn x25_exec(card, X25_DISCONNECT_RESPONSE, link, &d, 5, NULL, 0);\r\n}\r\nstatic int x25_clear_call(struct cycx_device *card, u8 link, u8 lcn, u8 cause,\r\nu8 diagn)\r\n{\r\nu8 d[7];\r\nmemset(d, 0, sizeof(d));\r\nd[0] = d[3] = lcn;\r\nd[2] = 0x10;\r\nd[4] = 0x13;\r\nd[5] = cause;\r\nd[6] = diagn;\r\nreturn x25_exec(card, X25_DISCONNECT_REQUEST, link, d, 7, NULL, 0);\r\n}\r\nstatic int cycx_x25_send(struct cycx_device *card, u8 link, u8 lcn, u8 bitm,\r\nint len, void *buf)\r\n{\r\nu8 d[] = "?\xFF\x10??";\r\nd[0] = d[3] = lcn;\r\nd[4] = bitm;\r\nreturn x25_exec(card, X25_DATA_REQUEST, link, &d, 5, buf, len);\r\n}\r\nstatic struct net_device *cycx_x25_get_dev_by_lcn(struct wan_device *wandev,\r\ns16 lcn)\r\n{\r\nstruct net_device *dev = wandev->dev;\r\nstruct cycx_x25_channel *chan;\r\nwhile (dev) {\r\nchan = netdev_priv(dev);\r\nif (chan->lcn == lcn)\r\nbreak;\r\ndev = chan->slave;\r\n}\r\nreturn dev;\r\n}\r\nstatic struct net_device *\r\ncycx_x25_get_dev_by_dte_addr(struct wan_device *wandev, char *dte)\r\n{\r\nstruct net_device *dev = wandev->dev;\r\nstruct cycx_x25_channel *chan;\r\nwhile (dev) {\r\nchan = netdev_priv(dev);\r\nif (!strcmp(chan->addr, dte))\r\nbreak;\r\ndev = chan->slave;\r\n}\r\nreturn dev;\r\n}\r\nstatic int cycx_x25_chan_connect(struct net_device *dev)\r\n{\r\nstruct cycx_x25_channel *chan = netdev_priv(dev);\r\nstruct cycx_device *card = chan->card;\r\nif (chan->svc) {\r\nif (!chan->addr[0])\r\nreturn -EINVAL;\r\ndprintk(1, KERN_INFO "%s: placing X.25 call to %s...\n",\r\ncard->devname, chan->addr);\r\nif (x25_place_call(card, chan))\r\nreturn -EIO;\r\ncycx_x25_set_chan_state(dev, WAN_CONNECTING);\r\nreturn 1;\r\n} else\r\ncycx_x25_set_chan_state(dev, WAN_CONNECTED);\r\nreturn 0;\r\n}\r\nstatic void cycx_x25_chan_disconnect(struct net_device *dev)\r\n{\r\nstruct cycx_x25_channel *chan = netdev_priv(dev);\r\nif (chan->svc) {\r\nx25_clear_call(chan->card, chan->link, chan->lcn, 0, 0);\r\ncycx_x25_set_chan_state(dev, WAN_DISCONNECTING);\r\n} else\r\ncycx_x25_set_chan_state(dev, WAN_DISCONNECTED);\r\n}\r\nstatic void cycx_x25_chan_timer(unsigned long d)\r\n{\r\nstruct net_device *dev = (struct net_device *)d;\r\nstruct cycx_x25_channel *chan = netdev_priv(dev);\r\nif (chan->state == WAN_CONNECTED)\r\ncycx_x25_chan_disconnect(dev);\r\nelse\r\npr_err("%s: %s for svc (%s) not connected!\n",\r\nchan->card->devname, __func__, dev->name);\r\n}\r\nstatic void cycx_x25_set_chan_state(struct net_device *dev, u8 state)\r\n{\r\nstruct cycx_x25_channel *chan = netdev_priv(dev);\r\nstruct cycx_device *card = chan->card;\r\nunsigned long flags;\r\nchar *string_state = NULL;\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (chan->state != state) {\r\nif (chan->svc && chan->state == WAN_CONNECTED)\r\ndel_timer(&chan->timer);\r\nswitch (state) {\r\ncase WAN_CONNECTED:\r\nstring_state = "connected!";\r\n*(__be16*)dev->dev_addr = htons(chan->lcn);\r\nnetif_wake_queue(dev);\r\nreset_timer(dev);\r\nif (chan->protocol == ETH_P_X25)\r\ncycx_x25_chan_send_event(dev,\r\nX25_IFACE_CONNECT);\r\nbreak;\r\ncase WAN_CONNECTING:\r\nstring_state = "connecting...";\r\nbreak;\r\ncase WAN_DISCONNECTING:\r\nstring_state = "disconnecting...";\r\nbreak;\r\ncase WAN_DISCONNECTED:\r\nstring_state = "disconnected!";\r\nif (chan->svc) {\r\n*(unsigned short*)dev->dev_addr = 0;\r\nchan->lcn = 0;\r\n}\r\nif (chan->protocol == ETH_P_X25)\r\ncycx_x25_chan_send_event(dev,\r\nX25_IFACE_DISCONNECT);\r\nnetif_wake_queue(dev);\r\nbreak;\r\n}\r\npr_info("%s: interface %s %s\n",\r\ncard->devname, dev->name, string_state);\r\nchan->state = state;\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nstatic int cycx_x25_chan_send(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct cycx_x25_channel *chan = netdev_priv(dev);\r\nstruct cycx_device *card = chan->card;\r\nint bitm = 0;\r\nunsigned len = skb->len;\r\nif (skb->len > card->wandev.mtu) {\r\nlen = card->wandev.mtu;\r\nbitm = 0x10;\r\n}\r\nif (cycx_x25_send(card, chan->link, chan->lcn, bitm, len, skb->data))\r\nreturn 1;\r\nif (bitm) {\r\nskb_pull(skb, len);\r\nreturn 1;\r\n}\r\n++chan->ifstats.tx_packets;\r\nchan->ifstats.tx_bytes += len;\r\nreturn 0;\r\n}\r\nstatic void cycx_x25_chan_send_event(struct net_device *dev, u8 event)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *ptr;\r\nif ((skb = dev_alloc_skb(1)) == NULL) {\r\npr_err("%s: out of memory\n", __func__);\r\nreturn;\r\n}\r\nptr = skb_put(skb, 1);\r\n*ptr = event;\r\nskb->protocol = x25_type_trans(skb, dev);\r\nnetif_rx(skb);\r\n}\r\nstatic u8 bps_to_speed_code(u32 bps)\r\n{\r\nu8 number = 0;\r\nif (bps >= 512000) number = 8;\r\nelse if (bps >= 256000) number = 7;\r\nelse if (bps >= 64000) number = 6;\r\nelse if (bps >= 38400) number = 5;\r\nelse if (bps >= 19200) number = 4;\r\nelse if (bps >= 9600) number = 3;\r\nelse if (bps >= 4800) number = 2;\r\nelse if (bps >= 2400) number = 1;\r\nreturn number;\r\n}\r\nstatic u8 cycx_log2(u32 n)\r\n{\r\nu8 log = 0;\r\nif (!n)\r\nreturn 0;\r\nwhile (n > 1) {\r\nn >>= 1;\r\n++log;\r\n}\r\nreturn log;\r\n}\r\nstatic unsigned dec_to_uint(u8 *str, int len)\r\n{\r\nunsigned val = 0;\r\nif (!len)\r\nlen = strlen(str);\r\nfor (; len && isdigit(*str); ++str, --len)\r\nval = (val * 10) + (*str - (unsigned) '0');\r\nreturn val;\r\n}\r\nstatic void reset_timer(struct net_device *dev)\r\n{\r\nstruct cycx_x25_channel *chan = netdev_priv(dev);\r\nif (chan->svc)\r\nmod_timer(&chan->timer, jiffies+chan->idle_tmout*HZ);\r\n}\r\nstatic void cycx_x25_dump_config(struct cycx_x25_config *conf)\r\n{\r\npr_info("X.25 configuration\n");\r\npr_info("-----------------\n");\r\npr_info("link number=%d\n", conf->link);\r\npr_info("line speed=%d\n", conf->speed);\r\npr_info("clock=%sternal\n", conf->clock == 8 ? "Ex" : "In");\r\npr_info("# level 2 retransm.=%d\n", conf->n2);\r\npr_info("level 2 window=%d\n", conf->n2win);\r\npr_info("level 3 window=%d\n", conf->n3win);\r\npr_info("# logical channels=%d\n", conf->nvc);\r\npr_info("level 3 pkt len=%d\n", conf->pktlen);\r\npr_info("my address=%d\n", conf->locaddr);\r\npr_info("remote address=%d\n", conf->remaddr);\r\npr_info("t1=%d seconds\n", conf->t1);\r\npr_info("t2=%d seconds\n", conf->t2);\r\npr_info("t21=%d seconds\n", conf->t21);\r\npr_info("# PVCs=%d\n", conf->npvc);\r\npr_info("t23=%d seconds\n", conf->t23);\r\npr_info("flags=0x%x\n", conf->flags);\r\n}\r\nstatic void cycx_x25_dump_stats(struct cycx_x25_stats *stats)\r\n{\r\npr_info("X.25 statistics\n");\r\npr_info("--------------\n");\r\npr_info("rx_crc_errors=%d\n", stats->rx_crc_errors);\r\npr_info("rx_over_errors=%d\n", stats->rx_over_errors);\r\npr_info("n2_tx_frames=%d\n", stats->n2_tx_frames);\r\npr_info("n2_rx_frames=%d\n", stats->n2_rx_frames);\r\npr_info("tx_timeouts=%d\n", stats->tx_timeouts);\r\npr_info("rx_timeouts=%d\n", stats->rx_timeouts);\r\npr_info("n3_tx_packets=%d\n", stats->n3_tx_packets);\r\npr_info("n3_rx_packets=%d\n", stats->n3_rx_packets);\r\npr_info("tx_aborts=%d\n", stats->tx_aborts);\r\npr_info("rx_aborts=%d\n", stats->rx_aborts);\r\n}\r\nstatic void cycx_x25_dump_devs(struct wan_device *wandev)\r\n{\r\nstruct net_device *dev = wandev->dev;\r\npr_info("X.25 dev states\n");\r\npr_info("name: addr: txoff: protocol:\n");\r\npr_info("---------------------------------------\n");\r\nwhile(dev) {\r\nstruct cycx_x25_channel *chan = netdev_priv(dev);\r\npr_info("%-5.5s %-15.15s %d ETH_P_%s\n",\r\nchan->name, chan->addr, netif_queue_stopped(dev),\r\nchan->protocol == ETH_P_IP ? "IP" : "X25");\r\ndev = chan->slave;\r\n}\r\n}
