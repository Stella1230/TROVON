static int srm_env_proc_show(struct seq_file *m, void *v)\r\n{\r\nunsigned long ret;\r\nsrm_env_t *entry;\r\nchar *page;\r\nentry = m->private;\r\npage = (char *)__get_free_page(GFP_USER);\r\nif (!page)\r\nreturn -ENOMEM;\r\nret = callback_getenv(entry->id, page, PAGE_SIZE);\r\nif ((ret >> 61) == 0) {\r\nseq_write(m, page, ret);\r\nret = 0;\r\n} else\r\nret = -EFAULT;\r\nfree_page((unsigned long)page);\r\nreturn ret;\r\n}\r\nstatic int srm_env_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, srm_env_proc_show, PDE(inode)->data);\r\n}\r\nstatic ssize_t srm_env_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nint res;\r\nsrm_env_t *entry = PDE(file->f_path.dentry->d_inode)->data;\r\nchar *buf = (char *) __get_free_page(GFP_USER);\r\nunsigned long ret1, ret2;\r\nif (!buf)\r\nreturn -ENOMEM;\r\nres = -EINVAL;\r\nif (count >= PAGE_SIZE)\r\ngoto out;\r\nres = -EFAULT;\r\nif (copy_from_user(buf, buffer, count))\r\ngoto out;\r\nbuf[count] = '\0';\r\nret1 = callback_setenv(entry->id, buf, count);\r\nif ((ret1 >> 61) == 0) {\r\ndo\r\nret2 = callback_save_env();\r\nwhile((ret2 >> 61) == 1);\r\nres = (int) ret1;\r\n}\r\nout:\r\nfree_page((unsigned long)buf);\r\nreturn res;\r\n}\r\nstatic void\r\nsrm_env_cleanup(void)\r\n{\r\nsrm_env_t *entry;\r\nunsigned long var_num;\r\nif (base_dir) {\r\nif (named_dir) {\r\nentry = srm_named_entries;\r\nwhile (entry->name != NULL && entry->id != 0) {\r\nif (entry->proc_entry) {\r\nremove_proc_entry(entry->name,\r\nnamed_dir);\r\nentry->proc_entry = NULL;\r\n}\r\nentry++;\r\n}\r\nremove_proc_entry(NAMED_DIR, base_dir);\r\n}\r\nif (numbered_dir) {\r\nfor (var_num = 0; var_num <= 255; var_num++) {\r\nentry = &srm_numbered_entries[var_num];\r\nif (entry->proc_entry) {\r\nremove_proc_entry(entry->name,\r\nnumbered_dir);\r\nentry->proc_entry = NULL;\r\nentry->name = NULL;\r\n}\r\n}\r\nremove_proc_entry(NUMBERED_DIR, base_dir);\r\n}\r\nremove_proc_entry(BASE_DIR, NULL);\r\n}\r\nreturn;\r\n}\r\nstatic int __init\r\nsrm_env_init(void)\r\n{\r\nsrm_env_t *entry;\r\nunsigned long var_num;\r\nif (!alpha_using_srm) {\r\nprintk(KERN_INFO "%s: This Alpha system doesn't "\r\n"know about SRM (or you've booted "\r\n"SRM->MILO->Linux, which gets "\r\n"misdetected)...\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nfor (var_num = 0; var_num <= 255; var_num++)\r\nsprintf(number[var_num], "%ld", var_num);\r\nbase_dir = proc_mkdir(BASE_DIR, NULL);\r\nif (!base_dir) {\r\nprintk(KERN_ERR "Couldn't create base dir /proc/%s\n",\r\nBASE_DIR);\r\ngoto cleanup;\r\n}\r\nnamed_dir = proc_mkdir(NAMED_DIR, base_dir);\r\nif (!named_dir) {\r\nprintk(KERN_ERR "Couldn't create dir /proc/%s/%s\n",\r\nBASE_DIR, NAMED_DIR);\r\ngoto cleanup;\r\n}\r\nnumbered_dir = proc_mkdir(NUMBERED_DIR, base_dir);\r\nif (!numbered_dir) {\r\nprintk(KERN_ERR "Couldn't create dir /proc/%s/%s\n",\r\nBASE_DIR, NUMBERED_DIR);\r\ngoto cleanup;\r\n}\r\nentry = srm_named_entries;\r\nwhile (entry->name && entry->id) {\r\nentry->proc_entry = proc_create_data(entry->name, 0644, named_dir,\r\n&srm_env_proc_fops, entry);\r\nif (!entry->proc_entry)\r\ngoto cleanup;\r\nentry++;\r\n}\r\nfor (var_num = 0; var_num <= 255; var_num++) {\r\nentry = &srm_numbered_entries[var_num];\r\nentry->name = number[var_num];\r\nentry->proc_entry = proc_create_data(entry->name, 0644, numbered_dir,\r\n&srm_env_proc_fops, entry);\r\nif (!entry->proc_entry)\r\ngoto cleanup;\r\nentry->id = var_num;\r\n}\r\nprintk(KERN_INFO "%s: version %s loaded successfully\n", NAME,\r\nVERSION);\r\nreturn 0;\r\ncleanup:\r\nsrm_env_cleanup();\r\nreturn -ENOMEM;\r\n}\r\nstatic void __exit\r\nsrm_env_exit(void)\r\n{\r\nsrm_env_cleanup();\r\nprintk(KERN_INFO "%s: unloaded successfully\n", NAME);\r\nreturn;\r\n}
