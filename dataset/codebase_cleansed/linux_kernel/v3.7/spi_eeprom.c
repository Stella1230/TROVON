int __init spi_eeprom_register(int busid, int chipid, int size)\r\n{\r\nstruct spi_board_info info = {\r\n.modalias = "at25",\r\n.max_speed_hz = 1500000,\r\n.bus_num = busid,\r\n.chip_select = chipid,\r\n};\r\nstruct spi_eeprom *eeprom;\r\neeprom = kzalloc(sizeof(*eeprom), GFP_KERNEL);\r\nif (!eeprom)\r\nreturn -ENOMEM;\r\nstrcpy(eeprom->name, "at250x0");\r\neeprom->byte_len = size;\r\neeprom->page_size = AT250X0_PAGE_SIZE;\r\neeprom->flags = EE_ADDR1;\r\ninfo.platform_data = eeprom;\r\nreturn spi_register_board_info(&info, 1);\r\n}\r\nstatic int __init early_seeprom_probe(struct spi_device *spi)\r\n{\r\nint stat = 0;\r\nu8 cmd[2];\r\nint len = read_param->len;\r\nchar *buf = read_param->buf;\r\nint address = read_param->address;\r\ndev_info(&spi->dev, "spiclk %u KHz.\n",\r\n(spi->max_speed_hz + 500) / 1000);\r\nif (read_param->busid != spi->master->bus_num ||\r\nread_param->chipid != spi->chip_select)\r\nreturn -ENODEV;\r\nwhile (len > 0) {\r\nint c = len < AT250X0_PAGE_SIZE ? len : AT250X0_PAGE_SIZE;\r\ncmd[0] = 0x03;\r\ncmd[1] = address;\r\nstat = spi_write_then_read(spi, cmd, sizeof(cmd), buf, c);\r\nbuf += c;\r\nlen -= c;\r\naddress += c;\r\n}\r\nreturn stat;\r\n}\r\nint __init spi_eeprom_read(int busid, int chipid, int address,\r\nunsigned char *buf, int len)\r\n{\r\nint ret;\r\nstruct read_param param = {\r\n.busid = busid,\r\n.chipid = chipid,\r\n.address = address,\r\n.buf = buf,\r\n.len = len\r\n};\r\nread_param = &param;\r\nret = spi_register_driver(&early_seeprom_driver);\r\nif (!ret)\r\nspi_unregister_driver(&early_seeprom_driver);\r\nreturn ret;\r\n}
