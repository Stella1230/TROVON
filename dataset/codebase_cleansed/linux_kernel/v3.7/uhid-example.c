static int uhid_write(int fd, const struct uhid_event *ev)\r\n{\r\nssize_t ret;\r\nret = write(fd, ev, sizeof(*ev));\r\nif (ret < 0) {\r\nfprintf(stderr, "Cannot write to uhid: %m\n");\r\nreturn -errno;\r\n} else if (ret != sizeof(*ev)) {\r\nfprintf(stderr, "Wrong size written to uhid: %ld != %lu\n",\r\nret, sizeof(ev));\r\nreturn -EFAULT;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic int create(int fd)\r\n{\r\nstruct uhid_event ev;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.type = UHID_CREATE;\r\nstrcpy((char*)ev.u.create.name, "test-uhid-device");\r\nev.u.create.rd_data = rdesc;\r\nev.u.create.rd_size = sizeof(rdesc);\r\nev.u.create.bus = BUS_USB;\r\nev.u.create.vendor = 0x15d9;\r\nev.u.create.product = 0x0a37;\r\nev.u.create.version = 0;\r\nev.u.create.country = 0;\r\nreturn uhid_write(fd, &ev);\r\n}\r\nstatic void destroy(int fd)\r\n{\r\nstruct uhid_event ev;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.type = UHID_DESTROY;\r\nuhid_write(fd, &ev);\r\n}\r\nstatic int event(int fd)\r\n{\r\nstruct uhid_event ev;\r\nssize_t ret;\r\nmemset(&ev, 0, sizeof(ev));\r\nret = read(fd, &ev, sizeof(ev));\r\nif (ret == 0) {\r\nfprintf(stderr, "Read HUP on uhid-cdev\n");\r\nreturn -EFAULT;\r\n} else if (ret < 0) {\r\nfprintf(stderr, "Cannot read uhid-cdev: %m\n");\r\nreturn -errno;\r\n} else if (ret != sizeof(ev)) {\r\nfprintf(stderr, "Invalid size read from uhid-dev: %ld != %lu\n",\r\nret, sizeof(ev));\r\nreturn -EFAULT;\r\n}\r\nswitch (ev.type) {\r\ncase UHID_START:\r\nfprintf(stderr, "UHID_START from uhid-dev\n");\r\nbreak;\r\ncase UHID_STOP:\r\nfprintf(stderr, "UHID_STOP from uhid-dev\n");\r\nbreak;\r\ncase UHID_OPEN:\r\nfprintf(stderr, "UHID_OPEN from uhid-dev\n");\r\nbreak;\r\ncase UHID_CLOSE:\r\nfprintf(stderr, "UHID_CLOSE from uhid-dev\n");\r\nbreak;\r\ncase UHID_OUTPUT:\r\nfprintf(stderr, "UHID_OUTPUT from uhid-dev\n");\r\nbreak;\r\ncase UHID_OUTPUT_EV:\r\nfprintf(stderr, "UHID_OUTPUT_EV from uhid-dev\n");\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "Invalid event from uhid-dev: %u\n", ev.type);\r\n}\r\nreturn 0;\r\n}\r\nstatic int send_event(int fd)\r\n{\r\nstruct uhid_event ev;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.type = UHID_INPUT;\r\nev.u.input.size = 4;\r\nif (btn1_down)\r\nev.u.input.data[0] |= 0x1;\r\nif (btn2_down)\r\nev.u.input.data[0] |= 0x2;\r\nif (btn3_down)\r\nev.u.input.data[0] |= 0x4;\r\nev.u.input.data[1] = abs_hor;\r\nev.u.input.data[2] = abs_ver;\r\nev.u.input.data[3] = wheel;\r\nreturn uhid_write(fd, &ev);\r\n}\r\nstatic int keyboard(int fd)\r\n{\r\nchar buf[128];\r\nssize_t ret, i;\r\nret = read(STDIN_FILENO, buf, sizeof(buf));\r\nif (ret == 0) {\r\nfprintf(stderr, "Read HUP on stdin\n");\r\nreturn -EFAULT;\r\n} else if (ret < 0) {\r\nfprintf(stderr, "Cannot read stdin: %m\n");\r\nreturn -errno;\r\n}\r\nfor (i = 0; i < ret; ++i) {\r\nswitch (buf[i]) {\r\ncase '1':\r\nbtn1_down = !btn1_down;\r\nret = send_event(fd);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase '2':\r\nbtn2_down = !btn2_down;\r\nret = send_event(fd);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase '3':\r\nbtn3_down = !btn3_down;\r\nret = send_event(fd);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase 'a':\r\nabs_hor = -20;\r\nret = send_event(fd);\r\nabs_hor = 0;\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase 'd':\r\nabs_hor = 20;\r\nret = send_event(fd);\r\nabs_hor = 0;\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase 'w':\r\nabs_ver = -20;\r\nret = send_event(fd);\r\nabs_ver = 0;\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase 's':\r\nabs_ver = 20;\r\nret = send_event(fd);\r\nabs_ver = 0;\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase 'r':\r\nwheel = 1;\r\nret = send_event(fd);\r\nwheel = 0;\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase 'f':\r\nwheel = -1;\r\nret = send_event(fd);\r\nwheel = 0;\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase 'q':\r\nreturn -ECANCELED;\r\ndefault:\r\nfprintf(stderr, "Invalid input: %c\n", buf[i]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nint fd;\r\nconst char *path = "/dev/uhid";\r\nstruct pollfd pfds[2];\r\nint ret;\r\nstruct termios state;\r\nret = tcgetattr(STDIN_FILENO, &state);\r\nif (ret) {\r\nfprintf(stderr, "Cannot get tty state\n");\r\n} else {\r\nstate.c_lflag &= ~ICANON;\r\nstate.c_cc[VMIN] = 1;\r\nret = tcsetattr(STDIN_FILENO, TCSANOW, &state);\r\nif (ret)\r\nfprintf(stderr, "Cannot set tty state\n");\r\n}\r\nif (argc >= 2) {\r\nif (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")) {\r\nfprintf(stderr, "Usage: %s [%s]\n", argv[0], path);\r\nreturn EXIT_SUCCESS;\r\n} else {\r\npath = argv[1];\r\n}\r\n}\r\nfprintf(stderr, "Open uhid-cdev %s\n", path);\r\nfd = open(path, O_RDWR | O_CLOEXEC);\r\nif (fd < 0) {\r\nfprintf(stderr, "Cannot open uhid-cdev %s: %m\n", path);\r\nreturn EXIT_FAILURE;\r\n}\r\nfprintf(stderr, "Create uhid device\n");\r\nret = create(fd);\r\nif (ret) {\r\nclose(fd);\r\nreturn EXIT_FAILURE;\r\n}\r\npfds[0].fd = STDIN_FILENO;\r\npfds[0].events = POLLIN;\r\npfds[1].fd = fd;\r\npfds[1].events = POLLIN;\r\nfprintf(stderr, "Press 'q' to quit...\n");\r\nwhile (1) {\r\nret = poll(pfds, 2, -1);\r\nif (ret < 0) {\r\nfprintf(stderr, "Cannot poll for fds: %m\n");\r\nbreak;\r\n}\r\nif (pfds[0].revents & POLLHUP) {\r\nfprintf(stderr, "Received HUP on stdin\n");\r\nbreak;\r\n}\r\nif (pfds[1].revents & POLLHUP) {\r\nfprintf(stderr, "Received HUP on uhid-cdev\n");\r\nbreak;\r\n}\r\nif (pfds[0].revents & POLLIN) {\r\nret = keyboard(fd);\r\nif (ret)\r\nbreak;\r\n}\r\nif (pfds[1].revents & POLLIN) {\r\nret = event(fd);\r\nif (ret)\r\nbreak;\r\n}\r\n}\r\nfprintf(stderr, "Destroy uhid device\n");\r\ndestroy(fd);\r\nreturn EXIT_SUCCESS;\r\n}
