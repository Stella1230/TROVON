static int\r\nnfs4_save_creds(const struct cred **original_creds)\r\n{\r\nstruct cred *new;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nnew->fsuid = 0;\r\nnew->fsgid = 0;\r\n*original_creds = override_creds(new);\r\nput_cred(new);\r\nreturn 0;\r\n}\r\nstatic void\r\nnfs4_reset_creds(const struct cred *original)\r\n{\r\nrevert_creds(original);\r\n}\r\nstatic void\r\nmd5_to_hex(char *out, char *md5)\r\n{\r\nint i;\r\nfor (i=0; i<16; i++) {\r\nunsigned char c = md5[i];\r\n*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);\r\n*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);\r\n}\r\n*out = '\0';\r\n}\r\n__be32\r\nnfs4_make_rec_clidname(char *dname, struct xdr_netobj *clname)\r\n{\r\nstruct xdr_netobj cksum;\r\nstruct hash_desc desc;\r\nstruct scatterlist sg;\r\n__be32 status = nfserr_jukebox;\r\ndprintk("NFSD: nfs4_make_rec_clidname for %.*s\n",\r\nclname->len, clname->data);\r\ndesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\ndesc.tfm = crypto_alloc_hash("md5", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(desc.tfm))\r\ngoto out_no_tfm;\r\ncksum.len = crypto_hash_digestsize(desc.tfm);\r\ncksum.data = kmalloc(cksum.len, GFP_KERNEL);\r\nif (cksum.data == NULL)\r\ngoto out;\r\nsg_init_one(&sg, clname->data, clname->len);\r\nif (crypto_hash_digest(&desc, &sg, sg.length, cksum.data))\r\ngoto out;\r\nmd5_to_hex(dname, cksum.data);\r\nstatus = nfs_ok;\r\nout:\r\nkfree(cksum.data);\r\ncrypto_free_hash(desc.tfm);\r\nout_no_tfm:\r\nreturn status;\r\n}\r\nstatic void\r\nnfsd4_create_clid_dir(struct nfs4_client *clp)\r\n{\r\nconst struct cred *original_cred;\r\nchar *dname = clp->cl_recdir;\r\nstruct dentry *dir, *dentry;\r\nint status;\r\ndprintk("NFSD: nfsd4_create_clid_dir for \"%s\"\n", dname);\r\nif (test_and_set_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn;\r\nif (!rec_file)\r\nreturn;\r\nstatus = nfs4_save_creds(&original_cred);\r\nif (status < 0)\r\nreturn;\r\nstatus = mnt_want_write_file(rec_file);\r\nif (status)\r\nreturn;\r\ndir = rec_file->f_path.dentry;\r\nmutex_lock(&dir->d_inode->i_mutex);\r\ndentry = lookup_one_len(dname, dir, HEXDIR_LEN-1);\r\nif (IS_ERR(dentry)) {\r\nstatus = PTR_ERR(dentry);\r\ngoto out_unlock;\r\n}\r\nif (dentry->d_inode)\r\ngoto out_put;\r\nstatus = vfs_mkdir(dir->d_inode, dentry, S_IRWXU);\r\nout_put:\r\ndput(dentry);\r\nout_unlock:\r\nmutex_unlock(&dir->d_inode->i_mutex);\r\nif (status == 0)\r\nvfs_fsync(rec_file, 0);\r\nelse\r\nprintk(KERN_ERR "NFSD: failed to write recovery record"\r\n" (err %d); please check that %s exists"\r\n" and is writeable", status,\r\nuser_recovery_dirname);\r\nmnt_drop_write_file(rec_file);\r\nnfs4_reset_creds(original_cred);\r\n}\r\nstatic int\r\nnfsd4_build_namelist(void *arg, const char *name, int namlen,\r\nloff_t offset, u64 ino, unsigned int d_type)\r\n{\r\nstruct list_head *names = arg;\r\nstruct name_list *entry;\r\nif (namlen != HEXDIR_LEN - 1)\r\nreturn 0;\r\nentry = kmalloc(sizeof(struct name_list), GFP_KERNEL);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(entry->name, name, HEXDIR_LEN - 1);\r\nentry->name[HEXDIR_LEN - 1] = '\0';\r\nlist_add(&entry->list, names);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfsd4_list_rec_dir(recdir_func *f)\r\n{\r\nconst struct cred *original_cred;\r\nstruct dentry *dir = rec_file->f_path.dentry;\r\nLIST_HEAD(names);\r\nint status;\r\nstatus = nfs4_save_creds(&original_cred);\r\nif (status < 0)\r\nreturn status;\r\nstatus = vfs_llseek(rec_file, 0, SEEK_SET);\r\nif (status < 0) {\r\nnfs4_reset_creds(original_cred);\r\nreturn status;\r\n}\r\nstatus = vfs_readdir(rec_file, nfsd4_build_namelist, &names);\r\nmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\r\nwhile (!list_empty(&names)) {\r\nstruct name_list *entry;\r\nentry = list_entry(names.next, struct name_list, list);\r\nif (!status) {\r\nstruct dentry *dentry;\r\ndentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\r\nif (IS_ERR(dentry)) {\r\nstatus = PTR_ERR(dentry);\r\nbreak;\r\n}\r\nstatus = f(dir, dentry);\r\ndput(dentry);\r\n}\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\nmutex_unlock(&dir->d_inode->i_mutex);\r\nnfs4_reset_creds(original_cred);\r\nreturn status;\r\n}\r\nstatic int\r\nnfsd4_unlink_clid_dir(char *name, int namlen)\r\n{\r\nstruct dentry *dir, *dentry;\r\nint status;\r\ndprintk("NFSD: nfsd4_unlink_clid_dir. name %.*s\n", namlen, name);\r\ndir = rec_file->f_path.dentry;\r\nmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\r\ndentry = lookup_one_len(name, dir, namlen);\r\nif (IS_ERR(dentry)) {\r\nstatus = PTR_ERR(dentry);\r\ngoto out_unlock;\r\n}\r\nstatus = -ENOENT;\r\nif (!dentry->d_inode)\r\ngoto out;\r\nstatus = vfs_rmdir(dir->d_inode, dentry);\r\nout:\r\ndput(dentry);\r\nout_unlock:\r\nmutex_unlock(&dir->d_inode->i_mutex);\r\nreturn status;\r\n}\r\nstatic void\r\nnfsd4_remove_clid_dir(struct nfs4_client *clp)\r\n{\r\nconst struct cred *original_cred;\r\nint status;\r\nif (!rec_file || !test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn;\r\nstatus = mnt_want_write_file(rec_file);\r\nif (status)\r\ngoto out;\r\nclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\r\nstatus = nfs4_save_creds(&original_cred);\r\nif (status < 0)\r\ngoto out;\r\nstatus = nfsd4_unlink_clid_dir(clp->cl_recdir, HEXDIR_LEN-1);\r\nnfs4_reset_creds(original_cred);\r\nif (status == 0)\r\nvfs_fsync(rec_file, 0);\r\nmnt_drop_write_file(rec_file);\r\nout:\r\nif (status)\r\nprintk("NFSD: Failed to remove expired client state directory"\r\n" %.*s\n", HEXDIR_LEN, clp->cl_recdir);\r\n}\r\nstatic int\r\npurge_old(struct dentry *parent, struct dentry *child)\r\n{\r\nint status;\r\nif (nfs4_has_reclaimed_state(child->d_name.name, false))\r\nreturn 0;\r\nstatus = vfs_rmdir(parent->d_inode, child);\r\nif (status)\r\nprintk("failed to remove client recovery directory %s\n",\r\nchild->d_name.name);\r\nreturn 0;\r\n}\r\nstatic void\r\nnfsd4_recdir_purge_old(struct net *net, time_t boot_time)\r\n{\r\nint status;\r\nif (!rec_file)\r\nreturn;\r\nstatus = mnt_want_write_file(rec_file);\r\nif (status)\r\ngoto out;\r\nstatus = nfsd4_list_rec_dir(purge_old);\r\nif (status == 0)\r\nvfs_fsync(rec_file, 0);\r\nmnt_drop_write_file(rec_file);\r\nout:\r\nif (status)\r\nprintk("nfsd4: failed to purge old clients from recovery"\r\n" directory %s\n", rec_file->f_path.dentry->d_name.name);\r\n}\r\nstatic int\r\nload_recdir(struct dentry *parent, struct dentry *child)\r\n{\r\nif (child->d_name.len != HEXDIR_LEN - 1) {\r\nprintk("nfsd4: illegal name %s in recovery directory\n",\r\nchild->d_name.name);\r\nreturn 0;\r\n}\r\nnfs4_client_to_reclaim(child->d_name.name);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfsd4_recdir_load(void) {\r\nint status;\r\nif (!rec_file)\r\nreturn 0;\r\nstatus = nfsd4_list_rec_dir(load_recdir);\r\nif (status)\r\nprintk("nfsd4: failed loading clients from recovery"\r\n" directory %s\n", rec_file->f_path.dentry->d_name.name);\r\nreturn status;\r\n}\r\nstatic int\r\nnfsd4_init_recdir(void)\r\n{\r\nconst struct cred *original_cred;\r\nint status;\r\nprintk("NFSD: Using %s as the NFSv4 state recovery directory\n",\r\nuser_recovery_dirname);\r\nBUG_ON(rec_file);\r\nstatus = nfs4_save_creds(&original_cred);\r\nif (status < 0) {\r\nprintk("NFSD: Unable to change credentials to find recovery"\r\n" directory: error %d\n",\r\nstatus);\r\nreturn status;\r\n}\r\nrec_file = filp_open(user_recovery_dirname, O_RDONLY | O_DIRECTORY, 0);\r\nif (IS_ERR(rec_file)) {\r\nprintk("NFSD: unable to find recovery directory %s\n",\r\nuser_recovery_dirname);\r\nstatus = PTR_ERR(rec_file);\r\nrec_file = NULL;\r\n}\r\nnfs4_reset_creds(original_cred);\r\nreturn status;\r\n}\r\nstatic int\r\nnfsd4_load_reboot_recovery_data(struct net *net)\r\n{\r\nint status;\r\nif (net != &init_net) {\r\nWARN(1, KERN_ERR "NFSD: attempt to initialize legacy client "\r\n"tracking in a container!\n");\r\nreturn -EINVAL;\r\n}\r\nnfs4_lock_state();\r\nstatus = nfsd4_init_recdir();\r\nif (!status)\r\nstatus = nfsd4_recdir_load();\r\nnfs4_unlock_state();\r\nif (status)\r\nprintk(KERN_ERR "NFSD: Failure reading reboot recovery data\n");\r\nreturn status;\r\n}\r\nstatic void\r\nnfsd4_shutdown_recdir(void)\r\n{\r\nif (!rec_file)\r\nreturn;\r\nfput(rec_file);\r\nrec_file = NULL;\r\n}\r\nstatic void\r\nnfsd4_legacy_tracking_exit(struct net *net)\r\n{\r\nnfs4_release_reclaim();\r\nnfsd4_shutdown_recdir();\r\n}\r\nint\r\nnfs4_reset_recoverydir(char *recdir)\r\n{\r\nint status;\r\nstruct path path;\r\nstatus = kern_path(recdir, LOOKUP_FOLLOW, &path);\r\nif (status)\r\nreturn status;\r\nstatus = -ENOTDIR;\r\nif (S_ISDIR(path.dentry->d_inode->i_mode)) {\r\nstrcpy(user_recovery_dirname, recdir);\r\nstatus = 0;\r\n}\r\npath_put(&path);\r\nreturn status;\r\n}\r\nchar *\r\nnfs4_recoverydir(void)\r\n{\r\nreturn user_recovery_dirname;\r\n}\r\nstatic int\r\nnfsd4_check_legacy_client(struct nfs4_client *clp)\r\n{\r\nif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn 0;\r\nif (nfsd4_find_reclaim_client(clp)) {\r\nset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int\r\n__cld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\r\n{\r\nint ret;\r\nstruct rpc_pipe_msg msg;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.data = cmsg;\r\nmsg.len = sizeof(*cmsg);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nret = rpc_queue_upcall(pipe, &msg);\r\nif (ret < 0) {\r\nset_current_state(TASK_RUNNING);\r\ngoto out;\r\n}\r\nschedule();\r\nset_current_state(TASK_RUNNING);\r\nif (msg.errno < 0)\r\nret = msg.errno;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\r\n{\r\nint ret;\r\ndo {\r\nret = __cld_pipe_upcall(pipe, cmsg);\r\n} while (ret == -EAGAIN);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\ncld_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\r\n{\r\nstruct cld_upcall *tmp, *cup;\r\nstruct cld_msg __user *cmsg = (struct cld_msg __user *)src;\r\nuint32_t xid;\r\nstruct nfsd_net *nn = net_generic(filp->f_dentry->d_sb->s_fs_info,\r\nnfsd_net_id);\r\nstruct cld_net *cn = nn->cld_net;\r\nif (mlen != sizeof(*cmsg)) {\r\ndprintk("%s: got %zu bytes, expected %zu\n", __func__, mlen,\r\nsizeof(*cmsg));\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&xid, &cmsg->cm_xid, sizeof(xid)) != 0) {\r\ndprintk("%s: error when copying xid from userspace", __func__);\r\nreturn -EFAULT;\r\n}\r\ncup = NULL;\r\nspin_lock(&cn->cn_lock);\r\nlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\r\nif (get_unaligned(&tmp->cu_msg.cm_xid) == xid) {\r\ncup = tmp;\r\nlist_del_init(&cup->cu_list);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&cn->cn_lock);\r\nif (!cup) {\r\ndprintk("%s: couldn't find upcall -- xid=%u\n", __func__, xid);\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&cup->cu_msg, src, mlen) != 0)\r\nreturn -EFAULT;\r\nwake_up_process(cup->cu_task);\r\nreturn mlen;\r\n}\r\nstatic void\r\ncld_pipe_destroy_msg(struct rpc_pipe_msg *msg)\r\n{\r\nstruct cld_msg *cmsg = msg->data;\r\nstruct cld_upcall *cup = container_of(cmsg, struct cld_upcall,\r\ncu_msg);\r\nif (msg->errno >= 0)\r\nreturn;\r\nwake_up_process(cup->cu_task);\r\n}\r\nstatic struct dentry *\r\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\r\n{\r\nstruct dentry *dir, *dentry;\r\ndir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\r\nif (dir == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\ndentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\r\ndput(dir);\r\nreturn dentry;\r\n}\r\nstatic void\r\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\r\n{\r\nif (pipe->dentry)\r\nrpc_unlink(pipe->dentry);\r\n}\r\nstatic struct dentry *\r\nnfsd4_cld_register_net(struct net *net, struct rpc_pipe *pipe)\r\n{\r\nstruct super_block *sb;\r\nstruct dentry *dentry;\r\nsb = rpc_get_sb_net(net);\r\nif (!sb)\r\nreturn NULL;\r\ndentry = nfsd4_cld_register_sb(sb, pipe);\r\nrpc_put_sb_net(net);\r\nreturn dentry;\r\n}\r\nstatic void\r\nnfsd4_cld_unregister_net(struct net *net, struct rpc_pipe *pipe)\r\n{\r\nstruct super_block *sb;\r\nsb = rpc_get_sb_net(net);\r\nif (sb) {\r\nnfsd4_cld_unregister_sb(pipe);\r\nrpc_put_sb_net(net);\r\n}\r\n}\r\nstatic int\r\nnfsd4_init_cld_pipe(struct net *net)\r\n{\r\nint ret;\r\nstruct dentry *dentry;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nstruct cld_net *cn;\r\nif (nn->cld_net)\r\nreturn 0;\r\ncn = kzalloc(sizeof(*cn), GFP_KERNEL);\r\nif (!cn) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ncn->cn_pipe = rpc_mkpipe_data(&cld_upcall_ops, RPC_PIPE_WAIT_FOR_OPEN);\r\nif (IS_ERR(cn->cn_pipe)) {\r\nret = PTR_ERR(cn->cn_pipe);\r\ngoto err;\r\n}\r\nspin_lock_init(&cn->cn_lock);\r\nINIT_LIST_HEAD(&cn->cn_list);\r\ndentry = nfsd4_cld_register_net(net, cn->cn_pipe);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\ngoto err_destroy_data;\r\n}\r\ncn->cn_pipe->dentry = dentry;\r\nnn->cld_net = cn;\r\nreturn 0;\r\nerr_destroy_data:\r\nrpc_destroy_pipe_data(cn->cn_pipe);\r\nerr:\r\nkfree(cn);\r\nprintk(KERN_ERR "NFSD: unable to create nfsdcld upcall pipe (%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic void\r\nnfsd4_remove_cld_pipe(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nstruct cld_net *cn = nn->cld_net;\r\nnfsd4_cld_unregister_net(net, cn->cn_pipe);\r\nrpc_destroy_pipe_data(cn->cn_pipe);\r\nkfree(nn->cld_net);\r\nnn->cld_net = NULL;\r\n}\r\nstatic struct cld_upcall *\r\nalloc_cld_upcall(struct cld_net *cn)\r\n{\r\nstruct cld_upcall *new, *tmp;\r\nnew = kzalloc(sizeof(*new), GFP_KERNEL);\r\nif (!new)\r\nreturn new;\r\nrestart_search:\r\nspin_lock(&cn->cn_lock);\r\nlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\r\nif (tmp->cu_msg.cm_xid == cn->cn_xid) {\r\ncn->cn_xid++;\r\nspin_unlock(&cn->cn_lock);\r\ngoto restart_search;\r\n}\r\n}\r\nnew->cu_task = current;\r\nnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\r\nput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\r\nnew->cu_net = cn;\r\nlist_add(&new->cu_list, &cn->cn_list);\r\nspin_unlock(&cn->cn_lock);\r\ndprintk("%s: allocated xid %u\n", __func__, new->cu_msg.cm_xid);\r\nreturn new;\r\n}\r\nstatic void\r\nfree_cld_upcall(struct cld_upcall *victim)\r\n{\r\nstruct cld_net *cn = victim->cu_net;\r\nspin_lock(&cn->cn_lock);\r\nlist_del(&victim->cu_list);\r\nspin_unlock(&cn->cn_lock);\r\nkfree(victim);\r\n}\r\nstatic void\r\nnfsd4_cld_create(struct nfs4_client *clp)\r\n{\r\nint ret;\r\nstruct cld_upcall *cup;\r\nstruct nfsd_net *nn = net_generic(&init_net, nfsd_net_id);\r\nstruct cld_net *cn = nn->cld_net;\r\nif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn;\r\ncup = alloc_cld_upcall(cn);\r\nif (!cup) {\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\ncup->cu_msg.cm_cmd = Cld_Create;\r\ncup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\r\nmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\r\nclp->cl_name.len);\r\nret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\r\nif (!ret) {\r\nret = cup->cu_msg.cm_status;\r\nset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\r\n}\r\nfree_cld_upcall(cup);\r\nout_err:\r\nif (ret)\r\nprintk(KERN_ERR "NFSD: Unable to create client "\r\n"record on stable storage: %d\n", ret);\r\n}\r\nstatic void\r\nnfsd4_cld_remove(struct nfs4_client *clp)\r\n{\r\nint ret;\r\nstruct cld_upcall *cup;\r\nstruct nfsd_net *nn = net_generic(&init_net, nfsd_net_id);\r\nstruct cld_net *cn = nn->cld_net;\r\nif (!test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn;\r\ncup = alloc_cld_upcall(cn);\r\nif (!cup) {\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\ncup->cu_msg.cm_cmd = Cld_Remove;\r\ncup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\r\nmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\r\nclp->cl_name.len);\r\nret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\r\nif (!ret) {\r\nret = cup->cu_msg.cm_status;\r\nclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\r\n}\r\nfree_cld_upcall(cup);\r\nout_err:\r\nif (ret)\r\nprintk(KERN_ERR "NFSD: Unable to remove client "\r\n"record from stable storage: %d\n", ret);\r\n}\r\nstatic int\r\nnfsd4_cld_check(struct nfs4_client *clp)\r\n{\r\nint ret;\r\nstruct cld_upcall *cup;\r\nstruct nfsd_net *nn = net_generic(&init_net, nfsd_net_id);\r\nstruct cld_net *cn = nn->cld_net;\r\nif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\r\nreturn 0;\r\ncup = alloc_cld_upcall(cn);\r\nif (!cup) {\r\nprintk(KERN_ERR "NFSD: Unable to check client record on "\r\n"stable storage: %d\n", -ENOMEM);\r\nreturn -ENOMEM;\r\n}\r\ncup->cu_msg.cm_cmd = Cld_Check;\r\ncup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\r\nmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\r\nclp->cl_name.len);\r\nret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\r\nif (!ret) {\r\nret = cup->cu_msg.cm_status;\r\nset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\r\n}\r\nfree_cld_upcall(cup);\r\nreturn ret;\r\n}\r\nstatic void\r\nnfsd4_cld_grace_done(struct net *net, time_t boot_time)\r\n{\r\nint ret;\r\nstruct cld_upcall *cup;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nstruct cld_net *cn = nn->cld_net;\r\ncup = alloc_cld_upcall(cn);\r\nif (!cup) {\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\ncup->cu_msg.cm_cmd = Cld_GraceDone;\r\ncup->cu_msg.cm_u.cm_gracetime = (int64_t)boot_time;\r\nret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\r\nif (!ret)\r\nret = cup->cu_msg.cm_status;\r\nfree_cld_upcall(cup);\r\nout_err:\r\nif (ret)\r\nprintk(KERN_ERR "NFSD: Unable to end grace period: %d\n", ret);\r\n}\r\nint\r\nnfsd4_client_tracking_init(struct net *net)\r\n{\r\nint status;\r\nstruct path path;\r\nif (!client_tracking_ops) {\r\nclient_tracking_ops = &nfsd4_cld_tracking_ops;\r\nstatus = kern_path(nfs4_recoverydir(), LOOKUP_FOLLOW, &path);\r\nif (!status) {\r\nif (S_ISDIR(path.dentry->d_inode->i_mode))\r\nclient_tracking_ops =\r\n&nfsd4_legacy_tracking_ops;\r\npath_put(&path);\r\n}\r\n}\r\nstatus = client_tracking_ops->init(net);\r\nif (status) {\r\nprintk(KERN_WARNING "NFSD: Unable to initialize client "\r\n"recovery tracking! (%d)\n", status);\r\nclient_tracking_ops = NULL;\r\n}\r\nreturn status;\r\n}\r\nvoid\r\nnfsd4_client_tracking_exit(struct net *net)\r\n{\r\nif (client_tracking_ops) {\r\nclient_tracking_ops->exit(net);\r\nclient_tracking_ops = NULL;\r\n}\r\n}\r\nvoid\r\nnfsd4_client_record_create(struct nfs4_client *clp)\r\n{\r\nif (client_tracking_ops)\r\nclient_tracking_ops->create(clp);\r\n}\r\nvoid\r\nnfsd4_client_record_remove(struct nfs4_client *clp)\r\n{\r\nif (client_tracking_ops)\r\nclient_tracking_ops->remove(clp);\r\n}\r\nint\r\nnfsd4_client_record_check(struct nfs4_client *clp)\r\n{\r\nif (client_tracking_ops)\r\nreturn client_tracking_ops->check(clp);\r\nreturn -EOPNOTSUPP;\r\n}\r\nvoid\r\nnfsd4_record_grace_done(struct net *net, time_t boot_time)\r\n{\r\nif (client_tracking_ops)\r\nclient_tracking_ops->grace_done(net, boot_time);\r\n}\r\nstatic int\r\nrpc_pipefs_event(struct notifier_block *nb, unsigned long event, void *ptr)\r\n{\r\nstruct super_block *sb = ptr;\r\nstruct net *net = sb->s_fs_info;\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nstruct cld_net *cn = nn->cld_net;\r\nstruct dentry *dentry;\r\nint ret = 0;\r\nif (!try_module_get(THIS_MODULE))\r\nreturn 0;\r\nif (!cn) {\r\nmodule_put(THIS_MODULE);\r\nreturn 0;\r\n}\r\nswitch (event) {\r\ncase RPC_PIPEFS_MOUNT:\r\ndentry = nfsd4_cld_register_sb(sb, cn->cn_pipe);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\nbreak;\r\n}\r\ncn->cn_pipe->dentry = dentry;\r\nbreak;\r\ncase RPC_PIPEFS_UMOUNT:\r\nif (cn->cn_pipe->dentry)\r\nnfsd4_cld_unregister_sb(cn->cn_pipe);\r\nbreak;\r\ndefault:\r\nret = -ENOTSUPP;\r\nbreak;\r\n}\r\nmodule_put(THIS_MODULE);\r\nreturn ret;\r\n}\r\nint\r\nregister_cld_notifier(void)\r\n{\r\nreturn rpc_pipefs_notifier_register(&nfsd4_cld_block);\r\n}\r\nvoid\r\nunregister_cld_notifier(void)\r\n{\r\nrpc_pipefs_notifier_unregister(&nfsd4_cld_block);\r\n}
