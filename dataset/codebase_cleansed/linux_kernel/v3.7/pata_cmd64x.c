static int cmd648_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu8 r;\r\npci_read_config_byte(pdev, BMIDECSR, &r);\r\nif (r & (1 << ap->port_no))\r\nreturn ATA_CBL_PATA80;\r\nreturn ATA_CBL_PATA40;\r\n}\r\nstatic void cmd64x_set_timing(struct ata_port *ap, struct ata_device *adev, u8 mode)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstruct ata_timing t;\r\nconst unsigned long T = 1000000 / 33;\r\nconst u8 setup_data[] = { 0x40, 0x40, 0x40, 0x80, 0x00 };\r\nu8 reg;\r\nconst u8 arttim_port[2][2] = {\r\n{ ARTTIM0, ARTTIM1 },\r\n{ ARTTIM23, ARTTIM23 }\r\n};\r\nconst u8 drwtim_port[2][2] = {\r\n{ DRWTIM0, DRWTIM1 },\r\n{ DRWTIM2, DRWTIM3 }\r\n};\r\nint arttim = arttim_port[ap->port_no][adev->devno];\r\nint drwtim = drwtim_port[ap->port_no][adev->devno];\r\nif (ata_timing_compute(adev, mode, &t, T, 0) < 0) {\r\nprintk(KERN_ERR DRV_NAME ": mode computation failed.\n");\r\nreturn;\r\n}\r\nif (ap->port_no) {\r\nstruct ata_device *pair = ata_dev_pair(adev);\r\nif (pair) {\r\nstruct ata_timing tp;\r\nata_timing_compute(pair, pair->pio_mode, &tp, T, 0);\r\nata_timing_merge(&t, &tp, &t, ATA_TIMING_SETUP);\r\n}\r\n}\r\nprintk(KERN_DEBUG DRV_NAME ": active %d recovery %d setup %d.\n",\r\nt.active, t.recover, t.setup);\r\nif (t.recover > 16) {\r\nt.active += t.recover - 16;\r\nt.recover = 16;\r\n}\r\nif (t.active > 16)\r\nt.active = 16;\r\nif (t.recover == 16)\r\nt.recover = 0;\r\nelse if (t.recover > 1)\r\nt.recover--;\r\nelse\r\nt.recover = 15;\r\nif (t.setup > 4)\r\nt.setup = 0xC0;\r\nelse\r\nt.setup = setup_data[t.setup];\r\nt.active &= 0x0F;\r\npci_read_config_byte(pdev, arttim, &reg);\r\nreg &= 0x3F;\r\nreg |= t.setup;\r\npci_write_config_byte(pdev, arttim, reg);\r\npci_write_config_byte(pdev, drwtim, (t.active << 4) | t.recover);\r\n}\r\nstatic void cmd64x_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\ncmd64x_set_timing(ap, adev, adev->pio_mode);\r\n}\r\nstatic void cmd64x_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstatic const u8 udma_data[] = {\r\n0x30, 0x20, 0x10, 0x20, 0x10, 0x00\r\n};\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu8 regU, regD;\r\nint pciU = UDIDETCR0 + 8 * ap->port_no;\r\nint pciD = BMIDESR0 + 8 * ap->port_no;\r\nint shift = 2 * adev->devno;\r\npci_read_config_byte(pdev, pciD, &regD);\r\npci_read_config_byte(pdev, pciU, &regU);\r\nregD &= ~(0x20 << adev->devno);\r\nregU &= ~(0x30 << shift);\r\nregU &= ~(0x05 << adev->devno);\r\nif (adev->dma_mode >= XFER_UDMA_0) {\r\nregU |= udma_data[adev->dma_mode - XFER_UDMA_0] << shift;\r\nregU |= 1 << adev->devno;\r\nif (adev->dma_mode > XFER_UDMA_2)\r\nregU |= 4 << adev->devno;\r\n} else {\r\nregU &= ~ (1 << adev->devno);\r\ncmd64x_set_timing(ap, adev, adev->dma_mode);\r\n}\r\nregD |= 0x20 << adev->devno;\r\npci_write_config_byte(pdev, pciU, regU);\r\npci_write_config_byte(pdev, pciD, regD);\r\n}\r\nstatic bool cmd64x_sff_irq_check(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint irq_mask = ap->port_no ? ARTTIM23_INTR_CH1 : CFR_INTR_CH0;\r\nint irq_reg = ap->port_no ? ARTTIM23 : CFR;\r\nu8 irq_stat;\r\npci_read_config_byte(pdev, irq_reg, &irq_stat);\r\nreturn irq_stat & irq_mask;\r\n}\r\nstatic void cmd64x_sff_irq_clear(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint irq_reg = ap->port_no ? ARTTIM23 : CFR;\r\nu8 irq_stat;\r\nata_bmdma_irq_clear(ap);\r\npci_read_config_byte(pdev, irq_reg, &irq_stat);\r\n}\r\nstatic bool cmd648_sff_irq_check(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nunsigned long base = pci_resource_start(pdev, 4);\r\nint irq_mask = ap->port_no ? MRDMODE_INTR_CH1 : MRDMODE_INTR_CH0;\r\nu8 mrdmode = inb(base + 1);\r\nreturn mrdmode & irq_mask;\r\n}\r\nstatic void cmd648_sff_irq_clear(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nunsigned long base = pci_resource_start(pdev, 4);\r\nint irq_mask = ap->port_no ? MRDMODE_INTR_CH1 : MRDMODE_INTR_CH0;\r\nu8 mrdmode;\r\nata_bmdma_irq_clear(ap);\r\nmrdmode = inb(base + 1);\r\nmrdmode &= ~(MRDMODE_INTR_CH0 | MRDMODE_INTR_CH1);\r\noutb(mrdmode | irq_mask, base + 1);\r\n}\r\nstatic void cmd646r1_bmdma_stop(struct ata_queued_cmd *qc)\r\n{\r\nata_bmdma_stop(qc);\r\n}\r\nstatic void cmd64x_fixup(struct pci_dev *pdev)\r\n{\r\nu8 mrdmode;\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, 64);\r\npci_read_config_byte(pdev, MRDMODE, &mrdmode);\r\nmrdmode &= ~0x30;\r\nmrdmode |= 0x02;\r\npci_write_config_byte(pdev, MRDMODE, mrdmode);\r\n#ifdef CONFIG_PPC\r\npci_write_config_byte(pdev, UDIDETCR0, 0xF0);\r\n#endif\r\n}\r\nstatic int cmd64x_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info cmd_info[7] = {\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.port_ops = &cmd64x_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.port_ops = &cmd64x_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.port_ops = &cmd646r3_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA2,\r\n.port_ops = &cmd646r3_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.port_ops = &cmd646r1_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA4,\r\n.port_ops = &cmd648_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &cmd648_port_ops\r\n}\r\n};\r\nconst struct ata_port_info *ppi[] = {\r\n&cmd_info[id->driver_data],\r\n&cmd_info[id->driver_data],\r\nNULL\r\n};\r\nu8 reg;\r\nint rc;\r\nstruct pci_dev *bridge = pdev->bus->self;\r\nint port_ok = !(bridge && bridge->vendor ==\r\nPCI_VENDOR_ID_MOBILITY_ELECTRONICS);\r\nint cntrl_ch0_ok = (id->driver_data != 0);\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (id->driver_data == 0)\r\nata_pci_bmdma_clear_simplex(pdev);\r\nif (pdev->device == PCI_DEVICE_ID_CMD_646)\r\nswitch (pdev->revision) {\r\ndefault:\r\nppi[0] = &cmd_info[3];\r\nppi[1] = &cmd_info[3];\r\nbreak;\r\ncase 3:\r\ncase 4:\r\nppi[0] = &cmd_info[2];\r\nppi[1] = &cmd_info[2];\r\nbreak;\r\ncase 1:\r\nppi[0] = &cmd_info[4];\r\nppi[1] = &cmd_info[4];\r\ncase 2:\r\ncase 0:\r\ncntrl_ch0_ok = 0;\r\nbreak;\r\n}\r\ncmd64x_fixup(pdev);\r\npci_read_config_byte(pdev, CNTRL, &reg);\r\nif (!port_ok)\r\ndev_printk(KERN_NOTICE, &pdev->dev, "Mobility Bridge detected, ignoring CNTRL port enable/disable\n");\r\nif (port_ok && cntrl_ch0_ok && !(reg & CNTRL_CH0)) {\r\ndev_printk(KERN_NOTICE, &pdev->dev, "Primary port is disabled\n");\r\nppi[0] = &ata_dummy_port_info;\r\n}\r\nif (port_ok && !(reg & CNTRL_CH1)) {\r\ndev_printk(KERN_NOTICE, &pdev->dev, "Secondary port is disabled\n");\r\nppi[1] = &ata_dummy_port_info;\r\n}\r\nreturn ata_pci_bmdma_init_one(pdev, ppi, &cmd64x_sht, NULL, 0);\r\n}\r\nstatic int cmd64x_reinit_one(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nint rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\ncmd64x_fixup(pdev);\r\nata_host_resume(host);\r\nreturn 0;\r\n}
