static unsigned int coda_psdev_poll(struct file *file, poll_table * wait)\r\n{\r\nstruct venus_comm *vcp = (struct venus_comm *) file->private_data;\r\nunsigned int mask = POLLOUT | POLLWRNORM;\r\npoll_wait(file, &vcp->vc_waitq, wait);\r\nmutex_lock(&vcp->vc_mutex);\r\nif (!list_empty(&vcp->vc_pending))\r\nmask |= POLLIN | POLLRDNORM;\r\nmutex_unlock(&vcp->vc_mutex);\r\nreturn mask;\r\n}\r\nstatic long coda_psdev_ioctl(struct file * filp, unsigned int cmd, unsigned long arg)\r\n{\r\nunsigned int data;\r\nswitch(cmd) {\r\ncase CIOC_KERNEL_VERSION:\r\ndata = CODA_KERNEL_VERSION;\r\nreturn put_user(data, (int __user *) arg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t coda_psdev_write(struct file *file, const char __user *buf,\r\nsize_t nbytes, loff_t *off)\r\n{\r\nstruct venus_comm *vcp = (struct venus_comm *) file->private_data;\r\nstruct upc_req *req = NULL;\r\nstruct upc_req *tmp;\r\nstruct list_head *lh;\r\nstruct coda_in_hdr hdr;\r\nssize_t retval = 0, count = 0;\r\nint error;\r\nif (copy_from_user(&hdr, buf, 2 * sizeof(u_long)))\r\nreturn -EFAULT;\r\nif (DOWNCALL(hdr.opcode)) {\r\nunion outputArgs *dcbuf;\r\nint size = sizeof(*dcbuf);\r\nif ( nbytes < sizeof(struct coda_out_hdr) ) {\r\nprintk("coda_downcall opc %d uniq %d, not enough!\n",\r\nhdr.opcode, hdr.unique);\r\ncount = nbytes;\r\ngoto out;\r\n}\r\nif ( nbytes > size ) {\r\nprintk("Coda: downcall opc %d, uniq %d, too much!",\r\nhdr.opcode, hdr.unique);\r\nnbytes = size;\r\n}\r\nCODA_ALLOC(dcbuf, union outputArgs *, nbytes);\r\nif (copy_from_user(dcbuf, buf, nbytes)) {\r\nCODA_FREE(dcbuf, nbytes);\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\nerror = coda_downcall(vcp, hdr.opcode, dcbuf);\r\nCODA_FREE(dcbuf, nbytes);\r\nif (error) {\r\nprintk("psdev_write: coda_downcall error: %d\n", error);\r\nretval = error;\r\ngoto out;\r\n}\r\ncount = nbytes;\r\ngoto out;\r\n}\r\nmutex_lock(&vcp->vc_mutex);\r\nlist_for_each(lh, &vcp->vc_processing) {\r\ntmp = list_entry(lh, struct upc_req , uc_chain);\r\nif (tmp->uc_unique == hdr.unique) {\r\nreq = tmp;\r\nlist_del(&req->uc_chain);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&vcp->vc_mutex);\r\nif (!req) {\r\nprintk("psdev_write: msg (%d, %d) not found\n",\r\nhdr.opcode, hdr.unique);\r\nretval = -ESRCH;\r\ngoto out;\r\n}\r\nif (req->uc_outSize < nbytes) {\r\nprintk("psdev_write: too much cnt: %d, cnt: %ld, opc: %d, uniq: %d.\n",\r\nreq->uc_outSize, (long)nbytes, hdr.opcode, hdr.unique);\r\nnbytes = req->uc_outSize;\r\n}\r\nif (copy_from_user(req->uc_data, buf, nbytes)) {\r\nreq->uc_flags |= CODA_REQ_ABORT;\r\nwake_up(&req->uc_sleep);\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\nreq->uc_outSize = nbytes;\r\nreq->uc_flags |= CODA_REQ_WRITE;\r\ncount = nbytes;\r\nif (req->uc_opcode == CODA_OPEN_BY_FD) {\r\nstruct coda_open_by_fd_out *outp =\r\n(struct coda_open_by_fd_out *)req->uc_data;\r\nif (!outp->oh.result)\r\noutp->fh = fget(outp->fd);\r\n}\r\nwake_up(&req->uc_sleep);\r\nout:\r\nreturn(count ? count : retval);\r\n}\r\nstatic ssize_t coda_psdev_read(struct file * file, char __user * buf,\r\nsize_t nbytes, loff_t *off)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct venus_comm *vcp = (struct venus_comm *) file->private_data;\r\nstruct upc_req *req;\r\nssize_t retval = 0, count = 0;\r\nif (nbytes == 0)\r\nreturn 0;\r\nmutex_lock(&vcp->vc_mutex);\r\nadd_wait_queue(&vcp->vc_waitq, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (list_empty(&vcp->vc_pending)) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nmutex_unlock(&vcp->vc_mutex);\r\nschedule();\r\nmutex_lock(&vcp->vc_mutex);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&vcp->vc_waitq, &wait);\r\nif (retval)\r\ngoto out;\r\nreq = list_entry(vcp->vc_pending.next, struct upc_req,uc_chain);\r\nlist_del(&req->uc_chain);\r\ncount = req->uc_inSize;\r\nif (nbytes < req->uc_inSize) {\r\nprintk ("psdev_read: Venus read %ld bytes of %d in message\n",\r\n(long)nbytes, req->uc_inSize);\r\ncount = nbytes;\r\n}\r\nif (copy_to_user(buf, req->uc_data, count))\r\nretval = -EFAULT;\r\nif (!(req->uc_flags & CODA_REQ_ASYNC)) {\r\nreq->uc_flags |= CODA_REQ_READ;\r\nlist_add_tail(&(req->uc_chain), &vcp->vc_processing);\r\ngoto out;\r\n}\r\nCODA_FREE(req->uc_data, sizeof(struct coda_in_hdr));\r\nkfree(req);\r\nout:\r\nmutex_unlock(&vcp->vc_mutex);\r\nreturn (count ? count : retval);\r\n}\r\nstatic int coda_psdev_open(struct inode * inode, struct file * file)\r\n{\r\nstruct venus_comm *vcp;\r\nint idx, err;\r\nidx = iminor(inode);\r\nif (idx < 0 || idx >= MAX_CODADEVS)\r\nreturn -ENODEV;\r\nerr = -EBUSY;\r\nvcp = &coda_comms[idx];\r\nmutex_lock(&vcp->vc_mutex);\r\nif (!vcp->vc_inuse) {\r\nvcp->vc_inuse++;\r\nINIT_LIST_HEAD(&vcp->vc_pending);\r\nINIT_LIST_HEAD(&vcp->vc_processing);\r\ninit_waitqueue_head(&vcp->vc_waitq);\r\nvcp->vc_sb = NULL;\r\nvcp->vc_seq = 0;\r\nfile->private_data = vcp;\r\nerr = 0;\r\n}\r\nmutex_unlock(&vcp->vc_mutex);\r\nreturn err;\r\n}\r\nstatic int coda_psdev_release(struct inode * inode, struct file * file)\r\n{\r\nstruct venus_comm *vcp = (struct venus_comm *) file->private_data;\r\nstruct upc_req *req, *tmp;\r\nif (!vcp || !vcp->vc_inuse ) {\r\nprintk("psdev_release: Not open.\n");\r\nreturn -1;\r\n}\r\nmutex_lock(&vcp->vc_mutex);\r\nlist_for_each_entry_safe(req, tmp, &vcp->vc_pending, uc_chain) {\r\nlist_del(&req->uc_chain);\r\nif (req->uc_flags & CODA_REQ_ASYNC) {\r\nCODA_FREE(req->uc_data, sizeof(struct coda_in_hdr));\r\nkfree(req);\r\ncontinue;\r\n}\r\nreq->uc_flags |= CODA_REQ_ABORT;\r\nwake_up(&req->uc_sleep);\r\n}\r\nlist_for_each_entry_safe(req, tmp, &vcp->vc_processing, uc_chain) {\r\nlist_del(&req->uc_chain);\r\nreq->uc_flags |= CODA_REQ_ABORT;\r\nwake_up(&req->uc_sleep);\r\n}\r\nfile->private_data = NULL;\r\nvcp->vc_inuse--;\r\nmutex_unlock(&vcp->vc_mutex);\r\nreturn 0;\r\n}\r\nstatic int init_coda_psdev(void)\r\n{\r\nint i, err = 0;\r\nif (register_chrdev(CODA_PSDEV_MAJOR, "coda", &coda_psdev_fops)) {\r\nprintk(KERN_ERR "coda_psdev: unable to get major %d\n",\r\nCODA_PSDEV_MAJOR);\r\nreturn -EIO;\r\n}\r\ncoda_psdev_class = class_create(THIS_MODULE, "coda");\r\nif (IS_ERR(coda_psdev_class)) {\r\nerr = PTR_ERR(coda_psdev_class);\r\ngoto out_chrdev;\r\n}\r\nfor (i = 0; i < MAX_CODADEVS; i++) {\r\nmutex_init(&(&coda_comms[i])->vc_mutex);\r\ndevice_create(coda_psdev_class, NULL,\r\nMKDEV(CODA_PSDEV_MAJOR, i), NULL, "cfs%d", i);\r\n}\r\ncoda_sysctl_init();\r\ngoto out;\r\nout_chrdev:\r\nunregister_chrdev(CODA_PSDEV_MAJOR, "coda");\r\nout:\r\nreturn err;\r\n}\r\nstatic int __init init_coda(void)\r\n{\r\nint status;\r\nint i;\r\nstatus = coda_init_inodecache();\r\nif (status)\r\ngoto out2;\r\nstatus = init_coda_psdev();\r\nif ( status ) {\r\nprintk("Problem (%d) in init_coda_psdev\n", status);\r\ngoto out1;\r\n}\r\nstatus = register_filesystem(&coda_fs_type);\r\nif (status) {\r\nprintk("coda: failed to register filesystem!\n");\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nfor (i = 0; i < MAX_CODADEVS; i++)\r\ndevice_destroy(coda_psdev_class, MKDEV(CODA_PSDEV_MAJOR, i));\r\nclass_destroy(coda_psdev_class);\r\nunregister_chrdev(CODA_PSDEV_MAJOR, "coda");\r\ncoda_sysctl_clean();\r\nout1:\r\ncoda_destroy_inodecache();\r\nout2:\r\nreturn status;\r\n}\r\nstatic void __exit exit_coda(void)\r\n{\r\nint err, i;\r\nerr = unregister_filesystem(&coda_fs_type);\r\nif ( err != 0 ) {\r\nprintk("coda: failed to unregister filesystem\n");\r\n}\r\nfor (i = 0; i < MAX_CODADEVS; i++)\r\ndevice_destroy(coda_psdev_class, MKDEV(CODA_PSDEV_MAJOR, i));\r\nclass_destroy(coda_psdev_class);\r\nunregister_chrdev(CODA_PSDEV_MAJOR, "coda");\r\ncoda_sysctl_clean();\r\ncoda_destroy_inodecache();\r\n}
