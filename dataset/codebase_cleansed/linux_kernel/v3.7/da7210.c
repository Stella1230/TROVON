static int da7210_put_alc_sw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nif (ucontrol->value.integer.value[0]) {\r\nif (snd_soc_read(codec, DA7210_CONTROL) & DA7210_NOISE_SUP_EN) {\r\ndev_dbg(codec->dev,\r\n"Disable noise suppression to enable ALC\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn snd_soc_put_volsw(kcontrol, ucontrol);\r\n}\r\nstatic int da7210_put_noise_sup_sw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nu8 val;\r\nif (ucontrol->value.integer.value[0]) {\r\nif (snd_soc_read(codec, DA7210_ADC) & DA7210_ADC_ALC_EN)\r\ngoto err;\r\nif ((snd_soc_read(codec, DA7210_ZERO_CROSS) &\r\n(DA7210_AUX1_L_ZC | DA7210_AUX1_R_ZC | DA7210_HP_L_ZC |\r\nDA7210_HP_R_ZC)) != (DA7210_AUX1_L_ZC |\r\nDA7210_AUX1_R_ZC | DA7210_HP_L_ZC | DA7210_HP_R_ZC))\r\ngoto err;\r\nval = snd_soc_read(codec, DA7210_IN_GAIN);\r\nif (((val & DA7210_INPGA_L_VOL) < DA7210_INPGA_MIN_VOL_NS) ||\r\n(((val & DA7210_INPGA_R_VOL) >> 4) <\r\nDA7210_INPGA_MIN_VOL_NS))\r\ngoto err;\r\nif (((snd_soc_read(codec, DA7210_AUX1_L) & DA7210_AUX1_L_VOL) <\r\nDA7210_AUX1_MIN_VOL_NS) ||\r\n((snd_soc_read(codec, DA7210_AUX1_R) & DA7210_AUX1_R_VOL) <\r\nDA7210_AUX1_MIN_VOL_NS))\r\ngoto err;\r\n}\r\nreturn snd_soc_put_volsw(kcontrol, ucontrol);\r\nerr:\r\nreturn -EINVAL;\r\n}\r\nstatic bool da7210_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase DA7210_A_HID_UNLOCK:\r\ncase DA7210_A_TEST_UNLOCK:\r\ncase DA7210_A_PLL1:\r\ncase DA7210_A_CP_MODE:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic bool da7210_volatile_register(struct device *dev,\r\nunsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase DA7210_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int da7210_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct da7210_priv *da7210 = snd_soc_codec_get_drvdata(codec);\r\nu32 dai_cfg1;\r\nu32 fs, sysclk;\r\nsnd_soc_write(codec, DA7210_DAI_SRC_SEL,\r\nDA7210_DAI_OUT_R_SRC | DA7210_DAI_OUT_L_SRC);\r\nsnd_soc_write(codec, DA7210_DAI_CFG3, DA7210_DAI_OE | DA7210_DAI_EN);\r\ndai_cfg1 = 0xFC & snd_soc_read(codec, DA7210_DAI_CFG1);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ndai_cfg1 |= DA7210_DAI_WORD_S16_LE;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\ndai_cfg1 |= DA7210_DAI_WORD_S20_3LE;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ndai_cfg1 |= DA7210_DAI_WORD_S24_LE;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\ndai_cfg1 |= DA7210_DAI_WORD_S32_LE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, DA7210_DAI_CFG1, dai_cfg1);\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nfs = DA7210_PLL_FS_8000;\r\nsysclk = 3072000;\r\nbreak;\r\ncase 11025:\r\nfs = DA7210_PLL_FS_11025;\r\nsysclk = 2822400;\r\nbreak;\r\ncase 12000:\r\nfs = DA7210_PLL_FS_12000;\r\nsysclk = 3072000;\r\nbreak;\r\ncase 16000:\r\nfs = DA7210_PLL_FS_16000;\r\nsysclk = 3072000;\r\nbreak;\r\ncase 22050:\r\nfs = DA7210_PLL_FS_22050;\r\nsysclk = 2822400;\r\nbreak;\r\ncase 32000:\r\nfs = DA7210_PLL_FS_32000;\r\nsysclk = 3072000;\r\nbreak;\r\ncase 44100:\r\nfs = DA7210_PLL_FS_44100;\r\nsysclk = 2822400;\r\nbreak;\r\ncase 48000:\r\nfs = DA7210_PLL_FS_48000;\r\nsysclk = 3072000;\r\nbreak;\r\ncase 88200:\r\nfs = DA7210_PLL_FS_88200;\r\nsysclk = 2822400;\r\nbreak;\r\ncase 96000:\r\nfs = DA7210_PLL_FS_96000;\r\nsysclk = 3072000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, DA7210_STARTUP1, DA7210_SC_MST_EN, 0);\r\nsnd_soc_update_bits(codec, DA7210_PLL, DA7210_PLL_FS_MASK, fs);\r\nif (da7210->mclk_rate && (da7210->mclk_rate != sysclk)) {\r\nsnd_soc_update_bits(codec, DA7210_PLL_DIV3, DA7210_PLL_BYP, 0);\r\nif (!da7210->master) {\r\nsnd_soc_update_bits(codec, DA7210_PLL,\r\n(DA7210_MCLK_SRM_EN |\r\nDA7210_MCLK_DET_EN),\r\n(DA7210_MCLK_SRM_EN |\r\nDA7210_MCLK_DET_EN));\r\n}\r\n} else {\r\nsnd_soc_update_bits(codec, DA7210_PLL, DA7210_MCLK_DET_EN,\r\nDA7210_MCLK_DET_EN);\r\nsnd_soc_update_bits(codec, DA7210_PLL_DIV3, DA7210_PLL_BYP,\r\nDA7210_PLL_BYP);\r\n}\r\nsnd_soc_update_bits(codec, DA7210_STARTUP1,\r\nDA7210_SC_MST_EN, DA7210_SC_MST_EN);\r\nreturn 0;\r\n}\r\nstatic int da7210_set_dai_fmt(struct snd_soc_dai *codec_dai, u32 fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da7210_priv *da7210 = snd_soc_codec_get_drvdata(codec);\r\nu32 dai_cfg1;\r\nu32 dai_cfg3;\r\ndai_cfg1 = 0x7f & snd_soc_read(codec, DA7210_DAI_CFG1);\r\ndai_cfg3 = 0xfc & snd_soc_read(codec, DA7210_DAI_CFG3);\r\nif ((snd_soc_read(codec, DA7210_PLL) & DA7210_PLL_EN) &&\r\n(!(snd_soc_read(codec, DA7210_PLL_DIV3) & DA7210_PLL_BYP)))\r\nreturn -EINVAL;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nda7210->master = 1;\r\ndai_cfg1 |= DA7210_DAI_MODE_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nda7210->master = 0;\r\ndai_cfg1 |= DA7210_DAI_MODE_SLAVE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ndai_cfg3 |= DA7210_DAI_FORMAT_I2SMODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ndai_cfg3 |= DA7210_DAI_FORMAT_LEFT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ndai_cfg3 |= DA7210_DAI_FORMAT_RIGHT_J;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndai_cfg1 |= DA7210_DAI_FLEN_64BIT;\r\nsnd_soc_write(codec, DA7210_DAI_CFG1, dai_cfg1);\r\nsnd_soc_write(codec, DA7210_DAI_CFG3, dai_cfg3);\r\nreturn 0;\r\n}\r\nstatic int da7210_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 mute_reg = snd_soc_read(codec, DA7210_DAC_HPF) & 0xFB;\r\nif (mute)\r\nsnd_soc_write(codec, DA7210_DAC_HPF, mute_reg | 0x4);\r\nelse\r\nsnd_soc_write(codec, DA7210_DAC_HPF, mute_reg);\r\nreturn 0;\r\n}\r\nstatic int da7210_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da7210_priv *da7210 = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase DA7210_CLKSRC_MCLK:\r\nswitch (freq) {\r\ncase 12000000:\r\ncase 13000000:\r\ncase 13500000:\r\ncase 14400000:\r\ncase 19200000:\r\ncase 19680000:\r\ncase 19800000:\r\nda7210->mclk_rate = freq;\r\nreturn 0;\r\ndefault:\r\ndev_err(codec_dai->dev, "Unsupported MCLK value %d\n",\r\nfreq);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(codec_dai->dev, "Unknown clock source %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int da7210_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int fref, unsigned int fout)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da7210_priv *da7210 = snd_soc_codec_get_drvdata(codec);\r\nu8 pll_div1, pll_div2, pll_div3, cnt;\r\nif (!da7210->master)\r\nfout = 2822400;\r\nfor (cnt = 0; cnt < ARRAY_SIZE(da7210_pll_div); cnt++) {\r\nif ((fref == da7210_pll_div[cnt].fref) &&\r\n(da7210->master == da7210_pll_div[cnt].mode) &&\r\n(fout == da7210_pll_div[cnt].fout)) {\r\npll_div1 = da7210_pll_div[cnt].div1;\r\npll_div2 = da7210_pll_div[cnt].div2;\r\npll_div3 = da7210_pll_div[cnt].div3;\r\nbreak;\r\n}\r\n}\r\nif (cnt >= ARRAY_SIZE(da7210_pll_div))\r\ngoto err;\r\nsnd_soc_update_bits(codec, DA7210_STARTUP1, DA7210_SC_MST_EN, 0);\r\nsnd_soc_write(codec, DA7210_PLL_DIV1, pll_div1);\r\nsnd_soc_write(codec, DA7210_PLL_DIV2, pll_div2);\r\nsnd_soc_update_bits(codec, DA7210_PLL_DIV3,\r\nDA7210_PLL_DIV_L_MASK, pll_div3);\r\nsnd_soc_update_bits(codec, DA7210_PLL, DA7210_PLL_EN, DA7210_PLL_EN);\r\nsnd_soc_update_bits(codec, DA7210_STARTUP1, DA7210_SC_MST_EN,\r\nDA7210_SC_MST_EN);\r\nreturn 0;\r\nerr:\r\ndev_err(codec_dai->dev, "Unsupported PLL input frequency %d\n", fref);\r\nreturn -EINVAL;\r\n}\r\nstatic int da7210_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct da7210_priv *da7210 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ndev_info(codec->dev, "DA7210 Audio Codec %s\n", DA7210_VERSION);\r\ncodec->control_data = da7210->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nda7210->mclk_rate = 0;\r\nda7210->master = 0;\r\nsnd_soc_write(codec, DA7210_CONTROL, DA7210_REG_EN | DA7210_BIAS_EN);\r\nsnd_soc_write(codec, DA7210_MIC_L, DA7210_MIC_L_EN | DA7210_MICBIAS_EN);\r\nsnd_soc_write(codec, DA7210_MIC_R, DA7210_MIC_R_EN);\r\nsnd_soc_write(codec, DA7210_INMIX_L, DA7210_IN_L_EN);\r\nsnd_soc_write(codec, DA7210_INMIX_R, DA7210_IN_R_EN);\r\nsnd_soc_write(codec, DA7210_ADC, DA7210_ADC_L_EN | DA7210_ADC_R_EN);\r\nsnd_soc_write(codec, DA7210_DAC_SEL,\r\nDA7210_DAC_L_SRC_DAI_L | DA7210_DAC_L_EN |\r\nDA7210_DAC_R_SRC_DAI_R | DA7210_DAC_R_EN);\r\nsnd_soc_write(codec, DA7210_OUTMIX_L, DA7210_OUT_L_EN);\r\nsnd_soc_write(codec, DA7210_OUTMIX_R, DA7210_OUT_R_EN);\r\nsnd_soc_write(codec, DA7210_HP_CFG,\r\nDA7210_HP_2CAP_MODE | DA7210_HP_SENSE_EN |\r\nDA7210_HP_L_EN | DA7210_HP_MODE | DA7210_HP_R_EN);\r\nsnd_soc_write(codec, DA7210_SOFTMUTE, DA7210_RAMP_EN);\r\nsnd_soc_write(codec, DA7210_OUT1_L, DA7210_OUT1_L_EN);\r\nsnd_soc_write(codec, DA7210_OUT1_R, DA7210_OUT1_R_EN);\r\nsnd_soc_write(codec, DA7210_OUT2, DA7210_OUT2_EN |\r\nDA7210_OUT2_OUTMIX_L | DA7210_OUT2_OUTMIX_R);\r\nsnd_soc_write(codec, DA7210_AUX1_L, DA7210_AUX1_L_EN);\r\nsnd_soc_write(codec, DA7210_AUX1_R, DA7210_AUX1_R_EN);\r\nsnd_soc_write(codec, DA7210_AUX2, DA7210_AUX2_EN);\r\nsnd_soc_write(codec, DA7210_PLL_DIV3, DA7210_MCLK_RANGE_10_20_MHZ |\r\nDA7210_PLL_BYP);\r\nsnd_soc_write(codec, DA7210_PLL, DA7210_PLL_FS_48000);\r\nsnd_soc_write(codec, DA7210_STARTUP1, DA7210_SC_MST_EN);\r\ndev_info(codec->dev, "DA7210 Audio Codec %s\n", DA7210_VERSION);\r\nreturn 0;\r\n}\r\nstatic int __devinit da7210_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct da7210_priv *da7210;\r\nint ret;\r\nda7210 = devm_kzalloc(&i2c->dev, sizeof(struct da7210_priv),\r\nGFP_KERNEL);\r\nif (!da7210)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, da7210);\r\nda7210->regmap = regmap_init_i2c(i2c, &da7210_regmap_config_i2c);\r\nif (IS_ERR(da7210->regmap)) {\r\nret = PTR_ERR(da7210->regmap);\r\ndev_err(&i2c->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_register_patch(da7210->regmap, da7210_regmap_i2c_patch,\r\nARRAY_SIZE(da7210_regmap_i2c_patch));\r\nif (ret != 0)\r\ndev_warn(&i2c->dev, "Failed to apply regmap patch: %d\n", ret);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_da7210, &da7210_dai, 1);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to register codec: %d\n", ret);\r\ngoto err_regmap;\r\n}\r\nreturn ret;\r\nerr_regmap:\r\nregmap_exit(da7210->regmap);\r\nreturn ret;\r\n}\r\nstatic int __devexit da7210_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct da7210_priv *da7210 = i2c_get_clientdata(client);\r\nsnd_soc_unregister_codec(&client->dev);\r\nregmap_exit(da7210->regmap);\r\nreturn 0;\r\n}\r\nstatic int __devinit da7210_spi_probe(struct spi_device *spi)\r\n{\r\nstruct da7210_priv *da7210;\r\nint ret;\r\nda7210 = devm_kzalloc(&spi->dev, sizeof(struct da7210_priv),\r\nGFP_KERNEL);\r\nif (!da7210)\r\nreturn -ENOMEM;\r\nspi_set_drvdata(spi, da7210);\r\nda7210->regmap = devm_regmap_init_spi(spi, &da7210_regmap_config_spi);\r\nif (IS_ERR(da7210->regmap)) {\r\nret = PTR_ERR(da7210->regmap);\r\ndev_err(&spi->dev, "Failed to register regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_register_patch(da7210->regmap, da7210_regmap_spi_patch,\r\nARRAY_SIZE(da7210_regmap_spi_patch));\r\nif (ret != 0)\r\ndev_warn(&spi->dev, "Failed to apply regmap patch: %d\n", ret);\r\nret = snd_soc_register_codec(&spi->dev,\r\n&soc_codec_dev_da7210, &da7210_dai, 1);\r\nif (ret < 0)\r\ngoto err_regmap;\r\nreturn ret;\r\nerr_regmap:\r\nregmap_exit(da7210->regmap);\r\nreturn ret;\r\n}\r\nstatic int __devexit da7210_spi_remove(struct spi_device *spi)\r\n{\r\nstruct da7210_priv *da7210 = spi_get_drvdata(spi);\r\nsnd_soc_unregister_codec(&spi->dev);\r\nregmap_exit(da7210->regmap);\r\nreturn 0;\r\n}\r\nstatic int __init da7210_modinit(void)\r\n{\r\nint ret = 0;\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&da7210_i2c_driver);\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nret = spi_register_driver(&da7210_spi_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "Failed to register da7210 SPI driver: %d\n",\r\nret);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit da7210_exit(void)\r\n{\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&da7210_i2c_driver);\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nspi_unregister_driver(&da7210_spi_driver);\r\n#endif\r\n}
