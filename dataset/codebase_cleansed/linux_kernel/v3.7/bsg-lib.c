static void bsg_destroy_job(struct bsg_job *job)\r\n{\r\nput_device(job->dev);\r\nkfree(job->request_payload.sg_list);\r\nkfree(job->reply_payload.sg_list);\r\nkfree(job);\r\n}\r\nvoid bsg_job_done(struct bsg_job *job, int result,\r\nunsigned int reply_payload_rcv_len)\r\n{\r\nstruct request *req = job->req;\r\nstruct request *rsp = req->next_rq;\r\nint err;\r\nerr = job->req->errors = result;\r\nif (err < 0)\r\njob->req->sense_len = sizeof(u32);\r\nelse\r\njob->req->sense_len = job->reply_len;\r\nreq->resid_len = 0;\r\nif (rsp) {\r\nWARN_ON(reply_payload_rcv_len > rsp->resid_len);\r\nrsp->resid_len -= min(reply_payload_rcv_len, rsp->resid_len);\r\n}\r\nblk_complete_request(req);\r\n}\r\nstatic void bsg_softirq_done(struct request *rq)\r\n{\r\nstruct bsg_job *job = rq->special;\r\nblk_end_request_all(rq, rq->errors);\r\nbsg_destroy_job(job);\r\n}\r\nstatic int bsg_map_buffer(struct bsg_buffer *buf, struct request *req)\r\n{\r\nsize_t sz = (sizeof(struct scatterlist) * req->nr_phys_segments);\r\nBUG_ON(!req->nr_phys_segments);\r\nbuf->sg_list = kzalloc(sz, GFP_KERNEL);\r\nif (!buf->sg_list)\r\nreturn -ENOMEM;\r\nsg_init_table(buf->sg_list, req->nr_phys_segments);\r\nbuf->sg_cnt = blk_rq_map_sg(req->q, req, buf->sg_list);\r\nbuf->payload_len = blk_rq_bytes(req);\r\nreturn 0;\r\n}\r\nstatic int bsg_create_job(struct device *dev, struct request *req)\r\n{\r\nstruct request *rsp = req->next_rq;\r\nstruct request_queue *q = req->q;\r\nstruct bsg_job *job;\r\nint ret;\r\nBUG_ON(req->special);\r\njob = kzalloc(sizeof(struct bsg_job) + q->bsg_job_size, GFP_KERNEL);\r\nif (!job)\r\nreturn -ENOMEM;\r\nreq->special = job;\r\njob->req = req;\r\nif (q->bsg_job_size)\r\njob->dd_data = (void *)&job[1];\r\njob->request = req->cmd;\r\njob->request_len = req->cmd_len;\r\njob->reply = req->sense;\r\njob->reply_len = SCSI_SENSE_BUFFERSIZE;\r\nif (req->bio) {\r\nret = bsg_map_buffer(&job->request_payload, req);\r\nif (ret)\r\ngoto failjob_rls_job;\r\n}\r\nif (rsp && rsp->bio) {\r\nret = bsg_map_buffer(&job->reply_payload, rsp);\r\nif (ret)\r\ngoto failjob_rls_rqst_payload;\r\n}\r\njob->dev = dev;\r\nget_device(job->dev);\r\nreturn 0;\r\nfailjob_rls_rqst_payload:\r\nkfree(job->request_payload.sg_list);\r\nfailjob_rls_job:\r\nkfree(job);\r\nreturn -ENOMEM;\r\n}\r\nvoid bsg_goose_queue(struct request_queue *q)\r\n{\r\nif (!q)\r\nreturn;\r\nblk_run_queue_async(q);\r\n}\r\nvoid bsg_request_fn(struct request_queue *q)\r\n{\r\nstruct device *dev = q->queuedata;\r\nstruct request *req;\r\nstruct bsg_job *job;\r\nint ret;\r\nif (!get_device(dev))\r\nreturn;\r\nwhile (1) {\r\nreq = blk_fetch_request(q);\r\nif (!req)\r\nbreak;\r\nspin_unlock_irq(q->queue_lock);\r\nret = bsg_create_job(dev, req);\r\nif (ret) {\r\nreq->errors = ret;\r\nblk_end_request_all(req, ret);\r\nspin_lock_irq(q->queue_lock);\r\ncontinue;\r\n}\r\njob = req->special;\r\nret = q->bsg_job_fn(job);\r\nspin_lock_irq(q->queue_lock);\r\nif (ret)\r\nbreak;\r\n}\r\nspin_unlock_irq(q->queue_lock);\r\nput_device(dev);\r\nspin_lock_irq(q->queue_lock);\r\n}\r\nint bsg_setup_queue(struct device *dev, struct request_queue *q,\r\nchar *name, bsg_job_fn *job_fn, int dd_job_size)\r\n{\r\nint ret;\r\nq->queuedata = dev;\r\nq->bsg_job_size = dd_job_size;\r\nq->bsg_job_fn = job_fn;\r\nqueue_flag_set_unlocked(QUEUE_FLAG_BIDI, q);\r\nblk_queue_softirq_done(q, bsg_softirq_done);\r\nblk_queue_rq_timeout(q, BLK_DEFAULT_SG_TIMEOUT);\r\nret = bsg_register_queue(q, dev, name, NULL);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: bsg interface failed to "\r\n"initialize - register queue\n", dev->kobj.name);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
