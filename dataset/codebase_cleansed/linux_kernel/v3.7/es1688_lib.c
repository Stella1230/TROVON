static int snd_es1688_dsp_command(struct snd_es1688 *chip, unsigned char val)\r\n{\r\nint i;\r\nfor (i = 10000; i; i--)\r\nif ((inb(ES1688P(chip, STATUS)) & 0x80) == 0) {\r\noutb(val, ES1688P(chip, COMMAND));\r\nreturn 1;\r\n}\r\n#ifdef CONFIG_SND_DEBUG\r\nprintk(KERN_DEBUG "snd_es1688_dsp_command: timeout (0x%x)\n", val);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_dsp_get_byte(struct snd_es1688 *chip)\r\n{\r\nint i;\r\nfor (i = 1000; i; i--)\r\nif (inb(ES1688P(chip, DATA_AVAIL)) & 0x80)\r\nreturn inb(ES1688P(chip, READ));\r\nsnd_printd("es1688 get byte failed: 0x%lx = 0x%x!!!\n", ES1688P(chip, DATA_AVAIL), inb(ES1688P(chip, DATA_AVAIL)));\r\nreturn -ENODEV;\r\n}\r\nstatic int snd_es1688_write(struct snd_es1688 *chip,\r\nunsigned char reg, unsigned char data)\r\n{\r\nif (!snd_es1688_dsp_command(chip, reg))\r\nreturn 0;\r\nreturn snd_es1688_dsp_command(chip, data);\r\n}\r\nstatic int snd_es1688_read(struct snd_es1688 *chip, unsigned char reg)\r\n{\r\nif (!snd_es1688_dsp_command(chip, 0xc0))\r\nreturn -1;\r\nif (!snd_es1688_dsp_command(chip, reg))\r\nreturn -1;\r\nreturn snd_es1688_dsp_get_byte(chip);\r\n}\r\nvoid snd_es1688_mixer_write(struct snd_es1688 *chip,\r\nunsigned char reg, unsigned char data)\r\n{\r\noutb(reg, ES1688P(chip, MIXER_ADDR));\r\nudelay(10);\r\noutb(data, ES1688P(chip, MIXER_DATA));\r\nudelay(10);\r\n}\r\nstatic unsigned char snd_es1688_mixer_read(struct snd_es1688 *chip, unsigned char reg)\r\n{\r\nunsigned char result;\r\noutb(reg, ES1688P(chip, MIXER_ADDR));\r\nudelay(10);\r\nresult = inb(ES1688P(chip, MIXER_DATA));\r\nudelay(10);\r\nreturn result;\r\n}\r\nint snd_es1688_reset(struct snd_es1688 *chip)\r\n{\r\nint i;\r\noutb(3, ES1688P(chip, RESET));\r\nudelay(10);\r\noutb(0, ES1688P(chip, RESET));\r\nudelay(30);\r\nfor (i = 0; i < 1000 && !(inb(ES1688P(chip, DATA_AVAIL)) & 0x80); i++);\r\nif (inb(ES1688P(chip, READ)) != 0xaa) {\r\nsnd_printd("ess_reset at 0x%lx: failed!!!\n", chip->port);\r\nreturn -ENODEV;\r\n}\r\nsnd_es1688_dsp_command(chip, 0xc6);\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_probe(struct snd_es1688 *chip)\r\n{\r\nunsigned long flags;\r\nunsigned short major, minor, hw;\r\nint i;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\ninb(ES1688P(chip, ENABLE1));\r\ninb(ES1688P(chip, ENABLE1));\r\ninb(ES1688P(chip, ENABLE1));\r\ninb(ES1688P(chip, ENABLE2));\r\ninb(ES1688P(chip, ENABLE1));\r\ninb(ES1688P(chip, ENABLE2));\r\ninb(ES1688P(chip, ENABLE1));\r\ninb(ES1688P(chip, ENABLE1));\r\ninb(ES1688P(chip, ENABLE2));\r\ninb(ES1688P(chip, ENABLE1));\r\ninb(ES1688P(chip, ENABLE0));\r\nif (snd_es1688_reset(chip) < 0) {\r\nsnd_printdd("ESS: [0x%lx] reset failed... 0x%x\n", chip->port, inb(ES1688P(chip, READ)));\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn -ENODEV;\r\n}\r\nsnd_es1688_dsp_command(chip, 0xe7);\r\nfor (i = 1000, major = minor = 0; i; i--) {\r\nif (inb(ES1688P(chip, DATA_AVAIL)) & 0x80) {\r\nif (major == 0) {\r\nmajor = inb(ES1688P(chip, READ));\r\n} else {\r\nminor = inb(ES1688P(chip, READ));\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_printdd("ESS: [0x%lx] found.. major = 0x%x, minor = 0x%x\n", chip->port, major, minor);\r\nchip->version = (major << 8) | minor;\r\nif (!chip->version)\r\nreturn -ENODEV;\r\nhw = ES1688_HW_AUTO;\r\nswitch (chip->version & 0xfff0) {\r\ncase 0x4880:\r\nsnd_printk(KERN_ERR "[0x%lx] ESS: AudioDrive ES488 detected, "\r\n"but driver is in another place\n", chip->port);\r\nreturn -ENODEV;\r\ncase 0x6880:\r\nhw = (chip->version & 0x0f) >= 8 ? ES1688_HW_1688 : ES1688_HW_688;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "[0x%lx] ESS: unknown AudioDrive chip "\r\n"with version 0x%x (Jazz16 soundcard?)\n",\r\nchip->port, chip->version);\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1688_write(chip, 0xb1, 0x10);\r\nsnd_es1688_write(chip, 0xb2, 0x00);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nspin_lock_irqsave(&chip->mixer_lock, flags);\r\nsnd_es1688_mixer_write(chip, 0x40, 0x01);\r\nspin_unlock_irqrestore(&chip->mixer_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_init(struct snd_es1688 * chip, int enable)\r\n{\r\nstatic int irqs[16] = {-1, -1, 0, -1, -1, 1, -1, 2, -1, 0, 3, -1, -1, -1, -1, -1};\r\nunsigned long flags;\r\nint cfg, irq_bits, dma, dma_bits, tmp, tmp1;\r\ncfg = 0x01;\r\nif (enable && chip->mpu_port >= 0x300 && chip->mpu_irq > 0 && chip->hardware != ES1688_HW_688) {\r\ntmp = (chip->mpu_port & 0x0f0) >> 4;\r\nif (tmp <= 3) {\r\nswitch (chip->mpu_irq) {\r\ncase 9:\r\ntmp1 = 4;\r\nbreak;\r\ncase 5:\r\ntmp1 = 5;\r\nbreak;\r\ncase 7:\r\ntmp1 = 6;\r\nbreak;\r\ncase 10:\r\ntmp1 = 7;\r\nbreak;\r\ndefault:\r\ntmp1 = 0;\r\n}\r\nif (tmp1) {\r\ncfg |= (tmp << 3) | (tmp1 << 5);\r\n}\r\n}\r\n}\r\n#if 0\r\nsnd_printk(KERN_DEBUG "mpu cfg = 0x%x\n", cfg);\r\n#endif\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1688_mixer_write(chip, 0x40, cfg);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1688_read(chip, 0xb1);\r\nsnd_es1688_read(chip, 0xb2);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (enable) {\r\ncfg = 0xf0;\r\nirq_bits = irqs[chip->irq & 0x0f];\r\nif (irq_bits < 0) {\r\nsnd_printk(KERN_ERR "[0x%lx] ESS: bad IRQ %d "\r\n"for ES1688 chip!!\n",\r\nchip->port, chip->irq);\r\n#if 0\r\nirq_bits = 0;\r\ncfg = 0x10;\r\n#endif\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1688_write(chip, 0xb1, cfg | (irq_bits << 2));\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\ncfg = 0xf0;\r\ndma = chip->dma8;\r\nif (dma > 3 || dma == 2) {\r\nsnd_printk(KERN_ERR "[0x%lx] ESS: bad DMA channel %d "\r\n"for ES1688 chip!!\n", chip->port, dma);\r\n#if 0\r\ndma_bits = 0;\r\ncfg = 0x00;\r\n#endif\r\nreturn -EINVAL;\r\n} else {\r\ndma_bits = dma;\r\nif (dma != 3)\r\ndma_bits++;\r\n}\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1688_write(chip, 0xb2, cfg | (dma_bits << 2));\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n} else {\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1688_write(chip, 0xb1, 0x10);\r\nsnd_es1688_write(chip, 0xb2, 0x00);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1688_read(chip, 0xb1);\r\nsnd_es1688_read(chip, 0xb2);\r\nsnd_es1688_reset(chip);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void snd_es1688_set_rate(struct snd_es1688 *chip, struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int bits, divider;\r\nif (runtime->rate_num == clocks[0].num)\r\nbits = 256 - runtime->rate_den;\r\nelse\r\nbits = 128 - runtime->rate_den;\r\ndivider = 256 - 7160000*20/(8*82*runtime->rate);\r\nsnd_es1688_write(chip, 0xa1, bits);\r\nsnd_es1688_write(chip, 0xa2, divider);\r\n}\r\nstatic int snd_es1688_ioctl(struct snd_pcm_substream *substream,\r\nunsigned int cmd, void *arg)\r\n{\r\nreturn snd_pcm_lib_ioctl(substream, cmd, arg);\r\n}\r\nstatic int snd_es1688_trigger(struct snd_es1688 *chip, int cmd, unsigned char value)\r\n{\r\nint val;\r\nif (cmd == SNDRV_PCM_TRIGGER_STOP) {\r\nvalue = 0x00;\r\n} else if (cmd != SNDRV_PCM_TRIGGER_START) {\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&chip->reg_lock);\r\nchip->trigger_value = value;\r\nval = snd_es1688_read(chip, 0xb8);\r\nif ((val < 0) || (val & 0x0f) == value) {\r\nspin_unlock(&chip->reg_lock);\r\nreturn -EINVAL;\r\n}\r\n#if 0\r\nprintk(KERN_DEBUG "trigger: val = 0x%x, value = 0x%x\n", val, value);\r\nprintk(KERN_DEBUG "trigger: pointer = 0x%x\n",\r\nsnd_dma_pointer(chip->dma8, chip->dma_size));\r\n#endif\r\nsnd_es1688_write(chip, 0xb8, (val & 0xf0) | value);\r\nspin_unlock(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_es1688_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_es1688_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int count = snd_pcm_lib_period_bytes(substream);\r\nchip->dma_size = size;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1688_reset(chip);\r\nsnd_es1688_set_rate(chip, substream);\r\nsnd_es1688_write(chip, 0xb8, 4);\r\nsnd_es1688_write(chip, 0xa8, (snd_es1688_read(chip, 0xa8) & ~0x03) | (3 - runtime->channels));\r\nsnd_es1688_write(chip, 0xb9, 2);\r\nif (runtime->channels == 1) {\r\nif (snd_pcm_format_width(runtime->format) == 8) {\r\nsnd_es1688_write(chip, 0xb6, 0x80);\r\nsnd_es1688_write(chip, 0xb7, 0x51);\r\nsnd_es1688_write(chip, 0xb7, 0xd0);\r\n} else {\r\nsnd_es1688_write(chip, 0xb6, 0x00);\r\nsnd_es1688_write(chip, 0xb7, 0x71);\r\nsnd_es1688_write(chip, 0xb7, 0xf4);\r\n}\r\n} else {\r\nif (snd_pcm_format_width(runtime->format) == 8) {\r\nsnd_es1688_write(chip, 0xb6, 0x80);\r\nsnd_es1688_write(chip, 0xb7, 0x51);\r\nsnd_es1688_write(chip, 0xb7, 0x98);\r\n} else {\r\nsnd_es1688_write(chip, 0xb6, 0x00);\r\nsnd_es1688_write(chip, 0xb7, 0x71);\r\nsnd_es1688_write(chip, 0xb7, 0xbc);\r\n}\r\n}\r\nsnd_es1688_write(chip, 0xb1, (snd_es1688_read(chip, 0xb1) & 0x0f) | 0x50);\r\nsnd_es1688_write(chip, 0xb2, (snd_es1688_read(chip, 0xb2) & 0x0f) | 0x50);\r\nsnd_es1688_dsp_command(chip, ES1688_DSP_CMD_SPKON);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\ncount = -count;\r\nsnd_dma_program(chip->dma8, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1688_write(chip, 0xa4, (unsigned char) count);\r\nsnd_es1688_write(chip, 0xa5, (unsigned char) (count >> 8));\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\r\nreturn snd_es1688_trigger(chip, cmd, 0x05);\r\n}\r\nstatic int snd_es1688_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int count = snd_pcm_lib_period_bytes(substream);\r\nchip->dma_size = size;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1688_reset(chip);\r\nsnd_es1688_set_rate(chip, substream);\r\nsnd_es1688_dsp_command(chip, ES1688_DSP_CMD_SPKOFF);\r\nsnd_es1688_write(chip, 0xb8, 0x0e);\r\nsnd_es1688_write(chip, 0xa8, (snd_es1688_read(chip, 0xa8) & ~0x03) | (3 - runtime->channels));\r\nsnd_es1688_write(chip, 0xb9, 2);\r\nif (runtime->channels == 1) {\r\nif (snd_pcm_format_width(runtime->format) == 8) {\r\nsnd_es1688_write(chip, 0xb7, 0x51);\r\nsnd_es1688_write(chip, 0xb7, 0xd0);\r\n} else {\r\nsnd_es1688_write(chip, 0xb7, 0x71);\r\nsnd_es1688_write(chip, 0xb7, 0xf4);\r\n}\r\n} else {\r\nif (snd_pcm_format_width(runtime->format) == 8) {\r\nsnd_es1688_write(chip, 0xb7, 0x51);\r\nsnd_es1688_write(chip, 0xb7, 0x98);\r\n} else {\r\nsnd_es1688_write(chip, 0xb7, 0x71);\r\nsnd_es1688_write(chip, 0xb7, 0xbc);\r\n}\r\n}\r\nsnd_es1688_write(chip, 0xb1, (snd_es1688_read(chip, 0xb1) & 0x0f) | 0x50);\r\nsnd_es1688_write(chip, 0xb2, (snd_es1688_read(chip, 0xb2) & 0x0f) | 0x50);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\ncount = -count;\r\nsnd_dma_program(chip->dma8, runtime->dma_addr, size, DMA_MODE_READ | DMA_AUTOINIT);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1688_write(chip, 0xa4, (unsigned char) count);\r\nsnd_es1688_write(chip, 0xa5, (unsigned char) (count >> 8));\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\r\nreturn snd_es1688_trigger(chip, cmd, 0x0f);\r\n}\r\nstatic irqreturn_t snd_es1688_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_es1688 *chip = dev_id;\r\nif (chip->trigger_value == 0x05)\r\nsnd_pcm_period_elapsed(chip->playback_substream);\r\nif (chip->trigger_value == 0x0f)\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\ninb(ES1688P(chip, DATA_AVAIL));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic snd_pcm_uframes_t snd_es1688_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (chip->trigger_value != 0x05)\r\nreturn 0;\r\nptr = snd_dma_pointer(chip->dma8, chip->dma_size);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic snd_pcm_uframes_t snd_es1688_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (chip->trigger_value != 0x0f)\r\nreturn 0;\r\nptr = snd_dma_pointer(chip->dma8, chip->dma_size);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic int snd_es1688_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (chip->capture_substream != NULL)\r\nreturn -EAGAIN;\r\nchip->playback_substream = substream;\r\nruntime->hw = snd_es1688_playback;\r\nsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraints_clocks);\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (chip->playback_substream != NULL)\r\nreturn -EAGAIN;\r\nchip->capture_substream = substream;\r\nruntime->hw = snd_es1688_capture;\r\nsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraints_clocks);\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\r\nchip->playback_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_es1688 *chip = snd_pcm_substream_chip(substream);\r\nchip->capture_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_free(struct snd_es1688 *chip)\r\n{\r\nif (chip->hardware != ES1688_HW_UNDEF)\r\nsnd_es1688_init(chip, 0);\r\nif (chip->res_port)\r\nrelease_and_free_resource(chip->res_port);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, (void *) chip);\r\nif (chip->dma8 >= 0) {\r\ndisable_dma(chip->dma8);\r\nfree_dma(chip->dma8);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_es1688 *chip = device->device_data;\r\nreturn snd_es1688_free(chip);\r\n}\r\nstatic const char *snd_es1688_chip_id(struct snd_es1688 *chip)\r\n{\r\nstatic char tmp[16];\r\nsprintf(tmp, "ES%s688 rev %i", chip->hardware == ES1688_HW_688 ? "" : "1", chip->version & 0x0f);\r\nreturn tmp;\r\n}\r\nint snd_es1688_create(struct snd_card *card,\r\nstruct snd_es1688 *chip,\r\nunsigned long port,\r\nunsigned long mpu_port,\r\nint irq,\r\nint mpu_irq,\r\nint dma8,\r\nunsigned short hardware)\r\n{\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_es1688_dev_free,\r\n};\r\nint err;\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nchip->irq = -1;\r\nchip->dma8 = -1;\r\nchip->hardware = ES1688_HW_UNDEF;\r\nchip->res_port = request_region(port + 4, 12, "ES1688");\r\nif (chip->res_port == NULL) {\r\nsnd_printk(KERN_ERR "es1688: can't grab port 0x%lx\n", port + 4);\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\nerr = request_irq(irq, snd_es1688_interrupt, 0, "ES1688", (void *) chip);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "es1688: can't grab IRQ %d\n", irq);\r\ngoto exit;\r\n}\r\nchip->irq = irq;\r\nerr = request_dma(dma8, "ES1688");\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "es1688: can't grab DMA8 %d\n", dma8);\r\ngoto exit;\r\n}\r\nchip->dma8 = dma8;\r\nspin_lock_init(&chip->reg_lock);\r\nspin_lock_init(&chip->mixer_lock);\r\nchip->port = port;\r\nmpu_port &= ~0x000f;\r\nif (mpu_port < 0x300 || mpu_port > 0x330)\r\nmpu_port = 0;\r\nchip->mpu_port = mpu_port;\r\nchip->mpu_irq = mpu_irq;\r\nchip->hardware = hardware;\r\nerr = snd_es1688_probe(chip);\r\nif (err < 0)\r\ngoto exit;\r\nerr = snd_es1688_init(chip, 1);\r\nif (err < 0)\r\ngoto exit;\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nexit:\r\nif (err)\r\nsnd_es1688_free(chip);\r\nreturn err;\r\n}\r\nint snd_es1688_pcm(struct snd_card *card, struct snd_es1688 *chip,\r\nint device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(card, "ESx688", device, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_es1688_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_es1688_capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;\r\nsprintf(pcm->name, snd_es1688_chip_id(chip));\r\nchip->pcm = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_isa_data(),\r\n64*1024, 64*1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_info_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[9] = {\r\n"Mic", "Mic Master", "CD", "AOUT",\r\n"Mic1", "Mix", "Line", "Master"\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 8;\r\nif (uinfo->value.enumerated.item > 7)\r\nuinfo->value.enumerated.item = 7;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_get_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es1688 *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = snd_es1688_mixer_read(chip, ES1688_REC_DEV) & 7;\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_put_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es1688 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nunsigned char oval, nval;\r\nint change;\r\nif (ucontrol->value.enumerated.item[0] > 8)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\noval = snd_es1688_mixer_read(chip, ES1688_REC_DEV);\r\nnval = (ucontrol->value.enumerated.item[0] & 7) | (oval & ~15);\r\nchange = nval != oval;\r\nif (change)\r\nsnd_es1688_mixer_write(chip, ES1688_REC_DEV, nval);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_es1688_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es1688 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = (snd_es1688_mixer_read(chip, reg) >> shift) & mask;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (invert)\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es1688 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nint change;\r\nunsigned char oval, nval;\r\nnval = (ucontrol->value.integer.value[0] & mask);\r\nif (invert)\r\nnval = mask - nval;\r\nnval <<= shift;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\noval = snd_es1688_mixer_read(chip, reg);\r\nnval = (oval & ~(mask << shift)) | nval;\r\nchange = nval != oval;\r\nif (change)\r\nsnd_es1688_mixer_write(chip, reg, nval);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_es1688_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es1688 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nunsigned char left, right;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (left_reg < 0xa0)\r\nleft = snd_es1688_mixer_read(chip, left_reg);\r\nelse\r\nleft = snd_es1688_read(chip, left_reg);\r\nif (left_reg != right_reg) {\r\nif (right_reg < 0xa0)\r\nright = snd_es1688_mixer_read(chip, right_reg);\r\nelse\r\nright = snd_es1688_read(chip, right_reg);\r\n} else\r\nright = left;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = (left >> shift_left) & mask;\r\nucontrol->value.integer.value[1] = (right >> shift_right) & mask;\r\nif (invert) {\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es1688_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es1688 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nint change;\r\nunsigned char val1, val2, oval1, oval2;\r\nval1 = ucontrol->value.integer.value[0] & mask;\r\nval2 = ucontrol->value.integer.value[1] & mask;\r\nif (invert) {\r\nval1 = mask - val1;\r\nval2 = mask - val2;\r\n}\r\nval1 <<= shift_left;\r\nval2 <<= shift_right;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (left_reg != right_reg) {\r\nif (left_reg < 0xa0)\r\noval1 = snd_es1688_mixer_read(chip, left_reg);\r\nelse\r\noval1 = snd_es1688_read(chip, left_reg);\r\nif (right_reg < 0xa0)\r\noval2 = snd_es1688_mixer_read(chip, right_reg);\r\nelse\r\noval2 = snd_es1688_read(chip, right_reg);\r\nval1 = (oval1 & ~(mask << shift_left)) | val1;\r\nval2 = (oval2 & ~(mask << shift_right)) | val2;\r\nchange = val1 != oval1 || val2 != oval2;\r\nif (change) {\r\nif (left_reg < 0xa0)\r\nsnd_es1688_mixer_write(chip, left_reg, val1);\r\nelse\r\nsnd_es1688_write(chip, left_reg, val1);\r\nif (right_reg < 0xa0)\r\nsnd_es1688_mixer_write(chip, right_reg, val1);\r\nelse\r\nsnd_es1688_write(chip, right_reg, val1);\r\n}\r\n} else {\r\nif (left_reg < 0xa0)\r\noval1 = snd_es1688_mixer_read(chip, left_reg);\r\nelse\r\noval1 = snd_es1688_read(chip, left_reg);\r\nval1 = (oval1 & ~((mask << shift_left) | (mask << shift_right))) | val1 | val2;\r\nchange = val1 != oval1;\r\nif (change) {\r\nif (left_reg < 0xa0)\r\nsnd_es1688_mixer_write(chip, left_reg, val1);\r\nelse\r\nsnd_es1688_write(chip, left_reg, val1);\r\n}\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nint snd_es1688_mixer(struct snd_card *card, struct snd_es1688 *chip)\r\n{\r\nunsigned int idx;\r\nint err;\r\nunsigned char reg, val;\r\nif (snd_BUG_ON(!chip || !card))\r\nreturn -EINVAL;\r\nstrcpy(card->mixername, snd_es1688_chip_id(chip));\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_es1688_controls); idx++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_es1688_controls[idx], chip))) < 0)\r\nreturn err;\r\n}\r\nfor (idx = 0; idx < ES1688_INIT_TABLE_SIZE; idx++) {\r\nreg = snd_es1688_init_table[idx][0];\r\nval = snd_es1688_init_table[idx][1];\r\nif (reg < 0xa0)\r\nsnd_es1688_mixer_write(chip, reg, val);\r\nelse\r\nsnd_es1688_write(chip, reg, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init alsa_es1688_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_es1688_exit(void)\r\n{\r\n}
