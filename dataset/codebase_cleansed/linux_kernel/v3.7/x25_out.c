static int x25_pacsize_to_bytes(unsigned int pacsize)\r\n{\r\nint bytes = 1;\r\nif (!pacsize)\r\nreturn 128;\r\nwhile (pacsize-- > 0)\r\nbytes *= 2;\r\nreturn bytes;\r\n}\r\nint x25_output(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *skbn;\r\nunsigned char header[X25_EXT_MIN_LEN];\r\nint err, frontlen, len;\r\nint sent=0, noblock = X25_SKB_CB(skb)->flags & MSG_DONTWAIT;\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nint header_len = x25->neighbour->extended ? X25_EXT_MIN_LEN :\r\nX25_STD_MIN_LEN;\r\nint max_len = x25_pacsize_to_bytes(x25->facilities.pacsize_out);\r\nif (skb->len - header_len > max_len) {\r\nskb_copy_from_linear_data(skb, header, header_len);\r\nskb_pull(skb, header_len);\r\nfrontlen = skb_headroom(skb);\r\nwhile (skb->len > 0) {\r\nrelease_sock(sk);\r\nskbn = sock_alloc_send_skb(sk, frontlen + max_len,\r\nnoblock, &err);\r\nlock_sock(sk);\r\nif (!skbn) {\r\nif (err == -EWOULDBLOCK && noblock){\r\nkfree_skb(skb);\r\nreturn sent;\r\n}\r\nSOCK_DEBUG(sk, "x25_output: fragment alloc"\r\n" failed, err=%d, %d bytes "\r\n"sent\n", err, sent);\r\nreturn err;\r\n}\r\nskb_reserve(skbn, frontlen);\r\nlen = max_len > skb->len ? skb->len : max_len;\r\nskb_copy_from_linear_data(skb, skb_put(skbn, len), len);\r\nskb_pull(skb, len);\r\nskb_push(skbn, header_len);\r\nskb_copy_to_linear_data(skbn, header, header_len);\r\nif (skb->len > 0) {\r\nif (x25->neighbour->extended)\r\nskbn->data[3] |= X25_EXT_M_BIT;\r\nelse\r\nskbn->data[2] |= X25_STD_M_BIT;\r\n}\r\nskb_queue_tail(&sk->sk_write_queue, skbn);\r\nsent += len;\r\n}\r\nkfree_skb(skb);\r\n} else {\r\nskb_queue_tail(&sk->sk_write_queue, skb);\r\nsent = skb->len - header_len;\r\n}\r\nreturn sent;\r\n}\r\nstatic void x25_send_iframe(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nif (!skb)\r\nreturn;\r\nif (x25->neighbour->extended) {\r\nskb->data[2] = (x25->vs << 1) & 0xFE;\r\nskb->data[3] &= X25_EXT_M_BIT;\r\nskb->data[3] |= (x25->vr << 1) & 0xFE;\r\n} else {\r\nskb->data[2] &= X25_STD_M_BIT;\r\nskb->data[2] |= (x25->vs << 1) & 0x0E;\r\nskb->data[2] |= (x25->vr << 5) & 0xE0;\r\n}\r\nx25_transmit_link(skb, x25->neighbour);\r\n}\r\nvoid x25_kick(struct sock *sk)\r\n{\r\nstruct sk_buff *skb, *skbn;\r\nunsigned short start, end;\r\nint modulus;\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nif (x25->state != X25_STATE_3)\r\nreturn;\r\nif (skb_peek(&x25->interrupt_out_queue) != NULL &&\r\n!test_and_set_bit(X25_INTERRUPT_FLAG, &x25->flags)) {\r\nskb = skb_dequeue(&x25->interrupt_out_queue);\r\nx25_transmit_link(skb, x25->neighbour);\r\n}\r\nif (x25->condition & X25_COND_PEER_RX_BUSY)\r\nreturn;\r\nif (!skb_peek(&sk->sk_write_queue))\r\nreturn;\r\nmodulus = x25->neighbour->extended ? X25_EMODULUS : X25_SMODULUS;\r\nstart = skb_peek(&x25->ack_queue) ? x25->vs : x25->va;\r\nend = (x25->va + x25->facilities.winsize_out) % modulus;\r\nif (start == end)\r\nreturn;\r\nx25->vs = start;\r\nskb = skb_dequeue(&sk->sk_write_queue);\r\ndo {\r\nif ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL) {\r\nskb_queue_head(&sk->sk_write_queue, skb);\r\nbreak;\r\n}\r\nskb_set_owner_w(skbn, sk);\r\nx25_send_iframe(sk, skbn);\r\nx25->vs = (x25->vs + 1) % modulus;\r\nskb_queue_tail(&x25->ack_queue, skb);\r\n} while (x25->vs != end &&\r\n(skb = skb_dequeue(&sk->sk_write_queue)) != NULL);\r\nx25->vl = x25->vr;\r\nx25->condition &= ~X25_COND_ACK_PENDING;\r\nx25_stop_timer(sk);\r\n}\r\nvoid x25_enquiry_response(struct sock *sk)\r\n{\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nif (x25->condition & X25_COND_OWN_RX_BUSY)\r\nx25_write_internal(sk, X25_RNR);\r\nelse\r\nx25_write_internal(sk, X25_RR);\r\nx25->vl = x25->vr;\r\nx25->condition &= ~X25_COND_ACK_PENDING;\r\nx25_stop_timer(sk);\r\n}
