static int uvc_input_init(struct uvc_device *dev)\r\n{\r\nstruct input_dev *input;\r\nint ret;\r\ninput = input_allocate_device();\r\nif (input == NULL)\r\nreturn -ENOMEM;\r\nusb_make_path(dev->udev, dev->input_phys, sizeof(dev->input_phys));\r\nstrlcat(dev->input_phys, "/button", sizeof(dev->input_phys));\r\ninput->name = dev->name;\r\ninput->phys = dev->input_phys;\r\nusb_to_input_id(dev->udev, &input->id);\r\ninput->dev.parent = &dev->intf->dev;\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(KEY_CAMERA, input->keybit);\r\nif ((ret = input_register_device(input)) < 0)\r\ngoto error;\r\ndev->input = input;\r\nreturn 0;\r\nerror:\r\ninput_free_device(input);\r\nreturn ret;\r\n}\r\nstatic void uvc_input_cleanup(struct uvc_device *dev)\r\n{\r\nif (dev->input)\r\ninput_unregister_device(dev->input);\r\n}\r\nstatic void uvc_input_report_key(struct uvc_device *dev, unsigned int code,\r\nint value)\r\n{\r\nif (dev->input) {\r\ninput_report_key(dev->input, code, value);\r\ninput_sync(dev->input);\r\n}\r\n}\r\nstatic void uvc_event_streaming(struct uvc_device *dev, __u8 *data, int len)\r\n{\r\nif (len < 3) {\r\nuvc_trace(UVC_TRACE_STATUS, "Invalid streaming status event "\r\n"received.\n");\r\nreturn;\r\n}\r\nif (data[2] == 0) {\r\nif (len < 4)\r\nreturn;\r\nuvc_trace(UVC_TRACE_STATUS, "Button (intf %u) %s len %d\n",\r\ndata[1], data[3] ? "pressed" : "released", len);\r\nuvc_input_report_key(dev, KEY_CAMERA, data[3]);\r\n} else {\r\nuvc_trace(UVC_TRACE_STATUS, "Stream %u error event %02x %02x "\r\n"len %d.\n", data[1], data[2], data[3], len);\r\n}\r\n}\r\nstatic void uvc_event_control(struct uvc_device *dev, __u8 *data, int len)\r\n{\r\nchar *attrs[3] = { "value", "info", "failure" };\r\nif (len < 6 || data[2] != 0 || data[4] > 2) {\r\nuvc_trace(UVC_TRACE_STATUS, "Invalid control status event "\r\n"received.\n");\r\nreturn;\r\n}\r\nuvc_trace(UVC_TRACE_STATUS, "Control %u/%u %s change len %d.\n",\r\ndata[1], data[3], attrs[data[4]], len);\r\n}\r\nstatic void uvc_status_complete(struct urb *urb)\r\n{\r\nstruct uvc_device *dev = urb->context;\r\nint len, ret;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\ncase -EPROTO:\r\nreturn;\r\ndefault:\r\nuvc_printk(KERN_WARNING, "Non-zero status (%d) in status "\r\n"completion handler.\n", urb->status);\r\nreturn;\r\n}\r\nlen = urb->actual_length;\r\nif (len > 0) {\r\nswitch (dev->status[0] & 0x0f) {\r\ncase UVC_STATUS_TYPE_CONTROL:\r\nuvc_event_control(dev, dev->status, len);\r\nbreak;\r\ncase UVC_STATUS_TYPE_STREAMING:\r\nuvc_event_streaming(dev, dev->status, len);\r\nbreak;\r\ndefault:\r\nuvc_trace(UVC_TRACE_STATUS, "Unknown status event "\r\n"type %u.\n", dev->status[0]);\r\nbreak;\r\n}\r\n}\r\nurb->interval = dev->int_ep->desc.bInterval;\r\nif ((ret = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {\r\nuvc_printk(KERN_ERR, "Failed to resubmit status URB (%d).\n",\r\nret);\r\n}\r\n}\r\nint uvc_status_init(struct uvc_device *dev)\r\n{\r\nstruct usb_host_endpoint *ep = dev->int_ep;\r\nunsigned int pipe;\r\nint interval;\r\nif (ep == NULL)\r\nreturn 0;\r\nuvc_input_init(dev);\r\ndev->status = kzalloc(UVC_MAX_STATUS_SIZE, GFP_KERNEL);\r\nif (dev->status == NULL)\r\nreturn -ENOMEM;\r\ndev->int_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (dev->int_urb == NULL) {\r\nkfree(dev->status);\r\nreturn -ENOMEM;\r\n}\r\npipe = usb_rcvintpipe(dev->udev, ep->desc.bEndpointAddress);\r\ninterval = ep->desc.bInterval;\r\nif (interval > 16 && dev->udev->speed == USB_SPEED_HIGH &&\r\n(dev->quirks & UVC_QUIRK_STATUS_INTERVAL))\r\ninterval = fls(interval) - 1;\r\nusb_fill_int_urb(dev->int_urb, dev->udev, pipe,\r\ndev->status, UVC_MAX_STATUS_SIZE, uvc_status_complete,\r\ndev, interval);\r\nreturn 0;\r\n}\r\nvoid uvc_status_cleanup(struct uvc_device *dev)\r\n{\r\nusb_kill_urb(dev->int_urb);\r\nusb_free_urb(dev->int_urb);\r\nkfree(dev->status);\r\nuvc_input_cleanup(dev);\r\n}\r\nint uvc_status_start(struct uvc_device *dev)\r\n{\r\nif (dev->int_urb == NULL)\r\nreturn 0;\r\nreturn usb_submit_urb(dev->int_urb, GFP_KERNEL);\r\n}\r\nvoid uvc_status_stop(struct uvc_device *dev)\r\n{\r\nusb_kill_urb(dev->int_urb);\r\n}\r\nint uvc_status_suspend(struct uvc_device *dev)\r\n{\r\nif (atomic_read(&dev->users))\r\nusb_kill_urb(dev->int_urb);\r\nreturn 0;\r\n}\r\nint uvc_status_resume(struct uvc_device *dev)\r\n{\r\nif (dev->int_urb == NULL || atomic_read(&dev->users) == 0)\r\nreturn 0;\r\nreturn usb_submit_urb(dev->int_urb, GFP_NOIO);\r\n}
