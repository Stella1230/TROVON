static struct wdm_device *wdm_find_device(struct usb_interface *intf)\r\n{\r\nstruct wdm_device *desc;\r\nspin_lock(&wdm_device_list_lock);\r\nlist_for_each_entry(desc, &wdm_device_list, device_list)\r\nif (desc->intf == intf)\r\ngoto found;\r\ndesc = NULL;\r\nfound:\r\nspin_unlock(&wdm_device_list_lock);\r\nreturn desc;\r\n}\r\nstatic struct wdm_device *wdm_find_device_by_minor(int minor)\r\n{\r\nstruct wdm_device *desc;\r\nspin_lock(&wdm_device_list_lock);\r\nlist_for_each_entry(desc, &wdm_device_list, device_list)\r\nif (desc->intf->minor == minor)\r\ngoto found;\r\ndesc = NULL;\r\nfound:\r\nspin_unlock(&wdm_device_list_lock);\r\nreturn desc;\r\n}\r\nstatic void wdm_out_callback(struct urb *urb)\r\n{\r\nstruct wdm_device *desc;\r\ndesc = urb->context;\r\nspin_lock(&desc->iuspin);\r\ndesc->werr = urb->status;\r\nspin_unlock(&desc->iuspin);\r\nkfree(desc->outbuf);\r\ndesc->outbuf = NULL;\r\nclear_bit(WDM_IN_USE, &desc->flags);\r\nwake_up(&desc->wait);\r\n}\r\nstatic void wdm_in_callback(struct urb *urb)\r\n{\r\nstruct wdm_device *desc = urb->context;\r\nint status = urb->status;\r\nspin_lock(&desc->iuspin);\r\nclear_bit(WDM_RESPONDING, &desc->flags);\r\nif (status) {\r\nswitch (status) {\r\ncase -ENOENT:\r\ndev_dbg(&desc->intf->dev,\r\n"nonzero urb status received: -ENOENT");\r\ngoto skip_error;\r\ncase -ECONNRESET:\r\ndev_dbg(&desc->intf->dev,\r\n"nonzero urb status received: -ECONNRESET");\r\ngoto skip_error;\r\ncase -ESHUTDOWN:\r\ndev_dbg(&desc->intf->dev,\r\n"nonzero urb status received: -ESHUTDOWN");\r\ngoto skip_error;\r\ncase -EPIPE:\r\ndev_err(&desc->intf->dev,\r\n"nonzero urb status received: -EPIPE\n");\r\nbreak;\r\ndefault:\r\ndev_err(&desc->intf->dev,\r\n"Unexpected error %d\n", status);\r\nbreak;\r\n}\r\n}\r\ndesc->rerr = status;\r\ndesc->reslength = urb->actual_length;\r\nmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\r\ndesc->length += desc->reslength;\r\nskip_error:\r\nwake_up(&desc->wait);\r\nset_bit(WDM_READ, &desc->flags);\r\nspin_unlock(&desc->iuspin);\r\n}\r\nstatic void wdm_int_callback(struct urb *urb)\r\n{\r\nint rv = 0;\r\nint status = urb->status;\r\nstruct wdm_device *desc;\r\nstruct usb_cdc_notification *dr;\r\ndesc = urb->context;\r\ndr = (struct usb_cdc_notification *)desc->sbuf;\r\nif (status) {\r\nswitch (status) {\r\ncase -ESHUTDOWN:\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\nreturn;\r\ncase -EPIPE:\r\nset_bit(WDM_INT_STALL, &desc->flags);\r\ndev_err(&desc->intf->dev, "Stall on int endpoint\n");\r\ngoto sw;\r\ndefault:\r\ndev_err(&desc->intf->dev,\r\n"nonzero urb status received: %d\n", status);\r\nbreak;\r\n}\r\n}\r\nif (urb->actual_length < sizeof(struct usb_cdc_notification)) {\r\ndev_err(&desc->intf->dev, "wdm_int_callback - %d bytes\n",\r\nurb->actual_length);\r\ngoto exit;\r\n}\r\nswitch (dr->bNotificationType) {\r\ncase USB_CDC_NOTIFY_RESPONSE_AVAILABLE:\r\ndev_dbg(&desc->intf->dev,\r\n"NOTIFY_RESPONSE_AVAILABLE received: index %d len %d",\r\ndr->wIndex, dr->wLength);\r\nbreak;\r\ncase USB_CDC_NOTIFY_NETWORK_CONNECTION:\r\ndev_dbg(&desc->intf->dev,\r\n"NOTIFY_NETWORK_CONNECTION %s network",\r\ndr->wValue ? "connected to" : "disconnected from");\r\ngoto exit;\r\ndefault:\r\nclear_bit(WDM_POLL_RUNNING, &desc->flags);\r\ndev_err(&desc->intf->dev,\r\n"unknown notification %d received: index %d len %d\n",\r\ndr->bNotificationType, dr->wIndex, dr->wLength);\r\ngoto exit;\r\n}\r\nspin_lock(&desc->iuspin);\r\nclear_bit(WDM_READ, &desc->flags);\r\nset_bit(WDM_RESPONDING, &desc->flags);\r\nif (!test_bit(WDM_DISCONNECTING, &desc->flags)\r\n&& !test_bit(WDM_SUSPENDING, &desc->flags)) {\r\nrv = usb_submit_urb(desc->response, GFP_ATOMIC);\r\ndev_dbg(&desc->intf->dev, "%s: usb_submit_urb %d",\r\n__func__, rv);\r\n}\r\nspin_unlock(&desc->iuspin);\r\nif (rv < 0) {\r\nclear_bit(WDM_RESPONDING, &desc->flags);\r\nif (rv == -EPERM)\r\nreturn;\r\nif (rv == -ENOMEM) {\r\nsw:\r\nrv = schedule_work(&desc->rxwork);\r\nif (rv)\r\ndev_err(&desc->intf->dev,\r\n"Cannot schedule work\n");\r\n}\r\n}\r\nexit:\r\nrv = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (rv)\r\ndev_err(&desc->intf->dev,\r\n"%s - usb_submit_urb failed with result %d\n",\r\n__func__, rv);\r\n}\r\nstatic void kill_urbs(struct wdm_device *desc)\r\n{\r\nusb_kill_urb(desc->command);\r\nusb_kill_urb(desc->validity);\r\nusb_kill_urb(desc->response);\r\n}\r\nstatic void free_urbs(struct wdm_device *desc)\r\n{\r\nusb_free_urb(desc->validity);\r\nusb_free_urb(desc->response);\r\nusb_free_urb(desc->command);\r\n}\r\nstatic void cleanup(struct wdm_device *desc)\r\n{\r\nkfree(desc->sbuf);\r\nkfree(desc->inbuf);\r\nkfree(desc->orq);\r\nkfree(desc->irq);\r\nkfree(desc->ubuf);\r\nfree_urbs(desc);\r\nkfree(desc);\r\n}\r\nstatic ssize_t wdm_write\r\n(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nu8 *buf;\r\nint rv = -EMSGSIZE, r, we;\r\nstruct wdm_device *desc = file->private_data;\r\nstruct usb_ctrlrequest *req;\r\nif (count > desc->wMaxCommand)\r\ncount = desc->wMaxCommand;\r\nspin_lock_irq(&desc->iuspin);\r\nwe = desc->werr;\r\ndesc->werr = 0;\r\nspin_unlock_irq(&desc->iuspin);\r\nif (we < 0)\r\nreturn -EIO;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf) {\r\nrv = -ENOMEM;\r\ngoto outnl;\r\n}\r\nr = copy_from_user(buf, buffer, count);\r\nif (r > 0) {\r\nkfree(buf);\r\nrv = -EFAULT;\r\ngoto outnl;\r\n}\r\nr = mutex_lock_interruptible(&desc->wlock);\r\nrv = -ERESTARTSYS;\r\nif (r) {\r\nkfree(buf);\r\ngoto outnl;\r\n}\r\nif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\r\nkfree(buf);\r\nrv = -ENODEV;\r\ngoto outnp;\r\n}\r\nr = usb_autopm_get_interface(desc->intf);\r\nif (r < 0) {\r\nkfree(buf);\r\nrv = usb_translate_errors(r);\r\ngoto outnp;\r\n}\r\nif (!(file->f_flags & O_NONBLOCK))\r\nr = wait_event_interruptible(desc->wait, !test_bit(WDM_IN_USE,\r\n&desc->flags));\r\nelse\r\nif (test_bit(WDM_IN_USE, &desc->flags))\r\nr = -EAGAIN;\r\nif (test_bit(WDM_RESETTING, &desc->flags))\r\nr = -EIO;\r\nif (r < 0) {\r\nkfree(buf);\r\nrv = r;\r\ngoto out;\r\n}\r\nreq = desc->orq;\r\nusb_fill_control_urb(\r\ndesc->command,\r\ninterface_to_usbdev(desc->intf),\r\nusb_sndctrlpipe(interface_to_usbdev(desc->intf), 0),\r\n(unsigned char *)req,\r\nbuf,\r\ncount,\r\nwdm_out_callback,\r\ndesc\r\n);\r\nreq->bRequestType = (USB_DIR_OUT | USB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE);\r\nreq->bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;\r\nreq->wValue = 0;\r\nreq->wIndex = desc->inum;\r\nreq->wLength = cpu_to_le16(count);\r\nset_bit(WDM_IN_USE, &desc->flags);\r\ndesc->outbuf = buf;\r\nrv = usb_submit_urb(desc->command, GFP_KERNEL);\r\nif (rv < 0) {\r\nkfree(buf);\r\ndesc->outbuf = NULL;\r\nclear_bit(WDM_IN_USE, &desc->flags);\r\ndev_err(&desc->intf->dev, "Tx URB error: %d\n", rv);\r\nrv = usb_translate_errors(rv);\r\n} else {\r\ndev_dbg(&desc->intf->dev, "Tx URB has been submitted index=%d",\r\nreq->wIndex);\r\n}\r\nout:\r\nusb_autopm_put_interface(desc->intf);\r\noutnp:\r\nmutex_unlock(&desc->wlock);\r\noutnl:\r\nreturn rv < 0 ? rv : count;\r\n}\r\nstatic ssize_t wdm_read\r\n(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nint rv, cntr;\r\nint i = 0;\r\nstruct wdm_device *desc = file->private_data;\r\nrv = mutex_lock_interruptible(&desc->rlock);\r\nif (rv < 0)\r\nreturn -ERESTARTSYS;\r\ncntr = ACCESS_ONCE(desc->length);\r\nif (cntr == 0) {\r\ndesc->read = 0;\r\nretry:\r\nif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\r\nrv = -ENODEV;\r\ngoto err;\r\n}\r\ni++;\r\nif (file->f_flags & O_NONBLOCK) {\r\nif (!test_bit(WDM_READ, &desc->flags)) {\r\nrv = cntr ? cntr : -EAGAIN;\r\ngoto err;\r\n}\r\nrv = 0;\r\n} else {\r\nrv = wait_event_interruptible(desc->wait,\r\ntest_bit(WDM_READ, &desc->flags));\r\n}\r\nif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\r\nrv = -ENODEV;\r\ngoto err;\r\n}\r\nif (test_bit(WDM_RESETTING, &desc->flags)) {\r\nrv = -EIO;\r\ngoto err;\r\n}\r\nusb_mark_last_busy(interface_to_usbdev(desc->intf));\r\nif (rv < 0) {\r\nrv = -ERESTARTSYS;\r\ngoto err;\r\n}\r\nspin_lock_irq(&desc->iuspin);\r\nif (desc->rerr) {\r\ndesc->rerr = 0;\r\nspin_unlock_irq(&desc->iuspin);\r\nrv = -EIO;\r\ngoto err;\r\n}\r\nif (!test_bit(WDM_READ, &desc->flags)) {\r\nspin_unlock_irq(&desc->iuspin);\r\ngoto retry;\r\n}\r\nif (!desc->reslength) {\r\ndev_dbg(&desc->intf->dev, "%s: zero length - clearing WDM_READ\n", __func__);\r\nclear_bit(WDM_READ, &desc->flags);\r\nspin_unlock_irq(&desc->iuspin);\r\ngoto retry;\r\n}\r\ncntr = desc->length;\r\nspin_unlock_irq(&desc->iuspin);\r\n}\r\nif (cntr > count)\r\ncntr = count;\r\nrv = copy_to_user(buffer, desc->ubuf, cntr);\r\nif (rv > 0) {\r\nrv = -EFAULT;\r\ngoto err;\r\n}\r\nspin_lock_irq(&desc->iuspin);\r\nfor (i = 0; i < desc->length - cntr; i++)\r\ndesc->ubuf[i] = desc->ubuf[i + cntr];\r\ndesc->length -= cntr;\r\nif (!desc->length)\r\nclear_bit(WDM_READ, &desc->flags);\r\nspin_unlock_irq(&desc->iuspin);\r\nrv = cntr;\r\nerr:\r\nmutex_unlock(&desc->rlock);\r\nreturn rv;\r\n}\r\nstatic int wdm_flush(struct file *file, fl_owner_t id)\r\n{\r\nstruct wdm_device *desc = file->private_data;\r\nwait_event(desc->wait, !test_bit(WDM_IN_USE, &desc->flags));\r\nif (desc->werr < 0 && !test_bit(WDM_DISCONNECTING, &desc->flags))\r\ndev_err(&desc->intf->dev, "Error in flush path: %d\n",\r\ndesc->werr);\r\nreturn usb_translate_errors(desc->werr);\r\n}\r\nstatic unsigned int wdm_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct wdm_device *desc = file->private_data;\r\nunsigned long flags;\r\nunsigned int mask = 0;\r\nspin_lock_irqsave(&desc->iuspin, flags);\r\nif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\r\nmask = POLLHUP | POLLERR;\r\nspin_unlock_irqrestore(&desc->iuspin, flags);\r\ngoto desc_out;\r\n}\r\nif (test_bit(WDM_READ, &desc->flags))\r\nmask = POLLIN | POLLRDNORM;\r\nif (desc->rerr || desc->werr)\r\nmask |= POLLERR;\r\nif (!test_bit(WDM_IN_USE, &desc->flags))\r\nmask |= POLLOUT | POLLWRNORM;\r\nspin_unlock_irqrestore(&desc->iuspin, flags);\r\npoll_wait(file, &desc->wait, wait);\r\ndesc_out:\r\nreturn mask;\r\n}\r\nstatic int wdm_open(struct inode *inode, struct file *file)\r\n{\r\nint minor = iminor(inode);\r\nint rv = -ENODEV;\r\nstruct usb_interface *intf;\r\nstruct wdm_device *desc;\r\nmutex_lock(&wdm_mutex);\r\ndesc = wdm_find_device_by_minor(minor);\r\nif (!desc)\r\ngoto out;\r\nintf = desc->intf;\r\nif (test_bit(WDM_DISCONNECTING, &desc->flags))\r\ngoto out;\r\nfile->private_data = desc;\r\nrv = usb_autopm_get_interface(desc->intf);\r\nif (rv < 0) {\r\ndev_err(&desc->intf->dev, "Error autopm - %d\n", rv);\r\ngoto out;\r\n}\r\nmutex_lock(&desc->wlock);\r\nif (!desc->count++) {\r\ndesc->werr = 0;\r\ndesc->rerr = 0;\r\nrv = usb_submit_urb(desc->validity, GFP_KERNEL);\r\nif (rv < 0) {\r\ndesc->count--;\r\ndev_err(&desc->intf->dev,\r\n"Error submitting int urb - %d\n", rv);\r\nrv = usb_translate_errors(rv);\r\n}\r\n} else {\r\nrv = 0;\r\n}\r\nmutex_unlock(&desc->wlock);\r\nif (desc->count == 1)\r\ndesc->manage_power(intf, 1);\r\nusb_autopm_put_interface(desc->intf);\r\nout:\r\nmutex_unlock(&wdm_mutex);\r\nreturn rv;\r\n}\r\nstatic int wdm_release(struct inode *inode, struct file *file)\r\n{\r\nstruct wdm_device *desc = file->private_data;\r\nmutex_lock(&wdm_mutex);\r\nmutex_lock(&desc->wlock);\r\ndesc->count--;\r\nmutex_unlock(&desc->wlock);\r\nif (!desc->count) {\r\nif (!test_bit(WDM_DISCONNECTING, &desc->flags)) {\r\ndev_dbg(&desc->intf->dev, "wdm_release: cleanup");\r\nkill_urbs(desc);\r\ndesc->manage_power(desc->intf, 0);\r\n} else {\r\npr_debug(KBUILD_MODNAME " %s: device gone - cleaning up\n", __func__);\r\ncleanup(desc);\r\n}\r\n}\r\nmutex_unlock(&wdm_mutex);\r\nreturn 0;\r\n}\r\nstatic void wdm_rxwork(struct work_struct *work)\r\n{\r\nstruct wdm_device *desc = container_of(work, struct wdm_device, rxwork);\r\nunsigned long flags;\r\nint rv;\r\nspin_lock_irqsave(&desc->iuspin, flags);\r\nif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\r\nspin_unlock_irqrestore(&desc->iuspin, flags);\r\n} else {\r\nspin_unlock_irqrestore(&desc->iuspin, flags);\r\nrv = usb_submit_urb(desc->response, GFP_KERNEL);\r\nif (rv < 0 && rv != -EPERM) {\r\nspin_lock_irqsave(&desc->iuspin, flags);\r\nif (!test_bit(WDM_DISCONNECTING, &desc->flags))\r\nschedule_work(&desc->rxwork);\r\nspin_unlock_irqrestore(&desc->iuspin, flags);\r\n}\r\n}\r\n}\r\nstatic int wdm_create(struct usb_interface *intf, struct usb_endpoint_descriptor *ep,\r\nu16 bufsize, int (*manage_power)(struct usb_interface *, int))\r\n{\r\nint rv = -ENOMEM;\r\nstruct wdm_device *desc;\r\ndesc = kzalloc(sizeof(struct wdm_device), GFP_KERNEL);\r\nif (!desc)\r\ngoto out;\r\nINIT_LIST_HEAD(&desc->device_list);\r\nmutex_init(&desc->rlock);\r\nmutex_init(&desc->wlock);\r\nspin_lock_init(&desc->iuspin);\r\ninit_waitqueue_head(&desc->wait);\r\ndesc->wMaxCommand = bufsize;\r\ndesc->inum = cpu_to_le16((u16)intf->cur_altsetting->desc.bInterfaceNumber);\r\ndesc->intf = intf;\r\nINIT_WORK(&desc->rxwork, wdm_rxwork);\r\nrv = -EINVAL;\r\nif (!usb_endpoint_is_int_in(ep))\r\ngoto err;\r\ndesc->wMaxPacketSize = usb_endpoint_maxp(ep);\r\ndesc->orq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\r\nif (!desc->orq)\r\ngoto err;\r\ndesc->irq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\r\nif (!desc->irq)\r\ngoto err;\r\ndesc->validity = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!desc->validity)\r\ngoto err;\r\ndesc->response = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!desc->response)\r\ngoto err;\r\ndesc->command = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!desc->command)\r\ngoto err;\r\ndesc->ubuf = kmalloc(desc->wMaxCommand, GFP_KERNEL);\r\nif (!desc->ubuf)\r\ngoto err;\r\ndesc->sbuf = kmalloc(desc->wMaxPacketSize, GFP_KERNEL);\r\nif (!desc->sbuf)\r\ngoto err;\r\ndesc->inbuf = kmalloc(desc->wMaxCommand, GFP_KERNEL);\r\nif (!desc->inbuf)\r\ngoto err;\r\nusb_fill_int_urb(\r\ndesc->validity,\r\ninterface_to_usbdev(intf),\r\nusb_rcvintpipe(interface_to_usbdev(intf), ep->bEndpointAddress),\r\ndesc->sbuf,\r\ndesc->wMaxPacketSize,\r\nwdm_int_callback,\r\ndesc,\r\nep->bInterval\r\n);\r\ndesc->irq->bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);\r\ndesc->irq->bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;\r\ndesc->irq->wValue = 0;\r\ndesc->irq->wIndex = desc->inum;\r\ndesc->irq->wLength = cpu_to_le16(desc->wMaxCommand);\r\nusb_fill_control_urb(\r\ndesc->response,\r\ninterface_to_usbdev(intf),\r\nusb_rcvctrlpipe(interface_to_usbdev(desc->intf), 0),\r\n(unsigned char *)desc->irq,\r\ndesc->inbuf,\r\ndesc->wMaxCommand,\r\nwdm_in_callback,\r\ndesc\r\n);\r\ndesc->manage_power = manage_power;\r\nspin_lock(&wdm_device_list_lock);\r\nlist_add(&desc->device_list, &wdm_device_list);\r\nspin_unlock(&wdm_device_list_lock);\r\nrv = usb_register_dev(intf, &wdm_class);\r\nif (rv < 0)\r\ngoto err;\r\nelse\r\ndev_info(&intf->dev, "%s: USB WDM device\n", dev_name(intf->usb_dev));\r\nout:\r\nreturn rv;\r\nerr:\r\nspin_lock(&wdm_device_list_lock);\r\nlist_del(&desc->device_list);\r\nspin_unlock(&wdm_device_list_lock);\r\ncleanup(desc);\r\nreturn rv;\r\n}\r\nstatic int wdm_manage_power(struct usb_interface *intf, int on)\r\n{\r\nint rv = usb_autopm_get_interface(intf);\r\nif (rv < 0)\r\ngoto err;\r\nintf->needs_remote_wakeup = on;\r\nusb_autopm_put_interface(intf);\r\nerr:\r\nreturn rv;\r\n}\r\nstatic int wdm_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nint rv = -EINVAL;\r\nstruct usb_host_interface *iface;\r\nstruct usb_endpoint_descriptor *ep;\r\nstruct usb_cdc_dmm_desc *dmhd;\r\nu8 *buffer = intf->altsetting->extra;\r\nint buflen = intf->altsetting->extralen;\r\nu16 maxcom = WDM_DEFAULT_BUFSIZE;\r\nif (!buffer)\r\ngoto err;\r\nwhile (buflen > 2) {\r\nif (buffer[1] != USB_DT_CS_INTERFACE) {\r\ndev_err(&intf->dev, "skipping garbage\n");\r\ngoto next_desc;\r\n}\r\nswitch (buffer[2]) {\r\ncase USB_CDC_HEADER_TYPE:\r\nbreak;\r\ncase USB_CDC_DMM_TYPE:\r\ndmhd = (struct usb_cdc_dmm_desc *)buffer;\r\nmaxcom = le16_to_cpu(dmhd->wMaxCommand);\r\ndev_dbg(&intf->dev,\r\n"Finding maximum buffer length: %d", maxcom);\r\nbreak;\r\ndefault:\r\ndev_err(&intf->dev,\r\n"Ignoring extra header, type %d, length %d\n",\r\nbuffer[2], buffer[0]);\r\nbreak;\r\n}\r\nnext_desc:\r\nbuflen -= buffer[0];\r\nbuffer += buffer[0];\r\n}\r\niface = intf->cur_altsetting;\r\nif (iface->desc.bNumEndpoints != 1)\r\ngoto err;\r\nep = &iface->endpoint[0].desc;\r\nrv = wdm_create(intf, ep, maxcom, &wdm_manage_power);\r\nerr:\r\nreturn rv;\r\n}\r\nstruct usb_driver *usb_cdc_wdm_register(struct usb_interface *intf,\r\nstruct usb_endpoint_descriptor *ep,\r\nint bufsize,\r\nint (*manage_power)(struct usb_interface *, int))\r\n{\r\nint rv = -EINVAL;\r\nrv = wdm_create(intf, ep, bufsize, manage_power);\r\nif (rv < 0)\r\ngoto err;\r\nreturn &wdm_driver;\r\nerr:\r\nreturn ERR_PTR(rv);\r\n}\r\nstatic void wdm_disconnect(struct usb_interface *intf)\r\n{\r\nstruct wdm_device *desc;\r\nunsigned long flags;\r\nusb_deregister_dev(intf, &wdm_class);\r\ndesc = wdm_find_device(intf);\r\nmutex_lock(&wdm_mutex);\r\nspin_lock_irqsave(&desc->iuspin, flags);\r\nset_bit(WDM_DISCONNECTING, &desc->flags);\r\nset_bit(WDM_READ, &desc->flags);\r\nclear_bit(WDM_IN_USE, &desc->flags);\r\nspin_unlock_irqrestore(&desc->iuspin, flags);\r\nwake_up_all(&desc->wait);\r\nmutex_lock(&desc->rlock);\r\nmutex_lock(&desc->wlock);\r\nkill_urbs(desc);\r\ncancel_work_sync(&desc->rxwork);\r\nmutex_unlock(&desc->wlock);\r\nmutex_unlock(&desc->rlock);\r\nspin_lock(&wdm_device_list_lock);\r\nlist_del(&desc->device_list);\r\nspin_unlock(&wdm_device_list_lock);\r\nif (!desc->count)\r\ncleanup(desc);\r\nelse\r\ndev_dbg(&intf->dev, "%s: %d open files - postponing cleanup\n", __func__, desc->count);\r\nmutex_unlock(&wdm_mutex);\r\n}\r\nstatic int wdm_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct wdm_device *desc = wdm_find_device(intf);\r\nint rv = 0;\r\ndev_dbg(&desc->intf->dev, "wdm%d_suspend\n", intf->minor);\r\nif (!PMSG_IS_AUTO(message)) {\r\nmutex_lock(&desc->rlock);\r\nmutex_lock(&desc->wlock);\r\n}\r\nspin_lock_irq(&desc->iuspin);\r\nif (PMSG_IS_AUTO(message) &&\r\n(test_bit(WDM_IN_USE, &desc->flags)\r\n|| test_bit(WDM_RESPONDING, &desc->flags))) {\r\nspin_unlock_irq(&desc->iuspin);\r\nrv = -EBUSY;\r\n} else {\r\nset_bit(WDM_SUSPENDING, &desc->flags);\r\nspin_unlock_irq(&desc->iuspin);\r\nkill_urbs(desc);\r\ncancel_work_sync(&desc->rxwork);\r\n}\r\nif (!PMSG_IS_AUTO(message)) {\r\nmutex_unlock(&desc->wlock);\r\nmutex_unlock(&desc->rlock);\r\n}\r\nreturn rv;\r\n}\r\nstatic int recover_from_urb_loss(struct wdm_device *desc)\r\n{\r\nint rv = 0;\r\nif (desc->count) {\r\nrv = usb_submit_urb(desc->validity, GFP_NOIO);\r\nif (rv < 0)\r\ndev_err(&desc->intf->dev,\r\n"Error resume submitting int urb - %d\n", rv);\r\n}\r\nreturn rv;\r\n}\r\nstatic int wdm_resume(struct usb_interface *intf)\r\n{\r\nstruct wdm_device *desc = wdm_find_device(intf);\r\nint rv;\r\ndev_dbg(&desc->intf->dev, "wdm%d_resume\n", intf->minor);\r\nclear_bit(WDM_SUSPENDING, &desc->flags);\r\nrv = recover_from_urb_loss(desc);\r\nreturn rv;\r\n}\r\nstatic int wdm_pre_reset(struct usb_interface *intf)\r\n{\r\nstruct wdm_device *desc = wdm_find_device(intf);\r\nspin_lock_irq(&desc->iuspin);\r\nset_bit(WDM_RESETTING, &desc->flags);\r\nset_bit(WDM_READ, &desc->flags);\r\nclear_bit(WDM_IN_USE, &desc->flags);\r\ndesc->rerr = -EINTR;\r\nspin_unlock_irq(&desc->iuspin);\r\nwake_up_all(&desc->wait);\r\nmutex_lock(&desc->rlock);\r\nmutex_lock(&desc->wlock);\r\nkill_urbs(desc);\r\ncancel_work_sync(&desc->rxwork);\r\nreturn 0;\r\n}\r\nstatic int wdm_post_reset(struct usb_interface *intf)\r\n{\r\nstruct wdm_device *desc = wdm_find_device(intf);\r\nint rv;\r\nclear_bit(WDM_RESETTING, &desc->flags);\r\nrv = recover_from_urb_loss(desc);\r\nmutex_unlock(&desc->wlock);\r\nmutex_unlock(&desc->rlock);\r\nreturn 0;\r\n}
