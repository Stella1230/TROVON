static VOID UpdateTokenCount(register struct bcm_mini_adapter *Adapter)\r\n{\r\nULONG liCurrentTime;\r\nINT i = 0;\r\nstruct timeval tv;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TOKEN_COUNTS, DBG_LVL_ALL, "=====>\n");\r\nif(NULL == Adapter)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TOKEN_COUNTS, DBG_LVL_ALL, "Adapter found NULL!\n");\r\nreturn;\r\n}\r\ndo_gettimeofday(&tv);\r\nfor(i = 0; i < NO_OF_QUEUES; i++)\r\n{\r\nif(TRUE == Adapter->PackInfo[i].bValid &&\r\n(1 == Adapter->PackInfo[i].ucDirection))\r\n{\r\nliCurrentTime = ((tv.tv_sec-\r\nAdapter->PackInfo[i].stLastUpdateTokenAt.tv_sec)*1000 +\r\n(tv.tv_usec-Adapter->PackInfo[i].stLastUpdateTokenAt.tv_usec)/\r\n1000);\r\nif(0!=liCurrentTime)\r\n{\r\nAdapter->PackInfo[i].uiCurrentTokenCount += (ULONG)\r\n((Adapter->PackInfo[i].uiMaxAllowedRate) *\r\n((ULONG)((liCurrentTime)))/1000);\r\nmemcpy(&Adapter->PackInfo[i].stLastUpdateTokenAt,\r\n&tv, sizeof(struct timeval));\r\nAdapter->PackInfo[i].liLastUpdateTokenAt = liCurrentTime;\r\nif((Adapter->PackInfo[i].uiCurrentTokenCount) >=\r\nAdapter->PackInfo[i].uiMaxBucketSize)\r\n{\r\nAdapter->PackInfo[i].uiCurrentTokenCount =\r\nAdapter->PackInfo[i].uiMaxBucketSize;\r\n}\r\n}\r\n}\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TOKEN_COUNTS, DBG_LVL_ALL, "<=====\n");\r\nreturn;\r\n}\r\nstatic ULONG GetSFTokenCount(struct bcm_mini_adapter *Adapter, struct bcm_packet_info *psSF)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TOKEN_COUNTS, DBG_LVL_ALL, "IsPacketAllowedForFlow ===>");\r\nif(NULL == Adapter || (psSF < Adapter->PackInfo &&\r\n(uintptr_t)psSF > (uintptr_t) &Adapter->PackInfo[HiPriority]))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TOKEN_COUNTS, DBG_LVL_ALL, "IPAFF: Got wrong Parameters:Adapter: %p, QIndex: %zd\n", Adapter, (psSF-Adapter->PackInfo));\r\nreturn 0;\r\n}\r\nif(FALSE != psSF->bValid && psSF->ucDirection)\r\n{\r\nif(0 != psSF->uiCurrentTokenCount)\r\n{\r\nreturn psSF->uiCurrentTokenCount;\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TOKEN_COUNTS, DBG_LVL_ALL, "Not enough tokens in queue %zd Available %u\n",\r\npsSF-Adapter->PackInfo, psSF->uiCurrentTokenCount);\r\npsSF->uiPendedLast = 1;\r\n}\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TOKEN_COUNTS, DBG_LVL_ALL, "IPAFF: Queue %zd not valid\n", psSF-Adapter->PackInfo);\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TOKEN_COUNTS, DBG_LVL_ALL, "IsPacketAllowedForFlow <===");\r\nreturn 0;\r\n}\r\nstatic INT SendPacketFromQueue(struct bcm_mini_adapter *Adapter,\r\nstruct bcm_packet_info *psSF,\r\nstruct sk_buff* Packet)\r\n{\r\nINT Status=STATUS_FAILURE;\r\nUINT uiIndex =0,PktLen = 0;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, SEND_QUEUE, DBG_LVL_ALL, "=====>");\r\nif(!Adapter || !Packet || !psSF)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, SEND_QUEUE, DBG_LVL_ALL, "Got NULL Adapter or Packet");\r\nreturn -EINVAL;\r\n}\r\nif(psSF->liDrainCalculated==0)\r\n{\r\npsSF->liDrainCalculated = jiffies;\r\n}\r\nPktLen = Packet->len;\r\nStatus = SetupNextSend(Adapter, Packet, psSF->usVCID_Value);\r\nif(Status == 0)\r\n{\r\nfor(uiIndex = 0 ; uiIndex < MIBS_MAX_HIST_ENTRIES ; uiIndex++)\r\n{ if((PktLen <= MIBS_PKTSIZEHIST_RANGE*(uiIndex+1)) && (PktLen > MIBS_PKTSIZEHIST_RANGE*(uiIndex)))\r\nAdapter->aTxPktSizeHist[uiIndex]++;\r\n}\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, SEND_QUEUE, DBG_LVL_ALL, "<=====");\r\nreturn Status;\r\n}\r\nstatic VOID CheckAndSendPacketFromIndex(struct bcm_mini_adapter *Adapter, struct bcm_packet_info *psSF)\r\n{\r\nstruct sk_buff *QueuePacket=NULL;\r\nchar *pControlPacket = NULL;\r\nINT Status=0;\r\nint iPacketLen=0;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "%zd ====>", (psSF-Adapter->PackInfo));\r\nif((psSF != &Adapter->PackInfo[HiPriority]) && Adapter->LinkUpStatus && atomic_read(&psSF->uiPerSFTxResourceCount))\r\n{\r\nif(!psSF->ucDirection )\r\nreturn;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "UpdateTokenCount ");\r\nif(Adapter->IdleMode || Adapter->bPreparingForLowPowerMode)\r\nreturn;\r\nif(atomic_read(&Adapter->CurrNumFreeTxDesc) <= MINIMUM_PENDING_DESCRIPTORS)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, " No Free Tx Descriptor(%d) is available for Data pkt..",atomic_read(&Adapter->CurrNumFreeTxDesc));\r\nreturn ;\r\n}\r\nspin_lock_bh(&psSF->SFQueueLock);\r\nQueuePacket=psSF->FirstTxQueue;\r\nif(QueuePacket)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "Dequeuing Data Packet");\r\nif(psSF->bEthCSSupport)\r\niPacketLen = QueuePacket->len;\r\nelse\r\niPacketLen = QueuePacket->len-ETH_HLEN;\r\niPacketLen<<=3;\r\nif(iPacketLen <= GetSFTokenCount(Adapter, psSF))\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "Allowed bytes %d",\r\n(iPacketLen >> 3));\r\nDEQUEUEPACKET(psSF->FirstTxQueue,psSF->LastTxQueue);\r\npsSF->uiCurrentBytesOnHost -= (QueuePacket->len);\r\npsSF->uiCurrentPacketsOnHost--;\r\natomic_dec(&Adapter->TotalPacketCount);\r\nspin_unlock_bh(&psSF->SFQueueLock);\r\nStatus = SendPacketFromQueue(Adapter, psSF, QueuePacket);\r\npsSF->uiPendedLast = FALSE;\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "For Queue: %zd\n", psSF-Adapter->PackInfo);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "\nAvailable Tokens = %d required = %d\n",\r\npsSF->uiCurrentTokenCount, iPacketLen);\r\npsSF->uiPendedLast = TRUE;\r\nspin_unlock_bh(&psSF->SFQueueLock);\r\n}\r\n}\r\nelse\r\n{\r\nspin_unlock_bh(&psSF->SFQueueLock);\r\n}\r\n}\r\nelse\r\n{\r\nif((atomic_read(&Adapter->CurrNumFreeTxDesc) > 0 ) &&\r\n(atomic_read(&Adapter->index_rd_txcntrlpkt) !=\r\natomic_read(&Adapter->index_wr_txcntrlpkt))\r\n)\r\n{\r\npControlPacket = Adapter->txctlpacket\r\n[(atomic_read(&Adapter->index_rd_txcntrlpkt)%MAX_CNTRL_PKTS)];\r\nif(pControlPacket)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "Sending Control packet");\r\nStatus = SendControlPacket(Adapter, pControlPacket);\r\nif(STATUS_SUCCESS==Status)\r\n{\r\nspin_lock_bh(&psSF->SFQueueLock);\r\npsSF->NumOfPacketsSent++;\r\npsSF->uiSentBytes+=((struct bcm_leader *)pControlPacket)->PLength;\r\npsSF->uiSentPackets++;\r\natomic_dec(&Adapter->TotalPacketCount);\r\npsSF->uiCurrentBytesOnHost -= ((struct bcm_leader *)pControlPacket)->PLength;\r\npsSF->uiCurrentPacketsOnHost--;\r\natomic_inc(&Adapter->index_rd_txcntrlpkt);\r\nspin_unlock_bh(&psSF->SFQueueLock);\r\n}\r\nelse\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "SendControlPacket Failed\n");\r\n}\r\nelse\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, " Control Pkt is not available, Indexing is wrong....");\r\n}\r\n}\r\n}\r\n}\r\nVOID transmit_packets(struct bcm_mini_adapter *Adapter)\r\n{\r\nUINT uiPrevTotalCount = 0;\r\nint iIndex = 0;\r\nBOOLEAN exit_flag = TRUE ;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "=====>");\r\nif(NULL == Adapter)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX,TX_PACKETS, DBG_LVL_ALL, "Got NULL Adapter");\r\nreturn;\r\n}\r\nif(Adapter->device_removed == TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "Device removed");\r\nreturn;\r\n}\r\nBCM_DEBUG_PRINT (Adapter, DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "\nUpdateTokenCount ====>\n");\r\nUpdateTokenCount(Adapter);\r\nBCM_DEBUG_PRINT (Adapter, DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "\nPruneQueueAllSF ====>\n");\r\nPruneQueueAllSF(Adapter);\r\nuiPrevTotalCount = atomic_read(&Adapter->TotalPacketCount);\r\nfor(iIndex=HiPriority;iIndex>=0;iIndex--)\r\n{\r\nif( !uiPrevTotalCount || (TRUE == Adapter->device_removed))\r\nbreak;\r\nif(Adapter->PackInfo[iIndex].bValid &&\r\nAdapter->PackInfo[iIndex].uiPendedLast &&\r\nAdapter->PackInfo[iIndex].uiCurrentBytesOnHost)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "Calling CheckAndSendPacketFromIndex..");\r\nCheckAndSendPacketFromIndex(Adapter, &Adapter->PackInfo[iIndex]);\r\nuiPrevTotalCount--;\r\n}\r\n}\r\nwhile(uiPrevTotalCount > 0 && !Adapter->device_removed)\r\n{\r\nexit_flag = TRUE ;\r\nfor(iIndex=HiPriority;iIndex>=0;iIndex--)\r\n{\r\nif( !uiPrevTotalCount || (TRUE == Adapter->device_removed))\r\nbreak;\r\nif(Adapter->PackInfo[iIndex].bValid &&\r\nAdapter->PackInfo[iIndex].uiCurrentBytesOnHost &&\r\n!Adapter->PackInfo[iIndex].uiPendedLast )\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "Calling CheckAndSendPacketFromIndex..");\r\nCheckAndSendPacketFromIndex(Adapter, &Adapter->PackInfo[iIndex]);\r\nuiPrevTotalCount--;\r\nexit_flag = FALSE;\r\n}\r\n}\r\nif(Adapter->IdleMode || Adapter->bPreparingForLowPowerMode)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "In Idle Mode\n");\r\nbreak;\r\n}\r\nif(exit_flag == TRUE )\r\nbreak ;\r\n}\r\nupdate_per_cid_rx (Adapter);\r\nAdapter->txtransmit_running = 0;\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "<======");\r\n}
