static inline void superio_outb(int sioaddr, int reg, int val)\r\n{\r\noutb(reg, sioaddr);\r\noutb(val, sioaddr + 1);\r\n}\r\nstatic inline int superio_inb(int sioaddr, int reg)\r\n{\r\noutb(reg, sioaddr);\r\nreturn inb(sioaddr + 1);\r\n}\r\nstatic inline void superio_exit(int sioaddr)\r\n{\r\noutb(0x02, sioaddr);\r\noutb(0x02, sioaddr + 1);\r\n}\r\nstatic inline int pc87427_read8(struct pc87427_data *data, u8 ldi, u8 reg)\r\n{\r\nreturn inb(data->address[ldi] + reg);\r\n}\r\nstatic inline int pc87427_read8_bank(struct pc87427_data *data, u8 ldi,\r\nu8 bank, u8 reg)\r\n{\r\noutb(bank, data->address[ldi] + PC87427_REG_BANK);\r\nreturn inb(data->address[ldi] + reg);\r\n}\r\nstatic inline void pc87427_write8_bank(struct pc87427_data *data, u8 ldi,\r\nu8 bank, u8 reg, u8 value)\r\n{\r\noutb(bank, data->address[ldi] + PC87427_REG_BANK);\r\noutb(value, data->address[ldi] + reg);\r\n}\r\nstatic void pc87427_readall_fan(struct pc87427_data *data, u8 nr)\r\n{\r\nint iobase = data->address[LD_FAN];\r\noutb(BANK_FM(nr), iobase + PC87427_REG_BANK);\r\ndata->fan[nr] = inw(iobase + PC87427_REG_FAN);\r\ndata->fan_min[nr] = inw(iobase + PC87427_REG_FAN_MIN);\r\ndata->fan_status[nr] = inb(iobase + PC87427_REG_FAN_STATUS);\r\noutb(data->fan_status[nr], iobase + PC87427_REG_FAN_STATUS);\r\n}\r\nstatic inline unsigned long fan_from_reg(u16 reg)\r\n{\r\nreg &= 0xfffc;\r\nif (reg == 0x0000 || reg == 0xfffc)\r\nreturn 0;\r\nreturn 5400000UL / reg;\r\n}\r\nstatic inline u16 fan_to_reg(unsigned long val)\r\n{\r\nif (val < 83UL)\r\nreturn 0xffff;\r\nif (val >= 1350000UL)\r\nreturn 0x0004;\r\nreturn ((1350000UL + val / 2) / val) << 2;\r\n}\r\nstatic void pc87427_readall_pwm(struct pc87427_data *data, u8 nr)\r\n{\r\nint iobase = data->address[LD_FAN];\r\noutb(BANK_FC(nr), iobase + PC87427_REG_BANK);\r\ndata->pwm_enable[nr] = inb(iobase + PC87427_REG_PWM_ENABLE);\r\ndata->pwm[nr] = inb(iobase + PC87427_REG_PWM_DUTY);\r\n}\r\nstatic inline int pwm_enable_from_reg(u8 reg)\r\n{\r\nswitch (reg & PWM_ENABLE_MODE_MASK) {\r\ncase PWM_MODE_ON:\r\nreturn 0;\r\ncase PWM_MODE_MANUAL:\r\ncase PWM_MODE_OFF:\r\nreturn 1;\r\ncase PWM_MODE_AUTO:\r\nreturn 2;\r\ndefault:\r\nreturn -EPROTO;\r\n}\r\n}\r\nstatic inline u8 pwm_enable_to_reg(unsigned long val, u8 pwmval)\r\n{\r\nswitch (val) {\r\ndefault:\r\nreturn PWM_MODE_ON;\r\ncase 1:\r\nreturn pwmval ? PWM_MODE_MANUAL : PWM_MODE_OFF;\r\ncase 2:\r\nreturn PWM_MODE_AUTO;\r\n}\r\n}\r\nstatic void pc87427_readall_temp(struct pc87427_data *data, u8 nr)\r\n{\r\nint iobase = data->address[LD_TEMP];\r\noutb(BANK_TM(nr), iobase + PC87427_REG_BANK);\r\ndata->temp[nr] = le16_to_cpu(inw(iobase + PC87427_REG_TEMP));\r\ndata->temp_max[nr] = inb(iobase + PC87427_REG_TEMP_MAX);\r\ndata->temp_min[nr] = inb(iobase + PC87427_REG_TEMP_MIN);\r\ndata->temp_crit[nr] = inb(iobase + PC87427_REG_TEMP_CRIT);\r\ndata->temp_type[nr] = inb(iobase + PC87427_REG_TEMP_TYPE);\r\ndata->temp_status[nr] = inb(iobase + PC87427_REG_TEMP_STATUS);\r\noutb(data->temp_status[nr], iobase + PC87427_REG_TEMP_STATUS);\r\n}\r\nstatic inline unsigned int temp_type_from_reg(u8 reg)\r\n{\r\nswitch (reg & TEMP_TYPE_MASK) {\r\ncase TEMP_TYPE_THERMISTOR:\r\nreturn 4;\r\ncase TEMP_TYPE_REMOTE_DIODE:\r\ncase TEMP_TYPE_LOCAL_DIODE:\r\nreturn 3;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline long temp_from_reg(s16 reg)\r\n{\r\nreturn reg * 1000 / 256;\r\n}\r\nstatic inline long temp_from_reg8(s8 reg)\r\n{\r\nreturn reg * 1000;\r\n}\r\nstatic struct pc87427_data *pc87427_update_device(struct device *dev)\r\n{\r\nstruct pc87427_data *data = dev_get_drvdata(dev);\r\nint i;\r\nmutex_lock(&data->lock);\r\nif (!time_after(jiffies, data->last_updated + HZ)\r\n&& data->last_updated)\r\ngoto done;\r\nfor (i = 0; i < 8; i++) {\r\nif (!(data->fan_enabled & (1 << i)))\r\ncontinue;\r\npc87427_readall_fan(data, i);\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nif (!(data->pwm_enabled & (1 << i)))\r\ncontinue;\r\npc87427_readall_pwm(data, i);\r\n}\r\nfor (i = 0; i < 6; i++) {\r\nif (!(data->temp_enabled & (1 << i)))\r\ncontinue;\r\npc87427_readall_temp(data, i);\r\n}\r\ndata->last_updated = jiffies;\r\ndone:\r\nmutex_unlock(&data->lock);\r\nreturn data;\r\n}\r\nstatic ssize_t show_fan_input(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%lu\n", fan_from_reg(data->fan[nr]));\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%lu\n", fan_from_reg(data->fan_min[nr]));\r\n}\r\nstatic ssize_t show_fan_alarm(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%d\n", !!(data->fan_status[nr]\r\n& FAN_STATUS_LOSPD));\r\n}\r\nstatic ssize_t show_fan_fault(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%d\n", !!(data->fan_status[nr]\r\n& FAN_STATUS_STALL));\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct pc87427_data *data = dev_get_drvdata(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nunsigned long val;\r\nint iobase = data->address[LD_FAN];\r\nif (kstrtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\noutb(BANK_FM(nr), iobase + PC87427_REG_BANK);\r\noutb(0, iobase + PC87427_REG_FAN_STATUS);\r\ndata->fan_min[nr] = fan_to_reg(val);\r\noutw(data->fan_min[nr], iobase + PC87427_REG_FAN_MIN);\r\noutb(FAN_STATUS_MONEN, iobase + PC87427_REG_FAN_STATUS);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic void update_pwm_enable(struct pc87427_data *data, int nr, u8 mode)\r\n{\r\nint iobase = data->address[LD_FAN];\r\ndata->pwm_enable[nr] &= ~PWM_ENABLE_MODE_MASK;\r\ndata->pwm_enable[nr] |= mode;\r\noutb(data->pwm_enable[nr], iobase + PC87427_REG_PWM_ENABLE);\r\n}\r\nstatic ssize_t show_pwm_enable(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nint pwm_enable;\r\npwm_enable = pwm_enable_from_reg(data->pwm_enable[nr]);\r\nif (pwm_enable < 0)\r\nreturn pwm_enable;\r\nreturn sprintf(buf, "%d\n", pwm_enable);\r\n}\r\nstatic ssize_t set_pwm_enable(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct pc87427_data *data = dev_get_drvdata(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nunsigned long val;\r\nif (kstrtoul(buf, 10, &val) < 0 || val > 2)\r\nreturn -EINVAL;\r\nif (val == 2 && !(data->pwm_auto_ok & (1 << nr)))\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\npc87427_readall_pwm(data, nr);\r\nupdate_pwm_enable(data, nr, pwm_enable_to_reg(val, data->pwm[nr]));\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%d\n", (int)data->pwm[nr]);\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct pc87427_data *data = dev_get_drvdata(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nunsigned long val;\r\nint iobase = data->address[LD_FAN];\r\nu8 mode;\r\nif (kstrtoul(buf, 10, &val) < 0 || val > 0xff)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\npc87427_readall_pwm(data, nr);\r\nmode = data->pwm_enable[nr] & PWM_ENABLE_MODE_MASK;\r\nif (mode != PWM_MODE_MANUAL && mode != PWM_MODE_OFF) {\r\ndev_notice(dev, "Can't set PWM%d duty cycle while not in "\r\n"manual mode\n", nr + 1);\r\nmutex_unlock(&data->lock);\r\nreturn -EPERM;\r\n}\r\nif (mode == PWM_MODE_MANUAL && val == 0) {\r\nupdate_pwm_enable(data, nr, PWM_MODE_OFF);\r\nmode = PWM_MODE_OFF;\r\ndev_dbg(dev, "Switching PWM%d from %s to %s\n", nr + 1,\r\n"manual", "off");\r\n} else if (mode == PWM_MODE_OFF && val != 0) {\r\nupdate_pwm_enable(data, nr, PWM_MODE_MANUAL);\r\nmode = PWM_MODE_MANUAL;\r\ndev_dbg(dev, "Switching PWM%d from %s to %s\n", nr + 1,\r\n"off", "manual");\r\n}\r\ndata->pwm[nr] = val;\r\nif (mode == PWM_MODE_MANUAL)\r\noutb(val, iobase + PC87427_REG_PWM_DUTY);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_input(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%ld\n", temp_from_reg(data->temp[nr]));\r\n}\r\nstatic ssize_t show_temp_min(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%ld\n", temp_from_reg8(data->temp_min[nr]));\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%ld\n", temp_from_reg8(data->temp_max[nr]));\r\n}\r\nstatic ssize_t show_temp_crit(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%ld\n", temp_from_reg8(data->temp_crit[nr]));\r\n}\r\nstatic ssize_t show_temp_type(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%u\n", temp_type_from_reg(data->temp_type[nr]));\r\n}\r\nstatic ssize_t show_temp_min_alarm(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%d\n", !!(data->temp_status[nr]\r\n& TEMP_STATUS_LOWFLG));\r\n}\r\nstatic ssize_t show_temp_max_alarm(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%d\n", !!(data->temp_status[nr]\r\n& TEMP_STATUS_HIGHFLG));\r\n}\r\nstatic ssize_t show_temp_crit_alarm(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%d\n", !!(data->temp_status[nr]\r\n& TEMP_STATUS_CRITFLG));\r\n}\r\nstatic ssize_t show_temp_fault(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = pc87427_update_device(dev);\r\nint nr = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%d\n", !!(data->temp_status[nr]\r\n& TEMP_STATUS_SENSERR));\r\n}\r\nstatic ssize_t show_name(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct pc87427_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", data->name);\r\n}\r\nstatic int __devinit pc87427_request_regions(struct platform_device *pdev,\r\nint count)\r\n{\r\nstruct resource *res;\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nres = platform_get_resource(pdev, IORESOURCE_IO, i);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Missing resource #%d\n", i);\r\nreturn -ENOENT;\r\n}\r\nif (!devm_request_region(&pdev->dev, res->start,\r\nresource_size(res), DRVNAME)) {\r\ndev_err(&pdev->dev,\r\n"Failed to request region 0x%lx-0x%lx\n",\r\n(unsigned long)res->start,\r\n(unsigned long)res->end);\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __devinit pc87427_init_device(struct device *dev)\r\n{\r\nstruct pc87427_sio_data *sio_data = dev->platform_data;\r\nstruct pc87427_data *data = dev_get_drvdata(dev);\r\nint i;\r\nu8 reg;\r\nreg = pc87427_read8(data, LD_FAN, PC87427_REG_BANK);\r\nif (!(reg & 0x80))\r\ndev_warn(dev, "%s module not ready!\n", "FMC");\r\nfor (i = 0; i < 8; i++) {\r\nif (!(sio_data->has_fanin & (1 << i)))\r\ncontinue;\r\nreg = pc87427_read8_bank(data, LD_FAN, BANK_FM(i),\r\nPC87427_REG_FAN_STATUS);\r\nif (reg & FAN_STATUS_MONEN)\r\ndata->fan_enabled |= (1 << i);\r\n}\r\nif (!data->fan_enabled) {\r\ndev_dbg(dev, "Enabling monitoring of all fans\n");\r\nfor (i = 0; i < 8; i++) {\r\nif (!(sio_data->has_fanin & (1 << i)))\r\ncontinue;\r\npc87427_write8_bank(data, LD_FAN, BANK_FM(i),\r\nPC87427_REG_FAN_STATUS,\r\nFAN_STATUS_MONEN);\r\n}\r\ndata->fan_enabled = sio_data->has_fanin;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nif (!(sio_data->has_fanout & (1 << i)))\r\ncontinue;\r\nreg = pc87427_read8_bank(data, LD_FAN, BANK_FC(i),\r\nPC87427_REG_PWM_ENABLE);\r\nif (reg & PWM_ENABLE_CTLEN)\r\ndata->pwm_enabled |= (1 << i);\r\nif ((reg & PWM_ENABLE_MODE_MASK) == PWM_MODE_AUTO) {\r\ndev_dbg(dev, "PWM%d is in automatic control mode\n",\r\ni + 1);\r\ndata->pwm_auto_ok |= (1 << i);\r\n}\r\n}\r\nreg = pc87427_read8(data, LD_TEMP, PC87427_REG_BANK);\r\nif (!(reg & 0x80))\r\ndev_warn(dev, "%s module not ready!\n", "HMC");\r\nfor (i = 0; i < 6; i++) {\r\nreg = pc87427_read8_bank(data, LD_TEMP, BANK_TM(i),\r\nPC87427_REG_TEMP_STATUS);\r\nif (reg & TEMP_STATUS_CHANEN)\r\ndata->temp_enabled |= (1 << i);\r\n}\r\n}\r\nstatic void pc87427_remove_files(struct device *dev)\r\n{\r\nstruct pc87427_data *data = dev_get_drvdata(dev);\r\nint i;\r\ndevice_remove_file(dev, &dev_attr_name);\r\nfor (i = 0; i < 8; i++) {\r\nif (!(data->fan_enabled & (1 << i)))\r\ncontinue;\r\nsysfs_remove_group(&dev->kobj, &pc87427_group_fan[i]);\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nif (!(data->pwm_enabled & (1 << i)))\r\ncontinue;\r\nsysfs_remove_group(&dev->kobj, &pc87427_group_pwm[i]);\r\n}\r\nfor (i = 0; i < 6; i++) {\r\nif (!(data->temp_enabled & (1 << i)))\r\ncontinue;\r\nsysfs_remove_group(&dev->kobj, &pc87427_group_temp[i]);\r\n}\r\n}\r\nstatic int __devinit pc87427_probe(struct platform_device *pdev)\r\n{\r\nstruct pc87427_sio_data *sio_data = pdev->dev.platform_data;\r\nstruct pc87427_data *data;\r\nint i, err, res_count;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct pc87427_data),\r\nGFP_KERNEL);\r\nif (!data) {\r\npr_err("Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->address[0] = sio_data->address[0];\r\ndata->address[1] = sio_data->address[1];\r\nres_count = (data->address[0] != 0) + (data->address[1] != 0);\r\nerr = pc87427_request_regions(pdev, res_count);\r\nif (err)\r\nreturn err;\r\nmutex_init(&data->lock);\r\ndata->name = "pc87427";\r\nplatform_set_drvdata(pdev, data);\r\npc87427_init_device(&pdev->dev);\r\nerr = device_create_file(&pdev->dev, &dev_attr_name);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < 8; i++) {\r\nif (!(data->fan_enabled & (1 << i)))\r\ncontinue;\r\nerr = sysfs_create_group(&pdev->dev.kobj,\r\n&pc87427_group_fan[i]);\r\nif (err)\r\ngoto exit_remove_files;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nif (!(data->pwm_enabled & (1 << i)))\r\ncontinue;\r\nerr = sysfs_create_group(&pdev->dev.kobj,\r\n&pc87427_group_pwm[i]);\r\nif (err)\r\ngoto exit_remove_files;\r\n}\r\nfor (i = 0; i < 6; i++) {\r\nif (!(data->temp_enabled & (1 << i)))\r\ncontinue;\r\nerr = sysfs_create_group(&pdev->dev.kobj,\r\n&pc87427_group_temp[i]);\r\nif (err)\r\ngoto exit_remove_files;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ndev_err(&pdev->dev, "Class registration failed (%d)\n", err);\r\ngoto exit_remove_files;\r\n}\r\nreturn 0;\r\nexit_remove_files:\r\npc87427_remove_files(&pdev->dev);\r\nreturn err;\r\n}\r\nstatic int __devexit pc87427_remove(struct platform_device *pdev)\r\n{\r\nstruct pc87427_data *data = platform_get_drvdata(pdev);\r\nhwmon_device_unregister(data->hwmon_dev);\r\npc87427_remove_files(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int __init pc87427_device_add(const struct pc87427_sio_data *sio_data)\r\n{\r\nstruct resource res[2] = {\r\n{ .flags = IORESOURCE_IO },\r\n{ .flags = IORESOURCE_IO },\r\n};\r\nint err, i, res_count;\r\nres_count = 0;\r\nfor (i = 0; i < 2; i++) {\r\nif (!sio_data->address[i])\r\ncontinue;\r\nres[res_count].start = sio_data->address[i];\r\nres[res_count].end = sio_data->address[i] + REGION_LENGTH - 1;\r\nres[res_count].name = logdev_str[i];\r\nerr = acpi_check_resource_conflict(&res[res_count]);\r\nif (err)\r\ngoto exit;\r\nres_count++;\r\n}\r\npdev = platform_device_alloc(DRVNAME, res[0].start);\r\nif (!pdev) {\r\nerr = -ENOMEM;\r\npr_err("Device allocation failed\n");\r\ngoto exit;\r\n}\r\nerr = platform_device_add_resources(pdev, res, res_count);\r\nif (err) {\r\npr_err("Device resource addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add_data(pdev, sio_data,\r\nsizeof(struct pc87427_sio_data));\r\nif (err) {\r\npr_err("Platform data allocation failed\n");\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\npr_err("Device addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(pdev);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __init pc87427_find(int sioaddr, struct pc87427_sio_data *sio_data)\r\n{\r\nu16 val;\r\nu8 cfg, cfg_b;\r\nint i, err = 0;\r\nval = force_id ? force_id : superio_inb(sioaddr, SIOREG_DEVID);\r\nif (val != 0xf2) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nsio_data->address[i] = 0;\r\nsuperio_outb(sioaddr, SIOREG_LDSEL, logdev[i]);\r\nval = superio_inb(sioaddr, SIOREG_ACT);\r\nif (!(val & 0x01)) {\r\npr_info("Logical device 0x%02x not activated\n",\r\nlogdev[i]);\r\ncontinue;\r\n}\r\nval = superio_inb(sioaddr, SIOREG_MAP);\r\nif (val & 0x01) {\r\npr_warn("Logical device 0x%02x is memory-mapped, "\r\n"can't use\n", logdev[i]);\r\ncontinue;\r\n}\r\nval = (superio_inb(sioaddr, SIOREG_IOBASE) << 8)\r\n| superio_inb(sioaddr, SIOREG_IOBASE + 1);\r\nif (!val) {\r\npr_info("I/O base address not set for logical device "\r\n"0x%02x\n", logdev[i]);\r\ncontinue;\r\n}\r\nsio_data->address[i] = val;\r\n}\r\nif (!sio_data->address[0] && !sio_data->address[1]) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nsio_data->has_fanin = (1 << 2) | (1 << 3);\r\ncfg = superio_inb(sioaddr, SIOREG_CF2);\r\nif (!(cfg & (1 << 3)))\r\nsio_data->has_fanin |= (1 << 0);\r\nif (!(cfg & (1 << 2)))\r\nsio_data->has_fanin |= (1 << 4);\r\ncfg = superio_inb(sioaddr, SIOREG_CFD);\r\nif (!(cfg & (1 << 0)))\r\nsio_data->has_fanin |= (1 << 1);\r\ncfg = superio_inb(sioaddr, SIOREG_CF4);\r\nif (!(cfg & (1 << 0)))\r\nsio_data->has_fanin |= (1 << 7);\r\ncfg_b = superio_inb(sioaddr, SIOREG_CFB);\r\nif (!(cfg & (1 << 1)) && (cfg_b & (1 << 3)))\r\nsio_data->has_fanin |= (1 << 5);\r\ncfg = superio_inb(sioaddr, SIOREG_CF3);\r\nif ((cfg & (1 << 3)) && !(cfg_b & (1 << 5)))\r\nsio_data->has_fanin |= (1 << 6);\r\nsio_data->has_fanout = (1 << 0);\r\nif (cfg_b & (1 << 0))\r\nsio_data->has_fanout |= (1 << 3);\r\ncfg = superio_inb(sioaddr, SIOREG_CFC);\r\nif (!(cfg & (1 << 4))) {\r\nif (cfg_b & (1 << 1))\r\nsio_data->has_fanout |= (1 << 1);\r\nif (cfg_b & (1 << 2))\r\nsio_data->has_fanout |= (1 << 2);\r\n}\r\ncfg = superio_inb(sioaddr, SIOREG_CF5);\r\nif (cfg & (1 << 6))\r\nsio_data->has_fanout |= (1 << 1);\r\nif (cfg & (1 << 5))\r\nsio_data->has_fanout |= (1 << 2);\r\nexit:\r\nsuperio_exit(sioaddr);\r\nreturn err;\r\n}\r\nstatic int __init pc87427_init(void)\r\n{\r\nint err;\r\nstruct pc87427_sio_data sio_data;\r\nif (pc87427_find(0x2e, &sio_data)\r\n&& pc87427_find(0x4e, &sio_data))\r\nreturn -ENODEV;\r\nerr = platform_driver_register(&pc87427_driver);\r\nif (err)\r\ngoto exit;\r\nerr = pc87427_device_add(&sio_data);\r\nif (err)\r\ngoto exit_driver;\r\nreturn 0;\r\nexit_driver:\r\nplatform_driver_unregister(&pc87427_driver);\r\nexit:\r\nreturn err;\r\n}\r\nstatic void __exit pc87427_exit(void)\r\n{\r\nplatform_device_unregister(pdev);\r\nplatform_driver_unregister(&pc87427_driver);\r\n}
