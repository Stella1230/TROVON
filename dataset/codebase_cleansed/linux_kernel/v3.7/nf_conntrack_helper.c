static int nf_conntrack_helper_init_sysctl(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\ntable = kmemdup(helper_sysctl_table, sizeof(helper_sysctl_table),\r\nGFP_KERNEL);\r\nif (!table)\r\ngoto out;\r\ntable[0].data = &net->ct.sysctl_auto_assign_helper;\r\nnet->ct.helper_sysctl_header =\r\nregister_net_sysctl(net, "net/netfilter", table);\r\nif (!net->ct.helper_sysctl_header) {\r\npr_err("nf_conntrack_helper: can't register to sysctl.\n");\r\ngoto out_register;\r\n}\r\nreturn 0;\r\nout_register:\r\nkfree(table);\r\nout:\r\nreturn -ENOMEM;\r\n}\r\nstatic void nf_conntrack_helper_fini_sysctl(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\ntable = net->ct.helper_sysctl_header->ctl_table_arg;\r\nunregister_net_sysctl_table(net->ct.helper_sysctl_header);\r\nkfree(table);\r\n}\r\nstatic int nf_conntrack_helper_init_sysctl(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void nf_conntrack_helper_fini_sysctl(struct net *net)\r\n{\r\n}\r\nstatic unsigned int helper_hash(const struct nf_conntrack_tuple *tuple)\r\n{\r\nreturn (((tuple->src.l3num << 8) | tuple->dst.protonum) ^\r\n(__force __u16)tuple->src.u.all) % nf_ct_helper_hsize;\r\n}\r\nstatic struct nf_conntrack_helper *\r\n__nf_ct_helper_find(const struct nf_conntrack_tuple *tuple)\r\n{\r\nstruct nf_conntrack_helper *helper;\r\nstruct nf_conntrack_tuple_mask mask = { .src.u.all = htons(0xFFFF) };\r\nstruct hlist_node *n;\r\nunsigned int h;\r\nif (!nf_ct_helper_count)\r\nreturn NULL;\r\nh = helper_hash(tuple);\r\nhlist_for_each_entry_rcu(helper, n, &nf_ct_helper_hash[h], hnode) {\r\nif (nf_ct_tuple_src_mask_cmp(tuple, &helper->tuple, &mask))\r\nreturn helper;\r\n}\r\nreturn NULL;\r\n}\r\nstruct nf_conntrack_helper *\r\n__nf_conntrack_helper_find(const char *name, u16 l3num, u8 protonum)\r\n{\r\nstruct nf_conntrack_helper *h;\r\nstruct hlist_node *n;\r\nunsigned int i;\r\nfor (i = 0; i < nf_ct_helper_hsize; i++) {\r\nhlist_for_each_entry_rcu(h, n, &nf_ct_helper_hash[i], hnode) {\r\nif (!strcmp(h->name, name) &&\r\nh->tuple.src.l3num == l3num &&\r\nh->tuple.dst.protonum == protonum)\r\nreturn h;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct nf_conntrack_helper *\r\nnf_conntrack_helper_try_module_get(const char *name, u16 l3num, u8 protonum)\r\n{\r\nstruct nf_conntrack_helper *h;\r\nh = __nf_conntrack_helper_find(name, l3num, protonum);\r\n#ifdef CONFIG_MODULES\r\nif (h == NULL) {\r\nif (request_module("nfct-helper-%s", name) == 0)\r\nh = __nf_conntrack_helper_find(name, l3num, protonum);\r\n}\r\n#endif\r\nif (h != NULL && !try_module_get(h->me))\r\nh = NULL;\r\nreturn h;\r\n}\r\nstruct nf_conn_help *\r\nnf_ct_helper_ext_add(struct nf_conn *ct,\r\nstruct nf_conntrack_helper *helper, gfp_t gfp)\r\n{\r\nstruct nf_conn_help *help;\r\nhelp = nf_ct_ext_add_length(ct, NF_CT_EXT_HELPER,\r\nhelper->data_len, gfp);\r\nif (help)\r\nINIT_HLIST_HEAD(&help->expectations);\r\nelse\r\npr_debug("failed to add helper extension area");\r\nreturn help;\r\n}\r\nint __nf_ct_try_assign_helper(struct nf_conn *ct, struct nf_conn *tmpl,\r\ngfp_t flags)\r\n{\r\nstruct nf_conntrack_helper *helper = NULL;\r\nstruct nf_conn_help *help;\r\nstruct net *net = nf_ct_net(ct);\r\nint ret = 0;\r\nif (test_bit(IPS_HELPER_BIT, &ct->status))\r\nreturn 0;\r\nif (tmpl != NULL) {\r\nhelp = nfct_help(tmpl);\r\nif (help != NULL) {\r\nhelper = help->helper;\r\nset_bit(IPS_HELPER_BIT, &ct->status);\r\n}\r\n}\r\nhelp = nfct_help(ct);\r\nif (net->ct.sysctl_auto_assign_helper && helper == NULL) {\r\nhelper = __nf_ct_helper_find(&ct->tuplehash[IP_CT_DIR_REPLY].tuple);\r\nif (unlikely(!net->ct.auto_assign_helper_warned && helper)) {\r\npr_info("nf_conntrack: automatic helper "\r\n"assignment is deprecated and it will "\r\n"be removed soon. Use the iptables CT target "\r\n"to attach helpers instead.\n");\r\nnet->ct.auto_assign_helper_warned = true;\r\n}\r\n}\r\nif (helper == NULL) {\r\nif (help)\r\nRCU_INIT_POINTER(help->helper, NULL);\r\ngoto out;\r\n}\r\nif (help == NULL) {\r\nhelp = nf_ct_helper_ext_add(ct, helper, flags);\r\nif (help == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n} else {\r\nif (help->helper != helper) {\r\nRCU_INIT_POINTER(help->helper, NULL);\r\ngoto out;\r\n}\r\n}\r\nrcu_assign_pointer(help->helper, helper);\r\nout:\r\nreturn ret;\r\n}\r\nstatic inline int unhelp(struct nf_conntrack_tuple_hash *i,\r\nconst struct nf_conntrack_helper *me)\r\n{\r\nstruct nf_conn *ct = nf_ct_tuplehash_to_ctrack(i);\r\nstruct nf_conn_help *help = nfct_help(ct);\r\nif (help && rcu_dereference_protected(\r\nhelp->helper,\r\nlockdep_is_held(&nf_conntrack_lock)\r\n) == me) {\r\nnf_conntrack_event(IPCT_HELPER, ct);\r\nRCU_INIT_POINTER(help->helper, NULL);\r\n}\r\nreturn 0;\r\n}\r\nvoid nf_ct_helper_destroy(struct nf_conn *ct)\r\n{\r\nstruct nf_conn_help *help = nfct_help(ct);\r\nstruct nf_conntrack_helper *helper;\r\nif (help) {\r\nrcu_read_lock();\r\nhelper = rcu_dereference(help->helper);\r\nif (helper && helper->destroy)\r\nhelper->destroy(ct);\r\nrcu_read_unlock();\r\n}\r\n}\r\nvoid nf_ct_helper_expectfn_register(struct nf_ct_helper_expectfn *n)\r\n{\r\nspin_lock_bh(&nf_conntrack_lock);\r\nlist_add_rcu(&n->head, &nf_ct_helper_expectfn_list);\r\nspin_unlock_bh(&nf_conntrack_lock);\r\n}\r\nvoid nf_ct_helper_expectfn_unregister(struct nf_ct_helper_expectfn *n)\r\n{\r\nspin_lock_bh(&nf_conntrack_lock);\r\nlist_del_rcu(&n->head);\r\nspin_unlock_bh(&nf_conntrack_lock);\r\n}\r\nstruct nf_ct_helper_expectfn *\r\nnf_ct_helper_expectfn_find_by_name(const char *name)\r\n{\r\nstruct nf_ct_helper_expectfn *cur;\r\nbool found = false;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(cur, &nf_ct_helper_expectfn_list, head) {\r\nif (!strcmp(cur->name, name)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn found ? cur : NULL;\r\n}\r\nstruct nf_ct_helper_expectfn *\r\nnf_ct_helper_expectfn_find_by_symbol(const void *symbol)\r\n{\r\nstruct nf_ct_helper_expectfn *cur;\r\nbool found = false;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(cur, &nf_ct_helper_expectfn_list, head) {\r\nif (cur->expectfn == symbol) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn found ? cur : NULL;\r\n}\r\nint nf_conntrack_helper_register(struct nf_conntrack_helper *me)\r\n{\r\nint ret = 0;\r\nstruct nf_conntrack_helper *cur;\r\nstruct hlist_node *n;\r\nunsigned int h = helper_hash(&me->tuple);\r\nBUG_ON(me->expect_policy == NULL);\r\nBUG_ON(me->expect_class_max >= NF_CT_MAX_EXPECT_CLASSES);\r\nBUG_ON(strlen(me->name) > NF_CT_HELPER_NAME_LEN - 1);\r\nmutex_lock(&nf_ct_helper_mutex);\r\nhlist_for_each_entry(cur, n, &nf_ct_helper_hash[h], hnode) {\r\nif (strncmp(cur->name, me->name, NF_CT_HELPER_NAME_LEN) == 0 &&\r\ncur->tuple.src.l3num == me->tuple.src.l3num &&\r\ncur->tuple.dst.protonum == me->tuple.dst.protonum) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nhlist_add_head_rcu(&me->hnode, &nf_ct_helper_hash[h]);\r\nnf_ct_helper_count++;\r\nout:\r\nmutex_unlock(&nf_ct_helper_mutex);\r\nreturn ret;\r\n}\r\nstatic void __nf_conntrack_helper_unregister(struct nf_conntrack_helper *me,\r\nstruct net *net)\r\n{\r\nstruct nf_conntrack_tuple_hash *h;\r\nstruct nf_conntrack_expect *exp;\r\nconst struct hlist_node *n, *next;\r\nconst struct hlist_nulls_node *nn;\r\nunsigned int i;\r\nfor (i = 0; i < nf_ct_expect_hsize; i++) {\r\nhlist_for_each_entry_safe(exp, n, next,\r\n&net->ct.expect_hash[i], hnode) {\r\nstruct nf_conn_help *help = nfct_help(exp->master);\r\nif ((rcu_dereference_protected(\r\nhelp->helper,\r\nlockdep_is_held(&nf_conntrack_lock)\r\n) == me || exp->helper == me) &&\r\ndel_timer(&exp->timeout)) {\r\nnf_ct_unlink_expect(exp);\r\nnf_ct_expect_put(exp);\r\n}\r\n}\r\n}\r\nhlist_nulls_for_each_entry(h, nn, &net->ct.unconfirmed, hnnode)\r\nunhelp(h, me);\r\nfor (i = 0; i < net->ct.htable_size; i++) {\r\nhlist_nulls_for_each_entry(h, nn, &net->ct.hash[i], hnnode)\r\nunhelp(h, me);\r\n}\r\n}\r\nvoid nf_conntrack_helper_unregister(struct nf_conntrack_helper *me)\r\n{\r\nstruct net *net;\r\nmutex_lock(&nf_ct_helper_mutex);\r\nhlist_del_rcu(&me->hnode);\r\nnf_ct_helper_count--;\r\nmutex_unlock(&nf_ct_helper_mutex);\r\nsynchronize_rcu();\r\nrtnl_lock();\r\nspin_lock_bh(&nf_conntrack_lock);\r\nfor_each_net(net)\r\n__nf_conntrack_helper_unregister(me, net);\r\nspin_unlock_bh(&nf_conntrack_lock);\r\nrtnl_unlock();\r\n}\r\nint nf_conntrack_helper_init(struct net *net)\r\n{\r\nint err;\r\nnet->ct.auto_assign_helper_warned = false;\r\nnet->ct.sysctl_auto_assign_helper = nf_ct_auto_assign_helper;\r\nif (net_eq(net, &init_net)) {\r\nnf_ct_helper_hsize = 1;\r\nnf_ct_helper_hash =\r\nnf_ct_alloc_hashtable(&nf_ct_helper_hsize, 0);\r\nif (!nf_ct_helper_hash)\r\nreturn -ENOMEM;\r\nerr = nf_ct_extend_register(&helper_extend);\r\nif (err < 0)\r\ngoto err1;\r\n}\r\nerr = nf_conntrack_helper_init_sysctl(net);\r\nif (err < 0)\r\ngoto out_sysctl;\r\nreturn 0;\r\nout_sysctl:\r\nif (net_eq(net, &init_net))\r\nnf_ct_extend_unregister(&helper_extend);\r\nerr1:\r\nnf_ct_free_hashtable(nf_ct_helper_hash, nf_ct_helper_hsize);\r\nreturn err;\r\n}\r\nvoid nf_conntrack_helper_fini(struct net *net)\r\n{\r\nnf_conntrack_helper_fini_sysctl(net);\r\nif (net_eq(net, &init_net)) {\r\nnf_ct_extend_unregister(&helper_extend);\r\nnf_ct_free_hashtable(nf_ct_helper_hash, nf_ct_helper_hsize);\r\n}\r\n}
