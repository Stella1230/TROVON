CsrResult xbv1_parse(card_t *card, fwreadfn_t readfn, void *dlpriv, xbv1_t *fwinfo)\r\n{\r\nct_t ct;\r\ntag_t tag;\r\nxbv_stack_t stack;\r\nct.dlpriv = dlpriv;\r\nct.ioffset = 0;\r\nct.iread = readfn;\r\nmemset(fwinfo, 0, sizeof(xbv1_t));\r\nfwinfo->mode = xbv_unknown;\r\nif (read_tag(card, &ct, &tag) <= 0)\r\n{\r\nunifi_error(NULL, "File is not UniFi firmware\n");\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nDBG_TAG(tag.t_name);\r\nif (!TAG_EQ(tag.t_name, "XBV1"))\r\n{\r\nunifi_error(NULL, "File is not UniFi firmware (%s)\n", tag.t_name);\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nstack.ptr = 0;\r\nstack.s[stack.ptr].container = xbv_xbv1;\r\nstack.s[stack.ptr].ioffset_end = XBV_MAX_OFFS;\r\nwhile (1)\r\n{\r\ns32 n;\r\nn = read_tag(card, &ct, &tag);\r\nif (n < 0)\r\n{\r\nunifi_error(NULL, "No tag\n");\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nif (n == 0)\r\n{\r\nbreak;\r\n}\r\nDBG_TAG(tag.t_name);\r\nif (TAG_EQ(tag.t_name, "VERF"))\r\n{\r\nu32 version;\r\nif (xbv_check(fwinfo, &stack, xbv_unknown, xbv_xbv1) ||\r\n(tag.t_len != 2) ||\r\nread_uint(card, &ct, &version, 2))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nif (version != 0)\r\n{\r\nunifi_error(NULL, "Unsupported firmware file version: %d.%d\n",\r\nversion >> 8, version & 0xFF);\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\n}\r\nelse if (TAG_EQ(tag.t_name, "LIST"))\r\n{\r\nchar name[4];\r\nu32 list_end;\r\nlist_end = ct.ioffset + tag.t_len;\r\nif (read_bytes(card, &ct, name, 4))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nDBG_TAG(name);\r\nif (TAG_EQ(name, "FW "))\r\n{\r\nif (xbv_push(fwinfo, &stack, xbv_firmware, xbv_xbv1, xbv_fw, list_end))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\n}\r\nelse if (TAG_EQ(name, "VERS"))\r\n{\r\nif (xbv_push(fwinfo, &stack, xbv_firmware, xbv_fw, xbv_vers, list_end) ||\r\n(fwinfo->vers.num_vand != 0))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\n}\r\nelse if (TAG_EQ(name, "VAND"))\r\n{\r\nstruct VAND *vand;\r\nif (xbv_push(fwinfo, &stack, xbv_firmware, xbv_vers, xbv_vand, list_end) ||\r\n(fwinfo->vers.num_vand >= MAX_VAND))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nvand = fwinfo->vand + fwinfo->vers.num_vand++;\r\nvand->first = fwinfo->num_vmeq;\r\nvand->count = 0;\r\n}\r\nelse if (TAG_EQ(name, "PTCH"))\r\n{\r\nif (xbv_push(fwinfo, &stack, xbv_patch, xbv_xbv1, xbv_ptch, list_end))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\n}\r\nelse\r\n{\r\nct.ioffset += tag.t_len - 4;\r\n}\r\n}\r\nelse if (TAG_EQ(tag.t_name, "SLTP"))\r\n{\r\nu32 addr;\r\nif (xbv_check(fwinfo, &stack, xbv_firmware, xbv_fw) ||\r\n(tag.t_len != 4) ||\r\n(fwinfo->slut_addr != 0) ||\r\nread_uint(card, &ct, &addr, 4))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nfwinfo->slut_addr = addr;\r\n}\r\nelse if (TAG_EQ(tag.t_name, "FWDL"))\r\n{\r\nu32 addr;\r\nstruct FWDL *fwdl;\r\nif (xbv_check(fwinfo, &stack, xbv_firmware, xbv_fw) ||\r\n(fwinfo->num_fwdl >= MAX_FWDL) ||\r\n(read_uint(card, &ct, &addr, 4)))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nfwdl = fwinfo->fwdl + fwinfo->num_fwdl++;\r\nfwdl->dl_size = tag.t_len - 4;\r\nfwdl->dl_addr = addr;\r\nfwdl->dl_offset = ct.ioffset;\r\nct.ioffset += tag.t_len - 4;\r\n}\r\nelse if (TAG_EQ(tag.t_name, "FWOV"))\r\n{\r\nif (xbv_check(fwinfo, &stack, xbv_firmware, xbv_fw) ||\r\n(fwinfo->fwov.dl_size != 0) ||\r\n(fwinfo->fwov.dl_offset != 0))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nfwinfo->fwov.dl_size = tag.t_len;\r\nfwinfo->fwov.dl_offset = ct.ioffset;\r\nct.ioffset += tag.t_len;\r\n}\r\nelse if (TAG_EQ(tag.t_name, "VMEQ"))\r\n{\r\nu32 temp[3];\r\nstruct VAND *vand;\r\nstruct VMEQ *vmeq;\r\nif (xbv_check(fwinfo, &stack, xbv_firmware, xbv_vand) ||\r\n(fwinfo->num_vmeq >= MAX_VMEQ) ||\r\n(fwinfo->vers.num_vand == 0) ||\r\n(tag.t_len != 8) ||\r\nread_uint(card, &ct, &temp[0], 4) ||\r\nread_uint(card, &ct, &temp[1], 2) ||\r\nread_uint(card, &ct, &temp[2], 2))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nvand = fwinfo->vand + (fwinfo->vers.num_vand - 1);\r\nvmeq = fwinfo->vmeq + fwinfo->num_vmeq++;\r\nvand->count++;\r\nvmeq->addr = temp[0];\r\nvmeq->mask = (u16)temp[1];\r\nvmeq->value = (u16)temp[2];\r\n}\r\nelse if (TAG_EQ(tag.t_name, "FWID"))\r\n{\r\nu32 build_id;\r\nif (xbv_check(fwinfo, &stack, xbv_patch, xbv_ptch) ||\r\n(tag.t_len != 4) ||\r\n(fwinfo->build_id != 0) ||\r\nread_uint(card, &ct, &build_id, 4))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nfwinfo->build_id = build_id;\r\n}\r\nelse if (TAG_EQ(tag.t_name, "PTDL"))\r\n{\r\nstruct PTDL *ptdl;\r\nif (xbv_check(fwinfo, &stack, xbv_patch, xbv_ptch) ||\r\n(fwinfo->num_ptdl >= MAX_PTDL))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nptdl = fwinfo->ptdl + fwinfo->num_ptdl++;\r\nptdl->dl_size = tag.t_len;\r\nptdl->dl_offset = ct.ioffset;\r\nct.ioffset += tag.t_len;\r\n}\r\nelse\r\n{\r\nct.ioffset += tag.t_len;\r\n}\r\nwhile (ct.ioffset >= stack.s[stack.ptr].ioffset_end)\r\n{\r\nif (ct.ioffset > stack.s[stack.ptr].ioffset_end)\r\n{\r\nunifi_error(NULL,\r\n"XBV file has overrun stack'd segment %d (%d > %d)\n",\r\nstack.ptr, ct.ioffset, stack.s[stack.ptr].ioffset_end);\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nif (stack.ptr <= 0)\r\n{\r\nunifi_error(NULL, "XBV file has underrun stack pointer\n");\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nstack.ptr--;\r\n}\r\n}\r\nif (stack.ptr != 0)\r\n{\r\nunifi_error(NULL, "Last list of XBV is not complete.\n");\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic s32 xbv_check(xbv1_t *fwinfo, const xbv_stack_t *stack,\r\nxbv_mode new_mode, xbv_container old_cont)\r\n{\r\nif (new_mode != xbv_unknown)\r\n{\r\nif (fwinfo->mode == xbv_unknown)\r\n{\r\nfwinfo->mode = new_mode;\r\n}\r\nelse if (fwinfo->mode != new_mode)\r\n{\r\nreturn -1;\r\n}\r\n}\r\nif (stack->s[stack->ptr].container != old_cont)\r\n{\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 xbv_push(xbv1_t *fwinfo, xbv_stack_t *stack,\r\nxbv_mode new_mode, xbv_container old_cont,\r\nxbv_container new_cont, u32 new_ioff)\r\n{\r\nif (xbv_check(fwinfo, stack, new_mode, old_cont))\r\n{\r\nreturn -1;\r\n}\r\nif (stack->ptr >= (XBV_STACK_SIZE - 1))\r\n{\r\nreturn -1;\r\n}\r\nstack->ptr++;\r\nstack->s[stack->ptr].container = new_cont;\r\nstack->s[stack->ptr].ioffset_end = new_ioff;\r\nreturn 0;\r\n}\r\nstatic u32 xbv2uint(u8 *ptr, s32 len)\r\n{\r\nu32 u = 0;\r\ns16 i;\r\nfor (i = 0; i < len; i++)\r\n{\r\nu32 b;\r\nb = ptr[i];\r\nu += b << (i * 8);\r\n}\r\nreturn u;\r\n}\r\nstatic s32 read_tag(card_t *card, ct_t *ct, tag_t *tag)\r\n{\r\nu8 buf[8];\r\ns32 n;\r\nn = (*ct->iread)(card->ospriv, ct->dlpriv, ct->ioffset, buf, 8);\r\nif (n <= 0)\r\n{\r\nreturn n;\r\n}\r\nif (n != 8)\r\n{\r\nreturn -1;\r\n}\r\nmemcpy(tag->t_name, buf, 4);\r\ntag->t_len = xbv2uint(buf + 4, 4);\r\nct->ioffset += 8;\r\nreturn 8;\r\n}\r\nstatic s32 read_bytes(card_t *card, ct_t *ct, void *buf, u32 len)\r\n{\r\nif ((*ct->iread)(card->ospriv, ct->dlpriv, ct->ioffset, buf, len) != (s32)len)\r\n{\r\nreturn -1;\r\n}\r\nct->ioffset += len;\r\nreturn 0;\r\n}\r\nstatic s32 read_uint(card_t *card, ct_t *ct, u32 *u, u32 len)\r\n{\r\nu8 buf[4];\r\nif (len > 4)\r\n{\r\nreturn -1;\r\n}\r\nif (read_bytes(card, ct, buf, len))\r\n{\r\nreturn -1;\r\n}\r\n*u = xbv2uint(buf, len);\r\nreturn 0;\r\n}\r\nstatic u32 write_uint16(void *buf, const u32 offset, const u16 val)\r\n{\r\nu8 *dst = (u8 *)buf + offset;\r\n*dst++ = (u8)(val & 0xff);\r\n*dst = (u8)(val >> 8);\r\nreturn sizeof(u16);\r\n}\r\nstatic u32 write_uint32(void *buf, const u32 offset, const u32 val)\r\n{\r\n(void)write_uint16(buf, offset + 0, (u16)(val & 0xffff));\r\n(void)write_uint16(buf, offset + 2, (u16)(val >> 16));\r\nreturn sizeof(u32);\r\n}\r\nstatic u32 write_bytes(void *buf, const u32 offset, const u8 *data, const u32 len)\r\n{\r\nu32 i;\r\nu8 *dst = (u8 *)buf + offset;\r\nfor (i = 0; i < len; i++)\r\n{\r\n*dst++ = *((u8 *)data + i);\r\n}\r\nreturn len;\r\n}\r\nstatic u32 write_tag(void *buf, const u32 offset, const char *tag_str)\r\n{\r\nu8 *dst = (u8 *)buf + offset;\r\nmemcpy(dst, tag_str, 4);\r\nreturn 4;\r\n}\r\nstatic u32 write_chunk(void *buf, const u32 offset, const char *tag_str, const u32 payload_len)\r\n{\r\nu32 written = 0;\r\nwritten += write_tag(buf, offset, tag_str);\r\nwritten += write_uint32(buf, written + offset, (u32)payload_len);\r\nreturn written;\r\n}\r\nstatic u16 calc_checksum(void *buf, const u32 offset, const u32 bytes_len)\r\n{\r\nu32 i;\r\nu8 *src = (u8 *)buf + offset;\r\nu16 sum = 0;\r\nu16 val;\r\nfor (i = 0; i < bytes_len / 2; i++)\r\n{\r\nval = (u16) * src++;\r\nval += (u16)(*src++) << 8;\r\nsum += val;\r\n}\r\nreturn (STREAM_CHECKSUM - sum);\r\n}\r\nstatic u32 calc_patch_size(const xbv1_t *fwinfo)\r\n{\r\ns16 i;\r\nu32 size = 0;\r\nif (fwinfo->mode != xbv_firmware)\r\n{\r\nreturn 0;\r\n}\r\nfor (i = 0; i < fwinfo->num_fwdl; i++)\r\n{\r\nsize += fwinfo->fwdl[i].dl_size;\r\n}\r\nsize += PTDL_RESET_DATA_SIZE;\r\nsize += ((fwinfo->num_fwdl / PTDL_MAX_SIZE) + 2) * PTDL_HDR_SIZE;\r\nsize += 1024;\r\nreturn size;\r\n}\r\nstatic u32 write_xbv_header(void *buf, const u32 offset, const u32 file_payload_length)\r\n{\r\nu32 written = 0;\r\nwritten += write_chunk(buf, offset + written, (char *)"XBV1", file_payload_length + 6);\r\nwritten += write_chunk(buf, offset + written, (char *)"VERF", 2);\r\nwritten += write_uint16(buf, offset + written, 0);\r\nreturn written;\r\n}\r\nstatic u32 write_ptch_header(void *buf, const u32 offset, const u32 fw_id)\r\n{\r\nu32 written = 0;\r\nwritten += write_chunk(buf, offset + written, (char *)"LIST", 0);\r\nwritten += write_tag(buf, offset + written, (char *)"PTCH");\r\nwritten += write_chunk(buf, offset + written, (char *)"FWID", 4);\r\nwritten += write_uint32(buf, offset + written, fw_id);\r\nreturn written;\r\n}\r\nstatic u32 write_patchcmd(void *buf, const u32 offset, const u32 dst_genaddr, const u16 len)\r\n{\r\nu32 written = 0;\r\nu32 region = (dst_genaddr >> 28);\r\nu16 cmd_and_len = UF_MEMPUT_MAC;\r\nif (region == UF_REGION_PHY)\r\n{\r\ncmd_and_len = UF_MEMPUT_PHY;\r\n}\r\nelse if (region != UF_REGION_MAC)\r\n{\r\nreturn 0;\r\n}\r\ncmd_and_len |= len;\r\nwritten += write_uint16(buf, offset + written, cmd_and_len);\r\nwritten += write_uint16(buf, offset + written, (u16)(dst_genaddr >> 16));\r\nwritten += write_uint16(buf, offset + written, (u16)(dst_genaddr & 0xffff));\r\nreturn written;\r\n}\r\nstatic u32 write_fwdl_to_ptdl(void *buf, const u32 offset, fwreadfn_t readfn,\r\nconst struct FWDL *fwdl, const void *dlpriv,\r\nconst u32 fw_id, void *fw_buf)\r\n{\r\nu32 written = 0;\r\ns16 chunks = 0;\r\nu32 left = fwdl->dl_size;\r\nu32 dl_addr = fwdl->dl_addr;\r\nu32 dl_offs = fwdl->dl_offset;\r\nu16 csum;\r\nu32 csum_start_offs;\r\nu32 sec_data_len;\r\nu32 sec_len;\r\nwhile (left)\r\n{\r\nsec_data_len = CSRMIN(left, PTDL_MAX_SIZE - PTDL_HDR_SIZE);\r\nsec_len = sec_data_len + PTDL_HDR_SIZE;\r\nwritten += write_chunk(buf, offset + written, (char *)"PTDL", sec_len);\r\ncsum_start_offs = offset + written;\r\nwritten += write_uint16(buf, offset + written, (u16)(fw_id >> 16));\r\nwritten += write_uint16(buf, offset + written, (u16)(fw_id & 0xffff));\r\nwritten += write_uint16(buf, offset + written, (u16)(sec_len / 2));\r\nwritten += write_patchcmd(buf, offset + written, dl_addr, (u16)(sec_data_len / 2));\r\nif (readfn(NULL, (void *)dlpriv, dl_offs, fw_buf, sec_data_len) < 0)\r\n{\r\nreturn 0;\r\n}\r\nwritten += write_bytes(buf,\r\noffset + written,\r\nfw_buf,\r\nsec_data_len);\r\ncsum = calc_checksum(buf, csum_start_offs, written - (csum_start_offs - offset));\r\nwritten += write_uint16(buf, offset + written, csum);\r\nleft -= sec_data_len;\r\ndl_addr += sec_data_len;\r\ndl_offs += sec_data_len;\r\nchunks++;\r\n}\r\nreturn written;\r\n}\r\nstatic u32 write_reset_ptdl(void *buf, const u32 offset, const xbv1_t *fwinfo, u32 fw_id)\r\n{\r\nu32 written = 0;\r\nu16 csum;\r\nu32 csum_start_offs;\r\nu32 sec_len;\r\nsec_len = SEC_CMD_LEN + PTDL_VEC_HDR_SIZE;\r\nwritten += write_chunk(buf, offset + written, (char *)"PTDL", sec_len);\r\ncsum_start_offs = offset + written;\r\nwritten += write_uint16(buf, offset + written, (u16)(fw_id >> 16));\r\nwritten += write_uint16(buf, offset + written, (u16)(fw_id & 0xffff));\r\nwritten += write_uint16(buf, offset + written, (u16)(sec_len / 2));\r\nwritten += write_uint16(buf, offset + written, UF_MAC_START_CMD);\r\nwritten += write_uint16(buf, offset + written, (UF_MAC_START_VEC >> 16));\r\nwritten += write_uint16(buf, offset + written, (UF_MAC_START_VEC & 0xffff));\r\nwritten += write_uint16(buf, offset + written, UF_PHY_START_CMD);\r\nwritten += write_uint16(buf, offset + written, (UF_PHY_START_VEC >> 16));\r\nwritten += write_uint16(buf, offset + written, (UF_PHY_START_VEC & 0xffff));\r\ncsum = calc_checksum(buf, csum_start_offs, written - (csum_start_offs - offset));\r\nwritten += write_uint16(buf, offset + written, csum);\r\nreturn written;\r\n}\r\ns32 xbv1_read_slut(card_t *card, fwreadfn_t readfn, void *dlpriv, xbv1_t *fwinfo,\r\nsymbol_t *slut, u32 slut_len)\r\n{\r\ns16 i;\r\ns32 offset;\r\nu32 magic;\r\nu32 count = 0;\r\nct_t ct;\r\nif (fwinfo->mode != xbv_firmware)\r\n{\r\nreturn -1;\r\n}\r\noffset = -1;\r\nfor (i = 0; i < fwinfo->num_fwdl; i++)\r\n{\r\nif ((fwinfo->slut_addr >= fwinfo->fwdl[i].dl_addr) &&\r\n(fwinfo->slut_addr < (fwinfo->fwdl[i].dl_addr + fwinfo->fwdl[i].dl_size)))\r\n{\r\noffset = fwinfo->fwdl[i].dl_offset +\r\n(fwinfo->slut_addr - fwinfo->fwdl[i].dl_addr);\r\n}\r\n}\r\nif (offset < 0)\r\n{\r\nreturn -1;\r\n}\r\nct.dlpriv = dlpriv;\r\nct.ioffset = offset;\r\nct.iread = readfn;\r\nif (read_uint(card, &ct, &magic, 2))\r\n{\r\nreturn -1;\r\n}\r\nif (magic != SLUT_FINGERPRINT)\r\n{\r\nreturn -1;\r\n}\r\nwhile (count < slut_len)\r\n{\r\nu32 id, obj;\r\nif (read_uint(card, &ct, &id, 2))\r\n{\r\nreturn -1;\r\n}\r\nif (id == CSR_SLT_END)\r\n{\r\nbreak;\r\n}\r\nif (read_uint(card, &ct, &obj, 4))\r\n{\r\nreturn -1;\r\n}\r\nslut[count].id = (u16)id;\r\nslut[count].obj = obj;\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nvoid* xbv_to_patch(card_t *card, fwreadfn_t readfn,\r\nconst void *fw_buf, const xbv1_t *fwinfo, u32 *size)\r\n{\r\nvoid *patch_buf = NULL;\r\nu32 patch_buf_size;\r\nu32 payload_offs = 0;\r\ns16 i;\r\nu32 patch_offs = 0;\r\nu32 list_len_offs = 0;\r\nu32 ptdl_start_offs = 0;\r\nu32 fw_id;\r\nvoid *rdbuf;\r\nif (!fw_buf || !fwinfo || !card)\r\n{\r\nreturn NULL;\r\n}\r\nif (fwinfo->mode != xbv_firmware)\r\n{\r\nunifi_error(NULL, "Not a firmware file\n");\r\nreturn NULL;\r\n}\r\nrdbuf = kmalloc(PTDL_MAX_SIZE, GFP_KERNEL);\r\nif (!rdbuf)\r\n{\r\nunifi_error(card, "Couldn't alloc conversion buffer\n");\r\nreturn NULL;\r\n}\r\nfw_id = card->build_id;\r\npatch_buf_size = calc_patch_size(fwinfo);\r\npatch_buf = kmalloc(patch_buf_size, GFP_KERNEL);\r\nif (!patch_buf)\r\n{\r\nkfree(rdbuf);\r\nunifi_error(NULL, "Can't malloc buffer for patch conversion\n");\r\nreturn NULL;\r\n}\r\nmemset(patch_buf, 0xdd, patch_buf_size);\r\npatch_offs += write_xbv_header(patch_buf, patch_offs, 0);\r\npayload_offs = patch_offs;\r\nlist_len_offs = patch_offs + 4;\r\npatch_offs += write_ptch_header(patch_buf, patch_offs, fw_id);\r\nptdl_start_offs = patch_offs;\r\nfor (i = 0; i < fwinfo->num_fwdl; i++)\r\n{\r\npatch_offs += write_fwdl_to_ptdl(patch_buf,\r\npatch_offs,\r\nreadfn,\r\n&fwinfo->fwdl[i],\r\nfw_buf,\r\nfw_id,\r\nrdbuf);\r\n}\r\npatch_offs += write_reset_ptdl(patch_buf, patch_offs, fwinfo, fw_id);\r\n(void)write_uint32(patch_buf, list_len_offs,\r\n(patch_offs - ptdl_start_offs) + PTCH_LIST_SIZE);\r\n(void)write_xbv_header(patch_buf, 0, (patch_offs - payload_offs));\r\nunifi_trace(card->ospriv, UDBG1, "XBV:PTCH size %u, fw_id %u\n",\r\npatch_offs, fw_id);\r\nif (size)\r\n{\r\n*size = patch_offs;\r\n}\r\nkfree(rdbuf);\r\nreturn patch_buf;\r\n}
