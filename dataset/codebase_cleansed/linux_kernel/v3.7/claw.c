static void\r\nclaw_unregister_debug_facility(void)\r\n{\r\nif (claw_dbf_setup)\r\ndebug_unregister(claw_dbf_setup);\r\nif (claw_dbf_trace)\r\ndebug_unregister(claw_dbf_trace);\r\n}\r\nstatic int\r\nclaw_register_debug_facility(void)\r\n{\r\nclaw_dbf_setup = debug_register("claw_setup", 2, 1, 8);\r\nclaw_dbf_trace = debug_register("claw_trace", 2, 2, 8);\r\nif (claw_dbf_setup == NULL || claw_dbf_trace == NULL) {\r\nclaw_unregister_debug_facility();\r\nreturn -ENOMEM;\r\n}\r\ndebug_register_view(claw_dbf_setup, &debug_hex_ascii_view);\r\ndebug_set_level(claw_dbf_setup, 2);\r\ndebug_register_view(claw_dbf_trace, &debug_hex_ascii_view);\r\ndebug_set_level(claw_dbf_trace, 2);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nclaw_set_busy(struct net_device *dev)\r\n{\r\n((struct claw_privbk *)dev->ml_priv)->tbusy = 1;\r\n}\r\nstatic inline void\r\nclaw_clear_busy(struct net_device *dev)\r\n{\r\nclear_bit(0, &(((struct claw_privbk *) dev->ml_priv)->tbusy));\r\nnetif_wake_queue(dev);\r\n}\r\nstatic inline int\r\nclaw_check_busy(struct net_device *dev)\r\n{\r\nreturn ((struct claw_privbk *) dev->ml_priv)->tbusy;\r\n}\r\nstatic inline void\r\nclaw_setbit_busy(int nr,struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nset_bit(nr, (void *)&(((struct claw_privbk *)dev->ml_priv)->tbusy));\r\n}\r\nstatic inline void\r\nclaw_clearbit_busy(int nr,struct net_device *dev)\r\n{\r\nclear_bit(nr, (void *)&(((struct claw_privbk *)dev->ml_priv)->tbusy));\r\nnetif_wake_queue(dev);\r\n}\r\nstatic inline int\r\nclaw_test_and_setbit_busy(int nr,struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nreturn test_and_set_bit(nr,\r\n(void *)&(((struct claw_privbk *) dev->ml_priv)->tbusy));\r\n}\r\nstatic int claw_pm_prepare(struct ccwgroup_device *gdev)\r\n{\r\nreturn -EPERM;\r\n}\r\nstatic ssize_t claw_driver_group_store(struct device_driver *ddrv,\r\nconst char *buf, size_t count)\r\n{\r\nint err;\r\nerr = ccwgroup_create_dev(claw_root_dev, &claw_group_driver, 2, buf);\r\nreturn err ? err : count;\r\n}\r\nstatic int\r\nclaw_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nint rc;\r\nstruct claw_privbk *privptr = dev->ml_priv;\r\nunsigned long saveflags;\r\nstruct chbk *p_ch;\r\nCLAW_DBF_TEXT(4, trace, "claw_tx");\r\np_ch = &privptr->channel[WRITE_CHANNEL];\r\nspin_lock_irqsave(get_ccwdev_lock(p_ch->cdev), saveflags);\r\nrc=claw_hw_tx( skb, dev, 1 );\r\nspin_unlock_irqrestore(get_ccwdev_lock(p_ch->cdev), saveflags);\r\nCLAW_DBF_TEXT_(4, trace, "clawtx%d", rc);\r\nif (rc)\r\nrc = NETDEV_TX_BUSY;\r\nelse\r\nrc = NETDEV_TX_OK;\r\nreturn rc;\r\n}\r\nstatic struct sk_buff *\r\nclaw_pack_skb(struct claw_privbk *privptr)\r\n{\r\nstruct sk_buff *new_skb,*held_skb;\r\nstruct chbk *p_ch = &privptr->channel[WRITE_CHANNEL];\r\nstruct claw_env *p_env = privptr->p_env;\r\nint pkt_cnt,pk_ind,so_far;\r\nnew_skb = NULL;\r\npkt_cnt = 0;\r\nCLAW_DBF_TEXT(4, trace, "PackSKBe");\r\nif (!skb_queue_empty(&p_ch->collect_queue)) {\r\nheld_skb = skb_dequeue(&p_ch->collect_queue);\r\nif (held_skb)\r\ndev_kfree_skb_any(held_skb);\r\nelse\r\nreturn NULL;\r\nif (p_env->packing != DO_PACKED)\r\nreturn held_skb;\r\nnew_skb = dev_alloc_skb(p_env->write_size);\r\nif (new_skb == NULL) {\r\natomic_inc(&held_skb->users);\r\nskb_queue_head(&p_ch->collect_queue,held_skb);\r\nreturn NULL;\r\n}\r\npk_ind = 1;\r\nso_far = 0;\r\nnew_skb->cb[1] = 'P';\r\nwhile ((pk_ind) && (held_skb != NULL)) {\r\nif (held_skb->len+so_far <= p_env->write_size-8) {\r\nmemcpy(skb_put(new_skb,held_skb->len),\r\nheld_skb->data,held_skb->len);\r\nprivptr->stats.tx_packets++;\r\nso_far += held_skb->len;\r\npkt_cnt++;\r\ndev_kfree_skb_any(held_skb);\r\nheld_skb = skb_dequeue(&p_ch->collect_queue);\r\nif (held_skb)\r\natomic_dec(&held_skb->users);\r\n} else {\r\npk_ind = 0;\r\natomic_inc(&held_skb->users);\r\nskb_queue_head(&p_ch->collect_queue,held_skb);\r\n}\r\n}\r\n}\r\nCLAW_DBF_TEXT(4, trace, "PackSKBx");\r\nreturn new_skb;\r\n}\r\nstatic int\r\nclaw_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct claw_privbk *privptr = dev->ml_priv;\r\nint buff_size;\r\nCLAW_DBF_TEXT(4, trace, "setmtu");\r\nbuff_size = privptr->p_env->write_size;\r\nif ((new_mtu < 60) || (new_mtu > buff_size)) {\r\nreturn -EINVAL;\r\n}\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int\r\nclaw_open(struct net_device *dev)\r\n{\r\nint rc;\r\nint i;\r\nunsigned long saveflags=0;\r\nunsigned long parm;\r\nstruct claw_privbk *privptr;\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct timer_list timer;\r\nstruct ccwbk *p_buf;\r\nCLAW_DBF_TEXT(4, trace, "open");\r\nprivptr = (struct claw_privbk *)dev->ml_priv;\r\nif (privptr->buffs_alloc == 0) {\r\nrc=init_ccw_bk(dev);\r\nif (rc) {\r\nCLAW_DBF_TEXT(2, trace, "openmem");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nprivptr->system_validate_comp=0;\r\nprivptr->release_pend=0;\r\nif(strncmp(privptr->p_env->api_type,WS_APPL_NAME_PACKED,6) == 0) {\r\nprivptr->p_env->read_size=DEF_PACK_BUFSIZE;\r\nprivptr->p_env->write_size=DEF_PACK_BUFSIZE;\r\nprivptr->p_env->packing=PACKING_ASK;\r\n} else {\r\nprivptr->p_env->packing=0;\r\nprivptr->p_env->read_size=CLAW_FRAME_SIZE;\r\nprivptr->p_env->write_size=CLAW_FRAME_SIZE;\r\n}\r\nclaw_set_busy(dev);\r\ntasklet_init(&privptr->channel[READ_CHANNEL].tasklet, claw_irq_tasklet,\r\n(unsigned long) &privptr->channel[READ_CHANNEL]);\r\nfor ( i = 0; i < 2; i++) {\r\nCLAW_DBF_TEXT_(2, trace, "opn_ch%d", i);\r\ninit_waitqueue_head(&privptr->channel[i].wait);\r\nif (i == WRITE_CHANNEL)\r\nskb_queue_head_init(\r\n&privptr->channel[WRITE_CHANNEL].collect_queue);\r\nprivptr->channel[i].flag_a = 0;\r\nprivptr->channel[i].IO_active = 0;\r\nprivptr->channel[i].flag &= ~CLAW_TIMER;\r\ninit_timer(&timer);\r\ntimer.function = (void *)claw_timer;\r\ntimer.data = (unsigned long)(&privptr->channel[i]);\r\ntimer.expires = jiffies + 15*HZ;\r\nadd_timer(&timer);\r\nspin_lock_irqsave(get_ccwdev_lock(\r\nprivptr->channel[i].cdev), saveflags);\r\nparm = (unsigned long) &privptr->channel[i];\r\nprivptr->channel[i].claw_state = CLAW_START_HALT_IO;\r\nrc = 0;\r\nadd_wait_queue(&privptr->channel[i].wait, &wait);\r\nrc = ccw_device_halt(\r\n(struct ccw_device *)privptr->channel[i].cdev,parm);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(\r\nget_ccwdev_lock(privptr->channel[i].cdev), saveflags);\r\nschedule();\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&privptr->channel[i].wait, &wait);\r\nif(rc != 0)\r\nccw_check_return_code(privptr->channel[i].cdev, rc);\r\nif((privptr->channel[i].flag & CLAW_TIMER) == 0x00)\r\ndel_timer(&timer);\r\n}\r\nif ((((privptr->channel[READ_CHANNEL].last_dstat |\r\nprivptr->channel[WRITE_CHANNEL].last_dstat) &\r\n~(DEV_STAT_CHN_END | DEV_STAT_DEV_END)) != 0x00) ||\r\n(((privptr->channel[READ_CHANNEL].flag |\r\nprivptr->channel[WRITE_CHANNEL].flag) & CLAW_TIMER) != 0x00)) {\r\ndev_info(&privptr->channel[READ_CHANNEL].cdev->dev,\r\n"%s: remote side is not ready\n", dev->name);\r\nCLAW_DBF_TEXT(2, trace, "notrdy");\r\nfor ( i = 0; i < 2; i++) {\r\nspin_lock_irqsave(\r\nget_ccwdev_lock(privptr->channel[i].cdev),\r\nsaveflags);\r\nparm = (unsigned long) &privptr->channel[i];\r\nprivptr->channel[i].claw_state = CLAW_STOP;\r\nrc = ccw_device_halt(\r\n(struct ccw_device *)&privptr->channel[i].cdev,\r\nparm);\r\nspin_unlock_irqrestore(\r\nget_ccwdev_lock(privptr->channel[i].cdev),\r\nsaveflags);\r\nif (rc != 0) {\r\nccw_check_return_code(\r\nprivptr->channel[i].cdev, rc);\r\n}\r\n}\r\nfree_pages((unsigned long)privptr->p_buff_ccw,\r\n(int)pages_to_order_of_mag(privptr->p_buff_ccw_num));\r\nif (privptr->p_env->read_size < PAGE_SIZE) {\r\nfree_pages((unsigned long)privptr->p_buff_read,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_read_num));\r\n}\r\nelse {\r\np_buf=privptr->p_read_active_first;\r\nwhile (p_buf!=NULL) {\r\nfree_pages((unsigned long)p_buf->p_buffer,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_pages_perread ));\r\np_buf=p_buf->next;\r\n}\r\n}\r\nif (privptr->p_env->write_size < PAGE_SIZE ) {\r\nfree_pages((unsigned long)privptr->p_buff_write,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_write_num));\r\n}\r\nelse {\r\np_buf=privptr->p_write_active_first;\r\nwhile (p_buf!=NULL) {\r\nfree_pages((unsigned long)p_buf->p_buffer,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_pages_perwrite ));\r\np_buf=p_buf->next;\r\n}\r\n}\r\nprivptr->buffs_alloc = 0;\r\nprivptr->channel[READ_CHANNEL].flag = 0x00;\r\nprivptr->channel[WRITE_CHANNEL].flag = 0x00;\r\nprivptr->p_buff_ccw=NULL;\r\nprivptr->p_buff_read=NULL;\r\nprivptr->p_buff_write=NULL;\r\nclaw_clear_busy(dev);\r\nCLAW_DBF_TEXT(2, trace, "open EIO");\r\nreturn -EIO;\r\n}\r\nclaw_clear_busy(dev);\r\nCLAW_DBF_TEXT(4, trace, "openok");\r\nreturn 0;\r\n}\r\nstatic void\r\nclaw_irq_handler(struct ccw_device *cdev,\r\nunsigned long intparm, struct irb *irb)\r\n{\r\nstruct chbk *p_ch = NULL;\r\nstruct claw_privbk *privptr = NULL;\r\nstruct net_device *dev = NULL;\r\nstruct claw_env *p_env;\r\nstruct chbk *p_ch_r=NULL;\r\nCLAW_DBF_TEXT(4, trace, "clawirq");\r\nprivptr = dev_get_drvdata(&cdev->dev);\r\nif (!privptr) {\r\ndev_warn(&cdev->dev, "An uninitialized CLAW device received an"\r\n" IRQ, c-%02x d-%02x\n",\r\nirb->scsw.cmd.cstat, irb->scsw.cmd.dstat);\r\nCLAW_DBF_TEXT(2, trace, "badirq");\r\nreturn;\r\n}\r\nif (privptr->channel[READ_CHANNEL].cdev == cdev)\r\np_ch = &privptr->channel[READ_CHANNEL];\r\nelse if (privptr->channel[WRITE_CHANNEL].cdev == cdev)\r\np_ch = &privptr->channel[WRITE_CHANNEL];\r\nelse {\r\ndev_warn(&cdev->dev, "The device is not a CLAW device\n");\r\nCLAW_DBF_TEXT(2, trace, "badchan");\r\nreturn;\r\n}\r\nCLAW_DBF_TEXT_(4, trace, "IRQCH=%d", p_ch->flag);\r\ndev = (struct net_device *) (p_ch->ndev);\r\np_env=privptr->p_env;\r\nmemcpy(p_ch->irb, irb, sizeof(struct irb));\r\nif (irb->scsw.cmd.cstat && !(irb->scsw.cmd.cstat & SCHN_STAT_PCI)) {\r\ndev_info(&cdev->dev,\r\n"%s: subchannel check for device: %04x -"\r\n" Sch Stat %02x Dev Stat %02x CPA - %04x\n",\r\ndev->name, p_ch->devno,\r\nirb->scsw.cmd.cstat, irb->scsw.cmd.dstat,\r\nirb->scsw.cmd.cpa);\r\nCLAW_DBF_TEXT(2, trace, "chanchk");\r\n}\r\nif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK)\r\nccw_check_unit_check(p_ch, irb->ecw[0]);\r\np_ch->last_dstat = irb->scsw.cmd.dstat;\r\nswitch (p_ch->claw_state) {\r\ncase CLAW_STOP:\r\nif (!((p_ch->irb->scsw.cmd.stctl & SCSW_STCTL_SEC_STATUS) ||\r\n(p_ch->irb->scsw.cmd.stctl == SCSW_STCTL_STATUS_PEND) ||\r\n(p_ch->irb->scsw.cmd.stctl ==\r\n(SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND))))\r\nreturn;\r\nwake_up(&p_ch->wait);\r\nCLAW_DBF_TEXT(4, trace, "stop");\r\nreturn;\r\ncase CLAW_START_HALT_IO:\r\nif (!((p_ch->irb->scsw.cmd.stctl & SCSW_STCTL_SEC_STATUS) ||\r\n(p_ch->irb->scsw.cmd.stctl == SCSW_STCTL_STATUS_PEND) ||\r\n(p_ch->irb->scsw.cmd.stctl ==\r\n(SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND)))) {\r\nCLAW_DBF_TEXT(4, trace, "haltio");\r\nreturn;\r\n}\r\nif (p_ch->flag == CLAW_READ) {\r\np_ch->claw_state = CLAW_START_READ;\r\nwake_up(&p_ch->wait);\r\n} else if (p_ch->flag == CLAW_WRITE) {\r\np_ch->claw_state = CLAW_START_WRITE;\r\nclaw_strt_read(dev, LOCK_NO);\r\nclaw_send_control(dev,\r\nSYSTEM_VALIDATE_REQUEST,\r\n0, 0, 0,\r\np_env->host_name,\r\np_env->adapter_name);\r\n} else {\r\ndev_warn(&cdev->dev, "The CLAW device received"\r\n" an unexpected IRQ, "\r\n"c-%02x d-%02x\n",\r\nirb->scsw.cmd.cstat,\r\nirb->scsw.cmd.dstat);\r\nreturn;\r\n}\r\nCLAW_DBF_TEXT(4, trace, "haltio");\r\nreturn;\r\ncase CLAW_START_READ:\r\nCLAW_DBF_TEXT(4, trace, "ReadIRQ");\r\nif (p_ch->irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) {\r\nclear_bit(0, (void *)&p_ch->IO_active);\r\nif ((p_ch->irb->ecw[0] & 0x41) == 0x41 ||\r\n(p_ch->irb->ecw[0] & 0x40) == 0x40 ||\r\n(p_ch->irb->ecw[0]) == 0) {\r\nprivptr->stats.rx_errors++;\r\ndev_info(&cdev->dev,\r\n"%s: Restart is required after remote "\r\n"side recovers \n",\r\ndev->name);\r\n}\r\nCLAW_DBF_TEXT(4, trace, "notrdy");\r\nreturn;\r\n}\r\nif ((p_ch->irb->scsw.cmd.cstat & SCHN_STAT_PCI) &&\r\n(p_ch->irb->scsw.cmd.dstat == 0)) {\r\nif (test_and_set_bit(CLAW_BH_ACTIVE,\r\n(void *)&p_ch->flag_a) == 0)\r\ntasklet_schedule(&p_ch->tasklet);\r\nelse\r\nCLAW_DBF_TEXT(4, trace, "PCINoBH");\r\nCLAW_DBF_TEXT(4, trace, "PCI_read");\r\nreturn;\r\n}\r\nif (!((p_ch->irb->scsw.cmd.stctl & SCSW_STCTL_SEC_STATUS) ||\r\n(p_ch->irb->scsw.cmd.stctl == SCSW_STCTL_STATUS_PEND) ||\r\n(p_ch->irb->scsw.cmd.stctl ==\r\n(SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND)))) {\r\nCLAW_DBF_TEXT(4, trace, "SPend_rd");\r\nreturn;\r\n}\r\nclear_bit(0, (void *)&p_ch->IO_active);\r\nclaw_clearbit_busy(TB_RETRY, dev);\r\nif (test_and_set_bit(CLAW_BH_ACTIVE,\r\n(void *)&p_ch->flag_a) == 0)\r\ntasklet_schedule(&p_ch->tasklet);\r\nelse\r\nCLAW_DBF_TEXT(4, trace, "RdBHAct");\r\nCLAW_DBF_TEXT(4, trace, "RdIRQXit");\r\nreturn;\r\ncase CLAW_START_WRITE:\r\nif (p_ch->irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) {\r\ndev_info(&cdev->dev,\r\n"%s: Unit Check Occurred in "\r\n"write channel\n", dev->name);\r\nclear_bit(0, (void *)&p_ch->IO_active);\r\nif (p_ch->irb->ecw[0] & 0x80) {\r\ndev_info(&cdev->dev,\r\n"%s: Resetting Event "\r\n"occurred:\n", dev->name);\r\ninit_timer(&p_ch->timer);\r\np_ch->timer.function =\r\n(void *)claw_write_retry;\r\np_ch->timer.data = (unsigned long)p_ch;\r\np_ch->timer.expires = jiffies + 10*HZ;\r\nadd_timer(&p_ch->timer);\r\ndev_info(&cdev->dev,\r\n"%s: write connection "\r\n"restarting\n", dev->name);\r\n}\r\nCLAW_DBF_TEXT(4, trace, "rstrtwrt");\r\nreturn;\r\n}\r\nif (p_ch->irb->scsw.cmd.dstat & DEV_STAT_UNIT_EXCEP) {\r\nclear_bit(0, (void *)&p_ch->IO_active);\r\ndev_info(&cdev->dev,\r\n"%s: Unit Exception "\r\n"occurred in write channel\n",\r\ndev->name);\r\n}\r\nif (!((p_ch->irb->scsw.cmd.stctl & SCSW_STCTL_SEC_STATUS) ||\r\n(p_ch->irb->scsw.cmd.stctl == SCSW_STCTL_STATUS_PEND) ||\r\n(p_ch->irb->scsw.cmd.stctl ==\r\n(SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND)))) {\r\nCLAW_DBF_TEXT(4, trace, "writeUE");\r\nreturn;\r\n}\r\nclear_bit(0, (void *)&p_ch->IO_active);\r\nif (claw_test_and_setbit_busy(TB_TX, dev) == 0) {\r\nclaw_write_next(p_ch);\r\nclaw_clearbit_busy(TB_TX, dev);\r\nclaw_clear_busy(dev);\r\n}\r\np_ch_r = (struct chbk *)&privptr->channel[READ_CHANNEL];\r\nif (test_and_set_bit(CLAW_BH_ACTIVE,\r\n(void *)&p_ch_r->flag_a) == 0)\r\ntasklet_schedule(&p_ch_r->tasklet);\r\nCLAW_DBF_TEXT(4, trace, "StWtExit");\r\nreturn;\r\ndefault:\r\ndev_warn(&cdev->dev,\r\n"The CLAW device for %s received an unexpected IRQ\n",\r\ndev->name);\r\nCLAW_DBF_TEXT(2, trace, "badIRQ");\r\nreturn;\r\n}\r\n}\r\nstatic void\r\nclaw_irq_tasklet ( unsigned long data )\r\n{\r\nstruct chbk * p_ch;\r\nstruct net_device *dev;\r\np_ch = (struct chbk *) data;\r\ndev = (struct net_device *)p_ch->ndev;\r\nCLAW_DBF_TEXT(4, trace, "IRQtask");\r\nunpack_read(dev);\r\nclear_bit(CLAW_BH_ACTIVE, (void *)&p_ch->flag_a);\r\nCLAW_DBF_TEXT(4, trace, "TskletXt");\r\nreturn;\r\n}\r\nstatic int\r\nclaw_release(struct net_device *dev)\r\n{\r\nint rc;\r\nint i;\r\nunsigned long saveflags;\r\nunsigned long parm;\r\nstruct claw_privbk *privptr;\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct ccwbk* p_this_ccw;\r\nstruct ccwbk* p_buf;\r\nif (!dev)\r\nreturn 0;\r\nprivptr = (struct claw_privbk *)dev->ml_priv;\r\nif (!privptr)\r\nreturn 0;\r\nCLAW_DBF_TEXT(4, trace, "release");\r\nprivptr->release_pend=1;\r\nclaw_setbit_busy(TB_STOP,dev);\r\nfor ( i = 1; i >=0 ; i--) {\r\nspin_lock_irqsave(\r\nget_ccwdev_lock(privptr->channel[i].cdev), saveflags);\r\nprivptr->channel[i].claw_state = CLAW_STOP;\r\nprivptr->channel[i].IO_active = 0;\r\nparm = (unsigned long) &privptr->channel[i];\r\nif (i == WRITE_CHANNEL)\r\nclaw_purge_skb_queue(\r\n&privptr->channel[WRITE_CHANNEL].collect_queue);\r\nrc = ccw_device_halt (privptr->channel[i].cdev, parm);\r\nif (privptr->system_validate_comp==0x00)\r\ninit_waitqueue_head(&privptr->channel[i].wait);\r\nadd_wait_queue(&privptr->channel[i].wait, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(\r\nget_ccwdev_lock(privptr->channel[i].cdev), saveflags);\r\nschedule();\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&privptr->channel[i].wait, &wait);\r\nif (rc != 0) {\r\nccw_check_return_code(privptr->channel[i].cdev, rc);\r\n}\r\n}\r\nif (privptr->pk_skb != NULL) {\r\ndev_kfree_skb_any(privptr->pk_skb);\r\nprivptr->pk_skb = NULL;\r\n}\r\nif(privptr->buffs_alloc != 1) {\r\nCLAW_DBF_TEXT(4, trace, "none2fre");\r\nreturn 0;\r\n}\r\nCLAW_DBF_TEXT(4, trace, "freebufs");\r\nif (privptr->p_buff_ccw != NULL) {\r\nfree_pages((unsigned long)privptr->p_buff_ccw,\r\n(int)pages_to_order_of_mag(privptr->p_buff_ccw_num));\r\n}\r\nCLAW_DBF_TEXT(4, trace, "freeread");\r\nif (privptr->p_env->read_size < PAGE_SIZE) {\r\nif (privptr->p_buff_read != NULL) {\r\nfree_pages((unsigned long)privptr->p_buff_read,\r\n(int)pages_to_order_of_mag(privptr->p_buff_read_num));\r\n}\r\n}\r\nelse {\r\np_buf=privptr->p_read_active_first;\r\nwhile (p_buf!=NULL) {\r\nfree_pages((unsigned long)p_buf->p_buffer,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_pages_perread ));\r\np_buf=p_buf->next;\r\n}\r\n}\r\nCLAW_DBF_TEXT(4, trace, "freewrit");\r\nif (privptr->p_env->write_size < PAGE_SIZE ) {\r\nfree_pages((unsigned long)privptr->p_buff_write,\r\n(int)pages_to_order_of_mag(privptr->p_buff_write_num));\r\n}\r\nelse {\r\np_buf=privptr->p_write_active_first;\r\nwhile (p_buf!=NULL) {\r\nfree_pages((unsigned long)p_buf->p_buffer,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_pages_perwrite ));\r\np_buf=p_buf->next;\r\n}\r\n}\r\nCLAW_DBF_TEXT(4, trace, "clearptr");\r\nprivptr->buffs_alloc = 0;\r\nprivptr->p_buff_ccw=NULL;\r\nprivptr->p_buff_read=NULL;\r\nprivptr->p_buff_write=NULL;\r\nprivptr->system_validate_comp=0;\r\nprivptr->release_pend=0;\r\np_this_ccw=privptr->p_read_active_first;\r\nwhile (p_this_ccw!=NULL) {\r\np_this_ccw->header.length=0xffff;\r\np_this_ccw->header.opcode=0xff;\r\np_this_ccw->header.flag=0x00;\r\np_this_ccw=p_this_ccw->next;\r\n}\r\nwhile (privptr->p_write_active_first!=NULL) {\r\np_this_ccw=privptr->p_write_active_first;\r\np_this_ccw->header.flag=CLAW_PENDING;\r\nprivptr->p_write_active_first=p_this_ccw->next;\r\np_this_ccw->next=privptr->p_write_free_chain;\r\nprivptr->p_write_free_chain=p_this_ccw;\r\n++privptr->write_free_count;\r\n}\r\nprivptr->p_write_active_last=NULL;\r\nprivptr->mtc_logical_link = -1;\r\nprivptr->mtc_skipping = 1;\r\nprivptr->mtc_offset=0;\r\nif (((privptr->channel[READ_CHANNEL].last_dstat |\r\nprivptr->channel[WRITE_CHANNEL].last_dstat) &\r\n~(DEV_STAT_CHN_END | DEV_STAT_DEV_END)) != 0x00) {\r\ndev_warn(&privptr->channel[READ_CHANNEL].cdev->dev,\r\n"Deactivating %s completed with incorrect"\r\n" subchannel status "\r\n"(read %02x, write %02x)\n",\r\ndev->name,\r\nprivptr->channel[READ_CHANNEL].last_dstat,\r\nprivptr->channel[WRITE_CHANNEL].last_dstat);\r\nCLAW_DBF_TEXT(2, trace, "badclose");\r\n}\r\nCLAW_DBF_TEXT(4, trace, "rlsexit");\r\nreturn 0;\r\n}\r\nstatic void\r\nclaw_write_retry ( struct chbk *p_ch )\r\n{\r\nstruct net_device *dev=p_ch->ndev;\r\nCLAW_DBF_TEXT(4, trace, "w_retry");\r\nif (p_ch->claw_state == CLAW_STOP) {\r\nreturn;\r\n}\r\nclaw_strt_out_IO( dev );\r\nCLAW_DBF_TEXT(4, trace, "rtry_xit");\r\nreturn;\r\n}\r\nstatic void\r\nclaw_write_next ( struct chbk * p_ch )\r\n{\r\nstruct net_device *dev;\r\nstruct claw_privbk *privptr=NULL;\r\nstruct sk_buff *pk_skb;\r\nCLAW_DBF_TEXT(4, trace, "claw_wrt");\r\nif (p_ch->claw_state == CLAW_STOP)\r\nreturn;\r\ndev = (struct net_device *) p_ch->ndev;\r\nprivptr = (struct claw_privbk *) dev->ml_priv;\r\nclaw_free_wrt_buf( dev );\r\nif ((privptr->write_free_count > 0) &&\r\n!skb_queue_empty(&p_ch->collect_queue)) {\r\npk_skb = claw_pack_skb(privptr);\r\nwhile (pk_skb != NULL) {\r\nclaw_hw_tx(pk_skb, dev, 1);\r\nif (privptr->write_free_count > 0) {\r\npk_skb = claw_pack_skb(privptr);\r\n} else\r\npk_skb = NULL;\r\n}\r\n}\r\nif (privptr->p_write_active_first!=NULL) {\r\nclaw_strt_out_IO(dev);\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nclaw_timer ( struct chbk * p_ch )\r\n{\r\nCLAW_DBF_TEXT(4, trace, "timer");\r\np_ch->flag |= CLAW_TIMER;\r\nwake_up(&p_ch->wait);\r\nreturn;\r\n}\r\nstatic int\r\npages_to_order_of_mag(int num_of_pages)\r\n{\r\nint order_of_mag=1;\r\nint nump;\r\nCLAW_DBF_TEXT_(5, trace, "pages%d", num_of_pages);\r\nif (num_of_pages == 1) {return 0; }\r\nif (num_of_pages >= 512) {return 9; }\r\nfor (nump=2 ;nump <= 512;nump*=2) {\r\nif (num_of_pages <= nump)\r\nbreak;\r\norder_of_mag +=1;\r\n}\r\nif (order_of_mag > 9) { order_of_mag = 9; }\r\nCLAW_DBF_TEXT_(5, trace, "mag%d", order_of_mag);\r\nreturn order_of_mag;\r\n}\r\nstatic int\r\nadd_claw_reads(struct net_device *dev, struct ccwbk* p_first,\r\nstruct ccwbk* p_last)\r\n{\r\nstruct claw_privbk *privptr;\r\nstruct ccw1 temp_ccw;\r\nstruct endccw * p_end;\r\nCLAW_DBF_TEXT(4, trace, "addreads");\r\nprivptr = dev->ml_priv;\r\np_end = privptr->p_end_ccw;\r\nif ( p_first==NULL) {\r\nCLAW_DBF_TEXT(4, trace, "addexit");\r\nreturn 0;\r\n}\r\nif (p_end->read1) {\r\np_end->read1=0x00;\r\np_end->read2_nop2.cmd_code = CCW_CLAW_CMD_READFF;\r\np_end->read2_nop2.flags = CCW_FLAG_SLI | CCW_FLAG_SKIP;\r\np_last->r_TIC_1.cda =(__u32)__pa(&p_end->read2_nop1);\r\np_last->r_TIC_2.cda =(__u32)__pa(&p_end->read2_nop1);\r\np_end->read2_nop2.cda=0;\r\np_end->read2_nop2.count=1;\r\n}\r\nelse {\r\np_end->read1=0x01;\r\np_end->read1_nop2.cmd_code = CCW_CLAW_CMD_READFF;\r\np_end->read1_nop2.flags = CCW_FLAG_SLI | CCW_FLAG_SKIP;\r\np_last->r_TIC_1.cda = (__u32)__pa(&p_end->read1_nop1);\r\np_last->r_TIC_2.cda = (__u32)__pa(&p_end->read1_nop1);\r\np_end->read1_nop2.cda=0;\r\np_end->read1_nop2.count=1;\r\n}\r\nif ( privptr-> p_read_active_first ==NULL ) {\r\nprivptr->p_read_active_first = p_first;\r\nprivptr->p_read_active_last = p_last;\r\n}\r\nelse {\r\ntemp_ccw.cda= (__u32)__pa(&p_first->read);\r\ntemp_ccw.count=0;\r\ntemp_ccw.flags=0;\r\ntemp_ccw.cmd_code = CCW_CLAW_CMD_TIC;\r\nif (p_end->read1) {\r\nmemcpy( &p_end->read2_nop2, &temp_ccw ,\r\nsizeof(struct ccw1));\r\nprivptr->p_read_active_last->r_TIC_1.cda=\r\n(__u32)__pa(&p_first->read);\r\nprivptr->p_read_active_last->r_TIC_2.cda=\r\n(__u32)__pa(&p_first->read);\r\n}\r\nelse {\r\nmemcpy( &p_end->read1_nop2, &temp_ccw ,\r\nsizeof(struct ccw1));\r\nprivptr->p_read_active_last->r_TIC_1.cda=\r\n(__u32)__pa(&p_first->read);\r\nprivptr->p_read_active_last->r_TIC_2.cda=\r\n(__u32)__pa(&p_first->read);\r\n}\r\nprivptr->p_read_active_last->next = p_first;\r\nprivptr->p_read_active_last=p_last;\r\n}\r\nCLAW_DBF_TEXT(4, trace, "addexit");\r\nreturn 0;\r\n}\r\nstatic void\r\nccw_check_return_code(struct ccw_device *cdev, int return_code)\r\n{\r\nCLAW_DBF_TEXT(4, trace, "ccwret");\r\nif (return_code != 0) {\r\nswitch (return_code) {\r\ncase -EBUSY:\r\nbreak;\r\ncase -ENODEV:\r\ndev_err(&cdev->dev, "The remote channel adapter is not"\r\n" available\n");\r\nbreak;\r\ncase -EINVAL:\r\ndev_err(&cdev->dev,\r\n"The status of the remote channel adapter"\r\n" is not valid\n");\r\nbreak;\r\ndefault:\r\ndev_err(&cdev->dev, "The common device layer"\r\n" returned error code %d\n",\r\nreturn_code);\r\n}\r\n}\r\nCLAW_DBF_TEXT(4, trace, "ccwret");\r\n}\r\nstatic void\r\nccw_check_unit_check(struct chbk * p_ch, unsigned char sense )\r\n{\r\nstruct net_device *ndev = p_ch->ndev;\r\nstruct device *dev = &p_ch->cdev->dev;\r\nCLAW_DBF_TEXT(4, trace, "unitchek");\r\ndev_warn(dev, "The communication peer of %s disconnected\n",\r\nndev->name);\r\nif (sense & 0x40) {\r\nif (sense & 0x01) {\r\ndev_warn(dev, "The remote channel adapter for"\r\n" %s has been reset\n",\r\nndev->name);\r\n}\r\n} else if (sense & 0x20) {\r\nif (sense & 0x04) {\r\ndev_warn(dev, "A data streaming timeout occurred"\r\n" for %s\n",\r\nndev->name);\r\n} else if (sense & 0x10) {\r\ndev_warn(dev, "The remote channel adapter for %s"\r\n" is faulty\n",\r\nndev->name);\r\n} else {\r\ndev_warn(dev, "A data transfer parity error occurred"\r\n" for %s\n",\r\nndev->name);\r\n}\r\n} else if (sense & 0x10) {\r\ndev_warn(dev, "A read data parity error occurred"\r\n" for %s\n",\r\nndev->name);\r\n}\r\n}\r\nstatic int\r\nfind_link(struct net_device *dev, char *host_name, char *ws_name )\r\n{\r\nstruct claw_privbk *privptr;\r\nstruct claw_env *p_env;\r\nint rc=0;\r\nCLAW_DBF_TEXT(2, setup, "findlink");\r\nprivptr = dev->ml_priv;\r\np_env=privptr->p_env;\r\nswitch (p_env->packing)\r\n{\r\ncase PACKING_ASK:\r\nif ((memcmp(WS_APPL_NAME_PACKED, host_name, 8)!=0) ||\r\n(memcmp(WS_APPL_NAME_PACKED, ws_name, 8)!=0 ))\r\nrc = EINVAL;\r\nbreak;\r\ncase DO_PACKED:\r\ncase PACK_SEND:\r\nif ((memcmp(WS_APPL_NAME_IP_NAME, host_name, 8)!=0) ||\r\n(memcmp(WS_APPL_NAME_IP_NAME, ws_name, 8)!=0 ))\r\nrc = EINVAL;\r\nbreak;\r\ndefault:\r\nif ((memcmp(HOST_APPL_NAME, host_name, 8)!=0) ||\r\n(memcmp(p_env->api_type , ws_name, 8)!=0))\r\nrc = EINVAL;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nclaw_hw_tx(struct sk_buff *skb, struct net_device *dev, long linkid)\r\n{\r\nint rc=0;\r\nstruct claw_privbk *privptr;\r\nstruct ccwbk *p_this_ccw;\r\nstruct ccwbk *p_first_ccw;\r\nstruct ccwbk *p_last_ccw;\r\n__u32 numBuffers;\r\nsigned long len_of_data;\r\nunsigned long bytesInThisBuffer;\r\nunsigned char *pDataAddress;\r\nstruct endccw *pEnd;\r\nstruct ccw1 tempCCW;\r\nstruct claw_env *p_env;\r\nstruct clawph *pk_head;\r\nstruct chbk *ch;\r\nCLAW_DBF_TEXT(4, trace, "hw_tx");\r\nprivptr = (struct claw_privbk *)(dev->ml_priv);\r\np_env =privptr->p_env;\r\nclaw_free_wrt_buf(dev);\r\np_first_ccw=NULL;\r\np_last_ccw=NULL;\r\nif ((p_env->packing >= PACK_SEND) &&\r\n(skb->cb[1] != 'P')) {\r\nskb_push(skb,sizeof(struct clawph));\r\npk_head=(struct clawph *)skb->data;\r\npk_head->len=skb->len-sizeof(struct clawph);\r\nif (pk_head->len%4) {\r\npk_head->len+= 4-(pk_head->len%4);\r\nskb_pad(skb,4-(pk_head->len%4));\r\nskb_put(skb,4-(pk_head->len%4));\r\n}\r\nif (p_env->packing == DO_PACKED)\r\npk_head->link_num = linkid;\r\nelse\r\npk_head->link_num = 0;\r\npk_head->flag = 0x00;\r\nskb_pad(skb,4);\r\nskb->cb[1] = 'P';\r\n}\r\nif (linkid == 0) {\r\nif (claw_check_busy(dev)) {\r\nif (privptr->write_free_count!=0) {\r\nclaw_clear_busy(dev);\r\n}\r\nelse {\r\nclaw_strt_out_IO(dev );\r\nclaw_free_wrt_buf( dev );\r\nif (privptr->write_free_count==0) {\r\nch = &privptr->channel[WRITE_CHANNEL];\r\natomic_inc(&skb->users);\r\nskb_queue_tail(&ch->collect_queue, skb);\r\ngoto Done;\r\n}\r\nelse {\r\nclaw_clear_busy(dev);\r\n}\r\n}\r\n}\r\nif (claw_test_and_setbit_busy(TB_TX,dev)) {\r\nch = &privptr->channel[WRITE_CHANNEL];\r\natomic_inc(&skb->users);\r\nskb_queue_tail(&ch->collect_queue, skb);\r\nclaw_strt_out_IO(dev );\r\nrc=-EBUSY;\r\ngoto Done2;\r\n}\r\n}\r\nnumBuffers = DIV_ROUND_UP(skb->len, privptr->p_env->write_size);\r\nif (privptr->write_free_count < numBuffers ||\r\nprivptr->p_write_free_chain == NULL ) {\r\nclaw_setbit_busy(TB_NOBUFFER,dev);\r\nch = &privptr->channel[WRITE_CHANNEL];\r\natomic_inc(&skb->users);\r\nskb_queue_tail(&ch->collect_queue, skb);\r\nCLAW_DBF_TEXT(2, trace, "clawbusy");\r\ngoto Done2;\r\n}\r\npDataAddress=skb->data;\r\nlen_of_data=skb->len;\r\nwhile (len_of_data > 0) {\r\np_this_ccw=privptr->p_write_free_chain;\r\nif (p_this_ccw == NULL) {\r\nch = &privptr->channel[WRITE_CHANNEL];\r\natomic_inc(&skb->users);\r\nskb_queue_tail(&ch->collect_queue, skb);\r\ngoto Done2;\r\n}\r\nprivptr->p_write_free_chain=p_this_ccw->next;\r\np_this_ccw->next=NULL;\r\n--privptr->write_free_count;\r\nif (len_of_data >= privptr->p_env->write_size)\r\nbytesInThisBuffer = privptr->p_env->write_size;\r\nelse\r\nbytesInThisBuffer = len_of_data;\r\nmemcpy( p_this_ccw->p_buffer,pDataAddress, bytesInThisBuffer);\r\nlen_of_data-=bytesInThisBuffer;\r\npDataAddress+=(unsigned long)bytesInThisBuffer;\r\np_this_ccw->write.cmd_code = (linkid * 8) +1;\r\nif (len_of_data>0) {\r\np_this_ccw->write.cmd_code+=MORE_to_COME_FLAG;\r\n}\r\np_this_ccw->write.count=bytesInThisBuffer;\r\nif (p_first_ccw==NULL) {\r\np_first_ccw=p_this_ccw;\r\n}\r\nif (p_last_ccw!=NULL) {\r\np_last_ccw->next=p_this_ccw;\r\np_last_ccw->w_TIC_1.cda=\r\n(__u32)__pa(&p_this_ccw->write);\r\n}\r\np_last_ccw=p_this_ccw;\r\n}\r\nif (p_first_ccw!=NULL) {\r\npEnd=privptr->p_end_ccw;\r\nif (pEnd->write1) {\r\npEnd->write1=0x00;\r\np_last_ccw->w_TIC_1.cda=\r\n(__u32)__pa(&pEnd->write2_nop1);\r\npEnd->write2_nop2.cmd_code = CCW_CLAW_CMD_READFF;\r\npEnd->write2_nop2.flags =\r\nCCW_FLAG_SLI | CCW_FLAG_SKIP;\r\npEnd->write2_nop2.cda=0;\r\npEnd->write2_nop2.count=1;\r\n}\r\nelse {\r\npEnd->write1=0x01;\r\np_last_ccw->w_TIC_1.cda=\r\n(__u32)__pa(&pEnd->write1_nop1);\r\npEnd->write1_nop2.cmd_code = CCW_CLAW_CMD_READFF;\r\npEnd->write1_nop2.flags =\r\nCCW_FLAG_SLI | CCW_FLAG_SKIP;\r\npEnd->write1_nop2.cda=0;\r\npEnd->write1_nop2.count=1;\r\n}\r\nif (privptr->p_write_active_first==NULL ) {\r\nprivptr->p_write_active_first=p_first_ccw;\r\nprivptr->p_write_active_last=p_last_ccw;\r\n}\r\nelse {\r\ntempCCW.cda=(__u32)__pa(&p_first_ccw->write);\r\ntempCCW.count=0;\r\ntempCCW.flags=0;\r\ntempCCW.cmd_code=CCW_CLAW_CMD_TIC;\r\nif (pEnd->write1) {\r\nmemcpy( &pEnd->write2_nop2, &tempCCW ,\r\nsizeof(struct ccw1));\r\nprivptr->p_write_active_last->w_TIC_1.cda=\r\n(__u32)__pa(&p_first_ccw->write);\r\n}\r\nelse {\r\nmemcpy(&pEnd->write1_nop2, &tempCCW ,\r\nsizeof(struct ccw1));\r\nprivptr->p_write_active_last->w_TIC_1.cda=\r\n(__u32)__pa(&p_first_ccw->write);\r\n}\r\nprivptr->p_write_active_last->next=p_first_ccw;\r\nprivptr->p_write_active_last=p_last_ccw;\r\n}\r\n}\r\ndev_kfree_skb_any(skb);\r\nclaw_strt_out_IO(dev );\r\nif (privptr->write_free_count==0) {\r\nclaw_setbit_busy(TB_NOBUFFER,dev);\r\n}\r\nDone2:\r\nclaw_clearbit_busy(TB_TX,dev);\r\nDone:\r\nreturn(rc);\r\n}\r\nstatic int\r\ninit_ccw_bk(struct net_device *dev)\r\n{\r\n__u32 ccw_blocks_required;\r\n__u32 ccw_blocks_perpage;\r\n__u32 ccw_pages_required;\r\n__u32 claw_reads_perpage=1;\r\n__u32 claw_read_pages;\r\n__u32 claw_writes_perpage=1;\r\n__u32 claw_write_pages;\r\nvoid *p_buff=NULL;\r\nstruct ccwbk*p_free_chain;\r\nstruct ccwbk*p_buf;\r\nstruct ccwbk*p_last_CCWB;\r\nstruct ccwbk*p_first_CCWB;\r\nstruct endccw *p_endccw=NULL;\r\naddr_t real_address;\r\nstruct claw_privbk *privptr = dev->ml_priv;\r\nstruct clawh *pClawH=NULL;\r\naddr_t real_TIC_address;\r\nint i,j;\r\nCLAW_DBF_TEXT(4, trace, "init_ccw");\r\nprivptr->active_link_ID=0;\r\nprivptr->p_write_free_chain=NULL;\r\nprivptr->p_write_active_first=NULL;\r\nprivptr->p_write_active_last=NULL;\r\nprivptr->p_read_active_first=NULL;\r\nprivptr->p_read_active_last=NULL;\r\nprivptr->p_end_ccw=NULL;\r\nprivptr->p_claw_signal_blk=NULL;\r\nprivptr->buffs_alloc = 0;\r\nmemset(&privptr->end_ccw, 0x00, sizeof(struct endccw));\r\nmemset(&privptr->ctl_bk, 0x00, sizeof(struct clawctl));\r\nprivptr->write_free_count=0;\r\np_last_CCWB = NULL;\r\np_first_CCWB= NULL;\r\nccw_blocks_required =\r\nprivptr->p_env->read_buffers+privptr->p_env->write_buffers+1;\r\nccw_blocks_perpage= PAGE_SIZE / CCWBK_SIZE;\r\nccw_pages_required=\r\nDIV_ROUND_UP(ccw_blocks_required, ccw_blocks_perpage);\r\nif (privptr->p_env->read_size < PAGE_SIZE) {\r\nclaw_reads_perpage = PAGE_SIZE / privptr->p_env->read_size;\r\nclaw_read_pages = DIV_ROUND_UP(privptr->p_env->read_buffers,\r\nclaw_reads_perpage);\r\n}\r\nelse {\r\nprivptr->p_buff_pages_perread =\r\nDIV_ROUND_UP(privptr->p_env->read_size, PAGE_SIZE);\r\nclaw_read_pages = privptr->p_env->read_buffers *\r\nprivptr->p_buff_pages_perread;\r\n}\r\nif (privptr->p_env->write_size < PAGE_SIZE) {\r\nclaw_writes_perpage =\r\nPAGE_SIZE / privptr->p_env->write_size;\r\nclaw_write_pages = DIV_ROUND_UP(privptr->p_env->write_buffers,\r\nclaw_writes_perpage);\r\n}\r\nelse {\r\nprivptr->p_buff_pages_perwrite =\r\nDIV_ROUND_UP(privptr->p_env->read_size, PAGE_SIZE);\r\nclaw_write_pages = privptr->p_env->write_buffers *\r\nprivptr->p_buff_pages_perwrite;\r\n}\r\nif (privptr->p_buff_ccw==NULL) {\r\nprivptr->p_buff_ccw=\r\n(void *)__get_free_pages(__GFP_DMA,\r\n(int)pages_to_order_of_mag(ccw_pages_required ));\r\nif (privptr->p_buff_ccw==NULL) {\r\nreturn -ENOMEM;\r\n}\r\nprivptr->p_buff_ccw_num=ccw_pages_required;\r\n}\r\nmemset(privptr->p_buff_ccw, 0x00,\r\nprivptr->p_buff_ccw_num * PAGE_SIZE);\r\nprivptr->p_end_ccw = (struct endccw *)&privptr->end_ccw;\r\nreal_address = (__u32)__pa(privptr->p_end_ccw);\r\np_endccw=privptr->p_end_ccw;\r\np_endccw->real=real_address;\r\np_endccw->write1=0x00;\r\np_endccw->read1=0x00;\r\np_endccw->write1_nop1.cmd_code = CCW_CLAW_CMD_NOP;\r\np_endccw->write1_nop1.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_endccw->write1_nop1.count = 1;\r\np_endccw->write1_nop1.cda = 0;\r\np_endccw->write1_nop2.cmd_code = CCW_CLAW_CMD_READFF;\r\np_endccw->write1_nop2.flags = CCW_FLAG_SLI | CCW_FLAG_SKIP;\r\np_endccw->write1_nop2.count = 1;\r\np_endccw->write1_nop2.cda = 0;\r\np_endccw->write2_nop1.cmd_code = CCW_CLAW_CMD_NOP;\r\np_endccw->write2_nop1.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_endccw->write2_nop1.count = 1;\r\np_endccw->write2_nop1.cda = 0;\r\np_endccw->write2_nop2.cmd_code = CCW_CLAW_CMD_READFF;\r\np_endccw->write2_nop2.flags = CCW_FLAG_SLI | CCW_FLAG_SKIP;\r\np_endccw->write2_nop2.count = 1;\r\np_endccw->write2_nop2.cda = 0;\r\np_endccw->read1_nop1.cmd_code = CCW_CLAW_CMD_NOP;\r\np_endccw->read1_nop1.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_endccw->read1_nop1.count = 1;\r\np_endccw->read1_nop1.cda = 0;\r\np_endccw->read1_nop2.cmd_code = CCW_CLAW_CMD_READFF;\r\np_endccw->read1_nop2.flags = CCW_FLAG_SLI | CCW_FLAG_SKIP;\r\np_endccw->read1_nop2.count = 1;\r\np_endccw->read1_nop2.cda = 0;\r\np_endccw->read2_nop1.cmd_code = CCW_CLAW_CMD_NOP;\r\np_endccw->read2_nop1.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_endccw->read2_nop1.count = 1;\r\np_endccw->read2_nop1.cda = 0;\r\np_endccw->read2_nop2.cmd_code = CCW_CLAW_CMD_READFF;\r\np_endccw->read2_nop2.flags = CCW_FLAG_SLI | CCW_FLAG_SKIP;\r\np_endccw->read2_nop2.count = 1;\r\np_endccw->read2_nop2.cda = 0;\r\np_buff=privptr->p_buff_ccw;\r\np_free_chain=NULL;\r\nfor (i=0 ; i < ccw_pages_required; i++ ) {\r\nreal_address = (__u32)__pa(p_buff);\r\np_buf=p_buff;\r\nfor (j=0 ; j < ccw_blocks_perpage ; j++) {\r\np_buf->next = p_free_chain;\r\np_free_chain = p_buf;\r\np_buf->real=(__u32)__pa(p_buf);\r\n++p_buf;\r\n}\r\np_buff+=PAGE_SIZE;\r\n}\r\nif (privptr->p_claw_signal_blk==NULL) {\r\nprivptr->p_claw_signal_blk=p_free_chain;\r\np_free_chain=p_free_chain->next;\r\npClawH=(struct clawh *)privptr->p_claw_signal_blk;\r\npClawH->length=0xffff;\r\npClawH->opcode=0xff;\r\npClawH->flag=CLAW_BUSY;\r\n}\r\nif (privptr->p_buff_write==NULL) {\r\nif (privptr->p_env->write_size < PAGE_SIZE) {\r\nprivptr->p_buff_write=\r\n(void *)__get_free_pages(__GFP_DMA,\r\n(int)pages_to_order_of_mag(claw_write_pages ));\r\nif (privptr->p_buff_write==NULL) {\r\nprivptr->p_buff_ccw=NULL;\r\nreturn -ENOMEM;\r\n}\r\nmemset(privptr->p_buff_write, 0x00,\r\nccw_pages_required * PAGE_SIZE);\r\nprivptr->p_write_free_chain=NULL;\r\np_buff=privptr->p_buff_write;\r\nfor (i=0 ; i< privptr->p_env->write_buffers ; i++) {\r\np_buf = p_free_chain;\r\np_free_chain = p_buf->next;\r\np_buf->next =privptr->p_write_free_chain;\r\nprivptr->p_write_free_chain = p_buf;\r\np_buf-> p_buffer = (struct clawbuf *)p_buff;\r\np_buf-> write.cda = (__u32)__pa(p_buff);\r\np_buf-> write.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_buf-> w_read_FF.cmd_code = CCW_CLAW_CMD_READFF;\r\np_buf-> w_read_FF.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_buf-> w_read_FF.count = 1;\r\np_buf-> w_read_FF.cda =\r\n(__u32)__pa(&p_buf-> header.flag);\r\np_buf-> w_TIC_1.cmd_code = CCW_CLAW_CMD_TIC;\r\np_buf-> w_TIC_1.flags = 0;\r\np_buf-> w_TIC_1.count = 0;\r\nif (((unsigned long)p_buff +\r\nprivptr->p_env->write_size) >=\r\n((unsigned long)(p_buff+2*\r\n(privptr->p_env->write_size) - 1) & PAGE_MASK)) {\r\np_buff = p_buff+privptr->p_env->write_size;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nprivptr->p_write_free_chain=NULL;\r\nfor (i = 0; i< privptr->p_env->write_buffers ; i++) {\r\np_buff=(void *)__get_free_pages(__GFP_DMA,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_pages_perwrite) );\r\nif (p_buff==NULL) {\r\nfree_pages((unsigned long)privptr->p_buff_ccw,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_ccw_num));\r\nprivptr->p_buff_ccw=NULL;\r\np_buf=privptr->p_buff_write;\r\nwhile (p_buf!=NULL) {\r\nfree_pages((unsigned long)\r\np_buf->p_buffer,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_pages_perwrite));\r\np_buf=p_buf->next;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nmemset(p_buff, 0x00, privptr->p_env->write_size );\r\np_buf = p_free_chain;\r\np_free_chain = p_buf->next;\r\np_buf->next = privptr->p_write_free_chain;\r\nprivptr->p_write_free_chain = p_buf;\r\nprivptr->p_buff_write = p_buf;\r\np_buf->p_buffer=(struct clawbuf *)p_buff;\r\np_buf-> write.cda = (__u32)__pa(p_buff);\r\np_buf-> write.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_buf-> w_read_FF.cmd_code = CCW_CLAW_CMD_READFF;\r\np_buf-> w_read_FF.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_buf-> w_read_FF.count = 1;\r\np_buf-> w_read_FF.cda =\r\n(__u32)__pa(&p_buf-> header.flag);\r\np_buf-> w_TIC_1.cmd_code = CCW_CLAW_CMD_TIC;\r\np_buf-> w_TIC_1.flags = 0;\r\np_buf-> w_TIC_1.count = 0;\r\n}\r\n}\r\n}\r\nprivptr->p_buff_write_num=claw_write_pages;\r\nprivptr->write_free_count=privptr->p_env->write_buffers;\r\nif (privptr->p_buff_read==NULL) {\r\nif (privptr->p_env->read_size < PAGE_SIZE) {\r\nprivptr->p_buff_read=\r\n(void *)__get_free_pages(__GFP_DMA,\r\n(int)pages_to_order_of_mag(claw_read_pages) );\r\nif (privptr->p_buff_read==NULL) {\r\nfree_pages((unsigned long)privptr->p_buff_ccw,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_ccw_num));\r\nfree_pages((unsigned long)privptr->p_buff_write,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_write_num));\r\nprivptr->p_buff_ccw=NULL;\r\nprivptr->p_buff_write=NULL;\r\nreturn -ENOMEM;\r\n}\r\nmemset(privptr->p_buff_read, 0x00, claw_read_pages * PAGE_SIZE);\r\nprivptr->p_buff_read_num=claw_read_pages;\r\np_buff=privptr->p_buff_read;\r\nfor (i=0 ; i< privptr->p_env->read_buffers ; i++) {\r\np_buf = p_free_chain;\r\np_free_chain = p_buf->next;\r\nif (p_last_CCWB==NULL) {\r\np_buf->next=NULL;\r\nreal_TIC_address=0;\r\np_last_CCWB=p_buf;\r\n}\r\nelse {\r\np_buf->next=p_first_CCWB;\r\nreal_TIC_address=\r\n(__u32)__pa(&p_first_CCWB -> read );\r\n}\r\np_first_CCWB=p_buf;\r\np_buf->p_buffer=(struct clawbuf *)p_buff;\r\np_buf-> read.cmd_code = CCW_CLAW_CMD_READ;\r\np_buf-> read.cda = (__u32)__pa(p_buff);\r\np_buf-> read.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_buf-> read.count = privptr->p_env->read_size;\r\np_buf-> read_h.cmd_code = CCW_CLAW_CMD_READHEADER;\r\np_buf-> read_h.cda =\r\n(__u32)__pa(&(p_buf->header));\r\np_buf-> read_h.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_buf-> read_h.count = sizeof(struct clawh);\r\np_buf-> signal.cmd_code = CCW_CLAW_CMD_SIGNAL_SMOD;\r\np_buf-> signal.cda =\r\n(__u32)__pa(&(pClawH->flag));\r\np_buf-> signal.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_buf-> signal.count = 1;\r\np_buf-> r_TIC_1.cmd_code = CCW_CLAW_CMD_TIC;\r\np_buf-> r_TIC_1.cda = (__u32)real_TIC_address;\r\np_buf-> r_TIC_1.flags = 0;\r\np_buf-> r_TIC_1.count = 0;\r\np_buf-> r_read_FF.cmd_code = CCW_CLAW_CMD_READFF;\r\np_buf-> r_read_FF.cda =\r\n(__u32)__pa(&(pClawH->flag));\r\np_buf-> r_read_FF.flags =\r\nCCW_FLAG_SLI | CCW_FLAG_CC | CCW_FLAG_PCI;\r\np_buf-> r_read_FF.count = 1;\r\nmemcpy(&p_buf->r_TIC_2,\r\n&p_buf->r_TIC_1, sizeof(struct ccw1));\r\np_buf->header.length=0xffff;\r\np_buf->header.opcode=0xff;\r\np_buf->header.flag=CLAW_PENDING;\r\nif (((unsigned long)p_buff+privptr->p_env->read_size) >=\r\n((unsigned long)(p_buff+2*(privptr->p_env->read_size)\r\n-1)\r\n& PAGE_MASK)) {\r\np_buff= p_buff+privptr->p_env->read_size;\r\n}\r\nelse {\r\np_buff=\r\n(void *)((unsigned long)\r\n(p_buff+2*(privptr->p_env->read_size)-1)\r\n& PAGE_MASK) ;\r\n}\r\n}\r\n}\r\nelse {\r\nfor (i=0 ; i< privptr->p_env->read_buffers ; i++) {\r\np_buff = (void *)__get_free_pages(__GFP_DMA,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_pages_perread));\r\nif (p_buff==NULL) {\r\nfree_pages((unsigned long)privptr->p_buff_ccw,\r\n(int)pages_to_order_of_mag(privptr->\r\np_buff_ccw_num));\r\np_buf=privptr->p_buff_write;\r\nwhile (p_buf!=NULL) {\r\nfree_pages(\r\n(unsigned long)p_buf->p_buffer,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_pages_perwrite));\r\np_buf=p_buf->next;\r\n}\r\np_buf=privptr->p_buff_read;\r\nwhile (p_buf!=NULL) {\r\nfree_pages(\r\n(unsigned long)p_buf->p_buffer,\r\n(int)pages_to_order_of_mag(\r\nprivptr->p_buff_pages_perread));\r\np_buf=p_buf->next;\r\n}\r\nprivptr->p_buff_ccw=NULL;\r\nprivptr->p_buff_write=NULL;\r\nreturn -ENOMEM;\r\n}\r\nmemset(p_buff, 0x00, privptr->p_env->read_size);\r\np_buf = p_free_chain;\r\nprivptr->p_buff_read = p_buf;\r\np_free_chain = p_buf->next;\r\nif (p_last_CCWB==NULL) {\r\np_buf->next=NULL;\r\nreal_TIC_address=0;\r\np_last_CCWB=p_buf;\r\n}\r\nelse {\r\np_buf->next=p_first_CCWB;\r\nreal_TIC_address=\r\n(addr_t)__pa(\r\n&p_first_CCWB -> read );\r\n}\r\np_first_CCWB=p_buf;\r\np_buf->p_buffer=(struct clawbuf *)p_buff;\r\np_buf-> read.cmd_code = CCW_CLAW_CMD_READ;\r\np_buf-> read.cda = (__u32)__pa(p_buff);\r\np_buf-> read.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_buf-> read.count = privptr->p_env->read_size;\r\np_buf-> read_h.cmd_code = CCW_CLAW_CMD_READHEADER;\r\np_buf-> read_h.cda =\r\n(__u32)__pa(&(p_buf->header));\r\np_buf-> read_h.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_buf-> read_h.count = sizeof(struct clawh);\r\np_buf-> signal.cmd_code = CCW_CLAW_CMD_SIGNAL_SMOD;\r\np_buf-> signal.cda =\r\n(__u32)__pa(&(pClawH->flag));\r\np_buf-> signal.flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\np_buf-> signal.count = 1;\r\np_buf-> r_TIC_1.cmd_code = CCW_CLAW_CMD_TIC;\r\np_buf-> r_TIC_1.cda = (__u32)real_TIC_address;\r\np_buf-> r_TIC_1.flags = 0;\r\np_buf-> r_TIC_1.count = 0;\r\np_buf-> r_read_FF.cmd_code = CCW_CLAW_CMD_READFF;\r\np_buf-> r_read_FF.cda =\r\n(__u32)__pa(&(pClawH->flag));\r\np_buf-> r_read_FF.flags =\r\nCCW_FLAG_SLI | CCW_FLAG_CC | CCW_FLAG_PCI;\r\np_buf-> r_read_FF.count = 1;\r\nmemcpy(&p_buf->r_TIC_2, &p_buf->r_TIC_1,\r\nsizeof(struct ccw1));\r\np_buf->header.length=0xffff;\r\np_buf->header.opcode=0xff;\r\np_buf->header.flag=CLAW_PENDING;\r\n}\r\n}\r\n}\r\nadd_claw_reads( dev ,p_first_CCWB , p_last_CCWB);\r\nprivptr->buffs_alloc = 1;\r\nreturn 0;\r\n}\r\nstatic void\r\nprobe_error( struct ccwgroup_device *cgdev)\r\n{\r\nstruct claw_privbk *privptr;\r\nCLAW_DBF_TEXT(4, trace, "proberr");\r\nprivptr = dev_get_drvdata(&cgdev->dev);\r\nif (privptr != NULL) {\r\ndev_set_drvdata(&cgdev->dev, NULL);\r\nkfree(privptr->p_env);\r\nkfree(privptr->p_mtc_envelope);\r\nkfree(privptr);\r\n}\r\n}\r\nstatic int\r\nclaw_process_control( struct net_device *dev, struct ccwbk * p_ccw)\r\n{\r\nstruct clawbuf *p_buf;\r\nstruct clawctl ctlbk;\r\nstruct clawctl *p_ctlbk;\r\nchar temp_host_name[8];\r\nchar temp_ws_name[8];\r\nstruct claw_privbk *privptr;\r\nstruct claw_env *p_env;\r\nstruct sysval *p_sysval;\r\nstruct conncmd *p_connect=NULL;\r\nint rc;\r\nstruct chbk *p_ch = NULL;\r\nstruct device *tdev;\r\nCLAW_DBF_TEXT(2, setup, "clw_cntl");\r\nudelay(1000);\r\nprivptr = dev->ml_priv;\r\np_env=privptr->p_env;\r\ntdev = &privptr->channel[READ_CHANNEL].cdev->dev;\r\nmemcpy( &temp_host_name, p_env->host_name, 8);\r\nmemcpy( &temp_ws_name, p_env->adapter_name , 8);\r\ndev_info(tdev, "%s: CLAW device %.8s: "\r\n"Received Control Packet\n",\r\ndev->name, temp_ws_name);\r\nif (privptr->release_pend==1) {\r\nreturn 0;\r\n}\r\np_buf=p_ccw->p_buffer;\r\np_ctlbk=&ctlbk;\r\nif (p_env->packing == DO_PACKED) {\r\nmemcpy(p_ctlbk, &p_buf->buffer[4], sizeof(struct clawctl));\r\n} else {\r\nmemcpy(p_ctlbk, p_buf, sizeof(struct clawctl));\r\n}\r\nswitch (p_ctlbk->command)\r\n{\r\ncase SYSTEM_VALIDATE_REQUEST:\r\nif (p_ctlbk->version != CLAW_VERSION_ID) {\r\nclaw_snd_sys_validate_rsp(dev, p_ctlbk,\r\nCLAW_RC_WRONG_VERSION);\r\ndev_warn(tdev, "The communication peer of %s"\r\n" uses an incorrect API version %d\n",\r\ndev->name, p_ctlbk->version);\r\n}\r\np_sysval = (struct sysval *)&(p_ctlbk->data);\r\ndev_info(tdev, "%s: Recv Sys Validate Request: "\r\n"Vers=%d,link_id=%d,Corr=%d,WS name=%.8s,"\r\n"Host name=%.8s\n",\r\ndev->name, p_ctlbk->version,\r\np_ctlbk->linkid,\r\np_ctlbk->correlator,\r\np_sysval->WS_name,\r\np_sysval->host_name);\r\nif (memcmp(temp_host_name, p_sysval->host_name, 8)) {\r\nclaw_snd_sys_validate_rsp(dev, p_ctlbk,\r\nCLAW_RC_NAME_MISMATCH);\r\nCLAW_DBF_TEXT(2, setup, "HSTBAD");\r\nCLAW_DBF_TEXT_(2, setup, "%s", p_sysval->host_name);\r\nCLAW_DBF_TEXT_(2, setup, "%s", temp_host_name);\r\ndev_warn(tdev,\r\n"Host name %s for %s does not match the"\r\n" remote adapter name %s\n",\r\np_sysval->host_name,\r\ndev->name,\r\ntemp_host_name);\r\n}\r\nif (memcmp(temp_ws_name, p_sysval->WS_name, 8)) {\r\nclaw_snd_sys_validate_rsp(dev, p_ctlbk,\r\nCLAW_RC_NAME_MISMATCH);\r\nCLAW_DBF_TEXT(2, setup, "WSNBAD");\r\nCLAW_DBF_TEXT_(2, setup, "%s", p_sysval->WS_name);\r\nCLAW_DBF_TEXT_(2, setup, "%s", temp_ws_name);\r\ndev_warn(tdev, "Adapter name %s for %s does not match"\r\n" the remote host name %s\n",\r\np_sysval->WS_name,\r\ndev->name,\r\ntemp_ws_name);\r\n}\r\nif ((p_sysval->write_frame_size < p_env->write_size) &&\r\n(p_env->packing == 0)) {\r\nclaw_snd_sys_validate_rsp(dev, p_ctlbk,\r\nCLAW_RC_HOST_RCV_TOO_SMALL);\r\ndev_warn(tdev,\r\n"The local write buffer is smaller than the"\r\n" remote read buffer\n");\r\nCLAW_DBF_TEXT(2, setup, "wrtszbad");\r\n}\r\nif ((p_sysval->read_frame_size < p_env->read_size) &&\r\n(p_env->packing == 0)) {\r\nclaw_snd_sys_validate_rsp(dev, p_ctlbk,\r\nCLAW_RC_HOST_RCV_TOO_SMALL);\r\ndev_warn(tdev,\r\n"The local read buffer is smaller than the"\r\n" remote write buffer\n");\r\nCLAW_DBF_TEXT(2, setup, "rdsizbad");\r\n}\r\nclaw_snd_sys_validate_rsp(dev, p_ctlbk, 0);\r\ndev_info(tdev,\r\n"CLAW device %.8s: System validate"\r\n" completed.\n", temp_ws_name);\r\ndev_info(tdev,\r\n"%s: sys Validate Rsize:%d Wsize:%d\n",\r\ndev->name, p_sysval->read_frame_size,\r\np_sysval->write_frame_size);\r\nprivptr->system_validate_comp = 1;\r\nif (strncmp(p_env->api_type, WS_APPL_NAME_PACKED, 6) == 0)\r\np_env->packing = PACKING_ASK;\r\nclaw_strt_conn_req(dev);\r\nbreak;\r\ncase SYSTEM_VALIDATE_RESPONSE:\r\np_sysval = (struct sysval *)&(p_ctlbk->data);\r\ndev_info(tdev,\r\n"Settings for %s validated (version=%d, "\r\n"remote device=%d, rc=%d, adapter name=%.8s, "\r\n"host name=%.8s)\n",\r\ndev->name,\r\np_ctlbk->version,\r\np_ctlbk->correlator,\r\np_ctlbk->rc,\r\np_sysval->WS_name,\r\np_sysval->host_name);\r\nswitch (p_ctlbk->rc) {\r\ncase 0:\r\ndev_info(tdev, "%s: CLAW device "\r\n"%.8s: System validate completed.\n",\r\ndev->name, temp_ws_name);\r\nif (privptr->system_validate_comp == 0)\r\nclaw_strt_conn_req(dev);\r\nprivptr->system_validate_comp = 1;\r\nbreak;\r\ncase CLAW_RC_NAME_MISMATCH:\r\ndev_warn(tdev, "Validating %s failed because of"\r\n" a host or adapter name mismatch\n",\r\ndev->name);\r\nbreak;\r\ncase CLAW_RC_WRONG_VERSION:\r\ndev_warn(tdev, "Validating %s failed because of a"\r\n" version conflict\n",\r\ndev->name);\r\nbreak;\r\ncase CLAW_RC_HOST_RCV_TOO_SMALL:\r\ndev_warn(tdev, "Validating %s failed because of a"\r\n" frame size conflict\n",\r\ndev->name);\r\nbreak;\r\ndefault:\r\ndev_warn(tdev, "The communication peer of %s rejected"\r\n" the connection\n",\r\ndev->name);\r\nbreak;\r\n}\r\nbreak;\r\ncase CONNECTION_REQUEST:\r\np_connect = (struct conncmd *)&(p_ctlbk->data);\r\ndev_info(tdev, "%s: Recv Conn Req: Vers=%d,link_id=%d,"\r\n"Corr=%d,HOST appl=%.8s,WS appl=%.8s\n",\r\ndev->name,\r\np_ctlbk->version,\r\np_ctlbk->linkid,\r\np_ctlbk->correlator,\r\np_connect->host_name,\r\np_connect->WS_name);\r\nif (privptr->active_link_ID != 0) {\r\nclaw_snd_disc(dev, p_ctlbk);\r\ndev_info(tdev, "%s rejected a connection request"\r\n" because it is already active\n",\r\ndev->name);\r\n}\r\nif (p_ctlbk->linkid != 1) {\r\nclaw_snd_disc(dev, p_ctlbk);\r\ndev_info(tdev, "%s rejected a request to open multiple"\r\n" connections\n",\r\ndev->name);\r\n}\r\nrc = find_link(dev, p_connect->host_name, p_connect->WS_name);\r\nif (rc != 0) {\r\nclaw_snd_disc(dev, p_ctlbk);\r\ndev_info(tdev, "%s rejected a connection request"\r\n" because of a type mismatch\n",\r\ndev->name);\r\n}\r\nclaw_send_control(dev,\r\nCONNECTION_CONFIRM, p_ctlbk->linkid,\r\np_ctlbk->correlator,\r\n0, p_connect->host_name,\r\np_connect->WS_name);\r\nif (p_env->packing == PACKING_ASK) {\r\np_env->packing = PACK_SEND;\r\nclaw_snd_conn_req(dev, 0);\r\n}\r\ndev_info(tdev, "%s: CLAW device %.8s: Connection "\r\n"completed link_id=%d.\n",\r\ndev->name, temp_ws_name,\r\np_ctlbk->linkid);\r\nprivptr->active_link_ID = p_ctlbk->linkid;\r\np_ch = &privptr->channel[WRITE_CHANNEL];\r\nwake_up(&p_ch->wait);\r\nbreak;\r\ncase CONNECTION_RESPONSE:\r\np_connect = (struct conncmd *)&(p_ctlbk->data);\r\ndev_info(tdev, "%s: Recv Conn Resp: Vers=%d,link_id=%d,"\r\n"Corr=%d,RC=%d,Host appl=%.8s, WS appl=%.8s\n",\r\ndev->name,\r\np_ctlbk->version,\r\np_ctlbk->linkid,\r\np_ctlbk->correlator,\r\np_ctlbk->rc,\r\np_connect->host_name,\r\np_connect->WS_name);\r\nif (p_ctlbk->rc != 0) {\r\ndev_warn(tdev, "The communication peer of %s rejected"\r\n" a connection request\n",\r\ndev->name);\r\nreturn 1;\r\n}\r\nrc = find_link(dev,\r\np_connect->host_name, p_connect->WS_name);\r\nif (rc != 0) {\r\nclaw_snd_disc(dev, p_ctlbk);\r\ndev_warn(tdev, "The communication peer of %s"\r\n" rejected a connection "\r\n"request because of a type mismatch\n",\r\ndev->name);\r\n}\r\nprivptr->active_link_ID = -(p_ctlbk->linkid);\r\nbreak;\r\ncase CONNECTION_CONFIRM:\r\np_connect = (struct conncmd *)&(p_ctlbk->data);\r\ndev_info(tdev,\r\n"%s: Recv Conn Confirm:Vers=%d,link_id=%d,"\r\n"Corr=%d,Host appl=%.8s,WS appl=%.8s\n",\r\ndev->name,\r\np_ctlbk->version,\r\np_ctlbk->linkid,\r\np_ctlbk->correlator,\r\np_connect->host_name,\r\np_connect->WS_name);\r\nif (p_ctlbk->linkid == -(privptr->active_link_ID)) {\r\nprivptr->active_link_ID = p_ctlbk->linkid;\r\nif (p_env->packing > PACKING_ASK) {\r\ndev_info(tdev,\r\n"%s: Confirmed Now packing\n", dev->name);\r\np_env->packing = DO_PACKED;\r\n}\r\np_ch = &privptr->channel[WRITE_CHANNEL];\r\nwake_up(&p_ch->wait);\r\n} else {\r\ndev_warn(tdev, "Activating %s failed because of"\r\n" an incorrect link ID=%d\n",\r\ndev->name, p_ctlbk->linkid);\r\nclaw_snd_disc(dev, p_ctlbk);\r\n}\r\nbreak;\r\ncase DISCONNECT:\r\ndev_info(tdev, "%s: Disconnect: "\r\n"Vers=%d,link_id=%d,Corr=%d\n",\r\ndev->name, p_ctlbk->version,\r\np_ctlbk->linkid, p_ctlbk->correlator);\r\nif ((p_ctlbk->linkid == 2) &&\r\n(p_env->packing == PACK_SEND)) {\r\nprivptr->active_link_ID = 1;\r\np_env->packing = DO_PACKED;\r\n} else\r\nprivptr->active_link_ID = 0;\r\nbreak;\r\ncase CLAW_ERROR:\r\ndev_warn(tdev, "The communication peer of %s failed\n",\r\ndev->name);\r\nbreak;\r\ndefault:\r\ndev_warn(tdev, "The communication peer of %s sent"\r\n" an unknown command code\n",\r\ndev->name);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nclaw_send_control(struct net_device *dev, __u8 type, __u8 link,\r\n__u8 correlator, __u8 rc, char *local_name, char *remote_name)\r\n{\r\nstruct claw_privbk *privptr;\r\nstruct clawctl *p_ctl;\r\nstruct sysval *p_sysval;\r\nstruct conncmd *p_connect;\r\nstruct sk_buff *skb;\r\nCLAW_DBF_TEXT(2, setup, "sndcntl");\r\nprivptr = dev->ml_priv;\r\np_ctl=(struct clawctl *)&privptr->ctl_bk;\r\np_ctl->command=type;\r\np_ctl->version=CLAW_VERSION_ID;\r\np_ctl->linkid=link;\r\np_ctl->correlator=correlator;\r\np_ctl->rc=rc;\r\np_sysval=(struct sysval *)&p_ctl->data;\r\np_connect=(struct conncmd *)&p_ctl->data;\r\nswitch (p_ctl->command) {\r\ncase SYSTEM_VALIDATE_REQUEST:\r\ncase SYSTEM_VALIDATE_RESPONSE:\r\nmemcpy(&p_sysval->host_name, local_name, 8);\r\nmemcpy(&p_sysval->WS_name, remote_name, 8);\r\nif (privptr->p_env->packing > 0) {\r\np_sysval->read_frame_size = DEF_PACK_BUFSIZE;\r\np_sysval->write_frame_size = DEF_PACK_BUFSIZE;\r\n} else {\r\np_sysval->read_frame_size =\r\nprivptr->p_env->read_size;\r\np_sysval->write_frame_size =\r\nprivptr->p_env->write_size;\r\n}\r\nmemset(&p_sysval->reserved, 0x00, 4);\r\nbreak;\r\ncase CONNECTION_REQUEST:\r\ncase CONNECTION_RESPONSE:\r\ncase CONNECTION_CONFIRM:\r\ncase DISCONNECT:\r\nmemcpy(&p_sysval->host_name, local_name, 8);\r\nmemcpy(&p_sysval->WS_name, remote_name, 8);\r\nif (privptr->p_env->packing > 0) {\r\np_connect->reserved1[0]=CLAW_FRAME_SIZE;\r\np_connect->reserved1[1]=CLAW_FRAME_SIZE;\r\n} else {\r\nmemset(&p_connect->reserved1, 0x00, 4);\r\nmemset(&p_connect->reserved2, 0x00, 4);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nskb = dev_alloc_skb(sizeof(struct clawctl));\r\nif (!skb) {\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(skb_put(skb, sizeof(struct clawctl)),\r\np_ctl, sizeof(struct clawctl));\r\nif (privptr->p_env->packing >= PACK_SEND)\r\nclaw_hw_tx(skb, dev, 1);\r\nelse\r\nclaw_hw_tx(skb, dev, 0);\r\nreturn 0;\r\n}\r\nstatic int\r\nclaw_snd_conn_req(struct net_device *dev, __u8 link)\r\n{\r\nint rc;\r\nstruct claw_privbk *privptr = dev->ml_priv;\r\nstruct clawctl *p_ctl;\r\nCLAW_DBF_TEXT(2, setup, "snd_conn");\r\nrc = 1;\r\np_ctl=(struct clawctl *)&privptr->ctl_bk;\r\np_ctl->linkid = link;\r\nif ( privptr->system_validate_comp==0x00 ) {\r\nreturn rc;\r\n}\r\nif (privptr->p_env->packing == PACKING_ASK )\r\nrc=claw_send_control(dev, CONNECTION_REQUEST,0,0,0,\r\nWS_APPL_NAME_PACKED, WS_APPL_NAME_PACKED);\r\nif (privptr->p_env->packing == PACK_SEND) {\r\nrc=claw_send_control(dev, CONNECTION_REQUEST,0,0,0,\r\nWS_APPL_NAME_IP_NAME, WS_APPL_NAME_IP_NAME);\r\n}\r\nif (privptr->p_env->packing == 0)\r\nrc=claw_send_control(dev, CONNECTION_REQUEST,0,0,0,\r\nHOST_APPL_NAME, privptr->p_env->api_type);\r\nreturn rc;\r\n}\r\nstatic int\r\nclaw_snd_disc(struct net_device *dev, struct clawctl * p_ctl)\r\n{\r\nint rc;\r\nstruct conncmd * p_connect;\r\nCLAW_DBF_TEXT(2, setup, "snd_dsc");\r\np_connect=(struct conncmd *)&p_ctl->data;\r\nrc=claw_send_control(dev, DISCONNECT, p_ctl->linkid,\r\np_ctl->correlator, 0,\r\np_connect->host_name, p_connect->WS_name);\r\nreturn rc;\r\n}\r\nstatic int\r\nclaw_snd_sys_validate_rsp(struct net_device *dev,\r\nstruct clawctl *p_ctl, __u32 return_code)\r\n{\r\nstruct claw_env * p_env;\r\nstruct claw_privbk *privptr;\r\nint rc;\r\nCLAW_DBF_TEXT(2, setup, "chkresp");\r\nprivptr = dev->ml_priv;\r\np_env=privptr->p_env;\r\nrc=claw_send_control(dev, SYSTEM_VALIDATE_RESPONSE,\r\np_ctl->linkid,\r\np_ctl->correlator,\r\nreturn_code,\r\np_env->host_name,\r\np_env->adapter_name );\r\nreturn rc;\r\n}\r\nstatic int\r\nclaw_strt_conn_req(struct net_device *dev )\r\n{\r\nint rc;\r\nCLAW_DBF_TEXT(2, setup, "conn_req");\r\nrc=claw_snd_conn_req(dev, 1);\r\nreturn rc;\r\n}\r\nstatic struct\r\nnet_device_stats *claw_stats(struct net_device *dev)\r\n{\r\nstruct claw_privbk *privptr;\r\nCLAW_DBF_TEXT(4, trace, "stats");\r\nprivptr = dev->ml_priv;\r\nreturn &privptr->stats;\r\n}\r\nstatic void\r\nunpack_read(struct net_device *dev )\r\n{\r\nstruct sk_buff *skb;\r\nstruct claw_privbk *privptr;\r\nstruct claw_env *p_env;\r\nstruct ccwbk *p_this_ccw;\r\nstruct ccwbk *p_first_ccw;\r\nstruct ccwbk *p_last_ccw;\r\nstruct clawph *p_packh;\r\nvoid *p_packd;\r\nstruct clawctl *p_ctlrec=NULL;\r\nstruct device *p_dev;\r\n__u32 len_of_data;\r\n__u32 pack_off;\r\n__u8 link_num;\r\n__u8 mtc_this_frm=0;\r\n__u32 bytes_to_mov;\r\nint i=0;\r\nint p=0;\r\nCLAW_DBF_TEXT(4, trace, "unpkread");\r\np_first_ccw=NULL;\r\np_last_ccw=NULL;\r\np_packh=NULL;\r\np_packd=NULL;\r\nprivptr = dev->ml_priv;\r\np_dev = &privptr->channel[READ_CHANNEL].cdev->dev;\r\np_env = privptr->p_env;\r\np_this_ccw=privptr->p_read_active_first;\r\nwhile (p_this_ccw!=NULL && p_this_ccw->header.flag!=CLAW_PENDING) {\r\npack_off = 0;\r\np = 0;\r\np_this_ccw->header.flag=CLAW_PENDING;\r\nprivptr->p_read_active_first=p_this_ccw->next;\r\np_this_ccw->next=NULL;\r\np_packh = (struct clawph *)p_this_ccw->p_buffer;\r\nif ((p_env->packing == PACK_SEND) &&\r\n(p_packh->len == 32) &&\r\n(p_packh->link_num == 0)) {\r\np_packh++;\r\np_ctlrec = (struct clawctl *)p_packh;\r\np_packh--;\r\nif ((p_ctlrec->command == CONNECTION_RESPONSE) ||\r\n(p_ctlrec->command == CONNECTION_CONFIRM))\r\np_env->packing = DO_PACKED;\r\n}\r\nif (p_env->packing == DO_PACKED)\r\nlink_num=p_packh->link_num;\r\nelse\r\nlink_num=p_this_ccw->header.opcode / 8;\r\nif ((p_this_ccw->header.opcode & MORE_to_COME_FLAG)!=0) {\r\nmtc_this_frm=1;\r\nif (p_this_ccw->header.length!=\r\nprivptr->p_env->read_size ) {\r\ndev_warn(p_dev,\r\n"The communication peer of %s"\r\n" sent a faulty"\r\n" frame of length %02x\n",\r\ndev->name, p_this_ccw->header.length);\r\n}\r\n}\r\nif (privptr->mtc_skipping) {\r\nif (mtc_this_frm==0) {\r\nprivptr->mtc_skipping=0;\r\nprivptr->mtc_logical_link=-1;\r\n}\r\ngoto NextFrame;\r\n}\r\nif (link_num==0) {\r\nclaw_process_control(dev, p_this_ccw);\r\nCLAW_DBF_TEXT(4, trace, "UnpkCntl");\r\ngoto NextFrame;\r\n}\r\nunpack_next:\r\nif (p_env->packing == DO_PACKED) {\r\nif (pack_off > p_env->read_size)\r\ngoto NextFrame;\r\np_packd = p_this_ccw->p_buffer+pack_off;\r\np_packh = (struct clawph *) p_packd;\r\nif ((p_packh->len == 0) ||\r\n(p_packh->flag != 0))\r\ngoto NextFrame;\r\nbytes_to_mov = p_packh->len;\r\npack_off += bytes_to_mov+sizeof(struct clawph);\r\np++;\r\n} else {\r\nbytes_to_mov=p_this_ccw->header.length;\r\n}\r\nif (privptr->mtc_logical_link<0) {\r\nprivptr->mtc_offset=0;\r\nprivptr->mtc_logical_link=link_num;\r\n}\r\nif (bytes_to_mov > (MAX_ENVELOPE_SIZE- privptr->mtc_offset) ) {\r\nprivptr->stats.rx_frame_errors++;\r\ngoto NextFrame;\r\n}\r\nif (p_env->packing == DO_PACKED) {\r\nmemcpy( privptr->p_mtc_envelope+ privptr->mtc_offset,\r\np_packd+sizeof(struct clawph), bytes_to_mov);\r\n} else {\r\nmemcpy( privptr->p_mtc_envelope+ privptr->mtc_offset,\r\np_this_ccw->p_buffer, bytes_to_mov);\r\n}\r\nif (mtc_this_frm==0) {\r\nlen_of_data=privptr->mtc_offset+bytes_to_mov;\r\nskb=dev_alloc_skb(len_of_data);\r\nif (skb) {\r\nmemcpy(skb_put(skb,len_of_data),\r\nprivptr->p_mtc_envelope,\r\nlen_of_data);\r\nskb->dev=dev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol=htons(ETH_P_IP);\r\nskb->ip_summed=CHECKSUM_UNNECESSARY;\r\nprivptr->stats.rx_packets++;\r\nprivptr->stats.rx_bytes+=len_of_data;\r\nnetif_rx(skb);\r\n}\r\nelse {\r\ndev_info(p_dev, "Allocating a buffer for"\r\n" incoming data failed\n");\r\nprivptr->stats.rx_dropped++;\r\n}\r\nprivptr->mtc_offset=0;\r\nprivptr->mtc_logical_link=-1;\r\n}\r\nelse {\r\nprivptr->mtc_offset+=bytes_to_mov;\r\n}\r\nif (p_env->packing == DO_PACKED)\r\ngoto unpack_next;\r\nNextFrame:\r\ni++;\r\np_this_ccw->header.length=0xffff;\r\np_this_ccw->header.opcode=0xff;\r\nif (p_first_ccw==NULL) {\r\np_first_ccw = p_this_ccw;\r\n}\r\nelse {\r\np_last_ccw->next = p_this_ccw;\r\n}\r\np_last_ccw = p_this_ccw;\r\np_this_ccw = privptr->p_read_active_first;\r\nCLAW_DBF_TEXT_(4, trace, "rxpkt %d", p);\r\n}\r\nCLAW_DBF_TEXT_(4, trace, "rxfrm %d", i);\r\nadd_claw_reads(dev, p_first_ccw, p_last_ccw);\r\nclaw_strt_read(dev, LOCK_YES);\r\nreturn;\r\n}\r\nstatic void\r\nclaw_strt_read (struct net_device *dev, int lock )\r\n{\r\nint rc = 0;\r\n__u32 parm;\r\nunsigned long saveflags = 0;\r\nstruct claw_privbk *privptr = dev->ml_priv;\r\nstruct ccwbk*p_ccwbk;\r\nstruct chbk *p_ch;\r\nstruct clawh *p_clawh;\r\np_ch = &privptr->channel[READ_CHANNEL];\r\nCLAW_DBF_TEXT(4, trace, "StRdNter");\r\np_clawh=(struct clawh *)privptr->p_claw_signal_blk;\r\np_clawh->flag=CLAW_IDLE;\r\nif ((privptr->p_write_active_first!=NULL &&\r\nprivptr->p_write_active_first->header.flag!=CLAW_PENDING) ||\r\n(privptr->p_read_active_first!=NULL &&\r\nprivptr->p_read_active_first->header.flag!=CLAW_PENDING )) {\r\np_clawh->flag=CLAW_BUSY;\r\n}\r\nif (lock==LOCK_YES) {\r\nspin_lock_irqsave(get_ccwdev_lock(p_ch->cdev), saveflags);\r\n}\r\nif (test_and_set_bit(0, (void *)&p_ch->IO_active) == 0) {\r\nCLAW_DBF_TEXT(4, trace, "HotRead");\r\np_ccwbk=privptr->p_read_active_first;\r\nparm = (unsigned long) p_ch;\r\nrc = ccw_device_start (p_ch->cdev, &p_ccwbk->read, parm,\r\n0xff, 0);\r\nif (rc != 0) {\r\nccw_check_return_code(p_ch->cdev, rc);\r\n}\r\n}\r\nelse {\r\nCLAW_DBF_TEXT(2, trace, "ReadAct");\r\n}\r\nif (lock==LOCK_YES) {\r\nspin_unlock_irqrestore(get_ccwdev_lock(p_ch->cdev), saveflags);\r\n}\r\nCLAW_DBF_TEXT(4, trace, "StRdExit");\r\nreturn;\r\n}\r\nstatic void\r\nclaw_strt_out_IO( struct net_device *dev )\r\n{\r\nint rc = 0;\r\nunsigned long parm;\r\nstruct claw_privbk *privptr;\r\nstruct chbk *p_ch;\r\nstruct ccwbk *p_first_ccw;\r\nif (!dev) {\r\nreturn;\r\n}\r\nprivptr = (struct claw_privbk *)dev->ml_priv;\r\np_ch = &privptr->channel[WRITE_CHANNEL];\r\nCLAW_DBF_TEXT(4, trace, "strt_io");\r\np_first_ccw=privptr->p_write_active_first;\r\nif (p_ch->claw_state == CLAW_STOP)\r\nreturn;\r\nif (p_first_ccw == NULL) {\r\nreturn;\r\n}\r\nif (test_and_set_bit(0, (void *)&p_ch->IO_active) == 0) {\r\nparm = (unsigned long) p_ch;\r\nCLAW_DBF_TEXT(2, trace, "StWrtIO");\r\nrc = ccw_device_start(p_ch->cdev, &p_first_ccw->write, parm,\r\n0xff, 0);\r\nif (rc != 0) {\r\nccw_check_return_code(p_ch->cdev, rc);\r\n}\r\n}\r\ndev->trans_start = jiffies;\r\nreturn;\r\n}\r\nstatic void\r\nclaw_free_wrt_buf( struct net_device *dev )\r\n{\r\nstruct claw_privbk *privptr = (struct claw_privbk *)dev->ml_priv;\r\nstruct ccwbk*p_this_ccw;\r\nstruct ccwbk*p_next_ccw;\r\nCLAW_DBF_TEXT(4, trace, "freewrtb");\r\np_this_ccw=privptr->p_write_active_first;\r\nwhile ( (p_this_ccw!=NULL) && (p_this_ccw->header.flag!=CLAW_PENDING))\r\n{\r\np_next_ccw = p_this_ccw->next;\r\nif (((p_next_ccw!=NULL) &&\r\n(p_next_ccw->header.flag!=CLAW_PENDING)) ||\r\n((p_this_ccw == privptr->p_write_active_last) &&\r\n(p_this_ccw->header.flag!=CLAW_PENDING))) {\r\nprivptr->p_write_active_first=p_this_ccw->next;\r\np_this_ccw->header.flag=CLAW_PENDING;\r\np_this_ccw->next=privptr->p_write_free_chain;\r\nprivptr->p_write_free_chain=p_this_ccw;\r\n++privptr->write_free_count;\r\nprivptr->stats.tx_bytes+= p_this_ccw->write.count;\r\np_this_ccw=privptr->p_write_active_first;\r\nprivptr->stats.tx_packets++;\r\n}\r\nelse {\r\nbreak;\r\n}\r\n}\r\nif (privptr->write_free_count!=0) {\r\nclaw_clearbit_busy(TB_NOBUFFER,dev);\r\n}\r\nif (privptr->p_write_active_first==NULL) {\r\nprivptr->p_write_active_last=NULL;\r\n}\r\nCLAW_DBF_TEXT_(4, trace, "FWC=%d", privptr->write_free_count);\r\nreturn;\r\n}\r\nstatic void\r\nclaw_free_netdevice(struct net_device * dev, int free_dev)\r\n{\r\nstruct claw_privbk *privptr;\r\nCLAW_DBF_TEXT(2, setup, "free_dev");\r\nif (!dev)\r\nreturn;\r\nCLAW_DBF_TEXT_(2, setup, "%s", dev->name);\r\nprivptr = dev->ml_priv;\r\nif (dev->flags & IFF_RUNNING)\r\nclaw_release(dev);\r\nif (privptr) {\r\nprivptr->channel[READ_CHANNEL].ndev = NULL;\r\n}\r\ndev->ml_priv = NULL;\r\n#ifdef MODULE\r\nif (free_dev) {\r\nfree_netdev(dev);\r\n}\r\n#endif\r\nCLAW_DBF_TEXT(2, setup, "free_ok");\r\n}\r\nstatic void\r\nclaw_init_netdevice(struct net_device * dev)\r\n{\r\nCLAW_DBF_TEXT(2, setup, "init_dev");\r\nCLAW_DBF_TEXT_(2, setup, "%s", dev->name);\r\ndev->mtu = CLAW_DEFAULT_MTU_SIZE;\r\ndev->hard_header_len = 0;\r\ndev->addr_len = 0;\r\ndev->type = ARPHRD_SLIP;\r\ndev->tx_queue_len = 1300;\r\ndev->flags = IFF_POINTOPOINT | IFF_NOARP;\r\ndev->netdev_ops = &claw_netdev_ops;\r\nCLAW_DBF_TEXT(2, setup, "initok");\r\nreturn;\r\n}\r\nstatic int\r\nadd_channel(struct ccw_device *cdev,int i,struct claw_privbk *privptr)\r\n{\r\nstruct chbk *p_ch;\r\nstruct ccw_dev_id dev_id;\r\nCLAW_DBF_TEXT_(2, setup, "%s", dev_name(&cdev->dev));\r\nprivptr->channel[i].flag = i+1;\r\np_ch = &privptr->channel[i];\r\np_ch->cdev = cdev;\r\nsnprintf(p_ch->id, CLAW_ID_SIZE, "cl-%s", dev_name(&cdev->dev));\r\nccw_device_get_id(cdev, &dev_id);\r\np_ch->devno = dev_id.devno;\r\nif ((p_ch->irb = kzalloc(sizeof (struct irb),GFP_KERNEL)) == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nclaw_new_device(struct ccwgroup_device *cgdev)\r\n{\r\nstruct claw_privbk *privptr;\r\nstruct claw_env *p_env;\r\nstruct net_device *dev;\r\nint ret;\r\nstruct ccw_dev_id dev_id;\r\ndev_info(&cgdev->dev, "add for %s\n",\r\ndev_name(&cgdev->cdev[READ_CHANNEL]->dev));\r\nCLAW_DBF_TEXT(2, setup, "new_dev");\r\nprivptr = dev_get_drvdata(&cgdev->dev);\r\ndev_set_drvdata(&cgdev->cdev[READ_CHANNEL]->dev, privptr);\r\ndev_set_drvdata(&cgdev->cdev[WRITE_CHANNEL]->dev, privptr);\r\nif (!privptr)\r\nreturn -ENODEV;\r\np_env = privptr->p_env;\r\nccw_device_get_id(cgdev->cdev[READ_CHANNEL], &dev_id);\r\np_env->devno[READ_CHANNEL] = dev_id.devno;\r\nccw_device_get_id(cgdev->cdev[WRITE_CHANNEL], &dev_id);\r\np_env->devno[WRITE_CHANNEL] = dev_id.devno;\r\nret = add_channel(cgdev->cdev[0],0,privptr);\r\nif (ret == 0)\r\nret = add_channel(cgdev->cdev[1],1,privptr);\r\nif (ret != 0) {\r\ndev_warn(&cgdev->dev, "Creating a CLAW group device"\r\n" failed with error code %d\n", ret);\r\ngoto out;\r\n}\r\nret = ccw_device_set_online(cgdev->cdev[READ_CHANNEL]);\r\nif (ret != 0) {\r\ndev_warn(&cgdev->dev,\r\n"Setting the read subchannel online"\r\n" failed with error code %d\n", ret);\r\ngoto out;\r\n}\r\nret = ccw_device_set_online(cgdev->cdev[WRITE_CHANNEL]);\r\nif (ret != 0) {\r\ndev_warn(&cgdev->dev,\r\n"Setting the write subchannel online "\r\n"failed with error code %d\n", ret);\r\ngoto out;\r\n}\r\ndev = alloc_netdev(0,"claw%d",claw_init_netdevice);\r\nif (!dev) {\r\ndev_warn(&cgdev->dev,\r\n"Activating the CLAW device failed\n");\r\ngoto out;\r\n}\r\ndev->ml_priv = privptr;\r\ndev_set_drvdata(&cgdev->dev, privptr);\r\ndev_set_drvdata(&cgdev->cdev[READ_CHANNEL]->dev, privptr);\r\ndev_set_drvdata(&cgdev->cdev[WRITE_CHANNEL]->dev, privptr);\r\nSET_NETDEV_DEV(dev, &cgdev->dev);\r\nif (register_netdev(dev) != 0) {\r\nclaw_free_netdevice(dev, 1);\r\nCLAW_DBF_TEXT(2, trace, "regfail");\r\ngoto out;\r\n}\r\ndev->flags &=~IFF_RUNNING;\r\nif (privptr->buffs_alloc == 0) {\r\nret=init_ccw_bk(dev);\r\nif (ret !=0) {\r\nunregister_netdev(dev);\r\nclaw_free_netdevice(dev,1);\r\nCLAW_DBF_TEXT(2, trace, "ccwmem");\r\ngoto out;\r\n}\r\n}\r\nprivptr->channel[READ_CHANNEL].ndev = dev;\r\nprivptr->channel[WRITE_CHANNEL].ndev = dev;\r\nprivptr->p_env->ndev = dev;\r\ndev_info(&cgdev->dev, "%s:readsize=%d writesize=%d "\r\n"readbuffer=%d writebuffer=%d read=0x%04x write=0x%04x\n",\r\ndev->name, p_env->read_size,\r\np_env->write_size, p_env->read_buffers,\r\np_env->write_buffers, p_env->devno[READ_CHANNEL],\r\np_env->devno[WRITE_CHANNEL]);\r\ndev_info(&cgdev->dev, "%s:host_name:%.8s, adapter_name "\r\n":%.8s api_type: %.8s\n",\r\ndev->name, p_env->host_name,\r\np_env->adapter_name , p_env->api_type);\r\nreturn 0;\r\nout:\r\nccw_device_set_offline(cgdev->cdev[1]);\r\nccw_device_set_offline(cgdev->cdev[0]);\r\nreturn -ENODEV;\r\n}\r\nstatic void\r\nclaw_purge_skb_queue(struct sk_buff_head *q)\r\n{\r\nstruct sk_buff *skb;\r\nCLAW_DBF_TEXT(4, trace, "purgque");\r\nwhile ((skb = skb_dequeue(q))) {\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\nstatic int\r\nclaw_shutdown_device(struct ccwgroup_device *cgdev)\r\n{\r\nstruct claw_privbk *priv;\r\nstruct net_device *ndev;\r\nint ret = 0;\r\nCLAW_DBF_TEXT_(2, setup, "%s", dev_name(&cgdev->dev));\r\npriv = dev_get_drvdata(&cgdev->dev);\r\nif (!priv)\r\nreturn -ENODEV;\r\nndev = priv->channel[READ_CHANNEL].ndev;\r\nif (ndev) {\r\ndev_info(&cgdev->dev, "%s: shutting down\n",\r\nndev->name);\r\nif (ndev->flags & IFF_RUNNING)\r\nret = claw_release(ndev);\r\nndev->flags &=~IFF_RUNNING;\r\nunregister_netdev(ndev);\r\nndev->ml_priv = NULL;\r\nclaw_free_netdevice(ndev, 1);\r\npriv->channel[READ_CHANNEL].ndev = NULL;\r\npriv->channel[WRITE_CHANNEL].ndev = NULL;\r\npriv->p_env->ndev = NULL;\r\n}\r\nccw_device_set_offline(cgdev->cdev[1]);\r\nccw_device_set_offline(cgdev->cdev[0]);\r\nreturn ret;\r\n}\r\nstatic void\r\nclaw_remove_device(struct ccwgroup_device *cgdev)\r\n{\r\nstruct claw_privbk *priv;\r\nBUG_ON(!cgdev);\r\nCLAW_DBF_TEXT_(2, setup, "%s", dev_name(&cgdev->dev));\r\npriv = dev_get_drvdata(&cgdev->dev);\r\nBUG_ON(!priv);\r\ndev_info(&cgdev->dev, " will be removed.\n");\r\nif (cgdev->state == CCWGROUP_ONLINE)\r\nclaw_shutdown_device(cgdev);\r\nkfree(priv->p_mtc_envelope);\r\npriv->p_mtc_envelope=NULL;\r\nkfree(priv->p_env);\r\npriv->p_env=NULL;\r\nkfree(priv->channel[0].irb);\r\npriv->channel[0].irb=NULL;\r\nkfree(priv->channel[1].irb);\r\npriv->channel[1].irb=NULL;\r\nkfree(priv);\r\ndev_set_drvdata(&cgdev->dev, NULL);\r\ndev_set_drvdata(&cgdev->cdev[READ_CHANNEL]->dev, NULL);\r\ndev_set_drvdata(&cgdev->cdev[WRITE_CHANNEL]->dev, NULL);\r\nput_device(&cgdev->dev);\r\nreturn;\r\n}\r\nstatic ssize_t\r\nclaw_hname_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct claw_privbk *priv;\r\nstruct claw_env * p_env;\r\npriv = dev_get_drvdata(dev);\r\nif (!priv)\r\nreturn -ENODEV;\r\np_env = priv->p_env;\r\nreturn sprintf(buf, "%s\n",p_env->host_name);\r\n}\r\nstatic ssize_t\r\nclaw_hname_write(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct claw_privbk *priv;\r\nstruct claw_env * p_env;\r\npriv = dev_get_drvdata(dev);\r\nif (!priv)\r\nreturn -ENODEV;\r\np_env = priv->p_env;\r\nif (count > MAX_NAME_LEN+1)\r\nreturn -EINVAL;\r\nmemset(p_env->host_name, 0x20, MAX_NAME_LEN);\r\nstrncpy(p_env->host_name,buf, count);\r\np_env->host_name[count-1] = 0x20;\r\np_env->host_name[MAX_NAME_LEN] = 0x00;\r\nCLAW_DBF_TEXT(2, setup, "HstnSet");\r\nCLAW_DBF_TEXT_(2, setup, "%s", p_env->host_name);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nclaw_adname_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct claw_privbk *priv;\r\nstruct claw_env * p_env;\r\npriv = dev_get_drvdata(dev);\r\nif (!priv)\r\nreturn -ENODEV;\r\np_env = priv->p_env;\r\nreturn sprintf(buf, "%s\n", p_env->adapter_name);\r\n}\r\nstatic ssize_t\r\nclaw_adname_write(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct claw_privbk *priv;\r\nstruct claw_env * p_env;\r\npriv = dev_get_drvdata(dev);\r\nif (!priv)\r\nreturn -ENODEV;\r\np_env = priv->p_env;\r\nif (count > MAX_NAME_LEN+1)\r\nreturn -EINVAL;\r\nmemset(p_env->adapter_name, 0x20, MAX_NAME_LEN);\r\nstrncpy(p_env->adapter_name,buf, count);\r\np_env->adapter_name[count-1] = 0x20;\r\np_env->adapter_name[MAX_NAME_LEN] = 0x00;\r\nCLAW_DBF_TEXT(2, setup, "AdnSet");\r\nCLAW_DBF_TEXT_(2, setup, "%s", p_env->adapter_name);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nclaw_apname_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct claw_privbk *priv;\r\nstruct claw_env * p_env;\r\npriv = dev_get_drvdata(dev);\r\nif (!priv)\r\nreturn -ENODEV;\r\np_env = priv->p_env;\r\nreturn sprintf(buf, "%s\n",\r\np_env->api_type);\r\n}\r\nstatic ssize_t\r\nclaw_apname_write(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct claw_privbk *priv;\r\nstruct claw_env * p_env;\r\npriv = dev_get_drvdata(dev);\r\nif (!priv)\r\nreturn -ENODEV;\r\np_env = priv->p_env;\r\nif (count > MAX_NAME_LEN+1)\r\nreturn -EINVAL;\r\nmemset(p_env->api_type, 0x20, MAX_NAME_LEN);\r\nstrncpy(p_env->api_type,buf, count);\r\np_env->api_type[count-1] = 0x20;\r\np_env->api_type[MAX_NAME_LEN] = 0x00;\r\nif(strncmp(p_env->api_type,WS_APPL_NAME_PACKED,6) == 0) {\r\np_env->read_size=DEF_PACK_BUFSIZE;\r\np_env->write_size=DEF_PACK_BUFSIZE;\r\np_env->packing=PACKING_ASK;\r\nCLAW_DBF_TEXT(2, setup, "PACKING");\r\n}\r\nelse {\r\np_env->packing=0;\r\np_env->read_size=CLAW_FRAME_SIZE;\r\np_env->write_size=CLAW_FRAME_SIZE;\r\nCLAW_DBF_TEXT(2, setup, "ApiSet");\r\n}\r\nCLAW_DBF_TEXT_(2, setup, "%s", p_env->api_type);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nclaw_wbuff_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct claw_privbk *priv;\r\nstruct claw_env * p_env;\r\npriv = dev_get_drvdata(dev);\r\nif (!priv)\r\nreturn -ENODEV;\r\np_env = priv->p_env;\r\nreturn sprintf(buf, "%d\n", p_env->write_buffers);\r\n}\r\nstatic ssize_t\r\nclaw_wbuff_write(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct claw_privbk *priv;\r\nstruct claw_env * p_env;\r\nint nnn,max;\r\npriv = dev_get_drvdata(dev);\r\nif (!priv)\r\nreturn -ENODEV;\r\np_env = priv->p_env;\r\nsscanf(buf, "%i", &nnn);\r\nif (p_env->packing) {\r\nmax = 64;\r\n}\r\nelse {\r\nmax = 512;\r\n}\r\nif ((nnn > max ) || (nnn < 2))\r\nreturn -EINVAL;\r\np_env->write_buffers = nnn;\r\nCLAW_DBF_TEXT(2, setup, "Wbufset");\r\nCLAW_DBF_TEXT_(2, setup, "WB=%d", p_env->write_buffers);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nclaw_rbuff_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct claw_privbk *priv;\r\nstruct claw_env * p_env;\r\npriv = dev_get_drvdata(dev);\r\nif (!priv)\r\nreturn -ENODEV;\r\np_env = priv->p_env;\r\nreturn sprintf(buf, "%d\n", p_env->read_buffers);\r\n}\r\nstatic ssize_t\r\nclaw_rbuff_write(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct claw_privbk *priv;\r\nstruct claw_env *p_env;\r\nint nnn,max;\r\npriv = dev_get_drvdata(dev);\r\nif (!priv)\r\nreturn -ENODEV;\r\np_env = priv->p_env;\r\nsscanf(buf, "%i", &nnn);\r\nif (p_env->packing) {\r\nmax = 64;\r\n}\r\nelse {\r\nmax = 512;\r\n}\r\nif ((nnn > max ) || (nnn < 2))\r\nreturn -EINVAL;\r\np_env->read_buffers = nnn;\r\nCLAW_DBF_TEXT(2, setup, "Rbufset");\r\nCLAW_DBF_TEXT_(2, setup, "RB=%d", p_env->read_buffers);\r\nreturn count;\r\n}\r\nstatic int claw_probe(struct ccwgroup_device *cgdev)\r\n{\r\nstruct claw_privbk *privptr = NULL;\r\nCLAW_DBF_TEXT(2, setup, "probe");\r\nif (!get_device(&cgdev->dev))\r\nreturn -ENODEV;\r\nprivptr = kzalloc(sizeof(struct claw_privbk), GFP_KERNEL);\r\ndev_set_drvdata(&cgdev->dev, privptr);\r\nif (privptr == NULL) {\r\nprobe_error(cgdev);\r\nput_device(&cgdev->dev);\r\nCLAW_DBF_TEXT_(2, setup, "probex%d", -ENOMEM);\r\nreturn -ENOMEM;\r\n}\r\nprivptr->p_mtc_envelope = kzalloc(MAX_ENVELOPE_SIZE, GFP_KERNEL);\r\nprivptr->p_env = kzalloc(sizeof(struct claw_env), GFP_KERNEL);\r\nif ((privptr->p_mtc_envelope == NULL) || (privptr->p_env == NULL)) {\r\nprobe_error(cgdev);\r\nput_device(&cgdev->dev);\r\nCLAW_DBF_TEXT_(2, setup, "probex%d", -ENOMEM);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(privptr->p_env->adapter_name, WS_NAME_NOT_DEF, 8);\r\nmemcpy(privptr->p_env->host_name, WS_NAME_NOT_DEF, 8);\r\nmemcpy(privptr->p_env->api_type, WS_NAME_NOT_DEF, 8);\r\nprivptr->p_env->packing = 0;\r\nprivptr->p_env->write_buffers = 5;\r\nprivptr->p_env->read_buffers = 5;\r\nprivptr->p_env->read_size = CLAW_FRAME_SIZE;\r\nprivptr->p_env->write_size = CLAW_FRAME_SIZE;\r\nprivptr->p_env->p_priv = privptr;\r\ncgdev->cdev[0]->handler = claw_irq_handler;\r\ncgdev->cdev[1]->handler = claw_irq_handler;\r\ncgdev->dev.type = &claw_devtype;\r\nCLAW_DBF_TEXT(2, setup, "prbext 0");\r\nreturn 0;\r\n}\r\nstatic void __exit claw_cleanup(void)\r\n{\r\nccwgroup_driver_unregister(&claw_group_driver);\r\nccw_driver_unregister(&claw_ccw_driver);\r\nroot_device_unregister(claw_root_dev);\r\nclaw_unregister_debug_facility();\r\npr_info("Driver unloaded\n");\r\n}\r\nstatic int __init claw_init(void)\r\n{\r\nint ret = 0;\r\npr_info("Loading %s\n", version);\r\nret = claw_register_debug_facility();\r\nif (ret) {\r\npr_err("Registering with the S/390 debug feature"\r\n" failed with error code %d\n", ret);\r\ngoto out_err;\r\n}\r\nCLAW_DBF_TEXT(2, setup, "init_mod");\r\nclaw_root_dev = root_device_register("claw");\r\nret = IS_ERR(claw_root_dev) ? PTR_ERR(claw_root_dev) : 0;\r\nif (ret)\r\ngoto register_err;\r\nret = ccw_driver_register(&claw_ccw_driver);\r\nif (ret)\r\ngoto ccw_err;\r\nclaw_group_driver.driver.groups = claw_drv_attr_groups;\r\nret = ccwgroup_driver_register(&claw_group_driver);\r\nif (ret)\r\ngoto ccwgroup_err;\r\nreturn 0;\r\nccwgroup_err:\r\nccw_driver_unregister(&claw_ccw_driver);\r\nccw_err:\r\nroot_device_unregister(claw_root_dev);\r\nregister_err:\r\nCLAW_DBF_TEXT(2, setup, "init_bad");\r\nclaw_unregister_debug_facility();\r\nout_err:\r\npr_err("Initializing the claw device driver failed\n");\r\nreturn ret;\r\n}
