void ceph_get_snap_realm(struct ceph_mds_client *mdsc,\r\nstruct ceph_snap_realm *realm)\r\n{\r\ndout("get_realm %p %d -> %d\n", realm,\r\natomic_read(&realm->nref), atomic_read(&realm->nref)+1);\r\nif (atomic_read(&realm->nref) == 0) {\r\nspin_lock(&mdsc->snap_empty_lock);\r\nlist_del_init(&realm->empty_item);\r\nspin_unlock(&mdsc->snap_empty_lock);\r\n}\r\natomic_inc(&realm->nref);\r\n}\r\nstatic void __insert_snap_realm(struct rb_root *root,\r\nstruct ceph_snap_realm *new)\r\n{\r\nstruct rb_node **p = &root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct ceph_snap_realm *r = NULL;\r\nwhile (*p) {\r\nparent = *p;\r\nr = rb_entry(parent, struct ceph_snap_realm, node);\r\nif (new->ino < r->ino)\r\np = &(*p)->rb_left;\r\nelse if (new->ino > r->ino)\r\np = &(*p)->rb_right;\r\nelse\r\nBUG();\r\n}\r\nrb_link_node(&new->node, parent, p);\r\nrb_insert_color(&new->node, root);\r\n}\r\nstatic struct ceph_snap_realm *ceph_create_snap_realm(\r\nstruct ceph_mds_client *mdsc,\r\nu64 ino)\r\n{\r\nstruct ceph_snap_realm *realm;\r\nrealm = kzalloc(sizeof(*realm), GFP_NOFS);\r\nif (!realm)\r\nreturn ERR_PTR(-ENOMEM);\r\natomic_set(&realm->nref, 0);\r\nrealm->ino = ino;\r\nINIT_LIST_HEAD(&realm->children);\r\nINIT_LIST_HEAD(&realm->child_item);\r\nINIT_LIST_HEAD(&realm->empty_item);\r\nINIT_LIST_HEAD(&realm->dirty_item);\r\nINIT_LIST_HEAD(&realm->inodes_with_caps);\r\nspin_lock_init(&realm->inodes_with_caps_lock);\r\n__insert_snap_realm(&mdsc->snap_realms, realm);\r\ndout("create_snap_realm %llx %p\n", realm->ino, realm);\r\nreturn realm;\r\n}\r\nstruct ceph_snap_realm *ceph_lookup_snap_realm(struct ceph_mds_client *mdsc,\r\nu64 ino)\r\n{\r\nstruct rb_node *n = mdsc->snap_realms.rb_node;\r\nstruct ceph_snap_realm *r;\r\nwhile (n) {\r\nr = rb_entry(n, struct ceph_snap_realm, node);\r\nif (ino < r->ino)\r\nn = n->rb_left;\r\nelse if (ino > r->ino)\r\nn = n->rb_right;\r\nelse {\r\ndout("lookup_snap_realm %llx %p\n", r->ino, r);\r\nreturn r;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void __destroy_snap_realm(struct ceph_mds_client *mdsc,\r\nstruct ceph_snap_realm *realm)\r\n{\r\ndout("__destroy_snap_realm %p %llx\n", realm, realm->ino);\r\nrb_erase(&realm->node, &mdsc->snap_realms);\r\nif (realm->parent) {\r\nlist_del_init(&realm->child_item);\r\n__put_snap_realm(mdsc, realm->parent);\r\n}\r\nkfree(realm->prior_parent_snaps);\r\nkfree(realm->snaps);\r\nceph_put_snap_context(realm->cached_context);\r\nkfree(realm);\r\n}\r\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\r\nstruct ceph_snap_realm *realm)\r\n{\r\ndout("__put_snap_realm %llx %p %d -> %d\n", realm->ino, realm,\r\natomic_read(&realm->nref), atomic_read(&realm->nref)-1);\r\nif (atomic_dec_and_test(&realm->nref))\r\n__destroy_snap_realm(mdsc, realm);\r\n}\r\nvoid ceph_put_snap_realm(struct ceph_mds_client *mdsc,\r\nstruct ceph_snap_realm *realm)\r\n{\r\ndout("put_snap_realm %llx %p %d -> %d\n", realm->ino, realm,\r\natomic_read(&realm->nref), atomic_read(&realm->nref)-1);\r\nif (!atomic_dec_and_test(&realm->nref))\r\nreturn;\r\nif (down_write_trylock(&mdsc->snap_rwsem)) {\r\n__destroy_snap_realm(mdsc, realm);\r\nup_write(&mdsc->snap_rwsem);\r\n} else {\r\nspin_lock(&mdsc->snap_empty_lock);\r\nlist_add(&realm->empty_item, &mdsc->snap_empty);\r\nspin_unlock(&mdsc->snap_empty_lock);\r\n}\r\n}\r\nstatic void __cleanup_empty_realms(struct ceph_mds_client *mdsc)\r\n{\r\nstruct ceph_snap_realm *realm;\r\nspin_lock(&mdsc->snap_empty_lock);\r\nwhile (!list_empty(&mdsc->snap_empty)) {\r\nrealm = list_first_entry(&mdsc->snap_empty,\r\nstruct ceph_snap_realm, empty_item);\r\nlist_del(&realm->empty_item);\r\nspin_unlock(&mdsc->snap_empty_lock);\r\n__destroy_snap_realm(mdsc, realm);\r\nspin_lock(&mdsc->snap_empty_lock);\r\n}\r\nspin_unlock(&mdsc->snap_empty_lock);\r\n}\r\nvoid ceph_cleanup_empty_realms(struct ceph_mds_client *mdsc)\r\n{\r\ndown_write(&mdsc->snap_rwsem);\r\n__cleanup_empty_realms(mdsc);\r\nup_write(&mdsc->snap_rwsem);\r\n}\r\nstatic int adjust_snap_realm_parent(struct ceph_mds_client *mdsc,\r\nstruct ceph_snap_realm *realm,\r\nu64 parentino)\r\n{\r\nstruct ceph_snap_realm *parent;\r\nif (realm->parent_ino == parentino)\r\nreturn 0;\r\nparent = ceph_lookup_snap_realm(mdsc, parentino);\r\nif (!parent) {\r\nparent = ceph_create_snap_realm(mdsc, parentino);\r\nif (IS_ERR(parent))\r\nreturn PTR_ERR(parent);\r\n}\r\ndout("adjust_snap_realm_parent %llx %p: %llx %p -> %llx %p\n",\r\nrealm->ino, realm, realm->parent_ino, realm->parent,\r\nparentino, parent);\r\nif (realm->parent) {\r\nlist_del_init(&realm->child_item);\r\nceph_put_snap_realm(mdsc, realm->parent);\r\n}\r\nrealm->parent_ino = parentino;\r\nrealm->parent = parent;\r\nceph_get_snap_realm(mdsc, parent);\r\nlist_add(&realm->child_item, &parent->children);\r\nreturn 1;\r\n}\r\nstatic int cmpu64_rev(const void *a, const void *b)\r\n{\r\nif (*(u64 *)a < *(u64 *)b)\r\nreturn 1;\r\nif (*(u64 *)a > *(u64 *)b)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int build_snap_context(struct ceph_snap_realm *realm)\r\n{\r\nstruct ceph_snap_realm *parent = realm->parent;\r\nstruct ceph_snap_context *snapc;\r\nint err = 0;\r\nu32 num = realm->num_prior_parent_snaps + realm->num_snaps;\r\nif (parent) {\r\nif (!parent->cached_context) {\r\nerr = build_snap_context(parent);\r\nif (err)\r\ngoto fail;\r\n}\r\nnum += parent->cached_context->num_snaps;\r\n}\r\nif (realm->cached_context &&\r\nrealm->cached_context->seq == realm->seq &&\r\n(!parent ||\r\nrealm->cached_context->seq >= parent->cached_context->seq)) {\r\ndout("build_snap_context %llx %p: %p seq %lld (%u snaps)"\r\n" (unchanged)\n",\r\nrealm->ino, realm, realm->cached_context,\r\nrealm->cached_context->seq,\r\n(unsigned int) realm->cached_context->num_snaps);\r\nreturn 0;\r\n}\r\nerr = -ENOMEM;\r\nif (num > (SIZE_MAX - sizeof(*snapc)) / sizeof(u64))\r\ngoto fail;\r\nsnapc = kzalloc(sizeof(*snapc) + num*sizeof(u64), GFP_NOFS);\r\nif (!snapc)\r\ngoto fail;\r\natomic_set(&snapc->nref, 1);\r\nnum = 0;\r\nsnapc->seq = realm->seq;\r\nif (parent) {\r\nu32 i;\r\nfor (i = 0; i < parent->cached_context->num_snaps; i++)\r\nif (parent->cached_context->snaps[i] >=\r\nrealm->parent_since)\r\nsnapc->snaps[num++] =\r\nparent->cached_context->snaps[i];\r\nif (parent->cached_context->seq > snapc->seq)\r\nsnapc->seq = parent->cached_context->seq;\r\n}\r\nmemcpy(snapc->snaps + num, realm->snaps,\r\nsizeof(u64)*realm->num_snaps);\r\nnum += realm->num_snaps;\r\nmemcpy(snapc->snaps + num, realm->prior_parent_snaps,\r\nsizeof(u64)*realm->num_prior_parent_snaps);\r\nnum += realm->num_prior_parent_snaps;\r\nsort(snapc->snaps, num, sizeof(u64), cmpu64_rev, NULL);\r\nsnapc->num_snaps = num;\r\ndout("build_snap_context %llx %p: %p seq %lld (%u snaps)\n",\r\nrealm->ino, realm, snapc, snapc->seq,\r\n(unsigned int) snapc->num_snaps);\r\nif (realm->cached_context)\r\nceph_put_snap_context(realm->cached_context);\r\nrealm->cached_context = snapc;\r\nreturn 0;\r\nfail:\r\nif (realm->cached_context) {\r\nceph_put_snap_context(realm->cached_context);\r\nrealm->cached_context = NULL;\r\n}\r\npr_err("build_snap_context %llx %p fail %d\n", realm->ino,\r\nrealm, err);\r\nreturn err;\r\n}\r\nstatic void rebuild_snap_realms(struct ceph_snap_realm *realm)\r\n{\r\nstruct ceph_snap_realm *child;\r\ndout("rebuild_snap_realms %llx %p\n", realm->ino, realm);\r\nbuild_snap_context(realm);\r\nlist_for_each_entry(child, &realm->children, child_item)\r\nrebuild_snap_realms(child);\r\n}\r\nstatic int dup_array(u64 **dst, __le64 *src, u32 num)\r\n{\r\nu32 i;\r\nkfree(*dst);\r\nif (num) {\r\n*dst = kcalloc(num, sizeof(u64), GFP_NOFS);\r\nif (!*dst)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num; i++)\r\n(*dst)[i] = get_unaligned_le64(src + i);\r\n} else {\r\n*dst = NULL;\r\n}\r\nreturn 0;\r\n}\r\nvoid ceph_queue_cap_snap(struct ceph_inode_info *ci)\r\n{\r\nstruct inode *inode = &ci->vfs_inode;\r\nstruct ceph_cap_snap *capsnap;\r\nint used, dirty;\r\ncapsnap = kzalloc(sizeof(*capsnap), GFP_NOFS);\r\nif (!capsnap) {\r\npr_err("ENOMEM allocating ceph_cap_snap on %p\n", inode);\r\nreturn;\r\n}\r\nspin_lock(&ci->i_ceph_lock);\r\nused = __ceph_caps_used(ci);\r\ndirty = __ceph_caps_dirty(ci);\r\nif (used & CEPH_CAP_FILE_WR)\r\ndirty |= CEPH_CAP_FILE_WR;\r\nif (__ceph_have_pending_cap_snap(ci)) {\r\ndout("queue_cap_snap %p already pending\n", inode);\r\nkfree(capsnap);\r\n} else if (dirty & (CEPH_CAP_AUTH_EXCL|CEPH_CAP_XATTR_EXCL|\r\nCEPH_CAP_FILE_EXCL|CEPH_CAP_FILE_WR)) {\r\nstruct ceph_snap_context *snapc = ci->i_head_snapc;\r\nif (!snapc)\r\nsnapc = ci->i_snap_realm->cached_context;\r\ndout("queue_cap_snap %p cap_snap %p queuing under %p %s\n",\r\ninode, capsnap, snapc, ceph_cap_string(dirty));\r\nihold(inode);\r\natomic_set(&capsnap->nref, 1);\r\ncapsnap->ci = ci;\r\nINIT_LIST_HEAD(&capsnap->ci_item);\r\nINIT_LIST_HEAD(&capsnap->flushing_item);\r\ncapsnap->follows = snapc->seq;\r\ncapsnap->issued = __ceph_caps_issued(ci, NULL);\r\ncapsnap->dirty = dirty;\r\ncapsnap->mode = inode->i_mode;\r\ncapsnap->uid = inode->i_uid;\r\ncapsnap->gid = inode->i_gid;\r\nif (dirty & CEPH_CAP_XATTR_EXCL) {\r\n__ceph_build_xattrs_blob(ci);\r\ncapsnap->xattr_blob =\r\nceph_buffer_get(ci->i_xattrs.blob);\r\ncapsnap->xattr_version = ci->i_xattrs.version;\r\n} else {\r\ncapsnap->xattr_blob = NULL;\r\ncapsnap->xattr_version = 0;\r\n}\r\ncapsnap->dirty_pages = ci->i_wrbuffer_ref_head;\r\nci->i_wrbuffer_ref_head = 0;\r\ncapsnap->context = snapc;\r\nci->i_head_snapc =\r\nceph_get_snap_context(ci->i_snap_realm->cached_context);\r\ndout(" new snapc is %p\n", ci->i_head_snapc);\r\nlist_add_tail(&capsnap->ci_item, &ci->i_cap_snaps);\r\nif (used & CEPH_CAP_FILE_WR) {\r\ndout("queue_cap_snap %p cap_snap %p snapc %p"\r\n" seq %llu used WR, now pending\n", inode,\r\ncapsnap, snapc, snapc->seq);\r\ncapsnap->writing = 1;\r\n} else {\r\n__ceph_finish_cap_snap(ci, capsnap);\r\n}\r\n} else {\r\ndout("queue_cap_snap %p nothing dirty|writing\n", inode);\r\nkfree(capsnap);\r\n}\r\nspin_unlock(&ci->i_ceph_lock);\r\n}\r\nint __ceph_finish_cap_snap(struct ceph_inode_info *ci,\r\nstruct ceph_cap_snap *capsnap)\r\n{\r\nstruct inode *inode = &ci->vfs_inode;\r\nstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\r\nBUG_ON(capsnap->writing);\r\ncapsnap->size = inode->i_size;\r\ncapsnap->mtime = inode->i_mtime;\r\ncapsnap->atime = inode->i_atime;\r\ncapsnap->ctime = inode->i_ctime;\r\ncapsnap->time_warp_seq = ci->i_time_warp_seq;\r\nif (capsnap->dirty_pages) {\r\ndout("finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu "\r\n"still has %d dirty pages\n", inode, capsnap,\r\ncapsnap->context, capsnap->context->seq,\r\nceph_cap_string(capsnap->dirty), capsnap->size,\r\ncapsnap->dirty_pages);\r\nreturn 0;\r\n}\r\ndout("finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu\n",\r\ninode, capsnap, capsnap->context,\r\ncapsnap->context->seq, ceph_cap_string(capsnap->dirty),\r\ncapsnap->size);\r\nspin_lock(&mdsc->snap_flush_lock);\r\nlist_add_tail(&ci->i_snap_flush_item, &mdsc->snap_flush_list);\r\nspin_unlock(&mdsc->snap_flush_lock);\r\nreturn 1;\r\n}\r\nstatic void queue_realm_cap_snaps(struct ceph_snap_realm *realm)\r\n{\r\nstruct ceph_inode_info *ci;\r\nstruct inode *lastinode = NULL;\r\nstruct ceph_snap_realm *child;\r\ndout("queue_realm_cap_snaps %p %llx inodes\n", realm, realm->ino);\r\nspin_lock(&realm->inodes_with_caps_lock);\r\nlist_for_each_entry(ci, &realm->inodes_with_caps,\r\ni_snap_realm_item) {\r\nstruct inode *inode = igrab(&ci->vfs_inode);\r\nif (!inode)\r\ncontinue;\r\nspin_unlock(&realm->inodes_with_caps_lock);\r\nif (lastinode)\r\niput(lastinode);\r\nlastinode = inode;\r\nceph_queue_cap_snap(ci);\r\nspin_lock(&realm->inodes_with_caps_lock);\r\n}\r\nspin_unlock(&realm->inodes_with_caps_lock);\r\nif (lastinode)\r\niput(lastinode);\r\nlist_for_each_entry(child, &realm->children, child_item) {\r\ndout("queue_realm_cap_snaps %p %llx queue child %p %llx\n",\r\nrealm, realm->ino, child, child->ino);\r\nlist_del_init(&child->dirty_item);\r\nlist_add(&child->dirty_item, &realm->dirty_item);\r\n}\r\nlist_del_init(&realm->dirty_item);\r\ndout("queue_realm_cap_snaps %p %llx done\n", realm, realm->ino);\r\n}\r\nint ceph_update_snap_trace(struct ceph_mds_client *mdsc,\r\nvoid *p, void *e, bool deletion)\r\n{\r\nstruct ceph_mds_snap_realm *ri;\r\n__le64 *snaps;\r\n__le64 *prior_parent_snaps;\r\nstruct ceph_snap_realm *realm;\r\nint invalidate = 0;\r\nint err = -ENOMEM;\r\nLIST_HEAD(dirty_realms);\r\ndout("update_snap_trace deletion=%d\n", deletion);\r\nmore:\r\nceph_decode_need(&p, e, sizeof(*ri), bad);\r\nri = p;\r\np += sizeof(*ri);\r\nceph_decode_need(&p, e, sizeof(u64)*(le32_to_cpu(ri->num_snaps) +\r\nle32_to_cpu(ri->num_prior_parent_snaps)), bad);\r\nsnaps = p;\r\np += sizeof(u64) * le32_to_cpu(ri->num_snaps);\r\nprior_parent_snaps = p;\r\np += sizeof(u64) * le32_to_cpu(ri->num_prior_parent_snaps);\r\nrealm = ceph_lookup_snap_realm(mdsc, le64_to_cpu(ri->ino));\r\nif (!realm) {\r\nrealm = ceph_create_snap_realm(mdsc, le64_to_cpu(ri->ino));\r\nif (IS_ERR(realm)) {\r\nerr = PTR_ERR(realm);\r\ngoto fail;\r\n}\r\n}\r\nerr = adjust_snap_realm_parent(mdsc, realm, le64_to_cpu(ri->parent));\r\nif (err < 0)\r\ngoto fail;\r\ninvalidate += err;\r\nif (le64_to_cpu(ri->seq) > realm->seq) {\r\ndout("update_snap_trace updating %llx %p %lld -> %lld\n",\r\nrealm->ino, realm, realm->seq, le64_to_cpu(ri->seq));\r\nrealm->seq = le64_to_cpu(ri->seq);\r\nrealm->created = le64_to_cpu(ri->created);\r\nrealm->parent_since = le64_to_cpu(ri->parent_since);\r\nrealm->num_snaps = le32_to_cpu(ri->num_snaps);\r\nerr = dup_array(&realm->snaps, snaps, realm->num_snaps);\r\nif (err < 0)\r\ngoto fail;\r\nrealm->num_prior_parent_snaps =\r\nle32_to_cpu(ri->num_prior_parent_snaps);\r\nerr = dup_array(&realm->prior_parent_snaps, prior_parent_snaps,\r\nrealm->num_prior_parent_snaps);\r\nif (err < 0)\r\ngoto fail;\r\nlist_add(&realm->dirty_item, &dirty_realms);\r\ninvalidate = 1;\r\n} else if (!realm->cached_context) {\r\ndout("update_snap_trace %llx %p seq %lld new\n",\r\nrealm->ino, realm, realm->seq);\r\ninvalidate = 1;\r\n} else {\r\ndout("update_snap_trace %llx %p seq %lld unchanged\n",\r\nrealm->ino, realm, realm->seq);\r\n}\r\ndout("done with %llx %p, invalidated=%d, %p %p\n", realm->ino,\r\nrealm, invalidate, p, e);\r\nif (p < e)\r\ngoto more;\r\nif (invalidate)\r\nrebuild_snap_realms(realm);\r\nwhile (!list_empty(&dirty_realms)) {\r\nrealm = list_first_entry(&dirty_realms, struct ceph_snap_realm,\r\ndirty_item);\r\nqueue_realm_cap_snaps(realm);\r\n}\r\n__cleanup_empty_realms(mdsc);\r\nreturn 0;\r\nbad:\r\nerr = -EINVAL;\r\nfail:\r\npr_err("update_snap_trace error %d\n", err);\r\nreturn err;\r\n}\r\nstatic void flush_snaps(struct ceph_mds_client *mdsc)\r\n{\r\nstruct ceph_inode_info *ci;\r\nstruct inode *inode;\r\nstruct ceph_mds_session *session = NULL;\r\ndout("flush_snaps\n");\r\nspin_lock(&mdsc->snap_flush_lock);\r\nwhile (!list_empty(&mdsc->snap_flush_list)) {\r\nci = list_first_entry(&mdsc->snap_flush_list,\r\nstruct ceph_inode_info, i_snap_flush_item);\r\ninode = &ci->vfs_inode;\r\nihold(inode);\r\nspin_unlock(&mdsc->snap_flush_lock);\r\nspin_lock(&ci->i_ceph_lock);\r\n__ceph_flush_snaps(ci, &session, 0);\r\nspin_unlock(&ci->i_ceph_lock);\r\niput(inode);\r\nspin_lock(&mdsc->snap_flush_lock);\r\n}\r\nspin_unlock(&mdsc->snap_flush_lock);\r\nif (session) {\r\nmutex_unlock(&session->s_mutex);\r\nceph_put_mds_session(session);\r\n}\r\ndout("flush_snaps done\n");\r\n}\r\nvoid ceph_handle_snap(struct ceph_mds_client *mdsc,\r\nstruct ceph_mds_session *session,\r\nstruct ceph_msg *msg)\r\n{\r\nstruct super_block *sb = mdsc->fsc->sb;\r\nint mds = session->s_mds;\r\nu64 split;\r\nint op;\r\nint trace_len;\r\nstruct ceph_snap_realm *realm = NULL;\r\nvoid *p = msg->front.iov_base;\r\nvoid *e = p + msg->front.iov_len;\r\nstruct ceph_mds_snap_head *h;\r\nint num_split_inos, num_split_realms;\r\n__le64 *split_inos = NULL, *split_realms = NULL;\r\nint i;\r\nint locked_rwsem = 0;\r\nif (msg->front.iov_len < sizeof(*h))\r\ngoto bad;\r\nh = p;\r\nop = le32_to_cpu(h->op);\r\nsplit = le64_to_cpu(h->split);\r\nnum_split_inos = le32_to_cpu(h->num_split_inos);\r\nnum_split_realms = le32_to_cpu(h->num_split_realms);\r\ntrace_len = le32_to_cpu(h->trace_len);\r\np += sizeof(*h);\r\ndout("handle_snap from mds%d op %s split %llx tracelen %d\n", mds,\r\nceph_snap_op_name(op), split, trace_len);\r\nmutex_lock(&session->s_mutex);\r\nsession->s_seq++;\r\nmutex_unlock(&session->s_mutex);\r\ndown_write(&mdsc->snap_rwsem);\r\nlocked_rwsem = 1;\r\nif (op == CEPH_SNAP_OP_SPLIT) {\r\nstruct ceph_mds_snap_realm *ri;\r\nsplit_inos = p;\r\np += sizeof(u64) * num_split_inos;\r\nsplit_realms = p;\r\np += sizeof(u64) * num_split_realms;\r\nceph_decode_need(&p, e, sizeof(*ri), bad);\r\nri = p;\r\nrealm = ceph_lookup_snap_realm(mdsc, split);\r\nif (!realm) {\r\nrealm = ceph_create_snap_realm(mdsc, split);\r\nif (IS_ERR(realm))\r\ngoto out;\r\n}\r\nceph_get_snap_realm(mdsc, realm);\r\ndout("splitting snap_realm %llx %p\n", realm->ino, realm);\r\nfor (i = 0; i < num_split_inos; i++) {\r\nstruct ceph_vino vino = {\r\n.ino = le64_to_cpu(split_inos[i]),\r\n.snap = CEPH_NOSNAP,\r\n};\r\nstruct inode *inode = ceph_find_inode(sb, vino);\r\nstruct ceph_inode_info *ci;\r\nstruct ceph_snap_realm *oldrealm;\r\nif (!inode)\r\ncontinue;\r\nci = ceph_inode(inode);\r\nspin_lock(&ci->i_ceph_lock);\r\nif (!ci->i_snap_realm)\r\ngoto skip_inode;\r\nif (ci->i_snap_realm->created >\r\nle64_to_cpu(ri->created)) {\r\ndout(" leaving %p in newer realm %llx %p\n",\r\ninode, ci->i_snap_realm->ino,\r\nci->i_snap_realm);\r\ngoto skip_inode;\r\n}\r\ndout(" will move %p to split realm %llx %p\n",\r\ninode, realm->ino, realm);\r\nspin_lock(&realm->inodes_with_caps_lock);\r\nlist_del_init(&ci->i_snap_realm_item);\r\nlist_add(&ci->i_snap_realm_item,\r\n&realm->inodes_with_caps);\r\noldrealm = ci->i_snap_realm;\r\nci->i_snap_realm = realm;\r\nspin_unlock(&realm->inodes_with_caps_lock);\r\nspin_unlock(&ci->i_ceph_lock);\r\nceph_get_snap_realm(mdsc, realm);\r\nceph_put_snap_realm(mdsc, oldrealm);\r\niput(inode);\r\ncontinue;\r\nskip_inode:\r\nspin_unlock(&ci->i_ceph_lock);\r\niput(inode);\r\n}\r\nfor (i = 0; i < num_split_realms; i++) {\r\nstruct ceph_snap_realm *child =\r\nceph_lookup_snap_realm(mdsc,\r\nle64_to_cpu(split_realms[i]));\r\nif (!child)\r\ncontinue;\r\nadjust_snap_realm_parent(mdsc, child, realm->ino);\r\n}\r\n}\r\nceph_update_snap_trace(mdsc, p, e,\r\nop == CEPH_SNAP_OP_DESTROY);\r\nif (op == CEPH_SNAP_OP_SPLIT)\r\nceph_put_snap_realm(mdsc, realm);\r\n__cleanup_empty_realms(mdsc);\r\nup_write(&mdsc->snap_rwsem);\r\nflush_snaps(mdsc);\r\nreturn;\r\nbad:\r\npr_err("corrupt snap message from mds%d\n", mds);\r\nceph_msg_dump(msg);\r\nout:\r\nif (locked_rwsem)\r\nup_write(&mdsc->snap_rwsem);\r\nreturn;\r\n}
