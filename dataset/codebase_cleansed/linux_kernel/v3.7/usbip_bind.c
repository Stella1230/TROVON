void usbip_bind_usage(void)\r\n{\r\nprintf("usage: %s", usbip_bind_usage_string);\r\n}\r\nstatic int bind_usbip(char *busid)\r\n{\r\nchar bus_type[] = "usb";\r\nchar attr_name[] = "bind";\r\nchar sysfs_mntpath[SYSFS_PATH_MAX];\r\nchar bind_attr_path[SYSFS_PATH_MAX];\r\nchar intf_busid[SYSFS_BUS_ID_SIZE];\r\nstruct sysfs_device *busid_dev;\r\nstruct sysfs_attribute *bind_attr;\r\nstruct sysfs_attribute *bConfValue;\r\nstruct sysfs_attribute *bNumIntfs;\r\nint i, failed = 0;\r\nint rc, ret = -1;\r\nrc = sysfs_get_mnt_path(sysfs_mntpath, SYSFS_PATH_MAX);\r\nif (rc < 0) {\r\nerr("sysfs must be mounted: %s", strerror(errno));\r\nreturn -1;\r\n}\r\nsnprintf(bind_attr_path, sizeof(bind_attr_path), "%s/%s/%s/%s/%s/%s",\r\nsysfs_mntpath, SYSFS_BUS_NAME, bus_type, SYSFS_DRIVERS_NAME,\r\nUSBIP_HOST_DRV_NAME, attr_name);\r\nbind_attr = sysfs_open_attribute(bind_attr_path);\r\nif (!bind_attr) {\r\ndbg("problem getting bind attribute: %s", strerror(errno));\r\nreturn -1;\r\n}\r\nbusid_dev = sysfs_open_device(bus_type, busid);\r\nif (!busid_dev) {\r\ndbg("sysfs_open_device %s failed: %s", busid, strerror(errno));\r\ngoto err_close_bind_attr;\r\n}\r\nbConfValue = sysfs_get_device_attr(busid_dev, "bConfigurationValue");\r\nbNumIntfs = sysfs_get_device_attr(busid_dev, "bNumInterfaces");\r\nif (!bConfValue || !bNumIntfs) {\r\ndbg("problem getting device attributes: %s",\r\nstrerror(errno));\r\ngoto err_close_busid_dev;\r\n}\r\nfor (i = 0; i < atoi(bNumIntfs->value); i++) {\r\nsnprintf(intf_busid, SYSFS_BUS_ID_SIZE, "%s:%.1s.%d", busid,\r\nbConfValue->value, i);\r\nrc = sysfs_write_attribute(bind_attr, intf_busid,\r\nSYSFS_BUS_ID_SIZE);\r\nif (rc < 0) {\r\ndbg("bind driver at %s failed", intf_busid);\r\nfailed = 1;\r\n}\r\n}\r\nif (!failed)\r\nret = 0;\r\nerr_close_busid_dev:\r\nsysfs_close_device(busid_dev);\r\nerr_close_bind_attr:\r\nsysfs_close_attribute(bind_attr);\r\nreturn ret;\r\n}\r\nstatic int unbind_other(char *busid)\r\n{\r\nchar bus_type[] = "usb";\r\nchar intf_busid[SYSFS_BUS_ID_SIZE];\r\nstruct sysfs_device *busid_dev;\r\nstruct sysfs_device *intf_dev;\r\nstruct sysfs_driver *intf_drv;\r\nstruct sysfs_attribute *unbind_attr;\r\nstruct sysfs_attribute *bConfValue;\r\nstruct sysfs_attribute *bDevClass;\r\nstruct sysfs_attribute *bNumIntfs;\r\nint i, rc;\r\nenum unbind_status status = UNBIND_ST_OK;\r\nbusid_dev = sysfs_open_device(bus_type, busid);\r\nif (!busid_dev) {\r\ndbg("sysfs_open_device %s failed: %s", busid, strerror(errno));\r\nreturn -1;\r\n}\r\nbConfValue = sysfs_get_device_attr(busid_dev, "bConfigurationValue");\r\nbDevClass = sysfs_get_device_attr(busid_dev, "bDeviceClass");\r\nbNumIntfs = sysfs_get_device_attr(busid_dev, "bNumInterfaces");\r\nif (!bConfValue || !bDevClass || !bNumIntfs) {\r\ndbg("problem getting device attributes: %s",\r\nstrerror(errno));\r\ngoto err_close_busid_dev;\r\n}\r\nif (!strncmp(bDevClass->value, "09", bDevClass->len)) {\r\ndbg("skip unbinding of hub");\r\ngoto err_close_busid_dev;\r\n}\r\nfor (i = 0; i < atoi(bNumIntfs->value); i++) {\r\nsnprintf(intf_busid, SYSFS_BUS_ID_SIZE, "%s:%.1s.%d", busid,\r\nbConfValue->value, i);\r\nintf_dev = sysfs_open_device(bus_type, intf_busid);\r\nif (!intf_dev) {\r\ndbg("could not open interface device: %s",\r\nstrerror(errno));\r\ngoto err_close_busid_dev;\r\n}\r\ndbg("%s -> %s", intf_dev->name, intf_dev->driver_name);\r\nif (!strncmp("unknown", intf_dev->driver_name, SYSFS_NAME_LEN))\r\ncontinue;\r\nif (!strncmp(USBIP_HOST_DRV_NAME, intf_dev->driver_name,\r\nSYSFS_NAME_LEN)) {\r\nstatus = UNBIND_ST_USBIP_HOST;\r\ncontinue;\r\n}\r\nintf_drv = sysfs_open_driver(bus_type, intf_dev->driver_name);\r\nif (!intf_drv) {\r\ndbg("could not open interface driver on %s: %s",\r\nintf_dev->name, strerror(errno));\r\ngoto err_close_intf_dev;\r\n}\r\nunbind_attr = sysfs_get_driver_attr(intf_drv, "unbind");\r\nif (!unbind_attr) {\r\ndbg("problem getting interface driver attribute: %s",\r\nstrerror(errno));\r\ngoto err_close_intf_drv;\r\n}\r\nrc = sysfs_write_attribute(unbind_attr, intf_dev->bus_id,\r\nSYSFS_BUS_ID_SIZE);\r\nif (rc < 0) {\r\ndbg("unbind driver at %s failed", intf_dev->bus_id);\r\nstatus = UNBIND_ST_FAILED;\r\n}\r\nsysfs_close_driver(intf_drv);\r\nsysfs_close_device(intf_dev);\r\n}\r\ngoto out;\r\nerr_close_intf_drv:\r\nsysfs_close_driver(intf_drv);\r\nerr_close_intf_dev:\r\nsysfs_close_device(intf_dev);\r\nerr_close_busid_dev:\r\nstatus = UNBIND_ST_FAILED;\r\nout:\r\nsysfs_close_device(busid_dev);\r\nreturn status;\r\n}\r\nstatic int bind_device(char *busid)\r\n{\r\nint rc;\r\nrc = unbind_other(busid);\r\nif (rc == UNBIND_ST_FAILED) {\r\nerr("could not unbind driver from device on busid %s", busid);\r\nreturn -1;\r\n} else if (rc == UNBIND_ST_USBIP_HOST) {\r\nerr("device on busid %s is already bound to %s", busid,\r\nUSBIP_HOST_DRV_NAME);\r\nreturn -1;\r\n}\r\nrc = modify_match_busid(busid, 1);\r\nif (rc < 0) {\r\nerr("unable to bind device on %s", busid);\r\nreturn -1;\r\n}\r\nrc = bind_usbip(busid);\r\nif (rc < 0) {\r\nerr("could not bind device to %s", USBIP_HOST_DRV_NAME);\r\nmodify_match_busid(busid, 0);\r\nreturn -1;\r\n}\r\nprintf("bind device on busid %s: complete\n", busid);\r\nreturn 0;\r\n}\r\nint usbip_bind(int argc, char *argv[])\r\n{\r\nstatic const struct option opts[] = {\r\n{ "busid", required_argument, NULL, 'b' },\r\n{ NULL, 0, NULL, 0 }\r\n};\r\nint opt;\r\nint ret = -1;\r\nfor (;;) {\r\nopt = getopt_long(argc, argv, "b:", opts, NULL);\r\nif (opt == -1)\r\nbreak;\r\nswitch (opt) {\r\ncase 'b':\r\nret = bind_device(optarg);\r\ngoto out;\r\ndefault:\r\ngoto err_out;\r\n}\r\n}\r\nerr_out:\r\nusbip_bind_usage();\r\nout:\r\nreturn ret;\r\n}
