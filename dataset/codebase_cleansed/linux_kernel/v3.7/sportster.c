static inline int\r\ncalc_off(unsigned int base, unsigned int off)\r\n{\r\nreturn (base + ((off & 0xfc) << 8) + ((off & 3) << 1));\r\n}\r\nstatic inline void\r\nread_fifo(unsigned int adr, u_char *data, int size)\r\n{\r\ninsb(adr, data, size);\r\n}\r\nstatic void\r\nwrite_fifo(unsigned int adr, u_char *data, int size)\r\n{\r\noutsb(adr, data, size);\r\n}\r\nstatic u_char\r\nReadISAC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nreturn (bytein(calc_off(cs->hw.spt.isac, offset)));\r\n}\r\nstatic void\r\nWriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nbyteout(calc_off(cs->hw.spt.isac, offset), value);\r\n}\r\nstatic void\r\nReadISACfifo(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nread_fifo(cs->hw.spt.isac, data, size);\r\n}\r\nstatic void\r\nWriteISACfifo(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nwrite_fifo(cs->hw.spt.isac, data, size);\r\n}\r\nstatic u_char\r\nReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)\r\n{\r\nreturn (bytein(calc_off(cs->hw.spt.hscx[hscx], offset)));\r\n}\r\nstatic void\r\nWriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)\r\n{\r\nbyteout(calc_off(cs->hw.spt.hscx[hscx], offset), value);\r\n}\r\nstatic irqreturn_t\r\nsportster_interrupt(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char val;\r\nu_long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nval = READHSCX(cs, 1, HSCX_ISTA);\r\nStart_HSCX:\r\nif (val)\r\nhscx_int_main(cs, val);\r\nval = ReadISAC(cs, ISAC_ISTA);\r\nStart_ISAC:\r\nif (val)\r\nisac_interrupt(cs, val);\r\nval = READHSCX(cs, 1, HSCX_ISTA);\r\nif (val) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HSCX IntStat after IntRoutine");\r\ngoto Start_HSCX;\r\n}\r\nval = ReadISAC(cs, ISAC_ISTA);\r\nif (val) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ISAC IntStat after IntRoutine");\r\ngoto Start_ISAC;\r\n}\r\nbytein(cs->hw.spt.cfg_reg + SPORTSTER_RES_IRQ + 1);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nrelease_io_sportster(struct IsdnCardState *cs)\r\n{\r\nint i, adr;\r\nbyteout(cs->hw.spt.cfg_reg + SPORTSTER_RES_IRQ, 0);\r\nfor (i = 0; i < 64; i++) {\r\nadr = cs->hw.spt.cfg_reg + i * 1024;\r\nrelease_region(adr, 8);\r\n}\r\n}\r\nstatic void\r\nreset_sportster(struct IsdnCardState *cs)\r\n{\r\ncs->hw.spt.res_irq |= SPORTSTER_RESET;\r\nbyteout(cs->hw.spt.cfg_reg + SPORTSTER_RES_IRQ, cs->hw.spt.res_irq);\r\nmdelay(10);\r\ncs->hw.spt.res_irq &= ~SPORTSTER_RESET;\r\nbyteout(cs->hw.spt.cfg_reg + SPORTSTER_RES_IRQ, cs->hw.spt.res_irq);\r\nmdelay(10);\r\n}\r\nstatic int\r\nSportster_card_msg(struct IsdnCardState *cs, int mt, void *arg)\r\n{\r\nu_long flags;\r\nswitch (mt) {\r\ncase CARD_RESET:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nreset_sportster(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_RELEASE:\r\nrelease_io_sportster(cs);\r\nreturn (0);\r\ncase CARD_INIT:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nreset_sportster(cs);\r\ninithscxisac(cs, 1);\r\ncs->hw.spt.res_irq |= SPORTSTER_INTE;\r\nbyteout(cs->hw.spt.cfg_reg + SPORTSTER_RES_IRQ, cs->hw.spt.res_irq);\r\ninithscxisac(cs, 2);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_TEST:\r\nreturn (0);\r\n}\r\nreturn (0);\r\n}\r\nstatic int __devinit\r\nget_io_range(struct IsdnCardState *cs)\r\n{\r\nint i, j, adr;\r\nfor (i = 0; i < 64; i++) {\r\nadr = cs->hw.spt.cfg_reg + i * 1024;\r\nif (!request_region(adr, 8, "sportster")) {\r\nprintk(KERN_WARNING "HiSax: USR Sportster config port "\r\n"%x-%x already in use\n",\r\nadr, adr + 8);\r\nbreak;\r\n}\r\n}\r\nif (i == 64)\r\nreturn (1);\r\nelse {\r\nfor (j = 0; j < i; j++) {\r\nadr = cs->hw.spt.cfg_reg + j * 1024;\r\nrelease_region(adr, 8);\r\n}\r\nreturn (0);\r\n}\r\n}\r\nint __devinit\r\nsetup_sportster(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\nchar tmp[64];\r\nstrcpy(tmp, sportster_revision);\r\nprintk(KERN_INFO "HiSax: USR Sportster driver Rev. %s\n", HiSax_getrev(tmp));\r\nif (cs->typ != ISDN_CTYPE_SPORTSTER)\r\nreturn (0);\r\ncs->hw.spt.cfg_reg = card->para[1];\r\ncs->irq = card->para[0];\r\nif (!get_io_range(cs))\r\nreturn (0);\r\ncs->hw.spt.isac = cs->hw.spt.cfg_reg + SPORTSTER_ISAC;\r\ncs->hw.spt.hscx[0] = cs->hw.spt.cfg_reg + SPORTSTER_HSCXA;\r\ncs->hw.spt.hscx[1] = cs->hw.spt.cfg_reg + SPORTSTER_HSCXB;\r\nswitch (cs->irq) {\r\ncase 5: cs->hw.spt.res_irq = 1;\r\nbreak;\r\ncase 7: cs->hw.spt.res_irq = 2;\r\nbreak;\r\ncase 10:cs->hw.spt.res_irq = 3;\r\nbreak;\r\ncase 11:cs->hw.spt.res_irq = 4;\r\nbreak;\r\ncase 12:cs->hw.spt.res_irq = 5;\r\nbreak;\r\ncase 14:cs->hw.spt.res_irq = 6;\r\nbreak;\r\ncase 15:cs->hw.spt.res_irq = 7;\r\nbreak;\r\ndefault:release_io_sportster(cs);\r\nprintk(KERN_WARNING "Sportster: wrong IRQ\n");\r\nreturn (0);\r\n}\r\nprintk(KERN_INFO "HiSax: USR Sportster config irq:%d cfg:0x%X\n",\r\ncs->irq, cs->hw.spt.cfg_reg);\r\nsetup_isac(cs);\r\ncs->readisac = &ReadISAC;\r\ncs->writeisac = &WriteISAC;\r\ncs->readisacfifo = &ReadISACfifo;\r\ncs->writeisacfifo = &WriteISACfifo;\r\ncs->BC_Read_Reg = &ReadHSCX;\r\ncs->BC_Write_Reg = &WriteHSCX;\r\ncs->BC_Send_Data = &hscx_fill_fifo;\r\ncs->cardmsg = &Sportster_card_msg;\r\ncs->irq_func = &sportster_interrupt;\r\nISACVersion(cs, "Sportster:");\r\nif (HscxVersion(cs, "Sportster:")) {\r\nprintk(KERN_WARNING\r\n"Sportster: wrong HSCX versions check IO address\n");\r\nrelease_io_sportster(cs);\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}
