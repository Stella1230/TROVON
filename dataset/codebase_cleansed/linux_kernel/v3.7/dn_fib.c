void dn_fib_free_info(struct dn_fib_info *fi)\r\n{\r\nif (fi->fib_dead == 0) {\r\nprintk(KERN_DEBUG "DECnet: BUG! Attempt to free alive dn_fib_info\n");\r\nreturn;\r\n}\r\nchange_nexthops(fi) {\r\nif (nh->nh_dev)\r\ndev_put(nh->nh_dev);\r\nnh->nh_dev = NULL;\r\n} endfor_nexthops(fi);\r\nkfree(fi);\r\n}\r\nvoid dn_fib_release_info(struct dn_fib_info *fi)\r\n{\r\nspin_lock(&dn_fib_info_lock);\r\nif (fi && --fi->fib_treeref == 0) {\r\nif (fi->fib_next)\r\nfi->fib_next->fib_prev = fi->fib_prev;\r\nif (fi->fib_prev)\r\nfi->fib_prev->fib_next = fi->fib_next;\r\nif (fi == dn_fib_info_list)\r\ndn_fib_info_list = fi->fib_next;\r\nfi->fib_dead = 1;\r\ndn_fib_info_put(fi);\r\n}\r\nspin_unlock(&dn_fib_info_lock);\r\n}\r\nstatic inline int dn_fib_nh_comp(const struct dn_fib_info *fi, const struct dn_fib_info *ofi)\r\n{\r\nconst struct dn_fib_nh *onh = ofi->fib_nh;\r\nfor_nexthops(fi) {\r\nif (nh->nh_oif != onh->nh_oif ||\r\nnh->nh_gw != onh->nh_gw ||\r\nnh->nh_scope != onh->nh_scope ||\r\nnh->nh_weight != onh->nh_weight ||\r\n((nh->nh_flags^onh->nh_flags)&~RTNH_F_DEAD))\r\nreturn -1;\r\nonh++;\r\n} endfor_nexthops(fi);\r\nreturn 0;\r\n}\r\nstatic inline struct dn_fib_info *dn_fib_find_info(const struct dn_fib_info *nfi)\r\n{\r\nfor_fib_info() {\r\nif (fi->fib_nhs != nfi->fib_nhs)\r\ncontinue;\r\nif (nfi->fib_protocol == fi->fib_protocol &&\r\nnfi->fib_prefsrc == fi->fib_prefsrc &&\r\nnfi->fib_priority == fi->fib_priority &&\r\nmemcmp(nfi->fib_metrics, fi->fib_metrics, sizeof(fi->fib_metrics)) == 0 &&\r\n((nfi->fib_flags^fi->fib_flags)&~RTNH_F_DEAD) == 0 &&\r\n(nfi->fib_nhs == 0 || dn_fib_nh_comp(fi, nfi) == 0))\r\nreturn fi;\r\n} endfor_fib_info();\r\nreturn NULL;\r\n}\r\n__le16 dn_fib_get_attr16(struct rtattr *attr, int attrlen, int type)\r\n{\r\nwhile(RTA_OK(attr,attrlen)) {\r\nif (attr->rta_type == type)\r\nreturn *(__le16*)RTA_DATA(attr);\r\nattr = RTA_NEXT(attr, attrlen);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dn_fib_count_nhs(struct rtattr *rta)\r\n{\r\nint nhs = 0;\r\nstruct rtnexthop *nhp = RTA_DATA(rta);\r\nint nhlen = RTA_PAYLOAD(rta);\r\nwhile(nhlen >= (int)sizeof(struct rtnexthop)) {\r\nif ((nhlen -= nhp->rtnh_len) < 0)\r\nreturn 0;\r\nnhs++;\r\nnhp = RTNH_NEXT(nhp);\r\n}\r\nreturn nhs;\r\n}\r\nstatic int dn_fib_get_nhs(struct dn_fib_info *fi, const struct rtattr *rta, const struct rtmsg *r)\r\n{\r\nstruct rtnexthop *nhp = RTA_DATA(rta);\r\nint nhlen = RTA_PAYLOAD(rta);\r\nchange_nexthops(fi) {\r\nint attrlen = nhlen - sizeof(struct rtnexthop);\r\nif (attrlen < 0 || (nhlen -= nhp->rtnh_len) < 0)\r\nreturn -EINVAL;\r\nnh->nh_flags = (r->rtm_flags&~0xFF) | nhp->rtnh_flags;\r\nnh->nh_oif = nhp->rtnh_ifindex;\r\nnh->nh_weight = nhp->rtnh_hops + 1;\r\nif (attrlen) {\r\nnh->nh_gw = dn_fib_get_attr16(RTNH_DATA(nhp), attrlen, RTA_GATEWAY);\r\n}\r\nnhp = RTNH_NEXT(nhp);\r\n} endfor_nexthops(fi);\r\nreturn 0;\r\n}\r\nstatic int dn_fib_check_nh(const struct rtmsg *r, struct dn_fib_info *fi, struct dn_fib_nh *nh)\r\n{\r\nint err;\r\nif (nh->nh_gw) {\r\nstruct flowidn fld;\r\nstruct dn_fib_res res;\r\nif (nh->nh_flags&RTNH_F_ONLINK) {\r\nstruct net_device *dev;\r\nif (r->rtm_scope >= RT_SCOPE_LINK)\r\nreturn -EINVAL;\r\nif (dnet_addr_type(nh->nh_gw) != RTN_UNICAST)\r\nreturn -EINVAL;\r\nif ((dev = __dev_get_by_index(&init_net, nh->nh_oif)) == NULL)\r\nreturn -ENODEV;\r\nif (!(dev->flags&IFF_UP))\r\nreturn -ENETDOWN;\r\nnh->nh_dev = dev;\r\ndev_hold(dev);\r\nnh->nh_scope = RT_SCOPE_LINK;\r\nreturn 0;\r\n}\r\nmemset(&fld, 0, sizeof(fld));\r\nfld.daddr = nh->nh_gw;\r\nfld.flowidn_oif = nh->nh_oif;\r\nfld.flowidn_scope = r->rtm_scope + 1;\r\nif (fld.flowidn_scope < RT_SCOPE_LINK)\r\nfld.flowidn_scope = RT_SCOPE_LINK;\r\nif ((err = dn_fib_lookup(&fld, &res)) != 0)\r\nreturn err;\r\nerr = -EINVAL;\r\nif (res.type != RTN_UNICAST && res.type != RTN_LOCAL)\r\ngoto out;\r\nnh->nh_scope = res.scope;\r\nnh->nh_oif = DN_FIB_RES_OIF(res);\r\nnh->nh_dev = DN_FIB_RES_DEV(res);\r\nif (nh->nh_dev == NULL)\r\ngoto out;\r\ndev_hold(nh->nh_dev);\r\nerr = -ENETDOWN;\r\nif (!(nh->nh_dev->flags & IFF_UP))\r\ngoto out;\r\nerr = 0;\r\nout:\r\ndn_fib_res_put(&res);\r\nreturn err;\r\n} else {\r\nstruct net_device *dev;\r\nif (nh->nh_flags&(RTNH_F_PERVASIVE|RTNH_F_ONLINK))\r\nreturn -EINVAL;\r\ndev = __dev_get_by_index(&init_net, nh->nh_oif);\r\nif (dev == NULL || dev->dn_ptr == NULL)\r\nreturn -ENODEV;\r\nif (!(dev->flags&IFF_UP))\r\nreturn -ENETDOWN;\r\nnh->nh_dev = dev;\r\ndev_hold(nh->nh_dev);\r\nnh->nh_scope = RT_SCOPE_HOST;\r\n}\r\nreturn 0;\r\n}\r\nstruct dn_fib_info *dn_fib_create_info(const struct rtmsg *r, struct dn_kern_rta *rta, const struct nlmsghdr *nlh, int *errp)\r\n{\r\nint err;\r\nstruct dn_fib_info *fi = NULL;\r\nstruct dn_fib_info *ofi;\r\nint nhs = 1;\r\nif (r->rtm_type > RTN_MAX)\r\ngoto err_inval;\r\nif (dn_fib_props[r->rtm_type].scope > r->rtm_scope)\r\ngoto err_inval;\r\nif (rta->rta_mp) {\r\nnhs = dn_fib_count_nhs(rta->rta_mp);\r\nif (nhs == 0)\r\ngoto err_inval;\r\n}\r\nfi = kzalloc(sizeof(*fi)+nhs*sizeof(struct dn_fib_nh), GFP_KERNEL);\r\nerr = -ENOBUFS;\r\nif (fi == NULL)\r\ngoto failure;\r\nfi->fib_protocol = r->rtm_protocol;\r\nfi->fib_nhs = nhs;\r\nfi->fib_flags = r->rtm_flags;\r\nif (rta->rta_priority)\r\nfi->fib_priority = *rta->rta_priority;\r\nif (rta->rta_mx) {\r\nint attrlen = RTA_PAYLOAD(rta->rta_mx);\r\nstruct rtattr *attr = RTA_DATA(rta->rta_mx);\r\nwhile(RTA_OK(attr, attrlen)) {\r\nunsigned int flavour = attr->rta_type;\r\nif (flavour) {\r\nif (flavour > RTAX_MAX)\r\ngoto err_inval;\r\nfi->fib_metrics[flavour-1] = *(unsigned int *)RTA_DATA(attr);\r\n}\r\nattr = RTA_NEXT(attr, attrlen);\r\n}\r\n}\r\nif (rta->rta_prefsrc)\r\nmemcpy(&fi->fib_prefsrc, rta->rta_prefsrc, 2);\r\nif (rta->rta_mp) {\r\nif ((err = dn_fib_get_nhs(fi, rta->rta_mp, r)) != 0)\r\ngoto failure;\r\nif (rta->rta_oif && fi->fib_nh->nh_oif != *rta->rta_oif)\r\ngoto err_inval;\r\nif (rta->rta_gw && memcmp(&fi->fib_nh->nh_gw, rta->rta_gw, 2))\r\ngoto err_inval;\r\n} else {\r\nstruct dn_fib_nh *nh = fi->fib_nh;\r\nif (rta->rta_oif)\r\nnh->nh_oif = *rta->rta_oif;\r\nif (rta->rta_gw)\r\nmemcpy(&nh->nh_gw, rta->rta_gw, 2);\r\nnh->nh_flags = r->rtm_flags;\r\nnh->nh_weight = 1;\r\n}\r\nif (r->rtm_type == RTN_NAT) {\r\nif (rta->rta_gw == NULL || nhs != 1 || rta->rta_oif)\r\ngoto err_inval;\r\nmemcpy(&fi->fib_nh->nh_gw, rta->rta_gw, 2);\r\ngoto link_it;\r\n}\r\nif (dn_fib_props[r->rtm_type].error) {\r\nif (rta->rta_gw || rta->rta_oif || rta->rta_mp)\r\ngoto err_inval;\r\ngoto link_it;\r\n}\r\nif (r->rtm_scope > RT_SCOPE_HOST)\r\ngoto err_inval;\r\nif (r->rtm_scope == RT_SCOPE_HOST) {\r\nstruct dn_fib_nh *nh = fi->fib_nh;\r\nif (nhs != 1 || nh->nh_gw)\r\ngoto err_inval;\r\nnh->nh_scope = RT_SCOPE_NOWHERE;\r\nnh->nh_dev = dev_get_by_index(&init_net, fi->fib_nh->nh_oif);\r\nerr = -ENODEV;\r\nif (nh->nh_dev == NULL)\r\ngoto failure;\r\n} else {\r\nchange_nexthops(fi) {\r\nif ((err = dn_fib_check_nh(r, fi, nh)) != 0)\r\ngoto failure;\r\n} endfor_nexthops(fi)\r\n}\r\nif (fi->fib_prefsrc) {\r\nif (r->rtm_type != RTN_LOCAL || rta->rta_dst == NULL ||\r\nmemcmp(&fi->fib_prefsrc, rta->rta_dst, 2))\r\nif (dnet_addr_type(fi->fib_prefsrc) != RTN_LOCAL)\r\ngoto err_inval;\r\n}\r\nlink_it:\r\nif ((ofi = dn_fib_find_info(fi)) != NULL) {\r\nfi->fib_dead = 1;\r\ndn_fib_free_info(fi);\r\nofi->fib_treeref++;\r\nreturn ofi;\r\n}\r\nfi->fib_treeref++;\r\natomic_inc(&fi->fib_clntref);\r\nspin_lock(&dn_fib_info_lock);\r\nfi->fib_next = dn_fib_info_list;\r\nfi->fib_prev = NULL;\r\nif (dn_fib_info_list)\r\ndn_fib_info_list->fib_prev = fi;\r\ndn_fib_info_list = fi;\r\nspin_unlock(&dn_fib_info_lock);\r\nreturn fi;\r\nerr_inval:\r\nerr = -EINVAL;\r\nfailure:\r\n*errp = err;\r\nif (fi) {\r\nfi->fib_dead = 1;\r\ndn_fib_free_info(fi);\r\n}\r\nreturn NULL;\r\n}\r\nint dn_fib_semantic_match(int type, struct dn_fib_info *fi, const struct flowidn *fld, struct dn_fib_res *res)\r\n{\r\nint err = dn_fib_props[type].error;\r\nif (err == 0) {\r\nif (fi->fib_flags & RTNH_F_DEAD)\r\nreturn 1;\r\nres->fi = fi;\r\nswitch (type) {\r\ncase RTN_NAT:\r\nDN_FIB_RES_RESET(*res);\r\natomic_inc(&fi->fib_clntref);\r\nreturn 0;\r\ncase RTN_UNICAST:\r\ncase RTN_LOCAL:\r\nfor_nexthops(fi) {\r\nif (nh->nh_flags & RTNH_F_DEAD)\r\ncontinue;\r\nif (!fld->flowidn_oif ||\r\nfld->flowidn_oif == nh->nh_oif)\r\nbreak;\r\n}\r\nif (nhsel < fi->fib_nhs) {\r\nres->nh_sel = nhsel;\r\natomic_inc(&fi->fib_clntref);\r\nreturn 0;\r\n}\r\nendfor_nexthops(fi);\r\nres->fi = NULL;\r\nreturn 1;\r\ndefault:\r\nnet_err_ratelimited("DECnet: impossible routing event : dn_fib_semantic_match type=%d\n",\r\ntype);\r\nres->fi = NULL;\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn err;\r\n}\r\nvoid dn_fib_select_multipath(const struct flowidn *fld, struct dn_fib_res *res)\r\n{\r\nstruct dn_fib_info *fi = res->fi;\r\nint w;\r\nspin_lock_bh(&dn_fib_multipath_lock);\r\nif (fi->fib_power <= 0) {\r\nint power = 0;\r\nchange_nexthops(fi) {\r\nif (!(nh->nh_flags&RTNH_F_DEAD)) {\r\npower += nh->nh_weight;\r\nnh->nh_power = nh->nh_weight;\r\n}\r\n} endfor_nexthops(fi);\r\nfi->fib_power = power;\r\nif (power < 0) {\r\nspin_unlock_bh(&dn_fib_multipath_lock);\r\nres->nh_sel = 0;\r\nreturn;\r\n}\r\n}\r\nw = jiffies % fi->fib_power;\r\nchange_nexthops(fi) {\r\nif (!(nh->nh_flags&RTNH_F_DEAD) && nh->nh_power) {\r\nif ((w -= nh->nh_power) <= 0) {\r\nnh->nh_power--;\r\nfi->fib_power--;\r\nres->nh_sel = nhsel;\r\nspin_unlock_bh(&dn_fib_multipath_lock);\r\nreturn;\r\n}\r\n}\r\n} endfor_nexthops(fi);\r\nres->nh_sel = 0;\r\nspin_unlock_bh(&dn_fib_multipath_lock);\r\n}\r\nstatic int dn_fib_check_attr(struct rtmsg *r, struct rtattr **rta)\r\n{\r\nint i;\r\nfor(i = 1; i <= RTA_MAX; i++) {\r\nstruct rtattr *attr = rta[i-1];\r\nif (attr) {\r\nif (RTA_PAYLOAD(attr) < 4 && RTA_PAYLOAD(attr) != 2)\r\nreturn -EINVAL;\r\nif (i != RTA_MULTIPATH && i != RTA_METRICS &&\r\ni != RTA_TABLE)\r\nrta[i-1] = (struct rtattr *)RTA_DATA(attr);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u32 rtm_get_table(struct rtattr **rta, u8 table)\r\n{\r\nif (rta[RTA_TABLE - 1])\r\ntable = nla_get_u32((struct nlattr *) rta[RTA_TABLE - 1]);\r\nreturn table;\r\n}\r\nstatic int dn_fib_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct dn_fib_table *tb;\r\nstruct rtattr **rta = arg;\r\nstruct rtmsg *r = NLMSG_DATA(nlh);\r\nif (!net_eq(net, &init_net))\r\nreturn -EINVAL;\r\nif (dn_fib_check_attr(r, rta))\r\nreturn -EINVAL;\r\ntb = dn_fib_get_table(rtm_get_table(rta, r->rtm_table), 0);\r\nif (tb)\r\nreturn tb->delete(tb, r, (struct dn_kern_rta *)rta, nlh, &NETLINK_CB(skb));\r\nreturn -ESRCH;\r\n}\r\nstatic int dn_fib_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct dn_fib_table *tb;\r\nstruct rtattr **rta = arg;\r\nstruct rtmsg *r = NLMSG_DATA(nlh);\r\nif (!net_eq(net, &init_net))\r\nreturn -EINVAL;\r\nif (dn_fib_check_attr(r, rta))\r\nreturn -EINVAL;\r\ntb = dn_fib_get_table(rtm_get_table(rta, r->rtm_table), 1);\r\nif (tb)\r\nreturn tb->insert(tb, r, (struct dn_kern_rta *)rta, nlh, &NETLINK_CB(skb));\r\nreturn -ENOBUFS;\r\n}\r\nstatic void fib_magic(int cmd, int type, __le16 dst, int dst_len, struct dn_ifaddr *ifa)\r\n{\r\nstruct dn_fib_table *tb;\r\nstruct {\r\nstruct nlmsghdr nlh;\r\nstruct rtmsg rtm;\r\n} req;\r\nstruct dn_kern_rta rta;\r\nmemset(&req.rtm, 0, sizeof(req.rtm));\r\nmemset(&rta, 0, sizeof(rta));\r\nif (type == RTN_UNICAST)\r\ntb = dn_fib_get_table(RT_MIN_TABLE, 1);\r\nelse\r\ntb = dn_fib_get_table(RT_TABLE_LOCAL, 1);\r\nif (tb == NULL)\r\nreturn;\r\nreq.nlh.nlmsg_len = sizeof(req);\r\nreq.nlh.nlmsg_type = cmd;\r\nreq.nlh.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_APPEND;\r\nreq.nlh.nlmsg_pid = 0;\r\nreq.nlh.nlmsg_seq = 0;\r\nreq.rtm.rtm_dst_len = dst_len;\r\nreq.rtm.rtm_table = tb->n;\r\nreq.rtm.rtm_protocol = RTPROT_KERNEL;\r\nreq.rtm.rtm_scope = (type != RTN_LOCAL ? RT_SCOPE_LINK : RT_SCOPE_HOST);\r\nreq.rtm.rtm_type = type;\r\nrta.rta_dst = &dst;\r\nrta.rta_prefsrc = &ifa->ifa_local;\r\nrta.rta_oif = &ifa->ifa_dev->dev->ifindex;\r\nif (cmd == RTM_NEWROUTE)\r\ntb->insert(tb, &req.rtm, &rta, &req.nlh, NULL);\r\nelse\r\ntb->delete(tb, &req.rtm, &rta, &req.nlh, NULL);\r\n}\r\nstatic void dn_fib_add_ifaddr(struct dn_ifaddr *ifa)\r\n{\r\nfib_magic(RTM_NEWROUTE, RTN_LOCAL, ifa->ifa_local, 16, ifa);\r\n#if 0\r\nif (!(dev->flags&IFF_UP))\r\nreturn;\r\n#endif\r\n}\r\nstatic void dn_fib_del_ifaddr(struct dn_ifaddr *ifa)\r\n{\r\nint found_it = 0;\r\nstruct net_device *dev;\r\nstruct dn_dev *dn_db;\r\nstruct dn_ifaddr *ifa2;\r\nASSERT_RTNL();\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(&init_net, dev) {\r\ndn_db = rcu_dereference(dev->dn_ptr);\r\nif (dn_db == NULL)\r\ncontinue;\r\nfor (ifa2 = rcu_dereference(dn_db->ifa_list);\r\nifa2 != NULL;\r\nifa2 = rcu_dereference(ifa2->ifa_next)) {\r\nif (ifa2->ifa_local == ifa->ifa_local) {\r\nfound_it = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (found_it == 0) {\r\nfib_magic(RTM_DELROUTE, RTN_LOCAL, ifa->ifa_local, 16, ifa);\r\nif (dnet_addr_type(ifa->ifa_local) != RTN_LOCAL) {\r\nif (dn_fib_sync_down(ifa->ifa_local, NULL, 0))\r\ndn_fib_flush();\r\n}\r\n}\r\n}\r\nstatic void dn_fib_disable_addr(struct net_device *dev, int force)\r\n{\r\nif (dn_fib_sync_down(0, dev, force))\r\ndn_fib_flush();\r\ndn_rt_cache_flush(0);\r\nneigh_ifdown(&dn_neigh_table, dev);\r\n}\r\nstatic int dn_fib_dnaddr_event(struct notifier_block *this, unsigned long event, void *ptr)\r\n{\r\nstruct dn_ifaddr *ifa = (struct dn_ifaddr *)ptr;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\ndn_fib_add_ifaddr(ifa);\r\ndn_fib_sync_up(ifa->ifa_dev->dev);\r\ndn_rt_cache_flush(-1);\r\nbreak;\r\ncase NETDEV_DOWN:\r\ndn_fib_del_ifaddr(ifa);\r\nif (ifa->ifa_dev && ifa->ifa_dev->ifa_list == NULL) {\r\ndn_fib_disable_addr(ifa->ifa_dev->dev, 1);\r\n} else {\r\ndn_rt_cache_flush(-1);\r\n}\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int dn_fib_sync_down(__le16 local, struct net_device *dev, int force)\r\n{\r\nint ret = 0;\r\nint scope = RT_SCOPE_NOWHERE;\r\nif (force)\r\nscope = -1;\r\nfor_fib_info() {\r\nif (local && fi->fib_prefsrc == local) {\r\nfi->fib_flags |= RTNH_F_DEAD;\r\nret++;\r\n} else if (dev && fi->fib_nhs) {\r\nint dead = 0;\r\nchange_nexthops(fi) {\r\nif (nh->nh_flags&RTNH_F_DEAD)\r\ndead++;\r\nelse if (nh->nh_dev == dev &&\r\nnh->nh_scope != scope) {\r\nspin_lock_bh(&dn_fib_multipath_lock);\r\nnh->nh_flags |= RTNH_F_DEAD;\r\nfi->fib_power -= nh->nh_power;\r\nnh->nh_power = 0;\r\nspin_unlock_bh(&dn_fib_multipath_lock);\r\ndead++;\r\n}\r\n} endfor_nexthops(fi)\r\nif (dead == fi->fib_nhs) {\r\nfi->fib_flags |= RTNH_F_DEAD;\r\nret++;\r\n}\r\n}\r\n} endfor_fib_info();\r\nreturn ret;\r\n}\r\nstatic int dn_fib_sync_up(struct net_device *dev)\r\n{\r\nint ret = 0;\r\nif (!(dev->flags&IFF_UP))\r\nreturn 0;\r\nfor_fib_info() {\r\nint alive = 0;\r\nchange_nexthops(fi) {\r\nif (!(nh->nh_flags&RTNH_F_DEAD)) {\r\nalive++;\r\ncontinue;\r\n}\r\nif (nh->nh_dev == NULL || !(nh->nh_dev->flags&IFF_UP))\r\ncontinue;\r\nif (nh->nh_dev != dev || dev->dn_ptr == NULL)\r\ncontinue;\r\nalive++;\r\nspin_lock_bh(&dn_fib_multipath_lock);\r\nnh->nh_power = 0;\r\nnh->nh_flags &= ~RTNH_F_DEAD;\r\nspin_unlock_bh(&dn_fib_multipath_lock);\r\n} endfor_nexthops(fi);\r\nif (alive > 0) {\r\nfi->fib_flags &= ~RTNH_F_DEAD;\r\nret++;\r\n}\r\n} endfor_fib_info();\r\nreturn ret;\r\n}\r\nvoid __exit dn_fib_cleanup(void)\r\n{\r\ndn_fib_table_cleanup();\r\ndn_fib_rules_cleanup();\r\nunregister_dnaddr_notifier(&dn_fib_dnaddr_notifier);\r\n}\r\nvoid __init dn_fib_init(void)\r\n{\r\ndn_fib_table_init();\r\ndn_fib_rules_init();\r\nregister_dnaddr_notifier(&dn_fib_dnaddr_notifier);\r\nrtnl_register(PF_DECnet, RTM_NEWROUTE, dn_fib_rtm_newroute, NULL, NULL);\r\nrtnl_register(PF_DECnet, RTM_DELROUTE, dn_fib_rtm_delroute, NULL, NULL);\r\n}
