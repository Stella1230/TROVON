static inline int redboot_checksum(struct fis_image_desc *img)\r\n{\r\nreturn 1;\r\n}\r\nstatic int parse_redboot_partitions(struct mtd_info *master,\r\nstruct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nint nrparts = 0;\r\nstruct fis_image_desc *buf;\r\nstruct mtd_partition *parts;\r\nstruct fis_list *fl = NULL, *tmp_fl;\r\nint ret, i;\r\nsize_t retlen;\r\nchar *names;\r\nchar *nullname;\r\nint namelen = 0;\r\nint nulllen = 0;\r\nint numslots;\r\nunsigned long offset;\r\n#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED\r\nstatic char nullstring[] = "unallocated";\r\n#endif\r\nif ( directory < 0 ) {\r\noffset = master->size + directory * master->erasesize;\r\nwhile (mtd_block_isbad(master, offset)) {\r\nif (!offset) {\r\nnogood:\r\nprintk(KERN_NOTICE "Failed to find a non-bad block to check for RedBoot partition table\n");\r\nreturn -EIO;\r\n}\r\noffset -= master->erasesize;\r\n}\r\n} else {\r\noffset = directory * master->erasesize;\r\nwhile (mtd_block_isbad(master, offset)) {\r\noffset += master->erasesize;\r\nif (offset == master->size)\r\ngoto nogood;\r\n}\r\n}\r\nbuf = vmalloc(master->erasesize);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nprintk(KERN_NOTICE "Searching for RedBoot partition table in %s at offset 0x%lx\n",\r\nmaster->name, offset);\r\nret = mtd_read(master, offset, master->erasesize, &retlen,\r\n(void *)buf);\r\nif (ret)\r\ngoto out;\r\nif (retlen != master->erasesize) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nnumslots = (master->erasesize / sizeof(struct fis_image_desc));\r\nfor (i = 0; i < numslots; i++) {\r\nif (!memcmp(buf[i].name, "FIS directory", 14)) {\r\nif (swab32(buf[i].size) == master->erasesize ||\r\n(buf[i].size > master->erasesize\r\n&& swab32(buf[i].size) < master->erasesize)) {\r\nint j;\r\nnumslots = swab32(buf[i].size) / sizeof (struct fis_image_desc);\r\nfor (j = 0; j < numslots; ++j) {\r\nif (buf[j].name[0] == 0xff) {\r\nif (buf[j].name[1] == 0xff) {\r\nbreak;\r\n} else {\r\ncontinue;\r\n}\r\n}\r\nswab32s(&buf[j].flash_base);\r\nswab32s(&buf[j].mem_base);\r\nswab32s(&buf[j].size);\r\nswab32s(&buf[j].entry_point);\r\nswab32s(&buf[j].data_length);\r\nswab32s(&buf[j].desc_cksum);\r\nswab32s(&buf[j].file_cksum);\r\n}\r\n} else if (buf[i].size < master->erasesize) {\r\nnumslots = buf[i].size / sizeof(struct fis_image_desc);\r\n}\r\nbreak;\r\n}\r\n}\r\nif (i == numslots) {\r\nprintk(KERN_NOTICE "No RedBoot partition table detected in %s\n",\r\nmaster->name);\r\nret = 0;\r\ngoto out;\r\n}\r\nfor (i = 0; i < numslots; i++) {\r\nstruct fis_list *new_fl, **prev;\r\nif (buf[i].name[0] == 0xff) {\r\nif (buf[i].name[1] == 0xff) {\r\nbreak;\r\n} else {\r\ncontinue;\r\n}\r\n}\r\nif (!redboot_checksum(&buf[i]))\r\nbreak;\r\nnew_fl = kmalloc(sizeof(struct fis_list), GFP_KERNEL);\r\nnamelen += strlen(buf[i].name)+1;\r\nif (!new_fl) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nnew_fl->img = &buf[i];\r\nif (data && data->origin)\r\nbuf[i].flash_base -= data->origin;\r\nelse\r\nbuf[i].flash_base &= master->size-1;\r\nprev = &fl;\r\nwhile(*prev && (*prev)->img->flash_base < new_fl->img->flash_base)\r\nprev = &(*prev)->next;\r\nnew_fl->next = *prev;\r\n*prev = new_fl;\r\nnrparts++;\r\n}\r\n#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED\r\nif (fl->img->flash_base) {\r\nnrparts++;\r\nnulllen = sizeof(nullstring);\r\n}\r\nfor (tmp_fl = fl; tmp_fl->next; tmp_fl = tmp_fl->next) {\r\nif (tmp_fl->img->flash_base + tmp_fl->img->size + master->erasesize <= tmp_fl->next->img->flash_base) {\r\nnrparts++;\r\nnulllen = sizeof(nullstring);\r\n}\r\n}\r\n#endif\r\nparts = kzalloc(sizeof(*parts)*nrparts + nulllen + namelen, GFP_KERNEL);\r\nif (!parts) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nnullname = (char *)&parts[nrparts];\r\n#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED\r\nif (nulllen > 0) {\r\nstrcpy(nullname, nullstring);\r\n}\r\n#endif\r\nnames = nullname + nulllen;\r\ni=0;\r\n#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED\r\nif (fl->img->flash_base) {\r\nparts[0].name = nullname;\r\nparts[0].size = fl->img->flash_base;\r\nparts[0].offset = 0;\r\ni++;\r\n}\r\n#endif\r\nfor ( ; i<nrparts; i++) {\r\nparts[i].size = fl->img->size;\r\nparts[i].offset = fl->img->flash_base;\r\nparts[i].name = names;\r\nstrcpy(names, fl->img->name);\r\n#ifdef CONFIG_MTD_REDBOOT_PARTS_READONLY\r\nif (!memcmp(names, "RedBoot", 8) ||\r\n!memcmp(names, "RedBoot config", 15) ||\r\n!memcmp(names, "FIS directory", 14)) {\r\nparts[i].mask_flags = MTD_WRITEABLE;\r\n}\r\n#endif\r\nnames += strlen(names)+1;\r\n#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED\r\nif(fl->next && fl->img->flash_base + fl->img->size + master->erasesize <= fl->next->img->flash_base) {\r\ni++;\r\nparts[i].offset = parts[i-1].size + parts[i-1].offset;\r\nparts[i].size = fl->next->img->flash_base - parts[i].offset;\r\nparts[i].name = nullname;\r\n}\r\n#endif\r\ntmp_fl = fl;\r\nfl = fl->next;\r\nkfree(tmp_fl);\r\n}\r\nret = nrparts;\r\n*pparts = parts;\r\nout:\r\nwhile (fl) {\r\nstruct fis_list *old = fl;\r\nfl = fl->next;\r\nkfree(old);\r\n}\r\nvfree(buf);\r\nreturn ret;\r\n}\r\nstatic int __init redboot_parser_init(void)\r\n{\r\nreturn register_mtd_parser(&redboot_parser);\r\n}\r\nstatic void __exit redboot_parser_exit(void)\r\n{\r\nderegister_mtd_parser(&redboot_parser);\r\n}
