static void tp_init(adapter_t * ap, const struct tp_params *p,\r\nunsigned int tp_clk)\r\n{\r\nu32 val;\r\nif (!t1_is_asic(ap))\r\nreturn;\r\nval = F_TP_IN_CSPI_CPL | F_TP_IN_CSPI_CHECK_IP_CSUM |\r\nF_TP_IN_CSPI_CHECK_TCP_CSUM | F_TP_IN_ESPI_ETHERNET;\r\nif (!p->pm_size)\r\nval |= F_OFFLOAD_DISABLE;\r\nelse\r\nval |= F_TP_IN_ESPI_CHECK_IP_CSUM | F_TP_IN_ESPI_CHECK_TCP_CSUM;\r\nwritel(val, ap->regs + A_TP_IN_CONFIG);\r\nwritel(F_TP_OUT_CSPI_CPL |\r\nF_TP_OUT_ESPI_ETHERNET |\r\nF_TP_OUT_ESPI_GENERATE_IP_CSUM |\r\nF_TP_OUT_ESPI_GENERATE_TCP_CSUM, ap->regs + A_TP_OUT_CONFIG);\r\nwritel(V_IP_TTL(64) |\r\nF_PATH_MTU |\r\nV_5TUPLE_LOOKUP(p->use_5tuple_mode) |\r\nV_SYN_COOKIE_PARAMETER(29), ap->regs + A_TP_GLOBAL_CONFIG);\r\nif (is_T2(ap) && ap->params.nports > 1) {\r\nu32 drop_ticks = DROP_MSEC * (tp_clk / 1000);\r\nwritel(F_ENABLE_TX_DROP | F_ENABLE_TX_ERROR |\r\nV_DROP_TICKS_CNT(drop_ticks) |\r\nV_NUM_PKTS_DROPPED(DROP_PKTS_CNT),\r\nap->regs + A_TP_TX_DROP_CONFIG);\r\n}\r\n}\r\nvoid t1_tp_destroy(struct petp *tp)\r\n{\r\nkfree(tp);\r\n}\r\nstruct petp *__devinit t1_tp_create(adapter_t * adapter, struct tp_params *p)\r\n{\r\nstruct petp *tp = kzalloc(sizeof(*tp), GFP_KERNEL);\r\nif (!tp)\r\nreturn NULL;\r\ntp->adapter = adapter;\r\nreturn tp;\r\n}\r\nvoid t1_tp_intr_enable(struct petp *tp)\r\n{\r\nu32 tp_intr = readl(tp->adapter->regs + A_PL_ENABLE);\r\n#ifdef CONFIG_CHELSIO_T1_1G\r\nif (!t1_is_asic(tp->adapter)) {\r\nwritel(0xffffffff,\r\ntp->adapter->regs + FPGA_TP_ADDR_INTERRUPT_ENABLE);\r\nwritel(tp_intr | FPGA_PCIX_INTERRUPT_TP,\r\ntp->adapter->regs + A_PL_ENABLE);\r\n} else\r\n#endif\r\n{\r\nwritel(0, tp->adapter->regs + A_TP_INT_ENABLE);\r\nwritel(tp_intr | F_PL_INTR_TP,\r\ntp->adapter->regs + A_PL_ENABLE);\r\n}\r\n}\r\nvoid t1_tp_intr_disable(struct petp *tp)\r\n{\r\nu32 tp_intr = readl(tp->adapter->regs + A_PL_ENABLE);\r\n#ifdef CONFIG_CHELSIO_T1_1G\r\nif (!t1_is_asic(tp->adapter)) {\r\nwritel(0, tp->adapter->regs + FPGA_TP_ADDR_INTERRUPT_ENABLE);\r\nwritel(tp_intr & ~FPGA_PCIX_INTERRUPT_TP,\r\ntp->adapter->regs + A_PL_ENABLE);\r\n} else\r\n#endif\r\n{\r\nwritel(0, tp->adapter->regs + A_TP_INT_ENABLE);\r\nwritel(tp_intr & ~F_PL_INTR_TP,\r\ntp->adapter->regs + A_PL_ENABLE);\r\n}\r\n}\r\nvoid t1_tp_intr_clear(struct petp *tp)\r\n{\r\n#ifdef CONFIG_CHELSIO_T1_1G\r\nif (!t1_is_asic(tp->adapter)) {\r\nwritel(0xffffffff,\r\ntp->adapter->regs + FPGA_TP_ADDR_INTERRUPT_CAUSE);\r\nwritel(FPGA_PCIX_INTERRUPT_TP, tp->adapter->regs + A_PL_CAUSE);\r\nreturn;\r\n}\r\n#endif\r\nwritel(0xffffffff, tp->adapter->regs + A_TP_INT_CAUSE);\r\nwritel(F_PL_INTR_TP, tp->adapter->regs + A_PL_CAUSE);\r\n}\r\nint t1_tp_intr_handler(struct petp *tp)\r\n{\r\nu32 cause;\r\n#ifdef CONFIG_CHELSIO_T1_1G\r\nif (!t1_is_asic(tp->adapter))\r\nreturn 1;\r\n#endif\r\ncause = readl(tp->adapter->regs + A_TP_INT_CAUSE);\r\nwritel(cause, tp->adapter->regs + A_TP_INT_CAUSE);\r\nreturn 0;\r\n}\r\nstatic void set_csum_offload(struct petp *tp, u32 csum_bit, int enable)\r\n{\r\nu32 val = readl(tp->adapter->regs + A_TP_GLOBAL_CONFIG);\r\nif (enable)\r\nval |= csum_bit;\r\nelse\r\nval &= ~csum_bit;\r\nwritel(val, tp->adapter->regs + A_TP_GLOBAL_CONFIG);\r\n}\r\nvoid t1_tp_set_ip_checksum_offload(struct petp *tp, int enable)\r\n{\r\nset_csum_offload(tp, F_IP_CSUM, enable);\r\n}\r\nvoid t1_tp_set_tcp_checksum_offload(struct petp *tp, int enable)\r\n{\r\nset_csum_offload(tp, F_TCP_CSUM, enable);\r\n}\r\nint t1_tp_reset(struct petp *tp, struct tp_params *p, unsigned int tp_clk)\r\n{\r\nadapter_t *adapter = tp->adapter;\r\ntp_init(adapter, p, tp_clk);\r\nwritel(F_TP_RESET, adapter->regs + A_TP_RESET);\r\nreturn 0;\r\n}
