static int ad5421_write_unlocked(struct iio_dev *indio_dev,\r\nunsigned int reg, unsigned int val)\r\n{\r\nstruct ad5421_state *st = iio_priv(indio_dev);\r\nst->data[0].d32 = cpu_to_be32((reg << 16) | val);\r\nreturn spi_write(st->spi, &st->data[0].d8[1], 3);\r\n}\r\nstatic int ad5421_write(struct iio_dev *indio_dev, unsigned int reg,\r\nunsigned int val)\r\n{\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nret = ad5421_write_unlocked(indio_dev, reg, val);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5421_read(struct iio_dev *indio_dev, unsigned int reg)\r\n{\r\nstruct ad5421_state *st = iio_priv(indio_dev);\r\nstruct spi_message m;\r\nint ret;\r\nstruct spi_transfer t[] = {\r\n{\r\n.tx_buf = &st->data[0].d8[1],\r\n.len = 3,\r\n.cs_change = 1,\r\n}, {\r\n.rx_buf = &st->data[1].d8[1],\r\n.len = 3,\r\n},\r\n};\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t[0], &m);\r\nspi_message_add_tail(&t[1], &m);\r\nmutex_lock(&indio_dev->mlock);\r\nst->data[0].d32 = cpu_to_be32((1 << 23) | (reg << 16));\r\nret = spi_sync(st->spi, &m);\r\nif (ret >= 0)\r\nret = be32_to_cpu(st->data[1].d32) & 0xffff;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5421_update_ctrl(struct iio_dev *indio_dev, unsigned int set,\r\nunsigned int clr)\r\n{\r\nstruct ad5421_state *st = iio_priv(indio_dev);\r\nunsigned int ret;\r\nmutex_lock(&indio_dev->mlock);\r\nst->ctrl &= ~clr;\r\nst->ctrl |= set;\r\nret = ad5421_write_unlocked(indio_dev, AD5421_REG_CTRL, st->ctrl);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t ad5421_fault_handler(int irq, void *data)\r\n{\r\nstruct iio_dev *indio_dev = data;\r\nstruct ad5421_state *st = iio_priv(indio_dev);\r\nunsigned int fault;\r\nunsigned int old_fault = 0;\r\nunsigned int events;\r\nfault = ad5421_read(indio_dev, AD5421_REG_FAULT);\r\nif (!fault)\r\nreturn IRQ_NONE;\r\nad5421_update_ctrl(indio_dev, 0, 0);\r\ndo {\r\nif (fault == 0xffff)\r\nfault = 0;\r\nevents = (old_fault ^ fault) & fault;\r\nevents &= st->fault_mask;\r\nif (events & AD5421_FAULT_OVER_CURRENT) {\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_CURRENT,\r\n0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\niio_get_time_ns());\r\n}\r\nif (events & AD5421_FAULT_UNDER_CURRENT) {\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_CURRENT,\r\n0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\niio_get_time_ns());\r\n}\r\nif (events & AD5421_FAULT_TEMP_OVER_140) {\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_TEMP,\r\n0,\r\nIIO_EV_TYPE_MAG,\r\nIIO_EV_DIR_RISING),\r\niio_get_time_ns());\r\n}\r\nold_fault = fault;\r\nfault = ad5421_read(indio_dev, AD5421_REG_FAULT);\r\nif (fault & AD5421_FAULT_TRIGGER_IRQ)\r\nmsleep(1000);\r\n} while (fault & AD5421_FAULT_TRIGGER_IRQ);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ad5421_get_current_min_max(struct ad5421_state *st,\r\nunsigned int *min, unsigned int *max)\r\n{\r\nswitch (st->current_range) {\r\ncase AD5421_CURRENT_RANGE_4mA_20mA:\r\n*min = 4000;\r\n*max = 20000;\r\nbreak;\r\ncase AD5421_CURRENT_RANGE_3mA8_21mA:\r\n*min = 3800;\r\n*max = 21000;\r\nbreak;\r\ncase AD5421_CURRENT_RANGE_3mA2_24mA:\r\n*min = 3200;\r\n*max = 24000;\r\nbreak;\r\ndefault:\r\n*min = 0;\r\n*max = 1;\r\nbreak;\r\n}\r\n}\r\nstatic inline unsigned int ad5421_get_offset(struct ad5421_state *st)\r\n{\r\nunsigned int min, max;\r\nad5421_get_current_min_max(st, &min, &max);\r\nreturn (min * (1 << 16)) / (max - min);\r\n}\r\nstatic inline unsigned int ad5421_get_scale(struct ad5421_state *st)\r\n{\r\nunsigned int min, max;\r\nad5421_get_current_min_max(st, &min, &max);\r\nreturn ((max - min) * 1000) / (1 << 16);\r\n}\r\nstatic int ad5421_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val, int *val2, long m)\r\n{\r\nstruct ad5421_state *st = iio_priv(indio_dev);\r\nint ret;\r\nif (chan->type != IIO_CURRENT)\r\nreturn -EINVAL;\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = ad5421_read(indio_dev, AD5421_REG_DAC_DATA);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\n*val2 = ad5421_get_scale(st);\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_CHAN_INFO_OFFSET:\r\n*val = ad5421_get_offset(st);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nret = ad5421_read(indio_dev, AD5421_REG_OFFSET);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret - 32768;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nret = ad5421_read(indio_dev, AD5421_REG_GAIN);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ad5421_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2, long mask)\r\n{\r\nconst unsigned int max_val = 1 << 16;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (val >= max_val || val < 0)\r\nreturn -EINVAL;\r\nreturn ad5421_write(indio_dev, AD5421_REG_DAC_DATA, val);\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nval += 32768;\r\nif (val >= max_val || val < 0)\r\nreturn -EINVAL;\r\nreturn ad5421_write(indio_dev, AD5421_REG_OFFSET, val);\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (val >= max_val || val < 0)\r\nreturn -EINVAL;\r\nreturn ad5421_write(indio_dev, AD5421_REG_GAIN, val);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ad5421_write_event_config(struct iio_dev *indio_dev,\r\nu64 event_code, int state)\r\n{\r\nstruct ad5421_state *st = iio_priv(indio_dev);\r\nunsigned int mask;\r\nswitch (IIO_EVENT_CODE_EXTRACT_CHAN_TYPE(event_code)) {\r\ncase IIO_CURRENT:\r\nif (IIO_EVENT_CODE_EXTRACT_DIR(event_code) ==\r\nIIO_EV_DIR_RISING)\r\nmask = AD5421_FAULT_OVER_CURRENT;\r\nelse\r\nmask = AD5421_FAULT_UNDER_CURRENT;\r\nbreak;\r\ncase IIO_TEMP:\r\nmask = AD5421_FAULT_TEMP_OVER_140;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&indio_dev->mlock);\r\nif (state)\r\nst->fault_mask |= mask;\r\nelse\r\nst->fault_mask &= ~mask;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn 0;\r\n}\r\nstatic int ad5421_read_event_config(struct iio_dev *indio_dev,\r\nu64 event_code)\r\n{\r\nstruct ad5421_state *st = iio_priv(indio_dev);\r\nunsigned int mask;\r\nswitch (IIO_EVENT_CODE_EXTRACT_CHAN_TYPE(event_code)) {\r\ncase IIO_CURRENT:\r\nif (IIO_EVENT_CODE_EXTRACT_DIR(event_code) ==\r\nIIO_EV_DIR_RISING)\r\nmask = AD5421_FAULT_OVER_CURRENT;\r\nelse\r\nmask = AD5421_FAULT_UNDER_CURRENT;\r\nbreak;\r\ncase IIO_TEMP:\r\nmask = AD5421_FAULT_TEMP_OVER_140;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn (bool)(st->fault_mask & mask);\r\n}\r\nstatic int ad5421_read_event_value(struct iio_dev *indio_dev, u64 event_code,\r\nint *val)\r\n{\r\nint ret;\r\nswitch (IIO_EVENT_CODE_EXTRACT_CHAN_TYPE(event_code)) {\r\ncase IIO_CURRENT:\r\nret = ad5421_read(indio_dev, AD5421_REG_DAC_DATA);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nbreak;\r\ncase IIO_TEMP:\r\n*val = 140000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit ad5421_probe(struct spi_device *spi)\r\n{\r\nstruct ad5421_platform_data *pdata = dev_get_platdata(&spi->dev);\r\nstruct iio_dev *indio_dev;\r\nstruct ad5421_state *st;\r\nint ret;\r\nindio_dev = iio_device_alloc(sizeof(*st));\r\nif (indio_dev == NULL) {\r\ndev_err(&spi->dev, "Failed to allocate iio device\n");\r\nreturn -ENOMEM;\r\n}\r\nst = iio_priv(indio_dev);\r\nspi_set_drvdata(spi, indio_dev);\r\nst->spi = spi;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = "ad5421";\r\nindio_dev->info = &ad5421_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = ad5421_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ad5421_channels);\r\nst->ctrl = AD5421_CTRL_WATCHDOG_DISABLE |\r\nAD5421_CTRL_AUTO_FAULT_READBACK;\r\nif (pdata) {\r\nst->current_range = pdata->current_range;\r\nif (pdata->external_vref)\r\nst->ctrl |= AD5421_CTRL_PWR_DOWN_INT_VREF;\r\n} else {\r\nst->current_range = AD5421_CURRENT_RANGE_4mA_20mA;\r\n}\r\nad5421_update_ctrl(indio_dev, 0, 0);\r\nif (spi->irq) {\r\nret = request_threaded_irq(spi->irq,\r\nNULL,\r\nad5421_fault_handler,\r\nIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\r\n"ad5421 fault",\r\nindio_dev);\r\nif (ret)\r\ngoto error_free;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(&spi->dev, "Failed to register iio device: %d\n", ret);\r\ngoto error_free_irq;\r\n}\r\nreturn 0;\r\nerror_free_irq:\r\nif (spi->irq)\r\nfree_irq(spi->irq, indio_dev);\r\nerror_free:\r\niio_device_free(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int __devexit ad5421_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\niio_device_unregister(indio_dev);\r\nif (spi->irq)\r\nfree_irq(spi->irq, indio_dev);\r\niio_device_free(indio_dev);\r\nreturn 0;\r\n}
