static inline u32 pci_cfg_read_32bit(struct pci_bus *bus, unsigned int devfn,\r\nint where)\r\n{\r\nu32 data;\r\nu32 *cfgaddr;\r\ncfgaddr = (u32 *)(pci_config_base +\r\npci_cfg_addr(bus->number, devfn, where & ~3));\r\ndata = *cfgaddr;\r\nreturn data;\r\n}\r\nstatic inline void pci_cfg_write_32bit(struct pci_bus *bus, unsigned int devfn,\r\nint where, u32 data)\r\n{\r\nu32 *cfgaddr;\r\ncfgaddr = (u32 *)(pci_config_base +\r\npci_cfg_addr(bus->number, devfn, where & ~3));\r\n*cfgaddr = data;\r\n}\r\nstatic int nlm_pcibios_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nu32 data;\r\nif ((size == 2) && (where & 1))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nelse if ((size == 4) && (where & 3))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\ndata = pci_cfg_read_32bit(bus, devfn, where);\r\nif (size == 1)\r\n*val = (data >> ((where & 3) << 3)) & 0xff;\r\nelse if (size == 2)\r\n*val = (data >> ((where & 3) << 3)) & 0xffff;\r\nelse\r\n*val = data;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int nlm_pcibios_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nu32 data;\r\nif ((size == 2) && (where & 1))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nelse if ((size == 4) && (where & 3))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\ndata = pci_cfg_read_32bit(bus, devfn, where);\r\nif (size == 1)\r\ndata = (data & ~(0xff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nelse if (size == 2)\r\ndata = (data & ~(0xffff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nelse\r\ndata = val;\r\npci_cfg_write_32bit(bus, devfn, where, data);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int get_irq_vector(const struct pci_dev *dev)\r\n{\r\nif (dev->bus->self == NULL)\r\nreturn 0;\r\nswitch (dev->bus->self->devfn) {\r\ncase 0x8:\r\nreturn PIC_PCIE_LINK_0_IRQ;\r\ncase 0x9:\r\nreturn PIC_PCIE_LINK_1_IRQ;\r\ncase 0xa:\r\nreturn PIC_PCIE_LINK_2_IRQ;\r\ncase 0xb:\r\nreturn PIC_PCIE_LINK_3_IRQ;\r\n}\r\nWARN(1, "Unexpected devfn %d\n", dev->bus->self->devfn);\r\nreturn 0;\r\n}\r\nint __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nreturn get_irq_vector(dev);\r\n}\r\nint pcibios_plat_dev_init(struct pci_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xlp_enable_pci_bswap(void)\r\n{\r\nuint64_t pciebase, sysbase;\r\nint node, i;\r\nu32 reg;\r\nnode = 0;\r\nsysbase = nlm_get_bridge_regbase(node);\r\nfor (i = 0; i < 4; i++) {\r\npciebase = nlm_pcicfg_base(XLP_IO_PCIE_OFFSET(node, i));\r\nif (nlm_read_pci_reg(pciebase, 0) == 0xffffffff)\r\ncontinue;\r\nreg = nlm_read_bridge_reg(sysbase, BRIDGE_PCIEMEM_BASE0 + i);\r\nnlm_write_pci_reg(pciebase, PCIE_BYTE_SWAP_MEM_BASE, reg);\r\nreg = nlm_read_bridge_reg(sysbase, BRIDGE_PCIEMEM_LIMIT0 + i);\r\nnlm_write_pci_reg(pciebase, PCIE_BYTE_SWAP_MEM_LIM,\r\nreg | 0xfff);\r\nreg = nlm_read_bridge_reg(sysbase, BRIDGE_PCIEIO_BASE0 + i);\r\nnlm_write_pci_reg(pciebase, PCIE_BYTE_SWAP_IO_BASE, reg);\r\nreg = nlm_read_bridge_reg(sysbase, BRIDGE_PCIEIO_LIMIT0 + i);\r\nnlm_write_pci_reg(pciebase, PCIE_BYTE_SWAP_IO_LIM, reg | 0xfff);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init pcibios_init(void)\r\n{\r\npci_set_flags(PCI_PROBE_ONLY);\r\npci_config_base = ioremap(XLP_DEFAULT_PCI_ECFG_BASE, 64 << 20);\r\nioport_resource.start = 0;\r\nioport_resource.end = ~0;\r\nxlp_enable_pci_bswap();\r\nset_io_port_base(CKSEG1);\r\nnlm_pci_controller.io_map_base = CKSEG1;\r\nregister_pci_controller(&nlm_pci_controller);\r\npr_info("XLP PCIe Controller %pR%pR.\n", &nlm_pci_io_resource,\r\n&nlm_pci_mem_resource);\r\nreturn 0;\r\n}
