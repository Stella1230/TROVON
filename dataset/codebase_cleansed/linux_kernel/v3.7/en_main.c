int en_print(const char *level, const struct mlx4_en_priv *priv,\r\nconst char *format, ...)\r\n{\r\nva_list args;\r\nstruct va_format vaf;\r\nint i;\r\nva_start(args, format);\r\nvaf.fmt = format;\r\nvaf.va = &args;\r\nif (priv->registered)\r\ni = printk("%s%s: %s: %pV",\r\nlevel, DRV_NAME, priv->dev->name, &vaf);\r\nelse\r\ni = printk("%s%s: %s: Port %d: %pV",\r\nlevel, DRV_NAME, dev_name(&priv->mdev->pdev->dev),\r\npriv->port, &vaf);\r\nva_end(args);\r\nreturn i;\r\n}\r\nstatic int mlx4_en_get_profile(struct mlx4_en_dev *mdev)\r\n{\r\nstruct mlx4_en_profile *params = &mdev->profile;\r\nint i;\r\nparams->udp_rss = udp_rss;\r\nparams->num_tx_rings_p_up = min_t(int, num_online_cpus(),\r\nMLX4_EN_MAX_TX_RING_P_UP);\r\nif (params->udp_rss && !(mdev->dev->caps.flags\r\n& MLX4_DEV_CAP_FLAG_UDP_RSS)) {\r\nmlx4_warn(mdev, "UDP RSS is not supported on this device.\n");\r\nparams->udp_rss = 0;\r\n}\r\nfor (i = 1; i <= MLX4_MAX_PORTS; i++) {\r\nparams->prof[i].rx_pause = 1;\r\nparams->prof[i].rx_ppp = pfcrx;\r\nparams->prof[i].tx_pause = 1;\r\nparams->prof[i].tx_ppp = pfctx;\r\nparams->prof[i].tx_ring_size = MLX4_EN_DEF_TX_RING_SIZE;\r\nparams->prof[i].rx_ring_size = MLX4_EN_DEF_RX_RING_SIZE;\r\nparams->prof[i].tx_ring_num = params->num_tx_rings_p_up *\r\nMLX4_EN_NUM_UP;\r\nparams->prof[i].rss_rings = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void *mlx4_en_get_netdev(struct mlx4_dev *dev, void *ctx, u8 port)\r\n{\r\nstruct mlx4_en_dev *endev = ctx;\r\nreturn endev->pndev[port];\r\n}\r\nstatic void mlx4_en_event(struct mlx4_dev *dev, void *endev_ptr,\r\nenum mlx4_dev_event event, unsigned long port)\r\n{\r\nstruct mlx4_en_dev *mdev = (struct mlx4_en_dev *) endev_ptr;\r\nstruct mlx4_en_priv *priv;\r\nswitch (event) {\r\ncase MLX4_DEV_EVENT_PORT_UP:\r\ncase MLX4_DEV_EVENT_PORT_DOWN:\r\nif (!mdev->pndev[port])\r\nreturn;\r\npriv = netdev_priv(mdev->pndev[port]);\r\npriv->link_state = event;\r\nqueue_work(mdev->workqueue, &priv->linkstate_task);\r\nbreak;\r\ncase MLX4_DEV_EVENT_CATASTROPHIC_ERROR:\r\nmlx4_err(mdev, "Internal error detected, restarting device\n");\r\nbreak;\r\ndefault:\r\nif (port < 1 || port > dev->caps.num_ports ||\r\n!mdev->pndev[port])\r\nreturn;\r\nmlx4_warn(mdev, "Unhandled event %d for port %d\n", event,\r\n(int) port);\r\n}\r\n}\r\nstatic void mlx4_en_remove(struct mlx4_dev *dev, void *endev_ptr)\r\n{\r\nstruct mlx4_en_dev *mdev = endev_ptr;\r\nint i;\r\nmutex_lock(&mdev->state_lock);\r\nmdev->device_up = false;\r\nmutex_unlock(&mdev->state_lock);\r\nmlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH)\r\nif (mdev->pndev[i])\r\nmlx4_en_destroy_netdev(mdev->pndev[i]);\r\nflush_workqueue(mdev->workqueue);\r\ndestroy_workqueue(mdev->workqueue);\r\nmlx4_mr_free(dev, &mdev->mr);\r\niounmap(mdev->uar_map);\r\nmlx4_uar_free(dev, &mdev->priv_uar);\r\nmlx4_pd_free(dev, mdev->priv_pdn);\r\nkfree(mdev);\r\n}\r\nstatic void *mlx4_en_add(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_en_dev *mdev;\r\nint i;\r\nint err;\r\nprintk_once(KERN_INFO "%s", mlx4_en_version);\r\nmdev = kzalloc(sizeof *mdev, GFP_KERNEL);\r\nif (!mdev) {\r\ndev_err(&dev->pdev->dev, "Device struct alloc failed, "\r\n"aborting.\n");\r\nerr = -ENOMEM;\r\ngoto err_free_res;\r\n}\r\nif (mlx4_pd_alloc(dev, &mdev->priv_pdn))\r\ngoto err_free_dev;\r\nif (mlx4_uar_alloc(dev, &mdev->priv_uar))\r\ngoto err_pd;\r\nmdev->uar_map = ioremap((phys_addr_t) mdev->priv_uar.pfn << PAGE_SHIFT,\r\nPAGE_SIZE);\r\nif (!mdev->uar_map)\r\ngoto err_uar;\r\nspin_lock_init(&mdev->uar_lock);\r\nmdev->dev = dev;\r\nmdev->dma_device = &(dev->pdev->dev);\r\nmdev->pdev = dev->pdev;\r\nmdev->device_up = false;\r\nmdev->LSO_support = !!(dev->caps.flags & (1 << 15));\r\nif (!mdev->LSO_support)\r\nmlx4_warn(mdev, "LSO not supported, please upgrade to later "\r\n"FW version to enable LSO\n");\r\nif (mlx4_mr_alloc(mdev->dev, mdev->priv_pdn, 0, ~0ull,\r\nMLX4_PERM_LOCAL_WRITE | MLX4_PERM_LOCAL_READ,\r\n0, 0, &mdev->mr)) {\r\nmlx4_err(mdev, "Failed allocating memory region\n");\r\ngoto err_map;\r\n}\r\nif (mlx4_mr_enable(mdev->dev, &mdev->mr)) {\r\nmlx4_err(mdev, "Failed enabling memory region\n");\r\ngoto err_mr;\r\n}\r\nerr = mlx4_en_get_profile(mdev);\r\nif (err) {\r\nmlx4_err(mdev, "Bad module parameters, aborting.\n");\r\ngoto err_mr;\r\n}\r\nmdev->port_cnt = 0;\r\nmlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH)\r\nmdev->port_cnt++;\r\nmlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH) {\r\nif (!dev->caps.comp_pool) {\r\nmdev->profile.prof[i].rx_ring_num =\r\nrounddown_pow_of_two(max_t(int, MIN_RX_RINGS,\r\nmin_t(int,\r\ndev->caps.num_comp_vectors,\r\nMAX_RX_RINGS)));\r\n} else {\r\nmdev->profile.prof[i].rx_ring_num = rounddown_pow_of_two(\r\nmin_t(int, dev->caps.comp_pool/\r\ndev->caps.num_ports - 1 , MAX_MSIX_P_PORT - 1));\r\n}\r\n}\r\nmdev->workqueue = create_singlethread_workqueue("mlx4_en");\r\nif (!mdev->workqueue) {\r\nerr = -ENOMEM;\r\ngoto err_mr;\r\n}\r\nmutex_init(&mdev->state_lock);\r\nmdev->device_up = true;\r\nmlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH) {\r\nmlx4_info(mdev, "Activating port:%d\n", i);\r\nif (mlx4_en_init_netdev(mdev, i, &mdev->profile.prof[i]))\r\nmdev->pndev[i] = NULL;\r\n}\r\nreturn mdev;\r\nerr_mr:\r\nmlx4_mr_free(dev, &mdev->mr);\r\nerr_map:\r\nif (!mdev->uar_map)\r\niounmap(mdev->uar_map);\r\nerr_uar:\r\nmlx4_uar_free(dev, &mdev->priv_uar);\r\nerr_pd:\r\nmlx4_pd_free(dev, mdev->priv_pdn);\r\nerr_free_dev:\r\nkfree(mdev);\r\nerr_free_res:\r\nreturn NULL;\r\n}\r\nstatic int __init mlx4_en_init(void)\r\n{\r\nreturn mlx4_register_interface(&mlx4_en_interface);\r\n}\r\nstatic void __exit mlx4_en_cleanup(void)\r\n{\r\nmlx4_unregister_interface(&mlx4_en_interface);\r\n}
