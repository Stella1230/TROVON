static int spu_alloc_lscsa_std(struct spu_state *csa)\r\n{\r\nstruct spu_lscsa *lscsa;\r\nunsigned char *p;\r\nlscsa = vzalloc(sizeof(struct spu_lscsa));\r\nif (!lscsa)\r\nreturn -ENOMEM;\r\ncsa->lscsa = lscsa;\r\nfor (p = lscsa->ls; p < lscsa->ls + LS_SIZE; p += PAGE_SIZE)\r\nSetPageReserved(vmalloc_to_page(p));\r\nreturn 0;\r\n}\r\nstatic void spu_free_lscsa_std(struct spu_state *csa)\r\n{\r\nunsigned char *p;\r\nif (csa->lscsa == NULL)\r\nreturn;\r\nfor (p = csa->lscsa->ls; p < csa->lscsa->ls + LS_SIZE; p += PAGE_SIZE)\r\nClearPageReserved(vmalloc_to_page(p));\r\nvfree(csa->lscsa);\r\n}\r\nint spu_alloc_lscsa(struct spu_state *csa)\r\n{\r\nstruct page **pgarray;\r\nunsigned char *p;\r\nint i, j, n_4k;\r\nif (!spu_64k_pages_available())\r\ngoto fail;\r\ncsa->use_big_pages = 1;\r\npr_debug("spu_alloc_lscsa(csa=0x%p), trying to allocate 64K pages\n",\r\ncsa);\r\nfor (i = 0; i < SPU_LSCSA_NUM_BIG_PAGES; i++) {\r\ncsa->lscsa_pages[i] = alloc_pages(GFP_KERNEL,\r\nSPU_64K_PAGE_ORDER);\r\nif (csa->lscsa_pages[i] == NULL)\r\ngoto fail;\r\n}\r\npr_debug(" success ! creating vmap...\n");\r\nn_4k = SPU_64K_PAGE_COUNT * SPU_LSCSA_NUM_BIG_PAGES;\r\npgarray = kmalloc(sizeof(struct page *) * n_4k, GFP_KERNEL);\r\nif (pgarray == NULL)\r\ngoto fail;\r\nfor (i = 0; i < SPU_LSCSA_NUM_BIG_PAGES; i++)\r\nfor (j = 0; j < SPU_64K_PAGE_COUNT; j++)\r\npgarray[i * SPU_64K_PAGE_COUNT + j] =\r\ncsa->lscsa_pages[i] + j;\r\ncsa->lscsa = vmap(pgarray, n_4k, VM_USERMAP, PAGE_KERNEL);\r\nkfree(pgarray);\r\nif (csa->lscsa == NULL)\r\ngoto fail;\r\nmemset(csa->lscsa, 0, sizeof(struct spu_lscsa));\r\nfor (p = csa->lscsa->ls; p < csa->lscsa->ls + LS_SIZE; p += PAGE_SIZE)\r\nSetPageReserved(vmalloc_to_page(p));\r\npr_debug(" all good !\n");\r\nreturn 0;\r\nfail:\r\npr_debug("spufs: failed to allocate lscsa 64K pages, falling back\n");\r\nspu_free_lscsa(csa);\r\nreturn spu_alloc_lscsa_std(csa);\r\n}\r\nvoid spu_free_lscsa(struct spu_state *csa)\r\n{\r\nunsigned char *p;\r\nint i;\r\nif (!csa->use_big_pages) {\r\nspu_free_lscsa_std(csa);\r\nreturn;\r\n}\r\ncsa->use_big_pages = 0;\r\nif (csa->lscsa == NULL)\r\ngoto free_pages;\r\nfor (p = csa->lscsa->ls; p < csa->lscsa->ls + LS_SIZE; p += PAGE_SIZE)\r\nClearPageReserved(vmalloc_to_page(p));\r\nvunmap(csa->lscsa);\r\ncsa->lscsa = NULL;\r\nfree_pages:\r\nfor (i = 0; i < SPU_LSCSA_NUM_BIG_PAGES; i++)\r\nif (csa->lscsa_pages[i])\r\n__free_pages(csa->lscsa_pages[i], SPU_64K_PAGE_ORDER);\r\n}\r\nint spu_alloc_lscsa(struct spu_state *csa)\r\n{\r\nreturn spu_alloc_lscsa_std(csa);\r\n}\r\nvoid spu_free_lscsa(struct spu_state *csa)\r\n{\r\nspu_free_lscsa_std(csa);\r\n}
