static int sn_dma_supported(struct device *dev, u64 mask)\r\n{\r\nBUG_ON(dev->bus != &pci_bus_type);\r\nif (mask < 0x7fffffff)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint sn_dma_set_mask(struct device *dev, u64 dma_mask)\r\n{\r\nBUG_ON(dev->bus != &pci_bus_type);\r\nif (!sn_dma_supported(dev, dma_mask))\r\nreturn 0;\r\n*dev->dma_mask = dma_mask;\r\nreturn 1;\r\n}\r\nstatic void *sn_dma_alloc_coherent(struct device *dev, size_t size,\r\ndma_addr_t * dma_handle, gfp_t flags,\r\nstruct dma_attrs *attrs)\r\n{\r\nvoid *cpuaddr;\r\nunsigned long phys_addr;\r\nint node;\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct sn_pcibus_provider *provider = SN_PCIDEV_BUSPROVIDER(pdev);\r\nBUG_ON(dev->bus != &pci_bus_type);\r\nnode = pcibus_to_node(pdev->bus);\r\nif (likely(node >=0)) {\r\nstruct page *p = alloc_pages_exact_node(node,\r\nflags, get_order(size));\r\nif (likely(p))\r\ncpuaddr = page_address(p);\r\nelse\r\nreturn NULL;\r\n} else\r\ncpuaddr = (void *)__get_free_pages(flags, get_order(size));\r\nif (unlikely(!cpuaddr))\r\nreturn NULL;\r\nmemset(cpuaddr, 0x0, size);\r\nphys_addr = __pa(cpuaddr);\r\n*dma_handle = provider->dma_map_consistent(pdev, phys_addr, size,\r\nSN_DMA_ADDR_PHYS);\r\nif (!*dma_handle) {\r\nprintk(KERN_ERR "%s: out of ATEs\n", __func__);\r\nfree_pages((unsigned long)cpuaddr, get_order(size));\r\nreturn NULL;\r\n}\r\nreturn cpuaddr;\r\n}\r\nstatic void sn_dma_free_coherent(struct device *dev, size_t size, void *cpu_addr,\r\ndma_addr_t dma_handle, struct dma_attrs *attrs)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct sn_pcibus_provider *provider = SN_PCIDEV_BUSPROVIDER(pdev);\r\nBUG_ON(dev->bus != &pci_bus_type);\r\nprovider->dma_unmap(pdev, dma_handle, 0);\r\nfree_pages((unsigned long)cpu_addr, get_order(size));\r\n}\r\nstatic dma_addr_t sn_dma_map_page(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nvoid *cpu_addr = page_address(page) + offset;\r\ndma_addr_t dma_addr;\r\nunsigned long phys_addr;\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct sn_pcibus_provider *provider = SN_PCIDEV_BUSPROVIDER(pdev);\r\nint dmabarr;\r\ndmabarr = dma_get_attr(DMA_ATTR_WRITE_BARRIER, attrs);\r\nBUG_ON(dev->bus != &pci_bus_type);\r\nphys_addr = __pa(cpu_addr);\r\nif (dmabarr)\r\ndma_addr = provider->dma_map_consistent(pdev, phys_addr,\r\nsize, SN_DMA_ADDR_PHYS);\r\nelse\r\ndma_addr = provider->dma_map(pdev, phys_addr, size,\r\nSN_DMA_ADDR_PHYS);\r\nif (!dma_addr) {\r\nprintk(KERN_ERR "%s: out of ATEs\n", __func__);\r\nreturn 0;\r\n}\r\nreturn dma_addr;\r\n}\r\nstatic void sn_dma_unmap_page(struct device *dev, dma_addr_t dma_addr,\r\nsize_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct sn_pcibus_provider *provider = SN_PCIDEV_BUSPROVIDER(pdev);\r\nBUG_ON(dev->bus != &pci_bus_type);\r\nprovider->dma_unmap(pdev, dma_addr, dir);\r\n}\r\nstatic void sn_dma_unmap_sg(struct device *dev, struct scatterlist *sgl,\r\nint nhwentries, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nint i;\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct sn_pcibus_provider *provider = SN_PCIDEV_BUSPROVIDER(pdev);\r\nstruct scatterlist *sg;\r\nBUG_ON(dev->bus != &pci_bus_type);\r\nfor_each_sg(sgl, sg, nhwentries, i) {\r\nprovider->dma_unmap(pdev, sg->dma_address, dir);\r\nsg->dma_address = (dma_addr_t) NULL;\r\nsg->dma_length = 0;\r\n}\r\n}\r\nstatic int sn_dma_map_sg(struct device *dev, struct scatterlist *sgl,\r\nint nhwentries, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nunsigned long phys_addr;\r\nstruct scatterlist *saved_sg = sgl, *sg;\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct sn_pcibus_provider *provider = SN_PCIDEV_BUSPROVIDER(pdev);\r\nint i;\r\nint dmabarr;\r\ndmabarr = dma_get_attr(DMA_ATTR_WRITE_BARRIER, attrs);\r\nBUG_ON(dev->bus != &pci_bus_type);\r\nfor_each_sg(sgl, sg, nhwentries, i) {\r\ndma_addr_t dma_addr;\r\nphys_addr = SG_ENT_PHYS_ADDRESS(sg);\r\nif (dmabarr)\r\ndma_addr = provider->dma_map_consistent(pdev,\r\nphys_addr,\r\nsg->length,\r\nSN_DMA_ADDR_PHYS);\r\nelse\r\ndma_addr = provider->dma_map(pdev, phys_addr,\r\nsg->length,\r\nSN_DMA_ADDR_PHYS);\r\nsg->dma_address = dma_addr;\r\nif (!sg->dma_address) {\r\nprintk(KERN_ERR "%s: out of ATEs\n", __func__);\r\nif (i > 0)\r\nsn_dma_unmap_sg(dev, saved_sg, i, dir, attrs);\r\nreturn 0;\r\n}\r\nsg->dma_length = sg->length;\r\n}\r\nreturn nhwentries;\r\n}\r\nstatic void sn_dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle,\r\nsize_t size, enum dma_data_direction dir)\r\n{\r\nBUG_ON(dev->bus != &pci_bus_type);\r\n}\r\nstatic void sn_dma_sync_single_for_device(struct device *dev, dma_addr_t dma_handle,\r\nsize_t size,\r\nenum dma_data_direction dir)\r\n{\r\nBUG_ON(dev->bus != &pci_bus_type);\r\n}\r\nstatic void sn_dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,\r\nint nelems, enum dma_data_direction dir)\r\n{\r\nBUG_ON(dev->bus != &pci_bus_type);\r\n}\r\nstatic void sn_dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,\r\nint nelems, enum dma_data_direction dir)\r\n{\r\nBUG_ON(dev->bus != &pci_bus_type);\r\n}\r\nstatic int sn_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\r\n{\r\nreturn 0;\r\n}\r\nu64 sn_dma_get_required_mask(struct device *dev)\r\n{\r\nreturn DMA_BIT_MASK(64);\r\n}\r\nchar *sn_pci_get_legacy_mem(struct pci_bus *bus)\r\n{\r\nif (!SN_PCIBUS_BUSSOFT(bus))\r\nreturn ERR_PTR(-ENODEV);\r\nreturn (char *)(SN_PCIBUS_BUSSOFT(bus)->bs_legacy_mem | __IA64_UNCACHED_OFFSET);\r\n}\r\nint sn_pci_legacy_read(struct pci_bus *bus, u16 port, u32 *val, u8 size)\r\n{\r\nunsigned long addr;\r\nint ret;\r\nstruct ia64_sal_retval isrv;\r\nSAL_CALL(isrv, SN_SAL_IOIF_PCI_SAFE,\r\npci_domain_nr(bus), bus->number,\r\n0,\r\n0,\r\nport, size, __pa(val));\r\nif (isrv.status == 0)\r\nreturn size;\r\nif (!SN_PCIBUS_BUSSOFT(bus))\r\nreturn -ENODEV;\r\naddr = SN_PCIBUS_BUSSOFT(bus)->bs_legacy_io | __IA64_UNCACHED_OFFSET;\r\naddr += port;\r\nret = ia64_sn_probe_mem(addr, (long)size, (void *)val);\r\nif (ret == 2)\r\nreturn -EINVAL;\r\nif (ret == 1)\r\n*val = -1;\r\nreturn size;\r\n}\r\nint sn_pci_legacy_write(struct pci_bus *bus, u16 port, u32 val, u8 size)\r\n{\r\nint ret = size;\r\nunsigned long paddr;\r\nunsigned long *addr;\r\nstruct ia64_sal_retval isrv;\r\nSAL_CALL(isrv, SN_SAL_IOIF_PCI_SAFE,\r\npci_domain_nr(bus), bus->number,\r\n0,\r\n1,\r\nport, size, __pa(&val));\r\nif (isrv.status == 0)\r\nreturn size;\r\nif (!SN_PCIBUS_BUSSOFT(bus)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\npaddr = SN_PCIBUS_BUSSOFT(bus)->bs_legacy_io | __IA64_UNCACHED_OFFSET;\r\npaddr += port;\r\naddr = (unsigned long *)paddr;\r\nswitch (size) {\r\ncase 1:\r\n*(volatile u8 *)(addr) = (u8)(val);\r\nbreak;\r\ncase 2:\r\n*(volatile u16 *)(addr) = (u16)(val);\r\nbreak;\r\ncase 4:\r\n*(volatile u32 *)(addr) = (u32)(val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nvoid sn_dma_init(void)\r\n{\r\ndma_ops = &sn_dma_ops;\r\n}
