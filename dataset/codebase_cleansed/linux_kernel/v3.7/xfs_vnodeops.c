STATIC int\r\nxfs_readlink_bmap(\r\nxfs_inode_t *ip,\r\nchar *link)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nint pathlen = ip->i_d.di_size;\r\nint nmaps = SYMLINK_MAPS;\r\nxfs_bmbt_irec_t mval[SYMLINK_MAPS];\r\nxfs_daddr_t d;\r\nint byte_cnt;\r\nint n;\r\nxfs_buf_t *bp;\r\nint error = 0;\r\nerror = xfs_bmapi_read(ip, 0, XFS_B_TO_FSB(mp, pathlen), mval, &nmaps,\r\n0);\r\nif (error)\r\ngoto out;\r\nfor (n = 0; n < nmaps; n++) {\r\nd = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\r\nbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\r\nbp = xfs_buf_read(mp->m_ddev_targp, d, BTOBB(byte_cnt), 0);\r\nif (!bp)\r\nreturn XFS_ERROR(ENOMEM);\r\nerror = bp->b_error;\r\nif (error) {\r\nxfs_buf_ioerror_alert(bp, __func__);\r\nxfs_buf_relse(bp);\r\ngoto out;\r\n}\r\nif (pathlen < byte_cnt)\r\nbyte_cnt = pathlen;\r\npathlen -= byte_cnt;\r\nmemcpy(link, bp->b_addr, byte_cnt);\r\nxfs_buf_relse(bp);\r\n}\r\nlink[ip->i_d.di_size] = '\0';\r\nerror = 0;\r\nout:\r\nreturn error;\r\n}\r\nint\r\nxfs_readlink(\r\nxfs_inode_t *ip,\r\nchar *link)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nxfs_fsize_t pathlen;\r\nint error = 0;\r\ntrace_xfs_readlink(ip);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn XFS_ERROR(EIO);\r\nxfs_ilock(ip, XFS_ILOCK_SHARED);\r\npathlen = ip->i_d.di_size;\r\nif (!pathlen)\r\ngoto out;\r\nif (pathlen < 0 || pathlen > MAXPATHLEN) {\r\nxfs_alert(mp, "%s: inode (%llu) bad symlink length (%lld)",\r\n__func__, (unsigned long long) ip->i_ino,\r\n(long long) pathlen);\r\nASSERT(0);\r\nerror = XFS_ERROR(EFSCORRUPTED);\r\ngoto out;\r\n}\r\nif (ip->i_df.if_flags & XFS_IFINLINE) {\r\nmemcpy(link, ip->i_df.if_u1.if_data, pathlen);\r\nlink[pathlen] = '\0';\r\n} else {\r\nerror = xfs_readlink_bmap(ip, link);\r\n}\r\nout:\r\nxfs_iunlock(ip, XFS_ILOCK_SHARED);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_free_eofblocks(\r\nxfs_mount_t *mp,\r\nxfs_inode_t *ip,\r\nbool need_iolock)\r\n{\r\nxfs_trans_t *tp;\r\nint error;\r\nxfs_fileoff_t end_fsb;\r\nxfs_fileoff_t last_fsb;\r\nxfs_filblks_t map_len;\r\nint nimaps;\r\nxfs_bmbt_irec_t imap;\r\nend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)XFS_ISIZE(ip));\r\nlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\r\nif (last_fsb <= end_fsb)\r\nreturn 0;\r\nmap_len = last_fsb - end_fsb;\r\nnimaps = 1;\r\nxfs_ilock(ip, XFS_ILOCK_SHARED);\r\nerror = xfs_bmapi_read(ip, end_fsb, map_len, &imap, &nimaps, 0);\r\nxfs_iunlock(ip, XFS_ILOCK_SHARED);\r\nif (!error && (nimaps != 0) &&\r\n(imap.br_startblock != HOLESTARTBLOCK ||\r\nip->i_delayed_blks)) {\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\nreturn error;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\r\nif (need_iolock) {\r\nif (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {\r\nxfs_trans_cancel(tp, 0);\r\nreturn 0;\r\n}\r\n}\r\nerror = xfs_trans_reserve(tp, 0,\r\nXFS_ITRUNCATE_LOG_RES(mp),\r\n0, XFS_TRANS_PERM_LOG_RES,\r\nXFS_ITRUNCATE_LOG_COUNT);\r\nif (error) {\r\nASSERT(XFS_FORCED_SHUTDOWN(mp));\r\nxfs_trans_cancel(tp, 0);\r\nif (need_iolock)\r\nxfs_iunlock(ip, XFS_IOLOCK_EXCL);\r\nreturn error;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, 0);\r\nerror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK,\r\nXFS_ISIZE(ip));\r\nif (error) {\r\nxfs_trans_cancel(tp,\r\n(XFS_TRANS_RELEASE_LOG_RES |\r\nXFS_TRANS_ABORT));\r\n} else {\r\nerror = xfs_trans_commit(tp,\r\nXFS_TRANS_RELEASE_LOG_RES);\r\n}\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nif (need_iolock)\r\nxfs_iunlock(ip, XFS_IOLOCK_EXCL);\r\n}\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_inactive_symlink_rmt(\r\nxfs_inode_t *ip,\r\nxfs_trans_t **tpp)\r\n{\r\nxfs_buf_t *bp;\r\nint committed;\r\nint done;\r\nint error;\r\nxfs_fsblock_t first_block;\r\nxfs_bmap_free_t free_list;\r\nint i;\r\nxfs_mount_t *mp;\r\nxfs_bmbt_irec_t mval[SYMLINK_MAPS];\r\nint nmaps;\r\nxfs_trans_t *ntp;\r\nint size;\r\nxfs_trans_t *tp;\r\ntp = *tpp;\r\nmp = ip->i_mount;\r\nASSERT(ip->i_d.di_size > XFS_IFORK_DSIZE(ip));\r\nASSERT(ip->i_d.di_nextents > 0 && ip->i_d.di_nextents <= 2);\r\nsize = (int)ip->i_d.di_size;\r\nip->i_d.di_size = 0;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\ndone = 0;\r\nxfs_bmap_init(&free_list, &first_block);\r\nnmaps = ARRAY_SIZE(mval);\r\nerror = xfs_bmapi_read(ip, 0, XFS_B_TO_FSB(mp, size),\r\nmval, &nmaps, 0);\r\nif (error)\r\ngoto error0;\r\nfor (i = 0; i < nmaps; i++) {\r\nbp = xfs_trans_get_buf(tp, mp->m_ddev_targp,\r\nXFS_FSB_TO_DADDR(mp, mval[i].br_startblock),\r\nXFS_FSB_TO_BB(mp, mval[i].br_blockcount), 0);\r\nif (!bp) {\r\nerror = ENOMEM;\r\ngoto error1;\r\n}\r\nxfs_trans_binval(tp, bp);\r\n}\r\nif ((error = xfs_bunmapi(tp, ip, 0, size, XFS_BMAPI_METADATA, nmaps,\r\n&first_block, &free_list, &done)))\r\ngoto error1;\r\nASSERT(done);\r\nif ((error = xfs_bmap_finish(&tp, &free_list, &committed)))\r\ngoto error1;\r\nASSERT(committed);\r\nxfs_trans_ijoin(tp, ip, 0);\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nntp = xfs_trans_dup(tp);\r\nerror = xfs_trans_commit(tp, 0);\r\ntp = ntp;\r\nif (error) {\r\nASSERT(XFS_FORCED_SHUTDOWN(mp));\r\ngoto error0;\r\n}\r\nxfs_log_ticket_put(tp->t_ticket);\r\nif (ip->i_df.if_bytes)\r\nxfs_idata_realloc(ip, -ip->i_df.if_bytes, XFS_DATA_FORK);\r\nASSERT(ip->i_df.if_bytes == 0);\r\nif ((error = xfs_trans_reserve(tp, 0, XFS_ITRUNCATE_LOG_RES(mp), 0,\r\nXFS_TRANS_PERM_LOG_RES, XFS_ITRUNCATE_LOG_COUNT))) {\r\nASSERT(XFS_FORCED_SHUTDOWN(mp));\r\ngoto error0;\r\n}\r\nxfs_trans_ijoin(tp, ip, 0);\r\n*tpp = tp;\r\nreturn 0;\r\nerror1:\r\nxfs_bmap_cancel(&free_list);\r\nerror0:\r\nreturn error;\r\n}\r\nint\r\nxfs_release(\r\nxfs_inode_t *ip)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nint error;\r\nif (!S_ISREG(ip->i_d.di_mode) || (ip->i_d.di_mode == 0))\r\nreturn 0;\r\nif (mp->m_flags & XFS_MOUNT_RDONLY)\r\nreturn 0;\r\nif (!XFS_FORCED_SHUTDOWN(mp)) {\r\nint truncated;\r\nif ((ip->i_d.di_nlink == 0) && xfs_inode_is_filestream(ip))\r\nxfs_filestream_deassociate(ip);\r\ntruncated = xfs_iflags_test_and_clear(ip, XFS_ITRUNCATED);\r\nif (truncated) {\r\nxfs_iflags_clear(ip, XFS_IDIRTY_RELEASE);\r\nif (VN_DIRTY(VFS_I(ip)) && ip->i_delayed_blks > 0)\r\nxfs_flush_pages(ip, 0, -1, XBF_ASYNC, FI_NONE);\r\n}\r\n}\r\nif (ip->i_d.di_nlink == 0)\r\nreturn 0;\r\nif ((S_ISREG(ip->i_d.di_mode) &&\r\n(VFS_I(ip)->i_size > 0 ||\r\n(VN_CACHED(VFS_I(ip)) > 0 || ip->i_delayed_blks > 0)) &&\r\n(ip->i_df.if_flags & XFS_IFEXTENTS)) &&\r\n(!(ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND)))) {\r\nif (xfs_iflags_test(ip, XFS_IDIRTY_RELEASE))\r\nreturn 0;\r\nerror = xfs_free_eofblocks(mp, ip, true);\r\nif (error)\r\nreturn error;\r\nif (ip->i_delayed_blks)\r\nxfs_iflags_set(ip, XFS_IDIRTY_RELEASE);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_inactive(\r\nxfs_inode_t *ip)\r\n{\r\nxfs_bmap_free_t free_list;\r\nxfs_fsblock_t first_block;\r\nint committed;\r\nxfs_trans_t *tp;\r\nxfs_mount_t *mp;\r\nint error;\r\nint truncate = 0;\r\nif (ip->i_d.di_mode == 0 || is_bad_inode(VFS_I(ip))) {\r\nASSERT(ip->i_df.if_real_bytes == 0);\r\nASSERT(ip->i_df.if_broot_bytes == 0);\r\nreturn VN_INACTIVE_CACHE;\r\n}\r\nmp = ip->i_mount;\r\nerror = 0;\r\nif (mp->m_flags & XFS_MOUNT_RDONLY)\r\ngoto out;\r\nif (ip->i_d.di_nlink != 0) {\r\nif ((S_ISREG(ip->i_d.di_mode) &&\r\n(VFS_I(ip)->i_size > 0 ||\r\n(VN_CACHED(VFS_I(ip)) > 0 || ip->i_delayed_blks > 0)) &&\r\n(ip->i_df.if_flags & XFS_IFEXTENTS) &&\r\n(!(ip->i_d.di_flags &\r\n(XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND)) ||\r\nip->i_delayed_blks != 0))) {\r\nerror = xfs_free_eofblocks(mp, ip, false);\r\nif (error)\r\nreturn VN_INACTIVE_CACHE;\r\n}\r\ngoto out;\r\n}\r\nif (S_ISREG(ip->i_d.di_mode) &&\r\n(ip->i_d.di_size != 0 || XFS_ISIZE(ip) != 0 ||\r\nip->i_d.di_nextents > 0 || ip->i_delayed_blks > 0))\r\ntruncate = 1;\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\nreturn VN_INACTIVE_CACHE;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\r\nerror = xfs_trans_reserve(tp, 0,\r\n(truncate || S_ISLNK(ip->i_d.di_mode)) ?\r\nXFS_ITRUNCATE_LOG_RES(mp) :\r\nXFS_IFREE_LOG_RES(mp),\r\n0,\r\nXFS_TRANS_PERM_LOG_RES,\r\nXFS_ITRUNCATE_LOG_COUNT);\r\nif (error) {\r\nASSERT(XFS_FORCED_SHUTDOWN(mp));\r\nxfs_trans_cancel(tp, 0);\r\nreturn VN_INACTIVE_CACHE;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, 0);\r\nif (S_ISLNK(ip->i_d.di_mode)) {\r\nif (ip->i_d.di_size > XFS_IFORK_DSIZE(ip)) {\r\nerror = xfs_inactive_symlink_rmt(ip, &tp);\r\nif (error)\r\ngoto out_cancel;\r\n} else if (ip->i_df.if_bytes > 0) {\r\nxfs_idata_realloc(ip, -(ip->i_df.if_bytes),\r\nXFS_DATA_FORK);\r\nASSERT(ip->i_df.if_bytes == 0);\r\n}\r\n} else if (truncate) {\r\nip->i_d.di_size = 0;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nerror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);\r\nif (error)\r\ngoto out_cancel;\r\nASSERT(ip->i_d.di_nextents == 0);\r\n}\r\nif (ip->i_d.di_anextents > 0) {\r\nASSERT(ip->i_d.di_forkoff != 0);\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nif (error)\r\ngoto out_unlock;\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nerror = xfs_attr_inactive(ip);\r\nif (error)\r\ngoto out;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\r\nerror = xfs_trans_reserve(tp, 0,\r\nXFS_IFREE_LOG_RES(mp),\r\n0, XFS_TRANS_PERM_LOG_RES,\r\nXFS_INACTIVE_LOG_COUNT);\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\ngoto out;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, 0);\r\n}\r\nif (ip->i_afp)\r\nxfs_idestroy_fork(ip, XFS_ATTR_FORK);\r\nASSERT(ip->i_d.di_anextents == 0);\r\nxfs_bmap_init(&free_list, &first_block);\r\nerror = xfs_ifree(tp, ip, &free_list);\r\nif (error) {\r\nif (!XFS_FORCED_SHUTDOWN(mp)) {\r\nxfs_notice(mp, "%s: xfs_ifree returned error %d",\r\n__func__, error);\r\nxfs_force_shutdown(mp, SHUTDOWN_META_IO_ERROR);\r\n}\r\nxfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\r\n} else {\r\nxfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_ICOUNT, -1);\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error)\r\nxfs_notice(mp, "%s: xfs_bmap_finish returned error %d",\r\n__func__, error);\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nif (error)\r\nxfs_notice(mp, "%s: xfs_trans_commit returned error %d",\r\n__func__, error);\r\n}\r\nxfs_qm_dqdetach(ip);\r\nout_unlock:\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nout:\r\nreturn VN_INACTIVE_CACHE;\r\nout_cancel:\r\nxfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\r\ngoto out_unlock;\r\n}\r\nint\r\nxfs_lookup(\r\nxfs_inode_t *dp,\r\nstruct xfs_name *name,\r\nxfs_inode_t **ipp,\r\nstruct xfs_name *ci_name)\r\n{\r\nxfs_ino_t inum;\r\nint error;\r\nuint lock_mode;\r\ntrace_xfs_lookup(dp, name);\r\nif (XFS_FORCED_SHUTDOWN(dp->i_mount))\r\nreturn XFS_ERROR(EIO);\r\nlock_mode = xfs_ilock_map_shared(dp);\r\nerror = xfs_dir_lookup(NULL, dp, name, &inum, ci_name);\r\nxfs_iunlock_map_shared(dp, lock_mode);\r\nif (error)\r\ngoto out;\r\nerror = xfs_iget(dp->i_mount, NULL, inum, 0, 0, ipp);\r\nif (error)\r\ngoto out_free_name;\r\nreturn 0;\r\nout_free_name:\r\nif (ci_name)\r\nkmem_free(ci_name->name);\r\nout:\r\n*ipp = NULL;\r\nreturn error;\r\n}\r\nint\r\nxfs_create(\r\nxfs_inode_t *dp,\r\nstruct xfs_name *name,\r\numode_t mode,\r\nxfs_dev_t rdev,\r\nxfs_inode_t **ipp)\r\n{\r\nint is_dir = S_ISDIR(mode);\r\nstruct xfs_mount *mp = dp->i_mount;\r\nstruct xfs_inode *ip = NULL;\r\nstruct xfs_trans *tp = NULL;\r\nint error;\r\nxfs_bmap_free_t free_list;\r\nxfs_fsblock_t first_block;\r\nboolean_t unlock_dp_on_error = B_FALSE;\r\nuint cancel_flags;\r\nint committed;\r\nprid_t prid;\r\nstruct xfs_dquot *udqp = NULL;\r\nstruct xfs_dquot *gdqp = NULL;\r\nuint resblks;\r\nuint log_res;\r\nuint log_count;\r\ntrace_xfs_create(dp, name);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn XFS_ERROR(EIO);\r\nif (dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)\r\nprid = xfs_get_projid(dp);\r\nelse\r\nprid = XFS_PROJID_DEFAULT;\r\nerror = xfs_qm_vop_dqalloc(dp, current_fsuid(), current_fsgid(), prid,\r\nXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT, &udqp, &gdqp);\r\nif (error)\r\nreturn error;\r\nif (is_dir) {\r\nrdev = 0;\r\nresblks = XFS_MKDIR_SPACE_RES(mp, name->len);\r\nlog_res = XFS_MKDIR_LOG_RES(mp);\r\nlog_count = XFS_MKDIR_LOG_COUNT;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_MKDIR);\r\n} else {\r\nresblks = XFS_CREATE_SPACE_RES(mp, name->len);\r\nlog_res = XFS_CREATE_LOG_RES(mp);\r\nlog_count = XFS_CREATE_LOG_COUNT;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_CREATE);\r\n}\r\ncancel_flags = XFS_TRANS_RELEASE_LOG_RES;\r\nerror = xfs_trans_reserve(tp, resblks, log_res, 0,\r\nXFS_TRANS_PERM_LOG_RES, log_count);\r\nif (error == ENOSPC) {\r\nxfs_flush_inodes(dp);\r\nerror = xfs_trans_reserve(tp, resblks, log_res, 0,\r\nXFS_TRANS_PERM_LOG_RES, log_count);\r\n}\r\nif (error == ENOSPC) {\r\nresblks = 0;\r\nerror = xfs_trans_reserve(tp, 0, log_res, 0,\r\nXFS_TRANS_PERM_LOG_RES, log_count);\r\n}\r\nif (error) {\r\ncancel_flags = 0;\r\ngoto out_trans_cancel;\r\n}\r\nxfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\r\nunlock_dp_on_error = B_TRUE;\r\nxfs_bmap_init(&free_list, &first_block);\r\nerror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp, resblks, 1, 0);\r\nif (error)\r\ngoto out_trans_cancel;\r\nerror = xfs_dir_canenter(tp, dp, name, resblks);\r\nif (error)\r\ngoto out_trans_cancel;\r\nerror = xfs_dir_ialloc(&tp, dp, mode, is_dir ? 2 : 1, rdev,\r\nprid, resblks > 0, &ip, &committed);\r\nif (error) {\r\nif (error == ENOSPC)\r\ngoto out_trans_cancel;\r\ngoto out_trans_abort;\r\n}\r\nxfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\r\nunlock_dp_on_error = B_FALSE;\r\nerror = xfs_dir_createname(tp, dp, name, ip->i_ino,\r\n&first_block, &free_list, resblks ?\r\nresblks - XFS_IALLOC_SPACE_RES(mp) : 0);\r\nif (error) {\r\nASSERT(error != ENOSPC);\r\ngoto out_trans_abort;\r\n}\r\nxfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\r\nxfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\r\nif (is_dir) {\r\nerror = xfs_dir_init(tp, ip, dp);\r\nif (error)\r\ngoto out_bmap_cancel;\r\nerror = xfs_bumplink(tp, dp);\r\nif (error)\r\ngoto out_bmap_cancel;\r\n}\r\nif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))\r\nxfs_trans_set_sync(tp);\r\nxfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp);\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error)\r\ngoto out_bmap_cancel;\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nif (error)\r\ngoto out_release_inode;\r\nxfs_qm_dqrele(udqp);\r\nxfs_qm_dqrele(gdqp);\r\n*ipp = ip;\r\nreturn 0;\r\nout_bmap_cancel:\r\nxfs_bmap_cancel(&free_list);\r\nout_trans_abort:\r\ncancel_flags |= XFS_TRANS_ABORT;\r\nout_trans_cancel:\r\nxfs_trans_cancel(tp, cancel_flags);\r\nout_release_inode:\r\nif (ip)\r\nIRELE(ip);\r\nxfs_qm_dqrele(udqp);\r\nxfs_qm_dqrele(gdqp);\r\nif (unlock_dp_on_error)\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn error;\r\n}\r\nstatic inline int\r\nxfs_lock_inumorder(int lock_mode, int subclass)\r\n{\r\nif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\r\nlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_IOLOCK_SHIFT;\r\nif (lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL))\r\nlock_mode |= (subclass + XFS_LOCK_INUMORDER) << XFS_ILOCK_SHIFT;\r\nreturn lock_mode;\r\n}\r\nvoid\r\nxfs_lock_inodes(\r\nxfs_inode_t **ips,\r\nint inodes,\r\nuint lock_mode)\r\n{\r\nint attempts = 0, i, j, try_lock;\r\nxfs_log_item_t *lp;\r\nASSERT(ips && (inodes >= 2));\r\ntry_lock = 0;\r\ni = 0;\r\nagain:\r\nfor (; i < inodes; i++) {\r\nASSERT(ips[i]);\r\nif (i && (ips[i] == ips[i-1]))\r\ncontinue;\r\nif (!try_lock) {\r\nfor (j = (i - 1); j >= 0 && !try_lock; j--) {\r\nlp = (xfs_log_item_t *)ips[j]->i_itemp;\r\nif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\r\ntry_lock++;\r\n}\r\n}\r\n}\r\nif (try_lock) {\r\nASSERT(i != 0);\r\nif (!xfs_ilock_nowait(ips[i], xfs_lock_inumorder(lock_mode, i))) {\r\nattempts++;\r\nfor(j = i - 1; j >= 0; j--) {\r\nif ((j != (i - 1)) && ips[j] ==\r\nips[j+1])\r\ncontinue;\r\nxfs_iunlock(ips[j], lock_mode);\r\n}\r\nif ((attempts % 5) == 0) {\r\ndelay(1);\r\n#ifdef DEBUG\r\nxfs_lock_delays++;\r\n#endif\r\n}\r\ni = 0;\r\ntry_lock = 0;\r\ngoto again;\r\n}\r\n} else {\r\nxfs_ilock(ips[i], xfs_lock_inumorder(lock_mode, i));\r\n}\r\n}\r\n#ifdef DEBUG\r\nif (attempts) {\r\nif (attempts < 5) xfs_small_retries++;\r\nelse if (attempts < 100) xfs_middle_retries++;\r\nelse xfs_lots_retries++;\r\n} else {\r\nxfs_locked_n++;\r\n}\r\n#endif\r\n}\r\nvoid\r\nxfs_lock_two_inodes(\r\nxfs_inode_t *ip0,\r\nxfs_inode_t *ip1,\r\nuint lock_mode)\r\n{\r\nxfs_inode_t *temp;\r\nint attempts = 0;\r\nxfs_log_item_t *lp;\r\nif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\r\nASSERT((lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL)) == 0);\r\nASSERT(ip0->i_ino != ip1->i_ino);\r\nif (ip0->i_ino > ip1->i_ino) {\r\ntemp = ip0;\r\nip0 = ip1;\r\nip1 = temp;\r\n}\r\nagain:\r\nxfs_ilock(ip0, xfs_lock_inumorder(lock_mode, 0));\r\nlp = (xfs_log_item_t *)ip0->i_itemp;\r\nif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\r\nif (!xfs_ilock_nowait(ip1, xfs_lock_inumorder(lock_mode, 1))) {\r\nxfs_iunlock(ip0, lock_mode);\r\nif ((++attempts % 5) == 0)\r\ndelay(1);\r\ngoto again;\r\n}\r\n} else {\r\nxfs_ilock(ip1, xfs_lock_inumorder(lock_mode, 1));\r\n}\r\n}\r\nint\r\nxfs_remove(\r\nxfs_inode_t *dp,\r\nstruct xfs_name *name,\r\nxfs_inode_t *ip)\r\n{\r\nxfs_mount_t *mp = dp->i_mount;\r\nxfs_trans_t *tp = NULL;\r\nint is_dir = S_ISDIR(ip->i_d.di_mode);\r\nint error = 0;\r\nxfs_bmap_free_t free_list;\r\nxfs_fsblock_t first_block;\r\nint cancel_flags;\r\nint committed;\r\nint link_zero;\r\nuint resblks;\r\nuint log_count;\r\ntrace_xfs_remove(dp, name);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn XFS_ERROR(EIO);\r\nerror = xfs_qm_dqattach(dp, 0);\r\nif (error)\r\ngoto std_return;\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\ngoto std_return;\r\nif (is_dir) {\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_RMDIR);\r\nlog_count = XFS_DEFAULT_LOG_COUNT;\r\n} else {\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_REMOVE);\r\nlog_count = XFS_REMOVE_LOG_COUNT;\r\n}\r\ncancel_flags = XFS_TRANS_RELEASE_LOG_RES;\r\nresblks = XFS_REMOVE_SPACE_RES(mp);\r\nerror = xfs_trans_reserve(tp, resblks, XFS_REMOVE_LOG_RES(mp), 0,\r\nXFS_TRANS_PERM_LOG_RES, log_count);\r\nif (error == ENOSPC) {\r\nresblks = 0;\r\nerror = xfs_trans_reserve(tp, 0, XFS_REMOVE_LOG_RES(mp), 0,\r\nXFS_TRANS_PERM_LOG_RES, log_count);\r\n}\r\nif (error) {\r\nASSERT(error != ENOSPC);\r\ncancel_flags = 0;\r\ngoto out_trans_cancel;\r\n}\r\nxfs_lock_two_inodes(dp, ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\r\nif (is_dir) {\r\nASSERT(ip->i_d.di_nlink >= 2);\r\nif (ip->i_d.di_nlink != 2) {\r\nerror = XFS_ERROR(ENOTEMPTY);\r\ngoto out_trans_cancel;\r\n}\r\nif (!xfs_dir_isempty(ip)) {\r\nerror = XFS_ERROR(ENOTEMPTY);\r\ngoto out_trans_cancel;\r\n}\r\n}\r\nxfs_bmap_init(&free_list, &first_block);\r\nerror = xfs_dir_removename(tp, dp, name, ip->i_ino,\r\n&first_block, &free_list, resblks);\r\nif (error) {\r\nASSERT(error != ENOENT);\r\ngoto out_bmap_cancel;\r\n}\r\nxfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\r\nif (is_dir) {\r\nerror = xfs_droplink(tp, dp);\r\nif (error)\r\ngoto out_bmap_cancel;\r\nerror = xfs_droplink(tp, ip);\r\nif (error)\r\ngoto out_bmap_cancel;\r\n} else {\r\nxfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\r\n}\r\nerror = xfs_droplink(tp, ip);\r\nif (error)\r\ngoto out_bmap_cancel;\r\nlink_zero = (ip->i_d.di_nlink == 0);\r\nif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))\r\nxfs_trans_set_sync(tp);\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error)\r\ngoto out_bmap_cancel;\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nif (error)\r\ngoto std_return;\r\nif (!is_dir && link_zero && xfs_inode_is_filestream(ip))\r\nxfs_filestream_deassociate(ip);\r\nreturn 0;\r\nout_bmap_cancel:\r\nxfs_bmap_cancel(&free_list);\r\ncancel_flags |= XFS_TRANS_ABORT;\r\nout_trans_cancel:\r\nxfs_trans_cancel(tp, cancel_flags);\r\nstd_return:\r\nreturn error;\r\n}\r\nint\r\nxfs_link(\r\nxfs_inode_t *tdp,\r\nxfs_inode_t *sip,\r\nstruct xfs_name *target_name)\r\n{\r\nxfs_mount_t *mp = tdp->i_mount;\r\nxfs_trans_t *tp;\r\nint error;\r\nxfs_bmap_free_t free_list;\r\nxfs_fsblock_t first_block;\r\nint cancel_flags;\r\nint committed;\r\nint resblks;\r\ntrace_xfs_link(tdp, target_name);\r\nASSERT(!S_ISDIR(sip->i_d.di_mode));\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn XFS_ERROR(EIO);\r\nerror = xfs_qm_dqattach(sip, 0);\r\nif (error)\r\ngoto std_return;\r\nerror = xfs_qm_dqattach(tdp, 0);\r\nif (error)\r\ngoto std_return;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_LINK);\r\ncancel_flags = XFS_TRANS_RELEASE_LOG_RES;\r\nresblks = XFS_LINK_SPACE_RES(mp, target_name->len);\r\nerror = xfs_trans_reserve(tp, resblks, XFS_LINK_LOG_RES(mp), 0,\r\nXFS_TRANS_PERM_LOG_RES, XFS_LINK_LOG_COUNT);\r\nif (error == ENOSPC) {\r\nresblks = 0;\r\nerror = xfs_trans_reserve(tp, 0, XFS_LINK_LOG_RES(mp), 0,\r\nXFS_TRANS_PERM_LOG_RES, XFS_LINK_LOG_COUNT);\r\n}\r\nif (error) {\r\ncancel_flags = 0;\r\ngoto error_return;\r\n}\r\nxfs_lock_two_inodes(sip, tdp, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, sip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, tdp, XFS_ILOCK_EXCL);\r\nif (unlikely((tdp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\r\n(xfs_get_projid(tdp) != xfs_get_projid(sip)))) {\r\nerror = XFS_ERROR(EXDEV);\r\ngoto error_return;\r\n}\r\nerror = xfs_dir_canenter(tp, tdp, target_name, resblks);\r\nif (error)\r\ngoto error_return;\r\nxfs_bmap_init(&free_list, &first_block);\r\nerror = xfs_dir_createname(tp, tdp, target_name, sip->i_ino,\r\n&first_block, &free_list, resblks);\r\nif (error)\r\ngoto abort_return;\r\nxfs_trans_ichgtime(tp, tdp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\r\nxfs_trans_log_inode(tp, tdp, XFS_ILOG_CORE);\r\nerror = xfs_bumplink(tp, sip);\r\nif (error)\r\ngoto abort_return;\r\nif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\r\nxfs_trans_set_sync(tp);\r\n}\r\nerror = xfs_bmap_finish (&tp, &free_list, &committed);\r\nif (error) {\r\nxfs_bmap_cancel(&free_list);\r\ngoto abort_return;\r\n}\r\nreturn xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nabort_return:\r\ncancel_flags |= XFS_TRANS_ABORT;\r\nerror_return:\r\nxfs_trans_cancel(tp, cancel_flags);\r\nstd_return:\r\nreturn error;\r\n}\r\nint\r\nxfs_symlink(\r\nxfs_inode_t *dp,\r\nstruct xfs_name *link_name,\r\nconst char *target_path,\r\numode_t mode,\r\nxfs_inode_t **ipp)\r\n{\r\nxfs_mount_t *mp = dp->i_mount;\r\nxfs_trans_t *tp;\r\nxfs_inode_t *ip;\r\nint error;\r\nint pathlen;\r\nxfs_bmap_free_t free_list;\r\nxfs_fsblock_t first_block;\r\nboolean_t unlock_dp_on_error = B_FALSE;\r\nuint cancel_flags;\r\nint committed;\r\nxfs_fileoff_t first_fsb;\r\nxfs_filblks_t fs_blocks;\r\nint nmaps;\r\nxfs_bmbt_irec_t mval[SYMLINK_MAPS];\r\nxfs_daddr_t d;\r\nconst char *cur_chunk;\r\nint byte_cnt;\r\nint n;\r\nxfs_buf_t *bp;\r\nprid_t prid;\r\nstruct xfs_dquot *udqp, *gdqp;\r\nuint resblks;\r\n*ipp = NULL;\r\nerror = 0;\r\nip = NULL;\r\ntp = NULL;\r\ntrace_xfs_symlink(dp, link_name);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn XFS_ERROR(EIO);\r\npathlen = strlen(target_path);\r\nif (pathlen >= MAXPATHLEN)\r\nreturn XFS_ERROR(ENAMETOOLONG);\r\nudqp = gdqp = NULL;\r\nif (dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)\r\nprid = xfs_get_projid(dp);\r\nelse\r\nprid = XFS_PROJID_DEFAULT;\r\nerror = xfs_qm_vop_dqalloc(dp, current_fsuid(), current_fsgid(), prid,\r\nXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT, &udqp, &gdqp);\r\nif (error)\r\ngoto std_return;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_SYMLINK);\r\ncancel_flags = XFS_TRANS_RELEASE_LOG_RES;\r\nif (pathlen <= XFS_LITINO(mp))\r\nfs_blocks = 0;\r\nelse\r\nfs_blocks = XFS_B_TO_FSB(mp, pathlen);\r\nresblks = XFS_SYMLINK_SPACE_RES(mp, link_name->len, fs_blocks);\r\nerror = xfs_trans_reserve(tp, resblks, XFS_SYMLINK_LOG_RES(mp), 0,\r\nXFS_TRANS_PERM_LOG_RES, XFS_SYMLINK_LOG_COUNT);\r\nif (error == ENOSPC && fs_blocks == 0) {\r\nresblks = 0;\r\nerror = xfs_trans_reserve(tp, 0, XFS_SYMLINK_LOG_RES(mp), 0,\r\nXFS_TRANS_PERM_LOG_RES, XFS_SYMLINK_LOG_COUNT);\r\n}\r\nif (error) {\r\ncancel_flags = 0;\r\ngoto error_return;\r\n}\r\nxfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\r\nunlock_dp_on_error = B_TRUE;\r\nif (dp->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) {\r\nerror = XFS_ERROR(EPERM);\r\ngoto error_return;\r\n}\r\nerror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp, resblks, 1, 0);\r\nif (error)\r\ngoto error_return;\r\nerror = xfs_dir_canenter(tp, dp, link_name, resblks);\r\nif (error)\r\ngoto error_return;\r\nxfs_bmap_init(&free_list, &first_block);\r\nerror = xfs_dir_ialloc(&tp, dp, S_IFLNK | (mode & ~S_IFMT), 1, 0,\r\nprid, resblks > 0, &ip, NULL);\r\nif (error) {\r\nif (error == ENOSPC)\r\ngoto error_return;\r\ngoto error1;\r\n}\r\nxfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\r\nunlock_dp_on_error = B_FALSE;\r\nxfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp);\r\nif (resblks)\r\nresblks -= XFS_IALLOC_SPACE_RES(mp);\r\nif (pathlen <= XFS_IFORK_DSIZE(ip)) {\r\nxfs_idata_realloc(ip, pathlen, XFS_DATA_FORK);\r\nmemcpy(ip->i_df.if_u1.if_data, target_path, pathlen);\r\nip->i_d.di_size = pathlen;\r\nip->i_df.if_flags &= ~(XFS_IFEXTENTS | XFS_IFBROOT);\r\nip->i_df.if_flags |= XFS_IFINLINE;\r\nip->i_d.di_format = XFS_DINODE_FMT_LOCAL;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_DDATA | XFS_ILOG_CORE);\r\n} else {\r\nfirst_fsb = 0;\r\nnmaps = SYMLINK_MAPS;\r\nerror = xfs_bmapi_write(tp, ip, first_fsb, fs_blocks,\r\nXFS_BMAPI_METADATA, &first_block, resblks,\r\nmval, &nmaps, &free_list);\r\nif (error)\r\ngoto error2;\r\nif (resblks)\r\nresblks -= fs_blocks;\r\nip->i_d.di_size = pathlen;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\ncur_chunk = target_path;\r\nfor (n = 0; n < nmaps; n++) {\r\nd = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\r\nbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\r\nbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\r\nBTOBB(byte_cnt), 0);\r\nif (!bp) {\r\nerror = ENOMEM;\r\ngoto error2;\r\n}\r\nif (pathlen < byte_cnt) {\r\nbyte_cnt = pathlen;\r\n}\r\npathlen -= byte_cnt;\r\nmemcpy(bp->b_addr, cur_chunk, byte_cnt);\r\ncur_chunk += byte_cnt;\r\nxfs_trans_log_buf(tp, bp, 0, byte_cnt - 1);\r\n}\r\n}\r\nerror = xfs_dir_createname(tp, dp, link_name, ip->i_ino,\r\n&first_block, &free_list, resblks);\r\nif (error)\r\ngoto error2;\r\nxfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\r\nxfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\r\nif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\r\nxfs_trans_set_sync(tp);\r\n}\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error) {\r\ngoto error2;\r\n}\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nxfs_qm_dqrele(udqp);\r\nxfs_qm_dqrele(gdqp);\r\n*ipp = ip;\r\nreturn 0;\r\nerror2:\r\nIRELE(ip);\r\nerror1:\r\nxfs_bmap_cancel(&free_list);\r\ncancel_flags |= XFS_TRANS_ABORT;\r\nerror_return:\r\nxfs_trans_cancel(tp, cancel_flags);\r\nxfs_qm_dqrele(udqp);\r\nxfs_qm_dqrele(gdqp);\r\nif (unlock_dp_on_error)\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nstd_return:\r\nreturn error;\r\n}\r\nint\r\nxfs_set_dmattrs(\r\nxfs_inode_t *ip,\r\nu_int evmask,\r\nu_int16_t state)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nxfs_trans_t *tp;\r\nint error;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn XFS_ERROR(EPERM);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn XFS_ERROR(EIO);\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_SET_DMATTRS);\r\nerror = xfs_trans_reserve(tp, 0, XFS_ICHANGE_LOG_RES (mp), 0, 0, 0);\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\nreturn error;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\r\nip->i_d.di_dmevmask = evmask;\r\nip->i_d.di_dmstate = state;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nerror = xfs_trans_commit(tp, 0);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_alloc_file_space(\r\nxfs_inode_t *ip,\r\nxfs_off_t offset,\r\nxfs_off_t len,\r\nint alloc_type,\r\nint attr_flags)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nxfs_off_t count;\r\nxfs_filblks_t allocated_fsb;\r\nxfs_filblks_t allocatesize_fsb;\r\nxfs_extlen_t extsz, temp;\r\nxfs_fileoff_t startoffset_fsb;\r\nxfs_fsblock_t firstfsb;\r\nint nimaps;\r\nint quota_flag;\r\nint rt;\r\nxfs_trans_t *tp;\r\nxfs_bmbt_irec_t imaps[1], *imapp;\r\nxfs_bmap_free_t free_list;\r\nuint qblocks, resblks, resrtextents;\r\nint committed;\r\nint error;\r\ntrace_xfs_alloc_file_space(ip);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn XFS_ERROR(EIO);\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\nreturn error;\r\nif (len <= 0)\r\nreturn XFS_ERROR(EINVAL);\r\nrt = XFS_IS_REALTIME_INODE(ip);\r\nextsz = xfs_get_extsz_hint(ip);\r\ncount = len;\r\nimapp = &imaps[0];\r\nnimaps = 1;\r\nstartoffset_fsb = XFS_B_TO_FSBT(mp, offset);\r\nallocatesize_fsb = XFS_B_TO_FSB(mp, count);\r\nwhile (allocatesize_fsb && !error) {\r\nxfs_fileoff_t s, e;\r\nif (unlikely(extsz)) {\r\ns = startoffset_fsb;\r\ndo_div(s, extsz);\r\ns *= extsz;\r\ne = startoffset_fsb + allocatesize_fsb;\r\nif ((temp = do_mod(startoffset_fsb, extsz)))\r\ne += temp;\r\nif ((temp = do_mod(e, extsz)))\r\ne += extsz - temp;\r\n} else {\r\ns = 0;\r\ne = allocatesize_fsb;\r\n}\r\nresblks = min_t(xfs_fileoff_t, (e - s), (MAXEXTLEN * nimaps));\r\nif (unlikely(rt)) {\r\nresrtextents = qblocks = resblks;\r\nresrtextents /= mp->m_sb.sb_rextsize;\r\nresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\r\nquota_flag = XFS_QMOPT_RES_RTBLKS;\r\n} else {\r\nresrtextents = 0;\r\nresblks = qblocks = XFS_DIOSTRAT_SPACE_RES(mp, resblks);\r\nquota_flag = XFS_QMOPT_RES_REGBLKS;\r\n}\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\r\nerror = xfs_trans_reserve(tp, resblks,\r\nXFS_WRITE_LOG_RES(mp), resrtextents,\r\nXFS_TRANS_PERM_LOG_RES,\r\nXFS_WRITE_LOG_COUNT);\r\nif (error) {\r\nASSERT(error == ENOSPC || XFS_FORCED_SHUTDOWN(mp));\r\nxfs_trans_cancel(tp, 0);\r\nbreak;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nerror = xfs_trans_reserve_quota_nblks(tp, ip, qblocks,\r\n0, quota_flag);\r\nif (error)\r\ngoto error1;\r\nxfs_trans_ijoin(tp, ip, 0);\r\nxfs_bmap_init(&free_list, &firstfsb);\r\nerror = xfs_bmapi_write(tp, ip, startoffset_fsb,\r\nallocatesize_fsb, alloc_type, &firstfsb,\r\n0, imapp, &nimaps, &free_list);\r\nif (error) {\r\ngoto error0;\r\n}\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error) {\r\ngoto error0;\r\n}\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nif (error) {\r\nbreak;\r\n}\r\nallocated_fsb = imapp->br_blockcount;\r\nif (nimaps == 0) {\r\nerror = XFS_ERROR(ENOSPC);\r\nbreak;\r\n}\r\nstartoffset_fsb += allocated_fsb;\r\nallocatesize_fsb -= allocated_fsb;\r\n}\r\nreturn error;\r\nerror0:\r\nxfs_bmap_cancel(&free_list);\r\nxfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);\r\nerror1:\r\nxfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_zero_remaining_bytes(\r\nxfs_inode_t *ip,\r\nxfs_off_t startoff,\r\nxfs_off_t endoff)\r\n{\r\nxfs_bmbt_irec_t imap;\r\nxfs_fileoff_t offset_fsb;\r\nxfs_off_t lastoffset;\r\nxfs_off_t offset;\r\nxfs_buf_t *bp;\r\nxfs_mount_t *mp = ip->i_mount;\r\nint nimap;\r\nint error = 0;\r\nif (startoff >= XFS_ISIZE(ip))\r\nreturn 0;\r\nif (endoff > XFS_ISIZE(ip))\r\nendoff = XFS_ISIZE(ip);\r\nbp = xfs_buf_get_uncached(XFS_IS_REALTIME_INODE(ip) ?\r\nmp->m_rtdev_targp : mp->m_ddev_targp,\r\nBTOBB(mp->m_sb.sb_blocksize), 0);\r\nif (!bp)\r\nreturn XFS_ERROR(ENOMEM);\r\nxfs_buf_unlock(bp);\r\nfor (offset = startoff; offset <= endoff; offset = lastoffset + 1) {\r\noffset_fsb = XFS_B_TO_FSBT(mp, offset);\r\nnimap = 1;\r\nerror = xfs_bmapi_read(ip, offset_fsb, 1, &imap, &nimap, 0);\r\nif (error || nimap < 1)\r\nbreak;\r\nASSERT(imap.br_blockcount >= 1);\r\nASSERT(imap.br_startoff == offset_fsb);\r\nlastoffset = XFS_FSB_TO_B(mp, imap.br_startoff + 1) - 1;\r\nif (lastoffset > endoff)\r\nlastoffset = endoff;\r\nif (imap.br_startblock == HOLESTARTBLOCK)\r\ncontinue;\r\nASSERT(imap.br_startblock != DELAYSTARTBLOCK);\r\nif (imap.br_state == XFS_EXT_UNWRITTEN)\r\ncontinue;\r\nXFS_BUF_UNDONE(bp);\r\nXFS_BUF_UNWRITE(bp);\r\nXFS_BUF_READ(bp);\r\nXFS_BUF_SET_ADDR(bp, xfs_fsb_to_db(ip, imap.br_startblock));\r\nxfsbdstrat(mp, bp);\r\nerror = xfs_buf_iowait(bp);\r\nif (error) {\r\nxfs_buf_ioerror_alert(bp,\r\n"xfs_zero_remaining_bytes(read)");\r\nbreak;\r\n}\r\nmemset(bp->b_addr +\r\n(offset - XFS_FSB_TO_B(mp, imap.br_startoff)),\r\n0, lastoffset - offset + 1);\r\nXFS_BUF_UNDONE(bp);\r\nXFS_BUF_UNREAD(bp);\r\nXFS_BUF_WRITE(bp);\r\nxfsbdstrat(mp, bp);\r\nerror = xfs_buf_iowait(bp);\r\nif (error) {\r\nxfs_buf_ioerror_alert(bp,\r\n"xfs_zero_remaining_bytes(write)");\r\nbreak;\r\n}\r\n}\r\nxfs_buf_free(bp);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_free_file_space(\r\nxfs_inode_t *ip,\r\nxfs_off_t offset,\r\nxfs_off_t len,\r\nint attr_flags)\r\n{\r\nint committed;\r\nint done;\r\nxfs_fileoff_t endoffset_fsb;\r\nint error;\r\nxfs_fsblock_t firstfsb;\r\nxfs_bmap_free_t free_list;\r\nxfs_bmbt_irec_t imap;\r\nxfs_off_t ioffset;\r\nxfs_extlen_t mod=0;\r\nxfs_mount_t *mp;\r\nint nimap;\r\nuint resblks;\r\nuint rounding;\r\nint rt;\r\nxfs_fileoff_t startoffset_fsb;\r\nxfs_trans_t *tp;\r\nint need_iolock = 1;\r\nmp = ip->i_mount;\r\ntrace_xfs_free_file_space(ip);\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\nreturn error;\r\nerror = 0;\r\nif (len <= 0)\r\nreturn error;\r\nrt = XFS_IS_REALTIME_INODE(ip);\r\nstartoffset_fsb = XFS_B_TO_FSB(mp, offset);\r\nendoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);\r\nif (attr_flags & XFS_ATTR_NOLOCK)\r\nneed_iolock = 0;\r\nif (need_iolock) {\r\nxfs_ilock(ip, XFS_IOLOCK_EXCL);\r\ninode_dio_wait(VFS_I(ip));\r\n}\r\nrounding = max_t(uint, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);\r\nioffset = offset & ~(rounding - 1);\r\nif (VN_CACHED(VFS_I(ip)) != 0) {\r\nerror = xfs_flushinval_pages(ip, ioffset, -1, FI_REMAPF_LOCKED);\r\nif (error)\r\ngoto out_unlock_iolock;\r\n}\r\nif (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\r\nnimap = 1;\r\nerror = xfs_bmapi_read(ip, startoffset_fsb, 1,\r\n&imap, &nimap, 0);\r\nif (error)\r\ngoto out_unlock_iolock;\r\nASSERT(nimap == 0 || nimap == 1);\r\nif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\r\nxfs_daddr_t block;\r\nASSERT(imap.br_startblock != DELAYSTARTBLOCK);\r\nblock = imap.br_startblock;\r\nmod = do_div(block, mp->m_sb.sb_rextsize);\r\nif (mod)\r\nstartoffset_fsb += mp->m_sb.sb_rextsize - mod;\r\n}\r\nnimap = 1;\r\nerror = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,\r\n&imap, &nimap, 0);\r\nif (error)\r\ngoto out_unlock_iolock;\r\nASSERT(nimap == 0 || nimap == 1);\r\nif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\r\nASSERT(imap.br_startblock != DELAYSTARTBLOCK);\r\nmod++;\r\nif (mod && (mod != mp->m_sb.sb_rextsize))\r\nendoffset_fsb -= mod;\r\n}\r\n}\r\nif ((done = (endoffset_fsb <= startoffset_fsb)))\r\nerror = xfs_zero_remaining_bytes(ip, offset, offset + len - 1);\r\nelse {\r\nif (offset < XFS_FSB_TO_B(mp, startoffset_fsb))\r\nerror = xfs_zero_remaining_bytes(ip, offset,\r\nXFS_FSB_TO_B(mp, startoffset_fsb) - 1);\r\nif (!error &&\r\nXFS_FSB_TO_B(mp, endoffset_fsb) < offset + len)\r\nerror = xfs_zero_remaining_bytes(ip,\r\nXFS_FSB_TO_B(mp, endoffset_fsb),\r\noffset + len - 1);\r\n}\r\nresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\r\nwhile (!error && !done) {\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\r\ntp->t_flags |= XFS_TRANS_RESERVE;\r\nerror = xfs_trans_reserve(tp,\r\nresblks,\r\nXFS_WRITE_LOG_RES(mp),\r\n0,\r\nXFS_TRANS_PERM_LOG_RES,\r\nXFS_WRITE_LOG_COUNT);\r\nif (error) {\r\nASSERT(error == ENOSPC || XFS_FORCED_SHUTDOWN(mp));\r\nxfs_trans_cancel(tp, 0);\r\nbreak;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nerror = xfs_trans_reserve_quota(tp, mp,\r\nip->i_udquot, ip->i_gdquot,\r\nresblks, 0, XFS_QMOPT_RES_REGBLKS);\r\nif (error)\r\ngoto error1;\r\nxfs_trans_ijoin(tp, ip, 0);\r\nxfs_bmap_init(&free_list, &firstfsb);\r\nerror = xfs_bunmapi(tp, ip, startoffset_fsb,\r\nendoffset_fsb - startoffset_fsb,\r\n0, 2, &firstfsb, &free_list, &done);\r\nif (error) {\r\ngoto error0;\r\n}\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error) {\r\ngoto error0;\r\n}\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\n}\r\nout_unlock_iolock:\r\nif (need_iolock)\r\nxfs_iunlock(ip, XFS_IOLOCK_EXCL);\r\nreturn error;\r\nerror0:\r\nxfs_bmap_cancel(&free_list);\r\nerror1:\r\nxfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\r\nxfs_iunlock(ip, need_iolock ? (XFS_ILOCK_EXCL | XFS_IOLOCK_EXCL) :\r\nXFS_ILOCK_EXCL);\r\nreturn error;\r\n}\r\nint\r\nxfs_change_file_space(\r\nxfs_inode_t *ip,\r\nint cmd,\r\nxfs_flock64_t *bf,\r\nxfs_off_t offset,\r\nint attr_flags)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nint clrprealloc;\r\nint error;\r\nxfs_fsize_t fsize;\r\nint setprealloc;\r\nxfs_off_t startoffset;\r\nxfs_off_t llen;\r\nxfs_trans_t *tp;\r\nstruct iattr iattr;\r\nint prealloc_type;\r\nif (!S_ISREG(ip->i_d.di_mode))\r\nreturn XFS_ERROR(EINVAL);\r\nswitch (bf->l_whence) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nbf->l_start += offset;\r\nbreak;\r\ncase 2:\r\nbf->l_start += XFS_ISIZE(ip);\r\nbreak;\r\ndefault:\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nllen = bf->l_len > 0 ? bf->l_len - 1 : bf->l_len;\r\nif (bf->l_start < 0 ||\r\nbf->l_start > mp->m_super->s_maxbytes ||\r\nbf->l_start + llen < 0 ||\r\nbf->l_start + llen > mp->m_super->s_maxbytes)\r\nreturn XFS_ERROR(EINVAL);\r\nbf->l_whence = 0;\r\nstartoffset = bf->l_start;\r\nfsize = XFS_ISIZE(ip);\r\nsetprealloc = clrprealloc = 0;\r\nprealloc_type = XFS_BMAPI_PREALLOC;\r\nswitch (cmd) {\r\ncase XFS_IOC_ZERO_RANGE:\r\nprealloc_type |= XFS_BMAPI_CONVERT;\r\nxfs_tosspages(ip, startoffset, startoffset + bf->l_len, 0);\r\ncase XFS_IOC_RESVSP:\r\ncase XFS_IOC_RESVSP64:\r\nerror = xfs_alloc_file_space(ip, startoffset, bf->l_len,\r\nprealloc_type, attr_flags);\r\nif (error)\r\nreturn error;\r\nsetprealloc = 1;\r\nbreak;\r\ncase XFS_IOC_UNRESVSP:\r\ncase XFS_IOC_UNRESVSP64:\r\nif ((error = xfs_free_file_space(ip, startoffset, bf->l_len,\r\nattr_flags)))\r\nreturn error;\r\nbreak;\r\ncase XFS_IOC_ALLOCSP:\r\ncase XFS_IOC_ALLOCSP64:\r\ncase XFS_IOC_FREESP:\r\ncase XFS_IOC_FREESP64:\r\nxfs_ilock(ip, XFS_IOLOCK_EXCL);\r\nif (startoffset > fsize) {\r\nerror = xfs_alloc_file_space(ip, fsize,\r\nstartoffset - fsize, 0,\r\nattr_flags | XFS_ATTR_NOLOCK);\r\nif (error) {\r\nxfs_iunlock(ip, XFS_IOLOCK_EXCL);\r\nbreak;\r\n}\r\n}\r\niattr.ia_valid = ATTR_SIZE;\r\niattr.ia_size = startoffset;\r\nerror = xfs_setattr_size(ip, &iattr,\r\nattr_flags | XFS_ATTR_NOLOCK);\r\nxfs_iunlock(ip, XFS_IOLOCK_EXCL);\r\nif (error)\r\nreturn error;\r\nclrprealloc = 1;\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_WRITEID);\r\nif ((error = xfs_trans_reserve(tp, 0, XFS_WRITEID_LOG_RES(mp),\r\n0, 0, 0))) {\r\nxfs_trans_cancel(tp, 0);\r\nreturn error;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\r\nif ((attr_flags & XFS_ATTR_DMI) == 0) {\r\nip->i_d.di_mode &= ~S_ISUID;\r\nif (ip->i_d.di_mode & S_IXGRP)\r\nip->i_d.di_mode &= ~S_ISGID;\r\nxfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\r\n}\r\nif (setprealloc)\r\nip->i_d.di_flags |= XFS_DIFLAG_PREALLOC;\r\nelse if (clrprealloc)\r\nip->i_d.di_flags &= ~XFS_DIFLAG_PREALLOC;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nif (attr_flags & XFS_ATTR_SYNC)\r\nxfs_trans_set_sync(tp);\r\nreturn xfs_trans_commit(tp, 0);\r\n}
