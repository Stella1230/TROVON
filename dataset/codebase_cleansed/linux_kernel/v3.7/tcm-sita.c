struct tcm *sita_init(u16 width, u16 height, struct tcm_pt *attr)\r\n{\r\nstruct tcm *tcm;\r\nstruct sita_pvt *pvt;\r\nstruct tcm_area area = {0};\r\ns32 i;\r\nif (width == 0 || height == 0)\r\nreturn NULL;\r\ntcm = kmalloc(sizeof(*tcm), GFP_KERNEL);\r\npvt = kmalloc(sizeof(*pvt), GFP_KERNEL);\r\nif (!tcm || !pvt)\r\ngoto error;\r\nmemset(tcm, 0, sizeof(*tcm));\r\nmemset(pvt, 0, sizeof(*pvt));\r\ntcm->height = height;\r\ntcm->width = width;\r\ntcm->reserve_2d = sita_reserve_2d;\r\ntcm->reserve_1d = sita_reserve_1d;\r\ntcm->free = sita_free;\r\ntcm->deinit = sita_deinit;\r\ntcm->pvt = (void *)pvt;\r\nspin_lock_init(&(pvt->lock));\r\npvt->map = kmalloc(sizeof(*pvt->map) * tcm->width, GFP_KERNEL);\r\nif (!pvt->map)\r\ngoto error;\r\nfor (i = 0; i < tcm->width; i++) {\r\npvt->map[i] =\r\nkmalloc(sizeof(**pvt->map) * tcm->height,\r\nGFP_KERNEL);\r\nif (pvt->map[i] == NULL) {\r\nwhile (i--)\r\nkfree(pvt->map[i]);\r\nkfree(pvt->map);\r\ngoto error;\r\n}\r\n}\r\nif (attr && attr->x <= tcm->width && attr->y <= tcm->height) {\r\npvt->div_pt.x = attr->x;\r\npvt->div_pt.y = attr->y;\r\n} else {\r\npvt->div_pt.x = (tcm->width * 3) / 4;\r\npvt->div_pt.y = (tcm->height * 3) / 4;\r\n}\r\nspin_lock(&(pvt->lock));\r\nassign(&area, 0, 0, width - 1, height - 1);\r\nfill_area(tcm, &area, NULL);\r\nspin_unlock(&(pvt->lock));\r\nreturn tcm;\r\nerror:\r\nkfree(tcm);\r\nkfree(pvt);\r\nreturn NULL;\r\n}\r\nstatic void sita_deinit(struct tcm *tcm)\r\n{\r\nstruct sita_pvt *pvt = (struct sita_pvt *)tcm->pvt;\r\nstruct tcm_area area = {0};\r\ns32 i;\r\narea.p1.x = tcm->width - 1;\r\narea.p1.y = tcm->height - 1;\r\nspin_lock(&(pvt->lock));\r\nfill_area(tcm, &area, NULL);\r\nspin_unlock(&(pvt->lock));\r\nfor (i = 0; i < tcm->height; i++)\r\nkfree(pvt->map[i]);\r\nkfree(pvt->map);\r\nkfree(pvt);\r\n}\r\nstatic s32 sita_reserve_1d(struct tcm *tcm, u32 num_slots,\r\nstruct tcm_area *area)\r\n{\r\ns32 ret;\r\nstruct tcm_area field = {0};\r\nstruct sita_pvt *pvt = (struct sita_pvt *)tcm->pvt;\r\nspin_lock(&(pvt->lock));\r\nassign(&field, tcm->width - 1, tcm->height - 1, 0, 0);\r\nret = scan_r2l_b2t_one_dim(tcm, num_slots, &field, area);\r\nif (!ret)\r\nfill_area(tcm, area, area);\r\nspin_unlock(&(pvt->lock));\r\nreturn ret;\r\n}\r\nstatic s32 sita_reserve_2d(struct tcm *tcm, u16 h, u16 w, u8 align,\r\nstruct tcm_area *area)\r\n{\r\ns32 ret;\r\nstruct sita_pvt *pvt = (struct sita_pvt *)tcm->pvt;\r\nif (align > 64)\r\nreturn -EINVAL;\r\nalign = align <= 1 ? 1 : align <= 32 ? 32 : 64;\r\nspin_lock(&(pvt->lock));\r\nret = scan_areas_and_find_fit(tcm, w, h, align, area);\r\nif (!ret)\r\nfill_area(tcm, area, area);\r\nspin_unlock(&(pvt->lock));\r\nreturn ret;\r\n}\r\nstatic s32 sita_free(struct tcm *tcm, struct tcm_area *area)\r\n{\r\nstruct sita_pvt *pvt = (struct sita_pvt *)tcm->pvt;\r\nspin_lock(&(pvt->lock));\r\nWARN_ON(pvt->map[area->p0.x][area->p0.y] != area ||\r\npvt->map[area->p1.x][area->p1.y] != area);\r\nfill_area(tcm, area, NULL);\r\nspin_unlock(&(pvt->lock));\r\nreturn 0;\r\n}\r\nstatic s32 scan_r2l_t2b(struct tcm *tcm, u16 w, u16 h, u16 align,\r\nstruct tcm_area *field, struct tcm_area *area)\r\n{\r\ns32 x, y;\r\ns16 start_x, end_x, start_y, end_y, found_x = -1;\r\nstruct tcm_area ***map = ((struct sita_pvt *)tcm->pvt)->map;\r\nstruct score best = {{0}, {0}, {0}, 0};\r\nstart_x = field->p0.x;\r\nend_x = field->p1.x;\r\nstart_y = field->p0.y;\r\nend_y = field->p1.y;\r\nif (field->p0.x < field->p1.x ||\r\nfield->p1.y < field->p0.y)\r\nreturn -EINVAL;\r\nif (w > LEN(start_x, end_x) || h > LEN(end_y, start_y))\r\nreturn -ENOSPC;\r\nstart_x = ALIGN_DOWN(start_x - w + 1, align);\r\nend_y = end_y - h + 1;\r\nif (start_x < end_x)\r\nreturn -ENOSPC;\r\nfor (y = start_y; y <= end_y; y++) {\r\nfor (x = start_x; x >= end_x; x -= align) {\r\nif (is_area_free(map, x, y, w, h)) {\r\nfound_x = x;\r\nif (update_candidate(tcm, x, y, w, h, field,\r\nCR_R2L_T2B, &best))\r\ngoto done;\r\nend_x = x + 1;\r\nbreak;\r\n} else if (map[x][y] && map[x][y]->is2d) {\r\nx = ALIGN(map[x][y]->p0.x - w + 1, align);\r\n}\r\n}\r\nif (found_x == start_x)\r\nbreak;\r\n}\r\nif (!best.a.tcm)\r\nreturn -ENOSPC;\r\ndone:\r\nassign(area, best.a.p0.x, best.a.p0.y, best.a.p1.x, best.a.p1.y);\r\nreturn 0;\r\n}\r\nstatic s32 scan_l2r_t2b(struct tcm *tcm, u16 w, u16 h, u16 align,\r\nstruct tcm_area *field, struct tcm_area *area)\r\n{\r\ns32 x, y;\r\ns16 start_x, end_x, start_y, end_y, found_x = -1;\r\nstruct tcm_area ***map = ((struct sita_pvt *)tcm->pvt)->map;\r\nstruct score best = {{0}, {0}, {0}, 0};\r\nstart_x = field->p0.x;\r\nend_x = field->p1.x;\r\nstart_y = field->p0.y;\r\nend_y = field->p1.y;\r\nif (field->p1.x < field->p0.x ||\r\nfield->p1.y < field->p0.y)\r\nreturn -EINVAL;\r\nif (w > LEN(end_x, start_x) || h > LEN(end_y, start_y))\r\nreturn -ENOSPC;\r\nstart_x = ALIGN(start_x, align);\r\nif (w > LEN(end_x, start_x))\r\nreturn -ENOSPC;\r\nend_x = end_x - w + 1;\r\nend_y = end_y - h + 1;\r\nfor (y = start_y; y <= end_y; y++) {\r\nfor (x = start_x; x <= end_x; x += align) {\r\nif (is_area_free(map, x, y, w, h)) {\r\nfound_x = x;\r\nif (update_candidate(tcm, x, y, w, h, field,\r\nCR_L2R_T2B, &best))\r\ngoto done;\r\nend_x = x - 1;\r\nbreak;\r\n} else if (map[x][y] && map[x][y]->is2d) {\r\nx = ALIGN_DOWN(map[x][y]->p1.x, align);\r\n}\r\n}\r\nif (found_x == start_x)\r\nbreak;\r\n}\r\nif (!best.a.tcm)\r\nreturn -ENOSPC;\r\ndone:\r\nassign(area, best.a.p0.x, best.a.p0.y, best.a.p1.x, best.a.p1.y);\r\nreturn 0;\r\n}\r\nstatic s32 scan_r2l_b2t_one_dim(struct tcm *tcm, u32 num_slots,\r\nstruct tcm_area *field, struct tcm_area *area)\r\n{\r\ns32 found = 0;\r\ns16 x, y;\r\nstruct sita_pvt *pvt = (struct sita_pvt *)tcm->pvt;\r\nstruct tcm_area *p;\r\nif (field->p0.y < field->p1.y)\r\nreturn -EINVAL;\r\nif (tcm->width != field->p0.x - field->p1.x + 1)\r\nreturn -EINVAL;\r\nif (num_slots > tcm->width * LEN(field->p0.y, field->p1.y))\r\nreturn -ENOSPC;\r\nx = field->p0.x;\r\ny = field->p0.y;\r\nwhile (found < num_slots) {\r\nif (y < 0)\r\nreturn -ENOSPC;\r\nif (found == 0) {\r\narea->p1.x = x;\r\narea->p1.y = y;\r\n}\r\np = pvt->map[x][y];\r\nif (p) {\r\nx = p->p0.x;\r\nif (!p->is2d)\r\ny = p->p0.y;\r\nfound = 0;\r\n} else {\r\nfound++;\r\nif (found == num_slots)\r\nbreak;\r\n}\r\nif (x == 0)\r\ny--;\r\nx = (x ? : tcm->width) - 1;\r\n}\r\narea->p0.x = x;\r\narea->p0.y = y;\r\nreturn 0;\r\n}\r\nstatic s32 scan_areas_and_find_fit(struct tcm *tcm, u16 w, u16 h, u16 align,\r\nstruct tcm_area *area)\r\n{\r\ns32 ret = 0;\r\nstruct tcm_area field = {0};\r\nu16 boundary_x, boundary_y;\r\nstruct sita_pvt *pvt = (struct sita_pvt *)tcm->pvt;\r\nif (align > 1) {\r\nboundary_x = pvt->div_pt.x - 1;\r\nboundary_y = pvt->div_pt.y - 1;\r\nif (w > pvt->div_pt.x)\r\nboundary_x = tcm->width - 1;\r\nif (h > pvt->div_pt.y)\r\nboundary_y = tcm->height - 1;\r\nassign(&field, 0, 0, boundary_x, boundary_y);\r\nret = scan_l2r_t2b(tcm, w, h, align, &field, area);\r\nif (ret != 0 && (boundary_x != tcm->width - 1 ||\r\nboundary_y != tcm->height - 1)) {\r\nassign(&field, 0, 0, tcm->width - 1, tcm->height - 1);\r\nret = scan_l2r_t2b(tcm, w, h, align, &field, area);\r\n}\r\n} else if (align == 1) {\r\nboundary_x = pvt->div_pt.x;\r\nboundary_y = pvt->div_pt.y - 1;\r\nif (w > (tcm->width - pvt->div_pt.x))\r\nboundary_x = 0;\r\nif (h > pvt->div_pt.y)\r\nboundary_y = tcm->height - 1;\r\nassign(&field, tcm->width - 1, 0, boundary_x, boundary_y);\r\nret = scan_r2l_t2b(tcm, w, h, align, &field, area);\r\nif (ret != 0 && (boundary_x != 0 ||\r\nboundary_y != tcm->height - 1)) {\r\nassign(&field, tcm->width - 1, 0, 0, tcm->height - 1);\r\nret = scan_r2l_t2b(tcm, w, h, align, &field,\r\narea);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic s32 is_area_free(struct tcm_area ***map, u16 x0, u16 y0, u16 w, u16 h)\r\n{\r\nu16 x = 0, y = 0;\r\nfor (y = y0; y < y0 + h; y++) {\r\nfor (x = x0; x < x0 + w; x++) {\r\nif (map[x][y])\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic void fill_area(struct tcm *tcm, struct tcm_area *area,\r\nstruct tcm_area *parent)\r\n{\r\ns32 x, y;\r\nstruct sita_pvt *pvt = (struct sita_pvt *)tcm->pvt;\r\nstruct tcm_area a, a_;\r\narea->tcm = tcm;\r\ntcm_for_each_slice(a, *area, a_) {\r\nfor (x = a.p0.x; x <= a.p1.x; ++x)\r\nfor (y = a.p0.y; y <= a.p1.y; ++y)\r\npvt->map[x][y] = parent;\r\n}\r\n}\r\nstatic s32 update_candidate(struct tcm *tcm, u16 x0, u16 y0, u16 w, u16 h,\r\nstruct tcm_area *field, s32 criteria,\r\nstruct score *best)\r\n{\r\nstruct score me;\r\nbool first = criteria & CR_BIAS_HORIZONTAL;\r\nassign(&me.a, x0, y0, x0 + w - 1, y0 + h - 1);\r\nif (!first) {\r\nget_neighbor_stats(tcm, &me.a, &me.n);\r\nme.neighs = me.n.edge + me.n.busy;\r\nget_nearness_factor(field, &me.a, &me.f);\r\n}\r\nif (!best->a.tcm)\r\ngoto better;\r\nBUG_ON(first);\r\nif ((criteria & CR_DIAGONAL_BALANCE) &&\r\nbest->neighs <= me.neighs &&\r\n(best->neighs < me.neighs ||\r\nbest->n.busy < me.n.busy ||\r\n(best->n.busy == me.n.busy &&\r\nbest->f.x + best->f.y > me.f.x + me.f.y)))\r\ngoto better;\r\nreturn 0;\r\nbetter:\r\nmemcpy(best, &me, sizeof(me));\r\nbest->a.tcm = tcm;\r\nreturn first;\r\n}\r\nstatic void get_nearness_factor(struct tcm_area *field, struct tcm_area *area,\r\nstruct nearness_factor *nf)\r\n{\r\nnf->x = (s32)(area->p0.x - field->p0.x) * 1000 /\r\n(field->p1.x - field->p0.x);\r\nnf->y = (s32)(area->p0.y - field->p0.y) * 1000 /\r\n(field->p1.y - field->p0.y);\r\n}\r\nstatic void get_neighbor_stats(struct tcm *tcm, struct tcm_area *area,\r\nstruct neighbor_stats *stat)\r\n{\r\ns16 x = 0, y = 0;\r\nstruct sita_pvt *pvt = (struct sita_pvt *)tcm->pvt;\r\nmemset(stat, 0, sizeof(*stat));\r\nfor (x = area->p0.x; x <= area->p1.x; x++) {\r\nif (area->p0.y == 0)\r\nstat->edge++;\r\nelse if (pvt->map[x][area->p0.y - 1])\r\nstat->busy++;\r\nif (area->p1.y == tcm->height - 1)\r\nstat->edge++;\r\nelse if (pvt->map[x][area->p1.y + 1])\r\nstat->busy++;\r\n}\r\nfor (y = area->p0.y; y <= area->p1.y; ++y) {\r\nif (area->p0.x == 0)\r\nstat->edge++;\r\nelse if (pvt->map[area->p0.x - 1][y])\r\nstat->busy++;\r\nif (area->p1.x == tcm->width - 1)\r\nstat->edge++;\r\nelse if (pvt->map[area->p1.x + 1][y])\r\nstat->busy++;\r\n}\r\n}
