static void auok190x_issue_data(struct auok190xfb_par *par, u16 data)\r\n{\r\npar->board->set_ctl(par, AUOK190X_I80_WR, 0);\r\npar->board->set_hdb(par, data);\r\npar->board->set_ctl(par, AUOK190X_I80_WR, 1);\r\n}\r\nstatic void auok190x_issue_cmd(struct auok190xfb_par *par, u16 data)\r\n{\r\npar->board->set_ctl(par, AUOK190X_I80_DC, 0);\r\nauok190x_issue_data(par, data);\r\npar->board->set_ctl(par, AUOK190X_I80_DC, 1);\r\n}\r\nstatic int auok190x_issue_pixels(struct auok190xfb_par *par, int size,\r\nu16 *data)\r\n{\r\nstruct device *dev = par->info->device;\r\nint i;\r\nu16 tmp;\r\nif (size & 3) {\r\ndev_err(dev, "issue_pixels: size %d must be a multiple of 4\n",\r\nsize);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < (size >> 1); i++) {\r\npar->board->set_ctl(par, AUOK190X_I80_WR, 0);\r\ntmp = (data[2*i] & 0xF0) >> 4;\r\ntmp |= (data[2*i] & 0xF000) >> 8;\r\ntmp |= (data[2*i+1] & 0xF0) << 4;\r\ntmp |= (data[2*i+1] & 0xF000);\r\npar->board->set_hdb(par, tmp);\r\npar->board->set_ctl(par, AUOK190X_I80_WR, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 auok190x_read_data(struct auok190xfb_par *par)\r\n{\r\nu16 data;\r\npar->board->set_ctl(par, AUOK190X_I80_OE, 0);\r\ndata = par->board->get_hdb(par);\r\npar->board->set_ctl(par, AUOK190X_I80_OE, 1);\r\nreturn data;\r\n}\r\nvoid auok190x_send_command_nowait(struct auok190xfb_par *par, u16 data)\r\n{\r\npar->board->set_ctl(par, AUOK190X_I80_CS, 0);\r\nauok190x_issue_cmd(par, data);\r\npar->board->set_ctl(par, AUOK190X_I80_CS, 1);\r\n}\r\nvoid auok190x_send_cmdargs_nowait(struct auok190xfb_par *par, u16 cmd,\r\nint argc, u16 *argv)\r\n{\r\nint i;\r\npar->board->set_ctl(par, AUOK190X_I80_CS, 0);\r\nauok190x_issue_cmd(par, cmd);\r\nfor (i = 0; i < argc; i++)\r\nauok190x_issue_data(par, argv[i]);\r\npar->board->set_ctl(par, AUOK190X_I80_CS, 1);\r\n}\r\nint auok190x_send_command(struct auok190xfb_par *par, u16 data)\r\n{\r\nint ret;\r\nret = par->board->wait_for_rdy(par);\r\nif (ret)\r\nreturn ret;\r\nauok190x_send_command_nowait(par, data);\r\nreturn 0;\r\n}\r\nint auok190x_send_cmdargs(struct auok190xfb_par *par, u16 cmd,\r\nint argc, u16 *argv)\r\n{\r\nint ret;\r\nret = par->board->wait_for_rdy(par);\r\nif (ret)\r\nreturn ret;\r\nauok190x_send_cmdargs_nowait(par, cmd, argc, argv);\r\nreturn 0;\r\n}\r\nint auok190x_read_cmdargs(struct auok190xfb_par *par, u16 cmd,\r\nint argc, u16 *argv)\r\n{\r\nint i, ret;\r\nret = par->board->wait_for_rdy(par);\r\nif (ret)\r\nreturn ret;\r\npar->board->set_ctl(par, AUOK190X_I80_CS, 0);\r\nauok190x_issue_cmd(par, cmd);\r\nfor (i = 0; i < argc; i++)\r\nargv[i] = auok190x_read_data(par);\r\npar->board->set_ctl(par, AUOK190X_I80_CS, 1);\r\nreturn 0;\r\n}\r\nvoid auok190x_send_cmdargs_pixels_nowait(struct auok190xfb_par *par, u16 cmd,\r\nint argc, u16 *argv, int size, u16 *data)\r\n{\r\nint i;\r\npar->board->set_ctl(par, AUOK190X_I80_CS, 0);\r\nauok190x_issue_cmd(par, cmd);\r\nfor (i = 0; i < argc; i++)\r\nauok190x_issue_data(par, argv[i]);\r\nauok190x_issue_pixels(par, size, data);\r\npar->board->set_ctl(par, AUOK190X_I80_CS, 1);\r\n}\r\nint auok190x_send_cmdargs_pixels(struct auok190xfb_par *par, u16 cmd,\r\nint argc, u16 *argv, int size, u16 *data)\r\n{\r\nint ret;\r\nret = par->board->wait_for_rdy(par);\r\nif (ret)\r\nreturn ret;\r\nauok190x_send_cmdargs_pixels_nowait(par, cmd, argc, argv, size, data);\r\nreturn 0;\r\n}\r\nstatic void auok190xfb_dpy_first_io(struct fb_info *info)\r\n{\r\npm_runtime_get(info->device);\r\n}\r\nstatic void auok190xfb_dpy_deferred_io(struct fb_info *info,\r\nstruct list_head *pagelist)\r\n{\r\nstruct fb_deferred_io *fbdefio = info->fbdefio;\r\nstruct auok190xfb_par *par = info->par;\r\nu16 yres = info->var.yres;\r\nu16 xres = info->var.xres;\r\nu16 y1 = 0, h = 0;\r\nint prev_index = -1;\r\nstruct page *cur;\r\nint h_inc;\r\nint threshold;\r\nif (!list_empty(pagelist))\r\npm_runtime_barrier(info->device);\r\nelse\r\npm_runtime_get_sync(info->device);\r\nif (par->need_refresh(par)) {\r\npar->update_all(par);\r\ngoto out;\r\n}\r\nh_inc = DIV_ROUND_UP(PAGE_SIZE , xres);\r\nthreshold = par->consecutive_threshold / h_inc;\r\nif (threshold < 1)\r\nthreshold = 1;\r\nlist_for_each_entry(cur, &fbdefio->pagelist, lru) {\r\nif (prev_index < 0) {\r\ny1 = (cur->index << PAGE_SHIFT) / xres;\r\nh = h_inc;\r\n} else if ((cur->index - prev_index) <= threshold) {\r\nh += h_inc * (cur->index - prev_index);\r\n} else {\r\npar->update_partial(par, y1, y1 + h);\r\ny1 = (cur->index << PAGE_SHIFT) / xres;\r\nh = h_inc;\r\n}\r\nprev_index = cur->index;\r\n}\r\nif (h >= yres)\r\npar->update_all(par);\r\nelse\r\npar->update_partial(par, y1, min((u16) (y1 + h), yres));\r\nout:\r\npm_runtime_mark_last_busy(info->device);\r\npm_runtime_put_autosuspend(info->device);\r\n}\r\nstatic ssize_t auok190xfb_write(struct fb_info *info, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct auok190xfb_par *par = info->par;\r\nunsigned long p = *ppos;\r\nvoid *dst;\r\nint err = 0;\r\nunsigned long total_size;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn -EPERM;\r\ntotal_size = info->fix.smem_len;\r\nif (p > total_size)\r\nreturn -EFBIG;\r\nif (count > total_size) {\r\nerr = -EFBIG;\r\ncount = total_size;\r\n}\r\nif (count + p > total_size) {\r\nif (!err)\r\nerr = -ENOSPC;\r\ncount = total_size - p;\r\n}\r\ndst = (void *)(info->screen_base + p);\r\nif (copy_from_user(dst, buf, count))\r\nerr = -EFAULT;\r\nif (!err)\r\n*ppos += count;\r\npar->update_all(par);\r\nreturn (err) ? err : count;\r\n}\r\nstatic void auok190xfb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct auok190xfb_par *par = info->par;\r\nsys_fillrect(info, rect);\r\npar->update_all(par);\r\n}\r\nstatic void auok190xfb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct auok190xfb_par *par = info->par;\r\nsys_copyarea(info, area);\r\npar->update_all(par);\r\n}\r\nstatic void auok190xfb_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct auok190xfb_par *par = info->par;\r\nsys_imageblit(info, image);\r\npar->update_all(par);\r\n}\r\nstatic int auok190xfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nif (info->var.xres != var->xres || info->var.yres != var->yres ||\r\ninfo->var.xres_virtual != var->xres_virtual ||\r\ninfo->var.yres_virtual != var->yres_virtual) {\r\npr_info("%s: Resolution not supported: X%u x Y%u\n",\r\n__func__, var->xres, var->yres);\r\nreturn -EINVAL;\r\n}\r\nif ((info->fix.line_length * var->yres_virtual) > info->fix.smem_len) {\r\npr_info("%s: Memory Limit requested yres_virtual = %u\n",\r\n__func__, var->yres_virtual);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int auok190x_read_temperature(struct auok190xfb_par *par)\r\n{\r\nstruct device *dev = par->info->device;\r\nu16 data[4];\r\nint temp;\r\npm_runtime_get_sync(dev);\r\nmutex_lock(&(par->io_lock));\r\nauok190x_read_cmdargs(par, AUOK190X_CMD_READ_VERSION, 4, data);\r\nmutex_unlock(&(par->io_lock));\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_put_autosuspend(dev);\r\ntemp = ((data[0] & AUOK190X_VERSION_TEMP_MASK) >> 1);\r\nif (temp >= 201)\r\nreturn (255 - temp + 1) * (-1);\r\nelse\r\nreturn temp;\r\n}\r\nstatic void auok190x_identify(struct auok190xfb_par *par)\r\n{\r\nstruct device *dev = par->info->device;\r\nu16 data[4];\r\npm_runtime_get_sync(dev);\r\nmutex_lock(&(par->io_lock));\r\nauok190x_read_cmdargs(par, AUOK190X_CMD_READ_VERSION, 4, data);\r\nmutex_unlock(&(par->io_lock));\r\npar->epd_type = data[1] & AUOK190X_VERSION_TEMP_MASK;\r\npar->panel_size_int = AUOK190X_VERSION_SIZE_INT(data[2]);\r\npar->panel_size_float = AUOK190X_VERSION_SIZE_FLOAT(data[2]);\r\npar->panel_model = AUOK190X_VERSION_MODEL(data[2]);\r\npar->tcon_version = AUOK190X_VERSION_TCON(data[3]);\r\npar->lut_version = AUOK190X_VERSION_LUT(data[3]);\r\ndev_dbg(dev, "panel %d.%din, model 0x%x, EPD 0x%x TCON-rev 0x%x, LUT-rev 0x%x",\r\npar->panel_size_int, par->panel_size_float, par->panel_model,\r\npar->epd_type, par->tcon_version, par->lut_version);\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_put_autosuspend(dev);\r\n}\r\nstatic ssize_t update_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct auok190xfb_par *par = info->par;\r\nreturn sprintf(buf, "%d\n", par->update_mode);\r\n}\r\nstatic ssize_t update_mode_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct auok190xfb_par *par = info->par;\r\nint mode, ret;\r\nret = kstrtoint(buf, 10, &mode);\r\nif (ret)\r\nreturn ret;\r\npar->update_mode = mode;\r\nif (par->last_mode > 1 && mode < par->last_mode)\r\npar->update_all(par);\r\nreturn count;\r\n}\r\nstatic ssize_t flash_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct auok190xfb_par *par = info->par;\r\nreturn sprintf(buf, "%d\n", par->flash);\r\n}\r\nstatic ssize_t flash_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct auok190xfb_par *par = info->par;\r\nint flash, ret;\r\nret = kstrtoint(buf, 10, &flash);\r\nif (ret)\r\nreturn ret;\r\nif (flash > 0)\r\npar->flash = 1;\r\nelse\r\npar->flash = 0;\r\nreturn count;\r\n}\r\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct auok190xfb_par *par = info->par;\r\nint temp;\r\ntemp = auok190x_read_temperature(par);\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic int auok190x_power(struct auok190xfb_par *par, bool on)\r\n{\r\nstruct auok190x_board *board = par->board;\r\nint ret;\r\nif (on) {\r\nret = regulator_enable(par->regulator);\r\nif (ret)\r\nreturn ret;\r\nmsleep(200);\r\ngpio_set_value(board->gpio_nrst, 1);\r\ngpio_set_value(board->gpio_nsleep, 1);\r\nmsleep(200);\r\n} else {\r\nregulator_disable(par->regulator);\r\ngpio_set_value(board->gpio_nrst, 0);\r\ngpio_set_value(board->gpio_nsleep, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void auok190x_recover(struct auok190xfb_par *par)\r\n{\r\nauok190x_power(par, 0);\r\nmsleep(100);\r\nauok190x_power(par, 1);\r\npar->init(par);\r\npar->board->wait_for_rdy(par);\r\n}\r\nstatic int auok190x_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nstruct auok190xfb_par *par = info->par;\r\nstruct auok190x_board *board = par->board;\r\nu16 standby_param;\r\nmutex_lock(&(par->io_lock));\r\nif (par->standby) {\r\ndev_warn(dev, "already in standby, runtime-pm pairing mismatch\n");\r\nmutex_unlock(&(par->io_lock));\r\nreturn 0;\r\n}\r\nif (board->quirks & AUOK190X_QUIRK_STANDBYBROKEN) {\r\ndev_dbg(dev, "runtime suspend without standby\n");\r\ngoto finish;\r\n} else if (board->quirks & AUOK190X_QUIRK_STANDBYPARAM) {\r\ndev_dbg(dev, "runtime suspend with additional empty param\n");\r\nstandby_param = 0;\r\nauok190x_send_cmdargs(par, AUOK190X_CMD_STANDBY, 1,\r\n&standby_param);\r\n} else {\r\ndev_dbg(dev, "runtime suspend without param\n");\r\nauok190x_send_command(par, AUOK190X_CMD_STANDBY);\r\n}\r\nmsleep(64);\r\nfinish:\r\npar->standby = 1;\r\nreturn 0;\r\n}\r\nstatic int auok190x_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nstruct auok190xfb_par *par = info->par;\r\nstruct auok190x_board *board = par->board;\r\nif (!par->standby) {\r\ndev_warn(dev, "not in standby, runtime-pm pairing mismatch\n");\r\nreturn 0;\r\n}\r\nif (board->quirks & AUOK190X_QUIRK_STANDBYBROKEN) {\r\ndev_dbg(dev, "runtime resume without standby\n");\r\n} else {\r\ndev_dbg(dev, "runtime resume from standby\n");\r\nauok190x_send_command_nowait(par, AUOK190X_CMD_WAKEUP);\r\nmsleep(160);\r\nboard->wait_for_rdy(par);\r\n}\r\npar->standby = 0;\r\nmutex_unlock(&(par->io_lock));\r\nreturn 0;\r\n}\r\nstatic int auok190x_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nstruct auok190xfb_par *par = info->par;\r\nstruct auok190x_board *board = par->board;\r\nint ret;\r\ndev_dbg(dev, "suspend\n");\r\nif (board->quirks & AUOK190X_QUIRK_STANDBYBROKEN) {\r\ndev_dbg(dev, "suspend with broken standby\n");\r\nauok190x_power(par, 0);\r\n} else {\r\ndev_dbg(dev, "suspend using sleep\n");\r\nif (!pm_runtime_status_suspended(dev)) {\r\nret = auok190x_runtime_suspend(dev);\r\nif (ret < 0) {\r\ndev_err(dev, "auok190x_runtime_suspend failed with %d\n",\r\nret);\r\nreturn ret;\r\n}\r\npar->manual_standby = 1;\r\n}\r\ngpio_direction_output(board->gpio_nsleep, 0);\r\n}\r\nmsleep(100);\r\nreturn 0;\r\n}\r\nstatic int auok190x_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nstruct auok190xfb_par *par = info->par;\r\nstruct auok190x_board *board = par->board;\r\ndev_dbg(dev, "resume\n");\r\nif (board->quirks & AUOK190X_QUIRK_STANDBYBROKEN) {\r\ndev_dbg(dev, "resume with broken standby\n");\r\nauok190x_power(par, 1);\r\npar->init(par);\r\n} else {\r\ndev_dbg(dev, "resume from sleep\n");\r\ngpio_direction_output(board->gpio_nsleep, 1);\r\nmsleep(100);\r\nauok190x_runtime_resume(dev);\r\npar->init(par);\r\nif (!par->manual_standby)\r\nauok190x_runtime_suspend(dev);\r\nelse\r\npar->manual_standby = 0;\r\n}\r\nreturn 0;\r\n}\r\nint __devinit auok190x_common_probe(struct platform_device *pdev,\r\nstruct auok190x_init_data *init)\r\n{\r\nstruct auok190x_board *board = init->board;\r\nstruct auok190xfb_par *par;\r\nstruct fb_info *info;\r\nstruct panel_info *panel;\r\nint videomemorysize, ret;\r\nunsigned char *videomemory;\r\nif (!board->init || !board->cleanup || !board->wait_for_rdy\r\n|| !board->set_ctl || !board->set_hdb || !board->get_hdb\r\n|| !board->setup_irq)\r\nreturn -EINVAL;\r\ninfo = framebuffer_alloc(sizeof(struct auok190xfb_par), &pdev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\npar = info->par;\r\npar->info = info;\r\npar->board = board;\r\npar->recover = auok190x_recover;\r\npar->update_partial = init->update_partial;\r\npar->update_all = init->update_all;\r\npar->need_refresh = init->need_refresh;\r\npar->init = init->init;\r\npar->update_cnt = 0;\r\npar->update_mode = -1;\r\npar->last_mode = -1;\r\npar->flash = 0;\r\npar->regulator = regulator_get(info->device, "vdd");\r\nif (IS_ERR(par->regulator)) {\r\nret = PTR_ERR(par->regulator);\r\ndev_err(info->device, "Failed to get regulator: %d\n", ret);\r\ngoto err_reg;\r\n}\r\nret = board->init(par);\r\nif (ret) {\r\ndev_err(info->device, "board init failed, %d\n", ret);\r\ngoto err_board;\r\n}\r\nret = gpio_request(board->gpio_nsleep, "AUOK190x sleep");\r\nif (ret) {\r\ndev_err(info->device, "could not request sleep gpio, %d\n",\r\nret);\r\ngoto err_gpio1;\r\n}\r\nret = gpio_direction_output(board->gpio_nsleep, 0);\r\nif (ret) {\r\ndev_err(info->device, "could not set sleep gpio, %d\n", ret);\r\ngoto err_gpio2;\r\n}\r\nret = gpio_request(board->gpio_nrst, "AUOK190x reset");\r\nif (ret) {\r\ndev_err(info->device, "could not request reset gpio, %d\n",\r\nret);\r\ngoto err_gpio2;\r\n}\r\nret = gpio_direction_output(board->gpio_nrst, 0);\r\nif (ret) {\r\ndev_err(info->device, "could not set reset gpio, %d\n", ret);\r\ngoto err_gpio3;\r\n}\r\nret = auok190x_power(par, 1);\r\nif (ret) {\r\ndev_err(info->device, "could not power on the device, %d\n",\r\nret);\r\ngoto err_gpio3;\r\n}\r\nmutex_init(&par->io_lock);\r\ninit_waitqueue_head(&par->waitq);\r\nret = par->board->setup_irq(par->info);\r\nif (ret) {\r\ndev_err(info->device, "could not setup ready-irq, %d\n", ret);\r\ngoto err_irq;\r\n}\r\npar->board->wait_for_rdy(par);\r\nstrlcpy(info->fix.id, init->id, 16);\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_STATIC_PSEUDOCOLOR;\r\ninfo->fix.xpanstep = 0;\r\ninfo->fix.ypanstep = 0;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->var.bits_per_pixel = 8;\r\ninfo->var.grayscale = 1;\r\ninfo->var.red.length = 8;\r\ninfo->var.green.length = 8;\r\ninfo->var.blue.length = 8;\r\npanel = &panel_table[board->resolution];\r\nif (board->rotation & 1) {\r\ninfo->var.xres = panel->h;\r\ninfo->var.yres = panel->w;\r\ninfo->var.xres_virtual = panel->h;\r\ninfo->var.yres_virtual = panel->w;\r\ninfo->fix.line_length = panel->h;\r\n} else {\r\ninfo->var.xres = panel->w;\r\ninfo->var.yres = panel->h;\r\ninfo->var.xres_virtual = panel->w;\r\ninfo->var.yres_virtual = panel->h;\r\ninfo->fix.line_length = panel->w;\r\n}\r\npar->resolution = board->resolution;\r\npar->rotation = board->rotation;\r\nvideomemorysize = roundup((panel->w * panel->h), PAGE_SIZE);\r\nvideomemory = vmalloc(videomemorysize);\r\nif (!videomemory) {\r\nret = -ENOMEM;\r\ngoto err_irq;\r\n}\r\nmemset(videomemory, 0, videomemorysize);\r\ninfo->screen_base = (char *)videomemory;\r\ninfo->fix.smem_len = videomemorysize;\r\ninfo->flags = FBINFO_FLAG_DEFAULT | FBINFO_VIRTFB;\r\ninfo->fbops = &auok190xfb_ops;\r\ninfo->fbdefio = devm_kzalloc(info->device,\r\nsizeof(struct fb_deferred_io),\r\nGFP_KERNEL);\r\nif (!info->fbdefio) {\r\ndev_err(info->device, "Failed to allocate memory\n");\r\nret = -ENOMEM;\r\ngoto err_defio;\r\n}\r\ndev_dbg(info->device, "targetting %d frames per second\n", board->fps);\r\ninfo->fbdefio->delay = HZ / board->fps;\r\ninfo->fbdefio->first_io = auok190xfb_dpy_first_io,\r\ninfo->fbdefio->deferred_io = auok190xfb_dpy_deferred_io,\r\nfb_deferred_io_init(info);\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret < 0) {\r\ndev_err(info->device, "Failed to allocate colormap\n");\r\ngoto err_cmap;\r\n}\r\npar->consecutive_threshold = 100;\r\npar->init(par);\r\nauok190x_identify(par);\r\nplatform_set_drvdata(pdev, info);\r\nret = register_framebuffer(info);\r\nif (ret < 0)\r\ngoto err_regfb;\r\nret = sysfs_create_group(&info->device->kobj, &auok190x_attr_group);\r\nif (ret)\r\ngoto err_sysfs;\r\ndev_info(info->device, "fb%d: %dx%d using %dK of video memory\n",\r\ninfo->node, info->var.xres, info->var.yres,\r\nvideomemorysize >> 10);\r\npar->autosuspend_delay = (board->quirks & AUOK190X_QUIRK_STANDBYBROKEN)\r\n? 1000 : 200;\r\npm_runtime_set_active(info->device);\r\npm_runtime_enable(info->device);\r\npm_runtime_set_autosuspend_delay(info->device, par->autosuspend_delay);\r\npm_runtime_use_autosuspend(info->device);\r\nreturn 0;\r\nerr_sysfs:\r\nunregister_framebuffer(info);\r\nerr_regfb:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_cmap:\r\nfb_deferred_io_cleanup(info);\r\nerr_defio:\r\nvfree((void *)info->screen_base);\r\nerr_irq:\r\nauok190x_power(par, 0);\r\nerr_gpio3:\r\ngpio_free(board->gpio_nrst);\r\nerr_gpio2:\r\ngpio_free(board->gpio_nsleep);\r\nerr_gpio1:\r\nboard->cleanup(par);\r\nerr_board:\r\nregulator_put(par->regulator);\r\nerr_reg:\r\nframebuffer_release(info);\r\nreturn ret;\r\n}\r\nint __devexit auok190x_common_remove(struct platform_device *pdev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nstruct auok190xfb_par *par = info->par;\r\nstruct auok190x_board *board = par->board;\r\npm_runtime_disable(info->device);\r\nsysfs_remove_group(&info->device->kobj, &auok190x_attr_group);\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nfb_deferred_io_cleanup(info);\r\nvfree((void *)info->screen_base);\r\nauok190x_power(par, 0);\r\ngpio_free(board->gpio_nrst);\r\ngpio_free(board->gpio_nsleep);\r\nboard->cleanup(par);\r\nregulator_put(par->regulator);\r\nframebuffer_release(info);\r\nreturn 0;\r\n}
