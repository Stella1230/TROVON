static int node_offset(void *fdt, const char *node_path)\r\n{\r\nint offset = fdt_path_offset(fdt, node_path);\r\nif (offset == -FDT_ERR_NOTFOUND)\r\noffset = fdt_add_subnode(fdt, 0, node_path);\r\nreturn offset;\r\n}\r\nstatic int setprop(void *fdt, const char *node_path, const char *property,\r\nuint32_t *val_array, int size)\r\n{\r\nint offset = node_offset(fdt, node_path);\r\nif (offset < 0)\r\nreturn offset;\r\nreturn fdt_setprop(fdt, offset, property, val_array, size);\r\n}\r\nstatic int setprop_string(void *fdt, const char *node_path,\r\nconst char *property, const char *string)\r\n{\r\nint offset = node_offset(fdt, node_path);\r\nif (offset < 0)\r\nreturn offset;\r\nreturn fdt_setprop_string(fdt, offset, property, string);\r\n}\r\nstatic int setprop_cell(void *fdt, const char *node_path,\r\nconst char *property, uint32_t val)\r\n{\r\nint offset = node_offset(fdt, node_path);\r\nif (offset < 0)\r\nreturn offset;\r\nreturn fdt_setprop_cell(fdt, offset, property, val);\r\n}\r\nstatic const void *getprop(const void *fdt, const char *node_path,\r\nconst char *property, int *len)\r\n{\r\nint offset = fdt_path_offset(fdt, node_path);\r\nif (offset == -FDT_ERR_NOTFOUND)\r\nreturn NULL;\r\nreturn fdt_getprop(fdt, offset, property, len);\r\n}\r\nstatic void merge_fdt_bootargs(void *fdt, const char *fdt_cmdline)\r\n{\r\nchar cmdline[COMMAND_LINE_SIZE];\r\nconst char *fdt_bootargs;\r\nchar *ptr = cmdline;\r\nint len = 0;\r\nfdt_bootargs = getprop(fdt, "/chosen", "bootargs", &len);\r\nif (fdt_bootargs)\r\nif (len < COMMAND_LINE_SIZE) {\r\nmemcpy(ptr, fdt_bootargs, len);\r\nptr += len - 1;\r\n}\r\nif (fdt_cmdline) {\r\nlen = strlen(fdt_cmdline);\r\nif (ptr - cmdline + len + 2 < COMMAND_LINE_SIZE) {\r\n*ptr++ = ' ';\r\nmemcpy(ptr, fdt_cmdline, len);\r\nptr += len;\r\n}\r\n}\r\n*ptr = '\0';\r\nsetprop_string(fdt, "/chosen", "bootargs", cmdline);\r\n}\r\nint atags_to_fdt(void *atag_list, void *fdt, int total_space)\r\n{\r\nstruct tag *atag = atag_list;\r\nuint32_t mem_reg_property[2 * NR_BANKS];\r\nint memcount = 0;\r\nint ret;\r\nif ((u32)atag_list & 0x3)\r\nreturn 1;\r\nif (*(u32 *)atag_list == fdt32_to_cpu(FDT_MAGIC))\r\nreturn 0;\r\nif (atag->hdr.tag != ATAG_CORE ||\r\n(atag->hdr.size != tag_size(tag_core) &&\r\natag->hdr.size != 2))\r\nreturn 1;\r\nret = fdt_open_into(fdt, fdt, total_space);\r\nif (ret < 0)\r\nreturn ret;\r\nfor_each_tag(atag, atag_list) {\r\nif (atag->hdr.tag == ATAG_CMDLINE) {\r\nif (do_extend_cmdline)\r\nmerge_fdt_bootargs(fdt,\r\natag->u.cmdline.cmdline);\r\nelse\r\nsetprop_string(fdt, "/chosen", "bootargs",\r\natag->u.cmdline.cmdline);\r\n} else if (atag->hdr.tag == ATAG_MEM) {\r\nif (memcount >= sizeof(mem_reg_property)/4)\r\ncontinue;\r\nif (!atag->u.mem.size)\r\ncontinue;\r\nmem_reg_property[memcount++] = cpu_to_fdt32(atag->u.mem.start);\r\nmem_reg_property[memcount++] = cpu_to_fdt32(atag->u.mem.size);\r\n} else if (atag->hdr.tag == ATAG_INITRD2) {\r\nuint32_t initrd_start, initrd_size;\r\ninitrd_start = atag->u.initrd.start;\r\ninitrd_size = atag->u.initrd.size;\r\nsetprop_cell(fdt, "/chosen", "linux,initrd-start",\r\ninitrd_start);\r\nsetprop_cell(fdt, "/chosen", "linux,initrd-end",\r\ninitrd_start + initrd_size);\r\n}\r\n}\r\nif (memcount)\r\nsetprop(fdt, "/memory", "reg", mem_reg_property, 4*memcount);\r\nreturn fdt_pack(fdt);\r\n}
