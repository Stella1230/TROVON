static inline int __init doccheck(void __iomem *potential, unsigned long physadr)\r\n{\r\nvoid __iomem *window=potential;\r\nunsigned char tmp, tmpb, tmpc, ChipID;\r\n#ifndef DOC_PASSIVE_PROBE\r\nunsigned char tmp2;\r\n#endif\r\n#ifdef CONFIG_MTD_DOCPROBE_55AA\r\nif (ReadDOC(window, Sig1) != 0x55 || ReadDOC(window, Sig2) != 0xaa)\r\nreturn 0;\r\n#endif\r\n#ifndef DOC_PASSIVE_PROBE\r\ntmp2 = ReadDOC(window, DOCControl);\r\nWriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_RESET,\r\nwindow, DOCControl);\r\nWriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_RESET,\r\nwindow, DOCControl);\r\nWriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_NORMAL,\r\nwindow, DOCControl);\r\nWriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_NORMAL,\r\nwindow, DOCControl);\r\n#endif\r\nChipID = ReadDOC(window, ChipID);\r\nswitch (ChipID) {\r\ncase DOC_ChipID_Doc2k:\r\ntmp = ReadDOC(window, 2k_ECCStatus) & DOC_TOGGLE_BIT;\r\ntmpb = ReadDOC(window, 2k_ECCStatus) & DOC_TOGGLE_BIT;\r\ntmpc = ReadDOC(window, 2k_ECCStatus) & DOC_TOGGLE_BIT;\r\nif (tmp != tmpb && tmp == tmpc)\r\nreturn ChipID;\r\nbreak;\r\ncase DOC_ChipID_DocMil:\r\nReadDOC(window, ChipID);\r\nReadDOC(window, ChipID);\r\nif (ReadDOC(window, ChipID) != DOC_ChipID_DocMil)\r\nChipID = DOC_ChipID_Doc2kTSOP;\r\ntmp = ReadDOC(window, ECCConf) & DOC_TOGGLE_BIT;\r\ntmpb = ReadDOC(window, ECCConf) & DOC_TOGGLE_BIT;\r\ntmpc = ReadDOC(window, ECCConf) & DOC_TOGGLE_BIT;\r\nif (tmp != tmpb && tmp == tmpc)\r\nreturn ChipID;\r\nbreak;\r\ncase DOC_ChipID_DocMilPlus16:\r\ncase DOC_ChipID_DocMilPlus32:\r\ncase 0:\r\n#ifndef DOC_PASSIVE_PROBE\r\nfor (tmp = 0; (tmp < 4); tmp++)\r\nReadDOC(window, Mplus_Power);\r\ntmp = DOC_MODE_RESET | DOC_MODE_MDWREN | DOC_MODE_RST_LAT |\r\nDOC_MODE_BDECT;\r\nWriteDOC(tmp, window, Mplus_DOCControl);\r\nWriteDOC(~tmp, window, Mplus_CtrlConfirm);\r\nmdelay(1);\r\ntmp = DOC_MODE_NORMAL | DOC_MODE_MDWREN | DOC_MODE_RST_LAT |\r\nDOC_MODE_BDECT;\r\nWriteDOC(tmp, window, Mplus_DOCControl);\r\nWriteDOC(~tmp, window, Mplus_CtrlConfirm);\r\nmdelay(1);\r\n#endif\r\nChipID = ReadDOC(window, ChipID);\r\nswitch (ChipID) {\r\ncase DOC_ChipID_DocMilPlus16:\r\ncase DOC_ChipID_DocMilPlus32:\r\ntmp = ReadDOC(window, Mplus_Toggle) & DOC_TOGGLE_BIT;\r\ntmpb = ReadDOC(window, Mplus_Toggle) & DOC_TOGGLE_BIT;\r\ntmpc = ReadDOC(window, Mplus_Toggle) & DOC_TOGGLE_BIT;\r\nif (tmp != tmpb && tmp == tmpc)\r\nreturn ChipID;\r\ndefault:\r\nbreak;\r\n}\r\ndefault:\r\n#ifdef CONFIG_MTD_DOCPROBE_55AA\r\nprintk(KERN_DEBUG "Possible DiskOnChip with unknown ChipID %2.2X found at 0x%lx\n",\r\nChipID, physadr);\r\n#endif\r\n#ifndef DOC_PASSIVE_PROBE\r\nWriteDOC(tmp2, window, DOCControl);\r\n#endif\r\nreturn 0;\r\n}\r\nprintk(KERN_WARNING "DiskOnChip failed TOGGLE test, dropping.\n");\r\n#ifndef DOC_PASSIVE_PROBE\r\nWriteDOC(tmp2, window, DOCControl);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __init DoC_Probe(unsigned long physadr)\r\n{\r\nvoid __iomem *docptr;\r\nstruct DiskOnChip *this;\r\nstruct mtd_info *mtd;\r\nint ChipID;\r\nchar namebuf[15];\r\nchar *name = namebuf;\r\nvoid (*initroutine)(struct mtd_info *) = NULL;\r\ndocptr = ioremap(physadr, DOC_IOREMAP_LEN);\r\nif (!docptr)\r\nreturn;\r\nif ((ChipID = doccheck(docptr, physadr))) {\r\nif (ChipID == DOC_ChipID_Doc2kTSOP) {\r\nprintk(KERN_NOTICE "Refusing to drive DiskOnChip 2000 TSOP until Bad Block Table is correctly supported by INFTL\n");\r\niounmap(docptr);\r\nreturn;\r\n}\r\ndocfound = 1;\r\nmtd = kzalloc(sizeof(struct DiskOnChip) + sizeof(struct mtd_info), GFP_KERNEL);\r\nif (!mtd) {\r\nprintk(KERN_WARNING "Cannot allocate memory for data structures. Dropping.\n");\r\niounmap(docptr);\r\nreturn;\r\n}\r\nthis = (struct DiskOnChip *)(&mtd[1]);\r\nmtd->priv = this;\r\nthis->virtadr = docptr;\r\nthis->physadr = physadr;\r\nthis->ChipID = ChipID;\r\nsprintf(namebuf, "with ChipID %2.2X", ChipID);\r\nswitch(ChipID) {\r\ncase DOC_ChipID_Doc2kTSOP:\r\nname="2000 TSOP";\r\ninitroutine = symbol_request(DoC2k_init);\r\nbreak;\r\ncase DOC_ChipID_Doc2k:\r\nname="2000";\r\ninitroutine = symbol_request(DoC2k_init);\r\nbreak;\r\ncase DOC_ChipID_DocMil:\r\nname="Millennium";\r\n#ifdef DOC_SINGLE_DRIVER\r\ninitroutine = symbol_request(DoC2k_init);\r\n#else\r\ninitroutine = symbol_request(DoCMil_init);\r\n#endif\r\nbreak;\r\ncase DOC_ChipID_DocMilPlus16:\r\ncase DOC_ChipID_DocMilPlus32:\r\nname="MillenniumPlus";\r\ninitroutine = symbol_request(DoCMilPlus_init);\r\nbreak;\r\n}\r\nif (initroutine) {\r\n(*initroutine)(mtd);\r\nsymbol_put_addr(initroutine);\r\nreturn;\r\n}\r\nprintk(KERN_NOTICE "Cannot find driver for DiskOnChip %s at 0x%lX\n", name, physadr);\r\nkfree(mtd);\r\n}\r\niounmap(docptr);\r\n}\r\nstatic int __init init_doc(void)\r\n{\r\nint i;\r\nif (doc_config_location) {\r\nprintk(KERN_INFO "Using configured DiskOnChip probe address 0x%lx\n", doc_config_location);\r\nDoC_Probe(doc_config_location);\r\n} else {\r\nfor (i=0; (doc_locations[i] != 0xffffffff); i++) {\r\nDoC_Probe(doc_locations[i]);\r\n}\r\n}\r\nif (!docfound)\r\nprintk(KERN_INFO "No recognised DiskOnChip devices found\n");\r\nreturn -EAGAIN;\r\n}
