static void ov534_reg_write(struct gspca_dev *gspca_dev, u16 reg, u8 val)\r\n{\r\nstruct usb_device *udev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nPDEBUG(D_USBO, "SET 01 0000 %04x %02x", reg, val);\r\ngspca_dev->usb_buf[0] = val;\r\nret = usb_control_msg(udev,\r\nusb_sndctrlpipe(udev, 0),\r\n0x01,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x00, reg, gspca_dev->usb_buf, 1, CTRL_TIMEOUT);\r\nif (ret < 0) {\r\npr_err("write failed %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic u8 ov534_reg_read(struct gspca_dev *gspca_dev, u16 reg)\r\n{\r\nstruct usb_device *udev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn 0;\r\nret = usb_control_msg(udev,\r\nusb_rcvctrlpipe(udev, 0),\r\n0x01,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x00, reg, gspca_dev->usb_buf, 1, CTRL_TIMEOUT);\r\nPDEBUG(D_USBI, "GET 01 0000 %04x %02x", reg, gspca_dev->usb_buf[0]);\r\nif (ret < 0) {\r\npr_err("read failed %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\nreturn gspca_dev->usb_buf[0];\r\n}\r\nstatic void ov534_set_led(struct gspca_dev *gspca_dev, int status)\r\n{\r\nu8 data;\r\nPDEBUG(D_CONF, "led status: %d", status);\r\ndata = ov534_reg_read(gspca_dev, 0x21);\r\ndata |= 0x80;\r\nov534_reg_write(gspca_dev, 0x21, data);\r\ndata = ov534_reg_read(gspca_dev, 0x23);\r\nif (status)\r\ndata |= 0x80;\r\nelse\r\ndata &= ~0x80;\r\nov534_reg_write(gspca_dev, 0x23, data);\r\nif (!status) {\r\ndata = ov534_reg_read(gspca_dev, 0x21);\r\ndata &= ~0x80;\r\nov534_reg_write(gspca_dev, 0x21, data);\r\n}\r\n}\r\nstatic int sccb_check_status(struct gspca_dev *gspca_dev)\r\n{\r\nu8 data;\r\nint i;\r\nfor (i = 0; i < 5; i++) {\r\nmsleep(10);\r\ndata = ov534_reg_read(gspca_dev, OV534_REG_STATUS);\r\nswitch (data) {\r\ncase 0x00:\r\nreturn 1;\r\ncase 0x04:\r\nreturn 0;\r\ncase 0x03:\r\nbreak;\r\ndefault:\r\nPDEBUG(D_ERR, "sccb status 0x%02x, attempt %d/5",\r\ndata, i + 1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sccb_reg_write(struct gspca_dev *gspca_dev, u8 reg, u8 val)\r\n{\r\nPDEBUG(D_USBO, "sccb write: %02x %02x", reg, val);\r\nov534_reg_write(gspca_dev, OV534_REG_SUBADDR, reg);\r\nov534_reg_write(gspca_dev, OV534_REG_WRITE, val);\r\nov534_reg_write(gspca_dev, OV534_REG_OPERATION, OV534_OP_WRITE_3);\r\nif (!sccb_check_status(gspca_dev)) {\r\npr_err("sccb_reg_write failed\n");\r\ngspca_dev->usb_err = -EIO;\r\n}\r\n}\r\nstatic u8 sccb_reg_read(struct gspca_dev *gspca_dev, u16 reg)\r\n{\r\nov534_reg_write(gspca_dev, OV534_REG_SUBADDR, reg);\r\nov534_reg_write(gspca_dev, OV534_REG_OPERATION, OV534_OP_WRITE_2);\r\nif (!sccb_check_status(gspca_dev))\r\npr_err("sccb_reg_read failed 1\n");\r\nov534_reg_write(gspca_dev, OV534_REG_OPERATION, OV534_OP_READ_2);\r\nif (!sccb_check_status(gspca_dev))\r\npr_err("sccb_reg_read failed 2\n");\r\nreturn ov534_reg_read(gspca_dev, OV534_REG_READ);\r\n}\r\nstatic void set_frame_rate(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i;\r\nstruct rate_s {\r\nu8 fps;\r\nu8 r11;\r\nu8 r0d;\r\nu8 re5;\r\n};\r\nconst struct rate_s *r;\r\nstatic const struct rate_s rate_0[] = {\r\n{60, 0x01, 0xc1, 0x04},\r\n{50, 0x01, 0x41, 0x02},\r\n{40, 0x02, 0xc1, 0x04},\r\n{30, 0x04, 0x81, 0x02},\r\n{15, 0x03, 0x41, 0x04},\r\n};\r\nstatic const struct rate_s rate_1[] = {\r\n{125, 0x02, 0x81, 0x02},\r\n{100, 0x02, 0xc1, 0x04},\r\n{75, 0x03, 0xc1, 0x04},\r\n{60, 0x04, 0xc1, 0x04},\r\n{50, 0x02, 0x41, 0x04},\r\n{40, 0x03, 0x41, 0x04},\r\n{30, 0x04, 0x41, 0x04},\r\n};\r\nif (sd->sensor != SENSOR_OV772x)\r\nreturn;\r\nif (gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv == 0) {\r\nr = rate_0;\r\ni = ARRAY_SIZE(rate_0);\r\n} else {\r\nr = rate_1;\r\ni = ARRAY_SIZE(rate_1);\r\n}\r\nwhile (--i > 0) {\r\nif (sd->frame_rate >= r->fps)\r\nbreak;\r\nr++;\r\n}\r\nsccb_reg_write(gspca_dev, 0x11, r->r11);\r\nsccb_reg_write(gspca_dev, 0x0d, r->r0d);\r\nov534_reg_write(gspca_dev, 0xe5, r->re5);\r\nPDEBUG(D_PROBE, "frame_rate: %d", r->fps);\r\n}\r\nstatic void sethue(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_OV767x) {\r\n} else {\r\ns16 huesin;\r\ns16 huecos;\r\nval += 360;\r\nhuesin = fixp_sin(val) * 0x80 / 0x100;\r\nhuecos = fixp_cos(val) * 0x80 / 0x100;\r\nif (huesin < 0) {\r\nsccb_reg_write(gspca_dev, 0xab,\r\nsccb_reg_read(gspca_dev, 0xab) | 0x2);\r\nhuesin = -huesin;\r\n} else {\r\nsccb_reg_write(gspca_dev, 0xab,\r\nsccb_reg_read(gspca_dev, 0xab) & ~0x2);\r\n}\r\nsccb_reg_write(gspca_dev, 0xa9, (u8)huecos);\r\nsccb_reg_write(gspca_dev, 0xaa, (u8)huesin);\r\n}\r\n}\r\nstatic void setsaturation(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_OV767x) {\r\nint i;\r\nstatic u8 color_tb[][6] = {\r\n{0x42, 0x42, 0x00, 0x11, 0x30, 0x41},\r\n{0x52, 0x52, 0x00, 0x16, 0x3c, 0x52},\r\n{0x66, 0x66, 0x00, 0x1b, 0x4b, 0x66},\r\n{0x80, 0x80, 0x00, 0x22, 0x5e, 0x80},\r\n{0x9a, 0x9a, 0x00, 0x29, 0x71, 0x9a},\r\n{0xb8, 0xb8, 0x00, 0x31, 0x87, 0xb8},\r\n{0xdd, 0xdd, 0x00, 0x3b, 0xa2, 0xdd},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(color_tb[0]); i++)\r\nsccb_reg_write(gspca_dev, 0x4f + i, color_tb[val][i]);\r\n} else {\r\nsccb_reg_write(gspca_dev, 0xa7, val);\r\nsccb_reg_write(gspca_dev, 0xa8, val);\r\n}\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_OV767x) {\r\nif (val < 0)\r\nval = 0x80 - val;\r\nsccb_reg_write(gspca_dev, 0x55, val);\r\n} else {\r\nsccb_reg_write(gspca_dev, 0x9b, val);\r\n}\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_OV767x)\r\nsccb_reg_write(gspca_dev, 0x56, val);\r\nelse\r\nsccb_reg_write(gspca_dev, 0x9c, val);\r\n}\r\nstatic void setgain(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nswitch (val & 0x30) {\r\ncase 0x00:\r\nval &= 0x0f;\r\nbreak;\r\ncase 0x10:\r\nval &= 0x0f;\r\nval |= 0x30;\r\nbreak;\r\ncase 0x20:\r\nval &= 0x0f;\r\nval |= 0x70;\r\nbreak;\r\ndefault:\r\nval &= 0x0f;\r\nval |= 0xf0;\r\nbreak;\r\n}\r\nsccb_reg_write(gspca_dev, 0x00, val);\r\n}\r\nstatic s32 getgain(struct gspca_dev *gspca_dev)\r\n{\r\nreturn sccb_reg_read(gspca_dev, 0x00);\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_OV767x) {\r\nsccb_reg_write(gspca_dev, 0x10, val);\r\n} else {\r\nsccb_reg_write(gspca_dev, 0x08, val >> 7);\r\nsccb_reg_write(gspca_dev, 0x10, val << 1);\r\n}\r\n}\r\nstatic s32 getexposure(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_OV767x) {\r\nreturn sccb_reg_read(gspca_dev, 0x10);\r\n} else {\r\nu8 hi = sccb_reg_read(gspca_dev, 0x08);\r\nu8 lo = sccb_reg_read(gspca_dev, 0x10);\r\nreturn (hi << 8 | lo) >> 1;\r\n}\r\n}\r\nstatic void setagc(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nif (val) {\r\nsccb_reg_write(gspca_dev, 0x13,\r\nsccb_reg_read(gspca_dev, 0x13) | 0x04);\r\nsccb_reg_write(gspca_dev, 0x64,\r\nsccb_reg_read(gspca_dev, 0x64) | 0x03);\r\n} else {\r\nsccb_reg_write(gspca_dev, 0x13,\r\nsccb_reg_read(gspca_dev, 0x13) & ~0x04);\r\nsccb_reg_write(gspca_dev, 0x64,\r\nsccb_reg_read(gspca_dev, 0x64) & ~0x03);\r\n}\r\n}\r\nstatic void setawb(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (val) {\r\nsccb_reg_write(gspca_dev, 0x13,\r\nsccb_reg_read(gspca_dev, 0x13) | 0x02);\r\nif (sd->sensor == SENSOR_OV772x)\r\nsccb_reg_write(gspca_dev, 0x63,\r\nsccb_reg_read(gspca_dev, 0x63) | 0xc0);\r\n} else {\r\nsccb_reg_write(gspca_dev, 0x13,\r\nsccb_reg_read(gspca_dev, 0x13) & ~0x02);\r\nif (sd->sensor == SENSOR_OV772x)\r\nsccb_reg_write(gspca_dev, 0x63,\r\nsccb_reg_read(gspca_dev, 0x63) & ~0xc0);\r\n}\r\n}\r\nstatic void setaec(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 data;\r\ndata = sd->sensor == SENSOR_OV767x ?\r\n0x05 :\r\n0x01;\r\nswitch (val) {\r\ncase V4L2_EXPOSURE_AUTO:\r\nsccb_reg_write(gspca_dev, 0x13,\r\nsccb_reg_read(gspca_dev, 0x13) | data);\r\nbreak;\r\ncase V4L2_EXPOSURE_MANUAL:\r\nsccb_reg_write(gspca_dev, 0x13,\r\nsccb_reg_read(gspca_dev, 0x13) & ~data);\r\nbreak;\r\n}\r\n}\r\nstatic void setsharpness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nsccb_reg_write(gspca_dev, 0x91, val);\r\nsccb_reg_write(gspca_dev, 0x8e, val);\r\n}\r\nstatic void sethvflip(struct gspca_dev *gspca_dev, s32 hflip, s32 vflip)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 val;\r\nif (sd->sensor == SENSOR_OV767x) {\r\nval = sccb_reg_read(gspca_dev, 0x1e);\r\nval &= ~0x30;\r\nif (hflip)\r\nval |= 0x20;\r\nif (vflip)\r\nval |= 0x10;\r\nsccb_reg_write(gspca_dev, 0x1e, val);\r\n} else {\r\nval = sccb_reg_read(gspca_dev, 0x0c);\r\nval &= ~0xc0;\r\nif (hflip == 0)\r\nval |= 0x40;\r\nif (vflip == 0)\r\nval |= 0x80;\r\nsccb_reg_write(gspca_dev, 0x0c, val);\r\n}\r\n}\r\nstatic void setlightfreq(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nval = val ? 0x9e : 0x00;\r\nif (sd->sensor == SENSOR_OV767x) {\r\nsccb_reg_write(gspca_dev, 0x2a, 0x00);\r\nif (val)\r\nval = 0x9d;\r\n}\r\nsccb_reg_write(gspca_dev, 0x2b, val);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\ncam = &gspca_dev->cam;\r\ncam->cam_mode = ov772x_mode;\r\ncam->nmodes = ARRAY_SIZE(ov772x_mode);\r\nsd->frame_rate = 30;\r\nreturn 0;\r\n}\r\nstatic int ov534_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct sd *sd = container_of(ctrl->handler, struct sd, ctrl_handler);\r\nstruct gspca_dev *gspca_dev = &sd->gspca_dev;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\ngspca_dev->usb_err = 0;\r\nif (ctrl->val && sd->gain && gspca_dev->streaming)\r\nsd->gain->val = getgain(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\ngspca_dev->usb_err = 0;\r\nif (ctrl->val == V4L2_EXPOSURE_AUTO && sd->exposure &&\r\ngspca_dev->streaming)\r\nsd->exposure->val = getexposure(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov534_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct sd *sd = container_of(ctrl->handler, struct sd, ctrl_handler);\r\nstruct gspca_dev *gspca_dev = &sd->gspca_dev;\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_HUE:\r\nsethue(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsetsaturation(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsetcontrast(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_AUTOGAIN:\r\nsetagc(gspca_dev, ctrl->val);\r\nif (!gspca_dev->usb_err && !ctrl->val && sd->gain)\r\nsetgain(gspca_dev, sd->gain->val);\r\nbreak;\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nsetawb(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nsetaec(gspca_dev, ctrl->val);\r\nif (!gspca_dev->usb_err && ctrl->val == V4L2_EXPOSURE_MANUAL &&\r\nsd->exposure)\r\nsetexposure(gspca_dev, sd->exposure->val);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nsetsharpness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nsethvflip(gspca_dev, ctrl->val, sd->vflip->val);\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nsethvflip(gspca_dev, sd->hflip->val, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nsetlightfreq(gspca_dev, ctrl->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &sd->ctrl_handler;\r\nint saturation_min;\r\nint saturation_max;\r\nint saturation_def;\r\nint brightness_min;\r\nint brightness_max;\r\nint brightness_def;\r\nint contrast_max;\r\nint contrast_def;\r\nint exposure_min;\r\nint exposure_max;\r\nint exposure_def;\r\nint hflip_def;\r\nif (sd->sensor == SENSOR_OV767x) {\r\nsaturation_min = 0,\r\nsaturation_max = 6,\r\nsaturation_def = 3,\r\nbrightness_min = -127;\r\nbrightness_max = 127;\r\nbrightness_def = 0;\r\ncontrast_max = 0x80;\r\ncontrast_def = 0x40;\r\nexposure_min = 0x08;\r\nexposure_max = 0x60;\r\nexposure_def = 0x13;\r\nhflip_def = 1;\r\n} else {\r\nsaturation_min = 0,\r\nsaturation_max = 255,\r\nsaturation_def = 64,\r\nbrightness_min = 0;\r\nbrightness_max = 255;\r\nbrightness_def = 0;\r\ncontrast_max = 255;\r\ncontrast_def = 32;\r\nexposure_min = 0;\r\nexposure_max = 255;\r\nexposure_def = 120;\r\nhflip_def = 0;\r\n}\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 13);\r\nif (sd->sensor == SENSOR_OV772x)\r\nsd->hue = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\r\nV4L2_CID_HUE, -90, 90, 1, 0);\r\nsd->saturation = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\r\nV4L2_CID_SATURATION, saturation_min, saturation_max, 1,\r\nsaturation_def);\r\nsd->brightness = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, brightness_min, brightness_max, 1,\r\nbrightness_def);\r\nsd->contrast = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, contrast_max, 1, contrast_def);\r\nif (sd->sensor == SENSOR_OV772x) {\r\nsd->autogain = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\nsd->gain = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 63, 1, 20);\r\n}\r\nsd->autoexposure = v4l2_ctrl_new_std_menu(hdl, &ov534_ctrl_ops,\r\nV4L2_CID_EXPOSURE_AUTO,\r\nV4L2_EXPOSURE_MANUAL, 0,\r\nV4L2_EXPOSURE_AUTO);\r\nsd->exposure = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\r\nV4L2_CID_EXPOSURE, exposure_min, exposure_max, 1,\r\nexposure_def);\r\nsd->autowhitebalance = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\r\nV4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);\r\nif (sd->sensor == SENSOR_OV772x)\r\nsd->sharpness = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\r\nV4L2_CID_SHARPNESS, 0, 63, 1, 0);\r\nsd->hflip = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, hflip_def);\r\nsd->vflip = v4l2_ctrl_new_std(hdl, &ov534_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nsd->plfreq = v4l2_ctrl_new_std_menu(hdl, &ov534_ctrl_ops,\r\nV4L2_CID_POWER_LINE_FREQUENCY,\r\nV4L2_CID_POWER_LINE_FREQUENCY_50HZ, 0,\r\nV4L2_CID_POWER_LINE_FREQUENCY_DISABLED);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nif (sd->sensor == SENSOR_OV772x)\r\nv4l2_ctrl_auto_cluster(2, &sd->autogain, 0, true);\r\nv4l2_ctrl_auto_cluster(2, &sd->autoexposure, V4L2_EXPOSURE_MANUAL,\r\ntrue);\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 sensor_id;\r\nstatic const struct reg_array bridge_init[NSENSORS] = {\r\n[SENSOR_OV767x] = {bridge_init_767x, ARRAY_SIZE(bridge_init_767x)},\r\n[SENSOR_OV772x] = {bridge_init_772x, ARRAY_SIZE(bridge_init_772x)},\r\n};\r\nstatic const struct reg_array sensor_init[NSENSORS] = {\r\n[SENSOR_OV767x] = {sensor_init_767x, ARRAY_SIZE(sensor_init_767x)},\r\n[SENSOR_OV772x] = {sensor_init_772x, ARRAY_SIZE(sensor_init_772x)},\r\n};\r\nov534_reg_write(gspca_dev, 0xe7, 0x3a);\r\nov534_reg_write(gspca_dev, 0xe0, 0x08);\r\nmsleep(100);\r\nov534_reg_write(gspca_dev, OV534_REG_ADDRESS, 0x42);\r\nsccb_reg_write(gspca_dev, 0x12, 0x80);\r\nmsleep(10);\r\nsccb_reg_read(gspca_dev, 0x0a);\r\nsensor_id = sccb_reg_read(gspca_dev, 0x0a) << 8;\r\nsccb_reg_read(gspca_dev, 0x0b);\r\nsensor_id |= sccb_reg_read(gspca_dev, 0x0b);\r\nPDEBUG(D_PROBE, "Sensor ID: %04x", sensor_id);\r\nif ((sensor_id & 0xfff0) == 0x7670) {\r\nsd->sensor = SENSOR_OV767x;\r\ngspca_dev->cam.cam_mode = ov767x_mode;\r\ngspca_dev->cam.nmodes = ARRAY_SIZE(ov767x_mode);\r\n} else {\r\nsd->sensor = SENSOR_OV772x;\r\ngspca_dev->cam.bulk = 1;\r\ngspca_dev->cam.bulk_size = 16384;\r\ngspca_dev->cam.bulk_nurbs = 2;\r\ngspca_dev->cam.mode_framerates = ov772x_framerates;\r\n}\r\nreg_w_array(gspca_dev, bridge_init[sd->sensor].val,\r\nbridge_init[sd->sensor].len);\r\nov534_set_led(gspca_dev, 1);\r\nsccb_w_array(gspca_dev, sensor_init[sd->sensor].val,\r\nsensor_init[sd->sensor].len);\r\nif (sd->sensor == SENSOR_OV767x)\r\nsd_start(gspca_dev);\r\nsd_stopN(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint mode;\r\nstatic const struct reg_array bridge_start[NSENSORS][2] = {\r\n[SENSOR_OV767x] = {{bridge_start_qvga_767x,\r\nARRAY_SIZE(bridge_start_qvga_767x)},\r\n{bridge_start_vga_767x,\r\nARRAY_SIZE(bridge_start_vga_767x)}},\r\n[SENSOR_OV772x] = {{bridge_start_qvga_772x,\r\nARRAY_SIZE(bridge_start_qvga_772x)},\r\n{bridge_start_vga_772x,\r\nARRAY_SIZE(bridge_start_vga_772x)}},\r\n};\r\nstatic const struct reg_array sensor_start[NSENSORS][2] = {\r\n[SENSOR_OV767x] = {{sensor_start_qvga_767x,\r\nARRAY_SIZE(sensor_start_qvga_767x)},\r\n{sensor_start_vga_767x,\r\nARRAY_SIZE(sensor_start_vga_767x)}},\r\n[SENSOR_OV772x] = {{sensor_start_qvga_772x,\r\nARRAY_SIZE(sensor_start_qvga_772x)},\r\n{sensor_start_vga_772x,\r\nARRAY_SIZE(sensor_start_vga_772x)}},\r\n};\r\nif (sd->sensor == SENSOR_OV767x)\r\nsccb_reg_write(gspca_dev, 0x1e, 0x04);\r\nmode = gspca_dev->curr_mode;\r\nreg_w_array(gspca_dev, bridge_start[sd->sensor][mode].val,\r\nbridge_start[sd->sensor][mode].len);\r\nsccb_w_array(gspca_dev, sensor_start[sd->sensor][mode].val,\r\nsensor_start[sd->sensor][mode].len);\r\nset_frame_rate(gspca_dev);\r\nif (sd->hue)\r\nsethue(gspca_dev, v4l2_ctrl_g_ctrl(sd->hue));\r\nsetsaturation(gspca_dev, v4l2_ctrl_g_ctrl(sd->saturation));\r\nif (sd->autogain)\r\nsetagc(gspca_dev, v4l2_ctrl_g_ctrl(sd->autogain));\r\nsetawb(gspca_dev, v4l2_ctrl_g_ctrl(sd->autowhitebalance));\r\nsetaec(gspca_dev, v4l2_ctrl_g_ctrl(sd->autoexposure));\r\nif (sd->gain)\r\nsetgain(gspca_dev, v4l2_ctrl_g_ctrl(sd->gain));\r\nsetexposure(gspca_dev, v4l2_ctrl_g_ctrl(sd->exposure));\r\nsetbrightness(gspca_dev, v4l2_ctrl_g_ctrl(sd->brightness));\r\nsetcontrast(gspca_dev, v4l2_ctrl_g_ctrl(sd->contrast));\r\nif (sd->sharpness)\r\nsetsharpness(gspca_dev, v4l2_ctrl_g_ctrl(sd->sharpness));\r\nsethvflip(gspca_dev, v4l2_ctrl_g_ctrl(sd->hflip),\r\nv4l2_ctrl_g_ctrl(sd->vflip));\r\nsetlightfreq(gspca_dev, v4l2_ctrl_g_ctrl(sd->plfreq));\r\nov534_set_led(gspca_dev, 1);\r\nov534_reg_write(gspca_dev, 0xe0, 0x00);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nov534_reg_write(gspca_dev, 0xe0, 0x09);\r\nov534_set_led(gspca_dev, 0);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data, int len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u32 this_pts;\r\nu16 this_fid;\r\nint remaining_len = len;\r\nint payload_len;\r\npayload_len = gspca_dev->cam.bulk ? 2048 : 2040;\r\ndo {\r\nlen = min(remaining_len, payload_len);\r\nif (data[0] != 12 || len < 12) {\r\nPDEBUG(D_PACK, "bad header");\r\ngoto discard;\r\n}\r\nif (data[1] & UVC_STREAM_ERR) {\r\nPDEBUG(D_PACK, "payload error");\r\ngoto discard;\r\n}\r\nif (!(data[1] & UVC_STREAM_PTS)) {\r\nPDEBUG(D_PACK, "PTS not present");\r\ngoto discard;\r\n}\r\nthis_pts = (data[5] << 24) | (data[4] << 16)\r\n| (data[3] << 8) | data[2];\r\nthis_fid = (data[1] & UVC_STREAM_FID) ? 1 : 0;\r\nif (this_pts != sd->last_pts || this_fid != sd->last_fid) {\r\nif (gspca_dev->last_packet_type == INTER_PACKET)\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\nNULL, 0);\r\nsd->last_pts = this_pts;\r\nsd->last_fid = this_fid;\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\ndata + 12, len - 12);\r\n} else if (data[1] & UVC_STREAM_EOF) {\r\nsd->last_pts = 0;\r\nif (gspca_dev->pixfmt == V4L2_PIX_FMT_YUYV\r\n&& gspca_dev->image_len + len - 12 !=\r\ngspca_dev->width * gspca_dev->height * 2) {\r\nPDEBUG(D_PACK, "wrong sized frame");\r\ngoto discard;\r\n}\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\ndata + 12, len - 12);\r\n} else {\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\ndata + 12, len - 12);\r\n}\r\ngoto scan_next;\r\ndiscard:\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\nscan_next:\r\nremaining_len -= len;\r\ndata += len;\r\n} while (remaining_len > 0);\r\n}\r\nstatic void sd_get_streamparm(struct gspca_dev *gspca_dev,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct v4l2_captureparm *cp = &parm->parm.capture;\r\nstruct v4l2_fract *tpf = &cp->timeperframe;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ncp->capability |= V4L2_CAP_TIMEPERFRAME;\r\ntpf->numerator = 1;\r\ntpf->denominator = sd->frame_rate;\r\n}\r\nstatic void sd_set_streamparm(struct gspca_dev *gspca_dev,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct v4l2_captureparm *cp = &parm->parm.capture;\r\nstruct v4l2_fract *tpf = &cp->timeperframe;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->frame_rate = tpf->denominator / tpf->numerator;\r\nif (gspca_dev->streaming)\r\nset_frame_rate(gspca_dev);\r\ntpf->numerator = 1;\r\ntpf->denominator = sd->frame_rate;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
