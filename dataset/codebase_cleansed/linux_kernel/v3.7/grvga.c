static int grvga_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct grvga_par *par = info->par;\r\nint i;\r\nif (!var->xres)\r\nvar->xres = 1;\r\nif (!var->yres)\r\nvar->yres = 1;\r\nif (var->bits_per_pixel <= 8)\r\nvar->bits_per_pixel = 8;\r\nelse if (var->bits_per_pixel <= 16)\r\nvar->bits_per_pixel = 16;\r\nelse if (var->bits_per_pixel <= 24)\r\nvar->bits_per_pixel = 24;\r\nelse if (var->bits_per_pixel <= 32)\r\nvar->bits_per_pixel = 32;\r\nelse\r\nreturn -EINVAL;\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = 2*var->yres;\r\nif (info->fix.smem_len) {\r\nif ((var->yres_virtual*var->xres_virtual*var->bits_per_pixel/8) > info->fix.smem_len)\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i <= 3 ; i++) {\r\nif (var->pixclock == par->regs->clk_vector[i])\r\nbreak;\r\n}\r\nif (i <= 3)\r\npar->clk_sel = i;\r\nelse\r\nreturn -EINVAL;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nvar->red = (struct fb_bitfield) {0, 8, 0};\r\nvar->green = (struct fb_bitfield) {0, 8, 0};\r\nvar->blue = (struct fb_bitfield) {0, 8, 0};\r\nvar->transp = (struct fb_bitfield) {0, 0, 0};\r\nbreak;\r\ncase 16:\r\nvar->red = (struct fb_bitfield) {11, 5, 0};\r\nvar->green = (struct fb_bitfield) {5, 6, 0};\r\nvar->blue = (struct fb_bitfield) {0, 5, 0};\r\nvar->transp = (struct fb_bitfield) {0, 0, 0};\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nvar->red = (struct fb_bitfield) {16, 8, 0};\r\nvar->green = (struct fb_bitfield) {8, 8, 0};\r\nvar->blue = (struct fb_bitfield) {0, 8, 0};\r\nvar->transp = (struct fb_bitfield) {24, 8, 0};\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int grvga_set_par(struct fb_info *info)\r\n{\r\nu32 func = 0;\r\nstruct grvga_par *par = info->par;\r\n__raw_writel(((info->var.yres - 1) << 16) | (info->var.xres - 1),\r\n&par->regs->video_length);\r\n__raw_writel((info->var.lower_margin << 16) | (info->var.right_margin),\r\n&par->regs->front_porch);\r\n__raw_writel((info->var.vsync_len << 16) | (info->var.hsync_len),\r\n&par->regs->sync_length);\r\n__raw_writel(((info->var.yres + info->var.lower_margin + info->var.upper_margin + info->var.vsync_len - 1) << 16) |\r\n(info->var.xres + info->var.right_margin + info->var.left_margin + info->var.hsync_len - 1),\r\n&par->regs->line_length);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nfunc = 1;\r\nbreak;\r\ncase 16:\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nfunc = 2;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nfunc = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n__raw_writel((par->clk_sel << 6) | (func << 4) | 1,\r\n&par->regs->status);\r\ninfo->fix.line_length = (info->var.xres_virtual*info->var.bits_per_pixel)/8;\r\nreturn 0;\r\n}\r\nstatic int grvga_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info)\r\n{\r\nstruct grvga_par *par;\r\npar = info->par;\r\nif (regno >= 256)\r\nreturn -EINVAL;\r\nif (info->var.grayscale) {\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\n#define CNVT_TOHW(val, width) ((((val)<<(width))+0x7FFF-(val))>>16)\r\nred = CNVT_TOHW(red, info->var.red.length);\r\ngreen = CNVT_TOHW(green, info->var.green.length);\r\nblue = CNVT_TOHW(blue, info->var.blue.length);\r\ntransp = CNVT_TOHW(transp, info->var.transp.length);\r\n#undef CNVT_TOHW\r\nif (info->fix.visual == FB_VISUAL_PSEUDOCOLOR)\r\n__raw_writel((regno << 24) | (red << 16) | (green << 8) | blue,\r\n&par->regs->clut);\r\nelse if (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 v;\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\nv = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset) |\r\n(transp << info->var.transp.offset);\r\n((u32 *) (info->pseudo_palette))[regno] = v;\r\n}\r\nreturn 0;\r\n}\r\nstatic int grvga_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct grvga_par *par = info->par;\r\nstruct fb_fix_screeninfo *fix = &info->fix;\r\nu32 base_addr;\r\nif (var->xoffset != 0)\r\nreturn -EINVAL;\r\nbase_addr = fix->smem_start + (var->yoffset * fix->line_length);\r\nbase_addr &= ~3UL;\r\n__raw_writel(base_addr,\r\n&par->regs->fb_pos);\r\nreturn 0;\r\n}\r\nstatic int __devinit grvga_parse_custom(char *options,\r\nstruct fb_var_screeninfo *screendata)\r\n{\r\nchar *this_opt;\r\nint count = 0;\r\nif (!options || !*options)\r\nreturn -1;\r\nwhile ((this_opt = strsep(&options, " ")) != NULL) {\r\nif (!*this_opt)\r\ncontinue;\r\nswitch (count) {\r\ncase 0:\r\nscreendata->pixclock = simple_strtoul(this_opt, NULL, 0);\r\ncount++;\r\nbreak;\r\ncase 1:\r\nscreendata->xres = screendata->xres_virtual = simple_strtoul(this_opt, NULL, 0);\r\ncount++;\r\nbreak;\r\ncase 2:\r\nscreendata->right_margin = simple_strtoul(this_opt, NULL, 0);\r\ncount++;\r\nbreak;\r\ncase 3:\r\nscreendata->hsync_len = simple_strtoul(this_opt, NULL, 0);\r\ncount++;\r\nbreak;\r\ncase 4:\r\nscreendata->left_margin = simple_strtoul(this_opt, NULL, 0);\r\ncount++;\r\nbreak;\r\ncase 5:\r\nscreendata->yres = screendata->yres_virtual = simple_strtoul(this_opt, NULL, 0);\r\ncount++;\r\nbreak;\r\ncase 6:\r\nscreendata->lower_margin = simple_strtoul(this_opt, NULL, 0);\r\ncount++;\r\nbreak;\r\ncase 7:\r\nscreendata->vsync_len = simple_strtoul(this_opt, NULL, 0);\r\ncount++;\r\nbreak;\r\ncase 8:\r\nscreendata->upper_margin = simple_strtoul(this_opt, NULL, 0);\r\ncount++;\r\nbreak;\r\ncase 9:\r\nscreendata->bits_per_pixel = simple_strtoul(this_opt, NULL, 0);\r\ncount++;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nscreendata->activate = FB_ACTIVATE_NOW;\r\nscreendata->vmode = FB_VMODE_NONINTERLACED;\r\nreturn 0;\r\n}\r\nstatic int __devinit grvga_probe(struct platform_device *dev)\r\n{\r\nstruct fb_info *info;\r\nint retval = -ENOMEM;\r\nunsigned long virtual_start;\r\nunsigned long grvga_fix_addr = 0;\r\nunsigned long physical_start = 0;\r\nunsigned long grvga_mem_size = 0;\r\nstruct grvga_par *par = NULL;\r\nchar *options = NULL, *mode_opt = NULL;\r\ninfo = framebuffer_alloc(sizeof(struct grvga_par), &dev->dev);\r\nif (!info) {\r\ndev_err(&dev->dev, "framebuffer_alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (fb_get_options("grvga", &options)) {\r\nretval = -ENODEV;\r\ngoto free_fb;\r\n}\r\nif (!options || !*options)\r\noptions = "640x480-8@60";\r\nwhile (1) {\r\nchar *this_opt = strsep(&options, ",");\r\nif (!this_opt)\r\nbreak;\r\nif (!strncmp(this_opt, "custom", 6)) {\r\nif (grvga_parse_custom(this_opt, &info->var) < 0) {\r\ndev_err(&dev->dev, "Failed to parse custom mode (%s).\n", this_opt);\r\nretval = -EINVAL;\r\ngoto free_fb;\r\n}\r\n} else if (!strncmp(this_opt, "addr", 4))\r\ngrvga_fix_addr = simple_strtoul(this_opt + 5, NULL, 16);\r\nelse if (!strncmp(this_opt, "size", 4))\r\ngrvga_mem_size = simple_strtoul(this_opt + 5, NULL, 0);\r\nelse\r\nmode_opt = this_opt;\r\n}\r\npar = info->par;\r\ninfo->fbops = &grvga_ops;\r\ninfo->fix = grvga_fix;\r\ninfo->pseudo_palette = par->color_palette;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_PARTIAL_PAN_OK | FBINFO_HWACCEL_YPAN;\r\ninfo->fix.smem_len = grvga_mem_size;\r\nif (!devm_request_mem_region(&dev->dev, dev->resource[0].start,\r\nresource_size(&dev->resource[0]), "grlib-svgactrl regs")) {\r\ndev_err(&dev->dev, "registers already mapped\n");\r\nretval = -EBUSY;\r\ngoto free_fb;\r\n}\r\npar->regs = of_ioremap(&dev->resource[0], 0,\r\nresource_size(&dev->resource[0]),\r\n"grlib-svgactrl regs");\r\nif (!par->regs) {\r\ndev_err(&dev->dev, "failed to map registers\n");\r\nretval = -ENOMEM;\r\ngoto free_fb;\r\n}\r\nretval = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (retval < 0) {\r\ndev_err(&dev->dev, "failed to allocate mem with fb_alloc_cmap\n");\r\nretval = -ENOMEM;\r\ngoto unmap_regs;\r\n}\r\nif (mode_opt) {\r\nretval = fb_find_mode(&info->var, info, mode_opt,\r\ngrvga_modedb, sizeof(grvga_modedb), &grvga_modedb[0], 8);\r\nif (!retval || retval == 4) {\r\nretval = -EINVAL;\r\ngoto dealloc_cmap;\r\n}\r\n}\r\nif (!grvga_mem_size)\r\ngrvga_mem_size = info->var.xres_virtual * info->var.yres_virtual * info->var.bits_per_pixel/8;\r\nif (grvga_fix_addr) {\r\nphysical_start = grvga_fix_addr;\r\nif (!devm_request_mem_region(&dev->dev, physical_start,\r\ngrvga_mem_size, dev->name)) {\r\ndev_err(&dev->dev, "failed to request memory region\n");\r\nretval = -ENOMEM;\r\ngoto dealloc_cmap;\r\n}\r\nvirtual_start = (unsigned long) ioremap(physical_start, grvga_mem_size);\r\nif (!virtual_start) {\r\ndev_err(&dev->dev, "error mapping framebuffer memory\n");\r\nretval = -ENOMEM;\r\ngoto dealloc_cmap;\r\n}\r\n} else {\r\nunsigned long page;\r\nvirtual_start = (unsigned long) __get_free_pages(GFP_DMA,\r\nget_order(grvga_mem_size));\r\nif (!virtual_start) {\r\ndev_err(&dev->dev,\r\n"unable to allocate framebuffer memory (%lu bytes)\n",\r\ngrvga_mem_size);\r\nretval = -ENOMEM;\r\ngoto dealloc_cmap;\r\n}\r\nphysical_start = dma_map_single(&dev->dev, (void *)virtual_start, grvga_mem_size, DMA_TO_DEVICE);\r\nfor (page = virtual_start;\r\npage < PAGE_ALIGN(virtual_start + grvga_mem_size);\r\npage += PAGE_SIZE) {\r\nSetPageReserved(virt_to_page(page));\r\n}\r\npar->fb_alloced = 1;\r\n}\r\nmemset((unsigned long *) virtual_start, 0, grvga_mem_size);\r\ninfo->screen_base = (char __iomem *) virtual_start;\r\ninfo->fix.smem_start = physical_start;\r\ninfo->fix.smem_len = grvga_mem_size;\r\ndev_set_drvdata(&dev->dev, info);\r\ndev_info(&dev->dev,\r\n"Aeroflex Gaisler framebuffer device (fb%d), %dx%d-%d, using %luK of video memory @ %p\n",\r\ninfo->node, info->var.xres, info->var.yres, info->var.bits_per_pixel,\r\ngrvga_mem_size >> 10, info->screen_base);\r\nretval = register_framebuffer(info);\r\nif (retval < 0) {\r\ndev_err(&dev->dev, "failed to register framebuffer\n");\r\ngoto free_mem;\r\n}\r\n__raw_writel(physical_start, &par->regs->fb_pos);\r\n__raw_writel(__raw_readl(&par->regs->status) | 1,\r\n&par->regs->status);\r\nreturn 0;\r\nfree_mem:\r\ndev_set_drvdata(&dev->dev, NULL);\r\nif (grvga_fix_addr)\r\niounmap((void *)virtual_start);\r\nelse\r\nkfree((void *)virtual_start);\r\ndealloc_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nunmap_regs:\r\nof_iounmap(&dev->resource[0], par->regs,\r\nresource_size(&dev->resource[0]));\r\nfree_fb:\r\nframebuffer_release(info);\r\nreturn retval;\r\n}\r\nstatic int __devexit grvga_remove(struct platform_device *device)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(&device->dev);\r\nstruct grvga_par *par = info->par;\r\nif (info) {\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nof_iounmap(&device->resource[0], par->regs,\r\nresource_size(&device->resource[0]));\r\nif (!par->fb_alloced)\r\niounmap(info->screen_base);\r\nelse\r\nkfree((void *)info->screen_base);\r\nframebuffer_release(info);\r\ndev_set_drvdata(&device->dev, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init grvga_init(void)\r\n{\r\nreturn platform_driver_register(&grvga_driver);\r\n}\r\nstatic void __exit grvga_exit(void)\r\n{\r\nplatform_driver_unregister(&grvga_driver);\r\n}
