static inline int autofs4_can_expire(struct dentry *dentry,\r\nunsigned long timeout, int do_now)\r\n{\r\nstruct autofs_info *ino = autofs4_dentry_ino(dentry);\r\nif (ino == NULL)\r\nreturn 0;\r\nif (!do_now) {\r\nif (!timeout || time_after(ino->last_used + timeout, now))\r\nreturn 0;\r\nino->last_used = now;\r\n}\r\nreturn 1;\r\n}\r\nstatic int autofs4_mount_busy(struct vfsmount *mnt, struct dentry *dentry)\r\n{\r\nstruct dentry *top = dentry;\r\nstruct path path = {.mnt = mnt, .dentry = dentry};\r\nint status = 1;\r\nDPRINTK("dentry %p %.*s",\r\ndentry, (int)dentry->d_name.len, dentry->d_name.name);\r\npath_get(&path);\r\nif (!follow_down_one(&path))\r\ngoto done;\r\nif (is_autofs4_dentry(path.dentry)) {\r\nstruct autofs_sb_info *sbi = autofs4_sbi(path.dentry->d_sb);\r\nif (autofs_type_indirect(sbi->type))\r\ngoto done;\r\nif (!d_mountpoint(path.dentry)) {\r\nstatus = 0;\r\ngoto done;\r\n}\r\n}\r\nif (!may_umount_tree(path.mnt)) {\r\nstruct autofs_info *ino = autofs4_dentry_ino(top);\r\nino->last_used = jiffies;\r\ngoto done;\r\n}\r\nstatus = 0;\r\ndone:\r\nDPRINTK("returning = %d", status);\r\npath_put(&path);\r\nreturn status;\r\n}\r\nstatic struct dentry *get_next_positive_subdir(struct dentry *prev,\r\nstruct dentry *root)\r\n{\r\nstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\r\nstruct list_head *next;\r\nstruct dentry *q;\r\nspin_lock(&sbi->lookup_lock);\r\nspin_lock(&root->d_lock);\r\nif (prev)\r\nnext = prev->d_u.d_child.next;\r\nelse {\r\nprev = dget_dlock(root);\r\nnext = prev->d_subdirs.next;\r\n}\r\ncont:\r\nif (next == &root->d_subdirs) {\r\nspin_unlock(&root->d_lock);\r\nspin_unlock(&sbi->lookup_lock);\r\ndput(prev);\r\nreturn NULL;\r\n}\r\nq = list_entry(next, struct dentry, d_u.d_child);\r\nspin_lock_nested(&q->d_lock, DENTRY_D_LOCK_NESTED);\r\nif (q->d_count == 0 || !simple_positive(q)) {\r\nspin_unlock(&q->d_lock);\r\nnext = q->d_u.d_child.next;\r\ngoto cont;\r\n}\r\ndget_dlock(q);\r\nspin_unlock(&q->d_lock);\r\nspin_unlock(&root->d_lock);\r\nspin_unlock(&sbi->lookup_lock);\r\ndput(prev);\r\nreturn q;\r\n}\r\nstatic struct dentry *get_next_positive_dentry(struct dentry *prev,\r\nstruct dentry *root)\r\n{\r\nstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\r\nstruct list_head *next;\r\nstruct dentry *p, *ret;\r\nif (prev == NULL)\r\nreturn dget(root);\r\nspin_lock(&sbi->lookup_lock);\r\nrelock:\r\np = prev;\r\nspin_lock(&p->d_lock);\r\nagain:\r\nnext = p->d_subdirs.next;\r\nif (next == &p->d_subdirs) {\r\nwhile (1) {\r\nstruct dentry *parent;\r\nif (p == root) {\r\nspin_unlock(&p->d_lock);\r\nspin_unlock(&sbi->lookup_lock);\r\ndput(prev);\r\nreturn NULL;\r\n}\r\nparent = p->d_parent;\r\nif (!spin_trylock(&parent->d_lock)) {\r\nspin_unlock(&p->d_lock);\r\ncpu_relax();\r\ngoto relock;\r\n}\r\nspin_unlock(&p->d_lock);\r\nnext = p->d_u.d_child.next;\r\np = parent;\r\nif (next != &parent->d_subdirs)\r\nbreak;\r\n}\r\n}\r\nret = list_entry(next, struct dentry, d_u.d_child);\r\nspin_lock_nested(&ret->d_lock, DENTRY_D_LOCK_NESTED);\r\nif (!simple_positive(ret)) {\r\nspin_unlock(&p->d_lock);\r\nlock_set_subclass(&ret->d_lock.dep_map, 0, _RET_IP_);\r\np = ret;\r\ngoto again;\r\n}\r\ndget_dlock(ret);\r\nspin_unlock(&ret->d_lock);\r\nspin_unlock(&p->d_lock);\r\nspin_unlock(&sbi->lookup_lock);\r\ndput(prev);\r\nreturn ret;\r\n}\r\nstatic int autofs4_direct_busy(struct vfsmount *mnt,\r\nstruct dentry *top,\r\nunsigned long timeout,\r\nint do_now)\r\n{\r\nDPRINTK("top %p %.*s",\r\ntop, (int) top->d_name.len, top->d_name.name);\r\nif (!may_umount_tree(mnt)) {\r\nstruct autofs_info *ino = autofs4_dentry_ino(top);\r\nif (ino)\r\nino->last_used = jiffies;\r\nreturn 1;\r\n}\r\nif (!autofs4_can_expire(top, timeout, do_now))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int autofs4_tree_busy(struct vfsmount *mnt,\r\nstruct dentry *top,\r\nunsigned long timeout,\r\nint do_now)\r\n{\r\nstruct autofs_info *top_ino = autofs4_dentry_ino(top);\r\nstruct dentry *p;\r\nDPRINTK("top %p %.*s",\r\ntop, (int)top->d_name.len, top->d_name.name);\r\nif (!simple_positive(top))\r\nreturn 1;\r\np = NULL;\r\nwhile ((p = get_next_positive_dentry(p, top))) {\r\nDPRINTK("dentry %p %.*s",\r\np, (int) p->d_name.len, p->d_name.name);\r\nif (d_mountpoint(p)) {\r\nif (autofs4_mount_busy(mnt, p)) {\r\ntop_ino->last_used = jiffies;\r\ndput(p);\r\nreturn 1;\r\n}\r\n} else {\r\nstruct autofs_info *ino = autofs4_dentry_ino(p);\r\nunsigned int ino_count = atomic_read(&ino->count);\r\nd_invalidate(p);\r\nif (p == top)\r\nino_count += 2;\r\nelse\r\nino_count++;\r\nif (p->d_count > ino_count) {\r\ntop_ino->last_used = jiffies;\r\ndput(p);\r\nreturn 1;\r\n}\r\n}\r\n}\r\nif (!autofs4_can_expire(top, timeout, do_now))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct dentry *autofs4_check_leaves(struct vfsmount *mnt,\r\nstruct dentry *parent,\r\nunsigned long timeout,\r\nint do_now)\r\n{\r\nstruct dentry *p;\r\nDPRINTK("parent %p %.*s",\r\nparent, (int)parent->d_name.len, parent->d_name.name);\r\np = NULL;\r\nwhile ((p = get_next_positive_dentry(p, parent))) {\r\nDPRINTK("dentry %p %.*s",\r\np, (int) p->d_name.len, p->d_name.name);\r\nif (d_mountpoint(p)) {\r\nif (autofs4_mount_busy(mnt, p))\r\ncontinue;\r\nif (autofs4_can_expire(p, timeout, do_now))\r\nreturn p;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct dentry *autofs4_expire_direct(struct super_block *sb,\r\nstruct vfsmount *mnt,\r\nstruct autofs_sb_info *sbi,\r\nint how)\r\n{\r\nunsigned long timeout;\r\nstruct dentry *root = dget(sb->s_root);\r\nint do_now = how & AUTOFS_EXP_IMMEDIATE;\r\nstruct autofs_info *ino;\r\nif (!root)\r\nreturn NULL;\r\nnow = jiffies;\r\ntimeout = sbi->exp_timeout;\r\nspin_lock(&sbi->fs_lock);\r\nino = autofs4_dentry_ino(root);\r\nif (ino->flags & AUTOFS_INF_PENDING)\r\ngoto out;\r\nif (!autofs4_direct_busy(mnt, root, timeout, do_now)) {\r\nstruct autofs_info *ino = autofs4_dentry_ino(root);\r\nino->flags |= AUTOFS_INF_EXPIRING;\r\ninit_completion(&ino->expire_complete);\r\nspin_unlock(&sbi->fs_lock);\r\nreturn root;\r\n}\r\nout:\r\nspin_unlock(&sbi->fs_lock);\r\ndput(root);\r\nreturn NULL;\r\n}\r\nstruct dentry *autofs4_expire_indirect(struct super_block *sb,\r\nstruct vfsmount *mnt,\r\nstruct autofs_sb_info *sbi,\r\nint how)\r\n{\r\nunsigned long timeout;\r\nstruct dentry *root = sb->s_root;\r\nstruct dentry *dentry;\r\nstruct dentry *expired = NULL;\r\nint do_now = how & AUTOFS_EXP_IMMEDIATE;\r\nint exp_leaves = how & AUTOFS_EXP_LEAVES;\r\nstruct autofs_info *ino;\r\nunsigned int ino_count;\r\nif (!root)\r\nreturn NULL;\r\nnow = jiffies;\r\ntimeout = sbi->exp_timeout;\r\ndentry = NULL;\r\nwhile ((dentry = get_next_positive_subdir(dentry, root))) {\r\nspin_lock(&sbi->fs_lock);\r\nino = autofs4_dentry_ino(dentry);\r\nif (ino->flags & AUTOFS_INF_PENDING)\r\ngoto next;\r\nif (d_mountpoint(dentry)) {\r\nDPRINTK("checking mountpoint %p %.*s",\r\ndentry, (int)dentry->d_name.len, dentry->d_name.name);\r\nif (autofs4_mount_busy(mnt, dentry))\r\ngoto next;\r\nif (autofs4_can_expire(dentry, timeout, do_now)) {\r\nexpired = dentry;\r\ngoto found;\r\n}\r\ngoto next;\r\n}\r\nif (simple_empty(dentry))\r\ngoto next;\r\nif (!exp_leaves) {\r\nino_count = atomic_read(&ino->count) + 1;\r\nif (dentry->d_count > ino_count)\r\ngoto next;\r\nif (!autofs4_tree_busy(mnt, dentry, timeout, do_now)) {\r\nexpired = dentry;\r\ngoto found;\r\n}\r\n} else {\r\nino_count = atomic_read(&ino->count) + 1;\r\nif (dentry->d_count > ino_count)\r\ngoto next;\r\nexpired = autofs4_check_leaves(mnt, dentry, timeout, do_now);\r\nif (expired) {\r\ndput(dentry);\r\ngoto found;\r\n}\r\n}\r\nnext:\r\nspin_unlock(&sbi->fs_lock);\r\n}\r\nreturn NULL;\r\nfound:\r\nDPRINTK("returning %p %.*s",\r\nexpired, (int)expired->d_name.len, expired->d_name.name);\r\nino = autofs4_dentry_ino(expired);\r\nino->flags |= AUTOFS_INF_EXPIRING;\r\ninit_completion(&ino->expire_complete);\r\nspin_unlock(&sbi->fs_lock);\r\nspin_lock(&sbi->lookup_lock);\r\nspin_lock(&expired->d_parent->d_lock);\r\nspin_lock_nested(&expired->d_lock, DENTRY_D_LOCK_NESTED);\r\nlist_move(&expired->d_parent->d_subdirs, &expired->d_u.d_child);\r\nspin_unlock(&expired->d_lock);\r\nspin_unlock(&expired->d_parent->d_lock);\r\nspin_unlock(&sbi->lookup_lock);\r\nreturn expired;\r\n}\r\nint autofs4_expire_wait(struct dentry *dentry)\r\n{\r\nstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\r\nstruct autofs_info *ino = autofs4_dentry_ino(dentry);\r\nint status;\r\nspin_lock(&sbi->fs_lock);\r\nif (ino->flags & AUTOFS_INF_EXPIRING) {\r\nspin_unlock(&sbi->fs_lock);\r\nDPRINTK("waiting for expire %p name=%.*s",\r\ndentry, dentry->d_name.len, dentry->d_name.name);\r\nstatus = autofs4_wait(sbi, dentry, NFY_NONE);\r\nwait_for_completion(&ino->expire_complete);\r\nDPRINTK("expire done status=%d", status);\r\nif (d_unhashed(dentry))\r\nreturn -EAGAIN;\r\nreturn status;\r\n}\r\nspin_unlock(&sbi->fs_lock);\r\nreturn 0;\r\n}\r\nint autofs4_expire_run(struct super_block *sb,\r\nstruct vfsmount *mnt,\r\nstruct autofs_sb_info *sbi,\r\nstruct autofs_packet_expire __user *pkt_p)\r\n{\r\nstruct autofs_packet_expire pkt;\r\nstruct autofs_info *ino;\r\nstruct dentry *dentry;\r\nint ret = 0;\r\nmemset(&pkt,0,sizeof pkt);\r\npkt.hdr.proto_version = sbi->version;\r\npkt.hdr.type = autofs_ptype_expire;\r\nif ((dentry = autofs4_expire_indirect(sb, mnt, sbi, 0)) == NULL)\r\nreturn -EAGAIN;\r\npkt.len = dentry->d_name.len;\r\nmemcpy(pkt.name, dentry->d_name.name, pkt.len);\r\npkt.name[pkt.len] = '\0';\r\ndput(dentry);\r\nif ( copy_to_user(pkt_p, &pkt, sizeof(struct autofs_packet_expire)) )\r\nret = -EFAULT;\r\nspin_lock(&sbi->fs_lock);\r\nino = autofs4_dentry_ino(dentry);\r\nino->flags &= ~AUTOFS_INF_EXPIRING;\r\ncomplete_all(&ino->expire_complete);\r\nspin_unlock(&sbi->fs_lock);\r\nreturn ret;\r\n}\r\nint autofs4_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,\r\nstruct autofs_sb_info *sbi, int when)\r\n{\r\nstruct dentry *dentry;\r\nint ret = -EAGAIN;\r\nif (autofs_type_trigger(sbi->type))\r\ndentry = autofs4_expire_direct(sb, mnt, sbi, when);\r\nelse\r\ndentry = autofs4_expire_indirect(sb, mnt, sbi, when);\r\nif (dentry) {\r\nstruct autofs_info *ino = autofs4_dentry_ino(dentry);\r\nret = autofs4_wait(sbi, dentry, NFY_EXPIRE);\r\nspin_lock(&sbi->fs_lock);\r\nino->flags &= ~AUTOFS_INF_EXPIRING;\r\nspin_lock(&dentry->d_lock);\r\nif (!ret) {\r\nif ((IS_ROOT(dentry) ||\r\n(autofs_type_indirect(sbi->type) &&\r\nIS_ROOT(dentry->d_parent))) &&\r\n!(dentry->d_flags & DCACHE_NEED_AUTOMOUNT))\r\n__managed_dentry_set_automount(dentry);\r\n}\r\nspin_unlock(&dentry->d_lock);\r\ncomplete_all(&ino->expire_complete);\r\nspin_unlock(&sbi->fs_lock);\r\ndput(dentry);\r\n}\r\nreturn ret;\r\n}\r\nint autofs4_expire_multi(struct super_block *sb, struct vfsmount *mnt,\r\nstruct autofs_sb_info *sbi, int __user *arg)\r\n{\r\nint do_now = 0;\r\nif (arg && get_user(do_now, arg))\r\nreturn -EFAULT;\r\nreturn autofs4_do_expire_multi(sb, mnt, sbi, do_now);\r\n}
