void drbd_md_io_complete(struct bio *bio, int error)\r\n{\r\nstruct drbd_md_io *md_io;\r\nstruct drbd_conf *mdev;\r\nmd_io = (struct drbd_md_io *)bio->bi_private;\r\nmdev = container_of(md_io, struct drbd_conf, md_io);\r\nmd_io->error = error;\r\ndrbd_md_put_buffer(mdev);\r\nmd_io->done = 1;\r\nwake_up(&mdev->misc_wait);\r\nbio_put(bio);\r\nput_ldev(mdev);\r\n}\r\nvoid drbd_endio_read_sec_final(struct drbd_epoch_entry *e) __releases(local)\r\n{\r\nunsigned long flags = 0;\r\nstruct drbd_conf *mdev = e->mdev;\r\nD_ASSERT(e->block_id != ID_VACANT);\r\nspin_lock_irqsave(&mdev->req_lock, flags);\r\nmdev->read_cnt += e->size >> 9;\r\nlist_del(&e->w.list);\r\nif (list_empty(&mdev->read_ee))\r\nwake_up(&mdev->ee_wait);\r\nif (test_bit(__EE_WAS_ERROR, &e->flags))\r\n__drbd_chk_io_error(mdev, DRBD_IO_ERROR);\r\nspin_unlock_irqrestore(&mdev->req_lock, flags);\r\ndrbd_queue_work(&mdev->data.work, &e->w);\r\nput_ldev(mdev);\r\n}\r\nstatic void drbd_endio_write_sec_final(struct drbd_epoch_entry *e) __releases(local)\r\n{\r\nunsigned long flags = 0;\r\nstruct drbd_conf *mdev = e->mdev;\r\nsector_t e_sector;\r\nint do_wake;\r\nint is_syncer_req;\r\nint do_al_complete_io;\r\nD_ASSERT(e->block_id != ID_VACANT);\r\ne_sector = e->sector;\r\ndo_al_complete_io = e->flags & EE_CALL_AL_COMPLETE_IO;\r\nis_syncer_req = is_syncer_block_id(e->block_id);\r\nspin_lock_irqsave(&mdev->req_lock, flags);\r\nmdev->writ_cnt += e->size >> 9;\r\nlist_del(&e->w.list);\r\nlist_add_tail(&e->w.list, &mdev->done_ee);\r\ndo_wake = is_syncer_req\r\n? list_empty(&mdev->sync_ee)\r\n: list_empty(&mdev->active_ee);\r\nif (test_bit(__EE_WAS_ERROR, &e->flags))\r\n__drbd_chk_io_error(mdev, DRBD_IO_ERROR);\r\nspin_unlock_irqrestore(&mdev->req_lock, flags);\r\nif (is_syncer_req)\r\ndrbd_rs_complete_io(mdev, e_sector);\r\nif (do_wake)\r\nwake_up(&mdev->ee_wait);\r\nif (do_al_complete_io)\r\ndrbd_al_complete_io(mdev, e_sector);\r\nwake_asender(mdev);\r\nput_ldev(mdev);\r\n}\r\nvoid drbd_endio_sec(struct bio *bio, int error)\r\n{\r\nstruct drbd_epoch_entry *e = bio->bi_private;\r\nstruct drbd_conf *mdev = e->mdev;\r\nint uptodate = bio_flagged(bio, BIO_UPTODATE);\r\nint is_write = bio_data_dir(bio) == WRITE;\r\nif (error && __ratelimit(&drbd_ratelimit_state))\r\ndev_warn(DEV, "%s: error=%d s=%llus\n",\r\nis_write ? "write" : "read", error,\r\n(unsigned long long)e->sector);\r\nif (!error && !uptodate) {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_warn(DEV, "%s: setting error to -EIO s=%llus\n",\r\nis_write ? "write" : "read",\r\n(unsigned long long)e->sector);\r\nerror = -EIO;\r\n}\r\nif (error)\r\nset_bit(__EE_WAS_ERROR, &e->flags);\r\nbio_put(bio);\r\nif (atomic_dec_and_test(&e->pending_bios)) {\r\nif (is_write)\r\ndrbd_endio_write_sec_final(e);\r\nelse\r\ndrbd_endio_read_sec_final(e);\r\n}\r\n}\r\nvoid drbd_endio_pri(struct bio *bio, int error)\r\n{\r\nunsigned long flags;\r\nstruct drbd_request *req = bio->bi_private;\r\nstruct drbd_conf *mdev = req->mdev;\r\nstruct bio_and_error m;\r\nenum drbd_req_event what;\r\nint uptodate = bio_flagged(bio, BIO_UPTODATE);\r\nif (!error && !uptodate) {\r\ndev_warn(DEV, "p %s: setting error to -EIO\n",\r\nbio_data_dir(bio) == WRITE ? "write" : "read");\r\nerror = -EIO;\r\n}\r\nif (unlikely(error)) {\r\nwhat = (bio_data_dir(bio) == WRITE)\r\n? write_completed_with_error\r\n: (bio_rw(bio) == READ)\r\n? read_completed_with_error\r\n: read_ahead_completed_with_error;\r\n} else\r\nwhat = completed_ok;\r\nbio_put(req->private_bio);\r\nreq->private_bio = ERR_PTR(error);\r\nspin_lock_irqsave(&mdev->req_lock, flags);\r\n__req_mod(req, what, &m);\r\nspin_unlock_irqrestore(&mdev->req_lock, flags);\r\nput_ldev(mdev);\r\nif (m.bio)\r\ncomplete_master_bio(mdev, &m);\r\n}\r\nint w_read_retry_remote(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_request *req = container_of(w, struct drbd_request, w);\r\nspin_lock_irq(&mdev->req_lock);\r\nif (cancel || mdev->state.pdsk != D_UP_TO_DATE) {\r\n_req_mod(req, read_retry_remote_canceled);\r\nspin_unlock_irq(&mdev->req_lock);\r\nreturn 1;\r\n}\r\nspin_unlock_irq(&mdev->req_lock);\r\nreturn w_send_read_req(mdev, w, 0);\r\n}\r\nvoid drbd_csum_ee(struct drbd_conf *mdev, struct crypto_hash *tfm, struct drbd_epoch_entry *e, void *digest)\r\n{\r\nstruct hash_desc desc;\r\nstruct scatterlist sg;\r\nstruct page *page = e->pages;\r\nstruct page *tmp;\r\nunsigned len;\r\ndesc.tfm = tfm;\r\ndesc.flags = 0;\r\nsg_init_table(&sg, 1);\r\ncrypto_hash_init(&desc);\r\nwhile ((tmp = page_chain_next(page))) {\r\nsg_set_page(&sg, page, PAGE_SIZE, 0);\r\ncrypto_hash_update(&desc, &sg, sg.length);\r\npage = tmp;\r\n}\r\nlen = e->size & (PAGE_SIZE - 1);\r\nsg_set_page(&sg, page, len ?: PAGE_SIZE, 0);\r\ncrypto_hash_update(&desc, &sg, sg.length);\r\ncrypto_hash_final(&desc, digest);\r\n}\r\nvoid drbd_csum_bio(struct drbd_conf *mdev, struct crypto_hash *tfm, struct bio *bio, void *digest)\r\n{\r\nstruct hash_desc desc;\r\nstruct scatterlist sg;\r\nstruct bio_vec *bvec;\r\nint i;\r\ndesc.tfm = tfm;\r\ndesc.flags = 0;\r\nsg_init_table(&sg, 1);\r\ncrypto_hash_init(&desc);\r\nbio_for_each_segment(bvec, bio, i) {\r\nsg_set_page(&sg, bvec->bv_page, bvec->bv_len, bvec->bv_offset);\r\ncrypto_hash_update(&desc, &sg, sg.length);\r\n}\r\ncrypto_hash_final(&desc, digest);\r\n}\r\nint w_e_send_csum(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_epoch_entry *e = container_of(w, struct drbd_epoch_entry, w);\r\nint digest_size;\r\nvoid *digest;\r\nint ok = 1;\r\nD_ASSERT(e->block_id == DRBD_MAGIC + 0xbeef);\r\nif (unlikely(cancel))\r\ngoto out;\r\nif (likely((e->flags & EE_WAS_ERROR) != 0))\r\ngoto out;\r\ndigest_size = crypto_hash_digestsize(mdev->csums_tfm);\r\ndigest = kmalloc(digest_size, GFP_NOIO);\r\nif (digest) {\r\nsector_t sector = e->sector;\r\nunsigned int size = e->size;\r\ndrbd_csum_ee(mdev, mdev->csums_tfm, e, digest);\r\ndrbd_free_ee(mdev, e);\r\ne = NULL;\r\ninc_rs_pending(mdev);\r\nok = drbd_send_drequest_csum(mdev, sector, size,\r\ndigest, digest_size,\r\nP_CSUM_RS_REQUEST);\r\nkfree(digest);\r\n} else {\r\ndev_err(DEV, "kmalloc() of digest failed.\n");\r\nok = 0;\r\n}\r\nout:\r\nif (e)\r\ndrbd_free_ee(mdev, e);\r\nif (unlikely(!ok))\r\ndev_err(DEV, "drbd_send_drequest(..., csum) failed\n");\r\nreturn ok;\r\n}\r\nstatic int read_for_csum(struct drbd_conf *mdev, sector_t sector, int size)\r\n{\r\nstruct drbd_epoch_entry *e;\r\nif (!get_ldev(mdev))\r\nreturn -EIO;\r\nif (drbd_rs_should_slow_down(mdev, sector))\r\ngoto defer;\r\ne = drbd_alloc_ee(mdev, DRBD_MAGIC+0xbeef, sector, size, GFP_TRY);\r\nif (!e)\r\ngoto defer;\r\ne->w.cb = w_e_send_csum;\r\nspin_lock_irq(&mdev->req_lock);\r\nlist_add(&e->w.list, &mdev->read_ee);\r\nspin_unlock_irq(&mdev->req_lock);\r\natomic_add(size >> 9, &mdev->rs_sect_ev);\r\nif (drbd_submit_ee(mdev, e, READ, DRBD_FAULT_RS_RD) == 0)\r\nreturn 0;\r\nspin_lock_irq(&mdev->req_lock);\r\nlist_del(&e->w.list);\r\nspin_unlock_irq(&mdev->req_lock);\r\ndrbd_free_ee(mdev, e);\r\ndefer:\r\nput_ldev(mdev);\r\nreturn -EAGAIN;\r\n}\r\nint w_resync_timer(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nswitch (mdev->state.conn) {\r\ncase C_VERIFY_S:\r\nw_make_ov_request(mdev, w, cancel);\r\nbreak;\r\ncase C_SYNC_TARGET:\r\nw_make_resync_request(mdev, w, cancel);\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nvoid resync_timer_fn(unsigned long data)\r\n{\r\nstruct drbd_conf *mdev = (struct drbd_conf *) data;\r\nif (list_empty(&mdev->resync_work.list))\r\ndrbd_queue_work(&mdev->data.work, &mdev->resync_work);\r\n}\r\nstatic void fifo_set(struct fifo_buffer *fb, int value)\r\n{\r\nint i;\r\nfor (i = 0; i < fb->size; i++)\r\nfb->values[i] = value;\r\n}\r\nstatic int fifo_push(struct fifo_buffer *fb, int value)\r\n{\r\nint ov;\r\nov = fb->values[fb->head_index];\r\nfb->values[fb->head_index++] = value;\r\nif (fb->head_index >= fb->size)\r\nfb->head_index = 0;\r\nreturn ov;\r\n}\r\nstatic void fifo_add_val(struct fifo_buffer *fb, int value)\r\n{\r\nint i;\r\nfor (i = 0; i < fb->size; i++)\r\nfb->values[i] += value;\r\n}\r\nstatic int drbd_rs_controller(struct drbd_conf *mdev)\r\n{\r\nunsigned int sect_in;\r\nunsigned int want;\r\nint req_sect;\r\nint correction;\r\nint cps;\r\nint steps;\r\nint curr_corr;\r\nint max_sect;\r\nsect_in = atomic_xchg(&mdev->rs_sect_in, 0);\r\nmdev->rs_in_flight -= sect_in;\r\nspin_lock(&mdev->peer_seq_lock);\r\nsteps = mdev->rs_plan_s.size;\r\nif (mdev->rs_in_flight + sect_in == 0) {\r\nwant = ((mdev->sync_conf.rate * 2 * SLEEP_TIME) / HZ) * steps;\r\n} else {\r\nwant = mdev->sync_conf.c_fill_target ? mdev->sync_conf.c_fill_target :\r\nsect_in * mdev->sync_conf.c_delay_target * HZ / (SLEEP_TIME * 10);\r\n}\r\ncorrection = want - mdev->rs_in_flight - mdev->rs_planed;\r\ncps = correction / steps;\r\nfifo_add_val(&mdev->rs_plan_s, cps);\r\nmdev->rs_planed += cps * steps;\r\ncurr_corr = fifo_push(&mdev->rs_plan_s, 0);\r\nspin_unlock(&mdev->peer_seq_lock);\r\nmdev->rs_planed -= curr_corr;\r\nreq_sect = sect_in + curr_corr;\r\nif (req_sect < 0)\r\nreq_sect = 0;\r\nmax_sect = (mdev->sync_conf.c_max_rate * 2 * SLEEP_TIME) / HZ;\r\nif (req_sect > max_sect)\r\nreq_sect = max_sect;\r\nreturn req_sect;\r\n}\r\nstatic int drbd_rs_number_requests(struct drbd_conf *mdev)\r\n{\r\nint number;\r\nif (mdev->rs_plan_s.size) {\r\nnumber = drbd_rs_controller(mdev) >> (BM_BLOCK_SHIFT - 9);\r\nmdev->c_sync_rate = number * HZ * (BM_BLOCK_SIZE / 1024) / SLEEP_TIME;\r\n} else {\r\nmdev->c_sync_rate = mdev->sync_conf.rate;\r\nnumber = SLEEP_TIME * mdev->c_sync_rate / ((BM_BLOCK_SIZE / 1024) * HZ);\r\n}\r\nreturn number;\r\n}\r\nstatic int w_make_resync_request(struct drbd_conf *mdev,\r\nstruct drbd_work *w, int cancel)\r\n{\r\nunsigned long bit;\r\nsector_t sector;\r\nconst sector_t capacity = drbd_get_capacity(mdev->this_bdev);\r\nint max_bio_size;\r\nint number, rollback_i, size;\r\nint align, queued, sndbuf;\r\nint i = 0;\r\nif (unlikely(cancel))\r\nreturn 1;\r\nif (mdev->rs_total == 0) {\r\ndrbd_resync_finished(mdev);\r\nreturn 1;\r\n}\r\nif (!get_ldev(mdev)) {\r\ndev_err(DEV, "Disk broke down during resync!\n");\r\nreturn 1;\r\n}\r\nmax_bio_size = queue_max_hw_sectors(mdev->rq_queue) << 9;\r\nnumber = drbd_rs_number_requests(mdev);\r\nif (number == 0)\r\ngoto requeue;\r\nfor (i = 0; i < number; i++) {\r\nmutex_lock(&mdev->data.mutex);\r\nif (mdev->data.socket) {\r\nqueued = mdev->data.socket->sk->sk_wmem_queued;\r\nsndbuf = mdev->data.socket->sk->sk_sndbuf;\r\n} else {\r\nqueued = 1;\r\nsndbuf = 0;\r\n}\r\nmutex_unlock(&mdev->data.mutex);\r\nif (queued > sndbuf / 2)\r\ngoto requeue;\r\nnext_sector:\r\nsize = BM_BLOCK_SIZE;\r\nbit = drbd_bm_find_next(mdev, mdev->bm_resync_fo);\r\nif (bit == DRBD_END_OF_BITMAP) {\r\nmdev->bm_resync_fo = drbd_bm_bits(mdev);\r\nput_ldev(mdev);\r\nreturn 1;\r\n}\r\nsector = BM_BIT_TO_SECT(bit);\r\nif (drbd_rs_should_slow_down(mdev, sector) ||\r\ndrbd_try_rs_begin_io(mdev, sector)) {\r\nmdev->bm_resync_fo = bit;\r\ngoto requeue;\r\n}\r\nmdev->bm_resync_fo = bit + 1;\r\nif (unlikely(drbd_bm_test_bit(mdev, bit) == 0)) {\r\ndrbd_rs_complete_io(mdev, sector);\r\ngoto next_sector;\r\n}\r\n#if DRBD_MAX_BIO_SIZE > BM_BLOCK_SIZE\r\nalign = 1;\r\nrollback_i = i;\r\nfor (;;) {\r\nif (size + BM_BLOCK_SIZE > max_bio_size)\r\nbreak;\r\nif (sector & ((1<<(align+3))-1))\r\nbreak;\r\nif (((bit+1) & BM_BLOCKS_PER_BM_EXT_MASK) == 0)\r\nbreak;\r\nif (drbd_bm_test_bit(mdev, bit+1) != 1)\r\nbreak;\r\nbit++;\r\nsize += BM_BLOCK_SIZE;\r\nif ((BM_BLOCK_SIZE << align) <= size)\r\nalign++;\r\ni++;\r\n}\r\nif (size > BM_BLOCK_SIZE)\r\nmdev->bm_resync_fo = bit + 1;\r\n#endif\r\nif (sector + (size>>9) > capacity)\r\nsize = (capacity-sector)<<9;\r\nif (mdev->agreed_pro_version >= 89 && mdev->csums_tfm) {\r\nswitch (read_for_csum(mdev, sector, size)) {\r\ncase -EIO:\r\nput_ldev(mdev);\r\nreturn 0;\r\ncase -EAGAIN:\r\ndrbd_rs_complete_io(mdev, sector);\r\nmdev->bm_resync_fo = BM_SECT_TO_BIT(sector);\r\ni = rollback_i;\r\ngoto requeue;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n} else {\r\ninc_rs_pending(mdev);\r\nif (!drbd_send_drequest(mdev, P_RS_DATA_REQUEST,\r\nsector, size, ID_SYNCER)) {\r\ndev_err(DEV, "drbd_send_drequest() failed, aborting...\n");\r\ndec_rs_pending(mdev);\r\nput_ldev(mdev);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nif (mdev->bm_resync_fo >= drbd_bm_bits(mdev)) {\r\nput_ldev(mdev);\r\nreturn 1;\r\n}\r\nrequeue:\r\nmdev->rs_in_flight += (i << (BM_BLOCK_SHIFT - 9));\r\nmod_timer(&mdev->resync_timer, jiffies + SLEEP_TIME);\r\nput_ldev(mdev);\r\nreturn 1;\r\n}\r\nstatic int w_make_ov_request(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nint number, i, size;\r\nsector_t sector;\r\nconst sector_t capacity = drbd_get_capacity(mdev->this_bdev);\r\nif (unlikely(cancel))\r\nreturn 1;\r\nnumber = drbd_rs_number_requests(mdev);\r\nsector = mdev->ov_position;\r\nfor (i = 0; i < number; i++) {\r\nif (sector >= capacity) {\r\nreturn 1;\r\n}\r\nsize = BM_BLOCK_SIZE;\r\nif (drbd_rs_should_slow_down(mdev, sector) ||\r\ndrbd_try_rs_begin_io(mdev, sector)) {\r\nmdev->ov_position = sector;\r\ngoto requeue;\r\n}\r\nif (sector + (size>>9) > capacity)\r\nsize = (capacity-sector)<<9;\r\ninc_rs_pending(mdev);\r\nif (!drbd_send_ov_request(mdev, sector, size)) {\r\ndec_rs_pending(mdev);\r\nreturn 0;\r\n}\r\nsector += BM_SECT_PER_BIT;\r\n}\r\nmdev->ov_position = sector;\r\nrequeue:\r\nmdev->rs_in_flight += (i << (BM_BLOCK_SHIFT - 9));\r\nmod_timer(&mdev->resync_timer, jiffies + SLEEP_TIME);\r\nreturn 1;\r\n}\r\nvoid start_resync_timer_fn(unsigned long data)\r\n{\r\nstruct drbd_conf *mdev = (struct drbd_conf *) data;\r\ndrbd_queue_work(&mdev->data.work, &mdev->start_resync_work);\r\n}\r\nint w_start_resync(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nif (atomic_read(&mdev->unacked_cnt) || atomic_read(&mdev->rs_pending_cnt)) {\r\ndev_warn(DEV, "w_start_resync later...\n");\r\nmdev->start_resync_timer.expires = jiffies + HZ/10;\r\nadd_timer(&mdev->start_resync_timer);\r\nreturn 1;\r\n}\r\ndrbd_start_resync(mdev, C_SYNC_SOURCE);\r\nclear_bit(AHEAD_TO_SYNC_SOURCE, &mdev->flags);\r\nreturn 1;\r\n}\r\nint w_ov_finished(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nkfree(w);\r\nov_oos_print(mdev);\r\ndrbd_resync_finished(mdev);\r\nreturn 1;\r\n}\r\nstatic int w_resync_finished(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nkfree(w);\r\ndrbd_resync_finished(mdev);\r\nreturn 1;\r\n}\r\nstatic void ping_peer(struct drbd_conf *mdev)\r\n{\r\nclear_bit(GOT_PING_ACK, &mdev->flags);\r\nrequest_ping(mdev);\r\nwait_event(mdev->misc_wait,\r\ntest_bit(GOT_PING_ACK, &mdev->flags) || mdev->state.conn < C_CONNECTED);\r\n}\r\nint drbd_resync_finished(struct drbd_conf *mdev)\r\n{\r\nunsigned long db, dt, dbdt;\r\nunsigned long n_oos;\r\nunion drbd_state os, ns;\r\nstruct drbd_work *w;\r\nchar *khelper_cmd = NULL;\r\nint verify_done = 0;\r\nif (drbd_rs_del_all(mdev)) {\r\nschedule_timeout_interruptible(HZ / 10);\r\nw = kmalloc(sizeof(struct drbd_work), GFP_ATOMIC);\r\nif (w) {\r\nw->cb = w_resync_finished;\r\ndrbd_queue_work(&mdev->data.work, w);\r\nreturn 1;\r\n}\r\ndev_err(DEV, "Warn failed to drbd_rs_del_all() and to kmalloc(w).\n");\r\n}\r\ndt = (jiffies - mdev->rs_start - mdev->rs_paused) / HZ;\r\nif (dt <= 0)\r\ndt = 1;\r\ndb = mdev->rs_total;\r\ndbdt = Bit2KB(db/dt);\r\nmdev->rs_paused /= HZ;\r\nif (!get_ldev(mdev))\r\ngoto out;\r\nping_peer(mdev);\r\nspin_lock_irq(&mdev->req_lock);\r\nos = mdev->state;\r\nverify_done = (os.conn == C_VERIFY_S || os.conn == C_VERIFY_T);\r\nif (os.conn <= C_CONNECTED)\r\ngoto out_unlock;\r\nns = os;\r\nns.conn = C_CONNECTED;\r\ndev_info(DEV, "%s done (total %lu sec; paused %lu sec; %lu K/sec)\n",\r\nverify_done ? "Online verify " : "Resync",\r\ndt + mdev->rs_paused, mdev->rs_paused, dbdt);\r\nn_oos = drbd_bm_total_weight(mdev);\r\nif (os.conn == C_VERIFY_S || os.conn == C_VERIFY_T) {\r\nif (n_oos) {\r\ndev_alert(DEV, "Online verify found %lu %dk block out of sync!\n",\r\nn_oos, Bit2KB(1));\r\nkhelper_cmd = "out-of-sync";\r\n}\r\n} else {\r\nD_ASSERT((n_oos - mdev->rs_failed) == 0);\r\nif (os.conn == C_SYNC_TARGET || os.conn == C_PAUSED_SYNC_T)\r\nkhelper_cmd = "after-resync-target";\r\nif (mdev->csums_tfm && mdev->rs_total) {\r\nconst unsigned long s = mdev->rs_same_csum;\r\nconst unsigned long t = mdev->rs_total;\r\nconst int ratio =\r\n(t == 0) ? 0 :\r\n(t < 100000) ? ((s*100)/t) : (s/(t/100));\r\ndev_info(DEV, "%u %% had equal checksums, eliminated: %luK; "\r\n"transferred %luK total %luK\n",\r\nratio,\r\nBit2KB(mdev->rs_same_csum),\r\nBit2KB(mdev->rs_total - mdev->rs_same_csum),\r\nBit2KB(mdev->rs_total));\r\n}\r\n}\r\nif (mdev->rs_failed) {\r\ndev_info(DEV, " %lu failed blocks\n", mdev->rs_failed);\r\nif (os.conn == C_SYNC_TARGET || os.conn == C_PAUSED_SYNC_T) {\r\nns.disk = D_INCONSISTENT;\r\nns.pdsk = D_UP_TO_DATE;\r\n} else {\r\nns.disk = D_UP_TO_DATE;\r\nns.pdsk = D_INCONSISTENT;\r\n}\r\n} else {\r\nns.disk = D_UP_TO_DATE;\r\nns.pdsk = D_UP_TO_DATE;\r\nif (os.conn == C_SYNC_TARGET || os.conn == C_PAUSED_SYNC_T) {\r\nif (mdev->p_uuid) {\r\nint i;\r\nfor (i = UI_BITMAP ; i <= UI_HISTORY_END ; i++)\r\n_drbd_uuid_set(mdev, i, mdev->p_uuid[i]);\r\ndrbd_uuid_set(mdev, UI_BITMAP, mdev->ldev->md.uuid[UI_CURRENT]);\r\n_drbd_uuid_set(mdev, UI_CURRENT, mdev->p_uuid[UI_CURRENT]);\r\n} else {\r\ndev_err(DEV, "mdev->p_uuid is NULL! BUG\n");\r\n}\r\n}\r\nif (!(os.conn == C_VERIFY_S || os.conn == C_VERIFY_T)) {\r\ndrbd_uuid_set_bm(mdev, 0UL);\r\ndrbd_print_uuids(mdev, "updated UUIDs");\r\nif (mdev->p_uuid) {\r\nint i;\r\nfor (i = UI_CURRENT ; i <= UI_HISTORY_END ; i++)\r\nmdev->p_uuid[i] = mdev->ldev->md.uuid[i];\r\n}\r\n}\r\n}\r\n_drbd_set_state(mdev, ns, CS_VERBOSE, NULL);\r\nout_unlock:\r\nspin_unlock_irq(&mdev->req_lock);\r\nput_ldev(mdev);\r\nout:\r\nmdev->rs_total = 0;\r\nmdev->rs_failed = 0;\r\nmdev->rs_paused = 0;\r\nif (verify_done)\r\nmdev->ov_start_sector = 0;\r\ndrbd_md_sync(mdev);\r\nif (khelper_cmd)\r\ndrbd_khelper(mdev, khelper_cmd);\r\nreturn 1;\r\n}\r\nstatic void move_to_net_ee_or_free(struct drbd_conf *mdev, struct drbd_epoch_entry *e)\r\n{\r\nif (drbd_ee_has_active_page(e)) {\r\nint i = (e->size + PAGE_SIZE -1) >> PAGE_SHIFT;\r\natomic_add(i, &mdev->pp_in_use_by_net);\r\natomic_sub(i, &mdev->pp_in_use);\r\nspin_lock_irq(&mdev->req_lock);\r\nlist_add_tail(&e->w.list, &mdev->net_ee);\r\nspin_unlock_irq(&mdev->req_lock);\r\nwake_up(&drbd_pp_wait);\r\n} else\r\ndrbd_free_ee(mdev, e);\r\n}\r\nint w_e_end_data_req(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_epoch_entry *e = container_of(w, struct drbd_epoch_entry, w);\r\nint ok;\r\nif (unlikely(cancel)) {\r\ndrbd_free_ee(mdev, e);\r\ndec_unacked(mdev);\r\nreturn 1;\r\n}\r\nif (likely((e->flags & EE_WAS_ERROR) == 0)) {\r\nok = drbd_send_block(mdev, P_DATA_REPLY, e);\r\n} else {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_err(DEV, "Sending NegDReply. sector=%llus.\n",\r\n(unsigned long long)e->sector);\r\nok = drbd_send_ack(mdev, P_NEG_DREPLY, e);\r\n}\r\ndec_unacked(mdev);\r\nmove_to_net_ee_or_free(mdev, e);\r\nif (unlikely(!ok))\r\ndev_err(DEV, "drbd_send_block() failed\n");\r\nreturn ok;\r\n}\r\nint w_e_end_rsdata_req(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_epoch_entry *e = container_of(w, struct drbd_epoch_entry, w);\r\nint ok;\r\nif (unlikely(cancel)) {\r\ndrbd_free_ee(mdev, e);\r\ndec_unacked(mdev);\r\nreturn 1;\r\n}\r\nif (get_ldev_if_state(mdev, D_FAILED)) {\r\ndrbd_rs_complete_io(mdev, e->sector);\r\nput_ldev(mdev);\r\n}\r\nif (mdev->state.conn == C_AHEAD) {\r\nok = drbd_send_ack(mdev, P_RS_CANCEL, e);\r\n} else if (likely((e->flags & EE_WAS_ERROR) == 0)) {\r\nif (likely(mdev->state.pdsk >= D_INCONSISTENT)) {\r\ninc_rs_pending(mdev);\r\nok = drbd_send_block(mdev, P_RS_DATA_REPLY, e);\r\n} else {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_err(DEV, "Not sending RSDataReply, "\r\n"partner DISKLESS!\n");\r\nok = 1;\r\n}\r\n} else {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_err(DEV, "Sending NegRSDReply. sector %llus.\n",\r\n(unsigned long long)e->sector);\r\nok = drbd_send_ack(mdev, P_NEG_RS_DREPLY, e);\r\ndrbd_rs_failed_io(mdev, e->sector, e->size);\r\n}\r\ndec_unacked(mdev);\r\nmove_to_net_ee_or_free(mdev, e);\r\nif (unlikely(!ok))\r\ndev_err(DEV, "drbd_send_block() failed\n");\r\nreturn ok;\r\n}\r\nint w_e_end_csum_rs_req(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_epoch_entry *e = container_of(w, struct drbd_epoch_entry, w);\r\nstruct digest_info *di;\r\nint digest_size;\r\nvoid *digest = NULL;\r\nint ok, eq = 0;\r\nif (unlikely(cancel)) {\r\ndrbd_free_ee(mdev, e);\r\ndec_unacked(mdev);\r\nreturn 1;\r\n}\r\nif (get_ldev(mdev)) {\r\ndrbd_rs_complete_io(mdev, e->sector);\r\nput_ldev(mdev);\r\n}\r\ndi = e->digest;\r\nif (likely((e->flags & EE_WAS_ERROR) == 0)) {\r\nif (mdev->csums_tfm) {\r\ndigest_size = crypto_hash_digestsize(mdev->csums_tfm);\r\nD_ASSERT(digest_size == di->digest_size);\r\ndigest = kmalloc(digest_size, GFP_NOIO);\r\n}\r\nif (digest) {\r\ndrbd_csum_ee(mdev, mdev->csums_tfm, e, digest);\r\neq = !memcmp(digest, di->digest, digest_size);\r\nkfree(digest);\r\n}\r\nif (eq) {\r\ndrbd_set_in_sync(mdev, e->sector, e->size);\r\nmdev->rs_same_csum += e->size >> BM_BLOCK_SHIFT;\r\nok = drbd_send_ack(mdev, P_RS_IS_IN_SYNC, e);\r\n} else {\r\ninc_rs_pending(mdev);\r\ne->block_id = ID_SYNCER;\r\ne->flags &= ~EE_HAS_DIGEST;\r\nkfree(di);\r\nok = drbd_send_block(mdev, P_RS_DATA_REPLY, e);\r\n}\r\n} else {\r\nok = drbd_send_ack(mdev, P_NEG_RS_DREPLY, e);\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_err(DEV, "Sending NegDReply. I guess it gets messy.\n");\r\n}\r\ndec_unacked(mdev);\r\nmove_to_net_ee_or_free(mdev, e);\r\nif (unlikely(!ok))\r\ndev_err(DEV, "drbd_send_block/ack() failed\n");\r\nreturn ok;\r\n}\r\nint w_e_end_ov_req(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_epoch_entry *e = container_of(w, struct drbd_epoch_entry, w);\r\nsector_t sector = e->sector;\r\nunsigned int size = e->size;\r\nint digest_size;\r\nvoid *digest;\r\nint ok = 1;\r\nif (unlikely(cancel))\r\ngoto out;\r\ndigest_size = crypto_hash_digestsize(mdev->verify_tfm);\r\ndigest = kmalloc(digest_size, GFP_NOIO);\r\nif (!digest) {\r\nok = 0;\r\ngoto out;\r\n}\r\nif (likely(!(e->flags & EE_WAS_ERROR)))\r\ndrbd_csum_ee(mdev, mdev->verify_tfm, e, digest);\r\nelse\r\nmemset(digest, 0, digest_size);\r\ndrbd_free_ee(mdev, e);\r\ne = NULL;\r\ninc_rs_pending(mdev);\r\nok = drbd_send_drequest_csum(mdev, sector, size,\r\ndigest, digest_size,\r\nP_OV_REPLY);\r\nif (!ok)\r\ndec_rs_pending(mdev);\r\nkfree(digest);\r\nout:\r\nif (e)\r\ndrbd_free_ee(mdev, e);\r\ndec_unacked(mdev);\r\nreturn ok;\r\n}\r\nvoid drbd_ov_oos_found(struct drbd_conf *mdev, sector_t sector, int size)\r\n{\r\nif (mdev->ov_last_oos_start + mdev->ov_last_oos_size == sector) {\r\nmdev->ov_last_oos_size += size>>9;\r\n} else {\r\nmdev->ov_last_oos_start = sector;\r\nmdev->ov_last_oos_size = size>>9;\r\n}\r\ndrbd_set_out_of_sync(mdev, sector, size);\r\n}\r\nint w_e_end_ov_reply(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_epoch_entry *e = container_of(w, struct drbd_epoch_entry, w);\r\nstruct digest_info *di;\r\nvoid *digest;\r\nsector_t sector = e->sector;\r\nunsigned int size = e->size;\r\nint digest_size;\r\nint ok, eq = 0;\r\nif (unlikely(cancel)) {\r\ndrbd_free_ee(mdev, e);\r\ndec_unacked(mdev);\r\nreturn 1;\r\n}\r\nif (get_ldev(mdev)) {\r\ndrbd_rs_complete_io(mdev, e->sector);\r\nput_ldev(mdev);\r\n}\r\ndi = e->digest;\r\nif (likely((e->flags & EE_WAS_ERROR) == 0)) {\r\ndigest_size = crypto_hash_digestsize(mdev->verify_tfm);\r\ndigest = kmalloc(digest_size, GFP_NOIO);\r\nif (digest) {\r\ndrbd_csum_ee(mdev, mdev->verify_tfm, e, digest);\r\nD_ASSERT(digest_size == di->digest_size);\r\neq = !memcmp(digest, di->digest, digest_size);\r\nkfree(digest);\r\n}\r\n}\r\ndrbd_free_ee(mdev, e);\r\nif (!eq)\r\ndrbd_ov_oos_found(mdev, sector, size);\r\nelse\r\nov_oos_print(mdev);\r\nok = drbd_send_ack_ex(mdev, P_OV_RESULT, sector, size,\r\neq ? ID_IN_SYNC : ID_OUT_OF_SYNC);\r\ndec_unacked(mdev);\r\n--mdev->ov_left;\r\nif ((mdev->ov_left & 0x200) == 0x200)\r\ndrbd_advance_rs_marks(mdev, mdev->ov_left);\r\nif (mdev->ov_left == 0) {\r\nov_oos_print(mdev);\r\ndrbd_resync_finished(mdev);\r\n}\r\nreturn ok;\r\n}\r\nint w_prev_work_done(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_wq_barrier *b = container_of(w, struct drbd_wq_barrier, w);\r\ncomplete(&b->done);\r\nreturn 1;\r\n}\r\nint w_send_barrier(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_tl_epoch *b = container_of(w, struct drbd_tl_epoch, w);\r\nstruct p_barrier *p = &mdev->data.sbuf.barrier;\r\nint ok = 1;\r\nspin_lock_irq(&mdev->req_lock);\r\nif (w->cb != w_send_barrier || mdev->state.conn < C_CONNECTED)\r\ncancel = 1;\r\nspin_unlock_irq(&mdev->req_lock);\r\nif (cancel)\r\nreturn 1;\r\nif (!drbd_get_data_sock(mdev))\r\nreturn 0;\r\np->barrier = b->br_number;\r\nok = _drbd_send_cmd(mdev, mdev->data.socket, P_BARRIER,\r\n(struct p_header80 *)p, sizeof(*p), 0);\r\ndrbd_put_data_sock(mdev);\r\nreturn ok;\r\n}\r\nint w_send_write_hint(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nif (cancel)\r\nreturn 1;\r\nreturn drbd_send_short_cmd(mdev, P_UNPLUG_REMOTE);\r\n}\r\nint w_send_oos(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_request *req = container_of(w, struct drbd_request, w);\r\nint ok;\r\nif (unlikely(cancel)) {\r\nreq_mod(req, send_canceled);\r\nreturn 1;\r\n}\r\nok = drbd_send_oos(mdev, req);\r\nreq_mod(req, oos_handed_to_network);\r\nreturn ok;\r\n}\r\nint w_send_dblock(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_request *req = container_of(w, struct drbd_request, w);\r\nint ok;\r\nif (unlikely(cancel)) {\r\nreq_mod(req, send_canceled);\r\nreturn 1;\r\n}\r\nok = drbd_send_dblock(mdev, req);\r\nreq_mod(req, ok ? handed_over_to_network : send_failed);\r\nreturn ok;\r\n}\r\nint w_send_read_req(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_request *req = container_of(w, struct drbd_request, w);\r\nint ok;\r\nif (unlikely(cancel)) {\r\nreq_mod(req, send_canceled);\r\nreturn 1;\r\n}\r\nok = drbd_send_drequest(mdev, P_DATA_REQUEST, req->sector, req->size,\r\n(unsigned long)req);\r\nif (!ok) {\r\nif (mdev->state.conn >= C_CONNECTED)\r\ndrbd_force_state(mdev, NS(conn, C_NETWORK_FAILURE));\r\n}\r\nreq_mod(req, ok ? handed_over_to_network : send_failed);\r\nreturn ok;\r\n}\r\nint w_restart_disk_io(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_request *req = container_of(w, struct drbd_request, w);\r\nif (bio_data_dir(req->master_bio) == WRITE && req->rq_state & RQ_IN_ACT_LOG)\r\ndrbd_al_begin_io(mdev, req->sector);\r\ndrbd_req_make_private_bio(req, req->master_bio);\r\nreq->private_bio->bi_bdev = mdev->ldev->backing_bdev;\r\ngeneric_make_request(req->private_bio);\r\nreturn 1;\r\n}\r\nstatic int _drbd_may_sync_now(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_conf *odev = mdev;\r\nwhile (1) {\r\nif (odev->sync_conf.after == -1)\r\nreturn 1;\r\nodev = minor_to_mdev(odev->sync_conf.after);\r\nERR_IF(!odev) return 1;\r\nif ((odev->state.conn >= C_SYNC_SOURCE &&\r\nodev->state.conn <= C_PAUSED_SYNC_T) ||\r\nodev->state.aftr_isp || odev->state.peer_isp ||\r\nodev->state.user_isp)\r\nreturn 0;\r\n}\r\n}\r\nstatic int _drbd_pause_after(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_conf *odev;\r\nint i, rv = 0;\r\nfor (i = 0; i < minor_count; i++) {\r\nodev = minor_to_mdev(i);\r\nif (!odev)\r\ncontinue;\r\nif (odev->state.conn == C_STANDALONE && odev->state.disk == D_DISKLESS)\r\ncontinue;\r\nif (!_drbd_may_sync_now(odev))\r\nrv |= (__drbd_set_state(_NS(odev, aftr_isp, 1), CS_HARD, NULL)\r\n!= SS_NOTHING_TO_DO);\r\n}\r\nreturn rv;\r\n}\r\nstatic int _drbd_resume_next(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_conf *odev;\r\nint i, rv = 0;\r\nfor (i = 0; i < minor_count; i++) {\r\nodev = minor_to_mdev(i);\r\nif (!odev)\r\ncontinue;\r\nif (odev->state.conn == C_STANDALONE && odev->state.disk == D_DISKLESS)\r\ncontinue;\r\nif (odev->state.aftr_isp) {\r\nif (_drbd_may_sync_now(odev))\r\nrv |= (__drbd_set_state(_NS(odev, aftr_isp, 0),\r\nCS_HARD, NULL)\r\n!= SS_NOTHING_TO_DO) ;\r\n}\r\n}\r\nreturn rv;\r\n}\r\nvoid resume_next_sg(struct drbd_conf *mdev)\r\n{\r\nwrite_lock_irq(&global_state_lock);\r\n_drbd_resume_next(mdev);\r\nwrite_unlock_irq(&global_state_lock);\r\n}\r\nvoid suspend_other_sg(struct drbd_conf *mdev)\r\n{\r\nwrite_lock_irq(&global_state_lock);\r\n_drbd_pause_after(mdev);\r\nwrite_unlock_irq(&global_state_lock);\r\n}\r\nstatic int sync_after_error(struct drbd_conf *mdev, int o_minor)\r\n{\r\nstruct drbd_conf *odev;\r\nif (o_minor == -1)\r\nreturn NO_ERROR;\r\nif (o_minor < -1 || minor_to_mdev(o_minor) == NULL)\r\nreturn ERR_SYNC_AFTER;\r\nodev = minor_to_mdev(o_minor);\r\nwhile (1) {\r\nif (odev == mdev)\r\nreturn ERR_SYNC_AFTER_CYCLE;\r\nif (odev->sync_conf.after == -1)\r\nreturn NO_ERROR;\r\nodev = minor_to_mdev(odev->sync_conf.after);\r\n}\r\n}\r\nint drbd_alter_sa(struct drbd_conf *mdev, int na)\r\n{\r\nint changes;\r\nint retcode;\r\nwrite_lock_irq(&global_state_lock);\r\nretcode = sync_after_error(mdev, na);\r\nif (retcode == NO_ERROR) {\r\nmdev->sync_conf.after = na;\r\ndo {\r\nchanges = _drbd_pause_after(mdev);\r\nchanges |= _drbd_resume_next(mdev);\r\n} while (changes);\r\n}\r\nwrite_unlock_irq(&global_state_lock);\r\nreturn retcode;\r\n}\r\nvoid drbd_rs_controller_reset(struct drbd_conf *mdev)\r\n{\r\natomic_set(&mdev->rs_sect_in, 0);\r\natomic_set(&mdev->rs_sect_ev, 0);\r\nmdev->rs_in_flight = 0;\r\nmdev->rs_planed = 0;\r\nspin_lock(&mdev->peer_seq_lock);\r\nfifo_set(&mdev->rs_plan_s, 0);\r\nspin_unlock(&mdev->peer_seq_lock);\r\n}\r\nvoid drbd_start_resync(struct drbd_conf *mdev, enum drbd_conns side)\r\n{\r\nunion drbd_state ns;\r\nint r;\r\nif (mdev->state.conn >= C_SYNC_SOURCE && mdev->state.conn < C_AHEAD) {\r\ndev_err(DEV, "Resync already running!\n");\r\nreturn;\r\n}\r\nif (side == C_SYNC_TARGET) {\r\nr = drbd_khelper(mdev, "before-resync-target");\r\nr = (r >> 8) & 0xff;\r\nif (r > 0) {\r\ndev_info(DEV, "before-resync-target handler returned %d, "\r\n"dropping connection.\n", r);\r\ndrbd_force_state(mdev, NS(conn, C_DISCONNECTING));\r\nreturn;\r\n}\r\n} else {\r\nr = drbd_khelper(mdev, "before-resync-source");\r\nr = (r >> 8) & 0xff;\r\nif (r > 0) {\r\nif (r == 3) {\r\ndev_info(DEV, "before-resync-source handler returned %d, "\r\n"ignoring. Old userland tools?", r);\r\n} else {\r\ndev_info(DEV, "before-resync-source handler returned %d, "\r\n"dropping connection.\n", r);\r\ndrbd_force_state(mdev, NS(conn, C_DISCONNECTING));\r\nreturn;\r\n}\r\n}\r\n}\r\ndrbd_state_lock(mdev);\r\nwrite_lock_irq(&global_state_lock);\r\nif (!get_ldev_if_state(mdev, D_NEGOTIATING)) {\r\nwrite_unlock_irq(&global_state_lock);\r\ndrbd_state_unlock(mdev);\r\nreturn;\r\n}\r\nns.i = mdev->state.i;\r\nns.aftr_isp = !_drbd_may_sync_now(mdev);\r\nns.conn = side;\r\nif (side == C_SYNC_TARGET)\r\nns.disk = D_INCONSISTENT;\r\nelse\r\nns.pdsk = D_INCONSISTENT;\r\nr = __drbd_set_state(mdev, ns, CS_VERBOSE, NULL);\r\nns = mdev->state;\r\nif (ns.conn < C_CONNECTED)\r\nr = SS_UNKNOWN_ERROR;\r\nif (r == SS_SUCCESS) {\r\nunsigned long tw = drbd_bm_total_weight(mdev);\r\nunsigned long now = jiffies;\r\nint i;\r\nmdev->rs_failed = 0;\r\nmdev->rs_paused = 0;\r\nmdev->rs_same_csum = 0;\r\nmdev->rs_last_events = 0;\r\nmdev->rs_last_sect_ev = 0;\r\nmdev->rs_total = tw;\r\nmdev->rs_start = now;\r\nfor (i = 0; i < DRBD_SYNC_MARKS; i++) {\r\nmdev->rs_mark_left[i] = tw;\r\nmdev->rs_mark_time[i] = now;\r\n}\r\n_drbd_pause_after(mdev);\r\n}\r\nwrite_unlock_irq(&global_state_lock);\r\nif (r == SS_SUCCESS) {\r\ndev_info(DEV, "Began resync as %s (will sync %lu KB [%lu bits set]).\n",\r\ndrbd_conn_str(ns.conn),\r\n(unsigned long) mdev->rs_total << (BM_BLOCK_SHIFT-10),\r\n(unsigned long) mdev->rs_total);\r\nif (side == C_SYNC_TARGET)\r\nmdev->bm_resync_fo = 0;\r\nif (side == C_SYNC_SOURCE && mdev->agreed_pro_version < 96)\r\ndrbd_gen_and_send_sync_uuid(mdev);\r\nif (mdev->agreed_pro_version < 95 && mdev->rs_total == 0) {\r\nif (side == C_SYNC_SOURCE)\r\nschedule_timeout_interruptible(\r\nmdev->net_conf->ping_int * HZ +\r\nmdev->net_conf->ping_timeo*HZ/9);\r\ndrbd_resync_finished(mdev);\r\n}\r\ndrbd_rs_controller_reset(mdev);\r\nif (ns.conn == C_SYNC_TARGET)\r\nmod_timer(&mdev->resync_timer, jiffies);\r\ndrbd_md_sync(mdev);\r\n}\r\nput_ldev(mdev);\r\ndrbd_state_unlock(mdev);\r\n}\r\nint drbd_worker(struct drbd_thread *thi)\r\n{\r\nstruct drbd_conf *mdev = thi->mdev;\r\nstruct drbd_work *w = NULL;\r\nLIST_HEAD(work_list);\r\nint intr = 0, i;\r\nsprintf(current->comm, "drbd%d_worker", mdev_to_minor(mdev));\r\nwhile (get_t_state(thi) == Running) {\r\ndrbd_thread_current_set_cpu(mdev);\r\nif (down_trylock(&mdev->data.work.s)) {\r\nmutex_lock(&mdev->data.mutex);\r\nif (mdev->data.socket && !mdev->net_conf->no_cork)\r\ndrbd_tcp_uncork(mdev->data.socket);\r\nmutex_unlock(&mdev->data.mutex);\r\nintr = down_interruptible(&mdev->data.work.s);\r\nmutex_lock(&mdev->data.mutex);\r\nif (mdev->data.socket && !mdev->net_conf->no_cork)\r\ndrbd_tcp_cork(mdev->data.socket);\r\nmutex_unlock(&mdev->data.mutex);\r\n}\r\nif (intr) {\r\nD_ASSERT(intr == -EINTR);\r\nflush_signals(current);\r\nERR_IF (get_t_state(thi) == Running)\r\ncontinue;\r\nbreak;\r\n}\r\nif (get_t_state(thi) != Running)\r\nbreak;\r\nw = NULL;\r\nspin_lock_irq(&mdev->data.work.q_lock);\r\nERR_IF(list_empty(&mdev->data.work.q)) {\r\nspin_unlock_irq(&mdev->data.work.q_lock);\r\ncontinue;\r\n}\r\nw = list_entry(mdev->data.work.q.next, struct drbd_work, list);\r\nlist_del_init(&w->list);\r\nspin_unlock_irq(&mdev->data.work.q_lock);\r\nif (!w->cb(mdev, w, mdev->state.conn < C_CONNECTED)) {\r\nif (mdev->state.conn >= C_CONNECTED)\r\ndrbd_force_state(mdev,\r\nNS(conn, C_NETWORK_FAILURE));\r\n}\r\n}\r\nD_ASSERT(test_bit(DEVICE_DYING, &mdev->flags));\r\nD_ASSERT(test_bit(CONFIG_PENDING, &mdev->flags));\r\nspin_lock_irq(&mdev->data.work.q_lock);\r\ni = 0;\r\nwhile (!list_empty(&mdev->data.work.q)) {\r\nlist_splice_init(&mdev->data.work.q, &work_list);\r\nspin_unlock_irq(&mdev->data.work.q_lock);\r\nwhile (!list_empty(&work_list)) {\r\nw = list_entry(work_list.next, struct drbd_work, list);\r\nlist_del_init(&w->list);\r\nw->cb(mdev, w, 1);\r\ni++;\r\n}\r\nspin_lock_irq(&mdev->data.work.q_lock);\r\n}\r\nsema_init(&mdev->data.work.s, 0);\r\nspin_unlock_irq(&mdev->data.work.q_lock);\r\nD_ASSERT(mdev->state.disk == D_DISKLESS && mdev->state.conn == C_STANDALONE);\r\ndrbd_thread_stop(&mdev->receiver);\r\ndrbd_mdev_cleanup(mdev);\r\ndev_info(DEV, "worker terminated\n");\r\nclear_bit(DEVICE_DYING, &mdev->flags);\r\nclear_bit(CONFIG_PENDING, &mdev->flags);\r\nwake_up(&mdev->state_wait);\r\nreturn 0;\r\n}
