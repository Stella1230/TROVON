static inline void poll_delay(int d)\r\n{\r\nudelay(3 * AC97_LINK_FRAME + delay_table[d]);\r\n}\r\nstatic void wm9713_phy_init(struct wm97xx *wm)\r\n{\r\nu16 dig1 = 0, dig2, dig3;\r\ndig2 = WM97XX_DELAY(4) | WM97XX_SLT(5);\r\ndig3 = WM9712_RPU(1);\r\nif (rpu) {\r\ndig3 &= 0xffc0;\r\ndig3 |= WM9712_RPU(rpu);\r\ndev_info(wm->dev, "setting pen detect pull-up to %d Ohms\n",\r\n64000 / rpu);\r\n}\r\nif (five_wire) {\r\ndig3 |= WM9713_45W;\r\ndev_info(wm->dev, "setting 5-wire touchscreen mode.");\r\nif (pil) {\r\ndev_warn(wm->dev,\r\n"Pressure measurement not supported in 5 "\r\n"wire mode, disabling\n");\r\npil = 0;\r\n}\r\n}\r\nif (pil == 2) {\r\ndig3 |= WM9712_PIL;\r\ndev_info(wm->dev,\r\n"setting pressure measurement current to 400uA.");\r\n} else if (pil)\r\ndev_info(wm->dev,\r\n"setting pressure measurement current to 200uA.");\r\nif (!pil)\r\npressure = 0;\r\nif (delay < 0 || delay > 15) {\r\ndev_info(wm->dev, "supplied delay out of range.");\r\ndelay = 4;\r\ndev_info(wm->dev, "setting adc sample delay to %d u Secs.",\r\ndelay_table[delay]);\r\n}\r\ndig2 &= 0xff0f;\r\ndig2 |= WM97XX_DELAY(delay);\r\ndig3 |= ((mask & 0x3) << 4);\r\nif (coord)\r\ndig3 |= WM9713_WAIT;\r\nwm->misc = wm97xx_reg_read(wm, 0x5a);\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG1, dig1);\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG2, dig2);\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG3, dig3);\r\nwm97xx_reg_write(wm, AC97_GPIO_STICKY, 0x0);\r\n}\r\nstatic void wm9713_dig_enable(struct wm97xx *wm, int enable)\r\n{\r\nu16 val;\r\nif (enable) {\r\nval = wm97xx_reg_read(wm, AC97_EXTENDED_MID);\r\nwm97xx_reg_write(wm, AC97_EXTENDED_MID, val & 0x7fff);\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG3, wm->dig[2] |\r\nWM97XX_PRP_DET_DIG);\r\nwm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\r\n} else {\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG3, wm->dig[2] &\r\n~WM97XX_PRP_DET_DIG);\r\nval = wm97xx_reg_read(wm, AC97_EXTENDED_MID);\r\nwm97xx_reg_write(wm, AC97_EXTENDED_MID, val | 0x8000);\r\n}\r\n}\r\nstatic void wm9713_dig_restore(struct wm97xx *wm)\r\n{\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG1, wm->dig_save[0]);\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG2, wm->dig_save[1]);\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG3, wm->dig_save[2]);\r\n}\r\nstatic void wm9713_aux_prepare(struct wm97xx *wm)\r\n{\r\nmemcpy(wm->dig_save, wm->dig, sizeof(wm->dig));\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG1, 0);\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG2, 0);\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG3, WM97XX_PRP_DET_DIG);\r\n}\r\nstatic inline int is_pden(struct wm97xx *wm)\r\n{\r\nreturn wm->dig[2] & WM9713_PDEN;\r\n}\r\nstatic int wm9713_poll_sample(struct wm97xx *wm, int adcsel, int *sample)\r\n{\r\nu16 dig1;\r\nint timeout = 5 * delay;\r\nbool wants_pen = adcsel & WM97XX_PEN_DOWN;\r\nif (wants_pen && !wm->pen_probably_down) {\r\nu16 data = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\r\nif (!(data & WM97XX_PEN_DOWN))\r\nreturn RC_PENUP;\r\nwm->pen_probably_down = 1;\r\n}\r\ndig1 = wm97xx_reg_read(wm, AC97_WM9713_DIG1);\r\ndig1 &= ~WM9713_ADCSEL_MASK;\r\ndig1 |= 1 << ((adcsel & WM97XX_ADCSEL_MASK) >> 12);\r\nif (wm->mach_ops && wm->mach_ops->pre_sample)\r\nwm->mach_ops->pre_sample(adcsel);\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG1, dig1 | WM9713_POLL);\r\npoll_delay(delay);\r\nwhile ((wm97xx_reg_read(wm, AC97_WM9713_DIG1) & WM9713_POLL) &&\r\ntimeout) {\r\nudelay(AC97_LINK_FRAME);\r\ntimeout--;\r\n}\r\nif (timeout <= 0) {\r\nif (is_pden(wm))\r\nwm->pen_probably_down = 0;\r\nelse\r\ndev_dbg(wm->dev, "adc sample timeout");\r\nreturn RC_PENUP;\r\n}\r\n*sample = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\r\nif (wm->mach_ops && wm->mach_ops->post_sample)\r\nwm->mach_ops->post_sample(adcsel);\r\nif ((*sample ^ adcsel) & WM97XX_ADCSEL_MASK) {\r\ndev_dbg(wm->dev, "adc wrong sample, wanted %x got %x",\r\nadcsel & WM97XX_ADCSEL_MASK,\r\n*sample & WM97XX_ADCSEL_MASK);\r\nreturn RC_PENUP;\r\n}\r\nif (wants_pen && !(*sample & WM97XX_PEN_DOWN)) {\r\nwm->pen_probably_down = 0;\r\nreturn RC_PENUP;\r\n}\r\nreturn RC_VALID;\r\n}\r\nstatic int wm9713_poll_coord(struct wm97xx *wm, struct wm97xx_data *data)\r\n{\r\nu16 dig1;\r\nint timeout = 5 * delay;\r\nif (!wm->pen_probably_down) {\r\nu16 val = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\r\nif (!(val & WM97XX_PEN_DOWN))\r\nreturn RC_PENUP;\r\nwm->pen_probably_down = 1;\r\n}\r\ndig1 = wm97xx_reg_read(wm, AC97_WM9713_DIG1);\r\ndig1 &= ~WM9713_ADCSEL_MASK;\r\nif (pil)\r\ndig1 |= WM9713_ADCSEL_PRES;\r\nif (wm->mach_ops && wm->mach_ops->pre_sample)\r\nwm->mach_ops->pre_sample(WM97XX_ADCSEL_X | WM97XX_ADCSEL_Y);\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG1,\r\ndig1 | WM9713_POLL | WM9713_COO);\r\npoll_delay(delay);\r\ndata->x = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\r\nwhile ((wm97xx_reg_read(wm, AC97_WM9713_DIG1) & WM9713_POLL)\r\n&& timeout) {\r\nudelay(AC97_LINK_FRAME);\r\ntimeout--;\r\n}\r\nif (timeout <= 0) {\r\nif (is_pden(wm))\r\nwm->pen_probably_down = 0;\r\nelse\r\ndev_dbg(wm->dev, "adc sample timeout");\r\nreturn RC_PENUP;\r\n}\r\ndata->y = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\r\nif (pil)\r\ndata->p = wm97xx_reg_read(wm, AC97_WM97XX_DIGITISER_RD);\r\nelse\r\ndata->p = DEFAULT_PRESSURE;\r\nif (wm->mach_ops && wm->mach_ops->post_sample)\r\nwm->mach_ops->post_sample(WM97XX_ADCSEL_X | WM97XX_ADCSEL_Y);\r\nif (!(data->x & WM97XX_ADCSEL_X) || !(data->y & WM97XX_ADCSEL_Y))\r\ngoto err;\r\nif (pil && !(data->p & WM97XX_ADCSEL_PRES))\r\ngoto err;\r\nif (!(data->x & WM97XX_PEN_DOWN) || !(data->y & WM97XX_PEN_DOWN)) {\r\nwm->pen_probably_down = 0;\r\nreturn RC_PENUP;\r\n}\r\nreturn RC_VALID;\r\nerr:\r\nreturn 0;\r\n}\r\nstatic int wm9713_poll_touch(struct wm97xx *wm, struct wm97xx_data *data)\r\n{\r\nint rc;\r\nif (coord) {\r\nrc = wm9713_poll_coord(wm, data);\r\nif (rc != RC_VALID)\r\nreturn rc;\r\n} else {\r\nrc = wm9713_poll_sample(wm, WM97XX_ADCSEL_X | WM97XX_PEN_DOWN, &data->x);\r\nif (rc != RC_VALID)\r\nreturn rc;\r\nrc = wm9713_poll_sample(wm, WM97XX_ADCSEL_Y | WM97XX_PEN_DOWN, &data->y);\r\nif (rc != RC_VALID)\r\nreturn rc;\r\nif (pil) {\r\nrc = wm9713_poll_sample(wm, WM97XX_ADCSEL_PRES | WM97XX_PEN_DOWN,\r\n&data->p);\r\nif (rc != RC_VALID)\r\nreturn rc;\r\n} else\r\ndata->p = DEFAULT_PRESSURE;\r\n}\r\nreturn RC_VALID;\r\n}\r\nstatic int wm9713_acc_enable(struct wm97xx *wm, int enable)\r\n{\r\nu16 dig1, dig2, dig3;\r\nint ret = 0;\r\ndig1 = wm->dig[0];\r\ndig2 = wm->dig[1];\r\ndig3 = wm->dig[2];\r\nif (enable) {\r\nif (wm->mach_ops->acc_startup &&\r\n(ret = wm->mach_ops->acc_startup(wm)) < 0)\r\nreturn ret;\r\ndig1 &= ~WM9713_ADCSEL_MASK;\r\ndig1 |= WM9713_CTC | WM9713_COO | WM9713_ADCSEL_X |\r\nWM9713_ADCSEL_Y;\r\nif (pil)\r\ndig1 |= WM9713_ADCSEL_PRES;\r\ndig2 &= ~(WM97XX_DELAY_MASK | WM97XX_SLT_MASK |\r\nWM97XX_CM_RATE_MASK);\r\ndig2 |= WM97XX_SLEN | WM97XX_DELAY(delay) |\r\nWM97XX_SLT(wm->acc_slot) | WM97XX_RATE(wm->acc_rate);\r\ndig3 |= WM9713_PDEN;\r\n} else {\r\ndig1 &= ~(WM9713_CTC | WM9713_COO);\r\ndig2 &= ~WM97XX_SLEN;\r\ndig3 &= ~WM9713_PDEN;\r\nif (wm->mach_ops->acc_shutdown)\r\nwm->mach_ops->acc_shutdown(wm);\r\n}\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG1, dig1);\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG2, dig2);\r\nwm97xx_reg_write(wm, AC97_WM9713_DIG3, dig3);\r\nreturn ret;\r\n}
