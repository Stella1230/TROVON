int rmm_alloc(struct rmm_target_obj *target, u32 segid, u32 size,\r\nu32 align, u32 *dsp_address, bool reserve)\r\n{\r\nstruct rmm_ovly_sect *sect, *prev_sect = NULL;\r\nstruct rmm_ovly_sect *new_sect;\r\nu32 addr;\r\nint status = 0;\r\nif (!reserve) {\r\nif (!alloc_block(target, segid, size, align, dsp_address)) {\r\nstatus = -ENOMEM;\r\n} else {\r\ntarget->seg_tab[segid].number++;\r\n}\r\ngoto func_end;\r\n}\r\naddr = *dsp_address;\r\nlist_for_each_entry(sect, &target->ovly_list, list_elem) {\r\nif (addr <= sect->addr) {\r\nif ((addr + size > sect->addr) || (prev_sect &&\r\n(prev_sect->addr +\r\nprev_sect->size >\r\naddr))) {\r\nstatus = -ENXIO;\r\n}\r\nbreak;\r\n}\r\nprev_sect = sect;\r\n}\r\nif (!status) {\r\nnew_sect = kzalloc(sizeof(struct rmm_ovly_sect), GFP_KERNEL);\r\nif (new_sect == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nnew_sect->addr = addr;\r\nnew_sect->size = size;\r\nnew_sect->page = segid;\r\nif (list_is_last(&sect->list_elem, &target->ovly_list))\r\nlist_add_tail(&new_sect->list_elem,\r\n&target->ovly_list);\r\nelse\r\nlist_add_tail(&new_sect->list_elem,\r\n&sect->list_elem);\r\n}\r\n}\r\nfunc_end:\r\nreturn status;\r\n}\r\nint rmm_create(struct rmm_target_obj **target_obj,\r\nstruct rmm_segment seg_tab[], u32 num_segs)\r\n{\r\nstruct rmm_header *hptr;\r\nstruct rmm_segment *sptr, *tmp;\r\nstruct rmm_target_obj *target;\r\ns32 i;\r\nint status = 0;\r\ntarget = kzalloc(sizeof(struct rmm_target_obj), GFP_KERNEL);\r\nif (target == NULL)\r\nstatus = -ENOMEM;\r\nif (status)\r\ngoto func_cont;\r\ntarget->num_segs = num_segs;\r\nif (!(num_segs > 0))\r\ngoto func_cont;\r\ntarget->free_list = kzalloc(num_segs * sizeof(struct rmm_header *),\r\nGFP_KERNEL);\r\nif (target->free_list == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nfor (i = 0; i < (s32) num_segs; i++) {\r\ntarget->free_list[i] =\r\nkzalloc(sizeof(struct rmm_header), GFP_KERNEL);\r\nif (target->free_list[i] == NULL) {\r\nstatus = -ENOMEM;\r\nbreak;\r\n}\r\n}\r\ntarget->seg_tab = kzalloc(num_segs * sizeof(struct rmm_segment),\r\nGFP_KERNEL);\r\nif (target->seg_tab == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nsptr = target->seg_tab;\r\nfor (i = 0, tmp = seg_tab; num_segs > 0;\r\nnum_segs--, i++) {\r\n*sptr = *tmp;\r\nhptr = target->free_list[i];\r\nhptr->addr = tmp->base;\r\nhptr->size = tmp->length;\r\nhptr->next = NULL;\r\ntmp++;\r\nsptr++;\r\n}\r\n}\r\n}\r\nfunc_cont:\r\nif (!status)\r\nINIT_LIST_HEAD(&target->ovly_list);\r\nif (!status) {\r\n*target_obj = target;\r\n} else {\r\n*target_obj = NULL;\r\nif (target)\r\nrmm_delete(target);\r\n}\r\nreturn status;\r\n}\r\nvoid rmm_delete(struct rmm_target_obj *target)\r\n{\r\nstruct rmm_ovly_sect *sect, *tmp;\r\nstruct rmm_header *hptr;\r\nstruct rmm_header *next;\r\nu32 i;\r\nkfree(target->seg_tab);\r\nlist_for_each_entry_safe(sect, tmp, &target->ovly_list, list_elem) {\r\nlist_del(&sect->list_elem);\r\nkfree(sect);\r\n}\r\nif (target->free_list != NULL) {\r\nfor (i = 0; i < target->num_segs; i++) {\r\nhptr = next = target->free_list[i];\r\nwhile (next) {\r\nhptr = next;\r\nnext = hptr->next;\r\nkfree(hptr);\r\n}\r\n}\r\nkfree(target->free_list);\r\n}\r\nkfree(target);\r\n}\r\nbool rmm_free(struct rmm_target_obj *target, u32 segid, u32 dsp_addr, u32 size,\r\nbool reserved)\r\n{\r\nstruct rmm_ovly_sect *sect, *tmp;\r\nbool ret = false;\r\nif (!reserved) {\r\nret = free_block(target, segid, dsp_addr, size);\r\nif (ret)\r\ntarget->seg_tab[segid].number--;\r\n} else {\r\nlist_for_each_entry_safe(sect, tmp, &target->ovly_list,\r\nlist_elem) {\r\nif (dsp_addr == sect->addr) {\r\nlist_del(&sect->list_elem);\r\nkfree(sect);\r\nreturn true;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nbool rmm_stat(struct rmm_target_obj *target, enum dsp_memtype segid,\r\nstruct dsp_memstat *mem_stat_buf)\r\n{\r\nstruct rmm_header *head;\r\nbool ret = false;\r\nu32 max_free_size = 0;\r\nu32 total_free_size = 0;\r\nu32 free_blocks = 0;\r\nif ((u32) segid < target->num_segs) {\r\nhead = target->free_list[segid];\r\nwhile (head != NULL) {\r\nmax_free_size = max(max_free_size, head->size);\r\ntotal_free_size += head->size;\r\nfree_blocks++;\r\nhead = head->next;\r\n}\r\nmem_stat_buf->size = target->seg_tab[segid].length;\r\nmem_stat_buf->num_free_blocks = free_blocks;\r\nmem_stat_buf->total_free_size = total_free_size;\r\nmem_stat_buf->len_max_free_block = max_free_size;\r\nmem_stat_buf->num_alloc_blocks =\r\ntarget->seg_tab[segid].number;\r\nret = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool alloc_block(struct rmm_target_obj *target, u32 segid, u32 size,\r\nu32 align, u32 *dsp_address)\r\n{\r\nstruct rmm_header *head;\r\nstruct rmm_header *prevhead = NULL;\r\nstruct rmm_header *next;\r\nu32 tmpalign;\r\nu32 alignbytes;\r\nu32 hsize;\r\nu32 allocsize;\r\nu32 addr;\r\nalignbytes = (align == 0) ? 1 : align;\r\nprevhead = NULL;\r\nhead = target->free_list[segid];\r\ndo {\r\nhsize = head->size;\r\nnext = head->next;\r\naddr = head->addr;\r\n(tmpalign = (u32) addr % alignbytes);\r\nif (tmpalign != 0)\r\ntmpalign = alignbytes - tmpalign;\r\nallocsize = size + tmpalign;\r\nif (hsize >= allocsize) {\r\nif (hsize == allocsize && prevhead != NULL) {\r\nprevhead->next = next;\r\nkfree(head);\r\n} else {\r\nhead->size = hsize - allocsize;\r\nhead->addr += allocsize;\r\n}\r\nif (tmpalign)\r\nfree_block(target, segid, addr, tmpalign);\r\n*dsp_address = addr + tmpalign;\r\nreturn true;\r\n}\r\nprevhead = head;\r\nhead = next;\r\n} while (head != NULL);\r\nreturn false;\r\n}\r\nstatic bool free_block(struct rmm_target_obj *target, u32 segid, u32 addr,\r\nu32 size)\r\n{\r\nstruct rmm_header *head;\r\nstruct rmm_header *thead;\r\nstruct rmm_header *rhead;\r\nbool ret = true;\r\nrhead = kzalloc(sizeof(struct rmm_header), GFP_KERNEL);\r\nif (rhead == NULL) {\r\nret = false;\r\n} else {\r\nhead = target->free_list[segid];\r\nif (addr >= head->addr) {\r\nwhile (head->next != NULL && addr > head->next->addr)\r\nhead = head->next;\r\nthead = head->next;\r\nhead->next = rhead;\r\nrhead->next = thead;\r\nrhead->addr = addr;\r\nrhead->size = size;\r\n} else {\r\n*rhead = *head;\r\nhead->next = rhead;\r\nhead->addr = addr;\r\nhead->size = size;\r\nthead = rhead->next;\r\n}\r\nif (thead != NULL && (rhead->addr + rhead->size) ==\r\nthead->addr) {\r\nhead->next = rhead->next;\r\nthead->size = size + thead->size;\r\nthead->addr = addr;\r\nkfree(rhead);\r\nrhead = thead;\r\n}\r\nif ((head->addr + head->size) == rhead->addr) {\r\nhead->next = rhead->next;\r\nhead->size = head->size + rhead->size;\r\nkfree(rhead);\r\n}\r\n}\r\nreturn ret;\r\n}
