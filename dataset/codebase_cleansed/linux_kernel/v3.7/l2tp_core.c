static inline struct l2tp_net *l2tp_pernet(struct net *net)\r\n{\r\nBUG_ON(!net);\r\nreturn net_generic(net, l2tp_net_id);\r\n}\r\nstatic inline void l2tp_tunnel_inc_refcount_1(struct l2tp_tunnel *tunnel)\r\n{\r\natomic_inc(&tunnel->ref_count);\r\n}\r\nstatic inline void l2tp_tunnel_dec_refcount_1(struct l2tp_tunnel *tunnel)\r\n{\r\nif (atomic_dec_and_test(&tunnel->ref_count))\r\nl2tp_tunnel_free(tunnel);\r\n}\r\nstatic struct l2tp_session *l2tp_session_find_2(struct net *net, u32 session_id)\r\n{\r\nstruct l2tp_net *pn = l2tp_pernet(net);\r\nstruct hlist_head *session_list =\r\nl2tp_session_id_hash_2(pn, session_id);\r\nstruct l2tp_session *session;\r\nstruct hlist_node *walk;\r\nrcu_read_lock_bh();\r\nhlist_for_each_entry_rcu(session, walk, session_list, global_hlist) {\r\nif (session->session_id == session_id) {\r\nrcu_read_unlock_bh();\r\nreturn session;\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nreturn NULL;\r\n}\r\nstatic inline struct hlist_head *\r\nl2tp_session_id_hash(struct l2tp_tunnel *tunnel, u32 session_id)\r\n{\r\nreturn &tunnel->session_hlist[hash_32(session_id, L2TP_HASH_BITS)];\r\n}\r\nstruct l2tp_session *l2tp_session_find(struct net *net, struct l2tp_tunnel *tunnel, u32 session_id)\r\n{\r\nstruct hlist_head *session_list;\r\nstruct l2tp_session *session;\r\nstruct hlist_node *walk;\r\nif (tunnel == NULL)\r\nreturn l2tp_session_find_2(net, session_id);\r\nsession_list = l2tp_session_id_hash(tunnel, session_id);\r\nread_lock_bh(&tunnel->hlist_lock);\r\nhlist_for_each_entry(session, walk, session_list, hlist) {\r\nif (session->session_id == session_id) {\r\nread_unlock_bh(&tunnel->hlist_lock);\r\nreturn session;\r\n}\r\n}\r\nread_unlock_bh(&tunnel->hlist_lock);\r\nreturn NULL;\r\n}\r\nstruct l2tp_session *l2tp_session_find_nth(struct l2tp_tunnel *tunnel, int nth)\r\n{\r\nint hash;\r\nstruct hlist_node *walk;\r\nstruct l2tp_session *session;\r\nint count = 0;\r\nread_lock_bh(&tunnel->hlist_lock);\r\nfor (hash = 0; hash < L2TP_HASH_SIZE; hash++) {\r\nhlist_for_each_entry(session, walk, &tunnel->session_hlist[hash], hlist) {\r\nif (++count > nth) {\r\nread_unlock_bh(&tunnel->hlist_lock);\r\nreturn session;\r\n}\r\n}\r\n}\r\nread_unlock_bh(&tunnel->hlist_lock);\r\nreturn NULL;\r\n}\r\nstruct l2tp_session *l2tp_session_find_by_ifname(struct net *net, char *ifname)\r\n{\r\nstruct l2tp_net *pn = l2tp_pernet(net);\r\nint hash;\r\nstruct hlist_node *walk;\r\nstruct l2tp_session *session;\r\nrcu_read_lock_bh();\r\nfor (hash = 0; hash < L2TP_HASH_SIZE_2; hash++) {\r\nhlist_for_each_entry_rcu(session, walk, &pn->l2tp_session_hlist[hash], global_hlist) {\r\nif (!strcmp(session->ifname, ifname)) {\r\nrcu_read_unlock_bh();\r\nreturn session;\r\n}\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nreturn NULL;\r\n}\r\nstruct l2tp_tunnel *l2tp_tunnel_find(struct net *net, u32 tunnel_id)\r\n{\r\nstruct l2tp_tunnel *tunnel;\r\nstruct l2tp_net *pn = l2tp_pernet(net);\r\nrcu_read_lock_bh();\r\nlist_for_each_entry_rcu(tunnel, &pn->l2tp_tunnel_list, list) {\r\nif (tunnel->tunnel_id == tunnel_id) {\r\nrcu_read_unlock_bh();\r\nreturn tunnel;\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nreturn NULL;\r\n}\r\nstruct l2tp_tunnel *l2tp_tunnel_find_nth(struct net *net, int nth)\r\n{\r\nstruct l2tp_net *pn = l2tp_pernet(net);\r\nstruct l2tp_tunnel *tunnel;\r\nint count = 0;\r\nrcu_read_lock_bh();\r\nlist_for_each_entry_rcu(tunnel, &pn->l2tp_tunnel_list, list) {\r\nif (++count > nth) {\r\nrcu_read_unlock_bh();\r\nreturn tunnel;\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nreturn NULL;\r\n}\r\nstatic void l2tp_recv_queue_skb(struct l2tp_session *session, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *skbp;\r\nstruct sk_buff *tmp;\r\nu32 ns = L2TP_SKB_CB(skb)->ns;\r\nstruct l2tp_stats *sstats;\r\nspin_lock_bh(&session->reorder_q.lock);\r\nsstats = &session->stats;\r\nskb_queue_walk_safe(&session->reorder_q, skbp, tmp) {\r\nif (L2TP_SKB_CB(skbp)->ns > ns) {\r\n__skb_queue_before(&session->reorder_q, skbp, skb);\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: pkt %hu, inserted before %hu, reorder_q len=%d\n",\r\nsession->name, ns, L2TP_SKB_CB(skbp)->ns,\r\nskb_queue_len(&session->reorder_q));\r\nu64_stats_update_begin(&sstats->syncp);\r\nsstats->rx_oos_packets++;\r\nu64_stats_update_end(&sstats->syncp);\r\ngoto out;\r\n}\r\n}\r\n__skb_queue_tail(&session->reorder_q, skb);\r\nout:\r\nspin_unlock_bh(&session->reorder_q.lock);\r\n}\r\nstatic void l2tp_recv_dequeue_skb(struct l2tp_session *session, struct sk_buff *skb)\r\n{\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nint length = L2TP_SKB_CB(skb)->length;\r\nstruct l2tp_stats *tstats, *sstats;\r\nskb_orphan(skb);\r\ntstats = &tunnel->stats;\r\nu64_stats_update_begin(&tstats->syncp);\r\nsstats = &session->stats;\r\nu64_stats_update_begin(&sstats->syncp);\r\ntstats->rx_packets++;\r\ntstats->rx_bytes += length;\r\nsstats->rx_packets++;\r\nsstats->rx_bytes += length;\r\nu64_stats_update_end(&tstats->syncp);\r\nu64_stats_update_end(&sstats->syncp);\r\nif (L2TP_SKB_CB(skb)->has_seq) {\r\nsession->nr++;\r\nif (tunnel->version == L2TP_HDR_VER_2)\r\nsession->nr &= 0xffff;\r\nelse\r\nsession->nr &= 0xffffff;\r\nl2tp_dbg(session, L2TP_MSG_SEQ, "%s: updated nr to %hu\n",\r\nsession->name, session->nr);\r\n}\r\nif (session->recv_skb != NULL)\r\n(*session->recv_skb)(session, skb, L2TP_SKB_CB(skb)->length);\r\nelse\r\nkfree_skb(skb);\r\nif (session->deref)\r\n(*session->deref)(session);\r\n}\r\nstatic void l2tp_recv_dequeue(struct l2tp_session *session)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sk_buff *tmp;\r\nstruct l2tp_stats *sstats;\r\nstart:\r\nspin_lock_bh(&session->reorder_q.lock);\r\nsstats = &session->stats;\r\nskb_queue_walk_safe(&session->reorder_q, skb, tmp) {\r\nif (time_after(jiffies, L2TP_SKB_CB(skb)->expires)) {\r\nu64_stats_update_begin(&sstats->syncp);\r\nsstats->rx_seq_discards++;\r\nsstats->rx_errors++;\r\nu64_stats_update_end(&sstats->syncp);\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: oos pkt %u len %d discarded (too old), waiting for %u, reorder_q_len=%d\n",\r\nsession->name, L2TP_SKB_CB(skb)->ns,\r\nL2TP_SKB_CB(skb)->length, session->nr,\r\nskb_queue_len(&session->reorder_q));\r\nsession->reorder_skip = 1;\r\n__skb_unlink(skb, &session->reorder_q);\r\nkfree_skb(skb);\r\nif (session->deref)\r\n(*session->deref)(session);\r\ncontinue;\r\n}\r\nif (L2TP_SKB_CB(skb)->has_seq) {\r\nif (session->reorder_skip) {\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: advancing nr to next pkt: %u -> %u",\r\nsession->name, session->nr,\r\nL2TP_SKB_CB(skb)->ns);\r\nsession->reorder_skip = 0;\r\nsession->nr = L2TP_SKB_CB(skb)->ns;\r\n}\r\nif (L2TP_SKB_CB(skb)->ns != session->nr) {\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: holding oos pkt %u len %d, waiting for %u, reorder_q_len=%d\n",\r\nsession->name, L2TP_SKB_CB(skb)->ns,\r\nL2TP_SKB_CB(skb)->length, session->nr,\r\nskb_queue_len(&session->reorder_q));\r\ngoto out;\r\n}\r\n}\r\n__skb_unlink(skb, &session->reorder_q);\r\nspin_unlock_bh(&session->reorder_q.lock);\r\nl2tp_recv_dequeue_skb(session, skb);\r\ngoto start;\r\n}\r\nout:\r\nspin_unlock_bh(&session->reorder_q.lock);\r\n}\r\nstatic inline int l2tp_verify_udp_checksum(struct sock *sk,\r\nstruct sk_buff *skb)\r\n{\r\nstruct udphdr *uh = udp_hdr(skb);\r\nu16 ulen = ntohs(uh->len);\r\n__wsum psum;\r\nif (sk->sk_no_check || skb_csum_unnecessary(skb))\r\nreturn 0;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (sk->sk_family == PF_INET6) {\r\nif (!uh->check) {\r\nLIMIT_NETDEBUG(KERN_INFO "L2TP: IPv6: checksum is 0\n");\r\nreturn 1;\r\n}\r\nif ((skb->ip_summed == CHECKSUM_COMPLETE) &&\r\n!csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\r\n&ipv6_hdr(skb)->daddr, ulen,\r\nIPPROTO_UDP, skb->csum)) {\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nreturn 0;\r\n}\r\nskb->csum = ~csum_unfold(csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\r\n&ipv6_hdr(skb)->daddr,\r\nskb->len, IPPROTO_UDP,\r\n0));\r\n} else\r\n#endif\r\n{\r\nstruct inet_sock *inet;\r\nif (!uh->check)\r\nreturn 0;\r\ninet = inet_sk(sk);\r\npsum = csum_tcpudp_nofold(inet->inet_saddr, inet->inet_daddr,\r\nulen, IPPROTO_UDP, 0);\r\nif ((skb->ip_summed == CHECKSUM_COMPLETE) &&\r\n!csum_fold(csum_add(psum, skb->csum)))\r\nreturn 0;\r\nskb->csum = psum;\r\n}\r\nreturn __skb_checksum_complete(skb);\r\n}\r\nvoid l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb,\r\nunsigned char *ptr, unsigned char *optr, u16 hdrflags,\r\nint length, int (*payload_hook)(struct sk_buff *skb))\r\n{\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nint offset;\r\nu32 ns, nr;\r\nstruct l2tp_stats *sstats = &session->stats;\r\nl2tp_session_inc_refcount(session);\r\nif (session->ref)\r\n(*session->ref)(session);\r\nif (session->peer_cookie_len > 0) {\r\nif (memcmp(ptr, &session->peer_cookie[0], session->peer_cookie_len)) {\r\nl2tp_info(tunnel, L2TP_MSG_DATA,\r\n"%s: cookie mismatch (%u/%u). Discarding.\n",\r\ntunnel->name, tunnel->tunnel_id,\r\nsession->session_id);\r\nu64_stats_update_begin(&sstats->syncp);\r\nsstats->rx_cookie_discards++;\r\nu64_stats_update_end(&sstats->syncp);\r\ngoto discard;\r\n}\r\nptr += session->peer_cookie_len;\r\n}\r\nns = nr = 0;\r\nL2TP_SKB_CB(skb)->has_seq = 0;\r\nif (tunnel->version == L2TP_HDR_VER_2) {\r\nif (hdrflags & L2TP_HDRFLAG_S) {\r\nns = ntohs(*(__be16 *) ptr);\r\nptr += 2;\r\nnr = ntohs(*(__be16 *) ptr);\r\nptr += 2;\r\nL2TP_SKB_CB(skb)->ns = ns;\r\nL2TP_SKB_CB(skb)->has_seq = 1;\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: recv data ns=%u, nr=%u, session nr=%u\n",\r\nsession->name, ns, nr, session->nr);\r\n}\r\n} else if (session->l2specific_type == L2TP_L2SPECTYPE_DEFAULT) {\r\nu32 l2h = ntohl(*(__be32 *) ptr);\r\nif (l2h & 0x40000000) {\r\nns = l2h & 0x00ffffff;\r\nL2TP_SKB_CB(skb)->ns = ns;\r\nL2TP_SKB_CB(skb)->has_seq = 1;\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: recv data ns=%u, session nr=%u\n",\r\nsession->name, ns, session->nr);\r\n}\r\n}\r\nptr += session->l2specific_len;\r\nif (L2TP_SKB_CB(skb)->has_seq) {\r\nif ((!session->lns_mode) && (!session->send_seq)) {\r\nl2tp_info(session, L2TP_MSG_SEQ,\r\n"%s: requested to enable seq numbers by LNS\n",\r\nsession->name);\r\nsession->send_seq = -1;\r\nl2tp_session_set_header_len(session, tunnel->version);\r\n}\r\n} else {\r\nif (session->recv_seq) {\r\nl2tp_warn(session, L2TP_MSG_SEQ,\r\n"%s: recv data has no seq numbers when required. Discarding.\n",\r\nsession->name);\r\nu64_stats_update_begin(&sstats->syncp);\r\nsstats->rx_seq_discards++;\r\nu64_stats_update_end(&sstats->syncp);\r\ngoto discard;\r\n}\r\nif ((!session->lns_mode) && (session->send_seq)) {\r\nl2tp_info(session, L2TP_MSG_SEQ,\r\n"%s: requested to disable seq numbers by LNS\n",\r\nsession->name);\r\nsession->send_seq = 0;\r\nl2tp_session_set_header_len(session, tunnel->version);\r\n} else if (session->send_seq) {\r\nl2tp_warn(session, L2TP_MSG_SEQ,\r\n"%s: recv data has no seq numbers when required. Discarding.\n",\r\nsession->name);\r\nu64_stats_update_begin(&sstats->syncp);\r\nsstats->rx_seq_discards++;\r\nu64_stats_update_end(&sstats->syncp);\r\ngoto discard;\r\n}\r\n}\r\nif (tunnel->version == L2TP_HDR_VER_2) {\r\nif (hdrflags & L2TP_HDRFLAG_O) {\r\noffset = ntohs(*(__be16 *)ptr);\r\nptr += 2 + offset;\r\n}\r\n} else\r\nptr += session->offset;\r\noffset = ptr - optr;\r\nif (!pskb_may_pull(skb, offset))\r\ngoto discard;\r\n__skb_pull(skb, offset);\r\nif (payload_hook)\r\nif ((*payload_hook)(skb))\r\ngoto discard;\r\nL2TP_SKB_CB(skb)->length = length;\r\nL2TP_SKB_CB(skb)->expires = jiffies +\r\n(session->reorder_timeout ? session->reorder_timeout : HZ);\r\nif (L2TP_SKB_CB(skb)->has_seq) {\r\nif (session->reorder_timeout != 0) {\r\nl2tp_recv_queue_skb(session, skb);\r\n} else {\r\nif (L2TP_SKB_CB(skb)->ns != session->nr) {\r\nu64_stats_update_begin(&sstats->syncp);\r\nsstats->rx_seq_discards++;\r\nu64_stats_update_end(&sstats->syncp);\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: oos pkt %u len %d discarded, waiting for %u, reorder_q_len=%d\n",\r\nsession->name, L2TP_SKB_CB(skb)->ns,\r\nL2TP_SKB_CB(skb)->length, session->nr,\r\nskb_queue_len(&session->reorder_q));\r\ngoto discard;\r\n}\r\nskb_queue_tail(&session->reorder_q, skb);\r\n}\r\n} else {\r\nskb_queue_tail(&session->reorder_q, skb);\r\n}\r\nl2tp_recv_dequeue(session);\r\nl2tp_session_dec_refcount(session);\r\nreturn;\r\ndiscard:\r\nu64_stats_update_begin(&sstats->syncp);\r\nsstats->rx_errors++;\r\nu64_stats_update_end(&sstats->syncp);\r\nkfree_skb(skb);\r\nif (session->deref)\r\n(*session->deref)(session);\r\nl2tp_session_dec_refcount(session);\r\n}\r\nstatic int l2tp_udp_recv_core(struct l2tp_tunnel *tunnel, struct sk_buff *skb,\r\nint (*payload_hook)(struct sk_buff *skb))\r\n{\r\nstruct l2tp_session *session = NULL;\r\nunsigned char *ptr, *optr;\r\nu16 hdrflags;\r\nu32 tunnel_id, session_id;\r\nu16 version;\r\nint length;\r\nstruct l2tp_stats *tstats;\r\nif (tunnel->sock && l2tp_verify_udp_checksum(tunnel->sock, skb))\r\ngoto discard_bad_csum;\r\n__skb_pull(skb, sizeof(struct udphdr));\r\nif (!pskb_may_pull(skb, L2TP_HDR_SIZE_SEQ)) {\r\nl2tp_info(tunnel, L2TP_MSG_DATA,\r\n"%s: recv short packet (len=%d)\n",\r\ntunnel->name, skb->len);\r\ngoto error;\r\n}\r\nif (tunnel->debug & L2TP_MSG_DATA) {\r\nlength = min(32u, skb->len);\r\nif (!pskb_may_pull(skb, length))\r\ngoto error;\r\npr_debug("%s: recv\n", tunnel->name);\r\nprint_hex_dump_bytes("", DUMP_PREFIX_OFFSET, skb->data, length);\r\n}\r\noptr = ptr = skb->data;\r\nhdrflags = ntohs(*(__be16 *) ptr);\r\nversion = hdrflags & L2TP_HDR_VER_MASK;\r\nif (version != tunnel->version) {\r\nl2tp_info(tunnel, L2TP_MSG_DATA,\r\n"%s: recv protocol version mismatch: got %d expected %d\n",\r\ntunnel->name, version, tunnel->version);\r\ngoto error;\r\n}\r\nlength = skb->len;\r\nif (hdrflags & L2TP_HDRFLAG_T) {\r\nl2tp_dbg(tunnel, L2TP_MSG_DATA,\r\n"%s: recv control packet, len=%d\n",\r\ntunnel->name, length);\r\ngoto error;\r\n}\r\nptr += 2;\r\nif (tunnel->version == L2TP_HDR_VER_2) {\r\nif (hdrflags & L2TP_HDRFLAG_L)\r\nptr += 2;\r\ntunnel_id = ntohs(*(__be16 *) ptr);\r\nptr += 2;\r\nsession_id = ntohs(*(__be16 *) ptr);\r\nptr += 2;\r\n} else {\r\nptr += 2;\r\ntunnel_id = tunnel->tunnel_id;\r\nsession_id = ntohl(*(__be32 *) ptr);\r\nptr += 4;\r\n}\r\nsession = l2tp_session_find(tunnel->l2tp_net, tunnel, session_id);\r\nif (!session || !session->recv_skb) {\r\nl2tp_info(tunnel, L2TP_MSG_DATA,\r\n"%s: no session found (%u/%u). Passing up.\n",\r\ntunnel->name, tunnel_id, session_id);\r\ngoto error;\r\n}\r\nl2tp_recv_common(session, skb, ptr, optr, hdrflags, length, payload_hook);\r\nreturn 0;\r\ndiscard_bad_csum:\r\nLIMIT_NETDEBUG("%s: UDP: bad checksum\n", tunnel->name);\r\nUDP_INC_STATS_USER(tunnel->l2tp_net, UDP_MIB_INERRORS, 0);\r\ntstats = &tunnel->stats;\r\nu64_stats_update_begin(&tstats->syncp);\r\ntstats->rx_errors++;\r\nu64_stats_update_end(&tstats->syncp);\r\nkfree_skb(skb);\r\nreturn 0;\r\nerror:\r\n__skb_push(skb, sizeof(struct udphdr));\r\nreturn 1;\r\n}\r\nint l2tp_udp_encap_recv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct l2tp_tunnel *tunnel;\r\ntunnel = l2tp_sock_to_tunnel(sk);\r\nif (tunnel == NULL)\r\ngoto pass_up;\r\nl2tp_dbg(tunnel, L2TP_MSG_DATA, "%s: received %d bytes\n",\r\ntunnel->name, skb->len);\r\nif (l2tp_udp_recv_core(tunnel, skb, tunnel->recv_payload_hook))\r\ngoto pass_up_put;\r\nsock_put(sk);\r\nreturn 0;\r\npass_up_put:\r\nsock_put(sk);\r\npass_up:\r\nreturn 1;\r\n}\r\nstatic int l2tp_build_l2tpv2_header(struct l2tp_session *session, void *buf)\r\n{\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\n__be16 *bufp = buf;\r\n__be16 *optr = buf;\r\nu16 flags = L2TP_HDR_VER_2;\r\nu32 tunnel_id = tunnel->peer_tunnel_id;\r\nu32 session_id = session->peer_session_id;\r\nif (session->send_seq)\r\nflags |= L2TP_HDRFLAG_S;\r\n*bufp++ = htons(flags);\r\n*bufp++ = htons(tunnel_id);\r\n*bufp++ = htons(session_id);\r\nif (session->send_seq) {\r\n*bufp++ = htons(session->ns);\r\n*bufp++ = 0;\r\nsession->ns++;\r\nsession->ns &= 0xffff;\r\nl2tp_dbg(session, L2TP_MSG_SEQ, "%s: updated ns to %u\n",\r\nsession->name, session->ns);\r\n}\r\nreturn bufp - optr;\r\n}\r\nstatic int l2tp_build_l2tpv3_header(struct l2tp_session *session, void *buf)\r\n{\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nchar *bufp = buf;\r\nchar *optr = bufp;\r\nif (tunnel->encap == L2TP_ENCAPTYPE_UDP) {\r\nu16 flags = L2TP_HDR_VER_3;\r\n*((__be16 *) bufp) = htons(flags);\r\nbufp += 2;\r\n*((__be16 *) bufp) = 0;\r\nbufp += 2;\r\n}\r\n*((__be32 *) bufp) = htonl(session->peer_session_id);\r\nbufp += 4;\r\nif (session->cookie_len) {\r\nmemcpy(bufp, &session->cookie[0], session->cookie_len);\r\nbufp += session->cookie_len;\r\n}\r\nif (session->l2specific_len) {\r\nif (session->l2specific_type == L2TP_L2SPECTYPE_DEFAULT) {\r\nu32 l2h = 0;\r\nif (session->send_seq) {\r\nl2h = 0x40000000 | session->ns;\r\nsession->ns++;\r\nsession->ns &= 0xffffff;\r\nl2tp_dbg(session, L2TP_MSG_SEQ,\r\n"%s: updated ns to %u\n",\r\nsession->name, session->ns);\r\n}\r\n*((__be32 *) bufp) = htonl(l2h);\r\n}\r\nbufp += session->l2specific_len;\r\n}\r\nif (session->offset)\r\nbufp += session->offset;\r\nreturn bufp - optr;\r\n}\r\nstatic int l2tp_xmit_core(struct l2tp_session *session, struct sk_buff *skb,\r\nstruct flowi *fl, size_t data_len)\r\n{\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nunsigned int len = skb->len;\r\nint error;\r\nstruct l2tp_stats *tstats, *sstats;\r\nif (session->send_seq)\r\nl2tp_dbg(session, L2TP_MSG_DATA, "%s: send %Zd bytes, ns=%u\n",\r\nsession->name, data_len, session->ns - 1);\r\nelse\r\nl2tp_dbg(session, L2TP_MSG_DATA, "%s: send %Zd bytes\n",\r\nsession->name, data_len);\r\nif (session->debug & L2TP_MSG_DATA) {\r\nint uhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(struct udphdr) : 0;\r\nunsigned char *datap = skb->data + uhlen;\r\npr_debug("%s: xmit\n", session->name);\r\nprint_hex_dump_bytes("", DUMP_PREFIX_OFFSET,\r\ndatap, min_t(size_t, 32, len - uhlen));\r\n}\r\nskb->local_df = 1;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (skb->sk->sk_family == PF_INET6)\r\nerror = inet6_csk_xmit(skb, NULL);\r\nelse\r\n#endif\r\nerror = ip_queue_xmit(skb, fl);\r\ntstats = &tunnel->stats;\r\nu64_stats_update_begin(&tstats->syncp);\r\nsstats = &session->stats;\r\nu64_stats_update_begin(&sstats->syncp);\r\nif (error >= 0) {\r\ntstats->tx_packets++;\r\ntstats->tx_bytes += len;\r\nsstats->tx_packets++;\r\nsstats->tx_bytes += len;\r\n} else {\r\ntstats->tx_errors++;\r\nsstats->tx_errors++;\r\n}\r\nu64_stats_update_end(&tstats->syncp);\r\nu64_stats_update_end(&sstats->syncp);\r\nreturn 0;\r\n}\r\nstatic void l2tp_sock_wfree(struct sk_buff *skb)\r\n{\r\nsock_put(skb->sk);\r\n}\r\nstatic inline void l2tp_skb_set_owner_w(struct sk_buff *skb, struct sock *sk)\r\n{\r\nsock_hold(sk);\r\nskb->sk = sk;\r\nskb->destructor = l2tp_sock_wfree;\r\n}\r\nstatic void l2tp_xmit_ipv6_csum(struct sock *sk, struct sk_buff *skb,\r\nint udp_len)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct udphdr *uh = udp_hdr(skb);\r\nif (!skb_dst(skb) || !skb_dst(skb)->dev ||\r\n!(skb_dst(skb)->dev->features & NETIF_F_IPV6_CSUM)) {\r\n__wsum csum = skb_checksum(skb, 0, udp_len, 0);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nuh->check = csum_ipv6_magic(&np->saddr, &np->daddr, udp_len,\r\nIPPROTO_UDP, csum);\r\nif (uh->check == 0)\r\nuh->check = CSUM_MANGLED_0;\r\n} else {\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nskb->csum_start = skb_transport_header(skb) - skb->head;\r\nskb->csum_offset = offsetof(struct udphdr, check);\r\nuh->check = ~csum_ipv6_magic(&np->saddr, &np->daddr,\r\nudp_len, IPPROTO_UDP, 0);\r\n}\r\n}\r\nint l2tp_xmit_skb(struct l2tp_session *session, struct sk_buff *skb, int hdr_len)\r\n{\r\nint data_len = skb->len;\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nstruct sock *sk = tunnel->sock;\r\nstruct flowi *fl;\r\nstruct udphdr *uh;\r\nstruct inet_sock *inet;\r\n__wsum csum;\r\nint old_headroom;\r\nint new_headroom;\r\nint headroom;\r\nint uhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(struct udphdr) : 0;\r\nint udp_len;\r\nint ret = NET_XMIT_SUCCESS;\r\nheadroom = NET_SKB_PAD + sizeof(struct iphdr) +\r\nuhlen + hdr_len;\r\nold_headroom = skb_headroom(skb);\r\nif (skb_cow_head(skb, headroom)) {\r\nkfree_skb(skb);\r\nreturn NET_XMIT_DROP;\r\n}\r\nnew_headroom = skb_headroom(skb);\r\nskb_orphan(skb);\r\nskb->truesize += new_headroom - old_headroom;\r\nsession->build_header(session, __skb_push(skb, hdr_len));\r\nmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\r\nIPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED |\r\nIPSKB_REROUTED);\r\nnf_reset(skb);\r\nbh_lock_sock(sk);\r\nif (sock_owned_by_user(sk)) {\r\nkfree_skb(skb);\r\nret = NET_XMIT_DROP;\r\ngoto out_unlock;\r\n}\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, dst_clone(__sk_dst_check(sk, 0)));\r\ninet = inet_sk(sk);\r\nfl = &inet->cork.fl;\r\nswitch (tunnel->encap) {\r\ncase L2TP_ENCAPTYPE_UDP:\r\n__skb_push(skb, sizeof(*uh));\r\nskb_reset_transport_header(skb);\r\nuh = udp_hdr(skb);\r\nuh->source = inet->inet_sport;\r\nuh->dest = inet->inet_dport;\r\nudp_len = uhlen + hdr_len + data_len;\r\nuh->len = htons(udp_len);\r\nuh->check = 0;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (sk->sk_family == PF_INET6)\r\nl2tp_xmit_ipv6_csum(sk, skb, udp_len);\r\nelse\r\n#endif\r\nif (sk->sk_no_check == UDP_CSUM_NOXMIT)\r\nskb->ip_summed = CHECKSUM_NONE;\r\nelse if ((skb_dst(skb) && skb_dst(skb)->dev) &&\r\n(!(skb_dst(skb)->dev->features & NETIF_F_V4_CSUM))) {\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\ncsum = skb_checksum(skb, 0, udp_len, 0);\r\nuh->check = csum_tcpudp_magic(inet->inet_saddr,\r\ninet->inet_daddr,\r\nudp_len, IPPROTO_UDP, csum);\r\nif (uh->check == 0)\r\nuh->check = CSUM_MANGLED_0;\r\n} else {\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nskb->csum_start = skb_transport_header(skb) - skb->head;\r\nskb->csum_offset = offsetof(struct udphdr, check);\r\nuh->check = ~csum_tcpudp_magic(inet->inet_saddr,\r\ninet->inet_daddr,\r\nudp_len, IPPROTO_UDP, 0);\r\n}\r\nbreak;\r\ncase L2TP_ENCAPTYPE_IP:\r\nbreak;\r\n}\r\nl2tp_skb_set_owner_w(skb, sk);\r\nl2tp_xmit_core(session, skb, fl, data_len);\r\nout_unlock:\r\nbh_unlock_sock(sk);\r\nreturn ret;\r\n}\r\nstatic void l2tp_tunnel_destruct(struct sock *sk)\r\n{\r\nstruct l2tp_tunnel *tunnel;\r\ntunnel = sk->sk_user_data;\r\nif (tunnel == NULL)\r\ngoto end;\r\nl2tp_info(tunnel, L2TP_MSG_CONTROL, "%s: closing...\n", tunnel->name);\r\nl2tp_tunnel_closeall(tunnel);\r\nswitch (tunnel->encap) {\r\ncase L2TP_ENCAPTYPE_UDP:\r\n(udp_sk(sk))->encap_type = 0;\r\n(udp_sk(sk))->encap_rcv = NULL;\r\nbreak;\r\ncase L2TP_ENCAPTYPE_IP:\r\nbreak;\r\n}\r\ntunnel->sock = NULL;\r\nsk->sk_destruct = tunnel->old_sk_destruct;\r\nsk->sk_user_data = NULL;\r\nif (sk->sk_destruct)\r\n(*sk->sk_destruct)(sk);\r\nl2tp_tunnel_dec_refcount(tunnel);\r\nend:\r\nreturn;\r\n}\r\nstatic void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel)\r\n{\r\nint hash;\r\nstruct hlist_node *walk;\r\nstruct hlist_node *tmp;\r\nstruct l2tp_session *session;\r\nBUG_ON(tunnel == NULL);\r\nl2tp_info(tunnel, L2TP_MSG_CONTROL, "%s: closing all sessions...\n",\r\ntunnel->name);\r\nwrite_lock_bh(&tunnel->hlist_lock);\r\nfor (hash = 0; hash < L2TP_HASH_SIZE; hash++) {\r\nagain:\r\nhlist_for_each_safe(walk, tmp, &tunnel->session_hlist[hash]) {\r\nsession = hlist_entry(walk, struct l2tp_session, hlist);\r\nl2tp_info(session, L2TP_MSG_CONTROL,\r\n"%s: closing session\n", session->name);\r\nhlist_del_init(&session->hlist);\r\nif (session->ref != NULL)\r\n(*session->ref)(session);\r\nwrite_unlock_bh(&tunnel->hlist_lock);\r\nif (tunnel->version != L2TP_HDR_VER_2) {\r\nstruct l2tp_net *pn = l2tp_pernet(tunnel->l2tp_net);\r\nspin_lock_bh(&pn->l2tp_session_hlist_lock);\r\nhlist_del_init_rcu(&session->global_hlist);\r\nspin_unlock_bh(&pn->l2tp_session_hlist_lock);\r\nsynchronize_rcu();\r\n}\r\nif (session->session_close != NULL)\r\n(*session->session_close)(session);\r\nif (session->deref != NULL)\r\n(*session->deref)(session);\r\nwrite_lock_bh(&tunnel->hlist_lock);\r\ngoto again;\r\n}\r\n}\r\nwrite_unlock_bh(&tunnel->hlist_lock);\r\n}\r\nstatic void l2tp_tunnel_free(struct l2tp_tunnel *tunnel)\r\n{\r\nstruct l2tp_net *pn = l2tp_pernet(tunnel->l2tp_net);\r\nBUG_ON(atomic_read(&tunnel->ref_count) != 0);\r\nBUG_ON(tunnel->sock != NULL);\r\nl2tp_info(tunnel, L2TP_MSG_CONTROL, "%s: free...\n", tunnel->name);\r\nspin_lock_bh(&pn->l2tp_tunnel_list_lock);\r\nlist_del_rcu(&tunnel->list);\r\nkfree_rcu(tunnel, rcu);\r\nspin_unlock_bh(&pn->l2tp_tunnel_list_lock);\r\natomic_dec(&l2tp_tunnel_count);\r\n}\r\nstatic int l2tp_tunnel_sock_create(u32 tunnel_id, u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg, struct socket **sockp)\r\n{\r\nint err = -EINVAL;\r\nstruct sockaddr_in udp_addr;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstruct sockaddr_in6 udp6_addr;\r\nstruct sockaddr_l2tpip6 ip6_addr;\r\n#endif\r\nstruct sockaddr_l2tpip ip_addr;\r\nstruct socket *sock = NULL;\r\nswitch (cfg->encap) {\r\ncase L2TP_ENCAPTYPE_UDP:\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (cfg->local_ip6 && cfg->peer_ip6) {\r\nerr = sock_create(AF_INET6, SOCK_DGRAM, 0, sockp);\r\nif (err < 0)\r\ngoto out;\r\nsock = *sockp;\r\nmemset(&udp6_addr, 0, sizeof(udp6_addr));\r\nudp6_addr.sin6_family = AF_INET6;\r\nmemcpy(&udp6_addr.sin6_addr, cfg->local_ip6,\r\nsizeof(udp6_addr.sin6_addr));\r\nudp6_addr.sin6_port = htons(cfg->local_udp_port);\r\nerr = kernel_bind(sock, (struct sockaddr *) &udp6_addr,\r\nsizeof(udp6_addr));\r\nif (err < 0)\r\ngoto out;\r\nudp6_addr.sin6_family = AF_INET6;\r\nmemcpy(&udp6_addr.sin6_addr, cfg->peer_ip6,\r\nsizeof(udp6_addr.sin6_addr));\r\nudp6_addr.sin6_port = htons(cfg->peer_udp_port);\r\nerr = kernel_connect(sock,\r\n(struct sockaddr *) &udp6_addr,\r\nsizeof(udp6_addr), 0);\r\nif (err < 0)\r\ngoto out;\r\n} else\r\n#endif\r\n{\r\nerr = sock_create(AF_INET, SOCK_DGRAM, 0, sockp);\r\nif (err < 0)\r\ngoto out;\r\nsock = *sockp;\r\nmemset(&udp_addr, 0, sizeof(udp_addr));\r\nudp_addr.sin_family = AF_INET;\r\nudp_addr.sin_addr = cfg->local_ip;\r\nudp_addr.sin_port = htons(cfg->local_udp_port);\r\nerr = kernel_bind(sock, (struct sockaddr *) &udp_addr,\r\nsizeof(udp_addr));\r\nif (err < 0)\r\ngoto out;\r\nudp_addr.sin_family = AF_INET;\r\nudp_addr.sin_addr = cfg->peer_ip;\r\nudp_addr.sin_port = htons(cfg->peer_udp_port);\r\nerr = kernel_connect(sock,\r\n(struct sockaddr *) &udp_addr,\r\nsizeof(udp_addr), 0);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nif (!cfg->use_udp_checksums)\r\nsock->sk->sk_no_check = UDP_CSUM_NOXMIT;\r\nbreak;\r\ncase L2TP_ENCAPTYPE_IP:\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (cfg->local_ip6 && cfg->peer_ip6) {\r\nerr = sock_create(AF_INET6, SOCK_DGRAM, IPPROTO_L2TP,\r\nsockp);\r\nif (err < 0)\r\ngoto out;\r\nsock = *sockp;\r\nmemset(&ip6_addr, 0, sizeof(ip6_addr));\r\nip6_addr.l2tp_family = AF_INET6;\r\nmemcpy(&ip6_addr.l2tp_addr, cfg->local_ip6,\r\nsizeof(ip6_addr.l2tp_addr));\r\nip6_addr.l2tp_conn_id = tunnel_id;\r\nerr = kernel_bind(sock, (struct sockaddr *) &ip6_addr,\r\nsizeof(ip6_addr));\r\nif (err < 0)\r\ngoto out;\r\nip6_addr.l2tp_family = AF_INET6;\r\nmemcpy(&ip6_addr.l2tp_addr, cfg->peer_ip6,\r\nsizeof(ip6_addr.l2tp_addr));\r\nip6_addr.l2tp_conn_id = peer_tunnel_id;\r\nerr = kernel_connect(sock,\r\n(struct sockaddr *) &ip6_addr,\r\nsizeof(ip6_addr), 0);\r\nif (err < 0)\r\ngoto out;\r\n} else\r\n#endif\r\n{\r\nerr = sock_create(AF_INET, SOCK_DGRAM, IPPROTO_L2TP,\r\nsockp);\r\nif (err < 0)\r\ngoto out;\r\nsock = *sockp;\r\nmemset(&ip_addr, 0, sizeof(ip_addr));\r\nip_addr.l2tp_family = AF_INET;\r\nip_addr.l2tp_addr = cfg->local_ip;\r\nip_addr.l2tp_conn_id = tunnel_id;\r\nerr = kernel_bind(sock, (struct sockaddr *) &ip_addr,\r\nsizeof(ip_addr));\r\nif (err < 0)\r\ngoto out;\r\nip_addr.l2tp_family = AF_INET;\r\nip_addr.l2tp_addr = cfg->peer_ip;\r\nip_addr.l2tp_conn_id = peer_tunnel_id;\r\nerr = kernel_connect(sock, (struct sockaddr *) &ip_addr,\r\nsizeof(ip_addr), 0);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nout:\r\nif ((err < 0) && sock) {\r\nsock_release(sock);\r\n*sockp = NULL;\r\n}\r\nreturn err;\r\n}\r\nint l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id, u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg, struct l2tp_tunnel **tunnelp)\r\n{\r\nstruct l2tp_tunnel *tunnel = NULL;\r\nint err;\r\nstruct socket *sock = NULL;\r\nstruct sock *sk = NULL;\r\nstruct l2tp_net *pn;\r\nenum l2tp_encap_type encap = L2TP_ENCAPTYPE_UDP;\r\nif (fd < 0) {\r\nerr = l2tp_tunnel_sock_create(tunnel_id, peer_tunnel_id, cfg, &sock);\r\nif (err < 0)\r\ngoto err;\r\n} else {\r\nerr = -EBADF;\r\nsock = sockfd_lookup(fd, &err);\r\nif (!sock) {\r\npr_err("tunl %hu: sockfd_lookup(fd=%d) returned %d\n",\r\ntunnel_id, fd, err);\r\ngoto err;\r\n}\r\n}\r\nsk = sock->sk;\r\nif (cfg != NULL)\r\nencap = cfg->encap;\r\nswitch (encap) {\r\ncase L2TP_ENCAPTYPE_UDP:\r\nerr = -EPROTONOSUPPORT;\r\nif (sk->sk_protocol != IPPROTO_UDP) {\r\npr_err("tunl %hu: fd %d wrong protocol, got %d, expected %d\n",\r\ntunnel_id, fd, sk->sk_protocol, IPPROTO_UDP);\r\ngoto err;\r\n}\r\nbreak;\r\ncase L2TP_ENCAPTYPE_IP:\r\nerr = -EPROTONOSUPPORT;\r\nif (sk->sk_protocol != IPPROTO_L2TP) {\r\npr_err("tunl %hu: fd %d wrong protocol, got %d, expected %d\n",\r\ntunnel_id, fd, sk->sk_protocol, IPPROTO_L2TP);\r\ngoto err;\r\n}\r\nbreak;\r\n}\r\ntunnel = (struct l2tp_tunnel *)sk->sk_user_data;\r\nif (tunnel != NULL) {\r\nerr = -EBUSY;\r\ngoto err;\r\n}\r\ntunnel = kzalloc(sizeof(struct l2tp_tunnel), GFP_KERNEL);\r\nif (tunnel == NULL) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\ntunnel->version = version;\r\ntunnel->tunnel_id = tunnel_id;\r\ntunnel->peer_tunnel_id = peer_tunnel_id;\r\ntunnel->debug = L2TP_DEFAULT_DEBUG_FLAGS;\r\ntunnel->magic = L2TP_TUNNEL_MAGIC;\r\nsprintf(&tunnel->name[0], "tunl %u", tunnel_id);\r\nrwlock_init(&tunnel->hlist_lock);\r\ntunnel->l2tp_net = net;\r\npn = l2tp_pernet(net);\r\nif (cfg != NULL)\r\ntunnel->debug = cfg->debug;\r\ntunnel->encap = encap;\r\nif (encap == L2TP_ENCAPTYPE_UDP) {\r\nudp_sk(sk)->encap_type = UDP_ENCAP_L2TPINUDP;\r\nudp_sk(sk)->encap_rcv = l2tp_udp_encap_recv;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (sk->sk_family == PF_INET6)\r\nudpv6_encap_enable();\r\nelse\r\n#endif\r\nudp_encap_enable();\r\n}\r\nsk->sk_user_data = tunnel;\r\ntunnel->old_sk_destruct = sk->sk_destruct;\r\nsk->sk_destruct = &l2tp_tunnel_destruct;\r\ntunnel->sock = sk;\r\nlockdep_set_class_and_name(&sk->sk_lock.slock, &l2tp_socket_class, "l2tp_sock");\r\nsk->sk_allocation = GFP_ATOMIC;\r\nINIT_LIST_HEAD(&tunnel->list);\r\natomic_inc(&l2tp_tunnel_count);\r\nl2tp_tunnel_inc_refcount(tunnel);\r\nspin_lock_bh(&pn->l2tp_tunnel_list_lock);\r\nlist_add_rcu(&tunnel->list, &pn->l2tp_tunnel_list);\r\nspin_unlock_bh(&pn->l2tp_tunnel_list_lock);\r\nerr = 0;\r\nerr:\r\nif (tunnelp)\r\n*tunnelp = tunnel;\r\nif (sock && sock->file)\r\nsockfd_put(sock);\r\nreturn err;\r\n}\r\nint l2tp_tunnel_delete(struct l2tp_tunnel *tunnel)\r\n{\r\nint err = 0;\r\nstruct socket *sock = tunnel->sock ? tunnel->sock->sk_socket : NULL;\r\nif (sock != NULL) {\r\nerr = inet_shutdown(sock, 2);\r\nif (sock->file == NULL)\r\nerr = inet_release(sock);\r\n}\r\nreturn err;\r\n}\r\nvoid l2tp_session_free(struct l2tp_session *session)\r\n{\r\nstruct l2tp_tunnel *tunnel;\r\nBUG_ON(atomic_read(&session->ref_count) != 0);\r\ntunnel = session->tunnel;\r\nif (tunnel != NULL) {\r\nBUG_ON(tunnel->magic != L2TP_TUNNEL_MAGIC);\r\nwrite_lock_bh(&tunnel->hlist_lock);\r\nhlist_del_init(&session->hlist);\r\nwrite_unlock_bh(&tunnel->hlist_lock);\r\nif (tunnel->version != L2TP_HDR_VER_2) {\r\nstruct l2tp_net *pn = l2tp_pernet(tunnel->l2tp_net);\r\nspin_lock_bh(&pn->l2tp_session_hlist_lock);\r\nhlist_del_init_rcu(&session->global_hlist);\r\nspin_unlock_bh(&pn->l2tp_session_hlist_lock);\r\nsynchronize_rcu();\r\n}\r\nif (session->session_id != 0)\r\natomic_dec(&l2tp_session_count);\r\nsock_put(tunnel->sock);\r\nsession->tunnel = NULL;\r\nl2tp_tunnel_dec_refcount(tunnel);\r\n}\r\nkfree(session);\r\nreturn;\r\n}\r\nint l2tp_session_delete(struct l2tp_session *session)\r\n{\r\nif (session->session_close != NULL)\r\n(*session->session_close)(session);\r\nl2tp_session_dec_refcount(session);\r\nreturn 0;\r\n}\r\nstatic void l2tp_session_set_header_len(struct l2tp_session *session, int version)\r\n{\r\nif (version == L2TP_HDR_VER_2) {\r\nsession->hdr_len = 6;\r\nif (session->send_seq)\r\nsession->hdr_len += 4;\r\n} else {\r\nsession->hdr_len = 4 + session->cookie_len + session->l2specific_len + session->offset;\r\nif (session->tunnel->encap == L2TP_ENCAPTYPE_UDP)\r\nsession->hdr_len += 4;\r\n}\r\n}\r\nstruct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg)\r\n{\r\nstruct l2tp_session *session;\r\nsession = kzalloc(sizeof(struct l2tp_session) + priv_size, GFP_KERNEL);\r\nif (session != NULL) {\r\nsession->magic = L2TP_SESSION_MAGIC;\r\nsession->tunnel = tunnel;\r\nsession->session_id = session_id;\r\nsession->peer_session_id = peer_session_id;\r\nsession->nr = 0;\r\nsprintf(&session->name[0], "sess %u/%u",\r\ntunnel->tunnel_id, session->session_id);\r\nskb_queue_head_init(&session->reorder_q);\r\nINIT_HLIST_NODE(&session->hlist);\r\nINIT_HLIST_NODE(&session->global_hlist);\r\nsession->debug = tunnel->debug;\r\nif (cfg) {\r\nsession->pwtype = cfg->pw_type;\r\nsession->debug = cfg->debug;\r\nsession->mtu = cfg->mtu;\r\nsession->mru = cfg->mru;\r\nsession->send_seq = cfg->send_seq;\r\nsession->recv_seq = cfg->recv_seq;\r\nsession->lns_mode = cfg->lns_mode;\r\nsession->reorder_timeout = cfg->reorder_timeout;\r\nsession->offset = cfg->offset;\r\nsession->l2specific_type = cfg->l2specific_type;\r\nsession->l2specific_len = cfg->l2specific_len;\r\nsession->cookie_len = cfg->cookie_len;\r\nmemcpy(&session->cookie[0], &cfg->cookie[0], cfg->cookie_len);\r\nsession->peer_cookie_len = cfg->peer_cookie_len;\r\nmemcpy(&session->peer_cookie[0], &cfg->peer_cookie[0], cfg->peer_cookie_len);\r\n}\r\nif (tunnel->version == L2TP_HDR_VER_2)\r\nsession->build_header = l2tp_build_l2tpv2_header;\r\nelse\r\nsession->build_header = l2tp_build_l2tpv3_header;\r\nl2tp_session_set_header_len(session, tunnel->version);\r\nl2tp_session_inc_refcount(session);\r\nl2tp_tunnel_inc_refcount(tunnel);\r\nsock_hold(tunnel->sock);\r\nwrite_lock_bh(&tunnel->hlist_lock);\r\nhlist_add_head(&session->hlist,\r\nl2tp_session_id_hash(tunnel, session_id));\r\nwrite_unlock_bh(&tunnel->hlist_lock);\r\nif (tunnel->version != L2TP_HDR_VER_2) {\r\nstruct l2tp_net *pn = l2tp_pernet(tunnel->l2tp_net);\r\nspin_lock_bh(&pn->l2tp_session_hlist_lock);\r\nhlist_add_head_rcu(&session->global_hlist,\r\nl2tp_session_id_hash_2(pn, session_id));\r\nspin_unlock_bh(&pn->l2tp_session_hlist_lock);\r\n}\r\nif (session->session_id != 0)\r\natomic_inc(&l2tp_session_count);\r\n}\r\nreturn session;\r\n}\r\nstatic __net_init int l2tp_init_net(struct net *net)\r\n{\r\nstruct l2tp_net *pn = net_generic(net, l2tp_net_id);\r\nint hash;\r\nINIT_LIST_HEAD(&pn->l2tp_tunnel_list);\r\nspin_lock_init(&pn->l2tp_tunnel_list_lock);\r\nfor (hash = 0; hash < L2TP_HASH_SIZE_2; hash++)\r\nINIT_HLIST_HEAD(&pn->l2tp_session_hlist[hash]);\r\nspin_lock_init(&pn->l2tp_session_hlist_lock);\r\nreturn 0;\r\n}\r\nstatic int __init l2tp_init(void)\r\n{\r\nint rc = 0;\r\nrc = register_pernet_device(&l2tp_net_ops);\r\nif (rc)\r\ngoto out;\r\npr_info("L2TP core driver, %s\n", L2TP_DRV_VERSION);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit l2tp_exit(void)\r\n{\r\nunregister_pernet_device(&l2tp_net_ops);\r\n}
