static int\r\nl1oip_socket_send(struct l1oip *hc, u8 localcodec, u8 channel, u32 chanmask,\r\nu16 timebase, u8 *buf, int len)\r\n{\r\nu8 *p;\r\nint multi = 0;\r\nu8 frame[len + 32];\r\nstruct socket *socket = NULL;\r\nif (debug & DEBUG_L1OIP_MSG)\r\nprintk(KERN_DEBUG "%s: sending data to socket (len = %d)\n",\r\n__func__, len);\r\np = frame;\r\nif ((int)(hc->keep_tl.expires-jiffies) < 5 * HZ) {\r\ndel_timer(&hc->keep_tl);\r\nhc->keep_tl.expires = jiffies + L1OIP_KEEPALIVE * HZ;\r\nadd_timer(&hc->keep_tl);\r\n} else\r\nhc->keep_tl.expires = jiffies + L1OIP_KEEPALIVE * HZ;\r\nif (debug & DEBUG_L1OIP_MSG)\r\nprintk(KERN_DEBUG "%s: resetting timer\n", __func__);\r\nif (!hc->sin_remote.sin_addr.s_addr || !hc->sin_remote.sin_port) {\r\nif (debug & DEBUG_L1OIP_MSG)\r\nprintk(KERN_DEBUG "%s: dropping frame, because remote "\r\n"IP is not set.\n", __func__);\r\nreturn len;\r\n}\r\n*p++ = (L1OIP_VERSION << 6)\r\n| (hc->pri ? 0x20 : 0x00)\r\n| (hc->id ? 0x10 : 0x00)\r\n| localcodec;\r\nif (hc->id) {\r\n*p++ = hc->id >> 24;\r\n*p++ = hc->id >> 16;\r\n*p++ = hc->id >> 8;\r\n*p++ = hc->id;\r\n}\r\n*p++ = (multi == 1) ? 0x80 : 0x00 + channel;\r\nif (multi == 1)\r\n*p++ = len;\r\n*p++ = timebase >> 8;\r\n*p++ = timebase;\r\nif (buf && len) {\r\nif (localcodec == 1 && ulaw)\r\nl1oip_ulaw_to_alaw(buf, len, p);\r\nelse if (localcodec == 2 && !ulaw)\r\nl1oip_alaw_to_ulaw(buf, len, p);\r\nelse if (localcodec == 3)\r\nlen = l1oip_law_to_4bit(buf, len, p,\r\n&hc->chan[channel].codecstate);\r\nelse\r\nmemcpy(p, buf, len);\r\n}\r\nlen += p - frame;\r\nspin_lock(&hc->socket_lock);\r\nif (!hc->socket) {\r\nspin_unlock(&hc->socket_lock);\r\nreturn 0;\r\n}\r\nsocket = hc->socket;\r\nhc->socket = NULL;\r\nspin_unlock(&hc->socket_lock);\r\nif (debug & DEBUG_L1OIP_MSG)\r\nprintk(KERN_DEBUG "%s: sending packet to socket (len "\r\n"= %d)\n", __func__, len);\r\nhc->sendiov.iov_base = frame;\r\nhc->sendiov.iov_len = len;\r\nlen = kernel_sendmsg(socket, &hc->sendmsg, &hc->sendiov, 1, len);\r\nhc->socket = socket;\r\nreturn len;\r\n}\r\nstatic void\r\nl1oip_socket_recv(struct l1oip *hc, u8 remotecodec, u8 channel, u16 timebase,\r\nu8 *buf, int len)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct bchannel *bch;\r\nstruct dchannel *dch;\r\nu8 *p;\r\nu32 rx_counter;\r\nif (len == 0) {\r\nif (debug & DEBUG_L1OIP_MSG)\r\nprintk(KERN_DEBUG "%s: received empty keepalive data, "\r\n"ignoring\n", __func__);\r\nreturn;\r\n}\r\nif (debug & DEBUG_L1OIP_MSG)\r\nprintk(KERN_DEBUG "%s: received data, sending to mISDN (%d)\n",\r\n__func__, len);\r\nif (channel < 1 || channel > 127) {\r\nprintk(KERN_WARNING "%s: packet error - channel %d out of "\r\n"range\n", __func__, channel);\r\nreturn;\r\n}\r\ndch = hc->chan[channel].dch;\r\nbch = hc->chan[channel].bch;\r\nif (!dch && !bch) {\r\nprintk(KERN_WARNING "%s: packet error - channel %d not in "\r\n"stack\n", __func__, channel);\r\nreturn;\r\n}\r\nnskb = mI_alloc_skb((remotecodec == 3) ? (len << 1) : len, GFP_ATOMIC);\r\nif (!nskb) {\r\nprintk(KERN_ERR "%s: No mem for skb.\n", __func__);\r\nreturn;\r\n}\r\np = skb_put(nskb, (remotecodec == 3) ? (len << 1) : len);\r\nif (remotecodec == 1 && ulaw)\r\nl1oip_alaw_to_ulaw(buf, len, p);\r\nelse if (remotecodec == 2 && !ulaw)\r\nl1oip_ulaw_to_alaw(buf, len, p);\r\nelse if (remotecodec == 3)\r\nlen = l1oip_4bit_to_law(buf, len, p);\r\nelse\r\nmemcpy(p, buf, len);\r\nif (dch && len >= 2) {\r\ndch->rx_skb = nskb;\r\nrecv_Dchannel(dch);\r\n}\r\nif (bch) {\r\nrx_counter = hc->chan[channel].rx_counter;\r\nif (((s16)(timebase - rx_counter)) >= 0) {\r\nif (timebase >= (rx_counter & 0xffff))\r\nrx_counter =\r\n(rx_counter & 0xffff0000) | timebase;\r\nelse\r\nrx_counter = ((rx_counter & 0xffff0000) + 0x10000)\r\n| timebase;\r\n} else {\r\nif (timebase < (rx_counter & 0xffff))\r\nrx_counter =\r\n(rx_counter & 0xffff0000) | timebase;\r\nelse\r\nrx_counter = ((rx_counter & 0xffff0000) - 0x10000)\r\n| timebase;\r\n}\r\nhc->chan[channel].rx_counter = rx_counter;\r\n#ifdef REORDER_DEBUG\r\nif (hc->chan[channel].disorder_flag) {\r\nstruct sk_buff *skb;\r\nint cnt;\r\nskb = hc->chan[channel].disorder_skb;\r\nhc->chan[channel].disorder_skb = nskb;\r\nnskb = skb;\r\ncnt = hc->chan[channel].disorder_cnt;\r\nhc->chan[channel].disorder_cnt = rx_counter;\r\nrx_counter = cnt;\r\n}\r\nhc->chan[channel].disorder_flag ^= 1;\r\nif (nskb)\r\n#endif\r\nqueue_ch_frame(&bch->ch, PH_DATA_IND, rx_counter, nskb);\r\n}\r\n}\r\nstatic void\r\nl1oip_socket_parse(struct l1oip *hc, struct sockaddr_in *sin, u8 *buf, int len)\r\n{\r\nu32 packet_id;\r\nu8 channel;\r\nu8 remotecodec;\r\nu16 timebase;\r\nint m, mlen;\r\nint len_start = len;\r\nstruct dchannel *dch = hc->chan[hc->d_idx].dch;\r\nif (debug & DEBUG_L1OIP_MSG)\r\nprintk(KERN_DEBUG "%s: received frame, parsing... (%d)\n",\r\n__func__, len);\r\nif (len < 1 + 1 + 2) {\r\nprintk(KERN_WARNING "%s: packet error - length %d below "\r\n"4 bytes\n", __func__, len);\r\nreturn;\r\n}\r\nif (((*buf) >> 6) != L1OIP_VERSION) {\r\nprintk(KERN_WARNING "%s: packet error - unknown version %d\n",\r\n__func__, buf[0]>>6);\r\nreturn;\r\n}\r\nif (((*buf) & 0x20) && !hc->pri) {\r\nprintk(KERN_WARNING "%s: packet error - received E1 packet "\r\n"on S0 interface\n", __func__);\r\nreturn;\r\n}\r\nif (!((*buf) & 0x20) && hc->pri) {\r\nprintk(KERN_WARNING "%s: packet error - received S0 packet "\r\n"on E1 interface\n", __func__);\r\nreturn;\r\n}\r\npacket_id = (*buf >> 4) & 1;\r\nremotecodec = (*buf) & 0x0f;\r\nif (remotecodec > 3) {\r\nprintk(KERN_WARNING "%s: packet error - remotecodec %d "\r\n"unsupported\n", __func__, remotecodec);\r\nreturn;\r\n}\r\nbuf++;\r\nlen--;\r\nif (packet_id) {\r\nif (!hc->id) {\r\nprintk(KERN_WARNING "%s: packet error - packet has id "\r\n"0x%x, but we have not\n", __func__, packet_id);\r\nreturn;\r\n}\r\nif (len < 4) {\r\nprintk(KERN_WARNING "%s: packet error - packet too "\r\n"short for ID value\n", __func__);\r\nreturn;\r\n}\r\npacket_id = (*buf++) << 24;\r\npacket_id += (*buf++) << 16;\r\npacket_id += (*buf++) << 8;\r\npacket_id += (*buf++);\r\nlen -= 4;\r\nif (packet_id != hc->id) {\r\nprintk(KERN_WARNING "%s: packet error - ID mismatch, "\r\n"got 0x%x, we 0x%x\n",\r\n__func__, packet_id, hc->id);\r\nreturn;\r\n}\r\n} else {\r\nif (hc->id) {\r\nprintk(KERN_WARNING "%s: packet error - packet has no "\r\n"ID, but we have\n", __func__);\r\nreturn;\r\n}\r\n}\r\nmultiframe:\r\nif (len < 1) {\r\nprintk(KERN_WARNING "%s: packet error - packet too short, "\r\n"channel expected at position %d.\n",\r\n__func__, len-len_start + 1);\r\nreturn;\r\n}\r\nchannel = *buf & 0x7f;\r\nm = *buf >> 7;\r\nbuf++;\r\nlen--;\r\nif (m) {\r\nif (len < 1) {\r\nprintk(KERN_WARNING "%s: packet error - packet too "\r\n"short, length expected at position %d.\n",\r\n__func__, len_start - len - 1);\r\nreturn;\r\n}\r\nmlen = *buf++;\r\nlen--;\r\nif (mlen == 0)\r\nmlen = 256;\r\nif (len < mlen + 3) {\r\nprintk(KERN_WARNING "%s: packet error - length %d at "\r\n"position %d exceeds total length %d.\n",\r\n__func__, mlen, len_start-len - 1, len_start);\r\nreturn;\r\n}\r\nif (len == mlen + 3) {\r\nprintk(KERN_WARNING "%s: packet error - length %d at "\r\n"position %d will not allow additional "\r\n"packet.\n",\r\n__func__, mlen, len_start-len + 1);\r\nreturn;\r\n}\r\n} else\r\nmlen = len - 2;\r\nif (len < 2) {\r\nprintk(KERN_WARNING "%s: packet error - packet too short, time "\r\n"base expected at position %d.\n",\r\n__func__, len-len_start + 1);\r\nreturn;\r\n}\r\ntimebase = (*buf++) << 8;\r\ntimebase |= (*buf++);\r\nlen -= 2;\r\nif (!test_bit(FLG_ACTIVE, &dch->Flags)) {\r\nif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\r\nprintk(KERN_DEBUG "%s: interface become active due to "\r\n"received packet\n", __func__);\r\ntest_and_set_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_ATOMIC);\r\n}\r\nl1oip_socket_recv(hc, remotecodec, channel, timebase, buf, mlen);\r\nbuf += mlen;\r\nlen -= mlen;\r\nif (m)\r\ngoto multiframe;\r\nif ((int)(hc->timeout_tl.expires-jiffies) < 5 * HZ || !hc->timeout_on) {\r\nhc->timeout_on = 1;\r\ndel_timer(&hc->timeout_tl);\r\nhc->timeout_tl.expires = jiffies + L1OIP_TIMEOUT * HZ;\r\nadd_timer(&hc->timeout_tl);\r\n} else\r\nhc->timeout_tl.expires = jiffies + L1OIP_TIMEOUT * HZ;\r\nif ((hc->sin_remote.sin_addr.s_addr != sin->sin_addr.s_addr)\r\n|| (hc->sin_remote.sin_port != sin->sin_port)) {\r\nif (debug & DEBUG_L1OIP_SOCKET)\r\nprintk(KERN_DEBUG "%s: remote address changes from "\r\n"0x%08x to 0x%08x (port %d to %d)\n", __func__,\r\nntohl(hc->sin_remote.sin_addr.s_addr),\r\nntohl(sin->sin_addr.s_addr),\r\nntohs(hc->sin_remote.sin_port),\r\nntohs(sin->sin_port));\r\nhc->sin_remote.sin_addr.s_addr = sin->sin_addr.s_addr;\r\nhc->sin_remote.sin_port = sin->sin_port;\r\n}\r\n}\r\nstatic int\r\nl1oip_socket_thread(void *data)\r\n{\r\nstruct l1oip *hc = (struct l1oip *)data;\r\nint ret = 0;\r\nstruct msghdr msg;\r\nstruct sockaddr_in sin_rx;\r\nunsigned char *recvbuf;\r\nsize_t recvbuf_size = 1500;\r\nint recvlen;\r\nstruct socket *socket = NULL;\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nrecvbuf = kmalloc(recvbuf_size, GFP_KERNEL);\r\nif (!recvbuf) {\r\nprintk(KERN_ERR "%s: Failed to alloc recvbuf.\n", __func__);\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nallow_signal(SIGTERM);\r\nif (sock_create(PF_INET, SOCK_DGRAM, IPPROTO_UDP, &socket)) {\r\nprintk(KERN_ERR "%s: Failed to create socket.\n", __func__);\r\nret = -EIO;\r\ngoto fail;\r\n}\r\nhc->sin_local.sin_family = AF_INET;\r\nhc->sin_local.sin_addr.s_addr = INADDR_ANY;\r\nhc->sin_local.sin_port = htons((unsigned short)hc->localport);\r\nhc->sin_remote.sin_family = AF_INET;\r\nhc->sin_remote.sin_addr.s_addr = htonl(hc->remoteip);\r\nhc->sin_remote.sin_port = htons((unsigned short)hc->remoteport);\r\nif (socket->ops->bind(socket, (struct sockaddr *)&hc->sin_local,\r\nsizeof(hc->sin_local))) {\r\nprintk(KERN_ERR "%s: Failed to bind socket to port %d.\n",\r\n__func__, hc->localport);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nif (socket->sk == NULL) {\r\nprintk(KERN_ERR "%s: socket->sk == NULL\n", __func__);\r\nret = -EIO;\r\ngoto fail;\r\n}\r\nmsg.msg_name = &sin_rx;\r\nmsg.msg_namelen = sizeof(sin_rx);\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nhc->sendmsg.msg_name = &hc->sin_remote;\r\nhc->sendmsg.msg_namelen = sizeof(hc->sin_remote);\r\nhc->sendmsg.msg_control = NULL;\r\nhc->sendmsg.msg_controllen = 0;\r\nspin_lock(&hc->socket_lock);\r\nhc->socket = socket;\r\nspin_unlock(&hc->socket_lock);\r\nif (debug & DEBUG_L1OIP_SOCKET)\r\nprintk(KERN_DEBUG "%s: socket created and open\n",\r\n__func__);\r\nwhile (!signal_pending(current)) {\r\nstruct kvec iov = {\r\n.iov_base = recvbuf,\r\n.iov_len = recvbuf_size,\r\n};\r\nrecvlen = kernel_recvmsg(socket, &msg, &iov, 1,\r\nrecvbuf_size, 0);\r\nif (recvlen > 0) {\r\nl1oip_socket_parse(hc, &sin_rx, recvbuf, recvlen);\r\n} else {\r\nif (debug & DEBUG_L1OIP_SOCKET)\r\nprintk(KERN_WARNING\r\n"%s: broken pipe on socket\n", __func__);\r\n}\r\n}\r\nspin_lock(&hc->socket_lock);\r\nwhile (!hc->socket) {\r\nspin_unlock(&hc->socket_lock);\r\nschedule_timeout(HZ / 10);\r\nspin_lock(&hc->socket_lock);\r\n}\r\nhc->socket = NULL;\r\nspin_unlock(&hc->socket_lock);\r\nif (debug & DEBUG_L1OIP_SOCKET)\r\nprintk(KERN_DEBUG "%s: socket thread terminating\n",\r\n__func__);\r\nfail:\r\nkfree(recvbuf);\r\nif (socket)\r\nsock_release(socket);\r\ncomplete(&hc->socket_complete);\r\nhc->socket_thread = NULL;\r\nif (debug & DEBUG_L1OIP_SOCKET)\r\nprintk(KERN_DEBUG "%s: socket thread terminated\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nstatic void\r\nl1oip_socket_close(struct l1oip *hc)\r\n{\r\nstruct dchannel *dch = hc->chan[hc->d_idx].dch;\r\nif (hc->socket_thread) {\r\nif (debug & DEBUG_L1OIP_SOCKET)\r\nprintk(KERN_DEBUG "%s: socket thread exists, "\r\n"killing...\n", __func__);\r\nsend_sig(SIGTERM, hc->socket_thread, 0);\r\nwait_for_completion(&hc->socket_complete);\r\n}\r\nif (test_bit(FLG_ACTIVE, &dch->Flags)) {\r\nif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\r\nprintk(KERN_DEBUG "%s: interface become deactivated "\r\n"due to timeout\n", __func__);\r\ntest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_ATOMIC);\r\n}\r\n}\r\nstatic int\r\nl1oip_socket_open(struct l1oip *hc)\r\n{\r\nl1oip_socket_close(hc);\r\ninit_completion(&hc->socket_complete);\r\nhc->socket_thread = kthread_run(l1oip_socket_thread, hc, "l1oip_%s",\r\nhc->name);\r\nif (IS_ERR(hc->socket_thread)) {\r\nint err = PTR_ERR(hc->socket_thread);\r\nprintk(KERN_ERR "%s: Failed (%d) to create socket process.\n",\r\n__func__, err);\r\nhc->socket_thread = NULL;\r\nsock_release(hc->socket);\r\nreturn err;\r\n}\r\nif (debug & DEBUG_L1OIP_SOCKET)\r\nprintk(KERN_DEBUG "%s: socket thread created\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void\r\nl1oip_send_bh(struct work_struct *work)\r\n{\r\nstruct l1oip *hc = container_of(work, struct l1oip, workq);\r\nif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\r\nprintk(KERN_DEBUG "%s: keepalive timer expired, sending empty "\r\n"frame on dchannel\n", __func__);\r\nl1oip_socket_send(hc, 0, hc->d_idx, 0, 0, NULL, 0);\r\n}\r\nstatic void\r\nl1oip_keepalive(void *data)\r\n{\r\nstruct l1oip *hc = (struct l1oip *)data;\r\nschedule_work(&hc->workq);\r\n}\r\nstatic void\r\nl1oip_timeout(void *data)\r\n{\r\nstruct l1oip *hc = (struct l1oip *)data;\r\nstruct dchannel *dch = hc->chan[hc->d_idx].dch;\r\nif (debug & DEBUG_L1OIP_MSG)\r\nprintk(KERN_DEBUG "%s: timeout timer expired, turn layer one "\r\n"down.\n", __func__);\r\nhc->timeout_on = 0;\r\nif (test_bit(FLG_ACTIVE, &dch->Flags)) {\r\nif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\r\nprintk(KERN_DEBUG "%s: interface become deactivated "\r\n"due to timeout\n", __func__);\r\ntest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_ATOMIC);\r\n}\r\nif (hc->ondemand) {\r\nif (debug & DEBUG_L1OIP_MSG)\r\nprintk(KERN_DEBUG "%s: on demand causes ip address to "\r\n"be removed\n", __func__);\r\nhc->sin_remote.sin_addr.s_addr = 0;\r\n}\r\n}\r\nstatic int\r\nhandle_dmsg(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct l1oip *hc = dch->hw;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nint ret = -EINVAL;\r\nint l, ll;\r\nunsigned char *p;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nif (skb->len < 1) {\r\nprintk(KERN_WARNING "%s: skb too small\n",\r\n__func__);\r\nbreak;\r\n}\r\nif (skb->len > MAX_DFRAME_LEN_L1 || skb->len > L1OIP_MAX_LEN) {\r\nprintk(KERN_WARNING "%s: skb too large\n",\r\n__func__);\r\nbreak;\r\n}\r\np = skb->data;\r\nl = skb->len;\r\nwhile (l) {\r\nll = (l < L1OIP_MAX_PERFRAME) ? l : L1OIP_MAX_PERFRAME;\r\nl1oip_socket_send(hc, 0, dch->slot, 0,\r\nhc->chan[dch->slot].tx_counter++, p, ll);\r\np += ll;\r\nl -= ll;\r\n}\r\nskb_trim(skb, 0);\r\nqueue_ch_frame(ch, PH_DATA_CNF, hh->id, skb);\r\nreturn 0;\r\ncase PH_ACTIVATE_REQ:\r\nif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\r\nprintk(KERN_DEBUG "%s: PH_ACTIVATE channel %d (1..%d)\n"\r\n, __func__, dch->slot, hc->b_num + 1);\r\nskb_trim(skb, 0);\r\nif (test_bit(FLG_ACTIVE, &dch->Flags))\r\nqueue_ch_frame(ch, PH_ACTIVATE_IND, hh->id, skb);\r\nelse\r\nqueue_ch_frame(ch, PH_DEACTIVATE_IND, hh->id, skb);\r\nreturn 0;\r\ncase PH_DEACTIVATE_REQ:\r\nif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\r\nprintk(KERN_DEBUG "%s: PH_DEACTIVATE channel %d "\r\n"(1..%d)\n", __func__, dch->slot,\r\nhc->b_num + 1);\r\nskb_trim(skb, 0);\r\nif (test_bit(FLG_ACTIVE, &dch->Flags))\r\nqueue_ch_frame(ch, PH_ACTIVATE_IND, hh->id, skb);\r\nelse\r\nqueue_ch_frame(ch, PH_DEACTIVATE_IND, hh->id, skb);\r\nreturn 0;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int\r\nchannel_dctrl(struct dchannel *dch, struct mISDN_ctrl_req *cq)\r\n{\r\nint ret = 0;\r\nstruct l1oip *hc = dch->hw;\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\ncq->op = MISDN_CTRL_SETPEER | MISDN_CTRL_UNSETPEER\r\n| MISDN_CTRL_GETPEER;\r\nbreak;\r\ncase MISDN_CTRL_SETPEER:\r\nhc->remoteip = (u32)cq->p1;\r\nhc->remoteport = cq->p2 & 0xffff;\r\nhc->localport = cq->p2 >> 16;\r\nif (!hc->remoteport)\r\nhc->remoteport = hc->localport;\r\nif (debug & DEBUG_L1OIP_SOCKET)\r\nprintk(KERN_DEBUG "%s: got new ip address from user "\r\n"space.\n", __func__);\r\nl1oip_socket_open(hc);\r\nbreak;\r\ncase MISDN_CTRL_UNSETPEER:\r\nif (debug & DEBUG_L1OIP_SOCKET)\r\nprintk(KERN_DEBUG "%s: removing ip address.\n",\r\n__func__);\r\nhc->remoteip = 0;\r\nl1oip_socket_open(hc);\r\nbreak;\r\ncase MISDN_CTRL_GETPEER:\r\nif (debug & DEBUG_L1OIP_SOCKET)\r\nprintk(KERN_DEBUG "%s: getting ip address.\n",\r\n__func__);\r\ncq->p1 = hc->remoteip;\r\ncq->p2 = hc->remoteport | (hc->localport << 16);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: unknown Op %x\n",\r\n__func__, cq->op);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nopen_dchannel(struct l1oip *hc, struct dchannel *dch, struct channel_req *rq)\r\n{\r\nif (debug & DEBUG_HW_OPEN)\r\nprintk(KERN_DEBUG "%s: dev(%d) open from %p\n", __func__,\r\ndch->dev.id, __builtin_return_address(0));\r\nif (rq->protocol == ISDN_P_NONE)\r\nreturn -EINVAL;\r\nif ((dch->dev.D.protocol != ISDN_P_NONE) &&\r\n(dch->dev.D.protocol != rq->protocol)) {\r\nif (debug & DEBUG_HW_OPEN)\r\nprintk(KERN_WARNING "%s: change protocol %x to %x\n",\r\n__func__, dch->dev.D.protocol, rq->protocol);\r\n}\r\nif (dch->dev.D.protocol != rq->protocol)\r\ndch->dev.D.protocol = rq->protocol;\r\nif (test_bit(FLG_ACTIVE, &dch->Flags)) {\r\n_queue_data(&dch->dev.D, PH_ACTIVATE_IND, MISDN_ID_ANY,\r\n0, NULL, GFP_KERNEL);\r\n}\r\nrq->ch = &dch->dev.D;\r\nif (!try_module_get(THIS_MODULE))\r\nprintk(KERN_WARNING "%s:cannot get module\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int\r\nopen_bchannel(struct l1oip *hc, struct dchannel *dch, struct channel_req *rq)\r\n{\r\nstruct bchannel *bch;\r\nint ch;\r\nif (!test_channelmap(rq->adr.channel, dch->dev.channelmap))\r\nreturn -EINVAL;\r\nif (rq->protocol == ISDN_P_NONE)\r\nreturn -EINVAL;\r\nch = rq->adr.channel;\r\nbch = hc->chan[ch].bch;\r\nif (!bch) {\r\nprintk(KERN_ERR "%s:internal error ch %d has no bch\n",\r\n__func__, ch);\r\nreturn -EINVAL;\r\n}\r\nif (test_and_set_bit(FLG_OPEN, &bch->Flags))\r\nreturn -EBUSY;\r\nbch->ch.protocol = rq->protocol;\r\nrq->ch = &bch->ch;\r\nif (!try_module_get(THIS_MODULE))\r\nprintk(KERN_WARNING "%s:cannot get module\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int\r\nl1oip_dctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct l1oip *hc = dch->hw;\r\nstruct channel_req *rq;\r\nint err = 0;\r\nif (dch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: cmd:%x %p\n",\r\n__func__, cmd, arg);\r\nswitch (cmd) {\r\ncase OPEN_CHANNEL:\r\nrq = arg;\r\nswitch (rq->protocol) {\r\ncase ISDN_P_TE_S0:\r\ncase ISDN_P_NT_S0:\r\nif (hc->pri) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nerr = open_dchannel(hc, dch, rq);\r\nbreak;\r\ncase ISDN_P_TE_E1:\r\ncase ISDN_P_NT_E1:\r\nif (!hc->pri) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nerr = open_dchannel(hc, dch, rq);\r\nbreak;\r\ndefault:\r\nerr = open_bchannel(hc, dch, rq);\r\n}\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\nif (debug & DEBUG_HW_OPEN)\r\nprintk(KERN_DEBUG "%s: dev(%d) close from %p\n",\r\n__func__, dch->dev.id,\r\n__builtin_return_address(0));\r\nmodule_put(THIS_MODULE);\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nerr = channel_dctrl(dch, arg);\r\nbreak;\r\ndefault:\r\nif (dch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: unknown command %x\n",\r\n__func__, cmd);\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nhandle_bmsg(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct l1oip *hc = bch->hw;\r\nint ret = -EINVAL;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nint l, ll;\r\nunsigned char *p;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nif (skb->len <= 0) {\r\nprintk(KERN_WARNING "%s: skb too small\n",\r\n__func__);\r\nbreak;\r\n}\r\nif (skb->len > MAX_DFRAME_LEN_L1 || skb->len > L1OIP_MAX_LEN) {\r\nprintk(KERN_WARNING "%s: skb too large\n",\r\n__func__);\r\nbreak;\r\n}\r\nl = skb->len;\r\nif (!memchr_inv(skb->data, 0xff, l)) {\r\nif (debug & DEBUG_L1OIP_MSG)\r\nprintk(KERN_DEBUG "%s: got AIS, not sending, "\r\n"but counting\n", __func__);\r\nhc->chan[bch->slot].tx_counter += l;\r\nskb_trim(skb, 0);\r\nqueue_ch_frame(ch, PH_DATA_CNF, hh->id, skb);\r\nreturn 0;\r\n}\r\nl = skb->len;\r\nif (!memchr_inv(skb->data, 0x2a, l)) {\r\nif (debug & DEBUG_L1OIP_MSG)\r\nprintk(KERN_DEBUG "%s: got silence, not sending"\r\n", but counting\n", __func__);\r\nhc->chan[bch->slot].tx_counter += l;\r\nskb_trim(skb, 0);\r\nqueue_ch_frame(ch, PH_DATA_CNF, hh->id, skb);\r\nreturn 0;\r\n}\r\np = skb->data;\r\nl = skb->len;\r\nwhile (l) {\r\nll = (l < L1OIP_MAX_PERFRAME) ? l : L1OIP_MAX_PERFRAME;\r\nl1oip_socket_send(hc, hc->codec, bch->slot, 0,\r\nhc->chan[bch->slot].tx_counter, p, ll);\r\nhc->chan[bch->slot].tx_counter += ll;\r\np += ll;\r\nl -= ll;\r\n}\r\nskb_trim(skb, 0);\r\nqueue_ch_frame(ch, PH_DATA_CNF, hh->id, skb);\r\nreturn 0;\r\ncase PH_ACTIVATE_REQ:\r\nif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\r\nprintk(KERN_DEBUG "%s: PH_ACTIVATE channel %d (1..%d)\n"\r\n, __func__, bch->slot, hc->b_num + 1);\r\nhc->chan[bch->slot].codecstate = 0;\r\ntest_and_set_bit(FLG_ACTIVE, &bch->Flags);\r\nskb_trim(skb, 0);\r\nqueue_ch_frame(ch, PH_ACTIVATE_IND, hh->id, skb);\r\nreturn 0;\r\ncase PH_DEACTIVATE_REQ:\r\nif (debug & (DEBUG_L1OIP_MSG | DEBUG_L1OIP_SOCKET))\r\nprintk(KERN_DEBUG "%s: PH_DEACTIVATE channel %d "\r\n"(1..%d)\n", __func__, bch->slot,\r\nhc->b_num + 1);\r\ntest_and_clear_bit(FLG_ACTIVE, &bch->Flags);\r\nskb_trim(skb, 0);\r\nqueue_ch_frame(ch, PH_DEACTIVATE_IND, hh->id, skb);\r\nreturn 0;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int\r\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\r\n{\r\nint ret = 0;\r\nstruct dsp_features *features =\r\n(struct dsp_features *)(*((u_long *)&cq->p1));\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\ncq->op = MISDN_CTRL_HW_FEATURES_OP;\r\nbreak;\r\ncase MISDN_CTRL_HW_FEATURES:\r\nif (debug & DEBUG_L1OIP_MSG)\r\nprintk(KERN_DEBUG "%s: HW_FEATURE request\n",\r\n__func__);\r\nfeatures->unclocked = 1;\r\nfeatures->unordered = 1;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: unknown Op %x\n",\r\n__func__, cq->op);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nl1oip_bctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nint err = -EINVAL;\r\nif (bch->debug & DEBUG_HW)\r\nprintk(KERN_DEBUG "%s: cmd:%x %p\n",\r\n__func__, cmd, arg);\r\nswitch (cmd) {\r\ncase CLOSE_CHANNEL:\r\ntest_and_clear_bit(FLG_OPEN, &bch->Flags);\r\ntest_and_clear_bit(FLG_ACTIVE, &bch->Flags);\r\nch->protocol = ISDN_P_NONE;\r\nch->peer = NULL;\r\nmodule_put(THIS_MODULE);\r\nerr = 0;\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nerr = channel_bctrl(bch, arg);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: unknown prim(%x)\n",\r\n__func__, cmd);\r\n}\r\nreturn err;\r\n}\r\nstatic void\r\nrelease_card(struct l1oip *hc)\r\n{\r\nint ch;\r\nif (timer_pending(&hc->keep_tl))\r\ndel_timer(&hc->keep_tl);\r\nif (timer_pending(&hc->timeout_tl))\r\ndel_timer(&hc->timeout_tl);\r\ncancel_work_sync(&hc->workq);\r\nif (hc->socket_thread)\r\nl1oip_socket_close(hc);\r\nif (hc->registered && hc->chan[hc->d_idx].dch)\r\nmISDN_unregister_device(&hc->chan[hc->d_idx].dch->dev);\r\nfor (ch = 0; ch < 128; ch++) {\r\nif (hc->chan[ch].dch) {\r\nmISDN_freedchannel(hc->chan[ch].dch);\r\nkfree(hc->chan[ch].dch);\r\n}\r\nif (hc->chan[ch].bch) {\r\nmISDN_freebchannel(hc->chan[ch].bch);\r\nkfree(hc->chan[ch].bch);\r\n#ifdef REORDER_DEBUG\r\nif (hc->chan[ch].disorder_skb)\r\ndev_kfree_skb(hc->chan[ch].disorder_skb);\r\n#endif\r\n}\r\n}\r\nspin_lock(&l1oip_lock);\r\nlist_del(&hc->list);\r\nspin_unlock(&l1oip_lock);\r\nkfree(hc);\r\n}\r\nstatic void\r\nl1oip_cleanup(void)\r\n{\r\nstruct l1oip *hc, *next;\r\nlist_for_each_entry_safe(hc, next, &l1oip_ilist, list)\r\nrelease_card(hc);\r\nl1oip_4bit_free();\r\n}\r\nstatic int\r\ninit_card(struct l1oip *hc, int pri, int bundle)\r\n{\r\nstruct dchannel *dch;\r\nstruct bchannel *bch;\r\nint ret;\r\nint i, ch;\r\nspin_lock_init(&hc->socket_lock);\r\nhc->idx = l1oip_cnt;\r\nhc->pri = pri;\r\nhc->d_idx = pri ? 16 : 3;\r\nhc->b_num = pri ? 30 : 2;\r\nhc->bundle = bundle;\r\nif (hc->pri)\r\nsprintf(hc->name, "l1oip-e1.%d", l1oip_cnt + 1);\r\nelse\r\nsprintf(hc->name, "l1oip-s0.%d", l1oip_cnt + 1);\r\nswitch (codec[l1oip_cnt]) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Codec(%d) not supported.\n",\r\ncodec[l1oip_cnt]);\r\nreturn -EINVAL;\r\n}\r\nhc->codec = codec[l1oip_cnt];\r\nif (debug & DEBUG_L1OIP_INIT)\r\nprintk(KERN_DEBUG "%s: using codec %d\n",\r\n__func__, hc->codec);\r\nif (id[l1oip_cnt] == 0) {\r\nprintk(KERN_WARNING "Warning: No 'id' value given or "\r\n"0, this is highly unsecure. Please use 32 "\r\n"bit randmom number 0x...\n");\r\n}\r\nhc->id = id[l1oip_cnt];\r\nif (debug & DEBUG_L1OIP_INIT)\r\nprintk(KERN_DEBUG "%s: using id 0x%x\n", __func__, hc->id);\r\nhc->ondemand = ondemand[l1oip_cnt];\r\nif (hc->ondemand && !hc->id) {\r\nprintk(KERN_ERR "%s: ondemand option only allowed in "\r\n"conjunction with non 0 ID\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (limit[l1oip_cnt])\r\nhc->b_num = limit[l1oip_cnt];\r\nif (!pri && hc->b_num > 2) {\r\nprintk(KERN_ERR "Maximum limit for BRI interface is 2 "\r\n"channels.\n");\r\nreturn -EINVAL;\r\n}\r\nif (pri && hc->b_num > 126) {\r\nprintk(KERN_ERR "Maximum limit for PRI interface is 126 "\r\n"channels.\n");\r\nreturn -EINVAL;\r\n}\r\nif (pri && hc->b_num > 30) {\r\nprintk(KERN_WARNING "Maximum limit for BRI interface is 30 "\r\n"channels.\n");\r\nprintk(KERN_WARNING "Your selection of %d channels must be "\r\n"supported by application.\n", hc->limit);\r\n}\r\nhc->remoteip = ip[l1oip_cnt << 2] << 24\r\n| ip[(l1oip_cnt << 2) + 1] << 16\r\n| ip[(l1oip_cnt << 2) + 2] << 8\r\n| ip[(l1oip_cnt << 2) + 3];\r\nhc->localport = port[l1oip_cnt]?:(L1OIP_DEFAULTPORT + l1oip_cnt);\r\nif (remoteport[l1oip_cnt])\r\nhc->remoteport = remoteport[l1oip_cnt];\r\nelse\r\nhc->remoteport = hc->localport;\r\nif (debug & DEBUG_L1OIP_INIT)\r\nprintk(KERN_DEBUG "%s: using local port %d remote ip "\r\n"%d.%d.%d.%d port %d ondemand %d\n", __func__,\r\nhc->localport, hc->remoteip >> 24,\r\n(hc->remoteip >> 16) & 0xff,\r\n(hc->remoteip >> 8) & 0xff, hc->remoteip & 0xff,\r\nhc->remoteport, hc->ondemand);\r\ndch = kzalloc(sizeof(struct dchannel), GFP_KERNEL);\r\nif (!dch)\r\nreturn -ENOMEM;\r\ndch->debug = debug;\r\nmISDN_initdchannel(dch, MAX_DFRAME_LEN_L1, NULL);\r\ndch->hw = hc;\r\nif (pri)\r\ndch->dev.Dprotocols = (1 << ISDN_P_TE_E1) | (1 << ISDN_P_NT_E1);\r\nelse\r\ndch->dev.Dprotocols = (1 << ISDN_P_TE_S0) | (1 << ISDN_P_NT_S0);\r\ndch->dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\r\n(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\r\ndch->dev.D.send = handle_dmsg;\r\ndch->dev.D.ctrl = l1oip_dctrl;\r\ndch->dev.nrbchan = hc->b_num;\r\ndch->slot = hc->d_idx;\r\nhc->chan[hc->d_idx].dch = dch;\r\ni = 1;\r\nfor (ch = 0; ch < dch->dev.nrbchan; ch++) {\r\nif (ch == 15)\r\ni++;\r\nbch = kzalloc(sizeof(struct bchannel), GFP_KERNEL);\r\nif (!bch) {\r\nprintk(KERN_ERR "%s: no memory for bchannel\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nbch->nr = i + ch;\r\nbch->slot = i + ch;\r\nbch->debug = debug;\r\nmISDN_initbchannel(bch, MAX_DATA_MEM, 0);\r\nbch->hw = hc;\r\nbch->ch.send = handle_bmsg;\r\nbch->ch.ctrl = l1oip_bctrl;\r\nbch->ch.nr = i + ch;\r\nlist_add(&bch->ch.list, &dch->dev.bchannels);\r\nhc->chan[i + ch].bch = bch;\r\nset_channelmap(bch->nr, dch->dev.channelmap);\r\n}\r\nret = mISDN_register_device(&dch->dev, NULL, hc->name);\r\nif (ret)\r\nreturn ret;\r\nhc->registered = 1;\r\nif (debug & DEBUG_L1OIP_INIT)\r\nprintk(KERN_DEBUG "%s: Setting up network card(%d)\n",\r\n__func__, l1oip_cnt + 1);\r\nret = l1oip_socket_open(hc);\r\nif (ret)\r\nreturn ret;\r\nhc->keep_tl.function = (void *)l1oip_keepalive;\r\nhc->keep_tl.data = (ulong)hc;\r\ninit_timer(&hc->keep_tl);\r\nhc->keep_tl.expires = jiffies + 2 * HZ;\r\nadd_timer(&hc->keep_tl);\r\nhc->timeout_tl.function = (void *)l1oip_timeout;\r\nhc->timeout_tl.data = (ulong)hc;\r\ninit_timer(&hc->timeout_tl);\r\nhc->timeout_on = 0;\r\nreturn 0;\r\n}\r\nstatic int __init\r\nl1oip_init(void)\r\n{\r\nint pri, bundle;\r\nstruct l1oip *hc;\r\nint ret;\r\nprintk(KERN_INFO "mISDN: Layer-1-over-IP driver Rev. %s\n",\r\nl1oip_revision);\r\nINIT_LIST_HEAD(&l1oip_ilist);\r\nspin_lock_init(&l1oip_lock);\r\nif (l1oip_4bit_alloc(ulaw))\r\nreturn -ENOMEM;\r\nl1oip_cnt = 0;\r\nwhile (l1oip_cnt < MAX_CARDS && type[l1oip_cnt]) {\r\nswitch (type[l1oip_cnt] & 0xff) {\r\ncase 1:\r\npri = 0;\r\nbundle = 0;\r\nbreak;\r\ncase 2:\r\npri = 1;\r\nbundle = 0;\r\nbreak;\r\ncase 3:\r\npri = 0;\r\nbundle = 1;\r\nbreak;\r\ncase 4:\r\npri = 1;\r\nbundle = 1;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Card type(%d) not supported.\n",\r\ntype[l1oip_cnt] & 0xff);\r\nl1oip_cleanup();\r\nreturn -EINVAL;\r\n}\r\nif (debug & DEBUG_L1OIP_INIT)\r\nprintk(KERN_DEBUG "%s: interface %d is %s with %s.\n",\r\n__func__, l1oip_cnt, pri ? "PRI" : "BRI",\r\nbundle ? "bundled IP packet for all B-channels" :\r\n"separate IP packets for every B-channel");\r\nhc = kzalloc(sizeof(struct l1oip), GFP_ATOMIC);\r\nif (!hc) {\r\nprintk(KERN_ERR "No kmem for L1-over-IP driver.\n");\r\nl1oip_cleanup();\r\nreturn -ENOMEM;\r\n}\r\nINIT_WORK(&hc->workq, (void *)l1oip_send_bh);\r\nspin_lock(&l1oip_lock);\r\nlist_add_tail(&hc->list, &l1oip_ilist);\r\nspin_unlock(&l1oip_lock);\r\nret = init_card(hc, pri, bundle);\r\nif (ret) {\r\nl1oip_cleanup();\r\nreturn ret;\r\n}\r\nl1oip_cnt++;\r\n}\r\nprintk(KERN_INFO "%d virtual devices registered\n", l1oip_cnt);\r\nreturn 0;\r\n}
