static inline void ehci_write(void __iomem *base, u32 reg, u32 val)\r\n{\r\n__raw_writel(val, base + reg);\r\n}\r\nstatic inline u32 ehci_read(void __iomem *base, u32 reg)\r\n{\r\nreturn __raw_readl(base + reg);\r\n}\r\nstatic void omap_ehci_soft_phy_reset(struct usb_hcd *hcd, u8 port)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\nunsigned reg = 0;\r\nreg = ULPI_FUNC_CTRL_RESET\r\n| (ULPI_SET(ULPI_FUNC_CTRL) << EHCI_INSNREG05_ULPI_REGADD_SHIFT)\r\n| (2 << EHCI_INSNREG05_ULPI_OPSEL_SHIFT)\r\n| ((port + 1) << EHCI_INSNREG05_ULPI_PORTSEL_SHIFT)\r\n| (1 << EHCI_INSNREG05_ULPI_CONTROL_SHIFT);\r\nehci_write(hcd->regs, EHCI_INSNREG05_ULPI, reg);\r\nwhile ((ehci_read(hcd->regs, EHCI_INSNREG05_ULPI)\r\n& (1 << EHCI_INSNREG05_ULPI_CONTROL_SHIFT))) {\r\ncpu_relax();\r\nif (time_after(jiffies, timeout)) {\r\ndev_dbg(hcd->self.controller,\r\n"phy reset operation timed out\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int omap_ehci_init(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nint rc;\r\nstruct ehci_hcd_omap_platform_data *pdata;\r\npdata = hcd->self.controller->platform_data;\r\nif (pdata->phy_reset) {\r\nif (gpio_is_valid(pdata->reset_gpio_port[0]))\r\ngpio_set_value_cansleep(pdata->reset_gpio_port[0], 0);\r\nif (gpio_is_valid(pdata->reset_gpio_port[1]))\r\ngpio_set_value_cansleep(pdata->reset_gpio_port[1], 0);\r\nudelay(10);\r\n}\r\nif (pdata->port_mode[0] == OMAP_EHCI_PORT_MODE_PHY)\r\nomap_ehci_soft_phy_reset(hcd, 0);\r\nif (pdata->port_mode[1] == OMAP_EHCI_PORT_MODE_PHY)\r\nomap_ehci_soft_phy_reset(hcd, 1);\r\nehci->caps = hcd->regs;\r\nrc = ehci_setup(hcd);\r\nif (pdata->phy_reset) {\r\nudelay(10);\r\nif (gpio_is_valid(pdata->reset_gpio_port[0]))\r\ngpio_set_value_cansleep(pdata->reset_gpio_port[0], 1);\r\nif (gpio_is_valid(pdata->reset_gpio_port[1]))\r\ngpio_set_value_cansleep(pdata->reset_gpio_port[1], 1);\r\n}\r\nehci_port_power(ehci, 1);\r\nreturn rc;\r\n}\r\nstatic void disable_put_regulator(\r\nstruct ehci_hcd_omap_platform_data *pdata)\r\n{\r\nint i;\r\nfor (i = 0 ; i < OMAP3_HS_USB_PORTS ; i++) {\r\nif (pdata->regulator[i]) {\r\nregulator_disable(pdata->regulator[i]);\r\nregulator_put(pdata->regulator[i]);\r\n}\r\n}\r\n}\r\nstatic int ehci_hcd_omap_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ehci_hcd_omap_platform_data *pdata = dev->platform_data;\r\nstruct resource *res;\r\nstruct usb_hcd *hcd;\r\nvoid __iomem *regs;\r\nint ret = -ENODEV;\r\nint irq;\r\nint i;\r\nchar supply[7];\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nif (!dev->parent) {\r\ndev_err(dev, "Missing parent device\n");\r\nreturn -ENODEV;\r\n}\r\nirq = platform_get_irq_byname(pdev, "ehci-irq");\r\nif (irq < 0) {\r\ndev_err(dev, "EHCI irq failed\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource_byname(pdev,\r\nIORESOURCE_MEM, "ehci");\r\nif (!res) {\r\ndev_err(dev, "UHH EHCI get resource failed\n");\r\nreturn -ENODEV;\r\n}\r\nregs = ioremap(res->start, resource_size(res));\r\nif (!regs) {\r\ndev_err(dev, "UHH EHCI ioremap failed\n");\r\nreturn -ENOMEM;\r\n}\r\nhcd = usb_create_hcd(&ehci_omap_hc_driver, dev,\r\ndev_name(dev));\r\nif (!hcd) {\r\ndev_err(dev, "failed to create hcd with err %d\n", ret);\r\nret = -ENOMEM;\r\ngoto err_io;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nhcd->regs = regs;\r\nfor (i = 0 ; i < OMAP3_HS_USB_PORTS ; i++) {\r\nif (pdata->port_mode[i] != OMAP_EHCI_PORT_MODE_PHY) {\r\npdata->regulator[i] = NULL;\r\ncontinue;\r\n}\r\nsnprintf(supply, sizeof(supply), "hsusb%d", i);\r\npdata->regulator[i] = regulator_get(dev, supply);\r\nif (IS_ERR(pdata->regulator[i])) {\r\npdata->regulator[i] = NULL;\r\ndev_dbg(dev,\r\n"failed to get ehci port%d regulator\n", i);\r\n} else {\r\nregulator_enable(pdata->regulator[i]);\r\n}\r\n}\r\npm_runtime_enable(dev);\r\npm_runtime_get_sync(dev);\r\nehci_write(regs, EHCI_INSNREG04,\r\nEHCI_INSNREG04_DISABLE_UNSUSPEND);\r\nret = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (ret) {\r\ndev_err(dev, "failed to add hcd with err %d\n", ret);\r\ngoto err_pm_runtime;\r\n}\r\nreturn 0;\r\nerr_pm_runtime:\r\ndisable_put_regulator(pdata);\r\npm_runtime_put_sync(dev);\r\nusb_put_hcd(hcd);\r\nerr_io:\r\niounmap(regs);\r\nreturn ret;\r\n}\r\nstatic int ehci_hcd_omap_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct ehci_hcd_omap_platform_data *pdata = dev->platform_data;\r\nusb_remove_hcd(hcd);\r\ndisable_put_regulator(dev->platform_data);\r\niounmap(hcd->regs);\r\nusb_put_hcd(hcd);\r\npm_runtime_put_sync(dev);\r\npm_runtime_disable(dev);\r\nif (pdata->phy_reset) {\r\nif (gpio_is_valid(pdata->reset_gpio_port[0]))\r\ngpio_free(pdata->reset_gpio_port[0]);\r\nif (gpio_is_valid(pdata->reset_gpio_port[1]))\r\ngpio_free(pdata->reset_gpio_port[1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ehci_hcd_omap_shutdown(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(&pdev->dev);\r\nif (hcd->driver->shutdown)\r\nhcd->driver->shutdown(hcd);\r\n}
