static void lpc32xx_mod_states(struct lpc32xx_kscan_drv *kscandat, int col)\r\n{\r\nstruct input_dev *input = kscandat->input;\r\nunsigned row, changed, scancode, keycode;\r\nu8 key;\r\nkey = readl(LPC32XX_KS_DATA(kscandat->kscan_base, col));\r\nchanged = key ^ kscandat->lastkeystates[col];\r\nkscandat->lastkeystates[col] = key;\r\nfor (row = 0; changed; row++, changed >>= 1) {\r\nif (changed & 1) {\r\nscancode = MATRIX_SCAN_CODE(row, col,\r\nkscandat->row_shift);\r\nkeycode = kscandat->keymap[scancode];\r\ninput_event(input, EV_MSC, MSC_SCAN, scancode);\r\ninput_report_key(input, keycode, key & (1 << row));\r\n}\r\n}\r\n}\r\nstatic irqreturn_t lpc32xx_kscan_irq(int irq, void *dev_id)\r\n{\r\nstruct lpc32xx_kscan_drv *kscandat = dev_id;\r\nint i;\r\nfor (i = 0; i < kscandat->matrix_sz; i++)\r\nlpc32xx_mod_states(kscandat, i);\r\nwritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\r\ninput_sync(kscandat->input);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lpc32xx_kscan_open(struct input_dev *dev)\r\n{\r\nstruct lpc32xx_kscan_drv *kscandat = input_get_drvdata(dev);\r\nint error;\r\nerror = clk_prepare_enable(kscandat->clk);\r\nif (error)\r\nreturn error;\r\nwritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\r\nreturn 0;\r\n}\r\nstatic void lpc32xx_kscan_close(struct input_dev *dev)\r\n{\r\nstruct lpc32xx_kscan_drv *kscandat = input_get_drvdata(dev);\r\nwritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\r\nclk_disable_unprepare(kscandat->clk);\r\n}\r\nstatic int __devinit lpc32xx_parse_dt(struct device *dev,\r\nstruct lpc32xx_kscan_drv *kscandat)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nu32 rows = 0, columns = 0;\r\nof_property_read_u32(np, "keypad,num-rows", &rows);\r\nof_property_read_u32(np, "keypad,num-columns", &columns);\r\nif (!rows || rows != columns) {\r\ndev_err(dev,\r\n"rows and columns must be specified and be equal!\n");\r\nreturn -EINVAL;\r\n}\r\nkscandat->matrix_sz = rows;\r\nkscandat->row_shift = get_count_order(columns);\r\nof_property_read_u32(np, "nxp,debounce-delay-ms", &kscandat->deb_clks);\r\nof_property_read_u32(np, "nxp,scan-delay-ms", &kscandat->scan_delay);\r\nif (!kscandat->deb_clks || !kscandat->scan_delay) {\r\ndev_err(dev, "debounce or scan delay not specified\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit lpc32xx_kscan_probe(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_kscan_drv *kscandat;\r\nstruct input_dev *input;\r\nstruct resource *res;\r\nsize_t keymap_size;\r\nint error;\r\nint irq;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "failed to get platform I/O memory\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0 || irq >= NR_IRQS) {\r\ndev_err(&pdev->dev, "failed to get platform irq\n");\r\nreturn -EINVAL;\r\n}\r\nkscandat = kzalloc(sizeof(struct lpc32xx_kscan_drv), GFP_KERNEL);\r\nif (!kscandat) {\r\ndev_err(&pdev->dev, "failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nerror = lpc32xx_parse_dt(&pdev->dev, kscandat);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to parse device tree\n");\r\ngoto err_free_mem;\r\n}\r\nkeymap_size = sizeof(kscandat->keymap[0]) *\r\n(kscandat->matrix_sz << kscandat->row_shift);\r\nkscandat->keymap = kzalloc(keymap_size, GFP_KERNEL);\r\nif (!kscandat->keymap) {\r\ndev_err(&pdev->dev, "could not allocate memory for keymap\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nkscandat->input = input = input_allocate_device();\r\nif (!input) {\r\ndev_err(&pdev->dev, "failed to allocate input device\n");\r\nerror = -ENOMEM;\r\ngoto err_free_keymap;\r\n}\r\ninput->name = pdev->name;\r\ninput->phys = "lpc32xx/input0";\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0100;\r\ninput->open = lpc32xx_kscan_open;\r\ninput->close = lpc32xx_kscan_close;\r\ninput->dev.parent = &pdev->dev;\r\ninput_set_capability(input, EV_MSC, MSC_SCAN);\r\nerror = matrix_keypad_build_keymap(NULL, NULL,\r\nkscandat->matrix_sz,\r\nkscandat->matrix_sz,\r\nkscandat->keymap, kscandat->input);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to build keymap\n");\r\ngoto err_free_input;\r\n}\r\ninput_set_drvdata(kscandat->input, kscandat);\r\nkscandat->iores = request_mem_region(res->start, resource_size(res),\r\npdev->name);\r\nif (!kscandat->iores) {\r\ndev_err(&pdev->dev, "failed to request I/O memory\n");\r\nerror = -EBUSY;\r\ngoto err_free_input;\r\n}\r\nkscandat->kscan_base = ioremap(kscandat->iores->start,\r\nresource_size(kscandat->iores));\r\nif (!kscandat->kscan_base) {\r\ndev_err(&pdev->dev, "failed to remap I/O memory\n");\r\nerror = -EBUSY;\r\ngoto err_release_memregion;\r\n}\r\nkscandat->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(kscandat->clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nerror = PTR_ERR(kscandat->clk);\r\ngoto err_unmap;\r\n}\r\nerror = clk_prepare_enable(kscandat->clk);\r\nif (error)\r\ngoto err_clk_put;\r\nwritel(kscandat->deb_clks, LPC32XX_KS_DEB(kscandat->kscan_base));\r\nwritel(kscandat->scan_delay, LPC32XX_KS_SCAN_CTL(kscandat->kscan_base));\r\nwritel(LPC32XX_KSCAN_FTST_USE32K_CLK,\r\nLPC32XX_KS_FAST_TST(kscandat->kscan_base));\r\nwritel(kscandat->matrix_sz,\r\nLPC32XX_KS_MATRIX_DIM(kscandat->kscan_base));\r\nwritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\r\nclk_disable_unprepare(kscandat->clk);\r\nerror = request_irq(irq, lpc32xx_kscan_irq, 0, pdev->name, kscandat);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to request irq\n");\r\ngoto err_clk_put;\r\n}\r\nerror = input_register_device(kscandat->input);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\ngoto err_free_irq;\r\n}\r\nplatform_set_drvdata(pdev, kscandat);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(irq, kscandat);\r\nerr_clk_put:\r\nclk_put(kscandat->clk);\r\nerr_unmap:\r\niounmap(kscandat->kscan_base);\r\nerr_release_memregion:\r\nrelease_mem_region(kscandat->iores->start,\r\nresource_size(kscandat->iores));\r\nerr_free_input:\r\ninput_free_device(kscandat->input);\r\nerr_free_keymap:\r\nkfree(kscandat->keymap);\r\nerr_free_mem:\r\nkfree(kscandat);\r\nreturn error;\r\n}\r\nstatic int __devexit lpc32xx_kscan_remove(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_kscan_drv *kscandat = platform_get_drvdata(pdev);\r\nfree_irq(platform_get_irq(pdev, 0), kscandat);\r\nclk_put(kscandat->clk);\r\niounmap(kscandat->kscan_base);\r\nrelease_mem_region(kscandat->iores->start,\r\nresource_size(kscandat->iores));\r\ninput_unregister_device(kscandat->input);\r\nkfree(kscandat->keymap);\r\nkfree(kscandat);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_kscan_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct lpc32xx_kscan_drv *kscandat = platform_get_drvdata(pdev);\r\nstruct input_dev *input = kscandat->input;\r\nmutex_lock(&input->mutex);\r\nif (input->users) {\r\nwritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\r\nclk_disable_unprepare(kscandat->clk);\r\n}\r\nmutex_unlock(&input->mutex);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_kscan_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct lpc32xx_kscan_drv *kscandat = platform_get_drvdata(pdev);\r\nstruct input_dev *input = kscandat->input;\r\nint retval = 0;\r\nmutex_lock(&input->mutex);\r\nif (input->users) {\r\nretval = clk_prepare_enable(kscandat->clk);\r\nif (retval == 0)\r\nwritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\r\n}\r\nmutex_unlock(&input->mutex);\r\nreturn retval;\r\n}
