static inline void *allocate_probes(int count)\r\n{\r\nstruct tp_probes *p = kmalloc(count * sizeof(struct tracepoint_func)\r\n+ sizeof(struct tp_probes), GFP_KERNEL);\r\nreturn p == NULL ? NULL : p->probes;\r\n}\r\nstatic void rcu_free_old_probes(struct rcu_head *head)\r\n{\r\nkfree(container_of(head, struct tp_probes, u.rcu));\r\n}\r\nstatic inline void release_probes(struct tracepoint_func *old)\r\n{\r\nif (old) {\r\nstruct tp_probes *tp_probes = container_of(old,\r\nstruct tp_probes, probes[0]);\r\ncall_rcu_sched(&tp_probes->u.rcu, rcu_free_old_probes);\r\n}\r\n}\r\nstatic void debug_print_probes(struct tracepoint_entry *entry)\r\n{\r\nint i;\r\nif (!tracepoint_debug || !entry->funcs)\r\nreturn;\r\nfor (i = 0; entry->funcs[i].func; i++)\r\nprintk(KERN_DEBUG "Probe %d : %p\n", i, entry->funcs[i].func);\r\n}\r\nstatic struct tracepoint_func *\r\ntracepoint_entry_add_probe(struct tracepoint_entry *entry,\r\nvoid *probe, void *data)\r\n{\r\nint nr_probes = 0;\r\nstruct tracepoint_func *old, *new;\r\nWARN_ON(!probe);\r\ndebug_print_probes(entry);\r\nold = entry->funcs;\r\nif (old) {\r\nfor (nr_probes = 0; old[nr_probes].func; nr_probes++)\r\nif (old[nr_probes].func == probe &&\r\nold[nr_probes].data == data)\r\nreturn ERR_PTR(-EEXIST);\r\n}\r\nnew = allocate_probes(nr_probes + 2);\r\nif (new == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (old)\r\nmemcpy(new, old, nr_probes * sizeof(struct tracepoint_func));\r\nnew[nr_probes].func = probe;\r\nnew[nr_probes].data = data;\r\nnew[nr_probes + 1].func = NULL;\r\nentry->refcount = nr_probes + 1;\r\nentry->funcs = new;\r\ndebug_print_probes(entry);\r\nreturn old;\r\n}\r\nstatic void *\r\ntracepoint_entry_remove_probe(struct tracepoint_entry *entry,\r\nvoid *probe, void *data)\r\n{\r\nint nr_probes = 0, nr_del = 0, i;\r\nstruct tracepoint_func *old, *new;\r\nold = entry->funcs;\r\nif (!old)\r\nreturn ERR_PTR(-ENOENT);\r\ndebug_print_probes(entry);\r\nfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\r\nif (!probe ||\r\n(old[nr_probes].func == probe &&\r\nold[nr_probes].data == data))\r\nnr_del++;\r\n}\r\nif (nr_probes - nr_del == 0) {\r\nentry->funcs = NULL;\r\nentry->refcount = 0;\r\ndebug_print_probes(entry);\r\nreturn old;\r\n} else {\r\nint j = 0;\r\nnew = allocate_probes(nr_probes - nr_del + 1);\r\nif (new == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; old[i].func; i++)\r\nif (probe &&\r\n(old[i].func != probe || old[i].data != data))\r\nnew[j++] = old[i];\r\nnew[nr_probes - nr_del].func = NULL;\r\nentry->refcount = nr_probes - nr_del;\r\nentry->funcs = new;\r\n}\r\ndebug_print_probes(entry);\r\nreturn old;\r\n}\r\nstatic struct tracepoint_entry *get_tracepoint(const char *name)\r\n{\r\nstruct hlist_head *head;\r\nstruct hlist_node *node;\r\nstruct tracepoint_entry *e;\r\nu32 hash = jhash(name, strlen(name), 0);\r\nhead = &tracepoint_table[hash & (TRACEPOINT_TABLE_SIZE - 1)];\r\nhlist_for_each_entry(e, node, head, hlist) {\r\nif (!strcmp(name, e->name))\r\nreturn e;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct tracepoint_entry *add_tracepoint(const char *name)\r\n{\r\nstruct hlist_head *head;\r\nstruct hlist_node *node;\r\nstruct tracepoint_entry *e;\r\nsize_t name_len = strlen(name) + 1;\r\nu32 hash = jhash(name, name_len-1, 0);\r\nhead = &tracepoint_table[hash & (TRACEPOINT_TABLE_SIZE - 1)];\r\nhlist_for_each_entry(e, node, head, hlist) {\r\nif (!strcmp(name, e->name)) {\r\nprintk(KERN_NOTICE\r\n"tracepoint %s busy\n", name);\r\nreturn ERR_PTR(-EEXIST);\r\n}\r\n}\r\ne = kmalloc(sizeof(struct tracepoint_entry) + name_len, GFP_KERNEL);\r\nif (!e)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemcpy(&e->name[0], name, name_len);\r\ne->funcs = NULL;\r\ne->refcount = 0;\r\nhlist_add_head(&e->hlist, head);\r\nreturn e;\r\n}\r\nstatic inline void remove_tracepoint(struct tracepoint_entry *e)\r\n{\r\nhlist_del(&e->hlist);\r\nkfree(e);\r\n}\r\nstatic void set_tracepoint(struct tracepoint_entry **entry,\r\nstruct tracepoint *elem, int active)\r\n{\r\nWARN_ON(strcmp((*entry)->name, elem->name) != 0);\r\nif (elem->regfunc && !static_key_enabled(&elem->key) && active)\r\nelem->regfunc();\r\nelse if (elem->unregfunc && static_key_enabled(&elem->key) && !active)\r\nelem->unregfunc();\r\nrcu_assign_pointer(elem->funcs, (*entry)->funcs);\r\nif (active && !static_key_enabled(&elem->key))\r\nstatic_key_slow_inc(&elem->key);\r\nelse if (!active && static_key_enabled(&elem->key))\r\nstatic_key_slow_dec(&elem->key);\r\n}\r\nstatic void disable_tracepoint(struct tracepoint *elem)\r\n{\r\nif (elem->unregfunc && static_key_enabled(&elem->key))\r\nelem->unregfunc();\r\nif (static_key_enabled(&elem->key))\r\nstatic_key_slow_dec(&elem->key);\r\nrcu_assign_pointer(elem->funcs, NULL);\r\n}\r\nstatic void tracepoint_update_probe_range(struct tracepoint * const *begin,\r\nstruct tracepoint * const *end)\r\n{\r\nstruct tracepoint * const *iter;\r\nstruct tracepoint_entry *mark_entry;\r\nif (!begin)\r\nreturn;\r\nfor (iter = begin; iter < end; iter++) {\r\nmark_entry = get_tracepoint((*iter)->name);\r\nif (mark_entry) {\r\nset_tracepoint(&mark_entry, *iter,\r\n!!mark_entry->refcount);\r\n} else {\r\ndisable_tracepoint(*iter);\r\n}\r\n}\r\n}\r\nvoid module_update_tracepoints(void)\r\n{\r\nstruct tp_module *tp_mod;\r\nlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\r\ntracepoint_update_probe_range(tp_mod->tracepoints_ptrs,\r\ntp_mod->tracepoints_ptrs + tp_mod->num_tracepoints);\r\n}\r\nvoid module_update_tracepoints(void)\r\n{\r\n}\r\nstatic void tracepoint_update_probes(void)\r\n{\r\ntracepoint_update_probe_range(__start___tracepoints_ptrs,\r\n__stop___tracepoints_ptrs);\r\nmodule_update_tracepoints();\r\n}\r\nstatic struct tracepoint_func *\r\ntracepoint_add_probe(const char *name, void *probe, void *data)\r\n{\r\nstruct tracepoint_entry *entry;\r\nstruct tracepoint_func *old;\r\nentry = get_tracepoint(name);\r\nif (!entry) {\r\nentry = add_tracepoint(name);\r\nif (IS_ERR(entry))\r\nreturn (struct tracepoint_func *)entry;\r\n}\r\nold = tracepoint_entry_add_probe(entry, probe, data);\r\nif (IS_ERR(old) && !entry->refcount)\r\nremove_tracepoint(entry);\r\nreturn old;\r\n}\r\nint tracepoint_probe_register(const char *name, void *probe, void *data)\r\n{\r\nstruct tracepoint_func *old;\r\nmutex_lock(&tracepoints_mutex);\r\nold = tracepoint_add_probe(name, probe, data);\r\nif (IS_ERR(old)) {\r\nmutex_unlock(&tracepoints_mutex);\r\nreturn PTR_ERR(old);\r\n}\r\ntracepoint_update_probes();\r\nmutex_unlock(&tracepoints_mutex);\r\nrelease_probes(old);\r\nreturn 0;\r\n}\r\nstatic struct tracepoint_func *\r\ntracepoint_remove_probe(const char *name, void *probe, void *data)\r\n{\r\nstruct tracepoint_entry *entry;\r\nstruct tracepoint_func *old;\r\nentry = get_tracepoint(name);\r\nif (!entry)\r\nreturn ERR_PTR(-ENOENT);\r\nold = tracepoint_entry_remove_probe(entry, probe, data);\r\nif (IS_ERR(old))\r\nreturn old;\r\nif (!entry->refcount)\r\nremove_tracepoint(entry);\r\nreturn old;\r\n}\r\nint tracepoint_probe_unregister(const char *name, void *probe, void *data)\r\n{\r\nstruct tracepoint_func *old;\r\nmutex_lock(&tracepoints_mutex);\r\nold = tracepoint_remove_probe(name, probe, data);\r\nif (IS_ERR(old)) {\r\nmutex_unlock(&tracepoints_mutex);\r\nreturn PTR_ERR(old);\r\n}\r\ntracepoint_update_probes();\r\nmutex_unlock(&tracepoints_mutex);\r\nrelease_probes(old);\r\nreturn 0;\r\n}\r\nstatic void tracepoint_add_old_probes(void *old)\r\n{\r\nneed_update = 1;\r\nif (old) {\r\nstruct tp_probes *tp_probes = container_of(old,\r\nstruct tp_probes, probes[0]);\r\nlist_add(&tp_probes->u.list, &old_probes);\r\n}\r\n}\r\nint tracepoint_probe_register_noupdate(const char *name, void *probe,\r\nvoid *data)\r\n{\r\nstruct tracepoint_func *old;\r\nmutex_lock(&tracepoints_mutex);\r\nold = tracepoint_add_probe(name, probe, data);\r\nif (IS_ERR(old)) {\r\nmutex_unlock(&tracepoints_mutex);\r\nreturn PTR_ERR(old);\r\n}\r\ntracepoint_add_old_probes(old);\r\nmutex_unlock(&tracepoints_mutex);\r\nreturn 0;\r\n}\r\nint tracepoint_probe_unregister_noupdate(const char *name, void *probe,\r\nvoid *data)\r\n{\r\nstruct tracepoint_func *old;\r\nmutex_lock(&tracepoints_mutex);\r\nold = tracepoint_remove_probe(name, probe, data);\r\nif (IS_ERR(old)) {\r\nmutex_unlock(&tracepoints_mutex);\r\nreturn PTR_ERR(old);\r\n}\r\ntracepoint_add_old_probes(old);\r\nmutex_unlock(&tracepoints_mutex);\r\nreturn 0;\r\n}\r\nvoid tracepoint_probe_update_all(void)\r\n{\r\nLIST_HEAD(release_probes);\r\nstruct tp_probes *pos, *next;\r\nmutex_lock(&tracepoints_mutex);\r\nif (!need_update) {\r\nmutex_unlock(&tracepoints_mutex);\r\nreturn;\r\n}\r\nif (!list_empty(&old_probes))\r\nlist_replace_init(&old_probes, &release_probes);\r\nneed_update = 0;\r\ntracepoint_update_probes();\r\nmutex_unlock(&tracepoints_mutex);\r\nlist_for_each_entry_safe(pos, next, &release_probes, u.list) {\r\nlist_del(&pos->u.list);\r\ncall_rcu_sched(&pos->u.rcu, rcu_free_old_probes);\r\n}\r\n}\r\nstatic int tracepoint_get_iter_range(struct tracepoint * const **tracepoint,\r\nstruct tracepoint * const *begin, struct tracepoint * const *end)\r\n{\r\nif (!*tracepoint && begin != end) {\r\n*tracepoint = begin;\r\nreturn 1;\r\n}\r\nif (*tracepoint >= begin && *tracepoint < end)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void tracepoint_get_iter(struct tracepoint_iter *iter)\r\n{\r\nint found = 0;\r\nstruct tp_module *iter_mod;\r\nif (!iter->module) {\r\nfound = tracepoint_get_iter_range(&iter->tracepoint,\r\n__start___tracepoints_ptrs,\r\n__stop___tracepoints_ptrs);\r\nif (found)\r\ngoto end;\r\n}\r\nmutex_lock(&tracepoints_mutex);\r\nlist_for_each_entry(iter_mod, &tracepoint_module_list, list) {\r\nif (iter_mod < iter->module)\r\ncontinue;\r\nelse if (iter_mod > iter->module)\r\niter->tracepoint = NULL;\r\nfound = tracepoint_get_iter_range(&iter->tracepoint,\r\niter_mod->tracepoints_ptrs,\r\niter_mod->tracepoints_ptrs\r\n+ iter_mod->num_tracepoints);\r\nif (found) {\r\niter->module = iter_mod;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&tracepoints_mutex);\r\nend:\r\nif (!found)\r\ntracepoint_iter_reset(iter);\r\n}\r\nstatic void tracepoint_get_iter(struct tracepoint_iter *iter)\r\n{\r\nint found = 0;\r\nfound = tracepoint_get_iter_range(&iter->tracepoint,\r\n__start___tracepoints_ptrs,\r\n__stop___tracepoints_ptrs);\r\nif (!found)\r\ntracepoint_iter_reset(iter);\r\n}\r\nvoid tracepoint_iter_start(struct tracepoint_iter *iter)\r\n{\r\ntracepoint_get_iter(iter);\r\n}\r\nvoid tracepoint_iter_next(struct tracepoint_iter *iter)\r\n{\r\niter->tracepoint++;\r\ntracepoint_get_iter(iter);\r\n}\r\nvoid tracepoint_iter_stop(struct tracepoint_iter *iter)\r\n{\r\n}\r\nvoid tracepoint_iter_reset(struct tracepoint_iter *iter)\r\n{\r\n#ifdef CONFIG_MODULES\r\niter->module = NULL;\r\n#endif\r\niter->tracepoint = NULL;\r\n}\r\nstatic int tracepoint_module_coming(struct module *mod)\r\n{\r\nstruct tp_module *tp_mod, *iter;\r\nint ret = 0;\r\nif (mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP)))\r\nreturn 0;\r\nmutex_lock(&tracepoints_mutex);\r\ntp_mod = kmalloc(sizeof(struct tp_module), GFP_KERNEL);\r\nif (!tp_mod) {\r\nret = -ENOMEM;\r\ngoto end;\r\n}\r\ntp_mod->num_tracepoints = mod->num_tracepoints;\r\ntp_mod->tracepoints_ptrs = mod->tracepoints_ptrs;\r\nlist_for_each_entry_reverse(iter, &tracepoint_module_list, list) {\r\nBUG_ON(iter == tp_mod);\r\nif (iter < tp_mod) {\r\nlist_add(&tp_mod->list, &iter->list);\r\ngoto module_added;\r\n}\r\n}\r\nlist_add(&tp_mod->list, &tracepoint_module_list);\r\nmodule_added:\r\ntracepoint_update_probe_range(mod->tracepoints_ptrs,\r\nmod->tracepoints_ptrs + mod->num_tracepoints);\r\nend:\r\nmutex_unlock(&tracepoints_mutex);\r\nreturn ret;\r\n}\r\nstatic int tracepoint_module_going(struct module *mod)\r\n{\r\nstruct tp_module *pos;\r\nmutex_lock(&tracepoints_mutex);\r\ntracepoint_update_probe_range(mod->tracepoints_ptrs,\r\nmod->tracepoints_ptrs + mod->num_tracepoints);\r\nlist_for_each_entry(pos, &tracepoint_module_list, list) {\r\nif (pos->tracepoints_ptrs == mod->tracepoints_ptrs) {\r\nlist_del(&pos->list);\r\nkfree(pos);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&tracepoints_mutex);\r\nreturn 0;\r\n}\r\nint tracepoint_module_notify(struct notifier_block *self,\r\nunsigned long val, void *data)\r\n{\r\nstruct module *mod = data;\r\nint ret = 0;\r\nswitch (val) {\r\ncase MODULE_STATE_COMING:\r\nret = tracepoint_module_coming(mod);\r\nbreak;\r\ncase MODULE_STATE_LIVE:\r\nbreak;\r\ncase MODULE_STATE_GOING:\r\nret = tracepoint_module_going(mod);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int init_tracepoints(void)\r\n{\r\nreturn register_module_notifier(&tracepoint_module_nb);\r\n}\r\nvoid syscall_regfunc(void)\r\n{\r\nunsigned long flags;\r\nstruct task_struct *g, *t;\r\nif (!sys_tracepoint_refcount) {\r\nread_lock_irqsave(&tasklist_lock, flags);\r\ndo_each_thread(g, t) {\r\nif (t->mm)\r\nset_tsk_thread_flag(t, TIF_SYSCALL_TRACEPOINT);\r\n} while_each_thread(g, t);\r\nread_unlock_irqrestore(&tasklist_lock, flags);\r\n}\r\nsys_tracepoint_refcount++;\r\n}\r\nvoid syscall_unregfunc(void)\r\n{\r\nunsigned long flags;\r\nstruct task_struct *g, *t;\r\nsys_tracepoint_refcount--;\r\nif (!sys_tracepoint_refcount) {\r\nread_lock_irqsave(&tasklist_lock, flags);\r\ndo_each_thread(g, t) {\r\nclear_tsk_thread_flag(t, TIF_SYSCALL_TRACEPOINT);\r\n} while_each_thread(g, t);\r\nread_unlock_irqrestore(&tasklist_lock, flags);\r\n}\r\n}
