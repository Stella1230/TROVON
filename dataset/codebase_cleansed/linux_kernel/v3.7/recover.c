int dlm_wait_function(struct dlm_ls *ls, int (*testfn) (struct dlm_ls *ls))\r\n{\r\nint error = 0;\r\nint rv;\r\nwhile (1) {\r\nrv = wait_event_timeout(ls->ls_wait_general,\r\ntestfn(ls) || dlm_recovery_stopped(ls),\r\ndlm_config.ci_recover_timer * HZ);\r\nif (rv)\r\nbreak;\r\n}\r\nif (dlm_recovery_stopped(ls)) {\r\nlog_debug(ls, "dlm_wait_function aborted");\r\nerror = -EINTR;\r\n}\r\nreturn error;\r\n}\r\nuint32_t dlm_recover_status(struct dlm_ls *ls)\r\n{\r\nuint32_t status;\r\nspin_lock(&ls->ls_recover_lock);\r\nstatus = ls->ls_recover_status;\r\nspin_unlock(&ls->ls_recover_lock);\r\nreturn status;\r\n}\r\nstatic void _set_recover_status(struct dlm_ls *ls, uint32_t status)\r\n{\r\nls->ls_recover_status |= status;\r\n}\r\nvoid dlm_set_recover_status(struct dlm_ls *ls, uint32_t status)\r\n{\r\nspin_lock(&ls->ls_recover_lock);\r\n_set_recover_status(ls, status);\r\nspin_unlock(&ls->ls_recover_lock);\r\n}\r\nstatic int wait_status_all(struct dlm_ls *ls, uint32_t wait_status,\r\nint save_slots)\r\n{\r\nstruct dlm_rcom *rc = ls->ls_recover_buf;\r\nstruct dlm_member *memb;\r\nint error = 0, delay;\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\ndelay = 0;\r\nfor (;;) {\r\nif (dlm_recovery_stopped(ls)) {\r\nerror = -EINTR;\r\ngoto out;\r\n}\r\nerror = dlm_rcom_status(ls, memb->nodeid, 0);\r\nif (error)\r\ngoto out;\r\nif (save_slots)\r\ndlm_slot_save(ls, rc, memb);\r\nif (rc->rc_result & wait_status)\r\nbreak;\r\nif (delay < 1000)\r\ndelay += 20;\r\nmsleep(delay);\r\n}\r\n}\r\nout:\r\nreturn error;\r\n}\r\nstatic int wait_status_low(struct dlm_ls *ls, uint32_t wait_status,\r\nuint32_t status_flags)\r\n{\r\nstruct dlm_rcom *rc = ls->ls_recover_buf;\r\nint error = 0, delay = 0, nodeid = ls->ls_low_nodeid;\r\nfor (;;) {\r\nif (dlm_recovery_stopped(ls)) {\r\nerror = -EINTR;\r\ngoto out;\r\n}\r\nerror = dlm_rcom_status(ls, nodeid, status_flags);\r\nif (error)\r\nbreak;\r\nif (rc->rc_result & wait_status)\r\nbreak;\r\nif (delay < 1000)\r\ndelay += 20;\r\nmsleep(delay);\r\n}\r\nout:\r\nreturn error;\r\n}\r\nstatic int wait_status(struct dlm_ls *ls, uint32_t status)\r\n{\r\nuint32_t status_all = status << 1;\r\nint error;\r\nif (ls->ls_low_nodeid == dlm_our_nodeid()) {\r\nerror = wait_status_all(ls, status, 0);\r\nif (!error)\r\ndlm_set_recover_status(ls, status_all);\r\n} else\r\nerror = wait_status_low(ls, status_all, 0);\r\nreturn error;\r\n}\r\nint dlm_recover_members_wait(struct dlm_ls *ls)\r\n{\r\nstruct dlm_member *memb;\r\nstruct dlm_slot *slots;\r\nint num_slots, slots_size;\r\nint error, rv;\r\nuint32_t gen;\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nmemb->slot = -1;\r\nmemb->generation = 0;\r\n}\r\nif (ls->ls_low_nodeid == dlm_our_nodeid()) {\r\nerror = wait_status_all(ls, DLM_RS_NODES, 1);\r\nif (error)\r\ngoto out;\r\nrv = dlm_slots_assign(ls, &num_slots, &slots_size, &slots, &gen);\r\nif (!rv) {\r\nspin_lock(&ls->ls_recover_lock);\r\n_set_recover_status(ls, DLM_RS_NODES_ALL);\r\nls->ls_num_slots = num_slots;\r\nls->ls_slots_size = slots_size;\r\nls->ls_slots = slots;\r\nls->ls_generation = gen;\r\nspin_unlock(&ls->ls_recover_lock);\r\n} else {\r\ndlm_set_recover_status(ls, DLM_RS_NODES_ALL);\r\n}\r\n} else {\r\nerror = wait_status_low(ls, DLM_RS_NODES_ALL, DLM_RSF_NEED_SLOTS);\r\nif (error)\r\ngoto out;\r\ndlm_slots_copy_in(ls);\r\n}\r\nout:\r\nreturn error;\r\n}\r\nint dlm_recover_directory_wait(struct dlm_ls *ls)\r\n{\r\nreturn wait_status(ls, DLM_RS_DIR);\r\n}\r\nint dlm_recover_locks_wait(struct dlm_ls *ls)\r\n{\r\nreturn wait_status(ls, DLM_RS_LOCKS);\r\n}\r\nint dlm_recover_done_wait(struct dlm_ls *ls)\r\n{\r\nreturn wait_status(ls, DLM_RS_DONE);\r\n}\r\nstatic int recover_list_empty(struct dlm_ls *ls)\r\n{\r\nint empty;\r\nspin_lock(&ls->ls_recover_list_lock);\r\nempty = list_empty(&ls->ls_recover_list);\r\nspin_unlock(&ls->ls_recover_list_lock);\r\nreturn empty;\r\n}\r\nstatic void recover_list_add(struct dlm_rsb *r)\r\n{\r\nstruct dlm_ls *ls = r->res_ls;\r\nspin_lock(&ls->ls_recover_list_lock);\r\nif (list_empty(&r->res_recover_list)) {\r\nlist_add_tail(&r->res_recover_list, &ls->ls_recover_list);\r\nls->ls_recover_list_count++;\r\ndlm_hold_rsb(r);\r\n}\r\nspin_unlock(&ls->ls_recover_list_lock);\r\n}\r\nstatic void recover_list_del(struct dlm_rsb *r)\r\n{\r\nstruct dlm_ls *ls = r->res_ls;\r\nspin_lock(&ls->ls_recover_list_lock);\r\nlist_del_init(&r->res_recover_list);\r\nls->ls_recover_list_count--;\r\nspin_unlock(&ls->ls_recover_list_lock);\r\ndlm_put_rsb(r);\r\n}\r\nstatic void recover_list_clear(struct dlm_ls *ls)\r\n{\r\nstruct dlm_rsb *r, *s;\r\nspin_lock(&ls->ls_recover_list_lock);\r\nlist_for_each_entry_safe(r, s, &ls->ls_recover_list, res_recover_list) {\r\nlist_del_init(&r->res_recover_list);\r\nr->res_recover_locks_count = 0;\r\ndlm_put_rsb(r);\r\nls->ls_recover_list_count--;\r\n}\r\nif (ls->ls_recover_list_count != 0) {\r\nlog_error(ls, "warning: recover_list_count %d",\r\nls->ls_recover_list_count);\r\nls->ls_recover_list_count = 0;\r\n}\r\nspin_unlock(&ls->ls_recover_list_lock);\r\n}\r\nstatic int recover_idr_empty(struct dlm_ls *ls)\r\n{\r\nint empty = 1;\r\nspin_lock(&ls->ls_recover_idr_lock);\r\nif (ls->ls_recover_list_count)\r\nempty = 0;\r\nspin_unlock(&ls->ls_recover_idr_lock);\r\nreturn empty;\r\n}\r\nstatic int recover_idr_add(struct dlm_rsb *r)\r\n{\r\nstruct dlm_ls *ls = r->res_ls;\r\nint rv, id;\r\nrv = idr_pre_get(&ls->ls_recover_idr, GFP_NOFS);\r\nif (!rv)\r\nreturn -ENOMEM;\r\nspin_lock(&ls->ls_recover_idr_lock);\r\nif (r->res_id) {\r\nspin_unlock(&ls->ls_recover_idr_lock);\r\nreturn -1;\r\n}\r\nrv = idr_get_new_above(&ls->ls_recover_idr, r, 1, &id);\r\nif (rv) {\r\nspin_unlock(&ls->ls_recover_idr_lock);\r\nreturn rv;\r\n}\r\nr->res_id = id;\r\nls->ls_recover_list_count++;\r\ndlm_hold_rsb(r);\r\nspin_unlock(&ls->ls_recover_idr_lock);\r\nreturn 0;\r\n}\r\nstatic void recover_idr_del(struct dlm_rsb *r)\r\n{\r\nstruct dlm_ls *ls = r->res_ls;\r\nspin_lock(&ls->ls_recover_idr_lock);\r\nidr_remove(&ls->ls_recover_idr, r->res_id);\r\nr->res_id = 0;\r\nls->ls_recover_list_count--;\r\nspin_unlock(&ls->ls_recover_idr_lock);\r\ndlm_put_rsb(r);\r\n}\r\nstatic struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)\r\n{\r\nstruct dlm_rsb *r;\r\nspin_lock(&ls->ls_recover_idr_lock);\r\nr = idr_find(&ls->ls_recover_idr, (int)id);\r\nspin_unlock(&ls->ls_recover_idr_lock);\r\nreturn r;\r\n}\r\nstatic int recover_idr_clear_rsb(int id, void *p, void *data)\r\n{\r\nstruct dlm_ls *ls = data;\r\nstruct dlm_rsb *r = p;\r\nr->res_id = 0;\r\nr->res_recover_locks_count = 0;\r\nls->ls_recover_list_count--;\r\ndlm_put_rsb(r);\r\nreturn 0;\r\n}\r\nstatic void recover_idr_clear(struct dlm_ls *ls)\r\n{\r\nspin_lock(&ls->ls_recover_idr_lock);\r\nidr_for_each(&ls->ls_recover_idr, recover_idr_clear_rsb, ls);\r\nidr_remove_all(&ls->ls_recover_idr);\r\nif (ls->ls_recover_list_count != 0) {\r\nlog_error(ls, "warning: recover_list_count %d",\r\nls->ls_recover_list_count);\r\nls->ls_recover_list_count = 0;\r\n}\r\nspin_unlock(&ls->ls_recover_idr_lock);\r\n}\r\nstatic void set_lock_master(struct list_head *queue, int nodeid)\r\n{\r\nstruct dlm_lkb *lkb;\r\nlist_for_each_entry(lkb, queue, lkb_statequeue) {\r\nif (!(lkb->lkb_flags & DLM_IFL_MSTCPY)) {\r\nlkb->lkb_nodeid = nodeid;\r\nlkb->lkb_remid = 0;\r\n}\r\n}\r\n}\r\nstatic void set_master_lkbs(struct dlm_rsb *r)\r\n{\r\nset_lock_master(&r->res_grantqueue, r->res_nodeid);\r\nset_lock_master(&r->res_convertqueue, r->res_nodeid);\r\nset_lock_master(&r->res_waitqueue, r->res_nodeid);\r\n}\r\nstatic void set_new_master(struct dlm_rsb *r)\r\n{\r\nset_master_lkbs(r);\r\nrsb_set_flag(r, RSB_NEW_MASTER);\r\nrsb_set_flag(r, RSB_NEW_MASTER2);\r\n}\r\nstatic int recover_master(struct dlm_rsb *r, unsigned int *count)\r\n{\r\nstruct dlm_ls *ls = r->res_ls;\r\nint our_nodeid, dir_nodeid;\r\nint is_removed = 0;\r\nint error;\r\nif (is_master(r))\r\nreturn 0;\r\nis_removed = dlm_is_removed(ls, r->res_nodeid);\r\nif (!is_removed && !rsb_flag(r, RSB_NEW_MASTER))\r\nreturn 0;\r\nour_nodeid = dlm_our_nodeid();\r\ndir_nodeid = dlm_dir_nodeid(r);\r\nif (dir_nodeid == our_nodeid) {\r\nif (is_removed) {\r\nr->res_master_nodeid = our_nodeid;\r\nr->res_nodeid = 0;\r\n}\r\nset_new_master(r);\r\nerror = 0;\r\n} else {\r\nrecover_idr_add(r);\r\nerror = dlm_send_rcom_lookup(r, dir_nodeid);\r\n}\r\n(*count)++;\r\nreturn error;\r\n}\r\nstatic int recover_master_static(struct dlm_rsb *r, unsigned int *count)\r\n{\r\nint dir_nodeid = dlm_dir_nodeid(r);\r\nint new_master = dir_nodeid;\r\nif (dir_nodeid == dlm_our_nodeid())\r\nnew_master = 0;\r\ndlm_purge_mstcpy_locks(r);\r\nr->res_master_nodeid = dir_nodeid;\r\nr->res_nodeid = new_master;\r\nset_new_master(r);\r\n(*count)++;\r\nreturn 0;\r\n}\r\nint dlm_recover_masters(struct dlm_ls *ls)\r\n{\r\nstruct dlm_rsb *r;\r\nunsigned int total = 0;\r\nunsigned int count = 0;\r\nint nodir = dlm_no_directory(ls);\r\nint error;\r\nlog_debug(ls, "dlm_recover_masters");\r\ndown_read(&ls->ls_root_sem);\r\nlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\r\nif (dlm_recovery_stopped(ls)) {\r\nup_read(&ls->ls_root_sem);\r\nerror = -EINTR;\r\ngoto out;\r\n}\r\nlock_rsb(r);\r\nif (nodir)\r\nerror = recover_master_static(r, &count);\r\nelse\r\nerror = recover_master(r, &count);\r\nunlock_rsb(r);\r\ncond_resched();\r\ntotal++;\r\nif (error) {\r\nup_read(&ls->ls_root_sem);\r\ngoto out;\r\n}\r\n}\r\nup_read(&ls->ls_root_sem);\r\nlog_debug(ls, "dlm_recover_masters %u of %u", count, total);\r\nerror = dlm_wait_function(ls, &recover_idr_empty);\r\nout:\r\nif (error)\r\nrecover_idr_clear(ls);\r\nreturn error;\r\n}\r\nint dlm_recover_master_reply(struct dlm_ls *ls, struct dlm_rcom *rc)\r\n{\r\nstruct dlm_rsb *r;\r\nint ret_nodeid, new_master;\r\nr = recover_idr_find(ls, rc->rc_id);\r\nif (!r) {\r\nlog_error(ls, "dlm_recover_master_reply no id %llx",\r\n(unsigned long long)rc->rc_id);\r\ngoto out;\r\n}\r\nret_nodeid = rc->rc_result;\r\nif (ret_nodeid == dlm_our_nodeid())\r\nnew_master = 0;\r\nelse\r\nnew_master = ret_nodeid;\r\nlock_rsb(r);\r\nr->res_master_nodeid = ret_nodeid;\r\nr->res_nodeid = new_master;\r\nset_new_master(r);\r\nunlock_rsb(r);\r\nrecover_idr_del(r);\r\nif (recover_idr_empty(ls))\r\nwake_up(&ls->ls_wait_general);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int recover_locks_queue(struct dlm_rsb *r, struct list_head *head)\r\n{\r\nstruct dlm_lkb *lkb;\r\nint error = 0;\r\nlist_for_each_entry(lkb, head, lkb_statequeue) {\r\nerror = dlm_send_rcom_lock(r, lkb);\r\nif (error)\r\nbreak;\r\nr->res_recover_locks_count++;\r\n}\r\nreturn error;\r\n}\r\nstatic int recover_locks(struct dlm_rsb *r)\r\n{\r\nint error = 0;\r\nlock_rsb(r);\r\nDLM_ASSERT(!r->res_recover_locks_count, dlm_dump_rsb(r););\r\nerror = recover_locks_queue(r, &r->res_grantqueue);\r\nif (error)\r\ngoto out;\r\nerror = recover_locks_queue(r, &r->res_convertqueue);\r\nif (error)\r\ngoto out;\r\nerror = recover_locks_queue(r, &r->res_waitqueue);\r\nif (error)\r\ngoto out;\r\nif (r->res_recover_locks_count)\r\nrecover_list_add(r);\r\nelse\r\nrsb_clear_flag(r, RSB_NEW_MASTER);\r\nout:\r\nunlock_rsb(r);\r\nreturn error;\r\n}\r\nint dlm_recover_locks(struct dlm_ls *ls)\r\n{\r\nstruct dlm_rsb *r;\r\nint error, count = 0;\r\ndown_read(&ls->ls_root_sem);\r\nlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\r\nif (is_master(r)) {\r\nrsb_clear_flag(r, RSB_NEW_MASTER);\r\ncontinue;\r\n}\r\nif (!rsb_flag(r, RSB_NEW_MASTER))\r\ncontinue;\r\nif (dlm_recovery_stopped(ls)) {\r\nerror = -EINTR;\r\nup_read(&ls->ls_root_sem);\r\ngoto out;\r\n}\r\nerror = recover_locks(r);\r\nif (error) {\r\nup_read(&ls->ls_root_sem);\r\ngoto out;\r\n}\r\ncount += r->res_recover_locks_count;\r\n}\r\nup_read(&ls->ls_root_sem);\r\nlog_debug(ls, "dlm_recover_locks %d out", count);\r\nerror = dlm_wait_function(ls, &recover_list_empty);\r\nout:\r\nif (error)\r\nrecover_list_clear(ls);\r\nreturn error;\r\n}\r\nvoid dlm_recovered_lock(struct dlm_rsb *r)\r\n{\r\nDLM_ASSERT(rsb_flag(r, RSB_NEW_MASTER), dlm_dump_rsb(r););\r\nr->res_recover_locks_count--;\r\nif (!r->res_recover_locks_count) {\r\nrsb_clear_flag(r, RSB_NEW_MASTER);\r\nrecover_list_del(r);\r\n}\r\nif (recover_list_empty(r->res_ls))\r\nwake_up(&r->res_ls->ls_wait_general);\r\n}\r\nstatic void recover_lvb(struct dlm_rsb *r)\r\n{\r\nstruct dlm_lkb *lkb, *high_lkb = NULL;\r\nuint32_t high_seq = 0;\r\nint lock_lvb_exists = 0;\r\nint big_lock_exists = 0;\r\nint lvblen = r->res_ls->ls_lvblen;\r\nlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\r\nif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\r\ncontinue;\r\nlock_lvb_exists = 1;\r\nif (lkb->lkb_grmode > DLM_LOCK_CR) {\r\nbig_lock_exists = 1;\r\ngoto setflag;\r\n}\r\nif (((int)lkb->lkb_lvbseq - (int)high_seq) >= 0) {\r\nhigh_lkb = lkb;\r\nhigh_seq = lkb->lkb_lvbseq;\r\n}\r\n}\r\nlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\r\nif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\r\ncontinue;\r\nlock_lvb_exists = 1;\r\nif (lkb->lkb_grmode > DLM_LOCK_CR) {\r\nbig_lock_exists = 1;\r\ngoto setflag;\r\n}\r\nif (((int)lkb->lkb_lvbseq - (int)high_seq) >= 0) {\r\nhigh_lkb = lkb;\r\nhigh_seq = lkb->lkb_lvbseq;\r\n}\r\n}\r\nsetflag:\r\nif (!lock_lvb_exists)\r\ngoto out;\r\nif (!big_lock_exists)\r\nrsb_set_flag(r, RSB_VALNOTVALID);\r\nif (!rsb_flag(r, RSB_NEW_MASTER2))\r\ngoto out;\r\nif (!r->res_lvbptr) {\r\nr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\r\nif (!r->res_lvbptr)\r\ngoto out;\r\n}\r\nif (big_lock_exists) {\r\nr->res_lvbseq = lkb->lkb_lvbseq;\r\nmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, lvblen);\r\n} else if (high_lkb) {\r\nr->res_lvbseq = high_lkb->lkb_lvbseq;\r\nmemcpy(r->res_lvbptr, high_lkb->lkb_lvbptr, lvblen);\r\n} else {\r\nr->res_lvbseq = 0;\r\nmemset(r->res_lvbptr, 0, lvblen);\r\n}\r\nout:\r\nreturn;\r\n}\r\nstatic void recover_conversion(struct dlm_rsb *r)\r\n{\r\nstruct dlm_ls *ls = r->res_ls;\r\nstruct dlm_lkb *lkb;\r\nint grmode = -1;\r\nlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\r\nif (lkb->lkb_grmode == DLM_LOCK_PR ||\r\nlkb->lkb_grmode == DLM_LOCK_CW) {\r\ngrmode = lkb->lkb_grmode;\r\nbreak;\r\n}\r\n}\r\nlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\r\nif (lkb->lkb_grmode != DLM_LOCK_IV)\r\ncontinue;\r\nif (grmode == -1) {\r\nlog_debug(ls, "recover_conversion %x set gr to rq %d",\r\nlkb->lkb_id, lkb->lkb_rqmode);\r\nlkb->lkb_grmode = lkb->lkb_rqmode;\r\n} else {\r\nlog_debug(ls, "recover_conversion %x set gr %d",\r\nlkb->lkb_id, grmode);\r\nlkb->lkb_grmode = grmode;\r\n}\r\n}\r\n}\r\nstatic void recover_grant(struct dlm_rsb *r)\r\n{\r\nif (!list_empty(&r->res_waitqueue) || !list_empty(&r->res_convertqueue))\r\nrsb_set_flag(r, RSB_RECOVER_GRANT);\r\n}\r\nvoid dlm_recover_rsbs(struct dlm_ls *ls)\r\n{\r\nstruct dlm_rsb *r;\r\nunsigned int count = 0;\r\ndown_read(&ls->ls_root_sem);\r\nlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\r\nlock_rsb(r);\r\nif (is_master(r)) {\r\nif (rsb_flag(r, RSB_RECOVER_CONVERT))\r\nrecover_conversion(r);\r\nif (rsb_flag(r, RSB_NEW_MASTER2))\r\nrecover_grant(r);\r\nrecover_lvb(r);\r\ncount++;\r\n}\r\nrsb_clear_flag(r, RSB_RECOVER_CONVERT);\r\nrsb_clear_flag(r, RSB_NEW_MASTER2);\r\nunlock_rsb(r);\r\n}\r\nup_read(&ls->ls_root_sem);\r\nif (count)\r\nlog_debug(ls, "dlm_recover_rsbs %d done", count);\r\n}\r\nint dlm_create_root_list(struct dlm_ls *ls)\r\n{\r\nstruct rb_node *n;\r\nstruct dlm_rsb *r;\r\nint i, error = 0;\r\ndown_write(&ls->ls_root_sem);\r\nif (!list_empty(&ls->ls_root_list)) {\r\nlog_error(ls, "root list not empty");\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\r\nspin_lock(&ls->ls_rsbtbl[i].lock);\r\nfor (n = rb_first(&ls->ls_rsbtbl[i].keep); n; n = rb_next(n)) {\r\nr = rb_entry(n, struct dlm_rsb, res_hashnode);\r\nlist_add(&r->res_root_list, &ls->ls_root_list);\r\ndlm_hold_rsb(r);\r\n}\r\nif (!RB_EMPTY_ROOT(&ls->ls_rsbtbl[i].toss))\r\nlog_error(ls, "dlm_create_root_list toss not empty");\r\nspin_unlock(&ls->ls_rsbtbl[i].lock);\r\n}\r\nout:\r\nup_write(&ls->ls_root_sem);\r\nreturn error;\r\n}\r\nvoid dlm_release_root_list(struct dlm_ls *ls)\r\n{\r\nstruct dlm_rsb *r, *safe;\r\ndown_write(&ls->ls_root_sem);\r\nlist_for_each_entry_safe(r, safe, &ls->ls_root_list, res_root_list) {\r\nlist_del_init(&r->res_root_list);\r\ndlm_put_rsb(r);\r\n}\r\nup_write(&ls->ls_root_sem);\r\n}\r\nvoid dlm_clear_toss(struct dlm_ls *ls)\r\n{\r\nstruct rb_node *n, *next;\r\nstruct dlm_rsb *r;\r\nunsigned int count = 0;\r\nint i;\r\nfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\r\nspin_lock(&ls->ls_rsbtbl[i].lock);\r\nfor (n = rb_first(&ls->ls_rsbtbl[i].toss); n; n = next) {\r\nnext = rb_next(n);\r\nr = rb_entry(n, struct dlm_rsb, res_hashnode);\r\nrb_erase(n, &ls->ls_rsbtbl[i].toss);\r\ndlm_free_rsb(r);\r\ncount++;\r\n}\r\nspin_unlock(&ls->ls_rsbtbl[i].lock);\r\n}\r\nif (count)\r\nlog_debug(ls, "dlm_clear_toss %u done", count);\r\n}
