void * __devinit update_dn_pci_info(struct device_node *dn, void *data)\r\n{\r\nstruct pci_controller *phb = data;\r\nconst int *type =\r\nof_get_property(dn, "ibm,pci-config-space-type", NULL);\r\nconst u32 *regs;\r\nstruct pci_dn *pdn;\r\npdn = zalloc_maybe_bootmem(sizeof(*pdn), GFP_KERNEL);\r\nif (pdn == NULL)\r\nreturn NULL;\r\ndn->data = pdn;\r\npdn->node = dn;\r\npdn->phb = phb;\r\n#ifdef CONFIG_PPC_POWERNV\r\npdn->pe_number = IODA_INVALID_PE;\r\n#endif\r\nregs = of_get_property(dn, "reg", NULL);\r\nif (regs) {\r\npdn->busno = (regs[0] >> 16) & 0xff;\r\npdn->devfn = (regs[0] >> 8) & 0xff;\r\n}\r\npdn->pci_ext_config_space = (type && *type == 1);\r\nreturn NULL;\r\n}\r\nvoid *traverse_pci_devices(struct device_node *start, traverse_func pre,\r\nvoid *data)\r\n{\r\nstruct device_node *dn, *nextdn;\r\nvoid *ret;\r\nfor (dn = start->child; dn; dn = nextdn) {\r\nconst u32 *classp;\r\nu32 class;\r\nnextdn = NULL;\r\nclassp = of_get_property(dn, "class-code", NULL);\r\nclass = classp ? *classp : 0;\r\nif (pre && ((ret = pre(dn, data)) != NULL))\r\nreturn ret;\r\nif (dn->child && ((class >> 8) == PCI_CLASS_BRIDGE_PCI ||\r\n(class >> 8) == PCI_CLASS_BRIDGE_CARDBUS))\r\nnextdn = dn->child;\r\nelse if (dn->sibling)\r\nnextdn = dn->sibling;\r\nif (!nextdn) {\r\ndo {\r\ndn = dn->parent;\r\nif (dn == start)\r\nreturn NULL;\r\n} while (dn->sibling == NULL);\r\nnextdn = dn->sibling;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid __devinit pci_devs_phb_init_dynamic(struct pci_controller *phb)\r\n{\r\nstruct device_node *dn = phb->dn;\r\nstruct pci_dn *pdn;\r\nupdate_dn_pci_info(dn, phb);\r\npdn = dn->data;\r\nif (pdn) {\r\npdn->devfn = pdn->busno = -1;\r\npdn->phb = phb;\r\n}\r\ntraverse_pci_devices(dn, update_dn_pci_info, phb);\r\n}\r\nvoid __init pci_devs_phb_init(void)\r\n{\r\nstruct pci_controller *phb, *tmp;\r\nlist_for_each_entry_safe(phb, tmp, &hose_list, list_node)\r\npci_devs_phb_init_dynamic(phb);\r\n}
