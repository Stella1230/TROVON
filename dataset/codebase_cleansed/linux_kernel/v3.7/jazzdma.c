static inline void vdma_pgtbl_init(void)\r\n{\r\nunsigned long paddr = 0;\r\nint i;\r\nfor (i = 0; i < VDMA_PGTBL_ENTRIES; i++) {\r\npgtbl[i].frame = paddr;\r\npgtbl[i].owner = VDMA_PAGE_EMPTY;\r\npaddr += VDMA_PAGESIZE;\r\n}\r\n}\r\nstatic int __init vdma_init(void)\r\n{\r\npgtbl = (VDMA_PGTBL_ENTRY *)__get_free_pages(GFP_KERNEL | GFP_DMA,\r\nget_order(VDMA_PGTBL_SIZE));\r\nBUG_ON(!pgtbl);\r\ndma_cache_wback_inv((unsigned long)pgtbl, VDMA_PGTBL_SIZE);\r\npgtbl = (VDMA_PGTBL_ENTRY *)KSEG1ADDR(pgtbl);\r\nvdma_pgtbl_init();\r\nr4030_write_reg32(JAZZ_R4030_TRSTBL_BASE, CPHYSADDR(pgtbl));\r\nr4030_write_reg32(JAZZ_R4030_TRSTBL_LIM, VDMA_PGTBL_SIZE);\r\nr4030_write_reg32(JAZZ_R4030_TRSTBL_INV, 0);\r\nprintk(KERN_INFO "VDMA: R4030 DMA pagetables initialized.\n");\r\nreturn 0;\r\n}\r\nunsigned long vdma_alloc(unsigned long paddr, unsigned long size)\r\n{\r\nint first, last, pages, frame, i;\r\nunsigned long laddr, flags;\r\nif (paddr > 0x1fffffff) {\r\nif (vdma_debug)\r\nprintk("vdma_alloc: Invalid physical address: %08lx\n",\r\npaddr);\r\nreturn VDMA_ERROR;\r\n}\r\nif (size > 0x400000 || size == 0) {\r\nif (vdma_debug)\r\nprintk("vdma_alloc: Invalid size: %08lx\n", size);\r\nreturn VDMA_ERROR;\r\n}\r\nspin_lock_irqsave(&vdma_lock, flags);\r\npages = VDMA_PAGE(paddr + size) - VDMA_PAGE(paddr) + 1;\r\nfirst = 0;\r\nwhile (1) {\r\nwhile (pgtbl[first].owner != VDMA_PAGE_EMPTY &&\r\nfirst < VDMA_PGTBL_ENTRIES) first++;\r\nif (first + pages > VDMA_PGTBL_ENTRIES) {\r\nspin_unlock_irqrestore(&vdma_lock, flags);\r\nreturn VDMA_ERROR;\r\n}\r\nlast = first + 1;\r\nwhile (pgtbl[last].owner == VDMA_PAGE_EMPTY\r\n&& last - first < pages)\r\nlast++;\r\nif (last - first == pages)\r\nbreak;\r\nfirst = last + 1;\r\n}\r\nladdr = (first << 12) + (paddr & (VDMA_PAGESIZE - 1));\r\nframe = paddr & ~(VDMA_PAGESIZE - 1);\r\nfor (i = first; i < last; i++) {\r\npgtbl[i].frame = frame;\r\npgtbl[i].owner = laddr;\r\nframe += VDMA_PAGESIZE;\r\n}\r\nr4030_write_reg32(JAZZ_R4030_TRSTBL_INV, 0);\r\nif (vdma_debug > 1)\r\nprintk("vdma_alloc: Allocated %d pages starting from %08lx\n",\r\npages, laddr);\r\nif (vdma_debug > 2) {\r\nprintk("LADDR: ");\r\nfor (i = first; i < last; i++)\r\nprintk("%08x ", i << 12);\r\nprintk("\nPADDR: ");\r\nfor (i = first; i < last; i++)\r\nprintk("%08x ", pgtbl[i].frame);\r\nprintk("\nOWNER: ");\r\nfor (i = first; i < last; i++)\r\nprintk("%08x ", pgtbl[i].owner);\r\nprintk("\n");\r\n}\r\nspin_unlock_irqrestore(&vdma_lock, flags);\r\nreturn laddr;\r\n}\r\nint vdma_free(unsigned long laddr)\r\n{\r\nint i;\r\ni = laddr >> 12;\r\nif (pgtbl[i].owner != laddr) {\r\nprintk\r\n("vdma_free: trying to free other's dma pages, laddr=%8lx\n",\r\nladdr);\r\nreturn -1;\r\n}\r\nwhile (i < VDMA_PGTBL_ENTRIES && pgtbl[i].owner == laddr) {\r\npgtbl[i].owner = VDMA_PAGE_EMPTY;\r\ni++;\r\n}\r\nif (vdma_debug > 1)\r\nprintk("vdma_free: freed %ld pages starting from %08lx\n",\r\ni - (laddr >> 12), laddr);\r\nreturn 0;\r\n}\r\nint vdma_remap(unsigned long laddr, unsigned long paddr, unsigned long size)\r\n{\r\nint first, pages;\r\nif (laddr > 0xffffff) {\r\nif (vdma_debug)\r\nprintk\r\n("vdma_map: Invalid logical address: %08lx\n",\r\nladdr);\r\nreturn -EINVAL;\r\n}\r\nif (paddr > 0x1fffffff) {\r\nif (vdma_debug)\r\nprintk\r\n("vdma_map: Invalid physical address: %08lx\n",\r\npaddr);\r\nreturn -EINVAL;\r\n}\r\npages = (((paddr & (VDMA_PAGESIZE - 1)) + size) >> 12) + 1;\r\nfirst = laddr >> 12;\r\nif (vdma_debug)\r\nprintk("vdma_remap: first=%x, pages=%x\n", first, pages);\r\nif (first + pages > VDMA_PGTBL_ENTRIES) {\r\nif (vdma_debug)\r\nprintk("vdma_alloc: Invalid size: %08lx\n", size);\r\nreturn -EINVAL;\r\n}\r\npaddr &= ~(VDMA_PAGESIZE - 1);\r\nwhile (pages > 0 && first < VDMA_PGTBL_ENTRIES) {\r\nif (pgtbl[first].owner != laddr) {\r\nif (vdma_debug)\r\nprintk("Trying to remap other's pages.\n");\r\nreturn -EPERM;\r\n}\r\npgtbl[first].frame = paddr;\r\npaddr += VDMA_PAGESIZE;\r\nfirst++;\r\npages--;\r\n}\r\nr4030_write_reg32(JAZZ_R4030_TRSTBL_INV, 0);\r\nif (vdma_debug > 2) {\r\nint i;\r\npages = (((paddr & (VDMA_PAGESIZE - 1)) + size) >> 12) + 1;\r\nfirst = laddr >> 12;\r\nprintk("LADDR: ");\r\nfor (i = first; i < first + pages; i++)\r\nprintk("%08x ", i << 12);\r\nprintk("\nPADDR: ");\r\nfor (i = first; i < first + pages; i++)\r\nprintk("%08x ", pgtbl[i].frame);\r\nprintk("\nOWNER: ");\r\nfor (i = first; i < first + pages; i++)\r\nprintk("%08x ", pgtbl[i].owner);\r\nprintk("\n");\r\n}\r\nreturn 0;\r\n}\r\nunsigned long vdma_phys2log(unsigned long paddr)\r\n{\r\nint i;\r\nint frame;\r\nframe = paddr & ~(VDMA_PAGESIZE - 1);\r\nfor (i = 0; i < VDMA_PGTBL_ENTRIES; i++) {\r\nif (pgtbl[i].frame == frame)\r\nbreak;\r\n}\r\nif (i == VDMA_PGTBL_ENTRIES)\r\nreturn ~0UL;\r\nreturn (i << 12) + (paddr & (VDMA_PAGESIZE - 1));\r\n}\r\nunsigned long vdma_log2phys(unsigned long laddr)\r\n{\r\nreturn pgtbl[laddr >> 12].frame + (laddr & (VDMA_PAGESIZE - 1));\r\n}\r\nvoid vdma_stats(void)\r\n{\r\nint i;\r\nprintk("vdma_stats: CONFIG: %08x\n",\r\nr4030_read_reg32(JAZZ_R4030_CONFIG));\r\nprintk("R4030 translation table base: %08x\n",\r\nr4030_read_reg32(JAZZ_R4030_TRSTBL_BASE));\r\nprintk("R4030 translation table limit: %08x\n",\r\nr4030_read_reg32(JAZZ_R4030_TRSTBL_LIM));\r\nprintk("vdma_stats: INV_ADDR: %08x\n",\r\nr4030_read_reg32(JAZZ_R4030_INV_ADDR));\r\nprintk("vdma_stats: R_FAIL_ADDR: %08x\n",\r\nr4030_read_reg32(JAZZ_R4030_R_FAIL_ADDR));\r\nprintk("vdma_stats: M_FAIL_ADDR: %08x\n",\r\nr4030_read_reg32(JAZZ_R4030_M_FAIL_ADDR));\r\nprintk("vdma_stats: IRQ_SOURCE: %08x\n",\r\nr4030_read_reg32(JAZZ_R4030_IRQ_SOURCE));\r\nprintk("vdma_stats: I386_ERROR: %08x\n",\r\nr4030_read_reg32(JAZZ_R4030_I386_ERROR));\r\nprintk("vdma_chnl_modes: ");\r\nfor (i = 0; i < 8; i++)\r\nprintk("%04x ",\r\n(unsigned) r4030_read_reg32(JAZZ_R4030_CHNL_MODE +\r\n(i << 5)));\r\nprintk("\n");\r\nprintk("vdma_chnl_enables: ");\r\nfor (i = 0; i < 8; i++)\r\nprintk("%04x ",\r\n(unsigned) r4030_read_reg32(JAZZ_R4030_CHNL_ENABLE +\r\n(i << 5)));\r\nprintk("\n");\r\n}\r\nvoid vdma_enable(int channel)\r\n{\r\nint status;\r\nif (vdma_debug)\r\nprintk("vdma_enable: channel %d\n", channel);\r\nstatus = r4030_read_reg32(JAZZ_R4030_CHNL_ENABLE + (channel << 5));\r\nif (status & 0x400)\r\nprintk("VDMA: Channel %d: Address error!\n", channel);\r\nif (status & 0x200)\r\nprintk("VDMA: Channel %d: Memory error!\n", channel);\r\nr4030_write_reg32(JAZZ_R4030_CHNL_ENABLE + (channel << 5),\r\nr4030_read_reg32(JAZZ_R4030_CHNL_ENABLE +\r\n(channel << 5)) | R4030_TC_INTR\r\n| R4030_MEM_INTR | R4030_ADDR_INTR);\r\nr4030_write_reg32(JAZZ_R4030_CHNL_ENABLE + (channel << 5),\r\nr4030_read_reg32(JAZZ_R4030_CHNL_ENABLE +\r\n(channel << 5)) |\r\nR4030_CHNL_ENABLE);\r\n}\r\nvoid vdma_disable(int channel)\r\n{\r\nif (vdma_debug) {\r\nint status =\r\nr4030_read_reg32(JAZZ_R4030_CHNL_ENABLE +\r\n(channel << 5));\r\nprintk("vdma_disable: channel %d\n", channel);\r\nprintk("VDMA: channel %d status: %04x (%s) mode: "\r\n"%02x addr: %06x count: %06x\n",\r\nchannel, status,\r\n((status & 0x600) ? "ERROR" : "OK"),\r\n(unsigned) r4030_read_reg32(JAZZ_R4030_CHNL_MODE +\r\n(channel << 5)),\r\n(unsigned) r4030_read_reg32(JAZZ_R4030_CHNL_ADDR +\r\n(channel << 5)),\r\n(unsigned) r4030_read_reg32(JAZZ_R4030_CHNL_COUNT +\r\n(channel << 5)));\r\n}\r\nr4030_write_reg32(JAZZ_R4030_CHNL_ENABLE + (channel << 5),\r\nr4030_read_reg32(JAZZ_R4030_CHNL_ENABLE +\r\n(channel << 5)) &\r\n~R4030_CHNL_ENABLE);\r\n*((volatile unsigned int *) JAZZ_DUMMY_DEVICE);\r\n}\r\nvoid vdma_set_mode(int channel, int mode)\r\n{\r\nif (vdma_debug)\r\nprintk("vdma_set_mode: channel %d, mode 0x%x\n", channel,\r\nmode);\r\nswitch (channel) {\r\ncase JAZZ_SCSI_DMA:\r\nr4030_write_reg32(JAZZ_R4030_CHNL_MODE + (channel << 5),\r\nR4030_MODE_INTR_EN |\r\nR4030_MODE_WIDTH_16 |\r\nR4030_MODE_ATIME_80);\r\nbreak;\r\ncase JAZZ_FLOPPY_DMA:\r\nr4030_write_reg32(JAZZ_R4030_CHNL_MODE + (channel << 5),\r\nR4030_MODE_INTR_EN |\r\nR4030_MODE_WIDTH_8 |\r\nR4030_MODE_ATIME_120);\r\nbreak;\r\ncase JAZZ_AUDIOL_DMA:\r\ncase JAZZ_AUDIOR_DMA:\r\nprintk("VDMA: Audio DMA not supported yet.\n");\r\nbreak;\r\ndefault:\r\nprintk\r\n("VDMA: vdma_set_mode() called with unsupported channel %d!\n",\r\nchannel);\r\n}\r\nswitch (mode) {\r\ncase DMA_MODE_READ:\r\nr4030_write_reg32(JAZZ_R4030_CHNL_ENABLE + (channel << 5),\r\nr4030_read_reg32(JAZZ_R4030_CHNL_ENABLE +\r\n(channel << 5)) &\r\n~R4030_CHNL_WRITE);\r\nbreak;\r\ncase DMA_MODE_WRITE:\r\nr4030_write_reg32(JAZZ_R4030_CHNL_ENABLE + (channel << 5),\r\nr4030_read_reg32(JAZZ_R4030_CHNL_ENABLE +\r\n(channel << 5)) |\r\nR4030_CHNL_WRITE);\r\nbreak;\r\ndefault:\r\nprintk\r\n("VDMA: vdma_set_mode() called with unknown dma mode 0x%x\n",\r\nmode);\r\n}\r\n}\r\nvoid vdma_set_addr(int channel, long addr)\r\n{\r\nif (vdma_debug)\r\nprintk("vdma_set_addr: channel %d, addr %lx\n", channel,\r\naddr);\r\nr4030_write_reg32(JAZZ_R4030_CHNL_ADDR + (channel << 5), addr);\r\n}\r\nvoid vdma_set_count(int channel, int count)\r\n{\r\nif (vdma_debug)\r\nprintk("vdma_set_count: channel %d, count %08x\n", channel,\r\n(unsigned) count);\r\nr4030_write_reg32(JAZZ_R4030_CHNL_COUNT + (channel << 5), count);\r\n}\r\nint vdma_get_residue(int channel)\r\n{\r\nint residual;\r\nresidual = r4030_read_reg32(JAZZ_R4030_CHNL_COUNT + (channel << 5));\r\nif (vdma_debug)\r\nprintk("vdma_get_residual: channel %d: residual=%d\n",\r\nchannel, residual);\r\nreturn residual;\r\n}\r\nint vdma_get_enable(int channel)\r\n{\r\nint enable;\r\nenable = r4030_read_reg32(JAZZ_R4030_CHNL_ENABLE + (channel << 5));\r\nif (vdma_debug)\r\nprintk("vdma_get_enable: channel %d: enable=%d\n", channel,\r\nenable);\r\nreturn enable;\r\n}
