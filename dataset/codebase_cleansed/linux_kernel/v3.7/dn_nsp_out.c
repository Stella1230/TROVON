static void dn_nsp_send(struct sk_buff *skb)\r\n{\r\nstruct sock *sk = skb->sk;\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct dst_entry *dst;\r\nstruct flowidn fld;\r\nskb_reset_transport_header(skb);\r\nscp->stamp = jiffies;\r\ndst = sk_dst_check(sk, 0);\r\nif (dst) {\r\ntry_again:\r\nskb_dst_set(skb, dst);\r\ndst_output(skb);\r\nreturn;\r\n}\r\nmemset(&fld, 0, sizeof(fld));\r\nfld.flowidn_oif = sk->sk_bound_dev_if;\r\nfld.saddr = dn_saddr2dn(&scp->addr);\r\nfld.daddr = dn_saddr2dn(&scp->peer);\r\ndn_sk_ports_copy(&fld, scp);\r\nfld.flowidn_proto = DNPROTO_NSP;\r\nif (dn_route_output_sock(&sk->sk_dst_cache, &fld, sk, 0) == 0) {\r\ndst = sk_dst_get(sk);\r\nsk->sk_route_caps = dst->dev->features;\r\ngoto try_again;\r\n}\r\nsk->sk_err = EHOSTUNREACH;\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_state_change(sk);\r\n}\r\nstruct sk_buff *dn_alloc_skb(struct sock *sk, int size, gfp_t pri)\r\n{\r\nstruct sk_buff *skb;\r\nint hdr = 64;\r\nif ((skb = alloc_skb(size + hdr, pri)) == NULL)\r\nreturn NULL;\r\nskb->protocol = htons(ETH_P_DNA_RT);\r\nskb->pkt_type = PACKET_OUTGOING;\r\nif (sk)\r\nskb_set_owner_w(skb, sk);\r\nskb_reserve(skb, hdr);\r\nreturn skb;\r\n}\r\nunsigned long dn_nsp_persist(struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nunsigned long t = ((scp->nsp_srtt >> 2) + scp->nsp_rttvar) >> 1;\r\nt *= nsp_backoff[scp->nsp_rxtshift];\r\nif (t < HZ) t = HZ;\r\nif (t > (600*HZ)) t = (600*HZ);\r\nif (scp->nsp_rxtshift < NSP_MAXRXTSHIFT)\r\nscp->nsp_rxtshift++;\r\nreturn t;\r\n}\r\nstatic void dn_nsp_rtt(struct sock *sk, long rtt)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nlong srtt = (long)scp->nsp_srtt;\r\nlong rttvar = (long)scp->nsp_rttvar;\r\nlong delta;\r\nif (rtt < 0)\r\nrtt = -rtt;\r\ndelta = ((rtt << 3) - srtt);\r\nsrtt += (delta >> 3);\r\nif (srtt >= 1)\r\nscp->nsp_srtt = (unsigned long)srtt;\r\nelse\r\nscp->nsp_srtt = 1;\r\ndelta >>= 1;\r\nrttvar += ((((delta>0)?(delta):(-delta)) - rttvar) >> 2);\r\nif (rttvar >= 1)\r\nscp->nsp_rttvar = (unsigned long)rttvar;\r\nelse\r\nscp->nsp_rttvar = 1;\r\n}\r\nstatic inline unsigned int dn_nsp_clone_and_send(struct sk_buff *skb,\r\ngfp_t gfp)\r\n{\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nstruct sk_buff *skb2;\r\nint ret = 0;\r\nif ((skb2 = skb_clone(skb, gfp)) != NULL) {\r\nret = cb->xmit_count;\r\ncb->xmit_count++;\r\ncb->stamp = jiffies;\r\nskb2->sk = skb->sk;\r\ndn_nsp_send(skb2);\r\n}\r\nreturn ret;\r\n}\r\nvoid dn_nsp_output(struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct sk_buff *skb;\r\nunsigned int reduce_win = 0;\r\nif ((skb = skb_peek(&scp->other_xmit_queue)) != NULL)\r\nreduce_win = dn_nsp_clone_and_send(skb, GFP_ATOMIC);\r\nif (reduce_win || (scp->flowrem_sw != DN_SEND))\r\ngoto recalc_window;\r\nif ((skb = skb_peek(&scp->data_xmit_queue)) != NULL)\r\nreduce_win = dn_nsp_clone_and_send(skb, GFP_ATOMIC);\r\nrecalc_window:\r\nif (reduce_win) {\r\nscp->snd_window >>= 1;\r\nif (scp->snd_window < NSP_MIN_WINDOW)\r\nscp->snd_window = NSP_MIN_WINDOW;\r\n}\r\n}\r\nint dn_nsp_xmit_timeout(struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\ndn_nsp_output(sk);\r\nif (!skb_queue_empty(&scp->data_xmit_queue) ||\r\n!skb_queue_empty(&scp->other_xmit_queue))\r\nscp->persist = dn_nsp_persist(sk);\r\nreturn 0;\r\n}\r\nstatic inline __le16 *dn_mk_common_header(struct dn_scp *scp, struct sk_buff *skb, unsigned char msgflag, int len)\r\n{\r\nunsigned char *ptr = skb_push(skb, len);\r\nBUG_ON(len < 5);\r\n*ptr++ = msgflag;\r\n*((__le16 *)ptr) = scp->addrrem;\r\nptr += 2;\r\n*((__le16 *)ptr) = scp->addrloc;\r\nptr += 2;\r\nreturn (__le16 __force *)ptr;\r\n}\r\nstatic __le16 *dn_mk_ack_header(struct sock *sk, struct sk_buff *skb, unsigned char msgflag, int hlen, int other)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nunsigned short acknum = scp->numdat_rcv & 0x0FFF;\r\nunsigned short ackcrs = scp->numoth_rcv & 0x0FFF;\r\n__le16 *ptr;\r\nBUG_ON(hlen < 9);\r\nscp->ackxmt_dat = acknum;\r\nscp->ackxmt_oth = ackcrs;\r\nacknum |= 0x8000;\r\nackcrs |= 0x8000;\r\nif (other) {\r\nunsigned short tmp = acknum;\r\nacknum = ackcrs;\r\nackcrs = tmp;\r\n}\r\nackcrs |= 0x2000;\r\nptr = dn_mk_common_header(scp, skb, msgflag, hlen);\r\n*ptr++ = cpu_to_le16(acknum);\r\n*ptr++ = cpu_to_le16(ackcrs);\r\nreturn ptr;\r\n}\r\nstatic __le16 *dn_nsp_mk_data_header(struct sock *sk, struct sk_buff *skb, int oth)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\n__le16 *ptr = dn_mk_ack_header(sk, skb, cb->nsp_flags, 11, oth);\r\nif (unlikely(oth)) {\r\ncb->segnum = scp->numoth;\r\nseq_add(&scp->numoth, 1);\r\n} else {\r\ncb->segnum = scp->numdat;\r\nseq_add(&scp->numdat, 1);\r\n}\r\n*(ptr++) = cpu_to_le16(cb->segnum);\r\nreturn ptr;\r\n}\r\nvoid dn_nsp_queue_xmit(struct sock *sk, struct sk_buff *skb,\r\ngfp_t gfp, int oth)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nunsigned long t = ((scp->nsp_srtt >> 2) + scp->nsp_rttvar) >> 1;\r\ncb->xmit_count = 0;\r\ndn_nsp_mk_data_header(sk, skb, oth);\r\nif ((jiffies - scp->stamp) > t)\r\nscp->snd_window = NSP_MIN_WINDOW;\r\nif (oth)\r\nskb_queue_tail(&scp->other_xmit_queue, skb);\r\nelse\r\nskb_queue_tail(&scp->data_xmit_queue, skb);\r\nif (scp->flowrem_sw != DN_SEND)\r\nreturn;\r\ndn_nsp_clone_and_send(skb, gfp);\r\n}\r\nint dn_nsp_check_xmit_queue(struct sock *sk, struct sk_buff *skb, struct sk_buff_head *q, unsigned short acknum)\r\n{\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct sk_buff *skb2, *n, *ack = NULL;\r\nint wakeup = 0;\r\nint try_retrans = 0;\r\nunsigned long reftime = cb->stamp;\r\nunsigned long pkttime;\r\nunsigned short xmit_count;\r\nunsigned short segnum;\r\nskb_queue_walk_safe(q, skb2, n) {\r\nstruct dn_skb_cb *cb2 = DN_SKB_CB(skb2);\r\nif (dn_before_or_equal(cb2->segnum, acknum))\r\nack = skb2;\r\nif (ack == NULL)\r\ncontinue;\r\ntry_retrans = 0;\r\nwakeup = 1;\r\npkttime = cb2->stamp;\r\nxmit_count = cb2->xmit_count;\r\nsegnum = cb2->segnum;\r\nskb_unlink(ack, q);\r\nkfree_skb(ack);\r\nack = NULL;\r\nWARN_ON(xmit_count == 0);\r\nif (xmit_count == 1) {\r\nif (dn_equal(segnum, acknum))\r\ndn_nsp_rtt(sk, (long)(pkttime - reftime));\r\nif (scp->snd_window < scp->max_window)\r\nscp->snd_window++;\r\n}\r\nif (xmit_count > 1)\r\ntry_retrans = 1;\r\n}\r\nif (try_retrans)\r\ndn_nsp_output(sk);\r\nreturn wakeup;\r\n}\r\nvoid dn_nsp_send_data_ack(struct sock *sk)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nif ((skb = dn_alloc_skb(sk, 9, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb_reserve(skb, 9);\r\ndn_mk_ack_header(sk, skb, 0x04, 9, 0);\r\ndn_nsp_send(skb);\r\n}\r\nvoid dn_nsp_send_oth_ack(struct sock *sk)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nif ((skb = dn_alloc_skb(sk, 9, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb_reserve(skb, 9);\r\ndn_mk_ack_header(sk, skb, 0x14, 9, 1);\r\ndn_nsp_send(skb);\r\n}\r\nvoid dn_send_conn_ack (struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct sk_buff *skb = NULL;\r\nstruct nsp_conn_ack_msg *msg;\r\nif ((skb = dn_alloc_skb(sk, 3, sk->sk_allocation)) == NULL)\r\nreturn;\r\nmsg = (struct nsp_conn_ack_msg *)skb_put(skb, 3);\r\nmsg->msgflg = 0x24;\r\nmsg->dstaddr = scp->addrrem;\r\ndn_nsp_send(skb);\r\n}\r\nvoid dn_nsp_delayed_ack(struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nif (scp->ackxmt_oth != scp->numoth_rcv)\r\ndn_nsp_send_oth_ack(sk);\r\nif (scp->ackxmt_dat != scp->numdat_rcv)\r\ndn_nsp_send_data_ack(sk);\r\n}\r\nstatic int dn_nsp_retrans_conn_conf(struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nif (scp->state == DN_CC)\r\ndn_send_conn_conf(sk, GFP_ATOMIC);\r\nreturn 0;\r\n}\r\nvoid dn_send_conn_conf(struct sock *sk, gfp_t gfp)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct sk_buff *skb = NULL;\r\nstruct nsp_conn_init_msg *msg;\r\n__u8 len = (__u8)le16_to_cpu(scp->conndata_out.opt_optl);\r\nif ((skb = dn_alloc_skb(sk, 50 + len, gfp)) == NULL)\r\nreturn;\r\nmsg = (struct nsp_conn_init_msg *)skb_put(skb, sizeof(*msg));\r\nmsg->msgflg = 0x28;\r\nmsg->dstaddr = scp->addrrem;\r\nmsg->srcaddr = scp->addrloc;\r\nmsg->services = scp->services_loc;\r\nmsg->info = scp->info_loc;\r\nmsg->segsize = cpu_to_le16(scp->segsize_loc);\r\n*skb_put(skb,1) = len;\r\nif (len > 0)\r\nmemcpy(skb_put(skb, len), scp->conndata_out.opt_data, len);\r\ndn_nsp_send(skb);\r\nscp->persist = dn_nsp_persist(sk);\r\nscp->persist_fxn = dn_nsp_retrans_conn_conf;\r\n}\r\nstatic __inline__ void dn_nsp_do_disc(struct sock *sk, unsigned char msgflg,\r\nunsigned short reason, gfp_t gfp,\r\nstruct dst_entry *dst,\r\nint ddl, unsigned char *dd, __le16 rem, __le16 loc)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nint size = 7 + ddl + ((msgflg == NSP_DISCINIT) ? 1 : 0);\r\nunsigned char *msg;\r\nif ((dst == NULL) || (rem == 0)) {\r\nnet_dbg_ratelimited("DECnet: dn_nsp_do_disc: BUG! Please report this to SteveW@ACM.org rem=%u dst=%p\n",\r\nle16_to_cpu(rem), dst);\r\nreturn;\r\n}\r\nif ((skb = dn_alloc_skb(sk, size, gfp)) == NULL)\r\nreturn;\r\nmsg = skb_put(skb, size);\r\n*msg++ = msgflg;\r\n*(__le16 *)msg = rem;\r\nmsg += 2;\r\n*(__le16 *)msg = loc;\r\nmsg += 2;\r\n*(__le16 *)msg = cpu_to_le16(reason);\r\nmsg += 2;\r\nif (msgflg == NSP_DISCINIT)\r\n*msg++ = ddl;\r\nif (ddl) {\r\nmemcpy(msg, dd, ddl);\r\n}\r\nskb_dst_set(skb, dst_clone(dst));\r\ndst_output(skb);\r\n}\r\nvoid dn_nsp_send_disc(struct sock *sk, unsigned char msgflg,\r\nunsigned short reason, gfp_t gfp)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nint ddl = 0;\r\nif (msgflg == NSP_DISCINIT)\r\nddl = le16_to_cpu(scp->discdata_out.opt_optl);\r\nif (reason == 0)\r\nreason = le16_to_cpu(scp->discdata_out.opt_status);\r\ndn_nsp_do_disc(sk, msgflg, reason, gfp, sk->sk_dst_cache, ddl,\r\nscp->discdata_out.opt_data, scp->addrrem, scp->addrloc);\r\n}\r\nvoid dn_nsp_return_disc(struct sk_buff *skb, unsigned char msgflg,\r\nunsigned short reason)\r\n{\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nint ddl = 0;\r\ngfp_t gfp = GFP_ATOMIC;\r\ndn_nsp_do_disc(NULL, msgflg, reason, gfp, skb_dst(skb), ddl,\r\nNULL, cb->src_port, cb->dst_port);\r\n}\r\nvoid dn_nsp_send_link(struct sock *sk, unsigned char lsflags, char fcval)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct sk_buff *skb;\r\nunsigned char *ptr;\r\ngfp_t gfp = GFP_ATOMIC;\r\nif ((skb = dn_alloc_skb(sk, DN_MAX_NSP_DATA_HEADER + 2, gfp)) == NULL)\r\nreturn;\r\nskb_reserve(skb, DN_MAX_NSP_DATA_HEADER);\r\nptr = skb_put(skb, 2);\r\nDN_SKB_CB(skb)->nsp_flags = 0x10;\r\n*ptr++ = lsflags;\r\n*ptr = fcval;\r\ndn_nsp_queue_xmit(sk, skb, gfp, 1);\r\nscp->persist = dn_nsp_persist(sk);\r\nscp->persist_fxn = dn_nsp_xmit_timeout;\r\n}\r\nstatic int dn_nsp_retrans_conninit(struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nif (scp->state == DN_CI)\r\ndn_nsp_send_conninit(sk, NSP_RCI);\r\nreturn 0;\r\n}\r\nvoid dn_nsp_send_conninit(struct sock *sk, unsigned char msgflg)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct nsp_conn_init_msg *msg;\r\nunsigned char aux;\r\nunsigned char menuver;\r\nstruct dn_skb_cb *cb;\r\nunsigned char type = 1;\r\ngfp_t allocation = (msgflg == NSP_CI) ? sk->sk_allocation : GFP_ATOMIC;\r\nstruct sk_buff *skb = dn_alloc_skb(sk, 200, allocation);\r\nif (!skb)\r\nreturn;\r\ncb = DN_SKB_CB(skb);\r\nmsg = (struct nsp_conn_init_msg *)skb_put(skb,sizeof(*msg));\r\nmsg->msgflg = msgflg;\r\nmsg->dstaddr = 0x0000;\r\nmsg->srcaddr = scp->addrloc;\r\nmsg->services = scp->services_loc;\r\nmsg->info = scp->info_loc;\r\nmsg->segsize = cpu_to_le16(scp->segsize_loc);\r\nif (scp->peer.sdn_objnum)\r\ntype = 0;\r\nskb_put(skb, dn_sockaddr2username(&scp->peer,\r\nskb_tail_pointer(skb), type));\r\nskb_put(skb, dn_sockaddr2username(&scp->addr,\r\nskb_tail_pointer(skb), 2));\r\nmenuver = DN_MENUVER_ACC | DN_MENUVER_USR;\r\nif (scp->peer.sdn_flags & SDF_PROXY)\r\nmenuver |= DN_MENUVER_PRX;\r\nif (scp->peer.sdn_flags & SDF_UICPROXY)\r\nmenuver |= DN_MENUVER_UIC;\r\n*skb_put(skb, 1) = menuver;\r\naux = scp->accessdata.acc_userl;\r\n*skb_put(skb, 1) = aux;\r\nif (aux > 0)\r\nmemcpy(skb_put(skb, aux), scp->accessdata.acc_user, aux);\r\naux = scp->accessdata.acc_passl;\r\n*skb_put(skb, 1) = aux;\r\nif (aux > 0)\r\nmemcpy(skb_put(skb, aux), scp->accessdata.acc_pass, aux);\r\naux = scp->accessdata.acc_accl;\r\n*skb_put(skb, 1) = aux;\r\nif (aux > 0)\r\nmemcpy(skb_put(skb, aux), scp->accessdata.acc_acc, aux);\r\naux = (__u8)le16_to_cpu(scp->conndata_out.opt_optl);\r\n*skb_put(skb, 1) = aux;\r\nif (aux > 0)\r\nmemcpy(skb_put(skb, aux), scp->conndata_out.opt_data, aux);\r\nscp->persist = dn_nsp_persist(sk);\r\nscp->persist_fxn = dn_nsp_retrans_conninit;\r\ncb->rt_flags = DN_RT_F_RQR;\r\ndn_nsp_send(skb);\r\n}
