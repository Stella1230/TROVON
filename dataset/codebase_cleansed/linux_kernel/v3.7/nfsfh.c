static int nfsd_acceptable(void *expv, struct dentry *dentry)\r\n{\r\nstruct svc_export *exp = expv;\r\nint rv;\r\nstruct dentry *tdentry;\r\nstruct dentry *parent;\r\nif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\r\nreturn 1;\r\ntdentry = dget(dentry);\r\nwhile (tdentry != exp->ex_path.dentry && !IS_ROOT(tdentry)) {\r\nint err;\r\nparent = dget_parent(tdentry);\r\nerr = inode_permission(parent->d_inode, MAY_EXEC);\r\nif (err < 0) {\r\ndput(parent);\r\nbreak;\r\n}\r\ndput(tdentry);\r\ntdentry = parent;\r\n}\r\nif (tdentry != exp->ex_path.dentry)\r\ndprintk("nfsd_acceptable failed at %p %s\n", tdentry, tdentry->d_name.name);\r\nrv = (tdentry == exp->ex_path.dentry);\r\ndput(tdentry);\r\nreturn rv;\r\n}\r\nstatic inline __be32\r\nnfsd_mode_check(struct svc_rqst *rqstp, umode_t mode, umode_t requested)\r\n{\r\nmode &= S_IFMT;\r\nif (requested == 0)\r\nreturn nfs_ok;\r\nif (mode == requested)\r\nreturn nfs_ok;\r\nif (rqstp->rq_vers == 4 && mode == S_IFLNK)\r\nreturn nfserr_symlink;\r\nif (requested == S_IFDIR)\r\nreturn nfserr_notdir;\r\nif (mode == S_IFDIR)\r\nreturn nfserr_isdir;\r\nreturn nfserr_inval;\r\n}\r\nstatic __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\r\nstruct svc_export *exp)\r\n{\r\nint flags = nfsexp_flags(rqstp, exp);\r\nif (!rqstp->rq_secure && !(flags & NFSEXP_INSECURE_PORT)) {\r\nRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\r\ndprintk(KERN_WARNING\r\n"nfsd: request from insecure port %s!\n",\r\nsvc_print_addr(rqstp, buf, sizeof(buf)));\r\nreturn nfserr_perm;\r\n}\r\nreturn nfserrno(nfsd_setuser(rqstp, exp));\r\n}\r\nstatic inline __be32 check_pseudo_root(struct svc_rqst *rqstp,\r\nstruct dentry *dentry, struct svc_export *exp)\r\n{\r\nif (!(exp->ex_flags & NFSEXP_V4ROOT))\r\nreturn nfs_ok;\r\nif (!nfsd_v4client(rqstp))\r\nreturn nfserr_stale;\r\nif (unlikely(!S_ISDIR(dentry->d_inode->i_mode) &&\r\n!S_ISLNK(dentry->d_inode->i_mode)))\r\nreturn nfserr_stale;\r\nif (unlikely(dentry != exp->ex_path.dentry))\r\nreturn nfserr_stale;\r\nreturn nfs_ok;\r\n}\r\nstatic __be32 nfsd_set_fh_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp)\r\n{\r\nstruct knfsd_fh *fh = &fhp->fh_handle;\r\nstruct fid *fid = NULL, sfid;\r\nstruct svc_export *exp;\r\nstruct dentry *dentry;\r\nint fileid_type;\r\nint data_left = fh->fh_size/4;\r\n__be32 error;\r\nerror = nfserr_stale;\r\nif (rqstp->rq_vers > 2)\r\nerror = nfserr_badhandle;\r\nif (rqstp->rq_vers == 4 && fh->fh_size == 0)\r\nreturn nfserr_nofilehandle;\r\nif (fh->fh_version == 1) {\r\nint len;\r\nif (--data_left < 0)\r\nreturn error;\r\nif (fh->fh_auth_type != 0)\r\nreturn error;\r\nlen = key_len(fh->fh_fsid_type) / 4;\r\nif (len == 0)\r\nreturn error;\r\nif (fh->fh_fsid_type == FSID_MAJOR_MINOR) {\r\nlen = key_len(FSID_ENCODE_DEV)/4;\r\nfh->fh_fsid_type = FSID_ENCODE_DEV;\r\nfh->fh_fsid[0] = new_encode_dev(MKDEV(ntohl(fh->fh_fsid[0]), ntohl(fh->fh_fsid[1])));\r\nfh->fh_fsid[1] = fh->fh_fsid[2];\r\n}\r\ndata_left -= len;\r\nif (data_left < 0)\r\nreturn error;\r\nexp = rqst_exp_find(rqstp, fh->fh_fsid_type, fh->fh_auth);\r\nfid = (struct fid *)(fh->fh_auth + len);\r\n} else {\r\n__u32 tfh[2];\r\ndev_t xdev;\r\nino_t xino;\r\nif (fh->fh_size != NFS_FHSIZE)\r\nreturn error;\r\nxdev = old_decode_dev(fh->ofh_xdev);\r\nxino = u32_to_ino_t(fh->ofh_xino);\r\nmk_fsid(FSID_DEV, tfh, xdev, xino, 0, NULL);\r\nexp = rqst_exp_find(rqstp, FSID_DEV, tfh);\r\n}\r\nerror = nfserr_stale;\r\nif (PTR_ERR(exp) == -ENOENT)\r\nreturn error;\r\nif (IS_ERR(exp))\r\nreturn nfserrno(PTR_ERR(exp));\r\nif (exp->ex_flags & NFSEXP_NOSUBTREECHECK) {\r\nstruct cred *new = prepare_creds();\r\nif (!new)\r\nreturn nfserrno(-ENOMEM);\r\nnew->cap_effective =\r\ncap_raise_nfsd_set(new->cap_effective,\r\nnew->cap_permitted);\r\nput_cred(override_creds(new));\r\nput_cred(new);\r\n} else {\r\nerror = nfsd_setuser_and_check_port(rqstp, exp);\r\nif (error)\r\ngoto out;\r\n}\r\nerror = nfserr_stale;\r\nif (rqstp->rq_vers > 2)\r\nerror = nfserr_badhandle;\r\nif (fh->fh_version != 1) {\r\nsfid.i32.ino = fh->ofh_ino;\r\nsfid.i32.gen = fh->ofh_generation;\r\nsfid.i32.parent_ino = fh->ofh_dirino;\r\nfid = &sfid;\r\ndata_left = 3;\r\nif (fh->ofh_dirino == 0)\r\nfileid_type = FILEID_INO32_GEN;\r\nelse\r\nfileid_type = FILEID_INO32_GEN_PARENT;\r\n} else\r\nfileid_type = fh->fh_fileid_type;\r\nif (fileid_type == FILEID_ROOT)\r\ndentry = dget(exp->ex_path.dentry);\r\nelse {\r\ndentry = exportfs_decode_fh(exp->ex_path.mnt, fid,\r\ndata_left, fileid_type,\r\nnfsd_acceptable, exp);\r\n}\r\nif (dentry == NULL)\r\ngoto out;\r\nif (IS_ERR(dentry)) {\r\nif (PTR_ERR(dentry) != -EINVAL)\r\nerror = nfserrno(PTR_ERR(dentry));\r\ngoto out;\r\n}\r\nif (S_ISDIR(dentry->d_inode->i_mode) &&\r\n(dentry->d_flags & DCACHE_DISCONNECTED)) {\r\nprintk("nfsd: find_fh_dentry returned a DISCONNECTED directory: %s/%s\n",\r\ndentry->d_parent->d_name.name, dentry->d_name.name);\r\n}\r\nfhp->fh_dentry = dentry;\r\nfhp->fh_export = exp;\r\nreturn 0;\r\nout:\r\nexp_put(exp);\r\nreturn error;\r\n}\r\n__be32\r\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\r\n{\r\nstruct svc_export *exp;\r\nstruct dentry *dentry;\r\n__be32 error;\r\ndprintk("nfsd: fh_verify(%s)\n", SVCFH_fmt(fhp));\r\nif (!fhp->fh_dentry) {\r\nerror = nfsd_set_fh_dentry(rqstp, fhp);\r\nif (error)\r\ngoto out;\r\n}\r\ndentry = fhp->fh_dentry;\r\nexp = fhp->fh_export;\r\nerror = check_pseudo_root(rqstp, dentry, exp);\r\nif (error)\r\ngoto out;\r\nerror = nfsd_setuser_and_check_port(rqstp, exp);\r\nif (error)\r\ngoto out;\r\nerror = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);\r\nif (error)\r\ngoto out;\r\nif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\r\ngoto skip_pseudoflavor_check;\r\nif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\r\n&& exp->ex_path.dentry == dentry)\r\ngoto skip_pseudoflavor_check;\r\nerror = check_nfsd_access(exp, rqstp);\r\nif (error)\r\ngoto out;\r\nskip_pseudoflavor_check:\r\nerror = nfsd_permission(rqstp, exp, dentry, access);\r\nif (error) {\r\ndprintk("fh_verify: %s/%s permission failure, "\r\n"acc=%x, error=%d\n",\r\ndentry->d_parent->d_name.name,\r\ndentry->d_name.name,\r\naccess, ntohl(error));\r\n}\r\nout:\r\nif (error == nfserr_stale)\r\nnfsdstats.fh_stale++;\r\nreturn error;\r\n}\r\nstatic void _fh_update(struct svc_fh *fhp, struct svc_export *exp,\r\nstruct dentry *dentry)\r\n{\r\nif (dentry != exp->ex_path.dentry) {\r\nstruct fid *fid = (struct fid *)\r\n(fhp->fh_handle.fh_auth + fhp->fh_handle.fh_size/4 - 1);\r\nint maxsize = (fhp->fh_maxsize - fhp->fh_handle.fh_size)/4;\r\nint subtreecheck = !(exp->ex_flags & NFSEXP_NOSUBTREECHECK);\r\nfhp->fh_handle.fh_fileid_type =\r\nexportfs_encode_fh(dentry, fid, &maxsize, subtreecheck);\r\nfhp->fh_handle.fh_size += maxsize * 4;\r\n} else {\r\nfhp->fh_handle.fh_fileid_type = FILEID_ROOT;\r\n}\r\n}\r\nstatic inline void _fh_update_old(struct dentry *dentry,\r\nstruct svc_export *exp,\r\nstruct knfsd_fh *fh)\r\n{\r\nfh->ofh_ino = ino_t_to_u32(dentry->d_inode->i_ino);\r\nfh->ofh_generation = dentry->d_inode->i_generation;\r\nif (S_ISDIR(dentry->d_inode->i_mode) ||\r\n(exp->ex_flags & NFSEXP_NOSUBTREECHECK))\r\nfh->ofh_dirino = 0;\r\n}\r\nstatic bool is_root_export(struct svc_export *exp)\r\n{\r\nreturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\r\n}\r\nstatic struct super_block *exp_sb(struct svc_export *exp)\r\n{\r\nreturn exp->ex_path.dentry->d_inode->i_sb;\r\n}\r\nstatic bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)\r\n{\r\nswitch (fsid_type) {\r\ncase FSID_DEV:\r\nif (!old_valid_dev(exp_sb(exp)->s_dev))\r\nreturn 0;\r\ncase FSID_MAJOR_MINOR:\r\ncase FSID_ENCODE_DEV:\r\nreturn exp_sb(exp)->s_type->fs_flags & FS_REQUIRES_DEV;\r\ncase FSID_NUM:\r\nreturn exp->ex_flags & NFSEXP_FSID;\r\ncase FSID_UUID8:\r\ncase FSID_UUID16:\r\nif (!is_root_export(exp))\r\nreturn 0;\r\ncase FSID_UUID4_INUM:\r\ncase FSID_UUID16_INUM:\r\nreturn exp->ex_uuid != NULL;\r\n}\r\nreturn 1;\r\n}\r\nstatic void set_version_and_fsid_type(struct svc_fh *fhp, struct svc_export *exp, struct svc_fh *ref_fh)\r\n{\r\nu8 version;\r\nu8 fsid_type;\r\nretry:\r\nversion = 1;\r\nif (ref_fh && ref_fh->fh_export == exp) {\r\nversion = ref_fh->fh_handle.fh_version;\r\nfsid_type = ref_fh->fh_handle.fh_fsid_type;\r\nref_fh = NULL;\r\nswitch (version) {\r\ncase 0xca:\r\nfsid_type = FSID_DEV;\r\nbreak;\r\ncase 1:\r\nbreak;\r\ndefault:\r\ngoto retry;\r\n}\r\nif (!fsid_type_ok_for_exp(fsid_type, exp))\r\ngoto retry;\r\n} else if (exp->ex_flags & NFSEXP_FSID) {\r\nfsid_type = FSID_NUM;\r\n} else if (exp->ex_uuid) {\r\nif (fhp->fh_maxsize >= 64) {\r\nif (is_root_export(exp))\r\nfsid_type = FSID_UUID16;\r\nelse\r\nfsid_type = FSID_UUID16_INUM;\r\n} else {\r\nif (is_root_export(exp))\r\nfsid_type = FSID_UUID8;\r\nelse\r\nfsid_type = FSID_UUID4_INUM;\r\n}\r\n} else if (!old_valid_dev(exp_sb(exp)->s_dev))\r\nfsid_type = FSID_ENCODE_DEV;\r\nelse\r\nfsid_type = FSID_DEV;\r\nfhp->fh_handle.fh_version = version;\r\nif (version)\r\nfhp->fh_handle.fh_fsid_type = fsid_type;\r\n}\r\n__be32\r\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\r\nstruct svc_fh *ref_fh)\r\n{\r\nstruct inode * inode = dentry->d_inode;\r\nstruct dentry *parent = dentry->d_parent;\r\n__u32 *datap;\r\ndev_t ex_dev = exp_sb(exp)->s_dev;\r\ndprintk("nfsd: fh_compose(exp %02x:%02x/%ld %s/%s, ino=%ld)\n",\r\nMAJOR(ex_dev), MINOR(ex_dev),\r\n(long) exp->ex_path.dentry->d_inode->i_ino,\r\nparent->d_name.name, dentry->d_name.name,\r\n(inode ? inode->i_ino : 0));\r\nset_version_and_fsid_type(fhp, exp, ref_fh);\r\nif (ref_fh == fhp)\r\nfh_put(ref_fh);\r\nif (fhp->fh_locked || fhp->fh_dentry) {\r\nprintk(KERN_ERR "fh_compose: fh %s/%s not initialized!\n",\r\nparent->d_name.name, dentry->d_name.name);\r\n}\r\nif (fhp->fh_maxsize < NFS_FHSIZE)\r\nprintk(KERN_ERR "fh_compose: called with maxsize %d! %s/%s\n",\r\nfhp->fh_maxsize,\r\nparent->d_name.name, dentry->d_name.name);\r\nfhp->fh_dentry = dget(dentry);\r\nfhp->fh_export = exp;\r\ncache_get(&exp->h);\r\nif (fhp->fh_handle.fh_version == 0xca) {\r\nmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\r\nfhp->fh_handle.fh_size = NFS_FHSIZE;\r\nfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\r\nfhp->fh_handle.ofh_dev = old_encode_dev(ex_dev);\r\nfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\r\nfhp->fh_handle.ofh_xino =\r\nino_t_to_u32(exp->ex_path.dentry->d_inode->i_ino);\r\nfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\r\nif (inode)\r\n_fh_update_old(dentry, exp, &fhp->fh_handle);\r\n} else {\r\nint len;\r\nfhp->fh_handle.fh_auth_type = 0;\r\ndatap = fhp->fh_handle.fh_auth+0;\r\nmk_fsid(fhp->fh_handle.fh_fsid_type, datap, ex_dev,\r\nexp->ex_path.dentry->d_inode->i_ino,\r\nexp->ex_fsid, exp->ex_uuid);\r\nlen = key_len(fhp->fh_handle.fh_fsid_type);\r\ndatap += len/4;\r\nfhp->fh_handle.fh_size = 4 + len;\r\nif (inode)\r\n_fh_update(fhp, exp, dentry);\r\nif (fhp->fh_handle.fh_fileid_type == 255) {\r\nfh_put(fhp);\r\nreturn nfserr_opnotsupp;\r\n}\r\n}\r\nreturn 0;\r\n}\r\n__be32\r\nfh_update(struct svc_fh *fhp)\r\n{\r\nstruct dentry *dentry;\r\nif (!fhp->fh_dentry)\r\ngoto out_bad;\r\ndentry = fhp->fh_dentry;\r\nif (!dentry->d_inode)\r\ngoto out_negative;\r\nif (fhp->fh_handle.fh_version != 1) {\r\n_fh_update_old(dentry, fhp->fh_export, &fhp->fh_handle);\r\n} else {\r\nif (fhp->fh_handle.fh_fileid_type != FILEID_ROOT)\r\ngoto out;\r\n_fh_update(fhp, fhp->fh_export, dentry);\r\nif (fhp->fh_handle.fh_fileid_type == 255)\r\nreturn nfserr_opnotsupp;\r\n}\r\nout:\r\nreturn 0;\r\nout_bad:\r\nprintk(KERN_ERR "fh_update: fh not verified!\n");\r\ngoto out;\r\nout_negative:\r\nprintk(KERN_ERR "fh_update: %s/%s still negative!\n",\r\ndentry->d_parent->d_name.name, dentry->d_name.name);\r\ngoto out;\r\n}\r\nvoid\r\nfh_put(struct svc_fh *fhp)\r\n{\r\nstruct dentry * dentry = fhp->fh_dentry;\r\nstruct svc_export * exp = fhp->fh_export;\r\nif (dentry) {\r\nfh_unlock(fhp);\r\nfhp->fh_dentry = NULL;\r\ndput(dentry);\r\n#ifdef CONFIG_NFSD_V3\r\nfhp->fh_pre_saved = 0;\r\nfhp->fh_post_saved = 0;\r\n#endif\r\n}\r\nfh_drop_write(fhp);\r\nif (exp) {\r\nexp_put(exp);\r\nfhp->fh_export = NULL;\r\n}\r\nreturn;\r\n}\r\nchar * SVCFH_fmt(struct svc_fh *fhp)\r\n{\r\nstruct knfsd_fh *fh = &fhp->fh_handle;\r\nstatic char buf[80];\r\nsprintf(buf, "%d: %08x %08x %08x %08x %08x %08x",\r\nfh->fh_size,\r\nfh->fh_base.fh_pad[0],\r\nfh->fh_base.fh_pad[1],\r\nfh->fh_base.fh_pad[2],\r\nfh->fh_base.fh_pad[3],\r\nfh->fh_base.fh_pad[4],\r\nfh->fh_base.fh_pad[5]);\r\nreturn buf;\r\n}\r\nenum fsid_source fsid_source(struct svc_fh *fhp)\r\n{\r\nif (fhp->fh_handle.fh_version != 1)\r\nreturn FSIDSOURCE_DEV;\r\nswitch(fhp->fh_handle.fh_fsid_type) {\r\ncase FSID_DEV:\r\ncase FSID_ENCODE_DEV:\r\ncase FSID_MAJOR_MINOR:\r\nif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\r\nreturn FSIDSOURCE_DEV;\r\nbreak;\r\ncase FSID_NUM:\r\nif (fhp->fh_export->ex_flags & NFSEXP_FSID)\r\nreturn FSIDSOURCE_FSID;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (fhp->fh_export->ex_flags & NFSEXP_FSID)\r\nreturn FSIDSOURCE_FSID;\r\nif (fhp->fh_export->ex_uuid)\r\nreturn FSIDSOURCE_UUID;\r\nreturn FSIDSOURCE_DEV;\r\n}
