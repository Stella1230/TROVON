static u8 ks_rdreg8(struct ks_net *ks, int offset)\r\n{\r\nu16 data;\r\nu8 shift_bit = offset & 0x03;\r\nu8 shift_data = (offset & 1) << 3;\r\nks->cmd_reg_cache = (u16) offset | (u16)(BE0 << shift_bit);\r\niowrite16(ks->cmd_reg_cache, ks->hw_addr_cmd);\r\ndata = ioread16(ks->hw_addr);\r\nreturn (u8)(data >> shift_data);\r\n}\r\nstatic u16 ks_rdreg16(struct ks_net *ks, int offset)\r\n{\r\nks->cmd_reg_cache = (u16)offset | ((BE1 | BE0) << (offset & 0x02));\r\niowrite16(ks->cmd_reg_cache, ks->hw_addr_cmd);\r\nreturn ioread16(ks->hw_addr);\r\n}\r\nstatic void ks_wrreg8(struct ks_net *ks, int offset, u8 value)\r\n{\r\nu8 shift_bit = (offset & 0x03);\r\nu16 value_write = (u16)(value << ((offset & 1) << 3));\r\nks->cmd_reg_cache = (u16)offset | (BE0 << shift_bit);\r\niowrite16(ks->cmd_reg_cache, ks->hw_addr_cmd);\r\niowrite16(value_write, ks->hw_addr);\r\n}\r\nstatic void ks_wrreg16(struct ks_net *ks, int offset, u16 value)\r\n{\r\nks->cmd_reg_cache = (u16)offset | ((BE1 | BE0) << (offset & 0x02));\r\niowrite16(ks->cmd_reg_cache, ks->hw_addr_cmd);\r\niowrite16(value, ks->hw_addr);\r\n}\r\nstatic inline void ks_inblk(struct ks_net *ks, u16 *wptr, u32 len)\r\n{\r\nlen >>= 1;\r\nwhile (len--)\r\n*wptr++ = (u16)ioread16(ks->hw_addr);\r\n}\r\nstatic inline void ks_outblk(struct ks_net *ks, u16 *wptr, u32 len)\r\n{\r\nlen >>= 1;\r\nwhile (len--)\r\niowrite16(*wptr++, ks->hw_addr);\r\n}\r\nstatic void ks_disable_int(struct ks_net *ks)\r\n{\r\nks_wrreg16(ks, KS_IER, 0x0000);\r\n}\r\nstatic void ks_enable_int(struct ks_net *ks)\r\n{\r\nks_wrreg16(ks, KS_IER, ks->rc_ier);\r\n}\r\nstatic inline u16 ks_tx_fifo_space(struct ks_net *ks)\r\n{\r\nreturn ks_rdreg16(ks, KS_TXMIR) & 0x1fff;\r\n}\r\nstatic inline void ks_save_cmd_reg(struct ks_net *ks)\r\n{\r\nks->cmd_reg_cache_int = ks->cmd_reg_cache;\r\n}\r\nstatic inline void ks_restore_cmd_reg(struct ks_net *ks)\r\n{\r\nks->cmd_reg_cache = ks->cmd_reg_cache_int;\r\niowrite16(ks->cmd_reg_cache, ks->hw_addr_cmd);\r\n}\r\nstatic void ks_set_powermode(struct ks_net *ks, unsigned pwrmode)\r\n{\r\nunsigned pmecr;\r\nnetif_dbg(ks, hw, ks->netdev, "setting power mode %d\n", pwrmode);\r\nks_rdreg16(ks, KS_GRR);\r\npmecr = ks_rdreg16(ks, KS_PMECR);\r\npmecr &= ~PMECR_PM_MASK;\r\npmecr |= pwrmode;\r\nks_wrreg16(ks, KS_PMECR, pmecr);\r\n}\r\nstatic void ks_read_config(struct ks_net *ks)\r\n{\r\nu16 reg_data = 0;\r\nreg_data = ks_rdreg8(ks, KS_CCR) & 0x00FF;\r\nreg_data |= ks_rdreg8(ks, KS_CCR+1) << 8;\r\nks->sharedbus = (reg_data & CCR_SHARED) == CCR_SHARED;\r\nif (reg_data & CCR_8BIT) {\r\nks->bus_width = ENUM_BUS_8BIT;\r\nks->extra_byte = 1;\r\n} else if (reg_data & CCR_16BIT) {\r\nks->bus_width = ENUM_BUS_16BIT;\r\nks->extra_byte = 2;\r\n} else {\r\nks->bus_width = ENUM_BUS_32BIT;\r\nks->extra_byte = 4;\r\n}\r\n}\r\nstatic void ks_soft_reset(struct ks_net *ks, unsigned op)\r\n{\r\nks_wrreg16(ks, KS_IER, 0x0000);\r\nks_wrreg16(ks, KS_GRR, op);\r\nmdelay(10);\r\nks_wrreg16(ks, KS_GRR, 0);\r\nmdelay(1);\r\n}\r\nvoid ks_enable_qmu(struct ks_net *ks)\r\n{\r\nu16 w;\r\nw = ks_rdreg16(ks, KS_TXCR);\r\nks_wrreg16(ks, KS_TXCR, w | TXCR_TXE);\r\nw = ks_rdreg16(ks, KS_RXQCR);\r\nks_wrreg16(ks, KS_RXQCR, w | RXQCR_RXFCTE);\r\nw = ks_rdreg16(ks, KS_RXCR1);\r\nks_wrreg16(ks, KS_RXCR1, w | RXCR1_RXE);\r\nks->enabled = true;\r\n}\r\nstatic void ks_disable_qmu(struct ks_net *ks)\r\n{\r\nu16 w;\r\nw = ks_rdreg16(ks, KS_TXCR);\r\nw &= ~TXCR_TXE;\r\nks_wrreg16(ks, KS_TXCR, w);\r\nw = ks_rdreg16(ks, KS_RXCR1);\r\nw &= ~RXCR1_RXE ;\r\nks_wrreg16(ks, KS_RXCR1, w);\r\nks->enabled = false;\r\n}\r\nstatic inline void ks_read_qmu(struct ks_net *ks, u16 *buf, u32 len)\r\n{\r\nu32 r = ks->extra_byte & 0x1 ;\r\nu32 w = ks->extra_byte - r;\r\nks_wrreg16(ks, KS_RXFDPR, RXFDPR_RXFPAI);\r\nks_wrreg8(ks, KS_RXQCR, (ks->rc_rxqcr | RXQCR_SDA) & 0xff);\r\nif (unlikely(r))\r\nioread8(ks->hw_addr);\r\nks_inblk(ks, buf, w + 2 + 2);\r\nks_inblk(ks, buf, ALIGN(len, 4));\r\nks_wrreg8(ks, KS_RXQCR, ks->rc_rxqcr);\r\n}\r\nstatic void ks_rcv(struct ks_net *ks, struct net_device *netdev)\r\n{\r\nu32 i;\r\nstruct type_frame_head *frame_hdr = ks->frame_head_info;\r\nstruct sk_buff *skb;\r\nks->frame_cnt = ks_rdreg16(ks, KS_RXFCTR) >> 8;\r\nfor (i = 0; i < ks->frame_cnt; i++) {\r\nframe_hdr->sts = ks_rdreg16(ks, KS_RXFHSR);\r\nframe_hdr->len = ks_rdreg16(ks, KS_RXFHBCR);\r\nframe_hdr++;\r\n}\r\nframe_hdr = ks->frame_head_info;\r\nwhile (ks->frame_cnt--) {\r\nskb = netdev_alloc_skb(netdev, frame_hdr->len + 16);\r\nif (likely(skb && (frame_hdr->sts & RXFSHR_RXFV) &&\r\n(frame_hdr->len < RX_BUF_SIZE) && frame_hdr->len)) {\r\nskb_reserve(skb, 2);\r\nks_read_qmu(ks, (u16 *)skb->data, frame_hdr->len);\r\nskb_put(skb, frame_hdr->len);\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nnetif_rx(skb);\r\n} else {\r\npr_err("%s: err:skb alloc\n", __func__);\r\nks_wrreg16(ks, KS_RXQCR, (ks->rc_rxqcr | RXQCR_RRXEF));\r\nif (skb)\r\ndev_kfree_skb_irq(skb);\r\n}\r\nframe_hdr++;\r\n}\r\n}\r\nstatic void ks_update_link_status(struct net_device *netdev, struct ks_net *ks)\r\n{\r\nu32 link_up_status;\r\nif (ks_rdreg16(ks, KS_P1SR) & P1SR_LINK_GOOD) {\r\nnetif_carrier_on(netdev);\r\nlink_up_status = true;\r\n} else {\r\nnetif_carrier_off(netdev);\r\nlink_up_status = false;\r\n}\r\nnetif_dbg(ks, link, ks->netdev,\r\n"%s: %s\n", __func__, link_up_status ? "UP" : "DOWN");\r\n}\r\nstatic irqreturn_t ks_irq(int irq, void *pw)\r\n{\r\nstruct net_device *netdev = pw;\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nu16 status;\r\nks_save_cmd_reg(ks);\r\nstatus = ks_rdreg16(ks, KS_ISR);\r\nif (unlikely(!status)) {\r\nks_restore_cmd_reg(ks);\r\nreturn IRQ_NONE;\r\n}\r\nks_wrreg16(ks, KS_ISR, status);\r\nif (likely(status & IRQ_RXI))\r\nks_rcv(ks, netdev);\r\nif (unlikely(status & IRQ_LCI))\r\nks_update_link_status(netdev, ks);\r\nif (unlikely(status & IRQ_TXI))\r\nnetif_wake_queue(netdev);\r\nif (unlikely(status & IRQ_LDI)) {\r\nu16 pmecr = ks_rdreg16(ks, KS_PMECR);\r\npmecr &= ~PMECR_WKEVT_MASK;\r\nks_wrreg16(ks, KS_PMECR, pmecr | PMECR_WKEVT_LINK);\r\n}\r\nks_restore_cmd_reg(ks);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ks_net_open(struct net_device *netdev)\r\n{\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nint err;\r\n#define KS_INT_FLAGS (IRQF_DISABLED|IRQF_TRIGGER_LOW)\r\nnetif_dbg(ks, ifup, ks->netdev, "%s - entry\n", __func__);\r\nerr = request_irq(netdev->irq, ks_irq, KS_INT_FLAGS, DRV_NAME, netdev);\r\nif (err) {\r\npr_err("Failed to request IRQ: %d: %d\n", netdev->irq, err);\r\nreturn err;\r\n}\r\nks_set_powermode(ks, PMECR_PM_NORMAL);\r\nmdelay(1);\r\nks_wrreg16(ks, KS_ISR, 0xffff);\r\nks_enable_int(ks);\r\nks_enable_qmu(ks);\r\nnetif_start_queue(ks->netdev);\r\nnetif_dbg(ks, ifup, ks->netdev, "network device up\n");\r\nreturn 0;\r\n}\r\nstatic int ks_net_stop(struct net_device *netdev)\r\n{\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nnetif_info(ks, ifdown, netdev, "shutting down\n");\r\nnetif_stop_queue(netdev);\r\nmutex_lock(&ks->lock);\r\nks_wrreg16(ks, KS_IER, 0x0000);\r\nks_wrreg16(ks, KS_ISR, 0xffff);\r\nks_disable_qmu(ks);\r\nks_set_powermode(ks, PMECR_PM_SOFTDOWN);\r\nfree_irq(netdev->irq, netdev);\r\nmutex_unlock(&ks->lock);\r\nreturn 0;\r\n}\r\nstatic void ks_write_qmu(struct ks_net *ks, u8 *pdata, u16 len)\r\n{\r\nks->txh.txw[0] = 0;\r\nks->txh.txw[1] = cpu_to_le16(len);\r\nks_wrreg8(ks, KS_RXQCR, (ks->rc_rxqcr | RXQCR_SDA) & 0xff);\r\nks_outblk(ks, ks->txh.txw, 4);\r\nks_outblk(ks, (u16 *)pdata, ALIGN(len, 4));\r\nks_wrreg8(ks, KS_RXQCR, ks->rc_rxqcr);\r\nks_wrreg16(ks, KS_TXQCR, TXQCR_METFE);\r\nwhile (ks_rdreg16(ks, KS_TXQCR) & TXQCR_METFE)\r\n;\r\n}\r\nstatic int ks_start_xmit(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nint retv = NETDEV_TX_OK;\r\nstruct ks_net *ks = netdev_priv(netdev);\r\ndisable_irq(netdev->irq);\r\nks_disable_int(ks);\r\nspin_lock(&ks->statelock);\r\nif (likely(ks_tx_fifo_space(ks) >= skb->len + 12)) {\r\nks_write_qmu(ks, skb->data, skb->len);\r\ndev_kfree_skb(skb);\r\n} else\r\nretv = NETDEV_TX_BUSY;\r\nspin_unlock(&ks->statelock);\r\nks_enable_int(ks);\r\nenable_irq(netdev->irq);\r\nreturn retv;\r\n}\r\nstatic void ks_start_rx(struct ks_net *ks)\r\n{\r\nu16 cntl;\r\ncntl = ks_rdreg16(ks, KS_RXCR1);\r\ncntl |= RXCR1_RXE ;\r\nks_wrreg16(ks, KS_RXCR1, cntl);\r\n}\r\nstatic void ks_stop_rx(struct ks_net *ks)\r\n{\r\nu16 cntl;\r\ncntl = ks_rdreg16(ks, KS_RXCR1);\r\ncntl &= ~RXCR1_RXE ;\r\nks_wrreg16(ks, KS_RXCR1, cntl);\r\n}\r\nstatic unsigned long ether_gen_crc(int length, u8 *data)\r\n{\r\nlong crc = -1;\r\nwhile (--length >= 0) {\r\nu8 current_octet = *data++;\r\nint bit;\r\nfor (bit = 0; bit < 8; bit++, current_octet >>= 1) {\r\ncrc = (crc << 1) ^\r\n((crc < 0) ^ (current_octet & 1) ?\r\nethernet_polynomial : 0);\r\n}\r\n}\r\nreturn (unsigned long)crc;\r\n}\r\nstatic void ks_set_grpaddr(struct ks_net *ks)\r\n{\r\nu8 i;\r\nu32 index, position, value;\r\nmemset(ks->mcast_bits, 0, sizeof(u8) * HW_MCAST_SIZE);\r\nfor (i = 0; i < ks->mcast_lst_size; i++) {\r\nposition = (ether_gen_crc(6, ks->mcast_lst[i]) >> 26) & 0x3f;\r\nindex = position >> 3;\r\nvalue = 1 << (position & 7);\r\nks->mcast_bits[index] |= (u8)value;\r\n}\r\nfor (i = 0; i < HW_MCAST_SIZE; i++) {\r\nif (i & 1) {\r\nks_wrreg16(ks, (u16)((KS_MAHTR0 + i) & ~1),\r\n(ks->mcast_bits[i] << 8) |\r\nks->mcast_bits[i - 1]);\r\n}\r\n}\r\n}\r\nstatic void ks_clear_mcast(struct ks_net *ks)\r\n{\r\nu16 i, mcast_size;\r\nfor (i = 0; i < HW_MCAST_SIZE; i++)\r\nks->mcast_bits[i] = 0;\r\nmcast_size = HW_MCAST_SIZE >> 2;\r\nfor (i = 0; i < mcast_size; i++)\r\nks_wrreg16(ks, KS_MAHTR0 + (2*i), 0);\r\n}\r\nstatic void ks_set_promis(struct ks_net *ks, u16 promiscuous_mode)\r\n{\r\nu16 cntl;\r\nks->promiscuous = promiscuous_mode;\r\nks_stop_rx(ks);\r\ncntl = ks_rdreg16(ks, KS_RXCR1);\r\ncntl &= ~RXCR1_FILTER_MASK;\r\nif (promiscuous_mode)\r\ncntl |= RXCR1_RXAE | RXCR1_RXINVF;\r\nelse\r\ncntl |= RXCR1_RXPAFMA;\r\nks_wrreg16(ks, KS_RXCR1, cntl);\r\nif (ks->enabled)\r\nks_start_rx(ks);\r\n}\r\nstatic void ks_set_mcast(struct ks_net *ks, u16 mcast)\r\n{\r\nu16 cntl;\r\nks->all_mcast = mcast;\r\nks_stop_rx(ks);\r\ncntl = ks_rdreg16(ks, KS_RXCR1);\r\ncntl &= ~RXCR1_FILTER_MASK;\r\nif (mcast)\r\ncntl |= (RXCR1_RXAE | RXCR1_RXMAFMA | RXCR1_RXPAFMA);\r\nelse\r\ncntl |= RXCR1_RXPAFMA;\r\nks_wrreg16(ks, KS_RXCR1, cntl);\r\nif (ks->enabled)\r\nks_start_rx(ks);\r\n}\r\nstatic void ks_set_rx_mode(struct net_device *netdev)\r\n{\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nstruct netdev_hw_addr *ha;\r\nif ((netdev->flags & IFF_PROMISC) == IFF_PROMISC)\r\nks_set_promis(ks,\r\n(u16)((netdev->flags & IFF_PROMISC) == IFF_PROMISC));\r\nelse if ((netdev->flags & IFF_ALLMULTI) == IFF_ALLMULTI)\r\nks_set_mcast(ks,\r\n(u16)((netdev->flags & IFF_ALLMULTI) == IFF_ALLMULTI));\r\nelse\r\nks_set_promis(ks, false);\r\nif ((netdev->flags & IFF_MULTICAST) && netdev_mc_count(netdev)) {\r\nif (netdev_mc_count(netdev) <= MAX_MCAST_LST) {\r\nint i = 0;\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nif (i >= MAX_MCAST_LST)\r\nbreak;\r\nmemcpy(ks->mcast_lst[i++], ha->addr, ETH_ALEN);\r\n}\r\nks->mcast_lst_size = (u8)i;\r\nks_set_grpaddr(ks);\r\n} else {\r\nks->mcast_lst_size = MAX_MCAST_LST;\r\nks_set_mcast(ks, true);\r\n}\r\n} else {\r\nks->mcast_lst_size = 0;\r\nks_clear_mcast(ks);\r\n}\r\n}\r\nstatic void ks_set_mac(struct ks_net *ks, u8 *data)\r\n{\r\nu16 *pw = (u16 *)data;\r\nu16 w, u;\r\nks_stop_rx(ks);\r\nu = *pw++;\r\nw = ((u & 0xFF) << 8) | ((u >> 8) & 0xFF);\r\nks_wrreg16(ks, KS_MARH, w);\r\nu = *pw++;\r\nw = ((u & 0xFF) << 8) | ((u >> 8) & 0xFF);\r\nks_wrreg16(ks, KS_MARM, w);\r\nu = *pw;\r\nw = ((u & 0xFF) << 8) | ((u >> 8) & 0xFF);\r\nks_wrreg16(ks, KS_MARL, w);\r\nmemcpy(ks->mac_addr, data, 6);\r\nif (ks->enabled)\r\nks_start_rx(ks);\r\n}\r\nstatic int ks_set_mac_address(struct net_device *netdev, void *paddr)\r\n{\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nstruct sockaddr *addr = paddr;\r\nu8 *da;\r\nnetdev->addr_assign_type &= ~NET_ADDR_RANDOM;\r\nmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\r\nda = (u8 *)netdev->dev_addr;\r\nks_set_mac(ks, da);\r\nreturn 0;\r\n}\r\nstatic int ks_net_ioctl(struct net_device *netdev, struct ifreq *req, int cmd)\r\n{\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nif (!netif_running(netdev))\r\nreturn -EINVAL;\r\nreturn generic_mii_ioctl(&ks->mii, if_mii(req), cmd, NULL);\r\n}\r\nstatic void ks_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *di)\r\n{\r\nstrlcpy(di->driver, DRV_NAME, sizeof(di->driver));\r\nstrlcpy(di->version, "1.00", sizeof(di->version));\r\nstrlcpy(di->bus_info, dev_name(netdev->dev.parent),\r\nsizeof(di->bus_info));\r\n}\r\nstatic u32 ks_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nreturn ks->msg_enable;\r\n}\r\nstatic void ks_set_msglevel(struct net_device *netdev, u32 to)\r\n{\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nks->msg_enable = to;\r\n}\r\nstatic int ks_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nreturn mii_ethtool_gset(&ks->mii, cmd);\r\n}\r\nstatic int ks_set_settings(struct net_device *netdev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nreturn mii_ethtool_sset(&ks->mii, cmd);\r\n}\r\nstatic u32 ks_get_link(struct net_device *netdev)\r\n{\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nreturn mii_link_ok(&ks->mii);\r\n}\r\nstatic int ks_nway_reset(struct net_device *netdev)\r\n{\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nreturn mii_nway_restart(&ks->mii);\r\n}\r\nstatic int ks_phy_reg(int reg)\r\n{\r\nswitch (reg) {\r\ncase MII_BMCR:\r\nreturn KS_P1MBCR;\r\ncase MII_BMSR:\r\nreturn KS_P1MBSR;\r\ncase MII_PHYSID1:\r\nreturn KS_PHY1ILR;\r\ncase MII_PHYSID2:\r\nreturn KS_PHY1IHR;\r\ncase MII_ADVERTISE:\r\nreturn KS_P1ANAR;\r\ncase MII_LPA:\r\nreturn KS_P1ANLPR;\r\n}\r\nreturn 0x0;\r\n}\r\nstatic int ks_phy_read(struct net_device *netdev, int phy_addr, int reg)\r\n{\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nint ksreg;\r\nint result;\r\nksreg = ks_phy_reg(reg);\r\nif (!ksreg)\r\nreturn 0x0;\r\nmutex_lock(&ks->lock);\r\nresult = ks_rdreg16(ks, ksreg);\r\nmutex_unlock(&ks->lock);\r\nreturn result;\r\n}\r\nstatic void ks_phy_write(struct net_device *netdev,\r\nint phy, int reg, int value)\r\n{\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nint ksreg;\r\nksreg = ks_phy_reg(reg);\r\nif (ksreg) {\r\nmutex_lock(&ks->lock);\r\nks_wrreg16(ks, ksreg, value);\r\nmutex_unlock(&ks->lock);\r\n}\r\n}\r\nstatic int ks_read_selftest(struct ks_net *ks)\r\n{\r\nunsigned both_done = MBIR_TXMBF | MBIR_RXMBF;\r\nint ret = 0;\r\nunsigned rd;\r\nrd = ks_rdreg16(ks, KS_MBIR);\r\nif ((rd & both_done) != both_done) {\r\nnetdev_warn(ks->netdev, "Memory selftest not finished\n");\r\nreturn 0;\r\n}\r\nif (rd & MBIR_TXMBFA) {\r\nnetdev_err(ks->netdev, "TX memory selftest fails\n");\r\nret |= 1;\r\n}\r\nif (rd & MBIR_RXMBFA) {\r\nnetdev_err(ks->netdev, "RX memory selftest fails\n");\r\nret |= 2;\r\n}\r\nnetdev_info(ks->netdev, "the selftest passes\n");\r\nreturn ret;\r\n}\r\nstatic void ks_setup(struct ks_net *ks)\r\n{\r\nu16 w;\r\nks_wrreg16(ks, KS_TXFDPR, TXFDPR_TXFPAI);\r\nks_wrreg16(ks, KS_RXFDPR, RXFDPR_RXFPAI);\r\nks_wrreg16(ks, KS_RXFCTR, 1 & RXFCTR_THRESHOLD_MASK);\r\nks->rc_rxqcr = RXQCR_CMD_CNTL;\r\nks_wrreg16(ks, KS_RXQCR, ks->rc_rxqcr);\r\nw = ks_rdreg16(ks, KS_P1MBCR);\r\nw &= ~P1MBCR_FORCE_FDX;\r\nks_wrreg16(ks, KS_P1MBCR, w);\r\nw = TXCR_TXFCE | TXCR_TXPE | TXCR_TXCRC | TXCR_TCGIP;\r\nks_wrreg16(ks, KS_TXCR, w);\r\nw = RXCR1_RXFCE | RXCR1_RXBE | RXCR1_RXUE | RXCR1_RXME | RXCR1_RXIPFCC;\r\nif (ks->promiscuous)\r\nw |= (RXCR1_RXAE | RXCR1_RXINVF);\r\nelse if (ks->all_mcast)\r\nw |= (RXCR1_RXAE | RXCR1_RXMAFMA | RXCR1_RXPAFMA);\r\nelse\r\nw |= RXCR1_RXPAFMA;\r\nks_wrreg16(ks, KS_RXCR1, w);\r\n}\r\nstatic void ks_setup_int(struct ks_net *ks)\r\n{\r\nks->rc_ier = 0x00;\r\nks_wrreg16(ks, KS_ISR, 0xffff);\r\nks->rc_ier = (IRQ_LCI | IRQ_TXI | IRQ_RXI);\r\n}\r\nstatic int ks_hw_init(struct ks_net *ks)\r\n{\r\n#define MHEADER_SIZE (sizeof(struct type_frame_head) * MAX_RECV_FRAMES)\r\nks->promiscuous = 0;\r\nks->all_mcast = 0;\r\nks->mcast_lst_size = 0;\r\nks->frame_head_info = kmalloc(MHEADER_SIZE, GFP_KERNEL);\r\nif (!ks->frame_head_info)\r\nreturn false;\r\nks_set_mac(ks, KS_DEFAULT_MAC_ADDRESS);\r\nreturn true;\r\n}\r\nstatic int __devinit ks8851_probe(struct platform_device *pdev)\r\n{\r\nint err = -ENOMEM;\r\nstruct resource *io_d, *io_c;\r\nstruct net_device *netdev;\r\nstruct ks_net *ks;\r\nu16 id, data;\r\nstruct ks8851_mll_platform_data *pdata;\r\nio_d = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nio_c = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!request_mem_region(io_d->start, resource_size(io_d), DRV_NAME))\r\ngoto err_mem_region;\r\nif (!request_mem_region(io_c->start, resource_size(io_c), DRV_NAME))\r\ngoto err_mem_region1;\r\nnetdev = alloc_etherdev(sizeof(struct ks_net));\r\nif (!netdev)\r\ngoto err_alloc_etherdev;\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\nks = netdev_priv(netdev);\r\nks->netdev = netdev;\r\nks->hw_addr = ioremap(io_d->start, resource_size(io_d));\r\nif (!ks->hw_addr)\r\ngoto err_ioremap;\r\nks->hw_addr_cmd = ioremap(io_c->start, resource_size(io_c));\r\nif (!ks->hw_addr_cmd)\r\ngoto err_ioremap1;\r\nnetdev->irq = platform_get_irq(pdev, 0);\r\nif ((int)netdev->irq < 0) {\r\nerr = netdev->irq;\r\ngoto err_get_irq;\r\n}\r\nks->pdev = pdev;\r\nmutex_init(&ks->lock);\r\nspin_lock_init(&ks->statelock);\r\nnetdev->netdev_ops = &ks_netdev_ops;\r\nnetdev->ethtool_ops = &ks_ethtool_ops;\r\nks->mii.dev = netdev;\r\nks->mii.phy_id = 1,\r\nks->mii.phy_id_mask = 1;\r\nks->mii.reg_num_mask = 0xf;\r\nks->mii.mdio_read = ks_phy_read;\r\nks->mii.mdio_write = ks_phy_write;\r\nnetdev_info(netdev, "message enable is %d\n", msg_enable);\r\nks->msg_enable = netif_msg_init(msg_enable, (NETIF_MSG_DRV |\r\nNETIF_MSG_PROBE |\r\nNETIF_MSG_LINK));\r\nks_read_config(ks);\r\nif ((ks_rdreg16(ks, KS_CIDER) & ~CIDER_REV_MASK) != CIDER_ID) {\r\nnetdev_err(netdev, "failed to read device ID\n");\r\nerr = -ENODEV;\r\ngoto err_register;\r\n}\r\nif (ks_read_selftest(ks)) {\r\nnetdev_err(netdev, "failed to read device ID\n");\r\nerr = -ENODEV;\r\ngoto err_register;\r\n}\r\nerr = register_netdev(netdev);\r\nif (err)\r\ngoto err_register;\r\nplatform_set_drvdata(pdev, netdev);\r\nks_soft_reset(ks, GRR_GSR);\r\nks_hw_init(ks);\r\nks_disable_qmu(ks);\r\nks_setup(ks);\r\nks_setup_int(ks);\r\ndata = ks_rdreg16(ks, KS_OBCR);\r\nks_wrreg16(ks, KS_OBCR, data | OBCR_ODS_16MA);\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\nnetdev_err(netdev, "No platform data\n");\r\nerr = -ENODEV;\r\ngoto err_pdata;\r\n}\r\nmemcpy(ks->mac_addr, pdata->mac_addr, 6);\r\nif (!is_valid_ether_addr(ks->mac_addr)) {\r\neth_random_addr(ks->mac_addr);\r\nnetdev_info(netdev, "Using random mac address\n");\r\n}\r\nnetdev_info(netdev, "Mac address is: %pM\n", ks->mac_addr);\r\nmemcpy(netdev->dev_addr, ks->mac_addr, 6);\r\nks_set_mac(ks, netdev->dev_addr);\r\nid = ks_rdreg16(ks, KS_CIDER);\r\nnetdev_info(netdev, "Found chip, family: 0x%x, id: 0x%x, rev: 0x%x\n",\r\n(id >> 8) & 0xff, (id >> 4) & 0xf, (id >> 1) & 0x7);\r\nreturn 0;\r\nerr_pdata:\r\nunregister_netdev(netdev);\r\nerr_register:\r\nerr_get_irq:\r\niounmap(ks->hw_addr_cmd);\r\nerr_ioremap1:\r\niounmap(ks->hw_addr);\r\nerr_ioremap:\r\nfree_netdev(netdev);\r\nerr_alloc_etherdev:\r\nrelease_mem_region(io_c->start, resource_size(io_c));\r\nerr_mem_region1:\r\nrelease_mem_region(io_d->start, resource_size(io_d));\r\nerr_mem_region:\r\nreturn err;\r\n}\r\nstatic int __devexit ks8851_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *netdev = platform_get_drvdata(pdev);\r\nstruct ks_net *ks = netdev_priv(netdev);\r\nstruct resource *iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nkfree(ks->frame_head_info);\r\nunregister_netdev(netdev);\r\niounmap(ks->hw_addr);\r\nfree_netdev(netdev);\r\nrelease_mem_region(iomem->start, resource_size(iomem));\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
