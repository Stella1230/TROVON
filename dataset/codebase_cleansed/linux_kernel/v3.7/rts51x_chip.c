static int check_sd_speed_prior(u32 sd_speed_prior)\r\n{\r\nint i, fake_para = 0;\r\nfor (i = 0; i < 4; i++) {\r\nu8 tmp = (u8) (sd_speed_prior >> (i * 8));\r\nif ((tmp < 0x01) || (tmp > 0x04)) {\r\nfake_para = 1;\r\nbreak;\r\n}\r\n}\r\nreturn !fake_para;\r\n}\r\nint rts51x_reset_chip(struct rts51x_chip *chip)\r\n{\r\nint retval;\r\nif (CHECK_PKG(chip, LQFP48)) {\r\nRTS51X_WRITE_REG(chip, CARD_PWR_CTL, LDO3318_PWR_MASK,\r\nLDO_SUSPEND);\r\nRTS51X_WRITE_REG(chip, CARD_PWR_CTL, FORCE_LDO_POWERB,\r\nFORCE_LDO_POWERB);\r\nRTS51X_WRITE_REG(chip, CARD_PULL_CTL1, 0x30, 0x10);\r\nRTS51X_WRITE_REG(chip, CARD_PULL_CTL5, 0x03, 0x01);\r\nRTS51X_WRITE_REG(chip, CARD_PULL_CTL6, 0x0C, 0x04);\r\n}\r\nif (chip->asic_code) {\r\nRTS51X_WRITE_REG(chip, SYS_DUMMY0, NYET_MSAK, NYET_EN);\r\nRTS51X_WRITE_REG(chip, CD_DEGLITCH_WIDTH, 0xFF, 0x08);\r\nrts51x_write_register(chip, CD_DEGLITCH_EN, XD_CD_DEGLITCH_EN,\r\n0x00);\r\nrts51x_write_register(chip, SD30_DRIVE_SEL, SD30_DRIVE_MASK,\r\nchip->option.sd30_pad_drive);\r\nrts51x_write_register(chip, CARD_DRIVE_SEL, SD20_DRIVE_MASK,\r\nchip->option.sd20_pad_drive);\r\nif (chip->rts5179)\r\nrts51x_write_register(chip, CARD_PULL_CTL5, 0x03, 0x01);\r\nif (CHECK_PKG(chip, LQFP48)) {\r\nrts51x_write_register(chip, CARD_PULL_CTL3,\r\n0x80, 0x80);\r\nrts51x_write_register(chip, CARD_PULL_CTL6,\r\n0xf0, 0xA0);\r\n} else {\r\nrts51x_write_register(chip, CARD_PULL_CTL1,\r\n0x30, 0x20);\r\nrts51x_write_register(chip, CARD_PULL_CTL3,\r\n0x80, 0x80);\r\nrts51x_write_register(chip, CARD_PULL_CTL6,\r\n0x0c, 0x08);\r\n}\r\n}\r\nif (chip->option.sd_ctl & SUPPORT_UHS50_MMC44) {\r\nSET_UHS50(chip);\r\nRTS51X_DEBUGP("option enable UHS50&MMC44,sd_ctl:0x%x\n",\r\nchip->option.sd_ctl);\r\n} else {\r\nif ((CHECK_PID(chip, 0x0139) && CHECK_PKG(chip, LQFP48))\r\n|| chip->rts5179) {\r\nSET_UHS50(chip);\r\nRTS51X_DEBUGP("PID enable UHS50&MMC44\n");\r\n} else {\r\nCLEAR_UHS50(chip);\r\nRTS51X_DEBUGP("PID disable UHS50&MMC44\n");\r\n}\r\n}\r\nif (chip->option.ms_errreg_fix && (chip->ic_version > 1))\r\nrts51x_write_register(chip, 0xFD4D, 0x01, 0x01);\r\nretval = rts51x_write_phy_register(chip, 0xC2, 0x7C);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_GPIO, GPIO_OE, GPIO_OE);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, CARD_DMA1_CTL,\r\nEXTEND_DMA1_ASYNC_SIGNAL, EXTEND_DMA1_ASYNC_SIGNAL);\r\nretval = rts51x_send_cmd(chip, MODE_C, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\n#ifdef SUPPORT_OCP\r\nif (chip->asic_code) {\r\nrts51x_write_register(chip, OCPCTL, MS_OCP_DETECT_EN,\r\nMS_OCP_DETECT_EN);\r\nRTS51X_DEBUGP("Enable OCP detect!\n");\r\n}\r\n#endif\r\nif (chip->option.FT2_fast_mode) {\r\ncard_power_on(chip, SD_CARD | MS_CARD | XD_CARD);\r\nwait_timeout(10);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_init_chip(struct rts51x_chip *chip)\r\n{\r\nint retval;\r\nu8 val;\r\nchip->max_lun = 0;\r\nchip->cur_clk = 0;\r\nchip->cur_card = 0;\r\nchip->card2lun[XD_CARD] = 0;\r\nchip->card2lun[SD_CARD] = 0;\r\nchip->card2lun[MS_CARD] = 0;\r\nchip->card_ejected = 0;\r\nchip->lun2card[0] = XD_CARD | SD_CARD | MS_CARD;\r\n#ifdef CLOSE_SSC_POWER\r\nrts51x_write_register(chip, FPDCTL, SSC_POWER_MASK, SSC_POWER_ON);\r\nudelay(100);\r\nrts51x_write_register(chip, CLK_DIV, CLK_CHANGE, 0x00);\r\n#endif\r\nRTS51X_SET_STAT(chip, STAT_RUN);\r\nRTS51X_READ_REG(chip, HW_VERSION, &val);\r\nRTS51X_DEBUGP("HW_VERSION: 0x%x\n", val);\r\nif (val & FPGA_VER) {\r\nchip->asic_code = 0;\r\nRTS51X_DEBUGP("FPGA!\n");\r\n} else {\r\nchip->asic_code = 1;\r\nRTS51X_DEBUGP("ASIC!\n");\r\n}\r\nchip->ic_version = val & HW_VER_MASK;\r\nif (!check_sd_speed_prior(chip->option.sd_speed_prior))\r\nchip->option.sd_speed_prior = 0x01020403;\r\nRTS51X_DEBUGP("sd_speed_prior = 0x%08x\n",\r\nchip->option.sd_speed_prior);\r\nRTS51X_READ_REG(chip, CARD_SHARE_MODE, &val);\r\nif (val & CARD_SHARE_LQFP_SEL) {\r\nchip->package = LQFP48;\r\nRTS51X_DEBUGP("Package: LQFP48\n");\r\n} else {\r\nchip->package = QFN24;\r\nRTS51X_DEBUGP("Package: QFN24\n");\r\n}\r\nRTS51X_READ_REG(chip, HS_USB_STAT, &val);\r\nif (val & USB_HI_SPEED) {\r\nchip->usb_speed = USB_20;\r\nRTS51X_DEBUGP("USB High Speed\n");\r\n} else {\r\nchip->usb_speed = USB_11;\r\nRTS51X_DEBUGP("USB Full Speed\n");\r\n}\r\nRTS51X_READ_REG(chip, CFG_MODE_1, &val);\r\nif (val & RTS5179) {\r\nchip->rts5179 = 1;\r\nRTS51X_DEBUGP("device is rts5179\n");\r\n} else {\r\nchip->rts5179 = 0;\r\n}\r\nretval = rts51x_reset_chip(chip);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_release_chip(struct rts51x_chip *chip)\r\n{\r\nxd_free_l2p_tbl(chip);\r\nms_free_l2p_tbl(chip);\r\nchip->card_ready = 0;\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic inline void rts51x_blink_led(struct rts51x_chip *chip)\r\n{\r\nif (chip->card_ready) {\r\nif (chip->led_toggle_counter <\r\nchip->option.led_toggle_interval) {\r\nchip->led_toggle_counter++;\r\n} else {\r\nchip->led_toggle_counter = 0;\r\ntoggle_gpio(chip, LED_GPIO);\r\n}\r\n}\r\n}\r\nstatic void rts51x_auto_delink_cmd(struct rts51x_chip *chip)\r\n{\r\nrts51x_write_register(chip, AUTO_DELINK_EN,\r\nAUTO_DELINK, AUTO_DELINK);\r\n}\r\nstatic void rts51x_auto_delink_force_cmd(struct rts51x_chip *chip)\r\n{\r\nrts51x_write_register(chip, AUTO_DELINK_EN,\r\nAUTO_DELINK | FORCE_DELINK,\r\nAUTO_DELINK | FORCE_DELINK);\r\n}\r\nstatic void rts51x_auto_delink_polling_cycle(struct rts51x_chip *chip)\r\n{\r\nif (chip->auto_delink_counter <=\r\nchip->option.delink_delay * 2) {\r\nif (chip->auto_delink_counter ==\r\nchip->option.delink_delay) {\r\nif (chip->card_exist) {\r\nif (!chip->card_ejected) {\r\nRTS51X_DEBUGP("False card inserted,"\r\n"do force delink\n");\r\nrts51x_auto_delink_force_cmd(chip);\r\nchip->auto_delink_counter =\r\nchip->option.delink_delay * 2 + 1;\r\n}\r\n} else {\r\nRTS51X_DEBUGP("No card inserted, do delink\n");\r\nrts51x_auto_delink_cmd(chip);\r\n}\r\n}\r\nif (chip->auto_delink_counter ==\r\nchip->option.delink_delay * 2) {\r\nRTS51X_DEBUGP("Try to do force delink\n");\r\nrts51x_auto_delink_force_cmd(chip);\r\n}\r\nchip->auto_delink_counter++;\r\n}\r\n}\r\nstatic void rts51x_auto_delink(struct rts51x_chip *chip)\r\n{\r\nrts51x_auto_delink_polling_cycle(chip);\r\n}\r\nstatic void rts51x_auto_delink(struct rts51x_chip *chip)\r\n{\r\n}\r\nvoid rts51x_polling_func(struct rts51x_chip *chip)\r\n{\r\nrts51x_init_cards(chip);\r\n#ifdef SUPPORT_OCP\r\nif ((chip->ocp_stat & (MS_OCP_NOW | MS_OCP_EVER)) &&\r\n(chip->card_exist)) {\r\nrts51x_prepare_run(chip);\r\nif (chip->card_exist & SD_CARD)\r\nrts51x_write_register(chip, CARD_OE, SD_OUTPUT_EN, 0);\r\nelse if (chip->card_exist & MS_CARD)\r\nrts51x_write_register(chip, CARD_OE, MS_OUTPUT_EN, 0);\r\nelse if (chip->card_exist & XD_CARD)\r\nrts51x_write_register(chip, CARD_OE, XD_OUTPUT_EN, 0);\r\n}\r\n#endif\r\nif (chip->idle_counter < IDLE_MAX_COUNT) {\r\nchip->idle_counter++;\r\n} else {\r\nif (!RTS51X_CHK_STAT(chip, STAT_IDLE)) {\r\nRTS51X_DEBUGP("Idle state!\n");\r\nRTS51X_SET_STAT(chip, STAT_IDLE);\r\nchip->led_toggle_counter = 0;\r\nif (chip->option.led_always_on\r\n&& (chip->card_exist &\r\n(SD_CARD | MS_CARD | XD_CARD))\r\n&& (!chip->card_ejected)) {\r\nturn_on_led(chip, LED_GPIO);\r\n} else {\r\nif (chip->rts5179) {\r\nrts51x_ep0_write_register(chip,\r\nCARD_GPIO,\r\n0x03, 0x00);\r\n} else {\r\nturn_off_led(chip, LED_GPIO);\r\n}\r\n}\r\n#ifdef CLOSE_SSC_POWER\r\nif (!chip->card_ready) {\r\nrts51x_write_register(chip, CLK_DIV, CLK_CHANGE,\r\nCLK_CHANGE);\r\nrts51x_write_register(chip, FPDCTL,\r\nSSC_POWER_MASK,\r\nSSC_POWER_DOWN);\r\nRTS51X_DEBUGP("Close SSC clock power!\n");\r\n}\r\n#endif\r\n}\r\n}\r\nswitch (RTS51X_GET_STAT(chip)) {\r\ncase STAT_RUN:\r\nrts51x_blink_led(chip);\r\ndo_remaining_work(chip);\r\nbreak;\r\ncase STAT_IDLE:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (chip->option.auto_delink_en && !chip->card_ready)\r\nrts51x_auto_delink(chip);\r\nelse\r\nchip->auto_delink_counter = 0;\r\n}\r\nvoid rts51x_add_cmd(struct rts51x_chip *chip,\r\nu8 cmd_type, u16 reg_addr, u8 mask, u8 data)\r\n{\r\nint i;\r\nif (chip->cmd_idx < ((CMD_BUF_LEN - CMD_OFFSET) / 4)) {\r\ni = CMD_OFFSET + chip->cmd_idx * 4;\r\nchip->cmd_buf[i++] =\r\n((cmd_type & 0x03) << 6) | (u8) ((reg_addr >> 8) & 0x3F);\r\nchip->cmd_buf[i++] = (u8) reg_addr;\r\nchip->cmd_buf[i++] = mask;\r\nchip->cmd_buf[i++] = data;\r\nchip->cmd_idx++;\r\n}\r\n}\r\nint rts51x_send_cmd(struct rts51x_chip *chip, u8 flag, int timeout)\r\n{\r\nint result;\r\nchip->cmd_buf[CNT_H] = (u8) (chip->cmd_idx >> 8);\r\nchip->cmd_buf[CNT_L] = (u8) (chip->cmd_idx);\r\nchip->cmd_buf[STAGE_FLAG] = flag;\r\nresult = rts51x_transfer_data_rcc(chip, SND_BULK_PIPE(chip),\r\n(void *)(chip->cmd_buf),\r\nchip->cmd_idx * 4 + CMD_OFFSET,\r\n0, NULL, timeout, MODE_C);\r\nif (result != STATUS_SUCCESS)\r\nTRACE_RET(chip, result);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_get_rsp(struct rts51x_chip *chip, int rsp_len, int timeout)\r\n{\r\nint result;\r\nif (rsp_len <= 0)\r\nTRACE_RET(chip, STATUS_ERROR);\r\nif (rsp_len % 4)\r\nrsp_len += (4 - rsp_len % 4);\r\nresult = rts51x_transfer_data_rcc(chip, RCV_BULK_PIPE(chip),\r\n(void *)chip->rsp_buf, rsp_len,\r\n0, NULL, timeout, STAGE_R);\r\nif (result != STATUS_SUCCESS)\r\nTRACE_RET(chip, result);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_get_card_status(struct rts51x_chip *chip, u16 *status)\r\n{\r\nint retval;\r\nu16 val;\r\n#ifdef GET_CARD_STATUS_USING_EPC\r\nretval = rts51x_get_epc_status(chip, &val);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\n#else\r\nretval = rts51x_ctrl_transfer(chip, RCV_CTRL_PIPE(chip), 0x02, 0xC0,\r\n0, 0, &val, 2, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\n#endif\r\nif (status)\r\n*status = val;\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_write_register(struct rts51x_chip *chip, u16 addr, u8 mask, u8 data)\r\n{\r\nint retval;\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, addr, mask, data);\r\nretval = rts51x_send_cmd(chip, MODE_C, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_read_register(struct rts51x_chip *chip, u16 addr, u8 *data)\r\n{\r\nint retval;\r\nif (data)\r\n*data = 0;\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, READ_REG_CMD, addr, 0, 0);\r\nretval = rts51x_send_cmd(chip, MODE_CR, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nretval = rts51x_get_rsp(chip, 1, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nif (data)\r\n*data = chip->rsp_buf[0];\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_ep0_write_register(struct rts51x_chip *chip, u16 addr, u8 mask,\r\nu8 data)\r\n{\r\nint retval;\r\nu16 value = 0, index = 0;\r\nvalue |= (u16) (3 & 0x03) << 14;\r\nvalue |= (u16) (addr & 0x3FFF);\r\nindex |= (u16) mask << 8;\r\nindex |= (u16) data;\r\nretval = rts51x_ctrl_transfer(chip, SND_CTRL_PIPE(chip), 0x00, 0x40,\r\ncpu_to_be16(value), cpu_to_be16(index),\r\nNULL, 0, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_ep0_read_register(struct rts51x_chip *chip, u16 addr, u8 *data)\r\n{\r\nint retval;\r\nu16 value = 0;\r\nu8 val;\r\nif (data)\r\n*data = 0;\r\nvalue |= (u16) (2 & 0x03) << 14;\r\nvalue |= (u16) (addr & 0x3FFF);\r\nretval = rts51x_ctrl_transfer(chip, RCV_CTRL_PIPE(chip), 0x00, 0xC0,\r\ncpu_to_be16(value), 0, &val, 1, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nif (data)\r\n*data = val;\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_seq_write_register(struct rts51x_chip *chip, u16 addr, u16 len,\r\nu8 *data)\r\n{\r\nint result;\r\nu16 cmd_len = len + 12;\r\nif (!data)\r\nTRACE_RET(chip, STATUS_ERROR);\r\ncmd_len = (cmd_len <= CMD_BUF_LEN) ? cmd_len : CMD_BUF_LEN;\r\nif (cmd_len % 4)\r\ncmd_len += (4 - cmd_len % 4);\r\nchip->cmd_buf[0] = 'R';\r\nchip->cmd_buf[1] = 'T';\r\nchip->cmd_buf[2] = 'C';\r\nchip->cmd_buf[3] = 'R';\r\nchip->cmd_buf[PACKET_TYPE] = SEQ_WRITE;\r\nchip->cmd_buf[5] = (u8) (len >> 8);\r\nchip->cmd_buf[6] = (u8) len;\r\nchip->cmd_buf[STAGE_FLAG] = 0;\r\nchip->cmd_buf[8] = (u8) (addr >> 8);\r\nchip->cmd_buf[9] = (u8) addr;\r\nmemcpy(chip->cmd_buf + 12, data, len);\r\nresult = rts51x_transfer_data_rcc(chip, SND_BULK_PIPE(chip),\r\n(void *)(chip->cmd_buf), cmd_len, 0,\r\nNULL, 100, MODE_C);\r\nif (result != STATUS_SUCCESS)\r\nTRACE_RET(chip, result);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_seq_read_register(struct rts51x_chip *chip, u16 addr, u16 len,\r\nu8 *data)\r\n{\r\nint result;\r\nu16 rsp_len;\r\nif (!data)\r\nTRACE_RET(chip, STATUS_ERROR);\r\nif (len % 4)\r\nrsp_len = len + (4 - len % 4);\r\nelse\r\nrsp_len = len;\r\nchip->cmd_buf[0] = 'R';\r\nchip->cmd_buf[1] = 'T';\r\nchip->cmd_buf[2] = 'C';\r\nchip->cmd_buf[3] = 'R';\r\nchip->cmd_buf[PACKET_TYPE] = SEQ_READ;\r\nchip->cmd_buf[5] = (u8) (rsp_len >> 8);\r\nchip->cmd_buf[6] = (u8) rsp_len;\r\nchip->cmd_buf[STAGE_FLAG] = STAGE_R;\r\nchip->cmd_buf[8] = (u8) (addr >> 8);\r\nchip->cmd_buf[9] = (u8) addr;\r\nresult = rts51x_transfer_data_rcc(chip, SND_BULK_PIPE(chip),\r\n(void *)(chip->cmd_buf), 12, 0, NULL,\r\n100, MODE_C);\r\nif (result != STATUS_SUCCESS)\r\nTRACE_RET(chip, result);\r\nresult = rts51x_transfer_data_rcc(chip, RCV_BULK_PIPE(chip),\r\n(void *)data, rsp_len, 0, NULL, 100,\r\nSTAGE_DI);\r\nif (result != STATUS_SUCCESS)\r\nTRACE_RET(chip, result);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_read_ppbuf(struct rts51x_chip *chip, u8 *buf, int buf_len)\r\n{\r\nint retval;\r\nif (!buf)\r\nTRACE_RET(chip, STATUS_ERROR);\r\nretval =\r\nrts51x_seq_read_register(chip, PPBUF_BASE2, (u16) buf_len, buf);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_write_ppbuf(struct rts51x_chip *chip, u8 *buf, int buf_len)\r\n{\r\nint retval;\r\nif (!buf)\r\nTRACE_RET(chip, STATUS_ERROR);\r\nretval =\r\nrts51x_seq_write_register(chip, PPBUF_BASE2, (u16) buf_len, buf);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_write_phy_register(struct rts51x_chip *chip, u8 addr, u8 val)\r\n{\r\nint retval;\r\nRTS51X_DEBUGP("Write 0x%x to phy register 0x%x\n", val, addr);\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VSTAIN, 0xFF, val);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VCONTROL, 0xFF, addr & 0x0F);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x01);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VCONTROL, 0xFF,\r\n(addr >> 4) & 0x0F);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x01);\r\nretval = rts51x_send_cmd(chip, MODE_C, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_read_phy_register(struct rts51x_chip *chip, u8 addr, u8 *val)\r\n{\r\nint retval;\r\nRTS51X_DEBUGP("Read from phy register 0x%x\n", addr);\r\nrts51x_init_cmd(chip);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VCONTROL, 0xFF, 0x07);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x01);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VCONTROL, 0xFF,\r\n(addr >> 4) & 0x0F);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x01);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VCONTROL, 0xFF, addr & 0x0F);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrts51x_add_cmd(chip, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x01);\r\nrts51x_add_cmd(chip, READ_REG_CMD, HS_VSTAOUT, 0, 0);\r\nretval = rts51x_send_cmd(chip, MODE_CR, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nretval = rts51x_get_rsp(chip, 1, 100);\r\nif (retval != STATUS_SUCCESS)\r\nTRACE_RET(chip, retval);\r\nif (val)\r\n*val = chip->rsp_buf[0];\r\nRTS51X_DEBUGP("Return value: 0x%x\n", chip->rsp_buf[0]);\r\nreturn STATUS_SUCCESS;\r\n}\r\nvoid rts51x_do_before_power_down(struct rts51x_chip *chip)\r\n{\r\nRTS51X_DEBUGP("rts51x_do_before_power_down\n");\r\nrts51x_prepare_run(chip);\r\nrts51x_release_cards(chip);\r\nif (chip->rts5179)\r\nrts51x_ep0_write_register(chip, CARD_GPIO, 0x03, 0x00);\r\nelse\r\nturn_off_led(chip, LED_GPIO);\r\nchip->cur_clk = 0;\r\nchip->card_exist = 0;\r\nchip->cur_card = 0;\r\nif (chip->asic_code) {\r\nif (CHECK_PKG(chip, LQFP48)) {\r\nrts51x_write_register(chip, CARD_PULL_CTL3, 0x80, 0x00);\r\nrts51x_write_register(chip, CARD_PULL_CTL6, 0xf0, 0x50);\r\n} else {\r\nrts51x_write_register(chip, CARD_PULL_CTL1, 0x30, 0x10);\r\nrts51x_write_register(chip, CARD_PULL_CTL3, 0x80, 0x00);\r\nrts51x_write_register(chip, CARD_PULL_CTL6, 0x0c, 0x04);\r\n}\r\n}\r\nif (CHECK_PKG(chip, LQFP48))\r\nrts51x_write_register(chip, CARD_PWR_CTL, LDO3318_PWR_MASK,\r\nLDO_OFF);\r\n}\r\nvoid rts51x_clear_hw_error(struct rts51x_chip *chip)\r\n{\r\nrts51x_ep0_write_register(chip, SFSM_ED, 0xf8, 0xf8);\r\n}\r\nvoid rts51x_prepare_run(struct rts51x_chip *chip)\r\n{\r\n#ifdef CLOSE_SSC_POWER\r\nif (RTS51X_CHK_STAT(chip, STAT_IDLE) && (!chip->card_ready)) {\r\nrts51x_write_register(chip, FPDCTL, SSC_POWER_MASK,\r\nSSC_POWER_ON);\r\nudelay(100);\r\nRTS51X_DEBUGP("Open SSC clock power.\n");\r\nrts51x_write_register(chip, CLK_DIV, CLK_CHANGE, 0x00);\r\n}\r\n#endif\r\n}\r\nvoid rts51x_trace_msg(struct rts51x_chip *chip, unsigned char *buf, int clear)\r\n{\r\nunsigned char *ptr;\r\nint i, msg_cnt;\r\nif (!buf)\r\nreturn;\r\nptr = buf;\r\nif (chip->trace_msg[chip->msg_idx].valid)\r\nmsg_cnt = TRACE_ITEM_CNT;\r\nelse\r\nmsg_cnt = chip->msg_idx;\r\n*(ptr++) = (u8) (msg_cnt >> 24);\r\n*(ptr++) = (u8) (msg_cnt >> 16);\r\n*(ptr++) = (u8) (msg_cnt >> 8);\r\n*(ptr++) = (u8) msg_cnt;\r\nRTS51X_DEBUGP("Trace message count is %d\n", msg_cnt);\r\nfor (i = 1; i <= msg_cnt; i++) {\r\nint j, idx;\r\nidx = chip->msg_idx - i;\r\nif (idx < 0)\r\nidx += TRACE_ITEM_CNT;\r\n*(ptr++) = (u8) (chip->trace_msg[idx].line >> 8);\r\n*(ptr++) = (u8) (chip->trace_msg[idx].line);\r\nfor (j = 0; j < MSG_FUNC_LEN; j++)\r\n*(ptr++) = chip->trace_msg[idx].func[j];\r\nfor (j = 0; j < MSG_FILE_LEN; j++)\r\n*(ptr++) = chip->trace_msg[idx].file[j];\r\nfor (j = 0; j < TIME_VAL_LEN; j++)\r\n*(ptr++) = chip->trace_msg[idx].timeval_buf[j];\r\n}\r\nif (clear) {\r\nchip->msg_idx = 0;\r\nfor (i = 0; i < TRACE_ITEM_CNT; i++)\r\nchip->trace_msg[i].valid = 0;\r\n}\r\n}\r\nvoid rts51x_pp_status(struct rts51x_chip *chip, unsigned int lun, u8 *status,\r\nu8 status_len)\r\n{\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nu8 card = get_lun_card(chip, lun);\r\n#ifdef SUPPORT_OC\r\nu8 oc_now_mask = 0, oc_ever_mask = 0;\r\n#endif\r\nif (!status || (status_len < 32))\r\nreturn;\r\nstatus[0] = (u8) RTS51X_GET_PID(chip);\r\nstatus[1] = (u8) (chip->ic_version);\r\nif (chip->option.auto_delink_en)\r\nstatus[2] = 0x10;\r\nelse\r\nstatus[2] = 0x00;\r\nstatus[3] = 20;\r\nstatus[4] = 10;\r\nstatus[5] = 05;\r\nstatus[6] = 21;\r\nif (chip->card_wp)\r\nstatus[7] = 0x20;\r\nelse\r\nstatus[7] = 0x00;\r\n#ifdef SUPPORT_OC\r\nstatus[8] = 0;\r\noc_now_mask = MS_OCP_NOW;\r\noc_ever_mask = MS_OCP_EVER;\r\nif (chip->ocp_stat & oc_now_mask)\r\nstatus[8] |= 0x02;\r\nif (chip->ocp_stat & oc_ever_mask)\r\nstatus[8] |= 0x01;\r\n#endif\r\nif (card == SD_CARD) {\r\nif (CHK_SD(sd_card)) {\r\nif (CHK_SD_HCXC(sd_card)) {\r\nif (sd_card->capacity > 0x4000000)\r\nstatus[0x0E] = 0x02;\r\nelse\r\nstatus[0x0E] = 0x01;\r\n} else {\r\nstatus[0x0E] = 0x00;\r\n}\r\nif (CHK_SD_SDR104(sd_card))\r\nstatus[0x0F] = 0x03;\r\nelse if (CHK_SD_DDR50(sd_card))\r\nstatus[0x0F] = 0x04;\r\nelse if (CHK_SD_SDR50(sd_card))\r\nstatus[0x0F] = 0x02;\r\nelse if (CHK_SD_HS(sd_card))\r\nstatus[0x0F] = 0x01;\r\nelse\r\nstatus[0x0F] = 0x00;\r\n} else {\r\nif (CHK_MMC_SECTOR_MODE(sd_card))\r\nstatus[0x0E] = 0x01;\r\nelse\r\nstatus[0x0E] = 0x00;\r\nif (CHK_MMC_DDR52(sd_card))\r\nstatus[0x0F] = 0x03;\r\nelse if (CHK_MMC_52M(sd_card))\r\nstatus[0x0F] = 0x02;\r\nelse if (CHK_MMC_26M(sd_card))\r\nstatus[0x0F] = 0x01;\r\nelse\r\nstatus[0x0F] = 0x00;\r\n}\r\n} else if (card == MS_CARD) {\r\nif (CHK_MSPRO(ms_card)) {\r\nif (CHK_MSXC(ms_card))\r\nstatus[0x0E] = 0x01;\r\nelse\r\nstatus[0x0E] = 0x00;\r\nif (CHK_HG8BIT(ms_card))\r\nstatus[0x0F] = 0x01;\r\nelse\r\nstatus[0x0F] = 0x00;\r\n}\r\n}\r\nstatus[0x18] = 0x8A;\r\nstatus[0x1A] = 0x28;\r\nstatus[0x1A] = 0x28;\r\n}\r\nvoid rts51x_read_status(struct rts51x_chip *chip, unsigned int lun,\r\nu8 *rts51x_status, u8 status_len)\r\n{\r\nif (!rts51x_status || (status_len < 16))\r\nreturn;\r\nrts51x_status[0] = (u8) (RTS51X_GET_VID(chip) >> 8);\r\nrts51x_status[1] = (u8) RTS51X_GET_VID(chip);\r\nrts51x_status[2] = (u8) (RTS51X_GET_PID(chip) >> 8);\r\nrts51x_status[3] = (u8) RTS51X_GET_PID(chip);\r\nrts51x_status[4] = (u8) lun;\r\nif (chip->card_exist) {\r\nif (chip->card_exist & XD_CARD)\r\nrts51x_status[5] = 4;\r\nelse if (chip->card_exist & SD_CARD)\r\nrts51x_status[5] = 2;\r\nelse if (chip->card_exist & MS_CARD)\r\nrts51x_status[5] = 3;\r\nelse\r\nrts51x_status[5] = 7;\r\n} else {\r\nrts51x_status[5] = 7;\r\n}\r\nrts51x_status[6] = 1;\r\nrts51x_status[7] = (u8) RTS51X_GET_PID(chip);\r\nrts51x_status[8] = chip->ic_version;\r\nif (check_card_exist(chip, lun))\r\nrts51x_status[9] = 1;\r\nelse\r\nrts51x_status[9] = 0;\r\nrts51x_status[10] = 1;\r\nrts51x_status[11] = XD_CARD | SD_CARD | MS_CARD;\r\nif (check_card_ready(chip, lun))\r\nrts51x_status[12] = 1;\r\nelse\r\nrts51x_status[12] = 0;\r\nif (get_lun_card(chip, lun) == XD_CARD) {\r\nrts51x_status[13] = 0x40;\r\n} else if (get_lun_card(chip, lun) == SD_CARD) {\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nrts51x_status[13] = 0x20;\r\nif (CHK_SD(sd_card)) {\r\nif (CHK_SD_HCXC(sd_card))\r\nrts51x_status[13] |= 0x04;\r\nif (CHK_SD_HS(sd_card))\r\nrts51x_status[13] |= 0x02;\r\n} else {\r\nrts51x_status[13] |= 0x08;\r\nif (CHK_MMC_52M(sd_card))\r\nrts51x_status[13] |= 0x02;\r\nif (CHK_MMC_SECTOR_MODE(sd_card))\r\nrts51x_status[13] |= 0x04;\r\n}\r\n} else if (get_lun_card(chip, lun) == MS_CARD) {\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nif (CHK_MSPRO(ms_card)) {\r\nrts51x_status[13] = 0x38;\r\nif (CHK_HG8BIT(ms_card))\r\nrts51x_status[13] |= 0x04;\r\n#ifdef SUPPORT_MSXC\r\nif (CHK_MSXC(ms_card))\r\nrts51x_status[13] |= 0x01;\r\n#endif\r\n} else {\r\nrts51x_status[13] = 0x30;\r\n}\r\n} else {\r\nrts51x_status[13] = 0x70;\r\n}\r\nrts51x_status[14] = 0x78;\r\nrts51x_status[15] = 0x82;\r\n}\r\nint rts51x_transfer_data_rcc(struct rts51x_chip *chip, unsigned int pipe,\r\nvoid *buf, unsigned int len, int use_sg,\r\nunsigned int *act_len, int timeout, u8 stage_flag)\r\n{\r\nint retval;\r\nretval =\r\nrts51x_transfer_data(chip, pipe, buf, len, use_sg, act_len,\r\ntimeout);\r\nreturn retval;\r\n}
