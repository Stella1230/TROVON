void __init setup_olpc_ofw_pgd(void)\r\n{\r\npgd_t *base, *ofw_pde;\r\nif (!olpc_ofw_cif)\r\nreturn;\r\nbase = early_ioremap(olpc_ofw_pgd, sizeof(olpc_ofw_pgd) * PTRS_PER_PGD);\r\nif (!base) {\r\nprintk(KERN_ERR "failed to remap OFW's pgd - disabling OFW!\n");\r\nolpc_ofw_cif = NULL;\r\nreturn;\r\n}\r\nofw_pde = &base[OLPC_OFW_PDE_NR];\r\nset_pgd(&swapper_pg_dir[OLPC_OFW_PDE_NR], *ofw_pde);\r\nearly_iounmap(base, sizeof(olpc_ofw_pgd) * PTRS_PER_PGD);\r\n}\r\nint __olpc_ofw(const char *name, int nr_args, const void **args, int nr_res,\r\nvoid **res)\r\n{\r\nint ofw_args[MAXARGS + 3];\r\nunsigned long flags;\r\nint ret, i, *p;\r\nBUG_ON(nr_args + nr_res > MAXARGS);\r\nif (!olpc_ofw_cif)\r\nreturn -EIO;\r\nofw_args[0] = (int)name;\r\nofw_args[1] = nr_args;\r\nofw_args[2] = nr_res;\r\np = &ofw_args[3];\r\nfor (i = 0; i < nr_args; i++, p++)\r\n*p = (int)args[i];\r\nspin_lock_irqsave(&ofw_lock, flags);\r\nret = olpc_ofw_cif(ofw_args);\r\nspin_unlock_irqrestore(&ofw_lock, flags);\r\nif (!ret) {\r\nfor (i = 0; i < nr_res; i++, p++)\r\n*((int *)res[i]) = *p;\r\n}\r\nreturn ret;\r\n}\r\nbool olpc_ofw_present(void)\r\n{\r\nreturn olpc_ofw_cif != NULL;\r\n}\r\nvoid __init olpc_ofw_detect(void)\r\n{\r\nstruct olpc_ofw_header *hdr = &boot_params.olpc_ofw_header;\r\nunsigned long start;\r\nif (hdr->ofw_magic != OLPC_OFW_SIG)\r\nreturn;\r\nolpc_ofw_cif = (int (*)(int *))hdr->cif_handler;\r\nif ((unsigned long)olpc_ofw_cif < OFW_MIN) {\r\nprintk(KERN_ERR "OFW detected, but cif has invalid address 0x%lx - disabling.\n",\r\n(unsigned long)olpc_ofw_cif);\r\nolpc_ofw_cif = NULL;\r\nreturn;\r\n}\r\nstart = round_down((unsigned long)olpc_ofw_cif, OFW_BOUND);\r\nprintk(KERN_INFO "OFW detected in memory, cif @ 0x%lx (reserving top %ldMB)\n",\r\n(unsigned long)olpc_ofw_cif, (-start) >> 20);\r\nreserve_top_address(-start);\r\n}\r\nbool __init olpc_ofw_is_installed(void)\r\n{\r\nreturn olpc_ofw_cif != NULL;\r\n}
