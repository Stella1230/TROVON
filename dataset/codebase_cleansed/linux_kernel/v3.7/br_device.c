netdev_tx_t br_dev_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nconst unsigned char *dest = skb->data;\r\nstruct net_bridge_fdb_entry *dst;\r\nstruct net_bridge_mdb_entry *mdst;\r\nstruct br_cpu_netstats *brstats = this_cpu_ptr(br->stats);\r\nrcu_read_lock();\r\n#ifdef CONFIG_BRIDGE_NETFILTER\r\nif (skb->nf_bridge && (skb->nf_bridge->mask & BRNF_BRIDGED_DNAT)) {\r\nbr_nf_pre_routing_finish_bridge_slow(skb);\r\nrcu_read_unlock();\r\nreturn NETDEV_TX_OK;\r\n}\r\n#endif\r\nu64_stats_update_begin(&brstats->syncp);\r\nbrstats->tx_packets++;\r\nbrstats->tx_bytes += skb->len;\r\nu64_stats_update_end(&brstats->syncp);\r\nBR_INPUT_SKB_CB(skb)->brdev = dev;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, ETH_HLEN);\r\nif (is_broadcast_ether_addr(dest))\r\nbr_flood_deliver(br, skb);\r\nelse if (is_multicast_ether_addr(dest)) {\r\nif (unlikely(netpoll_tx_running(dev))) {\r\nbr_flood_deliver(br, skb);\r\ngoto out;\r\n}\r\nif (br_multicast_rcv(br, NULL, skb)) {\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nmdst = br_mdb_get(br, skb);\r\nif (mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb))\r\nbr_multicast_deliver(mdst, skb);\r\nelse\r\nbr_flood_deliver(br, skb);\r\n} else if ((dst = __br_fdb_get(br, dest)) != NULL)\r\nbr_deliver(dst->dst, skb);\r\nelse\r\nbr_flood_deliver(br, skb);\r\nout:\r\nrcu_read_unlock();\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int br_dev_init(struct net_device *dev)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nbr->stats = alloc_percpu(struct br_cpu_netstats);\r\nif (!br->stats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int br_dev_open(struct net_device *dev)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nnetdev_update_features(dev);\r\nnetif_start_queue(dev);\r\nbr_stp_enable_bridge(br);\r\nbr_multicast_open(br);\r\nreturn 0;\r\n}\r\nstatic void br_dev_set_multicast_list(struct net_device *dev)\r\n{\r\n}\r\nstatic int br_dev_stop(struct net_device *dev)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nbr_stp_disable_bridge(br);\r\nbr_multicast_stop(br);\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic struct rtnl_link_stats64 *br_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nstruct br_cpu_netstats tmp, sum = { 0 };\r\nunsigned int cpu;\r\nfor_each_possible_cpu(cpu) {\r\nunsigned int start;\r\nconst struct br_cpu_netstats *bstats\r\n= per_cpu_ptr(br->stats, cpu);\r\ndo {\r\nstart = u64_stats_fetch_begin_bh(&bstats->syncp);\r\nmemcpy(&tmp, bstats, sizeof(tmp));\r\n} while (u64_stats_fetch_retry_bh(&bstats->syncp, start));\r\nsum.tx_bytes += tmp.tx_bytes;\r\nsum.tx_packets += tmp.tx_packets;\r\nsum.rx_bytes += tmp.rx_bytes;\r\nsum.rx_packets += tmp.rx_packets;\r\n}\r\nstats->tx_bytes = sum.tx_bytes;\r\nstats->tx_packets = sum.tx_packets;\r\nstats->rx_bytes = sum.rx_bytes;\r\nstats->rx_packets = sum.rx_packets;\r\nreturn stats;\r\n}\r\nstatic int br_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nif (new_mtu < 68 || new_mtu > br_min_mtu(br))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\n#ifdef CONFIG_BRIDGE_NETFILTER\r\ndst_metric_set(&br->fake_rtable.dst, RTAX_MTU, new_mtu);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int br_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nspin_lock_bh(&br->lock);\r\nif (!ether_addr_equal(dev->dev_addr, addr->sa_data)) {\r\ndev->addr_assign_type &= ~NET_ADDR_RANDOM;\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\nbr_fdb_change_mac_address(br, addr->sa_data);\r\nbr_stp_change_bridge_id(br, addr->sa_data);\r\n}\r\nbr->flags |= BR_SET_MAC_ADDR;\r\nspin_unlock_bh(&br->lock);\r\nreturn 0;\r\n}\r\nstatic void br_getinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstrcpy(info->driver, "bridge");\r\nstrcpy(info->version, BR_VERSION);\r\nstrcpy(info->fw_version, "N/A");\r\nstrcpy(info->bus_info, "N/A");\r\n}\r\nstatic netdev_features_t br_fix_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nreturn br_features_recompute(br, features);\r\n}\r\nstatic void br_poll_controller(struct net_device *br_dev)\r\n{\r\n}\r\nstatic void br_netpoll_cleanup(struct net_device *dev)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nstruct net_bridge_port *p;\r\nlist_for_each_entry(p, &br->port_list, list)\r\nbr_netpoll_disable(p);\r\n}\r\nstatic int br_netpoll_setup(struct net_device *dev, struct netpoll_info *ni,\r\ngfp_t gfp)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nstruct net_bridge_port *p;\r\nint err = 0;\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nif (!p->dev)\r\ncontinue;\r\nerr = br_netpoll_enable(p, gfp);\r\nif (err)\r\ngoto fail;\r\n}\r\nout:\r\nreturn err;\r\nfail:\r\nbr_netpoll_cleanup(dev);\r\ngoto out;\r\n}\r\nint br_netpoll_enable(struct net_bridge_port *p, gfp_t gfp)\r\n{\r\nstruct netpoll *np;\r\nint err = 0;\r\nnp = kzalloc(sizeof(*p->np), gfp);\r\nerr = -ENOMEM;\r\nif (!np)\r\ngoto out;\r\nerr = __netpoll_setup(np, p->dev, gfp);\r\nif (err) {\r\nkfree(np);\r\ngoto out;\r\n}\r\np->np = np;\r\nout:\r\nreturn err;\r\n}\r\nvoid br_netpoll_disable(struct net_bridge_port *p)\r\n{\r\nstruct netpoll *np = p->np;\r\nif (!np)\r\nreturn;\r\np->np = NULL;\r\n__netpoll_free_rcu(np);\r\n}\r\nstatic int br_add_slave(struct net_device *dev, struct net_device *slave_dev)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nreturn br_add_if(br, slave_dev);\r\n}\r\nstatic int br_del_slave(struct net_device *dev, struct net_device *slave_dev)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nreturn br_del_if(br, slave_dev);\r\n}\r\nstatic void br_dev_free(struct net_device *dev)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nfree_percpu(br->stats);\r\nfree_netdev(dev);\r\n}\r\nvoid br_dev_setup(struct net_device *dev)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\neth_hw_addr_random(dev);\r\nether_setup(dev);\r\ndev->netdev_ops = &br_netdev_ops;\r\ndev->destructor = br_dev_free;\r\nSET_ETHTOOL_OPS(dev, &br_ethtool_ops);\r\nSET_NETDEV_DEVTYPE(dev, &br_type);\r\ndev->tx_queue_len = 0;\r\ndev->priv_flags = IFF_EBRIDGE;\r\ndev->features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |\r\nNETIF_F_GSO_MASK | NETIF_F_HW_CSUM | NETIF_F_LLTX |\r\nNETIF_F_NETNS_LOCAL | NETIF_F_HW_VLAN_TX;\r\ndev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |\r\nNETIF_F_GSO_MASK | NETIF_F_HW_CSUM |\r\nNETIF_F_HW_VLAN_TX;\r\nbr->dev = dev;\r\nspin_lock_init(&br->lock);\r\nINIT_LIST_HEAD(&br->port_list);\r\nspin_lock_init(&br->hash_lock);\r\nbr->bridge_id.prio[0] = 0x80;\r\nbr->bridge_id.prio[1] = 0x00;\r\nmemcpy(br->group_addr, br_group_address, ETH_ALEN);\r\nbr->stp_enabled = BR_NO_STP;\r\nbr->group_fwd_mask = BR_GROUPFWD_DEFAULT;\r\nbr->designated_root = br->bridge_id;\r\nbr->bridge_max_age = br->max_age = 20 * HZ;\r\nbr->bridge_hello_time = br->hello_time = 2 * HZ;\r\nbr->bridge_forward_delay = br->forward_delay = 15 * HZ;\r\nbr->ageing_time = 300 * HZ;\r\nbr_netfilter_rtable_init(br);\r\nbr_stp_timer_init(br);\r\nbr_multicast_init(br);\r\n}
