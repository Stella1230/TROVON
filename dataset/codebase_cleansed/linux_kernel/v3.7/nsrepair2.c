acpi_status\r\nacpi_ns_complex_repairs(struct acpi_predefined_data *data,\r\nstruct acpi_namespace_node *node,\r\nacpi_status validate_status,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nconst struct acpi_repair_info *predefined;\r\nacpi_status status;\r\npredefined = acpi_ns_match_repairable_name(node);\r\nif (!predefined) {\r\nreturn (validate_status);\r\n}\r\nstatus = predefined->repair_function(data, return_object_ptr);\r\nreturn (status);\r\n}\r\nstatic const struct acpi_repair_info *acpi_ns_match_repairable_name(struct\r\nacpi_namespace_node\r\n*node)\r\n{\r\nconst struct acpi_repair_info *this_name;\r\nthis_name = acpi_ns_repairable_names;\r\nwhile (this_name->repair_function) {\r\nif (ACPI_COMPARE_NAME(node->name.ascii, this_name->name)) {\r\nreturn (this_name);\r\n}\r\nthis_name++;\r\n}\r\nreturn (NULL);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_ALR(struct acpi_predefined_data *data,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nacpi_status status;\r\nstatus = acpi_ns_check_sorted_list(data, return_object, 2, 1,\r\nACPI_SORT_ASCENDING,\r\n"AmbientIlluminance");\r\nreturn (status);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_FDE(struct acpi_predefined_data *data,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nunion acpi_operand_object *buffer_object;\r\nu8 *byte_buffer;\r\nu32 *dword_buffer;\r\nu32 i;\r\nACPI_FUNCTION_NAME(ns_repair_FDE);\r\nswitch (return_object->common.type) {\r\ncase ACPI_TYPE_BUFFER:\r\nif (return_object->buffer.length >= ACPI_FDE_DWORD_BUFFER_SIZE) {\r\nreturn (AE_OK);\r\n}\r\nif (return_object->buffer.length != ACPI_FDE_BYTE_BUFFER_SIZE) {\r\nACPI_WARN_PREDEFINED((AE_INFO, data->pathname,\r\ndata->node_flags,\r\n"Incorrect return buffer length %u, expected %u",\r\nreturn_object->buffer.length,\r\nACPI_FDE_DWORD_BUFFER_SIZE));\r\nreturn (AE_AML_OPERAND_TYPE);\r\n}\r\nbuffer_object =\r\nacpi_ut_create_buffer_object(ACPI_FDE_DWORD_BUFFER_SIZE);\r\nif (!buffer_object) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nbyte_buffer = return_object->buffer.pointer;\r\ndword_buffer =\r\nACPI_CAST_PTR(u32, buffer_object->buffer.pointer);\r\nfor (i = 0; i < ACPI_FDE_FIELD_COUNT; i++) {\r\n*dword_buffer = (u32) *byte_buffer;\r\ndword_buffer++;\r\nbyte_buffer++;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_REPAIR,\r\n"%s Expanded Byte Buffer to expected DWord Buffer\n",\r\ndata->pathname));\r\nbreak;\r\ndefault:\r\nreturn (AE_AML_OPERAND_TYPE);\r\n}\r\nacpi_ut_remove_reference(return_object);\r\n*return_object_ptr = buffer_object;\r\ndata->flags |= ACPI_OBJECT_REPAIRED;\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_CID(struct acpi_predefined_data *data,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nacpi_status status;\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nunion acpi_operand_object **element_ptr;\r\nunion acpi_operand_object *original_element;\r\nu16 original_ref_count;\r\nu32 i;\r\nif (return_object->common.type == ACPI_TYPE_STRING) {\r\nstatus = acpi_ns_repair_HID(data, return_object_ptr);\r\nreturn (status);\r\n}\r\nif (return_object->common.type != ACPI_TYPE_PACKAGE) {\r\nreturn (AE_OK);\r\n}\r\nelement_ptr = return_object->package.elements;\r\nfor (i = 0; i < return_object->package.count; i++) {\r\noriginal_element = *element_ptr;\r\noriginal_ref_count = original_element->common.reference_count;\r\nstatus = acpi_ns_repair_HID(data, element_ptr);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (original_element != *element_ptr) {\r\n(*element_ptr)->common.reference_count =\r\noriginal_ref_count;\r\nacpi_ut_remove_reference(original_element);\r\n}\r\nelement_ptr++;\r\n}\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_HID(struct acpi_predefined_data *data,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nunion acpi_operand_object *new_string;\r\nchar *source;\r\nchar *dest;\r\nACPI_FUNCTION_NAME(ns_repair_HID);\r\nif (return_object->common.type != ACPI_TYPE_STRING) {\r\nreturn (AE_OK);\r\n}\r\nif (return_object->string.length == 0) {\r\nACPI_WARN_PREDEFINED((AE_INFO, data->pathname, data->node_flags,\r\n"Invalid zero-length _HID or _CID string"));\r\ndata->flags |= ACPI_OBJECT_REPAIRED;\r\nreturn (AE_OK);\r\n}\r\nnew_string = acpi_ut_create_string_object(return_object->string.length);\r\nif (!new_string) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nsource = return_object->string.pointer;\r\nif (*source == '*') {\r\nsource++;\r\nnew_string->string.length--;\r\nACPI_DEBUG_PRINT((ACPI_DB_REPAIR,\r\n"%s: Removed invalid leading asterisk\n",\r\ndata->pathname));\r\n}\r\nfor (dest = new_string->string.pointer; *source; dest++, source++) {\r\n*dest = (char)ACPI_TOUPPER(*source);\r\n}\r\nacpi_ut_remove_reference(return_object);\r\n*return_object_ptr = new_string;\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_TSS(struct acpi_predefined_data *data,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nacpi_status status;\r\nstruct acpi_namespace_node *node;\r\nstatus =\r\nacpi_ns_get_node(data->node, "^_PSS", ACPI_NS_NO_UPSEARCH, &node);\r\nif (ACPI_SUCCESS(status)) {\r\nreturn (AE_OK);\r\n}\r\nstatus = acpi_ns_check_sorted_list(data, return_object, 5, 1,\r\nACPI_SORT_DESCENDING,\r\n"PowerDissipation");\r\nreturn (status);\r\n}\r\nstatic acpi_status\r\nacpi_ns_repair_PSS(struct acpi_predefined_data *data,\r\nunion acpi_operand_object **return_object_ptr)\r\n{\r\nunion acpi_operand_object *return_object = *return_object_ptr;\r\nunion acpi_operand_object **outer_elements;\r\nu32 outer_element_count;\r\nunion acpi_operand_object **elements;\r\nunion acpi_operand_object *obj_desc;\r\nu32 previous_value;\r\nacpi_status status;\r\nu32 i;\r\nstatus = acpi_ns_check_sorted_list(data, return_object, 6, 0,\r\nACPI_SORT_DESCENDING,\r\n"CpuFrequency");\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nprevious_value = ACPI_UINT32_MAX;\r\nouter_elements = return_object->package.elements;\r\nouter_element_count = return_object->package.count;\r\nfor (i = 0; i < outer_element_count; i++) {\r\nelements = (*outer_elements)->package.elements;\r\nobj_desc = elements[1];\r\nif ((u32) obj_desc->integer.value > previous_value) {\r\nACPI_WARN_PREDEFINED((AE_INFO, data->pathname,\r\ndata->node_flags,\r\n"SubPackage[%u,%u] - suspicious power dissipation values",\r\ni - 1, i));\r\n}\r\nprevious_value = (u32) obj_desc->integer.value;\r\nouter_elements++;\r\n}\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ns_check_sorted_list(struct acpi_predefined_data *data,\r\nunion acpi_operand_object *return_object,\r\nu32 expected_count,\r\nu32 sort_index,\r\nu8 sort_direction, char *sort_key_name)\r\n{\r\nu32 outer_element_count;\r\nunion acpi_operand_object **outer_elements;\r\nunion acpi_operand_object **elements;\r\nunion acpi_operand_object *obj_desc;\r\nu32 i;\r\nu32 previous_value;\r\nACPI_FUNCTION_NAME(ns_check_sorted_list);\r\nif (return_object->common.type != ACPI_TYPE_PACKAGE) {\r\nreturn (AE_AML_OPERAND_TYPE);\r\n}\r\nouter_elements = return_object->package.elements;\r\nouter_element_count = return_object->package.count;\r\nif (!outer_element_count) {\r\nreturn (AE_AML_PACKAGE_LIMIT);\r\n}\r\nprevious_value = 0;\r\nif (sort_direction == ACPI_SORT_DESCENDING) {\r\nprevious_value = ACPI_UINT32_MAX;\r\n}\r\nfor (i = 0; i < outer_element_count; i++) {\r\nif ((*outer_elements)->common.type != ACPI_TYPE_PACKAGE) {\r\nreturn (AE_AML_OPERAND_TYPE);\r\n}\r\nif ((*outer_elements)->package.count < expected_count) {\r\nreturn (AE_AML_PACKAGE_LIMIT);\r\n}\r\nelements = (*outer_elements)->package.elements;\r\nobj_desc = elements[sort_index];\r\nif (obj_desc->common.type != ACPI_TYPE_INTEGER) {\r\nreturn (AE_AML_OPERAND_TYPE);\r\n}\r\nif (((sort_direction == ACPI_SORT_ASCENDING) &&\r\n(obj_desc->integer.value < previous_value)) ||\r\n((sort_direction == ACPI_SORT_DESCENDING) &&\r\n(obj_desc->integer.value > previous_value))) {\r\nacpi_ns_sort_list(return_object->package.elements,\r\nouter_element_count, sort_index,\r\nsort_direction);\r\ndata->flags |= ACPI_OBJECT_REPAIRED;\r\nACPI_DEBUG_PRINT((ACPI_DB_REPAIR,\r\n"%s: Repaired unsorted list - now sorted by %s\n",\r\ndata->pathname, sort_key_name));\r\nreturn (AE_OK);\r\n}\r\nprevious_value = (u32) obj_desc->integer.value;\r\nouter_elements++;\r\n}\r\nreturn (AE_OK);\r\n}\r\nstatic void\r\nacpi_ns_sort_list(union acpi_operand_object **elements,\r\nu32 count, u32 index, u8 sort_direction)\r\n{\r\nunion acpi_operand_object *obj_desc1;\r\nunion acpi_operand_object *obj_desc2;\r\nunion acpi_operand_object *temp_obj;\r\nu32 i;\r\nu32 j;\r\nfor (i = 1; i < count; i++) {\r\nfor (j = (count - 1); j >= i; j--) {\r\nobj_desc1 = elements[j - 1]->package.elements[index];\r\nobj_desc2 = elements[j]->package.elements[index];\r\nif (((sort_direction == ACPI_SORT_ASCENDING) &&\r\n(obj_desc1->integer.value >\r\nobj_desc2->integer.value))\r\n|| ((sort_direction == ACPI_SORT_DESCENDING)\r\n&& (obj_desc1->integer.value <\r\nobj_desc2->integer.value))) {\r\ntemp_obj = elements[j - 1];\r\nelements[j - 1] = elements[j];\r\nelements[j] = temp_obj;\r\n}\r\n}\r\n}\r\n}
