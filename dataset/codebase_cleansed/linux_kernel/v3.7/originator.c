static void batadv_start_purge_timer(struct batadv_priv *bat_priv)\r\n{\r\nINIT_DELAYED_WORK(&bat_priv->orig_work, batadv_purge_orig);\r\nqueue_delayed_work(batadv_event_workqueue,\r\n&bat_priv->orig_work, msecs_to_jiffies(1000));\r\n}\r\nstatic int batadv_compare_orig(const struct hlist_node *node, const void *data2)\r\n{\r\nconst void *data1 = container_of(node, struct batadv_orig_node,\r\nhash_entry);\r\nreturn (memcmp(data1, data2, ETH_ALEN) == 0 ? 1 : 0);\r\n}\r\nint batadv_originator_init(struct batadv_priv *bat_priv)\r\n{\r\nif (bat_priv->orig_hash)\r\nreturn 0;\r\nbat_priv->orig_hash = batadv_hash_new(1024);\r\nif (!bat_priv->orig_hash)\r\ngoto err;\r\nbatadv_start_purge_timer(bat_priv);\r\nreturn 0;\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nvoid batadv_neigh_node_free_ref(struct batadv_neigh_node *neigh_node)\r\n{\r\nif (atomic_dec_and_test(&neigh_node->refcount))\r\nkfree_rcu(neigh_node, rcu);\r\n}\r\nstruct batadv_neigh_node *\r\nbatadv_orig_node_get_router(struct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_neigh_node *router;\r\nrcu_read_lock();\r\nrouter = rcu_dereference(orig_node->router);\r\nif (router && !atomic_inc_not_zero(&router->refcount))\r\nrouter = NULL;\r\nrcu_read_unlock();\r\nreturn router;\r\n}\r\nstruct batadv_neigh_node *\r\nbatadv_neigh_node_new(struct batadv_hard_iface *hard_iface,\r\nconst uint8_t *neigh_addr, uint32_t seqno)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nstruct batadv_neigh_node *neigh_node;\r\nneigh_node = kzalloc(sizeof(*neigh_node), GFP_ATOMIC);\r\nif (!neigh_node)\r\ngoto out;\r\nINIT_HLIST_NODE(&neigh_node->list);\r\nmemcpy(neigh_node->addr, neigh_addr, ETH_ALEN);\r\nspin_lock_init(&neigh_node->lq_update_lock);\r\natomic_set(&neigh_node->refcount, 2);\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Creating new neighbor %pM, initial seqno %d\n",\r\nneigh_addr, seqno);\r\nout:\r\nreturn neigh_node;\r\n}\r\nstatic void batadv_orig_node_free_rcu(struct rcu_head *rcu)\r\n{\r\nstruct hlist_node *node, *node_tmp;\r\nstruct batadv_neigh_node *neigh_node, *tmp_neigh_node;\r\nstruct batadv_orig_node *orig_node;\r\norig_node = container_of(rcu, struct batadv_orig_node, rcu);\r\nspin_lock_bh(&orig_node->neigh_list_lock);\r\nlist_for_each_entry_safe(neigh_node, tmp_neigh_node,\r\n&orig_node->bond_list, bonding_list) {\r\nlist_del_rcu(&neigh_node->bonding_list);\r\nbatadv_neigh_node_free_ref(neigh_node);\r\n}\r\nhlist_for_each_entry_safe(neigh_node, node, node_tmp,\r\n&orig_node->neigh_list, list) {\r\nhlist_del_rcu(&neigh_node->list);\r\nbatadv_neigh_node_free_ref(neigh_node);\r\n}\r\nspin_unlock_bh(&orig_node->neigh_list_lock);\r\nbatadv_frag_list_free(&orig_node->frag_list);\r\nbatadv_tt_global_del_orig(orig_node->bat_priv, orig_node,\r\n"originator timed out");\r\nkfree(orig_node->tt_buff);\r\nkfree(orig_node->bcast_own);\r\nkfree(orig_node->bcast_own_sum);\r\nkfree(orig_node);\r\n}\r\nvoid batadv_orig_node_free_ref(struct batadv_orig_node *orig_node)\r\n{\r\nif (atomic_dec_and_test(&orig_node->refcount))\r\ncall_rcu(&orig_node->rcu, batadv_orig_node_free_rcu);\r\n}\r\nvoid batadv_originator_free(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct hlist_node *node, *node_tmp;\r\nstruct hlist_head *head;\r\nspinlock_t *list_lock;\r\nstruct batadv_orig_node *orig_node;\r\nuint32_t i;\r\nif (!hash)\r\nreturn;\r\ncancel_delayed_work_sync(&bat_priv->orig_work);\r\nbat_priv->orig_hash = NULL;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(orig_node, node, node_tmp,\r\nhead, hash_entry) {\r\nhlist_del_rcu(node);\r\nbatadv_orig_node_free_ref(orig_node);\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\nbatadv_hash_destroy(hash);\r\n}\r\nstruct batadv_orig_node *batadv_get_orig_node(struct batadv_priv *bat_priv,\r\nconst uint8_t *addr)\r\n{\r\nstruct batadv_orig_node *orig_node;\r\nint size;\r\nint hash_added;\r\nunsigned long reset_time;\r\norig_node = batadv_orig_hash_find(bat_priv, addr);\r\nif (orig_node)\r\nreturn orig_node;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Creating new originator: %pM\n", addr);\r\norig_node = kzalloc(sizeof(*orig_node), GFP_ATOMIC);\r\nif (!orig_node)\r\nreturn NULL;\r\nINIT_HLIST_HEAD(&orig_node->neigh_list);\r\nINIT_LIST_HEAD(&orig_node->bond_list);\r\nspin_lock_init(&orig_node->ogm_cnt_lock);\r\nspin_lock_init(&orig_node->bcast_seqno_lock);\r\nspin_lock_init(&orig_node->neigh_list_lock);\r\nspin_lock_init(&orig_node->tt_buff_lock);\r\natomic_set(&orig_node->refcount, 2);\r\norig_node->tt_initialised = false;\r\norig_node->tt_poss_change = false;\r\norig_node->bat_priv = bat_priv;\r\nmemcpy(orig_node->orig, addr, ETH_ALEN);\r\norig_node->router = NULL;\r\norig_node->tt_crc = 0;\r\natomic_set(&orig_node->last_ttvn, 0);\r\norig_node->tt_buff = NULL;\r\norig_node->tt_buff_len = 0;\r\natomic_set(&orig_node->tt_size, 0);\r\nreset_time = jiffies - 1 - msecs_to_jiffies(BATADV_RESET_PROTECTION_MS);\r\norig_node->bcast_seqno_reset = reset_time;\r\norig_node->batman_seqno_reset = reset_time;\r\natomic_set(&orig_node->bond_candidates, 0);\r\nsize = bat_priv->num_ifaces * sizeof(unsigned long) * BATADV_NUM_WORDS;\r\norig_node->bcast_own = kzalloc(size, GFP_ATOMIC);\r\nif (!orig_node->bcast_own)\r\ngoto free_orig_node;\r\nsize = bat_priv->num_ifaces * sizeof(uint8_t);\r\norig_node->bcast_own_sum = kzalloc(size, GFP_ATOMIC);\r\nINIT_LIST_HEAD(&orig_node->frag_list);\r\norig_node->last_frag_packet = 0;\r\nif (!orig_node->bcast_own_sum)\r\ngoto free_bcast_own;\r\nhash_added = batadv_hash_add(bat_priv->orig_hash, batadv_compare_orig,\r\nbatadv_choose_orig, orig_node,\r\n&orig_node->hash_entry);\r\nif (hash_added != 0)\r\ngoto free_bcast_own_sum;\r\nreturn orig_node;\r\nfree_bcast_own_sum:\r\nkfree(orig_node->bcast_own_sum);\r\nfree_bcast_own:\r\nkfree(orig_node->bcast_own);\r\nfree_orig_node:\r\nkfree(orig_node);\r\nreturn NULL;\r\n}\r\nstatic bool\r\nbatadv_purge_orig_neighbors(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_neigh_node **best_neigh_node)\r\n{\r\nstruct hlist_node *node, *node_tmp;\r\nstruct batadv_neigh_node *neigh_node;\r\nbool neigh_purged = false;\r\nunsigned long last_seen;\r\nstruct batadv_hard_iface *if_incoming;\r\n*best_neigh_node = NULL;\r\nspin_lock_bh(&orig_node->neigh_list_lock);\r\nhlist_for_each_entry_safe(neigh_node, node, node_tmp,\r\n&orig_node->neigh_list, list) {\r\nlast_seen = neigh_node->last_seen;\r\nif_incoming = neigh_node->if_incoming;\r\nif ((batadv_has_timed_out(last_seen, BATADV_PURGE_TIMEOUT)) ||\r\n(if_incoming->if_status == BATADV_IF_INACTIVE) ||\r\n(if_incoming->if_status == BATADV_IF_NOT_IN_USE) ||\r\n(if_incoming->if_status == BATADV_IF_TO_BE_REMOVED)) {\r\nif ((if_incoming->if_status == BATADV_IF_INACTIVE) ||\r\n(if_incoming->if_status == BATADV_IF_NOT_IN_USE) ||\r\n(if_incoming->if_status == BATADV_IF_TO_BE_REMOVED))\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"neighbor purge: originator %pM, neighbor: %pM, iface: %s\n",\r\norig_node->orig, neigh_node->addr,\r\nif_incoming->net_dev->name);\r\nelse\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"neighbor timeout: originator %pM, neighbor: %pM, last_seen: %u\n",\r\norig_node->orig, neigh_node->addr,\r\njiffies_to_msecs(last_seen));\r\nneigh_purged = true;\r\nhlist_del_rcu(&neigh_node->list);\r\nbatadv_bonding_candidate_del(orig_node, neigh_node);\r\nbatadv_neigh_node_free_ref(neigh_node);\r\n} else {\r\nif ((!*best_neigh_node) ||\r\n(neigh_node->tq_avg > (*best_neigh_node)->tq_avg))\r\n*best_neigh_node = neigh_node;\r\n}\r\n}\r\nspin_unlock_bh(&orig_node->neigh_list_lock);\r\nreturn neigh_purged;\r\n}\r\nstatic bool batadv_purge_orig_node(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_neigh_node *best_neigh_node;\r\nif (batadv_has_timed_out(orig_node->last_seen,\r\n2 * BATADV_PURGE_TIMEOUT)) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Originator timeout: originator %pM, last_seen %u\n",\r\norig_node->orig,\r\njiffies_to_msecs(orig_node->last_seen));\r\nreturn true;\r\n} else {\r\nif (batadv_purge_orig_neighbors(bat_priv, orig_node,\r\n&best_neigh_node))\r\nbatadv_update_route(bat_priv, orig_node,\r\nbest_neigh_node);\r\n}\r\nreturn false;\r\n}\r\nstatic void _batadv_purge_orig(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct hlist_node *node, *node_tmp;\r\nstruct hlist_head *head;\r\nspinlock_t *list_lock;\r\nstruct batadv_orig_node *orig_node;\r\nuint32_t i;\r\nif (!hash)\r\nreturn;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nlist_lock = &hash->list_locks[i];\r\nspin_lock_bh(list_lock);\r\nhlist_for_each_entry_safe(orig_node, node, node_tmp,\r\nhead, hash_entry) {\r\nif (batadv_purge_orig_node(bat_priv, orig_node)) {\r\nif (orig_node->gw_flags)\r\nbatadv_gw_node_delete(bat_priv,\r\norig_node);\r\nhlist_del_rcu(node);\r\nbatadv_orig_node_free_ref(orig_node);\r\ncontinue;\r\n}\r\nif (batadv_has_timed_out(orig_node->last_frag_packet,\r\nBATADV_FRAG_TIMEOUT))\r\nbatadv_frag_list_free(&orig_node->frag_list);\r\n}\r\nspin_unlock_bh(list_lock);\r\n}\r\nbatadv_gw_node_purge(bat_priv);\r\nbatadv_gw_election(bat_priv);\r\n}\r\nstatic void batadv_purge_orig(struct work_struct *work)\r\n{\r\nstruct delayed_work *delayed_work;\r\nstruct batadv_priv *bat_priv;\r\ndelayed_work = container_of(work, struct delayed_work, work);\r\nbat_priv = container_of(delayed_work, struct batadv_priv, orig_work);\r\n_batadv_purge_orig(bat_priv);\r\nbatadv_start_purge_timer(bat_priv);\r\n}\r\nvoid batadv_purge_orig_ref(struct batadv_priv *bat_priv)\r\n{\r\n_batadv_purge_orig(bat_priv);\r\n}\r\nint batadv_orig_seq_print_text(struct seq_file *seq, void *offset)\r\n{\r\nstruct net_device *net_dev = (struct net_device *)seq->private;\r\nstruct batadv_priv *bat_priv = netdev_priv(net_dev);\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct hlist_node *node, *node_tmp;\r\nstruct hlist_head *head;\r\nstruct batadv_hard_iface *primary_if;\r\nstruct batadv_orig_node *orig_node;\r\nstruct batadv_neigh_node *neigh_node, *neigh_node_tmp;\r\nint batman_count = 0;\r\nint last_seen_secs;\r\nint last_seen_msecs;\r\nunsigned long last_seen_jiffies;\r\nuint32_t i;\r\nint ret = 0;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if) {\r\nret = seq_printf(seq,\r\n"BATMAN mesh %s disabled - please specify interfaces to enable it\n",\r\nnet_dev->name);\r\ngoto out;\r\n}\r\nif (primary_if->if_status != BATADV_IF_ACTIVE) {\r\nret = seq_printf(seq,\r\n"BATMAN mesh %s disabled - primary interface not active\n",\r\nnet_dev->name);\r\ngoto out;\r\n}\r\nseq_printf(seq, "[B.A.T.M.A.N. adv %s, MainIF/MAC: %s/%pM (%s)]\n",\r\nBATADV_SOURCE_VERSION, primary_if->net_dev->name,\r\nprimary_if->net_dev->dev_addr, net_dev->name);\r\nseq_printf(seq, " %-15s %s (%s/%i) %17s [%10s]: %20s ...\n",\r\n"Originator", "last-seen", "#", BATADV_TQ_MAX_VALUE,\r\n"Nexthop", "outgoingIF", "Potential nexthops");\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_node, node, head, hash_entry) {\r\nneigh_node = batadv_orig_node_get_router(orig_node);\r\nif (!neigh_node)\r\ncontinue;\r\nif (neigh_node->tq_avg == 0)\r\ngoto next;\r\nlast_seen_jiffies = jiffies - orig_node->last_seen;\r\nlast_seen_msecs = jiffies_to_msecs(last_seen_jiffies);\r\nlast_seen_secs = last_seen_msecs / 1000;\r\nlast_seen_msecs = last_seen_msecs % 1000;\r\nseq_printf(seq, "%pM %4i.%03is (%3i) %pM [%10s]:",\r\norig_node->orig, last_seen_secs,\r\nlast_seen_msecs, neigh_node->tq_avg,\r\nneigh_node->addr,\r\nneigh_node->if_incoming->net_dev->name);\r\nhlist_for_each_entry_rcu(neigh_node_tmp, node_tmp,\r\n&orig_node->neigh_list, list) {\r\nseq_printf(seq, " %pM (%3i)",\r\nneigh_node_tmp->addr,\r\nneigh_node_tmp->tq_avg);\r\n}\r\nseq_printf(seq, "\n");\r\nbatman_count++;\r\nnext:\r\nbatadv_neigh_node_free_ref(neigh_node);\r\n}\r\nrcu_read_unlock();\r\n}\r\nif (batman_count == 0)\r\nseq_printf(seq, "No batman nodes in range ...\n");\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\nreturn ret;\r\n}\r\nstatic int batadv_orig_node_add_if(struct batadv_orig_node *orig_node,\r\nint max_if_num)\r\n{\r\nvoid *data_ptr;\r\nsize_t data_size, old_size;\r\ndata_size = max_if_num * sizeof(unsigned long) * BATADV_NUM_WORDS;\r\nold_size = (max_if_num - 1) * sizeof(unsigned long) * BATADV_NUM_WORDS;\r\ndata_ptr = kmalloc(data_size, GFP_ATOMIC);\r\nif (!data_ptr)\r\nreturn -ENOMEM;\r\nmemcpy(data_ptr, orig_node->bcast_own, old_size);\r\nkfree(orig_node->bcast_own);\r\norig_node->bcast_own = data_ptr;\r\ndata_ptr = kmalloc(max_if_num * sizeof(uint8_t), GFP_ATOMIC);\r\nif (!data_ptr)\r\nreturn -ENOMEM;\r\nmemcpy(data_ptr, orig_node->bcast_own_sum,\r\n(max_if_num - 1) * sizeof(uint8_t));\r\nkfree(orig_node->bcast_own_sum);\r\norig_node->bcast_own_sum = data_ptr;\r\nreturn 0;\r\n}\r\nint batadv_orig_hash_add_if(struct batadv_hard_iface *hard_iface,\r\nint max_if_num)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct hlist_node *node;\r\nstruct hlist_head *head;\r\nstruct batadv_orig_node *orig_node;\r\nuint32_t i;\r\nint ret;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_node, node, head, hash_entry) {\r\nspin_lock_bh(&orig_node->ogm_cnt_lock);\r\nret = batadv_orig_node_add_if(orig_node, max_if_num);\r\nspin_unlock_bh(&orig_node->ogm_cnt_lock);\r\nif (ret == -ENOMEM)\r\ngoto err;\r\n}\r\nrcu_read_unlock();\r\n}\r\nreturn 0;\r\nerr:\r\nrcu_read_unlock();\r\nreturn -ENOMEM;\r\n}\r\nstatic int batadv_orig_node_del_if(struct batadv_orig_node *orig_node,\r\nint max_if_num, int del_if_num)\r\n{\r\nvoid *data_ptr = NULL;\r\nint chunk_size;\r\nif (max_if_num == 0)\r\ngoto free_bcast_own;\r\nchunk_size = sizeof(unsigned long) * BATADV_NUM_WORDS;\r\ndata_ptr = kmalloc(max_if_num * chunk_size, GFP_ATOMIC);\r\nif (!data_ptr)\r\nreturn -ENOMEM;\r\nmemcpy(data_ptr, orig_node->bcast_own, del_if_num * chunk_size);\r\nmemcpy((char *)data_ptr + del_if_num * chunk_size,\r\norig_node->bcast_own + ((del_if_num + 1) * chunk_size),\r\n(max_if_num - del_if_num) * chunk_size);\r\nfree_bcast_own:\r\nkfree(orig_node->bcast_own);\r\norig_node->bcast_own = data_ptr;\r\nif (max_if_num == 0)\r\ngoto free_own_sum;\r\ndata_ptr = kmalloc(max_if_num * sizeof(uint8_t), GFP_ATOMIC);\r\nif (!data_ptr)\r\nreturn -ENOMEM;\r\nmemcpy(data_ptr, orig_node->bcast_own_sum,\r\ndel_if_num * sizeof(uint8_t));\r\nmemcpy((char *)data_ptr + del_if_num * sizeof(uint8_t),\r\norig_node->bcast_own_sum + ((del_if_num + 1) * sizeof(uint8_t)),\r\n(max_if_num - del_if_num) * sizeof(uint8_t));\r\nfree_own_sum:\r\nkfree(orig_node->bcast_own_sum);\r\norig_node->bcast_own_sum = data_ptr;\r\nreturn 0;\r\n}\r\nint batadv_orig_hash_del_if(struct batadv_hard_iface *hard_iface,\r\nint max_if_num)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct hlist_node *node;\r\nstruct hlist_head *head;\r\nstruct batadv_hard_iface *hard_iface_tmp;\r\nstruct batadv_orig_node *orig_node;\r\nuint32_t i;\r\nint ret;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_node, node, head, hash_entry) {\r\nspin_lock_bh(&orig_node->ogm_cnt_lock);\r\nret = batadv_orig_node_del_if(orig_node, max_if_num,\r\nhard_iface->if_num);\r\nspin_unlock_bh(&orig_node->ogm_cnt_lock);\r\nif (ret == -ENOMEM)\r\ngoto err;\r\n}\r\nrcu_read_unlock();\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface_tmp, &batadv_hardif_list, list) {\r\nif (hard_iface_tmp->if_status == BATADV_IF_NOT_IN_USE)\r\ncontinue;\r\nif (hard_iface == hard_iface_tmp)\r\ncontinue;\r\nif (hard_iface->soft_iface != hard_iface_tmp->soft_iface)\r\ncontinue;\r\nif (hard_iface_tmp->if_num > hard_iface->if_num)\r\nhard_iface_tmp->if_num--;\r\n}\r\nrcu_read_unlock();\r\nhard_iface->if_num = -1;\r\nreturn 0;\r\nerr:\r\nrcu_read_unlock();\r\nreturn -ENOMEM;\r\n}
