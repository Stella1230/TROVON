static inline int lpcr_rmls(unsigned long rma_size)\r\n{\r\nswitch (rma_size) {\r\ncase 32ul << 20:\r\nif (cpu_has_feature(CPU_FTR_ARCH_206))\r\nreturn 8;\r\nreturn -1;\r\ncase 64ul << 20:\r\nreturn 3;\r\ncase 128ul << 20:\r\nreturn 7;\r\ncase 256ul << 20:\r\nreturn 4;\r\ncase 1ul << 30:\r\nreturn 2;\r\ncase 16ul << 30:\r\nreturn 1;\r\ncase 256ul << 30:\r\nreturn 0;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nstatic int __init early_parse_rma_size(char *p)\r\n{\r\nif (!p)\r\nreturn 1;\r\nkvm_rma_size = memparse(p, &p);\r\nreturn 0;\r\n}\r\nstatic int __init early_parse_rma_count(char *p)\r\n{\r\nif (!p)\r\nreturn 1;\r\nkvm_rma_count = simple_strtoul(p, NULL, 0);\r\nreturn 0;\r\n}\r\nstruct kvmppc_linear_info *kvm_alloc_rma(void)\r\n{\r\nreturn kvm_alloc_linear(KVM_LINEAR_RMA);\r\n}\r\nvoid kvm_release_rma(struct kvmppc_linear_info *ri)\r\n{\r\nkvm_release_linear(ri);\r\n}\r\nstatic int __init early_parse_hpt_count(char *p)\r\n{\r\nif (!p)\r\nreturn 1;\r\nkvm_hpt_count = simple_strtoul(p, NULL, 0);\r\nreturn 0;\r\n}\r\nstruct kvmppc_linear_info *kvm_alloc_hpt(void)\r\n{\r\nreturn kvm_alloc_linear(KVM_LINEAR_HPT);\r\n}\r\nvoid kvm_release_hpt(struct kvmppc_linear_info *li)\r\n{\r\nkvm_release_linear(li);\r\n}\r\nstatic void __init kvm_linear_init_one(ulong size, int count, int type)\r\n{\r\nunsigned long i;\r\nunsigned long j, npages;\r\nvoid *linear;\r\nstruct page *pg;\r\nconst char *typestr;\r\nstruct kvmppc_linear_info *linear_info;\r\nif (!count)\r\nreturn;\r\ntypestr = (type == KVM_LINEAR_RMA) ? "RMA" : "HPT";\r\nnpages = size >> PAGE_SHIFT;\r\nlinear_info = alloc_bootmem(count * sizeof(struct kvmppc_linear_info));\r\nfor (i = 0; i < count; ++i) {\r\nlinear = alloc_bootmem_align(size, size);\r\npr_info("Allocated KVM %s at %p (%ld MB)\n", typestr, linear,\r\nsize >> 20);\r\nlinear_info[i].base_virt = linear;\r\nlinear_info[i].base_pfn = __pa(linear) >> PAGE_SHIFT;\r\nlinear_info[i].npages = npages;\r\nlinear_info[i].type = type;\r\nlist_add_tail(&linear_info[i].list, &free_linears);\r\natomic_set(&linear_info[i].use_count, 0);\r\npg = pfn_to_page(linear_info[i].base_pfn);\r\nfor (j = 0; j < npages; ++j) {\r\natomic_inc(&pg->_count);\r\n++pg;\r\n}\r\n}\r\n}\r\nstatic struct kvmppc_linear_info *kvm_alloc_linear(int type)\r\n{\r\nstruct kvmppc_linear_info *ri, *ret;\r\nret = NULL;\r\nspin_lock(&linear_lock);\r\nlist_for_each_entry(ri, &free_linears, list) {\r\nif (ri->type != type)\r\ncontinue;\r\nlist_del(&ri->list);\r\natomic_inc(&ri->use_count);\r\nmemset(ri->base_virt, 0, ri->npages << PAGE_SHIFT);\r\nret = ri;\r\nbreak;\r\n}\r\nspin_unlock(&linear_lock);\r\nreturn ret;\r\n}\r\nstatic void kvm_release_linear(struct kvmppc_linear_info *ri)\r\n{\r\nif (atomic_dec_and_test(&ri->use_count)) {\r\nspin_lock(&linear_lock);\r\nlist_add_tail(&ri->list, &free_linears);\r\nspin_unlock(&linear_lock);\r\n}\r\n}\r\nvoid __init kvm_linear_init(void)\r\n{\r\nkvm_linear_init_one(1 << kvm_hpt_order, kvm_hpt_count, KVM_LINEAR_HPT);\r\nif (!cpu_has_feature(CPU_FTR_HVMODE) ||\r\n!cpu_has_feature(CPU_FTR_ARCH_201))\r\nreturn;\r\nif (!kvm_rma_size || !kvm_rma_count)\r\nreturn;\r\nif (lpcr_rmls(kvm_rma_size) < 0) {\r\npr_err("RMA size of 0x%lx not supported\n", kvm_rma_size);\r\nreturn;\r\n}\r\nkvm_linear_init_one(kvm_rma_size, kvm_rma_count, KVM_LINEAR_RMA);\r\n}
