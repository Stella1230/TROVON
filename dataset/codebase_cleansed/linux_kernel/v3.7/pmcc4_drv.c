void\r\nsbecom_set_loglevel (int d)\r\n{\r\nif (d > LOG_DEBUG)\r\n{\r\nunsigned int channum = d - (LOG_DEBUG + 1);\r\n(void) musycc_dump_ring ((ci_t *) CI, channum);\r\n} else\r\n{\r\nif (cxt1e1_log_level != d)\r\n{\r\npr_info("log level changed from %d to %d\n", cxt1e1_log_level, d);\r\ncxt1e1_log_level = d;\r\n} else\r\npr_info("log level is %d\n", cxt1e1_log_level);\r\n}\r\n}\r\nmch_t *\r\nc4_find_chan (int channum)\r\n{\r\nci_t *ci;\r\nmch_t *ch;\r\nint portnum, gchan;\r\nfor (ci = c4_list; ci; ci = ci->next)\r\nfor (portnum = 0; portnum < ci->max_port; portnum++)\r\nfor (gchan = 0; gchan < MUSYCC_NCHANS; gchan++)\r\n{\r\nif ((ch = ci->port[portnum].chan[gchan]))\r\n{\r\nif ((ch->state != UNASSIGNED) &&\r\n(ch->channum == channum))\r\nreturn (ch);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nci_t *__init\r\nc4_new (void *hi)\r\n{\r\nci_t *ci;\r\n#ifdef SBE_MAP_DEBUG\r\npr_warning("c4_new() entered, ci needs %u.\n",\r\n(unsigned int) sizeof (ci_t));\r\n#endif\r\nci = (ci_t *) OS_kmalloc (sizeof (ci_t));\r\nif (ci)\r\n{\r\nci->hdw_info = hi;\r\nci->state = C_INIT;\r\nci->next = c4_list;\r\nc4_list = ci;\r\nci->brdno = ci->next ? ci->next->brdno + 1 : 0;\r\n} else\r\npr_warning("failed CI malloc, size %u.\n",\r\n(unsigned int) sizeof (ci_t));\r\nif (CI == 0)\r\nCI = ci;\r\nreturn ci;\r\n}\r\nvoid\r\ncheckPorts (ci_t * ci)\r\n{\r\n#ifndef CONFIG_SBE_PMCC4_NCOMM\r\ncomet_t *comet;\r\nvolatile u_int32_t value;\r\nu_int32_t copyVal, LEDval;\r\nu_int8_t portnum;\r\nLEDval = 0;\r\nfor (portnum = 0; portnum < ci->max_port; portnum++)\r\n{\r\ncopyVal = 0x12f & (ci->alarmed[portnum]);\r\ncomet = ci->port[portnum].cometbase;\r\nvalue = pci_read_32 ((u_int32_t *) &comet->cdrc_ists) & sbeLinkMask;\r\nif (value & sbeLinkChange)\r\n{\r\nif (!(((copyVal >> 3) & sbeLinkDown) ^ (value & sbeLinkDown)))\r\n{\r\nif (value & sbeLinkDown)\r\npr_warning("%s: Port %d momentarily recovered.\n",\r\nci->devname, portnum);\r\nelse\r\npr_warning("%s: Warning: Port %d link was briefly down.\n",\r\nci->devname, portnum);\r\n} else if (value & sbeLinkDown)\r\npr_warning("%s: Warning: Port %d link is down.\n",\r\nci->devname, portnum);\r\nelse\r\n{\r\npr_warning("%s: Port %d link has recovered.\n",\r\nci->devname, portnum);\r\ncopyVal |= 0x20;\r\n}\r\ncopyVal |= 0x10;\r\n}\r\ncopyVal &= 0x137;\r\nif (value & sbeLinkDown)\r\ncopyVal |= 0x08;\r\nelse\r\n{\r\ncopyVal |= 0x40;\r\nif (IS_FRAME_ANY_E1 (ci->port[portnum].p.port_mode))\r\n{\r\nvalue = pci_read_32 ((u_int32_t *) &comet->e1_frmr_nat_ists);\r\nif (value & 0x1f)\r\n{\r\nif (value & 0x10)\r\npr_warning("%s: E1 Port %d Codeword Sa4 change detected.\n",\r\nci->devname, portnum);\r\nif (value & 0x08)\r\npr_warning("%s: E1 Port %d Codeword Sa5 change detected.\n",\r\nci->devname, portnum);\r\nif (value & 0x04)\r\npr_warning("%s: E1 Port %d Codeword Sa6 change detected.\n",\r\nci->devname, portnum);\r\nif (value & 0x02)\r\npr_warning("%s: E1 Port %d Codeword Sa7 change detected.\n",\r\nci->devname, portnum);\r\nif (value & 0x01)\r\npr_warning("%s: E1 Port %d Codeword Sa8 change detected.\n",\r\nci->devname, portnum);\r\n}\r\nvalue = pci_read_32 ((u_int32_t *) &comet->e1_frmr_mists);\r\nif (value & 0x3)\r\n{\r\nif (value & sbeE1CRC)\r\npr_warning("%s: E1 Port %d CRC-4 error(s) detected.\n",\r\nci->devname, portnum);\r\nif (value & sbeE1errSMF)\r\npr_warning("%s: E1 Port %d received errored SMF.\n",\r\nci->devname, portnum);\r\n}\r\nvalue = pci_read_32 ((u_int32_t *) &comet->e1_frmr_masts) & 0xcc;\r\nvalue = (value >> 2);\r\nif (value & 0x30)\r\n{\r\nif (value & 0x20)\r\nvalue |= 0x40;\r\nif (value & 0x10)\r\nvalue |= 0x100;\r\nvalue &= ~0x30;\r\n}\r\nif (value != (copyVal & sbeE1AlarmsMask))\r\n{\r\ncopyVal |= 0x10;\r\nif ((copyVal & sbeRedAlm) && !(value & sbeRedAlm))\r\n{\r\ncopyVal &= ~sbeRedAlm;\r\npr_warning("%s: E1 Port %d LOF alarm ended.\n",\r\nci->devname, portnum);\r\n} else if (!(copyVal & sbeRedAlm) && (value & sbeRedAlm))\r\n{\r\ncopyVal |= sbeRedAlm;\r\npr_warning("%s: E1 Warning: Port %d LOF alarm.\n",\r\nci->devname, portnum);\r\n} else if ((copyVal & sbeYelAlm) && !(value & sbeYelAlm))\r\n{\r\ncopyVal &= ~sbeYelAlm;\r\npr_warning("%s: E1 Port %d RAI alarm ended.\n",\r\nci->devname, portnum);\r\n} else if (!(copyVal & sbeYelAlm) && (value & sbeYelAlm))\r\n{\r\ncopyVal |= sbeYelAlm;\r\npr_warning("%s: E1 Warning: Port %d RAI alarm.\n",\r\nci->devname, portnum);\r\n} else if ((copyVal & sbeE1RMAI) && !(value & sbeE1RMAI))\r\n{\r\ncopyVal &= ~sbeE1RMAI;\r\npr_warning("%s: E1 Port %d RMAI alarm ended.\n",\r\nci->devname, portnum);\r\n} else if (!(copyVal & sbeE1RMAI) && (value & sbeE1RMAI))\r\n{\r\ncopyVal |= sbeE1RMAI;\r\npr_warning("%s: E1 Warning: Port %d RMAI alarm.\n",\r\nci->devname, portnum);\r\n} else if ((copyVal & sbeAISAlm) && !(value & sbeAISAlm))\r\n{\r\ncopyVal &= ~sbeAISAlm;\r\npr_warning("%s: E1 Port %d AIS alarm ended.\n",\r\nci->devname, portnum);\r\n} else if (!(copyVal & sbeAISAlm) && (value & sbeAISAlm))\r\n{\r\ncopyVal |= sbeAISAlm;\r\npr_warning("%s: E1 Warning: Port %d AIS alarm.\n",\r\nci->devname, portnum);\r\n}\r\n}\r\n} else\r\n{\r\nvalue = pci_read_32 ((u_int32_t *) &comet->t1_almi_ists);\r\nvalue &= sbeAlarmsMask;\r\nif (value != (copyVal & sbeAlarmsMask))\r\n{\r\ncopyVal |= 0x10;\r\nif ((copyVal & sbeRedAlm) && !(value & sbeRedAlm))\r\n{\r\ncopyVal &= ~sbeRedAlm;\r\npr_warning("%s: Port %d red alarm ended.\n",\r\nci->devname, portnum);\r\n} else if (!(copyVal & sbeRedAlm) && (value & sbeRedAlm))\r\n{\r\ncopyVal |= sbeRedAlm;\r\npr_warning("%s: Warning: Port %d red alarm.\n",\r\nci->devname, portnum);\r\n} else if ((copyVal & sbeYelAlm) && !(value & sbeYelAlm))\r\n{\r\ncopyVal &= ~sbeYelAlm;\r\npr_warning("%s: Port %d yellow (RAI) alarm ended.\n",\r\nci->devname, portnum);\r\n} else if (!(copyVal & sbeYelAlm) && (value & sbeYelAlm))\r\n{\r\ncopyVal |= sbeYelAlm;\r\npr_warning("%s: Warning: Port %d yellow (RAI) alarm.\n",\r\nci->devname, portnum);\r\n} else if ((copyVal & sbeAISAlm) && !(value & sbeAISAlm))\r\n{\r\ncopyVal &= ~sbeAISAlm;\r\npr_warning("%s: Port %d blue (AIS) alarm ended.\n",\r\nci->devname, portnum);\r\n} else if (!(copyVal & sbeAISAlm) && (value & sbeAISAlm))\r\n{\r\ncopyVal |= sbeAISAlm;\r\npr_warning("%s: Warning: Port %d blue (AIS) alarm.\n",\r\nci->devname, portnum);\r\n}\r\n}\r\n}\r\n}\r\nif (copyVal & sbeAlarmsMask)\r\ncopyVal |= 0x80;\r\nif (copyVal & 0x10)\r\nLEDval |= 0x100;\r\nLEDval |= ((copyVal & 0xc0) >> (6 - (portnum * 2)));\r\nci->alarmed[portnum] &= 0xfffff000;\r\nci->alarmed[portnum] |= (copyVal);\r\nif (IS_FRAME_ANY_T1 (ci->port[portnum].p.port_mode))\r\n{\r\nvalue = pci_read_32 ((u_int32_t *) &comet->ibcd_ies);\r\nvalue &= 0x3;\r\nif (value & 0x2)\r\n{\r\ncopyVal = c4_loop_port (ci, portnum, COMET_LBCMD_READ);\r\nif (copyVal != COMET_MDIAG_LINELB)\r\nc4_loop_port (ci, portnum, COMET_MDIAG_LINELB);\r\n}\r\nif (value & 0x1)\r\n{\r\ncopyVal = c4_loop_port (ci, portnum, COMET_LBCMD_READ);\r\nif (copyVal != COMET_MDIAG_LBOFF)\r\nc4_loop_port (ci, portnum, COMET_MDIAG_LBOFF);\r\n}\r\n}\r\nif (IS_FRAME_ANY_T1ESF (ci->port[portnum].p.port_mode))\r\n{\r\nvalue = pci_read_32 ((u_int32_t *) &comet->t1_rboc_sts) & 0x3f;\r\nif (value == 0x07)\r\nc4_loop_port (ci, portnum, COMET_MDIAG_LINELB);\r\nif (value == 0x0a)\r\nc4_loop_port (ci, portnum, COMET_MDIAG_PAYLB);\r\nif ((value == 0x1c) || (value == 0x19) || (value == 0x12))\r\nc4_loop_port (ci, portnum, COMET_MDIAG_LBOFF);\r\nif (cxt1e1_log_level >= LOG_DEBUG)\r\nif (value != 0x3f)\r\npr_warning("%s: BOC value = %x on Port %d\n",\r\nci->devname, value, portnum);\r\n}\r\n}\r\nif (LEDval & 0x100)\r\npci_write_32 ((u_int32_t *) &ci->cpldbase->leds, LEDval & 0xff);\r\n#endif\r\n}\r\nSTATIC void\r\nc4_watchdog (ci_t * ci)\r\n{\r\nif (drvr_state != SBE_DRVR_AVAILABLE)\r\n{\r\nif (cxt1e1_log_level >= LOG_MONITOR)\r\npr_info("drvr not available (%x)\n", drvr_state);\r\nreturn;\r\n}\r\nci->wdcount++;\r\ncheckPorts (ci);\r\nci->wd_notify = 0;\r\n}\r\nvoid\r\nc4_cleanup (void)\r\n{\r\nci_t *ci, *next;\r\nmpi_t *pi;\r\nint portnum, j;\r\nci = c4_list;\r\nwhile (ci)\r\n{\r\nnext = ci->next;\r\npci_write_32 ((u_int32_t *) &ci->cpldbase->leds, PMCC4_CPLD_LED_OFF);\r\nfor (portnum = 0; portnum < ci->max_port; portnum++)\r\n{\r\npi = &ci->port[portnum];\r\nc4_wq_port_cleanup (pi);\r\nfor (j = 0; j < MUSYCC_NCHANS; j++)\r\n{\r\nif (pi->chan[j])\r\nOS_kfree (pi->chan[j]);\r\n}\r\nOS_kfree (pi->regram_saved);\r\n}\r\nOS_kfree (ci->iqd_p_saved);\r\nOS_kfree (ci);\r\nci = next;\r\n}\r\n}\r\nint\r\nc4_get_portcfg (ci_t * ci)\r\n{\r\ncomet_t *comet;\r\nint portnum, mask;\r\nu_int32_t wdata, rdata;\r\nwdata = COMET_MDIAG_LBOFF;\r\nmask = 0;\r\nfor (portnum = 0; portnum < MUSYCC_NPORTS; portnum++)\r\n{\r\ncomet = ci->port[portnum].cometbase;\r\npci_write_32 ((u_int32_t *) &comet->mdiag, wdata);\r\nrdata = pci_read_32 ((u_int32_t *) &comet->mdiag) & COMET_MDIAG_LBMASK;\r\nif (wdata == rdata)\r\nmask |= 1 << portnum;\r\n}\r\nreturn mask;\r\n}\r\nstatus_t __init\r\nc4_init (ci_t * ci, u_char *func0, u_char *func1)\r\n{\r\nmpi_t *pi;\r\nmch_t *ch;\r\nstatic u_int32_t count = 0;\r\nint portnum, j;\r\nci->state = C_INIT;\r\nci->brdno = count++;\r\nci->intlog.this_status_new = 0;\r\natomic_set (&ci->bh_pending, 0);\r\nci->reg = (struct musycc_globalr *) func0;\r\nci->eeprombase = (u_int32_t *) (func1 + EEPROM_OFFSET);\r\nci->cpldbase = (c4cpld_t *) ((u_int32_t *) (func1 + ISPLD_OFFSET));\r\n#ifdef CONFIG_SBE_PMCC4_NCOMM\r\npci_write_32 ((u_int32_t *) &ci->reg->glcd, GCD_MAGIC);\r\n#else\r\npci_write_32 ((u_int32_t *) &ci->reg->glcd, GCD_MAGIC | MUSYCC_GCD_INTB_DISABLE);\r\n#endif\r\n{\r\nint pmsk;\r\nfor (portnum = 0; portnum < MUSYCC_NPORTS; portnum++)\r\n{\r\npi = &ci->port[portnum];\r\npi->cometbase = (comet_t *) ((u_int32_t *) (func1 + COMET_OFFSET (portnum)));\r\npi->reg = (struct musycc_globalr *) ((u_char *) ci->reg + (portnum * 0x800));\r\npi->portnum = portnum;\r\npi->p.portnum = portnum;\r\npi->openchans = 0;\r\n#ifdef SBE_MAP_DEBUG\r\npr_info("Comet-%d: addr = %p\n", portnum, pi->cometbase);\r\n#endif\r\n}\r\npmsk = c4_get_portcfg (ci);\r\nswitch (pmsk)\r\n{\r\ncase 0x1:\r\nci->max_port = 1;\r\nbreak;\r\ncase 0x3:\r\nci->max_port = 2;\r\nbreak;\r\n#if 0\r\ncase 0x7:\r\nci->max_port = 3;\r\nbreak;\r\n#endif\r\ncase 0xf:\r\nci->max_port = 4;\r\nbreak;\r\ndefault:\r\nci->max_port = 0;\r\npr_warning("%s: illegal port configuration (%x)\n",\r\nci->devname, pmsk);\r\nreturn SBE_DRVR_FAIL;\r\n}\r\n#ifdef SBE_MAP_DEBUG\r\npr_info(">> %s: c4_get_build - pmsk %x max_port %x\n",\r\nci->devname, pmsk, ci->max_port);\r\n#endif\r\n}\r\nfor (portnum = 0; portnum < ci->max_port; portnum++)\r\n{\r\npi = &ci->port[portnum];\r\npi->up = ci;\r\npi->sr_last = 0xffffffff;\r\npi->p.port_mode = CFG_FRAME_SF;\r\npi->p.portP = (CFG_CLK_PORT_EXTERNAL | CFG_LBO_LH0);\r\nOS_sem_init (&pi->sr_sem_busy, SEM_AVAILABLE);\r\nOS_sem_init (&pi->sr_sem_wait, SEM_TAKEN);\r\nfor (j = 0; j < 32; j++)\r\n{\r\npi->fifomap[j] = -1;\r\npi->tsm[j] = 0;\r\n}\r\nfor (j = 0; j < MUSYCC_NCHANS; j++)\r\n{\r\nch = OS_kmalloc (sizeof (mch_t));\r\nif (ch)\r\n{\r\npi->chan[j] = ch;\r\nch->state = UNASSIGNED;\r\nch->up = pi;\r\nch->gchan = (-1);\r\nch->channum = (-1);\r\nch->p.card = ci->brdno;\r\nch->p.port = portnum;\r\nch->p.channum = (-1);\r\nch->p.mode_56k = 0;\r\n} else\r\n{\r\npr_warning("failed mch_t malloc, port %d channel %d size %u.\n",\r\nportnum, j, (unsigned int) sizeof (mch_t));\r\nbreak;\r\n}\r\n}\r\n}\r\n{\r\npci_write_32 ((u_int32_t *) &ci->cpldbase->leds,\r\nPMCC4_CPLD_LED_GREEN | PMCC4_CPLD_LED_YELLOW);\r\nOS_uwait (750000, "leds");\r\npci_write_32 ((u_int32_t *) &ci->cpldbase->leds, PMCC4_CPLD_LED_OFF);\r\n}\r\nOS_init_watchdog (&ci->wd, (void (*) (void *)) c4_watchdog, ci, WATCHDOG_TIMEOUT);\r\nreturn SBE_DRVR_SUCCESS;\r\n}\r\nstatus_t __init\r\nc4_init2 (ci_t * ci)\r\n{\r\nstatus_t ret;\r\nif ((ret = musycc_init (ci)) != SBE_DRVR_SUCCESS)\r\nreturn ret;\r\n#if 0\r\nci->p.framing_type = FRAMING_CBP;\r\nci->p.h110enable = 1;\r\n#if 0\r\nci->p.hypersize = 0;\r\n#else\r\nhyperdummy = 0;\r\n#endif\r\nci->p.clock = 0;\r\nc4_card_set_params (ci, &ci->p);\r\n#endif\r\nOS_start_watchdog (&ci->wd);\r\nreturn SBE_DRVR_SUCCESS;\r\n}\r\nint\r\nc4_loop_port (ci_t * ci, int portnum, u_int8_t cmd)\r\n{\r\ncomet_t *comet;\r\nvolatile u_int32_t loopValue;\r\ncomet = ci->port[portnum].cometbase;\r\nloopValue = pci_read_32 ((u_int32_t *) &comet->mdiag) & COMET_MDIAG_LBMASK;\r\nif (cmd & COMET_LBCMD_READ)\r\nreturn loopValue;\r\nif (loopValue != cmd)\r\n{\r\nswitch (cmd)\r\n{\r\ncase COMET_MDIAG_LINELB:\r\npci_write_32 ((u_int32_t *) &comet->ibcd_cfg, 0x05);\r\nbreak;\r\ncase COMET_MDIAG_LBOFF:\r\npci_write_32 ((u_int32_t *) &comet->ibcd_cfg, 0x00);\r\nbreak;\r\n}\r\npci_write_32 ((u_int32_t *) &comet->mdiag, cmd);\r\nif (cxt1e1_log_level >= LOG_WARN)\r\npr_info("%s: loopback mode changed to %2x from %2x on Port %d\n",\r\nci->devname, cmd, loopValue, portnum);\r\nloopValue = pci_read_32 ((u_int32_t *) &comet->mdiag) & COMET_MDIAG_LBMASK;\r\nif (loopValue != cmd)\r\n{\r\nif (cxt1e1_log_level >= LOG_ERROR)\r\npr_info("%s: write to loop register failed, unknown state for Port %d\n",\r\nci->devname, portnum);\r\n}\r\n} else\r\n{\r\nif (cxt1e1_log_level >= LOG_WARN)\r\npr_info("%s: loopback already in that mode (%2x)\n",\r\nci->devname, loopValue);\r\n}\r\nreturn 0;\r\n}\r\nstatus_t\r\nc4_frame_rw (ci_t * ci, struct sbecom_port_param * pp)\r\n{\r\ncomet_t *comet;\r\nvolatile u_int32_t data;\r\nif (pp->portnum >= ci->max_port)\r\nreturn ENXIO;\r\ncomet = ci->port[pp->portnum].cometbase;\r\ndata = pci_read_32 ((u_int32_t *) comet + pp->port_mode) & 0xff;\r\nif (pp->portP)\r\n{\r\nif (pp->portStatus == data)\r\npr_info("%s: Port %d already that value! Writing again anyhow.\n",\r\nci->devname, pp->portnum);\r\npp->portP = (u_int8_t) data;\r\npci_write_32 ((u_int32_t *) comet + pp->port_mode,\r\npp->portStatus);\r\ndata = pci_read_32 ((u_int32_t *) comet + pp->port_mode) & 0xff;\r\n}\r\npp->portStatus = (u_int8_t) data;\r\nreturn 0;\r\n}\r\nstatus_t\r\nc4_pld_rw (ci_t * ci, struct sbecom_port_param * pp)\r\n{\r\nvolatile u_int32_t *regaddr;\r\nvolatile u_int32_t data;\r\nint regnum = pp->port_mode;\r\nregaddr = (u_int32_t *) ci->cpldbase + regnum;\r\ndata = pci_read_32 ((u_int32_t *) regaddr) & 0xff;\r\nif (pp->portP)\r\n{\r\npp->portP = (u_int8_t) data;\r\npci_write_32 ((u_int32_t *) regaddr, pp->portStatus);\r\ndata = pci_read_32 ((u_int32_t *) regaddr) & 0xff;\r\n}\r\npp->portStatus = (u_int8_t) data;\r\nreturn 0;\r\n}\r\nstatus_t\r\nc4_musycc_rw (ci_t * ci, struct c4_musycc_param * mcp)\r\n{\r\nmpi_t *pi;\r\nvolatile u_int32_t *dph;\r\nu_int32_t *dpr = 0;\r\nint offset = mcp->offset % 0x800;\r\nint portnum, ramread = 0;\r\nvolatile u_int32_t data;\r\nportnum = (mcp->offset % 0x6000) / 0x800;\r\nif (portnum >= ci->max_port)\r\nreturn ENXIO;\r\npi = &ci->port[portnum];\r\nif (mcp->offset >= 0x6000)\r\noffset += 0x6000;\r\ndph = (u_int32_t *) ((u_long) pi->reg + offset);\r\ndpr = (u_int32_t *) ((u_long) pi->regram + offset);\r\nif (mcp->offset < 0x6000)\r\n{\r\nif (offset >= 0x200 && offset < 0x380)\r\nramread = 1;\r\nif (offset >= 0x10 && offset < 0x200)\r\nramread = 1;\r\n}\r\nif (ramread)\r\n{\r\ndata = *dpr;\r\n} else\r\n{\r\ndata = pci_read_32 ((u_int32_t *) dph);\r\n}\r\nif (mcp->RWportnum & 0x80)\r\n{\r\nif (mcp->value == data)\r\npr_info("%s: musycc grp%d already that value! writing again anyhow.\n",\r\nci->devname, (mcp->RWportnum & 0x7));\r\nif (ramread)\r\n*dpr = mcp->value;\r\npci_write_32 ((u_int32_t *) dph, mcp->value);\r\n}\r\nmcp->value = data;\r\nreturn 0;\r\n}\r\nstatus_t\r\nc4_get_port (ci_t * ci, int portnum)\r\n{\r\nif (portnum >= ci->max_port)\r\nreturn ENXIO;\r\nSD_SEM_TAKE (&ci->sem_wdbusy, "_wd_");\r\ncheckPorts (ci);\r\nci->port[portnum].p.portStatus = (u_int8_t) ci->alarmed[portnum];\r\nci->alarmed[portnum] &= 0xdf;\r\nSD_SEM_GIVE (&ci->sem_wdbusy);\r\nreturn 0;\r\n}\r\nstatus_t\r\nc4_set_port (ci_t * ci, int portnum)\r\n{\r\nmpi_t *pi;\r\nstruct sbecom_port_param *pp;\r\nint e1mode;\r\nu_int8_t clck;\r\nint i;\r\nif (portnum >= ci->max_port)\r\nreturn ENXIO;\r\npi = &ci->port[portnum];\r\npp = &ci->port[portnum].p;\r\ne1mode = IS_FRAME_ANY_E1 (pp->port_mode);\r\nif (cxt1e1_log_level >= LOG_MONITOR2)\r\n{\r\npr_info("%s: c4_set_port[%d]: entered, e1mode = %x, openchans %d.\n",\r\nci->devname,\r\nportnum, e1mode, pi->openchans);\r\n}\r\nif (pi->openchans)\r\nreturn EBUSY;\r\n{\r\nstatus_t ret;\r\nif ((ret = c4_wq_port_init (pi)))\r\nreturn (ret);\r\n}\r\ninit_comet (ci, pi->cometbase, pp->port_mode, 1 , pp->portP);\r\nclck = pci_read_32 ((u_int32_t *) &ci->cpldbase->mclk) & PMCC4_CPLD_MCLK_MASK;\r\nif (e1mode)\r\nclck |= 1 << portnum;\r\nelse\r\nclck &= 0xf ^ (1 << portnum);\r\npci_write_32 ((u_int32_t *) &ci->cpldbase->mclk, clck);\r\npci_write_32 ((u_int32_t *) &ci->cpldbase->mcsr, PMCC4_CPLD_MCSR_IND);\r\npci_write_32 ((u_int32_t *) &pi->reg->gbp, OS_vtophys (pi->regram));\r\npi->regram->grcd =\r\n__constant_cpu_to_le32 (MUSYCC_GRCD_RX_ENABLE |\r\nMUSYCC_GRCD_TX_ENABLE |\r\nMUSYCC_GRCD_OOFMP_DISABLE |\r\nMUSYCC_GRCD_SF_ALIGN |\r\nMUSYCC_GRCD_COFAIRQ_DISABLE |\r\nMUSYCC_GRCD_MC_ENABLE |\r\n(MUSYCC_GRCD_POLLTH_32 << MUSYCC_GRCD_POLLTH_SHIFT));\r\npi->regram->pcd =\r\n__constant_cpu_to_le32 ((e1mode ? 1 : 0) |\r\nMUSYCC_PCD_TXSYNC_RISING |\r\nMUSYCC_PCD_RXSYNC_RISING |\r\nMUSYCC_PCD_RXDATA_RISING);\r\npi->regram->mld = __constant_cpu_to_le32 (cxt1e1_max_mru | (cxt1e1_max_mru << 16));\r\nfor (i = 0; i < 32; i++)\r\n{\r\nif (((i == 0) && e1mode) ||\r\n((i == 16) && ((pp->port_mode == CFG_FRAME_E1CRC_CAS) || (pp->port_mode == CFG_FRAME_E1CRC_CAS_AMI)))\r\n|| ((i > 23) && (!e1mode)))\r\n{\r\npi->tsm[i] = 0xff;\r\n} else\r\n{\r\npi->tsm[i] = 0x00;\r\n}\r\n}\r\nfor (i = 0; i < MUSYCC_NCHANS; i++)\r\n{\r\npi->regram->ttsm[i] = 0;\r\npi->regram->rtsm[i] = 0;\r\n}\r\nFLUSH_MEM_WRITE ();\r\nmusycc_serv_req (pi, SR_GROUP_INIT | SR_RX_DIRECTION);\r\nmusycc_serv_req (pi, SR_GROUP_INIT | SR_TX_DIRECTION);\r\nmusycc_init_mdt (pi);\r\npi->group_is_set = 1;\r\npi->p = *pp;\r\nreturn 0;\r\n}\r\nstatus_t\r\nc4_new_chan (ci_t * ci, int portnum, int channum, void *user)\r\n{\r\nmpi_t *pi;\r\nmch_t *ch;\r\nint gchan;\r\nif (c4_find_chan (channum))\r\nreturn EEXIST;\r\nif (portnum >= ci->max_port)\r\nreturn ENXIO;\r\npi = &(ci->port[portnum]);\r\nfor (gchan = 0; gchan < MUSYCC_NCHANS; gchan++)\r\n{\r\nch = pi->chan[gchan];\r\nif (ch && ch->state == UNASSIGNED)\r\nbreak;\r\n}\r\nif (gchan == MUSYCC_NCHANS)\r\nreturn ENFILE;\r\nch->up = pi;\r\nch->state = DOWN;\r\nch->user = user;\r\nch->gchan = gchan;\r\nch->channum = channum;\r\nch->p.channum = channum;\r\n#if 1\r\nch->p.card = ci->brdno;\r\nch->p.port = portnum;\r\n#endif\r\nch->p.chan_mode = CFG_CH_PROTO_HDLC_FCS16;\r\nch->p.idlecode = CFG_CH_FLAG_7E;\r\nch->p.pad_fill_count = 2;\r\nspin_lock_init (&ch->ch_rxlock);\r\nspin_lock_init (&ch->ch_txlock);\r\n{\r\nstatus_t ret;\r\nif ((ret = c4_wk_chan_init (pi, ch)))\r\nreturn ret;\r\n}\r\nif (ci->first_if == 0)\r\n{\r\nci->first_if = ci->last_if = user;\r\nci->first_channum = ci->last_channum = channum;\r\n} else\r\n{\r\nci->last_if = user;\r\nif (ci->last_channum < channum)\r\nci->last_channum = channum;\r\n}\r\nreturn 0;\r\n}\r\nstatus_t\r\nc4_del_chan (int channum)\r\n{\r\nmch_t *ch;\r\nif (!(ch = c4_find_chan (channum)))\r\nreturn ENOENT;\r\nif (ch->state == UP)\r\nmusycc_chan_down ((ci_t *) 0, channum);\r\nch->state = UNASSIGNED;\r\nch->gchan = (-1);\r\nch->channum = (-1);\r\nch->p.channum = (-1);\r\nreturn 0;\r\n}\r\nstatus_t\r\nc4_del_chan_stats (int channum)\r\n{\r\nmch_t *ch;\r\nif (!(ch = c4_find_chan (channum)))\r\nreturn ENOENT;\r\nmemset (&ch->s, 0, sizeof (struct sbecom_chan_stats));\r\nreturn 0;\r\n}\r\nstatus_t\r\nc4_set_chan (int channum, struct sbecom_chan_param * p)\r\n{\r\nmch_t *ch;\r\nint i, x = 0;\r\nif (!(ch = c4_find_chan (channum)))\r\nreturn ENOENT;\r\n#if 1\r\nif (ch->p.card != p->card ||\r\nch->p.port != p->port ||\r\nch->p.channum != p->channum)\r\nreturn EINVAL;\r\n#endif\r\nif (!(ch->up->group_is_set))\r\n{\r\nreturn EIO;\r\n}\r\nif (ch->p.status != p->status || ch->p.chan_mode != p->chan_mode ||\r\nch->p.data_inv != p->data_inv || ch->p.intr_mask != p->intr_mask ||\r\nch->txd_free < ch->txd_num)\r\nx = 1;\r\nfor (i = 0; i < 32; i++)\r\nif (ch->p.bitmask[i] != p->bitmask[i])\r\nx = 1;\r\nch->p = *p;\r\nif (x && (ch->state == UP))\r\n{\r\nstatus_t ret;\r\nif ((ret = musycc_chan_down ((ci_t *) 0, channum)))\r\nreturn ret;\r\nif ((ret = c4_chan_up (ch->up->up, channum)))\r\nreturn ret;\r\nsd_enable_xmit (ch->user);\r\n}\r\nreturn 0;\r\n}\r\nstatus_t\r\nc4_get_chan (int channum, struct sbecom_chan_param * p)\r\n{\r\nmch_t *ch;\r\nif (!(ch = c4_find_chan (channum)))\r\nreturn ENOENT;\r\n*p = ch->p;\r\nreturn 0;\r\n}\r\nstatus_t\r\nc4_get_chan_stats (int channum, struct sbecom_chan_stats * p)\r\n{\r\nmch_t *ch;\r\nif (!(ch = c4_find_chan (channum)))\r\nreturn ENOENT;\r\n*p = ch->s;\r\np->tx_pending = atomic_read (&ch->tx_pending);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nc4_fifo_alloc (mpi_t * pi, int chan, int *len)\r\n{\r\nint i, l = 0, start = 0, max = 0, maxstart = 0;\r\nfor (i = 0; i < 32; i++)\r\n{\r\nif (pi->fifomap[i] != -1)\r\n{\r\nl = 0;\r\nstart = i + 1;\r\ncontinue;\r\n}\r\n++l;\r\nif (l > max)\r\n{\r\nmax = l;\r\nmaxstart = start;\r\n}\r\nif (max == *len)\r\nbreak;\r\n}\r\nif (max != *len)\r\n{\r\nif (cxt1e1_log_level >= LOG_WARN)\r\npr_info("%s: wanted to allocate %d fifo space, but got only %d\n",\r\npi->up->devname, *len, max);\r\n*len = max;\r\n}\r\nif (cxt1e1_log_level >= LOG_DEBUG)\r\npr_info("%s: allocated %d fifo at %d for channel %d/%d\n",\r\npi->up->devname, max, start, chan, pi->p.portnum);\r\nfor (i = maxstart; i < (maxstart + max); i++)\r\npi->fifomap[i] = chan;\r\nreturn start;\r\n}\r\nvoid\r\nc4_fifo_free (mpi_t * pi, int chan)\r\n{\r\nint i;\r\nif (cxt1e1_log_level >= LOG_DEBUG)\r\npr_info("%s: deallocated fifo for channel %d/%d\n",\r\npi->up->devname, chan, pi->p.portnum);\r\nfor (i = 0; i < 32; i++)\r\nif (pi->fifomap[i] == chan)\r\npi->fifomap[i] = -1;\r\n}\r\nstatus_t\r\nc4_chan_up (ci_t * ci, int channum)\r\n{\r\nmpi_t *pi;\r\nmch_t *ch;\r\nstruct mbuf *m;\r\nstruct mdesc *md;\r\nint nts, nbuf, txnum, rxnum;\r\nint addr, i, j, gchan;\r\nu_int32_t tmp;\r\nif (!(ch = c4_find_chan (channum)))\r\nreturn ENOENT;\r\nif (ch->state == UP)\r\n{\r\nif (cxt1e1_log_level >= LOG_MONITOR)\r\npr_info("%s: channel already UP, graceful early exit\n",\r\nci->devname);\r\nreturn 0;\r\n}\r\npi = ch->up;\r\ngchan = ch->gchan;\r\nnts = 0;\r\nfor (i = 0; i < 32; i++)\r\n{\r\nif (ch->p.bitmask[i] & pi->tsm[i])\r\n{\r\nif (1 || cxt1e1_log_level >= LOG_WARN)\r\n{\r\npr_info("%s: c4_chan_up[%d] EINVAL (attempt to cfg in-use or unavailable TimeSlot[%d])\n",\r\nci->devname, channum, i);\r\npr_info("+ ask4 %x, currently %x\n",\r\nch->p.bitmask[i], pi->tsm[i]);\r\n}\r\nreturn EINVAL;\r\n}\r\nfor (j = 0; j < 8; j++)\r\nif (ch->p.bitmask[i] & (1 << j))\r\nnts++;\r\n}\r\nnbuf = nts / 8 ? nts / 8 : 1;\r\nif (!nbuf)\r\n{\r\npr_info("%s: c4_chan_up[%d] ENOBUFS (no TimeSlots assigned)\n",\r\nci->devname, channum);\r\nreturn ENOBUFS;\r\n}\r\naddr = c4_fifo_alloc (pi, gchan, &nbuf);\r\nch->state = UP;\r\nmusycc_update_timeslots (pi);\r\nch->s.tx_pending = 0;\r\n{\r\nu_int32_t ccd;\r\nccd = musycc_chan_proto (ch->p.chan_mode) << MUSYCC_CCD_PROTO_SHIFT;\r\nif ((ch->p.chan_mode == CFG_CH_PROTO_ISLP_MODE) ||\r\n(ch->p.chan_mode == CFG_CH_PROTO_TRANS))\r\n{\r\nccd |= MUSYCC_CCD_FCS_XFER;\r\n}\r\nccd |= 2 << MUSYCC_CCD_MAX_LENGTH;\r\nccd |= ch->p.intr_mask;\r\nccd |= addr << MUSYCC_CCD_BUFFER_LOC;\r\nif (ch->p.chan_mode == CFG_CH_PROTO_TRANS)\r\nccd |= (nbuf) << MUSYCC_CCD_BUFFER_LENGTH;\r\nelse\r\nccd |= (nbuf - 1) << MUSYCC_CCD_BUFFER_LENGTH;\r\nif (ch->p.data_inv & CFG_CH_DINV_TX)\r\nccd |= MUSYCC_CCD_INVERT_DATA;\r\npi->regram->tcct[gchan] = cpu_to_le32 (ccd);\r\nif (ch->p.data_inv & CFG_CH_DINV_RX)\r\nccd |= MUSYCC_CCD_INVERT_DATA;\r\nelse\r\nccd &= ~MUSYCC_CCD_INVERT_DATA;\r\npi->regram->rcct[gchan] = cpu_to_le32 (ccd);\r\nFLUSH_MEM_WRITE ();\r\n}\r\nmusycc_serv_req (pi, SR_CHANNEL_CONFIG | SR_RX_DIRECTION | gchan);\r\nmusycc_serv_req (pi, SR_CHANNEL_CONFIG | SR_TX_DIRECTION | gchan);\r\nif (ch->p.chan_mode == CFG_CH_PROTO_TRANS)\r\n{\r\nif (max_rxdesc_used == max_rxdesc_default)\r\nmax_rxdesc_used = MUSYCC_RXDESC_TRANS;\r\nif (max_txdesc_used == max_txdesc_default)\r\nmax_txdesc_used = MUSYCC_TXDESC_TRANS;\r\n}\r\nrxnum = max_rxdesc_used + (nts / 4);\r\ntxnum = max_txdesc_used + (nts / 4);\r\n#if 0\r\nif (cxt1e1_log_level >= LOG_MONITOR)\r\npr_info("%s: mode %x rxnum %d (rxused %d def %d) txnum %d (txused %d def %d)\n",\r\nci->devname, ch->p.chan_mode,\r\nrxnum, max_rxdesc_used, max_rxdesc_default,\r\ntxnum, max_txdesc_used, max_txdesc_default);\r\n#endif\r\nch->rxd_num = rxnum;\r\nch->txd_num = txnum;\r\nch->rxix_irq_srv = 0;\r\nch->mdr = OS_kmalloc (sizeof (struct mdesc) * rxnum);\r\nch->mdt = OS_kmalloc (sizeof (struct mdesc) * txnum);\r\nif (ch->p.chan_mode == CFG_CH_PROTO_TRANS)\r\ntmp = __constant_cpu_to_le32 (cxt1e1_max_mru | EOBIRQ_ENABLE);\r\nelse\r\ntmp = __constant_cpu_to_le32 (cxt1e1_max_mru);\r\nfor (i = 0, md = ch->mdr; i < rxnum; i++, md++)\r\n{\r\nif (i == (rxnum - 1))\r\n{\r\nmd->snext = &ch->mdr[0];\r\n} else\r\n{\r\nmd->snext = &ch->mdr[i + 1];\r\n}\r\nmd->next = cpu_to_le32 (OS_vtophys (md->snext));\r\nif (!(m = OS_mem_token_alloc (cxt1e1_max_mru)))\r\n{\r\nif (cxt1e1_log_level >= LOG_MONITOR)\r\npr_info("%s: c4_chan_up[%d] - token alloc failure, size = %d.\n",\r\nci->devname, channum, cxt1e1_max_mru);\r\ngoto errfree;\r\n}\r\nmd->mem_token = m;\r\nmd->data = cpu_to_le32 (OS_vtophys (OS_mem_token_data (m)));\r\nmd->status = tmp | MUSYCC_RX_OWNED;\r\n}\r\nfor (i = 0, md = ch->mdt; i < txnum; i++, md++)\r\n{\r\nmd->status = HOST_TX_OWNED;\r\nmd->mem_token = 0;\r\nmd->data = 0;\r\nif (i == (txnum - 1))\r\n{\r\nmd->snext = &ch->mdt[0];\r\n} else\r\n{\r\nmd->snext = &ch->mdt[i + 1];\r\n}\r\nmd->next = cpu_to_le32 (OS_vtophys (md->snext));\r\n}\r\nch->txd_irq_srv = ch->txd_usr_add = &ch->mdt[0];\r\nch->txd_free = txnum;\r\nch->tx_full = 0;\r\nch->txd_required = 0;\r\ntmp = cpu_to_le32 (OS_vtophys (&ch->mdt[0]));\r\npi->regram->thp[gchan] = tmp;\r\npi->regram->tmp[gchan] = tmp;\r\ntmp = cpu_to_le32 (OS_vtophys (&ch->mdr[0]));\r\npi->regram->rhp[gchan] = tmp;\r\npi->regram->rmp[gchan] = tmp;\r\nFLUSH_MEM_WRITE ();\r\nif (ch->p.status & RX_ENABLED)\r\n{\r\n#ifdef RLD_TRANS_DEBUG\r\npr_info("++ c4_chan_up() CHAN RX ACTIVATE: chan %d\n", ch->channum);\r\n#endif\r\nch->ch_start_rx = 0;\r\nmusycc_serv_req (pi, SR_CHANNEL_ACTIVATE | SR_RX_DIRECTION | gchan);\r\n}\r\nif (ch->p.status & TX_ENABLED)\r\n{\r\n#ifdef RLD_TRANS_DEBUG\r\npr_info("++ c4_chan_up() CHAN TX ACTIVATE: chan %d <delayed>\n", ch->channum);\r\n#endif\r\nch->ch_start_tx = CH_START_TX_1ST;\r\n}\r\nch->status = ch->p.status;\r\npi->openchans++;\r\nreturn 0;\r\nerrfree:\r\nwhile (i > 0)\r\n{\r\ni--;\r\nOS_mem_token_free (ch->mdr[i].mem_token);\r\n}\r\nOS_kfree (ch->mdt);\r\nch->mdt = 0;\r\nch->txd_num = 0;\r\nOS_kfree (ch->mdr);\r\nch->mdr = 0;\r\nch->rxd_num = 0;\r\nch->state = DOWN;\r\nreturn ENOBUFS;\r\n}\r\nvoid\r\nc4_stopwd (ci_t * ci)\r\n{\r\nOS_stop_watchdog (&ci->wd);\r\nSD_SEM_TAKE (&ci->sem_wdbusy, "_stop_");\r\nSD_SEM_GIVE (&ci->sem_wdbusy);\r\n}\r\nvoid\r\nsbecom_get_brdinfo (ci_t * ci, struct sbe_brd_info * bip, u_int8_t *bsn)\r\n{\r\nchar *np;\r\nu_int32_t sn = 0;\r\nint i;\r\nbip->brdno = ci->brdno;\r\nbip->brd_id = ci->brd_id;\r\nbip->brd_hdw_id = ci->hdw_bid;\r\nbip->brd_chan_cnt = MUSYCC_NCHANS * ci->max_port;\r\nbip->brd_port_cnt = ci->max_port;\r\nbip->brd_pci_speed = BINFO_PCI_SPEED_unk;\r\nif (ci->first_if)\r\n{\r\n{\r\nstruct net_device *dev;\r\ndev = (struct net_device *) ci->first_if;\r\nnp = (char *) dev->name;\r\n}\r\nstrncpy (bip->first_iname, np, CHNM_STRLEN - 1);\r\n} else\r\nstrcpy (bip->first_iname, "<NULL>");\r\nif (ci->last_if)\r\n{\r\n{\r\nstruct net_device *dev;\r\ndev = (struct net_device *) ci->last_if;\r\nnp = (char *) dev->name;\r\n}\r\nstrncpy (bip->last_iname, np, CHNM_STRLEN - 1);\r\n} else\r\nstrcpy (bip->last_iname, "<NULL>");\r\nif (bsn)\r\n{\r\nfor (i = 0; i < 3; i++)\r\n{\r\nbip->brd_mac_addr[i] = *bsn++;\r\n}\r\nfor (; i < 6; i++)\r\n{\r\nbip->brd_mac_addr[i] = *bsn;\r\nsn = (sn << 8) | *bsn++;\r\n}\r\n} else\r\n{\r\nfor (i = 0; i < 6; i++)\r\nbip->brd_mac_addr[i] = 0;\r\n}\r\nbip->brd_sn = sn;\r\n}\r\nstatus_t\r\nc4_get_iidinfo (ci_t * ci, struct sbe_iid_info * iip)\r\n{\r\nstruct net_device *dev;\r\nchar *np;\r\nif (!(dev = getuserbychan (iip->channum)))\r\nreturn ENOENT;\r\nnp = dev->name;\r\nstrncpy (iip->iname, np, CHNM_STRLEN - 1);\r\nreturn 0;\r\n}\r\nvoid\r\nwanpmcC4T1E1_hookInterrupt (int cardID, int deviceID, void *handler)\r\n{\r\nif (cardID < MAX_BOARDS)\r\nnciInterrupt[cardID][deviceID] = handler;\r\n}\r\nirqreturn_t\r\nc4_ebus_intr_th_handler (void *devp)\r\n{\r\nci_t *ci = (ci_t *) devp;\r\nvolatile u_int32_t ists;\r\nint handled = 0;\r\nint brdno;\r\nbrdno = ci->brdno;\r\nists = pci_read_32 ((u_int32_t *) &ci->cpldbase->intr);\r\nif (ists & PMCC4_CPLD_INTR_CMT_1)\r\n{\r\nhandled = 0x1;\r\nif (nciInterrupt[brdno][0] != NULL)\r\n(*nciInterrupt[brdno][0]) ();\r\n}\r\nif (ists & PMCC4_CPLD_INTR_CMT_2)\r\n{\r\nhandled |= 0x2;\r\nif (nciInterrupt[brdno][1] != NULL)\r\n(*nciInterrupt[brdno][1]) ();\r\n}\r\nif (ists & PMCC4_CPLD_INTR_CMT_3)\r\n{\r\nhandled |= 0x4;\r\nif (nciInterrupt[brdno][2] != NULL)\r\n(*nciInterrupt[brdno][2]) ();\r\n}\r\nif (ists & PMCC4_CPLD_INTR_CMT_4)\r\n{\r\nhandled |= 0x8;\r\nif (nciInterrupt[brdno][3] != NULL)\r\n(*nciInterrupt[brdno][3]) ();\r\n}\r\n#if 0\r\npci_write_32 ((u_int32_t *) &ci->reg->glcd, GCD_MAGIC | MUSYCC_GCD_INTB_DISABLE);\r\n#endif\r\nreturn IRQ_RETVAL (handled);\r\n}\r\nunsigned long\r\nwanpmcC4T1E1_getBaseAddress (int cardID, int deviceID)\r\n{\r\nci_t *ci;\r\nunsigned long base = 0;\r\nci = c4_list;\r\nwhile (ci)\r\n{\r\nif (ci->brdno == cardID)\r\n{\r\nif (deviceID < ci->max_port)\r\nbase = ((unsigned long) ci->port[deviceID].cometbase);\r\nbreak;\r\n}\r\nci = ci->next;\r\n}\r\nreturn (base);\r\n}
