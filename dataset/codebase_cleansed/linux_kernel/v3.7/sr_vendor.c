void sr_vendor_init(Scsi_CD *cd)\r\n{\r\n#ifndef CONFIG_BLK_DEV_SR_VENDOR\r\ncd->vendor = VENDOR_SCSI3;\r\n#else\r\nconst char *vendor = cd->device->vendor;\r\nconst char *model = cd->device->model;\r\ncd->vendor = VENDOR_SCSI3;\r\nif (cd->readcd_known)\r\nreturn;\r\nif (cd->device->type == TYPE_WORM) {\r\ncd->vendor = VENDOR_WRITER;\r\n} else if (!strncmp(vendor, "NEC", 3)) {\r\ncd->vendor = VENDOR_NEC;\r\nif (!strncmp(model, "CD-ROM DRIVE:25", 15) ||\r\n!strncmp(model, "CD-ROM DRIVE:36", 15) ||\r\n!strncmp(model, "CD-ROM DRIVE:83", 15) ||\r\n!strncmp(model, "CD-ROM DRIVE:84 ", 16)\r\n#if 0\r\n|| !strncmp(model, "CD-ROM DRIVE:500", 16)\r\n#endif\r\n)\r\ncd->cdi.mask |= CDC_MULTI_SESSION;\r\n} else if (!strncmp(vendor, "TOSHIBA", 7)) {\r\ncd->vendor = VENDOR_TOSHIBA;\r\n}\r\n#endif\r\n}\r\nint sr_set_blocklength(Scsi_CD *cd, int blocklength)\r\n{\r\nunsigned char *buffer;\r\nstruct packet_command cgc;\r\nstruct ccs_modesel_head *modesel;\r\nint rc, density = 0;\r\n#ifdef CONFIG_BLK_DEV_SR_VENDOR\r\nif (cd->vendor == VENDOR_TOSHIBA)\r\ndensity = (blocklength > 2048) ? 0x81 : 0x83;\r\n#endif\r\nbuffer = kmalloc(512, GFP_KERNEL | GFP_DMA);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\n#ifdef DEBUG\r\nprintk("%s: MODE SELECT 0x%x/%d\n", cd->cdi.name, density, blocklength);\r\n#endif\r\nmemset(&cgc, 0, sizeof(struct packet_command));\r\ncgc.cmd[0] = MODE_SELECT;\r\ncgc.cmd[1] = (1 << 4);\r\ncgc.cmd[4] = 12;\r\nmodesel = (struct ccs_modesel_head *) buffer;\r\nmemset(modesel, 0, sizeof(*modesel));\r\nmodesel->block_desc_length = 0x08;\r\nmodesel->density = density;\r\nmodesel->block_length_med = (blocklength >> 8) & 0xff;\r\nmodesel->block_length_lo = blocklength & 0xff;\r\ncgc.buffer = buffer;\r\ncgc.buflen = sizeof(*modesel);\r\ncgc.data_direction = DMA_TO_DEVICE;\r\ncgc.timeout = VENDOR_TIMEOUT;\r\nif (0 == (rc = sr_do_ioctl(cd, &cgc))) {\r\ncd->device->sector_size = blocklength;\r\n}\r\n#ifdef DEBUG\r\nelse\r\nprintk("%s: switching blocklength to %d bytes failed\n",\r\ncd->cdi.name, blocklength);\r\n#endif\r\nkfree(buffer);\r\nreturn rc;\r\n}\r\nint sr_cd_check(struct cdrom_device_info *cdi)\r\n{\r\nScsi_CD *cd = cdi->handle;\r\nunsigned long sector;\r\nunsigned char *buffer;\r\nstruct packet_command cgc;\r\nint rc, no_multi;\r\nif (cd->cdi.mask & CDC_MULTI_SESSION)\r\nreturn 0;\r\nbuffer = kmalloc(512, GFP_KERNEL | GFP_DMA);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nsector = 0;\r\nno_multi = 0;\r\nrc = 0;\r\nmemset(&cgc, 0, sizeof(struct packet_command));\r\nswitch (cd->vendor) {\r\ncase VENDOR_SCSI3:\r\ncgc.cmd[0] = READ_TOC;\r\ncgc.cmd[8] = 12;\r\ncgc.cmd[9] = 0x40;\r\ncgc.buffer = buffer;\r\ncgc.buflen = 12;\r\ncgc.quiet = 1;\r\ncgc.data_direction = DMA_FROM_DEVICE;\r\ncgc.timeout = VENDOR_TIMEOUT;\r\nrc = sr_do_ioctl(cd, &cgc);\r\nif (rc != 0)\r\nbreak;\r\nif ((buffer[0] << 8) + buffer[1] < 0x0a) {\r\nprintk(KERN_INFO "%s: Hmm, seems the drive "\r\n"doesn't support multisession CD's\n", cd->cdi.name);\r\nno_multi = 1;\r\nbreak;\r\n}\r\nsector = buffer[11] + (buffer[10] << 8) +\r\n(buffer[9] << 16) + (buffer[8] << 24);\r\nif (buffer[6] <= 1) {\r\nsector = 0;\r\n}\r\nbreak;\r\n#ifdef CONFIG_BLK_DEV_SR_VENDOR\r\ncase VENDOR_NEC:{\r\nunsigned long min, sec, frame;\r\ncgc.cmd[0] = 0xde;\r\ncgc.cmd[1] = 0x03;\r\ncgc.cmd[2] = 0xb0;\r\ncgc.buffer = buffer;\r\ncgc.buflen = 0x16;\r\ncgc.quiet = 1;\r\ncgc.data_direction = DMA_FROM_DEVICE;\r\ncgc.timeout = VENDOR_TIMEOUT;\r\nrc = sr_do_ioctl(cd, &cgc);\r\nif (rc != 0)\r\nbreak;\r\nif (buffer[14] != 0 && buffer[14] != 0xb0) {\r\nprintk(KERN_INFO "%s: Hmm, seems the cdrom "\r\n"doesn't support multisession CD's\n",\r\ncd->cdi.name);\r\nno_multi = 1;\r\nbreak;\r\n}\r\nmin = bcd2bin(buffer[15]);\r\nsec = bcd2bin(buffer[16]);\r\nframe = bcd2bin(buffer[17]);\r\nsector = min * CD_SECS * CD_FRAMES + sec * CD_FRAMES + frame;\r\nbreak;\r\n}\r\ncase VENDOR_TOSHIBA:{\r\nunsigned long min, sec, frame;\r\ncgc.cmd[0] = 0xc7;\r\ncgc.cmd[1] = 0x03;\r\ncgc.buffer = buffer;\r\ncgc.buflen = 4;\r\ncgc.quiet = 1;\r\ncgc.data_direction = DMA_FROM_DEVICE;\r\ncgc.timeout = VENDOR_TIMEOUT;\r\nrc = sr_do_ioctl(cd, &cgc);\r\nif (rc == -EINVAL) {\r\nprintk(KERN_INFO "%s: Hmm, seems the drive "\r\n"doesn't support multisession CD's\n",\r\ncd->cdi.name);\r\nno_multi = 1;\r\nbreak;\r\n}\r\nif (rc != 0)\r\nbreak;\r\nmin = bcd2bin(buffer[1]);\r\nsec = bcd2bin(buffer[2]);\r\nframe = bcd2bin(buffer[3]);\r\nsector = min * CD_SECS * CD_FRAMES + sec * CD_FRAMES + frame;\r\nif (sector)\r\nsector -= CD_MSF_OFFSET;\r\nsr_set_blocklength(cd, 2048);\r\nbreak;\r\n}\r\ncase VENDOR_WRITER:\r\ncgc.cmd[0] = READ_TOC;\r\ncgc.cmd[8] = 0x04;\r\ncgc.cmd[9] = 0x40;\r\ncgc.buffer = buffer;\r\ncgc.buflen = 0x04;\r\ncgc.quiet = 1;\r\ncgc.data_direction = DMA_FROM_DEVICE;\r\ncgc.timeout = VENDOR_TIMEOUT;\r\nrc = sr_do_ioctl(cd, &cgc);\r\nif (rc != 0) {\r\nbreak;\r\n}\r\nif ((rc = buffer[2]) == 0) {\r\nprintk(KERN_WARNING\r\n"%s: No finished session\n", cd->cdi.name);\r\nbreak;\r\n}\r\ncgc.cmd[0] = READ_TOC;\r\ncgc.cmd[6] = rc & 0x7f;\r\ncgc.cmd[8] = 0x0c;\r\ncgc.cmd[9] = 0x40;\r\ncgc.buffer = buffer;\r\ncgc.buflen = 12;\r\ncgc.quiet = 1;\r\ncgc.data_direction = DMA_FROM_DEVICE;\r\ncgc.timeout = VENDOR_TIMEOUT;\r\nrc = sr_do_ioctl(cd, &cgc);\r\nif (rc != 0) {\r\nbreak;\r\n}\r\nsector = buffer[11] + (buffer[10] << 8) +\r\n(buffer[9] << 16) + (buffer[8] << 24);\r\nbreak;\r\n#endif\r\ndefault:\r\nprintk(KERN_WARNING\r\n"%s: unknown vendor code (%i), not initialized ?\n",\r\ncd->cdi.name, cd->vendor);\r\nsector = 0;\r\nno_multi = 1;\r\nbreak;\r\n}\r\ncd->ms_offset = sector;\r\ncd->xa_flag = 0;\r\nif (CDS_AUDIO != sr_disk_status(cdi) && 1 == sr_is_xa(cd))\r\ncd->xa_flag = 1;\r\nif (2048 != cd->device->sector_size) {\r\nsr_set_blocklength(cd, 2048);\r\n}\r\nif (no_multi)\r\ncdi->mask |= CDC_MULTI_SESSION;\r\n#ifdef DEBUG\r\nif (sector)\r\nprintk(KERN_DEBUG "%s: multisession offset=%lu\n",\r\ncd->cdi.name, sector);\r\n#endif\r\nkfree(buffer);\r\nreturn rc;\r\n}
