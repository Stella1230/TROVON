static unsigned\r\nnext_clk(unsigned t1_NS, unsigned t2_ps, unsigned fclk_ps)\r\n{\r\nunsigned t1_ps = t1_NS * 1000;\r\nunsigned t1_f, t2_f;\r\nif ((t1_ps + fclk_ps) < t2_ps)\r\nreturn t2_ps / 1000;\r\nt1_f = (t1_ps + fclk_ps - 1) / fclk_ps;\r\nt2_f = (t2_ps + fclk_ps - 1) / fclk_ps;\r\nif (t1_f >= t2_f)\r\nt2_f = t1_f + 1;\r\nreturn (t2_f * fclk_ps) / 1000;\r\n}\r\nstatic int tusb_set_async_mode(unsigned sysclk_ps, unsigned fclk_ps)\r\n{\r\nstruct gpmc_timings t;\r\nunsigned t_acsnh_advnh = sysclk_ps + 3000;\r\nunsigned tmp;\r\nmemset(&t, 0, sizeof(t));\r\nt.cs_on = 8;\r\nt.adv_on = next_clk(t.cs_on, t_acsnh_advnh - 7000, fclk_ps);\r\nt.adv_rd_off = next_clk(t.adv_on, t_acsnh_advnh, fclk_ps);\r\nt.oe_on = next_clk(t.adv_on, t_acsnh_advnh + 1000, fclk_ps);\r\ntmp = t.oe_on * 1000 + 300;\r\nt.access = next_clk(t.oe_on, tmp, fclk_ps);\r\ntmp = t.access * 1000;\r\nt.oe_off = next_clk(t.access, tmp, fclk_ps);\r\nt.cs_rd_off = t.oe_off;\r\ntmp = t.cs_rd_off * 1000 + 7000 ;\r\nt.rd_cycle = next_clk(t.cs_rd_off, tmp, fclk_ps);\r\nt.adv_wr_off = t.adv_rd_off;\r\nt.we_on = next_clk(t.adv_wr_off, t_acsnh_advnh + 1000, fclk_ps);\r\ntmp = t.we_on * 1000 + 300;\r\nt.we_off = next_clk(t.we_on, tmp, fclk_ps);\r\nt.cs_wr_off = t.we_off;\r\ntmp = t.cs_wr_off * 1000 + 7000 ;\r\nt.wr_cycle = next_clk(t.cs_wr_off, tmp, fclk_ps);\r\nreturn gpmc_cs_set_timings(async_cs, &t);\r\n}\r\nstatic int tusb_set_sync_mode(unsigned sysclk_ps, unsigned fclk_ps)\r\n{\r\nstruct gpmc_timings t;\r\nunsigned t_scsnh_advnh = sysclk_ps + 3000;\r\nunsigned tmp;\r\nmemset(&t, 0, sizeof(t));\r\nt.cs_on = 8;\r\nt.adv_on = next_clk(t.cs_on, t_scsnh_advnh - 7000, fclk_ps);\r\nt.sync_clk = 11100 ;\r\ntmp = (t.sync_clk + fclk_ps - 1) / fclk_ps;\r\nif (tmp > 4)\r\nreturn -ERANGE;\r\nif (tmp == 0)\r\ntmp = 1;\r\nt.page_burst_access = (fclk_ps * tmp) / 1000;\r\nt.adv_rd_off = next_clk(t.adv_on, t_scsnh_advnh, fclk_ps);\r\ntmp = (t.adv_rd_off * 1000) + (3 * fclk_ps);\r\nt.oe_on = next_clk(t.adv_on, tmp, fclk_ps);\r\ntmp = (t.oe_on * 1000) + (5 * fclk_ps);\r\nt.access = next_clk(t.oe_on, tmp, fclk_ps);\r\ntmp = (t.access * 1000) + (1 * fclk_ps);\r\nt.oe_off = next_clk(t.access, tmp, fclk_ps);\r\nt.cs_rd_off = t.oe_off;\r\ntmp = t.cs_rd_off * 1000 + 7000 ;\r\nt.rd_cycle = next_clk(t.cs_rd_off, tmp, fclk_ps);\r\nt.adv_wr_off = t.adv_rd_off;\r\ntmp = (t.adv_wr_off * 1000) + (3 * fclk_ps);\r\nt.we_on = next_clk(t.adv_wr_off, tmp, fclk_ps);\r\ntmp = (t.we_on * 1000) + (6 * fclk_ps);\r\nt.we_off = next_clk(t.we_on, tmp, fclk_ps);\r\nt.cs_wr_off = t.we_off;\r\ntmp = t.cs_wr_off * 1000 + 7000 ;\r\nt.wr_cycle = next_clk(t.cs_wr_off, tmp, fclk_ps);\r\nreturn gpmc_cs_set_timings(sync_cs, &t);\r\n}\r\nint tusb6010_platform_retime(unsigned is_refclk)\r\n{\r\nstatic const char error[] =\r\nKERN_ERR "tusb6010 %s retime error %d\n";\r\nunsigned fclk_ps = gpmc_get_fclk_period();\r\nunsigned sysclk_ps;\r\nint status;\r\nif (!refclk_psec || fclk_ps == 0)\r\nreturn -ENODEV;\r\nsysclk_ps = is_refclk ? refclk_psec : TUSB6010_OSCCLK_60;\r\nstatus = tusb_set_async_mode(sysclk_ps, fclk_ps);\r\nif (status < 0) {\r\nprintk(error, "async", status);\r\ngoto done;\r\n}\r\nstatus = tusb_set_sync_mode(sysclk_ps, fclk_ps);\r\nif (status < 0)\r\nprintk(error, "sync", status);\r\ndone:\r\nreturn status;\r\n}\r\nint __init\r\ntusb6010_setup_interface(struct musb_hdrc_platform_data *data,\r\nunsigned ps_refclk, unsigned waitpin,\r\nunsigned async, unsigned sync,\r\nunsigned irq, unsigned dmachan)\r\n{\r\nint status;\r\nstatic char error[] __initdata =\r\nKERN_ERR "tusb6010 init error %d, %d\n";\r\nstatus = gpmc_cs_request(async, SZ_16M, (unsigned long *)\r\n&tusb_resources[0].start);\r\nif (status < 0) {\r\nprintk(error, 1, status);\r\nreturn status;\r\n}\r\ntusb_resources[0].end = tusb_resources[0].start + 0x9ff;\r\nasync_cs = async;\r\ngpmc_cs_write_reg(async, GPMC_CS_CONFIG1,\r\nGPMC_CONFIG1_PAGE_LEN(2)\r\n| GPMC_CONFIG1_WAIT_READ_MON\r\n| GPMC_CONFIG1_WAIT_WRITE_MON\r\n| GPMC_CONFIG1_WAIT_PIN_SEL(waitpin)\r\n| GPMC_CONFIG1_READTYPE_ASYNC\r\n| GPMC_CONFIG1_WRITETYPE_ASYNC\r\n| GPMC_CONFIG1_DEVICESIZE_16\r\n| GPMC_CONFIG1_DEVICETYPE_NOR\r\n| GPMC_CONFIG1_MUXADDDATA);\r\nstatus = gpmc_cs_request(sync, SZ_16M, (unsigned long *)\r\n&tusb_resources[1].start);\r\nif (status < 0) {\r\nprintk(error, 2, status);\r\nreturn status;\r\n}\r\ntusb_resources[1].end = tusb_resources[1].start + 0x9ff;\r\nsync_cs = sync;\r\ngpmc_cs_write_reg(sync, GPMC_CS_CONFIG1,\r\nGPMC_CONFIG1_READMULTIPLE_SUPP\r\n| GPMC_CONFIG1_READTYPE_SYNC\r\n| GPMC_CONFIG1_WRITEMULTIPLE_SUPP\r\n| GPMC_CONFIG1_WRITETYPE_SYNC\r\n| GPMC_CONFIG1_CLKACTIVATIONTIME(1)\r\n| GPMC_CONFIG1_PAGE_LEN(2)\r\n| GPMC_CONFIG1_WAIT_READ_MON\r\n| GPMC_CONFIG1_WAIT_WRITE_MON\r\n| GPMC_CONFIG1_WAIT_PIN_SEL(waitpin)\r\n| GPMC_CONFIG1_DEVICESIZE_16\r\n| GPMC_CONFIG1_DEVICETYPE_NOR\r\n| GPMC_CONFIG1_MUXADDDATA\r\n);\r\nstatus = gpio_request_one(irq, GPIOF_IN, "TUSB6010 irq");\r\nif (status < 0) {\r\nprintk(error, 3, status);\r\nreturn status;\r\n}\r\ntusb_resources[2].start = gpio_to_irq(irq);\r\nif (!ps_refclk) {\r\nprintk(error, 4, status);\r\nreturn -ENODEV;\r\n}\r\nrefclk_psec = ps_refclk;\r\nstatus = tusb6010_platform_retime(1);\r\nif (status < 0) {\r\nprintk(error, 5, status);\r\nreturn status;\r\n}\r\nif (!data) {\r\nprintk(error, 6, status);\r\nreturn -ENODEV;\r\n}\r\ntusb_device.dev.platform_data = data;\r\nif (!dmachan)\r\ntusb_device.dev.dma_mask = NULL;\r\nelse {\r\nif (dmachan & (1 << 0))\r\nomap_mux_init_signal("sys_ndmareq0", 0);\r\nif (dmachan & (1 << 1))\r\nomap_mux_init_signal("sys_ndmareq1", 0);\r\nif (dmachan & (1 << 2))\r\nomap_mux_init_signal("sys_ndmareq2", 0);\r\nif (dmachan & (1 << 3))\r\nomap_mux_init_signal("sys_ndmareq3", 0);\r\nif (dmachan & (1 << 4))\r\nomap_mux_init_signal("sys_ndmareq4", 0);\r\nif (dmachan & (1 << 5))\r\nomap_mux_init_signal("sys_ndmareq5", 0);\r\n}\r\nstatus = platform_device_register(&tusb_device);\r\nif (status < 0) {\r\nprintk(error, 7, status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}
