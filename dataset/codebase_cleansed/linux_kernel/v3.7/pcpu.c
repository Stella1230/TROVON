static int xen_pcpu_down(uint32_t cpu_id)\r\n{\r\nstruct xen_platform_op op = {\r\n.cmd = XENPF_cpu_offline,\r\n.interface_version = XENPF_INTERFACE_VERSION,\r\n.u.cpu_ol.cpuid = cpu_id,\r\n};\r\nreturn HYPERVISOR_dom0_op(&op);\r\n}\r\nstatic int xen_pcpu_up(uint32_t cpu_id)\r\n{\r\nstruct xen_platform_op op = {\r\n.cmd = XENPF_cpu_online,\r\n.interface_version = XENPF_INTERFACE_VERSION,\r\n.u.cpu_ol.cpuid = cpu_id,\r\n};\r\nreturn HYPERVISOR_dom0_op(&op);\r\n}\r\nstatic ssize_t show_online(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct pcpu *cpu = container_of(dev, struct pcpu, dev);\r\nreturn sprintf(buf, "%u\n", !!(cpu->flags & XEN_PCPU_FLAGS_ONLINE));\r\n}\r\nstatic ssize_t __ref store_online(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct pcpu *pcpu = container_of(dev, struct pcpu, dev);\r\nunsigned long long val;\r\nssize_t ret;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (kstrtoull(buf, 0, &val) < 0)\r\nreturn -EINVAL;\r\nswitch (val) {\r\ncase 0:\r\nret = xen_pcpu_down(pcpu->cpu_id);\r\nbreak;\r\ncase 1:\r\nret = xen_pcpu_up(pcpu->cpu_id);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (ret >= 0)\r\nret = count;\r\nreturn ret;\r\n}\r\nstatic bool xen_pcpu_online(uint32_t flags)\r\n{\r\nreturn !!(flags & XEN_PCPU_FLAGS_ONLINE);\r\n}\r\nstatic void pcpu_online_status(struct xenpf_pcpuinfo *info,\r\nstruct pcpu *pcpu)\r\n{\r\nif (xen_pcpu_online(info->flags) &&\r\n!xen_pcpu_online(pcpu->flags)) {\r\npcpu->flags |= XEN_PCPU_FLAGS_ONLINE;\r\nkobject_uevent(&pcpu->dev.kobj, KOBJ_ONLINE);\r\n} else if (!xen_pcpu_online(info->flags) &&\r\nxen_pcpu_online(pcpu->flags)) {\r\npcpu->flags &= ~XEN_PCPU_FLAGS_ONLINE;\r\nkobject_uevent(&pcpu->dev.kobj, KOBJ_OFFLINE);\r\n}\r\n}\r\nstatic struct pcpu *get_pcpu(uint32_t cpu_id)\r\n{\r\nstruct pcpu *pcpu;\r\nlist_for_each_entry(pcpu, &xen_pcpus, list) {\r\nif (pcpu->cpu_id == cpu_id)\r\nreturn pcpu;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void pcpu_release(struct device *dev)\r\n{\r\nstruct pcpu *pcpu = container_of(dev, struct pcpu, dev);\r\nlist_del(&pcpu->list);\r\nkfree(pcpu);\r\n}\r\nstatic void unregister_and_remove_pcpu(struct pcpu *pcpu)\r\n{\r\nstruct device *dev;\r\nif (!pcpu)\r\nreturn;\r\ndev = &pcpu->dev;\r\nif (dev->id)\r\ndevice_remove_file(dev, &dev_attr_online);\r\ndevice_unregister(dev);\r\n}\r\nstatic int register_pcpu(struct pcpu *pcpu)\r\n{\r\nstruct device *dev;\r\nint err = -EINVAL;\r\nif (!pcpu)\r\nreturn err;\r\ndev = &pcpu->dev;\r\ndev->bus = &xen_pcpu_subsys;\r\ndev->id = pcpu->cpu_id;\r\ndev->release = pcpu_release;\r\nerr = device_register(dev);\r\nif (err) {\r\npcpu_release(dev);\r\nreturn err;\r\n}\r\nif (dev->id) {\r\nerr = device_create_file(dev, &dev_attr_online);\r\nif (err) {\r\ndevice_unregister(dev);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct pcpu *create_and_register_pcpu(struct xenpf_pcpuinfo *info)\r\n{\r\nstruct pcpu *pcpu;\r\nint err;\r\nif (info->flags & XEN_PCPU_FLAGS_INVALID)\r\nreturn ERR_PTR(-ENODEV);\r\npcpu = kzalloc(sizeof(struct pcpu), GFP_KERNEL);\r\nif (!pcpu)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&pcpu->list);\r\npcpu->cpu_id = info->xen_cpuid;\r\npcpu->flags = info->flags;\r\nlist_add_tail(&pcpu->list, &xen_pcpus);\r\nerr = register_pcpu(pcpu);\r\nif (err) {\r\npr_warning(XEN_PCPU "Failed to register pcpu%u\n",\r\ninfo->xen_cpuid);\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nreturn pcpu;\r\n}\r\nstatic int sync_pcpu(uint32_t cpu, uint32_t *max_cpu)\r\n{\r\nint ret;\r\nstruct pcpu *pcpu = NULL;\r\nstruct xenpf_pcpuinfo *info;\r\nstruct xen_platform_op op = {\r\n.cmd = XENPF_get_cpuinfo,\r\n.interface_version = XENPF_INTERFACE_VERSION,\r\n.u.pcpu_info.xen_cpuid = cpu,\r\n};\r\nret = HYPERVISOR_dom0_op(&op);\r\nif (ret)\r\nreturn ret;\r\ninfo = &op.u.pcpu_info;\r\nif (max_cpu)\r\n*max_cpu = info->max_present;\r\npcpu = get_pcpu(cpu);\r\nif (info->flags & XEN_PCPU_FLAGS_INVALID) {\r\nif (pcpu)\r\nunregister_and_remove_pcpu(pcpu);\r\nreturn 0;\r\n}\r\nif (!pcpu) {\r\npcpu = create_and_register_pcpu(info);\r\nif (IS_ERR_OR_NULL(pcpu))\r\nreturn -ENODEV;\r\n} else\r\npcpu_online_status(info, pcpu);\r\nreturn 0;\r\n}\r\nstatic int xen_sync_pcpus(void)\r\n{\r\nuint32_t cpu = 0, max_cpu = 0;\r\nint err = 0;\r\nstruct pcpu *pcpu, *tmp;\r\nmutex_lock(&xen_pcpu_lock);\r\nwhile (!err && (cpu <= max_cpu)) {\r\nerr = sync_pcpu(cpu, &max_cpu);\r\ncpu++;\r\n}\r\nif (err)\r\nlist_for_each_entry_safe(pcpu, tmp, &xen_pcpus, list)\r\nunregister_and_remove_pcpu(pcpu);\r\nmutex_unlock(&xen_pcpu_lock);\r\nreturn err;\r\n}\r\nstatic void xen_pcpu_work_fn(struct work_struct *work)\r\n{\r\nxen_sync_pcpus();\r\n}\r\nstatic irqreturn_t xen_pcpu_interrupt(int irq, void *dev_id)\r\n{\r\nschedule_work(&xen_pcpu_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init xen_pcpu_init(void)\r\n{\r\nint irq, ret;\r\nif (!xen_initial_domain())\r\nreturn -ENODEV;\r\nirq = bind_virq_to_irqhandler(VIRQ_PCPU_STATE, 0,\r\nxen_pcpu_interrupt, 0,\r\n"xen-pcpu", NULL);\r\nif (irq < 0) {\r\npr_warning(XEN_PCPU "Failed to bind pcpu virq\n");\r\nreturn irq;\r\n}\r\nret = subsys_system_register(&xen_pcpu_subsys, NULL);\r\nif (ret) {\r\npr_warning(XEN_PCPU "Failed to register pcpu subsys\n");\r\ngoto err1;\r\n}\r\nret = xen_sync_pcpus();\r\nif (ret) {\r\npr_warning(XEN_PCPU "Failed to sync pcpu info\n");\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\nbus_unregister(&xen_pcpu_subsys);\r\nerr1:\r\nunbind_from_irqhandler(irq, NULL);\r\nreturn ret;\r\n}
