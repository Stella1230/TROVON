static int gpio_regulator_get_value(struct regulator_dev *dev)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nint ptr;\r\nfor (ptr = 0; ptr < data->nr_states; ptr++)\r\nif (data->states[ptr].gpios == data->state)\r\nreturn data->states[ptr].value;\r\nreturn -EINVAL;\r\n}\r\nstatic int gpio_regulator_set_voltage(struct regulator_dev *dev,\r\nint min_uV, int max_uV,\r\nunsigned *selector)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nint ptr, target = 0, state, best_val = INT_MAX;\r\nfor (ptr = 0; ptr < data->nr_states; ptr++)\r\nif (data->states[ptr].value < best_val &&\r\ndata->states[ptr].value >= min_uV &&\r\ndata->states[ptr].value <= max_uV) {\r\ntarget = data->states[ptr].gpios;\r\nbest_val = data->states[ptr].value;\r\nif (selector)\r\n*selector = ptr;\r\n}\r\nif (best_val == INT_MAX)\r\nreturn -EINVAL;\r\nfor (ptr = 0; ptr < data->nr_gpios; ptr++) {\r\nstate = (target & (1 << ptr)) >> ptr;\r\ngpio_set_value(data->gpios[ptr].gpio, state);\r\n}\r\ndata->state = target;\r\nreturn 0;\r\n}\r\nstatic int gpio_regulator_list_voltage(struct regulator_dev *dev,\r\nunsigned selector)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nif (selector >= data->nr_states)\r\nreturn -EINVAL;\r\nreturn data->states[selector].value;\r\n}\r\nstatic int gpio_regulator_set_current_limit(struct regulator_dev *dev,\r\nint min_uA, int max_uA)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nint ptr, target = 0, state, best_val = 0;\r\nfor (ptr = 0; ptr < data->nr_states; ptr++)\r\nif (data->states[ptr].value > best_val &&\r\ndata->states[ptr].value >= min_uA &&\r\ndata->states[ptr].value <= max_uA) {\r\ntarget = data->states[ptr].gpios;\r\nbest_val = data->states[ptr].value;\r\n}\r\nif (best_val == 0)\r\nreturn -EINVAL;\r\nfor (ptr = 0; ptr < data->nr_gpios; ptr++) {\r\nstate = (target & (1 << ptr)) >> ptr;\r\ngpio_set_value(data->gpios[ptr].gpio, state);\r\n}\r\ndata->state = target;\r\nreturn 0;\r\n}\r\nstatic int __devinit gpio_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_regulator_config *config = pdev->dev.platform_data;\r\nstruct gpio_regulator_data *drvdata;\r\nstruct regulator_config cfg = { };\r\nint ptr, ret, state;\r\ndrvdata = devm_kzalloc(&pdev->dev, sizeof(struct gpio_regulator_data),\r\nGFP_KERNEL);\r\nif (drvdata == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate device data\n");\r\nreturn -ENOMEM;\r\n}\r\ndrvdata->desc.name = kstrdup(config->supply_name, GFP_KERNEL);\r\nif (drvdata->desc.name == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate supply name\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndrvdata->gpios = kmemdup(config->gpios,\r\nconfig->nr_gpios * sizeof(struct gpio),\r\nGFP_KERNEL);\r\nif (drvdata->gpios == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate gpio data\n");\r\nret = -ENOMEM;\r\ngoto err_name;\r\n}\r\ndrvdata->states = kmemdup(config->states,\r\nconfig->nr_states *\r\nsizeof(struct gpio_regulator_state),\r\nGFP_KERNEL);\r\nif (drvdata->states == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate state data\n");\r\nret = -ENOMEM;\r\ngoto err_memgpio;\r\n}\r\ndrvdata->nr_states = config->nr_states;\r\ndrvdata->desc.owner = THIS_MODULE;\r\ndrvdata->desc.enable_time = config->startup_delay;\r\nswitch (config->type) {\r\ncase REGULATOR_VOLTAGE:\r\ndrvdata->desc.type = REGULATOR_VOLTAGE;\r\ndrvdata->desc.ops = &gpio_regulator_voltage_ops;\r\ndrvdata->desc.n_voltages = config->nr_states;\r\nbreak;\r\ncase REGULATOR_CURRENT:\r\ndrvdata->desc.type = REGULATOR_CURRENT;\r\ndrvdata->desc.ops = &gpio_regulator_current_ops;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "No regulator type set\n");\r\nret = -EINVAL;\r\ngoto err_memgpio;\r\nbreak;\r\n}\r\ndrvdata->nr_gpios = config->nr_gpios;\r\nret = gpio_request_array(drvdata->gpios, drvdata->nr_gpios);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Could not obtain regulator setting GPIOs: %d\n", ret);\r\ngoto err_memstate;\r\n}\r\nstate = 0;\r\nfor (ptr = 0; ptr < drvdata->nr_gpios; ptr++) {\r\nif (config->gpios[ptr].flags & GPIOF_OUT_INIT_HIGH)\r\nstate |= (1 << ptr);\r\n}\r\ndrvdata->state = state;\r\ncfg.dev = &pdev->dev;\r\ncfg.init_data = config->init_data;\r\ncfg.driver_data = drvdata;\r\nif (config->enable_gpio >= 0)\r\ncfg.ena_gpio = config->enable_gpio;\r\ncfg.ena_gpio_invert = !config->enable_high;\r\nif (config->enabled_at_boot) {\r\nif (config->enable_high)\r\ncfg.ena_gpio_flags |= GPIOF_OUT_INIT_HIGH;\r\nelse\r\ncfg.ena_gpio_flags |= GPIOF_OUT_INIT_LOW;\r\n} else {\r\nif (config->enable_high)\r\ncfg.ena_gpio_flags |= GPIOF_OUT_INIT_LOW;\r\nelse\r\ncfg.ena_gpio_flags |= GPIOF_OUT_INIT_HIGH;\r\n}\r\ndrvdata->dev = regulator_register(&drvdata->desc, &cfg);\r\nif (IS_ERR(drvdata->dev)) {\r\nret = PTR_ERR(drvdata->dev);\r\ndev_err(&pdev->dev, "Failed to register regulator: %d\n", ret);\r\ngoto err_stategpio;\r\n}\r\nplatform_set_drvdata(pdev, drvdata);\r\nreturn 0;\r\nerr_stategpio:\r\ngpio_free_array(drvdata->gpios, drvdata->nr_gpios);\r\nerr_memstate:\r\nkfree(drvdata->states);\r\nerr_memgpio:\r\nkfree(drvdata->gpios);\r\nerr_name:\r\nkfree(drvdata->desc.name);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int __devexit gpio_regulator_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_regulator_data *drvdata = platform_get_drvdata(pdev);\r\nregulator_unregister(drvdata->dev);\r\ngpio_free_array(drvdata->gpios, drvdata->nr_gpios);\r\nkfree(drvdata->states);\r\nkfree(drvdata->gpios);\r\nkfree(drvdata->desc.name);\r\nreturn 0;\r\n}\r\nstatic int __init gpio_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&gpio_regulator_driver);\r\n}\r\nstatic void __exit gpio_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&gpio_regulator_driver);\r\n}
