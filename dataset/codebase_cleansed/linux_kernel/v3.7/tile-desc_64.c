static const struct tilegx_opcode *\r\nfind_opcode(tilegx_bundle_bits bits, const unsigned short *table)\r\n{\r\nint index = 0;\r\nwhile (1)\r\n{\r\nunsigned short bitspec = table[index];\r\nunsigned int bitfield =\r\n((unsigned int)(bits >> (bitspec & 63))) & (bitspec >> 6);\r\nunsigned short next = table[index + 1 + bitfield];\r\nif (next <= TILEGX_OPC_NONE)\r\nreturn &tilegx_opcodes[next];\r\nindex = next - TILEGX_OPC_NONE;\r\n}\r\n}\r\nint\r\nparse_insn_tilegx(tilegx_bundle_bits bits,\r\nunsigned long long pc,\r\nstruct tilegx_decoded_instruction\r\ndecoded[TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE])\r\n{\r\nint num_instructions = 0;\r\nint pipe;\r\nint min_pipe, max_pipe;\r\nif ((bits & TILEGX_BUNDLE_MODE_MASK) == 0)\r\n{\r\nmin_pipe = TILEGX_PIPELINE_X0;\r\nmax_pipe = TILEGX_PIPELINE_X1;\r\n}\r\nelse\r\n{\r\nmin_pipe = TILEGX_PIPELINE_Y0;\r\nmax_pipe = TILEGX_PIPELINE_Y2;\r\n}\r\nfor (pipe = min_pipe; pipe <= max_pipe; pipe++)\r\n{\r\nconst struct tilegx_opcode *opc;\r\nstruct tilegx_decoded_instruction *d;\r\nint i;\r\nd = &decoded[num_instructions++];\r\nopc = find_opcode (bits, tilegx_bundle_decoder_fsms[pipe]);\r\nd->opcode = opc;\r\nfor (i = 0; i < opc->num_operands; i++)\r\n{\r\nconst struct tilegx_operand *op =\r\n&tilegx_operands[opc->operands[pipe][i]];\r\nint raw_opval = op->extract (bits);\r\nlong long opval;\r\nif (op->is_signed)\r\n{\r\nint shift = (int)((sizeof(int) * 8) - op->num_bits);\r\nraw_opval = (raw_opval << shift) >> shift;\r\n}\r\nif (op->type == TILEGX_OP_TYPE_ADDRESS)\r\nopval = (raw_opval * TILEGX_BUNDLE_SIZE_IN_BYTES) + pc;\r\nelse\r\nopval = raw_opval;\r\nd->operands[i] = op;\r\nd->operand_values[i] = opval;\r\n}\r\n}\r\nreturn num_instructions;\r\n}
