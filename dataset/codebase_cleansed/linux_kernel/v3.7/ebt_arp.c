static bool\r\nebt_arp_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct ebt_arp_info *info = par->matchinfo;\r\nconst struct arphdr *ah;\r\nstruct arphdr _arph;\r\nah = skb_header_pointer(skb, 0, sizeof(_arph), &_arph);\r\nif (ah == NULL)\r\nreturn false;\r\nif (info->bitmask & EBT_ARP_OPCODE && FWINV(info->opcode !=\r\nah->ar_op, EBT_ARP_OPCODE))\r\nreturn false;\r\nif (info->bitmask & EBT_ARP_HTYPE && FWINV(info->htype !=\r\nah->ar_hrd, EBT_ARP_HTYPE))\r\nreturn false;\r\nif (info->bitmask & EBT_ARP_PTYPE && FWINV(info->ptype !=\r\nah->ar_pro, EBT_ARP_PTYPE))\r\nreturn false;\r\nif (info->bitmask & (EBT_ARP_SRC_IP | EBT_ARP_DST_IP | EBT_ARP_GRAT)) {\r\nconst __be32 *sap, *dap;\r\n__be32 saddr, daddr;\r\nif (ah->ar_pln != sizeof(__be32) || ah->ar_pro != htons(ETH_P_IP))\r\nreturn false;\r\nsap = skb_header_pointer(skb, sizeof(struct arphdr) +\r\nah->ar_hln, sizeof(saddr),\r\n&saddr);\r\nif (sap == NULL)\r\nreturn false;\r\ndap = skb_header_pointer(skb, sizeof(struct arphdr) +\r\n2*ah->ar_hln+sizeof(saddr),\r\nsizeof(daddr), &daddr);\r\nif (dap == NULL)\r\nreturn false;\r\nif (info->bitmask & EBT_ARP_SRC_IP &&\r\nFWINV(info->saddr != (*sap & info->smsk), EBT_ARP_SRC_IP))\r\nreturn false;\r\nif (info->bitmask & EBT_ARP_DST_IP &&\r\nFWINV(info->daddr != (*dap & info->dmsk), EBT_ARP_DST_IP))\r\nreturn false;\r\nif (info->bitmask & EBT_ARP_GRAT &&\r\nFWINV(*dap != *sap, EBT_ARP_GRAT))\r\nreturn false;\r\n}\r\nif (info->bitmask & (EBT_ARP_SRC_MAC | EBT_ARP_DST_MAC)) {\r\nconst unsigned char *mp;\r\nunsigned char _mac[ETH_ALEN];\r\nuint8_t verdict, i;\r\nif (ah->ar_hln != ETH_ALEN || ah->ar_hrd != htons(ARPHRD_ETHER))\r\nreturn false;\r\nif (info->bitmask & EBT_ARP_SRC_MAC) {\r\nmp = skb_header_pointer(skb, sizeof(struct arphdr),\r\nsizeof(_mac), &_mac);\r\nif (mp == NULL)\r\nreturn false;\r\nverdict = 0;\r\nfor (i = 0; i < 6; i++)\r\nverdict |= (mp[i] ^ info->smaddr[i]) &\r\ninfo->smmsk[i];\r\nif (FWINV(verdict != 0, EBT_ARP_SRC_MAC))\r\nreturn false;\r\n}\r\nif (info->bitmask & EBT_ARP_DST_MAC) {\r\nmp = skb_header_pointer(skb, sizeof(struct arphdr) +\r\nah->ar_hln + ah->ar_pln,\r\nsizeof(_mac), &_mac);\r\nif (mp == NULL)\r\nreturn false;\r\nverdict = 0;\r\nfor (i = 0; i < 6; i++)\r\nverdict |= (mp[i] ^ info->dmaddr[i]) &\r\ninfo->dmmsk[i];\r\nif (FWINV(verdict != 0, EBT_ARP_DST_MAC))\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int ebt_arp_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct ebt_arp_info *info = par->matchinfo;\r\nconst struct ebt_entry *e = par->entryinfo;\r\nif ((e->ethproto != htons(ETH_P_ARP) &&\r\ne->ethproto != htons(ETH_P_RARP)) ||\r\ne->invflags & EBT_IPROTO)\r\nreturn -EINVAL;\r\nif (info->bitmask & ~EBT_ARP_MASK || info->invflags & ~EBT_ARP_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __init ebt_arp_init(void)\r\n{\r\nreturn xt_register_match(&ebt_arp_mt_reg);\r\n}\r\nstatic void __exit ebt_arp_fini(void)\r\n{\r\nxt_unregister_match(&ebt_arp_mt_reg);\r\n}
