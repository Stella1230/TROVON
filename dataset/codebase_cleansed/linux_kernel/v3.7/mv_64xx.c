static void mvs_64xx_detect_porttype(struct mvs_info *mvi, int i)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 reg;\r\nstruct mvs_phy *phy = &mvi->phy[i];\r\nreg = mr32(MVS_GBL_PORT_TYPE);\r\nphy->phy_type &= ~(PORT_TYPE_SAS | PORT_TYPE_SATA);\r\nif (reg & MODE_SAS_SATA & (1 << i))\r\nphy->phy_type |= PORT_TYPE_SAS;\r\nelse\r\nphy->phy_type |= PORT_TYPE_SATA;\r\n}\r\nstatic void __devinit mvs_64xx_enable_xmt(struct mvs_info *mvi, int phy_id)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp;\r\ntmp = mr32(MVS_PCS);\r\nif (mvi->chip->n_phy <= MVS_SOC_PORTS)\r\ntmp |= 1 << (phy_id + PCS_EN_PORT_XMT_SHIFT);\r\nelse\r\ntmp |= 1 << (phy_id + PCS_EN_PORT_XMT_SHIFT2);\r\nmw32(MVS_PCS, tmp);\r\n}\r\nstatic void __devinit mvs_64xx_phy_hacks(struct mvs_info *mvi)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nint i;\r\nmvs_phy_hacks(mvi);\r\nif (!(mvi->flags & MVF_FLAG_SOC)) {\r\nfor (i = 0; i < MVS_SOC_PORTS; i++) {\r\nmvs_write_port_vsr_addr(mvi, i, VSR_PHY_MODE8);\r\nmvs_write_port_vsr_data(mvi, i, 0x2F0);\r\n}\r\n} else {\r\nmw32(MVS_GBL_PORT_TYPE, 0);\r\nfor (i = 0; i < mvi->chip->n_phy; i++) {\r\nmvs_write_port_vsr_addr(mvi, i, VSR_PHY_MODE7);\r\nmvs_write_port_vsr_data(mvi, i, 0x90000000);\r\nmvs_write_port_vsr_addr(mvi, i, VSR_PHY_MODE9);\r\nmvs_write_port_vsr_data(mvi, i, 0x50f2);\r\nmvs_write_port_vsr_addr(mvi, i, VSR_PHY_MODE11);\r\nmvs_write_port_vsr_data(mvi, i, 0x0e);\r\n}\r\n}\r\n}\r\nstatic void mvs_64xx_stp_reset(struct mvs_info *mvi, u32 phy_id)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 reg, tmp;\r\nif (!(mvi->flags & MVF_FLAG_SOC)) {\r\nif (phy_id < MVS_SOC_PORTS)\r\npci_read_config_dword(mvi->pdev, PCR_PHY_CTL, &reg);\r\nelse\r\npci_read_config_dword(mvi->pdev, PCR_PHY_CTL2, &reg);\r\n} else\r\nreg = mr32(MVS_PHY_CTL);\r\ntmp = reg;\r\nif (phy_id < MVS_SOC_PORTS)\r\ntmp |= (1U << phy_id) << PCTL_LINK_OFFS;\r\nelse\r\ntmp |= (1U << (phy_id - MVS_SOC_PORTS)) << PCTL_LINK_OFFS;\r\nif (!(mvi->flags & MVF_FLAG_SOC)) {\r\nif (phy_id < MVS_SOC_PORTS) {\r\npci_write_config_dword(mvi->pdev, PCR_PHY_CTL, tmp);\r\nmdelay(10);\r\npci_write_config_dword(mvi->pdev, PCR_PHY_CTL, reg);\r\n} else {\r\npci_write_config_dword(mvi->pdev, PCR_PHY_CTL2, tmp);\r\nmdelay(10);\r\npci_write_config_dword(mvi->pdev, PCR_PHY_CTL2, reg);\r\n}\r\n} else {\r\nmw32(MVS_PHY_CTL, tmp);\r\nmdelay(10);\r\nmw32(MVS_PHY_CTL, reg);\r\n}\r\n}\r\nstatic void mvs_64xx_phy_reset(struct mvs_info *mvi, u32 phy_id, int hard)\r\n{\r\nu32 tmp;\r\ntmp = mvs_read_port_irq_stat(mvi, phy_id);\r\ntmp &= ~PHYEV_RDY_CH;\r\nmvs_write_port_irq_stat(mvi, phy_id, tmp);\r\ntmp = mvs_read_phy_ctl(mvi, phy_id);\r\nif (hard == MVS_HARD_RESET)\r\ntmp |= PHY_RST_HARD;\r\nelse if (hard == MVS_SOFT_RESET)\r\ntmp |= PHY_RST;\r\nmvs_write_phy_ctl(mvi, phy_id, tmp);\r\nif (hard) {\r\ndo {\r\ntmp = mvs_read_phy_ctl(mvi, phy_id);\r\n} while (tmp & PHY_RST_HARD);\r\n}\r\n}\r\nvoid mvs_64xx_clear_srs_irq(struct mvs_info *mvi, u8 reg_set, u8 clear_all)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp;\r\nif (clear_all) {\r\ntmp = mr32(MVS_INT_STAT_SRS_0);\r\nif (tmp) {\r\nprintk(KERN_DEBUG "check SRS 0 %08X.\n", tmp);\r\nmw32(MVS_INT_STAT_SRS_0, tmp);\r\n}\r\n} else {\r\ntmp = mr32(MVS_INT_STAT_SRS_0);\r\nif (tmp & (1 << (reg_set % 32))) {\r\nprintk(KERN_DEBUG "register set 0x%x was stopped.\n",\r\nreg_set);\r\nmw32(MVS_INT_STAT_SRS_0, 1 << (reg_set % 32));\r\n}\r\n}\r\n}\r\nstatic int __devinit mvs_64xx_chip_reset(struct mvs_info *mvi)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp;\r\nint i;\r\nmw32(MVS_GBL_CTL, 0);\r\ntmp = mr32(MVS_GBL_CTL);\r\nif (!(tmp & HBA_RST)) {\r\nif (mvi->flags & MVF_PHY_PWR_FIX) {\r\npci_read_config_dword(mvi->pdev, PCR_PHY_CTL, &tmp);\r\ntmp &= ~PCTL_PWR_OFF;\r\ntmp |= PCTL_PHY_DSBL;\r\npci_write_config_dword(mvi->pdev, PCR_PHY_CTL, tmp);\r\npci_read_config_dword(mvi->pdev, PCR_PHY_CTL2, &tmp);\r\ntmp &= ~PCTL_PWR_OFF;\r\ntmp |= PCTL_PHY_DSBL;\r\npci_write_config_dword(mvi->pdev, PCR_PHY_CTL2, tmp);\r\n}\r\n}\r\nmw32(MVS_GBL_CTL, 0);\r\ntmp = mr32(MVS_GBL_CTL);\r\nif (!(tmp & HBA_RST)) {\r\nmw32_f(MVS_GBL_CTL, HBA_RST);\r\n}\r\ni = 1000;\r\nwhile (i-- > 0) {\r\nmsleep(10);\r\nif (!(mr32(MVS_GBL_CTL) & HBA_RST))\r\nbreak;\r\n}\r\nif (mr32(MVS_GBL_CTL) & HBA_RST) {\r\ndev_printk(KERN_ERR, mvi->dev, "HBA reset failed\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mvs_64xx_phy_disable(struct mvs_info *mvi, u32 phy_id)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp;\r\nif (!(mvi->flags & MVF_FLAG_SOC)) {\r\nu32 offs;\r\nif (phy_id < 4)\r\noffs = PCR_PHY_CTL;\r\nelse {\r\noffs = PCR_PHY_CTL2;\r\nphy_id -= 4;\r\n}\r\npci_read_config_dword(mvi->pdev, offs, &tmp);\r\ntmp |= 1U << (PCTL_PHY_DSBL_OFFS + phy_id);\r\npci_write_config_dword(mvi->pdev, offs, tmp);\r\n} else {\r\ntmp = mr32(MVS_PHY_CTL);\r\ntmp |= 1U << (PCTL_PHY_DSBL_OFFS + phy_id);\r\nmw32(MVS_PHY_CTL, tmp);\r\n}\r\n}\r\nstatic void mvs_64xx_phy_enable(struct mvs_info *mvi, u32 phy_id)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp;\r\nif (!(mvi->flags & MVF_FLAG_SOC)) {\r\nu32 offs;\r\nif (phy_id < 4)\r\noffs = PCR_PHY_CTL;\r\nelse {\r\noffs = PCR_PHY_CTL2;\r\nphy_id -= 4;\r\n}\r\npci_read_config_dword(mvi->pdev, offs, &tmp);\r\ntmp &= ~(1U << (PCTL_PHY_DSBL_OFFS + phy_id));\r\npci_write_config_dword(mvi->pdev, offs, tmp);\r\n} else {\r\ntmp = mr32(MVS_PHY_CTL);\r\ntmp &= ~(1U << (PCTL_PHY_DSBL_OFFS + phy_id));\r\nmw32(MVS_PHY_CTL, tmp);\r\n}\r\n}\r\nstatic int __devinit mvs_64xx_init(struct mvs_info *mvi)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nint i;\r\nu32 tmp, cctl;\r\nif (mvi->pdev && mvi->pdev->revision == 0)\r\nmvi->flags |= MVF_PHY_PWR_FIX;\r\nif (!(mvi->flags & MVF_FLAG_SOC)) {\r\nmvs_show_pcie_usage(mvi);\r\ntmp = mvs_64xx_chip_reset(mvi);\r\nif (tmp)\r\nreturn tmp;\r\n} else {\r\ntmp = mr32(MVS_PHY_CTL);\r\ntmp &= ~PCTL_PWR_OFF;\r\ntmp |= PCTL_PHY_DSBL;\r\nmw32(MVS_PHY_CTL, tmp);\r\n}\r\ncctl = mr32(MVS_CTL) & 0xFFFF;\r\nif (cctl & CCTL_RST)\r\ncctl &= ~CCTL_RST;\r\nelse\r\nmw32_f(MVS_CTL, cctl | CCTL_RST);\r\nif (!(mvi->flags & MVF_FLAG_SOC)) {\r\npci_read_config_dword(mvi->pdev, PCR_DEV_CTRL, &tmp);\r\ntmp &= ~PRD_REQ_MASK;\r\ntmp |= PRD_REQ_SIZE;\r\npci_write_config_dword(mvi->pdev, PCR_DEV_CTRL, tmp);\r\npci_read_config_dword(mvi->pdev, PCR_PHY_CTL, &tmp);\r\ntmp &= ~PCTL_PWR_OFF;\r\ntmp &= ~PCTL_PHY_DSBL;\r\npci_write_config_dword(mvi->pdev, PCR_PHY_CTL, tmp);\r\npci_read_config_dword(mvi->pdev, PCR_PHY_CTL2, &tmp);\r\ntmp &= PCTL_PWR_OFF;\r\ntmp &= ~PCTL_PHY_DSBL;\r\npci_write_config_dword(mvi->pdev, PCR_PHY_CTL2, tmp);\r\n} else {\r\ntmp = mr32(MVS_PHY_CTL);\r\ntmp &= ~PCTL_PWR_OFF;\r\ntmp |= PCTL_COM_ON;\r\ntmp &= ~PCTL_PHY_DSBL;\r\ntmp |= PCTL_LINK_RST;\r\nmw32(MVS_PHY_CTL, tmp);\r\nmsleep(100);\r\ntmp &= ~PCTL_LINK_RST;\r\nmw32(MVS_PHY_CTL, tmp);\r\nmsleep(100);\r\n}\r\nmw32(MVS_PCS, 0);\r\nmvs_64xx_phy_hacks(mvi);\r\ntmp = mvs_cr32(mvi, CMD_PHY_MODE_21);\r\ntmp &= 0x0000ffff;\r\ntmp |= 0x00fa0000;\r\nmvs_cw32(mvi, CMD_PHY_MODE_21, tmp);\r\nmw32(MVS_GBL_PORT_TYPE, MODE_AUTO_DET_EN);\r\nmw32(MVS_CMD_LIST_LO, mvi->slot_dma);\r\nmw32(MVS_CMD_LIST_HI, (mvi->slot_dma >> 16) >> 16);\r\nmw32(MVS_RX_FIS_LO, mvi->rx_fis_dma);\r\nmw32(MVS_RX_FIS_HI, (mvi->rx_fis_dma >> 16) >> 16);\r\nmw32(MVS_TX_CFG, MVS_CHIP_SLOT_SZ);\r\nmw32(MVS_TX_LO, mvi->tx_dma);\r\nmw32(MVS_TX_HI, (mvi->tx_dma >> 16) >> 16);\r\nmw32(MVS_RX_CFG, MVS_RX_RING_SZ);\r\nmw32(MVS_RX_LO, mvi->rx_dma);\r\nmw32(MVS_RX_HI, (mvi->rx_dma >> 16) >> 16);\r\nfor (i = 0; i < mvi->chip->n_phy; i++) {\r\nmvs_set_sas_addr(mvi, i, PHYR_ADDR_LO, PHYR_ADDR_HI,\r\ncpu_to_be64(mvi->phy[i].dev_sas_addr));\r\nmvs_64xx_enable_xmt(mvi, i);\r\nmvs_64xx_phy_reset(mvi, i, MVS_HARD_RESET);\r\nmsleep(500);\r\nmvs_64xx_detect_porttype(mvi, i);\r\n}\r\nif (mvi->flags & MVF_FLAG_SOC) {\r\nwritel(0x0E008000, regs + 0x000);\r\nwritel(0x59000008, regs + 0x004);\r\nwritel(0x20, regs + 0x008);\r\nwritel(0x20, regs + 0x00c);\r\nwritel(0x20, regs + 0x010);\r\nwritel(0x20, regs + 0x014);\r\nwritel(0x20, regs + 0x018);\r\nwritel(0x20, regs + 0x01c);\r\n}\r\nfor (i = 0; i < mvi->chip->n_phy; i++) {\r\ntmp = mvs_read_port_irq_stat(mvi, i);\r\ntmp &= ~PHYEV_SIG_FIS;\r\nmvs_write_port_irq_stat(mvi, i, tmp);\r\ntmp = PHYEV_RDY_CH | PHYEV_BROAD_CH | PHYEV_UNASSOC_FIS |\r\nPHYEV_ID_DONE | PHYEV_DCDR_ERR | PHYEV_CRC_ERR |\r\nPHYEV_DEC_ERR;\r\nmvs_write_port_irq_mask(mvi, i, tmp);\r\nmsleep(100);\r\nmvs_update_phyinfo(mvi, i, 1);\r\n}\r\ncctl = mr32(MVS_CTL);\r\ncctl |= CCTL_ENDIAN_CMD;\r\ncctl |= CCTL_ENDIAN_DATA;\r\ncctl &= ~CCTL_ENDIAN_OPEN;\r\ncctl |= CCTL_ENDIAN_RSP;\r\nmw32_f(MVS_CTL, cctl);\r\ntmp = mr32(MVS_PCS);\r\ntmp |= PCS_CMD_RST;\r\ntmp &= ~PCS_SELF_CLEAR;\r\nmw32(MVS_PCS, tmp);\r\ntmp = 0;\r\nif (MVS_CHIP_SLOT_SZ > 0x1ff)\r\nmw32(MVS_INT_COAL, 0x1ff | COAL_EN);\r\nelse\r\nmw32(MVS_INT_COAL, MVS_CHIP_SLOT_SZ | COAL_EN);\r\ntmp = 0x10000 | interrupt_coalescing;\r\nmw32(MVS_INT_COAL_TMOUT, tmp);\r\nmw32(MVS_TX_CFG, 0);\r\nmw32(MVS_TX_CFG, MVS_CHIP_SLOT_SZ | TX_EN);\r\nmw32(MVS_RX_CFG, MVS_RX_RING_SZ | RX_EN);\r\nmw32(MVS_PCS, PCS_SATA_RETRY | PCS_FIS_RX_EN |\r\nPCS_CMD_EN | PCS_CMD_STOP_ERR);\r\ntmp = (CINT_PORT_MASK | CINT_DONE | CINT_MEM | CINT_SRS | CINT_CI_STOP |\r\nCINT_DMA_PCIE);\r\nmw32(MVS_INT_MASK, tmp);\r\nmw32(MVS_INT_MASK_SRS_0, 0xFFFF);\r\nreturn 0;\r\n}\r\nstatic int mvs_64xx_ioremap(struct mvs_info *mvi)\r\n{\r\nif (!mvs_ioremap(mvi, 4, 2))\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic void mvs_64xx_iounmap(struct mvs_info *mvi)\r\n{\r\nmvs_iounmap(mvi->regs);\r\nmvs_iounmap(mvi->regs_ex);\r\n}\r\nstatic void mvs_64xx_interrupt_enable(struct mvs_info *mvi)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp;\r\ntmp = mr32(MVS_GBL_CTL);\r\nmw32(MVS_GBL_CTL, tmp | INT_EN);\r\n}\r\nstatic void mvs_64xx_interrupt_disable(struct mvs_info *mvi)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp;\r\ntmp = mr32(MVS_GBL_CTL);\r\nmw32(MVS_GBL_CTL, tmp & ~INT_EN);\r\n}\r\nstatic u32 mvs_64xx_isr_status(struct mvs_info *mvi, int irq)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 stat;\r\nif (!(mvi->flags & MVF_FLAG_SOC)) {\r\nstat = mr32(MVS_GBL_INT_STAT);\r\nif (stat == 0 || stat == 0xffffffff)\r\nreturn 0;\r\n} else\r\nstat = 1;\r\nreturn stat;\r\n}\r\nstatic irqreturn_t mvs_64xx_isr(struct mvs_info *mvi, int irq, u32 stat)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nmw32_f(MVS_INT_STAT, CINT_DONE);\r\nspin_lock(&mvi->lock);\r\nmvs_int_full(mvi);\r\nspin_unlock(&mvi->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mvs_64xx_command_active(struct mvs_info *mvi, u32 slot_idx)\r\n{\r\nu32 tmp;\r\nmvs_cw32(mvi, 0x40 + (slot_idx >> 3), 1 << (slot_idx % 32));\r\nmvs_cw32(mvi, 0x00 + (slot_idx >> 3), 1 << (slot_idx % 32));\r\ndo {\r\ntmp = mvs_cr32(mvi, 0x00 + (slot_idx >> 3));\r\n} while (tmp & 1 << (slot_idx % 32));\r\ndo {\r\ntmp = mvs_cr32(mvi, 0x40 + (slot_idx >> 3));\r\n} while (tmp & 1 << (slot_idx % 32));\r\n}\r\nstatic void mvs_64xx_issue_stop(struct mvs_info *mvi, enum mvs_port_type type,\r\nu32 tfs)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp;\r\nif (type == PORT_TYPE_SATA) {\r\ntmp = mr32(MVS_INT_STAT_SRS_0) | (1U << tfs);\r\nmw32(MVS_INT_STAT_SRS_0, tmp);\r\n}\r\nmw32(MVS_INT_STAT, CINT_CI_STOP);\r\ntmp = mr32(MVS_PCS) | 0xFF00;\r\nmw32(MVS_PCS, tmp);\r\n}\r\nstatic void mvs_64xx_free_reg_set(struct mvs_info *mvi, u8 *tfs)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp, offs;\r\nif (*tfs == MVS_ID_NOT_MAPPED)\r\nreturn;\r\noffs = 1U << ((*tfs & 0x0f) + PCS_EN_SATA_REG_SHIFT);\r\nif (*tfs < 16) {\r\ntmp = mr32(MVS_PCS);\r\nmw32(MVS_PCS, tmp & ~offs);\r\n} else {\r\ntmp = mr32(MVS_CTL);\r\nmw32(MVS_CTL, tmp & ~offs);\r\n}\r\ntmp = mr32(MVS_INT_STAT_SRS_0) & (1U << *tfs);\r\nif (tmp)\r\nmw32(MVS_INT_STAT_SRS_0, tmp);\r\n*tfs = MVS_ID_NOT_MAPPED;\r\nreturn;\r\n}\r\nstatic u8 mvs_64xx_assign_reg_set(struct mvs_info *mvi, u8 *tfs)\r\n{\r\nint i;\r\nu32 tmp, offs;\r\nvoid __iomem *regs = mvi->regs;\r\nif (*tfs != MVS_ID_NOT_MAPPED)\r\nreturn 0;\r\ntmp = mr32(MVS_PCS);\r\nfor (i = 0; i < mvi->chip->srs_sz; i++) {\r\nif (i == 16)\r\ntmp = mr32(MVS_CTL);\r\noffs = 1U << ((i & 0x0f) + PCS_EN_SATA_REG_SHIFT);\r\nif (!(tmp & offs)) {\r\n*tfs = i;\r\nif (i < 16)\r\nmw32(MVS_PCS, tmp | offs);\r\nelse\r\nmw32(MVS_CTL, tmp | offs);\r\ntmp = mr32(MVS_INT_STAT_SRS_0) & (1U << i);\r\nif (tmp)\r\nmw32(MVS_INT_STAT_SRS_0, tmp);\r\nreturn 0;\r\n}\r\n}\r\nreturn MVS_ID_NOT_MAPPED;\r\n}\r\nvoid mvs_64xx_make_prd(struct scatterlist *scatter, int nr, void *prd)\r\n{\r\nint i;\r\nstruct scatterlist *sg;\r\nstruct mvs_prd *buf_prd = prd;\r\nfor_each_sg(scatter, sg, nr, i) {\r\nbuf_prd->addr = cpu_to_le64(sg_dma_address(sg));\r\nbuf_prd->len = cpu_to_le32(sg_dma_len(sg));\r\nbuf_prd++;\r\n}\r\n}\r\nstatic int mvs_64xx_oob_done(struct mvs_info *mvi, int i)\r\n{\r\nu32 phy_st;\r\nmvs_write_port_cfg_addr(mvi, i,\r\nPHYR_PHY_STAT);\r\nphy_st = mvs_read_port_cfg_data(mvi, i);\r\nif (phy_st & PHY_OOB_DTCTD)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void mvs_64xx_fix_phy_info(struct mvs_info *mvi, int i,\r\nstruct sas_identify_frame *id)\r\n{\r\nstruct mvs_phy *phy = &mvi->phy[i];\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nsas_phy->linkrate =\r\n(phy->phy_status & PHY_NEG_SPP_PHYS_LINK_RATE_MASK) >>\r\nPHY_NEG_SPP_PHYS_LINK_RATE_MASK_OFFSET;\r\nphy->minimum_linkrate =\r\n(phy->phy_status &\r\nPHY_MIN_SPP_PHYS_LINK_RATE_MASK) >> 8;\r\nphy->maximum_linkrate =\r\n(phy->phy_status &\r\nPHY_MAX_SPP_PHYS_LINK_RATE_MASK) >> 12;\r\nmvs_write_port_cfg_addr(mvi, i, PHYR_IDENTIFY);\r\nphy->dev_info = mvs_read_port_cfg_data(mvi, i);\r\nmvs_write_port_cfg_addr(mvi, i, PHYR_ATT_DEV_INFO);\r\nphy->att_dev_info = mvs_read_port_cfg_data(mvi, i);\r\nmvs_write_port_cfg_addr(mvi, i, PHYR_ATT_ADDR_HI);\r\nphy->att_dev_sas_addr =\r\n(u64) mvs_read_port_cfg_data(mvi, i) << 32;\r\nmvs_write_port_cfg_addr(mvi, i, PHYR_ATT_ADDR_LO);\r\nphy->att_dev_sas_addr |= mvs_read_port_cfg_data(mvi, i);\r\nphy->att_dev_sas_addr = SAS_ADDR(&phy->att_dev_sas_addr);\r\n}\r\nstatic void mvs_64xx_phy_work_around(struct mvs_info *mvi, int i)\r\n{\r\nu32 tmp;\r\nstruct mvs_phy *phy = &mvi->phy[i];\r\nmvs_write_port_vsr_addr(mvi, i, VSR_PHY_MODE6);\r\ntmp = mvs_read_port_vsr_data(mvi, i);\r\nif (((phy->phy_status & PHY_NEG_SPP_PHYS_LINK_RATE_MASK) >>\r\nPHY_NEG_SPP_PHYS_LINK_RATE_MASK_OFFSET) ==\r\nSAS_LINK_RATE_1_5_GBPS)\r\ntmp &= ~PHY_MODE6_LATECLK;\r\nelse\r\ntmp |= PHY_MODE6_LATECLK;\r\nmvs_write_port_vsr_data(mvi, i, tmp);\r\n}\r\nvoid mvs_64xx_phy_set_link_rate(struct mvs_info *mvi, u32 phy_id,\r\nstruct sas_phy_linkrates *rates)\r\n{\r\nu32 lrmin = 0, lrmax = 0;\r\nu32 tmp;\r\ntmp = mvs_read_phy_ctl(mvi, phy_id);\r\nlrmin = (rates->minimum_linkrate << 8);\r\nlrmax = (rates->maximum_linkrate << 12);\r\nif (lrmin) {\r\ntmp &= ~(0xf << 8);\r\ntmp |= lrmin;\r\n}\r\nif (lrmax) {\r\ntmp &= ~(0xf << 12);\r\ntmp |= lrmax;\r\n}\r\nmvs_write_phy_ctl(mvi, phy_id, tmp);\r\nmvs_64xx_phy_reset(mvi, phy_id, MVS_HARD_RESET);\r\n}\r\nstatic void mvs_64xx_clear_active_cmds(struct mvs_info *mvi)\r\n{\r\nu32 tmp;\r\nvoid __iomem *regs = mvi->regs;\r\ntmp = mr32(MVS_PCS);\r\nmw32(MVS_PCS, tmp & 0xFFFF);\r\nmw32(MVS_PCS, tmp);\r\ntmp = mr32(MVS_CTL);\r\nmw32(MVS_CTL, tmp & 0xFFFF);\r\nmw32(MVS_CTL, tmp);\r\n}\r\nu32 mvs_64xx_spi_read_data(struct mvs_info *mvi)\r\n{\r\nvoid __iomem *regs = mvi->regs_ex;\r\nreturn ior32(SPI_DATA_REG_64XX);\r\n}\r\nvoid mvs_64xx_spi_write_data(struct mvs_info *mvi, u32 data)\r\n{\r\nvoid __iomem *regs = mvi->regs_ex;\r\niow32(SPI_DATA_REG_64XX, data);\r\n}\r\nint mvs_64xx_spi_buildcmd(struct mvs_info *mvi,\r\nu32 *dwCmd,\r\nu8 cmd,\r\nu8 read,\r\nu8 length,\r\nu32 addr\r\n)\r\n{\r\nu32 dwTmp;\r\ndwTmp = ((u32)cmd << 24) | ((u32)length << 19);\r\nif (read)\r\ndwTmp |= 1U<<23;\r\nif (addr != MV_MAX_U32) {\r\ndwTmp |= 1U<<22;\r\ndwTmp |= (addr & 0x0003FFFF);\r\n}\r\n*dwCmd = dwTmp;\r\nreturn 0;\r\n}\r\nint mvs_64xx_spi_issuecmd(struct mvs_info *mvi, u32 cmd)\r\n{\r\nvoid __iomem *regs = mvi->regs_ex;\r\nint retry;\r\nfor (retry = 0; retry < 1; retry++) {\r\niow32(SPI_CTRL_REG_64XX, SPI_CTRL_VENDOR_ENABLE);\r\niow32(SPI_CMD_REG_64XX, cmd);\r\niow32(SPI_CTRL_REG_64XX,\r\nSPI_CTRL_VENDOR_ENABLE | SPI_CTRL_SPISTART);\r\n}\r\nreturn 0;\r\n}\r\nint mvs_64xx_spi_waitdataready(struct mvs_info *mvi, u32 timeout)\r\n{\r\nvoid __iomem *regs = mvi->regs_ex;\r\nu32 i, dwTmp;\r\nfor (i = 0; i < timeout; i++) {\r\ndwTmp = ior32(SPI_CTRL_REG_64XX);\r\nif (!(dwTmp & SPI_CTRL_SPISTART))\r\nreturn 0;\r\nmsleep(10);\r\n}\r\nreturn -1;\r\n}\r\nvoid mvs_64xx_fix_dma(struct mvs_info *mvi, u32 phy_mask,\r\nint buf_len, int from, void *prd)\r\n{\r\nint i;\r\nstruct mvs_prd *buf_prd = prd;\r\ndma_addr_t buf_dma = mvi->bulk_buffer_dma;\r\nbuf_prd += from;\r\nfor (i = 0; i < MAX_SG_ENTRY - from; i++) {\r\nbuf_prd->addr = cpu_to_le64(buf_dma);\r\nbuf_prd->len = cpu_to_le32(buf_len);\r\n++buf_prd;\r\n}\r\n}\r\nstatic void mvs_64xx_tune_interrupt(struct mvs_info *mvi, u32 time)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp = 0;\r\nif (time == 0) {\r\nmw32(MVS_INT_COAL, 0);\r\nmw32(MVS_INT_COAL_TMOUT, 0x10000);\r\n} else {\r\nif (MVS_CHIP_SLOT_SZ > 0x1ff)\r\nmw32(MVS_INT_COAL, 0x1ff|COAL_EN);\r\nelse\r\nmw32(MVS_INT_COAL, MVS_CHIP_SLOT_SZ|COAL_EN);\r\ntmp = 0x10000 | time;\r\nmw32(MVS_INT_COAL_TMOUT, tmp);\r\n}\r\n}
