static inline u32 pmcmsptwi_clock_to_reg(\r\nconst struct pmcmsptwi_clock *clock)\r\n{\r\nreturn ((clock->filter & 0xf) << 12) | (clock->clock & 0x03ff);\r\n}\r\nstatic inline void pmcmsptwi_reg_to_clock(\r\nu32 reg, struct pmcmsptwi_clock *clock)\r\n{\r\nclock->filter = (reg >> 12) & 0xf;\r\nclock->clock = reg & 0x03ff;\r\n}\r\nstatic inline u32 pmcmsptwi_cfg_to_reg(const struct pmcmsptwi_cfg *cfg)\r\n{\r\nreturn ((cfg->arbf & 0xf) << 12) |\r\n((cfg->nak & 0xf) << 8) |\r\n((cfg->add10 & 0x1) << 7) |\r\n((cfg->mst_code & 0x7) << 4) |\r\n((cfg->arb & 0x1) << 1) |\r\n(cfg->highspeed & 0x1);\r\n}\r\nstatic inline void pmcmsptwi_reg_to_cfg(u32 reg, struct pmcmsptwi_cfg *cfg)\r\n{\r\ncfg->arbf = (reg >> 12) & 0xf;\r\ncfg->nak = (reg >> 8) & 0xf;\r\ncfg->add10 = (reg >> 7) & 0x1;\r\ncfg->mst_code = (reg >> 4) & 0x7;\r\ncfg->arb = (reg >> 1) & 0x1;\r\ncfg->highspeed = reg & 0x1;\r\n}\r\nstatic void pmcmsptwi_set_clock_config(const struct pmcmsptwi_clockcfg *cfg,\r\nstruct pmcmsptwi_data *data)\r\n{\r\nmutex_lock(&data->lock);\r\npmcmsptwi_writel(pmcmsptwi_clock_to_reg(&cfg->standard),\r\ndata->iobase + MSP_TWI_SF_CLK_REG_OFFSET);\r\npmcmsptwi_writel(pmcmsptwi_clock_to_reg(&cfg->highspeed),\r\ndata->iobase + MSP_TWI_HS_CLK_REG_OFFSET);\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic void pmcmsptwi_get_twi_config(struct pmcmsptwi_cfg *cfg,\r\nstruct pmcmsptwi_data *data)\r\n{\r\nmutex_lock(&data->lock);\r\npmcmsptwi_reg_to_cfg(pmcmsptwi_readl(\r\ndata->iobase + MSP_TWI_CFG_REG_OFFSET), cfg);\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic void pmcmsptwi_set_twi_config(const struct pmcmsptwi_cfg *cfg,\r\nstruct pmcmsptwi_data *data)\r\n{\r\nmutex_lock(&data->lock);\r\npmcmsptwi_writel(pmcmsptwi_cfg_to_reg(cfg),\r\ndata->iobase + MSP_TWI_CFG_REG_OFFSET);\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic enum pmcmsptwi_xfer_result pmcmsptwi_get_result(u32 reg)\r\n{\r\nif (reg & MSP_TWI_INT_STS_LOST_ARBITRATION) {\r\ndev_dbg(&pmcmsptwi_adapter.dev,\r\n"Result: Lost arbitration\n");\r\nreturn MSP_TWI_XFER_LOST_ARBITRATION;\r\n} else if (reg & MSP_TWI_INT_STS_NO_RESPONSE) {\r\ndev_dbg(&pmcmsptwi_adapter.dev,\r\n"Result: No response\n");\r\nreturn MSP_TWI_XFER_NO_RESPONSE;\r\n} else if (reg & MSP_TWI_INT_STS_DATA_COLLISION) {\r\ndev_dbg(&pmcmsptwi_adapter.dev,\r\n"Result: Data collision\n");\r\nreturn MSP_TWI_XFER_DATA_COLLISION;\r\n} else if (reg & MSP_TWI_INT_STS_BUSY) {\r\ndev_dbg(&pmcmsptwi_adapter.dev,\r\n"Result: Bus busy\n");\r\nreturn MSP_TWI_XFER_BUSY;\r\n}\r\ndev_dbg(&pmcmsptwi_adapter.dev, "Result: Operation succeeded\n");\r\nreturn MSP_TWI_XFER_OK;\r\n}\r\nstatic irqreturn_t pmcmsptwi_interrupt(int irq, void *ptr)\r\n{\r\nstruct pmcmsptwi_data *data = ptr;\r\nu32 reason = pmcmsptwi_readl(data->iobase +\r\nMSP_TWI_INT_STS_REG_OFFSET);\r\npmcmsptwi_writel(reason, data->iobase + MSP_TWI_INT_STS_REG_OFFSET);\r\ndev_dbg(&pmcmsptwi_adapter.dev, "Got interrupt 0x%08x\n", reason);\r\nif (!(reason & MSP_TWI_INT_STS_DONE))\r\nreturn IRQ_NONE;\r\ndata->last_result = pmcmsptwi_get_result(reason);\r\ncomplete(&data->wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit pmcmsptwi_probe(struct platform_device *pldev)\r\n{\r\nstruct resource *res;\r\nint rc = -ENODEV;\r\nres = platform_get_resource(pldev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pldev->dev, "IOMEM resource not found\n");\r\ngoto ret_err;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res),\r\npldev->name)) {\r\ndev_err(&pldev->dev,\r\n"Unable to get memory/io address region 0x%08x\n",\r\nres->start);\r\nrc = -EBUSY;\r\ngoto ret_err;\r\n}\r\npmcmsptwi_data.iobase = ioremap_nocache(res->start,\r\nresource_size(res));\r\nif (!pmcmsptwi_data.iobase) {\r\ndev_err(&pldev->dev,\r\n"Unable to ioremap address 0x%08x\n", res->start);\r\nrc = -EIO;\r\ngoto ret_unreserve;\r\n}\r\npmcmsptwi_data.irq = platform_get_irq(pldev, 0);\r\nif (pmcmsptwi_data.irq) {\r\nrc = request_irq(pmcmsptwi_data.irq, &pmcmsptwi_interrupt,\r\nIRQF_SHARED, pldev->name, &pmcmsptwi_data);\r\nif (rc == 0) {\r\npmcmsptwi_writel(MSP_TWI_INT_STS_DONE,\r\npmcmsptwi_data.iobase +\r\nMSP_TWI_INT_MSK_REG_OFFSET);\r\n} else {\r\ndev_warn(&pldev->dev,\r\n"Could not assign TWI IRQ handler "\r\n"to irq %d (continuing with poll)\n",\r\npmcmsptwi_data.irq);\r\npmcmsptwi_data.irq = 0;\r\n}\r\n}\r\ninit_completion(&pmcmsptwi_data.wait);\r\nmutex_init(&pmcmsptwi_data.lock);\r\npmcmsptwi_set_clock_config(&pmcmsptwi_defclockcfg, &pmcmsptwi_data);\r\npmcmsptwi_set_twi_config(&pmcmsptwi_defcfg, &pmcmsptwi_data);\r\nprintk(KERN_INFO DRV_NAME ": Registering MSP71xx I2C adapter\n");\r\npmcmsptwi_adapter.dev.parent = &pldev->dev;\r\nplatform_set_drvdata(pldev, &pmcmsptwi_adapter);\r\ni2c_set_adapdata(&pmcmsptwi_adapter, &pmcmsptwi_data);\r\nrc = i2c_add_adapter(&pmcmsptwi_adapter);\r\nif (rc) {\r\ndev_err(&pldev->dev, "Unable to register I2C adapter\n");\r\ngoto ret_unmap;\r\n}\r\nreturn 0;\r\nret_unmap:\r\nplatform_set_drvdata(pldev, NULL);\r\nif (pmcmsptwi_data.irq) {\r\npmcmsptwi_writel(0,\r\npmcmsptwi_data.iobase + MSP_TWI_INT_MSK_REG_OFFSET);\r\nfree_irq(pmcmsptwi_data.irq, &pmcmsptwi_data);\r\n}\r\niounmap(pmcmsptwi_data.iobase);\r\nret_unreserve:\r\nrelease_mem_region(res->start, resource_size(res));\r\nret_err:\r\nreturn rc;\r\n}\r\nstatic int __devexit pmcmsptwi_remove(struct platform_device *pldev)\r\n{\r\nstruct resource *res;\r\ni2c_del_adapter(&pmcmsptwi_adapter);\r\nplatform_set_drvdata(pldev, NULL);\r\nif (pmcmsptwi_data.irq) {\r\npmcmsptwi_writel(0,\r\npmcmsptwi_data.iobase + MSP_TWI_INT_MSK_REG_OFFSET);\r\nfree_irq(pmcmsptwi_data.irq, &pmcmsptwi_data);\r\n}\r\niounmap(pmcmsptwi_data.iobase);\r\nres = platform_get_resource(pldev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn 0;\r\n}\r\nstatic void pmcmsptwi_poll_complete(struct pmcmsptwi_data *data)\r\n{\r\nint i;\r\nfor (i = 0; i < MSP_MAX_POLL; i++) {\r\nu32 val = pmcmsptwi_readl(data->iobase +\r\nMSP_TWI_BUSY_REG_OFFSET);\r\nif (val == 0) {\r\nu32 reason = pmcmsptwi_readl(data->iobase +\r\nMSP_TWI_INT_STS_REG_OFFSET);\r\npmcmsptwi_writel(reason, data->iobase +\r\nMSP_TWI_INT_STS_REG_OFFSET);\r\ndata->last_result = pmcmsptwi_get_result(reason);\r\nreturn;\r\n}\r\nudelay(MSP_POLL_DELAY);\r\n}\r\ndev_dbg(&pmcmsptwi_adapter.dev, "Result: Poll timeout\n");\r\ndata->last_result = MSP_TWI_XFER_TIMEOUT;\r\n}\r\nstatic enum pmcmsptwi_xfer_result pmcmsptwi_do_xfer(\r\nu32 reg, struct pmcmsptwi_data *data)\r\n{\r\ndev_dbg(&pmcmsptwi_adapter.dev, "Writing cmd reg 0x%08x\n", reg);\r\npmcmsptwi_writel(reg, data->iobase + MSP_TWI_CMD_REG_OFFSET);\r\nif (data->irq) {\r\nunsigned long timeleft = wait_for_completion_timeout(\r\n&data->wait, MSP_IRQ_TIMEOUT);\r\nif (timeleft == 0) {\r\ndev_dbg(&pmcmsptwi_adapter.dev,\r\n"Result: IRQ timeout\n");\r\ncomplete(&data->wait);\r\ndata->last_result = MSP_TWI_XFER_TIMEOUT;\r\n}\r\n} else\r\npmcmsptwi_poll_complete(data);\r\nreturn data->last_result;\r\n}\r\nstatic inline u32 pmcmsptwi_cmd_to_reg(const struct pmcmsptwi_cmd *cmd)\r\n{\r\nreturn ((cmd->type & 0x3) << 8) |\r\n(((cmd->write_len - 1) & 0x7) << 4) |\r\n((cmd->read_len - 1) & 0x7);\r\n}\r\nstatic enum pmcmsptwi_xfer_result pmcmsptwi_xfer_cmd(\r\nstruct pmcmsptwi_cmd *cmd,\r\nstruct pmcmsptwi_data *data)\r\n{\r\nenum pmcmsptwi_xfer_result retval;\r\nif ((cmd->type == MSP_TWI_CMD_WRITE && cmd->write_len == 0) ||\r\n(cmd->type == MSP_TWI_CMD_READ && cmd->read_len == 0) ||\r\n(cmd->type == MSP_TWI_CMD_WRITE_READ &&\r\n(cmd->read_len == 0 || cmd->write_len == 0))) {\r\ndev_err(&pmcmsptwi_adapter.dev,\r\n"%s: Cannot transfer less than 1 byte\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (cmd->read_len > MSP_MAX_BYTES_PER_RW ||\r\ncmd->write_len > MSP_MAX_BYTES_PER_RW) {\r\ndev_err(&pmcmsptwi_adapter.dev,\r\n"%s: Cannot transfer more than %d bytes\n",\r\n__func__, MSP_MAX_BYTES_PER_RW);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&data->lock);\r\ndev_dbg(&pmcmsptwi_adapter.dev,\r\n"Setting address to 0x%04x\n", cmd->addr);\r\npmcmsptwi_writel(cmd->addr, data->iobase + MSP_TWI_ADD_REG_OFFSET);\r\nif (cmd->type == MSP_TWI_CMD_WRITE ||\r\ncmd->type == MSP_TWI_CMD_WRITE_READ) {\r\nu64 tmp = be64_to_cpup((__be64 *)cmd->write_data);\r\ntmp >>= (MSP_MAX_BYTES_PER_RW - cmd->write_len) * 8;\r\ndev_dbg(&pmcmsptwi_adapter.dev, "Writing 0x%016llx\n", tmp);\r\npmcmsptwi_writel(tmp & 0x00000000ffffffffLL,\r\ndata->iobase + MSP_TWI_DAT_0_REG_OFFSET);\r\nif (cmd->write_len > 4)\r\npmcmsptwi_writel(tmp >> 32,\r\ndata->iobase + MSP_TWI_DAT_1_REG_OFFSET);\r\n}\r\nretval = pmcmsptwi_do_xfer(pmcmsptwi_cmd_to_reg(cmd), data);\r\nif (retval != MSP_TWI_XFER_OK)\r\ngoto xfer_err;\r\nif (cmd->type == MSP_TWI_CMD_READ ||\r\ncmd->type == MSP_TWI_CMD_WRITE_READ) {\r\nint i;\r\nu64 rmsk = ~(0xffffffffffffffffLL << (cmd->read_len * 8));\r\nu64 tmp = (u64)pmcmsptwi_readl(data->iobase +\r\nMSP_TWI_DAT_0_REG_OFFSET);\r\nif (cmd->read_len > 4)\r\ntmp |= (u64)pmcmsptwi_readl(data->iobase +\r\nMSP_TWI_DAT_1_REG_OFFSET) << 32;\r\ntmp &= rmsk;\r\ndev_dbg(&pmcmsptwi_adapter.dev, "Read 0x%016llx\n", tmp);\r\nfor (i = 0; i < cmd->read_len; i++)\r\ncmd->read_data[i] = tmp >> i;\r\n}\r\nxfer_err:\r\nmutex_unlock(&data->lock);\r\nreturn retval;\r\n}\r\nstatic int pmcmsptwi_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msg, int num)\r\n{\r\nstruct pmcmsptwi_data *data = i2c_get_adapdata(adap);\r\nstruct pmcmsptwi_cmd cmd;\r\nstruct pmcmsptwi_cfg oldcfg, newcfg;\r\nint ret;\r\nif (num > 2) {\r\ndev_dbg(&adap->dev, "%d messages unsupported\n", num);\r\nreturn -EINVAL;\r\n} else if (num == 2) {\r\nstruct i2c_msg *nextmsg = msg + 1;\r\nif (!(msg->flags & I2C_M_RD) &&\r\n(nextmsg->flags & I2C_M_RD) &&\r\nmsg->addr == nextmsg->addr) {\r\ncmd.type = MSP_TWI_CMD_WRITE_READ;\r\ncmd.write_len = msg->len;\r\ncmd.write_data = msg->buf;\r\ncmd.read_len = nextmsg->len;\r\ncmd.read_data = nextmsg->buf;\r\n} else {\r\ndev_dbg(&adap->dev,\r\n"Non write-read dual messages unsupported\n");\r\nreturn -EINVAL;\r\n}\r\n} else if (msg->flags & I2C_M_RD) {\r\ncmd.type = MSP_TWI_CMD_READ;\r\ncmd.read_len = msg->len;\r\ncmd.read_data = msg->buf;\r\ncmd.write_len = 0;\r\ncmd.write_data = NULL;\r\n} else {\r\ncmd.type = MSP_TWI_CMD_WRITE;\r\ncmd.read_len = 0;\r\ncmd.read_data = NULL;\r\ncmd.write_len = msg->len;\r\ncmd.write_data = msg->buf;\r\n}\r\nif (msg->len == 0) {\r\ndev_err(&adap->dev, "Zero-byte messages unsupported\n");\r\nreturn -EINVAL;\r\n}\r\ncmd.addr = msg->addr;\r\nif (msg->flags & I2C_M_TEN) {\r\npmcmsptwi_get_twi_config(&newcfg, data);\r\nmemcpy(&oldcfg, &newcfg, sizeof(oldcfg));\r\nnewcfg.add10 = 1;\r\npmcmsptwi_set_twi_config(&newcfg, data);\r\n}\r\nret = pmcmsptwi_xfer_cmd(&cmd, data);\r\nif (msg->flags & I2C_M_TEN)\r\npmcmsptwi_set_twi_config(&oldcfg, data);\r\ndev_dbg(&adap->dev, "I2C %s of %d bytes %s\n",\r\n(msg->flags & I2C_M_RD) ? "read" : "write", msg->len,\r\n(ret == MSP_TWI_XFER_OK) ? "succeeded" : "failed");\r\nif (ret != MSP_TWI_XFER_OK) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 pmcmsptwi_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR |\r\nI2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_PROC_CALL;\r\n}
