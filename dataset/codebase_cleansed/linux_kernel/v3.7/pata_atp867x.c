static void atp867x_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstruct atp867x_priv *dp = ap->private_data;\r\nu8 speed = adev->dma_mode;\r\nu8 b;\r\nu8 mode = speed - XFER_UDMA_0 + 1;\r\nif (dp->pci66mhz && mode > ATP867X_IO_DMAMODE_UDMA_0 &&\r\n(pdev->device == PCI_DEVICE_ID_ARTOP_ATP867B ||\r\nmode < ATP867X_IO_DMAMODE_UDMA_5))\r\nmode--;\r\nb = ioread8(dp->dma_mode);\r\nif (adev->devno & 1) {\r\nb = (b & ~ATP867X_IO_DMAMODE_SLAVE_MASK) |\r\n(mode << ATP867X_IO_DMAMODE_SLAVE_SHIFT);\r\n} else {\r\nb = (b & ~ATP867X_IO_DMAMODE_MSTR_MASK) |\r\n(mode << ATP867X_IO_DMAMODE_MSTR_SHIFT);\r\n}\r\niowrite8(b, dp->dma_mode);\r\n}\r\nstatic int atp867x_get_active_clocks_shifted(struct ata_port *ap,\r\nunsigned int clk)\r\n{\r\nstruct atp867x_priv *dp = ap->private_data;\r\nunsigned char clocks = clk;\r\nif (dp->pci66mhz)\r\nclocks++;\r\nswitch (clocks) {\r\ncase 0:\r\nclocks = 1;\r\nbreak;\r\ncase 1 ... 6:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "ATP867X: active %dclk is invalid. "\r\n"Using 12clk.\n", clk);\r\ncase 9 ... 12:\r\nclocks = 7;\r\nbreak;\r\ncase 7:\r\ncase 8:\r\nclocks = 0;\r\ngoto active_clock_shift_done;\r\n}\r\nactive_clock_shift_done:\r\nreturn clocks << ATP867X_IO_PIOSPD_ACTIVE_SHIFT;\r\n}\r\nstatic int atp867x_get_recover_clocks_shifted(unsigned int clk)\r\n{\r\nunsigned char clocks = clk;\r\nswitch (clocks) {\r\ncase 0:\r\nclocks = 1;\r\nbreak;\r\ncase 1 ... 11:\r\nbreak;\r\ncase 13:\r\ncase 14:\r\n--clocks;\r\nbreak;\r\ncase 15:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "ATP867X: recover %dclk is invalid. "\r\n"Using default 12clk.\n", clk);\r\ncase 12:\r\nclocks = 0;\r\nbreak;\r\n}\r\nreturn clocks << ATP867X_IO_PIOSPD_RECOVER_SHIFT;\r\n}\r\nstatic void atp867x_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct ata_device *peer = ata_dev_pair(adev);\r\nstruct atp867x_priv *dp = ap->private_data;\r\nu8 speed = adev->pio_mode;\r\nstruct ata_timing t, p;\r\nint T, UT;\r\nu8 b;\r\nT = 1000000000 / 33333;\r\nUT = T / 4;\r\nata_timing_compute(adev, speed, &t, T, UT);\r\nif (peer && peer->pio_mode) {\r\nata_timing_compute(peer, peer->pio_mode, &p, T, UT);\r\nata_timing_merge(&p, &t, &t, ATA_TIMING_8BIT);\r\n}\r\nb = ioread8(dp->dma_mode);\r\nif (adev->devno & 1)\r\nb = (b & ~ATP867X_IO_DMAMODE_SLAVE_MASK);\r\nelse\r\nb = (b & ~ATP867X_IO_DMAMODE_MSTR_MASK);\r\niowrite8(b, dp->dma_mode);\r\nb = atp867x_get_active_clocks_shifted(ap, t.active) |\r\natp867x_get_recover_clocks_shifted(t.recover);\r\nif (adev->devno & 1)\r\niowrite8(b, dp->slave_piospd);\r\nelse\r\niowrite8(b, dp->mstr_piospd);\r\nb = atp867x_get_active_clocks_shifted(ap, t.act8b) |\r\natp867x_get_recover_clocks_shifted(t.rec8b);\r\niowrite8(b, dp->eightb_piospd);\r\n}\r\nstatic int atp867x_cable_override(struct pci_dev *pdev)\r\n{\r\nif (pdev->subsystem_vendor == PCI_VENDOR_ID_ARTOP &&\r\n(pdev->subsystem_device == PCI_DEVICE_ID_ARTOP_ATP867A ||\r\npdev->subsystem_device == PCI_DEVICE_ID_ARTOP_ATP867B)) {\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atp867x_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nif (atp867x_cable_override(pdev))\r\nreturn ATA_CBL_PATA40_SHORT;\r\nreturn ATA_CBL_PATA_UNK;\r\n}\r\nstatic void atp867x_check_res(struct pci_dev *pdev)\r\n{\r\nint i;\r\nunsigned long start, len;\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\r\nstart = pci_resource_start(pdev, i);\r\nlen = pci_resource_len(pdev, i);\r\nprintk(KERN_DEBUG "ATP867X: resource start:len=%lx:%lx\n",\r\nstart, len);\r\n}\r\n}\r\nstatic void atp867x_check_ports(struct ata_port *ap, int port)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nstruct atp867x_priv *dp = ap->private_data;\r\nprintk(KERN_DEBUG "ATP867X: port[%d] addresses\n"\r\n" cmd_addr =0x%llx, 0x%llx\n"\r\n" ctl_addr =0x%llx, 0x%llx\n"\r\n" bmdma_addr =0x%llx, 0x%llx\n"\r\n" data_addr =0x%llx\n"\r\n" error_addr =0x%llx\n"\r\n" feature_addr =0x%llx\n"\r\n" nsect_addr =0x%llx\n"\r\n" lbal_addr =0x%llx\n"\r\n" lbam_addr =0x%llx\n"\r\n" lbah_addr =0x%llx\n"\r\n" device_addr =0x%llx\n"\r\n" status_addr =0x%llx\n"\r\n" command_addr =0x%llx\n"\r\n" dp->dma_mode =0x%llx\n"\r\n" dp->mstr_piospd =0x%llx\n"\r\n" dp->slave_piospd =0x%llx\n"\r\n" dp->eightb_piospd =0x%llx\n"\r\n" dp->pci66mhz =0x%lx\n",\r\nport,\r\n(unsigned long long)ioaddr->cmd_addr,\r\n(unsigned long long)ATP867X_IO_PORTBASE(ap, port),\r\n(unsigned long long)ioaddr->ctl_addr,\r\n(unsigned long long)ATP867X_IO_ALTSTATUS(ap, port),\r\n(unsigned long long)ioaddr->bmdma_addr,\r\n(unsigned long long)ATP867X_IO_DMABASE(ap, port),\r\n(unsigned long long)ioaddr->data_addr,\r\n(unsigned long long)ioaddr->error_addr,\r\n(unsigned long long)ioaddr->feature_addr,\r\n(unsigned long long)ioaddr->nsect_addr,\r\n(unsigned long long)ioaddr->lbal_addr,\r\n(unsigned long long)ioaddr->lbam_addr,\r\n(unsigned long long)ioaddr->lbah_addr,\r\n(unsigned long long)ioaddr->device_addr,\r\n(unsigned long long)ioaddr->status_addr,\r\n(unsigned long long)ioaddr->command_addr,\r\n(unsigned long long)dp->dma_mode,\r\n(unsigned long long)dp->mstr_piospd,\r\n(unsigned long long)dp->slave_piospd,\r\n(unsigned long long)dp->eightb_piospd,\r\n(unsigned long)dp->pci66mhz);\r\n}\r\nstatic int atp867x_set_priv(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstruct atp867x_priv *dp;\r\nint port = ap->port_no;\r\ndp = ap->private_data =\r\ndevm_kzalloc(&pdev->dev, sizeof(*dp), GFP_KERNEL);\r\nif (dp == NULL)\r\nreturn -ENOMEM;\r\ndp->dma_mode = ATP867X_IO_DMAMODE(ap, port);\r\ndp->mstr_piospd = ATP867X_IO_MSTRPIOSPD(ap, port);\r\ndp->slave_piospd = ATP867X_IO_SLAVPIOSPD(ap, port);\r\ndp->eightb_piospd = ATP867X_IO_8BPIOSPD(ap, port);\r\ndp->pci66mhz =\r\nioread8(ATP867X_SYS_INFO(ap)) & ATP867X_IO_SYS_INFO_66MHZ;\r\nreturn 0;\r\n}\r\nstatic void atp867x_fixup(struct ata_host *host)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nstruct ata_port *ap = host->ports[0];\r\nint i;\r\nu8 v;\r\npci_read_config_byte(pdev, PCI_LATENCY_TIMER, &v);\r\nif (v < 0x80) {\r\nv = 0x80;\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, v);\r\nprintk(KERN_DEBUG "ATP867X: set latency timer of device %s"\r\n" to %d\n", pci_name(pdev), v);\r\n}\r\nfor (i = 0; i < ATP867X_NUM_PORTS; i++)\r\niowrite16(ATP867X_IO_PORTSPD_VAL, ATP867X_IO_PORTSPD(ap, i));\r\nfor (i = 0; i < ATP867X_NUM_PORTS; i++)\r\niowrite16(ATP867X_PREREAD_VAL, ATP867X_IO_PREREAD(ap, i));\r\nv = ioread8(ATP867X_IOBASE(ap) + 0x28);\r\nv &= 0xcf;\r\nv |= 0xc0;\r\niowrite8(v, ATP867X_IOBASE(ap) + 0x28);\r\nv = ioread8(ATP867X_SYS_INFO(ap));\r\nv &= ATP867X_IO_SYS_MASK_RESERVED;\r\nif (pdev->device == PCI_DEVICE_ID_ARTOP_ATP867B)\r\nv |= ATP867X_IO_SYS_INFO_SLOW_UDMA5;\r\niowrite8(v, ATP867X_SYS_INFO(ap));\r\n}\r\nstatic int atp867x_ata_pci_sff_init_host(struct ata_host *host)\r\n{\r\nstruct device *gdev = host->dev;\r\nstruct pci_dev *pdev = to_pci_dev(gdev);\r\nunsigned int mask = 0;\r\nint i, rc;\r\nrc = pcim_iomap_regions(pdev, 1 << ATP867X_BAR_IOBASE, DRV_NAME);\r\nif (rc == -EBUSY)\r\npcim_pin_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nhost->iomap = pcim_iomap_table(pdev);\r\n#ifdef ATP867X_DEBUG\r\natp867x_check_res(pdev);\r\nfor (i = 0; i < PCI_ROM_RESOURCE; i++)\r\nprintk(KERN_DEBUG "ATP867X: iomap[%d]=0x%llx\n", i,\r\n(unsigned long long)(host->iomap[i]));\r\n#endif\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nioaddr->cmd_addr = ATP867X_IO_PORTBASE(ap, i);\r\nioaddr->ctl_addr = ioaddr->altstatus_addr\r\n= ATP867X_IO_ALTSTATUS(ap, i);\r\nioaddr->bmdma_addr = ATP867X_IO_DMABASE(ap, i);\r\nata_sff_std_ports(ioaddr);\r\nrc = atp867x_set_priv(ap);\r\nif (rc)\r\nreturn rc;\r\n#ifdef ATP867X_DEBUG\r\natp867x_check_ports(ap, i);\r\n#endif\r\nata_port_desc(ap, "cmd 0x%lx ctl 0x%lx",\r\n(unsigned long)ioaddr->cmd_addr,\r\n(unsigned long)ioaddr->ctl_addr);\r\nata_port_desc(ap, "bmdma 0x%lx",\r\n(unsigned long)ioaddr->bmdma_addr);\r\nmask |= 1 << i;\r\n}\r\nif (!mask) {\r\ndev_err(gdev, "no available native port\n");\r\nreturn -ENODEV;\r\n}\r\natp867x_fixup(host);\r\nrc = pci_set_dma_mask(pdev, ATA_DMA_MASK);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_set_consistent_dma_mask(pdev, ATA_DMA_MASK);\r\nreturn rc;\r\n}\r\nstatic int atp867x_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info info_867x = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &atp867x_ops,\r\n};\r\nstruct ata_host *host;\r\nconst struct ata_port_info *ppi[] = { &info_867x, NULL };\r\nint rc;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nprintk(KERN_INFO "ATP867X: ATP867 ATA UDMA133 controller (rev %02X)",\r\npdev->device);\r\nhost = ata_host_alloc_pinfo(&pdev->dev, ppi, ATP867X_NUM_PORTS);\r\nif (!host) {\r\ndev_err(&pdev->dev, "failed to allocate ATA host\n");\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\nrc = atp867x_ata_pci_sff_init_host(host);\r\nif (rc) {\r\ndev_err(&pdev->dev, "failed to init host\n");\r\ngoto err_out;\r\n}\r\npci_set_master(pdev);\r\nrc = ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,\r\nIRQF_SHARED, &atp867x_sht);\r\nif (rc)\r\ndev_err(&pdev->dev, "failed to activate host\n");\r\nerr_out:\r\nreturn rc;\r\n}\r\nstatic int atp867x_reinit_one(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nint rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\natp867x_fixup(host);\r\nata_host_resume(host);\r\nreturn 0;\r\n}
