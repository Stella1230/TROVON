static void __iomem *rtl_port_map(phys_addr_t addr, unsigned long len)\r\n{\r\nif (rtl_cmd_type == RTL_ADDR_TYPE_MMIO)\r\nreturn ioremap(addr, len);\r\nreturn ioport_map(addr, len);\r\n}\r\nstatic void rtl_port_unmap(void __iomem *addr)\r\n{\r\nif (addr && rtl_cmd_type == RTL_ADDR_TYPE_MMIO)\r\niounmap(addr);\r\nelse\r\nioport_unmap(addr);\r\n}\r\nstatic int ibm_rtl_write(u8 value)\r\n{\r\nint ret = 0, count = 0;\r\nstatic u32 cmd_port_val;\r\nRTL_DEBUG("%s(%d)\n", __func__, value);\r\nvalue = value == 1 ? RTL_CMD_ENTER_PRTM : RTL_CMD_EXIT_PRTM;\r\nmutex_lock(&rtl_lock);\r\nif (ioread8(&rtl_table->rt_status) != value) {\r\niowrite8(value, &rtl_table->command);\r\nswitch (rtl_cmd_width) {\r\ncase 8:\r\ncmd_port_val = ioread8(&rtl_table->cmd_port_value);\r\nRTL_DEBUG("cmd_port_val = %u\n", cmd_port_val);\r\niowrite8((u8)cmd_port_val, rtl_cmd_addr);\r\nbreak;\r\ncase 16:\r\ncmd_port_val = ioread16(&rtl_table->cmd_port_value);\r\nRTL_DEBUG("cmd_port_val = %u\n", cmd_port_val);\r\niowrite16((u16)cmd_port_val, rtl_cmd_addr);\r\nbreak;\r\ncase 32:\r\ncmd_port_val = ioread32(&rtl_table->cmd_port_value);\r\nRTL_DEBUG("cmd_port_val = %u\n", cmd_port_val);\r\niowrite32(cmd_port_val, rtl_cmd_addr);\r\nbreak;\r\n}\r\nwhile (ioread8(&rtl_table->command)) {\r\nmsleep(10);\r\nif (count++ > 500) {\r\npr_err("Hardware not responding to "\r\n"mode switch request\n");\r\nret = -EIO;\r\nbreak;\r\n}\r\n}\r\nif (ioread8(&rtl_table->command_status)) {\r\nRTL_DEBUG("command_status reports failed command\n");\r\nret = -EIO;\r\n}\r\n}\r\nmutex_unlock(&rtl_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t rtl_show_version(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", (int)ioread8(&rtl_table->version));\r\n}\r\nstatic ssize_t rtl_show_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", ioread8(&rtl_table->rt_status));\r\n}\r\nstatic ssize_t rtl_set_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nssize_t ret;\r\nif (count < 1 || count > 2)\r\nreturn -EINVAL;\r\nswitch (buf[0]) {\r\ncase '0':\r\nret = ibm_rtl_write(0);\r\nbreak;\r\ncase '1':\r\nret = ibm_rtl_write(1);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (ret >= 0)\r\nret = count;\r\nreturn ret;\r\n}\r\nstatic int rtl_setup_sysfs(void) {\r\nint ret, i;\r\nret = subsys_system_register(&rtl_subsys, NULL);\r\nif (!ret) {\r\nfor (i = 0; rtl_attributes[i]; i ++)\r\ndevice_create_file(rtl_subsys.dev_root, rtl_attributes[i]);\r\n}\r\nreturn ret;\r\n}\r\nstatic void rtl_teardown_sysfs(void) {\r\nint i;\r\nfor (i = 0; rtl_attributes[i]; i ++)\r\ndevice_remove_file(rtl_subsys.dev_root, rtl_attributes[i]);\r\nbus_unregister(&rtl_subsys);\r\n}\r\nstatic int __init ibm_rtl_init(void) {\r\nunsigned long ebda_addr, ebda_size;\r\nunsigned int ebda_kb;\r\nint ret = -ENODEV, i;\r\nif (force)\r\npr_warn("module loaded by force\n");\r\nelse if (efi_enabled || !dmi_check_system(ibm_rtl_dmi_table))\r\nreturn -ENODEV;\r\nebda_addr = get_bios_ebda();\r\nif (!ebda_addr) {\r\nRTL_DEBUG("no BIOS EBDA found\n");\r\nreturn -ENODEV;\r\n}\r\nebda_map = ioremap(ebda_addr, 4);\r\nif (!ebda_map)\r\nreturn -ENOMEM;\r\nebda_kb = ioread16(ebda_map);\r\nRTL_DEBUG("EBDA is %d kB\n", ebda_kb);\r\nif (ebda_kb == 0)\r\ngoto out;\r\niounmap(ebda_map);\r\nebda_size = ebda_kb*1024;\r\nebda_map = ioremap(ebda_addr, ebda_size);\r\nif (!ebda_map)\r\nreturn -ENOMEM;\r\nfor (i = 0 ; i < ebda_size/sizeof(unsigned int); i++) {\r\nstruct ibm_rtl_table __iomem * tmp;\r\ntmp = (struct ibm_rtl_table __iomem *) (ebda_map+i);\r\nif ((readq(&tmp->signature) & RTL_MASK) == RTL_SIGNATURE) {\r\nphys_addr_t addr;\r\nunsigned int plen;\r\nRTL_DEBUG("found RTL_SIGNATURE at %p\n", tmp);\r\nrtl_table = tmp;\r\nrtl_cmd_width = ioread8(&rtl_table->cmd_granularity);\r\nrtl_cmd_type = ioread8(&rtl_table->cmd_address_type);\r\nRTL_DEBUG("rtl_cmd_width = %u, rtl_cmd_type = %u\n",\r\nrtl_cmd_width, rtl_cmd_type);\r\naddr = ioread32(&rtl_table->cmd_port_address);\r\nRTL_DEBUG("addr = %#llx\n", (unsigned long long)addr);\r\nplen = rtl_cmd_width/sizeof(char);\r\nrtl_cmd_addr = rtl_port_map(addr, plen);\r\nRTL_DEBUG("rtl_cmd_addr = %p\n", rtl_cmd_addr);\r\nif (!rtl_cmd_addr) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nret = rtl_setup_sysfs();\r\nbreak;\r\n}\r\n}\r\nout:\r\nif (ret) {\r\niounmap(ebda_map);\r\nrtl_port_unmap(rtl_cmd_addr);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit ibm_rtl_exit(void)\r\n{\r\nif (rtl_table) {\r\nRTL_DEBUG("cleaning up");\r\nibm_rtl_write(0);\r\nrtl_teardown_sysfs();\r\niounmap(ebda_map);\r\nrtl_port_unmap(rtl_cmd_addr);\r\n}\r\n}
