static inline u32 tegra_rtc_check_busy(struct tegra_rtc_info *info)\r\n{\r\nreturn readl(info->rtc_base + TEGRA_RTC_REG_BUSY) & 1;\r\n}\r\nstatic int tegra_rtc_wait_while_busy(struct device *dev)\r\n{\r\nstruct tegra_rtc_info *info = dev_get_drvdata(dev);\r\nint retries = 500;\r\nwhile (tegra_rtc_check_busy(info)) {\r\nif (!retries--)\r\ngoto retry_failed;\r\nudelay(1);\r\n}\r\nreturn 0;\r\nretry_failed:\r\ndev_err(dev, "write failed:retry count exceeded.\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int tegra_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct tegra_rtc_info *info = dev_get_drvdata(dev);\r\nunsigned long sec, msec;\r\nunsigned long sl_irq_flags;\r\nspin_lock_irqsave(&info->tegra_rtc_lock, sl_irq_flags);\r\nmsec = readl(info->rtc_base + TEGRA_RTC_REG_MILLI_SECONDS);\r\nsec = readl(info->rtc_base + TEGRA_RTC_REG_SHADOW_SECONDS);\r\nspin_unlock_irqrestore(&info->tegra_rtc_lock, sl_irq_flags);\r\nrtc_time_to_tm(sec, tm);\r\ndev_vdbg(dev, "time read as %lu. %d/%d/%d %d:%02u:%02u\n",\r\nsec,\r\ntm->tm_mon + 1,\r\ntm->tm_mday,\r\ntm->tm_year + 1900,\r\ntm->tm_hour,\r\ntm->tm_min,\r\ntm->tm_sec\r\n);\r\nreturn 0;\r\n}\r\nstatic int tegra_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct tegra_rtc_info *info = dev_get_drvdata(dev);\r\nunsigned long sec;\r\nint ret;\r\nret = rtc_valid_tm(tm);\r\nif (ret)\r\nreturn ret;\r\nrtc_tm_to_time(tm, &sec);\r\ndev_vdbg(dev, "time set to %lu. %d/%d/%d %d:%02u:%02u\n",\r\nsec,\r\ntm->tm_mon+1,\r\ntm->tm_mday,\r\ntm->tm_year+1900,\r\ntm->tm_hour,\r\ntm->tm_min,\r\ntm->tm_sec\r\n);\r\nret = tegra_rtc_wait_while_busy(dev);\r\nif (!ret)\r\nwritel(sec, info->rtc_base + TEGRA_RTC_REG_SECONDS);\r\ndev_vdbg(dev, "time read back as %d\n",\r\nreadl(info->rtc_base + TEGRA_RTC_REG_SECONDS));\r\nreturn ret;\r\n}\r\nstatic int tegra_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct tegra_rtc_info *info = dev_get_drvdata(dev);\r\nunsigned long sec;\r\nunsigned tmp;\r\nsec = readl(info->rtc_base + TEGRA_RTC_REG_SECONDS_ALARM0);\r\nif (sec == 0) {\r\nalarm->enabled = 0;\r\nalarm->time.tm_mon = -1;\r\nalarm->time.tm_mday = -1;\r\nalarm->time.tm_year = -1;\r\nalarm->time.tm_hour = -1;\r\nalarm->time.tm_min = -1;\r\nalarm->time.tm_sec = -1;\r\n} else {\r\nalarm->enabled = 1;\r\nrtc_time_to_tm(sec, &alarm->time);\r\n}\r\ntmp = readl(info->rtc_base + TEGRA_RTC_REG_INTR_STATUS);\r\nalarm->pending = (tmp & TEGRA_RTC_INTR_STATUS_SEC_ALARM0) != 0;\r\nreturn 0;\r\n}\r\nstatic int tegra_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct tegra_rtc_info *info = dev_get_drvdata(dev);\r\nunsigned status;\r\nunsigned long sl_irq_flags;\r\ntegra_rtc_wait_while_busy(dev);\r\nspin_lock_irqsave(&info->tegra_rtc_lock, sl_irq_flags);\r\nstatus = readl(info->rtc_base + TEGRA_RTC_REG_INTR_MASK);\r\nif (enabled)\r\nstatus |= TEGRA_RTC_INTR_MASK_SEC_ALARM0;\r\nelse\r\nstatus &= ~TEGRA_RTC_INTR_MASK_SEC_ALARM0;\r\nwritel(status, info->rtc_base + TEGRA_RTC_REG_INTR_MASK);\r\nspin_unlock_irqrestore(&info->tegra_rtc_lock, sl_irq_flags);\r\nreturn 0;\r\n}\r\nstatic int tegra_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct tegra_rtc_info *info = dev_get_drvdata(dev);\r\nunsigned long sec;\r\nif (alarm->enabled)\r\nrtc_tm_to_time(&alarm->time, &sec);\r\nelse\r\nsec = 0;\r\ntegra_rtc_wait_while_busy(dev);\r\nwritel(sec, info->rtc_base + TEGRA_RTC_REG_SECONDS_ALARM0);\r\ndev_vdbg(dev, "alarm read back as %d\n",\r\nreadl(info->rtc_base + TEGRA_RTC_REG_SECONDS_ALARM0));\r\nif (sec) {\r\ntegra_rtc_alarm_irq_enable(dev, 1);\r\ndev_vdbg(dev, "alarm set as %lu. %d/%d/%d %d:%02u:%02u\n",\r\nsec,\r\nalarm->time.tm_mon+1,\r\nalarm->time.tm_mday,\r\nalarm->time.tm_year+1900,\r\nalarm->time.tm_hour,\r\nalarm->time.tm_min,\r\nalarm->time.tm_sec);\r\n} else {\r\ndev_vdbg(dev, "alarm disabled\n");\r\ntegra_rtc_alarm_irq_enable(dev, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nif (!dev || !dev->driver)\r\nreturn 0;\r\nreturn seq_printf(seq, "name\t\t: %s\n", dev_name(dev));\r\n}\r\nstatic irqreturn_t tegra_rtc_irq_handler(int irq, void *data)\r\n{\r\nstruct device *dev = data;\r\nstruct tegra_rtc_info *info = dev_get_drvdata(dev);\r\nunsigned long events = 0;\r\nunsigned status;\r\nunsigned long sl_irq_flags;\r\nstatus = readl(info->rtc_base + TEGRA_RTC_REG_INTR_STATUS);\r\nif (status) {\r\ntegra_rtc_wait_while_busy(dev);\r\nspin_lock_irqsave(&info->tegra_rtc_lock, sl_irq_flags);\r\nwritel(0, info->rtc_base + TEGRA_RTC_REG_INTR_MASK);\r\nwritel(status, info->rtc_base + TEGRA_RTC_REG_INTR_STATUS);\r\nspin_unlock_irqrestore(&info->tegra_rtc_lock, sl_irq_flags);\r\n}\r\nif ((status & TEGRA_RTC_INTR_STATUS_SEC_ALARM0))\r\nevents |= RTC_IRQF | RTC_AF;\r\nif ((status & TEGRA_RTC_INTR_STATUS_SEC_CDN_ALARM))\r\nevents |= RTC_IRQF | RTC_PF;\r\nrtc_update_irq(info->rtc_dev, 1, events);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit tegra_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_rtc_info *info;\r\nstruct resource *res;\r\nint ret;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(struct tegra_rtc_info),\r\nGFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev,\r\n"Unable to allocate resources for device.\n");\r\nreturn -EBUSY;\r\n}\r\ninfo->rtc_base = devm_request_and_ioremap(&pdev->dev, res);\r\nif (!info->rtc_base) {\r\ndev_err(&pdev->dev, "Unable to request mem region and grab IOs for device.\n");\r\nreturn -EBUSY;\r\n}\r\ninfo->tegra_rtc_irq = platform_get_irq(pdev, 0);\r\nif (info->tegra_rtc_irq <= 0)\r\nreturn -EBUSY;\r\ninfo->pdev = pdev;\r\nspin_lock_init(&info->tegra_rtc_lock);\r\nplatform_set_drvdata(pdev, info);\r\nwritel(0, info->rtc_base + TEGRA_RTC_REG_SECONDS_ALARM0);\r\nwritel(0xffffffff, info->rtc_base + TEGRA_RTC_REG_INTR_STATUS);\r\nwritel(0, info->rtc_base + TEGRA_RTC_REG_INTR_MASK);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\ninfo->rtc_dev = rtc_device_register(\r\npdev->name, &pdev->dev, &tegra_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(info->rtc_dev)) {\r\nret = PTR_ERR(info->rtc_dev);\r\ninfo->rtc_dev = NULL;\r\ndev_err(&pdev->dev,\r\n"Unable to register device (err=%d).\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, info->tegra_rtc_irq,\r\ntegra_rtc_irq_handler, IRQF_TRIGGER_HIGH,\r\n"rtc alarm", &pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Unable to request interrupt for device (err=%d).\n",\r\nret);\r\ngoto err_dev_unreg;\r\n}\r\ndev_notice(&pdev->dev, "Tegra internal Real Time Clock\n");\r\nreturn 0;\r\nerr_dev_unreg:\r\nrtc_device_unregister(info->rtc_dev);\r\nreturn ret;\r\n}\r\nstatic int __devexit tegra_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_rtc_info *info = platform_get_drvdata(pdev);\r\nrtc_device_unregister(info->rtc_dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int tegra_rtc_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct tegra_rtc_info *info = platform_get_drvdata(pdev);\r\ntegra_rtc_wait_while_busy(dev);\r\nwritel(0xffffffff, info->rtc_base + TEGRA_RTC_REG_INTR_STATUS);\r\nwritel(TEGRA_RTC_INTR_STATUS_SEC_ALARM0,\r\ninfo->rtc_base + TEGRA_RTC_REG_INTR_MASK);\r\ndev_vdbg(dev, "alarm sec = %d\n",\r\nreadl(info->rtc_base + TEGRA_RTC_REG_SECONDS_ALARM0));\r\ndev_vdbg(dev, "Suspend (device_may_wakeup=%d) irq:%d\n",\r\ndevice_may_wakeup(dev), info->tegra_rtc_irq);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(info->tegra_rtc_irq);\r\nreturn 0;\r\n}\r\nstatic int tegra_rtc_resume(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct tegra_rtc_info *info = platform_get_drvdata(pdev);\r\ndev_vdbg(dev, "Resume (device_may_wakeup=%d)\n",\r\ndevice_may_wakeup(dev));\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(info->tegra_rtc_irq);\r\nreturn 0;\r\n}\r\nstatic void tegra_rtc_shutdown(struct platform_device *pdev)\r\n{\r\ndev_vdbg(&pdev->dev, "disabling interrupts.\n");\r\ntegra_rtc_alarm_irq_enable(&pdev->dev, 0);\r\n}\r\nstatic int __init tegra_rtc_init(void)\r\n{\r\nreturn platform_driver_probe(&tegra_rtc_driver, tegra_rtc_probe);\r\n}\r\nstatic void __exit tegra_rtc_exit(void)\r\n{\r\nplatform_driver_unregister(&tegra_rtc_driver);\r\n}
