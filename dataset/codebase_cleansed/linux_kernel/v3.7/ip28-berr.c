static inline void save_cache_tags(unsigned busaddr)\r\n{\r\nunsigned long addr = CAC_BASE | busaddr;\r\nint i;\r\ncache_tags.err_addr = addr;\r\naddr &= ~1L;\r\n#define tag cache_tags.tags[0]\r\ncache_op(Index_Load_Tag_S, addr);\r\ntag[0].lo = read_c0_taglo();\r\ntag[0].hi = read_c0_taghi();\r\ncache_op(Index_Load_Tag_S, addr | 1L);\r\ntag[1].lo = read_c0_taglo();\r\ntag[1].hi = read_c0_taghi();\r\n#undef tag\r\naddr &= (0xffL << 56) | ((1 << 12) - 1);\r\n#define tag cache_tags.tagd[i]\r\nfor (i = 0; i < 4; ++i, addr += (1 << 12)) {\r\ncache_op(Index_Load_Tag_D, addr);\r\ntag[0].lo = read_c0_taglo();\r\ntag[0].hi = read_c0_taghi();\r\ncache_op(Index_Load_Tag_D, addr | 1L);\r\ntag[1].lo = read_c0_taglo();\r\ntag[1].hi = read_c0_taghi();\r\n}\r\n#undef tag\r\naddr &= (0xffL << 56) | ((1 << 12) - 1);\r\n#define tag cache_tags.tagi[i]\r\nfor (i = 0; i < 4; ++i, addr += (1 << 12)) {\r\ncache_op(Index_Load_Tag_I, addr);\r\ntag[0].lo = read_c0_taglo();\r\ntag[0].hi = read_c0_taghi();\r\ncache_op(Index_Load_Tag_I, addr | 1L);\r\ntag[1].lo = read_c0_taglo();\r\ntag[1].hi = read_c0_taghi();\r\n}\r\n#undef tag\r\n}\r\nstatic void save_and_clear_buserr(void)\r\n{\r\nint i;\r\ncpu_err_addr = sgimc->cerr;\r\ncpu_err_stat = sgimc->cstat;\r\ngio_err_addr = sgimc->gerr;\r\ngio_err_stat = sgimc->gstat;\r\nextio_stat = sgioc->extio;\r\nhpc3_berr_stat = hpc3c0->bestat;\r\nhpc3.scsi[0].addr = (unsigned long)&hpc3c0->scsi_chan0;\r\nhpc3.scsi[0].ctrl = hpc3c0->scsi_chan0.ctrl;\r\nhpc3.scsi[0].cbp = hpc3c0->scsi_chan0.cbptr;\r\nhpc3.scsi[0].ndptr = hpc3c0->scsi_chan0.ndptr;\r\nhpc3.scsi[1].addr = (unsigned long)&hpc3c0->scsi_chan1;\r\nhpc3.scsi[1].ctrl = hpc3c0->scsi_chan1.ctrl;\r\nhpc3.scsi[1].cbp = hpc3c0->scsi_chan1.cbptr;\r\nhpc3.scsi[1].ndptr = hpc3c0->scsi_chan1.ndptr;\r\nhpc3.ethrx.addr = (unsigned long)&hpc3c0->ethregs.rx_cbptr;\r\nhpc3.ethrx.ctrl = hpc3c0->ethregs.rx_ctrl;\r\nhpc3.ethrx.cbp = hpc3c0->ethregs.rx_cbptr;\r\nhpc3.ethrx.ndptr = hpc3c0->ethregs.rx_ndptr;\r\nhpc3.ethtx.addr = (unsigned long)&hpc3c0->ethregs.tx_cbptr;\r\nhpc3.ethtx.ctrl = hpc3c0->ethregs.tx_ctrl;\r\nhpc3.ethtx.cbp = hpc3c0->ethregs.tx_cbptr;\r\nhpc3.ethtx.ndptr = hpc3c0->ethregs.tx_ndptr;\r\nfor (i = 0; i < 8; ++i) {\r\nhpc3.pbdma[i].addr = (unsigned long)&hpc3c0->pbdma[i];\r\nhpc3.pbdma[i].ctrl = hpc3c0->pbdma[i].pbdma_ctrl;\r\nhpc3.pbdma[i].cbp = hpc3c0->pbdma[i].pbdma_bptr;\r\nhpc3.pbdma[i].ndptr = hpc3c0->pbdma[i].pbdma_dptr;\r\n}\r\ni = 0;\r\nif (gio_err_stat & CPU_ERRMASK)\r\ni = gio_err_addr;\r\nif (cpu_err_stat & CPU_ERRMASK)\r\ni = cpu_err_addr;\r\nsave_cache_tags(i);\r\nsgimc->cstat = sgimc->gstat = 0;\r\n}\r\nstatic void print_cache_tags(void)\r\n{\r\nu32 scb, scw;\r\nint i;\r\nprintk(KERN_ERR "Cache tags @ %08x:\n", (unsigned)cache_tags.err_addr);\r\nscw = (cache_tags.err_addr >> 4) & 0x0fffff00;\r\nscb = cache_tags.err_addr & ((1 << 12) - 1) & ~((1 << 5) - 1);\r\nfor (i = 0; i < 4; ++i) {\r\nif ((cache_tags.tagd[i][0].lo & 0x0fffff00) != scw &&\r\n(cache_tags.tagd[i][1].lo & 0x0fffff00) != scw)\r\ncontinue;\r\nprintk(KERN_ERR\r\n"D: 0: %08x %08x, 1: %08x %08x (VA[13:5] %04x)\n",\r\ncache_tags.tagd[i][0].hi, cache_tags.tagd[i][0].lo,\r\ncache_tags.tagd[i][1].hi, cache_tags.tagd[i][1].lo,\r\nscb | (1 << 12)*i);\r\n}\r\nscb = cache_tags.err_addr & ((1 << 12) - 1) & ~((1 << 6) - 1);\r\nfor (i = 0; i < 4; ++i) {\r\nif ((cache_tags.tagi[i][0].lo & 0x0fffff00) != scw &&\r\n(cache_tags.tagi[i][1].lo & 0x0fffff00) != scw)\r\ncontinue;\r\nprintk(KERN_ERR\r\n"I: 0: %08x %08x, 1: %08x %08x (VA[13:6] %04x)\n",\r\ncache_tags.tagi[i][0].hi, cache_tags.tagi[i][0].lo,\r\ncache_tags.tagi[i][1].hi, cache_tags.tagi[i][1].lo,\r\nscb | (1 << 12)*i);\r\n}\r\ni = read_c0_config();\r\nscb = i & (1 << 13) ? 7:6;\r\nscw = ((i >> 16) & 7) + 19 - 1;\r\ni = ((1 << scw) - 1) & ~((1 << scb) - 1);\r\nprintk(KERN_ERR "S: 0: %08x %08x, 1: %08x %08x (PA[%u:%u] %05x)\n",\r\ncache_tags.tags[0][0].hi, cache_tags.tags[0][0].lo,\r\ncache_tags.tags[0][1].hi, cache_tags.tags[0][1].lo,\r\nscw-1, scb, i & (unsigned)cache_tags.err_addr);\r\n}\r\nstatic inline const char *cause_excode_text(int cause)\r\n{\r\nstatic const char *txt[32] =\r\n{ "Interrupt",\r\n"TLB modification",\r\n"TLB (load or instruction fetch)",\r\n"TLB (store)",\r\n"Address error (load or instruction fetch)",\r\n"Address error (store)",\r\n"Bus error (instruction fetch)",\r\n"Bus error (data: load or store)",\r\n"Syscall",\r\n"Breakpoint",\r\n"Reserved instruction",\r\n"Coprocessor unusable",\r\n"Arithmetic Overflow",\r\n"Trap",\r\n"14",\r\n"Floating-Point",\r\n"16", "17", "18", "19", "20", "21", "22",\r\n"Watch Hi/Lo",\r\n"24", "25", "26", "27", "28", "29", "30", "31",\r\n};\r\nreturn txt[(cause & 0x7c) >> 2];\r\n}\r\nstatic void print_buserr(const struct pt_regs *regs)\r\n{\r\nconst int field = 2 * sizeof(unsigned long);\r\nint error = 0;\r\nif (extio_stat & EXTIO_MC_BUSERR) {\r\nprintk(KERN_ERR "MC Bus Error\n");\r\nerror |= 1;\r\n}\r\nif (extio_stat & EXTIO_HPC3_BUSERR) {\r\nprintk(KERN_ERR "HPC3 Bus Error 0x%x:<id=0x%x,%s,lane=0x%x>\n",\r\nhpc3_berr_stat,\r\n(hpc3_berr_stat & HPC3_BESTAT_PIDMASK) >>\r\nHPC3_BESTAT_PIDSHIFT,\r\n(hpc3_berr_stat & HPC3_BESTAT_CTYPE) ? "PIO" : "DMA",\r\nhpc3_berr_stat & HPC3_BESTAT_BLMASK);\r\nerror |= 2;\r\n}\r\nif (extio_stat & EXTIO_EISA_BUSERR) {\r\nprintk(KERN_ERR "EISA Bus Error\n");\r\nerror |= 4;\r\n}\r\nif (cpu_err_stat & CPU_ERRMASK) {\r\nprintk(KERN_ERR "CPU error 0x%x<%s%s%s%s%s%s> @ 0x%08x\n",\r\ncpu_err_stat,\r\ncpu_err_stat & SGIMC_CSTAT_RD ? "RD " : "",\r\ncpu_err_stat & SGIMC_CSTAT_PAR ? "PAR " : "",\r\ncpu_err_stat & SGIMC_CSTAT_ADDR ? "ADDR " : "",\r\ncpu_err_stat & SGIMC_CSTAT_SYSAD_PAR ? "SYSAD " : "",\r\ncpu_err_stat & SGIMC_CSTAT_SYSCMD_PAR ? "SYSCMD " : "",\r\ncpu_err_stat & SGIMC_CSTAT_BAD_DATA ? "BAD_DATA " : "",\r\ncpu_err_addr);\r\nerror |= 8;\r\n}\r\nif (gio_err_stat & GIO_ERRMASK) {\r\nprintk(KERN_ERR "GIO error 0x%x:<%s%s%s%s%s%s%s%s> @ 0x%08x\n",\r\ngio_err_stat,\r\ngio_err_stat & SGIMC_GSTAT_RD ? "RD " : "",\r\ngio_err_stat & SGIMC_GSTAT_WR ? "WR " : "",\r\ngio_err_stat & SGIMC_GSTAT_TIME ? "TIME " : "",\r\ngio_err_stat & SGIMC_GSTAT_PROM ? "PROM " : "",\r\ngio_err_stat & SGIMC_GSTAT_ADDR ? "ADDR " : "",\r\ngio_err_stat & SGIMC_GSTAT_BC ? "BC " : "",\r\ngio_err_stat & SGIMC_GSTAT_PIO_RD ? "PIO_RD " : "",\r\ngio_err_stat & SGIMC_GSTAT_PIO_WR ? "PIO_WR " : "",\r\ngio_err_addr);\r\nerror |= 16;\r\n}\r\nif (!error)\r\nprintk(KERN_ERR "MC: Hmm, didn't find any error condition.\n");\r\nelse {\r\nprintk(KERN_ERR "CP0: config %08x, "\r\n"MC: cpuctrl0/1: %08x/%05x, giopar: %04x\n"\r\n"MC: cpu/gio_memacc: %08x/%05x, memcfg0/1: %08x/%08x\n",\r\nread_c0_config(),\r\nsgimc->cpuctrl0, sgimc->cpuctrl0, sgimc->giopar,\r\nsgimc->cmacc, sgimc->gmacc,\r\nsgimc->mconfig0, sgimc->mconfig1);\r\nprint_cache_tags();\r\n}\r\nprintk(KERN_ALERT "%s, epc == %0*lx, ra == %0*lx\n",\r\ncause_excode_text(regs->cp0_cause),\r\nfield, regs->cp0_epc, field, regs->regs[31]);\r\n}\r\nstatic int addr_is_ram(unsigned long addr, unsigned sz)\r\n{\r\nint i;\r\nfor (i = 0; i < boot_mem_map.nr_map; i++) {\r\nunsigned long a = boot_mem_map.map[i].addr;\r\nif (a <= addr && addr+sz <= a+boot_mem_map.map[i].size)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_microtlb(u32 hi, u32 lo, unsigned long vaddr)\r\n{\r\nvaddr &= 0x7fffffff;\r\nif ((lo & 2) && (vaddr >> 21) == ((hi<<1) >> 22)) {\r\nu32 ctl = sgimc->dma_ctrl;\r\nif (ctl & 1) {\r\nunsigned int pgsz = (ctl & 2) ? 14:12;\r\nunsigned long pte = (lo >> 6) << 12;\r\npte += 8*((vaddr >> pgsz) & 0x1ff);\r\nif (addr_is_ram(pte, 8)) {\r\nunsigned long a = *(unsigned long *)\r\nPHYS_TO_XKSEG_UNCACHED(pte);\r\na = (a & 0x3f) << 6;\r\na += vaddr & ((1 << pgsz) - 1);\r\nreturn (cpu_err_addr == a);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_vdma_memaddr(void)\r\n{\r\nif (cpu_err_stat & CPU_ERRMASK) {\r\nu32 a = sgimc->maddronly;\r\nif (!(sgimc->dma_ctrl & 0x100))\r\nreturn (cpu_err_addr == a);\r\nif (check_microtlb(sgimc->dtlb_hi0, sgimc->dtlb_lo0, a) ||\r\ncheck_microtlb(sgimc->dtlb_hi1, sgimc->dtlb_lo1, a) ||\r\ncheck_microtlb(sgimc->dtlb_hi2, sgimc->dtlb_lo2, a) ||\r\ncheck_microtlb(sgimc->dtlb_hi3, sgimc->dtlb_lo3, a))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_vdma_gioaddr(void)\r\n{\r\nif (gio_err_stat & GIO_ERRMASK) {\r\nu32 a = sgimc->gio_dma_trans;\r\na = (sgimc->gmaddronly & ~a) | (sgimc->gio_dma_sbits & a);\r\nreturn (gio_err_addr == a);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ip28_be_interrupt(const struct pt_regs *regs)\r\n{\r\nint i;\r\nsave_and_clear_buserr();\r\nif (regs->cp0_cause & CAUSEF_EXCCODE)\r\ngoto mips_be_fatal;\r\nif ((regs->cp0_cause & CAUSEF_IP6) != CAUSEF_IP6)\r\ngoto mips_be_fatal;\r\nif (extio_stat & (EXTIO_HPC3_BUSERR | EXTIO_EISA_BUSERR))\r\ngoto mips_be_fatal;\r\nif (cpu_err_stat & CPU_ERRMASK & ~SGIMC_CSTAT_ADDR)\r\ngoto mips_be_fatal;\r\nif (gio_err_stat & GIO_ERRMASK & ~SGIMC_GSTAT_TIME)\r\ngoto mips_be_fatal;\r\nfor (i = 0; i < sizeof(hpc3)/sizeof(struct hpc3_stat); ++i) {\r\nstruct hpc3_stat *hp = (struct hpc3_stat *)&hpc3 + i;\r\nif ((cpu_err_stat & CPU_ERRMASK) &&\r\n(cpu_err_addr == hp->ndptr || cpu_err_addr == hp->cbp))\r\nbreak;\r\nif ((gio_err_stat & GIO_ERRMASK) &&\r\n(gio_err_addr == hp->ndptr || gio_err_addr == hp->cbp))\r\nbreak;\r\n}\r\nif (i < sizeof(hpc3)/sizeof(struct hpc3_stat)) {\r\nstruct hpc3_stat *hp = (struct hpc3_stat *)&hpc3 + i;\r\nprintk(KERN_ERR "at DMA addresses: HPC3 @ %08lx:"\r\n" ctl %08x, ndp %08x, cbp %08x\n",\r\nCPHYSADDR(hp->addr), hp->ctrl, hp->ndptr, hp->cbp);\r\ngoto mips_be_fatal;\r\n}\r\nif (check_vdma_memaddr()) {\r\nprintk(KERN_ERR "at GIO DMA: mem address 0x%08x.\n",\r\nsgimc->maddronly);\r\ngoto mips_be_fatal;\r\n}\r\nif (check_vdma_gioaddr()) {\r\nprintk(KERN_ERR "at GIO DMA: gio address 0x%08x.\n",\r\nsgimc->gmaddronly);\r\ngoto mips_be_fatal;\r\n}\r\nif (debug_be_interrupt) {\r\nprint_buserr(regs);\r\nprintk(KERN_ERR "discarded!\n");\r\n}\r\nreturn MIPS_BE_DISCARD;\r\nmips_be_fatal:\r\nprint_buserr(regs);\r\nreturn MIPS_BE_FATAL;\r\n}\r\nvoid ip22_be_interrupt(int irq)\r\n{\r\nstruct pt_regs *regs = get_irq_regs();\r\ncount_be_interrupt++;\r\nif (ip28_be_interrupt(regs) != MIPS_BE_DISCARD) {\r\ndie_if_kernel("Oops", regs);\r\nforce_sig(SIGBUS, current);\r\n} else if (debug_be_interrupt)\r\nshow_regs((struct pt_regs *)regs);\r\n}\r\nstatic int ip28_be_handler(struct pt_regs *regs, int is_fixup)\r\n{\r\nif (is_fixup) {\r\ncount_be_is_fixup++;\r\nsave_and_clear_buserr();\r\nreturn MIPS_BE_FIXUP;\r\n}\r\ncount_be_handler++;\r\nreturn ip28_be_interrupt(regs);\r\n}\r\nvoid __init ip22_be_init(void)\r\n{\r\nboard_be_handler = ip28_be_handler;\r\n}\r\nint ip28_show_be_info(struct seq_file *m)\r\n{\r\nseq_printf(m, "IP28 be fixups\t\t: %u\n", count_be_is_fixup);\r\nseq_printf(m, "IP28 be interrupts\t: %u\n", count_be_interrupt);\r\nseq_printf(m, "IP28 be handler\t\t: %u\n", count_be_handler);\r\nreturn 0;\r\n}\r\nstatic int __init debug_be_setup(char *str)\r\n{\r\ndebug_be_interrupt++;\r\nreturn 1;\r\n}
