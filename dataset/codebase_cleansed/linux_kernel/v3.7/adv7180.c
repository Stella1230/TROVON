static v4l2_std_id adv7180_std_to_v4l2(u8 status1)\r\n{\r\nswitch (status1 & ADV7180_STATUS1_AUTOD_MASK) {\r\ncase ADV7180_STATUS1_AUTOD_NTSM_M_J:\r\nreturn V4L2_STD_NTSC;\r\ncase ADV7180_STATUS1_AUTOD_NTSC_4_43:\r\nreturn V4L2_STD_NTSC_443;\r\ncase ADV7180_STATUS1_AUTOD_PAL_M:\r\nreturn V4L2_STD_PAL_M;\r\ncase ADV7180_STATUS1_AUTOD_PAL_60:\r\nreturn V4L2_STD_PAL_60;\r\ncase ADV7180_STATUS1_AUTOD_PAL_B_G:\r\nreturn V4L2_STD_PAL;\r\ncase ADV7180_STATUS1_AUTOD_SECAM:\r\nreturn V4L2_STD_SECAM;\r\ncase ADV7180_STATUS1_AUTOD_PAL_COMB:\r\nreturn V4L2_STD_PAL_Nc | V4L2_STD_PAL_N;\r\ncase ADV7180_STATUS1_AUTOD_SECAM_525:\r\nreturn V4L2_STD_SECAM;\r\ndefault:\r\nreturn V4L2_STD_UNKNOWN;\r\n}\r\n}\r\nstatic int v4l2_std_to_adv7180(v4l2_std_id std)\r\n{\r\nif (std == V4L2_STD_PAL_60)\r\nreturn ADV7180_INPUT_CONTROL_PAL60;\r\nif (std == V4L2_STD_NTSC_443)\r\nreturn ADV7180_INPUT_CONTROL_NTSC_443;\r\nif (std == V4L2_STD_PAL_N)\r\nreturn ADV7180_INPUT_CONTROL_PAL_N;\r\nif (std == V4L2_STD_PAL_M)\r\nreturn ADV7180_INPUT_CONTROL_PAL_M;\r\nif (std == V4L2_STD_PAL_Nc)\r\nreturn ADV7180_INPUT_CONTROL_PAL_COMB_N;\r\nif (std & V4L2_STD_PAL)\r\nreturn ADV7180_INPUT_CONTROL_PAL_BG;\r\nif (std & V4L2_STD_NTSC)\r\nreturn ADV7180_INPUT_CONTROL_NTSC_M;\r\nif (std & V4L2_STD_SECAM)\r\nreturn ADV7180_INPUT_CONTROL_PAL_SECAM;\r\nreturn -EINVAL;\r\n}\r\nstatic u32 adv7180_status_to_v4l2(u8 status1)\r\n{\r\nif (!(status1 & ADV7180_STATUS1_IN_LOCK))\r\nreturn V4L2_IN_ST_NO_SIGNAL;\r\nreturn 0;\r\n}\r\nstatic int __adv7180_status(struct i2c_client *client, u32 *status,\r\nv4l2_std_id *std)\r\n{\r\nint status1 = i2c_smbus_read_byte_data(client, ADV7180_STATUS1_REG);\r\nif (status1 < 0)\r\nreturn status1;\r\nif (status)\r\n*status = adv7180_status_to_v4l2(status1);\r\nif (std)\r\n*std = adv7180_std_to_v4l2(status1);\r\nreturn 0;\r\n}\r\nstatic inline struct adv7180_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct adv7180_state, sd);\r\n}\r\nstatic int adv7180_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\nstruct adv7180_state *state = to_state(sd);\r\nint err = mutex_lock_interruptible(&state->mutex);\r\nif (err)\r\nreturn err;\r\nif (!state->autodetect || state->irq > 0)\r\n*std = state->curr_norm;\r\nelse\r\nerr = __adv7180_status(v4l2_get_subdevdata(sd), NULL, std);\r\nmutex_unlock(&state->mutex);\r\nreturn err;\r\n}\r\nstatic int adv7180_s_routing(struct v4l2_subdev *sd, u32 input,\r\nu32 output, u32 config)\r\n{\r\nstruct adv7180_state *state = to_state(sd);\r\nint ret = mutex_lock_interruptible(&state->mutex);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (ret)\r\nreturn ret;\r\nif ((input & ADV7180_INPUT_CONTROL_INSEL_MASK) != input)\r\ngoto out;\r\nret = i2c_smbus_read_byte_data(client, ADV7180_INPUT_CONTROL_REG);\r\nif (ret < 0)\r\ngoto out;\r\nret &= ~ADV7180_INPUT_CONTROL_INSEL_MASK;\r\nret = i2c_smbus_write_byte_data(client,\r\nADV7180_INPUT_CONTROL_REG, ret | input);\r\nstate->input = input;\r\nout:\r\nmutex_unlock(&state->mutex);\r\nreturn ret;\r\n}\r\nstatic int adv7180_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\nstruct adv7180_state *state = to_state(sd);\r\nint ret = mutex_lock_interruptible(&state->mutex);\r\nif (ret)\r\nreturn ret;\r\nret = __adv7180_status(v4l2_get_subdevdata(sd), status, NULL);\r\nmutex_unlock(&state->mutex);\r\nreturn ret;\r\n}\r\nstatic int adv7180_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_ADV7180, 0);\r\n}\r\nstatic int adv7180_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct adv7180_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret = mutex_lock_interruptible(&state->mutex);\r\nif (ret)\r\nreturn ret;\r\nif (std == V4L2_STD_ALL) {\r\nret =\r\ni2c_smbus_write_byte_data(client, ADV7180_INPUT_CONTROL_REG,\r\nADV7180_INPUT_CONTROL_AD_PAL_BG_NTSC_J_SECAM\r\n| state->input);\r\nif (ret < 0)\r\ngoto out;\r\n__adv7180_status(client, NULL, &state->curr_norm);\r\nstate->autodetect = true;\r\n} else {\r\nret = v4l2_std_to_adv7180(std);\r\nif (ret < 0)\r\ngoto out;\r\nret = i2c_smbus_write_byte_data(client,\r\nADV7180_INPUT_CONTROL_REG,\r\nret | state->input);\r\nif (ret < 0)\r\ngoto out;\r\nstate->curr_norm = std;\r\nstate->autodetect = false;\r\n}\r\nret = 0;\r\nout:\r\nmutex_unlock(&state->mutex);\r\nreturn ret;\r\n}\r\nstatic int adv7180_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_adv7180_sd(ctrl);\r\nstruct adv7180_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret = mutex_lock_interruptible(&state->mutex);\r\nint val;\r\nif (ret)\r\nreturn ret;\r\nval = ctrl->val;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nret = i2c_smbus_write_byte_data(client, ADV7180_BRI_REG, val);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nret = i2c_smbus_write_byte_data(client, ADV7180_HUE_REG, -val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nret = i2c_smbus_write_byte_data(client, ADV7180_CON_REG, val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nret = i2c_smbus_write_byte_data(client, ADV7180_SD_SAT_CB_REG,\r\nval);\r\nif (ret < 0)\r\nbreak;\r\nret = i2c_smbus_write_byte_data(client, ADV7180_SD_SAT_CR_REG,\r\nval);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&state->mutex);\r\nreturn ret;\r\n}\r\nstatic int adv7180_init_controls(struct adv7180_state *state)\r\n{\r\nv4l2_ctrl_handler_init(&state->ctrl_hdl, 4);\r\nv4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, ADV7180_BRI_MIN,\r\nADV7180_BRI_MAX, 1, ADV7180_BRI_DEF);\r\nv4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,\r\nV4L2_CID_CONTRAST, ADV7180_CON_MIN,\r\nADV7180_CON_MAX, 1, ADV7180_CON_DEF);\r\nv4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,\r\nV4L2_CID_SATURATION, ADV7180_SAT_MIN,\r\nADV7180_SAT_MAX, 1, ADV7180_SAT_DEF);\r\nv4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,\r\nV4L2_CID_HUE, ADV7180_HUE_MIN,\r\nADV7180_HUE_MAX, 1, ADV7180_HUE_DEF);\r\nstate->sd.ctrl_handler = &state->ctrl_hdl;\r\nif (state->ctrl_hdl.error) {\r\nint err = state->ctrl_hdl.error;\r\nv4l2_ctrl_handler_free(&state->ctrl_hdl);\r\nreturn err;\r\n}\r\nv4l2_ctrl_handler_setup(&state->ctrl_hdl);\r\nreturn 0;\r\n}\r\nstatic void adv7180_exit_controls(struct adv7180_state *state)\r\n{\r\nv4l2_ctrl_handler_free(&state->ctrl_hdl);\r\n}\r\nstatic void adv7180_work(struct work_struct *work)\r\n{\r\nstruct adv7180_state *state = container_of(work, struct adv7180_state,\r\nwork);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&state->sd);\r\nu8 isr3;\r\nmutex_lock(&state->mutex);\r\ni2c_smbus_write_byte_data(client, ADV7180_ADI_CTRL_REG,\r\nADV7180_ADI_CTRL_IRQ_SPACE);\r\nisr3 = i2c_smbus_read_byte_data(client, ADV7180_ISR3_ADI);\r\ni2c_smbus_write_byte_data(client, ADV7180_ICR3_ADI, isr3);\r\ni2c_smbus_write_byte_data(client, ADV7180_ADI_CTRL_REG, 0);\r\nif (isr3 & ADV7180_IRQ3_AD_CHANGE && state->autodetect)\r\n__adv7180_status(client, NULL, &state->curr_norm);\r\nmutex_unlock(&state->mutex);\r\nenable_irq(state->irq);\r\n}\r\nstatic irqreturn_t adv7180_irq(int irq, void *devid)\r\n{\r\nstruct adv7180_state *state = devid;\r\nschedule_work(&state->work);\r\ndisable_irq_nosync(state->irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int init_device(struct i2c_client *client, struct adv7180_state *state)\r\n{\r\nint ret;\r\nif (state->autodetect) {\r\nret =\r\ni2c_smbus_write_byte_data(client, ADV7180_INPUT_CONTROL_REG,\r\nADV7180_INPUT_CONTROL_AD_PAL_BG_NTSC_J_SECAM\r\n| state->input);\r\nif (ret < 0)\r\nreturn ret;\r\nret =\r\ni2c_smbus_write_byte_data(client,\r\nADV7180_AUTODETECT_ENABLE_REG,\r\nADV7180_AUTODETECT_DEFAULT);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\nret = v4l2_std_to_adv7180(state->curr_norm);\r\nif (ret < 0)\r\nreturn ret;\r\nret =\r\ni2c_smbus_write_byte_data(client, ADV7180_INPUT_CONTROL_REG,\r\nret | state->input);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = i2c_smbus_write_byte_data(client,\r\nADV7180_EXTENDED_OUTPUT_CONTROL_REG,\r\nADV7180_EXTENDED_OUTPUT_CONTROL_NTSCDIS);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client,\r\nADV7180_NTSC_V_BIT_END_REG,\r\nADV7180_NTSC_V_BIT_END_MANUAL_NVEND);\r\nif (ret < 0)\r\nreturn ret;\r\n__adv7180_status(client, NULL, &state->curr_norm);\r\nif (state->irq > 0) {\r\nret = request_irq(state->irq, adv7180_irq, 0, KBUILD_MODNAME,\r\nstate);\r\nif (ret)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, ADV7180_ADI_CTRL_REG,\r\nADV7180_ADI_CTRL_IRQ_SPACE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, ADV7180_ICONF1_ADI,\r\nADV7180_ICONF1_ACTIVE_LOW |\r\nADV7180_ICONF1_PSYNC_ONLY);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, ADV7180_IMR1_ADI, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, ADV7180_IMR2_ADI, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, ADV7180_IMR3_ADI,\r\nADV7180_IRQ3_AD_CHANGE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, ADV7180_IMR4_ADI, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(client, ADV7180_ADI_CTRL_REG,\r\n0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic __devinit int adv7180_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adv7180_state *state;\r\nstruct v4l2_subdev *sd;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_info(client, "chip found @ 0x%02x (%s)\n",\r\nclient->addr, client->adapter->name);\r\nstate = kzalloc(sizeof(struct adv7180_state), GFP_KERNEL);\r\nif (state == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nstate->irq = client->irq;\r\nINIT_WORK(&state->work, adv7180_work);\r\nmutex_init(&state->mutex);\r\nstate->autodetect = true;\r\nstate->input = 0;\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &adv7180_ops);\r\nret = adv7180_init_controls(state);\r\nif (ret)\r\ngoto err_unreg_subdev;\r\nret = init_device(client, state);\r\nif (ret)\r\ngoto err_free_ctrl;\r\nreturn 0;\r\nerr_free_ctrl:\r\nadv7180_exit_controls(state);\r\nerr_unreg_subdev:\r\nmutex_destroy(&state->mutex);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(state);\r\nerr:\r\nprintk(KERN_ERR KBUILD_MODNAME ": Failed to probe: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic __devexit int adv7180_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct adv7180_state *state = to_state(sd);\r\nif (state->irq > 0) {\r\nfree_irq(client->irq, state);\r\nif (cancel_work_sync(&state->work)) {\r\nenable_irq(state->irq);\r\n}\r\n}\r\nmutex_destroy(&state->mutex);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(to_state(sd));\r\nreturn 0;\r\n}\r\nstatic int adv7180_suspend(struct i2c_client *client, pm_message_t state)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, ADV7180_PWR_MAN_REG,\r\nADV7180_PWR_MAN_OFF);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int adv7180_resume(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct adv7180_state *state = to_state(sd);\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, ADV7180_PWR_MAN_REG,\r\nADV7180_PWR_MAN_ON);\r\nif (ret < 0)\r\nreturn ret;\r\nret = init_device(client, state);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}
