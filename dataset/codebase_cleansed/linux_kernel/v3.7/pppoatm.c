static inline struct pppoatm_vcc *atmvcc_to_pvcc(const struct atm_vcc *atmvcc)\r\n{\r\nreturn (struct pppoatm_vcc *) (atmvcc->user_back);\r\n}\r\nstatic inline struct pppoatm_vcc *chan_to_pvcc(const struct ppp_channel *chan)\r\n{\r\nreturn (struct pppoatm_vcc *) (chan->private);\r\n}\r\nstatic void pppoatm_wakeup_sender(unsigned long arg)\r\n{\r\nppp_output_wakeup((struct ppp_channel *) arg);\r\n}\r\nstatic void pppoatm_pop(struct atm_vcc *atmvcc, struct sk_buff *skb)\r\n{\r\nstruct pppoatm_vcc *pvcc = atmvcc_to_pvcc(atmvcc);\r\npvcc->old_pop(atmvcc, skb);\r\natomic_dec(&pvcc->inflight);\r\nif (test_and_clear_bit(BLOCKED, &pvcc->blocked))\r\ntasklet_schedule(&pvcc->wakeup_tasklet);\r\n}\r\nstatic void pppoatm_unassign_vcc(struct atm_vcc *atmvcc)\r\n{\r\nstruct pppoatm_vcc *pvcc;\r\npvcc = atmvcc_to_pvcc(atmvcc);\r\natmvcc->push = pvcc->old_push;\r\natmvcc->pop = pvcc->old_pop;\r\ntasklet_kill(&pvcc->wakeup_tasklet);\r\nppp_unregister_channel(&pvcc->chan);\r\natmvcc->user_back = NULL;\r\nkfree(pvcc);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic void pppoatm_push(struct atm_vcc *atmvcc, struct sk_buff *skb)\r\n{\r\nstruct pppoatm_vcc *pvcc = atmvcc_to_pvcc(atmvcc);\r\npr_debug("\n");\r\nif (skb == NULL) {\r\npr_debug("removing ATMPPP VCC %p\n", pvcc);\r\npppoatm_unassign_vcc(atmvcc);\r\natmvcc->push(atmvcc, NULL);\r\nreturn;\r\n}\r\natm_return(atmvcc, skb->truesize);\r\nswitch (pvcc->encaps) {\r\ncase e_llc:\r\nif (skb->len < LLC_LEN ||\r\nmemcmp(skb->data, pppllc, LLC_LEN))\r\ngoto error;\r\nskb_pull(skb, LLC_LEN);\r\nbreak;\r\ncase e_autodetect:\r\nif (pvcc->chan.ppp == NULL) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (skb->len >= sizeof(pppllc) &&\r\n!memcmp(skb->data, pppllc, sizeof(pppllc))) {\r\npvcc->encaps = e_llc;\r\nskb_pull(skb, LLC_LEN);\r\nbreak;\r\n}\r\nif (skb->len >= (sizeof(pppllc) - LLC_LEN) &&\r\n!memcmp(skb->data, &pppllc[LLC_LEN],\r\nsizeof(pppllc) - LLC_LEN)) {\r\npvcc->encaps = e_vc;\r\npvcc->chan.mtu += LLC_LEN;\r\nbreak;\r\n}\r\npr_debug("Couldn't autodetect yet (skb: %02X %02X %02X %02X %02X %02X)\n",\r\nskb->data[0], skb->data[1], skb->data[2],\r\nskb->data[3], skb->data[4], skb->data[5]);\r\ngoto error;\r\ncase e_vc:\r\nbreak;\r\n}\r\nppp_input(&pvcc->chan, skb);\r\nreturn;\r\nerror:\r\nkfree_skb(skb);\r\nppp_input_error(&pvcc->chan, 0);\r\n}\r\nstatic inline int pppoatm_may_send(struct pppoatm_vcc *pvcc, int size)\r\n{\r\nif (atm_may_send(pvcc->atmvcc, size) &&\r\natomic_inc_not_zero_hint(&pvcc->inflight, NONE_INFLIGHT))\r\nreturn 1;\r\ntest_and_set_bit(BLOCKED, &pvcc->blocked);\r\nif (atm_may_send(pvcc->atmvcc, size) &&\r\natomic_inc_not_zero(&pvcc->inflight))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int pppoatm_send(struct ppp_channel *chan, struct sk_buff *skb)\r\n{\r\nstruct pppoatm_vcc *pvcc = chan_to_pvcc(chan);\r\nATM_SKB(skb)->vcc = pvcc->atmvcc;\r\npr_debug("(skb=0x%p, vcc=0x%p)\n", skb, pvcc->atmvcc);\r\nif (skb->data[0] == '\0' && (pvcc->flags & SC_COMP_PROT))\r\n(void) skb_pull(skb, 1);\r\nswitch (pvcc->encaps) {\r\ncase e_llc:\r\nif (skb_headroom(skb) < LLC_LEN) {\r\nstruct sk_buff *n;\r\nn = skb_realloc_headroom(skb, LLC_LEN);\r\nif (n != NULL &&\r\n!pppoatm_may_send(pvcc, n->truesize)) {\r\nkfree_skb(n);\r\ngoto nospace;\r\n}\r\nconsume_skb(skb);\r\nskb = n;\r\nif (skb == NULL)\r\nreturn DROP_PACKET;\r\n} else if (!pppoatm_may_send(pvcc, skb->truesize))\r\ngoto nospace;\r\nmemcpy(skb_push(skb, LLC_LEN), pppllc, LLC_LEN);\r\nbreak;\r\ncase e_vc:\r\nif (!pppoatm_may_send(pvcc, skb->truesize))\r\ngoto nospace;\r\nbreak;\r\ncase e_autodetect:\r\npr_debug("Trying to send without setting encaps!\n");\r\nkfree_skb(skb);\r\nreturn 1;\r\n}\r\natomic_add(skb->truesize, &sk_atm(ATM_SKB(skb)->vcc)->sk_wmem_alloc);\r\nATM_SKB(skb)->atm_options = ATM_SKB(skb)->vcc->atm_options;\r\npr_debug("atm_skb(%p)->vcc(%p)->dev(%p)\n",\r\nskb, ATM_SKB(skb)->vcc, ATM_SKB(skb)->vcc->dev);\r\nreturn ATM_SKB(skb)->vcc->send(ATM_SKB(skb)->vcc, skb)\r\n? DROP_PACKET : 1;\r\nnospace:\r\nif ((pvcc->flags & SC_COMP_PROT) && skb_headroom(skb) > 0 &&\r\nskb->data[-1] == '\0')\r\n(void) skb_push(skb, 1);\r\nreturn 0;\r\n}\r\nstatic int pppoatm_devppp_ioctl(struct ppp_channel *chan, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase PPPIOCGFLAGS:\r\nreturn put_user(chan_to_pvcc(chan)->flags, (int __user *) arg)\r\n? -EFAULT : 0;\r\ncase PPPIOCSFLAGS:\r\nreturn get_user(chan_to_pvcc(chan)->flags, (int __user *) arg)\r\n? -EFAULT : 0;\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic int pppoatm_assign_vcc(struct atm_vcc *atmvcc, void __user *arg)\r\n{\r\nstruct atm_backend_ppp be;\r\nstruct pppoatm_vcc *pvcc;\r\nint err;\r\nstatic const DECLARE_TASKLET(tasklet_proto, pppoatm_wakeup_sender, 0);\r\nif (copy_from_user(&be, arg, sizeof be))\r\nreturn -EFAULT;\r\nif (be.encaps != PPPOATM_ENCAPS_AUTODETECT &&\r\nbe.encaps != PPPOATM_ENCAPS_VC && be.encaps != PPPOATM_ENCAPS_LLC)\r\nreturn -EINVAL;\r\npvcc = kzalloc(sizeof(*pvcc), GFP_KERNEL);\r\nif (pvcc == NULL)\r\nreturn -ENOMEM;\r\npvcc->atmvcc = atmvcc;\r\natomic_set(&pvcc->inflight, NONE_INFLIGHT);\r\npvcc->old_push = atmvcc->push;\r\npvcc->old_pop = atmvcc->pop;\r\npvcc->encaps = (enum pppoatm_encaps) be.encaps;\r\npvcc->chan.private = pvcc;\r\npvcc->chan.ops = &pppoatm_ops;\r\npvcc->chan.mtu = atmvcc->qos.txtp.max_sdu - PPP_HDRLEN -\r\n(be.encaps == e_vc ? 0 : LLC_LEN);\r\npvcc->wakeup_tasklet = tasklet_proto;\r\npvcc->wakeup_tasklet.data = (unsigned long) &pvcc->chan;\r\nerr = ppp_register_channel(&pvcc->chan);\r\nif (err != 0) {\r\nkfree(pvcc);\r\nreturn err;\r\n}\r\natmvcc->user_back = pvcc;\r\natmvcc->push = pppoatm_push;\r\natmvcc->pop = pppoatm_pop;\r\n__module_get(THIS_MODULE);\r\nvcc_process_recv_queue(atmvcc);\r\nreturn 0;\r\n}\r\nstatic int pppoatm_ioctl(struct socket *sock, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct atm_vcc *atmvcc = ATM_SD(sock);\r\nvoid __user *argp = (void __user *)arg;\r\nif (cmd != ATM_SETBACKEND && atmvcc->push != pppoatm_push)\r\nreturn -ENOIOCTLCMD;\r\nswitch (cmd) {\r\ncase ATM_SETBACKEND: {\r\natm_backend_t b;\r\nif (get_user(b, (atm_backend_t __user *) argp))\r\nreturn -EFAULT;\r\nif (b != ATM_BACKEND_PPP)\r\nreturn -ENOIOCTLCMD;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nreturn pppoatm_assign_vcc(atmvcc, argp);\r\n}\r\ncase PPPIOCGCHAN:\r\nreturn put_user(ppp_channel_index(&atmvcc_to_pvcc(atmvcc)->\r\nchan), (int __user *) argp) ? -EFAULT : 0;\r\ncase PPPIOCGUNIT:\r\nreturn put_user(ppp_unit_number(&atmvcc_to_pvcc(atmvcc)->\r\nchan), (int __user *) argp) ? -EFAULT : 0;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int __init pppoatm_init(void)\r\n{\r\nregister_atm_ioctl(&pppoatm_ioctl_ops);\r\nreturn 0;\r\n}\r\nstatic void __exit pppoatm_exit(void)\r\n{\r\nderegister_atm_ioctl(&pppoatm_ioctl_ops);\r\n}
