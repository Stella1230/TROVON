static void battery_status_changed(void)\r\n{\r\nstruct power_supply *psy = power_supply_get_by_name("olpc-battery");\r\nif (psy) {\r\npower_supply_changed(psy);\r\nput_device(psy->dev);\r\n}\r\n}\r\nstatic void ac_status_changed(void)\r\n{\r\nstruct power_supply *psy = power_supply_get_by_name("olpc-ac");\r\nif (psy) {\r\npower_supply_changed(psy);\r\nput_device(psy->dev);\r\n}\r\n}\r\nstatic void send_ebook_state(void)\r\n{\r\nunsigned char state;\r\nif (olpc_ec_cmd(EC_READ_EB_MODE, NULL, 0, &state, 1)) {\r\npr_err(PFX "failed to get ebook state\n");\r\nreturn;\r\n}\r\nif (!!test_bit(SW_TABLET_MODE, ebook_switch_idev->sw) == state)\r\nreturn;\r\ninput_report_switch(ebook_switch_idev, SW_TABLET_MODE, state);\r\ninput_sync(ebook_switch_idev);\r\npm_wakeup_event(&ebook_switch_idev->dev, 0);\r\n}\r\nstatic void flip_lid_inverter(void)\r\n{\r\nif (lid_inverted)\r\ncs5535_gpio_clear(OLPC_GPIO_LID, GPIO_INPUT_INVERT);\r\nelse\r\ncs5535_gpio_set(OLPC_GPIO_LID, GPIO_INPUT_INVERT);\r\nlid_inverted = !lid_inverted;\r\n}\r\nstatic void detect_lid_state(void)\r\n{\r\nint state;\r\nstate = cs5535_gpio_isset(OLPC_GPIO_LID, GPIO_READ_BACK);\r\nlid_open = !state ^ !lid_inverted;\r\nif (!state)\r\nreturn;\r\nflip_lid_inverter();\r\n}\r\nstatic void send_lid_state(void)\r\n{\r\nif (!!test_bit(SW_LID, lid_switch_idev->sw) == !lid_open)\r\nreturn;\r\ninput_report_switch(lid_switch_idev, SW_LID, !lid_open);\r\ninput_sync(lid_switch_idev);\r\npm_wakeup_event(&lid_switch_idev->dev, 0);\r\n}\r\nstatic ssize_t lid_wake_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst char *mode = lid_wake_mode_names[lid_wake_mode];\r\nreturn sprintf(buf, "%s\n", mode);\r\n}\r\nstatic ssize_t lid_wake_mode_set(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(lid_wake_mode_names); i++) {\r\nconst char *mode = lid_wake_mode_names[i];\r\nif (strlen(mode) != count || strncasecmp(mode, buf, count))\r\ncontinue;\r\nlid_wake_mode = i;\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void process_sci_queue(bool propagate_events)\r\n{\r\nint r;\r\nu16 data;\r\ndo {\r\nr = olpc_ec_sci_query(&data);\r\nif (r || !data)\r\nbreak;\r\npr_debug(PFX "SCI 0x%x received\n", data);\r\nswitch (data) {\r\ncase EC_SCI_SRC_BATERR:\r\ncase EC_SCI_SRC_BATSOC:\r\ncase EC_SCI_SRC_BATTERY:\r\ncase EC_SCI_SRC_BATCRIT:\r\nbattery_status_changed();\r\nbreak;\r\ncase EC_SCI_SRC_ACPWR:\r\nac_status_changed();\r\nbreak;\r\n}\r\nif (data == EC_SCI_SRC_EBOOK && propagate_events)\r\nsend_ebook_state();\r\n} while (data);\r\nif (r)\r\npr_err(PFX "Failed to clear SCI queue");\r\n}\r\nstatic void process_sci_queue_work(struct work_struct *work)\r\n{\r\nprocess_sci_queue(true);\r\n}\r\nstatic irqreturn_t xo1_sci_intr(int irq, void *dev_id)\r\n{\r\nstruct platform_device *pdev = dev_id;\r\nu32 sts;\r\nu32 gpe;\r\nsts = inl(acpi_base + CS5536_PM1_STS);\r\noutl(sts | 0xffff, acpi_base + CS5536_PM1_STS);\r\ngpe = inl(acpi_base + CS5536_PM_GPE0_STS);\r\noutl(0xffffffff, acpi_base + CS5536_PM_GPE0_STS);\r\ndev_dbg(&pdev->dev, "sts %x gpe %x\n", sts, gpe);\r\nif (sts & CS5536_PWRBTN_FLAG) {\r\nif (!(sts & CS5536_WAK_FLAG)) {\r\ninput_report_key(power_button_idev, KEY_POWER, 1);\r\ninput_sync(power_button_idev);\r\ninput_report_key(power_button_idev, KEY_POWER, 0);\r\ninput_sync(power_button_idev);\r\n}\r\npm_wakeup_event(&power_button_idev->dev, 0);\r\n}\r\nif ((sts & (CS5536_RTC_FLAG | CS5536_WAK_FLAG)) ==\r\n(CS5536_RTC_FLAG | CS5536_WAK_FLAG)) {\r\nstruct device *rtc = bus_find_device_by_name(\r\n&platform_bus_type, NULL, "rtc_cmos");\r\nif (rtc) {\r\npm_wakeup_event(rtc, 0);\r\nput_device(rtc);\r\n}\r\n}\r\nif (gpe & CS5536_GPIOM7_PME_FLAG) {\r\ncs5535_gpio_set(OLPC_GPIO_ECSCI, GPIO_NEGATIVE_EDGE_STS);\r\nschedule_work(&sci_work);\r\n}\r\ncs5535_gpio_set(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_STS);\r\ncs5535_gpio_set(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_STS);\r\ndetect_lid_state();\r\nsend_lid_state();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int xo1_sci_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nif (device_may_wakeup(&power_button_idev->dev))\r\nolpc_xo1_pm_wakeup_set(CS5536_PM_PWRBTN);\r\nelse\r\nolpc_xo1_pm_wakeup_clear(CS5536_PM_PWRBTN);\r\nif (device_may_wakeup(&ebook_switch_idev->dev))\r\nolpc_ec_wakeup_set(EC_SCI_SRC_EBOOK);\r\nelse\r\nolpc_ec_wakeup_clear(EC_SCI_SRC_EBOOK);\r\nif (!device_may_wakeup(&lid_switch_idev->dev)) {\r\ncs5535_gpio_clear(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);\r\n} else if ((lid_open && lid_wake_mode == LID_WAKE_OPEN) ||\r\n(!lid_open && lid_wake_mode == LID_WAKE_CLOSE)) {\r\nflip_lid_inverter();\r\ncs5535_gpio_set(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_STS);\r\ncs5535_gpio_set(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_STS);\r\ncs5535_gpio_set(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xo1_sci_resume(struct platform_device *pdev)\r\n{\r\ndetect_lid_state();\r\nsend_lid_state();\r\ncs5535_gpio_set(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);\r\nolpc_ec_mask_write(EC_SCI_SRC_ALL);\r\nbattery_status_changed();\r\nac_status_changed();\r\nreturn 0;\r\n}\r\nstatic int __devinit setup_sci_interrupt(struct platform_device *pdev)\r\n{\r\nu32 lo, hi;\r\nu32 sts;\r\nint r;\r\nrdmsr(0x51400020, lo, hi);\r\nsci_irq = (lo >> 20) & 15;\r\nif (sci_irq) {\r\ndev_info(&pdev->dev, "SCI is mapped to IRQ %d\n", sci_irq);\r\n} else {\r\ndev_info(&pdev->dev, "SCI unmapped. Mapping to IRQ 3\n");\r\nsci_irq = 3;\r\nlo |= 0x00300000;\r\nwrmsrl(0x51400020, lo);\r\n}\r\nif (sci_irq < 8) {\r\nlo = inb(CS5536_PIC_INT_SEL1);\r\nlo |= 1 << sci_irq;\r\noutb(lo, CS5536_PIC_INT_SEL1);\r\n} else {\r\nlo = inb(CS5536_PIC_INT_SEL2);\r\nlo |= 1 << (sci_irq - 8);\r\noutb(lo, CS5536_PIC_INT_SEL2);\r\n}\r\nsts = inl(acpi_base + CS5536_PM1_STS);\r\noutl(((CS5536_PM_PWRBTN | CS5536_PM_RTC) << 16) | 0xffff,\r\nacpi_base + CS5536_PM1_STS);\r\nr = request_irq(sci_irq, xo1_sci_intr, 0, DRV_NAME, pdev);\r\nif (r)\r\ndev_err(&pdev->dev, "can't request interrupt\n");\r\nreturn r;\r\n}\r\nstatic int __devinit setup_ec_sci(void)\r\n{\r\nint r;\r\nr = gpio_request(OLPC_GPIO_ECSCI, "OLPC-ECSCI");\r\nif (r)\r\nreturn r;\r\ngpio_direction_input(OLPC_GPIO_ECSCI);\r\ncs5535_gpio_set(OLPC_GPIO_ECSCI, GPIO_NEGATIVE_EDGE_STS);\r\ncs5535_gpio_set(OLPC_GPIO_ECSCI, GPIO_POSITIVE_EDGE_STS);\r\ncs5535_gpio_set(OLPC_GPIO_ECSCI, GPIO_EVENTS_ENABLE);\r\ncs5535_gpio_setup_event(OLPC_GPIO_ECSCI, 7, 1);\r\ncs5535_pic_unreqz_select_high(7, sci_irq);\r\nreturn 0;\r\n}\r\nstatic void free_ec_sci(void)\r\n{\r\ngpio_free(OLPC_GPIO_ECSCI);\r\n}\r\nstatic int __devinit setup_lid_events(void)\r\n{\r\nint r;\r\nr = gpio_request(OLPC_GPIO_LID, "OLPC-LID");\r\nif (r)\r\nreturn r;\r\ngpio_direction_input(OLPC_GPIO_LID);\r\ncs5535_gpio_clear(OLPC_GPIO_LID, GPIO_INPUT_INVERT);\r\nlid_inverted = 0;\r\ncs5535_gpio_clear(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);\r\ncs5535_gpio_clear(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_EN);\r\ncs5535_gpio_clear(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_EN);\r\ncs5535_gpio_set(OLPC_GPIO_LID, GPIO_NEGATIVE_EDGE_STS);\r\ncs5535_gpio_set(OLPC_GPIO_LID, GPIO_POSITIVE_EDGE_STS);\r\ncs5535_gpio_setup_event(OLPC_GPIO_LID, 6, 1);\r\ncs5535_gpio_set_irq(6, sci_irq);\r\ncs5535_gpio_set(OLPC_GPIO_LID, GPIO_EVENTS_ENABLE);\r\nreturn 0;\r\n}\r\nstatic void free_lid_events(void)\r\n{\r\ngpio_free(OLPC_GPIO_LID);\r\n}\r\nstatic int __devinit setup_power_button(struct platform_device *pdev)\r\n{\r\nint r;\r\npower_button_idev = input_allocate_device();\r\nif (!power_button_idev)\r\nreturn -ENOMEM;\r\npower_button_idev->name = "Power Button";\r\npower_button_idev->phys = DRV_NAME "/input0";\r\nset_bit(EV_KEY, power_button_idev->evbit);\r\nset_bit(KEY_POWER, power_button_idev->keybit);\r\npower_button_idev->dev.parent = &pdev->dev;\r\ndevice_init_wakeup(&power_button_idev->dev, 1);\r\nr = input_register_device(power_button_idev);\r\nif (r) {\r\ndev_err(&pdev->dev, "failed to register power button: %d\n", r);\r\ninput_free_device(power_button_idev);\r\n}\r\nreturn r;\r\n}\r\nstatic void free_power_button(void)\r\n{\r\ninput_unregister_device(power_button_idev);\r\ninput_free_device(power_button_idev);\r\n}\r\nstatic int __devinit setup_ebook_switch(struct platform_device *pdev)\r\n{\r\nint r;\r\nebook_switch_idev = input_allocate_device();\r\nif (!ebook_switch_idev)\r\nreturn -ENOMEM;\r\nebook_switch_idev->name = "EBook Switch";\r\nebook_switch_idev->phys = DRV_NAME "/input1";\r\nset_bit(EV_SW, ebook_switch_idev->evbit);\r\nset_bit(SW_TABLET_MODE, ebook_switch_idev->swbit);\r\nebook_switch_idev->dev.parent = &pdev->dev;\r\ndevice_set_wakeup_capable(&ebook_switch_idev->dev, true);\r\nr = input_register_device(ebook_switch_idev);\r\nif (r) {\r\ndev_err(&pdev->dev, "failed to register ebook switch: %d\n", r);\r\ninput_free_device(ebook_switch_idev);\r\n}\r\nreturn r;\r\n}\r\nstatic void free_ebook_switch(void)\r\n{\r\ninput_unregister_device(ebook_switch_idev);\r\ninput_free_device(ebook_switch_idev);\r\n}\r\nstatic int __devinit setup_lid_switch(struct platform_device *pdev)\r\n{\r\nint r;\r\nlid_switch_idev = input_allocate_device();\r\nif (!lid_switch_idev)\r\nreturn -ENOMEM;\r\nlid_switch_idev->name = "Lid Switch";\r\nlid_switch_idev->phys = DRV_NAME "/input2";\r\nset_bit(EV_SW, lid_switch_idev->evbit);\r\nset_bit(SW_LID, lid_switch_idev->swbit);\r\nlid_switch_idev->dev.parent = &pdev->dev;\r\ndevice_set_wakeup_capable(&lid_switch_idev->dev, true);\r\nr = input_register_device(lid_switch_idev);\r\nif (r) {\r\ndev_err(&pdev->dev, "failed to register lid switch: %d\n", r);\r\ngoto err_register;\r\n}\r\nr = device_create_file(&lid_switch_idev->dev, &dev_attr_lid_wake_mode);\r\nif (r) {\r\ndev_err(&pdev->dev, "failed to create wake mode attr: %d\n", r);\r\ngoto err_create_attr;\r\n}\r\nreturn 0;\r\nerr_create_attr:\r\ninput_unregister_device(lid_switch_idev);\r\nerr_register:\r\ninput_free_device(lid_switch_idev);\r\nreturn r;\r\n}\r\nstatic void free_lid_switch(void)\r\n{\r\ndevice_remove_file(&lid_switch_idev->dev, &dev_attr_lid_wake_mode);\r\ninput_unregister_device(lid_switch_idev);\r\ninput_free_device(lid_switch_idev);\r\n}\r\nstatic int __devinit xo1_sci_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint r;\r\nif (!machine_is_olpc())\r\nreturn -ENODEV;\r\nr = mfd_cell_enable(pdev);\r\nif (r)\r\nreturn r;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "can't fetch device resource info\n");\r\nreturn -EIO;\r\n}\r\nacpi_base = res->start;\r\nr = setup_power_button(pdev);\r\nif (r)\r\nreturn r;\r\nr = setup_ebook_switch(pdev);\r\nif (r)\r\ngoto err_ebook;\r\nr = setup_lid_switch(pdev);\r\nif (r)\r\ngoto err_lid;\r\nr = setup_lid_events();\r\nif (r)\r\ngoto err_lidevt;\r\nr = setup_ec_sci();\r\nif (r)\r\ngoto err_ecsci;\r\noutl(CS5536_GPIOM6_PME_EN | CS5536_GPIOM7_PME_EN,\r\nacpi_base + CS5536_PM_GPE0_EN);\r\noutl(0xffffffff, acpi_base + CS5536_PM_GPE0_STS);\r\nprocess_sci_queue(false);\r\nsend_ebook_state();\r\ndetect_lid_state();\r\nsend_lid_state();\r\nr = setup_sci_interrupt(pdev);\r\nif (r)\r\ngoto err_sci;\r\nolpc_ec_mask_write(EC_SCI_SRC_ALL);\r\nreturn r;\r\nerr_sci:\r\nfree_ec_sci();\r\nerr_ecsci:\r\nfree_lid_events();\r\nerr_lidevt:\r\nfree_lid_switch();\r\nerr_lid:\r\nfree_ebook_switch();\r\nerr_ebook:\r\nfree_power_button();\r\nreturn r;\r\n}\r\nstatic int __devexit xo1_sci_remove(struct platform_device *pdev)\r\n{\r\nmfd_cell_disable(pdev);\r\nfree_irq(sci_irq, pdev);\r\ncancel_work_sync(&sci_work);\r\nfree_ec_sci();\r\nfree_lid_events();\r\nfree_lid_switch();\r\nfree_ebook_switch();\r\nfree_power_button();\r\nacpi_base = 0;\r\nreturn 0;\r\n}\r\nstatic int __init xo1_sci_init(void)\r\n{\r\nreturn platform_driver_register(&xo1_sci_driver);\r\n}
