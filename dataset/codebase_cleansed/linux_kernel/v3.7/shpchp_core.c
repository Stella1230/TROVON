static void release_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\nkfree(slot->hotplug_slot->info);\r\nkfree(slot->hotplug_slot);\r\nkfree(slot);\r\n}\r\nstatic int init_slots(struct controller *ctrl)\r\n{\r\nstruct slot *slot;\r\nstruct hotplug_slot *hotplug_slot;\r\nstruct hotplug_slot_info *info;\r\nchar name[SLOT_NAME_SIZE];\r\nint retval;\r\nint i;\r\nfor (i = 0; i < ctrl->num_slots; i++) {\r\nslot = kzalloc(sizeof(*slot), GFP_KERNEL);\r\nif (!slot) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nhotplug_slot = kzalloc(sizeof(*hotplug_slot), GFP_KERNEL);\r\nif (!hotplug_slot) {\r\nretval = -ENOMEM;\r\ngoto error_slot;\r\n}\r\nslot->hotplug_slot = hotplug_slot;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\nretval = -ENOMEM;\r\ngoto error_hpslot;\r\n}\r\nhotplug_slot->info = info;\r\nslot->hp_slot = i;\r\nslot->ctrl = ctrl;\r\nslot->bus = ctrl->pci_dev->subordinate->number;\r\nslot->device = ctrl->slot_device_offset + i;\r\nslot->hpc_ops = ctrl->hpc_ops;\r\nslot->number = ctrl->first_slot + (ctrl->slot_num_inc * i);\r\nmutex_init(&slot->lock);\r\nINIT_DELAYED_WORK(&slot->work, shpchp_queue_pushbutton_work);\r\nhotplug_slot->private = slot;\r\nhotplug_slot->release = &release_slot;\r\nsnprintf(name, SLOT_NAME_SIZE, "%d", slot->number);\r\nhotplug_slot->ops = &shpchp_hotplug_slot_ops;\r\nctrl_dbg(ctrl, "Registering domain:bus:dev=%04x:%02x:%02x "\r\n"hp_slot=%x sun=%x slot_device_offset=%x\n",\r\npci_domain_nr(ctrl->pci_dev->subordinate),\r\nslot->bus, slot->device, slot->hp_slot, slot->number,\r\nctrl->slot_device_offset);\r\nretval = pci_hp_register(slot->hotplug_slot,\r\nctrl->pci_dev->subordinate, slot->device, name);\r\nif (retval) {\r\nctrl_err(ctrl, "pci_hp_register failed with error %d\n",\r\nretval);\r\ngoto error_info;\r\n}\r\nget_power_status(hotplug_slot, &info->power_status);\r\nget_attention_status(hotplug_slot, &info->attention_status);\r\nget_latch_status(hotplug_slot, &info->latch_status);\r\nget_adapter_status(hotplug_slot, &info->adapter_status);\r\nlist_add(&slot->slot_list, &ctrl->slot_list);\r\n}\r\nreturn 0;\r\nerror_info:\r\nkfree(info);\r\nerror_hpslot:\r\nkfree(hotplug_slot);\r\nerror_slot:\r\nkfree(slot);\r\nerror:\r\nreturn retval;\r\n}\r\nvoid cleanup_slots(struct controller *ctrl)\r\n{\r\nstruct list_head *tmp;\r\nstruct list_head *next;\r\nstruct slot *slot;\r\nlist_for_each_safe(tmp, next, &ctrl->slot_list) {\r\nslot = list_entry(tmp, struct slot, slot_list);\r\nlist_del(&slot->slot_list);\r\ncancel_delayed_work(&slot->work);\r\nflush_workqueue(shpchp_wq);\r\nflush_workqueue(shpchp_ordered_wq);\r\npci_hp_deregister(slot->hotplug_slot);\r\n}\r\n}\r\nstatic int set_attention_status (struct hotplug_slot *hotplug_slot, u8 status)\r\n{\r\nstruct slot *slot = get_slot(hotplug_slot);\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\nhotplug_slot->info->attention_status = status;\r\nslot->hpc_ops->set_attention_status(slot, status);\r\nreturn 0;\r\n}\r\nstatic int enable_slot (struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = get_slot(hotplug_slot);\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\nreturn shpchp_sysfs_enable_slot(slot);\r\n}\r\nstatic int disable_slot (struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = get_slot(hotplug_slot);\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\nreturn shpchp_sysfs_disable_slot(slot);\r\n}\r\nstatic int get_power_status (struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = get_slot(hotplug_slot);\r\nint retval;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\nretval = slot->hpc_ops->get_power_status(slot, value);\r\nif (retval < 0)\r\n*value = hotplug_slot->info->power_status;\r\nreturn 0;\r\n}\r\nstatic int get_attention_status (struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = get_slot(hotplug_slot);\r\nint retval;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\nretval = slot->hpc_ops->get_attention_status(slot, value);\r\nif (retval < 0)\r\n*value = hotplug_slot->info->attention_status;\r\nreturn 0;\r\n}\r\nstatic int get_latch_status (struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = get_slot(hotplug_slot);\r\nint retval;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\nretval = slot->hpc_ops->get_latch_status(slot, value);\r\nif (retval < 0)\r\n*value = hotplug_slot->info->latch_status;\r\nreturn 0;\r\n}\r\nstatic int get_adapter_status (struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = get_slot(hotplug_slot);\r\nint retval;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\nretval = slot->hpc_ops->get_adapter_status(slot, value);\r\nif (retval < 0)\r\n*value = hotplug_slot->info->adapter_status;\r\nreturn 0;\r\n}\r\nstatic int is_shpc_capable(struct pci_dev *dev)\r\n{\r\nif (dev->vendor == PCI_VENDOR_ID_AMD &&\r\ndev->device == PCI_DEVICE_ID_AMD_GOLAM_7450)\r\nreturn 1;\r\nif (!pci_find_capability(dev, PCI_CAP_ID_SHPC))\r\nreturn 0;\r\nif (get_hp_hw_control_from_firmware(dev))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int shpc_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint rc;\r\nstruct controller *ctrl;\r\nif (!is_shpc_capable(pdev))\r\nreturn -ENODEV;\r\nctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\r\nif (!ctrl) {\r\ndev_err(&pdev->dev, "%s: Out of memory\n", __func__);\r\ngoto err_out_none;\r\n}\r\nINIT_LIST_HEAD(&ctrl->slot_list);\r\nrc = shpc_init(ctrl, pdev);\r\nif (rc) {\r\nctrl_dbg(ctrl, "Controller initialization failed\n");\r\ngoto err_out_free_ctrl;\r\n}\r\npci_set_drvdata(pdev, ctrl);\r\nrc = init_slots(ctrl);\r\nif (rc) {\r\nctrl_err(ctrl, "Slot initialization failed\n");\r\ngoto err_out_release_ctlr;\r\n}\r\nrc = shpchp_create_ctrl_files(ctrl);\r\nif (rc)\r\ngoto err_cleanup_slots;\r\nreturn 0;\r\nerr_cleanup_slots:\r\ncleanup_slots(ctrl);\r\nerr_out_release_ctlr:\r\nctrl->hpc_ops->release_ctlr(ctrl);\r\nerr_out_free_ctrl:\r\nkfree(ctrl);\r\nerr_out_none:\r\nreturn -ENODEV;\r\n}\r\nstatic void shpc_remove(struct pci_dev *dev)\r\n{\r\nstruct controller *ctrl = pci_get_drvdata(dev);\r\nshpchp_remove_ctrl_files(ctrl);\r\nctrl->hpc_ops->release_ctlr(ctrl);\r\nkfree(ctrl);\r\n}\r\nstatic int __init shpcd_init(void)\r\n{\r\nint retval = 0;\r\nshpchp_wq = alloc_ordered_workqueue("shpchp", 0);\r\nif (!shpchp_wq)\r\nreturn -ENOMEM;\r\nshpchp_ordered_wq = alloc_ordered_workqueue("shpchp_ordered", 0);\r\nif (!shpchp_ordered_wq) {\r\ndestroy_workqueue(shpchp_wq);\r\nreturn -ENOMEM;\r\n}\r\nretval = pci_register_driver(&shpc_driver);\r\ndbg("%s: pci_register_driver = %d\n", __func__, retval);\r\ninfo(DRIVER_DESC " version: " DRIVER_VERSION "\n");\r\nif (retval) {\r\ndestroy_workqueue(shpchp_ordered_wq);\r\ndestroy_workqueue(shpchp_wq);\r\n}\r\nreturn retval;\r\n}\r\nstatic void __exit shpcd_cleanup(void)\r\n{\r\ndbg("unload_shpchpd()\n");\r\npci_unregister_driver(&shpc_driver);\r\ndestroy_workqueue(shpchp_ordered_wq);\r\ndestroy_workqueue(shpchp_wq);\r\ninfo(DRIVER_DESC " version: " DRIVER_VERSION " unloaded\n");\r\n}
