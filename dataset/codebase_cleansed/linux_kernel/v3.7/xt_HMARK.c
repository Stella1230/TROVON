static inline __be32 hmark_addr6_mask(const __be32 *addr32, const __be32 *mask)\r\n{\r\nreturn (addr32[0] & mask[0]) ^\r\n(addr32[1] & mask[1]) ^\r\n(addr32[2] & mask[2]) ^\r\n(addr32[3] & mask[3]);\r\n}\r\nstatic inline __be32\r\nhmark_addr_mask(int l3num, const __be32 *addr32, const __be32 *mask)\r\n{\r\nswitch (l3num) {\r\ncase AF_INET:\r\nreturn *addr32 & *mask;\r\ncase AF_INET6:\r\nreturn hmark_addr6_mask(addr32, mask);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void hmark_swap_ports(union hmark_ports *uports,\r\nconst struct xt_hmark_info *info)\r\n{\r\nunion hmark_ports hp;\r\nu16 src, dst;\r\nhp.b32 = (uports->b32 & info->port_mask.b32) | info->port_set.b32;\r\nsrc = ntohs(hp.b16.src);\r\ndst = ntohs(hp.b16.dst);\r\nif (dst > src)\r\nuports->v32 = (dst << 16) | src;\r\nelse\r\nuports->v32 = (src << 16) | dst;\r\n}\r\nstatic int\r\nhmark_ct_set_htuple(const struct sk_buff *skb, struct hmark_tuple *t,\r\nconst struct xt_hmark_info *info)\r\n{\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nstruct nf_conntrack_tuple *otuple;\r\nstruct nf_conntrack_tuple *rtuple;\r\nif (ct == NULL || nf_ct_is_untracked(ct))\r\nreturn -1;\r\notuple = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\r\nrtuple = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;\r\nt->src = hmark_addr_mask(otuple->src.l3num, otuple->src.u3.ip6,\r\ninfo->src_mask.ip6);\r\nt->dst = hmark_addr_mask(otuple->src.l3num, rtuple->src.u3.ip6,\r\ninfo->dst_mask.ip6);\r\nif (info->flags & XT_HMARK_FLAG(XT_HMARK_METHOD_L3))\r\nreturn 0;\r\nt->proto = nf_ct_protonum(ct);\r\nif (t->proto != IPPROTO_ICMP) {\r\nt->uports.b16.src = otuple->src.u.all;\r\nt->uports.b16.dst = rtuple->src.u.all;\r\nhmark_swap_ports(&t->uports, info);\r\n}\r\nreturn 0;\r\n#else\r\nreturn -1;\r\n#endif\r\n}\r\nstatic inline u32\r\nhmark_hash(struct hmark_tuple *t, const struct xt_hmark_info *info)\r\n{\r\nu32 hash;\r\nu32 src = ntohl(t->src);\r\nu32 dst = ntohl(t->dst);\r\nif (dst < src)\r\nswap(src, dst);\r\nhash = jhash_3words(src, dst, t->uports.v32, info->hashrnd);\r\nhash = hash ^ (t->proto & info->proto_mask);\r\nreturn (((u64)hash * info->hmodulus) >> 32) + info->hoffset;\r\n}\r\nstatic void\r\nhmark_set_tuple_ports(const struct sk_buff *skb, unsigned int nhoff,\r\nstruct hmark_tuple *t, const struct xt_hmark_info *info)\r\n{\r\nint protoff;\r\nprotoff = proto_ports_offset(t->proto);\r\nif (protoff < 0)\r\nreturn;\r\nnhoff += protoff;\r\nif (skb_copy_bits(skb, nhoff, &t->uports, sizeof(t->uports)) < 0)\r\nreturn;\r\nhmark_swap_ports(&t->uports, info);\r\n}\r\nstatic int get_inner6_hdr(const struct sk_buff *skb, int *offset)\r\n{\r\nstruct icmp6hdr *icmp6h, _ih6;\r\nicmp6h = skb_header_pointer(skb, *offset, sizeof(_ih6), &_ih6);\r\nif (icmp6h == NULL)\r\nreturn 0;\r\nif (icmp6h->icmp6_type && icmp6h->icmp6_type < 128) {\r\n*offset += sizeof(struct icmp6hdr);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nhmark_pkt_set_htuple_ipv6(const struct sk_buff *skb, struct hmark_tuple *t,\r\nconst struct xt_hmark_info *info)\r\n{\r\nstruct ipv6hdr *ip6, _ip6;\r\nint flag = IP6T_FH_F_AUTH;\r\nunsigned int nhoff = 0;\r\nu16 fragoff = 0;\r\nint nexthdr;\r\nip6 = (struct ipv6hdr *) (skb->data + skb_network_offset(skb));\r\nnexthdr = ipv6_find_hdr(skb, &nhoff, -1, &fragoff, &flag);\r\nif (nexthdr < 0)\r\nreturn 0;\r\nif ((flag & IP6T_FH_F_FRAG) || (nexthdr != IPPROTO_ICMPV6))\r\ngoto noicmp;\r\nif (get_inner6_hdr(skb, &nhoff)) {\r\nip6 = skb_header_pointer(skb, nhoff, sizeof(_ip6), &_ip6);\r\nif (ip6 == NULL)\r\nreturn -1;\r\nflag = IP6T_FH_F_AUTH;\r\nnexthdr = ipv6_find_hdr(skb, &nhoff, -1, &fragoff, &flag);\r\nif (nexthdr < 0)\r\nreturn -1;\r\n}\r\nnoicmp:\r\nt->src = hmark_addr6_mask(ip6->saddr.s6_addr32, info->src_mask.ip6);\r\nt->dst = hmark_addr6_mask(ip6->daddr.s6_addr32, info->dst_mask.ip6);\r\nif (info->flags & XT_HMARK_FLAG(XT_HMARK_METHOD_L3))\r\nreturn 0;\r\nt->proto = nexthdr;\r\nif (t->proto == IPPROTO_ICMPV6)\r\nreturn 0;\r\nif (flag & IP6T_FH_F_FRAG)\r\nreturn 0;\r\nhmark_set_tuple_ports(skb, nhoff, t, info);\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nhmark_tg_v6(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_hmark_info *info = par->targinfo;\r\nstruct hmark_tuple t;\r\nmemset(&t, 0, sizeof(struct hmark_tuple));\r\nif (info->flags & XT_HMARK_FLAG(XT_HMARK_CT)) {\r\nif (hmark_ct_set_htuple(skb, &t, info) < 0)\r\nreturn XT_CONTINUE;\r\n} else {\r\nif (hmark_pkt_set_htuple_ipv6(skb, &t, info) < 0)\r\nreturn XT_CONTINUE;\r\n}\r\nskb->mark = hmark_hash(&t, info);\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int get_inner_hdr(const struct sk_buff *skb, int iphsz, int *nhoff)\r\n{\r\nconst struct icmphdr *icmph;\r\nstruct icmphdr _ih;\r\nicmph = skb_header_pointer(skb, *nhoff + iphsz, sizeof(_ih), &_ih);\r\nif (icmph == NULL || icmph->type > NR_ICMP_TYPES)\r\nreturn 0;\r\nif (icmph->type != ICMP_DEST_UNREACH &&\r\nicmph->type != ICMP_SOURCE_QUENCH &&\r\nicmph->type != ICMP_TIME_EXCEEDED &&\r\nicmph->type != ICMP_PARAMETERPROB &&\r\nicmph->type != ICMP_REDIRECT)\r\nreturn 0;\r\n*nhoff += iphsz + sizeof(_ih);\r\nreturn 1;\r\n}\r\nstatic int\r\nhmark_pkt_set_htuple_ipv4(const struct sk_buff *skb, struct hmark_tuple *t,\r\nconst struct xt_hmark_info *info)\r\n{\r\nstruct iphdr *ip, _ip;\r\nint nhoff = skb_network_offset(skb);\r\nip = (struct iphdr *) (skb->data + nhoff);\r\nif (ip->protocol == IPPROTO_ICMP) {\r\nif (get_inner_hdr(skb, ip->ihl * 4, &nhoff)) {\r\nip = skb_header_pointer(skb, nhoff, sizeof(_ip), &_ip);\r\nif (ip == NULL)\r\nreturn -1;\r\n}\r\n}\r\nt->src = ip->saddr & info->src_mask.ip;\r\nt->dst = ip->daddr & info->dst_mask.ip;\r\nif (info->flags & XT_HMARK_FLAG(XT_HMARK_METHOD_L3))\r\nreturn 0;\r\nt->proto = ip->protocol;\r\nif (t->proto == IPPROTO_ICMP)\r\nreturn 0;\r\nif (ip->frag_off & htons(IP_MF | IP_OFFSET))\r\nreturn 0;\r\nhmark_set_tuple_ports(skb, (ip->ihl * 4) + nhoff, t, info);\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nhmark_tg_v4(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_hmark_info *info = par->targinfo;\r\nstruct hmark_tuple t;\r\nmemset(&t, 0, sizeof(struct hmark_tuple));\r\nif (info->flags & XT_HMARK_FLAG(XT_HMARK_CT)) {\r\nif (hmark_ct_set_htuple(skb, &t, info) < 0)\r\nreturn XT_CONTINUE;\r\n} else {\r\nif (hmark_pkt_set_htuple_ipv4(skb, &t, info) < 0)\r\nreturn XT_CONTINUE;\r\n}\r\nskb->mark = hmark_hash(&t, info);\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int hmark_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct xt_hmark_info *info = par->targinfo;\r\nif (!info->hmodulus) {\r\npr_info("xt_HMARK: hash modulus can't be zero\n");\r\nreturn -EINVAL;\r\n}\r\nif (info->proto_mask &&\r\n(info->flags & XT_HMARK_FLAG(XT_HMARK_METHOD_L3))) {\r\npr_info("xt_HMARK: proto mask must be zero with L3 mode\n");\r\nreturn -EINVAL;\r\n}\r\nif (info->flags & XT_HMARK_FLAG(XT_HMARK_SPI_MASK) &&\r\n(info->flags & (XT_HMARK_FLAG(XT_HMARK_SPORT_MASK) |\r\nXT_HMARK_FLAG(XT_HMARK_DPORT_MASK)))) {\r\npr_info("xt_HMARK: spi-mask and port-mask can't be combined\n");\r\nreturn -EINVAL;\r\n}\r\nif (info->flags & XT_HMARK_FLAG(XT_HMARK_SPI) &&\r\n(info->flags & (XT_HMARK_FLAG(XT_HMARK_SPORT) |\r\nXT_HMARK_FLAG(XT_HMARK_DPORT)))) {\r\npr_info("xt_HMARK: spi-set and port-set can't be combined\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init hmark_tg_init(void)\r\n{\r\nreturn xt_register_targets(hmark_tg_reg, ARRAY_SIZE(hmark_tg_reg));\r\n}\r\nstatic void __exit hmark_tg_exit(void)\r\n{\r\nxt_unregister_targets(hmark_tg_reg, ARRAY_SIZE(hmark_tg_reg));\r\n}
