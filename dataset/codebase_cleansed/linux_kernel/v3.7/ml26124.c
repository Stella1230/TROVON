static inline int get_srate(int rate)\r\n{\r\nint srate;\r\nswitch (rate) {\r\ncase 16000:\r\nsrate = 3;\r\nbreak;\r\ncase 32000:\r\nsrate = 6;\r\nbreak;\r\ncase 48000:\r\nsrate = 8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn srate;\r\n}\r\nstatic inline int get_coeff(int mclk, int rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(coeff_div); i++) {\r\nif (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ml26124_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ml26124_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nint i = get_coeff(priv->mclk, params_rate(hw_params));\r\npriv->substream = substream;\r\npriv->rate = params_rate(hw_params);\r\nif (priv->clk_in) {\r\nswitch (priv->mclk / params_rate(hw_params)) {\r\ncase 256:\r\nsnd_soc_update_bits(codec, ML26124_CLK_CTL,\r\nBIT(0) | BIT(1), 1);\r\nbreak;\r\ncase 512:\r\nsnd_soc_update_bits(codec, ML26124_CLK_CTL,\r\nBIT(0) | BIT(1), 2);\r\nbreak;\r\ncase 1024:\r\nsnd_soc_update_bits(codec, ML26124_CLK_CTL,\r\nBIT(0) | BIT(1), 3);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported MCLKI\n");\r\nbreak;\r\n}\r\n} else {\r\nsnd_soc_update_bits(codec, ML26124_CLK_CTL,\r\nBIT(0) | BIT(1), 0);\r\n}\r\nswitch (params_rate(hw_params)) {\r\ncase 16000:\r\nsnd_soc_update_bits(codec, ML26124_SMPLING_RATE, 0xf,\r\nget_srate(params_rate(hw_params)));\r\nsnd_soc_update_bits(codec, ML26124_PLLNL, 0xff,\r\ncoeff_div[i].pllnl);\r\nsnd_soc_update_bits(codec, ML26124_PLLNH, 0x1,\r\ncoeff_div[i].pllnh);\r\nsnd_soc_update_bits(codec, ML26124_PLLML, 0xff,\r\ncoeff_div[i].pllml);\r\nsnd_soc_update_bits(codec, ML26124_PLLMH, 0x3f,\r\ncoeff_div[i].pllmh);\r\nsnd_soc_update_bits(codec, ML26124_PLLDIV, 0x1f,\r\ncoeff_div[i].plldiv);\r\nbreak;\r\ncase 32000:\r\nsnd_soc_update_bits(codec, ML26124_SMPLING_RATE, 0xf,\r\nget_srate(params_rate(hw_params)));\r\nsnd_soc_update_bits(codec, ML26124_PLLNL, 0xff,\r\ncoeff_div[i].pllnl);\r\nsnd_soc_update_bits(codec, ML26124_PLLNH, 0x1,\r\ncoeff_div[i].pllnh);\r\nsnd_soc_update_bits(codec, ML26124_PLLML, 0xff,\r\ncoeff_div[i].pllml);\r\nsnd_soc_update_bits(codec, ML26124_PLLMH, 0x3f,\r\ncoeff_div[i].pllmh);\r\nsnd_soc_update_bits(codec, ML26124_PLLDIV, 0x1f,\r\ncoeff_div[i].plldiv);\r\nbreak;\r\ncase 48000:\r\nsnd_soc_update_bits(codec, ML26124_SMPLING_RATE, 0xf,\r\nget_srate(params_rate(hw_params)));\r\nsnd_soc_update_bits(codec, ML26124_PLLNL, 0xff,\r\ncoeff_div[i].pllnl);\r\nsnd_soc_update_bits(codec, ML26124_PLLNH, 0x1,\r\ncoeff_div[i].pllnh);\r\nsnd_soc_update_bits(codec, ML26124_PLLML, 0xff,\r\ncoeff_div[i].pllml);\r\nsnd_soc_update_bits(codec, ML26124_PLLMH, 0x3f,\r\ncoeff_div[i].pllmh);\r\nsnd_soc_update_bits(codec, ML26124_PLLDIV, 0x1f,\r\ncoeff_div[i].plldiv);\r\nbreak;\r\ndefault:\r\npr_err("%s:this rate is no support for ml26124\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ml26124_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ml26124_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (priv->substream->stream) {\r\ncase SNDRV_PCM_STREAM_CAPTURE:\r\nsnd_soc_update_bits(codec, ML26124_REC_PLYBAK_RUN, BIT(0), 1);\r\nbreak;\r\ncase SNDRV_PCM_STREAM_PLAYBACK:\r\nsnd_soc_update_bits(codec, ML26124_REC_PLYBAK_RUN, BIT(1), 2);\r\nbreak;\r\n}\r\nif (mute)\r\nsnd_soc_update_bits(codec, ML26124_DVOL_CTL, BIT(4),\r\nDVOL_CTL_DVMUTE_ON);\r\nelse\r\nsnd_soc_update_bits(codec, ML26124_DVOL_CTL, BIT(4),\r\nDVOL_CTL_DVMUTE_OFF);\r\nreturn 0;\r\n}\r\nstatic int ml26124_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nunsigned char mode;\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmode = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmode = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, ML26124_SAI_MODE_SEL, BIT(0), mode);\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ml26124_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct ml26124_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase ML26124_USE_PLLOUT:\r\npriv->clk_in = ML26124_USE_PLLOUT;\r\nbreak;\r\ncase ML26124_USE_MCLKI:\r\npriv->clk_in = ML26124_USE_MCLKI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npriv->mclk = freq;\r\nreturn 0;\r\n}\r\nstatic int ml26124_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct ml26124_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nsnd_soc_update_bits(codec, ML26124_PW_SPAMP_PW_MNG,\r\nML26124_R26_MASK, ML26124_BLT_PREAMP_ON);\r\nmsleep(100);\r\nsnd_soc_update_bits(codec, ML26124_PW_SPAMP_PW_MNG,\r\nML26124_R26_MASK,\r\nML26124_MICBEN_ON | ML26124_BLT_ALL_ON);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nsnd_soc_update_bits(codec, ML26124_PW_REF_PW_MNG,\r\nML26124_VMID, ML26124_VMID);\r\nmsleep(500);\r\nregcache_sync(priv->regmap);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, ML26124_PW_REF_PW_MNG,\r\nML26124_VMID, 0);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int ml26124_suspend(struct snd_soc_codec *codec)\r\n{\r\nml26124_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int ml26124_resume(struct snd_soc_codec *codec)\r\n{\r\nml26124_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int ml26124_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret;\r\nstruct ml26124_priv *priv = snd_soc_codec_get_drvdata(codec);\r\ncodec->control_data = priv->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 7, 9, SND_SOC_REGMAP);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nsnd_soc_update_bits(codec, ML26124_SW_RST, 0x01, 1);\r\nsnd_soc_update_bits(codec, ML26124_SW_RST, 0x01, 0);\r\nml26124_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic __devinit int ml26124_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ml26124_priv *priv;\r\nint ret;\r\npriv = devm_kzalloc(&i2c->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, priv);\r\npriv->regmap = devm_regmap_init_i2c(i2c, &ml26124_i2c_regmap);\r\nif (IS_ERR(priv->regmap)) {\r\nret = PTR_ERR(priv->regmap);\r\ndev_err(&i2c->dev, "regmap_init_i2c() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_ml26124, &ml26124_dai, 1);\r\n}\r\nstatic __devexit int ml26124_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
