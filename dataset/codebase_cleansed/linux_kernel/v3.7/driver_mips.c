static inline bool bcma_core_mips_bcm47162a0_quirk(struct bcma_device *dev)\r\n{\r\nreturn dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM47162 &&\r\ndev->bus->chipinfo.rev == 0 && dev->id.id == BCMA_CORE_MIPS_74K;\r\n}\r\nstatic inline bool bcma_core_mips_bcm5357b0_quirk(struct bcma_device *dev)\r\n{\r\nreturn (dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM5357 ||\r\ndev->bus->chipinfo.id == BCMA_CHIP_ID_BCM4749) &&\r\ndev->bus->chipinfo.pkg == 11 &&\r\ndev->id.id == BCMA_CORE_USB20_HOST;\r\n}\r\nstatic inline u32 mips_read32(struct bcma_drv_mips *mcore,\r\nu16 offset)\r\n{\r\nreturn bcma_read32(mcore->core, offset);\r\n}\r\nstatic inline void mips_write32(struct bcma_drv_mips *mcore,\r\nu16 offset,\r\nu32 value)\r\n{\r\nbcma_write32(mcore->core, offset, value);\r\n}\r\nstatic u32 bcma_core_mips_irqflag(struct bcma_device *dev)\r\n{\r\nu32 flag;\r\nif (bcma_core_mips_bcm47162a0_quirk(dev))\r\nreturn dev->core_index;\r\nif (bcma_core_mips_bcm5357b0_quirk(dev))\r\nreturn dev->core_index;\r\nflag = bcma_aread32(dev, BCMA_MIPS_OOBSELOUTA30);\r\nreturn flag & 0x1F;\r\n}\r\nunsigned int bcma_core_mips_irq(struct bcma_device *dev)\r\n{\r\nstruct bcma_device *mdev = dev->bus->drv_mips.core;\r\nu32 irqflag;\r\nunsigned int irq;\r\nirqflag = bcma_core_mips_irqflag(dev);\r\nfor (irq = 1; irq <= 4; irq++)\r\nif (bcma_read32(mdev, BCMA_MIPS_MIPS74K_INTMASK(irq)) &\r\n(1 << irqflag))\r\nreturn irq;\r\nreturn 0;\r\n}\r\nstatic void bcma_core_mips_set_irq(struct bcma_device *dev, unsigned int irq)\r\n{\r\nunsigned int oldirq = bcma_core_mips_irq(dev);\r\nstruct bcma_bus *bus = dev->bus;\r\nstruct bcma_device *mdev = bus->drv_mips.core;\r\nu32 irqflag;\r\nirqflag = bcma_core_mips_irqflag(dev);\r\nBUG_ON(oldirq == 6);\r\ndev->irq = irq + 2;\r\nif (oldirq == 0)\r\nbcma_write32(mdev, BCMA_MIPS_MIPS74K_INTMASK(0),\r\nbcma_read32(mdev, BCMA_MIPS_MIPS74K_INTMASK(0)) &\r\n~(1 << irqflag));\r\nelse\r\nbcma_write32(mdev, BCMA_MIPS_MIPS74K_INTMASK(irq), 0);\r\nif (irq == 0) {\r\nbcma_write32(mdev, BCMA_MIPS_MIPS74K_INTMASK(0),\r\nbcma_read32(mdev, BCMA_MIPS_MIPS74K_INTMASK(0)) |\r\n(1 << irqflag));\r\n} else {\r\nu32 oldirqflag = bcma_read32(mdev,\r\nBCMA_MIPS_MIPS74K_INTMASK(irq));\r\nif (oldirqflag) {\r\nstruct bcma_device *core;\r\nlist_for_each_entry(core, &bus->cores, list) {\r\nif ((1 << bcma_core_mips_irqflag(core)) ==\r\noldirqflag) {\r\nbcma_core_mips_set_irq(core, 0);\r\nbreak;\r\n}\r\n}\r\n}\r\nbcma_write32(mdev, BCMA_MIPS_MIPS74K_INTMASK(irq),\r\n1 << irqflag);\r\n}\r\nbcma_info(bus, "set_irq: core 0x%04x, irq %d => %d\n",\r\ndev->id.id, oldirq + 2, irq + 2);\r\n}\r\nstatic void bcma_core_mips_print_irq(struct bcma_device *dev, unsigned int irq)\r\n{\r\nint i;\r\nstatic const char *irq_name[] = {"2(S)", "3", "4", "5", "6", "D", "I"};\r\nprintk(KERN_INFO KBUILD_MODNAME ": core 0x%04x, irq :", dev->id.id);\r\nfor (i = 0; i <= 6; i++)\r\nprintk(" %s%s", irq_name[i], i == irq ? "*" : " ");\r\nprintk("\n");\r\n}\r\nstatic void bcma_core_mips_dump_irq(struct bcma_bus *bus)\r\n{\r\nstruct bcma_device *core;\r\nlist_for_each_entry(core, &bus->cores, list) {\r\nbcma_core_mips_print_irq(core, bcma_core_mips_irq(core));\r\n}\r\n}\r\nu32 bcma_cpu_clock(struct bcma_drv_mips *mcore)\r\n{\r\nstruct bcma_bus *bus = mcore->core->bus;\r\nif (bus->drv_cc.capabilities & BCMA_CC_CAP_PMU)\r\nreturn bcma_pmu_get_clockcpu(&bus->drv_cc);\r\nbcma_err(bus, "No PMU available, need this to get the cpu clock\n");\r\nreturn 0;\r\n}\r\nstatic void bcma_core_mips_flash_detect(struct bcma_drv_mips *mcore)\r\n{\r\nstruct bcma_bus *bus = mcore->core->bus;\r\nswitch (bus->drv_cc.capabilities & BCMA_CC_CAP_FLASHT) {\r\ncase BCMA_CC_FLASHT_STSER:\r\ncase BCMA_CC_FLASHT_ATSER:\r\nbcma_debug(bus, "Found serial flash\n");\r\nbcma_sflash_init(&bus->drv_cc);\r\nbreak;\r\ncase BCMA_CC_FLASHT_PARA:\r\nbcma_debug(bus, "Found parallel flash\n");\r\nbus->drv_cc.pflash.window = 0x1c000000;\r\nbus->drv_cc.pflash.window_size = 0x02000000;\r\nif ((bcma_read32(bus->drv_cc.core, BCMA_CC_FLASH_CFG) &\r\nBCMA_CC_FLASH_CFG_DS) == 0)\r\nbus->drv_cc.pflash.buswidth = 1;\r\nelse\r\nbus->drv_cc.pflash.buswidth = 2;\r\nbreak;\r\ndefault:\r\nbcma_err(bus, "Flash type not supported\n");\r\n}\r\nif (bus->drv_cc.core->id.rev == 38 ||\r\nbus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {\r\nif (bus->drv_cc.capabilities & BCMA_CC_CAP_NFLASH) {\r\nbcma_debug(bus, "Found NAND flash\n");\r\nbcma_nflash_init(&bus->drv_cc);\r\n}\r\n}\r\n}\r\nvoid bcma_core_mips_init(struct bcma_drv_mips *mcore)\r\n{\r\nstruct bcma_bus *bus;\r\nstruct bcma_device *core;\r\nbus = mcore->core->bus;\r\nbcma_info(bus, "Initializing MIPS core...\n");\r\nif (!mcore->setup_done)\r\nmcore->assigned_irqs = 1;\r\nlist_for_each_entry(core, &bus->cores, list) {\r\nint mips_irq;\r\nif (core->irq)\r\ncontinue;\r\nmips_irq = bcma_core_mips_irq(core);\r\nif (mips_irq > 4)\r\ncore->irq = 0;\r\nelse\r\ncore->irq = mips_irq + 2;\r\nif (core->irq > 5)\r\ncontinue;\r\nswitch (core->id.id) {\r\ncase BCMA_CORE_PCI:\r\ncase BCMA_CORE_PCIE:\r\ncase BCMA_CORE_ETHERNET:\r\ncase BCMA_CORE_ETHERNET_GBIT:\r\ncase BCMA_CORE_MAC_GBIT:\r\ncase BCMA_CORE_80211:\r\ncase BCMA_CORE_USB20_HOST:\r\nif (mcore->assigned_irqs <= 4)\r\nbcma_core_mips_set_irq(core,\r\nmcore->assigned_irqs++);\r\nbreak;\r\n}\r\n}\r\nbcma_info(bus, "IRQ reconfiguration done\n");\r\nbcma_core_mips_dump_irq(bus);\r\nif (mcore->setup_done)\r\nreturn;\r\nbcma_chipco_serial_init(&bus->drv_cc);\r\nbcma_core_mips_flash_detect(mcore);\r\nmcore->setup_done = true;\r\n}
