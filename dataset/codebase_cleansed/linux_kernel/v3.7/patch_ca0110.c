static int ca0110_playback_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_analog_open(codec, &spec->multiout, substream,\r\nhinfo);\r\n}\r\nstatic int ca0110_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_analog_prepare(codec, &spec->multiout,\r\nstream_tag, format, substream);\r\n}\r\nstatic int ca0110_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_analog_cleanup(codec, &spec->multiout);\r\n}\r\nstatic int ca0110_dig_playback_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_open(codec, &spec->multiout);\r\n}\r\nstatic int ca0110_dig_playback_pcm_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_close(codec, &spec->multiout);\r\n}\r\nstatic int ca0110_dig_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_prepare(codec, &spec->multiout, stream_tag,\r\nformat, substream);\r\n}\r\nstatic int ca0110_capture_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nsnd_hda_codec_setup_stream(codec, spec->adcs[substream->number],\r\nstream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int ca0110_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nsnd_hda_codec_cleanup_stream(codec, spec->adcs[substream->number]);\r\nreturn 0;\r\n}\r\nstatic int _add_switch(struct hda_codec *codec, hda_nid_t nid, const char *pfx,\r\nint chan, int dir)\r\n{\r\nchar namestr[44];\r\nint type = dir ? HDA_INPUT : HDA_OUTPUT;\r\nstruct snd_kcontrol_new knew =\r\nHDA_CODEC_MUTE_MONO(namestr, nid, chan, 0, type);\r\nsprintf(namestr, "%s %s Switch", pfx, dirstr[dir]);\r\nreturn snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));\r\n}\r\nstatic int _add_volume(struct hda_codec *codec, hda_nid_t nid, const char *pfx,\r\nint chan, int dir)\r\n{\r\nchar namestr[44];\r\nint type = dir ? HDA_INPUT : HDA_OUTPUT;\r\nstruct snd_kcontrol_new knew =\r\nHDA_CODEC_VOLUME_MONO(namestr, nid, chan, 0, type);\r\nsprintf(namestr, "%s %s Volume", pfx, dirstr[dir]);\r\nreturn snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));\r\n}\r\nstatic int ca0110_build_controls(struct hda_codec *codec)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nstatic const char * const prefix[AUTO_CFG_MAX_OUTS] = {\r\n"Front", "Surround", NULL, "Side", "Multi"\r\n};\r\nhda_nid_t mutenid;\r\nint i, err;\r\nfor (i = 0; i < spec->multiout.num_dacs; i++) {\r\nif (get_wcaps(codec, spec->out_pins[i]) & AC_WCAP_OUT_AMP)\r\nmutenid = spec->out_pins[i];\r\nelse\r\nmutenid = spec->multiout.dac_nids[i];\r\nif (!prefix[i]) {\r\nerr = add_mono_switch(codec, mutenid,\r\n"Center", 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_mono_switch(codec, mutenid,\r\n"LFE", 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_mono_volume(codec, spec->multiout.dac_nids[i],\r\n"Center", 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_mono_volume(codec, spec->multiout.dac_nids[i],\r\n"LFE", 1);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\nerr = add_out_switch(codec, mutenid,\r\nprefix[i]);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_out_volume(codec, spec->multiout.dac_nids[i],\r\nprefix[i]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (cfg->hp_outs) {\r\nif (get_wcaps(codec, cfg->hp_pins[0]) & AC_WCAP_OUT_AMP)\r\nmutenid = cfg->hp_pins[0];\r\nelse\r\nmutenid = spec->multiout.dac_nids[i];\r\nerr = add_out_switch(codec, mutenid, "Headphone");\r\nif (err < 0)\r\nreturn err;\r\nif (spec->hp_dac) {\r\nerr = add_out_volume(codec, spec->hp_dac, "Headphone");\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nfor (i = 0; i < spec->num_inputs; i++) {\r\nconst char *label = spec->input_labels[i];\r\nif (get_wcaps(codec, spec->input_pins[i]) & AC_WCAP_IN_AMP)\r\nmutenid = spec->input_pins[i];\r\nelse\r\nmutenid = spec->adcs[i];\r\nerr = add_in_switch(codec, mutenid, label);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_in_volume(codec, spec->adcs[i], label);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (spec->dig_out) {\r\nerr = snd_hda_create_spdif_out_ctls(codec, spec->dig_out,\r\nspec->dig_out);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hda_create_spdif_share_sw(codec, &spec->multiout);\r\nif (err < 0)\r\nreturn err;\r\nspec->multiout.share_spdif = 1;\r\n}\r\nif (spec->dig_in) {\r\nerr = snd_hda_create_spdif_in_ctls(codec, spec->dig_in);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_in_volume(codec, spec->dig_in, "IEC958");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ca0110_build_pcms(struct hda_codec *codec)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nstruct hda_pcm *info = spec->pcm_rec;\r\ncodec->pcm_info = info;\r\ncodec->num_pcms = 0;\r\ninfo->name = "CA0110 Analog";\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK] = ca0110_pcm_analog_playback;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dacs[0];\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].channels_max =\r\nspec->multiout.max_channels;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] = ca0110_pcm_analog_capture;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = spec->num_inputs;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[0];\r\ncodec->num_pcms++;\r\nif (!spec->dig_out && !spec->dig_in)\r\nreturn 0;\r\ninfo++;\r\ninfo->name = "CA0110 Digital";\r\ninfo->pcm_type = HDA_PCM_TYPE_SPDIF;\r\nif (spec->dig_out) {\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK] =\r\nca0110_pcm_digital_playback;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dig_out;\r\n}\r\nif (spec->dig_in) {\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] =\r\nca0110_pcm_digital_capture;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->dig_in;\r\n}\r\ncodec->num_pcms++;\r\nreturn 0;\r\n}\r\nstatic void init_output(struct hda_codec *codec, hda_nid_t pin, hda_nid_t dac)\r\n{\r\nif (pin) {\r\nsnd_hda_set_pin_ctl(codec, pin, PIN_HP);\r\nif (get_wcaps(codec, pin) & AC_WCAP_OUT_AMP)\r\nsnd_hda_codec_write(codec, pin, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE,\r\nAMP_OUT_UNMUTE);\r\n}\r\nif (dac)\r\nsnd_hda_codec_write(codec, dac, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO);\r\n}\r\nstatic void init_input(struct hda_codec *codec, hda_nid_t pin, hda_nid_t adc)\r\n{\r\nif (pin) {\r\nsnd_hda_set_pin_ctl(codec, pin, PIN_IN |\r\nsnd_hda_get_default_vref(codec, pin));\r\nif (get_wcaps(codec, pin) & AC_WCAP_IN_AMP)\r\nsnd_hda_codec_write(codec, pin, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE,\r\nAMP_IN_UNMUTE(0));\r\n}\r\nif (adc)\r\nsnd_hda_codec_write(codec, adc, 0, AC_VERB_SET_AMP_GAIN_MUTE,\r\nAMP_IN_UNMUTE(0));\r\n}\r\nstatic int ca0110_init(struct hda_codec *codec)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i;\r\nfor (i = 0; i < spec->multiout.num_dacs; i++)\r\ninit_output(codec, spec->out_pins[i],\r\nspec->multiout.dac_nids[i]);\r\ninit_output(codec, cfg->hp_pins[0], spec->hp_dac);\r\ninit_output(codec, cfg->dig_out_pins[0], spec->dig_out);\r\nfor (i = 0; i < spec->num_inputs; i++)\r\ninit_input(codec, spec->input_pins[i], spec->adcs[i]);\r\ninit_input(codec, cfg->dig_in_pin, spec->dig_in);\r\nreturn 0;\r\n}\r\nstatic void ca0110_free(struct hda_codec *codec)\r\n{\r\nkfree(codec->spec);\r\n}\r\nstatic void parse_line_outs(struct hda_codec *codec)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i, n;\r\nunsigned int def_conf;\r\nhda_nid_t nid;\r\nn = 0;\r\nfor (i = 0; i < cfg->line_outs; i++) {\r\nnid = cfg->line_out_pins[i];\r\ndef_conf = snd_hda_codec_get_pincfg(codec, nid);\r\nif (!def_conf)\r\ncontinue;\r\nif (snd_hda_get_connections(codec, nid, &spec->dacs[i], 1) != 1)\r\ncontinue;\r\nspec->out_pins[n++] = nid;\r\n}\r\nspec->multiout.dac_nids = spec->dacs;\r\nspec->multiout.num_dacs = n;\r\nspec->multiout.max_channels = n * 2;\r\n}\r\nstatic void parse_hp_out(struct hda_codec *codec)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i;\r\nunsigned int def_conf;\r\nhda_nid_t nid, dac;\r\nif (!cfg->hp_outs)\r\nreturn;\r\nnid = cfg->hp_pins[0];\r\ndef_conf = snd_hda_codec_get_pincfg(codec, nid);\r\nif (!def_conf) {\r\ncfg->hp_outs = 0;\r\nreturn;\r\n}\r\nif (snd_hda_get_connections(codec, nid, &dac, 1) != 1)\r\nreturn;\r\nfor (i = 0; i < cfg->line_outs; i++)\r\nif (dac == spec->dacs[i])\r\nbreak;\r\nif (i >= cfg->line_outs) {\r\nspec->hp_dac = dac;\r\nspec->multiout.hp_nid = dac;\r\n}\r\n}\r\nstatic void parse_input(struct hda_codec *codec)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nhda_nid_t nid, pin;\r\nint n, i, j;\r\nn = 0;\r\nnid = codec->start_nid;\r\nfor (i = 0; i < codec->num_nodes; i++, nid++) {\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nunsigned int type = get_wcaps_type(wcaps);\r\nif (type != AC_WID_AUD_IN)\r\ncontinue;\r\nif (snd_hda_get_connections(codec, nid, &pin, 1) != 1)\r\ncontinue;\r\nif (pin == cfg->dig_in_pin) {\r\nspec->dig_in = nid;\r\ncontinue;\r\n}\r\nfor (j = 0; j < cfg->num_inputs; j++)\r\nif (cfg->inputs[j].pin == pin)\r\nbreak;\r\nif (j >= cfg->num_inputs)\r\ncontinue;\r\nspec->input_pins[n] = pin;\r\nsnd_hda_get_pin_label(codec, pin, cfg,\r\nspec->input_labels[n],\r\nsizeof(spec->input_labels[n]), NULL);\r\nspec->adcs[n] = nid;\r\nn++;\r\n}\r\nspec->num_inputs = n;\r\n}\r\nstatic void parse_digital(struct hda_codec *codec)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nif (cfg->dig_outs &&\r\nsnd_hda_get_connections(codec, cfg->dig_out_pins[0],\r\n&spec->dig_out, 1) == 1)\r\nspec->multiout.dig_out_nid = spec->dig_out;\r\n}\r\nstatic int ca0110_parse_auto_config(struct hda_codec *codec)\r\n{\r\nstruct ca0110_spec *spec = codec->spec;\r\nint err;\r\nerr = snd_hda_parse_pin_def_config(codec, &spec->autocfg, NULL);\r\nif (err < 0)\r\nreturn err;\r\nparse_line_outs(codec);\r\nparse_hp_out(codec);\r\nparse_digital(codec);\r\nparse_input(codec);\r\nreturn 0;\r\n}\r\nstatic int patch_ca0110(struct hda_codec *codec)\r\n{\r\nstruct ca0110_spec *spec;\r\nint err;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->spec = spec;\r\ncodec->bus->needs_damn_long_delay = 1;\r\nerr = ca0110_parse_auto_config(codec);\r\nif (err < 0)\r\ngoto error;\r\ncodec->patch_ops = ca0110_patch_ops;\r\nreturn 0;\r\nerror:\r\nkfree(codec->spec);\r\ncodec->spec = NULL;\r\nreturn err;\r\n}\r\nstatic int __init patch_ca0110_init(void)\r\n{\r\nreturn snd_hda_add_codec_preset(&ca0110_list);\r\n}\r\nstatic void __exit patch_ca0110_exit(void)\r\n{\r\nsnd_hda_delete_codec_preset(&ca0110_list);\r\n}
