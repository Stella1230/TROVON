static void omap_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct omap_encoder *omap_encoder = to_omap_encoder(encoder);\r\nDBG("%s", omap_encoder->mgr->name);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(omap_encoder);\r\n}\r\nstatic void omap_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct omap_encoder *omap_encoder = to_omap_encoder(encoder);\r\nDBG("%s: %d", omap_encoder->mgr->name, mode);\r\n}\r\nstatic bool omap_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct omap_encoder *omap_encoder = to_omap_encoder(encoder);\r\nDBG("%s", omap_encoder->mgr->name);\r\nreturn true;\r\n}\r\nstatic void omap_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct omap_encoder *omap_encoder = to_omap_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nint i;\r\nmode = adjusted_mode;\r\nDBG("%s: set mode: %dx%d", omap_encoder->mgr->name,\r\nmode->hdisplay, mode->vdisplay);\r\nfor (i = 0; i < priv->num_connectors; i++) {\r\nstruct drm_connector *connector = priv->connectors[i];\r\nif (connector->encoder == encoder) {\r\nomap_connector_mode_set(connector, mode);\r\n}\r\n}\r\n}\r\nstatic void omap_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct omap_encoder *omap_encoder = to_omap_encoder(encoder);\r\nstruct drm_encoder_helper_funcs *encoder_funcs =\r\nencoder->helper_private;\r\nDBG("%s", omap_encoder->mgr->name);\r\nencoder_funcs->dpms(encoder, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic void omap_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nstruct omap_encoder *omap_encoder = to_omap_encoder(encoder);\r\nstruct drm_encoder_helper_funcs *encoder_funcs =\r\nencoder->helper_private;\r\nDBG("%s", omap_encoder->mgr->name);\r\nomap_encoder->mgr->apply(omap_encoder->mgr);\r\nencoder_funcs->dpms(encoder, DRM_MODE_DPMS_ON);\r\n}\r\nstruct omap_overlay_manager *omap_encoder_get_manager(\r\nstruct drm_encoder *encoder)\r\n{\r\nstruct omap_encoder *omap_encoder = to_omap_encoder(encoder);\r\nreturn omap_encoder->mgr;\r\n}\r\nstruct drm_encoder *omap_encoder_init(struct drm_device *dev,\r\nstruct omap_overlay_manager *mgr)\r\n{\r\nstruct drm_encoder *encoder = NULL;\r\nstruct omap_encoder *omap_encoder;\r\nstruct omap_overlay_manager_info info;\r\nint ret;\r\nDBG("%s", mgr->name);\r\nomap_encoder = kzalloc(sizeof(*omap_encoder), GFP_KERNEL);\r\nif (!omap_encoder) {\r\ndev_err(dev->dev, "could not allocate encoder\n");\r\ngoto fail;\r\n}\r\nomap_encoder->mgr = mgr;\r\nencoder = &omap_encoder->base;\r\ndrm_encoder_init(dev, encoder, &omap_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS);\r\ndrm_encoder_helper_add(encoder, &omap_encoder_helper_funcs);\r\nmgr->get_manager_info(mgr, &info);\r\ninfo.default_color = 0x00000000;\r\ninfo.trans_key = 0x00000000;\r\ninfo.trans_key_type = OMAP_DSS_COLOR_KEY_GFX_DST;\r\ninfo.trans_enabled = false;\r\nret = mgr->set_manager_info(mgr, &info);\r\nif (ret) {\r\ndev_err(dev->dev, "could not set manager info\n");\r\ngoto fail;\r\n}\r\nret = mgr->apply(mgr);\r\nif (ret) {\r\ndev_err(dev->dev, "could not apply\n");\r\ngoto fail;\r\n}\r\nreturn encoder;\r\nfail:\r\nif (encoder) {\r\nomap_encoder_destroy(encoder);\r\n}\r\nreturn NULL;\r\n}
