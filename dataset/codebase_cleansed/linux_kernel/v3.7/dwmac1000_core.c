static void dwmac1000_core_init(void __iomem *ioaddr)\r\n{\r\nu32 value = readl(ioaddr + GMAC_CONTROL);\r\nvalue |= GMAC_CORE_INIT;\r\nwritel(value, ioaddr + GMAC_CONTROL);\r\nwritel(0x207, ioaddr + GMAC_INT_MASK);\r\n#ifdef STMMAC_VLAN_TAG_USED\r\nwritel(0x0, ioaddr + GMAC_VLAN_TAG);\r\n#endif\r\n}\r\nstatic int dwmac1000_rx_ipc_enable(void __iomem *ioaddr)\r\n{\r\nu32 value = readl(ioaddr + GMAC_CONTROL);\r\nvalue |= GMAC_CONTROL_IPC;\r\nwritel(value, ioaddr + GMAC_CONTROL);\r\nvalue = readl(ioaddr + GMAC_CONTROL);\r\nreturn !!(value & GMAC_CONTROL_IPC);\r\n}\r\nstatic void dwmac1000_dump_regs(void __iomem *ioaddr)\r\n{\r\nint i;\r\npr_info("\tDWMAC1000 regs (base addr = 0x%p)\n", ioaddr);\r\nfor (i = 0; i < 55; i++) {\r\nint offset = i * 4;\r\npr_info("\tReg No. %d (offset 0x%x): 0x%08x\n", i,\r\noffset, readl(ioaddr + offset));\r\n}\r\n}\r\nstatic void dwmac1000_set_umac_addr(void __iomem *ioaddr, unsigned char *addr,\r\nunsigned int reg_n)\r\n{\r\nstmmac_set_mac_addr(ioaddr, addr, GMAC_ADDR_HIGH(reg_n),\r\nGMAC_ADDR_LOW(reg_n));\r\n}\r\nstatic void dwmac1000_get_umac_addr(void __iomem *ioaddr, unsigned char *addr,\r\nunsigned int reg_n)\r\n{\r\nstmmac_get_mac_addr(ioaddr, addr, GMAC_ADDR_HIGH(reg_n),\r\nGMAC_ADDR_LOW(reg_n));\r\n}\r\nstatic void dwmac1000_set_filter(struct net_device *dev, int id)\r\n{\r\nvoid __iomem *ioaddr = (void __iomem *) dev->base_addr;\r\nunsigned int value = 0;\r\nunsigned int perfect_addr_number;\r\nCHIP_DBG(KERN_INFO "%s: # mcasts %d, # unicast %d\n",\r\n__func__, netdev_mc_count(dev), netdev_uc_count(dev));\r\nif (dev->flags & IFF_PROMISC)\r\nvalue = GMAC_FRAME_FILTER_PR;\r\nelse if ((netdev_mc_count(dev) > HASH_TABLE_SIZE)\r\n|| (dev->flags & IFF_ALLMULTI)) {\r\nvalue = GMAC_FRAME_FILTER_PM;\r\nwritel(0xffffffff, ioaddr + GMAC_HASH_HIGH);\r\nwritel(0xffffffff, ioaddr + GMAC_HASH_LOW);\r\n} else if (!netdev_mc_empty(dev)) {\r\nu32 mc_filter[2];\r\nstruct netdev_hw_addr *ha;\r\nvalue = GMAC_FRAME_FILTER_HMC;\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit_nr =\r\nbitrev32(~crc32_le(~0, ha->addr, 6)) >> 26;\r\nmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\r\n}\r\nwritel(mc_filter[0], ioaddr + GMAC_HASH_LOW);\r\nwritel(mc_filter[1], ioaddr + GMAC_HASH_HIGH);\r\n}\r\nif (id > DWMAC_CORE_3_40)\r\nperfect_addr_number = GMAC_MAX_PERFECT_ADDRESSES;\r\nelse\r\nperfect_addr_number = GMAC_MAX_PERFECT_ADDRESSES / 2;\r\nif (netdev_uc_count(dev) > perfect_addr_number)\r\nvalue |= GMAC_FRAME_FILTER_PR;\r\nelse {\r\nint reg = 1;\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_uc_addr(ha, dev) {\r\ndwmac1000_set_umac_addr(ioaddr, ha->addr, reg);\r\nreg++;\r\n}\r\n}\r\n#ifdef FRAME_FILTER_DEBUG\r\nvalue |= GMAC_FRAME_FILTER_RA;\r\n#endif\r\nwritel(value, ioaddr + GMAC_FRAME_FILTER);\r\nCHIP_DBG(KERN_INFO "\tFrame Filter reg: 0x%08x\n\tHash regs: "\r\n"HI 0x%08x, LO 0x%08x\n", readl(ioaddr + GMAC_FRAME_FILTER),\r\nreadl(ioaddr + GMAC_HASH_HIGH), readl(ioaddr + GMAC_HASH_LOW));\r\n}\r\nstatic void dwmac1000_flow_ctrl(void __iomem *ioaddr, unsigned int duplex,\r\nunsigned int fc, unsigned int pause_time)\r\n{\r\nunsigned int flow = 0;\r\nCHIP_DBG(KERN_DEBUG "GMAC Flow-Control:\n");\r\nif (fc & FLOW_RX) {\r\nCHIP_DBG(KERN_DEBUG "\tReceive Flow-Control ON\n");\r\nflow |= GMAC_FLOW_CTRL_RFE;\r\n}\r\nif (fc & FLOW_TX) {\r\nCHIP_DBG(KERN_DEBUG "\tTransmit Flow-Control ON\n");\r\nflow |= GMAC_FLOW_CTRL_TFE;\r\n}\r\nif (duplex) {\r\nCHIP_DBG(KERN_DEBUG "\tduplex mode: PAUSE %d\n", pause_time);\r\nflow |= (pause_time << GMAC_FLOW_CTRL_PT_SHIFT);\r\n}\r\nwritel(flow, ioaddr + GMAC_FLOW_CTRL);\r\n}\r\nstatic void dwmac1000_pmt(void __iomem *ioaddr, unsigned long mode)\r\n{\r\nunsigned int pmt = 0;\r\nif (mode & WAKE_MAGIC) {\r\nCHIP_DBG(KERN_DEBUG "GMAC: WOL Magic frame\n");\r\npmt |= power_down | magic_pkt_en;\r\n}\r\nif (mode & WAKE_UCAST) {\r\nCHIP_DBG(KERN_DEBUG "GMAC: WOL on global unicast\n");\r\npmt |= global_unicast;\r\n}\r\nwritel(pmt, ioaddr + GMAC_PMT);\r\n}\r\nstatic int dwmac1000_irq_status(void __iomem *ioaddr)\r\n{\r\nu32 intr_status = readl(ioaddr + GMAC_INT_STATUS);\r\nint status = 0;\r\nif ((intr_status & mmc_tx_irq)) {\r\nCHIP_DBG(KERN_INFO "GMAC: MMC tx interrupt: 0x%08x\n",\r\nreadl(ioaddr + GMAC_MMC_TX_INTR));\r\nstatus |= core_mmc_tx_irq;\r\n}\r\nif (unlikely(intr_status & mmc_rx_irq)) {\r\nCHIP_DBG(KERN_INFO "GMAC: MMC rx interrupt: 0x%08x\n",\r\nreadl(ioaddr + GMAC_MMC_RX_INTR));\r\nstatus |= core_mmc_rx_irq;\r\n}\r\nif (unlikely(intr_status & mmc_rx_csum_offload_irq)) {\r\nCHIP_DBG(KERN_INFO "GMAC: MMC rx csum offload: 0x%08x\n",\r\nreadl(ioaddr + GMAC_MMC_RX_CSUM_OFFLOAD));\r\nstatus |= core_mmc_rx_csum_offload_irq;\r\n}\r\nif (unlikely(intr_status & pmt_irq)) {\r\nCHIP_DBG(KERN_INFO "GMAC: received Magic frame\n");\r\nreadl(ioaddr + GMAC_PMT);\r\nstatus |= core_irq_receive_pmt_irq;\r\n}\r\nif (intr_status & lpiis_irq) {\r\nu32 lpi_status = readl(ioaddr + LPI_CTRL_STATUS);\r\nif (lpi_status & LPI_CTRL_STATUS_TLPIEN) {\r\nCHIP_DBG(KERN_INFO "GMAC TX entered in LPI\n");\r\nstatus |= core_irq_tx_path_in_lpi_mode;\r\n}\r\nif (lpi_status & LPI_CTRL_STATUS_TLPIEX) {\r\nCHIP_DBG(KERN_INFO "GMAC TX exit from LPI\n");\r\nstatus |= core_irq_tx_path_exit_lpi_mode;\r\n}\r\nif (lpi_status & LPI_CTRL_STATUS_RLPIEN) {\r\nCHIP_DBG(KERN_INFO "GMAC RX entered in LPI\n");\r\nstatus |= core_irq_rx_path_in_lpi_mode;\r\n}\r\nif (lpi_status & LPI_CTRL_STATUS_RLPIEX) {\r\nCHIP_DBG(KERN_INFO "GMAC RX exit from LPI\n");\r\nstatus |= core_irq_rx_path_exit_lpi_mode;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic void dwmac1000_set_eee_mode(void __iomem *ioaddr)\r\n{\r\nu32 value;\r\nvalue = readl(ioaddr + LPI_CTRL_STATUS);\r\nvalue |= LPI_CTRL_STATUS_LPIEN | LPI_CTRL_STATUS_LPITXA;\r\nwritel(value, ioaddr + LPI_CTRL_STATUS);\r\n}\r\nstatic void dwmac1000_reset_eee_mode(void __iomem *ioaddr)\r\n{\r\nu32 value;\r\nvalue = readl(ioaddr + LPI_CTRL_STATUS);\r\nvalue &= ~(LPI_CTRL_STATUS_LPIEN | LPI_CTRL_STATUS_LPITXA);\r\nwritel(value, ioaddr + LPI_CTRL_STATUS);\r\n}\r\nstatic void dwmac1000_set_eee_pls(void __iomem *ioaddr, int link)\r\n{\r\nu32 value;\r\nvalue = readl(ioaddr + LPI_CTRL_STATUS);\r\nif (link)\r\nvalue |= LPI_CTRL_STATUS_PLS;\r\nelse\r\nvalue &= ~LPI_CTRL_STATUS_PLS;\r\nwritel(value, ioaddr + LPI_CTRL_STATUS);\r\n}\r\nstatic void dwmac1000_set_eee_timer(void __iomem *ioaddr, int ls, int tw)\r\n{\r\nint value = ((tw & 0xffff)) | ((ls & 0x7ff) << 16);\r\nwritel(value, ioaddr + LPI_TIMER_CTRL);\r\n}\r\nstruct mac_device_info *dwmac1000_setup(void __iomem *ioaddr)\r\n{\r\nstruct mac_device_info *mac;\r\nu32 hwid = readl(ioaddr + GMAC_VERSION);\r\nmac = kzalloc(sizeof(const struct mac_device_info), GFP_KERNEL);\r\nif (!mac)\r\nreturn NULL;\r\nmac->mac = &dwmac1000_ops;\r\nmac->dma = &dwmac1000_dma_ops;\r\nmac->link.port = GMAC_CONTROL_PS;\r\nmac->link.duplex = GMAC_CONTROL_DM;\r\nmac->link.speed = GMAC_CONTROL_FES;\r\nmac->mii.addr = GMAC_MII_ADDR;\r\nmac->mii.data = GMAC_MII_DATA;\r\nmac->synopsys_uid = hwid;\r\nreturn mac;\r\n}
