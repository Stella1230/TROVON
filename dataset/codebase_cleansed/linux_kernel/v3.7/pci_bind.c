static int acpi_pci_unbind(struct acpi_device *device)\r\n{\r\nstruct pci_dev *dev;\r\ndev = acpi_get_pci_dev(device->handle);\r\nif (!dev)\r\ngoto out;\r\ndevice_set_run_wake(&dev->dev, false);\r\npci_acpi_remove_pm_notifier(device);\r\nif (!dev->subordinate)\r\ngoto out;\r\nacpi_pci_irq_del_prt(dev->subordinate);\r\ndevice->ops.bind = NULL;\r\ndevice->ops.unbind = NULL;\r\nout:\r\npci_dev_put(dev);\r\nreturn 0;\r\n}\r\nstatic int acpi_pci_bind(struct acpi_device *device)\r\n{\r\nacpi_status status;\r\nacpi_handle handle;\r\nstruct pci_bus *bus;\r\nstruct pci_dev *dev;\r\ndev = acpi_get_pci_dev(device->handle);\r\nif (!dev)\r\nreturn 0;\r\npci_acpi_add_pm_notifier(device, dev);\r\nif (device->wakeup.flags.run_wake)\r\ndevice_set_run_wake(&dev->dev, true);\r\nif (dev->subordinate) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Device %04x:%02x:%02x.%d is a PCI bridge\n",\r\npci_domain_nr(dev->bus), dev->bus->number,\r\nPCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn)));\r\ndevice->ops.bind = acpi_pci_bind;\r\ndevice->ops.unbind = acpi_pci_unbind;\r\n}\r\nstatus = acpi_get_handle(device->handle, METHOD_NAME__PRT, &handle);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\nif (dev->subordinate)\r\nbus = dev->subordinate;\r\nelse\r\nbus = dev->bus;\r\nacpi_pci_irq_add_prt(device->handle, bus);\r\nout:\r\npci_dev_put(dev);\r\nreturn 0;\r\n}\r\nint acpi_pci_bind_root(struct acpi_device *device)\r\n{\r\ndevice->ops.bind = acpi_pci_bind;\r\ndevice->ops.unbind = acpi_pci_unbind;\r\nreturn 0;\r\n}
