static inline int pca95xx_num_input_regs(int bits)\r\n{\r\nreturn (bits + 7) / 8;\r\n}\r\nstatic inline int pca95xx_num_led_regs(int bits)\r\n{\r\nreturn (bits + 3) / 4;\r\n}\r\nstatic inline u8 pca955x_ledsel(u8 oldval, int led_num, int state)\r\n{\r\nreturn (oldval & (~(0x3 << (led_num << 1)))) |\r\n((state & 0x3) << (led_num << 1));\r\n}\r\nstatic void pca955x_write_psc(struct i2c_client *client, int n, u8 val)\r\n{\r\nstruct pca955x *pca955x = i2c_get_clientdata(client);\r\ni2c_smbus_write_byte_data(client,\r\npca95xx_num_input_regs(pca955x->chipdef->bits) + 2*n,\r\nval);\r\n}\r\nstatic void pca955x_write_pwm(struct i2c_client *client, int n, u8 val)\r\n{\r\nstruct pca955x *pca955x = i2c_get_clientdata(client);\r\ni2c_smbus_write_byte_data(client,\r\npca95xx_num_input_regs(pca955x->chipdef->bits) + 1 + 2*n,\r\nval);\r\n}\r\nstatic void pca955x_write_ls(struct i2c_client *client, int n, u8 val)\r\n{\r\nstruct pca955x *pca955x = i2c_get_clientdata(client);\r\ni2c_smbus_write_byte_data(client,\r\npca95xx_num_input_regs(pca955x->chipdef->bits) + 4 + n,\r\nval);\r\n}\r\nstatic u8 pca955x_read_ls(struct i2c_client *client, int n)\r\n{\r\nstruct pca955x *pca955x = i2c_get_clientdata(client);\r\nreturn (u8) i2c_smbus_read_byte_data(client,\r\npca95xx_num_input_regs(pca955x->chipdef->bits) + 4 + n);\r\n}\r\nstatic void pca955x_led_work(struct work_struct *work)\r\n{\r\nstruct pca955x_led *pca955x_led;\r\nstruct pca955x *pca955x;\r\nu8 ls;\r\nint chip_ls;\r\nint ls_led;\r\npca955x_led = container_of(work, struct pca955x_led, work);\r\npca955x = pca955x_led->pca955x;\r\nchip_ls = pca955x_led->led_num / 4;\r\nls_led = pca955x_led->led_num % 4;\r\nmutex_lock(&pca955x->lock);\r\nls = pca955x_read_ls(pca955x->client, chip_ls);\r\nswitch (pca955x_led->brightness) {\r\ncase LED_FULL:\r\nls = pca955x_ledsel(ls, ls_led, PCA955X_LS_LED_ON);\r\nbreak;\r\ncase LED_OFF:\r\nls = pca955x_ledsel(ls, ls_led, PCA955X_LS_LED_OFF);\r\nbreak;\r\ncase LED_HALF:\r\nls = pca955x_ledsel(ls, ls_led, PCA955X_LS_BLINK0);\r\nbreak;\r\ndefault:\r\npca955x_write_pwm(pca955x->client, 1,\r\n255 - pca955x_led->brightness);\r\nls = pca955x_ledsel(ls, ls_led, PCA955X_LS_BLINK1);\r\nbreak;\r\n}\r\npca955x_write_ls(pca955x->client, chip_ls, ls);\r\nmutex_unlock(&pca955x->lock);\r\n}\r\nstatic void pca955x_led_set(struct led_classdev *led_cdev, enum led_brightness value)\r\n{\r\nstruct pca955x_led *pca955x;\r\npca955x = container_of(led_cdev, struct pca955x_led, led_cdev);\r\npca955x->brightness = value;\r\nschedule_work(&pca955x->work);\r\n}\r\nstatic int __devinit pca955x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pca955x *pca955x;\r\nstruct pca955x_led *pca955x_led;\r\nstruct pca955x_chipdef *chip;\r\nstruct i2c_adapter *adapter;\r\nstruct led_platform_data *pdata;\r\nint i, err;\r\nchip = &pca955x_chipdefs[id->driver_data];\r\nadapter = to_i2c_adapter(client->dev.parent);\r\npdata = client->dev.platform_data;\r\nif ((client->addr & ~((1 << chip->slv_addr_shift) - 1)) !=\r\nchip->slv_addr) {\r\ndev_err(&client->dev, "invalid slave address %02x\n",\r\nclient->addr);\r\nreturn -ENODEV;\r\n}\r\nprintk(KERN_INFO "leds-pca955x: Using %s %d-bit LED driver at "\r\n"slave address 0x%02x\n",\r\nid->name, chip->bits, client->addr);\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_I2C))\r\nreturn -EIO;\r\nif (pdata) {\r\nif (pdata->num_leds != chip->bits) {\r\ndev_err(&client->dev, "board info claims %d LEDs"\r\n" on a %d-bit chip\n",\r\npdata->num_leds, chip->bits);\r\nreturn -ENODEV;\r\n}\r\n}\r\npca955x = devm_kzalloc(&client->dev, sizeof(*pca955x), GFP_KERNEL);\r\nif (!pca955x)\r\nreturn -ENOMEM;\r\npca955x->leds = devm_kzalloc(&client->dev,\r\nsizeof(*pca955x_led) * chip->bits, GFP_KERNEL);\r\nif (!pca955x->leds)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, pca955x);\r\nmutex_init(&pca955x->lock);\r\npca955x->client = client;\r\npca955x->chipdef = chip;\r\nfor (i = 0; i < chip->bits; i++) {\r\npca955x_led = &pca955x->leds[i];\r\npca955x_led->led_num = i;\r\npca955x_led->pca955x = pca955x;\r\nif (pdata) {\r\nif (pdata->leds[i].name)\r\nsnprintf(pca955x_led->name,\r\nsizeof(pca955x_led->name), "pca955x:%s",\r\npdata->leds[i].name);\r\nif (pdata->leds[i].default_trigger)\r\npca955x_led->led_cdev.default_trigger =\r\npdata->leds[i].default_trigger;\r\n} else {\r\nsnprintf(pca955x_led->name, sizeof(pca955x_led->name),\r\n"pca955x:%d", i);\r\n}\r\npca955x_led->led_cdev.name = pca955x_led->name;\r\npca955x_led->led_cdev.brightness_set = pca955x_led_set;\r\nINIT_WORK(&pca955x_led->work, pca955x_led_work);\r\nerr = led_classdev_register(&client->dev,\r\n&pca955x_led->led_cdev);\r\nif (err < 0)\r\ngoto exit;\r\n}\r\nfor (i = 0; i < pca95xx_num_led_regs(chip->bits); i++)\r\npca955x_write_ls(client, i, 0x55);\r\npca955x_write_pwm(client, 0, 255-LED_HALF);\r\npca955x_write_pwm(client, 1, 0);\r\npca955x_write_psc(client, 0, 0);\r\npca955x_write_psc(client, 1, 0);\r\nreturn 0;\r\nexit:\r\nwhile (i--) {\r\nled_classdev_unregister(&pca955x->leds[i].led_cdev);\r\ncancel_work_sync(&pca955x->leds[i].work);\r\n}\r\nreturn err;\r\n}\r\nstatic int __devexit pca955x_remove(struct i2c_client *client)\r\n{\r\nstruct pca955x *pca955x = i2c_get_clientdata(client);\r\nint i;\r\nfor (i = 0; i < pca955x->chipdef->bits; i++) {\r\nled_classdev_unregister(&pca955x->leds[i].led_cdev);\r\ncancel_work_sync(&pca955x->leds[i].work);\r\n}\r\nreturn 0;\r\n}
