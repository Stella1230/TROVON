void zd_chip_init(struct zd_chip *chip,\r\nstruct ieee80211_hw *hw,\r\nstruct usb_interface *intf)\r\n{\r\nmemset(chip, 0, sizeof(*chip));\r\nmutex_init(&chip->mutex);\r\nzd_usb_init(&chip->usb, hw, intf);\r\nzd_rf_init(&chip->rf);\r\n}\r\nvoid zd_chip_clear(struct zd_chip *chip)\r\n{\r\nZD_ASSERT(!mutex_is_locked(&chip->mutex));\r\nzd_usb_clear(&chip->usb);\r\nzd_rf_clear(&chip->rf);\r\nmutex_destroy(&chip->mutex);\r\nZD_MEMCLEAR(chip, sizeof(*chip));\r\n}\r\nstatic int scnprint_mac_oui(struct zd_chip *chip, char *buffer, size_t size)\r\n{\r\nu8 *addr = zd_mac_get_perm_addr(zd_chip_to_mac(chip));\r\nreturn scnprintf(buffer, size, "%02x-%02x-%02x",\r\naddr[0], addr[1], addr[2]);\r\n}\r\nstatic int scnprint_id(struct zd_chip *chip, char *buffer, size_t size)\r\n{\r\nint i = 0;\r\ni = scnprintf(buffer, size, "zd1211%s chip ",\r\nzd_chip_is_zd1211b(chip) ? "b" : "");\r\ni += zd_usb_scnprint_id(&chip->usb, buffer+i, size-i);\r\ni += scnprintf(buffer+i, size-i, " ");\r\ni += scnprint_mac_oui(chip, buffer+i, size-i);\r\ni += scnprintf(buffer+i, size-i, " ");\r\ni += zd_rf_scnprint_id(&chip->rf, buffer+i, size-i);\r\ni += scnprintf(buffer+i, size-i, " pa%1x %c%c%c%c%c", chip->pa_type,\r\nchip->patch_cck_gain ? 'g' : '-',\r\nchip->patch_cr157 ? '7' : '-',\r\nchip->patch_6m_band_edge ? '6' : '-',\r\nchip->new_phy_layout ? 'N' : '-',\r\nchip->al2230s_bit ? 'S' : '-');\r\nreturn i;\r\n}\r\nstatic void print_id(struct zd_chip *chip)\r\n{\r\nchar buffer[80];\r\nscnprint_id(chip, buffer, sizeof(buffer));\r\nbuffer[sizeof(buffer)-1] = 0;\r\ndev_info(zd_chip_dev(chip), "%s\n", buffer);\r\n}\r\nstatic zd_addr_t inc_addr(zd_addr_t addr)\r\n{\r\nu16 a = (u16)addr;\r\nif ((a & 0xf000) == CR_START)\r\na += 2;\r\nelse\r\na += 1;\r\nreturn (zd_addr_t)a;\r\n}\r\nint zd_ioread32v_locked(struct zd_chip *chip, u32 *values, const zd_addr_t *addr,\r\nunsigned int count)\r\n{\r\nint r;\r\nint i;\r\nzd_addr_t a16[USB_MAX_IOREAD32_COUNT * 2];\r\nu16 v16[USB_MAX_IOREAD32_COUNT * 2];\r\nunsigned int count16;\r\nif (count > USB_MAX_IOREAD32_COUNT)\r\nreturn -EINVAL;\r\ncount16 = 2 * count;\r\nBUG_ON(count16 * sizeof(zd_addr_t) > sizeof(a16));\r\nBUG_ON(count16 * sizeof(u16) > sizeof(v16));\r\nfor (i = 0; i < count; i++) {\r\nint j = 2*i;\r\na16[j] = inc_addr(addr[i]);\r\na16[j+1] = addr[i];\r\n}\r\nr = zd_ioread16v_locked(chip, v16, a16, count16);\r\nif (r) {\r\ndev_dbg_f(zd_chip_dev(chip),\r\n"error: zd_ioread16v_locked. Error number %d\n", r);\r\nreturn r;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nint j = 2*i;\r\nvalues[i] = (v16[j] << 16) | v16[j+1];\r\n}\r\nreturn 0;\r\n}\r\nstatic int _zd_iowrite32v_async_locked(struct zd_chip *chip,\r\nconst struct zd_ioreq32 *ioreqs,\r\nunsigned int count)\r\n{\r\nint i, j, r;\r\nstruct zd_ioreq16 ioreqs16[USB_MAX_IOWRITE32_COUNT * 2];\r\nunsigned int count16;\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nif (count == 0)\r\nreturn 0;\r\nif (count > USB_MAX_IOWRITE32_COUNT)\r\nreturn -EINVAL;\r\ncount16 = 2 * count;\r\nBUG_ON(count16 * sizeof(struct zd_ioreq16) > sizeof(ioreqs16));\r\nfor (i = 0; i < count; i++) {\r\nj = 2*i;\r\nioreqs16[j].value = ioreqs[i].value >> 16;\r\nioreqs16[j].addr = inc_addr(ioreqs[i].addr);\r\nioreqs16[j+1].value = ioreqs[i].value;\r\nioreqs16[j+1].addr = ioreqs[i].addr;\r\n}\r\nr = zd_usb_iowrite16v_async(&chip->usb, ioreqs16, count16);\r\n#ifdef DEBUG\r\nif (r) {\r\ndev_dbg_f(zd_chip_dev(chip),\r\n"error %d in zd_usb_write16v\n", r);\r\n}\r\n#endif\r\nreturn r;\r\n}\r\nint _zd_iowrite32v_locked(struct zd_chip *chip, const struct zd_ioreq32 *ioreqs,\r\nunsigned int count)\r\n{\r\nint r;\r\nzd_usb_iowrite16v_async_start(&chip->usb);\r\nr = _zd_iowrite32v_async_locked(chip, ioreqs, count);\r\nif (r) {\r\nzd_usb_iowrite16v_async_end(&chip->usb, 0);\r\nreturn r;\r\n}\r\nreturn zd_usb_iowrite16v_async_end(&chip->usb, 50 );\r\n}\r\nint zd_iowrite16a_locked(struct zd_chip *chip,\r\nconst struct zd_ioreq16 *ioreqs, unsigned int count)\r\n{\r\nint r;\r\nunsigned int i, j, t, max;\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nzd_usb_iowrite16v_async_start(&chip->usb);\r\nfor (i = 0; i < count; i += j + t) {\r\nt = 0;\r\nmax = count-i;\r\nif (max > USB_MAX_IOWRITE16_COUNT)\r\nmax = USB_MAX_IOWRITE16_COUNT;\r\nfor (j = 0; j < max; j++) {\r\nif (!ioreqs[i+j].addr) {\r\nt = 1;\r\nbreak;\r\n}\r\n}\r\nr = zd_usb_iowrite16v_async(&chip->usb, &ioreqs[i], j);\r\nif (r) {\r\nzd_usb_iowrite16v_async_end(&chip->usb, 0);\r\ndev_dbg_f(zd_chip_dev(chip),\r\n"error zd_usb_iowrite16v. Error number %d\n",\r\nr);\r\nreturn r;\r\n}\r\n}\r\nreturn zd_usb_iowrite16v_async_end(&chip->usb, 50 );\r\n}\r\nint zd_iowrite32a_locked(struct zd_chip *chip,\r\nconst struct zd_ioreq32 *ioreqs, unsigned int count)\r\n{\r\nint r;\r\nunsigned int i, j, t, max;\r\nzd_usb_iowrite16v_async_start(&chip->usb);\r\nfor (i = 0; i < count; i += j + t) {\r\nt = 0;\r\nmax = count-i;\r\nif (max > USB_MAX_IOWRITE32_COUNT)\r\nmax = USB_MAX_IOWRITE32_COUNT;\r\nfor (j = 0; j < max; j++) {\r\nif (!ioreqs[i+j].addr) {\r\nt = 1;\r\nbreak;\r\n}\r\n}\r\nr = _zd_iowrite32v_async_locked(chip, &ioreqs[i], j);\r\nif (r) {\r\nzd_usb_iowrite16v_async_end(&chip->usb, 0);\r\ndev_dbg_f(zd_chip_dev(chip),\r\n"error _zd_iowrite32v_locked."\r\n" Error number %d\n", r);\r\nreturn r;\r\n}\r\n}\r\nreturn zd_usb_iowrite16v_async_end(&chip->usb, 50 );\r\n}\r\nint zd_ioread16(struct zd_chip *chip, zd_addr_t addr, u16 *value)\r\n{\r\nint r;\r\nmutex_lock(&chip->mutex);\r\nr = zd_ioread16_locked(chip, value, addr);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nint zd_ioread32(struct zd_chip *chip, zd_addr_t addr, u32 *value)\r\n{\r\nint r;\r\nmutex_lock(&chip->mutex);\r\nr = zd_ioread32_locked(chip, value, addr);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nint zd_iowrite16(struct zd_chip *chip, zd_addr_t addr, u16 value)\r\n{\r\nint r;\r\nmutex_lock(&chip->mutex);\r\nr = zd_iowrite16_locked(chip, value, addr);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nint zd_iowrite32(struct zd_chip *chip, zd_addr_t addr, u32 value)\r\n{\r\nint r;\r\nmutex_lock(&chip->mutex);\r\nr = zd_iowrite32_locked(chip, value, addr);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nint zd_ioread32v(struct zd_chip *chip, const zd_addr_t *addresses,\r\nu32 *values, unsigned int count)\r\n{\r\nint r;\r\nmutex_lock(&chip->mutex);\r\nr = zd_ioread32v_locked(chip, values, addresses, count);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nint zd_iowrite32a(struct zd_chip *chip, const struct zd_ioreq32 *ioreqs,\r\nunsigned int count)\r\n{\r\nint r;\r\nmutex_lock(&chip->mutex);\r\nr = zd_iowrite32a_locked(chip, ioreqs, count);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nstatic int read_pod(struct zd_chip *chip, u8 *rf_type)\r\n{\r\nint r;\r\nu32 value;\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nr = zd_ioread32_locked(chip, &value, E2P_POD);\r\nif (r)\r\ngoto error;\r\ndev_dbg_f(zd_chip_dev(chip), "E2P_POD %#010x\n", value);\r\n*rf_type = value & 0x0f;\r\nchip->pa_type = (value >> 16) & 0x0f;\r\nchip->patch_cck_gain = (value >> 8) & 0x1;\r\nchip->patch_cr157 = (value >> 13) & 0x1;\r\nchip->patch_6m_band_edge = (value >> 21) & 0x1;\r\nchip->new_phy_layout = (value >> 31) & 0x1;\r\nchip->al2230s_bit = (value >> 7) & 0x1;\r\nchip->link_led = ((value >> 4) & 1) ? LED1 : LED2;\r\nchip->supports_tx_led = 1;\r\nif (value & (1 << 24)) {\r\nif (value & (1 << 29))\r\nchip->supports_tx_led = 0;\r\n}\r\ndev_dbg_f(zd_chip_dev(chip),\r\n"RF %s %#01x PA type %#01x patch CCK %d patch CR157 %d "\r\n"patch 6M %d new PHY %d link LED%d tx led %d\n",\r\nzd_rf_name(*rf_type), *rf_type,\r\nchip->pa_type, chip->patch_cck_gain,\r\nchip->patch_cr157, chip->patch_6m_band_edge,\r\nchip->new_phy_layout,\r\nchip->link_led == LED1 ? 1 : 2,\r\nchip->supports_tx_led);\r\nreturn 0;\r\nerror:\r\n*rf_type = 0;\r\nchip->pa_type = 0;\r\nchip->patch_cck_gain = 0;\r\nchip->patch_cr157 = 0;\r\nchip->patch_6m_band_edge = 0;\r\nchip->new_phy_layout = 0;\r\nreturn r;\r\n}\r\nstatic int zd_write_mac_addr_common(struct zd_chip *chip, const u8 *mac_addr,\r\nconst struct zd_ioreq32 *in_reqs,\r\nconst char *type)\r\n{\r\nint r;\r\nstruct zd_ioreq32 reqs[2] = {in_reqs[0], in_reqs[1]};\r\nif (mac_addr) {\r\nreqs[0].value = (mac_addr[3] << 24)\r\n| (mac_addr[2] << 16)\r\n| (mac_addr[1] << 8)\r\n| mac_addr[0];\r\nreqs[1].value = (mac_addr[5] << 8)\r\n| mac_addr[4];\r\ndev_dbg_f(zd_chip_dev(chip), "%s addr %pM\n", type, mac_addr);\r\n} else {\r\ndev_dbg_f(zd_chip_dev(chip), "set NULL %s\n", type);\r\n}\r\nmutex_lock(&chip->mutex);\r\nr = zd_iowrite32a_locked(chip, reqs, ARRAY_SIZE(reqs));\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nint zd_write_mac_addr(struct zd_chip *chip, const u8 *mac_addr)\r\n{\r\nstatic const struct zd_ioreq32 reqs[2] = {\r\n[0] = { .addr = CR_MAC_ADDR_P1 },\r\n[1] = { .addr = CR_MAC_ADDR_P2 },\r\n};\r\nreturn zd_write_mac_addr_common(chip, mac_addr, reqs, "mac");\r\n}\r\nint zd_write_bssid(struct zd_chip *chip, const u8 *bssid)\r\n{\r\nstatic const struct zd_ioreq32 reqs[2] = {\r\n[0] = { .addr = CR_BSSID_P1 },\r\n[1] = { .addr = CR_BSSID_P2 },\r\n};\r\nreturn zd_write_mac_addr_common(chip, bssid, reqs, "bssid");\r\n}\r\nint zd_read_regdomain(struct zd_chip *chip, u8 *regdomain)\r\n{\r\nint r;\r\nu32 value;\r\nmutex_lock(&chip->mutex);\r\nr = zd_ioread32_locked(chip, &value, E2P_SUBID);\r\nmutex_unlock(&chip->mutex);\r\nif (r)\r\nreturn r;\r\n*regdomain = value >> 16;\r\ndev_dbg_f(zd_chip_dev(chip), "regdomain: %#04x\n", *regdomain);\r\nreturn 0;\r\n}\r\nstatic int read_values(struct zd_chip *chip, u8 *values, size_t count,\r\nzd_addr_t e2p_addr, u32 guard)\r\n{\r\nint r;\r\nint i;\r\nu32 v;\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nfor (i = 0;;) {\r\nr = zd_ioread32_locked(chip, &v,\r\n(zd_addr_t)((u16)e2p_addr+i/2));\r\nif (r)\r\nreturn r;\r\nv -= guard;\r\nif (i+4 < count) {\r\nvalues[i++] = v;\r\nvalues[i++] = v >> 8;\r\nvalues[i++] = v >> 16;\r\nvalues[i++] = v >> 24;\r\ncontinue;\r\n}\r\nfor (;i < count; i++)\r\nvalues[i] = v >> (8*(i%3));\r\nreturn 0;\r\n}\r\n}\r\nstatic int read_pwr_cal_values(struct zd_chip *chip)\r\n{\r\nreturn read_values(chip, chip->pwr_cal_values,\r\nE2P_CHANNEL_COUNT, E2P_PWR_CAL_VALUE1,\r\n0);\r\n}\r\nstatic int read_pwr_int_values(struct zd_chip *chip)\r\n{\r\nreturn read_values(chip, chip->pwr_int_values,\r\nE2P_CHANNEL_COUNT, E2P_PWR_INT_VALUE1,\r\nE2P_PWR_INT_GUARD);\r\n}\r\nstatic int read_ofdm_cal_values(struct zd_chip *chip)\r\n{\r\nint r;\r\nint i;\r\nstatic const zd_addr_t addresses[] = {\r\nE2P_36M_CAL_VALUE1,\r\nE2P_48M_CAL_VALUE1,\r\nE2P_54M_CAL_VALUE1,\r\n};\r\nfor (i = 0; i < 3; i++) {\r\nr = read_values(chip, chip->ofdm_cal_values[i],\r\nE2P_CHANNEL_COUNT, addresses[i], 0);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_cal_int_tables(struct zd_chip *chip)\r\n{\r\nint r;\r\nr = read_pwr_cal_values(chip);\r\nif (r)\r\nreturn r;\r\nr = read_pwr_int_values(chip);\r\nif (r)\r\nreturn r;\r\nr = read_ofdm_cal_values(chip);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nint zd_chip_lock_phy_regs(struct zd_chip *chip)\r\n{\r\nint r;\r\nu32 tmp;\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nr = zd_ioread32_locked(chip, &tmp, CR_REG1);\r\nif (r) {\r\ndev_err(zd_chip_dev(chip), "error ioread32(CR_REG1): %d\n", r);\r\nreturn r;\r\n}\r\ntmp &= ~UNLOCK_PHY_REGS;\r\nr = zd_iowrite32_locked(chip, tmp, CR_REG1);\r\nif (r)\r\ndev_err(zd_chip_dev(chip), "error iowrite32(CR_REG1): %d\n", r);\r\nreturn r;\r\n}\r\nint zd_chip_unlock_phy_regs(struct zd_chip *chip)\r\n{\r\nint r;\r\nu32 tmp;\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nr = zd_ioread32_locked(chip, &tmp, CR_REG1);\r\nif (r) {\r\ndev_err(zd_chip_dev(chip),\r\n"error ioread32(CR_REG1): %d\n", r);\r\nreturn r;\r\n}\r\ntmp |= UNLOCK_PHY_REGS;\r\nr = zd_iowrite32_locked(chip, tmp, CR_REG1);\r\nif (r)\r\ndev_err(zd_chip_dev(chip), "error iowrite32(CR_REG1): %d\n", r);\r\nreturn r;\r\n}\r\nstatic int patch_cr157(struct zd_chip *chip)\r\n{\r\nint r;\r\nu16 value;\r\nif (!chip->patch_cr157)\r\nreturn 0;\r\nr = zd_ioread16_locked(chip, &value, E2P_PHY_REG);\r\nif (r)\r\nreturn r;\r\ndev_dbg_f(zd_chip_dev(chip), "patching value %x\n", value >> 8);\r\nreturn zd_iowrite32_locked(chip, value >> 8, ZD_CR157);\r\n}\r\nstatic int patch_6m_band_edge(struct zd_chip *chip, u8 channel)\r\n{\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nif (!chip->patch_6m_band_edge)\r\nreturn 0;\r\nreturn zd_rf_patch_6m_band_edge(&chip->rf, channel);\r\n}\r\nint zd_chip_generic_patch_6m_band(struct zd_chip *chip, int channel)\r\n{\r\nstruct zd_ioreq16 ioreqs[] = {\r\n{ ZD_CR128, 0x14 }, { ZD_CR129, 0x12 }, { ZD_CR130, 0x10 },\r\n{ ZD_CR47, 0x1e },\r\n};\r\nif (channel == 1 || channel == 11)\r\nioreqs[0].value = 0x12;\r\ndev_dbg_f(zd_chip_dev(chip), "patching for channel %d\n", channel);\r\nreturn zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\r\n}\r\nstatic int zd1211_hw_reset_phy(struct zd_chip *chip)\r\n{\r\nstatic const struct zd_ioreq16 ioreqs[] = {\r\n{ ZD_CR0, 0x0a }, { ZD_CR1, 0x06 }, { ZD_CR2, 0x26 },\r\n{ ZD_CR3, 0x38 }, { ZD_CR4, 0x80 }, { ZD_CR9, 0xa0 },\r\n{ ZD_CR10, 0x81 }, { ZD_CR11, 0x00 }, { ZD_CR12, 0x7f },\r\n{ ZD_CR13, 0x8c }, { ZD_CR14, 0x80 }, { ZD_CR15, 0x3d },\r\n{ ZD_CR16, 0x20 }, { ZD_CR17, 0x1e }, { ZD_CR18, 0x0a },\r\n{ ZD_CR19, 0x48 }, { ZD_CR20, 0x0c }, { ZD_CR21, 0x0c },\r\n{ ZD_CR22, 0x23 }, { ZD_CR23, 0x90 }, { ZD_CR24, 0x14 },\r\n{ ZD_CR25, 0x40 }, { ZD_CR26, 0x10 }, { ZD_CR27, 0x19 },\r\n{ ZD_CR28, 0x7f }, { ZD_CR29, 0x80 }, { ZD_CR30, 0x4b },\r\n{ ZD_CR31, 0x60 }, { ZD_CR32, 0x43 }, { ZD_CR33, 0x08 },\r\n{ ZD_CR34, 0x06 }, { ZD_CR35, 0x0a }, { ZD_CR36, 0x00 },\r\n{ ZD_CR37, 0x00 }, { ZD_CR38, 0x38 }, { ZD_CR39, 0x0c },\r\n{ ZD_CR40, 0x84 }, { ZD_CR41, 0x2a }, { ZD_CR42, 0x80 },\r\n{ ZD_CR43, 0x10 }, { ZD_CR44, 0x12 }, { ZD_CR46, 0xff },\r\n{ ZD_CR47, 0x1E }, { ZD_CR48, 0x26 }, { ZD_CR49, 0x5b },\r\n{ ZD_CR64, 0xd0 }, { ZD_CR65, 0x04 }, { ZD_CR66, 0x58 },\r\n{ ZD_CR67, 0xc9 }, { ZD_CR68, 0x88 }, { ZD_CR69, 0x41 },\r\n{ ZD_CR70, 0x23 }, { ZD_CR71, 0x10 }, { ZD_CR72, 0xff },\r\n{ ZD_CR73, 0x32 }, { ZD_CR74, 0x30 }, { ZD_CR75, 0x65 },\r\n{ ZD_CR76, 0x41 }, { ZD_CR77, 0x1b }, { ZD_CR78, 0x30 },\r\n{ ZD_CR79, 0x68 }, { ZD_CR80, 0x64 }, { ZD_CR81, 0x64 },\r\n{ ZD_CR82, 0x00 }, { ZD_CR83, 0x00 }, { ZD_CR84, 0x00 },\r\n{ ZD_CR85, 0x02 }, { ZD_CR86, 0x00 }, { ZD_CR87, 0x00 },\r\n{ ZD_CR88, 0xff }, { ZD_CR89, 0xfc }, { ZD_CR90, 0x00 },\r\n{ ZD_CR91, 0x00 }, { ZD_CR92, 0x00 }, { ZD_CR93, 0x08 },\r\n{ ZD_CR94, 0x00 }, { ZD_CR95, 0x00 }, { ZD_CR96, 0xff },\r\n{ ZD_CR97, 0xe7 }, { ZD_CR98, 0x00 }, { ZD_CR99, 0x00 },\r\n{ ZD_CR100, 0x00 }, { ZD_CR101, 0xae }, { ZD_CR102, 0x02 },\r\n{ ZD_CR103, 0x00 }, { ZD_CR104, 0x03 }, { ZD_CR105, 0x65 },\r\n{ ZD_CR106, 0x04 }, { ZD_CR107, 0x00 }, { ZD_CR108, 0x0a },\r\n{ ZD_CR109, 0xaa }, { ZD_CR110, 0xaa }, { ZD_CR111, 0x25 },\r\n{ ZD_CR112, 0x25 }, { ZD_CR113, 0x00 }, { ZD_CR119, 0x1e },\r\n{ ZD_CR125, 0x90 }, { ZD_CR126, 0x00 }, { ZD_CR127, 0x00 },\r\n{ },\r\n{ ZD_CR5, 0x00 }, { ZD_CR6, 0x00 }, { ZD_CR7, 0x00 },\r\n{ ZD_CR8, 0x00 }, { ZD_CR9, 0x20 }, { ZD_CR12, 0xf0 },\r\n{ ZD_CR20, 0x0e }, { ZD_CR21, 0x0e }, { ZD_CR27, 0x10 },\r\n{ ZD_CR44, 0x33 }, { ZD_CR47, 0x1E }, { ZD_CR83, 0x24 },\r\n{ ZD_CR84, 0x04 }, { ZD_CR85, 0x00 }, { ZD_CR86, 0x0C },\r\n{ ZD_CR87, 0x12 }, { ZD_CR88, 0x0C }, { ZD_CR89, 0x00 },\r\n{ ZD_CR90, 0x10 }, { ZD_CR91, 0x08 }, { ZD_CR93, 0x00 },\r\n{ ZD_CR94, 0x01 }, { ZD_CR95, 0x00 }, { ZD_CR96, 0x50 },\r\n{ ZD_CR97, 0x37 }, { ZD_CR98, 0x35 }, { ZD_CR101, 0x13 },\r\n{ ZD_CR102, 0x27 }, { ZD_CR103, 0x27 }, { ZD_CR104, 0x18 },\r\n{ ZD_CR105, 0x12 }, { ZD_CR109, 0x27 }, { ZD_CR110, 0x27 },\r\n{ ZD_CR111, 0x27 }, { ZD_CR112, 0x27 }, { ZD_CR113, 0x27 },\r\n{ ZD_CR114, 0x27 }, { ZD_CR115, 0x26 }, { ZD_CR116, 0x24 },\r\n{ ZD_CR117, 0xfc }, { ZD_CR118, 0xfa }, { ZD_CR120, 0x4f },\r\n{ ZD_CR125, 0xaa }, { ZD_CR127, 0x03 }, { ZD_CR128, 0x14 },\r\n{ ZD_CR129, 0x12 }, { ZD_CR130, 0x10 }, { ZD_CR131, 0x0C },\r\n{ ZD_CR136, 0xdf }, { ZD_CR137, 0x40 }, { ZD_CR138, 0xa0 },\r\n{ ZD_CR139, 0xb0 }, { ZD_CR140, 0x99 }, { ZD_CR141, 0x82 },\r\n{ ZD_CR142, 0x54 }, { ZD_CR143, 0x1c }, { ZD_CR144, 0x6c },\r\n{ ZD_CR147, 0x07 }, { ZD_CR148, 0x4c }, { ZD_CR149, 0x50 },\r\n{ ZD_CR150, 0x0e }, { ZD_CR151, 0x18 }, { ZD_CR160, 0xfe },\r\n{ ZD_CR161, 0xee }, { ZD_CR162, 0xaa }, { ZD_CR163, 0xfa },\r\n{ ZD_CR164, 0xfa }, { ZD_CR165, 0xea }, { ZD_CR166, 0xbe },\r\n{ ZD_CR167, 0xbe }, { ZD_CR168, 0x6a }, { ZD_CR169, 0xba },\r\n{ ZD_CR170, 0xba }, { ZD_CR171, 0xba },\r\n{ ZD_CR204, 0x7d },\r\n{ },\r\n{ ZD_CR203, 0x30 },\r\n};\r\nint r, t;\r\ndev_dbg_f(zd_chip_dev(chip), "\n");\r\nr = zd_chip_lock_phy_regs(chip);\r\nif (r)\r\ngoto out;\r\nr = zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\r\nif (r)\r\ngoto unlock;\r\nr = patch_cr157(chip);\r\nunlock:\r\nt = zd_chip_unlock_phy_regs(chip);\r\nif (t && !r)\r\nr = t;\r\nout:\r\nreturn r;\r\n}\r\nstatic int zd1211b_hw_reset_phy(struct zd_chip *chip)\r\n{\r\nstatic const struct zd_ioreq16 ioreqs[] = {\r\n{ ZD_CR0, 0x14 }, { ZD_CR1, 0x06 }, { ZD_CR2, 0x26 },\r\n{ ZD_CR3, 0x38 }, { ZD_CR4, 0x80 }, { ZD_CR9, 0xe0 },\r\n{ ZD_CR10, 0x81 },\r\n{ ZD_CR11, 0x00 },\r\n{ ZD_CR12, 0xf0 }, { ZD_CR13, 0x8c }, { ZD_CR14, 0x80 },\r\n{ ZD_CR15, 0x3d }, { ZD_CR16, 0x20 }, { ZD_CR17, 0x1e },\r\n{ ZD_CR18, 0x0a }, { ZD_CR19, 0x48 },\r\n{ ZD_CR20, 0x10 },\r\n{ ZD_CR21, 0x0e }, { ZD_CR22, 0x23 }, { ZD_CR23, 0x90 },\r\n{ ZD_CR24, 0x14 }, { ZD_CR25, 0x40 }, { ZD_CR26, 0x10 },\r\n{ ZD_CR27, 0x10 }, { ZD_CR28, 0x7f }, { ZD_CR29, 0x80 },\r\n{ ZD_CR30, 0x4b },\r\n{ ZD_CR31, 0x60 }, { ZD_CR32, 0x43 }, { ZD_CR33, 0x08 },\r\n{ ZD_CR34, 0x06 }, { ZD_CR35, 0x0a }, { ZD_CR36, 0x00 },\r\n{ ZD_CR37, 0x00 }, { ZD_CR38, 0x38 }, { ZD_CR39, 0x0c },\r\n{ ZD_CR40, 0x84 }, { ZD_CR41, 0x2a }, { ZD_CR42, 0x80 },\r\n{ ZD_CR43, 0x10 }, { ZD_CR44, 0x33 }, { ZD_CR46, 0xff },\r\n{ ZD_CR47, 0x1E }, { ZD_CR48, 0x26 }, { ZD_CR49, 0x5b },\r\n{ ZD_CR64, 0xd0 }, { ZD_CR65, 0x04 }, { ZD_CR66, 0x58 },\r\n{ ZD_CR67, 0xc9 }, { ZD_CR68, 0x88 }, { ZD_CR69, 0x41 },\r\n{ ZD_CR70, 0x23 }, { ZD_CR71, 0x10 }, { ZD_CR72, 0xff },\r\n{ ZD_CR73, 0x32 }, { ZD_CR74, 0x30 }, { ZD_CR75, 0x65 },\r\n{ ZD_CR76, 0x41 }, { ZD_CR77, 0x1b }, { ZD_CR78, 0x30 },\r\n{ ZD_CR79, 0xf0 }, { ZD_CR80, 0x64 }, { ZD_CR81, 0x64 },\r\n{ ZD_CR82, 0x00 }, { ZD_CR83, 0x24 }, { ZD_CR84, 0x04 },\r\n{ ZD_CR85, 0x00 }, { ZD_CR86, 0x0c }, { ZD_CR87, 0x12 },\r\n{ ZD_CR88, 0x0c }, { ZD_CR89, 0x00 }, { ZD_CR90, 0x58 },\r\n{ ZD_CR91, 0x04 }, { ZD_CR92, 0x00 }, { ZD_CR93, 0x00 },\r\n{ ZD_CR94, 0x01 },\r\n{ ZD_CR95, 0x20 },\r\n{ ZD_CR96, 0x50 }, { ZD_CR97, 0x37 }, { ZD_CR98, 0x35 },\r\n{ ZD_CR99, 0x00 }, { ZD_CR100, 0x01 }, { ZD_CR101, 0x13 },\r\n{ ZD_CR102, 0x27 }, { ZD_CR103, 0x27 }, { ZD_CR104, 0x18 },\r\n{ ZD_CR105, 0x12 }, { ZD_CR106, 0x04 }, { ZD_CR107, 0x00 },\r\n{ ZD_CR108, 0x0a }, { ZD_CR109, 0x27 }, { ZD_CR110, 0x27 },\r\n{ ZD_CR111, 0x27 }, { ZD_CR112, 0x27 }, { ZD_CR113, 0x27 },\r\n{ ZD_CR114, 0x27 }, { ZD_CR115, 0x26 }, { ZD_CR116, 0x24 },\r\n{ ZD_CR117, 0xfc }, { ZD_CR118, 0xfa }, { ZD_CR119, 0x1e },\r\n{ ZD_CR125, 0x90 }, { ZD_CR126, 0x00 }, { ZD_CR127, 0x00 },\r\n{ ZD_CR128, 0x14 }, { ZD_CR129, 0x12 }, { ZD_CR130, 0x10 },\r\n{ ZD_CR131, 0x0c }, { ZD_CR136, 0xdf }, { ZD_CR137, 0xa0 },\r\n{ ZD_CR138, 0xa8 }, { ZD_CR139, 0xb4 }, { ZD_CR140, 0x98 },\r\n{ ZD_CR141, 0x82 }, { ZD_CR142, 0x53 }, { ZD_CR143, 0x1c },\r\n{ ZD_CR144, 0x6c }, { ZD_CR147, 0x07 }, { ZD_CR148, 0x40 },\r\n{ ZD_CR149, 0x40 },\r\n{ ZD_CR150, 0x14 },\r\n{ ZD_CR151, 0x18 }, { ZD_CR159, 0x70 }, { ZD_CR160, 0xfe },\r\n{ ZD_CR161, 0xee }, { ZD_CR162, 0xaa }, { ZD_CR163, 0xfa },\r\n{ ZD_CR164, 0xfa }, { ZD_CR165, 0xea }, { ZD_CR166, 0xbe },\r\n{ ZD_CR167, 0xbe }, { ZD_CR168, 0x6a }, { ZD_CR169, 0xba },\r\n{ ZD_CR170, 0xba }, { ZD_CR171, 0xba },\r\n{ ZD_CR204, 0x7d },\r\n{},\r\n{ ZD_CR203, 0x30 },\r\n};\r\nint r, t;\r\ndev_dbg_f(zd_chip_dev(chip), "\n");\r\nr = zd_chip_lock_phy_regs(chip);\r\nif (r)\r\ngoto out;\r\nr = zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\r\nt = zd_chip_unlock_phy_regs(chip);\r\nif (t && !r)\r\nr = t;\r\nout:\r\nreturn r;\r\n}\r\nstatic int hw_reset_phy(struct zd_chip *chip)\r\n{\r\nreturn zd_chip_is_zd1211b(chip) ? zd1211b_hw_reset_phy(chip) :\r\nzd1211_hw_reset_phy(chip);\r\n}\r\nstatic int zd1211_hw_init_hmac(struct zd_chip *chip)\r\n{\r\nstatic const struct zd_ioreq32 ioreqs[] = {\r\n{ CR_ZD1211_RETRY_MAX, ZD1211_RETRY_COUNT },\r\n{ CR_RX_THRESHOLD, 0x000c0640 },\r\n};\r\ndev_dbg_f(zd_chip_dev(chip), "\n");\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nreturn zd_iowrite32a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\r\n}\r\nstatic int zd1211b_hw_init_hmac(struct zd_chip *chip)\r\n{\r\nstatic const struct zd_ioreq32 ioreqs[] = {\r\n{ CR_ZD1211B_RETRY_MAX, ZD1211B_RETRY_COUNT },\r\n{ CR_ZD1211B_CWIN_MAX_MIN_AC0, 0x007f003f },\r\n{ CR_ZD1211B_CWIN_MAX_MIN_AC1, 0x007f003f },\r\n{ CR_ZD1211B_CWIN_MAX_MIN_AC2, 0x003f001f },\r\n{ CR_ZD1211B_CWIN_MAX_MIN_AC3, 0x001f000f },\r\n{ CR_ZD1211B_AIFS_CTL1, 0x00280028 },\r\n{ CR_ZD1211B_AIFS_CTL2, 0x008C003C },\r\n{ CR_ZD1211B_TXOP, 0x01800824 },\r\n{ CR_RX_THRESHOLD, 0x000c0eff, },\r\n};\r\ndev_dbg_f(zd_chip_dev(chip), "\n");\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nreturn zd_iowrite32a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\r\n}\r\nstatic int hw_init_hmac(struct zd_chip *chip)\r\n{\r\nint r;\r\nstatic const struct zd_ioreq32 ioreqs[] = {\r\n{ CR_ACK_TIMEOUT_EXT, 0x20 },\r\n{ CR_ADDA_MBIAS_WARMTIME, 0x30000808 },\r\n{ CR_SNIFFER_ON, 0 },\r\n{ CR_RX_FILTER, STA_RX_FILTER },\r\n{ CR_GROUP_HASH_P1, 0x00 },\r\n{ CR_GROUP_HASH_P2, 0x80000000 },\r\n{ CR_REG1, 0xa4 },\r\n{ CR_ADDA_PWR_DWN, 0x7f },\r\n{ CR_BCN_PLCP_CFG, 0x00f00401 },\r\n{ CR_PHY_DELAY, 0x00 },\r\n{ CR_ACK_TIMEOUT_EXT, 0x80 },\r\n{ CR_ADDA_PWR_DWN, 0x00 },\r\n{ CR_ACK_TIME_80211, 0x100 },\r\n{ CR_RX_PE_DELAY, 0x70 },\r\n{ CR_PS_CTRL, 0x10000000 },\r\n{ CR_RTS_CTS_RATE, 0x02030203 },\r\n{ CR_AFTER_PNP, 0x1 },\r\n{ CR_WEP_PROTECT, 0x114 },\r\n{ CR_IFS_VALUE, IFS_VALUE_DEFAULT },\r\n{ CR_CAM_MODE, MODE_AP_WDS},\r\n};\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nr = zd_iowrite32a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\r\nif (r)\r\nreturn r;\r\nreturn zd_chip_is_zd1211b(chip) ?\r\nzd1211b_hw_init_hmac(chip) : zd1211_hw_init_hmac(chip);\r\n}\r\nstatic int get_aw_pt_bi(struct zd_chip *chip, struct aw_pt_bi *s)\r\n{\r\nint r;\r\nstatic const zd_addr_t aw_pt_bi_addr[] =\r\n{ CR_ATIM_WND_PERIOD, CR_PRE_TBTT, CR_BCN_INTERVAL };\r\nu32 values[3];\r\nr = zd_ioread32v_locked(chip, values, (const zd_addr_t *)aw_pt_bi_addr,\r\nARRAY_SIZE(aw_pt_bi_addr));\r\nif (r) {\r\nmemset(s, 0, sizeof(*s));\r\nreturn r;\r\n}\r\ns->atim_wnd_period = values[0];\r\ns->pre_tbtt = values[1];\r\ns->beacon_interval = values[2];\r\nreturn 0;\r\n}\r\nstatic int set_aw_pt_bi(struct zd_chip *chip, struct aw_pt_bi *s)\r\n{\r\nstruct zd_ioreq32 reqs[3];\r\nu16 b_interval = s->beacon_interval & 0xffff;\r\nif (b_interval <= 5)\r\nb_interval = 5;\r\nif (s->pre_tbtt < 4 || s->pre_tbtt >= b_interval)\r\ns->pre_tbtt = b_interval - 1;\r\nif (s->atim_wnd_period >= s->pre_tbtt)\r\ns->atim_wnd_period = s->pre_tbtt - 1;\r\nreqs[0].addr = CR_ATIM_WND_PERIOD;\r\nreqs[0].value = s->atim_wnd_period;\r\nreqs[1].addr = CR_PRE_TBTT;\r\nreqs[1].value = s->pre_tbtt;\r\nreqs[2].addr = CR_BCN_INTERVAL;\r\nreqs[2].value = (s->beacon_interval & ~0xffff) | b_interval;\r\nreturn zd_iowrite32a_locked(chip, reqs, ARRAY_SIZE(reqs));\r\n}\r\nstatic int set_beacon_interval(struct zd_chip *chip, u16 interval,\r\nu8 dtim_period, int type)\r\n{\r\nint r;\r\nstruct aw_pt_bi s;\r\nu32 b_interval, mode_flag;\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nif (interval > 0) {\r\nswitch (type) {\r\ncase NL80211_IFTYPE_ADHOC:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nmode_flag = BCN_MODE_IBSS;\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nmode_flag = BCN_MODE_AP;\r\nbreak;\r\ndefault:\r\nmode_flag = 0;\r\nbreak;\r\n}\r\n} else {\r\ndtim_period = 0;\r\nmode_flag = 0;\r\n}\r\nb_interval = mode_flag | (dtim_period << 16) | interval;\r\nr = zd_iowrite32_locked(chip, b_interval, CR_BCN_INTERVAL);\r\nif (r)\r\nreturn r;\r\nr = get_aw_pt_bi(chip, &s);\r\nif (r)\r\nreturn r;\r\nreturn set_aw_pt_bi(chip, &s);\r\n}\r\nint zd_set_beacon_interval(struct zd_chip *chip, u16 interval, u8 dtim_period,\r\nint type)\r\n{\r\nint r;\r\nmutex_lock(&chip->mutex);\r\nr = set_beacon_interval(chip, interval, dtim_period, type);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nstatic int hw_init(struct zd_chip *chip)\r\n{\r\nint r;\r\ndev_dbg_f(zd_chip_dev(chip), "\n");\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nr = hw_reset_phy(chip);\r\nif (r)\r\nreturn r;\r\nr = hw_init_hmac(chip);\r\nif (r)\r\nreturn r;\r\nreturn set_beacon_interval(chip, 100, 0, NL80211_IFTYPE_UNSPECIFIED);\r\n}\r\nstatic zd_addr_t fw_reg_addr(struct zd_chip *chip, u16 offset)\r\n{\r\nreturn (zd_addr_t)((u16)chip->fw_regs_base + offset);\r\n}\r\nstatic int dump_cr(struct zd_chip *chip, const zd_addr_t addr,\r\nconst char *addr_string)\r\n{\r\nint r;\r\nu32 value;\r\nr = zd_ioread32_locked(chip, &value, addr);\r\nif (r) {\r\ndev_dbg_f(zd_chip_dev(chip),\r\n"error reading %s. Error number %d\n", addr_string, r);\r\nreturn r;\r\n}\r\ndev_dbg_f(zd_chip_dev(chip), "%s %#010x\n",\r\naddr_string, (unsigned int)value);\r\nreturn 0;\r\n}\r\nstatic int test_init(struct zd_chip *chip)\r\n{\r\nint r;\r\nr = dump_cr(chip, CR_AFTER_PNP, "CR_AFTER_PNP");\r\nif (r)\r\nreturn r;\r\nr = dump_cr(chip, CR_GPI_EN, "CR_GPI_EN");\r\nif (r)\r\nreturn r;\r\nreturn dump_cr(chip, CR_INTERRUPT, "CR_INTERRUPT");\r\n}\r\nstatic void dump_fw_registers(struct zd_chip *chip)\r\n{\r\nconst zd_addr_t addr[4] = {\r\nfw_reg_addr(chip, FW_REG_FIRMWARE_VER),\r\nfw_reg_addr(chip, FW_REG_USB_SPEED),\r\nfw_reg_addr(chip, FW_REG_FIX_TX_RATE),\r\nfw_reg_addr(chip, FW_REG_LED_LINK_STATUS),\r\n};\r\nint r;\r\nu16 values[4];\r\nr = zd_ioread16v_locked(chip, values, (const zd_addr_t*)addr,\r\nARRAY_SIZE(addr));\r\nif (r) {\r\ndev_dbg_f(zd_chip_dev(chip), "error %d zd_ioread16v_locked\n",\r\nr);\r\nreturn;\r\n}\r\ndev_dbg_f(zd_chip_dev(chip), "FW_FIRMWARE_VER %#06hx\n", values[0]);\r\ndev_dbg_f(zd_chip_dev(chip), "FW_USB_SPEED %#06hx\n", values[1]);\r\ndev_dbg_f(zd_chip_dev(chip), "FW_FIX_TX_RATE %#06hx\n", values[2]);\r\ndev_dbg_f(zd_chip_dev(chip), "FW_LINK_STATUS %#06hx\n", values[3]);\r\n}\r\nstatic int print_fw_version(struct zd_chip *chip)\r\n{\r\nstruct wiphy *wiphy = zd_chip_to_mac(chip)->hw->wiphy;\r\nint r;\r\nu16 version;\r\nr = zd_ioread16_locked(chip, &version,\r\nfw_reg_addr(chip, FW_REG_FIRMWARE_VER));\r\nif (r)\r\nreturn r;\r\ndev_info(zd_chip_dev(chip),"firmware version %04hx\n", version);\r\nsnprintf(wiphy->fw_version, sizeof(wiphy->fw_version),\r\n"%04hx", version);\r\nreturn 0;\r\n}\r\nstatic int set_mandatory_rates(struct zd_chip *chip, int gmode)\r\n{\r\nu32 rates;\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nif (!gmode)\r\nrates = CR_RATE_1M|CR_RATE_2M|CR_RATE_5_5M|CR_RATE_11M;\r\nelse\r\nrates = CR_RATE_1M|CR_RATE_2M|CR_RATE_5_5M|CR_RATE_11M|\r\nCR_RATE_6M|CR_RATE_12M|CR_RATE_24M;\r\nreturn zd_iowrite32_locked(chip, rates, CR_MANDATORY_RATE_TBL);\r\n}\r\nint zd_chip_set_rts_cts_rate_locked(struct zd_chip *chip,\r\nint preamble)\r\n{\r\nu32 value = 0;\r\ndev_dbg_f(zd_chip_dev(chip), "preamble=%x\n", preamble);\r\nvalue |= preamble << RTSCTS_SH_RTS_PMB_TYPE;\r\nvalue |= preamble << RTSCTS_SH_CTS_PMB_TYPE;\r\nvalue |= ZD_PURE_RATE(ZD_CCK_RATE_11M) << RTSCTS_SH_RTS_RATE;\r\nvalue |= ZD_RX_CCK << RTSCTS_SH_RTS_MOD_TYPE;\r\nvalue |= ZD_PURE_RATE(ZD_CCK_RATE_11M) << RTSCTS_SH_CTS_RATE;\r\nvalue |= ZD_RX_CCK << RTSCTS_SH_CTS_MOD_TYPE;\r\nreturn zd_iowrite32_locked(chip, value, CR_RTS_CTS_RATE);\r\n}\r\nint zd_chip_enable_hwint(struct zd_chip *chip)\r\n{\r\nint r;\r\nmutex_lock(&chip->mutex);\r\nr = zd_iowrite32_locked(chip, HWINT_ENABLED, CR_INTERRUPT);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nstatic int disable_hwint(struct zd_chip *chip)\r\n{\r\nreturn zd_iowrite32_locked(chip, HWINT_DISABLED, CR_INTERRUPT);\r\n}\r\nint zd_chip_disable_hwint(struct zd_chip *chip)\r\n{\r\nint r;\r\nmutex_lock(&chip->mutex);\r\nr = disable_hwint(chip);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nstatic int read_fw_regs_offset(struct zd_chip *chip)\r\n{\r\nint r;\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nr = zd_ioread16_locked(chip, (u16*)&chip->fw_regs_base,\r\nFWRAW_REGS_ADDR);\r\nif (r)\r\nreturn r;\r\ndev_dbg_f(zd_chip_dev(chip), "fw_regs_base: %#06hx\n",\r\n(u16)chip->fw_regs_base);\r\nreturn 0;\r\n}\r\nint zd_chip_read_mac_addr_fw(struct zd_chip *chip, u8 *addr)\r\n{\r\ndev_dbg_f(zd_chip_dev(chip), "\n");\r\nreturn zd_usb_read_fw(&chip->usb, E2P_MAC_ADDR_P1, addr,\r\nETH_ALEN);\r\n}\r\nint zd_chip_init_hw(struct zd_chip *chip)\r\n{\r\nint r;\r\nu8 rf_type;\r\ndev_dbg_f(zd_chip_dev(chip), "\n");\r\nmutex_lock(&chip->mutex);\r\n#ifdef DEBUG\r\nr = test_init(chip);\r\nif (r)\r\ngoto out;\r\n#endif\r\nr = zd_iowrite32_locked(chip, 1, CR_AFTER_PNP);\r\nif (r)\r\ngoto out;\r\nr = read_fw_regs_offset(chip);\r\nif (r)\r\ngoto out;\r\nr = zd_iowrite32_locked(chip, 0, CR_GPI_EN);\r\nif (r)\r\ngoto out;\r\nr = zd_iowrite32_locked(chip, CWIN_SIZE, CR_CWMIN_CWMAX);\r\nif (r)\r\ngoto out;\r\nr = set_mandatory_rates(chip, 1);\r\nif (r)\r\ngoto out;\r\nr = disable_hwint(chip);\r\nif (r)\r\ngoto out;\r\nr = read_pod(chip, &rf_type);\r\nif (r)\r\ngoto out;\r\nr = hw_init(chip);\r\nif (r)\r\ngoto out;\r\nr = zd_rf_init_hw(&chip->rf, rf_type);\r\nif (r)\r\ngoto out;\r\nr = print_fw_version(chip);\r\nif (r)\r\ngoto out;\r\n#ifdef DEBUG\r\ndump_fw_registers(chip);\r\nr = test_init(chip);\r\nif (r)\r\ngoto out;\r\n#endif\r\nr = read_cal_int_tables(chip);\r\nif (r)\r\ngoto out;\r\nprint_id(chip);\r\nout:\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nstatic int update_pwr_int(struct zd_chip *chip, u8 channel)\r\n{\r\nu8 value = chip->pwr_int_values[channel - 1];\r\nreturn zd_iowrite16_locked(chip, value, ZD_CR31);\r\n}\r\nstatic int update_pwr_cal(struct zd_chip *chip, u8 channel)\r\n{\r\nu8 value = chip->pwr_cal_values[channel-1];\r\nreturn zd_iowrite16_locked(chip, value, ZD_CR68);\r\n}\r\nstatic int update_ofdm_cal(struct zd_chip *chip, u8 channel)\r\n{\r\nstruct zd_ioreq16 ioreqs[3];\r\nioreqs[0].addr = ZD_CR67;\r\nioreqs[0].value = chip->ofdm_cal_values[OFDM_36M_INDEX][channel-1];\r\nioreqs[1].addr = ZD_CR66;\r\nioreqs[1].value = chip->ofdm_cal_values[OFDM_48M_INDEX][channel-1];\r\nioreqs[2].addr = ZD_CR65;\r\nioreqs[2].value = chip->ofdm_cal_values[OFDM_54M_INDEX][channel-1];\r\nreturn zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\r\n}\r\nstatic int update_channel_integration_and_calibration(struct zd_chip *chip,\r\nu8 channel)\r\n{\r\nint r;\r\nif (!zd_rf_should_update_pwr_int(&chip->rf))\r\nreturn 0;\r\nr = update_pwr_int(chip, channel);\r\nif (r)\r\nreturn r;\r\nif (zd_chip_is_zd1211b(chip)) {\r\nstatic const struct zd_ioreq16 ioreqs[] = {\r\n{ ZD_CR69, 0x28 },\r\n{},\r\n{ ZD_CR69, 0x2a },\r\n};\r\nr = update_ofdm_cal(chip, channel);\r\nif (r)\r\nreturn r;\r\nr = update_pwr_cal(chip, channel);\r\nif (r)\r\nreturn r;\r\nr = zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\r\nif (r)\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int patch_cck_gain(struct zd_chip *chip)\r\n{\r\nint r;\r\nu32 value;\r\nif (!chip->patch_cck_gain || !zd_rf_should_patch_cck_gain(&chip->rf))\r\nreturn 0;\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nr = zd_ioread32_locked(chip, &value, E2P_PHY_REG);\r\nif (r)\r\nreturn r;\r\ndev_dbg_f(zd_chip_dev(chip), "patching value %x\n", value & 0xff);\r\nreturn zd_iowrite16_locked(chip, value & 0xff, ZD_CR47);\r\n}\r\nint zd_chip_set_channel(struct zd_chip *chip, u8 channel)\r\n{\r\nint r, t;\r\nmutex_lock(&chip->mutex);\r\nr = zd_chip_lock_phy_regs(chip);\r\nif (r)\r\ngoto out;\r\nr = zd_rf_set_channel(&chip->rf, channel);\r\nif (r)\r\ngoto unlock;\r\nr = update_channel_integration_and_calibration(chip, channel);\r\nif (r)\r\ngoto unlock;\r\nr = patch_cck_gain(chip);\r\nif (r)\r\ngoto unlock;\r\nr = patch_6m_band_edge(chip, channel);\r\nif (r)\r\ngoto unlock;\r\nr = zd_iowrite32_locked(chip, 0, CR_CONFIG_PHILIPS);\r\nunlock:\r\nt = zd_chip_unlock_phy_regs(chip);\r\nif (t && !r)\r\nr = t;\r\nout:\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nu8 zd_chip_get_channel(struct zd_chip *chip)\r\n{\r\nu8 channel;\r\nmutex_lock(&chip->mutex);\r\nchannel = chip->rf.channel;\r\nmutex_unlock(&chip->mutex);\r\nreturn channel;\r\n}\r\nint zd_chip_control_leds(struct zd_chip *chip, enum led_status status)\r\n{\r\nconst zd_addr_t a[] = {\r\nfw_reg_addr(chip, FW_REG_LED_LINK_STATUS),\r\nCR_LED,\r\n};\r\nint r;\r\nu16 v[ARRAY_SIZE(a)];\r\nstruct zd_ioreq16 ioreqs[ARRAY_SIZE(a)] = {\r\n[0] = { fw_reg_addr(chip, FW_REG_LED_LINK_STATUS) },\r\n[1] = { CR_LED },\r\n};\r\nu16 other_led;\r\nmutex_lock(&chip->mutex);\r\nr = zd_ioread16v_locked(chip, v, (const zd_addr_t *)a, ARRAY_SIZE(a));\r\nif (r)\r\ngoto out;\r\nother_led = chip->link_led == LED1 ? LED2 : LED1;\r\nswitch (status) {\r\ncase ZD_LED_OFF:\r\nioreqs[0].value = FW_LINK_OFF;\r\nioreqs[1].value = v[1] & ~(LED1|LED2);\r\nbreak;\r\ncase ZD_LED_SCANNING:\r\nioreqs[0].value = FW_LINK_OFF;\r\nioreqs[1].value = v[1] & ~other_led;\r\nif (get_seconds() % 3 == 0) {\r\nioreqs[1].value &= ~chip->link_led;\r\n} else {\r\nioreqs[1].value |= chip->link_led;\r\n}\r\nbreak;\r\ncase ZD_LED_ASSOCIATED:\r\nioreqs[0].value = FW_LINK_TX;\r\nioreqs[1].value = v[1] & ~other_led;\r\nioreqs[1].value |= chip->link_led;\r\nbreak;\r\ndefault:\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nif (v[0] != ioreqs[0].value || v[1] != ioreqs[1].value) {\r\nr = zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\r\nif (r)\r\ngoto out;\r\n}\r\nr = 0;\r\nout:\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nint zd_chip_set_basic_rates(struct zd_chip *chip, u16 cr_rates)\r\n{\r\nint r;\r\nif (cr_rates & ~(CR_RATES_80211B|CR_RATES_80211G))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nr = zd_iowrite32_locked(chip, cr_rates, CR_BASIC_RATE_TBL);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nstatic inline u8 zd_rate_from_ofdm_plcp_header(const void *rx_frame)\r\n{\r\nreturn ZD_OFDM | zd_ofdm_plcp_header_rate(rx_frame);\r\n}\r\nu8 zd_rx_rate(const void *rx_frame, const struct rx_status *status)\r\n{\r\nu8 zd_rate;\r\nif (status->frame_status & ZD_RX_OFDM) {\r\nzd_rate = zd_rate_from_ofdm_plcp_header(rx_frame);\r\n} else {\r\nswitch (zd_cck_plcp_header_signal(rx_frame)) {\r\ncase ZD_CCK_PLCP_SIGNAL_1M:\r\nzd_rate = ZD_CCK_RATE_1M;\r\nbreak;\r\ncase ZD_CCK_PLCP_SIGNAL_2M:\r\nzd_rate = ZD_CCK_RATE_2M;\r\nbreak;\r\ncase ZD_CCK_PLCP_SIGNAL_5M5:\r\nzd_rate = ZD_CCK_RATE_5_5M;\r\nbreak;\r\ncase ZD_CCK_PLCP_SIGNAL_11M:\r\nzd_rate = ZD_CCK_RATE_11M;\r\nbreak;\r\ndefault:\r\nzd_rate = 0;\r\n}\r\n}\r\nreturn zd_rate;\r\n}\r\nint zd_chip_switch_radio_on(struct zd_chip *chip)\r\n{\r\nint r;\r\nmutex_lock(&chip->mutex);\r\nr = zd_switch_radio_on(&chip->rf);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nint zd_chip_switch_radio_off(struct zd_chip *chip)\r\n{\r\nint r;\r\nmutex_lock(&chip->mutex);\r\nr = zd_switch_radio_off(&chip->rf);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nint zd_chip_enable_int(struct zd_chip *chip)\r\n{\r\nint r;\r\nmutex_lock(&chip->mutex);\r\nr = zd_usb_enable_int(&chip->usb);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nvoid zd_chip_disable_int(struct zd_chip *chip)\r\n{\r\nmutex_lock(&chip->mutex);\r\nzd_usb_disable_int(&chip->usb);\r\nmutex_unlock(&chip->mutex);\r\ncancel_work_sync(&zd_chip_to_mac(chip)->process_intr);\r\n}\r\nint zd_chip_enable_rxtx(struct zd_chip *chip)\r\n{\r\nint r;\r\nmutex_lock(&chip->mutex);\r\nzd_usb_enable_tx(&chip->usb);\r\nr = zd_usb_enable_rx(&chip->usb);\r\nzd_tx_watchdog_enable(&chip->usb);\r\nmutex_unlock(&chip->mutex);\r\nreturn r;\r\n}\r\nvoid zd_chip_disable_rxtx(struct zd_chip *chip)\r\n{\r\nmutex_lock(&chip->mutex);\r\nzd_tx_watchdog_disable(&chip->usb);\r\nzd_usb_disable_rx(&chip->usb);\r\nzd_usb_disable_tx(&chip->usb);\r\nmutex_unlock(&chip->mutex);\r\n}\r\nint zd_rfwritev_locked(struct zd_chip *chip,\r\nconst u32* values, unsigned int count, u8 bits)\r\n{\r\nint r;\r\nunsigned int i;\r\nfor (i = 0; i < count; i++) {\r\nr = zd_rfwrite_locked(chip, values[i], bits);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint zd_rfwrite_cr_locked(struct zd_chip *chip, u32 value)\r\n{\r\nconst struct zd_ioreq16 ioreqs[] = {\r\n{ ZD_CR244, (value >> 16) & 0xff },\r\n{ ZD_CR243, (value >> 8) & 0xff },\r\n{ ZD_CR242, value & 0xff },\r\n};\r\nZD_ASSERT(mutex_is_locked(&chip->mutex));\r\nreturn zd_iowrite16a_locked(chip, ioreqs, ARRAY_SIZE(ioreqs));\r\n}\r\nint zd_rfwritev_cr_locked(struct zd_chip *chip,\r\nconst u32 *values, unsigned int count)\r\n{\r\nint r;\r\nunsigned int i;\r\nfor (i = 0; i < count; i++) {\r\nr = zd_rfwrite_cr_locked(chip, values[i]);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint zd_chip_set_multicast_hash(struct zd_chip *chip,\r\nstruct zd_mc_hash *hash)\r\n{\r\nconst struct zd_ioreq32 ioreqs[] = {\r\n{ CR_GROUP_HASH_P1, hash->low },\r\n{ CR_GROUP_HASH_P2, hash->high },\r\n};\r\nreturn zd_iowrite32a(chip, ioreqs, ARRAY_SIZE(ioreqs));\r\n}\r\nu64 zd_chip_get_tsf(struct zd_chip *chip)\r\n{\r\nint r;\r\nstatic const zd_addr_t aw_pt_bi_addr[] =\r\n{ CR_TSF_LOW_PART, CR_TSF_HIGH_PART };\r\nu32 values[2];\r\nu64 tsf;\r\nmutex_lock(&chip->mutex);\r\nr = zd_ioread32v_locked(chip, values, (const zd_addr_t *)aw_pt_bi_addr,\r\nARRAY_SIZE(aw_pt_bi_addr));\r\nmutex_unlock(&chip->mutex);\r\nif (r)\r\nreturn 0;\r\ntsf = values[1];\r\ntsf = (tsf << 32) | values[0];\r\nreturn tsf;\r\n}
