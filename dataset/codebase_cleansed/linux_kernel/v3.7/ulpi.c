static int ulpi_set_otg_flags(struct usb_phy *phy)\r\n{\r\nunsigned int flags = ULPI_OTG_CTRL_DP_PULLDOWN |\r\nULPI_OTG_CTRL_DM_PULLDOWN;\r\nif (phy->flags & ULPI_OTG_ID_PULLUP)\r\nflags |= ULPI_OTG_CTRL_ID_PULLUP;\r\nif (phy->flags & ULPI_OTG_DP_PULLDOWN_DIS)\r\nflags &= ~ULPI_OTG_CTRL_DP_PULLDOWN;\r\nif (phy->flags & ULPI_OTG_DM_PULLDOWN_DIS)\r\nflags &= ~ULPI_OTG_CTRL_DM_PULLDOWN;\r\nif (phy->flags & ULPI_OTG_EXTVBUSIND)\r\nflags |= ULPI_OTG_CTRL_EXTVBUSIND;\r\nreturn usb_phy_io_write(phy, flags, ULPI_OTG_CTRL);\r\n}\r\nstatic int ulpi_set_fc_flags(struct usb_phy *phy)\r\n{\r\nunsigned int flags = 0;\r\nif (phy->flags & ULPI_FC_HS)\r\nflags |= ULPI_FUNC_CTRL_HIGH_SPEED;\r\nelse if (phy->flags & ULPI_FC_LS)\r\nflags |= ULPI_FUNC_CTRL_LOW_SPEED;\r\nelse if (phy->flags & ULPI_FC_FS4LS)\r\nflags |= ULPI_FUNC_CTRL_FS4LS;\r\nelse\r\nflags |= ULPI_FUNC_CTRL_FULL_SPEED;\r\nif (phy->flags & ULPI_FC_TERMSEL)\r\nflags |= ULPI_FUNC_CTRL_TERMSELECT;\r\nif (phy->flags & ULPI_FC_OP_NODRV)\r\nflags |= ULPI_FUNC_CTRL_OPMODE_NONDRIVING;\r\nelse if (phy->flags & ULPI_FC_OP_DIS_NRZI)\r\nflags |= ULPI_FUNC_CTRL_OPMODE_DISABLE_NRZI;\r\nelse if (phy->flags & ULPI_FC_OP_NSYNC_NEOP)\r\nflags |= ULPI_FUNC_CTRL_OPMODE_NOSYNC_NOEOP;\r\nelse\r\nflags |= ULPI_FUNC_CTRL_OPMODE_NORMAL;\r\nflags |= ULPI_FUNC_CTRL_SUSPENDM;\r\nreturn usb_phy_io_write(phy, flags, ULPI_FUNC_CTRL);\r\n}\r\nstatic int ulpi_set_ic_flags(struct usb_phy *phy)\r\n{\r\nunsigned int flags = 0;\r\nif (phy->flags & ULPI_IC_AUTORESUME)\r\nflags |= ULPI_IFC_CTRL_AUTORESUME;\r\nif (phy->flags & ULPI_IC_EXTVBUS_INDINV)\r\nflags |= ULPI_IFC_CTRL_EXTERNAL_VBUS;\r\nif (phy->flags & ULPI_IC_IND_PASSTHRU)\r\nflags |= ULPI_IFC_CTRL_PASSTHRU;\r\nif (phy->flags & ULPI_IC_PROTECT_DIS)\r\nflags |= ULPI_IFC_CTRL_PROTECT_IFC_DISABLE;\r\nreturn usb_phy_io_write(phy, flags, ULPI_IFC_CTRL);\r\n}\r\nstatic int ulpi_set_flags(struct usb_phy *phy)\r\n{\r\nint ret;\r\nret = ulpi_set_otg_flags(phy);\r\nif (ret)\r\nreturn ret;\r\nret = ulpi_set_ic_flags(phy);\r\nif (ret)\r\nreturn ret;\r\nreturn ulpi_set_fc_flags(phy);\r\n}\r\nstatic int ulpi_check_integrity(struct usb_phy *phy)\r\n{\r\nint ret, i;\r\nunsigned int val = 0x55;\r\nfor (i = 0; i < 2; i++) {\r\nret = usb_phy_io_write(phy, val, ULPI_SCRATCH);\r\nif (ret < 0)\r\nreturn ret;\r\nret = usb_phy_io_read(phy, ULPI_SCRATCH);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != val) {\r\npr_err("ULPI integrity check: failed!");\r\nreturn -ENODEV;\r\n}\r\nval = val << 1;\r\n}\r\npr_info("ULPI integrity check: passed.\n");\r\nreturn 0;\r\n}\r\nstatic int ulpi_init(struct usb_phy *phy)\r\n{\r\nint i, vid, pid, ret;\r\nu32 ulpi_id = 0;\r\nfor (i = 0; i < 4; i++) {\r\nret = usb_phy_io_read(phy, ULPI_PRODUCT_ID_HIGH - i);\r\nif (ret < 0)\r\nreturn ret;\r\nulpi_id = (ulpi_id << 8) | ret;\r\n}\r\nvid = ulpi_id & 0xffff;\r\npid = ulpi_id >> 16;\r\npr_info("ULPI transceiver vendor/product ID 0x%04x/0x%04x\n", vid, pid);\r\nfor (i = 0; i < ARRAY_SIZE(ulpi_ids); i++) {\r\nif (ulpi_ids[i].id == ULPI_ID(vid, pid)) {\r\npr_info("Found %s ULPI transceiver.\n",\r\nulpi_ids[i].name);\r\nbreak;\r\n}\r\n}\r\nret = ulpi_check_integrity(phy);\r\nif (ret)\r\nreturn ret;\r\nreturn ulpi_set_flags(phy);\r\n}\r\nstatic int ulpi_set_host(struct usb_otg *otg, struct usb_bus *host)\r\n{\r\nstruct usb_phy *phy = otg->phy;\r\nunsigned int flags = usb_phy_io_read(phy, ULPI_IFC_CTRL);\r\nif (!host) {\r\notg->host = NULL;\r\nreturn 0;\r\n}\r\notg->host = host;\r\nflags &= ~(ULPI_IFC_CTRL_6_PIN_SERIAL_MODE |\r\nULPI_IFC_CTRL_3_PIN_SERIAL_MODE |\r\nULPI_IFC_CTRL_CARKITMODE);\r\nif (phy->flags & ULPI_IC_6PIN_SERIAL)\r\nflags |= ULPI_IFC_CTRL_6_PIN_SERIAL_MODE;\r\nelse if (phy->flags & ULPI_IC_3PIN_SERIAL)\r\nflags |= ULPI_IFC_CTRL_3_PIN_SERIAL_MODE;\r\nelse if (phy->flags & ULPI_IC_CARKIT)\r\nflags |= ULPI_IFC_CTRL_CARKITMODE;\r\nreturn usb_phy_io_write(phy, flags, ULPI_IFC_CTRL);\r\n}\r\nstatic int ulpi_set_vbus(struct usb_otg *otg, bool on)\r\n{\r\nstruct usb_phy *phy = otg->phy;\r\nunsigned int flags = usb_phy_io_read(phy, ULPI_OTG_CTRL);\r\nflags &= ~(ULPI_OTG_CTRL_DRVVBUS | ULPI_OTG_CTRL_DRVVBUS_EXT);\r\nif (on) {\r\nif (phy->flags & ULPI_OTG_DRVVBUS)\r\nflags |= ULPI_OTG_CTRL_DRVVBUS;\r\nif (phy->flags & ULPI_OTG_DRVVBUS_EXT)\r\nflags |= ULPI_OTG_CTRL_DRVVBUS_EXT;\r\n}\r\nreturn usb_phy_io_write(phy, flags, ULPI_OTG_CTRL);\r\n}\r\nstruct usb_phy *\r\notg_ulpi_create(struct usb_phy_io_ops *ops,\r\nunsigned int flags)\r\n{\r\nstruct usb_phy *phy;\r\nstruct usb_otg *otg;\r\nphy = kzalloc(sizeof(*phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn NULL;\r\notg = kzalloc(sizeof(*otg), GFP_KERNEL);\r\nif (!otg) {\r\nkfree(phy);\r\nreturn NULL;\r\n}\r\nphy->label = "ULPI";\r\nphy->flags = flags;\r\nphy->io_ops = ops;\r\nphy->otg = otg;\r\nphy->init = ulpi_init;\r\notg->phy = phy;\r\notg->set_host = ulpi_set_host;\r\notg->set_vbus = ulpi_set_vbus;\r\nreturn phy;\r\n}
