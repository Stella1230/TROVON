static void\r\nsigint_handler(int signal_num)\r\n{\r\nif (run == 1) {\r\nrun = 0;\r\nsignal(SIGINT, SIG_DFL);\r\n}\r\n}\r\nstatic struct subaction *\r\nsubaction_create(uint32_t *data, size_t length)\r\n{\r\nstruct subaction *sa;\r\nsa = malloc(sizeof *sa - sizeof sa->packet + length);\r\nsa->ack = data[length / 4 - 1];\r\nsa->length = length;\r\nmemcpy(&sa->packet, data, length);\r\nreturn sa;\r\n}\r\nstatic void\r\nsubaction_destroy(struct subaction *sa)\r\n{\r\nfree(sa);\r\n}\r\nstatic struct link_transaction *\r\nlink_transaction_lookup(int request_node, int response_node, int tlabel)\r\n{\r\nstruct link_transaction *t;\r\nlist_for_each_entry(t, &pending_transaction_list, link) {\r\nif (t->request_node == request_node &&\r\nt->response_node == response_node &&\r\nt->tlabel == tlabel)\r\nreturn t;\r\n}\r\nt = malloc(sizeof *t);\r\nt->request_node = request_node;\r\nt->response_node = response_node;\r\nt->tlabel = tlabel;\r\nlist_init(&t->request_list);\r\nlist_init(&t->response_list);\r\nlist_append(&pending_transaction_list, &t->link);\r\nreturn t;\r\n}\r\nstatic void\r\nlink_transaction_destroy(struct link_transaction *t)\r\n{\r\nstruct subaction *sa;\r\nwhile (!list_empty(&t->request_list)) {\r\nsa = list_head(&t->request_list, struct subaction, link);\r\nlist_remove(&sa->link);\r\nsubaction_destroy(sa);\r\n}\r\nwhile (!list_empty(&t->response_list)) {\r\nsa = list_head(&t->response_list, struct subaction, link);\r\nlist_remove(&sa->link);\r\nsubaction_destroy(sa);\r\n}\r\nfree(t);\r\n}\r\nstatic void\r\nhandle_transaction(struct link_transaction *t)\r\n{\r\nstruct subaction *sa;\r\nint i;\r\nif (!t->request) {\r\nprintf("BUG in handle_transaction\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < array_length(protocol_decoders); i++)\r\nif (protocol_decoders[i].decode(t))\r\nbreak;\r\nreturn;\r\ndecode_link_packet(&t->request->packet, t->request->length,\r\nPACKET_FIELD_TRANSACTION, 0);\r\nif (t->response)\r\ndecode_link_packet(&t->response->packet, t->request->length,\r\nPACKET_FIELD_TRANSACTION, 0);\r\nelse\r\nprintf("[no response]");\r\nif (option_verbose) {\r\nlist_for_each_entry(sa, &t->request_list, link)\r\nprint_packet((uint32_t *) &sa->packet, sa->length);\r\nlist_for_each_entry(sa, &t->response_list, link)\r\nprint_packet((uint32_t *) &sa->packet, sa->length);\r\n}\r\nprintf("\r\n");\r\nlink_transaction_destroy(t);\r\n}\r\nstatic void\r\nclear_pending_transaction_list(void)\r\n{\r\nstruct link_transaction *t;\r\nwhile (!list_empty(&pending_transaction_list)) {\r\nt = list_head(&pending_transaction_list,\r\nstruct link_transaction, link);\r\nlist_remove(&t->link);\r\nlink_transaction_destroy(t);\r\n}\r\n}\r\nstatic int\r\nhandle_request_packet(uint32_t *data, size_t length)\r\n{\r\nstruct link_packet *p = (struct link_packet *) data;\r\nstruct subaction *sa, *prev;\r\nstruct link_transaction *t;\r\nt = link_transaction_lookup(p->common.source, p->common.destination,\r\np->common.tlabel);\r\nsa = subaction_create(data, length);\r\nt->request = sa;\r\nif (!list_empty(&t->request_list)) {\r\nprev = list_tail(&t->request_list,\r\nstruct subaction, link);\r\nif (!ACK_BUSY(prev->ack)) {\r\n}\r\nif (prev->packet.common.tcode != sa->packet.common.tcode ||\r\nprev->packet.common.tlabel != sa->packet.common.tlabel) {\r\n}\r\n}\r\nlist_append(&t->request_list, &sa->link);\r\nswitch (sa->ack) {\r\ncase ACK_COMPLETE:\r\nif (p->common.tcode != TCODE_WRITE_QUADLET_REQUEST &&\r\np->common.tcode != TCODE_WRITE_BLOCK_REQUEST)\r\n;\r\nlist_remove(&t->link);\r\nhandle_transaction(t);\r\nbreak;\r\ncase ACK_NO_ACK:\r\ncase ACK_DATA_ERROR:\r\ncase ACK_TYPE_ERROR:\r\nlist_remove(&t->link);\r\nhandle_transaction(t);\r\nbreak;\r\ncase ACK_PENDING:\r\nbreak;\r\ncase ACK_BUSY_X:\r\ncase ACK_BUSY_A:\r\ncase ACK_BUSY_B:\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nhandle_response_packet(uint32_t *data, size_t length)\r\n{\r\nstruct link_packet *p = (struct link_packet *) data;\r\nstruct subaction *sa, *prev;\r\nstruct link_transaction *t;\r\nt = link_transaction_lookup(p->common.destination, p->common.source,\r\np->common.tlabel);\r\nif (list_empty(&t->request_list)) {\r\n}\r\nsa = subaction_create(data, length);\r\nt->response = sa;\r\nif (!list_empty(&t->response_list)) {\r\nprev = list_tail(&t->response_list, struct subaction, link);\r\nif (!ACK_BUSY(prev->ack)) {\r\n}\r\nif (prev->packet.common.tcode != sa->packet.common.tcode ||\r\nprev->packet.common.tlabel != sa->packet.common.tlabel) {\r\n}\r\n} else {\r\nprev = list_tail(&t->request_list, struct subaction, link);\r\nif (prev->ack != ACK_PENDING) {\r\n}\r\nif (packet_info[prev->packet.common.tcode].response_tcode !=\r\nsa->packet.common.tcode) {\r\n}\r\n}\r\nlist_append(&t->response_list, &sa->link);\r\nswitch (sa->ack) {\r\ncase ACK_COMPLETE:\r\ncase ACK_NO_ACK:\r\ncase ACK_DATA_ERROR:\r\ncase ACK_TYPE_ERROR:\r\nlist_remove(&t->link);\r\nhandle_transaction(t);\r\nbreak;\r\ncase ACK_PENDING:\r\nbreak;\r\ncase ACK_BUSY_X:\r\ncase ACK_BUSY_A:\r\ncase ACK_BUSY_B:\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nhandle_packet(uint32_t *data, size_t length)\r\n{\r\nif (length == 0) {\r\nprintf("bus reset\r\n");\r\nclear_pending_transaction_list();\r\n} else if (length > sizeof(struct phy_packet)) {\r\nstruct link_packet *p = (struct link_packet *) data;\r\nswitch (packet_info[p->common.tcode].type) {\r\ncase PACKET_REQUEST:\r\nreturn handle_request_packet(data, length);\r\ncase PACKET_RESPONSE:\r\nreturn handle_response_packet(data, length);\r\ncase PACKET_OTHER:\r\ncase PACKET_RESERVED:\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned int\r\nget_bits(struct link_packet *packet, int offset, int width)\r\n{\r\nuint32_t *data = (uint32_t *) packet;\r\nuint32_t index, shift, mask;\r\nindex = offset / 32 + 1;\r\nshift = 32 - (offset & 31) - width;\r\nmask = width == 32 ? ~0 : (1 << width) - 1;\r\nreturn (data[index] >> shift) & mask;\r\n}\r\nstatic void\r\ndump_data(unsigned char *data, int length)\r\n{\r\nint i, print_length;\r\nif (length > 128)\r\nprint_length = 128;\r\nelse\r\nprint_length = length;\r\nfor (i = 0; i < print_length; i++)\r\nprintf("%s%02hhx",\r\n(i % 4 == 0 && i != 0) ? " " : "",\r\ndata[byte_index(i)]);\r\nif (print_length < length)\r\nprintf(" (%d more bytes)", length - print_length);\r\n}\r\nstatic void\r\ndecode_link_packet(struct link_packet *packet, size_t length,\r\nint include_flags, int exclude_flags)\r\n{\r\nconst struct packet_info *pi;\r\nint data_length = 0;\r\nint i;\r\npi = &packet_info[packet->common.tcode];\r\nfor (i = 0; i < pi->field_count; i++) {\r\nconst struct packet_field *f = &pi->fields[i];\r\nint offset;\r\nif (f->flags & exclude_flags)\r\ncontinue;\r\nif (include_flags && !(f->flags & include_flags))\r\ncontinue;\r\nif (f->offset < 0)\r\noffset = length * 8 + f->offset - 32;\r\nelse\r\noffset = f->offset;\r\nif (f->value_names != NULL) {\r\nuint32_t bits;\r\nbits = get_bits(packet, offset, f->width);\r\nprintf("%s", f->value_names[bits]);\r\n} else if (f->width == 0) {\r\nprintf("%s=[", f->name);\r\ndump_data((unsigned char *) packet + (offset / 8 + 4), data_length);\r\nprintf("]");\r\n} else {\r\nunsigned long long bits;\r\nint high_width, low_width;\r\nif ((offset & ~31) != ((offset + f->width - 1) & ~31)) {\r\nhigh_width = ((offset + 31) & ~31) - offset;\r\nlow_width = f->width - high_width;\r\nbits = get_bits(packet, offset, high_width);\r\nbits = (bits << low_width) |\r\nget_bits(packet, offset + high_width, low_width);\r\n} else {\r\nbits = get_bits(packet, offset, f->width);\r\n}\r\nprintf("%s=0x%0*llx", f->name, (f->width + 3) / 4, bits);\r\nif (f->flags & PACKET_FIELD_DATA_LENGTH)\r\ndata_length = bits;\r\n}\r\nif (i < pi->field_count - 1)\r\nprintf(", ");\r\n}\r\n}\r\nstatic void\r\nprint_packet(uint32_t *data, size_t length)\r\n{\r\nint i;\r\nprintf("%6u ", data[0]);\r\nif (length == 4) {\r\nprintf("bus reset");\r\n} else if (length < sizeof(struct phy_packet)) {\r\nprintf("short packet: ");\r\nfor (i = 1; i < length / 4; i++)\r\nprintf("%s%08x", i == 0 ? "[" : " ", data[i]);\r\nprintf("]");\r\n} else if (length == sizeof(struct phy_packet) && data[1] == ~data[2]) {\r\nstruct phy_packet *pp = (struct phy_packet *) data;\r\nswitch (pp->common.identifier) {\r\ncase PHY_PACKET_CONFIGURATION:\r\nif (!pp->phy_config.set_root && !pp->phy_config.set_gap_count) {\r\nprintf("ext phy config: phy_id=%02x", pp->phy_config.root_id);\r\n} else {\r\nprintf("phy config:");\r\nif (pp->phy_config.set_root)\r\nprintf(" set_root_id=%02x", pp->phy_config.root_id);\r\nif (pp->phy_config.set_gap_count)\r\nprintf(" set_gap_count=%d", pp->phy_config.gap_count);\r\n}\r\nbreak;\r\ncase PHY_PACKET_LINK_ON:\r\nprintf("link-on packet, phy_id=%02x", pp->link_on.phy_id);\r\nbreak;\r\ncase PHY_PACKET_SELF_ID:\r\nif (pp->self_id.extended) {\r\nprintf("extended self id: phy_id=%02x, seq=%d",\r\npp->ext_self_id.phy_id, pp->ext_self_id.sequence);\r\n} else {\r\nstatic const char * const speed_names[] = {\r\n"S100", "S200", "S400", "BETA"\r\n};\r\nprintf("self id: phy_id=%02x, link %s, gap_count=%d, speed=%s%s%s",\r\npp->self_id.phy_id,\r\n(pp->self_id.link_active ? "active" : "not active"),\r\npp->self_id.gap_count,\r\nspeed_names[pp->self_id.phy_speed],\r\n(pp->self_id.contender ? ", irm contender" : ""),\r\n(pp->self_id.initiated_reset ? ", initiator" : ""));\r\n}\r\nbreak;\r\ndefault:\r\nprintf("unknown phy packet: ");\r\nfor (i = 1; i < length / 4; i++)\r\nprintf("%s%08x", i == 0 ? "[" : " ", data[i]);\r\nprintf("]");\r\nbreak;\r\n}\r\n} else {\r\nstruct link_packet *packet = (struct link_packet *) data;\r\ndecode_link_packet(packet, length, 0,\r\noption_verbose ? 0 : PACKET_FIELD_DETAIL);\r\n}\r\nif (option_hex) {\r\nprintf(" [");\r\ndump_data((unsigned char *) data + 4, length - 4);\r\nprintf("]");\r\n}\r\nprintf("\r\n");\r\n}\r\nstatic void\r\nprint_stats(uint32_t *data, size_t length)\r\n{\r\nstatic int bus_reset_count, short_packet_count, phy_packet_count;\r\nstatic int tcode_count[16];\r\nstatic struct timeval last_update;\r\nstruct timeval now;\r\nint i;\r\nif (length == 0)\r\nbus_reset_count++;\r\nelse if (length < sizeof(struct phy_packet))\r\nshort_packet_count++;\r\nelse if (length == sizeof(struct phy_packet) && data[1] == ~data[2])\r\nphy_packet_count++;\r\nelse {\r\nstruct link_packet *packet = (struct link_packet *) data;\r\ntcode_count[packet->common.tcode]++;\r\n}\r\ngettimeofday(&now, NULL);\r\nif (now.tv_sec <= last_update.tv_sec &&\r\nnow.tv_usec < last_update.tv_usec + 500000)\r\nreturn;\r\nlast_update = now;\r\nprintf(CLEAR HIDE_CURSOR\r\n" bus resets : %8d\n"\r\n" short packets : %8d\n"\r\n" phy packets : %8d\n",\r\nbus_reset_count, short_packet_count, phy_packet_count);\r\nfor (i = 0; i < array_length(packet_info); i++)\r\nif (packet_info[i].type != PACKET_RESERVED)\r\nprintf(" %-24s: %8d\n", packet_info[i].name, tcode_count[i]);\r\nprintf(SHOW_CURSOR "\n");\r\n}\r\nstatic void\r\nreset_input_mode(void)\r\n{\r\ntcsetattr(STDIN_FILENO, TCSANOW, &saved_attributes);\r\n}\r\nstatic void\r\nset_input_mode(void)\r\n{\r\nstruct termios tattr;\r\nif (!isatty(STDIN_FILENO)) {\r\nfprintf(stderr, "Not a terminal.\n");\r\nexit(EXIT_FAILURE);\r\n}\r\ntcgetattr(STDIN_FILENO, &saved_attributes);\r\natexit(reset_input_mode);\r\ntcgetattr(STDIN_FILENO, &tattr);\r\ntattr.c_lflag &= ~(ICANON|ECHO);\r\ntattr.c_cc[VMIN] = 1;\r\ntattr.c_cc[VTIME] = 0;\r\ntcsetattr(STDIN_FILENO, TCSAFLUSH, &tattr);\r\n}\r\nint main(int argc, const char *argv[])\r\n{\r\nuint32_t buf[128 * 1024];\r\nuint32_t filter;\r\nint length, retval, view;\r\nint fd = -1;\r\nFILE *output = NULL, *input = NULL;\r\npoptContext con;\r\nchar c;\r\nstruct pollfd pollfds[2];\r\nsys_sigint_handler = signal(SIGINT, sigint_handler);\r\ncon = poptGetContext(NULL, argc, argv, options, 0);\r\nretval = poptGetNextOpt(con);\r\nif (retval < -1) {\r\npoptPrintUsage(con, stdout, 0);\r\nreturn -1;\r\n}\r\nif (option_version) {\r\nprintf("dump tool for nosy sniffer, version %s\n", VERSION);\r\nreturn 0;\r\n}\r\nif (__BYTE_ORDER != __LITTLE_ENDIAN)\r\nfprintf(stderr, "warning: nosy has only been tested on little "\r\n"endian machines\n");\r\nif (option_input != NULL) {\r\ninput = fopen(option_input, "r");\r\nif (input == NULL) {\r\nfprintf(stderr, "Could not open %s, %m\n", option_input);\r\nreturn -1;\r\n}\r\n} else {\r\nfd = open(option_nosy_device, O_RDWR);\r\nif (fd < 0) {\r\nfprintf(stderr, "Could not open %s, %m\n", option_nosy_device);\r\nreturn -1;\r\n}\r\nset_input_mode();\r\n}\r\nif (strcmp(option_view, "transaction") == 0)\r\nview = VIEW_TRANSACTION;\r\nelse if (strcmp(option_view, "stats") == 0)\r\nview = VIEW_STATS;\r\nelse\r\nview = VIEW_PACKET;\r\nif (option_output) {\r\noutput = fopen(option_output, "w");\r\nif (output == NULL) {\r\nfprintf(stderr, "Could not open %s, %m\n", option_output);\r\nreturn -1;\r\n}\r\n}\r\nsetvbuf(stdout, NULL, _IOLBF, BUFSIZ);\r\nfilter = ~0;\r\nif (!option_iso)\r\nfilter &= ~(1 << TCODE_STREAM_DATA);\r\nif (!option_cycle_start)\r\nfilter &= ~(1 << TCODE_CYCLE_START);\r\nif (view == VIEW_STATS)\r\nfilter = ~(1 << TCODE_CYCLE_START);\r\nioctl(fd, NOSY_IOC_FILTER, filter);\r\nioctl(fd, NOSY_IOC_START);\r\npollfds[0].fd = fd;\r\npollfds[0].events = POLLIN;\r\npollfds[1].fd = STDIN_FILENO;\r\npollfds[1].events = POLLIN;\r\nwhile (run) {\r\nif (input != NULL) {\r\nif (fread(&length, sizeof length, 1, input) != 1)\r\nreturn 0;\r\nfread(buf, 1, length, input);\r\n} else {\r\npoll(pollfds, 2, -1);\r\nif (pollfds[1].revents) {\r\nread(STDIN_FILENO, &c, sizeof c);\r\nswitch (c) {\r\ncase 'q':\r\nif (output != NULL)\r\nfclose(output);\r\nreturn 0;\r\n}\r\n}\r\nif (pollfds[0].revents)\r\nlength = read(fd, buf, sizeof buf);\r\nelse\r\ncontinue;\r\n}\r\nif (output != NULL) {\r\nfwrite(&length, sizeof length, 1, output);\r\nfwrite(buf, 1, length, output);\r\n}\r\nswitch (view) {\r\ncase VIEW_TRANSACTION:\r\nhandle_packet(buf, length);\r\nbreak;\r\ncase VIEW_PACKET:\r\nprint_packet(buf, length);\r\nbreak;\r\ncase VIEW_STATS:\r\nprint_stats(buf, length);\r\nbreak;\r\n}\r\n}\r\nif (output != NULL)\r\nfclose(output);\r\nclose(fd);\r\npoptFreeContext(con);\r\nreturn 0;\r\n}
