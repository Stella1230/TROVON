static ssize_t get_fan(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct max6650_data *data = max6650_update_device(dev);\r\nint rpm;\r\nrpm = ((data->tach[attr->index] * 120) / DIV_FROM_REG(data->count));\r\nreturn sprintf(buf, "%d\n", rpm);\r\n}\r\nstatic ssize_t get_target(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct max6650_data *data = max6650_update_device(dev);\r\nint kscale, ktach, rpm;\r\nkscale = DIV_FROM_REG(data->config);\r\nktach = data->speed;\r\nrpm = 60 * kscale * clock / (256 * (ktach + 1));\r\nreturn sprintf(buf, "%d\n", rpm);\r\n}\r\nstatic ssize_t set_target(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct max6650_data *data = i2c_get_clientdata(client);\r\nint kscale, ktach;\r\nunsigned long rpm;\r\nint err;\r\nerr = kstrtoul(buf, 10, &rpm);\r\nif (err)\r\nreturn err;\r\nrpm = SENSORS_LIMIT(rpm, FAN_RPM_MIN, FAN_RPM_MAX);\r\nmutex_lock(&data->update_lock);\r\nkscale = DIV_FROM_REG(data->config);\r\nktach = ((clock * kscale) / (256 * rpm / 60)) - 1;\r\nif (ktach < 0)\r\nktach = 0;\r\nif (ktach > 255)\r\nktach = 255;\r\ndata->speed = ktach;\r\ni2c_smbus_write_byte_data(client, MAX6650_REG_SPEED, data->speed);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t get_pwm(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nint pwm;\r\nstruct max6650_data *data = max6650_update_device(dev);\r\nif (data->config & MAX6650_CFG_V12)\r\npwm = 255 - (255 * (int)data->dac)/180;\r\nelse\r\npwm = 255 - (255 * (int)data->dac)/76;\r\nif (pwm < 0)\r\npwm = 0;\r\nreturn sprintf(buf, "%d\n", pwm);\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct max6650_data *data = i2c_get_clientdata(client);\r\nunsigned long pwm;\r\nint err;\r\nerr = kstrtoul(buf, 10, &pwm);\r\nif (err)\r\nreturn err;\r\npwm = SENSORS_LIMIT(pwm, 0, 255);\r\nmutex_lock(&data->update_lock);\r\nif (data->config & MAX6650_CFG_V12)\r\ndata->dac = 180 - (180 * pwm)/255;\r\nelse\r\ndata->dac = 76 - (76 * pwm)/255;\r\ni2c_smbus_write_byte_data(client, MAX6650_REG_DAC, data->dac);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t get_enable(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct max6650_data *data = max6650_update_device(dev);\r\nint mode = (data->config & MAX6650_CFG_MODE_MASK) >> 4;\r\nint sysfs_modes[4] = {0, 1, 2, 1};\r\nreturn sprintf(buf, "%d\n", sysfs_modes[mode]);\r\n}\r\nstatic ssize_t set_enable(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct max6650_data *data = i2c_get_clientdata(client);\r\nint max6650_modes[3] = {0, 3, 2};\r\nunsigned long mode;\r\nint err;\r\nerr = kstrtoul(buf, 10, &mode);\r\nif (err)\r\nreturn err;\r\nif (mode > 2)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->config = i2c_smbus_read_byte_data(client, MAX6650_REG_CONFIG);\r\ndata->config = (data->config & ~MAX6650_CFG_MODE_MASK)\r\n| (max6650_modes[mode] << 4);\r\ni2c_smbus_write_byte_data(client, MAX6650_REG_CONFIG, data->config);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t get_div(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct max6650_data *data = max6650_update_device(dev);\r\nreturn sprintf(buf, "%d\n", DIV_FROM_REG(data->count));\r\n}\r\nstatic ssize_t set_div(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct max6650_data *data = i2c_get_clientdata(client);\r\nunsigned long div;\r\nint err;\r\nerr = kstrtoul(buf, 10, &div);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nswitch (div) {\r\ncase 1:\r\ndata->count = 0;\r\nbreak;\r\ncase 2:\r\ndata->count = 1;\r\nbreak;\r\ncase 4:\r\ndata->count = 2;\r\nbreak;\r\ncase 8:\r\ndata->count = 3;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&data->update_lock);\r\nreturn -EINVAL;\r\n}\r\ni2c_smbus_write_byte_data(client, MAX6650_REG_COUNT, data->count);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t get_alarm(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct max6650_data *data = max6650_update_device(dev);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint alarm = 0;\r\nif (data->alarm & attr->index) {\r\nmutex_lock(&data->update_lock);\r\nalarm = 1;\r\ndata->alarm &= ~attr->index;\r\ndata->alarm |= i2c_smbus_read_byte_data(client,\r\nMAX6650_REG_ALARM);\r\nmutex_unlock(&data->update_lock);\r\n}\r\nreturn sprintf(buf, "%d\n", alarm);\r\n}\r\nstatic umode_t max6650_attrs_visible(struct kobject *kobj, struct attribute *a,\r\nint n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nu8 alarm_en = i2c_smbus_read_byte_data(client, MAX6650_REG_ALARM_EN);\r\nstruct device_attribute *devattr;\r\ndevattr = container_of(a, struct device_attribute, attr);\r\nif (devattr == &sensor_dev_attr_fan1_max_alarm.dev_attr\r\n|| devattr == &sensor_dev_attr_fan1_min_alarm.dev_attr\r\n|| devattr == &sensor_dev_attr_fan1_fault.dev_attr\r\n|| devattr == &sensor_dev_attr_gpio1_alarm.dev_attr\r\n|| devattr == &sensor_dev_attr_gpio2_alarm.dev_attr) {\r\nif (!(alarm_en & to_sensor_dev_attr(devattr)->index))\r\nreturn 0;\r\n}\r\nreturn a->mode;\r\n}\r\nstatic int max6650_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct max6650_data *data;\r\nint err;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct max6650_data),\r\nGFP_KERNEL);\r\nif (!data) {\r\ndev_err(&client->dev, "out of memory.\n");\r\nreturn -ENOMEM;\r\n}\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\ndata->nr_fans = id->driver_data;\r\nerr = max6650_init_client(client);\r\nif (err)\r\nreturn err;\r\nerr = sysfs_create_group(&client->dev.kobj, &max6650_attr_grp);\r\nif (err)\r\nreturn err;\r\nif (data->nr_fans == 4) {\r\nerr = sysfs_create_group(&client->dev.kobj, &max6651_attr_grp);\r\nif (err)\r\ngoto err_remove;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (!IS_ERR(data->hwmon_dev))\r\nreturn 0;\r\nerr = PTR_ERR(data->hwmon_dev);\r\ndev_err(&client->dev, "error registering hwmon device.\n");\r\nif (data->nr_fans == 4)\r\nsysfs_remove_group(&client->dev.kobj, &max6651_attr_grp);\r\nerr_remove:\r\nsysfs_remove_group(&client->dev.kobj, &max6650_attr_grp);\r\nreturn err;\r\n}\r\nstatic int max6650_remove(struct i2c_client *client)\r\n{\r\nstruct max6650_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nif (data->nr_fans == 4)\r\nsysfs_remove_group(&client->dev.kobj, &max6651_attr_grp);\r\nsysfs_remove_group(&client->dev.kobj, &max6650_attr_grp);\r\nreturn 0;\r\n}\r\nstatic int max6650_init_client(struct i2c_client *client)\r\n{\r\nstruct max6650_data *data = i2c_get_clientdata(client);\r\nint config;\r\nint err = -EIO;\r\nconfig = i2c_smbus_read_byte_data(client, MAX6650_REG_CONFIG);\r\nif (config < 0) {\r\ndev_err(&client->dev, "Error reading config, aborting.\n");\r\nreturn err;\r\n}\r\nswitch (fan_voltage) {\r\ncase 0:\r\nbreak;\r\ncase 5:\r\nconfig &= ~MAX6650_CFG_V12;\r\nbreak;\r\ncase 12:\r\nconfig |= MAX6650_CFG_V12;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "illegal value for fan_voltage (%d)\n",\r\nfan_voltage);\r\n}\r\ndev_info(&client->dev, "Fan voltage is set to %dV.\n",\r\n(config & MAX6650_CFG_V12) ? 12 : 5);\r\nswitch (prescaler) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nconfig &= ~MAX6650_CFG_PRESCALER_MASK;\r\nbreak;\r\ncase 2:\r\nconfig = (config & ~MAX6650_CFG_PRESCALER_MASK)\r\n| MAX6650_CFG_PRESCALER_2;\r\nbreak;\r\ncase 4:\r\nconfig = (config & ~MAX6650_CFG_PRESCALER_MASK)\r\n| MAX6650_CFG_PRESCALER_4;\r\nbreak;\r\ncase 8:\r\nconfig = (config & ~MAX6650_CFG_PRESCALER_MASK)\r\n| MAX6650_CFG_PRESCALER_8;\r\nbreak;\r\ncase 16:\r\nconfig = (config & ~MAX6650_CFG_PRESCALER_MASK)\r\n| MAX6650_CFG_PRESCALER_16;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "illegal value for prescaler (%d)\n",\r\nprescaler);\r\n}\r\ndev_info(&client->dev, "Prescaler is set to %d.\n",\r\n1 << (config & MAX6650_CFG_PRESCALER_MASK));\r\nif ((config & MAX6650_CFG_MODE_MASK) == MAX6650_CFG_MODE_OFF) {\r\ndev_dbg(&client->dev, "Change mode to open loop, full off.\n");\r\nconfig = (config & ~MAX6650_CFG_MODE_MASK)\r\n| MAX6650_CFG_MODE_OPEN_LOOP;\r\nif (i2c_smbus_write_byte_data(client, MAX6650_REG_DAC, 255)) {\r\ndev_err(&client->dev, "DAC write error, aborting.\n");\r\nreturn err;\r\n}\r\n}\r\nif (i2c_smbus_write_byte_data(client, MAX6650_REG_CONFIG, config)) {\r\ndev_err(&client->dev, "Config write error, aborting.\n");\r\nreturn err;\r\n}\r\ndata->config = config;\r\ndata->count = i2c_smbus_read_byte_data(client, MAX6650_REG_COUNT);\r\nreturn 0;\r\n}\r\nstatic struct max6650_data *max6650_update_device(struct device *dev)\r\n{\r\nint i;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct max6650_data *data = i2c_get_clientdata(client);\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\ndata->speed = i2c_smbus_read_byte_data(client,\r\nMAX6650_REG_SPEED);\r\ndata->config = i2c_smbus_read_byte_data(client,\r\nMAX6650_REG_CONFIG);\r\nfor (i = 0; i < data->nr_fans; i++) {\r\ndata->tach[i] = i2c_smbus_read_byte_data(client,\r\ntach_reg[i]);\r\n}\r\ndata->count = i2c_smbus_read_byte_data(client,\r\nMAX6650_REG_COUNT);\r\ndata->dac = i2c_smbus_read_byte_data(client, MAX6650_REG_DAC);\r\ndata->alarm |= i2c_smbus_read_byte_data(client,\r\nMAX6650_REG_ALARM);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}
