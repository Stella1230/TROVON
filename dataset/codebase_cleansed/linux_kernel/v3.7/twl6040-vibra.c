static irqreturn_t twl6040_vib_irq_handler(int irq, void *data)\r\n{\r\nstruct vibra_info *info = data;\r\nstruct twl6040 *twl6040 = info->twl6040;\r\nu8 status;\r\nstatus = twl6040_reg_read(twl6040, TWL6040_REG_STATUS);\r\nif (status & TWL6040_VIBLOCDET) {\r\ndev_warn(info->dev, "Left Vibrator overcurrent detected\n");\r\ntwl6040_clear_bits(twl6040, TWL6040_REG_VIBCTLL,\r\nTWL6040_VIBENA);\r\n}\r\nif (status & TWL6040_VIBROCDET) {\r\ndev_warn(info->dev, "Right Vibrator overcurrent detected\n");\r\ntwl6040_clear_bits(twl6040, TWL6040_REG_VIBCTLR,\r\nTWL6040_VIBENA);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void twl6040_vibra_enable(struct vibra_info *info)\r\n{\r\nstruct twl6040 *twl6040 = info->twl6040;\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(info->supplies), info->supplies);\r\nif (ret) {\r\ndev_err(info->dev, "failed to enable regulators %d\n", ret);\r\nreturn;\r\n}\r\ntwl6040_power(info->twl6040, 1);\r\nif (twl6040_get_revid(twl6040) <= TWL6040_REV_ES1_1) {\r\ntwl6040_reg_write(twl6040, TWL6040_REG_VIBCTLL,\r\nTWL6040_VIBENA | TWL6040_VIBCTRL);\r\ntwl6040_reg_write(twl6040, TWL6040_REG_VIBCTLR,\r\nTWL6040_VIBENA | TWL6040_VIBCTRL);\r\nusleep_range(3000, 3500);\r\n}\r\ntwl6040_reg_write(twl6040, TWL6040_REG_VIBCTLL,\r\nTWL6040_VIBENA);\r\ntwl6040_reg_write(twl6040, TWL6040_REG_VIBCTLR,\r\nTWL6040_VIBENA);\r\ninfo->enabled = true;\r\n}\r\nstatic void twl6040_vibra_disable(struct vibra_info *info)\r\n{\r\nstruct twl6040 *twl6040 = info->twl6040;\r\ntwl6040_reg_write(twl6040, TWL6040_REG_VIBCTLL, 0x00);\r\ntwl6040_reg_write(twl6040, TWL6040_REG_VIBCTLR, 0x00);\r\ntwl6040_power(info->twl6040, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(info->supplies), info->supplies);\r\ninfo->enabled = false;\r\n}\r\nstatic u8 twl6040_vibra_code(int vddvib, int vibdrv_res, int motor_res,\r\nint speed, int direction)\r\n{\r\nint vpk, max_code;\r\nu8 vibdat;\r\nvpk = (vddvib * motor_res * TWL6040_VIBRA_MOD) /\r\n(100 * (vibdrv_res + motor_res));\r\nmax_code = vpk / 50;\r\nif (max_code > TWL6040_VIBDAT_MAX)\r\nmax_code = TWL6040_VIBDAT_MAX;\r\nvibdat = (u8)((speed * max_code) / USHRT_MAX);\r\nvibdat *= direction;\r\nreturn vibdat;\r\n}\r\nstatic void twl6040_vibra_set_effect(struct vibra_info *info)\r\n{\r\nstruct twl6040 *twl6040 = info->twl6040;\r\nu8 vibdatl, vibdatr;\r\nint volt;\r\nvolt = regulator_get_voltage(info->supplies[0].consumer) / 1000;\r\nvibdatl = twl6040_vibra_code(volt, info->vibldrv_res,\r\ninfo->viblmotor_res,\r\ninfo->weak_speed, info->direction);\r\nvolt = regulator_get_voltage(info->supplies[1].consumer) / 1000;\r\nvibdatr = twl6040_vibra_code(volt, info->vibrdrv_res,\r\ninfo->vibrmotor_res,\r\ninfo->strong_speed, info->direction);\r\ntwl6040_reg_write(twl6040, TWL6040_REG_VIBDATL, vibdatl);\r\ntwl6040_reg_write(twl6040, TWL6040_REG_VIBDATR, vibdatr);\r\n}\r\nstatic void vibra_play_work(struct work_struct *work)\r\n{\r\nstruct vibra_info *info = container_of(work,\r\nstruct vibra_info, play_work);\r\nmutex_lock(&info->mutex);\r\nif (info->weak_speed || info->strong_speed) {\r\nif (!info->enabled)\r\ntwl6040_vibra_enable(info);\r\ntwl6040_vibra_set_effect(info);\r\n} else if (info->enabled)\r\ntwl6040_vibra_disable(info);\r\nmutex_unlock(&info->mutex);\r\n}\r\nstatic int vibra_play(struct input_dev *input, void *data,\r\nstruct ff_effect *effect)\r\n{\r\nstruct vibra_info *info = input_get_drvdata(input);\r\nint ret;\r\nret = twl6040_get_vibralr_status(info->twl6040);\r\nif (ret & TWL6040_VIBSEL) {\r\ndev_info(&input->dev, "Vibra is configured for audio\n");\r\nreturn -EBUSY;\r\n}\r\ninfo->weak_speed = effect->u.rumble.weak_magnitude;\r\ninfo->strong_speed = effect->u.rumble.strong_magnitude;\r\ninfo->direction = effect->direction < EFFECT_DIR_180_DEG ? 1 : -1;\r\nret = queue_work(info->workqueue, &info->play_work);\r\nif (!ret) {\r\ndev_info(&input->dev, "work is already on queue\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void twl6040_vibra_close(struct input_dev *input)\r\n{\r\nstruct vibra_info *info = input_get_drvdata(input);\r\ncancel_work_sync(&info->play_work);\r\nmutex_lock(&info->mutex);\r\nif (info->enabled)\r\ntwl6040_vibra_disable(info);\r\nmutex_unlock(&info->mutex);\r\n}\r\nstatic int twl6040_vibra_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct vibra_info *info = platform_get_drvdata(pdev);\r\nmutex_lock(&info->mutex);\r\nif (info->enabled)\r\ntwl6040_vibra_disable(info);\r\nmutex_unlock(&info->mutex);\r\nreturn 0;\r\n}\r\nstatic int __devinit twl6040_vibra_probe(struct platform_device *pdev)\r\n{\r\nstruct twl6040_vibra_data *pdata = pdev->dev.platform_data;\r\nstruct device *twl6040_core_dev = pdev->dev.parent;\r\nstruct device_node *twl6040_core_node = NULL;\r\nstruct vibra_info *info;\r\nint vddvibl_uV = 0;\r\nint vddvibr_uV = 0;\r\nint ret;\r\n#ifdef CONFIG_OF\r\ntwl6040_core_node = of_find_node_by_name(twl6040_core_dev->of_node,\r\n"vibra");\r\n#endif\r\nif (!pdata && !twl6040_core_node) {\r\ndev_err(&pdev->dev, "platform_data not available\n");\r\nreturn -EINVAL;\r\n}\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\ndev_err(&pdev->dev, "couldn't allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->dev = &pdev->dev;\r\ninfo->twl6040 = dev_get_drvdata(pdev->dev.parent);\r\nif (pdata) {\r\ninfo->vibldrv_res = pdata->vibldrv_res;\r\ninfo->vibrdrv_res = pdata->vibrdrv_res;\r\ninfo->viblmotor_res = pdata->viblmotor_res;\r\ninfo->vibrmotor_res = pdata->vibrmotor_res;\r\nvddvibl_uV = pdata->vddvibl_uV;\r\nvddvibr_uV = pdata->vddvibr_uV;\r\n} else {\r\nof_property_read_u32(twl6040_core_node, "ti,vibldrv-res",\r\n&info->vibldrv_res);\r\nof_property_read_u32(twl6040_core_node, "ti,vibrdrv-res",\r\n&info->vibrdrv_res);\r\nof_property_read_u32(twl6040_core_node, "ti,viblmotor-res",\r\n&info->viblmotor_res);\r\nof_property_read_u32(twl6040_core_node, "ti,vibrmotor-res",\r\n&info->vibrmotor_res);\r\nof_property_read_u32(twl6040_core_node, "ti,vddvibl-uV",\r\n&vddvibl_uV);\r\nof_property_read_u32(twl6040_core_node, "ti,vddvibr-uV",\r\n&vddvibr_uV);\r\n}\r\nif ((!info->vibldrv_res && !info->viblmotor_res) ||\r\n(!info->vibrdrv_res && !info->vibrmotor_res)) {\r\ndev_err(info->dev, "invalid vibra driver/motor resistance\n");\r\nret = -EINVAL;\r\ngoto err_kzalloc;\r\n}\r\ninfo->irq = platform_get_irq(pdev, 0);\r\nif (info->irq < 0) {\r\ndev_err(info->dev, "invalid irq\n");\r\nret = -EINVAL;\r\ngoto err_kzalloc;\r\n}\r\nmutex_init(&info->mutex);\r\ninfo->input_dev = input_allocate_device();\r\nif (info->input_dev == NULL) {\r\ndev_err(info->dev, "couldn't allocate input device\n");\r\nret = -ENOMEM;\r\ngoto err_kzalloc;\r\n}\r\ninput_set_drvdata(info->input_dev, info);\r\ninfo->input_dev->name = "twl6040:vibrator";\r\ninfo->input_dev->id.version = 1;\r\ninfo->input_dev->dev.parent = pdev->dev.parent;\r\ninfo->input_dev->close = twl6040_vibra_close;\r\n__set_bit(FF_RUMBLE, info->input_dev->ffbit);\r\nret = input_ff_create_memless(info->input_dev, NULL, vibra_play);\r\nif (ret < 0) {\r\ndev_err(info->dev, "couldn't register vibrator to FF\n");\r\ngoto err_ialloc;\r\n}\r\nret = input_register_device(info->input_dev);\r\nif (ret < 0) {\r\ndev_err(info->dev, "couldn't register input device\n");\r\ngoto err_iff;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nret = request_threaded_irq(info->irq, NULL, twl6040_vib_irq_handler, 0,\r\n"twl6040_irq_vib", info);\r\nif (ret) {\r\ndev_err(info->dev, "VIB IRQ request failed: %d\n", ret);\r\ngoto err_irq;\r\n}\r\ninfo->supplies[0].supply = "vddvibl";\r\ninfo->supplies[1].supply = "vddvibr";\r\nret = regulator_bulk_get(pdata ? info->dev : twl6040_core_dev,\r\nARRAY_SIZE(info->supplies), info->supplies);\r\nif (ret) {\r\ndev_err(info->dev, "couldn't get regulators %d\n", ret);\r\ngoto err_regulator;\r\n}\r\nif (vddvibl_uV) {\r\nret = regulator_set_voltage(info->supplies[0].consumer,\r\nvddvibl_uV, vddvibl_uV);\r\nif (ret) {\r\ndev_err(info->dev, "failed to set VDDVIBL volt %d\n",\r\nret);\r\ngoto err_voltage;\r\n}\r\n}\r\nif (vddvibr_uV) {\r\nret = regulator_set_voltage(info->supplies[1].consumer,\r\nvddvibr_uV, vddvibr_uV);\r\nif (ret) {\r\ndev_err(info->dev, "failed to set VDDVIBR volt %d\n",\r\nret);\r\ngoto err_voltage;\r\n}\r\n}\r\ninfo->workqueue = alloc_workqueue("twl6040-vibra", 0, 0);\r\nif (info->workqueue == NULL) {\r\ndev_err(info->dev, "couldn't create workqueue\n");\r\nret = -ENOMEM;\r\ngoto err_voltage;\r\n}\r\nINIT_WORK(&info->play_work, vibra_play_work);\r\nreturn 0;\r\nerr_voltage:\r\nregulator_bulk_free(ARRAY_SIZE(info->supplies), info->supplies);\r\nerr_regulator:\r\nfree_irq(info->irq, info);\r\nerr_irq:\r\ninput_unregister_device(info->input_dev);\r\ninfo->input_dev = NULL;\r\nerr_iff:\r\nif (info->input_dev)\r\ninput_ff_destroy(info->input_dev);\r\nerr_ialloc:\r\ninput_free_device(info->input_dev);\r\nerr_kzalloc:\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int __devexit twl6040_vibra_remove(struct platform_device *pdev)\r\n{\r\nstruct vibra_info *info = platform_get_drvdata(pdev);\r\ninput_unregister_device(info->input_dev);\r\nfree_irq(info->irq, info);\r\nregulator_bulk_free(ARRAY_SIZE(info->supplies), info->supplies);\r\ndestroy_workqueue(info->workqueue);\r\nkfree(info);\r\nreturn 0;\r\n}
