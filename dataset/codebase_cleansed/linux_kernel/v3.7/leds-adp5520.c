static void adp5520_led_work(struct work_struct *work)\r\n{\r\nstruct adp5520_led *led = container_of(work, struct adp5520_led, work);\r\nadp5520_write(led->master, ADP5520_LED1_CURRENT + led->id - 1,\r\nled->new_brightness >> 2);\r\n}\r\nstatic void adp5520_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct adp5520_led *led;\r\nled = container_of(led_cdev, struct adp5520_led, cdev);\r\nled->new_brightness = value;\r\nschedule_work(&led->work);\r\n}\r\nstatic int adp5520_led_setup(struct adp5520_led *led)\r\n{\r\nstruct device *dev = led->master;\r\nint flags = led->flags;\r\nint ret = 0;\r\nswitch (led->id) {\r\ncase FLAG_ID_ADP5520_LED1_ADP5501_LED0:\r\nret |= adp5520_set_bits(dev, ADP5520_LED_TIME,\r\n(flags >> ADP5520_FLAG_OFFT_SHIFT) &\r\nADP5520_FLAG_OFFT_MASK);\r\nret |= adp5520_set_bits(dev, ADP5520_LED_CONTROL,\r\nADP5520_LED1_EN);\r\nbreak;\r\ncase FLAG_ID_ADP5520_LED2_ADP5501_LED1:\r\nret |= adp5520_set_bits(dev, ADP5520_LED_TIME,\r\n((flags >> ADP5520_FLAG_OFFT_SHIFT) &\r\nADP5520_FLAG_OFFT_MASK) << 2);\r\nret |= adp5520_clr_bits(dev, ADP5520_LED_CONTROL,\r\nADP5520_R3_MODE);\r\nret |= adp5520_set_bits(dev, ADP5520_LED_CONTROL,\r\nADP5520_LED2_EN);\r\nbreak;\r\ncase FLAG_ID_ADP5520_LED3_ADP5501_LED2:\r\nret |= adp5520_set_bits(dev, ADP5520_LED_TIME,\r\n((flags >> ADP5520_FLAG_OFFT_SHIFT) &\r\nADP5520_FLAG_OFFT_MASK) << 4);\r\nret |= adp5520_clr_bits(dev, ADP5520_LED_CONTROL,\r\nADP5520_C3_MODE);\r\nret |= adp5520_set_bits(dev, ADP5520_LED_CONTROL,\r\nADP5520_LED3_EN);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devinit adp5520_led_prepare(struct platform_device *pdev)\r\n{\r\nstruct adp5520_leds_platform_data *pdata = pdev->dev.platform_data;\r\nstruct device *dev = pdev->dev.parent;\r\nint ret = 0;\r\nret |= adp5520_write(dev, ADP5520_LED1_CURRENT, 0);\r\nret |= adp5520_write(dev, ADP5520_LED2_CURRENT, 0);\r\nret |= adp5520_write(dev, ADP5520_LED3_CURRENT, 0);\r\nret |= adp5520_write(dev, ADP5520_LED_TIME, pdata->led_on_time << 6);\r\nret |= adp5520_write(dev, ADP5520_LED_FADE, FADE_VAL(pdata->fade_in,\r\npdata->fade_out));\r\nreturn ret;\r\n}\r\nstatic int __devinit adp5520_led_probe(struct platform_device *pdev)\r\n{\r\nstruct adp5520_leds_platform_data *pdata = pdev->dev.platform_data;\r\nstruct adp5520_led *led, *led_dat;\r\nstruct led_info *cur_led;\r\nint ret, i;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "missing platform data\n");\r\nreturn -ENODEV;\r\n}\r\nif (pdata->num_leds > ADP5520_01_MAXLEDS) {\r\ndev_err(&pdev->dev, "can't handle more than %d LEDS\n",\r\nADP5520_01_MAXLEDS);\r\nreturn -EFAULT;\r\n}\r\nled = devm_kzalloc(&pdev->dev, sizeof(*led) * pdata->num_leds,\r\nGFP_KERNEL);\r\nif (led == NULL) {\r\ndev_err(&pdev->dev, "failed to alloc memory\n");\r\nreturn -ENOMEM;\r\n}\r\nret = adp5520_led_prepare(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to write\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < pdata->num_leds; ++i) {\r\ncur_led = &pdata->leds[i];\r\nled_dat = &led[i];\r\nled_dat->cdev.name = cur_led->name;\r\nled_dat->cdev.default_trigger = cur_led->default_trigger;\r\nled_dat->cdev.brightness_set = adp5520_led_set;\r\nled_dat->cdev.brightness = LED_OFF;\r\nif (cur_led->flags & ADP5520_FLAG_LED_MASK)\r\nled_dat->flags = cur_led->flags;\r\nelse\r\nled_dat->flags = i + 1;\r\nled_dat->id = led_dat->flags & ADP5520_FLAG_LED_MASK;\r\nled_dat->master = pdev->dev.parent;\r\nled_dat->new_brightness = LED_OFF;\r\nINIT_WORK(&led_dat->work, adp5520_led_work);\r\nret = led_classdev_register(led_dat->master, &led_dat->cdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register LED %d\n",\r\nled_dat->id);\r\ngoto err;\r\n}\r\nret = adp5520_led_setup(led_dat);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to write\n");\r\ni++;\r\ngoto err;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, led);\r\nreturn 0;\r\nerr:\r\nif (i > 0) {\r\nfor (i = i - 1; i >= 0; i--) {\r\nled_classdev_unregister(&led[i].cdev);\r\ncancel_work_sync(&led[i].work);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devexit adp5520_led_remove(struct platform_device *pdev)\r\n{\r\nstruct adp5520_leds_platform_data *pdata = pdev->dev.platform_data;\r\nstruct adp5520_led *led;\r\nint i;\r\nled = platform_get_drvdata(pdev);\r\nadp5520_clr_bits(led->master, ADP5520_LED_CONTROL,\r\nADP5520_LED1_EN | ADP5520_LED2_EN | ADP5520_LED3_EN);\r\nfor (i = 0; i < pdata->num_leds; i++) {\r\nled_classdev_unregister(&led[i].cdev);\r\ncancel_work_sync(&led[i].work);\r\n}\r\nreturn 0;\r\n}
