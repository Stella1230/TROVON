static void smu_ads_release(struct wf_sensor *sr)\r\n{\r\nstruct smu_ad_sensor *ads = to_smu_ads(sr);\r\nkfree(ads);\r\n}\r\nstatic int smu_read_adc(u8 id, s32 *value)\r\n{\r\nstruct smu_simple_cmd cmd;\r\nDECLARE_COMPLETION_ONSTACK(comp);\r\nint rc;\r\nrc = smu_queue_simple(&cmd, SMU_CMD_READ_ADC, 1,\r\nsmu_done_complete, &comp, id);\r\nif (rc)\r\nreturn rc;\r\nwait_for_completion(&comp);\r\nif (cmd.cmd.status != 0)\r\nreturn cmd.cmd.status;\r\nif (cmd.cmd.reply_len != 2) {\r\nprintk(KERN_ERR "winfarm: read ADC 0x%x returned %d bytes !\n",\r\nid, cmd.cmd.reply_len);\r\nreturn -EIO;\r\n}\r\n*value = *((u16 *)cmd.buffer);\r\nreturn 0;\r\n}\r\nstatic int smu_cputemp_get(struct wf_sensor *sr, s32 *value)\r\n{\r\nstruct smu_ad_sensor *ads = to_smu_ads(sr);\r\nint rc;\r\ns32 val;\r\ns64 scaled;\r\nrc = smu_read_adc(ads->reg, &val);\r\nif (rc) {\r\nprintk(KERN_ERR "windfarm: read CPU temp failed, err %d\n",\r\nrc);\r\nreturn rc;\r\n}\r\nscaled = (s64)(((u64)val) * (u64)cpudiode->m_value);\r\nscaled >>= 3;\r\nscaled += ((s64)cpudiode->b_value) << 9;\r\n*value = (s32)(scaled << 1);\r\nreturn 0;\r\n}\r\nstatic int smu_cpuamp_get(struct wf_sensor *sr, s32 *value)\r\n{\r\nstruct smu_ad_sensor *ads = to_smu_ads(sr);\r\ns32 val, scaled;\r\nint rc;\r\nrc = smu_read_adc(ads->reg, &val);\r\nif (rc) {\r\nprintk(KERN_ERR "windfarm: read CPU current failed, err %d\n",\r\nrc);\r\nreturn rc;\r\n}\r\nscaled = (s32)(val * (u32)cpuvcp->curr_scale);\r\nscaled += (s32)cpuvcp->curr_offset;\r\n*value = scaled << 4;\r\nreturn 0;\r\n}\r\nstatic int smu_cpuvolt_get(struct wf_sensor *sr, s32 *value)\r\n{\r\nstruct smu_ad_sensor *ads = to_smu_ads(sr);\r\ns32 val, scaled;\r\nint rc;\r\nrc = smu_read_adc(ads->reg, &val);\r\nif (rc) {\r\nprintk(KERN_ERR "windfarm: read CPU voltage failed, err %d\n",\r\nrc);\r\nreturn rc;\r\n}\r\nscaled = (s32)(val * (u32)cpuvcp->volt_scale);\r\nscaled += (s32)cpuvcp->volt_offset;\r\n*value = scaled << 4;\r\nreturn 0;\r\n}\r\nstatic int smu_slotspow_get(struct wf_sensor *sr, s32 *value)\r\n{\r\nstruct smu_ad_sensor *ads = to_smu_ads(sr);\r\ns32 val, scaled;\r\nint rc;\r\nrc = smu_read_adc(ads->reg, &val);\r\nif (rc) {\r\nprintk(KERN_ERR "windfarm: read slots power failed, err %d\n",\r\nrc);\r\nreturn rc;\r\n}\r\nscaled = (s32)(val * (u32)slotspow->pow_scale);\r\nscaled += (s32)slotspow->pow_offset;\r\n*value = scaled << 4;\r\nreturn 0;\r\n}\r\nstatic struct smu_ad_sensor *smu_ads_create(struct device_node *node)\r\n{\r\nstruct smu_ad_sensor *ads;\r\nconst char *c, *l;\r\nconst u32 *v;\r\nads = kmalloc(sizeof(struct smu_ad_sensor), GFP_KERNEL);\r\nif (ads == NULL)\r\nreturn NULL;\r\nc = of_get_property(node, "device_type", NULL);\r\nl = of_get_property(node, "location", NULL);\r\nif (c == NULL || l == NULL)\r\ngoto fail;\r\nif (!strcmp(c, "temp-sensor") &&\r\n!strcmp(l, "CPU T-Diode")) {\r\nads->sens.ops = &smu_cputemp_ops;\r\nads->sens.name = "cpu-temp";\r\nif (cpudiode == NULL) {\r\nDBG("wf: cpudiode partition (%02x) not found\n",\r\nSMU_SDB_CPUDIODE_ID);\r\ngoto fail;\r\n}\r\n} else if (!strcmp(c, "current-sensor") &&\r\n!strcmp(l, "CPU Current")) {\r\nads->sens.ops = &smu_cpuamp_ops;\r\nads->sens.name = "cpu-current";\r\nif (cpuvcp == NULL) {\r\nDBG("wf: cpuvcp partition (%02x) not found\n",\r\nSMU_SDB_CPUVCP_ID);\r\ngoto fail;\r\n}\r\n} else if (!strcmp(c, "voltage-sensor") &&\r\n!strcmp(l, "CPU Voltage")) {\r\nads->sens.ops = &smu_cpuvolt_ops;\r\nads->sens.name = "cpu-voltage";\r\nif (cpuvcp == NULL) {\r\nDBG("wf: cpuvcp partition (%02x) not found\n",\r\nSMU_SDB_CPUVCP_ID);\r\ngoto fail;\r\n}\r\n} else if (!strcmp(c, "power-sensor") &&\r\n!strcmp(l, "Slots Power")) {\r\nads->sens.ops = &smu_slotspow_ops;\r\nads->sens.name = "slots-power";\r\nif (slotspow == NULL) {\r\nDBG("wf: slotspow partition (%02x) not found\n",\r\nSMU_SDB_SLOTSPOW_ID);\r\ngoto fail;\r\n}\r\n} else\r\ngoto fail;\r\nv = of_get_property(node, "reg", NULL);\r\nif (v == NULL)\r\ngoto fail;\r\nads->reg = *v;\r\nif (wf_register_sensor(&ads->sens))\r\ngoto fail;\r\nreturn ads;\r\nfail:\r\nkfree(ads);\r\nreturn NULL;\r\n}\r\nstatic void smu_cpu_power_release(struct wf_sensor *sr)\r\n{\r\nstruct smu_cpu_power_sensor *pow = to_smu_cpu_power(sr);\r\nif (pow->volts)\r\nwf_put_sensor(pow->volts);\r\nif (pow->amps)\r\nwf_put_sensor(pow->amps);\r\nkfree(pow);\r\n}\r\nstatic int smu_cpu_power_get(struct wf_sensor *sr, s32 *value)\r\n{\r\nstruct smu_cpu_power_sensor *pow = to_smu_cpu_power(sr);\r\ns32 volts, amps, power;\r\nu64 tmps, tmpa, tmpb;\r\nint rc;\r\nrc = pow->amps->ops->get_value(pow->amps, &amps);\r\nif (rc)\r\nreturn rc;\r\nif (pow->fake_volts) {\r\n*value = amps * 12 - 0x30000;\r\nreturn 0;\r\n}\r\nrc = pow->volts->ops->get_value(pow->volts, &volts);\r\nif (rc)\r\nreturn rc;\r\npower = (s32)((((u64)volts) * ((u64)amps)) >> 16);\r\nif (!pow->quadratic) {\r\n*value = power;\r\nreturn 0;\r\n}\r\ntmps = (((u64)power) * ((u64)power)) >> 16;\r\ntmpa = ((u64)cpuvcp->power_quads[0]) * tmps;\r\ntmpb = ((u64)cpuvcp->power_quads[1]) * ((u64)power);\r\n*value = (tmpa >> 28) + (tmpb >> 28) + (cpuvcp->power_quads[2] >> 12);\r\nreturn 0;\r\n}\r\nstatic struct smu_cpu_power_sensor *\r\nsmu_cpu_power_create(struct wf_sensor *volts, struct wf_sensor *amps)\r\n{\r\nstruct smu_cpu_power_sensor *pow;\r\npow = kmalloc(sizeof(struct smu_cpu_power_sensor), GFP_KERNEL);\r\nif (pow == NULL)\r\nreturn NULL;\r\npow->sens.ops = &smu_cpu_power_ops;\r\npow->sens.name = "cpu-power";\r\nwf_get_sensor(volts);\r\npow->volts = volts;\r\nwf_get_sensor(amps);\r\npow->amps = amps;\r\nif (debugswitches && ((*debugswitches) & 0x80)) {\r\nprintk(KERN_INFO "windfarm: CPU Power sensor using faked"\r\n" voltage !\n");\r\npow->fake_volts = 1;\r\n} else\r\npow->fake_volts = 0;\r\nif ((of_machine_is_compatible("PowerMac8,1") ||\r\nof_machine_is_compatible("PowerMac8,2") ||\r\nof_machine_is_compatible("PowerMac9,1")) &&\r\ncpuvcp_version >= 2) {\r\npow->quadratic = 1;\r\nDBG("windfarm: CPU Power using quadratic transform\n");\r\n} else\r\npow->quadratic = 0;\r\nif (wf_register_sensor(&pow->sens))\r\ngoto fail;\r\nreturn pow;\r\nfail:\r\nkfree(pow);\r\nreturn NULL;\r\n}\r\nstatic void smu_fetch_param_partitions(void)\r\n{\r\nconst struct smu_sdbp_header *hdr;\r\nhdr = smu_get_sdb_partition(SMU_SDB_CPUVCP_ID, NULL);\r\nif (hdr != NULL) {\r\ncpuvcp = (struct smu_sdbp_cpuvcp *)&hdr[1];\r\ncpuvcp_version = hdr->version;\r\n}\r\nhdr = smu_get_sdb_partition(SMU_SDB_CPUDIODE_ID, NULL);\r\nif (hdr != NULL)\r\ncpudiode = (struct smu_sdbp_cpudiode *)&hdr[1];\r\nhdr = smu_get_sdb_partition(SMU_SDB_SLOTSPOW_ID, NULL);\r\nif (hdr != NULL)\r\nslotspow = (struct smu_sdbp_slotspow *)&hdr[1];\r\nhdr = smu_get_sdb_partition(SMU_SDB_DEBUG_SWITCHES_ID, NULL);\r\nif (hdr != NULL)\r\ndebugswitches = (u8 *)&hdr[1];\r\n}\r\nstatic int __init smu_sensors_init(void)\r\n{\r\nstruct device_node *smu, *sensors, *s;\r\nstruct smu_ad_sensor *volt_sensor = NULL, *curr_sensor = NULL;\r\nif (!smu_present())\r\nreturn -ENODEV;\r\nsmu_fetch_param_partitions();\r\nsmu = of_find_node_by_type(NULL, "smu");\r\nif (smu == NULL)\r\nreturn -ENODEV;\r\nfor (sensors = NULL;\r\n(sensors = of_get_next_child(smu, sensors)) != NULL;)\r\nif (!strcmp(sensors->name, "sensors"))\r\nbreak;\r\nof_node_put(smu);\r\nfor (s = NULL;\r\nsensors && (s = of_get_next_child(sensors, s)) != NULL;) {\r\nstruct smu_ad_sensor *ads;\r\nads = smu_ads_create(s);\r\nif (ads == NULL)\r\ncontinue;\r\nlist_add(&ads->link, &smu_ads);\r\nif (!strcmp(ads->sens.name, "cpu-voltage"))\r\nvolt_sensor = ads;\r\nelse if (!strcmp(ads->sens.name, "cpu-current"))\r\ncurr_sensor = ads;\r\n}\r\nof_node_put(sensors);\r\nif (volt_sensor && curr_sensor)\r\nsmu_cpu_power = smu_cpu_power_create(&volt_sensor->sens,\r\n&curr_sensor->sens);\r\nreturn 0;\r\n}\r\nstatic void __exit smu_sensors_exit(void)\r\n{\r\nstruct smu_ad_sensor *ads;\r\nif (smu_cpu_power)\r\nwf_unregister_sensor(&smu_cpu_power->sens);\r\nwhile (!list_empty(&smu_ads)) {\r\nads = list_entry(smu_ads.next, struct smu_ad_sensor, link);\r\nlist_del(&ads->link);\r\nwf_unregister_sensor(&ads->sens);\r\n}\r\n}
