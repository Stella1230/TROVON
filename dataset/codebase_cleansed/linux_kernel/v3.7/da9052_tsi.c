static void da9052_ts_adc_toggle(struct da9052_tsi *tsi, bool on)\r\n{\r\nda9052_reg_update(tsi->da9052, DA9052_TSI_CONT_A_REG, 1 << 0, on);\r\ntsi->adc_on = on;\r\n}\r\nstatic irqreturn_t da9052_ts_pendwn_irq(int irq, void *data)\r\n{\r\nstruct da9052_tsi *tsi = data;\r\nif (!tsi->stopped) {\r\ndisable_irq_nosync(tsi->irq_pendwn);\r\nenable_irq(tsi->irq_datardy);\r\nda9052_ts_adc_toggle(tsi, true);\r\nschedule_delayed_work(&tsi->ts_pen_work, HZ / 50);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void da9052_ts_read(struct da9052_tsi *tsi)\r\n{\r\nstruct input_dev *input = tsi->dev;\r\nint ret;\r\nu16 x, y, z;\r\nu8 v;\r\nret = da9052_reg_read(tsi->da9052, DA9052_TSI_X_MSB_REG);\r\nif (ret < 0)\r\nreturn;\r\nx = (u16) ret;\r\nret = da9052_reg_read(tsi->da9052, DA9052_TSI_Y_MSB_REG);\r\nif (ret < 0)\r\nreturn;\r\ny = (u16) ret;\r\nret = da9052_reg_read(tsi->da9052, DA9052_TSI_Z_MSB_REG);\r\nif (ret < 0)\r\nreturn;\r\nz = (u16) ret;\r\nret = da9052_reg_read(tsi->da9052, DA9052_TSI_LSB_REG);\r\nif (ret < 0)\r\nreturn;\r\nv = (u8) ret;\r\nx = ((x << 2) & 0x3fc) | (v & 0x3);\r\ny = ((y << 2) & 0x3fc) | ((v & 0xc) >> 2);\r\nz = ((z << 2) & 0x3fc) | ((v & 0x30) >> 4);\r\ninput_report_key(input, BTN_TOUCH, 1);\r\ninput_report_abs(input, ABS_X, x);\r\ninput_report_abs(input, ABS_Y, y);\r\ninput_report_abs(input, ABS_PRESSURE, z);\r\ninput_sync(input);\r\n}\r\nstatic irqreturn_t da9052_ts_datardy_irq(int irq, void *data)\r\n{\r\nstruct da9052_tsi *tsi = data;\r\nda9052_ts_read(tsi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void da9052_ts_pen_work(struct work_struct *work)\r\n{\r\nstruct da9052_tsi *tsi = container_of(work, struct da9052_tsi,\r\nts_pen_work.work);\r\nif (!tsi->stopped) {\r\nint ret = da9052_reg_read(tsi->da9052, DA9052_TSI_LSB_REG);\r\nif (ret < 0 || (ret & TSI_PEN_DOWN_STATUS)) {\r\nschedule_delayed_work(&tsi->ts_pen_work, HZ / 50);\r\n} else {\r\nstruct input_dev *input = tsi->dev;\r\nda9052_ts_adc_toggle(tsi, false);\r\ninput_report_key(input, BTN_TOUCH, 0);\r\ninput_report_abs(input, ABS_PRESSURE, 0);\r\ninput_sync(input);\r\nret = da9052_reg_update(tsi->da9052,\r\nDA9052_EVENT_B_REG, 0xC0, 0xC0);\r\nif (ret < 0)\r\nreturn;\r\ndisable_irq(tsi->irq_datardy);\r\nenable_irq(tsi->irq_pendwn);\r\n}\r\n}\r\n}\r\nstatic int __devinit da9052_ts_configure_gpio(struct da9052 *da9052)\r\n{\r\nint error;\r\nerror = da9052_reg_update(da9052, DA9052_GPIO_2_3_REG, 0x30, 0);\r\nif (error < 0)\r\nreturn error;\r\nerror = da9052_reg_update(da9052, DA9052_GPIO_4_5_REG, 0x33, 0);\r\nif (error < 0)\r\nreturn error;\r\nerror = da9052_reg_update(da9052, DA9052_GPIO_6_7_REG, 0x33, 0);\r\nif (error < 0)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int __devinit da9052_configure_tsi(struct da9052_tsi *tsi)\r\n{\r\nint error;\r\nerror = da9052_ts_configure_gpio(tsi->da9052);\r\nif (error)\r\nreturn error;\r\nerror = da9052_reg_update(tsi->da9052, DA9052_ADC_CONT_REG,\r\n1 << 6, 1 << 6);\r\nif (error < 0)\r\nreturn error;\r\nerror = da9052_reg_update(tsi->da9052, DA9052_TSI_CONT_A_REG, 0xFC, 0xC0);\r\nif (error < 0)\r\nreturn error;\r\nerror = da9052_reg_write(tsi->da9052, DA9052_LDO9_REG, 0x59);\r\nif (error < 0)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int da9052_ts_input_open(struct input_dev *input_dev)\r\n{\r\nstruct da9052_tsi *tsi = input_get_drvdata(input_dev);\r\ntsi->stopped = false;\r\nmb();\r\nenable_irq(tsi->irq_pendwn);\r\nreturn da9052_reg_update(tsi->da9052, DA9052_TSI_CONT_A_REG,\r\n1 << 1, 1 << 1);\r\n}\r\nstatic void da9052_ts_input_close(struct input_dev *input_dev)\r\n{\r\nstruct da9052_tsi *tsi = input_get_drvdata(input_dev);\r\ntsi->stopped = true;\r\nmb();\r\ndisable_irq(tsi->irq_pendwn);\r\ncancel_delayed_work_sync(&tsi->ts_pen_work);\r\nif (tsi->adc_on) {\r\ndisable_irq(tsi->irq_datardy);\r\nda9052_ts_adc_toggle(tsi, false);\r\nenable_irq(tsi->irq_pendwn);\r\n}\r\nda9052_reg_update(tsi->da9052, DA9052_TSI_CONT_A_REG, 1 << 1, 0);\r\n}\r\nstatic int __devinit da9052_ts_probe(struct platform_device *pdev)\r\n{\r\nstruct da9052 *da9052;\r\nstruct da9052_tsi *tsi;\r\nstruct input_dev *input_dev;\r\nint irq_pendwn;\r\nint irq_datardy;\r\nint error;\r\nda9052 = dev_get_drvdata(pdev->dev.parent);\r\nif (!da9052)\r\nreturn -EINVAL;\r\nirq_pendwn = platform_get_irq_byname(pdev, "PENDWN");\r\nirq_datardy = platform_get_irq_byname(pdev, "TSIRDY");\r\nif (irq_pendwn < 0 || irq_datardy < 0) {\r\ndev_err(da9052->dev, "Unable to determine device interrupts\n");\r\nreturn -ENXIO;\r\n}\r\ntsi = kzalloc(sizeof(struct da9052_tsi), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!tsi || !input_dev) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ntsi->da9052 = da9052;\r\ntsi->dev = input_dev;\r\ntsi->irq_pendwn = da9052->irq_base + irq_pendwn;\r\ntsi->irq_datardy = da9052->irq_base + irq_datardy;\r\ntsi->stopped = true;\r\nINIT_DELAYED_WORK(&tsi->ts_pen_work, da9052_ts_pen_work);\r\ninput_dev->id.version = 0x0101;\r\ninput_dev->id.vendor = 0x15B6;\r\ninput_dev->id.product = 0x9052;\r\ninput_dev->name = "Dialog DA9052 TouchScreen Driver";\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->open = da9052_ts_input_open;\r\ninput_dev->close = da9052_ts_input_close;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_X, 0, 1023, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, 1023, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, 1023, 0, 0);\r\ninput_set_drvdata(input_dev, tsi);\r\nda9052_reg_update(tsi->da9052, DA9052_TSI_CONT_A_REG, 1 << 1, 0);\r\nda9052_ts_adc_toggle(tsi, false);\r\nerror = request_threaded_irq(tsi->irq_pendwn,\r\nNULL, da9052_ts_pendwn_irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"PENDWN", tsi);\r\nif (error) {\r\ndev_err(tsi->da9052->dev,\r\n"Failed to register PENDWN IRQ %d, error = %d\n",\r\ntsi->irq_pendwn, error);\r\ngoto err_free_mem;\r\n}\r\nerror = request_threaded_irq(tsi->irq_datardy,\r\nNULL, da9052_ts_datardy_irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"TSIRDY", tsi);\r\nif (error) {\r\ndev_err(tsi->da9052->dev,\r\n"Failed to register TSIRDY IRQ %d, error = %d\n",\r\ntsi->irq_datardy, error);\r\ngoto err_free_pendwn_irq;\r\n}\r\ndisable_irq(tsi->irq_pendwn);\r\ndisable_irq(tsi->irq_datardy);\r\nerror = da9052_configure_tsi(tsi);\r\nif (error)\r\ngoto err_free_datardy_irq;\r\nerror = input_register_device(tsi->dev);\r\nif (error)\r\ngoto err_free_datardy_irq;\r\nplatform_set_drvdata(pdev, tsi);\r\nreturn 0;\r\nerr_free_datardy_irq:\r\nfree_irq(tsi->irq_datardy, tsi);\r\nerr_free_pendwn_irq:\r\nfree_irq(tsi->irq_pendwn, tsi);\r\nerr_free_mem:\r\nkfree(tsi);\r\ninput_free_device(input_dev);\r\nreturn error;\r\n}\r\nstatic int __devexit da9052_ts_remove(struct platform_device *pdev)\r\n{\r\nstruct da9052_tsi *tsi = platform_get_drvdata(pdev);\r\nda9052_reg_write(tsi->da9052, DA9052_LDO9_REG, 0x19);\r\nfree_irq(tsi->irq_pendwn, tsi);\r\nfree_irq(tsi->irq_datardy, tsi);\r\ninput_unregister_device(tsi->dev);\r\nkfree(tsi);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
