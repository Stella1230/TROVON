static int cx18_i2c_new_ir(struct cx18 *cx, struct i2c_adapter *adap, u32 hw,\r\nconst char *type, u8 addr)\r\n{\r\nstruct i2c_board_info info;\r\nstruct IR_i2c_init_data *init_data = &cx->ir_i2c_init_data;\r\nunsigned short addr_list[2] = { addr, I2C_CLIENT_END };\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, type, I2C_NAME_SIZE);\r\nswitch (hw) {\r\ncase CX18_HW_Z8F0811_IR_RX_HAUP:\r\ninit_data->ir_codes = RC_MAP_HAUPPAUGE;\r\ninit_data->internal_get_key_func = IR_KBD_GET_KEY_HAUP_XVR;\r\ninit_data->type = RC_TYPE_RC5;\r\ninit_data->name = cx->card_name;\r\ninfo.platform_data = init_data;\r\nbreak;\r\n}\r\nreturn i2c_new_probed_device(adap, &info, addr_list, NULL) == NULL ?\r\n-1 : 0;\r\n}\r\nint cx18_i2c_register(struct cx18 *cx, unsigned idx)\r\n{\r\nstruct v4l2_subdev *sd;\r\nint bus = hw_bus[idx];\r\nstruct i2c_adapter *adap = &cx->i2c_adap[bus];\r\nconst char *type = hw_devicenames[idx];\r\nu32 hw = 1 << idx;\r\nif (idx >= ARRAY_SIZE(hw_addrs))\r\nreturn -1;\r\nif (hw == CX18_HW_TUNER) {\r\nsd = v4l2_i2c_new_subdev(&cx->v4l2_dev,\r\nadap, type, 0, cx->card_i2c->radio);\r\nif (sd != NULL)\r\nsd->grp_id = hw;\r\nsd = v4l2_i2c_new_subdev(&cx->v4l2_dev,\r\nadap, type, 0, cx->card_i2c->demod);\r\nif (sd != NULL)\r\nsd->grp_id = hw;\r\nsd = v4l2_i2c_new_subdev(&cx->v4l2_dev,\r\nadap, type, 0, cx->card_i2c->tv);\r\nif (sd != NULL)\r\nsd->grp_id = hw;\r\nreturn sd != NULL ? 0 : -1;\r\n}\r\nif (hw & CX18_HW_IR_ANY)\r\nreturn cx18_i2c_new_ir(cx, adap, hw, type, hw_addrs[idx]);\r\nif (!hw_addrs[idx])\r\nreturn -1;\r\nsd = v4l2_i2c_new_subdev(&cx->v4l2_dev, adap, type, hw_addrs[idx],\r\nNULL);\r\nif (sd != NULL)\r\nsd->grp_id = hw;\r\nreturn sd != NULL ? 0 : -1;\r\n}\r\nstruct v4l2_subdev *cx18_find_hw(struct cx18 *cx, u32 hw)\r\n{\r\nstruct v4l2_subdev *result = NULL;\r\nstruct v4l2_subdev *sd;\r\nspin_lock(&cx->v4l2_dev.lock);\r\nv4l2_device_for_each_subdev(sd, &cx->v4l2_dev) {\r\nif (sd->grp_id == hw) {\r\nresult = sd;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&cx->v4l2_dev.lock);\r\nreturn result;\r\n}\r\nstatic void cx18_setscl(void *data, int state)\r\n{\r\nstruct cx18 *cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;\r\nint bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;\r\nu32 addr = bus_index ? CX18_REG_I2C_2_WR : CX18_REG_I2C_1_WR;\r\nu32 r = cx18_read_reg(cx, addr);\r\nif (state)\r\ncx18_write_reg(cx, r | SETSCL_BIT, addr);\r\nelse\r\ncx18_write_reg(cx, r & ~SETSCL_BIT, addr);\r\n}\r\nstatic void cx18_setsda(void *data, int state)\r\n{\r\nstruct cx18 *cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;\r\nint bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;\r\nu32 addr = bus_index ? CX18_REG_I2C_2_WR : CX18_REG_I2C_1_WR;\r\nu32 r = cx18_read_reg(cx, addr);\r\nif (state)\r\ncx18_write_reg(cx, r | SETSDL_BIT, addr);\r\nelse\r\ncx18_write_reg(cx, r & ~SETSDL_BIT, addr);\r\n}\r\nstatic int cx18_getscl(void *data)\r\n{\r\nstruct cx18 *cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;\r\nint bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;\r\nu32 addr = bus_index ? CX18_REG_I2C_2_RD : CX18_REG_I2C_1_RD;\r\nreturn cx18_read_reg(cx, addr) & GETSCL_BIT;\r\n}\r\nstatic int cx18_getsda(void *data)\r\n{\r\nstruct cx18 *cx = ((struct cx18_i2c_algo_callback_data *)data)->cx;\r\nint bus_index = ((struct cx18_i2c_algo_callback_data *)data)->bus_index;\r\nu32 addr = bus_index ? CX18_REG_I2C_2_RD : CX18_REG_I2C_1_RD;\r\nreturn cx18_read_reg(cx, addr) & GETSDL_BIT;\r\n}\r\nint init_cx18_i2c(struct cx18 *cx)\r\n{\r\nint i, err;\r\nCX18_DEBUG_I2C("i2c init\n");\r\nfor (i = 0; i < 2; i++) {\r\nmemcpy(&cx->i2c_algo[i], &cx18_i2c_algo_template,\r\nsizeof(struct i2c_algo_bit_data));\r\ncx->i2c_algo_cb_data[i].cx = cx;\r\ncx->i2c_algo_cb_data[i].bus_index = i;\r\ncx->i2c_algo[i].data = &cx->i2c_algo_cb_data[i];\r\nmemcpy(&cx->i2c_adap[i], &cx18_i2c_adap_template,\r\nsizeof(struct i2c_adapter));\r\ncx->i2c_adap[i].algo_data = &cx->i2c_algo[i];\r\nsprintf(cx->i2c_adap[i].name + strlen(cx->i2c_adap[i].name),\r\n" #%d-%d", cx->instance, i);\r\ni2c_set_adapdata(&cx->i2c_adap[i], &cx->v4l2_dev);\r\ncx->i2c_adap[i].dev.parent = &cx->pci_dev->dev;\r\n}\r\nif (cx18_read_reg(cx, CX18_REG_I2C_2_WR) != 0x0003c02f) {\r\ncx18_write_reg_expect(cx, 0x10000000, 0xc71004,\r\n0x00000000, 0x10001000);\r\ncx18_write_reg_expect(cx, 0x10001000, 0xc71024,\r\n0x00001000, 0x10001000);\r\n}\r\ncx18_write_reg_expect(cx, 0x00c00000, 0xc7001c, 0x00000000, 0x00c000c0);\r\nmdelay(10);\r\ncx18_write_reg_expect(cx, 0x00c000c0, 0xc7001c, 0x000000c0, 0x00c000c0);\r\nmdelay(10);\r\ncx18_write_reg_expect(cx, 0x00c00000, 0xc7001c, 0x00000000, 0x00c000c0);\r\nmdelay(10);\r\ncx18_write_reg(cx, 0x00c00000, 0xc730c8);\r\ncx18_write_reg_expect(cx, HW2_I2C1_INT|HW2_I2C2_INT, HW2_INT_CLR_STATUS,\r\n~(HW2_I2C1_INT|HW2_I2C2_INT), HW2_I2C1_INT|HW2_I2C2_INT);\r\ncx18_write_reg(cx, 0x00021c0f & ~4, CX18_REG_I2C_1_WR);\r\ncx18_setscl(&cx->i2c_algo_cb_data[0], 1);\r\ncx18_setsda(&cx->i2c_algo_cb_data[0], 1);\r\ncx18_write_reg(cx, 0x00021c0f & ~4, CX18_REG_I2C_2_WR);\r\ncx18_setscl(&cx->i2c_algo_cb_data[1], 1);\r\ncx18_setsda(&cx->i2c_algo_cb_data[1], 1);\r\ncx18_call_hw(cx, CX18_HW_GPIO_RESET_CTRL,\r\ncore, reset, (u32) CX18_GPIO_RESET_I2C);\r\nerr = i2c_bit_add_bus(&cx->i2c_adap[0]);\r\nif (err)\r\ngoto err;\r\nerr = i2c_bit_add_bus(&cx->i2c_adap[1]);\r\nif (err)\r\ngoto err_del_bus_0;\r\nreturn 0;\r\nerr_del_bus_0:\r\ni2c_del_adapter(&cx->i2c_adap[0]);\r\nerr:\r\nreturn err;\r\n}\r\nvoid exit_cx18_i2c(struct cx18 *cx)\r\n{\r\nint i;\r\nCX18_DEBUG_I2C("i2c exit\n");\r\ncx18_write_reg(cx, cx18_read_reg(cx, CX18_REG_I2C_1_WR) | 4,\r\nCX18_REG_I2C_1_WR);\r\ncx18_write_reg(cx, cx18_read_reg(cx, CX18_REG_I2C_2_WR) | 4,\r\nCX18_REG_I2C_2_WR);\r\nfor (i = 0; i < 2; i++) {\r\ni2c_del_adapter(&cx->i2c_adap[i]);\r\n}\r\n}
