static int reply(struct ib_smp *smp)\r\n{\r\nsmp->method = IB_MGMT_METHOD_GET_RESP;\r\nif (smp->mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE)\r\nsmp->status |= IB_SMP_DIRECTION;\r\nreturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY;\r\n}\r\nstatic int recv_subn_get_nodedescription(struct ib_smp *smp,\r\nstruct ib_device *ibdev)\r\n{\r\nif (smp->attr_mod)\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nmemcpy(smp->data, ibdev->node_desc, sizeof(smp->data));\r\nreturn reply(smp);\r\n}\r\nstatic int recv_subn_get_nodeinfo(struct ib_smp *smp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct nodeinfo *nip = (struct nodeinfo *)&smp->data;\r\nstruct ipath_devdata *dd = to_idev(ibdev)->dd;\r\nu32 vendor, majrev, minrev;\r\nif (smp->attr_mod || (dd->ipath_guid == 0))\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nnip->base_version = 1;\r\nnip->class_version = 1;\r\nnip->node_type = 1;\r\nnip->num_ports = ibdev->phys_port_cnt;\r\nnip->sys_guid = to_idev(ibdev)->sys_image_guid;\r\nnip->node_guid = dd->ipath_guid;\r\nnip->port_guid = dd->ipath_guid;\r\nnip->partition_cap = cpu_to_be16(ipath_get_npkeys(dd));\r\nnip->device_id = cpu_to_be16(dd->ipath_deviceid);\r\nmajrev = dd->ipath_majrev;\r\nminrev = dd->ipath_minrev;\r\nnip->revision = cpu_to_be32((majrev << 16) | minrev);\r\nnip->local_port_num = port;\r\nvendor = dd->ipath_vendorid;\r\nnip->vendor_id[0] = IPATH_SRC_OUI_1;\r\nnip->vendor_id[1] = IPATH_SRC_OUI_2;\r\nnip->vendor_id[2] = IPATH_SRC_OUI_3;\r\nreturn reply(smp);\r\n}\r\nstatic int recv_subn_get_guidinfo(struct ib_smp *smp,\r\nstruct ib_device *ibdev)\r\n{\r\nu32 startgx = 8 * be32_to_cpu(smp->attr_mod);\r\n__be64 *p = (__be64 *) smp->data;\r\nmemset(smp->data, 0, sizeof(smp->data));\r\nif (startgx == 0) {\r\n__be64 g = to_idev(ibdev)->dd->ipath_guid;\r\nif (g == 0)\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nelse\r\n*p = g;\r\n} else\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nreturn reply(smp);\r\n}\r\nstatic void set_link_width_enabled(struct ipath_devdata *dd, u32 w)\r\n{\r\n(void) dd->ipath_f_set_ib_cfg(dd, IPATH_IB_CFG_LWID_ENB, w);\r\n}\r\nstatic void set_link_speed_enabled(struct ipath_devdata *dd, u32 s)\r\n{\r\n(void) dd->ipath_f_set_ib_cfg(dd, IPATH_IB_CFG_SPD_ENB, s);\r\n}\r\nstatic int get_overrunthreshold(struct ipath_devdata *dd)\r\n{\r\nreturn (dd->ipath_ibcctrl >>\r\nINFINIPATH_IBCC_OVERRUNTHRESHOLD_SHIFT) &\r\nINFINIPATH_IBCC_OVERRUNTHRESHOLD_MASK;\r\n}\r\nstatic int set_overrunthreshold(struct ipath_devdata *dd, unsigned n)\r\n{\r\nunsigned v;\r\nv = (dd->ipath_ibcctrl >> INFINIPATH_IBCC_OVERRUNTHRESHOLD_SHIFT) &\r\nINFINIPATH_IBCC_OVERRUNTHRESHOLD_MASK;\r\nif (v != n) {\r\ndd->ipath_ibcctrl &=\r\n~(INFINIPATH_IBCC_OVERRUNTHRESHOLD_MASK <<\r\nINFINIPATH_IBCC_OVERRUNTHRESHOLD_SHIFT);\r\ndd->ipath_ibcctrl |=\r\n(u64) n << INFINIPATH_IBCC_OVERRUNTHRESHOLD_SHIFT;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_ibcctrl,\r\ndd->ipath_ibcctrl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_phyerrthreshold(struct ipath_devdata *dd)\r\n{\r\nreturn (dd->ipath_ibcctrl >>\r\nINFINIPATH_IBCC_PHYERRTHRESHOLD_SHIFT) &\r\nINFINIPATH_IBCC_PHYERRTHRESHOLD_MASK;\r\n}\r\nstatic int set_phyerrthreshold(struct ipath_devdata *dd, unsigned n)\r\n{\r\nunsigned v;\r\nv = (dd->ipath_ibcctrl >> INFINIPATH_IBCC_PHYERRTHRESHOLD_SHIFT) &\r\nINFINIPATH_IBCC_PHYERRTHRESHOLD_MASK;\r\nif (v != n) {\r\ndd->ipath_ibcctrl &=\r\n~(INFINIPATH_IBCC_PHYERRTHRESHOLD_MASK <<\r\nINFINIPATH_IBCC_PHYERRTHRESHOLD_SHIFT);\r\ndd->ipath_ibcctrl |=\r\n(u64) n << INFINIPATH_IBCC_PHYERRTHRESHOLD_SHIFT;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_ibcctrl,\r\ndd->ipath_ibcctrl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_linkdowndefaultstate(struct ipath_devdata *dd)\r\n{\r\nreturn !!(dd->ipath_ibcctrl & INFINIPATH_IBCC_LINKDOWNDEFAULTSTATE);\r\n}\r\nstatic int recv_subn_get_portinfo(struct ib_smp *smp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ipath_ibdev *dev;\r\nstruct ipath_devdata *dd;\r\nstruct ib_port_info *pip = (struct ib_port_info *)smp->data;\r\nu16 lid;\r\nu8 ibcstat;\r\nu8 mtu;\r\nint ret;\r\nif (be32_to_cpu(smp->attr_mod) > ibdev->phys_port_cnt) {\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nret = reply(smp);\r\ngoto bail;\r\n}\r\ndev = to_idev(ibdev);\r\ndd = dev->dd;\r\nmemset(smp->data, 0, sizeof(smp->data));\r\nif (smp->method == IB_MGMT_METHOD_SET || dev->mkey == smp->mkey ||\r\ndev->mkeyprot == 0)\r\npip->mkey = dev->mkey;\r\npip->gid_prefix = dev->gid_prefix;\r\nlid = dd->ipath_lid;\r\npip->lid = lid ? cpu_to_be16(lid) : IB_LID_PERMISSIVE;\r\npip->sm_lid = cpu_to_be16(dev->sm_lid);\r\npip->cap_mask = cpu_to_be32(dev->port_cap_flags);\r\npip->mkey_lease_period = cpu_to_be16(dev->mkey_lease_period);\r\npip->local_port_num = port;\r\npip->link_width_enabled = dd->ipath_link_width_enabled;\r\npip->link_width_supported = dd->ipath_link_width_supported;\r\npip->link_width_active = dd->ipath_link_width_active;\r\npip->linkspeed_portstate = dd->ipath_link_speed_supported << 4;\r\nibcstat = dd->ipath_lastibcstat;\r\npip->linkspeed_portstate |= ipath_ib_linkstate(dd, ibcstat) + 1;\r\npip->portphysstate_linkdown =\r\n(ipath_cvt_physportstate[ibcstat & dd->ibcs_lts_mask] << 4) |\r\n(get_linkdowndefaultstate(dd) ? 1 : 2);\r\npip->mkeyprot_resv_lmc = (dev->mkeyprot << 6) | dd->ipath_lmc;\r\npip->linkspeedactive_enabled = (dd->ipath_link_speed_active << 4) |\r\ndd->ipath_link_speed_enabled;\r\nswitch (dd->ipath_ibmtu) {\r\ncase 4096:\r\nmtu = IB_MTU_4096;\r\nbreak;\r\ncase 2048:\r\nmtu = IB_MTU_2048;\r\nbreak;\r\ncase 1024:\r\nmtu = IB_MTU_1024;\r\nbreak;\r\ncase 512:\r\nmtu = IB_MTU_512;\r\nbreak;\r\ncase 256:\r\nmtu = IB_MTU_256;\r\nbreak;\r\ndefault:\r\nmtu = IB_MTU_2048;\r\nbreak;\r\n}\r\npip->neighbormtu_mastersmsl = (mtu << 4) | dev->sm_sl;\r\npip->vlcap_inittype = 0x10;\r\npip->vl_high_limit = dev->vl_high_limit;\r\npip->inittypereply_mtucap = ipath_mtu4096 ? IB_MTU_4096 : IB_MTU_2048;\r\npip->operationalvl_pei_peo_fpi_fpo = 0x10;\r\npip->mkey_violations = cpu_to_be16(dev->mkey_violations);\r\npip->pkey_violations =\r\ncpu_to_be16((ipath_get_cr_errpkey(dd) -\r\ndev->z_pkey_violations) & 0xFFFF);\r\npip->qkey_violations = cpu_to_be16(dev->qkey_violations);\r\npip->guid_cap = 1;\r\npip->clientrereg_resv_subnetto = dev->subnet_timeout;\r\npip->resv_resptimevalue = 3;\r\npip->localphyerrors_overrunerrors =\r\n(get_phyerrthreshold(dd) << 4) |\r\nget_overrunthreshold(dd);\r\nif (dev->port_cap_flags & IB_PORT_LINK_LATENCY_SUP) {\r\nu32 v;\r\nv = dd->ipath_f_get_ib_cfg(dd, IPATH_IB_CFG_LINKLATENCY);\r\npip->link_roundtrip_latency[0] = v >> 16;\r\npip->link_roundtrip_latency[1] = v >> 8;\r\npip->link_roundtrip_latency[2] = v;\r\n}\r\nret = reply(smp);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int get_pkeys(struct ipath_devdata *dd, u16 * pkeys)\r\n{\r\nstruct ipath_portdata *pd = dd->ipath_pd[0];\r\nmemcpy(pkeys, pd->port_pkeys, sizeof(pd->port_pkeys));\r\nreturn 0;\r\n}\r\nstatic int recv_subn_get_pkeytable(struct ib_smp *smp,\r\nstruct ib_device *ibdev)\r\n{\r\nu32 startpx = 32 * (be32_to_cpu(smp->attr_mod) & 0xffff);\r\nu16 *p = (u16 *) smp->data;\r\n__be16 *q = (__be16 *) smp->data;\r\nmemset(smp->data, 0, sizeof(smp->data));\r\nif (startpx == 0) {\r\nstruct ipath_ibdev *dev = to_idev(ibdev);\r\nunsigned i, n = ipath_get_npkeys(dev->dd);\r\nget_pkeys(dev->dd, p);\r\nfor (i = 0; i < n; i++)\r\nq[i] = cpu_to_be16(p[i]);\r\n} else\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nreturn reply(smp);\r\n}\r\nstatic int recv_subn_set_guidinfo(struct ib_smp *smp,\r\nstruct ib_device *ibdev)\r\n{\r\nreturn recv_subn_get_guidinfo(smp, ibdev);\r\n}\r\nstatic int set_linkdowndefaultstate(struct ipath_devdata *dd, int sleep)\r\n{\r\nif (sleep)\r\ndd->ipath_ibcctrl |= INFINIPATH_IBCC_LINKDOWNDEFAULTSTATE;\r\nelse\r\ndd->ipath_ibcctrl &= ~INFINIPATH_IBCC_LINKDOWNDEFAULTSTATE;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_ibcctrl,\r\ndd->ipath_ibcctrl);\r\nreturn 0;\r\n}\r\nstatic int recv_subn_set_portinfo(struct ib_smp *smp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_port_info *pip = (struct ib_port_info *)smp->data;\r\nstruct ib_event event;\r\nstruct ipath_ibdev *dev;\r\nstruct ipath_devdata *dd;\r\nchar clientrereg = 0;\r\nu16 lid, smlid;\r\nu8 lwe;\r\nu8 lse;\r\nu8 state;\r\nu16 lstate;\r\nu32 mtu;\r\nint ret, ore;\r\nif (be32_to_cpu(smp->attr_mod) > ibdev->phys_port_cnt)\r\ngoto err;\r\ndev = to_idev(ibdev);\r\ndd = dev->dd;\r\nevent.device = ibdev;\r\nevent.element.port_num = port;\r\ndev->mkey = pip->mkey;\r\ndev->gid_prefix = pip->gid_prefix;\r\ndev->mkey_lease_period = be16_to_cpu(pip->mkey_lease_period);\r\nlid = be16_to_cpu(pip->lid);\r\nif (dd->ipath_lid != lid ||\r\ndd->ipath_lmc != (pip->mkeyprot_resv_lmc & 7)) {\r\nif (lid == 0 || lid >= IPATH_MULTICAST_LID_BASE)\r\ngoto err;\r\nipath_set_lid(dd, lid, pip->mkeyprot_resv_lmc & 7);\r\nevent.event = IB_EVENT_LID_CHANGE;\r\nib_dispatch_event(&event);\r\n}\r\nsmlid = be16_to_cpu(pip->sm_lid);\r\nif (smlid != dev->sm_lid) {\r\nif (smlid == 0 || smlid >= IPATH_MULTICAST_LID_BASE)\r\ngoto err;\r\ndev->sm_lid = smlid;\r\nevent.event = IB_EVENT_SM_CHANGE;\r\nib_dispatch_event(&event);\r\n}\r\nlwe = pip->link_width_enabled;\r\nif (lwe) {\r\nif (lwe == 0xFF)\r\nlwe = dd->ipath_link_width_supported;\r\nelse if (lwe >= 16 || (lwe & ~dd->ipath_link_width_supported))\r\ngoto err;\r\nset_link_width_enabled(dd, lwe);\r\n}\r\nlse = pip->linkspeedactive_enabled & 0xF;\r\nif (lse) {\r\nif (lse == 15)\r\nlse = dd->ipath_link_speed_supported;\r\nelse if (lse >= 8 || (lse & ~dd->ipath_link_speed_supported))\r\ngoto err;\r\nset_link_speed_enabled(dd, lse);\r\n}\r\nswitch (pip->portphysstate_linkdown & 0xF) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nif (set_linkdowndefaultstate(dd, 1))\r\ngoto err;\r\nbreak;\r\ncase 2:\r\nif (set_linkdowndefaultstate(dd, 0))\r\ngoto err;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\ndev->mkeyprot = pip->mkeyprot_resv_lmc >> 6;\r\ndev->vl_high_limit = pip->vl_high_limit;\r\nswitch ((pip->neighbormtu_mastersmsl >> 4) & 0xF) {\r\ncase IB_MTU_256:\r\nmtu = 256;\r\nbreak;\r\ncase IB_MTU_512:\r\nmtu = 512;\r\nbreak;\r\ncase IB_MTU_1024:\r\nmtu = 1024;\r\nbreak;\r\ncase IB_MTU_2048:\r\nmtu = 2048;\r\nbreak;\r\ncase IB_MTU_4096:\r\nif (!ipath_mtu4096)\r\ngoto err;\r\nmtu = 4096;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nipath_set_mtu(dd, mtu);\r\ndev->sm_sl = pip->neighbormtu_mastersmsl & 0xF;\r\nif (((pip->operationalvl_pei_peo_fpi_fpo >> 4) & 0xF) > 1)\r\ngoto err;\r\nif (pip->mkey_violations == 0)\r\ndev->mkey_violations = 0;\r\nif (pip->pkey_violations == 0)\r\ndev->z_pkey_violations = ipath_get_cr_errpkey(dd);\r\nif (pip->qkey_violations == 0)\r\ndev->qkey_violations = 0;\r\nore = pip->localphyerrors_overrunerrors;\r\nif (set_phyerrthreshold(dd, (ore >> 4) & 0xF))\r\ngoto err;\r\nif (set_overrunthreshold(dd, (ore & 0xF)))\r\ngoto err;\r\ndev->subnet_timeout = pip->clientrereg_resv_subnetto & 0x1F;\r\nif (pip->clientrereg_resv_subnetto & 0x80) {\r\nclientrereg = 1;\r\nevent.event = IB_EVENT_CLIENT_REREGISTER;\r\nib_dispatch_event(&event);\r\n}\r\nstate = pip->linkspeed_portstate & 0xF;\r\nlstate = (pip->portphysstate_linkdown >> 4) & 0xF;\r\nif (lstate && !(state == IB_PORT_DOWN || state == IB_PORT_NOP))\r\ngoto err;\r\nswitch (state) {\r\ncase IB_PORT_NOP:\r\nif (lstate == 0)\r\nbreak;\r\ncase IB_PORT_DOWN:\r\nif (lstate == 0)\r\nlstate = IPATH_IB_LINKDOWN_ONLY;\r\nelse if (lstate == 1)\r\nlstate = IPATH_IB_LINKDOWN_SLEEP;\r\nelse if (lstate == 2)\r\nlstate = IPATH_IB_LINKDOWN;\r\nelse if (lstate == 3)\r\nlstate = IPATH_IB_LINKDOWN_DISABLE;\r\nelse\r\ngoto err;\r\nipath_set_linkstate(dd, lstate);\r\nif (lstate == IPATH_IB_LINKDOWN_DISABLE) {\r\nret = IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\r\ngoto done;\r\n}\r\nipath_wait_linkstate(dd, IPATH_LINKINIT | IPATH_LINKARMED |\r\nIPATH_LINKACTIVE, 1000);\r\nbreak;\r\ncase IB_PORT_ARMED:\r\nipath_set_linkstate(dd, IPATH_IB_LINKARM);\r\nbreak;\r\ncase IB_PORT_ACTIVE:\r\nipath_set_linkstate(dd, IPATH_IB_LINKACTIVE);\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nret = recv_subn_get_portinfo(smp, ibdev, port);\r\nif (clientrereg)\r\npip->clientrereg_resv_subnetto |= 0x80;\r\ngoto done;\r\nerr:\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nret = recv_subn_get_portinfo(smp, ibdev, port);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int rm_pkey(struct ipath_devdata *dd, u16 key)\r\n{\r\nint i;\r\nint ret;\r\nfor (i = 0; i < ARRAY_SIZE(dd->ipath_pkeys); i++) {\r\nif (dd->ipath_pkeys[i] != key)\r\ncontinue;\r\nif (atomic_dec_and_test(&dd->ipath_pkeyrefs[i])) {\r\ndd->ipath_pkeys[i] = 0;\r\nret = 1;\r\ngoto bail;\r\n}\r\nbreak;\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int add_pkey(struct ipath_devdata *dd, u16 key)\r\n{\r\nint i;\r\nu16 lkey = key & 0x7FFF;\r\nint any = 0;\r\nint ret;\r\nif (lkey == 0x7FFF) {\r\nret = 0;\r\ngoto bail;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(dd->ipath_pkeys); i++) {\r\nif (!dd->ipath_pkeys[i]) {\r\nany++;\r\ncontinue;\r\n}\r\nif (dd->ipath_pkeys[i] == key) {\r\nif (atomic_inc_return(&dd->ipath_pkeyrefs[i]) > 1) {\r\nret = 0;\r\ngoto bail;\r\n}\r\natomic_dec(&dd->ipath_pkeyrefs[i]);\r\nany++;\r\n}\r\nif ((dd->ipath_pkeys[i] & 0x7FFF) == lkey) {\r\nret = -EEXIST;\r\ngoto bail;\r\n}\r\n}\r\nif (!any) {\r\nret = -EBUSY;\r\ngoto bail;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(dd->ipath_pkeys); i++) {\r\nif (!dd->ipath_pkeys[i] &&\r\natomic_inc_return(&dd->ipath_pkeyrefs[i]) == 1) {\r\nipath_stats.sps_pkeys[i] = lkey;\r\ndd->ipath_pkeys[i] = key;\r\nret = 1;\r\ngoto bail;\r\n}\r\n}\r\nret = -EBUSY;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int set_pkeys(struct ipath_devdata *dd, u16 *pkeys)\r\n{\r\nstruct ipath_portdata *pd;\r\nint i;\r\nint changed = 0;\r\npd = dd->ipath_pd[0];\r\nfor (i = 0; i < ARRAY_SIZE(pd->port_pkeys); i++) {\r\nu16 key = pkeys[i];\r\nu16 okey = pd->port_pkeys[i];\r\nif (key == okey)\r\ncontinue;\r\nif (okey & 0x7FFF)\r\nchanged |= rm_pkey(dd, okey);\r\nif (key & 0x7FFF) {\r\nint ret = add_pkey(dd, key);\r\nif (ret < 0)\r\nkey = 0;\r\nelse\r\nchanged |= ret;\r\n}\r\npd->port_pkeys[i] = key;\r\n}\r\nif (changed) {\r\nu64 pkey;\r\npkey = (u64) dd->ipath_pkeys[0] |\r\n((u64) dd->ipath_pkeys[1] << 16) |\r\n((u64) dd->ipath_pkeys[2] << 32) |\r\n((u64) dd->ipath_pkeys[3] << 48);\r\nipath_cdbg(VERBOSE, "p0 new pkey reg %llx\n",\r\n(unsigned long long) pkey);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_partitionkey,\r\npkey);\r\n}\r\nreturn 0;\r\n}\r\nstatic int recv_subn_set_pkeytable(struct ib_smp *smp,\r\nstruct ib_device *ibdev)\r\n{\r\nu32 startpx = 32 * (be32_to_cpu(smp->attr_mod) & 0xffff);\r\n__be16 *p = (__be16 *) smp->data;\r\nu16 *q = (u16 *) smp->data;\r\nstruct ipath_ibdev *dev = to_idev(ibdev);\r\nunsigned i, n = ipath_get_npkeys(dev->dd);\r\nfor (i = 0; i < n; i++)\r\nq[i] = be16_to_cpu(p[i]);\r\nif (startpx != 0 || set_pkeys(dev->dd, q) != 0)\r\nsmp->status |= IB_SMP_INVALID_FIELD;\r\nreturn recv_subn_get_pkeytable(smp, ibdev);\r\n}\r\nstatic int recv_pma_get_classportinfo(struct ib_pma_mad *pmp)\r\n{\r\nstruct ib_class_port_info *p =\r\n(struct ib_class_port_info *)pmp->data;\r\nmemset(pmp->data, 0, sizeof(pmp->data));\r\nif (pmp->mad_hdr.attr_mod != 0)\r\npmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\r\np->capability_mask = cpu_to_be16(1 << 8);\r\np->base_version = 1;\r\np->class_version = 1;\r\np->resp_time_value = 18;\r\nreturn reply((struct ib_smp *) pmp);\r\n}\r\nstatic int recv_pma_get_portsamplescontrol(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portsamplescontrol *p =\r\n(struct ib_pma_portsamplescontrol *)pmp->data;\r\nstruct ipath_ibdev *dev = to_idev(ibdev);\r\nstruct ipath_cregs const *crp = dev->dd->ipath_cregs;\r\nunsigned long flags;\r\nu8 port_select = p->port_select;\r\nmemset(pmp->data, 0, sizeof(pmp->data));\r\np->port_select = port_select;\r\nif (pmp->mad_hdr.attr_mod != 0 ||\r\n(port_select != port && port_select != 0xFF))\r\npmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\r\nif (crp->cr_psstat)\r\np->tick = dev->dd->ipath_link_speed_active - 1;\r\nelse\r\np->tick = 250;\r\np->counter_width = 4;\r\np->counter_mask0_9 = COUNTER_MASK0_9;\r\nspin_lock_irqsave(&dev->pending_lock, flags);\r\nif (crp->cr_psstat)\r\np->sample_status = ipath_read_creg32(dev->dd, crp->cr_psstat);\r\nelse\r\np->sample_status = dev->pma_sample_status;\r\np->sample_start = cpu_to_be32(dev->pma_sample_start);\r\np->sample_interval = cpu_to_be32(dev->pma_sample_interval);\r\np->tag = cpu_to_be16(dev->pma_tag);\r\np->counter_select[0] = dev->pma_counter_select[0];\r\np->counter_select[1] = dev->pma_counter_select[1];\r\np->counter_select[2] = dev->pma_counter_select[2];\r\np->counter_select[3] = dev->pma_counter_select[3];\r\np->counter_select[4] = dev->pma_counter_select[4];\r\nspin_unlock_irqrestore(&dev->pending_lock, flags);\r\nreturn reply((struct ib_smp *) pmp);\r\n}\r\nstatic int recv_pma_set_portsamplescontrol(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portsamplescontrol *p =\r\n(struct ib_pma_portsamplescontrol *)pmp->data;\r\nstruct ipath_ibdev *dev = to_idev(ibdev);\r\nstruct ipath_cregs const *crp = dev->dd->ipath_cregs;\r\nunsigned long flags;\r\nu8 status;\r\nint ret;\r\nif (pmp->mad_hdr.attr_mod != 0 ||\r\n(p->port_select != port && p->port_select != 0xFF)) {\r\npmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\r\nret = reply((struct ib_smp *) pmp);\r\ngoto bail;\r\n}\r\nspin_lock_irqsave(&dev->pending_lock, flags);\r\nif (crp->cr_psstat)\r\nstatus = ipath_read_creg32(dev->dd, crp->cr_psstat);\r\nelse\r\nstatus = dev->pma_sample_status;\r\nif (status == IB_PMA_SAMPLE_STATUS_DONE) {\r\ndev->pma_sample_start = be32_to_cpu(p->sample_start);\r\ndev->pma_sample_interval = be32_to_cpu(p->sample_interval);\r\ndev->pma_tag = be16_to_cpu(p->tag);\r\ndev->pma_counter_select[0] = p->counter_select[0];\r\ndev->pma_counter_select[1] = p->counter_select[1];\r\ndev->pma_counter_select[2] = p->counter_select[2];\r\ndev->pma_counter_select[3] = p->counter_select[3];\r\ndev->pma_counter_select[4] = p->counter_select[4];\r\nif (crp->cr_psstat) {\r\nipath_write_creg(dev->dd, crp->cr_psinterval,\r\ndev->pma_sample_interval);\r\nipath_write_creg(dev->dd, crp->cr_psstart,\r\ndev->pma_sample_start);\r\n} else\r\ndev->pma_sample_status = IB_PMA_SAMPLE_STATUS_STARTED;\r\n}\r\nspin_unlock_irqrestore(&dev->pending_lock, flags);\r\nret = recv_pma_get_portsamplescontrol(pmp, ibdev, port);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic u64 get_counter(struct ipath_ibdev *dev,\r\nstruct ipath_cregs const *crp,\r\n__be16 sel)\r\n{\r\nu64 ret;\r\nswitch (sel) {\r\ncase IB_PMA_PORT_XMIT_DATA:\r\nret = (crp->cr_psxmitdatacount) ?\r\nipath_read_creg32(dev->dd, crp->cr_psxmitdatacount) :\r\ndev->ipath_sword;\r\nbreak;\r\ncase IB_PMA_PORT_RCV_DATA:\r\nret = (crp->cr_psrcvdatacount) ?\r\nipath_read_creg32(dev->dd, crp->cr_psrcvdatacount) :\r\ndev->ipath_rword;\r\nbreak;\r\ncase IB_PMA_PORT_XMIT_PKTS:\r\nret = (crp->cr_psxmitpktscount) ?\r\nipath_read_creg32(dev->dd, crp->cr_psxmitpktscount) :\r\ndev->ipath_spkts;\r\nbreak;\r\ncase IB_PMA_PORT_RCV_PKTS:\r\nret = (crp->cr_psrcvpktscount) ?\r\nipath_read_creg32(dev->dd, crp->cr_psrcvpktscount) :\r\ndev->ipath_rpkts;\r\nbreak;\r\ncase IB_PMA_PORT_XMIT_WAIT:\r\nret = (crp->cr_psxmitwaitcount) ?\r\nipath_read_creg32(dev->dd, crp->cr_psxmitwaitcount) :\r\ndev->ipath_xmit_wait;\r\nbreak;\r\ndefault:\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int recv_pma_get_portsamplesresult(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev)\r\n{\r\nstruct ib_pma_portsamplesresult *p =\r\n(struct ib_pma_portsamplesresult *)pmp->data;\r\nstruct ipath_ibdev *dev = to_idev(ibdev);\r\nstruct ipath_cregs const *crp = dev->dd->ipath_cregs;\r\nu8 status;\r\nint i;\r\nmemset(pmp->data, 0, sizeof(pmp->data));\r\np->tag = cpu_to_be16(dev->pma_tag);\r\nif (crp->cr_psstat)\r\nstatus = ipath_read_creg32(dev->dd, crp->cr_psstat);\r\nelse\r\nstatus = dev->pma_sample_status;\r\np->sample_status = cpu_to_be16(status);\r\nfor (i = 0; i < ARRAY_SIZE(dev->pma_counter_select); i++)\r\np->counter[i] = (status != IB_PMA_SAMPLE_STATUS_DONE) ? 0 :\r\ncpu_to_be32(\r\nget_counter(dev, crp, dev->pma_counter_select[i]));\r\nreturn reply((struct ib_smp *) pmp);\r\n}\r\nstatic int recv_pma_get_portsamplesresult_ext(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev)\r\n{\r\nstruct ib_pma_portsamplesresult_ext *p =\r\n(struct ib_pma_portsamplesresult_ext *)pmp->data;\r\nstruct ipath_ibdev *dev = to_idev(ibdev);\r\nstruct ipath_cregs const *crp = dev->dd->ipath_cregs;\r\nu8 status;\r\nint i;\r\nmemset(pmp->data, 0, sizeof(pmp->data));\r\np->tag = cpu_to_be16(dev->pma_tag);\r\nif (crp->cr_psstat)\r\nstatus = ipath_read_creg32(dev->dd, crp->cr_psstat);\r\nelse\r\nstatus = dev->pma_sample_status;\r\np->sample_status = cpu_to_be16(status);\r\np->extended_width = cpu_to_be32(0x80000000);\r\nfor (i = 0; i < ARRAY_SIZE(dev->pma_counter_select); i++)\r\np->counter[i] = (status != IB_PMA_SAMPLE_STATUS_DONE) ? 0 :\r\ncpu_to_be64(\r\nget_counter(dev, crp, dev->pma_counter_select[i]));\r\nreturn reply((struct ib_smp *) pmp);\r\n}\r\nstatic int recv_pma_get_portcounters(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portcounters *p = (struct ib_pma_portcounters *)\r\npmp->data;\r\nstruct ipath_ibdev *dev = to_idev(ibdev);\r\nstruct ipath_verbs_counters cntrs;\r\nu8 port_select = p->port_select;\r\nipath_get_counters(dev->dd, &cntrs);\r\ncntrs.symbol_error_counter -= dev->z_symbol_error_counter;\r\ncntrs.link_error_recovery_counter -=\r\ndev->z_link_error_recovery_counter;\r\ncntrs.link_downed_counter -= dev->z_link_downed_counter;\r\ncntrs.port_rcv_errors += dev->rcv_errors;\r\ncntrs.port_rcv_errors -= dev->z_port_rcv_errors;\r\ncntrs.port_rcv_remphys_errors -= dev->z_port_rcv_remphys_errors;\r\ncntrs.port_xmit_discards -= dev->z_port_xmit_discards;\r\ncntrs.port_xmit_data -= dev->z_port_xmit_data;\r\ncntrs.port_rcv_data -= dev->z_port_rcv_data;\r\ncntrs.port_xmit_packets -= dev->z_port_xmit_packets;\r\ncntrs.port_rcv_packets -= dev->z_port_rcv_packets;\r\ncntrs.local_link_integrity_errors -=\r\ndev->z_local_link_integrity_errors;\r\ncntrs.excessive_buffer_overrun_errors -=\r\ndev->z_excessive_buffer_overrun_errors;\r\ncntrs.vl15_dropped -= dev->z_vl15_dropped;\r\ncntrs.vl15_dropped += dev->n_vl15_dropped;\r\nmemset(pmp->data, 0, sizeof(pmp->data));\r\np->port_select = port_select;\r\nif (pmp->mad_hdr.attr_mod != 0 ||\r\n(port_select != port && port_select != 0xFF))\r\npmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\r\nif (cntrs.symbol_error_counter > 0xFFFFUL)\r\np->symbol_error_counter = cpu_to_be16(0xFFFF);\r\nelse\r\np->symbol_error_counter =\r\ncpu_to_be16((u16)cntrs.symbol_error_counter);\r\nif (cntrs.link_error_recovery_counter > 0xFFUL)\r\np->link_error_recovery_counter = 0xFF;\r\nelse\r\np->link_error_recovery_counter =\r\n(u8)cntrs.link_error_recovery_counter;\r\nif (cntrs.link_downed_counter > 0xFFUL)\r\np->link_downed_counter = 0xFF;\r\nelse\r\np->link_downed_counter = (u8)cntrs.link_downed_counter;\r\nif (cntrs.port_rcv_errors > 0xFFFFUL)\r\np->port_rcv_errors = cpu_to_be16(0xFFFF);\r\nelse\r\np->port_rcv_errors =\r\ncpu_to_be16((u16) cntrs.port_rcv_errors);\r\nif (cntrs.port_rcv_remphys_errors > 0xFFFFUL)\r\np->port_rcv_remphys_errors = cpu_to_be16(0xFFFF);\r\nelse\r\np->port_rcv_remphys_errors =\r\ncpu_to_be16((u16)cntrs.port_rcv_remphys_errors);\r\nif (cntrs.port_xmit_discards > 0xFFFFUL)\r\np->port_xmit_discards = cpu_to_be16(0xFFFF);\r\nelse\r\np->port_xmit_discards =\r\ncpu_to_be16((u16)cntrs.port_xmit_discards);\r\nif (cntrs.local_link_integrity_errors > 0xFUL)\r\ncntrs.local_link_integrity_errors = 0xFUL;\r\nif (cntrs.excessive_buffer_overrun_errors > 0xFUL)\r\ncntrs.excessive_buffer_overrun_errors = 0xFUL;\r\np->link_overrun_errors = (cntrs.local_link_integrity_errors << 4) |\r\ncntrs.excessive_buffer_overrun_errors;\r\nif (cntrs.vl15_dropped > 0xFFFFUL)\r\np->vl15_dropped = cpu_to_be16(0xFFFF);\r\nelse\r\np->vl15_dropped = cpu_to_be16((u16)cntrs.vl15_dropped);\r\nif (cntrs.port_xmit_data > 0xFFFFFFFFUL)\r\np->port_xmit_data = cpu_to_be32(0xFFFFFFFF);\r\nelse\r\np->port_xmit_data = cpu_to_be32((u32)cntrs.port_xmit_data);\r\nif (cntrs.port_rcv_data > 0xFFFFFFFFUL)\r\np->port_rcv_data = cpu_to_be32(0xFFFFFFFF);\r\nelse\r\np->port_rcv_data = cpu_to_be32((u32)cntrs.port_rcv_data);\r\nif (cntrs.port_xmit_packets > 0xFFFFFFFFUL)\r\np->port_xmit_packets = cpu_to_be32(0xFFFFFFFF);\r\nelse\r\np->port_xmit_packets =\r\ncpu_to_be32((u32)cntrs.port_xmit_packets);\r\nif (cntrs.port_rcv_packets > 0xFFFFFFFFUL)\r\np->port_rcv_packets = cpu_to_be32(0xFFFFFFFF);\r\nelse\r\np->port_rcv_packets =\r\ncpu_to_be32((u32) cntrs.port_rcv_packets);\r\nreturn reply((struct ib_smp *) pmp);\r\n}\r\nstatic int recv_pma_get_portcounters_ext(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portcounters_ext *p =\r\n(struct ib_pma_portcounters_ext *)pmp->data;\r\nstruct ipath_ibdev *dev = to_idev(ibdev);\r\nu64 swords, rwords, spkts, rpkts, xwait;\r\nu8 port_select = p->port_select;\r\nipath_snapshot_counters(dev->dd, &swords, &rwords, &spkts,\r\n&rpkts, &xwait);\r\nswords -= dev->z_port_xmit_data;\r\nrwords -= dev->z_port_rcv_data;\r\nspkts -= dev->z_port_xmit_packets;\r\nrpkts -= dev->z_port_rcv_packets;\r\nmemset(pmp->data, 0, sizeof(pmp->data));\r\np->port_select = port_select;\r\nif (pmp->mad_hdr.attr_mod != 0 ||\r\n(port_select != port && port_select != 0xFF))\r\npmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\r\np->port_xmit_data = cpu_to_be64(swords);\r\np->port_rcv_data = cpu_to_be64(rwords);\r\np->port_xmit_packets = cpu_to_be64(spkts);\r\np->port_rcv_packets = cpu_to_be64(rpkts);\r\np->port_unicast_xmit_packets = cpu_to_be64(dev->n_unicast_xmit);\r\np->port_unicast_rcv_packets = cpu_to_be64(dev->n_unicast_rcv);\r\np->port_multicast_xmit_packets = cpu_to_be64(dev->n_multicast_xmit);\r\np->port_multicast_rcv_packets = cpu_to_be64(dev->n_multicast_rcv);\r\nreturn reply((struct ib_smp *) pmp);\r\n}\r\nstatic int recv_pma_set_portcounters(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portcounters *p = (struct ib_pma_portcounters *)\r\npmp->data;\r\nstruct ipath_ibdev *dev = to_idev(ibdev);\r\nstruct ipath_verbs_counters cntrs;\r\nipath_get_counters(dev->dd, &cntrs);\r\nif (p->counter_select & IB_PMA_SEL_SYMBOL_ERROR)\r\ndev->z_symbol_error_counter = cntrs.symbol_error_counter;\r\nif (p->counter_select & IB_PMA_SEL_LINK_ERROR_RECOVERY)\r\ndev->z_link_error_recovery_counter =\r\ncntrs.link_error_recovery_counter;\r\nif (p->counter_select & IB_PMA_SEL_LINK_DOWNED)\r\ndev->z_link_downed_counter = cntrs.link_downed_counter;\r\nif (p->counter_select & IB_PMA_SEL_PORT_RCV_ERRORS)\r\ndev->z_port_rcv_errors =\r\ncntrs.port_rcv_errors + dev->rcv_errors;\r\nif (p->counter_select & IB_PMA_SEL_PORT_RCV_REMPHYS_ERRORS)\r\ndev->z_port_rcv_remphys_errors =\r\ncntrs.port_rcv_remphys_errors;\r\nif (p->counter_select & IB_PMA_SEL_PORT_XMIT_DISCARDS)\r\ndev->z_port_xmit_discards = cntrs.port_xmit_discards;\r\nif (p->counter_select & IB_PMA_SEL_LOCAL_LINK_INTEGRITY_ERRORS)\r\ndev->z_local_link_integrity_errors =\r\ncntrs.local_link_integrity_errors;\r\nif (p->counter_select & IB_PMA_SEL_EXCESSIVE_BUFFER_OVERRUNS)\r\ndev->z_excessive_buffer_overrun_errors =\r\ncntrs.excessive_buffer_overrun_errors;\r\nif (p->counter_select & IB_PMA_SEL_PORT_VL15_DROPPED) {\r\ndev->n_vl15_dropped = 0;\r\ndev->z_vl15_dropped = cntrs.vl15_dropped;\r\n}\r\nif (p->counter_select & IB_PMA_SEL_PORT_XMIT_DATA)\r\ndev->z_port_xmit_data = cntrs.port_xmit_data;\r\nif (p->counter_select & IB_PMA_SEL_PORT_RCV_DATA)\r\ndev->z_port_rcv_data = cntrs.port_rcv_data;\r\nif (p->counter_select & IB_PMA_SEL_PORT_XMIT_PACKETS)\r\ndev->z_port_xmit_packets = cntrs.port_xmit_packets;\r\nif (p->counter_select & IB_PMA_SEL_PORT_RCV_PACKETS)\r\ndev->z_port_rcv_packets = cntrs.port_rcv_packets;\r\nreturn recv_pma_get_portcounters(pmp, ibdev, port);\r\n}\r\nstatic int recv_pma_set_portcounters_ext(struct ib_pma_mad *pmp,\r\nstruct ib_device *ibdev, u8 port)\r\n{\r\nstruct ib_pma_portcounters *p = (struct ib_pma_portcounters *)\r\npmp->data;\r\nstruct ipath_ibdev *dev = to_idev(ibdev);\r\nu64 swords, rwords, spkts, rpkts, xwait;\r\nipath_snapshot_counters(dev->dd, &swords, &rwords, &spkts,\r\n&rpkts, &xwait);\r\nif (p->counter_select & IB_PMA_SELX_PORT_XMIT_DATA)\r\ndev->z_port_xmit_data = swords;\r\nif (p->counter_select & IB_PMA_SELX_PORT_RCV_DATA)\r\ndev->z_port_rcv_data = rwords;\r\nif (p->counter_select & IB_PMA_SELX_PORT_XMIT_PACKETS)\r\ndev->z_port_xmit_packets = spkts;\r\nif (p->counter_select & IB_PMA_SELX_PORT_RCV_PACKETS)\r\ndev->z_port_rcv_packets = rpkts;\r\nif (p->counter_select & IB_PMA_SELX_PORT_UNI_XMIT_PACKETS)\r\ndev->n_unicast_xmit = 0;\r\nif (p->counter_select & IB_PMA_SELX_PORT_UNI_RCV_PACKETS)\r\ndev->n_unicast_rcv = 0;\r\nif (p->counter_select & IB_PMA_SELX_PORT_MULTI_XMIT_PACKETS)\r\ndev->n_multicast_xmit = 0;\r\nif (p->counter_select & IB_PMA_SELX_PORT_MULTI_RCV_PACKETS)\r\ndev->n_multicast_rcv = 0;\r\nreturn recv_pma_get_portcounters_ext(pmp, ibdev, port);\r\n}\r\nstatic int process_subn(struct ib_device *ibdev, int mad_flags,\r\nu8 port_num, struct ib_mad *in_mad,\r\nstruct ib_mad *out_mad)\r\n{\r\nstruct ib_smp *smp = (struct ib_smp *)out_mad;\r\nstruct ipath_ibdev *dev = to_idev(ibdev);\r\nint ret;\r\n*out_mad = *in_mad;\r\nif (smp->class_version != 1) {\r\nsmp->status |= IB_SMP_UNSUP_VERSION;\r\nret = reply(smp);\r\ngoto bail;\r\n}\r\nif (dev->mkey_lease_timeout &&\r\ntime_after_eq(jiffies, dev->mkey_lease_timeout)) {\r\ndev->mkey_lease_timeout = 0;\r\ndev->mkeyprot = 0;\r\n}\r\nif ((mad_flags & IB_MAD_IGNORE_MKEY) == 0 && dev->mkey != 0 &&\r\ndev->mkey != smp->mkey &&\r\n(smp->method == IB_MGMT_METHOD_SET ||\r\n(smp->method == IB_MGMT_METHOD_GET &&\r\ndev->mkeyprot >= 2))) {\r\nif (dev->mkey_violations != 0xFFFF)\r\n++dev->mkey_violations;\r\nif (dev->mkey_lease_timeout ||\r\ndev->mkey_lease_period == 0) {\r\nret = IB_MAD_RESULT_SUCCESS |\r\nIB_MAD_RESULT_CONSUMED;\r\ngoto bail;\r\n}\r\ndev->mkey_lease_timeout = jiffies +\r\ndev->mkey_lease_period * HZ;\r\nret = IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\r\ngoto bail;\r\n} else if (dev->mkey_lease_timeout)\r\ndev->mkey_lease_timeout = 0;\r\nswitch (smp->method) {\r\ncase IB_MGMT_METHOD_GET:\r\nswitch (smp->attr_id) {\r\ncase IB_SMP_ATTR_NODE_DESC:\r\nret = recv_subn_get_nodedescription(smp, ibdev);\r\ngoto bail;\r\ncase IB_SMP_ATTR_NODE_INFO:\r\nret = recv_subn_get_nodeinfo(smp, ibdev, port_num);\r\ngoto bail;\r\ncase IB_SMP_ATTR_GUID_INFO:\r\nret = recv_subn_get_guidinfo(smp, ibdev);\r\ngoto bail;\r\ncase IB_SMP_ATTR_PORT_INFO:\r\nret = recv_subn_get_portinfo(smp, ibdev, port_num);\r\ngoto bail;\r\ncase IB_SMP_ATTR_PKEY_TABLE:\r\nret = recv_subn_get_pkeytable(smp, ibdev);\r\ngoto bail;\r\ncase IB_SMP_ATTR_SM_INFO:\r\nif (dev->port_cap_flags & IB_PORT_SM_DISABLED) {\r\nret = IB_MAD_RESULT_SUCCESS |\r\nIB_MAD_RESULT_CONSUMED;\r\ngoto bail;\r\n}\r\nif (dev->port_cap_flags & IB_PORT_SM) {\r\nret = IB_MAD_RESULT_SUCCESS;\r\ngoto bail;\r\n}\r\ndefault:\r\nsmp->status |= IB_SMP_UNSUP_METH_ATTR;\r\nret = reply(smp);\r\ngoto bail;\r\n}\r\ncase IB_MGMT_METHOD_SET:\r\nswitch (smp->attr_id) {\r\ncase IB_SMP_ATTR_GUID_INFO:\r\nret = recv_subn_set_guidinfo(smp, ibdev);\r\ngoto bail;\r\ncase IB_SMP_ATTR_PORT_INFO:\r\nret = recv_subn_set_portinfo(smp, ibdev, port_num);\r\ngoto bail;\r\ncase IB_SMP_ATTR_PKEY_TABLE:\r\nret = recv_subn_set_pkeytable(smp, ibdev);\r\ngoto bail;\r\ncase IB_SMP_ATTR_SM_INFO:\r\nif (dev->port_cap_flags & IB_PORT_SM_DISABLED) {\r\nret = IB_MAD_RESULT_SUCCESS |\r\nIB_MAD_RESULT_CONSUMED;\r\ngoto bail;\r\n}\r\nif (dev->port_cap_flags & IB_PORT_SM) {\r\nret = IB_MAD_RESULT_SUCCESS;\r\ngoto bail;\r\n}\r\ndefault:\r\nsmp->status |= IB_SMP_UNSUP_METH_ATTR;\r\nret = reply(smp);\r\ngoto bail;\r\n}\r\ncase IB_MGMT_METHOD_TRAP:\r\ncase IB_MGMT_METHOD_REPORT:\r\ncase IB_MGMT_METHOD_REPORT_RESP:\r\ncase IB_MGMT_METHOD_TRAP_REPRESS:\r\ncase IB_MGMT_METHOD_GET_RESP:\r\nret = IB_MAD_RESULT_SUCCESS;\r\ngoto bail;\r\ndefault:\r\nsmp->status |= IB_SMP_UNSUP_METHOD;\r\nret = reply(smp);\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int process_perf(struct ib_device *ibdev, u8 port_num,\r\nstruct ib_mad *in_mad,\r\nstruct ib_mad *out_mad)\r\n{\r\nstruct ib_pma_mad *pmp = (struct ib_pma_mad *)out_mad;\r\nint ret;\r\n*out_mad = *in_mad;\r\nif (pmp->mad_hdr.class_version != 1) {\r\npmp->mad_hdr.status |= IB_SMP_UNSUP_VERSION;\r\nret = reply((struct ib_smp *) pmp);\r\ngoto bail;\r\n}\r\nswitch (pmp->mad_hdr.method) {\r\ncase IB_MGMT_METHOD_GET:\r\nswitch (pmp->mad_hdr.attr_id) {\r\ncase IB_PMA_CLASS_PORT_INFO:\r\nret = recv_pma_get_classportinfo(pmp);\r\ngoto bail;\r\ncase IB_PMA_PORT_SAMPLES_CONTROL:\r\nret = recv_pma_get_portsamplescontrol(pmp, ibdev,\r\nport_num);\r\ngoto bail;\r\ncase IB_PMA_PORT_SAMPLES_RESULT:\r\nret = recv_pma_get_portsamplesresult(pmp, ibdev);\r\ngoto bail;\r\ncase IB_PMA_PORT_SAMPLES_RESULT_EXT:\r\nret = recv_pma_get_portsamplesresult_ext(pmp,\r\nibdev);\r\ngoto bail;\r\ncase IB_PMA_PORT_COUNTERS:\r\nret = recv_pma_get_portcounters(pmp, ibdev,\r\nport_num);\r\ngoto bail;\r\ncase IB_PMA_PORT_COUNTERS_EXT:\r\nret = recv_pma_get_portcounters_ext(pmp, ibdev,\r\nport_num);\r\ngoto bail;\r\ndefault:\r\npmp->mad_hdr.status |= IB_SMP_UNSUP_METH_ATTR;\r\nret = reply((struct ib_smp *) pmp);\r\ngoto bail;\r\n}\r\ncase IB_MGMT_METHOD_SET:\r\nswitch (pmp->mad_hdr.attr_id) {\r\ncase IB_PMA_PORT_SAMPLES_CONTROL:\r\nret = recv_pma_set_portsamplescontrol(pmp, ibdev,\r\nport_num);\r\ngoto bail;\r\ncase IB_PMA_PORT_COUNTERS:\r\nret = recv_pma_set_portcounters(pmp, ibdev,\r\nport_num);\r\ngoto bail;\r\ncase IB_PMA_PORT_COUNTERS_EXT:\r\nret = recv_pma_set_portcounters_ext(pmp, ibdev,\r\nport_num);\r\ngoto bail;\r\ndefault:\r\npmp->mad_hdr.status |= IB_SMP_UNSUP_METH_ATTR;\r\nret = reply((struct ib_smp *) pmp);\r\ngoto bail;\r\n}\r\ncase IB_MGMT_METHOD_GET_RESP:\r\nret = IB_MAD_RESULT_SUCCESS;\r\ngoto bail;\r\ndefault:\r\npmp->mad_hdr.status |= IB_SMP_UNSUP_METHOD;\r\nret = reply((struct ib_smp *) pmp);\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nint ipath_process_mad(struct ib_device *ibdev, int mad_flags, u8 port_num,\r\nstruct ib_wc *in_wc, struct ib_grh *in_grh,\r\nstruct ib_mad *in_mad, struct ib_mad *out_mad)\r\n{\r\nint ret;\r\nswitch (in_mad->mad_hdr.mgmt_class) {\r\ncase IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE:\r\ncase IB_MGMT_CLASS_SUBN_LID_ROUTED:\r\nret = process_subn(ibdev, mad_flags, port_num,\r\nin_mad, out_mad);\r\ngoto bail;\r\ncase IB_MGMT_CLASS_PERF_MGMT:\r\nret = process_perf(ibdev, port_num, in_mad, out_mad);\r\ngoto bail;\r\ndefault:\r\nret = IB_MAD_RESULT_SUCCESS;\r\n}\r\nbail:\r\nreturn ret;\r\n}
