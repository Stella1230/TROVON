static int corb_send_verb(struct lola *chip, unsigned int nid,\r\nunsigned int verb, unsigned int data,\r\nunsigned int extdata)\r\n{\r\nunsigned long flags;\r\nint ret = -EIO;\r\nchip->last_cmd_nid = nid;\r\nchip->last_verb = verb;\r\nchip->last_data = data;\r\nchip->last_extdata = extdata;\r\ndata |= (nid << 20) | (verb << 8);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (chip->rirb.cmds < LOLA_CORB_ENTRIES - 1) {\r\nunsigned int wp = chip->corb.wp + 1;\r\nwp %= LOLA_CORB_ENTRIES;\r\nchip->corb.wp = wp;\r\nchip->corb.buf[wp * 2] = cpu_to_le32(data);\r\nchip->corb.buf[wp * 2 + 1] = cpu_to_le32(extdata);\r\nlola_writew(chip, BAR0, CORBWP, wp);\r\nchip->rirb.cmds++;\r\nsmp_wmb();\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void lola_queue_unsol_event(struct lola *chip, unsigned int res,\r\nunsigned int res_ex)\r\n{\r\nlola_update_ext_clock_freq(chip, res);\r\n}\r\nstatic void lola_update_rirb(struct lola *chip)\r\n{\r\nunsigned int rp, wp;\r\nu32 res, res_ex;\r\nwp = lola_readw(chip, BAR0, RIRBWP);\r\nif (wp == chip->rirb.wp)\r\nreturn;\r\nchip->rirb.wp = wp;\r\nwhile (chip->rirb.rp != wp) {\r\nchip->rirb.rp++;\r\nchip->rirb.rp %= LOLA_CORB_ENTRIES;\r\nrp = chip->rirb.rp << 1;\r\nres_ex = le32_to_cpu(chip->rirb.buf[rp + 1]);\r\nres = le32_to_cpu(chip->rirb.buf[rp]);\r\nif (res_ex & LOLA_RIRB_EX_UNSOL_EV)\r\nlola_queue_unsol_event(chip, res, res_ex);\r\nelse if (chip->rirb.cmds) {\r\nchip->res = res;\r\nchip->res_ex = res_ex;\r\nsmp_wmb();\r\nchip->rirb.cmds--;\r\n}\r\n}\r\n}\r\nstatic int rirb_get_response(struct lola *chip, unsigned int *val,\r\nunsigned int *extval)\r\n{\r\nunsigned long timeout;\r\nagain:\r\ntimeout = jiffies + msecs_to_jiffies(1000);\r\nfor (;;) {\r\nif (chip->polling_mode) {\r\nspin_lock_irq(&chip->reg_lock);\r\nlola_update_rirb(chip);\r\nspin_unlock_irq(&chip->reg_lock);\r\n}\r\nif (!chip->rirb.cmds) {\r\n*val = chip->res;\r\nif (extval)\r\n*extval = chip->res_ex;\r\nverbose_debug("get_response: %x, %x\n",\r\nchip->res, chip->res_ex);\r\nif (chip->res_ex & LOLA_RIRB_EX_ERROR) {\r\nprintk(KERN_WARNING SFX "RIRB ERROR: "\r\n"NID=%x, verb=%x, data=%x, ext=%x\n",\r\nchip->last_cmd_nid,\r\nchip->last_verb, chip->last_data,\r\nchip->last_extdata);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\nudelay(20);\r\ncond_resched();\r\n}\r\nprintk(KERN_WARNING SFX "RIRB response error\n");\r\nif (!chip->polling_mode) {\r\nprintk(KERN_WARNING SFX "switching to polling mode\n");\r\nchip->polling_mode = 1;\r\ngoto again;\r\n}\r\nreturn -EIO;\r\n}\r\nint lola_codec_write(struct lola *chip, unsigned int nid, unsigned int verb,\r\nunsigned int data, unsigned int extdata)\r\n{\r\nverbose_debug("codec_write NID=%x, verb=%x, data=%x, ext=%x\n",\r\nnid, verb, data, extdata);\r\nreturn corb_send_verb(chip, nid, verb, data, extdata);\r\n}\r\nint lola_codec_read(struct lola *chip, unsigned int nid, unsigned int verb,\r\nunsigned int data, unsigned int extdata,\r\nunsigned int *val, unsigned int *extval)\r\n{\r\nint err;\r\nverbose_debug("codec_read NID=%x, verb=%x, data=%x, ext=%x\n",\r\nnid, verb, data, extdata);\r\nerr = corb_send_verb(chip, nid, verb, data, extdata);\r\nif (err < 0)\r\nreturn err;\r\nerr = rirb_get_response(chip, val, extval);\r\nreturn err;\r\n}\r\nint lola_codec_flush(struct lola *chip)\r\n{\r\nunsigned int tmp;\r\nreturn rirb_get_response(chip, &tmp, NULL);\r\n}\r\nstatic irqreturn_t lola_interrupt(int irq, void *dev_id)\r\n{\r\nstruct lola *chip = dev_id;\r\nunsigned int notify_ins, notify_outs, error_ins, error_outs;\r\nint handled = 0;\r\nint i;\r\nnotify_ins = notify_outs = error_ins = error_outs = 0;\r\nspin_lock(&chip->reg_lock);\r\nfor (;;) {\r\nunsigned int status, in_sts, out_sts;\r\nunsigned int reg;\r\nstatus = lola_readl(chip, BAR1, DINTSTS);\r\nif (!status || status == -1)\r\nbreak;\r\nin_sts = lola_readl(chip, BAR1, DIINTSTS);\r\nout_sts = lola_readl(chip, BAR1, DOINTSTS);\r\nfor (i = 0; in_sts && i < chip->pcm[CAPT].num_streams; i++) {\r\nif (!(in_sts & (1 << i)))\r\ncontinue;\r\nin_sts &= ~(1 << i);\r\nreg = lola_dsd_read(chip, i, STS);\r\nif (reg & LOLA_DSD_STS_DESE)\r\nerror_ins |= (1 << i);\r\nif (reg & LOLA_DSD_STS_BCIS)\r\nnotify_ins |= (1 << i);\r\nlola_dsd_write(chip, i, STS, reg);\r\n}\r\nfor (i = 0; out_sts && i < chip->pcm[PLAY].num_streams; i++) {\r\nif (!(out_sts & (1 << i)))\r\ncontinue;\r\nout_sts &= ~(1 << i);\r\nreg = lola_dsd_read(chip, i + MAX_STREAM_IN_COUNT, STS);\r\nif (reg & LOLA_DSD_STS_DESE)\r\nerror_outs |= (1 << i);\r\nif (reg & LOLA_DSD_STS_BCIS)\r\nnotify_outs |= (1 << i);\r\nlola_dsd_write(chip, i + MAX_STREAM_IN_COUNT, STS, reg);\r\n}\r\nif (status & LOLA_DINT_CTRL) {\r\nunsigned char rbsts;\r\nrbsts = lola_readb(chip, BAR0, RIRBSTS);\r\nrbsts &= LOLA_RIRB_INT_MASK;\r\nif (rbsts)\r\nlola_writeb(chip, BAR0, RIRBSTS, rbsts);\r\nrbsts = lola_readb(chip, BAR0, CORBSTS);\r\nrbsts &= LOLA_CORB_INT_MASK;\r\nif (rbsts)\r\nlola_writeb(chip, BAR0, CORBSTS, rbsts);\r\nlola_update_rirb(chip);\r\n}\r\nif (status & (LOLA_DINT_FIFOERR | LOLA_DINT_MUERR)) {\r\nlola_writel(chip, BAR1, DINTSTS,\r\n(status & (LOLA_DINT_FIFOERR | LOLA_DINT_MUERR)));\r\n}\r\nhandled = 1;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nlola_pcm_update(chip, &chip->pcm[CAPT], notify_ins);\r\nlola_pcm_update(chip, &chip->pcm[PLAY], notify_outs);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int reset_controller(struct lola *chip)\r\n{\r\nunsigned int gctl = lola_readl(chip, BAR0, GCTL);\r\nunsigned long end_time;\r\nif (gctl) {\r\nlola_writel(chip, BAR1, BOARD_MODE, 0);\r\nreturn 0;\r\n}\r\nchip->cold_reset = 1;\r\nlola_writel(chip, BAR0, GCTL, LOLA_GCTL_RESET);\r\nend_time = jiffies + msecs_to_jiffies(200);\r\ndo {\r\nmsleep(1);\r\ngctl = lola_readl(chip, BAR0, GCTL);\r\nif (gctl)\r\nbreak;\r\n} while (time_before(jiffies, end_time));\r\nif (!gctl) {\r\nprintk(KERN_ERR SFX "cannot reset controller\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lola_irq_enable(struct lola *chip)\r\n{\r\nunsigned int val;\r\nval = (1 << chip->pcm[PLAY].num_streams) - 1;\r\nlola_writel(chip, BAR1, DOINTCTL, val);\r\nval = (1 << chip->pcm[CAPT].num_streams) - 1;\r\nlola_writel(chip, BAR1, DIINTCTL, val);\r\nval = LOLA_DINT_GLOBAL | LOLA_DINT_CTRL | LOLA_DINT_FIFOERR |\r\nLOLA_DINT_MUERR;\r\nlola_writel(chip, BAR1, DINTCTL, val);\r\n}\r\nstatic void lola_irq_disable(struct lola *chip)\r\n{\r\nlola_writel(chip, BAR1, DINTCTL, 0);\r\nlola_writel(chip, BAR1, DIINTCTL, 0);\r\nlola_writel(chip, BAR1, DOINTCTL, 0);\r\n}\r\nstatic int setup_corb_rirb(struct lola *chip)\r\n{\r\nint err;\r\nunsigned char tmp;\r\nunsigned long end_time;\r\nerr = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nPAGE_SIZE, &chip->rb);\r\nif (err < 0)\r\nreturn err;\r\nchip->corb.addr = chip->rb.addr;\r\nchip->corb.buf = (u32 *)chip->rb.area;\r\nchip->rirb.addr = chip->rb.addr + 2048;\r\nchip->rirb.buf = (u32 *)(chip->rb.area + 2048);\r\nlola_writeb(chip, BAR0, RIRBCTL, 0);\r\nlola_writeb(chip, BAR0, CORBCTL, 0);\r\nend_time = jiffies + msecs_to_jiffies(200);\r\ndo {\r\nif (!lola_readb(chip, BAR0, RIRBCTL) &&\r\n!lola_readb(chip, BAR0, CORBCTL))\r\nbreak;\r\nmsleep(1);\r\n} while (time_before(jiffies, end_time));\r\nlola_writel(chip, BAR0, CORBLBASE, (u32)chip->corb.addr);\r\nlola_writel(chip, BAR0, CORBUBASE, upper_32_bits(chip->corb.addr));\r\nlola_writeb(chip, BAR0, CORBSIZE, 0x02);\r\nlola_writew(chip, BAR0, CORBWP, 0);\r\nlola_writew(chip, BAR0, CORBRP, LOLA_RBRWP_CLR);\r\nlola_writeb(chip, BAR0, CORBCTL, LOLA_RBCTL_DMA_EN);\r\ntmp = lola_readb(chip, BAR0, CORBSTS) & LOLA_CORB_INT_MASK;\r\nif (tmp)\r\nlola_writeb(chip, BAR0, CORBSTS, tmp);\r\nchip->corb.wp = 0;\r\nlola_writel(chip, BAR0, RIRBLBASE, (u32)chip->rirb.addr);\r\nlola_writel(chip, BAR0, RIRBUBASE, upper_32_bits(chip->rirb.addr));\r\nlola_writeb(chip, BAR0, RIRBSIZE, 0x02);\r\nlola_writew(chip, BAR0, RIRBWP, LOLA_RBRWP_CLR);\r\nlola_writew(chip, BAR0, RINTCNT, 1);\r\nlola_writeb(chip, BAR0, RIRBCTL, LOLA_RBCTL_DMA_EN | LOLA_RBCTL_IRQ_EN);\r\ntmp = lola_readb(chip, BAR0, RIRBSTS) & LOLA_RIRB_INT_MASK;\r\nif (tmp)\r\nlola_writeb(chip, BAR0, RIRBSTS, tmp);\r\nchip->rirb.rp = chip->rirb.cmds = 0;\r\nreturn 0;\r\n}\r\nstatic void stop_corb_rirb(struct lola *chip)\r\n{\r\nlola_writeb(chip, BAR0, RIRBCTL, 0);\r\nlola_writeb(chip, BAR0, CORBCTL, 0);\r\n}\r\nstatic void lola_reset_setups(struct lola *chip)\r\n{\r\nlola_set_granularity(chip, chip->granularity, true);\r\nlola_set_clock_index(chip, chip->clock.cur_index);\r\nlola_enable_clock_events(chip);\r\nlola_setup_all_analog_gains(chip, CAPT, false);\r\nlola_set_src_config(chip, chip->input_src_mask, false);\r\nlola_setup_all_analog_gains(chip, PLAY, false);\r\n}\r\nstatic int __devinit lola_parse_tree(struct lola *chip)\r\n{\r\nunsigned int val;\r\nint nid, err;\r\nerr = lola_read_param(chip, 0, LOLA_PAR_VENDOR_ID, &val);\r\nif (err < 0) {\r\nprintk(KERN_ERR SFX "Can't read VENDOR_ID\n");\r\nreturn err;\r\n}\r\nval >>= 16;\r\nif (val != 0x1369) {\r\nprintk(KERN_ERR SFX "Unknown codec vendor 0x%x\n", val);\r\nreturn -EINVAL;\r\n}\r\nerr = lola_read_param(chip, 1, LOLA_PAR_FUNCTION_TYPE, &val);\r\nif (err < 0) {\r\nprintk(KERN_ERR SFX "Can't read FUNCTION_TYPE for 0x%x\n", nid);\r\nreturn err;\r\n}\r\nif (val != 1) {\r\nprintk(KERN_ERR SFX "Unknown function type %d\n", val);\r\nreturn -EINVAL;\r\n}\r\nerr = lola_read_param(chip, 1, LOLA_PAR_SPECIFIC_CAPS, &val);\r\nif (err < 0) {\r\nprintk(KERN_ERR SFX "Can't read SPECCAPS\n");\r\nreturn err;\r\n}\r\nchip->lola_caps = val;\r\nchip->pin[CAPT].num_pins = LOLA_AFG_INPUT_PIN_COUNT(chip->lola_caps);\r\nchip->pin[PLAY].num_pins = LOLA_AFG_OUTPUT_PIN_COUNT(chip->lola_caps);\r\nsnd_printdd(SFX "speccaps=0x%x, pins in=%d, out=%d\n",\r\nchip->lola_caps,\r\nchip->pin[CAPT].num_pins, chip->pin[PLAY].num_pins);\r\nif (chip->pin[CAPT].num_pins > MAX_AUDIO_INOUT_COUNT ||\r\nchip->pin[PLAY].num_pins > MAX_AUDIO_INOUT_COUNT) {\r\nprintk(KERN_ERR SFX "Invalid Lola-spec caps 0x%x\n", val);\r\nreturn -EINVAL;\r\n}\r\nnid = 0x02;\r\nerr = lola_init_pcm(chip, CAPT, &nid);\r\nif (err < 0)\r\nreturn err;\r\nerr = lola_init_pcm(chip, PLAY, &nid);\r\nif (err < 0)\r\nreturn err;\r\nerr = lola_init_pins(chip, CAPT, &nid);\r\nif (err < 0)\r\nreturn err;\r\nerr = lola_init_pins(chip, PLAY, &nid);\r\nif (err < 0)\r\nreturn err;\r\nif (LOLA_AFG_CLOCK_WIDGET_PRESENT(chip->lola_caps)) {\r\nerr = lola_init_clock_widget(chip, nid);\r\nif (err < 0)\r\nreturn err;\r\nnid++;\r\n}\r\nif (LOLA_AFG_MIXER_WIDGET_PRESENT(chip->lola_caps)) {\r\nerr = lola_init_mixer_widget(chip, nid);\r\nif (err < 0)\r\nreturn err;\r\nnid++;\r\n}\r\nerr = lola_enable_clock_events(chip);\r\nif (err < 0)\r\nreturn err;\r\nif (!chip->cold_reset) {\r\nlola_reset_setups(chip);\r\nchip->cold_reset = 1;\r\n} else {\r\nif (chip->granularity != LOLA_GRANULARITY_MIN)\r\nlola_set_granularity(chip, chip->granularity, true);\r\n}\r\nreturn 0;\r\n}\r\nstatic void lola_stop_hw(struct lola *chip)\r\n{\r\nstop_corb_rirb(chip);\r\nlola_irq_disable(chip);\r\n}\r\nstatic void lola_free(struct lola *chip)\r\n{\r\nif (chip->initialized)\r\nlola_stop_hw(chip);\r\nlola_free_pcm(chip);\r\nlola_free_mixer(chip);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, (void *)chip);\r\nif (chip->bar[0].remap_addr)\r\niounmap(chip->bar[0].remap_addr);\r\nif (chip->bar[1].remap_addr)\r\niounmap(chip->bar[1].remap_addr);\r\nif (chip->rb.area)\r\nsnd_dma_free_pages(&chip->rb);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\n}\r\nstatic int lola_dev_free(struct snd_device *device)\r\n{\r\nlola_free(device->device_data);\r\nreturn 0;\r\n}\r\nstatic int __devinit lola_create(struct snd_card *card, struct pci_dev *pci,\r\nint dev, struct lola **rchip)\r\n{\r\nstruct lola *chip;\r\nint err;\r\nunsigned int dever;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = lola_dev_free,\r\n};\r\n*rchip = NULL;\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\nreturn err;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip) {\r\nsnd_printk(KERN_ERR SFX "cannot allocate chip\n");\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&chip->reg_lock);\r\nmutex_init(&chip->open_mutex);\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nchip->granularity = granularity[dev];\r\nswitch (chip->granularity) {\r\ncase 8:\r\nchip->sample_rate_max = 48000;\r\nbreak;\r\ncase 16:\r\nchip->sample_rate_max = 96000;\r\nbreak;\r\ncase 32:\r\nchip->sample_rate_max = 192000;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING SFX\r\n"Invalid granularity %d, reset to %d\n",\r\nchip->granularity, LOLA_GRANULARITY_MAX);\r\nchip->granularity = LOLA_GRANULARITY_MAX;\r\nchip->sample_rate_max = 192000;\r\nbreak;\r\n}\r\nchip->sample_rate_min = sample_rate_min[dev];\r\nif (chip->sample_rate_min > chip->sample_rate_max) {\r\nsnd_printk(KERN_WARNING SFX\r\n"Invalid sample_rate_min %d, reset to 16000\n",\r\nchip->sample_rate_min);\r\nchip->sample_rate_min = 16000;\r\n}\r\nerr = pci_request_regions(pci, DRVNAME);\r\nif (err < 0) {\r\nkfree(chip);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nchip->bar[0].addr = pci_resource_start(pci, 0);\r\nchip->bar[0].remap_addr = pci_ioremap_bar(pci, 0);\r\nchip->bar[1].addr = pci_resource_start(pci, 2);\r\nchip->bar[1].remap_addr = pci_ioremap_bar(pci, 2);\r\nif (!chip->bar[0].remap_addr || !chip->bar[1].remap_addr) {\r\nsnd_printk(KERN_ERR SFX "ioremap error\n");\r\nerr = -ENXIO;\r\ngoto errout;\r\n}\r\npci_set_master(pci);\r\nerr = reset_controller(chip);\r\nif (err < 0)\r\ngoto errout;\r\nif (request_irq(pci->irq, lola_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\nprintk(KERN_ERR SFX "unable to grab IRQ %d\n", pci->irq);\r\nerr = -EBUSY;\r\ngoto errout;\r\n}\r\nchip->irq = pci->irq;\r\nsynchronize_irq(chip->irq);\r\ndever = lola_readl(chip, BAR1, DEVER);\r\nchip->pcm[CAPT].num_streams = (dever >> 0) & 0x3ff;\r\nchip->pcm[PLAY].num_streams = (dever >> 10) & 0x3ff;\r\nchip->version = (dever >> 24) & 0xff;\r\nsnd_printdd(SFX "streams in=%d, out=%d, version=0x%x\n",\r\nchip->pcm[CAPT].num_streams, chip->pcm[PLAY].num_streams,\r\nchip->version);\r\nif (chip->pcm[CAPT].num_streams > MAX_STREAM_IN_COUNT ||\r\nchip->pcm[PLAY].num_streams > MAX_STREAM_OUT_COUNT ||\r\n(!chip->pcm[CAPT].num_streams &&\r\n!chip->pcm[PLAY].num_streams)) {\r\nprintk(KERN_ERR SFX "invalid DEVER = %x\n", dever);\r\nerr = -EINVAL;\r\ngoto errout;\r\n}\r\nerr = setup_corb_rirb(chip);\r\nif (err < 0)\r\ngoto errout;\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR SFX "Error creating device [card]!\n");\r\ngoto errout;\r\n}\r\nstrcpy(card->driver, "Lola");\r\nstrlcpy(card->shortname, "Digigram Lola", sizeof(card->shortname));\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s at 0x%lx irq %i",\r\ncard->shortname, chip->bar[0].addr, chip->irq);\r\nstrcpy(card->mixername, card->shortname);\r\nlola_irq_enable(chip);\r\nchip->initialized = 1;\r\n*rchip = chip;\r\nreturn 0;\r\nerrout:\r\nlola_free(chip);\r\nreturn err;\r\n}\r\nstatic int __devinit lola_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct lola *chip;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR SFX "Error creating card!\n");\r\nreturn err;\r\n}\r\nsnd_card_set_dev(card, &pci->dev);\r\nerr = lola_create(card, pci, dev, &chip);\r\nif (err < 0)\r\ngoto out_free;\r\ncard->private_data = chip;\r\nerr = lola_parse_tree(chip);\r\nif (err < 0)\r\ngoto out_free;\r\nerr = lola_create_pcm(chip);\r\nif (err < 0)\r\ngoto out_free;\r\nerr = lola_create_mixer(chip);\r\nif (err < 0)\r\ngoto out_free;\r\nlola_proc_debug_new(chip);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto out_free;\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn err;\r\nout_free:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void __devexit lola_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}
