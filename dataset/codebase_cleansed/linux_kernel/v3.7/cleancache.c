struct cleancache_ops cleancache_register_ops(struct cleancache_ops *ops)\r\n{\r\nstruct cleancache_ops old = cleancache_ops;\r\ncleancache_ops = *ops;\r\ncleancache_enabled = 1;\r\nreturn old;\r\n}\r\nvoid __cleancache_init_fs(struct super_block *sb)\r\n{\r\nsb->cleancache_poolid = (*cleancache_ops.init_fs)(PAGE_SIZE);\r\n}\r\nvoid __cleancache_init_shared_fs(char *uuid, struct super_block *sb)\r\n{\r\nsb->cleancache_poolid =\r\n(*cleancache_ops.init_shared_fs)(uuid, PAGE_SIZE);\r\n}\r\nstatic int cleancache_get_key(struct inode *inode,\r\nstruct cleancache_filekey *key)\r\n{\r\nint (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);\r\nint len = 0, maxlen = CLEANCACHE_KEY_MAX;\r\nstruct super_block *sb = inode->i_sb;\r\nkey->u.ino = inode->i_ino;\r\nif (sb->s_export_op != NULL) {\r\nfhfn = sb->s_export_op->encode_fh;\r\nif (fhfn) {\r\nlen = (*fhfn)(inode, &key->u.fh[0], &maxlen, NULL);\r\nif (len <= 0 || len == 255)\r\nreturn -1;\r\nif (maxlen > CLEANCACHE_KEY_MAX)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint __cleancache_get_page(struct page *page)\r\n{\r\nint ret = -1;\r\nint pool_id;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nVM_BUG_ON(!PageLocked(page));\r\npool_id = page->mapping->host->i_sb->cleancache_poolid;\r\nif (pool_id < 0)\r\ngoto out;\r\nif (cleancache_get_key(page->mapping->host, &key) < 0)\r\ngoto out;\r\nret = (*cleancache_ops.get_page)(pool_id, key, page->index, page);\r\nif (ret == 0)\r\ncleancache_succ_gets++;\r\nelse\r\ncleancache_failed_gets++;\r\nout:\r\nreturn ret;\r\n}\r\nvoid __cleancache_put_page(struct page *page)\r\n{\r\nint pool_id;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nVM_BUG_ON(!PageLocked(page));\r\npool_id = page->mapping->host->i_sb->cleancache_poolid;\r\nif (pool_id >= 0 &&\r\ncleancache_get_key(page->mapping->host, &key) >= 0) {\r\n(*cleancache_ops.put_page)(pool_id, key, page->index, page);\r\ncleancache_puts++;\r\n}\r\n}\r\nvoid __cleancache_invalidate_page(struct address_space *mapping,\r\nstruct page *page)\r\n{\r\nint pool_id = mapping->host->i_sb->cleancache_poolid;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nif (pool_id >= 0) {\r\nVM_BUG_ON(!PageLocked(page));\r\nif (cleancache_get_key(mapping->host, &key) >= 0) {\r\n(*cleancache_ops.invalidate_page)(pool_id,\r\nkey, page->index);\r\ncleancache_invalidates++;\r\n}\r\n}\r\n}\r\nvoid __cleancache_invalidate_inode(struct address_space *mapping)\r\n{\r\nint pool_id = mapping->host->i_sb->cleancache_poolid;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nif (pool_id >= 0 && cleancache_get_key(mapping->host, &key) >= 0)\r\n(*cleancache_ops.invalidate_inode)(pool_id, key);\r\n}\r\nvoid __cleancache_invalidate_fs(struct super_block *sb)\r\n{\r\nif (sb->cleancache_poolid >= 0) {\r\nint old_poolid = sb->cleancache_poolid;\r\nsb->cleancache_poolid = -1;\r\n(*cleancache_ops.invalidate_fs)(old_poolid);\r\n}\r\n}\r\nstatic int __init init_cleancache(void)\r\n{\r\n#ifdef CONFIG_DEBUG_FS\r\nstruct dentry *root = debugfs_create_dir("cleancache", NULL);\r\nif (root == NULL)\r\nreturn -ENXIO;\r\ndebugfs_create_u64("succ_gets", S_IRUGO, root, &cleancache_succ_gets);\r\ndebugfs_create_u64("failed_gets", S_IRUGO,\r\nroot, &cleancache_failed_gets);\r\ndebugfs_create_u64("puts", S_IRUGO, root, &cleancache_puts);\r\ndebugfs_create_u64("invalidates", S_IRUGO,\r\nroot, &cleancache_invalidates);\r\n#endif\r\nreturn 0;\r\n}
