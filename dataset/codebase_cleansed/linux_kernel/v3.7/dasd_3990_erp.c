static struct dasd_ccw_req *\r\ndasd_3990_erp_cleanup(struct dasd_ccw_req * erp, char final_status)\r\n{\r\nstruct dasd_ccw_req *cqr = erp->refers;\r\ndasd_free_erp_request(erp, erp->memdev);\r\ncqr->status = final_status;\r\nreturn cqr;\r\n}\r\nstatic void dasd_3990_erp_block_queue(struct dasd_ccw_req *erp, int expires)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nunsigned long flags;\r\nDBF_DEV_EVENT(DBF_INFO, device,\r\n"blocking request queue for %is", expires/HZ);\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\ndasd_device_set_stop_bits(device, DASD_STOPPED_PENDING);\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\nerp->status = DASD_CQR_FILLED;\r\nif (erp->block)\r\ndasd_block_set_timer(erp->block, expires);\r\nelse\r\ndasd_device_set_timer(device, expires);\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_int_req(struct dasd_ccw_req * erp)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nif (erp->function != dasd_3990_erp_int_req) {\r\nerp->retries = 256;\r\nerp->function = dasd_3990_erp_int_req;\r\n} else {\r\ndev_err(&device->cdev->dev,\r\n"is offline or not installed - "\r\n"INTERVENTION REQUIRED!!\n");\r\ndasd_3990_erp_block_queue(erp, 60*HZ);\r\n}\r\nreturn erp;\r\n}\r\nstatic void\r\ndasd_3990_erp_alternate_path(struct dasd_ccw_req * erp)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\n__u8 opm;\r\nunsigned long flags;\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\nopm = ccw_device_get_path_mask(device->cdev);\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\nif (erp->lpm == 0)\r\nerp->lpm = device->path_data.opm &\r\n~(erp->irb.esw.esw0.sublog.lpum);\r\nelse\r\nerp->lpm &= ~(erp->irb.esw.esw0.sublog.lpum);\r\nif ((erp->lpm & opm) != 0x00) {\r\nDBF_DEV_EVENT(DBF_WARNING, device,\r\n"try alternate lpm=%x (lpum=%x / opm=%x)",\r\nerp->lpm, erp->irb.esw.esw0.sublog.lpum, opm);\r\nerp->status = DASD_CQR_FILLED;\r\nerp->retries = 10;\r\n} else {\r\ndev_err(&device->cdev->dev,\r\n"The DASD cannot be reached on any path (lpum=%x"\r\n"/opm=%x)\n", erp->irb.esw.esw0.sublog.lpum, opm);\r\nerp->status = DASD_CQR_FAILED;\r\n}\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_DCTL(struct dasd_ccw_req * erp, char modifier)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nstruct DCTL_data *DCTL_data;\r\nstruct ccw1 *ccw;\r\nstruct dasd_ccw_req *dctl_cqr;\r\ndctl_cqr = dasd_alloc_erp_request((char *) &erp->magic, 1,\r\nsizeof(struct DCTL_data),\r\ndevice);\r\nif (IS_ERR(dctl_cqr)) {\r\ndev_err(&device->cdev->dev,\r\n"Unable to allocate DCTL-CQR\n");\r\nerp->status = DASD_CQR_FAILED;\r\nreturn erp;\r\n}\r\nDCTL_data = dctl_cqr->data;\r\nDCTL_data->subcommand = 0x02;\r\nDCTL_data->modifier = modifier;\r\nccw = dctl_cqr->cpaddr;\r\nmemset(ccw, 0, sizeof(struct ccw1));\r\nccw->cmd_code = CCW_CMD_DCTL;\r\nccw->count = 4;\r\nccw->cda = (__u32)(addr_t) DCTL_data;\r\ndctl_cqr->flags = erp->flags;\r\ndctl_cqr->function = dasd_3990_erp_DCTL;\r\ndctl_cqr->refers = erp;\r\ndctl_cqr->startdev = device;\r\ndctl_cqr->memdev = device;\r\ndctl_cqr->magic = erp->magic;\r\ndctl_cqr->expires = 5 * 60 * HZ;\r\ndctl_cqr->retries = 2;\r\ndctl_cqr->buildclk = get_clock();\r\ndctl_cqr->status = DASD_CQR_FILLED;\r\nreturn dctl_cqr;\r\n}\r\nstatic struct dasd_ccw_req *dasd_3990_erp_action_1_sec(struct dasd_ccw_req *erp)\r\n{\r\nerp->function = dasd_3990_erp_action_1_sec;\r\ndasd_3990_erp_alternate_path(erp);\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *dasd_3990_erp_action_1(struct dasd_ccw_req *erp)\r\n{\r\nerp->function = dasd_3990_erp_action_1;\r\ndasd_3990_erp_alternate_path(erp);\r\nif (erp->status == DASD_CQR_FAILED &&\r\n!test_bit(DASD_CQR_VERIFY_PATH, &erp->flags)) {\r\nerp->status = DASD_CQR_FILLED;\r\nerp->retries = 10;\r\nerp->lpm = erp->startdev->path_data.opm;\r\nerp->function = dasd_3990_erp_action_1_sec;\r\n}\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_action_4(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nif (erp->function != dasd_3990_erp_action_4) {\r\nDBF_DEV_EVENT(DBF_INFO, device, "%s",\r\n"dasd_3990_erp_action_4: first time retry");\r\nerp->retries = 256;\r\nerp->function = dasd_3990_erp_action_4;\r\n} else {\r\nif (sense && (sense[25] == 0x1D)) {\r\nDBF_DEV_EVENT(DBF_INFO, device,\r\n"waiting for state change pending "\r\n"interrupt, %d retries left",\r\nerp->retries);\r\ndasd_3990_erp_block_queue(erp, 30*HZ);\r\n} else if (sense && (sense[25] == 0x1E)) {\r\nDBF_DEV_EVENT(DBF_INFO, device,\r\n"busy - redriving request later, "\r\n"%d retries left",\r\nerp->retries);\r\ndasd_3990_erp_block_queue(erp, HZ);\r\n} else {\r\nDBF_DEV_EVENT(DBF_INFO, device,\r\n"redriving request immediately, "\r\n"%d retries left",\r\nerp->retries);\r\nerp->status = DASD_CQR_FILLED;\r\n}\r\n}\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_action_5(struct dasd_ccw_req * erp)\r\n{\r\nerp->retries = 10;\r\nerp->function = dasd_3990_erp_action_5;\r\nreturn erp;\r\n}\r\nstatic void\r\ndasd_3990_handle_env_data(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nchar msg_format = (sense[7] & 0xF0);\r\nchar msg_no = (sense[7] & 0x0F);\r\nchar errorstring[ERRORLENGTH];\r\nswitch (msg_format) {\r\ncase 0x00:\r\nif (sense[1] & 0x10) {\r\nswitch (msg_no) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x01:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Invalid Command\n");\r\nbreak;\r\ncase 0x02:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Invalid Command "\r\n"Sequence\n");\r\nbreak;\r\ncase 0x03:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - CCW Count less than "\r\n"required\n");\r\nbreak;\r\ncase 0x04:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Invalid Parameter\n");\r\nbreak;\r\ncase 0x05:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Diagnostic of Special"\r\n" Command Violates File Mask\n");\r\nbreak;\r\ncase 0x07:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Channel Returned with "\r\n"Incorrect retry CCW\n");\r\nbreak;\r\ncase 0x08:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Reset Notification\n");\r\nbreak;\r\ncase 0x09:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Storage Path Restart\n");\r\nbreak;\r\ncase 0x0A:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Channel requested "\r\n"... %02x\n", sense[8]);\r\nbreak;\r\ncase 0x0B:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Invalid Defective/"\r\n"Alternate Track Pointer\n");\r\nbreak;\r\ncase 0x0C:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - DPS Installation "\r\n"Check\n");\r\nbreak;\r\ncase 0x0E:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Command Invalid on "\r\n"Secondary Address\n");\r\nbreak;\r\ncase 0x0F:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Status Not As "\r\n"Required: reason %02x\n",\r\nsense[8]);\r\nbreak;\r\ndefault:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Reserved\n");\r\n}\r\n} else {\r\nswitch (msg_no) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x01:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Device Error "\r\n"Source\n");\r\nbreak;\r\ncase 0x02:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Reserved\n");\r\nbreak;\r\ncase 0x03:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Device Fenced - "\r\n"device = %02x\n", sense[4]);\r\nbreak;\r\ncase 0x04:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Data Pinned for "\r\n"Device\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 0 - Reserved\n");\r\n}\r\n}\r\nbreak;\r\ncase 0x10:\r\nswitch (msg_no) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x01:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Device Status 1 not as "\r\n"expected\n");\r\nbreak;\r\ncase 0x03:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Index missing\n");\r\nbreak;\r\ncase 0x04:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Interruption cannot be "\r\n"reset\n");\r\nbreak;\r\ncase 0x05:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Device did not respond to "\r\n"selection\n");\r\nbreak;\r\ncase 0x06:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Device check-2 error or Set "\r\n"Sector is not complete\n");\r\nbreak;\r\ncase 0x07:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Head address does not "\r\n"compare\n");\r\nbreak;\r\ncase 0x08:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Device status 1 not valid\n");\r\nbreak;\r\ncase 0x09:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Device not ready\n");\r\nbreak;\r\ncase 0x0A:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Track physical address did "\r\n"not compare\n");\r\nbreak;\r\ncase 0x0B:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Missing device address bit\n");\r\nbreak;\r\ncase 0x0C:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Drive motor switch is off\n");\r\nbreak;\r\ncase 0x0D:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Seek incomplete\n");\r\nbreak;\r\ncase 0x0E:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Cylinder address did not "\r\n"compare\n");\r\nbreak;\r\ncase 0x0F:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Offset active cannot be "\r\n"reset\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 1 - Reserved\n");\r\n}\r\nbreak;\r\ncase 0x20:\r\nswitch (msg_no) {\r\ncase 0x08:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 2 - 3990 check-2 error\n");\r\nbreak;\r\ncase 0x0E:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 2 - Support facility errors\n");\r\nbreak;\r\ncase 0x0F:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 2 - Microcode detected error "\r\n"%02x\n",\r\nsense[8]);\r\nbreak;\r\ndefault:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 2 - Reserved\n");\r\n}\r\nbreak;\r\ncase 0x30:\r\nswitch (msg_no) {\r\ncase 0x0F:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 3 - Allegiance terminated\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 3 - Reserved\n");\r\n}\r\nbreak;\r\ncase 0x40:\r\nswitch (msg_no) {\r\ncase 0x00:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - Home address area error\n");\r\nbreak;\r\ncase 0x01:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - Count area error\n");\r\nbreak;\r\ncase 0x02:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - Key area error\n");\r\nbreak;\r\ncase 0x03:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - Data area error\n");\r\nbreak;\r\ncase 0x04:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - No sync byte in home address "\r\n"area\n");\r\nbreak;\r\ncase 0x05:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - No sync byte in count address "\r\n"area\n");\r\nbreak;\r\ncase 0x06:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - No sync byte in key area\n");\r\nbreak;\r\ncase 0x07:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - No sync byte in data area\n");\r\nbreak;\r\ncase 0x08:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - Home address area error; "\r\n"offset active\n");\r\nbreak;\r\ncase 0x09:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - Count area error; offset "\r\n"active\n");\r\nbreak;\r\ncase 0x0A:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - Key area error; offset "\r\n"active\n");\r\nbreak;\r\ncase 0x0B:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - Data area error; "\r\n"offset active\n");\r\nbreak;\r\ncase 0x0C:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - No sync byte in home "\r\n"address area; offset active\n");\r\nbreak;\r\ncase 0x0D:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - No syn byte in count "\r\n"address area; offset active\n");\r\nbreak;\r\ncase 0x0E:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - No sync byte in key area; "\r\n"offset active\n");\r\nbreak;\r\ncase 0x0F:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - No syn byte in data area; "\r\n"offset active\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 4 - Reserved\n");\r\n}\r\nbreak;\r\ncase 0x50:\r\nswitch (msg_no) {\r\ncase 0x00:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 5 - Data Check in the "\r\n"home address area\n");\r\nbreak;\r\ncase 0x01:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 5 - Data Check in the count "\r\n"area\n");\r\nbreak;\r\ncase 0x02:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 5 - Data Check in the key area\n");\r\nbreak;\r\ncase 0x03:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 5 - Data Check in the data "\r\n"area\n");\r\nbreak;\r\ncase 0x08:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 5 - Data Check in the "\r\n"home address area; offset active\n");\r\nbreak;\r\ncase 0x09:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 5 - Data Check in the count area; "\r\n"offset active\n");\r\nbreak;\r\ncase 0x0A:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 5 - Data Check in the key area; "\r\n"offset active\n");\r\nbreak;\r\ncase 0x0B:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 5 - Data Check in the data area; "\r\n"offset active\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 5 - Reserved\n");\r\n}\r\nbreak;\r\ncase 0x60:\r\nswitch (msg_no) {\r\ncase 0x00:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 6 - Overrun on channel A\n");\r\nbreak;\r\ncase 0x01:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 6 - Overrun on channel B\n");\r\nbreak;\r\ncase 0x02:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 6 - Overrun on channel C\n");\r\nbreak;\r\ncase 0x03:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 6 - Overrun on channel D\n");\r\nbreak;\r\ncase 0x04:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 6 - Overrun on channel E\n");\r\nbreak;\r\ncase 0x05:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 6 - Overrun on channel F\n");\r\nbreak;\r\ncase 0x06:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 6 - Overrun on channel G\n");\r\nbreak;\r\ncase 0x07:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 6 - Overrun on channel H\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 6 - Reserved\n");\r\n}\r\nbreak;\r\ncase 0x70:\r\nswitch (msg_no) {\r\ncase 0x00:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - RCC initiated by a connection "\r\n"check alert\n");\r\nbreak;\r\ncase 0x01:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - RCC 1 sequence not "\r\n"successful\n");\r\nbreak;\r\ncase 0x02:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - RCC 1 and RCC 2 sequences not "\r\n"successful\n");\r\nbreak;\r\ncase 0x03:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - Invalid tag-in during "\r\n"selection sequence\n");\r\nbreak;\r\ncase 0x04:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - extra RCC required\n");\r\nbreak;\r\ncase 0x05:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - Invalid DCC selection "\r\n"response or timeout\n");\r\nbreak;\r\ncase 0x06:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - Missing end operation; device "\r\n"transfer complete\n");\r\nbreak;\r\ncase 0x07:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - Missing end operation; device "\r\n"transfer incomplete\n");\r\nbreak;\r\ncase 0x08:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - Invalid tag-in for an "\r\n"immediate command sequence\n");\r\nbreak;\r\ncase 0x09:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - Invalid tag-in for an "\r\n"extended command sequence\n");\r\nbreak;\r\ncase 0x0A:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - 3990 microcode time out when "\r\n"stopping selection\n");\r\nbreak;\r\ncase 0x0B:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - No response to selection "\r\n"after a poll interruption\n");\r\nbreak;\r\ncase 0x0C:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - Permanent path error (DASD "\r\n"controller not available)\n");\r\nbreak;\r\ncase 0x0D:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - DASD controller not available"\r\n" on disconnected command chain\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 7 - Reserved\n");\r\n}\r\nbreak;\r\ncase 0x80:\r\nswitch (msg_no) {\r\ncase 0x00:\r\ncase 0x01:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 8 - Error correction code "\r\n"hardware fault\n");\r\nbreak;\r\ncase 0x03:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 8 - Unexpected end operation "\r\n"response code\n");\r\nbreak;\r\ncase 0x04:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 8 - End operation with transfer "\r\n"count not zero\n");\r\nbreak;\r\ncase 0x05:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 8 - End operation with transfer "\r\n"count zero\n");\r\nbreak;\r\ncase 0x06:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 8 - DPS checks after a system "\r\n"reset or selective reset\n");\r\nbreak;\r\ncase 0x07:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 8 - DPS cannot be filled\n");\r\nbreak;\r\ncase 0x08:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 8 - Short busy time-out during "\r\n"device selection\n");\r\nbreak;\r\ncase 0x09:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 8 - DASD controller failed to "\r\n"set or reset the long busy latch\n");\r\nbreak;\r\ncase 0x0A:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 8 - No interruption from device "\r\n"during a command chain\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 8 - Reserved\n");\r\n}\r\nbreak;\r\ncase 0x90:\r\nswitch (msg_no) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x06:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 9 - Device check-2 error\n");\r\nbreak;\r\ncase 0x07:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 9 - Head address did not "\r\n"compare\n");\r\nbreak;\r\ncase 0x0A:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 9 - Track physical address did "\r\n"not compare while oriented\n");\r\nbreak;\r\ncase 0x0E:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 9 - Cylinder address did not "\r\n"compare\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT 9 - Reserved\n");\r\n}\r\nbreak;\r\ncase 0xF0:\r\nswitch (msg_no) {\r\ncase 0x00:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT F - Operation Terminated\n");\r\nbreak;\r\ncase 0x01:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT F - Subsystem Processing Error\n");\r\nbreak;\r\ncase 0x02:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT F - Cache or nonvolatile storage "\r\n"equipment failure\n");\r\nbreak;\r\ncase 0x04:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT F - Caching terminated\n");\r\nbreak;\r\ncase 0x06:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT F - Cache fast write access not "\r\n"authorized\n");\r\nbreak;\r\ncase 0x07:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT F - Track format incorrect\n");\r\nbreak;\r\ncase 0x09:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT F - Caching reinitiated\n");\r\nbreak;\r\ncase 0x0A:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT F - Nonvolatile storage "\r\n"terminated\n");\r\nbreak;\r\ncase 0x0B:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT F - Volume is suspended duplex\n");\r\ndasd_eer_write(device, erp->refers,\r\nDASD_EER_PPRCSUSPEND);\r\nbreak;\r\ncase 0x0C:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT F - Subsystem status cannot be "\r\n"determined\n");\r\nbreak;\r\ncase 0x0D:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT F - Caching status reset to "\r\n"default\n");\r\nbreak;\r\ncase 0x0E:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT F - DASD Fast Write inhibited\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&device->cdev->dev,\r\n"FORMAT D - Reserved\n");\r\n}\r\nbreak;\r\ndefault:\r\nsnprintf(errorstring, ERRORLENGTH, "03 %x02", msg_format);\r\ndev_err(&device->cdev->dev,\r\n"An error occurred in the DASD device driver, "\r\n"reason=%s\n", errorstring);\r\nbreak;\r\n}\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_com_rej(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nerp->function = dasd_3990_erp_com_rej;\r\nif (sense[2] & SNS2_ENV_DATA_PRESENT) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Command Reject - environmental data present");\r\ndasd_3990_handle_env_data(erp, sense);\r\nerp->retries = 5;\r\n} else if (sense[1] & SNS1_WRITE_INHIBITED) {\r\ndev_err(&device->cdev->dev, "An I/O request was rejected"\r\n" because writing is inhibited\n");\r\nerp = dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\r\n} else {\r\ndev_err(&device->cdev->dev, "An error occurred in the DASD "\r\n"device driver, reason=%s\n", "09");\r\nerp = dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\r\n}\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_bus_out(struct dasd_ccw_req * erp)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nif (erp->function != dasd_3990_erp_bus_out) {\r\nerp->retries = 256;\r\nerp->function = dasd_3990_erp_bus_out;\r\n} else {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"bus out parity error or BOPC requested by "\r\n"channel");\r\ndasd_3990_erp_block_queue(erp, 60*HZ);\r\n}\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_equip_check(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nerp->function = dasd_3990_erp_equip_check;\r\nif (sense[1] & SNS1_WRITE_INHIBITED) {\r\ndev_info(&device->cdev->dev,\r\n"Write inhibited path encountered\n");\r\ndev_err(&device->cdev->dev, "An error occurred in the DASD "\r\n"device driver, reason=%s\n", "04");\r\nerp = dasd_3990_erp_action_1(erp);\r\n} else if (sense[2] & SNS2_ENV_DATA_PRESENT) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Equipment Check - " "environmental data present");\r\ndasd_3990_handle_env_data(erp, sense);\r\nerp = dasd_3990_erp_action_4(erp, sense);\r\n} else if (sense[1] & SNS1_PERM_ERR) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Equipment Check - retry exhausted or "\r\n"undesirable");\r\nerp = dasd_3990_erp_action_1(erp);\r\n} else {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Equipment check or processing error");\r\nerp = dasd_3990_erp_action_5(erp);\r\n}\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_data_check(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nerp->function = dasd_3990_erp_data_check;\r\nif (sense[2] & SNS2_CORRECTABLE) {\r\ndev_emerg(&device->cdev->dev,\r\n"Data recovered during retry with PCI "\r\n"fetch mode active\n");\r\npanic("No way to inform application about the possibly "\r\n"incorrect data");\r\n} else if (sense[2] & SNS2_ENV_DATA_PRESENT) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Uncorrectable data check recovered secondary "\r\n"addr of duplex pair");\r\nerp = dasd_3990_erp_action_4(erp, sense);\r\n} else if (sense[1] & SNS1_PERM_ERR) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Uncorrectable data check with internal "\r\n"retry exhausted");\r\nerp = dasd_3990_erp_action_1(erp);\r\n} else {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Uncorrectable data check with retry count "\r\n"exhausted...");\r\nerp = dasd_3990_erp_action_5(erp);\r\n}\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_overrun(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nerp->function = dasd_3990_erp_overrun;\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Overrun - service overrun or overrun"\r\n" error requested by channel");\r\nerp = dasd_3990_erp_action_5(erp);\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_inv_format(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nerp->function = dasd_3990_erp_inv_format;\r\nif (sense[2] & SNS2_ENV_DATA_PRESENT) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Track format error when destaging or "\r\n"staging data");\r\ndasd_3990_handle_env_data(erp, sense);\r\nerp = dasd_3990_erp_action_4(erp, sense);\r\n} else {\r\ndev_err(&device->cdev->dev,\r\n"An error occurred in the DASD device driver, "\r\n"reason=%s\n", "06");\r\nerp = dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\r\n}\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_EOC(struct dasd_ccw_req * default_erp, char *sense)\r\n{\r\nstruct dasd_device *device = default_erp->startdev;\r\ndev_err(&device->cdev->dev,\r\n"The cylinder data for accessing the DASD is inconsistent\n");\r\nreturn dasd_3990_erp_cleanup(default_erp, DASD_CQR_FAILED);\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_env_data(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nerp->function = dasd_3990_erp_env_data;\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s", "Environmental data present");\r\ndasd_3990_handle_env_data(erp, sense);\r\nif (sense[7] != 0x0F) {\r\nerp = dasd_3990_erp_action_4(erp, sense);\r\n} else {\r\nerp->status = DASD_CQR_FILLED;\r\n}\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_no_rec(struct dasd_ccw_req * default_erp, char *sense)\r\n{\r\nstruct dasd_device *device = default_erp->startdev;\r\ndev_err(&device->cdev->dev,\r\n"The specified record was not found\n");\r\nreturn dasd_3990_erp_cleanup(default_erp, DASD_CQR_FAILED);\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_file_prot(struct dasd_ccw_req * erp)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\ndev_err(&device->cdev->dev, "Accessing the DASD failed because of "\r\n"a hardware error\n");\r\nreturn dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\r\n}\r\nstatic struct dasd_ccw_req *dasd_3990_erp_inspect_alias(\r\nstruct dasd_ccw_req *erp)\r\n{\r\nstruct dasd_ccw_req *cqr = erp->refers;\r\nchar *sense;\r\nif (cqr->block &&\r\n(cqr->block->base != cqr->startdev)) {\r\nsense = dasd_get_sense(&erp->refers->irb);\r\nif (!test_bit(DASD_FLAG_OFFLINE, &cqr->startdev->flags) && sense\r\n&& (sense[0] == 0x10) && (sense[7] == 0x0F)\r\n&& (sense[8] == 0x67)) {\r\ndasd_alias_remove_device(cqr->startdev);\r\ndasd_reload_device(cqr->startdev);\r\n}\r\nif (cqr->startdev->features & DASD_FEATURE_ERPLOG) {\r\nDBF_DEV_EVENT(DBF_ERR, cqr->startdev,\r\n"ERP on alias device for request %p,"\r\n" recover on base device %s", cqr,\r\ndev_name(&cqr->block->base->cdev->dev));\r\n}\r\ndasd_eckd_reset_ccw_to_base_io(cqr);\r\nerp->startdev = cqr->block->base;\r\nerp->function = dasd_3990_erp_inspect_alias;\r\nreturn erp;\r\n} else\r\nreturn NULL;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_inspect_24(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nstruct dasd_ccw_req *erp_filled = NULL;\r\nif ((erp_filled == NULL) && (sense[0] & SNS0_CMD_REJECT)) {\r\nerp_filled = dasd_3990_erp_com_rej(erp, sense);\r\n}\r\nif ((erp_filled == NULL) && (sense[0] & SNS0_INTERVENTION_REQ)) {\r\nerp_filled = dasd_3990_erp_int_req(erp);\r\n}\r\nif ((erp_filled == NULL) && (sense[0] & SNS0_BUS_OUT_CHECK)) {\r\nerp_filled = dasd_3990_erp_bus_out(erp);\r\n}\r\nif ((erp_filled == NULL) && (sense[0] & SNS0_EQUIPMENT_CHECK)) {\r\nerp_filled = dasd_3990_erp_equip_check(erp, sense);\r\n}\r\nif ((erp_filled == NULL) && (sense[0] & SNS0_DATA_CHECK)) {\r\nerp_filled = dasd_3990_erp_data_check(erp, sense);\r\n}\r\nif ((erp_filled == NULL) && (sense[0] & SNS0_OVERRUN)) {\r\nerp_filled = dasd_3990_erp_overrun(erp, sense);\r\n}\r\nif ((erp_filled == NULL) && (sense[1] & SNS1_INV_TRACK_FORMAT)) {\r\nerp_filled = dasd_3990_erp_inv_format(erp, sense);\r\n}\r\nif ((erp_filled == NULL) && (sense[1] & SNS1_EOC)) {\r\nerp_filled = dasd_3990_erp_EOC(erp, sense);\r\n}\r\nif ((erp_filled == NULL) && (sense[2] & SNS2_ENV_DATA_PRESENT)) {\r\nerp_filled = dasd_3990_erp_env_data(erp, sense);\r\n}\r\nif ((erp_filled == NULL) && (sense[1] & SNS1_NO_REC_FOUND)) {\r\nerp_filled = dasd_3990_erp_no_rec(erp, sense);\r\n}\r\nif ((erp_filled == NULL) && (sense[1] & SNS1_FILE_PROTECTED)) {\r\nerp_filled = dasd_3990_erp_file_prot(erp);\r\n}\r\nif (erp_filled == NULL) {\r\nerp_filled = erp;\r\n}\r\nreturn erp_filled;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_action_10_32(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nerp->retries = 256;\r\nerp->function = dasd_3990_erp_action_10_32;\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s", "Perform logging requested");\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_action_1B_32(struct dasd_ccw_req * default_erp, char *sense)\r\n{\r\nstruct dasd_device *device = default_erp->startdev;\r\n__u32 cpa = 0;\r\nstruct dasd_ccw_req *cqr;\r\nstruct dasd_ccw_req *erp;\r\nstruct DE_eckd_data *DE_data;\r\nstruct PFX_eckd_data *PFX_data;\r\nchar *LO_data;\r\nstruct ccw1 *ccw, *oldccw;\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Write not finished because of unexpected condition");\r\ndefault_erp->function = dasd_3990_erp_action_1B_32;\r\ncqr = default_erp;\r\nwhile (cqr->refers != NULL) {\r\ncqr = cqr->refers;\r\n}\r\nif (scsw_is_tm(&cqr->irb.scsw)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"32 bit sense, action 1B is not defined"\r\n" in transport mode - just retry");\r\nreturn default_erp;\r\n}\r\nif (sense[1] & 0x01) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Imprecise ending is set - just retry");\r\nreturn default_erp;\r\n}\r\ncpa = default_erp->refers->irb.scsw.cmd.cpa;\r\nif (cpa == 0) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Unable to determine address of the CCW "\r\n"to be restarted");\r\nreturn dasd_3990_erp_cleanup(default_erp, DASD_CQR_FAILED);\r\n}\r\nerp = dasd_alloc_erp_request((char *) &cqr->magic,\r\n2 + 1,\r\nsizeof(struct DE_eckd_data) +\r\nsizeof(struct LO_eckd_data), device);\r\nif (IS_ERR(erp)) {\r\ndev_err(&device->cdev->dev, "An error occurred in the DASD "\r\n"device driver, reason=%s\n", "01");\r\nreturn dasd_3990_erp_cleanup(default_erp, DASD_CQR_FAILED);\r\n}\r\nDE_data = erp->data;\r\noldccw = cqr->cpaddr;\r\nif (oldccw->cmd_code == DASD_ECKD_CCW_PFX) {\r\nPFX_data = cqr->data;\r\nmemcpy(DE_data, &PFX_data->define_extent,\r\nsizeof(struct DE_eckd_data));\r\n} else\r\nmemcpy(DE_data, cqr->data, sizeof(struct DE_eckd_data));\r\nLO_data = erp->data + sizeof(struct DE_eckd_data);\r\nif ((sense[3] == 0x01) && (LO_data[1] & 0x01)) {\r\nreturn dasd_3990_erp_cleanup(default_erp, DASD_CQR_FAILED);\r\n}\r\nif ((sense[7] & 0x3F) == 0x01) {\r\nLO_data[0] = 0x81;\r\n} else if ((sense[7] & 0x3F) == 0x03) {\r\nLO_data[0] = 0xC3;\r\n} else {\r\nLO_data[0] = sense[7];\r\n}\r\nLO_data[1] = sense[8];\r\nLO_data[2] = sense[9];\r\nLO_data[3] = sense[3];\r\nLO_data[4] = sense[29];\r\nLO_data[5] = sense[30];\r\nLO_data[7] = sense[31];\r\nmemcpy(&(LO_data[8]), &(sense[11]), 8);\r\nccw = erp->cpaddr;\r\nmemset(ccw, 0, sizeof(struct ccw1));\r\nccw->cmd_code = DASD_ECKD_CCW_DEFINE_EXTENT;\r\nccw->flags = CCW_FLAG_CC;\r\nccw->count = 16;\r\nccw->cda = (__u32)(addr_t) DE_data;\r\nccw++;\r\nmemset(ccw, 0, sizeof(struct ccw1));\r\nccw->cmd_code = DASD_ECKD_CCW_LOCATE_RECORD;\r\nccw->flags = CCW_FLAG_CC;\r\nccw->count = 16;\r\nccw->cda = (__u32)(addr_t) LO_data;\r\nccw++;\r\nccw->cmd_code = CCW_CMD_TIC;\r\nccw->cda = cpa;\r\nerp->flags = default_erp->flags;\r\nerp->function = dasd_3990_erp_action_1B_32;\r\nerp->refers = default_erp->refers;\r\nerp->startdev = device;\r\nerp->memdev = device;\r\nerp->magic = default_erp->magic;\r\nerp->expires = default_erp->expires;\r\nerp->retries = 256;\r\nerp->buildclk = get_clock();\r\nerp->status = DASD_CQR_FILLED;\r\ndasd_free_erp_request(default_erp, device);\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_update_1B(struct dasd_ccw_req * previous_erp, char *sense)\r\n{\r\nstruct dasd_device *device = previous_erp->startdev;\r\n__u32 cpa = 0;\r\nstruct dasd_ccw_req *cqr;\r\nstruct dasd_ccw_req *erp;\r\nchar *LO_data;\r\nstruct ccw1 *ccw;\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Write not finished because of unexpected condition"\r\n" - follow on");\r\ncqr = previous_erp;\r\nwhile (cqr->refers != NULL) {\r\ncqr = cqr->refers;\r\n}\r\nif (scsw_is_tm(&cqr->irb.scsw)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"32 bit sense, action 1B, update,"\r\n" in transport mode - just retry");\r\nreturn previous_erp;\r\n}\r\nif (sense[1] & 0x01) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Imprecise ending is set - just retry");\r\nprevious_erp->status = DASD_CQR_FILLED;\r\nreturn previous_erp;\r\n}\r\ncpa = previous_erp->irb.scsw.cmd.cpa;\r\nif (cpa == 0) {\r\ndev_err(&device->cdev->dev, "An error occurred in the DASD "\r\n"device driver, reason=%s\n", "02");\r\nprevious_erp->status = DASD_CQR_FAILED;\r\nreturn previous_erp;\r\n}\r\nerp = previous_erp;\r\nLO_data = erp->data + sizeof(struct DE_eckd_data);\r\nif ((sense[3] == 0x01) && (LO_data[1] & 0x01)) {\r\nprevious_erp->status = DASD_CQR_FAILED;\r\nreturn previous_erp;\r\n}\r\nif ((sense[7] & 0x3F) == 0x01) {\r\nLO_data[0] = 0x81;\r\n} else if ((sense[7] & 0x3F) == 0x03) {\r\nLO_data[0] = 0xC3;\r\n} else {\r\nLO_data[0] = sense[7];\r\n}\r\nLO_data[1] = sense[8];\r\nLO_data[2] = sense[9];\r\nLO_data[3] = sense[3];\r\nLO_data[4] = sense[29];\r\nLO_data[5] = sense[30];\r\nLO_data[7] = sense[31];\r\nmemcpy(&(LO_data[8]), &(sense[11]), 8);\r\nccw = erp->cpaddr;\r\nccw++;\r\nccw++;\r\nccw->cda = cpa;\r\nerp->status = DASD_CQR_FILLED;\r\nreturn erp;\r\n}\r\nstatic void\r\ndasd_3990_erp_compound_retry(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nswitch (sense[25] & 0x03) {\r\ncase 0x00:\r\nerp->retries = 1;\r\nbreak;\r\ncase 0x01:\r\nerp->retries = 2;\r\nbreak;\r\ncase 0x02:\r\nerp->retries = 10;\r\nbreak;\r\ncase 0x03:\r\nerp->retries = 256;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nerp->function = dasd_3990_erp_compound_retry;\r\n}\r\nstatic void\r\ndasd_3990_erp_compound_path(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nif (sense[25] & DASD_SENSE_BIT_3) {\r\ndasd_3990_erp_alternate_path(erp);\r\nif (erp->status == DASD_CQR_FAILED &&\r\n!test_bit(DASD_CQR_VERIFY_PATH, &erp->flags)) {\r\nerp->lpm = erp->startdev->path_data.opm;\r\nerp->status = DASD_CQR_NEED_ERP;\r\n}\r\n}\r\nerp->function = dasd_3990_erp_compound_path;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_compound_code(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nif (sense[25] & DASD_SENSE_BIT_2) {\r\nswitch (sense[28]) {\r\ncase 0x17:\r\nerp = dasd_3990_erp_DCTL(erp, 0x20);\r\nbreak;\r\ncase 0x25:\r\nerp->retries = 1;\r\ndasd_3990_erp_block_queue (erp, 5*HZ);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nerp->function = dasd_3990_erp_compound_code;\r\nreturn erp;\r\n}\r\nstatic void\r\ndasd_3990_erp_compound_config(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nif ((sense[25] & DASD_SENSE_BIT_1) && (sense[26] & DASD_SENSE_BIT_2)) {\r\nstruct dasd_device *device = erp->startdev;\r\ndev_err(&device->cdev->dev,\r\n"An error occurred in the DASD device driver, "\r\n"reason=%s\n", "05");\r\n}\r\nerp->function = dasd_3990_erp_compound_config;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_compound(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nif ((erp->function == dasd_3990_erp_compound_retry) &&\r\n(erp->status == DASD_CQR_NEED_ERP)) {\r\ndasd_3990_erp_compound_path(erp, sense);\r\n}\r\nif ((erp->function == dasd_3990_erp_compound_path) &&\r\n(erp->status == DASD_CQR_NEED_ERP)) {\r\nerp = dasd_3990_erp_compound_code(erp, sense);\r\n}\r\nif ((erp->function == dasd_3990_erp_compound_code) &&\r\n(erp->status == DASD_CQR_NEED_ERP)) {\r\ndasd_3990_erp_compound_config(erp, sense);\r\n}\r\nif (erp->status == DASD_CQR_NEED_ERP)\r\nerp->status = DASD_CQR_FAILED;\r\nreturn erp;\r\n}\r\nvoid\r\ndasd_3990_erp_handle_sim(struct dasd_device *device, char *sense)\r\n{\r\nif ((sense[24] & DASD_SIM_MSG_TO_OP) || (sense[1] & 0x10)) {\r\ndev_err(&device->cdev->dev, "SIM - SRC: "\r\n"%02x%02x%02x%02x\n", sense[22],\r\nsense[23], sense[11], sense[12]);\r\n} else if (sense[24] & DASD_SIM_LOG) {\r\ndev_warn(&device->cdev->dev, "log SIM - SRC: "\r\n"%02x%02x%02x%02x\n", sense[22],\r\nsense[23], sense[11], sense[12]);\r\n}\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_inspect_32(struct dasd_ccw_req * erp, char *sense)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nerp->function = dasd_3990_erp_inspect_32;\r\nif ((sense[6] & DASD_SIM_SENSE) == DASD_SIM_SENSE)\r\ndasd_3990_erp_handle_sim(device, sense);\r\nif (sense[25] & DASD_SENSE_BIT_0) {\r\ndasd_3990_erp_compound_retry(erp, sense);\r\n} else {\r\nswitch (sense[25]) {\r\ncase 0x00:\r\nDBF_DEV_EVENT(DBF_DEBUG, device, "%s",\r\n"ERP called for successful request"\r\n" - just retry");\r\nbreak;\r\ncase 0x01:\r\ndev_err(&device->cdev->dev,\r\n"ERP failed for the DASD\n");\r\nerp = dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\r\nbreak;\r\ncase 0x02:\r\ncase 0x03:\r\nerp = dasd_3990_erp_int_req(erp);\r\nbreak;\r\ncase 0x0F:\r\ndev_err(&device->cdev->dev, "An error occurred in the "\r\n"DASD device driver, reason=%s\n", "08");\r\nerp = dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\r\nbreak;\r\ncase 0x10:\r\nerp = dasd_3990_erp_action_10_32(erp, sense);\r\nbreak;\r\ncase 0x15:\r\ndev_err(&device->cdev->dev,\r\n"An error occurred in the DASD device driver, "\r\n"reason=%s\n", "07");\r\nerp = dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\r\nbreak;\r\ncase 0x1B:\r\nerp = dasd_3990_erp_action_1B_32(erp, sense);\r\nbreak;\r\ncase 0x1C:\r\ndev_emerg(&device->cdev->dev,\r\n"Data recovered during retry with PCI "\r\n"fetch mode active\n");\r\npanic\r\n("Invalid data - No way to inform application "\r\n"about the possibly incorrect data");\r\nbreak;\r\ncase 0x1D:\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"A State change pending condition exists "\r\n"for the subsystem or device");\r\nerp = dasd_3990_erp_action_4(erp, sense);\r\nbreak;\r\ncase 0x1E:\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Busy condition exists "\r\n"for the subsystem or device");\r\nerp = dasd_3990_erp_action_4(erp, sense);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_control_check(struct dasd_ccw_req *erp)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nif (scsw_cstat(&erp->refers->irb.scsw) & (SCHN_STAT_INTF_CTRL_CHK\r\n| SCHN_STAT_CHN_CTRL_CHK)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"channel or interface control check");\r\nerp = dasd_3990_erp_action_4(erp, NULL);\r\n}\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_inspect(struct dasd_ccw_req *erp)\r\n{\r\nstruct dasd_ccw_req *erp_new = NULL;\r\nchar *sense;\r\nerp_new = dasd_3990_erp_inspect_alias(erp);\r\nif (erp_new)\r\nreturn erp_new;\r\nsense = dasd_get_sense(&erp->refers->irb);\r\nif (!sense)\r\nerp_new = dasd_3990_erp_control_check(erp);\r\nelse if (sense[27] & DASD_SENSE_BIT_0) {\r\nerp_new = dasd_3990_erp_inspect_24(erp, sense);\r\n} else {\r\nerp_new = dasd_3990_erp_inspect_32(erp, sense);\r\n}\r\nreturn erp_new;\r\n}\r\nstatic struct dasd_ccw_req *dasd_3990_erp_add_erp(struct dasd_ccw_req *cqr)\r\n{\r\nstruct dasd_device *device = cqr->startdev;\r\nstruct ccw1 *ccw;\r\nstruct dasd_ccw_req *erp;\r\nint cplength, datasize;\r\nstruct tcw *tcw;\r\nstruct tsb *tsb;\r\nif (cqr->cpmode == 1) {\r\ncplength = 0;\r\ndatasize = 64 + sizeof(struct tcw) + sizeof(struct tsb);\r\n} else {\r\ncplength = 2;\r\ndatasize = 0;\r\n}\r\nerp = dasd_alloc_erp_request((char *) &cqr->magic,\r\ncplength, datasize, device);\r\nif (IS_ERR(erp)) {\r\nif (cqr->retries <= 0) {\r\nDBF_DEV_EVENT(DBF_ERR, device, "%s",\r\n"Unable to allocate ERP request");\r\ncqr->status = DASD_CQR_FAILED;\r\ncqr->stopclk = get_clock ();\r\n} else {\r\nDBF_DEV_EVENT(DBF_ERR, device,\r\n"Unable to allocate ERP request "\r\n"(%i retries left)",\r\ncqr->retries);\r\ndasd_block_set_timer(device->block, (HZ << 3));\r\n}\r\nreturn erp;\r\n}\r\nccw = cqr->cpaddr;\r\nif (cqr->cpmode == 1) {\r\nerp->cpmode = 1;\r\nerp->cpaddr = PTR_ALIGN(erp->data, 64);\r\ntcw = erp->cpaddr;\r\ntsb = (struct tsb *) &tcw[1];\r\n*tcw = *((struct tcw *)cqr->cpaddr);\r\ntcw->tsb = (long)tsb;\r\n} else if (ccw->cmd_code == DASD_ECKD_CCW_PSF) {\r\nerp->cpaddr = cqr->cpaddr;\r\n} else {\r\nccw = erp->cpaddr;\r\nccw->cmd_code = CCW_CMD_NOOP;\r\nccw->flags = CCW_FLAG_CC;\r\nccw++;\r\nccw->cmd_code = CCW_CMD_TIC;\r\nccw->cda = (long)(cqr->cpaddr);\r\n}\r\nerp->flags = cqr->flags;\r\nerp->function = dasd_3990_erp_add_erp;\r\nerp->refers = cqr;\r\nerp->startdev = device;\r\nerp->memdev = device;\r\nerp->block = cqr->block;\r\nerp->magic = cqr->magic;\r\nerp->expires = cqr->expires;\r\nerp->retries = 256;\r\nerp->buildclk = get_clock();\r\nerp->status = DASD_CQR_FILLED;\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_additional_erp(struct dasd_ccw_req * cqr)\r\n{\r\nstruct dasd_ccw_req *erp = NULL;\r\nerp = dasd_3990_erp_add_erp(cqr);\r\nif (IS_ERR(erp))\r\nreturn erp;\r\nif (erp != cqr) {\r\nerp = dasd_3990_erp_inspect(erp);\r\n}\r\nreturn erp;\r\n}\r\nstatic int dasd_3990_erp_error_match(struct dasd_ccw_req *cqr1,\r\nstruct dasd_ccw_req *cqr2)\r\n{\r\nchar *sense1, *sense2;\r\nif (cqr1->startdev != cqr2->startdev)\r\nreturn 0;\r\nsense1 = dasd_get_sense(&cqr1->irb);\r\nsense2 = dasd_get_sense(&cqr2->irb);\r\nif (!sense1 != !sense2)\r\nreturn 0;\r\nif (!sense1 && !sense2) {\r\nif ((scsw_cstat(&cqr1->irb.scsw) & (SCHN_STAT_INTF_CTRL_CHK |\r\nSCHN_STAT_CHN_CTRL_CHK)) ==\r\n(scsw_cstat(&cqr2->irb.scsw) & (SCHN_STAT_INTF_CTRL_CHK |\r\nSCHN_STAT_CHN_CTRL_CHK)))\r\nreturn 1;\r\n}\r\nif (!(sense1 && sense2 &&\r\n(memcmp(sense1, sense2, 3) == 0) &&\r\n(sense1[27] == sense2[27]) &&\r\n(sense1[25] == sense2[25]))) {\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_in_erp(struct dasd_ccw_req *cqr)\r\n{\r\nstruct dasd_ccw_req *erp_head = cqr,\r\n*erp_match = NULL;\r\nint match = 0;\r\nif (cqr->refers == NULL) {\r\nreturn NULL;\r\n}\r\ndo {\r\nmatch = dasd_3990_erp_error_match(erp_head, cqr->refers);\r\nerp_match = cqr;\r\ncqr = cqr->refers;\r\n} while ((cqr->refers != NULL) && (!match));\r\nif (!match) {\r\nreturn NULL;\r\n}\r\nreturn erp_match;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_further_erp(struct dasd_ccw_req *erp)\r\n{\r\nstruct dasd_device *device = erp->startdev;\r\nchar *sense = dasd_get_sense(&erp->irb);\r\nif ((erp->function == dasd_3990_erp_bus_out) ||\r\n(erp->function == dasd_3990_erp_action_1) ||\r\n(erp->function == dasd_3990_erp_action_4)) {\r\nerp = dasd_3990_erp_action_1(erp);\r\n} else if (erp->function == dasd_3990_erp_action_1_sec) {\r\nerp = dasd_3990_erp_action_1_sec(erp);\r\n} else if (erp->function == dasd_3990_erp_action_5) {\r\nerp = dasd_3990_erp_action_1(erp);\r\nif (sense && !(sense[2] & DASD_SENSE_BIT_0)) {\r\nswitch (sense[25]) {\r\ncase 0x17:\r\ncase 0x57:{\r\nerp = dasd_3990_erp_DCTL(erp, 0x20);\r\nbreak;\r\n}\r\ncase 0x18:\r\ncase 0x58:{\r\nerp = dasd_3990_erp_DCTL(erp, 0x40);\r\nbreak;\r\n}\r\ncase 0x19:\r\ncase 0x59:{\r\nerp = dasd_3990_erp_DCTL(erp, 0x80);\r\nbreak;\r\n}\r\ndefault:\r\nDBF_DEV_EVENT(DBF_WARNING, device,\r\n"invalid subcommand modifier 0x%x "\r\n"for Diagnostic Control Command",\r\nsense[25]);\r\n}\r\n}\r\n} else if (sense &&\r\n((erp->function == dasd_3990_erp_compound_retry) ||\r\n(erp->function == dasd_3990_erp_compound_path) ||\r\n(erp->function == dasd_3990_erp_compound_code) ||\r\n(erp->function == dasd_3990_erp_compound_config))) {\r\nerp = dasd_3990_erp_compound(erp, sense);\r\n} else {\r\ndev_err(&device->cdev->dev,\r\n"ERP %p has run out of retries and failed\n", erp);\r\nerp->status = DASD_CQR_FAILED;\r\n}\r\nreturn erp;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_3990_erp_handle_match_erp(struct dasd_ccw_req *erp_head,\r\nstruct dasd_ccw_req *erp)\r\n{\r\nstruct dasd_device *device = erp_head->startdev;\r\nstruct dasd_ccw_req *erp_done = erp_head;\r\nstruct dasd_ccw_req *erp_free = NULL;\r\nwhile (erp_done != erp) {\r\nif (erp_done == NULL)\r\npanic(PRINTK_HEADER "Programming error in ERP! The "\r\n"original request was lost\n");\r\nlist_del(&erp_done->blocklist);\r\nerp_free = erp_done;\r\nerp_done = erp_done->refers;\r\ndasd_free_erp_request(erp_free, erp_free->memdev);\r\n}\r\nif (erp->retries > 0) {\r\nchar *sense = dasd_get_sense(&erp->refers->irb);\r\nif (sense && erp->function == dasd_3990_erp_action_4) {\r\nerp = dasd_3990_erp_action_4(erp, sense);\r\n} else if (sense &&\r\nerp->function == dasd_3990_erp_action_1B_32) {\r\nerp = dasd_3990_update_1B(erp, sense);\r\n} else if (sense && erp->function == dasd_3990_erp_int_req) {\r\nerp = dasd_3990_erp_int_req(erp);\r\n} else {\r\nDBF_DEV_EVENT(DBF_DEBUG, device,\r\n"%i retries left for erp %p",\r\nerp->retries, erp);\r\nerp->status = DASD_CQR_FILLED;\r\n}\r\n} else {\r\nerp = dasd_3990_erp_further_erp(erp);\r\n}\r\nreturn erp;\r\n}\r\nstruct dasd_ccw_req *\r\ndasd_3990_erp_action(struct dasd_ccw_req * cqr)\r\n{\r\nstruct dasd_ccw_req *erp = NULL;\r\nstruct dasd_device *device = cqr->startdev;\r\nstruct dasd_ccw_req *temp_erp = NULL;\r\nif (device->features & DASD_FEATURE_ERPLOG) {\r\ndev_err(&device->cdev->dev,\r\n"ERP chain at BEGINNING of ERP-ACTION\n");\r\nfor (temp_erp = cqr;\r\ntemp_erp != NULL; temp_erp = temp_erp->refers) {\r\ndev_err(&device->cdev->dev,\r\n"ERP %p (%02x) refers to %p\n",\r\ntemp_erp, temp_erp->status,\r\ntemp_erp->refers);\r\n}\r\n}\r\nif ((scsw_cstat(&cqr->irb.scsw) == 0x00) &&\r\n(scsw_dstat(&cqr->irb.scsw) ==\r\n(DEV_STAT_CHN_END | DEV_STAT_DEV_END))) {\r\nDBF_DEV_EVENT(DBF_DEBUG, device,\r\n"ERP called for successful request %p"\r\n" - NO ERP necessary", cqr);\r\ncqr->status = DASD_CQR_DONE;\r\nreturn cqr;\r\n}\r\nerp = dasd_3990_erp_in_erp(cqr);\r\nif (erp == NULL) {\r\nerp = dasd_3990_erp_additional_erp(cqr);\r\nif (IS_ERR(erp))\r\nreturn erp;\r\n} else {\r\nerp = dasd_3990_erp_handle_match_erp(cqr, erp);\r\n}\r\nif (device->features & DASD_FEATURE_ERPLOG) {\r\ndev_err(&device->cdev->dev,\r\n"ERP chain at END of ERP-ACTION\n");\r\nfor (temp_erp = erp;\r\ntemp_erp != NULL; temp_erp = temp_erp->refers) {\r\ndev_err(&device->cdev->dev,\r\n"ERP %p (%02x) refers to %p\n",\r\ntemp_erp, temp_erp->status,\r\ntemp_erp->refers);\r\n}\r\n}\r\nif (list_empty(&erp->blocklist)) {\r\ncqr->status = DASD_CQR_IN_ERP;\r\nlist_add_tail(&erp->blocklist, &cqr->blocklist);\r\n}\r\nreturn erp;\r\n}
