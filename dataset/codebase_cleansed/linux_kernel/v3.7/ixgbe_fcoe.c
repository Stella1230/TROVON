static inline void ixgbe_fcoe_clear_ddp(struct ixgbe_fcoe_ddp *ddp)\r\n{\r\nddp->len = 0;\r\nddp->err = 1;\r\nddp->udl = NULL;\r\nddp->udp = 0UL;\r\nddp->sgl = NULL;\r\nddp->sgc = 0;\r\n}\r\nint ixgbe_fcoe_ddp_put(struct net_device *netdev, u16 xid)\r\n{\r\nint len = 0;\r\nstruct ixgbe_fcoe *fcoe;\r\nstruct ixgbe_adapter *adapter;\r\nstruct ixgbe_fcoe_ddp *ddp;\r\nu32 fcbuff;\r\nif (!netdev)\r\ngoto out_ddp_put;\r\nif (xid >= IXGBE_FCOE_DDP_MAX)\r\ngoto out_ddp_put;\r\nadapter = netdev_priv(netdev);\r\nfcoe = &adapter->fcoe;\r\nddp = &fcoe->ddp[xid];\r\nif (!ddp->udl)\r\ngoto out_ddp_put;\r\nlen = ddp->len;\r\nif (ddp->err) {\r\nspin_lock_bh(&fcoe->lock);\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_FCFLT, 0);\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_FCFLTRW,\r\n(xid | IXGBE_FCFLTRW_WE));\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_FCBUFF, 0);\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_FCDMARW,\r\n(xid | IXGBE_FCDMARW_WE));\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_FCDMARW,\r\n(xid | IXGBE_FCDMARW_RE));\r\nfcbuff = IXGBE_READ_REG(&adapter->hw, IXGBE_FCBUFF);\r\nspin_unlock_bh(&fcoe->lock);\r\nif (fcbuff & IXGBE_FCBUFF_VALID)\r\nudelay(100);\r\n}\r\nif (ddp->sgl)\r\ndma_unmap_sg(&adapter->pdev->dev, ddp->sgl, ddp->sgc,\r\nDMA_FROM_DEVICE);\r\nif (ddp->pool) {\r\ndma_pool_free(ddp->pool, ddp->udl, ddp->udp);\r\nddp->pool = NULL;\r\n}\r\nixgbe_fcoe_clear_ddp(ddp);\r\nout_ddp_put:\r\nreturn len;\r\n}\r\nstatic int ixgbe_fcoe_ddp_setup(struct net_device *netdev, u16 xid,\r\nstruct scatterlist *sgl, unsigned int sgc,\r\nint target_mode)\r\n{\r\nstruct ixgbe_adapter *adapter;\r\nstruct ixgbe_hw *hw;\r\nstruct ixgbe_fcoe *fcoe;\r\nstruct ixgbe_fcoe_ddp *ddp;\r\nstruct ixgbe_fcoe_ddp_pool *ddp_pool;\r\nstruct scatterlist *sg;\r\nunsigned int i, j, dmacount;\r\nunsigned int len;\r\nstatic const unsigned int bufflen = IXGBE_FCBUFF_MIN;\r\nunsigned int firstoff = 0;\r\nunsigned int lastsize;\r\nunsigned int thisoff = 0;\r\nunsigned int thislen = 0;\r\nu32 fcbuff, fcdmarw, fcfltrw, fcrxctl;\r\ndma_addr_t addr = 0;\r\nif (!netdev || !sgl)\r\nreturn 0;\r\nadapter = netdev_priv(netdev);\r\nif (xid >= IXGBE_FCOE_DDP_MAX) {\r\ne_warn(drv, "xid=0x%x out-of-range\n", xid);\r\nreturn 0;\r\n}\r\nif (test_bit(__IXGBE_DOWN, &adapter->state) ||\r\ntest_bit(__IXGBE_RESETTING, &adapter->state))\r\nreturn 0;\r\nfcoe = &adapter->fcoe;\r\nddp = &fcoe->ddp[xid];\r\nif (ddp->sgl) {\r\ne_err(drv, "xid 0x%x w/ non-null sgl=%p nents=%d\n",\r\nxid, ddp->sgl, ddp->sgc);\r\nreturn 0;\r\n}\r\nixgbe_fcoe_clear_ddp(ddp);\r\nif (!fcoe->ddp_pool) {\r\ne_warn(drv, "No ddp_pool resources allocated\n");\r\nreturn 0;\r\n}\r\nddp_pool = per_cpu_ptr(fcoe->ddp_pool, get_cpu());\r\nif (!ddp_pool->pool) {\r\ne_warn(drv, "xid=0x%x no ddp pool for fcoe\n", xid);\r\ngoto out_noddp;\r\n}\r\ndmacount = dma_map_sg(&adapter->pdev->dev, sgl, sgc, DMA_FROM_DEVICE);\r\nif (dmacount == 0) {\r\ne_err(drv, "xid 0x%x DMA map error\n", xid);\r\ngoto out_noddp;\r\n}\r\nddp->udl = dma_pool_alloc(ddp_pool->pool, GFP_ATOMIC, &ddp->udp);\r\nif (!ddp->udl) {\r\ne_err(drv, "failed allocated ddp context\n");\r\ngoto out_noddp_unmap;\r\n}\r\nddp->pool = ddp_pool->pool;\r\nddp->sgl = sgl;\r\nddp->sgc = sgc;\r\nj = 0;\r\nfor_each_sg(sgl, sg, dmacount, i) {\r\naddr = sg_dma_address(sg);\r\nlen = sg_dma_len(sg);\r\nwhile (len) {\r\nif (j >= IXGBE_BUFFCNT_MAX) {\r\nddp_pool->noddp++;\r\ngoto out_noddp_free;\r\n}\r\nthisoff = addr & ((dma_addr_t)bufflen - 1);\r\nthislen = min((bufflen - thisoff), len);\r\nif ((j != 0) && (thisoff))\r\ngoto out_noddp_free;\r\nif (((i != (dmacount - 1)) || (thislen != len))\r\n&& ((thislen + thisoff) != bufflen))\r\ngoto out_noddp_free;\r\nddp->udl[j] = (u64)(addr - thisoff);\r\nif (j == 0)\r\nfirstoff = thisoff;\r\nlen -= thislen;\r\naddr += thislen;\r\nj++;\r\n}\r\n}\r\nlastsize = thisoff + thislen;\r\nif (lastsize == bufflen) {\r\nif (j >= IXGBE_BUFFCNT_MAX) {\r\nddp_pool->noddp_ext_buff++;\r\ngoto out_noddp_free;\r\n}\r\nddp->udl[j] = (u64)(fcoe->extra_ddp_buffer_dma);\r\nj++;\r\nlastsize = 1;\r\n}\r\nput_cpu();\r\nfcbuff = (IXGBE_FCBUFF_4KB << IXGBE_FCBUFF_BUFFSIZE_SHIFT);\r\nfcbuff |= ((j & 0xff) << IXGBE_FCBUFF_BUFFCNT_SHIFT);\r\nfcbuff |= (firstoff << IXGBE_FCBUFF_OFFSET_SHIFT);\r\nif (target_mode)\r\nfcbuff |= (IXGBE_FCBUFF_WRCONTX);\r\nfcbuff |= (IXGBE_FCBUFF_VALID);\r\nfcdmarw = xid;\r\nfcdmarw |= IXGBE_FCDMARW_WE;\r\nfcdmarw |= (lastsize << IXGBE_FCDMARW_LASTSIZE_SHIFT);\r\nfcfltrw = xid;\r\nfcfltrw |= IXGBE_FCFLTRW_WE;\r\nhw = &adapter->hw;\r\nspin_lock_bh(&fcoe->lock);\r\nif (target_mode && !test_bit(__IXGBE_FCOE_TARGET, &fcoe->mode)) {\r\nset_bit(__IXGBE_FCOE_TARGET, &fcoe->mode);\r\nfcrxctl = IXGBE_READ_REG(hw, IXGBE_FCRXCTRL);\r\nfcrxctl |= IXGBE_FCRXCTRL_LASTSEQH;\r\nIXGBE_WRITE_REG(hw, IXGBE_FCRXCTRL, fcrxctl);\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_FCPTRL, ddp->udp & DMA_BIT_MASK(32));\r\nIXGBE_WRITE_REG(hw, IXGBE_FCPTRH, (u64)ddp->udp >> 32);\r\nIXGBE_WRITE_REG(hw, IXGBE_FCBUFF, fcbuff);\r\nIXGBE_WRITE_REG(hw, IXGBE_FCDMARW, fcdmarw);\r\nIXGBE_WRITE_REG(hw, IXGBE_FCPARAM, 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_FCFLT, IXGBE_FCFLT_VALID);\r\nIXGBE_WRITE_REG(hw, IXGBE_FCFLTRW, fcfltrw);\r\nspin_unlock_bh(&fcoe->lock);\r\nreturn 1;\r\nout_noddp_free:\r\ndma_pool_free(ddp->pool, ddp->udl, ddp->udp);\r\nixgbe_fcoe_clear_ddp(ddp);\r\nout_noddp_unmap:\r\ndma_unmap_sg(&adapter->pdev->dev, sgl, sgc, DMA_FROM_DEVICE);\r\nout_noddp:\r\nput_cpu();\r\nreturn 0;\r\n}\r\nint ixgbe_fcoe_ddp_get(struct net_device *netdev, u16 xid,\r\nstruct scatterlist *sgl, unsigned int sgc)\r\n{\r\nreturn ixgbe_fcoe_ddp_setup(netdev, xid, sgl, sgc, 0);\r\n}\r\nint ixgbe_fcoe_ddp_target(struct net_device *netdev, u16 xid,\r\nstruct scatterlist *sgl, unsigned int sgc)\r\n{\r\nreturn ixgbe_fcoe_ddp_setup(netdev, xid, sgl, sgc, 1);\r\n}\r\nint ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter,\r\nunion ixgbe_adv_rx_desc *rx_desc,\r\nstruct sk_buff *skb)\r\n{\r\nint rc = -EINVAL;\r\nstruct ixgbe_fcoe *fcoe;\r\nstruct ixgbe_fcoe_ddp *ddp;\r\nstruct fc_frame_header *fh;\r\nstruct fcoe_crc_eof *crc;\r\n__le32 fcerr = ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_ERR_FCERR);\r\n__le32 ddp_err;\r\nu32 fctl;\r\nu16 xid;\r\nif (fcerr == cpu_to_le32(IXGBE_FCERR_BADCRC))\r\nskb->ip_summed = CHECKSUM_NONE;\r\nelse\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nif (eth_hdr(skb)->h_proto == htons(ETH_P_8021Q))\r\nfh = (struct fc_frame_header *)(skb->data +\r\nsizeof(struct vlan_hdr) + sizeof(struct fcoe_hdr));\r\nelse\r\nfh = (struct fc_frame_header *)(skb->data +\r\nsizeof(struct fcoe_hdr));\r\nfctl = ntoh24(fh->fh_f_ctl);\r\nif (fctl & FC_FC_EX_CTX)\r\nxid = be16_to_cpu(fh->fh_ox_id);\r\nelse\r\nxid = be16_to_cpu(fh->fh_rx_id);\r\nif (xid >= IXGBE_FCOE_DDP_MAX)\r\ngoto ddp_out;\r\nfcoe = &adapter->fcoe;\r\nddp = &fcoe->ddp[xid];\r\nif (!ddp->udl)\r\ngoto ddp_out;\r\nddp_err = ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_ERR_FCEOFE |\r\nIXGBE_RXDADV_ERR_FCERR);\r\nif (ddp_err)\r\ngoto ddp_out;\r\nswitch (ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_STAT_FCSTAT)) {\r\ncase __constant_cpu_to_le32(IXGBE_RXDADV_STAT_FCSTAT_DDP):\r\nddp->len = le32_to_cpu(rx_desc->wb.lower.hi_dword.rss);\r\nrc = 0;\r\nbreak;\r\ncase __constant_cpu_to_le32(IXGBE_RXDADV_STAT_FCSTAT_FCPRSP):\r\ndma_unmap_sg(&adapter->pdev->dev, ddp->sgl,\r\nddp->sgc, DMA_FROM_DEVICE);\r\nddp->err = ddp_err;\r\nddp->sgl = NULL;\r\nddp->sgc = 0;\r\ncase __constant_cpu_to_le32(IXGBE_RXDADV_STAT_FCSTAT_NODDP):\r\nddp->len = le32_to_cpu(rx_desc->wb.lower.hi_dword.rss);\r\nif (ddp->len)\r\nrc = ddp->len;\r\nbreak;\r\ncase __constant_cpu_to_le32(IXGBE_RXDADV_STAT_FCSTAT_NOMTCH):\r\ndefault:\r\nbreak;\r\n}\r\nif ((fh->fh_r_ctl == FC_RCTL_DD_SOL_DATA) &&\r\n(fctl & FC_FC_END_SEQ)) {\r\nskb_linearize(skb);\r\ncrc = (struct fcoe_crc_eof *)skb_put(skb, sizeof(*crc));\r\ncrc->fcoe_eof = FC_EOF_T;\r\n}\r\nddp_out:\r\nreturn rc;\r\n}\r\nint ixgbe_fso(struct ixgbe_ring *tx_ring,\r\nstruct ixgbe_tx_buffer *first,\r\nu8 *hdr_len)\r\n{\r\nstruct sk_buff *skb = first->skb;\r\nstruct fc_frame_header *fh;\r\nu32 vlan_macip_lens;\r\nu32 fcoe_sof_eof = 0;\r\nu32 mss_l4len_idx;\r\nu8 sof, eof;\r\nif (skb_is_gso(skb) && (skb_shinfo(skb)->gso_type != SKB_GSO_FCOE)) {\r\ndev_err(tx_ring->dev, "Wrong gso type %d:expecting SKB_GSO_FCOE\n",\r\nskb_shinfo(skb)->gso_type);\r\nreturn -EINVAL;\r\n}\r\nskb_set_network_header(skb, skb->mac_len);\r\nskb_set_transport_header(skb, skb->mac_len +\r\nsizeof(struct fcoe_hdr));\r\nsof = ((struct fcoe_hdr *)skb_network_header(skb))->fcoe_sof;\r\nswitch (sof) {\r\ncase FC_SOF_I2:\r\nfcoe_sof_eof = IXGBE_ADVTXD_FCOEF_ORIS;\r\nbreak;\r\ncase FC_SOF_I3:\r\nfcoe_sof_eof = IXGBE_ADVTXD_FCOEF_SOF |\r\nIXGBE_ADVTXD_FCOEF_ORIS;\r\nbreak;\r\ncase FC_SOF_N2:\r\nbreak;\r\ncase FC_SOF_N3:\r\nfcoe_sof_eof = IXGBE_ADVTXD_FCOEF_SOF;\r\nbreak;\r\ndefault:\r\ndev_warn(tx_ring->dev, "unknown sof = 0x%x\n", sof);\r\nreturn -EINVAL;\r\n}\r\nskb_copy_bits(skb, skb->len - 4, &eof, 1);\r\nswitch (eof) {\r\ncase FC_EOF_N:\r\nfcoe_sof_eof |= IXGBE_ADVTXD_FCOEF_EOF_N;\r\nbreak;\r\ncase FC_EOF_T:\r\nif (skb_is_gso(skb))\r\nfcoe_sof_eof |= IXGBE_ADVTXD_FCOEF_EOF_N |\r\nIXGBE_ADVTXD_FCOEF_ORIE;\r\nelse\r\nfcoe_sof_eof |= IXGBE_ADVTXD_FCOEF_EOF_T;\r\nbreak;\r\ncase FC_EOF_NI:\r\nfcoe_sof_eof |= IXGBE_ADVTXD_FCOEF_EOF_NI;\r\nbreak;\r\ncase FC_EOF_A:\r\nfcoe_sof_eof |= IXGBE_ADVTXD_FCOEF_EOF_A;\r\nbreak;\r\ndefault:\r\ndev_warn(tx_ring->dev, "unknown eof = 0x%x\n", eof);\r\nreturn -EINVAL;\r\n}\r\nfh = (struct fc_frame_header *)skb_transport_header(skb);\r\nif (fh->fh_f_ctl[2] & FC_FC_REL_OFF)\r\nfcoe_sof_eof |= IXGBE_ADVTXD_FCOEF_PARINC;\r\n*hdr_len = sizeof(struct fcoe_crc_eof);\r\nif (skb_is_gso(skb)) {\r\n*hdr_len += skb_transport_offset(skb) +\r\nsizeof(struct fc_frame_header);\r\nfirst->gso_segs = DIV_ROUND_UP(skb->len - *hdr_len,\r\nskb_shinfo(skb)->gso_size);\r\nfirst->bytecount += (first->gso_segs - 1) * *hdr_len;\r\nfirst->tx_flags |= IXGBE_TX_FLAGS_FSO;\r\n}\r\nfirst->tx_flags |= IXGBE_TX_FLAGS_FCOE;\r\nmss_l4len_idx = skb_shinfo(skb)->gso_size << IXGBE_ADVTXD_MSS_SHIFT;\r\nmss_l4len_idx |= 1 << IXGBE_ADVTXD_IDX_SHIFT;\r\nvlan_macip_lens = skb_transport_offset(skb) +\r\nsizeof(struct fc_frame_header);\r\nvlan_macip_lens |= (skb_transport_offset(skb) - 4)\r\n<< IXGBE_ADVTXD_MACLEN_SHIFT;\r\nvlan_macip_lens |= first->tx_flags & IXGBE_TX_FLAGS_VLAN_MASK;\r\nixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, fcoe_sof_eof,\r\nIXGBE_ADVTXT_TUCMD_FCOE, mss_l4len_idx);\r\nreturn 0;\r\n}\r\nstatic void ixgbe_fcoe_dma_pool_free(struct ixgbe_fcoe *fcoe, unsigned int cpu)\r\n{\r\nstruct ixgbe_fcoe_ddp_pool *ddp_pool;\r\nddp_pool = per_cpu_ptr(fcoe->ddp_pool, cpu);\r\nif (ddp_pool->pool)\r\ndma_pool_destroy(ddp_pool->pool);\r\nddp_pool->pool = NULL;\r\n}\r\nstatic int ixgbe_fcoe_dma_pool_alloc(struct ixgbe_fcoe *fcoe,\r\nstruct device *dev,\r\nunsigned int cpu)\r\n{\r\nstruct ixgbe_fcoe_ddp_pool *ddp_pool;\r\nstruct dma_pool *pool;\r\nchar pool_name[32];\r\nsnprintf(pool_name, 32, "ixgbe_fcoe_ddp_%d", cpu);\r\npool = dma_pool_create(pool_name, dev, IXGBE_FCPTR_MAX,\r\nIXGBE_FCPTR_ALIGN, PAGE_SIZE);\r\nif (!pool)\r\nreturn -ENOMEM;\r\nddp_pool = per_cpu_ptr(fcoe->ddp_pool, cpu);\r\nddp_pool->pool = pool;\r\nddp_pool->noddp = 0;\r\nddp_pool->noddp_ext_buff = 0;\r\nreturn 0;\r\n}\r\nvoid ixgbe_configure_fcoe(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_ring_feature *fcoe = &adapter->ring_feature[RING_F_FCOE];\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint i, fcoe_q, fcoe_i;\r\nu32 etqf;\r\nif (!(adapter->netdev->features & NETIF_F_FCOE_CRC))\r\nreturn;\r\netqf = ETH_P_FCOE | IXGBE_ETQF_FCOE | IXGBE_ETQF_FILTER_EN;\r\nif (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {\r\netqf |= IXGBE_ETQF_POOL_ENABLE;\r\netqf |= VMDQ_P(0) << IXGBE_ETQF_POOL_SHIFT;\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_FCOE), etqf);\r\nIXGBE_WRITE_REG(hw, IXGBE_ETQS(IXGBE_ETQF_FILTER_FCOE), 0);\r\nif (!(adapter->flags & IXGBE_FLAG_FCOE_ENABLED))\r\nreturn;\r\nfor (i = 0; i < IXGBE_FCRETA_SIZE; i++) {\r\nfcoe_i = fcoe->offset + (i % fcoe->indices);\r\nfcoe_i &= IXGBE_FCRETA_ENTRY_MASK;\r\nfcoe_q = adapter->rx_ring[fcoe_i]->reg_idx;\r\nIXGBE_WRITE_REG(hw, IXGBE_FCRETA(i), fcoe_q);\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_FCRECTL, IXGBE_FCRECTL_ENA);\r\netqf = ETH_P_FIP | IXGBE_ETQF_FILTER_EN;\r\nif (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {\r\netqf |= IXGBE_ETQF_POOL_ENABLE;\r\netqf |= VMDQ_P(0) << IXGBE_ETQF_POOL_SHIFT;\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_FIP), etqf);\r\nfcoe_q = adapter->rx_ring[fcoe->offset]->reg_idx;\r\nIXGBE_WRITE_REG(hw, IXGBE_ETQS(IXGBE_ETQF_FILTER_FIP),\r\nIXGBE_ETQS_QUEUE_EN |\r\n(fcoe_q << IXGBE_ETQS_RX_QUEUE_SHIFT));\r\nIXGBE_WRITE_REG(hw, IXGBE_FCRXCTRL,\r\nIXGBE_FCRXCTRL_FCCRCBO |\r\n(FC_FCOE_VER << IXGBE_FCRXCTRL_FCOEVER_SHIFT));\r\n}\r\nvoid ixgbe_free_fcoe_ddp_resources(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_fcoe *fcoe = &adapter->fcoe;\r\nint cpu, i;\r\nif (!fcoe->ddp_pool)\r\nreturn;\r\nfor (i = 0; i < IXGBE_FCOE_DDP_MAX; i++)\r\nixgbe_fcoe_ddp_put(adapter->netdev, i);\r\nfor_each_possible_cpu(cpu)\r\nixgbe_fcoe_dma_pool_free(fcoe, cpu);\r\ndma_unmap_single(&adapter->pdev->dev,\r\nfcoe->extra_ddp_buffer_dma,\r\nIXGBE_FCBUFF_MIN,\r\nDMA_FROM_DEVICE);\r\nkfree(fcoe->extra_ddp_buffer);\r\nfcoe->extra_ddp_buffer = NULL;\r\nfcoe->extra_ddp_buffer_dma = 0;\r\n}\r\nint ixgbe_setup_fcoe_ddp_resources(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_fcoe *fcoe = &adapter->fcoe;\r\nstruct device *dev = &adapter->pdev->dev;\r\nvoid *buffer;\r\ndma_addr_t dma;\r\nunsigned int cpu;\r\nif (!fcoe->ddp_pool)\r\nreturn 0;\r\nbuffer = kmalloc(IXGBE_FCBUFF_MIN, GFP_ATOMIC);\r\nif (!buffer) {\r\ne_err(drv, "failed to allocate extra DDP buffer\n");\r\nreturn -ENOMEM;\r\n}\r\ndma = dma_map_single(dev, buffer, IXGBE_FCBUFF_MIN, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(dev, dma)) {\r\ne_err(drv, "failed to map extra DDP buffer\n");\r\nkfree(buffer);\r\nreturn -ENOMEM;\r\n}\r\nfcoe->extra_ddp_buffer = buffer;\r\nfcoe->extra_ddp_buffer_dma = dma;\r\nfor_each_possible_cpu(cpu) {\r\nint err = ixgbe_fcoe_dma_pool_alloc(fcoe, dev, cpu);\r\nif (!err)\r\ncontinue;\r\ne_err(drv, "failed to alloc DDP pool on cpu:%d\n", cpu);\r\nixgbe_free_fcoe_ddp_resources(adapter);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixgbe_fcoe_ddp_enable(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_fcoe *fcoe = &adapter->fcoe;\r\nif (!(adapter->flags & IXGBE_FLAG_FCOE_CAPABLE))\r\nreturn -EINVAL;\r\nfcoe->ddp_pool = alloc_percpu(struct ixgbe_fcoe_ddp_pool);\r\nif (!fcoe->ddp_pool) {\r\ne_err(drv, "failed to allocate percpu DDP resources\n");\r\nreturn -ENOMEM;\r\n}\r\nadapter->netdev->fcoe_ddp_xid = IXGBE_FCOE_DDP_MAX - 1;\r\nreturn 0;\r\n}\r\nstatic void ixgbe_fcoe_ddp_disable(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_fcoe *fcoe = &adapter->fcoe;\r\nadapter->netdev->fcoe_ddp_xid = 0;\r\nif (!fcoe->ddp_pool)\r\nreturn;\r\nfree_percpu(fcoe->ddp_pool);\r\nfcoe->ddp_pool = NULL;\r\n}\r\nint ixgbe_fcoe_enable(struct net_device *netdev)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_fcoe *fcoe = &adapter->fcoe;\r\natomic_inc(&fcoe->refcnt);\r\nif (!(adapter->flags & IXGBE_FLAG_FCOE_CAPABLE))\r\nreturn -EINVAL;\r\nif (adapter->flags & IXGBE_FLAG_FCOE_ENABLED)\r\nreturn -EINVAL;\r\ne_info(drv, "Enabling FCoE offload features.\n");\r\nif (netif_running(netdev))\r\nnetdev->netdev_ops->ndo_stop(netdev);\r\nixgbe_fcoe_ddp_enable(adapter);\r\nadapter->flags |= IXGBE_FLAG_FCOE_ENABLED;\r\nnetdev->features |= NETIF_F_FCOE_MTU;\r\nnetdev_features_change(netdev);\r\nixgbe_clear_interrupt_scheme(adapter);\r\nixgbe_init_interrupt_scheme(adapter);\r\nif (netif_running(netdev))\r\nnetdev->netdev_ops->ndo_open(netdev);\r\nreturn 0;\r\n}\r\nint ixgbe_fcoe_disable(struct net_device *netdev)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nif (!atomic_dec_and_test(&adapter->fcoe.refcnt))\r\nreturn -EINVAL;\r\nif (!(adapter->flags & IXGBE_FLAG_FCOE_ENABLED))\r\nreturn -EINVAL;\r\ne_info(drv, "Disabling FCoE offload features.\n");\r\nif (netif_running(netdev))\r\nnetdev->netdev_ops->ndo_stop(netdev);\r\nixgbe_fcoe_ddp_disable(adapter);\r\nadapter->flags &= ~IXGBE_FLAG_FCOE_ENABLED;\r\nnetdev->features &= ~NETIF_F_FCOE_MTU;\r\nnetdev_features_change(netdev);\r\nixgbe_clear_interrupt_scheme(adapter);\r\nixgbe_init_interrupt_scheme(adapter);\r\nif (netif_running(netdev))\r\nnetdev->netdev_ops->ndo_open(netdev);\r\nreturn 0;\r\n}\r\nint ixgbe_fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type)\r\n{\r\nint rc = -EINVAL;\r\nu16 prefix = 0xffff;\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_mac_info *mac = &adapter->hw.mac;\r\nswitch (type) {\r\ncase NETDEV_FCOE_WWNN:\r\nprefix = mac->wwnn_prefix;\r\nbreak;\r\ncase NETDEV_FCOE_WWPN:\r\nprefix = mac->wwpn_prefix;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif ((prefix != 0xffff) &&\r\nis_valid_ether_addr(mac->san_addr)) {\r\n*wwn = ((u64) prefix << 48) |\r\n((u64) mac->san_addr[0] << 40) |\r\n((u64) mac->san_addr[1] << 32) |\r\n((u64) mac->san_addr[2] << 24) |\r\n((u64) mac->san_addr[3] << 16) |\r\n((u64) mac->san_addr[4] << 8) |\r\n((u64) mac->san_addr[5]);\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nint ixgbe_fcoe_get_hbainfo(struct net_device *netdev,\r\nstruct netdev_fcoe_hbainfo *info)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint i, pos;\r\nu8 buf[8];\r\nif (!info)\r\nreturn -EINVAL;\r\nif (hw->mac.type != ixgbe_mac_82599EB &&\r\nhw->mac.type != ixgbe_mac_X540)\r\nreturn -EINVAL;\r\nsnprintf(info->manufacturer, sizeof(info->manufacturer),\r\n"Intel Corporation");\r\npos = pci_find_ext_capability(adapter->pdev, PCI_EXT_CAP_ID_DSN);\r\nif (pos) {\r\npos += 4;\r\nfor (i = 0; i < 8; i++)\r\npci_read_config_byte(adapter->pdev, pos + i, &buf[i]);\r\nsnprintf(info->serial_number, sizeof(info->serial_number),\r\n"%02X%02X%02X%02X%02X%02X%02X%02X",\r\nbuf[7], buf[6], buf[5], buf[4],\r\nbuf[3], buf[2], buf[1], buf[0]);\r\n} else\r\nsnprintf(info->serial_number, sizeof(info->serial_number),\r\n"Unknown");\r\nsnprintf(info->hardware_version,\r\nsizeof(info->hardware_version),\r\n"Rev %d", hw->revision_id);\r\nsnprintf(info->driver_version,\r\nsizeof(info->driver_version),\r\n"%s v%s",\r\nixgbe_driver_name,\r\nixgbe_driver_version);\r\nsnprintf(info->firmware_version,\r\nsizeof(info->firmware_version),\r\n"0x%08x",\r\n(adapter->eeprom_verh << 16) |\r\nadapter->eeprom_verl);\r\nif (hw->mac.type == ixgbe_mac_82599EB) {\r\nsnprintf(info->model,\r\nsizeof(info->model),\r\n"Intel 82599");\r\n} else {\r\nsnprintf(info->model,\r\nsizeof(info->model),\r\n"Intel X540");\r\n}\r\nsnprintf(info->model_description,\r\nsizeof(info->model_description),\r\n"%s",\r\nixgbe_default_device_descr);\r\nreturn 0;\r\n}\r\nu8 ixgbe_fcoe_get_tc(struct ixgbe_adapter *adapter)\r\n{\r\n#ifdef CONFIG_IXGBE_DCB\r\nreturn netdev_get_prio_tc_map(adapter->netdev, adapter->fcoe.up);\r\n#else\r\nreturn 0;\r\n#endif\r\n}
