static inline int wait_timeout(struct i2c_pnx_algo_data *data)\r\n{\r\nlong timeout = data->timeout;\r\nwhile (timeout > 0 &&\r\n(ioread32(I2C_REG_STS(data)) & mstatus_active)) {\r\nmdelay(1);\r\ntimeout--;\r\n}\r\nreturn (timeout <= 0);\r\n}\r\nstatic inline int wait_reset(struct i2c_pnx_algo_data *data)\r\n{\r\nlong timeout = data->timeout;\r\nwhile (timeout > 0 &&\r\n(ioread32(I2C_REG_CTL(data)) & mcntrl_reset)) {\r\nmdelay(1);\r\ntimeout--;\r\n}\r\nreturn (timeout <= 0);\r\n}\r\nstatic inline void i2c_pnx_arm_timer(struct i2c_pnx_algo_data *alg_data)\r\n{\r\nstruct timer_list *timer = &alg_data->mif.timer;\r\nunsigned long expires = msecs_to_jiffies(alg_data->timeout);\r\nif (expires <= 1)\r\nexpires = 2;\r\ndel_timer_sync(timer);\r\ndev_dbg(&alg_data->adapter.dev, "Timer armed at %lu plus %lu jiffies.\n",\r\njiffies, expires);\r\ntimer->expires = jiffies + expires;\r\ntimer->data = (unsigned long)alg_data;\r\nadd_timer(timer);\r\n}\r\nstatic int i2c_pnx_start(unsigned char slave_addr,\r\nstruct i2c_pnx_algo_data *alg_data)\r\n{\r\ndev_dbg(&alg_data->adapter.dev, "%s(): addr 0x%x mode %d\n", __func__,\r\nslave_addr, alg_data->mif.mode);\r\nif (slave_addr & ~0x7f) {\r\ndev_err(&alg_data->adapter.dev,\r\n"%s: Invalid slave address %x. Only 7-bit addresses are supported\n",\r\nalg_data->adapter.name, slave_addr);\r\nreturn -EINVAL;\r\n}\r\nif (wait_timeout(alg_data)) {\r\ndev_err(&alg_data->adapter.dev,\r\n"%s: Bus busy. Slave addr = %02x, cntrl = %x, stat = %x\n",\r\nalg_data->adapter.name, slave_addr,\r\nioread32(I2C_REG_CTL(alg_data)),\r\nioread32(I2C_REG_STS(alg_data)));\r\nreturn -EBUSY;\r\n} else if (ioread32(I2C_REG_STS(alg_data)) & mstatus_afi) {\r\ndev_err(&alg_data->adapter.dev,\r\n"%s: Arbitration failure. Slave addr = %02x\n",\r\nalg_data->adapter.name, slave_addr);\r\nreturn -EIO;\r\n}\r\niowrite32(ioread32(I2C_REG_STS(alg_data)) | mstatus_tdi | mstatus_afi,\r\nI2C_REG_STS(alg_data));\r\ndev_dbg(&alg_data->adapter.dev, "%s(): sending %#x\n", __func__,\r\n(slave_addr << 1) | start_bit | alg_data->mif.mode);\r\niowrite32((slave_addr << 1) | start_bit | alg_data->mif.mode,\r\nI2C_REG_TX(alg_data));\r\ndev_dbg(&alg_data->adapter.dev, "%s(): exit\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void i2c_pnx_stop(struct i2c_pnx_algo_data *alg_data)\r\n{\r\nlong timeout = 1000;\r\ndev_dbg(&alg_data->adapter.dev, "%s(): entering: stat = %04x.\n",\r\n__func__, ioread32(I2C_REG_STS(alg_data)));\r\niowrite32(0xff | stop_bit, I2C_REG_TX(alg_data));\r\nwhile (timeout > 0 &&\r\n(ioread32(I2C_REG_STS(alg_data)) & mstatus_active)) {\r\nudelay(1);\r\ntimeout--;\r\n}\r\ndev_dbg(&alg_data->adapter.dev, "%s(): exiting: stat = %04x.\n",\r\n__func__, ioread32(I2C_REG_STS(alg_data)));\r\n}\r\nstatic int i2c_pnx_master_xmit(struct i2c_pnx_algo_data *alg_data)\r\n{\r\nu32 val;\r\ndev_dbg(&alg_data->adapter.dev, "%s(): entering: stat = %04x.\n",\r\n__func__, ioread32(I2C_REG_STS(alg_data)));\r\nif (alg_data->mif.len > 0) {\r\nval = *alg_data->mif.buf++;\r\nif (alg_data->mif.len == 1)\r\nval |= stop_bit;\r\nalg_data->mif.len--;\r\niowrite32(val, I2C_REG_TX(alg_data));\r\ndev_dbg(&alg_data->adapter.dev, "%s(): xmit %#x [%d]\n",\r\n__func__, val, alg_data->mif.len + 1);\r\nif (alg_data->mif.len == 0) {\r\nif (alg_data->last) {\r\nif (wait_timeout(alg_data))\r\ndev_err(&alg_data->adapter.dev,\r\n"The bus is still active after timeout\n");\r\n}\r\niowrite32(ioread32(I2C_REG_CTL(alg_data)) &\r\n~(mcntrl_afie | mcntrl_naie | mcntrl_drmie),\r\nI2C_REG_CTL(alg_data));\r\ndel_timer_sync(&alg_data->mif.timer);\r\ndev_dbg(&alg_data->adapter.dev,\r\n"%s(): Waking up xfer routine.\n",\r\n__func__);\r\ncomplete(&alg_data->mif.complete);\r\n}\r\n} else if (alg_data->mif.len == 0) {\r\ni2c_pnx_stop(alg_data);\r\niowrite32(ioread32(I2C_REG_CTL(alg_data)) &\r\n~(mcntrl_afie | mcntrl_naie | mcntrl_drmie),\r\nI2C_REG_CTL(alg_data));\r\ndel_timer_sync(&alg_data->mif.timer);\r\ndev_dbg(&alg_data->adapter.dev,\r\n"%s(): Waking up xfer routine after zero-xfer.\n",\r\n__func__);\r\ncomplete(&alg_data->mif.complete);\r\n}\r\ndev_dbg(&alg_data->adapter.dev, "%s(): exiting: stat = %04x.\n",\r\n__func__, ioread32(I2C_REG_STS(alg_data)));\r\nreturn 0;\r\n}\r\nstatic int i2c_pnx_master_rcv(struct i2c_pnx_algo_data *alg_data)\r\n{\r\nunsigned int val = 0;\r\nu32 ctl = 0;\r\ndev_dbg(&alg_data->adapter.dev, "%s(): entering: stat = %04x.\n",\r\n__func__, ioread32(I2C_REG_STS(alg_data)));\r\nif (ioread32(I2C_REG_STS(alg_data)) & mstatus_rfe) {\r\nif (alg_data->mif.order) {\r\ndev_dbg(&alg_data->adapter.dev,\r\n"%s(): Write dummy data to fill Rx-fifo...\n",\r\n__func__);\r\nif (alg_data->mif.order == 1) {\r\nval |= stop_bit;\r\nctl = ioread32(I2C_REG_CTL(alg_data));\r\nctl |= mcntrl_rffie | mcntrl_daie;\r\nctl &= ~mcntrl_drmie;\r\niowrite32(ctl, I2C_REG_CTL(alg_data));\r\n}\r\niowrite32(val, I2C_REG_TX(alg_data));\r\nalg_data->mif.order--;\r\n}\r\nreturn 0;\r\n}\r\nif (alg_data->mif.len > 0) {\r\nval = ioread32(I2C_REG_RX(alg_data));\r\n*alg_data->mif.buf++ = (u8) (val & 0xff);\r\ndev_dbg(&alg_data->adapter.dev, "%s(): rcv 0x%x [%d]\n",\r\n__func__, val, alg_data->mif.len);\r\nalg_data->mif.len--;\r\nif (alg_data->mif.len == 0) {\r\nif (alg_data->last)\r\nif (wait_timeout(alg_data))\r\ndev_err(&alg_data->adapter.dev,\r\n"The bus is still active after timeout\n");\r\nctl = ioread32(I2C_REG_CTL(alg_data));\r\nctl &= ~(mcntrl_afie | mcntrl_naie | mcntrl_rffie |\r\nmcntrl_drmie | mcntrl_daie);\r\niowrite32(ctl, I2C_REG_CTL(alg_data));\r\ndel_timer_sync(&alg_data->mif.timer);\r\ncomplete(&alg_data->mif.complete);\r\n}\r\n}\r\ndev_dbg(&alg_data->adapter.dev, "%s(): exiting: stat = %04x.\n",\r\n__func__, ioread32(I2C_REG_STS(alg_data)));\r\nreturn 0;\r\n}\r\nstatic irqreturn_t i2c_pnx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct i2c_pnx_algo_data *alg_data = dev_id;\r\nu32 stat, ctl;\r\ndev_dbg(&alg_data->adapter.dev,\r\n"%s(): mstat = %x mctrl = %x, mode = %d\n",\r\n__func__,\r\nioread32(I2C_REG_STS(alg_data)),\r\nioread32(I2C_REG_CTL(alg_data)),\r\nalg_data->mif.mode);\r\nstat = ioread32(I2C_REG_STS(alg_data));\r\nif (stat & mstatus_afi) {\r\nalg_data->mif.ret = -EIO;\r\nctl = ioread32(I2C_REG_CTL(alg_data));\r\nctl &= ~(mcntrl_afie | mcntrl_naie | mcntrl_rffie |\r\nmcntrl_drmie);\r\niowrite32(ctl, I2C_REG_CTL(alg_data));\r\ndel_timer_sync(&alg_data->mif.timer);\r\ncomplete(&alg_data->mif.complete);\r\n} else if (stat & mstatus_nai) {\r\ndev_dbg(&alg_data->adapter.dev,\r\n"%s(): Slave did not acknowledge, generating a STOP.\n",\r\n__func__);\r\ni2c_pnx_stop(alg_data);\r\nctl = ioread32(I2C_REG_CTL(alg_data));\r\nctl &= ~(mcntrl_afie | mcntrl_naie | mcntrl_rffie |\r\nmcntrl_drmie);\r\niowrite32(ctl, I2C_REG_CTL(alg_data));\r\nalg_data->mif.ret = -EIO;\r\ndel_timer_sync(&alg_data->mif.timer);\r\ncomplete(&alg_data->mif.complete);\r\n} else {\r\nif ((stat & mstatus_drmi) || !(stat & mstatus_rfe)) {\r\nif (alg_data->mif.mode == I2C_SMBUS_WRITE) {\r\ni2c_pnx_master_xmit(alg_data);\r\n} else if (alg_data->mif.mode == I2C_SMBUS_READ) {\r\ni2c_pnx_master_rcv(alg_data);\r\n}\r\n}\r\n}\r\nstat = ioread32(I2C_REG_STS(alg_data));\r\niowrite32(stat | mstatus_tdi | mstatus_afi, I2C_REG_STS(alg_data));\r\ndev_dbg(&alg_data->adapter.dev,\r\n"%s(): exiting, stat = %x ctrl = %x.\n",\r\n__func__, ioread32(I2C_REG_STS(alg_data)),\r\nioread32(I2C_REG_CTL(alg_data)));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void i2c_pnx_timeout(unsigned long data)\r\n{\r\nstruct i2c_pnx_algo_data *alg_data = (struct i2c_pnx_algo_data *)data;\r\nu32 ctl;\r\ndev_err(&alg_data->adapter.dev,\r\n"Master timed out. stat = %04x, cntrl = %04x. Resetting master...\n",\r\nioread32(I2C_REG_STS(alg_data)),\r\nioread32(I2C_REG_CTL(alg_data)));\r\nctl = ioread32(I2C_REG_CTL(alg_data));\r\nctl &= ~(mcntrl_afie | mcntrl_naie | mcntrl_rffie | mcntrl_drmie);\r\niowrite32(ctl, I2C_REG_CTL(alg_data));\r\nctl |= mcntrl_reset;\r\niowrite32(ctl, I2C_REG_CTL(alg_data));\r\nwait_reset(alg_data);\r\nalg_data->mif.ret = -EIO;\r\ncomplete(&alg_data->mif.complete);\r\n}\r\nstatic inline void bus_reset_if_active(struct i2c_pnx_algo_data *alg_data)\r\n{\r\nu32 stat;\r\nif ((stat = ioread32(I2C_REG_STS(alg_data))) & mstatus_active) {\r\ndev_err(&alg_data->adapter.dev,\r\n"%s: Bus is still active after xfer. Reset it...\n",\r\nalg_data->adapter.name);\r\niowrite32(ioread32(I2C_REG_CTL(alg_data)) | mcntrl_reset,\r\nI2C_REG_CTL(alg_data));\r\nwait_reset(alg_data);\r\n} else if (!(stat & mstatus_rfe) || !(stat & mstatus_tfe)) {\r\niowrite32(ioread32(I2C_REG_CTL(alg_data)) | mcntrl_reset,\r\nI2C_REG_CTL(alg_data));\r\nwait_reset(alg_data);\r\n} else if (stat & mstatus_nai) {\r\niowrite32(ioread32(I2C_REG_CTL(alg_data)) | mcntrl_reset,\r\nI2C_REG_CTL(alg_data));\r\nwait_reset(alg_data);\r\n}\r\n}\r\nstatic int\r\ni2c_pnx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct i2c_msg *pmsg;\r\nint rc = 0, completed = 0, i;\r\nstruct i2c_pnx_algo_data *alg_data = adap->algo_data;\r\nu32 stat = ioread32(I2C_REG_STS(alg_data));\r\ndev_dbg(&alg_data->adapter.dev,\r\n"%s(): entering: %d messages, stat = %04x.\n",\r\n__func__, num, ioread32(I2C_REG_STS(alg_data)));\r\nbus_reset_if_active(alg_data);\r\nfor (i = 0; rc >= 0 && i < num; i++) {\r\nu8 addr;\r\npmsg = &msgs[i];\r\naddr = pmsg->addr;\r\nif (pmsg->flags & I2C_M_TEN) {\r\ndev_err(&alg_data->adapter.dev,\r\n"%s: 10 bits addr not supported!\n",\r\nalg_data->adapter.name);\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nalg_data->mif.buf = pmsg->buf;\r\nalg_data->mif.len = pmsg->len;\r\nalg_data->mif.order = pmsg->len;\r\nalg_data->mif.mode = (pmsg->flags & I2C_M_RD) ?\r\nI2C_SMBUS_READ : I2C_SMBUS_WRITE;\r\nalg_data->mif.ret = 0;\r\nalg_data->last = (i == num - 1);\r\ndev_dbg(&alg_data->adapter.dev, "%s(): mode %d, %d bytes\n",\r\n__func__, alg_data->mif.mode, alg_data->mif.len);\r\ni2c_pnx_arm_timer(alg_data);\r\ninit_completion(&alg_data->mif.complete);\r\niowrite32(ioread32(I2C_REG_CTL(alg_data)) | mcntrl_afie |\r\nmcntrl_naie | mcntrl_drmie,\r\nI2C_REG_CTL(alg_data));\r\nrc = i2c_pnx_start(addr, alg_data);\r\nif (rc < 0)\r\nbreak;\r\nwait_for_completion(&alg_data->mif.complete);\r\nif (!(rc = alg_data->mif.ret))\r\ncompleted++;\r\ndev_dbg(&alg_data->adapter.dev,\r\n"%s(): Complete, return code = %d.\n",\r\n__func__, rc);\r\nif ((stat = ioread32(I2C_REG_STS(alg_data))) & mstatus_tdi) {\r\ndev_dbg(&alg_data->adapter.dev,\r\n"%s: TDI still set... clearing now.\n",\r\nalg_data->adapter.name);\r\niowrite32(stat, I2C_REG_STS(alg_data));\r\n}\r\nif ((stat = ioread32(I2C_REG_STS(alg_data))) & mstatus_afi) {\r\ndev_dbg(&alg_data->adapter.dev,\r\n"%s: AFI still set... clearing now.\n",\r\nalg_data->adapter.name);\r\niowrite32(stat, I2C_REG_STS(alg_data));\r\n}\r\n}\r\nbus_reset_if_active(alg_data);\r\nalg_data->mif.buf = NULL;\r\nalg_data->mif.len = 0;\r\nalg_data->mif.order = 0;\r\ndev_dbg(&alg_data->adapter.dev, "%s(): exiting, stat = %x\n",\r\n__func__, ioread32(I2C_REG_STS(alg_data)));\r\nif (completed != num)\r\nreturn ((rc < 0) ? rc : -EREMOTEIO);\r\nreturn num;\r\n}\r\nstatic u32 i2c_pnx_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int i2c_pnx_controller_suspend(struct device *dev)\r\n{\r\nstruct i2c_pnx_algo_data *alg_data = dev_get_drvdata(dev);\r\nclk_disable(alg_data->clk);\r\nreturn 0;\r\n}\r\nstatic int i2c_pnx_controller_resume(struct device *dev)\r\n{\r\nstruct i2c_pnx_algo_data *alg_data = dev_get_drvdata(dev);\r\nreturn clk_enable(alg_data->clk);\r\n}\r\nstatic int __devinit i2c_pnx_probe(struct platform_device *pdev)\r\n{\r\nunsigned long tmp;\r\nint ret = 0;\r\nstruct i2c_pnx_algo_data *alg_data;\r\nunsigned long freq;\r\nstruct resource *res;\r\nu32 speed = I2C_PNX_SPEED_KHZ_DEFAULT * 1000;\r\nalg_data = kzalloc(sizeof(*alg_data), GFP_KERNEL);\r\nif (!alg_data) {\r\nret = -ENOMEM;\r\ngoto err_kzalloc;\r\n}\r\nplatform_set_drvdata(pdev, alg_data);\r\nalg_data->adapter.dev.parent = &pdev->dev;\r\nalg_data->adapter.algo = &pnx_algorithm;\r\nalg_data->adapter.algo_data = alg_data;\r\nalg_data->adapter.nr = pdev->id;\r\nalg_data->timeout = I2C_PNX_TIMEOUT_DEFAULT;\r\n#ifdef CONFIG_OF\r\nalg_data->adapter.dev.of_node = of_node_get(pdev->dev.of_node);\r\nif (pdev->dev.of_node) {\r\nof_property_read_u32(pdev->dev.of_node, "clock-frequency",\r\n&speed);\r\n}\r\n#endif\r\nalg_data->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(alg_data->clk)) {\r\nret = PTR_ERR(alg_data->clk);\r\ngoto out_drvdata;\r\n}\r\ninit_timer(&alg_data->mif.timer);\r\nalg_data->mif.timer.function = i2c_pnx_timeout;\r\nalg_data->mif.timer.data = (unsigned long)alg_data;\r\nsnprintf(alg_data->adapter.name, sizeof(alg_data->adapter.name),\r\n"%s", pdev->name);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Unable to get mem resource.\n");\r\nret = -EBUSY;\r\ngoto out_clkget;\r\n}\r\nif (!request_mem_region(res->start, I2C_PNX_REGION_SIZE,\r\npdev->name)) {\r\ndev_err(&pdev->dev,\r\n"I/O region 0x%08x for I2C already in use.\n",\r\nres->start);\r\nret = -ENOMEM;\r\ngoto out_clkget;\r\n}\r\nalg_data->base = res->start;\r\nalg_data->ioaddr = ioremap(res->start, I2C_PNX_REGION_SIZE);\r\nif (!alg_data->ioaddr) {\r\ndev_err(&pdev->dev, "Couldn't ioremap I2C I/O region\n");\r\nret = -ENOMEM;\r\ngoto out_release;\r\n}\r\nret = clk_enable(alg_data->clk);\r\nif (ret)\r\ngoto out_unmap;\r\nfreq = clk_get_rate(alg_data->clk);\r\ntmp = (freq / speed) / 2 - 2;\r\nif (tmp > 0x3FF)\r\ntmp = 0x3FF;\r\niowrite32(tmp, I2C_REG_CKH(alg_data));\r\niowrite32(tmp, I2C_REG_CKL(alg_data));\r\niowrite32(mcntrl_reset, I2C_REG_CTL(alg_data));\r\nif (wait_reset(alg_data)) {\r\nret = -ENODEV;\r\ngoto out_clock;\r\n}\r\ninit_completion(&alg_data->mif.complete);\r\nalg_data->irq = platform_get_irq(pdev, 0);\r\nif (alg_data->irq < 0) {\r\ndev_err(&pdev->dev, "Failed to get IRQ from platform resource\n");\r\ngoto out_irq;\r\n}\r\nret = request_irq(alg_data->irq, i2c_pnx_interrupt,\r\n0, pdev->name, alg_data);\r\nif (ret)\r\ngoto out_clock;\r\nret = i2c_add_numbered_adapter(&alg_data->adapter);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "I2C: Failed to add bus\n");\r\ngoto out_irq;\r\n}\r\nof_i2c_register_devices(&alg_data->adapter);\r\ndev_dbg(&pdev->dev, "%s: Master at %#8x, irq %d.\n",\r\nalg_data->adapter.name, res->start, alg_data->irq);\r\nreturn 0;\r\nout_irq:\r\nfree_irq(alg_data->irq, alg_data);\r\nout_clock:\r\nclk_disable(alg_data->clk);\r\nout_unmap:\r\niounmap(alg_data->ioaddr);\r\nout_release:\r\nrelease_mem_region(res->start, I2C_PNX_REGION_SIZE);\r\nout_clkget:\r\nclk_put(alg_data->clk);\r\nout_drvdata:\r\nkfree(alg_data);\r\nerr_kzalloc:\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn ret;\r\n}\r\nstatic int __devexit i2c_pnx_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_pnx_algo_data *alg_data = platform_get_drvdata(pdev);\r\nfree_irq(alg_data->irq, alg_data);\r\ni2c_del_adapter(&alg_data->adapter);\r\nclk_disable(alg_data->clk);\r\niounmap(alg_data->ioaddr);\r\nrelease_mem_region(alg_data->base, I2C_PNX_REGION_SIZE);\r\nclk_put(alg_data->clk);\r\nkfree(alg_data);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init i2c_adap_pnx_init(void)\r\n{\r\nreturn platform_driver_register(&i2c_pnx_driver);\r\n}\r\nstatic void __exit i2c_adap_pnx_exit(void)\r\n{\r\nplatform_driver_unregister(&i2c_pnx_driver);\r\n}
