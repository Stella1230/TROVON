static int ttl_get_value(struct gpio_chip *gpio, unsigned offset)\r\n{\r\nstruct ttl_module *mod = dev_get_drvdata(gpio->dev);\r\nu8 *shadow;\r\nint ret;\r\nif (offset < 8) {\r\nshadow = &mod->porta_shadow;\r\n} else if (offset < 16) {\r\nshadow = &mod->portb_shadow;\r\noffset -= 8;\r\n} else {\r\nshadow = &mod->portc_shadow;\r\noffset -= 16;\r\n}\r\nspin_lock(&mod->lock);\r\nret = *shadow & (1 << offset);\r\nspin_unlock(&mod->lock);\r\nreturn ret;\r\n}\r\nstatic void ttl_set_value(struct gpio_chip *gpio, unsigned offset, int value)\r\n{\r\nstruct ttl_module *mod = dev_get_drvdata(gpio->dev);\r\nvoid __iomem *port;\r\nu8 *shadow;\r\nif (offset < 8) {\r\nport = &mod->regs->porta;\r\nshadow = &mod->porta_shadow;\r\n} else if (offset < 16) {\r\nport = &mod->regs->portb;\r\nshadow = &mod->portb_shadow;\r\noffset -= 8;\r\n} else {\r\nport = &mod->regs->portc;\r\nshadow = &mod->portc_shadow;\r\noffset -= 16;\r\n}\r\nspin_lock(&mod->lock);\r\nif (value)\r\n*shadow |= (1 << offset);\r\nelse\r\n*shadow &= ~(1 << offset);\r\niowrite16be(*shadow, port);\r\nspin_unlock(&mod->lock);\r\n}\r\nstatic void __devinit ttl_write_reg(struct ttl_module *mod, u8 reg, u16 val)\r\n{\r\niowrite16be(reg, &mod->regs->control);\r\niowrite16be(val, &mod->regs->control);\r\n}\r\nstatic void __devinit ttl_setup_device(struct ttl_module *mod)\r\n{\r\niowrite16be(0x0000, &mod->regs->control);\r\niowrite16be(0x0001, &mod->regs->control);\r\niowrite16be(0x0000, &mod->regs->control);\r\nttl_write_reg(mod, PORTA_IOCTL, 0x00ff);\r\nttl_write_reg(mod, PORTB_IOCTL, 0x00ff);\r\nttl_write_reg(mod, PORTC_IOCTL, 0x000f);\r\nttl_write_reg(mod, PORTA_DIRECTION, 0x0000);\r\nttl_write_reg(mod, PORTB_DIRECTION, 0x0000);\r\nttl_write_reg(mod, PORTC_DIRECTION, 0x0000);\r\niowrite16be(0x0000, &mod->regs->porta);\r\niowrite16be(0x0000, &mod->regs->portb);\r\niowrite16be(0x0000, &mod->regs->portc);\r\nttl_write_reg(mod, MASTER_CONF_CTL, CONF_PAE | CONF_PBE | CONF_PCE);\r\n}\r\nstatic int __devinit ttl_probe(struct platform_device *pdev)\r\n{\r\nstruct janz_platform_data *pdata;\r\nstruct device *dev = &pdev->dev;\r\nstruct ttl_module *mod;\r\nstruct gpio_chip *gpio;\r\nstruct resource *res;\r\nint ret;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(dev, "no platform data\n");\r\nret = -ENXIO;\r\ngoto out_return;\r\n}\r\nmod = kzalloc(sizeof(*mod), GFP_KERNEL);\r\nif (!mod) {\r\ndev_err(dev, "unable to allocate private data\n");\r\nret = -ENOMEM;\r\ngoto out_return;\r\n}\r\nplatform_set_drvdata(pdev, mod);\r\nspin_lock_init(&mod->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "MODULbus registers not found\n");\r\nret = -ENODEV;\r\ngoto out_free_mod;\r\n}\r\nmod->regs = ioremap(res->start, resource_size(res));\r\nif (!mod->regs) {\r\ndev_err(dev, "MODULbus registers not ioremap\n");\r\nret = -ENOMEM;\r\ngoto out_free_mod;\r\n}\r\nttl_setup_device(mod);\r\ngpio = &mod->gpio;\r\ngpio->dev = &pdev->dev;\r\ngpio->label = pdev->name;\r\ngpio->get = ttl_get_value;\r\ngpio->set = ttl_set_value;\r\ngpio->owner = THIS_MODULE;\r\ngpio->base = -1;\r\ngpio->ngpio = 20;\r\nret = gpiochip_add(gpio);\r\nif (ret) {\r\ndev_err(dev, "unable to add GPIO chip\n");\r\ngoto out_iounmap_regs;\r\n}\r\nreturn 0;\r\nout_iounmap_regs:\r\niounmap(mod->regs);\r\nout_free_mod:\r\nkfree(mod);\r\nout_return:\r\nreturn ret;\r\n}\r\nstatic int __devexit ttl_remove(struct platform_device *pdev)\r\n{\r\nstruct ttl_module *mod = platform_get_drvdata(pdev);\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nret = gpiochip_remove(&mod->gpio);\r\nif (ret) {\r\ndev_err(dev, "unable to remove GPIO chip\n");\r\nreturn ret;\r\n}\r\niounmap(mod->regs);\r\nkfree(mod);\r\nreturn 0;\r\n}
