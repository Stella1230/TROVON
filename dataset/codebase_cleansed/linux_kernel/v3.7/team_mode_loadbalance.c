static struct lb_priv *get_lb_priv(struct team *team)\r\n{\r\nreturn (struct lb_priv *) &team->mode_priv;\r\n}\r\nstatic struct lb_port_priv *get_lb_port_priv(struct team_port *port)\r\n{\r\nreturn (struct lb_port_priv *) &port->mode_priv;\r\n}\r\nstatic void lb_tx_hash_to_port_mapping_null_port(struct team *team,\r\nstruct team_port *port)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nbool changed = false;\r\nint i;\r\nfor (i = 0; i < LB_TX_HASHTABLE_SIZE; i++) {\r\nstruct lb_port_mapping *pm;\r\npm = &lb_priv->ex->tx_hash_to_port_mapping[i];\r\nif (rcu_access_pointer(pm->port) == port) {\r\nRCU_INIT_POINTER(pm->port, NULL);\r\nteam_option_inst_set_change(pm->opt_inst_info);\r\nchanged = true;\r\n}\r\n}\r\nif (changed)\r\nteam_options_change_check(team);\r\n}\r\nstatic struct team_port *lb_hash_select_tx_port(struct team *team,\r\nstruct lb_priv *lb_priv,\r\nstruct sk_buff *skb,\r\nunsigned char hash)\r\n{\r\nint port_index;\r\nport_index = hash % team->en_port_count;\r\nreturn team_get_port_by_index_rcu(team, port_index);\r\n}\r\nstatic struct team_port *lb_htpm_select_tx_port(struct team *team,\r\nstruct lb_priv *lb_priv,\r\nstruct sk_buff *skb,\r\nunsigned char hash)\r\n{\r\nreturn rcu_dereference_bh(LB_HTPM_PORT_BY_HASH(lb_priv, hash));\r\n}\r\nstatic char *lb_select_tx_port_get_name(lb_select_tx_port_func_t *func)\r\n{\r\nint i;\r\nfor (i = 0; i < LB_SELECT_TX_PORT_LIST_COUNT; i++) {\r\nconst struct lb_select_tx_port *item;\r\nitem = &lb_select_tx_port_list[i];\r\nif (item->func == func)\r\nreturn item->name;\r\n}\r\nreturn NULL;\r\n}\r\nstatic lb_select_tx_port_func_t *lb_select_tx_port_get_func(const char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < LB_SELECT_TX_PORT_LIST_COUNT; i++) {\r\nconst struct lb_select_tx_port *item;\r\nitem = &lb_select_tx_port_list[i];\r\nif (!strcmp(item->name, name))\r\nreturn item->func;\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned int lb_get_skb_hash(struct lb_priv *lb_priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_filter *fp;\r\nuint32_t lhash;\r\nunsigned char *c;\r\nfp = rcu_dereference_bh(lb_priv->fp);\r\nif (unlikely(!fp))\r\nreturn 0;\r\nlhash = SK_RUN_FILTER(fp, skb);\r\nc = (char *) &lhash;\r\nreturn c[0] ^ c[1] ^ c[2] ^ c[3];\r\n}\r\nstatic void lb_update_tx_stats(unsigned int tx_bytes, struct lb_priv *lb_priv,\r\nstruct lb_port_priv *lb_port_priv,\r\nunsigned char hash)\r\n{\r\nstruct lb_pcpu_stats *pcpu_stats;\r\nstruct lb_stats *port_stats;\r\nstruct lb_stats *hash_stats;\r\npcpu_stats = this_cpu_ptr(lb_priv->pcpu_stats);\r\nport_stats = this_cpu_ptr(lb_port_priv->pcpu_stats);\r\nhash_stats = &pcpu_stats->hash_stats[hash];\r\nu64_stats_update_begin(&pcpu_stats->syncp);\r\nport_stats->tx_bytes += tx_bytes;\r\nhash_stats->tx_bytes += tx_bytes;\r\nu64_stats_update_end(&pcpu_stats->syncp);\r\n}\r\nstatic bool lb_transmit(struct team *team, struct sk_buff *skb)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nlb_select_tx_port_func_t *select_tx_port_func;\r\nstruct team_port *port;\r\nunsigned char hash;\r\nunsigned int tx_bytes = skb->len;\r\nhash = lb_get_skb_hash(lb_priv, skb);\r\nselect_tx_port_func = rcu_dereference_bh(lb_priv->select_tx_port_func);\r\nport = select_tx_port_func(team, lb_priv, skb, hash);\r\nif (unlikely(!port))\r\ngoto drop;\r\nif (team_dev_queue_xmit(team, port, skb))\r\nreturn false;\r\nlb_update_tx_stats(tx_bytes, lb_priv, get_lb_port_priv(port), hash);\r\nreturn true;\r\ndrop:\r\ndev_kfree_skb_any(skb);\r\nreturn false;\r\n}\r\nstatic int lb_bpf_func_get(struct team *team, struct team_gsetter_ctx *ctx)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nif (!lb_priv->ex->orig_fprog) {\r\nctx->data.bin_val.len = 0;\r\nctx->data.bin_val.ptr = NULL;\r\nreturn 0;\r\n}\r\nctx->data.bin_val.len = lb_priv->ex->orig_fprog->len *\r\nsizeof(struct sock_filter);\r\nctx->data.bin_val.ptr = lb_priv->ex->orig_fprog->filter;\r\nreturn 0;\r\n}\r\nstatic int __fprog_create(struct sock_fprog **pfprog, u32 data_len,\r\nconst void *data)\r\n{\r\nstruct sock_fprog *fprog;\r\nstruct sock_filter *filter = (struct sock_filter *) data;\r\nif (data_len % sizeof(struct sock_filter))\r\nreturn -EINVAL;\r\nfprog = kmalloc(sizeof(struct sock_fprog), GFP_KERNEL);\r\nif (!fprog)\r\nreturn -ENOMEM;\r\nfprog->filter = kmemdup(filter, data_len, GFP_KERNEL);\r\nif (!fprog->filter) {\r\nkfree(fprog);\r\nreturn -ENOMEM;\r\n}\r\nfprog->len = data_len / sizeof(struct sock_filter);\r\n*pfprog = fprog;\r\nreturn 0;\r\n}\r\nstatic void __fprog_destroy(struct sock_fprog *fprog)\r\n{\r\nkfree(fprog->filter);\r\nkfree(fprog);\r\n}\r\nstatic int lb_bpf_func_set(struct team *team, struct team_gsetter_ctx *ctx)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nstruct sk_filter *fp = NULL;\r\nstruct sk_filter *orig_fp;\r\nstruct sock_fprog *fprog = NULL;\r\nint err;\r\nif (ctx->data.bin_val.len) {\r\nerr = __fprog_create(&fprog, ctx->data.bin_val.len,\r\nctx->data.bin_val.ptr);\r\nif (err)\r\nreturn err;\r\nerr = sk_unattached_filter_create(&fp, fprog);\r\nif (err) {\r\n__fprog_destroy(fprog);\r\nreturn err;\r\n}\r\n}\r\nif (lb_priv->ex->orig_fprog) {\r\n__fprog_destroy(lb_priv->ex->orig_fprog);\r\norig_fp = rcu_dereference_protected(lb_priv->fp,\r\nlockdep_is_held(&team->lock));\r\nsk_unattached_filter_destroy(orig_fp);\r\n}\r\nrcu_assign_pointer(lb_priv->fp, fp);\r\nlb_priv->ex->orig_fprog = fprog;\r\nreturn 0;\r\n}\r\nstatic int lb_tx_method_get(struct team *team, struct team_gsetter_ctx *ctx)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nlb_select_tx_port_func_t *func;\r\nchar *name;\r\nfunc = rcu_dereference_protected(lb_priv->select_tx_port_func,\r\nlockdep_is_held(&team->lock));\r\nname = lb_select_tx_port_get_name(func);\r\nBUG_ON(!name);\r\nctx->data.str_val = name;\r\nreturn 0;\r\n}\r\nstatic int lb_tx_method_set(struct team *team, struct team_gsetter_ctx *ctx)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nlb_select_tx_port_func_t *func;\r\nfunc = lb_select_tx_port_get_func(ctx->data.str_val);\r\nif (!func)\r\nreturn -EINVAL;\r\nrcu_assign_pointer(lb_priv->select_tx_port_func, func);\r\nreturn 0;\r\n}\r\nstatic int lb_tx_hash_to_port_mapping_init(struct team *team,\r\nstruct team_option_inst_info *info)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nunsigned char hash = info->array_index;\r\nLB_HTPM_OPT_INST_INFO_BY_HASH(lb_priv, hash) = info;\r\nreturn 0;\r\n}\r\nstatic int lb_tx_hash_to_port_mapping_get(struct team *team,\r\nstruct team_gsetter_ctx *ctx)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nstruct team_port *port;\r\nunsigned char hash = ctx->info->array_index;\r\nport = LB_HTPM_PORT_BY_HASH(lb_priv, hash);\r\nctx->data.u32_val = port ? port->dev->ifindex : 0;\r\nreturn 0;\r\n}\r\nstatic int lb_tx_hash_to_port_mapping_set(struct team *team,\r\nstruct team_gsetter_ctx *ctx)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nstruct team_port *port;\r\nunsigned char hash = ctx->info->array_index;\r\nlist_for_each_entry(port, &team->port_list, list) {\r\nif (ctx->data.u32_val == port->dev->ifindex &&\r\nteam_port_enabled(port)) {\r\nrcu_assign_pointer(LB_HTPM_PORT_BY_HASH(lb_priv, hash),\r\nport);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int lb_hash_stats_init(struct team *team,\r\nstruct team_option_inst_info *info)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nunsigned char hash = info->array_index;\r\nlb_priv->ex->stats.info[hash].opt_inst_info = info;\r\nreturn 0;\r\n}\r\nstatic int lb_hash_stats_get(struct team *team, struct team_gsetter_ctx *ctx)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nunsigned char hash = ctx->info->array_index;\r\nctx->data.bin_val.ptr = &lb_priv->ex->stats.info[hash].stats;\r\nctx->data.bin_val.len = sizeof(struct lb_stats);\r\nreturn 0;\r\n}\r\nstatic int lb_port_stats_init(struct team *team,\r\nstruct team_option_inst_info *info)\r\n{\r\nstruct team_port *port = info->port;\r\nstruct lb_port_priv *lb_port_priv = get_lb_port_priv(port);\r\nlb_port_priv->stats_info.opt_inst_info = info;\r\nreturn 0;\r\n}\r\nstatic int lb_port_stats_get(struct team *team, struct team_gsetter_ctx *ctx)\r\n{\r\nstruct team_port *port = ctx->info->port;\r\nstruct lb_port_priv *lb_port_priv = get_lb_port_priv(port);\r\nctx->data.bin_val.ptr = &lb_port_priv->stats_info.stats;\r\nctx->data.bin_val.len = sizeof(struct lb_stats);\r\nreturn 0;\r\n}\r\nstatic void __lb_stats_info_refresh_prepare(struct lb_stats_info *s_info)\r\n{\r\nmemcpy(&s_info->last_stats, &s_info->stats, sizeof(struct lb_stats));\r\nmemset(&s_info->stats, 0, sizeof(struct lb_stats));\r\n}\r\nstatic bool __lb_stats_info_refresh_check(struct lb_stats_info *s_info,\r\nstruct team *team)\r\n{\r\nif (memcmp(&s_info->last_stats, &s_info->stats,\r\nsizeof(struct lb_stats))) {\r\nteam_option_inst_set_change(s_info->opt_inst_info);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void __lb_one_cpu_stats_add(struct lb_stats *acc_stats,\r\nstruct lb_stats *cpu_stats,\r\nstruct u64_stats_sync *syncp)\r\n{\r\nunsigned int start;\r\nstruct lb_stats tmp;\r\ndo {\r\nstart = u64_stats_fetch_begin_bh(syncp);\r\ntmp.tx_bytes = cpu_stats->tx_bytes;\r\n} while (u64_stats_fetch_retry_bh(syncp, start));\r\nacc_stats->tx_bytes += tmp.tx_bytes;\r\n}\r\nstatic void lb_stats_refresh(struct work_struct *work)\r\n{\r\nstruct team *team;\r\nstruct lb_priv *lb_priv;\r\nstruct lb_priv_ex *lb_priv_ex;\r\nstruct lb_pcpu_stats *pcpu_stats;\r\nstruct lb_stats *stats;\r\nstruct lb_stats_info *s_info;\r\nstruct team_port *port;\r\nbool changed = false;\r\nint i;\r\nint j;\r\nlb_priv_ex = container_of(work, struct lb_priv_ex,\r\nstats.refresh_dw.work);\r\nteam = lb_priv_ex->team;\r\nlb_priv = get_lb_priv(team);\r\nif (!mutex_trylock(&team->lock)) {\r\nschedule_delayed_work(&lb_priv_ex->stats.refresh_dw, 0);\r\nreturn;\r\n}\r\nfor (j = 0; j < LB_TX_HASHTABLE_SIZE; j++) {\r\ns_info = &lb_priv->ex->stats.info[j];\r\n__lb_stats_info_refresh_prepare(s_info);\r\nfor_each_possible_cpu(i) {\r\npcpu_stats = per_cpu_ptr(lb_priv->pcpu_stats, i);\r\nstats = &pcpu_stats->hash_stats[j];\r\n__lb_one_cpu_stats_add(&s_info->stats, stats,\r\n&pcpu_stats->syncp);\r\n}\r\nchanged |= __lb_stats_info_refresh_check(s_info, team);\r\n}\r\nlist_for_each_entry(port, &team->port_list, list) {\r\nstruct lb_port_priv *lb_port_priv = get_lb_port_priv(port);\r\ns_info = &lb_port_priv->stats_info;\r\n__lb_stats_info_refresh_prepare(s_info);\r\nfor_each_possible_cpu(i) {\r\npcpu_stats = per_cpu_ptr(lb_priv->pcpu_stats, i);\r\nstats = per_cpu_ptr(lb_port_priv->pcpu_stats, i);\r\n__lb_one_cpu_stats_add(&s_info->stats, stats,\r\n&pcpu_stats->syncp);\r\n}\r\nchanged |= __lb_stats_info_refresh_check(s_info, team);\r\n}\r\nif (changed)\r\nteam_options_change_check(team);\r\nschedule_delayed_work(&lb_priv_ex->stats.refresh_dw,\r\n(lb_priv_ex->stats.refresh_interval * HZ) / 10);\r\nmutex_unlock(&team->lock);\r\n}\r\nstatic int lb_stats_refresh_interval_get(struct team *team,\r\nstruct team_gsetter_ctx *ctx)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nctx->data.u32_val = lb_priv->ex->stats.refresh_interval;\r\nreturn 0;\r\n}\r\nstatic int lb_stats_refresh_interval_set(struct team *team,\r\nstruct team_gsetter_ctx *ctx)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nunsigned int interval;\r\ninterval = ctx->data.u32_val;\r\nif (lb_priv->ex->stats.refresh_interval == interval)\r\nreturn 0;\r\nlb_priv->ex->stats.refresh_interval = interval;\r\nif (interval)\r\nschedule_delayed_work(&lb_priv->ex->stats.refresh_dw, 0);\r\nelse\r\ncancel_delayed_work(&lb_priv->ex->stats.refresh_dw);\r\nreturn 0;\r\n}\r\nstatic int lb_init(struct team *team)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nlb_select_tx_port_func_t *func;\r\nint err;\r\nfunc = lb_select_tx_port_get_func("hash");\r\nBUG_ON(!func);\r\nrcu_assign_pointer(lb_priv->select_tx_port_func, func);\r\nlb_priv->ex = kzalloc(sizeof(*lb_priv->ex), GFP_KERNEL);\r\nif (!lb_priv->ex)\r\nreturn -ENOMEM;\r\nlb_priv->ex->team = team;\r\nlb_priv->pcpu_stats = alloc_percpu(struct lb_pcpu_stats);\r\nif (!lb_priv->pcpu_stats) {\r\nerr = -ENOMEM;\r\ngoto err_alloc_pcpu_stats;\r\n}\r\nINIT_DELAYED_WORK(&lb_priv->ex->stats.refresh_dw, lb_stats_refresh);\r\nerr = team_options_register(team, lb_options, ARRAY_SIZE(lb_options));\r\nif (err)\r\ngoto err_options_register;\r\nreturn 0;\r\nerr_options_register:\r\nfree_percpu(lb_priv->pcpu_stats);\r\nerr_alloc_pcpu_stats:\r\nkfree(lb_priv->ex);\r\nreturn err;\r\n}\r\nstatic void lb_exit(struct team *team)\r\n{\r\nstruct lb_priv *lb_priv = get_lb_priv(team);\r\nteam_options_unregister(team, lb_options,\r\nARRAY_SIZE(lb_options));\r\ncancel_delayed_work_sync(&lb_priv->ex->stats.refresh_dw);\r\nfree_percpu(lb_priv->pcpu_stats);\r\nkfree(lb_priv->ex);\r\n}\r\nstatic int lb_port_enter(struct team *team, struct team_port *port)\r\n{\r\nstruct lb_port_priv *lb_port_priv = get_lb_port_priv(port);\r\nlb_port_priv->pcpu_stats = alloc_percpu(struct lb_stats);\r\nif (!lb_port_priv->pcpu_stats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void lb_port_leave(struct team *team, struct team_port *port)\r\n{\r\nstruct lb_port_priv *lb_port_priv = get_lb_port_priv(port);\r\nfree_percpu(lb_port_priv->pcpu_stats);\r\n}\r\nstatic void lb_port_disabled(struct team *team, struct team_port *port)\r\n{\r\nlb_tx_hash_to_port_mapping_null_port(team, port);\r\n}\r\nstatic int __init lb_init_module(void)\r\n{\r\nreturn team_mode_register(&lb_mode);\r\n}\r\nstatic void __exit lb_cleanup_module(void)\r\n{\r\nteam_mode_unregister(&lb_mode);\r\n}
