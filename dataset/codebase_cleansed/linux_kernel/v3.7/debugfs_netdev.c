static ssize_t ieee80211_if_read(\r\nstruct ieee80211_sub_if_data *sdata,\r\nchar __user *userbuf,\r\nsize_t count, loff_t *ppos,\r\nssize_t (*format)(const struct ieee80211_sub_if_data *, char *, int))\r\n{\r\nchar buf[70];\r\nssize_t ret = -EINVAL;\r\nread_lock(&dev_base_lock);\r\nif (sdata->dev->reg_state == NETREG_REGISTERED)\r\nret = (*format)(sdata, buf, sizeof(buf));\r\nread_unlock(&dev_base_lock);\r\nif (ret >= 0)\r\nret = simple_read_from_buffer(userbuf, count, ppos, buf, ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t ieee80211_if_write(\r\nstruct ieee80211_sub_if_data *sdata,\r\nconst char __user *userbuf,\r\nsize_t count, loff_t *ppos,\r\nssize_t (*write)(struct ieee80211_sub_if_data *, const char *, int))\r\n{\r\nchar buf[64];\r\nssize_t ret;\r\nif (count >= sizeof(buf))\r\nreturn -E2BIG;\r\nif (copy_from_user(buf, userbuf, count))\r\nreturn -EFAULT;\r\nbuf[count] = '\0';\r\nret = -ENODEV;\r\nrtnl_lock();\r\nif (sdata->dev->reg_state == NETREG_REGISTERED)\r\nret = (*write)(sdata, buf, count);\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nstatic int ieee80211_set_smps(struct ieee80211_sub_if_data *sdata,\r\nenum ieee80211_smps_mode smps_mode)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nint err;\r\nif (!(local->hw.flags & IEEE80211_HW_SUPPORTS_STATIC_SMPS) &&\r\nsmps_mode == IEEE80211_SMPS_STATIC)\r\nreturn -EINVAL;\r\nif (!(local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_SMPS) &&\r\n(smps_mode == IEEE80211_SMPS_DYNAMIC ||\r\nsmps_mode == IEEE80211_SMPS_AUTOMATIC))\r\nreturn -EINVAL;\r\nif (sdata->vif.type != NL80211_IFTYPE_STATION)\r\nreturn -EOPNOTSUPP;\r\nmutex_lock(&sdata->u.mgd.mtx);\r\nerr = __ieee80211_request_smps(sdata, smps_mode);\r\nmutex_unlock(&sdata->u.mgd.mtx);\r\nreturn err;\r\n}\r\nstatic ssize_t ieee80211_if_fmt_smps(const struct ieee80211_sub_if_data *sdata,\r\nchar *buf, int buflen)\r\n{\r\nif (sdata->vif.type != NL80211_IFTYPE_STATION)\r\nreturn -EOPNOTSUPP;\r\nreturn snprintf(buf, buflen, "request: %s\nused: %s\n",\r\nsmps_modes[sdata->u.mgd.req_smps],\r\nsmps_modes[sdata->u.mgd.ap_smps]);\r\n}\r\nstatic ssize_t ieee80211_if_parse_smps(struct ieee80211_sub_if_data *sdata,\r\nconst char *buf, int buflen)\r\n{\r\nenum ieee80211_smps_mode mode;\r\nfor (mode = 0; mode < IEEE80211_SMPS_NUM_MODES; mode++) {\r\nif (strncmp(buf, smps_modes[mode], buflen) == 0) {\r\nint err = ieee80211_set_smps(sdata, mode);\r\nif (!err)\r\nreturn buflen;\r\nreturn err;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t ieee80211_if_fmt_tkip_mic_test(\r\nconst struct ieee80211_sub_if_data *sdata, char *buf, int buflen)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int hwaddr_aton(const char *txt, u8 *addr)\r\n{\r\nint i;\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\nint a, b;\r\na = hex_to_bin(*txt++);\r\nif (a < 0)\r\nreturn -1;\r\nb = hex_to_bin(*txt++);\r\nif (b < 0)\r\nreturn -1;\r\n*addr++ = (a << 4) | b;\r\nif (i < 5 && *txt++ != ':')\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t ieee80211_if_parse_tkip_mic_test(\r\nstruct ieee80211_sub_if_data *sdata, const char *buf, int buflen)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nu8 addr[ETH_ALEN];\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr *hdr;\r\n__le16 fc;\r\nif (buflen < 3 * ETH_ALEN - 1)\r\nreturn -EINVAL;\r\nif (hwaddr_aton(buf, addr) < 0)\r\nreturn -EINVAL;\r\nif (!ieee80211_sdata_running(sdata))\r\nreturn -ENOTCONN;\r\nskb = dev_alloc_skb(local->hw.extra_tx_headroom + 24 + 100);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_reserve(skb, local->hw.extra_tx_headroom);\r\nhdr = (struct ieee80211_hdr *) skb_put(skb, 24);\r\nmemset(hdr, 0, 24);\r\nfc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);\r\nswitch (sdata->vif.type) {\r\ncase NL80211_IFTYPE_AP:\r\nfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\r\nmemcpy(hdr->addr1, addr, ETH_ALEN);\r\nmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\r\nmemcpy(hdr->addr3, sdata->vif.addr, ETH_ALEN);\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nfc |= cpu_to_le16(IEEE80211_FCTL_TODS);\r\nif (sdata->vif.bss_conf.bssid == NULL) {\r\ndev_kfree_skb(skb);\r\nreturn -ENOTCONN;\r\n}\r\nmemcpy(hdr->addr1, sdata->vif.bss_conf.bssid, ETH_ALEN);\r\nmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\r\nmemcpy(hdr->addr3, addr, ETH_ALEN);\r\nbreak;\r\ndefault:\r\ndev_kfree_skb(skb);\r\nreturn -EOPNOTSUPP;\r\n}\r\nhdr->frame_control = fc;\r\nmemset(skb_put(skb, 50), 0, 50);\r\nIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_TKIP_MIC_FAILURE;\r\nieee80211_tx_skb(sdata, skb);\r\nreturn buflen;\r\n}\r\nstatic ssize_t ieee80211_if_fmt_uapsd_queues(\r\nconst struct ieee80211_sub_if_data *sdata, char *buf, int buflen)\r\n{\r\nconst struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\r\nreturn snprintf(buf, buflen, "0x%x\n", ifmgd->uapsd_queues);\r\n}\r\nstatic ssize_t ieee80211_if_parse_uapsd_queues(\r\nstruct ieee80211_sub_if_data *sdata, const char *buf, int buflen)\r\n{\r\nstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\r\nu8 val;\r\nint ret;\r\nret = kstrtou8(buf, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val & ~IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)\r\nreturn -ERANGE;\r\nifmgd->uapsd_queues = val;\r\nreturn buflen;\r\n}\r\nstatic ssize_t ieee80211_if_fmt_uapsd_max_sp_len(\r\nconst struct ieee80211_sub_if_data *sdata, char *buf, int buflen)\r\n{\r\nconst struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\r\nreturn snprintf(buf, buflen, "0x%x\n", ifmgd->uapsd_max_sp_len);\r\n}\r\nstatic ssize_t ieee80211_if_parse_uapsd_max_sp_len(\r\nstruct ieee80211_sub_if_data *sdata, const char *buf, int buflen)\r\n{\r\nstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul(buf, 0, &val);\r\nif (ret)\r\nreturn -EINVAL;\r\nif (val & ~IEEE80211_WMM_IE_STA_QOSINFO_SP_MASK)\r\nreturn -ERANGE;\r\nifmgd->uapsd_max_sp_len = val;\r\nreturn buflen;\r\n}\r\nstatic ssize_t ieee80211_if_fmt_num_buffered_multicast(\r\nconst struct ieee80211_sub_if_data *sdata, char *buf, int buflen)\r\n{\r\nreturn scnprintf(buf, buflen, "%u\n",\r\nskb_queue_len(&sdata->u.ap.ps_bc_buf));\r\n}\r\nstatic ssize_t ieee80211_if_fmt_tsf(\r\nconst struct ieee80211_sub_if_data *sdata, char *buf, int buflen)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nu64 tsf;\r\ntsf = drv_get_tsf(local, (struct ieee80211_sub_if_data *)sdata);\r\nreturn scnprintf(buf, buflen, "0x%016llx\n", (unsigned long long) tsf);\r\n}\r\nstatic ssize_t ieee80211_if_parse_tsf(\r\nstruct ieee80211_sub_if_data *sdata, const char *buf, int buflen)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nunsigned long long tsf;\r\nint ret;\r\nint tsf_is_delta = 0;\r\nif (strncmp(buf, "reset", 5) == 0) {\r\nif (local->ops->reset_tsf) {\r\ndrv_reset_tsf(local, sdata);\r\nwiphy_info(local->hw.wiphy, "debugfs reset TSF\n");\r\n}\r\n} else {\r\nif (buflen > 10 && buf[1] == '=') {\r\nif (buf[0] == '+')\r\ntsf_is_delta = 1;\r\nelse if (buf[0] == '-')\r\ntsf_is_delta = -1;\r\nelse\r\nreturn -EINVAL;\r\nbuf += 2;\r\n}\r\nret = kstrtoull(buf, 10, &tsf);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nif (tsf_is_delta)\r\ntsf = drv_get_tsf(local, sdata) + tsf_is_delta * tsf;\r\nif (local->ops->set_tsf) {\r\ndrv_set_tsf(local, sdata, tsf);\r\nwiphy_info(local->hw.wiphy,\r\n"debugfs set TSF to %#018llx\n", tsf);\r\n}\r\n}\r\nreturn buflen;\r\n}\r\nstatic void add_common_files(struct ieee80211_sub_if_data *sdata)\r\n{\r\nDEBUGFS_ADD(drop_unencrypted);\r\nDEBUGFS_ADD(rc_rateidx_mask_2ghz);\r\nDEBUGFS_ADD(rc_rateidx_mask_5ghz);\r\nDEBUGFS_ADD(rc_rateidx_mcs_mask_2ghz);\r\nDEBUGFS_ADD(rc_rateidx_mcs_mask_5ghz);\r\n}\r\nstatic void add_sta_files(struct ieee80211_sub_if_data *sdata)\r\n{\r\nDEBUGFS_ADD(bssid);\r\nDEBUGFS_ADD(aid);\r\nDEBUGFS_ADD(last_beacon);\r\nDEBUGFS_ADD(ave_beacon);\r\nDEBUGFS_ADD_MODE(smps, 0600);\r\nDEBUGFS_ADD_MODE(tkip_mic_test, 0200);\r\nDEBUGFS_ADD_MODE(uapsd_queues, 0600);\r\nDEBUGFS_ADD_MODE(uapsd_max_sp_len, 0600);\r\n}\r\nstatic void add_ap_files(struct ieee80211_sub_if_data *sdata)\r\n{\r\nDEBUGFS_ADD(num_mcast_sta);\r\nDEBUGFS_ADD(num_sta_ps);\r\nDEBUGFS_ADD(dtim_count);\r\nDEBUGFS_ADD(num_buffered_multicast);\r\nDEBUGFS_ADD_MODE(tkip_mic_test, 0200);\r\n}\r\nstatic void add_ibss_files(struct ieee80211_sub_if_data *sdata)\r\n{\r\nDEBUGFS_ADD_MODE(tsf, 0600);\r\n}\r\nstatic void add_wds_files(struct ieee80211_sub_if_data *sdata)\r\n{\r\nDEBUGFS_ADD(peer);\r\n}\r\nstatic void add_mesh_files(struct ieee80211_sub_if_data *sdata)\r\n{\r\nDEBUGFS_ADD_MODE(tsf, 0600);\r\n}\r\nstatic void add_mesh_stats(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct dentry *dir = debugfs_create_dir("mesh_stats",\r\nsdata->debugfs.dir);\r\n#define MESHSTATS_ADD(name)\\r\ndebugfs_create_file(#name, 0400, dir, sdata, &name##_ops);\r\nMESHSTATS_ADD(fwded_mcast);\r\nMESHSTATS_ADD(fwded_unicast);\r\nMESHSTATS_ADD(fwded_frames);\r\nMESHSTATS_ADD(dropped_frames_ttl);\r\nMESHSTATS_ADD(dropped_frames_no_route);\r\nMESHSTATS_ADD(dropped_frames_congestion);\r\nMESHSTATS_ADD(estab_plinks);\r\n#undef MESHSTATS_ADD\r\n}\r\nstatic void add_mesh_config(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct dentry *dir = debugfs_create_dir("mesh_config",\r\nsdata->debugfs.dir);\r\n#define MESHPARAMS_ADD(name) \\r\ndebugfs_create_file(#name, 0600, dir, sdata, &name##_ops);\r\nMESHPARAMS_ADD(dot11MeshMaxRetries);\r\nMESHPARAMS_ADD(dot11MeshRetryTimeout);\r\nMESHPARAMS_ADD(dot11MeshConfirmTimeout);\r\nMESHPARAMS_ADD(dot11MeshHoldingTimeout);\r\nMESHPARAMS_ADD(dot11MeshTTL);\r\nMESHPARAMS_ADD(element_ttl);\r\nMESHPARAMS_ADD(auto_open_plinks);\r\nMESHPARAMS_ADD(dot11MeshMaxPeerLinks);\r\nMESHPARAMS_ADD(dot11MeshHWMPactivePathTimeout);\r\nMESHPARAMS_ADD(dot11MeshHWMPpreqMinInterval);\r\nMESHPARAMS_ADD(dot11MeshHWMPperrMinInterval);\r\nMESHPARAMS_ADD(dot11MeshHWMPnetDiameterTraversalTime);\r\nMESHPARAMS_ADD(dot11MeshHWMPmaxPREQretries);\r\nMESHPARAMS_ADD(path_refresh_time);\r\nMESHPARAMS_ADD(min_discovery_timeout);\r\nMESHPARAMS_ADD(dot11MeshHWMPRootMode);\r\nMESHPARAMS_ADD(dot11MeshHWMPRannInterval);\r\nMESHPARAMS_ADD(dot11MeshForwarding);\r\nMESHPARAMS_ADD(dot11MeshGateAnnouncementProtocol);\r\nMESHPARAMS_ADD(rssi_threshold);\r\nMESHPARAMS_ADD(ht_opmode);\r\nMESHPARAMS_ADD(dot11MeshHWMPactivePathToRootTimeout);\r\nMESHPARAMS_ADD(dot11MeshHWMProotInterval);\r\nMESHPARAMS_ADD(dot11MeshHWMPconfirmationInterval);\r\n#undef MESHPARAMS_ADD\r\n}\r\nstatic void add_files(struct ieee80211_sub_if_data *sdata)\r\n{\r\nif (!sdata->debugfs.dir)\r\nreturn;\r\nDEBUGFS_ADD(flags);\r\nDEBUGFS_ADD(state);\r\nDEBUGFS_ADD(channel_type);\r\nif (sdata->vif.type != NL80211_IFTYPE_MONITOR)\r\nadd_common_files(sdata);\r\nswitch (sdata->vif.type) {\r\ncase NL80211_IFTYPE_MESH_POINT:\r\n#ifdef CONFIG_MAC80211_MESH\r\nadd_mesh_files(sdata);\r\nadd_mesh_stats(sdata);\r\nadd_mesh_config(sdata);\r\n#endif\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nadd_sta_files(sdata);\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nadd_ibss_files(sdata);\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nadd_ap_files(sdata);\r\nbreak;\r\ncase NL80211_IFTYPE_WDS:\r\nadd_wds_files(sdata);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid ieee80211_debugfs_add_netdev(struct ieee80211_sub_if_data *sdata)\r\n{\r\nchar buf[10+IFNAMSIZ];\r\nsprintf(buf, "netdev:%s", sdata->name);\r\nsdata->debugfs.dir = debugfs_create_dir(buf,\r\nsdata->local->hw.wiphy->debugfsdir);\r\nif (sdata->debugfs.dir)\r\nsdata->debugfs.subdir_stations = debugfs_create_dir("stations",\r\nsdata->debugfs.dir);\r\nadd_files(sdata);\r\n}\r\nvoid ieee80211_debugfs_remove_netdev(struct ieee80211_sub_if_data *sdata)\r\n{\r\nif (!sdata->debugfs.dir)\r\nreturn;\r\ndebugfs_remove_recursive(sdata->debugfs.dir);\r\nsdata->debugfs.dir = NULL;\r\n}\r\nvoid ieee80211_debugfs_rename_netdev(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct dentry *dir;\r\nchar buf[10 + IFNAMSIZ];\r\ndir = sdata->debugfs.dir;\r\nif (!dir)\r\nreturn;\r\nsprintf(buf, "netdev:%s", sdata->name);\r\nif (!debugfs_rename(dir->d_parent, dir, dir->d_parent, buf))\r\nsdata_err(sdata,\r\n"debugfs: failed to rename debugfs dir to %s\n",\r\nbuf);\r\n}
