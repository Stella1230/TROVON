static int tcf_skbedit(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nstruct tcf_skbedit *d = a->priv;\r\nspin_lock(&d->tcf_lock);\r\nd->tcf_tm.lastuse = jiffies;\r\nbstats_update(&d->tcf_bstats, skb);\r\nif (d->flags & SKBEDIT_F_PRIORITY)\r\nskb->priority = d->priority;\r\nif (d->flags & SKBEDIT_F_QUEUE_MAPPING &&\r\nskb->dev->real_num_tx_queues > d->queue_mapping)\r\nskb_set_queue_mapping(skb, d->queue_mapping);\r\nif (d->flags & SKBEDIT_F_MARK)\r\nskb->mark = d->mark;\r\nspin_unlock(&d->tcf_lock);\r\nreturn d->tcf_action;\r\n}\r\nstatic int tcf_skbedit_init(struct nlattr *nla, struct nlattr *est,\r\nstruct tc_action *a, int ovr, int bind)\r\n{\r\nstruct nlattr *tb[TCA_SKBEDIT_MAX + 1];\r\nstruct tc_skbedit *parm;\r\nstruct tcf_skbedit *d;\r\nstruct tcf_common *pc;\r\nu32 flags = 0, *priority = NULL, *mark = NULL;\r\nu16 *queue_mapping = NULL;\r\nint ret = 0, err;\r\nif (nla == NULL)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_SKBEDIT_MAX, nla, skbedit_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[TCA_SKBEDIT_PARMS] == NULL)\r\nreturn -EINVAL;\r\nif (tb[TCA_SKBEDIT_PRIORITY] != NULL) {\r\nflags |= SKBEDIT_F_PRIORITY;\r\npriority = nla_data(tb[TCA_SKBEDIT_PRIORITY]);\r\n}\r\nif (tb[TCA_SKBEDIT_QUEUE_MAPPING] != NULL) {\r\nflags |= SKBEDIT_F_QUEUE_MAPPING;\r\nqueue_mapping = nla_data(tb[TCA_SKBEDIT_QUEUE_MAPPING]);\r\n}\r\nif (tb[TCA_SKBEDIT_MARK] != NULL) {\r\nflags |= SKBEDIT_F_MARK;\r\nmark = nla_data(tb[TCA_SKBEDIT_MARK]);\r\n}\r\nif (!flags)\r\nreturn -EINVAL;\r\nparm = nla_data(tb[TCA_SKBEDIT_PARMS]);\r\npc = tcf_hash_check(parm->index, a, bind, &skbedit_hash_info);\r\nif (!pc) {\r\npc = tcf_hash_create(parm->index, est, a, sizeof(*d), bind,\r\n&skbedit_idx_gen, &skbedit_hash_info);\r\nif (IS_ERR(pc))\r\nreturn PTR_ERR(pc);\r\nd = to_skbedit(pc);\r\nret = ACT_P_CREATED;\r\n} else {\r\nd = to_skbedit(pc);\r\nif (!ovr) {\r\ntcf_hash_release(pc, bind, &skbedit_hash_info);\r\nreturn -EEXIST;\r\n}\r\n}\r\nspin_lock_bh(&d->tcf_lock);\r\nd->flags = flags;\r\nif (flags & SKBEDIT_F_PRIORITY)\r\nd->priority = *priority;\r\nif (flags & SKBEDIT_F_QUEUE_MAPPING)\r\nd->queue_mapping = *queue_mapping;\r\nif (flags & SKBEDIT_F_MARK)\r\nd->mark = *mark;\r\nd->tcf_action = parm->action;\r\nspin_unlock_bh(&d->tcf_lock);\r\nif (ret == ACT_P_CREATED)\r\ntcf_hash_insert(pc, &skbedit_hash_info);\r\nreturn ret;\r\n}\r\nstatic int tcf_skbedit_cleanup(struct tc_action *a, int bind)\r\n{\r\nstruct tcf_skbedit *d = a->priv;\r\nif (d)\r\nreturn tcf_hash_release(&d->common, bind, &skbedit_hash_info);\r\nreturn 0;\r\n}\r\nstatic int tcf_skbedit_dump(struct sk_buff *skb, struct tc_action *a,\r\nint bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_skbedit *d = a->priv;\r\nstruct tc_skbedit opt = {\r\n.index = d->tcf_index,\r\n.refcnt = d->tcf_refcnt - ref,\r\n.bindcnt = d->tcf_bindcnt - bind,\r\n.action = d->tcf_action,\r\n};\r\nstruct tcf_t t;\r\nif (nla_put(skb, TCA_SKBEDIT_PARMS, sizeof(opt), &opt))\r\ngoto nla_put_failure;\r\nif ((d->flags & SKBEDIT_F_PRIORITY) &&\r\nnla_put(skb, TCA_SKBEDIT_PRIORITY, sizeof(d->priority),\r\n&d->priority))\r\ngoto nla_put_failure;\r\nif ((d->flags & SKBEDIT_F_QUEUE_MAPPING) &&\r\nnla_put(skb, TCA_SKBEDIT_QUEUE_MAPPING,\r\nsizeof(d->queue_mapping), &d->queue_mapping))\r\ngoto nla_put_failure;\r\nif ((d->flags & SKBEDIT_F_MARK) &&\r\nnla_put(skb, TCA_SKBEDIT_MARK, sizeof(d->mark),\r\n&d->mark))\r\ngoto nla_put_failure;\r\nt.install = jiffies_to_clock_t(jiffies - d->tcf_tm.install);\r\nt.lastuse = jiffies_to_clock_t(jiffies - d->tcf_tm.lastuse);\r\nt.expires = jiffies_to_clock_t(d->tcf_tm.expires);\r\nif (nla_put(skb, TCA_SKBEDIT_TM, sizeof(t), &t))\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int __init skbedit_init_module(void)\r\n{\r\nreturn tcf_register_action(&act_skbedit_ops);\r\n}\r\nstatic void __exit skbedit_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_skbedit_ops);\r\n}
