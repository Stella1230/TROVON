static inline struct f_phonet *func_to_pn(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_phonet, function);\r\n}\r\nstatic int pn_net_open(struct net_device *dev)\r\n{\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int pn_net_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void pn_tx_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_phonet *fp = ep->driver_data;\r\nstruct net_device *dev = fp->dev;\r\nstruct sk_buff *skb = req->context;\r\nswitch (req->status) {\r\ncase 0:\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nbreak;\r\ncase -ESHUTDOWN:\r\ncase -ECONNRESET:\r\ndev->stats.tx_aborted_errors++;\r\ndefault:\r\ndev->stats.tx_errors++;\r\n}\r\ndev_kfree_skb_any(skb);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int pn_net_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct phonet_port *port = netdev_priv(dev);\r\nstruct f_phonet *fp;\r\nstruct usb_request *req;\r\nunsigned long flags;\r\nif (skb->protocol != htons(ETH_P_PHONET))\r\ngoto out;\r\nspin_lock_irqsave(&port->lock, flags);\r\nfp = port->usb;\r\nif (unlikely(!fp))\r\ngoto out_unlock;\r\nreq = fp->in_req;\r\nreq->buf = skb->data;\r\nreq->length = skb->len;\r\nreq->complete = pn_tx_complete;\r\nreq->zero = 1;\r\nreq->context = skb;\r\nif (unlikely(usb_ep_queue(fp->in_ep, req, GFP_ATOMIC)))\r\ngoto out_unlock;\r\nnetif_stop_queue(dev);\r\nskb = NULL;\r\nout_unlock:\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nout:\r\nif (unlikely(skb)) {\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int pn_net_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif ((new_mtu < PHONET_MIN_MTU) || (new_mtu > PHONET_MAX_MTU))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void pn_net_setup(struct net_device *dev)\r\n{\r\ndev->features = 0;\r\ndev->type = ARPHRD_PHONET;\r\ndev->flags = IFF_POINTOPOINT | IFF_NOARP;\r\ndev->mtu = PHONET_DEV_MTU;\r\ndev->hard_header_len = 1;\r\ndev->dev_addr[0] = PN_MEDIA_USB;\r\ndev->addr_len = 1;\r\ndev->tx_queue_len = 1;\r\ndev->netdev_ops = &pn_netdev_ops;\r\ndev->destructor = free_netdev;\r\ndev->header_ops = &phonet_header_ops;\r\n}\r\nstatic int\r\npn_rx_submit(struct f_phonet *fp, struct usb_request *req, gfp_t gfp_flags)\r\n{\r\nstruct page *page;\r\nint err;\r\npage = __skb_alloc_page(gfp_flags | __GFP_NOMEMALLOC, NULL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nreq->buf = page_address(page);\r\nreq->length = PAGE_SIZE;\r\nreq->context = page;\r\nerr = usb_ep_queue(fp->out_ep, req, gfp_flags);\r\nif (unlikely(err))\r\nput_page(page);\r\nreturn err;\r\n}\r\nstatic void pn_rx_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_phonet *fp = ep->driver_data;\r\nstruct net_device *dev = fp->dev;\r\nstruct page *page = req->context;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nint status = req->status;\r\nswitch (status) {\r\ncase 0:\r\nspin_lock_irqsave(&fp->rx.lock, flags);\r\nskb = fp->rx.skb;\r\nif (!skb)\r\nskb = fp->rx.skb = netdev_alloc_skb(dev, 12);\r\nif (req->actual < req->length)\r\nfp->rx.skb = NULL;\r\nspin_unlock_irqrestore(&fp->rx.lock, flags);\r\nif (unlikely(!skb))\r\nbreak;\r\nif (skb->len == 0) {\r\nskb->protocol = htons(ETH_P_PHONET);\r\nskb_reset_mac_header(skb);\r\nmemcpy(skb_put(skb, 1), page_address(page), 1);\r\n}\r\nskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,\r\nskb->len <= 1, req->actual, PAGE_SIZE);\r\npage = NULL;\r\nif (req->actual < req->length) {\r\nskb->dev = dev;\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nnetif_rx(skb);\r\n}\r\nbreak;\r\ncase -ESHUTDOWN:\r\ncase -ECONNABORTED:\r\ncase -ECONNRESET:\r\nreq = NULL;\r\nbreak;\r\ncase -EOVERFLOW:\r\ndev->stats.rx_over_errors++;\r\ndefault:\r\ndev->stats.rx_errors++;\r\nbreak;\r\n}\r\nif (page)\r\nput_page(page);\r\nif (req)\r\npn_rx_submit(fp, req, GFP_ATOMIC | __GFP_COLD);\r\n}\r\nstatic void __pn_reset(struct usb_function *f)\r\n{\r\nstruct f_phonet *fp = func_to_pn(f);\r\nstruct net_device *dev = fp->dev;\r\nstruct phonet_port *port = netdev_priv(dev);\r\nnetif_carrier_off(dev);\r\nport->usb = NULL;\r\nusb_ep_disable(fp->out_ep);\r\nusb_ep_disable(fp->in_ep);\r\nif (fp->rx.skb) {\r\ndev_kfree_skb_irq(fp->rx.skb);\r\nfp->rx.skb = NULL;\r\n}\r\n}\r\nstatic int pn_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_phonet *fp = func_to_pn(f);\r\nstruct usb_gadget *gadget = fp->function.config->cdev->gadget;\r\nif (intf == pn_control_intf_desc.bInterfaceNumber)\r\nreturn (alt > 0) ? -EINVAL : 0;\r\nif (intf == pn_data_intf_desc.bInterfaceNumber) {\r\nstruct net_device *dev = fp->dev;\r\nstruct phonet_port *port = netdev_priv(dev);\r\nif (alt > 1)\r\nreturn -EINVAL;\r\nspin_lock(&port->lock);\r\n__pn_reset(f);\r\nif (alt == 1) {\r\nint i;\r\nif (config_ep_by_speed(gadget, f, fp->in_ep) ||\r\nconfig_ep_by_speed(gadget, f, fp->out_ep)) {\r\nfp->in_ep->desc = NULL;\r\nfp->out_ep->desc = NULL;\r\nspin_unlock(&port->lock);\r\nreturn -EINVAL;\r\n}\r\nusb_ep_enable(fp->out_ep);\r\nusb_ep_enable(fp->in_ep);\r\nport->usb = fp;\r\nfp->out_ep->driver_data = fp;\r\nfp->in_ep->driver_data = fp;\r\nnetif_carrier_on(dev);\r\nfor (i = 0; i < phonet_rxq_size; i++)\r\npn_rx_submit(fp, fp->out_reqv[i], GFP_ATOMIC | __GFP_COLD);\r\n}\r\nspin_unlock(&port->lock);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int pn_get_alt(struct usb_function *f, unsigned intf)\r\n{\r\nstruct f_phonet *fp = func_to_pn(f);\r\nif (intf == pn_control_intf_desc.bInterfaceNumber)\r\nreturn 0;\r\nif (intf == pn_data_intf_desc.bInterfaceNumber) {\r\nstruct phonet_port *port = netdev_priv(fp->dev);\r\nu8 alt;\r\nspin_lock(&port->lock);\r\nalt = port->usb != NULL;\r\nspin_unlock(&port->lock);\r\nreturn alt;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void pn_disconnect(struct usb_function *f)\r\n{\r\nstruct f_phonet *fp = func_to_pn(f);\r\nstruct phonet_port *port = netdev_priv(fp->dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\n__pn_reset(f);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic __init\r\nint pn_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct f_phonet *fp = func_to_pn(f);\r\nstruct usb_ep *ep;\r\nint status, i;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto err;\r\npn_control_intf_desc.bInterfaceNumber = status;\r\npn_union_desc.bMasterInterface0 = status;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto err;\r\npn_data_nop_intf_desc.bInterfaceNumber = status;\r\npn_data_intf_desc.bInterfaceNumber = status;\r\npn_union_desc.bSlaveInterface0 = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(gadget, &pn_fs_sink_desc);\r\nif (!ep)\r\ngoto err;\r\nfp->out_ep = ep;\r\nep->driver_data = fp;\r\nep = usb_ep_autoconfig(gadget, &pn_fs_source_desc);\r\nif (!ep)\r\ngoto err;\r\nfp->in_ep = ep;\r\nep->driver_data = fp;\r\npn_hs_sink_desc.bEndpointAddress =\r\npn_fs_sink_desc.bEndpointAddress;\r\npn_hs_source_desc.bEndpointAddress =\r\npn_fs_source_desc.bEndpointAddress;\r\nfp->function.descriptors = fs_pn_function;\r\nfp->function.hs_descriptors = hs_pn_function;\r\nstatus = -ENOMEM;\r\nfor (i = 0; i < phonet_rxq_size; i++) {\r\nstruct usb_request *req;\r\nreq = usb_ep_alloc_request(fp->out_ep, GFP_KERNEL);\r\nif (!req)\r\ngoto err;\r\nreq->complete = pn_rx_complete;\r\nfp->out_reqv[i] = req;\r\n}\r\nfp->in_req = usb_ep_alloc_request(fp->in_ep, GFP_KERNEL);\r\nif (!fp->in_req)\r\ngoto err;\r\nINFO(cdev, "USB CDC Phonet function\n");\r\nINFO(cdev, "using %s, OUT %s, IN %s\n", cdev->gadget->name,\r\nfp->out_ep->name, fp->in_ep->name);\r\nreturn 0;\r\nerr:\r\nif (fp->out_ep)\r\nfp->out_ep->driver_data = NULL;\r\nif (fp->in_ep)\r\nfp->in_ep->driver_data = NULL;\r\nERROR(cdev, "USB CDC Phonet: cannot autoconfigure\n");\r\nreturn status;\r\n}\r\nstatic void\r\npn_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_phonet *fp = func_to_pn(f);\r\nint i;\r\nif (fp->in_req)\r\nusb_ep_free_request(fp->in_ep, fp->in_req);\r\nfor (i = 0; i < phonet_rxq_size; i++)\r\nif (fp->out_reqv[i])\r\nusb_ep_free_request(fp->out_ep, fp->out_reqv[i]);\r\nkfree(fp);\r\n}\r\nint __init phonet_bind_config(struct usb_configuration *c)\r\n{\r\nstruct f_phonet *fp;\r\nint err, size;\r\nsize = sizeof(*fp) + (phonet_rxq_size * sizeof(struct usb_request *));\r\nfp = kzalloc(size, GFP_KERNEL);\r\nif (!fp)\r\nreturn -ENOMEM;\r\nfp->dev = dev;\r\nfp->function.name = "phonet";\r\nfp->function.bind = pn_bind;\r\nfp->function.unbind = pn_unbind;\r\nfp->function.set_alt = pn_set_alt;\r\nfp->function.get_alt = pn_get_alt;\r\nfp->function.disable = pn_disconnect;\r\nspin_lock_init(&fp->rx.lock);\r\nerr = usb_add_function(c, &fp->function);\r\nif (err)\r\nkfree(fp);\r\nreturn err;\r\n}\r\nint __init gphonet_setup(struct usb_gadget *gadget)\r\n{\r\nstruct phonet_port *port;\r\nint err;\r\nBUG_ON(dev);\r\ndev = alloc_netdev(sizeof(*port), "upnlink%d", pn_net_setup);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nport = netdev_priv(dev);\r\nspin_lock_init(&port->lock);\r\nnetif_carrier_off(dev);\r\nSET_NETDEV_DEV(dev, &gadget->dev);\r\nerr = register_netdev(dev);\r\nif (err)\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nvoid gphonet_cleanup(void)\r\n{\r\nunregister_netdev(dev);\r\n}
