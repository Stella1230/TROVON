static void prepare_reply_buffer(struct rpc_rqst *req, struct page **pages,\r\nunsigned int base, unsigned int len,\r\nunsigned int bufsize)\r\n{\r\nstruct rpc_auth *auth = req->rq_cred->cr_auth;\r\nunsigned int replen;\r\nreplen = RPC_REPHDRSIZE + auth->au_rslack + bufsize;\r\nxdr_inline_pages(&req->rq_rcv_buf, replen << 2, pages, base, len);\r\n}\r\nstatic void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\r\n{\r\ndprintk("NFS: %s prematurely hit the end of our receive buffer. "\r\n"Remaining buffer length is %tu words.\n",\r\nfunc, xdr->end - xdr->p);\r\n}\r\nstatic void encode_uint32(struct xdr_stream *xdr, u32 value)\r\n{\r\n__be32 *p = xdr_reserve_space(xdr, 4);\r\n*p = cpu_to_be32(value);\r\n}\r\nstatic int decode_uint32(struct xdr_stream *xdr, u32 *value)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\n*value = be32_to_cpup(p);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic int decode_uint64(struct xdr_stream *xdr, u64 *value)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 8);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nxdr_decode_hyper(p, value);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic __be32 *xdr_decode_fileid3(__be32 *p, u64 *fileid)\r\n{\r\nreturn xdr_decode_hyper(p, fileid);\r\n}\r\nstatic int decode_fileid3(struct xdr_stream *xdr, u64 *fileid)\r\n{\r\nreturn decode_uint64(xdr, fileid);\r\n}\r\nstatic void encode_filename3(struct xdr_stream *xdr,\r\nconst char *name, u32 length)\r\n{\r\n__be32 *p;\r\nBUG_ON(length > NFS3_MAXNAMLEN);\r\np = xdr_reserve_space(xdr, 4 + length);\r\nxdr_encode_opaque(p, name, length);\r\n}\r\nstatic int decode_inline_filename3(struct xdr_stream *xdr,\r\nconst char **name, u32 *length)\r\n{\r\n__be32 *p;\r\nu32 count;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\ncount = be32_to_cpup(p);\r\nif (count > NFS3_MAXNAMLEN)\r\ngoto out_nametoolong;\r\np = xdr_inline_decode(xdr, count);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\n*name = (const char *)p;\r\n*length = count;\r\nreturn 0;\r\nout_nametoolong:\r\ndprintk("NFS: returned filename too long: %u\n", count);\r\nreturn -ENAMETOOLONG;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_nfspath3(struct xdr_stream *xdr, struct page **pages,\r\nconst u32 length)\r\n{\r\nBUG_ON(length > NFS3_MAXPATHLEN);\r\nencode_uint32(xdr, length);\r\nxdr_write_pages(xdr, pages, 0, length);\r\n}\r\nstatic int decode_nfspath3(struct xdr_stream *xdr)\r\n{\r\nu32 recvd, count;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\ncount = be32_to_cpup(p);\r\nif (unlikely(count >= xdr->buf->page_len || count > NFS3_MAXPATHLEN))\r\ngoto out_nametoolong;\r\nrecvd = xdr_read_pages(xdr, count);\r\nif (unlikely(count > recvd))\r\ngoto out_cheating;\r\nxdr_terminate_string(xdr->buf, count);\r\nreturn 0;\r\nout_nametoolong:\r\ndprintk("NFS: returned pathname too long: %u\n", count);\r\nreturn -ENAMETOOLONG;\r\nout_cheating:\r\ndprintk("NFS: server cheating in pathname result: "\r\n"count %u > recvd %u\n", count, recvd);\r\nreturn -EIO;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic __be32 *xdr_encode_cookie3(__be32 *p, u64 cookie)\r\n{\r\nreturn xdr_encode_hyper(p, cookie);\r\n}\r\nstatic int decode_cookie3(struct xdr_stream *xdr, u64 *cookie)\r\n{\r\nreturn decode_uint64(xdr, cookie);\r\n}\r\nstatic __be32 *xdr_encode_cookieverf3(__be32 *p, const __be32 *verifier)\r\n{\r\nmemcpy(p, verifier, NFS3_COOKIEVERFSIZE);\r\nreturn p + XDR_QUADLEN(NFS3_COOKIEVERFSIZE);\r\n}\r\nstatic int decode_cookieverf3(struct xdr_stream *xdr, __be32 *verifier)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, NFS3_COOKIEVERFSIZE);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nmemcpy(verifier, p, NFS3_COOKIEVERFSIZE);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_createverf3(struct xdr_stream *xdr, const __be32 *verifier)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, NFS3_CREATEVERFSIZE);\r\nmemcpy(p, verifier, NFS3_CREATEVERFSIZE);\r\n}\r\nstatic int decode_writeverf3(struct xdr_stream *xdr, struct nfs_write_verifier *verifier)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, NFS3_WRITEVERFSIZE);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nmemcpy(verifier->data, p, NFS3_WRITEVERFSIZE);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic __be32 *xdr_decode_size3(__be32 *p, u64 *size)\r\n{\r\nreturn xdr_decode_hyper(p, size);\r\n}\r\nstatic int decode_nfsstat3(struct xdr_stream *xdr, enum nfs_stat *status)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\n*status = be32_to_cpup(p);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_ftype3(struct xdr_stream *xdr, const u32 type)\r\n{\r\nBUG_ON(type > NF3FIFO);\r\nencode_uint32(xdr, type);\r\n}\r\nstatic __be32 *xdr_decode_ftype3(__be32 *p, umode_t *mode)\r\n{\r\nu32 type;\r\ntype = be32_to_cpup(p++);\r\nif (type > NF3FIFO)\r\ntype = NF3NON;\r\n*mode = nfs_type2fmt[type];\r\nreturn p;\r\n}\r\nstatic void encode_specdata3(struct xdr_stream *xdr, const dev_t rdev)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 8);\r\n*p++ = cpu_to_be32(MAJOR(rdev));\r\n*p = cpu_to_be32(MINOR(rdev));\r\n}\r\nstatic __be32 *xdr_decode_specdata3(__be32 *p, dev_t *rdev)\r\n{\r\nunsigned int major, minor;\r\nmajor = be32_to_cpup(p++);\r\nminor = be32_to_cpup(p++);\r\n*rdev = MKDEV(major, minor);\r\nif (MAJOR(*rdev) != major || MINOR(*rdev) != minor)\r\n*rdev = 0;\r\nreturn p;\r\n}\r\nstatic void encode_nfs_fh3(struct xdr_stream *xdr, const struct nfs_fh *fh)\r\n{\r\n__be32 *p;\r\nBUG_ON(fh->size > NFS3_FHSIZE);\r\np = xdr_reserve_space(xdr, 4 + fh->size);\r\nxdr_encode_opaque(p, fh->data, fh->size);\r\n}\r\nstatic int decode_nfs_fh3(struct xdr_stream *xdr, struct nfs_fh *fh)\r\n{\r\nu32 length;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nlength = be32_to_cpup(p++);\r\nif (unlikely(length > NFS3_FHSIZE))\r\ngoto out_toobig;\r\np = xdr_inline_decode(xdr, length);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nfh->size = length;\r\nmemcpy(fh->data, p, length);\r\nreturn 0;\r\nout_toobig:\r\ndprintk("NFS: file handle size (%u) too big\n", length);\r\nreturn -E2BIG;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void zero_nfs_fh3(struct nfs_fh *fh)\r\n{\r\nmemset(fh, 0, sizeof(*fh));\r\n}\r\nstatic __be32 *xdr_encode_nfstime3(__be32 *p, const struct timespec *timep)\r\n{\r\n*p++ = cpu_to_be32(timep->tv_sec);\r\n*p++ = cpu_to_be32(timep->tv_nsec);\r\nreturn p;\r\n}\r\nstatic __be32 *xdr_decode_nfstime3(__be32 *p, struct timespec *timep)\r\n{\r\ntimep->tv_sec = be32_to_cpup(p++);\r\ntimep->tv_nsec = be32_to_cpup(p++);\r\nreturn p;\r\n}\r\nstatic void encode_sattr3(struct xdr_stream *xdr, const struct iattr *attr)\r\n{\r\nu32 nbytes;\r\n__be32 *p;\r\nnbytes = 6 * 4;\r\nif (attr->ia_valid & ATTR_MODE)\r\nnbytes += 4;\r\nif (attr->ia_valid & ATTR_UID)\r\nnbytes += 4;\r\nif (attr->ia_valid & ATTR_GID)\r\nnbytes += 4;\r\nif (attr->ia_valid & ATTR_SIZE)\r\nnbytes += 8;\r\nif (attr->ia_valid & ATTR_ATIME_SET)\r\nnbytes += 8;\r\nif (attr->ia_valid & ATTR_MTIME_SET)\r\nnbytes += 8;\r\np = xdr_reserve_space(xdr, nbytes);\r\nif (attr->ia_valid & ATTR_MODE) {\r\n*p++ = xdr_one;\r\n*p++ = cpu_to_be32(attr->ia_mode & S_IALLUGO);\r\n} else\r\n*p++ = xdr_zero;\r\nif (attr->ia_valid & ATTR_UID) {\r\n*p++ = xdr_one;\r\n*p++ = cpu_to_be32(attr->ia_uid);\r\n} else\r\n*p++ = xdr_zero;\r\nif (attr->ia_valid & ATTR_GID) {\r\n*p++ = xdr_one;\r\n*p++ = cpu_to_be32(attr->ia_gid);\r\n} else\r\n*p++ = xdr_zero;\r\nif (attr->ia_valid & ATTR_SIZE) {\r\n*p++ = xdr_one;\r\np = xdr_encode_hyper(p, (u64)attr->ia_size);\r\n} else\r\n*p++ = xdr_zero;\r\nif (attr->ia_valid & ATTR_ATIME_SET) {\r\n*p++ = xdr_two;\r\np = xdr_encode_nfstime3(p, &attr->ia_atime);\r\n} else if (attr->ia_valid & ATTR_ATIME) {\r\n*p++ = xdr_one;\r\n} else\r\n*p++ = xdr_zero;\r\nif (attr->ia_valid & ATTR_MTIME_SET) {\r\n*p++ = xdr_two;\r\nxdr_encode_nfstime3(p, &attr->ia_mtime);\r\n} else if (attr->ia_valid & ATTR_MTIME) {\r\n*p = xdr_one;\r\n} else\r\n*p = xdr_zero;\r\n}\r\nstatic int decode_fattr3(struct xdr_stream *xdr, struct nfs_fattr *fattr)\r\n{\r\numode_t fmode;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, NFS3_fattr_sz << 2);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\np = xdr_decode_ftype3(p, &fmode);\r\nfattr->mode = (be32_to_cpup(p++) & ~S_IFMT) | fmode;\r\nfattr->nlink = be32_to_cpup(p++);\r\nfattr->uid = be32_to_cpup(p++);\r\nfattr->gid = be32_to_cpup(p++);\r\np = xdr_decode_size3(p, &fattr->size);\r\np = xdr_decode_size3(p, &fattr->du.nfs3.used);\r\np = xdr_decode_specdata3(p, &fattr->rdev);\r\np = xdr_decode_hyper(p, &fattr->fsid.major);\r\nfattr->fsid.minor = 0;\r\np = xdr_decode_fileid3(p, &fattr->fileid);\r\np = xdr_decode_nfstime3(p, &fattr->atime);\r\np = xdr_decode_nfstime3(p, &fattr->mtime);\r\nxdr_decode_nfstime3(p, &fattr->ctime);\r\nfattr->change_attr = nfs_timespec_to_change_attr(&fattr->ctime);\r\nfattr->valid |= NFS_ATTR_FATTR_V3;\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic int decode_post_op_attr(struct xdr_stream *xdr, struct nfs_fattr *fattr)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nif (*p != xdr_zero)\r\nreturn decode_fattr3(xdr, fattr);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic int decode_wcc_attr(struct xdr_stream *xdr, struct nfs_fattr *fattr)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, NFS3_wcc_attr_sz << 2);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nfattr->valid |= NFS_ATTR_FATTR_PRESIZE\r\n| NFS_ATTR_FATTR_PRECHANGE\r\n| NFS_ATTR_FATTR_PREMTIME\r\n| NFS_ATTR_FATTR_PRECTIME;\r\np = xdr_decode_size3(p, &fattr->pre_size);\r\np = xdr_decode_nfstime3(p, &fattr->pre_mtime);\r\nxdr_decode_nfstime3(p, &fattr->pre_ctime);\r\nfattr->pre_change_attr = nfs_timespec_to_change_attr(&fattr->pre_ctime);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic int decode_pre_op_attr(struct xdr_stream *xdr, struct nfs_fattr *fattr)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nif (*p != xdr_zero)\r\nreturn decode_wcc_attr(xdr, fattr);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic int decode_wcc_data(struct xdr_stream *xdr, struct nfs_fattr *fattr)\r\n{\r\nint error;\r\nerror = decode_pre_op_attr(xdr, fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_post_op_attr(xdr, fattr);\r\nout:\r\nreturn error;\r\n}\r\nstatic int decode_post_op_fh3(struct xdr_stream *xdr, struct nfs_fh *fh)\r\n{\r\n__be32 *p = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nif (*p != xdr_zero)\r\nreturn decode_nfs_fh3(xdr, fh);\r\nzero_nfs_fh3(fh);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_diropargs3(struct xdr_stream *xdr, const struct nfs_fh *fh,\r\nconst char *name, u32 length)\r\n{\r\nencode_nfs_fh3(xdr, fh);\r\nencode_filename3(xdr, name, length);\r\n}\r\nstatic void nfs3_xdr_enc_getattr3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_fh *fh)\r\n{\r\nencode_nfs_fh3(xdr, fh);\r\n}\r\nstatic void encode_sattrguard3(struct xdr_stream *xdr,\r\nconst struct nfs3_sattrargs *args)\r\n{\r\n__be32 *p;\r\nif (args->guard) {\r\np = xdr_reserve_space(xdr, 4 + 8);\r\n*p++ = xdr_one;\r\nxdr_encode_nfstime3(p, &args->guardtime);\r\n} else {\r\np = xdr_reserve_space(xdr, 4);\r\n*p = xdr_zero;\r\n}\r\n}\r\nstatic void nfs3_xdr_enc_setattr3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs3_sattrargs *args)\r\n{\r\nencode_nfs_fh3(xdr, args->fh);\r\nencode_sattr3(xdr, args->sattr);\r\nencode_sattrguard3(xdr, args);\r\n}\r\nstatic void nfs3_xdr_enc_lookup3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs3_diropargs *args)\r\n{\r\nencode_diropargs3(xdr, args->fh, args->name, args->len);\r\n}\r\nstatic void encode_access3args(struct xdr_stream *xdr,\r\nconst struct nfs3_accessargs *args)\r\n{\r\nencode_nfs_fh3(xdr, args->fh);\r\nencode_uint32(xdr, args->access);\r\n}\r\nstatic void nfs3_xdr_enc_access3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs3_accessargs *args)\r\n{\r\nencode_access3args(xdr, args);\r\n}\r\nstatic void nfs3_xdr_enc_readlink3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs3_readlinkargs *args)\r\n{\r\nencode_nfs_fh3(xdr, args->fh);\r\nprepare_reply_buffer(req, args->pages, args->pgbase,\r\nargs->pglen, NFS3_readlinkres_sz);\r\n}\r\nstatic void encode_read3args(struct xdr_stream *xdr,\r\nconst struct nfs_readargs *args)\r\n{\r\n__be32 *p;\r\nencode_nfs_fh3(xdr, args->fh);\r\np = xdr_reserve_space(xdr, 8 + 4);\r\np = xdr_encode_hyper(p, args->offset);\r\n*p = cpu_to_be32(args->count);\r\n}\r\nstatic void nfs3_xdr_enc_read3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_readargs *args)\r\n{\r\nencode_read3args(xdr, args);\r\nprepare_reply_buffer(req, args->pages, args->pgbase,\r\nargs->count, NFS3_readres_sz);\r\nreq->rq_rcv_buf.flags |= XDRBUF_READ;\r\n}\r\nstatic void encode_write3args(struct xdr_stream *xdr,\r\nconst struct nfs_writeargs *args)\r\n{\r\n__be32 *p;\r\nencode_nfs_fh3(xdr, args->fh);\r\np = xdr_reserve_space(xdr, 8 + 4 + 4 + 4);\r\np = xdr_encode_hyper(p, args->offset);\r\n*p++ = cpu_to_be32(args->count);\r\n*p++ = cpu_to_be32(args->stable);\r\n*p = cpu_to_be32(args->count);\r\nxdr_write_pages(xdr, args->pages, args->pgbase, args->count);\r\n}\r\nstatic void nfs3_xdr_enc_write3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_writeargs *args)\r\n{\r\nencode_write3args(xdr, args);\r\nxdr->buf->flags |= XDRBUF_WRITE;\r\n}\r\nstatic void encode_createhow3(struct xdr_stream *xdr,\r\nconst struct nfs3_createargs *args)\r\n{\r\nencode_uint32(xdr, args->createmode);\r\nswitch (args->createmode) {\r\ncase NFS3_CREATE_UNCHECKED:\r\ncase NFS3_CREATE_GUARDED:\r\nencode_sattr3(xdr, args->sattr);\r\nbreak;\r\ncase NFS3_CREATE_EXCLUSIVE:\r\nencode_createverf3(xdr, args->verifier);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void nfs3_xdr_enc_create3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs3_createargs *args)\r\n{\r\nencode_diropargs3(xdr, args->fh, args->name, args->len);\r\nencode_createhow3(xdr, args);\r\n}\r\nstatic void nfs3_xdr_enc_mkdir3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs3_mkdirargs *args)\r\n{\r\nencode_diropargs3(xdr, args->fh, args->name, args->len);\r\nencode_sattr3(xdr, args->sattr);\r\n}\r\nstatic void encode_symlinkdata3(struct xdr_stream *xdr,\r\nconst struct nfs3_symlinkargs *args)\r\n{\r\nencode_sattr3(xdr, args->sattr);\r\nencode_nfspath3(xdr, args->pages, args->pathlen);\r\n}\r\nstatic void nfs3_xdr_enc_symlink3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs3_symlinkargs *args)\r\n{\r\nencode_diropargs3(xdr, args->fromfh, args->fromname, args->fromlen);\r\nencode_symlinkdata3(xdr, args);\r\n}\r\nstatic void encode_devicedata3(struct xdr_stream *xdr,\r\nconst struct nfs3_mknodargs *args)\r\n{\r\nencode_sattr3(xdr, args->sattr);\r\nencode_specdata3(xdr, args->rdev);\r\n}\r\nstatic void encode_mknoddata3(struct xdr_stream *xdr,\r\nconst struct nfs3_mknodargs *args)\r\n{\r\nencode_ftype3(xdr, args->type);\r\nswitch (args->type) {\r\ncase NF3CHR:\r\ncase NF3BLK:\r\nencode_devicedata3(xdr, args);\r\nbreak;\r\ncase NF3SOCK:\r\ncase NF3FIFO:\r\nencode_sattr3(xdr, args->sattr);\r\nbreak;\r\ncase NF3REG:\r\ncase NF3DIR:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void nfs3_xdr_enc_mknod3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs3_mknodargs *args)\r\n{\r\nencode_diropargs3(xdr, args->fh, args->name, args->len);\r\nencode_mknoddata3(xdr, args);\r\n}\r\nstatic void nfs3_xdr_enc_remove3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_removeargs *args)\r\n{\r\nencode_diropargs3(xdr, args->fh, args->name.name, args->name.len);\r\n}\r\nstatic void nfs3_xdr_enc_rename3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_renameargs *args)\r\n{\r\nconst struct qstr *old = args->old_name;\r\nconst struct qstr *new = args->new_name;\r\nencode_diropargs3(xdr, args->old_dir, old->name, old->len);\r\nencode_diropargs3(xdr, args->new_dir, new->name, new->len);\r\n}\r\nstatic void nfs3_xdr_enc_link3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs3_linkargs *args)\r\n{\r\nencode_nfs_fh3(xdr, args->fromfh);\r\nencode_diropargs3(xdr, args->tofh, args->toname, args->tolen);\r\n}\r\nstatic void encode_readdir3args(struct xdr_stream *xdr,\r\nconst struct nfs3_readdirargs *args)\r\n{\r\n__be32 *p;\r\nencode_nfs_fh3(xdr, args->fh);\r\np = xdr_reserve_space(xdr, 8 + NFS3_COOKIEVERFSIZE + 4);\r\np = xdr_encode_cookie3(p, args->cookie);\r\np = xdr_encode_cookieverf3(p, args->verf);\r\n*p = cpu_to_be32(args->count);\r\n}\r\nstatic void nfs3_xdr_enc_readdir3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs3_readdirargs *args)\r\n{\r\nencode_readdir3args(xdr, args);\r\nprepare_reply_buffer(req, args->pages, 0,\r\nargs->count, NFS3_readdirres_sz);\r\n}\r\nstatic void encode_readdirplus3args(struct xdr_stream *xdr,\r\nconst struct nfs3_readdirargs *args)\r\n{\r\n__be32 *p;\r\nencode_nfs_fh3(xdr, args->fh);\r\np = xdr_reserve_space(xdr, 8 + NFS3_COOKIEVERFSIZE + 4 + 4);\r\np = xdr_encode_cookie3(p, args->cookie);\r\np = xdr_encode_cookieverf3(p, args->verf);\r\n*p++ = cpu_to_be32(args->count >> 3);\r\n*p = cpu_to_be32(args->count);\r\n}\r\nstatic void nfs3_xdr_enc_readdirplus3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs3_readdirargs *args)\r\n{\r\nencode_readdirplus3args(xdr, args);\r\nprepare_reply_buffer(req, args->pages, 0,\r\nargs->count, NFS3_readdirres_sz);\r\n}\r\nstatic void encode_commit3args(struct xdr_stream *xdr,\r\nconst struct nfs_commitargs *args)\r\n{\r\n__be32 *p;\r\nencode_nfs_fh3(xdr, args->fh);\r\np = xdr_reserve_space(xdr, 8 + 4);\r\np = xdr_encode_hyper(p, args->offset);\r\n*p = cpu_to_be32(args->count);\r\n}\r\nstatic void nfs3_xdr_enc_commit3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs_commitargs *args)\r\n{\r\nencode_commit3args(xdr, args);\r\n}\r\nstatic void nfs3_xdr_enc_getacl3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs3_getaclargs *args)\r\n{\r\nencode_nfs_fh3(xdr, args->fh);\r\nencode_uint32(xdr, args->mask);\r\nif (args->mask & (NFS_ACL | NFS_DFACL))\r\nprepare_reply_buffer(req, args->pages, 0,\r\nNFSACL_MAXPAGES << PAGE_SHIFT,\r\nACL3_getaclres_sz);\r\n}\r\nstatic void nfs3_xdr_enc_setacl3args(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nfs3_setaclargs *args)\r\n{\r\nunsigned int base;\r\nint error;\r\nencode_nfs_fh3(xdr, NFS_FH(args->inode));\r\nencode_uint32(xdr, args->mask);\r\nbase = req->rq_slen;\r\nif (args->npages != 0)\r\nxdr_write_pages(xdr, args->pages, 0, args->len);\r\nelse\r\nxdr_reserve_space(xdr, NFS_ACL_INLINE_BUFSIZE);\r\nerror = nfsacl_encode(xdr->buf, base, args->inode,\r\n(args->mask & NFS_ACL) ?\r\nargs->acl_access : NULL, 1, 0);\r\nBUG_ON(error < 0);\r\nerror = nfsacl_encode(xdr->buf, base + error, args->inode,\r\n(args->mask & NFS_DFACL) ?\r\nargs->acl_default : NULL, 1,\r\nNFS_ACL_DEFAULT);\r\nBUG_ON(error < 0);\r\n}\r\nstatic int nfs3_xdr_dec_getattr3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs_fattr *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_default;\r\nerror = decode_fattr3(xdr, result);\r\nout:\r\nreturn error;\r\nout_default:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int nfs3_xdr_dec_setattr3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs_fattr *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_wcc_data(xdr, result);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_status;\r\nout:\r\nreturn error;\r\nout_status:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int nfs3_xdr_dec_lookup3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs3_diropres *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_default;\r\nerror = decode_nfs_fh3(xdr, result->fh);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_post_op_attr(xdr, result->fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_post_op_attr(xdr, result->dir_attr);\r\nout:\r\nreturn error;\r\nout_default:\r\nerror = decode_post_op_attr(xdr, result->dir_attr);\r\nif (unlikely(error))\r\ngoto out;\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int nfs3_xdr_dec_access3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs3_accessres *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_post_op_attr(xdr, result->fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_default;\r\nerror = decode_uint32(xdr, &result->access);\r\nout:\r\nreturn error;\r\nout_default:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int nfs3_xdr_dec_readlink3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs_fattr *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_post_op_attr(xdr, result);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_default;\r\nerror = decode_nfspath3(xdr);\r\nout:\r\nreturn error;\r\nout_default:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int decode_read3resok(struct xdr_stream *xdr,\r\nstruct nfs_readres *result)\r\n{\r\nu32 eof, count, ocount, recvd;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4 + 4 + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\ncount = be32_to_cpup(p++);\r\neof = be32_to_cpup(p++);\r\nocount = be32_to_cpup(p++);\r\nif (unlikely(ocount != count))\r\ngoto out_mismatch;\r\nrecvd = xdr_read_pages(xdr, count);\r\nif (unlikely(count > recvd))\r\ngoto out_cheating;\r\nout:\r\nresult->eof = eof;\r\nresult->count = count;\r\nreturn count;\r\nout_mismatch:\r\ndprintk("NFS: READ count doesn't match length of opaque: "\r\n"count %u != ocount %u\n", count, ocount);\r\nreturn -EIO;\r\nout_cheating:\r\ndprintk("NFS: server cheating in read result: "\r\n"count %u > recvd %u\n", count, recvd);\r\ncount = recvd;\r\neof = 0;\r\ngoto out;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic int nfs3_xdr_dec_read3res(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nstruct nfs_readres *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_post_op_attr(xdr, result->fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_status;\r\nerror = decode_read3resok(xdr, result);\r\nout:\r\nreturn error;\r\nout_status:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int decode_write3resok(struct xdr_stream *xdr,\r\nstruct nfs_writeres *result)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4 + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nresult->count = be32_to_cpup(p++);\r\nresult->verf->committed = be32_to_cpup(p++);\r\nif (unlikely(result->verf->committed > NFS_FILE_SYNC))\r\ngoto out_badvalue;\r\nif (decode_writeverf3(xdr, &result->verf->verifier))\r\ngoto out_eio;\r\nreturn result->count;\r\nout_badvalue:\r\ndprintk("NFS: bad stable_how value: %u\n", result->verf->committed);\r\nreturn -EIO;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nout_eio:\r\nreturn -EIO;\r\n}\r\nstatic int nfs3_xdr_dec_write3res(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nstruct nfs_writeres *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_wcc_data(xdr, result->fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_status;\r\nerror = decode_write3resok(xdr, result);\r\nout:\r\nreturn error;\r\nout_status:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int decode_create3resok(struct xdr_stream *xdr,\r\nstruct nfs3_diropres *result)\r\n{\r\nint error;\r\nerror = decode_post_op_fh3(xdr, result->fh);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_post_op_attr(xdr, result->fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nif (result->fh->size == 0)\r\nresult->fattr->valid = 0;\r\nerror = decode_wcc_data(xdr, result->dir_attr);\r\nout:\r\nreturn error;\r\n}\r\nstatic int nfs3_xdr_dec_create3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs3_diropres *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_default;\r\nerror = decode_create3resok(xdr, result);\r\nout:\r\nreturn error;\r\nout_default:\r\nerror = decode_wcc_data(xdr, result->dir_attr);\r\nif (unlikely(error))\r\ngoto out;\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int nfs3_xdr_dec_remove3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs_removeres *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_wcc_data(xdr, result->dir_attr);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_status;\r\nout:\r\nreturn error;\r\nout_status:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int nfs3_xdr_dec_rename3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs_renameres *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_wcc_data(xdr, result->old_fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_wcc_data(xdr, result->new_fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_status;\r\nout:\r\nreturn error;\r\nout_status:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int nfs3_xdr_dec_link3res(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nstruct nfs3_linkres *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_post_op_attr(xdr, result->fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_wcc_data(xdr, result->dir_attr);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_status;\r\nout:\r\nreturn error;\r\nout_status:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nint nfs3_decode_dirent(struct xdr_stream *xdr, struct nfs_entry *entry,\r\nint plus)\r\n{\r\nstruct nfs_entry old = *entry;\r\n__be32 *p;\r\nint error;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nif (*p == xdr_zero) {\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nif (*p == xdr_zero)\r\nreturn -EAGAIN;\r\nentry->eof = 1;\r\nreturn -EBADCOOKIE;\r\n}\r\nerror = decode_fileid3(xdr, &entry->ino);\r\nif (unlikely(error))\r\nreturn error;\r\nerror = decode_inline_filename3(xdr, &entry->name, &entry->len);\r\nif (unlikely(error))\r\nreturn error;\r\nentry->prev_cookie = entry->cookie;\r\nerror = decode_cookie3(xdr, &entry->cookie);\r\nif (unlikely(error))\r\nreturn error;\r\nentry->d_type = DT_UNKNOWN;\r\nif (plus) {\r\nentry->fattr->valid = 0;\r\nerror = decode_post_op_attr(xdr, entry->fattr);\r\nif (unlikely(error))\r\nreturn error;\r\nif (entry->fattr->valid & NFS_ATTR_FATTR_V3)\r\nentry->d_type = nfs_umode_to_dtype(entry->fattr->mode);\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nif (*p != xdr_zero) {\r\nerror = decode_nfs_fh3(xdr, entry->fh);\r\nif (unlikely(error)) {\r\nif (error == -E2BIG)\r\ngoto out_truncated;\r\nreturn error;\r\n}\r\n} else\r\nzero_nfs_fh3(entry->fh);\r\n}\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EAGAIN;\r\nout_truncated:\r\ndprintk("NFS: directory entry contains invalid file handle\n");\r\n*entry = old;\r\nreturn -EAGAIN;\r\n}\r\nstatic int decode_dirlist3(struct xdr_stream *xdr)\r\n{\r\nreturn xdr_read_pages(xdr, xdr->buf->page_len);\r\n}\r\nstatic int decode_readdir3resok(struct xdr_stream *xdr,\r\nstruct nfs3_readdirres *result)\r\n{\r\nint error;\r\nerror = decode_post_op_attr(xdr, result->dir_attr);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_cookieverf3(xdr, result->verf);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_dirlist3(xdr);\r\nout:\r\nreturn error;\r\n}\r\nstatic int nfs3_xdr_dec_readdir3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs3_readdirres *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_default;\r\nerror = decode_readdir3resok(xdr, result);\r\nout:\r\nreturn error;\r\nout_default:\r\nerror = decode_post_op_attr(xdr, result->dir_attr);\r\nif (unlikely(error))\r\ngoto out;\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int decode_fsstat3resok(struct xdr_stream *xdr,\r\nstruct nfs_fsstat *result)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 8 * 6 + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\np = xdr_decode_size3(p, &result->tbytes);\r\np = xdr_decode_size3(p, &result->fbytes);\r\np = xdr_decode_size3(p, &result->abytes);\r\np = xdr_decode_size3(p, &result->tfiles);\r\np = xdr_decode_size3(p, &result->ffiles);\r\nxdr_decode_size3(p, &result->afiles);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic int nfs3_xdr_dec_fsstat3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs_fsstat *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_post_op_attr(xdr, result->fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_status;\r\nerror = decode_fsstat3resok(xdr, result);\r\nout:\r\nreturn error;\r\nout_status:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int decode_fsinfo3resok(struct xdr_stream *xdr,\r\nstruct nfs_fsinfo *result)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4 * 7 + 8 + 8 + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nresult->rtmax = be32_to_cpup(p++);\r\nresult->rtpref = be32_to_cpup(p++);\r\nresult->rtmult = be32_to_cpup(p++);\r\nresult->wtmax = be32_to_cpup(p++);\r\nresult->wtpref = be32_to_cpup(p++);\r\nresult->wtmult = be32_to_cpup(p++);\r\nresult->dtpref = be32_to_cpup(p++);\r\np = xdr_decode_size3(p, &result->maxfilesize);\r\nxdr_decode_nfstime3(p, &result->time_delta);\r\nresult->lease_time = 0;\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic int nfs3_xdr_dec_fsinfo3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs_fsinfo *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_post_op_attr(xdr, result->fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_status;\r\nerror = decode_fsinfo3resok(xdr, result);\r\nout:\r\nreturn error;\r\nout_status:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int decode_pathconf3resok(struct xdr_stream *xdr,\r\nstruct nfs_pathconf *result)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4 * 6);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nresult->max_link = be32_to_cpup(p++);\r\nresult->max_namelen = be32_to_cpup(p);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic int nfs3_xdr_dec_pathconf3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs_pathconf *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_post_op_attr(xdr, result->fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_status;\r\nerror = decode_pathconf3resok(xdr, result);\r\nout:\r\nreturn error;\r\nout_status:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int nfs3_xdr_dec_commit3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs_commitres *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_wcc_data(xdr, result->fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_status;\r\nerror = decode_writeverf3(xdr, &result->verf->verifier);\r\nout:\r\nreturn error;\r\nout_status:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic inline int decode_getacl3resok(struct xdr_stream *xdr,\r\nstruct nfs3_getaclres *result)\r\n{\r\nstruct posix_acl **acl;\r\nunsigned int *aclcnt;\r\nsize_t hdrlen;\r\nint error;\r\nerror = decode_post_op_attr(xdr, result->fattr);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_uint32(xdr, &result->mask);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = -EINVAL;\r\nif (result->mask & ~(NFS_ACL|NFS_ACLCNT|NFS_DFACL|NFS_DFACLCNT))\r\ngoto out;\r\nhdrlen = xdr_stream_pos(xdr);\r\nacl = NULL;\r\nif (result->mask & NFS_ACL)\r\nacl = &result->acl_access;\r\naclcnt = NULL;\r\nif (result->mask & NFS_ACLCNT)\r\naclcnt = &result->acl_access_count;\r\nerror = nfsacl_decode(xdr->buf, hdrlen, aclcnt, acl);\r\nif (unlikely(error <= 0))\r\ngoto out;\r\nacl = NULL;\r\nif (result->mask & NFS_DFACL)\r\nacl = &result->acl_default;\r\naclcnt = NULL;\r\nif (result->mask & NFS_DFACLCNT)\r\naclcnt = &result->acl_default_count;\r\nerror = nfsacl_decode(xdr->buf, hdrlen + error, aclcnt, acl);\r\nif (unlikely(error <= 0))\r\nreturn error;\r\nerror = 0;\r\nout:\r\nreturn error;\r\n}\r\nstatic int nfs3_xdr_dec_getacl3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs3_getaclres *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_default;\r\nerror = decode_getacl3resok(xdr, result);\r\nout:\r\nreturn error;\r\nout_default:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int nfs3_xdr_dec_setacl3res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nfs_fattr *result)\r\n{\r\nenum nfs_stat status;\r\nint error;\r\nerror = decode_nfsstat3(xdr, &status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (status != NFS3_OK)\r\ngoto out_default;\r\nerror = decode_post_op_attr(xdr, result);\r\nout:\r\nreturn error;\r\nout_default:\r\nreturn nfs3_stat_to_errno(status);\r\n}\r\nstatic int nfs3_stat_to_errno(enum nfs_stat status)\r\n{\r\nint i;\r\nfor (i = 0; nfs_errtbl[i].stat != -1; i++) {\r\nif (nfs_errtbl[i].stat == (int)status)\r\nreturn nfs_errtbl[i].errno;\r\n}\r\ndprintk("NFS: Unrecognized nfs status value: %u\n", status);\r\nreturn nfs_errtbl[i].errno;\r\n}
