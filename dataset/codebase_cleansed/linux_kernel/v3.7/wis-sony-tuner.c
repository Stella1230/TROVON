static int set_freq(struct i2c_client *client, int freq)\r\n{\r\nstruct wis_sony_tuner *t = i2c_get_clientdata(client);\r\nchar *band_name;\r\nint n;\r\nint band_select;\r\nstruct sony_tunertype *tun;\r\nu8 buffer[4];\r\ntun = &sony_tuners[t->type - 200];\r\nif (freq < tun->thresh1) {\r\nband_name = "VHF_L";\r\nband_select = tun->VHF_L;\r\n} else if (freq < tun->thresh2) {\r\nband_name = "VHF_H";\r\nband_select = tun->VHF_H;\r\n} else {\r\nband_name = "UHF";\r\nband_select = tun->UHF;\r\n}\r\nprintk(KERN_DEBUG "wis-sony-tuner: tuning to frequency %d.%04d (%s)\n",\r\nfreq / 16, (freq % 16) * 625, band_name);\r\nn = freq + tun->IFPCoff;\r\nbuffer[0] = n >> 8;\r\nbuffer[1] = n & 0xff;\r\nbuffer[2] = tun->config;\r\nbuffer[3] = band_select;\r\ni2c_master_send(client, buffer, 4);\r\nreturn 0;\r\n}\r\nstatic int mpx_write(struct i2c_client *client, int dev, int addr, int val)\r\n{\r\nu8 buffer[5];\r\nstruct i2c_msg msg;\r\nbuffer[0] = dev;\r\nbuffer[1] = addr >> 8;\r\nbuffer[2] = addr & 0xff;\r\nbuffer[3] = val >> 8;\r\nbuffer[4] = val & 0xff;\r\nmsg.addr = MPX_I2C_ADDR;\r\nmsg.flags = 0;\r\nmsg.len = 5;\r\nmsg.buf = buffer;\r\ni2c_transfer(client->adapter, &msg, 1);\r\nreturn 0;\r\n}\r\nstatic int mpx_setup(struct i2c_client *client)\r\n{\r\nstruct wis_sony_tuner *t = i2c_get_clientdata(client);\r\nu16 source = 0;\r\nu8 buffer[3];\r\nstruct i2c_msg msg;\r\nbuffer[0] = 0x00;\r\nbuffer[1] = 0x80;\r\nbuffer[2] = 0x00;\r\nmsg.addr = MPX_I2C_ADDR;\r\nmsg.flags = 0;\r\nmsg.len = 3;\r\nmsg.buf = buffer;\r\ni2c_transfer(client->adapter, &msg, 1);\r\nbuffer[1] = 0x00;\r\ni2c_transfer(client->adapter, &msg, 1);\r\nif (mpx_audio_modes[t->mpxmode].audio_mode != AUD_MONO) {\r\nswitch (t->audmode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nswitch (mpx_audio_modes[t->mpxmode].audio_mode) {\r\ncase AUD_A2:\r\nsource = mpx_audio_modes[t->mpxmode].source;\r\nbreak;\r\ncase AUD_NICAM:\r\nsource = 0x0000;\r\nbreak;\r\ncase AUD_NICAM_L:\r\nsource = 0x0200;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\nsource = mpx_audio_modes[t->mpxmode].source;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\nsource = 0x0300;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nsource = 0x0400;\r\nbreak;\r\n}\r\nsource |= mpx_audio_modes[t->mpxmode].source & 0x00ff;\r\n} else\r\nsource = mpx_audio_modes[t->mpxmode].source;\r\nmpx_write(client, 0x10, 0x0030, mpx_audio_modes[t->mpxmode].modus);\r\nmpx_write(client, 0x12, 0x0008, source);\r\nmpx_write(client, 0x12, 0x0013, mpx_audio_modes[t->mpxmode].acb);\r\nmpx_write(client, 0x12, 0x000e,\r\nmpx_audio_modes[t->mpxmode].fm_prescale);\r\nmpx_write(client, 0x12, 0x0010,\r\nmpx_audio_modes[t->mpxmode].nicam_prescale);\r\nmpx_write(client, 0x12, 0x000d,\r\nmpx_audio_modes[t->mpxmode].scart_prescale);\r\nmpx_write(client, 0x10, 0x0020, mpx_audio_modes[t->mpxmode].system);\r\nmpx_write(client, 0x12, 0x0000, mpx_audio_modes[t->mpxmode].volume);\r\nif (mpx_audio_modes[t->mpxmode].audio_mode == AUD_A2)\r\nmpx_write(client, 0x10, 0x0022,\r\nt->audmode == V4L2_TUNER_MODE_MONO ? 0x07f0 : 0x0190);\r\n#ifdef MPX_DEBUG\r\n{\r\nu8 buf1[3], buf2[2];\r\nstruct i2c_msg msgs[2];\r\nprintk(KERN_DEBUG "wis-sony-tuner: MPX registers: %04x %04x "\r\n"%04x %04x %04x %04x %04x %04x\n",\r\nmpx_audio_modes[t->mpxmode].modus,\r\nsource,\r\nmpx_audio_modes[t->mpxmode].acb,\r\nmpx_audio_modes[t->mpxmode].fm_prescale,\r\nmpx_audio_modes[t->mpxmode].nicam_prescale,\r\nmpx_audio_modes[t->mpxmode].scart_prescale,\r\nmpx_audio_modes[t->mpxmode].system,\r\nmpx_audio_modes[t->mpxmode].volume);\r\nbuf1[0] = 0x11;\r\nbuf1[1] = 0x00;\r\nbuf1[2] = 0x7e;\r\nmsgs[0].addr = MPX_I2C_ADDR;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = 3;\r\nmsgs[0].buf = buf1;\r\nmsgs[1].addr = MPX_I2C_ADDR;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[1].len = 2;\r\nmsgs[1].buf = buf2;\r\ni2c_transfer(client->adapter, msgs, 2);\r\nprintk(KERN_DEBUG "wis-sony-tuner: MPX system: %02x%02x\n",\r\nbuf2[0], buf2[1]);\r\nbuf1[0] = 0x11;\r\nbuf1[1] = 0x02;\r\nbuf1[2] = 0x00;\r\ni2c_transfer(client->adapter, msgs, 2);\r\nprintk(KERN_DEBUG "wis-sony-tuner: MPX status: %02x%02x\n",\r\nbuf2[0], buf2[1]);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int set_if(struct i2c_client *client)\r\n{\r\nstruct wis_sony_tuner *t = i2c_get_clientdata(client);\r\nu8 buffer[4];\r\nstruct i2c_msg msg;\r\nint default_mpx_mode = 0;\r\nbuffer[0] = 0;\r\nif (t->std & V4L2_STD_PAL_BG) {\r\nbuffer[1] = 0x94;\r\nbuffer[2] = 0x70;\r\nbuffer[3] = 0x49;\r\ndefault_mpx_mode = 1;\r\n} else if (t->std & V4L2_STD_PAL_I) {\r\nbuffer[1] = 0x14;\r\nbuffer[2] = 0x70;\r\nbuffer[3] = 0x4a;\r\ndefault_mpx_mode = 4;\r\n} else if (t->std & V4L2_STD_PAL_DK) {\r\nbuffer[1] = 0x14;\r\nbuffer[2] = 0x70;\r\nbuffer[3] = 0x4b;\r\ndefault_mpx_mode = 6;\r\n} else if (t->std & V4L2_STD_SECAM_L) {\r\nbuffer[1] = 0x04;\r\nbuffer[2] = 0x70;\r\nbuffer[3] = 0x4b;\r\ndefault_mpx_mode = 11;\r\n}\r\nmsg.addr = IF_I2C_ADDR;\r\nmsg.flags = 0;\r\nmsg.len = 4;\r\nmsg.buf = buffer;\r\ni2c_transfer(client->adapter, &msg, 1);\r\nif (force_mpx_mode >= 0 && force_mpx_mode < MPX_NUM_MODES)\r\nt->mpxmode = force_mpx_mode;\r\nelse\r\nt->mpxmode = default_mpx_mode;\r\nprintk(KERN_DEBUG "wis-sony-tuner: setting MPX to mode %d\n",\r\nt->mpxmode);\r\nmpx_setup(client);\r\nreturn 0;\r\n}\r\nstatic int tuner_command(struct i2c_client *client, unsigned int cmd, void *arg)\r\n{\r\nstruct wis_sony_tuner *t = i2c_get_clientdata(client);\r\nswitch (cmd) {\r\n#if 0\r\n#ifdef TUNER_SET_TYPE_ADDR\r\ncase TUNER_SET_TYPE_ADDR:\r\n{\r\nstruct tuner_setup *tun_setup = arg;\r\nint *type = &tun_setup->type;\r\n#else\r\ncase TUNER_SET_TYPE:\r\n{\r\nint *type = arg;\r\n#endif\r\nif (t->type >= 0) {\r\nif (t->type != *type)\r\nprintk(KERN_ERR "wis-sony-tuner: type already "\r\n"set to %d, ignoring request for %d\n",\r\nt->type, *type);\r\nbreak;\r\n}\r\nt->type = *type;\r\nswitch (t->type) {\r\ncase TUNER_SONY_BTF_PG472Z:\r\nswitch (force_band_str[0]) {\r\ncase 'b':\r\ncase 'B':\r\ncase 'g':\r\ncase 'G':\r\nprintk(KERN_INFO "wis-sony-tuner: forcing "\r\n"tuner to PAL-B/G bands\n");\r\nforce_band = V4L2_STD_PAL_BG;\r\nbreak;\r\ncase 'i':\r\ncase 'I':\r\nprintk(KERN_INFO "wis-sony-tuner: forcing "\r\n"tuner to PAL-I band\n");\r\nforce_band = V4L2_STD_PAL_I;\r\nbreak;\r\ncase 'd':\r\ncase 'D':\r\ncase 'k':\r\ncase 'K':\r\nprintk(KERN_INFO "wis-sony-tuner: forcing "\r\n"tuner to PAL-D/K bands\n");\r\nforce_band = V4L2_STD_PAL_I;\r\nbreak;\r\ncase 'l':\r\ncase 'L':\r\nprintk(KERN_INFO "wis-sony-tuner: forcing "\r\n"tuner to SECAM-L band\n");\r\nforce_band = V4L2_STD_SECAM_L;\r\nbreak;\r\ndefault:\r\nforce_band = 0;\r\nbreak;\r\n}\r\nif (force_band)\r\nt->std = force_band;\r\nelse\r\nt->std = V4L2_STD_PAL_BG;\r\nset_if(client);\r\nbreak;\r\ncase TUNER_SONY_BTF_PK467Z:\r\nt->std = V4L2_STD_NTSC_M_JP;\r\nbreak;\r\ncase TUNER_SONY_BTF_PB463Z:\r\nt->std = V4L2_STD_NTSC_M;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "wis-sony-tuner: tuner type %d is not "\r\n"supported by this module\n", *type);\r\nbreak;\r\n}\r\nif (type >= 0)\r\nprintk(KERN_INFO\r\n"wis-sony-tuner: type set to %d (%s)\n",\r\nt->type, sony_tuners[t->type - 200].name);\r\nbreak;\r\n}\r\n#endif\r\ncase VIDIOC_G_FREQUENCY:\r\n{\r\nstruct v4l2_frequency *f = arg;\r\nf->frequency = t->freq;\r\nbreak;\r\n}\r\ncase VIDIOC_S_FREQUENCY:\r\n{\r\nstruct v4l2_frequency *f = arg;\r\nt->freq = f->frequency;\r\nset_freq(client, t->freq);\r\nbreak;\r\n}\r\ncase VIDIOC_ENUMSTD:\r\n{\r\nstruct v4l2_standard *std = arg;\r\nswitch (t->type) {\r\ncase TUNER_SONY_BTF_PG472Z:\r\nswitch (std->index) {\r\ncase 0:\r\nv4l2_video_std_construct(std,\r\nV4L2_STD_PAL_BG, "PAL-B/G");\r\nbreak;\r\ncase 1:\r\nv4l2_video_std_construct(std,\r\nV4L2_STD_PAL_I, "PAL-I");\r\nbreak;\r\ncase 2:\r\nv4l2_video_std_construct(std,\r\nV4L2_STD_PAL_DK, "PAL-D/K");\r\nbreak;\r\ncase 3:\r\nv4l2_video_std_construct(std,\r\nV4L2_STD_SECAM_L, "SECAM-L");\r\nbreak;\r\ndefault:\r\nstd->id = 0;\r\nbreak;\r\n}\r\nbreak;\r\ncase TUNER_SONY_BTF_PK467Z:\r\nif (std->index != 0) {\r\nstd->id = 0;\r\nbreak;\r\n}\r\nv4l2_video_std_construct(std,\r\nV4L2_STD_NTSC_M_JP, "NTSC-J");\r\nbreak;\r\ncase TUNER_SONY_BTF_PB463Z:\r\nif (std->index != 0) {\r\nstd->id = 0;\r\nbreak;\r\n}\r\nv4l2_video_std_construct(std, V4L2_STD_NTSC_M, "NTSC");\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_G_STD:\r\n{\r\nv4l2_std_id *std = arg;\r\n*std = t->std;\r\nbreak;\r\n}\r\ncase VIDIOC_S_STD:\r\n{\r\nv4l2_std_id *std = arg;\r\nv4l2_std_id old = t->std;\r\nswitch (t->type) {\r\ncase TUNER_SONY_BTF_PG472Z:\r\nif (force_band && (*std & force_band) != *std &&\r\n*std != V4L2_STD_PAL &&\r\n*std != V4L2_STD_SECAM) {\r\nprintk(KERN_DEBUG "wis-sony-tuner: ignoring "\r\n"requested TV standard in "\r\n"favor of force_band value\n");\r\nt->std = force_band;\r\n} else if (*std & V4L2_STD_PAL_BG) {\r\nt->std = V4L2_STD_PAL_BG;\r\n} else if (*std & V4L2_STD_PAL_I) {\r\nt->std = V4L2_STD_PAL_I;\r\n} else if (*std & V4L2_STD_PAL_DK) {\r\nt->std = V4L2_STD_PAL_DK;\r\n} else if (*std & V4L2_STD_SECAM_L) {\r\nt->std = V4L2_STD_SECAM_L;\r\n} else {\r\nprintk(KERN_ERR "wis-sony-tuner: TV standard "\r\n"not supported\n");\r\n*std = 0;\r\nbreak;\r\n}\r\nif (old != t->std)\r\nset_if(client);\r\nbreak;\r\ncase TUNER_SONY_BTF_PK467Z:\r\nif (!(*std & V4L2_STD_NTSC_M_JP)) {\r\nprintk(KERN_ERR "wis-sony-tuner: TV standard "\r\n"not supported\n");\r\n*std = 0;\r\n}\r\nbreak;\r\ncase TUNER_SONY_BTF_PB463Z:\r\nif (!(*std & V4L2_STD_NTSC_M)) {\r\nprintk(KERN_ERR "wis-sony-tuner: TV standard "\r\n"not supported\n");\r\n*std = 0;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_QUERYSTD:\r\n{\r\nv4l2_std_id *std = arg;\r\nswitch (t->type) {\r\ncase TUNER_SONY_BTF_PG472Z:\r\nif (force_band)\r\n*std = force_band;\r\nelse\r\n*std = V4L2_STD_PAL_BG | V4L2_STD_PAL_I |\r\nV4L2_STD_PAL_DK | V4L2_STD_SECAM_L;\r\nbreak;\r\ncase TUNER_SONY_BTF_PK467Z:\r\n*std = V4L2_STD_NTSC_M_JP;\r\nbreak;\r\ncase TUNER_SONY_BTF_PB463Z:\r\n*std = V4L2_STD_NTSC_M;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_G_TUNER:\r\n{\r\nstruct v4l2_tuner *tun = arg;\r\nmemset(tun, 0, sizeof(*tun));\r\nstrcpy(tun->name, "Television");\r\ntun->type = V4L2_TUNER_ANALOG_TV;\r\ntun->rangelow = 0UL;\r\ntun->rangehigh = 0xffffffffUL;\r\nswitch (t->type) {\r\ncase TUNER_SONY_BTF_PG472Z:\r\ntun->capability = V4L2_TUNER_CAP_NORM |\r\nV4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LANG1 |\r\nV4L2_TUNER_CAP_LANG2;\r\ntun->rxsubchans = V4L2_TUNER_SUB_MONO |\r\nV4L2_TUNER_SUB_STEREO | V4L2_TUNER_SUB_LANG1 |\r\nV4L2_TUNER_SUB_LANG2;\r\nbreak;\r\ncase TUNER_SONY_BTF_PK467Z:\r\ncase TUNER_SONY_BTF_PB463Z:\r\ntun->capability = V4L2_TUNER_CAP_STEREO;\r\ntun->rxsubchans = V4L2_TUNER_SUB_MONO |\r\nV4L2_TUNER_SUB_STEREO;\r\nbreak;\r\n}\r\ntun->audmode = t->audmode;\r\nreturn 0;\r\n}\r\ncase VIDIOC_S_TUNER:\r\n{\r\nstruct v4l2_tuner *tun = arg;\r\nswitch (t->type) {\r\ncase TUNER_SONY_BTF_PG472Z:\r\nif (tun->audmode != t->audmode) {\r\nt->audmode = tun->audmode;\r\nmpx_setup(client);\r\n}\r\nbreak;\r\ncase TUNER_SONY_BTF_PK467Z:\r\ncase TUNER_SONY_BTF_PB463Z:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wis_sony_tuner_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct wis_sony_tuner *t;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn -ENODEV;\r\nt = kmalloc(sizeof(struct wis_sony_tuner), GFP_KERNEL);\r\nif (t == NULL)\r\nreturn -ENOMEM;\r\nt->type = -1;\r\nt->freq = 0;\r\nt->mpxmode = 0;\r\nt->audmode = V4L2_TUNER_MODE_STEREO;\r\ni2c_set_clientdata(client, t);\r\nprintk(KERN_DEBUG\r\n"wis-sony-tuner: initializing tuner at address %d on %s\n",\r\nclient->addr, adapter->name);\r\nreturn 0;\r\n}\r\nstatic int wis_sony_tuner_remove(struct i2c_client *client)\r\n{\r\nstruct wis_sony_tuner *t = i2c_get_clientdata(client);\r\nkfree(t);\r\nreturn 0;\r\n}\r\nstatic int __init wis_sony_tuner_init(void)\r\n{\r\nreturn i2c_add_driver(&wis_sony_tuner_driver);\r\n}\r\nstatic void __exit wis_sony_tuner_cleanup(void)\r\n{\r\ni2c_del_driver(&wis_sony_tuner_driver);\r\n}
