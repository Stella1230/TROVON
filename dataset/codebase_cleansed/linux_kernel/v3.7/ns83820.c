static inline struct ns83820 *PRIV(struct net_device *dev)\r\n{\r\nreturn netdev_priv(dev);\r\n}\r\nstatic inline void kick_rx(struct net_device *ndev)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\ndprintk("kick_rx: maybe kicking\n");\r\nif (test_and_clear_bit(0, &dev->rx_info.idle)) {\r\ndprintk("actually kicking\n");\r\nwritel(dev->rx_info.phy_descs +\r\n(4 * DESC_SIZE * dev->rx_info.next_rx),\r\ndev->base + RXDP);\r\nif (dev->rx_info.next_rx == dev->rx_info.next_empty)\r\nprintk(KERN_DEBUG "%s: uh-oh: next_rx == next_empty???\n",\r\nndev->name);\r\n__kick_rx(dev);\r\n}\r\n}\r\nstatic inline void build_rx_desc(struct ns83820 *dev, __le32 *desc, dma_addr_t link, dma_addr_t buf, u32 cmdsts, u32 extsts)\r\n{\r\ndesc_addr_set(desc + DESC_LINK, link);\r\ndesc_addr_set(desc + DESC_BUFPTR, buf);\r\ndesc[DESC_EXTSTS] = cpu_to_le32(extsts);\r\nmb();\r\ndesc[DESC_CMDSTS] = cpu_to_le32(cmdsts);\r\n}\r\nstatic inline int ns83820_add_rx_skb(struct ns83820 *dev, struct sk_buff *skb)\r\n{\r\nunsigned next_empty;\r\nu32 cmdsts;\r\n__le32 *sg;\r\ndma_addr_t buf;\r\nnext_empty = dev->rx_info.next_empty;\r\nif (unlikely(nr_rx_empty(dev) <= 2)) {\r\nkfree_skb(skb);\r\nreturn 1;\r\n}\r\n#if 0\r\ndprintk("next_empty[%d] nr_used[%d] next_rx[%d]\n",\r\ndev->rx_info.next_empty,\r\ndev->rx_info.nr_used,\r\ndev->rx_info.next_rx\r\n);\r\n#endif\r\nsg = dev->rx_info.descs + (next_empty * DESC_SIZE);\r\nBUG_ON(NULL != dev->rx_info.skbs[next_empty]);\r\ndev->rx_info.skbs[next_empty] = skb;\r\ndev->rx_info.next_empty = (next_empty + 1) % NR_RX_DESC;\r\ncmdsts = REAL_RX_BUF_SIZE | CMDSTS_INTR;\r\nbuf = pci_map_single(dev->pci_dev, skb->data,\r\nREAL_RX_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\nbuild_rx_desc(dev, sg, 0, buf, cmdsts, 0);\r\nif (likely(next_empty != dev->rx_info.next_rx))\r\ndev->rx_info.descs[((NR_RX_DESC + next_empty - 1) % NR_RX_DESC) * DESC_SIZE] = cpu_to_le32(dev->rx_info.phy_descs + (next_empty * DESC_SIZE * 4));\r\nreturn 0;\r\n}\r\nstatic inline int rx_refill(struct net_device *ndev, gfp_t gfp)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nunsigned i;\r\nunsigned long flags = 0;\r\nif (unlikely(nr_rx_empty(dev) <= 2))\r\nreturn 0;\r\ndprintk("rx_refill(%p)\n", ndev);\r\nif (gfp == GFP_ATOMIC)\r\nspin_lock_irqsave(&dev->rx_info.lock, flags);\r\nfor (i=0; i<NR_RX_DESC; i++) {\r\nstruct sk_buff *skb;\r\nlong res;\r\nskb = __netdev_alloc_skb(ndev, REAL_RX_BUF_SIZE+16, gfp);\r\nif (unlikely(!skb))\r\nbreak;\r\nskb_reserve(skb, skb->data - PTR_ALIGN(skb->data, 16));\r\nif (gfp != GFP_ATOMIC)\r\nspin_lock_irqsave(&dev->rx_info.lock, flags);\r\nres = ns83820_add_rx_skb(dev, skb);\r\nif (gfp != GFP_ATOMIC)\r\nspin_unlock_irqrestore(&dev->rx_info.lock, flags);\r\nif (res) {\r\ni = 1;\r\nbreak;\r\n}\r\n}\r\nif (gfp == GFP_ATOMIC)\r\nspin_unlock_irqrestore(&dev->rx_info.lock, flags);\r\nreturn i ? 0 : -ENOMEM;\r\n}\r\nstatic void rx_refill_atomic(struct net_device *ndev)\r\n{\r\nrx_refill(ndev, GFP_ATOMIC);\r\n}\r\nstatic inline void queue_refill(struct work_struct *work)\r\n{\r\nstruct ns83820 *dev = container_of(work, struct ns83820, tq_refill);\r\nstruct net_device *ndev = dev->ndev;\r\nrx_refill(ndev, GFP_KERNEL);\r\nif (dev->rx_info.up)\r\nkick_rx(ndev);\r\n}\r\nstatic inline void clear_rx_desc(struct ns83820 *dev, unsigned i)\r\n{\r\nbuild_rx_desc(dev, dev->rx_info.descs + (DESC_SIZE * i), 0, 0, CMDSTS_OWN, 0);\r\n}\r\nstatic void phy_intr(struct net_device *ndev)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nstatic const char *speeds[] = { "10", "100", "1000", "1000(?)", "1000F" };\r\nu32 cfg, new_cfg;\r\nu32 tbisr, tanar, tanlpar;\r\nint speed, fullduplex, newlinkstate;\r\ncfg = readl(dev->base + CFG) ^ SPDSTS_POLARITY;\r\nif (dev->CFG_cache & CFG_TBI_EN) {\r\ntbisr = readl(dev->base + TBISR);\r\ntanar = readl(dev->base + TANAR);\r\ntanlpar = readl(dev->base + TANLPAR);\r\ndprintk("phy_intr: tbisr=%08x, tanar=%08x, tanlpar=%08x\n",\r\ntbisr, tanar, tanlpar);\r\nif ( (fullduplex = (tanlpar & TANAR_FULL_DUP) &&\r\n(tanar & TANAR_FULL_DUP)) ) {\r\nwritel(readl(dev->base + TXCFG)\r\n| TXCFG_CSI | TXCFG_HBI | TXCFG_ATP,\r\ndev->base + TXCFG);\r\nwritel(readl(dev->base + RXCFG) | RXCFG_RX_FD,\r\ndev->base + RXCFG);\r\nwritel(readl(dev->base + GPIOR) | GPIOR_GP1_OUT,\r\ndev->base + GPIOR);\r\n} else if (((tanlpar & TANAR_HALF_DUP) &&\r\n(tanar & TANAR_HALF_DUP)) ||\r\n((tanlpar & TANAR_FULL_DUP) &&\r\n(tanar & TANAR_HALF_DUP)) ||\r\n((tanlpar & TANAR_HALF_DUP) &&\r\n(tanar & TANAR_FULL_DUP))) {\r\nwritel((readl(dev->base + TXCFG)\r\n& ~(TXCFG_CSI | TXCFG_HBI)) | TXCFG_ATP,\r\ndev->base + TXCFG);\r\nwritel(readl(dev->base + RXCFG) & ~RXCFG_RX_FD,\r\ndev->base + RXCFG);\r\nwritel(readl(dev->base + GPIOR) & ~GPIOR_GP1_OUT,\r\ndev->base + GPIOR);\r\n}\r\nspeed = 4;\r\n} else {\r\nnew_cfg = dev->CFG_cache & ~(CFG_SB | CFG_MODE_1000 | CFG_SPDSTS);\r\nif (cfg & CFG_SPDSTS1)\r\nnew_cfg |= CFG_MODE_1000;\r\nelse\r\nnew_cfg &= ~CFG_MODE_1000;\r\nspeed = ((cfg / CFG_SPDSTS0) & 3);\r\nfullduplex = (cfg & CFG_DUPSTS);\r\nif (fullduplex) {\r\nnew_cfg |= CFG_SB;\r\nwritel(readl(dev->base + TXCFG)\r\n| TXCFG_CSI | TXCFG_HBI,\r\ndev->base + TXCFG);\r\nwritel(readl(dev->base + RXCFG) | RXCFG_RX_FD,\r\ndev->base + RXCFG);\r\n} else {\r\nwritel(readl(dev->base + TXCFG)\r\n& ~(TXCFG_CSI | TXCFG_HBI),\r\ndev->base + TXCFG);\r\nwritel(readl(dev->base + RXCFG) & ~(RXCFG_RX_FD),\r\ndev->base + RXCFG);\r\n}\r\nif ((cfg & CFG_LNKSTS) &&\r\n((new_cfg ^ dev->CFG_cache) != 0)) {\r\nwritel(new_cfg, dev->base + CFG);\r\ndev->CFG_cache = new_cfg;\r\n}\r\ndev->CFG_cache &= ~CFG_SPDSTS;\r\ndev->CFG_cache |= cfg & CFG_SPDSTS;\r\n}\r\nnewlinkstate = (cfg & CFG_LNKSTS) ? LINK_UP : LINK_DOWN;\r\nif (newlinkstate & LINK_UP &&\r\ndev->linkstate != newlinkstate) {\r\nnetif_start_queue(ndev);\r\nnetif_wake_queue(ndev);\r\nprintk(KERN_INFO "%s: link now %s mbps, %s duplex and up.\n",\r\nndev->name,\r\nspeeds[speed],\r\nfullduplex ? "full" : "half");\r\n} else if (newlinkstate & LINK_DOWN &&\r\ndev->linkstate != newlinkstate) {\r\nnetif_stop_queue(ndev);\r\nprintk(KERN_INFO "%s: link now down.\n", ndev->name);\r\n}\r\ndev->linkstate = newlinkstate;\r\n}\r\nstatic int ns83820_setup_rx(struct net_device *ndev)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nunsigned i;\r\nint ret;\r\ndprintk("ns83820_setup_rx(%p)\n", ndev);\r\ndev->rx_info.idle = 1;\r\ndev->rx_info.next_rx = 0;\r\ndev->rx_info.next_rx_desc = dev->rx_info.descs;\r\ndev->rx_info.next_empty = 0;\r\nfor (i=0; i<NR_RX_DESC; i++)\r\nclear_rx_desc(dev, i);\r\nwritel(0, dev->base + RXDP_HI);\r\nwritel(dev->rx_info.phy_descs, dev->base + RXDP);\r\nret = rx_refill(ndev, GFP_KERNEL);\r\nif (!ret) {\r\ndprintk("starting receiver\n");\r\nspin_lock_irq(&dev->rx_info.lock);\r\nwritel(0x0001, dev->base + CCSR);\r\nwritel(0, dev->base + RFCR);\r\nwritel(0x7fc00000, dev->base + RFCR);\r\nwritel(0xffc00000, dev->base + RFCR);\r\ndev->rx_info.up = 1;\r\nphy_intr(ndev);\r\nspin_lock(&dev->misc_lock);\r\ndev->IMR_cache |= ISR_PHY;\r\ndev->IMR_cache |= ISR_RXRCMP;\r\ndev->IMR_cache |= ISR_RXORN;\r\ndev->IMR_cache |= ISR_RXSOVR;\r\ndev->IMR_cache |= ISR_RXDESC;\r\ndev->IMR_cache |= ISR_RXIDLE;\r\ndev->IMR_cache |= ISR_TXDESC;\r\ndev->IMR_cache |= ISR_TXIDLE;\r\nwritel(dev->IMR_cache, dev->base + IMR);\r\nwritel(1, dev->base + IER);\r\nspin_unlock(&dev->misc_lock);\r\nkick_rx(ndev);\r\nspin_unlock_irq(&dev->rx_info.lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic void ns83820_cleanup_rx(struct ns83820 *dev)\r\n{\r\nunsigned i;\r\nunsigned long flags;\r\ndprintk("ns83820_cleanup_rx(%p)\n", dev);\r\nspin_lock_irqsave(&dev->misc_lock, flags);\r\ndev->IMR_cache &= ~(ISR_RXOK | ISR_RXDESC | ISR_RXERR | ISR_RXEARLY | ISR_RXIDLE);\r\nwritel(dev->IMR_cache, dev->base + IMR);\r\nspin_unlock_irqrestore(&dev->misc_lock, flags);\r\ndev->rx_info.up = 0;\r\nsynchronize_irq(dev->pci_dev->irq);\r\nreadl(dev->base + IMR);\r\nwritel(0, dev->base + RXDP_HI);\r\nwritel(0, dev->base + RXDP);\r\nfor (i=0; i<NR_RX_DESC; i++) {\r\nstruct sk_buff *skb = dev->rx_info.skbs[i];\r\ndev->rx_info.skbs[i] = NULL;\r\nclear_rx_desc(dev, i);\r\nkfree_skb(skb);\r\n}\r\n}\r\nstatic void ns83820_rx_kick(struct net_device *ndev)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\n{\r\nif (dev->rx_info.up) {\r\nrx_refill_atomic(ndev);\r\nkick_rx(ndev);\r\n}\r\n}\r\nif (dev->rx_info.up && nr_rx_empty(dev) > NR_RX_DESC*3/4)\r\nschedule_work(&dev->tq_refill);\r\nelse\r\nkick_rx(ndev);\r\nif (dev->rx_info.idle)\r\nprintk(KERN_DEBUG "%s: BAD\n", ndev->name);\r\n}\r\nstatic void rx_action(unsigned long _dev)\r\n{\r\nstruct net_device *ndev = (void *)_dev;\r\nstruct ns83820 *dev = PRIV(ndev);\r\nrx_irq(ndev);\r\nwritel(ihr, dev->base + IHR);\r\nspin_lock_irq(&dev->misc_lock);\r\ndev->IMR_cache |= ISR_RXDESC;\r\nwritel(dev->IMR_cache, dev->base + IMR);\r\nspin_unlock_irq(&dev->misc_lock);\r\nrx_irq(ndev);\r\nns83820_rx_kick(ndev);\r\n}\r\nstatic inline void kick_tx(struct ns83820 *dev)\r\n{\r\ndprintk("kick_tx(%p): tx_idx=%d free_idx=%d\n",\r\ndev, dev->tx_idx, dev->tx_free_idx);\r\nwritel(CR_TXE, dev->base + CR);\r\n}\r\nstatic void do_tx_done(struct net_device *ndev)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nu32 cmdsts, tx_done_idx;\r\n__le32 *desc;\r\ndprintk("do_tx_done(%p)\n", ndev);\r\ntx_done_idx = dev->tx_done_idx;\r\ndesc = dev->tx_descs + (tx_done_idx * DESC_SIZE);\r\ndprintk("tx_done_idx=%d free_idx=%d cmdsts=%08x\n",\r\ntx_done_idx, dev->tx_free_idx, le32_to_cpu(desc[DESC_CMDSTS]));\r\nwhile ((tx_done_idx != dev->tx_free_idx) &&\r\n!(CMDSTS_OWN & (cmdsts = le32_to_cpu(desc[DESC_CMDSTS]))) ) {\r\nstruct sk_buff *skb;\r\nunsigned len;\r\ndma_addr_t addr;\r\nif (cmdsts & CMDSTS_ERR)\r\nndev->stats.tx_errors++;\r\nif (cmdsts & CMDSTS_OK)\r\nndev->stats.tx_packets++;\r\nif (cmdsts & CMDSTS_OK)\r\nndev->stats.tx_bytes += cmdsts & 0xffff;\r\ndprintk("tx_done_idx=%d free_idx=%d cmdsts=%08x\n",\r\ntx_done_idx, dev->tx_free_idx, cmdsts);\r\nskb = dev->tx_skbs[tx_done_idx];\r\ndev->tx_skbs[tx_done_idx] = NULL;\r\ndprintk("done(%p)\n", skb);\r\nlen = cmdsts & CMDSTS_LEN_MASK;\r\naddr = desc_addr_get(desc + DESC_BUFPTR);\r\nif (skb) {\r\npci_unmap_single(dev->pci_dev,\r\naddr,\r\nlen,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(skb);\r\natomic_dec(&dev->nr_tx_skbs);\r\n} else\r\npci_unmap_page(dev->pci_dev,\r\naddr,\r\nlen,\r\nPCI_DMA_TODEVICE);\r\ntx_done_idx = (tx_done_idx + 1) % NR_TX_DESC;\r\ndev->tx_done_idx = tx_done_idx;\r\ndesc[DESC_CMDSTS] = cpu_to_le32(0);\r\nmb();\r\ndesc = dev->tx_descs + (tx_done_idx * DESC_SIZE);\r\n}\r\nif (netif_queue_stopped(ndev) && start_tx_okay(dev)) {\r\ndprintk("start_queue(%p)\n", ndev);\r\nnetif_start_queue(ndev);\r\nnetif_wake_queue(ndev);\r\n}\r\n}\r\nstatic void ns83820_cleanup_tx(struct ns83820 *dev)\r\n{\r\nunsigned i;\r\nfor (i=0; i<NR_TX_DESC; i++) {\r\nstruct sk_buff *skb = dev->tx_skbs[i];\r\ndev->tx_skbs[i] = NULL;\r\nif (skb) {\r\n__le32 *desc = dev->tx_descs + (i * DESC_SIZE);\r\npci_unmap_single(dev->pci_dev,\r\ndesc_addr_get(desc + DESC_BUFPTR),\r\nle32_to_cpu(desc[DESC_CMDSTS]) & CMDSTS_LEN_MASK,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(skb);\r\natomic_dec(&dev->nr_tx_skbs);\r\n}\r\n}\r\nmemset(dev->tx_descs, 0, NR_TX_DESC * DESC_SIZE * 4);\r\n}\r\nstatic netdev_tx_t ns83820_hard_start_xmit(struct sk_buff *skb,\r\nstruct net_device *ndev)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nu32 free_idx, cmdsts, extsts;\r\nint nr_free, nr_frags;\r\nunsigned tx_done_idx, last_idx;\r\ndma_addr_t buf;\r\nunsigned len;\r\nskb_frag_t *frag;\r\nint stopped = 0;\r\nint do_intr = 0;\r\nvolatile __le32 *first_desc;\r\ndprintk("ns83820_hard_start_xmit\n");\r\nnr_frags = skb_shinfo(skb)->nr_frags;\r\nagain:\r\nif (unlikely(dev->CFG_cache & CFG_LNKSTS)) {\r\nnetif_stop_queue(ndev);\r\nif (unlikely(dev->CFG_cache & CFG_LNKSTS))\r\nreturn NETDEV_TX_BUSY;\r\nnetif_start_queue(ndev);\r\n}\r\nlast_idx = free_idx = dev->tx_free_idx;\r\ntx_done_idx = dev->tx_done_idx;\r\nnr_free = (tx_done_idx + NR_TX_DESC-2 - free_idx) % NR_TX_DESC;\r\nnr_free -= 1;\r\nif (nr_free <= nr_frags) {\r\ndprintk("stop_queue - not enough(%p)\n", ndev);\r\nnetif_stop_queue(ndev);\r\nif (dev->tx_done_idx != tx_done_idx) {\r\ndprintk("restart queue(%p)\n", ndev);\r\nnetif_start_queue(ndev);\r\ngoto again;\r\n}\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (free_idx == dev->tx_intr_idx) {\r\ndo_intr = 1;\r\ndev->tx_intr_idx = (dev->tx_intr_idx + NR_TX_DESC/4) % NR_TX_DESC;\r\n}\r\nnr_free -= nr_frags;\r\nif (nr_free < MIN_TX_DESC_FREE) {\r\ndprintk("stop_queue - last entry(%p)\n", ndev);\r\nnetif_stop_queue(ndev);\r\nstopped = 1;\r\n}\r\nfrag = skb_shinfo(skb)->frags;\r\nif (!nr_frags)\r\nfrag = NULL;\r\nextsts = 0;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nextsts |= EXTSTS_IPPKT;\r\nif (IPPROTO_TCP == ip_hdr(skb)->protocol)\r\nextsts |= EXTSTS_TCPPKT;\r\nelse if (IPPROTO_UDP == ip_hdr(skb)->protocol)\r\nextsts |= EXTSTS_UDPPKT;\r\n}\r\n#ifdef NS83820_VLAN_ACCEL_SUPPORT\r\nif(vlan_tx_tag_present(skb)) {\r\nshort tag = vlan_tx_tag_get(skb);\r\nextsts |= (EXTSTS_VPKT | htons(tag));\r\n}\r\n#endif\r\nlen = skb->len;\r\nif (nr_frags)\r\nlen -= skb->data_len;\r\nbuf = pci_map_single(dev->pci_dev, skb->data, len, PCI_DMA_TODEVICE);\r\nfirst_desc = dev->tx_descs + (free_idx * DESC_SIZE);\r\nfor (;;) {\r\nvolatile __le32 *desc = dev->tx_descs + (free_idx * DESC_SIZE);\r\ndprintk("frag[%3u]: %4u @ 0x%08Lx\n", free_idx, len,\r\n(unsigned long long)buf);\r\nlast_idx = free_idx;\r\nfree_idx = (free_idx + 1) % NR_TX_DESC;\r\ndesc[DESC_LINK] = cpu_to_le32(dev->tx_phy_descs + (free_idx * DESC_SIZE * 4));\r\ndesc_addr_set(desc + DESC_BUFPTR, buf);\r\ndesc[DESC_EXTSTS] = cpu_to_le32(extsts);\r\ncmdsts = ((nr_frags) ? CMDSTS_MORE : do_intr ? CMDSTS_INTR : 0);\r\ncmdsts |= (desc == first_desc) ? 0 : CMDSTS_OWN;\r\ncmdsts |= len;\r\ndesc[DESC_CMDSTS] = cpu_to_le32(cmdsts);\r\nif (!nr_frags)\r\nbreak;\r\nbuf = skb_frag_dma_map(&dev->pci_dev->dev, frag, 0,\r\nskb_frag_size(frag), DMA_TO_DEVICE);\r\ndprintk("frag: buf=%08Lx page=%08lx offset=%08lx\n",\r\n(long long)buf, (long) page_to_pfn(frag->page),\r\nfrag->page_offset);\r\nlen = skb_frag_size(frag);\r\nfrag++;\r\nnr_frags--;\r\n}\r\ndprintk("done pkt\n");\r\nspin_lock_irq(&dev->tx_lock);\r\ndev->tx_skbs[last_idx] = skb;\r\nfirst_desc[DESC_CMDSTS] |= cpu_to_le32(CMDSTS_OWN);\r\ndev->tx_free_idx = free_idx;\r\natomic_inc(&dev->nr_tx_skbs);\r\nspin_unlock_irq(&dev->tx_lock);\r\nkick_tx(dev);\r\nif (stopped && (dev->tx_done_idx != tx_done_idx) && start_tx_okay(dev))\r\nnetif_start_queue(ndev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void ns83820_update_stats(struct ns83820 *dev)\r\n{\r\nstruct net_device *ndev = dev->ndev;\r\nu8 __iomem *base = dev->base;\r\nndev->stats.rx_errors += readl(base + 0x60) & 0xffff;\r\nndev->stats.rx_crc_errors += readl(base + 0x64) & 0xffff;\r\nndev->stats.rx_missed_errors += readl(base + 0x68) & 0xffff;\r\nndev->stats.rx_frame_errors += readl(base + 0x6c) & 0xffff;\r\nreadl(base + 0x70);\r\nndev->stats.rx_length_errors += readl(base + 0x74) & 0xffff;\r\nndev->stats.rx_length_errors += readl(base + 0x78) & 0xffff;\r\nreadl(base + 0x7c);\r\nreadl(base + 0x80);\r\nreadl(base + 0x84);\r\nndev->stats.tx_carrier_errors += readl(base + 0x88) & 0xff;\r\n}\r\nstatic struct net_device_stats *ns83820_get_stats(struct net_device *ndev)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nspin_lock_irq(&dev->misc_lock);\r\nns83820_update_stats(dev);\r\nspin_unlock_irq(&dev->misc_lock);\r\nreturn &ndev->stats;\r\n}\r\nstatic int ns83820_get_settings(struct net_device *ndev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nu32 cfg, tanar, tbicr;\r\nint fullduplex = 0;\r\ncfg = readl(dev->base + CFG) ^ SPDSTS_POLARITY;\r\ntanar = readl(dev->base + TANAR);\r\ntbicr = readl(dev->base + TBICR);\r\nfullduplex = (cfg & CFG_DUPSTS) ? 1 : 0;\r\ncmd->supported = SUPPORTED_Autoneg;\r\nif (dev->CFG_cache & CFG_TBI_EN) {\r\ncmd->supported |= SUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full |\r\nSUPPORTED_FIBRE;\r\ncmd->port = PORT_FIBRE;\r\n} else {\r\ncmd->supported |= SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full | SUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full | SUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full |\r\nSUPPORTED_MII;\r\ncmd->port = PORT_MII;\r\n}\r\ncmd->duplex = fullduplex ? DUPLEX_FULL : DUPLEX_HALF;\r\nswitch (cfg / CFG_SPDSTS0 & 3) {\r\ncase 2:\r\nethtool_cmd_speed_set(cmd, SPEED_1000);\r\nbreak;\r\ncase 1:\r\nethtool_cmd_speed_set(cmd, SPEED_100);\r\nbreak;\r\ndefault:\r\nethtool_cmd_speed_set(cmd, SPEED_10);\r\nbreak;\r\n}\r\ncmd->autoneg = (tbicr & TBICR_MR_AN_ENABLE)\r\n? AUTONEG_ENABLE : AUTONEG_DISABLE;\r\nreturn 0;\r\n}\r\nstatic int ns83820_set_settings(struct net_device *ndev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nu32 cfg, tanar;\r\nint have_optical = 0;\r\nint fullduplex = 0;\r\ncfg = readl(dev->base + CFG) ^ SPDSTS_POLARITY;\r\ntanar = readl(dev->base + TANAR);\r\nif (dev->CFG_cache & CFG_TBI_EN) {\r\nhave_optical = 1;\r\nfullduplex = (tanar & TANAR_FULL_DUP);\r\n} else {\r\nfullduplex = cfg & CFG_DUPSTS;\r\n}\r\nspin_lock_irq(&dev->misc_lock);\r\nspin_lock(&dev->tx_lock);\r\nif (cmd->duplex != fullduplex) {\r\nif (have_optical) {\r\nif (cmd->duplex == DUPLEX_FULL) {\r\nwritel(readl(dev->base + TXCFG)\r\n| TXCFG_CSI | TXCFG_HBI | TXCFG_ATP,\r\ndev->base + TXCFG);\r\nwritel(readl(dev->base + RXCFG) | RXCFG_RX_FD,\r\ndev->base + RXCFG);\r\nwritel(readl(dev->base + GPIOR) | GPIOR_GP1_OUT,\r\ndev->base + GPIOR);\r\n} else {\r\n}\r\n} else {\r\n}\r\nprintk(KERN_INFO "%s: Duplex set via ethtool\n",\r\nndev->name);\r\n}\r\nif (1) {\r\nif (cmd->autoneg == AUTONEG_ENABLE) {\r\nwritel(TBICR_MR_AN_ENABLE | TBICR_MR_RESTART_AN,\r\ndev->base + TBICR);\r\nwritel(TBICR_MR_AN_ENABLE, dev->base + TBICR);\r\ndev->linkstate = LINK_AUTONEGOTIATE;\r\nprintk(KERN_INFO "%s: autoneg enabled via ethtool\n",\r\nndev->name);\r\n} else {\r\nwritel(0x00000000, dev->base + TBICR);\r\n}\r\nprintk(KERN_INFO "%s: autoneg %s via ethtool\n", ndev->name,\r\ncmd->autoneg ? "ENABLED" : "DISABLED");\r\n}\r\nphy_intr(ndev);\r\nspin_unlock(&dev->tx_lock);\r\nspin_unlock_irq(&dev->misc_lock);\r\nreturn 0;\r\n}\r\nstatic void ns83820_get_drvinfo(struct net_device *ndev, struct ethtool_drvinfo *info)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nstrlcpy(info->driver, "ns83820", sizeof(info->driver));\r\nstrlcpy(info->version, VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(dev->pci_dev), sizeof(info->bus_info));\r\n}\r\nstatic u32 ns83820_get_link(struct net_device *ndev)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nu32 cfg = readl(dev->base + CFG) ^ SPDSTS_POLARITY;\r\nreturn cfg & CFG_LNKSTS ? 1 : 0;\r\n}\r\nstatic inline void ns83820_disable_interrupts(struct ns83820 *dev)\r\n{\r\nwritel(0, dev->base + IMR);\r\nwritel(0, dev->base + IER);\r\nreadl(dev->base + IER);\r\n}\r\nstatic void ns83820_mib_isr(struct ns83820 *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->misc_lock, flags);\r\nns83820_update_stats(dev);\r\nspin_unlock_irqrestore(&dev->misc_lock, flags);\r\n}\r\nstatic irqreturn_t ns83820_irq(int foo, void *data)\r\n{\r\nstruct net_device *ndev = data;\r\nstruct ns83820 *dev = PRIV(ndev);\r\nu32 isr;\r\ndprintk("ns83820_irq(%p)\n", ndev);\r\ndev->ihr = 0;\r\nisr = readl(dev->base + ISR);\r\ndprintk("irq: %08x\n", isr);\r\nns83820_do_isr(ndev, isr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ns83820_do_isr(struct net_device *ndev, u32 isr)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nunsigned long flags;\r\n#ifdef DEBUG\r\nif (isr & ~(ISR_PHY | ISR_RXDESC | ISR_RXEARLY | ISR_RXOK | ISR_RXERR | ISR_TXIDLE | ISR_TXOK | ISR_TXDESC))\r\nDprintk("odd isr? 0x%08x\n", isr);\r\n#endif\r\nif (ISR_RXIDLE & isr) {\r\ndev->rx_info.idle = 1;\r\nDprintk("oh dear, we are idle\n");\r\nns83820_rx_kick(ndev);\r\n}\r\nif ((ISR_RXDESC | ISR_RXOK) & isr) {\r\nprefetch(dev->rx_info.next_rx_desc);\r\nspin_lock_irqsave(&dev->misc_lock, flags);\r\ndev->IMR_cache &= ~(ISR_RXDESC | ISR_RXOK);\r\nwritel(dev->IMR_cache, dev->base + IMR);\r\nspin_unlock_irqrestore(&dev->misc_lock, flags);\r\ntasklet_schedule(&dev->rx_tasklet);\r\n}\r\nif ((ISR_RXIDLE | ISR_RXORN | ISR_RXDESC | ISR_RXOK | ISR_RXERR) & isr)\r\nns83820_rx_kick(ndev);\r\nif (unlikely(ISR_RXSOVR & isr)) {\r\nndev->stats.rx_fifo_errors++;\r\n}\r\nif (unlikely(ISR_RXORN & isr)) {\r\nndev->stats.rx_fifo_errors++;\r\n}\r\nif ((ISR_RXRCMP & isr) && dev->rx_info.up)\r\nwritel(CR_RXE, dev->base + CR);\r\nif (ISR_TXIDLE & isr) {\r\nu32 txdp;\r\ntxdp = readl(dev->base + TXDP);\r\ndprintk("txdp: %08x\n", txdp);\r\ntxdp -= dev->tx_phy_descs;\r\ndev->tx_idx = txdp / (DESC_SIZE * 4);\r\nif (dev->tx_idx >= NR_TX_DESC) {\r\nprintk(KERN_ALERT "%s: BUG -- txdp out of range\n", ndev->name);\r\ndev->tx_idx = 0;\r\n}\r\nif (dev->tx_idx != dev->tx_free_idx)\r\nkick_tx(dev);\r\n}\r\nif ((ISR_TXDESC | ISR_TXIDLE | ISR_TXOK | ISR_TXERR) & isr) {\r\nspin_lock_irqsave(&dev->tx_lock, flags);\r\ndo_tx_done(ndev);\r\nspin_unlock_irqrestore(&dev->tx_lock, flags);\r\nif ((dev->tx_done_idx == dev->tx_free_idx) &&\r\n(dev->IMR_cache & ISR_TXOK)) {\r\nspin_lock_irqsave(&dev->misc_lock, flags);\r\ndev->IMR_cache &= ~ISR_TXOK;\r\nwritel(dev->IMR_cache, dev->base + IMR);\r\nspin_unlock_irqrestore(&dev->misc_lock, flags);\r\n}\r\n}\r\nif ((ISR_TXIDLE & isr) && (dev->tx_done_idx != dev->tx_free_idx)) {\r\nspin_lock_irqsave(&dev->misc_lock, flags);\r\ndev->IMR_cache |= ISR_TXOK;\r\nwritel(dev->IMR_cache, dev->base + IMR);\r\nspin_unlock_irqrestore(&dev->misc_lock, flags);\r\n}\r\nif (unlikely(ISR_MIB & isr))\r\nns83820_mib_isr(dev);\r\nif (unlikely(ISR_PHY & isr))\r\nphy_intr(ndev);\r\n#if 0\r\nif (dev->ihr)\r\nwritel(dev->ihr, dev->base + IHR);\r\n#endif\r\n}\r\nstatic void ns83820_do_reset(struct ns83820 *dev, u32 which)\r\n{\r\nDprintk("resetting chip...\n");\r\nwritel(which, dev->base + CR);\r\ndo {\r\nschedule();\r\n} while (readl(dev->base + CR) & which);\r\nDprintk("okay!\n");\r\n}\r\nstatic int ns83820_stop(struct net_device *ndev)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\ndel_timer_sync(&dev->tx_watchdog);\r\nns83820_disable_interrupts(dev);\r\ndev->rx_info.up = 0;\r\nsynchronize_irq(dev->pci_dev->irq);\r\nns83820_do_reset(dev, CR_RST);\r\nsynchronize_irq(dev->pci_dev->irq);\r\nspin_lock_irq(&dev->misc_lock);\r\ndev->IMR_cache &= ~(ISR_TXURN | ISR_TXIDLE | ISR_TXERR | ISR_TXDESC | ISR_TXOK);\r\nspin_unlock_irq(&dev->misc_lock);\r\nns83820_cleanup_rx(dev);\r\nns83820_cleanup_tx(dev);\r\nreturn 0;\r\n}\r\nstatic void ns83820_tx_timeout(struct net_device *ndev)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nu32 tx_done_idx;\r\n__le32 *desc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->tx_lock, flags);\r\ntx_done_idx = dev->tx_done_idx;\r\ndesc = dev->tx_descs + (tx_done_idx * DESC_SIZE);\r\nprintk(KERN_INFO "%s: tx_timeout: tx_done_idx=%d free_idx=%d cmdsts=%08x\n",\r\nndev->name,\r\ntx_done_idx, dev->tx_free_idx, le32_to_cpu(desc[DESC_CMDSTS]));\r\n#if defined(DEBUG)\r\n{\r\nu32 isr;\r\nisr = readl(dev->base + ISR);\r\nprintk("irq: %08x imr: %08x\n", isr, dev->IMR_cache);\r\nns83820_do_isr(ndev, isr);\r\n}\r\n#endif\r\ndo_tx_done(ndev);\r\ntx_done_idx = dev->tx_done_idx;\r\ndesc = dev->tx_descs + (tx_done_idx * DESC_SIZE);\r\nprintk(KERN_INFO "%s: after: tx_done_idx=%d free_idx=%d cmdsts=%08x\n",\r\nndev->name,\r\ntx_done_idx, dev->tx_free_idx, le32_to_cpu(desc[DESC_CMDSTS]));\r\nspin_unlock_irqrestore(&dev->tx_lock, flags);\r\n}\r\nstatic void ns83820_tx_watch(unsigned long data)\r\n{\r\nstruct net_device *ndev = (void *)data;\r\nstruct ns83820 *dev = PRIV(ndev);\r\n#if defined(DEBUG)\r\nprintk("ns83820_tx_watch: %u %u %d\n",\r\ndev->tx_done_idx, dev->tx_free_idx, atomic_read(&dev->nr_tx_skbs)\r\n);\r\n#endif\r\nif (time_after(jiffies, dev_trans_start(ndev) + 1*HZ) &&\r\ndev->tx_done_idx != dev->tx_free_idx) {\r\nprintk(KERN_DEBUG "%s: ns83820_tx_watch: %u %u %d\n",\r\nndev->name,\r\ndev->tx_done_idx, dev->tx_free_idx,\r\natomic_read(&dev->nr_tx_skbs));\r\nns83820_tx_timeout(ndev);\r\n}\r\nmod_timer(&dev->tx_watchdog, jiffies + 2*HZ);\r\n}\r\nstatic int ns83820_open(struct net_device *ndev)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nunsigned i;\r\nu32 desc;\r\nint ret;\r\ndprintk("ns83820_open\n");\r\nwritel(0, dev->base + PQCR);\r\nret = ns83820_setup_rx(ndev);\r\nif (ret)\r\ngoto failed;\r\nmemset(dev->tx_descs, 0, 4 * NR_TX_DESC * DESC_SIZE);\r\nfor (i=0; i<NR_TX_DESC; i++) {\r\ndev->tx_descs[(i * DESC_SIZE) + DESC_LINK]\r\n= cpu_to_le32(\r\ndev->tx_phy_descs\r\n+ ((i+1) % NR_TX_DESC) * DESC_SIZE * 4);\r\n}\r\ndev->tx_idx = 0;\r\ndev->tx_done_idx = 0;\r\ndesc = dev->tx_phy_descs;\r\nwritel(0, dev->base + TXDP_HI);\r\nwritel(desc, dev->base + TXDP);\r\ninit_timer(&dev->tx_watchdog);\r\ndev->tx_watchdog.data = (unsigned long)ndev;\r\ndev->tx_watchdog.function = ns83820_tx_watch;\r\nmod_timer(&dev->tx_watchdog, jiffies + 2*HZ);\r\nnetif_start_queue(ndev);\r\nreturn 0;\r\nfailed:\r\nns83820_stop(ndev);\r\nreturn ret;\r\n}\r\nstatic void ns83820_getmac(struct ns83820 *dev, u8 *mac)\r\n{\r\nunsigned i;\r\nfor (i=0; i<3; i++) {\r\nu32 data;\r\nwritel(i*2, dev->base + RFCR);\r\ndata = readl(dev->base + RFDR);\r\n*mac++ = data;\r\n*mac++ = data >> 8;\r\n}\r\n}\r\nstatic int ns83820_change_mtu(struct net_device *ndev, int new_mtu)\r\n{\r\nif (new_mtu > RX_BUF_SIZE)\r\nreturn -EINVAL;\r\nndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void ns83820_set_multicast(struct net_device *ndev)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nu8 __iomem *rfcr = dev->base + RFCR;\r\nu32 and_mask = 0xffffffff;\r\nu32 or_mask = 0;\r\nu32 val;\r\nif (ndev->flags & IFF_PROMISC)\r\nor_mask |= RFCR_AAU | RFCR_AAM;\r\nelse\r\nand_mask &= ~(RFCR_AAU | RFCR_AAM);\r\nif (ndev->flags & IFF_ALLMULTI || netdev_mc_count(ndev))\r\nor_mask |= RFCR_AAM;\r\nelse\r\nand_mask &= ~RFCR_AAM;\r\nspin_lock_irq(&dev->misc_lock);\r\nval = (readl(rfcr) & and_mask) | or_mask;\r\nwritel(val & ~RFCR_RFEN, rfcr);\r\nwritel(val, rfcr);\r\nspin_unlock_irq(&dev->misc_lock);\r\n}\r\nstatic void ns83820_run_bist(struct net_device *ndev, const char *name, u32 enable, u32 done, u32 fail)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nint timed_out = 0;\r\nunsigned long start;\r\nu32 status;\r\nint loops = 0;\r\ndprintk("%s: start %s\n", ndev->name, name);\r\nstart = jiffies;\r\nwritel(enable, dev->base + PTSCR);\r\nfor (;;) {\r\nloops++;\r\nstatus = readl(dev->base + PTSCR);\r\nif (!(status & enable))\r\nbreak;\r\nif (status & done)\r\nbreak;\r\nif (status & fail)\r\nbreak;\r\nif (time_after_eq(jiffies, start + HZ)) {\r\ntimed_out = 1;\r\nbreak;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n}\r\nif (status & fail)\r\nprintk(KERN_INFO "%s: %s failed! (0x%08x & 0x%08x)\n",\r\nndev->name, name, status, fail);\r\nelse if (timed_out)\r\nprintk(KERN_INFO "%s: run_bist %s timed out! (%08x)\n",\r\nndev->name, name, status);\r\ndprintk("%s: done %s in %d loops\n", ndev->name, name, loops);\r\n}\r\nstatic void ns83820_mii_write_bit(struct ns83820 *dev, int bit)\r\n{\r\ndev->MEAR_cache &= ~MEAR_MDC;\r\nwritel(dev->MEAR_cache, dev->base + MEAR);\r\nreadl(dev->base + MEAR);\r\ndev->MEAR_cache |= MEAR_MDDIR;\r\nif (bit)\r\ndev->MEAR_cache |= MEAR_MDIO;\r\nelse\r\ndev->MEAR_cache &= ~MEAR_MDIO;\r\nwritel(dev->MEAR_cache, dev->base + MEAR);\r\nreadl(dev->base + MEAR);\r\nudelay(1);\r\ndev->MEAR_cache |= MEAR_MDC;\r\nwritel(dev->MEAR_cache, dev->base + MEAR);\r\nreadl(dev->base + MEAR);\r\nudelay(1);\r\n}\r\nstatic int ns83820_mii_read_bit(struct ns83820 *dev)\r\n{\r\nint bit;\r\ndev->MEAR_cache &= ~MEAR_MDC;\r\ndev->MEAR_cache &= ~MEAR_MDDIR;\r\nwritel(dev->MEAR_cache, dev->base + MEAR);\r\nreadl(dev->base + MEAR);\r\nudelay(1);\r\nbit = (readl(dev->base + MEAR) & MEAR_MDIO) ? 1 : 0;\r\ndev->MEAR_cache |= MEAR_MDC;\r\nwritel(dev->MEAR_cache, dev->base + MEAR);\r\nudelay(1);\r\nreturn bit;\r\n}\r\nstatic unsigned ns83820_mii_read_reg(struct ns83820 *dev, unsigned phy, unsigned reg)\r\n{\r\nunsigned data = 0;\r\nint i;\r\nfor (i=0; i<64; i++)\r\nns83820_mii_read_bit(dev);\r\nns83820_mii_write_bit(dev, 0);\r\nns83820_mii_write_bit(dev, 1);\r\nns83820_mii_write_bit(dev, 1);\r\nns83820_mii_write_bit(dev, 0);\r\nfor (i=0; i<5; i++)\r\nns83820_mii_write_bit(dev, phy & (0x10 >> i));\r\nfor (i=0; i<5; i++)\r\nns83820_mii_write_bit(dev, reg & (0x10 >> i));\r\nns83820_mii_read_bit(dev);\r\nns83820_mii_read_bit(dev);\r\nfor (i=0; i<16; i++) {\r\ndata <<= 1;\r\ndata |= ns83820_mii_read_bit(dev);\r\n}\r\nreturn data;\r\n}\r\nstatic unsigned ns83820_mii_write_reg(struct ns83820 *dev, unsigned phy, unsigned reg, unsigned data)\r\n{\r\nint i;\r\nfor (i=0; i<64; i++)\r\nns83820_mii_read_bit(dev);\r\nns83820_mii_write_bit(dev, 0);\r\nns83820_mii_write_bit(dev, 1);\r\nns83820_mii_write_bit(dev, 0);\r\nns83820_mii_write_bit(dev, 1);\r\nfor (i=0; i<5; i++)\r\nns83820_mii_write_bit(dev, phy & (0x10 >> i));\r\nfor (i=0; i<5; i++)\r\nns83820_mii_write_bit(dev, reg & (0x10 >> i));\r\nns83820_mii_read_bit(dev);\r\nns83820_mii_read_bit(dev);\r\nfor (i=0; i<16; i++)\r\nns83820_mii_write_bit(dev, (data >> (15 - i)) & 1);\r\nreturn data;\r\n}\r\nstatic void ns83820_probe_phy(struct net_device *ndev)\r\n{\r\nstruct ns83820 *dev = PRIV(ndev);\r\nstatic int first;\r\nint i;\r\n#define MII_PHYIDR1 0x02\r\n#define MII_PHYIDR2 0x03\r\n#if 0\r\nif (!first) {\r\nunsigned tmp;\r\nns83820_mii_read_reg(dev, 1, 0x09);\r\nns83820_mii_write_reg(dev, 1, 0x10, 0x0d3e);\r\ntmp = ns83820_mii_read_reg(dev, 1, 0x00);\r\nns83820_mii_write_reg(dev, 1, 0x00, tmp | 0x8000);\r\nudelay(1300);\r\nns83820_mii_read_reg(dev, 1, 0x09);\r\n}\r\n#endif\r\nfirst = 1;\r\nfor (i=1; i<2; i++) {\r\nint j;\r\nunsigned a, b;\r\na = ns83820_mii_read_reg(dev, i, MII_PHYIDR1);\r\nb = ns83820_mii_read_reg(dev, i, MII_PHYIDR2);\r\nfor (j=0; j<0x16; j+=4) {\r\ndprintk("%s: [0x%02x] %04x %04x %04x %04x\n",\r\nndev->name, j,\r\nns83820_mii_read_reg(dev, i, 0 + j),\r\nns83820_mii_read_reg(dev, i, 1 + j),\r\nns83820_mii_read_reg(dev, i, 2 + j),\r\nns83820_mii_read_reg(dev, i, 3 + j)\r\n);\r\n}\r\n}\r\n{\r\nunsigned a, b;\r\nns83820_mii_write_reg(dev, 1, 0x16, 0x000d);\r\nns83820_mii_write_reg(dev, 1, 0x1e, 0x810e);\r\na = ns83820_mii_read_reg(dev, 1, 0x1d);\r\nns83820_mii_write_reg(dev, 1, 0x16, 0x000d);\r\nns83820_mii_write_reg(dev, 1, 0x1e, 0x810e);\r\nb = ns83820_mii_read_reg(dev, 1, 0x1d);\r\ndprintk("version: 0x%04x 0x%04x\n", a, b);\r\n}\r\n}\r\nstatic int __devinit ns83820_init_one(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct net_device *ndev;\r\nstruct ns83820 *dev;\r\nlong addr;\r\nint err;\r\nint using_dac = 0;\r\nif (sizeof(dma_addr_t) == 8 &&\r\n!pci_set_dma_mask(pci_dev, DMA_BIT_MASK(64))) {\r\nusing_dac = 1;\r\n} else if (!pci_set_dma_mask(pci_dev, DMA_BIT_MASK(32))) {\r\nusing_dac = 0;\r\n} else {\r\ndev_warn(&pci_dev->dev, "pci_set_dma_mask failed!\n");\r\nreturn -ENODEV;\r\n}\r\nndev = alloc_etherdev(sizeof(struct ns83820));\r\nerr = -ENOMEM;\r\nif (!ndev)\r\ngoto out;\r\ndev = PRIV(ndev);\r\ndev->ndev = ndev;\r\nspin_lock_init(&dev->rx_info.lock);\r\nspin_lock_init(&dev->tx_lock);\r\nspin_lock_init(&dev->misc_lock);\r\ndev->pci_dev = pci_dev;\r\nSET_NETDEV_DEV(ndev, &pci_dev->dev);\r\nINIT_WORK(&dev->tq_refill, queue_refill);\r\ntasklet_init(&dev->rx_tasklet, rx_action, (unsigned long)ndev);\r\nerr = pci_enable_device(pci_dev);\r\nif (err) {\r\ndev_info(&pci_dev->dev, "pci_enable_dev failed: %d\n", err);\r\ngoto out_free;\r\n}\r\npci_set_master(pci_dev);\r\naddr = pci_resource_start(pci_dev, 1);\r\ndev->base = ioremap_nocache(addr, PAGE_SIZE);\r\ndev->tx_descs = pci_alloc_consistent(pci_dev,\r\n4 * DESC_SIZE * NR_TX_DESC, &dev->tx_phy_descs);\r\ndev->rx_info.descs = pci_alloc_consistent(pci_dev,\r\n4 * DESC_SIZE * NR_RX_DESC, &dev->rx_info.phy_descs);\r\nerr = -ENOMEM;\r\nif (!dev->base || !dev->tx_descs || !dev->rx_info.descs)\r\ngoto out_disable;\r\ndprintk("%p: %08lx %p: %08lx\n",\r\ndev->tx_descs, (long)dev->tx_phy_descs,\r\ndev->rx_info.descs, (long)dev->rx_info.phy_descs);\r\nns83820_disable_interrupts(dev);\r\ndev->IMR_cache = 0;\r\nerr = request_irq(pci_dev->irq, ns83820_irq, IRQF_SHARED,\r\nDRV_NAME, ndev);\r\nif (err) {\r\ndev_info(&pci_dev->dev, "unable to register irq %d, err %d\n",\r\npci_dev->irq, err);\r\ngoto out_disable;\r\n}\r\nrtnl_lock();\r\nerr = dev_alloc_name(ndev, ndev->name);\r\nif (err < 0) {\r\ndev_info(&pci_dev->dev, "unable to get netdev name: %d\n", err);\r\ngoto out_free_irq;\r\n}\r\nprintk("%s: ns83820.c: 0x22c: %08x, subsystem: %04x:%04x\n",\r\nndev->name, le32_to_cpu(readl(dev->base + 0x22c)),\r\npci_dev->subsystem_vendor, pci_dev->subsystem_device);\r\nndev->netdev_ops = &netdev_ops;\r\nSET_ETHTOOL_OPS(ndev, &ops);\r\nndev->watchdog_timeo = 5 * HZ;\r\npci_set_drvdata(pci_dev, ndev);\r\nns83820_do_reset(dev, CR_RST);\r\nwritel(PTSCR_RBIST_RST, dev->base + PTSCR);\r\nns83820_run_bist(ndev, "sram bist", PTSCR_RBIST_EN,\r\nPTSCR_RBIST_DONE, PTSCR_RBIST_FAIL);\r\nns83820_run_bist(ndev, "eeprom bist", PTSCR_EEBIST_EN, 0,\r\nPTSCR_EEBIST_FAIL);\r\nns83820_run_bist(ndev, "eeprom load", PTSCR_EELOAD_EN, 0, 0);\r\ndev->CFG_cache = readl(dev->base + CFG);\r\nif ((dev->CFG_cache & CFG_PCI64_DET)) {\r\nprintk(KERN_INFO "%s: detected 64 bit PCI data bus.\n",\r\nndev->name);\r\nif (!(dev->CFG_cache & CFG_DATA64_EN))\r\nprintk(KERN_INFO "%s: EEPROM did not enable 64 bit bus. Disabled.\n",\r\nndev->name);\r\n} else\r\ndev->CFG_cache &= ~(CFG_DATA64_EN);\r\ndev->CFG_cache &= (CFG_TBI_EN | CFG_MRM_DIS | CFG_MWI_DIS |\r\nCFG_T64ADDR | CFG_DATA64_EN | CFG_EXT_125 |\r\nCFG_M64ADDR);\r\ndev->CFG_cache |= CFG_PINT_DUPSTS | CFG_PINT_LNKSTS | CFG_PINT_SPDSTS |\r\nCFG_EXTSTS_EN | CFG_EXD | CFG_PESEL;\r\ndev->CFG_cache |= CFG_REQALG;\r\ndev->CFG_cache |= CFG_POW;\r\ndev->CFG_cache |= CFG_TMRTEST;\r\nif (sizeof(dma_addr_t) == 8)\r\ndev->CFG_cache |= CFG_M64ADDR;\r\nif (using_dac)\r\ndev->CFG_cache |= CFG_T64ADDR;\r\ndev->CFG_cache &= ~CFG_BEM;\r\nif (dev->CFG_cache & CFG_TBI_EN) {\r\nprintk(KERN_INFO "%s: enabling optical transceiver\n",\r\nndev->name);\r\nwritel(readl(dev->base + GPIOR) | 0x3e8, dev->base + GPIOR);\r\nwritel(readl(dev->base + TANAR)\r\n| TANAR_HALF_DUP | TANAR_FULL_DUP,\r\ndev->base + TANAR);\r\nwritel(TBICR_MR_AN_ENABLE | TBICR_MR_RESTART_AN,\r\ndev->base + TBICR);\r\nwritel(TBICR_MR_AN_ENABLE, dev->base + TBICR);\r\ndev->linkstate = LINK_AUTONEGOTIATE;\r\ndev->CFG_cache |= CFG_MODE_1000;\r\n}\r\nwritel(dev->CFG_cache, dev->base + CFG);\r\ndprintk("CFG: %08x\n", dev->CFG_cache);\r\nif (reset_phy) {\r\nprintk(KERN_INFO "%s: resetting phy\n", ndev->name);\r\nwritel(dev->CFG_cache | CFG_PHY_RST, dev->base + CFG);\r\nmsleep(10);\r\nwritel(dev->CFG_cache, dev->base + CFG);\r\n}\r\n#if 0\r\nif (readl(dev->base + SRR))\r\nwritel(readl(dev->base+0x20c) | 0xfe00, dev->base + 0x20c);\r\n#endif\r\nwritel(TXCFG_CSI | TXCFG_HBI | TXCFG_ATP | TXCFG_MXDMA512\r\n| ((1600 / 32) * 0x100),\r\ndev->base + TXCFG);\r\nwritel(0x000, dev->base + IHR);\r\nwritel(0x100, dev->base + IHR);\r\nwritel(0x000, dev->base + IHR);\r\nwritel(RXCFG_AEP | RXCFG_ARP | RXCFG_AIRL | RXCFG_RX_FD\r\n| RXCFG_STRIPCRC\r\n| (RXCFG_MXDMA512) | 0, dev->base + RXCFG);\r\nwritel(0, dev->base + PQCR);\r\n#ifdef NS83820_VLAN_ACCEL_SUPPORT\r\n#define VRCR_INIT_VALUE (VRCR_IPEN|VRCR_VTDEN|VRCR_VTREN)\r\n#else\r\n#define VRCR_INIT_VALUE (VRCR_IPEN|VRCR_VTDEN)\r\n#endif\r\nwritel(VRCR_INIT_VALUE, dev->base + VRCR);\r\n#ifdef NS83820_VLAN_ACCEL_SUPPORT\r\n#define VTCR_INIT_VALUE (VTCR_PPCHK|VTCR_VPPTI)\r\n#else\r\n#define VTCR_INIT_VALUE VTCR_PPCHK\r\n#endif\r\nwritel(VTCR_INIT_VALUE, dev->base + VTCR);\r\nwritel((PCR_PS_MCAST | PCR_PS_DA | PCR_PSEN | PCR_FFLO_4K |\r\nPCR_FFHI_8K | PCR_STLO_4 | PCR_STHI_8 | PCR_PAUSE_CNT),\r\ndev->base + PCR);\r\nwritel(0, dev->base + WCSR);\r\nns83820_getmac(dev, ndev->dev_addr);\r\nndev->features |= NETIF_F_SG;\r\nndev->features |= NETIF_F_IP_CSUM;\r\n#ifdef NS83820_VLAN_ACCEL_SUPPORT\r\nndev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;\r\n#endif\r\nif (using_dac) {\r\nprintk(KERN_INFO "%s: using 64 bit addressing.\n",\r\nndev->name);\r\nndev->features |= NETIF_F_HIGHDMA;\r\n}\r\nprintk(KERN_INFO "%s: ns83820 v" VERSION ": DP83820 v%u.%u: %pM io=0x%08lx irq=%d f=%s\n",\r\nndev->name,\r\n(unsigned)readl(dev->base + SRR) >> 8,\r\n(unsigned)readl(dev->base + SRR) & 0xff,\r\nndev->dev_addr, addr, pci_dev->irq,\r\n(ndev->features & NETIF_F_HIGHDMA) ? "h,sg" : "sg"\r\n);\r\n#ifdef PHY_CODE_IS_FINISHED\r\nns83820_probe_phy(ndev);\r\n#endif\r\nerr = register_netdevice(ndev);\r\nif (err) {\r\nprintk(KERN_INFO "ns83820: unable to register netdev: %d\n", err);\r\ngoto out_cleanup;\r\n}\r\nrtnl_unlock();\r\nreturn 0;\r\nout_cleanup:\r\nns83820_disable_interrupts(dev);\r\nout_free_irq:\r\nrtnl_unlock();\r\nfree_irq(pci_dev->irq, ndev);\r\nout_disable:\r\nif (dev->base)\r\niounmap(dev->base);\r\npci_free_consistent(pci_dev, 4 * DESC_SIZE * NR_TX_DESC, dev->tx_descs, dev->tx_phy_descs);\r\npci_free_consistent(pci_dev, 4 * DESC_SIZE * NR_RX_DESC, dev->rx_info.descs, dev->rx_info.phy_descs);\r\npci_disable_device(pci_dev);\r\nout_free:\r\nfree_netdev(ndev);\r\npci_set_drvdata(pci_dev, NULL);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __devexit ns83820_remove_one(struct pci_dev *pci_dev)\r\n{\r\nstruct net_device *ndev = pci_get_drvdata(pci_dev);\r\nstruct ns83820 *dev = PRIV(ndev);\r\nif (!ndev)\r\nreturn;\r\nns83820_disable_interrupts(dev);\r\nunregister_netdev(ndev);\r\nfree_irq(dev->pci_dev->irq, ndev);\r\niounmap(dev->base);\r\npci_free_consistent(dev->pci_dev, 4 * DESC_SIZE * NR_TX_DESC,\r\ndev->tx_descs, dev->tx_phy_descs);\r\npci_free_consistent(dev->pci_dev, 4 * DESC_SIZE * NR_RX_DESC,\r\ndev->rx_info.descs, dev->rx_info.phy_descs);\r\npci_disable_device(dev->pci_dev);\r\nfree_netdev(ndev);\r\npci_set_drvdata(pci_dev, NULL);\r\n}\r\nstatic int __init ns83820_init(void)\r\n{\r\nprintk(KERN_INFO "ns83820.c: National Semiconductor DP83820 10/100/1000 driver.\n");\r\nreturn pci_register_driver(&driver);\r\n}\r\nstatic void __exit ns83820_exit(void)\r\n{\r\npci_unregister_driver(&driver);\r\n}
