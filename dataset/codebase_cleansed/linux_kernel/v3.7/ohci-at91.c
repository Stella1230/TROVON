static void at91_start_clock(void)\r\n{\r\nclk_enable(hclk);\r\nclk_enable(iclk);\r\nclk_enable(fclk);\r\nclocked = 1;\r\n}\r\nstatic void at91_stop_clock(void)\r\n{\r\nclk_disable(fclk);\r\nclk_disable(iclk);\r\nclk_disable(hclk);\r\nclocked = 0;\r\n}\r\nstatic void at91_start_hc(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct ohci_regs __iomem *regs = hcd->regs;\r\ndev_dbg(&pdev->dev, "start\n");\r\nat91_start_clock();\r\nwritel(0, &regs->control);\r\n}\r\nstatic void at91_stop_hc(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct ohci_regs __iomem *regs = hcd->regs;\r\ndev_dbg(&pdev->dev, "stop\n");\r\nwritel(0, &regs->control);\r\nat91_stop_clock();\r\n}\r\nstatic int __devinit usb_hcd_at91_probe(const struct hc_driver *driver,\r\nstruct platform_device *pdev)\r\n{\r\nint retval;\r\nstruct usb_hcd *hcd = NULL;\r\nif (pdev->num_resources != 2) {\r\npr_debug("hcd probe: invalid num_resources");\r\nreturn -ENODEV;\r\n}\r\nif ((pdev->resource[0].flags != IORESOURCE_MEM)\r\n|| (pdev->resource[1].flags != IORESOURCE_IRQ)) {\r\npr_debug("hcd probe: invalid resource type\n");\r\nreturn -ENODEV;\r\n}\r\nhcd = usb_create_hcd(driver, &pdev->dev, "at91");\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nhcd->rsrc_start = pdev->resource[0].start;\r\nhcd->rsrc_len = resource_size(&pdev->resource[0]);\r\nif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {\r\npr_debug("request_mem_region failed\n");\r\nretval = -EBUSY;\r\ngoto err1;\r\n}\r\nhcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);\r\nif (!hcd->regs) {\r\npr_debug("ioremap failed\n");\r\nretval = -EIO;\r\ngoto err2;\r\n}\r\niclk = clk_get(&pdev->dev, "ohci_clk");\r\nif (IS_ERR(iclk)) {\r\ndev_err(&pdev->dev, "failed to get ohci_clk\n");\r\nretval = PTR_ERR(iclk);\r\ngoto err3;\r\n}\r\nfclk = clk_get(&pdev->dev, "uhpck");\r\nif (IS_ERR(fclk)) {\r\ndev_err(&pdev->dev, "failed to get uhpck\n");\r\nretval = PTR_ERR(fclk);\r\ngoto err4;\r\n}\r\nhclk = clk_get(&pdev->dev, "hclk");\r\nif (IS_ERR(hclk)) {\r\ndev_err(&pdev->dev, "failed to get hclk\n");\r\nretval = PTR_ERR(hclk);\r\ngoto err5;\r\n}\r\nat91_start_hc(pdev);\r\nohci_hcd_init(hcd_to_ohci(hcd));\r\nretval = usb_add_hcd(hcd, pdev->resource[1].start, IRQF_SHARED);\r\nif (retval == 0)\r\nreturn retval;\r\nat91_stop_hc(pdev);\r\nclk_put(hclk);\r\nerr5:\r\nclk_put(fclk);\r\nerr4:\r\nclk_put(iclk);\r\nerr3:\r\niounmap(hcd->regs);\r\nerr2:\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nerr1:\r\nusb_put_hcd(hcd);\r\nreturn retval;\r\n}\r\nstatic void __devexit usb_hcd_at91_remove(struct usb_hcd *hcd,\r\nstruct platform_device *pdev)\r\n{\r\nusb_remove_hcd(hcd);\r\nat91_stop_hc(pdev);\r\niounmap(hcd->regs);\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nusb_put_hcd(hcd);\r\nclk_put(hclk);\r\nclk_put(fclk);\r\nclk_put(iclk);\r\nfclk = iclk = hclk = NULL;\r\ndev_set_drvdata(&pdev->dev, NULL);\r\n}\r\nstatic int __devinit\r\nohci_at91_reset (struct usb_hcd *hcd)\r\n{\r\nstruct at91_usbh_data *board = hcd->self.controller->platform_data;\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nint ret;\r\nif ((ret = ohci_init(ohci)) < 0)\r\nreturn ret;\r\nohci->num_ports = board->ports;\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\nohci_at91_start (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nint ret;\r\nif ((ret = ohci_run(ohci)) < 0) {\r\ndev_err(hcd->self.controller, "can't start %s\n",\r\nhcd->self.bus_name);\r\nohci_stop(hcd);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ohci_at91_usb_set_power(struct at91_usbh_data *pdata, int port, int enable)\r\n{\r\nif (!valid_port(port))\r\nreturn;\r\nif (!gpio_is_valid(pdata->vbus_pin[port]))\r\nreturn;\r\ngpio_set_value(pdata->vbus_pin[port],\r\npdata->vbus_pin_active_low[port] ^ enable);\r\n}\r\nstatic int ohci_at91_usb_get_power(struct at91_usbh_data *pdata, int port)\r\n{\r\nif (!valid_port(port))\r\nreturn -EINVAL;\r\nif (!gpio_is_valid(pdata->vbus_pin[port]))\r\nreturn -EINVAL;\r\nreturn gpio_get_value(pdata->vbus_pin[port]) ^\r\npdata->vbus_pin_active_low[port];\r\n}\r\nstatic int ohci_at91_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct at91_usbh_data *pdata = hcd->self.controller->platform_data;\r\nint length = ohci_hub_status_data(hcd, buf);\r\nint port;\r\nat91_for_each_port(port) {\r\nif (pdata->overcurrent_changed[port]) {\r\nif (!length)\r\nlength = 1;\r\nbuf[0] |= 1 << (port + 1);\r\n}\r\n}\r\nreturn length;\r\n}\r\nstatic int ohci_at91_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct at91_usbh_data *pdata = hcd->self.controller->platform_data;\r\nstruct usb_hub_descriptor *desc;\r\nint ret = -EINVAL;\r\nu32 *data = (u32 *)buf;\r\ndev_dbg(hcd->self.controller,\r\n"ohci_at91_hub_control(%p,0x%04x,0x%04x,0x%04x,%p,%04x)\n",\r\nhcd, typeReq, wValue, wIndex, buf, wLength);\r\nwIndex--;\r\nswitch (typeReq) {\r\ncase SetPortFeature:\r\nif (wValue == USB_PORT_FEAT_POWER) {\r\ndev_dbg(hcd->self.controller, "SetPortFeat: POWER\n");\r\nif (valid_port(wIndex)) {\r\nohci_at91_usb_set_power(pdata, wIndex, 1);\r\nret = 0;\r\n}\r\ngoto out;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ndev_dbg(hcd->self.controller,\r\n"ClearPortFeature: C_OVER_CURRENT\n");\r\nif (valid_port(wIndex)) {\r\npdata->overcurrent_changed[wIndex] = 0;\r\npdata->overcurrent_status[wIndex] = 0;\r\n}\r\ngoto out;\r\ncase USB_PORT_FEAT_OVER_CURRENT:\r\ndev_dbg(hcd->self.controller,\r\n"ClearPortFeature: OVER_CURRENT\n");\r\nif (valid_port(wIndex))\r\npdata->overcurrent_status[wIndex] = 0;\r\ngoto out;\r\ncase USB_PORT_FEAT_POWER:\r\ndev_dbg(hcd->self.controller,\r\n"ClearPortFeature: POWER\n");\r\nif (valid_port(wIndex)) {\r\nohci_at91_usb_set_power(pdata, wIndex, 0);\r\nreturn 0;\r\n}\r\n}\r\nbreak;\r\n}\r\nret = ohci_hub_control(hcd, typeReq, wValue, wIndex + 1, buf, wLength);\r\nif (ret)\r\ngoto out;\r\nswitch (typeReq) {\r\ncase GetHubDescriptor:\r\ndesc = (struct usb_hub_descriptor *)buf;\r\ndev_dbg(hcd->self.controller, "wHubCharacteristics 0x%04x\n",\r\ndesc->wHubCharacteristics);\r\ndesc->wHubCharacteristics &= ~cpu_to_le16(HUB_CHAR_LPSM);\r\ndesc->wHubCharacteristics |= cpu_to_le16(0x0001);\r\nif (pdata->overcurrent_supported) {\r\ndesc->wHubCharacteristics &= ~cpu_to_le16(HUB_CHAR_OCPM);\r\ndesc->wHubCharacteristics |= cpu_to_le16(0x0008|0x0001);\r\n}\r\ndev_dbg(hcd->self.controller, "wHubCharacteristics after 0x%04x\n",\r\ndesc->wHubCharacteristics);\r\nreturn ret;\r\ncase GetPortStatus:\r\ndev_dbg(hcd->self.controller, "GetPortStatus(%d)\n", wIndex);\r\nif (valid_port(wIndex)) {\r\nif (!ohci_at91_usb_get_power(pdata, wIndex))\r\n*data &= ~cpu_to_le32(RH_PS_PPS);\r\nif (pdata->overcurrent_changed[wIndex])\r\n*data |= cpu_to_le32(RH_PS_OCIC);\r\nif (pdata->overcurrent_status[wIndex])\r\n*data |= cpu_to_le32(RH_PS_POCI);\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic irqreturn_t ohci_hcd_at91_overcurrent_irq(int irq, void *data)\r\n{\r\nstruct platform_device *pdev = data;\r\nstruct at91_usbh_data *pdata = pdev->dev.platform_data;\r\nint val, gpio, port;\r\nat91_for_each_port(port) {\r\nif (gpio_is_valid(pdata->overcurrent_pin[port]) &&\r\ngpio_to_irq(pdata->overcurrent_pin[port]) == irq) {\r\ngpio = pdata->overcurrent_pin[port];\r\nbreak;\r\n}\r\n}\r\nif (port == AT91_MAX_USBH_PORTS) {\r\ndev_err(& pdev->dev, "overcurrent interrupt from unknown GPIO\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nval = gpio_get_value(gpio);\r\nif (!val) {\r\nohci_at91_usb_set_power(pdata, port, 0);\r\npdata->overcurrent_status[port] = 1;\r\npdata->overcurrent_changed[port] = 1;\r\n}\r\ndev_dbg(& pdev->dev, "overcurrent situation %s\n",\r\nval ? "exited" : "notified");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit ohci_at91_of_init(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint i, gpio;\r\nenum of_gpio_flags flags;\r\nstruct at91_usbh_data *pdata;\r\nu32 ports;\r\nif (!np)\r\nreturn 0;\r\nif (!pdev->dev.dma_mask)\r\npdev->dev.dma_mask = &at91_ohci_dma_mask;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nif (!of_property_read_u32(np, "num-ports", &ports))\r\npdata->ports = ports;\r\nat91_for_each_port(i) {\r\ngpio = of_get_named_gpio_flags(np, "atmel,vbus-gpio", i, &flags);\r\npdata->vbus_pin[i] = gpio;\r\nif (!gpio_is_valid(gpio))\r\ncontinue;\r\npdata->vbus_pin_active_low[i] = flags & OF_GPIO_ACTIVE_LOW;\r\n}\r\nat91_for_each_port(i)\r\npdata->overcurrent_pin[i] =\r\nof_get_named_gpio_flags(np, "atmel,oc-gpio", i, &flags);\r\npdev->dev.platform_data = pdata;\r\nreturn 0;\r\n}\r\nstatic int __devinit ohci_at91_of_init(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __devinit ohci_hcd_at91_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct at91_usbh_data *pdata;\r\nint i;\r\nint gpio;\r\nint ret;\r\nret = ohci_at91_of_init(pdev);\r\nif (ret)\r\nreturn ret;\r\npdata = pdev->dev.platform_data;\r\nif (pdata) {\r\nat91_for_each_port(i) {\r\nif (i >= pdata->ports) {\r\npdata->vbus_pin[i] = -EINVAL;\r\npdata->overcurrent_pin[i] = -EINVAL;\r\nbreak;\r\n}\r\nif (!gpio_is_valid(pdata->vbus_pin[i]))\r\ncontinue;\r\ngpio = pdata->vbus_pin[i];\r\nret = gpio_request(gpio, "ohci_vbus");\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"can't request vbus gpio %d\n", gpio);\r\ncontinue;\r\n}\r\nret = gpio_direction_output(gpio,\r\n!pdata->vbus_pin_active_low[i]);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"can't put vbus gpio %d as output %d\n",\r\ngpio, !pdata->vbus_pin_active_low[i]);\r\ngpio_free(gpio);\r\ncontinue;\r\n}\r\nohci_at91_usb_set_power(pdata, i, 1);\r\n}\r\nat91_for_each_port(i) {\r\nif (!gpio_is_valid(pdata->overcurrent_pin[i]))\r\ncontinue;\r\ngpio = pdata->overcurrent_pin[i];\r\nret = gpio_request(gpio, "ohci_overcurrent");\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"can't request overcurrent gpio %d\n",\r\ngpio);\r\ncontinue;\r\n}\r\nret = gpio_direction_input(gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"can't configure overcurrent gpio %d as input\n",\r\ngpio);\r\ngpio_free(gpio);\r\ncontinue;\r\n}\r\nret = request_irq(gpio_to_irq(gpio),\r\nohci_hcd_at91_overcurrent_irq,\r\nIRQF_SHARED, "ohci_overcurrent", pdev);\r\nif (ret) {\r\ngpio_free(gpio);\r\ndev_err(&pdev->dev,\r\n"can't get gpio IRQ for overcurrent\n");\r\n}\r\n}\r\n}\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn usb_hcd_at91_probe(&ohci_at91_hc_driver, pdev);\r\n}\r\nstatic int __devexit ohci_hcd_at91_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct at91_usbh_data *pdata = pdev->dev.platform_data;\r\nint i;\r\nif (pdata) {\r\nat91_for_each_port(i) {\r\nif (!gpio_is_valid(pdata->vbus_pin[i]))\r\ncontinue;\r\nohci_at91_usb_set_power(pdata, i, 0);\r\ngpio_free(pdata->vbus_pin[i]);\r\n}\r\nat91_for_each_port(i) {\r\nif (!gpio_is_valid(pdata->overcurrent_pin[i]))\r\ncontinue;\r\nfree_irq(gpio_to_irq(pdata->overcurrent_pin[i]), pdev);\r\ngpio_free(pdata->overcurrent_pin[i]);\r\n}\r\n}\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nusb_hcd_at91_remove(platform_get_drvdata(pdev), pdev);\r\nreturn 0;\r\n}\r\nstatic int\r\nohci_hcd_at91_drv_suspend(struct platform_device *pdev, pm_message_t mesg)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nif (device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(hcd->irq);\r\nif (at91_suspend_entering_slow_clock()) {\r\nohci_usb_reset (ohci);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\nat91_stop_clock();\r\n}\r\nreturn 0;\r\n}\r\nstatic int ohci_hcd_at91_drv_resume(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nif (device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(hcd->irq);\r\nif (!clocked)\r\nat91_start_clock();\r\nohci_finish_controller_resume(hcd);\r\nreturn 0;\r\n}
