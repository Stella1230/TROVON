void smc_set_timing(struct smc_config *config,\r\nconst struct smc_timing *timing)\r\n{\r\nint recover;\r\nint cycle;\r\nunsigned long mul;\r\nconfig->ncs_read_setup = 0;\r\nconfig->nrd_setup = 0;\r\nconfig->ncs_write_setup = 0;\r\nconfig->nwe_setup = 0;\r\nconfig->ncs_read_pulse = 0;\r\nconfig->nrd_pulse = 0;\r\nconfig->ncs_write_pulse = 0;\r\nconfig->nwe_pulse = 0;\r\nconfig->read_cycle = 0;\r\nconfig->write_cycle = 0;\r\nmul = (clk_get_rate(hsmc->mck) / 10000) << 16;\r\nmul /= 100000;\r\n#define ns2cyc(x) ((((x) * mul) + 65535) >> 16)\r\nif (timing->ncs_read_setup > 0)\r\nconfig->ncs_read_setup = ns2cyc(timing->ncs_read_setup);\r\nif (timing->nrd_setup > 0)\r\nconfig->nrd_setup = ns2cyc(timing->nrd_setup);\r\nif (timing->ncs_write_setup > 0)\r\nconfig->ncs_write_setup = ns2cyc(timing->ncs_write_setup);\r\nif (timing->nwe_setup > 0)\r\nconfig->nwe_setup = ns2cyc(timing->nwe_setup);\r\nif (timing->ncs_read_pulse > 0)\r\nconfig->ncs_read_pulse = ns2cyc(timing->ncs_read_pulse);\r\nif (timing->nrd_pulse > 0)\r\nconfig->nrd_pulse = ns2cyc(timing->nrd_pulse);\r\nif (timing->ncs_write_pulse > 0)\r\nconfig->ncs_write_pulse = ns2cyc(timing->ncs_write_pulse);\r\nif (timing->nwe_pulse > 0)\r\nconfig->nwe_pulse = ns2cyc(timing->nwe_pulse);\r\nif (timing->read_cycle > 0)\r\nconfig->read_cycle = ns2cyc(timing->read_cycle);\r\nif (timing->write_cycle > 0)\r\nconfig->write_cycle = ns2cyc(timing->write_cycle);\r\nif (timing->ncs_read_recover > 0)\r\nrecover = ns2cyc(timing->ncs_read_recover);\r\nelse\r\nrecover = 1;\r\ncycle = config->ncs_read_setup + config->ncs_read_pulse + recover;\r\nif (config->read_cycle < cycle)\r\nconfig->read_cycle = cycle;\r\nif (timing->nrd_recover > 0)\r\nrecover = ns2cyc(timing->nrd_recover);\r\nelse\r\nrecover = 1;\r\ncycle = config->nrd_setup + config->nrd_pulse + recover;\r\nif (config->read_cycle < cycle)\r\nconfig->read_cycle = cycle;\r\nif (timing->ncs_write_recover > 0)\r\nrecover = ns2cyc(timing->ncs_write_recover);\r\nelse\r\nrecover = 1;\r\ncycle = config->ncs_write_setup + config->ncs_write_pulse + recover;\r\nif (config->write_cycle < cycle)\r\nconfig->write_cycle = cycle;\r\nif (timing->nwe_recover > 0)\r\nrecover = ns2cyc(timing->nwe_recover);\r\nelse\r\nrecover = 1;\r\ncycle = config->nwe_setup + config->nwe_pulse + recover;\r\nif (config->write_cycle < cycle)\r\nconfig->write_cycle = cycle;\r\n}\r\nint smc_set_configuration(int cs, const struct smc_config *config)\r\n{\r\nunsigned long offset;\r\nu32 setup, pulse, cycle, mode;\r\nif (!hsmc)\r\nreturn -ENODEV;\r\nif (cs >= NR_CHIP_SELECTS)\r\nreturn -EINVAL;\r\nsetup = (HSMC_BF(NWE_SETUP, config->nwe_setup)\r\n| HSMC_BF(NCS_WR_SETUP, config->ncs_write_setup)\r\n| HSMC_BF(NRD_SETUP, config->nrd_setup)\r\n| HSMC_BF(NCS_RD_SETUP, config->ncs_read_setup));\r\npulse = (HSMC_BF(NWE_PULSE, config->nwe_pulse)\r\n| HSMC_BF(NCS_WR_PULSE, config->ncs_write_pulse)\r\n| HSMC_BF(NRD_PULSE, config->nrd_pulse)\r\n| HSMC_BF(NCS_RD_PULSE, config->ncs_read_pulse));\r\ncycle = (HSMC_BF(NWE_CYCLE, config->write_cycle)\r\n| HSMC_BF(NRD_CYCLE, config->read_cycle));\r\nswitch (config->bus_width) {\r\ncase 1:\r\nmode = HSMC_BF(DBW, HSMC_DBW_8_BITS);\r\nbreak;\r\ncase 2:\r\nmode = HSMC_BF(DBW, HSMC_DBW_16_BITS);\r\nbreak;\r\ncase 4:\r\nmode = HSMC_BF(DBW, HSMC_DBW_32_BITS);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (config->nwait_mode) {\r\ncase 0:\r\nmode |= HSMC_BF(EXNW_MODE, HSMC_EXNW_MODE_DISABLED);\r\nbreak;\r\ncase 1:\r\nmode |= HSMC_BF(EXNW_MODE, HSMC_EXNW_MODE_RESERVED);\r\nbreak;\r\ncase 2:\r\nmode |= HSMC_BF(EXNW_MODE, HSMC_EXNW_MODE_FROZEN);\r\nbreak;\r\ncase 3:\r\nmode |= HSMC_BF(EXNW_MODE, HSMC_EXNW_MODE_READY);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (config->tdf_cycles) {\r\nmode |= HSMC_BF(TDF_CYCLES, config->tdf_cycles);\r\n}\r\nif (config->nrd_controlled)\r\nmode |= HSMC_BIT(READ_MODE);\r\nif (config->nwe_controlled)\r\nmode |= HSMC_BIT(WRITE_MODE);\r\nif (config->byte_write)\r\nmode |= HSMC_BIT(BAT);\r\nif (config->tdf_mode)\r\nmode |= HSMC_BIT(TDF_MODE);\r\npr_debug("smc cs%d: setup/%08x pulse/%08x cycle/%08x mode/%08x\n",\r\ncs, setup, pulse, cycle, mode);\r\noffset = cs * 0x10;\r\nhsmc_writel(hsmc, SETUP0 + offset, setup);\r\nhsmc_writel(hsmc, PULSE0 + offset, pulse);\r\nhsmc_writel(hsmc, CYCLE0 + offset, cycle);\r\nhsmc_writel(hsmc, MODE0 + offset, mode);\r\nhsmc_readl(hsmc, MODE0);\r\nreturn 0;\r\n}\r\nstatic int hsmc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *regs;\r\nstruct clk *pclk, *mck;\r\nint ret;\r\nif (hsmc)\r\nreturn -EBUSY;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs)\r\nreturn -ENXIO;\r\npclk = clk_get(&pdev->dev, "pclk");\r\nif (IS_ERR(pclk))\r\nreturn PTR_ERR(pclk);\r\nmck = clk_get(&pdev->dev, "mck");\r\nif (IS_ERR(mck)) {\r\nret = PTR_ERR(mck);\r\ngoto out_put_pclk;\r\n}\r\nret = -ENOMEM;\r\nhsmc = kzalloc(sizeof(struct hsmc), GFP_KERNEL);\r\nif (!hsmc)\r\ngoto out_put_clocks;\r\nclk_enable(pclk);\r\nclk_enable(mck);\r\nhsmc->pclk = pclk;\r\nhsmc->mck = mck;\r\nhsmc->regs = ioremap(regs->start, resource_size(regs));\r\nif (!hsmc->regs)\r\ngoto out_disable_clocks;\r\ndev_info(&pdev->dev, "Atmel Static Memory Controller at 0x%08lx\n",\r\n(unsigned long)regs->start);\r\nplatform_set_drvdata(pdev, hsmc);\r\nreturn 0;\r\nout_disable_clocks:\r\nclk_disable(mck);\r\nclk_disable(pclk);\r\nkfree(hsmc);\r\nout_put_clocks:\r\nclk_put(mck);\r\nout_put_pclk:\r\nclk_put(pclk);\r\nhsmc = NULL;\r\nreturn ret;\r\n}\r\nstatic int __init hsmc_init(void)\r\n{\r\nreturn platform_driver_register(&hsmc_driver);\r\n}
