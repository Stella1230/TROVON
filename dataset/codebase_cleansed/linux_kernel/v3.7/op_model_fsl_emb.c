static inline u32 get_pmlca(int ctr)\r\n{\r\nu32 pmlca;\r\nswitch (ctr) {\r\ncase 0:\r\npmlca = mfpmr(PMRN_PMLCA0);\r\nbreak;\r\ncase 1:\r\npmlca = mfpmr(PMRN_PMLCA1);\r\nbreak;\r\ncase 2:\r\npmlca = mfpmr(PMRN_PMLCA2);\r\nbreak;\r\ncase 3:\r\npmlca = mfpmr(PMRN_PMLCA3);\r\nbreak;\r\ndefault:\r\npanic("Bad ctr number\n");\r\n}\r\nreturn pmlca;\r\n}\r\nstatic inline void set_pmlca(int ctr, u32 pmlca)\r\n{\r\nswitch (ctr) {\r\ncase 0:\r\nmtpmr(PMRN_PMLCA0, pmlca);\r\nbreak;\r\ncase 1:\r\nmtpmr(PMRN_PMLCA1, pmlca);\r\nbreak;\r\ncase 2:\r\nmtpmr(PMRN_PMLCA2, pmlca);\r\nbreak;\r\ncase 3:\r\nmtpmr(PMRN_PMLCA3, pmlca);\r\nbreak;\r\ndefault:\r\npanic("Bad ctr number\n");\r\n}\r\n}\r\nstatic inline unsigned int ctr_read(unsigned int i)\r\n{\r\nswitch(i) {\r\ncase 0:\r\nreturn mfpmr(PMRN_PMC0);\r\ncase 1:\r\nreturn mfpmr(PMRN_PMC1);\r\ncase 2:\r\nreturn mfpmr(PMRN_PMC2);\r\ncase 3:\r\nreturn mfpmr(PMRN_PMC3);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline void ctr_write(unsigned int i, unsigned int val)\r\n{\r\nswitch(i) {\r\ncase 0:\r\nmtpmr(PMRN_PMC0, val);\r\nbreak;\r\ncase 1:\r\nmtpmr(PMRN_PMC1, val);\r\nbreak;\r\ncase 2:\r\nmtpmr(PMRN_PMC2, val);\r\nbreak;\r\ncase 3:\r\nmtpmr(PMRN_PMC3, val);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void init_pmc_stop(int ctr)\r\n{\r\nu32 pmlca = (PMLCA_FC | PMLCA_FCS | PMLCA_FCU |\r\nPMLCA_FCM1 | PMLCA_FCM0);\r\nu32 pmlcb = 0;\r\nswitch (ctr) {\r\ncase 0:\r\nmtpmr(PMRN_PMLCA0, pmlca);\r\nmtpmr(PMRN_PMLCB0, pmlcb);\r\nbreak;\r\ncase 1:\r\nmtpmr(PMRN_PMLCA1, pmlca);\r\nmtpmr(PMRN_PMLCB1, pmlcb);\r\nbreak;\r\ncase 2:\r\nmtpmr(PMRN_PMLCA2, pmlca);\r\nmtpmr(PMRN_PMLCB2, pmlcb);\r\nbreak;\r\ncase 3:\r\nmtpmr(PMRN_PMLCA3, pmlca);\r\nmtpmr(PMRN_PMLCB3, pmlcb);\r\nbreak;\r\ndefault:\r\npanic("Bad ctr number!\n");\r\n}\r\n}\r\nstatic void set_pmc_event(int ctr, int event)\r\n{\r\nu32 pmlca;\r\npmlca = get_pmlca(ctr);\r\npmlca = (pmlca & ~PMLCA_EVENT_MASK) |\r\n((event << PMLCA_EVENT_SHIFT) &\r\nPMLCA_EVENT_MASK);\r\nset_pmlca(ctr, pmlca);\r\n}\r\nstatic void set_pmc_user_kernel(int ctr, int user, int kernel)\r\n{\r\nu32 pmlca;\r\npmlca = get_pmlca(ctr);\r\nif(user)\r\npmlca &= ~PMLCA_FCU;\r\nelse\r\npmlca |= PMLCA_FCU;\r\nif(kernel)\r\npmlca &= ~PMLCA_FCS;\r\nelse\r\npmlca |= PMLCA_FCS;\r\nset_pmlca(ctr, pmlca);\r\n}\r\nstatic void set_pmc_marked(int ctr, int mark0, int mark1)\r\n{\r\nu32 pmlca = get_pmlca(ctr);\r\nif(mark0)\r\npmlca &= ~PMLCA_FCM0;\r\nelse\r\npmlca |= PMLCA_FCM0;\r\nif(mark1)\r\npmlca &= ~PMLCA_FCM1;\r\nelse\r\npmlca |= PMLCA_FCM1;\r\nset_pmlca(ctr, pmlca);\r\n}\r\nstatic void pmc_start_ctr(int ctr, int enable)\r\n{\r\nu32 pmlca = get_pmlca(ctr);\r\npmlca &= ~PMLCA_FC;\r\nif (enable)\r\npmlca |= PMLCA_CE;\r\nelse\r\npmlca &= ~PMLCA_CE;\r\nset_pmlca(ctr, pmlca);\r\n}\r\nstatic void pmc_start_ctrs(int enable)\r\n{\r\nu32 pmgc0 = mfpmr(PMRN_PMGC0);\r\npmgc0 &= ~PMGC0_FAC;\r\npmgc0 |= PMGC0_FCECE;\r\nif (enable)\r\npmgc0 |= PMGC0_PMIE;\r\nelse\r\npmgc0 &= ~PMGC0_PMIE;\r\nmtpmr(PMRN_PMGC0, pmgc0);\r\n}\r\nstatic void pmc_stop_ctrs(void)\r\n{\r\nu32 pmgc0 = mfpmr(PMRN_PMGC0);\r\npmgc0 |= PMGC0_FAC;\r\npmgc0 &= ~(PMGC0_PMIE | PMGC0_FCECE);\r\nmtpmr(PMRN_PMGC0, pmgc0);\r\n}\r\nstatic int fsl_emb_cpu_setup(struct op_counter_config *ctr)\r\n{\r\nint i;\r\npmc_stop_ctrs();\r\nfor (i = 0;i < num_counters;i++) {\r\ninit_pmc_stop(i);\r\nset_pmc_event(i, ctr[i].event);\r\nset_pmc_user_kernel(i, ctr[i].user, ctr[i].kernel);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_emb_reg_setup(struct op_counter_config *ctr,\r\nstruct op_system_config *sys,\r\nint num_ctrs)\r\n{\r\nint i;\r\nnum_counters = num_ctrs;\r\nfor (i = 0; i < num_counters; ++i)\r\nreset_value[i] = 0x80000000UL - ctr[i].count;\r\nreturn 0;\r\n}\r\nstatic int fsl_emb_start(struct op_counter_config *ctr)\r\n{\r\nint i;\r\nmtmsr(mfmsr() | MSR_PMM);\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (ctr[i].enabled) {\r\nctr_write(i, reset_value[i]);\r\nset_pmc_marked(i, 1, 0);\r\npmc_start_ctr(i, 1);\r\n} else {\r\nctr_write(i, 0);\r\npmc_start_ctr(i, 0);\r\n}\r\n}\r\npmc_start_ctrs(1);\r\noprofile_running = 1;\r\npr_debug("start on cpu %d, pmgc0 %x\n", smp_processor_id(),\r\nmfpmr(PMRN_PMGC0));\r\nreturn 0;\r\n}\r\nstatic void fsl_emb_stop(void)\r\n{\r\npmc_stop_ctrs();\r\noprofile_running = 0;\r\npr_debug("stop on cpu %d, pmgc0 %x\n", smp_processor_id(),\r\nmfpmr(PMRN_PMGC0));\r\nmb();\r\n}\r\nstatic void fsl_emb_handle_interrupt(struct pt_regs *regs,\r\nstruct op_counter_config *ctr)\r\n{\r\nunsigned long pc;\r\nint is_kernel;\r\nint val;\r\nint i;\r\npc = regs->nip;\r\nis_kernel = is_kernel_addr(pc);\r\nfor (i = 0; i < num_counters; ++i) {\r\nval = ctr_read(i);\r\nif (val < 0) {\r\nif (oprofile_running && ctr[i].enabled) {\r\noprofile_add_ext_sample(pc, regs, i, is_kernel);\r\nctr_write(i, reset_value[i]);\r\n} else {\r\nctr_write(i, 0);\r\n}\r\n}\r\n}\r\nmtmsr(mfmsr() | MSR_PMM);\r\npmc_start_ctrs(1);\r\n}
