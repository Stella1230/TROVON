static int zl10036_read_status_reg(struct zl10036_state *state)\r\n{\r\nu8 status;\r\nstruct i2c_msg msg[1] = {\r\n{ .addr = state->config->tuner_address, .flags = I2C_M_RD,\r\n.buf = &status, .len = sizeof(status) },\r\n};\r\nif (i2c_transfer(state->i2c, msg, 1) != 1) {\r\nprintk(KERN_ERR "%s: i2c read failed at addr=%02x\n",\r\n__func__, state->config->tuner_address);\r\nreturn -EIO;\r\n}\r\ndeb_i2c("R(status): %02x [FL=%d]\n", status,\r\n(status & STATUS_FL) ? 1 : 0);\r\nif (status & STATUS_POR)\r\ndeb_info("%s: Power-On-Reset bit enabled - "\r\n"need to initialize the tuner\n", __func__);\r\nreturn status;\r\n}\r\nstatic int zl10036_write(struct zl10036_state *state, u8 buf[], u8 count)\r\n{\r\nstruct i2c_msg msg[1] = {\r\n{ .addr = state->config->tuner_address, .flags = 0,\r\n.buf = buf, .len = count },\r\n};\r\nu8 reg = 0;\r\nint ret;\r\nif (zl10036_debug & 0x02) {\r\nif ((buf[0] & 0x80) == 0x00)\r\nreg = 2;\r\nelse if ((buf[0] & 0xc0) == 0x80)\r\nreg = 4;\r\nelse if ((buf[0] & 0xf0) == 0xc0)\r\nreg = 6;\r\nelse if ((buf[0] & 0xf0) == 0xd0)\r\nreg = 8;\r\nelse if ((buf[0] & 0xf0) == 0xe0)\r\nreg = 10;\r\nelse if ((buf[0] & 0xf0) == 0xf0)\r\nreg = 12;\r\ndeb_i2c("W(%d):", reg);\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++)\r\nprintk(KERN_CONT " %02x", buf[i]);\r\nprintk(KERN_CONT "\n");\r\n}\r\n}\r\nret = i2c_transfer(state->i2c, msg, 1);\r\nif (ret != 1) {\r\nprintk(KERN_ERR "%s: i2c error, ret=%d\n", __func__, ret);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zl10036_release(struct dvb_frontend *fe)\r\n{\r\nstruct zl10036_state *state = fe->tuner_priv;\r\nfe->tuner_priv = NULL;\r\nkfree(state);\r\nreturn 0;\r\n}\r\nstatic int zl10036_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct zl10036_state *state = fe->tuner_priv;\r\nu8 buf[] = { 0xf0, 0x80 };\r\nint ret;\r\ndeb_info("%s\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = zl10036_write(state, buf, sizeof(buf));\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\n}\r\nstatic int zl10036_set_frequency(struct zl10036_state *state, u32 frequency)\r\n{\r\nu8 buf[2];\r\nu32 div, foffset;\r\ndiv = (frequency + _FR/2) / _FR;\r\nstate->frequency = div * _FR;\r\nfoffset = frequency - state->frequency;\r\nbuf[0] = (div >> 8) & 0x7f;\r\nbuf[1] = (div >> 0) & 0xff;\r\ndeb_info("%s: ftodo=%u fpriv=%u ferr=%d div=%u\n", __func__,\r\nfrequency, state->frequency, foffset, div);\r\nreturn zl10036_write(state, buf, sizeof(buf));\r\n}\r\nstatic int zl10036_set_bandwidth(struct zl10036_state *state, u32 fbw)\r\n{\r\nu8 br, bf;\r\nint ret;\r\nu8 buf_bf[] = {\r\n0xc0, 0x00,\r\n};\r\nu8 buf_br[] = {\r\n0xf0, 0x00,\r\n};\r\nu8 zl10036_rsd_off[] = { 0xc8 };\r\nif (fbw > 35000)\r\nfbw = 35000;\r\nif (fbw < 8000)\r\nfbw = 8000;\r\n#define _BR_MAXIMUM (_XTAL/575)\r\nif (fbw <= 28820) {\r\nbr = _BR_MAXIMUM;\r\n} else {\r\nbr = ((_XTAL * 21 * 1000) / (fbw * 419));\r\n}\r\nif (br < 4)\r\nbr = 4;\r\nif (br > _BR_MAXIMUM)\r\nbr = _BR_MAXIMUM;\r\nbf = (fbw * br * 1257) / (_XTAL * 1000) - 1;\r\nif (bf > 62)\r\nbf = 62;\r\nbuf_bf[1] = (bf << 1) & 0x7e;\r\nbuf_br[1] = (br << 2) & 0x7c;\r\ndeb_info("%s: BW=%d br=%u bf=%u\n", __func__, fbw, br, bf);\r\nif (br != state->br) {\r\nret = zl10036_write(state, buf_br, sizeof(buf_br));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (bf != state->bf) {\r\nret = zl10036_write(state, buf_bf, sizeof(buf_bf));\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(1);\r\nret = zl10036_write(state, zl10036_rsd_off,\r\nsizeof(zl10036_rsd_off));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nstate->br = br;\r\nstate->bf = bf;\r\nreturn 0;\r\n}\r\nstatic int zl10036_set_gain_params(struct zl10036_state *state,\r\nint c)\r\n{\r\nu8 buf[2];\r\nu8 rfg, ba, bg;\r\nrfg = 0;\r\nba = 1;\r\nbg = 1;\r\nbuf[0] = 0x80 | ((rfg << 5) & 0x20)\r\n| ((ba << 3) & 0x18) | ((bg << 1) & 0x06);\r\nif (!state->config->rf_loop_enable)\r\nbuf[0] |= 0x01;\r\nbuf[1] = _RDIV_REG | ((c << 5) & 0x60);\r\ndeb_info("%s: c=%u rfg=%u ba=%u bg=%u\n", __func__, c, rfg, ba, bg);\r\nreturn zl10036_write(state, buf, sizeof(buf));\r\n}\r\nstatic int zl10036_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct zl10036_state *state = fe->tuner_priv;\r\nint ret = 0;\r\nu32 frequency = p->frequency;\r\nu32 fbw;\r\nint i;\r\nu8 c;\r\nif ((frequency < fe->ops.info.frequency_min)\r\n|| (frequency > fe->ops.info.frequency_max))\r\nreturn -EINVAL;\r\nfbw = (27 * p->symbol_rate) / 32;\r\nfbw /= 1000;\r\nfbw += 3000;\r\nif (frequency < 950000)\r\nreturn -EINVAL;\r\nelse if (frequency < 1250000)\r\nc = 0;\r\nelse if (frequency < 1750000)\r\nc = 1;\r\nelse if (frequency < 2175000)\r\nc = 2;\r\nelse\r\nreturn -EINVAL;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = zl10036_set_gain_params(state, c);\r\nif (ret < 0)\r\ngoto error;\r\nret = zl10036_set_frequency(state, p->frequency);\r\nif (ret < 0)\r\ngoto error;\r\nret = zl10036_set_bandwidth(state, fbw);\r\nif (ret < 0)\r\ngoto error;\r\nfor (i = 0; i < 20; i++) {\r\nret = zl10036_read_status_reg(state);\r\nif (ret < 0)\r\ngoto error;\r\nif (ret & STATUS_FL)\r\nbreak;\r\nmsleep(10);\r\n}\r\nerror:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\n}\r\nstatic int zl10036_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct zl10036_state *state = fe->tuner_priv;\r\n*frequency = state->frequency;\r\nreturn 0;\r\n}\r\nstatic int zl10036_init_regs(struct zl10036_state *state)\r\n{\r\nint ret;\r\nint i;\r\nu8 zl10036_init_tab[][2] = {\r\n{ 0x04, 0x00 },\r\n{ 0x8b, _RDIV_REG },\r\n{ 0xc0, 0x20 },\r\n{ 0xd3, 0x40 },\r\n{ 0xe3, 0x5b },\r\n{ 0xf0, 0x28 },\r\n{ 0xe3, 0xf9 },\r\n};\r\nstate->br = 0xff;\r\nstate->bf = 0xff;\r\nif (!state->config->rf_loop_enable)\r\nzl10036_init_tab[1][0] |= 0x01;\r\ndeb_info("%s\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(zl10036_init_tab); i++) {\r\nret = zl10036_write(state, zl10036_init_tab[i], 2);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zl10036_init(struct dvb_frontend *fe)\r\n{\r\nstruct zl10036_state *state = fe->tuner_priv;\r\nint ret = 0;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = zl10036_read_status_reg(state);\r\nif (ret < 0)\r\nreturn ret;\r\nret = zl10036_init_regs(state);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\n}\r\nstruct dvb_frontend *zl10036_attach(struct dvb_frontend *fe,\r\nconst struct zl10036_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct zl10036_state *state;\r\nint ret;\r\nif (!config) {\r\nprintk(KERN_ERR "%s: no config specified", __func__);\r\nreturn NULL;\r\n}\r\nstate = kzalloc(sizeof(struct zl10036_state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = zl10036_read_status_reg(state);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: No zl10036 found\n", __func__);\r\ngoto error;\r\n}\r\nret = zl10036_init_regs(state);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: tuner initialization failed\n",\r\n__func__);\r\ngoto error;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nfe->tuner_priv = state;\r\nmemcpy(&fe->ops.tuner_ops, &zl10036_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nprintk(KERN_INFO "%s: tuner initialization (%s addr=0x%02x) ok\n",\r\n__func__, fe->ops.tuner_ops.info.name, config->tuner_address);\r\nreturn fe;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
