struct ssp_device *pxa_ssp_request(int port, const char *label)\r\n{\r\nstruct ssp_device *ssp = NULL;\r\nmutex_lock(&ssp_lock);\r\nlist_for_each_entry(ssp, &ssp_list, node) {\r\nif (ssp->port_id == port && ssp->use_count == 0) {\r\nssp->use_count++;\r\nssp->label = label;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&ssp_lock);\r\nif (&ssp->node == &ssp_list)\r\nreturn NULL;\r\nreturn ssp;\r\n}\r\nvoid pxa_ssp_free(struct ssp_device *ssp)\r\n{\r\nmutex_lock(&ssp_lock);\r\nif (ssp->use_count) {\r\nssp->use_count--;\r\nssp->label = NULL;\r\n} else\r\ndev_err(&ssp->pdev->dev, "device already free\n");\r\nmutex_unlock(&ssp_lock);\r\n}\r\nstatic int __devinit ce4100_spi_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint ret;\r\nresource_size_t phys_beg;\r\nresource_size_t phys_len;\r\nstruct ce4100_info *spi_info;\r\nstruct platform_device *pdev;\r\nstruct pxa2xx_spi_master spi_pdata;\r\nstruct ssp_device *ssp;\r\nret = pci_enable_device(dev);\r\nif (ret)\r\nreturn ret;\r\nphys_beg = pci_resource_start(dev, 0);\r\nphys_len = pci_resource_len(dev, 0);\r\nif (!request_mem_region(phys_beg, phys_len,\r\n"CE4100 SPI")) {\r\ndev_err(&dev->dev, "Can't request register space.\n");\r\nret = -EBUSY;\r\nreturn ret;\r\n}\r\npdev = platform_device_alloc("pxa2xx-spi", dev->devfn);\r\nspi_info = kzalloc(sizeof(*spi_info), GFP_KERNEL);\r\nif (!pdev || !spi_info ) {\r\nret = -ENOMEM;\r\ngoto err_nomem;\r\n}\r\nmemset(&spi_pdata, 0, sizeof(spi_pdata));\r\nspi_pdata.num_chipselect = dev->devfn;\r\nret = platform_device_add_data(pdev, &spi_pdata, sizeof(spi_pdata));\r\nif (ret)\r\ngoto err_nomem;\r\npdev->dev.parent = &dev->dev;\r\npdev->dev.of_node = dev->dev.of_node;\r\nssp = &spi_info->ssp;\r\nssp->phys_base = pci_resource_start(dev, 0);\r\nssp->mmio_base = ioremap(phys_beg, phys_len);\r\nif (!ssp->mmio_base) {\r\ndev_err(&pdev->dev, "failed to ioremap() registers\n");\r\nret = -EIO;\r\ngoto err_nomem;\r\n}\r\nssp->irq = dev->irq;\r\nssp->port_id = pdev->id;\r\nssp->type = PXA25x_SSP;\r\nmutex_lock(&ssp_lock);\r\nlist_add(&ssp->node, &ssp_list);\r\nmutex_unlock(&ssp_lock);\r\npci_set_drvdata(dev, spi_info);\r\nret = platform_device_add(pdev);\r\nif (ret)\r\ngoto err_dev_add;\r\nreturn ret;\r\nerr_dev_add:\r\npci_set_drvdata(dev, NULL);\r\nmutex_lock(&ssp_lock);\r\nlist_del(&ssp->node);\r\nmutex_unlock(&ssp_lock);\r\niounmap(ssp->mmio_base);\r\nerr_nomem:\r\nrelease_mem_region(phys_beg, phys_len);\r\nplatform_device_put(pdev);\r\nkfree(spi_info);\r\nreturn ret;\r\n}\r\nstatic void __devexit ce4100_spi_remove(struct pci_dev *dev)\r\n{\r\nstruct ce4100_info *spi_info;\r\nstruct ssp_device *ssp;\r\nspi_info = pci_get_drvdata(dev);\r\nssp = &spi_info->ssp;\r\nplatform_device_unregister(spi_info->spi_pdev);\r\niounmap(ssp->mmio_base);\r\nrelease_mem_region(pci_resource_start(dev, 0),\r\npci_resource_len(dev, 0));\r\nmutex_lock(&ssp_lock);\r\nlist_del(&ssp->node);\r\nmutex_unlock(&ssp_lock);\r\npci_set_drvdata(dev, NULL);\r\npci_disable_device(dev);\r\nkfree(spi_info);\r\n}
