static int postprocess_read(u32 data, int where, unsigned int size)\r\n{\r\nu32 ret;\r\nret = 0;\r\nswitch (size) {\r\ncase 1:\r\nret = (data >> ((where & 3) << 3)) & 0xff;\r\nbreak;\r\ncase 2:\r\nret = (data >> ((where & 3) << 3)) & 0xffff;\r\nbreak;\r\ncase 4:\r\nret = data;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int preprocess_write(u32 orig_data, u32 val, int where,\r\nunsigned int size)\r\n{\r\nu32 ret;\r\nret = 0;\r\nswitch (size) {\r\ncase 1:\r\nret = (orig_data & ~(0xff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nbreak;\r\ncase 2:\r\nret = (orig_data & ~(0xffff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nbreak;\r\ncase 4:\r\nret = val;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int bcm63xx_setup_cfg_access(int type, unsigned int busn,\r\nunsigned int devfn, int where)\r\n{\r\nunsigned int slot, func, reg;\r\nu32 val;\r\nslot = PCI_SLOT(devfn);\r\nfunc = PCI_FUNC(devfn);\r\nreg = where >> 2;\r\nif (slot > (MPI_L2PCFG_DEVNUM_MASK >> MPI_L2PCFG_DEVNUM_SHIFT))\r\nreturn 1;\r\nif (func > (MPI_L2PCFG_FUNC_MASK >> MPI_L2PCFG_FUNC_SHIFT))\r\nreturn 1;\r\nif (reg > (MPI_L2PCFG_REG_MASK >> MPI_L2PCFG_REG_SHIFT))\r\nreturn 1;\r\nval = (reg << MPI_L2PCFG_REG_SHIFT);\r\nval |= (func << MPI_L2PCFG_FUNC_SHIFT);\r\nval |= (slot << MPI_L2PCFG_DEVNUM_SHIFT);\r\nval |= MPI_L2PCFG_CFG_USEREG_MASK;\r\nval |= MPI_L2PCFG_CFG_SEL_MASK;\r\nif (type != 0) {\r\nval |= (1 << MPI_L2PCFG_CFG_TYPE_SHIFT);\r\n}\r\nbcm_mpi_writel(val, MPI_L2PCFG_REG);\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_do_cfg_read(int type, unsigned int busn,\r\nunsigned int devfn, int where, int size,\r\nu32 *val)\r\n{\r\nu32 data;\r\nif (bcm63xx_setup_cfg_access(type, busn, devfn, where))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\niob();\r\ndata = le32_to_cpu(__raw_readl(pci_iospace_start));\r\nbcm_mpi_writel(0, MPI_L2PCFG_REG);\r\n*val = postprocess_read(data, where, size);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int bcm63xx_do_cfg_write(int type, unsigned int busn,\r\nunsigned int devfn, int where, int size,\r\nu32 val)\r\n{\r\nu32 data;\r\nif (bcm63xx_setup_cfg_access(type, busn, devfn, where))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\niob();\r\ndata = le32_to_cpu(__raw_readl(pci_iospace_start));\r\ndata = preprocess_write(data, val, where, size);\r\n__raw_writel(cpu_to_le32(data), pci_iospace_start);\r\nwmb();\r\nudelay(500);\r\nbcm_mpi_writel(0, MPI_L2PCFG_REG);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int bcm63xx_pci_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nint type;\r\ntype = bus->parent ? 1 : 0;\r\nif (type == 0 && PCI_SLOT(devfn) == CARDBUS_PCI_IDSEL)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nreturn bcm63xx_do_cfg_read(type, bus->number, devfn,\r\nwhere, size, val);\r\n}\r\nstatic int bcm63xx_pci_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nint type;\r\ntype = bus->parent ? 1 : 0;\r\nif (type == 0 && PCI_SLOT(devfn) == CARDBUS_PCI_IDSEL)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nreturn bcm63xx_do_cfg_write(type, bus->number, devfn,\r\nwhere, size, val);\r\n}\r\nstatic int fake_cb_bridge_read(int where, int size, u32 *val)\r\n{\r\nunsigned int reg;\r\nu32 data;\r\ndata = 0;\r\nreg = where >> 2;\r\nswitch (reg) {\r\ncase (PCI_VENDOR_ID >> 2):\r\ncase (PCI_CB_SUBSYSTEM_VENDOR_ID >> 2):\r\ndata = (bcm63xx_get_cpu_id() << 16) | PCI_VENDOR_ID_BROADCOM;\r\nbreak;\r\ncase (PCI_COMMAND >> 2):\r\ndata = (PCI_STATUS_DEVSEL_SLOW << 16);\r\ndata |= fake_cb_bridge_regs.pci_command;\r\nbreak;\r\ncase (PCI_CLASS_REVISION >> 2):\r\ndata = (PCI_CLASS_BRIDGE_CARDBUS << 16);\r\nbreak;\r\ncase (PCI_CACHE_LINE_SIZE >> 2):\r\ndata = (PCI_HEADER_TYPE_CARDBUS << 16);\r\nbreak;\r\ncase (PCI_INTERRUPT_LINE >> 2):\r\ndata = (fake_cb_bridge_regs.bridge_control << 16);\r\ndata |= (0x1 << 8) | 0xff;\r\nbreak;\r\ncase (PCI_CB_PRIMARY_BUS >> 2):\r\ndata = (fake_cb_bridge_regs.cb_latency << 24);\r\ndata |= (fake_cb_bridge_regs.subordinate_busn << 16);\r\ndata |= (fake_cb_bridge_regs.cardbus_busn << 8);\r\ndata |= fake_cb_bridge_regs.pci_busn;\r\nbreak;\r\ncase (PCI_CB_MEMORY_BASE_0 >> 2):\r\ndata = fake_cb_bridge_regs.mem_base0;\r\nbreak;\r\ncase (PCI_CB_MEMORY_LIMIT_0 >> 2):\r\ndata = fake_cb_bridge_regs.mem_limit0;\r\nbreak;\r\ncase (PCI_CB_MEMORY_BASE_1 >> 2):\r\ndata = fake_cb_bridge_regs.mem_base1;\r\nbreak;\r\ncase (PCI_CB_MEMORY_LIMIT_1 >> 2):\r\ndata = fake_cb_bridge_regs.mem_limit1;\r\nbreak;\r\ncase (PCI_CB_IO_BASE_0 >> 2):\r\ndata = fake_cb_bridge_regs.io_base0 | 0x1;\r\nbreak;\r\ncase (PCI_CB_IO_LIMIT_0 >> 2):\r\ndata = fake_cb_bridge_regs.io_limit0;\r\nbreak;\r\ncase (PCI_CB_IO_BASE_1 >> 2):\r\ndata = fake_cb_bridge_regs.io_base1 | 0x1;\r\nbreak;\r\ncase (PCI_CB_IO_LIMIT_1 >> 2):\r\ndata = fake_cb_bridge_regs.io_limit1;\r\nbreak;\r\n}\r\n*val = postprocess_read(data, where, size);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int fake_cb_bridge_write(int where, int size, u32 val)\r\n{\r\nunsigned int reg;\r\nu32 data, tmp;\r\nint ret;\r\nret = fake_cb_bridge_read((where & ~0x3), 4, &data);\r\nif (ret != PCIBIOS_SUCCESSFUL)\r\nreturn ret;\r\ndata = preprocess_write(data, val, where, size);\r\nreg = where >> 2;\r\nswitch (reg) {\r\ncase (PCI_COMMAND >> 2):\r\nfake_cb_bridge_regs.pci_command = (data & 0xffff);\r\nbreak;\r\ncase (PCI_CB_PRIMARY_BUS >> 2):\r\nfake_cb_bridge_regs.cb_latency = (data >> 24) & 0xff;\r\nfake_cb_bridge_regs.subordinate_busn = (data >> 16) & 0xff;\r\nfake_cb_bridge_regs.cardbus_busn = (data >> 8) & 0xff;\r\nfake_cb_bridge_regs.pci_busn = data & 0xff;\r\nif (fake_cb_bridge_regs.cardbus_busn)\r\nfake_cb_bridge_regs.bus_assigned = 1;\r\nbreak;\r\ncase (PCI_INTERRUPT_LINE >> 2):\r\ntmp = (data >> 16) & 0xffff;\r\ntmp &= ~PCI_CB_BRIDGE_CTL_PREFETCH_MEM0;\r\ntmp &= ~PCI_CB_BRIDGE_CTL_PREFETCH_MEM1;\r\nfake_cb_bridge_regs.bridge_control = tmp;\r\nbreak;\r\ncase (PCI_CB_MEMORY_BASE_0 >> 2):\r\nfake_cb_bridge_regs.mem_base0 = data;\r\nbreak;\r\ncase (PCI_CB_MEMORY_LIMIT_0 >> 2):\r\nfake_cb_bridge_regs.mem_limit0 = data;\r\nbreak;\r\ncase (PCI_CB_MEMORY_BASE_1 >> 2):\r\nfake_cb_bridge_regs.mem_base1 = data;\r\nbreak;\r\ncase (PCI_CB_MEMORY_LIMIT_1 >> 2):\r\nfake_cb_bridge_regs.mem_limit1 = data;\r\nbreak;\r\ncase (PCI_CB_IO_BASE_0 >> 2):\r\nfake_cb_bridge_regs.io_base0 = data;\r\nbreak;\r\ncase (PCI_CB_IO_LIMIT_0 >> 2):\r\nfake_cb_bridge_regs.io_limit0 = data;\r\nbreak;\r\ncase (PCI_CB_IO_BASE_1 >> 2):\r\nfake_cb_bridge_regs.io_base1 = data;\r\nbreak;\r\ncase (PCI_CB_IO_LIMIT_1 >> 2):\r\nfake_cb_bridge_regs.io_limit1 = data;\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int bcm63xx_cb_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nif (!bus->parent && PCI_SLOT(devfn) == FAKE_CB_BRIDGE_SLOT) {\r\nfake_cb_bridge_bus_number = bus->number;\r\nreturn fake_cb_bridge_read(where, size, val);\r\n}\r\nif (fake_cb_bridge_regs.bus_assigned &&\r\nbus->number == fake_cb_bridge_regs.cardbus_busn &&\r\nPCI_SLOT(devfn) == 0)\r\nreturn bcm63xx_do_cfg_read(0, 0,\r\nPCI_DEVFN(CARDBUS_PCI_IDSEL, 0),\r\nwhere, size, val);\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nstatic int bcm63xx_cb_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nif (!bus->parent && PCI_SLOT(devfn) == FAKE_CB_BRIDGE_SLOT) {\r\nfake_cb_bridge_bus_number = bus->number;\r\nreturn fake_cb_bridge_write(where, size, val);\r\n}\r\nif (fake_cb_bridge_regs.bus_assigned &&\r\nbus->number == fake_cb_bridge_regs.cardbus_busn &&\r\nPCI_SLOT(devfn) == 0)\r\nreturn bcm63xx_do_cfg_write(0, 0,\r\nPCI_DEVFN(CARDBUS_PCI_IDSEL, 0),\r\nwhere, size, val);\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nstatic void __devinit bcm63xx_fixup(struct pci_dev *dev)\r\n{\r\nstatic int io_window = -1;\r\nint i, found, new_io_window;\r\nu32 val;\r\nfound = 0;\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\r\nif (pci_resource_flags(dev, i) & IORESOURCE_IO) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn;\r\nif (dev->bus->number == fake_cb_bridge_bus_number)\r\nreturn;\r\nif (fake_cb_bridge_regs.bus_assigned &&\r\ndev->bus->number == fake_cb_bridge_regs.cardbus_busn &&\r\nPCI_SLOT(dev->devfn) == 0)\r\nnew_io_window = 1;\r\nelse\r\nnew_io_window = 0;\r\nif (new_io_window == io_window)\r\nreturn;\r\nif (io_window != -1) {\r\nprintk(KERN_ERR "bcm63xx: both PCI and cardbus devices "\r\n"need IO, which hardware cannot do\n");\r\nreturn;\r\n}\r\nprintk(KERN_INFO "bcm63xx: PCI IO window assigned to %s\n",\r\n(new_io_window == 0) ? "PCI" : "cardbus");\r\nval = bcm_mpi_readl(MPI_L2PIOREMAP_REG);\r\nif (io_window)\r\nval |= MPI_L2PREMAP_IS_CARDBUS_MASK;\r\nelse\r\nval &= ~MPI_L2PREMAP_IS_CARDBUS_MASK;\r\nbcm_mpi_writel(val, MPI_L2PIOREMAP_REG);\r\nio_window = new_io_window;\r\n}\r\nstatic int bcm63xx_pcie_can_access(struct pci_bus *bus, int devfn)\r\n{\r\nswitch (bus->number) {\r\ncase PCIE_BUS_BRIDGE:\r\nreturn (PCI_SLOT(devfn) == 0);\r\ncase PCIE_BUS_DEVICE:\r\nif (PCI_SLOT(devfn) == 0)\r\nreturn bcm_pcie_readl(PCIE_DLSTATUS_REG)\r\n& DLSTATUS_PHYLINKUP;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int bcm63xx_pcie_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nu32 data;\r\nu32 reg = where & ~3;\r\nif (!bcm63xx_pcie_can_access(bus, devfn))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (bus->number == PCIE_BUS_DEVICE)\r\nreg += PCIE_DEVICE_OFFSET;\r\ndata = bcm_pcie_readl(reg);\r\n*val = postprocess_read(data, where, size);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int bcm63xx_pcie_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nu32 data;\r\nu32 reg = where & ~3;\r\nif (!bcm63xx_pcie_can_access(bus, devfn))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (bus->number == PCIE_BUS_DEVICE)\r\nreg += PCIE_DEVICE_OFFSET;\r\ndata = bcm_pcie_readl(reg);\r\ndata = preprocess_write(data, val, where, size);\r\nbcm_pcie_writel(data, reg);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}
