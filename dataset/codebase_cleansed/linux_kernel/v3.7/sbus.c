void sbus_set_sbus64(struct device *dev, int bursts)\r\n{\r\nstruct iommu *iommu = dev->archdata.iommu;\r\nstruct platform_device *op = to_platform_device(dev);\r\nconst struct linux_prom_registers *regs;\r\nunsigned long cfg_reg;\r\nint slot;\r\nu64 val;\r\nregs = of_get_property(op->dev.of_node, "reg", NULL);\r\nif (!regs) {\r\nprintk(KERN_ERR "sbus_set_sbus64: Cannot find regs for %s\n",\r\nop->dev.of_node->full_name);\r\nreturn;\r\n}\r\nslot = regs->which_io;\r\ncfg_reg = iommu->write_complete_reg;\r\nswitch (slot) {\r\ncase 0:\r\ncfg_reg += 0x20UL;\r\nbreak;\r\ncase 1:\r\ncfg_reg += 0x28UL;\r\nbreak;\r\ncase 2:\r\ncfg_reg += 0x30UL;\r\nbreak;\r\ncase 3:\r\ncfg_reg += 0x38UL;\r\nbreak;\r\ncase 13:\r\ncfg_reg += 0x40UL;\r\nbreak;\r\ncase 14:\r\ncfg_reg += 0x48UL;\r\nbreak;\r\ncase 15:\r\ncfg_reg += 0x50UL;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nval = upa_readq(cfg_reg);\r\nif (val & (1UL << 14UL)) {\r\nreturn;\r\n}\r\nval |= (1UL << 14UL);\r\nif (bursts & DMA_BURST8)\r\nval |= (1UL << 1UL);\r\nif (bursts & DMA_BURST16)\r\nval |= (1UL << 2UL);\r\nif (bursts & DMA_BURST32)\r\nval |= (1UL << 3UL);\r\nif (bursts & DMA_BURST64)\r\nval |= (1UL << 4UL);\r\nupa_writeq(val, cfg_reg);\r\n}\r\nstatic unsigned long sysio_imap_to_iclr(unsigned long imap)\r\n{\r\nunsigned long diff = SYSIO_ICLR_UNUSED0 - SYSIO_IMAP_SLOT0;\r\nreturn imap + diff;\r\n}\r\nstatic unsigned int sbus_build_irq(struct platform_device *op, unsigned int ino)\r\n{\r\nstruct iommu *iommu = op->dev.archdata.iommu;\r\nunsigned long reg_base = iommu->write_complete_reg - 0x2000UL;\r\nunsigned long imap, iclr;\r\nint sbus_level = 0;\r\nimap = sysio_irq_offsets[ino];\r\nif (imap == ((unsigned long)-1)) {\r\nprom_printf("get_irq_translations: Bad SYSIO INO[%x]\n",\r\nino);\r\nprom_halt();\r\n}\r\nimap += reg_base;\r\nif (ino >= 0x20) {\r\niclr = sysio_imap_to_iclr(imap);\r\n} else {\r\nint sbus_slot = (ino & 0x18)>>3;\r\nsbus_level = ino & 0x7;\r\nswitch(sbus_slot) {\r\ncase 0:\r\niclr = reg_base + SYSIO_ICLR_SLOT0;\r\nbreak;\r\ncase 1:\r\niclr = reg_base + SYSIO_ICLR_SLOT1;\r\nbreak;\r\ncase 2:\r\niclr = reg_base + SYSIO_ICLR_SLOT2;\r\nbreak;\r\ndefault:\r\ncase 3:\r\niclr = reg_base + SYSIO_ICLR_SLOT3;\r\nbreak;\r\n}\r\niclr += ((unsigned long)sbus_level - 1UL) * 8UL;\r\n}\r\nreturn build_irq(sbus_level, iclr, imap);\r\n}\r\nstatic irqreturn_t sysio_ue_handler(int irq, void *dev_id)\r\n{\r\nstruct platform_device *op = dev_id;\r\nstruct iommu *iommu = op->dev.archdata.iommu;\r\nunsigned long reg_base = iommu->write_complete_reg - 0x2000UL;\r\nunsigned long afsr_reg, afar_reg;\r\nunsigned long afsr, afar, error_bits;\r\nint reported, portid;\r\nafsr_reg = reg_base + SYSIO_UE_AFSR;\r\nafar_reg = reg_base + SYSIO_UE_AFAR;\r\nafsr = upa_readq(afsr_reg);\r\nafar = upa_readq(afar_reg);\r\nerror_bits = afsr &\r\n(SYSIO_UEAFSR_PPIO | SYSIO_UEAFSR_PDRD | SYSIO_UEAFSR_PDWR |\r\nSYSIO_UEAFSR_SPIO | SYSIO_UEAFSR_SDRD | SYSIO_UEAFSR_SDWR);\r\nupa_writeq(error_bits, afsr_reg);\r\nportid = of_getintprop_default(op->dev.of_node, "portid", -1);\r\nprintk("SYSIO[%x]: Uncorrectable ECC Error, primary error type[%s]\n",\r\nportid,\r\n(((error_bits & SYSIO_UEAFSR_PPIO) ?\r\n"PIO" :\r\n((error_bits & SYSIO_UEAFSR_PDRD) ?\r\n"DVMA Read" :\r\n((error_bits & SYSIO_UEAFSR_PDWR) ?\r\n"DVMA Write" : "???")))));\r\nprintk("SYSIO[%x]: DOFF[%lx] SIZE[%lx] MID[%lx]\n",\r\nportid,\r\n(afsr & SYSIO_UEAFSR_DOFF) >> 45UL,\r\n(afsr & SYSIO_UEAFSR_SIZE) >> 42UL,\r\n(afsr & SYSIO_UEAFSR_MID) >> 37UL);\r\nprintk("SYSIO[%x]: AFAR[%016lx]\n", portid, afar);\r\nprintk("SYSIO[%x]: Secondary UE errors [", portid);\r\nreported = 0;\r\nif (afsr & SYSIO_UEAFSR_SPIO) {\r\nreported++;\r\nprintk("(PIO)");\r\n}\r\nif (afsr & SYSIO_UEAFSR_SDRD) {\r\nreported++;\r\nprintk("(DVMA Read)");\r\n}\r\nif (afsr & SYSIO_UEAFSR_SDWR) {\r\nreported++;\r\nprintk("(DVMA Write)");\r\n}\r\nif (!reported)\r\nprintk("(none)");\r\nprintk("]\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sysio_ce_handler(int irq, void *dev_id)\r\n{\r\nstruct platform_device *op = dev_id;\r\nstruct iommu *iommu = op->dev.archdata.iommu;\r\nunsigned long reg_base = iommu->write_complete_reg - 0x2000UL;\r\nunsigned long afsr_reg, afar_reg;\r\nunsigned long afsr, afar, error_bits;\r\nint reported, portid;\r\nafsr_reg = reg_base + SYSIO_CE_AFSR;\r\nafar_reg = reg_base + SYSIO_CE_AFAR;\r\nafsr = upa_readq(afsr_reg);\r\nafar = upa_readq(afar_reg);\r\nerror_bits = afsr &\r\n(SYSIO_CEAFSR_PPIO | SYSIO_CEAFSR_PDRD | SYSIO_CEAFSR_PDWR |\r\nSYSIO_CEAFSR_SPIO | SYSIO_CEAFSR_SDRD | SYSIO_CEAFSR_SDWR);\r\nupa_writeq(error_bits, afsr_reg);\r\nportid = of_getintprop_default(op->dev.of_node, "portid", -1);\r\nprintk("SYSIO[%x]: Correctable ECC Error, primary error type[%s]\n",\r\nportid,\r\n(((error_bits & SYSIO_CEAFSR_PPIO) ?\r\n"PIO" :\r\n((error_bits & SYSIO_CEAFSR_PDRD) ?\r\n"DVMA Read" :\r\n((error_bits & SYSIO_CEAFSR_PDWR) ?\r\n"DVMA Write" : "???")))));\r\nprintk("SYSIO[%x]: DOFF[%lx] ECC Syndrome[%lx] Size[%lx] MID[%lx]\n",\r\nportid,\r\n(afsr & SYSIO_CEAFSR_DOFF) >> 45UL,\r\n(afsr & SYSIO_CEAFSR_ESYND) >> 48UL,\r\n(afsr & SYSIO_CEAFSR_SIZE) >> 42UL,\r\n(afsr & SYSIO_CEAFSR_MID) >> 37UL);\r\nprintk("SYSIO[%x]: AFAR[%016lx]\n", portid, afar);\r\nprintk("SYSIO[%x]: Secondary CE errors [", portid);\r\nreported = 0;\r\nif (afsr & SYSIO_CEAFSR_SPIO) {\r\nreported++;\r\nprintk("(PIO)");\r\n}\r\nif (afsr & SYSIO_CEAFSR_SDRD) {\r\nreported++;\r\nprintk("(DVMA Read)");\r\n}\r\nif (afsr & SYSIO_CEAFSR_SDWR) {\r\nreported++;\r\nprintk("(DVMA Write)");\r\n}\r\nif (!reported)\r\nprintk("(none)");\r\nprintk("]\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sysio_sbus_error_handler(int irq, void *dev_id)\r\n{\r\nstruct platform_device *op = dev_id;\r\nstruct iommu *iommu = op->dev.archdata.iommu;\r\nunsigned long afsr_reg, afar_reg, reg_base;\r\nunsigned long afsr, afar, error_bits;\r\nint reported, portid;\r\nreg_base = iommu->write_complete_reg - 0x2000UL;\r\nafsr_reg = reg_base + SYSIO_SBUS_AFSR;\r\nafar_reg = reg_base + SYSIO_SBUS_AFAR;\r\nafsr = upa_readq(afsr_reg);\r\nafar = upa_readq(afar_reg);\r\nerror_bits = afsr &\r\n(SYSIO_SBAFSR_PLE | SYSIO_SBAFSR_PTO | SYSIO_SBAFSR_PBERR |\r\nSYSIO_SBAFSR_SLE | SYSIO_SBAFSR_STO | SYSIO_SBAFSR_SBERR);\r\nupa_writeq(error_bits, afsr_reg);\r\nportid = of_getintprop_default(op->dev.of_node, "portid", -1);\r\nprintk("SYSIO[%x]: SBUS Error, primary error type[%s] read(%d)\n",\r\nportid,\r\n(((error_bits & SYSIO_SBAFSR_PLE) ?\r\n"Late PIO Error" :\r\n((error_bits & SYSIO_SBAFSR_PTO) ?\r\n"Time Out" :\r\n((error_bits & SYSIO_SBAFSR_PBERR) ?\r\n"Error Ack" : "???")))),\r\n(afsr & SYSIO_SBAFSR_RD) ? 1 : 0);\r\nprintk("SYSIO[%x]: size[%lx] MID[%lx]\n",\r\nportid,\r\n(afsr & SYSIO_SBAFSR_SIZE) >> 42UL,\r\n(afsr & SYSIO_SBAFSR_MID) >> 37UL);\r\nprintk("SYSIO[%x]: AFAR[%016lx]\n", portid, afar);\r\nprintk("SYSIO[%x]: Secondary SBUS errors [", portid);\r\nreported = 0;\r\nif (afsr & SYSIO_SBAFSR_SLE) {\r\nreported++;\r\nprintk("(Late PIO Error)");\r\n}\r\nif (afsr & SYSIO_SBAFSR_STO) {\r\nreported++;\r\nprintk("(Time Out)");\r\n}\r\nif (afsr & SYSIO_SBAFSR_SBERR) {\r\nreported++;\r\nprintk("(Error Ack)");\r\n}\r\nif (!reported)\r\nprintk("(none)");\r\nprintk("]\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __init sysio_register_error_handlers(struct platform_device *op)\r\n{\r\nstruct iommu *iommu = op->dev.archdata.iommu;\r\nunsigned long reg_base = iommu->write_complete_reg - 0x2000UL;\r\nunsigned int irq;\r\nu64 control;\r\nint portid;\r\nportid = of_getintprop_default(op->dev.of_node, "portid", -1);\r\nirq = sbus_build_irq(op, SYSIO_UE_INO);\r\nif (request_irq(irq, sysio_ue_handler, 0,\r\n"SYSIO_UE", op) < 0) {\r\nprom_printf("SYSIO[%x]: Cannot register UE interrupt.\n",\r\nportid);\r\nprom_halt();\r\n}\r\nirq = sbus_build_irq(op, SYSIO_CE_INO);\r\nif (request_irq(irq, sysio_ce_handler, 0,\r\n"SYSIO_CE", op) < 0) {\r\nprom_printf("SYSIO[%x]: Cannot register CE interrupt.\n",\r\nportid);\r\nprom_halt();\r\n}\r\nirq = sbus_build_irq(op, SYSIO_SBUSERR_INO);\r\nif (request_irq(irq, sysio_sbus_error_handler, 0,\r\n"SYSIO_SBERR", op) < 0) {\r\nprom_printf("SYSIO[%x]: Cannot register SBUS Error interrupt.\n",\r\nportid);\r\nprom_halt();\r\n}\r\nupa_writeq((SYSIO_ECNTRL_ECCEN |\r\nSYSIO_ECNTRL_UEEN |\r\nSYSIO_ECNTRL_CEEN),\r\nreg_base + ECC_CONTROL);\r\ncontrol = upa_readq(iommu->write_complete_reg);\r\ncontrol |= 0x100UL;\r\nupa_writeq(control, iommu->write_complete_reg);\r\n}\r\nstatic void __init sbus_iommu_init(struct platform_device *op)\r\n{\r\nconst struct linux_prom64_registers *pr;\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct iommu *iommu;\r\nstruct strbuf *strbuf;\r\nunsigned long regs, reg_base;\r\nint i, portid;\r\nu64 control;\r\npr = of_get_property(dp, "reg", NULL);\r\nif (!pr) {\r\nprom_printf("sbus_iommu_init: Cannot map SYSIO "\r\n"control registers.\n");\r\nprom_halt();\r\n}\r\nregs = pr->phys_addr;\r\niommu = kzalloc(sizeof(*iommu), GFP_ATOMIC);\r\nif (!iommu)\r\ngoto fatal_memory_error;\r\nstrbuf = kzalloc(sizeof(*strbuf), GFP_ATOMIC);\r\nif (!strbuf)\r\ngoto fatal_memory_error;\r\nop->dev.archdata.iommu = iommu;\r\nop->dev.archdata.stc = strbuf;\r\nop->dev.archdata.numa_node = -1;\r\nreg_base = regs + SYSIO_IOMMUREG_BASE;\r\niommu->iommu_control = reg_base + IOMMU_CONTROL;\r\niommu->iommu_tsbbase = reg_base + IOMMU_TSBBASE;\r\niommu->iommu_flush = reg_base + IOMMU_FLUSH;\r\niommu->iommu_tags = iommu->iommu_control +\r\n(IOMMU_TAGDIAG - IOMMU_CONTROL);\r\nreg_base = regs + SYSIO_STRBUFREG_BASE;\r\nstrbuf->strbuf_control = reg_base + STRBUF_CONTROL;\r\nstrbuf->strbuf_pflush = reg_base + STRBUF_PFLUSH;\r\nstrbuf->strbuf_fsync = reg_base + STRBUF_FSYNC;\r\nstrbuf->strbuf_enabled = 1;\r\nstrbuf->strbuf_flushflag = (volatile unsigned long *)\r\n((((unsigned long)&strbuf->__flushflag_buf[0])\r\n+ 63UL)\r\n& ~63UL);\r\nstrbuf->strbuf_flushflag_pa = (unsigned long)\r\n__pa(strbuf->strbuf_flushflag);\r\niommu->write_complete_reg = regs + 0x2000UL;\r\nportid = of_getintprop_default(op->dev.of_node, "portid", -1);\r\nprintk(KERN_INFO "SYSIO: UPA portID %x, at %016lx\n",\r\nportid, regs);\r\nif (iommu_table_init(iommu, IO_TSB_SIZE, MAP_BASE, 0xffffffff, -1))\r\ngoto fatal_memory_error;\r\ncontrol = upa_readq(iommu->iommu_control);\r\ncontrol = ((7UL << 16UL) |\r\n(0UL << 2UL) |\r\n(1UL << 1UL) |\r\n(1UL << 0UL));\r\nupa_writeq(control, iommu->iommu_control);\r\nfor (i = 0; i < 16; i++) {\r\nunsigned long dram, tag;\r\ndram = iommu->iommu_control + (IOMMU_DRAMDIAG - IOMMU_CONTROL);\r\ntag = iommu->iommu_control + (IOMMU_TAGDIAG - IOMMU_CONTROL);\r\ndram += (unsigned long)i * 8UL;\r\ntag += (unsigned long)i * 8UL;\r\nupa_writeq(0, dram);\r\nupa_writeq(0, tag);\r\n}\r\nupa_readq(iommu->write_complete_reg);\r\nupa_writeq(__pa(iommu->page_table), iommu->iommu_tsbbase);\r\ncontrol = (1UL << 1UL) | (1UL << 0UL);\r\nupa_writeq(control, strbuf->strbuf_control);\r\nfor (i = 0; i < 16; i++) {\r\nunsigned long ptag, ltag;\r\nptag = strbuf->strbuf_control +\r\n(STRBUF_PTAGDIAG - STRBUF_CONTROL);\r\nltag = strbuf->strbuf_control +\r\n(STRBUF_LTAGDIAG - STRBUF_CONTROL);\r\nptag += (unsigned long)i * 8UL;\r\nltag += (unsigned long)i * 8UL;\r\nupa_writeq(0UL, ptag);\r\nupa_writeq(0UL, ltag);\r\n}\r\ncontrol = upa_readq(iommu->write_complete_reg);\r\ncontrol |= 0x3fUL;\r\nupa_writeq(control, iommu->write_complete_reg);\r\nif (this_is_starfire)\r\nstarfire_hookup(portid);\r\nsysio_register_error_handlers(op);\r\nreturn;\r\nfatal_memory_error:\r\nprom_printf("sbus_iommu_init: Fatal memory allocation error.\n");\r\n}\r\nstatic int __init sbus_init(void)\r\n{\r\nstruct device_node *dp;\r\nfor_each_node_by_name(dp, "sbus") {\r\nstruct platform_device *op = of_find_device_by_node(dp);\r\nsbus_iommu_init(op);\r\nof_propagate_archdata(op);\r\n}\r\nreturn 0;\r\n}
