static int brcmf_proto_cdc_msg(struct brcmf_pub *drvr)\r\n{\r\nstruct brcmf_proto *prot = drvr->prot;\r\nint len = le32_to_cpu(prot->msg.len) +\r\nsizeof(struct brcmf_proto_cdc_dcmd);\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (len > CDC_MAX_MSG_SIZE)\r\nlen = CDC_MAX_MSG_SIZE;\r\nreturn drvr->bus_if->brcmf_bus_txctl(drvr->dev,\r\n(unsigned char *)&prot->msg,\r\nlen);\r\n}\r\nstatic int brcmf_proto_cdc_cmplt(struct brcmf_pub *drvr, u32 id, u32 len)\r\n{\r\nint ret;\r\nstruct brcmf_proto *prot = drvr->prot;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\ndo {\r\nret = drvr->bus_if->brcmf_bus_rxctl(drvr->dev,\r\n(unsigned char *)&prot->msg,\r\nlen + sizeof(struct brcmf_proto_cdc_dcmd));\r\nif (ret < 0)\r\nbreak;\r\n} while (CDC_DCMD_ID(le32_to_cpu(prot->msg.flags)) != id);\r\nreturn ret;\r\n}\r\nint\r\nbrcmf_proto_cdc_query_dcmd(struct brcmf_pub *drvr, int ifidx, uint cmd,\r\nvoid *buf, uint len)\r\n{\r\nstruct brcmf_proto *prot = drvr->prot;\r\nstruct brcmf_proto_cdc_dcmd *msg = &prot->msg;\r\nvoid *info;\r\nint ret = 0, retries = 0;\r\nu32 id, flags;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nbrcmf_dbg(CTL, "cmd %d len %d\n", cmd, len);\r\nif (cmd == BRCMF_C_GET_VAR && buf) {\r\nif (!strcmp((char *)buf, "bcmerrorstr")) {\r\nstrncpy((char *)buf, "bcm_error",\r\nBCME_STRLEN);\r\ngoto done;\r\n} else if (!strcmp((char *)buf, "bcmerror")) {\r\n*(int *)buf = drvr->dongle_error;\r\ngoto done;\r\n}\r\n}\r\nmemset(msg, 0, sizeof(struct brcmf_proto_cdc_dcmd));\r\nmsg->cmd = cpu_to_le32(cmd);\r\nmsg->len = cpu_to_le32(len);\r\nflags = (++prot->reqid << CDC_DCMD_ID_SHIFT);\r\nflags = (flags & ~CDC_DCMD_IF_MASK) |\r\n(ifidx << CDC_DCMD_IF_SHIFT);\r\nmsg->flags = cpu_to_le32(flags);\r\nif (buf)\r\nmemcpy(prot->buf, buf, len);\r\nret = brcmf_proto_cdc_msg(drvr);\r\nif (ret < 0) {\r\nbrcmf_dbg(ERROR, "brcmf_proto_cdc_msg failed w/status %d\n",\r\nret);\r\ngoto done;\r\n}\r\nretry:\r\nret = brcmf_proto_cdc_cmplt(drvr, prot->reqid, len);\r\nif (ret < 0)\r\ngoto done;\r\nflags = le32_to_cpu(msg->flags);\r\nid = (flags & CDC_DCMD_ID_MASK) >> CDC_DCMD_ID_SHIFT;\r\nif ((id < prot->reqid) && (++retries < RETRIES))\r\ngoto retry;\r\nif (id != prot->reqid) {\r\nbrcmf_dbg(ERROR, "%s: unexpected request id %d (expected %d)\n",\r\nbrcmf_ifname(drvr, ifidx), id, prot->reqid);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\ninfo = (void *)&msg[1];\r\nif (buf) {\r\nif (ret < (int)len)\r\nlen = ret;\r\nmemcpy(buf, info, len);\r\n}\r\nif (flags & CDC_DCMD_ERROR) {\r\nret = le32_to_cpu(msg->status);\r\ndrvr->dongle_error = ret;\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nint brcmf_proto_cdc_set_dcmd(struct brcmf_pub *drvr, int ifidx, uint cmd,\r\nvoid *buf, uint len)\r\n{\r\nstruct brcmf_proto *prot = drvr->prot;\r\nstruct brcmf_proto_cdc_dcmd *msg = &prot->msg;\r\nint ret = 0;\r\nu32 flags, id;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nbrcmf_dbg(CTL, "cmd %d len %d\n", cmd, len);\r\nmemset(msg, 0, sizeof(struct brcmf_proto_cdc_dcmd));\r\nmsg->cmd = cpu_to_le32(cmd);\r\nmsg->len = cpu_to_le32(len);\r\nflags = (++prot->reqid << CDC_DCMD_ID_SHIFT) | CDC_DCMD_SET;\r\nflags = (flags & ~CDC_DCMD_IF_MASK) |\r\n(ifidx << CDC_DCMD_IF_SHIFT);\r\nmsg->flags = cpu_to_le32(flags);\r\nif (buf)\r\nmemcpy(prot->buf, buf, len);\r\nret = brcmf_proto_cdc_msg(drvr);\r\nif (ret < 0)\r\ngoto done;\r\nret = brcmf_proto_cdc_cmplt(drvr, prot->reqid, len);\r\nif (ret < 0)\r\ngoto done;\r\nflags = le32_to_cpu(msg->flags);\r\nid = (flags & CDC_DCMD_ID_MASK) >> CDC_DCMD_ID_SHIFT;\r\nif (id != prot->reqid) {\r\nbrcmf_dbg(ERROR, "%s: unexpected request id %d (expected %d)\n",\r\nbrcmf_ifname(drvr, ifidx), id, prot->reqid);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (flags & CDC_DCMD_ERROR) {\r\nret = le32_to_cpu(msg->status);\r\ndrvr->dongle_error = ret;\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nint\r\nbrcmf_proto_dcmd(struct brcmf_pub *drvr, int ifidx, struct brcmf_dcmd *dcmd,\r\nint len)\r\n{\r\nstruct brcmf_proto *prot = drvr->prot;\r\nint ret = -1;\r\nif (drvr->bus_if->state == BRCMF_BUS_DOWN) {\r\nbrcmf_dbg(ERROR, "bus is down. we have nothing to do.\n");\r\nreturn ret;\r\n}\r\nmutex_lock(&drvr->proto_block);\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (len > BRCMF_DCMD_MAXLEN)\r\ngoto done;\r\nif (prot->pending == true) {\r\nbrcmf_dbg(TRACE, "CDC packet is pending!!!! cmd=0x%x (%lu) lastcmd=0x%x (%lu)\n",\r\ndcmd->cmd, (unsigned long)dcmd->cmd, prot->lastcmd,\r\n(unsigned long)prot->lastcmd);\r\nif (dcmd->cmd == BRCMF_C_SET_VAR ||\r\ndcmd->cmd == BRCMF_C_GET_VAR)\r\nbrcmf_dbg(TRACE, "iovar cmd=%s\n", (char *)dcmd->buf);\r\ngoto done;\r\n}\r\nprot->pending = true;\r\nprot->lastcmd = dcmd->cmd;\r\nif (dcmd->set)\r\nret = brcmf_proto_cdc_set_dcmd(drvr, ifidx, dcmd->cmd,\r\ndcmd->buf, len);\r\nelse {\r\nret = brcmf_proto_cdc_query_dcmd(drvr, ifidx, dcmd->cmd,\r\ndcmd->buf, len);\r\nif (ret > 0)\r\ndcmd->used = ret -\r\nsizeof(struct brcmf_proto_cdc_dcmd);\r\n}\r\nif (ret >= 0)\r\nret = 0;\r\nelse {\r\nstruct brcmf_proto_cdc_dcmd *msg = &prot->msg;\r\ndcmd->needed = le32_to_cpu(msg->len);\r\n}\r\nif (!ret && dcmd->cmd == BRCMF_C_SET_VAR &&\r\n!strcmp(dcmd->buf, "wme_dp")) {\r\nint slen;\r\n__le32 val = 0;\r\nslen = strlen("wme_dp") + 1;\r\nif (len >= (int)(slen + sizeof(int)))\r\nmemcpy(&val, (char *)dcmd->buf + slen, sizeof(int));\r\ndrvr->wme_dp = (u8) le32_to_cpu(val);\r\n}\r\nprot->pending = false;\r\ndone:\r\nmutex_unlock(&drvr->proto_block);\r\nreturn ret;\r\n}\r\nstatic bool pkt_sum_needed(struct sk_buff *skb)\r\n{\r\nreturn skb->ip_summed == CHECKSUM_PARTIAL;\r\n}\r\nstatic void pkt_set_sum_good(struct sk_buff *skb, bool x)\r\n{\r\nskb->ip_summed = (x ? CHECKSUM_UNNECESSARY : CHECKSUM_NONE);\r\n}\r\nvoid brcmf_proto_hdrpush(struct brcmf_pub *drvr, int ifidx,\r\nstruct sk_buff *pktbuf)\r\n{\r\nstruct brcmf_proto_bdc_header *h;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nskb_push(pktbuf, BDC_HEADER_LEN);\r\nh = (struct brcmf_proto_bdc_header *)(pktbuf->data);\r\nh->flags = (BDC_PROTO_VER << BDC_FLAG_VER_SHIFT);\r\nif (pkt_sum_needed(pktbuf))\r\nh->flags |= BDC_FLAG_SUM_NEEDED;\r\nh->priority = (pktbuf->priority & BDC_PRIORITY_MASK);\r\nh->flags2 = 0;\r\nh->data_offset = 0;\r\nBDC_SET_IF_IDX(h, ifidx);\r\n}\r\nint brcmf_proto_hdrpull(struct device *dev, int *ifidx,\r\nstruct sk_buff *pktbuf)\r\n{\r\nstruct brcmf_proto_bdc_header *h;\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (pktbuf->len < BDC_HEADER_LEN) {\r\nbrcmf_dbg(ERROR, "rx data too short (%d < %d)\n",\r\npktbuf->len, BDC_HEADER_LEN);\r\nreturn -EBADE;\r\n}\r\nh = (struct brcmf_proto_bdc_header *)(pktbuf->data);\r\n*ifidx = BDC_GET_IF_IDX(h);\r\nif (*ifidx >= BRCMF_MAX_IFS) {\r\nbrcmf_dbg(ERROR, "rx data ifnum out of range (%d)\n", *ifidx);\r\nreturn -EBADE;\r\n}\r\nif (((h->flags & BDC_FLAG_VER_MASK) >> BDC_FLAG_VER_SHIFT) !=\r\nBDC_PROTO_VER) {\r\nbrcmf_dbg(ERROR, "%s: non-BDC packet received, flags 0x%x\n",\r\nbrcmf_ifname(drvr, *ifidx), h->flags);\r\nreturn -EBADE;\r\n}\r\nif (h->flags & BDC_FLAG_SUM_GOOD) {\r\nbrcmf_dbg(INFO, "%s: BDC packet received with good rx-csum, flags 0x%x\n",\r\nbrcmf_ifname(drvr, *ifidx), h->flags);\r\npkt_set_sum_good(pktbuf, true);\r\n}\r\npktbuf->priority = h->priority & BDC_PRIORITY_MASK;\r\nskb_pull(pktbuf, BDC_HEADER_LEN);\r\nskb_pull(pktbuf, h->data_offset << 2);\r\nreturn 0;\r\n}\r\nint brcmf_proto_attach(struct brcmf_pub *drvr)\r\n{\r\nstruct brcmf_proto *cdc;\r\ncdc = kzalloc(sizeof(struct brcmf_proto), GFP_ATOMIC);\r\nif (!cdc)\r\ngoto fail;\r\nif ((unsigned long)(&cdc->msg + 1) != (unsigned long)cdc->buf) {\r\nbrcmf_dbg(ERROR, "struct brcmf_proto is not correctly defined\n");\r\ngoto fail;\r\n}\r\ndrvr->prot = cdc;\r\ndrvr->hdrlen += BDC_HEADER_LEN;\r\ndrvr->bus_if->maxctl = BRCMF_DCMD_MAXLEN +\r\nsizeof(struct brcmf_proto_cdc_dcmd) + ROUND_UP_MARGIN;\r\nreturn 0;\r\nfail:\r\nkfree(cdc);\r\nreturn -ENOMEM;\r\n}\r\nvoid brcmf_proto_detach(struct brcmf_pub *drvr)\r\n{\r\nkfree(drvr->prot);\r\ndrvr->prot = NULL;\r\n}\r\nint brcmf_proto_init(struct brcmf_pub *drvr)\r\n{\r\nint ret = 0;\r\nchar buf[128];\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nmutex_lock(&drvr->proto_block);\r\nstrcpy(buf, "cur_etheraddr");\r\nret = brcmf_proto_cdc_query_dcmd(drvr, 0, BRCMF_C_GET_VAR,\r\nbuf, sizeof(buf));\r\nif (ret < 0) {\r\nmutex_unlock(&drvr->proto_block);\r\nreturn ret;\r\n}\r\nmemcpy(drvr->mac, buf, ETH_ALEN);\r\nmutex_unlock(&drvr->proto_block);\r\nret = brcmf_c_preinit_dcmds(drvr);\r\ndrvr->iswl = true;\r\nreturn ret;\r\n}\r\nvoid brcmf_proto_stop(struct brcmf_pub *drvr)\r\n{\r\n}
