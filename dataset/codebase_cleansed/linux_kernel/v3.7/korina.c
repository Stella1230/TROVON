static inline void korina_start_dma(struct dma_reg *ch, u32 dma_addr)\r\n{\r\nwritel(0, &ch->dmandptr);\r\nwritel(dma_addr, &ch->dmadptr);\r\n}\r\nstatic inline void korina_abort_dma(struct net_device *dev,\r\nstruct dma_reg *ch)\r\n{\r\nif (readl(&ch->dmac) & DMA_CHAN_RUN_BIT) {\r\nwritel(0x10, &ch->dmac);\r\nwhile (!(readl(&ch->dmas) & DMA_STAT_HALT))\r\ndev->trans_start = jiffies;\r\nwritel(0, &ch->dmas);\r\n}\r\nwritel(0, &ch->dmadptr);\r\nwritel(0, &ch->dmandptr);\r\n}\r\nstatic inline void korina_chain_dma(struct dma_reg *ch, u32 dma_addr)\r\n{\r\nwritel(dma_addr, &ch->dmandptr);\r\n}\r\nstatic void korina_abort_tx(struct net_device *dev)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nkorina_abort_dma(dev, lp->tx_dma_regs);\r\n}\r\nstatic void korina_abort_rx(struct net_device *dev)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nkorina_abort_dma(dev, lp->rx_dma_regs);\r\n}\r\nstatic void korina_start_rx(struct korina_private *lp,\r\nstruct dma_desc *rd)\r\n{\r\nkorina_start_dma(lp->rx_dma_regs, CPHYSADDR(rd));\r\n}\r\nstatic void korina_chain_rx(struct korina_private *lp,\r\nstruct dma_desc *rd)\r\n{\r\nkorina_chain_dma(lp->rx_dma_regs, CPHYSADDR(rd));\r\n}\r\nstatic int korina_send_packet(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nu32 length;\r\nu32 chain_prev, chain_next;\r\nstruct dma_desc *td;\r\nspin_lock_irqsave(&lp->lock, flags);\r\ntd = &lp->td_ring[lp->tx_chain_tail];\r\nif (lp->tx_count >= (KORINA_NUM_TDS - 2)) {\r\nlp->tx_full = 1;\r\nif (lp->tx_count == (KORINA_NUM_TDS - 2))\r\nnetif_stop_queue(dev);\r\nelse {\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb_any(skb);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\n}\r\nlp->tx_count++;\r\nlp->tx_skb[lp->tx_chain_tail] = skb;\r\nlength = skb->len;\r\ndma_cache_wback((u32)skb->data, skb->len);\r\ndma_cache_inv((u32) td, sizeof(*td));\r\ntd->ca = CPHYSADDR(skb->data);\r\nchain_prev = (lp->tx_chain_tail - 1) & KORINA_TDS_MASK;\r\nchain_next = (lp->tx_chain_tail + 1) & KORINA_TDS_MASK;\r\nif (readl(&(lp->tx_dma_regs->dmandptr)) == 0) {\r\nif (lp->tx_chain_status == desc_empty) {\r\ntd->control = DMA_COUNT(length) |\r\nDMA_DESC_COF | DMA_DESC_IOF;\r\nlp->tx_chain_tail = chain_next;\r\nwritel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]),\r\n&lp->tx_dma_regs->dmandptr);\r\nlp->tx_chain_head = lp->tx_chain_tail;\r\n} else {\r\ntd->control = DMA_COUNT(length) |\r\nDMA_DESC_COF | DMA_DESC_IOF;\r\nlp->td_ring[chain_prev].control &=\r\n~DMA_DESC_COF;\r\nlp->td_ring[chain_prev].link = CPHYSADDR(td);\r\nlp->tx_chain_tail = chain_next;\r\nwritel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]),\r\n&(lp->tx_dma_regs->dmandptr));\r\nlp->tx_chain_head = lp->tx_chain_tail;\r\nlp->tx_chain_status = desc_empty;\r\n}\r\n} else {\r\nif (lp->tx_chain_status == desc_empty) {\r\ntd->control = DMA_COUNT(length) |\r\nDMA_DESC_COF | DMA_DESC_IOF;\r\nlp->tx_chain_tail = chain_next;\r\nlp->tx_chain_status = desc_filled;\r\n} else {\r\ntd->control = DMA_COUNT(length) |\r\nDMA_DESC_COF | DMA_DESC_IOF;\r\nlp->td_ring[chain_prev].control &=\r\n~DMA_DESC_COF;\r\nlp->td_ring[chain_prev].link = CPHYSADDR(td);\r\nlp->tx_chain_tail = chain_next;\r\n}\r\n}\r\ndma_cache_wback((u32) td, sizeof(*td));\r\ndev->trans_start = jiffies;\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int mdio_read(struct net_device *dev, int mii_id, int reg)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nint ret;\r\nmii_id = ((lp->rx_irq == 0x2c ? 1 : 0) << 8);\r\nwritel(0, &lp->eth_regs->miimcfg);\r\nwritel(0, &lp->eth_regs->miimcmd);\r\nwritel(mii_id | reg, &lp->eth_regs->miimaddr);\r\nwritel(ETH_MII_CMD_SCN, &lp->eth_regs->miimcmd);\r\nret = (int)(readl(&lp->eth_regs->miimrdd));\r\nreturn ret;\r\n}\r\nstatic void mdio_write(struct net_device *dev, int mii_id, int reg, int val)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nmii_id = ((lp->rx_irq == 0x2c ? 1 : 0) << 8);\r\nwritel(0, &lp->eth_regs->miimcfg);\r\nwritel(1, &lp->eth_regs->miimcmd);\r\nwritel(mii_id | reg, &lp->eth_regs->miimaddr);\r\nwritel(ETH_MII_CMD_SCN, &lp->eth_regs->miimcmd);\r\nwritel(val, &lp->eth_regs->miimwtd);\r\n}\r\nstatic irqreturn_t korina_rx_dma_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct korina_private *lp = netdev_priv(dev);\r\nu32 dmas, dmasm;\r\nirqreturn_t retval;\r\ndmas = readl(&lp->rx_dma_regs->dmas);\r\nif (dmas & (DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR)) {\r\ndmasm = readl(&lp->rx_dma_regs->dmasm);\r\nwritel(dmasm | (DMA_STAT_DONE |\r\nDMA_STAT_HALT | DMA_STAT_ERR),\r\n&lp->rx_dma_regs->dmasm);\r\nnapi_schedule(&lp->napi);\r\nif (dmas & DMA_STAT_ERR)\r\nprintk(KERN_ERR "%s: DMA error\n", dev->name);\r\nretval = IRQ_HANDLED;\r\n} else\r\nretval = IRQ_NONE;\r\nreturn retval;\r\n}\r\nstatic int korina_rx(struct net_device *dev, int limit)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nstruct dma_desc *rd = &lp->rd_ring[lp->rx_next_done];\r\nstruct sk_buff *skb, *skb_new;\r\nu8 *pkt_buf;\r\nu32 devcs, pkt_len, dmas;\r\nint count;\r\ndma_cache_inv((u32)rd, sizeof(*rd));\r\nfor (count = 0; count < limit; count++) {\r\nskb = lp->rx_skb[lp->rx_next_done];\r\nskb_new = NULL;\r\ndevcs = rd->devcs;\r\nif ((KORINA_RBSIZE - (u32)DMA_COUNT(rd->control)) == 0)\r\nbreak;\r\nif (devcs & ETH_RX_CRC)\r\ndev->stats.rx_crc_errors++;\r\nif (devcs & ETH_RX_LOR)\r\ndev->stats.rx_length_errors++;\r\nif (devcs & ETH_RX_LE)\r\ndev->stats.rx_length_errors++;\r\nif (devcs & ETH_RX_OVR)\r\ndev->stats.rx_fifo_errors++;\r\nif (devcs & ETH_RX_CV)\r\ndev->stats.rx_frame_errors++;\r\nif (devcs & ETH_RX_CES)\r\ndev->stats.rx_length_errors++;\r\nif (devcs & ETH_RX_MP)\r\ndev->stats.multicast++;\r\nif ((devcs & ETH_RX_LD) != ETH_RX_LD) {\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_dropped++;\r\n} else if ((devcs & ETH_RX_ROK)) {\r\npkt_len = RCVPKT_LENGTH(devcs);\r\npkt_buf = (u8 *)lp->rx_skb[lp->rx_next_done]->data;\r\ndma_cache_inv((unsigned long)pkt_buf, pkt_len - 4);\r\nskb_new = netdev_alloc_skb_ip_align(dev, KORINA_RBSIZE);\r\nif (!skb_new)\r\nbreak;\r\nskb_put(skb, pkt_len - 4);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_receive_skb(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\nif (devcs & ETH_RX_MP)\r\ndev->stats.multicast++;\r\nlp->rx_skb[lp->rx_next_done] = skb_new;\r\n}\r\nrd->devcs = 0;\r\nif (skb_new)\r\nrd->ca = CPHYSADDR(skb_new->data);\r\nelse\r\nrd->ca = CPHYSADDR(skb->data);\r\nrd->control = DMA_COUNT(KORINA_RBSIZE) |\r\nDMA_DESC_COD | DMA_DESC_IOD;\r\nlp->rd_ring[(lp->rx_next_done - 1) &\r\nKORINA_RDS_MASK].control &=\r\n~DMA_DESC_COD;\r\nlp->rx_next_done = (lp->rx_next_done + 1) & KORINA_RDS_MASK;\r\ndma_cache_wback((u32)rd, sizeof(*rd));\r\nrd = &lp->rd_ring[lp->rx_next_done];\r\nwritel(~DMA_STAT_DONE, &lp->rx_dma_regs->dmas);\r\n}\r\ndmas = readl(&lp->rx_dma_regs->dmas);\r\nif (dmas & DMA_STAT_HALT) {\r\nwritel(~(DMA_STAT_HALT | DMA_STAT_ERR),\r\n&lp->rx_dma_regs->dmas);\r\nlp->dma_halt_cnt++;\r\nrd->devcs = 0;\r\nskb = lp->rx_skb[lp->rx_next_done];\r\nrd->ca = CPHYSADDR(skb->data);\r\ndma_cache_wback((u32)rd, sizeof(*rd));\r\nkorina_chain_rx(lp, rd);\r\n}\r\nreturn count;\r\n}\r\nstatic int korina_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct korina_private *lp =\r\ncontainer_of(napi, struct korina_private, napi);\r\nstruct net_device *dev = lp->dev;\r\nint work_done;\r\nwork_done = korina_rx(dev, budget);\r\nif (work_done < budget) {\r\nnapi_complete(napi);\r\nwritel(readl(&lp->rx_dma_regs->dmasm) &\r\n~(DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR),\r\n&lp->rx_dma_regs->dmasm);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void korina_multicast_list(struct net_device *dev)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nstruct netdev_hw_addr *ha;\r\nu32 recognise = ETH_ARC_AB;\r\nint i;\r\nif (dev->flags & IFF_PROMISC)\r\nrecognise |= ETH_ARC_PRO;\r\nelse if ((dev->flags & IFF_ALLMULTI) || (netdev_mc_count(dev) > 4))\r\nrecognise |= ETH_ARC_AM;\r\nif (netdev_mc_count(dev) > 4) {\r\nu16 hash_table[4];\r\nu32 crc;\r\nfor (i = 0; i < 4; i++)\r\nhash_table[i] = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc_le(6, ha->addr);\r\ncrc >>= 26;\r\nhash_table[crc >> 4] |= 1 << (15 - (crc & 0xf));\r\n}\r\nrecognise |= ETH_ARC_AFM;\r\nwritel((u32)(hash_table[1] << 16 | hash_table[0]),\r\n&lp->eth_regs->ethhash0);\r\nwritel((u32)(hash_table[3] << 16 | hash_table[2]),\r\n&lp->eth_regs->ethhash1);\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\nwritel(recognise, &lp->eth_regs->etharc);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic void korina_tx(struct net_device *dev)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nstruct dma_desc *td = &lp->td_ring[lp->tx_next_done];\r\nu32 devcs;\r\nu32 dmas;\r\nspin_lock(&lp->lock);\r\nwhile (IS_DMA_FINISHED(td->control)) {\r\nif (lp->tx_full == 1) {\r\nnetif_wake_queue(dev);\r\nlp->tx_full = 0;\r\n}\r\ndevcs = lp->td_ring[lp->tx_next_done].devcs;\r\nif ((devcs & (ETH_TX_FD | ETH_TX_LD)) !=\r\n(ETH_TX_FD | ETH_TX_LD)) {\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_dropped++;\r\nprintk(KERN_ERR "%s: split tx ignored\n",\r\ndev->name);\r\n} else if (devcs & ETH_TX_TOK) {\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes +=\r\nlp->tx_skb[lp->tx_next_done]->len;\r\n} else {\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_dropped++;\r\nif (devcs & ETH_TX_UND)\r\ndev->stats.tx_fifo_errors++;\r\nif (devcs & ETH_TX_OF)\r\ndev->stats.tx_aborted_errors++;\r\nif (devcs & ETH_TX_ED)\r\ndev->stats.tx_carrier_errors++;\r\nif (devcs & ETH_TX_EC)\r\ndev->stats.collisions++;\r\nif (devcs & ETH_TX_LC)\r\ndev->stats.tx_window_errors++;\r\n}\r\nif (lp->tx_skb[lp->tx_next_done]) {\r\ndev_kfree_skb_any(lp->tx_skb[lp->tx_next_done]);\r\nlp->tx_skb[lp->tx_next_done] = NULL;\r\n}\r\nlp->td_ring[lp->tx_next_done].control = DMA_DESC_IOF;\r\nlp->td_ring[lp->tx_next_done].devcs = ETH_TX_FD | ETH_TX_LD;\r\nlp->td_ring[lp->tx_next_done].link = 0;\r\nlp->td_ring[lp->tx_next_done].ca = 0;\r\nlp->tx_count--;\r\nlp->tx_next_done = (lp->tx_next_done + 1) & KORINA_TDS_MASK;\r\ntd = &lp->td_ring[lp->tx_next_done];\r\n}\r\ndmas = readl(&lp->tx_dma_regs->dmas);\r\nwritel(~dmas, &lp->tx_dma_regs->dmas);\r\nwritel(readl(&lp->tx_dma_regs->dmasm) &\r\n~(DMA_STAT_FINI | DMA_STAT_ERR),\r\n&lp->tx_dma_regs->dmasm);\r\nspin_unlock(&lp->lock);\r\n}\r\nstatic irqreturn_t\r\nkorina_tx_dma_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct korina_private *lp = netdev_priv(dev);\r\nu32 dmas, dmasm;\r\nirqreturn_t retval;\r\ndmas = readl(&lp->tx_dma_regs->dmas);\r\nif (dmas & (DMA_STAT_FINI | DMA_STAT_ERR)) {\r\ndmasm = readl(&lp->tx_dma_regs->dmasm);\r\nwritel(dmasm | (DMA_STAT_FINI | DMA_STAT_ERR),\r\n&lp->tx_dma_regs->dmasm);\r\nkorina_tx(dev);\r\nif (lp->tx_chain_status == desc_filled &&\r\n(readl(&(lp->tx_dma_regs->dmandptr)) == 0)) {\r\nwritel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]),\r\n&(lp->tx_dma_regs->dmandptr));\r\nlp->tx_chain_status = desc_empty;\r\nlp->tx_chain_head = lp->tx_chain_tail;\r\ndev->trans_start = jiffies;\r\n}\r\nif (dmas & DMA_STAT_ERR)\r\nprintk(KERN_ERR "%s: DMA error\n", dev->name);\r\nretval = IRQ_HANDLED;\r\n} else\r\nretval = IRQ_NONE;\r\nreturn retval;\r\n}\r\nstatic void korina_check_media(struct net_device *dev, unsigned int init_media)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nmii_check_media(&lp->mii_if, 0, init_media);\r\nif (lp->mii_if.full_duplex)\r\nwritel(readl(&lp->eth_regs->ethmac2) | ETH_MAC2_FD,\r\n&lp->eth_regs->ethmac2);\r\nelse\r\nwritel(readl(&lp->eth_regs->ethmac2) & ~ETH_MAC2_FD,\r\n&lp->eth_regs->ethmac2);\r\n}\r\nstatic void korina_poll_media(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *) data;\r\nstruct korina_private *lp = netdev_priv(dev);\r\nkorina_check_media(dev, 0);\r\nmod_timer(&lp->media_check_timer, jiffies + HZ);\r\n}\r\nstatic void korina_set_carrier(struct mii_if_info *mii)\r\n{\r\nif (mii->force_media) {\r\nif (!netif_carrier_ok(mii->dev))\r\nnetif_carrier_on(mii->dev);\r\n} else\r\nkorina_check_media(mii->dev, 0);\r\n}\r\nstatic int korina_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nstruct mii_ioctl_data *data = if_mii(rq);\r\nint rc;\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nspin_lock_irq(&lp->lock);\r\nrc = generic_mii_ioctl(&lp->mii_if, data, cmd, NULL);\r\nspin_unlock_irq(&lp->lock);\r\nkorina_set_carrier(&lp->mii_if);\r\nreturn rc;\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nstrcpy(info->bus_info, lp->dev->name);\r\n}\r\nstatic int netdev_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nint rc;\r\nspin_lock_irq(&lp->lock);\r\nrc = mii_ethtool_gset(&lp->mii_if, cmd);\r\nspin_unlock_irq(&lp->lock);\r\nreturn rc;\r\n}\r\nstatic int netdev_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nint rc;\r\nspin_lock_irq(&lp->lock);\r\nrc = mii_ethtool_sset(&lp->mii_if, cmd);\r\nspin_unlock_irq(&lp->lock);\r\nkorina_set_carrier(&lp->mii_if);\r\nreturn rc;\r\n}\r\nstatic u32 netdev_get_link(struct net_device *dev)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nreturn mii_link_ok(&lp->mii_if);\r\n}\r\nstatic int korina_alloc_ring(struct net_device *dev)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nint i;\r\nfor (i = 0; i < KORINA_NUM_TDS; i++) {\r\nlp->td_ring[i].control = DMA_DESC_IOF;\r\nlp->td_ring[i].devcs = ETH_TX_FD | ETH_TX_LD;\r\nlp->td_ring[i].ca = 0;\r\nlp->td_ring[i].link = 0;\r\n}\r\nlp->tx_next_done = lp->tx_chain_head = lp->tx_chain_tail =\r\nlp->tx_full = lp->tx_count = 0;\r\nlp->tx_chain_status = desc_empty;\r\nfor (i = 0; i < KORINA_NUM_RDS; i++) {\r\nskb = netdev_alloc_skb_ip_align(dev, KORINA_RBSIZE);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nlp->rx_skb[i] = skb;\r\nlp->rd_ring[i].control = DMA_DESC_IOD |\r\nDMA_COUNT(KORINA_RBSIZE);\r\nlp->rd_ring[i].devcs = 0;\r\nlp->rd_ring[i].ca = CPHYSADDR(skb->data);\r\nlp->rd_ring[i].link = CPHYSADDR(&lp->rd_ring[i+1]);\r\n}\r\nlp->rd_ring[i - 1].link = CPHYSADDR(&lp->rd_ring[0]);\r\nlp->rd_ring[i - 1].control |= DMA_DESC_COD;\r\nlp->rx_next_done = 0;\r\nlp->rx_chain_head = 0;\r\nlp->rx_chain_tail = 0;\r\nlp->rx_chain_status = desc_empty;\r\nreturn 0;\r\n}\r\nstatic void korina_free_ring(struct net_device *dev)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < KORINA_NUM_RDS; i++) {\r\nlp->rd_ring[i].control = 0;\r\nif (lp->rx_skb[i])\r\ndev_kfree_skb_any(lp->rx_skb[i]);\r\nlp->rx_skb[i] = NULL;\r\n}\r\nfor (i = 0; i < KORINA_NUM_TDS; i++) {\r\nlp->td_ring[i].control = 0;\r\nif (lp->tx_skb[i])\r\ndev_kfree_skb_any(lp->tx_skb[i]);\r\nlp->tx_skb[i] = NULL;\r\n}\r\n}\r\nstatic int korina_init(struct net_device *dev)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nkorina_abort_tx(dev);\r\nkorina_abort_rx(dev);\r\nwritel(0, &lp->eth_regs->ethintfc);\r\nwhile ((readl(&lp->eth_regs->ethintfc) & ETH_INT_FC_RIP))\r\ndev->trans_start = jiffies;\r\nwritel(ETH_INT_FC_EN, &lp->eth_regs->ethintfc);\r\nif (korina_alloc_ring(dev)) {\r\nprintk(KERN_ERR "%s: descriptor allocation failed\n", dev->name);\r\nkorina_free_ring(dev);\r\nreturn -ENOMEM;\r\n}\r\nwritel(0, &lp->rx_dma_regs->dmas);\r\nkorina_start_rx(lp, &lp->rd_ring[0]);\r\nwritel(readl(&lp->tx_dma_regs->dmasm) &\r\n~(DMA_STAT_FINI | DMA_STAT_ERR),\r\n&lp->tx_dma_regs->dmasm);\r\nwritel(readl(&lp->rx_dma_regs->dmasm) &\r\n~(DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR),\r\n&lp->rx_dma_regs->dmasm);\r\nwritel(ETH_ARC_AB, &lp->eth_regs->etharc);\r\nwritel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal0);\r\nwritel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah0);\r\nwritel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal1);\r\nwritel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah1);\r\nwritel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal2);\r\nwritel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah2);\r\nwritel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal3);\r\nwritel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah3);\r\nwritel(ETH_MAC2_PE | ETH_MAC2_CEN | ETH_MAC2_FD,\r\n&lp->eth_regs->ethmac2);\r\nwritel(0x15, &lp->eth_regs->ethipgt);\r\nwritel(0x12, &lp->eth_regs->ethipgr);\r\nwritel(((idt_cpu_freq) / MII_CLOCK + 1) & ~1,\r\n&lp->eth_regs->ethmcp);\r\nwritel(48, &lp->eth_regs->ethfifott);\r\nwritel(ETH_MAC1_RE, &lp->eth_regs->ethmac1);\r\nnapi_enable(&lp->napi);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void korina_restart_task(struct work_struct *work)\r\n{\r\nstruct korina_private *lp = container_of(work,\r\nstruct korina_private, restart_task);\r\nstruct net_device *dev = lp->dev;\r\ndisable_irq(lp->rx_irq);\r\ndisable_irq(lp->tx_irq);\r\ndisable_irq(lp->ovr_irq);\r\ndisable_irq(lp->und_irq);\r\nwritel(readl(&lp->tx_dma_regs->dmasm) |\r\nDMA_STAT_FINI | DMA_STAT_ERR,\r\n&lp->tx_dma_regs->dmasm);\r\nwritel(readl(&lp->rx_dma_regs->dmasm) |\r\nDMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR,\r\n&lp->rx_dma_regs->dmasm);\r\nkorina_free_ring(dev);\r\nnapi_disable(&lp->napi);\r\nif (korina_init(dev) < 0) {\r\nprintk(KERN_ERR "%s: cannot restart device\n", dev->name);\r\nreturn;\r\n}\r\nkorina_multicast_list(dev);\r\nenable_irq(lp->und_irq);\r\nenable_irq(lp->ovr_irq);\r\nenable_irq(lp->tx_irq);\r\nenable_irq(lp->rx_irq);\r\n}\r\nstatic void korina_clear_and_restart(struct net_device *dev, u32 value)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nwritel(value, &lp->eth_regs->ethintfc);\r\nschedule_work(&lp->restart_task);\r\n}\r\nstatic irqreturn_t korina_und_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct korina_private *lp = netdev_priv(dev);\r\nunsigned int und;\r\nspin_lock(&lp->lock);\r\nund = readl(&lp->eth_regs->ethintfc);\r\nif (und & ETH_INT_FC_UND)\r\nkorina_clear_and_restart(dev, und & ~ETH_INT_FC_UND);\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void korina_tx_timeout(struct net_device *dev)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nschedule_work(&lp->restart_task);\r\n}\r\nstatic irqreturn_t\r\nkorina_ovr_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct korina_private *lp = netdev_priv(dev);\r\nunsigned int ovr;\r\nspin_lock(&lp->lock);\r\novr = readl(&lp->eth_regs->ethintfc);\r\nif (ovr & ETH_INT_FC_OVR)\r\nkorina_clear_and_restart(dev, ovr & ~ETH_INT_FC_OVR);\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void korina_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\nkorina_tx_dma_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic int korina_open(struct net_device *dev)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nint ret;\r\nret = korina_init(dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: cannot open device\n", dev->name);\r\ngoto out;\r\n}\r\nret = request_irq(lp->rx_irq, korina_rx_dma_interrupt,\r\nIRQF_DISABLED, "Korina ethernet Rx", dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: unable to get Rx DMA IRQ %d\n",\r\ndev->name, lp->rx_irq);\r\ngoto err_release;\r\n}\r\nret = request_irq(lp->tx_irq, korina_tx_dma_interrupt,\r\nIRQF_DISABLED, "Korina ethernet Tx", dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: unable to get Tx DMA IRQ %d\n",\r\ndev->name, lp->tx_irq);\r\ngoto err_free_rx_irq;\r\n}\r\nret = request_irq(lp->ovr_irq, korina_ovr_interrupt,\r\nIRQF_DISABLED, "Ethernet Overflow", dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: unable to get OVR IRQ %d\n",\r\ndev->name, lp->ovr_irq);\r\ngoto err_free_tx_irq;\r\n}\r\nret = request_irq(lp->und_irq, korina_und_interrupt,\r\nIRQF_DISABLED, "Ethernet Underflow", dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: unable to get UND IRQ %d\n",\r\ndev->name, lp->und_irq);\r\ngoto err_free_ovr_irq;\r\n}\r\nmod_timer(&lp->media_check_timer, jiffies + 1);\r\nout:\r\nreturn ret;\r\nerr_free_ovr_irq:\r\nfree_irq(lp->ovr_irq, dev);\r\nerr_free_tx_irq:\r\nfree_irq(lp->tx_irq, dev);\r\nerr_free_rx_irq:\r\nfree_irq(lp->rx_irq, dev);\r\nerr_release:\r\nkorina_free_ring(dev);\r\ngoto out;\r\n}\r\nstatic int korina_close(struct net_device *dev)\r\n{\r\nstruct korina_private *lp = netdev_priv(dev);\r\nu32 tmp;\r\ndel_timer(&lp->media_check_timer);\r\ndisable_irq(lp->rx_irq);\r\ndisable_irq(lp->tx_irq);\r\ndisable_irq(lp->ovr_irq);\r\ndisable_irq(lp->und_irq);\r\nkorina_abort_tx(dev);\r\ntmp = readl(&lp->tx_dma_regs->dmasm);\r\ntmp = tmp | DMA_STAT_FINI | DMA_STAT_ERR;\r\nwritel(tmp, &lp->tx_dma_regs->dmasm);\r\nkorina_abort_rx(dev);\r\ntmp = readl(&lp->rx_dma_regs->dmasm);\r\ntmp = tmp | DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR;\r\nwritel(tmp, &lp->rx_dma_regs->dmasm);\r\nkorina_free_ring(dev);\r\nnapi_disable(&lp->napi);\r\ncancel_work_sync(&lp->restart_task);\r\nfree_irq(lp->rx_irq, dev);\r\nfree_irq(lp->tx_irq, dev);\r\nfree_irq(lp->ovr_irq, dev);\r\nfree_irq(lp->und_irq, dev);\r\nreturn 0;\r\n}\r\nstatic int korina_probe(struct platform_device *pdev)\r\n{\r\nstruct korina_device *bif = platform_get_drvdata(pdev);\r\nstruct korina_private *lp;\r\nstruct net_device *dev;\r\nstruct resource *r;\r\nint rc;\r\ndev = alloc_etherdev(sizeof(struct korina_private));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nlp = netdev_priv(dev);\r\nbif->dev = dev;\r\nmemcpy(dev->dev_addr, bif->mac, 6);\r\nlp->rx_irq = platform_get_irq_byname(pdev, "korina_rx");\r\nlp->tx_irq = platform_get_irq_byname(pdev, "korina_tx");\r\nlp->ovr_irq = platform_get_irq_byname(pdev, "korina_ovr");\r\nlp->und_irq = platform_get_irq_byname(pdev, "korina_und");\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "korina_regs");\r\ndev->base_addr = r->start;\r\nlp->eth_regs = ioremap_nocache(r->start, resource_size(r));\r\nif (!lp->eth_regs) {\r\nprintk(KERN_ERR DRV_NAME ": cannot remap registers\n");\r\nrc = -ENXIO;\r\ngoto probe_err_out;\r\n}\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "korina_dma_rx");\r\nlp->rx_dma_regs = ioremap_nocache(r->start, resource_size(r));\r\nif (!lp->rx_dma_regs) {\r\nprintk(KERN_ERR DRV_NAME ": cannot remap Rx DMA registers\n");\r\nrc = -ENXIO;\r\ngoto probe_err_dma_rx;\r\n}\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "korina_dma_tx");\r\nlp->tx_dma_regs = ioremap_nocache(r->start, resource_size(r));\r\nif (!lp->tx_dma_regs) {\r\nprintk(KERN_ERR DRV_NAME ": cannot remap Tx DMA registers\n");\r\nrc = -ENXIO;\r\ngoto probe_err_dma_tx;\r\n}\r\nlp->td_ring = kmalloc(TD_RING_SIZE + RD_RING_SIZE, GFP_KERNEL);\r\nif (!lp->td_ring) {\r\nrc = -ENXIO;\r\ngoto probe_err_td_ring;\r\n}\r\ndma_cache_inv((unsigned long)(lp->td_ring),\r\nTD_RING_SIZE + RD_RING_SIZE);\r\nlp->td_ring = (struct dma_desc *)KSEG1ADDR(lp->td_ring);\r\nlp->rd_ring = &lp->td_ring[KORINA_NUM_TDS];\r\nspin_lock_init(&lp->lock);\r\ndev->irq = lp->rx_irq;\r\nlp->dev = dev;\r\ndev->netdev_ops = &korina_netdev_ops;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nnetif_napi_add(dev, &lp->napi, korina_poll, 64);\r\nlp->phy_addr = (((lp->rx_irq == 0x2c? 1:0) << 8) | 0x05);\r\nlp->mii_if.dev = dev;\r\nlp->mii_if.mdio_read = mdio_read;\r\nlp->mii_if.mdio_write = mdio_write;\r\nlp->mii_if.phy_id = lp->phy_addr;\r\nlp->mii_if.phy_id_mask = 0x1f;\r\nlp->mii_if.reg_num_mask = 0x1f;\r\nrc = register_netdev(dev);\r\nif (rc < 0) {\r\nprintk(KERN_ERR DRV_NAME\r\n": cannot register net device: %d\n", rc);\r\ngoto probe_err_register;\r\n}\r\nsetup_timer(&lp->media_check_timer, korina_poll_media, (unsigned long) dev);\r\nINIT_WORK(&lp->restart_task, korina_restart_task);\r\nprintk(KERN_INFO "%s: " DRV_NAME "-" DRV_VERSION " " DRV_RELDATE "\n",\r\ndev->name);\r\nout:\r\nreturn rc;\r\nprobe_err_register:\r\nkfree(lp->td_ring);\r\nprobe_err_td_ring:\r\niounmap(lp->tx_dma_regs);\r\nprobe_err_dma_tx:\r\niounmap(lp->rx_dma_regs);\r\nprobe_err_dma_rx:\r\niounmap(lp->eth_regs);\r\nprobe_err_out:\r\nfree_netdev(dev);\r\ngoto out;\r\n}\r\nstatic int korina_remove(struct platform_device *pdev)\r\n{\r\nstruct korina_device *bif = platform_get_drvdata(pdev);\r\nstruct korina_private *lp = netdev_priv(bif->dev);\r\niounmap(lp->eth_regs);\r\niounmap(lp->rx_dma_regs);\r\niounmap(lp->tx_dma_regs);\r\nplatform_set_drvdata(pdev, NULL);\r\nunregister_netdev(bif->dev);\r\nfree_netdev(bif->dev);\r\nreturn 0;\r\n}
