STATIC int\r\nxfs_qm_dquot_walk(\r\nstruct xfs_mount *mp,\r\nint type,\r\nint (*execute)(struct xfs_dquot *dqp, void *data),\r\nvoid *data)\r\n{\r\nstruct xfs_quotainfo *qi = mp->m_quotainfo;\r\nstruct radix_tree_root *tree = XFS_DQUOT_TREE(qi, type);\r\nuint32_t next_index;\r\nint last_error = 0;\r\nint skipped;\r\nint nr_found;\r\nrestart:\r\nskipped = 0;\r\nnext_index = 0;\r\nnr_found = 0;\r\nwhile (1) {\r\nstruct xfs_dquot *batch[XFS_DQ_LOOKUP_BATCH];\r\nint error = 0;\r\nint i;\r\nmutex_lock(&qi->qi_tree_lock);\r\nnr_found = radix_tree_gang_lookup(tree, (void **)batch,\r\nnext_index, XFS_DQ_LOOKUP_BATCH);\r\nif (!nr_found) {\r\nmutex_unlock(&qi->qi_tree_lock);\r\nbreak;\r\n}\r\nfor (i = 0; i < nr_found; i++) {\r\nstruct xfs_dquot *dqp = batch[i];\r\nnext_index = be32_to_cpu(dqp->q_core.d_id) + 1;\r\nerror = execute(batch[i], data);\r\nif (error == EAGAIN) {\r\nskipped++;\r\ncontinue;\r\n}\r\nif (error && last_error != EFSCORRUPTED)\r\nlast_error = error;\r\n}\r\nmutex_unlock(&qi->qi_tree_lock);\r\nif (last_error == EFSCORRUPTED) {\r\nskipped = 0;\r\nbreak;\r\n}\r\n}\r\nif (skipped) {\r\ndelay(1);\r\ngoto restart;\r\n}\r\nreturn last_error;\r\n}\r\nSTATIC int\r\nxfs_qm_dqpurge(\r\nstruct xfs_dquot *dqp,\r\nvoid *data)\r\n{\r\nstruct xfs_mount *mp = dqp->q_mount;\r\nstruct xfs_quotainfo *qi = mp->m_quotainfo;\r\nstruct xfs_dquot *gdqp = NULL;\r\nxfs_dqlock(dqp);\r\nif ((dqp->dq_flags & XFS_DQ_FREEING) || dqp->q_nrefs != 0) {\r\nxfs_dqunlock(dqp);\r\nreturn EAGAIN;\r\n}\r\ngdqp = dqp->q_gdquot;\r\nif (gdqp) {\r\nxfs_dqlock(gdqp);\r\ndqp->q_gdquot = NULL;\r\n}\r\ndqp->dq_flags |= XFS_DQ_FREEING;\r\nxfs_dqflock(dqp);\r\nif (XFS_DQ_IS_DIRTY(dqp)) {\r\nstruct xfs_buf *bp = NULL;\r\nint error;\r\nerror = xfs_qm_dqflush(dqp, &bp);\r\nif (error) {\r\nxfs_warn(mp, "%s: dquot %p flush failed",\r\n__func__, dqp);\r\n} else {\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\n}\r\nxfs_dqflock(dqp);\r\n}\r\nASSERT(atomic_read(&dqp->q_pincount) == 0);\r\nASSERT(XFS_FORCED_SHUTDOWN(mp) ||\r\n!(dqp->q_logitem.qli_item.li_flags & XFS_LI_IN_AIL));\r\nxfs_dqfunlock(dqp);\r\nxfs_dqunlock(dqp);\r\nradix_tree_delete(XFS_DQUOT_TREE(qi, dqp->q_core.d_flags),\r\nbe32_to_cpu(dqp->q_core.d_id));\r\nqi->qi_dquots--;\r\nmutex_lock(&qi->qi_lru_lock);\r\nASSERT(!list_empty(&dqp->q_lru));\r\nlist_del_init(&dqp->q_lru);\r\nqi->qi_lru_count--;\r\nXFS_STATS_DEC(xs_qm_dquot_unused);\r\nmutex_unlock(&qi->qi_lru_lock);\r\nxfs_qm_dqdestroy(dqp);\r\nif (gdqp)\r\nxfs_qm_dqput(gdqp);\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_qm_dqpurge_all(\r\nstruct xfs_mount *mp,\r\nuint flags)\r\n{\r\nif (flags & XFS_QMOPT_UQUOTA)\r\nxfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_dqpurge, NULL);\r\nif (flags & XFS_QMOPT_GQUOTA)\r\nxfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_dqpurge, NULL);\r\nif (flags & XFS_QMOPT_PQUOTA)\r\nxfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_dqpurge, NULL);\r\n}\r\nvoid\r\nxfs_qm_unmount(\r\nstruct xfs_mount *mp)\r\n{\r\nif (mp->m_quotainfo) {\r\nxfs_qm_dqpurge_all(mp, XFS_QMOPT_QUOTALL);\r\nxfs_qm_destroy_quotainfo(mp);\r\n}\r\n}\r\nvoid\r\nxfs_qm_mount_quotas(\r\nxfs_mount_t *mp)\r\n{\r\nint error = 0;\r\nuint sbf;\r\nif (mp->m_sb.sb_rextents) {\r\nxfs_notice(mp, "Cannot turn on quotas for realtime filesystem");\r\nmp->m_qflags = 0;\r\ngoto write_changes;\r\n}\r\nASSERT(XFS_IS_QUOTA_RUNNING(mp));\r\nerror = xfs_qm_init_quotainfo(mp);\r\nif (error) {\r\nASSERT(mp->m_quotainfo == NULL);\r\nmp->m_qflags = 0;\r\ngoto write_changes;\r\n}\r\nif (XFS_QM_NEED_QUOTACHECK(mp)) {\r\nerror = xfs_qm_quotacheck(mp);\r\nif (error) {\r\nreturn;\r\n}\r\n}\r\nif (!XFS_IS_UQUOTA_ON(mp))\r\nmp->m_qflags &= ~XFS_UQUOTA_CHKD;\r\nif (!(XFS_IS_GQUOTA_ON(mp) || XFS_IS_PQUOTA_ON(mp)))\r\nmp->m_qflags &= ~XFS_OQUOTA_CHKD;\r\nwrite_changes:\r\nspin_lock(&mp->m_sb_lock);\r\nsbf = mp->m_sb.sb_qflags;\r\nmp->m_sb.sb_qflags = mp->m_qflags & XFS_MOUNT_QUOTA_ALL;\r\nspin_unlock(&mp->m_sb_lock);\r\nif (sbf != (mp->m_qflags & XFS_MOUNT_QUOTA_ALL)) {\r\nif (xfs_qm_write_sb_changes(mp, XFS_SB_QFLAGS)) {\r\nASSERT(!(XFS_IS_QUOTA_RUNNING(mp)));\r\nxfs_alert(mp, "%s: Superblock update failed!",\r\n__func__);\r\n}\r\n}\r\nif (error) {\r\nxfs_warn(mp, "Failed to initialize disk quotas.");\r\nreturn;\r\n}\r\n}\r\nvoid\r\nxfs_qm_unmount_quotas(\r\nxfs_mount_t *mp)\r\n{\r\nASSERT(mp->m_rootip);\r\nxfs_qm_dqdetach(mp->m_rootip);\r\nif (mp->m_rbmip)\r\nxfs_qm_dqdetach(mp->m_rbmip);\r\nif (mp->m_rsumip)\r\nxfs_qm_dqdetach(mp->m_rsumip);\r\nif (mp->m_quotainfo) {\r\nif (mp->m_quotainfo->qi_uquotaip) {\r\nIRELE(mp->m_quotainfo->qi_uquotaip);\r\nmp->m_quotainfo->qi_uquotaip = NULL;\r\n}\r\nif (mp->m_quotainfo->qi_gquotaip) {\r\nIRELE(mp->m_quotainfo->qi_gquotaip);\r\nmp->m_quotainfo->qi_gquotaip = NULL;\r\n}\r\n}\r\n}\r\nSTATIC int\r\nxfs_qm_dqattach_one(\r\nxfs_inode_t *ip,\r\nxfs_dqid_t id,\r\nuint type,\r\nuint doalloc,\r\nxfs_dquot_t *udqhint,\r\nxfs_dquot_t **IO_idqpp)\r\n{\r\nxfs_dquot_t *dqp;\r\nint error;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nerror = 0;\r\ndqp = *IO_idqpp;\r\nif (dqp) {\r\ntrace_xfs_dqattach_found(dqp);\r\nreturn 0;\r\n}\r\nif (udqhint) {\r\nASSERT(type == XFS_DQ_GROUP || type == XFS_DQ_PROJ);\r\nxfs_dqlock(udqhint);\r\ndqp = udqhint->q_gdquot;\r\nif (dqp && be32_to_cpu(dqp->q_core.d_id) == id) {\r\nASSERT(*IO_idqpp == NULL);\r\n*IO_idqpp = xfs_qm_dqhold(dqp);\r\nxfs_dqunlock(udqhint);\r\nreturn 0;\r\n}\r\nxfs_dqunlock(udqhint);\r\n}\r\nerror = xfs_qm_dqget(ip->i_mount, ip, id, type,\r\ndoalloc | XFS_QMOPT_DOWARN, &dqp);\r\nif (error)\r\nreturn error;\r\ntrace_xfs_dqattach_get(dqp);\r\n*IO_idqpp = dqp;\r\nxfs_dqunlock(dqp);\r\nreturn 0;\r\n}\r\nSTATIC void\r\nxfs_qm_dqattach_grouphint(\r\nxfs_dquot_t *udq,\r\nxfs_dquot_t *gdq)\r\n{\r\nxfs_dquot_t *tmp;\r\nxfs_dqlock(udq);\r\ntmp = udq->q_gdquot;\r\nif (tmp) {\r\nif (tmp == gdq)\r\ngoto done;\r\nudq->q_gdquot = NULL;\r\nxfs_qm_dqrele(tmp);\r\n}\r\nudq->q_gdquot = xfs_qm_dqhold(gdq);\r\ndone:\r\nxfs_dqunlock(udq);\r\n}\r\nstatic bool\r\nxfs_qm_need_dqattach(\r\nstruct xfs_inode *ip)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nif (!XFS_IS_QUOTA_RUNNING(mp))\r\nreturn false;\r\nif (!XFS_IS_QUOTA_ON(mp))\r\nreturn false;\r\nif (!XFS_NOT_DQATTACHED(mp, ip))\r\nreturn false;\r\nif (ip->i_ino == mp->m_sb.sb_uquotino ||\r\nip->i_ino == mp->m_sb.sb_gquotino)\r\nreturn false;\r\nreturn true;\r\n}\r\nint\r\nxfs_qm_dqattach_locked(\r\nxfs_inode_t *ip,\r\nuint flags)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nuint nquotas = 0;\r\nint error = 0;\r\nif (!xfs_qm_need_dqattach(ip))\r\nreturn 0;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nif (XFS_IS_UQUOTA_ON(mp)) {\r\nerror = xfs_qm_dqattach_one(ip, ip->i_d.di_uid, XFS_DQ_USER,\r\nflags & XFS_QMOPT_DQALLOC,\r\nNULL, &ip->i_udquot);\r\nif (error)\r\ngoto done;\r\nnquotas++;\r\n}\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nif (XFS_IS_OQUOTA_ON(mp)) {\r\nerror = XFS_IS_GQUOTA_ON(mp) ?\r\nxfs_qm_dqattach_one(ip, ip->i_d.di_gid, XFS_DQ_GROUP,\r\nflags & XFS_QMOPT_DQALLOC,\r\nip->i_udquot, &ip->i_gdquot) :\r\nxfs_qm_dqattach_one(ip, xfs_get_projid(ip), XFS_DQ_PROJ,\r\nflags & XFS_QMOPT_DQALLOC,\r\nip->i_udquot, &ip->i_gdquot);\r\nif (error)\r\ngoto done;\r\nnquotas++;\r\n}\r\nif (nquotas == 2) {\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nASSERT(ip->i_udquot);\r\nASSERT(ip->i_gdquot);\r\nif (ip->i_udquot->q_gdquot != ip->i_gdquot)\r\nxfs_qm_dqattach_grouphint(ip->i_udquot, ip->i_gdquot);\r\n}\r\ndone:\r\n#ifdef DEBUG\r\nif (!error) {\r\nif (XFS_IS_UQUOTA_ON(mp))\r\nASSERT(ip->i_udquot);\r\nif (XFS_IS_OQUOTA_ON(mp))\r\nASSERT(ip->i_gdquot);\r\n}\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\n#endif\r\nreturn error;\r\n}\r\nint\r\nxfs_qm_dqattach(\r\nstruct xfs_inode *ip,\r\nuint flags)\r\n{\r\nint error;\r\nif (!xfs_qm_need_dqattach(ip))\r\nreturn 0;\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nerror = xfs_qm_dqattach_locked(ip, flags);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn error;\r\n}\r\nvoid\r\nxfs_qm_dqdetach(\r\nxfs_inode_t *ip)\r\n{\r\nif (!(ip->i_udquot || ip->i_gdquot))\r\nreturn;\r\ntrace_xfs_dquot_dqdetach(ip);\r\nASSERT(ip->i_ino != ip->i_mount->m_sb.sb_uquotino);\r\nASSERT(ip->i_ino != ip->i_mount->m_sb.sb_gquotino);\r\nif (ip->i_udquot) {\r\nxfs_qm_dqrele(ip->i_udquot);\r\nip->i_udquot = NULL;\r\n}\r\nif (ip->i_gdquot) {\r\nxfs_qm_dqrele(ip->i_gdquot);\r\nip->i_gdquot = NULL;\r\n}\r\n}\r\nSTATIC int\r\nxfs_qm_init_quotainfo(\r\nxfs_mount_t *mp)\r\n{\r\nxfs_quotainfo_t *qinf;\r\nint error;\r\nxfs_dquot_t *dqp;\r\nASSERT(XFS_IS_QUOTA_RUNNING(mp));\r\nqinf = mp->m_quotainfo = kmem_zalloc(sizeof(xfs_quotainfo_t), KM_SLEEP);\r\nif ((error = xfs_qm_init_quotainos(mp))) {\r\nkmem_free(qinf);\r\nmp->m_quotainfo = NULL;\r\nreturn error;\r\n}\r\nINIT_RADIX_TREE(&qinf->qi_uquota_tree, GFP_NOFS);\r\nINIT_RADIX_TREE(&qinf->qi_gquota_tree, GFP_NOFS);\r\nmutex_init(&qinf->qi_tree_lock);\r\nINIT_LIST_HEAD(&qinf->qi_lru_list);\r\nqinf->qi_lru_count = 0;\r\nmutex_init(&qinf->qi_lru_lock);\r\nmutex_init(&qinf->qi_quotaofflock);\r\nqinf->qi_dqchunklen = XFS_FSB_TO_BB(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);\r\nASSERT(qinf->qi_dqchunklen);\r\nqinf->qi_dqperchunk = BBTOB(qinf->qi_dqchunklen);\r\ndo_div(qinf->qi_dqperchunk, sizeof(xfs_dqblk_t));\r\nmp->m_qflags |= (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_CHKD);\r\nerror = xfs_qm_dqread(mp, 0,\r\nXFS_IS_UQUOTA_RUNNING(mp) ? XFS_DQ_USER :\r\n(XFS_IS_GQUOTA_RUNNING(mp) ? XFS_DQ_GROUP :\r\nXFS_DQ_PROJ),\r\nXFS_QMOPT_DOWARN, &dqp);\r\nif (!error) {\r\nxfs_disk_dquot_t *ddqp = &dqp->q_core;\r\nqinf->qi_btimelimit = ddqp->d_btimer ?\r\nbe32_to_cpu(ddqp->d_btimer) : XFS_QM_BTIMELIMIT;\r\nqinf->qi_itimelimit = ddqp->d_itimer ?\r\nbe32_to_cpu(ddqp->d_itimer) : XFS_QM_ITIMELIMIT;\r\nqinf->qi_rtbtimelimit = ddqp->d_rtbtimer ?\r\nbe32_to_cpu(ddqp->d_rtbtimer) : XFS_QM_RTBTIMELIMIT;\r\nqinf->qi_bwarnlimit = ddqp->d_bwarns ?\r\nbe16_to_cpu(ddqp->d_bwarns) : XFS_QM_BWARNLIMIT;\r\nqinf->qi_iwarnlimit = ddqp->d_iwarns ?\r\nbe16_to_cpu(ddqp->d_iwarns) : XFS_QM_IWARNLIMIT;\r\nqinf->qi_rtbwarnlimit = ddqp->d_rtbwarns ?\r\nbe16_to_cpu(ddqp->d_rtbwarns) : XFS_QM_RTBWARNLIMIT;\r\nqinf->qi_bhardlimit = be64_to_cpu(ddqp->d_blk_hardlimit);\r\nqinf->qi_bsoftlimit = be64_to_cpu(ddqp->d_blk_softlimit);\r\nqinf->qi_ihardlimit = be64_to_cpu(ddqp->d_ino_hardlimit);\r\nqinf->qi_isoftlimit = be64_to_cpu(ddqp->d_ino_softlimit);\r\nqinf->qi_rtbhardlimit = be64_to_cpu(ddqp->d_rtb_hardlimit);\r\nqinf->qi_rtbsoftlimit = be64_to_cpu(ddqp->d_rtb_softlimit);\r\nxfs_qm_dqdestroy(dqp);\r\n} else {\r\nqinf->qi_btimelimit = XFS_QM_BTIMELIMIT;\r\nqinf->qi_itimelimit = XFS_QM_ITIMELIMIT;\r\nqinf->qi_rtbtimelimit = XFS_QM_RTBTIMELIMIT;\r\nqinf->qi_bwarnlimit = XFS_QM_BWARNLIMIT;\r\nqinf->qi_iwarnlimit = XFS_QM_IWARNLIMIT;\r\nqinf->qi_rtbwarnlimit = XFS_QM_RTBWARNLIMIT;\r\n}\r\nqinf->qi_shrinker.shrink = xfs_qm_shake;\r\nqinf->qi_shrinker.seeks = DEFAULT_SEEKS;\r\nregister_shrinker(&qinf->qi_shrinker);\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_qm_destroy_quotainfo(\r\nxfs_mount_t *mp)\r\n{\r\nxfs_quotainfo_t *qi;\r\nqi = mp->m_quotainfo;\r\nASSERT(qi != NULL);\r\nunregister_shrinker(&qi->qi_shrinker);\r\nif (qi->qi_uquotaip) {\r\nIRELE(qi->qi_uquotaip);\r\nqi->qi_uquotaip = NULL;\r\n}\r\nif (qi->qi_gquotaip) {\r\nIRELE(qi->qi_gquotaip);\r\nqi->qi_gquotaip = NULL;\r\n}\r\nmutex_destroy(&qi->qi_quotaofflock);\r\nkmem_free(qi);\r\nmp->m_quotainfo = NULL;\r\n}\r\nSTATIC int\r\nxfs_qm_qino_alloc(\r\nxfs_mount_t *mp,\r\nxfs_inode_t **ip,\r\n__int64_t sbfields,\r\nuint flags)\r\n{\r\nxfs_trans_t *tp;\r\nint error;\r\nint committed;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_QM_QINOCREATE);\r\nif ((error = xfs_trans_reserve(tp,\r\nXFS_QM_QINOCREATE_SPACE_RES(mp),\r\nXFS_CREATE_LOG_RES(mp), 0,\r\nXFS_TRANS_PERM_LOG_RES,\r\nXFS_CREATE_LOG_COUNT))) {\r\nxfs_trans_cancel(tp, 0);\r\nreturn error;\r\n}\r\nerror = xfs_dir_ialloc(&tp, NULL, S_IFREG, 1, 0, 0, 1, ip, &committed);\r\nif (error) {\r\nxfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES |\r\nXFS_TRANS_ABORT);\r\nreturn error;\r\n}\r\nspin_lock(&mp->m_sb_lock);\r\nif (flags & XFS_QMOPT_SBVERSION) {\r\nASSERT(!xfs_sb_version_hasquota(&mp->m_sb));\r\nASSERT((sbfields & (XFS_SB_VERSIONNUM | XFS_SB_UQUOTINO |\r\nXFS_SB_GQUOTINO | XFS_SB_QFLAGS)) ==\r\n(XFS_SB_VERSIONNUM | XFS_SB_UQUOTINO |\r\nXFS_SB_GQUOTINO | XFS_SB_QFLAGS));\r\nxfs_sb_version_addquota(&mp->m_sb);\r\nmp->m_sb.sb_uquotino = NULLFSINO;\r\nmp->m_sb.sb_gquotino = NULLFSINO;\r\nmp->m_sb.sb_qflags = 0;\r\n}\r\nif (flags & XFS_QMOPT_UQUOTA)\r\nmp->m_sb.sb_uquotino = (*ip)->i_ino;\r\nelse\r\nmp->m_sb.sb_gquotino = (*ip)->i_ino;\r\nspin_unlock(&mp->m_sb_lock);\r\nxfs_mod_sb(tp, sbfields);\r\nif ((error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES))) {\r\nxfs_alert(mp, "%s failed (error %d)!", __func__, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nSTATIC void\r\nxfs_qm_reset_dqcounts(\r\nxfs_mount_t *mp,\r\nxfs_buf_t *bp,\r\nxfs_dqid_t id,\r\nuint type)\r\n{\r\nxfs_disk_dquot_t *ddq;\r\nint j;\r\ntrace_xfs_reset_dqcounts(bp, _RET_IP_);\r\n#ifdef DEBUG\r\nj = XFS_FSB_TO_B(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);\r\ndo_div(j, sizeof(xfs_dqblk_t));\r\nASSERT(mp->m_quotainfo->qi_dqperchunk == j);\r\n#endif\r\nddq = bp->b_addr;\r\nfor (j = 0; j < mp->m_quotainfo->qi_dqperchunk; j++) {\r\n(void) xfs_qm_dqcheck(mp, ddq, id+j, type, XFS_QMOPT_DQREPAIR,\r\n"xfs_quotacheck");\r\nddq->d_bcount = 0;\r\nddq->d_icount = 0;\r\nddq->d_rtbcount = 0;\r\nddq->d_btimer = 0;\r\nddq->d_itimer = 0;\r\nddq->d_rtbtimer = 0;\r\nddq->d_bwarns = 0;\r\nddq->d_iwarns = 0;\r\nddq->d_rtbwarns = 0;\r\nddq = (xfs_disk_dquot_t *) ((xfs_dqblk_t *)ddq + 1);\r\n}\r\n}\r\nSTATIC int\r\nxfs_qm_dqiter_bufs(\r\nstruct xfs_mount *mp,\r\nxfs_dqid_t firstid,\r\nxfs_fsblock_t bno,\r\nxfs_filblks_t blkcnt,\r\nuint flags,\r\nstruct list_head *buffer_list)\r\n{\r\nstruct xfs_buf *bp;\r\nint error;\r\nint type;\r\nASSERT(blkcnt > 0);\r\ntype = flags & XFS_QMOPT_UQUOTA ? XFS_DQ_USER :\r\n(flags & XFS_QMOPT_PQUOTA ? XFS_DQ_PROJ : XFS_DQ_GROUP);\r\nerror = 0;\r\nwhile (blkcnt--) {\r\nerror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\r\nXFS_FSB_TO_DADDR(mp, bno),\r\nmp->m_quotainfo->qi_dqchunklen, 0, &bp);\r\nif (error)\r\nbreak;\r\nxfs_qm_reset_dqcounts(mp, bp, firstid, type);\r\nxfs_buf_delwri_queue(bp, buffer_list);\r\nxfs_buf_relse(bp);\r\nbno++;\r\nfirstid += mp->m_quotainfo->qi_dqperchunk;\r\n}\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_qm_dqiterate(\r\nstruct xfs_mount *mp,\r\nstruct xfs_inode *qip,\r\nuint flags,\r\nstruct list_head *buffer_list)\r\n{\r\nstruct xfs_bmbt_irec *map;\r\nint i, nmaps;\r\nint error;\r\nxfs_fileoff_t lblkno;\r\nxfs_filblks_t maxlblkcnt;\r\nxfs_dqid_t firstid;\r\nxfs_fsblock_t rablkno;\r\nxfs_filblks_t rablkcnt;\r\nerror = 0;\r\nif (qip->i_d.di_nblocks == 0)\r\nreturn 0;\r\nmap = kmem_alloc(XFS_DQITER_MAP_SIZE * sizeof(*map), KM_SLEEP);\r\nlblkno = 0;\r\nmaxlblkcnt = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\r\ndo {\r\nnmaps = XFS_DQITER_MAP_SIZE;\r\nxfs_ilock(qip, XFS_ILOCK_SHARED);\r\nerror = xfs_bmapi_read(qip, lblkno, maxlblkcnt - lblkno,\r\nmap, &nmaps, 0);\r\nxfs_iunlock(qip, XFS_ILOCK_SHARED);\r\nif (error)\r\nbreak;\r\nASSERT(nmaps <= XFS_DQITER_MAP_SIZE);\r\nfor (i = 0; i < nmaps; i++) {\r\nASSERT(map[i].br_startblock != DELAYSTARTBLOCK);\r\nASSERT(map[i].br_blockcount);\r\nlblkno += map[i].br_blockcount;\r\nif (map[i].br_startblock == HOLESTARTBLOCK)\r\ncontinue;\r\nfirstid = (xfs_dqid_t) map[i].br_startoff *\r\nmp->m_quotainfo->qi_dqperchunk;\r\nif ((i+1 < nmaps) &&\r\n(map[i+1].br_startblock != HOLESTARTBLOCK)) {\r\nrablkcnt = map[i+1].br_blockcount;\r\nrablkno = map[i+1].br_startblock;\r\nwhile (rablkcnt--) {\r\nxfs_buf_readahead(mp->m_ddev_targp,\r\nXFS_FSB_TO_DADDR(mp, rablkno),\r\nmp->m_quotainfo->qi_dqchunklen);\r\nrablkno++;\r\n}\r\n}\r\nerror = xfs_qm_dqiter_bufs(mp, firstid,\r\nmap[i].br_startblock,\r\nmap[i].br_blockcount,\r\nflags, buffer_list);\r\nif (error)\r\ngoto out;\r\n}\r\n} while (nmaps > 0);\r\nout:\r\nkmem_free(map);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_qm_quotacheck_dqadjust(\r\nstruct xfs_inode *ip,\r\nxfs_dqid_t id,\r\nuint type,\r\nxfs_qcnt_t nblks,\r\nxfs_qcnt_t rtblks)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct xfs_dquot *dqp;\r\nint error;\r\nerror = xfs_qm_dqget(mp, ip, id, type,\r\nXFS_QMOPT_DQALLOC | XFS_QMOPT_DOWARN, &dqp);\r\nif (error) {\r\nASSERT(error != ESRCH);\r\nASSERT(error != ENOENT);\r\nreturn error;\r\n}\r\ntrace_xfs_dqadjust(dqp);\r\nbe64_add_cpu(&dqp->q_core.d_icount, 1);\r\ndqp->q_res_icount++;\r\nif (nblks) {\r\nbe64_add_cpu(&dqp->q_core.d_bcount, nblks);\r\ndqp->q_res_bcount += nblks;\r\n}\r\nif (rtblks) {\r\nbe64_add_cpu(&dqp->q_core.d_rtbcount, rtblks);\r\ndqp->q_res_rtbcount += rtblks;\r\n}\r\nif (dqp->q_core.d_id) {\r\nxfs_qm_adjust_dqlimits(mp, &dqp->q_core);\r\nxfs_qm_adjust_dqtimers(mp, &dqp->q_core);\r\n}\r\ndqp->dq_flags |= XFS_DQ_DIRTY;\r\nxfs_qm_dqput(dqp);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_qm_get_rtblks(\r\nxfs_inode_t *ip,\r\nxfs_qcnt_t *O_rtblks)\r\n{\r\nxfs_filblks_t rtblks;\r\nxfs_extnum_t idx;\r\nxfs_ifork_t *ifp;\r\nxfs_extnum_t nextents;\r\nint error;\r\nASSERT(XFS_IS_REALTIME_INODE(ip));\r\nifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\r\nif (!(ifp->if_flags & XFS_IFEXTENTS)) {\r\nif ((error = xfs_iread_extents(NULL, ip, XFS_DATA_FORK)))\r\nreturn error;\r\n}\r\nrtblks = 0;\r\nnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\r\nfor (idx = 0; idx < nextents; idx++)\r\nrtblks += xfs_bmbt_get_blockcount(xfs_iext_get_ext(ifp, idx));\r\n*O_rtblks = (xfs_qcnt_t)rtblks;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_qm_dqusage_adjust(\r\nxfs_mount_t *mp,\r\nxfs_ino_t ino,\r\nvoid __user *buffer,\r\nint ubsize,\r\nint *ubused,\r\nint *res)\r\n{\r\nxfs_inode_t *ip;\r\nxfs_qcnt_t nblks, rtblks = 0;\r\nint error;\r\nASSERT(XFS_IS_QUOTA_RUNNING(mp));\r\nif (ino == mp->m_sb.sb_uquotino || ino == mp->m_sb.sb_gquotino) {\r\n*res = BULKSTAT_RV_NOTHING;\r\nreturn XFS_ERROR(EINVAL);\r\n}\r\nerror = xfs_iget(mp, NULL, ino, 0, XFS_ILOCK_EXCL, &ip);\r\nif (error) {\r\n*res = BULKSTAT_RV_NOTHING;\r\nreturn error;\r\n}\r\nASSERT(ip->i_delayed_blks == 0);\r\nif (XFS_IS_REALTIME_INODE(ip)) {\r\nerror = xfs_qm_get_rtblks(ip, &rtblks);\r\nif (error)\r\ngoto error0;\r\n}\r\nnblks = (xfs_qcnt_t)ip->i_d.di_nblocks - rtblks;\r\nif (XFS_IS_UQUOTA_ON(mp)) {\r\nerror = xfs_qm_quotacheck_dqadjust(ip, ip->i_d.di_uid,\r\nXFS_DQ_USER, nblks, rtblks);\r\nif (error)\r\ngoto error0;\r\n}\r\nif (XFS_IS_GQUOTA_ON(mp)) {\r\nerror = xfs_qm_quotacheck_dqadjust(ip, ip->i_d.di_gid,\r\nXFS_DQ_GROUP, nblks, rtblks);\r\nif (error)\r\ngoto error0;\r\n}\r\nif (XFS_IS_PQUOTA_ON(mp)) {\r\nerror = xfs_qm_quotacheck_dqadjust(ip, xfs_get_projid(ip),\r\nXFS_DQ_PROJ, nblks, rtblks);\r\nif (error)\r\ngoto error0;\r\n}\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nIRELE(ip);\r\n*res = BULKSTAT_RV_DIDONE;\r\nreturn 0;\r\nerror0:\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nIRELE(ip);\r\n*res = BULKSTAT_RV_GIVEUP;\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_qm_flush_one(\r\nstruct xfs_dquot *dqp,\r\nvoid *data)\r\n{\r\nstruct list_head *buffer_list = data;\r\nstruct xfs_buf *bp = NULL;\r\nint error = 0;\r\nxfs_dqlock(dqp);\r\nif (dqp->dq_flags & XFS_DQ_FREEING)\r\ngoto out_unlock;\r\nif (!XFS_DQ_IS_DIRTY(dqp))\r\ngoto out_unlock;\r\nxfs_dqflock(dqp);\r\nerror = xfs_qm_dqflush(dqp, &bp);\r\nif (error)\r\ngoto out_unlock;\r\nxfs_buf_delwri_queue(bp, buffer_list);\r\nxfs_buf_relse(bp);\r\nout_unlock:\r\nxfs_dqunlock(dqp);\r\nreturn error;\r\n}\r\nint\r\nxfs_qm_quotacheck(\r\nxfs_mount_t *mp)\r\n{\r\nint done, count, error, error2;\r\nxfs_ino_t lastino;\r\nsize_t structsz;\r\nxfs_inode_t *uip, *gip;\r\nuint flags;\r\nLIST_HEAD (buffer_list);\r\ncount = INT_MAX;\r\nstructsz = 1;\r\nlastino = 0;\r\nflags = 0;\r\nASSERT(mp->m_quotainfo->qi_uquotaip || mp->m_quotainfo->qi_gquotaip);\r\nASSERT(XFS_IS_QUOTA_RUNNING(mp));\r\nxfs_notice(mp, "Quotacheck needed: Please wait.");\r\nuip = mp->m_quotainfo->qi_uquotaip;\r\nif (uip) {\r\nerror = xfs_qm_dqiterate(mp, uip, XFS_QMOPT_UQUOTA,\r\n&buffer_list);\r\nif (error)\r\ngoto error_return;\r\nflags |= XFS_UQUOTA_CHKD;\r\n}\r\ngip = mp->m_quotainfo->qi_gquotaip;\r\nif (gip) {\r\nerror = xfs_qm_dqiterate(mp, gip, XFS_IS_GQUOTA_ON(mp) ?\r\nXFS_QMOPT_GQUOTA : XFS_QMOPT_PQUOTA,\r\n&buffer_list);\r\nif (error)\r\ngoto error_return;\r\nflags |= XFS_OQUOTA_CHKD;\r\n}\r\ndo {\r\nerror = xfs_bulkstat(mp, &lastino, &count,\r\nxfs_qm_dqusage_adjust,\r\nstructsz, NULL, &done);\r\nif (error)\r\nbreak;\r\n} while (!done);\r\nif (XFS_IS_UQUOTA_ON(mp)) {\r\nerror = xfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_flush_one,\r\n&buffer_list);\r\n}\r\nif (XFS_IS_GQUOTA_ON(mp)) {\r\nerror2 = xfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_flush_one,\r\n&buffer_list);\r\nif (!error)\r\nerror = error2;\r\n}\r\nif (XFS_IS_PQUOTA_ON(mp)) {\r\nerror2 = xfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_flush_one,\r\n&buffer_list);\r\nif (!error)\r\nerror = error2;\r\n}\r\nerror2 = xfs_buf_delwri_submit(&buffer_list);\r\nif (!error)\r\nerror = error2;\r\nif (error) {\r\nxfs_qm_dqpurge_all(mp, XFS_QMOPT_QUOTALL);\r\ngoto error_return;\r\n}\r\nmp->m_qflags &= ~XFS_ALL_QUOTA_CHKD;\r\nmp->m_qflags |= flags;\r\nerror_return:\r\nwhile (!list_empty(&buffer_list)) {\r\nstruct xfs_buf *bp =\r\nlist_first_entry(&buffer_list, struct xfs_buf, b_list);\r\nlist_del_init(&bp->b_list);\r\nxfs_buf_relse(bp);\r\n}\r\nif (error) {\r\nxfs_warn(mp,\r\n"Quotacheck: Unsuccessful (Error %d): Disabling quotas.",\r\nerror);\r\nASSERT(mp->m_quotainfo != NULL);\r\nxfs_qm_destroy_quotainfo(mp);\r\nif (xfs_mount_reset_sbqflags(mp)) {\r\nxfs_warn(mp,\r\n"Quotacheck: Failed to reset quota flags.");\r\n}\r\n} else\r\nxfs_notice(mp, "Quotacheck: Done.");\r\nreturn (error);\r\n}\r\nSTATIC int\r\nxfs_qm_init_quotainos(\r\nxfs_mount_t *mp)\r\n{\r\nxfs_inode_t *uip, *gip;\r\nint error;\r\n__int64_t sbflags;\r\nuint flags;\r\nASSERT(mp->m_quotainfo);\r\nuip = gip = NULL;\r\nsbflags = 0;\r\nflags = 0;\r\nif (xfs_sb_version_hasquota(&mp->m_sb)) {\r\nif (XFS_IS_UQUOTA_ON(mp) &&\r\nmp->m_sb.sb_uquotino != NULLFSINO) {\r\nASSERT(mp->m_sb.sb_uquotino > 0);\r\nif ((error = xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\r\n0, 0, &uip)))\r\nreturn XFS_ERROR(error);\r\n}\r\nif (XFS_IS_OQUOTA_ON(mp) &&\r\nmp->m_sb.sb_gquotino != NULLFSINO) {\r\nASSERT(mp->m_sb.sb_gquotino > 0);\r\nif ((error = xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\r\n0, 0, &gip))) {\r\nif (uip)\r\nIRELE(uip);\r\nreturn XFS_ERROR(error);\r\n}\r\n}\r\n} else {\r\nflags |= XFS_QMOPT_SBVERSION;\r\nsbflags |= (XFS_SB_VERSIONNUM | XFS_SB_UQUOTINO |\r\nXFS_SB_GQUOTINO | XFS_SB_QFLAGS);\r\n}\r\nif (XFS_IS_UQUOTA_ON(mp) && uip == NULL) {\r\nif ((error = xfs_qm_qino_alloc(mp, &uip,\r\nsbflags | XFS_SB_UQUOTINO,\r\nflags | XFS_QMOPT_UQUOTA)))\r\nreturn XFS_ERROR(error);\r\nflags &= ~XFS_QMOPT_SBVERSION;\r\n}\r\nif (XFS_IS_OQUOTA_ON(mp) && gip == NULL) {\r\nflags |= (XFS_IS_GQUOTA_ON(mp) ?\r\nXFS_QMOPT_GQUOTA : XFS_QMOPT_PQUOTA);\r\nerror = xfs_qm_qino_alloc(mp, &gip,\r\nsbflags | XFS_SB_GQUOTINO, flags);\r\nif (error) {\r\nif (uip)\r\nIRELE(uip);\r\nreturn XFS_ERROR(error);\r\n}\r\n}\r\nmp->m_quotainfo->qi_uquotaip = uip;\r\nmp->m_quotainfo->qi_gquotaip = gip;\r\nreturn 0;\r\n}\r\nSTATIC void\r\nxfs_qm_dqfree_one(\r\nstruct xfs_dquot *dqp)\r\n{\r\nstruct xfs_mount *mp = dqp->q_mount;\r\nstruct xfs_quotainfo *qi = mp->m_quotainfo;\r\nmutex_lock(&qi->qi_tree_lock);\r\nradix_tree_delete(XFS_DQUOT_TREE(qi, dqp->q_core.d_flags),\r\nbe32_to_cpu(dqp->q_core.d_id));\r\nqi->qi_dquots--;\r\nmutex_unlock(&qi->qi_tree_lock);\r\nxfs_qm_dqdestroy(dqp);\r\n}\r\nSTATIC void\r\nxfs_qm_dqreclaim_one(\r\nstruct xfs_dquot *dqp,\r\nstruct list_head *buffer_list,\r\nstruct list_head *dispose_list)\r\n{\r\nstruct xfs_mount *mp = dqp->q_mount;\r\nstruct xfs_quotainfo *qi = mp->m_quotainfo;\r\nint error;\r\nif (!xfs_dqlock_nowait(dqp))\r\ngoto out_busy;\r\nif (dqp->q_nrefs) {\r\nxfs_dqunlock(dqp);\r\ntrace_xfs_dqreclaim_want(dqp);\r\nXFS_STATS_INC(xs_qm_dqwants);\r\nlist_del_init(&dqp->q_lru);\r\nqi->qi_lru_count--;\r\nXFS_STATS_DEC(xs_qm_dquot_unused);\r\nreturn;\r\n}\r\nif (!xfs_dqflock_nowait(dqp))\r\ngoto out_busy;\r\nif (XFS_DQ_IS_DIRTY(dqp)) {\r\nstruct xfs_buf *bp = NULL;\r\ntrace_xfs_dqreclaim_dirty(dqp);\r\nerror = xfs_qm_dqflush(dqp, &bp);\r\nif (error) {\r\nxfs_warn(mp, "%s: dquot %p flush failed",\r\n__func__, dqp);\r\ngoto out_busy;\r\n}\r\nxfs_buf_delwri_queue(bp, buffer_list);\r\nxfs_buf_relse(bp);\r\ngoto out_busy;\r\n}\r\nxfs_dqfunlock(dqp);\r\ndqp->dq_flags |= XFS_DQ_FREEING;\r\nxfs_dqunlock(dqp);\r\nASSERT(dqp->q_nrefs == 0);\r\nlist_move_tail(&dqp->q_lru, dispose_list);\r\nqi->qi_lru_count--;\r\nXFS_STATS_DEC(xs_qm_dquot_unused);\r\ntrace_xfs_dqreclaim_done(dqp);\r\nXFS_STATS_INC(xs_qm_dqreclaims);\r\nreturn;\r\nout_busy:\r\nxfs_dqunlock(dqp);\r\nlist_move_tail(&dqp->q_lru, &qi->qi_lru_list);\r\ntrace_xfs_dqreclaim_busy(dqp);\r\nXFS_STATS_INC(xs_qm_dqreclaim_misses);\r\n}\r\nSTATIC int\r\nxfs_qm_shake(\r\nstruct shrinker *shrink,\r\nstruct shrink_control *sc)\r\n{\r\nstruct xfs_quotainfo *qi =\r\ncontainer_of(shrink, struct xfs_quotainfo, qi_shrinker);\r\nint nr_to_scan = sc->nr_to_scan;\r\nLIST_HEAD (buffer_list);\r\nLIST_HEAD (dispose_list);\r\nstruct xfs_dquot *dqp;\r\nint error;\r\nif ((sc->gfp_mask & (__GFP_FS|__GFP_WAIT)) != (__GFP_FS|__GFP_WAIT))\r\nreturn 0;\r\nif (!nr_to_scan)\r\ngoto out;\r\nmutex_lock(&qi->qi_lru_lock);\r\nwhile (!list_empty(&qi->qi_lru_list)) {\r\nif (nr_to_scan-- <= 0)\r\nbreak;\r\ndqp = list_first_entry(&qi->qi_lru_list, struct xfs_dquot,\r\nq_lru);\r\nxfs_qm_dqreclaim_one(dqp, &buffer_list, &dispose_list);\r\n}\r\nmutex_unlock(&qi->qi_lru_lock);\r\nerror = xfs_buf_delwri_submit(&buffer_list);\r\nif (error)\r\nxfs_warn(NULL, "%s: dquot reclaim failed", __func__);\r\nwhile (!list_empty(&dispose_list)) {\r\ndqp = list_first_entry(&dispose_list, struct xfs_dquot, q_lru);\r\nlist_del_init(&dqp->q_lru);\r\nxfs_qm_dqfree_one(dqp);\r\n}\r\nout:\r\nreturn (qi->qi_lru_count / 100) * sysctl_vfs_cache_pressure;\r\n}\r\nint\r\nxfs_qm_write_sb_changes(\r\nxfs_mount_t *mp,\r\n__int64_t flags)\r\n{\r\nxfs_trans_t *tp;\r\nint error;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_QM_SBCHANGE);\r\nif ((error = xfs_trans_reserve(tp, 0,\r\nmp->m_sb.sb_sectsize + 128, 0,\r\n0,\r\nXFS_DEFAULT_LOG_COUNT))) {\r\nxfs_trans_cancel(tp, 0);\r\nreturn error;\r\n}\r\nxfs_mod_sb(tp, flags);\r\nerror = xfs_trans_commit(tp, 0);\r\nreturn error;\r\n}\r\nint\r\nxfs_qm_vop_dqalloc(\r\nstruct xfs_inode *ip,\r\nuid_t uid,\r\ngid_t gid,\r\nprid_t prid,\r\nuint flags,\r\nstruct xfs_dquot **O_udqpp,\r\nstruct xfs_dquot **O_gdqpp)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct xfs_dquot *uq, *gq;\r\nint error;\r\nuint lockflags;\r\nif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\r\nreturn 0;\r\nlockflags = XFS_ILOCK_EXCL;\r\nxfs_ilock(ip, lockflags);\r\nif ((flags & XFS_QMOPT_INHERIT) && XFS_INHERIT_GID(ip))\r\ngid = ip->i_d.di_gid;\r\nif (XFS_NOT_DQATTACHED(mp, ip)) {\r\nerror = xfs_qm_dqattach_locked(ip, XFS_QMOPT_DQALLOC);\r\nif (error) {\r\nxfs_iunlock(ip, lockflags);\r\nreturn error;\r\n}\r\n}\r\nuq = gq = NULL;\r\nif ((flags & XFS_QMOPT_UQUOTA) && XFS_IS_UQUOTA_ON(mp)) {\r\nif (ip->i_d.di_uid != uid) {\r\nxfs_iunlock(ip, lockflags);\r\nif ((error = xfs_qm_dqget(mp, NULL, (xfs_dqid_t) uid,\r\nXFS_DQ_USER,\r\nXFS_QMOPT_DQALLOC |\r\nXFS_QMOPT_DOWARN,\r\n&uq))) {\r\nASSERT(error != ENOENT);\r\nreturn error;\r\n}\r\nxfs_dqunlock(uq);\r\nlockflags = XFS_ILOCK_SHARED;\r\nxfs_ilock(ip, lockflags);\r\n} else {\r\nASSERT(ip->i_udquot);\r\nuq = xfs_qm_dqhold(ip->i_udquot);\r\n}\r\n}\r\nif ((flags & XFS_QMOPT_GQUOTA) && XFS_IS_GQUOTA_ON(mp)) {\r\nif (ip->i_d.di_gid != gid) {\r\nxfs_iunlock(ip, lockflags);\r\nif ((error = xfs_qm_dqget(mp, NULL, (xfs_dqid_t)gid,\r\nXFS_DQ_GROUP,\r\nXFS_QMOPT_DQALLOC |\r\nXFS_QMOPT_DOWARN,\r\n&gq))) {\r\nif (uq)\r\nxfs_qm_dqrele(uq);\r\nASSERT(error != ENOENT);\r\nreturn error;\r\n}\r\nxfs_dqunlock(gq);\r\nlockflags = XFS_ILOCK_SHARED;\r\nxfs_ilock(ip, lockflags);\r\n} else {\r\nASSERT(ip->i_gdquot);\r\ngq = xfs_qm_dqhold(ip->i_gdquot);\r\n}\r\n} else if ((flags & XFS_QMOPT_PQUOTA) && XFS_IS_PQUOTA_ON(mp)) {\r\nif (xfs_get_projid(ip) != prid) {\r\nxfs_iunlock(ip, lockflags);\r\nif ((error = xfs_qm_dqget(mp, NULL, (xfs_dqid_t)prid,\r\nXFS_DQ_PROJ,\r\nXFS_QMOPT_DQALLOC |\r\nXFS_QMOPT_DOWARN,\r\n&gq))) {\r\nif (uq)\r\nxfs_qm_dqrele(uq);\r\nASSERT(error != ENOENT);\r\nreturn (error);\r\n}\r\nxfs_dqunlock(gq);\r\nlockflags = XFS_ILOCK_SHARED;\r\nxfs_ilock(ip, lockflags);\r\n} else {\r\nASSERT(ip->i_gdquot);\r\ngq = xfs_qm_dqhold(ip->i_gdquot);\r\n}\r\n}\r\nif (uq)\r\ntrace_xfs_dquot_dqalloc(ip);\r\nxfs_iunlock(ip, lockflags);\r\nif (O_udqpp)\r\n*O_udqpp = uq;\r\nelse if (uq)\r\nxfs_qm_dqrele(uq);\r\nif (O_gdqpp)\r\n*O_gdqpp = gq;\r\nelse if (gq)\r\nxfs_qm_dqrele(gq);\r\nreturn 0;\r\n}\r\nxfs_dquot_t *\r\nxfs_qm_vop_chown(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *ip,\r\nxfs_dquot_t **IO_olddq,\r\nxfs_dquot_t *newdq)\r\n{\r\nxfs_dquot_t *prevdq;\r\nuint bfield = XFS_IS_REALTIME_INODE(ip) ?\r\nXFS_TRANS_DQ_RTBCOUNT : XFS_TRANS_DQ_BCOUNT;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nASSERT(XFS_IS_QUOTA_RUNNING(ip->i_mount));\r\nprevdq = *IO_olddq;\r\nASSERT(prevdq);\r\nASSERT(prevdq != newdq);\r\nxfs_trans_mod_dquot(tp, prevdq, bfield, -(ip->i_d.di_nblocks));\r\nxfs_trans_mod_dquot(tp, prevdq, XFS_TRANS_DQ_ICOUNT, -1);\r\nxfs_trans_mod_dquot(tp, newdq, bfield, ip->i_d.di_nblocks);\r\nxfs_trans_mod_dquot(tp, newdq, XFS_TRANS_DQ_ICOUNT, 1);\r\n*IO_olddq = xfs_qm_dqhold(newdq);\r\nreturn prevdq;\r\n}\r\nint\r\nxfs_qm_vop_chown_reserve(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *ip,\r\nxfs_dquot_t *udqp,\r\nxfs_dquot_t *gdqp,\r\nuint flags)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nuint delblks, blkflags, prjflags = 0;\r\nxfs_dquot_t *unresudq, *unresgdq, *delblksudq, *delblksgdq;\r\nint error;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\r\nASSERT(XFS_IS_QUOTA_RUNNING(mp));\r\ndelblks = ip->i_delayed_blks;\r\ndelblksudq = delblksgdq = unresudq = unresgdq = NULL;\r\nblkflags = XFS_IS_REALTIME_INODE(ip) ?\r\nXFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS;\r\nif (XFS_IS_UQUOTA_ON(mp) && udqp &&\r\nip->i_d.di_uid != (uid_t)be32_to_cpu(udqp->q_core.d_id)) {\r\ndelblksudq = udqp;\r\nif (delblks) {\r\nASSERT(ip->i_udquot);\r\nunresudq = ip->i_udquot;\r\n}\r\n}\r\nif (XFS_IS_OQUOTA_ON(ip->i_mount) && gdqp) {\r\nif (XFS_IS_PQUOTA_ON(ip->i_mount) &&\r\nxfs_get_projid(ip) != be32_to_cpu(gdqp->q_core.d_id))\r\nprjflags = XFS_QMOPT_ENOSPC;\r\nif (prjflags ||\r\n(XFS_IS_GQUOTA_ON(ip->i_mount) &&\r\nip->i_d.di_gid != be32_to_cpu(gdqp->q_core.d_id))) {\r\ndelblksgdq = gdqp;\r\nif (delblks) {\r\nASSERT(ip->i_gdquot);\r\nunresgdq = ip->i_gdquot;\r\n}\r\n}\r\n}\r\nif ((error = xfs_trans_reserve_quota_bydquots(tp, ip->i_mount,\r\ndelblksudq, delblksgdq, ip->i_d.di_nblocks, 1,\r\nflags | blkflags | prjflags)))\r\nreturn (error);\r\nif (delblks) {\r\nASSERT(delblksudq || delblksgdq);\r\nASSERT(unresudq || unresgdq);\r\nif ((error = xfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\r\ndelblksudq, delblksgdq, (xfs_qcnt_t)delblks, 0,\r\nflags | blkflags | prjflags)))\r\nreturn (error);\r\nxfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\r\nunresudq, unresgdq, -((xfs_qcnt_t)delblks), 0,\r\nblkflags);\r\n}\r\nreturn (0);\r\n}\r\nint\r\nxfs_qm_vop_rename_dqattach(\r\nstruct xfs_inode **i_tab)\r\n{\r\nstruct xfs_mount *mp = i_tab[0]->i_mount;\r\nint i;\r\nif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\r\nreturn 0;\r\nfor (i = 0; (i < 4 && i_tab[i]); i++) {\r\nstruct xfs_inode *ip = i_tab[i];\r\nint error;\r\nif (i == 0 || ip != i_tab[i-1]) {\r\nif (XFS_NOT_DQATTACHED(mp, ip)) {\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\nreturn error;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_qm_vop_create_dqattach(\r\nstruct xfs_trans *tp,\r\nstruct xfs_inode *ip,\r\nstruct xfs_dquot *udqp,\r\nstruct xfs_dquot *gdqp)\r\n{\r\nstruct xfs_mount *mp = tp->t_mountp;\r\nif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\r\nreturn;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nASSERT(XFS_IS_QUOTA_RUNNING(mp));\r\nif (udqp) {\r\nASSERT(ip->i_udquot == NULL);\r\nASSERT(XFS_IS_UQUOTA_ON(mp));\r\nASSERT(ip->i_d.di_uid == be32_to_cpu(udqp->q_core.d_id));\r\nip->i_udquot = xfs_qm_dqhold(udqp);\r\nxfs_trans_mod_dquot(tp, udqp, XFS_TRANS_DQ_ICOUNT, 1);\r\n}\r\nif (gdqp) {\r\nASSERT(ip->i_gdquot == NULL);\r\nASSERT(XFS_IS_OQUOTA_ON(mp));\r\nASSERT((XFS_IS_GQUOTA_ON(mp) ?\r\nip->i_d.di_gid : xfs_get_projid(ip)) ==\r\nbe32_to_cpu(gdqp->q_core.d_id));\r\nip->i_gdquot = xfs_qm_dqhold(gdqp);\r\nxfs_trans_mod_dquot(tp, gdqp, XFS_TRANS_DQ_ICOUNT, 1);\r\n}\r\n}
