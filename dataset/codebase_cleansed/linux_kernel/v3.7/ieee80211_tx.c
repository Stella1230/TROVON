static inline int ieee80211_put_snap(u8 *data, u16 h_proto)\r\n{\r\nstruct ieee80211_snap_hdr *snap;\r\nu8 *oui;\r\nsnap = (struct ieee80211_snap_hdr *)data;\r\nsnap->dsap = 0xaa;\r\nsnap->ssap = 0xaa;\r\nsnap->ctrl = 0x03;\r\nif (h_proto == 0x8137 || h_proto == 0x80f3)\r\noui = P802_1H_OUI;\r\nelse\r\noui = RFC1042_OUI;\r\nsnap->oui[0] = oui[0];\r\nsnap->oui[1] = oui[1];\r\nsnap->oui[2] = oui[2];\r\n*(u16 *)(data + SNAP_SIZE) = htons(h_proto);\r\nreturn SNAP_SIZE + sizeof(u16);\r\n}\r\nint ieee80211_encrypt_fragment(\r\nstruct ieee80211_device *ieee,\r\nstruct sk_buff *frag,\r\nint hdr_len)\r\n{\r\nstruct ieee80211_crypt_data* crypt = ieee->crypt[ieee->tx_keyidx];\r\nint res;\r\nif (!(crypt && crypt->ops))\r\n{\r\nprintk("=========>%s(), crypt is null\n", __FUNCTION__);\r\nreturn -1;\r\n}\r\n#ifdef CONFIG_IEEE80211_CRYPT_TKIP\r\nstruct ieee80211_hdr *header;\r\nif (ieee->tkip_countermeasures &&\r\ncrypt && crypt->ops && strcmp(crypt->ops->name, "TKIP") == 0) {\r\nheader = (struct ieee80211_hdr *) frag->data;\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "%s: TKIP countermeasures: dropped "\r\n"TX packet to %pM\n",\r\nieee->dev->name, header->addr1);\r\n}\r\nreturn -1;\r\n}\r\n#endif\r\natomic_inc(&crypt->refcnt);\r\nres = 0;\r\nif (crypt->ops->encrypt_msdu)\r\nres = crypt->ops->encrypt_msdu(frag, hdr_len, crypt->priv);\r\nif (res == 0 && crypt->ops->encrypt_mpdu)\r\nres = crypt->ops->encrypt_mpdu(frag, hdr_len, crypt->priv);\r\natomic_dec(&crypt->refcnt);\r\nif (res < 0) {\r\nprintk(KERN_INFO "%s: Encryption failed: len=%d.\n",\r\nieee->dev->name, frag->len);\r\nieee->ieee_stats.tx_discards++;\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid ieee80211_txb_free(struct ieee80211_txb *txb) {\r\nif (unlikely(!txb))\r\nreturn;\r\nkfree(txb);\r\n}\r\nstruct ieee80211_txb *ieee80211_alloc_txb(int nr_frags, int txb_size,\r\nint gfp_mask)\r\n{\r\nstruct ieee80211_txb *txb;\r\nint i;\r\ntxb = kmalloc(\r\nsizeof(struct ieee80211_txb) + (sizeof(u8*) * nr_frags),\r\ngfp_mask);\r\nif (!txb)\r\nreturn NULL;\r\nmemset(txb, 0, sizeof(struct ieee80211_txb));\r\ntxb->nr_frags = nr_frags;\r\ntxb->frag_size = txb_size;\r\nfor (i = 0; i < nr_frags; i++) {\r\ntxb->fragments[i] = dev_alloc_skb(txb_size);\r\nif (unlikely(!txb->fragments[i])) {\r\ni--;\r\nbreak;\r\n}\r\nmemset(txb->fragments[i]->cb, 0, sizeof(txb->fragments[i]->cb));\r\n}\r\nif (unlikely(i != nr_frags)) {\r\nwhile (i >= 0)\r\ndev_kfree_skb_any(txb->fragments[i--]);\r\nkfree(txb);\r\nreturn NULL;\r\n}\r\nreturn txb;\r\n}\r\nstatic int\r\nieee80211_classify(struct sk_buff *skb, struct ieee80211_network *network)\r\n{\r\nstruct ethhdr *eth;\r\nstruct iphdr *ip;\r\neth = (struct ethhdr *)skb->data;\r\nif (eth->h_proto != htons(ETH_P_IP))\r\nreturn 0;\r\nip = ip_hdr(skb);\r\nswitch (ip->tos & 0xfc) {\r\ncase 0x20:\r\nreturn 2;\r\ncase 0x40:\r\nreturn 1;\r\ncase 0x60:\r\nreturn 3;\r\ncase 0x80:\r\nreturn 4;\r\ncase 0xa0:\r\nreturn 5;\r\ncase 0xc0:\r\nreturn 6;\r\ncase 0xe0:\r\nreturn 7;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nvoid ieee80211_tx_query_agg_cap(struct ieee80211_device* ieee, struct sk_buff* skb, cb_desc* tcb_desc)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nPTX_TS_RECORD pTxTs = NULL;\r\nstruct ieee80211_hdr_1addr* hdr = (struct ieee80211_hdr_1addr*)skb->data;\r\nif (!pHTInfo->bCurrentHTSupport||!pHTInfo->bEnableHT)\r\nreturn;\r\nif (!IsQoSDataFrame(skb->data))\r\nreturn;\r\nif (is_multicast_ether_addr(hdr->addr1))\r\nreturn;\r\n#ifdef TO_DO_LIST\r\nif(pTcb->PacketLength >= 4096)\r\nreturn;\r\nif(!Adapter->HalFunc.GetNmodeSupportBySecCfgHandler(Adapter))\r\nreturn;\r\n#endif\r\nif(!ieee->GetNmodeSupportBySecCfg(ieee->dev))\r\n{\r\nreturn;\r\n}\r\nif(pHTInfo->bCurrentAMPDUEnable)\r\n{\r\nif (!GetTs(ieee, (PTS_COMMON_INFO*)(&pTxTs), hdr->addr1, skb->priority, TX_DIR, true))\r\n{\r\nprintk("===>can't get TS\n");\r\nreturn;\r\n}\r\nif (pTxTs->TxAdmittedBARecord.bValid == false)\r\n{\r\nTsStartAddBaProcess(ieee, pTxTs);\r\ngoto FORCED_AGG_SETTING;\r\n}\r\nelse if (pTxTs->bUsingBa == false)\r\n{\r\nif (SN_LESS(pTxTs->TxAdmittedBARecord.BaStartSeqCtrl.field.SeqNum, (pTxTs->TxCurSeq+1)%4096))\r\npTxTs->bUsingBa = true;\r\nelse\r\ngoto FORCED_AGG_SETTING;\r\n}\r\nif (ieee->iw_mode == IW_MODE_INFRA)\r\n{\r\ntcb_desc->bAMPDUEnable = true;\r\ntcb_desc->ampdu_factor = pHTInfo->CurrentAMPDUFactor;\r\ntcb_desc->ampdu_density = pHTInfo->CurrentMPDUDensity;\r\n}\r\n}\r\nFORCED_AGG_SETTING:\r\nswitch(pHTInfo->ForcedAMPDUMode )\r\n{\r\ncase HT_AGG_AUTO:\r\nbreak;\r\ncase HT_AGG_FORCE_ENABLE:\r\ntcb_desc->bAMPDUEnable = true;\r\ntcb_desc->ampdu_density = pHTInfo->ForcedMPDUDensity;\r\ntcb_desc->ampdu_factor = pHTInfo->ForcedAMPDUFactor;\r\nbreak;\r\ncase HT_AGG_FORCE_DISABLE:\r\ntcb_desc->bAMPDUEnable = false;\r\ntcb_desc->ampdu_density = 0;\r\ntcb_desc->ampdu_factor = 0;\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nextern void ieee80211_qurey_ShortPreambleMode(struct ieee80211_device* ieee, cb_desc* tcb_desc)\r\n{\r\ntcb_desc->bUseShortPreamble = false;\r\nif (tcb_desc->data_rate == 2)\r\n{\r\nreturn;\r\n}\r\nelse if (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\r\n{\r\ntcb_desc->bUseShortPreamble = true;\r\n}\r\nreturn;\r\n}\r\nextern void\r\nieee80211_query_HTCapShortGI(struct ieee80211_device *ieee, cb_desc *tcb_desc)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\ntcb_desc->bUseShortGI = false;\r\nif(!pHTInfo->bCurrentHTSupport||!pHTInfo->bEnableHT)\r\nreturn;\r\nif(pHTInfo->bForcedShortGI)\r\n{\r\ntcb_desc->bUseShortGI = true;\r\nreturn;\r\n}\r\nif((pHTInfo->bCurBW40MHz==true) && pHTInfo->bCurShortGI40MHz)\r\ntcb_desc->bUseShortGI = true;\r\nelse if((pHTInfo->bCurBW40MHz==false) && pHTInfo->bCurShortGI20MHz)\r\ntcb_desc->bUseShortGI = true;\r\n}\r\nvoid ieee80211_query_BandwidthMode(struct ieee80211_device* ieee, cb_desc *tcb_desc)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\ntcb_desc->bPacketBW = false;\r\nif(!pHTInfo->bCurrentHTSupport||!pHTInfo->bEnableHT)\r\nreturn;\r\nif(tcb_desc->bMulticast || tcb_desc->bBroadcast)\r\nreturn;\r\nif((tcb_desc->data_rate & 0x80)==0)\r\nreturn;\r\nif(pHTInfo->bCurBW40MHz && pHTInfo->bCurTxBW40MHz && !ieee->bandwidth_auto_switch.bforced_tx20Mhz)\r\ntcb_desc->bPacketBW = true;\r\nreturn;\r\n}\r\nvoid ieee80211_query_protectionmode(struct ieee80211_device* ieee, cb_desc* tcb_desc, struct sk_buff* skb)\r\n{\r\ntcb_desc->bRTSSTBC = false;\r\ntcb_desc->bRTSUseShortGI = false;\r\ntcb_desc->bCTSEnable = false;\r\ntcb_desc->RTSSC = 0;\r\ntcb_desc->bRTSBW = false;\r\nif(tcb_desc->bBroadcast || tcb_desc->bMulticast)\r\nreturn;\r\nif (is_broadcast_ether_addr(skb->data+16))\r\nreturn;\r\nif (ieee->mode < IEEE_N_24G)\r\n{\r\nif (skb->len > ieee->rts)\r\n{\r\ntcb_desc->bRTSEnable = true;\r\ntcb_desc->rts_rate = MGN_24M;\r\n}\r\nelse if (ieee->current_network.buseprotection)\r\n{\r\ntcb_desc->bRTSEnable = true;\r\ntcb_desc->bCTSEnable = true;\r\ntcb_desc->rts_rate = MGN_24M;\r\n}\r\nreturn;\r\n}\r\nelse\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nwhile (true)\r\n{\r\nif (ieee->current_network.buseprotection)\r\n{\r\ntcb_desc->bRTSEnable = true;\r\ntcb_desc->bCTSEnable = true;\r\ntcb_desc->rts_rate = MGN_24M;\r\nbreak;\r\n}\r\nif(pHTInfo->bCurrentHTSupport && pHTInfo->bEnableHT)\r\n{\r\nu8 HTOpMode = pHTInfo->CurrentOpMode;\r\nif((pHTInfo->bCurBW40MHz && (HTOpMode == 2 || HTOpMode == 3)) ||\r\n(!pHTInfo->bCurBW40MHz && HTOpMode == 3) )\r\n{\r\ntcb_desc->rts_rate = MGN_24M;\r\ntcb_desc->bRTSEnable = true;\r\nbreak;\r\n}\r\n}\r\nif (skb->len > ieee->rts)\r\n{\r\ntcb_desc->rts_rate = MGN_24M;\r\ntcb_desc->bRTSEnable = true;\r\nbreak;\r\n}\r\nif(tcb_desc->bAMPDUEnable)\r\n{\r\ntcb_desc->rts_rate = MGN_24M;\r\ntcb_desc->bRTSEnable = false;\r\nbreak;\r\n}\r\nif(pHTInfo->IOTAction & HT_IOT_ACT_FORCED_CTS2SELF)\r\n{\r\ntcb_desc->bCTSEnable = true;\r\ntcb_desc->rts_rate = MGN_24M;\r\ntcb_desc->bRTSEnable = true;\r\nbreak;\r\n}\r\ngoto NO_PROTECTION;\r\n}\r\n}\r\nif( 0 )\r\n{\r\ntcb_desc->bCTSEnable = true;\r\ntcb_desc->rts_rate = MGN_24M;\r\ntcb_desc->bRTSEnable = true;\r\n}\r\nif (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\r\ntcb_desc->bUseShortPreamble = true;\r\nif (ieee->mode == IW_MODE_MASTER)\r\ngoto NO_PROTECTION;\r\nreturn;\r\nNO_PROTECTION:\r\ntcb_desc->bRTSEnable = false;\r\ntcb_desc->bCTSEnable = false;\r\ntcb_desc->rts_rate = 0;\r\ntcb_desc->RTSSC = 0;\r\ntcb_desc->bRTSBW = false;\r\n}\r\nvoid ieee80211_txrate_selectmode(struct ieee80211_device* ieee, cb_desc* tcb_desc)\r\n{\r\n#ifdef TO_DO_LIST\r\nif(!IsDataFrame(pFrame))\r\n{\r\npTcb->bTxDisableRateFallBack = TRUE;\r\npTcb->bTxUseDriverAssingedRate = TRUE;\r\npTcb->RATRIndex = 7;\r\nreturn;\r\n}\r\nif(pMgntInfo->ForcedDataRate!= 0)\r\n{\r\npTcb->bTxDisableRateFallBack = TRUE;\r\npTcb->bTxUseDriverAssingedRate = TRUE;\r\nreturn;\r\n}\r\n#endif\r\nif(ieee->bTxDisableRateFallBack)\r\ntcb_desc->bTxDisableRateFallBack = true;\r\nif(ieee->bTxUseDriverAssingedRate)\r\ntcb_desc->bTxUseDriverAssingedRate = true;\r\nif(!tcb_desc->bTxDisableRateFallBack || !tcb_desc->bTxUseDriverAssingedRate)\r\n{\r\nif (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC)\r\ntcb_desc->RATRIndex = 0;\r\n}\r\n}\r\nvoid ieee80211_query_seqnum(struct ieee80211_device*ieee, struct sk_buff* skb, u8* dst)\r\n{\r\nif (is_multicast_ether_addr(dst))\r\nreturn;\r\nif (IsQoSDataFrame(skb->data))\r\n{\r\nPTX_TS_RECORD pTS = NULL;\r\nif (!GetTs(ieee, (PTS_COMMON_INFO*)(&pTS), dst, skb->priority, TX_DIR, true))\r\n{\r\nreturn;\r\n}\r\npTS->TxCurSeq = (pTS->TxCurSeq+1)%4096;\r\n}\r\n}\r\nint ieee80211_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ieee80211_device *ieee = netdev_priv(dev);\r\nstruct ieee80211_txb *txb = NULL;\r\nstruct ieee80211_hdr_3addrqos *frag_hdr;\r\nint i, bytes_per_frag, nr_frags, bytes_last_frag, frag_size;\r\nunsigned long flags;\r\nstruct net_device_stats *stats = &ieee->stats;\r\nint ether_type = 0, encrypt;\r\nint bytes, fc, qos_ctl = 0, hdr_len;\r\nstruct sk_buff *skb_frag;\r\nstruct ieee80211_hdr_3addrqos header = {\r\n.duration_id = 0,\r\n.seq_ctl = 0,\r\n.qos_ctl = 0\r\n};\r\nu8 dest[ETH_ALEN], src[ETH_ALEN];\r\nint qos_actived = ieee->current_network.qos_data.active;\r\nstruct ieee80211_crypt_data* crypt;\r\ncb_desc *tcb_desc;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif ((!ieee->hard_start_xmit && !(ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE))||\r\n((!ieee->softmac_data_hard_start_xmit && (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)))) {\r\nprintk(KERN_WARNING "%s: No xmit handler.\n",\r\nieee->dev->name);\r\ngoto success;\r\n}\r\nif(likely(ieee->raw_tx == 0)){\r\nif (unlikely(skb->len < SNAP_SIZE + sizeof(u16))) {\r\nprintk(KERN_WARNING "%s: skb too small (%d).\n",\r\nieee->dev->name, skb->len);\r\ngoto success;\r\n}\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nether_type = ntohs(((struct ethhdr *)skb->data)->h_proto);\r\ncrypt = ieee->crypt[ieee->tx_keyidx];\r\nencrypt = !(ether_type == ETH_P_PAE && ieee->ieee802_1x) &&\r\nieee->host_encrypt && crypt && crypt->ops;\r\nif (!encrypt && ieee->ieee802_1x &&\r\nieee->drop_unencrypted && ether_type != ETH_P_PAE) {\r\nstats->tx_dropped++;\r\ngoto success;\r\n}\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\nif (crypt && !encrypt && ether_type == ETH_P_PAE) {\r\nstruct eapol *eap = (struct eapol *)(skb->data +\r\nsizeof(struct ethhdr) - SNAP_SIZE - sizeof(u16));\r\nIEEE80211_DEBUG_EAP("TX: IEEE 802.11 EAPOL frame: %s\n",\r\neap_get_type(eap->type));\r\n}\r\n#endif\r\nmemcpy(&dest, skb->data, ETH_ALEN);\r\nmemcpy(&src, skb->data+ETH_ALEN, ETH_ALEN);\r\nskb_pull(skb, sizeof(struct ethhdr));\r\nbytes = skb->len + SNAP_SIZE + sizeof(u16);\r\nif (encrypt)\r\nfc = IEEE80211_FTYPE_DATA | IEEE80211_FCTL_WEP;\r\nelse\r\nfc = IEEE80211_FTYPE_DATA;\r\nif(qos_actived)\r\nfc |= IEEE80211_STYPE_QOS_DATA;\r\nelse\r\nfc |= IEEE80211_STYPE_DATA;\r\nif (ieee->iw_mode == IW_MODE_INFRA) {\r\nfc |= IEEE80211_FCTL_TODS;\r\nmemcpy(&header.addr1, ieee->current_network.bssid, ETH_ALEN);\r\nmemcpy(&header.addr2, &src, ETH_ALEN);\r\nmemcpy(&header.addr3, &dest, ETH_ALEN);\r\n} else if (ieee->iw_mode == IW_MODE_ADHOC) {\r\nmemcpy(&header.addr1, dest, ETH_ALEN);\r\nmemcpy(&header.addr2, src, ETH_ALEN);\r\nmemcpy(&header.addr3, ieee->current_network.bssid, ETH_ALEN);\r\n}\r\nheader.frame_ctl = cpu_to_le16(fc);\r\nif (is_multicast_ether_addr(header.addr1)) {\r\nfrag_size = MAX_FRAG_THRESHOLD;\r\nqos_ctl |= QOS_CTL_NOTCONTAIN_ACK;\r\n}\r\nelse {\r\nfrag_size = ieee->fts;\r\nqos_ctl = 0;\r\n}\r\nif(qos_actived)\r\n{\r\nhdr_len = IEEE80211_3ADDR_LEN + 2;\r\nskb->priority = ieee80211_classify(skb, &ieee->current_network);\r\nqos_ctl |= skb->priority;\r\nheader.qos_ctl = cpu_to_le16(qos_ctl & IEEE80211_QOS_TID);\r\n} else {\r\nhdr_len = IEEE80211_3ADDR_LEN;\r\n}\r\nbytes_per_frag = frag_size - hdr_len;\r\nif (ieee->config &\r\n(CFG_IEEE80211_COMPUTE_FCS | CFG_IEEE80211_RESERVE_FCS))\r\nbytes_per_frag -= IEEE80211_FCS_LEN;\r\nif (encrypt)\r\nbytes_per_frag -= crypt->ops->extra_prefix_len +\r\ncrypt->ops->extra_postfix_len;\r\nnr_frags = bytes / bytes_per_frag;\r\nbytes_last_frag = bytes % bytes_per_frag;\r\nif (bytes_last_frag)\r\nnr_frags++;\r\nelse\r\nbytes_last_frag = bytes_per_frag;\r\ntxb = ieee80211_alloc_txb(nr_frags, frag_size + ieee->tx_headroom, GFP_ATOMIC);\r\nif (unlikely(!txb)) {\r\nprintk(KERN_WARNING "%s: Could not allocate TXB\n",\r\nieee->dev->name);\r\ngoto failed;\r\n}\r\ntxb->encrypted = encrypt;\r\ntxb->payload_size = bytes;\r\nif(qos_actived)\r\n{\r\ntxb->queue_index = UP2AC(skb->priority);\r\n} else {\r\ntxb->queue_index = WME_AC_BK;\r\n}\r\nfor (i = 0; i < nr_frags; i++) {\r\nskb_frag = txb->fragments[i];\r\ntcb_desc = (cb_desc *)(skb_frag->cb + MAX_DEV_ADDR_SIZE);\r\nif(qos_actived){\r\nskb_frag->priority = skb->priority;\r\ntcb_desc->queue_index = UP2AC(skb->priority);\r\n} else {\r\nskb_frag->priority = WME_AC_BK;\r\ntcb_desc->queue_index = WME_AC_BK;\r\n}\r\nskb_reserve(skb_frag, ieee->tx_headroom);\r\nif (encrypt){\r\nif (ieee->hwsec_active)\r\ntcb_desc->bHwSec = 1;\r\nelse\r\ntcb_desc->bHwSec = 0;\r\nskb_reserve(skb_frag, crypt->ops->extra_prefix_len);\r\n}\r\nelse\r\n{\r\ntcb_desc->bHwSec = 0;\r\n}\r\nfrag_hdr = (struct ieee80211_hdr_3addrqos *)skb_put(skb_frag, hdr_len);\r\nmemcpy(frag_hdr, &header, hdr_len);\r\nif (i != nr_frags - 1) {\r\nfrag_hdr->frame_ctl = cpu_to_le16(\r\nfc | IEEE80211_FCTL_MOREFRAGS);\r\nbytes = bytes_per_frag;\r\n} else {\r\nbytes = bytes_last_frag;\r\n}\r\nif(qos_actived)\r\n{\r\nfrag_hdr->seq_ctl = cpu_to_le16(ieee->seq_ctrl[UP2AC(skb->priority)+1]<<4 | i);\r\n} else {\r\nfrag_hdr->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0]<<4 | i);\r\n}\r\nif (i == 0) {\r\nieee80211_put_snap(\r\nskb_put(skb_frag, SNAP_SIZE + sizeof(u16)),\r\nether_type);\r\nbytes -= SNAP_SIZE + sizeof(u16);\r\n}\r\nmemcpy(skb_put(skb_frag, bytes), skb->data, bytes);\r\nskb_pull(skb, bytes);\r\nif (encrypt)\r\nieee80211_encrypt_fragment(ieee, skb_frag, hdr_len);\r\nif (ieee->config &\r\n(CFG_IEEE80211_COMPUTE_FCS | CFG_IEEE80211_RESERVE_FCS))\r\nskb_put(skb_frag, 4);\r\n}\r\nif(qos_actived)\r\n{\r\nif (ieee->seq_ctrl[UP2AC(skb->priority) + 1] == 0xFFF)\r\nieee->seq_ctrl[UP2AC(skb->priority) + 1] = 0;\r\nelse\r\nieee->seq_ctrl[UP2AC(skb->priority) + 1]++;\r\n} else {\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\n}\r\n}else{\r\nif (unlikely(skb->len < sizeof(struct ieee80211_hdr_3addr))) {\r\nprintk(KERN_WARNING "%s: skb too small (%d).\n",\r\nieee->dev->name, skb->len);\r\ngoto success;\r\n}\r\ntxb = ieee80211_alloc_txb(1, skb->len, GFP_ATOMIC);\r\nif(!txb){\r\nprintk(KERN_WARNING "%s: Could not allocate TXB\n",\r\nieee->dev->name);\r\ngoto failed;\r\n}\r\ntxb->encrypted = 0;\r\ntxb->payload_size = skb->len;\r\nmemcpy(skb_put(txb->fragments[0],skb->len), skb->data, skb->len);\r\n}\r\nsuccess:\r\nif (txb)\r\n{\r\ncb_desc *tcb_desc = (cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);\r\ntcb_desc->bTxEnableFwCalcDur = 1;\r\nif (is_multicast_ether_addr(header.addr1))\r\ntcb_desc->bMulticast = 1;\r\nif (is_broadcast_ether_addr(header.addr1))\r\ntcb_desc->bBroadcast = 1;\r\nieee80211_txrate_selectmode(ieee, tcb_desc);\r\nif ( tcb_desc->bMulticast || tcb_desc->bBroadcast)\r\ntcb_desc->data_rate = ieee->basic_rate;\r\nelse\r\ntcb_desc->data_rate = CURRENT_RATE(ieee->mode, ieee->rate, ieee->HTCurrentOperaRate);\r\nieee80211_qurey_ShortPreambleMode(ieee, tcb_desc);\r\nieee80211_tx_query_agg_cap(ieee, txb->fragments[0], tcb_desc);\r\nieee80211_query_HTCapShortGI(ieee, tcb_desc);\r\nieee80211_query_BandwidthMode(ieee, tcb_desc);\r\nieee80211_query_protectionmode(ieee, tcb_desc, txb->fragments[0]);\r\nieee80211_query_seqnum(ieee, txb->fragments[0], header.addr1);\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\ndev_kfree_skb_any(skb);\r\nif (txb) {\r\nif (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE){\r\nieee80211_softmac_xmit(txb, ieee);\r\n}else{\r\nif ((*ieee->hard_start_xmit)(txb, dev) == 0) {\r\nstats->tx_packets++;\r\nstats->tx_bytes += txb->payload_size;\r\nreturn 0;\r\n}\r\nieee80211_txb_free(txb);\r\n}\r\n}\r\nreturn 0;\r\nfailed:\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nnetif_stop_queue(dev);\r\nstats->tx_errors++;\r\nreturn 1;\r\n}
