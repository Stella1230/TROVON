static int cpufreq_p4_setdc(unsigned int cpu, unsigned int newstate)\r\n{\r\nu32 l, h;\r\nif (!cpu_online(cpu) ||\r\n(newstate > DC_DISABLE) || (newstate == DC_RESV))\r\nreturn -EINVAL;\r\nrdmsr_on_cpu(cpu, MSR_IA32_THERM_STATUS, &l, &h);\r\nif (l & 0x01)\r\npr_debug("CPU#%d currently thermal throttled\n", cpu);\r\nif (has_N44_O17_errata[cpu] &&\r\n(newstate == DC_25PT || newstate == DC_DFLT))\r\nnewstate = DC_38PT;\r\nrdmsr_on_cpu(cpu, MSR_IA32_THERM_CONTROL, &l, &h);\r\nif (newstate == DC_DISABLE) {\r\npr_debug("CPU#%d disabling modulation\n", cpu);\r\nwrmsr_on_cpu(cpu, MSR_IA32_THERM_CONTROL, l & ~(1<<4), h);\r\n} else {\r\npr_debug("CPU#%d setting duty cycle to %d%%\n",\r\ncpu, ((125 * newstate) / 10));\r\nl = (l & ~14);\r\nl = l | (1<<4) | ((newstate & 0x7)<<1);\r\nwrmsr_on_cpu(cpu, MSR_IA32_THERM_CONTROL, l, h);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cpufreq_p4_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nunsigned int newstate = DC_RESV;\r\nstruct cpufreq_freqs freqs;\r\nint i;\r\nif (cpufreq_frequency_table_target(policy, &p4clockmod_table[0],\r\ntarget_freq, relation, &newstate))\r\nreturn -EINVAL;\r\nfreqs.old = cpufreq_p4_get(policy->cpu);\r\nfreqs.new = stock_freq * p4clockmod_table[newstate].index / 8;\r\nif (freqs.new == freqs.old)\r\nreturn 0;\r\nfor_each_cpu(i, policy->cpus) {\r\nfreqs.cpu = i;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\n}\r\nfor_each_cpu(i, policy->cpus)\r\ncpufreq_p4_setdc(i, p4clockmod_table[newstate].index);\r\nfor_each_cpu(i, policy->cpus) {\r\nfreqs.cpu = i;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cpufreq_p4_verify(struct cpufreq_policy *policy)\r\n{\r\nreturn cpufreq_frequency_table_verify(policy, &p4clockmod_table[0]);\r\n}\r\nstatic unsigned int cpufreq_p4_get_frequency(struct cpuinfo_x86 *c)\r\n{\r\nif (c->x86 == 0x06) {\r\nif (cpu_has(c, X86_FEATURE_EST))\r\nprintk_once(KERN_WARNING PFX "Warning: EST-capable "\r\n"CPU detected. The acpi-cpufreq module offers "\r\n"voltage scaling in addition to frequency "\r\n"scaling. You should use that instead of "\r\n"p4-clockmod, if possible.\n");\r\nswitch (c->x86_model) {\r\ncase 0x0E:\r\ncase 0x0F:\r\ncase 0x16:\r\ncase 0x1C:\r\np4clockmod_driver.flags |= CPUFREQ_CONST_LOOPS;\r\nreturn speedstep_get_frequency(SPEEDSTEP_CPU_PCORE);\r\ncase 0x0D:\r\np4clockmod_driver.flags |= CPUFREQ_CONST_LOOPS;\r\ncase 0x09:\r\nreturn speedstep_get_frequency(SPEEDSTEP_CPU_PM);\r\n}\r\n}\r\nif (c->x86 != 0xF)\r\nreturn 0;\r\np4clockmod_driver.flags |= CPUFREQ_CONST_LOOPS;\r\nif (speedstep_detect_processor() == SPEEDSTEP_CPU_P4M) {\r\nprintk(KERN_WARNING PFX "Warning: Pentium 4-M detected. "\r\n"The speedstep-ich or acpi cpufreq modules offer "\r\n"voltage scaling in addition of frequency scaling. "\r\n"You should use either one instead of p4-clockmod, "\r\n"if possible.\n");\r\nreturn speedstep_get_frequency(SPEEDSTEP_CPU_P4M);\r\n}\r\nreturn speedstep_get_frequency(SPEEDSTEP_CPU_P4D);\r\n}\r\nstatic int cpufreq_p4_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(policy->cpu);\r\nint cpuid = 0;\r\nunsigned int i;\r\n#ifdef CONFIG_SMP\r\ncpumask_copy(policy->cpus, cpu_sibling_mask(policy->cpu));\r\n#endif\r\ncpuid = (c->x86 << 8) | (c->x86_model << 4) | c->x86_mask;\r\nswitch (cpuid) {\r\ncase 0x0f07:\r\ncase 0x0f0a:\r\ncase 0x0f11:\r\ncase 0x0f12:\r\nhas_N44_O17_errata[policy->cpu] = 1;\r\npr_debug("has errata -- disabling low frequencies\n");\r\n}\r\nif (speedstep_detect_processor() == SPEEDSTEP_CPU_P4D &&\r\nc->x86_model < 2) {\r\ncpufreq_p4_setdc(policy->cpu, DC_DISABLE);\r\nrecalibrate_cpu_khz();\r\n}\r\nstock_freq = cpufreq_p4_get_frequency(c);\r\nif (!stock_freq)\r\nreturn -EINVAL;\r\nfor (i = 1; (p4clockmod_table[i].frequency != CPUFREQ_TABLE_END); i++) {\r\nif ((i < 2) && (has_N44_O17_errata[policy->cpu]))\r\np4clockmod_table[i].frequency = CPUFREQ_ENTRY_INVALID;\r\nelse\r\np4clockmod_table[i].frequency = (stock_freq * i)/8;\r\n}\r\ncpufreq_frequency_table_get_attr(p4clockmod_table, policy->cpu);\r\npolicy->cpuinfo.transition_latency = 10000001;\r\npolicy->cur = stock_freq;\r\nreturn cpufreq_frequency_table_cpuinfo(policy, &p4clockmod_table[0]);\r\n}\r\nstatic int cpufreq_p4_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\ncpufreq_frequency_table_put_attr(policy->cpu);\r\nreturn 0;\r\n}\r\nstatic unsigned int cpufreq_p4_get(unsigned int cpu)\r\n{\r\nu32 l, h;\r\nrdmsr_on_cpu(cpu, MSR_IA32_THERM_CONTROL, &l, &h);\r\nif (l & 0x10) {\r\nl = l >> 1;\r\nl &= 0x7;\r\n} else\r\nl = DC_DISABLE;\r\nif (l != DC_DISABLE)\r\nreturn stock_freq * l / 8;\r\nreturn stock_freq;\r\n}\r\nstatic int __init cpufreq_p4_init(void)\r\n{\r\nint ret;\r\nif (!x86_match_cpu(cpufreq_p4_id) || !boot_cpu_has(X86_FEATURE_ACPI))\r\nreturn -ENODEV;\r\nret = cpufreq_register_driver(&p4clockmod_driver);\r\nif (!ret)\r\nprintk(KERN_INFO PFX "P4/Xeon(TM) CPU On-Demand Clock "\r\n"Modulation available\n");\r\nreturn ret;\r\n}\r\nstatic void __exit cpufreq_p4_exit(void)\r\n{\r\ncpufreq_unregister_driver(&p4clockmod_driver);\r\n}
