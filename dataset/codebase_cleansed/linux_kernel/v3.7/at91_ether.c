static inline unsigned long at91_emac_read(struct at91_private *lp, unsigned int reg)\r\n{\r\nreturn __raw_readl(lp->emac_base + reg);\r\n}\r\nstatic inline void at91_emac_write(struct at91_private *lp, unsigned int reg, unsigned long value)\r\n{\r\n__raw_writel(value, lp->emac_base + reg);\r\n}\r\nstatic void enable_mdi(struct at91_private *lp)\r\n{\r\nunsigned long ctl;\r\nctl = at91_emac_read(lp, AT91_EMAC_CTL);\r\nat91_emac_write(lp, AT91_EMAC_CTL, ctl | AT91_EMAC_MPE);\r\n}\r\nstatic void disable_mdi(struct at91_private *lp)\r\n{\r\nunsigned long ctl;\r\nctl = at91_emac_read(lp, AT91_EMAC_CTL);\r\nat91_emac_write(lp, AT91_EMAC_CTL, ctl & ~AT91_EMAC_MPE);\r\n}\r\nstatic inline void at91_phy_wait(struct at91_private *lp)\r\n{\r\nunsigned long timeout = jiffies + 2;\r\nwhile (!(at91_emac_read(lp, AT91_EMAC_SR) & AT91_EMAC_SR_IDLE)) {\r\nif (time_after(jiffies, timeout)) {\r\nprintk("at91_ether: MIO timeout\n");\r\nbreak;\r\n}\r\ncpu_relax();\r\n}\r\n}\r\nstatic void write_phy(struct at91_private *lp, unsigned char phy_addr, unsigned char address, unsigned int value)\r\n{\r\nat91_emac_write(lp, AT91_EMAC_MAN, AT91_EMAC_MAN_802_3 | AT91_EMAC_RW_W\r\n| ((phy_addr & 0x1f) << 23) | (address << 18) | (value & AT91_EMAC_DATA));\r\nat91_phy_wait(lp);\r\n}\r\nstatic void read_phy(struct at91_private *lp, unsigned char phy_addr, unsigned char address, unsigned int *value)\r\n{\r\nat91_emac_write(lp, AT91_EMAC_MAN, AT91_EMAC_MAN_802_3 | AT91_EMAC_RW_R\r\n| ((phy_addr & 0x1f) << 23) | (address << 18));\r\nat91_phy_wait(lp);\r\n*value = at91_emac_read(lp, AT91_EMAC_MAN) & AT91_EMAC_DATA;\r\n}\r\nstatic void update_linkspeed(struct net_device *dev, int silent)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nunsigned int bmsr, bmcr, lpa, mac_cfg;\r\nunsigned int speed, duplex;\r\nif (!mii_link_ok(&lp->mii)) {\r\nnetif_carrier_off(dev);\r\nif (!silent)\r\nprintk(KERN_INFO "%s: Link down.\n", dev->name);\r\nreturn;\r\n}\r\nread_phy(lp, lp->phy_address, MII_BMSR, &bmsr);\r\nread_phy(lp, lp->phy_address, MII_BMCR, &bmcr);\r\nif (bmcr & BMCR_ANENABLE) {\r\nif (!(bmsr & BMSR_ANEGCOMPLETE))\r\nreturn;\r\nread_phy(lp, lp->phy_address, MII_LPA, &lpa);\r\nif ((lpa & LPA_100FULL) || (lpa & LPA_100HALF)) speed = SPEED_100;\r\nelse speed = SPEED_10;\r\nif ((lpa & LPA_100FULL) || (lpa & LPA_10FULL)) duplex = DUPLEX_FULL;\r\nelse duplex = DUPLEX_HALF;\r\n} else {\r\nspeed = (bmcr & BMCR_SPEED100) ? SPEED_100 : SPEED_10;\r\nduplex = (bmcr & BMCR_FULLDPLX) ? DUPLEX_FULL : DUPLEX_HALF;\r\n}\r\nmac_cfg = at91_emac_read(lp, AT91_EMAC_CFG) & ~(AT91_EMAC_SPD | AT91_EMAC_FD);\r\nif (speed == SPEED_100) {\r\nif (duplex == DUPLEX_FULL)\r\nmac_cfg |= AT91_EMAC_SPD | AT91_EMAC_FD;\r\nelse\r\nmac_cfg |= AT91_EMAC_SPD;\r\n} else {\r\nif (duplex == DUPLEX_FULL)\r\nmac_cfg |= AT91_EMAC_FD;\r\nelse {}\r\n}\r\nat91_emac_write(lp, AT91_EMAC_CFG, mac_cfg);\r\nif (!silent)\r\nprintk(KERN_INFO "%s: Link now %i-%s\n", dev->name, speed, (duplex == DUPLEX_FULL) ? "FullDuplex" : "HalfDuplex");\r\nnetif_carrier_on(dev);\r\n}\r\nstatic irqreturn_t at91ether_phy_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_id;\r\nstruct at91_private *lp = netdev_priv(dev);\r\nunsigned int phy;\r\nenable_mdi(lp);\r\nif ((lp->phy_type == MII_DM9161_ID) || (lp->phy_type == MII_DM9161A_ID)) {\r\nread_phy(lp, lp->phy_address, MII_DSINTR_REG, &phy);\r\nif (!(phy & (1 << 0)))\r\ngoto done;\r\n}\r\nelse if (lp->phy_type == MII_LXT971A_ID) {\r\nread_phy(lp, lp->phy_address, MII_ISINTS_REG, &phy);\r\nif (!(phy & (1 << 2)))\r\ngoto done;\r\n}\r\nelse if (lp->phy_type == MII_BCM5221_ID) {\r\nread_phy(lp, lp->phy_address, MII_BCMINTR_REG, &phy);\r\nif (!(phy & (1 << 0)))\r\ngoto done;\r\n}\r\nelse if (lp->phy_type == MII_KS8721_ID) {\r\nread_phy(lp, lp->phy_address, MII_TPISTATUS, &phy);\r\nif (!(phy & ((1 << 2) | 1)))\r\ngoto done;\r\n}\r\nelse if (lp->phy_type == MII_T78Q21x3_ID) {\r\nread_phy(lp, lp->phy_address, MII_T78Q21INT_REG, &phy);\r\nif (!(phy & ((1 << 2) | 1)))\r\ngoto done;\r\n}\r\nelse if (lp->phy_type == MII_DP83848_ID) {\r\nread_phy(lp, lp->phy_address, MII_DPPHYSTS_REG, &phy);\r\nif (!(phy & (1 << 7)))\r\ngoto done;\r\n}\r\nupdate_linkspeed(dev, 0);\r\ndone:\r\ndisable_mdi(lp);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void enable_phyirq(struct net_device *dev)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nunsigned int dsintr, irq_number;\r\nint status;\r\nif (!gpio_is_valid(lp->board_data.phy_irq_pin)) {\r\nmod_timer(&lp->check_timer, jiffies + LINK_POLL_INTERVAL);\r\nreturn;\r\n}\r\nirq_number = gpio_to_irq(lp->board_data.phy_irq_pin);\r\nstatus = request_irq(irq_number, at91ether_phy_interrupt, 0, dev->name, dev);\r\nif (status) {\r\nprintk(KERN_ERR "at91_ether: PHY IRQ %d request failed - status %d!\n", irq_number, status);\r\nreturn;\r\n}\r\nspin_lock_irq(&lp->lock);\r\nenable_mdi(lp);\r\nif ((lp->phy_type == MII_DM9161_ID) || (lp->phy_type == MII_DM9161A_ID)) {\r\nread_phy(lp, lp->phy_address, MII_DSINTR_REG, &dsintr);\r\ndsintr = dsintr & ~0xf00;\r\nwrite_phy(lp, lp->phy_address, MII_DSINTR_REG, dsintr);\r\n}\r\nelse if (lp->phy_type == MII_LXT971A_ID) {\r\nread_phy(lp, lp->phy_address, MII_ISINTE_REG, &dsintr);\r\ndsintr = dsintr | 0xf2;\r\nwrite_phy(lp, lp->phy_address, MII_ISINTE_REG, dsintr);\r\n}\r\nelse if (lp->phy_type == MII_BCM5221_ID) {\r\ndsintr = (1 << 15) | ( 1 << 14);\r\nwrite_phy(lp, lp->phy_address, MII_BCMINTR_REG, dsintr);\r\n}\r\nelse if (lp->phy_type == MII_KS8721_ID) {\r\ndsintr = (1 << 10) | ( 1 << 8);\r\nwrite_phy(lp, lp->phy_address, MII_TPISTATUS, dsintr);\r\n}\r\nelse if (lp->phy_type == MII_T78Q21x3_ID) {\r\nread_phy(lp, lp->phy_address, MII_T78Q21INT_REG, &dsintr);\r\ndsintr = dsintr | 0x500;\r\nwrite_phy(lp, lp->phy_address, MII_T78Q21INT_REG, dsintr);\r\n}\r\nelse if (lp->phy_type == MII_DP83848_ID) {\r\nread_phy(lp, lp->phy_address, MII_DPMISR_REG, &dsintr);\r\ndsintr = dsintr | 0x3c;\r\nwrite_phy(lp, lp->phy_address, MII_DPMISR_REG, dsintr);\r\nread_phy(lp, lp->phy_address, MII_DPMICR_REG, &dsintr);\r\ndsintr = dsintr | 0x3;\r\nwrite_phy(lp, lp->phy_address, MII_DPMICR_REG, dsintr);\r\n}\r\ndisable_mdi(lp);\r\nspin_unlock_irq(&lp->lock);\r\n}\r\nstatic void disable_phyirq(struct net_device *dev)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nunsigned int dsintr;\r\nunsigned int irq_number;\r\nif (!gpio_is_valid(lp->board_data.phy_irq_pin)) {\r\ndel_timer_sync(&lp->check_timer);\r\nreturn;\r\n}\r\nspin_lock_irq(&lp->lock);\r\nenable_mdi(lp);\r\nif ((lp->phy_type == MII_DM9161_ID) || (lp->phy_type == MII_DM9161A_ID)) {\r\nread_phy(lp, lp->phy_address, MII_DSINTR_REG, &dsintr);\r\ndsintr = dsintr | 0xf00;\r\nwrite_phy(lp, lp->phy_address, MII_DSINTR_REG, dsintr);\r\n}\r\nelse if (lp->phy_type == MII_LXT971A_ID) {\r\nread_phy(lp, lp->phy_address, MII_ISINTE_REG, &dsintr);\r\ndsintr = dsintr & ~0xf2;\r\nwrite_phy(lp, lp->phy_address, MII_ISINTE_REG, dsintr);\r\n}\r\nelse if (lp->phy_type == MII_BCM5221_ID) {\r\nread_phy(lp, lp->phy_address, MII_BCMINTR_REG, &dsintr);\r\ndsintr = ~(1 << 14);\r\nwrite_phy(lp, lp->phy_address, MII_BCMINTR_REG, dsintr);\r\n}\r\nelse if (lp->phy_type == MII_KS8721_ID) {\r\nread_phy(lp, lp->phy_address, MII_TPISTATUS, &dsintr);\r\ndsintr = ~((1 << 10) | (1 << 8));\r\nwrite_phy(lp, lp->phy_address, MII_TPISTATUS, dsintr);\r\n}\r\nelse if (lp->phy_type == MII_T78Q21x3_ID) {\r\nread_phy(lp, lp->phy_address, MII_T78Q21INT_REG, &dsintr);\r\ndsintr = dsintr & ~0x500;\r\nwrite_phy(lp, lp->phy_address, MII_T78Q21INT_REG, dsintr);\r\n}\r\nelse if (lp->phy_type == MII_DP83848_ID) {\r\nread_phy(lp, lp->phy_address, MII_DPMICR_REG, &dsintr);\r\ndsintr = dsintr & ~0x3;\r\nwrite_phy(lp, lp->phy_address, MII_DPMICR_REG, dsintr);\r\nread_phy(lp, lp->phy_address, MII_DPMISR_REG, &dsintr);\r\ndsintr = dsintr & ~0x3c;\r\nwrite_phy(lp, lp->phy_address, MII_DPMISR_REG, dsintr);\r\n}\r\ndisable_mdi(lp);\r\nspin_unlock_irq(&lp->lock);\r\nirq_number = gpio_to_irq(lp->board_data.phy_irq_pin);\r\nfree_irq(irq_number, dev);\r\n}\r\nstatic void at91ether_check_link(unsigned long dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_id;\r\nstruct at91_private *lp = netdev_priv(dev);\r\nenable_mdi(lp);\r\nupdate_linkspeed(dev, 1);\r\ndisable_mdi(lp);\r\nmod_timer(&lp->check_timer, jiffies + LINK_POLL_INTERVAL);\r\n}\r\nstatic void __init initialize_phy(struct at91_private *lp)\r\n{\r\nunsigned int val;\r\nspin_lock_irq(&lp->lock);\r\nenable_mdi(lp);\r\nif ((lp->phy_type == MII_DM9161_ID) || (lp->phy_type == MII_DM9161A_ID)) {\r\nread_phy(lp, lp->phy_address, MII_DSCR_REG, &val);\r\nif ((val & (1 << 10)) == 0)\r\nlp->phy_media = PORT_FIBRE;\r\n} else if (machine_is_csb337()) {\r\nwrite_phy(lp, lp->phy_address, MII_LEDCTRL_REG, 0x0d22);\r\n} else if (machine_is_ecbat91())\r\nwrite_phy(lp, lp->phy_address, MII_LEDCTRL_REG, 0x156A);\r\ndisable_mdi(lp);\r\nspin_unlock_irq(&lp->lock);\r\n}\r\nstatic short __init unpack_mac_address(struct net_device *dev, unsigned int hi, unsigned int lo)\r\n{\r\nchar addr[6];\r\nif (machine_is_csb337()) {\r\naddr[5] = (lo & 0xff);\r\naddr[4] = (lo & 0xff00) >> 8;\r\naddr[3] = (lo & 0xff0000) >> 16;\r\naddr[2] = (lo & 0xff000000) >> 24;\r\naddr[1] = (hi & 0xff);\r\naddr[0] = (hi & 0xff00) >> 8;\r\n}\r\nelse {\r\naddr[0] = (lo & 0xff);\r\naddr[1] = (lo & 0xff00) >> 8;\r\naddr[2] = (lo & 0xff0000) >> 16;\r\naddr[3] = (lo & 0xff000000) >> 24;\r\naddr[4] = (hi & 0xff);\r\naddr[5] = (hi & 0xff00) >> 8;\r\n}\r\nif (is_valid_ether_addr(addr)) {\r\nmemcpy(dev->dev_addr, &addr, 6);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init get_mac_address(struct net_device *dev)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nif (unpack_mac_address(dev, at91_emac_read(lp, AT91_EMAC_SA1H), at91_emac_read(lp, AT91_EMAC_SA1L)))\r\nreturn;\r\nif (unpack_mac_address(dev, at91_emac_read(lp, AT91_EMAC_SA2H), at91_emac_read(lp, AT91_EMAC_SA2L)))\r\nreturn;\r\nif (unpack_mac_address(dev, at91_emac_read(lp, AT91_EMAC_SA3H), at91_emac_read(lp, AT91_EMAC_SA3L)))\r\nreturn;\r\nif (unpack_mac_address(dev, at91_emac_read(lp, AT91_EMAC_SA4H), at91_emac_read(lp, AT91_EMAC_SA4L)))\r\nreturn;\r\nprintk(KERN_ERR "at91_ether: Your bootloader did not configure a MAC address.\n");\r\n}\r\nstatic void update_mac_address(struct net_device *dev)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nat91_emac_write(lp, AT91_EMAC_SA1L, (dev->dev_addr[3] << 24) | (dev->dev_addr[2] << 16) | (dev->dev_addr[1] << 8) | (dev->dev_addr[0]));\r\nat91_emac_write(lp, AT91_EMAC_SA1H, (dev->dev_addr[5] << 8) | (dev->dev_addr[4]));\r\nat91_emac_write(lp, AT91_EMAC_SA2L, 0);\r\nat91_emac_write(lp, AT91_EMAC_SA2H, 0);\r\n}\r\nstatic int set_mac_address(struct net_device *dev, void* addr)\r\n{\r\nstruct sockaddr *address = addr;\r\nif (!is_valid_ether_addr(address->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, address->sa_data, dev->addr_len);\r\nupdate_mac_address(dev);\r\nprintk("%s: Setting MAC address to %pM\n", dev->name,\r\ndev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic int inline hash_bit_value(int bitnr, __u8 *addr)\r\n{\r\nif (addr[bitnr / 8] & (1 << (bitnr % 8)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int hash_get_index(__u8 *addr)\r\n{\r\nint i, j, bitval;\r\nint hash_index = 0;\r\nfor (j = 0; j < 6; j++) {\r\nfor (i = 0, bitval = 0; i < 8; i++)\r\nbitval ^= hash_bit_value(i*6 + j, addr);\r\nhash_index |= (bitval << j);\r\n}\r\nreturn hash_index;\r\n}\r\nstatic void at91ether_sethashtable(struct net_device *dev)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nunsigned long mc_filter[2];\r\nunsigned int bitnr;\r\nmc_filter[0] = mc_filter[1] = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nbitnr = hash_get_index(ha->addr);\r\nmc_filter[bitnr >> 5] |= 1 << (bitnr & 31);\r\n}\r\nat91_emac_write(lp, AT91_EMAC_HSL, mc_filter[0]);\r\nat91_emac_write(lp, AT91_EMAC_HSH, mc_filter[1]);\r\n}\r\nstatic void at91ether_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nunsigned long cfg;\r\ncfg = at91_emac_read(lp, AT91_EMAC_CFG);\r\nif (dev->flags & IFF_PROMISC)\r\ncfg |= AT91_EMAC_CAF;\r\nelse if (dev->flags & (~IFF_PROMISC))\r\ncfg &= ~AT91_EMAC_CAF;\r\nif (dev->flags & IFF_ALLMULTI) {\r\nat91_emac_write(lp, AT91_EMAC_HSH, -1);\r\nat91_emac_write(lp, AT91_EMAC_HSL, -1);\r\ncfg |= AT91_EMAC_MTI;\r\n} else if (!netdev_mc_empty(dev)) {\r\nat91ether_sethashtable(dev);\r\ncfg |= AT91_EMAC_MTI;\r\n} else if (dev->flags & (~IFF_ALLMULTI)) {\r\nat91_emac_write(lp, AT91_EMAC_HSH, 0);\r\nat91_emac_write(lp, AT91_EMAC_HSL, 0);\r\ncfg &= ~AT91_EMAC_MTI;\r\n}\r\nat91_emac_write(lp, AT91_EMAC_CFG, cfg);\r\n}\r\nstatic int mdio_read(struct net_device *dev, int phy_id, int location)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nunsigned int value;\r\nread_phy(lp, phy_id, location, &value);\r\nreturn value;\r\n}\r\nstatic void mdio_write(struct net_device *dev, int phy_id, int location, int value)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nwrite_phy(lp, phy_id, location, value);\r\n}\r\nstatic int at91ether_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nint ret;\r\nspin_lock_irq(&lp->lock);\r\nenable_mdi(lp);\r\nret = mii_ethtool_gset(&lp->mii, cmd);\r\ndisable_mdi(lp);\r\nspin_unlock_irq(&lp->lock);\r\nif (lp->phy_media == PORT_FIBRE) {\r\ncmd->supported = SUPPORTED_FIBRE;\r\ncmd->port = PORT_FIBRE;\r\n}\r\nreturn ret;\r\n}\r\nstatic int at91ether_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nint ret;\r\nspin_lock_irq(&lp->lock);\r\nenable_mdi(lp);\r\nret = mii_ethtool_sset(&lp->mii, cmd);\r\ndisable_mdi(lp);\r\nspin_unlock_irq(&lp->lock);\r\nreturn ret;\r\n}\r\nstatic int at91ether_nwayreset(struct net_device *dev)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nint ret;\r\nspin_lock_irq(&lp->lock);\r\nenable_mdi(lp);\r\nret = mii_nway_restart(&lp->mii);\r\ndisable_mdi(lp);\r\nspin_unlock_irq(&lp->lock);\r\nreturn ret;\r\n}\r\nstatic void at91ether_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, dev_name(dev->dev.parent), sizeof(info->bus_info));\r\n}\r\nstatic int at91ether_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nint res;\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nspin_lock_irq(&lp->lock);\r\nenable_mdi(lp);\r\nres = generic_mii_ioctl(&lp->mii, if_mii(rq), cmd, NULL);\r\ndisable_mdi(lp);\r\nspin_unlock_irq(&lp->lock);\r\nreturn res;\r\n}\r\nstatic void at91ether_start(struct net_device *dev)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nstruct recv_desc_bufs *dlist, *dlist_phys;\r\nint i;\r\nunsigned long ctl;\r\ndlist = lp->dlist;\r\ndlist_phys = lp->dlist_phys;\r\nfor (i = 0; i < MAX_RX_DESCR; i++) {\r\ndlist->descriptors[i].addr = (unsigned int) &dlist_phys->recv_buf[i][0];\r\ndlist->descriptors[i].size = 0;\r\n}\r\ndlist->descriptors[i-1].addr |= EMAC_DESC_WRAP;\r\nlp->rxBuffIndex = 0;\r\nat91_emac_write(lp, AT91_EMAC_RBQP, (unsigned long) dlist_phys);\r\nctl = at91_emac_read(lp, AT91_EMAC_CTL);\r\nat91_emac_write(lp, AT91_EMAC_CTL, ctl | AT91_EMAC_RE | AT91_EMAC_TE);\r\n}\r\nstatic int at91ether_open(struct net_device *dev)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nunsigned long ctl;\r\nif (!is_valid_ether_addr(dev->dev_addr))\r\nreturn -EADDRNOTAVAIL;\r\nclk_enable(lp->ether_clk);\r\nctl = at91_emac_read(lp, AT91_EMAC_CTL);\r\nat91_emac_write(lp, AT91_EMAC_CTL, ctl | AT91_EMAC_CSR);\r\nupdate_mac_address(dev);\r\nenable_phyirq(dev);\r\nat91_emac_write(lp, AT91_EMAC_IER, AT91_EMAC_RCOM | AT91_EMAC_RBNA\r\n| AT91_EMAC_TUND | AT91_EMAC_RTRY | AT91_EMAC_TCOM\r\n| AT91_EMAC_ROVR | AT91_EMAC_ABT);\r\nspin_lock_irq(&lp->lock);\r\nenable_mdi(lp);\r\nupdate_linkspeed(dev, 0);\r\ndisable_mdi(lp);\r\nspin_unlock_irq(&lp->lock);\r\nat91ether_start(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int at91ether_close(struct net_device *dev)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nunsigned long ctl;\r\nctl = at91_emac_read(lp, AT91_EMAC_CTL);\r\nat91_emac_write(lp, AT91_EMAC_CTL, ctl & ~(AT91_EMAC_TE | AT91_EMAC_RE));\r\ndisable_phyirq(dev);\r\nat91_emac_write(lp, AT91_EMAC_IDR, AT91_EMAC_RCOM | AT91_EMAC_RBNA\r\n| AT91_EMAC_TUND | AT91_EMAC_RTRY | AT91_EMAC_TCOM\r\n| AT91_EMAC_ROVR | AT91_EMAC_ABT);\r\nnetif_stop_queue(dev);\r\nclk_disable(lp->ether_clk);\r\nreturn 0;\r\n}\r\nstatic int at91ether_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nif (at91_emac_read(lp, AT91_EMAC_TSR) & AT91_EMAC_TSR_BNQ) {\r\nnetif_stop_queue(dev);\r\nlp->skb = skb;\r\nlp->skb_length = skb->len;\r\nlp->skb_physaddr = dma_map_single(NULL, skb->data, skb->len, DMA_TO_DEVICE);\r\ndev->stats.tx_bytes += skb->len;\r\nat91_emac_write(lp, AT91_EMAC_TAR, lp->skb_physaddr);\r\nat91_emac_write(lp, AT91_EMAC_TCR, skb->len);\r\n} else {\r\nprintk(KERN_ERR "at91_ether.c: at91ether_start_xmit() called, but device is busy!\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *at91ether_stats(struct net_device *dev)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nint ale, lenerr, seqe, lcol, ecol;\r\nif (netif_running(dev)) {\r\ndev->stats.rx_packets += at91_emac_read(lp, AT91_EMAC_OK);\r\nale = at91_emac_read(lp, AT91_EMAC_ALE);\r\ndev->stats.rx_frame_errors += ale;\r\nlenerr = at91_emac_read(lp, AT91_EMAC_ELR) + at91_emac_read(lp, AT91_EMAC_USF);\r\ndev->stats.rx_length_errors += lenerr;\r\nseqe = at91_emac_read(lp, AT91_EMAC_SEQE);\r\ndev->stats.rx_crc_errors += seqe;\r\ndev->stats.rx_fifo_errors += at91_emac_read(lp, AT91_EMAC_DRFC);\r\ndev->stats.rx_errors += (ale + lenerr + seqe\r\n+ at91_emac_read(lp, AT91_EMAC_CDE) + at91_emac_read(lp, AT91_EMAC_RJB));\r\ndev->stats.tx_packets += at91_emac_read(lp, AT91_EMAC_FRA);\r\ndev->stats.tx_fifo_errors += at91_emac_read(lp, AT91_EMAC_TUE);\r\ndev->stats.tx_carrier_errors += at91_emac_read(lp, AT91_EMAC_CSE);\r\ndev->stats.tx_heartbeat_errors += at91_emac_read(lp, AT91_EMAC_SQEE);\r\nlcol = at91_emac_read(lp, AT91_EMAC_LCOL);\r\necol = at91_emac_read(lp, AT91_EMAC_ECOL);\r\ndev->stats.tx_window_errors += lcol;\r\ndev->stats.tx_aborted_errors += ecol;\r\ndev->stats.collisions += (at91_emac_read(lp, AT91_EMAC_SCOL) + at91_emac_read(lp, AT91_EMAC_MCOL) + lcol + ecol);\r\n}\r\nreturn &dev->stats;\r\n}\r\nstatic void at91ether_rx(struct net_device *dev)\r\n{\r\nstruct at91_private *lp = netdev_priv(dev);\r\nstruct recv_desc_bufs *dlist;\r\nunsigned char *p_recv;\r\nstruct sk_buff *skb;\r\nunsigned int pktlen;\r\ndlist = lp->dlist;\r\nwhile (dlist->descriptors[lp->rxBuffIndex].addr & EMAC_DESC_DONE) {\r\np_recv = dlist->recv_buf[lp->rxBuffIndex];\r\npktlen = dlist->descriptors[lp->rxBuffIndex].size & 0x7ff;\r\nskb = netdev_alloc_skb(dev, pktlen + 2);\r\nif (skb != NULL) {\r\nskb_reserve(skb, 2);\r\nmemcpy(skb_put(skb, pktlen), p_recv, pktlen);\r\nskb->protocol = eth_type_trans(skb, dev);\r\ndev->stats.rx_bytes += pktlen;\r\nnetif_rx(skb);\r\n}\r\nelse {\r\ndev->stats.rx_dropped += 1;\r\nprintk(KERN_NOTICE "%s: Memory squeeze, dropping packet.\n", dev->name);\r\n}\r\nif (dlist->descriptors[lp->rxBuffIndex].size & EMAC_MULTICAST)\r\ndev->stats.multicast++;\r\ndlist->descriptors[lp->rxBuffIndex].addr &= ~EMAC_DESC_DONE;\r\nif (lp->rxBuffIndex == MAX_RX_DESCR-1)\r\nlp->rxBuffIndex = 0;\r\nelse\r\nlp->rxBuffIndex++;\r\n}\r\n}\r\nstatic irqreturn_t at91ether_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_id;\r\nstruct at91_private *lp = netdev_priv(dev);\r\nunsigned long intstatus, ctl;\r\nintstatus = at91_emac_read(lp, AT91_EMAC_ISR);\r\nif (intstatus & AT91_EMAC_RCOM)\r\nat91ether_rx(dev);\r\nif (intstatus & AT91_EMAC_TCOM) {\r\nif (intstatus & (AT91_EMAC_TUND | AT91_EMAC_RTRY))\r\ndev->stats.tx_errors += 1;\r\nif (lp->skb) {\r\ndev_kfree_skb_irq(lp->skb);\r\nlp->skb = NULL;\r\ndma_unmap_single(NULL, lp->skb_physaddr, lp->skb_length, DMA_TO_DEVICE);\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nif (intstatus & AT91_EMAC_RBNA) {\r\nctl = at91_emac_read(lp, AT91_EMAC_CTL);\r\nat91_emac_write(lp, AT91_EMAC_CTL, ctl & ~AT91_EMAC_RE);\r\nat91_emac_write(lp, AT91_EMAC_CTL, ctl | AT91_EMAC_RE);\r\n}\r\nif (intstatus & AT91_EMAC_ROVR)\r\nprintk("%s: ROVR error\n", dev->name);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void at91ether_poll_controller(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nat91ether_interrupt(dev->irq, dev);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int __init at91ether_phy_detect(struct at91_private *lp)\r\n{\r\nunsigned int phyid1, phyid2;\r\nunsigned long phy_id;\r\nunsigned short phy_address = 0;\r\nwhile (phy_address < PHY_MAX_ADDR) {\r\nenable_mdi(lp);\r\nread_phy(lp, phy_address, MII_PHYSID1, &phyid1);\r\nread_phy(lp, phy_address, MII_PHYSID2, &phyid2);\r\ndisable_mdi(lp);\r\nphy_id = (phyid1 << 16) | (phyid2 & 0xfff0);\r\nswitch (phy_id) {\r\ncase MII_DM9161_ID:\r\ncase MII_DM9161A_ID:\r\ncase MII_LXT971A_ID:\r\ncase MII_RTL8201_ID:\r\ncase MII_BCM5221_ID:\r\ncase MII_DP83847_ID:\r\ncase MII_DP83848_ID:\r\ncase MII_AC101L_ID:\r\ncase MII_KS8721_ID:\r\ncase MII_T78Q21x3_ID:\r\ncase MII_LAN83C185_ID:\r\nlp->phy_type = phy_id;\r\nlp->phy_address = phy_address;\r\nreturn 1;\r\n}\r\nphy_address++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init at91ether_probe(struct platform_device *pdev)\r\n{\r\nstruct macb_platform_data *board_data = pdev->dev.platform_data;\r\nstruct resource *regs;\r\nstruct net_device *dev;\r\nstruct at91_private *lp;\r\nint res;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs)\r\nreturn -ENOENT;\r\ndev = alloc_etherdev(sizeof(struct at91_private));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nlp = netdev_priv(dev);\r\nlp->board_data = *board_data;\r\nspin_lock_init(&lp->lock);\r\ndev->base_addr = regs->start;\r\nlp->emac_base = ioremap(regs->start, regs->end - regs->start + 1);\r\nif (!lp->emac_base) {\r\nres = -ENOMEM;\r\ngoto err_free_dev;\r\n}\r\nlp->ether_clk = clk_get(&pdev->dev, "ether_clk");\r\nif (IS_ERR(lp->ether_clk)) {\r\nres = PTR_ERR(lp->ether_clk);\r\ngoto err_ioumap;\r\n}\r\nclk_enable(lp->ether_clk);\r\ndev->irq = platform_get_irq(pdev, 0);\r\nif (request_irq(dev->irq, at91ether_interrupt, 0, dev->name, dev)) {\r\nres = -EBUSY;\r\ngoto err_disable_clock;\r\n}\r\nlp->dlist = (struct recv_desc_bufs *) dma_alloc_coherent(NULL, sizeof(struct recv_desc_bufs), (dma_addr_t *) &lp->dlist_phys, GFP_KERNEL);\r\nif (lp->dlist == NULL) {\r\nres = -ENOMEM;\r\ngoto err_free_irq;\r\n}\r\nether_setup(dev);\r\ndev->netdev_ops = &at91ether_netdev_ops;\r\ndev->ethtool_ops = &at91ether_ethtool_ops;\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nget_mac_address(dev);\r\nupdate_mac_address(dev);\r\nat91_emac_write(lp, AT91_EMAC_CTL, 0);\r\nif (board_data->is_rmii)\r\nat91_emac_write(lp, AT91_EMAC_CFG, AT91_EMAC_CLK_DIV32 | AT91_EMAC_BIG | AT91_EMAC_RMII);\r\nelse\r\nat91_emac_write(lp, AT91_EMAC_CFG, AT91_EMAC_CLK_DIV32 | AT91_EMAC_BIG);\r\nif (!at91ether_phy_detect(lp)) {\r\nprintk(KERN_ERR "at91_ether: Could not detect ethernet PHY\n");\r\nres = -ENODEV;\r\ngoto err_free_dmamem;\r\n}\r\ninitialize_phy(lp);\r\nlp->mii.dev = dev;\r\nlp->mii.mdio_read = mdio_read;\r\nlp->mii.mdio_write = mdio_write;\r\nlp->mii.phy_id = lp->phy_address;\r\nlp->mii.phy_id_mask = 0x1f;\r\nlp->mii.reg_num_mask = 0x1f;\r\nres = register_netdev(dev);\r\nif (res)\r\ngoto err_free_dmamem;\r\nspin_lock_irq(&lp->lock);\r\nenable_mdi(lp);\r\nupdate_linkspeed(dev, 0);\r\ndisable_mdi(lp);\r\nspin_unlock_irq(&lp->lock);\r\nnetif_carrier_off(dev);\r\nif (gpio_is_valid(lp->board_data.phy_irq_pin)) {\r\ngpio_request(board_data->phy_irq_pin, "ethernet_phy");\r\n} else {\r\ninit_timer(&lp->check_timer);\r\nlp->check_timer.data = (unsigned long)dev;\r\nlp->check_timer.function = at91ether_check_link;\r\n}\r\nprintk(KERN_INFO "%s: AT91 ethernet at 0x%08x int=%d %s%s (%pM)\n",\r\ndev->name, (uint) dev->base_addr, dev->irq,\r\nat91_emac_read(lp, AT91_EMAC_CFG) & AT91_EMAC_SPD ? "100-" : "10-",\r\nat91_emac_read(lp, AT91_EMAC_CFG) & AT91_EMAC_FD ? "FullDuplex" : "HalfDuplex",\r\ndev->dev_addr);\r\nif ((lp->phy_type == MII_DM9161_ID) || (lp->phy_type == MII_DM9161A_ID))\r\nprintk(KERN_INFO "%s: Davicom 9161 PHY %s\n", dev->name, (lp->phy_media == PORT_FIBRE) ? "(Fiber)" : "(Copper)");\r\nelse if (lp->phy_type == MII_LXT971A_ID)\r\nprintk(KERN_INFO "%s: Intel LXT971A PHY\n", dev->name);\r\nelse if (lp->phy_type == MII_RTL8201_ID)\r\nprintk(KERN_INFO "%s: Realtek RTL8201(B)L PHY\n", dev->name);\r\nelse if (lp->phy_type == MII_BCM5221_ID)\r\nprintk(KERN_INFO "%s: Broadcom BCM5221 PHY\n", dev->name);\r\nelse if (lp->phy_type == MII_DP83847_ID)\r\nprintk(KERN_INFO "%s: National Semiconductor DP83847 PHY\n", dev->name);\r\nelse if (lp->phy_type == MII_DP83848_ID)\r\nprintk(KERN_INFO "%s: National Semiconductor DP83848 PHY\n", dev->name);\r\nelse if (lp->phy_type == MII_AC101L_ID)\r\nprintk(KERN_INFO "%s: Altima AC101L PHY\n", dev->name);\r\nelse if (lp->phy_type == MII_KS8721_ID)\r\nprintk(KERN_INFO "%s: Micrel KS8721 PHY\n", dev->name);\r\nelse if (lp->phy_type == MII_T78Q21x3_ID)\r\nprintk(KERN_INFO "%s: Teridian 78Q21x3 PHY\n", dev->name);\r\nelse if (lp->phy_type == MII_LAN83C185_ID)\r\nprintk(KERN_INFO "%s: SMSC LAN83C185 PHY\n", dev->name);\r\nclk_disable(lp->ether_clk);\r\nreturn 0;\r\nerr_free_dmamem:\r\nplatform_set_drvdata(pdev, NULL);\r\ndma_free_coherent(NULL, sizeof(struct recv_desc_bufs), lp->dlist, (dma_addr_t)lp->dlist_phys);\r\nerr_free_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_disable_clock:\r\nclk_disable(lp->ether_clk);\r\nclk_put(lp->ether_clk);\r\nerr_ioumap:\r\niounmap(lp->emac_base);\r\nerr_free_dev:\r\nfree_netdev(dev);\r\nreturn res;\r\n}\r\nstatic int __devexit at91ether_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct at91_private *lp = netdev_priv(dev);\r\nif (gpio_is_valid(lp->board_data.phy_irq_pin))\r\ngpio_free(lp->board_data.phy_irq_pin);\r\nunregister_netdev(dev);\r\nfree_irq(dev->irq, dev);\r\ndma_free_coherent(NULL, sizeof(struct recv_desc_bufs), lp->dlist, (dma_addr_t)lp->dlist_phys);\r\nclk_put(lp->ether_clk);\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_netdev(dev);\r\nreturn 0;\r\n}\r\nstatic int at91ether_suspend(struct platform_device *pdev, pm_message_t mesg)\r\n{\r\nstruct net_device *net_dev = platform_get_drvdata(pdev);\r\nstruct at91_private *lp = netdev_priv(net_dev);\r\nif (netif_running(net_dev)) {\r\nif (gpio_is_valid(lp->board_data.phy_irq_pin)) {\r\nint phy_irq = gpio_to_irq(lp->board_data.phy_irq_pin);\r\ndisable_irq(phy_irq);\r\n}\r\nnetif_stop_queue(net_dev);\r\nnetif_device_detach(net_dev);\r\nclk_disable(lp->ether_clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int at91ether_resume(struct platform_device *pdev)\r\n{\r\nstruct net_device *net_dev = platform_get_drvdata(pdev);\r\nstruct at91_private *lp = netdev_priv(net_dev);\r\nif (netif_running(net_dev)) {\r\nclk_enable(lp->ether_clk);\r\nnetif_device_attach(net_dev);\r\nnetif_start_queue(net_dev);\r\nif (gpio_is_valid(lp->board_data.phy_irq_pin)) {\r\nint phy_irq = gpio_to_irq(lp->board_data.phy_irq_pin);\r\nenable_irq(phy_irq);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init at91ether_init(void)\r\n{\r\nreturn platform_driver_probe(&at91ether_driver, at91ether_probe);\r\n}\r\nstatic void __exit at91ether_exit(void)\r\n{\r\nplatform_driver_unregister(&at91ether_driver);\r\n}
