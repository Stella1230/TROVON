static u8 wait_chip_ready(struct orc_host * host)\r\n{\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nif (inb(host->base + ORC_HCTRL) & HOSTSTOP)\r\nreturn 1;\r\nmdelay(100);\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 wait_firmware_ready(struct orc_host * host)\r\n{\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nif (inb(host->base + ORC_HSTUS) & RREADY)\r\nreturn 1;\r\nmdelay(100);\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 wait_scsi_reset_done(struct orc_host * host)\r\n{\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nif (!(inb(host->base + ORC_HCTRL) & SCSIRST))\r\nreturn 1;\r\nmdelay(100);\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 wait_HDO_off(struct orc_host * host)\r\n{\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nif (!(inb(host->base + ORC_HCTRL) & HDO))\r\nreturn 1;\r\nmdelay(100);\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 wait_hdi_set(struct orc_host * host, u8 * data)\r\n{\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nif ((*data = inb(host->base + ORC_HSTUS)) & HDI)\r\nreturn 1;\r\nmdelay(100);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned short orc_read_fwrev(struct orc_host * host)\r\n{\r\nu16 version;\r\nu8 data;\r\noutb(ORC_CMD_VERSION, host->base + ORC_HDATA);\r\noutb(HDO, host->base + ORC_HCTRL);\r\nif (wait_HDO_off(host) == 0)\r\nreturn 0;\r\nif (wait_hdi_set(host, &data) == 0)\r\nreturn 0;\r\nversion = inb(host->base + ORC_HDATA);\r\noutb(data, host->base + ORC_HSTUS);\r\nif (wait_hdi_set(host, &data) == 0)\r\nreturn 0;\r\nversion |= inb(host->base + ORC_HDATA) << 8;\r\noutb(data, host->base + ORC_HSTUS);\r\nreturn version;\r\n}\r\nstatic u8 orc_nv_write(struct orc_host * host, unsigned char address, unsigned char value)\r\n{\r\noutb(ORC_CMD_SET_NVM, host->base + ORC_HDATA);\r\noutb(HDO, host->base + ORC_HCTRL);\r\nif (wait_HDO_off(host) == 0)\r\nreturn 0;\r\noutb(address, host->base + ORC_HDATA);\r\noutb(HDO, host->base + ORC_HCTRL);\r\nif (wait_HDO_off(host) == 0)\r\nreturn 0;\r\noutb(value, host->base + ORC_HDATA);\r\noutb(HDO, host->base + ORC_HCTRL);\r\nif (wait_HDO_off(host) == 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic u8 orc_nv_read(struct orc_host * host, u8 address, u8 *ptr)\r\n{\r\nunsigned char data;\r\noutb(ORC_CMD_GET_NVM, host->base + ORC_HDATA);\r\noutb(HDO, host->base + ORC_HCTRL);\r\nif (wait_HDO_off(host) == 0)\r\nreturn 0;\r\noutb(address, host->base + ORC_HDATA);\r\noutb(HDO, host->base + ORC_HCTRL);\r\nif (wait_HDO_off(host) == 0)\r\nreturn 0;\r\nif (wait_hdi_set(host, &data) == 0)\r\nreturn 0;\r\n*ptr = inb(host->base + ORC_HDATA);\r\noutb(data, host->base + ORC_HSTUS);\r\nreturn 1;\r\n}\r\nstatic void orc_exec_scb(struct orc_host * host, struct orc_scb * scb)\r\n{\r\nscb->status = ORCSCB_POST;\r\noutb(scb->scbidx, host->base + ORC_PQUEUE);\r\n}\r\nstatic int se2_rd_all(struct orc_host * host)\r\n{\r\nint i;\r\nu8 *np, chksum = 0;\r\nnp = (u8 *) nvramp;\r\nfor (i = 0; i < 64; i++, np++) {\r\nif (orc_nv_read(host, (u8) i, np) == 0)\r\nreturn -1;\r\n}\r\nnp = (u8 *) nvramp;\r\nfor (i = 0; i < 63; i++)\r\nchksum += *np++;\r\nif (nvramp->CheckSum != (u8) chksum)\r\nreturn -1;\r\nreturn 1;\r\n}\r\nstatic void se2_update_all(struct orc_host * host)\r\n{\r\nint i;\r\nu8 *np, *np1, chksum = 0;\r\nnp = (u8 *) default_nvram;\r\nfor (i = 0; i < 63; i++)\r\nchksum += *np++;\r\n*np = chksum;\r\nnp = (u8 *) default_nvram;\r\nnp1 = (u8 *) nvramp;\r\nfor (i = 0; i < 64; i++, np++, np1++) {\r\nif (*np != *np1)\r\norc_nv_write(host, (u8) i, *np);\r\n}\r\n}\r\nstatic void read_eeprom(struct orc_host * host)\r\n{\r\nif (se2_rd_all(host) != 1) {\r\nse2_update_all(host);\r\nse2_rd_all(host);\r\n}\r\n}\r\nstatic u8 orc_load_firmware(struct orc_host * host)\r\n{\r\nu32 data32;\r\nu16 bios_addr;\r\nu16 i;\r\nu8 *data32_ptr, data;\r\ndata = inb(host->base + ORC_GCFG);\r\noutb(data | EEPRG, host->base + ORC_GCFG);\r\noutb(0x00, host->base + ORC_EBIOSADR2);\r\noutw(0x0000, host->base + ORC_EBIOSADR0);\r\nif (inb(host->base + ORC_EBIOSDATA) != 0x55) {\r\noutb(data, host->base + ORC_GCFG);\r\nreturn 0;\r\n}\r\noutw(0x0001, host->base + ORC_EBIOSADR0);\r\nif (inb(host->base + ORC_EBIOSDATA) != 0xAA) {\r\noutb(data, host->base + ORC_GCFG);\r\nreturn 0;\r\n}\r\noutb(PRGMRST | DOWNLOAD, host->base + ORC_RISCCTL);\r\ndata32_ptr = (u8 *) & data32;\r\ndata32 = cpu_to_le32(0);\r\noutw(0x0010, host->base + ORC_EBIOSADR0);\r\n*data32_ptr = inb(host->base + ORC_EBIOSDATA);\r\noutw(0x0011, host->base + ORC_EBIOSADR0);\r\n*(data32_ptr + 1) = inb(host->base + ORC_EBIOSDATA);\r\noutw(0x0012, host->base + ORC_EBIOSADR0);\r\n*(data32_ptr + 2) = inb(host->base + ORC_EBIOSDATA);\r\noutw(*(data32_ptr + 2), host->base + ORC_EBIOSADR2);\r\noutl(le32_to_cpu(data32), host->base + ORC_FWBASEADR);\r\nudelay(500);\r\nbios_addr = (u16) le32_to_cpu(data32);\r\nfor (i = 0, data32_ptr = (u8 *) & data32;\r\ni < 0x1000;\r\ni++, bios_addr++) {\r\noutw(bios_addr, host->base + ORC_EBIOSADR0);\r\n*data32_ptr++ = inb(host->base + ORC_EBIOSDATA);\r\nif ((i % 4) == 3) {\r\noutl(le32_to_cpu(data32), host->base + ORC_RISCRAM);\r\ndata32_ptr = (u8 *) & data32;\r\n}\r\n}\r\noutb(PRGMRST | DOWNLOAD, host->base + ORC_RISCCTL);\r\nbios_addr -= 0x1000;\r\nfor (i = 0, data32_ptr = (u8 *) & data32;\r\ni < 0x1000;\r\ni++, bios_addr++) {\r\noutw(bios_addr, host->base + ORC_EBIOSADR0);\r\n*data32_ptr++ = inb(host->base + ORC_EBIOSDATA);\r\nif ((i % 4) == 3) {\r\nif (inl(host->base + ORC_RISCRAM) != le32_to_cpu(data32)) {\r\noutb(PRGMRST, host->base + ORC_RISCCTL);\r\noutb(data, host->base + ORC_GCFG);\r\nreturn 0;\r\n}\r\ndata32_ptr = (u8 *) & data32;\r\n}\r\n}\r\noutb(PRGMRST, host->base + ORC_RISCCTL);\r\noutb(data, host->base + ORC_GCFG);\r\nreturn 1;\r\n}\r\nstatic void setup_SCBs(struct orc_host * host)\r\n{\r\nstruct orc_scb *scb;\r\nint i;\r\nstruct orc_extended_scb *escb;\r\ndma_addr_t escb_phys;\r\noutb(ORC_MAXQUEUE, host->base + ORC_SCBSIZE);\r\noutl(host->scb_phys, host->base + ORC_SCBBASE0);\r\noutl(host->scb_phys, host->base + ORC_SCBBASE1);\r\nscb = host->scb_virt;\r\nescb = host->escb_virt;\r\nfor (i = 0; i < ORC_MAXQUEUE; i++) {\r\nescb_phys = (host->escb_phys + (sizeof(struct orc_extended_scb) * i));\r\nscb->sg_addr = cpu_to_le32((u32) escb_phys);\r\nscb->sense_addr = cpu_to_le32((u32) escb_phys);\r\nscb->escb = escb;\r\nscb->scbidx = i;\r\nscb++;\r\nescb++;\r\n}\r\n}\r\nstatic void init_alloc_map(struct orc_host * host)\r\n{\r\nu8 i, j;\r\nfor (i = 0; i < MAX_CHANNELS; i++) {\r\nfor (j = 0; j < 8; j++) {\r\nhost->allocation_map[i][j] = 0xffffffff;\r\n}\r\n}\r\n}\r\nstatic int init_orchid(struct orc_host * host)\r\n{\r\nu8 *ptr;\r\nu16 revision;\r\nu8 i;\r\ninit_alloc_map(host);\r\noutb(0xFF, host->base + ORC_GIMSK);\r\nif (inb(host->base + ORC_HSTUS) & RREADY) {\r\nrevision = orc_read_fwrev(host);\r\nif (revision == 0xFFFF) {\r\noutb(DEVRST, host->base + ORC_HCTRL);\r\nif (wait_chip_ready(host) == 0)\r\nreturn -1;\r\norc_load_firmware(host);\r\nsetup_SCBs(host);\r\noutb(0x00, host->base + ORC_HCTRL);\r\nif (wait_firmware_ready(host) == 0)\r\nreturn -1;\r\n} else {\r\nsetup_SCBs(host);\r\n}\r\n} else {\r\noutb(DEVRST, host->base + ORC_HCTRL);\r\nif (wait_chip_ready(host) == 0)\r\nreturn -1;\r\norc_load_firmware(host);\r\nsetup_SCBs(host);\r\noutb(HDO, host->base + ORC_HCTRL);\r\nif (wait_firmware_ready(host) == 0)\r\nreturn -1;\r\n}\r\nread_eeprom(host);\r\nif (nvramp->revision != 1)\r\nreturn -1;\r\nhost->scsi_id = nvramp->scsi_id;\r\nhost->BIOScfg = nvramp->BIOSConfig1;\r\nhost->max_targets = MAX_TARGETS;\r\nptr = (u8 *) & (nvramp->Target00Config);\r\nfor (i = 0; i < 16; ptr++, i++) {\r\nhost->target_flag[i] = *ptr;\r\nhost->max_tags[i] = ORC_MAXTAGS;\r\n}\r\nif (nvramp->SCSI0Config & NCC_BUSRESET)\r\nhost->flags |= HCF_SCSI_RESET;\r\noutb(0xFB, host->base + ORC_GIMSK);\r\nreturn 0;\r\n}\r\nstatic int orc_reset_scsi_bus(struct orc_host * host)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->allocation_lock, flags);\r\ninit_alloc_map(host);\r\noutb(SCSIRST, host->base + ORC_HCTRL);\r\nif (wait_scsi_reset_done(host) == 0) {\r\nspin_unlock_irqrestore(&host->allocation_lock, flags);\r\nreturn FAILED;\r\n} else {\r\nspin_unlock_irqrestore(&host->allocation_lock, flags);\r\nreturn SUCCESS;\r\n}\r\n}\r\nstatic int orc_device_reset(struct orc_host * host, struct scsi_cmnd *cmd, unsigned int target)\r\n{\r\nstruct orc_scb *scb;\r\nstruct orc_extended_scb *escb;\r\nstruct orc_scb *host_scb;\r\nu8 i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&(host->allocation_lock), flags);\r\nscb = (struct orc_scb *) NULL;\r\nescb = (struct orc_extended_scb *) NULL;\r\nhost_scb = host->scb_virt;\r\ninit_alloc_map(host);\r\nfor (i = 0; i < ORC_MAXQUEUE; i++) {\r\nescb = host_scb->escb;\r\nif (host_scb->status && escb->srb == cmd)\r\nbreak;\r\nhost_scb++;\r\n}\r\nif (i == ORC_MAXQUEUE) {\r\nprintk(KERN_ERR "Unable to Reset - No SCB Found\n");\r\nspin_unlock_irqrestore(&(host->allocation_lock), flags);\r\nreturn FAILED;\r\n}\r\nif ((scb = __orc_alloc_scb(host)) == NULL) {\r\nspin_unlock_irqrestore(&(host->allocation_lock), flags);\r\nreturn FAILED;\r\n}\r\nscb->opcode = ORC_BUSDEVRST;\r\nscb->target = target;\r\nscb->hastat = 0;\r\nscb->tastat = 0;\r\nscb->status = 0x0;\r\nscb->link = 0xFF;\r\nscb->reserved0 = 0;\r\nscb->reserved1 = 0;\r\nscb->xferlen = cpu_to_le32(0);\r\nscb->sg_len = cpu_to_le32(0);\r\nescb->srb = NULL;\r\nescb->srb = cmd;\r\norc_exec_scb(host, scb);\r\nspin_unlock_irqrestore(&host->allocation_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nstatic struct orc_scb *__orc_alloc_scb(struct orc_host * host)\r\n{\r\nu8 channel;\r\nunsigned long idx;\r\nu8 index;\r\nu8 i;\r\nchannel = host->index;\r\nfor (i = 0; i < 8; i++) {\r\nfor (index = 0; index < 32; index++) {\r\nif ((host->allocation_map[channel][i] >> index) & 0x01) {\r\nhost->allocation_map[channel][i] &= ~(1 << index);\r\nidx = index + 32 * i;\r\nreturn host->scb_virt + idx;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct orc_scb *orc_alloc_scb(struct orc_host * host)\r\n{\r\nstruct orc_scb *scb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->allocation_lock, flags);\r\nscb = __orc_alloc_scb(host);\r\nspin_unlock_irqrestore(&host->allocation_lock, flags);\r\nreturn scb;\r\n}\r\nstatic void orc_release_scb(struct orc_host *host, struct orc_scb *scb)\r\n{\r\nunsigned long flags;\r\nu8 index, i, channel;\r\nspin_lock_irqsave(&(host->allocation_lock), flags);\r\nchannel = host->index;\r\nindex = scb->scbidx;\r\ni = index / 32;\r\nindex %= 32;\r\nhost->allocation_map[channel][i] |= (1 << index);\r\nspin_unlock_irqrestore(&(host->allocation_lock), flags);\r\n}\r\nstatic int orchid_abort_scb(struct orc_host * host, struct orc_scb * scb)\r\n{\r\nunsigned char data, status;\r\noutb(ORC_CMD_ABORT_SCB, host->base + ORC_HDATA);\r\noutb(HDO, host->base + ORC_HCTRL);\r\nif (wait_HDO_off(host) == 0)\r\nreturn 0;\r\noutb(scb->scbidx, host->base + ORC_HDATA);\r\noutb(HDO, host->base + ORC_HCTRL);\r\nif (wait_HDO_off(host) == 0)\r\nreturn 0;\r\nif (wait_hdi_set(host, &data) == 0)\r\nreturn 0;\r\nstatus = inb(host->base + ORC_HDATA);\r\noutb(data, host->base + ORC_HSTUS);\r\nif (status == 1)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int inia100_abort_cmd(struct orc_host * host, struct scsi_cmnd *cmd)\r\n{\r\nstruct orc_extended_scb *escb;\r\nstruct orc_scb *scb;\r\nu8 i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&(host->allocation_lock), flags);\r\nscb = host->scb_virt;\r\nfor (i = 0; i < ORC_MAXQUEUE; i++, scb++) {\r\nescb = scb->escb;\r\nif (scb->status && escb->srb == cmd) {\r\nif (scb->tag_msg == 0) {\r\ngoto out;\r\n} else {\r\nif (orchid_abort_scb(host, scb)) {\r\nescb->srb = NULL;\r\nspin_unlock_irqrestore(&host->allocation_lock, flags);\r\nreturn SUCCESS;\r\n} else\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&host->allocation_lock, flags);\r\nreturn FAILED;\r\n}\r\nstatic irqreturn_t orc_interrupt(struct orc_host * host)\r\n{\r\nu8 scb_index;\r\nstruct orc_scb *scb;\r\nif (inb(host->base + ORC_RQUEUECNT) == 0)\r\nreturn IRQ_NONE;\r\ndo {\r\nscb_index = inb(host->base + ORC_RQUEUE);\r\nscb = (struct orc_scb *) ((unsigned long) host->scb_virt + (unsigned long) (sizeof(struct orc_scb) * scb_index));\r\nscb->status = 0x0;\r\ninia100_scb_handler(host, scb);\r\n} while (inb(host->base + ORC_RQUEUECNT));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int inia100_build_scb(struct orc_host * host, struct orc_scb * scb, struct scsi_cmnd * cmd)\r\n{\r\nstruct scatterlist *sg;\r\nstruct orc_sgent *sgent;\r\nint i, count_sg;\r\nstruct orc_extended_scb *escb;\r\nescb = scb->escb;\r\nescb->srb = cmd;\r\nsgent = NULL;\r\nscb->opcode = ORC_EXECSCSI;\r\nscb->flags = SCF_NO_DCHK;\r\nscb->target = cmd->device->id;\r\nscb->lun = cmd->device->lun;\r\nscb->reserved0 = 0;\r\nscb->reserved1 = 0;\r\nscb->sg_len = cpu_to_le32(0);\r\nscb->xferlen = cpu_to_le32((u32) scsi_bufflen(cmd));\r\nsgent = (struct orc_sgent *) & escb->sglist[0];\r\ncount_sg = scsi_dma_map(cmd);\r\nif (count_sg < 0)\r\nreturn count_sg;\r\nBUG_ON(count_sg > TOTAL_SG_ENTRY);\r\nif (count_sg) {\r\nscb->sg_len = cpu_to_le32((u32) (count_sg * 8));\r\nscsi_for_each_sg(cmd, sg, count_sg, i) {\r\nsgent->base = cpu_to_le32((u32) sg_dma_address(sg));\r\nsgent->length = cpu_to_le32((u32) sg_dma_len(sg));\r\nsgent++;\r\n}\r\n} else {\r\nscb->sg_len = cpu_to_le32(0);\r\nsgent->base = cpu_to_le32(0);\r\nsgent->length = cpu_to_le32(0);\r\n}\r\nscb->sg_addr = (u32) scb->sense_addr;\r\nscb->hastat = 0;\r\nscb->tastat = 0;\r\nscb->link = 0xFF;\r\nscb->sense_len = SENSE_SIZE;\r\nscb->cdb_len = cmd->cmd_len;\r\nif (scb->cdb_len >= IMAX_CDB) {\r\nprintk("max cdb length= %x\b", cmd->cmd_len);\r\nscb->cdb_len = IMAX_CDB;\r\n}\r\nscb->ident = cmd->device->lun | DISC_ALLOW;\r\nif (cmd->device->tagged_supported) {\r\nscb->tag_msg = SIMPLE_QUEUE_TAG;\r\n} else {\r\nscb->tag_msg = 0;\r\n}\r\nmemcpy(scb->cdb, cmd->cmnd, scb->cdb_len);\r\nreturn 0;\r\n}\r\nstatic int inia100_queue_lck(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd *))\r\n{\r\nstruct orc_scb *scb;\r\nstruct orc_host *host;\r\nhost = (struct orc_host *) cmd->device->host->hostdata;\r\ncmd->scsi_done = done;\r\nif ((scb = orc_alloc_scb(host)) == NULL)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nif (inia100_build_scb(host, scb, cmd)) {\r\norc_release_scb(host, scb);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\norc_exec_scb(host, scb);\r\nreturn 0;\r\n}\r\nstatic int inia100_bus_reset(struct scsi_cmnd * cmd)\r\n{\r\nstruct orc_host *host;\r\nhost = (struct orc_host *) cmd->device->host->hostdata;\r\nreturn orc_reset_scsi_bus(host);\r\n}\r\nstatic int inia100_device_reset(struct scsi_cmnd * cmd)\r\n{\r\nstruct orc_host *host;\r\nhost = (struct orc_host *) cmd->device->host->hostdata;\r\nreturn orc_device_reset(host, cmd, scmd_id(cmd));\r\n}\r\nstatic void inia100_scb_handler(struct orc_host *host, struct orc_scb *scb)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nstruct orc_extended_scb *escb;\r\nescb = scb->escb;\r\nif ((cmd = (struct scsi_cmnd *) escb->srb) == NULL) {\r\nprintk(KERN_ERR "inia100_scb_handler: SRB pointer is empty\n");\r\norc_release_scb(host, scb);\r\nreturn;\r\n}\r\nescb->srb = NULL;\r\nswitch (scb->hastat) {\r\ncase 0x0:\r\ncase 0xa:\r\ncase 0xb:\r\nscb->hastat = 0;\r\nbreak;\r\ncase 0x11:\r\nscb->hastat = DID_TIME_OUT;\r\nbreak;\r\ncase 0x14:\r\nscb->hastat = DID_RESET;\r\nbreak;\r\ncase 0x1a:\r\nscb->hastat = DID_ABORT;\r\nbreak;\r\ncase 0x12:\r\ncase 0x13:\r\ncase 0x16:\r\ndefault:\r\nprintk(KERN_DEBUG "inia100: %x %x\n", scb->hastat, scb->tastat);\r\nscb->hastat = DID_ERROR;\r\nbreak;\r\n}\r\nif (scb->tastat == 2) {\r\nmemcpy((unsigned char *) &cmd->sense_buffer[0],\r\n(unsigned char *) &escb->sglist[0], SENSE_SIZE);\r\n}\r\ncmd->result = scb->tastat | (scb->hastat << 16);\r\nscsi_dma_unmap(cmd);\r\ncmd->scsi_done(cmd);\r\norc_release_scb(host, scb);\r\n}\r\nstatic irqreturn_t inia100_intr(int irqno, void *devid)\r\n{\r\nstruct Scsi_Host *shost = (struct Scsi_Host *)devid;\r\nstruct orc_host *host = (struct orc_host *)shost->hostdata;\r\nunsigned long flags;\r\nirqreturn_t res;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nres = orc_interrupt(host);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn res;\r\n}\r\nstatic int __devinit inia100_probe_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct orc_host *host;\r\nunsigned long port, bios;\r\nint error = -ENODEV;\r\nu32 sz;\r\nunsigned long biosaddr;\r\nchar *bios_phys;\r\nif (pci_enable_device(pdev))\r\ngoto out;\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_WARNING "Unable to set 32bit DMA "\r\n"on inia100 adapter, ignoring.\n");\r\ngoto out_disable_device;\r\n}\r\npci_set_master(pdev);\r\nport = pci_resource_start(pdev, 0);\r\nif (!request_region(port, 256, "inia100")) {\r\nprintk(KERN_WARNING "inia100: io port 0x%lx, is busy.\n", port);\r\ngoto out_disable_device;\r\n}\r\nbios = inw(port + 0x50);\r\nshost = scsi_host_alloc(&inia100_template, sizeof(struct orc_host));\r\nif (!shost)\r\ngoto out_release_region;\r\nhost = (struct orc_host *)shost->hostdata;\r\nhost->pdev = pdev;\r\nhost->base = port;\r\nhost->BIOScfg = bios;\r\nspin_lock_init(&host->allocation_lock);\r\nsz = ORC_MAXQUEUE * sizeof(struct orc_scb);\r\nhost->scb_virt = pci_alloc_consistent(pdev, sz,\r\n&host->scb_phys);\r\nif (!host->scb_virt) {\r\nprintk("inia100: SCB memory allocation error\n");\r\ngoto out_host_put;\r\n}\r\nmemset(host->scb_virt, 0, sz);\r\nsz = ORC_MAXQUEUE * sizeof(struct orc_extended_scb);\r\nhost->escb_virt = pci_alloc_consistent(pdev, sz,\r\n&host->escb_phys);\r\nif (!host->escb_virt) {\r\nprintk("inia100: ESCB memory allocation error\n");\r\ngoto out_free_scb_array;\r\n}\r\nmemset(host->escb_virt, 0, sz);\r\nbiosaddr = host->BIOScfg;\r\nbiosaddr = (biosaddr << 4);\r\nbios_phys = phys_to_virt(biosaddr);\r\nif (init_orchid(host)) {\r\nprintk("inia100: initial orchid fail!!\n");\r\ngoto out_free_escb_array;\r\n}\r\nshost->io_port = host->base;\r\nshost->n_io_port = 0xff;\r\nshost->can_queue = ORC_MAXQUEUE;\r\nshost->unique_id = shost->io_port;\r\nshost->max_id = host->max_targets;\r\nshost->max_lun = 16;\r\nshost->irq = pdev->irq;\r\nshost->this_id = host->scsi_id;\r\nshost->sg_tablesize = TOTAL_SG_ENTRY;\r\nerror = request_irq(pdev->irq, inia100_intr, IRQF_SHARED,\r\n"inia100", shost);\r\nif (error < 0) {\r\nprintk(KERN_WARNING "inia100: unable to get irq %d\n",\r\npdev->irq);\r\ngoto out_free_escb_array;\r\n}\r\npci_set_drvdata(pdev, shost);\r\nerror = scsi_add_host(shost, &pdev->dev);\r\nif (error)\r\ngoto out_free_irq;\r\nscsi_scan_host(shost);\r\nreturn 0;\r\nout_free_irq:\r\nfree_irq(shost->irq, shost);\r\nout_free_escb_array:\r\npci_free_consistent(pdev, ORC_MAXQUEUE * sizeof(struct orc_extended_scb),\r\nhost->escb_virt, host->escb_phys);\r\nout_free_scb_array:\r\npci_free_consistent(pdev, ORC_MAXQUEUE * sizeof(struct orc_scb),\r\nhost->scb_virt, host->scb_phys);\r\nout_host_put:\r\nscsi_host_put(shost);\r\nout_release_region:\r\nrelease_region(port, 256);\r\nout_disable_device:\r\npci_disable_device(pdev);\r\nout:\r\nreturn error;\r\n}\r\nstatic void __devexit inia100_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct orc_host *host = (struct orc_host *)shost->hostdata;\r\nscsi_remove_host(shost);\r\nfree_irq(shost->irq, shost);\r\npci_free_consistent(pdev, ORC_MAXQUEUE * sizeof(struct orc_extended_scb),\r\nhost->escb_virt, host->escb_phys);\r\npci_free_consistent(pdev, ORC_MAXQUEUE * sizeof(struct orc_scb),\r\nhost->scb_virt, host->scb_phys);\r\nrelease_region(shost->io_port, 256);\r\nscsi_host_put(shost);\r\n}\r\nstatic int __init inia100_init(void)\r\n{\r\nreturn pci_register_driver(&inia100_pci_driver);\r\n}\r\nstatic void __exit inia100_exit(void)\r\n{\r\npci_unregister_driver(&inia100_pci_driver);\r\n}
