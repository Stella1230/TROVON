void\r\nxfs_extent_busy_insert(\r\nstruct xfs_trans *tp,\r\nxfs_agnumber_t agno,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nunsigned int flags)\r\n{\r\nstruct xfs_extent_busy *new;\r\nstruct xfs_extent_busy *busyp;\r\nstruct xfs_perag *pag;\r\nstruct rb_node **rbp;\r\nstruct rb_node *parent = NULL;\r\nnew = kmem_zalloc(sizeof(struct xfs_extent_busy), KM_MAYFAIL);\r\nif (!new) {\r\ntrace_xfs_extent_busy_enomem(tp->t_mountp, agno, bno, len);\r\nxfs_trans_set_sync(tp);\r\nreturn;\r\n}\r\nnew->agno = agno;\r\nnew->bno = bno;\r\nnew->length = len;\r\nINIT_LIST_HEAD(&new->list);\r\nnew->flags = flags;\r\ntrace_xfs_extent_busy(tp->t_mountp, agno, bno, len);\r\npag = xfs_perag_get(tp->t_mountp, new->agno);\r\nspin_lock(&pag->pagb_lock);\r\nrbp = &pag->pagb_tree.rb_node;\r\nwhile (*rbp) {\r\nparent = *rbp;\r\nbusyp = rb_entry(parent, struct xfs_extent_busy, rb_node);\r\nif (new->bno < busyp->bno) {\r\nrbp = &(*rbp)->rb_left;\r\nASSERT(new->bno + new->length <= busyp->bno);\r\n} else if (new->bno > busyp->bno) {\r\nrbp = &(*rbp)->rb_right;\r\nASSERT(bno >= busyp->bno + busyp->length);\r\n} else {\r\nASSERT(0);\r\n}\r\n}\r\nrb_link_node(&new->rb_node, parent, rbp);\r\nrb_insert_color(&new->rb_node, &pag->pagb_tree);\r\nlist_add(&new->list, &tp->t_busy);\r\nspin_unlock(&pag->pagb_lock);\r\nxfs_perag_put(pag);\r\n}\r\nint\r\nxfs_extent_busy_search(\r\nstruct xfs_mount *mp,\r\nxfs_agnumber_t agno,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len)\r\n{\r\nstruct xfs_perag *pag;\r\nstruct rb_node *rbp;\r\nstruct xfs_extent_busy *busyp;\r\nint match = 0;\r\npag = xfs_perag_get(mp, agno);\r\nspin_lock(&pag->pagb_lock);\r\nrbp = pag->pagb_tree.rb_node;\r\nwhile (rbp) {\r\nbusyp = rb_entry(rbp, struct xfs_extent_busy, rb_node);\r\nif (bno < busyp->bno) {\r\nif (bno + len > busyp->bno)\r\nmatch = -1;\r\nrbp = rbp->rb_left;\r\n} else if (bno > busyp->bno) {\r\nif (bno < busyp->bno + busyp->length)\r\nmatch = -1;\r\nrbp = rbp->rb_right;\r\n} else {\r\nmatch = (busyp->length == len) ? 1 : -1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&pag->pagb_lock);\r\nxfs_perag_put(pag);\r\nreturn match;\r\n}\r\nSTATIC bool\r\nxfs_extent_busy_update_extent(\r\nstruct xfs_mount *mp,\r\nstruct xfs_perag *pag,\r\nstruct xfs_extent_busy *busyp,\r\nxfs_agblock_t fbno,\r\nxfs_extlen_t flen,\r\nbool userdata)\r\n{\r\nxfs_agblock_t fend = fbno + flen;\r\nxfs_agblock_t bbno = busyp->bno;\r\nxfs_agblock_t bend = bbno + busyp->length;\r\nif (busyp->flags & XFS_EXTENT_BUSY_DISCARDED) {\r\nspin_unlock(&pag->pagb_lock);\r\ndelay(1);\r\nspin_lock(&pag->pagb_lock);\r\nreturn false;\r\n}\r\nif (userdata)\r\ngoto out_force_log;\r\nif (bbno < fbno && bend > fend) {\r\ngoto out_force_log;\r\n} else if (bbno >= fbno && bend <= fend) {\r\nrb_erase(&busyp->rb_node, &pag->pagb_tree);\r\nbusyp->length = 0;\r\nreturn false;\r\n} else if (fend < bend) {\r\nbusyp->bno = fend;\r\n} else if (bbno < fbno) {\r\nbusyp->length = fbno - busyp->bno;\r\n} else {\r\nASSERT(0);\r\n}\r\ntrace_xfs_extent_busy_reuse(mp, pag->pag_agno, fbno, flen);\r\nreturn true;\r\nout_force_log:\r\nspin_unlock(&pag->pagb_lock);\r\nxfs_log_force(mp, XFS_LOG_SYNC);\r\ntrace_xfs_extent_busy_force(mp, pag->pag_agno, fbno, flen);\r\nspin_lock(&pag->pagb_lock);\r\nreturn false;\r\n}\r\nvoid\r\nxfs_extent_busy_reuse(\r\nstruct xfs_mount *mp,\r\nxfs_agnumber_t agno,\r\nxfs_agblock_t fbno,\r\nxfs_extlen_t flen,\r\nbool userdata)\r\n{\r\nstruct xfs_perag *pag;\r\nstruct rb_node *rbp;\r\nASSERT(flen > 0);\r\npag = xfs_perag_get(mp, agno);\r\nspin_lock(&pag->pagb_lock);\r\nrestart:\r\nrbp = pag->pagb_tree.rb_node;\r\nwhile (rbp) {\r\nstruct xfs_extent_busy *busyp =\r\nrb_entry(rbp, struct xfs_extent_busy, rb_node);\r\nxfs_agblock_t bbno = busyp->bno;\r\nxfs_agblock_t bend = bbno + busyp->length;\r\nif (fbno + flen <= bbno) {\r\nrbp = rbp->rb_left;\r\ncontinue;\r\n} else if (fbno >= bend) {\r\nrbp = rbp->rb_right;\r\ncontinue;\r\n}\r\nif (!xfs_extent_busy_update_extent(mp, pag, busyp, fbno, flen,\r\nuserdata))\r\ngoto restart;\r\n}\r\nspin_unlock(&pag->pagb_lock);\r\nxfs_perag_put(pag);\r\n}\r\nvoid\r\nxfs_extent_busy_trim(\r\nstruct xfs_alloc_arg *args,\r\nxfs_agblock_t bno,\r\nxfs_extlen_t len,\r\nxfs_agblock_t *rbno,\r\nxfs_extlen_t *rlen)\r\n{\r\nxfs_agblock_t fbno;\r\nxfs_extlen_t flen;\r\nstruct rb_node *rbp;\r\nASSERT(len > 0);\r\nspin_lock(&args->pag->pagb_lock);\r\nrestart:\r\nfbno = bno;\r\nflen = len;\r\nrbp = args->pag->pagb_tree.rb_node;\r\nwhile (rbp && flen >= args->minlen) {\r\nstruct xfs_extent_busy *busyp =\r\nrb_entry(rbp, struct xfs_extent_busy, rb_node);\r\nxfs_agblock_t fend = fbno + flen;\r\nxfs_agblock_t bbno = busyp->bno;\r\nxfs_agblock_t bend = bbno + busyp->length;\r\nif (fend <= bbno) {\r\nrbp = rbp->rb_left;\r\ncontinue;\r\n} else if (fbno >= bend) {\r\nrbp = rbp->rb_right;\r\ncontinue;\r\n}\r\nif (!args->userdata &&\r\n!(busyp->flags & XFS_EXTENT_BUSY_DISCARDED)) {\r\nif (!xfs_extent_busy_update_extent(args->mp, args->pag,\r\nbusyp, fbno, flen,\r\nfalse))\r\ngoto restart;\r\ncontinue;\r\n}\r\nif (bbno <= fbno) {\r\nif (fend <= bend)\r\ngoto fail;\r\nfbno = bend;\r\n} else if (bend >= fend) {\r\nfend = bbno;\r\n} else {\r\nif (bbno - fbno >= args->maxlen) {\r\nfend = bbno;\r\n} else if (fend - bend >= args->maxlen * 4) {\r\nfbno = bend;\r\n} else if (bbno - fbno >= args->minlen) {\r\nfend = bbno;\r\n} else {\r\ngoto fail;\r\n}\r\n}\r\nflen = fend - fbno;\r\n}\r\nspin_unlock(&args->pag->pagb_lock);\r\nif (fbno != bno || flen != len) {\r\ntrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len,\r\nfbno, flen);\r\n}\r\n*rbno = fbno;\r\n*rlen = flen;\r\nreturn;\r\nfail:\r\nspin_unlock(&args->pag->pagb_lock);\r\ntrace_xfs_extent_busy_trim(args->mp, args->agno, bno, len, fbno, 0);\r\n*rbno = fbno;\r\n*rlen = 0;\r\n}\r\nSTATIC void\r\nxfs_extent_busy_clear_one(\r\nstruct xfs_mount *mp,\r\nstruct xfs_perag *pag,\r\nstruct xfs_extent_busy *busyp)\r\n{\r\nif (busyp->length) {\r\ntrace_xfs_extent_busy_clear(mp, busyp->agno, busyp->bno,\r\nbusyp->length);\r\nrb_erase(&busyp->rb_node, &pag->pagb_tree);\r\n}\r\nlist_del_init(&busyp->list);\r\nkmem_free(busyp);\r\n}\r\nvoid\r\nxfs_extent_busy_clear(\r\nstruct xfs_mount *mp,\r\nstruct list_head *list,\r\nbool do_discard)\r\n{\r\nstruct xfs_extent_busy *busyp, *n;\r\nstruct xfs_perag *pag = NULL;\r\nxfs_agnumber_t agno = NULLAGNUMBER;\r\nlist_for_each_entry_safe(busyp, n, list, list) {\r\nif (busyp->agno != agno) {\r\nif (pag) {\r\nspin_unlock(&pag->pagb_lock);\r\nxfs_perag_put(pag);\r\n}\r\npag = xfs_perag_get(mp, busyp->agno);\r\nspin_lock(&pag->pagb_lock);\r\nagno = busyp->agno;\r\n}\r\nif (do_discard && busyp->length &&\r\n!(busyp->flags & XFS_EXTENT_BUSY_SKIP_DISCARD))\r\nbusyp->flags = XFS_EXTENT_BUSY_DISCARDED;\r\nelse\r\nxfs_extent_busy_clear_one(mp, pag, busyp);\r\n}\r\nif (pag) {\r\nspin_unlock(&pag->pagb_lock);\r\nxfs_perag_put(pag);\r\n}\r\n}\r\nint\r\nxfs_extent_busy_ag_cmp(\r\nvoid *priv,\r\nstruct list_head *a,\r\nstruct list_head *b)\r\n{\r\nreturn container_of(a, struct xfs_extent_busy, list)->agno -\r\ncontainer_of(b, struct xfs_extent_busy, list)->agno;\r\n}
