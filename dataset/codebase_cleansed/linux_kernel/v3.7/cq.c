static int destroy_cq(struct c4iw_rdev *rdev, struct t4_cq *cq,\r\nstruct c4iw_dev_ucontext *uctx)\r\n{\r\nstruct fw_ri_res_wr *res_wr;\r\nstruct fw_ri_res *res;\r\nint wr_len;\r\nstruct c4iw_wr_wait wr_wait;\r\nstruct sk_buff *skb;\r\nint ret;\r\nwr_len = sizeof *res_wr + sizeof *res;\r\nskb = alloc_skb(wr_len, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nset_wr_txq(skb, CPL_PRIORITY_CONTROL, 0);\r\nres_wr = (struct fw_ri_res_wr *)__skb_put(skb, wr_len);\r\nmemset(res_wr, 0, wr_len);\r\nres_wr->op_nres = cpu_to_be32(\r\nFW_WR_OP(FW_RI_RES_WR) |\r\nV_FW_RI_RES_WR_NRES(1) |\r\nFW_WR_COMPL(1));\r\nres_wr->len16_pkd = cpu_to_be32(DIV_ROUND_UP(wr_len, 16));\r\nres_wr->cookie = (unsigned long) &wr_wait;\r\nres = res_wr->res;\r\nres->u.cq.restype = FW_RI_RES_TYPE_CQ;\r\nres->u.cq.op = FW_RI_RES_OP_RESET;\r\nres->u.cq.iqid = cpu_to_be32(cq->cqid);\r\nc4iw_init_wr_wait(&wr_wait);\r\nret = c4iw_ofld_send(rdev, skb);\r\nif (!ret) {\r\nret = c4iw_wait_for_reply(rdev, &wr_wait, 0, 0, __func__);\r\n}\r\nkfree(cq->sw_queue);\r\ndma_free_coherent(&(rdev->lldi.pdev->dev),\r\ncq->memsize, cq->queue,\r\ndma_unmap_addr(cq, mapping));\r\nc4iw_put_cqid(rdev, cq->cqid, uctx);\r\nreturn ret;\r\n}\r\nstatic int create_cq(struct c4iw_rdev *rdev, struct t4_cq *cq,\r\nstruct c4iw_dev_ucontext *uctx)\r\n{\r\nstruct fw_ri_res_wr *res_wr;\r\nstruct fw_ri_res *res;\r\nint wr_len;\r\nint user = (uctx != &rdev->uctx);\r\nstruct c4iw_wr_wait wr_wait;\r\nint ret;\r\nstruct sk_buff *skb;\r\ncq->cqid = c4iw_get_cqid(rdev, uctx);\r\nif (!cq->cqid) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nif (!user) {\r\ncq->sw_queue = kzalloc(cq->memsize, GFP_KERNEL);\r\nif (!cq->sw_queue) {\r\nret = -ENOMEM;\r\ngoto err2;\r\n}\r\n}\r\ncq->queue = dma_alloc_coherent(&rdev->lldi.pdev->dev, cq->memsize,\r\n&cq->dma_addr, GFP_KERNEL);\r\nif (!cq->queue) {\r\nret = -ENOMEM;\r\ngoto err3;\r\n}\r\ndma_unmap_addr_set(cq, mapping, cq->dma_addr);\r\nmemset(cq->queue, 0, cq->memsize);\r\nwr_len = sizeof *res_wr + sizeof *res;\r\nskb = alloc_skb(wr_len, GFP_KERNEL);\r\nif (!skb) {\r\nret = -ENOMEM;\r\ngoto err4;\r\n}\r\nset_wr_txq(skb, CPL_PRIORITY_CONTROL, 0);\r\nres_wr = (struct fw_ri_res_wr *)__skb_put(skb, wr_len);\r\nmemset(res_wr, 0, wr_len);\r\nres_wr->op_nres = cpu_to_be32(\r\nFW_WR_OP(FW_RI_RES_WR) |\r\nV_FW_RI_RES_WR_NRES(1) |\r\nFW_WR_COMPL(1));\r\nres_wr->len16_pkd = cpu_to_be32(DIV_ROUND_UP(wr_len, 16));\r\nres_wr->cookie = (unsigned long) &wr_wait;\r\nres = res_wr->res;\r\nres->u.cq.restype = FW_RI_RES_TYPE_CQ;\r\nres->u.cq.op = FW_RI_RES_OP_WRITE;\r\nres->u.cq.iqid = cpu_to_be32(cq->cqid);\r\nres->u.cq.iqandst_to_iqandstindex = cpu_to_be32(\r\nV_FW_RI_RES_WR_IQANUS(0) |\r\nV_FW_RI_RES_WR_IQANUD(1) |\r\nF_FW_RI_RES_WR_IQANDST |\r\nV_FW_RI_RES_WR_IQANDSTINDEX(*rdev->lldi.rxq_ids));\r\nres->u.cq.iqdroprss_to_iqesize = cpu_to_be16(\r\nF_FW_RI_RES_WR_IQDROPRSS |\r\nV_FW_RI_RES_WR_IQPCIECH(2) |\r\nV_FW_RI_RES_WR_IQINTCNTTHRESH(0) |\r\nF_FW_RI_RES_WR_IQO |\r\nV_FW_RI_RES_WR_IQESIZE(1));\r\nres->u.cq.iqsize = cpu_to_be16(cq->size);\r\nres->u.cq.iqaddr = cpu_to_be64(cq->dma_addr);\r\nc4iw_init_wr_wait(&wr_wait);\r\nret = c4iw_ofld_send(rdev, skb);\r\nif (ret)\r\ngoto err4;\r\nPDBG("%s wait_event wr_wait %p\n", __func__, &wr_wait);\r\nret = c4iw_wait_for_reply(rdev, &wr_wait, 0, 0, __func__);\r\nif (ret)\r\ngoto err4;\r\ncq->gen = 1;\r\ncq->gts = rdev->lldi.gts_reg;\r\ncq->rdev = rdev;\r\nif (user) {\r\ncq->ugts = (u64)pci_resource_start(rdev->lldi.pdev, 2) +\r\n(cq->cqid << rdev->cqshift);\r\ncq->ugts &= PAGE_MASK;\r\n}\r\nreturn 0;\r\nerr4:\r\ndma_free_coherent(&rdev->lldi.pdev->dev, cq->memsize, cq->queue,\r\ndma_unmap_addr(cq, mapping));\r\nerr3:\r\nkfree(cq->sw_queue);\r\nerr2:\r\nc4iw_put_cqid(rdev, cq->cqid, uctx);\r\nerr1:\r\nreturn ret;\r\n}\r\nstatic void insert_recv_cqe(struct t4_wq *wq, struct t4_cq *cq)\r\n{\r\nstruct t4_cqe cqe;\r\nPDBG("%s wq %p cq %p sw_cidx %u sw_pidx %u\n", __func__,\r\nwq, cq, cq->sw_cidx, cq->sw_pidx);\r\nmemset(&cqe, 0, sizeof(cqe));\r\ncqe.header = cpu_to_be32(V_CQE_STATUS(T4_ERR_SWFLUSH) |\r\nV_CQE_OPCODE(FW_RI_SEND) |\r\nV_CQE_TYPE(0) |\r\nV_CQE_SWCQE(1) |\r\nV_CQE_QPID(wq->sq.qid));\r\ncqe.bits_type_ts = cpu_to_be64(V_CQE_GENBIT((u64)cq->gen));\r\ncq->sw_queue[cq->sw_pidx] = cqe;\r\nt4_swcq_produce(cq);\r\n}\r\nint c4iw_flush_rq(struct t4_wq *wq, struct t4_cq *cq, int count)\r\n{\r\nint flushed = 0;\r\nint in_use = wq->rq.in_use - count;\r\nBUG_ON(in_use < 0);\r\nPDBG("%s wq %p cq %p rq.in_use %u skip count %u\n", __func__,\r\nwq, cq, wq->rq.in_use, count);\r\nwhile (in_use--) {\r\ninsert_recv_cqe(wq, cq);\r\nflushed++;\r\n}\r\nreturn flushed;\r\n}\r\nstatic void insert_sq_cqe(struct t4_wq *wq, struct t4_cq *cq,\r\nstruct t4_swsqe *swcqe)\r\n{\r\nstruct t4_cqe cqe;\r\nPDBG("%s wq %p cq %p sw_cidx %u sw_pidx %u\n", __func__,\r\nwq, cq, cq->sw_cidx, cq->sw_pidx);\r\nmemset(&cqe, 0, sizeof(cqe));\r\ncqe.header = cpu_to_be32(V_CQE_STATUS(T4_ERR_SWFLUSH) |\r\nV_CQE_OPCODE(swcqe->opcode) |\r\nV_CQE_TYPE(1) |\r\nV_CQE_SWCQE(1) |\r\nV_CQE_QPID(wq->sq.qid));\r\nCQE_WRID_SQ_IDX(&cqe) = swcqe->idx;\r\ncqe.bits_type_ts = cpu_to_be64(V_CQE_GENBIT((u64)cq->gen));\r\ncq->sw_queue[cq->sw_pidx] = cqe;\r\nt4_swcq_produce(cq);\r\n}\r\nint c4iw_flush_sq(struct t4_wq *wq, struct t4_cq *cq, int count)\r\n{\r\nint flushed = 0;\r\nstruct t4_swsqe *swsqe = &wq->sq.sw_sq[wq->sq.cidx + count];\r\nint in_use = wq->sq.in_use - count;\r\nBUG_ON(in_use < 0);\r\nwhile (in_use--) {\r\nswsqe->signaled = 0;\r\ninsert_sq_cqe(wq, cq, swsqe);\r\nswsqe++;\r\nif (swsqe == (wq->sq.sw_sq + wq->sq.size))\r\nswsqe = wq->sq.sw_sq;\r\nflushed++;\r\n}\r\nreturn flushed;\r\n}\r\nvoid c4iw_flush_hw_cq(struct t4_cq *cq)\r\n{\r\nstruct t4_cqe *cqe = NULL, *swcqe;\r\nint ret;\r\nPDBG("%s cq %p cqid 0x%x\n", __func__, cq, cq->cqid);\r\nret = t4_next_hw_cqe(cq, &cqe);\r\nwhile (!ret) {\r\nPDBG("%s flushing hwcq cidx 0x%x swcq pidx 0x%x\n",\r\n__func__, cq->cidx, cq->sw_pidx);\r\nswcqe = &cq->sw_queue[cq->sw_pidx];\r\n*swcqe = *cqe;\r\nswcqe->header |= cpu_to_be32(V_CQE_SWCQE(1));\r\nt4_swcq_produce(cq);\r\nt4_hwcq_consume(cq);\r\nret = t4_next_hw_cqe(cq, &cqe);\r\n}\r\n}\r\nstatic int cqe_completes_wr(struct t4_cqe *cqe, struct t4_wq *wq)\r\n{\r\nif (CQE_OPCODE(cqe) == FW_RI_TERMINATE)\r\nreturn 0;\r\nif ((CQE_OPCODE(cqe) == FW_RI_RDMA_WRITE) && RQ_TYPE(cqe))\r\nreturn 0;\r\nif ((CQE_OPCODE(cqe) == FW_RI_READ_RESP) && SQ_TYPE(cqe))\r\nreturn 0;\r\nif (CQE_SEND_OPCODE(cqe) && RQ_TYPE(cqe) && t4_rq_empty(wq))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid c4iw_count_scqes(struct t4_cq *cq, struct t4_wq *wq, int *count)\r\n{\r\nstruct t4_cqe *cqe;\r\nu32 ptr;\r\n*count = 0;\r\nptr = cq->sw_cidx;\r\nwhile (ptr != cq->sw_pidx) {\r\ncqe = &cq->sw_queue[ptr];\r\nif ((SQ_TYPE(cqe) || ((CQE_OPCODE(cqe) == FW_RI_READ_RESP) &&\r\nwq->sq.oldest_read)) &&\r\n(CQE_QPID(cqe) == wq->sq.qid))\r\n(*count)++;\r\nif (++ptr == cq->size)\r\nptr = 0;\r\n}\r\nPDBG("%s cq %p count %d\n", __func__, cq, *count);\r\n}\r\nvoid c4iw_count_rcqes(struct t4_cq *cq, struct t4_wq *wq, int *count)\r\n{\r\nstruct t4_cqe *cqe;\r\nu32 ptr;\r\n*count = 0;\r\nPDBG("%s count zero %d\n", __func__, *count);\r\nptr = cq->sw_cidx;\r\nwhile (ptr != cq->sw_pidx) {\r\ncqe = &cq->sw_queue[ptr];\r\nif (RQ_TYPE(cqe) && (CQE_OPCODE(cqe) != FW_RI_READ_RESP) &&\r\n(CQE_QPID(cqe) == wq->sq.qid) && cqe_completes_wr(cqe, wq))\r\n(*count)++;\r\nif (++ptr == cq->size)\r\nptr = 0;\r\n}\r\nPDBG("%s cq %p count %d\n", __func__, cq, *count);\r\n}\r\nstatic void flush_completed_wrs(struct t4_wq *wq, struct t4_cq *cq)\r\n{\r\nstruct t4_swsqe *swsqe;\r\nu16 ptr = wq->sq.cidx;\r\nint count = wq->sq.in_use;\r\nint unsignaled = 0;\r\nswsqe = &wq->sq.sw_sq[ptr];\r\nwhile (count--)\r\nif (!swsqe->signaled) {\r\nif (++ptr == wq->sq.size)\r\nptr = 0;\r\nswsqe = &wq->sq.sw_sq[ptr];\r\nunsignaled++;\r\n} else if (swsqe->complete) {\r\nPDBG("%s moving cqe into swcq sq idx %u cq idx %u\n",\r\n__func__, ptr, cq->sw_pidx);\r\nswsqe->cqe.header |= htonl(V_CQE_SWCQE(1));\r\ncq->sw_queue[cq->sw_pidx] = swsqe->cqe;\r\nt4_swcq_produce(cq);\r\nswsqe->signaled = 0;\r\nwq->sq.in_use -= unsignaled;\r\nbreak;\r\n} else\r\nbreak;\r\n}\r\nstatic void create_read_req_cqe(struct t4_wq *wq, struct t4_cqe *hw_cqe,\r\nstruct t4_cqe *read_cqe)\r\n{\r\nread_cqe->u.scqe.cidx = wq->sq.oldest_read->idx;\r\nread_cqe->len = cpu_to_be32(wq->sq.oldest_read->read_len);\r\nread_cqe->header = htonl(V_CQE_QPID(CQE_QPID(hw_cqe)) |\r\nV_CQE_SWCQE(SW_CQE(hw_cqe)) |\r\nV_CQE_OPCODE(FW_RI_READ_REQ) |\r\nV_CQE_TYPE(1));\r\nread_cqe->bits_type_ts = hw_cqe->bits_type_ts;\r\n}\r\nstatic void advance_oldest_read(struct t4_wq *wq)\r\n{\r\nu32 rptr = wq->sq.oldest_read - wq->sq.sw_sq + 1;\r\nif (rptr == wq->sq.size)\r\nrptr = 0;\r\nwhile (rptr != wq->sq.pidx) {\r\nwq->sq.oldest_read = &wq->sq.sw_sq[rptr];\r\nif (wq->sq.oldest_read->opcode == FW_RI_READ_REQ)\r\nreturn;\r\nif (++rptr == wq->sq.size)\r\nrptr = 0;\r\n}\r\nwq->sq.oldest_read = NULL;\r\n}\r\nstatic int poll_cq(struct t4_wq *wq, struct t4_cq *cq, struct t4_cqe *cqe,\r\nu8 *cqe_flushed, u64 *cookie, u32 *credit)\r\n{\r\nint ret = 0;\r\nstruct t4_cqe *hw_cqe, read_cqe;\r\n*cqe_flushed = 0;\r\n*credit = 0;\r\nret = t4_next_cqe(cq, &hw_cqe);\r\nif (ret)\r\nreturn ret;\r\nPDBG("%s CQE OVF %u qpid 0x%0x genbit %u type %u status 0x%0x"\r\n" opcode 0x%0x len 0x%0x wrid_hi_stag 0x%x wrid_low_msn 0x%x\n",\r\n__func__, CQE_OVFBIT(hw_cqe), CQE_QPID(hw_cqe),\r\nCQE_GENBIT(hw_cqe), CQE_TYPE(hw_cqe), CQE_STATUS(hw_cqe),\r\nCQE_OPCODE(hw_cqe), CQE_LEN(hw_cqe), CQE_WRID_HI(hw_cqe),\r\nCQE_WRID_LOW(hw_cqe));\r\nif (wq == NULL) {\r\nret = -EAGAIN;\r\ngoto skip_cqe;\r\n}\r\nif (RQ_TYPE(hw_cqe) && (CQE_OPCODE(hw_cqe) == FW_RI_READ_RESP)) {\r\nif (!wq->sq.oldest_read) {\r\nif (CQE_STATUS(hw_cqe))\r\nt4_set_wq_in_error(wq);\r\nret = -EAGAIN;\r\ngoto skip_cqe;\r\n}\r\ncreate_read_req_cqe(wq, hw_cqe, &read_cqe);\r\nhw_cqe = &read_cqe;\r\nadvance_oldest_read(wq);\r\n}\r\nif (CQE_STATUS(hw_cqe) || t4_wq_in_error(wq)) {\r\n*cqe_flushed = t4_wq_in_error(wq);\r\nt4_set_wq_in_error(wq);\r\ngoto proc_cqe;\r\n}\r\nif (CQE_OPCODE(hw_cqe) == FW_RI_TERMINATE) {\r\nret = -EAGAIN;\r\ngoto skip_cqe;\r\n}\r\nif (RQ_TYPE(hw_cqe)) {\r\nif (t4_rq_empty(wq)) {\r\nt4_set_wq_in_error(wq);\r\nret = -EAGAIN;\r\ngoto skip_cqe;\r\n}\r\nif (unlikely((CQE_WRID_MSN(hw_cqe) != (wq->rq.msn)))) {\r\nt4_set_wq_in_error(wq);\r\nhw_cqe->header |= htonl(V_CQE_STATUS(T4_ERR_MSN));\r\ngoto proc_cqe;\r\n}\r\ngoto proc_cqe;\r\n}\r\nif (!SW_CQE(hw_cqe) && (CQE_WRID_SQ_IDX(hw_cqe) != wq->sq.cidx)) {\r\nstruct t4_swsqe *swsqe;\r\nPDBG("%s out of order completion going in sw_sq at idx %u\n",\r\n__func__, CQE_WRID_SQ_IDX(hw_cqe));\r\nswsqe = &wq->sq.sw_sq[CQE_WRID_SQ_IDX(hw_cqe)];\r\nswsqe->cqe = *hw_cqe;\r\nswsqe->complete = 1;\r\nret = -EAGAIN;\r\ngoto flush_wq;\r\n}\r\nproc_cqe:\r\n*cqe = *hw_cqe;\r\nif (SQ_TYPE(hw_cqe)) {\r\nwq->sq.cidx = CQE_WRID_SQ_IDX(hw_cqe);\r\nPDBG("%s completing sq idx %u\n", __func__, wq->sq.cidx);\r\n*cookie = wq->sq.sw_sq[wq->sq.cidx].wr_id;\r\nt4_sq_consume(wq);\r\n} else {\r\nPDBG("%s completing rq idx %u\n", __func__, wq->rq.cidx);\r\n*cookie = wq->rq.sw_rq[wq->rq.cidx].wr_id;\r\nBUG_ON(t4_rq_empty(wq));\r\nt4_rq_consume(wq);\r\n}\r\nflush_wq:\r\nflush_completed_wrs(wq, cq);\r\nskip_cqe:\r\nif (SW_CQE(hw_cqe)) {\r\nPDBG("%s cq %p cqid 0x%x skip sw cqe cidx %u\n",\r\n__func__, cq, cq->cqid, cq->sw_cidx);\r\nt4_swcq_consume(cq);\r\n} else {\r\nPDBG("%s cq %p cqid 0x%x skip hw cqe cidx %u\n",\r\n__func__, cq, cq->cqid, cq->cidx);\r\nt4_hwcq_consume(cq);\r\n}\r\nreturn ret;\r\n}\r\nstatic int c4iw_poll_cq_one(struct c4iw_cq *chp, struct ib_wc *wc)\r\n{\r\nstruct c4iw_qp *qhp = NULL;\r\nstruct t4_cqe cqe = {0, 0}, *rd_cqe;\r\nstruct t4_wq *wq;\r\nu32 credit = 0;\r\nu8 cqe_flushed;\r\nu64 cookie = 0;\r\nint ret;\r\nret = t4_next_cqe(&chp->cq, &rd_cqe);\r\nif (ret)\r\nreturn ret;\r\nqhp = get_qhp(chp->rhp, CQE_QPID(rd_cqe));\r\nif (!qhp)\r\nwq = NULL;\r\nelse {\r\nspin_lock(&qhp->lock);\r\nwq = &(qhp->wq);\r\n}\r\nret = poll_cq(wq, &(chp->cq), &cqe, &cqe_flushed, &cookie, &credit);\r\nif (ret)\r\ngoto out;\r\nwc->wr_id = cookie;\r\nwc->qp = &qhp->ibqp;\r\nwc->vendor_err = CQE_STATUS(&cqe);\r\nwc->wc_flags = 0;\r\nPDBG("%s qpid 0x%x type %d opcode %d status 0x%x len %u wrid hi 0x%x "\r\n"lo 0x%x cookie 0x%llx\n", __func__, CQE_QPID(&cqe),\r\nCQE_TYPE(&cqe), CQE_OPCODE(&cqe), CQE_STATUS(&cqe), CQE_LEN(&cqe),\r\nCQE_WRID_HI(&cqe), CQE_WRID_LOW(&cqe), (unsigned long long)cookie);\r\nif (CQE_TYPE(&cqe) == 0) {\r\nif (!CQE_STATUS(&cqe))\r\nwc->byte_len = CQE_LEN(&cqe);\r\nelse\r\nwc->byte_len = 0;\r\nwc->opcode = IB_WC_RECV;\r\nif (CQE_OPCODE(&cqe) == FW_RI_SEND_WITH_INV ||\r\nCQE_OPCODE(&cqe) == FW_RI_SEND_WITH_SE_INV) {\r\nwc->ex.invalidate_rkey = CQE_WRID_STAG(&cqe);\r\nwc->wc_flags |= IB_WC_WITH_INVALIDATE;\r\n}\r\n} else {\r\nswitch (CQE_OPCODE(&cqe)) {\r\ncase FW_RI_RDMA_WRITE:\r\nwc->opcode = IB_WC_RDMA_WRITE;\r\nbreak;\r\ncase FW_RI_READ_REQ:\r\nwc->opcode = IB_WC_RDMA_READ;\r\nwc->byte_len = CQE_LEN(&cqe);\r\nbreak;\r\ncase FW_RI_SEND_WITH_INV:\r\ncase FW_RI_SEND_WITH_SE_INV:\r\nwc->opcode = IB_WC_SEND;\r\nwc->wc_flags |= IB_WC_WITH_INVALIDATE;\r\nbreak;\r\ncase FW_RI_SEND:\r\ncase FW_RI_SEND_WITH_SE:\r\nwc->opcode = IB_WC_SEND;\r\nbreak;\r\ncase FW_RI_BIND_MW:\r\nwc->opcode = IB_WC_BIND_MW;\r\nbreak;\r\ncase FW_RI_LOCAL_INV:\r\nwc->opcode = IB_WC_LOCAL_INV;\r\nbreak;\r\ncase FW_RI_FAST_REGISTER:\r\nwc->opcode = IB_WC_FAST_REG_MR;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR MOD "Unexpected opcode %d "\r\n"in the CQE received for QPID=0x%0x\n",\r\nCQE_OPCODE(&cqe), CQE_QPID(&cqe));\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nif (cqe_flushed)\r\nwc->status = IB_WC_WR_FLUSH_ERR;\r\nelse {\r\nswitch (CQE_STATUS(&cqe)) {\r\ncase T4_ERR_SUCCESS:\r\nwc->status = IB_WC_SUCCESS;\r\nbreak;\r\ncase T4_ERR_STAG:\r\nwc->status = IB_WC_LOC_ACCESS_ERR;\r\nbreak;\r\ncase T4_ERR_PDID:\r\nwc->status = IB_WC_LOC_PROT_ERR;\r\nbreak;\r\ncase T4_ERR_QPID:\r\ncase T4_ERR_ACCESS:\r\nwc->status = IB_WC_LOC_ACCESS_ERR;\r\nbreak;\r\ncase T4_ERR_WRAP:\r\nwc->status = IB_WC_GENERAL_ERR;\r\nbreak;\r\ncase T4_ERR_BOUND:\r\nwc->status = IB_WC_LOC_LEN_ERR;\r\nbreak;\r\ncase T4_ERR_INVALIDATE_SHARED_MR:\r\ncase T4_ERR_INVALIDATE_MR_WITH_MW_BOUND:\r\nwc->status = IB_WC_MW_BIND_ERR;\r\nbreak;\r\ncase T4_ERR_CRC:\r\ncase T4_ERR_MARKER:\r\ncase T4_ERR_PDU_LEN_ERR:\r\ncase T4_ERR_OUT_OF_RQE:\r\ncase T4_ERR_DDP_VERSION:\r\ncase T4_ERR_RDMA_VERSION:\r\ncase T4_ERR_DDP_QUEUE_NUM:\r\ncase T4_ERR_MSN:\r\ncase T4_ERR_TBIT:\r\ncase T4_ERR_MO:\r\ncase T4_ERR_MSN_RANGE:\r\ncase T4_ERR_IRD_OVERFLOW:\r\ncase T4_ERR_OPCODE:\r\ncase T4_ERR_INTERNAL_ERR:\r\nwc->status = IB_WC_FATAL_ERR;\r\nbreak;\r\ncase T4_ERR_SWFLUSH:\r\nwc->status = IB_WC_WR_FLUSH_ERR;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR MOD\r\n"Unexpected cqe_status 0x%x for QPID=0x%0x\n",\r\nCQE_STATUS(&cqe), CQE_QPID(&cqe));\r\nret = -EINVAL;\r\n}\r\n}\r\nout:\r\nif (wq)\r\nspin_unlock(&qhp->lock);\r\nreturn ret;\r\n}\r\nint c4iw_poll_cq(struct ib_cq *ibcq, int num_entries, struct ib_wc *wc)\r\n{\r\nstruct c4iw_cq *chp;\r\nunsigned long flags;\r\nint npolled;\r\nint err = 0;\r\nchp = to_c4iw_cq(ibcq);\r\nspin_lock_irqsave(&chp->lock, flags);\r\nfor (npolled = 0; npolled < num_entries; ++npolled) {\r\ndo {\r\nerr = c4iw_poll_cq_one(chp, wc + npolled);\r\n} while (err == -EAGAIN);\r\nif (err)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&chp->lock, flags);\r\nreturn !err || err == -ENODATA ? npolled : err;\r\n}\r\nint c4iw_destroy_cq(struct ib_cq *ib_cq)\r\n{\r\nstruct c4iw_cq *chp;\r\nstruct c4iw_ucontext *ucontext;\r\nPDBG("%s ib_cq %p\n", __func__, ib_cq);\r\nchp = to_c4iw_cq(ib_cq);\r\nremove_handle(chp->rhp, &chp->rhp->cqidr, chp->cq.cqid);\r\natomic_dec(&chp->refcnt);\r\nwait_event(chp->wait, !atomic_read(&chp->refcnt));\r\nucontext = ib_cq->uobject ? to_c4iw_ucontext(ib_cq->uobject->context)\r\n: NULL;\r\ndestroy_cq(&chp->rhp->rdev, &chp->cq,\r\nucontext ? &ucontext->uctx : &chp->cq.rdev->uctx);\r\nkfree(chp);\r\nreturn 0;\r\n}\r\nstruct ib_cq *c4iw_create_cq(struct ib_device *ibdev, int entries,\r\nint vector, struct ib_ucontext *ib_context,\r\nstruct ib_udata *udata)\r\n{\r\nstruct c4iw_dev *rhp;\r\nstruct c4iw_cq *chp;\r\nstruct c4iw_create_cq_resp uresp;\r\nstruct c4iw_ucontext *ucontext = NULL;\r\nint ret;\r\nsize_t memsize, hwentries;\r\nstruct c4iw_mm_entry *mm, *mm2;\r\nPDBG("%s ib_dev %p entries %d\n", __func__, ibdev, entries);\r\nrhp = to_c4iw_dev(ibdev);\r\nchp = kzalloc(sizeof(*chp), GFP_KERNEL);\r\nif (!chp)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (ib_context)\r\nucontext = to_c4iw_ucontext(ib_context);\r\nentries++;\r\nentries++;\r\nentries = roundup(entries, 16);\r\nhwentries = entries * 2;\r\nif (hwentries < 64)\r\nhwentries = 64;\r\nmemsize = hwentries * sizeof *chp->cq.queue;\r\nif (ucontext) {\r\nmemsize = roundup(memsize, PAGE_SIZE);\r\nhwentries = memsize / sizeof *chp->cq.queue;\r\nwhile (hwentries > T4_MAX_IQ_SIZE) {\r\nmemsize -= PAGE_SIZE;\r\nhwentries = memsize / sizeof *chp->cq.queue;\r\n}\r\n}\r\nchp->cq.size = hwentries;\r\nchp->cq.memsize = memsize;\r\nret = create_cq(&rhp->rdev, &chp->cq,\r\nucontext ? &ucontext->uctx : &rhp->rdev.uctx);\r\nif (ret)\r\ngoto err1;\r\nchp->rhp = rhp;\r\nchp->cq.size--;\r\nchp->ibcq.cqe = entries - 2;\r\nspin_lock_init(&chp->lock);\r\nspin_lock_init(&chp->comp_handler_lock);\r\natomic_set(&chp->refcnt, 1);\r\ninit_waitqueue_head(&chp->wait);\r\nret = insert_handle(rhp, &rhp->cqidr, chp, chp->cq.cqid);\r\nif (ret)\r\ngoto err2;\r\nif (ucontext) {\r\nmm = kmalloc(sizeof *mm, GFP_KERNEL);\r\nif (!mm)\r\ngoto err3;\r\nmm2 = kmalloc(sizeof *mm2, GFP_KERNEL);\r\nif (!mm2)\r\ngoto err4;\r\nuresp.qid_mask = rhp->rdev.cqmask;\r\nuresp.cqid = chp->cq.cqid;\r\nuresp.size = chp->cq.size;\r\nuresp.memsize = chp->cq.memsize;\r\nspin_lock(&ucontext->mmap_lock);\r\nuresp.key = ucontext->key;\r\nucontext->key += PAGE_SIZE;\r\nuresp.gts_key = ucontext->key;\r\nucontext->key += PAGE_SIZE;\r\nspin_unlock(&ucontext->mmap_lock);\r\nret = ib_copy_to_udata(udata, &uresp, sizeof uresp);\r\nif (ret)\r\ngoto err5;\r\nmm->key = uresp.key;\r\nmm->addr = virt_to_phys(chp->cq.queue);\r\nmm->len = chp->cq.memsize;\r\ninsert_mmap(ucontext, mm);\r\nmm2->key = uresp.gts_key;\r\nmm2->addr = chp->cq.ugts;\r\nmm2->len = PAGE_SIZE;\r\ninsert_mmap(ucontext, mm2);\r\n}\r\nPDBG("%s cqid 0x%0x chp %p size %u memsize %zu, dma_addr 0x%0llx\n",\r\n__func__, chp->cq.cqid, chp, chp->cq.size,\r\nchp->cq.memsize,\r\n(unsigned long long) chp->cq.dma_addr);\r\nreturn &chp->ibcq;\r\nerr5:\r\nkfree(mm2);\r\nerr4:\r\nkfree(mm);\r\nerr3:\r\nremove_handle(rhp, &rhp->cqidr, chp->cq.cqid);\r\nerr2:\r\ndestroy_cq(&chp->rhp->rdev, &chp->cq,\r\nucontext ? &ucontext->uctx : &rhp->rdev.uctx);\r\nerr1:\r\nkfree(chp);\r\nreturn ERR_PTR(ret);\r\n}\r\nint c4iw_resize_cq(struct ib_cq *cq, int cqe, struct ib_udata *udata)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nint c4iw_arm_cq(struct ib_cq *ibcq, enum ib_cq_notify_flags flags)\r\n{\r\nstruct c4iw_cq *chp;\r\nint ret;\r\nunsigned long flag;\r\nchp = to_c4iw_cq(ibcq);\r\nspin_lock_irqsave(&chp->lock, flag);\r\nret = t4_arm_cq(&chp->cq,\r\n(flags & IB_CQ_SOLICITED_MASK) == IB_CQ_SOLICITED);\r\nspin_unlock_irqrestore(&chp->lock, flag);\r\nif (ret && !(flags & IB_CQ_REPORT_MISSED_EVENTS))\r\nret = 0;\r\nreturn ret;\r\n}
