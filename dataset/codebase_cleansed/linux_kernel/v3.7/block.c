static struct mmc_blk_data *mmc_blk_get(struct gendisk *disk)\r\n{\r\nstruct mmc_blk_data *md;\r\nmutex_lock(&open_lock);\r\nmd = disk->private_data;\r\nif (md && md->usage == 0)\r\nmd = NULL;\r\nif (md)\r\nmd->usage++;\r\nmutex_unlock(&open_lock);\r\nreturn md;\r\n}\r\nstatic inline int mmc_get_devidx(struct gendisk *disk)\r\n{\r\nint devmaj = MAJOR(disk_devt(disk));\r\nint devidx = MINOR(disk_devt(disk)) / perdev_minors;\r\nif (!devmaj)\r\ndevidx = disk->first_minor / perdev_minors;\r\nreturn devidx;\r\n}\r\nstatic void mmc_blk_put(struct mmc_blk_data *md)\r\n{\r\nmutex_lock(&open_lock);\r\nmd->usage--;\r\nif (md->usage == 0) {\r\nint devidx = mmc_get_devidx(md->disk);\r\nblk_cleanup_queue(md->queue.queue);\r\n__clear_bit(devidx, dev_use);\r\nput_disk(md->disk);\r\nkfree(md);\r\n}\r\nmutex_unlock(&open_lock);\r\n}\r\nstatic ssize_t power_ro_lock_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nstruct mmc_blk_data *md = mmc_blk_get(dev_to_disk(dev));\r\nstruct mmc_card *card = md->queue.card;\r\nint locked = 0;\r\nif (card->ext_csd.boot_ro_lock & EXT_CSD_BOOT_WP_B_PERM_WP_EN)\r\nlocked = 2;\r\nelse if (card->ext_csd.boot_ro_lock & EXT_CSD_BOOT_WP_B_PWR_WP_EN)\r\nlocked = 1;\r\nret = snprintf(buf, PAGE_SIZE, "%d\n", locked);\r\nreturn ret;\r\n}\r\nstatic ssize_t power_ro_lock_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint ret;\r\nstruct mmc_blk_data *md, *part_md;\r\nstruct mmc_card *card;\r\nunsigned long set;\r\nif (kstrtoul(buf, 0, &set))\r\nreturn -EINVAL;\r\nif (set != 1)\r\nreturn count;\r\nmd = mmc_blk_get(dev_to_disk(dev));\r\ncard = md->queue.card;\r\nmmc_claim_host(card->host);\r\nret = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BOOT_WP,\r\ncard->ext_csd.boot_ro_lock |\r\nEXT_CSD_BOOT_WP_B_PWR_WP_EN,\r\ncard->ext_csd.part_time);\r\nif (ret)\r\npr_err("%s: Locking boot partition ro until next power on failed: %d\n", md->disk->disk_name, ret);\r\nelse\r\ncard->ext_csd.boot_ro_lock |= EXT_CSD_BOOT_WP_B_PWR_WP_EN;\r\nmmc_release_host(card->host);\r\nif (!ret) {\r\npr_info("%s: Locking boot partition ro until next power on\n",\r\nmd->disk->disk_name);\r\nset_disk_ro(md->disk, 1);\r\nlist_for_each_entry(part_md, &md->part, part)\r\nif (part_md->area_type == MMC_BLK_DATA_AREA_BOOT) {\r\npr_info("%s: Locking boot partition ro until next power on\n", part_md->disk->disk_name);\r\nset_disk_ro(part_md->disk, 1);\r\n}\r\n}\r\nmmc_blk_put(md);\r\nreturn count;\r\n}\r\nstatic ssize_t force_ro_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nstruct mmc_blk_data *md = mmc_blk_get(dev_to_disk(dev));\r\nret = snprintf(buf, PAGE_SIZE, "%d",\r\nget_disk_ro(dev_to_disk(dev)) ^\r\nmd->read_only);\r\nmmc_blk_put(md);\r\nreturn ret;\r\n}\r\nstatic ssize_t force_ro_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nchar *end;\r\nstruct mmc_blk_data *md = mmc_blk_get(dev_to_disk(dev));\r\nunsigned long set = simple_strtoul(buf, &end, 0);\r\nif (end == buf) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nset_disk_ro(dev_to_disk(dev), set || md->read_only);\r\nret = count;\r\nout:\r\nmmc_blk_put(md);\r\nreturn ret;\r\n}\r\nstatic int mmc_blk_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct mmc_blk_data *md = mmc_blk_get(bdev->bd_disk);\r\nint ret = -ENXIO;\r\nmutex_lock(&block_mutex);\r\nif (md) {\r\nif (md->usage == 2)\r\ncheck_disk_change(bdev);\r\nret = 0;\r\nif ((mode & FMODE_WRITE) && md->read_only) {\r\nmmc_blk_put(md);\r\nret = -EROFS;\r\n}\r\n}\r\nmutex_unlock(&block_mutex);\r\nreturn ret;\r\n}\r\nstatic int mmc_blk_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct mmc_blk_data *md = disk->private_data;\r\nmutex_lock(&block_mutex);\r\nmmc_blk_put(md);\r\nmutex_unlock(&block_mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\nmmc_blk_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\ngeo->cylinders = get_capacity(bdev->bd_disk) / (4 * 16);\r\ngeo->heads = 4;\r\ngeo->sectors = 16;\r\nreturn 0;\r\n}\r\nstatic struct mmc_blk_ioc_data *mmc_blk_ioctl_copy_from_user(\r\nstruct mmc_ioc_cmd __user *user)\r\n{\r\nstruct mmc_blk_ioc_data *idata;\r\nint err;\r\nidata = kzalloc(sizeof(*idata), GFP_KERNEL);\r\nif (!idata) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(&idata->ic, user, sizeof(idata->ic))) {\r\nerr = -EFAULT;\r\ngoto idata_err;\r\n}\r\nidata->buf_bytes = (u64) idata->ic.blksz * idata->ic.blocks;\r\nif (idata->buf_bytes > MMC_IOC_MAX_BYTES) {\r\nerr = -EOVERFLOW;\r\ngoto idata_err;\r\n}\r\nif (!idata->buf_bytes)\r\nreturn idata;\r\nidata->buf = kzalloc(idata->buf_bytes, GFP_KERNEL);\r\nif (!idata->buf) {\r\nerr = -ENOMEM;\r\ngoto idata_err;\r\n}\r\nif (copy_from_user(idata->buf, (void __user *)(unsigned long)\r\nidata->ic.data_ptr, idata->buf_bytes)) {\r\nerr = -EFAULT;\r\ngoto copy_err;\r\n}\r\nreturn idata;\r\ncopy_err:\r\nkfree(idata->buf);\r\nidata_err:\r\nkfree(idata);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int mmc_blk_ioctl_cmd(struct block_device *bdev,\r\nstruct mmc_ioc_cmd __user *ic_ptr)\r\n{\r\nstruct mmc_blk_ioc_data *idata;\r\nstruct mmc_blk_data *md;\r\nstruct mmc_card *card;\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_data data = {0};\r\nstruct mmc_request mrq = {NULL};\r\nstruct scatterlist sg;\r\nint err;\r\nif ((!capable(CAP_SYS_RAWIO)) || (bdev != bdev->bd_contains))\r\nreturn -EPERM;\r\nidata = mmc_blk_ioctl_copy_from_user(ic_ptr);\r\nif (IS_ERR(idata))\r\nreturn PTR_ERR(idata);\r\nmd = mmc_blk_get(bdev->bd_disk);\r\nif (!md) {\r\nerr = -EINVAL;\r\ngoto cmd_err;\r\n}\r\ncard = md->queue.card;\r\nif (IS_ERR(card)) {\r\nerr = PTR_ERR(card);\r\ngoto cmd_done;\r\n}\r\ncmd.opcode = idata->ic.opcode;\r\ncmd.arg = idata->ic.arg;\r\ncmd.flags = idata->ic.flags;\r\nif (idata->buf_bytes) {\r\ndata.sg = &sg;\r\ndata.sg_len = 1;\r\ndata.blksz = idata->ic.blksz;\r\ndata.blocks = idata->ic.blocks;\r\nsg_init_one(data.sg, idata->buf, idata->buf_bytes);\r\nif (idata->ic.write_flag)\r\ndata.flags = MMC_DATA_WRITE;\r\nelse\r\ndata.flags = MMC_DATA_READ;\r\nmmc_set_data_timeout(&data, card);\r\nif (idata->ic.data_timeout_ns)\r\ndata.timeout_ns = idata->ic.data_timeout_ns;\r\nif ((cmd.flags & MMC_RSP_R1B) == MMC_RSP_R1B) {\r\ndata.timeout_ns = idata->ic.cmd_timeout_ms * 1000000;\r\n}\r\nmrq.data = &data;\r\n}\r\nmrq.cmd = &cmd;\r\nmmc_claim_host(card->host);\r\nif (idata->ic.is_acmd) {\r\nerr = mmc_app_cmd(card->host, card);\r\nif (err)\r\ngoto cmd_rel_host;\r\n}\r\nmmc_wait_for_req(card->host, &mrq);\r\nif (cmd.error) {\r\ndev_err(mmc_dev(card->host), "%s: cmd error %d\n",\r\n__func__, cmd.error);\r\nerr = cmd.error;\r\ngoto cmd_rel_host;\r\n}\r\nif (data.error) {\r\ndev_err(mmc_dev(card->host), "%s: data error %d\n",\r\n__func__, data.error);\r\nerr = data.error;\r\ngoto cmd_rel_host;\r\n}\r\nif (idata->ic.postsleep_min_us)\r\nusleep_range(idata->ic.postsleep_min_us, idata->ic.postsleep_max_us);\r\nif (copy_to_user(&(ic_ptr->response), cmd.resp, sizeof(cmd.resp))) {\r\nerr = -EFAULT;\r\ngoto cmd_rel_host;\r\n}\r\nif (!idata->ic.write_flag) {\r\nif (copy_to_user((void __user *)(unsigned long) idata->ic.data_ptr,\r\nidata->buf, idata->buf_bytes)) {\r\nerr = -EFAULT;\r\ngoto cmd_rel_host;\r\n}\r\n}\r\ncmd_rel_host:\r\nmmc_release_host(card->host);\r\ncmd_done:\r\nmmc_blk_put(md);\r\ncmd_err:\r\nkfree(idata->buf);\r\nkfree(idata);\r\nreturn err;\r\n}\r\nstatic int mmc_blk_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint ret = -EINVAL;\r\nif (cmd == MMC_IOC_CMD)\r\nret = mmc_blk_ioctl_cmd(bdev, (struct mmc_ioc_cmd __user *)arg);\r\nreturn ret;\r\n}\r\nstatic int mmc_blk_compat_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn mmc_blk_ioctl(bdev, mode, cmd, (unsigned long) compat_ptr(arg));\r\n}\r\nstatic inline int mmc_blk_part_switch(struct mmc_card *card,\r\nstruct mmc_blk_data *md)\r\n{\r\nint ret;\r\nstruct mmc_blk_data *main_md = mmc_get_drvdata(card);\r\nif (main_md->part_curr == md->part_type)\r\nreturn 0;\r\nif (mmc_card_mmc(card)) {\r\nu8 part_config = card->ext_csd.part_config;\r\npart_config &= ~EXT_CSD_PART_CONFIG_ACC_MASK;\r\npart_config |= md->part_type;\r\nret = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\r\nEXT_CSD_PART_CONFIG, part_config,\r\ncard->ext_csd.part_time);\r\nif (ret)\r\nreturn ret;\r\ncard->ext_csd.part_config = part_config;\r\n}\r\nmain_md->part_curr = md->part_type;\r\nreturn 0;\r\n}\r\nstatic u32 mmc_sd_num_wr_blocks(struct mmc_card *card)\r\n{\r\nint err;\r\nu32 result;\r\n__be32 *blocks;\r\nstruct mmc_request mrq = {NULL};\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_data data = {0};\r\nstruct scatterlist sg;\r\ncmd.opcode = MMC_APP_CMD;\r\ncmd.arg = card->rca << 16;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;\r\nerr = mmc_wait_for_cmd(card->host, &cmd, 0);\r\nif (err)\r\nreturn (u32)-1;\r\nif (!mmc_host_is_spi(card->host) && !(cmd.resp[0] & R1_APP_CMD))\r\nreturn (u32)-1;\r\nmemset(&cmd, 0, sizeof(struct mmc_command));\r\ncmd.opcode = SD_APP_SEND_NUM_WR_BLKS;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;\r\ndata.blksz = 4;\r\ndata.blocks = 1;\r\ndata.flags = MMC_DATA_READ;\r\ndata.sg = &sg;\r\ndata.sg_len = 1;\r\nmmc_set_data_timeout(&data, card);\r\nmrq.cmd = &cmd;\r\nmrq.data = &data;\r\nblocks = kmalloc(4, GFP_KERNEL);\r\nif (!blocks)\r\nreturn (u32)-1;\r\nsg_init_one(&sg, blocks, 4);\r\nmmc_wait_for_req(card->host, &mrq);\r\nresult = ntohl(*blocks);\r\nkfree(blocks);\r\nif (cmd.error || data.error)\r\nresult = (u32)-1;\r\nreturn result;\r\n}\r\nstatic int send_stop(struct mmc_card *card, u32 *status)\r\n{\r\nstruct mmc_command cmd = {0};\r\nint err;\r\ncmd.opcode = MMC_STOP_TRANSMISSION;\r\ncmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;\r\nerr = mmc_wait_for_cmd(card->host, &cmd, 5);\r\nif (err == 0)\r\n*status = cmd.resp[0];\r\nreturn err;\r\n}\r\nstatic int get_card_status(struct mmc_card *card, u32 *status, int retries)\r\n{\r\nstruct mmc_command cmd = {0};\r\nint err;\r\ncmd.opcode = MMC_SEND_STATUS;\r\nif (!mmc_host_is_spi(card->host))\r\ncmd.arg = card->rca << 16;\r\ncmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;\r\nerr = mmc_wait_for_cmd(card->host, &cmd, retries);\r\nif (err == 0)\r\n*status = cmd.resp[0];\r\nreturn err;\r\n}\r\nstatic int mmc_blk_cmd_error(struct request *req, const char *name, int error,\r\nbool status_valid, u32 status)\r\n{\r\nswitch (error) {\r\ncase -EILSEQ:\r\npr_err("%s: %s sending %s command, card status %#x\n",\r\nreq->rq_disk->disk_name, "response CRC error",\r\nname, status);\r\nreturn ERR_RETRY;\r\ncase -ETIMEDOUT:\r\npr_err("%s: %s sending %s command, card status %#x\n",\r\nreq->rq_disk->disk_name, "timed out", name, status);\r\nif (!status_valid)\r\nreturn ERR_RETRY;\r\nif (status & (R1_COM_CRC_ERROR | R1_ILLEGAL_COMMAND))\r\nreturn ERR_RETRY;\r\nreturn ERR_ABORT;\r\ndefault:\r\npr_err("%s: unknown error %d sending read/write command, card status %#x\n",\r\nreq->rq_disk->disk_name, error, status);\r\nreturn ERR_ABORT;\r\n}\r\n}\r\nstatic int mmc_blk_cmd_recovery(struct mmc_card *card, struct request *req,\r\nstruct mmc_blk_request *brq, int *ecc_err)\r\n{\r\nbool prev_cmd_status_valid = true;\r\nu32 status, stop_status = 0;\r\nint err, retry;\r\nif (mmc_card_removed(card))\r\nreturn ERR_NOMEDIUM;\r\nfor (retry = 2; retry >= 0; retry--) {\r\nerr = get_card_status(card, &status, 0);\r\nif (!err)\r\nbreak;\r\nprev_cmd_status_valid = false;\r\npr_err("%s: error %d sending status command, %sing\n",\r\nreq->rq_disk->disk_name, err, retry ? "retry" : "abort");\r\n}\r\nif (err) {\r\nif (mmc_detect_card_removed(card->host))\r\nreturn ERR_NOMEDIUM;\r\nreturn ERR_ABORT;\r\n}\r\nif ((status & R1_CARD_ECC_FAILED) ||\r\n(brq->stop.resp[0] & R1_CARD_ECC_FAILED) ||\r\n(brq->cmd.resp[0] & R1_CARD_ECC_FAILED))\r\n*ecc_err = 1;\r\nif (R1_CURRENT_STATE(status) == R1_STATE_DATA ||\r\nR1_CURRENT_STATE(status) == R1_STATE_RCV) {\r\nerr = send_stop(card, &stop_status);\r\nif (err)\r\npr_err("%s: error %d sending stop command\n",\r\nreq->rq_disk->disk_name, err);\r\nif (err)\r\nreturn ERR_ABORT;\r\nif (stop_status & R1_CARD_ECC_FAILED)\r\n*ecc_err = 1;\r\n}\r\nif (brq->sbc.error)\r\nreturn mmc_blk_cmd_error(req, "SET_BLOCK_COUNT", brq->sbc.error,\r\nprev_cmd_status_valid, status);\r\nif (brq->cmd.error)\r\nreturn mmc_blk_cmd_error(req, "r/w cmd", brq->cmd.error,\r\nprev_cmd_status_valid, status);\r\nif (!brq->stop.error)\r\nreturn ERR_CONTINUE;\r\npr_err("%s: error %d sending stop command, original cmd response %#x, card status %#x\n",\r\nreq->rq_disk->disk_name, brq->stop.error,\r\nbrq->cmd.resp[0], status);\r\nif (stop_status) {\r\nbrq->stop.resp[0] = stop_status;\r\nbrq->stop.error = 0;\r\n}\r\nreturn ERR_CONTINUE;\r\n}\r\nstatic int mmc_blk_reset(struct mmc_blk_data *md, struct mmc_host *host,\r\nint type)\r\n{\r\nint err;\r\nif (md->reset_done & type)\r\nreturn -EEXIST;\r\nmd->reset_done |= type;\r\nerr = mmc_hw_reset(host);\r\nif (err != -EOPNOTSUPP) {\r\nstruct mmc_blk_data *main_md = mmc_get_drvdata(host->card);\r\nint part_err;\r\nmain_md->part_curr = main_md->part_type;\r\npart_err = mmc_blk_part_switch(host->card, md);\r\nif (part_err) {\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic inline void mmc_blk_reset_success(struct mmc_blk_data *md, int type)\r\n{\r\nmd->reset_done &= ~type;\r\n}\r\nstatic int mmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)\r\n{\r\nstruct mmc_blk_data *md = mq->data;\r\nstruct mmc_card *card = md->queue.card;\r\nunsigned int from, nr, arg;\r\nint err = 0, type = MMC_BLK_DISCARD;\r\nif (!mmc_can_erase(card)) {\r\nerr = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nfrom = blk_rq_pos(req);\r\nnr = blk_rq_sectors(req);\r\nif (mmc_can_discard(card))\r\narg = MMC_DISCARD_ARG;\r\nelse if (mmc_can_trim(card))\r\narg = MMC_TRIM_ARG;\r\nelse\r\narg = MMC_ERASE_ARG;\r\nretry:\r\nif (card->quirks & MMC_QUIRK_INAND_CMD38) {\r\nerr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\r\nINAND_CMD38_ARG_EXT_CSD,\r\narg == MMC_TRIM_ARG ?\r\nINAND_CMD38_ARG_TRIM :\r\nINAND_CMD38_ARG_ERASE,\r\n0);\r\nif (err)\r\ngoto out;\r\n}\r\nerr = mmc_erase(card, from, nr, arg);\r\nout:\r\nif (err == -EIO && !mmc_blk_reset(md, card->host, type))\r\ngoto retry;\r\nif (!err)\r\nmmc_blk_reset_success(md, type);\r\nblk_end_request(req, err, blk_rq_bytes(req));\r\nreturn err ? 0 : 1;\r\n}\r\nstatic int mmc_blk_issue_secdiscard_rq(struct mmc_queue *mq,\r\nstruct request *req)\r\n{\r\nstruct mmc_blk_data *md = mq->data;\r\nstruct mmc_card *card = md->queue.card;\r\nunsigned int from, nr, arg, trim_arg, erase_arg;\r\nint err = 0, type = MMC_BLK_SECDISCARD;\r\nif (!(mmc_can_secure_erase_trim(card) || mmc_can_sanitize(card))) {\r\nerr = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nfrom = blk_rq_pos(req);\r\nnr = blk_rq_sectors(req);\r\nif (mmc_can_sanitize(card)) {\r\nerase_arg = MMC_ERASE_ARG;\r\ntrim_arg = MMC_TRIM_ARG;\r\n} else {\r\nerase_arg = MMC_SECURE_ERASE_ARG;\r\ntrim_arg = MMC_SECURE_TRIM1_ARG;\r\n}\r\nif (mmc_erase_group_aligned(card, from, nr))\r\narg = erase_arg;\r\nelse if (mmc_can_trim(card))\r\narg = trim_arg;\r\nelse {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nretry:\r\nif (card->quirks & MMC_QUIRK_INAND_CMD38) {\r\nerr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\r\nINAND_CMD38_ARG_EXT_CSD,\r\narg == MMC_SECURE_TRIM1_ARG ?\r\nINAND_CMD38_ARG_SECTRIM1 :\r\nINAND_CMD38_ARG_SECERASE,\r\n0);\r\nif (err)\r\ngoto out_retry;\r\n}\r\nerr = mmc_erase(card, from, nr, arg);\r\nif (err == -EIO)\r\ngoto out_retry;\r\nif (err)\r\ngoto out;\r\nif (arg == MMC_SECURE_TRIM1_ARG) {\r\nif (card->quirks & MMC_QUIRK_INAND_CMD38) {\r\nerr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\r\nINAND_CMD38_ARG_EXT_CSD,\r\nINAND_CMD38_ARG_SECTRIM2,\r\n0);\r\nif (err)\r\ngoto out_retry;\r\n}\r\nerr = mmc_erase(card, from, nr, MMC_SECURE_TRIM2_ARG);\r\nif (err == -EIO)\r\ngoto out_retry;\r\nif (err)\r\ngoto out;\r\n}\r\nif (mmc_can_sanitize(card))\r\nerr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\r\nEXT_CSD_SANITIZE_START, 1, 0);\r\nout_retry:\r\nif (err && !mmc_blk_reset(md, card->host, type))\r\ngoto retry;\r\nif (!err)\r\nmmc_blk_reset_success(md, type);\r\nout:\r\nblk_end_request(req, err, blk_rq_bytes(req));\r\nreturn err ? 0 : 1;\r\n}\r\nstatic int mmc_blk_issue_flush(struct mmc_queue *mq, struct request *req)\r\n{\r\nstruct mmc_blk_data *md = mq->data;\r\nstruct mmc_card *card = md->queue.card;\r\nint ret = 0;\r\nret = mmc_flush_cache(card);\r\nif (ret)\r\nret = -EIO;\r\nblk_end_request_all(req, ret);\r\nreturn ret ? 0 : 1;\r\n}\r\nstatic inline void mmc_apply_rel_rw(struct mmc_blk_request *brq,\r\nstruct mmc_card *card,\r\nstruct request *req)\r\n{\r\nif (!(card->ext_csd.rel_param & EXT_CSD_WR_REL_PARAM_EN)) {\r\nif (!IS_ALIGNED(brq->cmd.arg, card->ext_csd.rel_sectors))\r\nbrq->data.blocks = 1;\r\nif (brq->data.blocks > card->ext_csd.rel_sectors)\r\nbrq->data.blocks = card->ext_csd.rel_sectors;\r\nelse if (brq->data.blocks < card->ext_csd.rel_sectors)\r\nbrq->data.blocks = 1;\r\n}\r\n}\r\nstatic int mmc_blk_err_check(struct mmc_card *card,\r\nstruct mmc_async_req *areq)\r\n{\r\nstruct mmc_queue_req *mq_mrq = container_of(areq, struct mmc_queue_req,\r\nmmc_active);\r\nstruct mmc_blk_request *brq = &mq_mrq->brq;\r\nstruct request *req = mq_mrq->req;\r\nint ecc_err = 0;\r\nif (brq->sbc.error || brq->cmd.error || brq->stop.error ||\r\nbrq->data.error) {\r\nswitch (mmc_blk_cmd_recovery(card, req, brq, &ecc_err)) {\r\ncase ERR_RETRY:\r\nreturn MMC_BLK_RETRY;\r\ncase ERR_ABORT:\r\nreturn MMC_BLK_ABORT;\r\ncase ERR_NOMEDIUM:\r\nreturn MMC_BLK_NOMEDIUM;\r\ncase ERR_CONTINUE:\r\nbreak;\r\n}\r\n}\r\nif (brq->cmd.resp[0] & CMD_ERRORS) {\r\npr_err("%s: r/w command failed, status = %#x\n",\r\nreq->rq_disk->disk_name, brq->cmd.resp[0]);\r\nreturn MMC_BLK_ABORT;\r\n}\r\nif (!mmc_host_is_spi(card->host) && rq_data_dir(req) != READ) {\r\nu32 status;\r\ndo {\r\nint err = get_card_status(card, &status, 5);\r\nif (err) {\r\npr_err("%s: error %d requesting status\n",\r\nreq->rq_disk->disk_name, err);\r\nreturn MMC_BLK_CMD_ERR;\r\n}\r\n} while (!(status & R1_READY_FOR_DATA) ||\r\n(R1_CURRENT_STATE(status) == R1_STATE_PRG));\r\n}\r\nif (brq->data.error) {\r\npr_err("%s: error %d transferring data, sector %u, nr %u, cmd response %#x, card status %#x\n",\r\nreq->rq_disk->disk_name, brq->data.error,\r\n(unsigned)blk_rq_pos(req),\r\n(unsigned)blk_rq_sectors(req),\r\nbrq->cmd.resp[0], brq->stop.resp[0]);\r\nif (rq_data_dir(req) == READ) {\r\nif (ecc_err)\r\nreturn MMC_BLK_ECC_ERR;\r\nreturn MMC_BLK_DATA_ERR;\r\n} else {\r\nreturn MMC_BLK_CMD_ERR;\r\n}\r\n}\r\nif (!brq->data.bytes_xfered)\r\nreturn MMC_BLK_RETRY;\r\nif (blk_rq_bytes(req) != brq->data.bytes_xfered)\r\nreturn MMC_BLK_PARTIAL;\r\nreturn MMC_BLK_SUCCESS;\r\n}\r\nstatic void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,\r\nstruct mmc_card *card,\r\nint disable_multi,\r\nstruct mmc_queue *mq)\r\n{\r\nu32 readcmd, writecmd;\r\nstruct mmc_blk_request *brq = &mqrq->brq;\r\nstruct request *req = mqrq->req;\r\nstruct mmc_blk_data *md = mq->data;\r\nbool do_data_tag;\r\nbool do_rel_wr = ((req->cmd_flags & REQ_FUA) ||\r\n(req->cmd_flags & REQ_META)) &&\r\n(rq_data_dir(req) == WRITE) &&\r\n(md->flags & MMC_BLK_REL_WR);\r\nmemset(brq, 0, sizeof(struct mmc_blk_request));\r\nbrq->mrq.cmd = &brq->cmd;\r\nbrq->mrq.data = &brq->data;\r\nbrq->cmd.arg = blk_rq_pos(req);\r\nif (!mmc_card_blockaddr(card))\r\nbrq->cmd.arg <<= 9;\r\nbrq->cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;\r\nbrq->data.blksz = 512;\r\nbrq->stop.opcode = MMC_STOP_TRANSMISSION;\r\nbrq->stop.arg = 0;\r\nbrq->stop.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;\r\nbrq->data.blocks = blk_rq_sectors(req);\r\nif (brq->data.blocks > card->host->max_blk_count)\r\nbrq->data.blocks = card->host->max_blk_count;\r\nif (brq->data.blocks > 1) {\r\nif (disable_multi)\r\nbrq->data.blocks = 1;\r\nif (card->host->caps2 & MMC_CAP2_NO_MULTI_READ &&\r\nrq_data_dir(req) == READ)\r\nbrq->data.blocks = 1;\r\n}\r\nif (brq->data.blocks > 1 || do_rel_wr) {\r\nif (!mmc_host_is_spi(card->host) ||\r\nrq_data_dir(req) == READ)\r\nbrq->mrq.stop = &brq->stop;\r\nreadcmd = MMC_READ_MULTIPLE_BLOCK;\r\nwritecmd = MMC_WRITE_MULTIPLE_BLOCK;\r\n} else {\r\nbrq->mrq.stop = NULL;\r\nreadcmd = MMC_READ_SINGLE_BLOCK;\r\nwritecmd = MMC_WRITE_BLOCK;\r\n}\r\nif (rq_data_dir(req) == READ) {\r\nbrq->cmd.opcode = readcmd;\r\nbrq->data.flags |= MMC_DATA_READ;\r\n} else {\r\nbrq->cmd.opcode = writecmd;\r\nbrq->data.flags |= MMC_DATA_WRITE;\r\n}\r\nif (do_rel_wr)\r\nmmc_apply_rel_rw(brq, card, req);\r\ndo_data_tag = (card->ext_csd.data_tag_unit_size) &&\r\n(req->cmd_flags & REQ_META) &&\r\n(rq_data_dir(req) == WRITE) &&\r\n((brq->data.blocks * brq->data.blksz) >=\r\ncard->ext_csd.data_tag_unit_size);\r\nif ((md->flags & MMC_BLK_CMD23) && mmc_op_multi(brq->cmd.opcode) &&\r\n(do_rel_wr || !(card->quirks & MMC_QUIRK_BLK_NO_CMD23) ||\r\ndo_data_tag)) {\r\nbrq->sbc.opcode = MMC_SET_BLOCK_COUNT;\r\nbrq->sbc.arg = brq->data.blocks |\r\n(do_rel_wr ? (1 << 31) : 0) |\r\n(do_data_tag ? (1 << 29) : 0);\r\nbrq->sbc.flags = MMC_RSP_R1 | MMC_CMD_AC;\r\nbrq->mrq.sbc = &brq->sbc;\r\n}\r\nmmc_set_data_timeout(&brq->data, card);\r\nbrq->data.sg = mqrq->sg;\r\nbrq->data.sg_len = mmc_queue_map_sg(mq, mqrq);\r\nif (brq->data.blocks != blk_rq_sectors(req)) {\r\nint i, data_size = brq->data.blocks << 9;\r\nstruct scatterlist *sg;\r\nfor_each_sg(brq->data.sg, sg, brq->data.sg_len, i) {\r\ndata_size -= sg->length;\r\nif (data_size <= 0) {\r\nsg->length += data_size;\r\ni++;\r\nbreak;\r\n}\r\n}\r\nbrq->data.sg_len = i;\r\n}\r\nmqrq->mmc_active.mrq = &brq->mrq;\r\nmqrq->mmc_active.err_check = mmc_blk_err_check;\r\nmmc_queue_bounce_pre(mqrq);\r\n}\r\nstatic int mmc_blk_cmd_err(struct mmc_blk_data *md, struct mmc_card *card,\r\nstruct mmc_blk_request *brq, struct request *req,\r\nint ret)\r\n{\r\nif (mmc_card_sd(card)) {\r\nu32 blocks;\r\nblocks = mmc_sd_num_wr_blocks(card);\r\nif (blocks != (u32)-1) {\r\nret = blk_end_request(req, 0, blocks << 9);\r\n}\r\n} else {\r\nret = blk_end_request(req, 0, brq->data.bytes_xfered);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)\r\n{\r\nstruct mmc_blk_data *md = mq->data;\r\nstruct mmc_card *card = md->queue.card;\r\nstruct mmc_blk_request *brq = &mq->mqrq_cur->brq;\r\nint ret = 1, disable_multi = 0, retry = 0, type;\r\nenum mmc_blk_status status;\r\nstruct mmc_queue_req *mq_rq;\r\nstruct request *req = rqc;\r\nstruct mmc_async_req *areq;\r\nif (!rqc && !mq->mqrq_prev->req)\r\nreturn 0;\r\ndo {\r\nif (rqc) {\r\nif ((brq->data.blocks & 0x07) &&\r\n(card->ext_csd.data_sector_size == 4096)) {\r\npr_err("%s: Transfer size is not 4KB sector size aligned\n",\r\nreq->rq_disk->disk_name);\r\ngoto cmd_abort;\r\n}\r\nmmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);\r\nareq = &mq->mqrq_cur->mmc_active;\r\n} else\r\nareq = NULL;\r\nareq = mmc_start_req(card->host, areq, (int *) &status);\r\nif (!areq)\r\nreturn 0;\r\nmq_rq = container_of(areq, struct mmc_queue_req, mmc_active);\r\nbrq = &mq_rq->brq;\r\nreq = mq_rq->req;\r\ntype = rq_data_dir(req) == READ ? MMC_BLK_READ : MMC_BLK_WRITE;\r\nmmc_queue_bounce_post(mq_rq);\r\nswitch (status) {\r\ncase MMC_BLK_SUCCESS:\r\ncase MMC_BLK_PARTIAL:\r\nmmc_blk_reset_success(md, type);\r\nret = blk_end_request(req, 0,\r\nbrq->data.bytes_xfered);\r\nif (status == MMC_BLK_SUCCESS && ret) {\r\npr_err("%s BUG rq_tot %d d_xfer %d\n",\r\n__func__, blk_rq_bytes(req),\r\nbrq->data.bytes_xfered);\r\nrqc = NULL;\r\ngoto cmd_abort;\r\n}\r\nbreak;\r\ncase MMC_BLK_CMD_ERR:\r\nret = mmc_blk_cmd_err(md, card, brq, req, ret);\r\nif (!mmc_blk_reset(md, card->host, type))\r\nbreak;\r\ngoto cmd_abort;\r\ncase MMC_BLK_RETRY:\r\nif (retry++ < 5)\r\nbreak;\r\ncase MMC_BLK_ABORT:\r\nif (!mmc_blk_reset(md, card->host, type))\r\nbreak;\r\ngoto cmd_abort;\r\ncase MMC_BLK_DATA_ERR: {\r\nint err;\r\nerr = mmc_blk_reset(md, card->host, type);\r\nif (!err)\r\nbreak;\r\nif (err == -ENODEV)\r\ngoto cmd_abort;\r\n}\r\ncase MMC_BLK_ECC_ERR:\r\nif (brq->data.blocks > 1) {\r\npr_warning("%s: retrying using single block read\n",\r\nreq->rq_disk->disk_name);\r\ndisable_multi = 1;\r\nbreak;\r\n}\r\nret = blk_end_request(req, -EIO,\r\nbrq->data.blksz);\r\nif (!ret)\r\ngoto start_new_req;\r\nbreak;\r\ncase MMC_BLK_NOMEDIUM:\r\ngoto cmd_abort;\r\n}\r\nif (ret) {\r\nmmc_blk_rw_rq_prep(mq_rq, card, disable_multi, mq);\r\nmmc_start_req(card->host, &mq_rq->mmc_active, NULL);\r\n}\r\n} while (ret);\r\nreturn 1;\r\ncmd_abort:\r\nif (mmc_card_removed(card))\r\nreq->cmd_flags |= REQ_QUIET;\r\nwhile (ret)\r\nret = blk_end_request(req, -EIO, blk_rq_cur_bytes(req));\r\nstart_new_req:\r\nif (rqc) {\r\nmmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);\r\nmmc_start_req(card->host, &mq->mqrq_cur->mmc_active, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)\r\n{\r\nint ret;\r\nstruct mmc_blk_data *md = mq->data;\r\nstruct mmc_card *card = md->queue.card;\r\nif (req && !mq->mqrq_prev->req)\r\nmmc_claim_host(card->host);\r\nret = mmc_blk_part_switch(card, md);\r\nif (ret) {\r\nif (req) {\r\nblk_end_request_all(req, -EIO);\r\n}\r\nret = 0;\r\ngoto out;\r\n}\r\nif (req && req->cmd_flags & REQ_DISCARD) {\r\nif (card->host->areq)\r\nmmc_blk_issue_rw_rq(mq, NULL);\r\nif (req->cmd_flags & REQ_SECURE &&\r\n!(card->quirks & MMC_QUIRK_SEC_ERASE_TRIM_BROKEN))\r\nret = mmc_blk_issue_secdiscard_rq(mq, req);\r\nelse\r\nret = mmc_blk_issue_discard_rq(mq, req);\r\n} else if (req && req->cmd_flags & REQ_FLUSH) {\r\nif (card->host->areq)\r\nmmc_blk_issue_rw_rq(mq, NULL);\r\nret = mmc_blk_issue_flush(mq, req);\r\n} else {\r\nret = mmc_blk_issue_rw_rq(mq, req);\r\n}\r\nout:\r\nif (!req)\r\nmmc_release_host(card->host);\r\nreturn ret;\r\n}\r\nstatic inline int mmc_blk_readonly(struct mmc_card *card)\r\n{\r\nreturn mmc_card_readonly(card) ||\r\n!(card->csd.cmdclass & CCC_BLOCK_WRITE);\r\n}\r\nstatic struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,\r\nstruct device *parent,\r\nsector_t size,\r\nbool default_ro,\r\nconst char *subname,\r\nint area_type)\r\n{\r\nstruct mmc_blk_data *md;\r\nint devidx, ret;\r\ndevidx = find_first_zero_bit(dev_use, max_devices);\r\nif (devidx >= max_devices)\r\nreturn ERR_PTR(-ENOSPC);\r\n__set_bit(devidx, dev_use);\r\nmd = kzalloc(sizeof(struct mmc_blk_data), GFP_KERNEL);\r\nif (!md) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (!subname) {\r\nmd->name_idx = find_first_zero_bit(name_use, max_devices);\r\n__set_bit(md->name_idx, name_use);\r\n} else\r\nmd->name_idx = ((struct mmc_blk_data *)\r\ndev_to_disk(parent)->private_data)->name_idx;\r\nmd->area_type = area_type;\r\nmd->read_only = mmc_blk_readonly(card);\r\nmd->disk = alloc_disk(perdev_minors);\r\nif (md->disk == NULL) {\r\nret = -ENOMEM;\r\ngoto err_kfree;\r\n}\r\nspin_lock_init(&md->lock);\r\nINIT_LIST_HEAD(&md->part);\r\nmd->usage = 1;\r\nret = mmc_init_queue(&md->queue, card, &md->lock, subname);\r\nif (ret)\r\ngoto err_putdisk;\r\nmd->queue.issue_fn = mmc_blk_issue_rq;\r\nmd->queue.data = md;\r\nmd->disk->major = MMC_BLOCK_MAJOR;\r\nmd->disk->first_minor = devidx * perdev_minors;\r\nmd->disk->fops = &mmc_bdops;\r\nmd->disk->private_data = md;\r\nmd->disk->queue = md->queue.queue;\r\nmd->disk->driverfs_dev = parent;\r\nset_disk_ro(md->disk, md->read_only || default_ro);\r\nsnprintf(md->disk->disk_name, sizeof(md->disk->disk_name),\r\n"mmcblk%d%s", md->name_idx, subname ? subname : "");\r\nif (mmc_card_mmc(card))\r\nblk_queue_logical_block_size(md->queue.queue,\r\ncard->ext_csd.data_sector_size);\r\nelse\r\nblk_queue_logical_block_size(md->queue.queue, 512);\r\nset_capacity(md->disk, size);\r\nif (mmc_host_cmd23(card->host)) {\r\nif (mmc_card_mmc(card) ||\r\n(mmc_card_sd(card) &&\r\ncard->scr.cmds & SD_SCR_CMD23_SUPPORT))\r\nmd->flags |= MMC_BLK_CMD23;\r\n}\r\nif (mmc_card_mmc(card) &&\r\nmd->flags & MMC_BLK_CMD23 &&\r\n((card->ext_csd.rel_param & EXT_CSD_WR_REL_PARAM_EN) ||\r\ncard->ext_csd.rel_sectors)) {\r\nmd->flags |= MMC_BLK_REL_WR;\r\nblk_queue_flush(md->queue.queue, REQ_FLUSH | REQ_FUA);\r\n}\r\nreturn md;\r\nerr_putdisk:\r\nput_disk(md->disk);\r\nerr_kfree:\r\nkfree(md);\r\nout:\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic struct mmc_blk_data *mmc_blk_alloc(struct mmc_card *card)\r\n{\r\nsector_t size;\r\nstruct mmc_blk_data *md;\r\nif (!mmc_card_sd(card) && mmc_card_blockaddr(card)) {\r\nsize = card->ext_csd.sectors;\r\n} else {\r\nsize = card->csd.capacity << (card->csd.read_blkbits - 9);\r\n}\r\nmd = mmc_blk_alloc_req(card, &card->dev, size, false, NULL,\r\nMMC_BLK_DATA_AREA_MAIN);\r\nreturn md;\r\n}\r\nstatic int mmc_blk_alloc_part(struct mmc_card *card,\r\nstruct mmc_blk_data *md,\r\nunsigned int part_type,\r\nsector_t size,\r\nbool default_ro,\r\nconst char *subname,\r\nint area_type)\r\n{\r\nchar cap_str[10];\r\nstruct mmc_blk_data *part_md;\r\npart_md = mmc_blk_alloc_req(card, disk_to_dev(md->disk), size, default_ro,\r\nsubname, area_type);\r\nif (IS_ERR(part_md))\r\nreturn PTR_ERR(part_md);\r\npart_md->part_type = part_type;\r\nlist_add(&part_md->part, &md->part);\r\nstring_get_size((u64)get_capacity(part_md->disk) << 9, STRING_UNITS_2,\r\ncap_str, sizeof(cap_str));\r\npr_info("%s: %s %s partition %u %s\n",\r\npart_md->disk->disk_name, mmc_card_id(card),\r\nmmc_card_name(card), part_md->part_type, cap_str);\r\nreturn 0;\r\n}\r\nstatic int mmc_blk_alloc_parts(struct mmc_card *card, struct mmc_blk_data *md)\r\n{\r\nint idx, ret = 0;\r\nif (!mmc_card_mmc(card))\r\nreturn 0;\r\nfor (idx = 0; idx < card->nr_parts; idx++) {\r\nif (card->part[idx].size) {\r\nret = mmc_blk_alloc_part(card, md,\r\ncard->part[idx].part_cfg,\r\ncard->part[idx].size >> 9,\r\ncard->part[idx].force_ro,\r\ncard->part[idx].name,\r\ncard->part[idx].area_type);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void mmc_blk_remove_req(struct mmc_blk_data *md)\r\n{\r\nstruct mmc_card *card;\r\nif (md) {\r\ncard = md->queue.card;\r\nif (md->disk->flags & GENHD_FL_UP) {\r\ndevice_remove_file(disk_to_dev(md->disk), &md->force_ro);\r\nif ((md->area_type & MMC_BLK_DATA_AREA_BOOT) &&\r\ncard->ext_csd.boot_ro_lockable)\r\ndevice_remove_file(disk_to_dev(md->disk),\r\n&md->power_ro_lock);\r\ndel_gendisk(md->disk);\r\n}\r\nmmc_cleanup_queue(&md->queue);\r\nmmc_blk_put(md);\r\n}\r\n}\r\nstatic void mmc_blk_remove_parts(struct mmc_card *card,\r\nstruct mmc_blk_data *md)\r\n{\r\nstruct list_head *pos, *q;\r\nstruct mmc_blk_data *part_md;\r\n__clear_bit(md->name_idx, name_use);\r\nlist_for_each_safe(pos, q, &md->part) {\r\npart_md = list_entry(pos, struct mmc_blk_data, part);\r\nlist_del(pos);\r\nmmc_blk_remove_req(part_md);\r\n}\r\n}\r\nstatic int mmc_add_disk(struct mmc_blk_data *md)\r\n{\r\nint ret;\r\nstruct mmc_card *card = md->queue.card;\r\nadd_disk(md->disk);\r\nmd->force_ro.show = force_ro_show;\r\nmd->force_ro.store = force_ro_store;\r\nsysfs_attr_init(&md->force_ro.attr);\r\nmd->force_ro.attr.name = "force_ro";\r\nmd->force_ro.attr.mode = S_IRUGO | S_IWUSR;\r\nret = device_create_file(disk_to_dev(md->disk), &md->force_ro);\r\nif (ret)\r\ngoto force_ro_fail;\r\nif ((md->area_type & MMC_BLK_DATA_AREA_BOOT) &&\r\ncard->ext_csd.boot_ro_lockable) {\r\numode_t mode;\r\nif (card->ext_csd.boot_ro_lock & EXT_CSD_BOOT_WP_B_PWR_WP_DIS)\r\nmode = S_IRUGO;\r\nelse\r\nmode = S_IRUGO | S_IWUSR;\r\nmd->power_ro_lock.show = power_ro_lock_show;\r\nmd->power_ro_lock.store = power_ro_lock_store;\r\nsysfs_attr_init(&md->power_ro_lock.attr);\r\nmd->power_ro_lock.attr.mode = mode;\r\nmd->power_ro_lock.attr.name =\r\n"ro_lock_until_next_power_on";\r\nret = device_create_file(disk_to_dev(md->disk),\r\n&md->power_ro_lock);\r\nif (ret)\r\ngoto power_ro_lock_fail;\r\n}\r\nreturn ret;\r\npower_ro_lock_fail:\r\ndevice_remove_file(disk_to_dev(md->disk), &md->force_ro);\r\nforce_ro_fail:\r\ndel_gendisk(md->disk);\r\nreturn ret;\r\n}\r\nstatic int mmc_blk_probe(struct mmc_card *card)\r\n{\r\nstruct mmc_blk_data *md, *part_md;\r\nchar cap_str[10];\r\nif (!(card->csd.cmdclass & CCC_BLOCK_READ))\r\nreturn -ENODEV;\r\nmd = mmc_blk_alloc(card);\r\nif (IS_ERR(md))\r\nreturn PTR_ERR(md);\r\nstring_get_size((u64)get_capacity(md->disk) << 9, STRING_UNITS_2,\r\ncap_str, sizeof(cap_str));\r\npr_info("%s: %s %s %s %s\n",\r\nmd->disk->disk_name, mmc_card_id(card), mmc_card_name(card),\r\ncap_str, md->read_only ? "(ro)" : "");\r\nif (mmc_blk_alloc_parts(card, md))\r\ngoto out;\r\nmmc_set_drvdata(card, md);\r\nmmc_fixup_device(card, blk_fixups);\r\nif (mmc_add_disk(md))\r\ngoto out;\r\nlist_for_each_entry(part_md, &md->part, part) {\r\nif (mmc_add_disk(part_md))\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nmmc_blk_remove_parts(card, md);\r\nmmc_blk_remove_req(md);\r\nreturn 0;\r\n}\r\nstatic void mmc_blk_remove(struct mmc_card *card)\r\n{\r\nstruct mmc_blk_data *md = mmc_get_drvdata(card);\r\nmmc_blk_remove_parts(card, md);\r\nmmc_claim_host(card->host);\r\nmmc_blk_part_switch(card, md);\r\nmmc_release_host(card->host);\r\nmmc_blk_remove_req(md);\r\nmmc_set_drvdata(card, NULL);\r\n}\r\nstatic int mmc_blk_suspend(struct mmc_card *card)\r\n{\r\nstruct mmc_blk_data *part_md;\r\nstruct mmc_blk_data *md = mmc_get_drvdata(card);\r\nif (md) {\r\nmmc_queue_suspend(&md->queue);\r\nlist_for_each_entry(part_md, &md->part, part) {\r\nmmc_queue_suspend(&part_md->queue);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mmc_blk_resume(struct mmc_card *card)\r\n{\r\nstruct mmc_blk_data *part_md;\r\nstruct mmc_blk_data *md = mmc_get_drvdata(card);\r\nif (md) {\r\nmd->part_curr = md->part_type;\r\nmmc_queue_resume(&md->queue);\r\nlist_for_each_entry(part_md, &md->part, part) {\r\nmmc_queue_resume(&part_md->queue);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init mmc_blk_init(void)\r\n{\r\nint res;\r\nif (perdev_minors != CONFIG_MMC_BLOCK_MINORS)\r\npr_info("mmcblk: using %d minors per device\n", perdev_minors);\r\nmax_devices = 256 / perdev_minors;\r\nres = register_blkdev(MMC_BLOCK_MAJOR, "mmc");\r\nif (res)\r\ngoto out;\r\nres = mmc_register_driver(&mmc_driver);\r\nif (res)\r\ngoto out2;\r\nreturn 0;\r\nout2:\r\nunregister_blkdev(MMC_BLOCK_MAJOR, "mmc");\r\nout:\r\nreturn res;\r\n}\r\nstatic void __exit mmc_blk_exit(void)\r\n{\r\nmmc_unregister_driver(&mmc_driver);\r\nunregister_blkdev(MMC_BLOCK_MAJOR, "mmc");\r\n}
