static u32 hpt37x_find_mode(struct ata_port *ap, int speed)\r\n{\r\nstruct hpt_clock *clocks = ap->host->private_data;\r\nwhile (clocks->xfer_speed) {\r\nif (clocks->xfer_speed == speed)\r\nreturn clocks->timing;\r\nclocks++;\r\n}\r\nBUG();\r\nreturn 0xffffffffU;\r\n}\r\nstatic int hpt_dma_blacklisted(const struct ata_device *dev, char *modestr,\r\nconst char * const list[])\r\n{\r\nunsigned char model_num[ATA_ID_PROD_LEN + 1];\r\nint i = 0;\r\nata_id_c_string(dev->id, model_num, ATA_ID_PROD, sizeof(model_num));\r\nwhile (list[i] != NULL) {\r\nif (!strcmp(list[i], model_num)) {\r\npr_warn("%s is not supported for %s\n",\r\nmodestr, list[i]);\r\nreturn 1;\r\n}\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long hpt370_filter(struct ata_device *adev, unsigned long mask)\r\n{\r\nif (adev->class == ATA_DEV_ATA) {\r\nif (hpt_dma_blacklisted(adev, "UDMA", bad_ata33))\r\nmask &= ~ATA_MASK_UDMA;\r\nif (hpt_dma_blacklisted(adev, "UDMA100", bad_ata100_5))\r\nmask &= ~(0xE0 << ATA_SHIFT_UDMA);\r\n}\r\nreturn mask;\r\n}\r\nstatic unsigned long hpt370a_filter(struct ata_device *adev, unsigned long mask)\r\n{\r\nif (adev->class == ATA_DEV_ATA) {\r\nif (hpt_dma_blacklisted(adev, "UDMA100", bad_ata100_5))\r\nmask &= ~(0xE0 << ATA_SHIFT_UDMA);\r\n}\r\nreturn mask;\r\n}\r\nstatic unsigned long hpt372_filter(struct ata_device *adev, unsigned long mask)\r\n{\r\nif (ata_id_is_sata(adev->id))\r\nmask &= ~((0xE << ATA_SHIFT_UDMA) | ATA_MASK_MWDMA);\r\nreturn mask;\r\n}\r\nstatic int hpt37x_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu8 scr2, ata66;\r\npci_read_config_byte(pdev, 0x5B, &scr2);\r\npci_write_config_byte(pdev, 0x5B, scr2 & ~0x01);\r\nudelay(10);\r\npci_read_config_byte(pdev, 0x5A, &ata66);\r\npci_write_config_byte(pdev, 0x5B, scr2);\r\nif (ata66 & (2 >> ap->port_no))\r\nreturn ATA_CBL_PATA40;\r\nelse\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic int hpt374_fn1_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nunsigned int mcrbase = 0x50 + 4 * ap->port_no;\r\nu16 mcr3;\r\nu8 ata66;\r\npci_read_config_word(pdev, mcrbase + 2, &mcr3);\r\npci_write_config_word(pdev, mcrbase + 2, mcr3 | 0x8000);\r\npci_read_config_byte(pdev, 0x5A, &ata66);\r\npci_write_config_word(pdev, mcrbase + 2, mcr3);\r\nif (ata66 & (2 >> ap->port_no))\r\nreturn ATA_CBL_PATA40;\r\nelse\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic int hpt37x_pre_reset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstatic const struct pci_bits hpt37x_enable_bits[] = {\r\n{ 0x50, 1, 0x04, 0x04 },\r\n{ 0x54, 1, 0x04, 0x04 }\r\n};\r\nif (!pci_test_config_bits(pdev, &hpt37x_enable_bits[ap->port_no]))\r\nreturn -ENOENT;\r\npci_write_config_byte(pdev, 0x50 + 4 * ap->port_no, 0x37);\r\nudelay(100);\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic void hpt370_set_mode(struct ata_port *ap, struct ata_device *adev,\r\nu8 mode)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu32 addr1, addr2;\r\nu32 reg, timing, mask;\r\nu8 fast;\r\naddr1 = 0x40 + 4 * (adev->devno + 2 * ap->port_no);\r\naddr2 = 0x51 + 4 * ap->port_no;\r\npci_read_config_byte(pdev, addr2, &fast);\r\nfast &= ~0x02;\r\nfast |= 0x01;\r\npci_write_config_byte(pdev, addr2, fast);\r\nif (mode < XFER_MW_DMA_0)\r\nmask = 0xcfc3ffff;\r\nelse if (mode < XFER_UDMA_0)\r\nmask = 0x31c001ff;\r\nelse\r\nmask = 0x303c0000;\r\ntiming = hpt37x_find_mode(ap, mode);\r\npci_read_config_dword(pdev, addr1, &reg);\r\nreg = (reg & ~mask) | (timing & mask);\r\npci_write_config_dword(pdev, addr1, reg);\r\n}\r\nstatic void hpt370_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nhpt370_set_mode(ap, adev, adev->pio_mode);\r\n}\r\nstatic void hpt370_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nhpt370_set_mode(ap, adev, adev->dma_mode);\r\n}\r\nstatic void hpt370_bmdma_stop(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nvoid __iomem *bmdma = ap->ioaddr.bmdma_addr;\r\nu8 dma_stat = ioread8(bmdma + ATA_DMA_STATUS);\r\nu8 dma_cmd;\r\nif (dma_stat & ATA_DMA_ACTIVE) {\r\nudelay(20);\r\ndma_stat = ioread8(bmdma + ATA_DMA_STATUS);\r\n}\r\nif (dma_stat & ATA_DMA_ACTIVE) {\r\npci_write_config_byte(pdev, 0x50 + 4 * ap->port_no, 0x37);\r\nudelay(10);\r\ndma_cmd = ioread8(bmdma + ATA_DMA_CMD);\r\niowrite8(dma_cmd & ~ATA_DMA_START, bmdma + ATA_DMA_CMD);\r\ndma_stat = ioread8(bmdma + ATA_DMA_STATUS);\r\niowrite8(dma_stat | ATA_DMA_INTR | ATA_DMA_ERR,\r\nbmdma + ATA_DMA_STATUS);\r\npci_write_config_byte(pdev, 0x50 + 4 * ap->port_no, 0x37);\r\nudelay(10);\r\n}\r\nata_bmdma_stop(qc);\r\n}\r\nstatic void hpt372_set_mode(struct ata_port *ap, struct ata_device *adev,\r\nu8 mode)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu32 addr1, addr2;\r\nu32 reg, timing, mask;\r\nu8 fast;\r\naddr1 = 0x40 + 4 * (adev->devno + 2 * ap->port_no);\r\naddr2 = 0x51 + 4 * ap->port_no;\r\npci_read_config_byte(pdev, addr2, &fast);\r\nfast &= ~0x07;\r\npci_write_config_byte(pdev, addr2, fast);\r\nif (mode < XFER_MW_DMA_0)\r\nmask = 0xcfc3ffff;\r\nelse if (mode < XFER_UDMA_0)\r\nmask = 0x31c001ff;\r\nelse\r\nmask = 0x303c0000;\r\ntiming = hpt37x_find_mode(ap, mode);\r\npci_read_config_dword(pdev, addr1, &reg);\r\nreg = (reg & ~mask) | (timing & mask);\r\npci_write_config_dword(pdev, addr1, reg);\r\n}\r\nstatic void hpt372_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nhpt372_set_mode(ap, adev, adev->pio_mode);\r\n}\r\nstatic void hpt372_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nhpt372_set_mode(ap, adev, adev->dma_mode);\r\n}\r\nstatic void hpt37x_bmdma_stop(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint mscreg = 0x50 + 4 * ap->port_no;\r\nu8 bwsr_stat, msc_stat;\r\npci_read_config_byte(pdev, 0x6A, &bwsr_stat);\r\npci_read_config_byte(pdev, mscreg, &msc_stat);\r\nif (bwsr_stat & (1 << ap->port_no))\r\npci_write_config_byte(pdev, mscreg, msc_stat | 0x30);\r\nata_bmdma_stop(qc);\r\n}\r\nstatic int hpt37x_clock_slot(unsigned int freq, unsigned int base)\r\n{\r\nunsigned int f = (base * freq) / 192;\r\nif (f < 40)\r\nreturn 0;\r\nif (f < 45)\r\nreturn 1;\r\nif (f < 55)\r\nreturn 2;\r\nreturn 3;\r\n}\r\nstatic int hpt37x_calibrate_dpll(struct pci_dev *dev)\r\n{\r\nu8 reg5b;\r\nu32 reg5c;\r\nint tries;\r\nfor (tries = 0; tries < 0x5000; tries++) {\r\nudelay(50);\r\npci_read_config_byte(dev, 0x5b, &reg5b);\r\nif (reg5b & 0x80) {\r\nfor (tries = 0; tries < 0x1000; tries++) {\r\npci_read_config_byte(dev, 0x5b, &reg5b);\r\nif ((reg5b & 0x80) == 0)\r\nreturn 0;\r\n}\r\npci_read_config_dword(dev, 0x5c, &reg5c);\r\npci_write_config_dword(dev, 0x5c, reg5c & ~0x100);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 hpt374_read_freq(struct pci_dev *pdev)\r\n{\r\nu32 freq;\r\nunsigned long io_base = pci_resource_start(pdev, 4);\r\nif (PCI_FUNC(pdev->devfn) & 1) {\r\nstruct pci_dev *pdev_0;\r\npdev_0 = pci_get_slot(pdev->bus, pdev->devfn - 1);\r\nif (pdev_0 == NULL)\r\nreturn 0;\r\nio_base = pci_resource_start(pdev_0, 4);\r\nfreq = inl(io_base + 0x90);\r\npci_dev_put(pdev_0);\r\n} else\r\nfreq = inl(io_base + 0x90);\r\nreturn freq;\r\n}\r\nstatic int hpt37x_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info info_hpt370 = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &hpt370_port_ops\r\n};\r\nstatic const struct ata_port_info info_hpt370a = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &hpt370a_port_ops\r\n};\r\nstatic const struct ata_port_info info_hpt370_33 = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA4,\r\n.port_ops = &hpt370_port_ops\r\n};\r\nstatic const struct ata_port_info info_hpt370a_33 = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA4,\r\n.port_ops = &hpt370a_port_ops\r\n};\r\nstatic const struct ata_port_info info_hpt372 = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &hpt372_port_ops\r\n};\r\nstatic const struct ata_port_info info_hpt302 = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &hpt302_port_ops\r\n};\r\nstatic const struct ata_port_info info_hpt374_fn0 = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &hpt372_port_ops\r\n};\r\nstatic const struct ata_port_info info_hpt374_fn1 = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &hpt374_fn1_port_ops\r\n};\r\nstatic const int MHz[4] = { 33, 40, 50, 66 };\r\nvoid *private_data = NULL;\r\nconst struct ata_port_info *ppi[] = { NULL, NULL };\r\nu8 rev = dev->revision;\r\nu8 irqmask;\r\nu8 mcr1;\r\nu32 freq;\r\nint prefer_dpll = 1;\r\nunsigned long iobase = pci_resource_start(dev, 4);\r\nconst struct hpt_chip *chip_table;\r\nint clock_slot;\r\nint rc;\r\nrc = pcim_enable_device(dev);\r\nif (rc)\r\nreturn rc;\r\nswitch (dev->device) {\r\ncase PCI_DEVICE_ID_TTI_HPT366:\r\nif (rev < 3)\r\nreturn -ENODEV;\r\nif (rev == 6)\r\nreturn -ENODEV;\r\nswitch (rev) {\r\ncase 3:\r\nppi[0] = &info_hpt370;\r\nchip_table = &hpt370;\r\nprefer_dpll = 0;\r\nbreak;\r\ncase 4:\r\nppi[0] = &info_hpt370a;\r\nchip_table = &hpt370a;\r\nprefer_dpll = 0;\r\nbreak;\r\ncase 5:\r\nppi[0] = &info_hpt372;\r\nchip_table = &hpt372;\r\nbreak;\r\ndefault:\r\npr_err("Unknown HPT366 subtype, please report (%d)\n",\r\nrev);\r\nreturn -ENODEV;\r\n}\r\nbreak;\r\ncase PCI_DEVICE_ID_TTI_HPT372:\r\nif (rev >= 2)\r\nreturn -ENODEV;\r\nppi[0] = &info_hpt372;\r\nchip_table = &hpt372a;\r\nbreak;\r\ncase PCI_DEVICE_ID_TTI_HPT302:\r\nif (rev > 1)\r\nreturn -ENODEV;\r\nppi[0] = &info_hpt302;\r\nchip_table = &hpt302;\r\nbreak;\r\ncase PCI_DEVICE_ID_TTI_HPT371:\r\nif (rev > 1)\r\nreturn -ENODEV;\r\nppi[0] = &info_hpt302;\r\nchip_table = &hpt371;\r\npci_read_config_byte(dev, 0x50, &mcr1);\r\nmcr1 &= ~0x04;\r\npci_write_config_byte(dev, 0x50, mcr1);\r\nbreak;\r\ncase PCI_DEVICE_ID_TTI_HPT374:\r\nchip_table = &hpt374;\r\nif (!(PCI_FUNC(dev->devfn) & 1))\r\n*ppi = &info_hpt374_fn0;\r\nelse\r\n*ppi = &info_hpt374_fn1;\r\nbreak;\r\ndefault:\r\npr_err("PCI table is bogus, please report (%d)\n", dev->device);\r\nreturn -ENODEV;\r\n}\r\npci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, (L1_CACHE_BYTES / 4));\r\npci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x78);\r\npci_write_config_byte(dev, PCI_MIN_GNT, 0x08);\r\npci_write_config_byte(dev, PCI_MAX_LAT, 0x08);\r\npci_read_config_byte(dev, 0x5A, &irqmask);\r\nirqmask &= ~0x10;\r\npci_write_config_byte(dev, 0x5a, irqmask);\r\npci_write_config_byte(dev, 0x5b, 0x23);\r\nif (chip_table == &hpt372a)\r\noutb(0x0e, iobase + 0x9c);\r\nif (chip_table == &hpt374) {\r\nfreq = hpt374_read_freq(dev);\r\nif (freq == 0)\r\nreturn -ENODEV;\r\n} else\r\nfreq = inl(iobase + 0x90);\r\nif ((freq >> 12) != 0xABCDE) {\r\nint i;\r\nu8 sr;\r\nu32 total = 0;\r\npr_warn("BIOS has not set timing clocks\n");\r\nfor (i = 0; i < 128; i++) {\r\npci_read_config_byte(dev, 0x78, &sr);\r\ntotal += sr & 0x1FF;\r\nudelay(15);\r\n}\r\nfreq = total / 128;\r\n}\r\nfreq &= 0x1FF;\r\nclock_slot = hpt37x_clock_slot(freq, chip_table->base);\r\nif (chip_table->clocks[clock_slot] == NULL || prefer_dpll) {\r\nunsigned int f_low, f_high;\r\nint dpll, adjust;\r\ndpll = (ppi[0]->udma_mask & 0xC0) ? 3 : 2;\r\nf_low = (MHz[clock_slot] * 48) / MHz[dpll];\r\nf_high = f_low + 2;\r\nif (clock_slot > 1)\r\nf_high += 2;\r\npci_write_config_byte(dev, 0x5b, 0x21);\r\npci_write_config_dword(dev, 0x5C,\r\n(f_high << 16) | f_low | 0x100);\r\nfor (adjust = 0; adjust < 8; adjust++) {\r\nif (hpt37x_calibrate_dpll(dev))\r\nbreak;\r\nif (adjust & 1)\r\nf_low -= adjust >> 1;\r\nelse\r\nf_high += adjust >> 1;\r\npci_write_config_dword(dev, 0x5C,\r\n(f_high << 16) | f_low | 0x100);\r\n}\r\nif (adjust == 8) {\r\npr_err("DPLL did not stabilize!\n");\r\nreturn -ENODEV;\r\n}\r\nif (dpll == 3)\r\nprivate_data = (void *)hpt37x_timings_66;\r\nelse\r\nprivate_data = (void *)hpt37x_timings_50;\r\npr_info("bus clock %dMHz, using %dMHz DPLL\n",\r\nMHz[clock_slot], MHz[dpll]);\r\n} else {\r\nprivate_data = (void *)chip_table->clocks[clock_slot];\r\nif (clock_slot < 2 && ppi[0] == &info_hpt370)\r\nppi[0] = &info_hpt370_33;\r\nif (clock_slot < 2 && ppi[0] == &info_hpt370a)\r\nppi[0] = &info_hpt370a_33;\r\npr_info("%s using %dMHz bus clock\n",\r\nchip_table->name, MHz[clock_slot]);\r\n}\r\nreturn ata_pci_bmdma_init_one(dev, ppi, &hpt37x_sht, private_data, 0);\r\n}
