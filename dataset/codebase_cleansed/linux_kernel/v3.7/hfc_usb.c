static inline const char *\r\nsymbolic(struct hfcusb_symbolic_list list[], const int num)\r\n{\r\nint i;\r\nfor (i = 0; list[i].name != NULL; i++)\r\nif (list[i].num == num)\r\nreturn (list[i].name);\r\nreturn "<unknown ERROR>";\r\n}\r\nstatic void\r\nctrl_start_transfer(hfcusb_data *hfc)\r\n{\r\nif (hfc->ctrl_cnt) {\r\nhfc->ctrl_urb->pipe = hfc->ctrl_out_pipe;\r\nhfc->ctrl_urb->setup_packet = (u_char *)&hfc->ctrl_write;\r\nhfc->ctrl_urb->transfer_buffer = NULL;\r\nhfc->ctrl_urb->transfer_buffer_length = 0;\r\nhfc->ctrl_write.wIndex =\r\ncpu_to_le16(hfc->ctrl_buff[hfc->ctrl_out_idx].hfc_reg);\r\nhfc->ctrl_write.wValue =\r\ncpu_to_le16(hfc->ctrl_buff[hfc->ctrl_out_idx].reg_val);\r\nusb_submit_urb(hfc->ctrl_urb, GFP_ATOMIC);\r\n}\r\n}\r\nstatic int\r\nqueue_control_request(hfcusb_data *hfc, __u8 reg, __u8 val, int action)\r\n{\r\nctrl_buft *buf;\r\nif (hfc->ctrl_cnt >= HFC_CTRL_BUFSIZE)\r\nreturn (1);\r\nbuf = &hfc->ctrl_buff[hfc->ctrl_in_idx];\r\nbuf->hfc_reg = reg;\r\nbuf->reg_val = val;\r\nbuf->action = action;\r\nif (++hfc->ctrl_in_idx >= HFC_CTRL_BUFSIZE)\r\nhfc->ctrl_in_idx = 0;\r\nif (++hfc->ctrl_cnt == 1)\r\nctrl_start_transfer(hfc);\r\nreturn (0);\r\n}\r\nstatic void\r\nctrl_complete(struct urb *urb)\r\n{\r\nhfcusb_data *hfc = (hfcusb_data *) urb->context;\r\nurb->dev = hfc->dev;\r\nif (hfc->ctrl_cnt) {\r\nhfc->ctrl_cnt--;\r\nif (++hfc->ctrl_out_idx >= HFC_CTRL_BUFSIZE)\r\nhfc->ctrl_out_idx = 0;\r\nctrl_start_transfer(hfc);\r\n}\r\n}\r\nstatic void\r\nwrite_led(hfcusb_data *hfc, __u8 led_state)\r\n{\r\nif (led_state != hfc->old_led_state) {\r\nhfc->old_led_state = led_state;\r\nqueue_control_request(hfc, HFCUSB_P_DATA, led_state, 1);\r\n}\r\n}\r\nstatic void\r\nset_led_bit(hfcusb_data *hfc, signed short led_bits, int on)\r\n{\r\nif (on) {\r\nif (led_bits < 0)\r\nhfc->led_state &= ~abs(led_bits);\r\nelse\r\nhfc->led_state |= led_bits;\r\n} else {\r\nif (led_bits < 0)\r\nhfc->led_state |= abs(led_bits);\r\nelse\r\nhfc->led_state &= ~led_bits;\r\n}\r\n}\r\nstatic void\r\nhandle_led(hfcusb_data *hfc, int event)\r\n{\r\nhfcsusb_vdata *driver_info =\r\n(hfcsusb_vdata *) hfcusb_idtab[hfc->vend_idx].driver_info;\r\nif (driver_info->led_scheme == LED_OFF)\r\nreturn;\r\nswitch (event) {\r\ncase LED_POWER_ON:\r\nset_led_bit(hfc, driver_info->led_bits[0], 1);\r\nset_led_bit(hfc, driver_info->led_bits[1], 0);\r\nset_led_bit(hfc, driver_info->led_bits[2], 0);\r\nset_led_bit(hfc, driver_info->led_bits[3], 0);\r\nbreak;\r\ncase LED_POWER_OFF:\r\nset_led_bit(hfc, driver_info->led_bits[0], 0);\r\nset_led_bit(hfc, driver_info->led_bits[1], 0);\r\nset_led_bit(hfc, driver_info->led_bits[2], 0);\r\nset_led_bit(hfc, driver_info->led_bits[3], 0);\r\nbreak;\r\ncase LED_S0_ON:\r\nset_led_bit(hfc, driver_info->led_bits[1], 1);\r\nbreak;\r\ncase LED_S0_OFF:\r\nset_led_bit(hfc, driver_info->led_bits[1], 0);\r\nbreak;\r\ncase LED_B1_ON:\r\nset_led_bit(hfc, driver_info->led_bits[2], 1);\r\nbreak;\r\ncase LED_B1_OFF:\r\nset_led_bit(hfc, driver_info->led_bits[2], 0);\r\nbreak;\r\ncase LED_B2_ON:\r\nset_led_bit(hfc, driver_info->led_bits[3], 1);\r\nbreak;\r\ncase LED_B2_OFF:\r\nset_led_bit(hfc, driver_info->led_bits[3], 0);\r\nbreak;\r\n}\r\nwrite_led(hfc, hfc->led_state);\r\n}\r\nstatic void\r\nl1_timer_expire_t3(hfcusb_data *hfc)\r\n{\r\nhfc->d_if.ifc.l1l2(&hfc->d_if.ifc, PH_DEACTIVATE | INDICATION,\r\nNULL);\r\nDBG(HFCUSB_DBG_STATES,\r\n"HFC-S USB: PH_DEACTIVATE | INDICATION sent (T3 expire)");\r\nhfc->l1_activated = 0;\r\nhandle_led(hfc, LED_S0_OFF);\r\nqueue_control_request(hfc, HFCUSB_STATES, 0x10, 1);\r\nqueue_control_request(hfc, HFCUSB_STATES, 3, 1);\r\n}\r\nstatic void\r\nl1_timer_expire_t4(hfcusb_data *hfc)\r\n{\r\nhfc->d_if.ifc.l1l2(&hfc->d_if.ifc, PH_DEACTIVATE | INDICATION,\r\nNULL);\r\nDBG(HFCUSB_DBG_STATES,\r\n"HFC-S USB: PH_DEACTIVATE | INDICATION sent (T4 expire)");\r\nhfc->l1_activated = 0;\r\nhandle_led(hfc, LED_S0_OFF);\r\n}\r\nstatic void\r\ns0_state_handler(hfcusb_data *hfc, __u8 state)\r\n{\r\n__u8 old_state;\r\nold_state = hfc->l1_state;\r\nif (state == old_state || state < 1 || state > 8)\r\nreturn;\r\nDBG(HFCUSB_DBG_STATES, "HFC-S USB: S0 statechange(%d -> %d)",\r\nold_state, state);\r\nif (state < 4 || state == 7 || state == 8) {\r\nif (timer_pending(&hfc->t3_timer))\r\ndel_timer(&hfc->t3_timer);\r\nDBG(HFCUSB_DBG_STATES, "HFC-S USB: T3 deactivated");\r\n}\r\nif (state >= 7) {\r\nif (timer_pending(&hfc->t4_timer))\r\ndel_timer(&hfc->t4_timer);\r\nDBG(HFCUSB_DBG_STATES, "HFC-S USB: T4 deactivated");\r\n}\r\nif (state == 7 && !hfc->l1_activated) {\r\nhfc->d_if.ifc.l1l2(&hfc->d_if.ifc,\r\nPH_ACTIVATE | INDICATION, NULL);\r\nDBG(HFCUSB_DBG_STATES, "HFC-S USB: PH_ACTIVATE | INDICATION sent");\r\nhfc->l1_activated = 1;\r\nhandle_led(hfc, LED_S0_ON);\r\n} else if (state <= 3 ) {\r\nif (old_state == 7 || old_state == 8) {\r\nDBG(HFCUSB_DBG_STATES, "HFC-S USB: T4 activated");\r\nif (!timer_pending(&hfc->t4_timer)) {\r\nhfc->t4_timer.expires =\r\njiffies + (HFC_TIMER_T4 * HZ) / 1000;\r\nadd_timer(&hfc->t4_timer);\r\n}\r\n} else {\r\nhfc->d_if.ifc.l1l2(&hfc->d_if.ifc,\r\nPH_DEACTIVATE | INDICATION,\r\nNULL);\r\nDBG(HFCUSB_DBG_STATES,\r\n"HFC-S USB: PH_DEACTIVATE | INDICATION sent");\r\nhfc->l1_activated = 0;\r\nhandle_led(hfc, LED_S0_OFF);\r\n}\r\n}\r\nhfc->l1_state = state;\r\n}\r\nstatic void\r\nfill_isoc_urb(struct urb *urb, struct usb_device *dev, unsigned int pipe,\r\nvoid *buf, int num_packets, int packet_size, int interval,\r\nusb_complete_t complete, void *context)\r\n{\r\nint k;\r\nurb->dev = dev;\r\nurb->pipe = pipe;\r\nurb->complete = complete;\r\nurb->number_of_packets = num_packets;\r\nurb->transfer_buffer_length = packet_size * num_packets;\r\nurb->context = context;\r\nurb->transfer_buffer = buf;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->actual_length = 0;\r\nurb->interval = interval;\r\nfor (k = 0; k < num_packets; k++) {\r\nurb->iso_frame_desc[k].offset = packet_size * k;\r\nurb->iso_frame_desc[k].length = packet_size;\r\nurb->iso_frame_desc[k].actual_length = 0;\r\n}\r\n}\r\nstatic int\r\nstart_isoc_chain(usb_fifo *fifo, int num_packets_per_urb,\r\nusb_complete_t complete, int packet_size)\r\n{\r\nint i, k, errcode;\r\nDBG(HFCUSB_DBG_INIT, "HFC-S USB: starting ISO-URBs for fifo:%d\n",\r\nfifo->fifonum);\r\nfor (i = 0; i < 2; i++) {\r\nif (!(fifo->iso[i].purb)) {\r\nfifo->iso[i].purb =\r\nusb_alloc_urb(num_packets_per_urb, GFP_KERNEL);\r\nif (!(fifo->iso[i].purb)) {\r\nprintk(KERN_INFO\r\n"alloc urb for fifo %i failed!!!",\r\nfifo->fifonum);\r\n}\r\nfifo->iso[i].owner_fifo = (struct usb_fifo *) fifo;\r\nif (ISO_BUFFER_SIZE >=\r\n(fifo->usb_packet_maxlen *\r\nnum_packets_per_urb)) {\r\nfill_isoc_urb(fifo->iso[i].purb,\r\nfifo->hfc->dev, fifo->pipe,\r\nfifo->iso[i].buffer,\r\nnum_packets_per_urb,\r\nfifo->usb_packet_maxlen,\r\nfifo->intervall, complete,\r\n&fifo->iso[i]);\r\nmemset(fifo->iso[i].buffer, 0,\r\nsizeof(fifo->iso[i].buffer));\r\nfor (k = 0; k < num_packets_per_urb; k++) {\r\nfifo->iso[i].purb->\r\niso_frame_desc[k].offset =\r\nk * packet_size;\r\nfifo->iso[i].purb->\r\niso_frame_desc[k].length =\r\npacket_size;\r\n}\r\n} else {\r\nprintk(KERN_INFO\r\n"HFC-S USB: ISO Buffer size to small!\n");\r\n}\r\n}\r\nfifo->bit_line = BITLINE_INF;\r\nerrcode = usb_submit_urb(fifo->iso[i].purb, GFP_KERNEL);\r\nfifo->active = (errcode >= 0) ? 1 : 0;\r\nif (errcode < 0)\r\nprintk(KERN_INFO "HFC-S USB: usb_submit_urb URB nr:%d, error(%i): '%s'\n",\r\ni, errcode, symbolic(urb_errlist, errcode));\r\n}\r\nreturn (fifo->active);\r\n}\r\nstatic void\r\nstop_isoc_chain(usb_fifo *fifo)\r\n{\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nif (fifo->iso[i].purb) {\r\nDBG(HFCUSB_DBG_INIT,\r\n"HFC-S USB: Stopping iso chain for fifo %i.%i",\r\nfifo->fifonum, i);\r\nusb_kill_urb(fifo->iso[i].purb);\r\nusb_free_urb(fifo->iso[i].purb);\r\nfifo->iso[i].purb = NULL;\r\n}\r\n}\r\nusb_kill_urb(fifo->urb);\r\nusb_free_urb(fifo->urb);\r\nfifo->urb = NULL;\r\nfifo->active = 0;\r\n}\r\nstatic void\r\ntx_iso_complete(struct urb *urb)\r\n{\r\niso_urb_struct *context_iso_urb = (iso_urb_struct *) urb->context;\r\nusb_fifo *fifo = context_iso_urb->owner_fifo;\r\nhfcusb_data *hfc = fifo->hfc;\r\nint k, tx_offset, num_isoc_packets, sink, len, current_len,\r\nerrcode;\r\nint frame_complete, transp_mode, fifon, status;\r\n__u8 threshbit;\r\nfifon = fifo->fifonum;\r\nstatus = urb->status;\r\ntx_offset = 0;\r\nif (status == -EXDEV) {\r\nDBG(HFCUSB_DBG_VERBOSE_USB, "HFC-S USB: tx_iso_complete with -EXDEV"\r\n", urb->status %d, fifonum %d\n",\r\nstatus, fifon);\r\nfor (k = 0; k < iso_packets[fifon]; ++k) {\r\nerrcode = urb->iso_frame_desc[k].status;\r\nif (errcode)\r\nDBG(HFCUSB_DBG_VERBOSE_USB, "HFC-S USB: tx_iso_complete "\r\n"packet %i, status: %i\n",\r\nk, errcode);\r\n}\r\nstatus = 0;\r\n}\r\nif (fifo->active && !status) {\r\ntransp_mode = 0;\r\nif (fifon < 4 && hfc->b_mode[fifon / 2] == L1_MODE_TRANS)\r\ntransp_mode = 1;\r\nthreshbit = (hfc->threshold_mask & (1 << fifon));\r\nnum_isoc_packets = iso_packets[fifon];\r\nif (fifon >= HFCUSB_D_TX) {\r\nsink = (threshbit) ? SINK_DMIN : SINK_DMAX;\r\n} else {\r\nsink = (threshbit) ? SINK_MIN : SINK_MAX;\r\n}\r\nfill_isoc_urb(urb, fifo->hfc->dev, fifo->pipe,\r\ncontext_iso_urb->buffer, num_isoc_packets,\r\nfifo->usb_packet_maxlen, fifo->intervall,\r\ntx_iso_complete, urb->context);\r\nmemset(context_iso_urb->buffer, 0,\r\nsizeof(context_iso_urb->buffer));\r\nframe_complete = 0;\r\nfor (k = 0; k < num_isoc_packets; ++k) {\r\nif (fifo->skbuff) {\r\nlen = fifo->skbuff->len;\r\nfifo->bit_line -= sink;\r\ncurrent_len = (0 - fifo->bit_line) / 8;\r\nif (current_len > 14)\r\ncurrent_len = 14;\r\ncurrent_len =\r\n(len <=\r\ncurrent_len) ? len : current_len;\r\nfifo->bit_line += current_len * 8;\r\ncontext_iso_urb->buffer[tx_offset] = 0;\r\nif (current_len == len) {\r\nif (!transp_mode) {\r\ncontext_iso_urb->\r\nbuffer[tx_offset] = 1;\r\nfifo->bit_line += 32;\r\n}\r\nframe_complete = 1;\r\n}\r\nmemcpy(context_iso_urb->buffer +\r\ntx_offset + 1, fifo->skbuff->data,\r\ncurrent_len);\r\nskb_pull(fifo->skbuff, current_len);\r\nurb->iso_frame_desc[k].offset = tx_offset;\r\nurb->iso_frame_desc[k].length =\r\ncurrent_len + 1;\r\ntx_offset += (current_len + 1);\r\n} else {\r\nurb->iso_frame_desc[k].offset =\r\ntx_offset++;\r\nurb->iso_frame_desc[k].length = 1;\r\nfifo->bit_line -= sink;\r\nif (fifo->bit_line < BITLINE_INF) {\r\nfifo->bit_line = BITLINE_INF;\r\n}\r\n}\r\nif (frame_complete) {\r\nfifo->delete_flg = 1;\r\nfifo->hif->l1l2(fifo->hif,\r\nPH_DATA | CONFIRM,\r\n(void *) (unsigned long) fifo->skbuff->\r\ntruesize);\r\nif (fifo->skbuff && fifo->delete_flg) {\r\ndev_kfree_skb_any(fifo->skbuff);\r\nfifo->skbuff = NULL;\r\nfifo->delete_flg = 0;\r\n}\r\nframe_complete = 0;\r\n}\r\n}\r\nerrcode = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (errcode < 0) {\r\nprintk(KERN_INFO\r\n"HFC-S USB: error submitting ISO URB: %d\n",\r\nerrcode);\r\n}\r\n} else {\r\nif (status && !hfc->disc_flag) {\r\nprintk(KERN_INFO\r\n"HFC-S USB: tx_iso_complete: error(%i): '%s', fifonum=%d\n",\r\nstatus, symbolic(urb_errlist, status), fifon);\r\n}\r\n}\r\n}\r\nstatic void\r\nrx_iso_complete(struct urb *urb)\r\n{\r\niso_urb_struct *context_iso_urb = (iso_urb_struct *) urb->context;\r\nusb_fifo *fifo = context_iso_urb->owner_fifo;\r\nhfcusb_data *hfc = fifo->hfc;\r\nint k, len, errcode, offset, num_isoc_packets, fifon, maxlen,\r\nstatus;\r\nunsigned int iso_status;\r\n__u8 *buf;\r\nstatic __u8 eof[8];\r\nfifon = fifo->fifonum;\r\nstatus = urb->status;\r\nif (urb->status == -EOVERFLOW) {\r\nDBG(HFCUSB_DBG_VERBOSE_USB,\r\n"HFC-USB: ignoring USB DATAOVERRUN fifo(%i)", fifon);\r\nstatus = 0;\r\n}\r\nif (status == -EXDEV) {\r\nDBG(HFCUSB_DBG_VERBOSE_USB, "HFC-S USB: rx_iso_complete with -EXDEV "\r\n"urb->status %d, fifonum %d\n",\r\nstatus, fifon);\r\nstatus = 0;\r\n}\r\nif (fifo->active && !status) {\r\nnum_isoc_packets = iso_packets[fifon];\r\nmaxlen = fifo->usb_packet_maxlen;\r\nfor (k = 0; k < num_isoc_packets; ++k) {\r\nlen = urb->iso_frame_desc[k].actual_length;\r\noffset = urb->iso_frame_desc[k].offset;\r\nbuf = context_iso_urb->buffer + offset;\r\niso_status = urb->iso_frame_desc[k].status;\r\nif (iso_status && !hfc->disc_flag)\r\nDBG(HFCUSB_DBG_VERBOSE_USB,\r\n"HFC-S USB: rx_iso_complete "\r\n"ISO packet %i, status: %i\n",\r\nk, iso_status);\r\nif (fifon == HFCUSB_D_RX) {\r\nDBG(HFCUSB_DBG_VERBOSE_USB,\r\n"HFC-S USB: ISO-D-RX lst_urblen:%2d "\r\n"act_urblen:%2d max-urblen:%2d EOF:0x%0x",\r\nfifo->last_urblen, len, maxlen,\r\neof[5]);\r\nDBG_PACKET(HFCUSB_DBG_VERBOSE_USB, buf, len);\r\n}\r\nif (fifo->last_urblen != maxlen) {\r\nhfc->threshold_mask = buf[1];\r\nif (fifon == HFCUSB_D_RX) {\r\ns0_state_handler(hfc, buf[0] >> 4);\r\n}\r\neof[fifon] = buf[0] & 1;\r\nif (len > 2)\r\ncollect_rx_frame(fifo, buf + 2,\r\nlen - 2,\r\n(len < maxlen) ?\r\neof[fifon] : 0);\r\n} else {\r\ncollect_rx_frame(fifo, buf, len,\r\n(len <\r\nmaxlen) ? eof[fifon] :\r\n0);\r\n}\r\nfifo->last_urblen = len;\r\n}\r\nfill_isoc_urb(urb, fifo->hfc->dev, fifo->pipe,\r\ncontext_iso_urb->buffer, num_isoc_packets,\r\nfifo->usb_packet_maxlen, fifo->intervall,\r\nrx_iso_complete, urb->context);\r\nerrcode = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (errcode < 0) {\r\nprintk(KERN_ERR\r\n"HFC-S USB: error submitting ISO URB: %d\n",\r\nerrcode);\r\n}\r\n} else {\r\nif (status && !hfc->disc_flag) {\r\nprintk(KERN_ERR\r\n"HFC-S USB: rx_iso_complete : "\r\n"urb->status %d, fifonum %d\n",\r\nstatus, fifon);\r\n}\r\n}\r\n}\r\nstatic void\r\ncollect_rx_frame(usb_fifo *fifo, __u8 *data, int len, int finish)\r\n{\r\nhfcusb_data *hfc = fifo->hfc;\r\nint transp_mode, fifon;\r\nfifon = fifo->fifonum;\r\ntransp_mode = 0;\r\nif (fifon < 4 && hfc->b_mode[fifon / 2] == L1_MODE_TRANS)\r\ntransp_mode = 1;\r\nif (!fifo->skbuff) {\r\nfifo->skbuff = dev_alloc_skb(fifo->max_size + 3);\r\nif (!fifo->skbuff) {\r\nprintk(KERN_ERR\r\n"HFC-S USB: cannot allocate buffer for fifo(%d)\n",\r\nfifon);\r\nreturn;\r\n}\r\n}\r\nif (len) {\r\nif (fifo->skbuff->len + len < fifo->max_size) {\r\nmemcpy(skb_put(fifo->skbuff, len), data, len);\r\n} else {\r\nDBG(HFCUSB_DBG_FIFO_ERR,\r\n"HCF-USB: got frame exceeded fifo->max_size(%d) fifo(%d)",\r\nfifo->max_size, fifon);\r\nDBG_SKB(HFCUSB_DBG_VERBOSE_USB, fifo->skbuff);\r\nskb_trim(fifo->skbuff, 0);\r\n}\r\n}\r\nif (transp_mode && fifo->skbuff->len >= 128) {\r\nfifo->hif->l1l2(fifo->hif, PH_DATA | INDICATION,\r\nfifo->skbuff);\r\nfifo->skbuff = NULL;\r\nreturn;\r\n}\r\nif (finish) {\r\nif (fifo->skbuff->len > 3 &&\r\n!fifo->skbuff->data[fifo->skbuff->len - 1]) {\r\nif (fifon == HFCUSB_D_RX) {\r\nDBG(HFCUSB_DBG_DCHANNEL,\r\n"HFC-S USB: D-RX len(%d)", fifo->skbuff->len);\r\nDBG_SKB(HFCUSB_DBG_DCHANNEL, fifo->skbuff);\r\n}\r\nskb_trim(fifo->skbuff, fifo->skbuff->len - 3);\r\nif (fifon == HFCUSB_PCM_RX) {\r\nfifo->hif->l1l2(fifo->hif,\r\nPH_DATA_E | INDICATION,\r\nfifo->skbuff);\r\n} else\r\nfifo->hif->l1l2(fifo->hif,\r\nPH_DATA | INDICATION,\r\nfifo->skbuff);\r\nfifo->skbuff = NULL;\r\n} else {\r\nDBG(HFCUSB_DBG_FIFO_ERR,\r\n"HFC-S USB: ERROR frame len(%d) fifo(%d)",\r\nfifo->skbuff->len, fifon);\r\nDBG_SKB(HFCUSB_DBG_VERBOSE_USB, fifo->skbuff);\r\nskb_trim(fifo->skbuff, 0);\r\n}\r\n}\r\n}\r\nstatic void\r\nrx_int_complete(struct urb *urb)\r\n{\r\nint len;\r\nint status;\r\n__u8 *buf, maxlen, fifon;\r\nusb_fifo *fifo = (usb_fifo *) urb->context;\r\nhfcusb_data *hfc = fifo->hfc;\r\nstatic __u8 eof[8];\r\nurb->dev = hfc->dev;\r\nfifon = fifo->fifonum;\r\nif ((!fifo->active) || (urb->status)) {\r\nDBG(HFCUSB_DBG_INIT, "HFC-S USB: RX-Fifo %i is going down (%i)",\r\nfifon, urb->status);\r\nfifo->urb->interval = 0;\r\nif (fifo->skbuff) {\r\ndev_kfree_skb_any(fifo->skbuff);\r\nfifo->skbuff = NULL;\r\n}\r\nreturn;\r\n}\r\nlen = urb->actual_length;\r\nbuf = fifo->buffer;\r\nmaxlen = fifo->usb_packet_maxlen;\r\nif (fifon == HFCUSB_D_RX) {\r\nDBG(HFCUSB_DBG_VERBOSE_USB,\r\n"HFC-S USB: INT-D-RX lst_urblen:%2d "\r\n"act_urblen:%2d max-urblen:%2d EOF:0x%0x",\r\nfifo->last_urblen, len, maxlen,\r\neof[5]);\r\nDBG_PACKET(HFCUSB_DBG_VERBOSE_USB, buf, len);\r\n}\r\nif (fifo->last_urblen != fifo->usb_packet_maxlen) {\r\nhfc->threshold_mask = buf[1];\r\ns0_state_handler(hfc, buf[0] >> 4);\r\neof[fifon] = buf[0] & 1;\r\nif (len > 2)\r\ncollect_rx_frame(fifo, buf + 2,\r\nurb->actual_length - 2,\r\n(len < maxlen) ? eof[fifon] : 0);\r\n} else {\r\ncollect_rx_frame(fifo, buf, urb->actual_length,\r\n(len < maxlen) ? eof[fifon] : 0);\r\n}\r\nfifo->last_urblen = urb->actual_length;\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status) {\r\nprintk(KERN_INFO\r\n"HFC-S USB: %s error resubmitting URB fifo(%d)\n",\r\n__func__, fifon);\r\n}\r\n}\r\nstatic void\r\nstart_int_fifo(usb_fifo *fifo)\r\n{\r\nint errcode;\r\nDBG(HFCUSB_DBG_INIT, "HFC-S USB: starting RX INT-URB for fifo:%d\n",\r\nfifo->fifonum);\r\nif (!fifo->urb) {\r\nfifo->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!fifo->urb)\r\nreturn;\r\n}\r\nusb_fill_int_urb(fifo->urb, fifo->hfc->dev, fifo->pipe,\r\nfifo->buffer, fifo->usb_packet_maxlen,\r\nrx_int_complete, fifo, fifo->intervall);\r\nfifo->active = 1;\r\nerrcode = usb_submit_urb(fifo->urb, GFP_KERNEL);\r\nif (errcode) {\r\nprintk(KERN_ERR\r\n"HFC-S USB: submit URB error(start_int_info): status:%i\n",\r\nerrcode);\r\nfifo->active = 0;\r\nfifo->skbuff = NULL;\r\n}\r\n}\r\nstatic void\r\nsetup_bchannel(hfcusb_data *hfc, int channel, int mode)\r\n{\r\n__u8 val, idx_table[2] = { 0, 2 };\r\nif (hfc->disc_flag) {\r\nreturn;\r\n}\r\nDBG(HFCUSB_DBG_STATES, "HFC-S USB: setting channel %d to mode %d",\r\nchannel, mode);\r\nhfc->b_mode[channel] = mode;\r\nval = 0;\r\nif (mode != L1_MODE_NULL)\r\nval = 8;\r\nif (mode == L1_MODE_TRANS)\r\nval |= 2;\r\nqueue_control_request(hfc, HFCUSB_FIFO, idx_table[channel], 1);\r\nqueue_control_request(hfc, HFCUSB_CON_HDLC, val, 1);\r\nqueue_control_request(hfc, HFCUSB_INC_RES_F, 2, 1);\r\nqueue_control_request(hfc, HFCUSB_FIFO, idx_table[channel] + 1, 1);\r\nqueue_control_request(hfc, HFCUSB_CON_HDLC, val, 1);\r\nqueue_control_request(hfc, HFCUSB_INC_RES_F, 2, 1);\r\nval = 0x40;\r\nif (hfc->b_mode[0])\r\nval |= 1;\r\nif (hfc->b_mode[1])\r\nval |= 2;\r\nqueue_control_request(hfc, HFCUSB_SCTRL, val, 1);\r\nval = 0;\r\nif (hfc->b_mode[0])\r\nval |= 1;\r\nif (hfc->b_mode[1])\r\nval |= 2;\r\nqueue_control_request(hfc, HFCUSB_SCTRL_R, val, 1);\r\nif (mode == L1_MODE_NULL) {\r\nif (channel)\r\nhandle_led(hfc, LED_B2_OFF);\r\nelse\r\nhandle_led(hfc, LED_B1_OFF);\r\n} else {\r\nif (channel)\r\nhandle_led(hfc, LED_B2_ON);\r\nelse\r\nhandle_led(hfc, LED_B1_ON);\r\n}\r\n}\r\nstatic void\r\nhfc_usb_l2l1(struct hisax_if *my_hisax_if, int pr, void *arg)\r\n{\r\nusb_fifo *fifo = my_hisax_if->priv;\r\nhfcusb_data *hfc = fifo->hfc;\r\nswitch (pr) {\r\ncase PH_ACTIVATE | REQUEST:\r\nif (fifo->fifonum == HFCUSB_D_TX) {\r\nDBG(HFCUSB_DBG_STATES,\r\n"HFC_USB: hfc_usb_d_l2l1 D-chan: PH_ACTIVATE | REQUEST");\r\nif (hfc->l1_state != 3\r\n&& hfc->l1_state != 7) {\r\nhfc->d_if.ifc.l1l2(&hfc->d_if.ifc,\r\nPH_DEACTIVATE |\r\nINDICATION,\r\nNULL);\r\nDBG(HFCUSB_DBG_STATES,\r\n"HFC-S USB: PH_DEACTIVATE | INDICATION sent (not state 3 or 7)");\r\n} else {\r\nif (hfc->l1_state == 7) {\r\nhfc->d_if.ifc.l1l2(&hfc->\r\nd_if.\r\nifc,\r\nPH_ACTIVATE\r\n|\r\nINDICATION,\r\nNULL);\r\nDBG(HFCUSB_DBG_STATES,\r\n"HFC-S USB: PH_ACTIVATE | INDICATION sent again ;)");\r\n} else {\r\nqueue_control_request(hfc,\r\nHFCUSB_STATES,\r\n0x14,\r\n1);\r\nmdelay(1);\r\nqueue_control_request(hfc,\r\nHFCUSB_STATES,\r\n0x04,\r\n1);\r\nif (!timer_pending\r\n(&hfc->t3_timer)) {\r\nhfc->t3_timer.\r\nexpires =\r\njiffies +\r\n(HFC_TIMER_T3 *\r\nHZ) / 1000;\r\nadd_timer(&hfc->\r\nt3_timer);\r\n}\r\n}\r\n}\r\n} else {\r\nDBG(HFCUSB_DBG_STATES,\r\n"HFC_USB: hfc_usb_d_l2l1 B-chan: PH_ACTIVATE | REQUEST");\r\nsetup_bchannel(hfc,\r\n(fifo->fifonum ==\r\nHFCUSB_B1_TX) ? 0 : 1,\r\n(long) arg);\r\nfifo->hif->l1l2(fifo->hif,\r\nPH_ACTIVATE | INDICATION,\r\nNULL);\r\n}\r\nbreak;\r\ncase PH_DEACTIVATE | REQUEST:\r\nif (fifo->fifonum == HFCUSB_D_TX) {\r\nDBG(HFCUSB_DBG_STATES,\r\n"HFC_USB: hfc_usb_d_l2l1 D-chan: PH_DEACTIVATE | REQUEST");\r\n} else {\r\nDBG(HFCUSB_DBG_STATES,\r\n"HFC_USB: hfc_usb_d_l2l1 Bx-chan: PH_DEACTIVATE | REQUEST");\r\nsetup_bchannel(hfc,\r\n(fifo->fifonum ==\r\nHFCUSB_B1_TX) ? 0 : 1,\r\n(int) L1_MODE_NULL);\r\nfifo->hif->l1l2(fifo->hif,\r\nPH_DEACTIVATE | INDICATION,\r\nNULL);\r\n}\r\nbreak;\r\ncase PH_DATA | REQUEST:\r\nif (fifo->skbuff && fifo->delete_flg) {\r\ndev_kfree_skb_any(fifo->skbuff);\r\nfifo->skbuff = NULL;\r\nfifo->delete_flg = 0;\r\n}\r\nfifo->skbuff = arg;\r\nbreak;\r\ndefault:\r\nDBG(HFCUSB_DBG_STATES,\r\n"HFC_USB: hfc_usb_d_l2l1: unknown state : %#x", pr);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nhfc_usb_init(hfcusb_data *hfc)\r\n{\r\nusb_fifo *fifo;\r\nint i;\r\nu_char b;\r\nstruct hisax_b_if *p_b_if[2];\r\nif (read_usb(hfc, HFCUSB_CHIP_ID, &b) != 1) {\r\nprintk(KERN_INFO "HFC-USB: cannot read chip id\n");\r\nreturn (1);\r\n}\r\nif (b != HFCUSB_CHIPID) {\r\nprintk(KERN_INFO "HFC-S USB: Invalid chip id 0x%02x\n", b);\r\nreturn (1);\r\n}\r\nusb_set_interface(hfc->dev, hfc->if_used, hfc->alt_used);\r\nwrite_usb(hfc, HFCUSB_CIRM, 8);\r\nwrite_usb(hfc, HFCUSB_CIRM, 0x10);\r\nwrite_usb(hfc, HFCUSB_USB_SIZE,\r\n(hfc->packet_size / 8) | ((hfc->packet_size / 8) << 4));\r\nwrite_usb(hfc, HFCUSB_USB_SIZE_I, hfc->iso_packet_size);\r\nwrite_usb(hfc, HFCUSB_MST_MODE1, 0);\r\nwrite_usb(hfc, HFCUSB_MST_MODE0, 1);\r\nwrite_usb(hfc, HFCUSB_F_THRES,\r\n(HFCUSB_TX_THRESHOLD /\r\n8) | ((HFCUSB_RX_THRESHOLD / 8) << 4));\r\nfifo = hfc->fifos;\r\nfor (i = 0; i < HFCUSB_NUM_FIFOS; i++) {\r\nwrite_usb(hfc, HFCUSB_FIFO, i);\r\nfifo[i].skbuff = NULL;\r\nfifo[i].max_size =\r\n(i <= HFCUSB_B2_RX) ? MAX_BCH_SIZE : MAX_DFRAME_LEN;\r\nfifo[i].last_urblen = 0;\r\nwrite_usb(hfc, HFCUSB_HDLC_PAR,\r\n((i <= HFCUSB_B2_RX) ? 0 : 2));\r\nwrite_usb(hfc, HFCUSB_CON_HDLC,\r\n((i == HFCUSB_D_TX) ? 0x09 : 0x08));\r\nwrite_usb(hfc, HFCUSB_INC_RES_F, 2);\r\n}\r\nwrite_usb(hfc, HFCUSB_CLKDEL, 0x0f);\r\nwrite_usb(hfc, HFCUSB_STATES, 3 | 0x10);\r\nwrite_usb(hfc, HFCUSB_STATES, 3);\r\nwrite_usb(hfc, HFCUSB_SCTRL_R, 0);\r\nwrite_usb(hfc, HFCUSB_SCTRL, 0x40);\r\nhfc->b_mode[0] = L1_MODE_NULL;\r\nhfc->b_mode[1] = L1_MODE_NULL;\r\nhfc->l1_activated = 0;\r\nhfc->disc_flag = 0;\r\nhfc->led_state = 0;\r\nhfc->old_led_state = 0;\r\ninit_timer(&hfc->t3_timer);\r\nhfc->t3_timer.data = (long) hfc;\r\nhfc->t3_timer.function = (void *) l1_timer_expire_t3;\r\ninit_timer(&hfc->t4_timer);\r\nhfc->t4_timer.data = (long) hfc;\r\nhfc->t4_timer.function = (void *) l1_timer_expire_t4;\r\nhfc->ctrl_read.bRequestType = 0xc0;\r\nhfc->ctrl_read.bRequest = 1;\r\nhfc->ctrl_read.wLength = cpu_to_le16(1);\r\nhfc->ctrl_write.bRequestType = 0x40;\r\nhfc->ctrl_write.bRequest = 0;\r\nhfc->ctrl_write.wLength = 0;\r\nusb_fill_control_urb(hfc->ctrl_urb,\r\nhfc->dev,\r\nhfc->ctrl_out_pipe,\r\n(u_char *)&hfc->ctrl_write,\r\nNULL, 0, ctrl_complete, hfc);\r\nfor (i = 0; i < HFCUSB_NUM_FIFOS; i++) {\r\nhfc->fifos[i].iso[0].purb = NULL;\r\nhfc->fifos[i].iso[1].purb = NULL;\r\nhfc->fifos[i].active = 0;\r\n}\r\nhfc->d_if.owner = THIS_MODULE;\r\nhfc->d_if.ifc.priv = &hfc->fifos[HFCUSB_D_TX];\r\nhfc->d_if.ifc.l2l1 = hfc_usb_l2l1;\r\nfor (i = 0; i < 2; i++) {\r\nhfc->b_if[i].ifc.priv = &hfc->fifos[HFCUSB_B1_TX + i * 2];\r\nhfc->b_if[i].ifc.l2l1 = hfc_usb_l2l1;\r\np_b_if[i] = &hfc->b_if[i];\r\n}\r\nhfc->protocol = 2;\r\ni = hisax_register(&hfc->d_if, p_b_if, "hfc_usb", hfc->protocol);\r\nif (i) {\r\nprintk(KERN_INFO "HFC-S USB: hisax_register -> %d\n", i);\r\nreturn i;\r\n}\r\n#ifdef CONFIG_HISAX_DEBUG\r\nhfc_debug = debug;\r\n#endif\r\nfor (i = 0; i < 4; i++)\r\nhfc->fifos[i].hif = &p_b_if[i / 2]->ifc;\r\nfor (i = 4; i < 8; i++)\r\nhfc->fifos[i].hif = &hfc->d_if.ifc;\r\nif (hfc->cfg_used == CNF_3INT3ISO || hfc->cfg_used == CNF_4INT3ISO) {\r\nstart_int_fifo(hfc->fifos + HFCUSB_D_RX);\r\nif (hfc->fifos[HFCUSB_PCM_RX].pipe)\r\nstart_int_fifo(hfc->fifos + HFCUSB_PCM_RX);\r\nstart_int_fifo(hfc->fifos + HFCUSB_B1_RX);\r\nstart_int_fifo(hfc->fifos + HFCUSB_B2_RX);\r\n}\r\nif (hfc->cfg_used == CNF_3ISO3ISO || hfc->cfg_used == CNF_4ISO3ISO) {\r\nstart_isoc_chain(hfc->fifos + HFCUSB_D_RX, ISOC_PACKETS_D,\r\nrx_iso_complete, 16);\r\nif (hfc->fifos[HFCUSB_PCM_RX].pipe)\r\nstart_isoc_chain(hfc->fifos + HFCUSB_PCM_RX,\r\nISOC_PACKETS_D, rx_iso_complete,\r\n16);\r\nstart_isoc_chain(hfc->fifos + HFCUSB_B1_RX, ISOC_PACKETS_B,\r\nrx_iso_complete, 16);\r\nstart_isoc_chain(hfc->fifos + HFCUSB_B2_RX, ISOC_PACKETS_B,\r\nrx_iso_complete, 16);\r\n}\r\nstart_isoc_chain(hfc->fifos + HFCUSB_D_TX, ISOC_PACKETS_D,\r\ntx_iso_complete, 1);\r\nstart_isoc_chain(hfc->fifos + HFCUSB_B1_TX, ISOC_PACKETS_B,\r\ntx_iso_complete, 1);\r\nstart_isoc_chain(hfc->fifos + HFCUSB_B2_TX, ISOC_PACKETS_B,\r\ntx_iso_complete, 1);\r\nhandle_led(hfc, LED_POWER_ON);\r\nreturn (0);\r\n}\r\nstatic int\r\nhfc_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nhfcusb_data *context;\r\nstruct usb_host_interface *iface = intf->cur_altsetting;\r\nstruct usb_host_interface *iface_used = NULL;\r\nstruct usb_host_endpoint *ep;\r\nint ifnum = iface->desc.bInterfaceNumber;\r\nint i, idx, alt_idx, probe_alt_setting, vend_idx, cfg_used, *vcf,\r\nattr, cfg_found, cidx, ep_addr;\r\nint cmptbl[16], small_match, iso_packet_size, packet_size,\r\nalt_used = 0;\r\nhfcsusb_vdata *driver_info;\r\nvend_idx = 0xffff;\r\nfor (i = 0; hfcusb_idtab[i].idVendor; i++) {\r\nif ((le16_to_cpu(dev->descriptor.idVendor) == hfcusb_idtab[i].idVendor)\r\n&& (le16_to_cpu(dev->descriptor.idProduct) == hfcusb_idtab[i].idProduct)) {\r\nvend_idx = i;\r\ncontinue;\r\n}\r\n}\r\nprintk(KERN_INFO\r\n"HFC-S USB: probing interface(%d) actalt(%d) minor(%d)\n",\r\nifnum, iface->desc.bAlternateSetting, intf->minor);\r\nif (vend_idx != 0xffff) {\r\nalt_idx = 0;\r\nsmall_match = 0xffff;\r\niso_packet_size = 16;\r\npacket_size = 64;\r\nwhile (alt_idx < intf->num_altsetting) {\r\niface = intf->altsetting + alt_idx;\r\nprobe_alt_setting = iface->desc.bAlternateSetting;\r\ncfg_used = 0;\r\nwhile (validconf[cfg_used][0]) {\r\ncfg_found = 1;\r\nvcf = validconf[cfg_used];\r\nep = iface->endpoint;\r\nmemcpy(cmptbl, vcf, 16 * sizeof(int));\r\nfor (i = 0; i < iface->desc.bNumEndpoints;\r\ni++) {\r\nep_addr =\r\nep->desc.bEndpointAddress;\r\nidx = ((ep_addr & 0x7f) - 1) * 2;\r\nif (ep_addr & 0x80)\r\nidx++;\r\nattr = ep->desc.bmAttributes;\r\nif (cmptbl[idx] == EP_NUL) {\r\ncfg_found = 0;\r\n}\r\nif (attr == USB_ENDPOINT_XFER_INT\r\n&& cmptbl[idx] == EP_INT)\r\ncmptbl[idx] = EP_NUL;\r\nif (attr == USB_ENDPOINT_XFER_BULK\r\n&& cmptbl[idx] == EP_BLK)\r\ncmptbl[idx] = EP_NUL;\r\nif (attr == USB_ENDPOINT_XFER_ISOC\r\n&& cmptbl[idx] == EP_ISO)\r\ncmptbl[idx] = EP_NUL;\r\nif ((attr == USB_ENDPOINT_XFER_INT)\r\n&& (ep->desc.bInterval < vcf[17])) {\r\ncfg_found = 0;\r\n}\r\nep++;\r\n}\r\nfor (i = 0; i < 16; i++) {\r\nif (cmptbl[i] != EP_NOP\r\n&& cmptbl[i] != EP_NUL)\r\ncfg_found = 0;\r\n}\r\nif (cfg_found) {\r\nif (cfg_used < small_match) {\r\nsmall_match = cfg_used;\r\nalt_used =\r\nprobe_alt_setting;\r\niface_used = iface;\r\n}\r\n}\r\ncfg_used++;\r\n}\r\nalt_idx++;\r\n}\r\nif (small_match != 0xffff) {\r\niface = iface_used;\r\nif (!(context = kzalloc(sizeof(hfcusb_data), GFP_KERNEL)))\r\nreturn (-ENOMEM);\r\nep = iface->endpoint;\r\nvcf = validconf[small_match];\r\nfor (i = 0; i < iface->desc.bNumEndpoints; i++) {\r\nep_addr = ep->desc.bEndpointAddress;\r\nidx = ((ep_addr & 0x7f) - 1) * 2;\r\nif (ep_addr & 0x80)\r\nidx++;\r\ncidx = idx & 7;\r\nattr = ep->desc.bmAttributes;\r\nif (vcf[idx] != EP_NOP\r\n&& vcf[idx] != EP_NUL) {\r\nswitch (attr) {\r\ncase USB_ENDPOINT_XFER_INT:\r\ncontext->\r\nfifos[cidx].\r\npipe =\r\nusb_rcvintpipe\r\n(dev,\r\nep->desc.\r\nbEndpointAddress);\r\ncontext->\r\nfifos[cidx].\r\nusb_transfer_mode\r\n= USB_INT;\r\npacket_size =\r\nle16_to_cpu(ep->desc.wMaxPacketSize);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (ep_addr & 0x80)\r\ncontext->\r\nfifos\r\n[cidx].\r\npipe =\r\nusb_rcvbulkpipe\r\n(dev,\r\nep->\r\ndesc.\r\nbEndpointAddress);\r\nelse\r\ncontext->\r\nfifos\r\n[cidx].\r\npipe =\r\nusb_sndbulkpipe\r\n(dev,\r\nep->\r\ndesc.\r\nbEndpointAddress);\r\ncontext->\r\nfifos[cidx].\r\nusb_transfer_mode\r\n= USB_BULK;\r\npacket_size =\r\nle16_to_cpu(ep->desc.wMaxPacketSize);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (ep_addr & 0x80)\r\ncontext->\r\nfifos\r\n[cidx].\r\npipe =\r\nusb_rcvisocpipe\r\n(dev,\r\nep->\r\ndesc.\r\nbEndpointAddress);\r\nelse\r\ncontext->\r\nfifos\r\n[cidx].\r\npipe =\r\nusb_sndisocpipe\r\n(dev,\r\nep->\r\ndesc.\r\nbEndpointAddress);\r\ncontext->\r\nfifos[cidx].\r\nusb_transfer_mode\r\n= USB_ISOC;\r\niso_packet_size =\r\nle16_to_cpu(ep->desc.wMaxPacketSize);\r\nbreak;\r\ndefault:\r\ncontext->\r\nfifos[cidx].\r\npipe = 0;\r\n}\r\nif (context->fifos[cidx].pipe) {\r\ncontext->fifos[cidx].\r\nfifonum = cidx;\r\ncontext->fifos[cidx].hfc =\r\ncontext;\r\ncontext->fifos[cidx].usb_packet_maxlen =\r\nle16_to_cpu(ep->desc.wMaxPacketSize);\r\ncontext->fifos[cidx].\r\nintervall =\r\nep->desc.bInterval;\r\ncontext->fifos[cidx].\r\nskbuff = NULL;\r\n}\r\n}\r\nep++;\r\n}\r\ncontext->dev = dev;\r\ncontext->if_used = ifnum;\r\ncontext->alt_used = alt_used;\r\ncontext->ctrl_paksize = dev->descriptor.bMaxPacketSize0;\r\ncontext->cfg_used = vcf[16];\r\ncontext->vend_idx = vend_idx;\r\ncontext->packet_size = packet_size;\r\ncontext->iso_packet_size = iso_packet_size;\r\ncontext->ctrl_in_pipe =\r\nusb_rcvctrlpipe(context->dev, 0);\r\ncontext->ctrl_out_pipe =\r\nusb_sndctrlpipe(context->dev, 0);\r\ndriver_info = (hfcsusb_vdata *)\r\nhfcusb_idtab[vend_idx].driver_info;\r\ncontext->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!context->ctrl_urb) {\r\npr_warn("%s: No memory for control urb\n",\r\ndriver_info->vend_name);\r\nkfree(context);\r\nreturn -ENOMEM;\r\n}\r\npr_info("HFC-S USB: detected \"%s\"\n",\r\ndriver_info->vend_name);\r\nDBG(HFCUSB_DBG_INIT,\r\n"HFC-S USB: Endpoint-Config: %s (if=%d alt=%d), E-Channel(%d)",\r\nconf_str[small_match], context->if_used,\r\ncontext->alt_used,\r\nvalidconf[small_match][18]);\r\nif (hfc_usb_init(context)) {\r\nusb_kill_urb(context->ctrl_urb);\r\nusb_free_urb(context->ctrl_urb);\r\ncontext->ctrl_urb = NULL;\r\nkfree(context);\r\nreturn (-EIO);\r\n}\r\nusb_set_intfdata(intf, context);\r\nreturn (0);\r\n}\r\n} else {\r\nprintk(KERN_INFO\r\n"HFC-S USB: no valid vendor found in USB descriptor\n");\r\n}\r\nreturn (-EIO);\r\n}\r\nstatic void\r\nhfc_usb_disconnect(struct usb_interface *intf)\r\n{\r\nhfcusb_data *context = usb_get_intfdata(intf);\r\nint i;\r\nhandle_led(context, LED_POWER_OFF);\r\nschedule_timeout(HZ / 100);\r\nprintk(KERN_INFO "HFC-S USB: device disconnect\n");\r\ncontext->disc_flag = 1;\r\nusb_set_intfdata(intf, NULL);\r\nif (timer_pending(&context->t3_timer))\r\ndel_timer(&context->t3_timer);\r\nif (timer_pending(&context->t4_timer))\r\ndel_timer(&context->t4_timer);\r\nfor (i = 0; i < HFCUSB_NUM_FIFOS; i++) {\r\nif (context->fifos[i].usb_transfer_mode == USB_ISOC) {\r\nif (context->fifos[i].active > 0) {\r\nstop_isoc_chain(&context->fifos[i]);\r\nDBG(HFCUSB_DBG_INIT,\r\n"HFC-S USB: %s stopping ISOC chain Fifo(%i)",\r\n__func__, i);\r\n}\r\n} else {\r\nif (context->fifos[i].active > 0) {\r\ncontext->fifos[i].active = 0;\r\nDBG(HFCUSB_DBG_INIT,\r\n"HFC-S USB: %s unlinking URB for Fifo(%i)",\r\n__func__, i);\r\n}\r\nusb_kill_urb(context->fifos[i].urb);\r\nusb_free_urb(context->fifos[i].urb);\r\ncontext->fifos[i].urb = NULL;\r\n}\r\ncontext->fifos[i].active = 0;\r\n}\r\nusb_kill_urb(context->ctrl_urb);\r\nusb_free_urb(context->ctrl_urb);\r\ncontext->ctrl_urb = NULL;\r\nhisax_unregister(&context->d_if);\r\nkfree(context);\r\n}\r\nstatic void __exit\r\nhfc_usb_mod_exit(void)\r\n{\r\nusb_deregister(&hfc_drv);\r\nprintk(KERN_INFO "HFC-S USB: module removed\n");\r\n}\r\nstatic int __init\r\nhfc_usb_mod_init(void)\r\n{\r\nchar revstr[30], datestr[30], dummy[30];\r\n#ifndef CONFIG_HISAX_DEBUG\r\nhfc_debug = debug;\r\n#endif\r\nsscanf(hfcusb_revision,\r\n"%s %s $ %s %s %s $ ", dummy, revstr,\r\ndummy, datestr, dummy);\r\nprintk(KERN_INFO\r\n"HFC-S USB: driver module revision %s date %s loaded, (debug=%i)\n",\r\nrevstr, datestr, debug);\r\nif (usb_register(&hfc_drv)) {\r\nprintk(KERN_INFO\r\n"HFC-S USB: Unable to register HFC-S USB module at usb stack\n");\r\nreturn (-1);\r\n}\r\nreturn (0);\r\n}
