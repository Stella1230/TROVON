static async_cookie_t __lowest_in_progress(struct async_domain *running)\r\n{\r\nstruct async_entry *entry;\r\nif (!list_empty(&running->domain)) {\r\nentry = list_first_entry(&running->domain, typeof(*entry), list);\r\nreturn entry->cookie;\r\n}\r\nlist_for_each_entry(entry, &async_pending, list)\r\nif (entry->running == running)\r\nreturn entry->cookie;\r\nreturn next_cookie;\r\n}\r\nstatic async_cookie_t lowest_in_progress(struct async_domain *running)\r\n{\r\nunsigned long flags;\r\nasync_cookie_t ret;\r\nspin_lock_irqsave(&async_lock, flags);\r\nret = __lowest_in_progress(running);\r\nspin_unlock_irqrestore(&async_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void async_run_entry_fn(struct work_struct *work)\r\n{\r\nstruct async_entry *entry =\r\ncontainer_of(work, struct async_entry, work);\r\nunsigned long flags;\r\nktime_t uninitialized_var(calltime), delta, rettime;\r\nstruct async_domain *running = entry->running;\r\nspin_lock_irqsave(&async_lock, flags);\r\nlist_move_tail(&entry->list, &running->domain);\r\nspin_unlock_irqrestore(&async_lock, flags);\r\nif (initcall_debug && system_state == SYSTEM_BOOTING) {\r\nprintk(KERN_DEBUG "calling %lli_%pF @ %i\n",\r\n(long long)entry->cookie,\r\nentry->func, task_pid_nr(current));\r\ncalltime = ktime_get();\r\n}\r\nentry->func(entry->data, entry->cookie);\r\nif (initcall_debug && system_state == SYSTEM_BOOTING) {\r\nrettime = ktime_get();\r\ndelta = ktime_sub(rettime, calltime);\r\nprintk(KERN_DEBUG "initcall %lli_%pF returned 0 after %lld usecs\n",\r\n(long long)entry->cookie,\r\nentry->func,\r\n(long long)ktime_to_ns(delta) >> 10);\r\n}\r\nspin_lock_irqsave(&async_lock, flags);\r\nlist_del(&entry->list);\r\nif (running->registered && --running->count == 0)\r\nlist_del_init(&running->node);\r\nkfree(entry);\r\natomic_dec(&entry_count);\r\nspin_unlock_irqrestore(&async_lock, flags);\r\nwake_up(&async_done);\r\n}\r\nstatic async_cookie_t __async_schedule(async_func_ptr *ptr, void *data, struct async_domain *running)\r\n{\r\nstruct async_entry *entry;\r\nunsigned long flags;\r\nasync_cookie_t newcookie;\r\nentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);\r\nif (!entry || atomic_read(&entry_count) > MAX_WORK) {\r\nkfree(entry);\r\nspin_lock_irqsave(&async_lock, flags);\r\nnewcookie = next_cookie++;\r\nspin_unlock_irqrestore(&async_lock, flags);\r\nptr(data, newcookie);\r\nreturn newcookie;\r\n}\r\nINIT_WORK(&entry->work, async_run_entry_fn);\r\nentry->func = ptr;\r\nentry->data = data;\r\nentry->running = running;\r\nspin_lock_irqsave(&async_lock, flags);\r\nnewcookie = entry->cookie = next_cookie++;\r\nlist_add_tail(&entry->list, &async_pending);\r\nif (running->registered && running->count++ == 0)\r\nlist_add_tail(&running->node, &async_domains);\r\natomic_inc(&entry_count);\r\nspin_unlock_irqrestore(&async_lock, flags);\r\nqueue_work(system_unbound_wq, &entry->work);\r\nreturn newcookie;\r\n}\r\nasync_cookie_t async_schedule(async_func_ptr *ptr, void *data)\r\n{\r\nreturn __async_schedule(ptr, data, &async_running);\r\n}\r\nasync_cookie_t async_schedule_domain(async_func_ptr *ptr, void *data,\r\nstruct async_domain *running)\r\n{\r\nreturn __async_schedule(ptr, data, running);\r\n}\r\nvoid async_synchronize_full(void)\r\n{\r\nmutex_lock(&async_register_mutex);\r\ndo {\r\nstruct async_domain *domain = NULL;\r\nspin_lock_irq(&async_lock);\r\nif (!list_empty(&async_domains))\r\ndomain = list_first_entry(&async_domains, typeof(*domain), node);\r\nspin_unlock_irq(&async_lock);\r\nasync_synchronize_cookie_domain(next_cookie, domain);\r\n} while (!list_empty(&async_domains));\r\nmutex_unlock(&async_register_mutex);\r\n}\r\nvoid async_unregister_domain(struct async_domain *domain)\r\n{\r\nmutex_lock(&async_register_mutex);\r\nspin_lock_irq(&async_lock);\r\nWARN_ON(!domain->registered || !list_empty(&domain->node) ||\r\n!list_empty(&domain->domain));\r\ndomain->registered = 0;\r\nspin_unlock_irq(&async_lock);\r\nmutex_unlock(&async_register_mutex);\r\n}\r\nvoid async_synchronize_full_domain(struct async_domain *domain)\r\n{\r\nasync_synchronize_cookie_domain(next_cookie, domain);\r\n}\r\nvoid async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *running)\r\n{\r\nktime_t uninitialized_var(starttime), delta, endtime;\r\nif (!running)\r\nreturn;\r\nif (initcall_debug && system_state == SYSTEM_BOOTING) {\r\nprintk(KERN_DEBUG "async_waiting @ %i\n", task_pid_nr(current));\r\nstarttime = ktime_get();\r\n}\r\nwait_event(async_done, lowest_in_progress(running) >= cookie);\r\nif (initcall_debug && system_state == SYSTEM_BOOTING) {\r\nendtime = ktime_get();\r\ndelta = ktime_sub(endtime, starttime);\r\nprintk(KERN_DEBUG "async_continuing @ %i after %lli usec\n",\r\ntask_pid_nr(current),\r\n(long long)ktime_to_ns(delta) >> 10);\r\n}\r\n}\r\nvoid async_synchronize_cookie(async_cookie_t cookie)\r\n{\r\nasync_synchronize_cookie_domain(cookie, &async_running);\r\n}
