static inline struct ax_device *to_ax_dev(struct net_device *dev)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nreturn (struct ax_device *)(ei_local + 1);\r\n}\r\nstatic int ax_initial_check(struct net_device *dev)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nvoid __iomem *ioaddr = ei_local->mem;\r\nint reg0;\r\nint regd;\r\nreg0 = ei_inb(ioaddr);\r\nif (reg0 == 0xFF)\r\nreturn -ENODEV;\r\nei_outb(E8390_NODMA + E8390_PAGE1 + E8390_STOP, ioaddr + E8390_CMD);\r\nregd = ei_inb(ioaddr + 0x0d);\r\nei_outb(0xff, ioaddr + 0x0d);\r\nei_outb(E8390_NODMA + E8390_PAGE0, ioaddr + E8390_CMD);\r\nei_inb(ioaddr + EN0_COUNTER0);\r\nif (ei_inb(ioaddr + EN0_COUNTER0) != 0) {\r\nei_outb(reg0, ioaddr);\r\nei_outb(regd, ioaddr + 0x0d);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ax_reset_8390(struct net_device *dev)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nunsigned long reset_start_time = jiffies;\r\nvoid __iomem *addr = (void __iomem *)dev->base_addr;\r\nif (ei_debug > 1)\r\nnetdev_dbg(dev, "resetting the 8390 t=%ld\n", jiffies);\r\nei_outb(ei_inb(addr + NE_RESET), addr + NE_RESET);\r\nei_local->txing = 0;\r\nei_local->dmaing = 0;\r\nwhile ((ei_inb(addr + EN0_ISR) & ENISR_RESET) == 0) {\r\nif (jiffies - reset_start_time > 2 * HZ / 100) {\r\nnetdev_warn(dev, "%s: did not complete.\n", __func__);\r\nbreak;\r\n}\r\n}\r\nei_outb(ENISR_RESET, addr + EN0_ISR);\r\n}\r\nstatic void ax_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr,\r\nint ring_page)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nvoid __iomem *nic_base = ei_local->mem;\r\nif (ei_local->dmaing) {\r\nnetdev_err(dev, "DMAing conflict in %s "\r\n"[DMAstat:%d][irqlock:%d].\n",\r\n__func__,\r\nei_local->dmaing, ei_local->irqlock);\r\nreturn;\r\n}\r\nei_local->dmaing |= 0x01;\r\nei_outb(E8390_NODMA + E8390_PAGE0 + E8390_START, nic_base + NE_CMD);\r\nei_outb(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);\r\nei_outb(0, nic_base + EN0_RCNTHI);\r\nei_outb(0, nic_base + EN0_RSARLO);\r\nei_outb(ring_page, nic_base + EN0_RSARHI);\r\nei_outb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nif (ei_local->word16)\r\nreadsw(nic_base + NE_DATAPORT, hdr,\r\nsizeof(struct e8390_pkt_hdr) >> 1);\r\nelse\r\nreadsb(nic_base + NE_DATAPORT, hdr,\r\nsizeof(struct e8390_pkt_hdr));\r\nei_outb(ENISR_RDC, nic_base + EN0_ISR);\r\nei_local->dmaing &= ~0x01;\r\nle16_to_cpus(&hdr->count);\r\n}\r\nstatic void ax_block_input(struct net_device *dev, int count,\r\nstruct sk_buff *skb, int ring_offset)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nvoid __iomem *nic_base = ei_local->mem;\r\nchar *buf = skb->data;\r\nif (ei_local->dmaing) {\r\nnetdev_err(dev,\r\n"DMAing conflict in %s "\r\n"[DMAstat:%d][irqlock:%d].\n",\r\n__func__,\r\nei_local->dmaing, ei_local->irqlock);\r\nreturn;\r\n}\r\nei_local->dmaing |= 0x01;\r\nei_outb(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base + NE_CMD);\r\nei_outb(count & 0xff, nic_base + EN0_RCNTLO);\r\nei_outb(count >> 8, nic_base + EN0_RCNTHI);\r\nei_outb(ring_offset & 0xff, nic_base + EN0_RSARLO);\r\nei_outb(ring_offset >> 8, nic_base + EN0_RSARHI);\r\nei_outb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nif (ei_local->word16) {\r\nreadsw(nic_base + NE_DATAPORT, buf, count >> 1);\r\nif (count & 0x01)\r\nbuf[count-1] = ei_inb(nic_base + NE_DATAPORT);\r\n} else {\r\nreadsb(nic_base + NE_DATAPORT, buf, count);\r\n}\r\nei_local->dmaing &= ~1;\r\n}\r\nstatic void ax_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, const int start_page)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nvoid __iomem *nic_base = ei_local->mem;\r\nunsigned long dma_start;\r\nif (ei_local->word16 && (count & 0x01))\r\ncount++;\r\nif (ei_local->dmaing) {\r\nnetdev_err(dev, "DMAing conflict in %s."\r\n"[DMAstat:%d][irqlock:%d]\n",\r\n__func__,\r\nei_local->dmaing, ei_local->irqlock);\r\nreturn;\r\n}\r\nei_local->dmaing |= 0x01;\r\nei_outb(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base + NE_CMD);\r\nei_outb(ENISR_RDC, nic_base + EN0_ISR);\r\nei_outb(count & 0xff, nic_base + EN0_RCNTLO);\r\nei_outb(count >> 8, nic_base + EN0_RCNTHI);\r\nei_outb(0x00, nic_base + EN0_RSARLO);\r\nei_outb(start_page, nic_base + EN0_RSARHI);\r\nei_outb(E8390_RWRITE+E8390_START, nic_base + NE_CMD);\r\nif (ei_local->word16)\r\nwritesw(nic_base + NE_DATAPORT, buf, count >> 1);\r\nelse\r\nwritesb(nic_base + NE_DATAPORT, buf, count);\r\ndma_start = jiffies;\r\nwhile ((ei_inb(nic_base + EN0_ISR) & ENISR_RDC) == 0) {\r\nif (jiffies - dma_start > 2 * HZ / 100) {\r\nnetdev_warn(dev, "timeout waiting for Tx RDC.\n");\r\nax_reset_8390(dev);\r\nax_NS8390_init(dev, 1);\r\nbreak;\r\n}\r\n}\r\nei_outb(ENISR_RDC, nic_base + EN0_ISR);\r\nei_local->dmaing &= ~0x01;\r\n}\r\nstatic void ax_handle_link_change(struct net_device *dev)\r\n{\r\nstruct ax_device *ax = to_ax_dev(dev);\r\nstruct phy_device *phy_dev = ax->phy_dev;\r\nint status_change = 0;\r\nif (phy_dev->link && ((ax->speed != phy_dev->speed) ||\r\n(ax->duplex != phy_dev->duplex))) {\r\nax->speed = phy_dev->speed;\r\nax->duplex = phy_dev->duplex;\r\nstatus_change = 1;\r\n}\r\nif (phy_dev->link != ax->link) {\r\nif (!phy_dev->link) {\r\nax->speed = 0;\r\nax->duplex = -1;\r\n}\r\nax->link = phy_dev->link;\r\nstatus_change = 1;\r\n}\r\nif (status_change)\r\nphy_print_status(phy_dev);\r\n}\r\nstatic int ax_mii_probe(struct net_device *dev)\r\n{\r\nstruct ax_device *ax = to_ax_dev(dev);\r\nstruct phy_device *phy_dev = NULL;\r\nint ret;\r\nphy_dev = phy_find_first(ax->mii_bus);\r\nif (!phy_dev) {\r\nnetdev_err(dev, "no PHY found\n");\r\nreturn -ENODEV;\r\n}\r\nret = phy_connect_direct(dev, phy_dev, ax_handle_link_change, 0,\r\nPHY_INTERFACE_MODE_MII);\r\nif (ret) {\r\nnetdev_err(dev, "Could not attach to PHY\n");\r\nreturn ret;\r\n}\r\nphy_dev->supported &= PHY_BASIC_FEATURES;\r\nphy_dev->advertising = phy_dev->supported;\r\nax->phy_dev = phy_dev;\r\nnetdev_info(dev, "PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",\r\nphy_dev->drv->name, dev_name(&phy_dev->dev), phy_dev->irq);\r\nreturn 0;\r\n}\r\nstatic void ax_phy_switch(struct net_device *dev, int on)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nstruct ax_device *ax = to_ax_dev(dev);\r\nu8 reg_gpoc = ax->plat->gpoc_val;\r\nif (!!on)\r\nreg_gpoc &= ~AX_GPOC_PPDSET;\r\nelse\r\nreg_gpoc |= AX_GPOC_PPDSET;\r\nei_outb(reg_gpoc, ei_local->mem + EI_SHIFT(0x17));\r\n}\r\nstatic int ax_open(struct net_device *dev)\r\n{\r\nstruct ax_device *ax = to_ax_dev(dev);\r\nint ret;\r\nnetdev_dbg(dev, "open\n");\r\nret = request_irq(dev->irq, ax_ei_interrupt, ax->irqflags,\r\ndev->name, dev);\r\nif (ret)\r\ngoto failed_request_irq;\r\nax_phy_switch(dev, 1);\r\nret = ax_mii_probe(dev);\r\nif (ret)\r\ngoto failed_mii_probe;\r\nphy_start(ax->phy_dev);\r\nret = ax_ei_open(dev);\r\nif (ret)\r\ngoto failed_ax_ei_open;\r\nax->running = 1;\r\nreturn 0;\r\nfailed_ax_ei_open:\r\nphy_disconnect(ax->phy_dev);\r\nfailed_mii_probe:\r\nax_phy_switch(dev, 0);\r\nfree_irq(dev->irq, dev);\r\nfailed_request_irq:\r\nreturn ret;\r\n}\r\nstatic int ax_close(struct net_device *dev)\r\n{\r\nstruct ax_device *ax = to_ax_dev(dev);\r\nnetdev_dbg(dev, "close\n");\r\nax->running = 0;\r\nwmb();\r\nax_ei_close(dev);\r\nax_phy_switch(dev, 0);\r\nphy_disconnect(ax->phy_dev);\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic int ax_ioctl(struct net_device *dev, struct ifreq *req, int cmd)\r\n{\r\nstruct ax_device *ax = to_ax_dev(dev);\r\nstruct phy_device *phy_dev = ax->phy_dev;\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nif (!phy_dev)\r\nreturn -ENODEV;\r\nreturn phy_mii_ioctl(phy_dev, req, cmd);\r\n}\r\nstatic void ax_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev->dev.parent);\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nstrcpy(info->bus_info, pdev->name);\r\n}\r\nstatic int ax_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ax_device *ax = to_ax_dev(dev);\r\nstruct phy_device *phy_dev = ax->phy_dev;\r\nif (!phy_dev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_gset(phy_dev, cmd);\r\n}\r\nstatic int ax_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ax_device *ax = to_ax_dev(dev);\r\nstruct phy_device *phy_dev = ax->phy_dev;\r\nif (!phy_dev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_sset(phy_dev, cmd);\r\n}\r\nstatic void ax_eeprom_register_read(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct ei_device *ei_local = eeprom->data;\r\nu8 reg = ei_inb(ei_local->mem + AX_MEMR);\r\neeprom->reg_data_in = reg & AX_MEMR_EEI;\r\neeprom->reg_data_out = reg & AX_MEMR_EEO;\r\neeprom->reg_data_clock = reg & AX_MEMR_EECLK;\r\neeprom->reg_chip_select = reg & AX_MEMR_EECS;\r\n}\r\nstatic void ax_eeprom_register_write(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct ei_device *ei_local = eeprom->data;\r\nu8 reg = ei_inb(ei_local->mem + AX_MEMR);\r\nreg &= ~(AX_MEMR_EEI | AX_MEMR_EECLK | AX_MEMR_EECS);\r\nif (eeprom->reg_data_in)\r\nreg |= AX_MEMR_EEI;\r\nif (eeprom->reg_data_clock)\r\nreg |= AX_MEMR_EECLK;\r\nif (eeprom->reg_chip_select)\r\nreg |= AX_MEMR_EECS;\r\nei_outb(reg, ei_local->mem + AX_MEMR);\r\nudelay(10);\r\n}\r\nstatic void ax_bb_mdc(struct mdiobb_ctrl *ctrl, int level)\r\n{\r\nstruct ax_device *ax = container_of(ctrl, struct ax_device, bb_ctrl);\r\nif (level)\r\nax->reg_memr |= AX_MEMR_MDC;\r\nelse\r\nax->reg_memr &= ~AX_MEMR_MDC;\r\nei_outb(ax->reg_memr, ax->addr_memr);\r\n}\r\nstatic void ax_bb_dir(struct mdiobb_ctrl *ctrl, int output)\r\n{\r\nstruct ax_device *ax = container_of(ctrl, struct ax_device, bb_ctrl);\r\nif (output)\r\nax->reg_memr &= ~AX_MEMR_MDIR;\r\nelse\r\nax->reg_memr |= AX_MEMR_MDIR;\r\nei_outb(ax->reg_memr, ax->addr_memr);\r\n}\r\nstatic void ax_bb_set_data(struct mdiobb_ctrl *ctrl, int value)\r\n{\r\nstruct ax_device *ax = container_of(ctrl, struct ax_device, bb_ctrl);\r\nif (value)\r\nax->reg_memr |= AX_MEMR_MDO;\r\nelse\r\nax->reg_memr &= ~AX_MEMR_MDO;\r\nei_outb(ax->reg_memr, ax->addr_memr);\r\n}\r\nstatic int ax_bb_get_data(struct mdiobb_ctrl *ctrl)\r\n{\r\nstruct ax_device *ax = container_of(ctrl, struct ax_device, bb_ctrl);\r\nint reg_memr = ei_inb(ax->addr_memr);\r\nreturn reg_memr & AX_MEMR_MDI ? 1 : 0;\r\n}\r\nstatic int ax_mii_init(struct net_device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev->dev.parent);\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nstruct ax_device *ax = to_ax_dev(dev);\r\nint err, i;\r\nax->bb_ctrl.ops = &bb_ops;\r\nax->addr_memr = ei_local->mem + AX_MEMR;\r\nax->mii_bus = alloc_mdio_bitbang(&ax->bb_ctrl);\r\nif (!ax->mii_bus) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nax->mii_bus->name = "ax88796_mii_bus";\r\nax->mii_bus->parent = dev->dev.parent;\r\nsnprintf(ax->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",\r\npdev->name, pdev->id);\r\nax->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);\r\nif (!ax->mii_bus->irq) {\r\nerr = -ENOMEM;\r\ngoto out_free_mdio_bitbang;\r\n}\r\nfor (i = 0; i < PHY_MAX_ADDR; i++)\r\nax->mii_bus->irq[i] = PHY_POLL;\r\nerr = mdiobus_register(ax->mii_bus);\r\nif (err)\r\ngoto out_free_irq;\r\nreturn 0;\r\nout_free_irq:\r\nkfree(ax->mii_bus->irq);\r\nout_free_mdio_bitbang:\r\nfree_mdio_bitbang(ax->mii_bus);\r\nout:\r\nreturn err;\r\n}\r\nstatic void ax_initial_setup(struct net_device *dev, struct ei_device *ei_local)\r\n{\r\nvoid __iomem *ioaddr = ei_local->mem;\r\nstruct ax_device *ax = to_ax_dev(dev);\r\nei_outb(E8390_NODMA + E8390_PAGE0 + E8390_STOP, ioaddr + E8390_CMD);\r\nei_outb(ax->plat->dcr_val & ~1, ioaddr + EN0_DCFG);\r\nei_outb(ax->plat->gpoc_val, ioaddr + EI_SHIFT(0x17));\r\n}\r\nstatic int ax_init_dev(struct net_device *dev)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nstruct ax_device *ax = to_ax_dev(dev);\r\nvoid __iomem *ioaddr = ei_local->mem;\r\nunsigned int start_page;\r\nunsigned int stop_page;\r\nint ret;\r\nint i;\r\nret = ax_initial_check(dev);\r\nif (ret)\r\ngoto err_out;\r\nax_initial_setup(dev, ei_local);\r\nif (ax->plat->flags & AXFLG_HAS_EEPROM) {\r\nunsigned char SA_prom[32];\r\nfor (i = 0; i < sizeof(SA_prom); i += 2) {\r\nSA_prom[i] = ei_inb(ioaddr + NE_DATAPORT);\r\nSA_prom[i + 1] = ei_inb(ioaddr + NE_DATAPORT);\r\n}\r\nif (ax->plat->wordlength == 2)\r\nfor (i = 0; i < 16; i++)\r\nSA_prom[i] = SA_prom[i+i];\r\nmemcpy(dev->dev_addr, SA_prom, 6);\r\n}\r\n#ifdef CONFIG_AX88796_93CX6\r\nif (ax->plat->flags & AXFLG_HAS_93CX6) {\r\nunsigned char mac_addr[6];\r\nstruct eeprom_93cx6 eeprom;\r\neeprom.data = ei_local;\r\neeprom.register_read = ax_eeprom_register_read;\r\neeprom.register_write = ax_eeprom_register_write;\r\neeprom.width = PCI_EEPROM_WIDTH_93C56;\r\neeprom_93cx6_multiread(&eeprom, 0,\r\n(__le16 __force *)mac_addr,\r\nsizeof(mac_addr) >> 1);\r\nmemcpy(dev->dev_addr, mac_addr, 6);\r\n}\r\n#endif\r\nif (ax->plat->wordlength == 2) {\r\nei_outb(ax->plat->dcr_val, ei_local->mem + EN0_DCFG);\r\nstart_page = NESM_START_PG;\r\nstop_page = NESM_STOP_PG;\r\n} else {\r\nstart_page = NE1SM_START_PG;\r\nstop_page = NE1SM_STOP_PG;\r\n}\r\nif (ax->plat->flags & AXFLG_MAC_FROMDEV) {\r\nei_outb(E8390_NODMA + E8390_PAGE1 + E8390_STOP,\r\nei_local->mem + E8390_CMD);\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ndev->dev_addr[i] =\r\nei_inb(ioaddr + EN1_PHYS_SHIFT(i));\r\n}\r\nif ((ax->plat->flags & AXFLG_MAC_FROMPLATFORM) &&\r\nax->plat->mac_addr)\r\nmemcpy(dev->dev_addr, ax->plat->mac_addr, ETH_ALEN);\r\nax_reset_8390(dev);\r\nei_local->name = "AX88796";\r\nei_local->tx_start_page = start_page;\r\nei_local->stop_page = stop_page;\r\nei_local->word16 = (ax->plat->wordlength == 2);\r\nei_local->rx_start_page = start_page + TX_PAGES;\r\n#ifdef PACKETBUF_MEMSIZE\r\nei_local->stop_page = ei_local->tx_start_page + PACKETBUF_MEMSIZE;\r\n#endif\r\nei_local->reset_8390 = &ax_reset_8390;\r\nei_local->block_input = &ax_block_input;\r\nei_local->block_output = &ax_block_output;\r\nei_local->get_8390_hdr = &ax_get_8390_hdr;\r\nei_local->priv = 0;\r\ndev->netdev_ops = &ax_netdev_ops;\r\ndev->ethtool_ops = &ax_ethtool_ops;\r\nret = ax_mii_init(dev);\r\nif (ret)\r\ngoto out_irq;\r\nax_NS8390_init(dev, 0);\r\nret = register_netdev(dev);\r\nif (ret)\r\ngoto out_irq;\r\nnetdev_info(dev, "%dbit, irq %d, %lx, MAC: %pM\n",\r\nei_local->word16 ? 16 : 8, dev->irq, dev->base_addr,\r\ndev->dev_addr);\r\nreturn 0;\r\nout_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int ax_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nstruct ax_device *ax = to_ax_dev(dev);\r\nstruct resource *mem;\r\nunregister_netdev(dev);\r\nfree_irq(dev->irq, dev);\r\niounmap(ei_local->mem);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nif (ax->map2) {\r\niounmap(ax->map2);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nrelease_mem_region(mem->start, resource_size(mem));\r\n}\r\nfree_netdev(dev);\r\nreturn 0;\r\n}\r\nstatic int ax_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct ei_device *ei_local;\r\nstruct ax_device *ax;\r\nstruct resource *irq, *mem, *mem2;\r\nresource_size_t mem_size, mem2_size = 0;\r\nint ret = 0;\r\ndev = ax__alloc_ei_netdev(sizeof(struct ax_device));\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nei_local = netdev_priv(dev);\r\nax = to_ax_dev(dev);\r\nax->plat = pdev->dev.platform_data;\r\nplatform_set_drvdata(pdev, dev);\r\nei_local->rxcr_base = ax->plat->rcr_val;\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "no IRQ specified\n");\r\nret = -ENXIO;\r\ngoto exit_mem;\r\n}\r\ndev->irq = irq->start;\r\nax->irqflags = irq->flags & IRQF_TRIGGER_MASK;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "no MEM specified\n");\r\nret = -ENXIO;\r\ngoto exit_mem;\r\n}\r\nmem_size = resource_size(mem);\r\nif (ax->plat->reg_offsets)\r\nei_local->reg_offset = ax->plat->reg_offsets;\r\nelse {\r\nei_local->reg_offset = ax->reg_offsets;\r\nfor (ret = 0; ret < 0x18; ret++)\r\nax->reg_offsets[ret] = (mem_size / 0x18) * ret;\r\n}\r\nif (!request_mem_region(mem->start, mem_size, pdev->name)) {\r\ndev_err(&pdev->dev, "cannot reserve registers\n");\r\nret = -ENXIO;\r\ngoto exit_mem;\r\n}\r\nei_local->mem = ioremap(mem->start, mem_size);\r\ndev->base_addr = (unsigned long)ei_local->mem;\r\nif (ei_local->mem == NULL) {\r\ndev_err(&pdev->dev, "Cannot ioremap area %pR\n", mem);\r\nret = -ENXIO;\r\ngoto exit_req;\r\n}\r\nmem2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!mem2) {\r\nif (!ax->plat->reg_offsets) {\r\nfor (ret = 0; ret < 0x20; ret++)\r\nax->reg_offsets[ret] = (mem_size / 0x20) * ret;\r\n}\r\n} else {\r\nmem2_size = resource_size(mem2);\r\nif (!request_mem_region(mem2->start, mem2_size, pdev->name)) {\r\ndev_err(&pdev->dev, "cannot reserve registers\n");\r\nret = -ENXIO;\r\ngoto exit_mem1;\r\n}\r\nax->map2 = ioremap(mem2->start, mem2_size);\r\nif (!ax->map2) {\r\ndev_err(&pdev->dev, "cannot map reset register\n");\r\nret = -ENXIO;\r\ngoto exit_mem2;\r\n}\r\nei_local->reg_offset[0x1f] = ax->map2 - ei_local->mem;\r\n}\r\nret = ax_init_dev(dev);\r\nif (!ret)\r\nreturn 0;\r\nif (!ax->map2)\r\ngoto exit_mem1;\r\niounmap(ax->map2);\r\nexit_mem2:\r\nrelease_mem_region(mem2->start, mem2_size);\r\nexit_mem1:\r\niounmap(ei_local->mem);\r\nexit_req:\r\nrelease_mem_region(mem->start, mem_size);\r\nexit_mem:\r\nfree_netdev(dev);\r\nreturn ret;\r\n}\r\nstatic int ax_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(dev);\r\nstruct ax_device *ax = to_ax_dev(ndev);\r\nax->resume_open = ax->running;\r\nnetif_device_detach(ndev);\r\nax_close(ndev);\r\nreturn 0;\r\n}\r\nstatic int ax_resume(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct ax_device *ax = to_ax_dev(ndev);\r\nax_initial_setup(ndev, netdev_priv(ndev));\r\nax_NS8390_init(ndev, ax->resume_open);\r\nnetif_device_attach(ndev);\r\nif (ax->resume_open)\r\nax_open(ndev);\r\nreturn 0;\r\n}
