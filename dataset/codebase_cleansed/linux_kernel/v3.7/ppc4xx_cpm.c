static unsigned int cpm_set(unsigned int cpm_reg, unsigned int mask)\r\n{\r\nunsigned int value;\r\nvalue = dcr_read(cpm.dcr_host, cpm.dcr_offset[cpm_reg]);\r\ndcr_write(cpm.dcr_host, cpm.dcr_offset[cpm_reg], value | mask);\r\nreturn value;\r\n}\r\nstatic void cpm_idle_wait(void)\r\n{\r\nunsigned long msr_save;\r\nmsr_save = mfmsr();\r\nmb();\r\nmtmsr(msr_save|MSR_WE|MSR_EE|MSR_CE|MSR_DE);\r\nisync();\r\nmtmsr(msr_save);\r\nisync();\r\n}\r\nstatic void cpm_idle_sleep(unsigned int mask)\r\n{\r\nunsigned int er_save;\r\ner_save = cpm_set(CPM_ER, mask);\r\ncpm_idle_wait();\r\ndcr_write(cpm.dcr_host, cpm.dcr_offset[CPM_ER], er_save);\r\n}\r\nstatic void cpm_idle_doze(void)\r\n{\r\ncpm_idle_sleep(cpm.idle_doze);\r\n}\r\nstatic void cpm_idle_config(int mode)\r\n{\r\nint i;\r\nif (idle_mode[mode].enabled)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(idle_mode); i++)\r\nidle_mode[i].enabled = 0;\r\nidle_mode[mode].enabled = 1;\r\n}\r\nstatic ssize_t cpm_idle_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nchar *s = buf;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(idle_mode); i++) {\r\nif (idle_mode[i].enabled)\r\ns += sprintf(s, "[%s] ", idle_mode[i].name);\r\nelse\r\ns += sprintf(s, "%s ", idle_mode[i].name);\r\n}\r\n*(s-1) = '\n';\r\nreturn s - buf;\r\n}\r\nstatic ssize_t cpm_idle_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t n)\r\n{\r\nint i;\r\nchar *p;\r\nint len;\r\np = memchr(buf, '\n', n);\r\nlen = p ? p - buf : n;\r\nfor (i = 0; i < ARRAY_SIZE(idle_mode); i++) {\r\nif (strncmp(buf, idle_mode[i].name, len) == 0) {\r\ncpm_idle_config(i);\r\nreturn n;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void cpm_idle_config_sysfs(void)\r\n{\r\nstruct device *dev;\r\nunsigned long ret;\r\ndev = get_cpu_device(0);\r\nret = sysfs_create_file(&dev->kobj,\r\n&cpm_idle_attr.attr);\r\nif (ret)\r\nprintk(KERN_WARNING\r\n"cpm: failed to create idle sysfs entry\n");\r\n}\r\nstatic void cpm_idle(void)\r\n{\r\nif (idle_mode[CPM_IDLE_DOZE].enabled)\r\ncpm_idle_doze();\r\nelse\r\ncpm_idle_wait();\r\n}\r\nstatic int cpm_suspend_valid(suspend_state_t state)\r\n{\r\nswitch (state) {\r\ncase PM_SUSPEND_STANDBY:\r\nreturn !!cpm.standby;\r\ncase PM_SUSPEND_MEM:\r\nreturn !!cpm.suspend;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void cpm_suspend_standby(unsigned int mask)\r\n{\r\nunsigned long tcr_save;\r\ntcr_save = mfspr(SPRN_TCR);\r\nmtspr(SPRN_TCR, tcr_save & ~TCR_DIE);\r\ncpm_idle_sleep(mask);\r\nmtspr(SPRN_TCR, tcr_save);\r\n}\r\nstatic int cpm_suspend_enter(suspend_state_t state)\r\n{\r\nswitch (state) {\r\ncase PM_SUSPEND_STANDBY:\r\ncpm_suspend_standby(cpm.standby);\r\nbreak;\r\ncase PM_SUSPEND_MEM:\r\ncpm_suspend_standby(cpm.suspend);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cpm_get_uint_property(struct device_node *np,\r\nconst char *name)\r\n{\r\nint len;\r\nconst unsigned int *prop = of_get_property(np, name, &len);\r\nif (prop == NULL || len < sizeof(u32))\r\nreturn 0;\r\nreturn *prop;\r\n}\r\nstatic int __init cpm_init(void)\r\n{\r\nstruct device_node *np;\r\nint dcr_base, dcr_len;\r\nint ret = 0;\r\nif (!cpm.powersave_off) {\r\ncpm_idle_config(CPM_IDLE_WAIT);\r\nppc_md.power_save = &cpm_idle;\r\n}\r\nnp = of_find_compatible_node(NULL, NULL, "ibm,cpm");\r\nif (!np) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ndcr_base = dcr_resource_start(np, 0);\r\ndcr_len = dcr_resource_len(np, 0);\r\nif (dcr_base == 0 || dcr_len == 0) {\r\nprintk(KERN_ERR "cpm: could not parse dcr property for %s\n",\r\nnp->full_name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ncpm.dcr_host = dcr_map(np, dcr_base, dcr_len);\r\nif (!DCR_MAP_OK(cpm.dcr_host)) {\r\nprintk(KERN_ERR "cpm: failed to map dcr property for %s\n",\r\nnp->full_name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (cpm_get_uint_property(np, "er-offset") == 0) {\r\ncpm.dcr_offset[CPM_ER] = 0;\r\ncpm.dcr_offset[CPM_FR] = 1;\r\ncpm.dcr_offset[CPM_SR] = 2;\r\n} else {\r\ncpm.dcr_offset[CPM_ER] = 1;\r\ncpm.dcr_offset[CPM_FR] = 2;\r\ncpm.dcr_offset[CPM_SR] = 0;\r\n}\r\ncpm.unused = cpm_get_uint_property(np, "unused-units");\r\ncpm.idle_doze = cpm_get_uint_property(np, "idle-doze");\r\ncpm.standby = cpm_get_uint_property(np, "standby");\r\ncpm.suspend = cpm_get_uint_property(np, "suspend");\r\nif (cpm.unused) {\r\ncpm_set(CPM_ER, cpm.unused);\r\ncpm_set(CPM_FR, cpm.unused);\r\n}\r\nif (!cpm.powersave_off && cpm.idle_doze)\r\ncpm_idle_config_sysfs();\r\nif (cpm.standby || cpm.suspend)\r\nsuspend_set_ops(&cpm_suspend_ops);\r\nout:\r\nif (np)\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nstatic int __init cpm_powersave_off(char *arg)\r\n{\r\ncpm.powersave_off = 1;\r\nreturn 0;\r\n}
