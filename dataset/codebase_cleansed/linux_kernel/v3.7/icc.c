void\r\nICCVersion(struct IsdnCardState *cs, char *s)\r\n{\r\nint val;\r\nval = cs->readisac(cs, ICC_RBCH);\r\nprintk(KERN_INFO "%s ICC version (%x): %s\n", s, val, ICCVer[(val >> 5) & 3]);\r\n}\r\nstatic void\r\nph_command(struct IsdnCardState *cs, unsigned int command)\r\n{\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ph_command %x", command);\r\ncs->writeisac(cs, ICC_CIX0, (command << 2) | 3);\r\n}\r\nstatic void\r\nicc_new_ph(struct IsdnCardState *cs)\r\n{\r\nswitch (cs->dc.icc.ph_state) {\r\ncase (ICC_IND_EI1):\r\nph_command(cs, ICC_CMD_DI);\r\nl1_msg(cs, HW_RESET | INDICATION, NULL);\r\nbreak;\r\ncase (ICC_IND_DC):\r\nl1_msg(cs, HW_DEACTIVATE | CONFIRM, NULL);\r\nbreak;\r\ncase (ICC_IND_DR):\r\nl1_msg(cs, HW_DEACTIVATE | INDICATION, NULL);\r\nbreak;\r\ncase (ICC_IND_PU):\r\nl1_msg(cs, HW_POWERUP | CONFIRM, NULL);\r\nbreak;\r\ncase (ICC_IND_FJ):\r\nl1_msg(cs, HW_RSYNC | INDICATION, NULL);\r\nbreak;\r\ncase (ICC_IND_AR):\r\nl1_msg(cs, HW_INFO2 | INDICATION, NULL);\r\nbreak;\r\ncase (ICC_IND_AI):\r\nl1_msg(cs, HW_INFO4 | INDICATION, NULL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nicc_bh(struct work_struct *work)\r\n{\r\nstruct IsdnCardState *cs =\r\ncontainer_of(work, struct IsdnCardState, tqueue);\r\nstruct PStack *stptr;\r\nif (test_and_clear_bit(D_CLEARBUSY, &cs->event)) {\r\nif (cs->debug)\r\ndebugl1(cs, "D-Channel Busy cleared");\r\nstptr = cs->stlist;\r\nwhile (stptr != NULL) {\r\nstptr->l1.l1l2(stptr, PH_PAUSE | CONFIRM, NULL);\r\nstptr = stptr->next;\r\n}\r\n}\r\nif (test_and_clear_bit(D_L1STATECHANGE, &cs->event))\r\nicc_new_ph(cs);\r\nif (test_and_clear_bit(D_RCVBUFREADY, &cs->event))\r\nDChannel_proc_rcv(cs);\r\nif (test_and_clear_bit(D_XMTBUFREADY, &cs->event))\r\nDChannel_proc_xmt(cs);\r\n#if ARCOFI_USE\r\nif (!test_bit(HW_ARCOFI, &cs->HW_Flags))\r\nreturn;\r\nif (test_and_clear_bit(D_RX_MON1, &cs->event))\r\narcofi_fsm(cs, ARCOFI_RX_END, NULL);\r\nif (test_and_clear_bit(D_TX_MON1, &cs->event))\r\narcofi_fsm(cs, ARCOFI_TX_END, NULL);\r\n#endif\r\n}\r\nstatic void\r\nicc_empty_fifo(struct IsdnCardState *cs, int count)\r\n{\r\nu_char *ptr;\r\nif ((cs->debug & L1_DEB_ISAC) && !(cs->debug & L1_DEB_ISAC_FIFO))\r\ndebugl1(cs, "icc_empty_fifo");\r\nif ((cs->rcvidx + count) >= MAX_DFRAME_LEN_L1) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "icc_empty_fifo overrun %d",\r\ncs->rcvidx + count);\r\ncs->writeisac(cs, ICC_CMDR, 0x80);\r\ncs->rcvidx = 0;\r\nreturn;\r\n}\r\nptr = cs->rcvbuf + cs->rcvidx;\r\ncs->rcvidx += count;\r\ncs->readisacfifo(cs, ptr, count);\r\ncs->writeisac(cs, ICC_CMDR, 0x80);\r\nif (cs->debug & L1_DEB_ISAC_FIFO) {\r\nchar *t = cs->dlog;\r\nt += sprintf(t, "icc_empty_fifo cnt %d", count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, cs->dlog);\r\n}\r\n}\r\nstatic void\r\nicc_fill_fifo(struct IsdnCardState *cs)\r\n{\r\nint count, more;\r\nu_char *ptr;\r\nif ((cs->debug & L1_DEB_ISAC) && !(cs->debug & L1_DEB_ISAC_FIFO))\r\ndebugl1(cs, "icc_fill_fifo");\r\nif (!cs->tx_skb)\r\nreturn;\r\ncount = cs->tx_skb->len;\r\nif (count <= 0)\r\nreturn;\r\nmore = 0;\r\nif (count > 32) {\r\nmore = !0;\r\ncount = 32;\r\n}\r\nptr = cs->tx_skb->data;\r\nskb_pull(cs->tx_skb, count);\r\ncs->tx_cnt += count;\r\ncs->writeisacfifo(cs, ptr, count);\r\ncs->writeisac(cs, ICC_CMDR, more ? 0x8 : 0xa);\r\nif (test_and_set_bit(FLG_DBUSY_TIMER, &cs->HW_Flags)) {\r\ndebugl1(cs, "icc_fill_fifo dbusytimer running");\r\ndel_timer(&cs->dbusytimer);\r\n}\r\ninit_timer(&cs->dbusytimer);\r\ncs->dbusytimer.expires = jiffies + ((DBUSY_TIMER_VALUE * HZ)/1000);\r\nadd_timer(&cs->dbusytimer);\r\nif (cs->debug & L1_DEB_ISAC_FIFO) {\r\nchar *t = cs->dlog;\r\nt += sprintf(t, "icc_fill_fifo cnt %d", count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, cs->dlog);\r\n}\r\n}\r\nvoid\r\nicc_interrupt(struct IsdnCardState *cs, u_char val)\r\n{\r\nu_char exval, v1;\r\nstruct sk_buff *skb;\r\nunsigned int count;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ICC interrupt %x", val);\r\nif (val & 0x80) {\r\nexval = cs->readisac(cs, ICC_RSTA);\r\nif ((exval & 0x70) != 0x20) {\r\nif (exval & 0x40) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ICC RDO");\r\n#ifdef ERROR_STATISTIC\r\ncs->err_rx++;\r\n#endif\r\n}\r\nif (!(exval & 0x20)) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ICC CRC error");\r\n#ifdef ERROR_STATISTIC\r\ncs->err_crc++;\r\n#endif\r\n}\r\ncs->writeisac(cs, ICC_CMDR, 0x80);\r\n} else {\r\ncount = cs->readisac(cs, ICC_RBCL) & 0x1f;\r\nif (count == 0)\r\ncount = 32;\r\nicc_empty_fifo(cs, count);\r\nif ((count = cs->rcvidx) > 0) {\r\ncs->rcvidx = 0;\r\nif (!(skb = alloc_skb(count, GFP_ATOMIC)))\r\nprintk(KERN_WARNING "HiSax: D receive out of memory\n");\r\nelse {\r\nmemcpy(skb_put(skb, count), cs->rcvbuf, count);\r\nskb_queue_tail(&cs->rq, skb);\r\n}\r\n}\r\n}\r\ncs->rcvidx = 0;\r\nschedule_event(cs, D_RCVBUFREADY);\r\n}\r\nif (val & 0x40) {\r\nicc_empty_fifo(cs, 32);\r\n}\r\nif (val & 0x20) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ICC RSC interrupt");\r\n}\r\nif (val & 0x10) {\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nif (cs->tx_skb) {\r\nif (cs->tx_skb->len) {\r\nicc_fill_fifo(cs);\r\ngoto afterXPR;\r\n} else {\r\ndev_kfree_skb_irq(cs->tx_skb);\r\ncs->tx_cnt = 0;\r\ncs->tx_skb = NULL;\r\n}\r\n}\r\nif ((cs->tx_skb = skb_dequeue(&cs->sq))) {\r\ncs->tx_cnt = 0;\r\nicc_fill_fifo(cs);\r\n} else\r\nschedule_event(cs, D_XMTBUFREADY);\r\n}\r\nafterXPR:\r\nif (val & 0x04) {\r\nexval = cs->readisac(cs, ICC_CIR0);\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ICC CIR0 %02X", exval);\r\nif (exval & 2) {\r\ncs->dc.icc.ph_state = (exval >> 2) & 0xf;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ph_state change %x", cs->dc.icc.ph_state);\r\nschedule_event(cs, D_L1STATECHANGE);\r\n}\r\nif (exval & 1) {\r\nexval = cs->readisac(cs, ICC_CIR1);\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ICC CIR1 %02X", exval);\r\n}\r\n}\r\nif (val & 0x02) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ICC SIN interrupt");\r\n}\r\nif (val & 0x01) {\r\nexval = cs->readisac(cs, ICC_EXIR);\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ICC EXIR %02x", exval);\r\nif (exval & 0x80) {\r\ndebugl1(cs, "ICC XMR");\r\nprintk(KERN_WARNING "HiSax: ICC XMR\n");\r\n}\r\nif (exval & 0x40) {\r\ndebugl1(cs, "ICC XDU");\r\nprintk(KERN_WARNING "HiSax: ICC XDU\n");\r\n#ifdef ERROR_STATISTIC\r\ncs->err_tx++;\r\n#endif\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nif (cs->tx_skb) {\r\nskb_push(cs->tx_skb, cs->tx_cnt);\r\ncs->tx_cnt = 0;\r\nicc_fill_fifo(cs);\r\n} else {\r\nprintk(KERN_WARNING "HiSax: ICC XDU no skb\n");\r\ndebugl1(cs, "ICC XDU no skb");\r\n}\r\n}\r\nif (exval & 0x04) {\r\nv1 = cs->readisac(cs, ICC_MOSR);\r\nif (cs->debug & L1_DEB_MONITOR)\r\ndebugl1(cs, "ICC MOSR %02x", v1);\r\n#if ARCOFI_USE\r\nif (v1 & 0x08) {\r\nif (!cs->dc.icc.mon_rx) {\r\nif (!(cs->dc.icc.mon_rx = kmalloc(MAX_MON_FRAME, GFP_ATOMIC))) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ICC MON RX out of memory!");\r\ncs->dc.icc.mocr &= 0xf0;\r\ncs->dc.icc.mocr |= 0x0a;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\ngoto afterMONR0;\r\n} else\r\ncs->dc.icc.mon_rxp = 0;\r\n}\r\nif (cs->dc.icc.mon_rxp >= MAX_MON_FRAME) {\r\ncs->dc.icc.mocr &= 0xf0;\r\ncs->dc.icc.mocr |= 0x0a;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\ncs->dc.icc.mon_rxp = 0;\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ICC MON RX overflow!");\r\ngoto afterMONR0;\r\n}\r\ncs->dc.icc.mon_rx[cs->dc.icc.mon_rxp++] = cs->readisac(cs, ICC_MOR0);\r\nif (cs->debug & L1_DEB_MONITOR)\r\ndebugl1(cs, "ICC MOR0 %02x", cs->dc.icc.mon_rx[cs->dc.icc.mon_rxp - 1]);\r\nif (cs->dc.icc.mon_rxp == 1) {\r\ncs->dc.icc.mocr |= 0x04;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\n}\r\n}\r\nafterMONR0:\r\nif (v1 & 0x80) {\r\nif (!cs->dc.icc.mon_rx) {\r\nif (!(cs->dc.icc.mon_rx = kmalloc(MAX_MON_FRAME, GFP_ATOMIC))) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ICC MON RX out of memory!");\r\ncs->dc.icc.mocr &= 0x0f;\r\ncs->dc.icc.mocr |= 0xa0;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\ngoto afterMONR1;\r\n} else\r\ncs->dc.icc.mon_rxp = 0;\r\n}\r\nif (cs->dc.icc.mon_rxp >= MAX_MON_FRAME) {\r\ncs->dc.icc.mocr &= 0x0f;\r\ncs->dc.icc.mocr |= 0xa0;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\ncs->dc.icc.mon_rxp = 0;\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ICC MON RX overflow!");\r\ngoto afterMONR1;\r\n}\r\ncs->dc.icc.mon_rx[cs->dc.icc.mon_rxp++] = cs->readisac(cs, ICC_MOR1);\r\nif (cs->debug & L1_DEB_MONITOR)\r\ndebugl1(cs, "ICC MOR1 %02x", cs->dc.icc.mon_rx[cs->dc.icc.mon_rxp - 1]);\r\ncs->dc.icc.mocr |= 0x40;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\n}\r\nafterMONR1:\r\nif (v1 & 0x04) {\r\ncs->dc.icc.mocr &= 0xf0;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\ncs->dc.icc.mocr |= 0x0a;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\nschedule_event(cs, D_RX_MON0);\r\n}\r\nif (v1 & 0x40) {\r\ncs->dc.icc.mocr &= 0x0f;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\ncs->dc.icc.mocr |= 0xa0;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\nschedule_event(cs, D_RX_MON1);\r\n}\r\nif (v1 & 0x02) {\r\nif ((!cs->dc.icc.mon_tx) || (cs->dc.icc.mon_txc &&\r\n(cs->dc.icc.mon_txp >= cs->dc.icc.mon_txc) &&\r\n!(v1 & 0x08))) {\r\ncs->dc.icc.mocr &= 0xf0;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\ncs->dc.icc.mocr |= 0x0a;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\nif (cs->dc.icc.mon_txc &&\r\n(cs->dc.icc.mon_txp >= cs->dc.icc.mon_txc))\r\nschedule_event(cs, D_TX_MON0);\r\ngoto AfterMOX0;\r\n}\r\nif (cs->dc.icc.mon_txc && (cs->dc.icc.mon_txp >= cs->dc.icc.mon_txc)) {\r\nschedule_event(cs, D_TX_MON0);\r\ngoto AfterMOX0;\r\n}\r\ncs->writeisac(cs, ICC_MOX0,\r\ncs->dc.icc.mon_tx[cs->dc.icc.mon_txp++]);\r\nif (cs->debug & L1_DEB_MONITOR)\r\ndebugl1(cs, "ICC %02x -> MOX0", cs->dc.icc.mon_tx[cs->dc.icc.mon_txp - 1]);\r\n}\r\nAfterMOX0:\r\nif (v1 & 0x20) {\r\nif ((!cs->dc.icc.mon_tx) || (cs->dc.icc.mon_txc &&\r\n(cs->dc.icc.mon_txp >= cs->dc.icc.mon_txc) &&\r\n!(v1 & 0x80))) {\r\ncs->dc.icc.mocr &= 0x0f;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\ncs->dc.icc.mocr |= 0xa0;\r\ncs->writeisac(cs, ICC_MOCR, cs->dc.icc.mocr);\r\nif (cs->dc.icc.mon_txc &&\r\n(cs->dc.icc.mon_txp >= cs->dc.icc.mon_txc))\r\nschedule_event(cs, D_TX_MON1);\r\ngoto AfterMOX1;\r\n}\r\nif (cs->dc.icc.mon_txc && (cs->dc.icc.mon_txp >= cs->dc.icc.mon_txc)) {\r\nschedule_event(cs, D_TX_MON1);\r\ngoto AfterMOX1;\r\n}\r\ncs->writeisac(cs, ICC_MOX1,\r\ncs->dc.icc.mon_tx[cs->dc.icc.mon_txp++]);\r\nif (cs->debug & L1_DEB_MONITOR)\r\ndebugl1(cs, "ICC %02x -> MOX1", cs->dc.icc.mon_tx[cs->dc.icc.mon_txp - 1]);\r\n}\r\nAfterMOX1:\r\n#endif\r\n}\r\n}\r\n}\r\nstatic void\r\nICC_l1hw(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct IsdnCardState *cs = (struct IsdnCardState *) st->l1.hardware;\r\nstruct sk_buff *skb = arg;\r\nu_long flags;\r\nint val;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nif (cs->debug & DEB_DLOG_HEX)\r\nLogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE)\r\ndlogframe(cs, skb, 0);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->tx_skb) {\r\nskb_queue_tail(&cs->sq, skb);\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA Queued", 0);\r\n#endif\r\n} else {\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA", 0);\r\n#endif\r\nicc_fill_fifo(cs);\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->tx_skb) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, " l2l1 tx_skb exist this shouldn't happen");\r\nskb_queue_tail(&cs->sq, skb);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\n}\r\nif (cs->debug & DEB_DLOG_HEX)\r\nLogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE)\r\ndlogframe(cs, skb, 0);\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA_PULLED", 0);\r\n#endif\r\nicc_fill_fifo(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\ndebugl1(cs, "-> PH_REQUEST_PULL");\r\n#endif\r\nif (!cs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (HW_RESET | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif ((cs->dc.icc.ph_state == ICC_IND_EI1) ||\r\n(cs->dc.icc.ph_state == ICC_IND_DR))\r\nph_command(cs, ICC_CMD_DI);\r\nelse\r\nph_command(cs, ICC_CMD_RES);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_ENABLE | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nph_command(cs, ICC_CMD_DI);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_INFO1 | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nph_command(cs, ICC_CMD_AR);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_INFO3 | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nph_command(cs, ICC_CMD_AI);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_TESTLOOP | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nval = 0;\r\nif (1 & (long) arg)\r\nval |= 0x0c;\r\nif (2 & (long) arg)\r\nval |= 0x3;\r\nif (test_bit(HW_IOM1, &cs->HW_Flags)) {\r\nif (!val) {\r\ncs->writeisac(cs, ICC_SPCR, 0xa);\r\ncs->writeisac(cs, ICC_ADF1, 0x2);\r\n} else {\r\ncs->writeisac(cs, ICC_SPCR, val);\r\ncs->writeisac(cs, ICC_ADF1, 0xa);\r\n}\r\n} else {\r\ncs->writeisac(cs, ICC_SPCR, val);\r\nif (val)\r\ncs->writeisac(cs, ICC_ADF1, 0x8);\r\nelse\r\ncs->writeisac(cs, ICC_ADF1, 0x0);\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_DEACTIVATE | RESPONSE):\r\nskb_queue_purge(&cs->rq);\r\nskb_queue_purge(&cs->sq);\r\nif (cs->tx_skb) {\r\ndev_kfree_skb_any(cs->tx_skb);\r\ncs->tx_skb = NULL;\r\n}\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nbreak;\r\ndefault:\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "icc_l1hw unknown %04x", pr);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nsetstack_icc(struct PStack *st, struct IsdnCardState *cs)\r\n{\r\nst->l1.l1hw = ICC_l1hw;\r\n}\r\nstatic void\r\nDC_Close_icc(struct IsdnCardState *cs) {\r\nkfree(cs->dc.icc.mon_rx);\r\ncs->dc.icc.mon_rx = NULL;\r\nkfree(cs->dc.icc.mon_tx);\r\ncs->dc.icc.mon_tx = NULL;\r\n}\r\nstatic void\r\ndbusy_timer_handler(struct IsdnCardState *cs)\r\n{\r\nstruct PStack *stptr;\r\nint rbch, star;\r\nif (test_bit(FLG_DBUSY_TIMER, &cs->HW_Flags)) {\r\nrbch = cs->readisac(cs, ICC_RBCH);\r\nstar = cs->readisac(cs, ICC_STAR);\r\nif (cs->debug)\r\ndebugl1(cs, "D-Channel Busy RBCH %02x STAR %02x",\r\nrbch, star);\r\nif (rbch & ICC_RBCH_XAC) {\r\ntest_and_set_bit(FLG_L1_DBUSY, &cs->HW_Flags);\r\nstptr = cs->stlist;\r\nwhile (stptr != NULL) {\r\nstptr->l1.l1l2(stptr, PH_PAUSE | INDICATION, NULL);\r\nstptr = stptr->next;\r\n}\r\n} else {\r\ntest_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags);\r\nif (cs->tx_skb) {\r\ndev_kfree_skb_any(cs->tx_skb);\r\ncs->tx_cnt = 0;\r\ncs->tx_skb = NULL;\r\n} else {\r\nprintk(KERN_WARNING "HiSax: ICC D-Channel Busy no skb\n");\r\ndebugl1(cs, "D-Channel Busy no skb");\r\n}\r\ncs->writeisac(cs, ICC_CMDR, 0x01);\r\ncs->irq_func(cs->irq, cs);\r\n}\r\n}\r\n}\r\nvoid\r\niniticc(struct IsdnCardState *cs)\r\n{\r\ncs->setstack_d = setstack_icc;\r\ncs->DC_Close = DC_Close_icc;\r\ncs->dc.icc.mon_tx = NULL;\r\ncs->dc.icc.mon_rx = NULL;\r\ncs->writeisac(cs, ICC_MASK, 0xff);\r\ncs->dc.icc.mocr = 0xaa;\r\nif (test_bit(HW_IOM1, &cs->HW_Flags)) {\r\ncs->writeisac(cs, ICC_ADF2, 0x0);\r\ncs->writeisac(cs, ICC_SPCR, 0xa);\r\ncs->writeisac(cs, ICC_ADF1, 0x2);\r\ncs->writeisac(cs, ICC_STCR, 0x70);\r\ncs->writeisac(cs, ICC_MODE, 0xc9);\r\n} else {\r\nif (!cs->dc.icc.adf2)\r\ncs->dc.icc.adf2 = 0x80;\r\ncs->writeisac(cs, ICC_ADF2, cs->dc.icc.adf2);\r\ncs->writeisac(cs, ICC_SQXR, 0xa0);\r\ncs->writeisac(cs, ICC_SPCR, 0x20);\r\ncs->writeisac(cs, ICC_STCR, 0x70);\r\ncs->writeisac(cs, ICC_MODE, 0xca);\r\ncs->writeisac(cs, ICC_TIMR, 0x00);\r\ncs->writeisac(cs, ICC_ADF1, 0x20);\r\n}\r\nph_command(cs, ICC_CMD_RES);\r\ncs->writeisac(cs, ICC_MASK, 0x0);\r\nph_command(cs, ICC_CMD_DI);\r\n}\r\nvoid\r\nclear_pending_icc_ints(struct IsdnCardState *cs)\r\n{\r\nint val, eval;\r\nval = cs->readisac(cs, ICC_STAR);\r\ndebugl1(cs, "ICC STAR %x", val);\r\nval = cs->readisac(cs, ICC_MODE);\r\ndebugl1(cs, "ICC MODE %x", val);\r\nval = cs->readisac(cs, ICC_ADF2);\r\ndebugl1(cs, "ICC ADF2 %x", val);\r\nval = cs->readisac(cs, ICC_ISTA);\r\ndebugl1(cs, "ICC ISTA %x", val);\r\nif (val & 0x01) {\r\neval = cs->readisac(cs, ICC_EXIR);\r\ndebugl1(cs, "ICC EXIR %x", eval);\r\n}\r\nval = cs->readisac(cs, ICC_CIR0);\r\ndebugl1(cs, "ICC CIR0 %x", val);\r\ncs->dc.icc.ph_state = (val >> 2) & 0xf;\r\nschedule_event(cs, D_L1STATECHANGE);\r\ncs->writeisac(cs, ICC_MASK, 0xFF);\r\n}\r\nvoid __devinit\r\nsetup_icc(struct IsdnCardState *cs)\r\n{\r\nINIT_WORK(&cs->tqueue, icc_bh);\r\ncs->dbusytimer.function = (void *) dbusy_timer_handler;\r\ncs->dbusytimer.data = (long) cs;\r\ninit_timer(&cs->dbusytimer);\r\n}
