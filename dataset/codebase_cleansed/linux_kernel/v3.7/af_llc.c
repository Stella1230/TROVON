static inline u16 llc_ui_next_link_no(int sap)\r\n{\r\nreturn llc_ui_sap_link_no_max[sap]++;\r\n}\r\nstatic inline __be16 llc_proto_type(u16 arphrd)\r\n{\r\nreturn htons(ETH_P_802_2);\r\n}\r\nstatic inline u8 llc_ui_addr_null(struct sockaddr_llc *addr)\r\n{\r\nreturn !memcmp(addr, &llc_ui_addrnull, sizeof(*addr));\r\n}\r\nstatic inline u8 llc_ui_header_len(struct sock *sk, struct sockaddr_llc *addr)\r\n{\r\nu8 rc = LLC_PDU_LEN_U;\r\nif (addr->sllc_test || addr->sllc_xid)\r\nrc = LLC_PDU_LEN_U;\r\nelse if (sk->sk_type == SOCK_STREAM)\r\nrc = LLC_PDU_LEN_I;\r\nreturn rc;\r\n}\r\nstatic int llc_ui_send_data(struct sock* sk, struct sk_buff *skb, int noblock)\r\n{\r\nstruct llc_sock* llc = llc_sk(sk);\r\nint rc = 0;\r\nif (unlikely(llc_data_accept_state(llc->state) ||\r\nllc->remote_busy_flag ||\r\nllc->p_flag)) {\r\nlong timeout = sock_sndtimeo(sk, noblock);\r\nrc = llc_ui_wait_for_busy_core(sk, timeout);\r\n}\r\nif (unlikely(!rc))\r\nrc = llc_build_and_send_pkt(sk, skb);\r\nreturn rc;\r\n}\r\nstatic void llc_ui_sk_init(struct socket *sock, struct sock *sk)\r\n{\r\nsock_graft(sk, sock);\r\nsk->sk_type = sock->type;\r\nsock->ops = &llc_ui_ops;\r\n}\r\nstatic int llc_ui_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nint rc = -ESOCKTNOSUPPORT;\r\nif (!capable(CAP_NET_RAW))\r\nreturn -EPERM;\r\nif (!net_eq(net, &init_net))\r\nreturn -EAFNOSUPPORT;\r\nif (likely(sock->type == SOCK_DGRAM || sock->type == SOCK_STREAM)) {\r\nrc = -ENOMEM;\r\nsk = llc_sk_alloc(net, PF_LLC, GFP_KERNEL, &llc_proto);\r\nif (sk) {\r\nrc = 0;\r\nllc_ui_sk_init(sock, sk);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int llc_ui_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct llc_sock *llc;\r\nif (unlikely(sk == NULL))\r\ngoto out;\r\nsock_hold(sk);\r\nlock_sock(sk);\r\nllc = llc_sk(sk);\r\ndprintk("%s: closing local(%02X) remote(%02X)\n", __func__,\r\nllc->laddr.lsap, llc->daddr.lsap);\r\nif (!llc_send_disc(sk))\r\nllc_ui_wait_for_disc(sk, sk->sk_rcvtimeo);\r\nif (!sock_flag(sk, SOCK_ZAPPED))\r\nllc_sap_remove_socket(llc->sap, sk);\r\nrelease_sock(sk);\r\nif (llc->dev)\r\ndev_put(llc->dev);\r\nsock_put(sk);\r\nllc_sk_free(sk);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int llc_ui_autoport(void)\r\n{\r\nstruct llc_sap *sap;\r\nint i, tries = 0;\r\nwhile (tries < LLC_SAP_DYN_TRIES) {\r\nfor (i = llc_ui_sap_last_autoport;\r\ni < LLC_SAP_DYN_STOP; i += 2) {\r\nsap = llc_sap_find(i);\r\nif (!sap) {\r\nllc_ui_sap_last_autoport = i + 2;\r\ngoto out;\r\n}\r\nllc_sap_put(sap);\r\n}\r\nllc_ui_sap_last_autoport = LLC_SAP_DYN_START;\r\ntries++;\r\n}\r\ni = 0;\r\nout:\r\nreturn i;\r\n}\r\nstatic int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct llc_sock *llc = llc_sk(sk);\r\nstruct llc_sap *sap;\r\nint rc = -EINVAL;\r\nif (!sock_flag(sk, SOCK_ZAPPED))\r\ngoto out;\r\nrc = -ENODEV;\r\nif (sk->sk_bound_dev_if) {\r\nllc->dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);\r\nif (llc->dev && addr->sllc_arphrd != llc->dev->type) {\r\ndev_put(llc->dev);\r\nllc->dev = NULL;\r\n}\r\n} else\r\nllc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\r\nif (!llc->dev)\r\ngoto out;\r\nrc = -EUSERS;\r\nllc->laddr.lsap = llc_ui_autoport();\r\nif (!llc->laddr.lsap)\r\ngoto out;\r\nrc = -EBUSY;\r\nsap = llc_sap_open(llc->laddr.lsap, NULL);\r\nif (!sap)\r\ngoto out;\r\nmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\r\nmemcpy(&llc->addr, addr, sizeof(llc->addr));\r\nllc_sap_add_socket(sap, sk);\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int llc_ui_bind(struct socket *sock, struct sockaddr *uaddr, int addrlen)\r\n{\r\nstruct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nstruct llc_sock *llc = llc_sk(sk);\r\nstruct llc_sap *sap;\r\nint rc = -EINVAL;\r\ndprintk("%s: binding %02X\n", __func__, addr->sllc_sap);\r\nif (unlikely(!sock_flag(sk, SOCK_ZAPPED) || addrlen != sizeof(*addr)))\r\ngoto out;\r\nrc = -EAFNOSUPPORT;\r\nif (unlikely(addr->sllc_family != AF_LLC))\r\ngoto out;\r\nrc = -ENODEV;\r\nrcu_read_lock();\r\nif (sk->sk_bound_dev_if) {\r\nllc->dev = dev_get_by_index_rcu(&init_net, sk->sk_bound_dev_if);\r\nif (llc->dev) {\r\nif (!addr->sllc_arphrd)\r\naddr->sllc_arphrd = llc->dev->type;\r\nif (llc_mac_null(addr->sllc_mac))\r\nmemcpy(addr->sllc_mac, llc->dev->dev_addr,\r\nIFHWADDRLEN);\r\nif (addr->sllc_arphrd != llc->dev->type ||\r\n!llc_mac_match(addr->sllc_mac,\r\nllc->dev->dev_addr)) {\r\nrc = -EINVAL;\r\nllc->dev = NULL;\r\n}\r\n}\r\n} else\r\nllc->dev = dev_getbyhwaddr_rcu(&init_net, addr->sllc_arphrd,\r\naddr->sllc_mac);\r\nif (llc->dev)\r\ndev_hold(llc->dev);\r\nrcu_read_unlock();\r\nif (!llc->dev)\r\ngoto out;\r\nif (!addr->sllc_sap) {\r\nrc = -EUSERS;\r\naddr->sllc_sap = llc_ui_autoport();\r\nif (!addr->sllc_sap)\r\ngoto out;\r\n}\r\nsap = llc_sap_find(addr->sllc_sap);\r\nif (!sap) {\r\nsap = llc_sap_open(addr->sllc_sap, NULL);\r\nrc = -EBUSY;\r\nif (!sap)\r\ngoto out;\r\n} else {\r\nstruct llc_addr laddr, daddr;\r\nstruct sock *ask;\r\nmemset(&laddr, 0, sizeof(laddr));\r\nmemset(&daddr, 0, sizeof(daddr));\r\nmemcpy(laddr.mac, addr->sllc_mac, IFHWADDRLEN);\r\nladdr.lsap = addr->sllc_sap;\r\nrc = -EADDRINUSE;\r\nask = llc_lookup_established(sap, &daddr, &laddr);\r\nif (ask) {\r\nsock_put(ask);\r\ngoto out_put;\r\n}\r\n}\r\nllc->laddr.lsap = addr->sllc_sap;\r\nmemcpy(llc->laddr.mac, addr->sllc_mac, IFHWADDRLEN);\r\nmemcpy(&llc->addr, addr, sizeof(llc->addr));\r\nllc_sap_add_socket(sap, sk);\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nrc = 0;\r\nout_put:\r\nllc_sap_put(sap);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int llc_ui_shutdown(struct socket *sock, int how)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint rc = -ENOTCONN;\r\nlock_sock(sk);\r\nif (unlikely(sk->sk_state != TCP_ESTABLISHED))\r\ngoto out;\r\nrc = -EINVAL;\r\nif (how != 2)\r\ngoto out;\r\nrc = llc_send_disc(sk);\r\nif (!rc)\r\nrc = llc_ui_wait_for_disc(sk, sk->sk_rcvtimeo);\r\nsk->sk_state_change(sk);\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int llc_ui_connect(struct socket *sock, struct sockaddr *uaddr,\r\nint addrlen, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct llc_sock *llc = llc_sk(sk);\r\nstruct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;\r\nint rc = -EINVAL;\r\nlock_sock(sk);\r\nif (unlikely(addrlen != sizeof(*addr)))\r\ngoto out;\r\nrc = -EAFNOSUPPORT;\r\nif (unlikely(addr->sllc_family != AF_LLC))\r\ngoto out;\r\nif (unlikely(sk->sk_type != SOCK_STREAM))\r\ngoto out;\r\nrc = -EALREADY;\r\nif (unlikely(sock->state == SS_CONNECTING))\r\ngoto out;\r\nif (sock_flag(sk, SOCK_ZAPPED)) {\r\nrc = llc_ui_autobind(sock, addr);\r\nif (rc)\r\ngoto out;\r\n}\r\nllc->daddr.lsap = addr->sllc_sap;\r\nmemcpy(llc->daddr.mac, addr->sllc_mac, IFHWADDRLEN);\r\nsock->state = SS_CONNECTING;\r\nsk->sk_state = TCP_SYN_SENT;\r\nllc->link = llc_ui_next_link_no(llc->sap->laddr.lsap);\r\nrc = llc_establish_connection(sk, llc->dev->dev_addr,\r\naddr->sllc_mac, addr->sllc_sap);\r\nif (rc) {\r\ndprintk("%s: llc_ui_send_conn failed :-(\n", __func__);\r\nsock->state = SS_UNCONNECTED;\r\nsk->sk_state = TCP_CLOSE;\r\ngoto out;\r\n}\r\nif (sk->sk_state == TCP_SYN_SENT) {\r\nconst long timeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\r\nif (!timeo || !llc_ui_wait_for_conn(sk, timeo))\r\ngoto out;\r\nrc = sock_intr_errno(timeo);\r\nif (signal_pending(current))\r\ngoto out;\r\n}\r\nif (sk->sk_state == TCP_CLOSE)\r\ngoto sock_error;\r\nsock->state = SS_CONNECTED;\r\nrc = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\nsock_error:\r\nrc = sock_error(sk) ? : -ECONNABORTED;\r\nsock->state = SS_UNCONNECTED;\r\ngoto out;\r\n}\r\nstatic int llc_ui_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint rc = -EINVAL;\r\nlock_sock(sk);\r\nif (unlikely(sock->state != SS_UNCONNECTED))\r\ngoto out;\r\nrc = -EOPNOTSUPP;\r\nif (unlikely(sk->sk_type != SOCK_STREAM))\r\ngoto out;\r\nrc = -EAGAIN;\r\nif (sock_flag(sk, SOCK_ZAPPED))\r\ngoto out;\r\nrc = 0;\r\nif (!(unsigned int)backlog)\r\nbacklog = 1;\r\nsk->sk_max_ack_backlog = backlog;\r\nif (sk->sk_state != TCP_LISTEN) {\r\nsk->sk_ack_backlog = 0;\r\nsk->sk_state = TCP_LISTEN;\r\n}\r\nsk->sk_socket->flags |= __SO_ACCEPTCON;\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int llc_ui_wait_for_disc(struct sock *sk, long timeout)\r\n{\r\nDEFINE_WAIT(wait);\r\nint rc = 0;\r\nwhile (1) {\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nif (sk_wait_event(sk, &timeout, sk->sk_state == TCP_CLOSE))\r\nbreak;\r\nrc = -ERESTARTSYS;\r\nif (signal_pending(current))\r\nbreak;\r\nrc = -EAGAIN;\r\nif (!timeout)\r\nbreak;\r\nrc = 0;\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nreturn rc;\r\n}\r\nstatic int llc_ui_wait_for_conn(struct sock *sk, long timeout)\r\n{\r\nDEFINE_WAIT(wait);\r\nwhile (1) {\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nif (sk_wait_event(sk, &timeout, sk->sk_state != TCP_SYN_SENT))\r\nbreak;\r\nif (signal_pending(current) || !timeout)\r\nbreak;\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nreturn timeout;\r\n}\r\nstatic int llc_ui_wait_for_busy_core(struct sock *sk, long timeout)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct llc_sock *llc = llc_sk(sk);\r\nint rc;\r\nwhile (1) {\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nrc = 0;\r\nif (sk_wait_event(sk, &timeout,\r\n(sk->sk_shutdown & RCV_SHUTDOWN) ||\r\n(!llc_data_accept_state(llc->state) &&\r\n!llc->remote_busy_flag &&\r\n!llc->p_flag)))\r\nbreak;\r\nrc = -ERESTARTSYS;\r\nif (signal_pending(current))\r\nbreak;\r\nrc = -EAGAIN;\r\nif (!timeout)\r\nbreak;\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nreturn rc;\r\n}\r\nstatic int llc_wait_data(struct sock *sk, long timeo)\r\n{\r\nint rc;\r\nwhile (1) {\r\nrc = sock_error(sk);\r\nif (rc)\r\nbreak;\r\nrc = 0;\r\nif (sk->sk_shutdown & RCV_SHUTDOWN)\r\nbreak;\r\nrc = -EAGAIN;\r\nif (!timeo)\r\nbreak;\r\nrc = sock_intr_errno(timeo);\r\nif (signal_pending(current))\r\nbreak;\r\nrc = 0;\r\nif (sk_wait_data(sk, &timeo))\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)\r\n{\r\nstruct llc_sock *llc = llc_sk(skb->sk);\r\nif (llc->cmsg_flags & LLC_CMSG_PKTINFO) {\r\nstruct llc_pktinfo info;\r\ninfo.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;\r\nllc_pdu_decode_dsap(skb, &info.lpi_sap);\r\nllc_pdu_decode_da(skb, info.lpi_mac);\r\nput_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);\r\n}\r\n}\r\nstatic int llc_ui_accept(struct socket *sock, struct socket *newsock, int flags)\r\n{\r\nstruct sock *sk = sock->sk, *newsk;\r\nstruct llc_sock *llc, *newllc;\r\nstruct sk_buff *skb;\r\nint rc = -EOPNOTSUPP;\r\ndprintk("%s: accepting on %02X\n", __func__,\r\nllc_sk(sk)->laddr.lsap);\r\nlock_sock(sk);\r\nif (unlikely(sk->sk_type != SOCK_STREAM))\r\ngoto out;\r\nrc = -EINVAL;\r\nif (unlikely(sock->state != SS_UNCONNECTED ||\r\nsk->sk_state != TCP_LISTEN))\r\ngoto out;\r\nif (skb_queue_empty(&sk->sk_receive_queue)) {\r\nrc = llc_wait_data(sk, sk->sk_rcvtimeo);\r\nif (rc)\r\ngoto out;\r\n}\r\ndprintk("%s: got a new connection on %02X\n", __func__,\r\nllc_sk(sk)->laddr.lsap);\r\nskb = skb_dequeue(&sk->sk_receive_queue);\r\nrc = -EINVAL;\r\nif (!skb->sk)\r\ngoto frees;\r\nrc = 0;\r\nnewsk = skb->sk;\r\nllc_ui_sk_init(newsock, newsk);\r\nsock_reset_flag(newsk, SOCK_ZAPPED);\r\nnewsk->sk_state = TCP_ESTABLISHED;\r\nnewsock->state = SS_CONNECTED;\r\nllc = llc_sk(sk);\r\nnewllc = llc_sk(newsk);\r\nmemcpy(&newllc->addr, &llc->addr, sizeof(newllc->addr));\r\nnewllc->link = llc_ui_next_link_no(newllc->laddr.lsap);\r\nsk->sk_state = TCP_LISTEN;\r\nsk->sk_ack_backlog--;\r\ndprintk("%s: ok success on %02X, client on %02X\n", __func__,\r\nllc_sk(sk)->addr.sllc_sap, newllc->daddr.lsap);\r\nfrees:\r\nkfree_skb(skb);\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len, int flags)\r\n{\r\nstruct sockaddr_llc *uaddr = (struct sockaddr_llc *)msg->msg_name;\r\nconst int nonblock = flags & MSG_DONTWAIT;\r\nstruct sk_buff *skb = NULL;\r\nstruct sock *sk = sock->sk;\r\nstruct llc_sock *llc = llc_sk(sk);\r\nunsigned long cpu_flags;\r\nsize_t copied = 0;\r\nu32 peek_seq = 0;\r\nu32 *seq;\r\nunsigned long used;\r\nint target;\r\nlong timeo;\r\nlock_sock(sk);\r\ncopied = -ENOTCONN;\r\nif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))\r\ngoto out;\r\ntimeo = sock_rcvtimeo(sk, nonblock);\r\nseq = &llc->copied_seq;\r\nif (flags & MSG_PEEK) {\r\npeek_seq = llc->copied_seq;\r\nseq = &peek_seq;\r\n}\r\ntarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\r\ncopied = 0;\r\ndo {\r\nu32 offset;\r\nif (signal_pending(current)) {\r\nif (copied)\r\nbreak;\r\ncopied = timeo ? sock_intr_errno(timeo) : -EAGAIN;\r\nbreak;\r\n}\r\nskb = skb_peek(&sk->sk_receive_queue);\r\nif (skb) {\r\noffset = *seq;\r\ngoto found_ok_skb;\r\n}\r\nif (copied >= target && !sk->sk_backlog.tail)\r\nbreak;\r\nif (copied) {\r\nif (sk->sk_err ||\r\nsk->sk_state == TCP_CLOSE ||\r\n(sk->sk_shutdown & RCV_SHUTDOWN) ||\r\n!timeo ||\r\n(flags & MSG_PEEK))\r\nbreak;\r\n} else {\r\nif (sock_flag(sk, SOCK_DONE))\r\nbreak;\r\nif (sk->sk_err) {\r\ncopied = sock_error(sk);\r\nbreak;\r\n}\r\nif (sk->sk_shutdown & RCV_SHUTDOWN)\r\nbreak;\r\nif (sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_CLOSE) {\r\nif (!sock_flag(sk, SOCK_DONE)) {\r\ncopied = -ENOTCONN;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nif (!timeo) {\r\ncopied = -EAGAIN;\r\nbreak;\r\n}\r\n}\r\nif (copied >= target) {\r\nrelease_sock(sk);\r\nlock_sock(sk);\r\n} else\r\nsk_wait_data(sk, &timeo);\r\nif ((flags & MSG_PEEK) && peek_seq != llc->copied_seq) {\r\nnet_dbg_ratelimited("LLC(%s:%d): Application bug, race in MSG_PEEK\n",\r\ncurrent->comm,\r\ntask_pid_nr(current));\r\npeek_seq = llc->copied_seq;\r\n}\r\ncontinue;\r\nfound_ok_skb:\r\nused = skb->len - offset;\r\nif (len < used)\r\nused = len;\r\nif (!(flags & MSG_TRUNC)) {\r\nint rc = skb_copy_datagram_iovec(skb, offset,\r\nmsg->msg_iov, used);\r\nif (rc) {\r\nif (!copied)\r\ncopied = -EFAULT;\r\nbreak;\r\n}\r\n}\r\n*seq += used;\r\ncopied += used;\r\nlen -= used;\r\nif (sk->sk_type != SOCK_STREAM)\r\ngoto copy_uaddr;\r\nif (!(flags & MSG_PEEK)) {\r\nspin_lock_irqsave(&sk->sk_receive_queue.lock, cpu_flags);\r\nsk_eat_skb(sk, skb, false);\r\nspin_unlock_irqrestore(&sk->sk_receive_queue.lock, cpu_flags);\r\n*seq = 0;\r\n}\r\nif (used + offset < skb->len)\r\ncontinue;\r\n} while (len > 0);\r\nout:\r\nrelease_sock(sk);\r\nreturn copied;\r\ncopy_uaddr:\r\nif (uaddr != NULL && skb != NULL) {\r\nmemcpy(uaddr, llc_ui_skb_cb(skb), sizeof(*uaddr));\r\nmsg->msg_namelen = sizeof(*uaddr);\r\n}\r\nif (llc_sk(sk)->cmsg_flags)\r\nllc_cmsg_rcv(msg, skb);\r\nif (!(flags & MSG_PEEK)) {\r\nspin_lock_irqsave(&sk->sk_receive_queue.lock, cpu_flags);\r\nsk_eat_skb(sk, skb, false);\r\nspin_unlock_irqrestore(&sk->sk_receive_queue.lock, cpu_flags);\r\n*seq = 0;\r\n}\r\ngoto out;\r\n}\r\nstatic int llc_ui_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct llc_sock *llc = llc_sk(sk);\r\nstruct sockaddr_llc *addr = (struct sockaddr_llc *)msg->msg_name;\r\nint flags = msg->msg_flags;\r\nint noblock = flags & MSG_DONTWAIT;\r\nstruct sk_buff *skb;\r\nsize_t size = 0;\r\nint rc = -EINVAL, copied = 0, hdrlen;\r\ndprintk("%s: sending from %02X to %02X\n", __func__,\r\nllc->laddr.lsap, llc->daddr.lsap);\r\nlock_sock(sk);\r\nif (addr) {\r\nif (msg->msg_namelen < sizeof(*addr))\r\ngoto release;\r\n} else {\r\nif (llc_ui_addr_null(&llc->addr))\r\ngoto release;\r\naddr = &llc->addr;\r\n}\r\nif (sock_flag(sk, SOCK_ZAPPED)) {\r\nrc = llc_ui_autobind(sock, addr);\r\nif (rc)\r\ngoto release;\r\n}\r\nhdrlen = llc->dev->hard_header_len + llc_ui_header_len(sk, addr);\r\nsize = hdrlen + len;\r\nif (size > llc->dev->mtu)\r\nsize = llc->dev->mtu;\r\ncopied = size - hdrlen;\r\nrelease_sock(sk);\r\nskb = sock_alloc_send_skb(sk, size, noblock, &rc);\r\nlock_sock(sk);\r\nif (!skb)\r\ngoto release;\r\nskb->dev = llc->dev;\r\nskb->protocol = llc_proto_type(addr->sllc_arphrd);\r\nskb_reserve(skb, hdrlen);\r\nrc = memcpy_fromiovec(skb_put(skb, copied), msg->msg_iov, copied);\r\nif (rc)\r\ngoto out;\r\nif (sk->sk_type == SOCK_DGRAM || addr->sllc_ua) {\r\nllc_build_and_send_ui_pkt(llc->sap, skb, addr->sllc_mac,\r\naddr->sllc_sap);\r\ngoto out;\r\n}\r\nif (addr->sllc_test) {\r\nllc_build_and_send_test_pkt(llc->sap, skb, addr->sllc_mac,\r\naddr->sllc_sap);\r\ngoto out;\r\n}\r\nif (addr->sllc_xid) {\r\nllc_build_and_send_xid_pkt(llc->sap, skb, addr->sllc_mac,\r\naddr->sllc_sap);\r\ngoto out;\r\n}\r\nrc = -ENOPROTOOPT;\r\nif (!(sk->sk_type == SOCK_STREAM && !addr->sllc_ua))\r\ngoto out;\r\nrc = llc_ui_send_data(sk, skb, noblock);\r\nout:\r\nif (rc) {\r\nkfree_skb(skb);\r\nrelease:\r\ndprintk("%s: failed sending from %02X to %02X: %d\n",\r\n__func__, llc->laddr.lsap, llc->daddr.lsap, rc);\r\n}\r\nrelease_sock(sk);\r\nreturn rc ? : copied;\r\n}\r\nstatic int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddrlen, int peer)\r\n{\r\nstruct sockaddr_llc sllc;\r\nstruct sock *sk = sock->sk;\r\nstruct llc_sock *llc = llc_sk(sk);\r\nint rc = -EBADF;\r\nmemset(&sllc, 0, sizeof(sllc));\r\nlock_sock(sk);\r\nif (sock_flag(sk, SOCK_ZAPPED))\r\ngoto out;\r\n*uaddrlen = sizeof(sllc);\r\nif (peer) {\r\nrc = -ENOTCONN;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\ngoto out;\r\nif(llc->dev)\r\nsllc.sllc_arphrd = llc->dev->type;\r\nsllc.sllc_sap = llc->daddr.lsap;\r\nmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\r\n} else {\r\nrc = -EINVAL;\r\nif (!llc->sap)\r\ngoto out;\r\nsllc.sllc_sap = llc->sap->laddr.lsap;\r\nif (llc->dev) {\r\nsllc.sllc_arphrd = llc->dev->type;\r\nmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\r\nIFHWADDRLEN);\r\n}\r\n}\r\nrc = 0;\r\nsllc.sllc_family = AF_LLC;\r\nmemcpy(uaddr, &sllc, sizeof(sllc));\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int llc_ui_ioctl(struct socket *sock, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int llc_ui_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct llc_sock *llc = llc_sk(sk);\r\nunsigned int opt;\r\nint rc = -EINVAL;\r\nlock_sock(sk);\r\nif (unlikely(level != SOL_LLC || optlen != sizeof(int)))\r\ngoto out;\r\nrc = get_user(opt, (int __user *)optval);\r\nif (rc)\r\ngoto out;\r\nrc = -EINVAL;\r\nswitch (optname) {\r\ncase LLC_OPT_RETRY:\r\nif (opt > LLC_OPT_MAX_RETRY)\r\ngoto out;\r\nllc->n2 = opt;\r\nbreak;\r\ncase LLC_OPT_SIZE:\r\nif (opt > LLC_OPT_MAX_SIZE)\r\ngoto out;\r\nllc->n1 = opt;\r\nbreak;\r\ncase LLC_OPT_ACK_TMR_EXP:\r\nif (opt > LLC_OPT_MAX_ACK_TMR_EXP)\r\ngoto out;\r\nllc->ack_timer.expire = opt * HZ;\r\nbreak;\r\ncase LLC_OPT_P_TMR_EXP:\r\nif (opt > LLC_OPT_MAX_P_TMR_EXP)\r\ngoto out;\r\nllc->pf_cycle_timer.expire = opt * HZ;\r\nbreak;\r\ncase LLC_OPT_REJ_TMR_EXP:\r\nif (opt > LLC_OPT_MAX_REJ_TMR_EXP)\r\ngoto out;\r\nllc->rej_sent_timer.expire = opt * HZ;\r\nbreak;\r\ncase LLC_OPT_BUSY_TMR_EXP:\r\nif (opt > LLC_OPT_MAX_BUSY_TMR_EXP)\r\ngoto out;\r\nllc->busy_state_timer.expire = opt * HZ;\r\nbreak;\r\ncase LLC_OPT_TX_WIN:\r\nif (opt > LLC_OPT_MAX_WIN)\r\ngoto out;\r\nllc->k = opt;\r\nbreak;\r\ncase LLC_OPT_RX_WIN:\r\nif (opt > LLC_OPT_MAX_WIN)\r\ngoto out;\r\nllc->rw = opt;\r\nbreak;\r\ncase LLC_OPT_PKTINFO:\r\nif (opt)\r\nllc->cmsg_flags |= LLC_CMSG_PKTINFO;\r\nelse\r\nllc->cmsg_flags &= ~LLC_CMSG_PKTINFO;\r\nbreak;\r\ndefault:\r\nrc = -ENOPROTOOPT;\r\ngoto out;\r\n}\r\nrc = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int llc_ui_getsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct llc_sock *llc = llc_sk(sk);\r\nint val = 0, len = 0, rc = -EINVAL;\r\nlock_sock(sk);\r\nif (unlikely(level != SOL_LLC))\r\ngoto out;\r\nrc = get_user(len, optlen);\r\nif (rc)\r\ngoto out;\r\nrc = -EINVAL;\r\nif (len != sizeof(int))\r\ngoto out;\r\nswitch (optname) {\r\ncase LLC_OPT_RETRY:\r\nval = llc->n2; break;\r\ncase LLC_OPT_SIZE:\r\nval = llc->n1; break;\r\ncase LLC_OPT_ACK_TMR_EXP:\r\nval = llc->ack_timer.expire / HZ; break;\r\ncase LLC_OPT_P_TMR_EXP:\r\nval = llc->pf_cycle_timer.expire / HZ; break;\r\ncase LLC_OPT_REJ_TMR_EXP:\r\nval = llc->rej_sent_timer.expire / HZ; break;\r\ncase LLC_OPT_BUSY_TMR_EXP:\r\nval = llc->busy_state_timer.expire / HZ; break;\r\ncase LLC_OPT_TX_WIN:\r\nval = llc->k; break;\r\ncase LLC_OPT_RX_WIN:\r\nval = llc->rw; break;\r\ncase LLC_OPT_PKTINFO:\r\nval = (llc->cmsg_flags & LLC_CMSG_PKTINFO) != 0;\r\nbreak;\r\ndefault:\r\nrc = -ENOPROTOOPT;\r\ngoto out;\r\n}\r\nrc = 0;\r\nif (put_user(len, optlen) || copy_to_user(optval, &val, len))\r\nrc = -EFAULT;\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int __init llc2_init(void)\r\n{\r\nint rc = proto_register(&llc_proto, 0);\r\nif (rc != 0)\r\ngoto out;\r\nllc_build_offset_table();\r\nllc_station_init();\r\nllc_ui_sap_last_autoport = LLC_SAP_DYN_START;\r\nrc = llc_proc_init();\r\nif (rc != 0) {\r\nprintk(llc_proc_err_msg);\r\ngoto out_station;\r\n}\r\nrc = llc_sysctl_init();\r\nif (rc) {\r\nprintk(llc_sysctl_err_msg);\r\ngoto out_proc;\r\n}\r\nrc = sock_register(&llc_ui_family_ops);\r\nif (rc) {\r\nprintk(llc_sock_err_msg);\r\ngoto out_sysctl;\r\n}\r\nllc_add_pack(LLC_DEST_SAP, llc_sap_handler);\r\nllc_add_pack(LLC_DEST_CONN, llc_conn_handler);\r\nout:\r\nreturn rc;\r\nout_sysctl:\r\nllc_sysctl_exit();\r\nout_proc:\r\nllc_proc_exit();\r\nout_station:\r\nllc_station_exit();\r\nproto_unregister(&llc_proto);\r\ngoto out;\r\n}\r\nstatic void __exit llc2_exit(void)\r\n{\r\nllc_station_exit();\r\nllc_remove_pack(LLC_DEST_SAP);\r\nllc_remove_pack(LLC_DEST_CONN);\r\nsock_unregister(PF_LLC);\r\nllc_proc_exit();\r\nllc_sysctl_exit();\r\nproto_unregister(&llc_proto);\r\n}
