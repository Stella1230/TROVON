void omap_vout_default_crop(struct v4l2_pix_format *pix,\r\nstruct v4l2_framebuffer *fbuf, struct v4l2_rect *crop)\r\n{\r\ncrop->width = (pix->width < fbuf->fmt.width) ?\r\npix->width : fbuf->fmt.width;\r\ncrop->height = (pix->height < fbuf->fmt.height) ?\r\npix->height : fbuf->fmt.height;\r\ncrop->width &= ~1;\r\ncrop->height &= ~1;\r\ncrop->left = ((pix->width - crop->width) >> 1) & ~1;\r\ncrop->top = ((pix->height - crop->height) >> 1) & ~1;\r\n}\r\nint omap_vout_try_window(struct v4l2_framebuffer *fbuf,\r\nstruct v4l2_window *new_win)\r\n{\r\nstruct v4l2_rect try_win;\r\ntry_win = new_win->w;\r\nif (try_win.left < 0) {\r\ntry_win.width += try_win.left;\r\ntry_win.left = 0;\r\n}\r\nif (try_win.top < 0) {\r\ntry_win.height += try_win.top;\r\ntry_win.top = 0;\r\n}\r\ntry_win.width = (try_win.width < fbuf->fmt.width) ?\r\ntry_win.width : fbuf->fmt.width;\r\ntry_win.height = (try_win.height < fbuf->fmt.height) ?\r\ntry_win.height : fbuf->fmt.height;\r\nif (try_win.left + try_win.width > fbuf->fmt.width)\r\ntry_win.width = fbuf->fmt.width - try_win.left;\r\nif (try_win.top + try_win.height > fbuf->fmt.height)\r\ntry_win.height = fbuf->fmt.height - try_win.top;\r\ntry_win.width &= ~1;\r\ntry_win.height &= ~1;\r\nif (try_win.width <= 0 || try_win.height <= 0)\r\nreturn -EINVAL;\r\nnew_win->w = try_win;\r\nnew_win->field = V4L2_FIELD_ANY;\r\nreturn 0;\r\n}\r\nint omap_vout_new_window(struct v4l2_rect *crop,\r\nstruct v4l2_window *win, struct v4l2_framebuffer *fbuf,\r\nstruct v4l2_window *new_win)\r\n{\r\nint err;\r\nerr = omap_vout_try_window(fbuf, new_win);\r\nif (err)\r\nreturn err;\r\nwin->w = new_win->w;\r\nwin->field = new_win->field;\r\nwin->chromakey = new_win->chromakey;\r\nif (cpu_is_omap24xx()) {\r\nif ((crop->height/win->w.height) >= 2)\r\ncrop->height = win->w.height * 2;\r\nif ((crop->width/win->w.width) >= 2)\r\ncrop->width = win->w.width * 2;\r\nif (crop->width > 768) {\r\nif (crop->height != win->w.height)\r\ncrop->width = 768;\r\n}\r\n} else if (cpu_is_omap34xx()) {\r\nif ((crop->height/win->w.height) >= 4)\r\ncrop->height = win->w.height * 4;\r\nif ((crop->width/win->w.width) >= 4)\r\ncrop->width = win->w.width * 4;\r\n}\r\nreturn 0;\r\n}\r\nint omap_vout_new_crop(struct v4l2_pix_format *pix,\r\nstruct v4l2_rect *crop, struct v4l2_window *win,\r\nstruct v4l2_framebuffer *fbuf, const struct v4l2_rect *new_crop)\r\n{\r\nstruct v4l2_rect try_crop;\r\nunsigned long vresize, hresize;\r\ntry_crop = *new_crop;\r\nif (try_crop.left < 0) {\r\ntry_crop.width += try_crop.left;\r\ntry_crop.left = 0;\r\n}\r\nif (try_crop.top < 0) {\r\ntry_crop.height += try_crop.top;\r\ntry_crop.top = 0;\r\n}\r\ntry_crop.width = (try_crop.width < pix->width) ?\r\ntry_crop.width : pix->width;\r\ntry_crop.height = (try_crop.height < pix->height) ?\r\ntry_crop.height : pix->height;\r\nif (try_crop.left + try_crop.width > pix->width)\r\ntry_crop.width = pix->width - try_crop.left;\r\nif (try_crop.top + try_crop.height > pix->height)\r\ntry_crop.height = pix->height - try_crop.top;\r\ntry_crop.width &= ~1;\r\ntry_crop.height &= ~1;\r\nif (try_crop.width <= 0 || try_crop.height <= 0)\r\nreturn -EINVAL;\r\nif (cpu_is_omap24xx()) {\r\nif (try_crop.height != win->w.height) {\r\nif (try_crop.width > 768)\r\ntry_crop.width = 768;\r\n}\r\n}\r\nvresize = (1024 * try_crop.height) / win->w.height;\r\nif (cpu_is_omap24xx() && (vresize > 2048))\r\nvresize = 2048;\r\nelse if (cpu_is_omap34xx() && (vresize > 4096))\r\nvresize = 4096;\r\nwin->w.height = ((1024 * try_crop.height) / vresize) & ~1;\r\nif (win->w.height == 0)\r\nwin->w.height = 2;\r\nif (win->w.height + win->w.top > fbuf->fmt.height) {\r\nwin->w.height = (fbuf->fmt.height - win->w.top) & ~1;\r\nif (try_crop.height == 0)\r\ntry_crop.height = 2;\r\n}\r\nhresize = (1024 * try_crop.width) / win->w.width;\r\nif (cpu_is_omap24xx() && (hresize > 2048))\r\nhresize = 2048;\r\nelse if (cpu_is_omap34xx() && (hresize > 4096))\r\nhresize = 4096;\r\nwin->w.width = ((1024 * try_crop.width) / hresize) & ~1;\r\nif (win->w.width == 0)\r\nwin->w.width = 2;\r\nif (win->w.width + win->w.left > fbuf->fmt.width) {\r\nwin->w.width = (fbuf->fmt.width - win->w.left) & ~1;\r\nif (try_crop.width == 0)\r\ntry_crop.width = 2;\r\n}\r\nif (cpu_is_omap24xx()) {\r\nif ((try_crop.height/win->w.height) >= 2)\r\ntry_crop.height = win->w.height * 2;\r\nif ((try_crop.width/win->w.width) >= 2)\r\ntry_crop.width = win->w.width * 2;\r\nif (try_crop.width > 768) {\r\nif (try_crop.height != win->w.height)\r\ntry_crop.width = 768;\r\n}\r\n} else if (cpu_is_omap34xx()) {\r\nif ((try_crop.height/win->w.height) >= 4)\r\ntry_crop.height = win->w.height * 4;\r\nif ((try_crop.width/win->w.width) >= 4)\r\ntry_crop.width = win->w.width * 4;\r\n}\r\n*crop = try_crop;\r\nreturn 0;\r\n}\r\nvoid omap_vout_new_format(struct v4l2_pix_format *pix,\r\nstruct v4l2_framebuffer *fbuf, struct v4l2_rect *crop,\r\nstruct v4l2_window *win)\r\n{\r\nomap_vout_default_crop(pix, fbuf, crop);\r\nwin->w.width = crop->width;\r\nwin->w.height = crop->height;\r\nwin->w.left = ((fbuf->fmt.width - win->w.width) >> 1) & ~1;\r\nwin->w.top = ((fbuf->fmt.height - win->w.height) >> 1) & ~1;\r\n}\r\nunsigned long omap_vout_alloc_buffer(u32 buf_size, u32 *phys_addr)\r\n{\r\nu32 order, size;\r\nunsigned long virt_addr, addr;\r\nsize = PAGE_ALIGN(buf_size);\r\norder = get_order(size);\r\nvirt_addr = __get_free_pages(GFP_KERNEL, order);\r\naddr = virt_addr;\r\nif (virt_addr) {\r\nwhile (size > 0) {\r\nSetPageReserved(virt_to_page(addr));\r\naddr += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\n}\r\n*phys_addr = (u32) virt_to_phys((void *) virt_addr);\r\nreturn virt_addr;\r\n}\r\nvoid omap_vout_free_buffer(unsigned long virtaddr, u32 buf_size)\r\n{\r\nu32 order, size;\r\nunsigned long addr = virtaddr;\r\nsize = PAGE_ALIGN(buf_size);\r\norder = get_order(size);\r\nwhile (size > 0) {\r\nClearPageReserved(virt_to_page(addr));\r\naddr += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\nfree_pages((unsigned long) virtaddr, order);\r\n}
