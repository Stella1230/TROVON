static void mod_wired_entry(int entry, unsigned long entrylo0,\r\nunsigned long entrylo1, unsigned long entryhi,\r\nunsigned long pagemask)\r\n{\r\nunsigned long old_pagemask;\r\nunsigned long old_ctx;\r\nold_ctx = read_c0_entryhi() & 0xff;\r\nold_pagemask = read_c0_pagemask();\r\nwrite_c0_index(entry);\r\nwrite_c0_pagemask(pagemask);\r\nwrite_c0_entryhi(entryhi);\r\nwrite_c0_entrylo0(entrylo0);\r\nwrite_c0_entrylo1(entrylo1);\r\ntlb_write_indexed();\r\nwrite_c0_entryhi(old_ctx);\r\nwrite_c0_pagemask(old_pagemask);\r\n}\r\nstatic void alchemy_pci_wired_entry(struct alchemy_pci_context *ctx)\r\n{\r\nctx->wired_entry = read_c0_wired();\r\nadd_wired_entry(0, 0, (unsigned long)ctx->pci_cfg_vm->addr, PM_4K);\r\nctx->last_elo0 = ctx->last_elo1 = ~0;\r\n}\r\nstatic int config_access(unsigned char access_type, struct pci_bus *bus,\r\nunsigned int dev_fn, unsigned char where, u32 *data)\r\n{\r\nstruct alchemy_pci_context *ctx = bus->sysdata;\r\nunsigned int device = PCI_SLOT(dev_fn);\r\nunsigned int function = PCI_FUNC(dev_fn);\r\nunsigned long offset, status, cfg_base, flags, entryLo0, entryLo1, r;\r\nint error = PCIBIOS_SUCCESSFUL;\r\nif (device > 19) {\r\n*data = 0xffffffff;\r\nreturn -1;\r\n}\r\nlocal_irq_save(flags);\r\nr = __raw_readl(ctx->regs + PCI_REG_STATCMD) & 0x0000ffff;\r\nr |= PCI_STATCMD_STATUS(0x2000);\r\n__raw_writel(r, ctx->regs + PCI_REG_STATCMD);\r\nwmb();\r\nif (ctx->board_pci_idsel(device, 1) == 0) {\r\n*data = 0xffffffff;\r\nlocal_irq_restore(flags);\r\nreturn -1;\r\n}\r\nif (bus->number == 0)\r\ncfg_base = (1 << device) << 11;\r\nelse\r\ncfg_base = 0x80000000 | (bus->number << 16) | (device << 11);\r\noffset = (function << 8) | (where & ~0x3);\r\noffset |= cfg_base & ~PAGE_MASK;\r\ncfg_base = cfg_base & PAGE_MASK;\r\nentryLo0 = (6 << 26) | (cfg_base >> 6) | (2 << 3) | 7;\r\nentryLo1 = (6 << 26) | (cfg_base >> 6) | (0x1000 >> 6) | (2 << 3) | 7;\r\nif ((entryLo0 != ctx->last_elo0) || (entryLo1 != ctx->last_elo1)) {\r\nmod_wired_entry(ctx->wired_entry, entryLo0, entryLo1,\r\n(unsigned long)ctx->pci_cfg_vm->addr, PM_4K);\r\nctx->last_elo0 = entryLo0;\r\nctx->last_elo1 = entryLo1;\r\n}\r\nif (access_type == PCI_ACCESS_WRITE)\r\n__raw_writel(*data, ctx->pci_cfg_vm->addr + offset);\r\nelse\r\n*data = __raw_readl(ctx->pci_cfg_vm->addr + offset);\r\nwmb();\r\nDBG("alchemy-pci: cfg access %d bus %u dev %u at %x dat %x conf %lx\n",\r\naccess_type, bus->number, device, where, *data, offset);\r\nstatus = __raw_readl(ctx->regs + PCI_REG_STATCMD);\r\nif (status & (1 << 29)) {\r\n*data = 0xffffffff;\r\nerror = -1;\r\nDBG("alchemy-pci: master abort on cfg access %d bus %d dev %d",\r\naccess_type, bus->number, device);\r\n} else if ((status >> 28) & 0xf) {\r\nDBG("alchemy-pci: PCI ERR detected: dev %d, status %lx\n",\r\ndevice, (status >> 28) & 0xf);\r\n__raw_writel(status & 0xf000ffff, ctx->regs + PCI_REG_STATCMD);\r\n*data = 0xffffffff;\r\nerror = -1;\r\n}\r\n(void)ctx->board_pci_idsel(device, 0);\r\nlocal_irq_restore(flags);\r\nreturn error;\r\n}\r\nstatic int read_config_byte(struct pci_bus *bus, unsigned int devfn,\r\nint where, u8 *val)\r\n{\r\nu32 data;\r\nint ret = config_access(PCI_ACCESS_READ, bus, devfn, where, &data);\r\nif (where & 1)\r\ndata >>= 8;\r\nif (where & 2)\r\ndata >>= 16;\r\n*val = data & 0xff;\r\nreturn ret;\r\n}\r\nstatic int read_config_word(struct pci_bus *bus, unsigned int devfn,\r\nint where, u16 *val)\r\n{\r\nu32 data;\r\nint ret = config_access(PCI_ACCESS_READ, bus, devfn, where, &data);\r\nif (where & 2)\r\ndata >>= 16;\r\n*val = data & 0xffff;\r\nreturn ret;\r\n}\r\nstatic int read_config_dword(struct pci_bus *bus, unsigned int devfn,\r\nint where, u32 *val)\r\n{\r\nreturn config_access(PCI_ACCESS_READ, bus, devfn, where, val);\r\n}\r\nstatic int write_config_byte(struct pci_bus *bus, unsigned int devfn,\r\nint where, u8 val)\r\n{\r\nu32 data = 0;\r\nif (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))\r\nreturn -1;\r\ndata = (data & ~(0xff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nif (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))\r\nreturn -1;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int write_config_word(struct pci_bus *bus, unsigned int devfn,\r\nint where, u16 val)\r\n{\r\nu32 data = 0;\r\nif (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))\r\nreturn -1;\r\ndata = (data & ~(0xffff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nif (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))\r\nreturn -1;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int write_config_dword(struct pci_bus *bus, unsigned int devfn,\r\nint where, u32 val)\r\n{\r\nreturn config_access(PCI_ACCESS_WRITE, bus, devfn, where, &val);\r\n}\r\nstatic int alchemy_pci_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nswitch (size) {\r\ncase 1: {\r\nu8 _val;\r\nint rc = read_config_byte(bus, devfn, where, &_val);\r\n*val = _val;\r\nreturn rc;\r\n}\r\ncase 2: {\r\nu16 _val;\r\nint rc = read_config_word(bus, devfn, where, &_val);\r\n*val = _val;\r\nreturn rc;\r\n}\r\ndefault:\r\nreturn read_config_dword(bus, devfn, where, val);\r\n}\r\n}\r\nstatic int alchemy_pci_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nswitch (size) {\r\ncase 1:\r\nreturn write_config_byte(bus, devfn, where, (u8) val);\r\ncase 2:\r\nreturn write_config_word(bus, devfn, where, (u16) val);\r\ndefault:\r\nreturn write_config_dword(bus, devfn, where, val);\r\n}\r\n}\r\nstatic int alchemy_pci_def_idsel(unsigned int devsel, int assert)\r\n{\r\nreturn 1;\r\n}\r\nstatic int alchemy_pci_suspend(void)\r\n{\r\nstruct alchemy_pci_context *ctx = __alchemy_pci_ctx;\r\nif (!ctx)\r\nreturn 0;\r\nctx->pm[0] = __raw_readl(ctx->regs + PCI_REG_CMEM);\r\nctx->pm[1] = __raw_readl(ctx->regs + PCI_REG_CONFIG) & 0x0009ffff;\r\nctx->pm[2] = __raw_readl(ctx->regs + PCI_REG_B2BMASK_CCH);\r\nctx->pm[3] = __raw_readl(ctx->regs + PCI_REG_B2BBASE0_VID);\r\nctx->pm[4] = __raw_readl(ctx->regs + PCI_REG_B2BBASE1_SID);\r\nctx->pm[5] = __raw_readl(ctx->regs + PCI_REG_MWMASK_DEV);\r\nctx->pm[6] = __raw_readl(ctx->regs + PCI_REG_MWBASE_REV_CCL);\r\nctx->pm[7] = __raw_readl(ctx->regs + PCI_REG_ID);\r\nctx->pm[8] = __raw_readl(ctx->regs + PCI_REG_CLASSREV);\r\nctx->pm[9] = __raw_readl(ctx->regs + PCI_REG_PARAM);\r\nctx->pm[10] = __raw_readl(ctx->regs + PCI_REG_MBAR);\r\nctx->pm[11] = __raw_readl(ctx->regs + PCI_REG_TIMEOUT);\r\nreturn 0;\r\n}\r\nstatic void alchemy_pci_resume(void)\r\n{\r\nstruct alchemy_pci_context *ctx = __alchemy_pci_ctx;\r\nif (!ctx)\r\nreturn;\r\n__raw_writel(ctx->pm[0], ctx->regs + PCI_REG_CMEM);\r\n__raw_writel(ctx->pm[2], ctx->regs + PCI_REG_B2BMASK_CCH);\r\n__raw_writel(ctx->pm[3], ctx->regs + PCI_REG_B2BBASE0_VID);\r\n__raw_writel(ctx->pm[4], ctx->regs + PCI_REG_B2BBASE1_SID);\r\n__raw_writel(ctx->pm[5], ctx->regs + PCI_REG_MWMASK_DEV);\r\n__raw_writel(ctx->pm[6], ctx->regs + PCI_REG_MWBASE_REV_CCL);\r\n__raw_writel(ctx->pm[7], ctx->regs + PCI_REG_ID);\r\n__raw_writel(ctx->pm[8], ctx->regs + PCI_REG_CLASSREV);\r\n__raw_writel(ctx->pm[9], ctx->regs + PCI_REG_PARAM);\r\n__raw_writel(ctx->pm[10], ctx->regs + PCI_REG_MBAR);\r\n__raw_writel(ctx->pm[11], ctx->regs + PCI_REG_TIMEOUT);\r\nwmb();\r\n__raw_writel(ctx->pm[1], ctx->regs + PCI_REG_CONFIG);\r\nwmb();\r\nctx->wired_entry = 8191;\r\nalchemy_pci_wired_entry(ctx);\r\n}\r\nstatic int __devinit alchemy_pci_probe(struct platform_device *pdev)\r\n{\r\nstruct alchemy_pci_platdata *pd = pdev->dev.platform_data;\r\nstruct alchemy_pci_context *ctx;\r\nvoid __iomem *virt_io;\r\nunsigned long val;\r\nstruct resource *r;\r\nint ret;\r\nif (!pd) {\r\ndev_err(&pdev->dev, "need platform data for PCI setup\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\ndev_err(&pdev->dev, "no memory for pcictl context\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "no pcictl ctrl regs resource\n");\r\nret = -ENODEV;\r\ngoto out1;\r\n}\r\nif (!request_mem_region(r->start, resource_size(r), pdev->name)) {\r\ndev_err(&pdev->dev, "cannot claim pci regs\n");\r\nret = -ENODEV;\r\ngoto out1;\r\n}\r\nctx->regs = ioremap_nocache(r->start, resource_size(r));\r\nif (!ctx->regs) {\r\ndev_err(&pdev->dev, "cannot map pci regs\n");\r\nret = -ENODEV;\r\ngoto out2;\r\n}\r\nvirt_io = ioremap(AU1500_PCI_IO_PHYS_ADDR, 0x00100000);\r\nif (!virt_io) {\r\ndev_err(&pdev->dev, "cannot remap pci io space\n");\r\nret = -ENODEV;\r\ngoto out3;\r\n}\r\nctx->alchemy_pci_ctrl.io_map_base = (unsigned long)virt_io;\r\n#ifdef CONFIG_DMA_NONCOHERENT\r\nif ((alchemy_get_cputype() == ALCHEMY_CPU_AU1500) &&\r\n(read_c0_prid() < 0x01030202)) {\r\nval = __raw_readl(ctx->regs + PCI_REG_CONFIG);\r\nval |= PCI_CONFIG_NC;\r\n__raw_writel(val, ctx->regs + PCI_REG_CONFIG);\r\nwmb();\r\ndev_info(&pdev->dev, "non-coherent PCI on Au1500 AA/AB/AC\n");\r\n}\r\n#endif\r\nif (pd->board_map_irq)\r\nctx->board_map_irq = pd->board_map_irq;\r\nif (pd->board_pci_idsel)\r\nctx->board_pci_idsel = pd->board_pci_idsel;\r\nelse\r\nctx->board_pci_idsel = alchemy_pci_def_idsel;\r\nctx->alchemy_pci_ctrl.pci_ops = &alchemy_pci_ops;\r\nctx->alchemy_pci_ctrl.mem_resource = &alchemy_pci_def_memres;\r\nctx->alchemy_pci_ctrl.io_resource = &alchemy_pci_def_iores;\r\nctx->pci_cfg_vm = get_vm_area(0x2000, VM_IOREMAP);\r\nif (!ctx->pci_cfg_vm) {\r\ndev_err(&pdev->dev, "unable to get vm area\n");\r\nret = -ENOMEM;\r\ngoto out4;\r\n}\r\nctx->wired_entry = 8191;\r\nalchemy_pci_wired_entry(ctx);\r\nset_io_port_base((unsigned long)ctx->alchemy_pci_ctrl.io_map_base);\r\nval = __raw_readl(ctx->regs + PCI_REG_CONFIG);\r\nval &= ~pd->pci_cfg_clr;\r\nval |= pd->pci_cfg_set;\r\nval &= ~PCI_CONFIG_PD;\r\n__raw_writel(val, ctx->regs + PCI_REG_CONFIG);\r\nwmb();\r\n__alchemy_pci_ctx = ctx;\r\nplatform_set_drvdata(pdev, ctx);\r\nregister_syscore_ops(&alchemy_pci_pmops);\r\nregister_pci_controller(&ctx->alchemy_pci_ctrl);\r\nreturn 0;\r\nout4:\r\niounmap(virt_io);\r\nout3:\r\niounmap(ctx->regs);\r\nout2:\r\nrelease_mem_region(r->start, resource_size(r));\r\nout1:\r\nkfree(ctx);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init alchemy_pci_init(void)\r\n{\r\nswitch (alchemy_get_cputype()) {\r\ncase ALCHEMY_CPU_AU1500:\r\ncase ALCHEMY_CPU_AU1550:\r\nreturn platform_driver_register(&alchemy_pcictl_driver);\r\n}\r\nreturn 0;\r\n}\r\nint __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstruct alchemy_pci_context *ctx = dev->sysdata;\r\nif (ctx && ctx->board_map_irq)\r\nreturn ctx->board_map_irq(dev, slot, pin);\r\nreturn -1;\r\n}\r\nint pcibios_plat_dev_init(struct pci_dev *dev)\r\n{\r\nreturn 0;\r\n}
