static inline void etherh_set_ctrl(struct etherh_priv *eh, unsigned char mask)\r\n{\r\nunsigned char ctrl = eh->ctrl | mask;\r\neh->ctrl = ctrl;\r\nwriteb(ctrl, eh->ctrl_port);\r\n}\r\nstatic inline void etherh_clr_ctrl(struct etherh_priv *eh, unsigned char mask)\r\n{\r\nunsigned char ctrl = eh->ctrl & ~mask;\r\neh->ctrl = ctrl;\r\nwriteb(ctrl, eh->ctrl_port);\r\n}\r\nstatic inline unsigned int etherh_get_stat(struct etherh_priv *eh)\r\n{\r\nreturn readb(eh->ctrl_port);\r\n}\r\nstatic void etherh_irq_enable(ecard_t *ec, int irqnr)\r\n{\r\nstruct etherh_priv *eh = ec->irq_data;\r\netherh_set_ctrl(eh, ETHERH_CP_IE);\r\n}\r\nstatic void etherh_irq_disable(ecard_t *ec, int irqnr)\r\n{\r\nstruct etherh_priv *eh = ec->irq_data;\r\netherh_clr_ctrl(eh, ETHERH_CP_IE);\r\n}\r\nstatic void\r\netherh_setif(struct net_device *dev)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nunsigned long flags;\r\nvoid __iomem *addr;\r\nlocal_irq_save(flags);\r\nswitch (etherh_priv(dev)->id) {\r\ncase PROD_I3_ETHERLAN600:\r\ncase PROD_I3_ETHERLAN600A:\r\naddr = (void __iomem *)dev->base_addr + EN0_RCNTHI;\r\nswitch (dev->if_port) {\r\ncase IF_PORT_10BASE2:\r\nwriteb((readb(addr) & 0xf8) | 1, addr);\r\nbreak;\r\ncase IF_PORT_10BASET:\r\nwriteb((readb(addr) & 0xf8), addr);\r\nbreak;\r\n}\r\nbreak;\r\ncase PROD_I3_ETHERLAN500:\r\nswitch (dev->if_port) {\r\ncase IF_PORT_10BASE2:\r\netherh_clr_ctrl(etherh_priv(dev), ETHERH_CP_IF);\r\nbreak;\r\ncase IF_PORT_10BASET:\r\netherh_set_ctrl(etherh_priv(dev), ETHERH_CP_IF);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int\r\netherh_getifstat(struct net_device *dev)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nvoid __iomem *addr;\r\nint stat = 0;\r\nswitch (etherh_priv(dev)->id) {\r\ncase PROD_I3_ETHERLAN600:\r\ncase PROD_I3_ETHERLAN600A:\r\naddr = (void __iomem *)dev->base_addr + EN0_RCNTHI;\r\nswitch (dev->if_port) {\r\ncase IF_PORT_10BASE2:\r\nstat = 1;\r\nbreak;\r\ncase IF_PORT_10BASET:\r\nstat = readb(addr) & 4;\r\nbreak;\r\n}\r\nbreak;\r\ncase PROD_I3_ETHERLAN500:\r\nswitch (dev->if_port) {\r\ncase IF_PORT_10BASE2:\r\nstat = 1;\r\nbreak;\r\ncase IF_PORT_10BASET:\r\nstat = etherh_get_stat(etherh_priv(dev)) & ETHERH_CP_HEARTBEAT;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nstat = 0;\r\nbreak;\r\n}\r\nreturn stat != 0;\r\n}\r\nstatic int etherh_set_config(struct net_device *dev, struct ifmap *map)\r\n{\r\nswitch (map->port) {\r\ncase IF_PORT_10BASE2:\r\ncase IF_PORT_10BASET:\r\ndev->flags &= ~IFF_AUTOMEDIA;\r\ndev->if_port = map->port;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\netherh_setif(dev);\r\nreturn 0;\r\n}\r\nstatic void\r\netherh_reset(struct net_device *dev)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nvoid __iomem *addr = (void __iomem *)dev->base_addr;\r\nwriteb(E8390_NODMA+E8390_PAGE0+E8390_STOP, addr);\r\nif (dev->flags & IFF_AUTOMEDIA && ei_local->interface_num) {\r\nei_local->interface_num = 0;\r\nif (dev->if_port == IF_PORT_10BASET)\r\ndev->if_port = IF_PORT_10BASE2;\r\nelse\r\ndev->if_port = IF_PORT_10BASET;\r\netherh_setif(dev);\r\n}\r\n}\r\nstatic void\r\netherh_block_output (struct net_device *dev, int count, const unsigned char *buf, int start_page)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nunsigned long dma_start;\r\nvoid __iomem *dma_base, *addr;\r\nif (ei_local->dmaing) {\r\nprintk(KERN_ERR "%s: DMAing conflict in etherh_block_input: "\r\n" DMAstat %d irqlock %d\n", dev->name,\r\nei_local->dmaing, ei_local->irqlock);\r\nreturn;\r\n}\r\nif (count & 1 && ei_local->word16)\r\ncount++;\r\nei_local->dmaing = 1;\r\naddr = (void __iomem *)dev->base_addr;\r\ndma_base = etherh_priv(dev)->dma_base;\r\ncount = (count + 1) & ~1;\r\nwriteb (E8390_NODMA | E8390_PAGE0 | E8390_START, addr + E8390_CMD);\r\nwriteb (0x42, addr + EN0_RCNTLO);\r\nwriteb (0x00, addr + EN0_RCNTHI);\r\nwriteb (0x42, addr + EN0_RSARLO);\r\nwriteb (0x00, addr + EN0_RSARHI);\r\nwriteb (E8390_RREAD | E8390_START, addr + E8390_CMD);\r\nudelay (1);\r\nwriteb (ENISR_RDC, addr + EN0_ISR);\r\nwriteb (count, addr + EN0_RCNTLO);\r\nwriteb (count >> 8, addr + EN0_RCNTHI);\r\nwriteb (0, addr + EN0_RSARLO);\r\nwriteb (start_page, addr + EN0_RSARHI);\r\nwriteb (E8390_RWRITE | E8390_START, addr + E8390_CMD);\r\nif (ei_local->word16)\r\nwritesw (dma_base, buf, count >> 1);\r\nelse\r\nwritesb (dma_base, buf, count);\r\ndma_start = jiffies;\r\nwhile ((readb (addr + EN0_ISR) & ENISR_RDC) == 0)\r\nif (time_after(jiffies, dma_start + 2*HZ/100)) {\r\nprintk(KERN_ERR "%s: timeout waiting for TX RDC\n",\r\ndev->name);\r\netherh_reset (dev);\r\n__NS8390_init (dev, 1);\r\nbreak;\r\n}\r\nwriteb (ENISR_RDC, addr + EN0_ISR);\r\nei_local->dmaing = 0;\r\n}\r\nstatic void\r\netherh_block_input (struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nunsigned char *buf;\r\nvoid __iomem *dma_base, *addr;\r\nif (ei_local->dmaing) {\r\nprintk(KERN_ERR "%s: DMAing conflict in etherh_block_input: "\r\n" DMAstat %d irqlock %d\n", dev->name,\r\nei_local->dmaing, ei_local->irqlock);\r\nreturn;\r\n}\r\nei_local->dmaing = 1;\r\naddr = (void __iomem *)dev->base_addr;\r\ndma_base = etherh_priv(dev)->dma_base;\r\nbuf = skb->data;\r\nwriteb (E8390_NODMA | E8390_PAGE0 | E8390_START, addr + E8390_CMD);\r\nwriteb (count, addr + EN0_RCNTLO);\r\nwriteb (count >> 8, addr + EN0_RCNTHI);\r\nwriteb (ring_offset, addr + EN0_RSARLO);\r\nwriteb (ring_offset >> 8, addr + EN0_RSARHI);\r\nwriteb (E8390_RREAD | E8390_START, addr + E8390_CMD);\r\nif (ei_local->word16) {\r\nreadsw (dma_base, buf, count >> 1);\r\nif (count & 1)\r\nbuf[count - 1] = readb (dma_base);\r\n} else\r\nreadsb (dma_base, buf, count);\r\nwriteb (ENISR_RDC, addr + EN0_ISR);\r\nei_local->dmaing = 0;\r\n}\r\nstatic void\r\netherh_get_header (struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nvoid __iomem *dma_base, *addr;\r\nif (ei_local->dmaing) {\r\nprintk(KERN_ERR "%s: DMAing conflict in etherh_get_header: "\r\n" DMAstat %d irqlock %d\n", dev->name,\r\nei_local->dmaing, ei_local->irqlock);\r\nreturn;\r\n}\r\nei_local->dmaing = 1;\r\naddr = (void __iomem *)dev->base_addr;\r\ndma_base = etherh_priv(dev)->dma_base;\r\nwriteb (E8390_NODMA | E8390_PAGE0 | E8390_START, addr + E8390_CMD);\r\nwriteb (sizeof (*hdr), addr + EN0_RCNTLO);\r\nwriteb (0, addr + EN0_RCNTHI);\r\nwriteb (0, addr + EN0_RSARLO);\r\nwriteb (ring_page, addr + EN0_RSARHI);\r\nwriteb (E8390_RREAD | E8390_START, addr + E8390_CMD);\r\nif (ei_local->word16)\r\nreadsw (dma_base, hdr, sizeof (*hdr) >> 1);\r\nelse\r\nreadsb (dma_base, hdr, sizeof (*hdr));\r\nwriteb (ENISR_RDC, addr + EN0_ISR);\r\nei_local->dmaing = 0;\r\n}\r\nstatic int\r\netherh_open(struct net_device *dev)\r\n{\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nprintk(KERN_WARNING "%s: invalid ethernet MAC address\n",\r\ndev->name);\r\nreturn -EINVAL;\r\n}\r\nif (request_irq(dev->irq, __ei_interrupt, 0, dev->name, dev))\r\nreturn -EAGAIN;\r\nei_local->interface_num = 0;\r\nif (dev->flags & IFF_AUTOMEDIA) {\r\ndev->if_port = IF_PORT_10BASET;\r\netherh_setif(dev);\r\nmdelay(1);\r\nif (!etherh_getifstat(dev)) {\r\ndev->if_port = IF_PORT_10BASE2;\r\netherh_setif(dev);\r\n}\r\n} else\r\netherh_setif(dev);\r\netherh_reset(dev);\r\n__ei_open(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\netherh_close(struct net_device *dev)\r\n{\r\n__ei_close (dev);\r\nfree_irq (dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic void __init etherh_banner(void)\r\n{\r\nstatic int version_printed;\r\nif (net_debug && version_printed++ == 0)\r\nprintk(KERN_INFO "%s", version);\r\n}\r\nstatic int __devinit etherh_addr(char *addr, struct expansion_card *ec)\r\n{\r\nstruct in_chunk_dir cd;\r\nchar *s;\r\nif (!ecard_readchunk(&cd, ec, 0xf5, 0)) {\r\nprintk(KERN_ERR "%s: unable to read podule description string\n",\r\ndev_name(&ec->dev));\r\ngoto no_addr;\r\n}\r\ns = strchr(cd.d.string, '(');\r\nif (s) {\r\nint i;\r\nfor (i = 0; i < 6; i++) {\r\naddr[i] = simple_strtoul(s + 1, &s, 0x10);\r\nif (*s != (i == 5? ')' : ':'))\r\nbreak;\r\n}\r\nif (i == 6)\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "%s: unable to parse MAC address: %s\n",\r\ndev_name(&ec->dev), cd.d.string);\r\nno_addr:\r\nreturn -ENODEV;\r\n}\r\nstatic int __init etherm_addr(char *addr)\r\n{\r\nunsigned int serial;\r\nif (system_serial_low == 0 && system_serial_high == 0)\r\nreturn -ENODEV;\r\nserial = system_serial_low | system_serial_high;\r\naddr[0] = 0;\r\naddr[1] = 0;\r\naddr[2] = 0xa4;\r\naddr[3] = 0x10 + (serial >> 24);\r\naddr[4] = serial >> 16;\r\naddr[5] = serial >> 8;\r\nreturn 0;\r\n}\r\nstatic void etherh_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, dev_name(dev->dev.parent),\r\nsizeof(info->bus_info));\r\n}\r\nstatic int etherh_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\ncmd->supported = etherh_priv(dev)->supported;\r\nethtool_cmd_speed_set(cmd, SPEED_10);\r\ncmd->duplex = DUPLEX_HALF;\r\ncmd->port = dev->if_port == IF_PORT_10BASET ? PORT_TP : PORT_BNC;\r\ncmd->autoneg = (dev->flags & IFF_AUTOMEDIA ?\r\nAUTONEG_ENABLE : AUTONEG_DISABLE);\r\nreturn 0;\r\n}\r\nstatic int etherh_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nswitch (cmd->autoneg) {\r\ncase AUTONEG_ENABLE:\r\ndev->flags |= IFF_AUTOMEDIA;\r\nbreak;\r\ncase AUTONEG_DISABLE:\r\nswitch (cmd->port) {\r\ncase PORT_TP:\r\ndev->if_port = IF_PORT_10BASET;\r\nbreak;\r\ncase PORT_BNC:\r\ndev->if_port = IF_PORT_10BASE2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev->flags &= ~IFF_AUTOMEDIA;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\netherh_setif(dev);\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\netherh_probe(struct expansion_card *ec, const struct ecard_id *id)\r\n{\r\nconst struct etherh_data *data = id->data;\r\nstruct ei_device *ei_local;\r\nstruct net_device *dev;\r\nstruct etherh_priv *eh;\r\nint ret;\r\netherh_banner();\r\nret = ecard_request_resources(ec);\r\nif (ret)\r\ngoto out;\r\ndev = ____alloc_ei_netdev(sizeof(struct etherh_priv));\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\nSET_NETDEV_DEV(dev, &ec->dev);\r\ndev->netdev_ops = &etherh_netdev_ops;\r\ndev->irq = ec->irq;\r\ndev->ethtool_ops = &etherh_ethtool_ops;\r\nif (data->supported & SUPPORTED_Autoneg)\r\ndev->flags |= IFF_AUTOMEDIA;\r\nif (data->supported & SUPPORTED_TP) {\r\ndev->flags |= IFF_PORTSEL;\r\ndev->if_port = IF_PORT_10BASET;\r\n} else if (data->supported & SUPPORTED_BNC) {\r\ndev->flags |= IFF_PORTSEL;\r\ndev->if_port = IF_PORT_10BASE2;\r\n} else\r\ndev->if_port = IF_PORT_UNKNOWN;\r\neh = etherh_priv(dev);\r\neh->supported = data->supported;\r\neh->ctrl = 0;\r\neh->id = ec->cid.product;\r\neh->memc = ecardm_iomap(ec, ECARD_RES_MEMC, 0, PAGE_SIZE);\r\nif (!eh->memc) {\r\nret = -ENOMEM;\r\ngoto free;\r\n}\r\neh->ctrl_port = eh->memc;\r\nif (data->ctrl_ioc) {\r\neh->ioc_fast = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, PAGE_SIZE);\r\nif (!eh->ioc_fast) {\r\nret = -ENOMEM;\r\ngoto free;\r\n}\r\neh->ctrl_port = eh->ioc_fast;\r\n}\r\ndev->base_addr = (unsigned long)eh->memc + data->ns8390_offset;\r\neh->dma_base = eh->memc + data->dataport_offset;\r\neh->ctrl_port += data->ctrlport_offset;\r\nif (ec->slot_no != 8) {\r\necard_setirq(ec, &etherh_ops, eh);\r\n} else {\r\netherh_set_ctrl(eh, ETHERH_CP_IE);\r\n}\r\nei_local = netdev_priv(dev);\r\nspin_lock_init(&ei_local->page_lock);\r\nif (ec->cid.product == PROD_ANT_ETHERM) {\r\netherm_addr(dev->dev_addr);\r\nei_local->reg_offset = etherm_regoffsets;\r\n} else {\r\netherh_addr(dev->dev_addr, ec);\r\nei_local->reg_offset = etherh_regoffsets;\r\n}\r\nei_local->name = dev->name;\r\nei_local->word16 = 1;\r\nei_local->tx_start_page = data->tx_start_page;\r\nei_local->rx_start_page = ei_local->tx_start_page + TX_PAGES;\r\nei_local->stop_page = data->stop_page;\r\nei_local->reset_8390 = etherh_reset;\r\nei_local->block_input = etherh_block_input;\r\nei_local->block_output = etherh_block_output;\r\nei_local->get_8390_hdr = etherh_get_header;\r\nei_local->interface_num = 0;\r\netherh_reset(dev);\r\n__NS8390_init(dev, 0);\r\nret = register_netdev(dev);\r\nif (ret)\r\ngoto free;\r\nprintk(KERN_INFO "%s: %s in slot %d, %pM\n",\r\ndev->name, data->name, ec->slot_no, dev->dev_addr);\r\necard_set_drvdata(ec, dev);\r\nreturn 0;\r\nfree:\r\nfree_netdev(dev);\r\nrelease:\r\necard_release_resources(ec);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __devexit etherh_remove(struct expansion_card *ec)\r\n{\r\nstruct net_device *dev = ecard_get_drvdata(ec);\r\necard_set_drvdata(ec, NULL);\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\necard_release_resources(ec);\r\n}\r\nstatic int __init etherh_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++) {\r\netherh_regoffsets[i] = i << 2;\r\netherm_regoffsets[i] = i << 5;\r\n}\r\nreturn ecard_register_driver(&etherh_driver);\r\n}\r\nstatic void __exit etherh_exit(void)\r\n{\r\necard_remove_driver(&etherh_driver);\r\n}
