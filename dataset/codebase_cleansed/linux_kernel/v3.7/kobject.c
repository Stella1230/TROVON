static int populate_dir(struct kobject *kobj)\r\n{\r\nstruct kobj_type *t = get_ktype(kobj);\r\nstruct attribute *attr;\r\nint error = 0;\r\nint i;\r\nif (t && t->default_attrs) {\r\nfor (i = 0; (attr = t->default_attrs[i]) != NULL; i++) {\r\nerror = sysfs_create_file(kobj, attr);\r\nif (error)\r\nbreak;\r\n}\r\n}\r\nreturn error;\r\n}\r\nstatic int create_dir(struct kobject *kobj)\r\n{\r\nint error = 0;\r\nerror = sysfs_create_dir(kobj);\r\nif (!error) {\r\nerror = populate_dir(kobj);\r\nif (error)\r\nsysfs_remove_dir(kobj);\r\n}\r\nreturn error;\r\n}\r\nstatic int get_kobj_path_length(struct kobject *kobj)\r\n{\r\nint length = 1;\r\nstruct kobject *parent = kobj;\r\ndo {\r\nif (kobject_name(parent) == NULL)\r\nreturn 0;\r\nlength += strlen(kobject_name(parent)) + 1;\r\nparent = parent->parent;\r\n} while (parent);\r\nreturn length;\r\n}\r\nstatic void fill_kobj_path(struct kobject *kobj, char *path, int length)\r\n{\r\nstruct kobject *parent;\r\n--length;\r\nfor (parent = kobj; parent; parent = parent->parent) {\r\nint cur = strlen(kobject_name(parent));\r\nlength -= cur;\r\nstrncpy(path + length, kobject_name(parent), cur);\r\n*(path + --length) = '/';\r\n}\r\npr_debug("kobject: '%s' (%p): %s: path = '%s'\n", kobject_name(kobj),\r\nkobj, __func__, path);\r\n}\r\nchar *kobject_get_path(struct kobject *kobj, gfp_t gfp_mask)\r\n{\r\nchar *path;\r\nint len;\r\nlen = get_kobj_path_length(kobj);\r\nif (len == 0)\r\nreturn NULL;\r\npath = kzalloc(len, gfp_mask);\r\nif (!path)\r\nreturn NULL;\r\nfill_kobj_path(kobj, path, len);\r\nreturn path;\r\n}\r\nstatic void kobj_kset_join(struct kobject *kobj)\r\n{\r\nif (!kobj->kset)\r\nreturn;\r\nkset_get(kobj->kset);\r\nspin_lock(&kobj->kset->list_lock);\r\nlist_add_tail(&kobj->entry, &kobj->kset->list);\r\nspin_unlock(&kobj->kset->list_lock);\r\n}\r\nstatic void kobj_kset_leave(struct kobject *kobj)\r\n{\r\nif (!kobj->kset)\r\nreturn;\r\nspin_lock(&kobj->kset->list_lock);\r\nlist_del_init(&kobj->entry);\r\nspin_unlock(&kobj->kset->list_lock);\r\nkset_put(kobj->kset);\r\n}\r\nstatic void kobject_init_internal(struct kobject *kobj)\r\n{\r\nif (!kobj)\r\nreturn;\r\nkref_init(&kobj->kref);\r\nINIT_LIST_HEAD(&kobj->entry);\r\nkobj->state_in_sysfs = 0;\r\nkobj->state_add_uevent_sent = 0;\r\nkobj->state_remove_uevent_sent = 0;\r\nkobj->state_initialized = 1;\r\n}\r\nstatic int kobject_add_internal(struct kobject *kobj)\r\n{\r\nint error = 0;\r\nstruct kobject *parent;\r\nif (!kobj)\r\nreturn -ENOENT;\r\nif (!kobj->name || !kobj->name[0]) {\r\nWARN(1, "kobject: (%p): attempted to be registered with empty "\r\n"name!\n", kobj);\r\nreturn -EINVAL;\r\n}\r\nparent = kobject_get(kobj->parent);\r\nif (kobj->kset) {\r\nif (!parent)\r\nparent = kobject_get(&kobj->kset->kobj);\r\nkobj_kset_join(kobj);\r\nkobj->parent = parent;\r\n}\r\npr_debug("kobject: '%s' (%p): %s: parent: '%s', set: '%s'\n",\r\nkobject_name(kobj), kobj, __func__,\r\nparent ? kobject_name(parent) : "<NULL>",\r\nkobj->kset ? kobject_name(&kobj->kset->kobj) : "<NULL>");\r\nerror = create_dir(kobj);\r\nif (error) {\r\nkobj_kset_leave(kobj);\r\nkobject_put(parent);\r\nkobj->parent = NULL;\r\nif (error == -EEXIST)\r\nWARN(1, "%s failed for %s with "\r\n"-EEXIST, don't try to register things with "\r\n"the same name in the same directory.\n",\r\n__func__, kobject_name(kobj));\r\nelse\r\nWARN(1, "%s failed for %s (error: %d parent: %s)\n",\r\n__func__, kobject_name(kobj), error,\r\nparent ? kobject_name(parent) : "'none'");\r\n} else\r\nkobj->state_in_sysfs = 1;\r\nreturn error;\r\n}\r\nint kobject_set_name_vargs(struct kobject *kobj, const char *fmt,\r\nva_list vargs)\r\n{\r\nconst char *old_name = kobj->name;\r\nchar *s;\r\nif (kobj->name && !fmt)\r\nreturn 0;\r\nkobj->name = kvasprintf(GFP_KERNEL, fmt, vargs);\r\nif (!kobj->name)\r\nreturn -ENOMEM;\r\nwhile ((s = strchr(kobj->name, '/')))\r\ns[0] = '!';\r\nkfree(old_name);\r\nreturn 0;\r\n}\r\nint kobject_set_name(struct kobject *kobj, const char *fmt, ...)\r\n{\r\nva_list vargs;\r\nint retval;\r\nva_start(vargs, fmt);\r\nretval = kobject_set_name_vargs(kobj, fmt, vargs);\r\nva_end(vargs);\r\nreturn retval;\r\n}\r\nvoid kobject_init(struct kobject *kobj, struct kobj_type *ktype)\r\n{\r\nchar *err_str;\r\nif (!kobj) {\r\nerr_str = "invalid kobject pointer!";\r\ngoto error;\r\n}\r\nif (!ktype) {\r\nerr_str = "must have a ktype to be initialized properly!\n";\r\ngoto error;\r\n}\r\nif (kobj->state_initialized) {\r\nprintk(KERN_ERR "kobject (%p): tried to init an initialized "\r\n"object, something is seriously wrong.\n", kobj);\r\ndump_stack();\r\n}\r\nkobject_init_internal(kobj);\r\nkobj->ktype = ktype;\r\nreturn;\r\nerror:\r\nprintk(KERN_ERR "kobject (%p): %s\n", kobj, err_str);\r\ndump_stack();\r\n}\r\nstatic int kobject_add_varg(struct kobject *kobj, struct kobject *parent,\r\nconst char *fmt, va_list vargs)\r\n{\r\nint retval;\r\nretval = kobject_set_name_vargs(kobj, fmt, vargs);\r\nif (retval) {\r\nprintk(KERN_ERR "kobject: can not set name properly!\n");\r\nreturn retval;\r\n}\r\nkobj->parent = parent;\r\nreturn kobject_add_internal(kobj);\r\n}\r\nint kobject_add(struct kobject *kobj, struct kobject *parent,\r\nconst char *fmt, ...)\r\n{\r\nva_list args;\r\nint retval;\r\nif (!kobj)\r\nreturn -EINVAL;\r\nif (!kobj->state_initialized) {\r\nprintk(KERN_ERR "kobject '%s' (%p): tried to add an "\r\n"uninitialized object, something is seriously wrong.\n",\r\nkobject_name(kobj), kobj);\r\ndump_stack();\r\nreturn -EINVAL;\r\n}\r\nva_start(args, fmt);\r\nretval = kobject_add_varg(kobj, parent, fmt, args);\r\nva_end(args);\r\nreturn retval;\r\n}\r\nint kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,\r\nstruct kobject *parent, const char *fmt, ...)\r\n{\r\nva_list args;\r\nint retval;\r\nkobject_init(kobj, ktype);\r\nva_start(args, fmt);\r\nretval = kobject_add_varg(kobj, parent, fmt, args);\r\nva_end(args);\r\nreturn retval;\r\n}\r\nint kobject_rename(struct kobject *kobj, const char *new_name)\r\n{\r\nint error = 0;\r\nconst char *devpath = NULL;\r\nconst char *dup_name = NULL, *name;\r\nchar *devpath_string = NULL;\r\nchar *envp[2];\r\nkobj = kobject_get(kobj);\r\nif (!kobj)\r\nreturn -EINVAL;\r\nif (!kobj->parent)\r\nreturn -EINVAL;\r\ndevpath = kobject_get_path(kobj, GFP_KERNEL);\r\nif (!devpath) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\ndevpath_string = kmalloc(strlen(devpath) + 15, GFP_KERNEL);\r\nif (!devpath_string) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nsprintf(devpath_string, "DEVPATH_OLD=%s", devpath);\r\nenvp[0] = devpath_string;\r\nenvp[1] = NULL;\r\nname = dup_name = kstrdup(new_name, GFP_KERNEL);\r\nif (!name) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nerror = sysfs_rename_dir(kobj, new_name);\r\nif (error)\r\ngoto out;\r\ndup_name = kobj->name;\r\nkobj->name = name;\r\nkobject_uevent_env(kobj, KOBJ_MOVE, envp);\r\nout:\r\nkfree(dup_name);\r\nkfree(devpath_string);\r\nkfree(devpath);\r\nkobject_put(kobj);\r\nreturn error;\r\n}\r\nint kobject_move(struct kobject *kobj, struct kobject *new_parent)\r\n{\r\nint error;\r\nstruct kobject *old_parent;\r\nconst char *devpath = NULL;\r\nchar *devpath_string = NULL;\r\nchar *envp[2];\r\nkobj = kobject_get(kobj);\r\nif (!kobj)\r\nreturn -EINVAL;\r\nnew_parent = kobject_get(new_parent);\r\nif (!new_parent) {\r\nif (kobj->kset)\r\nnew_parent = kobject_get(&kobj->kset->kobj);\r\n}\r\ndevpath = kobject_get_path(kobj, GFP_KERNEL);\r\nif (!devpath) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\ndevpath_string = kmalloc(strlen(devpath) + 15, GFP_KERNEL);\r\nif (!devpath_string) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nsprintf(devpath_string, "DEVPATH_OLD=%s", devpath);\r\nenvp[0] = devpath_string;\r\nenvp[1] = NULL;\r\nerror = sysfs_move_dir(kobj, new_parent);\r\nif (error)\r\ngoto out;\r\nold_parent = kobj->parent;\r\nkobj->parent = new_parent;\r\nnew_parent = NULL;\r\nkobject_put(old_parent);\r\nkobject_uevent_env(kobj, KOBJ_MOVE, envp);\r\nout:\r\nkobject_put(new_parent);\r\nkobject_put(kobj);\r\nkfree(devpath_string);\r\nkfree(devpath);\r\nreturn error;\r\n}\r\nvoid kobject_del(struct kobject *kobj)\r\n{\r\nif (!kobj)\r\nreturn;\r\nsysfs_remove_dir(kobj);\r\nkobj->state_in_sysfs = 0;\r\nkobj_kset_leave(kobj);\r\nkobject_put(kobj->parent);\r\nkobj->parent = NULL;\r\n}\r\nstruct kobject *kobject_get(struct kobject *kobj)\r\n{\r\nif (kobj)\r\nkref_get(&kobj->kref);\r\nreturn kobj;\r\n}\r\nstatic void kobject_cleanup(struct kobject *kobj)\r\n{\r\nstruct kobj_type *t = get_ktype(kobj);\r\nconst char *name = kobj->name;\r\npr_debug("kobject: '%s' (%p): %s\n",\r\nkobject_name(kobj), kobj, __func__);\r\nif (t && !t->release)\r\npr_debug("kobject: '%s' (%p): does not have a release() "\r\n"function, it is broken and must be fixed.\n",\r\nkobject_name(kobj), kobj);\r\nif (kobj->state_add_uevent_sent && !kobj->state_remove_uevent_sent) {\r\npr_debug("kobject: '%s' (%p): auto cleanup 'remove' event\n",\r\nkobject_name(kobj), kobj);\r\nkobject_uevent(kobj, KOBJ_REMOVE);\r\n}\r\nif (kobj->state_in_sysfs) {\r\npr_debug("kobject: '%s' (%p): auto cleanup kobject_del\n",\r\nkobject_name(kobj), kobj);\r\nkobject_del(kobj);\r\n}\r\nif (t && t->release) {\r\npr_debug("kobject: '%s' (%p): calling ktype release\n",\r\nkobject_name(kobj), kobj);\r\nt->release(kobj);\r\n}\r\nif (name) {\r\npr_debug("kobject: '%s': free name\n", name);\r\nkfree(name);\r\n}\r\n}\r\nstatic void kobject_release(struct kref *kref)\r\n{\r\nkobject_cleanup(container_of(kref, struct kobject, kref));\r\n}\r\nvoid kobject_put(struct kobject *kobj)\r\n{\r\nif (kobj) {\r\nif (!kobj->state_initialized)\r\nWARN(1, KERN_WARNING "kobject: '%s' (%p): is not "\r\n"initialized, yet kobject_put() is being "\r\n"called.\n", kobject_name(kobj), kobj);\r\nkref_put(&kobj->kref, kobject_release);\r\n}\r\n}\r\nstatic void dynamic_kobj_release(struct kobject *kobj)\r\n{\r\npr_debug("kobject: (%p): %s\n", kobj, __func__);\r\nkfree(kobj);\r\n}\r\nstruct kobject *kobject_create(void)\r\n{\r\nstruct kobject *kobj;\r\nkobj = kzalloc(sizeof(*kobj), GFP_KERNEL);\r\nif (!kobj)\r\nreturn NULL;\r\nkobject_init(kobj, &dynamic_kobj_ktype);\r\nreturn kobj;\r\n}\r\nstruct kobject *kobject_create_and_add(const char *name, struct kobject *parent)\r\n{\r\nstruct kobject *kobj;\r\nint retval;\r\nkobj = kobject_create();\r\nif (!kobj)\r\nreturn NULL;\r\nretval = kobject_add(kobj, parent, "%s", name);\r\nif (retval) {\r\nprintk(KERN_WARNING "%s: kobject_add error: %d\n",\r\n__func__, retval);\r\nkobject_put(kobj);\r\nkobj = NULL;\r\n}\r\nreturn kobj;\r\n}\r\nvoid kset_init(struct kset *k)\r\n{\r\nkobject_init_internal(&k->kobj);\r\nINIT_LIST_HEAD(&k->list);\r\nspin_lock_init(&k->list_lock);\r\n}\r\nstatic ssize_t kobj_attr_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct kobj_attribute *kattr;\r\nssize_t ret = -EIO;\r\nkattr = container_of(attr, struct kobj_attribute, attr);\r\nif (kattr->show)\r\nret = kattr->show(kobj, kattr, buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t kobj_attr_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct kobj_attribute *kattr;\r\nssize_t ret = -EIO;\r\nkattr = container_of(attr, struct kobj_attribute, attr);\r\nif (kattr->store)\r\nret = kattr->store(kobj, kattr, buf, count);\r\nreturn ret;\r\n}\r\nint kset_register(struct kset *k)\r\n{\r\nint err;\r\nif (!k)\r\nreturn -EINVAL;\r\nkset_init(k);\r\nerr = kobject_add_internal(&k->kobj);\r\nif (err)\r\nreturn err;\r\nkobject_uevent(&k->kobj, KOBJ_ADD);\r\nreturn 0;\r\n}\r\nvoid kset_unregister(struct kset *k)\r\n{\r\nif (!k)\r\nreturn;\r\nkobject_put(&k->kobj);\r\n}\r\nstruct kobject *kset_find_obj(struct kset *kset, const char *name)\r\n{\r\nstruct kobject *k;\r\nstruct kobject *ret = NULL;\r\nspin_lock(&kset->list_lock);\r\nlist_for_each_entry(k, &kset->list, entry) {\r\nif (kobject_name(k) && !strcmp(kobject_name(k), name)) {\r\nret = kobject_get(k);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&kset->list_lock);\r\nreturn ret;\r\n}\r\nstatic void kset_release(struct kobject *kobj)\r\n{\r\nstruct kset *kset = container_of(kobj, struct kset, kobj);\r\npr_debug("kobject: '%s' (%p): %s\n",\r\nkobject_name(kobj), kobj, __func__);\r\nkfree(kset);\r\n}\r\nstatic struct kset *kset_create(const char *name,\r\nconst struct kset_uevent_ops *uevent_ops,\r\nstruct kobject *parent_kobj)\r\n{\r\nstruct kset *kset;\r\nint retval;\r\nkset = kzalloc(sizeof(*kset), GFP_KERNEL);\r\nif (!kset)\r\nreturn NULL;\r\nretval = kobject_set_name(&kset->kobj, name);\r\nif (retval) {\r\nkfree(kset);\r\nreturn NULL;\r\n}\r\nkset->uevent_ops = uevent_ops;\r\nkset->kobj.parent = parent_kobj;\r\nkset->kobj.ktype = &kset_ktype;\r\nkset->kobj.kset = NULL;\r\nreturn kset;\r\n}\r\nstruct kset *kset_create_and_add(const char *name,\r\nconst struct kset_uevent_ops *uevent_ops,\r\nstruct kobject *parent_kobj)\r\n{\r\nstruct kset *kset;\r\nint error;\r\nkset = kset_create(name, uevent_ops, parent_kobj);\r\nif (!kset)\r\nreturn NULL;\r\nerror = kset_register(kset);\r\nif (error) {\r\nkfree(kset);\r\nreturn NULL;\r\n}\r\nreturn kset;\r\n}\r\nint kobj_ns_type_register(const struct kobj_ns_type_operations *ops)\r\n{\r\nenum kobj_ns_type type = ops->type;\r\nint error;\r\nspin_lock(&kobj_ns_type_lock);\r\nerror = -EINVAL;\r\nif (type >= KOBJ_NS_TYPES)\r\ngoto out;\r\nerror = -EINVAL;\r\nif (type <= KOBJ_NS_TYPE_NONE)\r\ngoto out;\r\nerror = -EBUSY;\r\nif (kobj_ns_ops_tbl[type])\r\ngoto out;\r\nerror = 0;\r\nkobj_ns_ops_tbl[type] = ops;\r\nout:\r\nspin_unlock(&kobj_ns_type_lock);\r\nreturn error;\r\n}\r\nint kobj_ns_type_registered(enum kobj_ns_type type)\r\n{\r\nint registered = 0;\r\nspin_lock(&kobj_ns_type_lock);\r\nif ((type > KOBJ_NS_TYPE_NONE) && (type < KOBJ_NS_TYPES))\r\nregistered = kobj_ns_ops_tbl[type] != NULL;\r\nspin_unlock(&kobj_ns_type_lock);\r\nreturn registered;\r\n}\r\nconst struct kobj_ns_type_operations *kobj_child_ns_ops(struct kobject *parent)\r\n{\r\nconst struct kobj_ns_type_operations *ops = NULL;\r\nif (parent && parent->ktype->child_ns_type)\r\nops = parent->ktype->child_ns_type(parent);\r\nreturn ops;\r\n}\r\nconst struct kobj_ns_type_operations *kobj_ns_ops(struct kobject *kobj)\r\n{\r\nreturn kobj_child_ns_ops(kobj->parent);\r\n}\r\nvoid *kobj_ns_grab_current(enum kobj_ns_type type)\r\n{\r\nvoid *ns = NULL;\r\nspin_lock(&kobj_ns_type_lock);\r\nif ((type > KOBJ_NS_TYPE_NONE) && (type < KOBJ_NS_TYPES) &&\r\nkobj_ns_ops_tbl[type])\r\nns = kobj_ns_ops_tbl[type]->grab_current_ns();\r\nspin_unlock(&kobj_ns_type_lock);\r\nreturn ns;\r\n}\r\nconst void *kobj_ns_netlink(enum kobj_ns_type type, struct sock *sk)\r\n{\r\nconst void *ns = NULL;\r\nspin_lock(&kobj_ns_type_lock);\r\nif ((type > KOBJ_NS_TYPE_NONE) && (type < KOBJ_NS_TYPES) &&\r\nkobj_ns_ops_tbl[type])\r\nns = kobj_ns_ops_tbl[type]->netlink_ns(sk);\r\nspin_unlock(&kobj_ns_type_lock);\r\nreturn ns;\r\n}\r\nconst void *kobj_ns_initial(enum kobj_ns_type type)\r\n{\r\nconst void *ns = NULL;\r\nspin_lock(&kobj_ns_type_lock);\r\nif ((type > KOBJ_NS_TYPE_NONE) && (type < KOBJ_NS_TYPES) &&\r\nkobj_ns_ops_tbl[type])\r\nns = kobj_ns_ops_tbl[type]->initial_ns();\r\nspin_unlock(&kobj_ns_type_lock);\r\nreturn ns;\r\n}\r\nvoid kobj_ns_drop(enum kobj_ns_type type, void *ns)\r\n{\r\nspin_lock(&kobj_ns_type_lock);\r\nif ((type > KOBJ_NS_TYPE_NONE) && (type < KOBJ_NS_TYPES) &&\r\nkobj_ns_ops_tbl[type] && kobj_ns_ops_tbl[type]->drop_ns)\r\nkobj_ns_ops_tbl[type]->drop_ns(ns);\r\nspin_unlock(&kobj_ns_type_lock);\r\n}
