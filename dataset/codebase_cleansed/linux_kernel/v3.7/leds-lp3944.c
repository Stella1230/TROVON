static int lp3944_reg_read(struct i2c_client *client, u8 reg, u8 *value)\r\n{\r\nint tmp;\r\ntmp = i2c_smbus_read_byte_data(client, reg);\r\nif (tmp < 0)\r\nreturn -EINVAL;\r\n*value = tmp;\r\nreturn 0;\r\n}\r\nstatic int lp3944_reg_write(struct i2c_client *client, u8 reg, u8 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic int lp3944_dim_set_period(struct i2c_client *client, u8 dim, u16 period)\r\n{\r\nu8 psc_reg;\r\nu8 psc_value;\r\nint err;\r\nif (dim == LP3944_DIM0)\r\npsc_reg = LP3944_REG_PSC0;\r\nelse if (dim == LP3944_DIM1)\r\npsc_reg = LP3944_REG_PSC1;\r\nelse\r\nreturn -EINVAL;\r\nif (period > LP3944_PERIOD_MAX)\r\nreturn -EINVAL;\r\npsc_value = (period * 255) / LP3944_PERIOD_MAX;\r\nerr = lp3944_reg_write(client, psc_reg, psc_value);\r\nreturn err;\r\n}\r\nstatic int lp3944_dim_set_dutycycle(struct i2c_client *client, u8 dim,\r\nu8 duty_cycle)\r\n{\r\nu8 pwm_reg;\r\nu8 pwm_value;\r\nint err;\r\nif (dim == LP3944_DIM0)\r\npwm_reg = LP3944_REG_PWM0;\r\nelse if (dim == LP3944_DIM1)\r\npwm_reg = LP3944_REG_PWM1;\r\nelse\r\nreturn -EINVAL;\r\nif (duty_cycle > LP3944_DUTY_CYCLE_MAX)\r\nreturn -EINVAL;\r\npwm_value = (duty_cycle * 255) / LP3944_DUTY_CYCLE_MAX;\r\nerr = lp3944_reg_write(client, pwm_reg, pwm_value);\r\nreturn err;\r\n}\r\nstatic int lp3944_led_set(struct lp3944_led_data *led, u8 status)\r\n{\r\nstruct lp3944_data *data = i2c_get_clientdata(led->client);\r\nu8 id = led->id;\r\nu8 reg;\r\nu8 val = 0;\r\nint err;\r\ndev_dbg(&led->client->dev, "%s: %s, status before normalization:%d\n",\r\n__func__, led->ldev.name, status);\r\nswitch (id) {\r\ncase LP3944_LED0:\r\ncase LP3944_LED1:\r\ncase LP3944_LED2:\r\ncase LP3944_LED3:\r\nreg = LP3944_REG_LS0;\r\nbreak;\r\ncase LP3944_LED4:\r\ncase LP3944_LED5:\r\ncase LP3944_LED6:\r\ncase LP3944_LED7:\r\nid -= LP3944_LED4;\r\nreg = LP3944_REG_LS1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (status > LP3944_LED_STATUS_DIM1)\r\nreturn -EINVAL;\r\nif (led->type == LP3944_LED_TYPE_LED_INVERTED && status < 2)\r\nstatus = 1 - status;\r\nmutex_lock(&data->lock);\r\nlp3944_reg_read(led->client, reg, &val);\r\nval &= ~(LP3944_LED_STATUS_MASK << (id << 1));\r\nval |= (status << (id << 1));\r\ndev_dbg(&led->client->dev, "%s: %s, reg:%d id:%d status:%d val:%#x\n",\r\n__func__, led->ldev.name, reg, id, status, val);\r\nerr = lp3944_reg_write(led->client, reg, val);\r\nmutex_unlock(&data->lock);\r\nreturn err;\r\n}\r\nstatic int lp3944_led_set_blink(struct led_classdev *led_cdev,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct lp3944_led_data *led = ldev_to_led(led_cdev);\r\nu16 period;\r\nu8 duty_cycle;\r\nint err;\r\nif (*delay_on + *delay_off > LP3944_PERIOD_MAX)\r\nreturn -EINVAL;\r\nif (*delay_on == 0 && *delay_off == 0) {\r\n*delay_on = 500;\r\n*delay_off = 500;\r\n}\r\nperiod = (*delay_on) + (*delay_off);\r\nduty_cycle = 100 * (*delay_on) / period;\r\nif (led->type == LP3944_LED_TYPE_LED_INVERTED)\r\nduty_cycle = 100 - duty_cycle;\r\nerr = lp3944_dim_set_period(led->client, LP3944_DIM0, period);\r\nif (err)\r\nreturn err;\r\nerr = lp3944_dim_set_dutycycle(led->client, LP3944_DIM0, duty_cycle);\r\nif (err)\r\nreturn err;\r\ndev_dbg(&led->client->dev, "%s: OK hardware accelerated blink!\n",\r\n__func__);\r\nled->status = LP3944_LED_STATUS_DIM0;\r\nschedule_work(&led->work);\r\nreturn 0;\r\n}\r\nstatic void lp3944_led_set_brightness(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct lp3944_led_data *led = ldev_to_led(led_cdev);\r\ndev_dbg(&led->client->dev, "%s: %s, %d\n",\r\n__func__, led_cdev->name, brightness);\r\nled->status = brightness;\r\nschedule_work(&led->work);\r\n}\r\nstatic void lp3944_led_work(struct work_struct *work)\r\n{\r\nstruct lp3944_led_data *led;\r\nled = container_of(work, struct lp3944_led_data, work);\r\nlp3944_led_set(led, led->status);\r\n}\r\nstatic int lp3944_configure(struct i2c_client *client,\r\nstruct lp3944_data *data,\r\nstruct lp3944_platform_data *pdata)\r\n{\r\nint i, err = 0;\r\nfor (i = 0; i < pdata->leds_size; i++) {\r\nstruct lp3944_led *pled = &pdata->leds[i];\r\nstruct lp3944_led_data *led = &data->leds[i];\r\nled->client = client;\r\nled->id = i;\r\nswitch (pled->type) {\r\ncase LP3944_LED_TYPE_LED:\r\ncase LP3944_LED_TYPE_LED_INVERTED:\r\nled->type = pled->type;\r\nled->status = pled->status;\r\nled->ldev.name = pled->name;\r\nled->ldev.max_brightness = 1;\r\nled->ldev.brightness_set = lp3944_led_set_brightness;\r\nled->ldev.blink_set = lp3944_led_set_blink;\r\nled->ldev.flags = LED_CORE_SUSPENDRESUME;\r\nINIT_WORK(&led->work, lp3944_led_work);\r\nerr = led_classdev_register(&client->dev, &led->ldev);\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"couldn't register LED %s\n",\r\nled->ldev.name);\r\ngoto exit;\r\n}\r\nled->ldev.brightness = led->status;\r\nerr = lp3944_led_set(led, led->status);\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"%s couldn't set STATUS %d\n",\r\nled->ldev.name, led->status);\r\ngoto exit;\r\n}\r\nbreak;\r\ncase LP3944_LED_TYPE_NONE:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\nexit:\r\nif (i > 0)\r\nfor (i = i - 1; i >= 0; i--)\r\nswitch (pdata->leds[i].type) {\r\ncase LP3944_LED_TYPE_LED:\r\ncase LP3944_LED_TYPE_LED_INVERTED:\r\nled_classdev_unregister(&data->leds[i].ldev);\r\ncancel_work_sync(&data->leds[i].work);\r\nbreak;\r\ncase LP3944_LED_TYPE_NONE:\r\ndefault:\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int __devinit lp3944_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lp3944_platform_data *lp3944_pdata = client->dev.platform_data;\r\nstruct lp3944_data *data;\r\nint err;\r\nif (lp3944_pdata == NULL) {\r\ndev_err(&client->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&client->dev, "insufficient functionality!\n");\r\nreturn -ENODEV;\r\n}\r\ndata = devm_kzalloc(&client->dev, sizeof(struct lp3944_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->client = client;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->lock);\r\nerr = lp3944_configure(client, data, lp3944_pdata);\r\nif (err < 0)\r\nreturn err;\r\ndev_info(&client->dev, "lp3944 enabled\n");\r\nreturn 0;\r\n}\r\nstatic int __devexit lp3944_remove(struct i2c_client *client)\r\n{\r\nstruct lp3944_platform_data *pdata = client->dev.platform_data;\r\nstruct lp3944_data *data = i2c_get_clientdata(client);\r\nint i;\r\nfor (i = 0; i < pdata->leds_size; i++)\r\nswitch (data->leds[i].type) {\r\ncase LP3944_LED_TYPE_LED:\r\ncase LP3944_LED_TYPE_LED_INVERTED:\r\nled_classdev_unregister(&data->leds[i].ldev);\r\ncancel_work_sync(&data->leds[i].work);\r\nbreak;\r\ncase LP3944_LED_TYPE_NONE:\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}
