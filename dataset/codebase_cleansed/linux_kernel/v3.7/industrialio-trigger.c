static ssize_t iio_trigger_read_name(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_trigger *trig = to_iio_trigger(dev);\r\nreturn sprintf(buf, "%s\n", trig->name);\r\n}\r\nint iio_trigger_register(struct iio_trigger *trig_info)\r\n{\r\nint ret;\r\ntrig_info->id = ida_simple_get(&iio_trigger_ida, 0, 0, GFP_KERNEL);\r\nif (trig_info->id < 0) {\r\nret = trig_info->id;\r\ngoto error_ret;\r\n}\r\ndev_set_name(&trig_info->dev, "trigger%ld",\r\n(unsigned long) trig_info->id);\r\nret = device_add(&trig_info->dev);\r\nif (ret)\r\ngoto error_unregister_id;\r\nmutex_lock(&iio_trigger_list_lock);\r\nlist_add_tail(&trig_info->list, &iio_trigger_list);\r\nmutex_unlock(&iio_trigger_list_lock);\r\nreturn 0;\r\nerror_unregister_id:\r\nida_simple_remove(&iio_trigger_ida, trig_info->id);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nvoid iio_trigger_unregister(struct iio_trigger *trig_info)\r\n{\r\nmutex_lock(&iio_trigger_list_lock);\r\nlist_del(&trig_info->list);\r\nmutex_unlock(&iio_trigger_list_lock);\r\nida_simple_remove(&iio_trigger_ida, trig_info->id);\r\ndevice_unregister(&trig_info->dev);\r\n}\r\nstatic struct iio_trigger *iio_trigger_find_by_name(const char *name,\r\nsize_t len)\r\n{\r\nstruct iio_trigger *trig = NULL, *iter;\r\nmutex_lock(&iio_trigger_list_lock);\r\nlist_for_each_entry(iter, &iio_trigger_list, list)\r\nif (sysfs_streq(iter->name, name)) {\r\ntrig = iter;\r\nbreak;\r\n}\r\nmutex_unlock(&iio_trigger_list_lock);\r\nreturn trig;\r\n}\r\nvoid iio_trigger_poll(struct iio_trigger *trig, s64 time)\r\n{\r\nint i;\r\nif (!trig->use_count)\r\nfor (i = 0; i < CONFIG_IIO_CONSUMERS_PER_TRIGGER; i++)\r\nif (trig->subirqs[i].enabled) {\r\ntrig->use_count++;\r\ngeneric_handle_irq(trig->subirq_base + i);\r\n}\r\n}\r\nirqreturn_t iio_trigger_generic_data_rdy_poll(int irq, void *private)\r\n{\r\niio_trigger_poll(private, iio_get_time_ns());\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid iio_trigger_poll_chained(struct iio_trigger *trig, s64 time)\r\n{\r\nint i;\r\nif (!trig->use_count)\r\nfor (i = 0; i < CONFIG_IIO_CONSUMERS_PER_TRIGGER; i++)\r\nif (trig->subirqs[i].enabled) {\r\ntrig->use_count++;\r\nhandle_nested_irq(trig->subirq_base + i);\r\n}\r\n}\r\nvoid iio_trigger_notify_done(struct iio_trigger *trig)\r\n{\r\ntrig->use_count--;\r\nif (trig->use_count == 0 && trig->ops && trig->ops->try_reenable)\r\nif (trig->ops->try_reenable(trig))\r\niio_trigger_poll(trig, 0);\r\n}\r\nstatic int iio_trigger_get_irq(struct iio_trigger *trig)\r\n{\r\nint ret;\r\nmutex_lock(&trig->pool_lock);\r\nret = bitmap_find_free_region(trig->pool,\r\nCONFIG_IIO_CONSUMERS_PER_TRIGGER,\r\nilog2(1));\r\nmutex_unlock(&trig->pool_lock);\r\nif (ret >= 0)\r\nret += trig->subirq_base;\r\nreturn ret;\r\n}\r\nstatic void iio_trigger_put_irq(struct iio_trigger *trig, int irq)\r\n{\r\nmutex_lock(&trig->pool_lock);\r\nclear_bit(irq - trig->subirq_base, trig->pool);\r\nmutex_unlock(&trig->pool_lock);\r\n}\r\nstatic int iio_trigger_attach_poll_func(struct iio_trigger *trig,\r\nstruct iio_poll_func *pf)\r\n{\r\nint ret = 0;\r\nbool notinuse\r\n= bitmap_empty(trig->pool, CONFIG_IIO_CONSUMERS_PER_TRIGGER);\r\n__module_get(pf->indio_dev->info->driver_module);\r\npf->irq = iio_trigger_get_irq(trig);\r\nret = request_threaded_irq(pf->irq, pf->h, pf->thread,\r\npf->type, pf->name,\r\npf);\r\nif (ret < 0) {\r\nmodule_put(pf->indio_dev->info->driver_module);\r\nreturn ret;\r\n}\r\nif (trig->ops && trig->ops->set_trigger_state && notinuse) {\r\nret = trig->ops->set_trigger_state(trig, true);\r\nif (ret < 0)\r\nmodule_put(pf->indio_dev->info->driver_module);\r\n}\r\nreturn ret;\r\n}\r\nstatic int iio_trigger_detach_poll_func(struct iio_trigger *trig,\r\nstruct iio_poll_func *pf)\r\n{\r\nint ret = 0;\r\nbool no_other_users\r\n= (bitmap_weight(trig->pool,\r\nCONFIG_IIO_CONSUMERS_PER_TRIGGER)\r\n== 1);\r\nif (trig->ops && trig->ops->set_trigger_state && no_other_users) {\r\nret = trig->ops->set_trigger_state(trig, false);\r\nif (ret)\r\ngoto error_ret;\r\n}\r\niio_trigger_put_irq(trig, pf->irq);\r\nfree_irq(pf->irq, pf);\r\nmodule_put(pf->indio_dev->info->driver_module);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nirqreturn_t iio_pollfunc_store_time(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\npf->timestamp = iio_get_time_ns();\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstruct iio_poll_func\r\n*iio_alloc_pollfunc(irqreturn_t (*h)(int irq, void *p),\r\nirqreturn_t (*thread)(int irq, void *p),\r\nint type,\r\nstruct iio_dev *indio_dev,\r\nconst char *fmt,\r\n...)\r\n{\r\nva_list vargs;\r\nstruct iio_poll_func *pf;\r\npf = kmalloc(sizeof *pf, GFP_KERNEL);\r\nif (pf == NULL)\r\nreturn NULL;\r\nva_start(vargs, fmt);\r\npf->name = kvasprintf(GFP_KERNEL, fmt, vargs);\r\nva_end(vargs);\r\nif (pf->name == NULL) {\r\nkfree(pf);\r\nreturn NULL;\r\n}\r\npf->h = h;\r\npf->thread = thread;\r\npf->type = type;\r\npf->indio_dev = indio_dev;\r\nreturn pf;\r\n}\r\nvoid iio_dealloc_pollfunc(struct iio_poll_func *pf)\r\n{\r\nkfree(pf->name);\r\nkfree(pf);\r\n}\r\nstatic ssize_t iio_trigger_read_current(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nif (indio_dev->trig)\r\nreturn sprintf(buf, "%s\n", indio_dev->trig->name);\r\nreturn 0;\r\n}\r\nstatic ssize_t iio_trigger_write_current(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_trigger *oldtrig = indio_dev->trig;\r\nstruct iio_trigger *trig;\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nif (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn -EBUSY;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\ntrig = iio_trigger_find_by_name(buf, len);\r\nif (oldtrig == trig)\r\nreturn len;\r\nif (trig && indio_dev->info->validate_trigger) {\r\nret = indio_dev->info->validate_trigger(indio_dev, trig);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (trig && trig->ops && trig->ops->validate_device) {\r\nret = trig->ops->validate_device(trig, indio_dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nindio_dev->trig = trig;\r\nif (oldtrig && indio_dev->trig != oldtrig)\r\niio_trigger_put(oldtrig);\r\nif (indio_dev->trig)\r\niio_trigger_get(indio_dev->trig);\r\nreturn len;\r\n}\r\nstatic void iio_trig_release(struct device *device)\r\n{\r\nstruct iio_trigger *trig = to_iio_trigger(device);\r\nint i;\r\nif (trig->subirq_base) {\r\nfor (i = 0; i < CONFIG_IIO_CONSUMERS_PER_TRIGGER; i++) {\r\nirq_modify_status(trig->subirq_base + i,\r\nIRQ_NOAUTOEN,\r\nIRQ_NOREQUEST | IRQ_NOPROBE);\r\nirq_set_chip(trig->subirq_base + i,\r\nNULL);\r\nirq_set_handler(trig->subirq_base + i,\r\nNULL);\r\n}\r\nirq_free_descs(trig->subirq_base,\r\nCONFIG_IIO_CONSUMERS_PER_TRIGGER);\r\n}\r\nkfree(trig->name);\r\nkfree(trig);\r\n}\r\nstatic void iio_trig_subirqmask(struct irq_data *d)\r\n{\r\nstruct irq_chip *chip = irq_data_get_irq_chip(d);\r\nstruct iio_trigger *trig\r\n= container_of(chip,\r\nstruct iio_trigger, subirq_chip);\r\ntrig->subirqs[d->irq - trig->subirq_base].enabled = false;\r\n}\r\nstatic void iio_trig_subirqunmask(struct irq_data *d)\r\n{\r\nstruct irq_chip *chip = irq_data_get_irq_chip(d);\r\nstruct iio_trigger *trig\r\n= container_of(chip,\r\nstruct iio_trigger, subirq_chip);\r\ntrig->subirqs[d->irq - trig->subirq_base].enabled = true;\r\n}\r\nstruct iio_trigger *iio_trigger_alloc(const char *fmt, ...)\r\n{\r\nva_list vargs;\r\nstruct iio_trigger *trig;\r\ntrig = kzalloc(sizeof *trig, GFP_KERNEL);\r\nif (trig) {\r\nint i;\r\ntrig->dev.type = &iio_trig_type;\r\ntrig->dev.bus = &iio_bus_type;\r\ndevice_initialize(&trig->dev);\r\nmutex_init(&trig->pool_lock);\r\ntrig->subirq_base\r\n= irq_alloc_descs(-1, 0,\r\nCONFIG_IIO_CONSUMERS_PER_TRIGGER,\r\n0);\r\nif (trig->subirq_base < 0) {\r\nkfree(trig);\r\nreturn NULL;\r\n}\r\nva_start(vargs, fmt);\r\ntrig->name = kvasprintf(GFP_KERNEL, fmt, vargs);\r\nva_end(vargs);\r\nif (trig->name == NULL) {\r\nirq_free_descs(trig->subirq_base,\r\nCONFIG_IIO_CONSUMERS_PER_TRIGGER);\r\nkfree(trig);\r\nreturn NULL;\r\n}\r\ntrig->subirq_chip.name = trig->name;\r\ntrig->subirq_chip.irq_mask = &iio_trig_subirqmask;\r\ntrig->subirq_chip.irq_unmask = &iio_trig_subirqunmask;\r\nfor (i = 0; i < CONFIG_IIO_CONSUMERS_PER_TRIGGER; i++) {\r\nirq_set_chip(trig->subirq_base + i,\r\n&trig->subirq_chip);\r\nirq_set_handler(trig->subirq_base + i,\r\n&handle_simple_irq);\r\nirq_modify_status(trig->subirq_base + i,\r\nIRQ_NOREQUEST | IRQ_NOAUTOEN,\r\nIRQ_NOPROBE);\r\n}\r\nget_device(&trig->dev);\r\n}\r\nreturn trig;\r\n}\r\nvoid iio_trigger_free(struct iio_trigger *trig)\r\n{\r\nif (trig)\r\nput_device(&trig->dev);\r\n}\r\nvoid iio_device_register_trigger_consumer(struct iio_dev *indio_dev)\r\n{\r\nindio_dev->groups[indio_dev->groupcounter++] =\r\n&iio_trigger_consumer_attr_group;\r\n}\r\nvoid iio_device_unregister_trigger_consumer(struct iio_dev *indio_dev)\r\n{\r\nif (indio_dev->trig)\r\niio_trigger_put(indio_dev->trig);\r\n}\r\nint iio_triggered_buffer_postenable(struct iio_dev *indio_dev)\r\n{\r\nreturn iio_trigger_attach_poll_func(indio_dev->trig,\r\nindio_dev->pollfunc);\r\n}\r\nint iio_triggered_buffer_predisable(struct iio_dev *indio_dev)\r\n{\r\nreturn iio_trigger_detach_poll_func(indio_dev->trig,\r\nindio_dev->pollfunc);\r\n}
