static inline int ssm2602_get_coeff(int mclk, int rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ssm2602_coeff_table); i++) {\r\nif (ssm2602_coeff_table[i].rate == rate &&\r\nssm2602_coeff_table[i].mclk == mclk)\r\nreturn ssm2602_coeff_table[i].srate;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ssm2602_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nint srate = ssm2602_get_coeff(ssm2602->sysclk, params_rate(params));\r\nunsigned int iface;\r\nif (substream == ssm2602->slave_substream) {\r\ndev_dbg(codec->dev, "Ignoring hw_params for slave substream\n");\r\nreturn 0;\r\n}\r\nif (srate < 0)\r\nreturn srate;\r\nregmap_write(ssm2602->regmap, SSM2602_SRATE, srate);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\niface = 0x0;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\niface = 0x4;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\niface = 0x8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\niface = 0xc;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(ssm2602->regmap, SSM2602_IFACE,\r\nIFACE_AUDIO_DATA_LEN, iface);\r\nreturn 0;\r\n}\r\nstatic int ssm2602_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_pcm_runtime *master_runtime;\r\nif (ssm2602->master_substream) {\r\nmaster_runtime = ssm2602->master_substream->runtime;\r\ndev_dbg(codec->dev, "Constraining to %d bits at %dHz\n",\r\nmaster_runtime->sample_bits,\r\nmaster_runtime->rate);\r\nif (master_runtime->rate != 0)\r\nsnd_pcm_hw_constraint_minmax(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nmaster_runtime->rate,\r\nmaster_runtime->rate);\r\nif (master_runtime->sample_bits != 0)\r\nsnd_pcm_hw_constraint_minmax(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_SAMPLE_BITS,\r\nmaster_runtime->sample_bits,\r\nmaster_runtime->sample_bits);\r\nssm2602->slave_substream = substream;\r\n} else\r\nssm2602->master_substream = substream;\r\nif (ssm2602->sysclk_constraints) {\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nssm2602->sysclk_constraints);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ssm2602_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nif (ssm2602->master_substream == substream)\r\nssm2602->master_substream = ssm2602->slave_substream;\r\nssm2602->slave_substream = NULL;\r\n}\r\nstatic int ssm2602_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(dai->codec);\r\nif (mute)\r\nregmap_update_bits(ssm2602->regmap, SSM2602_APDIGI,\r\nAPDIGI_ENABLE_DAC_MUTE,\r\nAPDIGI_ENABLE_DAC_MUTE);\r\nelse\r\nregmap_update_bits(ssm2602->regmap, SSM2602_APDIGI,\r\nAPDIGI_ENABLE_DAC_MUTE, 0);\r\nreturn 0;\r\n}\r\nstatic int ssm2602_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nif (dir == SND_SOC_CLOCK_IN) {\r\nif (clk_id != SSM2602_SYSCLK)\r\nreturn -EINVAL;\r\nswitch (freq) {\r\ncase 12288000:\r\ncase 18432000:\r\nssm2602->sysclk_constraints = &ssm2602_constraints_12288000;\r\nbreak;\r\ncase 11289600:\r\ncase 16934400:\r\nssm2602->sysclk_constraints = &ssm2602_constraints_11289600;\r\nbreak;\r\ncase 12000000:\r\nssm2602->sysclk_constraints = NULL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nssm2602->sysclk = freq;\r\n} else {\r\nunsigned int mask;\r\nswitch (clk_id) {\r\ncase SSM2602_CLK_CLKOUT:\r\nmask = PWR_CLK_OUT_PDN;\r\nbreak;\r\ncase SSM2602_CLK_XTO:\r\nmask = PWR_OSC_PDN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (freq == 0)\r\nssm2602->clk_out_pwr |= mask;\r\nelse\r\nssm2602->clk_out_pwr &= ~mask;\r\nregmap_update_bits(ssm2602->regmap, SSM2602_PWR,\r\nPWR_CLK_OUT_PDN | PWR_OSC_PDN, ssm2602->clk_out_pwr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ssm2602_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec_dai->codec);\r\nunsigned int iface = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\niface |= 0x0040;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= 0x0002;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface |= 0x0001;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface |= 0x0013;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\niface |= 0x0003;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\niface |= 0x0090;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\niface |= 0x0080;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\niface |= 0x0010;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_write(ssm2602->regmap, SSM2602_IFACE, iface);\r\nreturn 0;\r\n}\r\nstatic int ssm2602_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nregmap_update_bits(ssm2602->regmap, SSM2602_PWR,\r\nPWR_POWER_OFF | PWR_CLK_OUT_PDN | PWR_OSC_PDN,\r\nssm2602->clk_out_pwr);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nregmap_update_bits(ssm2602->regmap, SSM2602_PWR,\r\nPWR_POWER_OFF | PWR_CLK_OUT_PDN | PWR_OSC_PDN,\r\nPWR_CLK_OUT_PDN | PWR_OSC_PDN);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregmap_update_bits(ssm2602->regmap, SSM2602_PWR,\r\nPWR_POWER_OFF, PWR_POWER_OFF);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int ssm2602_suspend(struct snd_soc_codec *codec)\r\n{\r\nssm2602_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int ssm2602_resume(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_cache_sync(codec);\r\nssm2602_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int ssm2602_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nint ret;\r\nregmap_update_bits(ssm2602->regmap, SSM2602_LOUT1V,\r\nLOUT1V_LRHP_BOTH, LOUT1V_LRHP_BOTH);\r\nregmap_update_bits(ssm2602->regmap, SSM2602_ROUT1V,\r\nROUT1V_RLHP_BOTH, ROUT1V_RLHP_BOTH);\r\nret = snd_soc_add_codec_controls(codec, ssm2602_snd_controls,\r\nARRAY_SIZE(ssm2602_snd_controls));\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_dapm_new_controls(dapm, ssm2602_dapm_widgets,\r\nARRAY_SIZE(ssm2602_dapm_widgets));\r\nif (ret)\r\nreturn ret;\r\nreturn snd_soc_dapm_add_routes(dapm, ssm2602_routes,\r\nARRAY_SIZE(ssm2602_routes));\r\n}\r\nstatic int ssm2604_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nint ret;\r\nret = snd_soc_dapm_new_controls(dapm, ssm2604_dapm_widgets,\r\nARRAY_SIZE(ssm2604_dapm_widgets));\r\nif (ret)\r\nreturn ret;\r\nreturn snd_soc_dapm_add_routes(dapm, ssm2604_routes,\r\nARRAY_SIZE(ssm2604_routes));\r\n}\r\nstatic int ssm260x_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct ssm2602_priv *ssm2602 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ncodec->control_data = ssm2602->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 0, 0, SND_SOC_REGMAP);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(ssm2602->regmap, SSM2602_RESET, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset: %d\n", ret);\r\nreturn ret;\r\n}\r\nregmap_update_bits(ssm2602->regmap, SSM2602_LINVOL,\r\nLINVOL_LRIN_BOTH, LINVOL_LRIN_BOTH);\r\nregmap_update_bits(ssm2602->regmap, SSM2602_RINVOL,\r\nRINVOL_RLIN_BOTH, RINVOL_RLIN_BOTH);\r\nregmap_write(ssm2602->regmap, SSM2602_APANA, APANA_SELECT_DAC |\r\nAPANA_ENABLE_MIC_BOOST);\r\nswitch (ssm2602->type) {\r\ncase SSM2602:\r\nret = ssm2602_probe(codec);\r\nbreak;\r\ncase SSM2604:\r\nret = ssm2604_probe(codec);\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\nssm2602_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int ssm2602_remove(struct snd_soc_codec *codec)\r\n{\r\nssm2602_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic bool ssm2602_register_volatile(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg == SSM2602_RESET;\r\n}\r\nstatic int __devinit ssm2602_spi_probe(struct spi_device *spi)\r\n{\r\nstruct ssm2602_priv *ssm2602;\r\nint ret;\r\nssm2602 = devm_kzalloc(&spi->dev, sizeof(struct ssm2602_priv),\r\nGFP_KERNEL);\r\nif (ssm2602 == NULL)\r\nreturn -ENOMEM;\r\nspi_set_drvdata(spi, ssm2602);\r\nssm2602->type = SSM2602;\r\nssm2602->regmap = devm_regmap_init_spi(spi, &ssm2602_regmap_config);\r\nif (IS_ERR(ssm2602->regmap))\r\nreturn PTR_ERR(ssm2602->regmap);\r\nret = snd_soc_register_codec(&spi->dev,\r\n&soc_codec_dev_ssm2602, &ssm2602_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int __devexit ssm2602_spi_remove(struct spi_device *spi)\r\n{\r\nsnd_soc_unregister_codec(&spi->dev);\r\nreturn 0;\r\n}\r\nstatic int __devinit ssm2602_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ssm2602_priv *ssm2602;\r\nint ret;\r\nssm2602 = devm_kzalloc(&i2c->dev, sizeof(struct ssm2602_priv),\r\nGFP_KERNEL);\r\nif (ssm2602 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, ssm2602);\r\nssm2602->type = id->driver_data;\r\nssm2602->regmap = devm_regmap_init_i2c(i2c, &ssm2602_regmap_config);\r\nif (IS_ERR(ssm2602->regmap))\r\nreturn PTR_ERR(ssm2602->regmap);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_ssm2602, &ssm2602_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int __devexit ssm2602_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int __init ssm2602_modinit(void)\r\n{\r\nint ret = 0;\r\n#if defined(CONFIG_SPI_MASTER)\r\nret = spi_register_driver(&ssm2602_spi_driver);\r\nif (ret)\r\nreturn ret;\r\n#endif\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&ssm2602_i2c_driver);\r\nif (ret)\r\nreturn ret;\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit ssm2602_exit(void)\r\n{\r\n#if defined(CONFIG_SPI_MASTER)\r\nspi_unregister_driver(&ssm2602_spi_driver);\r\n#endif\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&ssm2602_i2c_driver);\r\n#endif\r\n}
