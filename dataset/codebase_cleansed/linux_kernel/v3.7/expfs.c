static int exportfs_get_name(struct vfsmount *mnt, struct dentry *dir,\r\nchar *name, struct dentry *child)\r\n{\r\nconst struct export_operations *nop = dir->d_sb->s_export_op;\r\nstruct path path = {.mnt = mnt, .dentry = dir};\r\nif (nop->get_name)\r\nreturn nop->get_name(dir, name, child);\r\nelse\r\nreturn get_name(&path, name, child);\r\n}\r\nstatic struct dentry *\r\nfind_acceptable_alias(struct dentry *result,\r\nint (*acceptable)(void *context, struct dentry *dentry),\r\nvoid *context)\r\n{\r\nstruct dentry *dentry, *toput = NULL;\r\nstruct inode *inode;\r\nstruct hlist_node *p;\r\nif (acceptable(context, result))\r\nreturn result;\r\ninode = result->d_inode;\r\nspin_lock(&inode->i_lock);\r\nhlist_for_each_entry(dentry, p, &inode->i_dentry, d_alias) {\r\ndget(dentry);\r\nspin_unlock(&inode->i_lock);\r\nif (toput)\r\ndput(toput);\r\nif (dentry != result && acceptable(context, dentry)) {\r\ndput(result);\r\nreturn dentry;\r\n}\r\nspin_lock(&inode->i_lock);\r\ntoput = dentry;\r\n}\r\nspin_unlock(&inode->i_lock);\r\nif (toput)\r\ndput(toput);\r\nreturn NULL;\r\n}\r\nstatic struct dentry *\r\nfind_disconnected_root(struct dentry *dentry)\r\n{\r\ndget(dentry);\r\nwhile (!IS_ROOT(dentry)) {\r\nstruct dentry *parent = dget_parent(dentry);\r\nif (!(parent->d_flags & DCACHE_DISCONNECTED)) {\r\ndput(parent);\r\nbreak;\r\n}\r\ndput(dentry);\r\ndentry = parent;\r\n}\r\nreturn dentry;\r\n}\r\nstatic int\r\nreconnect_path(struct vfsmount *mnt, struct dentry *target_dir, char *nbuf)\r\n{\r\nint noprogress = 0;\r\nint err = -ESTALE;\r\nwhile (target_dir->d_flags & DCACHE_DISCONNECTED && noprogress++ < 10) {\r\nstruct dentry *pd = find_disconnected_root(target_dir);\r\nif (!IS_ROOT(pd)) {\r\nspin_lock(&pd->d_lock);\r\npd->d_flags &= ~DCACHE_DISCONNECTED;\r\nspin_unlock(&pd->d_lock);\r\nnoprogress = 0;\r\n} else if (pd == mnt->mnt_sb->s_root) {\r\nprintk(KERN_ERR "export: Eeek filesystem root is not connected, impossible\n");\r\nspin_lock(&pd->d_lock);\r\npd->d_flags &= ~DCACHE_DISCONNECTED;\r\nspin_unlock(&pd->d_lock);\r\nnoprogress = 0;\r\n} else {\r\nstruct dentry *ppd = ERR_PTR(-EACCES);\r\nstruct dentry *npd;\r\nmutex_lock(&pd->d_inode->i_mutex);\r\nif (mnt->mnt_sb->s_export_op->get_parent)\r\nppd = mnt->mnt_sb->s_export_op->get_parent(pd);\r\nmutex_unlock(&pd->d_inode->i_mutex);\r\nif (IS_ERR(ppd)) {\r\nerr = PTR_ERR(ppd);\r\ndprintk("%s: get_parent of %ld failed, err %d\n",\r\n__func__, pd->d_inode->i_ino, err);\r\ndput(pd);\r\nbreak;\r\n}\r\ndprintk("%s: find name of %lu in %lu\n", __func__,\r\npd->d_inode->i_ino, ppd->d_inode->i_ino);\r\nerr = exportfs_get_name(mnt, ppd, nbuf, pd);\r\nif (err) {\r\ndput(ppd);\r\ndput(pd);\r\nif (err == -ENOENT)\r\ncontinue;\r\nbreak;\r\n}\r\ndprintk("%s: found name: %s\n", __func__, nbuf);\r\nmutex_lock(&ppd->d_inode->i_mutex);\r\nnpd = lookup_one_len(nbuf, ppd, strlen(nbuf));\r\nmutex_unlock(&ppd->d_inode->i_mutex);\r\nif (IS_ERR(npd)) {\r\nerr = PTR_ERR(npd);\r\ndprintk("%s: lookup failed: %d\n",\r\n__func__, err);\r\ndput(ppd);\r\ndput(pd);\r\nbreak;\r\n}\r\nif (npd == pd)\r\nnoprogress = 0;\r\nelse\r\nprintk("%s: npd != pd\n", __func__);\r\ndput(npd);\r\ndput(ppd);\r\nif (IS_ROOT(pd)) {\r\ndput(pd);\r\nbreak;\r\n}\r\n}\r\ndput(pd);\r\n}\r\nif (target_dir->d_flags & DCACHE_DISCONNECTED) {\r\nif (!err)\r\nerr = -ESTALE;\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int filldir_one(void * __buf, const char * name, int len,\r\nloff_t pos, u64 ino, unsigned int d_type)\r\n{\r\nstruct getdents_callback *buf = __buf;\r\nint result = 0;\r\nbuf->sequence++;\r\nif (buf->ino == ino) {\r\nmemcpy(buf->name, name, len);\r\nbuf->name[len] = '\0';\r\nbuf->found = 1;\r\nresult = -1;\r\n}\r\nreturn result;\r\n}\r\nstatic int get_name(const struct path *path, char *name, struct dentry *child)\r\n{\r\nconst struct cred *cred = current_cred();\r\nstruct inode *dir = path->dentry->d_inode;\r\nint error;\r\nstruct file *file;\r\nstruct getdents_callback buffer;\r\nerror = -ENOTDIR;\r\nif (!dir || !S_ISDIR(dir->i_mode))\r\ngoto out;\r\nerror = -EINVAL;\r\nif (!dir->i_fop)\r\ngoto out;\r\nfile = dentry_open(path, O_RDONLY, cred);\r\nerror = PTR_ERR(file);\r\nif (IS_ERR(file))\r\ngoto out;\r\nerror = -EINVAL;\r\nif (!file->f_op->readdir)\r\ngoto out_close;\r\nbuffer.name = name;\r\nbuffer.ino = child->d_inode->i_ino;\r\nbuffer.found = 0;\r\nbuffer.sequence = 0;\r\nwhile (1) {\r\nint old_seq = buffer.sequence;\r\nerror = vfs_readdir(file, filldir_one, &buffer);\r\nif (buffer.found) {\r\nerror = 0;\r\nbreak;\r\n}\r\nif (error < 0)\r\nbreak;\r\nerror = -ENOENT;\r\nif (old_seq == buffer.sequence)\r\nbreak;\r\n}\r\nout_close:\r\nfput(file);\r\nout:\r\nreturn error;\r\n}\r\nstatic int export_encode_fh(struct inode *inode, struct fid *fid,\r\nint *max_len, struct inode *parent)\r\n{\r\nint len = *max_len;\r\nint type = FILEID_INO32_GEN;\r\nif (parent && (len < 4)) {\r\n*max_len = 4;\r\nreturn 255;\r\n} else if (len < 2) {\r\n*max_len = 2;\r\nreturn 255;\r\n}\r\nlen = 2;\r\nfid->i32.ino = inode->i_ino;\r\nfid->i32.gen = inode->i_generation;\r\nif (parent) {\r\nfid->i32.parent_ino = parent->i_ino;\r\nfid->i32.parent_gen = parent->i_generation;\r\nlen = 4;\r\ntype = FILEID_INO32_GEN_PARENT;\r\n}\r\n*max_len = len;\r\nreturn type;\r\n}\r\nint exportfs_encode_fh(struct dentry *dentry, struct fid *fid, int *max_len,\r\nint connectable)\r\n{\r\nconst struct export_operations *nop = dentry->d_sb->s_export_op;\r\nint error;\r\nstruct dentry *p = NULL;\r\nstruct inode *inode = dentry->d_inode, *parent = NULL;\r\nif (connectable && !S_ISDIR(inode->i_mode)) {\r\np = dget_parent(dentry);\r\nparent = p->d_inode;\r\n}\r\nif (nop->encode_fh)\r\nerror = nop->encode_fh(inode, fid->raw, max_len, parent);\r\nelse\r\nerror = export_encode_fh(inode, fid, max_len, parent);\r\ndput(p);\r\nreturn error;\r\n}\r\nstruct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,\r\nint fh_len, int fileid_type,\r\nint (*acceptable)(void *, struct dentry *), void *context)\r\n{\r\nconst struct export_operations *nop = mnt->mnt_sb->s_export_op;\r\nstruct dentry *result, *alias;\r\nchar nbuf[NAME_MAX+1];\r\nint err;\r\nif (!nop || !nop->fh_to_dentry)\r\nreturn ERR_PTR(-ESTALE);\r\nresult = nop->fh_to_dentry(mnt->mnt_sb, fid, fh_len, fileid_type);\r\nif (!result)\r\nresult = ERR_PTR(-ESTALE);\r\nif (IS_ERR(result))\r\nreturn result;\r\nif (S_ISDIR(result->d_inode->i_mode)) {\r\nif (result->d_flags & DCACHE_DISCONNECTED) {\r\nerr = reconnect_path(mnt, result, nbuf);\r\nif (err)\r\ngoto err_result;\r\n}\r\nif (!acceptable(context, result)) {\r\nerr = -EACCES;\r\ngoto err_result;\r\n}\r\nreturn result;\r\n} else {\r\nstruct dentry *target_dir, *nresult;\r\nalias = find_acceptable_alias(result, acceptable, context);\r\nif (alias)\r\nreturn alias;\r\nerr = -ESTALE;\r\nif (!nop->fh_to_parent)\r\ngoto err_result;\r\ntarget_dir = nop->fh_to_parent(mnt->mnt_sb, fid,\r\nfh_len, fileid_type);\r\nif (!target_dir)\r\ngoto err_result;\r\nerr = PTR_ERR(target_dir);\r\nif (IS_ERR(target_dir))\r\ngoto err_result;\r\nerr = reconnect_path(mnt, target_dir, nbuf);\r\nif (err) {\r\ndput(target_dir);\r\ngoto err_result;\r\n}\r\nerr = exportfs_get_name(mnt, target_dir, nbuf, result);\r\nif (!err) {\r\nmutex_lock(&target_dir->d_inode->i_mutex);\r\nnresult = lookup_one_len(nbuf, target_dir,\r\nstrlen(nbuf));\r\nmutex_unlock(&target_dir->d_inode->i_mutex);\r\nif (!IS_ERR(nresult)) {\r\nif (nresult->d_inode) {\r\ndput(result);\r\nresult = nresult;\r\n} else\r\ndput(nresult);\r\n}\r\n}\r\ndput(target_dir);\r\nalias = find_acceptable_alias(result, acceptable, context);\r\nif (!alias) {\r\nerr = -EACCES;\r\ngoto err_result;\r\n}\r\nreturn alias;\r\n}\r\nerr_result:\r\ndput(result);\r\nreturn ERR_PTR(err);\r\n}
