static int queue_interrupt_event(struct slot *p_slot, u32 event_type)\r\n{\r\nstruct event_info *info;\r\ninfo = kmalloc(sizeof(*info), GFP_ATOMIC);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->event_type = event_type;\r\ninfo->p_slot = p_slot;\r\nINIT_WORK(&info->work, interrupt_event_handler);\r\nqueue_work(shpchp_wq, &info->work);\r\nreturn 0;\r\n}\r\nu8 shpchp_handle_attention_button(u8 hp_slot, struct controller *ctrl)\r\n{\r\nstruct slot *p_slot;\r\nu32 event_type;\r\nctrl_dbg(ctrl, "Attention button interrupt received\n");\r\np_slot = shpchp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\r\np_slot->hpc_ops->get_adapter_status(p_slot, &(p_slot->presence_save));\r\nctrl_info(ctrl, "Button pressed on Slot(%s)\n", slot_name(p_slot));\r\nevent_type = INT_BUTTON_PRESS;\r\nqueue_interrupt_event(p_slot, event_type);\r\nreturn 0;\r\n}\r\nu8 shpchp_handle_switch_change(u8 hp_slot, struct controller *ctrl)\r\n{\r\nstruct slot *p_slot;\r\nu8 getstatus;\r\nu32 event_type;\r\nctrl_dbg(ctrl, "Switch interrupt received\n");\r\np_slot = shpchp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\r\np_slot->hpc_ops->get_adapter_status(p_slot, &(p_slot->presence_save));\r\np_slot->hpc_ops->get_latch_status(p_slot, &getstatus);\r\nctrl_dbg(ctrl, "Card present %x Power status %x\n",\r\np_slot->presence_save, p_slot->pwr_save);\r\nif (getstatus) {\r\nctrl_info(ctrl, "Latch open on Slot(%s)\n", slot_name(p_slot));\r\nevent_type = INT_SWITCH_OPEN;\r\nif (p_slot->pwr_save && p_slot->presence_save) {\r\nevent_type = INT_POWER_FAULT;\r\nctrl_err(ctrl, "Surprise Removal of card\n");\r\n}\r\n} else {\r\nctrl_info(ctrl, "Latch close on Slot(%s)\n", slot_name(p_slot));\r\nevent_type = INT_SWITCH_CLOSE;\r\n}\r\nqueue_interrupt_event(p_slot, event_type);\r\nreturn 1;\r\n}\r\nu8 shpchp_handle_presence_change(u8 hp_slot, struct controller *ctrl)\r\n{\r\nstruct slot *p_slot;\r\nu32 event_type;\r\nctrl_dbg(ctrl, "Presence/Notify input change\n");\r\np_slot = shpchp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\r\np_slot->hpc_ops->get_adapter_status(p_slot, &(p_slot->presence_save));\r\nif (p_slot->presence_save) {\r\nctrl_info(ctrl, "Card present on Slot(%s)\n",\r\nslot_name(p_slot));\r\nevent_type = INT_PRESENCE_ON;\r\n} else {\r\nctrl_info(ctrl, "Card not present on Slot(%s)\n",\r\nslot_name(p_slot));\r\nevent_type = INT_PRESENCE_OFF;\r\n}\r\nqueue_interrupt_event(p_slot, event_type);\r\nreturn 1;\r\n}\r\nu8 shpchp_handle_power_fault(u8 hp_slot, struct controller *ctrl)\r\n{\r\nstruct slot *p_slot;\r\nu32 event_type;\r\nctrl_dbg(ctrl, "Power fault interrupt received\n");\r\np_slot = shpchp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\r\nif ( !(p_slot->hpc_ops->query_power_fault(p_slot))) {\r\nctrl_info(ctrl, "Power fault cleared on Slot(%s)\n",\r\nslot_name(p_slot));\r\np_slot->status = 0x00;\r\nevent_type = INT_POWER_FAULT_CLEAR;\r\n} else {\r\nctrl_info(ctrl, "Power fault on Slot(%s)\n", slot_name(p_slot));\r\nevent_type = INT_POWER_FAULT;\r\np_slot->status = 0xFF;\r\nctrl_info(ctrl, "Power fault bit %x set\n", hp_slot);\r\n}\r\nqueue_interrupt_event(p_slot, event_type);\r\nreturn 1;\r\n}\r\nstatic int change_bus_speed(struct controller *ctrl, struct slot *p_slot,\r\nenum pci_bus_speed speed)\r\n{\r\nint rc = 0;\r\nctrl_dbg(ctrl, "Change speed to %d\n", speed);\r\nif ((rc = p_slot->hpc_ops->set_bus_speed_mode(p_slot, speed))) {\r\nctrl_err(ctrl, "%s: Issue of set bus speed mode command "\r\n"failed\n", __func__);\r\nreturn WRONG_BUS_FREQUENCY;\r\n}\r\nreturn rc;\r\n}\r\nstatic int fix_bus_speed(struct controller *ctrl, struct slot *pslot,\r\nu8 flag, enum pci_bus_speed asp, enum pci_bus_speed bsp,\r\nenum pci_bus_speed msp)\r\n{\r\nint rc = 0;\r\nif (flag) {\r\nif (asp < bsp) {\r\nctrl_err(ctrl, "Speed of bus %x and adapter %x "\r\n"mismatch\n", bsp, asp);\r\nrc = WRONG_BUS_FREQUENCY;\r\n}\r\nreturn rc;\r\n}\r\nif (asp < msp) {\r\nif (bsp != asp)\r\nrc = change_bus_speed(ctrl, pslot, asp);\r\n} else {\r\nif (bsp != msp)\r\nrc = change_bus_speed(ctrl, pslot, msp);\r\n}\r\nreturn rc;\r\n}\r\nstatic int board_added(struct slot *p_slot)\r\n{\r\nu8 hp_slot;\r\nu8 slots_not_empty = 0;\r\nint rc = 0;\r\nenum pci_bus_speed asp, bsp, msp;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nstruct pci_bus *parent = ctrl->pci_dev->subordinate;\r\nhp_slot = p_slot->device - ctrl->slot_device_offset;\r\nctrl_dbg(ctrl,\r\n"%s: p_slot->device, slot_offset, hp_slot = %d, %d ,%d\n",\r\n__func__, p_slot->device, ctrl->slot_device_offset, hp_slot);\r\nrc = p_slot->hpc_ops->power_on_slot(p_slot);\r\nif (rc) {\r\nctrl_err(ctrl, "Failed to power on slot\n");\r\nreturn -1;\r\n}\r\nif ((ctrl->pci_dev->vendor == 0x8086) && (ctrl->pci_dev->device == 0x0332)) {\r\nif ((rc = p_slot->hpc_ops->set_bus_speed_mode(p_slot, PCI_SPEED_33MHz))) {\r\nctrl_err(ctrl, "%s: Issue of set bus speed mode command"\r\n" failed\n", __func__);\r\nreturn WRONG_BUS_FREQUENCY;\r\n}\r\nif ((rc = p_slot->hpc_ops->slot_enable(p_slot))) {\r\nctrl_err(ctrl, "Issue of Slot Enable command failed\n");\r\nreturn rc;\r\n}\r\n}\r\nrc = p_slot->hpc_ops->get_adapter_speed(p_slot, &asp);\r\nif (rc) {\r\nctrl_err(ctrl, "Can't get adapter speed or "\r\n"bus mode mismatch\n");\r\nreturn WRONG_BUS_FREQUENCY;\r\n}\r\nbsp = ctrl->pci_dev->bus->cur_bus_speed;\r\nmsp = ctrl->pci_dev->bus->max_bus_speed;\r\nif (!list_empty(&ctrl->pci_dev->subordinate->devices))\r\nslots_not_empty = 1;\r\nctrl_dbg(ctrl, "%s: slots_not_empty %d, adapter_speed %d, bus_speed %d,"\r\n" max_bus_speed %d\n", __func__, slots_not_empty, asp,\r\nbsp, msp);\r\nrc = fix_bus_speed(ctrl, p_slot, slots_not_empty, asp, bsp, msp);\r\nif (rc)\r\nreturn rc;\r\nif ((rc = p_slot->hpc_ops->slot_enable(p_slot))) {\r\nctrl_err(ctrl, "Issue of Slot Enable command failed\n");\r\nreturn rc;\r\n}\r\nmsleep(1000);\r\nctrl_dbg(ctrl, "%s: slot status = %x\n", __func__, p_slot->status);\r\nif (p_slot->status == 0xFF) {\r\nctrl_dbg(ctrl, "%s: Power fault\n", __func__);\r\nrc = POWER_FAILURE;\r\np_slot->status = 0;\r\ngoto err_exit;\r\n}\r\nif (shpchp_configure_device(p_slot)) {\r\nctrl_err(ctrl, "Cannot add device at %04x:%02x:%02x\n",\r\npci_domain_nr(parent), p_slot->bus, p_slot->device);\r\ngoto err_exit;\r\n}\r\np_slot->status = 0;\r\np_slot->is_a_board = 0x01;\r\np_slot->pwr_save = 1;\r\np_slot->hpc_ops->green_led_on(p_slot);\r\nreturn 0;\r\nerr_exit:\r\nrc = p_slot->hpc_ops->slot_disable(p_slot);\r\nif (rc) {\r\nctrl_err(ctrl, "%s: Issue of Slot Disable command failed\n",\r\n__func__);\r\nreturn rc;\r\n}\r\nreturn(rc);\r\n}\r\nstatic int remove_board(struct slot *p_slot)\r\n{\r\nstruct controller *ctrl = p_slot->ctrl;\r\nu8 hp_slot;\r\nint rc;\r\nif (shpchp_unconfigure_device(p_slot))\r\nreturn(1);\r\nhp_slot = p_slot->device - ctrl->slot_device_offset;\r\np_slot = shpchp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\r\nctrl_dbg(ctrl, "%s: hp_slot = %d\n", __func__, hp_slot);\r\nif (p_slot->is_a_board)\r\np_slot->status = 0x01;\r\nrc = p_slot->hpc_ops->slot_disable(p_slot);\r\nif (rc) {\r\nctrl_err(ctrl, "%s: Issue of Slot Disable command failed\n",\r\n__func__);\r\nreturn rc;\r\n}\r\nrc = p_slot->hpc_ops->set_attention_status(p_slot, 0);\r\nif (rc) {\r\nctrl_err(ctrl, "Issue of Set Attention command failed\n");\r\nreturn rc;\r\n}\r\np_slot->pwr_save = 0;\r\np_slot->is_a_board = 0;\r\nreturn 0;\r\n}\r\nstatic void shpchp_pushbutton_thread(struct work_struct *work)\r\n{\r\nstruct pushbutton_work_info *info =\r\ncontainer_of(work, struct pushbutton_work_info, work);\r\nstruct slot *p_slot = info->p_slot;\r\nmutex_lock(&p_slot->lock);\r\nswitch (p_slot->state) {\r\ncase POWEROFF_STATE:\r\nmutex_unlock(&p_slot->lock);\r\nshpchp_disable_slot(p_slot);\r\nmutex_lock(&p_slot->lock);\r\np_slot->state = STATIC_STATE;\r\nbreak;\r\ncase POWERON_STATE:\r\nmutex_unlock(&p_slot->lock);\r\nif (shpchp_enable_slot(p_slot))\r\np_slot->hpc_ops->green_led_off(p_slot);\r\nmutex_lock(&p_slot->lock);\r\np_slot->state = STATIC_STATE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&p_slot->lock);\r\nkfree(info);\r\n}\r\nvoid shpchp_queue_pushbutton_work(struct work_struct *work)\r\n{\r\nstruct slot *p_slot = container_of(work, struct slot, work.work);\r\nstruct pushbutton_work_info *info;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\nctrl_err(p_slot->ctrl, "%s: Cannot allocate memory\n",\r\n__func__);\r\nreturn;\r\n}\r\ninfo->p_slot = p_slot;\r\nINIT_WORK(&info->work, shpchp_pushbutton_thread);\r\nmutex_lock(&p_slot->lock);\r\nswitch (p_slot->state) {\r\ncase BLINKINGOFF_STATE:\r\np_slot->state = POWEROFF_STATE;\r\nbreak;\r\ncase BLINKINGON_STATE:\r\np_slot->state = POWERON_STATE;\r\nbreak;\r\ndefault:\r\nkfree(info);\r\ngoto out;\r\n}\r\nqueue_work(shpchp_ordered_wq, &info->work);\r\nout:\r\nmutex_unlock(&p_slot->lock);\r\n}\r\nstatic int update_slot_info (struct slot *slot)\r\n{\r\nstruct hotplug_slot_info *info;\r\nint result;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nslot->hpc_ops->get_power_status(slot, &(info->power_status));\r\nslot->hpc_ops->get_attention_status(slot, &(info->attention_status));\r\nslot->hpc_ops->get_latch_status(slot, &(info->latch_status));\r\nslot->hpc_ops->get_adapter_status(slot, &(info->adapter_status));\r\nresult = pci_hp_change_slot_info(slot->hotplug_slot, info);\r\nkfree (info);\r\nreturn result;\r\n}\r\nstatic void handle_button_press_event(struct slot *p_slot)\r\n{\r\nu8 getstatus;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nswitch (p_slot->state) {\r\ncase STATIC_STATE:\r\np_slot->hpc_ops->get_power_status(p_slot, &getstatus);\r\nif (getstatus) {\r\np_slot->state = BLINKINGOFF_STATE;\r\nctrl_info(ctrl, "PCI slot #%s - powering off due to "\r\n"button press.\n", slot_name(p_slot));\r\n} else {\r\np_slot->state = BLINKINGON_STATE;\r\nctrl_info(ctrl, "PCI slot #%s - powering on due to "\r\n"button press.\n", slot_name(p_slot));\r\n}\r\np_slot->hpc_ops->green_led_blink(p_slot);\r\np_slot->hpc_ops->set_attention_status(p_slot, 0);\r\nqueue_delayed_work(shpchp_wq, &p_slot->work, 5*HZ);\r\nbreak;\r\ncase BLINKINGOFF_STATE:\r\ncase BLINKINGON_STATE:\r\nctrl_info(ctrl, "Button cancel on Slot(%s)\n",\r\nslot_name(p_slot));\r\ncancel_delayed_work(&p_slot->work);\r\nif (p_slot->state == BLINKINGOFF_STATE)\r\np_slot->hpc_ops->green_led_on(p_slot);\r\nelse\r\np_slot->hpc_ops->green_led_off(p_slot);\r\np_slot->hpc_ops->set_attention_status(p_slot, 0);\r\nctrl_info(ctrl, "PCI slot #%s - action canceled due to "\r\n"button press\n", slot_name(p_slot));\r\np_slot->state = STATIC_STATE;\r\nbreak;\r\ncase POWEROFF_STATE:\r\ncase POWERON_STATE:\r\nctrl_info(ctrl, "Button ignore on Slot(%s)\n",\r\nslot_name(p_slot));\r\nupdate_slot_info(p_slot);\r\nbreak;\r\ndefault:\r\nctrl_warn(ctrl, "Not a valid state\n");\r\nbreak;\r\n}\r\n}\r\nstatic void interrupt_event_handler(struct work_struct *work)\r\n{\r\nstruct event_info *info = container_of(work, struct event_info, work);\r\nstruct slot *p_slot = info->p_slot;\r\nmutex_lock(&p_slot->lock);\r\nswitch (info->event_type) {\r\ncase INT_BUTTON_PRESS:\r\nhandle_button_press_event(p_slot);\r\nbreak;\r\ncase INT_POWER_FAULT:\r\nctrl_dbg(p_slot->ctrl, "%s: Power fault\n", __func__);\r\np_slot->hpc_ops->set_attention_status(p_slot, 1);\r\np_slot->hpc_ops->green_led_off(p_slot);\r\nbreak;\r\ndefault:\r\nupdate_slot_info(p_slot);\r\nbreak;\r\n}\r\nmutex_unlock(&p_slot->lock);\r\nkfree(info);\r\n}\r\nstatic int shpchp_enable_slot (struct slot *p_slot)\r\n{\r\nu8 getstatus = 0;\r\nint rc, retval = -ENODEV;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nmutex_lock(&p_slot->ctrl->crit_sect);\r\nrc = p_slot->hpc_ops->get_adapter_status(p_slot, &getstatus);\r\nif (rc || !getstatus) {\r\nctrl_info(ctrl, "No adapter on slot(%s)\n", slot_name(p_slot));\r\ngoto out;\r\n}\r\nrc = p_slot->hpc_ops->get_latch_status(p_slot, &getstatus);\r\nif (rc || getstatus) {\r\nctrl_info(ctrl, "Latch open on slot(%s)\n", slot_name(p_slot));\r\ngoto out;\r\n}\r\nrc = p_slot->hpc_ops->get_power_status(p_slot, &getstatus);\r\nif (rc || getstatus) {\r\nctrl_info(ctrl, "Already enabled on slot(%s)\n",\r\nslot_name(p_slot));\r\ngoto out;\r\n}\r\np_slot->is_a_board = 1;\r\np_slot->hpc_ops->get_adapter_status(p_slot, &(p_slot->presence_save));\r\np_slot->hpc_ops->get_power_status(p_slot, &(p_slot->pwr_save));\r\nctrl_dbg(ctrl, "%s: p_slot->pwr_save %x\n", __func__, p_slot->pwr_save);\r\np_slot->hpc_ops->get_latch_status(p_slot, &getstatus);\r\nif(((p_slot->ctrl->pci_dev->vendor == PCI_VENDOR_ID_AMD) ||\r\n(p_slot->ctrl->pci_dev->device == PCI_DEVICE_ID_AMD_POGO_7458))\r\n&& p_slot->ctrl->num_slots == 1) {\r\namd_pogo_errata_save_misc_reg(p_slot);\r\nretval = board_added(p_slot);\r\namd_pogo_errata_restore_misc_reg(p_slot);\r\n} else\r\nretval = board_added(p_slot);\r\nif (retval) {\r\np_slot->hpc_ops->get_adapter_status(p_slot,\r\n&(p_slot->presence_save));\r\np_slot->hpc_ops->get_latch_status(p_slot, &getstatus);\r\n}\r\nupdate_slot_info(p_slot);\r\nout:\r\nmutex_unlock(&p_slot->ctrl->crit_sect);\r\nreturn retval;\r\n}\r\nstatic int shpchp_disable_slot (struct slot *p_slot)\r\n{\r\nu8 getstatus = 0;\r\nint rc, retval = -ENODEV;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nif (!p_slot->ctrl)\r\nreturn -ENODEV;\r\nmutex_lock(&p_slot->ctrl->crit_sect);\r\nrc = p_slot->hpc_ops->get_adapter_status(p_slot, &getstatus);\r\nif (rc || !getstatus) {\r\nctrl_info(ctrl, "No adapter on slot(%s)\n", slot_name(p_slot));\r\ngoto out;\r\n}\r\nrc = p_slot->hpc_ops->get_latch_status(p_slot, &getstatus);\r\nif (rc || getstatus) {\r\nctrl_info(ctrl, "Latch open on slot(%s)\n", slot_name(p_slot));\r\ngoto out;\r\n}\r\nrc = p_slot->hpc_ops->get_power_status(p_slot, &getstatus);\r\nif (rc || !getstatus) {\r\nctrl_info(ctrl, "Already disabled on slot(%s)\n",\r\nslot_name(p_slot));\r\ngoto out;\r\n}\r\nretval = remove_board(p_slot);\r\nupdate_slot_info(p_slot);\r\nout:\r\nmutex_unlock(&p_slot->ctrl->crit_sect);\r\nreturn retval;\r\n}\r\nint shpchp_sysfs_enable_slot(struct slot *p_slot)\r\n{\r\nint retval = -ENODEV;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nmutex_lock(&p_slot->lock);\r\nswitch (p_slot->state) {\r\ncase BLINKINGON_STATE:\r\ncancel_delayed_work(&p_slot->work);\r\ncase STATIC_STATE:\r\np_slot->state = POWERON_STATE;\r\nmutex_unlock(&p_slot->lock);\r\nretval = shpchp_enable_slot(p_slot);\r\nmutex_lock(&p_slot->lock);\r\np_slot->state = STATIC_STATE;\r\nbreak;\r\ncase POWERON_STATE:\r\nctrl_info(ctrl, "Slot %s is already in powering on state\n",\r\nslot_name(p_slot));\r\nbreak;\r\ncase BLINKINGOFF_STATE:\r\ncase POWEROFF_STATE:\r\nctrl_info(ctrl, "Already enabled on slot %s\n",\r\nslot_name(p_slot));\r\nbreak;\r\ndefault:\r\nctrl_err(ctrl, "Not a valid state on slot %s\n",\r\nslot_name(p_slot));\r\nbreak;\r\n}\r\nmutex_unlock(&p_slot->lock);\r\nreturn retval;\r\n}\r\nint shpchp_sysfs_disable_slot(struct slot *p_slot)\r\n{\r\nint retval = -ENODEV;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nmutex_lock(&p_slot->lock);\r\nswitch (p_slot->state) {\r\ncase BLINKINGOFF_STATE:\r\ncancel_delayed_work(&p_slot->work);\r\ncase STATIC_STATE:\r\np_slot->state = POWEROFF_STATE;\r\nmutex_unlock(&p_slot->lock);\r\nretval = shpchp_disable_slot(p_slot);\r\nmutex_lock(&p_slot->lock);\r\np_slot->state = STATIC_STATE;\r\nbreak;\r\ncase POWEROFF_STATE:\r\nctrl_info(ctrl, "Slot %s is already in powering off state\n",\r\nslot_name(p_slot));\r\nbreak;\r\ncase BLINKINGON_STATE:\r\ncase POWERON_STATE:\r\nctrl_info(ctrl, "Already disabled on slot %s\n",\r\nslot_name(p_slot));\r\nbreak;\r\ndefault:\r\nctrl_err(ctrl, "Not a valid state on slot %s\n",\r\nslot_name(p_slot));\r\nbreak;\r\n}\r\nmutex_unlock(&p_slot->lock);\r\nreturn retval;\r\n}
