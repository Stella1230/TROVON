int iio_push_event(struct iio_dev *indio_dev, u64 ev_code, s64 timestamp)\r\n{\r\nstruct iio_event_interface *ev_int = indio_dev->event_interface;\r\nstruct iio_event_data ev;\r\nint copied;\r\nspin_lock(&ev_int->wait.lock);\r\nif (test_bit(IIO_BUSY_BIT_POS, &ev_int->flags)) {\r\nev.id = ev_code;\r\nev.timestamp = timestamp;\r\ncopied = kfifo_put(&ev_int->det_events, &ev);\r\nif (copied != 0)\r\nwake_up_locked_poll(&ev_int->wait, POLLIN);\r\n}\r\nspin_unlock(&ev_int->wait.lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int iio_event_poll(struct file *filep,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct iio_event_interface *ev_int = filep->private_data;\r\nunsigned int events = 0;\r\npoll_wait(filep, &ev_int->wait, wait);\r\nspin_lock(&ev_int->wait.lock);\r\nif (!kfifo_is_empty(&ev_int->det_events))\r\nevents = POLLIN | POLLRDNORM;\r\nspin_unlock(&ev_int->wait.lock);\r\nreturn events;\r\n}\r\nstatic ssize_t iio_event_chrdev_read(struct file *filep,\r\nchar __user *buf,\r\nsize_t count,\r\nloff_t *f_ps)\r\n{\r\nstruct iio_event_interface *ev_int = filep->private_data;\r\nunsigned int copied;\r\nint ret;\r\nif (count < sizeof(struct iio_event_data))\r\nreturn -EINVAL;\r\nspin_lock(&ev_int->wait.lock);\r\nif (kfifo_is_empty(&ev_int->det_events)) {\r\nif (filep->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\ngoto error_unlock;\r\n}\r\nret = wait_event_interruptible_locked(ev_int->wait,\r\n!kfifo_is_empty(&ev_int->det_events));\r\nif (ret)\r\ngoto error_unlock;\r\n}\r\nret = kfifo_to_user(&ev_int->det_events, buf, count, &copied);\r\nerror_unlock:\r\nspin_unlock(&ev_int->wait.lock);\r\nreturn ret ? ret : copied;\r\n}\r\nstatic int iio_event_chrdev_release(struct inode *inode, struct file *filep)\r\n{\r\nstruct iio_event_interface *ev_int = filep->private_data;\r\nspin_lock(&ev_int->wait.lock);\r\n__clear_bit(IIO_BUSY_BIT_POS, &ev_int->flags);\r\nkfifo_reset_out(&ev_int->det_events);\r\nspin_unlock(&ev_int->wait.lock);\r\nreturn 0;\r\n}\r\nint iio_event_getfd(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_event_interface *ev_int = indio_dev->event_interface;\r\nint fd;\r\nif (ev_int == NULL)\r\nreturn -ENODEV;\r\nspin_lock(&ev_int->wait.lock);\r\nif (__test_and_set_bit(IIO_BUSY_BIT_POS, &ev_int->flags)) {\r\nspin_unlock(&ev_int->wait.lock);\r\nreturn -EBUSY;\r\n}\r\nspin_unlock(&ev_int->wait.lock);\r\nfd = anon_inode_getfd("iio:event",\r\n&iio_event_chrdev_fileops, ev_int, O_RDONLY);\r\nif (fd < 0) {\r\nspin_lock(&ev_int->wait.lock);\r\n__clear_bit(IIO_BUSY_BIT_POS, &ev_int->flags);\r\nspin_unlock(&ev_int->wait.lock);\r\n}\r\nreturn fd;\r\n}\r\nstatic ssize_t iio_ev_state_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint ret;\r\nbool val;\r\nret = strtobool(buf, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nret = indio_dev->info->write_event_config(indio_dev,\r\nthis_attr->address,\r\nval);\r\nreturn (ret < 0) ? ret : len;\r\n}\r\nstatic ssize_t iio_ev_state_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint val = indio_dev->info->read_event_config(indio_dev,\r\nthis_attr->address);\r\nif (val < 0)\r\nreturn val;\r\nelse\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t iio_ev_value_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint val, ret;\r\nret = indio_dev->info->read_event_value(indio_dev,\r\nthis_attr->address, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t iio_ev_value_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nunsigned long val;\r\nint ret;\r\nif (!indio_dev->info->write_event_value)\r\nreturn -EINVAL;\r\nret = strict_strtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nret = indio_dev->info->write_event_value(indio_dev, this_attr->address,\r\nval);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic int iio_device_add_event_sysfs(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan)\r\n{\r\nint ret = 0, i, attrcount = 0;\r\nu64 mask = 0;\r\nchar *postfix;\r\nif (!chan->event_mask)\r\nreturn 0;\r\nfor_each_set_bit(i, &chan->event_mask, sizeof(chan->event_mask)*8) {\r\npostfix = kasprintf(GFP_KERNEL, "%s_%s_en",\r\niio_ev_type_text[i/IIO_EV_DIR_MAX],\r\niio_ev_dir_text[i%IIO_EV_DIR_MAX]);\r\nif (postfix == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nif (chan->modified)\r\nmask = IIO_MOD_EVENT_CODE(chan->type, 0, chan->channel,\r\ni/IIO_EV_DIR_MAX,\r\ni%IIO_EV_DIR_MAX);\r\nelse if (chan->differential)\r\nmask = IIO_EVENT_CODE(chan->type,\r\n0, 0,\r\ni%IIO_EV_DIR_MAX,\r\ni/IIO_EV_DIR_MAX,\r\n0,\r\nchan->channel,\r\nchan->channel2);\r\nelse\r\nmask = IIO_UNMOD_EVENT_CODE(chan->type,\r\nchan->channel,\r\ni/IIO_EV_DIR_MAX,\r\ni%IIO_EV_DIR_MAX);\r\nret = __iio_add_chan_devattr(postfix,\r\nchan,\r\n&iio_ev_state_show,\r\niio_ev_state_store,\r\nmask,\r\n0,\r\n&indio_dev->dev,\r\n&indio_dev->event_interface->\r\ndev_attr_list);\r\nkfree(postfix);\r\nif (ret)\r\ngoto error_ret;\r\nattrcount++;\r\npostfix = kasprintf(GFP_KERNEL, "%s_%s_value",\r\niio_ev_type_text[i/IIO_EV_DIR_MAX],\r\niio_ev_dir_text[i%IIO_EV_DIR_MAX]);\r\nif (postfix == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nret = __iio_add_chan_devattr(postfix, chan,\r\niio_ev_value_show,\r\niio_ev_value_store,\r\nmask,\r\n0,\r\n&indio_dev->dev,\r\n&indio_dev->event_interface->\r\ndev_attr_list);\r\nkfree(postfix);\r\nif (ret)\r\ngoto error_ret;\r\nattrcount++;\r\n}\r\nret = attrcount;\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic inline void __iio_remove_event_config_attrs(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_dev_attr *p, *n;\r\nlist_for_each_entry_safe(p, n,\r\n&indio_dev->event_interface->\r\ndev_attr_list, l) {\r\nkfree(p->dev_attr.attr.name);\r\nkfree(p);\r\n}\r\n}\r\nstatic inline int __iio_add_event_config_attrs(struct iio_dev *indio_dev)\r\n{\r\nint j, ret, attrcount = 0;\r\nfor (j = 0; j < indio_dev->num_channels; j++) {\r\nret = iio_device_add_event_sysfs(indio_dev,\r\n&indio_dev->channels[j]);\r\nif (ret < 0)\r\ngoto error_clear_attrs;\r\nattrcount += ret;\r\n}\r\nreturn attrcount;\r\nerror_clear_attrs:\r\n__iio_remove_event_config_attrs(indio_dev);\r\nreturn ret;\r\n}\r\nstatic bool iio_check_for_dynamic_events(struct iio_dev *indio_dev)\r\n{\r\nint j;\r\nfor (j = 0; j < indio_dev->num_channels; j++)\r\nif (indio_dev->channels[j].event_mask != 0)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void iio_setup_ev_int(struct iio_event_interface *ev_int)\r\n{\r\nINIT_KFIFO(ev_int->det_events);\r\ninit_waitqueue_head(&ev_int->wait);\r\n}\r\nint iio_device_register_eventset(struct iio_dev *indio_dev)\r\n{\r\nstruct iio_dev_attr *p;\r\nint ret = 0, attrcount_orig = 0, attrcount, attrn;\r\nstruct attribute **attr;\r\nif (!(indio_dev->info->event_attrs ||\r\niio_check_for_dynamic_events(indio_dev)))\r\nreturn 0;\r\nindio_dev->event_interface =\r\nkzalloc(sizeof(struct iio_event_interface), GFP_KERNEL);\r\nif (indio_dev->event_interface == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nINIT_LIST_HEAD(&indio_dev->event_interface->dev_attr_list);\r\niio_setup_ev_int(indio_dev->event_interface);\r\nif (indio_dev->info->event_attrs != NULL) {\r\nattr = indio_dev->info->event_attrs->attrs;\r\nwhile (*attr++ != NULL)\r\nattrcount_orig++;\r\n}\r\nattrcount = attrcount_orig;\r\nif (indio_dev->channels) {\r\nret = __iio_add_event_config_attrs(indio_dev);\r\nif (ret < 0)\r\ngoto error_free_setup_event_lines;\r\nattrcount += ret;\r\n}\r\nindio_dev->event_interface->group.name = iio_event_group_name;\r\nindio_dev->event_interface->group.attrs = kcalloc(attrcount + 1,\r\nsizeof(indio_dev->event_interface->group.attrs[0]),\r\nGFP_KERNEL);\r\nif (indio_dev->event_interface->group.attrs == NULL) {\r\nret = -ENOMEM;\r\ngoto error_free_setup_event_lines;\r\n}\r\nif (indio_dev->info->event_attrs)\r\nmemcpy(indio_dev->event_interface->group.attrs,\r\nindio_dev->info->event_attrs->attrs,\r\nsizeof(indio_dev->event_interface->group.attrs[0])\r\n*attrcount_orig);\r\nattrn = attrcount_orig;\r\nlist_for_each_entry(p,\r\n&indio_dev->event_interface->dev_attr_list,\r\nl)\r\nindio_dev->event_interface->group.attrs[attrn++] =\r\n&p->dev_attr.attr;\r\nindio_dev->groups[indio_dev->groupcounter++] =\r\n&indio_dev->event_interface->group;\r\nreturn 0;\r\nerror_free_setup_event_lines:\r\n__iio_remove_event_config_attrs(indio_dev);\r\nkfree(indio_dev->event_interface);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nvoid iio_device_unregister_eventset(struct iio_dev *indio_dev)\r\n{\r\nif (indio_dev->event_interface == NULL)\r\nreturn;\r\n__iio_remove_event_config_attrs(indio_dev);\r\nkfree(indio_dev->event_interface->group.attrs);\r\nkfree(indio_dev->event_interface);\r\n}
