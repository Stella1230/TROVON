static void\r\n_set_debug(struct fritzcard *card)\r\n{\r\ncard->isac.dch.debug = debug;\r\ncard->bch[0].debug = debug;\r\ncard->bch[1].debug = debug;\r\n}\r\nstatic int\r\nset_debug(const char *val, struct kernel_param *kp)\r\n{\r\nint ret;\r\nstruct fritzcard *card;\r\nret = param_set_uint(val, kp);\r\nif (!ret) {\r\nread_lock(&card_lock);\r\nlist_for_each_entry(card, &Cards, list)\r\n_set_debug(card);\r\nread_unlock(&card_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic u8\r\nReadISAC_V1(void *p, u8 offset)\r\n{\r\nstruct fritzcard *fc = p;\r\nu8 idx = (offset > 0x2f) ? AVM_ISAC_REG_HIGH : AVM_ISAC_REG_LOW;\r\noutb(idx, fc->addr + CHIP_INDEX);\r\nreturn inb(fc->addr + CHIP_WINDOW + (offset & 0xf));\r\n}\r\nstatic void\r\nWriteISAC_V1(void *p, u8 offset, u8 value)\r\n{\r\nstruct fritzcard *fc = p;\r\nu8 idx = (offset > 0x2f) ? AVM_ISAC_REG_HIGH : AVM_ISAC_REG_LOW;\r\noutb(idx, fc->addr + CHIP_INDEX);\r\noutb(value, fc->addr + CHIP_WINDOW + (offset & 0xf));\r\n}\r\nstatic void\r\nReadFiFoISAC_V1(void *p, u8 off, u8 *data, int size)\r\n{\r\nstruct fritzcard *fc = p;\r\noutb(AVM_ISAC_FIFO, fc->addr + CHIP_INDEX);\r\ninsb(fc->addr + CHIP_WINDOW, data, size);\r\n}\r\nstatic void\r\nWriteFiFoISAC_V1(void *p, u8 off, u8 *data, int size)\r\n{\r\nstruct fritzcard *fc = p;\r\noutb(AVM_ISAC_FIFO, fc->addr + CHIP_INDEX);\r\noutsb(fc->addr + CHIP_WINDOW, data, size);\r\n}\r\nstatic u8\r\nReadISAC_V2(void *p, u8 offset)\r\n{\r\nstruct fritzcard *fc = p;\r\noutl(offset, fc->addr + AVM_ISACX_INDEX);\r\nreturn 0xff & inl(fc->addr + AVM_ISACX_DATA);\r\n}\r\nstatic void\r\nWriteISAC_V2(void *p, u8 offset, u8 value)\r\n{\r\nstruct fritzcard *fc = p;\r\noutl(offset, fc->addr + AVM_ISACX_INDEX);\r\noutl(value, fc->addr + AVM_ISACX_DATA);\r\n}\r\nstatic void\r\nReadFiFoISAC_V2(void *p, u8 off, u8 *data, int size)\r\n{\r\nstruct fritzcard *fc = p;\r\nint i;\r\noutl(off, fc->addr + AVM_ISACX_INDEX);\r\nfor (i = 0; i < size; i++)\r\ndata[i] = 0xff & inl(fc->addr + AVM_ISACX_DATA);\r\n}\r\nstatic void\r\nWriteFiFoISAC_V2(void *p, u8 off, u8 *data, int size)\r\n{\r\nstruct fritzcard *fc = p;\r\nint i;\r\noutl(off, fc->addr + AVM_ISACX_INDEX);\r\nfor (i = 0; i < size; i++)\r\noutl(data[i], fc->addr + AVM_ISACX_DATA);\r\n}\r\nstatic struct bchannel *\r\nSel_BCS(struct fritzcard *fc, u32 channel)\r\n{\r\nif (test_bit(FLG_ACTIVE, &fc->bch[0].Flags) &&\r\n(fc->bch[0].nr & channel))\r\nreturn &fc->bch[0];\r\nelse if (test_bit(FLG_ACTIVE, &fc->bch[1].Flags) &&\r\n(fc->bch[1].nr & channel))\r\nreturn &fc->bch[1];\r\nelse\r\nreturn NULL;\r\n}\r\nstatic inline void\r\n__write_ctrl_pci(struct fritzcard *fc, struct hdlc_hw *hdlc, u32 channel) {\r\nu32 idx = channel == 2 ? AVM_HDLC_2 : AVM_HDLC_1;\r\noutl(idx, fc->addr + CHIP_INDEX);\r\noutl(hdlc->ctrl.ctrl, fc->addr + CHIP_WINDOW + HDLC_STATUS);\r\n}\r\nstatic inline void\r\n__write_ctrl_pciv2(struct fritzcard *fc, struct hdlc_hw *hdlc, u32 channel) {\r\noutl(hdlc->ctrl.ctrl, fc->addr + (channel == 2 ? AVM_HDLC_STATUS_2 :\r\nAVM_HDLC_STATUS_1));\r\n}\r\nvoid\r\nwrite_ctrl(struct bchannel *bch, int which) {\r\nstruct fritzcard *fc = bch->hw;\r\nstruct hdlc_hw *hdlc;\r\nhdlc = &fc->hdlc[(bch->nr - 1) & 1];\r\npr_debug("%s: hdlc %c wr%x ctrl %x\n", fc->name, '@' + bch->nr,\r\nwhich, hdlc->ctrl.ctrl);\r\nswitch (fc->type) {\r\ncase AVM_FRITZ_PCIV2:\r\n__write_ctrl_pciv2(fc, hdlc, bch->nr);\r\nbreak;\r\ncase AVM_FRITZ_PCI:\r\n__write_ctrl_pci(fc, hdlc, bch->nr);\r\nbreak;\r\n}\r\n}\r\nstatic inline u32\r\n__read_status_pci(u_long addr, u32 channel)\r\n{\r\noutl(channel == 2 ? AVM_HDLC_2 : AVM_HDLC_1, addr + CHIP_INDEX);\r\nreturn inl(addr + CHIP_WINDOW + HDLC_STATUS);\r\n}\r\nstatic inline u32\r\n__read_status_pciv2(u_long addr, u32 channel)\r\n{\r\nreturn inl(addr + (channel == 2 ? AVM_HDLC_STATUS_2 :\r\nAVM_HDLC_STATUS_1));\r\n}\r\nstatic u32\r\nread_status(struct fritzcard *fc, u32 channel)\r\n{\r\nswitch (fc->type) {\r\ncase AVM_FRITZ_PCIV2:\r\nreturn __read_status_pciv2(fc->addr, channel);\r\ncase AVM_FRITZ_PCI:\r\nreturn __read_status_pci(fc->addr, channel);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nenable_hwirq(struct fritzcard *fc)\r\n{\r\nfc->ctrlreg |= AVM_STATUS0_ENA_IRQ;\r\noutb(fc->ctrlreg, fc->addr + 2);\r\n}\r\nstatic void\r\ndisable_hwirq(struct fritzcard *fc)\r\n{\r\nfc->ctrlreg &= ~AVM_STATUS0_ENA_IRQ;\r\noutb(fc->ctrlreg, fc->addr + 2);\r\n}\r\nstatic int\r\nmodehdlc(struct bchannel *bch, int protocol)\r\n{\r\nstruct fritzcard *fc = bch->hw;\r\nstruct hdlc_hw *hdlc;\r\nu8 mode;\r\nhdlc = &fc->hdlc[(bch->nr - 1) & 1];\r\npr_debug("%s: hdlc %c protocol %x-->%x ch %d\n", fc->name,\r\n'@' + bch->nr, bch->state, protocol, bch->nr);\r\nhdlc->ctrl.ctrl = 0;\r\nmode = (fc->type == AVM_FRITZ_PCIV2) ? HDLC_FIFO_SIZE_128 : 0;\r\nswitch (protocol) {\r\ncase -1:\r\nbch->state = -1;\r\ncase ISDN_P_NONE:\r\nif (bch->state == ISDN_P_NONE)\r\nbreak;\r\nhdlc->ctrl.sr.cmd = HDLC_CMD_XRS | HDLC_CMD_RRS;\r\nhdlc->ctrl.sr.mode = mode | HDLC_MODE_TRANS;\r\nwrite_ctrl(bch, 5);\r\nbch->state = ISDN_P_NONE;\r\ntest_and_clear_bit(FLG_HDLC, &bch->Flags);\r\ntest_and_clear_bit(FLG_TRANSPARENT, &bch->Flags);\r\nbreak;\r\ncase ISDN_P_B_RAW:\r\nbch->state = protocol;\r\nhdlc->ctrl.sr.cmd = HDLC_CMD_XRS | HDLC_CMD_RRS;\r\nhdlc->ctrl.sr.mode = mode | HDLC_MODE_TRANS;\r\nwrite_ctrl(bch, 5);\r\nhdlc->ctrl.sr.cmd = HDLC_CMD_XRS;\r\nwrite_ctrl(bch, 1);\r\nhdlc->ctrl.sr.cmd = 0;\r\ntest_and_set_bit(FLG_TRANSPARENT, &bch->Flags);\r\nbreak;\r\ncase ISDN_P_B_HDLC:\r\nbch->state = protocol;\r\nhdlc->ctrl.sr.cmd = HDLC_CMD_XRS | HDLC_CMD_RRS;\r\nhdlc->ctrl.sr.mode = mode | HDLC_MODE_ITF_FLG;\r\nwrite_ctrl(bch, 5);\r\nhdlc->ctrl.sr.cmd = HDLC_CMD_XRS;\r\nwrite_ctrl(bch, 1);\r\nhdlc->ctrl.sr.cmd = 0;\r\ntest_and_set_bit(FLG_HDLC, &bch->Flags);\r\nbreak;\r\ndefault:\r\npr_info("%s: protocol not known %x\n", fc->name, protocol);\r\nreturn -ENOPROTOOPT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nhdlc_empty_fifo(struct bchannel *bch, int count)\r\n{\r\nu32 *ptr;\r\nu8 *p;\r\nu32 val, addr;\r\nint cnt;\r\nstruct fritzcard *fc = bch->hw;\r\npr_debug("%s: %s %d\n", fc->name, __func__, count);\r\nif (test_bit(FLG_RX_OFF, &bch->Flags)) {\r\np = NULL;\r\nbch->dropcnt += count;\r\n} else {\r\ncnt = bchannel_get_rxbuf(bch, count);\r\nif (cnt < 0) {\r\npr_warning("%s.B%d: No bufferspace for %d bytes\n",\r\nfc->name, bch->nr, count);\r\nreturn;\r\n}\r\np = skb_put(bch->rx_skb, count);\r\n}\r\nptr = (u32 *)p;\r\nif (fc->type == AVM_FRITZ_PCIV2)\r\naddr = fc->addr + (bch->nr == 2 ?\r\nAVM_HDLC_FIFO_2 : AVM_HDLC_FIFO_1);\r\nelse {\r\naddr = fc->addr + CHIP_WINDOW;\r\noutl(bch->nr == 2 ? AVM_HDLC_2 : AVM_HDLC_1, fc->addr);\r\n}\r\ncnt = 0;\r\nwhile (cnt < count) {\r\nval = le32_to_cpu(inl(addr));\r\nif (p) {\r\nput_unaligned(val, ptr);\r\nptr++;\r\n}\r\ncnt += 4;\r\n}\r\nif (p && (debug & DEBUG_HW_BFIFO)) {\r\nsnprintf(fc->log, LOG_SIZE, "B%1d-recv %s %d ",\r\nbch->nr, fc->name, count);\r\nprint_hex_dump_bytes(fc->log, DUMP_PREFIX_OFFSET, p, count);\r\n}\r\n}\r\nstatic void\r\nhdlc_fill_fifo(struct bchannel *bch)\r\n{\r\nstruct fritzcard *fc = bch->hw;\r\nstruct hdlc_hw *hdlc;\r\nint count, fs, cnt = 0, idx;\r\nbool fillempty = false;\r\nu8 *p;\r\nu32 *ptr, val, addr;\r\nidx = (bch->nr - 1) & 1;\r\nhdlc = &fc->hdlc[idx];\r\nfs = (fc->type == AVM_FRITZ_PCIV2) ?\r\nHDLC_FIFO_SIZE_V2 : HDLC_FIFO_SIZE_V1;\r\nif (!bch->tx_skb) {\r\nif (!test_bit(FLG_TX_EMPTY, &bch->Flags))\r\nreturn;\r\ncount = fs;\r\np = bch->fill;\r\nfillempty = true;\r\n} else {\r\ncount = bch->tx_skb->len - bch->tx_idx;\r\nif (count <= 0)\r\nreturn;\r\np = bch->tx_skb->data + bch->tx_idx;\r\n}\r\nhdlc->ctrl.sr.cmd &= ~HDLC_CMD_XME;\r\nif (count > fs) {\r\ncount = fs;\r\n} else {\r\nif (test_bit(FLG_HDLC, &bch->Flags))\r\nhdlc->ctrl.sr.cmd |= HDLC_CMD_XME;\r\n}\r\nptr = (u32 *)p;\r\nif (!fillempty) {\r\npr_debug("%s.B%d: %d/%d/%d", fc->name, bch->nr, count,\r\nbch->tx_idx, bch->tx_skb->len);\r\nbch->tx_idx += count;\r\n} else {\r\npr_debug("%s.B%d: fillempty %d\n", fc->name, bch->nr, count);\r\n}\r\nhdlc->ctrl.sr.xml = ((count == fs) ? 0 : count);\r\nif (fc->type == AVM_FRITZ_PCIV2) {\r\n__write_ctrl_pciv2(fc, hdlc, bch->nr);\r\naddr = fc->addr + (bch->nr == 2 ?\r\nAVM_HDLC_FIFO_2 : AVM_HDLC_FIFO_1);\r\n} else {\r\n__write_ctrl_pci(fc, hdlc, bch->nr);\r\naddr = fc->addr + CHIP_WINDOW;\r\n}\r\nif (fillempty) {\r\nwhile (cnt < count) {\r\noutl(*ptr, addr);\r\ncnt += 4;\r\n}\r\n} else {\r\nwhile (cnt < count) {\r\nval = get_unaligned(ptr);\r\noutl(cpu_to_le32(val), addr);\r\nptr++;\r\ncnt += 4;\r\n}\r\n}\r\nif ((debug & DEBUG_HW_BFIFO) && !fillempty) {\r\nsnprintf(fc->log, LOG_SIZE, "B%1d-send %s %d ",\r\nbch->nr, fc->name, count);\r\nprint_hex_dump_bytes(fc->log, DUMP_PREFIX_OFFSET, p, count);\r\n}\r\n}\r\nstatic void\r\nHDLC_irq_xpr(struct bchannel *bch)\r\n{\r\nif (bch->tx_skb && bch->tx_idx < bch->tx_skb->len) {\r\nhdlc_fill_fifo(bch);\r\n} else {\r\nif (bch->tx_skb)\r\ndev_kfree_skb(bch->tx_skb);\r\nif (get_next_bframe(bch)) {\r\nhdlc_fill_fifo(bch);\r\ntest_and_clear_bit(FLG_TX_EMPTY, &bch->Flags);\r\n} else if (test_bit(FLG_TX_EMPTY, &bch->Flags)) {\r\nhdlc_fill_fifo(bch);\r\n}\r\n}\r\n}\r\nstatic void\r\nHDLC_irq(struct bchannel *bch, u32 stat)\r\n{\r\nstruct fritzcard *fc = bch->hw;\r\nint len, fs;\r\nu32 rmlMask;\r\nstruct hdlc_hw *hdlc;\r\nhdlc = &fc->hdlc[(bch->nr - 1) & 1];\r\npr_debug("%s: ch%d stat %#x\n", fc->name, bch->nr, stat);\r\nif (fc->type == AVM_FRITZ_PCIV2) {\r\nrmlMask = HDLC_STAT_RML_MASK_V2;\r\nfs = HDLC_FIFO_SIZE_V2;\r\n} else {\r\nrmlMask = HDLC_STAT_RML_MASK_V1;\r\nfs = HDLC_FIFO_SIZE_V1;\r\n}\r\nif (stat & HDLC_INT_RPR) {\r\nif (stat & HDLC_STAT_RDO) {\r\npr_warning("%s: ch%d stat %x RDO\n",\r\nfc->name, bch->nr, stat);\r\nhdlc->ctrl.sr.xml = 0;\r\nhdlc->ctrl.sr.cmd |= HDLC_CMD_RRS;\r\nwrite_ctrl(bch, 1);\r\nhdlc->ctrl.sr.cmd &= ~HDLC_CMD_RRS;\r\nwrite_ctrl(bch, 1);\r\nif (bch->rx_skb)\r\nskb_trim(bch->rx_skb, 0);\r\n} else {\r\nlen = (stat & rmlMask) >> 8;\r\nif (!len)\r\nlen = fs;\r\nhdlc_empty_fifo(bch, len);\r\nif (!bch->rx_skb)\r\ngoto handle_tx;\r\nif (test_bit(FLG_TRANSPARENT, &bch->Flags)) {\r\nrecv_Bchannel(bch, 0, false);\r\n} else if (stat & HDLC_STAT_RME) {\r\nif ((stat & HDLC_STAT_CRCVFRRAB) ==\r\nHDLC_STAT_CRCVFR) {\r\nrecv_Bchannel(bch, 0, false);\r\n} else {\r\npr_warning("%s: got invalid frame\n",\r\nfc->name);\r\nskb_trim(bch->rx_skb, 0);\r\n}\r\n}\r\n}\r\n}\r\nhandle_tx:\r\nif (stat & HDLC_INT_XDU) {\r\npr_warning("%s: ch%d stat %x XDU %s\n", fc->name, bch->nr,\r\nstat, bch->tx_skb ? "tx_skb" : "no tx_skb");\r\nif (bch->tx_skb && bch->tx_skb->len) {\r\nif (!test_bit(FLG_TRANSPARENT, &bch->Flags))\r\nbch->tx_idx = 0;\r\n} else if (test_bit(FLG_FILLEMPTY, &bch->Flags)) {\r\ntest_and_set_bit(FLG_TX_EMPTY, &bch->Flags);\r\n}\r\nhdlc->ctrl.sr.xml = 0;\r\nhdlc->ctrl.sr.cmd |= HDLC_CMD_XRS;\r\nwrite_ctrl(bch, 1);\r\nhdlc->ctrl.sr.cmd &= ~HDLC_CMD_XRS;\r\nHDLC_irq_xpr(bch);\r\nreturn;\r\n} else if (stat & HDLC_INT_XPR)\r\nHDLC_irq_xpr(bch);\r\n}\r\nstatic inline void\r\nHDLC_irq_main(struct fritzcard *fc)\r\n{\r\nu32 stat;\r\nstruct bchannel *bch;\r\nstat = read_status(fc, 1);\r\nif (stat & HDLC_INT_MASK) {\r\nbch = Sel_BCS(fc, 1);\r\nif (bch)\r\nHDLC_irq(bch, stat);\r\nelse\r\npr_debug("%s: spurious ch1 IRQ\n", fc->name);\r\n}\r\nstat = read_status(fc, 2);\r\nif (stat & HDLC_INT_MASK) {\r\nbch = Sel_BCS(fc, 2);\r\nif (bch)\r\nHDLC_irq(bch, stat);\r\nelse\r\npr_debug("%s: spurious ch2 IRQ\n", fc->name);\r\n}\r\n}\r\nstatic irqreturn_t\r\navm_fritz_interrupt(int intno, void *dev_id)\r\n{\r\nstruct fritzcard *fc = dev_id;\r\nu8 val;\r\nu8 sval;\r\nspin_lock(&fc->lock);\r\nsval = inb(fc->addr + 2);\r\npr_debug("%s: irq stat0 %x\n", fc->name, sval);\r\nif ((sval & AVM_STATUS0_IRQ_MASK) == AVM_STATUS0_IRQ_MASK) {\r\nspin_unlock(&fc->lock);\r\nreturn IRQ_NONE;\r\n}\r\nfc->irqcnt++;\r\nif (!(sval & AVM_STATUS0_IRQ_ISAC)) {\r\nval = ReadISAC_V1(fc, ISAC_ISTA);\r\nmISDNisac_irq(&fc->isac, val);\r\n}\r\nif (!(sval & AVM_STATUS0_IRQ_HDLC))\r\nHDLC_irq_main(fc);\r\nspin_unlock(&fc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\navm_fritzv2_interrupt(int intno, void *dev_id)\r\n{\r\nstruct fritzcard *fc = dev_id;\r\nu8 val;\r\nu8 sval;\r\nspin_lock(&fc->lock);\r\nsval = inb(fc->addr + 2);\r\npr_debug("%s: irq stat0 %x\n", fc->name, sval);\r\nif (!(sval & AVM_STATUS0_IRQ_MASK)) {\r\nspin_unlock(&fc->lock);\r\nreturn IRQ_NONE;\r\n}\r\nfc->irqcnt++;\r\nif (sval & AVM_STATUS0_IRQ_HDLC)\r\nHDLC_irq_main(fc);\r\nif (sval & AVM_STATUS0_IRQ_ISAC) {\r\nval = ReadISAC_V2(fc, ISACX_ISTA);\r\nmISDNisac_irq(&fc->isac, val);\r\n}\r\nif (sval & AVM_STATUS0_IRQ_TIMER) {\r\npr_debug("%s: timer irq\n", fc->name);\r\noutb(fc->ctrlreg | AVM_STATUS0_RES_TIMER, fc->addr + 2);\r\nudelay(1);\r\noutb(fc->ctrlreg, fc->addr + 2);\r\n}\r\nspin_unlock(&fc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\navm_l2l1B(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct fritzcard *fc = bch->hw;\r\nint ret = -EINVAL;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nunsigned long flags;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nspin_lock_irqsave(&fc->lock, flags);\r\nret = bchannel_senddata(bch, skb);\r\nif (ret > 0) {\r\nhdlc_fill_fifo(bch);\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&fc->lock, flags);\r\nreturn ret;\r\ncase PH_ACTIVATE_REQ:\r\nspin_lock_irqsave(&fc->lock, flags);\r\nif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags))\r\nret = modehdlc(bch, ch->protocol);\r\nelse\r\nret = 0;\r\nspin_unlock_irqrestore(&fc->lock, flags);\r\nif (!ret)\r\n_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\nbreak;\r\ncase PH_DEACTIVATE_REQ:\r\nspin_lock_irqsave(&fc->lock, flags);\r\nmISDN_clear_bchannel(bch);\r\nmodehdlc(bch, ISDN_P_NONE);\r\nspin_unlock_irqrestore(&fc->lock, flags);\r\n_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\nret = 0;\r\nbreak;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic void\r\ninithdlc(struct fritzcard *fc)\r\n{\r\nmodehdlc(&fc->bch[0], -1);\r\nmodehdlc(&fc->bch[1], -1);\r\n}\r\nvoid\r\nclear_pending_hdlc_ints(struct fritzcard *fc)\r\n{\r\nu32 val;\r\nval = read_status(fc, 1);\r\npr_debug("%s: HDLC 1 STA %x\n", fc->name, val);\r\nval = read_status(fc, 2);\r\npr_debug("%s: HDLC 2 STA %x\n", fc->name, val);\r\n}\r\nstatic void\r\nreset_avm(struct fritzcard *fc)\r\n{\r\nswitch (fc->type) {\r\ncase AVM_FRITZ_PCI:\r\nfc->ctrlreg = AVM_STATUS0_RESET | AVM_STATUS0_DIS_TIMER;\r\nbreak;\r\ncase AVM_FRITZ_PCIV2:\r\nfc->ctrlreg = AVM_STATUS0_RESET;\r\nbreak;\r\n}\r\nif (debug & DEBUG_HW)\r\npr_notice("%s: reset\n", fc->name);\r\ndisable_hwirq(fc);\r\nmdelay(5);\r\nswitch (fc->type) {\r\ncase AVM_FRITZ_PCI:\r\nfc->ctrlreg = AVM_STATUS0_DIS_TIMER | AVM_STATUS0_RES_TIMER;\r\ndisable_hwirq(fc);\r\noutb(AVM_STATUS1_ENA_IOM, fc->addr + 3);\r\nbreak;\r\ncase AVM_FRITZ_PCIV2:\r\nfc->ctrlreg = 0;\r\ndisable_hwirq(fc);\r\nbreak;\r\n}\r\nmdelay(1);\r\nif (debug & DEBUG_HW)\r\npr_notice("%s: S0/S1 %x/%x\n", fc->name,\r\ninb(fc->addr + 2), inb(fc->addr + 3));\r\n}\r\nstatic int\r\ninit_card(struct fritzcard *fc)\r\n{\r\nint ret, cnt = 3;\r\nu_long flags;\r\nreset_avm(fc);\r\nif (fc->type == AVM_FRITZ_PCIV2)\r\nret = request_irq(fc->irq, avm_fritzv2_interrupt,\r\nIRQF_SHARED, fc->name, fc);\r\nelse\r\nret = request_irq(fc->irq, avm_fritz_interrupt,\r\nIRQF_SHARED, fc->name, fc);\r\nif (ret) {\r\npr_info("%s: couldn't get interrupt %d\n",\r\nfc->name, fc->irq);\r\nreturn ret;\r\n}\r\nwhile (cnt--) {\r\nspin_lock_irqsave(&fc->lock, flags);\r\nret = fc->isac.init(&fc->isac);\r\nif (ret) {\r\nspin_unlock_irqrestore(&fc->lock, flags);\r\npr_info("%s: ISAC init failed with %d\n",\r\nfc->name, ret);\r\nbreak;\r\n}\r\nclear_pending_hdlc_ints(fc);\r\ninithdlc(fc);\r\nenable_hwirq(fc);\r\nif (fc->type == AVM_FRITZ_PCIV2) {\r\nWriteISAC_V2(fc, ISACX_MASK, 0);\r\nWriteISAC_V2(fc, ISACX_CMDRD, 0x41);\r\n} else {\r\nWriteISAC_V1(fc, ISAC_MASK, 0);\r\nWriteISAC_V1(fc, ISAC_CMDR, 0x41);\r\n}\r\nspin_unlock_irqrestore(&fc->lock, flags);\r\nmsleep_interruptible(10);\r\nif (debug & DEBUG_HW)\r\npr_notice("%s: IRQ %d count %d\n", fc->name,\r\nfc->irq, fc->irqcnt);\r\nif (!fc->irqcnt) {\r\npr_info("%s: IRQ(%d) getting no IRQs during init %d\n",\r\nfc->name, fc->irq, 3 - cnt);\r\nreset_avm(fc);\r\n} else\r\nreturn 0;\r\n}\r\nfree_irq(fc->irq, fc);\r\nreturn -EIO;\r\n}\r\nstatic int\r\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\r\n{\r\nreturn mISDN_ctrl_bchannel(bch, cq);\r\n}\r\nstatic int\r\navm_bctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct fritzcard *fc = bch->hw;\r\nint ret = -EINVAL;\r\nu_long flags;\r\npr_debug("%s: %s cmd:%x %p\n", fc->name, __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase CLOSE_CHANNEL:\r\ntest_and_clear_bit(FLG_OPEN, &bch->Flags);\r\ncancel_work_sync(&bch->workq);\r\nspin_lock_irqsave(&fc->lock, flags);\r\nmISDN_clear_bchannel(bch);\r\nmodehdlc(bch, ISDN_P_NONE);\r\nspin_unlock_irqrestore(&fc->lock, flags);\r\nch->protocol = ISDN_P_NONE;\r\nch->peer = NULL;\r\nmodule_put(THIS_MODULE);\r\nret = 0;\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nret = channel_bctrl(bch, arg);\r\nbreak;\r\ndefault:\r\npr_info("%s: %s unknown prim(%x)\n", fc->name, __func__, cmd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nchannel_ctrl(struct fritzcard *fc, struct mISDN_ctrl_req *cq)\r\n{\r\nint ret = 0;\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\ncq->op = MISDN_CTRL_LOOP | MISDN_CTRL_L1_TIMER3;\r\nbreak;\r\ncase MISDN_CTRL_LOOP:\r\nif (cq->channel < 0 || cq->channel > 3) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = fc->isac.ctrl(&fc->isac, HW_TESTLOOP, cq->channel);\r\nbreak;\r\ncase MISDN_CTRL_L1_TIMER3:\r\nret = fc->isac.ctrl(&fc->isac, HW_TIMER3_VALUE, cq->p1);\r\nbreak;\r\ndefault:\r\npr_info("%s: %s unknown Op %x\n", fc->name, __func__, cq->op);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nopen_bchannel(struct fritzcard *fc, struct channel_req *rq)\r\n{\r\nstruct bchannel *bch;\r\nif (rq->adr.channel == 0 || rq->adr.channel > 2)\r\nreturn -EINVAL;\r\nif (rq->protocol == ISDN_P_NONE)\r\nreturn -EINVAL;\r\nbch = &fc->bch[rq->adr.channel - 1];\r\nif (test_and_set_bit(FLG_OPEN, &bch->Flags))\r\nreturn -EBUSY;\r\nbch->ch.protocol = rq->protocol;\r\nrq->ch = &bch->ch;\r\nreturn 0;\r\n}\r\nstatic int\r\navm_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct fritzcard *fc = dch->hw;\r\nstruct channel_req *rq;\r\nint err = 0;\r\npr_debug("%s: %s cmd:%x %p\n", fc->name, __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase OPEN_CHANNEL:\r\nrq = arg;\r\nif (rq->protocol == ISDN_P_TE_S0)\r\nerr = fc->isac.open(&fc->isac, rq);\r\nelse\r\nerr = open_bchannel(fc, rq);\r\nif (err)\r\nbreak;\r\nif (!try_module_get(THIS_MODULE))\r\npr_info("%s: cannot get module\n", fc->name);\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\npr_debug("%s: dev(%d) close from %p\n", fc->name, dch->dev.id,\r\n__builtin_return_address(0));\r\nmodule_put(THIS_MODULE);\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nerr = channel_ctrl(fc, arg);\r\nbreak;\r\ndefault:\r\npr_debug("%s: %s unknown command %x\n",\r\nfc->name, __func__, cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nint\r\nsetup_fritz(struct fritzcard *fc)\r\n{\r\nu32 val, ver;\r\nif (!request_region(fc->addr, 32, fc->name)) {\r\npr_info("%s: AVM config port %x-%x already in use\n",\r\nfc->name, fc->addr, fc->addr + 31);\r\nreturn -EIO;\r\n}\r\nswitch (fc->type) {\r\ncase AVM_FRITZ_PCI:\r\nval = inl(fc->addr);\r\noutl(AVM_HDLC_1, fc->addr + CHIP_INDEX);\r\nver = inl(fc->addr + CHIP_WINDOW + HDLC_STATUS) >> 24;\r\nif (debug & DEBUG_HW) {\r\npr_notice("%s: PCI stat %#x\n", fc->name, val);\r\npr_notice("%s: PCI Class %X Rev %d\n", fc->name,\r\nval & 0xff, (val >> 8) & 0xff);\r\npr_notice("%s: HDLC version %x\n", fc->name, ver & 0xf);\r\n}\r\nASSIGN_FUNC(V1, ISAC, fc->isac);\r\nfc->isac.type = IPAC_TYPE_ISAC;\r\nbreak;\r\ncase AVM_FRITZ_PCIV2:\r\nval = inl(fc->addr);\r\nver = inl(fc->addr + AVM_HDLC_STATUS_1) >> 24;\r\nif (debug & DEBUG_HW) {\r\npr_notice("%s: PCI V2 stat %#x\n", fc->name, val);\r\npr_notice("%s: PCI V2 Class %X Rev %d\n", fc->name,\r\nval & 0xff, (val >> 8) & 0xff);\r\npr_notice("%s: HDLC version %x\n", fc->name, ver & 0xf);\r\n}\r\nASSIGN_FUNC(V2, ISAC, fc->isac);\r\nfc->isac.type = IPAC_TYPE_ISACX;\r\nbreak;\r\ndefault:\r\nrelease_region(fc->addr, 32);\r\npr_info("%s: AVM unknown type %d\n", fc->name, fc->type);\r\nreturn -ENODEV;\r\n}\r\npr_notice("%s: %s config irq:%d base:0x%X\n", fc->name,\r\n(fc->type == AVM_FRITZ_PCI) ? "AVM Fritz!CARD PCI" :\r\n"AVM Fritz!CARD PCIv2", fc->irq, fc->addr);\r\nreturn 0;\r\n}\r\nstatic void\r\nrelease_card(struct fritzcard *card)\r\n{\r\nu_long flags;\r\ndisable_hwirq(card);\r\nspin_lock_irqsave(&card->lock, flags);\r\nmodehdlc(&card->bch[0], ISDN_P_NONE);\r\nmodehdlc(&card->bch[1], ISDN_P_NONE);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncard->isac.release(&card->isac);\r\nfree_irq(card->irq, card);\r\nmISDN_freebchannel(&card->bch[1]);\r\nmISDN_freebchannel(&card->bch[0]);\r\nmISDN_unregister_device(&card->isac.dch.dev);\r\nrelease_region(card->addr, 32);\r\npci_disable_device(card->pdev);\r\npci_set_drvdata(card->pdev, NULL);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_del(&card->list);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\nkfree(card);\r\nAVM_cnt--;\r\n}\r\nstatic int __devinit\r\nsetup_instance(struct fritzcard *card)\r\n{\r\nint i, err;\r\nunsigned short minsize;\r\nu_long flags;\r\nsnprintf(card->name, MISDN_MAX_IDLEN - 1, "AVM.%d", AVM_cnt + 1);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_add_tail(&card->list, &Cards);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\n_set_debug(card);\r\ncard->isac.name = card->name;\r\nspin_lock_init(&card->lock);\r\ncard->isac.hwlock = &card->lock;\r\nmISDNisac_init(&card->isac, card);\r\ncard->isac.dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\r\n(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\r\ncard->isac.dch.dev.D.ctrl = avm_dctrl;\r\nfor (i = 0; i < 2; i++) {\r\ncard->bch[i].nr = i + 1;\r\nset_channelmap(i + 1, card->isac.dch.dev.channelmap);\r\nif (AVM_FRITZ_PCIV2 == card->type)\r\nminsize = HDLC_FIFO_SIZE_V2;\r\nelse\r\nminsize = HDLC_FIFO_SIZE_V1;\r\nmISDN_initbchannel(&card->bch[i], MAX_DATA_MEM, minsize);\r\ncard->bch[i].hw = card;\r\ncard->bch[i].ch.send = avm_l2l1B;\r\ncard->bch[i].ch.ctrl = avm_bctrl;\r\ncard->bch[i].ch.nr = i + 1;\r\nlist_add(&card->bch[i].ch.list, &card->isac.dch.dev.bchannels);\r\n}\r\nerr = setup_fritz(card);\r\nif (err)\r\ngoto error;\r\nerr = mISDN_register_device(&card->isac.dch.dev, &card->pdev->dev,\r\ncard->name);\r\nif (err)\r\ngoto error_reg;\r\nerr = init_card(card);\r\nif (!err) {\r\nAVM_cnt++;\r\npr_notice("AVM %d cards installed DEBUG\n", AVM_cnt);\r\nreturn 0;\r\n}\r\nmISDN_unregister_device(&card->isac.dch.dev);\r\nerror_reg:\r\nrelease_region(card->addr, 32);\r\nerror:\r\ncard->isac.release(&card->isac);\r\nmISDN_freebchannel(&card->bch[1]);\r\nmISDN_freebchannel(&card->bch[0]);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_del(&card->list);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\nkfree(card);\r\nreturn err;\r\n}\r\nstatic int __devinit\r\nfritzpci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint err = -ENOMEM;\r\nstruct fritzcard *card;\r\ncard = kzalloc(sizeof(struct fritzcard), GFP_KERNEL);\r\nif (!card) {\r\npr_info("No kmem for fritzcard\n");\r\nreturn err;\r\n}\r\nif (pdev->device == PCI_DEVICE_ID_AVM_A1_V2)\r\ncard->type = AVM_FRITZ_PCIV2;\r\nelse\r\ncard->type = AVM_FRITZ_PCI;\r\ncard->pdev = pdev;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nkfree(card);\r\nreturn err;\r\n}\r\npr_notice("mISDN: found adapter %s at %s\n",\r\n(char *) ent->driver_data, pci_name(pdev));\r\ncard->addr = pci_resource_start(pdev, 1);\r\ncard->irq = pdev->irq;\r\npci_set_drvdata(pdev, card);\r\nerr = setup_instance(card);\r\nif (err)\r\npci_set_drvdata(pdev, NULL);\r\nreturn err;\r\n}\r\nstatic void __devexit\r\nfritz_remove_pci(struct pci_dev *pdev)\r\n{\r\nstruct fritzcard *card = pci_get_drvdata(pdev);\r\nif (card)\r\nrelease_card(card);\r\nelse\r\nif (debug)\r\npr_info("%s: drvdata already removed\n", __func__);\r\n}\r\nstatic int __init AVM_init(void)\r\n{\r\nint err;\r\npr_notice("AVM Fritz PCI driver Rev. %s\n", AVMFRITZ_REV);\r\nerr = pci_register_driver(&fcpci_driver);\r\nreturn err;\r\n}\r\nstatic void __exit AVM_cleanup(void)\r\n{\r\npci_unregister_driver(&fcpci_driver);\r\n}
