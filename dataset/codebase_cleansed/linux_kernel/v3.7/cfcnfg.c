struct cfcnfg *cfcnfg_create(void)\r\n{\r\nstruct cfcnfg *this;\r\nstruct cfctrl_rsp *resp;\r\nmight_sleep();\r\nthis = kzalloc(sizeof(struct cfcnfg), GFP_ATOMIC);\r\nif (!this)\r\nreturn NULL;\r\nthis->mux = cfmuxl_create();\r\nif (!this->mux)\r\ngoto out_of_mem;\r\nthis->ctrl = cfctrl_create();\r\nif (!this->ctrl)\r\ngoto out_of_mem;\r\nresp = cfctrl_get_respfuncs(this->ctrl);\r\nresp->enum_rsp = cfctrl_enum_resp;\r\nresp->linkerror_ind = cfctrl_resp_func;\r\nresp->linkdestroy_rsp = cfcnfg_linkdestroy_rsp;\r\nresp->sleep_rsp = cfctrl_resp_func;\r\nresp->wake_rsp = cfctrl_resp_func;\r\nresp->restart_rsp = cfctrl_resp_func;\r\nresp->radioset_rsp = cfctrl_resp_func;\r\nresp->linksetup_rsp = cfcnfg_linkup_rsp;\r\nresp->reject_rsp = cfcnfg_reject_rsp;\r\nINIT_LIST_HEAD(&this->phys);\r\ncfmuxl_set_uplayer(this->mux, this->ctrl, 0);\r\nlayer_set_dn(this->ctrl, this->mux);\r\nlayer_set_up(this->ctrl, this);\r\nmutex_init(&this->lock);\r\nreturn this;\r\nout_of_mem:\r\nsynchronize_rcu();\r\nkfree(this->mux);\r\nkfree(this->ctrl);\r\nkfree(this);\r\nreturn NULL;\r\n}\r\nvoid cfcnfg_remove(struct cfcnfg *cfg)\r\n{\r\nmight_sleep();\r\nif (cfg) {\r\nsynchronize_rcu();\r\nkfree(cfg->mux);\r\ncfctrl_remove(cfg->ctrl);\r\nkfree(cfg);\r\n}\r\n}\r\nstatic void cfctrl_resp_func(void)\r\n{\r\n}\r\nstatic struct cfcnfg_phyinfo *cfcnfg_get_phyinfo_rcu(struct cfcnfg *cnfg,\r\nu8 phyid)\r\n{\r\nstruct cfcnfg_phyinfo *phy;\r\nlist_for_each_entry_rcu(phy, &cnfg->phys, node)\r\nif (phy->id == phyid)\r\nreturn phy;\r\nreturn NULL;\r\n}\r\nstatic void cfctrl_enum_resp(void)\r\n{\r\n}\r\nstatic struct dev_info *cfcnfg_get_phyid(struct cfcnfg *cnfg,\r\nenum cfcnfg_phy_preference phy_pref)\r\n{\r\nstruct cfcnfg_phyinfo *phy;\r\nlist_for_each_entry_rcu(phy, &cnfg->phys, node) {\r\nif (phy->up && phy->pref == phy_pref &&\r\nphy->frm_layer != NULL)\r\nreturn &phy->dev_info;\r\n}\r\nlist_for_each_entry_rcu(phy, &cnfg->phys, node)\r\nif (phy->up)\r\nreturn &phy->dev_info;\r\nreturn NULL;\r\n}\r\nstatic int cfcnfg_get_id_from_ifi(struct cfcnfg *cnfg, int ifi)\r\n{\r\nstruct cfcnfg_phyinfo *phy;\r\nlist_for_each_entry_rcu(phy, &cnfg->phys, node)\r\nif (phy->ifindex == ifi && phy->up)\r\nreturn phy->id;\r\nreturn -ENODEV;\r\n}\r\nint caif_disconnect_client(struct net *net, struct cflayer *adap_layer)\r\n{\r\nu8 channel_id;\r\nstruct cfcnfg *cfg = get_cfcnfg(net);\r\ncaif_assert(adap_layer != NULL);\r\ncfctrl_cancel_req(cfg->ctrl, adap_layer);\r\nchannel_id = adap_layer->id;\r\nif (channel_id != 0) {\r\nstruct cflayer *servl;\r\nservl = cfmuxl_remove_uplayer(cfg->mux, channel_id);\r\ncfctrl_linkdown_req(cfg->ctrl, channel_id, adap_layer);\r\nif (servl != NULL)\r\nlayer_set_up(servl, NULL);\r\n} else\r\npr_debug("nothing to disconnect\n");\r\nsynchronize_rcu();\r\nif (adap_layer->ctrlcmd != NULL)\r\nadap_layer->ctrlcmd(adap_layer, CAIF_CTRLCMD_DEINIT_RSP, 0);\r\nreturn 0;\r\n}\r\nstatic void cfcnfg_linkdestroy_rsp(struct cflayer *layer, u8 channel_id)\r\n{\r\n}\r\nstatic int caif_connect_req_to_link_param(struct cfcnfg *cnfg,\r\nstruct caif_connect_request *s,\r\nstruct cfctrl_link_param *l)\r\n{\r\nstruct dev_info *dev_info;\r\nenum cfcnfg_phy_preference pref;\r\nint res;\r\nmemset(l, 0, sizeof(*l));\r\nl->priority = CAIF_PRIO_MAX - s->priority + 1;\r\nif (s->ifindex != 0) {\r\nres = cfcnfg_get_id_from_ifi(cnfg, s->ifindex);\r\nif (res < 0)\r\nreturn res;\r\nl->phyid = res;\r\n} else {\r\nswitch (s->link_selector) {\r\ncase CAIF_LINK_HIGH_BANDW:\r\npref = CFPHYPREF_HIGH_BW;\r\nbreak;\r\ncase CAIF_LINK_LOW_LATENCY:\r\npref = CFPHYPREF_LOW_LAT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_info = cfcnfg_get_phyid(cnfg, pref);\r\nif (dev_info == NULL)\r\nreturn -ENODEV;\r\nl->phyid = dev_info->id;\r\n}\r\nswitch (s->protocol) {\r\ncase CAIFPROTO_AT:\r\nl->linktype = CFCTRL_SRV_VEI;\r\nl->endpoint = (s->sockaddr.u.at.type >> 2) & 0x3;\r\nl->chtype = s->sockaddr.u.at.type & 0x3;\r\nbreak;\r\ncase CAIFPROTO_DATAGRAM:\r\nl->linktype = CFCTRL_SRV_DATAGRAM;\r\nl->chtype = 0x00;\r\nl->u.datagram.connid = s->sockaddr.u.dgm.connection_id;\r\nbreak;\r\ncase CAIFPROTO_DATAGRAM_LOOP:\r\nl->linktype = CFCTRL_SRV_DATAGRAM;\r\nl->chtype = 0x03;\r\nl->endpoint = 0x00;\r\nl->u.datagram.connid = s->sockaddr.u.dgm.connection_id;\r\nbreak;\r\ncase CAIFPROTO_RFM:\r\nl->linktype = CFCTRL_SRV_RFM;\r\nl->u.datagram.connid = s->sockaddr.u.rfm.connection_id;\r\nstrncpy(l->u.rfm.volume, s->sockaddr.u.rfm.volume,\r\nsizeof(l->u.rfm.volume)-1);\r\nl->u.rfm.volume[sizeof(l->u.rfm.volume)-1] = 0;\r\nbreak;\r\ncase CAIFPROTO_UTIL:\r\nl->linktype = CFCTRL_SRV_UTIL;\r\nl->endpoint = 0x00;\r\nl->chtype = 0x00;\r\nstrncpy(l->u.utility.name, s->sockaddr.u.util.service,\r\nsizeof(l->u.utility.name)-1);\r\nl->u.utility.name[sizeof(l->u.utility.name)-1] = 0;\r\ncaif_assert(sizeof(l->u.utility.name) > 10);\r\nl->u.utility.paramlen = s->param.size;\r\nif (l->u.utility.paramlen > sizeof(l->u.utility.params))\r\nl->u.utility.paramlen = sizeof(l->u.utility.params);\r\nmemcpy(l->u.utility.params, s->param.data,\r\nl->u.utility.paramlen);\r\nbreak;\r\ncase CAIFPROTO_DEBUG:\r\nl->linktype = CFCTRL_SRV_DBG;\r\nl->endpoint = s->sockaddr.u.dbg.service;\r\nl->chtype = s->sockaddr.u.dbg.type;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint caif_connect_client(struct net *net, struct caif_connect_request *conn_req,\r\nstruct cflayer *adap_layer, int *ifindex,\r\nint *proto_head,\r\nint *proto_tail)\r\n{\r\nstruct cflayer *frml;\r\nstruct cfcnfg_phyinfo *phy;\r\nint err;\r\nstruct cfctrl_link_param param;\r\nstruct cfcnfg *cfg = get_cfcnfg(net);\r\nrcu_read_lock();\r\nerr = caif_connect_req_to_link_param(cfg, conn_req, &param);\r\nif (err)\r\ngoto unlock;\r\nphy = cfcnfg_get_phyinfo_rcu(cfg, param.phyid);\r\nif (!phy) {\r\nerr = -ENODEV;\r\ngoto unlock;\r\n}\r\nerr = -EINVAL;\r\nif (adap_layer == NULL) {\r\npr_err("adap_layer is zero\n");\r\ngoto unlock;\r\n}\r\nif (adap_layer->receive == NULL) {\r\npr_err("adap_layer->receive is NULL\n");\r\ngoto unlock;\r\n}\r\nif (adap_layer->ctrlcmd == NULL) {\r\npr_err("adap_layer->ctrlcmd == NULL\n");\r\ngoto unlock;\r\n}\r\nerr = -ENODEV;\r\nfrml = phy->frm_layer;\r\nif (frml == NULL) {\r\npr_err("Specified PHY type does not exist!\n");\r\ngoto unlock;\r\n}\r\ncaif_assert(param.phyid == phy->id);\r\ncaif_assert(phy->frm_layer->id ==\r\nparam.phyid);\r\ncaif_assert(phy->phy_layer->id ==\r\nparam.phyid);\r\n*ifindex = phy->ifindex;\r\n*proto_tail = 2;\r\n*proto_head = protohead[param.linktype] + phy->head_room;\r\nrcu_read_unlock();\r\ncfctrl_enum_req(cfg->ctrl, param.phyid);\r\nreturn cfctrl_linkup_request(cfg->ctrl, &param, adap_layer);\r\nunlock:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic void cfcnfg_reject_rsp(struct cflayer *layer, u8 channel_id,\r\nstruct cflayer *adapt_layer)\r\n{\r\nif (adapt_layer != NULL && adapt_layer->ctrlcmd != NULL)\r\nadapt_layer->ctrlcmd(adapt_layer,\r\nCAIF_CTRLCMD_INIT_FAIL_RSP, 0);\r\n}\r\nstatic void\r\ncfcnfg_linkup_rsp(struct cflayer *layer, u8 channel_id, enum cfctrl_srv serv,\r\nu8 phyid, struct cflayer *adapt_layer)\r\n{\r\nstruct cfcnfg *cnfg = container_obj(layer);\r\nstruct cflayer *servicel = NULL;\r\nstruct cfcnfg_phyinfo *phyinfo;\r\nstruct net_device *netdev;\r\nif (channel_id == 0) {\r\npr_warn("received channel_id zero\n");\r\nif (adapt_layer != NULL && adapt_layer->ctrlcmd != NULL)\r\nadapt_layer->ctrlcmd(adapt_layer,\r\nCAIF_CTRLCMD_INIT_FAIL_RSP, 0);\r\nreturn;\r\n}\r\nrcu_read_lock();\r\nif (adapt_layer == NULL) {\r\npr_debug("link setup response but no client exist,"\r\n"send linkdown back\n");\r\ncfctrl_linkdown_req(cnfg->ctrl, channel_id, NULL);\r\ngoto unlock;\r\n}\r\ncaif_assert(cnfg != NULL);\r\ncaif_assert(phyid != 0);\r\nphyinfo = cfcnfg_get_phyinfo_rcu(cnfg, phyid);\r\nif (phyinfo == NULL) {\r\npr_err("ERROR: Link Layer Device dissapeared"\r\n"while connecting\n");\r\ngoto unlock;\r\n}\r\ncaif_assert(phyinfo != NULL);\r\ncaif_assert(phyinfo->id == phyid);\r\ncaif_assert(phyinfo->phy_layer != NULL);\r\ncaif_assert(phyinfo->phy_layer->id == phyid);\r\nadapt_layer->id = channel_id;\r\nswitch (serv) {\r\ncase CFCTRL_SRV_VEI:\r\nservicel = cfvei_create(channel_id, &phyinfo->dev_info);\r\nbreak;\r\ncase CFCTRL_SRV_DATAGRAM:\r\nservicel = cfdgml_create(channel_id,\r\n&phyinfo->dev_info);\r\nbreak;\r\ncase CFCTRL_SRV_RFM:\r\nnetdev = phyinfo->dev_info.dev;\r\nservicel = cfrfml_create(channel_id, &phyinfo->dev_info,\r\nnetdev->mtu);\r\nbreak;\r\ncase CFCTRL_SRV_UTIL:\r\nservicel = cfutill_create(channel_id, &phyinfo->dev_info);\r\nbreak;\r\ncase CFCTRL_SRV_VIDEO:\r\nservicel = cfvidl_create(channel_id, &phyinfo->dev_info);\r\nbreak;\r\ncase CFCTRL_SRV_DBG:\r\nservicel = cfdbgl_create(channel_id, &phyinfo->dev_info);\r\nbreak;\r\ndefault:\r\npr_err("Protocol error. Link setup response "\r\n"- unknown channel type\n");\r\ngoto unlock;\r\n}\r\nif (!servicel)\r\ngoto unlock;\r\nlayer_set_dn(servicel, cnfg->mux);\r\ncfmuxl_set_uplayer(cnfg->mux, servicel, channel_id);\r\nlayer_set_up(servicel, adapt_layer);\r\nlayer_set_dn(adapt_layer, servicel);\r\nrcu_read_unlock();\r\nservicel->ctrlcmd(servicel, CAIF_CTRLCMD_INIT_RSP, 0);\r\nreturn;\r\nunlock:\r\nrcu_read_unlock();\r\n}\r\nvoid\r\ncfcnfg_add_phy_layer(struct cfcnfg *cnfg,\r\nstruct net_device *dev, struct cflayer *phy_layer,\r\nenum cfcnfg_phy_preference pref,\r\nstruct cflayer *link_support,\r\nbool fcs, int head_room)\r\n{\r\nstruct cflayer *frml;\r\nstruct cfcnfg_phyinfo *phyinfo = NULL;\r\nint i;\r\nu8 phyid;\r\nmutex_lock(&cnfg->lock);\r\nfor (i = 0; i < 7; i++) {\r\nphyid = (dev->ifindex + i) & 0x7;\r\nif (phyid == 0)\r\ncontinue;\r\nif (cfcnfg_get_phyinfo_rcu(cnfg, phyid) == NULL)\r\ngoto got_phyid;\r\n}\r\npr_warn("Too many CAIF Link Layers (max 6)\n");\r\ngoto out;\r\ngot_phyid:\r\nphyinfo = kzalloc(sizeof(struct cfcnfg_phyinfo), GFP_ATOMIC);\r\nif (!phyinfo)\r\ngoto out_err;\r\nphy_layer->id = phyid;\r\nphyinfo->pref = pref;\r\nphyinfo->id = phyid;\r\nphyinfo->dev_info.id = phyid;\r\nphyinfo->dev_info.dev = dev;\r\nphyinfo->phy_layer = phy_layer;\r\nphyinfo->ifindex = dev->ifindex;\r\nphyinfo->head_room = head_room;\r\nphyinfo->use_fcs = fcs;\r\nfrml = cffrml_create(phyid, fcs);\r\nif (!frml)\r\ngoto out_err;\r\nphyinfo->frm_layer = frml;\r\nlayer_set_up(frml, cnfg->mux);\r\nif (link_support != NULL) {\r\nlink_support->id = phyid;\r\nlayer_set_dn(frml, link_support);\r\nlayer_set_up(link_support, frml);\r\nlayer_set_dn(link_support, phy_layer);\r\nlayer_set_up(phy_layer, link_support);\r\n} else {\r\nlayer_set_dn(frml, phy_layer);\r\nlayer_set_up(phy_layer, frml);\r\n}\r\nlist_add_rcu(&phyinfo->node, &cnfg->phys);\r\nout:\r\nmutex_unlock(&cnfg->lock);\r\nreturn;\r\nout_err:\r\nkfree(phyinfo);\r\nmutex_unlock(&cnfg->lock);\r\n}\r\nint cfcnfg_set_phy_state(struct cfcnfg *cnfg, struct cflayer *phy_layer,\r\nbool up)\r\n{\r\nstruct cfcnfg_phyinfo *phyinfo;\r\nrcu_read_lock();\r\nphyinfo = cfcnfg_get_phyinfo_rcu(cnfg, phy_layer->id);\r\nif (phyinfo == NULL) {\r\nrcu_read_unlock();\r\nreturn -ENODEV;\r\n}\r\nif (phyinfo->up == up) {\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nphyinfo->up = up;\r\nif (up) {\r\ncffrml_hold(phyinfo->frm_layer);\r\ncfmuxl_set_dnlayer(cnfg->mux, phyinfo->frm_layer,\r\nphy_layer->id);\r\n} else {\r\ncfmuxl_remove_dnlayer(cnfg->mux, phy_layer->id);\r\ncffrml_put(phyinfo->frm_layer);\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nint cfcnfg_del_phy_layer(struct cfcnfg *cnfg, struct cflayer *phy_layer)\r\n{\r\nstruct cflayer *frml, *frml_dn;\r\nu16 phyid;\r\nstruct cfcnfg_phyinfo *phyinfo;\r\nmight_sleep();\r\nmutex_lock(&cnfg->lock);\r\nphyid = phy_layer->id;\r\nphyinfo = cfcnfg_get_phyinfo_rcu(cnfg, phyid);\r\nif (phyinfo == NULL) {\r\nmutex_unlock(&cnfg->lock);\r\nreturn 0;\r\n}\r\ncaif_assert(phyid == phyinfo->id);\r\ncaif_assert(phy_layer == phyinfo->phy_layer);\r\ncaif_assert(phy_layer->id == phyid);\r\ncaif_assert(phyinfo->frm_layer->id == phyid);\r\nlist_del_rcu(&phyinfo->node);\r\nsynchronize_rcu();\r\nif (cffrml_refcnt_read(phyinfo->frm_layer) != 0) {\r\npr_info("Wait for device inuse\n");\r\nlist_add_rcu(&phyinfo->node, &cnfg->phys);\r\nmutex_unlock(&cnfg->lock);\r\nreturn -EAGAIN;\r\n}\r\nfrml = phyinfo->frm_layer;\r\nfrml_dn = frml->dn;\r\ncffrml_set_uplayer(frml, NULL);\r\ncffrml_set_dnlayer(frml, NULL);\r\nif (phy_layer != frml_dn) {\r\nlayer_set_up(frml_dn, NULL);\r\nlayer_set_dn(frml_dn, NULL);\r\n}\r\nlayer_set_up(phy_layer, NULL);\r\nif (phyinfo->phy_layer != frml_dn)\r\nkfree(frml_dn);\r\ncffrml_free(frml);\r\nkfree(phyinfo);\r\nmutex_unlock(&cnfg->lock);\r\nreturn 0;\r\n}
