int __devinit pm80x_init(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pm80x_chip *chip;\r\nstruct regmap *map;\r\nint ret = 0;\r\nchip =\r\ndevm_kzalloc(&client->dev, sizeof(struct pm80x_chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nmap = devm_regmap_init_i2c(client, &pm80x_regmap_config);\r\nif (IS_ERR(map)) {\r\nret = PTR_ERR(map);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nret);\r\ngoto err_regmap_init;\r\n}\r\nchip->id = id->driver_data;\r\nif (chip->id < CHIP_PM800 || chip->id > CHIP_PM805) {\r\nret = -EINVAL;\r\ngoto err_chip_id;\r\n}\r\nchip->client = client;\r\nchip->regmap = map;\r\nchip->irq = client->irq;\r\nchip->dev = &client->dev;\r\ndev_set_drvdata(chip->dev, chip);\r\ni2c_set_clientdata(chip->client, chip);\r\ndevice_init_wakeup(&client->dev, 1);\r\nif (!g_pm80x_chip)\r\ng_pm80x_chip = chip;\r\nelse {\r\nchip->companion = g_pm80x_chip->client;\r\ng_pm80x_chip->companion = chip->client;\r\n}\r\nreturn 0;\r\nerr_chip_id:\r\nregmap_exit(map);\r\nerr_regmap_init:\r\ndevm_kfree(&client->dev, chip);\r\nreturn ret;\r\n}\r\nint pm80x_deinit(struct i2c_client *client)\r\n{\r\nstruct pm80x_chip *chip = i2c_get_clientdata(client);\r\nif (g_pm80x_chip->companion)\r\ng_pm80x_chip->companion = NULL;\r\nelse\r\ng_pm80x_chip = NULL;\r\nregmap_exit(chip->regmap);\r\ndevm_kfree(&client->dev, chip);\r\nreturn 0;\r\n}\r\nstatic int pm80x_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct pm80x_chip *chip = i2c_get_clientdata(client);\r\nif (chip && chip->wu_flag)\r\nif (device_may_wakeup(chip->dev))\r\nenable_irq_wake(chip->irq);\r\nreturn 0;\r\n}\r\nstatic int pm80x_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct pm80x_chip *chip = i2c_get_clientdata(client);\r\nif (chip && chip->wu_flag)\r\nif (device_may_wakeup(chip->dev))\r\ndisable_irq_wake(chip->irq);\r\nreturn 0;\r\n}
