int __init irlap_init(void)\r\n{\r\nIRDA_ASSERT(sizeof(struct xid_frame) == 14, ;);\r\nIRDA_ASSERT(sizeof(struct test_frame) == 10, ;);\r\nIRDA_ASSERT(sizeof(struct ua_frame) == 10, ;);\r\nIRDA_ASSERT(sizeof(struct snrm_frame) == 11, ;);\r\nirlap = hashbin_new(HB_LOCK);\r\nif (irlap == NULL) {\r\nIRDA_ERROR("%s: can't allocate irlap hashbin!\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid irlap_cleanup(void)\r\n{\r\nIRDA_ASSERT(irlap != NULL, return;);\r\nhashbin_delete(irlap, (FREE_FUNC) __irlap_close);\r\n}\r\nstruct irlap_cb *irlap_open(struct net_device *dev, struct qos_info *qos,\r\nconst char *hw_name)\r\n{\r\nstruct irlap_cb *self;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nself = kzalloc(sizeof(struct irlap_cb), GFP_KERNEL);\r\nif (self == NULL)\r\nreturn NULL;\r\nself->magic = LAP_MAGIC;\r\nself->netdev = dev;\r\nself->qos_dev = qos;\r\nif(hw_name != NULL) {\r\nstrlcpy(self->hw_name, hw_name, sizeof(self->hw_name));\r\n} else {\r\nself->hw_name[0] = '\0';\r\n}\r\ndev->atalk_ptr = self;\r\nself->state = LAP_OFFLINE;\r\nskb_queue_head_init(&self->txq);\r\nskb_queue_head_init(&self->txq_ultra);\r\nskb_queue_head_init(&self->wx_list);\r\ndo {\r\nget_random_bytes(&self->saddr, sizeof(self->saddr));\r\n} while ((self->saddr == 0x0) || (self->saddr == BROADCAST) ||\r\n(hashbin_lock_find(irlap, self->saddr, NULL)) );\r\nmemcpy(dev->dev_addr, &self->saddr, 4);\r\ninit_timer(&self->slot_timer);\r\ninit_timer(&self->query_timer);\r\ninit_timer(&self->discovery_timer);\r\ninit_timer(&self->final_timer);\r\ninit_timer(&self->poll_timer);\r\ninit_timer(&self->wd_timer);\r\ninit_timer(&self->backoff_timer);\r\ninit_timer(&self->media_busy_timer);\r\nirlap_apply_default_connection_parameters(self);\r\nself->N3 = 3;\r\nself->state = LAP_NDM;\r\nhashbin_insert(irlap, (irda_queue_t *) self, self->saddr, NULL);\r\nirlmp_register_link(self, self->saddr, &self->notify);\r\nreturn self;\r\n}\r\nstatic void __irlap_close(struct irlap_cb *self)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\ndel_timer(&self->slot_timer);\r\ndel_timer(&self->query_timer);\r\ndel_timer(&self->discovery_timer);\r\ndel_timer(&self->final_timer);\r\ndel_timer(&self->poll_timer);\r\ndel_timer(&self->wd_timer);\r\ndel_timer(&self->backoff_timer);\r\ndel_timer(&self->media_busy_timer);\r\nirlap_flush_all_queues(self);\r\nself->magic = 0;\r\nkfree(self);\r\n}\r\nvoid irlap_close(struct irlap_cb *self)\r\n{\r\nstruct irlap_cb *lap;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nirlmp_unregister_link(self->saddr);\r\nself->notify.instance = NULL;\r\nlap = hashbin_remove(irlap, self->saddr, NULL);\r\nif (!lap) {\r\nIRDA_DEBUG(1, "%s(), Didn't find myself!\n", __func__);\r\nreturn;\r\n}\r\n__irlap_close(lap);\r\n}\r\nvoid irlap_connect_indication(struct irlap_cb *self, struct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nirlap_init_qos_capabilities(self, NULL);\r\nirlmp_link_connect_indication(self->notify.instance, self->saddr,\r\nself->daddr, &self->qos_tx, skb);\r\n}\r\nvoid irlap_connect_response(struct irlap_cb *self, struct sk_buff *userdata)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nirlap_do_event(self, CONNECT_RESPONSE, userdata, NULL);\r\n}\r\nvoid irlap_connect_request(struct irlap_cb *self, __u32 daddr,\r\nstruct qos_info *qos_user, int sniff)\r\n{\r\nIRDA_DEBUG(3, "%s(), daddr=0x%08x\n", __func__, daddr);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nself->daddr = daddr;\r\nirlap_init_qos_capabilities(self, qos_user);\r\nif ((self->state == LAP_NDM) && !self->media_busy)\r\nirlap_do_event(self, CONNECT_REQUEST, NULL, NULL);\r\nelse\r\nself->connect_pending = TRUE;\r\n}\r\nvoid irlap_connect_confirm(struct irlap_cb *self, struct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nirlmp_link_connect_confirm(self->notify.instance, &self->qos_tx, skb);\r\n}\r\nvoid irlap_data_indication(struct irlap_cb *self, struct sk_buff *skb,\r\nint unreliable)\r\n{\r\nskb_pull(skb, LAP_ADDR_HEADER+LAP_CTRL_HEADER);\r\nirlmp_link_data_indication(self->notify.instance, skb, unreliable);\r\n}\r\nvoid irlap_data_request(struct irlap_cb *self, struct sk_buff *skb,\r\nint unreliable)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nIRDA_DEBUG(3, "%s()\n", __func__);\r\nIRDA_ASSERT(skb_headroom(skb) >= (LAP_ADDR_HEADER+LAP_CTRL_HEADER),\r\nreturn;);\r\nskb_push(skb, LAP_ADDR_HEADER+LAP_CTRL_HEADER);\r\nif (unreliable)\r\nskb->data[1] = UI_FRAME;\r\nelse\r\nskb->data[1] = I_FRAME;\r\nskb_get(skb);\r\nskb_queue_tail(&self->txq, skb);\r\nif ((self->state == LAP_XMIT_P) || (self->state == LAP_XMIT_S)) {\r\nif((skb_queue_len(&self->txq) <= 1) && (!self->local_busy))\r\nirlap_do_event(self, DATA_REQUEST, skb, NULL);\r\n}\r\n}\r\nvoid irlap_unitdata_request(struct irlap_cb *self, struct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nIRDA_DEBUG(3, "%s()\n", __func__);\r\nIRDA_ASSERT(skb_headroom(skb) >= (LAP_ADDR_HEADER+LAP_CTRL_HEADER),\r\nreturn;);\r\nskb_push(skb, LAP_ADDR_HEADER+LAP_CTRL_HEADER);\r\nskb->data[0] = CBROADCAST;\r\nskb->data[1] = UI_FRAME;\r\nskb_queue_tail(&self->txq_ultra, skb);\r\nirlap_do_event(self, SEND_UI_FRAME, NULL, NULL);\r\n}\r\nvoid irlap_unitdata_indication(struct irlap_cb *self, struct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(1, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nskb_pull(skb, LAP_ADDR_HEADER+LAP_CTRL_HEADER);\r\nirlmp_link_unitdata_indication(self->notify.instance, skb);\r\n}\r\nvoid irlap_disconnect_request(struct irlap_cb *self)\r\n{\r\nIRDA_DEBUG(3, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nif (!skb_queue_empty(&self->txq)) {\r\nself->disconnect_pending = TRUE;\r\nreturn;\r\n}\r\nswitch (self->state) {\r\ncase LAP_XMIT_P:\r\ncase LAP_XMIT_S:\r\ncase LAP_CONN:\r\ncase LAP_RESET_WAIT:\r\ncase LAP_RESET_CHECK:\r\nirlap_do_event(self, DISCONNECT_REQUEST, NULL, NULL);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(2, "%s(), disconnect pending!\n", __func__);\r\nself->disconnect_pending = TRUE;\r\nbreak;\r\n}\r\n}\r\nvoid irlap_disconnect_indication(struct irlap_cb *self, LAP_REASON reason)\r\n{\r\nIRDA_DEBUG(1, "%s(), reason=%s\n", __func__, lap_reasons[reason]);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nirlap_flush_all_queues(self);\r\nswitch (reason) {\r\ncase LAP_RESET_INDICATION:\r\nIRDA_DEBUG(1, "%s(), Sending reset request!\n", __func__);\r\nirlap_do_event(self, RESET_REQUEST, NULL, NULL);\r\nbreak;\r\ncase LAP_NO_RESPONSE:\r\ncase LAP_DISC_INDICATION:\r\ncase LAP_FOUND_NONE:\r\ncase LAP_MEDIA_BUSY:\r\nirlmp_link_disconnect_indication(self->notify.instance, self,\r\nreason, NULL);\r\nbreak;\r\ndefault:\r\nIRDA_ERROR("%s: Unknown reason %d\n", __func__, reason);\r\n}\r\n}\r\nvoid irlap_discovery_request(struct irlap_cb *self, discovery_t *discovery)\r\n{\r\nstruct irlap_info info;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nIRDA_ASSERT(discovery != NULL, return;);\r\nIRDA_DEBUG(4, "%s(), nslots = %d\n", __func__, discovery->nslots);\r\nIRDA_ASSERT((discovery->nslots == 1) || (discovery->nslots == 6) ||\r\n(discovery->nslots == 8) || (discovery->nslots == 16),\r\nreturn;);\r\nif (self->state != LAP_NDM) {\r\nIRDA_DEBUG(4, "%s(), discovery only possible in NDM mode\n",\r\n__func__);\r\nirlap_discovery_confirm(self, NULL);\r\nreturn;\r\n}\r\nif (self->discovery_log != NULL) {\r\nhashbin_delete(self->discovery_log, (FREE_FUNC) kfree);\r\nself->discovery_log = NULL;\r\n}\r\nself->discovery_log = hashbin_new(HB_NOLOCK);\r\nif (self->discovery_log == NULL) {\r\nIRDA_WARNING("%s(), Unable to allocate discovery log!\n",\r\n__func__);\r\nreturn;\r\n}\r\ninfo.S = discovery->nslots;\r\ninfo.s = 0;\r\nself->discovery_cmd = discovery;\r\ninfo.discovery = discovery;\r\nself->slot_timeout = sysctl_slot_timeout * HZ / 1000;\r\nirlap_do_event(self, DISCOVERY_REQUEST, NULL, &info);\r\n}\r\nvoid irlap_discovery_confirm(struct irlap_cb *self, hashbin_t *discovery_log)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nIRDA_ASSERT(self->notify.instance != NULL, return;);\r\nif (discovery_log)\r\nirda_device_set_media_busy(self->netdev, FALSE);\r\nirlmp_link_discovery_confirm(self->notify.instance, discovery_log);\r\n}\r\nvoid irlap_discovery_indication(struct irlap_cb *self, discovery_t *discovery)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nIRDA_ASSERT(discovery != NULL, return;);\r\nIRDA_ASSERT(self->notify.instance != NULL, return;);\r\nirda_device_set_media_busy(self->netdev, SMALL);\r\nirlmp_link_discovery_indication(self->notify.instance, discovery);\r\n}\r\nvoid irlap_status_indication(struct irlap_cb *self, int quality_of_link)\r\n{\r\nswitch (quality_of_link) {\r\ncase STATUS_NO_ACTIVITY:\r\nIRDA_MESSAGE("IrLAP, no activity on link!\n");\r\nbreak;\r\ncase STATUS_NOISY:\r\nIRDA_MESSAGE("IrLAP, noisy link!\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nirlmp_status_indication(self->notify.instance,\r\nquality_of_link, LOCK_NO_CHANGE);\r\n}\r\nvoid irlap_reset_indication(struct irlap_cb *self)\r\n{\r\nIRDA_DEBUG(1, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nif (self->state == LAP_RESET_WAIT)\r\nirlap_do_event(self, RESET_REQUEST, NULL, NULL);\r\nelse\r\nirlap_do_event(self, RESET_RESPONSE, NULL, NULL);\r\n}\r\nvoid irlap_reset_confirm(void)\r\n{\r\nIRDA_DEBUG(1, "%s()\n", __func__);\r\n}\r\nint irlap_generate_rand_time_slot(int S, int s)\r\n{\r\nstatic int rand;\r\nint slot;\r\nIRDA_ASSERT((S - s) > 0, return 0;);\r\nrand += jiffies;\r\nrand ^= (rand << 12);\r\nrand ^= (rand >> 20);\r\nslot = s + rand % (S-s);\r\nIRDA_ASSERT((slot >= s) || (slot < S), return 0;);\r\nreturn slot;\r\n}\r\nvoid irlap_update_nr_received(struct irlap_cb *self, int nr)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nint count = 0;\r\nif (nr == self->vs) {\r\nwhile ((skb = skb_dequeue(&self->wx_list)) != NULL) {\r\ndev_kfree_skb(skb);\r\n}\r\nself->va = nr - 1;\r\n} else {\r\nwhile ((skb_peek(&self->wx_list) != NULL) &&\r\n(((self->va+1) % 8) != nr))\r\n{\r\nskb = skb_dequeue(&self->wx_list);\r\ndev_kfree_skb(skb);\r\nself->va = (self->va + 1) % 8;\r\ncount++;\r\n}\r\n}\r\nself->window = self->window_size - skb_queue_len(&self->wx_list);\r\n}\r\nint irlap_validate_ns_received(struct irlap_cb *self, int ns)\r\n{\r\nif (ns == self->vr)\r\nreturn NS_EXPECTED;\r\nreturn NS_UNEXPECTED;\r\n}\r\nint irlap_validate_nr_received(struct irlap_cb *self, int nr)\r\n{\r\nif (nr == self->vs) {\r\nIRDA_DEBUG(4, "%s(), expected!\n", __func__);\r\nreturn NR_EXPECTED;\r\n}\r\nif (self->va < self->vs) {\r\nif ((nr >= self->va) && (nr <= self->vs))\r\nreturn NR_UNEXPECTED;\r\n} else {\r\nif ((nr >= self->va) || (nr <= self->vs))\r\nreturn NR_UNEXPECTED;\r\n}\r\nreturn NR_INVALID;\r\n}\r\nvoid irlap_initiate_connection_state(struct irlap_cb *self)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nself->vs = self->vr = 0;\r\nself->va = 7;\r\nself->window = 1;\r\nself->remote_busy = FALSE;\r\nself->retry_count = 0;\r\n}\r\nvoid irlap_wait_min_turn_around(struct irlap_cb *self, struct qos_info *qos)\r\n{\r\n__u32 min_turn_time;\r\n__u32 speed;\r\nspeed = qos->baud_rate.value;\r\nmin_turn_time = qos->min_turn_time.value;\r\nif (speed > 115200) {\r\nself->mtt_required = min_turn_time;\r\nreturn;\r\n}\r\nself->xbofs_delay = irlap_min_turn_time_in_bytes(speed, min_turn_time);\r\n}\r\nvoid irlap_flush_all_queues(struct irlap_cb *self)\r\n{\r\nstruct sk_buff* skb;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nwhile ((skb = skb_dequeue(&self->txq)) != NULL)\r\ndev_kfree_skb(skb);\r\nwhile ((skb = skb_dequeue(&self->txq_ultra)) != NULL)\r\ndev_kfree_skb(skb);\r\nwhile ((skb = skb_dequeue(&self->wx_list)) != NULL)\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void irlap_change_speed(struct irlap_cb *self, __u32 speed, int now)\r\n{\r\nstruct sk_buff *skb;\r\nIRDA_DEBUG(0, "%s(), setting speed to %d\n", __func__, speed);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nself->speed = speed;\r\nif (now) {\r\nskb = alloc_skb(0, GFP_ATOMIC);\r\nif (skb)\r\nirlap_queue_xmit(self, skb);\r\n}\r\n}\r\nstatic void irlap_init_qos_capabilities(struct irlap_cb *self,\r\nstruct qos_info *qos_user)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nIRDA_ASSERT(self->netdev != NULL, return;);\r\nirda_init_max_qos_capabilies(&self->qos_rx);\r\nirda_qos_compute_intersection(&self->qos_rx, self->qos_dev);\r\nif (qos_user) {\r\nIRDA_DEBUG(1, "%s(), Found user specified QoS!\n", __func__);\r\nif (qos_user->baud_rate.bits)\r\nself->qos_rx.baud_rate.bits &= qos_user->baud_rate.bits;\r\nif (qos_user->max_turn_time.bits)\r\nself->qos_rx.max_turn_time.bits &= qos_user->max_turn_time.bits;\r\nif (qos_user->data_size.bits)\r\nself->qos_rx.data_size.bits &= qos_user->data_size.bits;\r\nif (qos_user->link_disc_time.bits)\r\nself->qos_rx.link_disc_time.bits &= qos_user->link_disc_time.bits;\r\n}\r\nself->qos_rx.max_turn_time.bits &= 0x01;\r\nirda_qos_bits_to_value(&self->qos_rx);\r\n}\r\nvoid irlap_apply_default_connection_parameters(struct irlap_cb *self)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nself->next_bofs = 12;\r\nself->bofs_count = 12;\r\nirlap_change_speed(self, 9600, TRUE);\r\nirda_device_set_media_busy(self->netdev, TRUE);\r\nwhile ((self->caddr == 0x00) || (self->caddr == 0xfe)) {\r\nget_random_bytes(&self->caddr, sizeof(self->caddr));\r\nself->caddr &= 0xfe;\r\n}\r\nself->slot_timeout = sysctl_slot_timeout;\r\nself->final_timeout = FINAL_TIMEOUT;\r\nself->poll_timeout = POLL_TIMEOUT;\r\nself->wd_timeout = WD_TIMEOUT;\r\nself->qos_tx.baud_rate.value = 9600;\r\nself->qos_rx.baud_rate.value = 9600;\r\nself->qos_tx.max_turn_time.value = 0;\r\nself->qos_rx.max_turn_time.value = 0;\r\nself->qos_tx.min_turn_time.value = 0;\r\nself->qos_rx.min_turn_time.value = 0;\r\nself->qos_tx.data_size.value = 64;\r\nself->qos_rx.data_size.value = 64;\r\nself->qos_tx.window_size.value = 1;\r\nself->qos_rx.window_size.value = 1;\r\nself->qos_tx.additional_bofs.value = 12;\r\nself->qos_rx.additional_bofs.value = 12;\r\nself->qos_tx.link_disc_time.value = 0;\r\nself->qos_rx.link_disc_time.value = 0;\r\nirlap_flush_all_queues(self);\r\nself->disconnect_pending = FALSE;\r\nself->connect_pending = FALSE;\r\n}\r\nvoid irlap_apply_connection_parameters(struct irlap_cb *self, int now)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\r\nself->next_bofs = self->qos_tx.additional_bofs.value;\r\nif (now)\r\nself->bofs_count = self->next_bofs;\r\nirlap_change_speed(self, self->qos_tx.baud_rate.value, now);\r\nself->window_size = self->qos_tx.window_size.value;\r\nself->window = self->qos_tx.window_size.value;\r\n#ifdef CONFIG_IRDA_DYNAMIC_WINDOW\r\nself->line_capacity =\r\nirlap_max_line_capacity(self->qos_tx.baud_rate.value,\r\nself->qos_tx.max_turn_time.value);\r\nself->bytes_left = self->line_capacity;\r\n#endif\r\nIRDA_ASSERT(self->qos_tx.max_turn_time.value != 0, return;);\r\nIRDA_ASSERT(self->qos_rx.max_turn_time.value != 0, return;);\r\nself->poll_timeout = self->qos_tx.max_turn_time.value * HZ / 1000;\r\nself->final_timeout = self->qos_rx.max_turn_time.value * HZ / 1000;\r\nself->wd_timeout = self->final_timeout * 2;\r\nif (self->qos_tx.link_disc_time.value == sysctl_warn_noreply_time)\r\nself->N1 = -2;\r\nelse\r\nself->N1 = sysctl_warn_noreply_time * 1000 /\r\nself->qos_rx.max_turn_time.value;\r\nIRDA_DEBUG(4, "Setting N1 = %d\n", self->N1);\r\nself->N2 = self->qos_tx.link_disc_time.value * 1000 /\r\nself->qos_rx.max_turn_time.value;\r\nIRDA_DEBUG(4, "Setting N2 = %d\n", self->N2);\r\n}\r\nstatic void *irlap_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct irlap_iter_state *iter = seq->private;\r\nstruct irlap_cb *self;\r\nspin_lock_irq(&irlap->hb_spinlock);\r\niter->id = 0;\r\nfor (self = (struct irlap_cb *) hashbin_get_first(irlap);\r\nself; self = (struct irlap_cb *) hashbin_get_next(irlap)) {\r\nif (iter->id == *pos)\r\nbreak;\r\n++iter->id;\r\n}\r\nreturn self;\r\n}\r\nstatic void *irlap_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct irlap_iter_state *iter = seq->private;\r\n++*pos;\r\n++iter->id;\r\nreturn (void *) hashbin_get_next(irlap);\r\n}\r\nstatic void irlap_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nspin_unlock_irq(&irlap->hb_spinlock);\r\n}\r\nstatic int irlap_seq_show(struct seq_file *seq, void *v)\r\n{\r\nconst struct irlap_iter_state *iter = seq->private;\r\nconst struct irlap_cb *self = v;\r\nIRDA_ASSERT(self->magic == LAP_MAGIC, return -EINVAL;);\r\nseq_printf(seq, "irlap%d ", iter->id);\r\nseq_printf(seq, "state: %s\n",\r\nirlap_state[self->state]);\r\nseq_printf(seq, " device name: %s, ",\r\n(self->netdev) ? self->netdev->name : "bug");\r\nseq_printf(seq, "hardware name: %s\n", self->hw_name);\r\nseq_printf(seq, " caddr: %#02x, ", self->caddr);\r\nseq_printf(seq, "saddr: %#08x, ", self->saddr);\r\nseq_printf(seq, "daddr: %#08x\n", self->daddr);\r\nseq_printf(seq, " win size: %d, ",\r\nself->window_size);\r\nseq_printf(seq, "win: %d, ", self->window);\r\n#ifdef CONFIG_IRDA_DYNAMIC_WINDOW\r\nseq_printf(seq, "line capacity: %d, ",\r\nself->line_capacity);\r\nseq_printf(seq, "bytes left: %d\n", self->bytes_left);\r\n#endif\r\nseq_printf(seq, " tx queue len: %d ",\r\nskb_queue_len(&self->txq));\r\nseq_printf(seq, "win queue len: %d ",\r\nskb_queue_len(&self->wx_list));\r\nseq_printf(seq, "rbusy: %s", self->remote_busy ?\r\n"TRUE" : "FALSE");\r\nseq_printf(seq, " mbusy: %s\n", self->media_busy ?\r\n"TRUE" : "FALSE");\r\nseq_printf(seq, " retrans: %d ", self->retry_count);\r\nseq_printf(seq, "vs: %d ", self->vs);\r\nseq_printf(seq, "vr: %d ", self->vr);\r\nseq_printf(seq, "va: %d\n", self->va);\r\nseq_printf(seq, " qos\tbps\tmaxtt\tdsize\twinsize\taddbofs\tmintt\tldisc\tcomp\n");\r\nseq_printf(seq, " tx\t%d\t",\r\nself->qos_tx.baud_rate.value);\r\nseq_printf(seq, "%d\t",\r\nself->qos_tx.max_turn_time.value);\r\nseq_printf(seq, "%d\t",\r\nself->qos_tx.data_size.value);\r\nseq_printf(seq, "%d\t",\r\nself->qos_tx.window_size.value);\r\nseq_printf(seq, "%d\t",\r\nself->qos_tx.additional_bofs.value);\r\nseq_printf(seq, "%d\t",\r\nself->qos_tx.min_turn_time.value);\r\nseq_printf(seq, "%d\t",\r\nself->qos_tx.link_disc_time.value);\r\nseq_printf(seq, "\n");\r\nseq_printf(seq, " rx\t%d\t",\r\nself->qos_rx.baud_rate.value);\r\nseq_printf(seq, "%d\t",\r\nself->qos_rx.max_turn_time.value);\r\nseq_printf(seq, "%d\t",\r\nself->qos_rx.data_size.value);\r\nseq_printf(seq, "%d\t",\r\nself->qos_rx.window_size.value);\r\nseq_printf(seq, "%d\t",\r\nself->qos_rx.additional_bofs.value);\r\nseq_printf(seq, "%d\t",\r\nself->qos_rx.min_turn_time.value);\r\nseq_printf(seq, "%d\n",\r\nself->qos_rx.link_disc_time.value);\r\nreturn 0;\r\n}\r\nstatic int irlap_seq_open(struct inode *inode, struct file *file)\r\n{\r\nif (irlap == NULL)\r\nreturn -EINVAL;\r\nreturn seq_open_private(file, &irlap_seq_ops,\r\nsizeof(struct irlap_iter_state));\r\n}
