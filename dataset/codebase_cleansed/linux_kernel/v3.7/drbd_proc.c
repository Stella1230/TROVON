void seq_printf_with_thousands_grouping(struct seq_file *seq, long v)\r\n{\r\nif (unlikely(v >= 1000000)) {\r\nseq_printf(seq, "%ld,", v / 1000000);\r\nv %= 1000000;\r\nseq_printf(seq, "%03ld,%03ld", v/1000, v % 1000);\r\n} else if (likely(v >= 1000))\r\nseq_printf(seq, "%ld,%03ld", v/1000, v % 1000);\r\nelse\r\nseq_printf(seq, "%ld", v);\r\n}\r\nstatic void drbd_syncer_progress(struct drbd_conf *mdev, struct seq_file *seq)\r\n{\r\nunsigned long db, dt, dbdt, rt, rs_left;\r\nunsigned int res;\r\nint i, x, y;\r\nint stalled = 0;\r\ndrbd_get_syncer_progress(mdev, &rs_left, &res);\r\nx = res/50;\r\ny = 20-x;\r\nseq_printf(seq, "\t[");\r\nfor (i = 1; i < x; i++)\r\nseq_printf(seq, "=");\r\nseq_printf(seq, ">");\r\nfor (i = 0; i < y; i++)\r\nseq_printf(seq, ".");\r\nseq_printf(seq, "] ");\r\nif (mdev->state.conn == C_VERIFY_S || mdev->state.conn == C_VERIFY_T)\r\nseq_printf(seq, "verified:");\r\nelse\r\nseq_printf(seq, "sync'ed:");\r\nseq_printf(seq, "%3u.%u%% ", res / 10, res % 10);\r\nif (mdev->rs_total > (4UL << (30 - BM_BLOCK_SHIFT)))\r\nseq_printf(seq, "(%lu/%lu)M",\r\n(unsigned long) Bit2KB(rs_left >> 10),\r\n(unsigned long) Bit2KB(mdev->rs_total >> 10));\r\nelse\r\nseq_printf(seq, "(%lu/%lu)K\n\t",\r\n(unsigned long) Bit2KB(rs_left),\r\n(unsigned long) Bit2KB(mdev->rs_total));\r\ni = (mdev->rs_last_mark + 2) % DRBD_SYNC_MARKS;\r\ndt = (jiffies - mdev->rs_mark_time[i]) / HZ;\r\nif (dt > (DRBD_SYNC_MARK_STEP * DRBD_SYNC_MARKS))\r\nstalled = 1;\r\nif (!dt)\r\ndt++;\r\ndb = mdev->rs_mark_left[i] - rs_left;\r\nrt = (dt * (rs_left / (db/100+1)))/100;\r\nseq_printf(seq, "finish: %lu:%02lu:%02lu",\r\nrt / 3600, (rt % 3600) / 60, rt % 60);\r\ndbdt = Bit2KB(db/dt);\r\nseq_printf(seq, " speed: ");\r\nseq_printf_with_thousands_grouping(seq, dbdt);\r\nseq_printf(seq, " (");\r\nif (proc_details >= 1) {\r\ni = (mdev->rs_last_mark + DRBD_SYNC_MARKS-1) % DRBD_SYNC_MARKS;\r\ndt = (jiffies - mdev->rs_mark_time[i]) / HZ;\r\nif (!dt)\r\ndt++;\r\ndb = mdev->rs_mark_left[i] - rs_left;\r\ndbdt = Bit2KB(db/dt);\r\nseq_printf_with_thousands_grouping(seq, dbdt);\r\nseq_printf(seq, " -- ");\r\n}\r\ndt = (jiffies - mdev->rs_start - mdev->rs_paused) / HZ;\r\nif (dt == 0)\r\ndt = 1;\r\ndb = mdev->rs_total - rs_left;\r\ndbdt = Bit2KB(db/dt);\r\nseq_printf_with_thousands_grouping(seq, dbdt);\r\nseq_printf(seq, ")");\r\nif (mdev->state.conn == C_SYNC_TARGET ||\r\nmdev->state.conn == C_VERIFY_S) {\r\nseq_printf(seq, " want: ");\r\nseq_printf_with_thousands_grouping(seq, mdev->c_sync_rate);\r\n}\r\nseq_printf(seq, " K/sec%s\n", stalled ? " (stalled)" : "");\r\nif (proc_details >= 1) {\r\nunsigned long bm_bits = drbd_bm_bits(mdev);\r\nunsigned long bit_pos;\r\nif (mdev->state.conn == C_VERIFY_S ||\r\nmdev->state.conn == C_VERIFY_T)\r\nbit_pos = bm_bits - mdev->ov_left;\r\nelse\r\nbit_pos = mdev->bm_resync_fo;\r\nseq_printf(seq,\r\n"\t%3d%% sector pos: %llu/%llu\n",\r\n(int)(bit_pos / (bm_bits/100+1)),\r\n(unsigned long long)bit_pos * BM_SECT_PER_BIT,\r\n(unsigned long long)bm_bits * BM_SECT_PER_BIT);\r\n}\r\n}\r\nstatic void resync_dump_detail(struct seq_file *seq, struct lc_element *e)\r\n{\r\nstruct bm_extent *bme = lc_entry(e, struct bm_extent, lce);\r\nseq_printf(seq, "%5d %s %s\n", bme->rs_left,\r\nbme->flags & BME_NO_WRITES ? "NO_WRITES" : "---------",\r\nbme->flags & BME_LOCKED ? "LOCKED" : "------"\r\n);\r\n}\r\nstatic int drbd_seq_show(struct seq_file *seq, void *v)\r\n{\r\nint i, hole = 0;\r\nconst char *sn;\r\nstruct drbd_conf *mdev;\r\nstatic char write_ordering_chars[] = {\r\n[WO_none] = 'n',\r\n[WO_drain_io] = 'd',\r\n[WO_bdev_flush] = 'f',\r\n};\r\nseq_printf(seq, "version: " REL_VERSION " (api:%d/proto:%d-%d)\n%s\n",\r\nAPI_VERSION, PRO_VERSION_MIN, PRO_VERSION_MAX, drbd_buildtag());\r\nfor (i = 0; i < minor_count; i++) {\r\nmdev = minor_to_mdev(i);\r\nif (!mdev) {\r\nhole = 1;\r\ncontinue;\r\n}\r\nif (hole) {\r\nhole = 0;\r\nseq_printf(seq, "\n");\r\n}\r\nsn = drbd_conn_str(mdev->state.conn);\r\nif (mdev->state.conn == C_STANDALONE &&\r\nmdev->state.disk == D_DISKLESS &&\r\nmdev->state.role == R_SECONDARY) {\r\nseq_printf(seq, "%2d: cs:Unconfigured\n", i);\r\n} else {\r\nbdi_rw_congested(&mdev->rq_queue->backing_dev_info);\r\nseq_printf(seq,\r\n"%2d: cs:%s ro:%s/%s ds:%s/%s %c %c%c%c%c%c%c\n"\r\n" ns:%u nr:%u dw:%u dr:%u al:%u bm:%u "\r\n"lo:%d pe:%d ua:%d ap:%d ep:%d wo:%c",\r\ni, sn,\r\ndrbd_role_str(mdev->state.role),\r\ndrbd_role_str(mdev->state.peer),\r\ndrbd_disk_str(mdev->state.disk),\r\ndrbd_disk_str(mdev->state.pdsk),\r\n(mdev->net_conf == NULL ? ' ' :\r\n(mdev->net_conf->wire_protocol - DRBD_PROT_A+'A')),\r\nis_susp(mdev->state) ? 's' : 'r',\r\nmdev->state.aftr_isp ? 'a' : '-',\r\nmdev->state.peer_isp ? 'p' : '-',\r\nmdev->state.user_isp ? 'u' : '-',\r\nmdev->congestion_reason ?: '-',\r\ntest_bit(AL_SUSPENDED, &mdev->flags) ? 's' : '-',\r\nmdev->send_cnt/2,\r\nmdev->recv_cnt/2,\r\nmdev->writ_cnt/2,\r\nmdev->read_cnt/2,\r\nmdev->al_writ_cnt,\r\nmdev->bm_writ_cnt,\r\natomic_read(&mdev->local_cnt),\r\natomic_read(&mdev->ap_pending_cnt) +\r\natomic_read(&mdev->rs_pending_cnt),\r\natomic_read(&mdev->unacked_cnt),\r\natomic_read(&mdev->ap_bio_cnt),\r\nmdev->epochs,\r\nwrite_ordering_chars[mdev->write_ordering]\r\n);\r\nseq_printf(seq, " oos:%llu\n",\r\nBit2KB((unsigned long long)\r\ndrbd_bm_total_weight(mdev)));\r\n}\r\nif (mdev->state.conn == C_SYNC_SOURCE ||\r\nmdev->state.conn == C_SYNC_TARGET ||\r\nmdev->state.conn == C_VERIFY_S ||\r\nmdev->state.conn == C_VERIFY_T)\r\ndrbd_syncer_progress(mdev, seq);\r\nif (proc_details >= 1 && get_ldev_if_state(mdev, D_FAILED)) {\r\nlc_seq_printf_stats(seq, mdev->resync);\r\nlc_seq_printf_stats(seq, mdev->act_log);\r\nput_ldev(mdev);\r\n}\r\nif (proc_details >= 2) {\r\nif (mdev->resync) {\r\nlc_seq_dump_details(seq, mdev->resync, "rs_left",\r\nresync_dump_detail);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int drbd_proc_open(struct inode *inode, struct file *file)\r\n{\r\nif (try_module_get(THIS_MODULE))\r\nreturn single_open(file, drbd_seq_show, PDE(inode)->data);\r\nreturn -ENODEV;\r\n}\r\nstatic int drbd_proc_release(struct inode *inode, struct file *file)\r\n{\r\nmodule_put(THIS_MODULE);\r\nreturn single_release(inode, file);\r\n}
