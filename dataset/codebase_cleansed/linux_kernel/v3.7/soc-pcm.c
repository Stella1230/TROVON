static int dpcm_dapm_stream_event(struct snd_soc_pcm_runtime *fe, int dir,\r\nint event)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nlist_for_each_entry(dpcm, &fe->dpcm[dir].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\ndev_dbg(be->dev, "pm: BE %s event %d dir %d\n",\r\nbe->dai_link->name, event, dir);\r\nsnd_soc_dapm_stream_event(be, dir, event);\r\n}\r\nsnd_soc_dapm_stream_event(fe, dir, event);\r\nreturn 0;\r\n}\r\nstatic int soc_pcm_apply_symmetry(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *soc_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nint ret;\r\nif (!soc_dai->driver->symmetric_rates &&\r\n!rtd->dai_link->symmetric_rates)\r\nreturn 0;\r\nif (!soc_dai->rate) {\r\ndev_warn(soc_dai->dev,\r\n"Not enforcing symmetric_rates due to race\n");\r\nreturn 0;\r\n}\r\ndev_dbg(soc_dai->dev, "Symmetry forces %dHz rate\n", soc_dai->rate);\r\nret = snd_pcm_hw_constraint_minmax(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nsoc_dai->rate, soc_dai->rate);\r\nif (ret < 0) {\r\ndev_err(soc_dai->dev,\r\n"Unable to apply rate symmetry constraint: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void soc_pcm_apply_msb(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint ret, i, bits;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nbits = dai->driver->playback.sig_bits;\r\nelse\r\nbits = dai->driver->capture.sig_bits;\r\nif (!bits)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(sample_sizes); i++) {\r\nif (bits >= sample_sizes[i])\r\ncontinue;\r\nret = snd_pcm_hw_constraint_msbits(substream->runtime, 0,\r\nsample_sizes[i], bits);\r\nif (ret != 0)\r\ndev_warn(dai->dev,\r\n"Failed to set MSB %d/%d: %d\n",\r\nbits, sample_sizes[i], ret);\r\n}\r\n}\r\nstatic int soc_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nstruct snd_soc_dai_driver *cpu_dai_drv = cpu_dai->driver;\r\nstruct snd_soc_dai_driver *codec_dai_drv = codec_dai->driver;\r\nint ret = 0;\r\npm_runtime_get_sync(cpu_dai->dev);\r\npm_runtime_get_sync(codec_dai->dev);\r\npm_runtime_get_sync(platform->dev);\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (cpu_dai->driver->ops->startup) {\r\nret = cpu_dai->driver->ops->startup(substream, cpu_dai);\r\nif (ret < 0) {\r\ndev_err(cpu_dai->dev, "can't open interface %s: %d\n",\r\ncpu_dai->name, ret);\r\ngoto out;\r\n}\r\n}\r\nif (platform->driver->ops && platform->driver->ops->open) {\r\nret = platform->driver->ops->open(substream);\r\nif (ret < 0) {\r\ndev_err(platform->dev, "can't open platform %s: %d\n",\r\nplatform->name, ret);\r\ngoto platform_err;\r\n}\r\n}\r\nif (codec_dai->driver->ops->startup) {\r\nret = codec_dai->driver->ops->startup(substream, codec_dai);\r\nif (ret < 0) {\r\ndev_err(codec_dai->dev, "can't open codec %s: %d\n",\r\ncodec_dai->name, ret);\r\ngoto codec_dai_err;\r\n}\r\n}\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->startup) {\r\nret = rtd->dai_link->ops->startup(substream);\r\nif (ret < 0) {\r\npr_err("asoc: %s startup failed: %d\n",\r\nrtd->dai_link->name, ret);\r\ngoto machine_err;\r\n}\r\n}\r\nif (rtd->dai_link->dynamic || rtd->dai_link->no_pcm)\r\ngoto dynamic;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nruntime->hw.rate_min =\r\nmax(codec_dai_drv->playback.rate_min,\r\ncpu_dai_drv->playback.rate_min);\r\nruntime->hw.rate_max =\r\nmin(codec_dai_drv->playback.rate_max,\r\ncpu_dai_drv->playback.rate_max);\r\nruntime->hw.channels_min =\r\nmax(codec_dai_drv->playback.channels_min,\r\ncpu_dai_drv->playback.channels_min);\r\nruntime->hw.channels_max =\r\nmin(codec_dai_drv->playback.channels_max,\r\ncpu_dai_drv->playback.channels_max);\r\nruntime->hw.formats =\r\ncodec_dai_drv->playback.formats & cpu_dai_drv->playback.formats;\r\nruntime->hw.rates =\r\ncodec_dai_drv->playback.rates & cpu_dai_drv->playback.rates;\r\nif (codec_dai_drv->playback.rates\r\n& (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))\r\nruntime->hw.rates |= cpu_dai_drv->playback.rates;\r\nif (cpu_dai_drv->playback.rates\r\n& (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))\r\nruntime->hw.rates |= codec_dai_drv->playback.rates;\r\n} else {\r\nruntime->hw.rate_min =\r\nmax(codec_dai_drv->capture.rate_min,\r\ncpu_dai_drv->capture.rate_min);\r\nruntime->hw.rate_max =\r\nmin(codec_dai_drv->capture.rate_max,\r\ncpu_dai_drv->capture.rate_max);\r\nruntime->hw.channels_min =\r\nmax(codec_dai_drv->capture.channels_min,\r\ncpu_dai_drv->capture.channels_min);\r\nruntime->hw.channels_max =\r\nmin(codec_dai_drv->capture.channels_max,\r\ncpu_dai_drv->capture.channels_max);\r\nruntime->hw.formats =\r\ncodec_dai_drv->capture.formats & cpu_dai_drv->capture.formats;\r\nruntime->hw.rates =\r\ncodec_dai_drv->capture.rates & cpu_dai_drv->capture.rates;\r\nif (codec_dai_drv->capture.rates\r\n& (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))\r\nruntime->hw.rates |= cpu_dai_drv->capture.rates;\r\nif (cpu_dai_drv->capture.rates\r\n& (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))\r\nruntime->hw.rates |= codec_dai_drv->capture.rates;\r\n}\r\nret = -EINVAL;\r\nsnd_pcm_limit_hw_rates(runtime);\r\nif (!runtime->hw.rates) {\r\nprintk(KERN_ERR "asoc: %s <-> %s No matching rates\n",\r\ncodec_dai->name, cpu_dai->name);\r\ngoto config_err;\r\n}\r\nif (!runtime->hw.formats) {\r\nprintk(KERN_ERR "asoc: %s <-> %s No matching formats\n",\r\ncodec_dai->name, cpu_dai->name);\r\ngoto config_err;\r\n}\r\nif (!runtime->hw.channels_min || !runtime->hw.channels_max ||\r\nruntime->hw.channels_min > runtime->hw.channels_max) {\r\nprintk(KERN_ERR "asoc: %s <-> %s No matching channels\n",\r\ncodec_dai->name, cpu_dai->name);\r\ngoto config_err;\r\n}\r\nsoc_pcm_apply_msb(substream, codec_dai);\r\nsoc_pcm_apply_msb(substream, cpu_dai);\r\nif (cpu_dai->active) {\r\nret = soc_pcm_apply_symmetry(substream, cpu_dai);\r\nif (ret != 0)\r\ngoto config_err;\r\n}\r\nif (codec_dai->active) {\r\nret = soc_pcm_apply_symmetry(substream, codec_dai);\r\nif (ret != 0)\r\ngoto config_err;\r\n}\r\npr_debug("asoc: %s <-> %s info:\n",\r\ncodec_dai->name, cpu_dai->name);\r\npr_debug("asoc: rate mask 0x%x\n", runtime->hw.rates);\r\npr_debug("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,\r\nruntime->hw.channels_max);\r\npr_debug("asoc: min rate %d max rate %d\n", runtime->hw.rate_min,\r\nruntime->hw.rate_max);\r\ndynamic:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ncpu_dai->playback_active++;\r\ncodec_dai->playback_active++;\r\n} else {\r\ncpu_dai->capture_active++;\r\ncodec_dai->capture_active++;\r\n}\r\ncpu_dai->active++;\r\ncodec_dai->active++;\r\nrtd->codec->active++;\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn 0;\r\nconfig_err:\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->shutdown)\r\nrtd->dai_link->ops->shutdown(substream);\r\nmachine_err:\r\nif (codec_dai->driver->ops->shutdown)\r\ncodec_dai->driver->ops->shutdown(substream, codec_dai);\r\ncodec_dai_err:\r\nif (platform->driver->ops && platform->driver->ops->close)\r\nplatform->driver->ops->close(substream);\r\nplatform_err:\r\nif (cpu_dai->driver->ops->shutdown)\r\ncpu_dai->driver->ops->shutdown(substream, cpu_dai);\r\nout:\r\nmutex_unlock(&rtd->pcm_mutex);\r\npm_runtime_put(platform->dev);\r\npm_runtime_put(codec_dai->dev);\r\npm_runtime_put(cpu_dai->dev);\r\nreturn ret;\r\n}\r\nstatic void close_delayed_work(struct work_struct *work)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd =\r\ncontainer_of(work, struct snd_soc_pcm_runtime, delayed_work.work);\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\npr_debug("pop wq checking: %s status: %s waiting: %s\n",\r\ncodec_dai->driver->playback.stream_name,\r\ncodec_dai->playback_active ? "active" : "inactive",\r\ncodec_dai->pop_wait ? "yes" : "no");\r\nif (codec_dai->pop_wait == 1) {\r\ncodec_dai->pop_wait = 0;\r\nsnd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,\r\nSND_SOC_DAPM_STREAM_STOP);\r\n}\r\nmutex_unlock(&rtd->pcm_mutex);\r\n}\r\nstatic int soc_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ncpu_dai->playback_active--;\r\ncodec_dai->playback_active--;\r\n} else {\r\ncpu_dai->capture_active--;\r\ncodec_dai->capture_active--;\r\n}\r\ncpu_dai->active--;\r\ncodec_dai->active--;\r\ncodec->active--;\r\nif (!cpu_dai->active)\r\ncpu_dai->rate = 0;\r\nif (!codec_dai->active)\r\ncodec_dai->rate = 0;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsnd_soc_dai_digital_mute(codec_dai, 1);\r\nif (cpu_dai->driver->ops->shutdown)\r\ncpu_dai->driver->ops->shutdown(substream, cpu_dai);\r\nif (codec_dai->driver->ops->shutdown)\r\ncodec_dai->driver->ops->shutdown(substream, codec_dai);\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->shutdown)\r\nrtd->dai_link->ops->shutdown(substream);\r\nif (platform->driver->ops && platform->driver->ops->close)\r\nplatform->driver->ops->close(substream);\r\ncpu_dai->runtime = NULL;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (!rtd->pmdown_time || codec->ignore_pmdown_time ||\r\nrtd->dai_link->ignore_pmdown_time) {\r\nsnd_soc_dapm_stream_event(rtd,\r\nSNDRV_PCM_STREAM_PLAYBACK,\r\nSND_SOC_DAPM_STREAM_STOP);\r\n} else {\r\ncodec_dai->pop_wait = 1;\r\nschedule_delayed_work(&rtd->delayed_work,\r\nmsecs_to_jiffies(rtd->pmdown_time));\r\n}\r\n} else {\r\nsnd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_CAPTURE,\r\nSND_SOC_DAPM_STREAM_STOP);\r\n}\r\nmutex_unlock(&rtd->pcm_mutex);\r\npm_runtime_put(platform->dev);\r\npm_runtime_put(codec_dai->dev);\r\npm_runtime_put(cpu_dai->dev);\r\nreturn 0;\r\n}\r\nstatic int soc_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nint ret = 0;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->prepare) {\r\nret = rtd->dai_link->ops->prepare(substream);\r\nif (ret < 0) {\r\npr_err("asoc: machine prepare error: %d\n", ret);\r\ngoto out;\r\n}\r\n}\r\nif (platform->driver->ops && platform->driver->ops->prepare) {\r\nret = platform->driver->ops->prepare(substream);\r\nif (ret < 0) {\r\ndev_err(platform->dev, "platform prepare error: %d\n",\r\nret);\r\ngoto out;\r\n}\r\n}\r\nif (codec_dai->driver->ops->prepare) {\r\nret = codec_dai->driver->ops->prepare(substream, codec_dai);\r\nif (ret < 0) {\r\ndev_err(codec_dai->dev, "DAI prepare error: %d\n",\r\nret);\r\ngoto out;\r\n}\r\n}\r\nif (cpu_dai->driver->ops->prepare) {\r\nret = cpu_dai->driver->ops->prepare(substream, cpu_dai);\r\nif (ret < 0) {\r\ndev_err(cpu_dai->dev, "DAI prepare error: %d\n",\r\nret);\r\ngoto out;\r\n}\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\r\ncodec_dai->pop_wait) {\r\ncodec_dai->pop_wait = 0;\r\ncancel_delayed_work(&rtd->delayed_work);\r\n}\r\nsnd_soc_dapm_stream_event(rtd, substream->stream,\r\nSND_SOC_DAPM_STREAM_START);\r\nsnd_soc_dai_digital_mute(codec_dai, 0);\r\nout:\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nint ret = 0;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->hw_params) {\r\nret = rtd->dai_link->ops->hw_params(substream, params);\r\nif (ret < 0) {\r\npr_err("asoc: machine hw_params failed: %d\n", ret);\r\ngoto out;\r\n}\r\n}\r\nif (codec_dai->driver->ops->hw_params) {\r\nret = codec_dai->driver->ops->hw_params(substream, params, codec_dai);\r\nif (ret < 0) {\r\ndev_err(codec_dai->dev, "can't set %s hw params: %d\n",\r\ncodec_dai->name, ret);\r\ngoto codec_err;\r\n}\r\n}\r\nif (cpu_dai->driver->ops->hw_params) {\r\nret = cpu_dai->driver->ops->hw_params(substream, params, cpu_dai);\r\nif (ret < 0) {\r\ndev_err(cpu_dai->dev, "%s hw params failed: %d\n",\r\ncpu_dai->name, ret);\r\ngoto interface_err;\r\n}\r\n}\r\nif (platform->driver->ops && platform->driver->ops->hw_params) {\r\nret = platform->driver->ops->hw_params(substream, params);\r\nif (ret < 0) {\r\ndev_err(platform->dev, "%s hw params failed: %d\n",\r\nplatform->name, ret);\r\ngoto platform_err;\r\n}\r\n}\r\ncpu_dai->rate = params_rate(params);\r\ncodec_dai->rate = params_rate(params);\r\nout:\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\nplatform_err:\r\nif (cpu_dai->driver->ops->hw_free)\r\ncpu_dai->driver->ops->hw_free(substream, cpu_dai);\r\ninterface_err:\r\nif (codec_dai->driver->ops->hw_free)\r\ncodec_dai->driver->ops->hw_free(substream, codec_dai);\r\ncodec_err:\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->hw_free)\r\nrtd->dai_link->ops->hw_free(substream);\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nmutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);\r\nif (!codec->active)\r\nsnd_soc_dai_digital_mute(codec_dai, 1);\r\nif (rtd->dai_link->ops && rtd->dai_link->ops->hw_free)\r\nrtd->dai_link->ops->hw_free(substream);\r\nif (platform->driver->ops && platform->driver->ops->hw_free)\r\nplatform->driver->ops->hw_free(substream);\r\nif (codec_dai->driver->ops->hw_free)\r\ncodec_dai->driver->ops->hw_free(substream, codec_dai);\r\nif (cpu_dai->driver->ops->hw_free)\r\ncpu_dai->driver->ops->hw_free(substream, cpu_dai);\r\nmutex_unlock(&rtd->pcm_mutex);\r\nreturn 0;\r\n}\r\nstatic int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nint ret;\r\nif (codec_dai->driver->ops->trigger) {\r\nret = codec_dai->driver->ops->trigger(substream, cmd, codec_dai);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (platform->driver->ops && platform->driver->ops->trigger) {\r\nret = platform->driver->ops->trigger(substream, cmd);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (cpu_dai->driver->ops->trigger) {\r\nret = cpu_dai->driver->ops->trigger(substream, cmd, cpu_dai);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int soc_pcm_bespoke_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nint ret;\r\nif (codec_dai->driver->ops->bespoke_trigger) {\r\nret = codec_dai->driver->ops->bespoke_trigger(substream, cmd, codec_dai);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (platform->driver->bespoke_trigger) {\r\nret = platform->driver->bespoke_trigger(substream, cmd);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (cpu_dai->driver->ops->bespoke_trigger) {\r\nret = cpu_dai->driver->ops->bespoke_trigger(substream, cmd, cpu_dai);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t soc_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_uframes_t offset = 0;\r\nsnd_pcm_sframes_t delay = 0;\r\nif (platform->driver->ops && platform->driver->ops->pointer)\r\noffset = platform->driver->ops->pointer(substream);\r\nif (cpu_dai->driver->ops->delay)\r\ndelay += cpu_dai->driver->ops->delay(substream, cpu_dai);\r\nif (codec_dai->driver->ops->delay)\r\ndelay += codec_dai->driver->ops->delay(substream, codec_dai);\r\nif (platform->driver->delay)\r\ndelay += platform->driver->delay(substream, codec_dai);\r\nruntime->delay = delay;\r\nreturn offset;\r\n}\r\nstatic int dpcm_be_connect(struct snd_soc_pcm_runtime *fe,\r\nstruct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nif (dpcm->be == be && dpcm->fe == fe)\r\nreturn 0;\r\n}\r\ndpcm = kzalloc(sizeof(struct snd_soc_dpcm), GFP_KERNEL);\r\nif (!dpcm)\r\nreturn -ENOMEM;\r\ndpcm->be = be;\r\ndpcm->fe = fe;\r\nbe->dpcm[stream].runtime = fe->dpcm[stream].runtime;\r\ndpcm->state = SND_SOC_DPCM_LINK_STATE_NEW;\r\nlist_add(&dpcm->list_be, &fe->dpcm[stream].be_clients);\r\nlist_add(&dpcm->list_fe, &be->dpcm[stream].fe_clients);\r\ndev_dbg(fe->dev, " connected new DPCM %s path %s %s %s\n",\r\nstream ? "capture" : "playback", fe->dai_link->name,\r\nstream ? "<-" : "->", be->dai_link->name);\r\n#ifdef CONFIG_DEBUG_FS\r\ndpcm->debugfs_state = debugfs_create_u32(be->dai_link->name, 0644,\r\nfe->debugfs_dpcm_root, &dpcm->state);\r\n#endif\r\nreturn 1;\r\n}\r\nstatic void dpcm_be_reparent(struct snd_soc_pcm_runtime *fe,\r\nstruct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nstruct snd_pcm_substream *fe_substream, *be_substream;\r\nif (!be->dpcm[stream].users)\r\nreturn;\r\nbe_substream = snd_soc_dpcm_get_substream(be, stream);\r\nlist_for_each_entry(dpcm, &be->dpcm[stream].fe_clients, list_fe) {\r\nif (dpcm->fe == fe)\r\ncontinue;\r\ndev_dbg(fe->dev, " reparent %s path %s %s %s\n",\r\nstream ? "capture" : "playback",\r\ndpcm->fe->dai_link->name,\r\nstream ? "<-" : "->", dpcm->be->dai_link->name);\r\nfe_substream = snd_soc_dpcm_get_substream(dpcm->fe, stream);\r\nbe_substream->runtime = fe_substream->runtime;\r\nbreak;\r\n}\r\n}\r\nstatic void dpcm_be_disconnect(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm, *d;\r\nlist_for_each_entry_safe(dpcm, d, &fe->dpcm[stream].be_clients, list_be) {\r\ndev_dbg(fe->dev, "BE %s disconnect check for %s\n",\r\nstream ? "capture" : "playback",\r\ndpcm->be->dai_link->name);\r\nif (dpcm->state != SND_SOC_DPCM_LINK_STATE_FREE)\r\ncontinue;\r\ndev_dbg(fe->dev, " freed DSP %s path %s %s %s\n",\r\nstream ? "capture" : "playback", fe->dai_link->name,\r\nstream ? "<-" : "->", dpcm->be->dai_link->name);\r\ndpcm_be_reparent(fe, dpcm->be, stream);\r\n#ifdef CONFIG_DEBUG_FS\r\ndebugfs_remove(dpcm->debugfs_state);\r\n#endif\r\nlist_del(&dpcm->list_be);\r\nlist_del(&dpcm->list_fe);\r\nkfree(dpcm);\r\n}\r\n}\r\nstatic struct snd_soc_pcm_runtime *dpcm_get_be(struct snd_soc_card *card,\r\nstruct snd_soc_dapm_widget *widget, int stream)\r\n{\r\nstruct snd_soc_pcm_runtime *be;\r\nint i;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nfor (i = 0; i < card->num_links; i++) {\r\nbe = &card->rtd[i];\r\nif (!be->dai_link->no_pcm)\r\ncontinue;\r\nif (be->cpu_dai->playback_widget == widget ||\r\nbe->codec_dai->playback_widget == widget)\r\nreturn be;\r\n}\r\n} else {\r\nfor (i = 0; i < card->num_links; i++) {\r\nbe = &card->rtd[i];\r\nif (!be->dai_link->no_pcm)\r\ncontinue;\r\nif (be->cpu_dai->capture_widget == widget ||\r\nbe->codec_dai->capture_widget == widget)\r\nreturn be;\r\n}\r\n}\r\ndev_err(card->dev, "can't get %s BE for %s\n",\r\nstream ? "capture" : "playback", widget->name);\r\nreturn NULL;\r\n}\r\nstatic inline struct snd_soc_dapm_widget *\r\nrtd_get_cpu_widget(struct snd_soc_pcm_runtime *rtd, int stream)\r\n{\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn rtd->cpu_dai->playback_widget;\r\nelse\r\nreturn rtd->cpu_dai->capture_widget;\r\n}\r\nstatic inline struct snd_soc_dapm_widget *\r\nrtd_get_codec_widget(struct snd_soc_pcm_runtime *rtd, int stream)\r\n{\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn rtd->codec_dai->playback_widget;\r\nelse\r\nreturn rtd->codec_dai->capture_widget;\r\n}\r\nstatic int widget_in_list(struct snd_soc_dapm_widget_list *list,\r\nstruct snd_soc_dapm_widget *widget)\r\n{\r\nint i;\r\nfor (i = 0; i < list->num_widgets; i++) {\r\nif (widget == list->widgets[i])\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dpcm_path_get(struct snd_soc_pcm_runtime *fe,\r\nint stream, struct snd_soc_dapm_widget_list **list_)\r\n{\r\nstruct snd_soc_dai *cpu_dai = fe->cpu_dai;\r\nstruct snd_soc_dapm_widget_list *list;\r\nint paths;\r\nlist = kzalloc(sizeof(struct snd_soc_dapm_widget_list) +\r\nsizeof(struct snd_soc_dapm_widget *), GFP_KERNEL);\r\nif (list == NULL)\r\nreturn -ENOMEM;\r\npaths = snd_soc_dapm_dai_get_connected_widgets(cpu_dai, stream, &list);\r\ndev_dbg(fe->dev, "found %d audio %s paths\n", paths,\r\nstream ? "capture" : "playback");\r\n*list_ = list;\r\nreturn paths;\r\n}\r\nstatic inline void dpcm_path_put(struct snd_soc_dapm_widget_list **list)\r\n{\r\nkfree(*list);\r\n}\r\nstatic int dpcm_prune_paths(struct snd_soc_pcm_runtime *fe, int stream,\r\nstruct snd_soc_dapm_widget_list **list_)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nstruct snd_soc_dapm_widget_list *list = *list_;\r\nstruct snd_soc_dapm_widget *widget;\r\nint prune = 0;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nwidget = rtd_get_cpu_widget(dpcm->be, stream);\r\nif (widget && widget_in_list(list, widget))\r\ncontinue;\r\nwidget = rtd_get_codec_widget(dpcm->be, stream);\r\nif (widget && widget_in_list(list, widget))\r\ncontinue;\r\ndev_dbg(fe->dev, "pruning %s BE %s for %s\n",\r\nstream ? "capture" : "playback",\r\ndpcm->be->dai_link->name, fe->dai_link->name);\r\ndpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\r\ndpcm->be->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_BE;\r\nprune++;\r\n}\r\ndev_dbg(fe->dev, "found %d old BE paths for pruning\n", prune);\r\nreturn prune;\r\n}\r\nstatic int dpcm_add_paths(struct snd_soc_pcm_runtime *fe, int stream,\r\nstruct snd_soc_dapm_widget_list **list_)\r\n{\r\nstruct snd_soc_card *card = fe->card;\r\nstruct snd_soc_dapm_widget_list *list = *list_;\r\nstruct snd_soc_pcm_runtime *be;\r\nint i, new = 0, err;\r\nfor (i = 0; i < list->num_widgets; i++) {\r\nif (list->widgets[i]->id != snd_soc_dapm_dai)\r\ncontinue;\r\nbe = dpcm_get_be(card, list->widgets[i], stream);\r\nif (!be) {\r\ndev_err(fe->dev, "no BE found for %s\n",\r\nlist->widgets[i]->name);\r\ncontinue;\r\n}\r\nif (!be->dai_link->no_pcm)\r\ncontinue;\r\nif (!fe->dpcm[stream].runtime)\r\ncontinue;\r\nerr = dpcm_be_connect(fe, be, stream);\r\nif (err < 0) {\r\ndev_err(fe->dev, "can't connect %s\n",\r\nlist->widgets[i]->name);\r\nbreak;\r\n} else if (err == 0)\r\ncontinue;\r\nbe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_BE;\r\nnew++;\r\n}\r\ndev_dbg(fe->dev, "found %d new BE paths\n", new);\r\nreturn new;\r\n}\r\nstatic int dpcm_process_paths(struct snd_soc_pcm_runtime *fe,\r\nint stream, struct snd_soc_dapm_widget_list **list, int new)\r\n{\r\nif (new)\r\nreturn dpcm_add_paths(fe, stream, list);\r\nelse\r\nreturn dpcm_prune_paths(fe, stream, list);\r\n}\r\nstatic void dpcm_clear_pending_state(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be)\r\ndpcm->be->dpcm[stream].runtime_update =\r\nSND_SOC_DPCM_UPDATE_NO;\r\n}\r\nstatic void dpcm_be_dai_startup_unwind(struct snd_soc_pcm_runtime *fe,\r\nint stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (be->dpcm[stream].users == 0)\r\ndev_err(be->dev, "no users %s at close - state %d\n",\r\nstream ? "capture" : "playback",\r\nbe->dpcm[stream].state);\r\nif (--be->dpcm[stream].users != 0)\r\ncontinue;\r\nif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN)\r\ncontinue;\r\nsoc_pcm_close(be_substream);\r\nbe_substream->runtime = NULL;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\r\n}\r\n}\r\nstatic int dpcm_be_dai_startup(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nint err, count = 0;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nif (be->dpcm[stream].users == DPCM_MAX_BE_USERS)\r\ndev_err(be->dev, "too many users %s at open %d\n",\r\nstream ? "capture" : "playback",\r\nbe->dpcm[stream].state);\r\nif (be->dpcm[stream].users++ != 0)\r\ncontinue;\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_NEW) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_CLOSE))\r\ncontinue;\r\ndev_dbg(be->dev, "dpcm: open BE %s\n", be->dai_link->name);\r\nbe_substream->runtime = be->dpcm[stream].runtime;\r\nerr = soc_pcm_open(be_substream);\r\nif (err < 0) {\r\ndev_err(be->dev, "BE open failed %d\n", err);\r\nbe->dpcm[stream].users--;\r\nif (be->dpcm[stream].users < 0)\r\ndev_err(be->dev, "no users %s at unwind %d\n",\r\nstream ? "capture" : "playback",\r\nbe->dpcm[stream].state);\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\r\ngoto unwind;\r\n}\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_OPEN;\r\ncount++;\r\n}\r\nreturn count;\r\nunwind:\r\nlist_for_each_entry_continue_reverse(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nif (be->dpcm[stream].users == 0)\r\ndev_err(be->dev, "no users %s at close %d\n",\r\nstream ? "capture" : "playback",\r\nbe->dpcm[stream].state);\r\nif (--be->dpcm[stream].users != 0)\r\ncontinue;\r\nif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN)\r\ncontinue;\r\nsoc_pcm_close(be_substream);\r\nbe_substream->runtime = NULL;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\r\n}\r\nreturn err;\r\n}\r\nstatic void dpcm_set_fe_runtime(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_soc_dai_driver *cpu_dai_drv = cpu_dai->driver;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nruntime->hw.rate_min = cpu_dai_drv->playback.rate_min;\r\nruntime->hw.rate_max = cpu_dai_drv->playback.rate_max;\r\nruntime->hw.channels_min = cpu_dai_drv->playback.channels_min;\r\nruntime->hw.channels_max = cpu_dai_drv->playback.channels_max;\r\nruntime->hw.formats &= cpu_dai_drv->playback.formats;\r\nruntime->hw.rates = cpu_dai_drv->playback.rates;\r\n} else {\r\nruntime->hw.rate_min = cpu_dai_drv->capture.rate_min;\r\nruntime->hw.rate_max = cpu_dai_drv->capture.rate_max;\r\nruntime->hw.channels_min = cpu_dai_drv->capture.channels_min;\r\nruntime->hw.channels_max = cpu_dai_drv->capture.channels_max;\r\nruntime->hw.formats &= cpu_dai_drv->capture.formats;\r\nruntime->hw.rates = cpu_dai_drv->capture.rates;\r\n}\r\n}\r\nstatic int dpcm_fe_dai_startup(struct snd_pcm_substream *fe_substream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = fe_substream->private_data;\r\nstruct snd_pcm_runtime *runtime = fe_substream->runtime;\r\nint stream = fe_substream->stream, ret = 0;\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\r\nret = dpcm_be_dai_startup(fe, fe_substream->stream);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"dpcm: failed to start some BEs %d\n", ret);\r\ngoto be_err;\r\n}\r\ndev_dbg(fe->dev, "dpcm: open FE %s\n", fe->dai_link->name);\r\nret = soc_pcm_open(fe_substream);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"dpcm: failed to start FE %d\n", ret);\r\ngoto unwind;\r\n}\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_OPEN;\r\ndpcm_set_fe_runtime(fe_substream);\r\nsnd_pcm_limit_hw_rates(runtime);\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nreturn 0;\r\nunwind:\r\ndpcm_be_dai_startup_unwind(fe, fe_substream->stream);\r\nbe_err:\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nreturn ret;\r\n}\r\nstatic int dpcm_be_dai_shutdown(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nif (be->dpcm[stream].users == 0)\r\ndev_err(be->dev, "no users %s at close - state %d\n",\r\nstream ? "capture" : "playback",\r\nbe->dpcm[stream].state);\r\nif (--be->dpcm[stream].users != 0)\r\ncontinue;\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN))\r\ncontinue;\r\ndev_dbg(be->dev, "dpcm: close BE %s\n",\r\ndpcm->fe->dai_link->name);\r\nsoc_pcm_close(be_substream);\r\nbe_substream->runtime = NULL;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dpcm_fe_dai_shutdown(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = substream->private_data;\r\nint stream = substream->stream;\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\r\ndpcm_be_dai_shutdown(fe, substream->stream);\r\ndev_dbg(fe->dev, "dpcm: close FE %s\n", fe->dai_link->name);\r\nsoc_pcm_close(substream);\r\ndpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nreturn 0;\r\n}\r\nstatic int dpcm_be_dai_hw_free(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nif (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))\r\ncontinue;\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_PREPARE) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))\r\ncontinue;\r\ndev_dbg(be->dev, "dpcm: hw_free BE %s\n",\r\ndpcm->fe->dai_link->name);\r\nsoc_pcm_hw_free(be_substream);\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_FREE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dpcm_fe_dai_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = substream->private_data;\r\nint err, stream = substream->stream;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\r\ndev_dbg(fe->dev, "dpcm: hw_free FE %s\n", fe->dai_link->name);\r\nerr = soc_pcm_hw_free(substream);\r\nif (err < 0)\r\ndev_err(fe->dev,"dpcm: hw_free FE %s failed\n",\r\nfe->dai_link->name);\r\nerr = dpcm_be_dai_hw_free(fe, stream);\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_FREE;\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nmutex_unlock(&fe->card->mutex);\r\nreturn 0;\r\n}\r\nstatic int dpcm_be_dai_hw_params(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nint ret;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nif (!snd_soc_dpcm_can_be_params(fe, be, stream))\r\ncontinue;\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE))\r\ncontinue;\r\ndev_dbg(be->dev, "dpcm: hw_params BE %s\n",\r\ndpcm->fe->dai_link->name);\r\nmemcpy(&dpcm->hw_params, &fe->dpcm[stream].hw_params,\r\nsizeof(struct snd_pcm_hw_params));\r\nif (be->dai_link->be_hw_params_fixup) {\r\nret = be->dai_link->be_hw_params_fixup(be,\r\n&dpcm->hw_params);\r\nif (ret < 0) {\r\ndev_err(be->dev,\r\n"dpcm: hw_params BE fixup failed %d\n",\r\nret);\r\ngoto unwind;\r\n}\r\n}\r\nret = soc_pcm_hw_params(be_substream, &dpcm->hw_params);\r\nif (ret < 0) {\r\ndev_err(dpcm->be->dev,\r\n"dpcm: hw_params BE failed %d\n", ret);\r\ngoto unwind;\r\n}\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_PARAMS;\r\n}\r\nreturn 0;\r\nunwind:\r\nlist_for_each_entry_continue_reverse(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nif (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))\r\ncontinue;\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))\r\ncontinue;\r\nsoc_pcm_hw_free(be_substream);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dpcm_fe_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = substream->private_data;\r\nint ret, stream = substream->stream;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\r\nmemcpy(&fe->dpcm[substream->stream].hw_params, params,\r\nsizeof(struct snd_pcm_hw_params));\r\nret = dpcm_be_dai_hw_params(fe, substream->stream);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"dpcm: hw_params BE failed %d\n", ret);\r\ngoto out;\r\n}\r\ndev_dbg(fe->dev, "dpcm: hw_params FE %s rate %d chan %x fmt %d\n",\r\nfe->dai_link->name, params_rate(params),\r\nparams_channels(params), params_format(params));\r\nret = soc_pcm_hw_params(substream, params);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"dpcm: hw_params FE failed %d\n", ret);\r\ndpcm_be_dai_hw_free(fe, stream);\r\n} else\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_PARAMS;\r\nout:\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nmutex_unlock(&fe->card->mutex);\r\nreturn ret;\r\n}\r\nstatic int dpcm_do_trigger(struct snd_soc_dpcm *dpcm,\r\nstruct snd_pcm_substream *substream, int cmd)\r\n{\r\nint ret;\r\ndev_dbg(dpcm->be->dev, "dpcm: trigger BE %s cmd %d\n",\r\ndpcm->fe->dai_link->name, cmd);\r\nret = soc_pcm_trigger(substream, cmd);\r\nif (ret < 0)\r\ndev_err(dpcm->be->dev,"dpcm: trigger BE failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int dpcm_be_dai_trigger(struct snd_soc_pcm_runtime *fe, int stream,\r\nint cmd)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nint ret = 0;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_PREPARE) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))\r\ncontinue;\r\nret = dpcm_do_trigger(dpcm, be_substream, cmd);\r\nif (ret)\r\nreturn ret;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_SUSPEND))\r\ncontinue;\r\nret = dpcm_do_trigger(dpcm, be_substream, cmd);\r\nif (ret)\r\nreturn ret;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_PAUSED))\r\ncontinue;\r\nret = dpcm_do_trigger(dpcm, be_substream, cmd);\r\nif (ret)\r\nreturn ret;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_START)\r\ncontinue;\r\nif (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))\r\ncontinue;\r\nret = dpcm_do_trigger(dpcm, be_substream, cmd);\r\nif (ret)\r\nreturn ret;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_STOP;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP)\r\ncontinue;\r\nif (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))\r\ncontinue;\r\nret = dpcm_do_trigger(dpcm, be_substream, cmd);\r\nif (ret)\r\nreturn ret;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_SUSPEND;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_START)\r\ncontinue;\r\nif (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))\r\ncontinue;\r\nret = dpcm_do_trigger(dpcm, be_substream, cmd);\r\nif (ret)\r\nreturn ret;\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_PAUSED;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int dpcm_fe_dai_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = substream->private_data;\r\nint stream = substream->stream, ret;\r\nenum snd_soc_dpcm_trigger trigger = fe->dai_link->trigger[stream];\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\r\nswitch (trigger) {\r\ncase SND_SOC_DPCM_TRIGGER_PRE:\r\ndev_dbg(fe->dev, "dpcm: pre trigger FE %s cmd %d\n",\r\nfe->dai_link->name, cmd);\r\nret = soc_pcm_trigger(substream, cmd);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"dpcm: trigger FE failed %d\n", ret);\r\ngoto out;\r\n}\r\nret = dpcm_be_dai_trigger(fe, substream->stream, cmd);\r\nbreak;\r\ncase SND_SOC_DPCM_TRIGGER_POST:\r\nret = dpcm_be_dai_trigger(fe, substream->stream, cmd);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"dpcm: trigger FE failed %d\n", ret);\r\ngoto out;\r\n}\r\ndev_dbg(fe->dev, "dpcm: post trigger FE %s cmd %d\n",\r\nfe->dai_link->name, cmd);\r\nret = soc_pcm_trigger(substream, cmd);\r\nbreak;\r\ncase SND_SOC_DPCM_TRIGGER_BESPOKE:\r\ndev_dbg(fe->dev, "dpcm: bespoke trigger FE %s cmd %d\n",\r\nfe->dai_link->name, cmd);\r\nret = soc_pcm_bespoke_trigger(substream, cmd);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"dpcm: trigger FE failed %d\n", ret);\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(fe->dev, "dpcm: invalid trigger cmd %d for %s\n", cmd,\r\nfe->dai_link->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_STOP;\r\nbreak;\r\n}\r\nout:\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nreturn ret;\r\n}\r\nstatic int dpcm_be_dai_prepare(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nint ret = 0;\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_pcm_substream *be_substream =\r\nsnd_soc_dpcm_get_substream(be, stream);\r\nif (!snd_soc_dpcm_be_can_update(fe, be, stream))\r\ncontinue;\r\nif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&\r\n(be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))\r\ncontinue;\r\ndev_dbg(be->dev, "dpcm: prepare BE %s\n",\r\ndpcm->fe->dai_link->name);\r\nret = soc_pcm_prepare(be_substream);\r\nif (ret < 0) {\r\ndev_err(be->dev, "dpcm: backend prepare failed %d\n",\r\nret);\r\nbreak;\r\n}\r\nbe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dpcm_fe_dai_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = substream->private_data;\r\nint stream = substream->stream, ret = 0;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\ndev_dbg(fe->dev, "dpcm: prepare FE %s\n", fe->dai_link->name);\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\r\nif (list_empty(&fe->dpcm[stream].be_clients)) {\r\ndev_err(fe->dev, "dpcm: no backend DAIs enabled for %s\n",\r\nfe->dai_link->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = dpcm_be_dai_prepare(fe, substream->stream);\r\nif (ret < 0)\r\ngoto out;\r\nret = soc_pcm_prepare(substream);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"dpcm: prepare FE %s failed\n",\r\nfe->dai_link->name);\r\ngoto out;\r\n}\r\ndpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_START);\r\nfe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;\r\nout:\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nmutex_unlock(&fe->card->mutex);\r\nreturn ret;\r\n}\r\nstatic int soc_pcm_ioctl(struct snd_pcm_substream *substream,\r\nunsigned int cmd, void *arg)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nif (platform->driver->ops->ioctl)\r\nreturn platform->driver->ops->ioctl(substream, cmd, arg);\r\nreturn snd_pcm_lib_ioctl(substream, cmd, arg);\r\n}\r\nstatic int dpcm_run_update_shutdown(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_pcm_substream *substream =\r\nsnd_soc_dpcm_get_substream(fe, stream);\r\nenum snd_soc_dpcm_trigger trigger = fe->dai_link->trigger[stream];\r\nint err;\r\ndev_dbg(fe->dev, "runtime %s close on FE %s\n",\r\nstream ? "capture" : "playback", fe->dai_link->name);\r\nif (trigger == SND_SOC_DPCM_TRIGGER_BESPOKE) {\r\ndev_dbg(fe->dev, "dpcm: bespoke trigger FE %s cmd stop\n",\r\nfe->dai_link->name);\r\nerr = soc_pcm_bespoke_trigger(substream, SNDRV_PCM_TRIGGER_STOP);\r\nif (err < 0)\r\ndev_err(fe->dev,"dpcm: trigger FE failed %d\n", err);\r\n} else {\r\ndev_dbg(fe->dev, "dpcm: trigger FE %s cmd stop\n",\r\nfe->dai_link->name);\r\nerr = dpcm_be_dai_trigger(fe, stream, SNDRV_PCM_TRIGGER_STOP);\r\nif (err < 0)\r\ndev_err(fe->dev,"dpcm: trigger FE failed %d\n", err);\r\n}\r\nerr = dpcm_be_dai_hw_free(fe, stream);\r\nif (err < 0)\r\ndev_err(fe->dev,"dpcm: hw_free FE failed %d\n", err);\r\nerr = dpcm_be_dai_shutdown(fe, stream);\r\nif (err < 0)\r\ndev_err(fe->dev,"dpcm: shutdown FE failed %d\n", err);\r\ndpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_NOP);\r\nreturn 0;\r\n}\r\nstatic int dpcm_run_update_startup(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nstruct snd_pcm_substream *substream =\r\nsnd_soc_dpcm_get_substream(fe, stream);\r\nstruct snd_soc_dpcm *dpcm;\r\nenum snd_soc_dpcm_trigger trigger = fe->dai_link->trigger[stream];\r\nint ret;\r\ndev_dbg(fe->dev, "runtime %s open on FE %s\n",\r\nstream ? "capture" : "playback", fe->dai_link->name);\r\nif (fe->dpcm[stream].state == SND_SOC_DPCM_STATE_HW_FREE ||\r\nfe->dpcm[stream].state == SND_SOC_DPCM_STATE_CLOSE)\r\nreturn -EINVAL;\r\nret = dpcm_be_dai_startup(fe, stream);\r\nif (ret < 0) {\r\ngoto disconnect;\r\nreturn ret;\r\n}\r\nif (fe->dpcm[stream].state == SND_SOC_DPCM_STATE_OPEN)\r\nreturn 0;\r\nret = dpcm_be_dai_hw_params(fe, stream);\r\nif (ret < 0) {\r\ngoto close;\r\nreturn ret;\r\n}\r\nif (fe->dpcm[stream].state == SND_SOC_DPCM_STATE_HW_PARAMS)\r\nreturn 0;\r\nret = dpcm_be_dai_prepare(fe, stream);\r\nif (ret < 0) {\r\ngoto hw_free;\r\nreturn ret;\r\n}\r\ndpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_NOP);\r\nif (fe->dpcm[stream].state == SND_SOC_DPCM_STATE_PREPARE ||\r\nfe->dpcm[stream].state == SND_SOC_DPCM_STATE_STOP)\r\nreturn 0;\r\nif (trigger == SND_SOC_DPCM_TRIGGER_BESPOKE) {\r\ndev_dbg(fe->dev, "dpcm: bespoke trigger FE %s cmd start\n",\r\nfe->dai_link->name);\r\nret = soc_pcm_bespoke_trigger(substream, SNDRV_PCM_TRIGGER_START);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"dpcm: bespoke trigger FE failed %d\n", ret);\r\ngoto hw_free;\r\n}\r\n} else {\r\ndev_dbg(fe->dev, "dpcm: trigger FE %s cmd start\n",\r\nfe->dai_link->name);\r\nret = dpcm_be_dai_trigger(fe, stream,\r\nSNDRV_PCM_TRIGGER_START);\r\nif (ret < 0) {\r\ndev_err(fe->dev,"dpcm: trigger FE failed %d\n", ret);\r\ngoto hw_free;\r\n}\r\n}\r\nreturn 0;\r\nhw_free:\r\ndpcm_be_dai_hw_free(fe, stream);\r\nclose:\r\ndpcm_be_dai_shutdown(fe, stream);\r\ndisconnect:\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_START)\r\ndpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dpcm_run_new_update(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nint ret;\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_BE;\r\nret = dpcm_run_update_startup(fe, stream);\r\nif (ret < 0)\r\ndev_err(fe->dev, "failed to startup some BEs\n");\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nreturn ret;\r\n}\r\nstatic int dpcm_run_old_update(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nint ret;\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_BE;\r\nret = dpcm_run_update_shutdown(fe, stream);\r\nif (ret < 0)\r\ndev_err(fe->dev, "failed to shutdown some BEs\n");\r\nfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\r\nreturn ret;\r\n}\r\nint soc_dpcm_runtime_update(struct snd_soc_dapm_widget *widget)\r\n{\r\nstruct snd_soc_card *card;\r\nint i, old, new, paths;\r\nif (widget->codec)\r\ncard = widget->codec->card;\r\nelse if (widget->platform)\r\ncard = widget->platform->card;\r\nelse\r\nreturn -EINVAL;\r\nmutex_lock_nested(&card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\nfor (i = 0; i < card->num_rtd; i++) {\r\nstruct snd_soc_dapm_widget_list *list;\r\nstruct snd_soc_pcm_runtime *fe = &card->rtd[i];\r\nif (!fe->dai_link->dynamic)\r\ncontinue;\r\nif (!fe->cpu_dai->active)\r\ncontinue;\r\ndev_dbg(fe->dev, "DPCM runtime update for FE %s\n",\r\nfe->dai_link->name);\r\nif (!fe->cpu_dai->driver->playback.channels_min)\r\ngoto capture;\r\npaths = dpcm_path_get(fe, SNDRV_PCM_STREAM_PLAYBACK, &list);\r\nif (paths < 0) {\r\ndev_warn(fe->dev, "%s no valid %s path\n",\r\nfe->dai_link->name, "playback");\r\nmutex_unlock(&card->mutex);\r\nreturn paths;\r\n}\r\nnew = dpcm_process_paths(fe, SNDRV_PCM_STREAM_PLAYBACK, &list, 1);\r\nif (new) {\r\ndpcm_run_new_update(fe, SNDRV_PCM_STREAM_PLAYBACK);\r\ndpcm_clear_pending_state(fe, SNDRV_PCM_STREAM_PLAYBACK);\r\ndpcm_be_disconnect(fe, SNDRV_PCM_STREAM_PLAYBACK);\r\n}\r\nold = dpcm_process_paths(fe, SNDRV_PCM_STREAM_PLAYBACK, &list, 0);\r\nif (old) {\r\ndpcm_run_old_update(fe, SNDRV_PCM_STREAM_PLAYBACK);\r\ndpcm_clear_pending_state(fe, SNDRV_PCM_STREAM_PLAYBACK);\r\ndpcm_be_disconnect(fe, SNDRV_PCM_STREAM_PLAYBACK);\r\n}\r\ncapture:\r\nif (!fe->cpu_dai->driver->capture.channels_min)\r\ncontinue;\r\npaths = dpcm_path_get(fe, SNDRV_PCM_STREAM_CAPTURE, &list);\r\nif (paths < 0) {\r\ndev_warn(fe->dev, "%s no valid %s path\n",\r\nfe->dai_link->name, "capture");\r\nmutex_unlock(&card->mutex);\r\nreturn paths;\r\n}\r\nnew = dpcm_process_paths(fe, SNDRV_PCM_STREAM_CAPTURE, &list, 1);\r\nif (new) {\r\ndpcm_run_new_update(fe, SNDRV_PCM_STREAM_CAPTURE);\r\ndpcm_clear_pending_state(fe, SNDRV_PCM_STREAM_CAPTURE);\r\ndpcm_be_disconnect(fe, SNDRV_PCM_STREAM_CAPTURE);\r\n}\r\nold = dpcm_process_paths(fe, SNDRV_PCM_STREAM_CAPTURE, &list, 0);\r\nif (old) {\r\ndpcm_run_old_update(fe, SNDRV_PCM_STREAM_CAPTURE);\r\ndpcm_clear_pending_state(fe, SNDRV_PCM_STREAM_CAPTURE);\r\ndpcm_be_disconnect(fe, SNDRV_PCM_STREAM_CAPTURE);\r\n}\r\ndpcm_path_put(&list);\r\n}\r\nmutex_unlock(&card->mutex);\r\nreturn 0;\r\n}\r\nint soc_dpcm_be_digital_mute(struct snd_soc_pcm_runtime *fe, int mute)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nstruct list_head *clients =\r\n&fe->dpcm[SNDRV_PCM_STREAM_PLAYBACK].be_clients;\r\nlist_for_each_entry(dpcm, clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nstruct snd_soc_dai *dai = be->codec_dai;\r\nstruct snd_soc_dai_driver *drv = dai->driver;\r\nif (be->dai_link->ignore_suspend)\r\ncontinue;\r\ndev_dbg(be->dev, "BE digital mute %s\n", be->dai_link->name);\r\nif (drv->ops->digital_mute && dai->playback_active)\r\ndrv->ops->digital_mute(dai, mute);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dpcm_fe_dai_open(struct snd_pcm_substream *fe_substream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = fe_substream->private_data;\r\nstruct snd_soc_dpcm *dpcm;\r\nstruct snd_soc_dapm_widget_list *list;\r\nint ret;\r\nint stream = fe_substream->stream;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\nfe->dpcm[stream].runtime = fe_substream->runtime;\r\nif (dpcm_path_get(fe, stream, &list) <= 0) {\r\ndev_dbg(fe->dev, "asoc: %s no valid %s route\n",\r\nfe->dai_link->name, stream ? "capture" : "playback");\r\n}\r\ndpcm_process_paths(fe, stream, &list, 1);\r\nret = dpcm_fe_dai_startup(fe_substream);\r\nif (ret < 0) {\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be)\r\ndpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\r\ndpcm_be_disconnect(fe, stream);\r\nfe->dpcm[stream].runtime = NULL;\r\n}\r\ndpcm_clear_pending_state(fe, stream);\r\ndpcm_path_put(&list);\r\nmutex_unlock(&fe->card->mutex);\r\nreturn ret;\r\n}\r\nstatic int dpcm_fe_dai_close(struct snd_pcm_substream *fe_substream)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = fe_substream->private_data;\r\nstruct snd_soc_dpcm *dpcm;\r\nint stream = fe_substream->stream, ret;\r\nmutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);\r\nret = dpcm_fe_dai_shutdown(fe_substream);\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be)\r\ndpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\r\ndpcm_be_disconnect(fe, stream);\r\nfe->dpcm[stream].runtime = NULL;\r\nmutex_unlock(&fe->card->mutex);\r\nreturn ret;\r\n}\r\nint soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)\r\n{\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct snd_pcm *pcm;\r\nchar new_name[64];\r\nint ret = 0, playback = 0, capture = 0;\r\nif (rtd->dai_link->dynamic || rtd->dai_link->no_pcm) {\r\nif (cpu_dai->driver->playback.channels_min)\r\nplayback = 1;\r\nif (cpu_dai->driver->capture.channels_min)\r\ncapture = 1;\r\n} else {\r\nif (codec_dai->driver->playback.channels_min)\r\nplayback = 1;\r\nif (codec_dai->driver->capture.channels_min)\r\ncapture = 1;\r\n}\r\nif (rtd->dai_link->no_pcm) {\r\nsnprintf(new_name, sizeof(new_name), "(%s)",\r\nrtd->dai_link->stream_name);\r\nret = snd_pcm_new_internal(rtd->card->snd_card, new_name, num,\r\nplayback, capture, &pcm);\r\n} else {\r\nif (rtd->dai_link->dynamic)\r\nsnprintf(new_name, sizeof(new_name), "%s (*)",\r\nrtd->dai_link->stream_name);\r\nelse\r\nsnprintf(new_name, sizeof(new_name), "%s %s-%d",\r\nrtd->dai_link->stream_name, codec_dai->name, num);\r\nret = snd_pcm_new(rtd->card->snd_card, new_name, num, playback,\r\ncapture, &pcm);\r\n}\r\nif (ret < 0) {\r\ndev_err(rtd->card->dev, "can't create pcm for %s\n",\r\nrtd->dai_link->name);\r\nreturn ret;\r\n}\r\ndev_dbg(rtd->card->dev, "registered pcm #%d %s\n",num, new_name);\r\nINIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);\r\nrtd->pcm = pcm;\r\npcm->private_data = rtd;\r\nif (rtd->dai_link->no_pcm) {\r\nif (playback)\r\npcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->private_data = rtd;\r\nif (capture)\r\npcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->private_data = rtd;\r\ngoto out;\r\n}\r\nif (rtd->dai_link->dynamic) {\r\nrtd->ops.open = dpcm_fe_dai_open;\r\nrtd->ops.hw_params = dpcm_fe_dai_hw_params;\r\nrtd->ops.prepare = dpcm_fe_dai_prepare;\r\nrtd->ops.trigger = dpcm_fe_dai_trigger;\r\nrtd->ops.hw_free = dpcm_fe_dai_hw_free;\r\nrtd->ops.close = dpcm_fe_dai_close;\r\nrtd->ops.pointer = soc_pcm_pointer;\r\nrtd->ops.ioctl = soc_pcm_ioctl;\r\n} else {\r\nrtd->ops.open = soc_pcm_open;\r\nrtd->ops.hw_params = soc_pcm_hw_params;\r\nrtd->ops.prepare = soc_pcm_prepare;\r\nrtd->ops.trigger = soc_pcm_trigger;\r\nrtd->ops.hw_free = soc_pcm_hw_free;\r\nrtd->ops.close = soc_pcm_close;\r\nrtd->ops.pointer = soc_pcm_pointer;\r\nrtd->ops.ioctl = soc_pcm_ioctl;\r\n}\r\nif (platform->driver->ops) {\r\nrtd->ops.ack = platform->driver->ops->ack;\r\nrtd->ops.copy = platform->driver->ops->copy;\r\nrtd->ops.silence = platform->driver->ops->silence;\r\nrtd->ops.page = platform->driver->ops->page;\r\nrtd->ops.mmap = platform->driver->ops->mmap;\r\n}\r\nif (playback)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &rtd->ops);\r\nif (capture)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &rtd->ops);\r\nif (platform->driver->pcm_new) {\r\nret = platform->driver->pcm_new(rtd);\r\nif (ret < 0) {\r\ndev_err(platform->dev, "pcm constructor failed\n");\r\nreturn ret;\r\n}\r\n}\r\npcm->private_free = platform->driver->pcm_free;\r\nout:\r\ndev_info(rtd->card->dev, " %s <-> %s mapping ok\n", codec_dai->name,\r\ncpu_dai->name);\r\nreturn ret;\r\n}\r\nint snd_soc_dpcm_fe_can_update(struct snd_soc_pcm_runtime *fe, int stream)\r\n{\r\nif (fe->dpcm[stream].runtime_update == SND_SOC_DPCM_UPDATE_FE)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint snd_soc_dpcm_be_can_update(struct snd_soc_pcm_runtime *fe,\r\nstruct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nif ((fe->dpcm[stream].runtime_update == SND_SOC_DPCM_UPDATE_FE) ||\r\n((fe->dpcm[stream].runtime_update == SND_SOC_DPCM_UPDATE_BE) &&\r\nbe->dpcm[stream].runtime_update))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstruct snd_pcm_substream *\r\nsnd_soc_dpcm_get_substream(struct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nreturn be->pcm->streams[stream].substream;\r\n}\r\nenum snd_soc_dpcm_state\r\nsnd_soc_dpcm_be_get_state(struct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nreturn be->dpcm[stream].state;\r\n}\r\nvoid snd_soc_dpcm_be_set_state(struct snd_soc_pcm_runtime *be,\r\nint stream, enum snd_soc_dpcm_state state)\r\n{\r\nbe->dpcm[stream].state = state;\r\n}\r\nint snd_soc_dpcm_can_be_free_stop(struct snd_soc_pcm_runtime *fe,\r\nstruct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nint state;\r\nlist_for_each_entry(dpcm, &be->dpcm[stream].fe_clients, list_fe) {\r\nif (dpcm->fe == fe)\r\ncontinue;\r\nstate = dpcm->fe->dpcm[stream].state;\r\nif (state == SND_SOC_DPCM_STATE_START ||\r\nstate == SND_SOC_DPCM_STATE_PAUSED ||\r\nstate == SND_SOC_DPCM_STATE_SUSPEND)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint snd_soc_dpcm_can_be_params(struct snd_soc_pcm_runtime *fe,\r\nstruct snd_soc_pcm_runtime *be, int stream)\r\n{\r\nstruct snd_soc_dpcm *dpcm;\r\nint state;\r\nlist_for_each_entry(dpcm, &be->dpcm[stream].fe_clients, list_fe) {\r\nif (dpcm->fe == fe)\r\ncontinue;\r\nstate = dpcm->fe->dpcm[stream].state;\r\nif (state == SND_SOC_DPCM_STATE_START ||\r\nstate == SND_SOC_DPCM_STATE_PAUSED ||\r\nstate == SND_SOC_DPCM_STATE_SUSPEND ||\r\nstate == SND_SOC_DPCM_STATE_PREPARE)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint snd_soc_platform_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_platform *platform)\r\n{\r\nif (platform->driver->ops->trigger)\r\nreturn platform->driver->ops->trigger(substream, cmd);\r\nreturn 0;\r\n}\r\nstatic char *dpcm_state_string(enum snd_soc_dpcm_state state)\r\n{\r\nswitch (state) {\r\ncase SND_SOC_DPCM_STATE_NEW:\r\nreturn "new";\r\ncase SND_SOC_DPCM_STATE_OPEN:\r\nreturn "open";\r\ncase SND_SOC_DPCM_STATE_HW_PARAMS:\r\nreturn "hw_params";\r\ncase SND_SOC_DPCM_STATE_PREPARE:\r\nreturn "prepare";\r\ncase SND_SOC_DPCM_STATE_START:\r\nreturn "start";\r\ncase SND_SOC_DPCM_STATE_STOP:\r\nreturn "stop";\r\ncase SND_SOC_DPCM_STATE_SUSPEND:\r\nreturn "suspend";\r\ncase SND_SOC_DPCM_STATE_PAUSED:\r\nreturn "paused";\r\ncase SND_SOC_DPCM_STATE_HW_FREE:\r\nreturn "hw_free";\r\ncase SND_SOC_DPCM_STATE_CLOSE:\r\nreturn "close";\r\n}\r\nreturn "unknown";\r\n}\r\nstatic ssize_t dpcm_show_state(struct snd_soc_pcm_runtime *fe,\r\nint stream, char *buf, size_t size)\r\n{\r\nstruct snd_pcm_hw_params *params = &fe->dpcm[stream].hw_params;\r\nstruct snd_soc_dpcm *dpcm;\r\nssize_t offset = 0;\r\noffset += snprintf(buf + offset, size - offset,\r\n"[%s - %s]\n", fe->dai_link->name,\r\nstream ? "Capture" : "Playback");\r\noffset += snprintf(buf + offset, size - offset, "State: %s\n",\r\ndpcm_state_string(fe->dpcm[stream].state));\r\nif ((fe->dpcm[stream].state >= SND_SOC_DPCM_STATE_HW_PARAMS) &&\r\n(fe->dpcm[stream].state <= SND_SOC_DPCM_STATE_STOP))\r\noffset += snprintf(buf + offset, size - offset,\r\n"Hardware Params: "\r\n"Format = %s, Channels = %d, Rate = %d\n",\r\nsnd_pcm_format_name(params_format(params)),\r\nparams_channels(params),\r\nparams_rate(params));\r\noffset += snprintf(buf + offset, size - offset, "Backends:\n");\r\nif (list_empty(&fe->dpcm[stream].be_clients)) {\r\noffset += snprintf(buf + offset, size - offset,\r\n" No active DSP links\n");\r\ngoto out;\r\n}\r\nlist_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be) {\r\nstruct snd_soc_pcm_runtime *be = dpcm->be;\r\nparams = &dpcm->hw_params;\r\noffset += snprintf(buf + offset, size - offset,\r\n"- %s\n", be->dai_link->name);\r\noffset += snprintf(buf + offset, size - offset,\r\n" State: %s\n",\r\ndpcm_state_string(be->dpcm[stream].state));\r\nif ((be->dpcm[stream].state >= SND_SOC_DPCM_STATE_HW_PARAMS) &&\r\n(be->dpcm[stream].state <= SND_SOC_DPCM_STATE_STOP))\r\noffset += snprintf(buf + offset, size - offset,\r\n" Hardware Params: "\r\n"Format = %s, Channels = %d, Rate = %d\n",\r\nsnd_pcm_format_name(params_format(params)),\r\nparams_channels(params),\r\nparams_rate(params));\r\n}\r\nout:\r\nreturn offset;\r\n}\r\nstatic ssize_t dpcm_state_read_file(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct snd_soc_pcm_runtime *fe = file->private_data;\r\nssize_t out_count = PAGE_SIZE, offset = 0, ret = 0;\r\nchar *buf;\r\nbuf = kmalloc(out_count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (fe->cpu_dai->driver->playback.channels_min)\r\noffset += dpcm_show_state(fe, SNDRV_PCM_STREAM_PLAYBACK,\r\nbuf + offset, out_count - offset);\r\nif (fe->cpu_dai->driver->capture.channels_min)\r\noffset += dpcm_show_state(fe, SNDRV_PCM_STREAM_CAPTURE,\r\nbuf + offset, out_count - offset);\r\nret = simple_read_from_buffer(user_buf, count, ppos, buf, offset);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nint soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nif (!rtd->dai_link)\r\nreturn 0;\r\nrtd->debugfs_dpcm_root = debugfs_create_dir(rtd->dai_link->name,\r\nrtd->card->debugfs_card_root);\r\nif (!rtd->debugfs_dpcm_root) {\r\ndev_dbg(rtd->dev,\r\n"ASoC: Failed to create dpcm debugfs directory %s\n",\r\nrtd->dai_link->name);\r\nreturn -EINVAL;\r\n}\r\nrtd->debugfs_dpcm_state = debugfs_create_file("state", 0444,\r\nrtd->debugfs_dpcm_root,\r\nrtd, &dpcm_state_fops);\r\nreturn 0;\r\n}
