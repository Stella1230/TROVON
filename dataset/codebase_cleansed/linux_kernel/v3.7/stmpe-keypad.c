static int stmpe_keypad_read_data(struct stmpe_keypad *keypad, u8 *data)\r\n{\r\nconst struct stmpe_keypad_variant *variant = keypad->variant;\r\nstruct stmpe *stmpe = keypad->stmpe;\r\nint ret;\r\nint i;\r\nif (variant->auto_increment)\r\nreturn stmpe_block_read(stmpe, STMPE_KPC_DATA_BYTE0,\r\nvariant->num_data, data);\r\nfor (i = 0; i < variant->num_data; i++) {\r\nret = stmpe_reg_read(stmpe, STMPE_KPC_DATA_BYTE0 + i);\r\nif (ret < 0)\r\nreturn ret;\r\ndata[i] = ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t stmpe_keypad_irq(int irq, void *dev)\r\n{\r\nstruct stmpe_keypad *keypad = dev;\r\nstruct input_dev *input = keypad->input;\r\nconst struct stmpe_keypad_variant *variant = keypad->variant;\r\nu8 fifo[variant->num_data];\r\nint ret;\r\nint i;\r\nret = stmpe_keypad_read_data(keypad, fifo);\r\nif (ret < 0)\r\nreturn IRQ_NONE;\r\nfor (i = 0; i < variant->num_normal_data; i++) {\r\nu8 data = fifo[i];\r\nint row = (data & STMPE_KPC_DATA_ROW) >> 3;\r\nint col = data & STMPE_KPC_DATA_COL;\r\nint code = MATRIX_SCAN_CODE(row, col, STMPE_KEYPAD_ROW_SHIFT);\r\nbool up = data & STMPE_KPC_DATA_UP;\r\nif ((data & STMPE_KPC_DATA_NOKEY_MASK)\r\n== STMPE_KPC_DATA_NOKEY_MASK)\r\ncontinue;\r\ninput_event(input, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input, keypad->keymap[code], !up);\r\ninput_sync(input);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit stmpe_keypad_altfunc_init(struct stmpe_keypad *keypad)\r\n{\r\nconst struct stmpe_keypad_variant *variant = keypad->variant;\r\nunsigned int col_gpios = variant->col_gpios;\r\nunsigned int row_gpios = variant->row_gpios;\r\nstruct stmpe *stmpe = keypad->stmpe;\r\nunsigned int pins = 0;\r\nint i;\r\nfor (i = 0; i < variant->max_cols; i++) {\r\nint num = __ffs(col_gpios);\r\nif (keypad->cols & (1 << i))\r\npins |= 1 << num;\r\ncol_gpios &= ~(1 << num);\r\n}\r\nfor (i = 0; i < variant->max_rows; i++) {\r\nint num = __ffs(row_gpios);\r\nif (keypad->rows & (1 << i))\r\npins |= 1 << num;\r\nrow_gpios &= ~(1 << num);\r\n}\r\nreturn stmpe_set_altfunc(stmpe, pins, STMPE_BLOCK_KEYPAD);\r\n}\r\nstatic int __devinit stmpe_keypad_chip_init(struct stmpe_keypad *keypad)\r\n{\r\nconst struct stmpe_keypad_platform_data *plat = keypad->plat;\r\nconst struct stmpe_keypad_variant *variant = keypad->variant;\r\nstruct stmpe *stmpe = keypad->stmpe;\r\nint ret;\r\nif (plat->debounce_ms > STMPE_KEYPAD_MAX_DEBOUNCE)\r\nreturn -EINVAL;\r\nif (plat->scan_count > STMPE_KEYPAD_MAX_SCAN_COUNT)\r\nreturn -EINVAL;\r\nret = stmpe_enable(stmpe, STMPE_BLOCK_KEYPAD);\r\nif (ret < 0)\r\nreturn ret;\r\nret = stmpe_keypad_altfunc_init(keypad);\r\nif (ret < 0)\r\nreturn ret;\r\nret = stmpe_reg_write(stmpe, STMPE_KPC_COL, keypad->cols);\r\nif (ret < 0)\r\nreturn ret;\r\nret = stmpe_reg_write(stmpe, STMPE_KPC_ROW_LSB, keypad->rows);\r\nif (ret < 0)\r\nreturn ret;\r\nif (variant->max_rows > 8) {\r\nret = stmpe_set_bits(stmpe, STMPE_KPC_ROW_MSB,\r\nSTMPE_KPC_ROW_MSB_ROWS,\r\nkeypad->rows >> 8);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = stmpe_set_bits(stmpe, STMPE_KPC_CTRL_MSB,\r\nSTMPE_KPC_CTRL_MSB_SCAN_COUNT,\r\nplat->scan_count << 4);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn stmpe_set_bits(stmpe, STMPE_KPC_CTRL_LSB,\r\nSTMPE_KPC_CTRL_LSB_SCAN |\r\nSTMPE_KPC_CTRL_LSB_DEBOUNCE,\r\nSTMPE_KPC_CTRL_LSB_SCAN |\r\n(plat->debounce_ms << 1));\r\n}\r\nstatic int __devinit stmpe_keypad_probe(struct platform_device *pdev)\r\n{\r\nstruct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);\r\nstruct stmpe_keypad_platform_data *plat;\r\nstruct stmpe_keypad *keypad;\r\nstruct input_dev *input;\r\nint ret;\r\nint irq;\r\nint i;\r\nplat = stmpe->pdata->keypad;\r\nif (!plat)\r\nreturn -ENODEV;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nkeypad = kzalloc(sizeof(struct stmpe_keypad), GFP_KERNEL);\r\nif (!keypad)\r\nreturn -ENOMEM;\r\ninput = input_allocate_device();\r\nif (!input) {\r\nret = -ENOMEM;\r\ngoto out_freekeypad;\r\n}\r\ninput->name = "STMPE keypad";\r\ninput->id.bustype = BUS_I2C;\r\ninput->dev.parent = &pdev->dev;\r\nret = matrix_keypad_build_keymap(plat->keymap_data, NULL,\r\nSTMPE_KEYPAD_MAX_ROWS,\r\nSTMPE_KEYPAD_MAX_COLS,\r\nkeypad->keymap, input);\r\nif (ret)\r\ngoto out_freeinput;\r\ninput_set_capability(input, EV_MSC, MSC_SCAN);\r\nif (!plat->no_autorepeat)\r\n__set_bit(EV_REP, input->evbit);\r\nfor (i = 0; i < plat->keymap_data->keymap_size; i++) {\r\nunsigned int key = plat->keymap_data->keymap[i];\r\nkeypad->cols |= 1 << KEY_COL(key);\r\nkeypad->rows |= 1 << KEY_ROW(key);\r\n}\r\nkeypad->stmpe = stmpe;\r\nkeypad->plat = plat;\r\nkeypad->input = input;\r\nkeypad->variant = &stmpe_keypad_variants[stmpe->partnum];\r\nret = stmpe_keypad_chip_init(keypad);\r\nif (ret < 0)\r\ngoto out_freeinput;\r\nret = input_register_device(input);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"unable to register input device: %d\n", ret);\r\ngoto out_freeinput;\r\n}\r\nret = request_threaded_irq(irq, NULL, stmpe_keypad_irq, IRQF_ONESHOT,\r\n"stmpe-keypad", keypad);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to get irq: %d\n", ret);\r\ngoto out_unregisterinput;\r\n}\r\nplatform_set_drvdata(pdev, keypad);\r\nreturn 0;\r\nout_unregisterinput:\r\ninput_unregister_device(input);\r\ninput = NULL;\r\nout_freeinput:\r\ninput_free_device(input);\r\nout_freekeypad:\r\nkfree(keypad);\r\nreturn ret;\r\n}\r\nstatic int __devexit stmpe_keypad_remove(struct platform_device *pdev)\r\n{\r\nstruct stmpe_keypad *keypad = platform_get_drvdata(pdev);\r\nstruct stmpe *stmpe = keypad->stmpe;\r\nint irq = platform_get_irq(pdev, 0);\r\nstmpe_disable(stmpe, STMPE_BLOCK_KEYPAD);\r\nfree_irq(irq, keypad);\r\ninput_unregister_device(keypad->input);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(keypad);\r\nreturn 0;\r\n}
