static inline struct arp_pkt *arp_pkt(const struct sk_buff *skb)\r\n{\r\nreturn (struct arp_pkt *)skb_network_header(skb);\r\n}\r\nstatic inline u8 _simple_hash(const u8 *hash_start, int hash_size)\r\n{\r\nint i;\r\nu8 hash = 0;\r\nfor (i = 0; i < hash_size; i++) {\r\nhash ^= hash_start[i];\r\n}\r\nreturn hash;\r\n}\r\nstatic inline void _lock_tx_hashtbl_bh(struct bonding *bond)\r\n{\r\nspin_lock_bh(&(BOND_ALB_INFO(bond).tx_hashtbl_lock));\r\n}\r\nstatic inline void _unlock_tx_hashtbl_bh(struct bonding *bond)\r\n{\r\nspin_unlock_bh(&(BOND_ALB_INFO(bond).tx_hashtbl_lock));\r\n}\r\nstatic inline void _lock_tx_hashtbl(struct bonding *bond)\r\n{\r\nspin_lock(&(BOND_ALB_INFO(bond).tx_hashtbl_lock));\r\n}\r\nstatic inline void _unlock_tx_hashtbl(struct bonding *bond)\r\n{\r\nspin_unlock(&(BOND_ALB_INFO(bond).tx_hashtbl_lock));\r\n}\r\nstatic inline void tlb_init_table_entry(struct tlb_client_info *entry, int save_load)\r\n{\r\nif (save_load) {\r\nentry->load_history = 1 + entry->tx_bytes /\r\nBOND_TLB_REBALANCE_INTERVAL;\r\nentry->tx_bytes = 0;\r\n}\r\nentry->tx_slave = NULL;\r\nentry->next = TLB_NULL_INDEX;\r\nentry->prev = TLB_NULL_INDEX;\r\n}\r\nstatic inline void tlb_init_slave(struct slave *slave)\r\n{\r\nSLAVE_TLB_INFO(slave).load = 0;\r\nSLAVE_TLB_INFO(slave).head = TLB_NULL_INDEX;\r\n}\r\nstatic void __tlb_clear_slave(struct bonding *bond, struct slave *slave,\r\nint save_load)\r\n{\r\nstruct tlb_client_info *tx_hash_table;\r\nu32 index;\r\ntx_hash_table = BOND_ALB_INFO(bond).tx_hashtbl;\r\nif (tx_hash_table) {\r\nindex = SLAVE_TLB_INFO(slave).head;\r\nwhile (index != TLB_NULL_INDEX) {\r\nu32 next_index = tx_hash_table[index].next;\r\ntlb_init_table_entry(&tx_hash_table[index], save_load);\r\nindex = next_index;\r\n}\r\n}\r\ntlb_init_slave(slave);\r\n}\r\nstatic void tlb_clear_slave(struct bonding *bond, struct slave *slave,\r\nint save_load)\r\n{\r\n_lock_tx_hashtbl_bh(bond);\r\n__tlb_clear_slave(bond, slave, save_load);\r\n_unlock_tx_hashtbl_bh(bond);\r\n}\r\nstatic int tlb_initialize(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nint size = TLB_HASH_TABLE_SIZE * sizeof(struct tlb_client_info);\r\nstruct tlb_client_info *new_hashtbl;\r\nint i;\r\nnew_hashtbl = kzalloc(size, GFP_KERNEL);\r\nif (!new_hashtbl)\r\nreturn -1;\r\n_lock_tx_hashtbl_bh(bond);\r\nbond_info->tx_hashtbl = new_hashtbl;\r\nfor (i = 0; i < TLB_HASH_TABLE_SIZE; i++) {\r\ntlb_init_table_entry(&bond_info->tx_hashtbl[i], 0);\r\n}\r\n_unlock_tx_hashtbl_bh(bond);\r\nreturn 0;\r\n}\r\nstatic void tlb_deinitialize(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\n_lock_tx_hashtbl_bh(bond);\r\nkfree(bond_info->tx_hashtbl);\r\nbond_info->tx_hashtbl = NULL;\r\n_unlock_tx_hashtbl_bh(bond);\r\n}\r\nstatic long long compute_gap(struct slave *slave)\r\n{\r\nreturn (s64) (slave->speed << 20) -\r\n(s64) (SLAVE_TLB_INFO(slave).load << 3);\r\n}\r\nstatic struct slave *tlb_get_least_loaded_slave(struct bonding *bond)\r\n{\r\nstruct slave *slave, *least_loaded;\r\nlong long max_gap;\r\nint i;\r\nleast_loaded = NULL;\r\nmax_gap = LLONG_MIN;\r\nbond_for_each_slave(bond, slave, i) {\r\nif (SLAVE_IS_OK(slave)) {\r\nlong long gap = compute_gap(slave);\r\nif (max_gap < gap) {\r\nleast_loaded = slave;\r\nmax_gap = gap;\r\n}\r\n}\r\n}\r\nreturn least_loaded;\r\n}\r\nstatic struct slave *__tlb_choose_channel(struct bonding *bond, u32 hash_index,\r\nu32 skb_len)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct tlb_client_info *hash_table;\r\nstruct slave *assigned_slave;\r\nhash_table = bond_info->tx_hashtbl;\r\nassigned_slave = hash_table[hash_index].tx_slave;\r\nif (!assigned_slave) {\r\nassigned_slave = tlb_get_least_loaded_slave(bond);\r\nif (assigned_slave) {\r\nstruct tlb_slave_info *slave_info =\r\n&(SLAVE_TLB_INFO(assigned_slave));\r\nu32 next_index = slave_info->head;\r\nhash_table[hash_index].tx_slave = assigned_slave;\r\nhash_table[hash_index].next = next_index;\r\nhash_table[hash_index].prev = TLB_NULL_INDEX;\r\nif (next_index != TLB_NULL_INDEX) {\r\nhash_table[next_index].prev = hash_index;\r\n}\r\nslave_info->head = hash_index;\r\nslave_info->load +=\r\nhash_table[hash_index].load_history;\r\n}\r\n}\r\nif (assigned_slave) {\r\nhash_table[hash_index].tx_bytes += skb_len;\r\n}\r\nreturn assigned_slave;\r\n}\r\nstatic struct slave *tlb_choose_channel(struct bonding *bond, u32 hash_index,\r\nu32 skb_len)\r\n{\r\nstruct slave *tx_slave;\r\n_lock_tx_hashtbl(bond);\r\ntx_slave = __tlb_choose_channel(bond, hash_index, skb_len);\r\n_unlock_tx_hashtbl(bond);\r\nreturn tx_slave;\r\n}\r\nstatic inline void _lock_rx_hashtbl_bh(struct bonding *bond)\r\n{\r\nspin_lock_bh(&(BOND_ALB_INFO(bond).rx_hashtbl_lock));\r\n}\r\nstatic inline void _unlock_rx_hashtbl_bh(struct bonding *bond)\r\n{\r\nspin_unlock_bh(&(BOND_ALB_INFO(bond).rx_hashtbl_lock));\r\n}\r\nstatic inline void _lock_rx_hashtbl(struct bonding *bond)\r\n{\r\nspin_lock(&(BOND_ALB_INFO(bond).rx_hashtbl_lock));\r\n}\r\nstatic inline void _unlock_rx_hashtbl(struct bonding *bond)\r\n{\r\nspin_unlock(&(BOND_ALB_INFO(bond).rx_hashtbl_lock));\r\n}\r\nstatic void rlb_update_entry_from_arp(struct bonding *bond, struct arp_pkt *arp)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct rlb_client_info *client_info;\r\nu32 hash_index;\r\n_lock_rx_hashtbl_bh(bond);\r\nhash_index = _simple_hash((u8*)&(arp->ip_src), sizeof(arp->ip_src));\r\nclient_info = &(bond_info->rx_hashtbl[hash_index]);\r\nif ((client_info->assigned) &&\r\n(client_info->ip_src == arp->ip_dst) &&\r\n(client_info->ip_dst == arp->ip_src) &&\r\n(!ether_addr_equal_64bits(client_info->mac_dst, arp->mac_src))) {\r\nmemcpy(client_info->mac_dst, arp->mac_src, ETH_ALEN);\r\nclient_info->ntt = 1;\r\nbond_info->rx_ntt = 1;\r\n}\r\n_unlock_rx_hashtbl_bh(bond);\r\n}\r\nstatic int rlb_arp_recv(const struct sk_buff *skb, struct bonding *bond,\r\nstruct slave *slave)\r\n{\r\nstruct arp_pkt *arp, _arp;\r\nif (skb->protocol != cpu_to_be16(ETH_P_ARP))\r\ngoto out;\r\narp = skb_header_pointer(skb, 0, sizeof(_arp), &_arp);\r\nif (!arp)\r\ngoto out;\r\nif (arp->op_code == htons(ARPOP_REPLY)) {\r\nrlb_update_entry_from_arp(bond, arp);\r\npr_debug("Server received an ARP Reply from client\n");\r\n}\r\nout:\r\nreturn RX_HANDLER_ANOTHER;\r\n}\r\nstatic struct slave *rlb_next_rx_slave(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct slave *rx_slave, *slave, *start_at;\r\nint i = 0;\r\nif (bond_info->next_rx_slave) {\r\nstart_at = bond_info->next_rx_slave;\r\n} else {\r\nstart_at = bond->first_slave;\r\n}\r\nrx_slave = NULL;\r\nbond_for_each_slave_from(bond, slave, i, start_at) {\r\nif (SLAVE_IS_OK(slave)) {\r\nif (!rx_slave) {\r\nrx_slave = slave;\r\n} else if (slave->speed > rx_slave->speed) {\r\nrx_slave = slave;\r\n}\r\n}\r\n}\r\nif (rx_slave) {\r\nbond_info->next_rx_slave = rx_slave->next;\r\n}\r\nreturn rx_slave;\r\n}\r\nstatic void rlb_teach_disabled_mac_on_primary(struct bonding *bond, u8 addr[])\r\n{\r\nif (!bond->curr_active_slave) {\r\nreturn;\r\n}\r\nif (!bond->alb_info.primary_is_promisc) {\r\nif (!dev_set_promiscuity(bond->curr_active_slave->dev, 1))\r\nbond->alb_info.primary_is_promisc = 1;\r\nelse\r\nbond->alb_info.primary_is_promisc = 0;\r\n}\r\nbond->alb_info.rlb_promisc_timeout_counter = 0;\r\nalb_send_learning_packets(bond->curr_active_slave, addr);\r\n}\r\nstatic void rlb_clear_slave(struct bonding *bond, struct slave *slave)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct rlb_client_info *rx_hash_table;\r\nu32 index, next_index;\r\n_lock_rx_hashtbl_bh(bond);\r\nrx_hash_table = bond_info->rx_hashtbl;\r\nindex = bond_info->rx_hashtbl_head;\r\nfor (; index != RLB_NULL_INDEX; index = next_index) {\r\nnext_index = rx_hash_table[index].next;\r\nif (rx_hash_table[index].slave == slave) {\r\nstruct slave *assigned_slave = rlb_next_rx_slave(bond);\r\nif (assigned_slave) {\r\nrx_hash_table[index].slave = assigned_slave;\r\nif (!ether_addr_equal_64bits(rx_hash_table[index].mac_dst,\r\nmac_bcast)) {\r\nbond_info->rx_hashtbl[index].ntt = 1;\r\nbond_info->rx_ntt = 1;\r\nbond_info->rlb_update_retry_counter =\r\nRLB_UPDATE_RETRY;\r\n}\r\n} else {\r\nrx_hash_table[index].slave = NULL;\r\n}\r\n}\r\n}\r\n_unlock_rx_hashtbl_bh(bond);\r\nwrite_lock_bh(&bond->curr_slave_lock);\r\nif (slave != bond->curr_active_slave) {\r\nrlb_teach_disabled_mac_on_primary(bond, slave->dev->dev_addr);\r\n}\r\nwrite_unlock_bh(&bond->curr_slave_lock);\r\n}\r\nstatic void rlb_update_client(struct rlb_client_info *client_info)\r\n{\r\nint i;\r\nif (!client_info->slave) {\r\nreturn;\r\n}\r\nfor (i = 0; i < RLB_ARP_BURST_SIZE; i++) {\r\nstruct sk_buff *skb;\r\nskb = arp_create(ARPOP_REPLY, ETH_P_ARP,\r\nclient_info->ip_dst,\r\nclient_info->slave->dev,\r\nclient_info->ip_src,\r\nclient_info->mac_dst,\r\nclient_info->slave->dev->dev_addr,\r\nclient_info->mac_dst);\r\nif (!skb) {\r\npr_err("%s: Error: failed to create an ARP packet\n",\r\nclient_info->slave->dev->master->name);\r\ncontinue;\r\n}\r\nskb->dev = client_info->slave->dev;\r\nif (client_info->tag) {\r\nskb = vlan_put_tag(skb, client_info->vlan_id);\r\nif (!skb) {\r\npr_err("%s: Error: failed to insert VLAN tag\n",\r\nclient_info->slave->dev->master->name);\r\ncontinue;\r\n}\r\n}\r\narp_xmit(skb);\r\n}\r\n}\r\nstatic void rlb_update_rx_clients(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct rlb_client_info *client_info;\r\nu32 hash_index;\r\n_lock_rx_hashtbl_bh(bond);\r\nhash_index = bond_info->rx_hashtbl_head;\r\nfor (; hash_index != RLB_NULL_INDEX; hash_index = client_info->next) {\r\nclient_info = &(bond_info->rx_hashtbl[hash_index]);\r\nif (client_info->ntt) {\r\nrlb_update_client(client_info);\r\nif (bond_info->rlb_update_retry_counter == 0) {\r\nclient_info->ntt = 0;\r\n}\r\n}\r\n}\r\nbond_info->rlb_update_delay_counter = RLB_UPDATE_DELAY;\r\n_unlock_rx_hashtbl_bh(bond);\r\n}\r\nstatic void rlb_req_update_slave_clients(struct bonding *bond, struct slave *slave)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct rlb_client_info *client_info;\r\nint ntt = 0;\r\nu32 hash_index;\r\n_lock_rx_hashtbl_bh(bond);\r\nhash_index = bond_info->rx_hashtbl_head;\r\nfor (; hash_index != RLB_NULL_INDEX; hash_index = client_info->next) {\r\nclient_info = &(bond_info->rx_hashtbl[hash_index]);\r\nif ((client_info->slave == slave) &&\r\n!ether_addr_equal_64bits(client_info->mac_dst, mac_bcast)) {\r\nclient_info->ntt = 1;\r\nntt = 1;\r\n}\r\n}\r\nif (ntt) {\r\nbond_info->rx_ntt = 1;\r\nbond_info->rlb_update_retry_counter = RLB_UPDATE_RETRY;\r\n}\r\n_unlock_rx_hashtbl_bh(bond);\r\n}\r\nstatic void rlb_req_update_subnet_clients(struct bonding *bond, __be32 src_ip)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct rlb_client_info *client_info;\r\nu32 hash_index;\r\n_lock_rx_hashtbl(bond);\r\nhash_index = bond_info->rx_hashtbl_head;\r\nfor (; hash_index != RLB_NULL_INDEX; hash_index = client_info->next) {\r\nclient_info = &(bond_info->rx_hashtbl[hash_index]);\r\nif (!client_info->slave) {\r\npr_err("%s: Error: found a client with no channel in the client's hash table\n",\r\nbond->dev->name);\r\ncontinue;\r\n}\r\nif ((client_info->ip_src == src_ip) &&\r\n!ether_addr_equal_64bits(client_info->slave->dev->dev_addr,\r\nbond->dev->dev_addr) &&\r\n!ether_addr_equal_64bits(client_info->mac_dst, mac_bcast)) {\r\nclient_info->ntt = 1;\r\nbond_info->rx_ntt = 1;\r\n}\r\n}\r\n_unlock_rx_hashtbl(bond);\r\n}\r\nstatic struct slave *rlb_choose_channel(struct sk_buff *skb, struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct arp_pkt *arp = arp_pkt(skb);\r\nstruct slave *assigned_slave;\r\nstruct rlb_client_info *client_info;\r\nu32 hash_index = 0;\r\n_lock_rx_hashtbl(bond);\r\nhash_index = _simple_hash((u8 *)&arp->ip_dst, sizeof(arp->ip_dst));\r\nclient_info = &(bond_info->rx_hashtbl[hash_index]);\r\nif (client_info->assigned) {\r\nif ((client_info->ip_src == arp->ip_src) &&\r\n(client_info->ip_dst == arp->ip_dst)) {\r\nif (!ether_addr_equal_64bits(arp->mac_dst, mac_bcast)) {\r\nmemcpy(client_info->mac_dst, arp->mac_dst, ETH_ALEN);\r\n}\r\nassigned_slave = client_info->slave;\r\nif (assigned_slave) {\r\n_unlock_rx_hashtbl(bond);\r\nreturn assigned_slave;\r\n}\r\n} else {\r\nif (bond->curr_active_slave &&\r\nclient_info->slave != bond->curr_active_slave) {\r\nclient_info->slave = bond->curr_active_slave;\r\nrlb_update_client(client_info);\r\n}\r\n}\r\n}\r\nassigned_slave = rlb_next_rx_slave(bond);\r\nif (assigned_slave) {\r\nclient_info->ip_src = arp->ip_src;\r\nclient_info->ip_dst = arp->ip_dst;\r\nmemcpy(client_info->mac_dst, arp->mac_dst, ETH_ALEN);\r\nclient_info->slave = assigned_slave;\r\nif (!ether_addr_equal_64bits(client_info->mac_dst, mac_bcast)) {\r\nclient_info->ntt = 1;\r\nbond->alb_info.rx_ntt = 1;\r\n} else {\r\nclient_info->ntt = 0;\r\n}\r\nif (bond_vlan_used(bond)) {\r\nif (!vlan_get_tag(skb, &client_info->vlan_id))\r\nclient_info->tag = 1;\r\n}\r\nif (!client_info->assigned) {\r\nu32 prev_tbl_head = bond_info->rx_hashtbl_head;\r\nbond_info->rx_hashtbl_head = hash_index;\r\nclient_info->next = prev_tbl_head;\r\nif (prev_tbl_head != RLB_NULL_INDEX) {\r\nbond_info->rx_hashtbl[prev_tbl_head].prev =\r\nhash_index;\r\n}\r\nclient_info->assigned = 1;\r\n}\r\n}\r\n_unlock_rx_hashtbl(bond);\r\nreturn assigned_slave;\r\n}\r\nstatic struct slave *rlb_arp_xmit(struct sk_buff *skb, struct bonding *bond)\r\n{\r\nstruct arp_pkt *arp = arp_pkt(skb);\r\nstruct slave *tx_slave = NULL;\r\nif (arp->op_code == htons(ARPOP_REPLY)) {\r\ntx_slave = rlb_choose_channel(skb, bond);\r\nif (tx_slave) {\r\nmemcpy(arp->mac_src,tx_slave->dev->dev_addr, ETH_ALEN);\r\n}\r\npr_debug("Server sent ARP Reply packet\n");\r\n} else if (arp->op_code == htons(ARPOP_REQUEST)) {\r\nrlb_choose_channel(skb, bond);\r\nbond->alb_info.rlb_update_delay_counter = RLB_UPDATE_DELAY;\r\nrlb_req_update_subnet_clients(bond, arp->ip_src);\r\npr_debug("Server sent ARP Request packet\n");\r\n}\r\nreturn tx_slave;\r\n}\r\nstatic void rlb_rebalance(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct slave *assigned_slave;\r\nstruct rlb_client_info *client_info;\r\nint ntt;\r\nu32 hash_index;\r\n_lock_rx_hashtbl_bh(bond);\r\nntt = 0;\r\nhash_index = bond_info->rx_hashtbl_head;\r\nfor (; hash_index != RLB_NULL_INDEX; hash_index = client_info->next) {\r\nclient_info = &(bond_info->rx_hashtbl[hash_index]);\r\nassigned_slave = rlb_next_rx_slave(bond);\r\nif (assigned_slave && (client_info->slave != assigned_slave)) {\r\nclient_info->slave = assigned_slave;\r\nclient_info->ntt = 1;\r\nntt = 1;\r\n}\r\n}\r\nif (ntt) {\r\nbond_info->rx_ntt = 1;\r\n}\r\n_unlock_rx_hashtbl_bh(bond);\r\n}\r\nstatic void rlb_init_table_entry(struct rlb_client_info *entry)\r\n{\r\nmemset(entry, 0, sizeof(struct rlb_client_info));\r\nentry->next = RLB_NULL_INDEX;\r\nentry->prev = RLB_NULL_INDEX;\r\n}\r\nstatic int rlb_initialize(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct rlb_client_info *new_hashtbl;\r\nint size = RLB_HASH_TABLE_SIZE * sizeof(struct rlb_client_info);\r\nint i;\r\nnew_hashtbl = kmalloc(size, GFP_KERNEL);\r\nif (!new_hashtbl)\r\nreturn -1;\r\n_lock_rx_hashtbl_bh(bond);\r\nbond_info->rx_hashtbl = new_hashtbl;\r\nbond_info->rx_hashtbl_head = RLB_NULL_INDEX;\r\nfor (i = 0; i < RLB_HASH_TABLE_SIZE; i++) {\r\nrlb_init_table_entry(bond_info->rx_hashtbl + i);\r\n}\r\n_unlock_rx_hashtbl_bh(bond);\r\nbond->recv_probe = rlb_arp_recv;\r\nreturn 0;\r\n}\r\nstatic void rlb_deinitialize(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\n_lock_rx_hashtbl_bh(bond);\r\nkfree(bond_info->rx_hashtbl);\r\nbond_info->rx_hashtbl = NULL;\r\nbond_info->rx_hashtbl_head = RLB_NULL_INDEX;\r\n_unlock_rx_hashtbl_bh(bond);\r\n}\r\nstatic void rlb_clear_vlan(struct bonding *bond, unsigned short vlan_id)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nu32 curr_index;\r\n_lock_rx_hashtbl_bh(bond);\r\ncurr_index = bond_info->rx_hashtbl_head;\r\nwhile (curr_index != RLB_NULL_INDEX) {\r\nstruct rlb_client_info *curr = &(bond_info->rx_hashtbl[curr_index]);\r\nu32 next_index = bond_info->rx_hashtbl[curr_index].next;\r\nu32 prev_index = bond_info->rx_hashtbl[curr_index].prev;\r\nif (curr->tag && (curr->vlan_id == vlan_id)) {\r\nif (curr_index == bond_info->rx_hashtbl_head) {\r\nbond_info->rx_hashtbl_head = next_index;\r\n}\r\nif (prev_index != RLB_NULL_INDEX) {\r\nbond_info->rx_hashtbl[prev_index].next = next_index;\r\n}\r\nif (next_index != RLB_NULL_INDEX) {\r\nbond_info->rx_hashtbl[next_index].prev = prev_index;\r\n}\r\nrlb_init_table_entry(curr);\r\n}\r\ncurr_index = next_index;\r\n}\r\n_unlock_rx_hashtbl_bh(bond);\r\n}\r\nstatic void alb_send_learning_packets(struct slave *slave, u8 mac_addr[])\r\n{\r\nstruct bonding *bond = bond_get_bond_by_slave(slave);\r\nstruct learning_pkt pkt;\r\nint size = sizeof(struct learning_pkt);\r\nint i;\r\nmemset(&pkt, 0, size);\r\nmemcpy(pkt.mac_dst, mac_addr, ETH_ALEN);\r\nmemcpy(pkt.mac_src, mac_addr, ETH_ALEN);\r\npkt.type = cpu_to_be16(ETH_P_LOOP);\r\nfor (i = 0; i < MAX_LP_BURST; i++) {\r\nstruct sk_buff *skb;\r\nchar *data;\r\nskb = dev_alloc_skb(size);\r\nif (!skb) {\r\nreturn;\r\n}\r\ndata = skb_put(skb, size);\r\nmemcpy(data, &pkt, size);\r\nskb_reset_mac_header(skb);\r\nskb->network_header = skb->mac_header + ETH_HLEN;\r\nskb->protocol = pkt.type;\r\nskb->priority = TC_PRIO_CONTROL;\r\nskb->dev = slave->dev;\r\nif (bond_vlan_used(bond)) {\r\nstruct vlan_entry *vlan;\r\nvlan = bond_next_vlan(bond,\r\nbond->alb_info.current_alb_vlan);\r\nbond->alb_info.current_alb_vlan = vlan;\r\nif (!vlan) {\r\nkfree_skb(skb);\r\ncontinue;\r\n}\r\nskb = vlan_put_tag(skb, vlan->vlan_id);\r\nif (!skb) {\r\npr_err("%s: Error: failed to insert VLAN tag\n",\r\nbond->dev->name);\r\ncontinue;\r\n}\r\n}\r\ndev_queue_xmit(skb);\r\n}\r\n}\r\nstatic int alb_set_slave_mac_addr(struct slave *slave, u8 addr[])\r\n{\r\nstruct net_device *dev = slave->dev;\r\nstruct sockaddr s_addr;\r\nif (slave->bond->params.mode == BOND_MODE_TLB) {\r\nmemcpy(dev->dev_addr, addr, dev->addr_len);\r\nreturn 0;\r\n}\r\nmemcpy(s_addr.sa_data, addr, dev->addr_len);\r\ns_addr.sa_family = dev->type;\r\nif (dev_set_mac_address(dev, &s_addr)) {\r\npr_err("%s: Error: dev_set_mac_address of dev %s failed!\n"\r\n"ALB mode requires that the base driver support setting the hw address also when the network device's interface is open\n",\r\ndev->master->name, dev->name);\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic void alb_swap_mac_addr(struct bonding *bond, struct slave *slave1, struct slave *slave2)\r\n{\r\nu8 tmp_mac_addr[ETH_ALEN];\r\nmemcpy(tmp_mac_addr, slave1->dev->dev_addr, ETH_ALEN);\r\nalb_set_slave_mac_addr(slave1, slave2->dev->dev_addr);\r\nalb_set_slave_mac_addr(slave2, tmp_mac_addr);\r\n}\r\nstatic void alb_fasten_mac_swap(struct bonding *bond, struct slave *slave1,\r\nstruct slave *slave2)\r\n{\r\nint slaves_state_differ = (SLAVE_IS_OK(slave1) != SLAVE_IS_OK(slave2));\r\nstruct slave *disabled_slave = NULL;\r\nASSERT_RTNL();\r\nif (SLAVE_IS_OK(slave1)) {\r\nalb_send_learning_packets(slave1, slave1->dev->dev_addr);\r\nif (bond->alb_info.rlb_enabled) {\r\nrlb_req_update_slave_clients(bond, slave1);\r\n}\r\n} else {\r\ndisabled_slave = slave1;\r\n}\r\nif (SLAVE_IS_OK(slave2)) {\r\nalb_send_learning_packets(slave2, slave2->dev->dev_addr);\r\nif (bond->alb_info.rlb_enabled) {\r\nrlb_req_update_slave_clients(bond, slave2);\r\n}\r\n} else {\r\ndisabled_slave = slave2;\r\n}\r\nif (bond->alb_info.rlb_enabled && slaves_state_differ) {\r\nrlb_teach_disabled_mac_on_primary(bond,\r\ndisabled_slave->dev->dev_addr);\r\n}\r\n}\r\nstatic void alb_change_hw_addr_on_detach(struct bonding *bond, struct slave *slave)\r\n{\r\nint perm_curr_diff;\r\nint perm_bond_diff;\r\nperm_curr_diff = !ether_addr_equal_64bits(slave->perm_hwaddr,\r\nslave->dev->dev_addr);\r\nperm_bond_diff = !ether_addr_equal_64bits(slave->perm_hwaddr,\r\nbond->dev->dev_addr);\r\nif (perm_curr_diff && perm_bond_diff) {\r\nstruct slave *tmp_slave;\r\nint i, found = 0;\r\nbond_for_each_slave(bond, tmp_slave, i) {\r\nif (ether_addr_equal_64bits(slave->perm_hwaddr,\r\ntmp_slave->dev->dev_addr)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nalb_swap_mac_addr(bond, slave, tmp_slave);\r\nalb_fasten_mac_swap(bond, slave, tmp_slave);\r\n}\r\n}\r\n}\r\nstatic int alb_handle_addr_collision_on_attach(struct bonding *bond, struct slave *slave)\r\n{\r\nstruct slave *tmp_slave1, *tmp_slave2, *free_mac_slave;\r\nstruct slave *has_bond_addr = bond->curr_active_slave;\r\nint i, j, found = 0;\r\nif (bond->slave_cnt == 0) {\r\nreturn 0;\r\n}\r\nif (!ether_addr_equal_64bits(slave->perm_hwaddr, bond->dev->dev_addr)) {\r\nbond_for_each_slave(bond, tmp_slave1, i) {\r\nif (ether_addr_equal_64bits(tmp_slave1->dev->dev_addr,\r\nslave->dev->dev_addr)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn 0;\r\nalb_set_slave_mac_addr(slave, bond->dev->dev_addr);\r\n}\r\nfree_mac_slave = NULL;\r\nbond_for_each_slave(bond, tmp_slave1, i) {\r\nfound = 0;\r\nbond_for_each_slave(bond, tmp_slave2, j) {\r\nif (ether_addr_equal_64bits(tmp_slave1->perm_hwaddr,\r\ntmp_slave2->dev->dev_addr)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nfree_mac_slave = tmp_slave1;\r\nbreak;\r\n}\r\nif (!has_bond_addr) {\r\nif (ether_addr_equal_64bits(tmp_slave1->dev->dev_addr,\r\nbond->dev->dev_addr)) {\r\nhas_bond_addr = tmp_slave1;\r\n}\r\n}\r\n}\r\nif (free_mac_slave) {\r\nalb_set_slave_mac_addr(slave, free_mac_slave->perm_hwaddr);\r\npr_warning("%s: Warning: the hw address of slave %s is in use by the bond; giving it the hw address of %s\n",\r\nbond->dev->name, slave->dev->name,\r\nfree_mac_slave->dev->name);\r\n} else if (has_bond_addr) {\r\npr_err("%s: Error: the hw address of slave %s is in use by the bond; couldn't find a slave with a free hw address to give it (this should not have happened)\n",\r\nbond->dev->name, slave->dev->name);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alb_set_mac_address(struct bonding *bond, void *addr)\r\n{\r\nstruct sockaddr sa;\r\nstruct slave *slave, *stop_at;\r\nchar tmp_addr[ETH_ALEN];\r\nint res;\r\nint i;\r\nif (bond->alb_info.rlb_enabled) {\r\nreturn 0;\r\n}\r\nbond_for_each_slave(bond, slave, i) {\r\nmemcpy(tmp_addr, slave->dev->dev_addr, ETH_ALEN);\r\nres = dev_set_mac_address(slave->dev, addr);\r\nmemcpy(slave->dev->dev_addr, tmp_addr, ETH_ALEN);\r\nif (res)\r\ngoto unwind;\r\n}\r\nreturn 0;\r\nunwind:\r\nmemcpy(sa.sa_data, bond->dev->dev_addr, bond->dev->addr_len);\r\nsa.sa_family = bond->dev->type;\r\nstop_at = slave;\r\nbond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {\r\nmemcpy(tmp_addr, slave->dev->dev_addr, ETH_ALEN);\r\ndev_set_mac_address(slave->dev, &sa);\r\nmemcpy(slave->dev->dev_addr, tmp_addr, ETH_ALEN);\r\n}\r\nreturn res;\r\n}\r\nint bond_alb_initialize(struct bonding *bond, int rlb_enabled)\r\n{\r\nint res;\r\nres = tlb_initialize(bond);\r\nif (res) {\r\nreturn res;\r\n}\r\nif (rlb_enabled) {\r\nbond->alb_info.rlb_enabled = 1;\r\nres = rlb_initialize(bond);\r\nif (res) {\r\ntlb_deinitialize(bond);\r\nreturn res;\r\n}\r\n} else {\r\nbond->alb_info.rlb_enabled = 0;\r\n}\r\nreturn 0;\r\n}\r\nvoid bond_alb_deinitialize(struct bonding *bond)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\ntlb_deinitialize(bond);\r\nif (bond_info->rlb_enabled) {\r\nrlb_deinitialize(bond);\r\n}\r\n}\r\nint bond_alb_xmit(struct sk_buff *skb, struct net_device *bond_dev)\r\n{\r\nstruct bonding *bond = netdev_priv(bond_dev);\r\nstruct ethhdr *eth_data;\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct slave *tx_slave = NULL;\r\nstatic const __be32 ip_bcast = htonl(0xffffffff);\r\nint hash_size = 0;\r\nint do_tx_balance = 1;\r\nu32 hash_index = 0;\r\nconst u8 *hash_start = NULL;\r\nint res = 1;\r\nstruct ipv6hdr *ip6hdr;\r\nskb_reset_mac_header(skb);\r\neth_data = eth_hdr(skb);\r\nread_lock(&bond->curr_slave_lock);\r\nswitch (ntohs(skb->protocol)) {\r\ncase ETH_P_IP: {\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nif (ether_addr_equal_64bits(eth_data->h_dest, mac_bcast) ||\r\n(iph->daddr == ip_bcast) ||\r\n(iph->protocol == IPPROTO_IGMP)) {\r\ndo_tx_balance = 0;\r\nbreak;\r\n}\r\nhash_start = (char *)&(iph->daddr);\r\nhash_size = sizeof(iph->daddr);\r\n}\r\nbreak;\r\ncase ETH_P_IPV6:\r\nif (ether_addr_equal_64bits(eth_data->h_dest, mac_bcast)) {\r\ndo_tx_balance = 0;\r\nbreak;\r\n}\r\nif (ether_addr_equal_64bits(eth_data->h_dest, mac_v6_allmcast)) {\r\ndo_tx_balance = 0;\r\nbreak;\r\n}\r\nip6hdr = ipv6_hdr(skb);\r\nif (ipv6_addr_any(&ip6hdr->saddr)) {\r\ndo_tx_balance = 0;\r\nbreak;\r\n}\r\nhash_start = (char *)&(ipv6_hdr(skb)->daddr);\r\nhash_size = sizeof(ipv6_hdr(skb)->daddr);\r\nbreak;\r\ncase ETH_P_IPX:\r\nif (ipx_hdr(skb)->ipx_checksum != IPX_NO_CHECKSUM) {\r\ndo_tx_balance = 0;\r\nbreak;\r\n}\r\nif (ipx_hdr(skb)->ipx_type != IPX_TYPE_NCP) {\r\ndo_tx_balance = 0;\r\nbreak;\r\n}\r\nhash_start = (char*)eth_data->h_dest;\r\nhash_size = ETH_ALEN;\r\nbreak;\r\ncase ETH_P_ARP:\r\ndo_tx_balance = 0;\r\nif (bond_info->rlb_enabled) {\r\ntx_slave = rlb_arp_xmit(skb, bond);\r\n}\r\nbreak;\r\ndefault:\r\ndo_tx_balance = 0;\r\nbreak;\r\n}\r\nif (do_tx_balance) {\r\nhash_index = _simple_hash(hash_start, hash_size);\r\ntx_slave = tlb_choose_channel(bond, hash_index, skb->len);\r\n}\r\nif (!tx_slave) {\r\ntx_slave = bond->curr_active_slave;\r\nbond_info->unbalanced_load += skb->len;\r\n}\r\nif (tx_slave && SLAVE_IS_OK(tx_slave)) {\r\nif (tx_slave != bond->curr_active_slave) {\r\nmemcpy(eth_data->h_source,\r\ntx_slave->dev->dev_addr,\r\nETH_ALEN);\r\n}\r\nres = bond_dev_queue_xmit(bond, skb, tx_slave->dev);\r\n} else {\r\nif (tx_slave) {\r\n_lock_tx_hashtbl(bond);\r\n__tlb_clear_slave(bond, tx_slave, 0);\r\n_unlock_tx_hashtbl(bond);\r\n}\r\n}\r\nread_unlock(&bond->curr_slave_lock);\r\nif (res) {\r\nkfree_skb(skb);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nvoid bond_alb_monitor(struct work_struct *work)\r\n{\r\nstruct bonding *bond = container_of(work, struct bonding,\r\nalb_work.work);\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nstruct slave *slave;\r\nint i;\r\nread_lock(&bond->lock);\r\nif (bond->slave_cnt == 0) {\r\nbond_info->tx_rebalance_counter = 0;\r\nbond_info->lp_counter = 0;\r\ngoto re_arm;\r\n}\r\nbond_info->tx_rebalance_counter++;\r\nbond_info->lp_counter++;\r\nif (bond_info->lp_counter >= BOND_ALB_LP_TICKS) {\r\nread_lock(&bond->curr_slave_lock);\r\nbond_for_each_slave(bond, slave, i) {\r\nalb_send_learning_packets(slave, slave->dev->dev_addr);\r\n}\r\nread_unlock(&bond->curr_slave_lock);\r\nbond_info->lp_counter = 0;\r\n}\r\nif (bond_info->tx_rebalance_counter >= BOND_TLB_REBALANCE_TICKS) {\r\nread_lock(&bond->curr_slave_lock);\r\nbond_for_each_slave(bond, slave, i) {\r\ntlb_clear_slave(bond, slave, 1);\r\nif (slave == bond->curr_active_slave) {\r\nSLAVE_TLB_INFO(slave).load =\r\nbond_info->unbalanced_load /\r\nBOND_TLB_REBALANCE_INTERVAL;\r\nbond_info->unbalanced_load = 0;\r\n}\r\n}\r\nread_unlock(&bond->curr_slave_lock);\r\nbond_info->tx_rebalance_counter = 0;\r\n}\r\nif (bond_info->rlb_enabled) {\r\nif (bond_info->primary_is_promisc &&\r\n(++bond_info->rlb_promisc_timeout_counter >= RLB_PROMISC_TIMEOUT)) {\r\nread_unlock(&bond->lock);\r\nif (!rtnl_trylock()) {\r\nread_lock(&bond->lock);\r\ngoto re_arm;\r\n}\r\nbond_info->rlb_promisc_timeout_counter = 0;\r\ndev_set_promiscuity(bond->curr_active_slave->dev, -1);\r\nbond_info->primary_is_promisc = 0;\r\nrtnl_unlock();\r\nread_lock(&bond->lock);\r\n}\r\nif (bond_info->rlb_rebalance) {\r\nbond_info->rlb_rebalance = 0;\r\nrlb_rebalance(bond);\r\n}\r\nif (bond_info->rx_ntt) {\r\nif (bond_info->rlb_update_delay_counter) {\r\n--bond_info->rlb_update_delay_counter;\r\n} else {\r\nrlb_update_rx_clients(bond);\r\nif (bond_info->rlb_update_retry_counter) {\r\n--bond_info->rlb_update_retry_counter;\r\n} else {\r\nbond_info->rx_ntt = 0;\r\n}\r\n}\r\n}\r\n}\r\nre_arm:\r\nqueue_delayed_work(bond->wq, &bond->alb_work, alb_delta_in_ticks);\r\nread_unlock(&bond->lock);\r\n}\r\nint bond_alb_init_slave(struct bonding *bond, struct slave *slave)\r\n{\r\nint res;\r\nres = alb_set_slave_mac_addr(slave, slave->perm_hwaddr);\r\nif (res) {\r\nreturn res;\r\n}\r\nread_lock(&bond->lock);\r\nres = alb_handle_addr_collision_on_attach(bond, slave);\r\nread_unlock(&bond->lock);\r\nif (res) {\r\nreturn res;\r\n}\r\ntlb_init_slave(slave);\r\nbond->alb_info.tx_rebalance_counter = BOND_TLB_REBALANCE_TICKS;\r\nif (bond->alb_info.rlb_enabled) {\r\nbond->alb_info.rlb_rebalance = 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid bond_alb_deinit_slave(struct bonding *bond, struct slave *slave)\r\n{\r\nif (bond->slave_cnt > 1) {\r\nalb_change_hw_addr_on_detach(bond, slave);\r\n}\r\ntlb_clear_slave(bond, slave, 0);\r\nif (bond->alb_info.rlb_enabled) {\r\nbond->alb_info.next_rx_slave = NULL;\r\nrlb_clear_slave(bond, slave);\r\n}\r\n}\r\nvoid bond_alb_handle_link_change(struct bonding *bond, struct slave *slave, char link)\r\n{\r\nstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\r\nif (link == BOND_LINK_DOWN) {\r\ntlb_clear_slave(bond, slave, 0);\r\nif (bond->alb_info.rlb_enabled) {\r\nrlb_clear_slave(bond, slave);\r\n}\r\n} else if (link == BOND_LINK_UP) {\r\nbond_info->tx_rebalance_counter = BOND_TLB_REBALANCE_TICKS;\r\nif (bond->alb_info.rlb_enabled) {\r\nbond->alb_info.rlb_rebalance = 1;\r\n}\r\n}\r\n}\r\nvoid bond_alb_handle_active_change(struct bonding *bond, struct slave *new_slave)\r\n__releases(&bond->curr_slave_lock\r\nint bond_alb_set_mac_address(struct net_device *bond_dev, void *addr)\r\n__acquires(&bond->lock\r\nvoid bond_alb_clear_vlan(struct bonding *bond, unsigned short vlan_id)\r\n{\r\nif (bond->alb_info.current_alb_vlan &&\r\n(bond->alb_info.current_alb_vlan->vlan_id == vlan_id)) {\r\nbond->alb_info.current_alb_vlan = NULL;\r\n}\r\nif (bond->alb_info.rlb_enabled) {\r\nrlb_clear_vlan(bond, vlan_id);\r\n}\r\n}
