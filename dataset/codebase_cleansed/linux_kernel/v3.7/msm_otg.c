static int msm_hsusb_init_vddcx(struct msm_otg *motg, int init)\r\n{\r\nint ret = 0;\r\nif (init) {\r\nhsusb_vddcx = regulator_get(motg->phy.dev, "HSUSB_VDDCX");\r\nif (IS_ERR(hsusb_vddcx)) {\r\ndev_err(motg->phy.dev, "unable to get hsusb vddcx\n");\r\nreturn PTR_ERR(hsusb_vddcx);\r\n}\r\nret = regulator_set_voltage(hsusb_vddcx,\r\nUSB_PHY_VDD_DIG_VOL_MIN,\r\nUSB_PHY_VDD_DIG_VOL_MAX);\r\nif (ret) {\r\ndev_err(motg->phy.dev, "unable to set the voltage "\r\n"for hsusb vddcx\n");\r\nregulator_put(hsusb_vddcx);\r\nreturn ret;\r\n}\r\nret = regulator_enable(hsusb_vddcx);\r\nif (ret) {\r\ndev_err(motg->phy.dev, "unable to enable hsusb vddcx\n");\r\nregulator_put(hsusb_vddcx);\r\n}\r\n} else {\r\nret = regulator_set_voltage(hsusb_vddcx, 0,\r\nUSB_PHY_VDD_DIG_VOL_MAX);\r\nif (ret)\r\ndev_err(motg->phy.dev, "unable to set the voltage "\r\n"for hsusb vddcx\n");\r\nret = regulator_disable(hsusb_vddcx);\r\nif (ret)\r\ndev_err(motg->phy.dev, "unable to disable hsusb vddcx\n");\r\nregulator_put(hsusb_vddcx);\r\n}\r\nreturn ret;\r\n}\r\nstatic int msm_hsusb_ldo_init(struct msm_otg *motg, int init)\r\n{\r\nint rc = 0;\r\nif (init) {\r\nhsusb_3p3 = regulator_get(motg->phy.dev, "HSUSB_3p3");\r\nif (IS_ERR(hsusb_3p3)) {\r\ndev_err(motg->phy.dev, "unable to get hsusb 3p3\n");\r\nreturn PTR_ERR(hsusb_3p3);\r\n}\r\nrc = regulator_set_voltage(hsusb_3p3, USB_PHY_3P3_VOL_MIN,\r\nUSB_PHY_3P3_VOL_MAX);\r\nif (rc) {\r\ndev_err(motg->phy.dev, "unable to set voltage level "\r\n"for hsusb 3p3\n");\r\ngoto put_3p3;\r\n}\r\nrc = regulator_enable(hsusb_3p3);\r\nif (rc) {\r\ndev_err(motg->phy.dev, "unable to enable the hsusb 3p3\n");\r\ngoto put_3p3;\r\n}\r\nhsusb_1p8 = regulator_get(motg->phy.dev, "HSUSB_1p8");\r\nif (IS_ERR(hsusb_1p8)) {\r\ndev_err(motg->phy.dev, "unable to get hsusb 1p8\n");\r\nrc = PTR_ERR(hsusb_1p8);\r\ngoto disable_3p3;\r\n}\r\nrc = regulator_set_voltage(hsusb_1p8, USB_PHY_1P8_VOL_MIN,\r\nUSB_PHY_1P8_VOL_MAX);\r\nif (rc) {\r\ndev_err(motg->phy.dev, "unable to set voltage level "\r\n"for hsusb 1p8\n");\r\ngoto put_1p8;\r\n}\r\nrc = regulator_enable(hsusb_1p8);\r\nif (rc) {\r\ndev_err(motg->phy.dev, "unable to enable the hsusb 1p8\n");\r\ngoto put_1p8;\r\n}\r\nreturn 0;\r\n}\r\nregulator_disable(hsusb_1p8);\r\nput_1p8:\r\nregulator_put(hsusb_1p8);\r\ndisable_3p3:\r\nregulator_disable(hsusb_3p3);\r\nput_3p3:\r\nregulator_put(hsusb_3p3);\r\nreturn rc;\r\n}\r\nstatic int msm_hsusb_config_vddcx(int high)\r\n{\r\nint max_vol = USB_PHY_VDD_DIG_VOL_MAX;\r\nint min_vol;\r\nint ret;\r\nif (high)\r\nmin_vol = USB_PHY_VDD_DIG_VOL_MIN;\r\nelse\r\nmin_vol = USB_PHY_SUSP_DIG_VOL;\r\nret = regulator_set_voltage(hsusb_vddcx, min_vol, max_vol);\r\nif (ret) {\r\npr_err("%s: unable to set the voltage for regulator "\r\n"HSUSB_VDDCX\n", __func__);\r\nreturn ret;\r\n}\r\npr_debug("%s: min_vol:%d max_vol:%d\n", __func__, min_vol, max_vol);\r\nreturn ret;\r\n}\r\nstatic int msm_hsusb_ldo_set_mode(int on)\r\n{\r\nint ret = 0;\r\nif (!hsusb_1p8 || IS_ERR(hsusb_1p8)) {\r\npr_err("%s: HSUSB_1p8 is not initialized\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (!hsusb_3p3 || IS_ERR(hsusb_3p3)) {\r\npr_err("%s: HSUSB_3p3 is not initialized\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (on) {\r\nret = regulator_set_optimum_mode(hsusb_1p8,\r\nUSB_PHY_1P8_HPM_LOAD);\r\nif (ret < 0) {\r\npr_err("%s: Unable to set HPM of the regulator "\r\n"HSUSB_1p8\n", __func__);\r\nreturn ret;\r\n}\r\nret = regulator_set_optimum_mode(hsusb_3p3,\r\nUSB_PHY_3P3_HPM_LOAD);\r\nif (ret < 0) {\r\npr_err("%s: Unable to set HPM of the regulator "\r\n"HSUSB_3p3\n", __func__);\r\nregulator_set_optimum_mode(hsusb_1p8,\r\nUSB_PHY_1P8_LPM_LOAD);\r\nreturn ret;\r\n}\r\n} else {\r\nret = regulator_set_optimum_mode(hsusb_1p8,\r\nUSB_PHY_1P8_LPM_LOAD);\r\nif (ret < 0)\r\npr_err("%s: Unable to set LPM of the regulator "\r\n"HSUSB_1p8\n", __func__);\r\nret = regulator_set_optimum_mode(hsusb_3p3,\r\nUSB_PHY_3P3_LPM_LOAD);\r\nif (ret < 0)\r\npr_err("%s: Unable to set LPM of the regulator "\r\n"HSUSB_3p3\n", __func__);\r\n}\r\npr_debug("reg (%s)\n", on ? "HPM" : "LPM");\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int ulpi_read(struct usb_phy *phy, u32 reg)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nint cnt = 0;\r\nwritel(ULPI_RUN | ULPI_READ | ULPI_ADDR(reg),\r\nUSB_ULPI_VIEWPORT);\r\nwhile (cnt < ULPI_IO_TIMEOUT_USEC) {\r\nif (!(readl(USB_ULPI_VIEWPORT) & ULPI_RUN))\r\nbreak;\r\nudelay(1);\r\ncnt++;\r\n}\r\nif (cnt >= ULPI_IO_TIMEOUT_USEC) {\r\ndev_err(phy->dev, "ulpi_read: timeout %08x\n",\r\nreadl(USB_ULPI_VIEWPORT));\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn ULPI_DATA_READ(readl(USB_ULPI_VIEWPORT));\r\n}\r\nstatic int ulpi_write(struct usb_phy *phy, u32 val, u32 reg)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nint cnt = 0;\r\nwritel(ULPI_RUN | ULPI_WRITE |\r\nULPI_ADDR(reg) | ULPI_DATA(val),\r\nUSB_ULPI_VIEWPORT);\r\nwhile (cnt < ULPI_IO_TIMEOUT_USEC) {\r\nif (!(readl(USB_ULPI_VIEWPORT) & ULPI_RUN))\r\nbreak;\r\nudelay(1);\r\ncnt++;\r\n}\r\nif (cnt >= ULPI_IO_TIMEOUT_USEC) {\r\ndev_err(phy->dev, "ulpi_write: timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ulpi_init(struct msm_otg *motg)\r\n{\r\nstruct msm_otg_platform_data *pdata = motg->pdata;\r\nint *seq = pdata->phy_init_seq;\r\nif (!seq)\r\nreturn;\r\nwhile (seq[0] >= 0) {\r\ndev_vdbg(motg->phy.dev, "ulpi: write 0x%02x to 0x%02x\n",\r\nseq[0], seq[1]);\r\nulpi_write(&motg->phy, seq[0], seq[1]);\r\nseq += 2;\r\n}\r\n}\r\nstatic int msm_otg_link_clk_reset(struct msm_otg *motg, bool assert)\r\n{\r\nint ret;\r\nif (assert) {\r\nret = clk_reset(motg->clk, CLK_RESET_ASSERT);\r\nif (ret)\r\ndev_err(motg->phy.dev, "usb hs_clk assert failed\n");\r\n} else {\r\nret = clk_reset(motg->clk, CLK_RESET_DEASSERT);\r\nif (ret)\r\ndev_err(motg->phy.dev, "usb hs_clk deassert failed\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int msm_otg_phy_clk_reset(struct msm_otg *motg)\r\n{\r\nint ret;\r\nret = clk_reset(motg->phy_reset_clk, CLK_RESET_ASSERT);\r\nif (ret) {\r\ndev_err(motg->phy.dev, "usb phy clk assert failed\n");\r\nreturn ret;\r\n}\r\nusleep_range(10000, 12000);\r\nret = clk_reset(motg->phy_reset_clk, CLK_RESET_DEASSERT);\r\nif (ret)\r\ndev_err(motg->phy.dev, "usb phy clk deassert failed\n");\r\nreturn ret;\r\n}\r\nstatic int msm_otg_phy_reset(struct msm_otg *motg)\r\n{\r\nu32 val;\r\nint ret;\r\nint retries;\r\nret = msm_otg_link_clk_reset(motg, 1);\r\nif (ret)\r\nreturn ret;\r\nret = msm_otg_phy_clk_reset(motg);\r\nif (ret)\r\nreturn ret;\r\nret = msm_otg_link_clk_reset(motg, 0);\r\nif (ret)\r\nreturn ret;\r\nval = readl(USB_PORTSC) & ~PORTSC_PTS_MASK;\r\nwritel(val | PORTSC_PTS_ULPI, USB_PORTSC);\r\nfor (retries = 3; retries > 0; retries--) {\r\nret = ulpi_write(&motg->phy, ULPI_FUNC_CTRL_SUSPENDM,\r\nULPI_CLR(ULPI_FUNC_CTRL));\r\nif (!ret)\r\nbreak;\r\nret = msm_otg_phy_clk_reset(motg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!retries)\r\nreturn -ETIMEDOUT;\r\nret = msm_otg_phy_clk_reset(motg);\r\nif (ret)\r\nreturn ret;\r\nfor (retries = 3; retries > 0; retries--) {\r\nret = ulpi_read(&motg->phy, ULPI_DEBUG);\r\nif (ret != -ETIMEDOUT)\r\nbreak;\r\nret = msm_otg_phy_clk_reset(motg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!retries)\r\nreturn -ETIMEDOUT;\r\ndev_info(motg->phy.dev, "phy_reset: success\n");\r\nreturn 0;\r\n}\r\nstatic int msm_otg_reset(struct usb_phy *phy)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nstruct msm_otg_platform_data *pdata = motg->pdata;\r\nint cnt = 0;\r\nint ret;\r\nu32 val = 0;\r\nu32 ulpi_val = 0;\r\nret = msm_otg_phy_reset(motg);\r\nif (ret) {\r\ndev_err(phy->dev, "phy_reset failed\n");\r\nreturn ret;\r\n}\r\nulpi_init(motg);\r\nwritel(USBCMD_RESET, USB_USBCMD);\r\nwhile (cnt < LINK_RESET_TIMEOUT_USEC) {\r\nif (!(readl(USB_USBCMD) & USBCMD_RESET))\r\nbreak;\r\nudelay(1);\r\ncnt++;\r\n}\r\nif (cnt >= LINK_RESET_TIMEOUT_USEC)\r\nreturn -ETIMEDOUT;\r\nwritel(0x80000000, USB_PORTSC);\r\nmsleep(100);\r\nwritel(0x0, USB_AHBBURST);\r\nwritel(0x00, USB_AHBMODE);\r\nif (pdata->otg_control == OTG_PHY_CONTROL) {\r\nval = readl(USB_OTGSC);\r\nif (pdata->mode == USB_OTG) {\r\nulpi_val = ULPI_INT_IDGRD | ULPI_INT_SESS_VALID;\r\nval |= OTGSC_IDIE | OTGSC_BSVIE;\r\n} else if (pdata->mode == USB_PERIPHERAL) {\r\nulpi_val = ULPI_INT_SESS_VALID;\r\nval |= OTGSC_BSVIE;\r\n}\r\nwritel(val, USB_OTGSC);\r\nulpi_write(phy, ulpi_val, ULPI_USB_INT_EN_RISE);\r\nulpi_write(phy, ulpi_val, ULPI_USB_INT_EN_FALL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm_otg_suspend(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nstruct usb_bus *bus = phy->otg->host;\r\nstruct msm_otg_platform_data *pdata = motg->pdata;\r\nint cnt = 0;\r\nif (atomic_read(&motg->in_lpm))\r\nreturn 0;\r\ndisable_irq(motg->irq);\r\nif (motg->pdata->phy_type == CI_45NM_INTEGRATED_PHY) {\r\nulpi_read(phy, 0x14);\r\nif (pdata->otg_control == OTG_PHY_CONTROL)\r\nulpi_write(phy, 0x01, 0x30);\r\nulpi_write(phy, 0x08, 0x09);\r\n}\r\nwritel(readl(USB_PORTSC) | PORTSC_PHCD, USB_PORTSC);\r\nwhile (cnt < PHY_SUSPEND_TIMEOUT_USEC) {\r\nif (readl(USB_PORTSC) & PORTSC_PHCD)\r\nbreak;\r\nudelay(1);\r\ncnt++;\r\n}\r\nif (cnt >= PHY_SUSPEND_TIMEOUT_USEC) {\r\ndev_err(phy->dev, "Unable to suspend PHY\n");\r\nmsm_otg_reset(phy);\r\nenable_irq(motg->irq);\r\nreturn -ETIMEDOUT;\r\n}\r\nwritel(readl(USB_USBCMD) | ASYNC_INTR_CTRL | ULPI_STP_CTRL, USB_USBCMD);\r\nif (motg->pdata->phy_type == SNPS_28NM_INTEGRATED_PHY &&\r\nmotg->pdata->otg_control == OTG_PMIC_CONTROL)\r\nwritel(readl(USB_PHY_CTRL) | PHY_RETEN, USB_PHY_CTRL);\r\nclk_disable(motg->pclk);\r\nclk_disable(motg->clk);\r\nif (motg->core_clk)\r\nclk_disable(motg->core_clk);\r\nif (!IS_ERR(motg->pclk_src))\r\nclk_disable(motg->pclk_src);\r\nif (motg->pdata->phy_type == SNPS_28NM_INTEGRATED_PHY &&\r\nmotg->pdata->otg_control == OTG_PMIC_CONTROL) {\r\nmsm_hsusb_ldo_set_mode(0);\r\nmsm_hsusb_config_vddcx(0);\r\n}\r\nif (device_may_wakeup(phy->dev))\r\nenable_irq_wake(motg->irq);\r\nif (bus)\r\nclear_bit(HCD_FLAG_HW_ACCESSIBLE, &(bus_to_hcd(bus))->flags);\r\natomic_set(&motg->in_lpm, 1);\r\nenable_irq(motg->irq);\r\ndev_info(phy->dev, "USB in low power mode\n");\r\nreturn 0;\r\n}\r\nstatic int msm_otg_resume(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nstruct usb_bus *bus = phy->otg->host;\r\nint cnt = 0;\r\nunsigned temp;\r\nif (!atomic_read(&motg->in_lpm))\r\nreturn 0;\r\nif (!IS_ERR(motg->pclk_src))\r\nclk_enable(motg->pclk_src);\r\nclk_enable(motg->pclk);\r\nclk_enable(motg->clk);\r\nif (motg->core_clk)\r\nclk_enable(motg->core_clk);\r\nif (motg->pdata->phy_type == SNPS_28NM_INTEGRATED_PHY &&\r\nmotg->pdata->otg_control == OTG_PMIC_CONTROL) {\r\nmsm_hsusb_ldo_set_mode(1);\r\nmsm_hsusb_config_vddcx(1);\r\nwritel(readl(USB_PHY_CTRL) & ~PHY_RETEN, USB_PHY_CTRL);\r\n}\r\ntemp = readl(USB_USBCMD);\r\ntemp &= ~ASYNC_INTR_CTRL;\r\ntemp &= ~ULPI_STP_CTRL;\r\nwritel(temp, USB_USBCMD);\r\nif (!(readl(USB_PORTSC) & PORTSC_PHCD))\r\ngoto skip_phy_resume;\r\nwritel(readl(USB_PORTSC) & ~PORTSC_PHCD, USB_PORTSC);\r\nwhile (cnt < PHY_RESUME_TIMEOUT_USEC) {\r\nif (!(readl(USB_PORTSC) & PORTSC_PHCD))\r\nbreak;\r\nudelay(1);\r\ncnt++;\r\n}\r\nif (cnt >= PHY_RESUME_TIMEOUT_USEC) {\r\ndev_err(phy->dev, "Unable to resume USB."\r\n"Re-plugin the cable\n");\r\nmsm_otg_reset(phy);\r\n}\r\nskip_phy_resume:\r\nif (device_may_wakeup(phy->dev))\r\ndisable_irq_wake(motg->irq);\r\nif (bus)\r\nset_bit(HCD_FLAG_HW_ACCESSIBLE, &(bus_to_hcd(bus))->flags);\r\natomic_set(&motg->in_lpm, 0);\r\nif (motg->async_int) {\r\nmotg->async_int = 0;\r\npm_runtime_put(phy->dev);\r\nenable_irq(motg->irq);\r\n}\r\ndev_info(phy->dev, "USB exited from low power mode\n");\r\nreturn 0;\r\n}\r\nstatic void msm_otg_notify_charger(struct msm_otg *motg, unsigned mA)\r\n{\r\nif (motg->cur_power == mA)\r\nreturn;\r\ndev_info(motg->phy.dev, "Avail curr from USB = %u\n", mA);\r\nmotg->cur_power = mA;\r\n}\r\nstatic int msm_otg_set_power(struct usb_phy *phy, unsigned mA)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nif (motg->chg_type == USB_SDP_CHARGER)\r\nmsm_otg_notify_charger(motg, mA);\r\nreturn 0;\r\n}\r\nstatic void msm_otg_start_host(struct usb_phy *phy, int on)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nstruct msm_otg_platform_data *pdata = motg->pdata;\r\nstruct usb_hcd *hcd;\r\nif (!phy->otg->host)\r\nreturn;\r\nhcd = bus_to_hcd(phy->otg->host);\r\nif (on) {\r\ndev_dbg(phy->dev, "host on\n");\r\nif (pdata->vbus_power)\r\npdata->vbus_power(1);\r\nif (pdata->setup_gpio)\r\npdata->setup_gpio(OTG_STATE_A_HOST);\r\n#ifdef CONFIG_USB\r\nusb_add_hcd(hcd, hcd->irq, IRQF_SHARED);\r\n#endif\r\n} else {\r\ndev_dbg(phy->dev, "host off\n");\r\n#ifdef CONFIG_USB\r\nusb_remove_hcd(hcd);\r\n#endif\r\nif (pdata->setup_gpio)\r\npdata->setup_gpio(OTG_STATE_UNDEFINED);\r\nif (pdata->vbus_power)\r\npdata->vbus_power(0);\r\n}\r\n}\r\nstatic int msm_otg_set_host(struct usb_otg *otg, struct usb_bus *host)\r\n{\r\nstruct msm_otg *motg = container_of(otg->phy, struct msm_otg, phy);\r\nstruct usb_hcd *hcd;\r\nif (motg->pdata->mode == USB_PERIPHERAL) {\r\ndev_info(otg->phy->dev, "Host mode is not supported\n");\r\nreturn -ENODEV;\r\n}\r\nif (!host) {\r\nif (otg->phy->state == OTG_STATE_A_HOST) {\r\npm_runtime_get_sync(otg->phy->dev);\r\nmsm_otg_start_host(otg->phy, 0);\r\notg->host = NULL;\r\notg->phy->state = OTG_STATE_UNDEFINED;\r\nschedule_work(&motg->sm_work);\r\n} else {\r\notg->host = NULL;\r\n}\r\nreturn 0;\r\n}\r\nhcd = bus_to_hcd(host);\r\nhcd->power_budget = motg->pdata->power_budget;\r\notg->host = host;\r\ndev_dbg(otg->phy->dev, "host driver registered w/ tranceiver\n");\r\nif (motg->pdata->mode == USB_HOST || otg->gadget) {\r\npm_runtime_get_sync(otg->phy->dev);\r\nschedule_work(&motg->sm_work);\r\n}\r\nreturn 0;\r\n}\r\nstatic void msm_otg_start_peripheral(struct usb_phy *phy, int on)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nstruct msm_otg_platform_data *pdata = motg->pdata;\r\nif (!phy->otg->gadget)\r\nreturn;\r\nif (on) {\r\ndev_dbg(phy->dev, "gadget on\n");\r\nif (pdata->setup_gpio)\r\npdata->setup_gpio(OTG_STATE_B_PERIPHERAL);\r\nusb_gadget_vbus_connect(phy->otg->gadget);\r\n} else {\r\ndev_dbg(phy->dev, "gadget off\n");\r\nusb_gadget_vbus_disconnect(phy->otg->gadget);\r\nif (pdata->setup_gpio)\r\npdata->setup_gpio(OTG_STATE_UNDEFINED);\r\n}\r\n}\r\nstatic int msm_otg_set_peripheral(struct usb_otg *otg,\r\nstruct usb_gadget *gadget)\r\n{\r\nstruct msm_otg *motg = container_of(otg->phy, struct msm_otg, phy);\r\nif (motg->pdata->mode == USB_HOST) {\r\ndev_info(otg->phy->dev, "Peripheral mode is not supported\n");\r\nreturn -ENODEV;\r\n}\r\nif (!gadget) {\r\nif (otg->phy->state == OTG_STATE_B_PERIPHERAL) {\r\npm_runtime_get_sync(otg->phy->dev);\r\nmsm_otg_start_peripheral(otg->phy, 0);\r\notg->gadget = NULL;\r\notg->phy->state = OTG_STATE_UNDEFINED;\r\nschedule_work(&motg->sm_work);\r\n} else {\r\notg->gadget = NULL;\r\n}\r\nreturn 0;\r\n}\r\notg->gadget = gadget;\r\ndev_dbg(otg->phy->dev, "peripheral driver registered w/ tranceiver\n");\r\nif (motg->pdata->mode == USB_PERIPHERAL || otg->host) {\r\npm_runtime_get_sync(otg->phy->dev);\r\nschedule_work(&motg->sm_work);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool msm_chg_check_secondary_det(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 chg_det;\r\nbool ret = false;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nret = chg_det & (1 << 4);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x87);\r\nret = chg_det & 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void msm_chg_enable_secondary_det(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 chg_det;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nchg_det |= ~(1 << 1);\r\nulpi_write(phy, chg_det, 0x34);\r\nudelay(20);\r\nchg_det &= ~(1 << 3);\r\nulpi_write(phy, chg_det, 0x34);\r\nchg_det &= ~(1 << 2);\r\nulpi_write(phy, chg_det, 0x34);\r\nchg_det &= ~(1 << 1);\r\nulpi_write(phy, chg_det, 0x34);\r\nudelay(20);\r\nchg_det &= ~(1 << 0);\r\nulpi_write(phy, chg_det, 0x34);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nulpi_write(phy, 0x8, 0x85);\r\nulpi_write(phy, 0x2, 0x85);\r\nulpi_write(phy, 0x1, 0x85);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic bool msm_chg_check_primary_det(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 chg_det;\r\nbool ret = false;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nret = chg_det & (1 << 4);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x87);\r\nret = chg_det & 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void msm_chg_enable_primary_det(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 chg_det;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nchg_det &= ~(1 << 0);\r\nulpi_write(phy, chg_det, 0x34);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nulpi_write(phy, 0x2, 0x85);\r\nulpi_write(phy, 0x1, 0x85);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic bool msm_chg_check_dcd(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 line_state;\r\nbool ret = false;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nline_state = ulpi_read(phy, 0x15);\r\nret = !(line_state & 1);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nline_state = ulpi_read(phy, 0x87);\r\nret = line_state & 2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void msm_chg_disable_dcd(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 chg_det;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nchg_det &= ~(1 << 5);\r\nulpi_write(phy, chg_det, 0x34);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nulpi_write(phy, 0x10, 0x86);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void msm_chg_enable_dcd(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 chg_det;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nchg_det |= (1 << 5);\r\nulpi_write(phy, chg_det, 0x34);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nulpi_write(phy, 0x10, 0x85);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void msm_chg_block_on(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 func_ctrl, chg_det;\r\nfunc_ctrl = ulpi_read(phy, ULPI_FUNC_CTRL);\r\nfunc_ctrl &= ~ULPI_FUNC_CTRL_OPMODE_MASK;\r\nfunc_ctrl |= ULPI_FUNC_CTRL_OPMODE_NONDRIVING;\r\nulpi_write(phy, func_ctrl, ULPI_FUNC_CTRL);\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nchg_det &= ~(1 << 3);\r\nulpi_write(phy, chg_det, 0x34);\r\nchg_det &= ~(1 << 1);\r\nulpi_write(phy, chg_det, 0x34);\r\nudelay(20);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nulpi_write(phy, 0x3F, 0x86);\r\nulpi_write(phy, 0x1F, 0x92);\r\nulpi_write(phy, 0x1F, 0x95);\r\nudelay(100);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void msm_chg_block_off(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 func_ctrl, chg_det;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nchg_det |= ~(1 << 1);\r\nulpi_write(phy, chg_det, 0x34);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nulpi_write(phy, 0x3F, 0x86);\r\nulpi_write(phy, 0x1F, 0x92);\r\nulpi_write(phy, 0x1F, 0x95);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfunc_ctrl = ulpi_read(phy, ULPI_FUNC_CTRL);\r\nfunc_ctrl &= ~ULPI_FUNC_CTRL_OPMODE_MASK;\r\nfunc_ctrl |= ULPI_FUNC_CTRL_OPMODE_NORMAL;\r\nulpi_write(phy, func_ctrl, ULPI_FUNC_CTRL);\r\n}\r\nstatic void msm_chg_detect_work(struct work_struct *w)\r\n{\r\nstruct msm_otg *motg = container_of(w, struct msm_otg, chg_work.work);\r\nstruct usb_phy *phy = &motg->phy;\r\nbool is_dcd, tmout, vout;\r\nunsigned long delay;\r\ndev_dbg(phy->dev, "chg detection work\n");\r\nswitch (motg->chg_state) {\r\ncase USB_CHG_STATE_UNDEFINED:\r\npm_runtime_get_sync(phy->dev);\r\nmsm_chg_block_on(motg);\r\nmsm_chg_enable_dcd(motg);\r\nmotg->chg_state = USB_CHG_STATE_WAIT_FOR_DCD;\r\nmotg->dcd_retries = 0;\r\ndelay = MSM_CHG_DCD_POLL_TIME;\r\nbreak;\r\ncase USB_CHG_STATE_WAIT_FOR_DCD:\r\nis_dcd = msm_chg_check_dcd(motg);\r\ntmout = ++motg->dcd_retries == MSM_CHG_DCD_MAX_RETRIES;\r\nif (is_dcd || tmout) {\r\nmsm_chg_disable_dcd(motg);\r\nmsm_chg_enable_primary_det(motg);\r\ndelay = MSM_CHG_PRIMARY_DET_TIME;\r\nmotg->chg_state = USB_CHG_STATE_DCD_DONE;\r\n} else {\r\ndelay = MSM_CHG_DCD_POLL_TIME;\r\n}\r\nbreak;\r\ncase USB_CHG_STATE_DCD_DONE:\r\nvout = msm_chg_check_primary_det(motg);\r\nif (vout) {\r\nmsm_chg_enable_secondary_det(motg);\r\ndelay = MSM_CHG_SECONDARY_DET_TIME;\r\nmotg->chg_state = USB_CHG_STATE_PRIMARY_DONE;\r\n} else {\r\nmotg->chg_type = USB_SDP_CHARGER;\r\nmotg->chg_state = USB_CHG_STATE_DETECTED;\r\ndelay = 0;\r\n}\r\nbreak;\r\ncase USB_CHG_STATE_PRIMARY_DONE:\r\nvout = msm_chg_check_secondary_det(motg);\r\nif (vout)\r\nmotg->chg_type = USB_DCP_CHARGER;\r\nelse\r\nmotg->chg_type = USB_CDP_CHARGER;\r\nmotg->chg_state = USB_CHG_STATE_SECONDARY_DONE;\r\ncase USB_CHG_STATE_SECONDARY_DONE:\r\nmotg->chg_state = USB_CHG_STATE_DETECTED;\r\ncase USB_CHG_STATE_DETECTED:\r\nmsm_chg_block_off(motg);\r\ndev_dbg(phy->dev, "charger = %d\n", motg->chg_type);\r\nschedule_work(&motg->sm_work);\r\nreturn;\r\ndefault:\r\nreturn;\r\n}\r\nschedule_delayed_work(&motg->chg_work, delay);\r\n}\r\nstatic void msm_otg_init_sm(struct msm_otg *motg)\r\n{\r\nstruct msm_otg_platform_data *pdata = motg->pdata;\r\nu32 otgsc = readl(USB_OTGSC);\r\nswitch (pdata->mode) {\r\ncase USB_OTG:\r\nif (pdata->otg_control == OTG_PHY_CONTROL) {\r\nif (otgsc & OTGSC_ID)\r\nset_bit(ID, &motg->inputs);\r\nelse\r\nclear_bit(ID, &motg->inputs);\r\nif (otgsc & OTGSC_BSV)\r\nset_bit(B_SESS_VLD, &motg->inputs);\r\nelse\r\nclear_bit(B_SESS_VLD, &motg->inputs);\r\n} else if (pdata->otg_control == OTG_USER_CONTROL) {\r\nif (pdata->default_mode == USB_HOST) {\r\nclear_bit(ID, &motg->inputs);\r\n} else if (pdata->default_mode == USB_PERIPHERAL) {\r\nset_bit(ID, &motg->inputs);\r\nset_bit(B_SESS_VLD, &motg->inputs);\r\n} else {\r\nset_bit(ID, &motg->inputs);\r\nclear_bit(B_SESS_VLD, &motg->inputs);\r\n}\r\n}\r\nbreak;\r\ncase USB_HOST:\r\nclear_bit(ID, &motg->inputs);\r\nbreak;\r\ncase USB_PERIPHERAL:\r\nset_bit(ID, &motg->inputs);\r\nif (otgsc & OTGSC_BSV)\r\nset_bit(B_SESS_VLD, &motg->inputs);\r\nelse\r\nclear_bit(B_SESS_VLD, &motg->inputs);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void msm_otg_sm_work(struct work_struct *w)\r\n{\r\nstruct msm_otg *motg = container_of(w, struct msm_otg, sm_work);\r\nstruct usb_otg *otg = motg->phy.otg;\r\nswitch (otg->phy->state) {\r\ncase OTG_STATE_UNDEFINED:\r\ndev_dbg(otg->phy->dev, "OTG_STATE_UNDEFINED state\n");\r\nmsm_otg_reset(otg->phy);\r\nmsm_otg_init_sm(motg);\r\notg->phy->state = OTG_STATE_B_IDLE;\r\ncase OTG_STATE_B_IDLE:\r\ndev_dbg(otg->phy->dev, "OTG_STATE_B_IDLE state\n");\r\nif (!test_bit(ID, &motg->inputs) && otg->host) {\r\nwritel(readl(USB_OTGSC) & ~OTGSC_BSVIE, USB_OTGSC);\r\nmsm_otg_start_host(otg->phy, 1);\r\notg->phy->state = OTG_STATE_A_HOST;\r\n} else if (test_bit(B_SESS_VLD, &motg->inputs)) {\r\nswitch (motg->chg_state) {\r\ncase USB_CHG_STATE_UNDEFINED:\r\nmsm_chg_detect_work(&motg->chg_work.work);\r\nbreak;\r\ncase USB_CHG_STATE_DETECTED:\r\nswitch (motg->chg_type) {\r\ncase USB_DCP_CHARGER:\r\nmsm_otg_notify_charger(motg,\r\nIDEV_CHG_MAX);\r\nbreak;\r\ncase USB_CDP_CHARGER:\r\nmsm_otg_notify_charger(motg,\r\nIDEV_CHG_MAX);\r\nmsm_otg_start_peripheral(otg->phy, 1);\r\notg->phy->state\r\n= OTG_STATE_B_PERIPHERAL;\r\nbreak;\r\ncase USB_SDP_CHARGER:\r\nmsm_otg_notify_charger(motg, IUNIT);\r\nmsm_otg_start_peripheral(otg->phy, 1);\r\notg->phy->state\r\n= OTG_STATE_B_PERIPHERAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nif (cancel_delayed_work_sync(&motg->chg_work)) {\r\npm_runtime_put_sync(otg->phy->dev);\r\nmsm_otg_reset(otg->phy);\r\n}\r\nmsm_otg_notify_charger(motg, 0);\r\nmotg->chg_state = USB_CHG_STATE_UNDEFINED;\r\nmotg->chg_type = USB_INVALID_CHARGER;\r\n}\r\npm_runtime_put_sync(otg->phy->dev);\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\ndev_dbg(otg->phy->dev, "OTG_STATE_B_PERIPHERAL state\n");\r\nif (!test_bit(B_SESS_VLD, &motg->inputs) ||\r\n!test_bit(ID, &motg->inputs)) {\r\nmsm_otg_notify_charger(motg, 0);\r\nmsm_otg_start_peripheral(otg->phy, 0);\r\nmotg->chg_state = USB_CHG_STATE_UNDEFINED;\r\nmotg->chg_type = USB_INVALID_CHARGER;\r\notg->phy->state = OTG_STATE_B_IDLE;\r\nmsm_otg_reset(otg->phy);\r\nschedule_work(w);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\ndev_dbg(otg->phy->dev, "OTG_STATE_A_HOST state\n");\r\nif (test_bit(ID, &motg->inputs)) {\r\nmsm_otg_start_host(otg->phy, 0);\r\notg->phy->state = OTG_STATE_B_IDLE;\r\nmsm_otg_reset(otg->phy);\r\nschedule_work(w);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t msm_otg_irq(int irq, void *data)\r\n{\r\nstruct msm_otg *motg = data;\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 otgsc = 0;\r\nif (atomic_read(&motg->in_lpm)) {\r\ndisable_irq_nosync(irq);\r\nmotg->async_int = 1;\r\npm_runtime_get(phy->dev);\r\nreturn IRQ_HANDLED;\r\n}\r\notgsc = readl(USB_OTGSC);\r\nif (!(otgsc & (OTGSC_IDIS | OTGSC_BSVIS)))\r\nreturn IRQ_NONE;\r\nif ((otgsc & OTGSC_IDIS) && (otgsc & OTGSC_IDIE)) {\r\nif (otgsc & OTGSC_ID)\r\nset_bit(ID, &motg->inputs);\r\nelse\r\nclear_bit(ID, &motg->inputs);\r\ndev_dbg(phy->dev, "ID set/clear\n");\r\npm_runtime_get_noresume(phy->dev);\r\n} else if ((otgsc & OTGSC_BSVIS) && (otgsc & OTGSC_BSVIE)) {\r\nif (otgsc & OTGSC_BSV)\r\nset_bit(B_SESS_VLD, &motg->inputs);\r\nelse\r\nclear_bit(B_SESS_VLD, &motg->inputs);\r\ndev_dbg(phy->dev, "BSV set/clear\n");\r\npm_runtime_get_noresume(phy->dev);\r\n}\r\nwritel(otgsc, USB_OTGSC);\r\nschedule_work(&motg->sm_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int msm_otg_mode_show(struct seq_file *s, void *unused)\r\n{\r\nstruct msm_otg *motg = s->private;\r\nstruct usb_otg *otg = motg->phy.otg;\r\nswitch (otg->phy->state) {\r\ncase OTG_STATE_A_HOST:\r\nseq_printf(s, "host\n");\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nseq_printf(s, "peripheral\n");\r\nbreak;\r\ndefault:\r\nseq_printf(s, "none\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm_otg_mode_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, msm_otg_mode_show, inode->i_private);\r\n}\r\nstatic ssize_t msm_otg_mode_write(struct file *file, const char __user *ubuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct seq_file *s = file->private_data;\r\nstruct msm_otg *motg = s->private;\r\nchar buf[16];\r\nstruct usb_otg *otg = motg->phy.otg;\r\nint status = count;\r\nenum usb_mode_type req_mode;\r\nmemset(buf, 0x00, sizeof(buf));\r\nif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count))) {\r\nstatus = -EFAULT;\r\ngoto out;\r\n}\r\nif (!strncmp(buf, "host", 4)) {\r\nreq_mode = USB_HOST;\r\n} else if (!strncmp(buf, "peripheral", 10)) {\r\nreq_mode = USB_PERIPHERAL;\r\n} else if (!strncmp(buf, "none", 4)) {\r\nreq_mode = USB_NONE;\r\n} else {\r\nstatus = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (req_mode) {\r\ncase USB_NONE:\r\nswitch (otg->phy->state) {\r\ncase OTG_STATE_A_HOST:\r\ncase OTG_STATE_B_PERIPHERAL:\r\nset_bit(ID, &motg->inputs);\r\nclear_bit(B_SESS_VLD, &motg->inputs);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nbreak;\r\ncase USB_PERIPHERAL:\r\nswitch (otg->phy->state) {\r\ncase OTG_STATE_B_IDLE:\r\ncase OTG_STATE_A_HOST:\r\nset_bit(ID, &motg->inputs);\r\nset_bit(B_SESS_VLD, &motg->inputs);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nbreak;\r\ncase USB_HOST:\r\nswitch (otg->phy->state) {\r\ncase OTG_STATE_B_IDLE:\r\ncase OTG_STATE_B_PERIPHERAL:\r\nclear_bit(ID, &motg->inputs);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\npm_runtime_get_sync(otg->phy->dev);\r\nschedule_work(&motg->sm_work);\r\nout:\r\nreturn status;\r\n}\r\nstatic int msm_otg_debugfs_init(struct msm_otg *motg)\r\n{\r\nmsm_otg_dbg_root = debugfs_create_dir("msm_otg", NULL);\r\nif (!msm_otg_dbg_root || IS_ERR(msm_otg_dbg_root))\r\nreturn -ENODEV;\r\nmsm_otg_dbg_mode = debugfs_create_file("mode", S_IRUGO | S_IWUSR,\r\nmsm_otg_dbg_root, motg, &msm_otg_mode_fops);\r\nif (!msm_otg_dbg_mode) {\r\ndebugfs_remove(msm_otg_dbg_root);\r\nmsm_otg_dbg_root = NULL;\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void msm_otg_debugfs_cleanup(void)\r\n{\r\ndebugfs_remove(msm_otg_dbg_mode);\r\ndebugfs_remove(msm_otg_dbg_root);\r\n}\r\nstatic int __init msm_otg_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct resource *res;\r\nstruct msm_otg *motg;\r\nstruct usb_phy *phy;\r\ndev_info(&pdev->dev, "msm_otg probe\n");\r\nif (!pdev->dev.platform_data) {\r\ndev_err(&pdev->dev, "No platform data given. Bailing out\n");\r\nreturn -ENODEV;\r\n}\r\nmotg = kzalloc(sizeof(struct msm_otg), GFP_KERNEL);\r\nif (!motg) {\r\ndev_err(&pdev->dev, "unable to allocate msm_otg\n");\r\nreturn -ENOMEM;\r\n}\r\nmotg->phy.otg = kzalloc(sizeof(struct usb_otg), GFP_KERNEL);\r\nif (!motg->phy.otg) {\r\ndev_err(&pdev->dev, "unable to allocate msm_otg\n");\r\nreturn -ENOMEM;\r\n}\r\nmotg->pdata = pdev->dev.platform_data;\r\nphy = &motg->phy;\r\nphy->dev = &pdev->dev;\r\nmotg->phy_reset_clk = clk_get(&pdev->dev, "usb_phy_clk");\r\nif (IS_ERR(motg->phy_reset_clk)) {\r\ndev_err(&pdev->dev, "failed to get usb_phy_clk\n");\r\nret = PTR_ERR(motg->phy_reset_clk);\r\ngoto free_motg;\r\n}\r\nmotg->clk = clk_get(&pdev->dev, "usb_hs_clk");\r\nif (IS_ERR(motg->clk)) {\r\ndev_err(&pdev->dev, "failed to get usb_hs_clk\n");\r\nret = PTR_ERR(motg->clk);\r\ngoto put_phy_reset_clk;\r\n}\r\nclk_set_rate(motg->clk, 60000000);\r\nif (motg->pdata->pclk_src_name) {\r\nmotg->pclk_src = clk_get(&pdev->dev,\r\nmotg->pdata->pclk_src_name);\r\nif (IS_ERR(motg->pclk_src))\r\ngoto put_clk;\r\nclk_set_rate(motg->pclk_src, INT_MAX);\r\nclk_enable(motg->pclk_src);\r\n} else\r\nmotg->pclk_src = ERR_PTR(-ENOENT);\r\nmotg->pclk = clk_get(&pdev->dev, "usb_hs_pclk");\r\nif (IS_ERR(motg->pclk)) {\r\ndev_err(&pdev->dev, "failed to get usb_hs_pclk\n");\r\nret = PTR_ERR(motg->pclk);\r\ngoto put_pclk_src;\r\n}\r\nmotg->core_clk = clk_get(&pdev->dev, "usb_hs_core_clk");\r\nif (IS_ERR(motg->core_clk))\r\nmotg->core_clk = NULL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "failed to get platform resource mem\n");\r\nret = -ENODEV;\r\ngoto put_core_clk;\r\n}\r\nmotg->regs = ioremap(res->start, resource_size(res));\r\nif (!motg->regs) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto put_core_clk;\r\n}\r\ndev_info(&pdev->dev, "OTG regs = %p\n", motg->regs);\r\nmotg->irq = platform_get_irq(pdev, 0);\r\nif (!motg->irq) {\r\ndev_err(&pdev->dev, "platform_get_irq failed\n");\r\nret = -ENODEV;\r\ngoto free_regs;\r\n}\r\nclk_enable(motg->clk);\r\nclk_enable(motg->pclk);\r\nret = msm_hsusb_init_vddcx(motg, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "hsusb vddcx configuration failed\n");\r\ngoto free_regs;\r\n}\r\nret = msm_hsusb_ldo_init(motg, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "hsusb vreg configuration failed\n");\r\ngoto vddcx_exit;\r\n}\r\nret = msm_hsusb_ldo_set_mode(1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "hsusb vreg enable failed\n");\r\ngoto ldo_exit;\r\n}\r\nif (motg->core_clk)\r\nclk_enable(motg->core_clk);\r\nwritel(0, USB_USBINTR);\r\nwritel(0, USB_OTGSC);\r\nINIT_WORK(&motg->sm_work, msm_otg_sm_work);\r\nINIT_DELAYED_WORK(&motg->chg_work, msm_chg_detect_work);\r\nret = request_irq(motg->irq, msm_otg_irq, IRQF_SHARED,\r\n"msm_otg", motg);\r\nif (ret) {\r\ndev_err(&pdev->dev, "request irq failed\n");\r\ngoto disable_clks;\r\n}\r\nphy->init = msm_otg_reset;\r\nphy->set_power = msm_otg_set_power;\r\nphy->io_ops = &msm_otg_io_ops;\r\nphy->otg->phy = &motg->phy;\r\nphy->otg->set_host = msm_otg_set_host;\r\nphy->otg->set_peripheral = msm_otg_set_peripheral;\r\nret = usb_add_phy(&motg->phy, USB_PHY_TYPE_USB2);\r\nif (ret) {\r\ndev_err(&pdev->dev, "usb_add_phy failed\n");\r\ngoto free_irq;\r\n}\r\nplatform_set_drvdata(pdev, motg);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nif (motg->pdata->mode == USB_OTG &&\r\nmotg->pdata->otg_control == OTG_USER_CONTROL) {\r\nret = msm_otg_debugfs_init(motg);\r\nif (ret)\r\ndev_dbg(&pdev->dev, "mode debugfs file is"\r\n"not available\n");\r\n}\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nreturn 0;\r\nfree_irq:\r\nfree_irq(motg->irq, motg);\r\ndisable_clks:\r\nclk_disable(motg->pclk);\r\nclk_disable(motg->clk);\r\nldo_exit:\r\nmsm_hsusb_ldo_init(motg, 0);\r\nvddcx_exit:\r\nmsm_hsusb_init_vddcx(motg, 0);\r\nfree_regs:\r\niounmap(motg->regs);\r\nput_core_clk:\r\nif (motg->core_clk)\r\nclk_put(motg->core_clk);\r\nclk_put(motg->pclk);\r\nput_pclk_src:\r\nif (!IS_ERR(motg->pclk_src)) {\r\nclk_disable(motg->pclk_src);\r\nclk_put(motg->pclk_src);\r\n}\r\nput_clk:\r\nclk_put(motg->clk);\r\nput_phy_reset_clk:\r\nclk_put(motg->phy_reset_clk);\r\nfree_motg:\r\nkfree(motg->phy.otg);\r\nkfree(motg);\r\nreturn ret;\r\n}\r\nstatic int __devexit msm_otg_remove(struct platform_device *pdev)\r\n{\r\nstruct msm_otg *motg = platform_get_drvdata(pdev);\r\nstruct usb_phy *phy = &motg->phy;\r\nint cnt = 0;\r\nif (phy->otg->host || phy->otg->gadget)\r\nreturn -EBUSY;\r\nmsm_otg_debugfs_cleanup();\r\ncancel_delayed_work_sync(&motg->chg_work);\r\ncancel_work_sync(&motg->sm_work);\r\npm_runtime_resume(&pdev->dev);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\npm_runtime_disable(&pdev->dev);\r\nusb_remove_phy(phy);\r\nfree_irq(motg->irq, motg);\r\nulpi_read(phy, 0x14);\r\nulpi_write(phy, 0x08, 0x09);\r\nwritel(readl(USB_PORTSC) | PORTSC_PHCD, USB_PORTSC);\r\nwhile (cnt < PHY_SUSPEND_TIMEOUT_USEC) {\r\nif (readl(USB_PORTSC) & PORTSC_PHCD)\r\nbreak;\r\nudelay(1);\r\ncnt++;\r\n}\r\nif (cnt >= PHY_SUSPEND_TIMEOUT_USEC)\r\ndev_err(phy->dev, "Unable to suspend PHY\n");\r\nclk_disable(motg->pclk);\r\nclk_disable(motg->clk);\r\nif (motg->core_clk)\r\nclk_disable(motg->core_clk);\r\nif (!IS_ERR(motg->pclk_src)) {\r\nclk_disable(motg->pclk_src);\r\nclk_put(motg->pclk_src);\r\n}\r\nmsm_hsusb_ldo_init(motg, 0);\r\niounmap(motg->regs);\r\npm_runtime_set_suspended(&pdev->dev);\r\nclk_put(motg->phy_reset_clk);\r\nclk_put(motg->pclk);\r\nclk_put(motg->clk);\r\nif (motg->core_clk)\r\nclk_put(motg->core_clk);\r\nkfree(motg->phy.otg);\r\nkfree(motg);\r\nreturn 0;\r\n}\r\nstatic int msm_otg_runtime_idle(struct device *dev)\r\n{\r\nstruct msm_otg *motg = dev_get_drvdata(dev);\r\nstruct usb_otg *otg = motg->phy.otg;\r\ndev_dbg(dev, "OTG runtime idle\n");\r\nif (otg->phy->state != OTG_STATE_UNDEFINED)\r\npm_schedule_suspend(dev, 1000);\r\nreturn -EAGAIN;\r\n}\r\nstatic int msm_otg_runtime_suspend(struct device *dev)\r\n{\r\nstruct msm_otg *motg = dev_get_drvdata(dev);\r\ndev_dbg(dev, "OTG runtime suspend\n");\r\nreturn msm_otg_suspend(motg);\r\n}\r\nstatic int msm_otg_runtime_resume(struct device *dev)\r\n{\r\nstruct msm_otg *motg = dev_get_drvdata(dev);\r\ndev_dbg(dev, "OTG runtime resume\n");\r\nreturn msm_otg_resume(motg);\r\n}\r\nstatic int msm_otg_pm_suspend(struct device *dev)\r\n{\r\nstruct msm_otg *motg = dev_get_drvdata(dev);\r\ndev_dbg(dev, "OTG PM suspend\n");\r\nreturn msm_otg_suspend(motg);\r\n}\r\nstatic int msm_otg_pm_resume(struct device *dev)\r\n{\r\nstruct msm_otg *motg = dev_get_drvdata(dev);\r\nint ret;\r\ndev_dbg(dev, "OTG PM resume\n");\r\nret = msm_otg_resume(motg);\r\nif (ret)\r\nreturn ret;\r\npm_runtime_disable(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\nreturn 0;\r\n}\r\nstatic int __init msm_otg_init(void)\r\n{\r\nreturn platform_driver_probe(&msm_otg_driver, msm_otg_probe);\r\n}\r\nstatic void __exit msm_otg_exit(void)\r\n{\r\nplatform_driver_unregister(&msm_otg_driver);\r\n}
