static int lm8323_write(struct lm8323_chip *lm, int len, ...)\r\n{\r\nint ret, i;\r\nva_list ap;\r\nu8 data[LM8323_MAX_DATA];\r\nva_start(ap, len);\r\nif (unlikely(len > LM8323_MAX_DATA)) {\r\ndev_err(&lm->client->dev, "tried to send %d bytes\n", len);\r\nva_end(ap);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < len; i++)\r\ndata[i] = va_arg(ap, int);\r\nva_end(ap);\r\nret = i2c_master_send(lm->client, data, len);\r\nif (unlikely(ret == -EREMOTEIO))\r\nret = i2c_master_send(lm->client, data, len);\r\nif (unlikely(ret != len))\r\ndev_err(&lm->client->dev, "sent %d bytes of %d total\n",\r\nlen, ret);\r\nreturn ret;\r\n}\r\nstatic int lm8323_read(struct lm8323_chip *lm, u8 cmd, u8 *buf, int len)\r\n{\r\nint ret;\r\nret = i2c_master_send(lm->client, &cmd, 1);\r\nif (unlikely(ret == -EREMOTEIO))\r\nret = i2c_master_send(lm->client, &cmd, 1);\r\nif (unlikely(ret != 1)) {\r\ndev_err(&lm->client->dev, "sending read cmd 0x%02x failed\n",\r\ncmd);\r\nreturn 0;\r\n}\r\nret = i2c_master_recv(lm->client, buf, len);\r\nif (unlikely(ret != len))\r\ndev_err(&lm->client->dev, "wanted %d bytes, got %d\n",\r\nlen, ret);\r\nreturn ret;\r\n}\r\nstatic void lm8323_set_active_time(struct lm8323_chip *lm, int time)\r\n{\r\nlm8323_write(lm, 2, LM8323_CMD_SET_ACTIVE, time >> 2);\r\n}\r\nstatic inline u8 lm8323_whichkey(u8 event)\r\n{\r\nreturn event & 0x7f;\r\n}\r\nstatic inline int lm8323_ispress(u8 event)\r\n{\r\nreturn (event & 0x80) ? 1 : 0;\r\n}\r\nstatic void process_keys(struct lm8323_chip *lm)\r\n{\r\nu8 event;\r\nu8 key_fifo[LM8323_FIFO_LEN + 1];\r\nint old_keys_down = lm->keys_down;\r\nint ret;\r\nint i = 0;\r\nret = lm8323_read(lm, LM8323_CMD_READ_FIFO, key_fifo, LM8323_FIFO_LEN);\r\nif (ret < 0) {\r\ndev_err(&lm->client->dev, "Failed reading fifo \n");\r\nreturn;\r\n}\r\nkey_fifo[ret] = 0;\r\nwhile ((event = key_fifo[i++])) {\r\nu8 key = lm8323_whichkey(event);\r\nint isdown = lm8323_ispress(event);\r\nunsigned short keycode = lm->keymap[key];\r\ndev_vdbg(&lm->client->dev, "key 0x%02x %s\n",\r\nkey, isdown ? "down" : "up");\r\nif (lm->kp_enabled) {\r\ninput_event(lm->idev, EV_MSC, MSC_SCAN, key);\r\ninput_report_key(lm->idev, keycode, isdown);\r\ninput_sync(lm->idev);\r\n}\r\nif (isdown)\r\nlm->keys_down++;\r\nelse\r\nlm->keys_down--;\r\n}\r\nif (!old_keys_down && lm->keys_down)\r\nlm8323_set_active_time(lm, 0);\r\nif (old_keys_down && !lm->keys_down)\r\nlm8323_set_active_time(lm, lm->active_time);\r\n}\r\nstatic void lm8323_process_error(struct lm8323_chip *lm)\r\n{\r\nu8 error;\r\nif (lm8323_read(lm, LM8323_CMD_READ_ERR, &error, 1) == 1) {\r\nif (error & ERR_FIFOOVER)\r\ndev_vdbg(&lm->client->dev, "fifo overflow!\n");\r\nif (error & ERR_KEYOVR)\r\ndev_vdbg(&lm->client->dev,\r\n"more than two keys pressed\n");\r\nif (error & ERR_CMDUNK)\r\ndev_vdbg(&lm->client->dev,\r\n"unknown command submitted\n");\r\nif (error & ERR_BADPAR)\r\ndev_vdbg(&lm->client->dev, "bad command parameter\n");\r\n}\r\n}\r\nstatic void lm8323_reset(struct lm8323_chip *lm)\r\n{\r\nlm8323_write(lm, 2, LM8323_CMD_RESET, 0xAA);\r\n}\r\nstatic int lm8323_configure(struct lm8323_chip *lm)\r\n{\r\nint keysize = (lm->size_x << 4) | lm->size_y;\r\nint clock = (CLK_SLOWCLKEN | CLK_RCPWM_EXTERNAL);\r\nint debounce = lm->debounce_time >> 2;\r\nint active = lm->active_time >> 2;\r\nif (debounce >= active)\r\nactive = debounce + 3;\r\nlm8323_write(lm, 2, LM8323_CMD_WRITE_CFG, 0);\r\nlm8323_write(lm, 2, LM8323_CMD_WRITE_CLOCK, clock);\r\nlm8323_write(lm, 2, LM8323_CMD_SET_KEY_SIZE, keysize);\r\nlm8323_set_active_time(lm, lm->active_time);\r\nlm8323_write(lm, 2, LM8323_CMD_SET_DEBOUNCE, debounce);\r\nlm8323_write(lm, 3, LM8323_CMD_WRITE_PORT_STATE, 0xff, 0xff);\r\nlm8323_write(lm, 3, LM8323_CMD_WRITE_PORT_SEL, 0, 0);\r\nreturn 0;\r\n}\r\nstatic void pwm_done(struct lm8323_pwm *pwm)\r\n{\r\nmutex_lock(&pwm->lock);\r\npwm->running = false;\r\nif (pwm->desired_brightness != pwm->brightness)\r\nschedule_work(&pwm->work);\r\nmutex_unlock(&pwm->lock);\r\n}\r\nstatic irqreturn_t lm8323_irq(int irq, void *_lm)\r\n{\r\nstruct lm8323_chip *lm = _lm;\r\nu8 ints;\r\nint i;\r\nmutex_lock(&lm->lock);\r\nwhile ((lm8323_read(lm, LM8323_CMD_READ_INT, &ints, 1) == 1) && ints) {\r\nif (likely(ints & INT_KEYPAD))\r\nprocess_keys(lm);\r\nif (ints & INT_ROTATOR) {\r\ndev_vdbg(&lm->client->dev, "rotator fired\n");\r\n}\r\nif (ints & INT_ERROR) {\r\ndev_vdbg(&lm->client->dev, "error!\n");\r\nlm8323_process_error(lm);\r\n}\r\nif (ints & INT_NOINIT) {\r\ndev_err(&lm->client->dev, "chip lost config; "\r\n"reinitialising\n");\r\nlm8323_configure(lm);\r\n}\r\nfor (i = 0; i < LM8323_NUM_PWMS; i++) {\r\nif (ints & (1 << (INT_PWM1 + i))) {\r\ndev_vdbg(&lm->client->dev,\r\n"pwm%d engine completed\n", i);\r\npwm_done(&lm->pwm[i]);\r\n}\r\n}\r\n}\r\nmutex_unlock(&lm->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lm8323_read_id(struct lm8323_chip *lm, u8 *buf)\r\n{\r\nint bytes;\r\nbytes = lm8323_read(lm, LM8323_CMD_READ_ID, buf, 2);\r\nif (unlikely(bytes != 2))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void lm8323_write_pwm_one(struct lm8323_pwm *pwm, int pos, u16 cmd)\r\n{\r\nlm8323_write(pwm->chip, 4, LM8323_CMD_PWM_WRITE, (pos << 2) | pwm->id,\r\n(cmd & 0xff00) >> 8, cmd & 0x00ff);\r\n}\r\nstatic void lm8323_write_pwm(struct lm8323_pwm *pwm, int kill,\r\nint len, const u16 *cmds)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nlm8323_write_pwm_one(pwm, i, cmds[i]);\r\nlm8323_write_pwm_one(pwm, i++, PWM_END(kill));\r\nlm8323_write(pwm->chip, 2, LM8323_CMD_START_PWM, pwm->id);\r\npwm->running = true;\r\n}\r\nstatic void lm8323_pwm_work(struct work_struct *work)\r\n{\r\nstruct lm8323_pwm *pwm = work_to_pwm(work);\r\nint div512, perstep, steps, hz, up, kill;\r\nu16 pwm_cmds[3];\r\nint num_cmds = 0;\r\nmutex_lock(&pwm->lock);\r\nif (pwm->running || pwm->desired_brightness == pwm->brightness)\r\ngoto out;\r\nkill = (pwm->desired_brightness == 0);\r\nup = (pwm->desired_brightness > pwm->brightness);\r\nsteps = abs(pwm->desired_brightness - pwm->brightness);\r\nif ((pwm->fade_time / steps) > (32768 / 512)) {\r\ndiv512 = 1;\r\nhz = 32768 / 512;\r\n} else {\r\ndiv512 = 0;\r\nhz = 32768 / 16;\r\n}\r\nperstep = (hz * pwm->fade_time) / (steps * 1000);\r\nif (perstep == 0)\r\nperstep = 1;\r\nelse if (perstep > 63)\r\nperstep = 63;\r\nwhile (steps) {\r\nint s;\r\ns = min(126, steps);\r\npwm_cmds[num_cmds++] = PWM_RAMP(div512, perstep, s, up);\r\nsteps -= s;\r\n}\r\nlm8323_write_pwm(pwm, kill, num_cmds, pwm_cmds);\r\npwm->brightness = pwm->desired_brightness;\r\nout:\r\nmutex_unlock(&pwm->lock);\r\n}\r\nstatic void lm8323_pwm_set_brightness(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct lm8323_pwm *pwm = cdev_to_pwm(led_cdev);\r\nstruct lm8323_chip *lm = pwm->chip;\r\nmutex_lock(&pwm->lock);\r\npwm->desired_brightness = brightness;\r\nmutex_unlock(&pwm->lock);\r\nif (in_interrupt()) {\r\nschedule_work(&pwm->work);\r\n} else {\r\nmutex_lock(&lm->lock);\r\nif (likely(!lm->pm_suspend))\r\nschedule_work(&pwm->work);\r\nelse\r\nlm8323_pwm_work(&pwm->work);\r\nmutex_unlock(&lm->lock);\r\n}\r\n}\r\nstatic ssize_t lm8323_pwm_show_time(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm8323_pwm *pwm = cdev_to_pwm(led_cdev);\r\nreturn sprintf(buf, "%d\n", pwm->fade_time);\r\n}\r\nstatic ssize_t lm8323_pwm_store_time(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm8323_pwm *pwm = cdev_to_pwm(led_cdev);\r\nint ret, time;\r\nret = kstrtoint(buf, 10, &time);\r\nif (ret)\r\nreturn ret;\r\npwm->fade_time = time;\r\nreturn strlen(buf);\r\n}\r\nstatic int init_pwm(struct lm8323_chip *lm, int id, struct device *dev,\r\nconst char *name)\r\n{\r\nstruct lm8323_pwm *pwm;\r\nBUG_ON(id > 3);\r\npwm = &lm->pwm[id - 1];\r\npwm->id = id;\r\npwm->fade_time = 0;\r\npwm->brightness = 0;\r\npwm->desired_brightness = 0;\r\npwm->running = false;\r\npwm->enabled = false;\r\nINIT_WORK(&pwm->work, lm8323_pwm_work);\r\nmutex_init(&pwm->lock);\r\npwm->chip = lm;\r\nif (name) {\r\npwm->cdev.name = name;\r\npwm->cdev.brightness_set = lm8323_pwm_set_brightness;\r\nif (led_classdev_register(dev, &pwm->cdev) < 0) {\r\ndev_err(dev, "couldn't register PWM %d\n", id);\r\nreturn -1;\r\n}\r\nif (device_create_file(pwm->cdev.dev,\r\n&dev_attr_time) < 0) {\r\ndev_err(dev, "couldn't register time attribute\n");\r\nled_classdev_unregister(&pwm->cdev);\r\nreturn -1;\r\n}\r\npwm->enabled = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t lm8323_show_disable(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lm8323_chip *lm = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", !lm->kp_enabled);\r\n}\r\nstatic ssize_t lm8323_set_disable(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct lm8323_chip *lm = dev_get_drvdata(dev);\r\nint ret;\r\nunsigned int i;\r\nret = kstrtouint(buf, 10, &i);\r\nmutex_lock(&lm->lock);\r\nlm->kp_enabled = !i;\r\nmutex_unlock(&lm->lock);\r\nreturn count;\r\n}\r\nstatic int __devinit lm8323_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lm8323_platform_data *pdata = client->dev.platform_data;\r\nstruct input_dev *idev;\r\nstruct lm8323_chip *lm;\r\nint pwm;\r\nint i, err;\r\nunsigned long tmo;\r\nu8 data[2];\r\nif (!pdata || !pdata->size_x || !pdata->size_y) {\r\ndev_err(&client->dev, "missing platform_data\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata->size_x > 8) {\r\ndev_err(&client->dev, "invalid x size %d specified\n",\r\npdata->size_x);\r\nreturn -EINVAL;\r\n}\r\nif (pdata->size_y > 12) {\r\ndev_err(&client->dev, "invalid y size %d specified\n",\r\npdata->size_y);\r\nreturn -EINVAL;\r\n}\r\nlm = kzalloc(sizeof *lm, GFP_KERNEL);\r\nidev = input_allocate_device();\r\nif (!lm || !idev) {\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\nlm->client = client;\r\nlm->idev = idev;\r\nmutex_init(&lm->lock);\r\nlm->size_x = pdata->size_x;\r\nlm->size_y = pdata->size_y;\r\ndev_vdbg(&client->dev, "Keypad size: %d x %d\n",\r\nlm->size_x, lm->size_y);\r\nlm->debounce_time = pdata->debounce_time;\r\nlm->active_time = pdata->active_time;\r\nlm8323_reset(lm);\r\ntmo = jiffies + msecs_to_jiffies(100);\r\nwhile (lm8323_read(lm, LM8323_CMD_READ_INT, data, 1) == 1) {\r\nif (data[0] & INT_NOINIT)\r\nbreak;\r\nif (time_after(jiffies, tmo)) {\r\ndev_err(&client->dev,\r\n"timeout waiting for initialisation\n");\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\nlm8323_configure(lm);\r\nif (lm8323_read_id(lm, data) != 0) {\r\ndev_err(&client->dev, "device not found\n");\r\nerr = -ENODEV;\r\ngoto fail1;\r\n}\r\nfor (pwm = 0; pwm < LM8323_NUM_PWMS; pwm++) {\r\nerr = init_pwm(lm, pwm + 1, &client->dev,\r\npdata->pwm_names[pwm]);\r\nif (err < 0)\r\ngoto fail2;\r\n}\r\nlm->kp_enabled = true;\r\nerr = device_create_file(&client->dev, &dev_attr_disable_kp);\r\nif (err < 0)\r\ngoto fail2;\r\nidev->name = pdata->name ? : "LM8323 keypad";\r\nsnprintf(lm->phys, sizeof(lm->phys),\r\n"%s/input-kp", dev_name(&client->dev));\r\nidev->phys = lm->phys;\r\nidev->evbit[0] = BIT(EV_KEY) | BIT(EV_MSC);\r\n__set_bit(MSC_SCAN, idev->mscbit);\r\nfor (i = 0; i < LM8323_KEYMAP_SIZE; i++) {\r\n__set_bit(pdata->keymap[i], idev->keybit);\r\nlm->keymap[i] = pdata->keymap[i];\r\n}\r\n__clear_bit(KEY_RESERVED, idev->keybit);\r\nif (pdata->repeat)\r\n__set_bit(EV_REP, idev->evbit);\r\nerr = input_register_device(idev);\r\nif (err) {\r\ndev_dbg(&client->dev, "error registering input device\n");\r\ngoto fail3;\r\n}\r\nerr = request_threaded_irq(client->irq, NULL, lm8323_irq,\r\nIRQF_TRIGGER_LOW|IRQF_ONESHOT, "lm8323", lm);\r\nif (err) {\r\ndev_err(&client->dev, "could not get IRQ %d\n", client->irq);\r\ngoto fail4;\r\n}\r\ni2c_set_clientdata(client, lm);\r\ndevice_init_wakeup(&client->dev, 1);\r\nenable_irq_wake(client->irq);\r\nreturn 0;\r\nfail4:\r\ninput_unregister_device(idev);\r\nidev = NULL;\r\nfail3:\r\ndevice_remove_file(&client->dev, &dev_attr_disable_kp);\r\nfail2:\r\nwhile (--pwm >= 0)\r\nif (lm->pwm[pwm].enabled) {\r\ndevice_remove_file(lm->pwm[pwm].cdev.dev,\r\n&dev_attr_time);\r\nled_classdev_unregister(&lm->pwm[pwm].cdev);\r\n}\r\nfail1:\r\ninput_free_device(idev);\r\nkfree(lm);\r\nreturn err;\r\n}\r\nstatic int __devexit lm8323_remove(struct i2c_client *client)\r\n{\r\nstruct lm8323_chip *lm = i2c_get_clientdata(client);\r\nint i;\r\ndisable_irq_wake(client->irq);\r\nfree_irq(client->irq, lm);\r\ninput_unregister_device(lm->idev);\r\ndevice_remove_file(&lm->client->dev, &dev_attr_disable_kp);\r\nfor (i = 0; i < 3; i++)\r\nif (lm->pwm[i].enabled) {\r\ndevice_remove_file(lm->pwm[i].cdev.dev, &dev_attr_time);\r\nled_classdev_unregister(&lm->pwm[i].cdev);\r\n}\r\nkfree(lm);\r\nreturn 0;\r\n}\r\nstatic int lm8323_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm8323_chip *lm = i2c_get_clientdata(client);\r\nint i;\r\nirq_set_irq_wake(client->irq, 0);\r\ndisable_irq(client->irq);\r\nmutex_lock(&lm->lock);\r\nlm->pm_suspend = true;\r\nmutex_unlock(&lm->lock);\r\nfor (i = 0; i < 3; i++)\r\nif (lm->pwm[i].enabled)\r\nled_classdev_suspend(&lm->pwm[i].cdev);\r\nreturn 0;\r\n}\r\nstatic int lm8323_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm8323_chip *lm = i2c_get_clientdata(client);\r\nint i;\r\nmutex_lock(&lm->lock);\r\nlm->pm_suspend = false;\r\nmutex_unlock(&lm->lock);\r\nfor (i = 0; i < 3; i++)\r\nif (lm->pwm[i].enabled)\r\nled_classdev_resume(&lm->pwm[i].cdev);\r\nenable_irq(client->irq);\r\nirq_set_irq_wake(client->irq, 1);\r\nreturn 0;\r\n}
