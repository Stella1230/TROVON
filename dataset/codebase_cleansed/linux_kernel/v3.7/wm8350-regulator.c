static int get_isink_val(int min_uA, int max_uA, u16 *setting)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(isink_cur); i++) {\r\nif (min_uA <= isink_cur[i] && max_uA >= isink_cur[i]) {\r\n*setting = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int wm8350_isink_set_current(struct regulator_dev *rdev, int min_uA,\r\nint max_uA)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint isink = rdev_get_id(rdev);\r\nu16 val, setting;\r\nint ret;\r\nret = get_isink_val(min_uA, max_uA, &setting);\r\nif (ret != 0)\r\nreturn ret;\r\nswitch (isink) {\r\ncase WM8350_ISINK_A:\r\nval = wm8350_reg_read(wm8350, WM8350_CURRENT_SINK_DRIVER_A) &\r\n~WM8350_CS1_ISEL_MASK;\r\nwm8350_reg_write(wm8350, WM8350_CURRENT_SINK_DRIVER_A,\r\nval | setting);\r\nbreak;\r\ncase WM8350_ISINK_B:\r\nval = wm8350_reg_read(wm8350, WM8350_CURRENT_SINK_DRIVER_B) &\r\n~WM8350_CS1_ISEL_MASK;\r\nwm8350_reg_write(wm8350, WM8350_CURRENT_SINK_DRIVER_B,\r\nval | setting);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_isink_get_current(struct regulator_dev *rdev)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint isink = rdev_get_id(rdev);\r\nu16 val;\r\nswitch (isink) {\r\ncase WM8350_ISINK_A:\r\nval = wm8350_reg_read(wm8350, WM8350_CURRENT_SINK_DRIVER_A) &\r\nWM8350_CS1_ISEL_MASK;\r\nbreak;\r\ncase WM8350_ISINK_B:\r\nval = wm8350_reg_read(wm8350, WM8350_CURRENT_SINK_DRIVER_B) &\r\nWM8350_CS1_ISEL_MASK;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn isink_cur[val];\r\n}\r\nstatic int wm8350_isink_enable(struct regulator_dev *rdev)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint isink = rdev_get_id(rdev);\r\nswitch (isink) {\r\ncase WM8350_ISINK_A:\r\nswitch (wm8350->pmic.isink_A_dcdc) {\r\ncase WM8350_DCDC_2:\r\ncase WM8350_DCDC_5:\r\nwm8350_set_bits(wm8350, WM8350_POWER_MGMT_7,\r\nWM8350_CS1_ENA);\r\nwm8350_set_bits(wm8350, WM8350_CSA_FLASH_CONTROL,\r\nWM8350_CS1_DRIVE);\r\nwm8350_set_bits(wm8350, WM8350_DCDC_LDO_REQUESTED,\r\n1 << (wm8350->pmic.isink_A_dcdc -\r\nWM8350_DCDC_1));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase WM8350_ISINK_B:\r\nswitch (wm8350->pmic.isink_B_dcdc) {\r\ncase WM8350_DCDC_2:\r\ncase WM8350_DCDC_5:\r\nwm8350_set_bits(wm8350, WM8350_POWER_MGMT_7,\r\nWM8350_CS2_ENA);\r\nwm8350_set_bits(wm8350, WM8350_CSB_FLASH_CONTROL,\r\nWM8350_CS2_DRIVE);\r\nwm8350_set_bits(wm8350, WM8350_DCDC_LDO_REQUESTED,\r\n1 << (wm8350->pmic.isink_B_dcdc -\r\nWM8350_DCDC_1));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_isink_disable(struct regulator_dev *rdev)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint isink = rdev_get_id(rdev);\r\nswitch (isink) {\r\ncase WM8350_ISINK_A:\r\nswitch (wm8350->pmic.isink_A_dcdc) {\r\ncase WM8350_DCDC_2:\r\ncase WM8350_DCDC_5:\r\nwm8350_clear_bits(wm8350, WM8350_DCDC_LDO_REQUESTED,\r\n1 << (wm8350->pmic.isink_A_dcdc -\r\nWM8350_DCDC_1));\r\nwm8350_clear_bits(wm8350, WM8350_POWER_MGMT_7,\r\nWM8350_CS1_ENA);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase WM8350_ISINK_B:\r\nswitch (wm8350->pmic.isink_B_dcdc) {\r\ncase WM8350_DCDC_2:\r\ncase WM8350_DCDC_5:\r\nwm8350_clear_bits(wm8350, WM8350_DCDC_LDO_REQUESTED,\r\n1 << (wm8350->pmic.isink_B_dcdc -\r\nWM8350_DCDC_1));\r\nwm8350_clear_bits(wm8350, WM8350_POWER_MGMT_7,\r\nWM8350_CS2_ENA);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_isink_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint isink = rdev_get_id(rdev);\r\nswitch (isink) {\r\ncase WM8350_ISINK_A:\r\nreturn wm8350_reg_read(wm8350, WM8350_CURRENT_SINK_DRIVER_A) &\r\n0x8000;\r\ncase WM8350_ISINK_B:\r\nreturn wm8350_reg_read(wm8350, WM8350_CURRENT_SINK_DRIVER_B) &\r\n0x8000;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int wm8350_isink_enable_time(struct regulator_dev *rdev)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint isink = rdev_get_id(rdev);\r\nint reg;\r\nswitch (isink) {\r\ncase WM8350_ISINK_A:\r\nreg = wm8350_reg_read(wm8350, WM8350_CSA_FLASH_CONTROL);\r\nbreak;\r\ncase WM8350_ISINK_B:\r\nreg = wm8350_reg_read(wm8350, WM8350_CSB_FLASH_CONTROL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (reg & WM8350_CS1_FLASH_MODE) {\r\nswitch (reg & WM8350_CS1_ON_RAMP_MASK) {\r\ncase 0:\r\nreturn 0;\r\ncase 1:\r\nreturn 1950;\r\ncase 2:\r\nreturn 3910;\r\ncase 3:\r\nreturn 7800;\r\n}\r\n} else {\r\nswitch (reg & WM8350_CS1_ON_RAMP_MASK) {\r\ncase 0:\r\nreturn 0;\r\ncase 1:\r\nreturn 250000;\r\ncase 2:\r\nreturn 500000;\r\ncase 3:\r\nreturn 1000000;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint wm8350_isink_set_flash(struct wm8350 *wm8350, int isink, u16 mode,\r\nu16 trigger, u16 duration, u16 on_ramp, u16 off_ramp,\r\nu16 drive)\r\n{\r\nswitch (isink) {\r\ncase WM8350_ISINK_A:\r\nwm8350_reg_write(wm8350, WM8350_CSA_FLASH_CONTROL,\r\n(mode ? WM8350_CS1_FLASH_MODE : 0) |\r\n(trigger ? WM8350_CS1_TRIGSRC : 0) |\r\nduration | on_ramp | off_ramp | drive);\r\nbreak;\r\ncase WM8350_ISINK_B:\r\nwm8350_reg_write(wm8350, WM8350_CSB_FLASH_CONTROL,\r\n(mode ? WM8350_CS2_FLASH_MODE : 0) |\r\n(trigger ? WM8350_CS2_TRIGSRC : 0) |\r\nduration | on_ramp | off_ramp | drive);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_dcdc_set_suspend_voltage(struct regulator_dev *rdev, int uV)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint sel, volt_reg, dcdc = rdev_get_id(rdev);\r\nu16 val;\r\ndev_dbg(wm8350->dev, "%s %d mV %d\n", __func__, dcdc, uV / 1000);\r\nswitch (dcdc) {\r\ncase WM8350_DCDC_1:\r\nvolt_reg = WM8350_DCDC1_LOW_POWER;\r\nbreak;\r\ncase WM8350_DCDC_3:\r\nvolt_reg = WM8350_DCDC3_LOW_POWER;\r\nbreak;\r\ncase WM8350_DCDC_4:\r\nvolt_reg = WM8350_DCDC4_LOW_POWER;\r\nbreak;\r\ncase WM8350_DCDC_6:\r\nvolt_reg = WM8350_DCDC6_LOW_POWER;\r\nbreak;\r\ncase WM8350_DCDC_2:\r\ncase WM8350_DCDC_5:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsel = regulator_map_voltage_linear(rdev, uV, uV);\r\nif (sel < 0)\r\nreturn -EINVAL;\r\nval = wm8350_reg_read(wm8350, volt_reg) & ~WM8350_DC1_VSEL_MASK;\r\nwm8350_reg_write(wm8350, volt_reg, val | sel);\r\nreturn 0;\r\n}\r\nstatic int wm8350_dcdc_set_suspend_enable(struct regulator_dev *rdev)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint dcdc = rdev_get_id(rdev);\r\nu16 val;\r\nswitch (dcdc) {\r\ncase WM8350_DCDC_1:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC1_LOW_POWER)\r\n& ~WM8350_DCDC_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, WM8350_DCDC1_LOW_POWER,\r\nval | wm8350->pmic.dcdc1_hib_mode);\r\nbreak;\r\ncase WM8350_DCDC_3:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC3_LOW_POWER)\r\n& ~WM8350_DCDC_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, WM8350_DCDC3_LOW_POWER,\r\nval | wm8350->pmic.dcdc3_hib_mode);\r\nbreak;\r\ncase WM8350_DCDC_4:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC4_LOW_POWER)\r\n& ~WM8350_DCDC_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, WM8350_DCDC4_LOW_POWER,\r\nval | wm8350->pmic.dcdc4_hib_mode);\r\nbreak;\r\ncase WM8350_DCDC_6:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC6_LOW_POWER)\r\n& ~WM8350_DCDC_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, WM8350_DCDC6_LOW_POWER,\r\nval | wm8350->pmic.dcdc6_hib_mode);\r\nbreak;\r\ncase WM8350_DCDC_2:\r\ncase WM8350_DCDC_5:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_dcdc_set_suspend_disable(struct regulator_dev *rdev)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint dcdc = rdev_get_id(rdev);\r\nu16 val;\r\nswitch (dcdc) {\r\ncase WM8350_DCDC_1:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC1_LOW_POWER);\r\nwm8350->pmic.dcdc1_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, WM8350_DCDC1_LOW_POWER,\r\nval | WM8350_DCDC_HIB_MODE_DIS);\r\nbreak;\r\ncase WM8350_DCDC_3:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC3_LOW_POWER);\r\nwm8350->pmic.dcdc3_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, WM8350_DCDC3_LOW_POWER,\r\nval | WM8350_DCDC_HIB_MODE_DIS);\r\nbreak;\r\ncase WM8350_DCDC_4:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC4_LOW_POWER);\r\nwm8350->pmic.dcdc4_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, WM8350_DCDC4_LOW_POWER,\r\nval | WM8350_DCDC_HIB_MODE_DIS);\r\nbreak;\r\ncase WM8350_DCDC_6:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC6_LOW_POWER);\r\nwm8350->pmic.dcdc6_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, WM8350_DCDC6_LOW_POWER,\r\nval | WM8350_DCDC_HIB_MODE_DIS);\r\nbreak;\r\ncase WM8350_DCDC_2:\r\ncase WM8350_DCDC_5:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_dcdc25_set_suspend_enable(struct regulator_dev *rdev)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint dcdc = rdev_get_id(rdev);\r\nu16 val;\r\nswitch (dcdc) {\r\ncase WM8350_DCDC_2:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC2_CONTROL)\r\n& ~WM8350_DC2_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, WM8350_DCDC2_CONTROL, val |\r\n(WM8350_DC2_HIB_MODE_ACTIVE << WM8350_DC2_HIB_MODE_SHIFT));\r\nbreak;\r\ncase WM8350_DCDC_5:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC5_CONTROL)\r\n& ~WM8350_DC5_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, WM8350_DCDC5_CONTROL, val |\r\n(WM8350_DC5_HIB_MODE_ACTIVE << WM8350_DC5_HIB_MODE_SHIFT));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_dcdc25_set_suspend_disable(struct regulator_dev *rdev)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint dcdc = rdev_get_id(rdev);\r\nu16 val;\r\nswitch (dcdc) {\r\ncase WM8350_DCDC_2:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC2_CONTROL)\r\n& ~WM8350_DC2_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, WM8350_DCDC2_CONTROL, val |\r\n(WM8350_DC2_HIB_MODE_DISABLE << WM8350_DC2_HIB_MODE_SHIFT));\r\nbreak;\r\ncase WM8350_DCDC_5:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC5_CONTROL)\r\n& ~WM8350_DC5_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, WM8350_DCDC5_CONTROL, val |\r\n(WM8350_DC5_HIB_MODE_DISABLE << WM8350_DC5_HIB_MODE_SHIFT));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_dcdc_set_suspend_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint dcdc = rdev_get_id(rdev);\r\nu16 *hib_mode;\r\nswitch (dcdc) {\r\ncase WM8350_DCDC_1:\r\nhib_mode = &wm8350->pmic.dcdc1_hib_mode;\r\nbreak;\r\ncase WM8350_DCDC_3:\r\nhib_mode = &wm8350->pmic.dcdc3_hib_mode;\r\nbreak;\r\ncase WM8350_DCDC_4:\r\nhib_mode = &wm8350->pmic.dcdc4_hib_mode;\r\nbreak;\r\ncase WM8350_DCDC_6:\r\nhib_mode = &wm8350->pmic.dcdc6_hib_mode;\r\nbreak;\r\ncase WM8350_DCDC_2:\r\ncase WM8350_DCDC_5:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\n*hib_mode = WM8350_DCDC_HIB_MODE_IMAGE;\r\nbreak;\r\ncase REGULATOR_MODE_IDLE:\r\n*hib_mode = WM8350_DCDC_HIB_MODE_STANDBY;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\n*hib_mode = WM8350_DCDC_HIB_MODE_LDO_IM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_ldo_list_voltage(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nif (selector > WM8350_LDO1_VSEL_MASK)\r\nreturn -EINVAL;\r\nif (selector < 16)\r\nreturn (selector * 50000) + 900000;\r\nelse\r\nreturn ((selector - 16) * 100000) + 1800000;\r\n}\r\nstatic int wm8350_ldo_map_voltage(struct regulator_dev *rdev, int min_uV,\r\nint max_uV)\r\n{\r\nint volt, sel;\r\nint min_mV = min_uV / 1000;\r\nint max_mV = max_uV / 1000;\r\nif (min_mV < 900 || min_mV > 3300)\r\nreturn -EINVAL;\r\nif (max_mV < 900 || max_mV > 3300)\r\nreturn -EINVAL;\r\nif (min_mV < 1800)\r\nsel = DIV_ROUND_UP(min_uV - 900, 50);\r\nelse\r\nsel = DIV_ROUND_UP(min_uV - 1800, 100) + 16;\r\nvolt = wm8350_ldo_list_voltage(rdev, sel);\r\nif (volt < min_uV || volt > max_uV)\r\nreturn -EINVAL;\r\nreturn sel;\r\n}\r\nstatic int wm8350_ldo_set_suspend_voltage(struct regulator_dev *rdev, int uV)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint sel, volt_reg, ldo = rdev_get_id(rdev);\r\nu16 val;\r\ndev_dbg(wm8350->dev, "%s %d mV %d\n", __func__, ldo, uV / 1000);\r\nswitch (ldo) {\r\ncase WM8350_LDO_1:\r\nvolt_reg = WM8350_LDO1_LOW_POWER;\r\nbreak;\r\ncase WM8350_LDO_2:\r\nvolt_reg = WM8350_LDO2_LOW_POWER;\r\nbreak;\r\ncase WM8350_LDO_3:\r\nvolt_reg = WM8350_LDO3_LOW_POWER;\r\nbreak;\r\ncase WM8350_LDO_4:\r\nvolt_reg = WM8350_LDO4_LOW_POWER;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsel = wm8350_ldo_map_voltage(rdev, uV, uV);\r\nif (sel < 0)\r\nreturn -EINVAL;\r\nval = wm8350_reg_read(wm8350, volt_reg) & ~WM8350_LDO1_VSEL_MASK;\r\nwm8350_reg_write(wm8350, volt_reg, val | sel);\r\nreturn 0;\r\n}\r\nstatic int wm8350_ldo_set_suspend_enable(struct regulator_dev *rdev)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint volt_reg, ldo = rdev_get_id(rdev);\r\nu16 val;\r\nswitch (ldo) {\r\ncase WM8350_LDO_1:\r\nvolt_reg = WM8350_LDO1_LOW_POWER;\r\nbreak;\r\ncase WM8350_LDO_2:\r\nvolt_reg = WM8350_LDO2_LOW_POWER;\r\nbreak;\r\ncase WM8350_LDO_3:\r\nvolt_reg = WM8350_LDO3_LOW_POWER;\r\nbreak;\r\ncase WM8350_LDO_4:\r\nvolt_reg = WM8350_LDO4_LOW_POWER;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval = wm8350_reg_read(wm8350, volt_reg) & ~WM8350_LDO1_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, volt_reg, val);\r\nreturn 0;\r\n}\r\nstatic int wm8350_ldo_set_suspend_disable(struct regulator_dev *rdev)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint volt_reg, ldo = rdev_get_id(rdev);\r\nu16 val;\r\nswitch (ldo) {\r\ncase WM8350_LDO_1:\r\nvolt_reg = WM8350_LDO1_LOW_POWER;\r\nbreak;\r\ncase WM8350_LDO_2:\r\nvolt_reg = WM8350_LDO2_LOW_POWER;\r\nbreak;\r\ncase WM8350_LDO_3:\r\nvolt_reg = WM8350_LDO3_LOW_POWER;\r\nbreak;\r\ncase WM8350_LDO_4:\r\nvolt_reg = WM8350_LDO4_LOW_POWER;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval = wm8350_reg_read(wm8350, volt_reg) & ~WM8350_LDO1_HIB_MODE_MASK;\r\nwm8350_reg_write(wm8350, volt_reg, val | WM8350_LDO1_HIB_MODE_DIS);\r\nreturn 0;\r\n}\r\nint wm8350_dcdc_set_slot(struct wm8350 *wm8350, int dcdc, u16 start,\r\nu16 stop, u16 fault)\r\n{\r\nint slot_reg;\r\nu16 val;\r\ndev_dbg(wm8350->dev, "%s %d start %d stop %d\n",\r\n__func__, dcdc, start, stop);\r\nif (start > 15 || stop > 15)\r\nreturn -EINVAL;\r\nswitch (dcdc) {\r\ncase WM8350_DCDC_1:\r\nslot_reg = WM8350_DCDC1_TIMEOUTS;\r\nbreak;\r\ncase WM8350_DCDC_2:\r\nslot_reg = WM8350_DCDC2_TIMEOUTS;\r\nbreak;\r\ncase WM8350_DCDC_3:\r\nslot_reg = WM8350_DCDC3_TIMEOUTS;\r\nbreak;\r\ncase WM8350_DCDC_4:\r\nslot_reg = WM8350_DCDC4_TIMEOUTS;\r\nbreak;\r\ncase WM8350_DCDC_5:\r\nslot_reg = WM8350_DCDC5_TIMEOUTS;\r\nbreak;\r\ncase WM8350_DCDC_6:\r\nslot_reg = WM8350_DCDC6_TIMEOUTS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval = wm8350_reg_read(wm8350, slot_reg) &\r\n~(WM8350_DC1_ENSLOT_MASK | WM8350_DC1_SDSLOT_MASK |\r\nWM8350_DC1_ERRACT_MASK);\r\nwm8350_reg_write(wm8350, slot_reg,\r\nval | (start << WM8350_DC1_ENSLOT_SHIFT) |\r\n(stop << WM8350_DC1_SDSLOT_SHIFT) |\r\n(fault << WM8350_DC1_ERRACT_SHIFT));\r\nreturn 0;\r\n}\r\nint wm8350_ldo_set_slot(struct wm8350 *wm8350, int ldo, u16 start, u16 stop)\r\n{\r\nint slot_reg;\r\nu16 val;\r\ndev_dbg(wm8350->dev, "%s %d start %d stop %d\n",\r\n__func__, ldo, start, stop);\r\nif (start > 15 || stop > 15)\r\nreturn -EINVAL;\r\nswitch (ldo) {\r\ncase WM8350_LDO_1:\r\nslot_reg = WM8350_LDO1_TIMEOUTS;\r\nbreak;\r\ncase WM8350_LDO_2:\r\nslot_reg = WM8350_LDO2_TIMEOUTS;\r\nbreak;\r\ncase WM8350_LDO_3:\r\nslot_reg = WM8350_LDO3_TIMEOUTS;\r\nbreak;\r\ncase WM8350_LDO_4:\r\nslot_reg = WM8350_LDO4_TIMEOUTS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval = wm8350_reg_read(wm8350, slot_reg) & ~WM8350_LDO1_SDSLOT_MASK;\r\nwm8350_reg_write(wm8350, slot_reg, val | ((start << 10) | (stop << 6)));\r\nreturn 0;\r\n}\r\nint wm8350_dcdc25_set_mode(struct wm8350 *wm8350, int dcdc, u16 mode,\r\nu16 ilim, u16 ramp, u16 feedback)\r\n{\r\nu16 val;\r\ndev_dbg(wm8350->dev, "%s %d mode: %s %s\n", __func__, dcdc,\r\nmode ? "normal" : "boost", ilim ? "low" : "normal");\r\nswitch (dcdc) {\r\ncase WM8350_DCDC_2:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC2_CONTROL)\r\n& ~(WM8350_DC2_MODE_MASK | WM8350_DC2_ILIM_MASK |\r\nWM8350_DC2_RMP_MASK | WM8350_DC2_FBSRC_MASK);\r\nwm8350_reg_write(wm8350, WM8350_DCDC2_CONTROL, val |\r\n(mode << WM8350_DC2_MODE_SHIFT) |\r\n(ilim << WM8350_DC2_ILIM_SHIFT) |\r\n(ramp << WM8350_DC2_RMP_SHIFT) |\r\n(feedback << WM8350_DC2_FBSRC_SHIFT));\r\nbreak;\r\ncase WM8350_DCDC_5:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC5_CONTROL)\r\n& ~(WM8350_DC5_MODE_MASK | WM8350_DC5_ILIM_MASK |\r\nWM8350_DC5_RMP_MASK | WM8350_DC5_FBSRC_MASK);\r\nwm8350_reg_write(wm8350, WM8350_DCDC5_CONTROL, val |\r\n(mode << WM8350_DC5_MODE_SHIFT) |\r\n(ilim << WM8350_DC5_ILIM_SHIFT) |\r\n(ramp << WM8350_DC5_RMP_SHIFT) |\r\n(feedback << WM8350_DC5_FBSRC_SHIFT));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int force_continuous_enable(struct wm8350 *wm8350, int dcdc, int enable)\r\n{\r\nint reg = 0, ret;\r\nswitch (dcdc) {\r\ncase WM8350_DCDC_1:\r\nreg = WM8350_DCDC1_FORCE_PWM;\r\nbreak;\r\ncase WM8350_DCDC_3:\r\nreg = WM8350_DCDC3_FORCE_PWM;\r\nbreak;\r\ncase WM8350_DCDC_4:\r\nreg = WM8350_DCDC4_FORCE_PWM;\r\nbreak;\r\ncase WM8350_DCDC_6:\r\nreg = WM8350_DCDC6_FORCE_PWM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (enable)\r\nret = wm8350_set_bits(wm8350, reg,\r\nWM8350_DCDC1_FORCE_PWM_ENA);\r\nelse\r\nret = wm8350_clear_bits(wm8350, reg,\r\nWM8350_DCDC1_FORCE_PWM_ENA);\r\nreturn ret;\r\n}\r\nstatic int wm8350_dcdc_set_mode(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint dcdc = rdev_get_id(rdev);\r\nu16 val;\r\nif (dcdc < WM8350_DCDC_1 || dcdc > WM8350_DCDC_6)\r\nreturn -EINVAL;\r\nif (dcdc == WM8350_DCDC_2 || dcdc == WM8350_DCDC_5)\r\nreturn -EINVAL;\r\nval = 1 << (dcdc - WM8350_DCDC_1);\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nwm8350_set_bits(wm8350, WM8350_DCDC_ACTIVE_OPTIONS, val);\r\nwm8350_clear_bits(wm8350, WM8350_DCDC_SLEEP_OPTIONS, val);\r\nforce_continuous_enable(wm8350, dcdc, 1);\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nwm8350_set_bits(wm8350, WM8350_DCDC_ACTIVE_OPTIONS, val);\r\nwm8350_clear_bits(wm8350, WM8350_DCDC_SLEEP_OPTIONS, val);\r\nforce_continuous_enable(wm8350, dcdc, 0);\r\nbreak;\r\ncase REGULATOR_MODE_IDLE:\r\nforce_continuous_enable(wm8350, dcdc, 0);\r\nwm8350_clear_bits(wm8350, WM8350_DCDC_SLEEP_OPTIONS, val);\r\nwm8350_clear_bits(wm8350, WM8350_DCDC_ACTIVE_OPTIONS, val);\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nforce_continuous_enable(wm8350, dcdc, 0);\r\nwm8350_set_bits(wm8350, WM8350_DCDC_SLEEP_OPTIONS, val);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int wm8350_dcdc_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nint dcdc = rdev_get_id(rdev);\r\nu16 mask, sleep, active, force;\r\nint mode = REGULATOR_MODE_NORMAL;\r\nint reg;\r\nswitch (dcdc) {\r\ncase WM8350_DCDC_1:\r\nreg = WM8350_DCDC1_FORCE_PWM;\r\nbreak;\r\ncase WM8350_DCDC_3:\r\nreg = WM8350_DCDC3_FORCE_PWM;\r\nbreak;\r\ncase WM8350_DCDC_4:\r\nreg = WM8350_DCDC4_FORCE_PWM;\r\nbreak;\r\ncase WM8350_DCDC_6:\r\nreg = WM8350_DCDC6_FORCE_PWM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmask = 1 << (dcdc - WM8350_DCDC_1);\r\nactive = wm8350_reg_read(wm8350, WM8350_DCDC_ACTIVE_OPTIONS) & mask;\r\nforce = wm8350_reg_read(wm8350, reg) & WM8350_DCDC1_FORCE_PWM_ENA;\r\nsleep = wm8350_reg_read(wm8350, WM8350_DCDC_SLEEP_OPTIONS) & mask;\r\ndev_dbg(wm8350->dev, "mask %x active %x sleep %x force %x",\r\nmask, active, sleep, force);\r\nif (active && !sleep) {\r\nif (force)\r\nmode = REGULATOR_MODE_FAST;\r\nelse\r\nmode = REGULATOR_MODE_NORMAL;\r\n} else if (!active && !sleep)\r\nmode = REGULATOR_MODE_IDLE;\r\nelse if (sleep)\r\nmode = REGULATOR_MODE_STANDBY;\r\nreturn mode;\r\n}\r\nstatic unsigned int wm8350_ldo_get_mode(struct regulator_dev *rdev)\r\n{\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic unsigned int get_mode(int uA, const struct wm8350_dcdc_efficiency *eff)\r\n{\r\nint i = 0;\r\nwhile (eff[i].uA_load_min != -1) {\r\nif (uA >= eff[i].uA_load_min && uA <= eff[i].uA_load_max)\r\nreturn eff[i].mode;\r\n}\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic unsigned int wm8350_dcdc_get_optimum_mode(struct regulator_dev *rdev,\r\nint input_uV, int output_uV,\r\nint output_uA)\r\n{\r\nint dcdc = rdev_get_id(rdev), mode;\r\nswitch (dcdc) {\r\ncase WM8350_DCDC_1:\r\ncase WM8350_DCDC_6:\r\nmode = get_mode(output_uA, dcdc1_6_efficiency);\r\nbreak;\r\ncase WM8350_DCDC_3:\r\ncase WM8350_DCDC_4:\r\nmode = get_mode(output_uA, dcdc3_4_efficiency);\r\nbreak;\r\ndefault:\r\nmode = REGULATOR_MODE_NORMAL;\r\nbreak;\r\n}\r\nreturn mode;\r\n}\r\nstatic irqreturn_t pmic_uv_handler(int irq, void *data)\r\n{\r\nstruct regulator_dev *rdev = (struct regulator_dev *)data;\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nmutex_lock(&rdev->mutex);\r\nif (irq == WM8350_IRQ_CS1 || irq == WM8350_IRQ_CS2)\r\nregulator_notifier_call_chain(rdev,\r\nREGULATOR_EVENT_REGULATION_OUT,\r\nwm8350);\r\nelse\r\nregulator_notifier_call_chain(rdev,\r\nREGULATOR_EVENT_UNDER_VOLTAGE,\r\nwm8350);\r\nmutex_unlock(&rdev->mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wm8350_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct wm8350 *wm8350 = dev_get_drvdata(&pdev->dev);\r\nstruct regulator_config config = { };\r\nstruct regulator_dev *rdev;\r\nint ret;\r\nu16 val;\r\nif (pdev->id < WM8350_DCDC_1 || pdev->id > WM8350_ISINK_B)\r\nreturn -ENODEV;\r\nswitch (pdev->id) {\r\ncase WM8350_DCDC_1:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC1_LOW_POWER);\r\nwm8350->pmic.dcdc1_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\r\nbreak;\r\ncase WM8350_DCDC_3:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC3_LOW_POWER);\r\nwm8350->pmic.dcdc3_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\r\nbreak;\r\ncase WM8350_DCDC_4:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC4_LOW_POWER);\r\nwm8350->pmic.dcdc4_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\r\nbreak;\r\ncase WM8350_DCDC_6:\r\nval = wm8350_reg_read(wm8350, WM8350_DCDC6_LOW_POWER);\r\nwm8350->pmic.dcdc6_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\r\nbreak;\r\n}\r\nconfig.dev = &pdev->dev;\r\nconfig.init_data = pdev->dev.platform_data;\r\nconfig.driver_data = dev_get_drvdata(&pdev->dev);\r\nconfig.regmap = wm8350->regmap;\r\nrdev = regulator_register(&wm8350_reg[pdev->id], &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "failed to register %s\n",\r\nwm8350_reg[pdev->id].name);\r\nreturn PTR_ERR(rdev);\r\n}\r\nret = wm8350_register_irq(wm8350, wm8350_reg[pdev->id].irq,\r\npmic_uv_handler, 0, "UV", rdev);\r\nif (ret < 0) {\r\nregulator_unregister(rdev);\r\ndev_err(&pdev->dev, "failed to register regulator %s IRQ\n",\r\nwm8350_reg[pdev->id].name);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8350_regulator_remove(struct platform_device *pdev)\r\n{\r\nstruct regulator_dev *rdev = platform_get_drvdata(pdev);\r\nstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\r\nwm8350_free_irq(wm8350, wm8350_reg[pdev->id].irq, rdev);\r\nregulator_unregister(rdev);\r\nreturn 0;\r\n}\r\nint wm8350_register_regulator(struct wm8350 *wm8350, int reg,\r\nstruct regulator_init_data *initdata)\r\n{\r\nstruct platform_device *pdev;\r\nint ret;\r\nif (reg < 0 || reg >= NUM_WM8350_REGULATORS)\r\nreturn -EINVAL;\r\nif (wm8350->pmic.pdev[reg])\r\nreturn -EBUSY;\r\nif (reg >= WM8350_DCDC_1 && reg <= WM8350_DCDC_6 &&\r\nreg > wm8350->pmic.max_dcdc)\r\nreturn -ENODEV;\r\nif (reg >= WM8350_ISINK_A && reg <= WM8350_ISINK_B &&\r\nreg > wm8350->pmic.max_isink)\r\nreturn -ENODEV;\r\npdev = platform_device_alloc("wm8350-regulator", reg);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\nwm8350->pmic.pdev[reg] = pdev;\r\ninitdata->driver_data = wm8350;\r\npdev->dev.platform_data = initdata;\r\npdev->dev.parent = wm8350->dev;\r\nplatform_set_drvdata(pdev, wm8350);\r\nret = platform_device_add(pdev);\r\nif (ret != 0) {\r\ndev_err(wm8350->dev, "Failed to register regulator %d: %d\n",\r\nreg, ret);\r\nplatform_device_put(pdev);\r\nwm8350->pmic.pdev[reg] = NULL;\r\n}\r\nreturn ret;\r\n}\r\nint wm8350_register_led(struct wm8350 *wm8350, int lednum, int dcdc, int isink,\r\nstruct wm8350_led_platform_data *pdata)\r\n{\r\nstruct wm8350_led *led;\r\nstruct platform_device *pdev;\r\nint ret;\r\nif (lednum >= ARRAY_SIZE(wm8350->pmic.led) || lednum < 0) {\r\ndev_err(wm8350->dev, "Invalid LED index %d\n", lednum);\r\nreturn -ENODEV;\r\n}\r\nled = &wm8350->pmic.led[lednum];\r\nif (led->pdev) {\r\ndev_err(wm8350->dev, "LED %d already allocated\n", lednum);\r\nreturn -EINVAL;\r\n}\r\npdev = platform_device_alloc("wm8350-led", lednum);\r\nif (pdev == NULL) {\r\ndev_err(wm8350->dev, "Failed to allocate LED %d\n", lednum);\r\nreturn -ENOMEM;\r\n}\r\nled->isink_consumer.dev_name = dev_name(&pdev->dev);\r\nled->isink_consumer.supply = "led_isink";\r\nled->isink_init.num_consumer_supplies = 1;\r\nled->isink_init.consumer_supplies = &led->isink_consumer;\r\nled->isink_init.constraints.min_uA = 0;\r\nled->isink_init.constraints.max_uA = pdata->max_uA;\r\nled->isink_init.constraints.valid_ops_mask\r\n= REGULATOR_CHANGE_CURRENT | REGULATOR_CHANGE_STATUS;\r\nled->isink_init.constraints.valid_modes_mask = REGULATOR_MODE_NORMAL;\r\nret = wm8350_register_regulator(wm8350, isink, &led->isink_init);\r\nif (ret != 0) {\r\nplatform_device_put(pdev);\r\nreturn ret;\r\n}\r\nled->dcdc_consumer.dev_name = dev_name(&pdev->dev);\r\nled->dcdc_consumer.supply = "led_vcc";\r\nled->dcdc_init.num_consumer_supplies = 1;\r\nled->dcdc_init.consumer_supplies = &led->dcdc_consumer;\r\nled->dcdc_init.constraints.valid_modes_mask = REGULATOR_MODE_NORMAL;\r\nled->dcdc_init.constraints.valid_ops_mask = REGULATOR_CHANGE_STATUS;\r\nret = wm8350_register_regulator(wm8350, dcdc, &led->dcdc_init);\r\nif (ret != 0) {\r\nplatform_device_put(pdev);\r\nreturn ret;\r\n}\r\nswitch (isink) {\r\ncase WM8350_ISINK_A:\r\nwm8350->pmic.isink_A_dcdc = dcdc;\r\nbreak;\r\ncase WM8350_ISINK_B:\r\nwm8350->pmic.isink_B_dcdc = dcdc;\r\nbreak;\r\n}\r\npdev->dev.platform_data = pdata;\r\npdev->dev.parent = wm8350->dev;\r\nret = platform_device_add(pdev);\r\nif (ret != 0) {\r\ndev_err(wm8350->dev, "Failed to register LED %d: %d\n",\r\nlednum, ret);\r\nplatform_device_put(pdev);\r\nreturn ret;\r\n}\r\nled->pdev = pdev;\r\nreturn 0;\r\n}\r\nstatic int __init wm8350_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&wm8350_regulator_driver);\r\n}\r\nstatic void __exit wm8350_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&wm8350_regulator_driver);\r\n}
