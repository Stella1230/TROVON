static int sh_pfc_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->nr_pads;\r\n}\r\nstatic const char *sh_pfc_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->pads[selector].name;\r\n}\r\nstatic int sh_pfc_get_group_pins(struct pinctrl_dev *pctldev, unsigned group,\r\nconst unsigned **pins, unsigned *num_pins)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = &pmx->pads[group].number;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic void sh_pfc_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nunsigned offset)\r\n{\r\nseq_printf(s, "%s", DRV_NAME);\r\n}\r\nstatic int sh_pfc_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->nr_functions;\r\n}\r\nstatic const char *sh_pfc_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->functions[selector]->name;\r\n}\r\nstatic int sh_pfc_get_function_groups(struct pinctrl_dev *pctldev, unsigned func,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = &pmx->functions[func]->name;\r\n*num_groups = 1;\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_noop_enable(struct pinctrl_dev *pctldev, unsigned func,\r\nunsigned group)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sh_pfc_noop_disable(struct pinctrl_dev *pctldev, unsigned func,\r\nunsigned group)\r\n{\r\n}\r\nstatic inline int sh_pfc_config_function(struct sh_pfc *pfc, unsigned offset)\r\n{\r\nif (sh_pfc_config_gpio(pfc, offset,\r\nPINMUX_TYPE_FUNCTION,\r\nGPIO_CFG_DRYRUN) != 0)\r\nreturn -EINVAL;\r\nif (sh_pfc_config_gpio(pfc, offset,\r\nPINMUX_TYPE_FUNCTION,\r\nGPIO_CFG_REQ) != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_reconfig_pin(struct sh_pfc *pfc, unsigned offset,\r\nint new_type)\r\n{\r\nunsigned long flags;\r\nint pinmux_type;\r\nint ret = -EINVAL;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\npinmux_type = pfc->gpios[offset].flags & PINMUX_FLAG_TYPE;\r\nswitch (pinmux_type) {\r\ncase PINMUX_TYPE_GPIO:\r\nbreak;\r\ncase PINMUX_TYPE_OUTPUT:\r\ncase PINMUX_TYPE_INPUT:\r\ncase PINMUX_TYPE_INPUT_PULLUP:\r\ncase PINMUX_TYPE_INPUT_PULLDOWN:\r\nsh_pfc_config_gpio(pfc, offset, pinmux_type, GPIO_CFG_FREE);\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nif (sh_pfc_config_gpio(pfc, offset, new_type,\r\nGPIO_CFG_DRYRUN) != 0)\r\ngoto err;\r\nif (sh_pfc_config_gpio(pfc, offset, new_type,\r\nGPIO_CFG_REQ) != 0)\r\ngoto err;\r\npfc->gpios[offset].flags &= ~PINMUX_FLAG_TYPE;\r\npfc->gpios[offset].flags |= new_type;\r\nret = 0;\r\nerr:\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int sh_pfc_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nunsigned long flags;\r\nint ret, pinmux_type;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\npinmux_type = pfc->gpios[offset].flags & PINMUX_FLAG_TYPE;\r\nswitch (pinmux_type) {\r\ncase PINMUX_TYPE_FUNCTION:\r\npr_notice_once("Use of GPIO API for function requests is "\r\n"deprecated, convert to pinctrl\n");\r\nret = sh_pfc_config_function(pfc, offset);\r\nif (unlikely(ret < 0))\r\ngoto err;\r\nbreak;\r\ncase PINMUX_TYPE_GPIO:\r\ncase PINMUX_TYPE_INPUT:\r\ncase PINMUX_TYPE_OUTPUT:\r\nbreak;\r\ndefault:\r\npr_err("Unsupported mux type (%d), bailing...\n", pinmux_type);\r\nret = -ENOTSUPP;\r\ngoto err;\r\n}\r\nret = 0;\r\nerr:\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void sh_pfc_gpio_disable_free(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nunsigned long flags;\r\nint pinmux_type;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\npinmux_type = pfc->gpios[offset].flags & PINMUX_FLAG_TYPE;\r\nsh_pfc_config_gpio(pfc, offset, pinmux_type, GPIO_CFG_FREE);\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\n}\r\nstatic int sh_pfc_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset, bool input)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nint type = input ? PINMUX_TYPE_INPUT : PINMUX_TYPE_OUTPUT;\r\nreturn sh_pfc_reconfig_pin(pmx->pfc, offset, type);\r\n}\r\nstatic int sh_pfc_pinconf_get(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *config)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\n*config = pfc->gpios[pin].flags & PINMUX_FLAG_TYPE;\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_pinconf_set(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long config)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nif (config >= PINMUX_FLAG_TYPE)\r\nreturn -EINVAL;\r\nreturn sh_pfc_reconfig_pin(pmx->pfc, pin, config);\r\n}\r\nstatic void sh_pfc_pinconf_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned pin)\r\n{\r\nconst char *pinmux_type_str[] = {\r\n[PINMUX_TYPE_NONE] = "none",\r\n[PINMUX_TYPE_FUNCTION] = "function",\r\n[PINMUX_TYPE_GPIO] = "gpio",\r\n[PINMUX_TYPE_OUTPUT] = "output",\r\n[PINMUX_TYPE_INPUT] = "input",\r\n[PINMUX_TYPE_INPUT_PULLUP] = "input bias pull up",\r\n[PINMUX_TYPE_INPUT_PULLDOWN] = "input bias pull down",\r\n};\r\nunsigned long config;\r\nint rc;\r\nrc = sh_pfc_pinconf_get(pctldev, pin, &config);\r\nif (unlikely(rc != 0))\r\nreturn;\r\nseq_printf(s, " %s", pinmux_type_str[config]);\r\n}\r\nstatic inline void __devinit sh_pfc_map_one_gpio(struct sh_pfc *pfc,\r\nstruct sh_pfc_pinctrl *pmx,\r\nstruct pinmux_gpio *gpio,\r\nunsigned offset)\r\n{\r\nstruct pinmux_data_reg *dummy;\r\nunsigned long flags;\r\nint bit;\r\ngpio->flags &= ~PINMUX_FLAG_TYPE;\r\nif (sh_pfc_get_data_reg(pfc, offset, &dummy, &bit) == 0)\r\ngpio->flags |= PINMUX_TYPE_GPIO;\r\nelse {\r\ngpio->flags |= PINMUX_TYPE_FUNCTION;\r\nspin_lock_irqsave(&pmx->lock, flags);\r\npmx->nr_functions++;\r\nspin_unlock_irqrestore(&pmx->lock, flags);\r\n}\r\n}\r\nstatic int __devinit sh_pfc_map_gpios(struct sh_pfc *pfc,\r\nstruct sh_pfc_pinctrl *pmx)\r\n{\r\nunsigned long flags;\r\nint i;\r\npmx->nr_pads = pfc->last_gpio - pfc->first_gpio + 1;\r\npmx->pads = kmalloc(sizeof(struct pinctrl_pin_desc) * pmx->nr_pads,\r\nGFP_KERNEL);\r\nif (unlikely(!pmx->pads)) {\r\npmx->nr_pads = 0;\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nfor (i = 0; i < pmx->nr_pads; i++) {\r\nstruct pinctrl_pin_desc *pin = pmx->pads + i;\r\nstruct pinmux_gpio *gpio = pfc->gpios + i;\r\npin->number = pfc->first_gpio + i;\r\npin->name = gpio->name;\r\nif (unlikely(!gpio->enum_id))\r\ncontinue;\r\nsh_pfc_map_one_gpio(pfc, pmx, gpio, i);\r\n}\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nsh_pfc_pinctrl_desc.pins = pmx->pads;\r\nsh_pfc_pinctrl_desc.npins = pmx->nr_pads;\r\nreturn 0;\r\n}\r\nstatic int __devinit sh_pfc_map_functions(struct sh_pfc *pfc,\r\nstruct sh_pfc_pinctrl *pmx)\r\n{\r\nunsigned long flags;\r\nint i, fn;\r\npmx->functions = kzalloc(pmx->nr_functions * sizeof(void *),\r\nGFP_KERNEL);\r\nif (unlikely(!pmx->functions))\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&pmx->lock, flags);\r\nfor (i = fn = 0; i < pmx->nr_pads; i++) {\r\nstruct pinmux_gpio *gpio = pfc->gpios + i;\r\nif ((gpio->flags & PINMUX_FLAG_TYPE) == PINMUX_TYPE_FUNCTION)\r\npmx->functions[fn++] = gpio;\r\n}\r\nspin_unlock_irqrestore(&pmx->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __devinit sh_pfc_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_pfc *pfc;\r\nint ret;\r\nif (unlikely(!sh_pfc_pmx))\r\nreturn -ENODEV;\r\npfc = sh_pfc_pmx->pfc;\r\nret = sh_pfc_map_gpios(pfc, sh_pfc_pmx);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = sh_pfc_map_functions(pfc, sh_pfc_pmx);\r\nif (unlikely(ret != 0))\r\ngoto free_pads;\r\nsh_pfc_pmx->pctl = pinctrl_register(&sh_pfc_pinctrl_desc, &pdev->dev,\r\nsh_pfc_pmx);\r\nif (IS_ERR(sh_pfc_pmx->pctl)) {\r\nret = PTR_ERR(sh_pfc_pmx->pctl);\r\ngoto free_functions;\r\n}\r\nsh_pfc_gpio_range.npins = pfc->last_gpio - pfc->first_gpio + 1;\r\nsh_pfc_gpio_range.base = pfc->first_gpio;\r\nsh_pfc_gpio_range.pin_base = pfc->first_gpio;\r\npinctrl_add_gpio_range(sh_pfc_pmx->pctl, &sh_pfc_gpio_range);\r\nplatform_set_drvdata(pdev, sh_pfc_pmx);\r\nreturn 0;\r\nfree_functions:\r\nkfree(sh_pfc_pmx->functions);\r\nfree_pads:\r\nkfree(sh_pfc_pmx->pads);\r\nkfree(sh_pfc_pmx);\r\nreturn ret;\r\n}\r\nstatic int __devexit sh_pfc_pinctrl_remove(struct platform_device *pdev)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = platform_get_drvdata(pdev);\r\npinctrl_unregister(pmx->pctl);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(sh_pfc_pmx->functions);\r\nkfree(sh_pfc_pmx->pads);\r\nkfree(sh_pfc_pmx);\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_pinctrl_init(void)\r\n{\r\nint rc;\r\nrc = platform_driver_register(&sh_pfc_pinctrl_driver);\r\nif (likely(!rc)) {\r\nrc = platform_device_register(&sh_pfc_pinctrl_device);\r\nif (unlikely(rc))\r\nplatform_driver_unregister(&sh_pfc_pinctrl_driver);\r\n}\r\nreturn rc;\r\n}\r\nint sh_pfc_register_pinctrl(struct sh_pfc *pfc)\r\n{\r\nsh_pfc_pmx = kzalloc(sizeof(struct sh_pfc_pinctrl), GFP_KERNEL);\r\nif (unlikely(!sh_pfc_pmx))\r\nreturn -ENOMEM;\r\nspin_lock_init(&sh_pfc_pmx->lock);\r\nsh_pfc_pmx->pfc = pfc;\r\nreturn sh_pfc_pinctrl_init();\r\n}\r\nstatic void __exit sh_pfc_pinctrl_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_pfc_pinctrl_driver);\r\n}
