static int nmk_rng_read(struct hwrng *rng, void *data, size_t max, bool wait)\r\n{\r\nvoid __iomem *base = (void __iomem *)rng->priv;\r\n*(u16 *)data = __raw_readl(base + 8) & 0xffff;\r\nreturn 2;\r\n}\r\nstatic int nmk_rng_probe(struct amba_device *dev, const struct amba_id *id)\r\n{\r\nvoid __iomem *base;\r\nint ret;\r\nrng_clk = clk_get(&dev->dev, NULL);\r\nif (IS_ERR(rng_clk)) {\r\ndev_err(&dev->dev, "could not get rng clock\n");\r\nret = PTR_ERR(rng_clk);\r\nreturn ret;\r\n}\r\nclk_enable(rng_clk);\r\nret = amba_request_regions(dev, dev->dev.init_name);\r\nif (ret)\r\ngoto out_clk;\r\nret = -ENOMEM;\r\nbase = ioremap(dev->res.start, resource_size(&dev->res));\r\nif (!base)\r\ngoto out_release;\r\nnmk_rng.priv = (unsigned long)base;\r\nret = hwrng_register(&nmk_rng);\r\nif (ret)\r\ngoto out_unmap;\r\nreturn 0;\r\nout_unmap:\r\niounmap(base);\r\nout_release:\r\namba_release_regions(dev);\r\nout_clk:\r\nclk_disable(rng_clk);\r\nclk_put(rng_clk);\r\nreturn ret;\r\n}\r\nstatic int nmk_rng_remove(struct amba_device *dev)\r\n{\r\nvoid __iomem *base = (void __iomem *)nmk_rng.priv;\r\nhwrng_unregister(&nmk_rng);\r\niounmap(base);\r\namba_release_regions(dev);\r\nclk_disable(rng_clk);\r\nclk_put(rng_clk);\r\nreturn 0;\r\n}
