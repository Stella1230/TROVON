static void __macb_set_hwaddr(struct macb *bp)\r\n{\r\nu32 bottom;\r\nu16 top;\r\nbottom = cpu_to_le32(*((u32 *)bp->dev->dev_addr));\r\nmacb_or_gem_writel(bp, SA1B, bottom);\r\ntop = cpu_to_le16(*((u16 *)(bp->dev->dev_addr + 4)));\r\nmacb_or_gem_writel(bp, SA1T, top);\r\n}\r\nstatic void __init macb_get_hwaddr(struct macb *bp)\r\n{\r\nu32 bottom;\r\nu16 top;\r\nu8 addr[6];\r\nbottom = macb_or_gem_readl(bp, SA1B);\r\ntop = macb_or_gem_readl(bp, SA1T);\r\naddr[0] = bottom & 0xff;\r\naddr[1] = (bottom >> 8) & 0xff;\r\naddr[2] = (bottom >> 16) & 0xff;\r\naddr[3] = (bottom >> 24) & 0xff;\r\naddr[4] = top & 0xff;\r\naddr[5] = (top >> 8) & 0xff;\r\nif (is_valid_ether_addr(addr)) {\r\nmemcpy(bp->dev->dev_addr, addr, sizeof(addr));\r\n} else {\r\nnetdev_info(bp->dev, "invalid hw address, using random\n");\r\neth_hw_addr_random(bp->dev);\r\n}\r\n}\r\nstatic int macb_mdio_read(struct mii_bus *bus, int mii_id, int regnum)\r\n{\r\nstruct macb *bp = bus->priv;\r\nint value;\r\nmacb_writel(bp, MAN, (MACB_BF(SOF, MACB_MAN_SOF)\r\n| MACB_BF(RW, MACB_MAN_READ)\r\n| MACB_BF(PHYA, mii_id)\r\n| MACB_BF(REGA, regnum)\r\n| MACB_BF(CODE, MACB_MAN_CODE)));\r\nwhile (!MACB_BFEXT(IDLE, macb_readl(bp, NSR)))\r\ncpu_relax();\r\nvalue = MACB_BFEXT(DATA, macb_readl(bp, MAN));\r\nreturn value;\r\n}\r\nstatic int macb_mdio_write(struct mii_bus *bus, int mii_id, int regnum,\r\nu16 value)\r\n{\r\nstruct macb *bp = bus->priv;\r\nmacb_writel(bp, MAN, (MACB_BF(SOF, MACB_MAN_SOF)\r\n| MACB_BF(RW, MACB_MAN_WRITE)\r\n| MACB_BF(PHYA, mii_id)\r\n| MACB_BF(REGA, regnum)\r\n| MACB_BF(CODE, MACB_MAN_CODE)\r\n| MACB_BF(DATA, value)));\r\nwhile (!MACB_BFEXT(IDLE, macb_readl(bp, NSR)))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic int macb_mdio_reset(struct mii_bus *bus)\r\n{\r\nreturn 0;\r\n}\r\nstatic void macb_handle_link_change(struct net_device *dev)\r\n{\r\nstruct macb *bp = netdev_priv(dev);\r\nstruct phy_device *phydev = bp->phy_dev;\r\nunsigned long flags;\r\nint status_change = 0;\r\nspin_lock_irqsave(&bp->lock, flags);\r\nif (phydev->link) {\r\nif ((bp->speed != phydev->speed) ||\r\n(bp->duplex != phydev->duplex)) {\r\nu32 reg;\r\nreg = macb_readl(bp, NCFGR);\r\nreg &= ~(MACB_BIT(SPD) | MACB_BIT(FD));\r\nif (phydev->duplex)\r\nreg |= MACB_BIT(FD);\r\nif (phydev->speed == SPEED_100)\r\nreg |= MACB_BIT(SPD);\r\nmacb_writel(bp, NCFGR, reg);\r\nbp->speed = phydev->speed;\r\nbp->duplex = phydev->duplex;\r\nstatus_change = 1;\r\n}\r\n}\r\nif (phydev->link != bp->link) {\r\nif (!phydev->link) {\r\nbp->speed = 0;\r\nbp->duplex = -1;\r\n}\r\nbp->link = phydev->link;\r\nstatus_change = 1;\r\n}\r\nspin_unlock_irqrestore(&bp->lock, flags);\r\nif (status_change) {\r\nif (phydev->link) {\r\nnetif_carrier_on(dev);\r\nnetdev_info(dev, "link up (%d/%s)\n",\r\nphydev->speed,\r\nphydev->duplex == DUPLEX_FULL ?\r\n"Full" : "Half");\r\n} else {\r\nnetif_carrier_off(dev);\r\nnetdev_info(dev, "link down\n");\r\n}\r\n}\r\n}\r\nstatic int macb_mii_probe(struct net_device *dev)\r\n{\r\nstruct macb *bp = netdev_priv(dev);\r\nstruct phy_device *phydev;\r\nint ret;\r\nphydev = phy_find_first(bp->mii_bus);\r\nif (!phydev) {\r\nnetdev_err(dev, "no PHY found\n");\r\nreturn -1;\r\n}\r\nret = phy_connect_direct(dev, phydev, &macb_handle_link_change, 0,\r\nbp->phy_interface);\r\nif (ret) {\r\nnetdev_err(dev, "Could not attach to PHY\n");\r\nreturn ret;\r\n}\r\nphydev->supported &= PHY_BASIC_FEATURES;\r\nphydev->advertising = phydev->supported;\r\nbp->link = 0;\r\nbp->speed = 0;\r\nbp->duplex = -1;\r\nbp->phy_dev = phydev;\r\nreturn 0;\r\n}\r\nstatic int macb_mii_init(struct macb *bp)\r\n{\r\nstruct macb_platform_data *pdata;\r\nint err = -ENXIO, i;\r\nmacb_writel(bp, NCR, MACB_BIT(MPE));\r\nbp->mii_bus = mdiobus_alloc();\r\nif (bp->mii_bus == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nbp->mii_bus->name = "MACB_mii_bus";\r\nbp->mii_bus->read = &macb_mdio_read;\r\nbp->mii_bus->write = &macb_mdio_write;\r\nbp->mii_bus->reset = &macb_mdio_reset;\r\nsnprintf(bp->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",\r\nbp->pdev->name, bp->pdev->id);\r\nbp->mii_bus->priv = bp;\r\nbp->mii_bus->parent = &bp->dev->dev;\r\npdata = bp->pdev->dev.platform_data;\r\nif (pdata)\r\nbp->mii_bus->phy_mask = pdata->phy_mask;\r\nbp->mii_bus->irq = kmalloc(sizeof(int)*PHY_MAX_ADDR, GFP_KERNEL);\r\nif (!bp->mii_bus->irq) {\r\nerr = -ENOMEM;\r\ngoto err_out_free_mdiobus;\r\n}\r\nfor (i = 0; i < PHY_MAX_ADDR; i++)\r\nbp->mii_bus->irq[i] = PHY_POLL;\r\ndev_set_drvdata(&bp->dev->dev, bp->mii_bus);\r\nif (mdiobus_register(bp->mii_bus))\r\ngoto err_out_free_mdio_irq;\r\nif (macb_mii_probe(bp->dev) != 0) {\r\ngoto err_out_unregister_bus;\r\n}\r\nreturn 0;\r\nerr_out_unregister_bus:\r\nmdiobus_unregister(bp->mii_bus);\r\nerr_out_free_mdio_irq:\r\nkfree(bp->mii_bus->irq);\r\nerr_out_free_mdiobus:\r\nmdiobus_free(bp->mii_bus);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void macb_update_stats(struct macb *bp)\r\n{\r\nu32 __iomem *reg = bp->regs + MACB_PFR;\r\nu32 *p = &bp->hw_stats.macb.rx_pause_frames;\r\nu32 *end = &bp->hw_stats.macb.tx_pause_frames + 1;\r\nWARN_ON((unsigned long)(end - p - 1) != (MACB_TPF - MACB_PFR) / 4);\r\nfor(; p < end; p++, reg++)\r\n*p += __raw_readl(reg);\r\n}\r\nstatic void macb_tx(struct macb *bp)\r\n{\r\nunsigned int tail;\r\nunsigned int head;\r\nu32 status;\r\nstatus = macb_readl(bp, TSR);\r\nmacb_writel(bp, TSR, status);\r\nnetdev_dbg(bp->dev, "macb_tx status = %02lx\n", (unsigned long)status);\r\nif (status & (MACB_BIT(UND) | MACB_BIT(TSR_RLE))) {\r\nint i;\r\nnetdev_err(bp->dev, "TX %s, resetting buffers\n",\r\nstatus & MACB_BIT(UND) ?\r\n"underrun" : "retry limit exceeded");\r\nif (status & MACB_BIT(TGO))\r\nmacb_writel(bp, NCR, macb_readl(bp, NCR) & ~MACB_BIT(TE));\r\nhead = bp->tx_head;\r\nfor (i = 0; i < TX_RING_SIZE; i++)\r\nbp->tx_ring[i].ctrl = MACB_BIT(TX_USED);\r\nbp->tx_ring[TX_RING_SIZE - 1].ctrl |= MACB_BIT(TX_WRAP);\r\nfor (tail = bp->tx_tail; tail != head; tail = NEXT_TX(tail)) {\r\nstruct ring_info *rp = &bp->tx_skb[tail];\r\nstruct sk_buff *skb = rp->skb;\r\nBUG_ON(skb == NULL);\r\nrmb();\r\ndma_unmap_single(&bp->pdev->dev, rp->mapping, skb->len,\r\nDMA_TO_DEVICE);\r\nrp->skb = NULL;\r\ndev_kfree_skb_irq(skb);\r\n}\r\nbp->tx_head = bp->tx_tail = 0;\r\nif (status & MACB_BIT(TGO))\r\nmacb_writel(bp, NCR, macb_readl(bp, NCR) | MACB_BIT(TE));\r\n}\r\nif (!(status & MACB_BIT(COMP)))\r\nreturn;\r\nhead = bp->tx_head;\r\nfor (tail = bp->tx_tail; tail != head; tail = NEXT_TX(tail)) {\r\nstruct ring_info *rp = &bp->tx_skb[tail];\r\nstruct sk_buff *skb = rp->skb;\r\nu32 bufstat;\r\nBUG_ON(skb == NULL);\r\nrmb();\r\nbufstat = bp->tx_ring[tail].ctrl;\r\nif (!(bufstat & MACB_BIT(TX_USED)))\r\nbreak;\r\nnetdev_dbg(bp->dev, "skb %u (data %p) TX complete\n",\r\ntail, skb->data);\r\ndma_unmap_single(&bp->pdev->dev, rp->mapping, skb->len,\r\nDMA_TO_DEVICE);\r\nbp->stats.tx_packets++;\r\nbp->stats.tx_bytes += skb->len;\r\nrp->skb = NULL;\r\ndev_kfree_skb_irq(skb);\r\n}\r\nbp->tx_tail = tail;\r\nif (netif_queue_stopped(bp->dev) &&\r\nTX_BUFFS_AVAIL(bp) > MACB_TX_WAKEUP_THRESH)\r\nnetif_wake_queue(bp->dev);\r\n}\r\nstatic int macb_rx_frame(struct macb *bp, unsigned int first_frag,\r\nunsigned int last_frag)\r\n{\r\nunsigned int len;\r\nunsigned int frag;\r\nunsigned int offset = 0;\r\nstruct sk_buff *skb;\r\nlen = MACB_BFEXT(RX_FRMLEN, bp->rx_ring[last_frag].ctrl);\r\nnetdev_dbg(bp->dev, "macb_rx_frame frags %u - %u (len %u)\n",\r\nfirst_frag, last_frag, len);\r\nskb = netdev_alloc_skb(bp->dev, len + RX_OFFSET);\r\nif (!skb) {\r\nbp->stats.rx_dropped++;\r\nfor (frag = first_frag; ; frag = NEXT_RX(frag)) {\r\nbp->rx_ring[frag].addr &= ~MACB_BIT(RX_USED);\r\nif (frag == last_frag)\r\nbreak;\r\n}\r\nwmb();\r\nreturn 1;\r\n}\r\nskb_reserve(skb, RX_OFFSET);\r\nskb_checksum_none_assert(skb);\r\nskb_put(skb, len);\r\nfor (frag = first_frag; ; frag = NEXT_RX(frag)) {\r\nunsigned int frag_len = RX_BUFFER_SIZE;\r\nif (offset + frag_len > len) {\r\nBUG_ON(frag != last_frag);\r\nfrag_len = len - offset;\r\n}\r\nskb_copy_to_linear_data_offset(skb, offset,\r\n(bp->rx_buffers +\r\n(RX_BUFFER_SIZE * frag)),\r\nfrag_len);\r\noffset += RX_BUFFER_SIZE;\r\nbp->rx_ring[frag].addr &= ~MACB_BIT(RX_USED);\r\nwmb();\r\nif (frag == last_frag)\r\nbreak;\r\n}\r\nskb->protocol = eth_type_trans(skb, bp->dev);\r\nbp->stats.rx_packets++;\r\nbp->stats.rx_bytes += len;\r\nnetdev_dbg(bp->dev, "received skb of length %u, csum: %08x\n",\r\nskb->len, skb->csum);\r\nnetif_receive_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void discard_partial_frame(struct macb *bp, unsigned int begin,\r\nunsigned int end)\r\n{\r\nunsigned int frag;\r\nfor (frag = begin; frag != end; frag = NEXT_RX(frag))\r\nbp->rx_ring[frag].addr &= ~MACB_BIT(RX_USED);\r\nwmb();\r\n}\r\nstatic int macb_rx(struct macb *bp, int budget)\r\n{\r\nint received = 0;\r\nunsigned int tail = bp->rx_tail;\r\nint first_frag = -1;\r\nfor (; budget > 0; tail = NEXT_RX(tail)) {\r\nu32 addr, ctrl;\r\nrmb();\r\naddr = bp->rx_ring[tail].addr;\r\nctrl = bp->rx_ring[tail].ctrl;\r\nif (!(addr & MACB_BIT(RX_USED)))\r\nbreak;\r\nif (ctrl & MACB_BIT(RX_SOF)) {\r\nif (first_frag != -1)\r\ndiscard_partial_frame(bp, first_frag, tail);\r\nfirst_frag = tail;\r\n}\r\nif (ctrl & MACB_BIT(RX_EOF)) {\r\nint dropped;\r\nBUG_ON(first_frag == -1);\r\ndropped = macb_rx_frame(bp, first_frag, tail);\r\nfirst_frag = -1;\r\nif (!dropped) {\r\nreceived++;\r\nbudget--;\r\n}\r\n}\r\n}\r\nif (first_frag != -1)\r\nbp->rx_tail = first_frag;\r\nelse\r\nbp->rx_tail = tail;\r\nreturn received;\r\n}\r\nstatic int macb_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct macb *bp = container_of(napi, struct macb, napi);\r\nint work_done;\r\nu32 status;\r\nstatus = macb_readl(bp, RSR);\r\nmacb_writel(bp, RSR, status);\r\nwork_done = 0;\r\nnetdev_dbg(bp->dev, "poll: status = %08lx, budget = %d\n",\r\n(unsigned long)status, budget);\r\nwork_done = macb_rx(bp, budget);\r\nif (work_done < budget) {\r\nnapi_complete(napi);\r\nmacb_writel(bp, IER, MACB_RX_INT_FLAGS);\r\n}\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t macb_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct macb *bp = netdev_priv(dev);\r\nu32 status;\r\nstatus = macb_readl(bp, ISR);\r\nif (unlikely(!status))\r\nreturn IRQ_NONE;\r\nspin_lock(&bp->lock);\r\nwhile (status) {\r\nif (unlikely(!netif_running(dev))) {\r\nmacb_writel(bp, IDR, ~0UL);\r\nbreak;\r\n}\r\nif (status & MACB_RX_INT_FLAGS) {\r\nmacb_writel(bp, IDR, MACB_RX_INT_FLAGS);\r\nif (napi_schedule_prep(&bp->napi)) {\r\nnetdev_dbg(bp->dev, "scheduling RX softirq\n");\r\n__napi_schedule(&bp->napi);\r\n}\r\n}\r\nif (status & (MACB_BIT(TCOMP) | MACB_BIT(ISR_TUND) |\r\nMACB_BIT(ISR_RLE)))\r\nmacb_tx(bp);\r\nif (status & MACB_BIT(ISR_ROVR)) {\r\nif (macb_is_gem(bp))\r\nbp->hw_stats.gem.rx_overruns++;\r\nelse\r\nbp->hw_stats.macb.rx_overruns++;\r\n}\r\nif (status & MACB_BIT(HRESP)) {\r\nnetdev_err(dev, "DMA bus error: HRESP not OK\n");\r\n}\r\nstatus = macb_readl(bp, ISR);\r\n}\r\nspin_unlock(&bp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void macb_poll_controller(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nmacb_interrupt(dev->irq, dev);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int macb_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct macb *bp = netdev_priv(dev);\r\ndma_addr_t mapping;\r\nunsigned int len, entry;\r\nu32 ctrl;\r\nunsigned long flags;\r\n#ifdef DEBUG\r\nnetdev_dbg(bp->dev,\r\n"start_xmit: len %u head %p data %p tail %p end %p\n",\r\nskb->len, skb->head, skb->data,\r\nskb_tail_pointer(skb), skb_end_pointer(skb));\r\nprint_hex_dump(KERN_DEBUG, "data: ", DUMP_PREFIX_OFFSET, 16, 1,\r\nskb->data, 16, true);\r\n#endif\r\nlen = skb->len;\r\nspin_lock_irqsave(&bp->lock, flags);\r\nif (TX_BUFFS_AVAIL(bp) < 1) {\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&bp->lock, flags);\r\nnetdev_err(bp->dev, "BUG! Tx Ring full when queue awake!\n");\r\nnetdev_dbg(bp->dev, "tx_head = %u, tx_tail = %u\n",\r\nbp->tx_head, bp->tx_tail);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nentry = bp->tx_head;\r\nnetdev_dbg(bp->dev, "Allocated ring entry %u\n", entry);\r\nmapping = dma_map_single(&bp->pdev->dev, skb->data,\r\nlen, DMA_TO_DEVICE);\r\nbp->tx_skb[entry].skb = skb;\r\nbp->tx_skb[entry].mapping = mapping;\r\nnetdev_dbg(bp->dev, "Mapped skb data %p to DMA addr %08lx\n",\r\nskb->data, (unsigned long)mapping);\r\nctrl = MACB_BF(TX_FRMLEN, len);\r\nctrl |= MACB_BIT(TX_LAST);\r\nif (entry == (TX_RING_SIZE - 1))\r\nctrl |= MACB_BIT(TX_WRAP);\r\nbp->tx_ring[entry].addr = mapping;\r\nbp->tx_ring[entry].ctrl = ctrl;\r\nwmb();\r\nentry = NEXT_TX(entry);\r\nbp->tx_head = entry;\r\nskb_tx_timestamp(skb);\r\nmacb_writel(bp, NCR, macb_readl(bp, NCR) | MACB_BIT(TSTART));\r\nif (TX_BUFFS_AVAIL(bp) < 1)\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&bp->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void macb_free_consistent(struct macb *bp)\r\n{\r\nif (bp->tx_skb) {\r\nkfree(bp->tx_skb);\r\nbp->tx_skb = NULL;\r\n}\r\nif (bp->rx_ring) {\r\ndma_free_coherent(&bp->pdev->dev, RX_RING_BYTES,\r\nbp->rx_ring, bp->rx_ring_dma);\r\nbp->rx_ring = NULL;\r\n}\r\nif (bp->tx_ring) {\r\ndma_free_coherent(&bp->pdev->dev, TX_RING_BYTES,\r\nbp->tx_ring, bp->tx_ring_dma);\r\nbp->tx_ring = NULL;\r\n}\r\nif (bp->rx_buffers) {\r\ndma_free_coherent(&bp->pdev->dev,\r\nRX_RING_SIZE * RX_BUFFER_SIZE,\r\nbp->rx_buffers, bp->rx_buffers_dma);\r\nbp->rx_buffers = NULL;\r\n}\r\n}\r\nstatic int macb_alloc_consistent(struct macb *bp)\r\n{\r\nint size;\r\nsize = TX_RING_SIZE * sizeof(struct ring_info);\r\nbp->tx_skb = kmalloc(size, GFP_KERNEL);\r\nif (!bp->tx_skb)\r\ngoto out_err;\r\nsize = RX_RING_BYTES;\r\nbp->rx_ring = dma_alloc_coherent(&bp->pdev->dev, size,\r\n&bp->rx_ring_dma, GFP_KERNEL);\r\nif (!bp->rx_ring)\r\ngoto out_err;\r\nnetdev_dbg(bp->dev,\r\n"Allocated RX ring of %d bytes at %08lx (mapped %p)\n",\r\nsize, (unsigned long)bp->rx_ring_dma, bp->rx_ring);\r\nsize = TX_RING_BYTES;\r\nbp->tx_ring = dma_alloc_coherent(&bp->pdev->dev, size,\r\n&bp->tx_ring_dma, GFP_KERNEL);\r\nif (!bp->tx_ring)\r\ngoto out_err;\r\nnetdev_dbg(bp->dev,\r\n"Allocated TX ring of %d bytes at %08lx (mapped %p)\n",\r\nsize, (unsigned long)bp->tx_ring_dma, bp->tx_ring);\r\nsize = RX_RING_SIZE * RX_BUFFER_SIZE;\r\nbp->rx_buffers = dma_alloc_coherent(&bp->pdev->dev, size,\r\n&bp->rx_buffers_dma, GFP_KERNEL);\r\nif (!bp->rx_buffers)\r\ngoto out_err;\r\nnetdev_dbg(bp->dev,\r\n"Allocated RX buffers of %d bytes at %08lx (mapped %p)\n",\r\nsize, (unsigned long)bp->rx_buffers_dma, bp->rx_buffers);\r\nreturn 0;\r\nout_err:\r\nmacb_free_consistent(bp);\r\nreturn -ENOMEM;\r\n}\r\nstatic void macb_init_rings(struct macb *bp)\r\n{\r\nint i;\r\ndma_addr_t addr;\r\naddr = bp->rx_buffers_dma;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nbp->rx_ring[i].addr = addr;\r\nbp->rx_ring[i].ctrl = 0;\r\naddr += RX_BUFFER_SIZE;\r\n}\r\nbp->rx_ring[RX_RING_SIZE - 1].addr |= MACB_BIT(RX_WRAP);\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nbp->tx_ring[i].addr = 0;\r\nbp->tx_ring[i].ctrl = MACB_BIT(TX_USED);\r\n}\r\nbp->tx_ring[TX_RING_SIZE - 1].ctrl |= MACB_BIT(TX_WRAP);\r\nbp->rx_tail = bp->tx_head = bp->tx_tail = 0;\r\n}\r\nstatic void macb_reset_hw(struct macb *bp)\r\n{\r\nwmb();\r\nmacb_writel(bp, NCR, 0);\r\nmacb_writel(bp, NCR, MACB_BIT(CLRSTAT));\r\nmacb_writel(bp, TSR, ~0UL);\r\nmacb_writel(bp, RSR, ~0UL);\r\nmacb_writel(bp, IDR, ~0UL);\r\nmacb_readl(bp, ISR);\r\n}\r\nstatic u32 gem_mdc_clk_div(struct macb *bp)\r\n{\r\nu32 config;\r\nunsigned long pclk_hz = clk_get_rate(bp->pclk);\r\nif (pclk_hz <= 20000000)\r\nconfig = GEM_BF(CLK, GEM_CLK_DIV8);\r\nelse if (pclk_hz <= 40000000)\r\nconfig = GEM_BF(CLK, GEM_CLK_DIV16);\r\nelse if (pclk_hz <= 80000000)\r\nconfig = GEM_BF(CLK, GEM_CLK_DIV32);\r\nelse if (pclk_hz <= 120000000)\r\nconfig = GEM_BF(CLK, GEM_CLK_DIV48);\r\nelse if (pclk_hz <= 160000000)\r\nconfig = GEM_BF(CLK, GEM_CLK_DIV64);\r\nelse\r\nconfig = GEM_BF(CLK, GEM_CLK_DIV96);\r\nreturn config;\r\n}\r\nstatic u32 macb_mdc_clk_div(struct macb *bp)\r\n{\r\nu32 config;\r\nunsigned long pclk_hz;\r\nif (macb_is_gem(bp))\r\nreturn gem_mdc_clk_div(bp);\r\npclk_hz = clk_get_rate(bp->pclk);\r\nif (pclk_hz <= 20000000)\r\nconfig = MACB_BF(CLK, MACB_CLK_DIV8);\r\nelse if (pclk_hz <= 40000000)\r\nconfig = MACB_BF(CLK, MACB_CLK_DIV16);\r\nelse if (pclk_hz <= 80000000)\r\nconfig = MACB_BF(CLK, MACB_CLK_DIV32);\r\nelse\r\nconfig = MACB_BF(CLK, MACB_CLK_DIV64);\r\nreturn config;\r\n}\r\nstatic u32 macb_dbw(struct macb *bp)\r\n{\r\nif (!macb_is_gem(bp))\r\nreturn 0;\r\nswitch (GEM_BFEXT(DBWDEF, gem_readl(bp, DCFG1))) {\r\ncase 4:\r\nreturn GEM_BF(DBW, GEM_DBW128);\r\ncase 2:\r\nreturn GEM_BF(DBW, GEM_DBW64);\r\ncase 1:\r\ndefault:\r\nreturn GEM_BF(DBW, GEM_DBW32);\r\n}\r\n}\r\nstatic void macb_configure_dma(struct macb *bp)\r\n{\r\nu32 dmacfg;\r\nif (macb_is_gem(bp)) {\r\ndmacfg = gem_readl(bp, DMACFG) & ~GEM_BF(RXBS, -1L);\r\ndmacfg |= GEM_BF(RXBS, RX_BUFFER_SIZE / 64);\r\ngem_writel(bp, DMACFG, dmacfg);\r\n}\r\n}\r\nstatic void macb_init_hw(struct macb *bp)\r\n{\r\nu32 config;\r\nmacb_reset_hw(bp);\r\n__macb_set_hwaddr(bp);\r\nconfig = macb_mdc_clk_div(bp);\r\nconfig |= MACB_BIT(PAE);\r\nconfig |= MACB_BIT(DRFCS);\r\nconfig |= MACB_BIT(BIG);\r\nif (bp->dev->flags & IFF_PROMISC)\r\nconfig |= MACB_BIT(CAF);\r\nif (!(bp->dev->flags & IFF_BROADCAST))\r\nconfig |= MACB_BIT(NBC);\r\nconfig |= macb_dbw(bp);\r\nmacb_writel(bp, NCFGR, config);\r\nmacb_configure_dma(bp);\r\nmacb_writel(bp, RBQP, bp->rx_ring_dma);\r\nmacb_writel(bp, TBQP, bp->tx_ring_dma);\r\nmacb_writel(bp, NCR, MACB_BIT(RE) | MACB_BIT(TE) | MACB_BIT(MPE));\r\nmacb_writel(bp, IER, (MACB_BIT(RCOMP)\r\n| MACB_BIT(RXUBR)\r\n| MACB_BIT(ISR_TUND)\r\n| MACB_BIT(ISR_RLE)\r\n| MACB_BIT(TXERR)\r\n| MACB_BIT(TCOMP)\r\n| MACB_BIT(ISR_ROVR)\r\n| MACB_BIT(HRESP)));\r\n}\r\nstatic inline int hash_bit_value(int bitnr, __u8 *addr)\r\n{\r\nif (addr[bitnr / 8] & (1 << (bitnr % 8)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int hash_get_index(__u8 *addr)\r\n{\r\nint i, j, bitval;\r\nint hash_index = 0;\r\nfor (j = 0; j < 6; j++) {\r\nfor (i = 0, bitval = 0; i < 8; i++)\r\nbitval ^= hash_bit_value(i*6 + j, addr);\r\nhash_index |= (bitval << j);\r\n}\r\nreturn hash_index;\r\n}\r\nstatic void macb_sethashtable(struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nunsigned long mc_filter[2];\r\nunsigned int bitnr;\r\nstruct macb *bp = netdev_priv(dev);\r\nmc_filter[0] = mc_filter[1] = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nbitnr = hash_get_index(ha->addr);\r\nmc_filter[bitnr >> 5] |= 1 << (bitnr & 31);\r\n}\r\nmacb_or_gem_writel(bp, HRB, mc_filter[0]);\r\nmacb_or_gem_writel(bp, HRT, mc_filter[1]);\r\n}\r\nstatic void macb_set_rx_mode(struct net_device *dev)\r\n{\r\nunsigned long cfg;\r\nstruct macb *bp = netdev_priv(dev);\r\ncfg = macb_readl(bp, NCFGR);\r\nif (dev->flags & IFF_PROMISC)\r\ncfg |= MACB_BIT(CAF);\r\nelse if (dev->flags & (~IFF_PROMISC))\r\ncfg &= ~MACB_BIT(CAF);\r\nif (dev->flags & IFF_ALLMULTI) {\r\nmacb_or_gem_writel(bp, HRB, -1);\r\nmacb_or_gem_writel(bp, HRT, -1);\r\ncfg |= MACB_BIT(NCFGR_MTI);\r\n} else if (!netdev_mc_empty(dev)) {\r\nmacb_sethashtable(dev);\r\ncfg |= MACB_BIT(NCFGR_MTI);\r\n} else if (dev->flags & (~IFF_ALLMULTI)) {\r\nmacb_or_gem_writel(bp, HRB, 0);\r\nmacb_or_gem_writel(bp, HRT, 0);\r\ncfg &= ~MACB_BIT(NCFGR_MTI);\r\n}\r\nmacb_writel(bp, NCFGR, cfg);\r\n}\r\nstatic int macb_open(struct net_device *dev)\r\n{\r\nstruct macb *bp = netdev_priv(dev);\r\nint err;\r\nnetdev_dbg(bp->dev, "open\n");\r\nnetif_carrier_off(dev);\r\nif (!bp->phy_dev)\r\nreturn -EAGAIN;\r\nif (!is_valid_ether_addr(dev->dev_addr))\r\nreturn -EADDRNOTAVAIL;\r\nerr = macb_alloc_consistent(bp);\r\nif (err) {\r\nnetdev_err(dev, "Unable to allocate DMA memory (error %d)\n",\r\nerr);\r\nreturn err;\r\n}\r\nnapi_enable(&bp->napi);\r\nmacb_init_rings(bp);\r\nmacb_init_hw(bp);\r\nphy_start(bp->phy_dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int macb_close(struct net_device *dev)\r\n{\r\nstruct macb *bp = netdev_priv(dev);\r\nunsigned long flags;\r\nnetif_stop_queue(dev);\r\nnapi_disable(&bp->napi);\r\nif (bp->phy_dev)\r\nphy_stop(bp->phy_dev);\r\nspin_lock_irqsave(&bp->lock, flags);\r\nmacb_reset_hw(bp);\r\nnetif_carrier_off(dev);\r\nspin_unlock_irqrestore(&bp->lock, flags);\r\nmacb_free_consistent(bp);\r\nreturn 0;\r\n}\r\nstatic void gem_update_stats(struct macb *bp)\r\n{\r\nu32 __iomem *reg = bp->regs + GEM_OTX;\r\nu32 *p = &bp->hw_stats.gem.tx_octets_31_0;\r\nu32 *end = &bp->hw_stats.gem.rx_udp_checksum_errors + 1;\r\nfor (; p < end; p++, reg++)\r\n*p += __raw_readl(reg);\r\n}\r\nstatic struct net_device_stats *gem_get_stats(struct macb *bp)\r\n{\r\nstruct gem_stats *hwstat = &bp->hw_stats.gem;\r\nstruct net_device_stats *nstat = &bp->stats;\r\ngem_update_stats(bp);\r\nnstat->rx_errors = (hwstat->rx_frame_check_sequence_errors +\r\nhwstat->rx_alignment_errors +\r\nhwstat->rx_resource_errors +\r\nhwstat->rx_overruns +\r\nhwstat->rx_oversize_frames +\r\nhwstat->rx_jabbers +\r\nhwstat->rx_undersized_frames +\r\nhwstat->rx_length_field_frame_errors);\r\nnstat->tx_errors = (hwstat->tx_late_collisions +\r\nhwstat->tx_excessive_collisions +\r\nhwstat->tx_underrun +\r\nhwstat->tx_carrier_sense_errors);\r\nnstat->multicast = hwstat->rx_multicast_frames;\r\nnstat->collisions = (hwstat->tx_single_collision_frames +\r\nhwstat->tx_multiple_collision_frames +\r\nhwstat->tx_excessive_collisions);\r\nnstat->rx_length_errors = (hwstat->rx_oversize_frames +\r\nhwstat->rx_jabbers +\r\nhwstat->rx_undersized_frames +\r\nhwstat->rx_length_field_frame_errors);\r\nnstat->rx_over_errors = hwstat->rx_resource_errors;\r\nnstat->rx_crc_errors = hwstat->rx_frame_check_sequence_errors;\r\nnstat->rx_frame_errors = hwstat->rx_alignment_errors;\r\nnstat->rx_fifo_errors = hwstat->rx_overruns;\r\nnstat->tx_aborted_errors = hwstat->tx_excessive_collisions;\r\nnstat->tx_carrier_errors = hwstat->tx_carrier_sense_errors;\r\nnstat->tx_fifo_errors = hwstat->tx_underrun;\r\nreturn nstat;\r\n}\r\nstatic struct net_device_stats *macb_get_stats(struct net_device *dev)\r\n{\r\nstruct macb *bp = netdev_priv(dev);\r\nstruct net_device_stats *nstat = &bp->stats;\r\nstruct macb_stats *hwstat = &bp->hw_stats.macb;\r\nif (macb_is_gem(bp))\r\nreturn gem_get_stats(bp);\r\nmacb_update_stats(bp);\r\nnstat->rx_errors = (hwstat->rx_fcs_errors +\r\nhwstat->rx_align_errors +\r\nhwstat->rx_resource_errors +\r\nhwstat->rx_overruns +\r\nhwstat->rx_oversize_pkts +\r\nhwstat->rx_jabbers +\r\nhwstat->rx_undersize_pkts +\r\nhwstat->sqe_test_errors +\r\nhwstat->rx_length_mismatch);\r\nnstat->tx_errors = (hwstat->tx_late_cols +\r\nhwstat->tx_excessive_cols +\r\nhwstat->tx_underruns +\r\nhwstat->tx_carrier_errors);\r\nnstat->collisions = (hwstat->tx_single_cols +\r\nhwstat->tx_multiple_cols +\r\nhwstat->tx_excessive_cols);\r\nnstat->rx_length_errors = (hwstat->rx_oversize_pkts +\r\nhwstat->rx_jabbers +\r\nhwstat->rx_undersize_pkts +\r\nhwstat->rx_length_mismatch);\r\nnstat->rx_over_errors = hwstat->rx_resource_errors +\r\nhwstat->rx_overruns;\r\nnstat->rx_crc_errors = hwstat->rx_fcs_errors;\r\nnstat->rx_frame_errors = hwstat->rx_align_errors;\r\nnstat->rx_fifo_errors = hwstat->rx_overruns;\r\nnstat->tx_aborted_errors = hwstat->tx_excessive_cols;\r\nnstat->tx_carrier_errors = hwstat->tx_carrier_errors;\r\nnstat->tx_fifo_errors = hwstat->tx_underruns;\r\nreturn nstat;\r\n}\r\nstatic int macb_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct macb *bp = netdev_priv(dev);\r\nstruct phy_device *phydev = bp->phy_dev;\r\nif (!phydev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_gset(phydev, cmd);\r\n}\r\nstatic int macb_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct macb *bp = netdev_priv(dev);\r\nstruct phy_device *phydev = bp->phy_dev;\r\nif (!phydev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_sset(phydev, cmd);\r\n}\r\nstatic void macb_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct macb *bp = netdev_priv(dev);\r\nstrcpy(info->driver, bp->pdev->dev.driver->name);\r\nstrcpy(info->version, "$Revision: 1.14 $");\r\nstrcpy(info->bus_info, dev_name(&bp->pdev->dev));\r\n}\r\nstatic int macb_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct macb *bp = netdev_priv(dev);\r\nstruct phy_device *phydev = bp->phy_dev;\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nif (!phydev)\r\nreturn -ENODEV;\r\nreturn phy_mii_ioctl(phydev, rq, cmd);\r\n}\r\nstatic int __devinit macb_get_phy_mode_dt(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nif (np)\r\nreturn of_get_phy_mode(np);\r\nreturn -ENODEV;\r\n}\r\nstatic int __devinit macb_get_hwaddr_dt(struct macb *bp)\r\n{\r\nstruct device_node *np = bp->pdev->dev.of_node;\r\nif (np) {\r\nconst char *mac = of_get_mac_address(np);\r\nif (mac) {\r\nmemcpy(bp->dev->dev_addr, mac, ETH_ALEN);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __devinit macb_get_phy_mode_dt(struct platform_device *pdev)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int __devinit macb_get_hwaddr_dt(struct macb *bp)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int __init macb_probe(struct platform_device *pdev)\r\n{\r\nstruct macb_platform_data *pdata;\r\nstruct resource *regs;\r\nstruct net_device *dev;\r\nstruct macb *bp;\r\nstruct phy_device *phydev;\r\nu32 config;\r\nint err = -ENXIO;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs) {\r\ndev_err(&pdev->dev, "no mmio resource defined\n");\r\ngoto err_out;\r\n}\r\nerr = -ENOMEM;\r\ndev = alloc_etherdev(sizeof(*bp));\r\nif (!dev)\r\ngoto err_out;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\ndev->features |= 0;\r\nbp = netdev_priv(dev);\r\nbp->pdev = pdev;\r\nbp->dev = dev;\r\nspin_lock_init(&bp->lock);\r\nbp->pclk = clk_get(&pdev->dev, "pclk");\r\nif (IS_ERR(bp->pclk)) {\r\ndev_err(&pdev->dev, "failed to get macb_clk\n");\r\ngoto err_out_free_dev;\r\n}\r\nclk_enable(bp->pclk);\r\nbp->hclk = clk_get(&pdev->dev, "hclk");\r\nif (IS_ERR(bp->hclk)) {\r\ndev_err(&pdev->dev, "failed to get hclk\n");\r\ngoto err_out_put_pclk;\r\n}\r\nclk_enable(bp->hclk);\r\nbp->regs = ioremap(regs->start, resource_size(regs));\r\nif (!bp->regs) {\r\ndev_err(&pdev->dev, "failed to map registers, aborting.\n");\r\nerr = -ENOMEM;\r\ngoto err_out_disable_clocks;\r\n}\r\ndev->irq = platform_get_irq(pdev, 0);\r\nerr = request_irq(dev->irq, macb_interrupt, 0, dev->name, dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Unable to request IRQ %d (error %d)\n",\r\ndev->irq, err);\r\ngoto err_out_iounmap;\r\n}\r\ndev->netdev_ops = &macb_netdev_ops;\r\nnetif_napi_add(dev, &bp->napi, macb_poll, 64);\r\ndev->ethtool_ops = &macb_ethtool_ops;\r\ndev->base_addr = regs->start;\r\nconfig = macb_mdc_clk_div(bp);\r\nconfig |= macb_dbw(bp);\r\nmacb_writel(bp, NCFGR, config);\r\nerr = macb_get_hwaddr_dt(bp);\r\nif (err < 0)\r\nmacb_get_hwaddr(bp);\r\nerr = macb_get_phy_mode_dt(pdev);\r\nif (err < 0) {\r\npdata = pdev->dev.platform_data;\r\nif (pdata && pdata->is_rmii)\r\nbp->phy_interface = PHY_INTERFACE_MODE_RMII;\r\nelse\r\nbp->phy_interface = PHY_INTERFACE_MODE_MII;\r\n} else {\r\nbp->phy_interface = err;\r\n}\r\nif (bp->phy_interface == PHY_INTERFACE_MODE_RMII)\r\n#if defined(CONFIG_ARCH_AT91)\r\nmacb_or_gem_writel(bp, USRIO, (MACB_BIT(RMII) |\r\nMACB_BIT(CLKEN)));\r\n#else\r\nmacb_or_gem_writel(bp, USRIO, 0);\r\n#endif\r\nelse\r\n#if defined(CONFIG_ARCH_AT91)\r\nmacb_or_gem_writel(bp, USRIO, MACB_BIT(CLKEN));\r\n#else\r\nmacb_or_gem_writel(bp, USRIO, MACB_BIT(MII));\r\n#endif\r\nbp->tx_pending = DEF_TX_RING_PENDING;\r\nerr = register_netdev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot register net device, aborting.\n");\r\ngoto err_out_free_irq;\r\n}\r\nif (macb_mii_init(bp) != 0) {\r\ngoto err_out_unregister_netdev;\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\nnetif_carrier_off(dev);\r\nnetdev_info(dev, "Cadence %s at 0x%08lx irq %d (%pM)\n",\r\nmacb_is_gem(bp) ? "GEM" : "MACB", dev->base_addr,\r\ndev->irq, dev->dev_addr);\r\nphydev = bp->phy_dev;\r\nnetdev_info(dev, "attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",\r\nphydev->drv->name, dev_name(&phydev->dev), phydev->irq);\r\nreturn 0;\r\nerr_out_unregister_netdev:\r\nunregister_netdev(dev);\r\nerr_out_free_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_out_iounmap:\r\niounmap(bp->regs);\r\nerr_out_disable_clocks:\r\nclk_disable(bp->hclk);\r\nclk_put(bp->hclk);\r\nclk_disable(bp->pclk);\r\nerr_out_put_pclk:\r\nclk_put(bp->pclk);\r\nerr_out_free_dev:\r\nfree_netdev(dev);\r\nerr_out:\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn err;\r\n}\r\nstatic int __exit macb_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct macb *bp;\r\ndev = platform_get_drvdata(pdev);\r\nif (dev) {\r\nbp = netdev_priv(dev);\r\nif (bp->phy_dev)\r\nphy_disconnect(bp->phy_dev);\r\nmdiobus_unregister(bp->mii_bus);\r\nkfree(bp->mii_bus->irq);\r\nmdiobus_free(bp->mii_bus);\r\nunregister_netdev(dev);\r\nfree_irq(dev->irq, dev);\r\niounmap(bp->regs);\r\nclk_disable(bp->hclk);\r\nclk_put(bp->hclk);\r\nclk_disable(bp->pclk);\r\nclk_put(bp->pclk);\r\nfree_netdev(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int macb_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct net_device *netdev = platform_get_drvdata(pdev);\r\nstruct macb *bp = netdev_priv(netdev);\r\nnetif_carrier_off(netdev);\r\nnetif_device_detach(netdev);\r\nclk_disable(bp->hclk);\r\nclk_disable(bp->pclk);\r\nreturn 0;\r\n}\r\nstatic int macb_resume(struct platform_device *pdev)\r\n{\r\nstruct net_device *netdev = platform_get_drvdata(pdev);\r\nstruct macb *bp = netdev_priv(netdev);\r\nclk_enable(bp->pclk);\r\nclk_enable(bp->hclk);\r\nnetif_device_attach(netdev);\r\nreturn 0;\r\n}\r\nstatic int __init macb_init(void)\r\n{\r\nreturn platform_driver_probe(&macb_driver, macb_probe);\r\n}\r\nstatic void __exit macb_exit(void)\r\n{\r\nplatform_driver_unregister(&macb_driver);\r\n}
