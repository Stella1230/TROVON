int mmc_app_cmd(struct mmc_host *host, struct mmc_card *card)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nBUG_ON(!host);\r\nBUG_ON(card && (card->host != host));\r\ncmd.opcode = MMC_APP_CMD;\r\nif (card) {\r\ncmd.arg = card->rca << 16;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;\r\n} else {\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_BCR;\r\n}\r\nerr = mmc_wait_for_cmd(host, &cmd, 0);\r\nif (err)\r\nreturn err;\r\nif (!mmc_host_is_spi(host) && !(cmd.resp[0] & R1_APP_CMD))\r\nreturn -EOPNOTSUPP;\r\nreturn 0;\r\n}\r\nint mmc_wait_for_app_cmd(struct mmc_host *host, struct mmc_card *card,\r\nstruct mmc_command *cmd, int retries)\r\n{\r\nstruct mmc_request mrq = {NULL};\r\nint i, err;\r\nBUG_ON(!cmd);\r\nBUG_ON(retries < 0);\r\nerr = -EIO;\r\nfor (i = 0;i <= retries;i++) {\r\nerr = mmc_app_cmd(host, card);\r\nif (err) {\r\nif (mmc_host_is_spi(host)) {\r\nif (cmd->resp[0] & R1_SPI_ILLEGAL_COMMAND)\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nmemset(&mrq, 0, sizeof(struct mmc_request));\r\nmemset(cmd->resp, 0, sizeof(cmd->resp));\r\ncmd->retries = 0;\r\nmrq.cmd = cmd;\r\ncmd->data = NULL;\r\nmmc_wait_for_req(host, &mrq);\r\nerr = cmd->error;\r\nif (!cmd->error)\r\nbreak;\r\nif (mmc_host_is_spi(host)) {\r\nif (cmd->resp[0] & R1_SPI_ILLEGAL_COMMAND)\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nint mmc_app_set_bus_width(struct mmc_card *card, int width)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nBUG_ON(!card);\r\nBUG_ON(!card->host);\r\ncmd.opcode = SD_APP_SET_BUS_WIDTH;\r\ncmd.flags = MMC_RSP_R1 | MMC_CMD_AC;\r\nswitch (width) {\r\ncase MMC_BUS_WIDTH_1:\r\ncmd.arg = SD_BUS_WIDTH_1;\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\ncmd.arg = SD_BUS_WIDTH_4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = mmc_wait_for_app_cmd(card->host, card, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mmc_send_app_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)\r\n{\r\nstruct mmc_command cmd = {0};\r\nint i, err = 0;\r\nBUG_ON(!host);\r\ncmd.opcode = SD_APP_OP_COND;\r\nif (mmc_host_is_spi(host))\r\ncmd.arg = ocr & (1 << 30);\r\nelse\r\ncmd.arg = ocr;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R3 | MMC_CMD_BCR;\r\nfor (i = 100; i; i--) {\r\nerr = mmc_wait_for_app_cmd(host, NULL, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nbreak;\r\nif (ocr == 0)\r\nbreak;\r\nif (mmc_host_is_spi(host)) {\r\nif (!(cmd.resp[0] & R1_SPI_IDLE))\r\nbreak;\r\n} else {\r\nif (cmd.resp[0] & MMC_CARD_BUSY)\r\nbreak;\r\n}\r\nerr = -ETIMEDOUT;\r\nmmc_delay(10);\r\n}\r\nif (rocr && !mmc_host_is_spi(host))\r\n*rocr = cmd.resp[0];\r\nreturn err;\r\n}\r\nint mmc_send_if_cond(struct mmc_host *host, u32 ocr)\r\n{\r\nstruct mmc_command cmd = {0};\r\nint err;\r\nstatic const u8 test_pattern = 0xAA;\r\nu8 result_pattern;\r\ncmd.opcode = SD_SEND_IF_COND;\r\ncmd.arg = ((ocr & 0xFF8000) != 0) << 8 | test_pattern;\r\ncmd.flags = MMC_RSP_SPI_R7 | MMC_RSP_R7 | MMC_CMD_BCR;\r\nerr = mmc_wait_for_cmd(host, &cmd, 0);\r\nif (err)\r\nreturn err;\r\nif (mmc_host_is_spi(host))\r\nresult_pattern = cmd.resp[1] & 0xFF;\r\nelse\r\nresult_pattern = cmd.resp[0] & 0xFF;\r\nif (result_pattern != test_pattern)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint mmc_send_relative_addr(struct mmc_host *host, unsigned int *rca)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {0};\r\nBUG_ON(!host);\r\nBUG_ON(!rca);\r\ncmd.opcode = SD_SEND_RELATIVE_ADDR;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_R6 | MMC_CMD_BCR;\r\nerr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\r\nif (err)\r\nreturn err;\r\n*rca = cmd.resp[0] >> 16;\r\nreturn 0;\r\n}\r\nint mmc_app_send_scr(struct mmc_card *card, u32 *scr)\r\n{\r\nint err;\r\nstruct mmc_request mrq = {NULL};\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_data data = {0};\r\nstruct scatterlist sg;\r\nvoid *data_buf;\r\nBUG_ON(!card);\r\nBUG_ON(!card->host);\r\nBUG_ON(!scr);\r\nerr = mmc_app_cmd(card->host, card);\r\nif (err)\r\nreturn err;\r\ndata_buf = kmalloc(sizeof(card->raw_scr), GFP_KERNEL);\r\nif (data_buf == NULL)\r\nreturn -ENOMEM;\r\nmrq.cmd = &cmd;\r\nmrq.data = &data;\r\ncmd.opcode = SD_APP_SEND_SCR;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;\r\ndata.blksz = 8;\r\ndata.blocks = 1;\r\ndata.flags = MMC_DATA_READ;\r\ndata.sg = &sg;\r\ndata.sg_len = 1;\r\nsg_init_one(&sg, data_buf, 8);\r\nmmc_set_data_timeout(&data, card);\r\nmmc_wait_for_req(card->host, &mrq);\r\nmemcpy(scr, data_buf, sizeof(card->raw_scr));\r\nkfree(data_buf);\r\nif (cmd.error)\r\nreturn cmd.error;\r\nif (data.error)\r\nreturn data.error;\r\nscr[0] = be32_to_cpu(scr[0]);\r\nscr[1] = be32_to_cpu(scr[1]);\r\nreturn 0;\r\n}\r\nint mmc_sd_switch(struct mmc_card *card, int mode, int group,\r\nu8 value, u8 *resp)\r\n{\r\nstruct mmc_request mrq = {NULL};\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_data data = {0};\r\nstruct scatterlist sg;\r\nBUG_ON(!card);\r\nBUG_ON(!card->host);\r\nmode = !!mode;\r\nvalue &= 0xF;\r\nmrq.cmd = &cmd;\r\nmrq.data = &data;\r\ncmd.opcode = SD_SWITCH;\r\ncmd.arg = mode << 31 | 0x00FFFFFF;\r\ncmd.arg &= ~(0xF << (group * 4));\r\ncmd.arg |= value << (group * 4);\r\ncmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;\r\ndata.blksz = 64;\r\ndata.blocks = 1;\r\ndata.flags = MMC_DATA_READ;\r\ndata.sg = &sg;\r\ndata.sg_len = 1;\r\nsg_init_one(&sg, resp, 64);\r\nmmc_set_data_timeout(&data, card);\r\nmmc_wait_for_req(card->host, &mrq);\r\nif (cmd.error)\r\nreturn cmd.error;\r\nif (data.error)\r\nreturn data.error;\r\nreturn 0;\r\n}\r\nint mmc_app_sd_status(struct mmc_card *card, void *ssr)\r\n{\r\nint err;\r\nstruct mmc_request mrq = {NULL};\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_data data = {0};\r\nstruct scatterlist sg;\r\nBUG_ON(!card);\r\nBUG_ON(!card->host);\r\nBUG_ON(!ssr);\r\nerr = mmc_app_cmd(card->host, card);\r\nif (err)\r\nreturn err;\r\nmrq.cmd = &cmd;\r\nmrq.data = &data;\r\ncmd.opcode = SD_APP_SD_STATUS;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_ADTC;\r\ndata.blksz = 64;\r\ndata.blocks = 1;\r\ndata.flags = MMC_DATA_READ;\r\ndata.sg = &sg;\r\ndata.sg_len = 1;\r\nsg_init_one(&sg, ssr, 64);\r\nmmc_set_data_timeout(&data, card);\r\nmmc_wait_for_req(card->host, &mrq);\r\nif (cmd.error)\r\nreturn cmd.error;\r\nif (data.error)\r\nreturn data.error;\r\nreturn 0;\r\n}
