int w1_register_family(struct w1_family *newf)\r\n{\r\nstruct list_head *ent, *n;\r\nstruct w1_family *f;\r\nint ret = 0;\r\nspin_lock(&w1_flock);\r\nlist_for_each_safe(ent, n, &w1_families) {\r\nf = list_entry(ent, struct w1_family, family_entry);\r\nif (f->fid == newf->fid) {\r\nret = -EEXIST;\r\nbreak;\r\n}\r\n}\r\nif (!ret) {\r\natomic_set(&newf->refcnt, 0);\r\nlist_add_tail(&newf->family_entry, &w1_families);\r\n}\r\nspin_unlock(&w1_flock);\r\nw1_reconnect_slaves(newf, 1);\r\nreturn ret;\r\n}\r\nvoid w1_unregister_family(struct w1_family *fent)\r\n{\r\nstruct list_head *ent, *n;\r\nstruct w1_family *f;\r\nspin_lock(&w1_flock);\r\nlist_for_each_safe(ent, n, &w1_families) {\r\nf = list_entry(ent, struct w1_family, family_entry);\r\nif (f->fid == fent->fid) {\r\nlist_del(&fent->family_entry);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&w1_flock);\r\nw1_reconnect_slaves(fent, 0);\r\nwhile (atomic_read(&fent->refcnt)) {\r\nprintk(KERN_INFO "Waiting for family %u to become free: refcnt=%d.\n",\r\nfent->fid, atomic_read(&fent->refcnt));\r\nif (msleep_interruptible(1000))\r\nflush_signals(current);\r\n}\r\n}\r\nstruct w1_family * w1_family_registered(u8 fid)\r\n{\r\nstruct list_head *ent, *n;\r\nstruct w1_family *f = NULL;\r\nint ret = 0;\r\nlist_for_each_safe(ent, n, &w1_families) {\r\nf = list_entry(ent, struct w1_family, family_entry);\r\nif (f->fid == fid) {\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nreturn (ret) ? f : NULL;\r\n}\r\nstatic void __w1_family_put(struct w1_family *f)\r\n{\r\natomic_dec(&f->refcnt);\r\n}\r\nvoid w1_family_put(struct w1_family *f)\r\n{\r\nspin_lock(&w1_flock);\r\n__w1_family_put(f);\r\nspin_unlock(&w1_flock);\r\n}\r\nvoid __w1_family_get(struct w1_family *f)\r\n{\r\nsmp_mb__before_atomic_inc();\r\natomic_inc(&f->refcnt);\r\nsmp_mb__after_atomic_inc();\r\n}
