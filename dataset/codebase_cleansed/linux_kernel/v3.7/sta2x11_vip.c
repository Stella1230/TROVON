static int buf_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct sta2x11_vip *vip = vq->priv_data;\r\n*size = vip->format.width * vip->format.height * 2;\r\nif (0 == *count || MAX_FRAMES < *count)\r\n*count = MAX_FRAMES;\r\nreturn 0;\r\n}\r\nstatic int buf_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct sta2x11_vip *vip = vq->priv_data;\r\nint ret;\r\nvb->size = vip->format.width * vip->format.height * 2;\r\nif ((0 != vb->baddr) && (vb->bsize < vb->size))\r\nreturn -EINVAL;\r\nvb->width = vip->format.width;\r\nvb->height = vip->format.height;\r\nvb->field = field;\r\nif (VIDEOBUF_NEEDS_INIT == vb->state) {\r\nret = videobuf_iolock(vq, vb, NULL);\r\nif (ret)\r\ngoto fail;\r\n}\r\nvb->state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\nvideobuf_dma_contig_free(vq, vb);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\nreturn ret;\r\n}\r\nstatic void buf_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct sta2x11_vip *vip = vq->priv_data;\r\nu32 dma;\r\nvb->state = VIDEOBUF_QUEUED;\r\nif (vip->active) {\r\nlist_add_tail(&vb->queue, &vip->capture);\r\nreturn;\r\n}\r\nvip->started = 1;\r\nvip->tcount = 0;\r\nvip->bcount = 0;\r\nvip->active = vb;\r\nvb->state = VIDEOBUF_ACTIVE;\r\ndma = videobuf_to_dma_contig(vb);\r\nREG_WRITE(vip, DVP_TFO, (0 << 16) | (0));\r\nREG_WRITE(vip, DVP_BFO, (0 << 16) | (0));\r\nswitch (vip->format.field) {\r\ncase V4L2_FIELD_INTERLACED:\r\nREG_WRITE(vip, DVP_TFS,\r\n((vip->format.height / 2 - 1) << 16) |\r\n(2 * vip->format.width - 1));\r\nREG_WRITE(vip, DVP_BFS, ((vip->format.height / 2 - 1) << 16) |\r\n(2 * vip->format.width - 1));\r\nREG_WRITE(vip, DVP_VTP, dma);\r\nREG_WRITE(vip, DVP_VBP, dma + vip->format.width * 2);\r\nREG_WRITE(vip, DVP_VMP, 4 * vip->format.width);\r\nbreak;\r\ncase V4L2_FIELD_TOP:\r\nREG_WRITE(vip, DVP_TFS,\r\n((vip->format.height - 1) << 16) |\r\n(2 * vip->format.width - 1));\r\nREG_WRITE(vip, DVP_BFS, ((0) << 16) |\r\n(2 * vip->format.width - 1));\r\nREG_WRITE(vip, DVP_VTP, dma);\r\nREG_WRITE(vip, DVP_VBP, dma);\r\nREG_WRITE(vip, DVP_VMP, 2 * vip->format.width);\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\nREG_WRITE(vip, DVP_TFS, ((0) << 16) |\r\n(2 * vip->format.width - 1));\r\nREG_WRITE(vip, DVP_BFS,\r\n((vip->format.height) << 16) |\r\n(2 * vip->format.width - 1));\r\nREG_WRITE(vip, DVP_VTP, dma);\r\nREG_WRITE(vip, DVP_VBP, dma);\r\nREG_WRITE(vip, DVP_VMP, 2 * vip->format.width);\r\nbreak;\r\ndefault:\r\npr_warning("VIP: unknown field format\n");\r\nreturn;\r\n}\r\nREG_WRITE(vip, DVP_CTL, DVP_CTL_ENA);\r\n}\r\nstatic void buf_release(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nvideobuf_dma_contig_free(vq, vb);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int vip_open(struct file *file)\r\n{\r\nstruct video_device *dev = video_devdata(file);\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nmutex_lock(&vip->mutex);\r\nvip->users++;\r\nif (vip->users > 1) {\r\nvip->users--;\r\nmutex_unlock(&vip->mutex);\r\nreturn -EBUSY;\r\n}\r\nfile->private_data = dev;\r\nvip->overflow = 0;\r\nvip->started = 0;\r\nvip->closing = 0;\r\nvip->active = NULL;\r\nINIT_LIST_HEAD(&vip->capture);\r\nvip->mem_spare = dma_alloc_coherent(&vip->pdev->dev, 64,\r\n&vip->dma_spare, GFP_KERNEL);\r\nif (!vip->mem_spare) {\r\nvip->users--;\r\nmutex_unlock(&vip->mutex);\r\nreturn -ENOMEM;\r\n}\r\nmutex_unlock(&vip->mutex);\r\nvideobuf_queue_dma_contig_init_cached(&vip->vb_vidq,\r\n&vip_qops,\r\n&vip->pdev->dev,\r\n&vip->slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct videobuf_buffer),\r\nvip, NULL);\r\nREG_READ(vip, DVP_ITS);\r\nREG_WRITE(vip, DVP_HLFLN, DVP_HLFLN_SD);\r\nREG_WRITE(vip, DVP_ITM, DVP_IT_VSB | DVP_IT_VST);\r\nREG_WRITE(vip, DVP_CTL, DVP_CTL_RST);\r\nREG_WRITE(vip, DVP_CTL, 0);\r\nREG_READ(vip, DVP_ITS);\r\nreturn 0;\r\n}\r\nstatic int vip_close(struct file *file)\r\n{\r\nstruct video_device *dev = video_devdata(file);\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nvip->closing = 1;\r\nif (vip->active)\r\nvideobuf_waiton(&vip->vb_vidq, vip->active, 0, 0);\r\nspin_lock_irq(&vip->slock);\r\nREG_WRITE(vip, DVP_ITM, 0);\r\nREG_WRITE(vip, DVP_CTL, DVP_CTL_RST);\r\nREG_WRITE(vip, DVP_CTL, 0);\r\nREG_READ(vip, DVP_ITS);\r\nvip->started = 0;\r\nvip->active = NULL;\r\nspin_unlock_irq(&vip->slock);\r\nvideobuf_stop(&vip->vb_vidq);\r\nvideobuf_mmap_free(&vip->vb_vidq);\r\ndma_free_coherent(&vip->pdev->dev, 64, vip->mem_spare, vip->dma_spare);\r\nfile->private_data = NULL;\r\nmutex_lock(&vip->mutex);\r\nvip->users--;\r\nmutex_unlock(&vip->mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t vip_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct video_device *dev = file->private_data;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nreturn videobuf_read_stream(&vip->vb_vidq, data, count, ppos, 0,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic int vip_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct video_device *dev = file->private_data;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nreturn videobuf_mmap_mapper(&vip->vb_vidq, vma);\r\n}\r\nstatic unsigned int vip_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct video_device *dev = file->private_data;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nreturn videobuf_poll_stream(file, &vip->vb_vidq, wait);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nmemset(cap, 0, sizeof(struct v4l2_capability));\r\nstrcpy(cap->driver, DRV_NAME);\r\nstrcpy(cap->card, DRV_NAME);\r\ncap->version = 0;\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "PCI:%s",\r\npci_name(vip->pdev));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nv4l2_std_id oldstd = vip->std, newstd;\r\nint status;\r\nif (V4L2_STD_ALL == *std) {\r\nv4l2_subdev_call(vip->decoder, core, s_std, *std);\r\nssleep(2);\r\nv4l2_subdev_call(vip->decoder, video, querystd, &newstd);\r\nv4l2_subdev_call(vip->decoder, video, g_input_status, &status);\r\nif (status & V4L2_IN_ST_NO_SIGNAL)\r\nreturn -EIO;\r\n*std = vip->std = newstd;\r\nif (oldstd != *std) {\r\nif (V4L2_STD_525_60 & (*std))\r\nvip->format = formats_60[0];\r\nelse\r\nvip->format = formats_50[0];\r\n}\r\nreturn 0;\r\n}\r\nif (oldstd != *std) {\r\nif (V4L2_STD_525_60 & (*std))\r\nvip->format = formats_60[0];\r\nelse\r\nvip->format = formats_50[0];\r\n}\r\nreturn v4l2_subdev_call(vip->decoder, core, s_std, *std);\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\n*std = vip->std;\r\nreturn 0;\r\n}\r\nstatic int vidioc_querystd(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nreturn v4l2_subdev_call(vip->decoder, video, querystd, std);\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *ctrl)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nreturn v4l2_subdev_call(vip->decoder, core, queryctrl, ctrl);\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nreturn v4l2_subdev_call(vip->decoder, core, g_ctrl, ctrl);\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nreturn v4l2_subdev_call(vip->decoder, core, s_ctrl, ctrl);\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nif (inp->index > 1)\r\nreturn -EINVAL;\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\ninp->std = V4L2_STD_ALL;\r\nsprintf(inp->name, "Camera %u", inp->index);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nint ret;\r\nif (i > 1)\r\nreturn -EINVAL;\r\nret = v4l2_subdev_call(vip->decoder, video, s_routing, i, 0, 0);\r\nif (!ret)\r\nvip->input = i;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\n*i = vip->input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nstrcpy(f->description, "4:2:2, packed, UYVY");\r\nf->pixelformat = V4L2_PIX_FMT_UYVY;\r\nf->flags = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nint interlace_lim;\r\nif (V4L2_PIX_FMT_UYVY != f->fmt.pix.pixelformat)\r\nreturn -EINVAL;\r\nif (V4L2_STD_525_60 & vip->std)\r\ninterlace_lim = 240;\r\nelse\r\ninterlace_lim = 288;\r\nswitch (f->fmt.pix.field) {\r\ncase V4L2_FIELD_ANY:\r\nif (interlace_lim < f->fmt.pix.height)\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nelse\r\nf->fmt.pix.field = V4L2_FIELD_BOTTOM;\r\nbreak;\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nif (interlace_lim < f->fmt.pix.height)\r\nf->fmt.pix.height = interlace_lim;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nf->fmt.pix.height &= ~1;\r\nif (2 * interlace_lim < f->fmt.pix.height)\r\nf->fmt.pix.height = 2 * interlace_lim;\r\nif (200 > f->fmt.pix.height)\r\nf->fmt.pix.height = 200;\r\nf->fmt.pix.width = 720;\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\nf->fmt.pix.sizeimage = f->fmt.pix.width * 2 * f->fmt.pix.height;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nint ret;\r\nret = vidioc_try_fmt_vid_cap(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(&vip->format, &f->fmt.pix, sizeof(struct v4l2_pix_format));\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nmemcpy(&f->fmt.pix, &vip->format, sizeof(struct v4l2_pix_format));\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nreturn videobuf_reqbufs(&vip->vb_vidq, p);\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nreturn videobuf_querybuf(&vip->vb_vidq, p);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nreturn videobuf_qbuf(&vip->vb_vidq, p);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nreturn videobuf_dqbuf(&vip->vb_vidq, p, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nreturn videobuf_streamon(&vip->vb_vidq);\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct video_device *dev = priv;\r\nstruct sta2x11_vip *vip = video_get_drvdata(dev);\r\nreturn videobuf_streamoff(&vip->vb_vidq);\r\n}\r\nstatic irqreturn_t vip_irq(int irq, struct sta2x11_vip *vip)\r\n{\r\nu32 status, dma;\r\nunsigned long flags;\r\nstruct videobuf_buffer *vb;\r\nstatus = REG_READ(vip, DVP_ITS);\r\nif (!status) {\r\npr_debug("VIP: irq ignored\n");\r\nreturn IRQ_NONE;\r\n}\r\nif (!vip->started)\r\nreturn IRQ_HANDLED;\r\nif (status & DVP_IT_VSB)\r\nvip->bcount++;\r\nif (status & DVP_IT_VST)\r\nvip->tcount++;\r\nif ((DVP_IT_VSB | DVP_IT_VST) == (status & (DVP_IT_VST | DVP_IT_VSB))) {\r\npr_info("VIP: both irqs\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (status & DVP_IT_FIFO) {\r\nif (5 > vip->overflow++)\r\npr_info("VIP: fifo overflow\n");\r\n}\r\nif (2 > vip->tcount)\r\nreturn IRQ_HANDLED;\r\nif (status & DVP_IT_VSB)\r\nreturn IRQ_HANDLED;\r\nspin_lock_irqsave(&vip->slock, flags);\r\nREG_WRITE(vip, DVP_CTL, REG_READ(vip, DVP_CTL) & ~DVP_CTL_ENA);\r\nif (vip->active) {\r\ndo_gettimeofday(&vip->active->ts);\r\nvip->active->field_count++;\r\nvip->active->state = VIDEOBUF_DONE;\r\nwake_up(&vip->active->done);\r\nvip->active = NULL;\r\n}\r\nif (!vip->closing) {\r\nif (list_empty(&vip->capture))\r\ngoto done;\r\nvb = list_first_entry(&vip->capture, struct videobuf_buffer,\r\nqueue);\r\nif (NULL == vb) {\r\npr_info("VIP: no buffer\n");\r\ngoto done;\r\n}\r\nvb->state = VIDEOBUF_ACTIVE;\r\nlist_del(&vb->queue);\r\nvip->active = vb;\r\ndma = videobuf_to_dma_contig(vb);\r\nswitch (vip->format.field) {\r\ncase V4L2_FIELD_INTERLACED:\r\nREG_WRITE(vip, DVP_VTP, dma);\r\nREG_WRITE(vip, DVP_VBP, dma + vip->format.width * 2);\r\nbreak;\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nREG_WRITE(vip, DVP_VTP, dma);\r\nREG_WRITE(vip, DVP_VBP, dma);\r\nbreak;\r\ndefault:\r\npr_warning("VIP: unknown field format\n");\r\ngoto done;\r\nbreak;\r\n}\r\nREG_WRITE(vip, DVP_CTL, REG_READ(vip, DVP_CTL) | DVP_CTL_ENA);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&vip->slock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vip_gpio_reserve(struct device *dev, int pin, int dir,\r\nconst char *name)\r\n{\r\nint ret;\r\nif (pin == -1)\r\nreturn 0;\r\nret = gpio_request(pin, name);\r\nif (ret) {\r\ndev_err(dev, "Failed to allocate pin %d (%s)\n", pin, name);\r\nreturn ret;\r\n}\r\nret = gpio_direction_output(pin, dir);\r\nif (ret) {\r\ndev_err(dev, "Failed to set direction for pin %d (%s)\n",\r\npin, name);\r\ngpio_free(pin);\r\nreturn ret;\r\n}\r\nret = gpio_export(pin, false);\r\nif (ret) {\r\ndev_err(dev, "Failed to export pin %d (%s)\n", pin, name);\r\ngpio_free(pin);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vip_gpio_release(struct device *dev, int pin, const char *name)\r\n{\r\nif (pin != -1) {\r\ndev_dbg(dev, "releasing pin %d (%s)\n", pin, name);\r\ngpio_unexport(pin);\r\ngpio_free(pin);\r\n}\r\n}\r\nstatic int __devinit sta2x11_vip_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint ret;\r\nstruct sta2x11_vip *vip;\r\nstruct vip_config *config;\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\nconfig = dev_get_platdata(&pdev->dev);\r\nif (!config) {\r\ndev_info(&pdev->dev, "VIP slot disabled\n");\r\nret = -EINVAL;\r\ngoto disable;\r\n}\r\nret = vip_gpio_reserve(&pdev->dev, config->pwr_pin, 0,\r\nconfig->pwr_name);\r\nif (ret)\r\ngoto disable;\r\nif (config->reset_pin >= 0) {\r\nret = vip_gpio_reserve(&pdev->dev, config->reset_pin, 0,\r\nconfig->reset_name);\r\nif (ret) {\r\nvip_gpio_release(&pdev->dev, config->pwr_pin,\r\nconfig->pwr_name);\r\ngoto disable;\r\n}\r\n}\r\nif (config->pwr_pin != -1) {\r\nusleep_range(5000, 25000);\r\nret = gpio_direction_output(config->pwr_pin, 1);\r\n}\r\nif (config->reset_pin != -1) {\r\nusleep_range(5000, 25000);\r\nret = gpio_direction_output(config->reset_pin, 1);\r\n}\r\nusleep_range(5000, 25000);\r\nvip = kzalloc(sizeof(struct sta2x11_vip), GFP_KERNEL);\r\nif (!vip) {\r\nret = -ENOMEM;\r\ngoto release_gpios;\r\n}\r\nvip->pdev = pdev;\r\nvip->std = V4L2_STD_PAL;\r\nvip->format = formats_50[0];\r\nvip->config = config;\r\nif (v4l2_device_register(&pdev->dev, &vip->v4l2_dev))\r\ngoto free_mem;\r\ndev_dbg(&pdev->dev, "BAR #0 at 0x%lx 0x%lx irq %d\n",\r\n(unsigned long)pci_resource_start(pdev, 0),\r\n(unsigned long)pci_resource_len(pdev, 0), pdev->irq);\r\npci_set_master(pdev);\r\nret = pci_request_regions(pdev, DRV_NAME);\r\nif (ret)\r\ngoto unreg;\r\nvip->iomem = pci_iomap(pdev, 0, 0x100);\r\nif (!vip->iomem) {\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\npci_enable_msi(pdev);\r\nINIT_LIST_HEAD(&vip->capture);\r\nspin_lock_init(&vip->slock);\r\nmutex_init(&vip->mutex);\r\nvip->started = 0;\r\nvip->disabled = 0;\r\nret = request_irq(pdev->irq,\r\n(irq_handler_t) vip_irq,\r\nIRQF_SHARED, DRV_NAME, vip);\r\nif (ret) {\r\ndev_err(&pdev->dev, "request_irq failed\n");\r\nret = -ENODEV;\r\ngoto unmap;\r\n}\r\nvip->video_dev = video_device_alloc();\r\nif (!vip->video_dev) {\r\nret = -ENOMEM;\r\ngoto release_irq;\r\n}\r\n*(vip->video_dev) = video_dev_template;\r\nvideo_set_drvdata(vip->video_dev, vip);\r\nret = video_register_device(vip->video_dev, VFL_TYPE_GRABBER, -1);\r\nif (ret)\r\ngoto vrelease;\r\nvip->adapter = i2c_get_adapter(vip->config->i2c_id);\r\nif (!vip->adapter) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "no I2C adapter found\n");\r\ngoto vunreg;\r\n}\r\nvip->decoder = v4l2_i2c_new_subdev(&vip->v4l2_dev, vip->adapter,\r\n"adv7180", vip->config->i2c_addr,\r\nNULL);\r\nif (!vip->decoder) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "no decoder found\n");\r\ngoto vunreg;\r\n}\r\ni2c_put_adapter(vip->adapter);\r\nv4l2_subdev_call(vip->decoder, core, init, 0);\r\npr_info("STA2X11 Video Input Port (VIP) loaded\n");\r\nreturn 0;\r\nvunreg:\r\nvideo_set_drvdata(vip->video_dev, NULL);\r\nvrelease:\r\nif (video_is_registered(vip->video_dev))\r\nvideo_unregister_device(vip->video_dev);\r\nelse\r\nvideo_device_release(vip->video_dev);\r\nrelease_irq:\r\nfree_irq(pdev->irq, vip);\r\npci_disable_msi(pdev);\r\nunmap:\r\npci_iounmap(pdev, vip->iomem);\r\nmutex_destroy(&vip->mutex);\r\nrelease:\r\npci_release_regions(pdev);\r\nunreg:\r\nv4l2_device_unregister(&vip->v4l2_dev);\r\nfree_mem:\r\nkfree(vip);\r\nrelease_gpios:\r\nvip_gpio_release(&pdev->dev, config->reset_pin, config->reset_name);\r\nvip_gpio_release(&pdev->dev, config->pwr_pin, config->pwr_name);\r\ndisable:\r\nreturn ret;\r\n}\r\nstatic void __devexit sta2x11_vip_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\r\nstruct sta2x11_vip *vip =\r\ncontainer_of(v4l2_dev, struct sta2x11_vip, v4l2_dev);\r\nvideo_set_drvdata(vip->video_dev, NULL);\r\nvideo_unregister_device(vip->video_dev);\r\nfree_irq(pdev->irq, vip);\r\npci_disable_msi(pdev);\r\npci_iounmap(pdev, vip->iomem);\r\npci_release_regions(pdev);\r\nv4l2_device_unregister(&vip->v4l2_dev);\r\nmutex_destroy(&vip->mutex);\r\nvip_gpio_release(&pdev->dev, vip->config->pwr_pin,\r\nvip->config->pwr_name);\r\nvip_gpio_release(&pdev->dev, vip->config->reset_pin,\r\nvip->config->reset_name);\r\nkfree(vip);\r\n}\r\nstatic int sta2x11_vip_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\r\nstruct sta2x11_vip *vip =\r\ncontainer_of(v4l2_dev, struct sta2x11_vip, v4l2_dev);\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&vip->slock, flags);\r\nvip->register_save_area[0] = REG_READ(vip, DVP_CTL);\r\nREG_WRITE(vip, DVP_CTL, vip->register_save_area[0] & DVP_CTL_DIS);\r\nvip->register_save_area[SAVE_COUNT] = REG_READ(vip, DVP_ITM);\r\nREG_WRITE(vip, DVP_ITM, 0);\r\nfor (i = 1; i < SAVE_COUNT; i++)\r\nvip->register_save_area[i] = REG_READ(vip, 4 * i);\r\nfor (i = 0; i < AUX_COUNT; i++)\r\nvip->register_save_area[SAVE_COUNT + IRQ_COUNT + i] =\r\nREG_READ(vip, registers_to_save[i]);\r\nspin_unlock_irqrestore(&vip->slock, flags);\r\npci_save_state(pdev);\r\nif (pci_set_power_state(pdev, pci_choose_state(pdev, state))) {\r\nvip->disabled = 1;\r\n}\r\npr_info("VIP: suspend\n");\r\nreturn 0;\r\n}\r\nstatic int sta2x11_vip_resume(struct pci_dev *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\r\nstruct sta2x11_vip *vip =\r\ncontainer_of(v4l2_dev, struct sta2x11_vip, v4l2_dev);\r\nunsigned long flags;\r\nint ret, i;\r\npr_info("VIP: resume\n");\r\nif (vip->disabled) {\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\npr_warning("VIP: Can't enable device.\n");\r\nreturn ret;\r\n}\r\nvip->disabled = 0;\r\n}\r\nret = pci_set_power_state(pdev, PCI_D0);\r\nif (ret) {\r\npr_warning("VIP: Can't enable device.\n");\r\nvip->disabled = 1;\r\nreturn ret;\r\n}\r\npci_restore_state(pdev);\r\nspin_lock_irqsave(&vip->slock, flags);\r\nfor (i = 1; i < SAVE_COUNT; i++)\r\nREG_WRITE(vip, 4 * i, vip->register_save_area[i]);\r\nfor (i = 0; i < AUX_COUNT; i++)\r\nREG_WRITE(vip, registers_to_save[i],\r\nvip->register_save_area[SAVE_COUNT + IRQ_COUNT + i]);\r\nREG_WRITE(vip, DVP_CTL, vip->register_save_area[0]);\r\nREG_WRITE(vip, DVP_ITM, vip->register_save_area[SAVE_COUNT]);\r\nspin_unlock_irqrestore(&vip->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init sta2x11_vip_init_module(void)\r\n{\r\nreturn pci_register_driver(&sta2x11_vip_driver);\r\n}\r\nstatic void __exit sta2x11_vip_exit_module(void)\r\n{\r\npci_unregister_driver(&sta2x11_vip_driver);\r\n}
