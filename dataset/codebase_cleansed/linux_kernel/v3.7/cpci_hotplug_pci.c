u8 cpci_get_attention_status(struct slot* slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn 0;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn 0;\r\nreturn hs_csr & 0x0008 ? 1 : 0;\r\n}\r\nint cpci_set_attention_status(struct slot* slot, int status)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn 0;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn 0;\r\nif (status)\r\nhs_csr |= HS_CSR_LOO;\r\nelse\r\nhs_csr &= ~HS_CSR_LOO;\r\nif (pci_bus_write_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\nhs_csr))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nu16 cpci_get_hs_csr(struct slot* slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn 0xFFFF;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn 0xFFFF;\r\nreturn hs_csr;\r\n}\r\nint cpci_check_and_clear_ins(struct slot* slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nint ins = 0;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn 0;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn 0;\r\nif (hs_csr & HS_CSR_INS) {\r\nif (pci_bus_write_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\nhs_csr))\r\nins = 0;\r\nelse\r\nins = 1;\r\n}\r\nreturn ins;\r\n}\r\nint cpci_check_ext(struct slot* slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nint ext = 0;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn 0;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn 0;\r\nif (hs_csr & HS_CSR_EXT)\r\next = 1;\r\nreturn ext;\r\n}\r\nint cpci_clear_ext(struct slot* slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn -ENODEV;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn -ENODEV;\r\nif (hs_csr & HS_CSR_EXT) {\r\nif (pci_bus_write_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\nhs_csr))\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nint cpci_led_on(struct slot* slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn -ENODEV;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn -ENODEV;\r\nif ((hs_csr & HS_CSR_LOO) != HS_CSR_LOO) {\r\nhs_csr |= HS_CSR_LOO;\r\nif (pci_bus_write_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\nhs_csr)) {\r\nerr("Could not set LOO for slot %s",\r\nhotplug_slot_name(slot->hotplug_slot));\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cpci_led_off(struct slot* slot)\r\n{\r\nint hs_cap;\r\nu16 hs_csr;\r\nhs_cap = pci_bus_find_capability(slot->bus,\r\nslot->devfn,\r\nPCI_CAP_ID_CHSWP);\r\nif (!hs_cap)\r\nreturn -ENODEV;\r\nif (pci_bus_read_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\n&hs_csr))\r\nreturn -ENODEV;\r\nif (hs_csr & HS_CSR_LOO) {\r\nhs_csr &= ~HS_CSR_LOO;\r\nif (pci_bus_write_config_word(slot->bus,\r\nslot->devfn,\r\nhs_cap + 2,\r\nhs_csr)) {\r\nerr("Could not clear LOO for slot %s",\r\nhotplug_slot_name(slot->hotplug_slot));\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint __ref cpci_configure_slot(struct slot *slot)\r\n{\r\nstruct pci_bus *parent;\r\nint fn;\r\ndbg("%s - enter", __func__);\r\nif (slot->dev == NULL) {\r\ndbg("pci_dev null, finding %02x:%02x:%x",\r\nslot->bus->number, PCI_SLOT(slot->devfn), PCI_FUNC(slot->devfn));\r\nslot->dev = pci_get_slot(slot->bus, slot->devfn);\r\n}\r\nif (slot->dev == NULL) {\r\nint n;\r\ndbg("pci_dev still null");\r\nn = pci_scan_slot(slot->bus, slot->devfn);\r\ndbg("%s: pci_scan_slot returned %d", __func__, n);\r\nslot->dev = pci_get_slot(slot->bus, slot->devfn);\r\nif (slot->dev == NULL) {\r\nerr("Could not find PCI device for slot %02x", slot->number);\r\nreturn -ENODEV;\r\n}\r\n}\r\nparent = slot->dev->bus;\r\nfor (fn = 0; fn < 8; fn++) {\r\nstruct pci_dev *dev;\r\ndev = pci_get_slot(parent,\r\nPCI_DEVFN(PCI_SLOT(slot->devfn), fn));\r\nif (!dev)\r\ncontinue;\r\nif ((dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) ||\r\n(dev->hdr_type == PCI_HEADER_TYPE_CARDBUS))\r\npci_hp_add_bridge(dev);\r\npci_dev_put(dev);\r\n}\r\npci_assign_unassigned_bridge_resources(parent->self);\r\npci_bus_add_devices(parent);\r\ndbg("%s - exit", __func__);\r\nreturn 0;\r\n}\r\nint cpci_unconfigure_slot(struct slot* slot)\r\n{\r\nint i;\r\nstruct pci_dev *dev;\r\ndbg("%s - enter", __func__);\r\nif (!slot->dev) {\r\nerr("No device for slot %02x\n", slot->number);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ndev = pci_get_slot(slot->bus,\r\nPCI_DEVFN(PCI_SLOT(slot->devfn), i));\r\nif (dev) {\r\npci_stop_and_remove_bus_device(dev);\r\npci_dev_put(dev);\r\n}\r\n}\r\npci_dev_put(slot->dev);\r\nslot->dev = NULL;\r\ndbg("%s - exit", __func__);\r\nreturn 0;\r\n}
