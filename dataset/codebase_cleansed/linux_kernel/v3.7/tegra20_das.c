static inline void tegra20_das_write(u32 reg, u32 val)\r\n{\r\nregmap_write(das->regmap, reg, val);\r\n}\r\nstatic inline u32 tegra20_das_read(u32 reg)\r\n{\r\nu32 val;\r\nregmap_read(das->regmap, reg, &val);\r\nreturn val;\r\n}\r\nint tegra20_das_connect_dap_to_dac(int dap, int dac)\r\n{\r\nu32 addr;\r\nu32 reg;\r\nif (!das)\r\nreturn -ENODEV;\r\naddr = TEGRA20_DAS_DAP_CTRL_SEL +\r\n(dap * TEGRA20_DAS_DAP_CTRL_SEL_STRIDE);\r\nreg = dac << TEGRA20_DAS_DAP_CTRL_SEL_DAP_CTRL_SEL_P;\r\ntegra20_das_write(addr, reg);\r\nreturn 0;\r\n}\r\nint tegra20_das_connect_dap_to_dap(int dap, int otherdap, int master,\r\nint sdata1rx, int sdata2rx)\r\n{\r\nu32 addr;\r\nu32 reg;\r\nif (!das)\r\nreturn -ENODEV;\r\naddr = TEGRA20_DAS_DAP_CTRL_SEL +\r\n(dap * TEGRA20_DAS_DAP_CTRL_SEL_STRIDE);\r\nreg = otherdap << TEGRA20_DAS_DAP_CTRL_SEL_DAP_CTRL_SEL_P |\r\n!!sdata2rx << TEGRA20_DAS_DAP_CTRL_SEL_DAP_SDATA2_TX_RX_P |\r\n!!sdata1rx << TEGRA20_DAS_DAP_CTRL_SEL_DAP_SDATA1_TX_RX_P |\r\n!!master << TEGRA20_DAS_DAP_CTRL_SEL_DAP_MS_SEL_P;\r\ntegra20_das_write(addr, reg);\r\nreturn 0;\r\n}\r\nint tegra20_das_connect_dac_to_dap(int dac, int dap)\r\n{\r\nu32 addr;\r\nu32 reg;\r\nif (!das)\r\nreturn -ENODEV;\r\naddr = TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL +\r\n(dac * TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL_STRIDE);\r\nreg = dap << TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_CLK_SEL_P |\r\ndap << TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_SDATA1_SEL_P |\r\ndap << TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL_DAC_SDATA2_SEL_P;\r\ntegra20_das_write(addr, reg);\r\nreturn 0;\r\n}\r\nstatic bool tegra20_das_wr_rd_reg(struct device *dev, unsigned int reg)\r\n{\r\nif ((reg >= TEGRA20_DAS_DAP_CTRL_SEL) &&\r\n(reg <= LAST_REG(DAP_CTRL_SEL)))\r\nreturn true;\r\nif ((reg >= TEGRA20_DAS_DAC_INPUT_DATA_CLK_SEL) &&\r\n(reg <= LAST_REG(DAC_INPUT_DATA_CLK_SEL)))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int __devinit tegra20_das_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res, *region;\r\nvoid __iomem *regs;\r\nint ret = 0;\r\nif (das)\r\nreturn -ENODEV;\r\ndas = devm_kzalloc(&pdev->dev, sizeof(struct tegra20_das), GFP_KERNEL);\r\nif (!das) {\r\ndev_err(&pdev->dev, "Can't allocate tegra20_das\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndas->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "No memory resource\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nregion = devm_request_mem_region(&pdev->dev, res->start,\r\nresource_size(res), pdev->name);\r\nif (!region) {\r\ndev_err(&pdev->dev, "Memory region already claimed\n");\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nregs = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!regs) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndas->regmap = devm_regmap_init_mmio(&pdev->dev, regs,\r\n&tegra20_das_regmap_config);\r\nif (IS_ERR(das->regmap)) {\r\ndev_err(&pdev->dev, "regmap init failed\n");\r\nret = PTR_ERR(das->regmap);\r\ngoto err;\r\n}\r\nret = tegra20_das_connect_dap_to_dac(TEGRA20_DAS_DAP_ID_1,\r\nTEGRA20_DAS_DAP_SEL_DAC1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't set up DAS DAP connection\n");\r\ngoto err;\r\n}\r\nret = tegra20_das_connect_dac_to_dap(TEGRA20_DAS_DAC_ID_1,\r\nTEGRA20_DAS_DAC_SEL_DAP1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Can't set up DAS DAC connection\n");\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, das);\r\nreturn 0;\r\nerr:\r\ndas = NULL;\r\nreturn ret;\r\n}\r\nstatic int __devexit tegra20_das_remove(struct platform_device *pdev)\r\n{\r\nif (!das)\r\nreturn -ENODEV;\r\ndas = NULL;\r\nreturn 0;\r\n}
