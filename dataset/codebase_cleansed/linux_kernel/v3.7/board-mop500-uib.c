static int __init mop500_uib_setup(char *str)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mop500_uibs); i++) {\r\nstruct uib *uib = &mop500_uibs[i];\r\nif (!strcmp(str, uib->option)) {\r\nmop500_uib = uib;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(mop500_uibs))\r\npr_err("invalid uib= option (%s)\n", str);\r\nreturn 1;\r\n}\r\nvoid mop500_uib_i2c_add(int busnum, struct i2c_board_info *info,\r\nunsigned n)\r\n{\r\nstruct i2c_adapter *adap;\r\nstruct i2c_client *client;\r\nint i;\r\nadap = i2c_get_adapter(busnum);\r\nif (!adap) {\r\npr_err("failed to get adapter i2c%d\n", busnum);\r\nreturn;\r\n}\r\nfor (i = 0; i < n; i++) {\r\nclient = i2c_new_device(adap, &info[i]);\r\nif (!client)\r\npr_err("failed to register %s to i2c%d\n",\r\ninfo[i].type, busnum);\r\n}\r\ni2c_put_adapter(adap);\r\n}\r\nstatic void __init __mop500_uib_init(struct uib *uib, const char *why)\r\n{\r\npr_info("%s (%s)\n", uib->name, why);\r\nuib->init();\r\n}\r\nint __init mop500_uib_init(void)\r\n{\r\nstruct uib *uib = mop500_uib;\r\nstruct i2c_adapter *i2c0;\r\nint ret;\r\nif (!cpu_is_u8500_family())\r\nreturn -ENODEV;\r\nif (uib) {\r\n__mop500_uib_init(uib, "from uib= boot argument");\r\nreturn 0;\r\n}\r\ni2c0 = i2c_get_adapter(0);\r\nif (!i2c0) {\r\n__mop500_uib_init(&mop500_uibs[STUIB],\r\n"fallback, could not get i2c0");\r\nreturn -ENODEV;\r\n}\r\nret = i2c_smbus_xfer(i2c0, 0x44, 0, I2C_SMBUS_WRITE, 0,\r\nI2C_SMBUS_QUICK, NULL);\r\ni2c_put_adapter(i2c0);\r\nif (ret == 0)\r\nuib = &mop500_uibs[U8500UIB];\r\nelse\r\nuib = &mop500_uibs[STUIB];\r\n__mop500_uib_init(uib, "detected");\r\nreturn 0;\r\n}
