u32 os_info_csum(struct os_info *os_info)\r\n{\r\nint size = sizeof(*os_info) - offsetof(struct os_info, version_major);\r\nreturn csum_partial(&os_info->version_major, size, 0);\r\n}\r\nvoid os_info_crashkernel_add(unsigned long base, unsigned long size)\r\n{\r\nos_info.crashkernel_addr = (u64)(unsigned long)base;\r\nos_info.crashkernel_size = (u64)(unsigned long)size;\r\nos_info.csum = os_info_csum(&os_info);\r\n}\r\nvoid os_info_entry_add(int nr, void *ptr, u64 size)\r\n{\r\nos_info.entry[nr].addr = (u64)(unsigned long)ptr;\r\nos_info.entry[nr].size = size;\r\nos_info.entry[nr].csum = csum_partial(ptr, size, 0);\r\nos_info.csum = os_info_csum(&os_info);\r\n}\r\nvoid __init os_info_init(void)\r\n{\r\nvoid *ptr = &os_info;\r\nos_info.version_major = OS_INFO_VERSION_MAJOR;\r\nos_info.version_minor = OS_INFO_VERSION_MINOR;\r\nos_info.magic = OS_INFO_MAGIC;\r\nos_info.csum = os_info_csum(&os_info);\r\nmem_assign_absolute(S390_lowcore.os_info, (unsigned long) ptr);\r\n}\r\nstatic void os_info_old_alloc(int nr, int align)\r\n{\r\nunsigned long addr, size = 0;\r\nchar *buf, *buf_align, *msg;\r\nu32 csum;\r\naddr = os_info_old->entry[nr].addr;\r\nif (!addr) {\r\nmsg = "not available";\r\ngoto fail;\r\n}\r\nsize = os_info_old->entry[nr].size;\r\nbuf = kmalloc(size + align - 1, GFP_KERNEL);\r\nif (!buf) {\r\nmsg = "alloc failed";\r\ngoto fail;\r\n}\r\nbuf_align = PTR_ALIGN(buf, align);\r\nif (copy_from_oldmem(buf_align, (void *) addr, size)) {\r\nmsg = "copy failed";\r\ngoto fail_free;\r\n}\r\ncsum = csum_partial(buf_align, size, 0);\r\nif (csum != os_info_old->entry[nr].csum) {\r\nmsg = "checksum failed";\r\ngoto fail_free;\r\n}\r\nos_info_old->entry[nr].addr = (u64)(unsigned long)buf_align;\r\nmsg = "copied";\r\ngoto out;\r\nfail_free:\r\nkfree(buf);\r\nfail:\r\nos_info_old->entry[nr].addr = 0;\r\nout:\r\npr_info("entry %i: %s (addr=0x%lx size=%lu)\n",\r\nnr, msg, addr, size);\r\n}\r\nstatic void os_info_old_init(void)\r\n{\r\nstatic int os_info_init;\r\nunsigned long addr;\r\nif (os_info_init)\r\nreturn;\r\nif (!OLDMEM_BASE)\r\ngoto fail;\r\nif (copy_from_oldmem(&addr, &S390_lowcore.os_info, sizeof(addr)))\r\ngoto fail;\r\nif (addr == 0 || addr % PAGE_SIZE)\r\ngoto fail;\r\nos_info_old = kzalloc(sizeof(*os_info_old), GFP_KERNEL);\r\nif (!os_info_old)\r\ngoto fail;\r\nif (copy_from_oldmem(os_info_old, (void *) addr, sizeof(*os_info_old)))\r\ngoto fail_free;\r\nif (os_info_old->magic != OS_INFO_MAGIC)\r\ngoto fail_free;\r\nif (os_info_old->csum != os_info_csum(os_info_old))\r\ngoto fail_free;\r\nif (os_info_old->version_major > OS_INFO_VERSION_MAJOR)\r\ngoto fail_free;\r\nos_info_old_alloc(OS_INFO_VMCOREINFO, 1);\r\nos_info_old_alloc(OS_INFO_REIPL_BLOCK, 1);\r\npr_info("crashkernel: addr=0x%lx size=%lu\n",\r\n(unsigned long) os_info_old->crashkernel_addr,\r\n(unsigned long) os_info_old->crashkernel_size);\r\nos_info_init = 1;\r\nreturn;\r\nfail_free:\r\nkfree(os_info_old);\r\nfail:\r\nos_info_init = 1;\r\nos_info_old = NULL;\r\n}\r\nvoid *os_info_old_entry(int nr, unsigned long *size)\r\n{\r\nos_info_old_init();\r\nif (!os_info_old)\r\nreturn NULL;\r\nif (!os_info_old->entry[nr].addr)\r\nreturn NULL;\r\n*size = (unsigned long) os_info_old->entry[nr].size;\r\nreturn (void *)(unsigned long)os_info_old->entry[nr].addr;\r\n}
