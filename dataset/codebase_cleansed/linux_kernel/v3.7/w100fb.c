static ssize_t flip_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct w100fb_par *par=info->par;\r\nreturn sprintf(buf, "%d\n",par->flip);\r\n}\r\nstatic ssize_t flip_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned int flip;\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct w100fb_par *par=info->par;\r\nflip = simple_strtoul(buf, NULL, 10);\r\nif (flip > 0)\r\npar->flip = 1;\r\nelse\r\npar->flip = 0;\r\nw100_update_disable();\r\nw100_set_dispregs(par);\r\nw100_update_enable();\r\ncalc_hsync(par);\r\nreturn count;\r\n}\r\nstatic ssize_t w100fb_reg_read(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long regs, param;\r\nregs = simple_strtoul(buf, NULL, 16);\r\nparam = readl(remapped_regs + regs);\r\nprintk("Read Register 0x%08lX: 0x%08lX\n", regs, param);\r\nreturn count;\r\n}\r\nstatic ssize_t w100fb_reg_write(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nunsigned long regs, param;\r\nsscanf(buf, "%lx %lx", &regs, &param);\r\nif (regs <= 0x2000) {\r\nprintk("Write Register 0x%08lX: 0x%08lX\n", regs, param);\r\nwritel(param, remapped_regs + regs);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t fastpllclk_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct w100fb_par *par=info->par;\r\nreturn sprintf(buf, "%d\n",par->fastpll_mode);\r\n}\r\nstatic ssize_t fastpllclk_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct w100fb_par *par=info->par;\r\nif (simple_strtoul(buf, NULL, 10) > 0) {\r\npar->fastpll_mode=1;\r\nprintk("w100fb: Using fast system clock (if possible)\n");\r\n} else {\r\npar->fastpll_mode=0;\r\nprintk("w100fb: Using normal system clock\n");\r\n}\r\nw100_init_clocks(par);\r\ncalc_hsync(par);\r\nreturn count;\r\n}\r\nunsigned long w100fb_get_hsynclen(struct device *dev)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct w100fb_par *par=info->par;\r\nif (par->blanked)\r\nreturn 0;\r\nelse\r\nreturn par->hsync_len;\r\n}\r\nstatic void w100fb_clear_screen(struct w100fb_par *par)\r\n{\r\nmemset_io(remapped_fbuf + (W100_FB_BASE-MEM_WINDOW_BASE), 0, (par->xres * par->yres * BITS_PER_PIXEL/8));\r\n}\r\nstatic int w100fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int trans, struct fb_info *info)\r\n{\r\nunsigned int val;\r\nint ret = 1;\r\nif (info->var.grayscale)\r\nred = green = blue = (19595 * red + 38470 * green + 7471 * blue) >> 16;\r\nif (regno < MAX_PALETTES) {\r\nu32 *pal = info->pseudo_palette;\r\nval = (red & 0xf800) | ((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);\r\npal[regno] = val;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int w100fb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct w100fb_par *par = info->par;\r\nstruct w100_tg_info *tg = par->mach->tg;\r\nswitch(blank_mode) {\r\ncase FB_BLANK_NORMAL:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_POWERDOWN:\r\nif (par->blanked == 0) {\r\nif(tg && tg->suspend)\r\ntg->suspend(par);\r\npar->blanked = 1;\r\n}\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nif (par->blanked != 0) {\r\nif(tg && tg->resume)\r\ntg->resume(par);\r\npar->blanked = 0;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void w100_fifo_wait(int entries)\r\n{\r\nunion rbbm_status_u status;\r\nint i;\r\nfor (i = 0; i < 2000000; i++) {\r\nstatus.val = readl(remapped_regs + mmRBBM_STATUS);\r\nif (status.f.cmdfifo_avail >= entries)\r\nreturn;\r\nudelay(1);\r\n}\r\nprintk(KERN_ERR "w100fb: FIFO Timeout!\n");\r\n}\r\nstatic int w100fb_sync(struct fb_info *info)\r\n{\r\nunion rbbm_status_u status;\r\nint i;\r\nfor (i = 0; i < 2000000; i++) {\r\nstatus.val = readl(remapped_regs + mmRBBM_STATUS);\r\nif (!status.f.gui_active)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nprintk(KERN_ERR "w100fb: Graphic engine timeout!\n");\r\nreturn -EBUSY;\r\n}\r\nstatic void w100_init_graphic_engine(struct w100fb_par *par)\r\n{\r\nunion dp_gui_master_cntl_u gmc;\r\nunion dp_mix_u dp_mix;\r\nunion dp_datatype_u dp_datatype;\r\nunion dp_cntl_u dp_cntl;\r\nw100_fifo_wait(4);\r\nwritel(W100_FB_BASE, remapped_regs + mmDST_OFFSET);\r\nwritel(par->xres, remapped_regs + mmDST_PITCH);\r\nwritel(W100_FB_BASE, remapped_regs + mmSRC_OFFSET);\r\nwritel(par->xres, remapped_regs + mmSRC_PITCH);\r\nw100_fifo_wait(3);\r\nwritel(0, remapped_regs + mmSC_TOP_LEFT);\r\nwritel((par->yres << 16) | par->xres, remapped_regs + mmSC_BOTTOM_RIGHT);\r\nwritel(0x1fff1fff, remapped_regs + mmSRC_SC_BOTTOM_RIGHT);\r\nw100_fifo_wait(4);\r\ndp_cntl.val = 0;\r\ndp_cntl.f.dst_x_dir = 1;\r\ndp_cntl.f.dst_y_dir = 1;\r\ndp_cntl.f.src_x_dir = 1;\r\ndp_cntl.f.src_y_dir = 1;\r\ndp_cntl.f.dst_major_x = 1;\r\ndp_cntl.f.src_major_x = 1;\r\nwritel(dp_cntl.val, remapped_regs + mmDP_CNTL);\r\ngmc.val = 0;\r\ngmc.f.gmc_src_pitch_offset_cntl = 1;\r\ngmc.f.gmc_dst_pitch_offset_cntl = 1;\r\ngmc.f.gmc_src_clipping = 1;\r\ngmc.f.gmc_dst_clipping = 1;\r\ngmc.f.gmc_brush_datatype = GMC_BRUSH_NONE;\r\ngmc.f.gmc_dst_datatype = 3;\r\ngmc.f.gmc_src_datatype = SRC_DATATYPE_EQU_DST;\r\ngmc.f.gmc_byte_pix_order = 1;\r\ngmc.f.gmc_default_sel = 0;\r\ngmc.f.gmc_rop3 = ROP3_SRCCOPY;\r\ngmc.f.gmc_dp_src_source = DP_SRC_MEM_RECTANGULAR;\r\ngmc.f.gmc_clr_cmp_fcn_dis = 1;\r\ngmc.f.gmc_wr_msk_dis = 1;\r\ngmc.f.gmc_dp_op = DP_OP_ROP;\r\nwritel(gmc.val, remapped_regs + mmDP_GUI_MASTER_CNTL);\r\ndp_datatype.val = dp_mix.val = 0;\r\ndp_datatype.f.dp_dst_datatype = gmc.f.gmc_dst_datatype;\r\ndp_datatype.f.dp_brush_datatype = gmc.f.gmc_brush_datatype;\r\ndp_datatype.f.dp_src2_type = 0;\r\ndp_datatype.f.dp_src2_datatype = gmc.f.gmc_src_datatype;\r\ndp_datatype.f.dp_src_datatype = gmc.f.gmc_src_datatype;\r\ndp_datatype.f.dp_byte_pix_order = gmc.f.gmc_byte_pix_order;\r\nwritel(dp_datatype.val, remapped_regs + mmDP_DATATYPE);\r\ndp_mix.f.dp_src_source = gmc.f.gmc_dp_src_source;\r\ndp_mix.f.dp_src2_source = 1;\r\ndp_mix.f.dp_rop3 = gmc.f.gmc_rop3;\r\ndp_mix.f.dp_op = gmc.f.gmc_dp_op;\r\nwritel(dp_mix.val, remapped_regs + mmDP_MIX);\r\n}\r\nstatic void w100fb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nunion dp_gui_master_cntl_u gmc;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED) {\r\ncfb_fillrect(info, rect);\r\nreturn;\r\n}\r\ngmc.val = readl(remapped_regs + mmDP_GUI_MASTER_CNTL);\r\ngmc.f.gmc_rop3 = ROP3_PATCOPY;\r\ngmc.f.gmc_brush_datatype = GMC_BRUSH_SOLID_COLOR;\r\nw100_fifo_wait(2);\r\nwritel(gmc.val, remapped_regs + mmDP_GUI_MASTER_CNTL);\r\nwritel(rect->color, remapped_regs + mmDP_BRUSH_FRGD_CLR);\r\nw100_fifo_wait(2);\r\nwritel((rect->dy << 16) | (rect->dx & 0xffff), remapped_regs + mmDST_Y_X);\r\nwritel((rect->width << 16) | (rect->height & 0xffff),\r\nremapped_regs + mmDST_WIDTH_HEIGHT);\r\n}\r\nstatic void w100fb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nu32 dx = area->dx, dy = area->dy, sx = area->sx, sy = area->sy;\r\nu32 h = area->height, w = area->width;\r\nunion dp_gui_master_cntl_u gmc;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED) {\r\ncfb_copyarea(info, area);\r\nreturn;\r\n}\r\ngmc.val = readl(remapped_regs + mmDP_GUI_MASTER_CNTL);\r\ngmc.f.gmc_rop3 = ROP3_SRCCOPY;\r\ngmc.f.gmc_brush_datatype = GMC_BRUSH_NONE;\r\nw100_fifo_wait(1);\r\nwritel(gmc.val, remapped_regs + mmDP_GUI_MASTER_CNTL);\r\nw100_fifo_wait(3);\r\nwritel((sy << 16) | (sx & 0xffff), remapped_regs + mmSRC_Y_X);\r\nwritel((dy << 16) | (dx & 0xffff), remapped_regs + mmDST_Y_X);\r\nwritel((w << 16) | (h & 0xffff), remapped_regs + mmDST_WIDTH_HEIGHT);\r\n}\r\nstatic void w100fb_activate_var(struct w100fb_par *par)\r\n{\r\nstruct w100_tg_info *tg = par->mach->tg;\r\nw100_pwm_setup(par);\r\nw100_setup_memory(par);\r\nw100_init_clocks(par);\r\nw100fb_clear_screen(par);\r\nw100_vsync();\r\nw100_update_disable();\r\nw100_init_lcd(par);\r\nw100_set_dispregs(par);\r\nw100_update_enable();\r\nw100_init_graphic_engine(par);\r\ncalc_hsync(par);\r\nif (!par->blanked && tg && tg->change)\r\ntg->change(par);\r\n}\r\nstatic struct w100_mode *w100fb_get_mode(struct w100fb_par *par, unsigned int *x, unsigned int *y, int saveval)\r\n{\r\nstruct w100_mode *mode = NULL;\r\nstruct w100_mode *modelist = par->mach->modelist;\r\nunsigned int best_x = 0xffffffff, best_y = 0xffffffff;\r\nunsigned int i;\r\nfor (i = 0 ; i < par->mach->num_modes ; i++) {\r\nif (modelist[i].xres >= *x && modelist[i].yres >= *y &&\r\nmodelist[i].xres < best_x && modelist[i].yres < best_y) {\r\nbest_x = modelist[i].xres;\r\nbest_y = modelist[i].yres;\r\nmode = &modelist[i];\r\n} else if(modelist[i].xres >= *y && modelist[i].yres >= *x &&\r\nmodelist[i].xres < best_y && modelist[i].yres < best_x) {\r\nbest_x = modelist[i].yres;\r\nbest_y = modelist[i].xres;\r\nmode = &modelist[i];\r\n}\r\n}\r\nif (mode && saveval) {\r\n*x = best_x;\r\n*y = best_y;\r\n}\r\nreturn mode;\r\n}\r\nstatic int w100fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct w100fb_par *par=info->par;\r\nif(!w100fb_get_mode(par, &var->xres, &var->yres, 1))\r\nreturn -EINVAL;\r\nif (par->mach->mem && ((var->xres*var->yres*BITS_PER_PIXEL/8) > (par->mach->mem->size+1)))\r\nreturn -EINVAL;\r\nif (!par->mach->mem && ((var->xres*var->yres*BITS_PER_PIXEL/8) > (MEM_INT_SIZE+1)))\r\nreturn -EINVAL;\r\nvar->xres_virtual = max(var->xres_virtual, var->xres);\r\nvar->yres_virtual = max(var->yres_virtual, var->yres);\r\nif (var->bits_per_pixel > BITS_PER_PIXEL)\r\nreturn -EINVAL;\r\nelse\r\nvar->bits_per_pixel = BITS_PER_PIXEL;\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = var->transp.length = 0;\r\nvar->nonstd = 0;\r\nvar->height = -1;\r\nvar->width = -1;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nvar->sync = 0;\r\nvar->pixclock = 0x04;\r\nreturn 0;\r\n}\r\nstatic int w100fb_set_par(struct fb_info *info)\r\n{\r\nstruct w100fb_par *par=info->par;\r\nif (par->xres != info->var.xres || par->yres != info->var.yres) {\r\npar->xres = info->var.xres;\r\npar->yres = info->var.yres;\r\npar->mode = w100fb_get_mode(par, &par->xres, &par->yres, 0);\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.ypanstep = 0;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.line_length = par->xres * BITS_PER_PIXEL / 8;\r\nmutex_lock(&info->mm_lock);\r\nif ((par->xres*par->yres*BITS_PER_PIXEL/8) > (MEM_INT_SIZE+1)) {\r\npar->extmem_active = 1;\r\ninfo->fix.smem_len = par->mach->mem->size+1;\r\n} else {\r\npar->extmem_active = 0;\r\ninfo->fix.smem_len = MEM_INT_SIZE+1;\r\n}\r\nmutex_unlock(&info->mm_lock);\r\nw100fb_activate_var(par);\r\n}\r\nreturn 0;\r\n}\r\nstatic void w100fb_save_vidmem(struct w100fb_par *par)\r\n{\r\nint memsize;\r\nif (par->extmem_active) {\r\nmemsize=par->mach->mem->size;\r\npar->saved_extmem = vmalloc(memsize);\r\nif (par->saved_extmem)\r\nmemcpy_fromio(par->saved_extmem, remapped_fbuf + (W100_FB_BASE-MEM_WINDOW_BASE), memsize);\r\n}\r\nmemsize=MEM_INT_SIZE;\r\npar->saved_intmem = vmalloc(memsize);\r\nif (par->saved_intmem && par->extmem_active)\r\nmemcpy_fromio(par->saved_intmem, remapped_fbuf + (W100_FB_BASE-MEM_INT_BASE_VALUE), memsize);\r\nelse if (par->saved_intmem)\r\nmemcpy_fromio(par->saved_intmem, remapped_fbuf + (W100_FB_BASE-MEM_WINDOW_BASE), memsize);\r\n}\r\nstatic void w100fb_restore_vidmem(struct w100fb_par *par)\r\n{\r\nint memsize;\r\nif (par->extmem_active && par->saved_extmem) {\r\nmemsize=par->mach->mem->size;\r\nmemcpy_toio(remapped_fbuf + (W100_FB_BASE-MEM_WINDOW_BASE), par->saved_extmem, memsize);\r\nvfree(par->saved_extmem);\r\n}\r\nif (par->saved_intmem) {\r\nmemsize=MEM_INT_SIZE;\r\nif (par->extmem_active)\r\nmemcpy_toio(remapped_fbuf + (W100_FB_BASE-MEM_INT_BASE_VALUE), par->saved_intmem, memsize);\r\nelse\r\nmemcpy_toio(remapped_fbuf + (W100_FB_BASE-MEM_WINDOW_BASE), par->saved_intmem, memsize);\r\nvfree(par->saved_intmem);\r\n}\r\n}\r\nstatic int w100fb_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct w100fb_par *par=info->par;\r\nstruct w100_tg_info *tg = par->mach->tg;\r\nw100fb_save_vidmem(par);\r\nif(tg && tg->suspend)\r\ntg->suspend(par);\r\nw100_suspend(W100_SUSPEND_ALL);\r\npar->blanked = 1;\r\nreturn 0;\r\n}\r\nstatic int w100fb_resume(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct w100fb_par *par=info->par;\r\nstruct w100_tg_info *tg = par->mach->tg;\r\nw100_hw_init(par);\r\nw100fb_activate_var(par);\r\nw100fb_restore_vidmem(par);\r\nif(tg && tg->resume)\r\ntg->resume(par);\r\npar->blanked = 0;\r\nreturn 0;\r\n}\r\nint __devinit w100fb_probe(struct platform_device *pdev)\r\n{\r\nint err = -EIO;\r\nstruct w100fb_mach_info *inf;\r\nstruct fb_info *info = NULL;\r\nstruct w100fb_par *par;\r\nstruct resource *mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nunsigned int chip_id;\r\nif (!mem)\r\nreturn -EINVAL;\r\nremapped_base = ioremap_nocache(mem->start+W100_CFG_BASE, W100_CFG_LEN);\r\nif (remapped_base == NULL)\r\ngoto out;\r\nremapped_regs = ioremap_nocache(mem->start+W100_REG_BASE, W100_REG_LEN);\r\nif (remapped_regs == NULL)\r\ngoto out;\r\nprintk("Found ");\r\nchip_id = readl(remapped_regs + mmCHIP_ID);\r\nswitch(chip_id) {\r\ncase CHIP_ID_W100: printk("w100"); break;\r\ncase CHIP_ID_W3200: printk("w3200"); break;\r\ncase CHIP_ID_W3220: printk("w3220"); break;\r\ndefault:\r\nprintk("Unknown imageon chip ID\n");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nprintk(" at 0x%08lx.\n", (unsigned long) mem->start+W100_CFG_BASE);\r\nremapped_fbuf = ioremap_nocache(mem->start+MEM_WINDOW_BASE, MEM_WINDOW_SIZE);\r\nif (remapped_fbuf == NULL)\r\ngoto out;\r\ninfo=framebuffer_alloc(sizeof(struct w100fb_par), &pdev->dev);\r\nif (!info) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\npar = info->par;\r\nplatform_set_drvdata(pdev, info);\r\ninf = pdev->dev.platform_data;\r\npar->chip_id = chip_id;\r\npar->mach = inf;\r\npar->fastpll_mode = 0;\r\npar->blanked = 0;\r\npar->pll_table=w100_get_xtal_table(inf->xtal_freq);\r\nif (!par->pll_table) {\r\nprintk(KERN_ERR "No matching Xtal definition found\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\ninfo->pseudo_palette = kmalloc(sizeof (u32) * MAX_PALETTES, GFP_KERNEL);\r\nif (!info->pseudo_palette) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\ninfo->fbops = &w100fb_ops;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_FILLRECT;\r\ninfo->node = -1;\r\ninfo->screen_base = remapped_fbuf + (W100_FB_BASE-MEM_WINDOW_BASE);\r\ninfo->screen_size = REMAPPED_FB_LEN;\r\nstrcpy(info->fix.id, "w100fb");\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->fix.smem_start = mem->start+W100_FB_BASE;\r\ninfo->fix.mmio_start = mem->start+W100_REG_BASE;\r\ninfo->fix.mmio_len = W100_REG_LEN;\r\nif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\npar->mode = &inf->modelist[0];\r\nif(inf->init_mode & INIT_MODE_ROTATED) {\r\ninfo->var.xres = par->mode->yres;\r\ninfo->var.yres = par->mode->xres;\r\n}\r\nelse {\r\ninfo->var.xres = par->mode->xres;\r\ninfo->var.yres = par->mode->yres;\r\n}\r\nif(inf->init_mode &= INIT_MODE_FLIPPED)\r\npar->flip = 1;\r\nelse\r\npar->flip = 0;\r\ninfo->var.xres_virtual = info->var.xres;\r\ninfo->var.yres_virtual = info->var.yres;\r\ninfo->var.pixclock = 0x04;\r\ninfo->var.sync = 0;\r\ninfo->var.grayscale = 0;\r\ninfo->var.xoffset = info->var.yoffset = 0;\r\ninfo->var.accel_flags = 0;\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\nw100_hw_init(par);\r\nif (w100fb_check_var(&info->var, info) < 0) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (register_framebuffer(info) < 0) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = device_create_file(&pdev->dev, &dev_attr_fastpllclk);\r\nerr |= device_create_file(&pdev->dev, &dev_attr_reg_read);\r\nerr |= device_create_file(&pdev->dev, &dev_attr_reg_write);\r\nerr |= device_create_file(&pdev->dev, &dev_attr_flip);\r\nif (err != 0)\r\nprintk(KERN_WARNING "fb%d: failed to register attributes (%d)\n",\r\ninfo->node, err);\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n", info->node, info->fix.id);\r\nreturn 0;\r\nout:\r\nif (info) {\r\nfb_dealloc_cmap(&info->cmap);\r\nkfree(info->pseudo_palette);\r\n}\r\nif (remapped_fbuf != NULL)\r\niounmap(remapped_fbuf);\r\nif (remapped_regs != NULL)\r\niounmap(remapped_regs);\r\nif (remapped_base != NULL)\r\niounmap(remapped_base);\r\nif (info)\r\nframebuffer_release(info);\r\nreturn err;\r\n}\r\nstatic int __devexit w100fb_remove(struct platform_device *pdev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nstruct w100fb_par *par=info->par;\r\ndevice_remove_file(&pdev->dev, &dev_attr_fastpllclk);\r\ndevice_remove_file(&pdev->dev, &dev_attr_reg_read);\r\ndevice_remove_file(&pdev->dev, &dev_attr_reg_write);\r\ndevice_remove_file(&pdev->dev, &dev_attr_flip);\r\nunregister_framebuffer(info);\r\nvfree(par->saved_intmem);\r\nvfree(par->saved_extmem);\r\nkfree(info->pseudo_palette);\r\nfb_dealloc_cmap(&info->cmap);\r\niounmap(remapped_base);\r\niounmap(remapped_regs);\r\niounmap(remapped_fbuf);\r\nframebuffer_release(info);\r\nreturn 0;\r\n}\r\nstatic void w100_soft_reset(void)\r\n{\r\nu16 val = readw((u16 *) remapped_base + cfgSTATUS);\r\nwritew(val | 0x08, (u16 *) remapped_base + cfgSTATUS);\r\nudelay(100);\r\nwritew(0x00, (u16 *) remapped_base + cfgSTATUS);\r\nudelay(100);\r\n}\r\nstatic void w100_update_disable(void)\r\n{\r\nunion disp_db_buf_cntl_wr_u disp_db_buf_wr_cntl;\r\ndisp_db_buf_wr_cntl.f.db_buf_cntl = 0x1e;\r\ndisp_db_buf_wr_cntl.f.update_db_buf = 0;\r\ndisp_db_buf_wr_cntl.f.en_db_buf = 0;\r\nwritel((u32) (disp_db_buf_wr_cntl.val), remapped_regs + mmDISP_DB_BUF_CNTL);\r\n}\r\nstatic void w100_update_enable(void)\r\n{\r\nunion disp_db_buf_cntl_wr_u disp_db_buf_wr_cntl;\r\ndisp_db_buf_wr_cntl.f.db_buf_cntl = 0x1e;\r\ndisp_db_buf_wr_cntl.f.update_db_buf = 1;\r\ndisp_db_buf_wr_cntl.f.en_db_buf = 1;\r\nwritel((u32) (disp_db_buf_wr_cntl.val), remapped_regs + mmDISP_DB_BUF_CNTL);\r\n}\r\nunsigned long w100fb_gpio_read(int port)\r\n{\r\nunsigned long value;\r\nif (port==W100_GPIO_PORT_A)\r\nvalue = readl(remapped_regs + mmGPIO_DATA);\r\nelse\r\nvalue = readl(remapped_regs + mmGPIO_DATA2);\r\nreturn value;\r\n}\r\nvoid w100fb_gpio_write(int port, unsigned long value)\r\n{\r\nif (port==W100_GPIO_PORT_A)\r\nwritel(value, remapped_regs + mmGPIO_DATA);\r\nelse\r\nwritel(value, remapped_regs + mmGPIO_DATA2);\r\n}\r\nstatic void w100_hw_init(struct w100fb_par *par)\r\n{\r\nu32 temp32;\r\nunion cif_cntl_u cif_cntl;\r\nunion intf_cntl_u intf_cntl;\r\nunion cfgreg_base_u cfgreg_base;\r\nunion wrap_top_dir_u wrap_top_dir;\r\nunion cif_read_dbg_u cif_read_dbg;\r\nunion cpu_defaults_u cpu_default;\r\nunion cif_write_dbg_u cif_write_dbg;\r\nunion wrap_start_dir_u wrap_start_dir;\r\nunion cif_io_u cif_io;\r\nstruct w100_gpio_regs *gpio = par->mach->gpio;\r\nw100_soft_reset();\r\nwritel(0x31, remapped_regs + mmSCRATCH_UMSK);\r\nfor (temp32 = 0; temp32 < 10000; temp32++)\r\nreadl(remapped_regs + mmSCRATCH_UMSK);\r\nwritel(0x30, remapped_regs + mmSCRATCH_UMSK);\r\ncif_io.val = defCIF_IO;\r\nwritel((u32)(cif_io.val), remapped_regs + mmCIF_IO);\r\ncif_write_dbg.val = readl(remapped_regs + mmCIF_WRITE_DBG);\r\ncif_write_dbg.f.dis_packer_ful_during_rbbm_timeout = 0;\r\ncif_write_dbg.f.en_dword_split_to_rbbm = 1;\r\ncif_write_dbg.f.dis_timeout_during_rbbm = 1;\r\nwritel((u32) (cif_write_dbg.val), remapped_regs + mmCIF_WRITE_DBG);\r\ncif_read_dbg.val = readl(remapped_regs + mmCIF_READ_DBG);\r\ncif_read_dbg.f.dis_rd_same_byte_to_trig_fetch = 1;\r\nwritel((u32) (cif_read_dbg.val), remapped_regs + mmCIF_READ_DBG);\r\ncif_cntl.val = readl(remapped_regs + mmCIF_CNTL);\r\ncif_cntl.f.dis_system_bits = 1;\r\ncif_cntl.f.dis_mr = 1;\r\ncif_cntl.f.en_wait_to_compensate_dq_prop_dly = 0;\r\ncif_cntl.f.intb_oe = 1;\r\ncif_cntl.f.interrupt_active_high = 1;\r\nwritel((u32) (cif_cntl.val), remapped_regs + mmCIF_CNTL);\r\nintf_cntl.val = defINTF_CNTL;\r\nintf_cntl.f.ad_inc_a = 1;\r\nintf_cntl.f.ad_inc_b = 1;\r\nintf_cntl.f.rd_data_rdy_a = 0;\r\nintf_cntl.f.rd_data_rdy_b = 0;\r\nwriteb((u8) (intf_cntl.val), remapped_base + cfgINTF_CNTL);\r\ncpu_default.val = defCPU_DEFAULTS;\r\ncpu_default.f.access_ind_addr_a = 1;\r\ncpu_default.f.access_ind_addr_b = 1;\r\ncpu_default.f.access_scratch_reg = 1;\r\ncpu_default.f.transition_size = 0;\r\nwriteb((u8) (cpu_default.val), remapped_base + cfgCPU_DEFAULTS);\r\nwriteb((u8) (W100_REG_BASE >> 16), remapped_base + cfgREG_BASE);\r\ncfgreg_base.val = defCFGREG_BASE;\r\ncfgreg_base.f.cfgreg_base = W100_CFG_BASE;\r\nwritel((u32) (cfgreg_base.val), remapped_regs + mmCFGREG_BASE);\r\nwrap_start_dir.val = defWRAP_START_DIR;\r\nwrap_start_dir.f.start_addr = WRAP_BUF_BASE_VALUE >> 1;\r\nwritel((u32) (wrap_start_dir.val), remapped_regs + mmWRAP_START_DIR);\r\nwrap_top_dir.val = defWRAP_TOP_DIR;\r\nwrap_top_dir.f.top_addr = WRAP_BUF_TOP_VALUE >> 1;\r\nwritel((u32) (wrap_top_dir.val), remapped_regs + mmWRAP_TOP_DIR);\r\nwritel((u32) 0x2440, remapped_regs + mmRBBM_CNTL);\r\ntemp32 = readl(remapped_regs + mmDISP_DEBUG2);\r\ntemp32 &= 0xff7fffff;\r\ntemp32 |= 0x00800000;\r\nwritel(temp32, remapped_regs + mmDISP_DEBUG2);\r\nif (gpio) {\r\nwritel(gpio->init_data1, remapped_regs + mmGPIO_DATA);\r\nwritel(gpio->init_data2, remapped_regs + mmGPIO_DATA2);\r\nwritel(gpio->gpio_dir1, remapped_regs + mmGPIO_CNTL1);\r\nwritel(gpio->gpio_oe1, remapped_regs + mmGPIO_CNTL2);\r\nwritel(gpio->gpio_dir2, remapped_regs + mmGPIO_CNTL3);\r\nwritel(gpio->gpio_oe2, remapped_regs + mmGPIO_CNTL4);\r\n}\r\n}\r\nstruct w100_pll_info __devinit *w100_get_xtal_table(unsigned int freq)\r\n{\r\nstruct pll_entries *pll_entry = w100_pll_tables;\r\ndo {\r\nif (freq == pll_entry->xtal_freq)\r\nreturn pll_entry->pll_table;\r\npll_entry++;\r\n} while (pll_entry->xtal_freq);\r\nreturn 0;\r\n}\r\nstatic unsigned int w100_get_testcount(unsigned int testclk_sel)\r\n{\r\nunion clk_test_cntl_u clk_test_cntl;\r\nudelay(5);\r\nclk_test_cntl.f.start_check_freq = 0x0;\r\nclk_test_cntl.f.testclk_sel = testclk_sel;\r\nclk_test_cntl.f.tstcount_rst = 0x1;\r\nwritel((u32) (clk_test_cntl.val), remapped_regs + mmCLK_TEST_CNTL);\r\nclk_test_cntl.f.tstcount_rst = 0x0;\r\nwritel((u32) (clk_test_cntl.val), remapped_regs + mmCLK_TEST_CNTL);\r\nclk_test_cntl.f.start_check_freq = 0x1;\r\nwritel((u32) (clk_test_cntl.val), remapped_regs + mmCLK_TEST_CNTL);\r\nudelay(20);\r\nclk_test_cntl.val = readl(remapped_regs + mmCLK_TEST_CNTL);\r\nclk_test_cntl.f.start_check_freq = 0x0;\r\nwritel((u32) (clk_test_cntl.val), remapped_regs + mmCLK_TEST_CNTL);\r\nreturn clk_test_cntl.f.test_count;\r\n}\r\nstatic int w100_pll_adjust(struct w100_pll_info *pll)\r\n{\r\nunsigned int tf80;\r\nunsigned int tf20;\r\nw100_pwr_state.pll_cntl.f.pll_pwdn = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_reset = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_tcpoff = 0x1;\r\nw100_pwr_state.pll_cntl.f.pll_pvg = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_vcofr = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_ioffset = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_ring_off = 0x0;\r\ndo {\r\nw100_pwr_state.pll_cntl.f.pll_dactal = 0xd;\r\nwritel((u32) (w100_pwr_state.pll_cntl.val), remapped_regs + mmPLL_CNTL);\r\ntf80 = w100_get_testcount(TESTCLK_SRC_PLL);\r\nif (tf80 >= (pll->tfgoal)) {\r\nw100_pwr_state.pll_cntl.f.pll_dactal = 0x7;\r\nwritel((u32) (w100_pwr_state.pll_cntl.val), remapped_regs + mmPLL_CNTL);\r\ntf20 = w100_get_testcount(TESTCLK_SRC_PLL);\r\nif (tf20 <= (pll->tfgoal))\r\nreturn 1;\r\nif ((w100_pwr_state.pll_cntl.f.pll_vcofr == 0x0) &&\r\n((w100_pwr_state.pll_cntl.f.pll_pvg == 0x7) ||\r\n(w100_pwr_state.pll_cntl.f.pll_ioffset == 0x0))) {\r\nw100_pwr_state.pll_cntl.f.pll_vcofr = 0x1;\r\nw100_pwr_state.pll_cntl.f.pll_pvg = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_ioffset = 0x0;\r\ncontinue;\r\n}\r\n}\r\nif ((w100_pwr_state.pll_cntl.f.pll_ioffset) < 0x3) {\r\nw100_pwr_state.pll_cntl.f.pll_ioffset += 0x1;\r\n} else if ((w100_pwr_state.pll_cntl.f.pll_pvg) < 0x7) {\r\nw100_pwr_state.pll_cntl.f.pll_ioffset = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_pvg += 0x1;\r\n} else {\r\nreturn 0;\r\n}\r\n} while(1);\r\n}\r\nstatic int w100_pll_calibration(struct w100_pll_info *pll)\r\n{\r\nint status;\r\nstatus = w100_pll_adjust(pll);\r\nw100_pwr_state.pll_cntl.f.pll_dactal = 0xa;\r\nwritel((u32) (w100_pwr_state.pll_cntl.val), remapped_regs + mmPLL_CNTL);\r\nudelay(1);\r\nw100_pwr_state.pll_cntl.f.pll_tcpoff = 0x0;\r\nwritel((u32) (w100_pwr_state.pll_cntl.val), remapped_regs + mmPLL_CNTL);\r\nw100_pwr_state.pll_cntl.f.pll_dactal = 0x0;\r\nwritel((u32) (w100_pwr_state.pll_cntl.val), remapped_regs + mmPLL_CNTL);\r\nudelay(400);\r\nreturn status;\r\n}\r\nstatic int w100_pll_set_clk(struct w100_pll_info *pll)\r\n{\r\nint status;\r\nif (w100_pwr_state.auto_mode == 1)\r\n{\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_fast_noml_hw_en = 0x0;\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_noml_fast_hw_en = 0x0;\r\nwritel((u32) (w100_pwr_state.pwrmgt_cntl.val), remapped_regs + mmPWRMGT_CNTL);\r\n}\r\nw100_pwr_state.sclk_cntl.f.sclk_src_sel = CLK_SRC_XTAL;\r\nwritel((u32) (w100_pwr_state.sclk_cntl.val), remapped_regs + mmSCLK_CNTL);\r\nw100_pwr_state.pll_ref_fb_div.f.pll_ref_div = pll->M;\r\nw100_pwr_state.pll_ref_fb_div.f.pll_fb_div_int = pll->N_int;\r\nw100_pwr_state.pll_ref_fb_div.f.pll_fb_div_frac = pll->N_fac;\r\nw100_pwr_state.pll_ref_fb_div.f.pll_lock_time = pll->lock_time;\r\nwritel((u32) (w100_pwr_state.pll_ref_fb_div.val), remapped_regs + mmPLL_REF_FB_DIV);\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_mode_req = 0;\r\nwritel((u32) (w100_pwr_state.pwrmgt_cntl.val), remapped_regs + mmPWRMGT_CNTL);\r\nstatus = w100_pll_calibration(pll);\r\nif (w100_pwr_state.auto_mode == 1)\r\n{\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_fast_noml_hw_en = 0x1;\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_noml_fast_hw_en = 0x1;\r\nwritel((u32) (w100_pwr_state.pwrmgt_cntl.val), remapped_regs + mmPWRMGT_CNTL);\r\n}\r\nreturn status;\r\n}\r\nstatic int w100_set_pll_freq(struct w100fb_par *par, unsigned int freq)\r\n{\r\nstruct w100_pll_info *pll = par->pll_table;\r\ndo {\r\nif (freq == pll->freq) {\r\nreturn w100_pll_set_clk(pll);\r\n}\r\npll++;\r\n} while(pll->freq);\r\nreturn 0;\r\n}\r\nstatic void w100_pwm_setup(struct w100fb_par *par)\r\n{\r\nw100_pwr_state.clk_pin_cntl.f.osc_en = 0x1;\r\nw100_pwr_state.clk_pin_cntl.f.osc_gain = 0x1f;\r\nw100_pwr_state.clk_pin_cntl.f.dont_use_xtalin = 0x0;\r\nw100_pwr_state.clk_pin_cntl.f.xtalin_pm_en = 0x0;\r\nw100_pwr_state.clk_pin_cntl.f.xtalin_dbl_en = par->mach->xtal_dbl ? 1 : 0;\r\nw100_pwr_state.clk_pin_cntl.f.cg_debug = 0x0;\r\nwritel((u32) (w100_pwr_state.clk_pin_cntl.val), remapped_regs + mmCLK_PIN_CNTL);\r\nw100_pwr_state.sclk_cntl.f.sclk_src_sel = CLK_SRC_XTAL;\r\nw100_pwr_state.sclk_cntl.f.sclk_post_div_fast = 0x0;\r\nw100_pwr_state.sclk_cntl.f.sclk_clkon_hys = 0x3;\r\nw100_pwr_state.sclk_cntl.f.sclk_post_div_slow = 0x0;\r\nw100_pwr_state.sclk_cntl.f.disp_cg_ok2switch_en = 0x0;\r\nw100_pwr_state.sclk_cntl.f.sclk_force_reg = 0x0;\r\nw100_pwr_state.sclk_cntl.f.sclk_force_disp = 0x0;\r\nw100_pwr_state.sclk_cntl.f.sclk_force_mc = 0x0;\r\nw100_pwr_state.sclk_cntl.f.sclk_force_extmc = 0x0;\r\nw100_pwr_state.sclk_cntl.f.sclk_force_cp = 0x0;\r\nw100_pwr_state.sclk_cntl.f.sclk_force_e2 = 0x0;\r\nw100_pwr_state.sclk_cntl.f.sclk_force_e3 = 0x0;\r\nw100_pwr_state.sclk_cntl.f.sclk_force_idct = 0x0;\r\nw100_pwr_state.sclk_cntl.f.sclk_force_bist = 0x0;\r\nw100_pwr_state.sclk_cntl.f.busy_extend_cp = 0x0;\r\nw100_pwr_state.sclk_cntl.f.busy_extend_e2 = 0x0;\r\nw100_pwr_state.sclk_cntl.f.busy_extend_e3 = 0x0;\r\nw100_pwr_state.sclk_cntl.f.busy_extend_idct = 0x0;\r\nwritel((u32) (w100_pwr_state.sclk_cntl.val), remapped_regs + mmSCLK_CNTL);\r\nw100_pwr_state.pclk_cntl.f.pclk_src_sel = CLK_SRC_XTAL;\r\nw100_pwr_state.pclk_cntl.f.pclk_post_div = 0x1;\r\nw100_pwr_state.pclk_cntl.f.pclk_force_disp = 0x0;\r\nwritel((u32) (w100_pwr_state.pclk_cntl.val), remapped_regs + mmPCLK_CNTL);\r\nw100_pwr_state.pll_ref_fb_div.f.pll_ref_div = 0x0;\r\nw100_pwr_state.pll_ref_fb_div.f.pll_fb_div_int = 0x0;\r\nw100_pwr_state.pll_ref_fb_div.f.pll_fb_div_frac = 0x0;\r\nw100_pwr_state.pll_ref_fb_div.f.pll_reset_time = 0x5;\r\nw100_pwr_state.pll_ref_fb_div.f.pll_lock_time = 0xff;\r\nwritel((u32) (w100_pwr_state.pll_ref_fb_div.val), remapped_regs + mmPLL_REF_FB_DIV);\r\nw100_pwr_state.pll_cntl.f.pll_pwdn = 0x1;\r\nw100_pwr_state.pll_cntl.f.pll_reset = 0x1;\r\nw100_pwr_state.pll_cntl.f.pll_pm_en = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_mode = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_refclk_sel = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_fbclk_sel = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_tcpoff = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_pcp = 0x4;\r\nw100_pwr_state.pll_cntl.f.pll_pvg = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_vcofr = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_ioffset = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_pecc_mode = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_pecc_scon = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_dactal = 0x0;\r\nw100_pwr_state.pll_cntl.f.pll_cp_clip = 0x3;\r\nw100_pwr_state.pll_cntl.f.pll_conf = 0x2;\r\nw100_pwr_state.pll_cntl.f.pll_mbctrl = 0x2;\r\nw100_pwr_state.pll_cntl.f.pll_ring_off = 0x0;\r\nwritel((u32) (w100_pwr_state.pll_cntl.val), remapped_regs + mmPLL_CNTL);\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_enable = 0x0;\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_mode_req = 0x1;\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_wakeup_cond = 0x0;\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_fast_noml_hw_en = 0x0;\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_noml_fast_hw_en = 0x0;\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_fast_noml_cond = 0x1;\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_noml_fast_cond = 0x1;\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_idle_timer = 0xFF;\r\nw100_pwr_state.pwrmgt_cntl.f.pwm_busy_timer = 0xFF;\r\nwritel((u32) (w100_pwr_state.pwrmgt_cntl.val), remapped_regs + mmPWRMGT_CNTL);\r\nw100_pwr_state.auto_mode = 0;\r\n}\r\nstatic void w100_init_clocks(struct w100fb_par *par)\r\n{\r\nstruct w100_mode *mode = par->mode;\r\nif (mode->pixclk_src == CLK_SRC_PLL || mode->sysclk_src == CLK_SRC_PLL)\r\nw100_set_pll_freq(par, (par->fastpll_mode && mode->fast_pll_freq) ? mode->fast_pll_freq : mode->pll_freq);\r\nw100_pwr_state.sclk_cntl.f.sclk_src_sel = mode->sysclk_src;\r\nw100_pwr_state.sclk_cntl.f.sclk_post_div_fast = mode->sysclk_divider;\r\nw100_pwr_state.sclk_cntl.f.sclk_post_div_slow = mode->sysclk_divider;\r\nwritel((u32) (w100_pwr_state.sclk_cntl.val), remapped_regs + mmSCLK_CNTL);\r\n}\r\nstatic void w100_init_lcd(struct w100fb_par *par)\r\n{\r\nu32 temp32;\r\nstruct w100_mode *mode = par->mode;\r\nstruct w100_gen_regs *regs = par->mach->regs;\r\nunion active_h_disp_u active_h_disp;\r\nunion active_v_disp_u active_v_disp;\r\nunion graphic_h_disp_u graphic_h_disp;\r\nunion graphic_v_disp_u graphic_v_disp;\r\nunion crtc_total_u crtc_total;\r\nactive_h_disp.val = 0;\r\nactive_h_disp.f.active_h_start=mode->left_margin;\r\nactive_h_disp.f.active_h_end=mode->left_margin + mode->xres;\r\nwritel(active_h_disp.val, remapped_regs + mmACTIVE_H_DISP);\r\nactive_v_disp.val = 0;\r\nactive_v_disp.f.active_v_start=mode->upper_margin;\r\nactive_v_disp.f.active_v_end=mode->upper_margin + mode->yres;\r\nwritel(active_v_disp.val, remapped_regs + mmACTIVE_V_DISP);\r\ngraphic_h_disp.val = 0;\r\ngraphic_h_disp.f.graphic_h_start=mode->left_margin;\r\ngraphic_h_disp.f.graphic_h_end=mode->left_margin + mode->xres;\r\nwritel(graphic_h_disp.val, remapped_regs + mmGRAPHIC_H_DISP);\r\ngraphic_v_disp.val = 0;\r\ngraphic_v_disp.f.graphic_v_start=mode->upper_margin;\r\ngraphic_v_disp.f.graphic_v_end=mode->upper_margin + mode->yres;\r\nwritel(graphic_v_disp.val, remapped_regs + mmGRAPHIC_V_DISP);\r\ncrtc_total.val = 0;\r\ncrtc_total.f.crtc_h_total=mode->left_margin + mode->xres + mode->right_margin;\r\ncrtc_total.f.crtc_v_total=mode->upper_margin + mode->yres + mode->lower_margin;\r\nwritel(crtc_total.val, remapped_regs + mmCRTC_TOTAL);\r\nwritel(mode->crtc_ss, remapped_regs + mmCRTC_SS);\r\nwritel(mode->crtc_ls, remapped_regs + mmCRTC_LS);\r\nwritel(mode->crtc_gs, remapped_regs + mmCRTC_GS);\r\nwritel(mode->crtc_vpos_gs, remapped_regs + mmCRTC_VPOS_GS);\r\nwritel(mode->crtc_rev, remapped_regs + mmCRTC_REV);\r\nwritel(mode->crtc_dclk, remapped_regs + mmCRTC_DCLK);\r\nwritel(mode->crtc_gclk, remapped_regs + mmCRTC_GCLK);\r\nwritel(mode->crtc_goe, remapped_regs + mmCRTC_GOE);\r\nwritel(mode->crtc_ps1_active, remapped_regs + mmCRTC_PS1_ACTIVE);\r\nwritel(regs->lcd_format, remapped_regs + mmLCD_FORMAT);\r\nwritel(regs->lcdd_cntl1, remapped_regs + mmLCDD_CNTL1);\r\nwritel(regs->lcdd_cntl2, remapped_regs + mmLCDD_CNTL2);\r\nwritel(regs->genlcd_cntl1, remapped_regs + mmGENLCD_CNTL1);\r\nwritel(regs->genlcd_cntl2, remapped_regs + mmGENLCD_CNTL2);\r\nwritel(regs->genlcd_cntl3, remapped_regs + mmGENLCD_CNTL3);\r\nwritel(0x00000000, remapped_regs + mmCRTC_FRAME);\r\nwritel(0x00000000, remapped_regs + mmCRTC_FRAME_VPOS);\r\nwritel(0x00000000, remapped_regs + mmCRTC_DEFAULT_COUNT);\r\nwritel(0x0000FF00, remapped_regs + mmLCD_BACKGROUND_COLOR);\r\ntemp32 = readl(remapped_regs + mmDISP_DEBUG2);\r\ntemp32 |= 0xc0000000;\r\nwritel(temp32, remapped_regs + mmDISP_DEBUG2);\r\n}\r\nstatic void w100_setup_memory(struct w100fb_par *par)\r\n{\r\nunion mc_ext_mem_location_u extmem_location;\r\nunion mc_fb_location_u intmem_location;\r\nstruct w100_mem_info *mem = par->mach->mem;\r\nstruct w100_bm_mem_info *bm_mem = par->mach->bm_mem;\r\nif (!par->extmem_active) {\r\nw100_suspend(W100_SUSPEND_EXTMEM);\r\nintmem_location.f.mc_fb_start = W100_FB_BASE >> 8;\r\nintmem_location.f.mc_fb_top = (W100_FB_BASE+MEM_INT_SIZE) >> 8;\r\nwritel((u32) (intmem_location.val), remapped_regs + mmMC_FB_LOCATION);\r\nextmem_location.f.mc_ext_mem_start = MEM_EXT_BASE_VALUE >> 8;\r\nextmem_location.f.mc_ext_mem_top = (MEM_EXT_BASE_VALUE-1) >> 8;\r\nwritel((u32) (extmem_location.val), remapped_regs + mmMC_EXT_MEM_LOCATION);\r\n} else {\r\nintmem_location.f.mc_fb_start = MEM_INT_BASE_VALUE >> 8;\r\nintmem_location.f.mc_fb_top = (MEM_INT_BASE_VALUE+MEM_INT_SIZE) >> 8;\r\nwritel((u32) (intmem_location.val), remapped_regs + mmMC_FB_LOCATION);\r\nextmem_location.f.mc_ext_mem_start = W100_FB_BASE >> 8;\r\nextmem_location.f.mc_ext_mem_top = (W100_FB_BASE+par->mach->mem->size) >> 8;\r\nwritel((u32) (extmem_location.val), remapped_regs + mmMC_EXT_MEM_LOCATION);\r\nwritel(0x00007800, remapped_regs + mmMC_BIST_CTRL);\r\nwritel(mem->ext_cntl, remapped_regs + mmMEM_EXT_CNTL);\r\nwritel(0x00200021, remapped_regs + mmMEM_SDRAM_MODE_REG);\r\nudelay(100);\r\nwritel(0x80200021, remapped_regs + mmMEM_SDRAM_MODE_REG);\r\nudelay(100);\r\nwritel(mem->sdram_mode_reg, remapped_regs + mmMEM_SDRAM_MODE_REG);\r\nudelay(100);\r\nwritel(mem->ext_timing_cntl, remapped_regs + mmMEM_EXT_TIMING_CNTL);\r\nwritel(mem->io_cntl, remapped_regs + mmMEM_IO_CNTL);\r\nif (bm_mem) {\r\nwritel(bm_mem->ext_mem_bw, remapped_regs + mmBM_EXT_MEM_BANDWIDTH);\r\nwritel(bm_mem->offset, remapped_regs + mmBM_OFFSET);\r\nwritel(bm_mem->ext_timing_ctl, remapped_regs + mmBM_MEM_EXT_TIMING_CNTL);\r\nwritel(bm_mem->ext_cntl, remapped_regs + mmBM_MEM_EXT_CNTL);\r\nwritel(bm_mem->mode_reg, remapped_regs + mmBM_MEM_MODE_REG);\r\nwritel(bm_mem->io_cntl, remapped_regs + mmBM_MEM_IO_CNTL);\r\nwritel(bm_mem->config, remapped_regs + mmBM_CONFIG);\r\n}\r\n}\r\n}\r\nstatic void w100_set_dispregs(struct w100fb_par *par)\r\n{\r\nunsigned long rot=0, divider, offset=0;\r\nunion graphic_ctrl_u graphic_ctrl;\r\nif (par->xres == par->mode->xres) {\r\nif (par->flip) {\r\nrot=3;\r\noffset=(par->xres * par->yres) - 1;\r\n}\r\ndivider = par->mode->pixclk_divider;\r\n} else {\r\nif (par->flip) {\r\nrot=2;\r\noffset=par->xres - 1;\r\n} else {\r\nrot=1;\r\noffset=par->xres * (par->yres - 1);\r\n}\r\ndivider = par->mode->pixclk_divider_rotated;\r\n}\r\ngraphic_ctrl.val = 0;\r\nswitch (par->chip_id) {\r\ncase CHIP_ID_W100:\r\ngraphic_ctrl.f_w100.color_depth=6;\r\ngraphic_ctrl.f_w100.en_crtc=1;\r\ngraphic_ctrl.f_w100.en_graphic_req=1;\r\ngraphic_ctrl.f_w100.en_graphic_crtc=1;\r\ngraphic_ctrl.f_w100.lcd_pclk_on=1;\r\ngraphic_ctrl.f_w100.lcd_sclk_on=1;\r\ngraphic_ctrl.f_w100.low_power_on=0;\r\ngraphic_ctrl.f_w100.req_freq=0;\r\ngraphic_ctrl.f_w100.portrait_mode=rot;\r\nswitch(par->xres) {\r\ncase 240:\r\ncase 320:\r\ndefault:\r\ngraphic_ctrl.f_w100.total_req_graphic=0xa0;\r\nbreak;\r\ncase 480:\r\ncase 640:\r\nswitch(rot) {\r\ncase 0:\r\ncase 3:\r\ngraphic_ctrl.f_w100.low_power_on=1;\r\ngraphic_ctrl.f_w100.req_freq=5;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ngraphic_ctrl.f_w100.req_freq=4;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ngraphic_ctrl.f_w100.total_req_graphic=0xf0;\r\nbreak;\r\n}\r\nbreak;\r\ncase CHIP_ID_W3200:\r\ncase CHIP_ID_W3220:\r\ngraphic_ctrl.f_w32xx.color_depth=6;\r\ngraphic_ctrl.f_w32xx.en_crtc=1;\r\ngraphic_ctrl.f_w32xx.en_graphic_req=1;\r\ngraphic_ctrl.f_w32xx.en_graphic_crtc=1;\r\ngraphic_ctrl.f_w32xx.lcd_pclk_on=1;\r\ngraphic_ctrl.f_w32xx.lcd_sclk_on=1;\r\ngraphic_ctrl.f_w32xx.low_power_on=0;\r\ngraphic_ctrl.f_w32xx.req_freq=0;\r\ngraphic_ctrl.f_w32xx.total_req_graphic=par->mode->xres >> 1;\r\ngraphic_ctrl.f_w32xx.portrait_mode=rot;\r\nbreak;\r\n}\r\nw100_pwr_state.pclk_cntl.f.pclk_src_sel = par->mode->pixclk_src;\r\nw100_pwr_state.pclk_cntl.f.pclk_post_div = divider;\r\nwritel((u32) (w100_pwr_state.pclk_cntl.val), remapped_regs + mmPCLK_CNTL);\r\nwritel(graphic_ctrl.val, remapped_regs + mmGRAPHIC_CTRL);\r\nwritel(W100_FB_BASE + ((offset * BITS_PER_PIXEL/8)&~0x03UL), remapped_regs + mmGRAPHIC_OFFSET);\r\nwritel((par->xres*BITS_PER_PIXEL/8), remapped_regs + mmGRAPHIC_PITCH);\r\n}\r\nstatic void calc_hsync(struct w100fb_par *par)\r\n{\r\nunsigned long hsync;\r\nstruct w100_mode *mode = par->mode;\r\nunion crtc_ss_u crtc_ss;\r\nif (mode->pixclk_src == CLK_SRC_XTAL)\r\nhsync=par->mach->xtal_freq;\r\nelse\r\nhsync=((par->fastpll_mode && mode->fast_pll_freq) ? mode->fast_pll_freq : mode->pll_freq)*100000;\r\nhsync /= (w100_pwr_state.pclk_cntl.f.pclk_post_div + 1);\r\ncrtc_ss.val = readl(remapped_regs + mmCRTC_SS);\r\nif (crtc_ss.val)\r\npar->hsync_len = hsync / (crtc_ss.f.ss_end-crtc_ss.f.ss_start);\r\nelse\r\npar->hsync_len = 0;\r\n}\r\nstatic void w100_suspend(u32 mode)\r\n{\r\nu32 val;\r\nwritel(0x7FFF8000, remapped_regs + mmMC_EXT_MEM_LOCATION);\r\nwritel(0x00FF0000, remapped_regs + mmMC_PERF_MON_CNTL);\r\nval = readl(remapped_regs + mmMEM_EXT_TIMING_CNTL);\r\nval &= ~(0x00100000);\r\nval |= 0xFF000000;\r\nwritel(val, remapped_regs + mmMEM_EXT_TIMING_CNTL);\r\nval = readl(remapped_regs + mmMEM_EXT_CNTL);\r\nval &= ~(0x00040000);\r\nval |= 0x00080000;\r\nwritel(val, remapped_regs + mmMEM_EXT_CNTL);\r\nudelay(1);\r\nif (mode == W100_SUSPEND_EXTMEM) {\r\nval = readl(remapped_regs + mmMEM_EXT_CNTL);\r\nval |= 0x40000000;\r\nwritel(val, remapped_regs + mmMEM_EXT_CNTL);\r\nval = readl(remapped_regs + mmMEM_EXT_CNTL);\r\nval &= ~(0x00000001);\r\nwritel(val, remapped_regs + mmMEM_EXT_CNTL);\r\n} else {\r\nwritel(0x00000000, remapped_regs + mmSCLK_CNTL);\r\nwritel(0x000000BF, remapped_regs + mmCLK_PIN_CNTL);\r\nwritel(0x00000015, remapped_regs + mmPWRMGT_CNTL);\r\nudelay(5);\r\nval = readl(remapped_regs + mmPLL_CNTL);\r\nval |= 0x00000004;\r\nwritel(val, remapped_regs + mmPLL_CNTL);\r\nwritel(0x00000000, remapped_regs + mmLCDD_CNTL1);\r\nwritel(0x00000000, remapped_regs + mmLCDD_CNTL2);\r\nwritel(0x00000000, remapped_regs + mmGENLCD_CNTL1);\r\nwritel(0x00000000, remapped_regs + mmGENLCD_CNTL2);\r\nwritel(0x00000000, remapped_regs + mmGENLCD_CNTL3);\r\nval = readl(remapped_regs + mmMEM_EXT_CNTL);\r\nval |= 0xF0000000;\r\nval &= ~(0x00000001);\r\nwritel(val, remapped_regs + mmMEM_EXT_CNTL);\r\nwritel(0x0000001d, remapped_regs + mmPWRMGT_CNTL);\r\n}\r\n}\r\nstatic void w100_vsync(void)\r\n{\r\nu32 tmp;\r\nint timeout = 30000;\r\ntmp = readl(remapped_regs + mmACTIVE_V_DISP);\r\nwritel((tmp >> 16) & 0x3ff, remapped_regs + mmDISP_INT_CNTL);\r\ntmp = readl(remapped_regs + mmGEN_INT_CNTL);\r\ntmp &= ~0x00000002;\r\nwritel(tmp, remapped_regs + mmGEN_INT_CNTL);\r\nwritel(0x00000002, remapped_regs + mmGEN_INT_STATUS);\r\nwritel((tmp | 0x00000002), remapped_regs + mmGEN_INT_CNTL);\r\nwritel(0x00000002, remapped_regs + mmGEN_INT_STATUS);\r\nwhile(timeout > 0) {\r\nif (readl(remapped_regs + mmGEN_INT_STATUS) & 0x00000002)\r\nbreak;\r\nudelay(1);\r\ntimeout--;\r\n}\r\nwritel(tmp, remapped_regs + mmGEN_INT_CNTL);\r\nwritel(0x00000002, remapped_regs + mmGEN_INT_STATUS);\r\n}
