static inline unsigned int ar933x_uart_read(struct ar933x_uart_port *up,\r\nint offset)\r\n{\r\nreturn readl(up->port.membase + offset);\r\n}\r\nstatic inline void ar933x_uart_write(struct ar933x_uart_port *up,\r\nint offset, unsigned int value)\r\n{\r\nwritel(value, up->port.membase + offset);\r\n}\r\nstatic inline void ar933x_uart_rmw(struct ar933x_uart_port *up,\r\nunsigned int offset,\r\nunsigned int mask,\r\nunsigned int val)\r\n{\r\nunsigned int t;\r\nt = ar933x_uart_read(up, offset);\r\nt &= ~mask;\r\nt |= val;\r\nar933x_uart_write(up, offset, t);\r\n}\r\nstatic inline void ar933x_uart_rmw_set(struct ar933x_uart_port *up,\r\nunsigned int offset,\r\nunsigned int val)\r\n{\r\nar933x_uart_rmw(up, offset, 0, val);\r\n}\r\nstatic inline void ar933x_uart_rmw_clear(struct ar933x_uart_port *up,\r\nunsigned int offset,\r\nunsigned int val)\r\n{\r\nar933x_uart_rmw(up, offset, val, 0);\r\n}\r\nstatic inline void ar933x_uart_start_tx_interrupt(struct ar933x_uart_port *up)\r\n{\r\nup->ier |= AR933X_UART_INT_TX_EMPTY;\r\nar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);\r\n}\r\nstatic inline void ar933x_uart_stop_tx_interrupt(struct ar933x_uart_port *up)\r\n{\r\nup->ier &= ~AR933X_UART_INT_TX_EMPTY;\r\nar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);\r\n}\r\nstatic inline void ar933x_uart_putc(struct ar933x_uart_port *up, int ch)\r\n{\r\nunsigned int rdata;\r\nrdata = ch & AR933X_UART_DATA_TX_RX_MASK;\r\nrdata |= AR933X_UART_DATA_TX_CSR;\r\nar933x_uart_write(up, AR933X_UART_DATA_REG, rdata);\r\n}\r\nstatic unsigned int ar933x_uart_tx_empty(struct uart_port *port)\r\n{\r\nstruct ar933x_uart_port *up = (struct ar933x_uart_port *) port;\r\nunsigned long flags;\r\nunsigned int rdata;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nrdata = ar933x_uart_read(up, AR933X_UART_DATA_REG);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn (rdata & AR933X_UART_DATA_TX_CSR) ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic unsigned int ar933x_uart_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR;\r\n}\r\nstatic void ar933x_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void ar933x_uart_start_tx(struct uart_port *port)\r\n{\r\nstruct ar933x_uart_port *up = (struct ar933x_uart_port *) port;\r\nar933x_uart_start_tx_interrupt(up);\r\n}\r\nstatic void ar933x_uart_stop_tx(struct uart_port *port)\r\n{\r\nstruct ar933x_uart_port *up = (struct ar933x_uart_port *) port;\r\nar933x_uart_stop_tx_interrupt(up);\r\n}\r\nstatic void ar933x_uart_stop_rx(struct uart_port *port)\r\n{\r\nstruct ar933x_uart_port *up = (struct ar933x_uart_port *) port;\r\nup->ier &= ~AR933X_UART_INT_RX_VALID;\r\nar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);\r\n}\r\nstatic void ar933x_uart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct ar933x_uart_port *up = (struct ar933x_uart_port *) port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (break_state == -1)\r\nar933x_uart_rmw_set(up, AR933X_UART_CS_REG,\r\nAR933X_UART_CS_TX_BREAK);\r\nelse\r\nar933x_uart_rmw_clear(up, AR933X_UART_CS_REG,\r\nAR933X_UART_CS_TX_BREAK);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic void ar933x_uart_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void ar933x_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *new,\r\nstruct ktermios *old)\r\n{\r\nstruct ar933x_uart_port *up = (struct ar933x_uart_port *) port;\r\nunsigned int cs;\r\nunsigned long flags;\r\nunsigned int baud, scale;\r\nnew->c_cflag &= ~CSIZE;\r\nnew->c_cflag |= CS8;\r\nnew->c_cflag &= ~CSTOPB;\r\ncs = 0;\r\nif (new->c_cflag & PARENB) {\r\nif (!(new->c_cflag & PARODD))\r\ncs |= AR933X_UART_CS_PARITY_EVEN;\r\nelse\r\ncs |= AR933X_UART_CS_PARITY_ODD;\r\n} else {\r\ncs |= AR933X_UART_CS_PARITY_NONE;\r\n}\r\nnew->c_cflag &= ~CMSPAR;\r\nbaud = uart_get_baud_rate(port, new, old, 0, port->uartclk / 16);\r\nscale = (port->uartclk / (16 * baud)) - 1;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nuart_update_timeout(port, new->c_cflag, baud);\r\nup->port.ignore_status_mask = 0;\r\nif ((new->c_cflag & CREAD) == 0)\r\nup->port.ignore_status_mask |= AR933X_DUMMY_STATUS_RD;\r\nar933x_uart_write(up, AR933X_UART_CLOCK_REG,\r\nscale << AR933X_UART_CLOCK_SCALE_S | 8192);\r\nar933x_uart_rmw(up, AR933X_UART_CS_REG, AR933X_UART_CS_PARITY_M, cs);\r\nar933x_uart_rmw_set(up, AR933X_UART_CS_REG,\r\nAR933X_UART_CS_HOST_INT_EN);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nif (tty_termios_baud_rate(new))\r\ntty_termios_encode_baud_rate(new, baud, baud);\r\n}\r\nstatic void ar933x_uart_rx_chars(struct ar933x_uart_port *up)\r\n{\r\nstruct tty_struct *tty;\r\nint max_count = 256;\r\ntty = tty_port_tty_get(&up->port.state->port);\r\ndo {\r\nunsigned int rdata;\r\nunsigned char ch;\r\nrdata = ar933x_uart_read(up, AR933X_UART_DATA_REG);\r\nif ((rdata & AR933X_UART_DATA_RX_CSR) == 0)\r\nbreak;\r\nar933x_uart_write(up, AR933X_UART_DATA_REG,\r\nAR933X_UART_DATA_RX_CSR);\r\nif (!tty) {\r\ncontinue;\r\n}\r\nup->port.icount.rx++;\r\nch = rdata & AR933X_UART_DATA_TX_RX_MASK;\r\nif (uart_handle_sysrq_char(&up->port, ch))\r\ncontinue;\r\nif ((up->port.ignore_status_mask & AR933X_DUMMY_STATUS_RD) == 0)\r\ntty_insert_flip_char(tty, ch, TTY_NORMAL);\r\n} while (max_count-- > 0);\r\nif (tty) {\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nstatic void ar933x_uart_tx_chars(struct ar933x_uart_port *up)\r\n{\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nint count;\r\nif (uart_tx_stopped(&up->port))\r\nreturn;\r\ncount = up->port.fifosize;\r\ndo {\r\nunsigned int rdata;\r\nrdata = ar933x_uart_read(up, AR933X_UART_DATA_REG);\r\nif ((rdata & AR933X_UART_DATA_TX_CSR) == 0)\r\nbreak;\r\nif (up->port.x_char) {\r\nar933x_uart_putc(up, up->port.x_char);\r\nup->port.icount.tx++;\r\nup->port.x_char = 0;\r\ncontinue;\r\n}\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\nar933x_uart_putc(up, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nup->port.icount.tx++;\r\n} while (--count > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\nif (!uart_circ_empty(xmit))\r\nar933x_uart_start_tx_interrupt(up);\r\n}\r\nstatic irqreturn_t ar933x_uart_interrupt(int irq, void *dev_id)\r\n{\r\nstruct ar933x_uart_port *up = dev_id;\r\nunsigned int status;\r\nstatus = ar933x_uart_read(up, AR933X_UART_CS_REG);\r\nif ((status & AR933X_UART_CS_HOST_INT) == 0)\r\nreturn IRQ_NONE;\r\nspin_lock(&up->port.lock);\r\nstatus = ar933x_uart_read(up, AR933X_UART_INT_REG);\r\nstatus &= ar933x_uart_read(up, AR933X_UART_INT_EN_REG);\r\nif (status & AR933X_UART_INT_RX_VALID) {\r\nar933x_uart_write(up, AR933X_UART_INT_REG,\r\nAR933X_UART_INT_RX_VALID);\r\nar933x_uart_rx_chars(up);\r\n}\r\nif (status & AR933X_UART_INT_TX_EMPTY) {\r\nar933x_uart_write(up, AR933X_UART_INT_REG,\r\nAR933X_UART_INT_TX_EMPTY);\r\nar933x_uart_stop_tx_interrupt(up);\r\nar933x_uart_tx_chars(up);\r\n}\r\nspin_unlock(&up->port.lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ar933x_uart_startup(struct uart_port *port)\r\n{\r\nstruct ar933x_uart_port *up = (struct ar933x_uart_port *) port;\r\nunsigned long flags;\r\nint ret;\r\nret = request_irq(up->port.irq, ar933x_uart_interrupt,\r\nup->port.irqflags, dev_name(up->port.dev), up);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nar933x_uart_rmw_set(up, AR933X_UART_CS_REG,\r\nAR933X_UART_CS_HOST_INT_EN);\r\nup->ier = AR933X_UART_INT_RX_VALID;\r\nar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ar933x_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct ar933x_uart_port *up = (struct ar933x_uart_port *) port;\r\nup->ier = 0;\r\nar933x_uart_write(up, AR933X_UART_INT_EN_REG, up->ier);\r\nar933x_uart_rmw_clear(up, AR933X_UART_CS_REG,\r\nAR933X_UART_CS_TX_BREAK);\r\nfree_irq(up->port.irq, up);\r\n}\r\nstatic const char *ar933x_uart_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_AR933X) ? "AR933X UART" : NULL;\r\n}\r\nstatic void ar933x_uart_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int ar933x_uart_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ar933x_uart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_AR933X;\r\n}\r\nstatic int ar933x_uart_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nif (ser->type != PORT_UNKNOWN &&\r\nser->type != PORT_AR933X)\r\nreturn -EINVAL;\r\nif (ser->irq < 0 || ser->irq >= NR_IRQS)\r\nreturn -EINVAL;\r\nif (ser->baud_base < 28800)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void ar933x_uart_wait_xmitr(struct ar933x_uart_port *up)\r\n{\r\nunsigned int status;\r\nunsigned int timeout = 60000;\r\ndo {\r\nstatus = ar933x_uart_read(up, AR933X_UART_DATA_REG);\r\nif (--timeout == 0)\r\nbreak;\r\nudelay(1);\r\n} while ((status & AR933X_UART_DATA_TX_CSR) == 0);\r\n}\r\nstatic void ar933x_uart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct ar933x_uart_port *up = (struct ar933x_uart_port *) port;\r\nar933x_uart_wait_xmitr(up);\r\nar933x_uart_putc(up, ch);\r\n}\r\nstatic void ar933x_uart_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct ar933x_uart_port *up = ar933x_console_ports[co->index];\r\nunsigned long flags;\r\nunsigned int int_en;\r\nint locked = 1;\r\nlocal_irq_save(flags);\r\nif (up->port.sysrq)\r\nlocked = 0;\r\nelse if (oops_in_progress)\r\nlocked = spin_trylock(&up->port.lock);\r\nelse\r\nspin_lock(&up->port.lock);\r\nint_en = ar933x_uart_read(up, AR933X_UART_INT_EN_REG);\r\nar933x_uart_write(up, AR933X_UART_INT_EN_REG, 0);\r\nuart_console_write(&up->port, s, count, ar933x_uart_console_putchar);\r\nar933x_uart_wait_xmitr(up);\r\nar933x_uart_write(up, AR933X_UART_INT_EN_REG, int_en);\r\nar933x_uart_write(up, AR933X_UART_INT_REG, AR933X_UART_INT_ALLINTS);\r\nif (locked)\r\nspin_unlock(&up->port.lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int ar933x_uart_console_setup(struct console *co, char *options)\r\n{\r\nstruct ar933x_uart_port *up;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index < 0 || co->index >= CONFIG_SERIAL_AR933X_NR_UARTS)\r\nreturn -EINVAL;\r\nup = ar933x_console_ports[co->index];\r\nif (!up)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&up->port, co, baud, parity, bits, flow);\r\n}\r\nstatic void ar933x_uart_add_console_port(struct ar933x_uart_port *up)\r\n{\r\nar933x_console_ports[up->port.line] = up;\r\n}\r\nstatic inline void ar933x_uart_add_console_port(struct ar933x_uart_port *up) {}\r\nstatic int __devinit ar933x_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct ar933x_uart_platform_data *pdata;\r\nstruct ar933x_uart_port *up;\r\nstruct uart_port *port;\r\nstruct resource *mem_res;\r\nstruct resource *irq_res;\r\nint id;\r\nint ret;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nid = pdev->id;\r\nif (id == -1)\r\nid = 0;\r\nif (id > CONFIG_SERIAL_AR933X_NR_UARTS)\r\nreturn -EINVAL;\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem_res) {\r\ndev_err(&pdev->dev, "no MEM resource\n");\r\nreturn -EINVAL;\r\n}\r\nirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq_res) {\r\ndev_err(&pdev->dev, "no IRQ resource\n");\r\nreturn -EINVAL;\r\n}\r\nup = kzalloc(sizeof(struct ar933x_uart_port), GFP_KERNEL);\r\nif (!up)\r\nreturn -ENOMEM;\r\nport = &up->port;\r\nport->mapbase = mem_res->start;\r\nport->membase = ioremap(mem_res->start, AR933X_UART_REGS_SIZE);\r\nif (!port->membase) {\r\nret = -ENOMEM;\r\ngoto err_free_up;\r\n}\r\nport->line = id;\r\nport->irq = irq_res->start;\r\nport->dev = &pdev->dev;\r\nport->type = PORT_AR933X;\r\nport->iotype = UPIO_MEM32;\r\nport->uartclk = pdata->uartclk;\r\nport->regshift = 2;\r\nport->fifosize = AR933X_UART_FIFO_SIZE;\r\nport->ops = &ar933x_uart_ops;\r\nar933x_uart_add_console_port(up);\r\nret = uart_add_one_port(&ar933x_uart_driver, &up->port);\r\nif (ret)\r\ngoto err_unmap;\r\nplatform_set_drvdata(pdev, up);\r\nreturn 0;\r\nerr_unmap:\r\niounmap(up->port.membase);\r\nerr_free_up:\r\nkfree(up);\r\nreturn ret;\r\n}\r\nstatic int __devexit ar933x_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct ar933x_uart_port *up;\r\nup = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (up) {\r\nuart_remove_one_port(&ar933x_uart_driver, &up->port);\r\niounmap(up->port.membase);\r\nkfree(up);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ar933x_uart_init(void)\r\n{\r\nint ret;\r\nar933x_uart_driver.nr = CONFIG_SERIAL_AR933X_NR_UARTS;\r\nret = uart_register_driver(&ar933x_uart_driver);\r\nif (ret)\r\ngoto err_out;\r\nret = platform_driver_register(&ar933x_uart_platform_driver);\r\nif (ret)\r\ngoto err_unregister_uart_driver;\r\nreturn 0;\r\nerr_unregister_uart_driver:\r\nuart_unregister_driver(&ar933x_uart_driver);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic void __exit ar933x_uart_exit(void)\r\n{\r\nplatform_driver_unregister(&ar933x_uart_platform_driver);\r\nuart_unregister_driver(&ar933x_uart_driver);\r\n}
