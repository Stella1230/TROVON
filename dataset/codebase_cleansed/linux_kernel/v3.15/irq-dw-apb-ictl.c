static void dw_apb_ictl_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_get_chip(irq);\r\nstruct irq_chip_generic *gc = irq_get_handler_data(irq);\r\nstruct irq_domain *d = gc->private;\r\nu32 stat;\r\nint n;\r\nchained_irq_enter(chip, desc);\r\nfor (n = 0; n < gc->num_ct; n++) {\r\nstat = readl_relaxed(gc->reg_base +\r\nAPB_INT_FINALSTATUS_L + 4 * n);\r\nwhile (stat) {\r\nu32 hwirq = ffs(stat) - 1;\r\ngeneric_handle_irq(irq_find_mapping(d,\r\ngc->irq_base + hwirq + 32 * n));\r\nstat &= ~(1 << hwirq);\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int __init dw_apb_ictl_init(struct device_node *np,\r\nstruct device_node *parent)\r\n{\r\nunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\r\nstruct resource r;\r\nstruct irq_domain *domain;\r\nstruct irq_chip_generic *gc;\r\nvoid __iomem *iobase;\r\nint ret, nrirqs, irq;\r\nu32 reg;\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (irq <= 0) {\r\npr_err("%s: unable to parse irq\n", np->full_name);\r\nreturn -EINVAL;\r\n}\r\nret = of_address_to_resource(np, 0, &r);\r\nif (ret) {\r\npr_err("%s: unable to get resource\n", np->full_name);\r\nreturn ret;\r\n}\r\nif (!request_mem_region(r.start, resource_size(&r), np->full_name)) {\r\npr_err("%s: unable to request mem region\n", np->full_name);\r\nreturn -ENOMEM;\r\n}\r\niobase = ioremap(r.start, resource_size(&r));\r\nif (!iobase) {\r\npr_err("%s: unable to map resource\n", np->full_name);\r\nret = -ENOMEM;\r\ngoto err_release;\r\n}\r\nwritel(~0, iobase + APB_INT_MASK_L);\r\nwritel(~0, iobase + APB_INT_MASK_H);\r\nwritel(~0, iobase + APB_INT_ENABLE_L);\r\nwritel(~0, iobase + APB_INT_ENABLE_H);\r\nreg = readl(iobase + APB_INT_ENABLE_H);\r\nif (reg)\r\nnrirqs = 32 + fls(reg);\r\nelse\r\nnrirqs = fls(readl(iobase + APB_INT_ENABLE_L));\r\ndomain = irq_domain_add_linear(np, nrirqs,\r\n&irq_generic_chip_ops, NULL);\r\nif (!domain) {\r\npr_err("%s: unable to add irq domain\n", np->full_name);\r\nret = -ENOMEM;\r\ngoto err_unmap;\r\n}\r\nret = irq_alloc_domain_generic_chips(domain, 32, (nrirqs > 32) ? 2 : 1,\r\nnp->name, handle_level_irq, clr, 0,\r\nIRQ_GC_INIT_MASK_CACHE);\r\nif (ret) {\r\npr_err("%s: unable to alloc irq domain gc\n", np->full_name);\r\ngoto err_unmap;\r\n}\r\ngc = irq_get_domain_generic_chip(domain, 0);\r\ngc->private = domain;\r\ngc->reg_base = iobase;\r\ngc->chip_types[0].regs.mask = APB_INT_MASK_L;\r\ngc->chip_types[0].chip.irq_mask = irq_gc_mask_set_bit;\r\ngc->chip_types[0].chip.irq_unmask = irq_gc_mask_clr_bit;\r\nif (nrirqs > 32) {\r\ngc->chip_types[1].regs.mask = APB_INT_MASK_H;\r\ngc->chip_types[1].chip.irq_mask = irq_gc_mask_set_bit;\r\ngc->chip_types[1].chip.irq_unmask = irq_gc_mask_clr_bit;\r\n}\r\nirq_set_handler_data(irq, gc);\r\nirq_set_chained_handler(irq, dw_apb_ictl_handler);\r\nreturn 0;\r\nerr_unmap:\r\niounmap(iobase);\r\nerr_release:\r\nrelease_mem_region(r.start, resource_size(&r));\r\nreturn ret;\r\n}
