void nf_register_queue_handler(const struct nf_queue_handler *qh)\r\n{\r\nWARN_ON(rcu_access_pointer(queue_handler));\r\nrcu_assign_pointer(queue_handler, qh);\r\n}\r\nvoid nf_unregister_queue_handler(void)\r\n{\r\nRCU_INIT_POINTER(queue_handler, NULL);\r\nsynchronize_rcu();\r\n}\r\nvoid nf_queue_entry_release_refs(struct nf_queue_entry *entry)\r\n{\r\nif (entry->indev)\r\ndev_put(entry->indev);\r\nif (entry->outdev)\r\ndev_put(entry->outdev);\r\n#ifdef CONFIG_BRIDGE_NETFILTER\r\nif (entry->skb->nf_bridge) {\r\nstruct nf_bridge_info *nf_bridge = entry->skb->nf_bridge;\r\nif (nf_bridge->physindev)\r\ndev_put(nf_bridge->physindev);\r\nif (nf_bridge->physoutdev)\r\ndev_put(nf_bridge->physoutdev);\r\n}\r\n#endif\r\nmodule_put(entry->elem->owner);\r\n}\r\nbool nf_queue_entry_get_refs(struct nf_queue_entry *entry)\r\n{\r\nif (!try_module_get(entry->elem->owner))\r\nreturn false;\r\nif (entry->indev)\r\ndev_hold(entry->indev);\r\nif (entry->outdev)\r\ndev_hold(entry->outdev);\r\n#ifdef CONFIG_BRIDGE_NETFILTER\r\nif (entry->skb->nf_bridge) {\r\nstruct nf_bridge_info *nf_bridge = entry->skb->nf_bridge;\r\nstruct net_device *physdev;\r\nphysdev = nf_bridge->physindev;\r\nif (physdev)\r\ndev_hold(physdev);\r\nphysdev = nf_bridge->physoutdev;\r\nif (physdev)\r\ndev_hold(physdev);\r\n}\r\n#endif\r\nreturn true;\r\n}\r\nint nf_queue(struct sk_buff *skb,\r\nstruct nf_hook_ops *elem,\r\nu_int8_t pf, unsigned int hook,\r\nstruct net_device *indev,\r\nstruct net_device *outdev,\r\nint (*okfn)(struct sk_buff *),\r\nunsigned int queuenum)\r\n{\r\nint status = -ENOENT;\r\nstruct nf_queue_entry *entry = NULL;\r\nconst struct nf_afinfo *afinfo;\r\nconst struct nf_queue_handler *qh;\r\nrcu_read_lock();\r\nqh = rcu_dereference(queue_handler);\r\nif (!qh) {\r\nstatus = -ESRCH;\r\ngoto err_unlock;\r\n}\r\nafinfo = nf_get_afinfo(pf);\r\nif (!afinfo)\r\ngoto err_unlock;\r\nentry = kmalloc(sizeof(*entry) + afinfo->route_key_size, GFP_ATOMIC);\r\nif (!entry) {\r\nstatus = -ENOMEM;\r\ngoto err_unlock;\r\n}\r\n*entry = (struct nf_queue_entry) {\r\n.skb = skb,\r\n.elem = elem,\r\n.pf = pf,\r\n.hook = hook,\r\n.indev = indev,\r\n.outdev = outdev,\r\n.okfn = okfn,\r\n.size = sizeof(*entry) + afinfo->route_key_size,\r\n};\r\nif (!nf_queue_entry_get_refs(entry)) {\r\nstatus = -ECANCELED;\r\ngoto err_unlock;\r\n}\r\nskb_dst_force(skb);\r\nafinfo->saveroute(skb, entry);\r\nstatus = qh->outfn(entry, queuenum);\r\nrcu_read_unlock();\r\nif (status < 0) {\r\nnf_queue_entry_release_refs(entry);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr_unlock:\r\nrcu_read_unlock();\r\nerr:\r\nkfree(entry);\r\nreturn status;\r\n}\r\nvoid nf_reinject(struct nf_queue_entry *entry, unsigned int verdict)\r\n{\r\nstruct sk_buff *skb = entry->skb;\r\nstruct nf_hook_ops *elem = entry->elem;\r\nconst struct nf_afinfo *afinfo;\r\nint err;\r\nrcu_read_lock();\r\nnf_queue_entry_release_refs(entry);\r\nif (verdict == NF_REPEAT) {\r\nelem = list_entry(elem->list.prev, struct nf_hook_ops, list);\r\nverdict = NF_ACCEPT;\r\n}\r\nif (verdict == NF_ACCEPT) {\r\nafinfo = nf_get_afinfo(entry->pf);\r\nif (!afinfo || afinfo->reroute(skb, entry) < 0)\r\nverdict = NF_DROP;\r\n}\r\nif (verdict == NF_ACCEPT) {\r\nnext_hook:\r\nverdict = nf_iterate(&nf_hooks[entry->pf][entry->hook],\r\nskb, entry->hook,\r\nentry->indev, entry->outdev, &elem,\r\nentry->okfn, INT_MIN);\r\n}\r\nswitch (verdict & NF_VERDICT_MASK) {\r\ncase NF_ACCEPT:\r\ncase NF_STOP:\r\nlocal_bh_disable();\r\nentry->okfn(skb);\r\nlocal_bh_enable();\r\nbreak;\r\ncase NF_QUEUE:\r\nerr = nf_queue(skb, elem, entry->pf, entry->hook,\r\nentry->indev, entry->outdev, entry->okfn,\r\nverdict >> NF_VERDICT_QBITS);\r\nif (err < 0) {\r\nif (err == -ECANCELED)\r\ngoto next_hook;\r\nif (err == -ESRCH &&\r\n(verdict & NF_VERDICT_FLAG_QUEUE_BYPASS))\r\ngoto next_hook;\r\nkfree_skb(skb);\r\n}\r\nbreak;\r\ncase NF_STOLEN:\r\nbreak;\r\ndefault:\r\nkfree_skb(skb);\r\n}\r\nrcu_read_unlock();\r\nkfree(entry);\r\n}
