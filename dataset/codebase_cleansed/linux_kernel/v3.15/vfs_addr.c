static int v9fs_fid_readpage(struct p9_fid *fid, struct page *page)\r\n{\r\nint retval;\r\nloff_t offset;\r\nchar *buffer;\r\nstruct inode *inode;\r\ninode = page->mapping->host;\r\np9_debug(P9_DEBUG_VFS, "\n");\r\nBUG_ON(!PageLocked(page));\r\nretval = v9fs_readpage_from_fscache(inode, page);\r\nif (retval == 0)\r\nreturn retval;\r\nbuffer = kmap(page);\r\noffset = page_offset(page);\r\nretval = v9fs_fid_readn(fid, buffer, NULL, PAGE_CACHE_SIZE, offset);\r\nif (retval < 0) {\r\nv9fs_uncache_page(inode, page);\r\ngoto done;\r\n}\r\nmemset(buffer + retval, 0, PAGE_CACHE_SIZE - retval);\r\nflush_dcache_page(page);\r\nSetPageUptodate(page);\r\nv9fs_readpage_to_fscache(inode, page);\r\nretval = 0;\r\ndone:\r\nkunmap(page);\r\nunlock_page(page);\r\nreturn retval;\r\n}\r\nstatic int v9fs_vfs_readpage(struct file *filp, struct page *page)\r\n{\r\nreturn v9fs_fid_readpage(filp->private_data, page);\r\n}\r\nstatic int v9fs_vfs_readpages(struct file *filp, struct address_space *mapping,\r\nstruct list_head *pages, unsigned nr_pages)\r\n{\r\nint ret = 0;\r\nstruct inode *inode;\r\ninode = mapping->host;\r\np9_debug(P9_DEBUG_VFS, "inode: %p file: %p\n", inode, filp);\r\nret = v9fs_readpages_from_fscache(inode, mapping, pages, &nr_pages);\r\nif (ret == 0)\r\nreturn ret;\r\nret = read_cache_pages(mapping, pages, (void *)v9fs_vfs_readpage, filp);\r\np9_debug(P9_DEBUG_VFS, " = %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int v9fs_release_page(struct page *page, gfp_t gfp)\r\n{\r\nif (PagePrivate(page))\r\nreturn 0;\r\nreturn v9fs_fscache_release_page(page, gfp);\r\n}\r\nstatic void v9fs_invalidate_page(struct page *page, unsigned int offset,\r\nunsigned int length)\r\n{\r\nif (offset == 0 && length == PAGE_CACHE_SIZE)\r\nv9fs_fscache_invalidate_page(page);\r\n}\r\nstatic int v9fs_vfs_writepage_locked(struct page *page)\r\n{\r\nchar *buffer;\r\nint retval, len;\r\nloff_t offset, size;\r\nmm_segment_t old_fs;\r\nstruct v9fs_inode *v9inode;\r\nstruct inode *inode = page->mapping->host;\r\nv9inode = V9FS_I(inode);\r\nsize = i_size_read(inode);\r\nif (page->index == size >> PAGE_CACHE_SHIFT)\r\nlen = size & ~PAGE_CACHE_MASK;\r\nelse\r\nlen = PAGE_CACHE_SIZE;\r\nset_page_writeback(page);\r\nbuffer = kmap(page);\r\noffset = page_offset(page);\r\nold_fs = get_fs();\r\nset_fs(get_ds());\r\nBUG_ON(!v9inode->writeback_fid);\r\nretval = v9fs_file_write_internal(inode,\r\nv9inode->writeback_fid,\r\n(__force const char __user *)buffer,\r\nlen, &offset, 0);\r\nif (retval > 0)\r\nretval = 0;\r\nset_fs(old_fs);\r\nkunmap(page);\r\nend_page_writeback(page);\r\nreturn retval;\r\n}\r\nstatic int v9fs_vfs_writepage(struct page *page, struct writeback_control *wbc)\r\n{\r\nint retval;\r\np9_debug(P9_DEBUG_VFS, "page %p\n", page);\r\nretval = v9fs_vfs_writepage_locked(page);\r\nif (retval < 0) {\r\nif (retval == -EAGAIN) {\r\nredirty_page_for_writepage(wbc, page);\r\nretval = 0;\r\n} else {\r\nSetPageError(page);\r\nmapping_set_error(page->mapping, retval);\r\n}\r\n} else\r\nretval = 0;\r\nunlock_page(page);\r\nreturn retval;\r\n}\r\nstatic int v9fs_launder_page(struct page *page)\r\n{\r\nint retval;\r\nstruct inode *inode = page->mapping->host;\r\nv9fs_fscache_wait_on_page_write(inode, page);\r\nif (clear_page_dirty_for_io(page)) {\r\nretval = v9fs_vfs_writepage_locked(page);\r\nif (retval)\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nv9fs_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov,\r\nloff_t pos, unsigned long nr_segs)\r\n{\r\np9_debug(P9_DEBUG_VFS, "v9fs_direct_IO: v9fs_direct_IO (%s) off/no(%lld/%lu) EINVAL\n",\r\niocb->ki_filp->f_path.dentry->d_name.name,\r\n(long long)pos, nr_segs);\r\nreturn -EINVAL;\r\n}\r\nstatic int v9fs_write_begin(struct file *filp, struct address_space *mapping,\r\nloff_t pos, unsigned len, unsigned flags,\r\nstruct page **pagep, void **fsdata)\r\n{\r\nint retval = 0;\r\nstruct page *page;\r\nstruct v9fs_inode *v9inode;\r\npgoff_t index = pos >> PAGE_CACHE_SHIFT;\r\nstruct inode *inode = mapping->host;\r\np9_debug(P9_DEBUG_VFS, "filp %p, mapping %p\n", filp, mapping);\r\nv9inode = V9FS_I(inode);\r\nstart:\r\npage = grab_cache_page_write_begin(mapping, index, flags);\r\nif (!page) {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nBUG_ON(!v9inode->writeback_fid);\r\nif (PageUptodate(page))\r\ngoto out;\r\nif (len == PAGE_CACHE_SIZE)\r\ngoto out;\r\nretval = v9fs_fid_readpage(v9inode->writeback_fid, page);\r\npage_cache_release(page);\r\nif (!retval)\r\ngoto start;\r\nout:\r\n*pagep = page;\r\nreturn retval;\r\n}\r\nstatic int v9fs_write_end(struct file *filp, struct address_space *mapping,\r\nloff_t pos, unsigned len, unsigned copied,\r\nstruct page *page, void *fsdata)\r\n{\r\nloff_t last_pos = pos + copied;\r\nstruct inode *inode = page->mapping->host;\r\np9_debug(P9_DEBUG_VFS, "filp %p, mapping %p\n", filp, mapping);\r\nif (unlikely(copied < len)) {\r\nunsigned from = pos & (PAGE_CACHE_SIZE - 1);\r\nzero_user(page, from + copied, len - copied);\r\nflush_dcache_page(page);\r\n}\r\nif (!PageUptodate(page))\r\nSetPageUptodate(page);\r\nif (last_pos > inode->i_size) {\r\ninode_add_bytes(inode, last_pos - inode->i_size);\r\ni_size_write(inode, last_pos);\r\n}\r\nset_page_dirty(page);\r\nunlock_page(page);\r\npage_cache_release(page);\r\nreturn copied;\r\n}
