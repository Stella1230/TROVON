static int vfio_user_config_read(struct pci_dev *pdev, int offset,\r\n__le32 *val, int count)\r\n{\r\nint ret = -EINVAL;\r\nu32 tmp_val = 0;\r\nswitch (count) {\r\ncase 1:\r\n{\r\nu8 tmp;\r\nret = pci_user_read_config_byte(pdev, offset, &tmp);\r\ntmp_val = tmp;\r\nbreak;\r\n}\r\ncase 2:\r\n{\r\nu16 tmp;\r\nret = pci_user_read_config_word(pdev, offset, &tmp);\r\ntmp_val = tmp;\r\nbreak;\r\n}\r\ncase 4:\r\nret = pci_user_read_config_dword(pdev, offset, &tmp_val);\r\nbreak;\r\n}\r\n*val = cpu_to_le32(tmp_val);\r\nreturn pcibios_err_to_errno(ret);\r\n}\r\nstatic int vfio_user_config_write(struct pci_dev *pdev, int offset,\r\n__le32 val, int count)\r\n{\r\nint ret = -EINVAL;\r\nu32 tmp_val = le32_to_cpu(val);\r\nswitch (count) {\r\ncase 1:\r\nret = pci_user_write_config_byte(pdev, offset, tmp_val);\r\nbreak;\r\ncase 2:\r\nret = pci_user_write_config_word(pdev, offset, tmp_val);\r\nbreak;\r\ncase 4:\r\nret = pci_user_write_config_dword(pdev, offset, tmp_val);\r\nbreak;\r\n}\r\nreturn pcibios_err_to_errno(ret);\r\n}\r\nstatic int vfio_default_config_read(struct vfio_pci_device *vdev, int pos,\r\nint count, struct perm_bits *perm,\r\nint offset, __le32 *val)\r\n{\r\n__le32 virt = 0;\r\nmemcpy(val, vdev->vconfig + pos, count);\r\nmemcpy(&virt, perm->virt + offset, count);\r\nif (cpu_to_le32(~0U >> (32 - (count * 8))) != virt) {\r\nstruct pci_dev *pdev = vdev->pdev;\r\n__le32 phys_val = 0;\r\nint ret;\r\nret = vfio_user_config_read(pdev, pos, &phys_val, count);\r\nif (ret)\r\nreturn ret;\r\n*val = (phys_val & ~virt) | (*val & virt);\r\n}\r\nreturn count;\r\n}\r\nstatic int vfio_default_config_write(struct vfio_pci_device *vdev, int pos,\r\nint count, struct perm_bits *perm,\r\nint offset, __le32 val)\r\n{\r\n__le32 virt = 0, write = 0;\r\nmemcpy(&write, perm->write + offset, count);\r\nif (!write)\r\nreturn count;\r\nmemcpy(&virt, perm->virt + offset, count);\r\nif (write & virt) {\r\n__le32 virt_val = 0;\r\nmemcpy(&virt_val, vdev->vconfig + pos, count);\r\nvirt_val &= ~(write & virt);\r\nvirt_val |= (val & (write & virt));\r\nmemcpy(vdev->vconfig + pos, &virt_val, count);\r\n}\r\nif (write & ~virt) {\r\nstruct pci_dev *pdev = vdev->pdev;\r\n__le32 phys_val = 0;\r\nint ret;\r\nret = vfio_user_config_read(pdev, pos, &phys_val, count);\r\nif (ret)\r\nreturn ret;\r\nphys_val &= ~(write & ~virt);\r\nphys_val |= (val & (write & ~virt));\r\nret = vfio_user_config_write(pdev, pos, phys_val, count);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn count;\r\n}\r\nstatic int vfio_direct_config_read(struct vfio_pci_device *vdev, int pos,\r\nint count, struct perm_bits *perm,\r\nint offset, __le32 *val)\r\n{\r\nint ret;\r\nret = vfio_user_config_read(vdev->pdev, pos, val, count);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nif (pos >= PCI_CFG_SPACE_SIZE) {\r\nif (offset < 4)\r\nmemcpy(val, vdev->vconfig + pos, count);\r\n} else if (pos >= PCI_STD_HEADER_SIZEOF) {\r\nif (offset == PCI_CAP_LIST_ID && count > 1)\r\nmemcpy(val, vdev->vconfig + pos,\r\nmin(PCI_CAP_FLAGS, count));\r\nelse if (offset == PCI_CAP_LIST_NEXT)\r\nmemcpy(val, vdev->vconfig + pos, 1);\r\n}\r\nreturn count;\r\n}\r\nstatic int vfio_raw_config_write(struct vfio_pci_device *vdev, int pos,\r\nint count, struct perm_bits *perm,\r\nint offset, __le32 val)\r\n{\r\nint ret;\r\nret = vfio_user_config_write(vdev->pdev, pos, val, count);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic int vfio_raw_config_read(struct vfio_pci_device *vdev, int pos,\r\nint count, struct perm_bits *perm,\r\nint offset, __le32 *val)\r\n{\r\nint ret;\r\nret = vfio_user_config_read(vdev->pdev, pos, val, count);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nreturn count;\r\n}\r\nstatic void free_perm_bits(struct perm_bits *perm)\r\n{\r\nkfree(perm->virt);\r\nkfree(perm->write);\r\nperm->virt = NULL;\r\nperm->write = NULL;\r\n}\r\nstatic int alloc_perm_bits(struct perm_bits *perm, int size)\r\n{\r\nsize = round_up(size, 4);\r\nperm->virt = kzalloc(size, GFP_KERNEL);\r\nperm->write = kzalloc(size, GFP_KERNEL);\r\nif (!perm->virt || !perm->write) {\r\nfree_perm_bits(perm);\r\nreturn -ENOMEM;\r\n}\r\nperm->readfn = vfio_default_config_read;\r\nperm->writefn = vfio_default_config_write;\r\nreturn 0;\r\n}\r\nstatic inline void p_setb(struct perm_bits *p, int off, u8 virt, u8 write)\r\n{\r\np->virt[off] = virt;\r\np->write[off] = write;\r\n}\r\nstatic inline void p_setw(struct perm_bits *p, int off, u16 virt, u16 write)\r\n{\r\n*(__le16 *)(&p->virt[off]) = cpu_to_le16(virt);\r\n*(__le16 *)(&p->write[off]) = cpu_to_le16(write);\r\n}\r\nstatic inline void p_setd(struct perm_bits *p, int off, u32 virt, u32 write)\r\n{\r\n*(__le32 *)(&p->virt[off]) = cpu_to_le32(virt);\r\n*(__le32 *)(&p->write[off]) = cpu_to_le32(write);\r\n}\r\nstatic void vfio_bar_restore(struct vfio_pci_device *vdev)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nu32 *rbar = vdev->rbar;\r\nint i;\r\nif (pdev->is_virtfn)\r\nreturn;\r\npr_info("%s: %s reset recovery - restoring bars\n",\r\n__func__, dev_name(&pdev->dev));\r\nfor (i = PCI_BASE_ADDRESS_0; i <= PCI_BASE_ADDRESS_5; i += 4, rbar++)\r\npci_user_write_config_dword(pdev, i, *rbar);\r\npci_user_write_config_dword(pdev, PCI_ROM_ADDRESS, *rbar);\r\n}\r\nstatic __le32 vfio_generate_bar_flags(struct pci_dev *pdev, int bar)\r\n{\r\nunsigned long flags = pci_resource_flags(pdev, bar);\r\nu32 val;\r\nif (flags & IORESOURCE_IO)\r\nreturn cpu_to_le32(PCI_BASE_ADDRESS_SPACE_IO);\r\nval = PCI_BASE_ADDRESS_SPACE_MEMORY;\r\nif (flags & IORESOURCE_PREFETCH)\r\nval |= PCI_BASE_ADDRESS_MEM_PREFETCH;\r\nif (flags & IORESOURCE_MEM_64)\r\nval |= PCI_BASE_ADDRESS_MEM_TYPE_64;\r\nreturn cpu_to_le32(val);\r\n}\r\nstatic void vfio_bar_fixup(struct vfio_pci_device *vdev)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nint i;\r\n__le32 *bar;\r\nu64 mask;\r\nbar = (__le32 *)&vdev->vconfig[PCI_BASE_ADDRESS_0];\r\nfor (i = PCI_STD_RESOURCES; i <= PCI_STD_RESOURCE_END; i++, bar++) {\r\nif (!pci_resource_start(pdev, i)) {\r\n*bar = 0;\r\ncontinue;\r\n}\r\nmask = ~(pci_resource_len(pdev, i) - 1);\r\n*bar &= cpu_to_le32((u32)mask);\r\n*bar |= vfio_generate_bar_flags(pdev, i);\r\nif (*bar & cpu_to_le32(PCI_BASE_ADDRESS_MEM_TYPE_64)) {\r\nbar++;\r\n*bar &= cpu_to_le32((u32)(mask >> 32));\r\ni++;\r\n}\r\n}\r\nbar = (__le32 *)&vdev->vconfig[PCI_ROM_ADDRESS];\r\nif (pci_resource_start(pdev, PCI_ROM_RESOURCE)) {\r\nmask = ~(pci_resource_len(pdev, PCI_ROM_RESOURCE) - 1);\r\nmask |= PCI_ROM_ADDRESS_ENABLE;\r\n*bar &= cpu_to_le32((u32)mask);\r\n} else\r\n*bar = 0;\r\nvdev->bardirty = false;\r\n}\r\nstatic int vfio_basic_config_read(struct vfio_pci_device *vdev, int pos,\r\nint count, struct perm_bits *perm,\r\nint offset, __le32 *val)\r\n{\r\nif (is_bar(offset))\r\nvfio_bar_fixup(vdev);\r\ncount = vfio_default_config_read(vdev, pos, count, perm, offset, val);\r\nif (offset == PCI_COMMAND && vdev->pdev->is_virtfn) {\r\nu16 cmd = le16_to_cpu(*(__le16 *)&vdev->vconfig[PCI_COMMAND]);\r\nu32 tmp_val = le32_to_cpu(*val);\r\ntmp_val |= cmd & PCI_COMMAND_MEMORY;\r\n*val = cpu_to_le32(tmp_val);\r\n}\r\nreturn count;\r\n}\r\nstatic int vfio_basic_config_write(struct vfio_pci_device *vdev, int pos,\r\nint count, struct perm_bits *perm,\r\nint offset, __le32 val)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\n__le16 *virt_cmd;\r\nu16 new_cmd = 0;\r\nint ret;\r\nvirt_cmd = (__le16 *)&vdev->vconfig[PCI_COMMAND];\r\nif (offset == PCI_COMMAND) {\r\nbool phys_mem, virt_mem, new_mem, phys_io, virt_io, new_io;\r\nu16 phys_cmd;\r\nret = pci_user_read_config_word(pdev, PCI_COMMAND, &phys_cmd);\r\nif (ret)\r\nreturn ret;\r\nnew_cmd = le32_to_cpu(val);\r\nphys_mem = !!(phys_cmd & PCI_COMMAND_MEMORY);\r\nvirt_mem = !!(le16_to_cpu(*virt_cmd) & PCI_COMMAND_MEMORY);\r\nnew_mem = !!(new_cmd & PCI_COMMAND_MEMORY);\r\nphys_io = !!(phys_cmd & PCI_COMMAND_IO);\r\nvirt_io = !!(le16_to_cpu(*virt_cmd) & PCI_COMMAND_IO);\r\nnew_io = !!(new_cmd & PCI_COMMAND_IO);\r\nif ((new_mem && virt_mem && !phys_mem) ||\r\n(new_io && virt_io && !phys_io))\r\nvfio_bar_restore(vdev);\r\n}\r\ncount = vfio_default_config_write(vdev, pos, count, perm, offset, val);\r\nif (count < 0)\r\nreturn count;\r\nif (offset == PCI_COMMAND) {\r\nu16 mask = PCI_COMMAND_MEMORY | PCI_COMMAND_IO;\r\n*virt_cmd &= cpu_to_le16(~mask);\r\n*virt_cmd |= cpu_to_le16(new_cmd & mask);\r\n}\r\nif (offset >= PCI_COMMAND && offset <= PCI_COMMAND + 1) {\r\nbool virt_intx_disable;\r\nvirt_intx_disable = !!(le16_to_cpu(*virt_cmd) &\r\nPCI_COMMAND_INTX_DISABLE);\r\nif (virt_intx_disable && !vdev->virq_disabled) {\r\nvdev->virq_disabled = true;\r\nvfio_pci_intx_mask(vdev);\r\n} else if (!virt_intx_disable && vdev->virq_disabled) {\r\nvdev->virq_disabled = false;\r\nvfio_pci_intx_unmask(vdev);\r\n}\r\n}\r\nif (is_bar(offset))\r\nvdev->bardirty = true;\r\nreturn count;\r\n}\r\nstatic int __init init_pci_cap_basic_perm(struct perm_bits *perm)\r\n{\r\nif (alloc_perm_bits(perm, PCI_STD_HEADER_SIZEOF))\r\nreturn -ENOMEM;\r\nperm->readfn = vfio_basic_config_read;\r\nperm->writefn = vfio_basic_config_write;\r\np_setw(perm, PCI_VENDOR_ID, (u16)ALL_VIRT, NO_WRITE);\r\np_setw(perm, PCI_DEVICE_ID, (u16)ALL_VIRT, NO_WRITE);\r\np_setw(perm, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE, (u16)ALL_WRITE);\r\np_setw(perm, PCI_STATUS, PCI_STATUS_CAP_LIST, NO_WRITE);\r\np_setb(perm, PCI_CACHE_LINE_SIZE, NO_VIRT, (u8)ALL_WRITE);\r\np_setb(perm, PCI_LATENCY_TIMER, NO_VIRT, (u8)ALL_WRITE);\r\np_setb(perm, PCI_BIST, NO_VIRT, (u8)ALL_WRITE);\r\np_setd(perm, PCI_BASE_ADDRESS_0, ALL_VIRT, ALL_WRITE);\r\np_setd(perm, PCI_BASE_ADDRESS_1, ALL_VIRT, ALL_WRITE);\r\np_setd(perm, PCI_BASE_ADDRESS_2, ALL_VIRT, ALL_WRITE);\r\np_setd(perm, PCI_BASE_ADDRESS_3, ALL_VIRT, ALL_WRITE);\r\np_setd(perm, PCI_BASE_ADDRESS_4, ALL_VIRT, ALL_WRITE);\r\np_setd(perm, PCI_BASE_ADDRESS_5, ALL_VIRT, ALL_WRITE);\r\np_setd(perm, PCI_ROM_ADDRESS, ALL_VIRT, ALL_WRITE);\r\np_setb(perm, PCI_CAPABILITY_LIST, (u8)ALL_VIRT, NO_WRITE);\r\np_setb(perm, PCI_INTERRUPT_LINE, (u8)ALL_VIRT, (u8)ALL_WRITE);\r\nreturn 0;\r\n}\r\nstatic int vfio_pm_config_write(struct vfio_pci_device *vdev, int pos,\r\nint count, struct perm_bits *perm,\r\nint offset, __le32 val)\r\n{\r\ncount = vfio_default_config_write(vdev, pos, count, perm, offset, val);\r\nif (count < 0)\r\nreturn count;\r\nif (offset == PCI_PM_CTRL) {\r\npci_power_t state;\r\nswitch (le32_to_cpu(val) & PCI_PM_CTRL_STATE_MASK) {\r\ncase 0:\r\nstate = PCI_D0;\r\nbreak;\r\ncase 1:\r\nstate = PCI_D1;\r\nbreak;\r\ncase 2:\r\nstate = PCI_D2;\r\nbreak;\r\ncase 3:\r\nstate = PCI_D3hot;\r\nbreak;\r\n}\r\npci_set_power_state(vdev->pdev, state);\r\n}\r\nreturn count;\r\n}\r\nstatic int __init init_pci_cap_pm_perm(struct perm_bits *perm)\r\n{\r\nif (alloc_perm_bits(perm, pci_cap_length[PCI_CAP_ID_PM]))\r\nreturn -ENOMEM;\r\nperm->writefn = vfio_pm_config_write;\r\np_setb(perm, PCI_CAP_LIST_NEXT, (u8)ALL_VIRT, NO_WRITE);\r\np_setd(perm, PCI_PM_CTRL, NO_VIRT, ~PCI_PM_CTRL_STATE_MASK);\r\nreturn 0;\r\n}\r\nstatic int __init init_pci_cap_pcix_perm(struct perm_bits *perm)\r\n{\r\nif (alloc_perm_bits(perm, PCI_CAP_PCIX_SIZEOF_V2))\r\nreturn -ENOMEM;\r\np_setb(perm, PCI_CAP_LIST_NEXT, (u8)ALL_VIRT, NO_WRITE);\r\np_setw(perm, PCI_X_CMD, NO_VIRT, (u16)ALL_WRITE);\r\np_setd(perm, PCI_X_ECC_CSR, NO_VIRT, ALL_WRITE);\r\nreturn 0;\r\n}\r\nstatic int __init init_pci_cap_exp_perm(struct perm_bits *perm)\r\n{\r\nif (alloc_perm_bits(perm, PCI_CAP_EXP_ENDPOINT_SIZEOF_V2))\r\nreturn -ENOMEM;\r\np_setb(perm, PCI_CAP_LIST_NEXT, (u8)ALL_VIRT, NO_WRITE);\r\np_setw(perm, PCI_EXP_DEVCTL, NO_VIRT, ~PCI_EXP_DEVCTL_PHANTOM);\r\np_setw(perm, PCI_EXP_DEVCTL2, NO_VIRT, ~PCI_EXP_DEVCTL2_ARI);\r\nreturn 0;\r\n}\r\nstatic int __init init_pci_cap_af_perm(struct perm_bits *perm)\r\n{\r\nif (alloc_perm_bits(perm, pci_cap_length[PCI_CAP_ID_AF]))\r\nreturn -ENOMEM;\r\np_setb(perm, PCI_CAP_LIST_NEXT, (u8)ALL_VIRT, NO_WRITE);\r\np_setb(perm, PCI_AF_CTRL, NO_VIRT, PCI_AF_CTRL_FLR);\r\nreturn 0;\r\n}\r\nstatic int __init init_pci_ext_cap_err_perm(struct perm_bits *perm)\r\n{\r\nu32 mask;\r\nif (alloc_perm_bits(perm, pci_ext_cap_length[PCI_EXT_CAP_ID_ERR]))\r\nreturn -ENOMEM;\r\np_setd(perm, 0, ALL_VIRT, NO_WRITE);\r\nmask = PCI_ERR_UNC_TRAIN |\r\nPCI_ERR_UNC_DLP |\r\nPCI_ERR_UNC_SURPDN |\r\nPCI_ERR_UNC_POISON_TLP |\r\nPCI_ERR_UNC_FCP |\r\nPCI_ERR_UNC_COMP_TIME |\r\nPCI_ERR_UNC_COMP_ABORT |\r\nPCI_ERR_UNC_UNX_COMP |\r\nPCI_ERR_UNC_RX_OVER |\r\nPCI_ERR_UNC_MALF_TLP |\r\nPCI_ERR_UNC_ECRC |\r\nPCI_ERR_UNC_UNSUP |\r\nPCI_ERR_UNC_ACSV |\r\nPCI_ERR_UNC_INTN |\r\nPCI_ERR_UNC_MCBTLP |\r\nPCI_ERR_UNC_ATOMEG |\r\nPCI_ERR_UNC_TLPPRE;\r\np_setd(perm, PCI_ERR_UNCOR_STATUS, NO_VIRT, mask);\r\np_setd(perm, PCI_ERR_UNCOR_MASK, NO_VIRT, mask);\r\np_setd(perm, PCI_ERR_UNCOR_SEVER, NO_VIRT, mask);\r\nmask = PCI_ERR_COR_RCVR |\r\nPCI_ERR_COR_BAD_TLP |\r\nPCI_ERR_COR_BAD_DLLP |\r\nPCI_ERR_COR_REP_ROLL |\r\nPCI_ERR_COR_REP_TIMER |\r\nPCI_ERR_COR_ADV_NFAT |\r\nPCI_ERR_COR_INTERNAL |\r\nPCI_ERR_COR_LOG_OVER;\r\np_setd(perm, PCI_ERR_COR_STATUS, NO_VIRT, mask);\r\np_setd(perm, PCI_ERR_COR_MASK, NO_VIRT, mask);\r\nmask = PCI_ERR_CAP_ECRC_GENE |\r\nPCI_ERR_CAP_ECRC_CHKE;\r\np_setd(perm, PCI_ERR_CAP, NO_VIRT, mask);\r\nreturn 0;\r\n}\r\nstatic int __init init_pci_ext_cap_pwr_perm(struct perm_bits *perm)\r\n{\r\nif (alloc_perm_bits(perm, pci_ext_cap_length[PCI_EXT_CAP_ID_PWR]))\r\nreturn -ENOMEM;\r\np_setd(perm, 0, ALL_VIRT, NO_WRITE);\r\np_setb(perm, PCI_PWR_DATA, NO_VIRT, (u8)ALL_WRITE);\r\nreturn 0;\r\n}\r\nvoid vfio_pci_uninit_perm_bits(void)\r\n{\r\nfree_perm_bits(&cap_perms[PCI_CAP_ID_BASIC]);\r\nfree_perm_bits(&cap_perms[PCI_CAP_ID_PM]);\r\nfree_perm_bits(&cap_perms[PCI_CAP_ID_PCIX]);\r\nfree_perm_bits(&cap_perms[PCI_CAP_ID_EXP]);\r\nfree_perm_bits(&cap_perms[PCI_CAP_ID_AF]);\r\nfree_perm_bits(&ecap_perms[PCI_EXT_CAP_ID_ERR]);\r\nfree_perm_bits(&ecap_perms[PCI_EXT_CAP_ID_PWR]);\r\n}\r\nint __init vfio_pci_init_perm_bits(void)\r\n{\r\nint ret;\r\nret = init_pci_cap_basic_perm(&cap_perms[PCI_CAP_ID_BASIC]);\r\nret |= init_pci_cap_pm_perm(&cap_perms[PCI_CAP_ID_PM]);\r\ncap_perms[PCI_CAP_ID_VPD].writefn = vfio_raw_config_write;\r\nret |= init_pci_cap_pcix_perm(&cap_perms[PCI_CAP_ID_PCIX]);\r\ncap_perms[PCI_CAP_ID_VNDR].writefn = vfio_raw_config_write;\r\nret |= init_pci_cap_exp_perm(&cap_perms[PCI_CAP_ID_EXP]);\r\nret |= init_pci_cap_af_perm(&cap_perms[PCI_CAP_ID_AF]);\r\nret |= init_pci_ext_cap_err_perm(&ecap_perms[PCI_EXT_CAP_ID_ERR]);\r\nret |= init_pci_ext_cap_pwr_perm(&ecap_perms[PCI_EXT_CAP_ID_PWR]);\r\necap_perms[PCI_EXT_CAP_ID_VNDR].writefn = vfio_raw_config_write;\r\nif (ret)\r\nvfio_pci_uninit_perm_bits();\r\nreturn ret;\r\n}\r\nstatic int vfio_find_cap_start(struct vfio_pci_device *vdev, int pos)\r\n{\r\nu8 cap;\r\nint base = (pos >= PCI_CFG_SPACE_SIZE) ? PCI_CFG_SPACE_SIZE :\r\nPCI_STD_HEADER_SIZEOF;\r\ncap = vdev->pci_config_map[pos];\r\nif (cap == PCI_CAP_ID_BASIC)\r\nreturn 0;\r\nwhile (pos - 1 >= base && vdev->pci_config_map[pos - 1] == cap)\r\npos--;\r\nreturn pos;\r\n}\r\nstatic int vfio_msi_config_read(struct vfio_pci_device *vdev, int pos,\r\nint count, struct perm_bits *perm,\r\nint offset, __le32 *val)\r\n{\r\nif (offset <= PCI_MSI_FLAGS && offset + count >= PCI_MSI_FLAGS) {\r\n__le16 *flags;\r\nint start;\r\nstart = vfio_find_cap_start(vdev, pos);\r\nflags = (__le16 *)&vdev->vconfig[start];\r\n*flags &= cpu_to_le16(~PCI_MSI_FLAGS_QMASK);\r\n*flags |= cpu_to_le16(vdev->msi_qmax << 1);\r\n}\r\nreturn vfio_default_config_read(vdev, pos, count, perm, offset, val);\r\n}\r\nstatic int vfio_msi_config_write(struct vfio_pci_device *vdev, int pos,\r\nint count, struct perm_bits *perm,\r\nint offset, __le32 val)\r\n{\r\ncount = vfio_default_config_write(vdev, pos, count, perm, offset, val);\r\nif (count < 0)\r\nreturn count;\r\nif (offset <= PCI_MSI_FLAGS && offset + count >= PCI_MSI_FLAGS) {\r\n__le16 *pflags;\r\nu16 flags;\r\nint start, ret;\r\nstart = vfio_find_cap_start(vdev, pos);\r\npflags = (__le16 *)&vdev->vconfig[start + PCI_MSI_FLAGS];\r\nflags = le16_to_cpu(*pflags);\r\nif (!is_msi(vdev))\r\nflags &= ~PCI_MSI_FLAGS_ENABLE;\r\nif ((flags & PCI_MSI_FLAGS_QSIZE) >> 4 > vdev->msi_qmax) {\r\nflags &= ~PCI_MSI_FLAGS_QSIZE;\r\nflags |= vdev->msi_qmax << 4;\r\n}\r\n*pflags = cpu_to_le16(flags);\r\nret = pci_user_write_config_word(vdev->pdev,\r\nstart + PCI_MSI_FLAGS,\r\nflags);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\n}\r\nreturn count;\r\n}\r\nstatic int init_pci_cap_msi_perm(struct perm_bits *perm, int len, u16 flags)\r\n{\r\nif (alloc_perm_bits(perm, len))\r\nreturn -ENOMEM;\r\nperm->readfn = vfio_msi_config_read;\r\nperm->writefn = vfio_msi_config_write;\r\np_setb(perm, PCI_CAP_LIST_NEXT, (u8)ALL_VIRT, NO_WRITE);\r\np_setb(perm, PCI_MSI_FLAGS, (u8)ALL_VIRT, (u8)ALL_WRITE);\r\np_setd(perm, PCI_MSI_ADDRESS_LO, ALL_VIRT, ALL_WRITE);\r\nif (flags & PCI_MSI_FLAGS_64BIT) {\r\np_setd(perm, PCI_MSI_ADDRESS_HI, ALL_VIRT, ALL_WRITE);\r\np_setw(perm, PCI_MSI_DATA_64, (u16)ALL_VIRT, (u16)ALL_WRITE);\r\nif (flags & PCI_MSI_FLAGS_MASKBIT) {\r\np_setd(perm, PCI_MSI_MASK_64, NO_VIRT, ALL_WRITE);\r\np_setd(perm, PCI_MSI_PENDING_64, NO_VIRT, ALL_WRITE);\r\n}\r\n} else {\r\np_setw(perm, PCI_MSI_DATA_32, (u16)ALL_VIRT, (u16)ALL_WRITE);\r\nif (flags & PCI_MSI_FLAGS_MASKBIT) {\r\np_setd(perm, PCI_MSI_MASK_32, NO_VIRT, ALL_WRITE);\r\np_setd(perm, PCI_MSI_PENDING_32, NO_VIRT, ALL_WRITE);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vfio_msi_cap_len(struct vfio_pci_device *vdev, u8 pos)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nint len, ret;\r\nu16 flags;\r\nret = pci_read_config_word(pdev, pos + PCI_MSI_FLAGS, &flags);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nlen = 10;\r\nif (flags & PCI_MSI_FLAGS_64BIT)\r\nlen += 4;\r\nif (flags & PCI_MSI_FLAGS_MASKBIT)\r\nlen += 10;\r\nif (vdev->msi_perm)\r\nreturn len;\r\nvdev->msi_perm = kmalloc(sizeof(struct perm_bits), GFP_KERNEL);\r\nif (!vdev->msi_perm)\r\nreturn -ENOMEM;\r\nret = init_pci_cap_msi_perm(vdev->msi_perm, len, flags);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic int vfio_vc_cap_len(struct vfio_pci_device *vdev, u16 pos)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nu32 tmp;\r\nint ret, evcc, phases, vc_arb;\r\nint len = PCI_CAP_VC_BASE_SIZEOF;\r\nret = pci_read_config_dword(pdev, pos + PCI_VC_PORT_CAP1, &tmp);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nevcc = tmp & PCI_VC_CAP1_EVCC;\r\nret = pci_read_config_dword(pdev, pos + PCI_VC_PORT_CAP2, &tmp);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nif (tmp & PCI_VC_CAP2_128_PHASE)\r\nphases = 128;\r\nelse if (tmp & PCI_VC_CAP2_64_PHASE)\r\nphases = 64;\r\nelse if (tmp & PCI_VC_CAP2_32_PHASE)\r\nphases = 32;\r\nelse\r\nphases = 0;\r\nvc_arb = phases * 4;\r\nlen += (1 + evcc) * PCI_CAP_VC_PER_VC_SIZEOF;\r\nif (vc_arb) {\r\nlen = round_up(len, 16);\r\nlen += vc_arb / 8;\r\n}\r\nreturn len;\r\n}\r\nstatic int vfio_cap_len(struct vfio_pci_device *vdev, u8 cap, u8 pos)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nu32 dword;\r\nu16 word;\r\nu8 byte;\r\nint ret;\r\nswitch (cap) {\r\ncase PCI_CAP_ID_MSI:\r\nreturn vfio_msi_cap_len(vdev, pos);\r\ncase PCI_CAP_ID_PCIX:\r\nret = pci_read_config_word(pdev, pos + PCI_X_CMD, &word);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nif (PCI_X_CMD_VERSION(word)) {\r\npci_read_config_dword(pdev, PCI_CFG_SPACE_SIZE, &dword);\r\nvdev->extended_caps = (dword != 0);\r\nreturn PCI_CAP_PCIX_SIZEOF_V2;\r\n} else\r\nreturn PCI_CAP_PCIX_SIZEOF_V0;\r\ncase PCI_CAP_ID_VNDR:\r\nret = pci_read_config_byte(pdev, pos + PCI_CAP_FLAGS, &byte);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nreturn byte;\r\ncase PCI_CAP_ID_EXP:\r\npci_read_config_dword(pdev, PCI_CFG_SPACE_SIZE, &dword);\r\nvdev->extended_caps = (dword != 0);\r\nif ((pcie_caps_reg(pdev) & PCI_EXP_FLAGS_VERS) == 1)\r\nreturn PCI_CAP_EXP_ENDPOINT_SIZEOF_V1;\r\nelse\r\nreturn PCI_CAP_EXP_ENDPOINT_SIZEOF_V2;\r\ncase PCI_CAP_ID_HT:\r\nret = pci_read_config_byte(pdev, pos + 3, &byte);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nreturn (byte & HT_3BIT_CAP_MASK) ?\r\nHT_CAP_SIZEOF_SHORT : HT_CAP_SIZEOF_LONG;\r\ncase PCI_CAP_ID_SATA:\r\nret = pci_read_config_byte(pdev, pos + PCI_SATA_REGS, &byte);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nbyte &= PCI_SATA_REGS_MASK;\r\nif (byte == PCI_SATA_REGS_INLINE)\r\nreturn PCI_SATA_SIZEOF_LONG;\r\nelse\r\nreturn PCI_SATA_SIZEOF_SHORT;\r\ndefault:\r\npr_warn("%s: %s unknown length for pci cap 0x%x@0x%x\n",\r\ndev_name(&pdev->dev), __func__, cap, pos);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vfio_ext_cap_len(struct vfio_pci_device *vdev, u16 ecap, u16 epos)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nu8 byte;\r\nu32 dword;\r\nint ret;\r\nswitch (ecap) {\r\ncase PCI_EXT_CAP_ID_VNDR:\r\nret = pci_read_config_dword(pdev, epos + PCI_VSEC_HDR, &dword);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nreturn dword >> PCI_VSEC_HDR_LEN_SHIFT;\r\ncase PCI_EXT_CAP_ID_VC:\r\ncase PCI_EXT_CAP_ID_VC9:\r\ncase PCI_EXT_CAP_ID_MFVC:\r\nreturn vfio_vc_cap_len(vdev, epos);\r\ncase PCI_EXT_CAP_ID_ACS:\r\nret = pci_read_config_byte(pdev, epos + PCI_ACS_CAP, &byte);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nif (byte & PCI_ACS_EC) {\r\nint bits;\r\nret = pci_read_config_byte(pdev,\r\nepos + PCI_ACS_EGRESS_BITS,\r\n&byte);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nbits = byte ? round_up(byte, 32) : 256;\r\nreturn 8 + (bits / 8);\r\n}\r\nreturn 8;\r\ncase PCI_EXT_CAP_ID_REBAR:\r\nret = pci_read_config_byte(pdev, epos + PCI_REBAR_CTRL, &byte);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nbyte &= PCI_REBAR_CTRL_NBAR_MASK;\r\nbyte >>= PCI_REBAR_CTRL_NBAR_SHIFT;\r\nreturn 4 + (byte * 8);\r\ncase PCI_EXT_CAP_ID_DPA:\r\nret = pci_read_config_byte(pdev, epos + PCI_DPA_CAP, &byte);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nbyte &= PCI_DPA_CAP_SUBSTATE_MASK;\r\nbyte = round_up(byte + 1, 4);\r\nreturn PCI_DPA_BASE_SIZEOF + byte;\r\ncase PCI_EXT_CAP_ID_TPH:\r\nret = pci_read_config_dword(pdev, epos + PCI_TPH_CAP, &dword);\r\nif (ret)\r\nreturn pcibios_err_to_errno(ret);\r\nif ((dword & PCI_TPH_CAP_LOC_MASK) == PCI_TPH_LOC_CAP) {\r\nint sts;\r\nsts = byte & PCI_TPH_CAP_ST_MASK;\r\nsts >>= PCI_TPH_CAP_ST_SHIFT;\r\nreturn PCI_TPH_BASE_SIZEOF + round_up(sts * 2, 4);\r\n}\r\nreturn PCI_TPH_BASE_SIZEOF;\r\ndefault:\r\npr_warn("%s: %s unknown length for pci ecap 0x%x@0x%x\n",\r\ndev_name(&pdev->dev), __func__, ecap, epos);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vfio_fill_vconfig_bytes(struct vfio_pci_device *vdev,\r\nint offset, int size)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nint ret = 0;\r\nwhile (size) {\r\nint filled;\r\nif (size >= 4 && !(offset % 4)) {\r\n__le32 *dwordp = (__le32 *)&vdev->vconfig[offset];\r\nu32 dword;\r\nret = pci_read_config_dword(pdev, offset, &dword);\r\nif (ret)\r\nreturn ret;\r\n*dwordp = cpu_to_le32(dword);\r\nfilled = 4;\r\n} else if (size >= 2 && !(offset % 2)) {\r\n__le16 *wordp = (__le16 *)&vdev->vconfig[offset];\r\nu16 word;\r\nret = pci_read_config_word(pdev, offset, &word);\r\nif (ret)\r\nreturn ret;\r\n*wordp = cpu_to_le16(word);\r\nfilled = 2;\r\n} else {\r\nu8 *byte = &vdev->vconfig[offset];\r\nret = pci_read_config_byte(pdev, offset, byte);\r\nif (ret)\r\nreturn ret;\r\nfilled = 1;\r\n}\r\noffset += filled;\r\nsize -= filled;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vfio_cap_init(struct vfio_pci_device *vdev)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nu8 *map = vdev->pci_config_map;\r\nu16 status;\r\nu8 pos, *prev, cap;\r\nint loops, ret, caps = 0;\r\nret = pci_read_config_word(pdev, PCI_STATUS, &status);\r\nif (ret)\r\nreturn ret;\r\nif (!(status & PCI_STATUS_CAP_LIST))\r\nreturn 0;\r\nret = pci_read_config_byte(pdev, PCI_CAPABILITY_LIST, &pos);\r\nif (ret)\r\nreturn ret;\r\nprev = &vdev->vconfig[PCI_CAPABILITY_LIST];\r\nloops = (PCI_CFG_SPACE_SIZE - PCI_STD_HEADER_SIZEOF) / PCI_CAP_SIZEOF;\r\nwhile (pos && loops--) {\r\nu8 next;\r\nint i, len = 0;\r\nret = pci_read_config_byte(pdev, pos, &cap);\r\nif (ret)\r\nreturn ret;\r\nret = pci_read_config_byte(pdev,\r\npos + PCI_CAP_LIST_NEXT, &next);\r\nif (ret)\r\nreturn ret;\r\nif (cap <= PCI_CAP_ID_MAX) {\r\nlen = pci_cap_length[cap];\r\nif (len == 0xFF) {\r\nlen = vfio_cap_len(vdev, cap, pos);\r\nif (len < 0)\r\nreturn len;\r\n}\r\n}\r\nif (!len) {\r\npr_info("%s: %s hiding cap 0x%x\n",\r\n__func__, dev_name(&pdev->dev), cap);\r\n*prev = next;\r\npos = next;\r\ncontinue;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nif (likely(map[pos + i] == PCI_CAP_ID_INVALID))\r\ncontinue;\r\npr_warn("%s: %s pci config conflict @0x%x, was cap 0x%x now cap 0x%x\n",\r\n__func__, dev_name(&pdev->dev),\r\npos + i, map[pos + i], cap);\r\n}\r\nmemset(map + pos, cap, len);\r\nret = vfio_fill_vconfig_bytes(vdev, pos, len);\r\nif (ret)\r\nreturn ret;\r\nprev = &vdev->vconfig[pos + PCI_CAP_LIST_NEXT];\r\npos = next;\r\ncaps++;\r\n}\r\nif (!caps) {\r\n__le16 *vstatus = (__le16 *)&vdev->vconfig[PCI_STATUS];\r\n*vstatus &= ~cpu_to_le16(PCI_STATUS_CAP_LIST);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vfio_ecap_init(struct vfio_pci_device *vdev)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nu8 *map = vdev->pci_config_map;\r\nu16 epos;\r\n__le32 *prev = NULL;\r\nint loops, ret, ecaps = 0;\r\nif (!vdev->extended_caps)\r\nreturn 0;\r\nepos = PCI_CFG_SPACE_SIZE;\r\nloops = (pdev->cfg_size - PCI_CFG_SPACE_SIZE) / PCI_CAP_SIZEOF;\r\nwhile (loops-- && epos >= PCI_CFG_SPACE_SIZE) {\r\nu32 header;\r\nu16 ecap;\r\nint i, len = 0;\r\nbool hidden = false;\r\nret = pci_read_config_dword(pdev, epos, &header);\r\nif (ret)\r\nreturn ret;\r\necap = PCI_EXT_CAP_ID(header);\r\nif (ecap <= PCI_EXT_CAP_ID_MAX) {\r\nlen = pci_ext_cap_length[ecap];\r\nif (len == 0xFF) {\r\nlen = vfio_ext_cap_len(vdev, ecap, epos);\r\nif (len < 0)\r\nreturn ret;\r\n}\r\n}\r\nif (!len) {\r\npr_info("%s: %s hiding ecap 0x%x@0x%x\n",\r\n__func__, dev_name(&pdev->dev), ecap, epos);\r\nif (prev) {\r\nu32 val = epos = PCI_EXT_CAP_NEXT(header);\r\n*prev &= cpu_to_le32(~(0xffcU << 20));\r\n*prev |= cpu_to_le32(val << 20);\r\ncontinue;\r\n}\r\nlen = PCI_CAP_SIZEOF;\r\nhidden = true;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nif (likely(map[epos + i] == PCI_CAP_ID_INVALID))\r\ncontinue;\r\npr_warn("%s: %s pci config conflict @0x%x, was ecap 0x%x now ecap 0x%x\n",\r\n__func__, dev_name(&pdev->dev),\r\nepos + i, map[epos + i], ecap);\r\n}\r\nBUILD_BUG_ON(PCI_EXT_CAP_ID_MAX >= PCI_CAP_ID_INVALID);\r\nmemset(map + epos, ecap, len);\r\nret = vfio_fill_vconfig_bytes(vdev, epos, len);\r\nif (ret)\r\nreturn ret;\r\nif (hidden)\r\n*(__le32 *)&vdev->vconfig[epos] &=\r\ncpu_to_le32((0xffcU << 20));\r\nelse\r\necaps++;\r\nprev = (__le32 *)&vdev->vconfig[epos];\r\nepos = PCI_EXT_CAP_NEXT(header);\r\n}\r\nif (!ecaps)\r\n*(u32 *)&vdev->vconfig[PCI_CFG_SPACE_SIZE] = 0;\r\nreturn 0;\r\n}\r\nint vfio_config_init(struct vfio_pci_device *vdev)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nu8 *map, *vconfig;\r\nint ret;\r\nmap = kmalloc(pdev->cfg_size, GFP_KERNEL);\r\nif (!map)\r\nreturn -ENOMEM;\r\nvconfig = kmalloc(pdev->cfg_size, GFP_KERNEL);\r\nif (!vconfig) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nvdev->pci_config_map = map;\r\nvdev->vconfig = vconfig;\r\nmemset(map, PCI_CAP_ID_BASIC, PCI_STD_HEADER_SIZEOF);\r\nmemset(map + PCI_STD_HEADER_SIZEOF, PCI_CAP_ID_INVALID,\r\npdev->cfg_size - PCI_STD_HEADER_SIZEOF);\r\nret = vfio_fill_vconfig_bytes(vdev, 0, PCI_STD_HEADER_SIZEOF);\r\nif (ret)\r\ngoto out;\r\nvdev->bardirty = true;\r\nvdev->rbar[0] = le32_to_cpu(*(__le32 *)&vconfig[PCI_BASE_ADDRESS_0]);\r\nvdev->rbar[1] = le32_to_cpu(*(__le32 *)&vconfig[PCI_BASE_ADDRESS_1]);\r\nvdev->rbar[2] = le32_to_cpu(*(__le32 *)&vconfig[PCI_BASE_ADDRESS_2]);\r\nvdev->rbar[3] = le32_to_cpu(*(__le32 *)&vconfig[PCI_BASE_ADDRESS_3]);\r\nvdev->rbar[4] = le32_to_cpu(*(__le32 *)&vconfig[PCI_BASE_ADDRESS_4]);\r\nvdev->rbar[5] = le32_to_cpu(*(__le32 *)&vconfig[PCI_BASE_ADDRESS_5]);\r\nvdev->rbar[6] = le32_to_cpu(*(__le32 *)&vconfig[PCI_ROM_ADDRESS]);\r\nif (pdev->is_virtfn) {\r\n*(__le16 *)&vconfig[PCI_VENDOR_ID] = cpu_to_le16(pdev->vendor);\r\n*(__le16 *)&vconfig[PCI_DEVICE_ID] = cpu_to_le16(pdev->device);\r\n}\r\nret = vfio_cap_init(vdev);\r\nif (ret)\r\ngoto out;\r\nret = vfio_ecap_init(vdev);\r\nif (ret)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nkfree(map);\r\nvdev->pci_config_map = NULL;\r\nkfree(vconfig);\r\nvdev->vconfig = NULL;\r\nreturn pcibios_err_to_errno(ret);\r\n}\r\nvoid vfio_config_free(struct vfio_pci_device *vdev)\r\n{\r\nkfree(vdev->vconfig);\r\nvdev->vconfig = NULL;\r\nkfree(vdev->pci_config_map);\r\nvdev->pci_config_map = NULL;\r\nkfree(vdev->msi_perm);\r\nvdev->msi_perm = NULL;\r\n}\r\nstatic size_t vfio_pci_cap_remaining_dword(struct vfio_pci_device *vdev,\r\nloff_t pos)\r\n{\r\nu8 cap = vdev->pci_config_map[pos];\r\nsize_t i;\r\nfor (i = 1; (pos + i) % 4 && vdev->pci_config_map[pos + i] == cap; i++)\r\n;\r\nreturn i;\r\n}\r\nstatic ssize_t vfio_config_do_rw(struct vfio_pci_device *vdev, char __user *buf,\r\nsize_t count, loff_t *ppos, bool iswrite)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nstruct perm_bits *perm;\r\n__le32 val = 0;\r\nint cap_start = 0, offset;\r\nu8 cap_id;\r\nssize_t ret;\r\nif (*ppos < 0 || *ppos >= pdev->cfg_size ||\r\n*ppos + count > pdev->cfg_size)\r\nreturn -EFAULT;\r\ncount = min(count, vfio_pci_cap_remaining_dword(vdev, *ppos));\r\nif (count >= 4 && !(*ppos % 4))\r\ncount = 4;\r\nelse if (count >= 2 && !(*ppos % 2))\r\ncount = 2;\r\nelse\r\ncount = 1;\r\nret = count;\r\ncap_id = vdev->pci_config_map[*ppos];\r\nif (cap_id == PCI_CAP_ID_INVALID) {\r\nperm = &unassigned_perms;\r\ncap_start = *ppos;\r\n} else {\r\nif (*ppos >= PCI_CFG_SPACE_SIZE) {\r\nWARN_ON(cap_id > PCI_EXT_CAP_ID_MAX);\r\nperm = &ecap_perms[cap_id];\r\ncap_start = vfio_find_cap_start(vdev, *ppos);\r\n} else {\r\nWARN_ON(cap_id > PCI_CAP_ID_MAX);\r\nperm = &cap_perms[cap_id];\r\nif (cap_id == PCI_CAP_ID_MSI)\r\nperm = vdev->msi_perm;\r\nif (cap_id > PCI_CAP_ID_BASIC)\r\ncap_start = vfio_find_cap_start(vdev, *ppos);\r\n}\r\n}\r\nWARN_ON(!cap_start && cap_id != PCI_CAP_ID_BASIC);\r\nWARN_ON(cap_start > *ppos);\r\noffset = *ppos - cap_start;\r\nif (iswrite) {\r\nif (!perm->writefn)\r\nreturn ret;\r\nif (copy_from_user(&val, buf, count))\r\nreturn -EFAULT;\r\nret = perm->writefn(vdev, *ppos, count, perm, offset, val);\r\n} else {\r\nif (perm->readfn) {\r\nret = perm->readfn(vdev, *ppos, count,\r\nperm, offset, &val);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (copy_to_user(buf, &val, count))\r\nreturn -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nssize_t vfio_pci_config_rw(struct vfio_pci_device *vdev, char __user *buf,\r\nsize_t count, loff_t *ppos, bool iswrite)\r\n{\r\nsize_t done = 0;\r\nint ret = 0;\r\nloff_t pos = *ppos;\r\npos &= VFIO_PCI_OFFSET_MASK;\r\nwhile (count) {\r\nret = vfio_config_do_rw(vdev, buf, count, &pos, iswrite);\r\nif (ret < 0)\r\nreturn ret;\r\ncount -= ret;\r\ndone += ret;\r\nbuf += ret;\r\npos += ret;\r\n}\r\n*ppos += done;\r\nreturn done;\r\n}
