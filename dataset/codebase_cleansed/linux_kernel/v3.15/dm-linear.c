static int linear_ctr(struct dm_target *ti, unsigned int argc, char **argv)\r\n{\r\nstruct linear_c *lc;\r\nunsigned long long tmp;\r\nchar dummy;\r\nif (argc != 2) {\r\nti->error = "Invalid argument count";\r\nreturn -EINVAL;\r\n}\r\nlc = kmalloc(sizeof(*lc), GFP_KERNEL);\r\nif (lc == NULL) {\r\nti->error = "dm-linear: Cannot allocate linear context";\r\nreturn -ENOMEM;\r\n}\r\nif (sscanf(argv[1], "%llu%c", &tmp, &dummy) != 1) {\r\nti->error = "dm-linear: Invalid device sector";\r\ngoto bad;\r\n}\r\nlc->start = tmp;\r\nif (dm_get_device(ti, argv[0], dm_table_get_mode(ti->table), &lc->dev)) {\r\nti->error = "dm-linear: Device lookup failed";\r\ngoto bad;\r\n}\r\nti->num_flush_bios = 1;\r\nti->num_discard_bios = 1;\r\nti->num_write_same_bios = 1;\r\nti->private = lc;\r\nreturn 0;\r\nbad:\r\nkfree(lc);\r\nreturn -EINVAL;\r\n}\r\nstatic void linear_dtr(struct dm_target *ti)\r\n{\r\nstruct linear_c *lc = (struct linear_c *) ti->private;\r\ndm_put_device(ti, lc->dev);\r\nkfree(lc);\r\n}\r\nstatic sector_t linear_map_sector(struct dm_target *ti, sector_t bi_sector)\r\n{\r\nstruct linear_c *lc = ti->private;\r\nreturn lc->start + dm_target_offset(ti, bi_sector);\r\n}\r\nstatic void linear_map_bio(struct dm_target *ti, struct bio *bio)\r\n{\r\nstruct linear_c *lc = ti->private;\r\nbio->bi_bdev = lc->dev->bdev;\r\nif (bio_sectors(bio))\r\nbio->bi_iter.bi_sector =\r\nlinear_map_sector(ti, bio->bi_iter.bi_sector);\r\n}\r\nstatic int linear_map(struct dm_target *ti, struct bio *bio)\r\n{\r\nlinear_map_bio(ti, bio);\r\nreturn DM_MAPIO_REMAPPED;\r\n}\r\nstatic void linear_status(struct dm_target *ti, status_type_t type,\r\nunsigned status_flags, char *result, unsigned maxlen)\r\n{\r\nstruct linear_c *lc = (struct linear_c *) ti->private;\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nresult[0] = '\0';\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nsnprintf(result, maxlen, "%s %llu", lc->dev->name,\r\n(unsigned long long)lc->start);\r\nbreak;\r\n}\r\n}\r\nstatic int linear_ioctl(struct dm_target *ti, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct linear_c *lc = (struct linear_c *) ti->private;\r\nstruct dm_dev *dev = lc->dev;\r\nint r = 0;\r\nif (lc->start ||\r\nti->len != i_size_read(dev->bdev->bd_inode) >> SECTOR_SHIFT)\r\nr = scsi_verify_blk_ioctl(NULL, cmd);\r\nreturn r ? : __blkdev_driver_ioctl(dev->bdev, dev->mode, cmd, arg);\r\n}\r\nstatic int linear_merge(struct dm_target *ti, struct bvec_merge_data *bvm,\r\nstruct bio_vec *biovec, int max_size)\r\n{\r\nstruct linear_c *lc = ti->private;\r\nstruct request_queue *q = bdev_get_queue(lc->dev->bdev);\r\nif (!q->merge_bvec_fn)\r\nreturn max_size;\r\nbvm->bi_bdev = lc->dev->bdev;\r\nbvm->bi_sector = linear_map_sector(ti, bvm->bi_sector);\r\nreturn min(max_size, q->merge_bvec_fn(q, bvm, biovec));\r\n}\r\nstatic int linear_iterate_devices(struct dm_target *ti,\r\niterate_devices_callout_fn fn, void *data)\r\n{\r\nstruct linear_c *lc = ti->private;\r\nreturn fn(ti, lc->dev, lc->start, ti->len, data);\r\n}\r\nint __init dm_linear_init(void)\r\n{\r\nint r = dm_register_target(&linear_target);\r\nif (r < 0)\r\nDMERR("register failed %d", r);\r\nreturn r;\r\n}\r\nvoid dm_linear_exit(void)\r\n{\r\ndm_unregister_target(&linear_target);\r\n}
