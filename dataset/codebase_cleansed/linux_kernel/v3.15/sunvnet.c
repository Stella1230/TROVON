static inline u32 vnet_tx_dring_avail(struct vio_dring_state *dr)\r\n{\r\nreturn vio_dring_avail(dr, VNET_TX_RING_SIZE);\r\n}\r\nstatic int vnet_handle_unknown(struct vnet_port *port, void *arg)\r\n{\r\nstruct vio_msg_tag *pkt = arg;\r\npr_err("Received unknown msg [%02x:%02x:%04x:%08x]\n",\r\npkt->type, pkt->stype, pkt->stype_env, pkt->sid);\r\npr_err("Resetting connection\n");\r\nldc_disconnect(port->vio.lp);\r\nreturn -ECONNRESET;\r\n}\r\nstatic int vnet_send_attr(struct vio_driver_state *vio)\r\n{\r\nstruct vnet_port *port = to_vnet_port(vio);\r\nstruct net_device *dev = port->vp->dev;\r\nstruct vio_net_attr_info pkt;\r\nint i;\r\nmemset(&pkt, 0, sizeof(pkt));\r\npkt.tag.type = VIO_TYPE_CTRL;\r\npkt.tag.stype = VIO_SUBTYPE_INFO;\r\npkt.tag.stype_env = VIO_ATTR_INFO;\r\npkt.tag.sid = vio_send_sid(vio);\r\npkt.xfer_mode = VIO_DRING_MODE;\r\npkt.addr_type = VNET_ADDR_ETHERMAC;\r\npkt.ack_freq = 0;\r\nfor (i = 0; i < 6; i++)\r\npkt.addr |= (u64)dev->dev_addr[i] << ((5 - i) * 8);\r\npkt.mtu = ETH_FRAME_LEN;\r\nviodbg(HS, "SEND NET ATTR xmode[0x%x] atype[0x%x] addr[%llx] "\r\n"ackfreq[%u] mtu[%llu]\n",\r\npkt.xfer_mode, pkt.addr_type,\r\n(unsigned long long) pkt.addr,\r\npkt.ack_freq,\r\n(unsigned long long) pkt.mtu);\r\nreturn vio_ldc_send(vio, &pkt, sizeof(pkt));\r\n}\r\nstatic int handle_attr_info(struct vio_driver_state *vio,\r\nstruct vio_net_attr_info *pkt)\r\n{\r\nviodbg(HS, "GOT NET ATTR INFO xmode[0x%x] atype[0x%x] addr[%llx] "\r\n"ackfreq[%u] mtu[%llu]\n",\r\npkt->xfer_mode, pkt->addr_type,\r\n(unsigned long long) pkt->addr,\r\npkt->ack_freq,\r\n(unsigned long long) pkt->mtu);\r\npkt->tag.sid = vio_send_sid(vio);\r\nif (pkt->xfer_mode != VIO_DRING_MODE ||\r\npkt->addr_type != VNET_ADDR_ETHERMAC ||\r\npkt->mtu != ETH_FRAME_LEN) {\r\nviodbg(HS, "SEND NET ATTR NACK\n");\r\npkt->tag.stype = VIO_SUBTYPE_NACK;\r\n(void) vio_ldc_send(vio, pkt, sizeof(*pkt));\r\nreturn -ECONNRESET;\r\n} else {\r\nviodbg(HS, "SEND NET ATTR ACK\n");\r\npkt->tag.stype = VIO_SUBTYPE_ACK;\r\nreturn vio_ldc_send(vio, pkt, sizeof(*pkt));\r\n}\r\n}\r\nstatic int handle_attr_ack(struct vio_driver_state *vio,\r\nstruct vio_net_attr_info *pkt)\r\n{\r\nviodbg(HS, "GOT NET ATTR ACK\n");\r\nreturn 0;\r\n}\r\nstatic int handle_attr_nack(struct vio_driver_state *vio,\r\nstruct vio_net_attr_info *pkt)\r\n{\r\nviodbg(HS, "GOT NET ATTR NACK\n");\r\nreturn -ECONNRESET;\r\n}\r\nstatic int vnet_handle_attr(struct vio_driver_state *vio, void *arg)\r\n{\r\nstruct vio_net_attr_info *pkt = arg;\r\nswitch (pkt->tag.stype) {\r\ncase VIO_SUBTYPE_INFO:\r\nreturn handle_attr_info(vio, pkt);\r\ncase VIO_SUBTYPE_ACK:\r\nreturn handle_attr_ack(vio, pkt);\r\ncase VIO_SUBTYPE_NACK:\r\nreturn handle_attr_nack(vio, pkt);\r\ndefault:\r\nreturn -ECONNRESET;\r\n}\r\n}\r\nstatic void vnet_handshake_complete(struct vio_driver_state *vio)\r\n{\r\nstruct vio_dring_state *dr;\r\ndr = &vio->drings[VIO_DRIVER_RX_RING];\r\ndr->snd_nxt = dr->rcv_nxt = 1;\r\ndr = &vio->drings[VIO_DRIVER_TX_RING];\r\ndr->snd_nxt = dr->rcv_nxt = 1;\r\n}\r\nstatic struct sk_buff *alloc_and_align_skb(struct net_device *dev,\r\nunsigned int len)\r\n{\r\nstruct sk_buff *skb = netdev_alloc_skb(dev, len+VNET_PACKET_SKIP+8+8);\r\nunsigned long addr, off;\r\nif (unlikely(!skb))\r\nreturn NULL;\r\naddr = (unsigned long) skb->data;\r\noff = ((addr + 7UL) & ~7UL) - addr;\r\nif (off)\r\nskb_reserve(skb, off);\r\nreturn skb;\r\n}\r\nstatic int vnet_rx_one(struct vnet_port *port, unsigned int len,\r\nstruct ldc_trans_cookie *cookies, int ncookies)\r\n{\r\nstruct net_device *dev = port->vp->dev;\r\nunsigned int copy_len;\r\nstruct sk_buff *skb;\r\nint err;\r\nerr = -EMSGSIZE;\r\nif (unlikely(len < ETH_ZLEN || len > ETH_FRAME_LEN)) {\r\ndev->stats.rx_length_errors++;\r\ngoto out_dropped;\r\n}\r\nskb = alloc_and_align_skb(dev, len);\r\nerr = -ENOMEM;\r\nif (unlikely(!skb)) {\r\ndev->stats.rx_missed_errors++;\r\ngoto out_dropped;\r\n}\r\ncopy_len = (len + VNET_PACKET_SKIP + 7U) & ~7U;\r\nskb_put(skb, copy_len);\r\nerr = ldc_copy(port->vio.lp, LDC_COPY_IN,\r\nskb->data, copy_len, 0,\r\ncookies, ncookies);\r\nif (unlikely(err < 0)) {\r\ndev->stats.rx_frame_errors++;\r\ngoto out_free_skb;\r\n}\r\nskb_pull(skb, VNET_PACKET_SKIP);\r\nskb_trim(skb, len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\nnetif_rx(skb);\r\nreturn 0;\r\nout_free_skb:\r\nkfree_skb(skb);\r\nout_dropped:\r\ndev->stats.rx_dropped++;\r\nreturn err;\r\n}\r\nstatic int vnet_send_ack(struct vnet_port *port, struct vio_dring_state *dr,\r\nu32 start, u32 end, u8 vio_dring_state)\r\n{\r\nstruct vio_dring_data hdr = {\r\n.tag = {\r\n.type = VIO_TYPE_DATA,\r\n.stype = VIO_SUBTYPE_ACK,\r\n.stype_env = VIO_DRING_DATA,\r\n.sid = vio_send_sid(&port->vio),\r\n},\r\n.dring_ident = dr->ident,\r\n.start_idx = start,\r\n.end_idx = end,\r\n.state = vio_dring_state,\r\n};\r\nint err, delay;\r\nhdr.seq = dr->snd_nxt;\r\ndelay = 1;\r\ndo {\r\nerr = vio_ldc_send(&port->vio, &hdr, sizeof(hdr));\r\nif (err > 0) {\r\ndr->snd_nxt++;\r\nbreak;\r\n}\r\nudelay(delay);\r\nif ((delay <<= 1) > 128)\r\ndelay = 128;\r\n} while (err == -EAGAIN);\r\nreturn err;\r\n}\r\nstatic u32 next_idx(u32 idx, struct vio_dring_state *dr)\r\n{\r\nif (++idx == dr->num_entries)\r\nidx = 0;\r\nreturn idx;\r\n}\r\nstatic u32 prev_idx(u32 idx, struct vio_dring_state *dr)\r\n{\r\nif (idx == 0)\r\nidx = dr->num_entries - 1;\r\nelse\r\nidx--;\r\nreturn idx;\r\n}\r\nstatic struct vio_net_desc *get_rx_desc(struct vnet_port *port,\r\nstruct vio_dring_state *dr,\r\nu32 index)\r\n{\r\nstruct vio_net_desc *desc = port->vio.desc_buf;\r\nint err;\r\nerr = ldc_get_dring_entry(port->vio.lp, desc, dr->entry_size,\r\n(index * dr->entry_size),\r\ndr->cookies, dr->ncookies);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nreturn desc;\r\n}\r\nstatic int put_rx_desc(struct vnet_port *port,\r\nstruct vio_dring_state *dr,\r\nstruct vio_net_desc *desc,\r\nu32 index)\r\n{\r\nint err;\r\nerr = ldc_put_dring_entry(port->vio.lp, desc, dr->entry_size,\r\n(index * dr->entry_size),\r\ndr->cookies, dr->ncookies);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int vnet_walk_rx_one(struct vnet_port *port,\r\nstruct vio_dring_state *dr,\r\nu32 index, int *needs_ack)\r\n{\r\nstruct vio_net_desc *desc = get_rx_desc(port, dr, index);\r\nstruct vio_driver_state *vio = &port->vio;\r\nint err;\r\nif (IS_ERR(desc))\r\nreturn PTR_ERR(desc);\r\nviodbg(DATA, "vio_walk_rx_one desc[%02x:%02x:%08x:%08x:%llx:%llx]\n",\r\ndesc->hdr.state, desc->hdr.ack,\r\ndesc->size, desc->ncookies,\r\ndesc->cookies[0].cookie_addr,\r\ndesc->cookies[0].cookie_size);\r\nif (desc->hdr.state != VIO_DESC_READY)\r\nreturn 1;\r\nerr = vnet_rx_one(port, desc->size, desc->cookies, desc->ncookies);\r\nif (err == -ECONNRESET)\r\nreturn err;\r\ndesc->hdr.state = VIO_DESC_DONE;\r\nerr = put_rx_desc(port, dr, desc, index);\r\nif (err < 0)\r\nreturn err;\r\n*needs_ack = desc->hdr.ack;\r\nreturn 0;\r\n}\r\nstatic int vnet_walk_rx(struct vnet_port *port, struct vio_dring_state *dr,\r\nu32 start, u32 end)\r\n{\r\nstruct vio_driver_state *vio = &port->vio;\r\nint ack_start = -1, ack_end = -1;\r\nend = (end == (u32) -1) ? prev_idx(start, dr) : next_idx(end, dr);\r\nviodbg(DATA, "vnet_walk_rx start[%08x] end[%08x]\n", start, end);\r\nwhile (start != end) {\r\nint ack = 0, err = vnet_walk_rx_one(port, dr, start, &ack);\r\nif (err == -ECONNRESET)\r\nreturn err;\r\nif (err != 0)\r\nbreak;\r\nif (ack_start == -1)\r\nack_start = start;\r\nack_end = start;\r\nstart = next_idx(start, dr);\r\nif (ack && start != end) {\r\nerr = vnet_send_ack(port, dr, ack_start, ack_end,\r\nVIO_DRING_ACTIVE);\r\nif (err == -ECONNRESET)\r\nreturn err;\r\nack_start = -1;\r\n}\r\n}\r\nif (unlikely(ack_start == -1))\r\nack_start = ack_end = prev_idx(start, dr);\r\nreturn vnet_send_ack(port, dr, ack_start, ack_end, VIO_DRING_STOPPED);\r\n}\r\nstatic int vnet_rx(struct vnet_port *port, void *msgbuf)\r\n{\r\nstruct vio_dring_data *pkt = msgbuf;\r\nstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_RX_RING];\r\nstruct vio_driver_state *vio = &port->vio;\r\nviodbg(DATA, "vnet_rx stype_env[%04x] seq[%016llx] rcv_nxt[%016llx]\n",\r\npkt->tag.stype_env, pkt->seq, dr->rcv_nxt);\r\nif (unlikely(pkt->tag.stype_env != VIO_DRING_DATA))\r\nreturn 0;\r\nif (unlikely(pkt->seq != dr->rcv_nxt)) {\r\npr_err("RX out of sequence seq[0x%llx] rcv_nxt[0x%llx]\n",\r\npkt->seq, dr->rcv_nxt);\r\nreturn 0;\r\n}\r\ndr->rcv_nxt++;\r\nreturn vnet_walk_rx(port, dr, pkt->start_idx, pkt->end_idx);\r\n}\r\nstatic int idx_is_pending(struct vio_dring_state *dr, u32 end)\r\n{\r\nu32 idx = dr->cons;\r\nint found = 0;\r\nwhile (idx != dr->prod) {\r\nif (idx == end) {\r\nfound = 1;\r\nbreak;\r\n}\r\nidx = next_idx(idx, dr);\r\n}\r\nreturn found;\r\n}\r\nstatic int vnet_ack(struct vnet_port *port, void *msgbuf)\r\n{\r\nstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nstruct vio_dring_data *pkt = msgbuf;\r\nstruct net_device *dev;\r\nstruct vnet *vp;\r\nu32 end;\r\nif (unlikely(pkt->tag.stype_env != VIO_DRING_DATA))\r\nreturn 0;\r\nend = pkt->end_idx;\r\nif (unlikely(!idx_is_pending(dr, end)))\r\nreturn 0;\r\ndr->cons = next_idx(end, dr);\r\nvp = port->vp;\r\ndev = vp->dev;\r\nif (unlikely(netif_queue_stopped(dev) &&\r\nvnet_tx_dring_avail(dr) >= VNET_TX_WAKEUP_THRESH(dr)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int vnet_nack(struct vnet_port *port, void *msgbuf)\r\n{\r\nreturn 0;\r\n}\r\nstatic int handle_mcast(struct vnet_port *port, void *msgbuf)\r\n{\r\nstruct vio_net_mcast_info *pkt = msgbuf;\r\nif (pkt->tag.stype != VIO_SUBTYPE_ACK)\r\npr_err("%s: Got unexpected MCAST reply [%02x:%02x:%04x:%08x]\n",\r\nport->vp->dev->name,\r\npkt->tag.type,\r\npkt->tag.stype,\r\npkt->tag.stype_env,\r\npkt->tag.sid);\r\nreturn 0;\r\n}\r\nstatic void maybe_tx_wakeup(struct vnet *vp)\r\n{\r\nstruct net_device *dev = vp->dev;\r\nnetif_tx_lock(dev);\r\nif (likely(netif_queue_stopped(dev))) {\r\nstruct vnet_port *port;\r\nint wake = 1;\r\nlist_for_each_entry(port, &vp->port_list, list) {\r\nstruct vio_dring_state *dr;\r\ndr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nif (vnet_tx_dring_avail(dr) <\r\nVNET_TX_WAKEUP_THRESH(dr)) {\r\nwake = 0;\r\nbreak;\r\n}\r\n}\r\nif (wake)\r\nnetif_wake_queue(dev);\r\n}\r\nnetif_tx_unlock(dev);\r\n}\r\nstatic void vnet_event(void *arg, int event)\r\n{\r\nstruct vnet_port *port = arg;\r\nstruct vio_driver_state *vio = &port->vio;\r\nunsigned long flags;\r\nint tx_wakeup, err;\r\nspin_lock_irqsave(&vio->lock, flags);\r\nif (unlikely(event == LDC_EVENT_RESET ||\r\nevent == LDC_EVENT_UP)) {\r\nvio_link_state_change(vio, event);\r\nspin_unlock_irqrestore(&vio->lock, flags);\r\nif (event == LDC_EVENT_RESET)\r\nvio_port_up(vio);\r\nreturn;\r\n}\r\nif (unlikely(event != LDC_EVENT_DATA_READY)) {\r\npr_warning("Unexpected LDC event %d\n", event);\r\nspin_unlock_irqrestore(&vio->lock, flags);\r\nreturn;\r\n}\r\ntx_wakeup = err = 0;\r\nwhile (1) {\r\nunion {\r\nstruct vio_msg_tag tag;\r\nu64 raw[8];\r\n} msgbuf;\r\nerr = ldc_read(vio->lp, &msgbuf, sizeof(msgbuf));\r\nif (unlikely(err < 0)) {\r\nif (err == -ECONNRESET)\r\nvio_conn_reset(vio);\r\nbreak;\r\n}\r\nif (err == 0)\r\nbreak;\r\nviodbg(DATA, "TAG [%02x:%02x:%04x:%08x]\n",\r\nmsgbuf.tag.type,\r\nmsgbuf.tag.stype,\r\nmsgbuf.tag.stype_env,\r\nmsgbuf.tag.sid);\r\nerr = vio_validate_sid(vio, &msgbuf.tag);\r\nif (err < 0)\r\nbreak;\r\nif (likely(msgbuf.tag.type == VIO_TYPE_DATA)) {\r\nif (msgbuf.tag.stype == VIO_SUBTYPE_INFO) {\r\nerr = vnet_rx(port, &msgbuf);\r\n} else if (msgbuf.tag.stype == VIO_SUBTYPE_ACK) {\r\nerr = vnet_ack(port, &msgbuf);\r\nif (err > 0)\r\ntx_wakeup |= err;\r\n} else if (msgbuf.tag.stype == VIO_SUBTYPE_NACK) {\r\nerr = vnet_nack(port, &msgbuf);\r\n}\r\n} else if (msgbuf.tag.type == VIO_TYPE_CTRL) {\r\nif (msgbuf.tag.stype_env == VNET_MCAST_INFO)\r\nerr = handle_mcast(port, &msgbuf);\r\nelse\r\nerr = vio_control_pkt_engine(vio, &msgbuf);\r\nif (err)\r\nbreak;\r\n} else {\r\nerr = vnet_handle_unknown(port, &msgbuf);\r\n}\r\nif (err == -ECONNRESET)\r\nbreak;\r\n}\r\nspin_unlock(&vio->lock);\r\nif (unlikely(tx_wakeup && err != -ECONNRESET))\r\nmaybe_tx_wakeup(port->vp);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int __vnet_tx_trigger(struct vnet_port *port)\r\n{\r\nstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nstruct vio_dring_data hdr = {\r\n.tag = {\r\n.type = VIO_TYPE_DATA,\r\n.stype = VIO_SUBTYPE_INFO,\r\n.stype_env = VIO_DRING_DATA,\r\n.sid = vio_send_sid(&port->vio),\r\n},\r\n.dring_ident = dr->ident,\r\n.start_idx = dr->prod,\r\n.end_idx = (u32) -1,\r\n};\r\nint err, delay;\r\nhdr.seq = dr->snd_nxt;\r\ndelay = 1;\r\ndo {\r\nerr = vio_ldc_send(&port->vio, &hdr, sizeof(hdr));\r\nif (err > 0) {\r\ndr->snd_nxt++;\r\nbreak;\r\n}\r\nudelay(delay);\r\nif ((delay <<= 1) > 128)\r\ndelay = 128;\r\n} while (err == -EAGAIN);\r\nreturn err;\r\n}\r\nstruct vnet_port *__tx_port_find(struct vnet *vp, struct sk_buff *skb)\r\n{\r\nunsigned int hash = vnet_hashfn(skb->data);\r\nstruct hlist_head *hp = &vp->port_hash[hash];\r\nstruct vnet_port *port;\r\nhlist_for_each_entry(port, hp, hash) {\r\nif (ether_addr_equal(port->raddr, skb->data))\r\nreturn port;\r\n}\r\nport = NULL;\r\nif (!list_empty(&vp->port_list))\r\nport = list_entry(vp->port_list.next, struct vnet_port, list);\r\nreturn port;\r\n}\r\nstruct vnet_port *tx_port_find(struct vnet *vp, struct sk_buff *skb)\r\n{\r\nstruct vnet_port *ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vp->lock, flags);\r\nret = __tx_port_find(vp, skb);\r\nspin_unlock_irqrestore(&vp->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int vnet_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nstruct vnet_port *port = tx_port_find(vp, skb);\r\nstruct vio_dring_state *dr;\r\nstruct vio_net_desc *d;\r\nunsigned long flags;\r\nunsigned int len;\r\nvoid *tx_buf;\r\nint i, err;\r\nif (unlikely(!port))\r\ngoto out_dropped;\r\nspin_lock_irqsave(&port->vio.lock, flags);\r\ndr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nif (unlikely(vnet_tx_dring_avail(dr) < 2)) {\r\nif (!netif_queue_stopped(dev)) {\r\nnetif_stop_queue(dev);\r\nnetdev_err(dev, "BUG! Tx Ring full when queue awake!\n");\r\ndev->stats.tx_errors++;\r\n}\r\nspin_unlock_irqrestore(&port->vio.lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nd = vio_dring_cur(dr);\r\ntx_buf = port->tx_bufs[dr->prod].buf;\r\nskb_copy_from_linear_data(skb, tx_buf + VNET_PACKET_SKIP, skb->len);\r\nlen = skb->len;\r\nif (len < ETH_ZLEN) {\r\nlen = ETH_ZLEN;\r\nmemset(tx_buf+VNET_PACKET_SKIP+skb->len, 0, len - skb->len);\r\n}\r\nd->hdr.ack = VIO_ACK_ENABLE;\r\nd->size = len;\r\nd->ncookies = port->tx_bufs[dr->prod].ncookies;\r\nfor (i = 0; i < d->ncookies; i++)\r\nd->cookies[i] = port->tx_bufs[dr->prod].cookies[i];\r\nwmb();\r\nd->hdr.state = VIO_DESC_READY;\r\nerr = __vnet_tx_trigger(port);\r\nif (unlikely(err < 0)) {\r\nnetdev_info(dev, "TX trigger error %d\n", err);\r\nd->hdr.state = VIO_DESC_FREE;\r\ndev->stats.tx_carrier_errors++;\r\ngoto out_dropped_unlock;\r\n}\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\ndr->prod = (dr->prod + 1) & (VNET_TX_RING_SIZE - 1);\r\nif (unlikely(vnet_tx_dring_avail(dr) < 2)) {\r\nnetif_stop_queue(dev);\r\nif (vnet_tx_dring_avail(dr) > VNET_TX_WAKEUP_THRESH(dr))\r\nnetif_wake_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&port->vio.lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\nout_dropped_unlock:\r\nspin_unlock_irqrestore(&port->vio.lock, flags);\r\nout_dropped:\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void vnet_tx_timeout(struct net_device *dev)\r\n{\r\n}\r\nstatic int vnet_open(struct net_device *dev)\r\n{\r\nnetif_carrier_on(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int vnet_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nnetif_carrier_off(dev);\r\nreturn 0;\r\n}\r\nstatic struct vnet_mcast_entry *__vnet_mc_find(struct vnet *vp, u8 *addr)\r\n{\r\nstruct vnet_mcast_entry *m;\r\nfor (m = vp->mcast_list; m; m = m->next) {\r\nif (ether_addr_equal(m->addr, addr))\r\nreturn m;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void __update_mc_list(struct vnet *vp, struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nstruct vnet_mcast_entry *m;\r\nm = __vnet_mc_find(vp, ha->addr);\r\nif (m) {\r\nm->hit = 1;\r\ncontinue;\r\n}\r\nif (!m) {\r\nm = kzalloc(sizeof(*m), GFP_ATOMIC);\r\nif (!m)\r\ncontinue;\r\nmemcpy(m->addr, ha->addr, ETH_ALEN);\r\nm->hit = 1;\r\nm->next = vp->mcast_list;\r\nvp->mcast_list = m;\r\n}\r\n}\r\n}\r\nstatic void __send_mc_list(struct vnet *vp, struct vnet_port *port)\r\n{\r\nstruct vio_net_mcast_info info;\r\nstruct vnet_mcast_entry *m, **pp;\r\nint n_addrs;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.tag.type = VIO_TYPE_CTRL;\r\ninfo.tag.stype = VIO_SUBTYPE_INFO;\r\ninfo.tag.stype_env = VNET_MCAST_INFO;\r\ninfo.tag.sid = vio_send_sid(&port->vio);\r\ninfo.set = 1;\r\nn_addrs = 0;\r\nfor (m = vp->mcast_list; m; m = m->next) {\r\nif (m->sent)\r\ncontinue;\r\nm->sent = 1;\r\nmemcpy(&info.mcast_addr[n_addrs * ETH_ALEN],\r\nm->addr, ETH_ALEN);\r\nif (++n_addrs == VNET_NUM_MCAST) {\r\ninfo.count = n_addrs;\r\n(void) vio_ldc_send(&port->vio, &info,\r\nsizeof(info));\r\nn_addrs = 0;\r\n}\r\n}\r\nif (n_addrs) {\r\ninfo.count = n_addrs;\r\n(void) vio_ldc_send(&port->vio, &info, sizeof(info));\r\n}\r\ninfo.set = 0;\r\nn_addrs = 0;\r\npp = &vp->mcast_list;\r\nwhile ((m = *pp) != NULL) {\r\nif (m->hit) {\r\nm->hit = 0;\r\npp = &m->next;\r\ncontinue;\r\n}\r\nmemcpy(&info.mcast_addr[n_addrs * ETH_ALEN],\r\nm->addr, ETH_ALEN);\r\nif (++n_addrs == VNET_NUM_MCAST) {\r\ninfo.count = n_addrs;\r\n(void) vio_ldc_send(&port->vio, &info,\r\nsizeof(info));\r\nn_addrs = 0;\r\n}\r\n*pp = m->next;\r\nkfree(m);\r\n}\r\nif (n_addrs) {\r\ninfo.count = n_addrs;\r\n(void) vio_ldc_send(&port->vio, &info, sizeof(info));\r\n}\r\n}\r\nstatic void vnet_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nstruct vnet_port *port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vp->lock, flags);\r\nif (!list_empty(&vp->port_list)) {\r\nport = list_entry(vp->port_list.next, struct vnet_port, list);\r\nif (port->switch_port) {\r\n__update_mc_list(vp, dev);\r\n__send_mc_list(vp, port);\r\n}\r\n}\r\nspin_unlock_irqrestore(&vp->lock, flags);\r\n}\r\nstatic int vnet_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (new_mtu != ETH_DATA_LEN)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int vnet_set_mac_addr(struct net_device *dev, void *p)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void vnet_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\r\n}\r\nstatic u32 vnet_get_msglevel(struct net_device *dev)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nreturn vp->msg_enable;\r\n}\r\nstatic void vnet_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nvp->msg_enable = value;\r\n}\r\nstatic void vnet_port_free_tx_bufs(struct vnet_port *port)\r\n{\r\nstruct vio_dring_state *dr;\r\nint i;\r\ndr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nif (dr->base) {\r\nldc_free_exp_dring(port->vio.lp, dr->base,\r\n(dr->entry_size * dr->num_entries),\r\ndr->cookies, dr->ncookies);\r\ndr->base = NULL;\r\ndr->entry_size = 0;\r\ndr->num_entries = 0;\r\ndr->pending = 0;\r\ndr->ncookies = 0;\r\n}\r\nfor (i = 0; i < VNET_TX_RING_SIZE; i++) {\r\nvoid *buf = port->tx_bufs[i].buf;\r\nif (!buf)\r\ncontinue;\r\nldc_unmap(port->vio.lp,\r\nport->tx_bufs[i].cookies,\r\nport->tx_bufs[i].ncookies);\r\nkfree(buf);\r\nport->tx_bufs[i].buf = NULL;\r\n}\r\n}\r\nstatic int vnet_port_alloc_tx_bufs(struct vnet_port *port)\r\n{\r\nstruct vio_dring_state *dr;\r\nunsigned long len;\r\nint i, err, ncookies;\r\nvoid *dring;\r\nfor (i = 0; i < VNET_TX_RING_SIZE; i++) {\r\nvoid *buf = kzalloc(ETH_FRAME_LEN + 8, GFP_KERNEL);\r\nint map_len = (ETH_FRAME_LEN + 7) & ~7;\r\nerr = -ENOMEM;\r\nif (!buf)\r\ngoto err_out;\r\nerr = -EFAULT;\r\nif ((unsigned long)buf & (8UL - 1)) {\r\npr_err("TX buffer misaligned\n");\r\nkfree(buf);\r\ngoto err_out;\r\n}\r\nerr = ldc_map_single(port->vio.lp, buf, map_len,\r\nport->tx_bufs[i].cookies, 2,\r\n(LDC_MAP_SHADOW |\r\nLDC_MAP_DIRECT |\r\nLDC_MAP_RW));\r\nif (err < 0) {\r\nkfree(buf);\r\ngoto err_out;\r\n}\r\nport->tx_bufs[i].buf = buf;\r\nport->tx_bufs[i].ncookies = err;\r\n}\r\ndr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nlen = (VNET_TX_RING_SIZE *\r\n(sizeof(struct vio_net_desc) +\r\n(sizeof(struct ldc_trans_cookie) * 2)));\r\nncookies = VIO_MAX_RING_COOKIES;\r\ndring = ldc_alloc_exp_dring(port->vio.lp, len,\r\ndr->cookies, &ncookies,\r\n(LDC_MAP_SHADOW |\r\nLDC_MAP_DIRECT |\r\nLDC_MAP_RW));\r\nif (IS_ERR(dring)) {\r\nerr = PTR_ERR(dring);\r\ngoto err_out;\r\n}\r\ndr->base = dring;\r\ndr->entry_size = (sizeof(struct vio_net_desc) +\r\n(sizeof(struct ldc_trans_cookie) * 2));\r\ndr->num_entries = VNET_TX_RING_SIZE;\r\ndr->prod = dr->cons = 0;\r\ndr->pending = VNET_TX_RING_SIZE;\r\ndr->ncookies = ncookies;\r\nreturn 0;\r\nerr_out:\r\nvnet_port_free_tx_bufs(port);\r\nreturn err;\r\n}\r\nstatic struct vnet *vnet_new(const u64 *local_mac)\r\n{\r\nstruct net_device *dev;\r\nstruct vnet *vp;\r\nint err, i;\r\ndev = alloc_etherdev(sizeof(*vp));\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ndev->dev_addr[i] = (*local_mac >> (5 - i) * 8) & 0xff;\r\nvp = netdev_priv(dev);\r\nspin_lock_init(&vp->lock);\r\nvp->dev = dev;\r\nINIT_LIST_HEAD(&vp->port_list);\r\nfor (i = 0; i < VNET_PORT_HASH_SIZE; i++)\r\nINIT_HLIST_HEAD(&vp->port_hash[i]);\r\nINIT_LIST_HEAD(&vp->list);\r\nvp->local_mac = *local_mac;\r\ndev->netdev_ops = &vnet_ops;\r\ndev->ethtool_ops = &vnet_ethtool_ops;\r\ndev->watchdog_timeo = VNET_TX_TIMEOUT;\r\nerr = register_netdev(dev);\r\nif (err) {\r\npr_err("Cannot register net device, aborting\n");\r\ngoto err_out_free_dev;\r\n}\r\nnetdev_info(dev, "Sun LDOM vnet %pM\n", dev->dev_addr);\r\nlist_add(&vp->list, &vnet_list);\r\nreturn vp;\r\nerr_out_free_dev:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic struct vnet *vnet_find_or_create(const u64 *local_mac)\r\n{\r\nstruct vnet *iter, *vp;\r\nmutex_lock(&vnet_list_mutex);\r\nvp = NULL;\r\nlist_for_each_entry(iter, &vnet_list, list) {\r\nif (iter->local_mac == *local_mac) {\r\nvp = iter;\r\nbreak;\r\n}\r\n}\r\nif (!vp)\r\nvp = vnet_new(local_mac);\r\nmutex_unlock(&vnet_list_mutex);\r\nreturn vp;\r\n}\r\nstatic struct vnet *vnet_find_parent(struct mdesc_handle *hp,\r\nu64 port_node)\r\n{\r\nconst u64 *local_mac = NULL;\r\nu64 a;\r\nmdesc_for_each_arc(a, hp, port_node, MDESC_ARC_TYPE_BACK) {\r\nu64 target = mdesc_arc_target(hp, a);\r\nconst char *name;\r\nname = mdesc_get_property(hp, target, "name", NULL);\r\nif (!name || strcmp(name, "network"))\r\ncontinue;\r\nlocal_mac = mdesc_get_property(hp, target,\r\nlocal_mac_prop, NULL);\r\nif (local_mac)\r\nbreak;\r\n}\r\nif (!local_mac)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn vnet_find_or_create(local_mac);\r\n}\r\nstatic void print_version(void)\r\n{\r\nprintk_once(KERN_INFO "%s", version);\r\n}\r\nstatic int vnet_port_probe(struct vio_dev *vdev, const struct vio_device_id *id)\r\n{\r\nstruct mdesc_handle *hp;\r\nstruct vnet_port *port;\r\nunsigned long flags;\r\nstruct vnet *vp;\r\nconst u64 *rmac;\r\nint len, i, err, switch_port;\r\nprint_version();\r\nhp = mdesc_grab();\r\nvp = vnet_find_parent(hp, vdev->mp);\r\nif (IS_ERR(vp)) {\r\npr_err("Cannot find port parent vnet\n");\r\nerr = PTR_ERR(vp);\r\ngoto err_out_put_mdesc;\r\n}\r\nrmac = mdesc_get_property(hp, vdev->mp, remote_macaddr_prop, &len);\r\nerr = -ENODEV;\r\nif (!rmac) {\r\npr_err("Port lacks %s property\n", remote_macaddr_prop);\r\ngoto err_out_put_mdesc;\r\n}\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!port)\r\ngoto err_out_put_mdesc;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nport->raddr[i] = (*rmac >> (5 - i) * 8) & 0xff;\r\nport->vp = vp;\r\nerr = vio_driver_init(&port->vio, vdev, VDEV_NETWORK,\r\nvnet_versions, ARRAY_SIZE(vnet_versions),\r\n&vnet_vio_ops, vp->dev->name);\r\nif (err)\r\ngoto err_out_free_port;\r\nerr = vio_ldc_alloc(&port->vio, &vnet_ldc_cfg, port);\r\nif (err)\r\ngoto err_out_free_port;\r\nerr = vnet_port_alloc_tx_bufs(port);\r\nif (err)\r\ngoto err_out_free_ldc;\r\nINIT_HLIST_NODE(&port->hash);\r\nINIT_LIST_HEAD(&port->list);\r\nswitch_port = 0;\r\nif (mdesc_get_property(hp, vdev->mp, "switch-port", NULL) != NULL)\r\nswitch_port = 1;\r\nport->switch_port = switch_port;\r\nspin_lock_irqsave(&vp->lock, flags);\r\nif (switch_port)\r\nlist_add(&port->list, &vp->port_list);\r\nelse\r\nlist_add_tail(&port->list, &vp->port_list);\r\nhlist_add_head(&port->hash, &vp->port_hash[vnet_hashfn(port->raddr)]);\r\nspin_unlock_irqrestore(&vp->lock, flags);\r\ndev_set_drvdata(&vdev->dev, port);\r\npr_info("%s: PORT ( remote-mac %pM%s )\n",\r\nvp->dev->name, port->raddr, switch_port ? " switch-port" : "");\r\nvio_port_up(&port->vio);\r\nmdesc_release(hp);\r\nreturn 0;\r\nerr_out_free_ldc:\r\nvio_ldc_free(&port->vio);\r\nerr_out_free_port:\r\nkfree(port);\r\nerr_out_put_mdesc:\r\nmdesc_release(hp);\r\nreturn err;\r\n}\r\nstatic int vnet_port_remove(struct vio_dev *vdev)\r\n{\r\nstruct vnet_port *port = dev_get_drvdata(&vdev->dev);\r\nif (port) {\r\nstruct vnet *vp = port->vp;\r\nunsigned long flags;\r\ndel_timer_sync(&port->vio.timer);\r\nspin_lock_irqsave(&vp->lock, flags);\r\nlist_del(&port->list);\r\nhlist_del(&port->hash);\r\nspin_unlock_irqrestore(&vp->lock, flags);\r\nvnet_port_free_tx_bufs(port);\r\nvio_ldc_free(&port->vio);\r\ndev_set_drvdata(&vdev->dev, NULL);\r\nkfree(port);\r\nunregister_netdev(vp->dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init vnet_init(void)\r\n{\r\nreturn vio_register_driver(&vnet_port_driver);\r\n}\r\nstatic void __exit vnet_exit(void)\r\n{\r\nvio_unregister_driver(&vnet_port_driver);\r\n}
