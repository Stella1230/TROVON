static bool mg_end_request(struct mg_host *host, int err, unsigned int nr_bytes)\r\n{\r\nif (__blk_end_request(host->req, err, nr_bytes))\r\nreturn true;\r\nhost->req = NULL;\r\nreturn false;\r\n}\r\nstatic bool mg_end_request_cur(struct mg_host *host, int err)\r\n{\r\nreturn mg_end_request(host, err, blk_rq_cur_bytes(host->req));\r\n}\r\nstatic void mg_dump_status(const char *msg, unsigned int stat,\r\nstruct mg_host *host)\r\n{\r\nchar *name = MG_DISK_NAME;\r\nif (host->req)\r\nname = host->req->rq_disk->disk_name;\r\nprintk(KERN_ERR "%s: %s: status=0x%02x { ", name, msg, stat & 0xff);\r\nif (stat & ATA_BUSY)\r\nprintk("Busy ");\r\nif (stat & ATA_DRDY)\r\nprintk("DriveReady ");\r\nif (stat & ATA_DF)\r\nprintk("WriteFault ");\r\nif (stat & ATA_DSC)\r\nprintk("SeekComplete ");\r\nif (stat & ATA_DRQ)\r\nprintk("DataRequest ");\r\nif (stat & ATA_CORR)\r\nprintk("CorrectedError ");\r\nif (stat & ATA_ERR)\r\nprintk("Error ");\r\nprintk("}\n");\r\nif ((stat & ATA_ERR) == 0) {\r\nhost->error = 0;\r\n} else {\r\nhost->error = inb((unsigned long)host->dev_base + MG_REG_ERROR);\r\nprintk(KERN_ERR "%s: %s: error=0x%02x { ", name, msg,\r\nhost->error & 0xff);\r\nif (host->error & ATA_BBK)\r\nprintk("BadSector ");\r\nif (host->error & ATA_UNC)\r\nprintk("UncorrectableError ");\r\nif (host->error & ATA_IDNF)\r\nprintk("SectorIdNotFound ");\r\nif (host->error & ATA_ABORTED)\r\nprintk("DriveStatusError ");\r\nif (host->error & ATA_AMNF)\r\nprintk("AddrMarkNotFound ");\r\nprintk("}");\r\nif (host->error & (ATA_BBK | ATA_UNC | ATA_IDNF | ATA_AMNF)) {\r\nif (host->req)\r\nprintk(", sector=%u",\r\n(unsigned int)blk_rq_pos(host->req));\r\n}\r\nprintk("\n");\r\n}\r\n}\r\nstatic unsigned int mg_wait(struct mg_host *host, u32 expect, u32 msec)\r\n{\r\nu8 status;\r\nunsigned long expire, cur_jiffies;\r\nstruct mg_drv_data *prv_data = host->dev->platform_data;\r\nhost->error = MG_ERR_NONE;\r\nexpire = jiffies + msecs_to_jiffies(msec);\r\nif (prv_data->use_polling) {\r\nstatus = inb((unsigned long)host->dev_base + MG_REG_STATUS);\r\nstatus = inb((unsigned long)host->dev_base + MG_REG_STATUS);\r\n}\r\nstatus = inb((unsigned long)host->dev_base + MG_REG_STATUS);\r\ndo {\r\ncur_jiffies = jiffies;\r\nif (status & ATA_BUSY) {\r\nif (expect == ATA_BUSY)\r\nbreak;\r\n} else {\r\nif (status & ATA_ERR) {\r\nmg_dump_status("mg_wait", status, host);\r\nbreak;\r\n}\r\nif (expect == MG_STAT_READY)\r\nif (MG_READY_OK(status))\r\nbreak;\r\nif (expect == ATA_DRQ)\r\nif (status & ATA_DRQ)\r\nbreak;\r\n}\r\nif (!msec) {\r\nmg_dump_status("not ready", status, host);\r\nreturn MG_ERR_INV_STAT;\r\n}\r\nstatus = inb((unsigned long)host->dev_base + MG_REG_STATUS);\r\n} while (time_before(cur_jiffies, expire));\r\nif (time_after_eq(cur_jiffies, expire) && msec)\r\nhost->error = MG_ERR_TIMEOUT;\r\nreturn host->error;\r\n}\r\nstatic unsigned int mg_wait_rstout(u32 rstout, u32 msec)\r\n{\r\nunsigned long expire;\r\nexpire = jiffies + msecs_to_jiffies(msec);\r\nwhile (time_before(jiffies, expire)) {\r\nif (gpio_get_value(rstout) == 1)\r\nreturn MG_ERR_NONE;\r\nmsleep(10);\r\n}\r\nreturn MG_ERR_RSTOUT;\r\n}\r\nstatic void mg_unexpected_intr(struct mg_host *host)\r\n{\r\nu32 status = inb((unsigned long)host->dev_base + MG_REG_STATUS);\r\nmg_dump_status("mg_unexpected_intr", status, host);\r\n}\r\nstatic irqreturn_t mg_irq(int irq, void *dev_id)\r\n{\r\nstruct mg_host *host = dev_id;\r\nvoid (*handler)(struct mg_host *) = host->mg_do_intr;\r\nspin_lock(&host->lock);\r\nhost->mg_do_intr = NULL;\r\ndel_timer(&host->timer);\r\nif (!handler)\r\nhandler = mg_unexpected_intr;\r\nhandler(host);\r\nspin_unlock(&host->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mg_id_string(const u16 *id, unsigned char *s,\r\nunsigned int ofs, unsigned int len)\r\n{\r\nunsigned int c;\r\nBUG_ON(len & 1);\r\nwhile (len > 0) {\r\nc = id[ofs] >> 8;\r\n*s = c;\r\ns++;\r\nc = id[ofs] & 0xff;\r\n*s = c;\r\ns++;\r\nofs++;\r\nlen -= 2;\r\n}\r\n}\r\nstatic void mg_id_c_string(const u16 *id, unsigned char *s,\r\nunsigned int ofs, unsigned int len)\r\n{\r\nunsigned char *p;\r\nmg_id_string(id, s, ofs, len - 1);\r\np = s + strnlen(s, len - 1);\r\nwhile (p > s && p[-1] == ' ')\r\np--;\r\n*p = '\0';\r\n}\r\nstatic int mg_get_disk_id(struct mg_host *host)\r\n{\r\nu32 i;\r\ns32 err;\r\nconst u16 *id = host->id;\r\nstruct mg_drv_data *prv_data = host->dev->platform_data;\r\nchar fwrev[ATA_ID_FW_REV_LEN + 1];\r\nchar model[ATA_ID_PROD_LEN + 1];\r\nchar serial[ATA_ID_SERNO_LEN + 1];\r\nif (!prv_data->use_polling)\r\noutb(ATA_NIEN, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);\r\noutb(MG_CMD_ID, (unsigned long)host->dev_base + MG_REG_COMMAND);\r\nerr = mg_wait(host, ATA_DRQ, MG_TMAX_WAIT_RD_DRQ);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < (MG_SECTOR_SIZE >> 1); i++)\r\nhost->id[i] = le16_to_cpu(inw((unsigned long)host->dev_base +\r\nMG_BUFF_OFFSET + i * 2));\r\noutb(MG_CMD_RD_CONF, (unsigned long)host->dev_base + MG_REG_COMMAND);\r\nerr = mg_wait(host, MG_STAT_READY, MG_TMAX_CONF_TO_CMD);\r\nif (err)\r\nreturn err;\r\nif ((id[ATA_ID_FIELD_VALID] & 1) == 0)\r\nreturn MG_ERR_TRANSLATION;\r\nhost->n_sectors = ata_id_u32(id, ATA_ID_LBA_CAPACITY);\r\nhost->cyls = id[ATA_ID_CYLS];\r\nhost->heads = id[ATA_ID_HEADS];\r\nhost->sectors = id[ATA_ID_SECTORS];\r\nif (MG_RES_SEC && host->heads && host->sectors) {\r\nhost->cyls = (host->n_sectors - MG_RES_SEC) /\r\nhost->heads / host->sectors;\r\nhost->nres_sectors = host->n_sectors - host->cyls *\r\nhost->heads * host->sectors;\r\nhost->n_sectors -= host->nres_sectors;\r\n}\r\nmg_id_c_string(id, fwrev, ATA_ID_FW_REV, sizeof(fwrev));\r\nmg_id_c_string(id, model, ATA_ID_PROD, sizeof(model));\r\nmg_id_c_string(id, serial, ATA_ID_SERNO, sizeof(serial));\r\nprintk(KERN_INFO "mg_disk: model: %s\n", model);\r\nprintk(KERN_INFO "mg_disk: firm: %.8s\n", fwrev);\r\nprintk(KERN_INFO "mg_disk: serial: %s\n", serial);\r\nprintk(KERN_INFO "mg_disk: %d + reserved %d sectors\n",\r\nhost->n_sectors, host->nres_sectors);\r\nif (!prv_data->use_polling)\r\noutb(0, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);\r\nreturn err;\r\n}\r\nstatic int mg_disk_init(struct mg_host *host)\r\n{\r\nstruct mg_drv_data *prv_data = host->dev->platform_data;\r\ns32 err;\r\nu8 init_status;\r\ngpio_set_value(host->rst, 0);\r\nerr = mg_wait(host, ATA_BUSY, MG_TMAX_RST_TO_BUSY);\r\nif (err)\r\nreturn err;\r\ngpio_set_value(host->rst, 1);\r\nerr = mg_wait(host, MG_STAT_READY, MG_TMAX_HDRST_TO_RDY);\r\nif (err)\r\nreturn err;\r\noutb(ATA_SRST | (prv_data->use_polling ? ATA_NIEN : 0),\r\n(unsigned long)host->dev_base + MG_REG_DRV_CTRL);\r\nerr = mg_wait(host, ATA_BUSY, MG_TMAX_RST_TO_BUSY);\r\nif (err)\r\nreturn err;\r\noutb(prv_data->use_polling ? ATA_NIEN : 0,\r\n(unsigned long)host->dev_base + MG_REG_DRV_CTRL);\r\nerr = mg_wait(host, MG_STAT_READY, MG_TMAX_SWRST_TO_RDY);\r\nif (err)\r\nreturn err;\r\ninit_status = inb((unsigned long)host->dev_base + MG_REG_STATUS) & 0xf;\r\nif (init_status == 0xf)\r\nreturn MG_ERR_INIT_STAT;\r\nreturn err;\r\n}\r\nstatic void mg_bad_rw_intr(struct mg_host *host)\r\n{\r\nif (host->req)\r\nif (++host->req->errors >= MG_MAX_ERRORS ||\r\nhost->error == MG_ERR_TIMEOUT)\r\nmg_end_request_cur(host, -EIO);\r\n}\r\nstatic unsigned int mg_out(struct mg_host *host,\r\nunsigned int sect_num,\r\nunsigned int sect_cnt,\r\nunsigned int cmd,\r\nvoid (*intr_addr)(struct mg_host *))\r\n{\r\nstruct mg_drv_data *prv_data = host->dev->platform_data;\r\nif (mg_wait(host, MG_STAT_READY, MG_TMAX_CONF_TO_CMD))\r\nreturn host->error;\r\nif (!prv_data->use_polling) {\r\nhost->mg_do_intr = intr_addr;\r\nmod_timer(&host->timer, jiffies + 3 * HZ);\r\n}\r\nif (MG_RES_SEC)\r\nsect_num += MG_RES_SEC;\r\noutb((u8)sect_cnt, (unsigned long)host->dev_base + MG_REG_SECT_CNT);\r\noutb((u8)sect_num, (unsigned long)host->dev_base + MG_REG_SECT_NUM);\r\noutb((u8)(sect_num >> 8), (unsigned long)host->dev_base +\r\nMG_REG_CYL_LOW);\r\noutb((u8)(sect_num >> 16), (unsigned long)host->dev_base +\r\nMG_REG_CYL_HIGH);\r\noutb((u8)((sect_num >> 24) | ATA_LBA | ATA_DEVICE_OBS),\r\n(unsigned long)host->dev_base + MG_REG_DRV_HEAD);\r\noutb(cmd, (unsigned long)host->dev_base + MG_REG_COMMAND);\r\nreturn MG_ERR_NONE;\r\n}\r\nstatic void mg_read_one(struct mg_host *host, struct request *req)\r\n{\r\nu16 *buff = (u16 *)req->buffer;\r\nu32 i;\r\nfor (i = 0; i < MG_SECTOR_SIZE >> 1; i++)\r\n*buff++ = inw((unsigned long)host->dev_base + MG_BUFF_OFFSET +\r\n(i << 1));\r\n}\r\nstatic void mg_read(struct request *req)\r\n{\r\nstruct mg_host *host = req->rq_disk->private_data;\r\nif (mg_out(host, blk_rq_pos(req), blk_rq_sectors(req),\r\nMG_CMD_RD, NULL) != MG_ERR_NONE)\r\nmg_bad_rw_intr(host);\r\nMG_DBG("requested %d sects (from %ld), buffer=0x%p\n",\r\nblk_rq_sectors(req), blk_rq_pos(req), req->buffer);\r\ndo {\r\nif (mg_wait(host, ATA_DRQ,\r\nMG_TMAX_WAIT_RD_DRQ) != MG_ERR_NONE) {\r\nmg_bad_rw_intr(host);\r\nreturn;\r\n}\r\nmg_read_one(host, req);\r\noutb(MG_CMD_RD_CONF, (unsigned long)host->dev_base +\r\nMG_REG_COMMAND);\r\n} while (mg_end_request(host, 0, MG_SECTOR_SIZE));\r\n}\r\nstatic void mg_write_one(struct mg_host *host, struct request *req)\r\n{\r\nu16 *buff = (u16 *)req->buffer;\r\nu32 i;\r\nfor (i = 0; i < MG_SECTOR_SIZE >> 1; i++)\r\noutw(*buff++, (unsigned long)host->dev_base + MG_BUFF_OFFSET +\r\n(i << 1));\r\n}\r\nstatic void mg_write(struct request *req)\r\n{\r\nstruct mg_host *host = req->rq_disk->private_data;\r\nunsigned int rem = blk_rq_sectors(req);\r\nif (mg_out(host, blk_rq_pos(req), rem,\r\nMG_CMD_WR, NULL) != MG_ERR_NONE) {\r\nmg_bad_rw_intr(host);\r\nreturn;\r\n}\r\nMG_DBG("requested %d sects (from %ld), buffer=0x%p\n",\r\nrem, blk_rq_pos(req), req->buffer);\r\nif (mg_wait(host, ATA_DRQ,\r\nMG_TMAX_WAIT_WR_DRQ) != MG_ERR_NONE) {\r\nmg_bad_rw_intr(host);\r\nreturn;\r\n}\r\ndo {\r\nmg_write_one(host, req);\r\noutb(MG_CMD_WR_CONF, (unsigned long)host->dev_base +\r\nMG_REG_COMMAND);\r\nrem--;\r\nif (rem > 1 && mg_wait(host, ATA_DRQ,\r\nMG_TMAX_WAIT_WR_DRQ) != MG_ERR_NONE) {\r\nmg_bad_rw_intr(host);\r\nreturn;\r\n} else if (mg_wait(host, MG_STAT_READY,\r\nMG_TMAX_WAIT_WR_DRQ) != MG_ERR_NONE) {\r\nmg_bad_rw_intr(host);\r\nreturn;\r\n}\r\n} while (mg_end_request(host, 0, MG_SECTOR_SIZE));\r\n}\r\nstatic void mg_read_intr(struct mg_host *host)\r\n{\r\nstruct request *req = host->req;\r\nu32 i;\r\ndo {\r\ni = inb((unsigned long)host->dev_base + MG_REG_STATUS);\r\nif (i & ATA_BUSY)\r\nbreak;\r\nif (!MG_READY_OK(i))\r\nbreak;\r\nif (i & ATA_DRQ)\r\ngoto ok_to_read;\r\n} while (0);\r\nmg_dump_status("mg_read_intr", i, host);\r\nmg_bad_rw_intr(host);\r\nmg_request(host->breq);\r\nreturn;\r\nok_to_read:\r\nmg_read_one(host, req);\r\nMG_DBG("sector %ld, remaining=%ld, buffer=0x%p\n",\r\nblk_rq_pos(req), blk_rq_sectors(req) - 1, req->buffer);\r\noutb(MG_CMD_RD_CONF, (unsigned long)host->dev_base + MG_REG_COMMAND);\r\nif (mg_end_request(host, 0, MG_SECTOR_SIZE)) {\r\nhost->mg_do_intr = mg_read_intr;\r\nmod_timer(&host->timer, jiffies + 3 * HZ);\r\n} else\r\nmg_request(host->breq);\r\n}\r\nstatic void mg_write_intr(struct mg_host *host)\r\n{\r\nstruct request *req = host->req;\r\nu32 i;\r\nbool rem;\r\ndo {\r\ni = inb((unsigned long)host->dev_base + MG_REG_STATUS);\r\nif (i & ATA_BUSY)\r\nbreak;\r\nif (!MG_READY_OK(i))\r\nbreak;\r\nif ((blk_rq_sectors(req) <= 1) || (i & ATA_DRQ))\r\ngoto ok_to_write;\r\n} while (0);\r\nmg_dump_status("mg_write_intr", i, host);\r\nmg_bad_rw_intr(host);\r\nmg_request(host->breq);\r\nreturn;\r\nok_to_write:\r\nif ((rem = mg_end_request(host, 0, MG_SECTOR_SIZE))) {\r\nmg_write_one(host, req);\r\nMG_DBG("sector %ld, remaining=%ld, buffer=0x%p\n",\r\nblk_rq_pos(req), blk_rq_sectors(req), req->buffer);\r\nhost->mg_do_intr = mg_write_intr;\r\nmod_timer(&host->timer, jiffies + 3 * HZ);\r\n}\r\noutb(MG_CMD_WR_CONF, (unsigned long)host->dev_base + MG_REG_COMMAND);\r\nif (!rem)\r\nmg_request(host->breq);\r\n}\r\nstatic void mg_times_out(unsigned long data)\r\n{\r\nstruct mg_host *host = (struct mg_host *)data;\r\nchar *name;\r\nspin_lock_irq(&host->lock);\r\nif (!host->req)\r\ngoto out_unlock;\r\nhost->mg_do_intr = NULL;\r\nname = host->req->rq_disk->disk_name;\r\nprintk(KERN_DEBUG "%s: timeout\n", name);\r\nhost->error = MG_ERR_TIMEOUT;\r\nmg_bad_rw_intr(host);\r\nout_unlock:\r\nmg_request(host->breq);\r\nspin_unlock_irq(&host->lock);\r\n}\r\nstatic void mg_request_poll(struct request_queue *q)\r\n{\r\nstruct mg_host *host = q->queuedata;\r\nwhile (1) {\r\nif (!host->req) {\r\nhost->req = blk_fetch_request(q);\r\nif (!host->req)\r\nbreak;\r\n}\r\nif (unlikely(host->req->cmd_type != REQ_TYPE_FS)) {\r\nmg_end_request_cur(host, -EIO);\r\ncontinue;\r\n}\r\nif (rq_data_dir(host->req) == READ)\r\nmg_read(host->req);\r\nelse\r\nmg_write(host->req);\r\n}\r\n}\r\nstatic unsigned int mg_issue_req(struct request *req,\r\nstruct mg_host *host,\r\nunsigned int sect_num,\r\nunsigned int sect_cnt)\r\n{\r\nswitch (rq_data_dir(req)) {\r\ncase READ:\r\nif (mg_out(host, sect_num, sect_cnt, MG_CMD_RD, &mg_read_intr)\r\n!= MG_ERR_NONE) {\r\nmg_bad_rw_intr(host);\r\nreturn host->error;\r\n}\r\nbreak;\r\ncase WRITE:\r\noutb(ATA_NIEN, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);\r\nif (mg_out(host, sect_num, sect_cnt, MG_CMD_WR, &mg_write_intr)\r\n!= MG_ERR_NONE) {\r\nmg_bad_rw_intr(host);\r\nreturn host->error;\r\n}\r\ndel_timer(&host->timer);\r\nmg_wait(host, ATA_DRQ, MG_TMAX_WAIT_WR_DRQ);\r\noutb(0, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);\r\nif (host->error) {\r\nmg_bad_rw_intr(host);\r\nreturn host->error;\r\n}\r\nmg_write_one(host, req);\r\nmod_timer(&host->timer, jiffies + 3 * HZ);\r\noutb(MG_CMD_WR_CONF, (unsigned long)host->dev_base +\r\nMG_REG_COMMAND);\r\nbreak;\r\n}\r\nreturn MG_ERR_NONE;\r\n}\r\nstatic void mg_request(struct request_queue *q)\r\n{\r\nstruct mg_host *host = q->queuedata;\r\nstruct request *req;\r\nu32 sect_num, sect_cnt;\r\nwhile (1) {\r\nif (!host->req) {\r\nhost->req = blk_fetch_request(q);\r\nif (!host->req)\r\nbreak;\r\n}\r\nreq = host->req;\r\nif (host->mg_do_intr)\r\nreturn;\r\ndel_timer(&host->timer);\r\nsect_num = blk_rq_pos(req);\r\nsect_cnt = blk_rq_sectors(req);\r\nif (sect_num >= get_capacity(req->rq_disk) ||\r\n((sect_num + sect_cnt) >\r\nget_capacity(req->rq_disk))) {\r\nprintk(KERN_WARNING\r\n"%s: bad access: sector=%d, count=%d\n",\r\nreq->rq_disk->disk_name,\r\nsect_num, sect_cnt);\r\nmg_end_request_cur(host, -EIO);\r\ncontinue;\r\n}\r\nif (unlikely(req->cmd_type != REQ_TYPE_FS)) {\r\nmg_end_request_cur(host, -EIO);\r\ncontinue;\r\n}\r\nif (!mg_issue_req(req, host, sect_num, sect_cnt))\r\nreturn;\r\n}\r\n}\r\nstatic int mg_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct mg_host *host = bdev->bd_disk->private_data;\r\ngeo->cylinders = (unsigned short)host->cyls;\r\ngeo->heads = (unsigned char)host->heads;\r\ngeo->sectors = (unsigned char)host->sectors;\r\nreturn 0;\r\n}\r\nstatic int mg_suspend(struct device *dev)\r\n{\r\nstruct mg_drv_data *prv_data = dev->platform_data;\r\nstruct mg_host *host = prv_data->host;\r\nif (mg_wait(host, MG_STAT_READY, MG_TMAX_CONF_TO_CMD))\r\nreturn -EIO;\r\nif (!prv_data->use_polling)\r\noutb(ATA_NIEN, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);\r\noutb(MG_CMD_SLEEP, (unsigned long)host->dev_base + MG_REG_COMMAND);\r\nmsleep(1);\r\nif (mg_wait(host, MG_STAT_READY, MG_TMAX_CONF_TO_CMD)) {\r\nif (!prv_data->use_polling)\r\noutb(0, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mg_resume(struct device *dev)\r\n{\r\nstruct mg_drv_data *prv_data = dev->platform_data;\r\nstruct mg_host *host = prv_data->host;\r\nif (mg_wait(host, MG_STAT_READY, MG_TMAX_CONF_TO_CMD))\r\nreturn -EIO;\r\noutb(MG_CMD_WAKEUP, (unsigned long)host->dev_base + MG_REG_COMMAND);\r\nmsleep(1);\r\nif (mg_wait(host, MG_STAT_READY, MG_TMAX_CONF_TO_CMD))\r\nreturn -EIO;\r\nif (!prv_data->use_polling)\r\noutb(0, (unsigned long)host->dev_base + MG_REG_DRV_CTRL);\r\nreturn 0;\r\n}\r\nstatic int mg_probe(struct platform_device *plat_dev)\r\n{\r\nstruct mg_host *host;\r\nstruct resource *rsc;\r\nstruct mg_drv_data *prv_data = plat_dev->dev.platform_data;\r\nint err = 0;\r\nif (!prv_data) {\r\nprintk(KERN_ERR "%s:%d fail (no driver_data)\n",\r\n__func__, __LINE__);\r\nerr = -EINVAL;\r\ngoto probe_err;\r\n}\r\nhost = kzalloc(sizeof(struct mg_host), GFP_KERNEL);\r\nif (!host) {\r\nprintk(KERN_ERR "%s:%d fail (no memory for mg_host)\n",\r\n__func__, __LINE__);\r\nerr = -ENOMEM;\r\ngoto probe_err;\r\n}\r\nhost->major = MG_DISK_MAJ;\r\nprv_data->host = host;\r\nhost->dev = &plat_dev->dev;\r\nrsc = platform_get_resource(plat_dev, IORESOURCE_MEM, 0);\r\nif (!rsc) {\r\nprintk(KERN_ERR "%s:%d platform_get_resource fail\n",\r\n__func__, __LINE__);\r\nerr = -EINVAL;\r\ngoto probe_err_2;\r\n}\r\nhost->dev_base = ioremap(rsc->start, resource_size(rsc));\r\nif (!host->dev_base) {\r\nprintk(KERN_ERR "%s:%d ioremap fail\n",\r\n__func__, __LINE__);\r\nerr = -EIO;\r\ngoto probe_err_2;\r\n}\r\nMG_DBG("dev_base = 0x%x\n", (u32)host->dev_base);\r\nrsc = platform_get_resource_byname(plat_dev, IORESOURCE_IO,\r\nMG_RST_PIN);\r\nif (!rsc) {\r\nprintk(KERN_ERR "%s:%d get reset pin fail\n",\r\n__func__, __LINE__);\r\nerr = -EIO;\r\ngoto probe_err_3;\r\n}\r\nhost->rst = rsc->start;\r\nerr = gpio_request(host->rst, MG_RST_PIN);\r\nif (err)\r\ngoto probe_err_3;\r\ngpio_direction_output(host->rst, 1);\r\nif (!(prv_data->dev_attr & MG_DEV_MASK)) {\r\nerr = -EINVAL;\r\ngoto probe_err_3a;\r\n}\r\nif (prv_data->dev_attr != MG_BOOT_DEV) {\r\nrsc = platform_get_resource_byname(plat_dev, IORESOURCE_IO,\r\nMG_RSTOUT_PIN);\r\nif (!rsc) {\r\nprintk(KERN_ERR "%s:%d get reset-out pin fail\n",\r\n__func__, __LINE__);\r\nerr = -EIO;\r\ngoto probe_err_3a;\r\n}\r\nhost->rstout = rsc->start;\r\nerr = gpio_request(host->rstout, MG_RSTOUT_PIN);\r\nif (err)\r\ngoto probe_err_3a;\r\ngpio_direction_input(host->rstout);\r\n}\r\nif (prv_data->dev_attr == MG_STORAGE_DEV) {\r\nerr = mg_wait_rstout(host->rstout, MG_TMAX_RSTOUT);\r\nif (err)\r\ngoto probe_err_3b;\r\nerr = mg_disk_init(host);\r\nif (err) {\r\nprintk(KERN_ERR "%s:%d fail (err code : %d)\n",\r\n__func__, __LINE__, err);\r\nerr = -EIO;\r\ngoto probe_err_3b;\r\n}\r\n}\r\nif (!prv_data->use_polling) {\r\nhost->irq = platform_get_irq(plat_dev, 0);\r\nif (host->irq == -ENXIO) {\r\nerr = host->irq;\r\ngoto probe_err_3b;\r\n}\r\nerr = request_irq(host->irq, mg_irq,\r\nIRQF_TRIGGER_RISING,\r\nMG_DEV_NAME, host);\r\nif (err) {\r\nprintk(KERN_ERR "%s:%d fail (request_irq err=%d)\n",\r\n__func__, __LINE__, err);\r\ngoto probe_err_3b;\r\n}\r\n}\r\nerr = mg_get_disk_id(host);\r\nif (err) {\r\nprintk(KERN_ERR "%s:%d fail (err code : %d)\n",\r\n__func__, __LINE__, err);\r\nerr = -EIO;\r\ngoto probe_err_4;\r\n}\r\nerr = register_blkdev(host->major, MG_DISK_NAME);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s:%d register_blkdev fail (err code : %d)\n",\r\n__func__, __LINE__, err);\r\ngoto probe_err_4;\r\n}\r\nif (!host->major)\r\nhost->major = err;\r\nspin_lock_init(&host->lock);\r\nif (prv_data->use_polling)\r\nhost->breq = blk_init_queue(mg_request_poll, &host->lock);\r\nelse\r\nhost->breq = blk_init_queue(mg_request, &host->lock);\r\nif (!host->breq) {\r\nerr = -ENOMEM;\r\nprintk(KERN_ERR "%s:%d (blk_init_queue) fail\n",\r\n__func__, __LINE__);\r\ngoto probe_err_5;\r\n}\r\nhost->breq->queuedata = host;\r\nerr = elevator_change(host->breq, "noop");\r\nif (err) {\r\nprintk(KERN_ERR "%s:%d (elevator_init) fail\n",\r\n__func__, __LINE__);\r\ngoto probe_err_6;\r\n}\r\nblk_queue_max_hw_sectors(host->breq, MG_MAX_SECTS);\r\nblk_queue_logical_block_size(host->breq, MG_SECTOR_SIZE);\r\ninit_timer(&host->timer);\r\nhost->timer.function = mg_times_out;\r\nhost->timer.data = (unsigned long)host;\r\nhost->gd = alloc_disk(MG_DISK_MAX_PART);\r\nif (!host->gd) {\r\nprintk(KERN_ERR "%s:%d (alloc_disk) fail\n",\r\n__func__, __LINE__);\r\nerr = -ENOMEM;\r\ngoto probe_err_7;\r\n}\r\nhost->gd->major = host->major;\r\nhost->gd->first_minor = 0;\r\nhost->gd->fops = &mg_disk_ops;\r\nhost->gd->queue = host->breq;\r\nhost->gd->private_data = host;\r\nsprintf(host->gd->disk_name, MG_DISK_NAME"a");\r\nset_capacity(host->gd, host->n_sectors);\r\nadd_disk(host->gd);\r\nreturn err;\r\nprobe_err_7:\r\ndel_timer_sync(&host->timer);\r\nprobe_err_6:\r\nblk_cleanup_queue(host->breq);\r\nprobe_err_5:\r\nunregister_blkdev(MG_DISK_MAJ, MG_DISK_NAME);\r\nprobe_err_4:\r\nif (!prv_data->use_polling)\r\nfree_irq(host->irq, host);\r\nprobe_err_3b:\r\ngpio_free(host->rstout);\r\nprobe_err_3a:\r\ngpio_free(host->rst);\r\nprobe_err_3:\r\niounmap(host->dev_base);\r\nprobe_err_2:\r\nkfree(host);\r\nprobe_err:\r\nreturn err;\r\n}\r\nstatic int mg_remove(struct platform_device *plat_dev)\r\n{\r\nstruct mg_drv_data *prv_data = plat_dev->dev.platform_data;\r\nstruct mg_host *host = prv_data->host;\r\nint err = 0;\r\ndel_timer_sync(&host->timer);\r\nif (host->gd) {\r\ndel_gendisk(host->gd);\r\nput_disk(host->gd);\r\n}\r\nif (host->breq)\r\nblk_cleanup_queue(host->breq);\r\nunregister_blkdev(host->major, MG_DISK_NAME);\r\nif (!prv_data->use_polling)\r\nfree_irq(host->irq, host);\r\nif (prv_data->dev_attr != MG_BOOT_DEV)\r\ngpio_free(host->rstout);\r\nif (host->rst)\r\ngpio_free(host->rst);\r\nif (host->dev_base)\r\niounmap(host->dev_base);\r\nkfree(host);\r\nreturn err;\r\n}\r\nstatic int __init mg_init(void)\r\n{\r\nprintk(KERN_INFO "mGine mflash driver, (c) 2008 mGine Co.\n");\r\nreturn platform_driver_register(&mg_disk_driver);\r\n}\r\nstatic void __exit mg_exit(void)\r\n{\r\nprintk(KERN_INFO "mflash driver : bye bye\n");\r\nplatform_driver_unregister(&mg_disk_driver);\r\n}
