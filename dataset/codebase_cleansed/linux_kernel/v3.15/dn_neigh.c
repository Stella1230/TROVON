static u32 dn_neigh_hash(const void *pkey,\r\nconst struct net_device *dev,\r\n__u32 *hash_rnd)\r\n{\r\nreturn jhash_2words(*(__u16 *)pkey, 0, hash_rnd[0]);\r\n}\r\nstatic int dn_neigh_construct(struct neighbour *neigh)\r\n{\r\nstruct net_device *dev = neigh->dev;\r\nstruct dn_neigh *dn = (struct dn_neigh *)neigh;\r\nstruct dn_dev *dn_db;\r\nstruct neigh_parms *parms;\r\nrcu_read_lock();\r\ndn_db = rcu_dereference(dev->dn_ptr);\r\nif (dn_db == NULL) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\nparms = dn_db->neigh_parms;\r\nif (!parms) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\n__neigh_parms_put(neigh->parms);\r\nneigh->parms = neigh_parms_clone(parms);\r\nif (dn_db->use_long)\r\nneigh->ops = &dn_long_ops;\r\nelse\r\nneigh->ops = &dn_short_ops;\r\nrcu_read_unlock();\r\nif (dn->flags & DN_NDFLAG_P3)\r\nneigh->ops = &dn_phase3_ops;\r\nneigh->nud_state = NUD_NOARP;\r\nneigh->output = neigh->ops->connected_output;\r\nif ((dev->type == ARPHRD_IPGRE) || (dev->flags & IFF_POINTOPOINT))\r\nmemcpy(neigh->ha, dev->broadcast, dev->addr_len);\r\nelse if ((dev->type == ARPHRD_ETHER) || (dev->type == ARPHRD_LOOPBACK))\r\ndn_dn2eth(neigh->ha, dn->addr);\r\nelse {\r\nnet_dbg_ratelimited("Trying to create neigh for hw %d\n",\r\ndev->type);\r\nreturn -EINVAL;\r\n}\r\ndn->blksize = dev->mtu - 2;\r\nreturn 0;\r\n}\r\nstatic void dn_long_error_report(struct neighbour *neigh, struct sk_buff *skb)\r\n{\r\nprintk(KERN_DEBUG "dn_long_error_report: called\n");\r\nkfree_skb(skb);\r\n}\r\nstatic void dn_short_error_report(struct neighbour *neigh, struct sk_buff *skb)\r\n{\r\nprintk(KERN_DEBUG "dn_short_error_report: called\n");\r\nkfree_skb(skb);\r\n}\r\nstatic int dn_neigh_output_packet(struct sk_buff *skb)\r\n{\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct dn_route *rt = (struct dn_route *)dst;\r\nstruct neighbour *neigh = rt->n;\r\nstruct net_device *dev = neigh->dev;\r\nchar mac_addr[ETH_ALEN];\r\nunsigned int seq;\r\nint err;\r\ndn_dn2eth(mac_addr, rt->rt_local_src);\r\ndo {\r\nseq = read_seqbegin(&neigh->ha_lock);\r\nerr = dev_hard_header(skb, dev, ntohs(skb->protocol),\r\nneigh->ha, mac_addr, skb->len);\r\n} while (read_seqretry(&neigh->ha_lock, seq));\r\nif (err >= 0)\r\nerr = dev_queue_xmit(skb);\r\nelse {\r\nkfree_skb(skb);\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int dn_long_output(struct neighbour *neigh, struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = neigh->dev;\r\nint headroom = dev->hard_header_len + sizeof(struct dn_long_packet) + 3;\r\nunsigned char *data;\r\nstruct dn_long_packet *lp;\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nif (skb_headroom(skb) < headroom) {\r\nstruct sk_buff *skb2 = skb_realloc_headroom(skb, headroom);\r\nif (skb2 == NULL) {\r\nnet_crit_ratelimited("dn_long_output: no memory\n");\r\nkfree_skb(skb);\r\nreturn -ENOBUFS;\r\n}\r\nconsume_skb(skb);\r\nskb = skb2;\r\nnet_info_ratelimited("dn_long_output: Increasing headroom\n");\r\n}\r\ndata = skb_push(skb, sizeof(struct dn_long_packet) + 3);\r\nlp = (struct dn_long_packet *)(data+3);\r\n*((__le16 *)data) = cpu_to_le16(skb->len - 2);\r\n*(data + 2) = 1 | DN_RT_F_PF;\r\nlp->msgflg = DN_RT_PKT_LONG|(cb->rt_flags&(DN_RT_F_IE|DN_RT_F_RQR|DN_RT_F_RTS));\r\nlp->d_area = lp->d_subarea = 0;\r\ndn_dn2eth(lp->d_id, cb->dst);\r\nlp->s_area = lp->s_subarea = 0;\r\ndn_dn2eth(lp->s_id, cb->src);\r\nlp->nl2 = 0;\r\nlp->visit_ct = cb->hops & 0x3f;\r\nlp->s_class = 0;\r\nlp->pt = 0;\r\nskb_reset_network_header(skb);\r\nreturn NF_HOOK(NFPROTO_DECNET, NF_DN_POST_ROUTING, skb, NULL,\r\nneigh->dev, dn_neigh_output_packet);\r\n}\r\nstatic int dn_short_output(struct neighbour *neigh, struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = neigh->dev;\r\nint headroom = dev->hard_header_len + sizeof(struct dn_short_packet) + 2;\r\nstruct dn_short_packet *sp;\r\nunsigned char *data;\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nif (skb_headroom(skb) < headroom) {\r\nstruct sk_buff *skb2 = skb_realloc_headroom(skb, headroom);\r\nif (skb2 == NULL) {\r\nnet_crit_ratelimited("dn_short_output: no memory\n");\r\nkfree_skb(skb);\r\nreturn -ENOBUFS;\r\n}\r\nconsume_skb(skb);\r\nskb = skb2;\r\nnet_info_ratelimited("dn_short_output: Increasing headroom\n");\r\n}\r\ndata = skb_push(skb, sizeof(struct dn_short_packet) + 2);\r\n*((__le16 *)data) = cpu_to_le16(skb->len - 2);\r\nsp = (struct dn_short_packet *)(data+2);\r\nsp->msgflg = DN_RT_PKT_SHORT|(cb->rt_flags&(DN_RT_F_RQR|DN_RT_F_RTS));\r\nsp->dstnode = cb->dst;\r\nsp->srcnode = cb->src;\r\nsp->forward = cb->hops & 0x3f;\r\nskb_reset_network_header(skb);\r\nreturn NF_HOOK(NFPROTO_DECNET, NF_DN_POST_ROUTING, skb, NULL,\r\nneigh->dev, dn_neigh_output_packet);\r\n}\r\nstatic int dn_phase3_output(struct neighbour *neigh, struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = neigh->dev;\r\nint headroom = dev->hard_header_len + sizeof(struct dn_short_packet) + 2;\r\nstruct dn_short_packet *sp;\r\nunsigned char *data;\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nif (skb_headroom(skb) < headroom) {\r\nstruct sk_buff *skb2 = skb_realloc_headroom(skb, headroom);\r\nif (skb2 == NULL) {\r\nnet_crit_ratelimited("dn_phase3_output: no memory\n");\r\nkfree_skb(skb);\r\nreturn -ENOBUFS;\r\n}\r\nconsume_skb(skb);\r\nskb = skb2;\r\nnet_info_ratelimited("dn_phase3_output: Increasing headroom\n");\r\n}\r\ndata = skb_push(skb, sizeof(struct dn_short_packet) + 2);\r\n*((__le16 *)data) = cpu_to_le16(skb->len - 2);\r\nsp = (struct dn_short_packet *)(data + 2);\r\nsp->msgflg = DN_RT_PKT_SHORT|(cb->rt_flags&(DN_RT_F_RQR|DN_RT_F_RTS));\r\nsp->dstnode = cb->dst & cpu_to_le16(0x03ff);\r\nsp->srcnode = cb->src & cpu_to_le16(0x03ff);\r\nsp->forward = cb->hops & 0x3f;\r\nskb_reset_network_header(skb);\r\nreturn NF_HOOK(NFPROTO_DECNET, NF_DN_POST_ROUTING, skb, NULL,\r\nneigh->dev, dn_neigh_output_packet);\r\n}\r\nvoid dn_neigh_pointopoint_hello(struct sk_buff *skb)\r\n{\r\nkfree_skb(skb);\r\n}\r\nint dn_neigh_router_hello(struct sk_buff *skb)\r\n{\r\nstruct rtnode_hello_message *msg = (struct rtnode_hello_message *)skb->data;\r\nstruct neighbour *neigh;\r\nstruct dn_neigh *dn;\r\nstruct dn_dev *dn_db;\r\n__le16 src;\r\nsrc = dn_eth2dn(msg->id);\r\nneigh = __neigh_lookup(&dn_neigh_table, &src, skb->dev, 1);\r\ndn = (struct dn_neigh *)neigh;\r\nif (neigh) {\r\nwrite_lock(&neigh->lock);\r\nneigh->used = jiffies;\r\ndn_db = rcu_dereference(neigh->dev->dn_ptr);\r\nif (!(neigh->nud_state & NUD_PERMANENT)) {\r\nneigh->updated = jiffies;\r\nif (neigh->dev->type == ARPHRD_ETHER)\r\nmemcpy(neigh->ha, &eth_hdr(skb)->h_source, ETH_ALEN);\r\ndn->blksize = le16_to_cpu(msg->blksize);\r\ndn->priority = msg->priority;\r\ndn->flags &= ~DN_NDFLAG_P3;\r\nswitch (msg->iinfo & DN_RT_INFO_TYPE) {\r\ncase DN_RT_INFO_L1RT:\r\ndn->flags &=~DN_NDFLAG_R2;\r\ndn->flags |= DN_NDFLAG_R1;\r\nbreak;\r\ncase DN_RT_INFO_L2RT:\r\ndn->flags |= DN_NDFLAG_R2;\r\n}\r\n}\r\nif ((le16_to_cpu(src)>>10) == (le16_to_cpu((decnet_address))>>10)) {\r\nif (!dn_db->router) {\r\ndn_db->router = neigh_clone(neigh);\r\n} else {\r\nif (msg->priority > ((struct dn_neigh *)dn_db->router)->priority)\r\nneigh_release(xchg(&dn_db->router, neigh_clone(neigh)));\r\n}\r\n}\r\nwrite_unlock(&neigh->lock);\r\nneigh_release(neigh);\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint dn_neigh_endnode_hello(struct sk_buff *skb)\r\n{\r\nstruct endnode_hello_message *msg = (struct endnode_hello_message *)skb->data;\r\nstruct neighbour *neigh;\r\nstruct dn_neigh *dn;\r\n__le16 src;\r\nsrc = dn_eth2dn(msg->id);\r\nneigh = __neigh_lookup(&dn_neigh_table, &src, skb->dev, 1);\r\ndn = (struct dn_neigh *)neigh;\r\nif (neigh) {\r\nwrite_lock(&neigh->lock);\r\nneigh->used = jiffies;\r\nif (!(neigh->nud_state & NUD_PERMANENT)) {\r\nneigh->updated = jiffies;\r\nif (neigh->dev->type == ARPHRD_ETHER)\r\nmemcpy(neigh->ha, &eth_hdr(skb)->h_source, ETH_ALEN);\r\ndn->flags &= ~(DN_NDFLAG_R1 | DN_NDFLAG_R2);\r\ndn->blksize = le16_to_cpu(msg->blksize);\r\ndn->priority = 0;\r\n}\r\nwrite_unlock(&neigh->lock);\r\nneigh_release(neigh);\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic char *dn_find_slot(char *base, int max, int priority)\r\n{\r\nint i;\r\nunsigned char *min = NULL;\r\nbase += 6;\r\nfor(i = 0; i < max; i++) {\r\nif (!min || (*base < *min))\r\nmin = base;\r\nbase += 7;\r\n}\r\nif (!min)\r\nreturn NULL;\r\nreturn (*min < priority) ? (min - 6) : NULL;\r\n}\r\nstatic void neigh_elist_cb(struct neighbour *neigh, void *_info)\r\n{\r\nstruct elist_cb_state *s = _info;\r\nstruct dn_neigh *dn;\r\nif (neigh->dev != s->dev)\r\nreturn;\r\ndn = (struct dn_neigh *) neigh;\r\nif (!(dn->flags & (DN_NDFLAG_R1|DN_NDFLAG_R2)))\r\nreturn;\r\nif (s->t == s->n)\r\ns->rs = dn_find_slot(s->ptr, s->n, dn->priority);\r\nelse\r\ns->t++;\r\nif (s->rs == NULL)\r\nreturn;\r\ndn_dn2eth(s->rs, dn->addr);\r\ns->rs += 6;\r\n*(s->rs) = neigh->nud_state & NUD_CONNECTED ? 0x80 : 0x0;\r\n*(s->rs) |= dn->priority;\r\ns->rs++;\r\n}\r\nint dn_neigh_elist(struct net_device *dev, unsigned char *ptr, int n)\r\n{\r\nstruct elist_cb_state state;\r\nstate.dev = dev;\r\nstate.t = 0;\r\nstate.n = n;\r\nstate.ptr = ptr;\r\nstate.rs = ptr;\r\nneigh_for_each(&dn_neigh_table, neigh_elist_cb, &state);\r\nreturn state.t;\r\n}\r\nstatic inline void dn_neigh_format_entry(struct seq_file *seq,\r\nstruct neighbour *n)\r\n{\r\nstruct dn_neigh *dn = (struct dn_neigh *) n;\r\nchar buf[DN_ASCBUF_LEN];\r\nread_lock(&n->lock);\r\nseq_printf(seq, "%-7s %s%s%s %02x %02d %07ld %-8s\n",\r\ndn_addr2asc(le16_to_cpu(dn->addr), buf),\r\n(dn->flags&DN_NDFLAG_R1) ? "1" : "-",\r\n(dn->flags&DN_NDFLAG_R2) ? "2" : "-",\r\n(dn->flags&DN_NDFLAG_P3) ? "3" : "-",\r\ndn->n.nud_state,\r\natomic_read(&dn->n.refcnt),\r\ndn->blksize,\r\n(dn->n.dev) ? dn->n.dev->name : "?");\r\nread_unlock(&n->lock);\r\n}\r\nstatic int dn_neigh_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "Addr Flags State Use Blksize Dev\n");\r\n} else {\r\ndn_neigh_format_entry(seq, v);\r\n}\r\nreturn 0;\r\n}\r\nstatic void *dn_neigh_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn neigh_seq_start(seq, pos, &dn_neigh_table,\r\nNEIGH_SEQ_NEIGH_ONLY);\r\n}\r\nstatic int dn_neigh_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &dn_neigh_seq_ops,\r\nsizeof(struct neigh_seq_state));\r\n}\r\nvoid __init dn_neigh_init(void)\r\n{\r\nneigh_table_init(&dn_neigh_table);\r\nproc_create("decnet_neigh", S_IRUGO, init_net.proc_net,\r\n&dn_neigh_seq_fops);\r\n}\r\nvoid __exit dn_neigh_cleanup(void)\r\n{\r\nremove_proc_entry("decnet_neigh", init_net.proc_net);\r\nneigh_table_clear(&dn_neigh_table);\r\n}
