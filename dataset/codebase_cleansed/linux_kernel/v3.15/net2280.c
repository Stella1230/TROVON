static char *type_string (u8 bmAttributes)\r\n{\r\nswitch ((bmAttributes) & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_BULK: return "bulk";\r\ncase USB_ENDPOINT_XFER_ISOC: return "iso";\r\ncase USB_ENDPOINT_XFER_INT: return "intr";\r\n}\r\nreturn "control";\r\n}\r\nstatic int\r\nnet2280_enable (struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct net2280 *dev;\r\nstruct net2280_ep *ep;\r\nu32 max, tmp;\r\nunsigned long flags;\r\nep = container_of (_ep, struct net2280_ep, ep);\r\nif (!_ep || !desc || ep->desc || _ep->name == ep0name\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT)\r\nreturn -EINVAL;\r\ndev = ep->dev;\r\nif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nif ((desc->bEndpointAddress & 0x0f) == EP_DONTUSE)\r\nreturn -EDOM;\r\nmax = usb_endpoint_maxp (desc) & 0x1fff;\r\nif (ep->num > 4 && max > 64)\r\nreturn -ERANGE;\r\nspin_lock_irqsave (&dev->lock, flags);\r\n_ep->maxpacket = max & 0x7ff;\r\nep->desc = desc;\r\nep->stopped = 0;\r\nep->wedged = 0;\r\nep->out_overflow = 0;\r\nset_idx_reg (dev->regs, REG_EP_MAXPKT (dev, ep->num), max);\r\nif (ep->dma && (max % 4) != 0 && use_dma_chaining) {\r\nDEBUG (ep->dev, "%s, no dma for maxpacket %d\n",\r\nep->ep.name, ep->ep.maxpacket);\r\nep->dma = NULL;\r\n}\r\nwritel ((1 << FIFO_FLUSH), &ep->regs->ep_stat);\r\ntmp = (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK);\r\nif (tmp == USB_ENDPOINT_XFER_INT) {\r\nif (dev->chiprev == 0100\r\n&& dev->gadget.speed == USB_SPEED_HIGH\r\n&& !(desc->bEndpointAddress & USB_DIR_IN))\r\nwritel ((1 << CLEAR_NAK_OUT_PACKETS_MODE),\r\n&ep->regs->ep_rsp);\r\n} else if (tmp == USB_ENDPOINT_XFER_BULK) {\r\nif ((dev->gadget.speed == USB_SPEED_HIGH\r\n&& max != 512)\r\n|| (dev->gadget.speed == USB_SPEED_FULL\r\n&& max > 64)) {\r\nspin_unlock_irqrestore (&dev->lock, flags);\r\nreturn -ERANGE;\r\n}\r\n}\r\nep->is_iso = (tmp == USB_ENDPOINT_XFER_ISOC) ? 1 : 0;\r\ntmp <<= ENDPOINT_TYPE;\r\ntmp |= desc->bEndpointAddress;\r\ntmp |= (4 << ENDPOINT_BYTE_COUNT);\r\ntmp |= 1 << ENDPOINT_ENABLE;\r\nwmb ();\r\nep->is_in = (tmp & USB_DIR_IN) != 0;\r\nif (!ep->is_in)\r\nwritel ((1 << SET_NAK_OUT_PACKETS), &ep->regs->ep_rsp);\r\nelse if (dev->pdev->device != 0x2280) {\r\nwritel ((1 << CLEAR_NAK_OUT_PACKETS)\r\n| (1 << CLEAR_NAK_OUT_PACKETS_MODE), &ep->regs->ep_rsp);\r\n}\r\nwritel (tmp, &ep->regs->ep_cfg);\r\nif (!ep->dma) {\r\ntmp = (1 << ep->num) | readl (&dev->regs->pciirqenb0);\r\nwritel (tmp, &dev->regs->pciirqenb0);\r\ntmp = (1 << DATA_PACKET_RECEIVED_INTERRUPT_ENABLE)\r\n| (1 << DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE);\r\nif (dev->pdev->device == 0x2280)\r\ntmp |= readl (&ep->regs->ep_irqenb);\r\nwritel (tmp, &ep->regs->ep_irqenb);\r\n} else {\r\ntmp = (1 << (8 + ep->num));\r\ntmp |= readl (&dev->regs->pciirqenb1);\r\nwritel (tmp, &dev->regs->pciirqenb1);\r\nif ((desc->bEndpointAddress & USB_DIR_IN) == 0) {\r\ntmp = (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT_ENABLE);\r\nwritel (tmp, &ep->regs->ep_irqenb);\r\ntmp = (1 << ep->num) | readl (&dev->regs->pciirqenb0);\r\nwritel (tmp, &dev->regs->pciirqenb0);\r\n}\r\n}\r\ntmp = desc->bEndpointAddress;\r\nDEBUG (dev, "enabled %s (ep%d%s-%s) %s max %04x\n",\r\n_ep->name, tmp & 0x0f, DIR_STRING (tmp),\r\ntype_string (desc->bmAttributes),\r\nep->dma ? "dma" : "pio", max);\r\nspin_unlock_irqrestore (&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int handshake (u32 __iomem *ptr, u32 mask, u32 done, int usec)\r\n{\r\nu32 result;\r\ndo {\r\nresult = readl (ptr);\r\nif (result == ~(u32)0)\r\nreturn -ENODEV;\r\nresult &= mask;\r\nif (result == done)\r\nreturn 0;\r\nudelay (1);\r\nusec--;\r\n} while (usec > 0);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void ep_reset (struct net2280_regs __iomem *regs, struct net2280_ep *ep)\r\n{\r\nu32 tmp;\r\nep->desc = NULL;\r\nINIT_LIST_HEAD (&ep->queue);\r\nusb_ep_set_maxpacket_limit(&ep->ep, ~0);\r\nep->ep.ops = &net2280_ep_ops;\r\nif (ep->dma) {\r\nwritel (0, &ep->dma->dmactl);\r\nwritel ( (1 << DMA_SCATTER_GATHER_DONE_INTERRUPT)\r\n| (1 << DMA_TRANSACTION_DONE_INTERRUPT)\r\n| (1 << DMA_ABORT)\r\n, &ep->dma->dmastat);\r\ntmp = readl (&regs->pciirqenb0);\r\ntmp &= ~(1 << ep->num);\r\nwritel (tmp, &regs->pciirqenb0);\r\n} else {\r\ntmp = readl (&regs->pciirqenb1);\r\ntmp &= ~(1 << (8 + ep->num));\r\nwritel (tmp, &regs->pciirqenb1);\r\n}\r\nwritel (0, &ep->regs->ep_irqenb);\r\nif (!ep->is_in || ep->dev->pdev->device == 0x2280) {\r\ntmp = (1 << SET_NAK_OUT_PACKETS_MODE)\r\n| (1 << SET_NAK_OUT_PACKETS)\r\n| (1 << CLEAR_EP_HIDE_STATUS_PHASE)\r\n| (1 << CLEAR_INTERRUPT_MODE);\r\n} else {\r\ntmp = (1 << CLEAR_NAK_OUT_PACKETS_MODE)\r\n| (1 << CLEAR_NAK_OUT_PACKETS)\r\n| (1 << CLEAR_EP_HIDE_STATUS_PHASE)\r\n| (1 << CLEAR_INTERRUPT_MODE);\r\n}\r\nif (ep->num != 0) {\r\ntmp |= (1 << CLEAR_ENDPOINT_TOGGLE)\r\n| (1 << CLEAR_ENDPOINT_HALT);\r\n}\r\nwritel (tmp, &ep->regs->ep_rsp);\r\nif (ep->dev->pdev->device == 0x2280)\r\ntmp = (1 << FIFO_OVERFLOW)\r\n| (1 << FIFO_UNDERFLOW);\r\nelse\r\ntmp = 0;\r\nwritel (tmp | (1 << TIMEOUT)\r\n| (1 << USB_STALL_SENT)\r\n| (1 << USB_IN_NAK_SENT)\r\n| (1 << USB_IN_ACK_RCVD)\r\n| (1 << USB_OUT_PING_NAK_SENT)\r\n| (1 << USB_OUT_ACK_SENT)\r\n| (1 << FIFO_FLUSH)\r\n| (1 << SHORT_PACKET_OUT_DONE_INTERRUPT)\r\n| (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT)\r\n| (1 << DATA_PACKET_RECEIVED_INTERRUPT)\r\n| (1 << DATA_PACKET_TRANSMITTED_INTERRUPT)\r\n| (1 << DATA_OUT_PING_TOKEN_INTERRUPT)\r\n| (1 << DATA_IN_TOKEN_INTERRUPT)\r\n, &ep->regs->ep_stat);\r\n}\r\nstatic int net2280_disable (struct usb_ep *_ep)\r\n{\r\nstruct net2280_ep *ep;\r\nunsigned long flags;\r\nep = container_of (_ep, struct net2280_ep, ep);\r\nif (!_ep || !ep->desc || _ep->name == ep0name)\r\nreturn -EINVAL;\r\nspin_lock_irqsave (&ep->dev->lock, flags);\r\nnuke (ep);\r\nep_reset (ep->dev->regs, ep);\r\nVDEBUG (ep->dev, "disabled %s %s\n",\r\nep->dma ? "dma" : "pio", _ep->name);\r\n(void) readl (&ep->regs->ep_cfg);\r\nif (use_dma && !ep->dma && ep->num >= 1 && ep->num <= 4)\r\nep->dma = &ep->dev->dma [ep->num - 1];\r\nspin_unlock_irqrestore (&ep->dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *\r\nnet2280_alloc_request (struct usb_ep *_ep, gfp_t gfp_flags)\r\n{\r\nstruct net2280_ep *ep;\r\nstruct net2280_request *req;\r\nif (!_ep)\r\nreturn NULL;\r\nep = container_of (_ep, struct net2280_ep, ep);\r\nreq = kzalloc(sizeof(*req), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD (&req->queue);\r\nif (ep->dma) {\r\nstruct net2280_dma *td;\r\ntd = pci_pool_alloc (ep->dev->requests, gfp_flags,\r\n&req->td_dma);\r\nif (!td) {\r\nkfree (req);\r\nreturn NULL;\r\n}\r\ntd->dmacount = 0;\r\ntd->dmadesc = td->dmaaddr;\r\nreq->td = td;\r\n}\r\nreturn &req->req;\r\n}\r\nstatic void\r\nnet2280_free_request (struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct net2280_ep *ep;\r\nstruct net2280_request *req;\r\nep = container_of (_ep, struct net2280_ep, ep);\r\nif (!_ep || !_req)\r\nreturn;\r\nreq = container_of (_req, struct net2280_request, req);\r\nWARN_ON (!list_empty (&req->queue));\r\nif (req->td)\r\npci_pool_free (ep->dev->requests, req->td, req->td_dma);\r\nkfree (req);\r\n}\r\nstatic void\r\nwrite_fifo (struct net2280_ep *ep, struct usb_request *req)\r\n{\r\nstruct net2280_ep_regs __iomem *regs = ep->regs;\r\nu8 *buf;\r\nu32 tmp;\r\nunsigned count, total;\r\nif (req) {\r\nbuf = req->buf + req->actual;\r\nprefetch (buf);\r\ntotal = req->length - req->actual;\r\n} else {\r\ntotal = 0;\r\nbuf = NULL;\r\n}\r\ncount = ep->ep.maxpacket;\r\nif (count > total)\r\ncount = total;\r\nVDEBUG (ep->dev, "write %s fifo (IN) %d bytes%s req %p\n",\r\nep->ep.name, count,\r\n(count != ep->ep.maxpacket) ? " (short)" : "",\r\nreq);\r\nwhile (count >= 4) {\r\ntmp = get_unaligned ((u32 *)buf);\r\ncpu_to_le32s (&tmp);\r\nwritel (tmp, &regs->ep_data);\r\nbuf += 4;\r\ncount -= 4;\r\n}\r\nif (count || total < ep->ep.maxpacket) {\r\ntmp = count ? get_unaligned ((u32 *)buf) : count;\r\ncpu_to_le32s (&tmp);\r\nset_fifo_bytecount (ep, count & 0x03);\r\nwritel (tmp, &regs->ep_data);\r\n}\r\n}\r\nstatic void out_flush (struct net2280_ep *ep)\r\n{\r\nu32 __iomem *statp;\r\nu32 tmp;\r\nASSERT_OUT_NAKING (ep);\r\nstatp = &ep->regs->ep_stat;\r\nwritel ( (1 << DATA_OUT_PING_TOKEN_INTERRUPT)\r\n| (1 << DATA_PACKET_RECEIVED_INTERRUPT)\r\n, statp);\r\nwritel ((1 << FIFO_FLUSH), statp);\r\nmb ();\r\ntmp = readl (statp);\r\nif (tmp & (1 << DATA_OUT_PING_TOKEN_INTERRUPT)\r\n&& ep->dev->gadget.speed == USB_SPEED_FULL) {\r\nunsigned usec;\r\nusec = 50;\r\nhandshake (statp, (1 << USB_OUT_PING_NAK_SENT),\r\n(1 << USB_OUT_PING_NAK_SENT), usec);\r\n}\r\n}\r\nstatic int\r\nread_fifo (struct net2280_ep *ep, struct net2280_request *req)\r\n{\r\nstruct net2280_ep_regs __iomem *regs = ep->regs;\r\nu8 *buf = req->req.buf + req->req.actual;\r\nunsigned count, tmp, is_short;\r\nunsigned cleanup = 0, prevent = 0;\r\nif (ep->dev->chiprev == 0x0100\r\n&& ep->dev->gadget.speed == USB_SPEED_FULL) {\r\nudelay (1);\r\ntmp = readl (&ep->regs->ep_stat);\r\nif ((tmp & (1 << NAK_OUT_PACKETS)))\r\ncleanup = 1;\r\nelse if ((tmp & (1 << FIFO_FULL))) {\r\nstart_out_naking (ep);\r\nprevent = 1;\r\n}\r\n}\r\nprefetchw (buf);\r\ncount = readl (&regs->ep_avail);\r\nif (unlikely (count == 0)) {\r\nudelay (1);\r\ntmp = readl (&ep->regs->ep_stat);\r\ncount = readl (&regs->ep_avail);\r\nif (count == 0 && (tmp & (1 << NAK_OUT_PACKETS)) == 0)\r\nreturn 0;\r\n}\r\ntmp = req->req.length - req->req.actual;\r\nif (count > tmp) {\r\nif ((tmp % ep->ep.maxpacket) != 0) {\r\nERROR (ep->dev,\r\n"%s out fifo %d bytes, expected %d\n",\r\nep->ep.name, count, tmp);\r\nreq->req.status = -EOVERFLOW;\r\ncleanup = 1;\r\n}\r\ncount = tmp;\r\n}\r\nreq->req.actual += count;\r\nis_short = (count == 0) || ((count % ep->ep.maxpacket) != 0);\r\nVDEBUG (ep->dev, "read %s fifo (OUT) %d bytes%s%s%s req %p %d/%d\n",\r\nep->ep.name, count, is_short ? " (short)" : "",\r\ncleanup ? " flush" : "", prevent ? " nak" : "",\r\nreq, req->req.actual, req->req.length);\r\nwhile (count >= 4) {\r\ntmp = readl (&regs->ep_data);\r\ncpu_to_le32s (&tmp);\r\nput_unaligned (tmp, (u32 *)buf);\r\nbuf += 4;\r\ncount -= 4;\r\n}\r\nif (count) {\r\ntmp = readl (&regs->ep_data);\r\ndo {\r\n*buf++ = (u8) tmp;\r\ntmp >>= 8;\r\n} while (--count);\r\n}\r\nif (cleanup)\r\nout_flush (ep);\r\nif (prevent) {\r\nwritel ((1 << CLEAR_NAK_OUT_PACKETS), &ep->regs->ep_rsp);\r\n(void) readl (&ep->regs->ep_rsp);\r\n}\r\nreturn is_short || ((req->req.actual == req->req.length)\r\n&& !req->req.zero);\r\n}\r\nstatic void\r\nfill_dma_desc (struct net2280_ep *ep, struct net2280_request *req, int valid)\r\n{\r\nstruct net2280_dma *td = req->td;\r\nu32 dmacount = req->req.length;\r\nif (ep->is_in)\r\ndmacount |= (1 << DMA_DIRECTION);\r\nif ((!ep->is_in && (dmacount % ep->ep.maxpacket) != 0)\r\n|| ep->dev->pdev->device != 0x2280)\r\ndmacount |= (1 << END_OF_CHAIN);\r\nreq->valid = valid;\r\nif (valid)\r\ndmacount |= (1 << VALID_BIT);\r\nif (likely(!req->req.no_interrupt || !use_dma_chaining))\r\ndmacount |= (1 << DMA_DONE_INTERRUPT_ENABLE);\r\ntd->dmaaddr = cpu_to_le32 (req->req.dma);\r\nwmb ();\r\ntd->dmacount = cpu_to_le32(dmacount);\r\n}\r\nstatic inline void spin_stop_dma (struct net2280_dma_regs __iomem *dma)\r\n{\r\nhandshake (&dma->dmactl, (1 << DMA_ENABLE), 0, 50);\r\n}\r\nstatic inline void stop_dma (struct net2280_dma_regs __iomem *dma)\r\n{\r\nwritel (readl (&dma->dmactl) & ~(1 << DMA_ENABLE), &dma->dmactl);\r\nspin_stop_dma (dma);\r\n}\r\nstatic void start_queue (struct net2280_ep *ep, u32 dmactl, u32 td_dma)\r\n{\r\nstruct net2280_dma_regs __iomem *dma = ep->dma;\r\nunsigned int tmp = (1 << VALID_BIT) | (ep->is_in << DMA_DIRECTION);\r\nif (ep->dev->pdev->device != 0x2280)\r\ntmp |= (1 << END_OF_CHAIN);\r\nwritel (tmp, &dma->dmacount);\r\nwritel (readl (&dma->dmastat), &dma->dmastat);\r\nwritel (td_dma, &dma->dmadesc);\r\nwritel (dmactl, &dma->dmactl);\r\n(void) readl (&ep->dev->pci->pcimstctl);\r\nwritel ((1 << DMA_START), &dma->dmastat);\r\nif (!ep->is_in)\r\nstop_out_naking (ep);\r\n}\r\nstatic void start_dma (struct net2280_ep *ep, struct net2280_request *req)\r\n{\r\nu32 tmp;\r\nstruct net2280_dma_regs __iomem *dma = ep->dma;\r\nWARN_ON (readl (&dma->dmactl) & (1 << DMA_ENABLE));\r\nwritel (0, &ep->dma->dmactl);\r\nif (!ep->is_in && ((tmp = readl (&ep->regs->ep_stat))\r\n& (1 << NAK_OUT_PACKETS)) != 0) {\r\nwritel ((1 << SHORT_PACKET_TRANSFERRED_INTERRUPT),\r\n&ep->regs->ep_stat);\r\ntmp = readl (&ep->regs->ep_avail);\r\nif (tmp) {\r\nwritel (readl (&dma->dmastat), &dma->dmastat);\r\nwritel (req->req.dma, &dma->dmaaddr);\r\ntmp = min (tmp, req->req.length);\r\nreq->td->dmacount = cpu_to_le32 (req->req.length - tmp);\r\nwritel ((1 << DMA_DONE_INTERRUPT_ENABLE)\r\n| tmp, &dma->dmacount);\r\nreq->td->dmadesc = 0;\r\nreq->valid = 1;\r\nwritel ((1 << DMA_ENABLE), &dma->dmactl);\r\nwritel ((1 << DMA_START), &dma->dmastat);\r\nreturn;\r\n}\r\n}\r\ntmp = dmactl_default;\r\nif (ep->is_in) {\r\nif (likely ((req->req.length % ep->ep.maxpacket) != 0\r\n|| req->req.zero)) {\r\ntmp |= (1 << DMA_FIFO_VALIDATE);\r\nep->in_fifo_validate = 1;\r\n} else\r\nep->in_fifo_validate = 0;\r\n}\r\nreq->td->dmadesc = cpu_to_le32 (ep->td_dma);\r\nfill_dma_desc (ep, req, 1);\r\nif (!use_dma_chaining)\r\nreq->td->dmacount |= cpu_to_le32 (1 << END_OF_CHAIN);\r\nstart_queue (ep, tmp, req->td_dma);\r\n}\r\nstatic inline void\r\nqueue_dma (struct net2280_ep *ep, struct net2280_request *req, int valid)\r\n{\r\nstruct net2280_dma *end;\r\ndma_addr_t tmp;\r\nend = ep->dummy;\r\nep->dummy = req->td;\r\nreq->td = end;\r\ntmp = ep->td_dma;\r\nep->td_dma = req->td_dma;\r\nreq->td_dma = tmp;\r\nend->dmadesc = cpu_to_le32 (ep->td_dma);\r\nfill_dma_desc (ep, req, valid);\r\n}\r\nstatic void\r\ndone (struct net2280_ep *ep, struct net2280_request *req, int status)\r\n{\r\nstruct net2280 *dev;\r\nunsigned stopped = ep->stopped;\r\nlist_del_init (&req->queue);\r\nif (req->req.status == -EINPROGRESS)\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\ndev = ep->dev;\r\nif (ep->dma)\r\nusb_gadget_unmap_request(&dev->gadget, &req->req, ep->is_in);\r\nif (status && status != -ESHUTDOWN)\r\nVDEBUG (dev, "complete %s req %p stat %d len %u/%u\n",\r\nep->ep.name, &req->req, status,\r\nreq->req.actual, req->req.length);\r\nep->stopped = 1;\r\nspin_unlock (&dev->lock);\r\nreq->req.complete (&ep->ep, &req->req);\r\nspin_lock (&dev->lock);\r\nep->stopped = stopped;\r\n}\r\nstatic int\r\nnet2280_queue (struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\r\n{\r\nstruct net2280_request *req;\r\nstruct net2280_ep *ep;\r\nstruct net2280 *dev;\r\nunsigned long flags;\r\nreq = container_of (_req, struct net2280_request, req);\r\nif (!_req || !_req->complete || !_req->buf\r\n|| !list_empty (&req->queue))\r\nreturn -EINVAL;\r\nif (_req->length > (~0 & DMA_BYTE_COUNT_MASK))\r\nreturn -EDOM;\r\nep = container_of (_ep, struct net2280_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0))\r\nreturn -EINVAL;\r\ndev = ep->dev;\r\nif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nif (ep->dma && _req->length == 0)\r\nreturn -EOPNOTSUPP;\r\nif (ep->dma) {\r\nint ret;\r\nret = usb_gadget_map_request(&dev->gadget, _req,\r\nep->is_in);\r\nif (ret)\r\nreturn ret;\r\n}\r\n#if 0\r\nVDEBUG (dev, "%s queue req %p, len %d buf %p\n",\r\n_ep->name, _req, _req->length, _req->buf);\r\n#endif\r\nspin_lock_irqsave (&dev->lock, flags);\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nif (list_empty (&ep->queue) && !ep->stopped) {\r\nif (ep->dma)\r\nstart_dma (ep, req);\r\nelse {\r\nif (ep->num == 0 && _req->length == 0) {\r\nallow_status (ep);\r\ndone (ep, req, 0);\r\nVDEBUG (dev, "%s status ack\n", ep->ep.name);\r\ngoto done;\r\n}\r\nif (ep->is_in)\r\nwrite_fifo (ep, _req);\r\nelse if (list_empty (&ep->queue)) {\r\nu32 s;\r\ns = readl (&ep->regs->ep_stat);\r\nif ((s & (1 << FIFO_EMPTY)) == 0) {\r\nif (read_fifo (ep, req)) {\r\ndone (ep, req, 0);\r\nif (ep->num == 0)\r\nallow_status (ep);\r\nreq = NULL;\r\n} else\r\ns = readl (&ep->regs->ep_stat);\r\n}\r\nif (req && (s & (1 << NAK_OUT_PACKETS)))\r\nwritel ((1 << CLEAR_NAK_OUT_PACKETS),\r\n&ep->regs->ep_rsp);\r\n}\r\n}\r\n} else if (ep->dma) {\r\nint valid = 1;\r\nif (ep->is_in) {\r\nint expect;\r\nexpect = likely (req->req.zero\r\n|| (req->req.length % ep->ep.maxpacket) != 0);\r\nif (expect != ep->in_fifo_validate)\r\nvalid = 0;\r\n}\r\nqueue_dma (ep, req, valid);\r\n}\r\nep->responded = 1;\r\nif (req)\r\nlist_add_tail (&req->queue, &ep->queue);\r\ndone:\r\nspin_unlock_irqrestore (&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline void\r\ndma_done (\r\nstruct net2280_ep *ep,\r\nstruct net2280_request *req,\r\nu32 dmacount,\r\nint status\r\n)\r\n{\r\nreq->req.actual = req->req.length - (DMA_BYTE_COUNT_MASK & dmacount);\r\ndone (ep, req, status);\r\n}\r\nstatic void scan_dma_completions (struct net2280_ep *ep)\r\n{\r\nwhile (!list_empty (&ep->queue)) {\r\nstruct net2280_request *req;\r\nu32 tmp;\r\nreq = list_entry (ep->queue.next,\r\nstruct net2280_request, queue);\r\nif (!req->valid)\r\nbreak;\r\nrmb ();\r\ntmp = le32_to_cpup (&req->td->dmacount);\r\nif ((tmp & (1 << VALID_BIT)) != 0)\r\nbreak;\r\nif (unlikely (req->td->dmadesc == 0)) {\r\ntmp = readl (&ep->dma->dmacount);\r\nif (tmp & DMA_BYTE_COUNT_MASK)\r\nbreak;\r\ndma_done (ep, req, tmp, 0);\r\nbreak;\r\n} else if (!ep->is_in\r\n&& (req->req.length % ep->ep.maxpacket) != 0) {\r\ntmp = readl (&ep->regs->ep_stat);\r\nif ((tmp & (1 << NAK_OUT_PACKETS)) == 0) {\r\nWARNING (ep->dev, "%s lost packet sync!\n",\r\nep->ep.name);\r\nreq->req.status = -EOVERFLOW;\r\n} else if ((tmp = readl (&ep->regs->ep_avail)) != 0) {\r\nep->out_overflow = 1;\r\nDEBUG (ep->dev, "%s dma, discard %d len %d\n",\r\nep->ep.name, tmp,\r\nreq->req.length);\r\nreq->req.status = -EOVERFLOW;\r\n}\r\n}\r\ndma_done (ep, req, tmp, 0);\r\n}\r\n}\r\nstatic void restart_dma (struct net2280_ep *ep)\r\n{\r\nstruct net2280_request *req;\r\nu32 dmactl = dmactl_default;\r\nif (ep->stopped)\r\nreturn;\r\nreq = list_entry (ep->queue.next, struct net2280_request, queue);\r\nif (!use_dma_chaining) {\r\nstart_dma (ep, req);\r\nreturn;\r\n}\r\nif (ep->is_in && !req->valid) {\r\nstruct net2280_request *entry, *prev = NULL;\r\nint reqmode, done = 0;\r\nDEBUG (ep->dev, "%s dma hiccup td %p\n", ep->ep.name, req->td);\r\nep->in_fifo_validate = likely (req->req.zero\r\n|| (req->req.length % ep->ep.maxpacket) != 0);\r\nif (ep->in_fifo_validate)\r\ndmactl |= (1 << DMA_FIFO_VALIDATE);\r\nlist_for_each_entry (entry, &ep->queue, queue) {\r\n__le32 dmacount;\r\nif (entry == req)\r\ncontinue;\r\ndmacount = entry->td->dmacount;\r\nif (!done) {\r\nreqmode = likely (entry->req.zero\r\n|| (entry->req.length\r\n% ep->ep.maxpacket) != 0);\r\nif (reqmode == ep->in_fifo_validate) {\r\nentry->valid = 1;\r\ndmacount |= valid_bit;\r\nentry->td->dmacount = dmacount;\r\nprev = entry;\r\ncontinue;\r\n} else {\r\nprev->td->dmacount |= dma_done_ie;\r\ndone = 1;\r\n}\r\n}\r\nentry->valid = 0;\r\ndmacount &= ~valid_bit;\r\nentry->td->dmacount = dmacount;\r\nprev = entry;\r\n}\r\n}\r\nwritel (0, &ep->dma->dmactl);\r\nstart_queue (ep, dmactl, req->td_dma);\r\n}\r\nstatic void abort_dma (struct net2280_ep *ep)\r\n{\r\nif (likely (!list_empty (&ep->queue))) {\r\nwritel ((1 << DMA_ABORT), &ep->dma->dmastat);\r\nspin_stop_dma (ep->dma);\r\n} else\r\nstop_dma (ep->dma);\r\nscan_dma_completions (ep);\r\n}\r\nstatic void nuke (struct net2280_ep *ep)\r\n{\r\nstruct net2280_request *req;\r\nep->stopped = 1;\r\nif (ep->dma)\r\nabort_dma (ep);\r\nwhile (!list_empty (&ep->queue)) {\r\nreq = list_entry (ep->queue.next,\r\nstruct net2280_request,\r\nqueue);\r\ndone (ep, req, -ESHUTDOWN);\r\n}\r\n}\r\nstatic int net2280_dequeue (struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct net2280_ep *ep;\r\nstruct net2280_request *req;\r\nunsigned long flags;\r\nu32 dmactl;\r\nint stopped;\r\nep = container_of (_ep, struct net2280_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0) || !_req)\r\nreturn -EINVAL;\r\nspin_lock_irqsave (&ep->dev->lock, flags);\r\nstopped = ep->stopped;\r\ndmactl = 0;\r\nep->stopped = 1;\r\nif (ep->dma) {\r\ndmactl = readl (&ep->dma->dmactl);\r\nstop_dma (ep->dma);\r\nscan_dma_completions (ep);\r\n}\r\nlist_for_each_entry (req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nspin_unlock_irqrestore (&ep->dev->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nif (ep->queue.next == &req->queue) {\r\nif (ep->dma) {\r\nDEBUG (ep->dev, "unlink (%s) dma\n", _ep->name);\r\n_req->status = -ECONNRESET;\r\nabort_dma (ep);\r\nif (likely (ep->queue.next == &req->queue)) {\r\nreq->td->dmacount = 0;\r\ndma_done (ep, req,\r\nreadl (&ep->dma->dmacount),\r\n-ECONNRESET);\r\n}\r\n} else {\r\nDEBUG (ep->dev, "unlink (%s) pio\n", _ep->name);\r\ndone (ep, req, -ECONNRESET);\r\n}\r\nreq = NULL;\r\n} else if (ep->dma && use_dma_chaining) {\r\nif (req->queue.prev == ep->queue.next) {\r\nwritel (le32_to_cpu (req->td->dmadesc),\r\n&ep->dma->dmadesc);\r\nif (req->td->dmacount & dma_done_ie)\r\nwritel (readl (&ep->dma->dmacount)\r\n| le32_to_cpu(dma_done_ie),\r\n&ep->dma->dmacount);\r\n} else {\r\nstruct net2280_request *prev;\r\nprev = list_entry (req->queue.prev,\r\nstruct net2280_request, queue);\r\nprev->td->dmadesc = req->td->dmadesc;\r\nif (req->td->dmacount & dma_done_ie)\r\nprev->td->dmacount |= dma_done_ie;\r\n}\r\n}\r\nif (req)\r\ndone (ep, req, -ECONNRESET);\r\nep->stopped = stopped;\r\nif (ep->dma) {\r\nif (list_empty (&ep->queue))\r\nstop_dma (ep->dma);\r\nelse if (!ep->stopped) {\r\nif (req)\r\nwritel (dmactl, &ep->dma->dmactl);\r\nelse\r\nstart_dma (ep, list_entry (ep->queue.next,\r\nstruct net2280_request, queue));\r\n}\r\n}\r\nspin_unlock_irqrestore (&ep->dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nnet2280_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedged)\r\n{\r\nstruct net2280_ep *ep;\r\nunsigned long flags;\r\nint retval = 0;\r\nep = container_of (_ep, struct net2280_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0))\r\nreturn -EINVAL;\r\nif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nif (ep->desc && (ep->desc->bmAttributes & 0x03)\r\n== USB_ENDPOINT_XFER_ISOC)\r\nreturn -EINVAL;\r\nspin_lock_irqsave (&ep->dev->lock, flags);\r\nif (!list_empty (&ep->queue))\r\nretval = -EAGAIN;\r\nelse if (ep->is_in && value && net2280_fifo_status (_ep) != 0)\r\nretval = -EAGAIN;\r\nelse {\r\nVDEBUG (ep->dev, "%s %s %s\n", _ep->name,\r\nvalue ? "set" : "clear",\r\nwedged ? "wedge" : "halt");\r\nif (value) {\r\nif (ep->num == 0)\r\nep->dev->protocol_stall = 1;\r\nelse\r\nset_halt (ep);\r\nif (wedged)\r\nep->wedged = 1;\r\n} else {\r\nclear_halt (ep);\r\nep->wedged = 0;\r\n}\r\n(void) readl (&ep->regs->ep_rsp);\r\n}\r\nspin_unlock_irqrestore (&ep->dev->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int\r\nnet2280_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nreturn net2280_set_halt_and_wedge(_ep, value, 0);\r\n}\r\nstatic int\r\nnet2280_set_wedge(struct usb_ep *_ep)\r\n{\r\nif (!_ep || _ep->name == ep0name)\r\nreturn -EINVAL;\r\nreturn net2280_set_halt_and_wedge(_ep, 1, 1);\r\n}\r\nstatic int\r\nnet2280_fifo_status (struct usb_ep *_ep)\r\n{\r\nstruct net2280_ep *ep;\r\nu32 avail;\r\nep = container_of (_ep, struct net2280_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0))\r\nreturn -ENODEV;\r\nif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\navail = readl (&ep->regs->ep_avail) & ((1 << 12) - 1);\r\nif (avail > ep->fifo_size)\r\nreturn -EOVERFLOW;\r\nif (ep->is_in)\r\navail = ep->fifo_size - avail;\r\nreturn avail;\r\n}\r\nstatic void\r\nnet2280_fifo_flush (struct usb_ep *_ep)\r\n{\r\nstruct net2280_ep *ep;\r\nep = container_of (_ep, struct net2280_ep, ep);\r\nif (!_ep || (!ep->desc && ep->num != 0))\r\nreturn;\r\nif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn;\r\nwritel ((1 << FIFO_FLUSH), &ep->regs->ep_stat);\r\n(void) readl (&ep->regs->ep_rsp);\r\n}\r\nstatic int net2280_get_frame (struct usb_gadget *_gadget)\r\n{\r\nstruct net2280 *dev;\r\nunsigned long flags;\r\nu16 retval;\r\nif (!_gadget)\r\nreturn -ENODEV;\r\ndev = container_of (_gadget, struct net2280, gadget);\r\nspin_lock_irqsave (&dev->lock, flags);\r\nretval = get_idx_reg (dev->regs, REG_FRAME) & 0x03ff;\r\nspin_unlock_irqrestore (&dev->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int net2280_wakeup (struct usb_gadget *_gadget)\r\n{\r\nstruct net2280 *dev;\r\nu32 tmp;\r\nunsigned long flags;\r\nif (!_gadget)\r\nreturn 0;\r\ndev = container_of (_gadget, struct net2280, gadget);\r\nspin_lock_irqsave (&dev->lock, flags);\r\ntmp = readl (&dev->usb->usbctl);\r\nif (tmp & (1 << DEVICE_REMOTE_WAKEUP_ENABLE))\r\nwritel (1 << GENERATE_RESUME, &dev->usb->usbstat);\r\nspin_unlock_irqrestore (&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int net2280_set_selfpowered (struct usb_gadget *_gadget, int value)\r\n{\r\nstruct net2280 *dev;\r\nu32 tmp;\r\nunsigned long flags;\r\nif (!_gadget)\r\nreturn 0;\r\ndev = container_of (_gadget, struct net2280, gadget);\r\nspin_lock_irqsave (&dev->lock, flags);\r\ntmp = readl (&dev->usb->usbctl);\r\nif (value)\r\ntmp |= (1 << SELF_POWERED_STATUS);\r\nelse\r\ntmp &= ~(1 << SELF_POWERED_STATUS);\r\nwritel (tmp, &dev->usb->usbctl);\r\nspin_unlock_irqrestore (&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int net2280_pullup(struct usb_gadget *_gadget, int is_on)\r\n{\r\nstruct net2280 *dev;\r\nu32 tmp;\r\nunsigned long flags;\r\nif (!_gadget)\r\nreturn -ENODEV;\r\ndev = container_of (_gadget, struct net2280, gadget);\r\nspin_lock_irqsave (&dev->lock, flags);\r\ntmp = readl (&dev->usb->usbctl);\r\ndev->softconnect = (is_on != 0);\r\nif (is_on)\r\ntmp |= (1 << USB_DETECT_ENABLE);\r\nelse\r\ntmp &= ~(1 << USB_DETECT_ENABLE);\r\nwritel (tmp, &dev->usb->usbctl);\r\nspin_unlock_irqrestore (&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic ssize_t function_show(struct device *_dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct net2280 *dev = dev_get_drvdata (_dev);\r\nif (!dev->driver\r\n|| !dev->driver->function\r\n|| strlen (dev->driver->function) > PAGE_SIZE)\r\nreturn 0;\r\nreturn scnprintf (buf, PAGE_SIZE, "%s\n", dev->driver->function);\r\n}\r\nstatic ssize_t registers_show(struct device *_dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct net2280 *dev;\r\nchar *next;\r\nunsigned size, t;\r\nunsigned long flags;\r\nint i;\r\nu32 t1, t2;\r\nconst char *s;\r\ndev = dev_get_drvdata (_dev);\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nspin_lock_irqsave (&dev->lock, flags);\r\nif (dev->driver)\r\ns = dev->driver->driver.name;\r\nelse\r\ns = "(none)";\r\nt = scnprintf (next, size, "%s version " DRIVER_VERSION\r\n", chiprev %04x, dma %s\n\n"\r\n"devinit %03x fifoctl %08x gadget '%s'\n"\r\n"pci irqenb0 %02x irqenb1 %08x "\r\n"irqstat0 %04x irqstat1 %08x\n",\r\ndriver_name, dev->chiprev,\r\nuse_dma\r\n? (use_dma_chaining ? "chaining" : "enabled")\r\n: "disabled",\r\nreadl (&dev->regs->devinit),\r\nreadl (&dev->regs->fifoctl),\r\ns,\r\nreadl (&dev->regs->pciirqenb0),\r\nreadl (&dev->regs->pciirqenb1),\r\nreadl (&dev->regs->irqstat0),\r\nreadl (&dev->regs->irqstat1));\r\nsize -= t;\r\nnext += t;\r\nt1 = readl (&dev->usb->usbctl);\r\nt2 = readl (&dev->usb->usbstat);\r\nif (t1 & (1 << VBUS_PIN)) {\r\nif (t2 & (1 << HIGH_SPEED))\r\ns = "high speed";\r\nelse if (dev->gadget.speed == USB_SPEED_UNKNOWN)\r\ns = "powered";\r\nelse\r\ns = "full speed";\r\n} else\r\ns = "not attached";\r\nt = scnprintf (next, size,\r\n"stdrsp %08x usbctl %08x usbstat %08x "\r\n"addr 0x%02x (%s)\n",\r\nreadl (&dev->usb->stdrsp), t1, t2,\r\nreadl (&dev->usb->ouraddr), s);\r\nsize -= t;\r\nnext += t;\r\nfor (i = 0; i < 7; i++) {\r\nstruct net2280_ep *ep;\r\nep = &dev->ep [i];\r\nif (i && !ep->desc)\r\ncontinue;\r\nt1 = readl (&ep->regs->ep_cfg);\r\nt2 = readl (&ep->regs->ep_rsp) & 0xff;\r\nt = scnprintf (next, size,\r\n"\n%s\tcfg %05x rsp (%02x) %s%s%s%s%s%s%s%s"\r\n"irqenb %02x\n",\r\nep->ep.name, t1, t2,\r\n(t2 & (1 << CLEAR_NAK_OUT_PACKETS))\r\n? "NAK " : "",\r\n(t2 & (1 << CLEAR_EP_HIDE_STATUS_PHASE))\r\n? "hide " : "",\r\n(t2 & (1 << CLEAR_EP_FORCE_CRC_ERROR))\r\n? "CRC " : "",\r\n(t2 & (1 << CLEAR_INTERRUPT_MODE))\r\n? "interrupt " : "",\r\n(t2 & (1<<CLEAR_CONTROL_STATUS_PHASE_HANDSHAKE))\r\n? "status " : "",\r\n(t2 & (1 << CLEAR_NAK_OUT_PACKETS_MODE))\r\n? "NAKmode " : "",\r\n(t2 & (1 << CLEAR_ENDPOINT_TOGGLE))\r\n? "DATA1 " : "DATA0 ",\r\n(t2 & (1 << CLEAR_ENDPOINT_HALT))\r\n? "HALT " : "",\r\nreadl (&ep->regs->ep_irqenb));\r\nsize -= t;\r\nnext += t;\r\nt = scnprintf (next, size,\r\n"\tstat %08x avail %04x "\r\n"(ep%d%s-%s)%s\n",\r\nreadl (&ep->regs->ep_stat),\r\nreadl (&ep->regs->ep_avail),\r\nt1 & 0x0f, DIR_STRING (t1),\r\ntype_string (t1 >> 8),\r\nep->stopped ? "*" : "");\r\nsize -= t;\r\nnext += t;\r\nif (!ep->dma)\r\ncontinue;\r\nt = scnprintf (next, size,\r\n" dma\tctl %08x stat %08x count %08x\n"\r\n"\taddr %08x desc %08x\n",\r\nreadl (&ep->dma->dmactl),\r\nreadl (&ep->dma->dmastat),\r\nreadl (&ep->dma->dmacount),\r\nreadl (&ep->dma->dmaaddr),\r\nreadl (&ep->dma->dmadesc));\r\nsize -= t;\r\nnext += t;\r\n}\r\nt = scnprintf (next, size, "\nirqs: ");\r\nsize -= t;\r\nnext += t;\r\nfor (i = 0; i < 7; i++) {\r\nstruct net2280_ep *ep;\r\nep = &dev->ep [i];\r\nif (i && !ep->irqs)\r\ncontinue;\r\nt = scnprintf (next, size, " %s/%lu", ep->ep.name, ep->irqs);\r\nsize -= t;\r\nnext += t;\r\n}\r\nt = scnprintf (next, size, "\n");\r\nsize -= t;\r\nnext += t;\r\nspin_unlock_irqrestore (&dev->lock, flags);\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t queues_show(struct device *_dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct net2280 *dev;\r\nchar *next;\r\nunsigned size;\r\nunsigned long flags;\r\nint i;\r\ndev = dev_get_drvdata (_dev);\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nspin_lock_irqsave (&dev->lock, flags);\r\nfor (i = 0; i < 7; i++) {\r\nstruct net2280_ep *ep = &dev->ep [i];\r\nstruct net2280_request *req;\r\nint t;\r\nif (i != 0) {\r\nconst struct usb_endpoint_descriptor *d;\r\nd = ep->desc;\r\nif (!d)\r\ncontinue;\r\nt = d->bEndpointAddress;\r\nt = scnprintf (next, size,\r\n"\n%s (ep%d%s-%s) max %04x %s fifo %d\n",\r\nep->ep.name, t & USB_ENDPOINT_NUMBER_MASK,\r\n(t & USB_DIR_IN) ? "in" : "out",\r\n({ char *val;\r\nswitch (d->bmAttributes & 0x03) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nval = "bulk"; break;\r\ncase USB_ENDPOINT_XFER_INT:\r\nval = "intr"; break;\r\ndefault:\r\nval = "iso"; break;\r\n} val; }),\r\nusb_endpoint_maxp (d) & 0x1fff,\r\nep->dma ? "dma" : "pio", ep->fifo_size\r\n);\r\n} else\r\nt = scnprintf (next, size, "ep0 max 64 pio %s\n",\r\nep->is_in ? "in" : "out");\r\nif (t <= 0 || t > size)\r\ngoto done;\r\nsize -= t;\r\nnext += t;\r\nif (list_empty (&ep->queue)) {\r\nt = scnprintf (next, size, "\t(nothing queued)\n");\r\nif (t <= 0 || t > size)\r\ngoto done;\r\nsize -= t;\r\nnext += t;\r\ncontinue;\r\n}\r\nlist_for_each_entry (req, &ep->queue, queue) {\r\nif (ep->dma && req->td_dma == readl (&ep->dma->dmadesc))\r\nt = scnprintf (next, size,\r\n"\treq %p len %d/%d "\r\n"buf %p (dmacount %08x)\n",\r\n&req->req, req->req.actual,\r\nreq->req.length, req->req.buf,\r\nreadl (&ep->dma->dmacount));\r\nelse\r\nt = scnprintf (next, size,\r\n"\treq %p len %d/%d buf %p\n",\r\n&req->req, req->req.actual,\r\nreq->req.length, req->req.buf);\r\nif (t <= 0 || t > size)\r\ngoto done;\r\nsize -= t;\r\nnext += t;\r\nif (ep->dma) {\r\nstruct net2280_dma *td;\r\ntd = req->td;\r\nt = scnprintf (next, size, "\t td %08x "\r\n" count %08x buf %08x desc %08x\n",\r\n(u32) req->td_dma,\r\nle32_to_cpu (td->dmacount),\r\nle32_to_cpu (td->dmaaddr),\r\nle32_to_cpu (td->dmadesc));\r\nif (t <= 0 || t > size)\r\ngoto done;\r\nsize -= t;\r\nnext += t;\r\n}\r\n}\r\n}\r\ndone:\r\nspin_unlock_irqrestore (&dev->lock, flags);\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic void set_fifo_mode (struct net2280 *dev, int mode)\r\n{\r\nwritel ((0xffff << PCI_BASE2_RANGE) | mode, &dev->regs->fifoctl);\r\nINIT_LIST_HEAD (&dev->gadget.ep_list);\r\nlist_add_tail (&dev->ep [1].ep.ep_list, &dev->gadget.ep_list);\r\nlist_add_tail (&dev->ep [2].ep.ep_list, &dev->gadget.ep_list);\r\nswitch (mode) {\r\ncase 0:\r\nlist_add_tail (&dev->ep [3].ep.ep_list, &dev->gadget.ep_list);\r\nlist_add_tail (&dev->ep [4].ep.ep_list, &dev->gadget.ep_list);\r\ndev->ep [1].fifo_size = dev->ep [2].fifo_size = 1024;\r\nbreak;\r\ncase 1:\r\ndev->ep [1].fifo_size = dev->ep [2].fifo_size = 2048;\r\nbreak;\r\ncase 2:\r\nlist_add_tail (&dev->ep [3].ep.ep_list, &dev->gadget.ep_list);\r\ndev->ep [1].fifo_size = 2048;\r\ndev->ep [2].fifo_size = 1024;\r\nbreak;\r\n}\r\nlist_add_tail (&dev->ep [5].ep.ep_list, &dev->gadget.ep_list);\r\nlist_add_tail (&dev->ep [6].ep.ep_list, &dev->gadget.ep_list);\r\n}\r\nstatic void usb_reset (struct net2280 *dev)\r\n{\r\nu32 tmp;\r\ndev->gadget.speed = USB_SPEED_UNKNOWN;\r\n(void) readl (&dev->usb->usbctl);\r\nnet2280_led_init (dev);\r\nwritel (0, &dev->usb->stdrsp);\r\nwritel (0, &dev->regs->pciirqenb0);\r\nwritel (0, &dev->regs->pciirqenb1);\r\nfor (tmp = 0; tmp < 4; tmp++) {\r\nstruct net2280_ep *ep = &dev->ep [tmp + 1];\r\nif (ep->dma)\r\nabort_dma (ep);\r\n}\r\nwritel (~0, &dev->regs->irqstat0),\r\nwritel (~(1 << SUSPEND_REQUEST_INTERRUPT), &dev->regs->irqstat1),\r\ntmp = readl (&dev->regs->devinit)\r\n| (1 << PCI_ENABLE)\r\n| (1 << FIFO_SOFT_RESET)\r\n| (1 << USB_SOFT_RESET)\r\n| (1 << M8051_RESET);\r\nwritel (tmp, &dev->regs->devinit);\r\nset_fifo_mode (dev, (fifo_mode <= 2) ? fifo_mode : 0);\r\n}\r\nstatic void usb_reinit (struct net2280 *dev)\r\n{\r\nu32 tmp;\r\nint init_dma;\r\ninit_dma = use_dma;\r\nfor (tmp = 0; tmp < 7; tmp++) {\r\nstruct net2280_ep *ep = &dev->ep [tmp];\r\nep->ep.name = ep_name [tmp];\r\nep->dev = dev;\r\nep->num = tmp;\r\nif (tmp > 0 && tmp <= 4) {\r\nep->fifo_size = 1024;\r\nif (init_dma)\r\nep->dma = &dev->dma [tmp - 1];\r\n} else\r\nep->fifo_size = 64;\r\nep->regs = &dev->epregs [tmp];\r\nep_reset (dev->regs, ep);\r\n}\r\nusb_ep_set_maxpacket_limit(&dev->ep [0].ep, 64);\r\nusb_ep_set_maxpacket_limit(&dev->ep [5].ep, 64);\r\nusb_ep_set_maxpacket_limit(&dev->ep [6].ep, 64);\r\ndev->gadget.ep0 = &dev->ep [0].ep;\r\ndev->ep [0].stopped = 0;\r\nINIT_LIST_HEAD (&dev->gadget.ep0->ep_list);\r\nfor (tmp = 0; tmp < 5; tmp++)\r\nwritel (EP_DONTUSE, &dev->dep [tmp].dep_cfg);\r\n}\r\nstatic void ep0_start (struct net2280 *dev)\r\n{\r\nwritel ( (1 << CLEAR_EP_HIDE_STATUS_PHASE)\r\n| (1 << CLEAR_NAK_OUT_PACKETS)\r\n| (1 << CLEAR_CONTROL_STATUS_PHASE_HANDSHAKE)\r\n, &dev->epregs [0].ep_rsp);\r\nwritel ( (1 << SET_TEST_MODE)\r\n| (1 << SET_ADDRESS)\r\n| (1 << DEVICE_SET_CLEAR_DEVICE_REMOTE_WAKEUP)\r\n| (1 << GET_DEVICE_STATUS)\r\n| (1 << GET_INTERFACE_STATUS)\r\n, &dev->usb->stdrsp);\r\nwritel ( (1 << USB_ROOT_PORT_WAKEUP_ENABLE)\r\n| (1 << SELF_POWERED_USB_DEVICE)\r\n| (1 << REMOTE_WAKEUP_SUPPORT)\r\n| (dev->softconnect << USB_DETECT_ENABLE)\r\n| (1 << SELF_POWERED_STATUS)\r\n, &dev->usb->usbctl);\r\nwritel ( (1 << SETUP_PACKET_INTERRUPT_ENABLE)\r\n| (1 << ENDPOINT_0_INTERRUPT_ENABLE)\r\n, &dev->regs->pciirqenb0);\r\nwritel ( (1 << PCI_INTERRUPT_ENABLE)\r\n| (1 << PCI_MASTER_ABORT_RECEIVED_INTERRUPT_ENABLE)\r\n| (1 << PCI_TARGET_ABORT_RECEIVED_INTERRUPT_ENABLE)\r\n| (1 << PCI_RETRY_ABORT_INTERRUPT_ENABLE)\r\n| (1 << VBUS_INTERRUPT_ENABLE)\r\n| (1 << ROOT_PORT_RESET_INTERRUPT_ENABLE)\r\n| (1 << SUSPEND_REQUEST_CHANGE_INTERRUPT_ENABLE)\r\n, &dev->regs->pciirqenb1);\r\n(void) readl (&dev->usb->usbctl);\r\n}\r\nstatic int net2280_start(struct usb_gadget *_gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct net2280 *dev;\r\nint retval;\r\nunsigned i;\r\nif (!driver || driver->max_speed < USB_SPEED_HIGH\r\n|| !driver->setup)\r\nreturn -EINVAL;\r\ndev = container_of (_gadget, struct net2280, gadget);\r\nfor (i = 0; i < 7; i++)\r\ndev->ep [i].irqs = 0;\r\ndev->softconnect = 1;\r\ndriver->driver.bus = NULL;\r\ndev->driver = driver;\r\nretval = device_create_file (&dev->pdev->dev, &dev_attr_function);\r\nif (retval) goto err_unbind;\r\nretval = device_create_file (&dev->pdev->dev, &dev_attr_queues);\r\nif (retval) goto err_func;\r\nif (full_speed)\r\nwritel(1 << FORCE_FULL_SPEED_MODE, &dev->usb->xcvrdiag);\r\nnet2280_led_active (dev, 1);\r\nep0_start (dev);\r\nDEBUG (dev, "%s ready, usbctl %08x stdrsp %08x\n",\r\ndriver->driver.name,\r\nreadl (&dev->usb->usbctl),\r\nreadl (&dev->usb->stdrsp));\r\nreturn 0;\r\nerr_func:\r\ndevice_remove_file (&dev->pdev->dev, &dev_attr_function);\r\nerr_unbind:\r\ndev->driver = NULL;\r\nreturn retval;\r\n}\r\nstatic void\r\nstop_activity (struct net2280 *dev, struct usb_gadget_driver *driver)\r\n{\r\nint i;\r\nif (dev->gadget.speed == USB_SPEED_UNKNOWN)\r\ndriver = NULL;\r\nusb_reset (dev);\r\nfor (i = 0; i < 7; i++)\r\nnuke (&dev->ep [i]);\r\nif (driver) {\r\nspin_unlock(&dev->lock);\r\ndriver->disconnect(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\nusb_reinit (dev);\r\n}\r\nstatic int net2280_stop(struct usb_gadget *_gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct net2280 *dev;\r\nunsigned long flags;\r\ndev = container_of (_gadget, struct net2280, gadget);\r\nspin_lock_irqsave (&dev->lock, flags);\r\nstop_activity (dev, driver);\r\nspin_unlock_irqrestore (&dev->lock, flags);\r\ndev->driver = NULL;\r\nnet2280_led_active (dev, 0);\r\nwritel(0, &dev->usb->xcvrdiag);\r\ndevice_remove_file (&dev->pdev->dev, &dev_attr_function);\r\ndevice_remove_file (&dev->pdev->dev, &dev_attr_queues);\r\nDEBUG (dev, "unregistered driver '%s'\n", driver->driver.name);\r\nreturn 0;\r\n}\r\nstatic void handle_ep_small (struct net2280_ep *ep)\r\n{\r\nstruct net2280_request *req;\r\nu32 t;\r\nint mode = 1;\r\nif (!list_empty (&ep->queue))\r\nreq = list_entry (ep->queue.next,\r\nstruct net2280_request, queue);\r\nelse\r\nreq = NULL;\r\nt = readl (&ep->regs->ep_stat);\r\nep->irqs++;\r\n#if 0\r\nVDEBUG (ep->dev, "%s ack ep_stat %08x, req %p\n",\r\nep->ep.name, t, req ? &req->req : 0);\r\n#endif\r\nif (!ep->is_in || ep->dev->pdev->device == 0x2280)\r\nwritel (t & ~(1 << NAK_OUT_PACKETS), &ep->regs->ep_stat);\r\nelse\r\nwritel (t, &ep->regs->ep_stat);\r\nif (unlikely (ep->num == 0)) {\r\nif (ep->is_in) {\r\nif (t & (1 << DATA_OUT_PING_TOKEN_INTERRUPT)) {\r\nif (ep->dev->protocol_stall) {\r\nep->stopped = 1;\r\nset_halt (ep);\r\n}\r\nif (!req)\r\nallow_status (ep);\r\nmode = 2;\r\n} else if (t & (1 << DATA_IN_TOKEN_INTERRUPT)) {\r\nif (ep->dev->protocol_stall) {\r\nep->stopped = 1;\r\nset_halt (ep);\r\nmode = 2;\r\n} else if (ep->responded &&\r\n!req && !ep->stopped)\r\nwrite_fifo (ep, NULL);\r\n}\r\n} else {\r\nif (t & (1 << DATA_IN_TOKEN_INTERRUPT)) {\r\nif (ep->dev->protocol_stall) {\r\nep->stopped = 1;\r\nset_halt (ep);\r\n}\r\nmode = 2;\r\n} else if (((t & (1 << DATA_OUT_PING_TOKEN_INTERRUPT))\r\n&& req\r\n&& req->req.actual == req->req.length)\r\n|| (ep->responded && !req)) {\r\nep->dev->protocol_stall = 1;\r\nset_halt (ep);\r\nep->stopped = 1;\r\nif (req)\r\ndone (ep, req, -EOVERFLOW);\r\nreq = NULL;\r\n}\r\n}\r\n}\r\nif (unlikely (!req))\r\nreturn;\r\nif (likely (ep->dma)) {\r\nif (t & (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT)) {\r\nu32 count;\r\nint stopped = ep->stopped;\r\nep->stopped = 1;\r\nfor (count = 0; ; t = readl (&ep->regs->ep_stat)) {\r\nscan_dma_completions (ep);\r\nif (unlikely (list_empty (&ep->queue)\r\n|| ep->out_overflow)) {\r\nreq = NULL;\r\nbreak;\r\n}\r\nreq = list_entry (ep->queue.next,\r\nstruct net2280_request, queue);\r\nif (likely (t & (1 << FIFO_EMPTY))) {\r\ncount = readl (&ep->dma->dmacount);\r\ncount &= DMA_BYTE_COUNT_MASK;\r\nif (readl (&ep->dma->dmadesc)\r\n!= req->td_dma)\r\nreq = NULL;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nwritel ((1 << DMA_ABORT), &ep->dma->dmastat);\r\nspin_stop_dma (ep->dma);\r\nif (likely (req)) {\r\nreq->td->dmacount = 0;\r\nt = readl (&ep->regs->ep_avail);\r\ndma_done (ep, req, count,\r\n(ep->out_overflow || t)\r\n? -EOVERFLOW : 0);\r\n}\r\nif (unlikely (ep->out_overflow\r\n|| (ep->dev->chiprev == 0x0100\r\n&& ep->dev->gadget.speed\r\n== USB_SPEED_FULL))) {\r\nout_flush (ep);\r\nep->out_overflow = 0;\r\n}\r\nep->stopped = stopped;\r\nif (!list_empty (&ep->queue))\r\nrestart_dma (ep);\r\n} else\r\nDEBUG (ep->dev, "%s dma ep_stat %08x ??\n",\r\nep->ep.name, t);\r\nreturn;\r\n} else if (t & (1 << DATA_PACKET_RECEIVED_INTERRUPT)) {\r\nif (read_fifo (ep, req) && ep->num != 0)\r\nmode = 2;\r\n} else if (t & (1 << DATA_PACKET_TRANSMITTED_INTERRUPT)) {\r\nunsigned len;\r\nlen = req->req.length - req->req.actual;\r\nif (len > ep->ep.maxpacket)\r\nlen = ep->ep.maxpacket;\r\nreq->req.actual += len;\r\nif (req->req.actual == req->req.length) {\r\nif (ep->num == 0) {\r\n} else if (!req->req.zero || len != ep->ep.maxpacket)\r\nmode = 2;\r\n}\r\n} else if (mode == 1)\r\nreturn;\r\nif (mode == 2) {\r\ndone (ep, req, 0);\r\nif (ep->num == 0) {\r\nif (!ep->stopped)\r\nallow_status (ep);\r\nreq = NULL;\r\n} else {\r\nif (!list_empty (&ep->queue) && !ep->stopped)\r\nreq = list_entry (ep->queue.next,\r\nstruct net2280_request, queue);\r\nelse\r\nreq = NULL;\r\nif (req && !ep->is_in)\r\nstop_out_naking (ep);\r\n}\r\n}\r\nif (req && !ep->stopped) {\r\nif (t & (1 << DATA_PACKET_TRANSMITTED_INTERRUPT))\r\nwrite_fifo (ep, &req->req);\r\n}\r\n}\r\nstatic struct net2280_ep *\r\nget_ep_by_addr (struct net2280 *dev, u16 wIndex)\r\n{\r\nstruct net2280_ep *ep;\r\nif ((wIndex & USB_ENDPOINT_NUMBER_MASK) == 0)\r\nreturn &dev->ep [0];\r\nlist_for_each_entry (ep, &dev->gadget.ep_list, ep.ep_list) {\r\nu8 bEndpointAddress;\r\nif (!ep->desc)\r\ncontinue;\r\nbEndpointAddress = ep->desc->bEndpointAddress;\r\nif ((wIndex ^ bEndpointAddress) & USB_DIR_IN)\r\ncontinue;\r\nif ((wIndex & 0x0f) == (bEndpointAddress & 0x0f))\r\nreturn ep;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void handle_stat0_irqs (struct net2280 *dev, u32 stat)\r\n{\r\nstruct net2280_ep *ep;\r\nu32 num, scratch;\r\nstat &= ~(1 << INTA_ASSERTED);\r\nif (!stat)\r\nreturn;\r\nif (unlikely (stat & (1 << SETUP_PACKET_INTERRUPT))) {\r\nunion {\r\nu32 raw [2];\r\nstruct usb_ctrlrequest r;\r\n} u;\r\nint tmp;\r\nstruct net2280_request *req;\r\nif (dev->gadget.speed == USB_SPEED_UNKNOWN) {\r\nif (readl (&dev->usb->usbstat) & (1 << HIGH_SPEED))\r\ndev->gadget.speed = USB_SPEED_HIGH;\r\nelse\r\ndev->gadget.speed = USB_SPEED_FULL;\r\nnet2280_led_speed (dev, dev->gadget.speed);\r\nDEBUG(dev, "%s\n", usb_speed_string(dev->gadget.speed));\r\n}\r\nep = &dev->ep [0];\r\nep->irqs++;\r\nstat &= ~(1 << ENDPOINT_0_INTERRUPT);\r\nwhile (!list_empty (&ep->queue)) {\r\nreq = list_entry (ep->queue.next,\r\nstruct net2280_request, queue);\r\ndone (ep, req, (req->req.actual == req->req.length)\r\n? 0 : -EPROTO);\r\n}\r\nep->stopped = 0;\r\ndev->protocol_stall = 0;\r\nif (ep->dev->pdev->device == 0x2280)\r\ntmp = (1 << FIFO_OVERFLOW)\r\n| (1 << FIFO_UNDERFLOW);\r\nelse\r\ntmp = 0;\r\nwritel (tmp | (1 << TIMEOUT)\r\n| (1 << USB_STALL_SENT)\r\n| (1 << USB_IN_NAK_SENT)\r\n| (1 << USB_IN_ACK_RCVD)\r\n| (1 << USB_OUT_PING_NAK_SENT)\r\n| (1 << USB_OUT_ACK_SENT)\r\n| (1 << SHORT_PACKET_OUT_DONE_INTERRUPT)\r\n| (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT)\r\n| (1 << DATA_PACKET_RECEIVED_INTERRUPT)\r\n| (1 << DATA_PACKET_TRANSMITTED_INTERRUPT)\r\n| (1 << DATA_OUT_PING_TOKEN_INTERRUPT)\r\n| (1 << DATA_IN_TOKEN_INTERRUPT)\r\n, &ep->regs->ep_stat);\r\nu.raw [0] = readl (&dev->usb->setup0123);\r\nu.raw [1] = readl (&dev->usb->setup4567);\r\ncpu_to_le32s (&u.raw [0]);\r\ncpu_to_le32s (&u.raw [1]);\r\ntmp = 0;\r\n#define w_value le16_to_cpu(u.r.wValue)\r\n#define w_index le16_to_cpu(u.r.wIndex)\r\n#define w_length le16_to_cpu(u.r.wLength)\r\nwritel (1 << SETUP_PACKET_INTERRUPT, &dev->regs->irqstat0);\r\nstat ^= (1 << SETUP_PACKET_INTERRUPT);\r\nep->is_in = (u.r.bRequestType & USB_DIR_IN) != 0;\r\nif (ep->is_in) {\r\nscratch = (1 << DATA_PACKET_TRANSMITTED_INTERRUPT)\r\n| (1 << DATA_OUT_PING_TOKEN_INTERRUPT)\r\n| (1 << DATA_IN_TOKEN_INTERRUPT);\r\nstop_out_naking (ep);\r\n} else\r\nscratch = (1 << DATA_PACKET_RECEIVED_INTERRUPT)\r\n| (1 << DATA_OUT_PING_TOKEN_INTERRUPT)\r\n| (1 << DATA_IN_TOKEN_INTERRUPT);\r\nwritel (scratch, &dev->epregs [0].ep_irqenb);\r\nep->responded = 1;\r\nswitch (u.r.bRequest) {\r\ncase USB_REQ_GET_STATUS: {\r\nstruct net2280_ep *e;\r\n__le32 status;\r\nif (u.r.bRequestType != (USB_DIR_IN|USB_RECIP_ENDPOINT))\r\ngoto delegate;\r\nif ((e = get_ep_by_addr (dev, w_index)) == NULL\r\n|| w_length > 2)\r\ngoto do_stall;\r\nif (readl (&e->regs->ep_rsp)\r\n& (1 << SET_ENDPOINT_HALT))\r\nstatus = cpu_to_le32 (1);\r\nelse\r\nstatus = cpu_to_le32 (0);\r\nwritel (0, &dev->epregs [0].ep_irqenb);\r\nset_fifo_bytecount (ep, w_length);\r\nwritel ((__force u32)status, &dev->epregs [0].ep_data);\r\nallow_status (ep);\r\nVDEBUG (dev, "%s stat %02x\n", ep->ep.name, status);\r\ngoto next_endpoints;\r\n}\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE: {\r\nstruct net2280_ep *e;\r\nif (u.r.bRequestType != USB_RECIP_ENDPOINT)\r\ngoto delegate;\r\nif (w_value != USB_ENDPOINT_HALT\r\n|| w_length != 0)\r\ngoto do_stall;\r\nif ((e = get_ep_by_addr (dev, w_index)) == NULL)\r\ngoto do_stall;\r\nif (e->wedged) {\r\nVDEBUG(dev, "%s wedged, halt not cleared\n",\r\nep->ep.name);\r\n} else {\r\nVDEBUG(dev, "%s clear halt\n", ep->ep.name);\r\nclear_halt(e);\r\n}\r\nallow_status (ep);\r\ngoto next_endpoints;\r\n}\r\nbreak;\r\ncase USB_REQ_SET_FEATURE: {\r\nstruct net2280_ep *e;\r\nif (u.r.bRequestType != USB_RECIP_ENDPOINT)\r\ngoto delegate;\r\nif (w_value != USB_ENDPOINT_HALT\r\n|| w_length != 0)\r\ngoto do_stall;\r\nif ((e = get_ep_by_addr (dev, w_index)) == NULL)\r\ngoto do_stall;\r\nif (e->ep.name == ep0name)\r\ngoto do_stall;\r\nset_halt (e);\r\nallow_status (ep);\r\nVDEBUG (dev, "%s set halt\n", ep->ep.name);\r\ngoto next_endpoints;\r\n}\r\nbreak;\r\ndefault:\r\ndelegate:\r\nVDEBUG (dev, "setup %02x.%02x v%04x i%04x l%04x "\r\n"ep_cfg %08x\n",\r\nu.r.bRequestType, u.r.bRequest,\r\nw_value, w_index, w_length,\r\nreadl (&ep->regs->ep_cfg));\r\nep->responded = 0;\r\nspin_unlock (&dev->lock);\r\ntmp = dev->driver->setup (&dev->gadget, &u.r);\r\nspin_lock (&dev->lock);\r\n}\r\nif (tmp < 0) {\r\ndo_stall:\r\nVDEBUG (dev, "req %02x.%02x protocol STALL; stat %d\n",\r\nu.r.bRequestType, u.r.bRequest, tmp);\r\ndev->protocol_stall = 1;\r\n}\r\n}\r\n#undef w_value\r\n#undef w_index\r\n#undef w_length\r\nnext_endpoints:\r\nscratch = stat & 0x7f;\r\nstat &= ~0x7f;\r\nfor (num = 0; scratch; num++) {\r\nu32 t;\r\nt = 1 << num;\r\nif ((scratch & t) == 0)\r\ncontinue;\r\nscratch ^= t;\r\nep = &dev->ep [num];\r\nhandle_ep_small (ep);\r\n}\r\nif (stat)\r\nDEBUG (dev, "unhandled irqstat0 %08x\n", stat);\r\n}\r\nstatic void handle_stat1_irqs (struct net2280 *dev, u32 stat)\r\n{\r\nstruct net2280_ep *ep;\r\nu32 tmp, num, mask, scratch;\r\ntmp = (1 << VBUS_INTERRUPT) | (1 << ROOT_PORT_RESET_INTERRUPT);\r\nmask = (1 << HIGH_SPEED) | (1 << FULL_SPEED);\r\nif (stat & tmp) {\r\nwritel (tmp, &dev->regs->irqstat1);\r\nif ((((stat & (1 << ROOT_PORT_RESET_INTERRUPT))\r\n&& ((readl (&dev->usb->usbstat) & mask)\r\n== 0))\r\n|| ((readl (&dev->usb->usbctl)\r\n& (1 << VBUS_PIN)) == 0)\r\n) && ( dev->gadget.speed != USB_SPEED_UNKNOWN)) {\r\nDEBUG (dev, "disconnect %s\n",\r\ndev->driver->driver.name);\r\nstop_activity (dev, dev->driver);\r\nep0_start (dev);\r\nreturn;\r\n}\r\nstat &= ~tmp;\r\nif (!stat)\r\nreturn;\r\n}\r\ntmp = (1 << SUSPEND_REQUEST_CHANGE_INTERRUPT);\r\nif (stat & tmp) {\r\nwritel (tmp, &dev->regs->irqstat1);\r\nif (stat & (1 << SUSPEND_REQUEST_INTERRUPT)) {\r\nif (dev->driver->suspend)\r\ndev->driver->suspend (&dev->gadget);\r\nif (!enable_suspend)\r\nstat &= ~(1 << SUSPEND_REQUEST_INTERRUPT);\r\n} else {\r\nif (dev->driver->resume)\r\ndev->driver->resume (&dev->gadget);\r\n}\r\nstat &= ~tmp;\r\n}\r\nif (stat)\r\nwritel (stat, &dev->regs->irqstat1);\r\nif (dev->pdev->device == 0x2280)\r\nstat &= ~((1 << CONTROL_STATUS_INTERRUPT)\r\n| (1 << SUSPEND_REQUEST_INTERRUPT)\r\n| (1 << RESUME_INTERRUPT)\r\n| (1 << SOF_INTERRUPT));\r\nelse\r\nstat &= ~((1 << CONTROL_STATUS_INTERRUPT)\r\n| (1 << RESUME_INTERRUPT)\r\n| (1 << SOF_DOWN_INTERRUPT)\r\n| (1 << SOF_INTERRUPT));\r\nif (!stat)\r\nreturn;\r\nscratch = stat & DMA_INTERRUPTS;\r\nstat &= ~DMA_INTERRUPTS;\r\nscratch >>= 9;\r\nfor (num = 0; scratch; num++) {\r\nstruct net2280_dma_regs __iomem *dma;\r\ntmp = 1 << num;\r\nif ((tmp & scratch) == 0)\r\ncontinue;\r\nscratch ^= tmp;\r\nep = &dev->ep [num + 1];\r\ndma = ep->dma;\r\nif (!dma)\r\ncontinue;\r\ntmp = readl (&dma->dmastat);\r\nwritel (tmp, &dma->dmastat);\r\nif (!use_dma_chaining) {\r\nif ((tmp & (1 << DMA_TRANSACTION_DONE_INTERRUPT))\r\n== 0) {\r\nDEBUG (ep->dev, "%s no xact done? %08x\n",\r\nep->ep.name, tmp);\r\ncontinue;\r\n}\r\nstop_dma (ep->dma);\r\n}\r\nscan_dma_completions (ep);\r\nif (list_empty (&ep->queue)) {\r\nif (use_dma_chaining)\r\nstop_dma (ep->dma);\r\n} else {\r\ntmp = readl (&dma->dmactl);\r\nif (!use_dma_chaining\r\n|| (tmp & (1 << DMA_ENABLE)) == 0)\r\nrestart_dma (ep);\r\nelse if (ep->is_in && use_dma_chaining) {\r\nstruct net2280_request *req;\r\n__le32 dmacount;\r\nreq = list_entry (ep->queue.next,\r\nstruct net2280_request, queue);\r\ndmacount = req->td->dmacount;\r\ndmacount &= cpu_to_le32 (\r\n(1 << VALID_BIT)\r\n| DMA_BYTE_COUNT_MASK);\r\nif (dmacount && (dmacount & valid_bit) == 0)\r\nrestart_dma (ep);\r\n}\r\n}\r\nep->irqs++;\r\n}\r\nif (stat & PCI_ERROR_INTERRUPTS) {\r\nERROR (dev, "pci dma error; stat %08x\n", stat);\r\nstat &= ~PCI_ERROR_INTERRUPTS;\r\nstop_activity (dev, dev->driver);\r\nep0_start (dev);\r\nstat = 0;\r\n}\r\nif (stat)\r\nDEBUG (dev, "unhandled irqstat1 %08x\n", stat);\r\n}\r\nstatic irqreturn_t net2280_irq (int irq, void *_dev)\r\n{\r\nstruct net2280 *dev = _dev;\r\nif (!(readl(&dev->regs->irqstat0) & (1 << INTA_ASSERTED)))\r\nreturn IRQ_NONE;\r\nspin_lock (&dev->lock);\r\nhandle_stat1_irqs (dev, readl (&dev->regs->irqstat1));\r\nhandle_stat0_irqs (dev, readl (&dev->regs->irqstat0));\r\nspin_unlock (&dev->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void gadget_release (struct device *_dev)\r\n{\r\nstruct net2280 *dev = dev_get_drvdata (_dev);\r\nkfree (dev);\r\n}\r\nstatic void net2280_remove (struct pci_dev *pdev)\r\n{\r\nstruct net2280 *dev = pci_get_drvdata (pdev);\r\nusb_del_gadget_udc(&dev->gadget);\r\nBUG_ON(dev->driver);\r\nnet2280_led_shutdown (dev);\r\nif (dev->requests) {\r\nint i;\r\nfor (i = 1; i < 5; i++) {\r\nif (!dev->ep [i].dummy)\r\ncontinue;\r\npci_pool_free (dev->requests, dev->ep [i].dummy,\r\ndev->ep [i].td_dma);\r\n}\r\npci_pool_destroy (dev->requests);\r\n}\r\nif (dev->got_irq)\r\nfree_irq (pdev->irq, dev);\r\nif (dev->regs)\r\niounmap (dev->regs);\r\nif (dev->region)\r\nrelease_mem_region (pci_resource_start (pdev, 0),\r\npci_resource_len (pdev, 0));\r\nif (dev->enabled)\r\npci_disable_device (pdev);\r\ndevice_remove_file (&pdev->dev, &dev_attr_registers);\r\nINFO (dev, "unbind\n");\r\n}\r\nstatic int net2280_probe (struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct net2280 *dev;\r\nunsigned long resource, len;\r\nvoid __iomem *base = NULL;\r\nint retval, i;\r\ndev = kzalloc (sizeof *dev, GFP_KERNEL);\r\nif (dev == NULL){\r\nretval = -ENOMEM;\r\ngoto done;\r\n}\r\npci_set_drvdata (pdev, dev);\r\nspin_lock_init (&dev->lock);\r\ndev->pdev = pdev;\r\ndev->gadget.ops = &net2280_ops;\r\ndev->gadget.max_speed = USB_SPEED_HIGH;\r\ndev->gadget.name = driver_name;\r\nif (pci_enable_device (pdev) < 0) {\r\nretval = -ENODEV;\r\ngoto done;\r\n}\r\ndev->enabled = 1;\r\nresource = pci_resource_start (pdev, 0);\r\nlen = pci_resource_len (pdev, 0);\r\nif (!request_mem_region (resource, len, driver_name)) {\r\nDEBUG (dev, "controller already in use\n");\r\nretval = -EBUSY;\r\ngoto done;\r\n}\r\ndev->region = 1;\r\nbase = ioremap_nocache (resource, len);\r\nif (base == NULL) {\r\nDEBUG (dev, "can't map memory\n");\r\nretval = -EFAULT;\r\ngoto done;\r\n}\r\ndev->regs = (struct net2280_regs __iomem *) base;\r\ndev->usb = (struct net2280_usb_regs __iomem *) (base + 0x0080);\r\ndev->pci = (struct net2280_pci_regs __iomem *) (base + 0x0100);\r\ndev->dma = (struct net2280_dma_regs __iomem *) (base + 0x0180);\r\ndev->dep = (struct net2280_dep_regs __iomem *) (base + 0x0200);\r\ndev->epregs = (struct net2280_ep_regs __iomem *) (base + 0x0300);\r\nwritel (0, &dev->usb->usbctl);\r\nusb_reset (dev);\r\nusb_reinit (dev);\r\nif (!pdev->irq) {\r\nERROR (dev, "No IRQ. Check PCI setup!\n");\r\nretval = -ENODEV;\r\ngoto done;\r\n}\r\nif (request_irq (pdev->irq, net2280_irq, IRQF_SHARED, driver_name, dev)\r\n!= 0) {\r\nERROR (dev, "request interrupt %d failed\n", pdev->irq);\r\nretval = -EBUSY;\r\ngoto done;\r\n}\r\ndev->got_irq = 1;\r\ndev->requests = pci_pool_create ("requests", pdev,\r\nsizeof (struct net2280_dma),\r\n0 ,\r\n0 );\r\nif (!dev->requests) {\r\nDEBUG (dev, "can't get request pool\n");\r\nretval = -ENOMEM;\r\ngoto done;\r\n}\r\nfor (i = 1; i < 5; i++) {\r\nstruct net2280_dma *td;\r\ntd = pci_pool_alloc (dev->requests, GFP_KERNEL,\r\n&dev->ep [i].td_dma);\r\nif (!td) {\r\nDEBUG (dev, "can't get dummy %d\n", i);\r\nretval = -ENOMEM;\r\ngoto done;\r\n}\r\ntd->dmacount = 0;\r\ntd->dmadesc = td->dmaaddr;\r\ndev->ep [i].dummy = td;\r\n}\r\nwritel ( (1 << DMA_MEMORY_WRITE_AND_INVALIDATE_ENABLE)\r\n| (1 << DMA_READ_MULTIPLE_ENABLE)\r\n| (1 << DMA_READ_LINE_ENABLE)\r\n, &dev->pci->pcimstctl);\r\npci_set_master (pdev);\r\npci_try_set_mwi (pdev);\r\ndev->chiprev = get_idx_reg (dev->regs, REG_CHIPREV) & 0xffff;\r\nINFO (dev, "%s\n", driver_desc);\r\nINFO (dev, "irq %d, pci mem %p, chip rev %04x\n",\r\npdev->irq, base, dev->chiprev);\r\nINFO (dev, "version: " DRIVER_VERSION "; dma %s\n",\r\nuse_dma\r\n? (use_dma_chaining ? "chaining" : "enabled")\r\n: "disabled");\r\nretval = device_create_file (&pdev->dev, &dev_attr_registers);\r\nif (retval) goto done;\r\nretval = usb_add_gadget_udc_release(&pdev->dev, &dev->gadget,\r\ngadget_release);\r\nif (retval)\r\ngoto done;\r\nreturn 0;\r\ndone:\r\nif (dev)\r\nnet2280_remove (pdev);\r\nreturn retval;\r\n}\r\nstatic void net2280_shutdown (struct pci_dev *pdev)\r\n{\r\nstruct net2280 *dev = pci_get_drvdata (pdev);\r\nwritel (0, &dev->regs->pciirqenb0);\r\nwritel (0, &dev->regs->pciirqenb1);\r\nwritel (0, &dev->usb->usbctl);\r\nwritel(0, &dev->usb->xcvrdiag);\r\n}\r\nstatic int __init init (void)\r\n{\r\nif (!use_dma)\r\nuse_dma_chaining = 0;\r\nreturn pci_register_driver (&net2280_pci_driver);\r\n}\r\nstatic void __exit cleanup (void)\r\n{\r\npci_unregister_driver (&net2280_pci_driver);\r\n}
