static void remove_files(struct nd_struct *nd)\r\n{\r\nchar buf[3];\r\nID_TO_CHAR(nd->nd_ID, buf);\r\ndgrp_remove_node_class_sysfs_files(nd);\r\nif (nd->nd_net_de)\r\nremove_proc_entry(buf, net_entry_pointer);\r\nif (nd->nd_mon_de)\r\nremove_proc_entry(buf, mon_entry_pointer);\r\nif (nd->nd_dpa_de)\r\nremove_proc_entry(buf, dpa_entry_pointer);\r\nif (nd->nd_ports_de)\r\nremove_proc_entry(buf, ports_entry_pointer);\r\n}\r\nvoid dgrp_unregister_proc(void)\r\n{\r\nnet_entry_pointer = NULL;\r\nmon_entry_pointer = NULL;\r\ndpa_entry_pointer = NULL;\r\nports_entry_pointer = NULL;\r\nif (dgrp_proc_dir_entry) {\r\nstruct nd_struct *nd;\r\nlist_for_each_entry(nd, &nd_struct_list, list)\r\nremove_files(nd);\r\nremove_proc_entry("dgrp/config", NULL);\r\nremove_proc_entry("dgrp/info", NULL);\r\nremove_proc_entry("dgrp/nodeinfo", NULL);\r\nremove_proc_entry("dgrp/net", NULL);\r\nremove_proc_entry("dgrp/mon", NULL);\r\nremove_proc_entry("dgrp/dpa", NULL);\r\nremove_proc_entry("dgrp/ports", NULL);\r\nremove_proc_entry("dgrp", NULL);\r\ndgrp_proc_dir_entry = NULL;\r\n}\r\n}\r\nvoid dgrp_register_proc(void)\r\n{\r\ndgrp_proc_dir_entry = proc_mkdir("dgrp", NULL);\r\nif (!dgrp_proc_dir_entry)\r\nreturn;\r\nproc_create("dgrp/config", 0644, NULL, &config_proc_file_ops);\r\nproc_create("dgrp/info", 0644, NULL, &info_proc_file_ops);\r\nproc_create("dgrp/nodeinfo", 0644, NULL, &nodeinfo_proc_file_ops);\r\nnet_entry_pointer = proc_mkdir_mode("dgrp/net", 0500, NULL);\r\nmon_entry_pointer = proc_mkdir_mode("dgrp/mon", 0500, NULL);\r\ndpa_entry_pointer = proc_mkdir_mode("dgrp/dpa", 0500, NULL);\r\nports_entry_pointer = proc_mkdir_mode("dgrp/ports", 0500, NULL);\r\n}\r\nstatic void *dgrp_config_proc_start(struct seq_file *m, loff_t *pos)\r\n{\r\nreturn seq_list_start_head(&nd_struct_list, *pos);\r\n}\r\nstatic void *dgrp_config_proc_next(struct seq_file *p, void *v, loff_t *pos)\r\n{\r\nreturn seq_list_next(v, &nd_struct_list, pos);\r\n}\r\nstatic void dgrp_config_proc_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic int dgrp_config_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct nd_struct *nd;\r\nchar tmp_id[4];\r\nif (v == &nd_struct_list) {\r\nseq_puts(m, "#-----------------------------------------------------------------------------\n");\r\nseq_puts(m, "# Avail\n");\r\nseq_puts(m, "# ID Major State Ports\n");\r\nreturn 0;\r\n}\r\nnd = list_entry(v, struct nd_struct, list);\r\nID_TO_CHAR(nd->nd_ID, tmp_id);\r\nseq_printf(m, " %-2.2s %-5ld %-10.10s %-5d\n",\r\ntmp_id,\r\nnd->nd_major,\r\nND_STATE_STR(nd->nd_state),\r\nnd->nd_chan_count);\r\nreturn 0;\r\n}\r\nstatic int dgrp_config_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &proc_config_ops);\r\n}\r\nstatic ssize_t dgrp_config_proc_write(struct file *file,\r\nconst char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nssize_t retval;\r\nchar *inbuf, *sp;\r\nchar *line, *ldelim;\r\nif (count > 32768)\r\nreturn -EINVAL;\r\ninbuf = sp = vzalloc(count + 1);\r\nif (!inbuf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(inbuf, buffer, count)) {\r\nretval = -EFAULT;\r\ngoto done;\r\n}\r\ninbuf[count] = 0;\r\nldelim = "\n";\r\nline = strpbrk(sp, ldelim);\r\nwhile (line) {\r\n*line = 0;\r\nretval = parse_write_config(sp);\r\nif (retval)\r\ngoto done;\r\nsp = line + 1;\r\nline = strpbrk(sp, ldelim);\r\n}\r\nretval = count;\r\ndone:\r\nvfree(inbuf);\r\nreturn retval;\r\n}\r\nstatic inline char *skip_past_ws(const char *str)\r\n{\r\nwhile ((*str) && !isspace(*str))\r\n++str;\r\nreturn skip_spaces(str);\r\n}\r\nstatic int parse_id(char **c, char *cID)\r\n{\r\nint tmp = **c;\r\nif (isalnum(tmp) || (tmp == '_'))\r\ncID[0] = tmp;\r\nelse\r\nreturn -EINVAL;\r\n(*c)++; tmp = **c;\r\nif (isalnum(tmp) || (tmp == '_')) {\r\ncID[1] = tmp;\r\n(*c)++;\r\n} else\r\ncID[1] = 0;\r\nreturn 0;\r\n}\r\nstatic int parse_add_config(char *buf)\r\n{\r\nchar *c = buf;\r\nint retval;\r\nchar cID[2];\r\nlong ID;\r\nc = skip_past_ws(c);\r\nretval = parse_id(&c, cID);\r\nif (retval < 0)\r\nreturn retval;\r\nID = CHAR_TO_ID(cID);\r\nc = skip_past_ws(c);\r\nreturn dgrp_add_id(ID);\r\n}\r\nstatic int parse_del_config(char *buf)\r\n{\r\nchar *c = buf;\r\nint retval;\r\nstruct nd_struct *nd;\r\nchar cID[2];\r\nlong ID;\r\nlong major;\r\nc = skip_past_ws(c);\r\nretval = parse_id(&c, cID);\r\nif (retval < 0)\r\nreturn retval;\r\nID = CHAR_TO_ID(cID);\r\nc = skip_past_ws(c);\r\nretval = kstrtol(c, 10, &major);\r\nif (retval)\r\nreturn retval;\r\nnd = nd_struct_get(major);\r\nif (!nd)\r\nreturn -EINVAL;\r\nif ((nd->nd_major != major) || (nd->nd_ID != ID))\r\nreturn -EINVAL;\r\nreturn dgrp_remove_nd(nd);\r\n}\r\nstatic int parse_chg_config(char *buf)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int parse_write_config(char *buf)\r\n{\r\nint retval;\r\nswitch (buf[0]) {\r\ncase '+':\r\nretval = parse_add_config(buf);\r\nbreak;\r\ncase '-':\r\nretval = parse_del_config(buf);\r\nbreak;\r\ncase '*':\r\nretval = parse_chg_config(buf);\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\n}\r\nreturn retval;\r\n}\r\nstatic int dgrp_info_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "version: %s\n", DIGI_VERSION);\r\nseq_puts(m, "register_with_sysfs: 1\n");\r\nseq_printf(m, "pollrate: 0x%08x\t(%d)\n",\r\ndgrp_poll_tick, dgrp_poll_tick);\r\nreturn 0;\r\n}\r\nstatic int dgrp_info_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dgrp_info_proc_show, NULL);\r\n}\r\nstatic void *dgrp_nodeinfo_start(struct seq_file *m, loff_t *pos)\r\n{\r\nreturn seq_list_start_head(&nd_struct_list, *pos);\r\n}\r\nstatic void *dgrp_nodeinfo_next(struct seq_file *p, void *v, loff_t *pos)\r\n{\r\nreturn seq_list_next(v, &nd_struct_list, pos);\r\n}\r\nstatic void dgrp_nodeinfo_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic int dgrp_nodeinfo_show(struct seq_file *m, void *v)\r\n{\r\nstruct nd_struct *nd;\r\nchar hwver[8];\r\nchar swver[8];\r\nchar tmp_id[4];\r\nif (v == &nd_struct_list) {\r\nseq_puts(m, "#-----------------------------------------------------------------------------\n");\r\nseq_puts(m, "# HW HW SW\n");\r\nseq_puts(m, "# ID State Version ID Version Description\n");\r\nreturn 0;\r\n}\r\nnd = list_entry(v, struct nd_struct, list);\r\nID_TO_CHAR(nd->nd_ID, tmp_id);\r\nif (nd->nd_state == NS_READY) {\r\nsprintf(hwver, "%d.%d", (nd->nd_hw_ver >> 8) & 0xff,\r\nnd->nd_hw_ver & 0xff);\r\nsprintf(swver, "%d.%d", (nd->nd_sw_ver >> 8) & 0xff,\r\nnd->nd_sw_ver & 0xff);\r\nseq_printf(m, " %-2.2s %-10.10s %-7.7s %-3d %-7.7s %-35.35s\n",\r\ntmp_id,\r\nND_STATE_STR(nd->nd_state),\r\nhwver,\r\nnd->nd_hw_id,\r\nswver,\r\nnd->nd_ps_desc);\r\n} else {\r\nseq_printf(m, " %-2.2s %-10.10s\n",\r\ntmp_id,\r\nND_STATE_STR(nd->nd_state));\r\n}\r\nreturn 0;\r\n}\r\nstatic int dgrp_nodeinfo_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &nodeinfo_ops);\r\n}\r\nstatic int dgrp_add_id(long id)\r\n{\r\nstruct nd_struct *nd;\r\nint ret;\r\nint i;\r\nnd = kzalloc(sizeof(struct nd_struct), GFP_KERNEL);\r\nif (!nd)\r\nreturn -ENOMEM;\r\nnd->nd_major = 0;\r\nnd->nd_ID = id;\r\nspin_lock_init(&nd->nd_lock);\r\ninit_waitqueue_head(&nd->nd_tx_waitq);\r\ninit_waitqueue_head(&nd->nd_mon_wqueue);\r\ninit_waitqueue_head(&nd->nd_dpa_wqueue);\r\nsema_init(&nd->nd_mon_semaphore, 1);\r\nsema_init(&nd->nd_net_semaphore, 1);\r\nspin_lock_init(&nd->nd_dpa_lock);\r\nnd->nd_state = NS_CLOSED;\r\nfor (i = 0; i < SEQ_MAX; i++)\r\ninit_waitqueue_head(&nd->nd_seq_wque[i]);\r\nret = dgrp_tty_init(nd);\r\nif (ret)\r\ngoto error_out;\r\nnd->nd_major = nd->nd_serial_ttdriver->major;\r\nret = nd_struct_add(nd);\r\nif (ret)\r\ngoto error_out;\r\ndgrp_create_node_class_sysfs_files(nd);\r\nnd->nd_net_de = add_proc_file(nd, net_entry_pointer, &dgrp_net_ops);\r\nnd->nd_mon_de = add_proc_file(nd, mon_entry_pointer, &dgrp_mon_ops);\r\nnd->nd_dpa_de = add_proc_file(nd, dpa_entry_pointer, &dgrp_dpa_ops);\r\nnd->nd_ports_de = add_proc_file(nd, ports_entry_pointer,\r\n&dgrp_ports_ops);\r\nreturn 0;\r\nerror_out:\r\nkfree(nd);\r\nreturn ret;\r\n}\r\nstatic int dgrp_remove_nd(struct nd_struct *nd)\r\n{\r\nint ret;\r\nif (nd->nd_tty_ref_cnt)\r\nreturn -EBUSY;\r\nremove_files(nd);\r\ndgrp_tty_uninit(nd);\r\nret = nd_struct_del(nd);\r\nif (ret)\r\nreturn ret;\r\nkfree(nd);\r\nreturn 0;\r\n}\r\nstatic struct proc_dir_entry *add_proc_file(struct nd_struct *node,\r\nstruct proc_dir_entry *root,\r\nconst struct file_operations *fops)\r\n{\r\nchar buf[3];\r\nID_TO_CHAR(node->nd_ID, buf);\r\nreturn proc_create_data(buf, 0600, root, fops, node);\r\n}
