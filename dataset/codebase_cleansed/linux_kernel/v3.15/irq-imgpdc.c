static void pdc_write(struct pdc_intc_priv *priv, unsigned int reg_offs,\r\nunsigned int data)\r\n{\r\niowrite32(data, priv->pdc_base + reg_offs);\r\n}\r\nstatic unsigned int pdc_read(struct pdc_intc_priv *priv,\r\nunsigned int reg_offs)\r\n{\r\nreturn ioread32(priv->pdc_base + reg_offs);\r\n}\r\nstatic unsigned int hwirq_is_syswake(irq_hw_number_t hw)\r\n{\r\nreturn hw >= SYS0_HWIRQ;\r\n}\r\nstatic unsigned int hwirq_to_syswake(irq_hw_number_t hw)\r\n{\r\nreturn hw - SYS0_HWIRQ;\r\n}\r\nstatic irq_hw_number_t syswake_to_hwirq(unsigned int syswake)\r\n{\r\nreturn SYS0_HWIRQ + syswake;\r\n}\r\nstatic struct pdc_intc_priv *irqd_to_priv(struct irq_data *data)\r\n{\r\nreturn (struct pdc_intc_priv *)data->domain->host_data;\r\n}\r\nstatic void perip_irq_mask(struct irq_data *data)\r\n{\r\nstruct pdc_intc_priv *priv = irqd_to_priv(data);\r\nraw_spin_lock(&priv->lock);\r\npriv->irq_route &= ~data->mask;\r\npdc_write(priv, PDC_IRQ_ROUTE, priv->irq_route);\r\nraw_spin_unlock(&priv->lock);\r\n}\r\nstatic void perip_irq_unmask(struct irq_data *data)\r\n{\r\nstruct pdc_intc_priv *priv = irqd_to_priv(data);\r\nraw_spin_lock(&priv->lock);\r\npriv->irq_route |= data->mask;\r\npdc_write(priv, PDC_IRQ_ROUTE, priv->irq_route);\r\nraw_spin_unlock(&priv->lock);\r\n}\r\nstatic int syswake_irq_set_type(struct irq_data *data, unsigned int flow_type)\r\n{\r\nstruct pdc_intc_priv *priv = irqd_to_priv(data);\r\nunsigned int syswake = hwirq_to_syswake(data->hwirq);\r\nunsigned int irq_mode;\r\nunsigned int soc_sys_wake_regoff, soc_sys_wake;\r\nswitch (flow_type) {\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nirq_mode = PDC_SYS_WAKE_INT_CHANGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nirq_mode = PDC_SYS_WAKE_INT_UP;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nirq_mode = PDC_SYS_WAKE_INT_DOWN;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nirq_mode = PDC_SYS_WAKE_INT_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nirq_mode = PDC_SYS_WAKE_INT_LOW;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nraw_spin_lock(&priv->lock);\r\nsoc_sys_wake_regoff = PDC_SYS_WAKE_BASE + syswake*PDC_SYS_WAKE_STRIDE;\r\nsoc_sys_wake = pdc_read(priv, soc_sys_wake_regoff);\r\nsoc_sys_wake &= ~PDC_SYS_WAKE_INT_MODE;\r\nsoc_sys_wake |= irq_mode << PDC_SYS_WAKE_INT_MODE_SHIFT;\r\npdc_write(priv, soc_sys_wake_regoff, soc_sys_wake);\r\nirq_setup_alt_chip(data, flow_type);\r\nraw_spin_unlock(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic int pdc_irq_set_wake(struct irq_data *data, unsigned int on)\r\n{\r\nstruct pdc_intc_priv *priv = irqd_to_priv(data);\r\nirq_hw_number_t hw = data->hwirq;\r\nunsigned int mask = (1 << 16) << hw;\r\nunsigned int dst_irq;\r\nraw_spin_lock(&priv->lock);\r\nif (on)\r\npriv->irq_route |= mask;\r\nelse\r\npriv->irq_route &= ~mask;\r\npdc_write(priv, PDC_IRQ_ROUTE, priv->irq_route);\r\nraw_spin_unlock(&priv->lock);\r\nif (hwirq_is_syswake(hw))\r\ndst_irq = priv->syswake_irq;\r\nelse\r\ndst_irq = priv->perip_irqs[hw];\r\nirq_set_irq_wake(dst_irq, on);\r\nreturn 0;\r\n}\r\nstatic void pdc_intc_perip_isr(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct pdc_intc_priv *priv;\r\nunsigned int i, irq_no;\r\npriv = (struct pdc_intc_priv *)irq_desc_get_handler_data(desc);\r\nfor (i = 0; i < priv->nr_perips; ++i)\r\nif (irq == priv->perip_irqs[i])\r\ngoto found;\r\nreturn;\r\nfound:\r\nirq_no = irq_linear_revmap(priv->domain, i);\r\ngeneric_handle_irq(irq_no);\r\n}\r\nstatic void pdc_intc_syswake_isr(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct pdc_intc_priv *priv;\r\nunsigned int syswake, irq_no;\r\nunsigned int status;\r\npriv = (struct pdc_intc_priv *)irq_desc_get_handler_data(desc);\r\nstatus = pdc_read(priv, PDC_IRQ_STATUS) &\r\npdc_read(priv, PDC_IRQ_ENABLE);\r\nstatus &= (1 << priv->nr_syswakes) - 1;\r\nfor (syswake = 0; status; status >>= 1, ++syswake) {\r\nif (!(status & 1))\r\ncontinue;\r\nirq_no = irq_linear_revmap(priv->domain,\r\nsyswake_to_hwirq(syswake));\r\ngeneric_handle_irq(irq_no);\r\n}\r\n}\r\nstatic void pdc_intc_setup(struct pdc_intc_priv *priv)\r\n{\r\nint i;\r\nunsigned int soc_sys_wake_regoff;\r\nunsigned int soc_sys_wake;\r\npdc_write(priv, PDC_IRQ_ENABLE, 0);\r\npriv->irq_route = ((PDC_IRQ_ROUTE_EXT_EN_SYS0 << priv->nr_syswakes) -\r\nPDC_IRQ_ROUTE_EXT_EN_SYS0);\r\npdc_write(priv, PDC_IRQ_ROUTE, priv->irq_route);\r\nfor (i = 0; i < priv->nr_syswakes; ++i) {\r\nsoc_sys_wake_regoff = PDC_SYS_WAKE_BASE + i*PDC_SYS_WAKE_STRIDE;\r\nsoc_sys_wake = PDC_SYS_WAKE_INT_NONE\r\n<< PDC_SYS_WAKE_INT_MODE_SHIFT;\r\npdc_write(priv, soc_sys_wake_regoff, soc_sys_wake);\r\n}\r\n}\r\nstatic int pdc_intc_probe(struct platform_device *pdev)\r\n{\r\nstruct pdc_intc_priv *priv;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct resource *res_regs;\r\nstruct irq_chip_generic *gc;\r\nunsigned int i;\r\nint irq, ret;\r\nu32 val;\r\nif (!node)\r\nreturn -ENOENT;\r\nres_regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res_regs == NULL) {\r\ndev_err(&pdev->dev, "cannot find registers resource\n");\r\nreturn -ENOENT;\r\n}\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&pdev->dev, "cannot allocate device data\n");\r\nreturn -ENOMEM;\r\n}\r\nraw_spin_lock_init(&priv->lock);\r\nplatform_set_drvdata(pdev, priv);\r\npriv->pdc_base = devm_ioremap(&pdev->dev, res_regs->start,\r\nres_regs->end - res_regs->start);\r\nif (!priv->pdc_base)\r\nreturn -EIO;\r\nret = of_property_read_u32(node, "num-perips", &val);\r\nif (ret) {\r\ndev_err(&pdev->dev, "No num-perips node property found\n");\r\nreturn -EINVAL;\r\n}\r\nif (val > SYS0_HWIRQ) {\r\ndev_err(&pdev->dev, "num-perips (%u) out of range\n", val);\r\nreturn -EINVAL;\r\n}\r\npriv->nr_perips = val;\r\nret = of_property_read_u32(node, "num-syswakes", &val);\r\nif (ret) {\r\ndev_err(&pdev->dev, "No num-syswakes node property found\n");\r\nreturn -EINVAL;\r\n}\r\nif (val > SYS0_HWIRQ) {\r\ndev_err(&pdev->dev, "num-syswakes (%u) out of range\n", val);\r\nreturn -EINVAL;\r\n}\r\npriv->nr_syswakes = val;\r\npriv->perip_irqs = devm_kzalloc(&pdev->dev, 4 * priv->nr_perips,\r\nGFP_KERNEL);\r\nif (!priv->perip_irqs) {\r\ndev_err(&pdev->dev, "cannot allocate perip IRQ list\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < priv->nr_perips; ++i) {\r\nirq = platform_get_irq(pdev, 1 + i);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "cannot find perip IRQ #%u\n", i);\r\nreturn irq;\r\n}\r\npriv->perip_irqs[i] = irq;\r\n}\r\nif (platform_get_irq(pdev, 1 + i) >= 0) {\r\ndev_err(&pdev->dev, "surplus perip IRQs detected\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "cannot find syswake IRQ\n");\r\nreturn irq;\r\n}\r\npriv->syswake_irq = irq;\r\npriv->domain = irq_domain_add_linear(node, 16, &irq_generic_chip_ops,\r\npriv);\r\nif (unlikely(!priv->domain)) {\r\ndev_err(&pdev->dev, "cannot add IRQ domain\n");\r\nreturn -ENOMEM;\r\n}\r\nret = irq_alloc_domain_generic_chips(priv->domain, 8, 2, "pdc",\r\nhandle_level_irq, 0, 0,\r\nIRQ_GC_INIT_NESTED_LOCK);\r\nif (ret)\r\ngoto err_generic;\r\ngc = irq_get_domain_generic_chip(priv->domain, 0);\r\ngc->unused = ~(BIT(priv->nr_perips) - 1);\r\ngc->reg_base = priv->pdc_base;\r\ngc->chip_types[0].regs.mask = PDC_IRQ_ROUTE;\r\ngc->chip_types[0].chip.irq_mask = perip_irq_mask;\r\ngc->chip_types[0].chip.irq_unmask = perip_irq_unmask;\r\ngc->chip_types[0].chip.irq_set_wake = pdc_irq_set_wake;\r\ngc = irq_get_domain_generic_chip(priv->domain, 8);\r\ngc->unused = ~(BIT(priv->nr_syswakes) - 1);\r\ngc->reg_base = priv->pdc_base;\r\ngc->chip_types[0].type = IRQ_TYPE_EDGE_BOTH;\r\ngc->chip_types[0].handler = handle_edge_irq;\r\ngc->chip_types[0].regs.ack = PDC_IRQ_CLEAR;\r\ngc->chip_types[0].regs.mask = PDC_IRQ_ENABLE;\r\ngc->chip_types[0].chip.irq_ack = irq_gc_ack_set_bit;\r\ngc->chip_types[0].chip.irq_mask = irq_gc_mask_clr_bit;\r\ngc->chip_types[0].chip.irq_unmask = irq_gc_mask_set_bit;\r\ngc->chip_types[0].chip.irq_set_type = syswake_irq_set_type;\r\ngc->chip_types[0].chip.irq_set_wake = pdc_irq_set_wake;\r\ngc->chip_types[0].chip.flags = IRQCHIP_MASK_ON_SUSPEND;\r\ngc->chip_types[1].type = IRQ_TYPE_LEVEL_MASK;\r\ngc->chip_types[1].handler = handle_level_irq;\r\ngc->chip_types[1].regs.ack = PDC_IRQ_CLEAR;\r\ngc->chip_types[1].regs.mask = PDC_IRQ_ENABLE;\r\ngc->chip_types[1].chip.irq_ack = irq_gc_ack_set_bit;\r\ngc->chip_types[1].chip.irq_mask = irq_gc_mask_clr_bit;\r\ngc->chip_types[1].chip.irq_unmask = irq_gc_mask_set_bit;\r\ngc->chip_types[1].chip.irq_set_type = syswake_irq_set_type;\r\ngc->chip_types[1].chip.irq_set_wake = pdc_irq_set_wake;\r\ngc->chip_types[1].chip.flags = IRQCHIP_MASK_ON_SUSPEND;\r\npdc_intc_setup(priv);\r\nfor (i = 0; i < priv->nr_perips; ++i) {\r\nirq = priv->perip_irqs[i];\r\nirq_set_handler_data(irq, priv);\r\nirq_set_chained_handler(irq, pdc_intc_perip_isr);\r\n}\r\nirq_set_handler_data(priv->syswake_irq, priv);\r\nirq_set_chained_handler(priv->syswake_irq, pdc_intc_syswake_isr);\r\ndev_info(&pdev->dev,\r\n"PDC IRQ controller initialised (%u perip IRQs, %u syswake IRQs)\n",\r\npriv->nr_perips,\r\npriv->nr_syswakes);\r\nreturn 0;\r\nerr_generic:\r\nirq_domain_remove(priv->domain);\r\nreturn ret;\r\n}\r\nstatic int pdc_intc_remove(struct platform_device *pdev)\r\n{\r\nstruct pdc_intc_priv *priv = platform_get_drvdata(pdev);\r\nirq_domain_remove(priv->domain);\r\nreturn 0;\r\n}\r\nstatic int __init pdc_intc_init(void)\r\n{\r\nreturn platform_driver_register(&pdc_intc_driver);\r\n}
