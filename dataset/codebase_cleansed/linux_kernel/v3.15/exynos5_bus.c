static void busfreq_mon_reset(struct busfreq_data_int *data)\r\n{\r\nunsigned int i;\r\nfor (i = PPMU_RIGHT; i < PPMU_END; i++) {\r\nvoid __iomem *ppmu_base = data->ppmu[i].hw_base;\r\nexynos_ppmu_reset(ppmu_base);\r\ndata->ppmu[i].event[PPMU_PMNCNT3] = RDWR_DATA_COUNT;\r\nexynos_ppmu_setevent(ppmu_base, PPMU_PMNCNT3,\r\ndata->ppmu[i].event[PPMU_PMNCNT3]);\r\nexynos_ppmu_start(ppmu_base);\r\n}\r\n}\r\nstatic void exynos5_read_ppmu(struct busfreq_data_int *data)\r\n{\r\nint i, j;\r\nfor (i = PPMU_RIGHT; i < PPMU_END; i++) {\r\nvoid __iomem *ppmu_base = data->ppmu[i].hw_base;\r\nexynos_ppmu_stop(ppmu_base);\r\ndata->ppmu[i].ccnt = __raw_readl(ppmu_base + PPMU_CCNT);\r\nfor (j = PPMU_PMNCNT0; j < PPMU_PMNCNT_MAX; j++) {\r\nif (data->ppmu[i].event[j] == 0)\r\ndata->ppmu[i].count[j] = 0;\r\nelse\r\ndata->ppmu[i].count[j] =\r\nexynos_ppmu_read(ppmu_base, j);\r\n}\r\n}\r\nbusfreq_mon_reset(data);\r\n}\r\nstatic int exynos5_int_setvolt(struct busfreq_data_int *data,\r\nunsigned long volt)\r\n{\r\nreturn regulator_set_voltage(data->vdd_int, volt, MAX_SAFEVOLT);\r\n}\r\nstatic int exynos5_busfreq_int_target(struct device *dev, unsigned long *_freq,\r\nu32 flags)\r\n{\r\nint err = 0;\r\nstruct platform_device *pdev = container_of(dev, struct platform_device,\r\ndev);\r\nstruct busfreq_data_int *data = platform_get_drvdata(pdev);\r\nstruct dev_pm_opp *opp;\r\nunsigned long old_freq, freq;\r\nunsigned long volt;\r\nrcu_read_lock();\r\nopp = devfreq_recommended_opp(dev, _freq, flags);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\ndev_err(dev, "%s: Invalid OPP.\n", __func__);\r\nreturn PTR_ERR(opp);\r\n}\r\nfreq = dev_pm_opp_get_freq(opp);\r\nvolt = dev_pm_opp_get_voltage(opp);\r\nrcu_read_unlock();\r\nold_freq = data->curr_freq;\r\nif (old_freq == freq)\r\nreturn 0;\r\ndev_dbg(dev, "targeting %lukHz %luuV\n", freq, volt);\r\nmutex_lock(&data->lock);\r\nif (data->disabled)\r\ngoto out;\r\nif (freq > exynos5_int_opp_table[0].clk)\r\npm_qos_update_request(&data->int_req, freq * 16 / 1000);\r\nelse\r\npm_qos_update_request(&data->int_req, -1);\r\nif (old_freq < freq)\r\nerr = exynos5_int_setvolt(data, volt);\r\nif (err)\r\ngoto out;\r\nerr = clk_set_rate(data->int_clk, freq * 1000);\r\nif (err)\r\ngoto out;\r\nif (old_freq > freq)\r\nerr = exynos5_int_setvolt(data, volt);\r\nif (err)\r\ngoto out;\r\ndata->curr_freq = freq;\r\nout:\r\nmutex_unlock(&data->lock);\r\nreturn err;\r\n}\r\nstatic int exynos5_get_busier_dmc(struct busfreq_data_int *data)\r\n{\r\nint i, j;\r\nint busy = 0;\r\nunsigned int temp = 0;\r\nfor (i = PPMU_RIGHT; i < PPMU_END; i++) {\r\nfor (j = PPMU_PMNCNT0; j < PPMU_PMNCNT_MAX; j++) {\r\nif (data->ppmu[i].count[j] > temp) {\r\ntemp = data->ppmu[i].count[j];\r\nbusy = i;\r\n}\r\n}\r\n}\r\nreturn busy;\r\n}\r\nstatic int exynos5_int_get_dev_status(struct device *dev,\r\nstruct devfreq_dev_status *stat)\r\n{\r\nstruct platform_device *pdev = container_of(dev, struct platform_device,\r\ndev);\r\nstruct busfreq_data_int *data = platform_get_drvdata(pdev);\r\nint busier_dmc;\r\nexynos5_read_ppmu(data);\r\nbusier_dmc = exynos5_get_busier_dmc(data);\r\nstat->current_frequency = data->curr_freq;\r\nstat->busy_time = data->ppmu[busier_dmc].count[PPMU_PMNCNT3];\r\nstat->busy_time *= 100 / INT_BUS_SATURATION_RATIO;\r\nstat->total_time = data->ppmu[busier_dmc].ccnt;\r\nreturn 0;\r\n}\r\nstatic void exynos5_int_exit(struct device *dev)\r\n{\r\nstruct platform_device *pdev = container_of(dev, struct platform_device,\r\ndev);\r\nstruct busfreq_data_int *data = platform_get_drvdata(pdev);\r\ndevfreq_unregister_opp_notifier(dev, data->devfreq);\r\n}\r\nstatic int exynos5250_init_int_tables(struct busfreq_data_int *data)\r\n{\r\nint i, err = 0;\r\nfor (i = LV_0; i < _LV_END; i++) {\r\nerr = dev_pm_opp_add(data->dev, exynos5_int_opp_table[i].clk,\r\nexynos5_int_opp_table[i].volt);\r\nif (err) {\r\ndev_err(data->dev, "Cannot add opp entries.\n");\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos5_busfreq_int_pm_notifier_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct busfreq_data_int *data = container_of(this,\r\nstruct busfreq_data_int, pm_notifier);\r\nstruct dev_pm_opp *opp;\r\nunsigned long maxfreq = ULONG_MAX;\r\nunsigned long freq;\r\nunsigned long volt;\r\nint err = 0;\r\nswitch (event) {\r\ncase PM_SUSPEND_PREPARE:\r\nmutex_lock(&data->lock);\r\ndata->disabled = true;\r\nrcu_read_lock();\r\nopp = dev_pm_opp_find_freq_floor(data->dev, &maxfreq);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\nerr = PTR_ERR(opp);\r\ngoto unlock;\r\n}\r\nfreq = dev_pm_opp_get_freq(opp);\r\nvolt = dev_pm_opp_get_voltage(opp);\r\nrcu_read_unlock();\r\nerr = exynos5_int_setvolt(data, volt);\r\nif (err)\r\ngoto unlock;\r\nerr = clk_set_rate(data->int_clk, freq * 1000);\r\nif (err)\r\ngoto unlock;\r\ndata->curr_freq = freq;\r\nunlock:\r\nmutex_unlock(&data->lock);\r\nif (err)\r\nreturn NOTIFY_BAD;\r\nreturn NOTIFY_OK;\r\ncase PM_POST_RESTORE:\r\ncase PM_POST_SUSPEND:\r\nmutex_lock(&data->lock);\r\ndata->disabled = false;\r\nmutex_unlock(&data->lock);\r\nreturn NOTIFY_OK;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int exynos5_busfreq_int_probe(struct platform_device *pdev)\r\n{\r\nstruct busfreq_data_int *data;\r\nstruct dev_pm_opp *opp;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np;\r\nunsigned long initial_freq;\r\nunsigned long initial_volt;\r\nint err = 0;\r\nint i;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct busfreq_data_int),\r\nGFP_KERNEL);\r\nif (data == NULL) {\r\ndev_err(dev, "Cannot allocate memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nnp = of_find_compatible_node(NULL, NULL, "samsung,exynos5250-ppmu");\r\nif (np == NULL) {\r\npr_err("Unable to find PPMU node\n");\r\nreturn -ENOENT;\r\n}\r\nfor (i = PPMU_RIGHT; i < PPMU_END; i++) {\r\ndata->ppmu[i].hw_base = of_iomap(np, i);\r\nif (data->ppmu[i].hw_base == NULL) {\r\ndev_err(&pdev->dev, "failed to map memory region\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\ndata->pm_notifier.notifier_call = exynos5_busfreq_int_pm_notifier_event;\r\ndata->dev = dev;\r\nmutex_init(&data->lock);\r\nerr = exynos5250_init_int_tables(data);\r\nif (err)\r\nreturn err;\r\ndata->vdd_int = devm_regulator_get(dev, "vdd_int");\r\nif (IS_ERR(data->vdd_int)) {\r\ndev_err(dev, "Cannot get the regulator \"vdd_int\"\n");\r\nreturn PTR_ERR(data->vdd_int);\r\n}\r\ndata->int_clk = devm_clk_get(dev, "int_clk");\r\nif (IS_ERR(data->int_clk)) {\r\ndev_err(dev, "Cannot get clock \"int_clk\"\n");\r\nreturn PTR_ERR(data->int_clk);\r\n}\r\nrcu_read_lock();\r\nopp = dev_pm_opp_find_freq_floor(dev,\r\n&exynos5_devfreq_int_profile.initial_freq);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\ndev_err(dev, "Invalid initial frequency %lu kHz.\n",\r\nexynos5_devfreq_int_profile.initial_freq);\r\nreturn PTR_ERR(opp);\r\n}\r\ninitial_freq = dev_pm_opp_get_freq(opp);\r\ninitial_volt = dev_pm_opp_get_voltage(opp);\r\nrcu_read_unlock();\r\ndata->curr_freq = initial_freq;\r\nerr = clk_set_rate(data->int_clk, initial_freq * 1000);\r\nif (err) {\r\ndev_err(dev, "Failed to set initial frequency\n");\r\nreturn err;\r\n}\r\nerr = exynos5_int_setvolt(data, initial_volt);\r\nif (err)\r\nreturn err;\r\nplatform_set_drvdata(pdev, data);\r\nbusfreq_mon_reset(data);\r\ndata->devfreq = devfreq_add_device(dev, &exynos5_devfreq_int_profile,\r\n"simple_ondemand", NULL);\r\nif (IS_ERR(data->devfreq)) {\r\nerr = PTR_ERR(data->devfreq);\r\ngoto err_devfreq_add;\r\n}\r\ndevfreq_register_opp_notifier(dev, data->devfreq);\r\nerr = register_pm_notifier(&data->pm_notifier);\r\nif (err) {\r\ndev_err(dev, "Failed to setup pm notifier\n");\r\ngoto err_devfreq_add;\r\n}\r\npm_qos_add_request(&data->int_req, PM_QOS_NETWORK_THROUGHPUT, -1);\r\nreturn 0;\r\nerr_devfreq_add:\r\ndevfreq_remove_device(data->devfreq);\r\nreturn err;\r\n}\r\nstatic int exynos5_busfreq_int_remove(struct platform_device *pdev)\r\n{\r\nstruct busfreq_data_int *data = platform_get_drvdata(pdev);\r\npm_qos_remove_request(&data->int_req);\r\nunregister_pm_notifier(&data->pm_notifier);\r\ndevfreq_remove_device(data->devfreq);\r\nreturn 0;\r\n}\r\nstatic int exynos5_busfreq_int_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = container_of(dev, struct platform_device,\r\ndev);\r\nstruct busfreq_data_int *data = platform_get_drvdata(pdev);\r\nbusfreq_mon_reset(data);\r\nreturn 0;\r\n}\r\nstatic int __init exynos5_busfreq_int_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&exynos5_busfreq_int_driver);\r\nif (ret < 0)\r\ngoto out;\r\nexynos5_devfreq_pdev =\r\nplatform_device_register_simple("exynos5-bus-int", -1, NULL, 0);\r\nif (IS_ERR(exynos5_devfreq_pdev)) {\r\nret = PTR_ERR(exynos5_devfreq_pdev);\r\ngoto out1;\r\n}\r\nreturn 0;\r\nout1:\r\nplatform_driver_unregister(&exynos5_busfreq_int_driver);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit exynos5_busfreq_int_exit(void)\r\n{\r\nplatform_device_unregister(exynos5_devfreq_pdev);\r\nplatform_driver_unregister(&exynos5_busfreq_int_driver);\r\n}
