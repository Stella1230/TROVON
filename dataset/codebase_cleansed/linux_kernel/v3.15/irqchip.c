bool kvm_irq_has_notifier(struct kvm *kvm, unsigned irqchip, unsigned pin)\r\n{\r\nstruct kvm_irq_ack_notifier *kian;\r\nint gsi;\r\nrcu_read_lock();\r\ngsi = rcu_dereference(kvm->irq_routing)->chip[irqchip][pin];\r\nif (gsi != -1)\r\nhlist_for_each_entry_rcu(kian, &kvm->irq_ack_notifier_list,\r\nlink)\r\nif (kian->gsi == gsi) {\r\nrcu_read_unlock();\r\nreturn true;\r\n}\r\nrcu_read_unlock();\r\nreturn false;\r\n}\r\nvoid kvm_notify_acked_irq(struct kvm *kvm, unsigned irqchip, unsigned pin)\r\n{\r\nstruct kvm_irq_ack_notifier *kian;\r\nint gsi;\r\ntrace_kvm_ack_irq(irqchip, pin);\r\nrcu_read_lock();\r\ngsi = rcu_dereference(kvm->irq_routing)->chip[irqchip][pin];\r\nif (gsi != -1)\r\nhlist_for_each_entry_rcu(kian, &kvm->irq_ack_notifier_list,\r\nlink)\r\nif (kian->gsi == gsi)\r\nkian->irq_acked(kian);\r\nrcu_read_unlock();\r\n}\r\nvoid kvm_register_irq_ack_notifier(struct kvm *kvm,\r\nstruct kvm_irq_ack_notifier *kian)\r\n{\r\nmutex_lock(&kvm->irq_lock);\r\nhlist_add_head_rcu(&kian->link, &kvm->irq_ack_notifier_list);\r\nmutex_unlock(&kvm->irq_lock);\r\n#ifdef __KVM_HAVE_IOAPIC\r\nkvm_vcpu_request_scan_ioapic(kvm);\r\n#endif\r\n}\r\nvoid kvm_unregister_irq_ack_notifier(struct kvm *kvm,\r\nstruct kvm_irq_ack_notifier *kian)\r\n{\r\nmutex_lock(&kvm->irq_lock);\r\nhlist_del_init_rcu(&kian->link);\r\nmutex_unlock(&kvm->irq_lock);\r\nsynchronize_rcu();\r\n#ifdef __KVM_HAVE_IOAPIC\r\nkvm_vcpu_request_scan_ioapic(kvm);\r\n#endif\r\n}\r\nint kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi)\r\n{\r\nstruct kvm_kernel_irq_routing_entry route;\r\nif (!irqchip_in_kernel(kvm) || msi->flags != 0)\r\nreturn -EINVAL;\r\nroute.msi.address_lo = msi->address_lo;\r\nroute.msi.address_hi = msi->address_hi;\r\nroute.msi.data = msi->data;\r\nreturn kvm_set_msi(&route, kvm, KVM_USERSPACE_IRQ_SOURCE_ID, 1, false);\r\n}\r\nint kvm_set_irq(struct kvm *kvm, int irq_source_id, u32 irq, int level,\r\nbool line_status)\r\n{\r\nstruct kvm_kernel_irq_routing_entry *e, irq_set[KVM_NR_IRQCHIPS];\r\nint ret = -1, i = 0;\r\nstruct kvm_irq_routing_table *irq_rt;\r\ntrace_kvm_set_irq(irq, level, irq_source_id);\r\nrcu_read_lock();\r\nirq_rt = rcu_dereference(kvm->irq_routing);\r\nif (irq < irq_rt->nr_rt_entries)\r\nhlist_for_each_entry(e, &irq_rt->map[irq], link)\r\nirq_set[i++] = *e;\r\nrcu_read_unlock();\r\nwhile(i--) {\r\nint r;\r\nr = irq_set[i].set(&irq_set[i], kvm, irq_source_id, level,\r\nline_status);\r\nif (r < 0)\r\ncontinue;\r\nret = r + ((ret < 0) ? 0 : ret);\r\n}\r\nreturn ret;\r\n}\r\nvoid kvm_free_irq_routing(struct kvm *kvm)\r\n{\r\nkfree(kvm->irq_routing);\r\n}\r\nstatic int setup_routing_entry(struct kvm_irq_routing_table *rt,\r\nstruct kvm_kernel_irq_routing_entry *e,\r\nconst struct kvm_irq_routing_entry *ue)\r\n{\r\nint r = -EINVAL;\r\nstruct kvm_kernel_irq_routing_entry *ei;\r\nhlist_for_each_entry(ei, &rt->map[ue->gsi], link)\r\nif (ei->type == KVM_IRQ_ROUTING_MSI ||\r\nue->type == KVM_IRQ_ROUTING_MSI ||\r\nue->u.irqchip.irqchip == ei->irqchip.irqchip)\r\nreturn r;\r\ne->gsi = ue->gsi;\r\ne->type = ue->type;\r\nr = kvm_set_routing_entry(rt, e, ue);\r\nif (r)\r\ngoto out;\r\nhlist_add_head(&e->link, &rt->map[e->gsi]);\r\nr = 0;\r\nout:\r\nreturn r;\r\n}\r\nint kvm_set_irq_routing(struct kvm *kvm,\r\nconst struct kvm_irq_routing_entry *ue,\r\nunsigned nr,\r\nunsigned flags)\r\n{\r\nstruct kvm_irq_routing_table *new, *old;\r\nu32 i, j, nr_rt_entries = 0;\r\nint r;\r\nfor (i = 0; i < nr; ++i) {\r\nif (ue[i].gsi >= KVM_MAX_IRQ_ROUTES)\r\nreturn -EINVAL;\r\nnr_rt_entries = max(nr_rt_entries, ue[i].gsi);\r\n}\r\nnr_rt_entries += 1;\r\nnew = kzalloc(sizeof(*new) + (nr_rt_entries * sizeof(struct hlist_head))\r\n+ (nr * sizeof(struct kvm_kernel_irq_routing_entry)),\r\nGFP_KERNEL);\r\nif (!new)\r\nreturn -ENOMEM;\r\nnew->rt_entries = (void *)&new->map[nr_rt_entries];\r\nnew->nr_rt_entries = nr_rt_entries;\r\nfor (i = 0; i < KVM_NR_IRQCHIPS; i++)\r\nfor (j = 0; j < KVM_IRQCHIP_NUM_PINS; j++)\r\nnew->chip[i][j] = -1;\r\nfor (i = 0; i < nr; ++i) {\r\nr = -EINVAL;\r\nif (ue->flags)\r\ngoto out;\r\nr = setup_routing_entry(new, &new->rt_entries[i], ue);\r\nif (r)\r\ngoto out;\r\n++ue;\r\n}\r\nmutex_lock(&kvm->irq_lock);\r\nold = kvm->irq_routing;\r\nkvm_irq_routing_update(kvm, new);\r\nmutex_unlock(&kvm->irq_lock);\r\nsynchronize_rcu();\r\nnew = old;\r\nr = 0;\r\nout:\r\nkfree(new);\r\nreturn r;\r\n}
