static int va1j5jf8007s_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct va1j5jf8007s_state *state;\r\nu8 addr;\r\nint i;\r\nu8 write_buf[1], read_buf[1];\r\nstruct i2c_msg msgs[2];\r\ns32 word, x1, x2, x3, x4, x5, y;\r\nstate = fe->demodulator_priv;\r\naddr = state->config->demod_address;\r\nword = 0;\r\nfor (i = 0; i < 2; i++) {\r\nwrite_buf[0] = 0xbc + i;\r\nmsgs[0].addr = addr;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = sizeof(write_buf);\r\nmsgs[0].buf = write_buf;\r\nmsgs[1].addr = addr;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[1].len = sizeof(read_buf);\r\nmsgs[1].buf = read_buf;\r\nif (i2c_transfer(state->adap, msgs, 2) != 2)\r\nreturn -EREMOTEIO;\r\nword <<= 8;\r\nword |= read_buf[0];\r\n}\r\nword -= 3000;\r\nif (word < 0)\r\nword = 0;\r\nx1 = int_sqrt(word << 16) * ((15625ll << 21) / 1000000);\r\nx2 = (s64)x1 * x1 >> 31;\r\nx3 = (s64)x2 * x1 >> 31;\r\nx4 = (s64)x2 * x2 >> 31;\r\nx5 = (s64)x4 * x1 >> 31;\r\ny = (58857ll << 23) / 1000;\r\ny -= (s64)x1 * ((89565ll << 24) / 1000) >> 30;\r\ny += (s64)x2 * ((88977ll << 24) / 1000) >> 28;\r\ny -= (s64)x3 * ((50259ll << 25) / 1000) >> 27;\r\ny += (s64)x4 * ((14341ll << 27) / 1000) >> 27;\r\ny -= (s64)x5 * ((16346ll << 30) / 10000) >> 28;\r\n*snr = y < 0 ? 0 : y >> 15;\r\nreturn 0;\r\n}\r\nstatic int va1j5jf8007s_get_frontend_algo(struct dvb_frontend *fe)\r\n{\r\nreturn DVBFE_ALGO_HW;\r\n}\r\nstatic int\r\nva1j5jf8007s_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct va1j5jf8007s_state *state;\r\nstate = fe->demodulator_priv;\r\nswitch (state->tune_state) {\r\ncase VA1J5JF8007S_IDLE:\r\ncase VA1J5JF8007S_SET_FREQUENCY_1:\r\ncase VA1J5JF8007S_SET_FREQUENCY_2:\r\ncase VA1J5JF8007S_SET_FREQUENCY_3:\r\ncase VA1J5JF8007S_CHECK_FREQUENCY:\r\n*status = 0;\r\nreturn 0;\r\ncase VA1J5JF8007S_SET_MODULATION:\r\ncase VA1J5JF8007S_CHECK_MODULATION:\r\n*status |= FE_HAS_SIGNAL;\r\nreturn 0;\r\ncase VA1J5JF8007S_SET_TS_ID:\r\ncase VA1J5JF8007S_CHECK_TS_ID:\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\nreturn 0;\r\ncase VA1J5JF8007S_TRACK:\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nBUG();\r\n}\r\nstatic u8 va1j5jf8007s_lookup_cb(u32 frequency)\r\n{\r\nint i;\r\nconst struct va1j5jf8007s_cb_map *map;\r\nfor (i = 0; i < ARRAY_SIZE(va1j5jf8007s_cb_maps); i++) {\r\nmap = &va1j5jf8007s_cb_maps[i];\r\nif (frequency < map->frequency)\r\nreturn map->cb;\r\n}\r\nreturn 0xc0;\r\n}\r\nstatic int va1j5jf8007s_set_frequency_1(struct va1j5jf8007s_state *state)\r\n{\r\nu32 frequency;\r\nu16 word;\r\nu8 buf[6];\r\nstruct i2c_msg msg;\r\nfrequency = state->fe.dtv_property_cache.frequency;\r\nword = (frequency + 500) / 1000;\r\nif (frequency < 1072000)\r\nword = (word << 1 & ~0x1f) | (word & 0x0f);\r\nbuf[0] = 0xfe;\r\nbuf[1] = 0xc0;\r\nbuf[2] = 0x40 | word >> 8;\r\nbuf[3] = word;\r\nbuf[4] = 0xe0;\r\nbuf[5] = va1j5jf8007s_lookup_cb(frequency);\r\nmsg.addr = state->config->demod_address;\r\nmsg.flags = 0;\r\nmsg.len = sizeof(buf);\r\nmsg.buf = buf;\r\nif (i2c_transfer(state->adap, &msg, 1) != 1)\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int va1j5jf8007s_set_frequency_2(struct va1j5jf8007s_state *state)\r\n{\r\nu8 buf[3];\r\nstruct i2c_msg msg;\r\nbuf[0] = 0xfe;\r\nbuf[1] = 0xc0;\r\nbuf[2] = 0xe4;\r\nmsg.addr = state->config->demod_address;\r\nmsg.flags = 0;\r\nmsg.len = sizeof(buf);\r\nmsg.buf = buf;\r\nif (i2c_transfer(state->adap, &msg, 1) != 1)\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int va1j5jf8007s_set_frequency_3(struct va1j5jf8007s_state *state)\r\n{\r\nu32 frequency;\r\nu8 buf[4];\r\nstruct i2c_msg msg;\r\nfrequency = state->fe.dtv_property_cache.frequency;\r\nbuf[0] = 0xfe;\r\nbuf[1] = 0xc0;\r\nbuf[2] = 0xf4;\r\nbuf[3] = va1j5jf8007s_lookup_cb(frequency) | 0x4;\r\nmsg.addr = state->config->demod_address;\r\nmsg.flags = 0;\r\nmsg.len = sizeof(buf);\r\nmsg.buf = buf;\r\nif (i2c_transfer(state->adap, &msg, 1) != 1)\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nva1j5jf8007s_check_frequency(struct va1j5jf8007s_state *state, int *lock)\r\n{\r\nu8 addr;\r\nu8 write_buf[2], read_buf[1];\r\nstruct i2c_msg msgs[2];\r\naddr = state->config->demod_address;\r\nwrite_buf[0] = 0xfe;\r\nwrite_buf[1] = 0xc1;\r\nmsgs[0].addr = addr;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = sizeof(write_buf);\r\nmsgs[0].buf = write_buf;\r\nmsgs[1].addr = addr;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[1].len = sizeof(read_buf);\r\nmsgs[1].buf = read_buf;\r\nif (i2c_transfer(state->adap, msgs, 2) != 2)\r\nreturn -EREMOTEIO;\r\n*lock = read_buf[0] & 0x40;\r\nreturn 0;\r\n}\r\nstatic int va1j5jf8007s_set_modulation(struct va1j5jf8007s_state *state)\r\n{\r\nu8 buf[2];\r\nstruct i2c_msg msg;\r\nbuf[0] = 0x03;\r\nbuf[1] = 0x01;\r\nmsg.addr = state->config->demod_address;\r\nmsg.flags = 0;\r\nmsg.len = sizeof(buf);\r\nmsg.buf = buf;\r\nif (i2c_transfer(state->adap, &msg, 1) != 1)\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nva1j5jf8007s_check_modulation(struct va1j5jf8007s_state *state, int *lock)\r\n{\r\nu8 addr;\r\nu8 write_buf[1], read_buf[1];\r\nstruct i2c_msg msgs[2];\r\naddr = state->config->demod_address;\r\nwrite_buf[0] = 0xc3;\r\nmsgs[0].addr = addr;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = sizeof(write_buf);\r\nmsgs[0].buf = write_buf;\r\nmsgs[1].addr = addr;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[1].len = sizeof(read_buf);\r\nmsgs[1].buf = read_buf;\r\nif (i2c_transfer(state->adap, msgs, 2) != 2)\r\nreturn -EREMOTEIO;\r\n*lock = !(read_buf[0] & 0x10);\r\nreturn 0;\r\n}\r\nstatic int\r\nva1j5jf8007s_set_ts_id(struct va1j5jf8007s_state *state)\r\n{\r\nu32 ts_id;\r\nu8 buf[3];\r\nstruct i2c_msg msg;\r\nts_id = state->fe.dtv_property_cache.stream_id;\r\nif (!ts_id || ts_id == NO_STREAM_ID_FILTER)\r\nreturn 0;\r\nbuf[0] = 0x8f;\r\nbuf[1] = ts_id >> 8;\r\nbuf[2] = ts_id;\r\nmsg.addr = state->config->demod_address;\r\nmsg.flags = 0;\r\nmsg.len = sizeof(buf);\r\nmsg.buf = buf;\r\nif (i2c_transfer(state->adap, &msg, 1) != 1)\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nva1j5jf8007s_check_ts_id(struct va1j5jf8007s_state *state, int *lock)\r\n{\r\nu8 addr;\r\nu8 write_buf[1], read_buf[2];\r\nstruct i2c_msg msgs[2];\r\nu32 ts_id;\r\nts_id = state->fe.dtv_property_cache.stream_id;\r\nif (!ts_id || ts_id == NO_STREAM_ID_FILTER) {\r\n*lock = 1;\r\nreturn 0;\r\n}\r\naddr = state->config->demod_address;\r\nwrite_buf[0] = 0xe6;\r\nmsgs[0].addr = addr;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = sizeof(write_buf);\r\nmsgs[0].buf = write_buf;\r\nmsgs[1].addr = addr;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[1].len = sizeof(read_buf);\r\nmsgs[1].buf = read_buf;\r\nif (i2c_transfer(state->adap, msgs, 2) != 2)\r\nreturn -EREMOTEIO;\r\n*lock = (read_buf[0] << 8 | read_buf[1]) == ts_id;\r\nreturn 0;\r\n}\r\nstatic int\r\nva1j5jf8007s_tune(struct dvb_frontend *fe,\r\nbool re_tune,\r\nunsigned int mode_flags, unsigned int *delay,\r\nfe_status_t *status)\r\n{\r\nstruct va1j5jf8007s_state *state;\r\nint ret;\r\nint lock = 0;\r\nstate = fe->demodulator_priv;\r\nif (re_tune)\r\nstate->tune_state = VA1J5JF8007S_SET_FREQUENCY_1;\r\nswitch (state->tune_state) {\r\ncase VA1J5JF8007S_IDLE:\r\n*delay = 3 * HZ;\r\n*status = 0;\r\nreturn 0;\r\ncase VA1J5JF8007S_SET_FREQUENCY_1:\r\nret = va1j5jf8007s_set_frequency_1(state);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->tune_state = VA1J5JF8007S_SET_FREQUENCY_2;\r\n*delay = 0;\r\n*status = 0;\r\nreturn 0;\r\ncase VA1J5JF8007S_SET_FREQUENCY_2:\r\nret = va1j5jf8007s_set_frequency_2(state);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->tune_state = VA1J5JF8007S_SET_FREQUENCY_3;\r\n*delay = (HZ + 99) / 100;\r\n*status = 0;\r\nreturn 0;\r\ncase VA1J5JF8007S_SET_FREQUENCY_3:\r\nret = va1j5jf8007s_set_frequency_3(state);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->tune_state = VA1J5JF8007S_CHECK_FREQUENCY;\r\n*delay = 0;\r\n*status = 0;\r\nreturn 0;\r\ncase VA1J5JF8007S_CHECK_FREQUENCY:\r\nret = va1j5jf8007s_check_frequency(state, &lock);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!lock) {\r\n*delay = (HZ + 999) / 1000;\r\n*status = 0;\r\nreturn 0;\r\n}\r\nstate->tune_state = VA1J5JF8007S_SET_MODULATION;\r\n*delay = 0;\r\n*status = FE_HAS_SIGNAL;\r\nreturn 0;\r\ncase VA1J5JF8007S_SET_MODULATION:\r\nret = va1j5jf8007s_set_modulation(state);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->tune_state = VA1J5JF8007S_CHECK_MODULATION;\r\n*delay = 0;\r\n*status = FE_HAS_SIGNAL;\r\nreturn 0;\r\ncase VA1J5JF8007S_CHECK_MODULATION:\r\nret = va1j5jf8007s_check_modulation(state, &lock);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!lock) {\r\n*delay = (HZ + 49) / 50;\r\n*status = FE_HAS_SIGNAL;\r\nreturn 0;\r\n}\r\nstate->tune_state = VA1J5JF8007S_SET_TS_ID;\r\n*delay = 0;\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\nreturn 0;\r\ncase VA1J5JF8007S_SET_TS_ID:\r\nret = va1j5jf8007s_set_ts_id(state);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->tune_state = VA1J5JF8007S_CHECK_TS_ID;\r\nreturn 0;\r\ncase VA1J5JF8007S_CHECK_TS_ID:\r\nret = va1j5jf8007s_check_ts_id(state, &lock);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!lock) {\r\n*delay = (HZ + 99) / 100;\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\nreturn 0;\r\n}\r\nstate->tune_state = VA1J5JF8007S_TRACK;\r\ncase VA1J5JF8007S_TRACK:\r\n*delay = 3 * HZ;\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nBUG();\r\n}\r\nstatic int va1j5jf8007s_init_frequency(struct va1j5jf8007s_state *state)\r\n{\r\nu8 buf[4];\r\nstruct i2c_msg msg;\r\nbuf[0] = 0xfe;\r\nbuf[1] = 0xc0;\r\nbuf[2] = 0xf0;\r\nbuf[3] = 0x04;\r\nmsg.addr = state->config->demod_address;\r\nmsg.flags = 0;\r\nmsg.len = sizeof(buf);\r\nmsg.buf = buf;\r\nif (i2c_transfer(state->adap, &msg, 1) != 1)\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int va1j5jf8007s_set_sleep(struct va1j5jf8007s_state *state, int sleep)\r\n{\r\nu8 buf[2];\r\nstruct i2c_msg msg;\r\nbuf[0] = 0x17;\r\nbuf[1] = sleep ? 0x01 : 0x00;\r\nmsg.addr = state->config->demod_address;\r\nmsg.flags = 0;\r\nmsg.len = sizeof(buf);\r\nmsg.buf = buf;\r\nif (i2c_transfer(state->adap, &msg, 1) != 1)\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int va1j5jf8007s_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct va1j5jf8007s_state *state;\r\nint ret;\r\nstate = fe->demodulator_priv;\r\nret = va1j5jf8007s_init_frequency(state);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn va1j5jf8007s_set_sleep(state, 1);\r\n}\r\nstatic int va1j5jf8007s_init(struct dvb_frontend *fe)\r\n{\r\nstruct va1j5jf8007s_state *state;\r\nstate = fe->demodulator_priv;\r\nstate->tune_state = VA1J5JF8007S_IDLE;\r\nreturn va1j5jf8007s_set_sleep(state, 0);\r\n}\r\nstatic void va1j5jf8007s_release(struct dvb_frontend *fe)\r\n{\r\nstruct va1j5jf8007s_state *state;\r\nstate = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstatic int va1j5jf8007s_prepare_1(struct va1j5jf8007s_state *state)\r\n{\r\nu8 addr;\r\nu8 write_buf[1], read_buf[1];\r\nstruct i2c_msg msgs[2];\r\naddr = state->config->demod_address;\r\nwrite_buf[0] = 0x07;\r\nmsgs[0].addr = addr;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = sizeof(write_buf);\r\nmsgs[0].buf = write_buf;\r\nmsgs[1].addr = addr;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[1].len = sizeof(read_buf);\r\nmsgs[1].buf = read_buf;\r\nif (i2c_transfer(state->adap, msgs, 2) != 2)\r\nreturn -EREMOTEIO;\r\nif (read_buf[0] != 0x41)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int va1j5jf8007s_prepare_2(struct va1j5jf8007s_state *state)\r\n{\r\nconst u8 (*bufs)[2];\r\nint size;\r\nu8 addr;\r\nu8 buf[2];\r\nstruct i2c_msg msg;\r\nint i;\r\nswitch (state->config->frequency) {\r\ncase VA1J5JF8007S_20MHZ:\r\nbufs = va1j5jf8007s_20mhz_prepare_bufs;\r\nsize = ARRAY_SIZE(va1j5jf8007s_20mhz_prepare_bufs);\r\nbreak;\r\ncase VA1J5JF8007S_25MHZ:\r\nbufs = va1j5jf8007s_25mhz_prepare_bufs;\r\nsize = ARRAY_SIZE(va1j5jf8007s_25mhz_prepare_bufs);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\naddr = state->config->demod_address;\r\nmsg.addr = addr;\r\nmsg.flags = 0;\r\nmsg.len = 2;\r\nmsg.buf = buf;\r\nfor (i = 0; i < size; i++) {\r\nmemcpy(buf, bufs[i], sizeof(buf));\r\nif (i2c_transfer(state->adap, &msg, 1) != 1)\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nint va1j5jf8007s_prepare(struct dvb_frontend *fe)\r\n{\r\nstruct va1j5jf8007s_state *state;\r\nint ret;\r\nstate = fe->demodulator_priv;\r\nret = va1j5jf8007s_prepare_1(state);\r\nif (ret < 0)\r\nreturn ret;\r\nret = va1j5jf8007s_prepare_2(state);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn va1j5jf8007s_init_frequency(state);\r\n}\r\nstruct dvb_frontend *\r\nva1j5jf8007s_attach(const struct va1j5jf8007s_config *config,\r\nstruct i2c_adapter *adap)\r\n{\r\nstruct va1j5jf8007s_state *state;\r\nstruct dvb_frontend *fe;\r\nu8 buf[2];\r\nstruct i2c_msg msg;\r\nstate = kzalloc(sizeof(struct va1j5jf8007s_state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\nstate->config = config;\r\nstate->adap = adap;\r\nfe = &state->fe;\r\nmemcpy(&fe->ops, &va1j5jf8007s_ops, sizeof(struct dvb_frontend_ops));\r\nfe->demodulator_priv = state;\r\nbuf[0] = 0x01;\r\nbuf[1] = 0x80;\r\nmsg.addr = state->config->demod_address;\r\nmsg.flags = 0;\r\nmsg.len = sizeof(buf);\r\nmsg.buf = buf;\r\nif (i2c_transfer(state->adap, &msg, 1) != 1) {\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nreturn fe;\r\n}
