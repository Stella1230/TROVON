static const struct cx25821_fmt *cx25821_format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++)\r\nif (formats[i].fourcc == fourcc)\r\nreturn formats + i;\r\nreturn NULL;\r\n}\r\nvoid cx25821_video_wakeup(struct cx25821_dev *dev, struct cx25821_dmaqueue *q,\r\nu32 count)\r\n{\r\nstruct cx25821_buffer *buf;\r\nint bc;\r\nfor (bc = 0;; bc++) {\r\nif (list_empty(&q->active)) {\r\ndprintk(1, "bc=%d (=0: active empty)\n", bc);\r\nbreak;\r\n}\r\nbuf = list_entry(q->active.next, struct cx25821_buffer,\r\nvb.queue);\r\nif ((s16) (count - buf->count) < 0)\r\nbreak;\r\nv4l2_get_timestamp(&buf->vb.ts);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nlist_del(&buf->vb.queue);\r\nwake_up(&buf->vb.done);\r\n}\r\nif (list_empty(&q->active))\r\ndel_timer(&q->timeout);\r\nelse\r\nmod_timer(&q->timeout, jiffies + BUFFER_TIMEOUT);\r\nif (bc != 1)\r\npr_err("%s: %d buffers handled (should be 1)\n", __func__, bc);\r\n}\r\nint cx25821_start_video_dma(struct cx25821_dev *dev,\r\nstruct cx25821_dmaqueue *q,\r\nstruct cx25821_buffer *buf,\r\nconst struct sram_channel *channel)\r\n{\r\nint tmp = 0;\r\ncx25821_sram_channel_setup(dev, channel, buf->bpl, buf->risc.dma);\r\ncx_write(channel->gpcnt_ctl, 3);\r\nq->count = 1;\r\ncx_set(PCI_INT_MSK, cx_read(PCI_INT_MSK) | (1 << channel->i));\r\ncx_set(channel->int_msk, 0x11);\r\ncx_write(channel->dma_ctl, 0x11);\r\ntmp = cx_read(VID_CH_MODE_SEL);\r\ncx_write(VID_CH_MODE_SEL, tmp & 0xFFFFFE00);\r\nreturn 0;\r\n}\r\nstatic int cx25821_restart_video_queue(struct cx25821_dev *dev,\r\nstruct cx25821_dmaqueue *q,\r\nconst struct sram_channel *channel)\r\n{\r\nstruct cx25821_buffer *buf, *prev;\r\nstruct list_head *item;\r\nif (!list_empty(&q->active)) {\r\nbuf = list_entry(q->active.next, struct cx25821_buffer,\r\nvb.queue);\r\ncx25821_start_video_dma(dev, q, buf, channel);\r\nlist_for_each(item, &q->active) {\r\nbuf = list_entry(item, struct cx25821_buffer, vb.queue);\r\nbuf->count = q->count++;\r\n}\r\nmod_timer(&q->timeout, jiffies + BUFFER_TIMEOUT);\r\nreturn 0;\r\n}\r\nprev = NULL;\r\nfor (;;) {\r\nif (list_empty(&q->queued))\r\nreturn 0;\r\nbuf = list_entry(q->queued.next, struct cx25821_buffer,\r\nvb.queue);\r\nif (NULL == prev) {\r\nlist_move_tail(&buf->vb.queue, &q->active);\r\ncx25821_start_video_dma(dev, q, buf, channel);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nmod_timer(&q->timeout, jiffies + BUFFER_TIMEOUT);\r\n} else if (prev->vb.width == buf->vb.width &&\r\nprev->vb.height == buf->vb.height &&\r\nprev->fmt == buf->fmt) {\r\nlist_move_tail(&buf->vb.queue, &q->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\nprev->risc.jmp[2] = cpu_to_le32(0);\r\n} else {\r\nreturn 0;\r\n}\r\nprev = buf;\r\n}\r\n}\r\nstatic void cx25821_vid_timeout(unsigned long data)\r\n{\r\nstruct cx25821_data *timeout_data = (struct cx25821_data *)data;\r\nstruct cx25821_dev *dev = timeout_data->dev;\r\nconst struct sram_channel *channel = timeout_data->channel;\r\nstruct cx25821_dmaqueue *q = &dev->channels[channel->i].dma_vidq;\r\nstruct cx25821_buffer *buf;\r\nunsigned long flags;\r\ncx_clear(channel->dma_ctl, 0x11);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nwhile (!list_empty(&q->active)) {\r\nbuf = list_entry(q->active.next, struct cx25821_buffer,\r\nvb.queue);\r\nlist_del(&buf->vb.queue);\r\nbuf->vb.state = VIDEOBUF_ERROR;\r\nwake_up(&buf->vb.done);\r\n}\r\ncx25821_restart_video_queue(dev, q, channel);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nint cx25821_video_irq(struct cx25821_dev *dev, int chan_num, u32 status)\r\n{\r\nu32 count = 0;\r\nint handled = 0;\r\nu32 mask;\r\nconst struct sram_channel *channel = dev->channels[chan_num].sram_channels;\r\nmask = cx_read(channel->int_msk);\r\nif (0 == (status & mask))\r\nreturn handled;\r\ncx_write(channel->int_stat, status);\r\nif (status & (1 << 16)) {\r\npr_warn("%s, %s: video risc op code error\n",\r\ndev->name, channel->name);\r\ncx_clear(channel->dma_ctl, 0x11);\r\ncx25821_sram_channel_dump(dev, channel);\r\n}\r\nif (status & FLD_VID_DST_RISC1) {\r\nspin_lock(&dev->slock);\r\ncount = cx_read(channel->gpcnt);\r\ncx25821_video_wakeup(dev, &dev->channels[channel->i].dma_vidq,\r\ncount);\r\nspin_unlock(&dev->slock);\r\nhandled++;\r\n}\r\nif (status & 0x10) {\r\ndprintk(2, "stopper video\n");\r\nspin_lock(&dev->slock);\r\ncx25821_restart_video_queue(dev,\r\n&dev->channels[channel->i].dma_vidq, channel);\r\nspin_unlock(&dev->slock);\r\nhandled++;\r\n}\r\nreturn handled;\r\n}\r\nstatic int cx25821_buffer_setup(struct videobuf_queue *q, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct cx25821_channel *chan = q->priv_data;\r\n*size = chan->fmt->depth * chan->width * chan->height >> 3;\r\nif (0 == *count)\r\n*count = 32;\r\nif (*size * *count > vid_limit * 1024 * 1024)\r\n*count = (vid_limit * 1024 * 1024) / *size;\r\nreturn 0;\r\n}\r\nstatic int cx25821_buffer_prepare(struct videobuf_queue *q, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct cx25821_channel *chan = q->priv_data;\r\nstruct cx25821_dev *dev = chan->dev;\r\nstruct cx25821_buffer *buf =\r\ncontainer_of(vb, struct cx25821_buffer, vb);\r\nint rc, init_buffer = 0;\r\nu32 line0_offset;\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(&buf->vb);\r\nint bpl_local = LINE_SIZE_D1;\r\nBUG_ON(NULL == chan->fmt);\r\nif (chan->width < 48 || chan->width > 720 ||\r\nchan->height < 32 || chan->height > 576)\r\nreturn -EINVAL;\r\nbuf->vb.size = (chan->width * chan->height * chan->fmt->depth) >> 3;\r\nif (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size)\r\nreturn -EINVAL;\r\nif (buf->fmt != chan->fmt ||\r\nbuf->vb.width != chan->width ||\r\nbuf->vb.height != chan->height || buf->vb.field != field) {\r\nbuf->fmt = chan->fmt;\r\nbuf->vb.width = chan->width;\r\nbuf->vb.height = chan->height;\r\nbuf->vb.field = field;\r\ninit_buffer = 1;\r\n}\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\ninit_buffer = 1;\r\nrc = videobuf_iolock(q, &buf->vb, NULL);\r\nif (0 != rc) {\r\nprintk(KERN_DEBUG pr_fmt("videobuf_iolock failed!\n"));\r\ngoto fail;\r\n}\r\n}\r\ndprintk(1, "init_buffer=%d\n", init_buffer);\r\nif (init_buffer) {\r\nif (chan->pixel_formats == PIXEL_FRMT_411)\r\nbuf->bpl = (buf->fmt->depth * buf->vb.width) >> 3;\r\nelse\r\nbuf->bpl = (buf->fmt->depth >> 3) * (buf->vb.width);\r\nif (chan->pixel_formats == PIXEL_FRMT_411) {\r\nbpl_local = buf->bpl;\r\n} else {\r\nbpl_local = buf->bpl;\r\nif (chan->use_cif_resolution) {\r\nif (dev->tvnorm & V4L2_STD_625_50)\r\nbpl_local = 352 << 1;\r\nelse\r\nbpl_local = chan->cif_width << 1;\r\n}\r\n}\r\nswitch (buf->vb.field) {\r\ncase V4L2_FIELD_TOP:\r\ncx25821_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist, 0, UNSET,\r\nbuf->bpl, 0, buf->vb.height);\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\ncx25821_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist, UNSET, 0,\r\nbuf->bpl, 0, buf->vb.height);\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nline0_offset = 0;\r\ndprintk(1, "top field first\n");\r\ncx25821_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist, line0_offset,\r\nbpl_local, bpl_local, bpl_local,\r\nbuf->vb.height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\ncx25821_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist,\r\n0, buf->bpl * (buf->vb.height >> 1),\r\nbuf->bpl, 0, buf->vb.height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_BT:\r\ncx25821_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist,\r\nbuf->bpl * (buf->vb.height >> 1), 0,\r\nbuf->bpl, 0, buf->vb.height >> 1);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\ndprintk(2, "[%p/%d] buffer_prep - %dx%d %dbpp \"%s\" - dma=0x%08lx\n",\r\nbuf, buf->vb.i, chan->width, chan->height, chan->fmt->depth,\r\nchan->fmt->name, (unsigned long)buf->risc.dma);\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\ncx25821_free_buffer(q, buf);\r\nreturn rc;\r\n}\r\nstatic void cx25821_buffer_release(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct cx25821_buffer *buf =\r\ncontainer_of(vb, struct cx25821_buffer, vb);\r\ncx25821_free_buffer(q, buf);\r\n}\r\nstatic int cx25821_video_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nreturn videobuf_mmap_mapper(&chan->vidq, vma);\r\n}\r\nstatic void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct cx25821_buffer *buf =\r\ncontainer_of(vb, struct cx25821_buffer, vb);\r\nstruct cx25821_buffer *prev;\r\nstruct cx25821_channel *chan = vq->priv_data;\r\nstruct cx25821_dev *dev = chan->dev;\r\nstruct cx25821_dmaqueue *q = &dev->channels[chan->id].dma_vidq;\r\nbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);\r\nbuf->risc.jmp[1] = cpu_to_le32(q->stopper.dma);\r\nbuf->risc.jmp[2] = cpu_to_le32(0);\r\ndprintk(2, "jmp to stopper (0x%x)\n", buf->risc.jmp[1]);\r\nif (!list_empty(&q->queued)) {\r\nlist_add_tail(&buf->vb.queue, &q->queued);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\ndprintk(2, "[%p/%d] buffer_queue - append to queued\n", buf,\r\nbuf->vb.i);\r\n} else if (list_empty(&q->active)) {\r\nlist_add_tail(&buf->vb.queue, &q->active);\r\ncx25821_start_video_dma(dev, q, buf, chan->sram_channels);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nmod_timer(&q->timeout, jiffies + BUFFER_TIMEOUT);\r\ndprintk(2, "[%p/%d] buffer_queue - first active, buf cnt = %d, q->count = %d\n",\r\nbuf, buf->vb.i, buf->count, q->count);\r\n} else {\r\nprev = list_entry(q->active.prev, struct cx25821_buffer,\r\nvb.queue);\r\nif (prev->vb.width == buf->vb.width\r\n&& prev->vb.height == buf->vb.height\r\n&& prev->fmt == buf->fmt) {\r\nlist_add_tail(&buf->vb.queue, &q->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\nprev->risc.jmp[2] = cpu_to_le32(0);\r\ndprintk(2, "[%p/%d] buffer_queue - append to active, buf->count=%d\n",\r\nbuf, buf->vb.i, buf->count);\r\n} else {\r\nlist_add_tail(&buf->vb.queue, &q->queued);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\ndprintk(2, "[%p/%d] buffer_queue - first queued\n", buf,\r\nbuf->vb.i);\r\n}\r\n}\r\nif (list_empty(&q->active))\r\ndprintk(2, "active queue empty!\n");\r\n}\r\nstatic ssize_t video_read(struct file *file, char __user * data, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct v4l2_fh *fh = file->private_data;\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nstruct cx25821_dev *dev = chan->dev;\r\nint err = 0;\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nif (chan->streaming_fh && chan->streaming_fh != fh) {\r\nerr = -EBUSY;\r\ngoto unlock;\r\n}\r\nchan->streaming_fh = fh;\r\nerr = videobuf_read_one(&chan->vidq, data, count, ppos,\r\nfile->f_flags & O_NONBLOCK);\r\nunlock:\r\nmutex_unlock(&dev->lock);\r\nreturn err;\r\n}\r\nstatic unsigned int video_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nunsigned long req_events = poll_requested_events(wait);\r\nunsigned int res = v4l2_ctrl_poll(file, wait);\r\nif (req_events & (POLLIN | POLLRDNORM))\r\nres |= videobuf_poll_stream(file, &chan->vidq, wait);\r\nreturn res;\r\n}\r\nstatic int video_release(struct file *file)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nstruct v4l2_fh *fh = file->private_data;\r\nstruct cx25821_dev *dev = chan->dev;\r\nconst struct sram_channel *sram_ch =\r\ndev->channels[0].sram_channels;\r\nmutex_lock(&dev->lock);\r\ncx_write(sram_ch->dma_ctl, 0);\r\nif (chan->streaming_fh == fh) {\r\nvideobuf_queue_cancel(&chan->vidq);\r\nchan->streaming_fh = NULL;\r\n}\r\nif (chan->vidq.read_buf) {\r\ncx25821_buffer_release(&chan->vidq, chan->vidq.read_buf);\r\nkfree(chan->vidq.read_buf);\r\n}\r\nvideobuf_mmap_free(&chan->vidq);\r\nmutex_unlock(&dev->lock);\r\nreturn v4l2_fh_release(file);\r\n}\r\nstatic int cx25821_vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (unlikely(f->index >= ARRAY_SIZE(formats)))\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[f->index].name, sizeof(f->description));\r\nf->pixelformat = formats[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int cx25821_vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nf->fmt.pix.width = chan->width;\r\nf->fmt.pix.height = chan->height;\r\nf->fmt.pix.field = chan->vidq.field;\r\nf->fmt.pix.pixelformat = chan->fmt->fourcc;\r\nf->fmt.pix.bytesperline = (chan->width * chan->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage = chan->height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int cx25821_vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nstruct cx25821_dev *dev = chan->dev;\r\nconst struct cx25821_fmt *fmt;\r\nenum v4l2_field field = f->fmt.pix.field;\r\nunsigned int maxh;\r\nunsigned w;\r\nfmt = cx25821_format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nmaxh = (dev->tvnorm & V4L2_STD_625_50) ? 576 : 480;\r\nw = f->fmt.pix.width;\r\nif (field != V4L2_FIELD_BOTTOM)\r\nfield = V4L2_FIELD_TOP;\r\nif (w < 352) {\r\nw = 176;\r\nf->fmt.pix.height = maxh / 4;\r\n} else if (w < 720) {\r\nw = 352;\r\nf->fmt.pix.height = maxh / 2;\r\n} else {\r\nw = 720;\r\nf->fmt.pix.height = maxh;\r\nfield = V4L2_FIELD_INTERLACED;\r\n}\r\nf->fmt.pix.field = field;\r\nf->fmt.pix.width = w;\r\nf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nstruct cx25821_dev *dev = chan->dev;\r\nint pix_format = PIXEL_FRMT_422;\r\nint err;\r\nerr = cx25821_vidioc_try_fmt_vid_cap(file, priv, f);\r\nif (0 != err)\r\nreturn err;\r\nchan->fmt = cx25821_format_by_fourcc(f->fmt.pix.pixelformat);\r\nchan->vidq.field = f->fmt.pix.field;\r\nchan->width = f->fmt.pix.width;\r\nchan->height = f->fmt.pix.height;\r\nif (f->fmt.pix.pixelformat == V4L2_PIX_FMT_Y41P)\r\npix_format = PIXEL_FRMT_411;\r\nelse\r\npix_format = PIXEL_FRMT_422;\r\ncx25821_set_pixel_format(dev, SRAM_CH00, pix_format);\r\nif (chan->width == 320 || chan->width == 352)\r\nchan->use_cif_resolution = 1;\r\nelse\r\nchan->use_cif_resolution = 0;\r\nchan->cif_width = chan->width;\r\nmedusa_set_resolution(dev, chan->width, SRAM_CH00);\r\nreturn 0;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nif (i != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (chan->streaming_fh && chan->streaming_fh != priv)\r\nreturn -EBUSY;\r\nchan->streaming_fh = priv;\r\nreturn videobuf_streamon(&chan->vidq);\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nif (i != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (chan->streaming_fh && chan->streaming_fh != priv)\r\nreturn -EBUSY;\r\nif (chan->streaming_fh == NULL)\r\nreturn 0;\r\nchan->streaming_fh = NULL;\r\nreturn videobuf_streamoff(&chan->vidq);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nint ret_val = 0;\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nret_val = videobuf_dqbuf(&chan->vidq, p, file->f_flags & O_NONBLOCK);\r\np->sequence = chan->dma_vidq.count;\r\nreturn ret_val;\r\n}\r\nstatic int vidioc_log_status(struct file *file, void *priv)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nstruct cx25821_dev *dev = chan->dev;\r\nconst struct sram_channel *sram_ch = chan->sram_channels;\r\nu32 tmp = 0;\r\ntmp = cx_read(sram_ch->dma_ctl);\r\npr_info("Video input 0 is %s\n",\r\n(tmp & 0x11) ? "streaming" : "stopped");\r\nreturn 0;\r\n}\r\nstatic int cx25821_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nstruct cx25821_dev *dev = chan->dev;\r\nconst u32 cap_input = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\r\nconst u32 cap_output = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_READWRITE;\r\nstrcpy(cap->driver, "cx25821");\r\nstrlcpy(cap->card, cx25821_boards[dev->board].name, sizeof(cap->card));\r\nsprintf(cap->bus_info, "PCIe:%s", pci_name(dev->pci));\r\nif (chan->id >= VID_CHANNEL_NUM)\r\ncap->device_caps = cap_output;\r\nelse\r\ncap->device_caps = cap_input;\r\ncap->capabilities = cap_input | cap_output | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int cx25821_vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nreturn videobuf_reqbufs(&chan->vidq, p);\r\n}\r\nstatic int cx25821_vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nreturn videobuf_querybuf(&chan->vidq, p);\r\n}\r\nstatic int cx25821_vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nreturn videobuf_qbuf(&chan->vidq, p);\r\n}\r\nstatic int cx25821_vidioc_g_std(struct file *file, void *priv, v4l2_std_id *tvnorms)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\n*tvnorms = chan->dev->tvnorm;\r\nreturn 0;\r\n}\r\nstatic int cx25821_vidioc_s_std(struct file *file, void *priv,\r\nv4l2_std_id tvnorms)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nstruct cx25821_dev *dev = chan->dev;\r\nif (dev->tvnorm == tvnorms)\r\nreturn 0;\r\ndev->tvnorm = tvnorms;\r\nchan->width = 720;\r\nchan->height = (dev->tvnorm & V4L2_STD_625_50) ? 576 : 480;\r\nmedusa_set_videostandard(dev);\r\nreturn 0;\r\n}\r\nstatic int cx25821_vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nif (i->index)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\ni->std = CX25821_NORMS;\r\nstrcpy(i->name, "Composite");\r\nreturn 0;\r\n}\r\nstatic int cx25821_vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int cx25821_vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nreturn i ? -EINVAL : 0;\r\n}\r\nstatic int cx25821_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct cx25821_channel *chan =\r\ncontainer_of(ctrl->handler, struct cx25821_channel, hdl);\r\nstruct cx25821_dev *dev = chan->dev;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nmedusa_set_brightness(dev, ctrl->val, chan->id);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nmedusa_set_hue(dev, ctrl->val, chan->id);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nmedusa_set_contrast(dev, ctrl->val, chan->id);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nmedusa_set_saturation(dev, ctrl->val, chan->id);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx25821_vidioc_enum_output(struct file *file, void *priv,\r\nstruct v4l2_output *o)\r\n{\r\nif (o->index)\r\nreturn -EINVAL;\r\no->type = V4L2_INPUT_TYPE_CAMERA;\r\no->std = CX25821_NORMS;\r\nstrcpy(o->name, "Composite");\r\nreturn 0;\r\n}\r\nstatic int cx25821_vidioc_g_output(struct file *file, void *priv, unsigned int *o)\r\n{\r\n*o = 0;\r\nreturn 0;\r\n}\r\nstatic int cx25821_vidioc_s_output(struct file *file, void *priv, unsigned int o)\r\n{\r\nreturn o ? -EINVAL : 0;\r\n}\r\nstatic int cx25821_vidioc_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nstruct cx25821_dev *dev = chan->dev;\r\nconst struct cx25821_fmt *fmt;\r\nfmt = cx25821_format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nf->fmt.pix.width = 720;\r\nf->fmt.pix.height = (dev->tvnorm & V4L2_STD_625_50) ? 576 : 480;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nint err;\r\nerr = cx25821_vidioc_try_fmt_vid_out(file, priv, f);\r\nif (0 != err)\r\nreturn err;\r\nchan->fmt = cx25821_format_by_fourcc(f->fmt.pix.pixelformat);\r\nchan->vidq.field = f->fmt.pix.field;\r\nchan->width = f->fmt.pix.width;\r\nchan->height = f->fmt.pix.height;\r\nif (f->fmt.pix.pixelformat == V4L2_PIX_FMT_Y41P)\r\nchan->pixel_formats = PIXEL_FRMT_411;\r\nelse\r\nchan->pixel_formats = PIXEL_FRMT_422;\r\nreturn 0;\r\n}\r\nstatic ssize_t video_write(struct file *file, const char __user *data, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nstruct cx25821_dev *dev = chan->dev;\r\nstruct v4l2_fh *fh = file->private_data;\r\nint err = 0;\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nif (chan->streaming_fh && chan->streaming_fh != fh) {\r\nerr = -EBUSY;\r\ngoto unlock;\r\n}\r\nif (!chan->streaming_fh) {\r\nerr = cx25821_vidupstream_init(chan, chan->pixel_formats);\r\nif (err)\r\ngoto unlock;\r\nchan->streaming_fh = fh;\r\n}\r\nerr = cx25821_write_frame(chan, data, count);\r\ncount -= err;\r\n*ppos += err;\r\nunlock:\r\nmutex_unlock(&dev->lock);\r\nreturn err;\r\n}\r\nstatic int video_out_release(struct file *file)\r\n{\r\nstruct cx25821_channel *chan = video_drvdata(file);\r\nstruct cx25821_dev *dev = chan->dev;\r\nstruct v4l2_fh *fh = file->private_data;\r\nmutex_lock(&dev->lock);\r\nif (chan->streaming_fh == fh) {\r\ncx25821_stop_upstream_video(chan);\r\nchan->streaming_fh = NULL;\r\n}\r\nmutex_unlock(&dev->lock);\r\nreturn v4l2_fh_release(file);\r\n}\r\nvoid cx25821_video_unregister(struct cx25821_dev *dev, int chan_num)\r\n{\r\ncx_clear(PCI_INT_MSK, 1);\r\nif (video_is_registered(&dev->channels[chan_num].vdev)) {\r\nvideo_unregister_device(&dev->channels[chan_num].vdev);\r\nv4l2_ctrl_handler_free(&dev->channels[chan_num].hdl);\r\nbtcx_riscmem_free(dev->pci,\r\n&dev->channels[chan_num].dma_vidq.stopper);\r\n}\r\n}\r\nint cx25821_video_register(struct cx25821_dev *dev)\r\n{\r\nint err;\r\nint i;\r\ndev->tvnorm = V4L2_STD_NTSC_M;\r\nspin_lock_init(&dev->slock);\r\nfor (i = 0; i < MAX_VID_CHANNEL_NUM - 1; ++i) {\r\nstruct cx25821_channel *chan = &dev->channels[i];\r\nstruct video_device *vdev = &chan->vdev;\r\nstruct v4l2_ctrl_handler *hdl = &chan->hdl;\r\nbool is_output = i > SRAM_CH08;\r\nif (i == SRAM_CH08)\r\ncontinue;\r\nif (!is_output) {\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nv4l2_ctrl_new_std(hdl, &cx25821_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 10000, 1, 6200);\r\nv4l2_ctrl_new_std(hdl, &cx25821_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 10000, 1, 5000);\r\nv4l2_ctrl_new_std(hdl, &cx25821_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 10000, 1, 5000);\r\nv4l2_ctrl_new_std(hdl, &cx25821_ctrl_ops,\r\nV4L2_CID_HUE, 0, 10000, 1, 5000);\r\nif (hdl->error) {\r\nerr = hdl->error;\r\ngoto fail_unreg;\r\n}\r\nerr = v4l2_ctrl_handler_setup(hdl);\r\nif (err)\r\ngoto fail_unreg;\r\n} else {\r\nchan->out = &dev->vid_out_data[i - SRAM_CH09];\r\nchan->out->chan = chan;\r\n}\r\ncx25821_risc_stopper(dev->pci, &chan->dma_vidq.stopper,\r\nchan->sram_channels->dma_ctl, 0x11, 0);\r\nchan->sram_channels = &cx25821_sram_channels[i];\r\nchan->width = 720;\r\nif (dev->tvnorm & V4L2_STD_625_50)\r\nchan->height = 576;\r\nelse\r\nchan->height = 480;\r\nif (chan->pixel_formats == PIXEL_FRMT_411)\r\nchan->fmt = cx25821_format_by_fourcc(V4L2_PIX_FMT_Y41P);\r\nelse\r\nchan->fmt = cx25821_format_by_fourcc(V4L2_PIX_FMT_YUYV);\r\ncx_write(chan->sram_channels->int_stat, 0xffffffff);\r\nINIT_LIST_HEAD(&chan->dma_vidq.active);\r\nINIT_LIST_HEAD(&chan->dma_vidq.queued);\r\nchan->timeout_data.dev = dev;\r\nchan->timeout_data.channel = &cx25821_sram_channels[i];\r\nchan->dma_vidq.timeout.function = cx25821_vid_timeout;\r\nchan->dma_vidq.timeout.data = (unsigned long)&chan->timeout_data;\r\ninit_timer(&chan->dma_vidq.timeout);\r\nif (!is_output)\r\nvideobuf_queue_sg_init(&chan->vidq, &cx25821_video_qops, &dev->pci->dev,\r\n&dev->slock, V4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED, sizeof(struct cx25821_buffer),\r\nchan, &dev->lock);\r\n*vdev = is_output ? cx25821_video_out_device : cx25821_video_device;\r\nvdev->v4l2_dev = &dev->v4l2_dev;\r\nif (!is_output)\r\nvdev->ctrl_handler = hdl;\r\nelse\r\nvdev->vfl_dir = VFL_DIR_TX;\r\nvdev->lock = &dev->lock;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &vdev->flags);\r\nsnprintf(vdev->name, sizeof(vdev->name), "%s #%d", dev->name, i);\r\nvideo_set_drvdata(vdev, chan);\r\nerr = video_register_device(vdev, VFL_TYPE_GRABBER,\r\nvideo_nr[dev->nr]);\r\nif (err < 0)\r\ngoto fail_unreg;\r\n}\r\ncx_set(PCI_INT_MSK, 0xff);\r\nreturn 0;\r\nfail_unreg:\r\nwhile (i >= 0)\r\ncx25821_video_unregister(dev, i--);\r\nreturn err;\r\n}
