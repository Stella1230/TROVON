static struct switch_ctx *alloc_switch_ctx(struct dm_target *ti, unsigned nr_paths,\r\nunsigned region_size)\r\n{\r\nstruct switch_ctx *sctx;\r\nsctx = kzalloc(sizeof(struct switch_ctx) + nr_paths * sizeof(struct switch_path),\r\nGFP_KERNEL);\r\nif (!sctx)\r\nreturn NULL;\r\nsctx->ti = ti;\r\nsctx->region_size = region_size;\r\nti->private = sctx;\r\nreturn sctx;\r\n}\r\nstatic int alloc_region_table(struct dm_target *ti, unsigned nr_paths)\r\n{\r\nstruct switch_ctx *sctx = ti->private;\r\nsector_t nr_regions = ti->len;\r\nsector_t nr_slots;\r\nif (!(sctx->region_size & (sctx->region_size - 1)))\r\nsctx->region_size_bits = __ffs(sctx->region_size);\r\nelse\r\nsctx->region_size_bits = -1;\r\nsctx->region_table_entry_bits = 1;\r\nwhile (sctx->region_table_entry_bits < sizeof(region_table_slot_t) * 8 &&\r\n(region_table_slot_t)1 << sctx->region_table_entry_bits < nr_paths)\r\nsctx->region_table_entry_bits++;\r\nsctx->region_entries_per_slot = (sizeof(region_table_slot_t) * 8) / sctx->region_table_entry_bits;\r\nif (!(sctx->region_entries_per_slot & (sctx->region_entries_per_slot - 1)))\r\nsctx->region_entries_per_slot_bits = __ffs(sctx->region_entries_per_slot);\r\nelse\r\nsctx->region_entries_per_slot_bits = -1;\r\nif (sector_div(nr_regions, sctx->region_size))\r\nnr_regions++;\r\nsctx->nr_regions = nr_regions;\r\nif (sctx->nr_regions != nr_regions || sctx->nr_regions >= ULONG_MAX) {\r\nti->error = "Region table too large";\r\nreturn -EINVAL;\r\n}\r\nnr_slots = nr_regions;\r\nif (sector_div(nr_slots, sctx->region_entries_per_slot))\r\nnr_slots++;\r\nif (nr_slots > ULONG_MAX / sizeof(region_table_slot_t)) {\r\nti->error = "Region table too large";\r\nreturn -EINVAL;\r\n}\r\nsctx->region_table = vmalloc(nr_slots * sizeof(region_table_slot_t));\r\nif (!sctx->region_table) {\r\nti->error = "Cannot allocate region table";\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void switch_get_position(struct switch_ctx *sctx, unsigned long region_nr,\r\nunsigned long *region_index, unsigned *bit)\r\n{\r\nif (sctx->region_entries_per_slot_bits >= 0) {\r\n*region_index = region_nr >> sctx->region_entries_per_slot_bits;\r\n*bit = region_nr & (sctx->region_entries_per_slot - 1);\r\n} else {\r\n*region_index = region_nr / sctx->region_entries_per_slot;\r\n*bit = region_nr % sctx->region_entries_per_slot;\r\n}\r\n*bit *= sctx->region_table_entry_bits;\r\n}\r\nstatic unsigned switch_get_path_nr(struct switch_ctx *sctx, sector_t offset)\r\n{\r\nunsigned long region_index;\r\nunsigned bit, path_nr;\r\nsector_t p;\r\np = offset;\r\nif (sctx->region_size_bits >= 0)\r\np >>= sctx->region_size_bits;\r\nelse\r\nsector_div(p, sctx->region_size);\r\nswitch_get_position(sctx, p, &region_index, &bit);\r\npath_nr = (ACCESS_ONCE(sctx->region_table[region_index]) >> bit) &\r\n((1 << sctx->region_table_entry_bits) - 1);\r\nif (unlikely(path_nr >= sctx->nr_paths))\r\npath_nr = 0;\r\nreturn path_nr;\r\n}\r\nstatic void switch_region_table_write(struct switch_ctx *sctx, unsigned long region_nr,\r\nunsigned value)\r\n{\r\nunsigned long region_index;\r\nunsigned bit;\r\nregion_table_slot_t pte;\r\nswitch_get_position(sctx, region_nr, &region_index, &bit);\r\npte = sctx->region_table[region_index];\r\npte &= ~((((region_table_slot_t)1 << sctx->region_table_entry_bits) - 1) << bit);\r\npte |= (region_table_slot_t)value << bit;\r\nsctx->region_table[region_index] = pte;\r\n}\r\nstatic void initialise_region_table(struct switch_ctx *sctx)\r\n{\r\nunsigned path_nr = 0;\r\nunsigned long region_nr;\r\nfor (region_nr = 0; region_nr < sctx->nr_regions; region_nr++) {\r\nswitch_region_table_write(sctx, region_nr, path_nr);\r\nif (++path_nr >= sctx->nr_paths)\r\npath_nr = 0;\r\n}\r\n}\r\nstatic int parse_path(struct dm_arg_set *as, struct dm_target *ti)\r\n{\r\nstruct switch_ctx *sctx = ti->private;\r\nunsigned long long start;\r\nint r;\r\nr = dm_get_device(ti, dm_shift_arg(as), dm_table_get_mode(ti->table),\r\n&sctx->path_list[sctx->nr_paths].dmdev);\r\nif (r) {\r\nti->error = "Device lookup failed";\r\nreturn r;\r\n}\r\nif (kstrtoull(dm_shift_arg(as), 10, &start) || start != (sector_t)start) {\r\nti->error = "Invalid device starting offset";\r\ndm_put_device(ti, sctx->path_list[sctx->nr_paths].dmdev);\r\nreturn -EINVAL;\r\n}\r\nsctx->path_list[sctx->nr_paths].start = start;\r\nsctx->nr_paths++;\r\nreturn 0;\r\n}\r\nstatic void switch_dtr(struct dm_target *ti)\r\n{\r\nstruct switch_ctx *sctx = ti->private;\r\nwhile (sctx->nr_paths--)\r\ndm_put_device(ti, sctx->path_list[sctx->nr_paths].dmdev);\r\nvfree(sctx->region_table);\r\nkfree(sctx);\r\n}\r\nstatic int switch_ctr(struct dm_target *ti, unsigned argc, char **argv)\r\n{\r\nstatic struct dm_arg _args[] = {\r\n{1, (KMALLOC_MAX_SIZE - sizeof(struct switch_ctx)) / sizeof(struct switch_path), "Invalid number of paths"},\r\n{1, UINT_MAX, "Invalid region size"},\r\n{0, 0, "Invalid number of optional args"},\r\n};\r\nstruct switch_ctx *sctx;\r\nstruct dm_arg_set as;\r\nunsigned nr_paths, region_size, nr_optional_args;\r\nint r;\r\nas.argc = argc;\r\nas.argv = argv;\r\nr = dm_read_arg(_args, &as, &nr_paths, &ti->error);\r\nif (r)\r\nreturn -EINVAL;\r\nr = dm_read_arg(_args + 1, &as, &region_size, &ti->error);\r\nif (r)\r\nreturn r;\r\nr = dm_read_arg_group(_args + 2, &as, &nr_optional_args, &ti->error);\r\nif (r)\r\nreturn r;\r\nif (as.argc != nr_paths * 2) {\r\nti->error = "Incorrect number of path arguments";\r\nreturn -EINVAL;\r\n}\r\nsctx = alloc_switch_ctx(ti, nr_paths, region_size);\r\nif (!sctx) {\r\nti->error = "Cannot allocate redirection context";\r\nreturn -ENOMEM;\r\n}\r\nr = dm_set_target_max_io_len(ti, region_size);\r\nif (r)\r\ngoto error;\r\nwhile (as.argc) {\r\nr = parse_path(&as, ti);\r\nif (r)\r\ngoto error;\r\n}\r\nr = alloc_region_table(ti, nr_paths);\r\nif (r)\r\ngoto error;\r\ninitialise_region_table(sctx);\r\nti->num_discard_bios = 1;\r\nreturn 0;\r\nerror:\r\nswitch_dtr(ti);\r\nreturn r;\r\n}\r\nstatic int switch_map(struct dm_target *ti, struct bio *bio)\r\n{\r\nstruct switch_ctx *sctx = ti->private;\r\nsector_t offset = dm_target_offset(ti, bio->bi_iter.bi_sector);\r\nunsigned path_nr = switch_get_path_nr(sctx, offset);\r\nbio->bi_bdev = sctx->path_list[path_nr].dmdev->bdev;\r\nbio->bi_iter.bi_sector = sctx->path_list[path_nr].start + offset;\r\nreturn DM_MAPIO_REMAPPED;\r\n}\r\nstatic __always_inline unsigned long parse_hex(const char **string)\r\n{\r\nunsigned char d;\r\nunsigned long r = 0;\r\nwhile ((d = hex_table[(unsigned char)**string]) < 16) {\r\nr = (r << 4) | d;\r\n(*string)++;\r\n}\r\nreturn r;\r\n}\r\nstatic int process_set_region_mappings(struct switch_ctx *sctx,\r\nunsigned argc, char **argv)\r\n{\r\nunsigned i;\r\nunsigned long region_index = 0;\r\nfor (i = 1; i < argc; i++) {\r\nunsigned long path_nr;\r\nconst char *string = argv[i];\r\nif (*string == ':')\r\nregion_index++;\r\nelse {\r\nregion_index = parse_hex(&string);\r\nif (unlikely(*string != ':')) {\r\nDMWARN("invalid set_region_mappings argument: '%s'", argv[i]);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstring++;\r\nif (unlikely(!*string)) {\r\nDMWARN("invalid set_region_mappings argument: '%s'", argv[i]);\r\nreturn -EINVAL;\r\n}\r\npath_nr = parse_hex(&string);\r\nif (unlikely(*string)) {\r\nDMWARN("invalid set_region_mappings argument: '%s'", argv[i]);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(region_index >= sctx->nr_regions)) {\r\nDMWARN("invalid set_region_mappings region number: %lu >= %lu", region_index, sctx->nr_regions);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(path_nr >= sctx->nr_paths)) {\r\nDMWARN("invalid set_region_mappings device: %lu >= %u", path_nr, sctx->nr_paths);\r\nreturn -EINVAL;\r\n}\r\nswitch_region_table_write(sctx, region_index, path_nr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int switch_message(struct dm_target *ti, unsigned argc, char **argv)\r\n{\r\nstatic DEFINE_MUTEX(message_mutex);\r\nstruct switch_ctx *sctx = ti->private;\r\nint r = -EINVAL;\r\nmutex_lock(&message_mutex);\r\nif (!strcasecmp(argv[0], "set_region_mappings"))\r\nr = process_set_region_mappings(sctx, argc, argv);\r\nelse\r\nDMWARN("Unrecognised message received.");\r\nmutex_unlock(&message_mutex);\r\nreturn r;\r\n}\r\nstatic void switch_status(struct dm_target *ti, status_type_t type,\r\nunsigned status_flags, char *result, unsigned maxlen)\r\n{\r\nstruct switch_ctx *sctx = ti->private;\r\nunsigned sz = 0;\r\nint path_nr;\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nresult[0] = '\0';\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT("%u %u 0", sctx->nr_paths, sctx->region_size);\r\nfor (path_nr = 0; path_nr < sctx->nr_paths; path_nr++)\r\nDMEMIT(" %s %llu", sctx->path_list[path_nr].dmdev->name,\r\n(unsigned long long)sctx->path_list[path_nr].start);\r\nbreak;\r\n}\r\n}\r\nstatic int switch_ioctl(struct dm_target *ti, unsigned cmd,\r\nunsigned long arg)\r\n{\r\nstruct switch_ctx *sctx = ti->private;\r\nstruct block_device *bdev;\r\nfmode_t mode;\r\nunsigned path_nr;\r\nint r = 0;\r\npath_nr = switch_get_path_nr(sctx, 0);\r\nbdev = sctx->path_list[path_nr].dmdev->bdev;\r\nmode = sctx->path_list[path_nr].dmdev->mode;\r\nif (ti->len + sctx->path_list[path_nr].start != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)\r\nr = scsi_verify_blk_ioctl(NULL, cmd);\r\nreturn r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);\r\n}\r\nstatic int switch_iterate_devices(struct dm_target *ti,\r\niterate_devices_callout_fn fn, void *data)\r\n{\r\nstruct switch_ctx *sctx = ti->private;\r\nint path_nr;\r\nint r;\r\nfor (path_nr = 0; path_nr < sctx->nr_paths; path_nr++) {\r\nr = fn(ti, sctx->path_list[path_nr].dmdev,\r\nsctx->path_list[path_nr].start, ti->len, data);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init dm_switch_init(void)\r\n{\r\nint r;\r\nr = dm_register_target(&switch_target);\r\nif (r < 0)\r\nDMERR("dm_register_target() failed %d", r);\r\nreturn r;\r\n}\r\nstatic void __exit dm_switch_exit(void)\r\n{\r\ndm_unregister_target(&switch_target);\r\n}
