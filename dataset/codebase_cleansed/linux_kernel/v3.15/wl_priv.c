int wvlan_uil(struct uilreq *urq, struct wl_private *lp)\r\n{\r\nint ioctl_ret = 0;\r\nswitch (urq->command) {\r\ncase UIL_FUN_CONNECT:\r\nDBG_TRACE(DbgInfo, "IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_CONNECT\n");\r\nioctl_ret = wvlan_uil_connect(urq, lp);\r\nbreak;\r\ncase UIL_FUN_DISCONNECT:\r\nDBG_TRACE(DbgInfo, "IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_DISCONNECT\n");\r\nioctl_ret = wvlan_uil_disconnect(urq, lp);\r\nbreak;\r\ncase UIL_FUN_ACTION:\r\nDBG_TRACE(DbgInfo, "IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_ACTION\n");\r\nioctl_ret = wvlan_uil_action(urq, lp);\r\nbreak;\r\ncase UIL_FUN_SEND_DIAG_MSG:\r\nDBG_TRACE(DbgInfo, "IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_SEND_DIAG_MSG\n");\r\nioctl_ret = wvlan_uil_send_diag_msg(urq, lp);\r\nbreak;\r\ncase UIL_FUN_GET_INFO:\r\nDBG_TRACE(DbgInfo, "IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_GET_INFO\n");\r\nioctl_ret = wvlan_uil_get_info(urq, lp);\r\nbreak;\r\ncase UIL_FUN_PUT_INFO:\r\nDBG_TRACE(DbgInfo, "IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_PUT_INFO\n");\r\nioctl_ret = wvlan_uil_put_info(urq, lp);\r\nbreak;\r\ndefault:\r\nDBG_TRACE(DbgInfo, "IOCTL: WVLAN2_IOCTL_UIL -- UNSUPPORTED UIL CODE: 0x%X", urq->command);\r\nioctl_ret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ioctl_ret;\r\n}\r\nint wvlan_uil_connect(struct uilreq *urq, struct wl_private *lp)\r\n{\r\nint result = 0;\r\nif (!(lp->flags & WVLAN2_UIL_CONNECTED)) {\r\nlp->flags |= WVLAN2_UIL_CONNECTED;\r\nurq->hcfCtx = &(lp->hcfCtx);\r\nurq->result = UIL_SUCCESS;\r\n} else {\r\nDBG_WARNING(DbgInfo, "UIL_ERR_IN_USE\n");\r\nurq->result = UIL_ERR_IN_USE;\r\n}\r\nreturn result;\r\n}\r\nint wvlan_uil_disconnect(struct uilreq *urq, struct wl_private *lp)\r\n{\r\nint result = 0;\r\nif (urq->hcfCtx == &(lp->hcfCtx)) {\r\nif (lp->flags & WVLAN2_UIL_CONNECTED) {\r\nlp->flags &= ~WVLAN2_UIL_CONNECTED;\r\n}\r\nurq->hcfCtx = NULL;\r\nurq->result = UIL_SUCCESS;\r\n} else {\r\nDBG_ERROR(DbgInfo, "UIL_ERR_WRONG_IFB\n");\r\nurq->result = UIL_ERR_WRONG_IFB;\r\n}\r\nreturn result;\r\n}\r\nint wvlan_uil_action(struct uilreq *urq, struct wl_private *lp)\r\n{\r\nint result = 0;\r\nltv_t *ltv;\r\nif (urq->hcfCtx == &(lp->hcfCtx)) {\r\nltv = (ltv_t *)urq->data;\r\nif (ltv != NULL) {\r\nswitch (ltv->typ) {\r\ncase UIL_ACT_BLOCK:\r\nDBG_TRACE(DbgInfo, "UIL_ACT_BLOCK\n");\r\nresult = wvlan_uil_block(urq, lp);\r\nbreak;\r\ncase UIL_ACT_UNBLOCK:\r\nDBG_TRACE(DbgInfo, "UIL_ACT_UNBLOCK\n");\r\nresult = wvlan_uil_unblock(urq, lp);\r\nbreak;\r\ncase UIL_ACT_SCAN:\r\nDBG_TRACE(DbgInfo, "UIL_ACT_SCAN\n");\r\nurq->result = hcf_action(&(lp->hcfCtx), MDD_ACT_SCAN);\r\nbreak;\r\ncase UIL_ACT_APPLY:\r\nDBG_TRACE(DbgInfo, "UIL_ACT_APPLY\n");\r\nurq->result = wl_apply(lp);\r\nbreak;\r\ncase UIL_ACT_RESET:\r\nDBG_TRACE(DbgInfo, "UIL_ACT_RESET\n");\r\nurq->result = wl_go(lp);\r\nbreak;\r\ndefault:\r\nDBG_WARNING(DbgInfo, "Unknown action code: 0x%x\n", ltv->typ);\r\nbreak;\r\n}\r\n} else {\r\nDBG_ERROR(DbgInfo, "Bad LTV for this action\n");\r\nurq->result = UIL_ERR_LEN;\r\n}\r\n} else {\r\nDBG_ERROR(DbgInfo, "UIL_ERR_WRONG_IFB\n");\r\nurq->result = UIL_ERR_WRONG_IFB;\r\n}\r\nreturn result;\r\n}\r\nint wvlan_uil_block(struct uilreq *urq, struct wl_private *lp)\r\n{\r\nint result = 0;\r\nif (urq->hcfCtx == &(lp->hcfCtx)) {\r\nif (capable(CAP_NET_ADMIN)) {\r\nlp->flags |= WVLAN2_UIL_BUSY;\r\nnetif_stop_queue(lp->dev);\r\nWL_WDS_NETIF_STOP_QUEUE(lp);\r\nurq->result = UIL_SUCCESS;\r\n} else {\r\nDBG_ERROR(DbgInfo, "EPERM\n");\r\nurq->result = UIL_FAILURE;\r\nresult = -EPERM;\r\n}\r\n} else {\r\nDBG_ERROR(DbgInfo, "UIL_ERR_WRONG_IFB\n");\r\nurq->result = UIL_ERR_WRONG_IFB;\r\n}\r\nreturn result;\r\n}\r\nint wvlan_uil_unblock(struct uilreq *urq, struct wl_private *lp)\r\n{\r\nint result = 0;\r\nif (urq->hcfCtx == &(lp->hcfCtx)) {\r\nif (capable(CAP_NET_ADMIN)) {\r\nif (lp->flags & WVLAN2_UIL_BUSY) {\r\nlp->flags &= ~WVLAN2_UIL_BUSY;\r\nnetif_wake_queue(lp->dev);\r\nWL_WDS_NETIF_WAKE_QUEUE(lp);\r\n}\r\n} else {\r\nDBG_ERROR(DbgInfo, "EPERM\n");\r\nurq->result = UIL_FAILURE;\r\nresult = -EPERM;\r\n}\r\n} else {\r\nDBG_ERROR(DbgInfo, "UIL_ERR_WRONG_IFB\n");\r\nurq->result = UIL_ERR_WRONG_IFB;\r\n}\r\nreturn result;\r\n}\r\nint wvlan_uil_send_diag_msg(struct uilreq *urq, struct wl_private *lp)\r\n{\r\nint result = 0;\r\nDESC_STRCT Descp[1];\r\nif (urq->hcfCtx == &(lp->hcfCtx)) {\r\nif (capable(CAP_NET_ADMIN)) {\r\nif ((urq->data != NULL) && (urq->len != 0)) {\r\nif (lp->hcfCtx.IFB_RscInd != 0) {\r\nu_char *data;\r\nresult = verify_area(VERIFY_READ, urq->data, urq->len);\r\nif (result != 0) {\r\nDBG_ERROR(DbgInfo, "verify_area failed, result: %d\n", result);\r\nurq->result = UIL_FAILURE;\r\nreturn result;\r\n}\r\ndata = kmalloc(urq->len, GFP_KERNEL);\r\nif (data != NULL) {\r\nmemset(Descp, 0, sizeof(DESC_STRCT));\r\nmemcpy(data, urq->data, urq->len);\r\nDescp[0].buf_addr = (wci_bufp)data;\r\nDescp[0].BUF_CNT = urq->len;\r\nDescp[0].next_desc_addr = 0;\r\nhcf_send_msg(&(lp->hcfCtx), &Descp[0], HCF_PORT_0);\r\nkfree(data);\r\n} else {\r\nDBG_ERROR(DbgInfo, "ENOMEM\n");\r\nurq->result = UIL_FAILURE;\r\nresult = -ENOMEM;\r\nreturn result;\r\n}\r\n} else {\r\nurq->result = UIL_ERR_BUSY;\r\n}\r\n} else {\r\nurq->result = UIL_FAILURE;\r\n}\r\n} else {\r\nDBG_ERROR(DbgInfo, "EPERM\n");\r\nurq->result = UIL_FAILURE;\r\nresult = -EPERM;\r\n}\r\n} else {\r\nDBG_ERROR(DbgInfo, "UIL_ERR_WRONG_IFB\n");\r\nurq->result = UIL_ERR_WRONG_IFB;\r\n}\r\nreturn result;\r\n}\r\nint wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\r\n{\r\nint result = 0;\r\nltv_t *pLtv;\r\nbool_t ltvAllocated = FALSE;\r\nENCSTRCT sEncryption;\r\nsize_t len;\r\n#ifdef USE_WDS\r\nhcf_16 hcfPort = HCF_PORT_0;\r\n#endif\r\nif (urq->hcfCtx == &(lp->hcfCtx)) {\r\nif (capable(CAP_NET_ADMIN)) {\r\nif ((urq->data != NULL) && (urq->len != 0)) {\r\nif (urq->len < (sizeof(hcf_16) * 2)) {\r\nurq->len = sizeof(lp->ltvRecord);\r\nurq->result = UIL_ERR_LEN;\r\nDBG_ERROR(DbgInfo, "No Length/Type in LTV!!!\n");\r\nDBG_ERROR(DbgInfo, "UIL_ERR_LEN\n");\r\nreturn result;\r\n}\r\nresult = verify_area(VERIFY_READ, urq->data, urq->len);\r\nif (result != 0) {\r\nurq->result = UIL_FAILURE;\r\nDBG_ERROR(DbgInfo, "verify_area(), VERIFY_READ FAILED\n");\r\nreturn result;\r\n}\r\ncopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\r\nif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\r\nurq->len = sizeof(lp->ltvRecord);\r\nurq->result = UIL_ERR_LEN;\r\nDBG_ERROR(DbgInfo, "UIL_ERR_LEN\n");\r\nreturn result;\r\n}\r\nif (urq->len > sizeof(lp->ltvRecord)) {\r\npLtv = kmalloc(urq->len, GFP_KERNEL);\r\nif (pLtv != NULL) {\r\nltvAllocated = TRUE;\r\n} else {\r\nDBG_ERROR(DbgInfo, "Alloc FAILED\n");\r\nurq->len = sizeof(lp->ltvRecord);\r\nurq->result = UIL_ERR_LEN;\r\nresult = -ENOMEM;\r\nreturn result;\r\n}\r\n} else {\r\npLtv = &(lp->ltvRecord);\r\n}\r\ncopy_from_user(pLtv, urq->data, urq->len);\r\nswitch (pLtv->typ) {\r\ncase CFG_CNF_PORT_TYPE:\r\nlp->PortType = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_CNF_OWN_MAC_ADDR:\r\nbreak;\r\ncase CFG_CNF_OWN_CHANNEL:\r\nlp->Channel = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_CNF_OWN_ATIM_WINDOW:\r\nlp->atimWindow = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_CNF_SYSTEM_SCALE:\r\nlp->DistanceBetweenAPs = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\ncase CFG_CNF_MAX_DATA_LEN:\r\nbreak;\r\ncase CFG_CNF_PM_ENABLED:\r\nlp->PMEnabled = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_CNF_MCAST_RX:\r\nlp->MulticastReceive = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_CNF_MAX_SLEEP_DURATION:\r\nlp->MaxSleepDuration = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_CNF_HOLDOVER_DURATION:\r\nlp->holdoverDuration = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_CNF_OWN_NAME:\r\nmemset(lp->StationName, 0, sizeof(lp->StationName));\r\nlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\r\nstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_CNF_LOAD_BALANCING:\r\nlp->loadBalancing = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_CNF_MEDIUM_DISTRIBUTION:\r\nlp->mediumDistribution = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\n#ifdef WARP\r\ncase CFG_CNF_TX_POW_LVL:\r\nlp->txPowLevel = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_SUPPORTED_RATE_SET_CNTL:\r\nlp->srsc[0] = pLtv->u.u16[0];\r\nlp->srsc[1] = pLtv->u.u16[1];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\npLtv->u.u16[1] = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\r\nbreak;\r\ncase CFG_BASIC_RATE_SET_CNTL:\r\nlp->brsc[0] = pLtv->u.u16[0];\r\nlp->brsc[1] = pLtv->u.u16[1];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\npLtv->u.u16[1] = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\r\nbreak;\r\ncase CFG_CNF_CONNECTION_CNTL:\r\nlp->connectionControl = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\n#endif\r\n#if 1\r\ncase CFG_CNF_OWN_DTIM_PERIOD:\r\nlp->DTIMPeriod = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\n#ifdef WARP\r\ncase CFG_CNF_OWN_BEACON_INTERVAL:\r\nlp->ownBeaconInterval = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\n#endif\r\ncase CFG_COEXISTENSE_BEHAVIOUR:\r\nlp->coexistence = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\n#ifdef USE_WDS\r\ncase CFG_CNF_WDS_ADDR1:\r\nmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\r\nhcfPort = HCF_PORT_1;\r\nbreak;\r\ncase CFG_CNF_WDS_ADDR2:\r\nmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\r\nhcfPort = HCF_PORT_2;\r\nbreak;\r\ncase CFG_CNF_WDS_ADDR3:\r\nmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\r\nhcfPort = HCF_PORT_3;\r\nbreak;\r\ncase CFG_CNF_WDS_ADDR4:\r\nmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\r\nhcfPort = HCF_PORT_4;\r\nbreak;\r\ncase CFG_CNF_WDS_ADDR5:\r\nmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\r\nhcfPort = HCF_PORT_5;\r\nbreak;\r\ncase CFG_CNF_WDS_ADDR6:\r\nmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\r\nhcfPort = HCF_PORT_6;\r\nbreak;\r\n#endif\r\ncase CFG_CNF_MCAST_PM_BUF:\r\nlp->multicastPMBuffering = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_CNF_REJECT_ANY:\r\nlp->RejectAny = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\n#endif\r\ncase CFG_CNF_ENCRYPTION:\r\nlp->EnableEncryption = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_CNF_AUTHENTICATION:\r\nlp->authentication = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\n#if 1\r\ncase CFG_CNF_MCAST_RATE:\r\nbreak;\r\ncase CFG_CNF_INTRA_BSS_RELAY:\r\nlp->intraBSSRelay = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\n#endif\r\ncase CFG_CNF_MICRO_WAVE:\r\nbreak;\r\ncase CFG_CNF_OWN_SSID:\r\ncase CFG_DESIRED_SSID:\r\nmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\r\nmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nif ((strlen(&pLtv->u.u8[2]) == 0) ||\r\n(strcmp(&pLtv->u.u8[2], "ANY") == 0) ||\r\n(strcmp(&pLtv->u.u8[2], "any") == 0)) {\r\npLtv->u.u16[0] = 0;\r\npLtv->u.u8[2] = 0;\r\n}\r\nbreak;\r\ncase CFG_GROUP_ADDR:\r\nbreak;\r\ncase CFG_CREATE_IBSS:\r\nlp->CreateIBSS = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_RTS_THRH:\r\nlp->RTSThreshold = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_TX_RATE_CNTL:\r\nlp->TxRateControl[0] = pLtv->u.u16[0];\r\nlp->TxRateControl[1] = pLtv->u.u16[1];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\npLtv->u.u16[1] = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\r\nbreak;\r\ncase CFG_PROMISCUOUS_MODE:\r\nbreak;\r\n#if 1\r\ncase CFG_RTS_THRH0:\r\nlp->RTSThreshold = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_TX_RATE_CNTL0:\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\n#ifdef USE_WDS\r\ncase CFG_RTS_THRH1:\r\nlp->wds_port[0].rtsThreshold = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nhcfPort = HCF_PORT_1;\r\nbreak;\r\ncase CFG_RTS_THRH2:\r\nlp->wds_port[1].rtsThreshold = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nhcfPort = HCF_PORT_2;\r\nbreak;\r\ncase CFG_RTS_THRH3:\r\nlp->wds_port[2].rtsThreshold = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nhcfPort = HCF_PORT_3;\r\nbreak;\r\ncase CFG_RTS_THRH4:\r\nlp->wds_port[3].rtsThreshold = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nhcfPort = HCF_PORT_4;\r\nbreak;\r\ncase CFG_RTS_THRH5:\r\nlp->wds_port[4].rtsThreshold = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nhcfPort = HCF_PORT_5;\r\nbreak;\r\ncase CFG_RTS_THRH6:\r\nlp->wds_port[5].rtsThreshold = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nhcfPort = HCF_PORT_6;\r\nbreak;\r\ncase CFG_TX_RATE_CNTL1:\r\nlp->wds_port[0].txRateCntl = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nhcfPort = HCF_PORT_1;\r\nbreak;\r\ncase CFG_TX_RATE_CNTL2:\r\nlp->wds_port[1].txRateCntl = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nhcfPort = HCF_PORT_2;\r\nbreak;\r\ncase CFG_TX_RATE_CNTL3:\r\nlp->wds_port[2].txRateCntl = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nhcfPort = HCF_PORT_3;\r\nbreak;\r\ncase CFG_TX_RATE_CNTL4:\r\nlp->wds_port[3].txRateCntl = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nhcfPort = HCF_PORT_4;\r\nbreak;\r\ncase CFG_TX_RATE_CNTL5:\r\nlp->wds_port[4].txRateCntl = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nhcfPort = HCF_PORT_5;\r\nbreak;\r\ncase CFG_TX_RATE_CNTL6:\r\nlp->wds_port[5].txRateCntl = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nhcfPort = HCF_PORT_6;\r\nbreak;\r\n#endif\r\n#endif\r\ncase CFG_DEFAULT_KEYS:\r\n{\r\nCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\r\npKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\r\npKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\r\npKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\r\npKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\r\nmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\r\nsizeof(CFG_DEFAULT_KEYS_STRCT));\r\n}\r\nbreak;\r\ncase CFG_TX_KEY_ID:\r\nlp->TransmitKeyID = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_SCAN_SSID:\r\nbreak;\r\ncase CFG_TICK_TIME:\r\nbreak;\r\ncase CFG_MAX_LOAD_TIME:\r\ncase CFG_DL_BUF:\r\ncase CFG_NIC_SERIAL_NUMBER:\r\ncase CFG_NIC_IDENTITY:\r\ncase CFG_NIC_MFI_SUP_RANGE:\r\ncase CFG_NIC_CFI_SUP_RANGE:\r\ncase CFG_NIC_TEMP_TYPE:\r\ncase CFG_NIC_PROFILE:\r\ncase CFG_FW_IDENTITY:\r\ncase CFG_FW_SUP_RANGE:\r\ncase CFG_MFI_ACT_RANGES_STA:\r\ncase CFG_CFI_ACT_RANGES_STA:\r\ncase CFG_PORT_STAT:\r\ncase CFG_CUR_SSID:\r\ncase CFG_CUR_BSSID:\r\ncase CFG_COMMS_QUALITY:\r\ncase CFG_CUR_TX_RATE:\r\ncase CFG_CUR_BEACON_INTERVAL:\r\ncase CFG_CUR_SCALE_THRH:\r\ncase CFG_PROTOCOL_RSP_TIME:\r\ncase CFG_CUR_SHORT_RETRY_LIMIT:\r\ncase CFG_CUR_LONG_RETRY_LIMIT:\r\ncase CFG_MAX_TX_LIFETIME:\r\ncase CFG_MAX_RX_LIFETIME:\r\ncase CFG_CF_POLLABLE:\r\ncase CFG_AUTHENTICATION_ALGORITHMS:\r\ncase CFG_PRIVACY_OPT_IMPLEMENTED:\r\ncase CFG_NIC_MAC_ADDR:\r\ncase CFG_PCF_INFO:\r\ncase CFG_PHY_TYPE:\r\ncase CFG_CUR_CHANNEL:\r\ncase CFG_SUPPORTED_DATA_RATES:\r\nbreak;\r\ncase CFG_AP_MODE:\r\nDBG_ERROR(DbgInfo, "set CFG_AP_MODE no longer supported\n");\r\nbreak;\r\ncase CFG_ENCRYPT_STRING:\r\nmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\r\nmemcpy((void *)lp->szEncryption, (void *)&pLtv->u.u8[0],\r\n(pLtv->len * sizeof(hcf_16)));\r\nwl_wep_decode(CRYPT_CODE, &sEncryption,\r\nlp->szEncryption);\r\nlp->TransmitKeyID = sEncryption.wTxKeyID + 1;\r\nlp->EnableEncryption = sEncryption.wEnabled;\r\nmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\r\nsizeof(CFG_DEFAULT_KEYS_STRCT));\r\nbreak;\r\ncase CFG_DRIVER_ENABLE:\r\nlp->driverEnable = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_WOLAS_ENABLE:\r\nlp->wolasEnable = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\r\nlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_DISASSOCIATE_ADDR:\r\npLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\r\nbreak;\r\ncase CFG_ADD_TKIP_DEFAULT_KEY:\r\ncase CFG_REMOVE_TKIP_DEFAULT_KEY:\r\npLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\r\nbreak;\r\ncase CFG_ADD_TKIP_MAPPED_KEY:\r\nbreak;\r\ncase CFG_REMOVE_TKIP_MAPPED_KEY:\r\nbreak;\r\ncase CFG_MB_INFO:\r\ncase CFG_IFB:\r\ndefault:\r\nbreak;\r\n}\r\nswitch (pLtv->typ) {\r\ncase CFG_CNF_PORT_TYPE:\r\ncase CFG_CNF_OWN_MAC_ADDR:\r\ncase CFG_CNF_OWN_CHANNEL:\r\ncase CFG_CNF_OWN_SSID:\r\ncase CFG_CNF_OWN_ATIM_WINDOW:\r\ncase CFG_CNF_SYSTEM_SCALE:\r\ncase CFG_CNF_MAX_DATA_LEN:\r\ncase CFG_CNF_PM_ENABLED:\r\ncase CFG_CNF_MCAST_RX:\r\ncase CFG_CNF_MAX_SLEEP_DURATION:\r\ncase CFG_CNF_HOLDOVER_DURATION:\r\ncase CFG_CNF_OWN_NAME:\r\ncase CFG_CNF_LOAD_BALANCING:\r\ncase CFG_CNF_MEDIUM_DISTRIBUTION:\r\n#ifdef WARP\r\ncase CFG_CNF_TX_POW_LVL:\r\ncase CFG_CNF_CONNECTION_CNTL:\r\n#endif\r\n#if 1\r\ncase CFG_CNF_OWN_DTIM_PERIOD:\r\n#ifdef WARP\r\ncase CFG_CNF_OWN_BEACON_INTERVAL:\r\n#endif\r\n#ifdef USE_WDS\r\ncase CFG_CNF_WDS_ADDR1:\r\ncase CFG_CNF_WDS_ADDR2:\r\ncase CFG_CNF_WDS_ADDR3:\r\ncase CFG_CNF_WDS_ADDR4:\r\ncase CFG_CNF_WDS_ADDR5:\r\ncase CFG_CNF_WDS_ADDR6:\r\n#endif\r\ncase CFG_CNF_MCAST_PM_BUF:\r\ncase CFG_CNF_REJECT_ANY:\r\n#endif\r\ncase CFG_CNF_ENCRYPTION:\r\ncase CFG_CNF_AUTHENTICATION:\r\n#if 1\r\ncase CFG_CNF_EXCL_UNENCRYPTED:\r\ncase CFG_CNF_MCAST_RATE:\r\ncase CFG_CNF_INTRA_BSS_RELAY:\r\n#endif\r\ncase CFG_CNF_MICRO_WAVE:\r\ncase CFG_AP_MODE:\r\ncase CFG_ENCRYPT_STRING:\r\ncase CFG_WOLAS_ENABLE:\r\ncase CFG_MB_INFO:\r\ncase CFG_IFB:\r\nbreak;\r\ncase CFG_DRIVER_ENABLE:\r\nif (lp->driverEnable) {\r\nhcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\r\nhcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\r\n} else {\r\nhcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\r\nhcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\r\n}\r\nbreak;\r\ndefault:\r\nwl_act_int_off(lp);\r\nurq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\r\nwl_act_int_on(lp);\r\nbreak;\r\n}\r\nif (ltvAllocated)\r\nkfree(pLtv);\r\n} else {\r\nurq->result = UIL_FAILURE;\r\n}\r\n} else {\r\nDBG_ERROR(DbgInfo, "EPERM\n");\r\nurq->result = UIL_FAILURE;\r\nresult = -EPERM;\r\n}\r\n} else {\r\nDBG_ERROR(DbgInfo, "UIL_ERR_WRONG_IFB\n");\r\nurq->result = UIL_ERR_WRONG_IFB;\r\n}\r\nreturn result;\r\n}\r\nint wvlan_uil_get_info(struct uilreq *urq, struct wl_private *lp)\r\n{\r\nint result = 0;\r\nint i;\r\nif (urq->hcfCtx == &(lp->hcfCtx)) {\r\nif ((urq->data != NULL) && (urq->len != 0)) {\r\nltv_t *pLtv;\r\nbool_t ltvAllocated = FALSE;\r\nif (urq->len < (sizeof(hcf_16) * 2)) {\r\nurq->len = sizeof(lp->ltvRecord);\r\nDBG_ERROR(DbgInfo, "No Length/Type in LTV!!!\n");\r\nDBG_ERROR(DbgInfo, "UIL_ERR_LEN\n");\r\nurq->result = UIL_ERR_LEN;\r\nreturn result;\r\n}\r\nresult = verify_area(VERIFY_READ, urq->data, sizeof(hcf_16) * 2);\r\nif (result != 0) {\r\nDBG_ERROR(DbgInfo, "verify_area(), VERIFY_READ FAILED\n");\r\nurq->result = UIL_FAILURE;\r\nreturn result;\r\n}\r\nresult = copy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\r\nif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\r\nDBG_ERROR(DbgInfo, "Incoming LTV too big\n");\r\nurq->len = sizeof(lp->ltvRecord);\r\nurq->result = UIL_ERR_LEN;\r\nreturn result;\r\n}\r\nswitch (lp->ltvRecord.typ) {\r\ncase CFG_NIC_IDENTITY:\r\nmemcpy(&lp->ltvRecord.u.u8[0], &lp->NICIdentity, sizeof(lp->NICIdentity));\r\nbreak;\r\ncase CFG_PRI_IDENTITY:\r\nmemcpy(&lp->ltvRecord.u.u8[0], &lp->PrimaryIdentity, sizeof(lp->PrimaryIdentity));\r\nbreak;\r\ncase CFG_AP_MODE:\r\nDBG_ERROR(DbgInfo, "set CFG_AP_MODE no longer supported, so is get useful ????\n");\r\nlp->ltvRecord.u.u16[0] =\r\nCNV_INT_TO_LITTLE(lp->hcfCtx.IFB_FWIdentity.comp_id) == COMP_ID_FW_AP;\r\nbreak;\r\ncase CFG_ENCRYPT_STRING:\r\ncase CFG_COUNTRY_STRING:\r\ncase CFG_DRIVER_ENABLE:\r\ncase CFG_WOLAS_ENABLE:\r\nurq->result = UIL_FAILURE;\r\nbreak;\r\ncase CFG_DRV_INFO:\r\nDBG_TRACE(DbgInfo, "Intercept CFG_DRV_INFO\n");\r\nresult = cfg_driver_info(urq, lp);\r\nbreak;\r\ncase CFG_DRV_IDENTITY:\r\nDBG_TRACE(DbgInfo, "Intercept CFG_DRV_IDENTITY\n");\r\nresult = cfg_driver_identity(urq, lp);\r\nbreak;\r\ncase CFG_IFB:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nresult = -EPERM;\r\nbreak;\r\n}\r\ncase CFG_FW_IDENTITY:\r\ndefault:\r\nresult = verify_area(VERIFY_WRITE, urq->data, urq->len);\r\nif (result != 0) {\r\nDBG_ERROR(DbgInfo, "verify_area(), VERIFY_WRITE FAILED\n");\r\nurq->result = UIL_FAILURE;\r\nbreak;\r\n}\r\nif (urq->len > sizeof(lp->ltvRecord)) {\r\npLtv = kmalloc(urq->len, GFP_KERNEL);\r\nif (pLtv != NULL) {\r\nltvAllocated = TRUE;\r\nmemcpy(pLtv, &(lp->ltvRecord), sizeof(hcf_16) * 2);\r\n} else {\r\nurq->len = sizeof(lp->ltvRecord);\r\nurq->result = UIL_ERR_LEN;\r\nDBG_ERROR(DbgInfo, "kmalloc FAILED\n");\r\nDBG_ERROR(DbgInfo, "UIL_ERR_LEN\n");\r\nresult = -ENOMEM;\r\nbreak;\r\n}\r\n} else {\r\npLtv = &(lp->ltvRecord);\r\n}\r\nwl_act_int_off(lp);\r\nurq->result = hcf_get_info(&(lp->hcfCtx), (LTVP) pLtv);\r\nwl_act_int_on(lp);\r\nbreak;\r\n}\r\nswitch (lp->ltvRecord.typ) {\r\ncase CFG_CNF_PORT_TYPE:\r\ncase CFG_CNF_OWN_CHANNEL:\r\ncase CFG_CNF_OWN_ATIM_WINDOW:\r\ncase CFG_CNF_SYSTEM_SCALE:\r\ncase CFG_CNF_MAX_DATA_LEN:\r\ncase CFG_CNF_PM_ENABLED:\r\ncase CFG_CNF_MCAST_RX:\r\ncase CFG_CNF_MAX_SLEEP_DURATION:\r\ncase CFG_CNF_HOLDOVER_DURATION:\r\ncase CFG_CNF_OWN_DTIM_PERIOD:\r\ncase CFG_CNF_MCAST_PM_BUF:\r\ncase CFG_CNF_REJECT_ANY:\r\ncase CFG_CNF_ENCRYPTION:\r\ncase CFG_CNF_AUTHENTICATION:\r\ncase CFG_CNF_EXCL_UNENCRYPTED:\r\ncase CFG_CNF_INTRA_BSS_RELAY:\r\ncase CFG_CNF_MICRO_WAVE:\r\ncase CFG_CNF_LOAD_BALANCING:\r\ncase CFG_CNF_MEDIUM_DISTRIBUTION:\r\n#ifdef WARP\r\ncase CFG_CNF_TX_POW_LVL:\r\ncase CFG_CNF_CONNECTION_CNTL:\r\ncase CFG_CNF_OWN_BEACON_INTERVAL:\r\ncase CFG_COEXISTENSE_BEHAVIOUR:\r\n#endif\r\ncase CFG_CREATE_IBSS:\r\ncase CFG_RTS_THRH:\r\ncase CFG_PROMISCUOUS_MODE:\r\ncase CFG_RTS_THRH0:\r\ncase CFG_RTS_THRH1:\r\ncase CFG_RTS_THRH2:\r\ncase CFG_RTS_THRH3:\r\ncase CFG_RTS_THRH4:\r\ncase CFG_RTS_THRH5:\r\ncase CFG_RTS_THRH6:\r\ncase CFG_TX_RATE_CNTL0:\r\ncase CFG_TX_RATE_CNTL1:\r\ncase CFG_TX_RATE_CNTL2:\r\ncase CFG_TX_RATE_CNTL3:\r\ncase CFG_TX_RATE_CNTL4:\r\ncase CFG_TX_RATE_CNTL5:\r\ncase CFG_TX_RATE_CNTL6:\r\ncase CFG_TX_KEY_ID:\r\ncase CFG_TICK_TIME:\r\ncase CFG_MAX_LOAD_TIME:\r\ncase CFG_NIC_TEMP_TYPE:\r\ncase CFG_PORT_STAT:\r\ncase CFG_CUR_TX_RATE:\r\ncase CFG_CUR_BEACON_INTERVAL:\r\ncase CFG_PROTOCOL_RSP_TIME:\r\ncase CFG_CUR_SHORT_RETRY_LIMIT:\r\ncase CFG_CUR_LONG_RETRY_LIMIT:\r\ncase CFG_MAX_TX_LIFETIME:\r\ncase CFG_MAX_RX_LIFETIME:\r\ncase CFG_CF_POLLABLE:\r\ncase CFG_PRIVACY_OPT_IMPLEMENTED:\r\ncase CFG_PHY_TYPE:\r\ncase CFG_CUR_CHANNEL:\r\ncase CFG_CNF_OWN_SSID:\r\ncase CFG_CNF_OWN_NAME:\r\ncase CFG_DESIRED_SSID:\r\ncase CFG_SCAN_SSID:\r\ncase CFG_CUR_SSID:\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\r\nbreak;\r\ncase CFG_CNF_OWN_MAC_ADDR:\r\ncase CFG_CNF_WDS_ADDR1:\r\ncase CFG_CNF_WDS_ADDR2:\r\ncase CFG_CNF_WDS_ADDR3:\r\ncase CFG_CNF_WDS_ADDR4:\r\ncase CFG_CNF_WDS_ADDR5:\r\ncase CFG_CNF_WDS_ADDR6:\r\ncase CFG_GROUP_ADDR:\r\ncase CFG_NIC_SERIAL_NUMBER:\r\ncase CFG_CUR_BSSID:\r\ncase CFG_NIC_MAC_ADDR:\r\ncase CFG_SUPPORTED_DATA_RATES:\r\nbreak;\r\ncase CFG_DEFAULT_KEYS:\r\n{\r\nCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)&lp->ltvRecord.u.u8[0];\r\npKeys[0].len = CNV_INT_TO_LITTLE(pKeys[0].len);\r\npKeys[1].len = CNV_INT_TO_LITTLE(pKeys[1].len);\r\npKeys[2].len = CNV_INT_TO_LITTLE(pKeys[2].len);\r\npKeys[3].len = CNV_INT_TO_LITTLE(pKeys[3].len);\r\n}\r\nbreak;\r\ncase CFG_CNF_MCAST_RATE:\r\ncase CFG_TX_RATE_CNTL:\r\ncase CFG_SUPPORTED_RATE_SET_CNTL:\r\ncase CFG_BASIC_RATE_SET_CNTL:\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\r\nlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);\r\nbreak;\r\ncase CFG_DL_BUF:\r\ncase CFG_NIC_IDENTITY:\r\ncase CFG_COMMS_QUALITY:\r\ncase CFG_PCF_INFO:\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\r\nlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);\r\nlp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[2]);\r\nbreak;\r\ncase CFG_FW_IDENTITY:\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\r\nlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);\r\nlp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[2]);\r\nlp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[3]);\r\nbreak;\r\ncase CFG_NIC_MFI_SUP_RANGE:\r\ncase CFG_NIC_CFI_SUP_RANGE:\r\ncase CFG_NIC_PROFILE:\r\ncase CFG_FW_SUP_RANGE:\r\nlp->ltvRecord.u.u16[0] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[0]);\r\nlp->ltvRecord.u.u16[1] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[1]);\r\nlp->ltvRecord.u.u16[2] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[2]);\r\nlp->ltvRecord.u.u16[3] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[3]);\r\nlp->ltvRecord.u.u16[4] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[4]);\r\nbreak;\r\ncase CFG_MFI_ACT_RANGES_STA:\r\ncase CFG_CFI_ACT_RANGES_STA:\r\ncase CFG_CUR_SCALE_THRH:\r\ncase CFG_AUTHENTICATION_ALGORITHMS:\r\nfor (i = 0; i < (lp->ltvRecord.len - 1); i++)\r\nlp->ltvRecord.u.u16[i] = CNV_INT_TO_LITTLE(lp->ltvRecord.u.u16[i]);\r\nbreak;\r\ncase CFG_PRI_IDENTITY:\r\nbreak;\r\ncase CFG_MB_INFO:\r\nbreak;\r\ncase CFG_IFB:\r\ncase CFG_DRV_INFO:\r\ncase CFG_AP_MODE:\r\ncase CFG_ENCRYPT_STRING:\r\ncase CFG_COUNTRY_STRING:\r\ncase CFG_DRIVER_ENABLE:\r\ncase CFG_WOLAS_ENABLE:\r\ndefault:\r\nbreak;\r\n}\r\ncopy_to_user(urq->data, &(lp->ltvRecord), urq->len);\r\nif (ltvAllocated)\r\nkfree(&(lp->ltvRecord));\r\nurq->result = UIL_SUCCESS;\r\n} else {\r\nurq->result = UIL_FAILURE;\r\n}\r\n} else {\r\nDBG_ERROR(DbgInfo, "UIL_ERR_WRONG_IFB\n");\r\nurq->result = UIL_ERR_WRONG_IFB;\r\n}\r\nreturn result;\r\n}\r\nint cfg_driver_info(struct uilreq *urq, struct wl_private *lp)\r\n{\r\nint result = 0;\r\nif (urq->len < sizeof(lp->driverInfo)) {\r\nurq->len = sizeof(lp->driverInfo);\r\nurq->result = UIL_ERR_LEN;\r\nreturn result;\r\n}\r\nresult = verify_area(VERIFY_WRITE, urq->data, sizeof(lp->driverInfo));\r\nif (result != 0) {\r\nurq->result = UIL_FAILURE;\r\nreturn result;\r\n}\r\nlp->driverInfo.card_stat = lp->hcfCtx.IFB_CardStat;\r\nurq->result = UIL_SUCCESS;\r\ncopy_to_user(urq->data, &(lp->driverInfo), sizeof(lp->driverInfo));\r\nreturn result;\r\n}\r\nint cfg_driver_identity(struct uilreq *urq, struct wl_private *lp)\r\n{\r\nint result = 0;\r\nif (urq->len < sizeof(lp->driverIdentity)) {\r\nurq->len = sizeof(lp->driverIdentity);\r\nurq->result = UIL_ERR_LEN;\r\nreturn result;\r\n}\r\nresult = verify_area(VERIFY_WRITE, urq->data, sizeof(lp->driverIdentity));\r\nif (result != 0) {\r\nurq->result = UIL_FAILURE;\r\nreturn result;\r\n}\r\nurq->result = UIL_SUCCESS;\r\ncopy_to_user(urq->data, &(lp->driverIdentity), sizeof(lp->driverIdentity));\r\nreturn result;\r\n}\r\nint wvlan_set_netname(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nwl_lock(lp, &flags);\r\nmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\r\nmemcpy(lp->NetworkName, extra, wrqu->data.length);\r\nwl_apply(lp);\r\nwl_unlock(lp, &flags);\r\nreturn ret;\r\n}\r\nint wvlan_get_netname(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nint status = -1;\r\nwvName_t *pName;\r\nwl_lock(lp, &flags);\r\nlp->ltvRecord.len = 1 + (sizeof(*pName) / sizeof(hcf_16));\r\nlp->ltvRecord.typ = CFG_CUR_SSID;\r\nstatus = hcf_get_info(&(lp->hcfCtx), (LTVP)&(lp->ltvRecord));\r\nif (status == HCF_SUCCESS) {\r\npName = (wvName_t *)&(lp->ltvRecord.u.u32);\r\nmemset(extra, '\0', HCF_MAX_NAME_LEN);\r\nwrqu->data.length = pName->length;\r\nmemcpy(extra, pName->name, pName->length);\r\n} else {\r\nret = -EFAULT;\r\n}\r\nwl_unlock(lp, &flags);\r\nreturn ret;\r\n}\r\nint wvlan_set_station_nickname(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nsize_t len;\r\nint ret = 0;\r\nwl_lock(lp, &flags);\r\nmemset(lp->StationName, 0, sizeof(lp->StationName));\r\nlen = min_t(size_t, wrqu->data.length, sizeof(lp->StationName));\r\nstrlcpy(lp->StationName, extra, len);\r\nwl_apply(lp);\r\nwl_unlock(lp, &flags);\r\nreturn ret;\r\n}\r\nint wvlan_get_station_nickname(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nint status = -1;\r\nwvName_t *pName;\r\nwl_lock(lp, &flags);\r\nlp->ltvRecord.len = 1 + (sizeof(*pName) / sizeof(hcf_16));\r\nlp->ltvRecord.typ = CFG_CNF_OWN_NAME;\r\nstatus = hcf_get_info(&(lp->hcfCtx), (LTVP)&(lp->ltvRecord));\r\nif (status == HCF_SUCCESS) {\r\npName = (wvName_t *)&(lp->ltvRecord.u.u32);\r\nmemset(extra, '\0', HCF_MAX_NAME_LEN);\r\nwrqu->data.length = pName->length;\r\nmemcpy(extra, pName->name, pName->length);\r\n} else {\r\nret = -EFAULT;\r\n}\r\nwl_unlock(lp, &flags);\r\nreturn ret;\r\n}\r\nint wvlan_set_porttype(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nhcf_16 portType;\r\nwl_lock(lp, &flags);\r\nportType = *((__u32 *)extra);\r\nif (!((portType == 1) || (portType == 3))) {\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nlp->PortType = portType;\r\nwl_apply(lp);\r\nout_unlock:\r\nwl_unlock(lp, &flags);\r\nreturn ret;\r\n}\r\nint wvlan_get_porttype(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nstruct wl_private *lp = wl_priv(dev);\r\nunsigned long flags;\r\nint ret = 0;\r\nint status = -1;\r\nhcf_16 *pPortType;\r\n__u32 *pData = (__u32 *)extra;\r\nwl_lock(lp, &flags);\r\nlp->ltvRecord.len = 1 + (sizeof(*pPortType) / sizeof(hcf_16));\r\nlp->ltvRecord.typ = CFG_CNF_PORT_TYPE;\r\nstatus = hcf_get_info(&(lp->hcfCtx), (LTVP)&(lp->ltvRecord));\r\nif (status == HCF_SUCCESS) {\r\npPortType = (hcf_16 *)&(lp->ltvRecord.u.u32);\r\n*pData = CNV_LITTLE_TO_INT(*pPortType);\r\n} else {\r\nret = -EFAULT;\r\n}\r\nwl_unlock(lp, &flags);\r\nreturn ret;\r\n}\r\nint wvlan_rts(struct rtsreq *rrq, __u32 io_base)\r\n{\r\nint ioctl_ret = 0;\r\nDBG_PRINT("io_base: 0x%08x\n", io_base);\r\nswitch (rrq->typ) {\r\ncase WL_IOCTL_RTS_READ:\r\nDBG_TRACE(DbgInfo, "IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_READ\n");\r\nrrq->data[0] = IN_PORT_WORD(io_base + rrq->reg);\r\nDBG_TRACE(DbgInfo, " reg 0x%04x ==> 0x%04x\n", rrq->reg, CNV_LITTLE_TO_SHORT(rrq->data[0]));\r\nbreak;\r\ncase WL_IOCTL_RTS_WRITE:\r\nDBG_TRACE(DbgInfo, "IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_WRITE\n");\r\nOUT_PORT_WORD(io_base + rrq->reg, rrq->data[0]);\r\nDBG_TRACE(DbgInfo, " reg 0x%04x <== 0x%04x\n", rrq->reg, CNV_LITTLE_TO_SHORT(rrq->data[0]));\r\nbreak;\r\ncase WL_IOCTL_RTS_BATCH_READ:\r\nDBG_TRACE(DbgInfo, "IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_BATCH_READ\n");\r\nIN_PORT_STRING_16(io_base + rrq->reg, rrq->data, rrq->len);\r\nDBG_TRACE(DbgInfo, " reg 0x%04x ==> %d bytes\n", rrq->reg, rrq->len * sizeof(__u16));\r\nbreak;\r\ncase WL_IOCTL_RTS_BATCH_WRITE:\r\nDBG_TRACE(DbgInfo, "IOCTL: WVLAN2_IOCTL_RTS -- WL_IOCTL_RTS_BATCH_WRITE\n");\r\nOUT_PORT_STRING_16(io_base + rrq->reg, rrq->data, rrq->len);\r\nDBG_TRACE(DbgInfo, " reg 0x%04x <== %d bytes\n", rrq->reg, rrq->len * sizeof(__u16));\r\nbreak;\r\ndefault:\r\nDBG_TRACE(DbgInfo, "IOCTL: WVLAN2_IOCTL_RTS -- UNSUPPORTED RTS CODE: 0x%X", rrq->typ);\r\nioctl_ret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ioctl_ret;\r\n}
