static __inline__ int radeon_check_and_fixup_offset(drm_radeon_private_t *\r\ndev_priv,\r\nstruct drm_file * file_priv,\r\nu32 *offset)\r\n{\r\nu64 off = *offset;\r\nu32 fb_end = dev_priv->fb_location + dev_priv->fb_size - 1;\r\nstruct drm_radeon_driver_file_fields *radeon_priv;\r\nif (radeon_check_offset(dev_priv, off))\r\nreturn 0;\r\nif (off < (dev_priv->fb_size + dev_priv->gart_size)) {\r\nradeon_priv = file_priv->driver_priv;\r\noff += radeon_priv->radeon_fb_delta;\r\n}\r\nif (off > fb_end)\r\noff = off - fb_end - 1 + dev_priv->gart_vm_start;\r\nif (radeon_check_offset(dev_priv, off)) {\r\nDRM_DEBUG("offset fixed up to 0x%x\n", (unsigned int)off);\r\n*offset = off;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic __inline__ int radeon_check_and_fixup_packets(drm_radeon_private_t *\r\ndev_priv,\r\nstruct drm_file *file_priv,\r\nint id, struct drm_buffer *buf)\r\n{\r\nu32 *data;\r\nswitch (id) {\r\ncase RADEON_EMIT_PP_MISC:\r\ndata = drm_buffer_pointer_to_dword(buf,\r\n(RADEON_RB3D_DEPTHOFFSET - RADEON_PP_MISC) / 4);\r\nif (radeon_check_and_fixup_offset(dev_priv, file_priv, data)) {\r\nDRM_ERROR("Invalid depth buffer offset\n");\r\nreturn -EINVAL;\r\n}\r\ndev_priv->have_z_offset = 1;\r\nbreak;\r\ncase RADEON_EMIT_PP_CNTL:\r\ndata = drm_buffer_pointer_to_dword(buf,\r\n(RADEON_RB3D_COLOROFFSET - RADEON_PP_CNTL) / 4);\r\nif (radeon_check_and_fixup_offset(dev_priv, file_priv, data)) {\r\nDRM_ERROR("Invalid colour buffer offset\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase R200_EMIT_PP_TXOFFSET_0:\r\ncase R200_EMIT_PP_TXOFFSET_1:\r\ncase R200_EMIT_PP_TXOFFSET_2:\r\ncase R200_EMIT_PP_TXOFFSET_3:\r\ncase R200_EMIT_PP_TXOFFSET_4:\r\ncase R200_EMIT_PP_TXOFFSET_5:\r\ndata = drm_buffer_pointer_to_dword(buf, 0);\r\nif (radeon_check_and_fixup_offset(dev_priv, file_priv, data)) {\r\nDRM_ERROR("Invalid R200 texture offset\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_EMIT_PP_TXFILTER_0:\r\ncase RADEON_EMIT_PP_TXFILTER_1:\r\ncase RADEON_EMIT_PP_TXFILTER_2:\r\ndata = drm_buffer_pointer_to_dword(buf,\r\n(RADEON_PP_TXOFFSET_0 - RADEON_PP_TXFILTER_0) / 4);\r\nif (radeon_check_and_fixup_offset(dev_priv, file_priv, data)) {\r\nDRM_ERROR("Invalid R100 texture offset\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase R200_EMIT_PP_CUBIC_OFFSETS_0:\r\ncase R200_EMIT_PP_CUBIC_OFFSETS_1:\r\ncase R200_EMIT_PP_CUBIC_OFFSETS_2:\r\ncase R200_EMIT_PP_CUBIC_OFFSETS_3:\r\ncase R200_EMIT_PP_CUBIC_OFFSETS_4:\r\ncase R200_EMIT_PP_CUBIC_OFFSETS_5:{\r\nint i;\r\nfor (i = 0; i < 5; i++) {\r\ndata = drm_buffer_pointer_to_dword(buf, i);\r\nif (radeon_check_and_fixup_offset(dev_priv,\r\nfile_priv,\r\ndata)) {\r\nDRM_ERROR\r\n("Invalid R200 cubic texture offset\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase RADEON_EMIT_PP_CUBIC_OFFSETS_T0:\r\ncase RADEON_EMIT_PP_CUBIC_OFFSETS_T1:\r\ncase RADEON_EMIT_PP_CUBIC_OFFSETS_T2:{\r\nint i;\r\nfor (i = 0; i < 5; i++) {\r\ndata = drm_buffer_pointer_to_dword(buf, i);\r\nif (radeon_check_and_fixup_offset(dev_priv,\r\nfile_priv,\r\ndata)) {\r\nDRM_ERROR\r\n("Invalid R100 cubic texture offset\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase R200_EMIT_VAP_CTL:{\r\nRING_LOCALS;\r\nBEGIN_RING(2);\r\nOUT_RING_REG(RADEON_SE_TCL_STATE_FLUSH, 0);\r\nADVANCE_RING();\r\n}\r\nbreak;\r\ncase RADEON_EMIT_RB3D_COLORPITCH:\r\ncase RADEON_EMIT_RE_LINE_PATTERN:\r\ncase RADEON_EMIT_SE_LINE_WIDTH:\r\ncase RADEON_EMIT_PP_LUM_MATRIX:\r\ncase RADEON_EMIT_PP_ROT_MATRIX_0:\r\ncase RADEON_EMIT_RB3D_STENCILREFMASK:\r\ncase RADEON_EMIT_SE_VPORT_XSCALE:\r\ncase RADEON_EMIT_SE_CNTL:\r\ncase RADEON_EMIT_SE_CNTL_STATUS:\r\ncase RADEON_EMIT_RE_MISC:\r\ncase RADEON_EMIT_PP_BORDER_COLOR_0:\r\ncase RADEON_EMIT_PP_BORDER_COLOR_1:\r\ncase RADEON_EMIT_PP_BORDER_COLOR_2:\r\ncase RADEON_EMIT_SE_ZBIAS_FACTOR:\r\ncase RADEON_EMIT_SE_TCL_OUTPUT_VTX_FMT:\r\ncase RADEON_EMIT_SE_TCL_MATERIAL_EMMISSIVE_RED:\r\ncase R200_EMIT_PP_TXCBLEND_0:\r\ncase R200_EMIT_PP_TXCBLEND_1:\r\ncase R200_EMIT_PP_TXCBLEND_2:\r\ncase R200_EMIT_PP_TXCBLEND_3:\r\ncase R200_EMIT_PP_TXCBLEND_4:\r\ncase R200_EMIT_PP_TXCBLEND_5:\r\ncase R200_EMIT_PP_TXCBLEND_6:\r\ncase R200_EMIT_PP_TXCBLEND_7:\r\ncase R200_EMIT_TCL_LIGHT_MODEL_CTL_0:\r\ncase R200_EMIT_TFACTOR_0:\r\ncase R200_EMIT_VTX_FMT_0:\r\ncase R200_EMIT_MATRIX_SELECT_0:\r\ncase R200_EMIT_TEX_PROC_CTL_2:\r\ncase R200_EMIT_TCL_UCP_VERT_BLEND_CTL:\r\ncase R200_EMIT_PP_TXFILTER_0:\r\ncase R200_EMIT_PP_TXFILTER_1:\r\ncase R200_EMIT_PP_TXFILTER_2:\r\ncase R200_EMIT_PP_TXFILTER_3:\r\ncase R200_EMIT_PP_TXFILTER_4:\r\ncase R200_EMIT_PP_TXFILTER_5:\r\ncase R200_EMIT_VTE_CNTL:\r\ncase R200_EMIT_OUTPUT_VTX_COMP_SEL:\r\ncase R200_EMIT_PP_TAM_DEBUG3:\r\ncase R200_EMIT_PP_CNTL_X:\r\ncase R200_EMIT_RB3D_DEPTHXY_OFFSET:\r\ncase R200_EMIT_RE_AUX_SCISSOR_CNTL:\r\ncase R200_EMIT_RE_SCISSOR_TL_0:\r\ncase R200_EMIT_RE_SCISSOR_TL_1:\r\ncase R200_EMIT_RE_SCISSOR_TL_2:\r\ncase R200_EMIT_SE_VAP_CNTL_STATUS:\r\ncase R200_EMIT_SE_VTX_STATE_CNTL:\r\ncase R200_EMIT_RE_POINTSIZE:\r\ncase R200_EMIT_TCL_INPUT_VTX_VECTOR_ADDR_0:\r\ncase R200_EMIT_PP_CUBIC_FACES_0:\r\ncase R200_EMIT_PP_CUBIC_FACES_1:\r\ncase R200_EMIT_PP_CUBIC_FACES_2:\r\ncase R200_EMIT_PP_CUBIC_FACES_3:\r\ncase R200_EMIT_PP_CUBIC_FACES_4:\r\ncase R200_EMIT_PP_CUBIC_FACES_5:\r\ncase RADEON_EMIT_PP_TEX_SIZE_0:\r\ncase RADEON_EMIT_PP_TEX_SIZE_1:\r\ncase RADEON_EMIT_PP_TEX_SIZE_2:\r\ncase R200_EMIT_RB3D_BLENDCOLOR:\r\ncase R200_EMIT_TCL_POINT_SPRITE_CNTL:\r\ncase RADEON_EMIT_PP_CUBIC_FACES_0:\r\ncase RADEON_EMIT_PP_CUBIC_FACES_1:\r\ncase RADEON_EMIT_PP_CUBIC_FACES_2:\r\ncase R200_EMIT_PP_TRI_PERF_CNTL:\r\ncase R200_EMIT_PP_AFS_0:\r\ncase R200_EMIT_PP_AFS_1:\r\ncase R200_EMIT_ATF_TFACTOR:\r\ncase R200_EMIT_PP_TXCTLALL_0:\r\ncase R200_EMIT_PP_TXCTLALL_1:\r\ncase R200_EMIT_PP_TXCTLALL_2:\r\ncase R200_EMIT_PP_TXCTLALL_3:\r\ncase R200_EMIT_PP_TXCTLALL_4:\r\ncase R200_EMIT_PP_TXCTLALL_5:\r\ncase R200_EMIT_VAP_PVS_CNTL:\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown state packet ID %d\n", id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_check_and_fixup_packet3(drm_radeon_private_t *\r\ndev_priv,\r\nstruct drm_file *file_priv,\r\ndrm_radeon_kcmd_buffer_t *\r\ncmdbuf,\r\nunsigned int *cmdsz)\r\n{\r\nu32 *cmd = drm_buffer_pointer_to_dword(cmdbuf->buffer, 0);\r\nu32 offset, narrays;\r\nint count, i, k;\r\ncount = ((*cmd & RADEON_CP_PACKET_COUNT_MASK) >> 16);\r\n*cmdsz = 2 + count;\r\nif ((*cmd & 0xc0000000) != RADEON_CP_PACKET3) {\r\nDRM_ERROR("Not a type 3 packet\n");\r\nreturn -EINVAL;\r\n}\r\nif (4 * *cmdsz > drm_buffer_unprocessed(cmdbuf->buffer)) {\r\nDRM_ERROR("Packet size larger than size of data provided\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (*cmd & 0xff00) {\r\ncase RADEON_3D_DRAW_IMMD:\r\ncase RADEON_3D_DRAW_VBUF:\r\ncase RADEON_3D_DRAW_INDX:\r\ncase RADEON_WAIT_FOR_IDLE:\r\ncase RADEON_CP_NOP:\r\ncase RADEON_3D_CLEAR_ZMASK:\r\nbreak;\r\ncase RADEON_CP_3D_DRAW_IMMD_2:\r\ncase RADEON_CP_3D_DRAW_VBUF_2:\r\ncase RADEON_CP_3D_DRAW_INDX_2:\r\ncase RADEON_3D_CLEAR_HIZ:\r\nif (dev_priv->microcode_version != UCODE_R200) {\r\nDRM_ERROR("Invalid 3d packet for r100-class chip\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_3D_LOAD_VBPNTR:\r\nif (count > 18) {\r\nDRM_ERROR("Too large payload in 3D_LOAD_VBPNTR (count=%d)\n",\r\ncount);\r\nreturn -EINVAL;\r\n}\r\ncmd = drm_buffer_pointer_to_dword(cmdbuf->buffer, 1);\r\nnarrays = *cmd & ~0xc000;\r\nk = 0;\r\ni = 2;\r\nwhile ((k < narrays) && (i < (count + 2))) {\r\ni++;\r\ncmd = drm_buffer_pointer_to_dword(cmdbuf->buffer, i);\r\nif (radeon_check_and_fixup_offset(dev_priv, file_priv,\r\ncmd)) {\r\nDRM_ERROR\r\n("Invalid offset (k=%d i=%d) in 3D_LOAD_VBPNTR packet.\n",\r\nk, i);\r\nreturn -EINVAL;\r\n}\r\nk++;\r\ni++;\r\nif (k == narrays)\r\nbreak;\r\ncmd = drm_buffer_pointer_to_dword(cmdbuf->buffer, i);\r\nif (radeon_check_and_fixup_offset(dev_priv,\r\nfile_priv, cmd))\r\n{\r\nDRM_ERROR\r\n("Invalid offset (k=%d i=%d) in 3D_LOAD_VBPNTR packet.\n",\r\nk, i);\r\nreturn -EINVAL;\r\n}\r\nk++;\r\ni++;\r\n}\r\nif ((k != narrays) || (i != (count + 2))) {\r\nDRM_ERROR\r\n("Malformed 3D_LOAD_VBPNTR packet (k=%d i=%d narrays=%d count+1=%d).\n",\r\nk, i, narrays, count + 1);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_3D_RNDR_GEN_INDX_PRIM:\r\nif (dev_priv->microcode_version != UCODE_R100) {\r\nDRM_ERROR("Invalid 3d packet for r200-class chip\n");\r\nreturn -EINVAL;\r\n}\r\ncmd = drm_buffer_pointer_to_dword(cmdbuf->buffer, 1);\r\nif (radeon_check_and_fixup_offset(dev_priv, file_priv, cmd)) {\r\nDRM_ERROR("Invalid rndr_gen_indx offset\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_CP_INDX_BUFFER:\r\nif (dev_priv->microcode_version != UCODE_R200) {\r\nDRM_ERROR("Invalid 3d packet for r100-class chip\n");\r\nreturn -EINVAL;\r\n}\r\ncmd = drm_buffer_pointer_to_dword(cmdbuf->buffer, 1);\r\nif ((*cmd & 0x8000ffff) != 0x80000810) {\r\nDRM_ERROR("Invalid indx_buffer reg address %08X\n", *cmd);\r\nreturn -EINVAL;\r\n}\r\ncmd = drm_buffer_pointer_to_dword(cmdbuf->buffer, 2);\r\nif (radeon_check_and_fixup_offset(dev_priv, file_priv, cmd)) {\r\nDRM_ERROR("Invalid indx_buffer offset is %08X\n", *cmd);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RADEON_CNTL_HOSTDATA_BLT:\r\ncase RADEON_CNTL_PAINT_MULTI:\r\ncase RADEON_CNTL_BITBLT_MULTI:\r\ncmd = drm_buffer_pointer_to_dword(cmdbuf->buffer, 1);\r\nif (*cmd & (RADEON_GMC_SRC_PITCH_OFFSET_CNTL\r\n| RADEON_GMC_DST_PITCH_OFFSET_CNTL)) {\r\nu32 *cmd2 = drm_buffer_pointer_to_dword(cmdbuf->buffer, 2);\r\noffset = *cmd2 << 10;\r\nif (radeon_check_and_fixup_offset\r\n(dev_priv, file_priv, &offset)) {\r\nDRM_ERROR("Invalid first packet offset\n");\r\nreturn -EINVAL;\r\n}\r\n*cmd2 = (*cmd2 & 0xffc00000) | offset >> 10;\r\n}\r\nif ((*cmd & RADEON_GMC_SRC_PITCH_OFFSET_CNTL) &&\r\n(*cmd & RADEON_GMC_DST_PITCH_OFFSET_CNTL)) {\r\nu32 *cmd3 = drm_buffer_pointer_to_dword(cmdbuf->buffer, 3);\r\noffset = *cmd3 << 10;\r\nif (radeon_check_and_fixup_offset\r\n(dev_priv, file_priv, &offset)) {\r\nDRM_ERROR("Invalid second packet offset\n");\r\nreturn -EINVAL;\r\n}\r\n*cmd3 = (*cmd3 & 0xffc00000) | offset >> 10;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Invalid packet type %x\n", *cmd & 0xff00);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void radeon_emit_clip_rect(drm_radeon_private_t * dev_priv,\r\nstruct drm_clip_rect * box)\r\n{\r\nRING_LOCALS;\r\nDRM_DEBUG(" box: x1=%d y1=%d x2=%d y2=%d\n",\r\nbox->x1, box->y1, box->x2, box->y2);\r\nBEGIN_RING(4);\r\nOUT_RING(CP_PACKET0(RADEON_RE_TOP_LEFT, 0));\r\nOUT_RING((box->y1 << 16) | box->x1);\r\nOUT_RING(CP_PACKET0(RADEON_RE_WIDTH_HEIGHT, 0));\r\nOUT_RING(((box->y2 - 1) << 16) | (box->x2 - 1));\r\nADVANCE_RING();\r\n}\r\nstatic int radeon_emit_state(drm_radeon_private_t * dev_priv,\r\nstruct drm_file *file_priv,\r\ndrm_radeon_context_regs_t * ctx,\r\ndrm_radeon_texture_regs_t * tex,\r\nunsigned int dirty)\r\n{\r\nRING_LOCALS;\r\nDRM_DEBUG("dirty=0x%08x\n", dirty);\r\nif (dirty & RADEON_UPLOAD_CONTEXT) {\r\nif (radeon_check_and_fixup_offset(dev_priv, file_priv,\r\n&ctx->rb3d_depthoffset)) {\r\nDRM_ERROR("Invalid depth buffer offset\n");\r\nreturn -EINVAL;\r\n}\r\nif (radeon_check_and_fixup_offset(dev_priv, file_priv,\r\n&ctx->rb3d_coloroffset)) {\r\nDRM_ERROR("Invalid depth buffer offset\n");\r\nreturn -EINVAL;\r\n}\r\nBEGIN_RING(14);\r\nOUT_RING(CP_PACKET0(RADEON_PP_MISC, 6));\r\nOUT_RING(ctx->pp_misc);\r\nOUT_RING(ctx->pp_fog_color);\r\nOUT_RING(ctx->re_solid_color);\r\nOUT_RING(ctx->rb3d_blendcntl);\r\nOUT_RING(ctx->rb3d_depthoffset);\r\nOUT_RING(ctx->rb3d_depthpitch);\r\nOUT_RING(ctx->rb3d_zstencilcntl);\r\nOUT_RING(CP_PACKET0(RADEON_PP_CNTL, 2));\r\nOUT_RING(ctx->pp_cntl);\r\nOUT_RING(ctx->rb3d_cntl);\r\nOUT_RING(ctx->rb3d_coloroffset);\r\nOUT_RING(CP_PACKET0(RADEON_RB3D_COLORPITCH, 0));\r\nOUT_RING(ctx->rb3d_colorpitch);\r\nADVANCE_RING();\r\n}\r\nif (dirty & RADEON_UPLOAD_VERTFMT) {\r\nBEGIN_RING(2);\r\nOUT_RING(CP_PACKET0(RADEON_SE_COORD_FMT, 0));\r\nOUT_RING(ctx->se_coord_fmt);\r\nADVANCE_RING();\r\n}\r\nif (dirty & RADEON_UPLOAD_LINE) {\r\nBEGIN_RING(5);\r\nOUT_RING(CP_PACKET0(RADEON_RE_LINE_PATTERN, 1));\r\nOUT_RING(ctx->re_line_pattern);\r\nOUT_RING(ctx->re_line_state);\r\nOUT_RING(CP_PACKET0(RADEON_SE_LINE_WIDTH, 0));\r\nOUT_RING(ctx->se_line_width);\r\nADVANCE_RING();\r\n}\r\nif (dirty & RADEON_UPLOAD_BUMPMAP) {\r\nBEGIN_RING(5);\r\nOUT_RING(CP_PACKET0(RADEON_PP_LUM_MATRIX, 0));\r\nOUT_RING(ctx->pp_lum_matrix);\r\nOUT_RING(CP_PACKET0(RADEON_PP_ROT_MATRIX_0, 1));\r\nOUT_RING(ctx->pp_rot_matrix_0);\r\nOUT_RING(ctx->pp_rot_matrix_1);\r\nADVANCE_RING();\r\n}\r\nif (dirty & RADEON_UPLOAD_MASKS) {\r\nBEGIN_RING(4);\r\nOUT_RING(CP_PACKET0(RADEON_RB3D_STENCILREFMASK, 2));\r\nOUT_RING(ctx->rb3d_stencilrefmask);\r\nOUT_RING(ctx->rb3d_ropcntl);\r\nOUT_RING(ctx->rb3d_planemask);\r\nADVANCE_RING();\r\n}\r\nif (dirty & RADEON_UPLOAD_VIEWPORT) {\r\nBEGIN_RING(7);\r\nOUT_RING(CP_PACKET0(RADEON_SE_VPORT_XSCALE, 5));\r\nOUT_RING(ctx->se_vport_xscale);\r\nOUT_RING(ctx->se_vport_xoffset);\r\nOUT_RING(ctx->se_vport_yscale);\r\nOUT_RING(ctx->se_vport_yoffset);\r\nOUT_RING(ctx->se_vport_zscale);\r\nOUT_RING(ctx->se_vport_zoffset);\r\nADVANCE_RING();\r\n}\r\nif (dirty & RADEON_UPLOAD_SETUP) {\r\nBEGIN_RING(4);\r\nOUT_RING(CP_PACKET0(RADEON_SE_CNTL, 0));\r\nOUT_RING(ctx->se_cntl);\r\nOUT_RING(CP_PACKET0(RADEON_SE_CNTL_STATUS, 0));\r\nOUT_RING(ctx->se_cntl_status);\r\nADVANCE_RING();\r\n}\r\nif (dirty & RADEON_UPLOAD_MISC) {\r\nBEGIN_RING(2);\r\nOUT_RING(CP_PACKET0(RADEON_RE_MISC, 0));\r\nOUT_RING(ctx->re_misc);\r\nADVANCE_RING();\r\n}\r\nif (dirty & RADEON_UPLOAD_TEX0) {\r\nif (radeon_check_and_fixup_offset(dev_priv, file_priv,\r\n&tex[0].pp_txoffset)) {\r\nDRM_ERROR("Invalid texture offset for unit 0\n");\r\nreturn -EINVAL;\r\n}\r\nBEGIN_RING(9);\r\nOUT_RING(CP_PACKET0(RADEON_PP_TXFILTER_0, 5));\r\nOUT_RING(tex[0].pp_txfilter);\r\nOUT_RING(tex[0].pp_txformat);\r\nOUT_RING(tex[0].pp_txoffset);\r\nOUT_RING(tex[0].pp_txcblend);\r\nOUT_RING(tex[0].pp_txablend);\r\nOUT_RING(tex[0].pp_tfactor);\r\nOUT_RING(CP_PACKET0(RADEON_PP_BORDER_COLOR_0, 0));\r\nOUT_RING(tex[0].pp_border_color);\r\nADVANCE_RING();\r\n}\r\nif (dirty & RADEON_UPLOAD_TEX1) {\r\nif (radeon_check_and_fixup_offset(dev_priv, file_priv,\r\n&tex[1].pp_txoffset)) {\r\nDRM_ERROR("Invalid texture offset for unit 1\n");\r\nreturn -EINVAL;\r\n}\r\nBEGIN_RING(9);\r\nOUT_RING(CP_PACKET0(RADEON_PP_TXFILTER_1, 5));\r\nOUT_RING(tex[1].pp_txfilter);\r\nOUT_RING(tex[1].pp_txformat);\r\nOUT_RING(tex[1].pp_txoffset);\r\nOUT_RING(tex[1].pp_txcblend);\r\nOUT_RING(tex[1].pp_txablend);\r\nOUT_RING(tex[1].pp_tfactor);\r\nOUT_RING(CP_PACKET0(RADEON_PP_BORDER_COLOR_1, 0));\r\nOUT_RING(tex[1].pp_border_color);\r\nADVANCE_RING();\r\n}\r\nif (dirty & RADEON_UPLOAD_TEX2) {\r\nif (radeon_check_and_fixup_offset(dev_priv, file_priv,\r\n&tex[2].pp_txoffset)) {\r\nDRM_ERROR("Invalid texture offset for unit 2\n");\r\nreturn -EINVAL;\r\n}\r\nBEGIN_RING(9);\r\nOUT_RING(CP_PACKET0(RADEON_PP_TXFILTER_2, 5));\r\nOUT_RING(tex[2].pp_txfilter);\r\nOUT_RING(tex[2].pp_txformat);\r\nOUT_RING(tex[2].pp_txoffset);\r\nOUT_RING(tex[2].pp_txcblend);\r\nOUT_RING(tex[2].pp_txablend);\r\nOUT_RING(tex[2].pp_tfactor);\r\nOUT_RING(CP_PACKET0(RADEON_PP_BORDER_COLOR_2, 0));\r\nOUT_RING(tex[2].pp_border_color);\r\nADVANCE_RING();\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_emit_state2(drm_radeon_private_t * dev_priv,\r\nstruct drm_file *file_priv,\r\ndrm_radeon_state_t * state)\r\n{\r\nRING_LOCALS;\r\nif (state->dirty & RADEON_UPLOAD_ZBIAS) {\r\nBEGIN_RING(3);\r\nOUT_RING(CP_PACKET0(RADEON_SE_ZBIAS_FACTOR, 1));\r\nOUT_RING(state->context2.se_zbias_factor);\r\nOUT_RING(state->context2.se_zbias_constant);\r\nADVANCE_RING();\r\n}\r\nreturn radeon_emit_state(dev_priv, file_priv, &state->context,\r\nstate->tex, state->dirty);\r\n}\r\nstatic void radeon_clear_box(drm_radeon_private_t * dev_priv,\r\nstruct drm_radeon_master_private *master_priv,\r\nint x, int y, int w, int h, int r, int g, int b)\r\n{\r\nu32 color;\r\nRING_LOCALS;\r\nx += master_priv->sarea_priv->boxes[0].x1;\r\ny += master_priv->sarea_priv->boxes[0].y1;\r\nswitch (dev_priv->color_fmt) {\r\ncase RADEON_COLOR_FORMAT_RGB565:\r\ncolor = (((r & 0xf8) << 8) |\r\n((g & 0xfc) << 3) | ((b & 0xf8) >> 3));\r\nbreak;\r\ncase RADEON_COLOR_FORMAT_ARGB8888:\r\ndefault:\r\ncolor = (((0xff) << 24) | (r << 16) | (g << 8) | b);\r\nbreak;\r\n}\r\nBEGIN_RING(4);\r\nRADEON_WAIT_UNTIL_3D_IDLE();\r\nOUT_RING(CP_PACKET0(RADEON_DP_WRITE_MASK, 0));\r\nOUT_RING(0xffffffff);\r\nADVANCE_RING();\r\nBEGIN_RING(6);\r\nOUT_RING(CP_PACKET3(RADEON_CNTL_PAINT_MULTI, 4));\r\nOUT_RING(RADEON_GMC_DST_PITCH_OFFSET_CNTL |\r\nRADEON_GMC_BRUSH_SOLID_COLOR |\r\n(dev_priv->color_fmt << 8) |\r\nRADEON_GMC_SRC_DATATYPE_COLOR |\r\nRADEON_ROP3_P | RADEON_GMC_CLR_CMP_CNTL_DIS);\r\nif (master_priv->sarea_priv->pfCurrentPage == 1) {\r\nOUT_RING(dev_priv->front_pitch_offset);\r\n} else {\r\nOUT_RING(dev_priv->back_pitch_offset);\r\n}\r\nOUT_RING(color);\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((w << 16) | h);\r\nADVANCE_RING();\r\n}\r\nstatic void radeon_cp_performance_boxes(drm_radeon_private_t *dev_priv, struct drm_radeon_master_private *master_priv)\r\n{\r\nif (dev_priv->stats.last_frame_reads > 1 ||\r\ndev_priv->stats.last_clear_reads > dev_priv->stats.clears) {\r\ndev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;\r\n}\r\nif (dev_priv->stats.freelist_loops) {\r\ndev_priv->stats.boxes |= RADEON_BOX_WAIT_IDLE;\r\n}\r\nif (dev_priv->stats.boxes & RADEON_BOX_FLIP)\r\nradeon_clear_box(dev_priv, master_priv, 4, 4, 8, 8, 255, 0, 255);\r\nif (dev_priv->stats.boxes & RADEON_BOX_WAIT_IDLE)\r\nradeon_clear_box(dev_priv, master_priv, 16, 4, 8, 8, 255, 0, 0);\r\nif (dev_priv->stats.boxes & RADEON_BOX_TEXTURE_LOAD)\r\nradeon_clear_box(dev_priv, master_priv, 40, 4, 8, 8, 255, 255, 0);\r\nif (!(dev_priv->stats.boxes & RADEON_BOX_DMA_IDLE))\r\nradeon_clear_box(dev_priv, master_priv, 64, 4, 8, 8, 0, 255, 0);\r\nif (dev_priv->stats.requested_bufs) {\r\nif (dev_priv->stats.requested_bufs > 100)\r\ndev_priv->stats.requested_bufs = 100;\r\nradeon_clear_box(dev_priv, master_priv, 4, 16,\r\ndev_priv->stats.requested_bufs, 4,\r\n196, 128, 128);\r\n}\r\nmemset(&dev_priv->stats, 0, sizeof(dev_priv->stats));\r\n}\r\nstatic void radeon_cp_dispatch_clear(struct drm_device * dev,\r\nstruct drm_master *master,\r\ndrm_radeon_clear_t * clear,\r\ndrm_radeon_clear_rect_t * depth_boxes)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = master->driver_priv;\r\ndrm_radeon_sarea_t *sarea_priv = master_priv->sarea_priv;\r\ndrm_radeon_depth_clear_t *depth_clear = &dev_priv->depth_clear;\r\nint nbox = sarea_priv->nbox;\r\nstruct drm_clip_rect *pbox = sarea_priv->boxes;\r\nunsigned int flags = clear->flags;\r\nu32 rb3d_cntl = 0, rb3d_stencilrefmask = 0;\r\nint i;\r\nRING_LOCALS;\r\nDRM_DEBUG("flags = 0x%x\n", flags);\r\ndev_priv->stats.clears++;\r\nif (sarea_priv->pfCurrentPage == 1) {\r\nunsigned int tmp = flags;\r\nflags &= ~(RADEON_FRONT | RADEON_BACK);\r\nif (tmp & RADEON_FRONT)\r\nflags |= RADEON_BACK;\r\nif (tmp & RADEON_BACK)\r\nflags |= RADEON_FRONT;\r\n}\r\nif (flags & (RADEON_DEPTH|RADEON_STENCIL)) {\r\nif (!dev_priv->have_z_offset) {\r\nprintk_once(KERN_ERR "radeon: illegal depth clear request. Buggy mesa detected - please update.\n");\r\nflags &= ~(RADEON_DEPTH | RADEON_STENCIL);\r\n}\r\n}\r\nif (flags & (RADEON_FRONT | RADEON_BACK)) {\r\nBEGIN_RING(4);\r\nRADEON_WAIT_UNTIL_3D_IDLE();\r\nOUT_RING(CP_PACKET0(RADEON_DP_WRITE_MASK, 0));\r\nOUT_RING(clear->color_mask);\r\nADVANCE_RING();\r\nsarea_priv->ctx_owner = 0;\r\nfor (i = 0; i < nbox; i++) {\r\nint x = pbox[i].x1;\r\nint y = pbox[i].y1;\r\nint w = pbox[i].x2 - x;\r\nint h = pbox[i].y2 - y;\r\nDRM_DEBUG("%d,%d-%d,%d flags 0x%x\n",\r\nx, y, w, h, flags);\r\nif (flags & RADEON_FRONT) {\r\nBEGIN_RING(6);\r\nOUT_RING(CP_PACKET3\r\n(RADEON_CNTL_PAINT_MULTI, 4));\r\nOUT_RING(RADEON_GMC_DST_PITCH_OFFSET_CNTL |\r\nRADEON_GMC_BRUSH_SOLID_COLOR |\r\n(dev_priv->\r\ncolor_fmt << 8) |\r\nRADEON_GMC_SRC_DATATYPE_COLOR |\r\nRADEON_ROP3_P |\r\nRADEON_GMC_CLR_CMP_CNTL_DIS);\r\nOUT_RING(dev_priv->front_pitch_offset);\r\nOUT_RING(clear->clear_color);\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((w << 16) | h);\r\nADVANCE_RING();\r\n}\r\nif (flags & RADEON_BACK) {\r\nBEGIN_RING(6);\r\nOUT_RING(CP_PACKET3\r\n(RADEON_CNTL_PAINT_MULTI, 4));\r\nOUT_RING(RADEON_GMC_DST_PITCH_OFFSET_CNTL |\r\nRADEON_GMC_BRUSH_SOLID_COLOR |\r\n(dev_priv->\r\ncolor_fmt << 8) |\r\nRADEON_GMC_SRC_DATATYPE_COLOR |\r\nRADEON_ROP3_P |\r\nRADEON_GMC_CLR_CMP_CNTL_DIS);\r\nOUT_RING(dev_priv->back_pitch_offset);\r\nOUT_RING(clear->clear_color);\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((w << 16) | h);\r\nADVANCE_RING();\r\n}\r\n}\r\n}\r\nif ((flags & (RADEON_DEPTH | RADEON_STENCIL))\r\n&& (flags & RADEON_CLEAR_FASTZ)) {\r\nint i;\r\nint depthpixperline =\r\ndev_priv->depth_fmt ==\r\nRADEON_DEPTH_FORMAT_16BIT_INT_Z ? (dev_priv->depth_pitch /\r\n2) : (dev_priv->\r\ndepth_pitch / 4);\r\nu32 clearmask;\r\nu32 tempRB3D_DEPTHCLEARVALUE = clear->clear_depth |\r\n((clear->depth_mask & 0xff) << 24);\r\nsarea_priv->ctx_owner = 0;\r\nif ((dev_priv->flags & RADEON_HAS_HIERZ)\r\n&& (flags & RADEON_USE_HIERZ)) {\r\nclearmask = (0xff << 22) | (0xff << 6) | 0x003f003f;\r\n} else {\r\nclearmask = 0x0;\r\n}\r\nBEGIN_RING(8);\r\nRADEON_WAIT_UNTIL_2D_IDLE();\r\nOUT_RING_REG(RADEON_RB3D_DEPTHCLEARVALUE,\r\ntempRB3D_DEPTHCLEARVALUE);\r\nOUT_RING_REG(RADEON_RB3D_ZMASKOFFSET, 0);\r\nOUT_RING_REG(RADEON_RB3D_ZCACHE_CTLSTAT,\r\nRADEON_RB3D_ZC_FLUSH_ALL);\r\nADVANCE_RING();\r\nfor (i = 0; i < nbox; i++) {\r\nint tileoffset, nrtilesx, nrtilesy, j;\r\nif ((dev_priv->flags & RADEON_HAS_HIERZ)\r\n&& !(dev_priv->microcode_version == UCODE_R200)) {\r\ntileoffset =\r\n((pbox[i].y1 >> 3) * depthpixperline +\r\npbox[i].x1) >> 6;\r\nnrtilesx =\r\n((pbox[i].x2 & ~63) -\r\n(pbox[i].x1 & ~63)) >> 4;\r\nnrtilesy =\r\n(pbox[i].y2 >> 3) - (pbox[i].y1 >> 3);\r\nfor (j = 0; j <= nrtilesy; j++) {\r\nBEGIN_RING(4);\r\nOUT_RING(CP_PACKET3\r\n(RADEON_3D_CLEAR_ZMASK, 2));\r\nOUT_RING(tileoffset * 8);\r\nOUT_RING(nrtilesx + 4);\r\nOUT_RING(clearmask);\r\nADVANCE_RING();\r\ntileoffset += depthpixperline >> 6;\r\n}\r\n} else if (dev_priv->microcode_version == UCODE_R200) {\r\ntileoffset =\r\n((pbox[i].y1 >> 3) * depthpixperline +\r\npbox[i].x1) >> 5;\r\nnrtilesx =\r\n(pbox[i].x2 >> 5) - (pbox[i].x1 >> 5);\r\nnrtilesy =\r\n(pbox[i].y2 >> 3) - (pbox[i].y1 >> 3);\r\nfor (j = 0; j <= nrtilesy; j++) {\r\nBEGIN_RING(4);\r\nOUT_RING(CP_PACKET3\r\n(RADEON_3D_CLEAR_ZMASK, 2));\r\nOUT_RING(tileoffset * 16);\r\nOUT_RING(nrtilesx + 1);\r\nOUT_RING(clearmask);\r\nADVANCE_RING();\r\ntileoffset += depthpixperline >> 5;\r\n}\r\n} else {\r\ntileoffset =\r\n((pbox[i].y1 >> 4) * depthpixperline +\r\npbox[i].x1) >> 6;\r\nnrtilesx =\r\n((pbox[i].x2 & ~63) -\r\n(pbox[i].x1 & ~63)) >> 4;\r\nnrtilesy =\r\n(pbox[i].y2 >> 4) - (pbox[i].y1 >> 4);\r\nfor (j = 0; j <= nrtilesy; j++) {\r\nBEGIN_RING(4);\r\nOUT_RING(CP_PACKET3\r\n(RADEON_3D_CLEAR_ZMASK, 2));\r\nOUT_RING(tileoffset * 128);\r\nOUT_RING(nrtilesx + 4);\r\nOUT_RING(clearmask);\r\nADVANCE_RING();\r\ntileoffset += depthpixperline >> 6;\r\n}\r\n}\r\n}\r\nif ((dev_priv->flags & RADEON_HAS_HIERZ)\r\n&& (dev_priv->microcode_version == UCODE_R200)\r\n&& (flags & RADEON_USE_HIERZ))\r\n{\r\nBEGIN_RING(4);\r\nOUT_RING(CP_PACKET3(RADEON_3D_CLEAR_HIZ, 2));\r\nOUT_RING(0x0);\r\nOUT_RING(0x3cc0);\r\nOUT_RING((0xff << 22) | (0xff << 6) | 0x003f003f);\r\nADVANCE_RING();\r\n}\r\n}\r\nelse if ((dev_priv->microcode_version == UCODE_R200) &&\r\n(flags & (RADEON_DEPTH | RADEON_STENCIL))) {\r\nint tempPP_CNTL;\r\nint tempRE_CNTL;\r\nint tempRB3D_CNTL;\r\nint tempRB3D_ZSTENCILCNTL;\r\nint tempRB3D_STENCILREFMASK;\r\nint tempRB3D_PLANEMASK;\r\nint tempSE_CNTL;\r\nint tempSE_VTE_CNTL;\r\nint tempSE_VTX_FMT_0;\r\nint tempSE_VTX_FMT_1;\r\nint tempSE_VAP_CNTL;\r\nint tempRE_AUX_SCISSOR_CNTL;\r\ntempPP_CNTL = 0;\r\ntempRE_CNTL = 0;\r\ntempRB3D_CNTL = depth_clear->rb3d_cntl;\r\ntempRB3D_ZSTENCILCNTL = depth_clear->rb3d_zstencilcntl;\r\ntempRB3D_STENCILREFMASK = 0x0;\r\ntempSE_CNTL = depth_clear->se_cntl;\r\ntempSE_VAP_CNTL = (\r\n(0x9 <<\r\nSE_VAP_CNTL__VF_MAX_VTX_NUM__SHIFT));\r\ntempRB3D_PLANEMASK = 0x0;\r\ntempRE_AUX_SCISSOR_CNTL = 0x0;\r\ntempSE_VTE_CNTL =\r\nSE_VTE_CNTL__VTX_XY_FMT_MASK | SE_VTE_CNTL__VTX_Z_FMT_MASK;\r\ntempSE_VTX_FMT_0 =\r\nSE_VTX_FMT_0__VTX_Z0_PRESENT_MASK |\r\nSE_VTX_FMT_0__VTX_W0_PRESENT_MASK;\r\ntempSE_VTX_FMT_1 = 0x0;\r\nif (flags & RADEON_DEPTH) {\r\ntempRB3D_CNTL |= RADEON_Z_ENABLE;\r\n} else {\r\ntempRB3D_CNTL &= ~RADEON_Z_ENABLE;\r\n}\r\nif (flags & RADEON_STENCIL) {\r\ntempRB3D_CNTL |= RADEON_STENCIL_ENABLE;\r\ntempRB3D_STENCILREFMASK = clear->depth_mask;\r\n} else {\r\ntempRB3D_CNTL &= ~RADEON_STENCIL_ENABLE;\r\ntempRB3D_STENCILREFMASK = 0x00000000;\r\n}\r\nif (flags & RADEON_USE_COMP_ZBUF) {\r\ntempRB3D_ZSTENCILCNTL |= RADEON_Z_COMPRESSION_ENABLE |\r\nRADEON_Z_DECOMPRESSION_ENABLE;\r\n}\r\nif (flags & RADEON_USE_HIERZ) {\r\ntempRB3D_ZSTENCILCNTL |= RADEON_Z_HIERARCHY_ENABLE;\r\n}\r\nBEGIN_RING(26);\r\nRADEON_WAIT_UNTIL_2D_IDLE();\r\nOUT_RING_REG(RADEON_PP_CNTL, tempPP_CNTL);\r\nOUT_RING_REG(R200_RE_CNTL, tempRE_CNTL);\r\nOUT_RING_REG(RADEON_RB3D_CNTL, tempRB3D_CNTL);\r\nOUT_RING_REG(RADEON_RB3D_ZSTENCILCNTL, tempRB3D_ZSTENCILCNTL);\r\nOUT_RING_REG(RADEON_RB3D_STENCILREFMASK,\r\ntempRB3D_STENCILREFMASK);\r\nOUT_RING_REG(RADEON_RB3D_PLANEMASK, tempRB3D_PLANEMASK);\r\nOUT_RING_REG(RADEON_SE_CNTL, tempSE_CNTL);\r\nOUT_RING_REG(R200_SE_VTE_CNTL, tempSE_VTE_CNTL);\r\nOUT_RING_REG(R200_SE_VTX_FMT_0, tempSE_VTX_FMT_0);\r\nOUT_RING_REG(R200_SE_VTX_FMT_1, tempSE_VTX_FMT_1);\r\nOUT_RING_REG(R200_SE_VAP_CNTL, tempSE_VAP_CNTL);\r\nOUT_RING_REG(R200_RE_AUX_SCISSOR_CNTL, tempRE_AUX_SCISSOR_CNTL);\r\nADVANCE_RING();\r\nsarea_priv->ctx_owner = 0;\r\nfor (i = 0; i < nbox; i++) {\r\nradeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);\r\nBEGIN_RING(14);\r\nOUT_RING(CP_PACKET3(R200_3D_DRAW_IMMD_2, 12));\r\nOUT_RING((RADEON_PRIM_TYPE_RECT_LIST |\r\nRADEON_PRIM_WALK_RING |\r\n(3 << RADEON_NUM_VERTICES_SHIFT)));\r\nOUT_RING(depth_boxes[i].ui[CLEAR_X1]);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_Y1]);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);\r\nOUT_RING(0x3f800000);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_X1]);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_Y2]);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);\r\nOUT_RING(0x3f800000);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_X2]);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_Y2]);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);\r\nOUT_RING(0x3f800000);\r\nADVANCE_RING();\r\n}\r\n} else if ((flags & (RADEON_DEPTH | RADEON_STENCIL))) {\r\nint tempRB3D_ZSTENCILCNTL = depth_clear->rb3d_zstencilcntl;\r\nrb3d_cntl = depth_clear->rb3d_cntl;\r\nif (flags & RADEON_DEPTH) {\r\nrb3d_cntl |= RADEON_Z_ENABLE;\r\n} else {\r\nrb3d_cntl &= ~RADEON_Z_ENABLE;\r\n}\r\nif (flags & RADEON_STENCIL) {\r\nrb3d_cntl |= RADEON_STENCIL_ENABLE;\r\nrb3d_stencilrefmask = clear->depth_mask;\r\n} else {\r\nrb3d_cntl &= ~RADEON_STENCIL_ENABLE;\r\nrb3d_stencilrefmask = 0x00000000;\r\n}\r\nif (flags & RADEON_USE_COMP_ZBUF) {\r\ntempRB3D_ZSTENCILCNTL |= RADEON_Z_COMPRESSION_ENABLE |\r\nRADEON_Z_DECOMPRESSION_ENABLE;\r\n}\r\nif (flags & RADEON_USE_HIERZ) {\r\ntempRB3D_ZSTENCILCNTL |= RADEON_Z_HIERARCHY_ENABLE;\r\n}\r\nBEGIN_RING(13);\r\nRADEON_WAIT_UNTIL_2D_IDLE();\r\nOUT_RING(CP_PACKET0(RADEON_PP_CNTL, 1));\r\nOUT_RING(0x00000000);\r\nOUT_RING(rb3d_cntl);\r\nOUT_RING_REG(RADEON_RB3D_ZSTENCILCNTL, tempRB3D_ZSTENCILCNTL);\r\nOUT_RING_REG(RADEON_RB3D_STENCILREFMASK, rb3d_stencilrefmask);\r\nOUT_RING_REG(RADEON_RB3D_PLANEMASK, 0x00000000);\r\nOUT_RING_REG(RADEON_SE_CNTL, depth_clear->se_cntl);\r\nADVANCE_RING();\r\nsarea_priv->ctx_owner = 0;\r\nfor (i = 0; i < nbox; i++) {\r\nradeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);\r\nBEGIN_RING(15);\r\nOUT_RING(CP_PACKET3(RADEON_3D_DRAW_IMMD, 13));\r\nOUT_RING(RADEON_VTX_Z_PRESENT |\r\nRADEON_VTX_PKCOLOR_PRESENT);\r\nOUT_RING((RADEON_PRIM_TYPE_RECT_LIST |\r\nRADEON_PRIM_WALK_RING |\r\nRADEON_MAOS_ENABLE |\r\nRADEON_VTX_FMT_RADEON_MODE |\r\n(3 << RADEON_NUM_VERTICES_SHIFT)));\r\nOUT_RING(depth_boxes[i].ui[CLEAR_X1]);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_Y1]);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);\r\nOUT_RING(0x0);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_X1]);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_Y2]);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);\r\nOUT_RING(0x0);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_X2]);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_Y2]);\r\nOUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);\r\nOUT_RING(0x0);\r\nADVANCE_RING();\r\n}\r\n}\r\nsarea_priv->last_clear++;\r\nBEGIN_RING(4);\r\nRADEON_CLEAR_AGE(sarea_priv->last_clear);\r\nRADEON_WAIT_UNTIL_IDLE();\r\nADVANCE_RING();\r\n}\r\nstatic void radeon_cp_dispatch_swap(struct drm_device *dev, struct drm_master *master)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = master->driver_priv;\r\ndrm_radeon_sarea_t *sarea_priv = master_priv->sarea_priv;\r\nint nbox = sarea_priv->nbox;\r\nstruct drm_clip_rect *pbox = sarea_priv->boxes;\r\nint i;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nif (dev_priv->do_boxes)\r\nradeon_cp_performance_boxes(dev_priv, master_priv);\r\nBEGIN_RING(2);\r\nRADEON_WAIT_UNTIL_3D_IDLE();\r\nADVANCE_RING();\r\nfor (i = 0; i < nbox; i++) {\r\nint x = pbox[i].x1;\r\nint y = pbox[i].y1;\r\nint w = pbox[i].x2 - x;\r\nint h = pbox[i].y2 - y;\r\nDRM_DEBUG("%d,%d-%d,%d\n", x, y, w, h);\r\nBEGIN_RING(9);\r\nOUT_RING(CP_PACKET0(RADEON_DP_GUI_MASTER_CNTL, 0));\r\nOUT_RING(RADEON_GMC_SRC_PITCH_OFFSET_CNTL |\r\nRADEON_GMC_DST_PITCH_OFFSET_CNTL |\r\nRADEON_GMC_BRUSH_NONE |\r\n(dev_priv->color_fmt << 8) |\r\nRADEON_GMC_SRC_DATATYPE_COLOR |\r\nRADEON_ROP3_S |\r\nRADEON_DP_SRC_SOURCE_MEMORY |\r\nRADEON_GMC_CLR_CMP_CNTL_DIS | RADEON_GMC_WR_MSK_DIS);\r\nOUT_RING(CP_PACKET0(RADEON_SRC_PITCH_OFFSET, 1));\r\nif (sarea_priv->pfCurrentPage == 0) {\r\nOUT_RING(dev_priv->back_pitch_offset);\r\nOUT_RING(dev_priv->front_pitch_offset);\r\n} else {\r\nOUT_RING(dev_priv->front_pitch_offset);\r\nOUT_RING(dev_priv->back_pitch_offset);\r\n}\r\nOUT_RING(CP_PACKET0(RADEON_SRC_X_Y, 2));\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((x << 16) | y);\r\nOUT_RING((w << 16) | h);\r\nADVANCE_RING();\r\n}\r\nsarea_priv->last_frame++;\r\nBEGIN_RING(4);\r\nRADEON_FRAME_AGE(sarea_priv->last_frame);\r\nRADEON_WAIT_UNTIL_2D_IDLE();\r\nADVANCE_RING();\r\n}\r\nvoid radeon_cp_dispatch_flip(struct drm_device *dev, struct drm_master *master)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = master->driver_priv;\r\nstruct drm_sarea *sarea = (struct drm_sarea *)master_priv->sarea->handle;\r\nint offset = (master_priv->sarea_priv->pfCurrentPage == 1)\r\n? dev_priv->front_offset : dev_priv->back_offset;\r\nRING_LOCALS;\r\nDRM_DEBUG("pfCurrentPage=%d\n",\r\nmaster_priv->sarea_priv->pfCurrentPage);\r\nif (dev_priv->do_boxes) {\r\ndev_priv->stats.boxes |= RADEON_BOX_FLIP;\r\nradeon_cp_performance_boxes(dev_priv, master_priv);\r\n}\r\nBEGIN_RING(6);\r\nRADEON_WAIT_UNTIL_3D_IDLE();\r\nOUT_RING_REG(RADEON_CRTC_OFFSET,\r\n((sarea->frame.y * dev_priv->front_pitch +\r\nsarea->frame.x * (dev_priv->color_fmt - 2)) & ~7)\r\n+ offset);\r\nOUT_RING_REG(RADEON_CRTC2_OFFSET, master_priv->sarea_priv->crtc2_base\r\n+ offset);\r\nADVANCE_RING();\r\nmaster_priv->sarea_priv->last_frame++;\r\nmaster_priv->sarea_priv->pfCurrentPage =\r\n1 - master_priv->sarea_priv->pfCurrentPage;\r\nBEGIN_RING(2);\r\nRADEON_FRAME_AGE(master_priv->sarea_priv->last_frame);\r\nADVANCE_RING();\r\n}\r\nstatic int bad_prim_vertex_nr(int primitive, int nr)\r\n{\r\nswitch (primitive & RADEON_PRIM_TYPE_MASK) {\r\ncase RADEON_PRIM_TYPE_NONE:\r\ncase RADEON_PRIM_TYPE_POINT:\r\nreturn nr < 1;\r\ncase RADEON_PRIM_TYPE_LINE:\r\nreturn (nr & 1) || nr == 0;\r\ncase RADEON_PRIM_TYPE_LINE_STRIP:\r\nreturn nr < 2;\r\ncase RADEON_PRIM_TYPE_TRI_LIST:\r\ncase RADEON_PRIM_TYPE_3VRT_POINT_LIST:\r\ncase RADEON_PRIM_TYPE_3VRT_LINE_LIST:\r\ncase RADEON_PRIM_TYPE_RECT_LIST:\r\nreturn nr % 3 || nr == 0;\r\ncase RADEON_PRIM_TYPE_TRI_FAN:\r\ncase RADEON_PRIM_TYPE_TRI_STRIP:\r\nreturn nr < 3;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic void radeon_cp_dispatch_vertex(struct drm_device * dev,\r\nstruct drm_file *file_priv,\r\nstruct drm_buf * buf,\r\ndrm_radeon_tcl_prim_t * prim)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = file_priv->master->driver_priv;\r\ndrm_radeon_sarea_t *sarea_priv = master_priv->sarea_priv;\r\nint offset = dev_priv->gart_buffers_offset + buf->offset + prim->start;\r\nint numverts = (int)prim->numverts;\r\nint nbox = sarea_priv->nbox;\r\nint i = 0;\r\nRING_LOCALS;\r\nDRM_DEBUG("hwprim 0x%x vfmt 0x%x %d..%d %d verts\n",\r\nprim->prim,\r\nprim->vc_format, prim->start, prim->finish, prim->numverts);\r\nif (bad_prim_vertex_nr(prim->prim, prim->numverts)) {\r\nDRM_ERROR("bad prim %x numverts %d\n",\r\nprim->prim, prim->numverts);\r\nreturn;\r\n}\r\ndo {\r\nif (i < nbox) {\r\nradeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);\r\n}\r\nBEGIN_RING(5);\r\nOUT_RING(CP_PACKET3(RADEON_3D_RNDR_GEN_INDX_PRIM, 3));\r\nOUT_RING(offset);\r\nOUT_RING(numverts);\r\nOUT_RING(prim->vc_format);\r\nOUT_RING(prim->prim | RADEON_PRIM_WALK_LIST |\r\nRADEON_COLOR_ORDER_RGBA |\r\nRADEON_VTX_FMT_RADEON_MODE |\r\n(numverts << RADEON_NUM_VERTICES_SHIFT));\r\nADVANCE_RING();\r\ni++;\r\n} while (i < nbox);\r\n}\r\nvoid radeon_cp_discard_buffer(struct drm_device *dev, struct drm_master *master, struct drm_buf *buf)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = master->driver_priv;\r\ndrm_radeon_buf_priv_t *buf_priv = buf->dev_private;\r\nRING_LOCALS;\r\nbuf_priv->age = ++master_priv->sarea_priv->last_dispatch;\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_R600) {\r\nBEGIN_RING(3);\r\nR600_DISPATCH_AGE(buf_priv->age);\r\nADVANCE_RING();\r\n} else {\r\nBEGIN_RING(2);\r\nRADEON_DISPATCH_AGE(buf_priv->age);\r\nADVANCE_RING();\r\n}\r\nbuf->pending = 1;\r\nbuf->used = 0;\r\n}\r\nstatic void radeon_cp_dispatch_indirect(struct drm_device * dev,\r\nstruct drm_buf * buf, int start, int end)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nRING_LOCALS;\r\nDRM_DEBUG("buf=%d s=0x%x e=0x%x\n", buf->idx, start, end);\r\nif (start != end) {\r\nint offset = (dev_priv->gart_buffers_offset\r\n+ buf->offset + start);\r\nint dwords = (end - start + 3) / sizeof(u32);\r\nif (dwords & 1) {\r\nu32 *data = (u32 *)\r\n((char *)dev->agp_buffer_map->handle\r\n+ buf->offset + start);\r\ndata[dwords++] = RADEON_CP_PACKET2;\r\n}\r\nBEGIN_RING(3);\r\nOUT_RING(CP_PACKET0(RADEON_CP_IB_BASE, 1));\r\nOUT_RING(offset);\r\nOUT_RING(dwords);\r\nADVANCE_RING();\r\n}\r\n}\r\nstatic void radeon_cp_dispatch_indices(struct drm_device *dev,\r\nstruct drm_master *master,\r\nstruct drm_buf * elt_buf,\r\ndrm_radeon_tcl_prim_t * prim)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = master->driver_priv;\r\ndrm_radeon_sarea_t *sarea_priv = master_priv->sarea_priv;\r\nint offset = dev_priv->gart_buffers_offset + prim->offset;\r\nu32 *data;\r\nint dwords;\r\nint i = 0;\r\nint start = prim->start + RADEON_INDEX_PRIM_OFFSET;\r\nint count = (prim->finish - start) / sizeof(u16);\r\nint nbox = sarea_priv->nbox;\r\nDRM_DEBUG("hwprim 0x%x vfmt 0x%x %d..%d offset: %x nr %d\n",\r\nprim->prim,\r\nprim->vc_format,\r\nprim->start, prim->finish, prim->offset, prim->numverts);\r\nif (bad_prim_vertex_nr(prim->prim, count)) {\r\nDRM_ERROR("bad prim %x count %d\n", prim->prim, count);\r\nreturn;\r\n}\r\nif (start >= prim->finish || (prim->start & 0x7)) {\r\nDRM_ERROR("buffer prim %d\n", prim->prim);\r\nreturn;\r\n}\r\ndwords = (prim->finish - prim->start + 3) / sizeof(u32);\r\ndata = (u32 *) ((char *)dev->agp_buffer_map->handle +\r\nelt_buf->offset + prim->start);\r\ndata[0] = CP_PACKET3(RADEON_3D_RNDR_GEN_INDX_PRIM, dwords - 2);\r\ndata[1] = offset;\r\ndata[2] = prim->numverts;\r\ndata[3] = prim->vc_format;\r\ndata[4] = (prim->prim |\r\nRADEON_PRIM_WALK_IND |\r\nRADEON_COLOR_ORDER_RGBA |\r\nRADEON_VTX_FMT_RADEON_MODE |\r\n(count << RADEON_NUM_VERTICES_SHIFT));\r\ndo {\r\nif (i < nbox)\r\nradeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);\r\nradeon_cp_dispatch_indirect(dev, elt_buf,\r\nprim->start, prim->finish);\r\ni++;\r\n} while (i < nbox);\r\n}\r\nstatic int radeon_cp_dispatch_texture(struct drm_device * dev,\r\nstruct drm_file *file_priv,\r\ndrm_radeon_texture_t * tex,\r\ndrm_radeon_tex_image_t * image)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_buf *buf;\r\nu32 format;\r\nu32 *buffer;\r\nconst u8 __user *data;\r\nint size, dwords, tex_width, blit_width, spitch;\r\nu32 height;\r\nint i;\r\nu32 texpitch, microtile;\r\nu32 offset, byte_offset;\r\nRING_LOCALS;\r\nif (radeon_check_and_fixup_offset(dev_priv, file_priv, &tex->offset)) {\r\nDRM_ERROR("Invalid destination offset\n");\r\nreturn -EINVAL;\r\n}\r\ndev_priv->stats.boxes |= RADEON_BOX_TEXTURE_LOAD;\r\nBEGIN_RING(4);\r\nRADEON_FLUSH_CACHE();\r\nRADEON_WAIT_UNTIL_IDLE();\r\nADVANCE_RING();\r\nswitch (tex->format) {\r\ncase RADEON_TXFORMAT_ARGB8888:\r\ncase RADEON_TXFORMAT_RGBA8888:\r\nformat = RADEON_COLOR_FORMAT_ARGB8888;\r\ntex_width = tex->width * 4;\r\nblit_width = image->width * 4;\r\nbreak;\r\ncase RADEON_TXFORMAT_AI88:\r\ncase RADEON_TXFORMAT_ARGB1555:\r\ncase RADEON_TXFORMAT_RGB565:\r\ncase RADEON_TXFORMAT_ARGB4444:\r\ncase RADEON_TXFORMAT_VYUY422:\r\ncase RADEON_TXFORMAT_YVYU422:\r\nformat = RADEON_COLOR_FORMAT_RGB565;\r\ntex_width = tex->width * 2;\r\nblit_width = image->width * 2;\r\nbreak;\r\ncase RADEON_TXFORMAT_I8:\r\ncase RADEON_TXFORMAT_RGB332:\r\nformat = RADEON_COLOR_FORMAT_CI8;\r\ntex_width = tex->width * 1;\r\nblit_width = image->width * 1;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid texture format %d\n", tex->format);\r\nreturn -EINVAL;\r\n}\r\nspitch = blit_width >> 6;\r\nif (spitch == 0 && image->height > 1)\r\nreturn -EINVAL;\r\ntexpitch = tex->pitch;\r\nif ((texpitch << 22) & RADEON_DST_TILE_MICRO) {\r\nmicrotile = 1;\r\nif (tex_width < 64) {\r\ntexpitch &= ~(RADEON_DST_TILE_MICRO >> 22);\r\nimage->x *= 2;\r\n}\r\n} else\r\nmicrotile = 0;\r\nif (!radeon_check_offset(dev_priv, tex->offset + image->height *\r\nblit_width - 1)) {\r\nDRM_ERROR("Invalid final destination offset\n");\r\nreturn -EINVAL;\r\n}\r\nDRM_DEBUG("tex=%dx%d blit=%d\n", tex_width, tex->height, blit_width);\r\ndo {\r\nDRM_DEBUG("tex: ofs=0x%x p=%d f=%d x=%hd y=%hd w=%hd h=%hd\n",\r\ntex->offset >> 10, tex->pitch, tex->format,\r\nimage->x, image->y, image->width, image->height);\r\nheight = image->height;\r\ndata = (const u8 __user *)image->data;\r\nsize = height * blit_width;\r\nif (size > RADEON_MAX_TEXTURE_SIZE) {\r\nheight = RADEON_MAX_TEXTURE_SIZE / blit_width;\r\nsize = height * blit_width;\r\n} else if (size < 4 && size > 0) {\r\nsize = 4;\r\n} else if (size == 0) {\r\nreturn 0;\r\n}\r\nbuf = radeon_freelist_get(dev);\r\nif (0 && !buf) {\r\nradeon_do_cp_idle(dev_priv);\r\nbuf = radeon_freelist_get(dev);\r\n}\r\nif (!buf) {\r\nDRM_DEBUG("EAGAIN\n");\r\nif (copy_to_user(tex->image, image, sizeof(*image)))\r\nreturn -EFAULT;\r\nreturn -EAGAIN;\r\n}\r\nbuffer =\r\n(u32 *) ((char *)dev->agp_buffer_map->handle + buf->offset);\r\ndwords = size / 4;\r\n#define RADEON_COPY_MT(_buf, _data, _width) \\r\ndo { \\r\nif (copy_from_user(_buf, _data, (_width))) {\\r\nDRM_ERROR("EFAULT on pad, %d bytes\n", (_width)); \\r\nreturn -EFAULT; \\r\n} \\r\n} while(0)\r\nif (microtile) {\r\nif (tex->height == 1) {\r\nif (tex_width >= 64 || tex_width <= 16) {\r\nRADEON_COPY_MT(buffer, data,\r\n(int)(tex_width * sizeof(u32)));\r\n} else if (tex_width == 32) {\r\nRADEON_COPY_MT(buffer, data, 16);\r\nRADEON_COPY_MT(buffer + 8,\r\ndata + 16, 16);\r\n}\r\n} else if (tex_width >= 64 || tex_width == 16) {\r\nRADEON_COPY_MT(buffer, data,\r\n(int)(dwords * sizeof(u32)));\r\n} else if (tex_width < 16) {\r\nfor (i = 0; i < tex->height; i++) {\r\nRADEON_COPY_MT(buffer, data, tex_width);\r\nbuffer += 4;\r\ndata += tex_width;\r\n}\r\n} else if (tex_width == 32) {\r\nfor (i = 0; i < tex->height; i += 2) {\r\nRADEON_COPY_MT(buffer, data, 16);\r\ndata += 16;\r\nRADEON_COPY_MT(buffer + 8, data, 16);\r\ndata += 16;\r\nRADEON_COPY_MT(buffer + 4, data, 16);\r\ndata += 16;\r\nRADEON_COPY_MT(buffer + 12, data, 16);\r\ndata += 16;\r\nbuffer += 16;\r\n}\r\n}\r\n} else {\r\nif (tex_width >= 32) {\r\nRADEON_COPY_MT(buffer, data,\r\n(int)(dwords * sizeof(u32)));\r\n} else {\r\nfor (i = 0; i < tex->height; i++) {\r\nRADEON_COPY_MT(buffer, data, tex_width);\r\nbuffer += 8;\r\ndata += tex_width;\r\n}\r\n}\r\n}\r\n#undef RADEON_COPY_MT\r\nbyte_offset = (image->y & ~2047) * blit_width;\r\nbuf->file_priv = file_priv;\r\nbuf->used = size;\r\noffset = dev_priv->gart_buffers_offset + buf->offset;\r\nBEGIN_RING(9);\r\nOUT_RING(CP_PACKET3(RADEON_CNTL_BITBLT_MULTI, 5));\r\nOUT_RING(RADEON_GMC_SRC_PITCH_OFFSET_CNTL |\r\nRADEON_GMC_DST_PITCH_OFFSET_CNTL |\r\nRADEON_GMC_BRUSH_NONE |\r\n(format << 8) |\r\nRADEON_GMC_SRC_DATATYPE_COLOR |\r\nRADEON_ROP3_S |\r\nRADEON_DP_SRC_SOURCE_MEMORY |\r\nRADEON_GMC_CLR_CMP_CNTL_DIS | RADEON_GMC_WR_MSK_DIS);\r\nOUT_RING((spitch << 22) | (offset >> 10));\r\nOUT_RING((texpitch << 22) | ((tex->offset >> 10) + (byte_offset >> 10)));\r\nOUT_RING(0);\r\nOUT_RING((image->x << 16) | (image->y % 2048));\r\nOUT_RING((image->width << 16) | height);\r\nRADEON_WAIT_UNTIL_2D_IDLE();\r\nADVANCE_RING();\r\nCOMMIT_RING();\r\nradeon_cp_discard_buffer(dev, file_priv->master, buf);\r\nimage->y += height;\r\nimage->height -= height;\r\nimage->data = (const u8 __user *)image->data + size;\r\n} while (image->height > 0);\r\nBEGIN_RING(4);\r\nRADEON_FLUSH_CACHE();\r\nRADEON_WAIT_UNTIL_2D_IDLE();\r\nADVANCE_RING();\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic void radeon_cp_dispatch_stipple(struct drm_device * dev, u32 * stipple)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nint i;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_RING(35);\r\nOUT_RING(CP_PACKET0(RADEON_RE_STIPPLE_ADDR, 0));\r\nOUT_RING(0x00000000);\r\nOUT_RING(CP_PACKET0_TABLE(RADEON_RE_STIPPLE_DATA, 31));\r\nfor (i = 0; i < 32; i++) {\r\nOUT_RING(stipple[i]);\r\n}\r\nADVANCE_RING();\r\n}\r\nstatic void radeon_apply_surface_regs(int surf_index,\r\ndrm_radeon_private_t *dev_priv)\r\n{\r\nif (!dev_priv->mmio)\r\nreturn;\r\nradeon_do_cp_idle(dev_priv);\r\nRADEON_WRITE(RADEON_SURFACE0_INFO + 16 * surf_index,\r\ndev_priv->surfaces[surf_index].flags);\r\nRADEON_WRITE(RADEON_SURFACE0_LOWER_BOUND + 16 * surf_index,\r\ndev_priv->surfaces[surf_index].lower);\r\nRADEON_WRITE(RADEON_SURFACE0_UPPER_BOUND + 16 * surf_index,\r\ndev_priv->surfaces[surf_index].upper);\r\n}\r\nstatic int alloc_surface(drm_radeon_surface_alloc_t *new,\r\ndrm_radeon_private_t *dev_priv,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct radeon_virt_surface *s;\r\nint i;\r\nint virt_surface_index;\r\nuint32_t new_upper, new_lower;\r\nnew_lower = new->address;\r\nnew_upper = new_lower + new->size - 1;\r\nif ((new_lower >= new_upper) || (new->flags == 0) || (new->size == 0) ||\r\n((new_upper & RADEON_SURF_ADDRESS_FIXED_MASK) !=\r\nRADEON_SURF_ADDRESS_FIXED_MASK)\r\n|| ((new_lower & RADEON_SURF_ADDRESS_FIXED_MASK) != 0))\r\nreturn -1;\r\nfor (i = 0; i < RADEON_MAX_SURFACES; i++) {\r\nif ((dev_priv->surfaces[i].refcount != 0) &&\r\n(((new_lower >= dev_priv->surfaces[i].lower) &&\r\n(new_lower < dev_priv->surfaces[i].upper)) ||\r\n((new_lower < dev_priv->surfaces[i].lower) &&\r\n(new_upper > dev_priv->surfaces[i].lower)))) {\r\nreturn -1;\r\n}\r\n}\r\nfor (i = 0; i < 2 * RADEON_MAX_SURFACES; i++)\r\nif (dev_priv->virt_surfaces[i].file_priv == NULL)\r\nbreak;\r\nif (i == 2 * RADEON_MAX_SURFACES) {\r\nreturn -1;\r\n}\r\nvirt_surface_index = i;\r\nfor (i = 0; i < RADEON_MAX_SURFACES; i++) {\r\nif ((dev_priv->surfaces[i].refcount == 1) &&\r\n(new->flags == dev_priv->surfaces[i].flags) &&\r\n(new_upper + 1 == dev_priv->surfaces[i].lower)) {\r\ns = &(dev_priv->virt_surfaces[virt_surface_index]);\r\ns->surface_index = i;\r\ns->lower = new_lower;\r\ns->upper = new_upper;\r\ns->flags = new->flags;\r\ns->file_priv = file_priv;\r\ndev_priv->surfaces[i].refcount++;\r\ndev_priv->surfaces[i].lower = s->lower;\r\nradeon_apply_surface_regs(s->surface_index, dev_priv);\r\nreturn virt_surface_index;\r\n}\r\nif ((dev_priv->surfaces[i].refcount == 1) &&\r\n(new->flags == dev_priv->surfaces[i].flags) &&\r\n(new_lower == dev_priv->surfaces[i].upper + 1)) {\r\ns = &(dev_priv->virt_surfaces[virt_surface_index]);\r\ns->surface_index = i;\r\ns->lower = new_lower;\r\ns->upper = new_upper;\r\ns->flags = new->flags;\r\ns->file_priv = file_priv;\r\ndev_priv->surfaces[i].refcount++;\r\ndev_priv->surfaces[i].upper = s->upper;\r\nradeon_apply_surface_regs(s->surface_index, dev_priv);\r\nreturn virt_surface_index;\r\n}\r\n}\r\nfor (i = 0; i < RADEON_MAX_SURFACES; i++) {\r\nif (dev_priv->surfaces[i].refcount == 0) {\r\ns = &(dev_priv->virt_surfaces[virt_surface_index]);\r\ns->surface_index = i;\r\ns->lower = new_lower;\r\ns->upper = new_upper;\r\ns->flags = new->flags;\r\ns->file_priv = file_priv;\r\ndev_priv->surfaces[i].refcount = 1;\r\ndev_priv->surfaces[i].lower = s->lower;\r\ndev_priv->surfaces[i].upper = s->upper;\r\ndev_priv->surfaces[i].flags = s->flags;\r\nradeon_apply_surface_regs(s->surface_index, dev_priv);\r\nreturn virt_surface_index;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int free_surface(struct drm_file *file_priv,\r\ndrm_radeon_private_t * dev_priv,\r\nint lower)\r\n{\r\nstruct radeon_virt_surface *s;\r\nint i;\r\nfor (i = 0; i < 2 * RADEON_MAX_SURFACES; i++) {\r\ns = &(dev_priv->virt_surfaces[i]);\r\nif (s->file_priv) {\r\nif ((lower == s->lower) && (file_priv == s->file_priv))\r\n{\r\nif (dev_priv->surfaces[s->surface_index].\r\nlower == s->lower)\r\ndev_priv->surfaces[s->surface_index].\r\nlower = s->upper;\r\nif (dev_priv->surfaces[s->surface_index].\r\nupper == s->upper)\r\ndev_priv->surfaces[s->surface_index].\r\nupper = s->lower;\r\ndev_priv->surfaces[s->surface_index].refcount--;\r\nif (dev_priv->surfaces[s->surface_index].\r\nrefcount == 0)\r\ndev_priv->surfaces[s->surface_index].\r\nflags = 0;\r\ns->file_priv = NULL;\r\nradeon_apply_surface_regs(s->surface_index,\r\ndev_priv);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void radeon_surfaces_release(struct drm_file *file_priv,\r\ndrm_radeon_private_t * dev_priv)\r\n{\r\nint i;\r\nfor (i = 0; i < 2 * RADEON_MAX_SURFACES; i++) {\r\nif (dev_priv->virt_surfaces[i].file_priv == file_priv)\r\nfree_surface(file_priv, dev_priv,\r\ndev_priv->virt_surfaces[i].lower);\r\n}\r\n}\r\nstatic int radeon_surface_alloc(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\ndrm_radeon_surface_alloc_t *alloc = data;\r\nif (alloc_surface(alloc, dev_priv, file_priv) == -1)\r\nreturn -EINVAL;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int radeon_surface_free(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\ndrm_radeon_surface_free_t *memfree = data;\r\nif (free_surface(file_priv, dev_priv, memfree->address))\r\nreturn -EINVAL;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int radeon_cp_clear(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = file_priv->master->driver_priv;\r\ndrm_radeon_sarea_t *sarea_priv = master_priv->sarea_priv;\r\ndrm_radeon_clear_t *clear = data;\r\ndrm_radeon_clear_rect_t depth_boxes[RADEON_NR_SAREA_CLIPRECTS];\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nif (sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS)\r\nsarea_priv->nbox = RADEON_NR_SAREA_CLIPRECTS;\r\nif (copy_from_user(&depth_boxes, clear->depth_boxes,\r\nsarea_priv->nbox * sizeof(depth_boxes[0])))\r\nreturn -EFAULT;\r\nradeon_cp_dispatch_clear(dev, file_priv->master, clear, depth_boxes);\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int radeon_do_init_pageflip(struct drm_device *dev, struct drm_master *master)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = master->driver_priv;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_RING(6);\r\nRADEON_WAIT_UNTIL_3D_IDLE();\r\nOUT_RING(CP_PACKET0(RADEON_CRTC_OFFSET_CNTL, 0));\r\nOUT_RING(RADEON_READ(RADEON_CRTC_OFFSET_CNTL) |\r\nRADEON_CRTC_OFFSET_FLIP_CNTL);\r\nOUT_RING(CP_PACKET0(RADEON_CRTC2_OFFSET_CNTL, 0));\r\nOUT_RING(RADEON_READ(RADEON_CRTC2_OFFSET_CNTL) |\r\nRADEON_CRTC_OFFSET_FLIP_CNTL);\r\nADVANCE_RING();\r\ndev_priv->page_flipping = 1;\r\nif (master_priv->sarea_priv->pfCurrentPage != 1)\r\nmaster_priv->sarea_priv->pfCurrentPage = 0;\r\nreturn 0;\r\n}\r\nstatic int radeon_cp_flip(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nif (!dev_priv->page_flipping)\r\nradeon_do_init_pageflip(dev, file_priv->master);\r\nradeon_cp_dispatch_flip(dev, file_priv->master);\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int radeon_cp_swap(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = file_priv->master->driver_priv;\r\ndrm_radeon_sarea_t *sarea_priv = master_priv->sarea_priv;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nif (sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS)\r\nsarea_priv->nbox = RADEON_NR_SAREA_CLIPRECTS;\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_R600)\r\nr600_cp_dispatch_swap(dev, file_priv);\r\nelse\r\nradeon_cp_dispatch_swap(dev, file_priv->master);\r\nsarea_priv->ctx_owner = 0;\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int radeon_cp_vertex(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = file_priv->master->driver_priv;\r\ndrm_radeon_sarea_t *sarea_priv;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf;\r\ndrm_radeon_vertex_t *vertex = data;\r\ndrm_radeon_tcl_prim_t prim;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nsarea_priv = master_priv->sarea_priv;\r\nDRM_DEBUG("pid=%d index=%d count=%d discard=%d\n",\r\nDRM_CURRENTPID, vertex->idx, vertex->count, vertex->discard);\r\nif (vertex->idx < 0 || vertex->idx >= dma->buf_count) {\r\nDRM_ERROR("buffer index %d (of %d max)\n",\r\nvertex->idx, dma->buf_count - 1);\r\nreturn -EINVAL;\r\n}\r\nif (vertex->prim < 0 || vertex->prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST) {\r\nDRM_ERROR("buffer prim %d\n", vertex->prim);\r\nreturn -EINVAL;\r\n}\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nVB_AGE_TEST_WITH_RETURN(dev_priv);\r\nbuf = dma->buflist[vertex->idx];\r\nif (buf->file_priv != file_priv) {\r\nDRM_ERROR("process %d using buffer owned by %p\n",\r\nDRM_CURRENTPID, buf->file_priv);\r\nreturn -EINVAL;\r\n}\r\nif (buf->pending) {\r\nDRM_ERROR("sending pending buffer %d\n", vertex->idx);\r\nreturn -EINVAL;\r\n}\r\nif (vertex->count) {\r\nbuf->used = vertex->count;\r\nif (sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS) {\r\nif (radeon_emit_state(dev_priv, file_priv,\r\n&sarea_priv->context_state,\r\nsarea_priv->tex_state,\r\nsarea_priv->dirty)) {\r\nDRM_ERROR("radeon_emit_state failed\n");\r\nreturn -EINVAL;\r\n}\r\nsarea_priv->dirty &= ~(RADEON_UPLOAD_TEX0IMAGES |\r\nRADEON_UPLOAD_TEX1IMAGES |\r\nRADEON_UPLOAD_TEX2IMAGES |\r\nRADEON_REQUIRE_QUIESCENCE);\r\n}\r\nprim.start = 0;\r\nprim.finish = vertex->count;\r\nprim.prim = vertex->prim;\r\nprim.numverts = vertex->count;\r\nprim.vc_format = sarea_priv->vc_format;\r\nradeon_cp_dispatch_vertex(dev, file_priv, buf, &prim);\r\n}\r\nif (vertex->discard) {\r\nradeon_cp_discard_buffer(dev, file_priv->master, buf);\r\n}\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int radeon_cp_indices(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = file_priv->master->driver_priv;\r\ndrm_radeon_sarea_t *sarea_priv;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf;\r\ndrm_radeon_indices_t *elts = data;\r\ndrm_radeon_tcl_prim_t prim;\r\nint count;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nsarea_priv = master_priv->sarea_priv;\r\nDRM_DEBUG("pid=%d index=%d start=%d end=%d discard=%d\n",\r\nDRM_CURRENTPID, elts->idx, elts->start, elts->end,\r\nelts->discard);\r\nif (elts->idx < 0 || elts->idx >= dma->buf_count) {\r\nDRM_ERROR("buffer index %d (of %d max)\n",\r\nelts->idx, dma->buf_count - 1);\r\nreturn -EINVAL;\r\n}\r\nif (elts->prim < 0 || elts->prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST) {\r\nDRM_ERROR("buffer prim %d\n", elts->prim);\r\nreturn -EINVAL;\r\n}\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nVB_AGE_TEST_WITH_RETURN(dev_priv);\r\nbuf = dma->buflist[elts->idx];\r\nif (buf->file_priv != file_priv) {\r\nDRM_ERROR("process %d using buffer owned by %p\n",\r\nDRM_CURRENTPID, buf->file_priv);\r\nreturn -EINVAL;\r\n}\r\nif (buf->pending) {\r\nDRM_ERROR("sending pending buffer %d\n", elts->idx);\r\nreturn -EINVAL;\r\n}\r\ncount = (elts->end - elts->start) / sizeof(u16);\r\nelts->start -= RADEON_INDEX_PRIM_OFFSET;\r\nif (elts->start & 0x7) {\r\nDRM_ERROR("misaligned buffer 0x%x\n", elts->start);\r\nreturn -EINVAL;\r\n}\r\nif (elts->start < buf->used) {\r\nDRM_ERROR("no header 0x%x - 0x%x\n", elts->start, buf->used);\r\nreturn -EINVAL;\r\n}\r\nbuf->used = elts->end;\r\nif (sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS) {\r\nif (radeon_emit_state(dev_priv, file_priv,\r\n&sarea_priv->context_state,\r\nsarea_priv->tex_state,\r\nsarea_priv->dirty)) {\r\nDRM_ERROR("radeon_emit_state failed\n");\r\nreturn -EINVAL;\r\n}\r\nsarea_priv->dirty &= ~(RADEON_UPLOAD_TEX0IMAGES |\r\nRADEON_UPLOAD_TEX1IMAGES |\r\nRADEON_UPLOAD_TEX2IMAGES |\r\nRADEON_REQUIRE_QUIESCENCE);\r\n}\r\nprim.start = elts->start;\r\nprim.finish = elts->end;\r\nprim.prim = elts->prim;\r\nprim.offset = 0;\r\nprim.numverts = RADEON_MAX_VB_VERTS;\r\nprim.vc_format = sarea_priv->vc_format;\r\nradeon_cp_dispatch_indices(dev, file_priv->master, buf, &prim);\r\nif (elts->discard) {\r\nradeon_cp_discard_buffer(dev, file_priv->master, buf);\r\n}\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int radeon_cp_texture(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\ndrm_radeon_texture_t *tex = data;\r\ndrm_radeon_tex_image_t image;\r\nint ret;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (tex->image == NULL) {\r\nDRM_ERROR("null texture image!\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&image,\r\n(drm_radeon_tex_image_t __user *) tex->image,\r\nsizeof(image)))\r\nreturn -EFAULT;\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nVB_AGE_TEST_WITH_RETURN(dev_priv);\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_R600)\r\nret = r600_cp_dispatch_texture(dev, file_priv, tex, &image);\r\nelse\r\nret = radeon_cp_dispatch_texture(dev, file_priv, tex, &image);\r\nreturn ret;\r\n}\r\nstatic int radeon_cp_stipple(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\ndrm_radeon_stipple_t *stipple = data;\r\nu32 mask[32];\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (copy_from_user(&mask, stipple->mask, 32 * sizeof(u32)))\r\nreturn -EFAULT;\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nradeon_cp_dispatch_stipple(dev, mask);\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int radeon_cp_indirect(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf;\r\ndrm_radeon_indirect_t *indirect = data;\r\nRING_LOCALS;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDRM_DEBUG("idx=%d s=%d e=%d d=%d\n",\r\nindirect->idx, indirect->start, indirect->end,\r\nindirect->discard);\r\nif (indirect->idx < 0 || indirect->idx >= dma->buf_count) {\r\nDRM_ERROR("buffer index %d (of %d max)\n",\r\nindirect->idx, dma->buf_count - 1);\r\nreturn -EINVAL;\r\n}\r\nbuf = dma->buflist[indirect->idx];\r\nif (buf->file_priv != file_priv) {\r\nDRM_ERROR("process %d using buffer owned by %p\n",\r\nDRM_CURRENTPID, buf->file_priv);\r\nreturn -EINVAL;\r\n}\r\nif (buf->pending) {\r\nDRM_ERROR("sending pending buffer %d\n", indirect->idx);\r\nreturn -EINVAL;\r\n}\r\nif (indirect->start < buf->used) {\r\nDRM_ERROR("reusing indirect: start=0x%x actual=0x%x\n",\r\nindirect->start, buf->used);\r\nreturn -EINVAL;\r\n}\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nVB_AGE_TEST_WITH_RETURN(dev_priv);\r\nbuf->used = indirect->end;\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_R600)\r\nr600_cp_dispatch_indirect(dev, buf, indirect->start, indirect->end);\r\nelse {\r\nBEGIN_RING(2);\r\nRADEON_WAIT_UNTIL_3D_IDLE();\r\nADVANCE_RING();\r\nradeon_cp_dispatch_indirect(dev, buf, indirect->start, indirect->end);\r\n}\r\nif (indirect->discard) {\r\nradeon_cp_discard_buffer(dev, file_priv->master, buf);\r\n}\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int radeon_cp_vertex2(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = file_priv->master->driver_priv;\r\ndrm_radeon_sarea_t *sarea_priv;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf;\r\ndrm_radeon_vertex2_t *vertex = data;\r\nint i;\r\nunsigned char laststate;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nsarea_priv = master_priv->sarea_priv;\r\nDRM_DEBUG("pid=%d index=%d discard=%d\n",\r\nDRM_CURRENTPID, vertex->idx, vertex->discard);\r\nif (vertex->idx < 0 || vertex->idx >= dma->buf_count) {\r\nDRM_ERROR("buffer index %d (of %d max)\n",\r\nvertex->idx, dma->buf_count - 1);\r\nreturn -EINVAL;\r\n}\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nVB_AGE_TEST_WITH_RETURN(dev_priv);\r\nbuf = dma->buflist[vertex->idx];\r\nif (buf->file_priv != file_priv) {\r\nDRM_ERROR("process %d using buffer owned by %p\n",\r\nDRM_CURRENTPID, buf->file_priv);\r\nreturn -EINVAL;\r\n}\r\nif (buf->pending) {\r\nDRM_ERROR("sending pending buffer %d\n", vertex->idx);\r\nreturn -EINVAL;\r\n}\r\nif (sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS)\r\nreturn -EINVAL;\r\nfor (laststate = 0xff, i = 0; i < vertex->nr_prims; i++) {\r\ndrm_radeon_prim_t prim;\r\ndrm_radeon_tcl_prim_t tclprim;\r\nif (copy_from_user(&prim, &vertex->prim[i], sizeof(prim)))\r\nreturn -EFAULT;\r\nif (prim.stateidx != laststate) {\r\ndrm_radeon_state_t state;\r\nif (copy_from_user(&state,\r\n&vertex->state[prim.stateidx],\r\nsizeof(state)))\r\nreturn -EFAULT;\r\nif (radeon_emit_state2(dev_priv, file_priv, &state)) {\r\nDRM_ERROR("radeon_emit_state2 failed\n");\r\nreturn -EINVAL;\r\n}\r\nlaststate = prim.stateidx;\r\n}\r\ntclprim.start = prim.start;\r\ntclprim.finish = prim.finish;\r\ntclprim.prim = prim.prim;\r\ntclprim.vc_format = prim.vc_format;\r\nif (prim.prim & RADEON_PRIM_WALK_IND) {\r\ntclprim.offset = prim.numverts * 64;\r\ntclprim.numverts = RADEON_MAX_VB_VERTS;\r\nradeon_cp_dispatch_indices(dev, file_priv->master, buf, &tclprim);\r\n} else {\r\ntclprim.numverts = prim.numverts;\r\ntclprim.offset = 0;\r\nradeon_cp_dispatch_vertex(dev, file_priv, buf, &tclprim);\r\n}\r\nif (sarea_priv->nbox == 1)\r\nsarea_priv->nbox = 0;\r\n}\r\nif (vertex->discard) {\r\nradeon_cp_discard_buffer(dev, file_priv->master, buf);\r\n}\r\nCOMMIT_RING();\r\nreturn 0;\r\n}\r\nstatic int radeon_emit_packets(drm_radeon_private_t * dev_priv,\r\nstruct drm_file *file_priv,\r\ndrm_radeon_cmd_header_t header,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf)\r\n{\r\nint id = (int)header.packet.packet_id;\r\nint sz, reg;\r\nRING_LOCALS;\r\nif (id >= RADEON_MAX_STATE_PACKETS)\r\nreturn -EINVAL;\r\nsz = packet[id].len;\r\nreg = packet[id].start;\r\nif (sz * sizeof(u32) > drm_buffer_unprocessed(cmdbuf->buffer)) {\r\nDRM_ERROR("Packet size provided larger than data provided\n");\r\nreturn -EINVAL;\r\n}\r\nif (radeon_check_and_fixup_packets(dev_priv, file_priv, id,\r\ncmdbuf->buffer)) {\r\nDRM_ERROR("Packet verification failed\n");\r\nreturn -EINVAL;\r\n}\r\nBEGIN_RING(sz + 1);\r\nOUT_RING(CP_PACKET0(reg, (sz - 1)));\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, sz);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic __inline__ int radeon_emit_scalars(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_cmd_header_t header,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf)\r\n{\r\nint sz = header.scalars.count;\r\nint start = header.scalars.offset;\r\nint stride = header.scalars.stride;\r\nRING_LOCALS;\r\nBEGIN_RING(3 + sz);\r\nOUT_RING(CP_PACKET0(RADEON_SE_TCL_SCALAR_INDX_REG, 0));\r\nOUT_RING(start | (stride << RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT));\r\nOUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_SCALAR_DATA_REG, sz - 1));\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, sz);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic __inline__ int radeon_emit_scalars2(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_cmd_header_t header,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf)\r\n{\r\nint sz = header.scalars.count;\r\nint start = ((unsigned int)header.scalars.offset) + 0x100;\r\nint stride = header.scalars.stride;\r\nRING_LOCALS;\r\nBEGIN_RING(3 + sz);\r\nOUT_RING(CP_PACKET0(RADEON_SE_TCL_SCALAR_INDX_REG, 0));\r\nOUT_RING(start | (stride << RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT));\r\nOUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_SCALAR_DATA_REG, sz - 1));\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, sz);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic __inline__ int radeon_emit_vectors(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_cmd_header_t header,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf)\r\n{\r\nint sz = header.vectors.count;\r\nint start = header.vectors.offset;\r\nint stride = header.vectors.stride;\r\nRING_LOCALS;\r\nBEGIN_RING(5 + sz);\r\nOUT_RING_REG(RADEON_SE_TCL_STATE_FLUSH, 0);\r\nOUT_RING(CP_PACKET0(RADEON_SE_TCL_VECTOR_INDX_REG, 0));\r\nOUT_RING(start | (stride << RADEON_VEC_INDX_OCTWORD_STRIDE_SHIFT));\r\nOUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_VECTOR_DATA_REG, (sz - 1)));\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, sz);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic __inline__ int radeon_emit_veclinear(drm_radeon_private_t *dev_priv,\r\ndrm_radeon_cmd_header_t header,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf)\r\n{\r\nint sz = header.veclinear.count * 4;\r\nint start = header.veclinear.addr_lo | (header.veclinear.addr_hi << 8);\r\nRING_LOCALS;\r\nif (!sz)\r\nreturn 0;\r\nif (sz * 4 > drm_buffer_unprocessed(cmdbuf->buffer))\r\nreturn -EINVAL;\r\nBEGIN_RING(5 + sz);\r\nOUT_RING_REG(RADEON_SE_TCL_STATE_FLUSH, 0);\r\nOUT_RING(CP_PACKET0(RADEON_SE_TCL_VECTOR_INDX_REG, 0));\r\nOUT_RING(start | (1 << RADEON_VEC_INDX_OCTWORD_STRIDE_SHIFT));\r\nOUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_VECTOR_DATA_REG, (sz - 1)));\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, sz);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic int radeon_emit_packet3(struct drm_device * dev,\r\nstruct drm_file *file_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nunsigned int cmdsz;\r\nint ret;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nif ((ret = radeon_check_and_fixup_packet3(dev_priv, file_priv,\r\ncmdbuf, &cmdsz))) {\r\nDRM_ERROR("Packet verification failed\n");\r\nreturn ret;\r\n}\r\nBEGIN_RING(cmdsz);\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, cmdsz);\r\nADVANCE_RING();\r\nreturn 0;\r\n}\r\nstatic int radeon_emit_packet3_cliprect(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\ndrm_radeon_kcmd_buffer_t *cmdbuf,\r\nint orig_nbox)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_clip_rect box;\r\nunsigned int cmdsz;\r\nint ret;\r\nstruct drm_clip_rect __user *boxes = cmdbuf->boxes;\r\nint i = 0;\r\nRING_LOCALS;\r\nDRM_DEBUG("\n");\r\nif ((ret = radeon_check_and_fixup_packet3(dev_priv, file_priv,\r\ncmdbuf, &cmdsz))) {\r\nDRM_ERROR("Packet verification failed\n");\r\nreturn ret;\r\n}\r\nif (!orig_nbox)\r\ngoto out;\r\ndo {\r\nif (i < cmdbuf->nbox) {\r\nif (copy_from_user(&box, &boxes[i], sizeof(box)))\r\nreturn -EFAULT;\r\nif (i) {\r\nBEGIN_RING(2);\r\nRADEON_WAIT_UNTIL_3D_IDLE();\r\nADVANCE_RING();\r\n}\r\nradeon_emit_clip_rect(dev_priv, &box);\r\n}\r\nBEGIN_RING(cmdsz);\r\nOUT_RING_DRM_BUFFER(cmdbuf->buffer, cmdsz);\r\nADVANCE_RING();\r\n} while (++i < cmdbuf->nbox);\r\nif (cmdbuf->nbox == 1)\r\ncmdbuf->nbox = 0;\r\nreturn 0;\r\nout:\r\ndrm_buffer_advance(cmdbuf->buffer, cmdsz * 4);\r\nreturn 0;\r\n}\r\nstatic int radeon_emit_wait(struct drm_device * dev, int flags)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nRING_LOCALS;\r\nDRM_DEBUG("%x\n", flags);\r\nswitch (flags) {\r\ncase RADEON_WAIT_2D:\r\nBEGIN_RING(2);\r\nRADEON_WAIT_UNTIL_2D_IDLE();\r\nADVANCE_RING();\r\nbreak;\r\ncase RADEON_WAIT_3D:\r\nBEGIN_RING(2);\r\nRADEON_WAIT_UNTIL_3D_IDLE();\r\nADVANCE_RING();\r\nbreak;\r\ncase RADEON_WAIT_2D | RADEON_WAIT_3D:\r\nBEGIN_RING(2);\r\nRADEON_WAIT_UNTIL_IDLE();\r\nADVANCE_RING();\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_cp_cmdbuf(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf = NULL;\r\ndrm_radeon_cmd_header_t stack_header;\r\nint idx;\r\ndrm_radeon_kcmd_buffer_t *cmdbuf = data;\r\nint orig_nbox;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nRING_SPACE_TEST_WITH_RETURN(dev_priv);\r\nVB_AGE_TEST_WITH_RETURN(dev_priv);\r\nif (cmdbuf->bufsz > 64 * 1024 || cmdbuf->bufsz < 0) {\r\nreturn -EINVAL;\r\n}\r\nif (cmdbuf->bufsz != 0) {\r\nint rv;\r\nvoid __user *buffer = cmdbuf->buffer;\r\nrv = drm_buffer_alloc(&cmdbuf->buffer, cmdbuf->bufsz);\r\nif (rv)\r\nreturn rv;\r\nrv = drm_buffer_copy_from_user(cmdbuf->buffer, buffer,\r\ncmdbuf->bufsz);\r\nif (rv) {\r\ndrm_buffer_free(cmdbuf->buffer);\r\nreturn rv;\r\n}\r\n} else\r\ngoto done;\r\norig_nbox = cmdbuf->nbox;\r\nif (dev_priv->microcode_version == UCODE_R300) {\r\nint temp;\r\ntemp = r300_do_cp_cmdbuf(dev, file_priv, cmdbuf);\r\ndrm_buffer_free(cmdbuf->buffer);\r\nreturn temp;\r\n}\r\nwhile (drm_buffer_unprocessed(cmdbuf->buffer) >= sizeof(stack_header)) {\r\ndrm_radeon_cmd_header_t *header;\r\nheader = drm_buffer_read_object(cmdbuf->buffer,\r\nsizeof(stack_header), &stack_header);\r\nswitch (header->header.cmd_type) {\r\ncase RADEON_CMD_PACKET:\r\nDRM_DEBUG("RADEON_CMD_PACKET\n");\r\nif (radeon_emit_packets\r\n(dev_priv, file_priv, *header, cmdbuf)) {\r\nDRM_ERROR("radeon_emit_packets failed\n");\r\ngoto err;\r\n}\r\nbreak;\r\ncase RADEON_CMD_SCALARS:\r\nDRM_DEBUG("RADEON_CMD_SCALARS\n");\r\nif (radeon_emit_scalars(dev_priv, *header, cmdbuf)) {\r\nDRM_ERROR("radeon_emit_scalars failed\n");\r\ngoto err;\r\n}\r\nbreak;\r\ncase RADEON_CMD_VECTORS:\r\nDRM_DEBUG("RADEON_CMD_VECTORS\n");\r\nif (radeon_emit_vectors(dev_priv, *header, cmdbuf)) {\r\nDRM_ERROR("radeon_emit_vectors failed\n");\r\ngoto err;\r\n}\r\nbreak;\r\ncase RADEON_CMD_DMA_DISCARD:\r\nDRM_DEBUG("RADEON_CMD_DMA_DISCARD\n");\r\nidx = header->dma.buf_idx;\r\nif (idx < 0 || idx >= dma->buf_count) {\r\nDRM_ERROR("buffer index %d (of %d max)\n",\r\nidx, dma->buf_count - 1);\r\ngoto err;\r\n}\r\nbuf = dma->buflist[idx];\r\nif (buf->file_priv != file_priv || buf->pending) {\r\nDRM_ERROR("bad buffer %p %p %d\n",\r\nbuf->file_priv, file_priv,\r\nbuf->pending);\r\ngoto err;\r\n}\r\nradeon_cp_discard_buffer(dev, file_priv->master, buf);\r\nbreak;\r\ncase RADEON_CMD_PACKET3:\r\nDRM_DEBUG("RADEON_CMD_PACKET3\n");\r\nif (radeon_emit_packet3(dev, file_priv, cmdbuf)) {\r\nDRM_ERROR("radeon_emit_packet3 failed\n");\r\ngoto err;\r\n}\r\nbreak;\r\ncase RADEON_CMD_PACKET3_CLIP:\r\nDRM_DEBUG("RADEON_CMD_PACKET3_CLIP\n");\r\nif (radeon_emit_packet3_cliprect\r\n(dev, file_priv, cmdbuf, orig_nbox)) {\r\nDRM_ERROR("radeon_emit_packet3_clip failed\n");\r\ngoto err;\r\n}\r\nbreak;\r\ncase RADEON_CMD_SCALARS2:\r\nDRM_DEBUG("RADEON_CMD_SCALARS2\n");\r\nif (radeon_emit_scalars2(dev_priv, *header, cmdbuf)) {\r\nDRM_ERROR("radeon_emit_scalars2 failed\n");\r\ngoto err;\r\n}\r\nbreak;\r\ncase RADEON_CMD_WAIT:\r\nDRM_DEBUG("RADEON_CMD_WAIT\n");\r\nif (radeon_emit_wait(dev, header->wait.flags)) {\r\nDRM_ERROR("radeon_emit_wait failed\n");\r\ngoto err;\r\n}\r\nbreak;\r\ncase RADEON_CMD_VECLINEAR:\r\nDRM_DEBUG("RADEON_CMD_VECLINEAR\n");\r\nif (radeon_emit_veclinear(dev_priv, *header, cmdbuf)) {\r\nDRM_ERROR("radeon_emit_veclinear failed\n");\r\ngoto err;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("bad cmd_type %d at byte %d\n",\r\nheader->header.cmd_type,\r\ncmdbuf->buffer->iterator);\r\ngoto err;\r\n}\r\n}\r\ndrm_buffer_free(cmdbuf->buffer);\r\ndone:\r\nDRM_DEBUG("DONE\n");\r\nCOMMIT_RING();\r\nreturn 0;\r\nerr:\r\ndrm_buffer_free(cmdbuf->buffer);\r\nreturn -EINVAL;\r\n}\r\nstatic int radeon_cp_getparam(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\ndrm_radeon_getparam_t *param = data;\r\nint value;\r\nDRM_DEBUG("pid=%d\n", DRM_CURRENTPID);\r\nswitch (param->param) {\r\ncase RADEON_PARAM_GART_BUFFER_OFFSET:\r\nvalue = dev_priv->gart_buffers_offset;\r\nbreak;\r\ncase RADEON_PARAM_LAST_FRAME:\r\ndev_priv->stats.last_frame_reads++;\r\nvalue = GET_SCRATCH(dev_priv, 0);\r\nbreak;\r\ncase RADEON_PARAM_LAST_DISPATCH:\r\nvalue = GET_SCRATCH(dev_priv, 1);\r\nbreak;\r\ncase RADEON_PARAM_LAST_CLEAR:\r\ndev_priv->stats.last_clear_reads++;\r\nvalue = GET_SCRATCH(dev_priv, 2);\r\nbreak;\r\ncase RADEON_PARAM_IRQ_NR:\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_R600)\r\nvalue = 0;\r\nelse\r\nvalue = drm_dev_to_irq(dev);\r\nbreak;\r\ncase RADEON_PARAM_GART_BASE:\r\nvalue = dev_priv->gart_vm_start;\r\nbreak;\r\ncase RADEON_PARAM_REGISTER_HANDLE:\r\nvalue = dev_priv->mmio->offset;\r\nbreak;\r\ncase RADEON_PARAM_STATUS_HANDLE:\r\nvalue = dev_priv->ring_rptr_offset;\r\nbreak;\r\n#if BITS_PER_LONG == 32\r\ncase RADEON_PARAM_SAREA_HANDLE:\r\nbreak;\r\n#endif\r\ncase RADEON_PARAM_GART_TEX_HANDLE:\r\nvalue = dev_priv->gart_textures_offset;\r\nbreak;\r\ncase RADEON_PARAM_SCRATCH_OFFSET:\r\nif (!dev_priv->writeback_works)\r\nreturn -EINVAL;\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_R600)\r\nvalue = R600_SCRATCH_REG_OFFSET;\r\nelse\r\nvalue = RADEON_SCRATCH_REG_OFFSET;\r\nbreak;\r\ncase RADEON_PARAM_CARD_TYPE:\r\nif (dev_priv->flags & RADEON_IS_PCIE)\r\nvalue = RADEON_CARD_PCIE;\r\nelse if (dev_priv->flags & RADEON_IS_AGP)\r\nvalue = RADEON_CARD_AGP;\r\nelse\r\nvalue = RADEON_CARD_PCI;\r\nbreak;\r\ncase RADEON_PARAM_VBLANK_CRTC:\r\nvalue = radeon_vblank_crtc_get(dev);\r\nbreak;\r\ncase RADEON_PARAM_FB_LOCATION:\r\nvalue = radeon_read_fb_location(dev_priv);\r\nbreak;\r\ncase RADEON_PARAM_NUM_GB_PIPES:\r\nvalue = dev_priv->num_gb_pipes;\r\nbreak;\r\ncase RADEON_PARAM_NUM_Z_PIPES:\r\nvalue = dev_priv->num_z_pipes;\r\nbreak;\r\ndefault:\r\nDRM_DEBUG("Invalid parameter %d\n", param->param);\r\nreturn -EINVAL;\r\n}\r\nif (copy_to_user(param->value, &value, sizeof(int))) {\r\nDRM_ERROR("copy_to_user\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_cp_setparam(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_master_private *master_priv = file_priv->master->driver_priv;\r\ndrm_radeon_setparam_t *sp = data;\r\nstruct drm_radeon_driver_file_fields *radeon_priv;\r\nswitch (sp->param) {\r\ncase RADEON_SETPARAM_FB_LOCATION:\r\nradeon_priv = file_priv->driver_priv;\r\nradeon_priv->radeon_fb_delta = dev_priv->fb_location -\r\nsp->value;\r\nbreak;\r\ncase RADEON_SETPARAM_SWITCH_TILING:\r\nif (sp->value == 0) {\r\nDRM_DEBUG("color tiling disabled\n");\r\ndev_priv->front_pitch_offset &= ~RADEON_DST_TILE_MACRO;\r\ndev_priv->back_pitch_offset &= ~RADEON_DST_TILE_MACRO;\r\nif (master_priv->sarea_priv)\r\nmaster_priv->sarea_priv->tiling_enabled = 0;\r\n} else if (sp->value == 1) {\r\nDRM_DEBUG("color tiling enabled\n");\r\ndev_priv->front_pitch_offset |= RADEON_DST_TILE_MACRO;\r\ndev_priv->back_pitch_offset |= RADEON_DST_TILE_MACRO;\r\nif (master_priv->sarea_priv)\r\nmaster_priv->sarea_priv->tiling_enabled = 1;\r\n}\r\nbreak;\r\ncase RADEON_SETPARAM_PCIGART_LOCATION:\r\ndev_priv->pcigart_offset = sp->value;\r\ndev_priv->pcigart_offset_set = 1;\r\nbreak;\r\ncase RADEON_SETPARAM_NEW_MEMMAP:\r\ndev_priv->new_memmap = sp->value;\r\nbreak;\r\ncase RADEON_SETPARAM_PCIGART_TABLE_SIZE:\r\ndev_priv->gart_info.table_size = sp->value;\r\nif (dev_priv->gart_info.table_size < RADEON_PCIGART_TABLE_SIZE)\r\ndev_priv->gart_info.table_size = RADEON_PCIGART_TABLE_SIZE;\r\nbreak;\r\ncase RADEON_SETPARAM_VBLANK_CRTC:\r\nreturn radeon_vblank_crtc_set(dev, sp->value);\r\nbreak;\r\ndefault:\r\nDRM_DEBUG("Invalid parameter %d\n", sp->param);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_driver_preclose(struct drm_device *dev, struct drm_file *file_priv)\r\n{\r\nif (dev->dev_private) {\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\ndev_priv->page_flipping = 0;\r\nradeon_mem_release(file_priv, dev_priv->gart_heap);\r\nradeon_mem_release(file_priv, dev_priv->fb_heap);\r\nradeon_surfaces_release(file_priv, dev_priv);\r\n}\r\n}\r\nvoid radeon_driver_lastclose(struct drm_device *dev)\r\n{\r\nradeon_surfaces_release(PCIGART_FILE_PRIV, dev->dev_private);\r\nradeon_do_release(dev);\r\n}\r\nint radeon_driver_open(struct drm_device *dev, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nstruct drm_radeon_driver_file_fields *radeon_priv;\r\nDRM_DEBUG("\n");\r\nradeon_priv = kmalloc(sizeof(*radeon_priv), GFP_KERNEL);\r\nif (!radeon_priv)\r\nreturn -ENOMEM;\r\nfile_priv->driver_priv = radeon_priv;\r\nif (dev_priv)\r\nradeon_priv->radeon_fb_delta = dev_priv->fb_location;\r\nelse\r\nradeon_priv->radeon_fb_delta = 0;\r\nreturn 0;\r\n}\r\nvoid radeon_driver_postclose(struct drm_device *dev, struct drm_file *file_priv)\r\n{\r\nstruct drm_radeon_driver_file_fields *radeon_priv =\r\nfile_priv->driver_priv;\r\nkfree(radeon_priv);\r\n}
