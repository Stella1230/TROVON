static inline struct tegra_fb *to_tegra_fb(struct drm_framebuffer *fb)\r\n{\r\nreturn container_of(fb, struct tegra_fb, base);\r\n}\r\nstatic inline struct tegra_fbdev *to_tegra_fbdev(struct drm_fb_helper *helper)\r\n{\r\nreturn container_of(helper, struct tegra_fbdev, base);\r\n}\r\nstruct tegra_bo *tegra_fb_get_plane(struct drm_framebuffer *framebuffer,\r\nunsigned int index)\r\n{\r\nstruct tegra_fb *fb = to_tegra_fb(framebuffer);\r\nif (index >= drm_format_num_planes(framebuffer->pixel_format))\r\nreturn NULL;\r\nreturn fb->planes[index];\r\n}\r\nbool tegra_fb_is_bottom_up(struct drm_framebuffer *framebuffer)\r\n{\r\nstruct tegra_fb *fb = to_tegra_fb(framebuffer);\r\nif (fb->planes[0]->flags & TEGRA_BO_BOTTOM_UP)\r\nreturn true;\r\nreturn false;\r\n}\r\nbool tegra_fb_is_tiled(struct drm_framebuffer *framebuffer)\r\n{\r\nstruct tegra_fb *fb = to_tegra_fb(framebuffer);\r\nif (fb->planes[0]->flags & TEGRA_BO_TILED)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void tegra_fb_destroy(struct drm_framebuffer *framebuffer)\r\n{\r\nstruct tegra_fb *fb = to_tegra_fb(framebuffer);\r\nunsigned int i;\r\nfor (i = 0; i < fb->num_planes; i++) {\r\nstruct tegra_bo *bo = fb->planes[i];\r\nif (bo)\r\ndrm_gem_object_unreference_unlocked(&bo->gem);\r\n}\r\ndrm_framebuffer_cleanup(framebuffer);\r\nkfree(fb->planes);\r\nkfree(fb);\r\n}\r\nstatic int tegra_fb_create_handle(struct drm_framebuffer *framebuffer,\r\nstruct drm_file *file, unsigned int *handle)\r\n{\r\nstruct tegra_fb *fb = to_tegra_fb(framebuffer);\r\nreturn drm_gem_handle_create(file, &fb->planes[0]->gem, handle);\r\n}\r\nstatic struct tegra_fb *tegra_fb_alloc(struct drm_device *drm,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct tegra_bo **planes,\r\nunsigned int num_planes)\r\n{\r\nstruct tegra_fb *fb;\r\nunsigned int i;\r\nint err;\r\nfb = kzalloc(sizeof(*fb), GFP_KERNEL);\r\nif (!fb)\r\nreturn ERR_PTR(-ENOMEM);\r\nfb->planes = kzalloc(num_planes * sizeof(*planes), GFP_KERNEL);\r\nif (!fb->planes) {\r\nkfree(fb);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nfb->num_planes = num_planes;\r\ndrm_helper_mode_fill_fb_struct(&fb->base, mode_cmd);\r\nfor (i = 0; i < fb->num_planes; i++)\r\nfb->planes[i] = planes[i];\r\nerr = drm_framebuffer_init(drm, &fb->base, &tegra_fb_funcs);\r\nif (err < 0) {\r\ndev_err(drm->dev, "failed to initialize framebuffer: %d\n",\r\nerr);\r\nkfree(fb->planes);\r\nkfree(fb);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn fb;\r\n}\r\nstatic struct drm_framebuffer *tegra_fb_create(struct drm_device *drm,\r\nstruct drm_file *file,\r\nstruct drm_mode_fb_cmd2 *cmd)\r\n{\r\nunsigned int hsub, vsub, i;\r\nstruct tegra_bo *planes[4];\r\nstruct drm_gem_object *gem;\r\nstruct tegra_fb *fb;\r\nint err;\r\nhsub = drm_format_horz_chroma_subsampling(cmd->pixel_format);\r\nvsub = drm_format_vert_chroma_subsampling(cmd->pixel_format);\r\nfor (i = 0; i < drm_format_num_planes(cmd->pixel_format); i++) {\r\nunsigned int width = cmd->width / (i ? hsub : 1);\r\nunsigned int height = cmd->height / (i ? vsub : 1);\r\nunsigned int size, bpp;\r\ngem = drm_gem_object_lookup(drm, file, cmd->handles[i]);\r\nif (!gem) {\r\nerr = -ENXIO;\r\ngoto unreference;\r\n}\r\nbpp = drm_format_plane_cpp(cmd->pixel_format, i);\r\nsize = (height - 1) * cmd->pitches[i] +\r\nwidth * bpp + cmd->offsets[i];\r\nif (gem->size < size) {\r\nerr = -EINVAL;\r\ngoto unreference;\r\n}\r\nplanes[i] = to_tegra_bo(gem);\r\n}\r\nfb = tegra_fb_alloc(drm, cmd, planes, i);\r\nif (IS_ERR(fb)) {\r\nerr = PTR_ERR(fb);\r\ngoto unreference;\r\n}\r\nreturn &fb->base;\r\nunreference:\r\nwhile (i--)\r\ndrm_gem_object_unreference_unlocked(&planes[i]->gem);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int tegra_fbdev_probe(struct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct tegra_fbdev *fbdev = to_tegra_fbdev(helper);\r\nstruct drm_device *drm = helper->dev;\r\nstruct drm_mode_fb_cmd2 cmd = { 0 };\r\nunsigned int bytes_per_pixel;\r\nstruct drm_framebuffer *fb;\r\nunsigned long offset;\r\nstruct fb_info *info;\r\nstruct tegra_bo *bo;\r\nsize_t size;\r\nint err;\r\nbytes_per_pixel = DIV_ROUND_UP(sizes->surface_bpp, 8);\r\ncmd.width = sizes->surface_width;\r\ncmd.height = sizes->surface_height;\r\ncmd.pitches[0] = sizes->surface_width * bytes_per_pixel;\r\ncmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\r\nsizes->surface_depth);\r\nsize = cmd.pitches[0] * cmd.height;\r\nbo = tegra_bo_create(drm, size, 0);\r\nif (IS_ERR(bo))\r\nreturn PTR_ERR(bo);\r\ninfo = framebuffer_alloc(0, drm->dev);\r\nif (!info) {\r\ndev_err(drm->dev, "failed to allocate framebuffer info\n");\r\ntegra_bo_free_object(&bo->gem);\r\nreturn -ENOMEM;\r\n}\r\nfbdev->fb = tegra_fb_alloc(drm, &cmd, &bo, 1);\r\nif (IS_ERR(fbdev->fb)) {\r\ndev_err(drm->dev, "failed to allocate DRM framebuffer\n");\r\nerr = PTR_ERR(fbdev->fb);\r\ngoto release;\r\n}\r\nfb = &fbdev->fb->base;\r\nhelper->fb = fb;\r\nhelper->fbdev = info;\r\ninfo->par = helper;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\ninfo->fbops = &tegra_fb_ops;\r\nerr = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (err < 0) {\r\ndev_err(drm->dev, "failed to allocate color map: %d\n", err);\r\ngoto destroy;\r\n}\r\ndrm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);\r\ndrm_fb_helper_fill_var(info, helper, fb->width, fb->height);\r\noffset = info->var.xoffset * bytes_per_pixel +\r\ninfo->var.yoffset * fb->pitches[0];\r\ndrm->mode_config.fb_base = (resource_size_t)bo->paddr;\r\ninfo->screen_base = (void __iomem *)bo->vaddr + offset;\r\ninfo->screen_size = size;\r\ninfo->fix.smem_start = (unsigned long)(bo->paddr + offset);\r\ninfo->fix.smem_len = size;\r\nreturn 0;\r\ndestroy:\r\ndrm_framebuffer_unregister_private(fb);\r\ntegra_fb_destroy(fb);\r\nrelease:\r\nframebuffer_release(info);\r\nreturn err;\r\n}\r\nstatic struct tegra_fbdev *tegra_fbdev_create(struct drm_device *drm,\r\nunsigned int preferred_bpp,\r\nunsigned int num_crtc,\r\nunsigned int max_connectors)\r\n{\r\nstruct drm_fb_helper *helper;\r\nstruct tegra_fbdev *fbdev;\r\nint err;\r\nfbdev = kzalloc(sizeof(*fbdev), GFP_KERNEL);\r\nif (!fbdev) {\r\ndev_err(drm->dev, "failed to allocate DRM fbdev\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nfbdev->base.funcs = &tegra_fb_helper_funcs;\r\nhelper = &fbdev->base;\r\nerr = drm_fb_helper_init(drm, &fbdev->base, num_crtc, max_connectors);\r\nif (err < 0) {\r\ndev_err(drm->dev, "failed to initialize DRM FB helper\n");\r\ngoto free;\r\n}\r\nerr = drm_fb_helper_single_add_all_connectors(&fbdev->base);\r\nif (err < 0) {\r\ndev_err(drm->dev, "failed to add connectors\n");\r\ngoto fini;\r\n}\r\ndrm_helper_disable_unused_functions(drm);\r\nerr = drm_fb_helper_initial_config(&fbdev->base, preferred_bpp);\r\nif (err < 0) {\r\ndev_err(drm->dev, "failed to set initial configuration\n");\r\ngoto fini;\r\n}\r\nreturn fbdev;\r\nfini:\r\ndrm_fb_helper_fini(&fbdev->base);\r\nfree:\r\nkfree(fbdev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void tegra_fbdev_free(struct tegra_fbdev *fbdev)\r\n{\r\nstruct fb_info *info = fbdev->base.fbdev;\r\nif (info) {\r\nint err;\r\nerr = unregister_framebuffer(info);\r\nif (err < 0)\r\nDRM_DEBUG_KMS("failed to unregister framebuffer\n");\r\nif (info->cmap.len)\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nif (fbdev->fb) {\r\ndrm_framebuffer_unregister_private(&fbdev->fb->base);\r\ntegra_fb_destroy(&fbdev->fb->base);\r\n}\r\ndrm_fb_helper_fini(&fbdev->base);\r\nkfree(fbdev);\r\n}\r\nvoid tegra_fbdev_restore_mode(struct tegra_fbdev *fbdev)\r\n{\r\nif (fbdev) {\r\ndrm_modeset_lock_all(fbdev->base.dev);\r\ndrm_fb_helper_restore_fbdev_mode(&fbdev->base);\r\ndrm_modeset_unlock_all(fbdev->base.dev);\r\n}\r\n}\r\nstatic void tegra_fb_output_poll_changed(struct drm_device *drm)\r\n{\r\nstruct tegra_drm *tegra = drm->dev_private;\r\nif (tegra->fbdev)\r\ndrm_fb_helper_hotplug_event(&tegra->fbdev->base);\r\n}\r\nint tegra_drm_fb_init(struct drm_device *drm)\r\n{\r\n#ifdef CONFIG_DRM_TEGRA_FBDEV\r\nstruct tegra_drm *tegra = drm->dev_private;\r\n#endif\r\ndrm->mode_config.min_width = 0;\r\ndrm->mode_config.min_height = 0;\r\ndrm->mode_config.max_width = 4096;\r\ndrm->mode_config.max_height = 4096;\r\ndrm->mode_config.funcs = &tegra_drm_mode_funcs;\r\n#ifdef CONFIG_DRM_TEGRA_FBDEV\r\ntegra->fbdev = tegra_fbdev_create(drm, 32, drm->mode_config.num_crtc,\r\ndrm->mode_config.num_connector);\r\nif (IS_ERR(tegra->fbdev))\r\nreturn PTR_ERR(tegra->fbdev);\r\n#endif\r\nreturn 0;\r\n}\r\nvoid tegra_drm_fb_exit(struct drm_device *drm)\r\n{\r\n#ifdef CONFIG_DRM_TEGRA_FBDEV\r\nstruct tegra_drm *tegra = drm->dev_private;\r\ntegra_fbdev_free(tegra->fbdev);\r\n#endif\r\n}
