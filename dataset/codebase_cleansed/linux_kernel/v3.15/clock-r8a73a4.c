static unsigned long pll_recalc(struct clk *clk)\r\n{\r\nunsigned long mult = 1;\r\nif (ioread32(CPG_MAP(PLLECR)) & (1 << clk->enable_bit))\r\nmult = (((ioread32(clk->mapped_reg) >> 24) & 0x7f) + 1);\r\nreturn clk->parent->rate * mult;\r\n}\r\nstatic int pll_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 val;\r\nint i, ret;\r\nif (!clk->parent_table || !clk->parent_num)\r\nreturn -EINVAL;\r\nfor (i = 0; i < clk->parent_num; i++)\r\nif (clk->parent_table[i] == parent)\r\nbreak;\r\nif (i == clk->parent_num)\r\nreturn -ENODEV;\r\nret = clk_reparent(clk, parent);\r\nif (ret < 0)\r\nreturn ret;\r\nval = ioread32(clk->mapped_reg) &\r\n~(((1 << clk->src_width) - 1) << clk->src_shift);\r\niowrite32(val | i << clk->src_shift, clk->mapped_reg);\r\nreturn 0;\r\n}\r\nstatic bool frqcr_kick_check(struct clk *clk)\r\n{\r\nreturn !(ioread32(CPG_MAP(FRQCRB)) & BIT(31));\r\n}\r\nstatic int frqcr_kick_do(struct clk *clk)\r\n{\r\nint i;\r\niowrite32(ioread32(CPG_MAP(FRQCRB)) | BIT(31), CPG_MAP(FRQCRB));\r\nfor (i = 1000; i; i--)\r\nif (ioread32(CPG_MAP(FRQCRB)) & BIT(31))\r\ncpu_relax();\r\nelse\r\nreturn 0;\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int zclk_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nvoid __iomem *frqcrc;\r\nint ret;\r\nunsigned long step, p_rate;\r\nu32 val;\r\nif (!clk->parent || !__clk_get(clk->parent))\r\nreturn -ENODEV;\r\nif (!atomic_inc_and_test(&frqcr_lock) || !frqcr_kick_check(clk)) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\np_rate = clk_get_rate(clk->parent);\r\nif (rate == p_rate) {\r\nval = 0;\r\n} else {\r\nstep = DIV_ROUND_CLOSEST(p_rate, 32);\r\nif (rate > p_rate || rate < step) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nval = 32 - rate / step;\r\n}\r\nfrqcrc = clk->mapped_reg + (FRQCRC - (u32)clk->enable_reg);\r\niowrite32((ioread32(frqcrc) & ~(clk->div_mask << clk->enable_bit)) |\r\n(val << clk->enable_bit), frqcrc);\r\nret = frqcr_kick_do(clk);\r\ndone:\r\natomic_dec(&frqcr_lock);\r\n__clk_put(clk->parent);\r\nreturn ret;\r\n}\r\nstatic long zclk_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned long step, mul_min, mul_max, rate_min, rate_max;\r\nrate_max = clk_get_rate(clk->parent);\r\nif (rate >= rate_max)\r\nreturn rate_max;\r\nstep = DIV_ROUND_CLOSEST(rate_max, 32);\r\nif (step >= rate)\r\nreturn step;\r\nmul_min = rate / step;\r\nmul_max = DIV_ROUND_UP(rate, step);\r\nrate_min = step * mul_min;\r\nif (mul_max == mul_min)\r\nreturn rate_min;\r\nrate_max = step * mul_max;\r\nif (rate_max - rate < rate - rate_min)\r\nreturn rate_max;\r\nreturn rate_min;\r\n}\r\nstatic unsigned long zclk_recalc(struct clk *clk)\r\n{\r\nvoid __iomem *frqcrc = FRQCRC - (u32)clk->enable_reg + clk->mapped_reg;\r\nunsigned int max = clk->div_mask + 1;\r\nunsigned long val = ((ioread32(frqcrc) >> clk->enable_bit) &\r\nclk->div_mask);\r\nreturn DIV_ROUND_CLOSEST(clk_get_rate(clk->parent), max) *\r\n(max - val);\r\n}\r\nstatic void div4_kick(struct clk *clk)\r\n{\r\nif (!WARN(!atomic_inc_and_test(&frqcr_lock), "FRQCR* lock broken!\n"))\r\nfrqcr_kick_do(clk);\r\natomic_dec(&frqcr_lock);\r\n}\r\nvoid __init r8a73a4_clock_init(void)\r\n{\r\nvoid __iomem *reg;\r\nint k, ret = 0;\r\nu32 ckscr;\r\natomic_set(&frqcr_lock, -1);\r\nreg = ioremap_nocache(CKSCR, PAGE_SIZE);\r\nBUG_ON(!reg);\r\nckscr = ioread32(reg);\r\niounmap(reg);\r\nswitch ((ckscr >> 28) & 0x3) {\r\ncase 0:\r\nmain_clk.parent = &extal1_clk;\r\nbreak;\r\ncase 1:\r\nmain_clk.parent = &extal1_div2_clk;\r\nbreak;\r\ncase 2:\r\nmain_clk.parent = &extal2_clk;\r\nbreak;\r\ncase 3:\r\nmain_clk.parent = &extal2_div2_clk;\r\nbreak;\r\n}\r\nfor (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)\r\nret = clk_register(main_clks[k]);\r\nif (!ret)\r\nret = sh_clk_div4_register(div4_clks, DIV4_NR, &div4_table);\r\nif (!ret)\r\nret = sh_clk_div6_reparent_register(div6_clks, DIV6_NR);\r\nif (!ret)\r\nret = sh_clk_mstp_register(mstp_clks, MSTP_NR);\r\nclkdev_add_table(lookups, ARRAY_SIZE(lookups));\r\nif (!ret)\r\nshmobile_clk_init();\r\nelse\r\npanic("failed to setup r8a73a4 clocks\n");\r\n}
