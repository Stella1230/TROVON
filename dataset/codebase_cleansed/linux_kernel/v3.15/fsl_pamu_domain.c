static int __init iommu_init_mempool(void)\r\n{\r\nfsl_pamu_domain_cache = kmem_cache_create("fsl_pamu_domain",\r\nsizeof(struct fsl_dma_domain),\r\n0,\r\nSLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!fsl_pamu_domain_cache) {\r\npr_debug("Couldn't create fsl iommu_domain cache\n");\r\nreturn -ENOMEM;\r\n}\r\niommu_devinfo_cache = kmem_cache_create("iommu_devinfo",\r\nsizeof(struct device_domain_info),\r\n0,\r\nSLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!iommu_devinfo_cache) {\r\npr_debug("Couldn't create devinfo cache\n");\r\nkmem_cache_destroy(fsl_pamu_domain_cache);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic phys_addr_t get_phys_addr(struct fsl_dma_domain *dma_domain, dma_addr_t iova)\r\n{\r\nu32 win_cnt = dma_domain->win_cnt;\r\nstruct dma_window *win_ptr =\r\n&dma_domain->win_arr[0];\r\nstruct iommu_domain_geometry *geom;\r\ngeom = &dma_domain->iommu_domain->geometry;\r\nif (!win_cnt || !dma_domain->geom_size) {\r\npr_debug("Number of windows/geometry not configured for the domain\n");\r\nreturn 0;\r\n}\r\nif (win_cnt > 1) {\r\nu64 subwin_size;\r\ndma_addr_t subwin_iova;\r\nu32 wnd;\r\nsubwin_size = dma_domain->geom_size >> ilog2(win_cnt);\r\nsubwin_iova = iova & ~(subwin_size - 1);\r\nwnd = (subwin_iova - geom->aperture_start) >> ilog2(subwin_size);\r\nwin_ptr = &dma_domain->win_arr[wnd];\r\n}\r\nif (win_ptr->valid)\r\nreturn (win_ptr->paddr + (iova & (win_ptr->size - 1)));\r\nreturn 0;\r\n}\r\nstatic int map_subwins(int liodn, struct fsl_dma_domain *dma_domain)\r\n{\r\nstruct dma_window *sub_win_ptr =\r\n&dma_domain->win_arr[0];\r\nint i, ret;\r\nunsigned long rpn, flags;\r\nfor (i = 0; i < dma_domain->win_cnt; i++) {\r\nif (sub_win_ptr[i].valid) {\r\nrpn = sub_win_ptr[i].paddr >>\r\nPAMU_PAGE_SHIFT;\r\nspin_lock_irqsave(&iommu_lock, flags);\r\nret = pamu_config_spaace(liodn, dma_domain->win_cnt, i,\r\nsub_win_ptr[i].size,\r\n~(u32)0,\r\nrpn,\r\ndma_domain->snoop_id,\r\ndma_domain->stash_id,\r\n(i > 0) ? 1 : 0,\r\nsub_win_ptr[i].prot);\r\nspin_unlock_irqrestore(&iommu_lock, flags);\r\nif (ret) {\r\npr_debug("PAMU SPAACE configuration failed for liodn %d\n",\r\nliodn);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int map_win(int liodn, struct fsl_dma_domain *dma_domain)\r\n{\r\nint ret;\r\nstruct dma_window *wnd = &dma_domain->win_arr[0];\r\nphys_addr_t wnd_addr = dma_domain->iommu_domain->geometry.aperture_start;\r\nunsigned long flags;\r\nspin_lock_irqsave(&iommu_lock, flags);\r\nret = pamu_config_ppaace(liodn, wnd_addr,\r\nwnd->size,\r\n~(u32)0,\r\nwnd->paddr >> PAMU_PAGE_SHIFT,\r\ndma_domain->snoop_id, dma_domain->stash_id,\r\n0, wnd->prot);\r\nspin_unlock_irqrestore(&iommu_lock, flags);\r\nif (ret)\r\npr_debug("PAMU PAACE configuration failed for liodn %d\n",\r\nliodn);\r\nreturn ret;\r\n}\r\nstatic int map_liodn(int liodn, struct fsl_dma_domain *dma_domain)\r\n{\r\nif (dma_domain->win_cnt > 1)\r\nreturn map_subwins(liodn, dma_domain);\r\nelse\r\nreturn map_win(liodn, dma_domain);\r\n}\r\nstatic int update_liodn(int liodn, struct fsl_dma_domain *dma_domain, u32 wnd_nr)\r\n{\r\nint ret;\r\nstruct dma_window *wnd = &dma_domain->win_arr[wnd_nr];\r\nunsigned long flags;\r\nspin_lock_irqsave(&iommu_lock, flags);\r\nif (dma_domain->win_cnt > 1) {\r\nret = pamu_config_spaace(liodn, dma_domain->win_cnt, wnd_nr,\r\nwnd->size,\r\n~(u32)0,\r\nwnd->paddr >> PAMU_PAGE_SHIFT,\r\ndma_domain->snoop_id,\r\ndma_domain->stash_id,\r\n(wnd_nr > 0) ? 1 : 0,\r\nwnd->prot);\r\nif (ret)\r\npr_debug("Subwindow reconfiguration failed for liodn %d\n", liodn);\r\n} else {\r\nphys_addr_t wnd_addr;\r\nwnd_addr = dma_domain->iommu_domain->geometry.aperture_start;\r\nret = pamu_config_ppaace(liodn, wnd_addr,\r\nwnd->size,\r\n~(u32)0,\r\nwnd->paddr >> PAMU_PAGE_SHIFT,\r\ndma_domain->snoop_id, dma_domain->stash_id,\r\n0, wnd->prot);\r\nif (ret)\r\npr_debug("Window reconfiguration failed for liodn %d\n", liodn);\r\n}\r\nspin_unlock_irqrestore(&iommu_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int update_liodn_stash(int liodn, struct fsl_dma_domain *dma_domain,\r\nu32 val)\r\n{\r\nint ret = 0, i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&iommu_lock, flags);\r\nif (!dma_domain->win_arr) {\r\npr_debug("Windows not configured, stash destination update failed for liodn %d\n", liodn);\r\nspin_unlock_irqrestore(&iommu_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < dma_domain->win_cnt; i++) {\r\nret = pamu_update_paace_stash(liodn, i, val);\r\nif (ret) {\r\npr_debug("Failed to update SPAACE %d field for liodn %d\n ", i, liodn);\r\nspin_unlock_irqrestore(&iommu_lock, flags);\r\nreturn ret;\r\n}\r\n}\r\nspin_unlock_irqrestore(&iommu_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int pamu_set_liodn(int liodn, struct device *dev,\r\nstruct fsl_dma_domain *dma_domain,\r\nstruct iommu_domain_geometry *geom_attr,\r\nu32 win_cnt)\r\n{\r\nphys_addr_t window_addr, window_size;\r\nphys_addr_t subwin_size;\r\nint ret = 0, i;\r\nu32 omi_index = ~(u32)0;\r\nunsigned long flags;\r\nget_ome_index(&omi_index, dev);\r\nwindow_addr = geom_attr->aperture_start;\r\nwindow_size = dma_domain->geom_size;\r\nspin_lock_irqsave(&iommu_lock, flags);\r\nret = pamu_disable_liodn(liodn);\r\nif (!ret)\r\nret = pamu_config_ppaace(liodn, window_addr, window_size, omi_index,\r\n0, dma_domain->snoop_id,\r\ndma_domain->stash_id, win_cnt, 0);\r\nspin_unlock_irqrestore(&iommu_lock, flags);\r\nif (ret) {\r\npr_debug("PAMU PAACE configuration failed for liodn %d, win_cnt =%d\n", liodn, win_cnt);\r\nreturn ret;\r\n}\r\nif (win_cnt > 1) {\r\nsubwin_size = window_size >> ilog2(win_cnt);\r\nfor (i = 0; i < win_cnt; i++) {\r\nspin_lock_irqsave(&iommu_lock, flags);\r\nret = pamu_disable_spaace(liodn, i);\r\nif (!ret)\r\nret = pamu_config_spaace(liodn, win_cnt, i,\r\nsubwin_size, omi_index,\r\n0, dma_domain->snoop_id,\r\ndma_domain->stash_id,\r\n0, 0);\r\nspin_unlock_irqrestore(&iommu_lock, flags);\r\nif (ret) {\r\npr_debug("PAMU SPAACE configuration failed for liodn %d\n", liodn);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int check_size(u64 size, dma_addr_t iova)\r\n{\r\nif (!is_power_of_2(size) || size < PAMU_PAGE_SIZE) {\r\npr_debug("%s: size too small or not a power of two\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (iova & (size - 1)) {\r\npr_debug("%s: address is not aligned with window size\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct fsl_dma_domain *iommu_alloc_dma_domain(void)\r\n{\r\nstruct fsl_dma_domain *domain;\r\ndomain = kmem_cache_zalloc(fsl_pamu_domain_cache, GFP_KERNEL);\r\nif (!domain)\r\nreturn NULL;\r\ndomain->stash_id = ~(u32)0;\r\ndomain->snoop_id = ~(u32)0;\r\ndomain->win_cnt = pamu_get_max_subwin_cnt();\r\ndomain->geom_size = 0;\r\nINIT_LIST_HEAD(&domain->devices);\r\nspin_lock_init(&domain->domain_lock);\r\nreturn domain;\r\n}\r\nstatic inline struct device_domain_info *find_domain(struct device *dev)\r\n{\r\nreturn dev->archdata.iommu_domain;\r\n}\r\nstatic void remove_device_ref(struct device_domain_info *info, u32 win_cnt)\r\n{\r\nunsigned long flags;\r\nlist_del(&info->link);\r\nspin_lock_irqsave(&iommu_lock, flags);\r\nif (win_cnt > 1)\r\npamu_free_subwins(info->liodn);\r\npamu_disable_liodn(info->liodn);\r\nspin_unlock_irqrestore(&iommu_lock, flags);\r\nspin_lock_irqsave(&device_domain_lock, flags);\r\ninfo->dev->archdata.iommu_domain = NULL;\r\nkmem_cache_free(iommu_devinfo_cache, info);\r\nspin_unlock_irqrestore(&device_domain_lock, flags);\r\n}\r\nstatic void detach_device(struct device *dev, struct fsl_dma_domain *dma_domain)\r\n{\r\nstruct device_domain_info *info, *tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dma_domain->domain_lock, flags);\r\nlist_for_each_entry_safe(info, tmp, &dma_domain->devices, link) {\r\nif (!dev || (info->dev == dev))\r\nremove_device_ref(info, dma_domain->win_cnt);\r\n}\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\n}\r\nstatic void attach_device(struct fsl_dma_domain *dma_domain, int liodn, struct device *dev)\r\n{\r\nstruct device_domain_info *info, *old_domain_info;\r\nunsigned long flags;\r\nspin_lock_irqsave(&device_domain_lock, flags);\r\nold_domain_info = find_domain(dev);\r\nif (old_domain_info && old_domain_info->domain != dma_domain) {\r\nspin_unlock_irqrestore(&device_domain_lock, flags);\r\ndetach_device(dev, old_domain_info->domain);\r\nspin_lock_irqsave(&device_domain_lock, flags);\r\n}\r\ninfo = kmem_cache_zalloc(iommu_devinfo_cache, GFP_ATOMIC);\r\ninfo->dev = dev;\r\ninfo->liodn = liodn;\r\ninfo->domain = dma_domain;\r\nlist_add(&info->link, &dma_domain->devices);\r\nif (!old_domain_info)\r\ndev->archdata.iommu_domain = info;\r\nspin_unlock_irqrestore(&device_domain_lock, flags);\r\n}\r\nstatic phys_addr_t fsl_pamu_iova_to_phys(struct iommu_domain *domain,\r\ndma_addr_t iova)\r\n{\r\nstruct fsl_dma_domain *dma_domain = domain->priv;\r\nif ((iova < domain->geometry.aperture_start) ||\r\niova > (domain->geometry.aperture_end))\r\nreturn 0;\r\nreturn get_phys_addr(dma_domain, iova);\r\n}\r\nstatic int fsl_pamu_domain_has_cap(struct iommu_domain *domain,\r\nunsigned long cap)\r\n{\r\nreturn cap == IOMMU_CAP_CACHE_COHERENCY;\r\n}\r\nstatic void fsl_pamu_domain_destroy(struct iommu_domain *domain)\r\n{\r\nstruct fsl_dma_domain *dma_domain = domain->priv;\r\ndomain->priv = NULL;\r\ndetach_device(NULL, dma_domain);\r\ndma_domain->enabled = 0;\r\ndma_domain->mapped = 0;\r\nkmem_cache_free(fsl_pamu_domain_cache, dma_domain);\r\n}\r\nstatic int fsl_pamu_domain_init(struct iommu_domain *domain)\r\n{\r\nstruct fsl_dma_domain *dma_domain;\r\ndma_domain = iommu_alloc_dma_domain();\r\nif (!dma_domain) {\r\npr_debug("dma_domain allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\ndomain->priv = dma_domain;\r\ndma_domain->iommu_domain = domain;\r\ndomain->geometry.aperture_start = 0;\r\ndomain->geometry.aperture_end = (1ULL << 36) - 1;\r\ndomain->geometry.force_aperture = true;\r\nreturn 0;\r\n}\r\nstatic int pamu_set_domain_geometry(struct fsl_dma_domain *dma_domain,\r\nstruct iommu_domain_geometry *geom_attr,\r\nu32 win_cnt)\r\n{\r\nstruct device_domain_info *info;\r\nint ret = 0;\r\nlist_for_each_entry(info, &dma_domain->devices, link) {\r\nret = pamu_set_liodn(info->liodn, info->dev, dma_domain,\r\ngeom_attr, win_cnt);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int update_domain_stash(struct fsl_dma_domain *dma_domain, u32 val)\r\n{\r\nstruct device_domain_info *info;\r\nint ret = 0;\r\nlist_for_each_entry(info, &dma_domain->devices, link) {\r\nret = update_liodn_stash(info->liodn, dma_domain, val);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int update_domain_mapping(struct fsl_dma_domain *dma_domain, u32 wnd_nr)\r\n{\r\nstruct device_domain_info *info;\r\nint ret = 0;\r\nlist_for_each_entry(info, &dma_domain->devices, link) {\r\nret = update_liodn(info->liodn, dma_domain, wnd_nr);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int disable_domain_win(struct fsl_dma_domain *dma_domain, u32 wnd_nr)\r\n{\r\nstruct device_domain_info *info;\r\nint ret = 0;\r\nlist_for_each_entry(info, &dma_domain->devices, link) {\r\nif (dma_domain->win_cnt == 1 && dma_domain->enabled) {\r\nret = pamu_disable_liodn(info->liodn);\r\nif (!ret)\r\ndma_domain->enabled = 0;\r\n} else {\r\nret = pamu_disable_spaace(info->liodn, wnd_nr);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void fsl_pamu_window_disable(struct iommu_domain *domain, u32 wnd_nr)\r\n{\r\nstruct fsl_dma_domain *dma_domain = domain->priv;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&dma_domain->domain_lock, flags);\r\nif (!dma_domain->win_arr) {\r\npr_debug("Number of windows not configured\n");\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn;\r\n}\r\nif (wnd_nr >= dma_domain->win_cnt) {\r\npr_debug("Invalid window index\n");\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn;\r\n}\r\nif (dma_domain->win_arr[wnd_nr].valid) {\r\nret = disable_domain_win(dma_domain, wnd_nr);\r\nif (!ret) {\r\ndma_domain->win_arr[wnd_nr].valid = 0;\r\ndma_domain->mapped--;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\n}\r\nstatic int fsl_pamu_window_enable(struct iommu_domain *domain, u32 wnd_nr,\r\nphys_addr_t paddr, u64 size, int prot)\r\n{\r\nstruct fsl_dma_domain *dma_domain = domain->priv;\r\nstruct dma_window *wnd;\r\nint pamu_prot = 0;\r\nint ret;\r\nunsigned long flags;\r\nu64 win_size;\r\nif (prot & IOMMU_READ)\r\npamu_prot |= PAACE_AP_PERMS_QUERY;\r\nif (prot & IOMMU_WRITE)\r\npamu_prot |= PAACE_AP_PERMS_UPDATE;\r\nspin_lock_irqsave(&dma_domain->domain_lock, flags);\r\nif (!dma_domain->win_arr) {\r\npr_debug("Number of windows not configured\n");\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn -ENODEV;\r\n}\r\nif (wnd_nr >= dma_domain->win_cnt) {\r\npr_debug("Invalid window index\n");\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nwin_size = dma_domain->geom_size >> ilog2(dma_domain->win_cnt);\r\nif (size > win_size) {\r\npr_debug("Invalid window size \n");\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nif (dma_domain->win_cnt == 1) {\r\nif (dma_domain->enabled) {\r\npr_debug("Disable the window before updating the mapping\n");\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn -EBUSY;\r\n}\r\nret = check_size(size, domain->geometry.aperture_start);\r\nif (ret) {\r\npr_debug("Aperture start not aligned to the size\n");\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn -EINVAL;\r\n}\r\n}\r\nwnd = &dma_domain->win_arr[wnd_nr];\r\nif (!wnd->valid) {\r\nwnd->paddr = paddr;\r\nwnd->size = size;\r\nwnd->prot = pamu_prot;\r\nret = update_domain_mapping(dma_domain, wnd_nr);\r\nif (!ret) {\r\nwnd->valid = 1;\r\ndma_domain->mapped++;\r\n}\r\n} else {\r\npr_debug("Disable the window before updating the mapping\n");\r\nret = -EBUSY;\r\n}\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int handle_attach_device(struct fsl_dma_domain *dma_domain,\r\nstruct device *dev, const u32 *liodn,\r\nint num)\r\n{\r\nunsigned long flags;\r\nstruct iommu_domain *domain = dma_domain->iommu_domain;\r\nint ret = 0;\r\nint i;\r\nspin_lock_irqsave(&dma_domain->domain_lock, flags);\r\nfor (i = 0; i < num; i++) {\r\nif (liodn[i] >= PAACE_NUMBER_ENTRIES) {\r\npr_debug("Invalid liodn %d, attach device failed for %s\n",\r\nliodn[i], dev->of_node->full_name);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nattach_device(dma_domain, liodn[i], dev);\r\nif (dma_domain->win_arr) {\r\nu32 win_cnt = dma_domain->win_cnt > 1 ? dma_domain->win_cnt : 0;\r\nret = pamu_set_liodn(liodn[i], dev, dma_domain,\r\n&domain->geometry,\r\nwin_cnt);\r\nif (ret)\r\nbreak;\r\nif (dma_domain->mapped) {\r\nret = map_liodn(liodn[i], dma_domain);\r\nif (ret)\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int fsl_pamu_attach_device(struct iommu_domain *domain,\r\nstruct device *dev)\r\n{\r\nstruct fsl_dma_domain *dma_domain = domain->priv;\r\nconst u32 *liodn;\r\nu32 liodn_cnt;\r\nint len, ret = 0;\r\nstruct pci_dev *pdev = NULL;\r\nstruct pci_controller *pci_ctl;\r\nif (dev_is_pci(dev)) {\r\npdev = to_pci_dev(dev);\r\npci_ctl = pci_bus_to_host(pdev->bus);\r\ndev = pci_ctl->parent;\r\n}\r\nliodn = of_get_property(dev->of_node, "fsl,liodn", &len);\r\nif (liodn) {\r\nliodn_cnt = len / sizeof(u32);\r\nret = handle_attach_device(dma_domain, dev,\r\nliodn, liodn_cnt);\r\n} else {\r\npr_debug("missing fsl,liodn property at %s\n",\r\ndev->of_node->full_name);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void fsl_pamu_detach_device(struct iommu_domain *domain,\r\nstruct device *dev)\r\n{\r\nstruct fsl_dma_domain *dma_domain = domain->priv;\r\nconst u32 *prop;\r\nint len;\r\nstruct pci_dev *pdev = NULL;\r\nstruct pci_controller *pci_ctl;\r\nif (dev_is_pci(dev)) {\r\npdev = to_pci_dev(dev);\r\npci_ctl = pci_bus_to_host(pdev->bus);\r\ndev = pci_ctl->parent;\r\n}\r\nprop = of_get_property(dev->of_node, "fsl,liodn", &len);\r\nif (prop)\r\ndetach_device(dev, dma_domain);\r\nelse\r\npr_debug("missing fsl,liodn property at %s\n",\r\ndev->of_node->full_name);\r\n}\r\nstatic int configure_domain_geometry(struct iommu_domain *domain, void *data)\r\n{\r\nstruct iommu_domain_geometry *geom_attr = data;\r\nstruct fsl_dma_domain *dma_domain = domain->priv;\r\ndma_addr_t geom_size;\r\nunsigned long flags;\r\ngeom_size = geom_attr->aperture_end - geom_attr->aperture_start + 1;\r\nif (check_size(geom_size, geom_attr->aperture_start) ||\r\n!geom_attr->force_aperture) {\r\npr_debug("Invalid PAMU geometry attributes\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&dma_domain->domain_lock, flags);\r\nif (dma_domain->enabled) {\r\npr_debug("Can't set geometry attributes as domain is active\n");\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn -EBUSY;\r\n}\r\nmemcpy(&domain->geometry, geom_attr,\r\nsizeof(struct iommu_domain_geometry));\r\ndma_domain->geom_size = geom_size;\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int configure_domain_stash(struct fsl_dma_domain *dma_domain, void *data)\r\n{\r\nstruct pamu_stash_attribute *stash_attr = data;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&dma_domain->domain_lock, flags);\r\nmemcpy(&dma_domain->dma_stash, stash_attr,\r\nsizeof(struct pamu_stash_attribute));\r\ndma_domain->stash_id = get_stash_id(stash_attr->cache,\r\nstash_attr->cpu);\r\nif (dma_domain->stash_id == ~(u32)0) {\r\npr_debug("Invalid stash attributes\n");\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nret = update_domain_stash(dma_domain, dma_domain->stash_id);\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int configure_domain_dma_state(struct fsl_dma_domain *dma_domain, bool enable)\r\n{\r\nstruct device_domain_info *info;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&dma_domain->domain_lock, flags);\r\nif (enable && !dma_domain->mapped) {\r\npr_debug("Can't enable DMA domain without valid mapping\n");\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn -ENODEV;\r\n}\r\ndma_domain->enabled = enable;\r\nlist_for_each_entry(info, &dma_domain->devices,\r\nlink) {\r\nret = (enable) ? pamu_enable_liodn(info->liodn) :\r\npamu_disable_liodn(info->liodn);\r\nif (ret)\r\npr_debug("Unable to set dma state for liodn %d",\r\ninfo->liodn);\r\n}\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fsl_pamu_set_domain_attr(struct iommu_domain *domain,\r\nenum iommu_attr attr_type, void *data)\r\n{\r\nstruct fsl_dma_domain *dma_domain = domain->priv;\r\nint ret = 0;\r\nswitch (attr_type) {\r\ncase DOMAIN_ATTR_GEOMETRY:\r\nret = configure_domain_geometry(domain, data);\r\nbreak;\r\ncase DOMAIN_ATTR_FSL_PAMU_STASH:\r\nret = configure_domain_stash(dma_domain, data);\r\nbreak;\r\ncase DOMAIN_ATTR_FSL_PAMU_ENABLE:\r\nret = configure_domain_dma_state(dma_domain, *(int *)data);\r\nbreak;\r\ndefault:\r\npr_debug("Unsupported attribute type\n");\r\nret = -EINVAL;\r\nbreak;\r\n};\r\nreturn ret;\r\n}\r\nstatic int fsl_pamu_get_domain_attr(struct iommu_domain *domain,\r\nenum iommu_attr attr_type, void *data)\r\n{\r\nstruct fsl_dma_domain *dma_domain = domain->priv;\r\nint ret = 0;\r\nswitch (attr_type) {\r\ncase DOMAIN_ATTR_FSL_PAMU_STASH:\r\nmemcpy((struct pamu_stash_attribute *) data, &dma_domain->dma_stash,\r\nsizeof(struct pamu_stash_attribute));\r\nbreak;\r\ncase DOMAIN_ATTR_FSL_PAMU_ENABLE:\r\n*(int *)data = dma_domain->enabled;\r\nbreak;\r\ncase DOMAIN_ATTR_FSL_PAMUV1:\r\n*(int *)data = DOMAIN_ATTR_FSL_PAMUV1;\r\nbreak;\r\ndefault:\r\npr_debug("Unsupported attribute type\n");\r\nret = -EINVAL;\r\nbreak;\r\n};\r\nreturn ret;\r\n}\r\nstatic struct iommu_group *get_device_iommu_group(struct device *dev)\r\n{\r\nstruct iommu_group *group;\r\ngroup = iommu_group_get(dev);\r\nif (!group)\r\ngroup = iommu_group_alloc();\r\nreturn group;\r\n}\r\nstatic bool check_pci_ctl_endpt_part(struct pci_controller *pci_ctl)\r\n{\r\nu32 version;\r\nversion = in_be32(pci_ctl->cfg_addr + (PCI_FSL_BRR1 >> 2));\r\nversion &= PCI_FSL_BRR1_VER;\r\nif (version >= 0x204)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct iommu_group *get_shared_pci_device_group(struct pci_dev *pdev)\r\n{\r\nstruct pci_dev *tmp;\r\nstruct iommu_group *group;\r\nstruct pci_bus *bus = pdev->bus;\r\nwhile (bus) {\r\nlist_for_each_entry(tmp, &bus->devices, bus_list) {\r\nif (tmp == pdev)\r\ncontinue;\r\ngroup = iommu_group_get(&tmp->dev);\r\nif (group)\r\nreturn group;\r\n}\r\nbus = bus->parent;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct iommu_group *get_pci_device_group(struct pci_dev *pdev)\r\n{\r\nstruct pci_controller *pci_ctl;\r\nbool pci_endpt_partioning;\r\nstruct iommu_group *group = NULL;\r\nstruct pci_dev *bridge, *dma_pdev = NULL;\r\npci_ctl = pci_bus_to_host(pdev->bus);\r\npci_endpt_partioning = check_pci_ctl_endpt_part(pci_ctl);\r\nif (pci_endpt_partioning) {\r\nbridge = pci_find_upstream_pcie_bridge(pdev);\r\nif (bridge) {\r\nif (pci_is_pcie(bridge))\r\ndma_pdev = pci_get_domain_bus_and_slot(\r\npci_domain_nr(pdev->bus),\r\nbridge->subordinate->number, 0);\r\nif (!dma_pdev)\r\ndma_pdev = pci_dev_get(bridge);\r\n} else\r\ndma_pdev = pci_dev_get(pdev);\r\nswap_pci_ref(&dma_pdev, pci_get_dma_source(dma_pdev));\r\nif (dma_pdev->multifunction &&\r\n!pci_acs_enabled(dma_pdev, REQ_ACS_FLAGS)) {\r\nu8 i, slot = PCI_SLOT(dma_pdev->devfn);\r\nfor (i = 0; i < 8; i++) {\r\nstruct pci_dev *tmp;\r\ntmp = pci_get_slot(dma_pdev->bus, PCI_DEVFN(slot, i));\r\nif (!tmp)\r\ncontinue;\r\nif (!pci_acs_enabled(tmp, REQ_ACS_FLAGS)) {\r\nswap_pci_ref(&dma_pdev, tmp);\r\nbreak;\r\n}\r\npci_dev_put(tmp);\r\n}\r\n}\r\nwhile (!pci_is_root_bus(dma_pdev->bus)) {\r\nstruct pci_bus *bus = dma_pdev->bus;\r\nwhile (!bus->self) {\r\nif (!pci_is_root_bus(bus))\r\nbus = bus->parent;\r\nelse\r\ngoto root_bus;\r\n}\r\nif (pci_acs_path_enabled(bus->self, NULL, REQ_ACS_FLAGS))\r\nbreak;\r\nswap_pci_ref(&dma_pdev, pci_dev_get(bus->self));\r\n}\r\nroot_bus:\r\ngroup = get_device_iommu_group(&dma_pdev->dev);\r\npci_dev_put(dma_pdev);\r\nif (pci_ctl->parent->iommu_group)\r\niommu_group_remove_device(pci_ctl->parent);\r\n} else {\r\nif (pci_ctl->parent->iommu_group) {\r\ngroup = get_device_iommu_group(pci_ctl->parent);\r\niommu_group_remove_device(pci_ctl->parent);\r\n} else\r\ngroup = get_shared_pci_device_group(pdev);\r\n}\r\nreturn group;\r\n}\r\nstatic int fsl_pamu_add_device(struct device *dev)\r\n{\r\nstruct iommu_group *group = NULL;\r\nstruct pci_dev *pdev;\r\nconst u32 *prop;\r\nint ret, len;\r\nif (dev_is_pci(dev)) {\r\npdev = to_pci_dev(dev);\r\nif (pdev->subordinate)\r\nreturn 0;\r\ngroup = get_pci_device_group(pdev);\r\n} else {\r\nprop = of_get_property(dev->of_node, "fsl,liodn", &len);\r\nif (prop)\r\ngroup = get_device_iommu_group(dev);\r\n}\r\nif (!group || IS_ERR(group))\r\nreturn PTR_ERR(group);\r\nret = iommu_group_add_device(group, dev);\r\niommu_group_put(group);\r\nreturn ret;\r\n}\r\nstatic void fsl_pamu_remove_device(struct device *dev)\r\n{\r\niommu_group_remove_device(dev);\r\n}\r\nstatic int fsl_pamu_set_windows(struct iommu_domain *domain, u32 w_count)\r\n{\r\nstruct fsl_dma_domain *dma_domain = domain->priv;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&dma_domain->domain_lock, flags);\r\nif (dma_domain->enabled) {\r\npr_debug("Can't set geometry attributes as domain is active\n");\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn -EBUSY;\r\n}\r\nif (!dma_domain->geom_size) {\r\npr_debug("Please configure geometry before setting the number of windows\n");\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nif (w_count > pamu_get_max_subwin_cnt() || !is_power_of_2(w_count)) {\r\npr_debug("Invalid window count\n");\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nret = pamu_set_domain_geometry(dma_domain, &domain->geometry,\r\n((w_count > 1) ? w_count : 0));\r\nif (!ret) {\r\nif (dma_domain->win_arr)\r\nkfree(dma_domain->win_arr);\r\ndma_domain->win_arr = kzalloc(sizeof(struct dma_window) *\r\nw_count, GFP_ATOMIC);\r\nif (!dma_domain->win_arr) {\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn -ENOMEM;\r\n}\r\ndma_domain->win_cnt = w_count;\r\n}\r\nspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\r\nreturn ret;\r\n}\r\nstatic u32 fsl_pamu_get_windows(struct iommu_domain *domain)\r\n{\r\nstruct fsl_dma_domain *dma_domain = domain->priv;\r\nreturn dma_domain->win_cnt;\r\n}\r\nint pamu_domain_init()\r\n{\r\nint ret = 0;\r\nret = iommu_init_mempool();\r\nif (ret)\r\nreturn ret;\r\nbus_set_iommu(&platform_bus_type, &fsl_pamu_ops);\r\nbus_set_iommu(&pci_bus_type, &fsl_pamu_ops);\r\nreturn ret;\r\n}
