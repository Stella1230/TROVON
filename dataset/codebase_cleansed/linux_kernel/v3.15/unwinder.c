static struct unwinder *select_unwinder(void)\r\n{\r\nstruct unwinder *best;\r\nif (list_empty(&unwinder_list))\r\nreturn NULL;\r\nbest = list_entry(unwinder_list.next, struct unwinder, list);\r\nif (best == curr_unwinder)\r\nreturn NULL;\r\nreturn best;\r\n}\r\nstatic int unwinder_enqueue(struct unwinder *ops)\r\n{\r\nstruct list_head *tmp, *entry = &unwinder_list;\r\nlist_for_each(tmp, &unwinder_list) {\r\nstruct unwinder *o;\r\no = list_entry(tmp, struct unwinder, list);\r\nif (o == ops)\r\nreturn -EBUSY;\r\nif (o->rating >= ops->rating)\r\nentry = tmp;\r\n}\r\nlist_add(&ops->list, entry);\r\nreturn 0;\r\n}\r\nint unwinder_register(struct unwinder *u)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&unwinder_lock, flags);\r\nret = unwinder_enqueue(u);\r\nif (!ret)\r\ncurr_unwinder = select_unwinder();\r\nspin_unlock_irqrestore(&unwinder_lock, flags);\r\nreturn ret;\r\n}\r\nvoid unwind_stack(struct task_struct *task, struct pt_regs *regs,\r\nunsigned long *sp, const struct stacktrace_ops *ops,\r\nvoid *data)\r\n{\r\nunsigned long flags;\r\nif (unwinder_faulted) {\r\nspin_lock_irqsave(&unwinder_lock, flags);\r\nif (unwinder_faulted && !list_is_singular(&unwinder_list)) {\r\nlist_del(&curr_unwinder->list);\r\ncurr_unwinder = select_unwinder();\r\nunwinder_faulted = 0;\r\n}\r\nspin_unlock_irqrestore(&unwinder_lock, flags);\r\n}\r\ncurr_unwinder->dump(task, regs, sp, ops, data);\r\n}
