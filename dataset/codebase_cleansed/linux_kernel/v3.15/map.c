static inline int is_anon_memory(const char *filename)\r\n{\r\nreturn !strcmp(filename, "//anon") ||\r\n!strcmp(filename, "/dev/zero (deleted)") ||\r\n!strcmp(filename, "/anon_hugepage (deleted)");\r\n}\r\nstatic inline int is_no_dso_memory(const char *filename)\r\n{\r\nreturn !strncmp(filename, "[stack", 6) ||\r\n!strcmp(filename, "[heap]");\r\n}\r\nvoid map__init(struct map *map, enum map_type type,\r\nu64 start, u64 end, u64 pgoff, struct dso *dso)\r\n{\r\nmap->type = type;\r\nmap->start = start;\r\nmap->end = end;\r\nmap->pgoff = pgoff;\r\nmap->reloc = 0;\r\nmap->dso = dso;\r\nmap->map_ip = map__map_ip;\r\nmap->unmap_ip = map__unmap_ip;\r\nRB_CLEAR_NODE(&map->rb_node);\r\nmap->groups = NULL;\r\nmap->referenced = false;\r\nmap->erange_warned = false;\r\n}\r\nstruct map *map__new(struct list_head *dsos__list, u64 start, u64 len,\r\nu64 pgoff, u32 pid, u32 d_maj, u32 d_min, u64 ino,\r\nu64 ino_gen, char *filename,\r\nenum map_type type)\r\n{\r\nstruct map *map = malloc(sizeof(*map));\r\nif (map != NULL) {\r\nchar newfilename[PATH_MAX];\r\nstruct dso *dso;\r\nint anon, no_dso, vdso;\r\nanon = is_anon_memory(filename);\r\nvdso = is_vdso_map(filename);\r\nno_dso = is_no_dso_memory(filename);\r\nmap->maj = d_maj;\r\nmap->min = d_min;\r\nmap->ino = ino;\r\nmap->ino_generation = ino_gen;\r\nif ((anon || no_dso) && type == MAP__FUNCTION) {\r\nsnprintf(newfilename, sizeof(newfilename), "/tmp/perf-%d.map", pid);\r\nfilename = newfilename;\r\n}\r\nif (vdso) {\r\npgoff = 0;\r\ndso = vdso__dso_findnew(dsos__list);\r\n} else\r\ndso = __dsos__findnew(dsos__list, filename);\r\nif (dso == NULL)\r\ngoto out_delete;\r\nmap__init(map, type, start, start + len, pgoff, dso);\r\nif (anon || no_dso) {\r\nmap->map_ip = map->unmap_ip = identity__map_ip;\r\nif (type != MAP__FUNCTION)\r\ndso__set_loaded(dso, map->type);\r\n}\r\n}\r\nreturn map;\r\nout_delete:\r\nfree(map);\r\nreturn NULL;\r\n}\r\nstruct map *map__new2(u64 start, struct dso *dso, enum map_type type)\r\n{\r\nstruct map *map = calloc(1, (sizeof(*map) +\r\n(dso->kernel ? sizeof(struct kmap) : 0)));\r\nif (map != NULL) {\r\nmap__init(map, type, start, 0, 0, dso);\r\n}\r\nreturn map;\r\n}\r\nvoid map__delete(struct map *map)\r\n{\r\nfree(map);\r\n}\r\nvoid map__fixup_start(struct map *map)\r\n{\r\nstruct rb_root *symbols = &map->dso->symbols[map->type];\r\nstruct rb_node *nd = rb_first(symbols);\r\nif (nd != NULL) {\r\nstruct symbol *sym = rb_entry(nd, struct symbol, rb_node);\r\nmap->start = sym->start;\r\n}\r\n}\r\nvoid map__fixup_end(struct map *map)\r\n{\r\nstruct rb_root *symbols = &map->dso->symbols[map->type];\r\nstruct rb_node *nd = rb_last(symbols);\r\nif (nd != NULL) {\r\nstruct symbol *sym = rb_entry(nd, struct symbol, rb_node);\r\nmap->end = sym->end;\r\n}\r\n}\r\nint map__load(struct map *map, symbol_filter_t filter)\r\n{\r\nconst char *name = map->dso->long_name;\r\nint nr;\r\nif (dso__loaded(map->dso, map->type))\r\nreturn 0;\r\nnr = dso__load(map->dso, map, filter);\r\nif (nr < 0) {\r\nif (map->dso->has_build_id) {\r\nchar sbuild_id[BUILD_ID_SIZE * 2 + 1];\r\nbuild_id__sprintf(map->dso->build_id,\r\nsizeof(map->dso->build_id),\r\nsbuild_id);\r\npr_warning("%s with build id %s not found",\r\nname, sbuild_id);\r\n} else\r\npr_warning("Failed to open %s", name);\r\npr_warning(", continuing without symbols\n");\r\nreturn -1;\r\n} else if (nr == 0) {\r\n#ifdef HAVE_LIBELF_SUPPORT\r\nconst size_t len = strlen(name);\r\nconst size_t real_len = len - sizeof(DSO__DELETED);\r\nif (len > sizeof(DSO__DELETED) &&\r\nstrcmp(name + real_len + 1, DSO__DELETED) == 0) {\r\npr_warning("%.*s was updated (is prelink enabled?). "\r\n"Restart the long running apps that use it!\n",\r\n(int)real_len, name);\r\n} else {\r\npr_warning("no symbols found in %s, maybe install "\r\n"a debug package?\n", name);\r\n}\r\n#endif\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstruct symbol *map__find_symbol(struct map *map, u64 addr,\r\nsymbol_filter_t filter)\r\n{\r\nif (map__load(map, filter) < 0)\r\nreturn NULL;\r\nreturn dso__find_symbol(map->dso, map->type, addr);\r\n}\r\nstruct symbol *map__find_symbol_by_name(struct map *map, const char *name,\r\nsymbol_filter_t filter)\r\n{\r\nif (map__load(map, filter) < 0)\r\nreturn NULL;\r\nif (!dso__sorted_by_name(map->dso, map->type))\r\ndso__sort_by_name(map->dso, map->type);\r\nreturn dso__find_symbol_by_name(map->dso, map->type, name);\r\n}\r\nstruct map *map__clone(struct map *map)\r\n{\r\nreturn memdup(map, sizeof(*map));\r\n}\r\nint map__overlap(struct map *l, struct map *r)\r\n{\r\nif (l->start > r->start) {\r\nstruct map *t = l;\r\nl = r;\r\nr = t;\r\n}\r\nif (l->end > r->start)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nsize_t map__fprintf(struct map *map, FILE *fp)\r\n{\r\nreturn fprintf(fp, " %" PRIx64 "-%" PRIx64 " %" PRIx64 " %s\n",\r\nmap->start, map->end, map->pgoff, map->dso->name);\r\n}\r\nsize_t map__fprintf_dsoname(struct map *map, FILE *fp)\r\n{\r\nconst char *dsoname = "[unknown]";\r\nif (map && map->dso && (map->dso->name || map->dso->long_name)) {\r\nif (symbol_conf.show_kernel_path && map->dso->long_name)\r\ndsoname = map->dso->long_name;\r\nelse if (map->dso->name)\r\ndsoname = map->dso->name;\r\n}\r\nreturn fprintf(fp, "%s", dsoname);\r\n}\r\nint map__fprintf_srcline(struct map *map, u64 addr, const char *prefix,\r\nFILE *fp)\r\n{\r\nchar *srcline;\r\nint ret = 0;\r\nif (map && map->dso) {\r\nsrcline = get_srcline(map->dso,\r\nmap__rip_2objdump(map, addr));\r\nif (srcline != SRCLINE_UNKNOWN)\r\nret = fprintf(fp, "%s%s", prefix, srcline);\r\nfree_srcline(srcline);\r\n}\r\nreturn ret;\r\n}\r\nu64 map__rip_2objdump(struct map *map, u64 rip)\r\n{\r\nif (!map->dso->adjust_symbols)\r\nreturn rip;\r\nif (map->dso->rel)\r\nreturn rip - map->pgoff;\r\nreturn map->unmap_ip(map, rip) - map->reloc;\r\n}\r\nu64 map__objdump_2mem(struct map *map, u64 ip)\r\n{\r\nif (!map->dso->adjust_symbols)\r\nreturn map->unmap_ip(map, ip);\r\nif (map->dso->rel)\r\nreturn map->unmap_ip(map, ip + map->pgoff);\r\nreturn ip + map->reloc;\r\n}\r\nvoid map_groups__init(struct map_groups *mg)\r\n{\r\nint i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i) {\r\nmg->maps[i] = RB_ROOT;\r\nINIT_LIST_HEAD(&mg->removed_maps[i]);\r\n}\r\nmg->machine = NULL;\r\n}\r\nstatic void maps__delete(struct rb_root *maps)\r\n{\r\nstruct rb_node *next = rb_first(maps);\r\nwhile (next) {\r\nstruct map *pos = rb_entry(next, struct map, rb_node);\r\nnext = rb_next(&pos->rb_node);\r\nrb_erase(&pos->rb_node, maps);\r\nmap__delete(pos);\r\n}\r\n}\r\nstatic void maps__delete_removed(struct list_head *maps)\r\n{\r\nstruct map *pos, *n;\r\nlist_for_each_entry_safe(pos, n, maps, node) {\r\nlist_del(&pos->node);\r\nmap__delete(pos);\r\n}\r\n}\r\nvoid map_groups__exit(struct map_groups *mg)\r\n{\r\nint i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i) {\r\nmaps__delete(&mg->maps[i]);\r\nmaps__delete_removed(&mg->removed_maps[i]);\r\n}\r\n}\r\nvoid map_groups__flush(struct map_groups *mg)\r\n{\r\nint type;\r\nfor (type = 0; type < MAP__NR_TYPES; type++) {\r\nstruct rb_root *root = &mg->maps[type];\r\nstruct rb_node *next = rb_first(root);\r\nwhile (next) {\r\nstruct map *pos = rb_entry(next, struct map, rb_node);\r\nnext = rb_next(&pos->rb_node);\r\nrb_erase(&pos->rb_node, root);\r\nlist_add_tail(&pos->node, &mg->removed_maps[pos->type]);\r\n}\r\n}\r\n}\r\nstruct symbol *map_groups__find_symbol(struct map_groups *mg,\r\nenum map_type type, u64 addr,\r\nstruct map **mapp,\r\nsymbol_filter_t filter)\r\n{\r\nstruct map *map = map_groups__find(mg, type, addr);\r\nif (map != NULL && map__load(map, filter) >= 0) {\r\nif (mapp != NULL)\r\n*mapp = map;\r\nreturn map__find_symbol(map, map->map_ip(map, addr), filter);\r\n}\r\nreturn NULL;\r\n}\r\nstruct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,\r\nenum map_type type,\r\nconst char *name,\r\nstruct map **mapp,\r\nsymbol_filter_t filter)\r\n{\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&mg->maps[type]); nd; nd = rb_next(nd)) {\r\nstruct map *pos = rb_entry(nd, struct map, rb_node);\r\nstruct symbol *sym = map__find_symbol_by_name(pos, name, filter);\r\nif (sym == NULL)\r\ncontinue;\r\nif (mapp != NULL)\r\n*mapp = pos;\r\nreturn sym;\r\n}\r\nreturn NULL;\r\n}\r\nint map_groups__find_ams(struct addr_map_symbol *ams, symbol_filter_t filter)\r\n{\r\nif (ams->addr < ams->map->start || ams->addr > ams->map->end) {\r\nif (ams->map->groups == NULL)\r\nreturn -1;\r\nams->map = map_groups__find(ams->map->groups, ams->map->type,\r\nams->addr);\r\nif (ams->map == NULL)\r\nreturn -1;\r\n}\r\nams->al_addr = ams->map->map_ip(ams->map, ams->addr);\r\nams->sym = map__find_symbol(ams->map, ams->al_addr, filter);\r\nreturn ams->sym ? 0 : -1;\r\n}\r\nsize_t __map_groups__fprintf_maps(struct map_groups *mg,\r\nenum map_type type, int verbose, FILE *fp)\r\n{\r\nsize_t printed = fprintf(fp, "%s:\n", map_type__name[type]);\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&mg->maps[type]); nd; nd = rb_next(nd)) {\r\nstruct map *pos = rb_entry(nd, struct map, rb_node);\r\nprinted += fprintf(fp, "Map:");\r\nprinted += map__fprintf(pos, fp);\r\nif (verbose > 2) {\r\nprinted += dso__fprintf(pos->dso, type, fp);\r\nprinted += fprintf(fp, "--\n");\r\n}\r\n}\r\nreturn printed;\r\n}\r\nsize_t map_groups__fprintf_maps(struct map_groups *mg, int verbose, FILE *fp)\r\n{\r\nsize_t printed = 0, i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i)\r\nprinted += __map_groups__fprintf_maps(mg, i, verbose, fp);\r\nreturn printed;\r\n}\r\nstatic size_t __map_groups__fprintf_removed_maps(struct map_groups *mg,\r\nenum map_type type,\r\nint verbose, FILE *fp)\r\n{\r\nstruct map *pos;\r\nsize_t printed = 0;\r\nlist_for_each_entry(pos, &mg->removed_maps[type], node) {\r\nprinted += fprintf(fp, "Map:");\r\nprinted += map__fprintf(pos, fp);\r\nif (verbose > 1) {\r\nprinted += dso__fprintf(pos->dso, type, fp);\r\nprinted += fprintf(fp, "--\n");\r\n}\r\n}\r\nreturn printed;\r\n}\r\nstatic size_t map_groups__fprintf_removed_maps(struct map_groups *mg,\r\nint verbose, FILE *fp)\r\n{\r\nsize_t printed = 0, i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i)\r\nprinted += __map_groups__fprintf_removed_maps(mg, i, verbose, fp);\r\nreturn printed;\r\n}\r\nsize_t map_groups__fprintf(struct map_groups *mg, int verbose, FILE *fp)\r\n{\r\nsize_t printed = map_groups__fprintf_maps(mg, verbose, fp);\r\nprinted += fprintf(fp, "Removed maps:\n");\r\nreturn printed + map_groups__fprintf_removed_maps(mg, verbose, fp);\r\n}\r\nint map_groups__fixup_overlappings(struct map_groups *mg, struct map *map,\r\nint verbose, FILE *fp)\r\n{\r\nstruct rb_root *root = &mg->maps[map->type];\r\nstruct rb_node *next = rb_first(root);\r\nint err = 0;\r\nwhile (next) {\r\nstruct map *pos = rb_entry(next, struct map, rb_node);\r\nnext = rb_next(&pos->rb_node);\r\nif (!map__overlap(pos, map))\r\ncontinue;\r\nif (verbose >= 2) {\r\nfputs("overlapping maps:\n", fp);\r\nmap__fprintf(map, fp);\r\nmap__fprintf(pos, fp);\r\n}\r\nrb_erase(&pos->rb_node, root);\r\nif (map->start > pos->start) {\r\nstruct map *before = map__clone(pos);\r\nif (before == NULL) {\r\nerr = -ENOMEM;\r\ngoto move_map;\r\n}\r\nbefore->end = map->start - 1;\r\nmap_groups__insert(mg, before);\r\nif (verbose >= 2)\r\nmap__fprintf(before, fp);\r\n}\r\nif (map->end < pos->end) {\r\nstruct map *after = map__clone(pos);\r\nif (after == NULL) {\r\nerr = -ENOMEM;\r\ngoto move_map;\r\n}\r\nafter->start = map->end + 1;\r\nmap_groups__insert(mg, after);\r\nif (verbose >= 2)\r\nmap__fprintf(after, fp);\r\n}\r\nmove_map:\r\nif (pos->referenced)\r\nlist_add_tail(&pos->node, &mg->removed_maps[map->type]);\r\nelse\r\nmap__delete(pos);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint map_groups__clone(struct map_groups *mg,\r\nstruct map_groups *parent, enum map_type type)\r\n{\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&parent->maps[type]); nd; nd = rb_next(nd)) {\r\nstruct map *map = rb_entry(nd, struct map, rb_node);\r\nstruct map *new = map__clone(map);\r\nif (new == NULL)\r\nreturn -ENOMEM;\r\nmap_groups__insert(mg, new);\r\n}\r\nreturn 0;\r\n}\r\nvoid maps__insert(struct rb_root *maps, struct map *map)\r\n{\r\nstruct rb_node **p = &maps->rb_node;\r\nstruct rb_node *parent = NULL;\r\nconst u64 ip = map->start;\r\nstruct map *m;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nm = rb_entry(parent, struct map, rb_node);\r\nif (ip < m->start)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&map->rb_node, parent, p);\r\nrb_insert_color(&map->rb_node, maps);\r\n}\r\nvoid maps__remove(struct rb_root *maps, struct map *map)\r\n{\r\nrb_erase(&map->rb_node, maps);\r\n}\r\nstruct map *maps__find(struct rb_root *maps, u64 ip)\r\n{\r\nstruct rb_node **p = &maps->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct map *m;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nm = rb_entry(parent, struct map, rb_node);\r\nif (ip < m->start)\r\np = &(*p)->rb_left;\r\nelse if (ip > m->end)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn m;\r\n}\r\nreturn NULL;\r\n}\r\nstruct map *maps__first(struct rb_root *maps)\r\n{\r\nstruct rb_node *first = rb_first(maps);\r\nif (first)\r\nreturn rb_entry(first, struct map, rb_node);\r\nreturn NULL;\r\n}\r\nstruct map *maps__next(struct map *map)\r\n{\r\nstruct rb_node *next = rb_next(&map->rb_node);\r\nif (next)\r\nreturn rb_entry(next, struct map, rb_node);\r\nreturn NULL;\r\n}
