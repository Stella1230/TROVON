static void orion_nand_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct nand_chip *nc = mtd->priv;\r\nstruct orion_nand_data *board = nc->priv;\r\nu32 offs;\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\noffs = (1 << board->cle);\r\nelse if (ctrl & NAND_ALE)\r\noffs = (1 << board->ale);\r\nelse\r\nreturn;\r\nif (nc->options & NAND_BUSWIDTH_16)\r\noffs <<= 1;\r\nwriteb(cmd, nc->IO_ADDR_W + offs);\r\n}\r\nstatic void orion_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nvoid __iomem *io_base = chip->IO_ADDR_R;\r\nuint64_t *buf64;\r\nint i = 0;\r\nwhile (len && (unsigned long)buf & 7) {\r\n*buf++ = readb(io_base);\r\nlen--;\r\n}\r\nbuf64 = (uint64_t *)buf;\r\nwhile (i < len/8) {\r\nregister uint64_t x asm ("r2");\r\nasm volatile ("ldrd\t%0, [%1]" : "=&r" (x) : "r" (io_base));\r\nbuf64[i++] = x;\r\n}\r\ni *= 8;\r\nwhile (i < len)\r\nbuf[i++] = readb(io_base);\r\n}\r\nstatic int __init orion_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct mtd_info *mtd;\r\nstruct mtd_part_parser_data ppdata = {};\r\nstruct nand_chip *nc;\r\nstruct orion_nand_data *board;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nvoid __iomem *io_base;\r\nint ret = 0;\r\nu32 val = 0;\r\nnc = kzalloc(sizeof(struct nand_chip) + sizeof(struct mtd_info), GFP_KERNEL);\r\nif (!nc) {\r\nret = -ENOMEM;\r\ngoto no_res;\r\n}\r\nmtd = (struct mtd_info *)(nc + 1);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\ngoto no_res;\r\n}\r\nio_base = ioremap(res->start, resource_size(res));\r\nif (!io_base) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -EIO;\r\ngoto no_res;\r\n}\r\nif (pdev->dev.of_node) {\r\nboard = devm_kzalloc(&pdev->dev, sizeof(struct orion_nand_data),\r\nGFP_KERNEL);\r\nif (!board) {\r\nret = -ENOMEM;\r\ngoto no_res;\r\n}\r\nif (!of_property_read_u32(pdev->dev.of_node, "cle", &val))\r\nboard->cle = (u8)val;\r\nelse\r\nboard->cle = 0;\r\nif (!of_property_read_u32(pdev->dev.of_node, "ale", &val))\r\nboard->ale = (u8)val;\r\nelse\r\nboard->ale = 1;\r\nif (!of_property_read_u32(pdev->dev.of_node,\r\n"bank-width", &val))\r\nboard->width = (u8)val * 8;\r\nelse\r\nboard->width = 8;\r\nif (!of_property_read_u32(pdev->dev.of_node,\r\n"chip-delay", &val))\r\nboard->chip_delay = (u8)val;\r\n} else {\r\nboard = dev_get_platdata(&pdev->dev);\r\n}\r\nmtd->priv = nc;\r\nmtd->owner = THIS_MODULE;\r\nnc->priv = board;\r\nnc->IO_ADDR_R = nc->IO_ADDR_W = io_base;\r\nnc->cmd_ctrl = orion_nand_cmd_ctrl;\r\nnc->read_buf = orion_nand_read_buf;\r\nnc->ecc.mode = NAND_ECC_SOFT;\r\nif (board->chip_delay)\r\nnc->chip_delay = board->chip_delay;\r\nWARN(board->width > 16,\r\n"%d bit bus width out of range",\r\nboard->width);\r\nif (board->width == 16)\r\nnc->options |= NAND_BUSWIDTH_16;\r\nif (board->dev_ready)\r\nnc->dev_ready = board->dev_ready;\r\nplatform_set_drvdata(pdev, mtd);\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(clk)) {\r\nclk_prepare_enable(clk);\r\nclk_put(clk);\r\n}\r\nif (nand_scan(mtd, 1)) {\r\nret = -ENXIO;\r\ngoto no_dev;\r\n}\r\nmtd->name = "orion_nand";\r\nppdata.of_node = pdev->dev.of_node;\r\nret = mtd_device_parse_register(mtd, NULL, &ppdata,\r\nboard->parts, board->nr_parts);\r\nif (ret) {\r\nnand_release(mtd);\r\ngoto no_dev;\r\n}\r\nreturn 0;\r\nno_dev:\r\nif (!IS_ERR(clk)) {\r\nclk_disable_unprepare(clk);\r\nclk_put(clk);\r\n}\r\niounmap(io_base);\r\nno_res:\r\nkfree(nc);\r\nreturn ret;\r\n}\r\nstatic int orion_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct mtd_info *mtd = platform_get_drvdata(pdev);\r\nstruct nand_chip *nc = mtd->priv;\r\nstruct clk *clk;\r\nnand_release(mtd);\r\niounmap(nc->IO_ADDR_W);\r\nkfree(nc);\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(clk)) {\r\nclk_disable_unprepare(clk);\r\nclk_put(clk);\r\n}\r\nreturn 0;\r\n}
