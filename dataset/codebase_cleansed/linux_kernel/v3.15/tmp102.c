static inline int tmp102_reg_to_mC(s16 val)\r\n{\r\nreturn ((val & ~0x01) * 1000) / 128;\r\n}\r\nstatic inline u16 tmp102_mC_to_reg(int val)\r\n{\r\nreturn (val * 128) / 1000;\r\n}\r\nstatic struct tmp102 *tmp102_update_device(struct i2c_client *client)\r\n{\r\nstruct tmp102 *tmp102 = i2c_get_clientdata(client);\r\nmutex_lock(&tmp102->lock);\r\nif (time_after(jiffies, tmp102->last_update + HZ / 3)) {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tmp102->temp); ++i) {\r\nint status = i2c_smbus_read_word_swapped(client,\r\ntmp102_reg[i]);\r\nif (status > -1)\r\ntmp102->temp[i] = tmp102_reg_to_mC(status);\r\n}\r\ntmp102->last_update = jiffies;\r\n}\r\nmutex_unlock(&tmp102->lock);\r\nreturn tmp102;\r\n}\r\nstatic int tmp102_read_temp(void *dev, long *temp)\r\n{\r\nstruct tmp102 *tmp102 = tmp102_update_device(to_i2c_client(dev));\r\n*temp = tmp102->temp[0];\r\nreturn 0;\r\n}\r\nstatic ssize_t tmp102_show_temp(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sda = to_sensor_dev_attr(attr);\r\nstruct tmp102 *tmp102 = tmp102_update_device(to_i2c_client(dev));\r\nreturn sprintf(buf, "%d\n", tmp102->temp[sda->index]);\r\n}\r\nstatic ssize_t tmp102_set_temp(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sda = to_sensor_dev_attr(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct tmp102 *tmp102 = i2c_get_clientdata(client);\r\nlong val;\r\nint status;\r\nif (kstrtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nval = clamp_val(val, -256000, 255000);\r\nmutex_lock(&tmp102->lock);\r\ntmp102->temp[sda->index] = val;\r\nstatus = i2c_smbus_write_word_swapped(client, tmp102_reg[sda->index],\r\ntmp102_mC_to_reg(val));\r\nmutex_unlock(&tmp102->lock);\r\nreturn status ? : count;\r\n}\r\nstatic int tmp102_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tmp102 *tmp102;\r\nint status;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WORD_DATA)) {\r\ndev_err(&client->dev,\r\n"adapter doesn't support SMBus word transactions\n");\r\nreturn -ENODEV;\r\n}\r\ntmp102 = devm_kzalloc(&client->dev, sizeof(*tmp102), GFP_KERNEL);\r\nif (!tmp102)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, tmp102);\r\nstatus = i2c_smbus_read_word_swapped(client, TMP102_CONF_REG);\r\nif (status < 0) {\r\ndev_err(&client->dev, "error reading config register\n");\r\nreturn status;\r\n}\r\ntmp102->config_orig = status;\r\nstatus = i2c_smbus_write_word_swapped(client, TMP102_CONF_REG,\r\nTMP102_CONFIG);\r\nif (status < 0) {\r\ndev_err(&client->dev, "error writing config register\n");\r\ngoto fail_restore_config;\r\n}\r\nstatus = i2c_smbus_read_word_swapped(client, TMP102_CONF_REG);\r\nif (status < 0) {\r\ndev_err(&client->dev, "error reading config register\n");\r\ngoto fail_restore_config;\r\n}\r\nstatus &= ~TMP102_CONFIG_RD_ONLY;\r\nif (status != TMP102_CONFIG) {\r\ndev_err(&client->dev, "config settings did not stick\n");\r\nstatus = -ENODEV;\r\ngoto fail_restore_config;\r\n}\r\ntmp102->last_update = jiffies - HZ;\r\nmutex_init(&tmp102->lock);\r\nstatus = sysfs_create_group(&client->dev.kobj, &tmp102_attr_group);\r\nif (status) {\r\ndev_dbg(&client->dev, "could not create sysfs files\n");\r\ngoto fail_restore_config;\r\n}\r\ntmp102->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(tmp102->hwmon_dev)) {\r\ndev_dbg(&client->dev, "unable to register hwmon device\n");\r\nstatus = PTR_ERR(tmp102->hwmon_dev);\r\ngoto fail_remove_sysfs;\r\n}\r\ntmp102->tz = thermal_zone_of_sensor_register(&client->dev, 0,\r\n&client->dev,\r\ntmp102_read_temp, NULL);\r\nif (IS_ERR(tmp102->tz))\r\ntmp102->tz = NULL;\r\ndev_info(&client->dev, "initialized\n");\r\nreturn 0;\r\nfail_remove_sysfs:\r\nsysfs_remove_group(&client->dev.kobj, &tmp102_attr_group);\r\nfail_restore_config:\r\ni2c_smbus_write_word_swapped(client, TMP102_CONF_REG,\r\ntmp102->config_orig);\r\nreturn status;\r\n}\r\nstatic int tmp102_remove(struct i2c_client *client)\r\n{\r\nstruct tmp102 *tmp102 = i2c_get_clientdata(client);\r\nthermal_zone_of_sensor_unregister(&client->dev, tmp102->tz);\r\nhwmon_device_unregister(tmp102->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &tmp102_attr_group);\r\nif (tmp102->config_orig & TMP102_CONF_SD) {\r\nint config;\r\nconfig = i2c_smbus_read_word_swapped(client, TMP102_CONF_REG);\r\nif (config >= 0)\r\ni2c_smbus_write_word_swapped(client, TMP102_CONF_REG,\r\nconfig | TMP102_CONF_SD);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tmp102_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint config;\r\nconfig = i2c_smbus_read_word_swapped(client, TMP102_CONF_REG);\r\nif (config < 0)\r\nreturn config;\r\nconfig |= TMP102_CONF_SD;\r\nreturn i2c_smbus_write_word_swapped(client, TMP102_CONF_REG, config);\r\n}\r\nstatic int tmp102_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint config;\r\nconfig = i2c_smbus_read_word_swapped(client, TMP102_CONF_REG);\r\nif (config < 0)\r\nreturn config;\r\nconfig &= ~TMP102_CONF_SD;\r\nreturn i2c_smbus_write_word_swapped(client, TMP102_CONF_REG, config);\r\n}
