static unsigned long osc_get_rate(struct clk *clk)\r\n{\r\nreturn at32_board_osc_rates[clk->index];\r\n}\r\nstatic unsigned long pll_get_rate(struct clk *clk, unsigned long control)\r\n{\r\nunsigned long div, mul, rate;\r\ndiv = PM_BFEXT(PLLDIV, control) + 1;\r\nmul = PM_BFEXT(PLLMUL, control) + 1;\r\nrate = clk->parent->get_rate(clk->parent);\r\nrate = (rate + div / 2) / div;\r\nrate *= mul;\r\nreturn rate;\r\n}\r\nstatic long pll_set_rate(struct clk *clk, unsigned long rate,\r\nu32 *pll_ctrl)\r\n{\r\nunsigned long mul;\r\nunsigned long mul_best_fit = 0;\r\nunsigned long div;\r\nunsigned long div_min;\r\nunsigned long div_max;\r\nunsigned long div_best_fit = 0;\r\nunsigned long base;\r\nunsigned long pll_in;\r\nunsigned long actual = 0;\r\nunsigned long rate_error;\r\nunsigned long rate_error_prev = ~0UL;\r\nu32 ctrl;\r\nif (rate < 80000000UL || rate > 200000000UL)\r\nreturn -EINVAL;\r\nctrl = PM_BF(PLLOPT, 4);\r\nbase = clk->parent->get_rate(clk->parent);\r\ndiv_min = DIV_ROUND_UP(base, 32000000UL);\r\ndiv_max = base / 6000000UL;\r\nif (div_max < div_min)\r\nreturn -EINVAL;\r\nfor (div = div_min; div <= div_max; div++) {\r\npll_in = (base + div / 2) / div;\r\nmul = (rate + pll_in / 2) / pll_in;\r\nif (mul == 0)\r\ncontinue;\r\nactual = pll_in * mul;\r\nrate_error = abs(actual - rate);\r\nif (rate_error < rate_error_prev) {\r\nmul_best_fit = mul;\r\ndiv_best_fit = div;\r\nrate_error_prev = rate_error;\r\n}\r\nif (rate_error == 0)\r\nbreak;\r\n}\r\nif (div_best_fit == 0)\r\nreturn -EINVAL;\r\nctrl |= PM_BF(PLLMUL, mul_best_fit - 1);\r\nctrl |= PM_BF(PLLDIV, div_best_fit - 1);\r\nctrl |= PM_BF(PLLCOUNT, 16);\r\nif (clk->parent == &osc1)\r\nctrl |= PM_BIT(PLLOSC);\r\n*pll_ctrl = ctrl;\r\nreturn actual;\r\n}\r\nstatic unsigned long pll0_get_rate(struct clk *clk)\r\n{\r\nu32 control;\r\ncontrol = pm_readl(PLL0);\r\nreturn pll_get_rate(clk, control);\r\n}\r\nstatic void pll1_mode(struct clk *clk, int enabled)\r\n{\r\nunsigned long timeout;\r\nu32 status;\r\nu32 ctrl;\r\nctrl = pm_readl(PLL1);\r\nif (enabled) {\r\nif (!PM_BFEXT(PLLMUL, ctrl) && !PM_BFEXT(PLLDIV, ctrl)) {\r\npr_debug("clk %s: failed to enable, rate not set\n",\r\nclk->name);\r\nreturn;\r\n}\r\nctrl |= PM_BIT(PLLEN);\r\npm_writel(PLL1, ctrl);\r\nfor (timeout = 10000; timeout; timeout--) {\r\nstatus = pm_readl(ISR);\r\nif (status & PM_BIT(LOCK1))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!(status & PM_BIT(LOCK1)))\r\nprintk(KERN_ERR "clk %s: timeout waiting for lock\n",\r\nclk->name);\r\n} else {\r\nctrl &= ~PM_BIT(PLLEN);\r\npm_writel(PLL1, ctrl);\r\n}\r\n}\r\nstatic unsigned long pll1_get_rate(struct clk *clk)\r\n{\r\nu32 control;\r\ncontrol = pm_readl(PLL1);\r\nreturn pll_get_rate(clk, control);\r\n}\r\nstatic long pll1_set_rate(struct clk *clk, unsigned long rate, int apply)\r\n{\r\nu32 ctrl = 0;\r\nunsigned long actual_rate;\r\nactual_rate = pll_set_rate(clk, rate, &ctrl);\r\nif (apply) {\r\nif (actual_rate != rate)\r\nreturn -EINVAL;\r\nif (clk->users > 0)\r\nreturn -EBUSY;\r\npr_debug(KERN_INFO "clk %s: new rate %lu (actual rate %lu)\n",\r\nclk->name, rate, actual_rate);\r\npm_writel(PLL1, ctrl);\r\n}\r\nreturn actual_rate;\r\n}\r\nstatic int pll1_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 ctrl;\r\nif (clk->users > 0)\r\nreturn -EBUSY;\r\nctrl = pm_readl(PLL1);\r\nWARN_ON(ctrl & PM_BIT(PLLEN));\r\nif (parent == &osc0)\r\nctrl &= ~PM_BIT(PLLOSC);\r\nelse if (parent == &osc1)\r\nctrl |= PM_BIT(PLLOSC);\r\nelse\r\nreturn -EINVAL;\r\npm_writel(PLL1, ctrl);\r\nclk->parent = parent;\r\nreturn 0;\r\n}\r\nstatic unsigned long bus_clk_get_rate(struct clk *clk, unsigned int shift)\r\n{\r\nreturn main_clock->get_rate(main_clock) >> shift;\r\n}\r\nstatic void cpu_clk_mode(struct clk *clk, int enabled)\r\n{\r\nunsigned long flags;\r\nu32 mask;\r\nspin_lock_irqsave(&pm_lock, flags);\r\nmask = pm_readl(CPU_MASK);\r\nif (enabled)\r\nmask |= 1 << clk->index;\r\nelse\r\nmask &= ~(1 << clk->index);\r\npm_writel(CPU_MASK, mask);\r\nspin_unlock_irqrestore(&pm_lock, flags);\r\n}\r\nstatic unsigned long cpu_clk_get_rate(struct clk *clk)\r\n{\r\nunsigned long cksel, shift = 0;\r\ncksel = pm_readl(CKSEL);\r\nif (cksel & PM_BIT(CPUDIV))\r\nshift = PM_BFEXT(CPUSEL, cksel) + 1;\r\nreturn bus_clk_get_rate(clk, shift);\r\n}\r\nstatic long cpu_clk_set_rate(struct clk *clk, unsigned long rate, int apply)\r\n{\r\nu32 control;\r\nunsigned long parent_rate, child_div, actual_rate, div;\r\nparent_rate = clk->parent->get_rate(clk->parent);\r\ncontrol = pm_readl(CKSEL);\r\nif (control & PM_BIT(HSBDIV))\r\nchild_div = 1 << (PM_BFEXT(HSBSEL, control) + 1);\r\nelse\r\nchild_div = 1;\r\nif (rate > 3 * (parent_rate / 4) || child_div == 1) {\r\nactual_rate = parent_rate;\r\ncontrol &= ~PM_BIT(CPUDIV);\r\n} else {\r\nunsigned int cpusel;\r\ndiv = (parent_rate + rate / 2) / rate;\r\nif (div > child_div)\r\ndiv = child_div;\r\ncpusel = (div > 1) ? (fls(div) - 2) : 0;\r\ncontrol = PM_BIT(CPUDIV) | PM_BFINS(CPUSEL, cpusel, control);\r\nactual_rate = parent_rate / (1 << (cpusel + 1));\r\n}\r\npr_debug("clk %s: new rate %lu (actual rate %lu)\n",\r\nclk->name, rate, actual_rate);\r\nif (apply)\r\npm_writel(CKSEL, control);\r\nreturn actual_rate;\r\n}\r\nstatic void hsb_clk_mode(struct clk *clk, int enabled)\r\n{\r\nunsigned long flags;\r\nu32 mask;\r\nspin_lock_irqsave(&pm_lock, flags);\r\nmask = pm_readl(HSB_MASK);\r\nif (enabled)\r\nmask |= 1 << clk->index;\r\nelse\r\nmask &= ~(1 << clk->index);\r\npm_writel(HSB_MASK, mask);\r\nspin_unlock_irqrestore(&pm_lock, flags);\r\n}\r\nstatic unsigned long hsb_clk_get_rate(struct clk *clk)\r\n{\r\nunsigned long cksel, shift = 0;\r\ncksel = pm_readl(CKSEL);\r\nif (cksel & PM_BIT(HSBDIV))\r\nshift = PM_BFEXT(HSBSEL, cksel) + 1;\r\nreturn bus_clk_get_rate(clk, shift);\r\n}\r\nvoid pba_clk_mode(struct clk *clk, int enabled)\r\n{\r\nunsigned long flags;\r\nu32 mask;\r\nspin_lock_irqsave(&pm_lock, flags);\r\nmask = pm_readl(PBA_MASK);\r\nif (enabled)\r\nmask |= 1 << clk->index;\r\nelse\r\nmask &= ~(1 << clk->index);\r\npm_writel(PBA_MASK, mask);\r\nspin_unlock_irqrestore(&pm_lock, flags);\r\n}\r\nunsigned long pba_clk_get_rate(struct clk *clk)\r\n{\r\nunsigned long cksel, shift = 0;\r\ncksel = pm_readl(CKSEL);\r\nif (cksel & PM_BIT(PBADIV))\r\nshift = PM_BFEXT(PBASEL, cksel) + 1;\r\nreturn bus_clk_get_rate(clk, shift);\r\n}\r\nstatic void pbb_clk_mode(struct clk *clk, int enabled)\r\n{\r\nunsigned long flags;\r\nu32 mask;\r\nspin_lock_irqsave(&pm_lock, flags);\r\nmask = pm_readl(PBB_MASK);\r\nif (enabled)\r\nmask |= 1 << clk->index;\r\nelse\r\nmask &= ~(1 << clk->index);\r\npm_writel(PBB_MASK, mask);\r\nspin_unlock_irqrestore(&pm_lock, flags);\r\n}\r\nstatic unsigned long pbb_clk_get_rate(struct clk *clk)\r\n{\r\nunsigned long cksel, shift = 0;\r\ncksel = pm_readl(CKSEL);\r\nif (cksel & PM_BIT(PBBDIV))\r\nshift = PM_BFEXT(PBBSEL, cksel) + 1;\r\nreturn bus_clk_get_rate(clk, shift);\r\n}\r\nstatic void genclk_mode(struct clk *clk, int enabled)\r\n{\r\nu32 control;\r\ncontrol = pm_readl(GCCTRL(clk->index));\r\nif (enabled)\r\ncontrol |= PM_BIT(CEN);\r\nelse\r\ncontrol &= ~PM_BIT(CEN);\r\npm_writel(GCCTRL(clk->index), control);\r\n}\r\nstatic unsigned long genclk_get_rate(struct clk *clk)\r\n{\r\nu32 control;\r\nunsigned long div = 1;\r\ncontrol = pm_readl(GCCTRL(clk->index));\r\nif (control & PM_BIT(DIVEN))\r\ndiv = 2 * (PM_BFEXT(DIV, control) + 1);\r\nreturn clk->parent->get_rate(clk->parent) / div;\r\n}\r\nstatic long genclk_set_rate(struct clk *clk, unsigned long rate, int apply)\r\n{\r\nu32 control;\r\nunsigned long parent_rate, actual_rate, div;\r\nparent_rate = clk->parent->get_rate(clk->parent);\r\ncontrol = pm_readl(GCCTRL(clk->index));\r\nif (rate > 3 * parent_rate / 4) {\r\nactual_rate = parent_rate;\r\ncontrol &= ~PM_BIT(DIVEN);\r\n} else {\r\ndiv = (parent_rate + rate) / (2 * rate) - 1;\r\ncontrol = PM_BFINS(DIV, div, control) | PM_BIT(DIVEN);\r\nactual_rate = parent_rate / (2 * (div + 1));\r\n}\r\ndev_dbg(clk->dev, "clk %s: new rate %lu (actual rate %lu)\n",\r\nclk->name, rate, actual_rate);\r\nif (apply)\r\npm_writel(GCCTRL(clk->index), control);\r\nreturn actual_rate;\r\n}\r\nint genclk_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 control;\r\ndev_dbg(clk->dev, "clk %s: new parent %s (was %s)\n",\r\nclk->name, parent->name, clk->parent->name);\r\ncontrol = pm_readl(GCCTRL(clk->index));\r\nif (parent == &osc1 || parent == &pll1)\r\ncontrol |= PM_BIT(OSCSEL);\r\nelse if (parent == &osc0 || parent == &pll0)\r\ncontrol &= ~PM_BIT(OSCSEL);\r\nelse\r\nreturn -EINVAL;\r\nif (parent == &pll0 || parent == &pll1)\r\ncontrol |= PM_BIT(PLLSEL);\r\nelse\r\ncontrol &= ~PM_BIT(PLLSEL);\r\npm_writel(GCCTRL(clk->index), control);\r\nclk->parent = parent;\r\nreturn 0;\r\n}\r\nstatic void __init genclk_init_parent(struct clk *clk)\r\n{\r\nu32 control;\r\nstruct clk *parent;\r\nBUG_ON(clk->index > 7);\r\ncontrol = pm_readl(GCCTRL(clk->index));\r\nif (control & PM_BIT(OSCSEL))\r\nparent = (control & PM_BIT(PLLSEL)) ? &pll1 : &osc1;\r\nelse\r\nparent = (control & PM_BIT(PLLSEL)) ? &pll0 : &osc0;\r\nclk->parent = parent;\r\n}\r\nstatic inline void set_ebi_sfr_bits(u32 mask)\r\n{\r\nhmatrix_sfr_set_bits(HMATRIX_SLAVE_EBI, mask);\r\n}\r\nstatic int __init system_device_init(void)\r\n{\r\nplatform_device_register(&at32_pm0_device);\r\nplatform_device_register(&at32_intc0_device);\r\nplatform_device_register(&at32ap700x_rtc0_device);\r\nplatform_device_register(&at32_wdt0_device);\r\nplatform_device_register(&at32_eic0_device);\r\nplatform_device_register(&smc0_device);\r\nplatform_device_register(&pdc_device);\r\nplatform_device_register(&dw_dmac0_device);\r\nplatform_device_register(&at32_tcb0_device);\r\nplatform_device_register(&at32_tcb1_device);\r\nplatform_device_register(&pio0_device);\r\nplatform_device_register(&pio1_device);\r\nplatform_device_register(&pio2_device);\r\nplatform_device_register(&pio3_device);\r\nplatform_device_register(&pio4_device);\r\nreturn 0;\r\n}\r\nstruct platform_device *__init at32_add_device_psif(unsigned int id)\r\n{\r\nstruct platform_device *pdev;\r\nu32 pin_mask;\r\nif (!(id == 0 || id == 1))\r\nreturn NULL;\r\npdev = platform_device_alloc("atmel_psif", id);\r\nif (!pdev)\r\nreturn NULL;\r\nswitch (id) {\r\ncase 0:\r\npin_mask = (1 << 8) | (1 << 9);\r\nif (platform_device_add_resources(pdev, atmel_psif0_resource,\r\nARRAY_SIZE(atmel_psif0_resource)))\r\ngoto err_add_resources;\r\natmel_psif0_pclk.dev = &pdev->dev;\r\nselect_peripheral(PIOA, pin_mask, PERIPH_A, 0);\r\nbreak;\r\ncase 1:\r\npin_mask = (1 << 11) | (1 << 12);\r\nif (platform_device_add_resources(pdev, atmel_psif1_resource,\r\nARRAY_SIZE(atmel_psif1_resource)))\r\ngoto err_add_resources;\r\natmel_psif1_pclk.dev = &pdev->dev;\r\nselect_peripheral(PIOB, pin_mask, PERIPH_A, 0);\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nplatform_device_add(pdev);\r\nreturn pdev;\r\nerr_add_resources:\r\nplatform_device_put(pdev);\r\nreturn NULL;\r\n}\r\nstatic inline void configure_usart0_pins(int flags)\r\n{\r\nu32 pin_mask = (1 << 8) | (1 << 9);\r\nif (flags & ATMEL_USART_RTS) pin_mask |= (1 << 6);\r\nif (flags & ATMEL_USART_CTS) pin_mask |= (1 << 7);\r\nif (flags & ATMEL_USART_CLK) pin_mask |= (1 << 10);\r\nselect_peripheral(PIOA, pin_mask, PERIPH_B, AT32_GPIOF_PULLUP);\r\n}\r\nstatic inline void configure_usart1_pins(int flags)\r\n{\r\nu32 pin_mask = (1 << 17) | (1 << 18);\r\nif (flags & ATMEL_USART_RTS) pin_mask |= (1 << 19);\r\nif (flags & ATMEL_USART_CTS) pin_mask |= (1 << 20);\r\nif (flags & ATMEL_USART_CLK) pin_mask |= (1 << 16);\r\nselect_peripheral(PIOA, pin_mask, PERIPH_A, AT32_GPIOF_PULLUP);\r\n}\r\nstatic inline void configure_usart2_pins(int flags)\r\n{\r\nu32 pin_mask = (1 << 26) | (1 << 27);\r\nif (flags & ATMEL_USART_RTS) pin_mask |= (1 << 30);\r\nif (flags & ATMEL_USART_CTS) pin_mask |= (1 << 29);\r\nif (flags & ATMEL_USART_CLK) pin_mask |= (1 << 28);\r\nselect_peripheral(PIOB, pin_mask, PERIPH_B, AT32_GPIOF_PULLUP);\r\n}\r\nstatic inline void configure_usart3_pins(int flags)\r\n{\r\nu32 pin_mask = (1 << 18) | (1 << 17);\r\nif (flags & ATMEL_USART_RTS) pin_mask |= (1 << 16);\r\nif (flags & ATMEL_USART_CTS) pin_mask |= (1 << 15);\r\nif (flags & ATMEL_USART_CLK) pin_mask |= (1 << 19);\r\nselect_peripheral(PIOB, pin_mask, PERIPH_B, AT32_GPIOF_PULLUP);\r\n}\r\nvoid __init at32_map_usart(unsigned int hw_id, unsigned int line, int flags)\r\n{\r\nstruct platform_device *pdev;\r\nstruct atmel_uart_data *pdata;\r\nswitch (hw_id) {\r\ncase 0:\r\npdev = &atmel_usart0_device;\r\nconfigure_usart0_pins(flags);\r\nbreak;\r\ncase 1:\r\npdev = &atmel_usart1_device;\r\nconfigure_usart1_pins(flags);\r\nbreak;\r\ncase 2:\r\npdev = &atmel_usart2_device;\r\nconfigure_usart2_pins(flags);\r\nbreak;\r\ncase 3:\r\npdev = &atmel_usart3_device;\r\nconfigure_usart3_pins(flags);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (PXSEG(pdev->resource[0].start) == P4SEG) {\r\nstruct atmel_uart_data *data = pdev->dev.platform_data;\r\ndata->regs = (void __iomem *)pdev->resource[0].start;\r\n}\r\npdev->id = line;\r\npdata = pdev->dev.platform_data;\r\npdata->num = line;\r\nat32_usarts[line] = pdev;\r\n}\r\nstruct platform_device *__init at32_add_device_usart(unsigned int id)\r\n{\r\nplatform_device_register(at32_usarts[id]);\r\nreturn at32_usarts[id];\r\n}\r\nvoid __init at32_setup_serial_console(unsigned int usart_id)\r\n{\r\n#ifdef CONFIG_SERIAL_ATMEL\r\natmel_default_console_device = at32_usarts[usart_id];\r\n#endif\r\n}\r\nstruct platform_device *__init\r\nat32_add_device_eth(unsigned int id, struct macb_platform_data *data)\r\n{\r\nstruct platform_device *pdev;\r\nu32 pin_mask;\r\nswitch (id) {\r\ncase 0:\r\npdev = &macb0_device;\r\npin_mask = (1 << 3);\r\npin_mask |= (1 << 4);\r\npin_mask |= (1 << 7);\r\npin_mask |= (1 << 8);\r\npin_mask |= (1 << 9);\r\npin_mask |= (1 << 10);\r\npin_mask |= (1 << 13);\r\npin_mask |= (1 << 15);\r\npin_mask |= (1 << 16);\r\npin_mask |= (1 << 17);\r\nif (!data->is_rmii) {\r\npin_mask |= (1 << 0);\r\npin_mask |= (1 << 1);\r\npin_mask |= (1 << 2);\r\npin_mask |= (1 << 5);\r\npin_mask |= (1 << 6);\r\npin_mask |= (1 << 11);\r\npin_mask |= (1 << 12);\r\npin_mask |= (1 << 14);\r\n#ifndef CONFIG_BOARD_MIMC200\r\npin_mask |= (1 << 18);\r\n#endif\r\n}\r\nselect_peripheral(PIOC, pin_mask, PERIPH_A, 0);\r\nbreak;\r\ncase 1:\r\npdev = &macb1_device;\r\npin_mask = (1 << 13);\r\npin_mask |= (1 << 14);\r\npin_mask |= (1 << 11);\r\npin_mask |= (1 << 12);\r\npin_mask |= (1 << 10);\r\npin_mask |= (1 << 6);\r\npin_mask |= (1 << 5);\r\npin_mask |= (1 << 4);\r\npin_mask |= (1 << 3);\r\npin_mask |= (1 << 2);\r\n#ifndef CONFIG_BOARD_MIMC200\r\nif (!data->is_rmii)\r\npin_mask |= (1 << 15);\r\n#endif\r\nselect_peripheral(PIOD, pin_mask, PERIPH_B, 0);\r\nif (!data->is_rmii) {\r\npin_mask = (1 << 19);\r\npin_mask |= (1 << 23);\r\npin_mask |= (1 << 26);\r\npin_mask |= (1 << 27);\r\npin_mask |= (1 << 28);\r\npin_mask |= (1 << 29);\r\npin_mask |= (1 << 30);\r\npin_mask |= (1 << 24);\r\nselect_peripheral(PIOC, pin_mask, PERIPH_B, 0);\r\n}\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nmemcpy(pdev->dev.platform_data, data, sizeof(struct macb_platform_data));\r\nplatform_device_register(pdev);\r\nreturn pdev;\r\n}\r\nvoid __init\r\nat32_spi_setup_slaves(unsigned int bus_num, struct spi_board_info *b, unsigned int n)\r\n{\r\nstatic u8 __initdata spi_pins[][4] = {\r\n{ GPIO_PIN_PA(3), GPIO_PIN_PA(4),\r\nGPIO_PIN_PA(5), GPIO_PIN_PA(20) },\r\n{ GPIO_PIN_PB(2), GPIO_PIN_PB(3),\r\nGPIO_PIN_PB(4), GPIO_PIN_PA(27) },\r\n};\r\nunsigned int pin, mode;\r\nif (bus_num > 1)\r\nreturn;\r\nfor (; n; n--, b++) {\r\nb->bus_num = bus_num;\r\nif (b->chip_select >= 4)\r\ncontinue;\r\npin = (unsigned)b->controller_data;\r\nif (!pin) {\r\npin = spi_pins[bus_num][b->chip_select];\r\nb->controller_data = (void *)pin;\r\n}\r\nmode = AT32_GPIOF_OUTPUT;\r\nif (!(b->mode & SPI_CS_HIGH))\r\nmode |= AT32_GPIOF_HIGH;\r\nat32_select_gpio(pin, mode);\r\n}\r\n}\r\nstruct platform_device *__init\r\nat32_add_device_spi(unsigned int id, struct spi_board_info *b, unsigned int n)\r\n{\r\nstruct platform_device *pdev;\r\nu32 pin_mask;\r\nswitch (id) {\r\ncase 0:\r\npdev = &atmel_spi0_device;\r\npin_mask = (1 << 1) | (1 << 2);\r\nselect_peripheral(PIOA, (1 << 0), PERIPH_A, AT32_GPIOF_PULLUP);\r\nselect_peripheral(PIOA, pin_mask, PERIPH_A, 0);\r\nat32_spi_setup_slaves(0, b, n);\r\nbreak;\r\ncase 1:\r\npdev = &atmel_spi1_device;\r\npin_mask = (1 << 1) | (1 << 5);\r\nselect_peripheral(PIOB, (1 << 0), PERIPH_B, AT32_GPIOF_PULLUP);\r\nselect_peripheral(PIOB, pin_mask, PERIPH_B, 0);\r\nat32_spi_setup_slaves(1, b, n);\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nspi_register_board_info(b, n);\r\nplatform_device_register(pdev);\r\nreturn pdev;\r\n}\r\nstruct platform_device *__init at32_add_device_twi(unsigned int id,\r\nstruct i2c_board_info *b,\r\nunsigned int n)\r\n{\r\nstruct platform_device *pdev;\r\nu32 pin_mask;\r\nif (id != 0)\r\nreturn NULL;\r\npdev = platform_device_alloc("atmel_twi", id);\r\nif (!pdev)\r\nreturn NULL;\r\nif (platform_device_add_resources(pdev, atmel_twi0_resource,\r\nARRAY_SIZE(atmel_twi0_resource)))\r\ngoto err_add_resources;\r\npin_mask = (1 << 6) | (1 << 7);\r\nselect_peripheral(PIOA, pin_mask, PERIPH_A, 0);\r\natmel_twi0_pclk.dev = &pdev->dev;\r\nif (b)\r\ni2c_register_board_info(id, b, n);\r\nplatform_device_add(pdev);\r\nreturn pdev;\r\nerr_add_resources:\r\nplatform_device_put(pdev);\r\nreturn NULL;\r\n}\r\nstruct platform_device *__init\r\nat32_add_device_mci(unsigned int id, struct mci_platform_data *data)\r\n{\r\nstruct platform_device *pdev;\r\nstruct mci_dma_data *slave;\r\nu32 pioa_mask;\r\nu32 piob_mask;\r\nif (id != 0 || !data)\r\nreturn NULL;\r\nif (!data->slot[0].bus_width && !data->slot[1].bus_width)\r\nreturn NULL;\r\npdev = platform_device_alloc("atmel_mci", id);\r\nif (!pdev)\r\ngoto fail;\r\nif (platform_device_add_resources(pdev, atmel_mci0_resource,\r\nARRAY_SIZE(atmel_mci0_resource)))\r\ngoto fail;\r\nslave = kzalloc(sizeof(struct mci_dma_data), GFP_KERNEL);\r\nif (!slave)\r\ngoto fail;\r\nslave->sdata.dma_dev = &dw_dmac0_device.dev;\r\nslave->sdata.cfg_hi = (DWC_CFGH_SRC_PER(0)\r\n| DWC_CFGH_DST_PER(1));\r\nslave->sdata.cfg_lo &= ~(DWC_CFGL_HS_DST_POL\r\n| DWC_CFGL_HS_SRC_POL);\r\ndata->dma_slave = slave;\r\nif (platform_device_add_data(pdev, data,\r\nsizeof(struct mci_platform_data)))\r\ngoto fail_free;\r\npioa_mask = 1 << 10;\r\nswitch (data->slot[0].bus_width) {\r\ncase 4:\r\npioa_mask |= 1 << 13;\r\npioa_mask |= 1 << 14;\r\npioa_mask |= 1 << 15;\r\ncase 1:\r\npioa_mask |= 1 << 11;\r\npioa_mask |= 1 << 12;\r\nif (gpio_is_valid(data->slot[0].detect_pin))\r\nat32_select_gpio(data->slot[0].detect_pin, 0);\r\nif (gpio_is_valid(data->slot[0].wp_pin))\r\nat32_select_gpio(data->slot[0].wp_pin, 0);\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\ngoto fail_free;\r\n}\r\nselect_peripheral(PIOA, pioa_mask, PERIPH_A, 0);\r\npiob_mask = 0;\r\nswitch (data->slot[1].bus_width) {\r\ncase 4:\r\npiob_mask |= 1 << 8;\r\npiob_mask |= 1 << 9;\r\npiob_mask |= 1 << 10;\r\ncase 1:\r\npiob_mask |= 1 << 6;\r\npiob_mask |= 1 << 7;\r\nselect_peripheral(PIOB, piob_mask, PERIPH_B, 0);\r\nif (gpio_is_valid(data->slot[1].detect_pin))\r\nat32_select_gpio(data->slot[1].detect_pin, 0);\r\nif (gpio_is_valid(data->slot[1].wp_pin))\r\nat32_select_gpio(data->slot[1].wp_pin, 0);\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nif (!data->slot[0].bus_width)\r\ngoto fail_free;\r\ndata->slot[1].bus_width = 0;\r\nbreak;\r\n}\r\natmel_mci0_pclk.dev = &pdev->dev;\r\nplatform_device_add(pdev);\r\nreturn pdev;\r\nfail_free:\r\nkfree(slave);\r\nfail:\r\ndata->dma_slave = NULL;\r\nplatform_device_put(pdev);\r\nreturn NULL;\r\n}\r\nstruct platform_device *__init\r\nat32_add_device_lcdc(unsigned int id, struct atmel_lcdfb_pdata *data,\r\nunsigned long fbmem_start, unsigned long fbmem_len,\r\nu64 pin_mask)\r\n{\r\nstruct platform_device *pdev;\r\nstruct atmel_lcdfb_pdata *info;\r\nstruct fb_monspecs *monspecs;\r\nstruct fb_videomode *modedb;\r\nunsigned int modedb_size;\r\nu32 portc_mask, portd_mask, porte_mask;\r\nmonspecs = kmemdup(data->default_monspecs,\r\nsizeof(struct fb_monspecs), GFP_KERNEL);\r\nif (!monspecs)\r\nreturn NULL;\r\nmodedb_size = sizeof(struct fb_videomode) * monspecs->modedb_len;\r\nmodedb = kmemdup(monspecs->modedb, modedb_size, GFP_KERNEL);\r\nif (!modedb)\r\ngoto err_dup_modedb;\r\nmonspecs->modedb = modedb;\r\nswitch (id) {\r\ncase 0:\r\npdev = &atmel_lcdfb0_device;\r\nif (pin_mask == 0ULL)\r\npin_mask = ATMEL_LCDC_PRI_24BIT | ATMEL_LCDC_PRI_CONTROL;\r\nportc_mask = pin_mask & 0xfff80000;\r\nselect_peripheral(PIOC, portc_mask, PERIPH_A, 0);\r\nportd_mask = pin_mask & 0x0003ffff;\r\nselect_peripheral(PIOD, portd_mask, PERIPH_A, 0);\r\nporte_mask = (pin_mask >> 32) & 0x0007ffff;\r\nselect_peripheral(PIOE, porte_mask, PERIPH_B, 0);\r\nclk_set_parent(&atmel_lcdfb0_pixclk, &pll0);\r\nclk_set_rate(&atmel_lcdfb0_pixclk, clk_get_rate(&pll0));\r\nbreak;\r\ndefault:\r\ngoto err_invalid_id;\r\n}\r\nif (fbmem_len) {\r\npdev->resource[2].start = fbmem_start;\r\npdev->resource[2].end = fbmem_start + fbmem_len - 1;\r\npdev->resource[2].flags = IORESOURCE_MEM;\r\n}\r\ninfo = pdev->dev.platform_data;\r\nmemcpy(info, data, sizeof(struct atmel_lcdfb_pdata));\r\ninfo->default_monspecs = monspecs;\r\npdev->name = "at32ap-lcdfb";\r\nplatform_device_register(pdev);\r\nreturn pdev;\r\nerr_invalid_id:\r\nkfree(modedb);\r\nerr_dup_modedb:\r\nkfree(monspecs);\r\nreturn NULL;\r\n}\r\nstruct platform_device *__init at32_add_device_pwm(u32 mask)\r\n{\r\nstruct platform_device *pdev;\r\nu32 pin_mask;\r\nif (!mask)\r\nreturn NULL;\r\npdev = platform_device_alloc("atmel_pwm", 0);\r\nif (!pdev)\r\nreturn NULL;\r\nif (platform_device_add_resources(pdev, atmel_pwm0_resource,\r\nARRAY_SIZE(atmel_pwm0_resource)))\r\ngoto out_free_pdev;\r\nif (platform_device_add_data(pdev, &mask, sizeof(mask)))\r\ngoto out_free_pdev;\r\npin_mask = 0;\r\nif (mask & (1 << 0))\r\npin_mask |= (1 << 28);\r\nif (mask & (1 << 1))\r\npin_mask |= (1 << 29);\r\nif (pin_mask > 0)\r\nselect_peripheral(PIOA, pin_mask, PERIPH_A, 0);\r\npin_mask = 0;\r\nif (mask & (1 << 2))\r\npin_mask |= (1 << 21);\r\nif (mask & (1 << 3))\r\npin_mask |= (1 << 22);\r\nif (pin_mask > 0)\r\nselect_peripheral(PIOA, pin_mask, PERIPH_B, 0);\r\natmel_pwm0_mck.dev = &pdev->dev;\r\nplatform_device_add(pdev);\r\nreturn pdev;\r\nout_free_pdev:\r\nplatform_device_put(pdev);\r\nreturn NULL;\r\n}\r\nstruct platform_device *__init\r\nat32_add_device_ssc(unsigned int id, unsigned int flags)\r\n{\r\nstruct platform_device *pdev;\r\nu32 pin_mask = 0;\r\nswitch (id) {\r\ncase 0:\r\npdev = &ssc0_device;\r\nif (flags & ATMEL_SSC_RF)\r\npin_mask |= (1 << 21);\r\nif (flags & ATMEL_SSC_RK)\r\npin_mask |= (1 << 22);\r\nif (flags & ATMEL_SSC_TK)\r\npin_mask |= (1 << 23);\r\nif (flags & ATMEL_SSC_TF)\r\npin_mask |= (1 << 24);\r\nif (flags & ATMEL_SSC_TD)\r\npin_mask |= (1 << 25);\r\nif (flags & ATMEL_SSC_RD)\r\npin_mask |= (1 << 26);\r\nif (pin_mask > 0)\r\nselect_peripheral(PIOA, pin_mask, PERIPH_A, 0);\r\nbreak;\r\ncase 1:\r\npdev = &ssc1_device;\r\nif (flags & ATMEL_SSC_RF)\r\npin_mask |= (1 << 0);\r\nif (flags & ATMEL_SSC_RK)\r\npin_mask |= (1 << 1);\r\nif (flags & ATMEL_SSC_TK)\r\npin_mask |= (1 << 2);\r\nif (flags & ATMEL_SSC_TF)\r\npin_mask |= (1 << 3);\r\nif (flags & ATMEL_SSC_TD)\r\npin_mask |= (1 << 4);\r\nif (flags & ATMEL_SSC_RD)\r\npin_mask |= (1 << 5);\r\nif (pin_mask > 0)\r\nselect_peripheral(PIOA, pin_mask, PERIPH_B, 0);\r\nbreak;\r\ncase 2:\r\npdev = &ssc2_device;\r\nif (flags & ATMEL_SSC_TD)\r\npin_mask |= (1 << 13);\r\nif (flags & ATMEL_SSC_RD)\r\npin_mask |= (1 << 14);\r\nif (flags & ATMEL_SSC_TK)\r\npin_mask |= (1 << 15);\r\nif (flags & ATMEL_SSC_TF)\r\npin_mask |= (1 << 16);\r\nif (flags & ATMEL_SSC_RF)\r\npin_mask |= (1 << 17);\r\nif (flags & ATMEL_SSC_RK)\r\npin_mask |= (1 << 18);\r\nif (pin_mask > 0)\r\nselect_peripheral(PIOB, pin_mask, PERIPH_A, 0);\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nplatform_device_register(pdev);\r\nreturn pdev;\r\n}\r\nstruct platform_device *__init\r\nat32_add_device_usba(unsigned int id, struct usba_platform_data *data)\r\n{\r\nstruct {\r\nstruct usba_platform_data pdata;\r\nstruct usba_ep_data ep[7];\r\n} usba_data;\r\nstruct platform_device *pdev;\r\nif (id != 0)\r\nreturn NULL;\r\npdev = platform_device_alloc("atmel_usba_udc", 0);\r\nif (!pdev)\r\nreturn NULL;\r\nif (platform_device_add_resources(pdev, usba0_resource,\r\nARRAY_SIZE(usba0_resource)))\r\ngoto out_free_pdev;\r\nif (data) {\r\nusba_data.pdata.vbus_pin = data->vbus_pin;\r\nusba_data.pdata.vbus_pin_inverted = data->vbus_pin_inverted;\r\n} else {\r\nusba_data.pdata.vbus_pin = -EINVAL;\r\nusba_data.pdata.vbus_pin_inverted = -EINVAL;\r\n}\r\ndata = &usba_data.pdata;\r\ndata->num_ep = ARRAY_SIZE(at32_usba_ep);\r\nmemcpy(data->ep, at32_usba_ep, sizeof(at32_usba_ep));\r\nif (platform_device_add_data(pdev, data, sizeof(usba_data)))\r\ngoto out_free_pdev;\r\nif (gpio_is_valid(data->vbus_pin))\r\nat32_select_gpio(data->vbus_pin, 0);\r\nusba0_pclk.dev = &pdev->dev;\r\nusba0_hclk.dev = &pdev->dev;\r\nplatform_device_add(pdev);\r\nreturn pdev;\r\nout_free_pdev:\r\nplatform_device_put(pdev);\r\nreturn NULL;\r\n}\r\nstatic int __init at32_init_ide_or_cf(struct platform_device *pdev,\r\nunsigned int cs, unsigned int extint)\r\n{\r\nstatic unsigned int extint_pin_map[4] __initdata = {\r\n(1 << 25),\r\n(1 << 26),\r\n(1 << 27),\r\n(1 << 28),\r\n};\r\nstatic bool common_pins_initialized __initdata = false;\r\nunsigned int extint_pin;\r\nint ret;\r\nu32 pin_mask;\r\nif (extint >= ARRAY_SIZE(extint_pin_map))\r\nreturn -EINVAL;\r\nextint_pin = extint_pin_map[extint];\r\nswitch (cs) {\r\ncase 4:\r\nret = platform_device_add_resources(pdev,\r\nat32_smc_cs4_resource,\r\nARRAY_SIZE(at32_smc_cs4_resource));\r\nif (ret)\r\nreturn ret;\r\nselect_peripheral(PIOE, (1 << 21), PERIPH_A, 0);\r\nhmatrix_sfr_set_bits(HMATRIX_SLAVE_EBI, HMATRIX_EBI_CF0_ENABLE);\r\nbreak;\r\ncase 5:\r\nret = platform_device_add_resources(pdev,\r\nat32_smc_cs5_resource,\r\nARRAY_SIZE(at32_smc_cs5_resource));\r\nif (ret)\r\nreturn ret;\r\nselect_peripheral(PIOE, (1 << 22), PERIPH_A, 0);\r\nhmatrix_sfr_set_bits(HMATRIX_SLAVE_EBI, HMATRIX_EBI_CF1_ENABLE);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!common_pins_initialized) {\r\npin_mask = (1 << 19);\r\npin_mask |= (1 << 20);\r\npin_mask |= (1 << 23);\r\npin_mask |= (1 << 24);\r\nselect_peripheral(PIOE, pin_mask, PERIPH_A, 0);\r\ncommon_pins_initialized = true;\r\n}\r\nselect_peripheral(PIOB, extint_pin, PERIPH_A, AT32_GPIOF_DEGLITCH);\r\npdev->resource[1].start = EIM_IRQ_BASE + extint;\r\npdev->resource[1].end = pdev->resource[1].start;\r\nreturn 0;\r\n}\r\nstruct platform_device *__init\r\nat32_add_device_ide(unsigned int id, unsigned int extint,\r\nstruct ide_platform_data *data)\r\n{\r\nstruct platform_device *pdev;\r\npdev = platform_device_alloc("at32_ide", id);\r\nif (!pdev)\r\ngoto fail;\r\nif (platform_device_add_data(pdev, data,\r\nsizeof(struct ide_platform_data)))\r\ngoto fail;\r\nif (at32_init_ide_or_cf(pdev, data->cs, extint))\r\ngoto fail;\r\nplatform_device_add(pdev);\r\nreturn pdev;\r\nfail:\r\nplatform_device_put(pdev);\r\nreturn NULL;\r\n}\r\nstruct platform_device *__init\r\nat32_add_device_cf(unsigned int id, unsigned int extint,\r\nstruct cf_platform_data *data)\r\n{\r\nstruct platform_device *pdev;\r\npdev = platform_device_alloc("at32_cf", id);\r\nif (!pdev)\r\ngoto fail;\r\nif (platform_device_add_data(pdev, data,\r\nsizeof(struct cf_platform_data)))\r\ngoto fail;\r\nif (at32_init_ide_or_cf(pdev, data->cs, extint))\r\ngoto fail;\r\nif (gpio_is_valid(data->detect_pin))\r\nat32_select_gpio(data->detect_pin, AT32_GPIOF_DEGLITCH);\r\nif (gpio_is_valid(data->reset_pin))\r\nat32_select_gpio(data->reset_pin, 0);\r\nif (gpio_is_valid(data->vcc_pin))\r\nat32_select_gpio(data->vcc_pin, 0);\r\nplatform_device_add(pdev);\r\nreturn pdev;\r\nfail:\r\nplatform_device_put(pdev);\r\nreturn NULL;\r\n}\r\nstruct platform_device *__init\r\nat32_add_device_nand(unsigned int id, struct atmel_nand_data *data)\r\n{\r\nstruct platform_device *pdev;\r\nif (id != 0 || !data)\r\nreturn NULL;\r\npdev = platform_device_alloc("atmel_nand", id);\r\nif (!pdev)\r\ngoto fail;\r\nif (platform_device_add_resources(pdev, smc_cs3_resource,\r\nARRAY_SIZE(smc_cs3_resource)))\r\ngoto fail;\r\ndata->need_reset_workaround = true;\r\nif (platform_device_add_data(pdev, data,\r\nsizeof(struct atmel_nand_data)))\r\ngoto fail;\r\nhmatrix_sfr_set_bits(HMATRIX_SLAVE_EBI, HMATRIX_EBI_NAND_ENABLE);\r\nif (data->enable_pin)\r\nat32_select_gpio(data->enable_pin,\r\nAT32_GPIOF_OUTPUT | AT32_GPIOF_HIGH);\r\nif (data->rdy_pin)\r\nat32_select_gpio(data->rdy_pin, 0);\r\nif (data->det_pin)\r\nat32_select_gpio(data->det_pin, 0);\r\nplatform_device_add(pdev);\r\nreturn pdev;\r\nfail:\r\nplatform_device_put(pdev);\r\nreturn NULL;\r\n}\r\nstruct platform_device *__init\r\nat32_add_device_ac97c(unsigned int id, struct ac97c_platform_data *data,\r\nunsigned int flags)\r\n{\r\nstruct platform_device *pdev;\r\nstruct dw_dma_slave *rx_dws;\r\nstruct dw_dma_slave *tx_dws;\r\nstruct ac97c_platform_data _data;\r\nu32 pin_mask;\r\nif (id != 0)\r\nreturn NULL;\r\npdev = platform_device_alloc("atmel_ac97c", id);\r\nif (!pdev)\r\nreturn NULL;\r\nif (platform_device_add_resources(pdev, atmel_ac97c0_resource,\r\nARRAY_SIZE(atmel_ac97c0_resource)))\r\ngoto out_free_resources;\r\nif (!data) {\r\ndata = &_data;\r\nmemset(data, 0, sizeof(struct ac97c_platform_data));\r\ndata->reset_pin = -ENODEV;\r\n}\r\nrx_dws = &data->rx_dws;\r\ntx_dws = &data->tx_dws;\r\nif (flags & AC97C_CAPTURE) {\r\nrx_dws->dma_dev = &dw_dmac0_device.dev;\r\nrx_dws->cfg_hi = DWC_CFGH_SRC_PER(3);\r\nrx_dws->cfg_lo &= ~(DWC_CFGL_HS_DST_POL | DWC_CFGL_HS_SRC_POL);\r\nrx_dws->src_master = 0;\r\nrx_dws->dst_master = 1;\r\n}\r\nif (flags & AC97C_PLAYBACK) {\r\ntx_dws->dma_dev = &dw_dmac0_device.dev;\r\ntx_dws->cfg_hi = DWC_CFGH_DST_PER(4);\r\ntx_dws->cfg_lo &= ~(DWC_CFGL_HS_DST_POL | DWC_CFGL_HS_SRC_POL);\r\ntx_dws->src_master = 0;\r\ntx_dws->dst_master = 1;\r\n}\r\nif (platform_device_add_data(pdev, data,\r\nsizeof(struct ac97c_platform_data)))\r\ngoto out_free_resources;\r\npin_mask = (1 << 20) | (1 << 21) | (1 << 22) | (1 << 23);\r\nselect_peripheral(PIOB, pin_mask, PERIPH_B, 0);\r\nif (gpio_is_valid(data->reset_pin))\r\nat32_select_gpio(data->reset_pin, AT32_GPIOF_OUTPUT\r\n| AT32_GPIOF_HIGH);\r\natmel_ac97c0_pclk.dev = &pdev->dev;\r\nplatform_device_add(pdev);\r\nreturn pdev;\r\nout_free_resources:\r\nplatform_device_put(pdev);\r\nreturn NULL;\r\n}\r\nstruct platform_device *__init\r\nat32_add_device_abdac(unsigned int id, struct atmel_abdac_pdata *data)\r\n{\r\nstruct platform_device *pdev;\r\nstruct dw_dma_slave *dws;\r\nu32 pin_mask;\r\nif (id != 0 || !data)\r\nreturn NULL;\r\npdev = platform_device_alloc("atmel_abdac", id);\r\nif (!pdev)\r\nreturn NULL;\r\nif (platform_device_add_resources(pdev, abdac0_resource,\r\nARRAY_SIZE(abdac0_resource)))\r\ngoto out_free_resources;\r\ndws = &data->dws;\r\ndws->dma_dev = &dw_dmac0_device.dev;\r\ndws->cfg_hi = DWC_CFGH_DST_PER(2);\r\ndws->cfg_lo &= ~(DWC_CFGL_HS_DST_POL | DWC_CFGL_HS_SRC_POL);\r\ndws->src_master = 0;\r\ndws->dst_master = 1;\r\nif (platform_device_add_data(pdev, data,\r\nsizeof(struct atmel_abdac_pdata)))\r\ngoto out_free_resources;\r\npin_mask = (1 << 20) | (1 << 22);\r\npin_mask |= (1 << 21) | (1 << 23);\r\nselect_peripheral(PIOB, pin_mask, PERIPH_A, 0);\r\nabdac0_pclk.dev = &pdev->dev;\r\nabdac0_sample_clk.dev = &pdev->dev;\r\nplatform_device_add(pdev);\r\nreturn pdev;\r\nout_free_resources:\r\nplatform_device_put(pdev);\r\nreturn NULL;\r\n}\r\nvoid __init setup_platform(void)\r\n{\r\nu32 cpu_mask = 0, hsb_mask = 0, pba_mask = 0, pbb_mask = 0;\r\nint i;\r\nif (pm_readl(MCCTRL) & PM_BIT(PLLSEL)) {\r\nmain_clock = &pll0;\r\ncpu_clk.parent = &pll0;\r\n} else {\r\nmain_clock = &osc0;\r\ncpu_clk.parent = &osc0;\r\n}\r\nif (pm_readl(PLL0) & PM_BIT(PLLOSC))\r\npll0.parent = &osc1;\r\nif (pm_readl(PLL1) & PM_BIT(PLLOSC))\r\npll1.parent = &osc1;\r\ngenclk_init_parent(&gclk0);\r\ngenclk_init_parent(&gclk1);\r\ngenclk_init_parent(&gclk2);\r\ngenclk_init_parent(&gclk3);\r\ngenclk_init_parent(&gclk4);\r\n#if defined(CONFIG_CPU_AT32AP7000) || defined(CONFIG_CPU_AT32AP7002)\r\ngenclk_init_parent(&atmel_lcdfb0_pixclk);\r\n#endif\r\ngenclk_init_parent(&abdac0_sample_clk);\r\nfor (i = 0; i < ARRAY_SIZE(init_clocks); i++) {\r\nstruct clk *clk = init_clocks[i];\r\nat32_clk_register(clk);\r\nif (clk->users == 0)\r\ncontinue;\r\nif (clk->mode == &cpu_clk_mode)\r\ncpu_mask |= 1 << clk->index;\r\nelse if (clk->mode == &hsb_clk_mode)\r\nhsb_mask |= 1 << clk->index;\r\nelse if (clk->mode == &pba_clk_mode)\r\npba_mask |= 1 << clk->index;\r\nelse if (clk->mode == &pbb_clk_mode)\r\npbb_mask |= 1 << clk->index;\r\n}\r\npm_writel(CPU_MASK, cpu_mask);\r\npm_writel(HSB_MASK, hsb_mask);\r\npm_writel(PBA_MASK, pba_mask);\r\npm_writel(PBB_MASK, pbb_mask);\r\nat32_init_pio(&pio0_device);\r\nat32_init_pio(&pio1_device);\r\nat32_init_pio(&pio2_device);\r\nat32_init_pio(&pio3_device);\r\nat32_init_pio(&pio4_device);\r\n}\r\nstatic int __init sram_init(void)\r\n{\r\nstruct gen_pool *pool;\r\npool = gen_pool_create(10, -1);\r\nif (!pool)\r\ngoto fail;\r\nif (gen_pool_add(pool, 0x24000000, 0x8000, -1))\r\ngoto err_pool_add;\r\nsram_pool = pool;\r\nreturn 0;\r\nerr_pool_add:\r\ngen_pool_destroy(pool);\r\nfail:\r\npr_err("Failed to create SRAM pool\n");\r\nreturn -ENOMEM;\r\n}
