static unsigned long sh_cmt_read16(void __iomem *base, unsigned long offs)\r\n{\r\nreturn ioread16(base + (offs << 1));\r\n}\r\nstatic unsigned long sh_cmt_read32(void __iomem *base, unsigned long offs)\r\n{\r\nreturn ioread32(base + (offs << 2));\r\n}\r\nstatic void sh_cmt_write16(void __iomem *base, unsigned long offs,\r\nunsigned long value)\r\n{\r\niowrite16(value, base + (offs << 1));\r\n}\r\nstatic void sh_cmt_write32(void __iomem *base, unsigned long offs,\r\nunsigned long value)\r\n{\r\niowrite32(value, base + (offs << 2));\r\n}\r\nstatic inline unsigned long sh_cmt_read_cmstr(struct sh_cmt_priv *p)\r\n{\r\nreturn p->read_control(p->mapbase_str, 0);\r\n}\r\nstatic inline unsigned long sh_cmt_read_cmcsr(struct sh_cmt_priv *p)\r\n{\r\nreturn p->read_control(p->mapbase, CMCSR);\r\n}\r\nstatic inline unsigned long sh_cmt_read_cmcnt(struct sh_cmt_priv *p)\r\n{\r\nreturn p->read_count(p->mapbase, CMCNT);\r\n}\r\nstatic inline void sh_cmt_write_cmstr(struct sh_cmt_priv *p,\r\nunsigned long value)\r\n{\r\np->write_control(p->mapbase_str, 0, value);\r\n}\r\nstatic inline void sh_cmt_write_cmcsr(struct sh_cmt_priv *p,\r\nunsigned long value)\r\n{\r\np->write_control(p->mapbase, CMCSR, value);\r\n}\r\nstatic inline void sh_cmt_write_cmcnt(struct sh_cmt_priv *p,\r\nunsigned long value)\r\n{\r\np->write_count(p->mapbase, CMCNT, value);\r\n}\r\nstatic inline void sh_cmt_write_cmcor(struct sh_cmt_priv *p,\r\nunsigned long value)\r\n{\r\np->write_count(p->mapbase, CMCOR, value);\r\n}\r\nstatic unsigned long sh_cmt_get_counter(struct sh_cmt_priv *p,\r\nint *has_wrapped)\r\n{\r\nunsigned long v1, v2, v3;\r\nint o1, o2;\r\no1 = sh_cmt_read_cmcsr(p) & p->overflow_bit;\r\ndo {\r\no2 = o1;\r\nv1 = sh_cmt_read_cmcnt(p);\r\nv2 = sh_cmt_read_cmcnt(p);\r\nv3 = sh_cmt_read_cmcnt(p);\r\no1 = sh_cmt_read_cmcsr(p) & p->overflow_bit;\r\n} while (unlikely((o1 != o2) || (v1 > v2 && v1 < v3)\r\n|| (v2 > v3 && v2 < v1) || (v3 > v1 && v3 < v2)));\r\n*has_wrapped = o1;\r\nreturn v2;\r\n}\r\nstatic void sh_cmt_start_stop_ch(struct sh_cmt_priv *p, int start)\r\n{\r\nstruct sh_timer_config *cfg = p->pdev->dev.platform_data;\r\nunsigned long flags, value;\r\nraw_spin_lock_irqsave(&sh_cmt_lock, flags);\r\nvalue = sh_cmt_read_cmstr(p);\r\nif (start)\r\nvalue |= 1 << cfg->timer_bit;\r\nelse\r\nvalue &= ~(1 << cfg->timer_bit);\r\nsh_cmt_write_cmstr(p, value);\r\nraw_spin_unlock_irqrestore(&sh_cmt_lock, flags);\r\n}\r\nstatic int sh_cmt_enable(struct sh_cmt_priv *p, unsigned long *rate)\r\n{\r\nint k, ret;\r\npm_runtime_get_sync(&p->pdev->dev);\r\ndev_pm_syscore_device(&p->pdev->dev, true);\r\nret = clk_enable(p->clk);\r\nif (ret) {\r\ndev_err(&p->pdev->dev, "cannot enable clock\n");\r\ngoto err0;\r\n}\r\nsh_cmt_start_stop_ch(p, 0);\r\nif (p->width == 16) {\r\n*rate = clk_get_rate(p->clk) / 512;\r\nsh_cmt_write_cmcsr(p, 0x43);\r\n} else {\r\n*rate = clk_get_rate(p->clk) / 8;\r\nsh_cmt_write_cmcsr(p, 0x01a4);\r\n}\r\nsh_cmt_write_cmcor(p, 0xffffffff);\r\nsh_cmt_write_cmcnt(p, 0);\r\nfor (k = 0; k < 100; k++) {\r\nif (!sh_cmt_read_cmcnt(p))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (sh_cmt_read_cmcnt(p)) {\r\ndev_err(&p->pdev->dev, "cannot clear CMCNT\n");\r\nret = -ETIMEDOUT;\r\ngoto err1;\r\n}\r\nsh_cmt_start_stop_ch(p, 1);\r\nreturn 0;\r\nerr1:\r\nclk_disable(p->clk);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic void sh_cmt_disable(struct sh_cmt_priv *p)\r\n{\r\nsh_cmt_start_stop_ch(p, 0);\r\nsh_cmt_write_cmcsr(p, 0);\r\nclk_disable(p->clk);\r\ndev_pm_syscore_device(&p->pdev->dev, false);\r\npm_runtime_put(&p->pdev->dev);\r\n}\r\nstatic void sh_cmt_clock_event_program_verify(struct sh_cmt_priv *p,\r\nint absolute)\r\n{\r\nunsigned long new_match;\r\nunsigned long value = p->next_match_value;\r\nunsigned long delay = 0;\r\nunsigned long now = 0;\r\nint has_wrapped;\r\nnow = sh_cmt_get_counter(p, &has_wrapped);\r\np->flags |= FLAG_REPROGRAM;\r\nif (has_wrapped) {\r\np->flags |= FLAG_SKIPEVENT;\r\nreturn;\r\n}\r\nif (absolute)\r\nnow = 0;\r\ndo {\r\nnew_match = now + value + delay;\r\nif (new_match > p->max_match_value)\r\nnew_match = p->max_match_value;\r\nsh_cmt_write_cmcor(p, new_match);\r\nnow = sh_cmt_get_counter(p, &has_wrapped);\r\nif (has_wrapped && (new_match > p->match_value)) {\r\np->flags |= FLAG_SKIPEVENT;\r\nbreak;\r\n}\r\nif (has_wrapped) {\r\np->match_value = new_match;\r\nbreak;\r\n}\r\nif (now < new_match) {\r\np->match_value = new_match;\r\nbreak;\r\n}\r\nif (delay)\r\ndelay <<= 1;\r\nelse\r\ndelay = 1;\r\nif (!delay)\r\ndev_warn(&p->pdev->dev, "too long delay\n");\r\n} while (delay);\r\n}\r\nstatic void __sh_cmt_set_next(struct sh_cmt_priv *p, unsigned long delta)\r\n{\r\nif (delta > p->max_match_value)\r\ndev_warn(&p->pdev->dev, "delta out of range\n");\r\np->next_match_value = delta;\r\nsh_cmt_clock_event_program_verify(p, 0);\r\n}\r\nstatic void sh_cmt_set_next(struct sh_cmt_priv *p, unsigned long delta)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&p->lock, flags);\r\n__sh_cmt_set_next(p, delta);\r\nraw_spin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic irqreturn_t sh_cmt_interrupt(int irq, void *dev_id)\r\n{\r\nstruct sh_cmt_priv *p = dev_id;\r\nsh_cmt_write_cmcsr(p, sh_cmt_read_cmcsr(p) & p->clear_bits);\r\nif (p->flags & FLAG_CLOCKSOURCE)\r\np->total_cycles += p->match_value + 1;\r\nif (!(p->flags & FLAG_REPROGRAM))\r\np->next_match_value = p->max_match_value;\r\np->flags |= FLAG_IRQCONTEXT;\r\nif (p->flags & FLAG_CLOCKEVENT) {\r\nif (!(p->flags & FLAG_SKIPEVENT)) {\r\nif (p->ced.mode == CLOCK_EVT_MODE_ONESHOT) {\r\np->next_match_value = p->max_match_value;\r\np->flags |= FLAG_REPROGRAM;\r\n}\r\np->ced.event_handler(&p->ced);\r\n}\r\n}\r\np->flags &= ~FLAG_SKIPEVENT;\r\nif (p->flags & FLAG_REPROGRAM) {\r\np->flags &= ~FLAG_REPROGRAM;\r\nsh_cmt_clock_event_program_verify(p, 1);\r\nif (p->flags & FLAG_CLOCKEVENT)\r\nif ((p->ced.mode == CLOCK_EVT_MODE_SHUTDOWN)\r\n|| (p->match_value == p->next_match_value))\r\np->flags &= ~FLAG_REPROGRAM;\r\n}\r\np->flags &= ~FLAG_IRQCONTEXT;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sh_cmt_start(struct sh_cmt_priv *p, unsigned long flag)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&p->lock, flags);\r\nif (!(p->flags & (FLAG_CLOCKEVENT | FLAG_CLOCKSOURCE)))\r\nret = sh_cmt_enable(p, &p->rate);\r\nif (ret)\r\ngoto out;\r\np->flags |= flag;\r\nif ((flag == FLAG_CLOCKSOURCE) && (!(p->flags & FLAG_CLOCKEVENT)))\r\n__sh_cmt_set_next(p, p->max_match_value);\r\nout:\r\nraw_spin_unlock_irqrestore(&p->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void sh_cmt_stop(struct sh_cmt_priv *p, unsigned long flag)\r\n{\r\nunsigned long flags;\r\nunsigned long f;\r\nraw_spin_lock_irqsave(&p->lock, flags);\r\nf = p->flags & (FLAG_CLOCKEVENT | FLAG_CLOCKSOURCE);\r\np->flags &= ~flag;\r\nif (f && !(p->flags & (FLAG_CLOCKEVENT | FLAG_CLOCKSOURCE)))\r\nsh_cmt_disable(p);\r\nif ((flag == FLAG_CLOCKEVENT) && (p->flags & FLAG_CLOCKSOURCE))\r\n__sh_cmt_set_next(p, p->max_match_value);\r\nraw_spin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic struct sh_cmt_priv *cs_to_sh_cmt(struct clocksource *cs)\r\n{\r\nreturn container_of(cs, struct sh_cmt_priv, cs);\r\n}\r\nstatic cycle_t sh_cmt_clocksource_read(struct clocksource *cs)\r\n{\r\nstruct sh_cmt_priv *p = cs_to_sh_cmt(cs);\r\nunsigned long flags, raw;\r\nunsigned long value;\r\nint has_wrapped;\r\nraw_spin_lock_irqsave(&p->lock, flags);\r\nvalue = p->total_cycles;\r\nraw = sh_cmt_get_counter(p, &has_wrapped);\r\nif (unlikely(has_wrapped))\r\nraw += p->match_value + 1;\r\nraw_spin_unlock_irqrestore(&p->lock, flags);\r\nreturn value + raw;\r\n}\r\nstatic int sh_cmt_clocksource_enable(struct clocksource *cs)\r\n{\r\nint ret;\r\nstruct sh_cmt_priv *p = cs_to_sh_cmt(cs);\r\nWARN_ON(p->cs_enabled);\r\np->total_cycles = 0;\r\nret = sh_cmt_start(p, FLAG_CLOCKSOURCE);\r\nif (!ret) {\r\n__clocksource_updatefreq_hz(cs, p->rate);\r\np->cs_enabled = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic void sh_cmt_clocksource_disable(struct clocksource *cs)\r\n{\r\nstruct sh_cmt_priv *p = cs_to_sh_cmt(cs);\r\nWARN_ON(!p->cs_enabled);\r\nsh_cmt_stop(p, FLAG_CLOCKSOURCE);\r\np->cs_enabled = false;\r\n}\r\nstatic void sh_cmt_clocksource_suspend(struct clocksource *cs)\r\n{\r\nstruct sh_cmt_priv *p = cs_to_sh_cmt(cs);\r\nsh_cmt_stop(p, FLAG_CLOCKSOURCE);\r\npm_genpd_syscore_poweroff(&p->pdev->dev);\r\n}\r\nstatic void sh_cmt_clocksource_resume(struct clocksource *cs)\r\n{\r\nstruct sh_cmt_priv *p = cs_to_sh_cmt(cs);\r\npm_genpd_syscore_poweron(&p->pdev->dev);\r\nsh_cmt_start(p, FLAG_CLOCKSOURCE);\r\n}\r\nstatic int sh_cmt_register_clocksource(struct sh_cmt_priv *p,\r\nchar *name, unsigned long rating)\r\n{\r\nstruct clocksource *cs = &p->cs;\r\ncs->name = name;\r\ncs->rating = rating;\r\ncs->read = sh_cmt_clocksource_read;\r\ncs->enable = sh_cmt_clocksource_enable;\r\ncs->disable = sh_cmt_clocksource_disable;\r\ncs->suspend = sh_cmt_clocksource_suspend;\r\ncs->resume = sh_cmt_clocksource_resume;\r\ncs->mask = CLOCKSOURCE_MASK(sizeof(unsigned long) * 8);\r\ncs->flags = CLOCK_SOURCE_IS_CONTINUOUS;\r\ndev_info(&p->pdev->dev, "used as clock source\n");\r\nclocksource_register_hz(cs, 1);\r\nreturn 0;\r\n}\r\nstatic struct sh_cmt_priv *ced_to_sh_cmt(struct clock_event_device *ced)\r\n{\r\nreturn container_of(ced, struct sh_cmt_priv, ced);\r\n}\r\nstatic void sh_cmt_clock_event_start(struct sh_cmt_priv *p, int periodic)\r\n{\r\nstruct clock_event_device *ced = &p->ced;\r\nsh_cmt_start(p, FLAG_CLOCKEVENT);\r\nced->shift = 32;\r\nced->mult = div_sc(p->rate, NSEC_PER_SEC, ced->shift);\r\nced->max_delta_ns = clockevent_delta2ns(p->max_match_value, ced);\r\nced->min_delta_ns = clockevent_delta2ns(0x1f, ced);\r\nif (periodic)\r\nsh_cmt_set_next(p, ((p->rate + HZ/2) / HZ) - 1);\r\nelse\r\nsh_cmt_set_next(p, p->max_match_value);\r\n}\r\nstatic void sh_cmt_clock_event_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *ced)\r\n{\r\nstruct sh_cmt_priv *p = ced_to_sh_cmt(ced);\r\nswitch (ced->mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nsh_cmt_stop(p, FLAG_CLOCKEVENT);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\ndev_info(&p->pdev->dev, "used for periodic clock events\n");\r\nsh_cmt_clock_event_start(p, 1);\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\ndev_info(&p->pdev->dev, "used for oneshot clock events\n");\r\nsh_cmt_clock_event_start(p, 0);\r\nbreak;\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ncase CLOCK_EVT_MODE_UNUSED:\r\nsh_cmt_stop(p, FLAG_CLOCKEVENT);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int sh_cmt_clock_event_next(unsigned long delta,\r\nstruct clock_event_device *ced)\r\n{\r\nstruct sh_cmt_priv *p = ced_to_sh_cmt(ced);\r\nBUG_ON(ced->mode != CLOCK_EVT_MODE_ONESHOT);\r\nif (likely(p->flags & FLAG_IRQCONTEXT))\r\np->next_match_value = delta - 1;\r\nelse\r\nsh_cmt_set_next(p, delta - 1);\r\nreturn 0;\r\n}\r\nstatic void sh_cmt_clock_event_suspend(struct clock_event_device *ced)\r\n{\r\nstruct sh_cmt_priv *p = ced_to_sh_cmt(ced);\r\npm_genpd_syscore_poweroff(&p->pdev->dev);\r\nclk_unprepare(p->clk);\r\n}\r\nstatic void sh_cmt_clock_event_resume(struct clock_event_device *ced)\r\n{\r\nstruct sh_cmt_priv *p = ced_to_sh_cmt(ced);\r\nclk_prepare(p->clk);\r\npm_genpd_syscore_poweron(&p->pdev->dev);\r\n}\r\nstatic void sh_cmt_register_clockevent(struct sh_cmt_priv *p,\r\nchar *name, unsigned long rating)\r\n{\r\nstruct clock_event_device *ced = &p->ced;\r\nmemset(ced, 0, sizeof(*ced));\r\nced->name = name;\r\nced->features = CLOCK_EVT_FEAT_PERIODIC;\r\nced->features |= CLOCK_EVT_FEAT_ONESHOT;\r\nced->rating = rating;\r\nced->cpumask = cpumask_of(0);\r\nced->set_next_event = sh_cmt_clock_event_next;\r\nced->set_mode = sh_cmt_clock_event_mode;\r\nced->suspend = sh_cmt_clock_event_suspend;\r\nced->resume = sh_cmt_clock_event_resume;\r\ndev_info(&p->pdev->dev, "used for clock events\n");\r\nclockevents_register_device(ced);\r\n}\r\nstatic int sh_cmt_register(struct sh_cmt_priv *p, char *name,\r\nunsigned long clockevent_rating,\r\nunsigned long clocksource_rating)\r\n{\r\nif (clockevent_rating)\r\nsh_cmt_register_clockevent(p, name, clockevent_rating);\r\nif (clocksource_rating)\r\nsh_cmt_register_clocksource(p, name, clocksource_rating);\r\nreturn 0;\r\n}\r\nstatic int sh_cmt_setup(struct sh_cmt_priv *p, struct platform_device *pdev)\r\n{\r\nstruct sh_timer_config *cfg = pdev->dev.platform_data;\r\nstruct resource *res, *res2;\r\nint irq, ret;\r\nret = -ENXIO;\r\nmemset(p, 0, sizeof(*p));\r\np->pdev = pdev;\r\nif (!cfg) {\r\ndev_err(&p->pdev->dev, "missing platform data\n");\r\ngoto err0;\r\n}\r\nres = platform_get_resource(p->pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&p->pdev->dev, "failed to get I/O memory\n");\r\ngoto err0;\r\n}\r\nres2 = platform_get_resource(p->pdev, IORESOURCE_MEM, 1);\r\nirq = platform_get_irq(p->pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&p->pdev->dev, "failed to get irq\n");\r\ngoto err0;\r\n}\r\np->mapbase = ioremap_nocache(res->start, resource_size(res));\r\nif (p->mapbase == NULL) {\r\ndev_err(&p->pdev->dev, "failed to remap I/O memory\n");\r\ngoto err0;\r\n}\r\np->mapbase_str = ioremap_nocache(res2 ? res2->start :\r\nres->start - cfg->channel_offset,\r\nres2 ? resource_size(res2) : 2);\r\nif (p->mapbase_str == NULL) {\r\ndev_err(&p->pdev->dev, "failed to remap I/O second memory\n");\r\ngoto err1;\r\n}\r\np->irqaction.name = dev_name(&p->pdev->dev);\r\np->irqaction.handler = sh_cmt_interrupt;\r\np->irqaction.dev_id = p;\r\np->irqaction.flags = IRQF_TIMER | IRQF_IRQPOLL | IRQF_NOBALANCING;\r\np->clk = clk_get(&p->pdev->dev, "cmt_fck");\r\nif (IS_ERR(p->clk)) {\r\ndev_err(&p->pdev->dev, "cannot get clock\n");\r\nret = PTR_ERR(p->clk);\r\ngoto err2;\r\n}\r\nret = clk_prepare(p->clk);\r\nif (ret < 0)\r\ngoto err3;\r\nif (res2 && (resource_size(res2) == 4)) {\r\np->read_control = sh_cmt_read32;\r\np->write_control = sh_cmt_write32;\r\n} else {\r\np->read_control = sh_cmt_read16;\r\np->write_control = sh_cmt_write16;\r\n}\r\nif (resource_size(res) == 6) {\r\np->width = 16;\r\np->read_count = sh_cmt_read16;\r\np->write_count = sh_cmt_write16;\r\np->overflow_bit = 0x80;\r\np->clear_bits = ~0x80;\r\n} else {\r\np->width = 32;\r\np->read_count = sh_cmt_read32;\r\np->write_count = sh_cmt_write32;\r\np->overflow_bit = 0x8000;\r\np->clear_bits = ~0xc000;\r\n}\r\nif (p->width == (sizeof(p->max_match_value) * 8))\r\np->max_match_value = ~0;\r\nelse\r\np->max_match_value = (1 << p->width) - 1;\r\np->match_value = p->max_match_value;\r\nraw_spin_lock_init(&p->lock);\r\nret = sh_cmt_register(p, (char *)dev_name(&p->pdev->dev),\r\ncfg->clockevent_rating,\r\ncfg->clocksource_rating);\r\nif (ret) {\r\ndev_err(&p->pdev->dev, "registration failed\n");\r\ngoto err4;\r\n}\r\np->cs_enabled = false;\r\nret = setup_irq(irq, &p->irqaction);\r\nif (ret) {\r\ndev_err(&p->pdev->dev, "failed to request irq %d\n", irq);\r\ngoto err4;\r\n}\r\nplatform_set_drvdata(pdev, p);\r\nreturn 0;\r\nerr4:\r\nclk_unprepare(p->clk);\r\nerr3:\r\nclk_put(p->clk);\r\nerr2:\r\niounmap(p->mapbase_str);\r\nerr1:\r\niounmap(p->mapbase);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int sh_cmt_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_cmt_priv *p = platform_get_drvdata(pdev);\r\nstruct sh_timer_config *cfg = pdev->dev.platform_data;\r\nint ret;\r\nif (!is_early_platform_device(pdev)) {\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\n}\r\nif (p) {\r\ndev_info(&pdev->dev, "kept as earlytimer\n");\r\ngoto out;\r\n}\r\np = kmalloc(sizeof(*p), GFP_KERNEL);\r\nif (p == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\nret = sh_cmt_setup(p, pdev);\r\nif (ret) {\r\nkfree(p);\r\npm_runtime_idle(&pdev->dev);\r\nreturn ret;\r\n}\r\nif (is_early_platform_device(pdev))\r\nreturn 0;\r\nout:\r\nif (cfg->clockevent_rating || cfg->clocksource_rating)\r\npm_runtime_irq_safe(&pdev->dev);\r\nelse\r\npm_runtime_idle(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int sh_cmt_remove(struct platform_device *pdev)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic int __init sh_cmt_init(void)\r\n{\r\nreturn platform_driver_register(&sh_cmt_device_driver);\r\n}\r\nstatic void __exit sh_cmt_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_cmt_device_driver);\r\n}
