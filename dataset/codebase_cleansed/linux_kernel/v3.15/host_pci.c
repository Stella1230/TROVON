static void bcma_host_pci_switch_core(struct bcma_device *core)\r\n{\r\npci_write_config_dword(core->bus->host_pci, BCMA_PCI_BAR0_WIN,\r\ncore->addr);\r\npci_write_config_dword(core->bus->host_pci, BCMA_PCI_BAR0_WIN2,\r\ncore->wrap);\r\ncore->bus->mapped_core = core;\r\nbcma_debug(core->bus, "Switched to core: 0x%X\n", core->id.id);\r\n}\r\nstatic u16 bcma_host_pci_provide_access_to_core(struct bcma_device *core)\r\n{\r\nswitch (core->id.id) {\r\ncase BCMA_CORE_CHIPCOMMON:\r\nreturn 3 * BCMA_CORE_SIZE;\r\ncase BCMA_CORE_PCIE:\r\nreturn 2 * BCMA_CORE_SIZE;\r\n}\r\nif (core->bus->mapped_core != core)\r\nbcma_host_pci_switch_core(core);\r\nreturn 0;\r\n}\r\nstatic u8 bcma_host_pci_read8(struct bcma_device *core, u16 offset)\r\n{\r\noffset += bcma_host_pci_provide_access_to_core(core);\r\nreturn ioread8(core->bus->mmio + offset);\r\n}\r\nstatic u16 bcma_host_pci_read16(struct bcma_device *core, u16 offset)\r\n{\r\noffset += bcma_host_pci_provide_access_to_core(core);\r\nreturn ioread16(core->bus->mmio + offset);\r\n}\r\nstatic u32 bcma_host_pci_read32(struct bcma_device *core, u16 offset)\r\n{\r\noffset += bcma_host_pci_provide_access_to_core(core);\r\nreturn ioread32(core->bus->mmio + offset);\r\n}\r\nstatic void bcma_host_pci_write8(struct bcma_device *core, u16 offset,\r\nu8 value)\r\n{\r\noffset += bcma_host_pci_provide_access_to_core(core);\r\niowrite8(value, core->bus->mmio + offset);\r\n}\r\nstatic void bcma_host_pci_write16(struct bcma_device *core, u16 offset,\r\nu16 value)\r\n{\r\noffset += bcma_host_pci_provide_access_to_core(core);\r\niowrite16(value, core->bus->mmio + offset);\r\n}\r\nstatic void bcma_host_pci_write32(struct bcma_device *core, u16 offset,\r\nu32 value)\r\n{\r\noffset += bcma_host_pci_provide_access_to_core(core);\r\niowrite32(value, core->bus->mmio + offset);\r\n}\r\nstatic void bcma_host_pci_block_read(struct bcma_device *core, void *buffer,\r\nsize_t count, u16 offset, u8 reg_width)\r\n{\r\nvoid __iomem *addr = core->bus->mmio + offset;\r\nif (core->bus->mapped_core != core)\r\nbcma_host_pci_switch_core(core);\r\nswitch (reg_width) {\r\ncase sizeof(u8):\r\nioread8_rep(addr, buffer, count);\r\nbreak;\r\ncase sizeof(u16):\r\nWARN_ON(count & 1);\r\nioread16_rep(addr, buffer, count >> 1);\r\nbreak;\r\ncase sizeof(u32):\r\nWARN_ON(count & 3);\r\nioread32_rep(addr, buffer, count >> 2);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nstatic void bcma_host_pci_block_write(struct bcma_device *core,\r\nconst void *buffer, size_t count,\r\nu16 offset, u8 reg_width)\r\n{\r\nvoid __iomem *addr = core->bus->mmio + offset;\r\nif (core->bus->mapped_core != core)\r\nbcma_host_pci_switch_core(core);\r\nswitch (reg_width) {\r\ncase sizeof(u8):\r\niowrite8_rep(addr, buffer, count);\r\nbreak;\r\ncase sizeof(u16):\r\nWARN_ON(count & 1);\r\niowrite16_rep(addr, buffer, count >> 1);\r\nbreak;\r\ncase sizeof(u32):\r\nWARN_ON(count & 3);\r\niowrite32_rep(addr, buffer, count >> 2);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nstatic u32 bcma_host_pci_aread32(struct bcma_device *core, u16 offset)\r\n{\r\nif (core->bus->mapped_core != core)\r\nbcma_host_pci_switch_core(core);\r\nreturn ioread32(core->bus->mmio + (1 * BCMA_CORE_SIZE) + offset);\r\n}\r\nstatic void bcma_host_pci_awrite32(struct bcma_device *core, u16 offset,\r\nu32 value)\r\n{\r\nif (core->bus->mapped_core != core)\r\nbcma_host_pci_switch_core(core);\r\niowrite32(value, core->bus->mmio + (1 * BCMA_CORE_SIZE) + offset);\r\n}\r\nstatic int bcma_host_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct bcma_bus *bus;\r\nint err = -ENOMEM;\r\nconst char *name;\r\nu32 val;\r\nbus = kzalloc(sizeof(*bus), GFP_KERNEL);\r\nif (!bus)\r\ngoto out;\r\nerr = pci_enable_device(dev);\r\nif (err)\r\ngoto err_kfree_bus;\r\nname = dev_name(&dev->dev);\r\nif (dev->driver && dev->driver->name)\r\nname = dev->driver->name;\r\nerr = pci_request_regions(dev, name);\r\nif (err)\r\ngoto err_pci_disable;\r\npci_set_master(dev);\r\npci_read_config_dword(dev, 0x40, &val);\r\nif ((val & 0x0000ff00) != 0)\r\npci_write_config_dword(dev, 0x40, val & 0xffff00ff);\r\nif (!pci_is_pcie(dev)) {\r\nbcma_err(bus, "PCI card detected, they are not supported.\n");\r\nerr = -ENXIO;\r\ngoto err_pci_release_regions;\r\n}\r\nerr = -ENOMEM;\r\nbus->mmio = pci_iomap(dev, 0, ~0UL);\r\nif (!bus->mmio)\r\ngoto err_pci_release_regions;\r\nbus->host_pci = dev;\r\nbus->hosttype = BCMA_HOSTTYPE_PCI;\r\nbus->ops = &bcma_host_pci_ops;\r\nbus->boardinfo.vendor = bus->host_pci->subsystem_vendor;\r\nbus->boardinfo.type = bus->host_pci->subsystem_device;\r\nerr = bcma_bus_register(bus);\r\nif (err)\r\ngoto err_pci_unmap_mmio;\r\npci_set_drvdata(dev, bus);\r\nout:\r\nreturn err;\r\nerr_pci_unmap_mmio:\r\npci_iounmap(dev, bus->mmio);\r\nerr_pci_release_regions:\r\npci_release_regions(dev);\r\nerr_pci_disable:\r\npci_disable_device(dev);\r\nerr_kfree_bus:\r\nkfree(bus);\r\nreturn err;\r\n}\r\nstatic void bcma_host_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct bcma_bus *bus = pci_get_drvdata(dev);\r\nbcma_bus_unregister(bus);\r\npci_iounmap(dev, bus->mmio);\r\npci_release_regions(dev);\r\npci_disable_device(dev);\r\nkfree(bus);\r\n}\r\nstatic int bcma_host_pci_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct bcma_bus *bus = pci_get_drvdata(pdev);\r\nbus->mapped_core = NULL;\r\nreturn bcma_bus_suspend(bus);\r\n}\r\nstatic int bcma_host_pci_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct bcma_bus *bus = pci_get_drvdata(pdev);\r\nreturn bcma_bus_resume(bus);\r\n}\r\nint __init bcma_host_pci_init(void)\r\n{\r\nreturn pci_register_driver(&bcma_pci_bridge_driver);\r\n}\r\nvoid __exit bcma_host_pci_exit(void)\r\n{\r\npci_unregister_driver(&bcma_pci_bridge_driver);\r\n}
