static ssize_t ata_scsi_lpm_store(struct device *device,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(device);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nenum ata_lpm_policy policy;\r\nunsigned long flags;\r\nfor (policy = ATA_LPM_MAX_POWER;\r\npolicy < ARRAY_SIZE(ata_lpm_policy_names); policy++) {\r\nconst char *name = ata_lpm_policy_names[policy];\r\nif (strncmp(name, buf, strlen(name)) == 0)\r\nbreak;\r\n}\r\nif (policy == ARRAY_SIZE(ata_lpm_policy_names))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(ap->lock, flags);\r\nata_for_each_link(link, ap, EDGE) {\r\nata_for_each_dev(dev, &ap->link, ENABLED) {\r\nif (dev->horkage & ATA_HORKAGE_NOLPM) {\r\ncount = -EOPNOTSUPP;\r\ngoto out_unlock;\r\n}\r\n}\r\n}\r\nap->target_lpm_policy = policy;\r\nata_port_schedule_eh(ap);\r\nout_unlock:\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn count;\r\n}\r\nstatic ssize_t ata_scsi_lpm_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nif (ap->target_lpm_policy >= ARRAY_SIZE(ata_lpm_policy_names))\r\nreturn -EINVAL;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nata_lpm_policy_names[ap->target_lpm_policy]);\r\n}\r\nstatic ssize_t ata_scsi_park_show(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(device);\r\nstruct ata_port *ap;\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nunsigned long flags, now;\r\nunsigned int uninitialized_var(msecs);\r\nint rc = 0;\r\nap = ata_shost_to_port(sdev->host);\r\nspin_lock_irqsave(ap->lock, flags);\r\ndev = ata_scsi_find_dev(ap, sdev);\r\nif (!dev) {\r\nrc = -ENODEV;\r\ngoto unlock;\r\n}\r\nif (dev->flags & ATA_DFLAG_NO_UNLOAD) {\r\nrc = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\nlink = dev->link;\r\nnow = jiffies;\r\nif (ap->pflags & ATA_PFLAG_EH_IN_PROGRESS &&\r\nlink->eh_context.unloaded_mask & (1 << dev->devno) &&\r\ntime_after(dev->unpark_deadline, now))\r\nmsecs = jiffies_to_msecs(dev->unpark_deadline - now);\r\nelse\r\nmsecs = 0;\r\nunlock:\r\nspin_unlock_irq(ap->lock);\r\nreturn rc ? rc : snprintf(buf, 20, "%u\n", msecs);\r\n}\r\nstatic ssize_t ata_scsi_park_store(struct device *device,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(device);\r\nstruct ata_port *ap;\r\nstruct ata_device *dev;\r\nlong int input;\r\nunsigned long flags;\r\nint rc;\r\nrc = kstrtol(buf, 10, &input);\r\nif (rc)\r\nreturn rc;\r\nif (input < -2)\r\nreturn -EINVAL;\r\nif (input > ATA_TMOUT_MAX_PARK) {\r\nrc = -EOVERFLOW;\r\ninput = ATA_TMOUT_MAX_PARK;\r\n}\r\nap = ata_shost_to_port(sdev->host);\r\nspin_lock_irqsave(ap->lock, flags);\r\ndev = ata_scsi_find_dev(ap, sdev);\r\nif (unlikely(!dev)) {\r\nrc = -ENODEV;\r\ngoto unlock;\r\n}\r\nif (dev->class != ATA_DEV_ATA) {\r\nrc = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\nif (input >= 0) {\r\nif (dev->flags & ATA_DFLAG_NO_UNLOAD) {\r\nrc = -EOPNOTSUPP;\r\ngoto unlock;\r\n}\r\ndev->unpark_deadline = ata_deadline(jiffies, input);\r\ndev->link->eh_info.dev_action[dev->devno] |= ATA_EH_PARK;\r\nata_port_schedule_eh(ap);\r\ncomplete(&ap->park_req_pending);\r\n} else {\r\nswitch (input) {\r\ncase -1:\r\ndev->flags &= ~ATA_DFLAG_NO_UNLOAD;\r\nbreak;\r\ncase -2:\r\ndev->flags |= ATA_DFLAG_NO_UNLOAD;\r\nbreak;\r\n}\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn rc ? rc : len;\r\n}\r\nstatic void ata_scsi_set_sense(struct scsi_cmnd *cmd, u8 sk, u8 asc, u8 ascq)\r\n{\r\ncmd->result = (DRIVER_SENSE << 24) | SAM_STAT_CHECK_CONDITION;\r\nscsi_build_sense_buffer(0, cmd->sense_buffer, sk, asc, ascq);\r\n}\r\nstatic ssize_t\r\nata_scsi_em_message_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nif (ap->ops->em_store && (ap->flags & ATA_FLAG_EM))\r\nreturn ap->ops->em_store(ap, buf, count);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nata_scsi_em_message_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nif (ap->ops->em_show && (ap->flags & ATA_FLAG_EM))\r\nreturn ap->ops->em_show(ap, buf);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nata_scsi_em_message_type_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nreturn snprintf(buf, 23, "%d\n", ap->em_message_type);\r\n}\r\nstatic ssize_t\r\nata_scsi_activity_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct ata_port *ap = ata_shost_to_port(sdev->host);\r\nstruct ata_device *atadev = ata_scsi_find_dev(ap, sdev);\r\nif (atadev && ap->ops->sw_activity_show &&\r\n(ap->flags & ATA_FLAG_SW_ACTIVITY))\r\nreturn ap->ops->sw_activity_show(atadev, buf);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nata_scsi_activity_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct ata_port *ap = ata_shost_to_port(sdev->host);\r\nstruct ata_device *atadev = ata_scsi_find_dev(ap, sdev);\r\nenum sw_activity val;\r\nint rc;\r\nif (atadev && ap->ops->sw_activity_store &&\r\n(ap->flags & ATA_FLAG_SW_ACTIVITY)) {\r\nval = simple_strtoul(buf, NULL, 0);\r\nswitch (val) {\r\ncase OFF: case BLINK_ON: case BLINK_OFF:\r\nrc = ap->ops->sw_activity_store(atadev, val);\r\nif (!rc)\r\nreturn count;\r\nelse\r\nreturn rc;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void ata_scsi_invalid_field(struct scsi_cmnd *cmd)\r\n{\r\nata_scsi_set_sense(cmd, ILLEGAL_REQUEST, 0x24, 0x0);\r\ncmd->scsi_done(cmd);\r\n}\r\nint ata_std_bios_param(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int geom[])\r\n{\r\ngeom[0] = 255;\r\ngeom[1] = 63;\r\nsector_div(capacity, 255*63);\r\ngeom[2] = capacity;\r\nreturn 0;\r\n}\r\nvoid ata_scsi_unlock_native_capacity(struct scsi_device *sdev)\r\n{\r\nstruct ata_port *ap = ata_shost_to_port(sdev->host);\r\nstruct ata_device *dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(ap->lock, flags);\r\ndev = ata_scsi_find_dev(ap, sdev);\r\nif (dev && dev->n_sectors < dev->n_native_sectors) {\r\ndev->flags |= ATA_DFLAG_UNLOCK_HPA;\r\ndev->link->eh_info.action |= ATA_EH_RESET;\r\nata_port_schedule_eh(ap);\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nata_port_wait_eh(ap);\r\n}\r\nstatic int ata_get_identity(struct ata_port *ap, struct scsi_device *sdev,\r\nvoid __user *arg)\r\n{\r\nstruct ata_device *dev = ata_scsi_find_dev(ap, sdev);\r\nu16 __user *dst = arg;\r\nchar buf[40];\r\nif (!dev)\r\nreturn -ENOMSG;\r\nif (copy_to_user(dst, dev->id, ATA_ID_WORDS * sizeof(u16)))\r\nreturn -EFAULT;\r\nata_id_string(dev->id, buf, ATA_ID_PROD, ATA_ID_PROD_LEN);\r\nif (copy_to_user(dst + ATA_ID_PROD, buf, ATA_ID_PROD_LEN))\r\nreturn -EFAULT;\r\nata_id_string(dev->id, buf, ATA_ID_FW_REV, ATA_ID_FW_REV_LEN);\r\nif (copy_to_user(dst + ATA_ID_FW_REV, buf, ATA_ID_FW_REV_LEN))\r\nreturn -EFAULT;\r\nata_id_string(dev->id, buf, ATA_ID_SERNO, ATA_ID_SERNO_LEN);\r\nif (copy_to_user(dst + ATA_ID_SERNO, buf, ATA_ID_SERNO_LEN))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg)\r\n{\r\nint rc = 0;\r\nu8 scsi_cmd[MAX_COMMAND_SIZE];\r\nu8 args[4], *argbuf = NULL, *sensebuf = NULL;\r\nint argsize = 0;\r\nenum dma_data_direction data_dir;\r\nint cmd_result;\r\nif (arg == NULL)\r\nreturn -EINVAL;\r\nif (copy_from_user(args, arg, sizeof(args)))\r\nreturn -EFAULT;\r\nsensebuf = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);\r\nif (!sensebuf)\r\nreturn -ENOMEM;\r\nmemset(scsi_cmd, 0, sizeof(scsi_cmd));\r\nif (args[3]) {\r\nargsize = ATA_SECT_SIZE * args[3];\r\nargbuf = kmalloc(argsize, GFP_KERNEL);\r\nif (argbuf == NULL) {\r\nrc = -ENOMEM;\r\ngoto error;\r\n}\r\nscsi_cmd[1] = (4 << 1);\r\nscsi_cmd[2] = 0x0e;\r\ndata_dir = DMA_FROM_DEVICE;\r\n} else {\r\nscsi_cmd[1] = (3 << 1);\r\nscsi_cmd[2] = 0x20;\r\ndata_dir = DMA_NONE;\r\n}\r\nscsi_cmd[0] = ATA_16;\r\nscsi_cmd[4] = args[2];\r\nif (args[0] == ATA_CMD_SMART) {\r\nscsi_cmd[6] = args[3];\r\nscsi_cmd[8] = args[1];\r\nscsi_cmd[10] = 0x4f;\r\nscsi_cmd[12] = 0xc2;\r\n} else {\r\nscsi_cmd[6] = args[1];\r\n}\r\nscsi_cmd[14] = args[0];\r\ncmd_result = scsi_execute(scsidev, scsi_cmd, data_dir, argbuf, argsize,\r\nsensebuf, (10*HZ), 5, 0, NULL);\r\nif (driver_byte(cmd_result) == DRIVER_SENSE) {\r\nu8 *desc = sensebuf + 8;\r\ncmd_result &= ~(0xFF<<24);\r\nif (cmd_result & SAM_STAT_CHECK_CONDITION) {\r\nstruct scsi_sense_hdr sshdr;\r\nscsi_normalize_sense(sensebuf, SCSI_SENSE_BUFFERSIZE,\r\n&sshdr);\r\nif (sshdr.sense_key == RECOVERED_ERROR &&\r\nsshdr.asc == 0 && sshdr.ascq == 0x1d)\r\ncmd_result &= ~SAM_STAT_CHECK_CONDITION;\r\n}\r\nif (sensebuf[0] == 0x72 &&\r\ndesc[0] == 0x09) {\r\nargs[0] = desc[13];\r\nargs[1] = desc[3];\r\nargs[2] = desc[5];\r\nif (copy_to_user(arg, args, sizeof(args)))\r\nrc = -EFAULT;\r\n}\r\n}\r\nif (cmd_result) {\r\nrc = -EIO;\r\ngoto error;\r\n}\r\nif ((argbuf)\r\n&& copy_to_user(arg + sizeof(args), argbuf, argsize))\r\nrc = -EFAULT;\r\nerror:\r\nkfree(sensebuf);\r\nkfree(argbuf);\r\nreturn rc;\r\n}\r\nint ata_task_ioctl(struct scsi_device *scsidev, void __user *arg)\r\n{\r\nint rc = 0;\r\nu8 scsi_cmd[MAX_COMMAND_SIZE];\r\nu8 args[7], *sensebuf = NULL;\r\nint cmd_result;\r\nif (arg == NULL)\r\nreturn -EINVAL;\r\nif (copy_from_user(args, arg, sizeof(args)))\r\nreturn -EFAULT;\r\nsensebuf = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);\r\nif (!sensebuf)\r\nreturn -ENOMEM;\r\nmemset(scsi_cmd, 0, sizeof(scsi_cmd));\r\nscsi_cmd[0] = ATA_16;\r\nscsi_cmd[1] = (3 << 1);\r\nscsi_cmd[2] = 0x20;\r\nscsi_cmd[4] = args[1];\r\nscsi_cmd[6] = args[2];\r\nscsi_cmd[8] = args[3];\r\nscsi_cmd[10] = args[4];\r\nscsi_cmd[12] = args[5];\r\nscsi_cmd[13] = args[6] & 0x4f;\r\nscsi_cmd[14] = args[0];\r\ncmd_result = scsi_execute(scsidev, scsi_cmd, DMA_NONE, NULL, 0,\r\nsensebuf, (10*HZ), 5, 0, NULL);\r\nif (driver_byte(cmd_result) == DRIVER_SENSE) {\r\nu8 *desc = sensebuf + 8;\r\ncmd_result &= ~(0xFF<<24);\r\nif (cmd_result & SAM_STAT_CHECK_CONDITION) {\r\nstruct scsi_sense_hdr sshdr;\r\nscsi_normalize_sense(sensebuf, SCSI_SENSE_BUFFERSIZE,\r\n&sshdr);\r\nif (sshdr.sense_key == RECOVERED_ERROR &&\r\nsshdr.asc == 0 && sshdr.ascq == 0x1d)\r\ncmd_result &= ~SAM_STAT_CHECK_CONDITION;\r\n}\r\nif (sensebuf[0] == 0x72 &&\r\ndesc[0] == 0x09) {\r\nargs[0] = desc[13];\r\nargs[1] = desc[3];\r\nargs[2] = desc[5];\r\nargs[3] = desc[7];\r\nargs[4] = desc[9];\r\nargs[5] = desc[11];\r\nargs[6] = desc[12];\r\nif (copy_to_user(arg, args, sizeof(args)))\r\nrc = -EFAULT;\r\n}\r\n}\r\nif (cmd_result) {\r\nrc = -EIO;\r\ngoto error;\r\n}\r\nerror:\r\nkfree(sensebuf);\r\nreturn rc;\r\n}\r\nstatic int ata_ioc32(struct ata_port *ap)\r\n{\r\nif (ap->flags & ATA_FLAG_PIO_DMA)\r\nreturn 1;\r\nif (ap->pflags & ATA_PFLAG_PIO32)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *scsidev,\r\nint cmd, void __user *arg)\r\n{\r\nint val = -EINVAL, rc = -EINVAL;\r\nunsigned long flags;\r\nswitch (cmd) {\r\ncase ATA_IOC_GET_IO32:\r\nspin_lock_irqsave(ap->lock, flags);\r\nval = ata_ioc32(ap);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nif (copy_to_user(arg, &val, 1))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase ATA_IOC_SET_IO32:\r\nval = (unsigned long) arg;\r\nrc = 0;\r\nspin_lock_irqsave(ap->lock, flags);\r\nif (ap->pflags & ATA_PFLAG_PIO32CHANGE) {\r\nif (val)\r\nap->pflags |= ATA_PFLAG_PIO32;\r\nelse\r\nap->pflags &= ~ATA_PFLAG_PIO32;\r\n} else {\r\nif (val != ata_ioc32(ap))\r\nrc = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn rc;\r\ncase HDIO_GET_IDENTITY:\r\nreturn ata_get_identity(ap, scsidev, arg);\r\ncase HDIO_DRIVE_CMD:\r\nif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nreturn ata_cmd_ioctl(scsidev, arg);\r\ncase HDIO_DRIVE_TASK:\r\nif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nreturn ata_task_ioctl(scsidev, arg);\r\ndefault:\r\nrc = -ENOTTY;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint ata_scsi_ioctl(struct scsi_device *scsidev, int cmd, void __user *arg)\r\n{\r\nreturn ata_sas_scsi_ioctl(ata_shost_to_port(scsidev->host),\r\nscsidev, cmd, arg);\r\n}\r\nstatic struct ata_queued_cmd *ata_scsi_qc_new(struct ata_device *dev,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct ata_queued_cmd *qc;\r\nqc = ata_qc_new_init(dev);\r\nif (qc) {\r\nqc->scsicmd = cmd;\r\nqc->scsidone = cmd->scsi_done;\r\nqc->sg = scsi_sglist(cmd);\r\nqc->n_elem = scsi_sg_count(cmd);\r\n} else {\r\ncmd->result = (DID_OK << 16) | (QUEUE_FULL << 1);\r\ncmd->scsi_done(cmd);\r\n}\r\nreturn qc;\r\n}\r\nstatic void ata_qc_set_pc_nbytes(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nqc->extrabytes = scmd->request->extra_len;\r\nqc->nbytes = scsi_bufflen(scmd) + qc->extrabytes;\r\n}\r\nstatic void ata_dump_status(unsigned id, struct ata_taskfile *tf)\r\n{\r\nu8 stat = tf->command, err = tf->feature;\r\nprintk(KERN_WARNING "ata%u: status=0x%02x { ", id, stat);\r\nif (stat & ATA_BUSY) {\r\nprintk("Busy }\n");\r\n} else {\r\nif (stat & 0x40) printk("DriveReady ");\r\nif (stat & 0x20) printk("DeviceFault ");\r\nif (stat & 0x10) printk("SeekComplete ");\r\nif (stat & 0x08) printk("DataRequest ");\r\nif (stat & 0x04) printk("CorrectedError ");\r\nif (stat & 0x02) printk("Index ");\r\nif (stat & 0x01) printk("Error ");\r\nprintk("}\n");\r\nif (err) {\r\nprintk(KERN_WARNING "ata%u: error=0x%02x { ", id, err);\r\nif (err & 0x04) printk("DriveStatusError ");\r\nif (err & 0x80) {\r\nif (err & 0x04) printk("BadCRC ");\r\nelse printk("Sector ");\r\n}\r\nif (err & 0x40) printk("UncorrectableError ");\r\nif (err & 0x10) printk("SectorIdNotFound ");\r\nif (err & 0x02) printk("TrackZeroNotFound ");\r\nif (err & 0x01) printk("AddrMarkNotFound ");\r\nprintk("}\n");\r\n}\r\n}\r\n}\r\nstatic void ata_to_sense_error(unsigned id, u8 drv_stat, u8 drv_err, u8 *sk,\r\nu8 *asc, u8 *ascq, int verbose)\r\n{\r\nint i;\r\nstatic const unsigned char sense_table[][4] = {\r\n{0xd1, ABORTED_COMMAND, 0x00, 0x00},\r\n{0xd0, ABORTED_COMMAND, 0x00, 0x00},\r\n{0x61, HARDWARE_ERROR, 0x00, 0x00},\r\n{0x84, ABORTED_COMMAND, 0x47, 0x00},\r\n{0x37, NOT_READY, 0x04, 0x00},\r\n{0x09, NOT_READY, 0x04, 0x00},\r\n{0x01, MEDIUM_ERROR, 0x13, 0x00},\r\n{0x02, HARDWARE_ERROR, 0x00, 0x00},\r\n{0x08, NOT_READY, 0x04, 0x00},\r\n{0x10, ILLEGAL_REQUEST, 0x21, 0x00},\r\n{0x20, UNIT_ATTENTION, 0x28, 0x00},\r\n{0x40, MEDIUM_ERROR, 0x11, 0x04},\r\n{0x80, MEDIUM_ERROR, 0x11, 0x04},\r\n{0xFF, 0xFF, 0xFF, 0xFF},\r\n};\r\nstatic const unsigned char stat_table[][4] = {\r\n{0x80, ABORTED_COMMAND, 0x47, 0x00},\r\n{0x20, HARDWARE_ERROR, 0x44, 0x00},\r\n{0x08, ABORTED_COMMAND, 0x47, 0x00},\r\n{0x04, RECOVERED_ERROR, 0x11, 0x00},\r\n{0xFF, 0xFF, 0xFF, 0xFF},\r\n};\r\nif (drv_stat & ATA_BUSY) {\r\ndrv_err = 0;\r\n}\r\nif (drv_err) {\r\nfor (i = 0; sense_table[i][0] != 0xFF; i++) {\r\nif ((sense_table[i][0] & drv_err) ==\r\nsense_table[i][0]) {\r\n*sk = sense_table[i][1];\r\n*asc = sense_table[i][2];\r\n*ascq = sense_table[i][3];\r\ngoto translate_done;\r\n}\r\n}\r\n}\r\nfor (i = 0; stat_table[i][0] != 0xFF; i++) {\r\nif (stat_table[i][0] & drv_stat) {\r\n*sk = stat_table[i][1];\r\n*asc = stat_table[i][2];\r\n*ascq = stat_table[i][3];\r\ngoto translate_done;\r\n}\r\n}\r\n*sk = ABORTED_COMMAND;\r\n*asc = 0x00;\r\n*ascq = 0x00;\r\ntranslate_done:\r\nif (verbose)\r\nprintk(KERN_ERR "ata%u: translated ATA stat/err 0x%02x/%02x "\r\n"to SCSI SK/ASC/ASCQ 0x%x/%02x/%02x\n",\r\nid, drv_stat, drv_err, *sk, *asc, *ascq);\r\nreturn;\r\n}\r\nstatic void ata_gen_passthru_sense(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *cmd = qc->scsicmd;\r\nstruct ata_taskfile *tf = &qc->result_tf;\r\nunsigned char *sb = cmd->sense_buffer;\r\nunsigned char *desc = sb + 8;\r\nint verbose = qc->ap->ops->error_handler == NULL;\r\nmemset(sb, 0, SCSI_SENSE_BUFFERSIZE);\r\ncmd->result = (DRIVER_SENSE << 24) | SAM_STAT_CHECK_CONDITION;\r\nif (qc->err_mask ||\r\ntf->command & (ATA_BUSY | ATA_DF | ATA_ERR | ATA_DRQ)) {\r\nata_to_sense_error(qc->ap->print_id, tf->command, tf->feature,\r\n&sb[1], &sb[2], &sb[3], verbose);\r\nsb[1] &= 0x0f;\r\n} else {\r\nsb[1] = RECOVERED_ERROR;\r\nsb[2] = 0;\r\nsb[3] = 0x1D;\r\n}\r\nsb[0] = 0x72;\r\ndesc[0] = 0x09;\r\nsb[7] = 14;\r\ndesc[1] = 12;\r\ndesc[2] = 0x00;\r\ndesc[3] = tf->feature;\r\ndesc[5] = tf->nsect;\r\ndesc[7] = tf->lbal;\r\ndesc[9] = tf->lbam;\r\ndesc[11] = tf->lbah;\r\ndesc[12] = tf->device;\r\ndesc[13] = tf->command;\r\nif (tf->flags & ATA_TFLAG_LBA48) {\r\ndesc[2] |= 0x01;\r\ndesc[4] = tf->hob_nsect;\r\ndesc[6] = tf->hob_lbal;\r\ndesc[8] = tf->hob_lbam;\r\ndesc[10] = tf->hob_lbah;\r\n}\r\n}\r\nstatic void ata_gen_ata_sense(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_device *dev = qc->dev;\r\nstruct scsi_cmnd *cmd = qc->scsicmd;\r\nstruct ata_taskfile *tf = &qc->result_tf;\r\nunsigned char *sb = cmd->sense_buffer;\r\nunsigned char *desc = sb + 8;\r\nint verbose = qc->ap->ops->error_handler == NULL;\r\nu64 block;\r\nmemset(sb, 0, SCSI_SENSE_BUFFERSIZE);\r\ncmd->result = (DRIVER_SENSE << 24) | SAM_STAT_CHECK_CONDITION;\r\nsb[0] = 0x72;\r\nif (qc->err_mask ||\r\ntf->command & (ATA_BUSY | ATA_DF | ATA_ERR | ATA_DRQ)) {\r\nata_to_sense_error(qc->ap->print_id, tf->command, tf->feature,\r\n&sb[1], &sb[2], &sb[3], verbose);\r\nsb[1] &= 0x0f;\r\n}\r\nblock = ata_tf_read_block(&qc->result_tf, dev);\r\nsb[7] = 12;\r\ndesc[0] = 0x00;\r\ndesc[1] = 10;\r\ndesc[2] |= 0x80;\r\ndesc[6] = block >> 40;\r\ndesc[7] = block >> 32;\r\ndesc[8] = block >> 24;\r\ndesc[9] = block >> 16;\r\ndesc[10] = block >> 8;\r\ndesc[11] = block;\r\n}\r\nstatic void ata_scsi_sdev_config(struct scsi_device *sdev)\r\n{\r\nsdev->use_10_for_rw = 1;\r\nsdev->use_10_for_ms = 1;\r\nsdev->no_report_opcodes = 1;\r\nsdev->no_write_same = 1;\r\nsdev->max_device_blocked = 1;\r\n}\r\nstatic int atapi_drain_needed(struct request *rq)\r\n{\r\nif (likely(rq->cmd_type != REQ_TYPE_BLOCK_PC))\r\nreturn 0;\r\nif (!blk_rq_bytes(rq) || (rq->cmd_flags & REQ_WRITE))\r\nreturn 0;\r\nreturn atapi_cmd_type(rq->cmd[0]) == ATAPI_MISC;\r\n}\r\nstatic int ata_scsi_dev_config(struct scsi_device *sdev,\r\nstruct ata_device *dev)\r\n{\r\nstruct request_queue *q = sdev->request_queue;\r\nif (!ata_id_has_unload(dev->id))\r\ndev->flags |= ATA_DFLAG_NO_UNLOAD;\r\nblk_queue_max_hw_sectors(q, dev->max_sectors);\r\nif (dev->class == ATA_DEV_ATAPI) {\r\nvoid *buf;\r\nsdev->sector_size = ATA_SECT_SIZE;\r\nblk_queue_update_dma_pad(q, ATA_DMA_PAD_SZ - 1);\r\nbuf = kmalloc(ATAPI_MAX_DRAIN, q->bounce_gfp | GFP_KERNEL);\r\nif (!buf) {\r\nata_dev_err(dev, "drain buffer allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nblk_queue_dma_drain(q, atapi_drain_needed, buf, ATAPI_MAX_DRAIN);\r\n} else {\r\nsdev->sector_size = ata_id_logical_sector_size(dev->id);\r\nsdev->manage_start_stop = 1;\r\n}\r\nif (sdev->sector_size > PAGE_SIZE)\r\nata_dev_warn(dev,\r\n"sector_size=%u > PAGE_SIZE, PIO may malfunction\n",\r\nsdev->sector_size);\r\nblk_queue_update_dma_alignment(q, sdev->sector_size - 1);\r\nif (dev->flags & ATA_DFLAG_AN)\r\nset_bit(SDEV_EVT_MEDIA_CHANGE, sdev->supported_events);\r\nif (dev->flags & ATA_DFLAG_NCQ) {\r\nint depth;\r\ndepth = min(sdev->host->can_queue, ata_id_queue_depth(dev->id));\r\ndepth = min(ATA_MAX_QUEUE - 1, depth);\r\nscsi_adjust_queue_depth(sdev, MSG_SIMPLE_TAG, depth);\r\n}\r\nblk_queue_flush_queueable(q, false);\r\ndev->sdev = sdev;\r\nreturn 0;\r\n}\r\nint ata_scsi_slave_config(struct scsi_device *sdev)\r\n{\r\nstruct ata_port *ap = ata_shost_to_port(sdev->host);\r\nstruct ata_device *dev = __ata_scsi_find_dev(ap, sdev);\r\nint rc = 0;\r\nata_scsi_sdev_config(sdev);\r\nif (dev)\r\nrc = ata_scsi_dev_config(sdev, dev);\r\nreturn rc;\r\n}\r\nvoid ata_scsi_slave_destroy(struct scsi_device *sdev)\r\n{\r\nstruct ata_port *ap = ata_shost_to_port(sdev->host);\r\nstruct request_queue *q = sdev->request_queue;\r\nunsigned long flags;\r\nstruct ata_device *dev;\r\nif (!ap->ops->error_handler)\r\nreturn;\r\nspin_lock_irqsave(ap->lock, flags);\r\ndev = __ata_scsi_find_dev(ap, sdev);\r\nif (dev && dev->sdev) {\r\ndev->sdev = NULL;\r\ndev->flags |= ATA_DFLAG_DETACH;\r\nata_port_schedule_eh(ap);\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nkfree(q->dma_drain_buffer);\r\nq->dma_drain_buffer = NULL;\r\nq->dma_drain_size = 0;\r\n}\r\nint __ata_change_queue_depth(struct ata_port *ap, struct scsi_device *sdev,\r\nint queue_depth, int reason)\r\n{\r\nstruct ata_device *dev;\r\nunsigned long flags;\r\nif (reason != SCSI_QDEPTH_DEFAULT)\r\nreturn -EOPNOTSUPP;\r\nif (queue_depth < 1 || queue_depth == sdev->queue_depth)\r\nreturn sdev->queue_depth;\r\ndev = ata_scsi_find_dev(ap, sdev);\r\nif (!dev || !ata_dev_enabled(dev))\r\nreturn sdev->queue_depth;\r\nspin_lock_irqsave(ap->lock, flags);\r\ndev->flags &= ~ATA_DFLAG_NCQ_OFF;\r\nif (queue_depth == 1 || !ata_ncq_enabled(dev)) {\r\ndev->flags |= ATA_DFLAG_NCQ_OFF;\r\nqueue_depth = 1;\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nqueue_depth = min(queue_depth, sdev->host->can_queue);\r\nqueue_depth = min(queue_depth, ata_id_queue_depth(dev->id));\r\nqueue_depth = min(queue_depth, ATA_MAX_QUEUE - 1);\r\nif (sdev->queue_depth == queue_depth)\r\nreturn -EINVAL;\r\nscsi_adjust_queue_depth(sdev, MSG_SIMPLE_TAG, queue_depth);\r\nreturn queue_depth;\r\n}\r\nint ata_scsi_change_queue_depth(struct scsi_device *sdev, int queue_depth,\r\nint reason)\r\n{\r\nstruct ata_port *ap = ata_shost_to_port(sdev->host);\r\nreturn __ata_change_queue_depth(ap, sdev, queue_depth, reason);\r\n}\r\nstatic unsigned int ata_scsi_start_stop_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nstruct ata_taskfile *tf = &qc->tf;\r\nconst u8 *cdb = scmd->cmnd;\r\nif (scmd->cmd_len < 5)\r\ngoto invalid_fld;\r\ntf->flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;\r\ntf->protocol = ATA_PROT_NODATA;\r\nif (cdb[1] & 0x1) {\r\n;\r\n}\r\nif (cdb[4] & 0x2)\r\ngoto invalid_fld;\r\nif (((cdb[4] >> 4) & 0xf) != 0)\r\ngoto invalid_fld;\r\nif (cdb[4] & 0x1) {\r\ntf->nsect = 1;\r\nif (qc->dev->flags & ATA_DFLAG_LBA) {\r\ntf->flags |= ATA_TFLAG_LBA;\r\ntf->lbah = 0x0;\r\ntf->lbam = 0x0;\r\ntf->lbal = 0x0;\r\ntf->device |= ATA_LBA;\r\n} else {\r\ntf->lbal = 0x1;\r\ntf->lbam = 0x0;\r\ntf->lbah = 0x0;\r\n}\r\ntf->command = ATA_CMD_VERIFY;\r\n} else {\r\nif ((qc->ap->flags & ATA_FLAG_NO_POWEROFF_SPINDOWN) &&\r\nsystem_state == SYSTEM_POWER_OFF)\r\ngoto skip;\r\nif ((qc->ap->flags & ATA_FLAG_NO_HIBERNATE_SPINDOWN) &&\r\nsystem_entering_hibernation())\r\ngoto skip;\r\ntf->command = ATA_CMD_STANDBYNOW1;\r\n}\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_sense(scmd, ILLEGAL_REQUEST, 0x24, 0x0);\r\nreturn 1;\r\nskip:\r\nscmd->result = SAM_STAT_GOOD;\r\nreturn 1;\r\n}\r\nstatic unsigned int ata_scsi_flush_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_taskfile *tf = &qc->tf;\r\ntf->flags |= ATA_TFLAG_DEVICE;\r\ntf->protocol = ATA_PROT_NODATA;\r\nif (qc->dev->flags & ATA_DFLAG_FLUSH_EXT)\r\ntf->command = ATA_CMD_FLUSH_EXT;\r\nelse\r\ntf->command = ATA_CMD_FLUSH;\r\nqc->flags |= ATA_QCFLAG_IO;\r\nreturn 0;\r\n}\r\nstatic void scsi_6_lba_len(const u8 *cdb, u64 *plba, u32 *plen)\r\n{\r\nu64 lba = 0;\r\nu32 len;\r\nVPRINTK("six-byte command\n");\r\nlba |= ((u64)(cdb[1] & 0x1f)) << 16;\r\nlba |= ((u64)cdb[2]) << 8;\r\nlba |= ((u64)cdb[3]);\r\nlen = cdb[4];\r\n*plba = lba;\r\n*plen = len;\r\n}\r\nstatic void scsi_10_lba_len(const u8 *cdb, u64 *plba, u32 *plen)\r\n{\r\nu64 lba = 0;\r\nu32 len = 0;\r\nVPRINTK("ten-byte command\n");\r\nlba |= ((u64)cdb[2]) << 24;\r\nlba |= ((u64)cdb[3]) << 16;\r\nlba |= ((u64)cdb[4]) << 8;\r\nlba |= ((u64)cdb[5]);\r\nlen |= ((u32)cdb[7]) << 8;\r\nlen |= ((u32)cdb[8]);\r\n*plba = lba;\r\n*plen = len;\r\n}\r\nstatic void scsi_16_lba_len(const u8 *cdb, u64 *plba, u32 *plen)\r\n{\r\nu64 lba = 0;\r\nu32 len = 0;\r\nVPRINTK("sixteen-byte command\n");\r\nlba |= ((u64)cdb[2]) << 56;\r\nlba |= ((u64)cdb[3]) << 48;\r\nlba |= ((u64)cdb[4]) << 40;\r\nlba |= ((u64)cdb[5]) << 32;\r\nlba |= ((u64)cdb[6]) << 24;\r\nlba |= ((u64)cdb[7]) << 16;\r\nlba |= ((u64)cdb[8]) << 8;\r\nlba |= ((u64)cdb[9]);\r\nlen |= ((u32)cdb[10]) << 24;\r\nlen |= ((u32)cdb[11]) << 16;\r\nlen |= ((u32)cdb[12]) << 8;\r\nlen |= ((u32)cdb[13]);\r\n*plba = lba;\r\n*plen = len;\r\n}\r\nstatic unsigned int ata_scsi_verify_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nstruct ata_taskfile *tf = &qc->tf;\r\nstruct ata_device *dev = qc->dev;\r\nu64 dev_sectors = qc->dev->n_sectors;\r\nconst u8 *cdb = scmd->cmnd;\r\nu64 block;\r\nu32 n_block;\r\ntf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\ntf->protocol = ATA_PROT_NODATA;\r\nif (cdb[0] == VERIFY) {\r\nif (scmd->cmd_len < 10)\r\ngoto invalid_fld;\r\nscsi_10_lba_len(cdb, &block, &n_block);\r\n} else if (cdb[0] == VERIFY_16) {\r\nif (scmd->cmd_len < 16)\r\ngoto invalid_fld;\r\nscsi_16_lba_len(cdb, &block, &n_block);\r\n} else\r\ngoto invalid_fld;\r\nif (!n_block)\r\ngoto nothing_to_do;\r\nif (block >= dev_sectors)\r\ngoto out_of_range;\r\nif ((block + n_block) > dev_sectors)\r\ngoto out_of_range;\r\nif (dev->flags & ATA_DFLAG_LBA) {\r\ntf->flags |= ATA_TFLAG_LBA;\r\nif (lba_28_ok(block, n_block)) {\r\ntf->command = ATA_CMD_VERIFY;\r\ntf->device |= (block >> 24) & 0xf;\r\n} else if (lba_48_ok(block, n_block)) {\r\nif (!(dev->flags & ATA_DFLAG_LBA48))\r\ngoto out_of_range;\r\ntf->flags |= ATA_TFLAG_LBA48;\r\ntf->command = ATA_CMD_VERIFY_EXT;\r\ntf->hob_nsect = (n_block >> 8) & 0xff;\r\ntf->hob_lbah = (block >> 40) & 0xff;\r\ntf->hob_lbam = (block >> 32) & 0xff;\r\ntf->hob_lbal = (block >> 24) & 0xff;\r\n} else\r\ngoto out_of_range;\r\ntf->nsect = n_block & 0xff;\r\ntf->lbah = (block >> 16) & 0xff;\r\ntf->lbam = (block >> 8) & 0xff;\r\ntf->lbal = block & 0xff;\r\ntf->device |= ATA_LBA;\r\n} else {\r\nu32 sect, head, cyl, track;\r\nif (!lba_28_ok(block, n_block))\r\ngoto out_of_range;\r\ntrack = (u32)block / dev->sectors;\r\ncyl = track / dev->heads;\r\nhead = track % dev->heads;\r\nsect = (u32)block % dev->sectors + 1;\r\nDPRINTK("block %u track %u cyl %u head %u sect %u\n",\r\n(u32)block, track, cyl, head, sect);\r\nif ((cyl >> 16) || (head >> 4) || (sect >> 8) || (!sect))\r\ngoto out_of_range;\r\ntf->command = ATA_CMD_VERIFY;\r\ntf->nsect = n_block & 0xff;\r\ntf->lbal = sect;\r\ntf->lbam = cyl;\r\ntf->lbah = cyl >> 8;\r\ntf->device |= head;\r\n}\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_sense(scmd, ILLEGAL_REQUEST, 0x24, 0x0);\r\nreturn 1;\r\nout_of_range:\r\nata_scsi_set_sense(scmd, ILLEGAL_REQUEST, 0x21, 0x0);\r\nreturn 1;\r\nnothing_to_do:\r\nscmd->result = SAM_STAT_GOOD;\r\nreturn 1;\r\n}\r\nstatic unsigned int ata_scsi_rw_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nconst u8 *cdb = scmd->cmnd;\r\nunsigned int tf_flags = 0;\r\nu64 block;\r\nu32 n_block;\r\nint rc;\r\nif (cdb[0] == WRITE_10 || cdb[0] == WRITE_6 || cdb[0] == WRITE_16)\r\ntf_flags |= ATA_TFLAG_WRITE;\r\nswitch (cdb[0]) {\r\ncase READ_10:\r\ncase WRITE_10:\r\nif (unlikely(scmd->cmd_len < 10))\r\ngoto invalid_fld;\r\nscsi_10_lba_len(cdb, &block, &n_block);\r\nif (cdb[1] & (1 << 3))\r\ntf_flags |= ATA_TFLAG_FUA;\r\nbreak;\r\ncase READ_6:\r\ncase WRITE_6:\r\nif (unlikely(scmd->cmd_len < 6))\r\ngoto invalid_fld;\r\nscsi_6_lba_len(cdb, &block, &n_block);\r\nif (!n_block)\r\nn_block = 256;\r\nbreak;\r\ncase READ_16:\r\ncase WRITE_16:\r\nif (unlikely(scmd->cmd_len < 16))\r\ngoto invalid_fld;\r\nscsi_16_lba_len(cdb, &block, &n_block);\r\nif (cdb[1] & (1 << 3))\r\ntf_flags |= ATA_TFLAG_FUA;\r\nbreak;\r\ndefault:\r\nDPRINTK("no-byte command\n");\r\ngoto invalid_fld;\r\n}\r\nif (!n_block)\r\ngoto nothing_to_do;\r\nqc->flags |= ATA_QCFLAG_IO;\r\nqc->nbytes = n_block * scmd->device->sector_size;\r\nrc = ata_build_rw_tf(&qc->tf, qc->dev, block, n_block, tf_flags,\r\nqc->tag);\r\nif (likely(rc == 0))\r\nreturn 0;\r\nif (rc == -ERANGE)\r\ngoto out_of_range;\r\ninvalid_fld:\r\nata_scsi_set_sense(scmd, ILLEGAL_REQUEST, 0x24, 0x0);\r\nreturn 1;\r\nout_of_range:\r\nata_scsi_set_sense(scmd, ILLEGAL_REQUEST, 0x21, 0x0);\r\nreturn 1;\r\nnothing_to_do:\r\nscmd->result = SAM_STAT_GOOD;\r\nreturn 1;\r\n}\r\nstatic void ata_scsi_qc_complete(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct scsi_cmnd *cmd = qc->scsicmd;\r\nu8 *cdb = cmd->cmnd;\r\nint need_sense = (qc->err_mask != 0);\r\nif (((cdb[0] == ATA_16) || (cdb[0] == ATA_12)) &&\r\n((cdb[2] & 0x20) || need_sense)) {\r\nata_gen_passthru_sense(qc);\r\n} else {\r\nif (!need_sense) {\r\ncmd->result = SAM_STAT_GOOD;\r\n} else {\r\nata_gen_ata_sense(qc);\r\n}\r\n}\r\nif (need_sense && !ap->ops->error_handler)\r\nata_dump_status(ap->print_id, &qc->result_tf);\r\nqc->scsidone(cmd);\r\nata_qc_free(qc);\r\n}\r\nstatic int ata_scsi_translate(struct ata_device *dev, struct scsi_cmnd *cmd,\r\nata_xlat_func_t xlat_func)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nstruct ata_queued_cmd *qc;\r\nint rc;\r\nVPRINTK("ENTER\n");\r\nqc = ata_scsi_qc_new(dev, cmd);\r\nif (!qc)\r\ngoto err_mem;\r\nif (cmd->sc_data_direction == DMA_FROM_DEVICE ||\r\ncmd->sc_data_direction == DMA_TO_DEVICE) {\r\nif (unlikely(scsi_bufflen(cmd) < 1)) {\r\nata_dev_warn(dev, "WARNING: zero len r/w req\n");\r\ngoto err_did;\r\n}\r\nata_sg_init(qc, scsi_sglist(cmd), scsi_sg_count(cmd));\r\nqc->dma_dir = cmd->sc_data_direction;\r\n}\r\nqc->complete_fn = ata_scsi_qc_complete;\r\nif (xlat_func(qc))\r\ngoto early_finish;\r\nif (ap->ops->qc_defer) {\r\nif ((rc = ap->ops->qc_defer(qc)))\r\ngoto defer;\r\n}\r\nata_qc_issue(qc);\r\nVPRINTK("EXIT\n");\r\nreturn 0;\r\nearly_finish:\r\nata_qc_free(qc);\r\ncmd->scsi_done(cmd);\r\nDPRINTK("EXIT - early finish (good or error)\n");\r\nreturn 0;\r\nerr_did:\r\nata_qc_free(qc);\r\ncmd->result = (DID_ERROR << 16);\r\ncmd->scsi_done(cmd);\r\nerr_mem:\r\nDPRINTK("EXIT - internal\n");\r\nreturn 0;\r\ndefer:\r\nata_qc_free(qc);\r\nDPRINTK("EXIT - defer\n");\r\nif (rc == ATA_DEFER_LINK)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\nelse\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nstatic void *ata_scsi_rbuf_get(struct scsi_cmnd *cmd, bool copy_in,\r\nunsigned long *flags)\r\n{\r\nspin_lock_irqsave(&ata_scsi_rbuf_lock, *flags);\r\nmemset(ata_scsi_rbuf, 0, ATA_SCSI_RBUF_SIZE);\r\nif (copy_in)\r\nsg_copy_to_buffer(scsi_sglist(cmd), scsi_sg_count(cmd),\r\nata_scsi_rbuf, ATA_SCSI_RBUF_SIZE);\r\nreturn ata_scsi_rbuf;\r\n}\r\nstatic inline void ata_scsi_rbuf_put(struct scsi_cmnd *cmd, bool copy_out,\r\nunsigned long *flags)\r\n{\r\nif (copy_out)\r\nsg_copy_from_buffer(scsi_sglist(cmd), scsi_sg_count(cmd),\r\nata_scsi_rbuf, ATA_SCSI_RBUF_SIZE);\r\nspin_unlock_irqrestore(&ata_scsi_rbuf_lock, *flags);\r\n}\r\nstatic unsigned int ata_scsiop_inq_std(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nconst u8 versions[] = {\r\n0x60,\r\n0x03,\r\n0x20,\r\n0x02,\r\n0x60\r\n};\r\nu8 hdr[] = {\r\nTYPE_DISK,\r\n0,\r\n0x5,\r\n2,\r\n95 - 4\r\n};\r\nVPRINTK("ENTER\n");\r\nif (ata_id_removeable(args->id))\r\nhdr[1] |= (1 << 7);\r\nmemcpy(rbuf, hdr, sizeof(hdr));\r\nmemcpy(&rbuf[8], "ATA ", 8);\r\nata_id_string(args->id, &rbuf[16], ATA_ID_PROD, 16);\r\nata_id_string(args->id, &rbuf[32], ATA_ID_FW_REV, 4);\r\nif (rbuf[32] == 0 || rbuf[32] == ' ')\r\nmemcpy(&rbuf[32], "n/a ", 4);\r\nmemcpy(rbuf + 59, versions, sizeof(versions));\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_00(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nconst u8 pages[] = {\r\n0x00,\r\n0x80,\r\n0x83,\r\n0x89,\r\n0xb0,\r\n0xb1,\r\n0xb2,\r\n};\r\nrbuf[3] = sizeof(pages);\r\nmemcpy(rbuf + 4, pages, sizeof(pages));\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_80(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nconst u8 hdr[] = {\r\n0,\r\n0x80,\r\n0,\r\nATA_ID_SERNO_LEN,\r\n};\r\nmemcpy(rbuf, hdr, sizeof(hdr));\r\nata_id_string(args->id, (unsigned char *) &rbuf[4],\r\nATA_ID_SERNO, ATA_ID_SERNO_LEN);\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_83(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nconst int sat_model_serial_desc_len = 68;\r\nint num;\r\nrbuf[1] = 0x83;\r\nnum = 4;\r\nrbuf[num + 0] = 2;\r\nrbuf[num + 3] = ATA_ID_SERNO_LEN;\r\nnum += 4;\r\nata_id_string(args->id, (unsigned char *) rbuf + num,\r\nATA_ID_SERNO, ATA_ID_SERNO_LEN);\r\nnum += ATA_ID_SERNO_LEN;\r\nrbuf[num + 0] = 2;\r\nrbuf[num + 1] = 1;\r\nrbuf[num + 3] = sat_model_serial_desc_len;\r\nnum += 4;\r\nmemcpy(rbuf + num, "ATA ", 8);\r\nnum += 8;\r\nata_id_string(args->id, (unsigned char *) rbuf + num, ATA_ID_PROD,\r\nATA_ID_PROD_LEN);\r\nnum += ATA_ID_PROD_LEN;\r\nata_id_string(args->id, (unsigned char *) rbuf + num, ATA_ID_SERNO,\r\nATA_ID_SERNO_LEN);\r\nnum += ATA_ID_SERNO_LEN;\r\nif (ata_id_has_wwn(args->id)) {\r\nrbuf[num + 0] = 1;\r\nrbuf[num + 1] = 3;\r\nrbuf[num + 3] = ATA_ID_WWN_LEN;\r\nnum += 4;\r\nata_id_string(args->id, (unsigned char *) rbuf + num,\r\nATA_ID_WWN, ATA_ID_WWN_LEN);\r\nnum += ATA_ID_WWN_LEN;\r\n}\r\nrbuf[3] = num - 4;\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_89(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nstruct ata_taskfile tf;\r\nmemset(&tf, 0, sizeof(tf));\r\nrbuf[1] = 0x89;\r\nrbuf[2] = (0x238 >> 8);\r\nrbuf[3] = (0x238 & 0xff);\r\nmemcpy(&rbuf[8], "linux ", 8);\r\nmemcpy(&rbuf[16], "libata ", 16);\r\nmemcpy(&rbuf[32], DRV_VERSION, 4);\r\ntf.command = ATA_DRDY;\r\ntf.lbal = 0x1;\r\ntf.nsect = 0x1;\r\nata_tf_to_fis(&tf, 0, 1, &rbuf[36]);\r\nrbuf[36] = 0x34;\r\nrbuf[56] = ATA_CMD_ID_ATA;\r\nmemcpy(&rbuf[60], &args->id[0], 512);\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_b0(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nu16 min_io_sectors;\r\nrbuf[1] = 0xb0;\r\nrbuf[3] = 0x3c;\r\nmin_io_sectors = 1 << ata_id_log2_per_physical_sector(args->id);\r\nput_unaligned_be16(min_io_sectors, &rbuf[6]);\r\nif (ata_id_has_trim(args->id)) {\r\nput_unaligned_be64(65535 * 512 / 8, &rbuf[36]);\r\nput_unaligned_be32(1, &rbuf[28]);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_b1(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nint form_factor = ata_id_form_factor(args->id);\r\nint media_rotation_rate = ata_id_rotation_rate(args->id);\r\nrbuf[1] = 0xb1;\r\nrbuf[3] = 0x3c;\r\nrbuf[4] = media_rotation_rate >> 8;\r\nrbuf[5] = media_rotation_rate;\r\nrbuf[7] = form_factor;\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_inq_b2(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nrbuf[1] = 0xb2;\r\nrbuf[3] = 0x4;\r\nrbuf[5] = 1 << 6;\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_noop(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nVPRINTK("ENTER\n");\r\nreturn 0;\r\n}\r\nstatic void modecpy(u8 *dest, const u8 *src, int n, bool changeable)\r\n{\r\nif (changeable) {\r\nmemcpy(dest, src, 2);\r\nmemset(dest + 2, 0, n - 2);\r\n} else {\r\nmemcpy(dest, src, n);\r\n}\r\n}\r\nstatic unsigned int ata_msense_caching(u16 *id, u8 *buf, bool changeable)\r\n{\r\nmodecpy(buf, def_cache_mpage, sizeof(def_cache_mpage), changeable);\r\nif (changeable || ata_id_wcache_enabled(id))\r\nbuf[2] |= (1 << 2);\r\nif (!changeable && !ata_id_rahead_enabled(id))\r\nbuf[12] |= (1 << 5);\r\nreturn sizeof(def_cache_mpage);\r\n}\r\nstatic unsigned int ata_msense_ctl_mode(u8 *buf, bool changeable)\r\n{\r\nmodecpy(buf, def_control_mpage, sizeof(def_control_mpage), changeable);\r\nreturn sizeof(def_control_mpage);\r\n}\r\nstatic unsigned int ata_msense_rw_recovery(u8 *buf, bool changeable)\r\n{\r\nmodecpy(buf, def_rw_recovery_mpage, sizeof(def_rw_recovery_mpage),\r\nchangeable);\r\nreturn sizeof(def_rw_recovery_mpage);\r\n}\r\nstatic int ata_dev_supports_fua(u16 *id)\r\n{\r\nunsigned char model[ATA_ID_PROD_LEN + 1], fw[ATA_ID_FW_REV_LEN + 1];\r\nif (!libata_fua)\r\nreturn 0;\r\nif (!ata_id_has_fua(id))\r\nreturn 0;\r\nata_id_c_string(id, model, ATA_ID_PROD, sizeof(model));\r\nata_id_c_string(id, fw, ATA_ID_FW_REV, sizeof(fw));\r\nif (strcmp(model, "Maxtor"))\r\nreturn 1;\r\nif (strcmp(fw, "BANC1G10"))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_mode_sense(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nstruct ata_device *dev = args->dev;\r\nu8 *scsicmd = args->cmd->cmnd, *p = rbuf;\r\nconst u8 sat_blk_desc[] = {\r\n0, 0, 0, 0,\r\n0,\r\n0, 0x2, 0x0\r\n};\r\nu8 pg, spg;\r\nunsigned int ebd, page_control, six_byte;\r\nu8 dpofua;\r\nVPRINTK("ENTER\n");\r\nsix_byte = (scsicmd[0] == MODE_SENSE);\r\nebd = !(scsicmd[1] & 0x8);\r\npage_control = scsicmd[2] >> 6;\r\nswitch (page_control) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ncase 3:\r\ngoto saving_not_supp;\r\ndefault:\r\ngoto invalid_fld;\r\n}\r\nif (six_byte)\r\np += 4 + (ebd ? 8 : 0);\r\nelse\r\np += 8 + (ebd ? 8 : 0);\r\npg = scsicmd[2] & 0x3f;\r\nspg = scsicmd[3];\r\nif (spg && (spg != ALL_SUB_MPAGES))\r\ngoto invalid_fld;\r\nswitch(pg) {\r\ncase RW_RECOVERY_MPAGE:\r\np += ata_msense_rw_recovery(p, page_control == 1);\r\nbreak;\r\ncase CACHE_MPAGE:\r\np += ata_msense_caching(args->id, p, page_control == 1);\r\nbreak;\r\ncase CONTROL_MPAGE:\r\np += ata_msense_ctl_mode(p, page_control == 1);\r\nbreak;\r\ncase ALL_MPAGES:\r\np += ata_msense_rw_recovery(p, page_control == 1);\r\np += ata_msense_caching(args->id, p, page_control == 1);\r\np += ata_msense_ctl_mode(p, page_control == 1);\r\nbreak;\r\ndefault:\r\ngoto invalid_fld;\r\n}\r\ndpofua = 0;\r\nif (ata_dev_supports_fua(args->id) && (dev->flags & ATA_DFLAG_LBA48) &&\r\n(!(dev->flags & ATA_DFLAG_PIO) || dev->multi_count))\r\ndpofua = 1 << 4;\r\nif (six_byte) {\r\nrbuf[0] = p - rbuf - 1;\r\nrbuf[2] |= dpofua;\r\nif (ebd) {\r\nrbuf[3] = sizeof(sat_blk_desc);\r\nmemcpy(rbuf + 4, sat_blk_desc, sizeof(sat_blk_desc));\r\n}\r\n} else {\r\nunsigned int output_len = p - rbuf - 2;\r\nrbuf[0] = output_len >> 8;\r\nrbuf[1] = output_len;\r\nrbuf[3] |= dpofua;\r\nif (ebd) {\r\nrbuf[7] = sizeof(sat_blk_desc);\r\nmemcpy(rbuf + 8, sat_blk_desc, sizeof(sat_blk_desc));\r\n}\r\n}\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_sense(args->cmd, ILLEGAL_REQUEST, 0x24, 0x0);\r\nreturn 1;\r\nsaving_not_supp:\r\nata_scsi_set_sense(args->cmd, ILLEGAL_REQUEST, 0x39, 0x0);\r\nreturn 1;\r\n}\r\nstatic unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nstruct ata_device *dev = args->dev;\r\nu64 last_lba = dev->n_sectors - 1;\r\nu32 sector_size;\r\nu8 log2_per_phys;\r\nu16 lowest_aligned;\r\nsector_size = ata_id_logical_sector_size(dev->id);\r\nlog2_per_phys = ata_id_log2_per_physical_sector(dev->id);\r\nlowest_aligned = ata_id_logical_sector_offset(dev->id, log2_per_phys);\r\nVPRINTK("ENTER\n");\r\nif (args->cmd->cmnd[0] == READ_CAPACITY) {\r\nif (last_lba >= 0xffffffffULL)\r\nlast_lba = 0xffffffff;\r\nrbuf[0] = last_lba >> (8 * 3);\r\nrbuf[1] = last_lba >> (8 * 2);\r\nrbuf[2] = last_lba >> (8 * 1);\r\nrbuf[3] = last_lba;\r\nrbuf[4] = sector_size >> (8 * 3);\r\nrbuf[5] = sector_size >> (8 * 2);\r\nrbuf[6] = sector_size >> (8 * 1);\r\nrbuf[7] = sector_size;\r\n} else {\r\nrbuf[0] = last_lba >> (8 * 7);\r\nrbuf[1] = last_lba >> (8 * 6);\r\nrbuf[2] = last_lba >> (8 * 5);\r\nrbuf[3] = last_lba >> (8 * 4);\r\nrbuf[4] = last_lba >> (8 * 3);\r\nrbuf[5] = last_lba >> (8 * 2);\r\nrbuf[6] = last_lba >> (8 * 1);\r\nrbuf[7] = last_lba;\r\nrbuf[ 8] = sector_size >> (8 * 3);\r\nrbuf[ 9] = sector_size >> (8 * 2);\r\nrbuf[10] = sector_size >> (8 * 1);\r\nrbuf[11] = sector_size;\r\nrbuf[12] = 0;\r\nrbuf[13] = log2_per_phys;\r\nrbuf[14] = (lowest_aligned >> 8) & 0x3f;\r\nrbuf[15] = lowest_aligned;\r\nif (ata_id_has_trim(args->id)) {\r\nrbuf[14] |= 0x80;\r\nif (ata_id_has_zero_after_trim(args->id))\r\nrbuf[14] |= 0x40;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsiop_report_luns(struct ata_scsi_args *args, u8 *rbuf)\r\n{\r\nVPRINTK("ENTER\n");\r\nrbuf[3] = 8;\r\nreturn 0;\r\n}\r\nstatic void atapi_sense_complete(struct ata_queued_cmd *qc)\r\n{\r\nif (qc->err_mask && ((qc->err_mask & AC_ERR_DEV) == 0)) {\r\nata_gen_passthru_sense(qc);\r\n}\r\nqc->scsidone(qc->scsicmd);\r\nata_qc_free(qc);\r\n}\r\nstatic inline int ata_pio_use_silly(struct ata_port *ap)\r\n{\r\nreturn (ap->flags & ATA_FLAG_PIO_DMA);\r\n}\r\nstatic void atapi_request_sense(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct scsi_cmnd *cmd = qc->scsicmd;\r\nDPRINTK("ATAPI request sense\n");\r\nmemset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\r\n#ifdef CONFIG_ATA_SFF\r\nif (ap->ops->sff_tf_read)\r\nap->ops->sff_tf_read(ap, &qc->tf);\r\n#endif\r\ncmd->sense_buffer[0] = 0x70;\r\ncmd->sense_buffer[2] = qc->tf.feature >> 4;\r\nata_qc_reinit(qc);\r\nsg_init_one(&qc->sgent, cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE);\r\nata_sg_init(qc, &qc->sgent, 1);\r\nqc->dma_dir = DMA_FROM_DEVICE;\r\nmemset(&qc->cdb, 0, qc->dev->cdb_len);\r\nqc->cdb[0] = REQUEST_SENSE;\r\nqc->cdb[4] = SCSI_SENSE_BUFFERSIZE;\r\nqc->tf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\nqc->tf.command = ATA_CMD_PACKET;\r\nif (ata_pio_use_silly(ap)) {\r\nqc->tf.protocol = ATAPI_PROT_DMA;\r\nqc->tf.feature |= ATAPI_PKT_DMA;\r\n} else {\r\nqc->tf.protocol = ATAPI_PROT_PIO;\r\nqc->tf.lbam = SCSI_SENSE_BUFFERSIZE;\r\nqc->tf.lbah = 0;\r\n}\r\nqc->nbytes = SCSI_SENSE_BUFFERSIZE;\r\nqc->complete_fn = atapi_sense_complete;\r\nata_qc_issue(qc);\r\nDPRINTK("EXIT\n");\r\n}\r\nstatic void atapi_qc_complete(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *cmd = qc->scsicmd;\r\nunsigned int err_mask = qc->err_mask;\r\nVPRINTK("ENTER, err_mask 0x%X\n", err_mask);\r\nif (unlikely(qc->ap->ops->error_handler &&\r\n(err_mask || qc->flags & ATA_QCFLAG_SENSE_VALID))) {\r\nif (!(qc->flags & ATA_QCFLAG_SENSE_VALID)) {\r\nata_gen_passthru_sense(qc);\r\n}\r\nif (qc->cdb[0] == ALLOW_MEDIUM_REMOVAL && qc->dev->sdev)\r\nqc->dev->sdev->locked = 0;\r\nqc->scsicmd->result = SAM_STAT_CHECK_CONDITION;\r\nqc->scsidone(cmd);\r\nata_qc_free(qc);\r\nreturn;\r\n}\r\nif (unlikely(err_mask & AC_ERR_DEV)) {\r\ncmd->result = SAM_STAT_CHECK_CONDITION;\r\natapi_request_sense(qc);\r\nreturn;\r\n} else if (unlikely(err_mask)) {\r\nata_gen_passthru_sense(qc);\r\n} else {\r\nu8 *scsicmd = cmd->cmnd;\r\nif ((scsicmd[0] == INQUIRY) && ((scsicmd[1] & 0x03) == 0)) {\r\nunsigned long flags;\r\nu8 *buf;\r\nbuf = ata_scsi_rbuf_get(cmd, true, &flags);\r\nif (buf[2] == 0) {\r\nbuf[2] = 0x5;\r\nbuf[3] = 0x32;\r\n}\r\nata_scsi_rbuf_put(cmd, true, &flags);\r\n}\r\ncmd->result = SAM_STAT_GOOD;\r\n}\r\nqc->scsidone(cmd);\r\nata_qc_free(qc);\r\n}\r\nstatic unsigned int atapi_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nstruct ata_device *dev = qc->dev;\r\nint nodata = (scmd->sc_data_direction == DMA_NONE);\r\nint using_pio = !nodata && (dev->flags & ATA_DFLAG_PIO);\r\nunsigned int nbytes;\r\nmemset(qc->cdb, 0, dev->cdb_len);\r\nmemcpy(qc->cdb, scmd->cmnd, scmd->cmd_len);\r\nqc->complete_fn = atapi_qc_complete;\r\nqc->tf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\nif (scmd->sc_data_direction == DMA_TO_DEVICE) {\r\nqc->tf.flags |= ATA_TFLAG_WRITE;\r\nDPRINTK("direction: write\n");\r\n}\r\nqc->tf.command = ATA_CMD_PACKET;\r\nata_qc_set_pc_nbytes(qc);\r\nif (!nodata && !using_pio && atapi_check_dma(qc))\r\nusing_pio = 1;\r\nnbytes = min(ata_qc_raw_nbytes(qc), (unsigned int)63 * 1024);\r\nif (nbytes & 0x1)\r\nnbytes++;\r\nqc->tf.lbam = (nbytes & 0xFF);\r\nqc->tf.lbah = (nbytes >> 8);\r\nif (nodata)\r\nqc->tf.protocol = ATAPI_PROT_NODATA;\r\nelse if (using_pio)\r\nqc->tf.protocol = ATAPI_PROT_PIO;\r\nelse {\r\nqc->tf.protocol = ATAPI_PROT_DMA;\r\nqc->tf.feature |= ATAPI_PKT_DMA;\r\nif ((dev->flags & ATA_DFLAG_DMADIR) &&\r\n(scmd->sc_data_direction != DMA_TO_DEVICE))\r\nqc->tf.feature |= ATAPI_DMADIR;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct ata_device *ata_find_dev(struct ata_port *ap, int devno)\r\n{\r\nif (!sata_pmp_attached(ap)) {\r\nif (likely(devno < ata_link_max_devices(&ap->link)))\r\nreturn &ap->link.device[devno];\r\n} else {\r\nif (likely(devno < ap->nr_pmp_links))\r\nreturn &ap->pmp_link[devno].device[0];\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ata_device *__ata_scsi_find_dev(struct ata_port *ap,\r\nconst struct scsi_device *scsidev)\r\n{\r\nint devno;\r\nif (!sata_pmp_attached(ap)) {\r\nif (unlikely(scsidev->channel || scsidev->lun))\r\nreturn NULL;\r\ndevno = scsidev->id;\r\n} else {\r\nif (unlikely(scsidev->id || scsidev->lun))\r\nreturn NULL;\r\ndevno = scsidev->channel;\r\n}\r\nreturn ata_find_dev(ap, devno);\r\n}\r\nstatic struct ata_device *\r\nata_scsi_find_dev(struct ata_port *ap, const struct scsi_device *scsidev)\r\n{\r\nstruct ata_device *dev = __ata_scsi_find_dev(ap, scsidev);\r\nif (unlikely(!dev || !ata_dev_enabled(dev)))\r\nreturn NULL;\r\nreturn dev;\r\n}\r\nstatic u8\r\nata_scsi_map_proto(u8 byte1)\r\n{\r\nswitch((byte1 & 0x1e) >> 1) {\r\ncase 3:\r\nreturn ATA_PROT_NODATA;\r\ncase 6:\r\ncase 10:\r\ncase 11:\r\nreturn ATA_PROT_DMA;\r\ncase 4:\r\ncase 5:\r\nreturn ATA_PROT_PIO;\r\ncase 0:\r\ncase 1:\r\ncase 8:\r\ncase 9:\r\ncase 7:\r\ncase 12:\r\ncase 15:\r\ndefault:\r\nbreak;\r\n}\r\nreturn ATA_PROT_UNKNOWN;\r\n}\r\nstatic unsigned int ata_scsi_pass_thru(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_taskfile *tf = &(qc->tf);\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nstruct ata_device *dev = qc->dev;\r\nconst u8 *cdb = scmd->cmnd;\r\nif ((tf->protocol = ata_scsi_map_proto(cdb[1])) == ATA_PROT_UNKNOWN)\r\ngoto invalid_fld;\r\nif (cdb[0] == ATA_16) {\r\nif (cdb[1] & 0x01) {\r\ntf->hob_feature = cdb[3];\r\ntf->hob_nsect = cdb[5];\r\ntf->hob_lbal = cdb[7];\r\ntf->hob_lbam = cdb[9];\r\ntf->hob_lbah = cdb[11];\r\ntf->flags |= ATA_TFLAG_LBA48;\r\n} else\r\ntf->flags &= ~ATA_TFLAG_LBA48;\r\ntf->feature = cdb[4];\r\ntf->nsect = cdb[6];\r\ntf->lbal = cdb[8];\r\ntf->lbam = cdb[10];\r\ntf->lbah = cdb[12];\r\ntf->device = cdb[13];\r\ntf->command = cdb[14];\r\n} else {\r\ntf->flags &= ~ATA_TFLAG_LBA48;\r\ntf->feature = cdb[3];\r\ntf->nsect = cdb[4];\r\ntf->lbal = cdb[5];\r\ntf->lbam = cdb[6];\r\ntf->lbah = cdb[7];\r\ntf->device = cdb[8];\r\ntf->command = cdb[9];\r\n}\r\ntf->device = dev->devno ?\r\ntf->device | ATA_DEV1 : tf->device & ~ATA_DEV1;\r\nswitch (tf->command) {\r\ncase ATA_CMD_READ_LONG:\r\ncase ATA_CMD_READ_LONG_ONCE:\r\ncase ATA_CMD_WRITE_LONG:\r\ncase ATA_CMD_WRITE_LONG_ONCE:\r\nif (tf->protocol != ATA_PROT_PIO || tf->nsect != 1)\r\ngoto invalid_fld;\r\nqc->sect_size = scsi_bufflen(scmd);\r\nbreak;\r\ncase ATA_CMD_CFA_WRITE_NE:\r\ncase ATA_CMD_CFA_TRANS_SECT:\r\ncase ATA_CMD_CFA_WRITE_MULT_NE:\r\ncase ATA_CMD_READ:\r\ncase ATA_CMD_READ_EXT:\r\ncase ATA_CMD_READ_QUEUED:\r\ncase ATA_CMD_FPDMA_READ:\r\ncase ATA_CMD_READ_MULTI:\r\ncase ATA_CMD_READ_MULTI_EXT:\r\ncase ATA_CMD_PIO_READ:\r\ncase ATA_CMD_PIO_READ_EXT:\r\ncase ATA_CMD_READ_STREAM_DMA_EXT:\r\ncase ATA_CMD_READ_STREAM_EXT:\r\ncase ATA_CMD_VERIFY:\r\ncase ATA_CMD_VERIFY_EXT:\r\ncase ATA_CMD_WRITE:\r\ncase ATA_CMD_WRITE_EXT:\r\ncase ATA_CMD_WRITE_FUA_EXT:\r\ncase ATA_CMD_WRITE_QUEUED:\r\ncase ATA_CMD_WRITE_QUEUED_FUA_EXT:\r\ncase ATA_CMD_FPDMA_WRITE:\r\ncase ATA_CMD_WRITE_MULTI:\r\ncase ATA_CMD_WRITE_MULTI_EXT:\r\ncase ATA_CMD_WRITE_MULTI_FUA_EXT:\r\ncase ATA_CMD_PIO_WRITE:\r\ncase ATA_CMD_PIO_WRITE_EXT:\r\ncase ATA_CMD_WRITE_STREAM_DMA_EXT:\r\ncase ATA_CMD_WRITE_STREAM_EXT:\r\nqc->sect_size = scmd->device->sector_size;\r\nbreak;\r\ndefault:\r\nqc->sect_size = ATA_SECT_SIZE;\r\n}\r\ntf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;\r\nif (scmd->sc_data_direction == DMA_TO_DEVICE)\r\ntf->flags |= ATA_TFLAG_WRITE;\r\nqc->flags |= ATA_QCFLAG_RESULT_TF | ATA_QCFLAG_QUIET;\r\nata_qc_set_pc_nbytes(qc);\r\nif (tf->protocol == ATA_PROT_DMA && dev->dma_mode == 0)\r\ngoto invalid_fld;\r\nif ((cdb[1] & 0xe0) && !is_multi_taskfile(tf))\r\ngoto invalid_fld;\r\nif (is_multi_taskfile(tf)) {\r\nunsigned int multi_count = 1 << (cdb[1] >> 5);\r\nif (multi_count != dev->multi_count)\r\nata_dev_warn(dev, "invalid multi_count %u ignored\n",\r\nmulti_count);\r\n}\r\nif (tf->command == ATA_CMD_SET_FEATURES &&\r\ntf->feature == SETFEATURES_XFER)\r\ngoto invalid_fld;\r\nif (tf->command >= 0x5C && tf->command <= 0x5F && !libata_allow_tpm)\r\ngoto invalid_fld;\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_sense(scmd, ILLEGAL_REQUEST, 0x24, 0x00);\r\nreturn 1;\r\n}\r\nstatic unsigned int ata_scsi_write_same_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_taskfile *tf = &qc->tf;\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nstruct ata_device *dev = qc->dev;\r\nconst u8 *cdb = scmd->cmnd;\r\nu64 block;\r\nu32 n_block;\r\nu32 size;\r\nvoid *buf;\r\nif (unlikely(!dev->dma_mode))\r\ngoto invalid_fld;\r\nif (unlikely(scmd->cmd_len < 16))\r\ngoto invalid_fld;\r\nscsi_16_lba_len(cdb, &block, &n_block);\r\nif (unlikely(!(cdb[1] & 0x8)))\r\ngoto invalid_fld;\r\nif (!scsi_sg_count(scmd))\r\ngoto invalid_fld;\r\nbuf = page_address(sg_page(scsi_sglist(scmd)));\r\nsize = ata_set_lba_range_entries(buf, 512, block, n_block);\r\nif (ata_ncq_enabled(dev) && ata_fpdma_dsm_supported(dev)) {\r\ntf->protocol = ATA_PROT_NCQ;\r\ntf->command = ATA_CMD_FPDMA_SEND;\r\ntf->hob_nsect = ATA_SUBCMD_FPDMA_SEND_DSM & 0x1f;\r\ntf->nsect = qc->tag << 3;\r\ntf->hob_feature = (size / 512) >> 8;\r\ntf->feature = size / 512;\r\ntf->auxiliary = 1;\r\n} else {\r\ntf->protocol = ATA_PROT_DMA;\r\ntf->hob_feature = 0;\r\ntf->feature = ATA_DSM_TRIM;\r\ntf->hob_nsect = (size / 512) >> 8;\r\ntf->nsect = size / 512;\r\ntf->command = ATA_CMD_DSM;\r\n}\r\ntf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48 |\r\nATA_TFLAG_WRITE;\r\nata_qc_set_pc_nbytes(qc);\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_sense(scmd, ILLEGAL_REQUEST, 0x24, 0x00);\r\nreturn 1;\r\n}\r\nstatic int ata_mselect_caching(struct ata_queued_cmd *qc,\r\nconst u8 *buf, int len)\r\n{\r\nstruct ata_taskfile *tf = &qc->tf;\r\nstruct ata_device *dev = qc->dev;\r\nchar mpage[CACHE_MPAGE_LEN];\r\nu8 wce;\r\nif (len != CACHE_MPAGE_LEN - 2)\r\nreturn -EINVAL;\r\nwce = buf[0] & (1 << 2);\r\nata_msense_caching(dev->id, mpage, false);\r\nmpage[2] &= ~(1 << 2);\r\nmpage[2] |= wce;\r\nif (memcmp(mpage + 2, buf, CACHE_MPAGE_LEN - 2) != 0)\r\nreturn -EINVAL;\r\ntf->flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;\r\ntf->protocol = ATA_PROT_NODATA;\r\ntf->nsect = 0;\r\ntf->command = ATA_CMD_SET_FEATURES;\r\ntf->feature = wce ? SETFEATURES_WC_ON : SETFEATURES_WC_OFF;\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_scsi_mode_select_xlat(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *scmd = qc->scsicmd;\r\nconst u8 *cdb = scmd->cmnd;\r\nconst u8 *p;\r\nu8 pg, spg;\r\nunsigned six_byte, pg_len, hdr_len, bd_len;\r\nint len;\r\nVPRINTK("ENTER\n");\r\nsix_byte = (cdb[0] == MODE_SELECT);\r\nif (six_byte) {\r\nif (scmd->cmd_len < 5)\r\ngoto invalid_fld;\r\nlen = cdb[4];\r\nhdr_len = 4;\r\n} else {\r\nif (scmd->cmd_len < 9)\r\ngoto invalid_fld;\r\nlen = (cdb[7] << 8) + cdb[8];\r\nhdr_len = 8;\r\n}\r\nif ((cdb[1] & 0x11) != 0x10)\r\ngoto invalid_fld;\r\nif (!scsi_sg_count(scmd) || scsi_sglist(scmd)->length < len)\r\ngoto invalid_param_len;\r\np = page_address(sg_page(scsi_sglist(scmd)));\r\nif (len < hdr_len)\r\ngoto invalid_param_len;\r\nif (six_byte)\r\nbd_len = p[3];\r\nelse\r\nbd_len = (p[6] << 8) + p[7];\r\nlen -= hdr_len;\r\np += hdr_len;\r\nif (len < bd_len)\r\ngoto invalid_param_len;\r\nif (bd_len != 0 && bd_len != 8)\r\ngoto invalid_param;\r\nlen -= bd_len;\r\np += bd_len;\r\nif (len == 0)\r\ngoto skip;\r\npg = p[0] & 0x3f;\r\nif (p[0] & 0x40) {\r\nif (len < 4)\r\ngoto invalid_param_len;\r\nspg = p[1];\r\npg_len = (p[2] << 8) | p[3];\r\np += 4;\r\nlen -= 4;\r\n} else {\r\nif (len < 2)\r\ngoto invalid_param_len;\r\nspg = 0;\r\npg_len = p[1];\r\np += 2;\r\nlen -= 2;\r\n}\r\nif (spg && (spg != ALL_SUB_MPAGES))\r\ngoto invalid_param;\r\nif (pg_len > len)\r\ngoto invalid_param_len;\r\nswitch (pg) {\r\ncase CACHE_MPAGE:\r\nif (ata_mselect_caching(qc, p, pg_len) < 0)\r\ngoto invalid_param;\r\nbreak;\r\ndefault:\r\ngoto invalid_param;\r\n}\r\nif (len > pg_len)\r\ngoto invalid_param;\r\nreturn 0;\r\ninvalid_fld:\r\nata_scsi_set_sense(scmd, ILLEGAL_REQUEST, 0x24, 0x0);\r\nreturn 1;\r\ninvalid_param:\r\nata_scsi_set_sense(scmd, ILLEGAL_REQUEST, 0x26, 0x0);\r\nreturn 1;\r\ninvalid_param_len:\r\nata_scsi_set_sense(scmd, ILLEGAL_REQUEST, 0x1a, 0x0);\r\nreturn 1;\r\nskip:\r\nscmd->result = SAM_STAT_GOOD;\r\nreturn 1;\r\n}\r\nstatic inline ata_xlat_func_t ata_get_xlat_func(struct ata_device *dev, u8 cmd)\r\n{\r\nswitch (cmd) {\r\ncase READ_6:\r\ncase READ_10:\r\ncase READ_16:\r\ncase WRITE_6:\r\ncase WRITE_10:\r\ncase WRITE_16:\r\nreturn ata_scsi_rw_xlat;\r\ncase WRITE_SAME_16:\r\nreturn ata_scsi_write_same_xlat;\r\ncase SYNCHRONIZE_CACHE:\r\nif (ata_try_flush_cache(dev))\r\nreturn ata_scsi_flush_xlat;\r\nbreak;\r\ncase VERIFY:\r\ncase VERIFY_16:\r\nreturn ata_scsi_verify_xlat;\r\ncase ATA_12:\r\ncase ATA_16:\r\nreturn ata_scsi_pass_thru;\r\ncase MODE_SELECT:\r\ncase MODE_SELECT_10:\r\nreturn ata_scsi_mode_select_xlat;\r\nbreak;\r\ncase START_STOP:\r\nreturn ata_scsi_start_stop_xlat;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void ata_scsi_dump_cdb(struct ata_port *ap,\r\nstruct scsi_cmnd *cmd)\r\n{\r\n#ifdef ATA_DEBUG\r\nstruct scsi_device *scsidev = cmd->device;\r\nu8 *scsicmd = cmd->cmnd;\r\nDPRINTK("CDB (%u:%d,%d,%d) %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\nap->print_id,\r\nscsidev->channel, scsidev->id, scsidev->lun,\r\nscsicmd[0], scsicmd[1], scsicmd[2], scsicmd[3],\r\nscsicmd[4], scsicmd[5], scsicmd[6], scsicmd[7],\r\nscsicmd[8]);\r\n#endif\r\n}\r\nstatic inline int __ata_scsi_queuecmd(struct scsi_cmnd *scmd,\r\nstruct ata_device *dev)\r\n{\r\nu8 scsi_op = scmd->cmnd[0];\r\nata_xlat_func_t xlat_func;\r\nint rc = 0;\r\nif (dev->class == ATA_DEV_ATA) {\r\nif (unlikely(!scmd->cmd_len || scmd->cmd_len > dev->cdb_len))\r\ngoto bad_cdb_len;\r\nxlat_func = ata_get_xlat_func(dev, scsi_op);\r\n} else {\r\nif (unlikely(!scmd->cmd_len))\r\ngoto bad_cdb_len;\r\nxlat_func = NULL;\r\nif (likely((scsi_op != ATA_16) || !atapi_passthru16)) {\r\nint len = COMMAND_SIZE(scsi_op);\r\nif (unlikely(len > scmd->cmd_len || len > dev->cdb_len))\r\ngoto bad_cdb_len;\r\nxlat_func = atapi_xlat;\r\n} else {\r\nif (unlikely(scmd->cmd_len > 16))\r\ngoto bad_cdb_len;\r\nxlat_func = ata_get_xlat_func(dev, scsi_op);\r\n}\r\n}\r\nif (xlat_func)\r\nrc = ata_scsi_translate(dev, scmd, xlat_func);\r\nelse\r\nata_scsi_simulate(dev, scmd);\r\nreturn rc;\r\nbad_cdb_len:\r\nDPRINTK("bad CDB len=%u, scsi_op=0x%02x, max=%u\n",\r\nscmd->cmd_len, scsi_op, dev->cdb_len);\r\nscmd->result = DID_ERROR << 16;\r\nscmd->scsi_done(scmd);\r\nreturn 0;\r\n}\r\nint ata_scsi_queuecmd(struct Scsi_Host *shost, struct scsi_cmnd *cmd)\r\n{\r\nstruct ata_port *ap;\r\nstruct ata_device *dev;\r\nstruct scsi_device *scsidev = cmd->device;\r\nint rc = 0;\r\nunsigned long irq_flags;\r\nap = ata_shost_to_port(shost);\r\nspin_lock_irqsave(ap->lock, irq_flags);\r\nata_scsi_dump_cdb(ap, cmd);\r\ndev = ata_scsi_find_dev(ap, scsidev);\r\nif (likely(dev))\r\nrc = __ata_scsi_queuecmd(cmd, dev);\r\nelse {\r\ncmd->result = (DID_BAD_TARGET << 16);\r\ncmd->scsi_done(cmd);\r\n}\r\nspin_unlock_irqrestore(ap->lock, irq_flags);\r\nreturn rc;\r\n}\r\nvoid ata_scsi_simulate(struct ata_device *dev, struct scsi_cmnd *cmd)\r\n{\r\nstruct ata_scsi_args args;\r\nconst u8 *scsicmd = cmd->cmnd;\r\nu8 tmp8;\r\nargs.dev = dev;\r\nargs.id = dev->id;\r\nargs.cmd = cmd;\r\nargs.done = cmd->scsi_done;\r\nswitch(scsicmd[0]) {\r\ncase FORMAT_UNIT:\r\nata_scsi_invalid_field(cmd);\r\nbreak;\r\ncase INQUIRY:\r\nif (scsicmd[1] & 2)\r\nata_scsi_invalid_field(cmd);\r\nelse if ((scsicmd[1] & 1) == 0)\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_std);\r\nelse switch (scsicmd[2]) {\r\ncase 0x00:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_00);\r\nbreak;\r\ncase 0x80:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_80);\r\nbreak;\r\ncase 0x83:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_83);\r\nbreak;\r\ncase 0x89:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_89);\r\nbreak;\r\ncase 0xb0:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_b0);\r\nbreak;\r\ncase 0xb1:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_b1);\r\nbreak;\r\ncase 0xb2:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_inq_b2);\r\nbreak;\r\ndefault:\r\nata_scsi_invalid_field(cmd);\r\nbreak;\r\n}\r\nbreak;\r\ncase MODE_SENSE:\r\ncase MODE_SENSE_10:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_mode_sense);\r\nbreak;\r\ncase READ_CAPACITY:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_read_cap);\r\nbreak;\r\ncase SERVICE_ACTION_IN:\r\nif ((scsicmd[1] & 0x1f) == SAI_READ_CAPACITY_16)\r\nata_scsi_rbuf_fill(&args, ata_scsiop_read_cap);\r\nelse\r\nata_scsi_invalid_field(cmd);\r\nbreak;\r\ncase REPORT_LUNS:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_report_luns);\r\nbreak;\r\ncase REQUEST_SENSE:\r\nata_scsi_set_sense(cmd, 0, 0, 0);\r\ncmd->result = (DRIVER_SENSE << 24);\r\ncmd->scsi_done(cmd);\r\nbreak;\r\ncase SYNCHRONIZE_CACHE:\r\ncase REZERO_UNIT:\r\ncase SEEK_6:\r\ncase SEEK_10:\r\ncase TEST_UNIT_READY:\r\nata_scsi_rbuf_fill(&args, ata_scsiop_noop);\r\nbreak;\r\ncase SEND_DIAGNOSTIC:\r\ntmp8 = scsicmd[1] & ~(1 << 3);\r\nif ((tmp8 == 0x4) && (!scsicmd[3]) && (!scsicmd[4]))\r\nata_scsi_rbuf_fill(&args, ata_scsiop_noop);\r\nelse\r\nata_scsi_invalid_field(cmd);\r\nbreak;\r\ndefault:\r\nata_scsi_set_sense(cmd, ILLEGAL_REQUEST, 0x20, 0x0);\r\ncmd->scsi_done(cmd);\r\nbreak;\r\n}\r\n}\r\nint ata_scsi_add_hosts(struct ata_host *host, struct scsi_host_template *sht)\r\n{\r\nint i, rc;\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nstruct Scsi_Host *shost;\r\nrc = -ENOMEM;\r\nshost = scsi_host_alloc(sht, sizeof(struct ata_port *));\r\nif (!shost)\r\ngoto err_alloc;\r\nshost->eh_noresume = 1;\r\n*(struct ata_port **)&shost->hostdata[0] = ap;\r\nap->scsi_host = shost;\r\nshost->transportt = ata_scsi_transport_template;\r\nshost->unique_id = ap->print_id;\r\nshost->max_id = 16;\r\nshost->max_lun = 1;\r\nshost->max_channel = 1;\r\nshost->max_cmd_len = 16;\r\nshost->no_write_same = 1;\r\nshost->max_host_blocked = 1;\r\nrc = scsi_add_host_with_dma(ap->scsi_host,\r\n&ap->tdev, ap->host->dev);\r\nif (rc)\r\ngoto err_add;\r\n}\r\nreturn 0;\r\nerr_add:\r\nscsi_host_put(host->ports[i]->scsi_host);\r\nerr_alloc:\r\nwhile (--i >= 0) {\r\nstruct Scsi_Host *shost = host->ports[i]->scsi_host;\r\nscsi_remove_host(shost);\r\nscsi_host_put(shost);\r\n}\r\nreturn rc;\r\n}\r\nvoid ata_scsi_scan_host(struct ata_port *ap, int sync)\r\n{\r\nint tries = 5;\r\nstruct ata_device *last_failed_dev = NULL;\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nrepeat:\r\nata_for_each_link(link, ap, EDGE) {\r\nata_for_each_dev(dev, link, ENABLED) {\r\nstruct scsi_device *sdev;\r\nint channel = 0, id = 0;\r\nif (dev->sdev)\r\ncontinue;\r\nif (ata_is_host_link(link))\r\nid = dev->devno;\r\nelse\r\nchannel = link->pmp;\r\nsdev = __scsi_add_device(ap->scsi_host, channel, id, 0,\r\nNULL);\r\nif (!IS_ERR(sdev)) {\r\ndev->sdev = sdev;\r\nscsi_device_put(sdev);\r\n} else {\r\ndev->sdev = NULL;\r\n}\r\n}\r\n}\r\nata_for_each_link(link, ap, EDGE) {\r\nata_for_each_dev(dev, link, ENABLED) {\r\nif (!dev->sdev)\r\ngoto exit_loop;\r\n}\r\n}\r\nexit_loop:\r\nif (!link)\r\nreturn;\r\nif (sync) {\r\nif (dev != last_failed_dev) {\r\nmsleep(100);\r\nlast_failed_dev = dev;\r\ngoto repeat;\r\n}\r\nif (--tries) {\r\nmsleep(100);\r\ngoto repeat;\r\n}\r\nata_port_err(ap,\r\n"WARNING: synchronous SCSI scan failed without making any progress, switching to async\n");\r\n}\r\nqueue_delayed_work(system_long_wq, &ap->hotplug_task,\r\nround_jiffies_relative(HZ));\r\n}\r\nint ata_scsi_offline_dev(struct ata_device *dev)\r\n{\r\nif (dev->sdev) {\r\nscsi_device_set_state(dev->sdev, SDEV_OFFLINE);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ata_scsi_remove_dev(struct ata_device *dev)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nstruct scsi_device *sdev;\r\nunsigned long flags;\r\nmutex_lock(&ap->scsi_host->scan_mutex);\r\nspin_lock_irqsave(ap->lock, flags);\r\nsdev = dev->sdev;\r\ndev->sdev = NULL;\r\nif (sdev) {\r\nif (scsi_device_get(sdev) == 0) {\r\nscsi_device_set_state(sdev, SDEV_OFFLINE);\r\n} else {\r\nWARN_ON(1);\r\nsdev = NULL;\r\n}\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nmutex_unlock(&ap->scsi_host->scan_mutex);\r\nif (sdev) {\r\nata_dev_info(dev, "detaching (SCSI %s)\n",\r\ndev_name(&sdev->sdev_gendev));\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\n}\r\n}\r\nstatic void ata_scsi_handle_link_detach(struct ata_link *link)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_device *dev;\r\nata_for_each_dev(dev, link, ALL) {\r\nunsigned long flags;\r\nif (!(dev->flags & ATA_DFLAG_DETACHED))\r\ncontinue;\r\nspin_lock_irqsave(ap->lock, flags);\r\ndev->flags &= ~ATA_DFLAG_DETACHED;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nif (zpodd_dev_enabled(dev))\r\nzpodd_exit(dev);\r\nata_scsi_remove_dev(dev);\r\n}\r\n}\r\nvoid ata_scsi_media_change_notify(struct ata_device *dev)\r\n{\r\nif (dev->sdev)\r\nsdev_evt_send_simple(dev->sdev, SDEV_EVT_MEDIA_CHANGE,\r\nGFP_ATOMIC);\r\n}\r\nvoid ata_scsi_hotplug(struct work_struct *work)\r\n{\r\nstruct ata_port *ap =\r\ncontainer_of(work, struct ata_port, hotplug_task.work);\r\nint i;\r\nif (ap->pflags & ATA_PFLAG_UNLOADING) {\r\nDPRINTK("ENTER/EXIT - unloading\n");\r\nreturn;\r\n}\r\n#ifdef CONFIG_FREEZER\r\nwhile (pm_freezing)\r\nmsleep(10);\r\n#endif\r\nDPRINTK("ENTER\n");\r\nmutex_lock(&ap->scsi_scan_mutex);\r\nata_scsi_handle_link_detach(&ap->link);\r\nif (ap->pmp_link)\r\nfor (i = 0; i < SATA_PMP_MAX_PORTS; i++)\r\nata_scsi_handle_link_detach(&ap->pmp_link[i]);\r\nata_scsi_scan_host(ap, 0);\r\nmutex_unlock(&ap->scsi_scan_mutex);\r\nDPRINTK("EXIT\n");\r\n}\r\nint ata_scsi_user_scan(struct Scsi_Host *shost, unsigned int channel,\r\nunsigned int id, unsigned int lun)\r\n{\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nunsigned long flags;\r\nint devno, rc = 0;\r\nif (!ap->ops->error_handler)\r\nreturn -EOPNOTSUPP;\r\nif (lun != SCAN_WILD_CARD && lun)\r\nreturn -EINVAL;\r\nif (!sata_pmp_attached(ap)) {\r\nif (channel != SCAN_WILD_CARD && channel)\r\nreturn -EINVAL;\r\ndevno = id;\r\n} else {\r\nif (id != SCAN_WILD_CARD && id)\r\nreturn -EINVAL;\r\ndevno = channel;\r\n}\r\nspin_lock_irqsave(ap->lock, flags);\r\nif (devno == SCAN_WILD_CARD) {\r\nstruct ata_link *link;\r\nata_for_each_link(link, ap, EDGE) {\r\nstruct ata_eh_info *ehi = &link->eh_info;\r\nehi->probe_mask |= ATA_ALL_DEVICES;\r\nehi->action |= ATA_EH_RESET;\r\n}\r\n} else {\r\nstruct ata_device *dev = ata_find_dev(ap, devno);\r\nif (dev) {\r\nstruct ata_eh_info *ehi = &dev->link->eh_info;\r\nehi->probe_mask |= 1 << dev->devno;\r\nehi->action |= ATA_EH_RESET;\r\n} else\r\nrc = -EINVAL;\r\n}\r\nif (rc == 0) {\r\nata_port_schedule_eh(ap);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nata_port_wait_eh(ap);\r\n} else\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn rc;\r\n}\r\nvoid ata_scsi_dev_rescan(struct work_struct *work)\r\n{\r\nstruct ata_port *ap =\r\ncontainer_of(work, struct ata_port, scsi_rescan_task);\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nunsigned long flags;\r\nmutex_lock(&ap->scsi_scan_mutex);\r\nspin_lock_irqsave(ap->lock, flags);\r\nata_for_each_link(link, ap, EDGE) {\r\nata_for_each_dev(dev, link, ENABLED) {\r\nstruct scsi_device *sdev = dev->sdev;\r\nif (!sdev)\r\ncontinue;\r\nif (scsi_device_get(sdev))\r\ncontinue;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nscsi_rescan_device(&(sdev->sdev_gendev));\r\nscsi_device_put(sdev);\r\nspin_lock_irqsave(ap->lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nmutex_unlock(&ap->scsi_scan_mutex);\r\n}\r\nstruct ata_port *ata_sas_port_alloc(struct ata_host *host,\r\nstruct ata_port_info *port_info,\r\nstruct Scsi_Host *shost)\r\n{\r\nstruct ata_port *ap;\r\nap = ata_port_alloc(host);\r\nif (!ap)\r\nreturn NULL;\r\nap->port_no = 0;\r\nap->lock = &host->lock;\r\nap->pio_mask = port_info->pio_mask;\r\nap->mwdma_mask = port_info->mwdma_mask;\r\nap->udma_mask = port_info->udma_mask;\r\nap->flags |= port_info->flags;\r\nap->ops = port_info->port_ops;\r\nap->cbl = ATA_CBL_SATA;\r\nreturn ap;\r\n}\r\nint ata_sas_port_start(struct ata_port *ap)\r\n{\r\nif (!ap->ops->error_handler)\r\nap->pflags &= ~ATA_PFLAG_FROZEN;\r\nreturn 0;\r\n}\r\nvoid ata_sas_port_stop(struct ata_port *ap)\r\n{\r\n}\r\nvoid ata_sas_async_probe(struct ata_port *ap)\r\n{\r\n__ata_port_probe(ap);\r\n}\r\nint ata_sas_sync_probe(struct ata_port *ap)\r\n{\r\nreturn ata_port_probe(ap);\r\n}\r\nint ata_sas_port_init(struct ata_port *ap)\r\n{\r\nint rc = ap->ops->port_start(ap);\r\nif (rc)\r\nreturn rc;\r\nap->print_id = atomic_inc_return(&ata_print_id);\r\nreturn 0;\r\n}\r\nvoid ata_sas_port_destroy(struct ata_port *ap)\r\n{\r\nif (ap->ops->port_stop)\r\nap->ops->port_stop(ap);\r\nkfree(ap);\r\n}\r\nint ata_sas_slave_configure(struct scsi_device *sdev, struct ata_port *ap)\r\n{\r\nata_scsi_sdev_config(sdev);\r\nata_scsi_dev_config(sdev, ap->link.device);\r\nreturn 0;\r\n}\r\nint ata_sas_queuecmd(struct scsi_cmnd *cmd, struct ata_port *ap)\r\n{\r\nint rc = 0;\r\nata_scsi_dump_cdb(ap, cmd);\r\nif (likely(ata_dev_enabled(ap->link.device)))\r\nrc = __ata_scsi_queuecmd(cmd, ap->link.device);\r\nelse {\r\ncmd->result = (DID_BAD_TARGET << 16);\r\ncmd->scsi_done(cmd);\r\n}\r\nreturn rc;\r\n}
