static void xpad_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)\r\n{\r\nstruct input_dev *dev = xpad->dev;\r\nif (!(xpad->mapping & MAP_STICKS_TO_NULL)) {\r\ninput_report_abs(dev, ABS_X,\r\n(__s16) le16_to_cpup((__le16 *)(data + 12)));\r\ninput_report_abs(dev, ABS_Y,\r\n~(__s16) le16_to_cpup((__le16 *)(data + 14)));\r\ninput_report_abs(dev, ABS_RX,\r\n(__s16) le16_to_cpup((__le16 *)(data + 16)));\r\ninput_report_abs(dev, ABS_RY,\r\n~(__s16) le16_to_cpup((__le16 *)(data + 18)));\r\n}\r\nif (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {\r\ninput_report_key(dev, BTN_TL2, data[10]);\r\ninput_report_key(dev, BTN_TR2, data[11]);\r\n} else {\r\ninput_report_abs(dev, ABS_Z, data[10]);\r\ninput_report_abs(dev, ABS_RZ, data[11]);\r\n}\r\nif (xpad->mapping & MAP_DPAD_TO_BUTTONS) {\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY1, data[2] & 0x04);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY2, data[2] & 0x08);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY3, data[2] & 0x01);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY4, data[2] & 0x02);\r\n} else {\r\ninput_report_abs(dev, ABS_HAT0X,\r\n!!(data[2] & 0x08) - !!(data[2] & 0x04));\r\ninput_report_abs(dev, ABS_HAT0Y,\r\n!!(data[2] & 0x02) - !!(data[2] & 0x01));\r\n}\r\ninput_report_key(dev, BTN_START, data[2] & 0x10);\r\ninput_report_key(dev, BTN_SELECT, data[2] & 0x20);\r\ninput_report_key(dev, BTN_THUMBL, data[2] & 0x40);\r\ninput_report_key(dev, BTN_THUMBR, data[2] & 0x80);\r\ninput_report_key(dev, BTN_A, data[4]);\r\ninput_report_key(dev, BTN_B, data[5]);\r\ninput_report_key(dev, BTN_X, data[6]);\r\ninput_report_key(dev, BTN_Y, data[7]);\r\ninput_report_key(dev, BTN_C, data[8]);\r\ninput_report_key(dev, BTN_Z, data[9]);\r\ninput_sync(dev);\r\n}\r\nstatic void xpad360_process_packet(struct usb_xpad *xpad,\r\nu16 cmd, unsigned char *data)\r\n{\r\nstruct input_dev *dev = xpad->dev;\r\nif (xpad->mapping & MAP_DPAD_TO_BUTTONS) {\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY1, data[2] & 0x04);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY2, data[2] & 0x08);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY3, data[2] & 0x01);\r\ninput_report_key(dev, BTN_TRIGGER_HAPPY4, data[2] & 0x02);\r\n} else {\r\ninput_report_abs(dev, ABS_HAT0X,\r\n!!(data[2] & 0x08) - !!(data[2] & 0x04));\r\ninput_report_abs(dev, ABS_HAT0Y,\r\n!!(data[2] & 0x02) - !!(data[2] & 0x01));\r\n}\r\ninput_report_key(dev, BTN_START, data[2] & 0x10);\r\ninput_report_key(dev, BTN_SELECT, data[2] & 0x20);\r\ninput_report_key(dev, BTN_THUMBL, data[2] & 0x40);\r\ninput_report_key(dev, BTN_THUMBR, data[2] & 0x80);\r\ninput_report_key(dev, BTN_A, data[3] & 0x10);\r\ninput_report_key(dev, BTN_B, data[3] & 0x20);\r\ninput_report_key(dev, BTN_X, data[3] & 0x40);\r\ninput_report_key(dev, BTN_Y, data[3] & 0x80);\r\ninput_report_key(dev, BTN_TL, data[3] & 0x01);\r\ninput_report_key(dev, BTN_TR, data[3] & 0x02);\r\ninput_report_key(dev, BTN_MODE, data[3] & 0x04);\r\nif (!(xpad->mapping & MAP_STICKS_TO_NULL)) {\r\ninput_report_abs(dev, ABS_X,\r\n(__s16) le16_to_cpup((__le16 *)(data + 6)));\r\ninput_report_abs(dev, ABS_Y,\r\n~(__s16) le16_to_cpup((__le16 *)(data + 8)));\r\ninput_report_abs(dev, ABS_RX,\r\n(__s16) le16_to_cpup((__le16 *)(data + 10)));\r\ninput_report_abs(dev, ABS_RY,\r\n~(__s16) le16_to_cpup((__le16 *)(data + 12)));\r\n}\r\nif (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {\r\ninput_report_key(dev, BTN_TL2, data[4]);\r\ninput_report_key(dev, BTN_TR2, data[5]);\r\n} else {\r\ninput_report_abs(dev, ABS_Z, data[4]);\r\ninput_report_abs(dev, ABS_RZ, data[5]);\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic void xpad360w_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)\r\n{\r\nif (data[0] & 0x08) {\r\nif (data[1] & 0x80) {\r\nxpad->pad_present = 1;\r\nusb_submit_urb(xpad->bulk_out, GFP_ATOMIC);\r\n} else\r\nxpad->pad_present = 0;\r\n}\r\nif (!(data[1] & 0x1))\r\nreturn;\r\nxpad360_process_packet(xpad, cmd, &data[4]);\r\n}\r\nstatic void xpad_irq_in(struct urb *urb)\r\n{\r\nstruct usb_xpad *xpad = urb->context;\r\nstruct device *dev = &xpad->intf->dev;\r\nint retval, status;\r\nstatus = urb->status;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nswitch (xpad->xtype) {\r\ncase XTYPE_XBOX360:\r\nxpad360_process_packet(xpad, 0, xpad->idata);\r\nbreak;\r\ncase XTYPE_XBOX360W:\r\nxpad360w_process_packet(xpad, 0, xpad->idata);\r\nbreak;\r\ndefault:\r\nxpad_process_packet(xpad, 0, xpad->idata);\r\n}\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(dev, "%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\nstatic void xpad_bulk_out(struct urb *urb)\r\n{\r\nstruct usb_xpad *xpad = urb->context;\r\nstruct device *dev = &xpad->intf->dev;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(dev, "%s - urb shutting down with status: %d\n",\r\n__func__, urb->status);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s - nonzero urb status received: %d\n",\r\n__func__, urb->status);\r\n}\r\n}\r\nstatic void xpad_irq_out(struct urb *urb)\r\n{\r\nstruct usb_xpad *xpad = urb->context;\r\nstruct device *dev = &xpad->intf->dev;\r\nint retval, status;\r\nstatus = urb->status;\r\nswitch (status) {\r\ncase 0:\r\nreturn;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(dev, "%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\nstatic int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)\r\n{\r\nstruct usb_endpoint_descriptor *ep_irq_out;\r\nint error;\r\nif (xpad->xtype == XTYPE_UNKNOWN)\r\nreturn 0;\r\nxpad->odata = usb_alloc_coherent(xpad->udev, XPAD_PKT_LEN,\r\nGFP_KERNEL, &xpad->odata_dma);\r\nif (!xpad->odata) {\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\nmutex_init(&xpad->odata_mutex);\r\nxpad->irq_out = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!xpad->irq_out) {\r\nerror = -ENOMEM;\r\ngoto fail2;\r\n}\r\nep_irq_out = &intf->cur_altsetting->endpoint[1].desc;\r\nusb_fill_int_urb(xpad->irq_out, xpad->udev,\r\nusb_sndintpipe(xpad->udev, ep_irq_out->bEndpointAddress),\r\nxpad->odata, XPAD_PKT_LEN,\r\nxpad_irq_out, xpad, ep_irq_out->bInterval);\r\nxpad->irq_out->transfer_dma = xpad->odata_dma;\r\nxpad->irq_out->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nreturn 0;\r\nfail2: usb_free_coherent(xpad->udev, XPAD_PKT_LEN, xpad->odata, xpad->odata_dma);\r\nfail1: return error;\r\n}\r\nstatic void xpad_stop_output(struct usb_xpad *xpad)\r\n{\r\nif (xpad->xtype != XTYPE_UNKNOWN)\r\nusb_kill_urb(xpad->irq_out);\r\n}\r\nstatic void xpad_deinit_output(struct usb_xpad *xpad)\r\n{\r\nif (xpad->xtype != XTYPE_UNKNOWN) {\r\nusb_free_urb(xpad->irq_out);\r\nusb_free_coherent(xpad->udev, XPAD_PKT_LEN,\r\nxpad->odata, xpad->odata_dma);\r\n}\r\n}\r\nstatic int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad) { return 0; }\r\nstatic void xpad_deinit_output(struct usb_xpad *xpad) {}\r\nstatic void xpad_stop_output(struct usb_xpad *xpad) {}\r\nstatic int xpad_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect)\r\n{\r\nstruct usb_xpad *xpad = input_get_drvdata(dev);\r\nif (effect->type == FF_RUMBLE) {\r\n__u16 strong = effect->u.rumble.strong_magnitude;\r\n__u16 weak = effect->u.rumble.weak_magnitude;\r\nswitch (xpad->xtype) {\r\ncase XTYPE_XBOX:\r\nxpad->odata[0] = 0x00;\r\nxpad->odata[1] = 0x06;\r\nxpad->odata[2] = 0x00;\r\nxpad->odata[3] = strong / 256;\r\nxpad->odata[4] = 0x00;\r\nxpad->odata[5] = weak / 256;\r\nxpad->irq_out->transfer_buffer_length = 6;\r\nreturn usb_submit_urb(xpad->irq_out, GFP_ATOMIC);\r\ncase XTYPE_XBOX360:\r\nxpad->odata[0] = 0x00;\r\nxpad->odata[1] = 0x08;\r\nxpad->odata[2] = 0x00;\r\nxpad->odata[3] = strong / 256;\r\nxpad->odata[4] = weak / 256;\r\nxpad->odata[5] = 0x00;\r\nxpad->odata[6] = 0x00;\r\nxpad->odata[7] = 0x00;\r\nxpad->irq_out->transfer_buffer_length = 8;\r\nreturn usb_submit_urb(xpad->irq_out, GFP_ATOMIC);\r\ncase XTYPE_XBOX360W:\r\nxpad->odata[0] = 0x00;\r\nxpad->odata[1] = 0x01;\r\nxpad->odata[2] = 0x0F;\r\nxpad->odata[3] = 0xC0;\r\nxpad->odata[4] = 0x00;\r\nxpad->odata[5] = strong / 256;\r\nxpad->odata[6] = weak / 256;\r\nxpad->odata[7] = 0x00;\r\nxpad->odata[8] = 0x00;\r\nxpad->odata[9] = 0x00;\r\nxpad->odata[10] = 0x00;\r\nxpad->odata[11] = 0x00;\r\nxpad->irq_out->transfer_buffer_length = 12;\r\nreturn usb_submit_urb(xpad->irq_out, GFP_ATOMIC);\r\ndefault:\r\ndev_dbg(&xpad->dev->dev,\r\n"%s - rumble command sent to unsupported xpad type: %d\n",\r\n__func__, xpad->xtype);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int xpad_init_ff(struct usb_xpad *xpad)\r\n{\r\nif (xpad->xtype == XTYPE_UNKNOWN)\r\nreturn 0;\r\ninput_set_capability(xpad->dev, EV_FF, FF_RUMBLE);\r\nreturn input_ff_create_memless(xpad->dev, NULL, xpad_play_effect);\r\n}\r\nstatic int xpad_init_ff(struct usb_xpad *xpad) { return 0; }\r\nstatic void xpad_send_led_command(struct usb_xpad *xpad, int command)\r\n{\r\nif (command >= 0 && command < 14) {\r\nmutex_lock(&xpad->odata_mutex);\r\nxpad->odata[0] = 0x01;\r\nxpad->odata[1] = 0x03;\r\nxpad->odata[2] = command;\r\nxpad->irq_out->transfer_buffer_length = 3;\r\nusb_submit_urb(xpad->irq_out, GFP_KERNEL);\r\nmutex_unlock(&xpad->odata_mutex);\r\n}\r\n}\r\nstatic void xpad_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct xpad_led *xpad_led = container_of(led_cdev,\r\nstruct xpad_led, led_cdev);\r\nxpad_send_led_command(xpad_led->xpad, value);\r\n}\r\nstatic int xpad_led_probe(struct usb_xpad *xpad)\r\n{\r\nstatic atomic_t led_seq = ATOMIC_INIT(0);\r\nlong led_no;\r\nstruct xpad_led *led;\r\nstruct led_classdev *led_cdev;\r\nint error;\r\nif (xpad->xtype != XTYPE_XBOX360)\r\nreturn 0;\r\nxpad->led = led = kzalloc(sizeof(struct xpad_led), GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nled_no = (long)atomic_inc_return(&led_seq) - 1;\r\nsnprintf(led->name, sizeof(led->name), "xpad%ld", led_no);\r\nled->xpad = xpad;\r\nled_cdev = &led->led_cdev;\r\nled_cdev->name = led->name;\r\nled_cdev->brightness_set = xpad_led_set;\r\nerror = led_classdev_register(&xpad->udev->dev, led_cdev);\r\nif (error) {\r\nkfree(led);\r\nxpad->led = NULL;\r\nreturn error;\r\n}\r\nxpad_send_led_command(xpad, (led_no % 4) + 2);\r\nreturn 0;\r\n}\r\nstatic void xpad_led_disconnect(struct usb_xpad *xpad)\r\n{\r\nstruct xpad_led *xpad_led = xpad->led;\r\nif (xpad_led) {\r\nled_classdev_unregister(&xpad_led->led_cdev);\r\nkfree(xpad_led);\r\n}\r\n}\r\nstatic int xpad_led_probe(struct usb_xpad *xpad) { return 0; }\r\nstatic void xpad_led_disconnect(struct usb_xpad *xpad) { }\r\nstatic int xpad_open(struct input_dev *dev)\r\n{\r\nstruct usb_xpad *xpad = input_get_drvdata(dev);\r\nif (xpad->xtype == XTYPE_XBOX360W)\r\nreturn 0;\r\nxpad->irq_in->dev = xpad->udev;\r\nif (usb_submit_urb(xpad->irq_in, GFP_KERNEL))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void xpad_close(struct input_dev *dev)\r\n{\r\nstruct usb_xpad *xpad = input_get_drvdata(dev);\r\nif (xpad->xtype != XTYPE_XBOX360W)\r\nusb_kill_urb(xpad->irq_in);\r\nxpad_stop_output(xpad);\r\n}\r\nstatic void xpad_set_up_abs(struct input_dev *input_dev, signed short abs)\r\n{\r\nset_bit(abs, input_dev->absbit);\r\nswitch (abs) {\r\ncase ABS_X:\r\ncase ABS_Y:\r\ncase ABS_RX:\r\ncase ABS_RY:\r\ninput_set_abs_params(input_dev, abs, -32768, 32767, 16, 128);\r\nbreak;\r\ncase ABS_Z:\r\ncase ABS_RZ:\r\ninput_set_abs_params(input_dev, abs, 0, 255, 0, 0);\r\nbreak;\r\ncase ABS_HAT0X:\r\ncase ABS_HAT0Y:\r\ninput_set_abs_params(input_dev, abs, -1, 1, 0, 0);\r\nbreak;\r\n}\r\n}\r\nstatic int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_xpad *xpad;\r\nstruct input_dev *input_dev;\r\nstruct usb_endpoint_descriptor *ep_irq_in;\r\nint i, error;\r\nfor (i = 0; xpad_device[i].idVendor; i++) {\r\nif ((le16_to_cpu(udev->descriptor.idVendor) == xpad_device[i].idVendor) &&\r\n(le16_to_cpu(udev->descriptor.idProduct) == xpad_device[i].idProduct))\r\nbreak;\r\n}\r\nxpad = kzalloc(sizeof(struct usb_xpad), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!xpad || !input_dev) {\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\nxpad->idata = usb_alloc_coherent(udev, XPAD_PKT_LEN,\r\nGFP_KERNEL, &xpad->idata_dma);\r\nif (!xpad->idata) {\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\nxpad->irq_in = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!xpad->irq_in) {\r\nerror = -ENOMEM;\r\ngoto fail2;\r\n}\r\nxpad->udev = udev;\r\nxpad->intf = intf;\r\nxpad->mapping = xpad_device[i].mapping;\r\nxpad->xtype = xpad_device[i].xtype;\r\nif (xpad->xtype == XTYPE_UNKNOWN) {\r\nif (intf->cur_altsetting->desc.bInterfaceClass == USB_CLASS_VENDOR_SPEC) {\r\nif (intf->cur_altsetting->desc.bInterfaceProtocol == 129)\r\nxpad->xtype = XTYPE_XBOX360W;\r\nelse\r\nxpad->xtype = XTYPE_XBOX360;\r\n} else\r\nxpad->xtype = XTYPE_XBOX;\r\nif (dpad_to_buttons)\r\nxpad->mapping |= MAP_DPAD_TO_BUTTONS;\r\nif (triggers_to_buttons)\r\nxpad->mapping |= MAP_TRIGGERS_TO_BUTTONS;\r\nif (sticks_to_null)\r\nxpad->mapping |= MAP_STICKS_TO_NULL;\r\n}\r\nxpad->dev = input_dev;\r\nusb_make_path(udev, xpad->phys, sizeof(xpad->phys));\r\nstrlcat(xpad->phys, "/input0", sizeof(xpad->phys));\r\ninput_dev->name = xpad_device[i].name;\r\ninput_dev->phys = xpad->phys;\r\nusb_to_input_id(udev, &input_dev->id);\r\ninput_dev->dev.parent = &intf->dev;\r\ninput_set_drvdata(input_dev, xpad);\r\ninput_dev->open = xpad_open;\r\ninput_dev->close = xpad_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY);\r\nif (!(xpad->mapping & MAP_STICKS_TO_NULL)) {\r\ninput_dev->evbit[0] |= BIT_MASK(EV_ABS);\r\nfor (i = 0; xpad_abs[i] >= 0; i++)\r\nxpad_set_up_abs(input_dev, xpad_abs[i]);\r\n}\r\nfor (i = 0; xpad_common_btn[i] >= 0; i++)\r\n__set_bit(xpad_common_btn[i], input_dev->keybit);\r\nif (xpad->xtype == XTYPE_XBOX360 || xpad->xtype == XTYPE_XBOX360W) {\r\nfor (i = 0; xpad360_btn[i] >= 0; i++)\r\n__set_bit(xpad360_btn[i], input_dev->keybit);\r\n} else {\r\nfor (i = 0; xpad_btn[i] >= 0; i++)\r\n__set_bit(xpad_btn[i], input_dev->keybit);\r\n}\r\nif (xpad->mapping & MAP_DPAD_TO_BUTTONS) {\r\nfor (i = 0; xpad_btn_pad[i] >= 0; i++)\r\n__set_bit(xpad_btn_pad[i], input_dev->keybit);\r\n} else {\r\nfor (i = 0; xpad_abs_pad[i] >= 0; i++)\r\nxpad_set_up_abs(input_dev, xpad_abs_pad[i]);\r\n}\r\nif (xpad->mapping & MAP_TRIGGERS_TO_BUTTONS) {\r\nfor (i = 0; xpad_btn_triggers[i] >= 0; i++)\r\n__set_bit(xpad_btn_triggers[i], input_dev->keybit);\r\n} else {\r\nfor (i = 0; xpad_abs_triggers[i] >= 0; i++)\r\nxpad_set_up_abs(input_dev, xpad_abs_triggers[i]);\r\n}\r\nerror = xpad_init_output(intf, xpad);\r\nif (error)\r\ngoto fail3;\r\nerror = xpad_init_ff(xpad);\r\nif (error)\r\ngoto fail4;\r\nerror = xpad_led_probe(xpad);\r\nif (error)\r\ngoto fail5;\r\nep_irq_in = &intf->cur_altsetting->endpoint[0].desc;\r\nusb_fill_int_urb(xpad->irq_in, udev,\r\nusb_rcvintpipe(udev, ep_irq_in->bEndpointAddress),\r\nxpad->idata, XPAD_PKT_LEN, xpad_irq_in,\r\nxpad, ep_irq_in->bInterval);\r\nxpad->irq_in->transfer_dma = xpad->idata_dma;\r\nxpad->irq_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nerror = input_register_device(xpad->dev);\r\nif (error)\r\ngoto fail6;\r\nusb_set_intfdata(intf, xpad);\r\nif (xpad->xtype == XTYPE_XBOX360W) {\r\nxpad->bulk_out = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!xpad->bulk_out) {\r\nerror = -ENOMEM;\r\ngoto fail7;\r\n}\r\nxpad->bdata = kzalloc(XPAD_PKT_LEN, GFP_KERNEL);\r\nif (!xpad->bdata) {\r\nerror = -ENOMEM;\r\ngoto fail8;\r\n}\r\nxpad->bdata[2] = 0x08;\r\nswitch (intf->cur_altsetting->desc.bInterfaceNumber) {\r\ncase 0:\r\nxpad->bdata[3] = 0x42;\r\nbreak;\r\ncase 2:\r\nxpad->bdata[3] = 0x43;\r\nbreak;\r\ncase 4:\r\nxpad->bdata[3] = 0x44;\r\nbreak;\r\ncase 6:\r\nxpad->bdata[3] = 0x45;\r\n}\r\nep_irq_in = &intf->cur_altsetting->endpoint[1].desc;\r\nusb_fill_bulk_urb(xpad->bulk_out, udev,\r\nusb_sndbulkpipe(udev, ep_irq_in->bEndpointAddress),\r\nxpad->bdata, XPAD_PKT_LEN, xpad_bulk_out, xpad);\r\nxpad->irq_in->dev = xpad->udev;\r\nerror = usb_submit_urb(xpad->irq_in, GFP_KERNEL);\r\nif (error)\r\ngoto fail9;\r\n}\r\nreturn 0;\r\nfail9: kfree(xpad->bdata);\r\nfail8: usb_free_urb(xpad->bulk_out);\r\nfail7: input_unregister_device(input_dev);\r\ninput_dev = NULL;\r\nfail6: xpad_led_disconnect(xpad);\r\nfail5: if (input_dev)\r\ninput_ff_destroy(input_dev);\r\nfail4: xpad_deinit_output(xpad);\r\nfail3: usb_free_urb(xpad->irq_in);\r\nfail2: usb_free_coherent(udev, XPAD_PKT_LEN, xpad->idata, xpad->idata_dma);\r\nfail1: input_free_device(input_dev);\r\nkfree(xpad);\r\nreturn error;\r\n}\r\nstatic void xpad_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usb_xpad *xpad = usb_get_intfdata (intf);\r\nxpad_led_disconnect(xpad);\r\ninput_unregister_device(xpad->dev);\r\nxpad_deinit_output(xpad);\r\nif (xpad->xtype == XTYPE_XBOX360W) {\r\nusb_kill_urb(xpad->bulk_out);\r\nusb_free_urb(xpad->bulk_out);\r\nusb_kill_urb(xpad->irq_in);\r\n}\r\nusb_free_urb(xpad->irq_in);\r\nusb_free_coherent(xpad->udev, XPAD_PKT_LEN,\r\nxpad->idata, xpad->idata_dma);\r\nkfree(xpad->bdata);\r\nkfree(xpad);\r\nusb_set_intfdata(intf, NULL);\r\n}
