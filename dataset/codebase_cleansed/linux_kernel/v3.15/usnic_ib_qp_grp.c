const char *usnic_ib_qp_grp_state_to_string(enum ib_qp_state state)\r\n{\r\nswitch (state) {\r\ncase IB_QPS_RESET:\r\nreturn "Rst";\r\ncase IB_QPS_INIT:\r\nreturn "Init";\r\ncase IB_QPS_RTR:\r\nreturn "RTR";\r\ncase IB_QPS_RTS:\r\nreturn "RTS";\r\ncase IB_QPS_SQD:\r\nreturn "SQD";\r\ncase IB_QPS_SQE:\r\nreturn "SQE";\r\ncase IB_QPS_ERR:\r\nreturn "ERR";\r\ndefault:\r\nreturn "UNKOWN STATE";\r\n}\r\n}\r\nint usnic_ib_qp_grp_dump_hdr(char *buf, int buf_sz)\r\n{\r\nreturn scnprintf(buf, buf_sz, "|QPN\t|State\t|PID\t|VF Idx\t|Fil ID");\r\n}\r\nint usnic_ib_qp_grp_dump_rows(void *obj, char *buf, int buf_sz)\r\n{\r\nstruct usnic_ib_qp_grp *qp_grp = obj;\r\nstruct usnic_ib_qp_grp_flow *default_flow;\r\nif (obj) {\r\ndefault_flow = list_first_entry(&qp_grp->flows_lst,\r\nstruct usnic_ib_qp_grp_flow, link);\r\nreturn scnprintf(buf, buf_sz, "|%d\t|%s\t|%d\t|%hu\t|%d",\r\nqp_grp->ibqp.qp_num,\r\nusnic_ib_qp_grp_state_to_string(\r\nqp_grp->state),\r\nqp_grp->owner_pid,\r\nusnic_vnic_get_index(qp_grp->vf->vnic),\r\ndefault_flow->flow->flow_id);\r\n} else {\r\nreturn scnprintf(buf, buf_sz, "|N/A\t|N/A\t|N/A\t|N/A\t|N/A");\r\n}\r\n}\r\nstatic struct usnic_vnic_res_chunk *\r\nget_qp_res_chunk(struct usnic_ib_qp_grp *qp_grp)\r\n{\r\nlockdep_assert_held(&qp_grp->lock);\r\nreturn usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);\r\n}\r\nstatic int enable_qp_grp(struct usnic_ib_qp_grp *qp_grp)\r\n{\r\nint status;\r\nint i, vnic_idx;\r\nstruct usnic_vnic_res_chunk *res_chunk;\r\nstruct usnic_vnic_res *res;\r\nlockdep_assert_held(&qp_grp->lock);\r\nvnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);\r\nres_chunk = get_qp_res_chunk(qp_grp);\r\nif (IS_ERR_OR_NULL(res_chunk)) {\r\nusnic_err("Unable to get qp res with err %ld\n",\r\nPTR_ERR(res_chunk));\r\nreturn res_chunk ? PTR_ERR(res_chunk) : -ENOMEM;\r\n}\r\nfor (i = 0; i < res_chunk->cnt; i++) {\r\nres = res_chunk->res[i];\r\nstatus = usnic_fwd_enable_qp(qp_grp->ufdev, vnic_idx,\r\nres->vnic_idx);\r\nif (status) {\r\nusnic_err("Failed to enable qp %d of %s:%d\n with err %d\n",\r\nres->vnic_idx, qp_grp->ufdev->name,\r\nvnic_idx, status);\r\ngoto out_err;\r\n}\r\n}\r\nreturn 0;\r\nout_err:\r\nfor (i--; i >= 0; i--) {\r\nres = res_chunk->res[i];\r\nusnic_fwd_disable_qp(qp_grp->ufdev, vnic_idx,\r\nres->vnic_idx);\r\n}\r\nreturn status;\r\n}\r\nstatic int disable_qp_grp(struct usnic_ib_qp_grp *qp_grp)\r\n{\r\nint i, vnic_idx;\r\nstruct usnic_vnic_res_chunk *res_chunk;\r\nstruct usnic_vnic_res *res;\r\nint status = 0;\r\nlockdep_assert_held(&qp_grp->lock);\r\nvnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);\r\nres_chunk = get_qp_res_chunk(qp_grp);\r\nif (IS_ERR_OR_NULL(res_chunk)) {\r\nusnic_err("Unable to get qp res with err %ld\n",\r\nPTR_ERR(res_chunk));\r\nreturn res_chunk ? PTR_ERR(res_chunk) : -ENOMEM;\r\n}\r\nfor (i = 0; i < res_chunk->cnt; i++) {\r\nres = res_chunk->res[i];\r\nstatus = usnic_fwd_disable_qp(qp_grp->ufdev, vnic_idx,\r\nres->vnic_idx);\r\nif (status) {\r\nusnic_err("Failed to disable rq %d of %s:%d\n with err %d\n",\r\nres->vnic_idx,\r\nqp_grp->ufdev->name,\r\nvnic_idx, status);\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int init_filter_action(struct usnic_ib_qp_grp *qp_grp,\r\nstruct usnic_filter_action *uaction)\r\n{\r\nstruct usnic_vnic_res_chunk *res_chunk;\r\nres_chunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);\r\nif (IS_ERR_OR_NULL(res_chunk)) {\r\nusnic_err("Unable to get %s with err %ld\n",\r\nusnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_RQ),\r\nPTR_ERR(res_chunk));\r\nreturn res_chunk ? PTR_ERR(res_chunk) : -ENOMEM;\r\n}\r\nuaction->vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);\r\nuaction->action.type = FILTER_ACTION_RQ_STEERING;\r\nuaction->action.u.rq_idx = res_chunk->res[DFLT_RQ_IDX]->vnic_idx;\r\nreturn 0;\r\n}\r\nstatic struct usnic_ib_qp_grp_flow*\r\ncreate_roce_custom_flow(struct usnic_ib_qp_grp *qp_grp,\r\nstruct usnic_transport_spec *trans_spec)\r\n{\r\nuint16_t port_num;\r\nint err;\r\nstruct filter filter;\r\nstruct usnic_filter_action uaction;\r\nstruct usnic_ib_qp_grp_flow *qp_flow;\r\nstruct usnic_fwd_flow *flow;\r\nenum usnic_transport_type trans_type;\r\ntrans_type = trans_spec->trans_type;\r\nport_num = trans_spec->usnic_roce.port_num;\r\nport_num = usnic_transport_rsrv_port(trans_type, port_num);\r\nif (port_num == 0)\r\nreturn ERR_PTR(-EINVAL);\r\nusnic_fwd_init_usnic_filter(&filter, port_num);\r\nerr = init_filter_action(qp_grp, &uaction);\r\nif (err)\r\ngoto out_unreserve_port;\r\nflow = usnic_fwd_alloc_flow(qp_grp->ufdev, &filter, &uaction);\r\nif (IS_ERR_OR_NULL(flow)) {\r\nusnic_err("Unable to alloc flow failed with err %ld\n",\r\nPTR_ERR(flow));\r\nerr = flow ? PTR_ERR(flow) : -EFAULT;\r\ngoto out_unreserve_port;\r\n}\r\nqp_flow = kzalloc(sizeof(*qp_flow), GFP_ATOMIC);\r\nif (IS_ERR_OR_NULL(qp_flow)) {\r\nerr = qp_flow ? PTR_ERR(qp_flow) : -ENOMEM;\r\ngoto out_dealloc_flow;\r\n}\r\nqp_flow->flow = flow;\r\nqp_flow->trans_type = trans_type;\r\nqp_flow->usnic_roce.port_num = port_num;\r\nqp_flow->qp_grp = qp_grp;\r\nreturn qp_flow;\r\nout_dealloc_flow:\r\nusnic_fwd_dealloc_flow(flow);\r\nout_unreserve_port:\r\nusnic_transport_unrsrv_port(trans_type, port_num);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void release_roce_custom_flow(struct usnic_ib_qp_grp_flow *qp_flow)\r\n{\r\nusnic_fwd_dealloc_flow(qp_flow->flow);\r\nusnic_transport_unrsrv_port(qp_flow->trans_type,\r\nqp_flow->usnic_roce.port_num);\r\nkfree(qp_flow);\r\n}\r\nstatic struct usnic_ib_qp_grp_flow*\r\ncreate_udp_flow(struct usnic_ib_qp_grp *qp_grp,\r\nstruct usnic_transport_spec *trans_spec)\r\n{\r\nstruct socket *sock;\r\nint sock_fd;\r\nint err;\r\nstruct filter filter;\r\nstruct usnic_filter_action uaction;\r\nstruct usnic_ib_qp_grp_flow *qp_flow;\r\nstruct usnic_fwd_flow *flow;\r\nenum usnic_transport_type trans_type;\r\nuint32_t addr;\r\nuint16_t port_num;\r\nint proto;\r\ntrans_type = trans_spec->trans_type;\r\nsock_fd = trans_spec->udp.sock_fd;\r\nsock = usnic_transport_get_socket(sock_fd);\r\nif (IS_ERR_OR_NULL(sock))\r\nreturn ERR_CAST(sock);\r\nerr = usnic_transport_sock_get_addr(sock, &proto, &addr, &port_num);\r\nif (err)\r\ngoto out_put_sock;\r\nif (proto != IPPROTO_UDP) {\r\nusnic_err("Protocol for fd %d is not UDP", sock_fd);\r\nerr = -EPERM;\r\ngoto out_put_sock;\r\n}\r\nusnic_fwd_init_udp_filter(&filter, addr, port_num);\r\nerr = init_filter_action(qp_grp, &uaction);\r\nif (err)\r\ngoto out_put_sock;\r\nflow = usnic_fwd_alloc_flow(qp_grp->ufdev, &filter, &uaction);\r\nif (IS_ERR_OR_NULL(flow)) {\r\nusnic_err("Unable to alloc flow failed with err %ld\n",\r\nPTR_ERR(flow));\r\nerr = flow ? PTR_ERR(flow) : -EFAULT;\r\ngoto out_put_sock;\r\n}\r\nqp_flow = kzalloc(sizeof(*qp_flow), GFP_ATOMIC);\r\nif (IS_ERR_OR_NULL(qp_flow)) {\r\nerr = qp_flow ? PTR_ERR(qp_flow) : -ENOMEM;\r\ngoto out_dealloc_flow;\r\n}\r\nqp_flow->flow = flow;\r\nqp_flow->trans_type = trans_type;\r\nqp_flow->udp.sock = sock;\r\nqp_flow->qp_grp = qp_grp;\r\nreturn qp_flow;\r\nout_dealloc_flow:\r\nusnic_fwd_dealloc_flow(flow);\r\nout_put_sock:\r\nusnic_transport_put_socket(sock);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void release_udp_flow(struct usnic_ib_qp_grp_flow *qp_flow)\r\n{\r\nusnic_fwd_dealloc_flow(qp_flow->flow);\r\nusnic_transport_put_socket(qp_flow->udp.sock);\r\nkfree(qp_flow);\r\n}\r\nstatic struct usnic_ib_qp_grp_flow*\r\ncreate_and_add_flow(struct usnic_ib_qp_grp *qp_grp,\r\nstruct usnic_transport_spec *trans_spec)\r\n{\r\nstruct usnic_ib_qp_grp_flow *qp_flow;\r\nenum usnic_transport_type trans_type;\r\ntrans_type = trans_spec->trans_type;\r\nswitch (trans_type) {\r\ncase USNIC_TRANSPORT_ROCE_CUSTOM:\r\nqp_flow = create_roce_custom_flow(qp_grp, trans_spec);\r\nbreak;\r\ncase USNIC_TRANSPORT_IPV4_UDP:\r\nqp_flow = create_udp_flow(qp_grp, trans_spec);\r\nbreak;\r\ndefault:\r\nusnic_err("Unsupported transport %u\n",\r\ntrans_spec->trans_type);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!IS_ERR_OR_NULL(qp_flow)) {\r\nlist_add_tail(&qp_flow->link, &qp_grp->flows_lst);\r\nusnic_debugfs_flow_add(qp_flow);\r\n}\r\nreturn qp_flow;\r\n}\r\nstatic void release_and_remove_flow(struct usnic_ib_qp_grp_flow *qp_flow)\r\n{\r\nusnic_debugfs_flow_remove(qp_flow);\r\nlist_del(&qp_flow->link);\r\nswitch (qp_flow->trans_type) {\r\ncase USNIC_TRANSPORT_ROCE_CUSTOM:\r\nrelease_roce_custom_flow(qp_flow);\r\nbreak;\r\ncase USNIC_TRANSPORT_IPV4_UDP:\r\nrelease_udp_flow(qp_flow);\r\nbreak;\r\ndefault:\r\nWARN(1, "Unsupported transport %u\n",\r\nqp_flow->trans_type);\r\nbreak;\r\n}\r\n}\r\nstatic void release_and_remove_all_flows(struct usnic_ib_qp_grp *qp_grp)\r\n{\r\nstruct usnic_ib_qp_grp_flow *qp_flow, *tmp;\r\nlist_for_each_entry_safe(qp_flow, tmp, &qp_grp->flows_lst, link)\r\nrelease_and_remove_flow(qp_flow);\r\n}\r\nint usnic_ib_qp_grp_modify(struct usnic_ib_qp_grp *qp_grp,\r\nenum ib_qp_state new_state,\r\nvoid *data)\r\n{\r\nint status = 0;\r\nint vnic_idx;\r\nstruct ib_event ib_event;\r\nenum ib_qp_state old_state;\r\nstruct usnic_transport_spec *trans_spec;\r\nstruct usnic_ib_qp_grp_flow *qp_flow;\r\nold_state = qp_grp->state;\r\nvnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);\r\ntrans_spec = (struct usnic_transport_spec *) data;\r\nspin_lock(&qp_grp->lock);\r\nswitch (new_state) {\r\ncase IB_QPS_RESET:\r\nswitch (old_state) {\r\ncase IB_QPS_RESET:\r\nbreak;\r\ncase IB_QPS_INIT:\r\nrelease_and_remove_all_flows(qp_grp);\r\nstatus = 0;\r\nbreak;\r\ncase IB_QPS_RTR:\r\ncase IB_QPS_RTS:\r\ncase IB_QPS_ERR:\r\nstatus = disable_qp_grp(qp_grp);\r\nrelease_and_remove_all_flows(qp_grp);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nbreak;\r\ncase IB_QPS_INIT:\r\nswitch (old_state) {\r\ncase IB_QPS_RESET:\r\nif (trans_spec) {\r\nqp_flow = create_and_add_flow(qp_grp,\r\ntrans_spec);\r\nif (IS_ERR_OR_NULL(qp_flow)) {\r\nstatus = qp_flow ? PTR_ERR(qp_flow) : -EFAULT;\r\nbreak;\r\n}\r\n} else {\r\nstatus = 0;\r\n}\r\nbreak;\r\ncase IB_QPS_INIT:\r\nif (trans_spec) {\r\nqp_flow = create_and_add_flow(qp_grp,\r\ntrans_spec);\r\nif (IS_ERR_OR_NULL(qp_flow)) {\r\nstatus = qp_flow ? PTR_ERR(qp_flow) : -EFAULT;\r\nbreak;\r\n}\r\n} else {\r\nstatus = -EINVAL;\r\n}\r\nbreak;\r\ncase IB_QPS_RTR:\r\nstatus = disable_qp_grp(qp_grp);\r\nbreak;\r\ncase IB_QPS_RTS:\r\nstatus = disable_qp_grp(qp_grp);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nbreak;\r\ncase IB_QPS_RTR:\r\nswitch (old_state) {\r\ncase IB_QPS_INIT:\r\nstatus = enable_qp_grp(qp_grp);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nbreak;\r\ncase IB_QPS_RTS:\r\nswitch (old_state) {\r\ncase IB_QPS_RTR:\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nbreak;\r\ncase IB_QPS_ERR:\r\nib_event.device = &qp_grp->vf->pf->ib_dev;\r\nib_event.element.qp = &qp_grp->ibqp;\r\nib_event.event = IB_EVENT_QP_FATAL;\r\nswitch (old_state) {\r\ncase IB_QPS_RESET:\r\nqp_grp->ibqp.event_handler(&ib_event,\r\nqp_grp->ibqp.qp_context);\r\nbreak;\r\ncase IB_QPS_INIT:\r\nrelease_and_remove_all_flows(qp_grp);\r\nqp_grp->ibqp.event_handler(&ib_event,\r\nqp_grp->ibqp.qp_context);\r\nbreak;\r\ncase IB_QPS_RTR:\r\ncase IB_QPS_RTS:\r\nstatus = disable_qp_grp(qp_grp);\r\nrelease_and_remove_all_flows(qp_grp);\r\nqp_grp->ibqp.event_handler(&ib_event,\r\nqp_grp->ibqp.qp_context);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nspin_unlock(&qp_grp->lock);\r\nif (!status) {\r\nqp_grp->state = new_state;\r\nusnic_info("Transistioned %u from %s to %s",\r\nqp_grp->grp_id,\r\nusnic_ib_qp_grp_state_to_string(old_state),\r\nusnic_ib_qp_grp_state_to_string(new_state));\r\n} else {\r\nusnic_err("Failed to transistion %u from %s to %s",\r\nqp_grp->grp_id,\r\nusnic_ib_qp_grp_state_to_string(old_state),\r\nusnic_ib_qp_grp_state_to_string(new_state));\r\n}\r\nreturn status;\r\n}\r\nstatic struct usnic_vnic_res_chunk**\r\nalloc_res_chunk_list(struct usnic_vnic *vnic,\r\nstruct usnic_vnic_res_spec *res_spec, void *owner_obj)\r\n{\r\nenum usnic_vnic_res_type res_type;\r\nstruct usnic_vnic_res_chunk **res_chunk_list;\r\nint err, i, res_cnt, res_lst_sz;\r\nfor (res_lst_sz = 0;\r\nres_spec->resources[res_lst_sz].type != USNIC_VNIC_RES_TYPE_EOL;\r\nres_lst_sz++) {\r\n}\r\nres_chunk_list = kzalloc(sizeof(*res_chunk_list)*(res_lst_sz+1),\r\nGFP_ATOMIC);\r\nif (!res_chunk_list)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; res_spec->resources[i].type != USNIC_VNIC_RES_TYPE_EOL;\r\ni++) {\r\nres_type = res_spec->resources[i].type;\r\nres_cnt = res_spec->resources[i].cnt;\r\nres_chunk_list[i] = usnic_vnic_get_resources(vnic, res_type,\r\nres_cnt, owner_obj);\r\nif (IS_ERR_OR_NULL(res_chunk_list[i])) {\r\nerr = res_chunk_list[i] ?\r\nPTR_ERR(res_chunk_list[i]) : -ENOMEM;\r\nusnic_err("Failed to get %s from %s with err %d\n",\r\nusnic_vnic_res_type_to_str(res_type),\r\nusnic_vnic_pci_name(vnic),\r\nerr);\r\ngoto out_free_res;\r\n}\r\n}\r\nreturn res_chunk_list;\r\nout_free_res:\r\nfor (i--; i > 0; i--)\r\nusnic_vnic_put_resources(res_chunk_list[i]);\r\nkfree(res_chunk_list);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void free_qp_grp_res(struct usnic_vnic_res_chunk **res_chunk_list)\r\n{\r\nint i;\r\nfor (i = 0; res_chunk_list[i]; i++)\r\nusnic_vnic_put_resources(res_chunk_list[i]);\r\nkfree(res_chunk_list);\r\n}\r\nstatic int qp_grp_and_vf_bind(struct usnic_ib_vf *vf,\r\nstruct usnic_ib_pd *pd,\r\nstruct usnic_ib_qp_grp *qp_grp)\r\n{\r\nint err;\r\nstruct pci_dev *pdev;\r\nlockdep_assert_held(&vf->lock);\r\npdev = usnic_vnic_get_pdev(vf->vnic);\r\nif (vf->qp_grp_ref_cnt == 0) {\r\nerr = usnic_uiom_attach_dev_to_pd(pd->umem_pd, &pdev->dev);\r\nif (err) {\r\nusnic_err("Failed to attach %s to domain\n",\r\npci_name(pdev));\r\nreturn err;\r\n}\r\nvf->pd = pd;\r\n}\r\nvf->qp_grp_ref_cnt++;\r\nWARN_ON(vf->pd != pd);\r\nqp_grp->vf = vf;\r\nreturn 0;\r\n}\r\nstatic void qp_grp_and_vf_unbind(struct usnic_ib_qp_grp *qp_grp)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct usnic_ib_pd *pd;\r\nlockdep_assert_held(&qp_grp->vf->lock);\r\npd = qp_grp->vf->pd;\r\npdev = usnic_vnic_get_pdev(qp_grp->vf->vnic);\r\nif (--qp_grp->vf->qp_grp_ref_cnt == 0) {\r\nqp_grp->vf->pd = NULL;\r\nusnic_uiom_detach_dev_from_pd(pd->umem_pd, &pdev->dev);\r\n}\r\nqp_grp->vf = NULL;\r\n}\r\nstatic void log_spec(struct usnic_vnic_res_spec *res_spec)\r\n{\r\nchar buf[512];\r\nusnic_vnic_spec_dump(buf, sizeof(buf), res_spec);\r\nusnic_dbg("%s\n", buf);\r\n}\r\nstatic int qp_grp_id_from_flow(struct usnic_ib_qp_grp_flow *qp_flow,\r\nuint32_t *id)\r\n{\r\nenum usnic_transport_type trans_type = qp_flow->trans_type;\r\nint err;\r\nuint16_t port_num = 0;\r\nswitch (trans_type) {\r\ncase USNIC_TRANSPORT_ROCE_CUSTOM:\r\n*id = qp_flow->usnic_roce.port_num;\r\nbreak;\r\ncase USNIC_TRANSPORT_IPV4_UDP:\r\nerr = usnic_transport_sock_get_addr(qp_flow->udp.sock,\r\nNULL, NULL,\r\n&port_num);\r\nif (err)\r\nreturn err;\r\n*id = port_num;\r\nbreak;\r\ndefault:\r\nusnic_err("Unsupported transport %u\n", trans_type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstruct usnic_ib_qp_grp *\r\nusnic_ib_qp_grp_create(struct usnic_fwd_dev *ufdev, struct usnic_ib_vf *vf,\r\nstruct usnic_ib_pd *pd,\r\nstruct usnic_vnic_res_spec *res_spec,\r\nstruct usnic_transport_spec *transport_spec)\r\n{\r\nstruct usnic_ib_qp_grp *qp_grp;\r\nint err;\r\nenum usnic_transport_type transport = transport_spec->trans_type;\r\nstruct usnic_ib_qp_grp_flow *qp_flow;\r\nlockdep_assert_held(&vf->lock);\r\nerr = usnic_vnic_res_spec_satisfied(&min_transport_spec[transport],\r\nres_spec);\r\nif (err) {\r\nusnic_err("Spec does not meet miniumum req for transport %d\n",\r\ntransport);\r\nlog_spec(res_spec);\r\nreturn ERR_PTR(err);\r\n}\r\nqp_grp = kzalloc(sizeof(*qp_grp), GFP_ATOMIC);\r\nif (!qp_grp) {\r\nusnic_err("Unable to alloc qp_grp - Out of memory\n");\r\nreturn NULL;\r\n}\r\nqp_grp->res_chunk_list = alloc_res_chunk_list(vf->vnic, res_spec,\r\nqp_grp);\r\nif (IS_ERR_OR_NULL(qp_grp->res_chunk_list)) {\r\nerr = qp_grp->res_chunk_list ?\r\nPTR_ERR(qp_grp->res_chunk_list) : -ENOMEM;\r\nusnic_err("Unable to alloc res for %d with err %d\n",\r\nqp_grp->grp_id, err);\r\ngoto out_free_qp_grp;\r\n}\r\nerr = qp_grp_and_vf_bind(vf, pd, qp_grp);\r\nif (err)\r\ngoto out_free_res;\r\nINIT_LIST_HEAD(&qp_grp->flows_lst);\r\nspin_lock_init(&qp_grp->lock);\r\nqp_grp->ufdev = ufdev;\r\nqp_grp->state = IB_QPS_RESET;\r\nqp_grp->owner_pid = current->pid;\r\nqp_flow = create_and_add_flow(qp_grp, transport_spec);\r\nif (IS_ERR_OR_NULL(qp_flow)) {\r\nusnic_err("Unable to create and add flow with err %ld\n",\r\nPTR_ERR(qp_flow));\r\nerr = qp_flow ? PTR_ERR(qp_flow) : -EFAULT;\r\ngoto out_qp_grp_vf_unbind;\r\n}\r\nerr = qp_grp_id_from_flow(qp_flow, &qp_grp->grp_id);\r\nif (err)\r\ngoto out_release_flow;\r\nqp_grp->ibqp.qp_num = qp_grp->grp_id;\r\nusnic_ib_sysfs_qpn_add(qp_grp);\r\nreturn qp_grp;\r\nout_release_flow:\r\nrelease_and_remove_flow(qp_flow);\r\nout_qp_grp_vf_unbind:\r\nqp_grp_and_vf_unbind(qp_grp);\r\nout_free_res:\r\nfree_qp_grp_res(qp_grp->res_chunk_list);\r\nout_free_qp_grp:\r\nkfree(qp_grp);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid usnic_ib_qp_grp_destroy(struct usnic_ib_qp_grp *qp_grp)\r\n{\r\nWARN_ON(qp_grp->state != IB_QPS_RESET);\r\nlockdep_assert_held(&qp_grp->vf->lock);\r\nrelease_and_remove_all_flows(qp_grp);\r\nusnic_ib_sysfs_qpn_remove(qp_grp);\r\nqp_grp_and_vf_unbind(qp_grp);\r\nfree_qp_grp_res(qp_grp->res_chunk_list);\r\nkfree(qp_grp);\r\n}\r\nstruct usnic_vnic_res_chunk*\r\nusnic_ib_qp_grp_get_chunk(struct usnic_ib_qp_grp *qp_grp,\r\nenum usnic_vnic_res_type res_type)\r\n{\r\nint i;\r\nfor (i = 0; qp_grp->res_chunk_list[i]; i++) {\r\nif (qp_grp->res_chunk_list[i]->type == res_type)\r\nreturn qp_grp->res_chunk_list[i];\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}
