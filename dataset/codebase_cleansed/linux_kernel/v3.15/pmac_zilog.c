static void pmz_load_zsregs(struct uart_pmac_port *uap, u8 *regs)\r\n{\r\nint i;\r\nfor (i = 0; i < 1000; i++) {\r\nunsigned char stat = read_zsreg(uap, R1);\r\nif (stat & ALL_SNT)\r\nbreak;\r\nudelay(100);\r\n}\r\nZS_CLEARERR(uap);\r\nzssync(uap);\r\nZS_CLEARFIFO(uap);\r\nzssync(uap);\r\nZS_CLEARERR(uap);\r\nwrite_zsreg(uap, R1,\r\nregs[R1] & ~(RxINT_MASK | TxINT_ENAB | EXT_INT_ENAB));\r\nwrite_zsreg(uap, R4, regs[R4]);\r\nwrite_zsreg(uap, R10, regs[R10]);\r\nwrite_zsreg(uap, R3, regs[R3] & ~RxENABLE);\r\nwrite_zsreg(uap, R5, regs[R5] & ~TxENABLE);\r\nwrite_zsreg(uap, R15, regs[R15] | EN85C30);\r\nwrite_zsreg(uap, R7, regs[R7P]);\r\nwrite_zsreg(uap, R15, regs[R15] & ~EN85C30);\r\nwrite_zsreg(uap, R6, regs[R6]);\r\nwrite_zsreg(uap, R7, regs[R7]);\r\nwrite_zsreg(uap, R14, regs[R14] & ~BRENAB);\r\nwrite_zsreg(uap, R11, regs[R11]);\r\nwrite_zsreg(uap, R12, regs[R12]);\r\nwrite_zsreg(uap, R13, regs[R13]);\r\nwrite_zsreg(uap, R14, regs[R14]);\r\nwrite_zsreg(uap, R0, RES_EXT_INT);\r\nwrite_zsreg(uap, R0, RES_EXT_INT);\r\nwrite_zsreg(uap, R3, regs[R3]);\r\nwrite_zsreg(uap, R5, regs[R5]);\r\nwrite_zsreg(uap, R1, regs[R1]);\r\nwrite_zsreg(uap, R9, regs[R9]);\r\n}\r\nstatic void pmz_maybe_update_regs(struct uart_pmac_port *uap)\r\n{\r\nif (!ZS_REGS_HELD(uap)) {\r\nif (ZS_TX_ACTIVE(uap)) {\r\nuap->flags |= PMACZILOG_FLAG_REGS_HELD;\r\n} else {\r\npmz_debug("pmz: maybe_update_regs: updating\n");\r\npmz_load_zsregs(uap, uap->curregs);\r\n}\r\n}\r\n}\r\nstatic void pmz_interrupt_control(struct uart_pmac_port *uap, int enable)\r\n{\r\nif (enable) {\r\nuap->curregs[1] |= INT_ALL_Rx | TxINT_ENAB;\r\nif (!ZS_IS_EXTCLK(uap))\r\nuap->curregs[1] |= EXT_INT_ENAB;\r\n} else {\r\nuap->curregs[1] &= ~(EXT_INT_ENAB | TxINT_ENAB | RxINT_MASK);\r\n}\r\nwrite_zsreg(uap, R1, uap->curregs[1]);\r\n}\r\nstatic bool pmz_receive_chars(struct uart_pmac_port *uap)\r\n{\r\nstruct tty_port *port;\r\nunsigned char ch, r1, drop, error, flag;\r\nint loops = 0;\r\nif (uap->port.state == NULL) {\r\nWARN_ON(1);\r\n(void)read_zsdata(uap);\r\nreturn false;\r\n}\r\nport = &uap->port.state->port;\r\nwhile (1) {\r\nerror = 0;\r\ndrop = 0;\r\nr1 = read_zsreg(uap, R1);\r\nch = read_zsdata(uap);\r\nif (r1 & (PAR_ERR | Rx_OVR | CRC_ERR)) {\r\nwrite_zsreg(uap, R0, ERR_RES);\r\nzssync(uap);\r\n}\r\nch &= uap->parity_mask;\r\nif (ch == 0 && uap->flags & PMACZILOG_FLAG_BREAK) {\r\nuap->flags &= ~PMACZILOG_FLAG_BREAK;\r\n}\r\n#if defined(CONFIG_MAGIC_SYSRQ) && defined(CONFIG_SERIAL_CORE_CONSOLE)\r\n#ifdef USE_CTRL_O_SYSRQ\r\nif (ch == '\x0f') {\r\nuap->port.sysrq = jiffies + HZ*5;\r\ngoto next_char;\r\n}\r\n#endif\r\nif (uap->port.sysrq) {\r\nint swallow;\r\nspin_unlock(&uap->port.lock);\r\nswallow = uart_handle_sysrq_char(&uap->port, ch);\r\nspin_lock(&uap->port.lock);\r\nif (swallow)\r\ngoto next_char;\r\n}\r\n#endif\r\nif (drop)\r\ngoto next_char;\r\nflag = TTY_NORMAL;\r\nuap->port.icount.rx++;\r\nif (r1 & (PAR_ERR | Rx_OVR | CRC_ERR | BRK_ABRT)) {\r\nerror = 1;\r\nif (r1 & BRK_ABRT) {\r\npmz_debug("pmz: got break !\n");\r\nr1 &= ~(PAR_ERR | CRC_ERR);\r\nuap->port.icount.brk++;\r\nif (uart_handle_break(&uap->port))\r\ngoto next_char;\r\n}\r\nelse if (r1 & PAR_ERR)\r\nuap->port.icount.parity++;\r\nelse if (r1 & CRC_ERR)\r\nuap->port.icount.frame++;\r\nif (r1 & Rx_OVR)\r\nuap->port.icount.overrun++;\r\nr1 &= uap->port.read_status_mask;\r\nif (r1 & BRK_ABRT)\r\nflag = TTY_BREAK;\r\nelse if (r1 & PAR_ERR)\r\nflag = TTY_PARITY;\r\nelse if (r1 & CRC_ERR)\r\nflag = TTY_FRAME;\r\n}\r\nif (uap->port.ignore_status_mask == 0xff ||\r\n(r1 & uap->port.ignore_status_mask) == 0) {\r\ntty_insert_flip_char(port, ch, flag);\r\n}\r\nif (r1 & Rx_OVR)\r\ntty_insert_flip_char(port, 0, TTY_OVERRUN);\r\nnext_char:\r\nif ((++loops) > 1000)\r\ngoto flood;\r\nch = read_zsreg(uap, R0);\r\nif (!(ch & Rx_CH_AV))\r\nbreak;\r\n}\r\nreturn true;\r\nflood:\r\npmz_interrupt_control(uap, 0);\r\npmz_error("pmz: rx irq flood !\n");\r\nreturn true;\r\n}\r\nstatic void pmz_status_handle(struct uart_pmac_port *uap)\r\n{\r\nunsigned char status;\r\nstatus = read_zsreg(uap, R0);\r\nwrite_zsreg(uap, R0, RES_EXT_INT);\r\nzssync(uap);\r\nif (ZS_IS_OPEN(uap) && ZS_WANTS_MODEM_STATUS(uap)) {\r\nif (status & SYNC_HUNT)\r\nuap->port.icount.dsr++;\r\nif ((status ^ uap->prev_status) & DCD)\r\nuart_handle_dcd_change(&uap->port,\r\n(status & DCD));\r\nif ((status ^ uap->prev_status) & CTS)\r\nuart_handle_cts_change(&uap->port,\r\n!(status & CTS));\r\nwake_up_interruptible(&uap->port.state->port.delta_msr_wait);\r\n}\r\nif (status & BRK_ABRT)\r\nuap->flags |= PMACZILOG_FLAG_BREAK;\r\nuap->prev_status = status;\r\n}\r\nstatic void pmz_transmit_chars(struct uart_pmac_port *uap)\r\n{\r\nstruct circ_buf *xmit;\r\nif (ZS_IS_CONS(uap)) {\r\nunsigned char status = read_zsreg(uap, R0);\r\nif (!(status & Tx_BUF_EMP))\r\nreturn;\r\n}\r\nuap->flags &= ~PMACZILOG_FLAG_TX_ACTIVE;\r\nif (ZS_REGS_HELD(uap)) {\r\npmz_load_zsregs(uap, uap->curregs);\r\nuap->flags &= ~PMACZILOG_FLAG_REGS_HELD;\r\n}\r\nif (ZS_TX_STOPPED(uap)) {\r\nuap->flags &= ~PMACZILOG_FLAG_TX_STOPPED;\r\ngoto ack_tx_int;\r\n}\r\nif (!ZS_IS_OPEN(uap))\r\ngoto ack_tx_int;\r\nif (uap->port.x_char) {\r\nuap->flags |= PMACZILOG_FLAG_TX_ACTIVE;\r\nwrite_zsdata(uap, uap->port.x_char);\r\nzssync(uap);\r\nuap->port.icount.tx++;\r\nuap->port.x_char = 0;\r\nreturn;\r\n}\r\nif (uap->port.state == NULL)\r\ngoto ack_tx_int;\r\nxmit = &uap->port.state->xmit;\r\nif (uart_circ_empty(xmit)) {\r\nuart_write_wakeup(&uap->port);\r\ngoto ack_tx_int;\r\n}\r\nif (uart_tx_stopped(&uap->port))\r\ngoto ack_tx_int;\r\nuap->flags |= PMACZILOG_FLAG_TX_ACTIVE;\r\nwrite_zsdata(uap, xmit->buf[xmit->tail]);\r\nzssync(uap);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nuap->port.icount.tx++;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&uap->port);\r\nreturn;\r\nack_tx_int:\r\nwrite_zsreg(uap, R0, RES_Tx_P);\r\nzssync(uap);\r\n}\r\nstatic irqreturn_t pmz_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_pmac_port *uap = dev_id;\r\nstruct uart_pmac_port *uap_a;\r\nstruct uart_pmac_port *uap_b;\r\nint rc = IRQ_NONE;\r\nbool push;\r\nu8 r3;\r\nuap_a = pmz_get_port_A(uap);\r\nuap_b = uap_a->mate;\r\nspin_lock(&uap_a->port.lock);\r\nr3 = read_zsreg(uap_a, R3);\r\n#ifdef DEBUG_HARD\r\npmz_debug("irq, r3: %x\n", r3);\r\n#endif\r\npush = false;\r\nif (r3 & (CHAEXT | CHATxIP | CHARxIP)) {\r\nif (!ZS_IS_OPEN(uap_a)) {\r\npmz_debug("ChanA interrupt while not open !\n");\r\ngoto skip_a;\r\n}\r\nwrite_zsreg(uap_a, R0, RES_H_IUS);\r\nzssync(uap_a);\r\nif (r3 & CHAEXT)\r\npmz_status_handle(uap_a);\r\nif (r3 & CHARxIP)\r\npush = pmz_receive_chars(uap_a);\r\nif (r3 & CHATxIP)\r\npmz_transmit_chars(uap_a);\r\nrc = IRQ_HANDLED;\r\n}\r\nskip_a:\r\nspin_unlock(&uap_a->port.lock);\r\nif (push)\r\ntty_flip_buffer_push(&uap->port.state->port);\r\nif (!uap_b)\r\ngoto out;\r\nspin_lock(&uap_b->port.lock);\r\npush = false;\r\nif (r3 & (CHBEXT | CHBTxIP | CHBRxIP)) {\r\nif (!ZS_IS_OPEN(uap_b)) {\r\npmz_debug("ChanB interrupt while not open !\n");\r\ngoto skip_b;\r\n}\r\nwrite_zsreg(uap_b, R0, RES_H_IUS);\r\nzssync(uap_b);\r\nif (r3 & CHBEXT)\r\npmz_status_handle(uap_b);\r\nif (r3 & CHBRxIP)\r\npush = pmz_receive_chars(uap_b);\r\nif (r3 & CHBTxIP)\r\npmz_transmit_chars(uap_b);\r\nrc = IRQ_HANDLED;\r\n}\r\nskip_b:\r\nspin_unlock(&uap_b->port.lock);\r\nif (push)\r\ntty_flip_buffer_push(&uap->port.state->port);\r\nout:\r\nreturn rc;\r\n}\r\nstatic inline u8 pmz_peek_status(struct uart_pmac_port *uap)\r\n{\r\nunsigned long flags;\r\nu8 status;\r\nspin_lock_irqsave(&uap->port.lock, flags);\r\nstatus = read_zsreg(uap, R0);\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\nreturn status;\r\n}\r\nstatic unsigned int pmz_tx_empty(struct uart_port *port)\r\n{\r\nunsigned char status;\r\nstatus = pmz_peek_status(to_pmz(port));\r\nif (status & Tx_BUF_EMP)\r\nreturn TIOCSER_TEMT;\r\nreturn 0;\r\n}\r\nstatic void pmz_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_pmac_port *uap = to_pmz(port);\r\nunsigned char set_bits, clear_bits;\r\nif (ZS_IS_IRDA(uap))\r\nreturn;\r\nif (!(ZS_IS_OPEN(uap) || ZS_IS_CONS(uap)))\r\nreturn;\r\nset_bits = clear_bits = 0;\r\nif (ZS_IS_INTMODEM(uap)) {\r\nif (mctrl & TIOCM_RTS)\r\nset_bits |= RTS;\r\nelse\r\nclear_bits |= RTS;\r\n}\r\nif (mctrl & TIOCM_DTR)\r\nset_bits |= DTR;\r\nelse\r\nclear_bits |= DTR;\r\nuap->curregs[R5] |= set_bits;\r\nuap->curregs[R5] &= ~clear_bits;\r\nwrite_zsreg(uap, R5, uap->curregs[R5]);\r\npmz_debug("pmz_set_mctrl: set bits: %x, clear bits: %x -> %x\n",\r\nset_bits, clear_bits, uap->curregs[R5]);\r\nzssync(uap);\r\n}\r\nstatic unsigned int pmz_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_pmac_port *uap = to_pmz(port);\r\nunsigned char status;\r\nunsigned int ret;\r\nstatus = read_zsreg(uap, R0);\r\nret = 0;\r\nif (status & DCD)\r\nret |= TIOCM_CAR;\r\nif (status & SYNC_HUNT)\r\nret |= TIOCM_DSR;\r\nif (!(status & CTS))\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void pmz_stop_tx(struct uart_port *port)\r\n{\r\nto_pmz(port)->flags |= PMACZILOG_FLAG_TX_STOPPED;\r\n}\r\nstatic void pmz_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_pmac_port *uap = to_pmz(port);\r\nunsigned char status;\r\npmz_debug("pmz: start_tx()\n");\r\nuap->flags |= PMACZILOG_FLAG_TX_ACTIVE;\r\nuap->flags &= ~PMACZILOG_FLAG_TX_STOPPED;\r\nstatus = read_zsreg(uap, R0);\r\nif (!(status & Tx_BUF_EMP))\r\nreturn;\r\nif (port->x_char) {\r\nwrite_zsdata(uap, port->x_char);\r\nzssync(uap);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\n} else {\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nwrite_zsdata(uap, xmit->buf[xmit->tail]);\r\nzssync(uap);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&uap->port);\r\n}\r\npmz_debug("pmz: start_tx() done.\n");\r\n}\r\nstatic void pmz_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_pmac_port *uap = to_pmz(port);\r\npmz_debug("pmz: stop_rx()()\n");\r\nuap->curregs[R1] &= ~RxINT_MASK;\r\npmz_maybe_update_regs(uap);\r\npmz_debug("pmz: stop_rx() done.\n");\r\n}\r\nstatic void pmz_enable_ms(struct uart_port *port)\r\n{\r\nstruct uart_pmac_port *uap = to_pmz(port);\r\nunsigned char new_reg;\r\nif (ZS_IS_IRDA(uap))\r\nreturn;\r\nnew_reg = uap->curregs[R15] | (DCDIE | SYNCIE | CTSIE);\r\nif (new_reg != uap->curregs[R15]) {\r\nuap->curregs[R15] = new_reg;\r\nwrite_zsreg(uap, R15, uap->curregs[R15]);\r\n}\r\n}\r\nstatic void pmz_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_pmac_port *uap = to_pmz(port);\r\nunsigned char set_bits, clear_bits, new_reg;\r\nunsigned long flags;\r\nset_bits = clear_bits = 0;\r\nif (break_state)\r\nset_bits |= SND_BRK;\r\nelse\r\nclear_bits |= SND_BRK;\r\nspin_lock_irqsave(&port->lock, flags);\r\nnew_reg = (uap->curregs[R5] | set_bits) & ~clear_bits;\r\nif (new_reg != uap->curregs[R5]) {\r\nuap->curregs[R5] = new_reg;\r\nwrite_zsreg(uap, R5, uap->curregs[R5]);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int pmz_set_scc_power(struct uart_pmac_port *uap, int state)\r\n{\r\nint delay = 0;\r\nint rc;\r\nif (state) {\r\nrc = pmac_call_feature(\r\nPMAC_FTR_SCC_ENABLE, uap->node, uap->port_type, 1);\r\npmz_debug("port power on result: %d\n", rc);\r\nif (ZS_IS_INTMODEM(uap)) {\r\nrc = pmac_call_feature(\r\nPMAC_FTR_MODEM_ENABLE, uap->node, 0, 1);\r\ndelay = 2500;\r\npmz_debug("modem power result: %d\n", rc);\r\n}\r\n} else {\r\nif (ZS_IS_INTMODEM(uap)) {\r\nrc = pmac_call_feature(\r\nPMAC_FTR_MODEM_ENABLE, uap->node, 0, 0);\r\npmz_debug("port power off result: %d\n", rc);\r\n}\r\npmac_call_feature(PMAC_FTR_SCC_ENABLE, uap->node, uap->port_type, 0);\r\n}\r\nreturn delay;\r\n}\r\nstatic int pmz_set_scc_power(struct uart_pmac_port *uap, int state)\r\n{\r\nreturn 0;\r\n}\r\nstatic void pmz_fix_zero_bug_scc(struct uart_pmac_port *uap)\r\n{\r\nwrite_zsreg(uap, 9, ZS_IS_CHANNEL_A(uap) ? CHRA : CHRB);\r\nzssync(uap);\r\nudelay(10);\r\nwrite_zsreg(uap, 9, (ZS_IS_CHANNEL_A(uap) ? CHRA : CHRB) | NV);\r\nzssync(uap);\r\nwrite_zsreg(uap, 4, X1CLK | MONSYNC);\r\nwrite_zsreg(uap, 3, Rx8);\r\nwrite_zsreg(uap, 5, Tx8 | RTS);\r\nwrite_zsreg(uap, 9, NV);\r\nwrite_zsreg(uap, 11, RCBR | TCBR);\r\nwrite_zsreg(uap, 12, 0);\r\nwrite_zsreg(uap, 13, 0);\r\nwrite_zsreg(uap, 14, (LOOPBAK | BRSRC));\r\nwrite_zsreg(uap, 14, (LOOPBAK | BRSRC | BRENAB));\r\nwrite_zsreg(uap, 3, Rx8 | RxENABLE);\r\nwrite_zsreg(uap, 0, RES_EXT_INT);\r\nwrite_zsreg(uap, 0, RES_EXT_INT);\r\nwrite_zsreg(uap, 0, RES_EXT_INT);\r\nwrite_zsreg(uap, 9, NV);\r\nwrite_zsreg(uap, 4, X16CLK | SB_MASK);\r\nwrite_zsreg(uap, 3, Rx8);\r\nwhile (read_zsreg(uap, 0) & Rx_CH_AV) {\r\n(void)read_zsreg(uap, 8);\r\nwrite_zsreg(uap, 0, RES_EXT_INT);\r\nwrite_zsreg(uap, 0, ERR_RES);\r\n}\r\n}\r\nstatic int __pmz_startup(struct uart_pmac_port *uap)\r\n{\r\nint pwr_delay = 0;\r\nmemset(&uap->curregs, 0, sizeof(uap->curregs));\r\npwr_delay = pmz_set_scc_power(uap, 1);\r\npmz_fix_zero_bug_scc(uap);\r\nuap->curregs[R9] = 0;\r\nwrite_zsreg(uap, 9, ZS_IS_CHANNEL_A(uap) ? CHRA : CHRB);\r\nzssync(uap);\r\nudelay(10);\r\nwrite_zsreg(uap, 9, 0);\r\nzssync(uap);\r\nwrite_zsreg(uap, R1, 0);\r\nwrite_zsreg(uap, R0, ERR_RES);\r\nwrite_zsreg(uap, R0, ERR_RES);\r\nwrite_zsreg(uap, R0, RES_H_IUS);\r\nwrite_zsreg(uap, R0, RES_H_IUS);\r\nuap->curregs[R4] = X16CLK | SB1;\r\nuap->curregs[R3] = Rx8;\r\nuap->curregs[R5] = Tx8 | RTS;\r\nif (!ZS_IS_IRDA(uap))\r\nuap->curregs[R5] |= DTR;\r\nuap->curregs[R12] = 0;\r\nuap->curregs[R13] = 0;\r\nuap->curregs[R14] = BRENAB;\r\nuap->curregs[R15] = BRKIE;\r\nuap->curregs[R9] |= NV | MIE;\r\npmz_load_zsregs(uap, uap->curregs);\r\nwrite_zsreg(uap, R3, uap->curregs[R3] |= RxENABLE);\r\nwrite_zsreg(uap, R5, uap->curregs[R5] |= TxENABLE);\r\nuap->prev_status = read_zsreg(uap, R0);\r\nreturn pwr_delay;\r\n}\r\nstatic void pmz_irda_reset(struct uart_pmac_port *uap)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&uap->port.lock, flags);\r\nuap->curregs[R5] |= DTR;\r\nwrite_zsreg(uap, R5, uap->curregs[R5]);\r\nzssync(uap);\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\nmsleep(110);\r\nspin_lock_irqsave(&uap->port.lock, flags);\r\nuap->curregs[R5] &= ~DTR;\r\nwrite_zsreg(uap, R5, uap->curregs[R5]);\r\nzssync(uap);\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\nmsleep(10);\r\n}\r\nstatic int pmz_startup(struct uart_port *port)\r\n{\r\nstruct uart_pmac_port *uap = to_pmz(port);\r\nunsigned long flags;\r\nint pwr_delay = 0;\r\npmz_debug("pmz: startup()\n");\r\nuap->flags |= PMACZILOG_FLAG_IS_OPEN;\r\nif (!ZS_IS_CONS(uap)) {\r\nspin_lock_irqsave(&port->lock, flags);\r\npwr_delay = __pmz_startup(uap);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nsprintf(uap->irq_name, PMACZILOG_NAME"%d", uap->port.line);\r\nif (request_irq(uap->port.irq, pmz_interrupt, IRQF_SHARED,\r\nuap->irq_name, uap)) {\r\npmz_error("Unable to register zs interrupt handler.\n");\r\npmz_set_scc_power(uap, 0);\r\nreturn -ENXIO;\r\n}\r\nif (pwr_delay != 0) {\r\npmz_debug("pmz: delaying %d ms\n", pwr_delay);\r\nmsleep(pwr_delay);\r\n}\r\nif (ZS_IS_IRDA(uap))\r\npmz_irda_reset(uap);\r\nspin_lock_irqsave(&port->lock, flags);\r\npmz_interrupt_control(uap, 1);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\npmz_debug("pmz: startup() done.\n");\r\nreturn 0;\r\n}\r\nstatic void pmz_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_pmac_port *uap = to_pmz(port);\r\nunsigned long flags;\r\npmz_debug("pmz: shutdown()\n");\r\nspin_lock_irqsave(&port->lock, flags);\r\npmz_interrupt_control(uap, 0);\r\nif (!ZS_IS_CONS(uap)) {\r\nuap->curregs[R3] &= ~RxENABLE;\r\nuap->curregs[R5] &= ~TxENABLE;\r\nuap->curregs[R5] &= ~SND_BRK;\r\npmz_maybe_update_regs(uap);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nfree_irq(uap->port.irq, uap);\r\nspin_lock_irqsave(&port->lock, flags);\r\nuap->flags &= ~PMACZILOG_FLAG_IS_OPEN;\r\nif (!ZS_IS_CONS(uap))\r\npmz_set_scc_power(uap, 0);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\npmz_debug("pmz: shutdown() done.\n");\r\n}\r\nstatic void pmz_convert_to_zs(struct uart_pmac_port *uap, unsigned int cflag,\r\nunsigned int iflag, unsigned long baud)\r\n{\r\nint brg;\r\nif (baud >= 115200 && ZS_IS_IRDA(uap)) {\r\nuap->curregs[R4] = X1CLK;\r\nuap->curregs[R11] = RCTRxCP | TCTRxCP;\r\nuap->curregs[R14] = 0;\r\nuap->curregs[R12] = 0;\r\nuap->curregs[R13] = 0;\r\nuap->flags |= PMACZILOG_FLAG_IS_EXTCLK;\r\n} else {\r\nswitch (baud) {\r\ncase ZS_CLOCK/16:\r\nuap->curregs[R4] = X16CLK;\r\nuap->curregs[R11] = 0;\r\nuap->curregs[R14] = 0;\r\nbreak;\r\ncase ZS_CLOCK/32:\r\nuap->curregs[R4] = X32CLK;\r\nuap->curregs[R11] = 0;\r\nuap->curregs[R14] = 0;\r\nbreak;\r\ndefault:\r\nuap->curregs[R4] = X16CLK;\r\nuap->curregs[R11] = TCBR | RCBR;\r\nbrg = BPS_TO_BRG(baud, ZS_CLOCK / 16);\r\nuap->curregs[R12] = (brg & 255);\r\nuap->curregs[R13] = ((brg >> 8) & 255);\r\nuap->curregs[R14] = BRENAB;\r\n}\r\nuap->flags &= ~PMACZILOG_FLAG_IS_EXTCLK;\r\n}\r\nuap->curregs[3] &= ~RxN_MASK;\r\nuap->curregs[5] &= ~TxN_MASK;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nuap->curregs[3] |= Rx5;\r\nuap->curregs[5] |= Tx5;\r\nuap->parity_mask = 0x1f;\r\nbreak;\r\ncase CS6:\r\nuap->curregs[3] |= Rx6;\r\nuap->curregs[5] |= Tx6;\r\nuap->parity_mask = 0x3f;\r\nbreak;\r\ncase CS7:\r\nuap->curregs[3] |= Rx7;\r\nuap->curregs[5] |= Tx7;\r\nuap->parity_mask = 0x7f;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nuap->curregs[3] |= Rx8;\r\nuap->curregs[5] |= Tx8;\r\nuap->parity_mask = 0xff;\r\nbreak;\r\n}\r\nuap->curregs[4] &= ~(SB_MASK);\r\nif (cflag & CSTOPB)\r\nuap->curregs[4] |= SB2;\r\nelse\r\nuap->curregs[4] |= SB1;\r\nif (cflag & PARENB)\r\nuap->curregs[4] |= PAR_ENAB;\r\nelse\r\nuap->curregs[4] &= ~PAR_ENAB;\r\nif (!(cflag & PARODD))\r\nuap->curregs[4] |= PAR_EVEN;\r\nelse\r\nuap->curregs[4] &= ~PAR_EVEN;\r\nuap->port.read_status_mask = Rx_OVR;\r\nif (iflag & INPCK)\r\nuap->port.read_status_mask |= CRC_ERR | PAR_ERR;\r\nif (iflag & (BRKINT | PARMRK))\r\nuap->port.read_status_mask |= BRK_ABRT;\r\nuap->port.ignore_status_mask = 0;\r\nif (iflag & IGNPAR)\r\nuap->port.ignore_status_mask |= CRC_ERR | PAR_ERR;\r\nif (iflag & IGNBRK) {\r\nuap->port.ignore_status_mask |= BRK_ABRT;\r\nif (iflag & IGNPAR)\r\nuap->port.ignore_status_mask |= Rx_OVR;\r\n}\r\nif ((cflag & CREAD) == 0)\r\nuap->port.ignore_status_mask = 0xff;\r\n}\r\nstatic void pmz_irda_setup(struct uart_pmac_port *uap, unsigned long *baud)\r\n{\r\nu8 cmdbyte;\r\nint t, version;\r\nswitch (*baud) {\r\ncase 2400:\r\ncmdbyte = 0x53;\r\nbreak;\r\ncase 4800:\r\ncmdbyte = 0x52;\r\nbreak;\r\ncase 9600:\r\ncmdbyte = 0x51;\r\nbreak;\r\ncase 19200:\r\ncmdbyte = 0x50;\r\nbreak;\r\ncase 38400:\r\ncmdbyte = 0x4f;\r\nbreak;\r\ncase 57600:\r\ncmdbyte = 0x4e;\r\nbreak;\r\ncase 115200:\r\ncmdbyte = 0x4d;\r\nbreak;\r\ncase 1152000:\r\ncmdbyte = 0;\r\nbreak;\r\ncase 4000000:\r\ncmdbyte = 0;\r\nbreak;\r\ndefault:\r\ncmdbyte = 0x51;\r\n*baud = 9600;\r\nbreak;\r\n}\r\nt = 10000;\r\nwhile ((read_zsreg(uap, R0) & Tx_BUF_EMP) == 0\r\n|| (read_zsreg(uap, R1) & ALL_SNT) == 0) {\r\nif (--t <= 0) {\r\npmz_error("transmitter didn't drain\n");\r\nreturn;\r\n}\r\nudelay(10);\r\n}\r\nt = 100;\r\n(void)read_zsdata(uap);\r\n(void)read_zsdata(uap);\r\n(void)read_zsdata(uap);\r\nmdelay(10);\r\nwhile (read_zsreg(uap, R0) & Rx_CH_AV) {\r\nread_zsdata(uap);\r\nmdelay(10);\r\nif (--t <= 0) {\r\npmz_error("receiver didn't drain\n");\r\nreturn;\r\n}\r\n}\r\nuap->curregs[R5] |= DTR;\r\nwrite_zsreg(uap, R5, uap->curregs[R5]);\r\nzssync(uap);\r\nmdelay(1);\r\npmz_convert_to_zs(uap, CS8, 0, 19200);\r\npmz_load_zsregs(uap, uap->curregs);\r\nmdelay(1);\r\nwrite_zsdata(uap, 1);\r\nt = 5000;\r\nwhile ((read_zsreg(uap, R0) & Rx_CH_AV) == 0) {\r\nif (--t <= 0) {\r\npmz_error("irda_setup timed out on get_version byte\n");\r\ngoto out;\r\n}\r\nudelay(10);\r\n}\r\nversion = read_zsdata(uap);\r\nif (version < 4) {\r\npmz_info("IrDA: dongle version %d not supported\n", version);\r\ngoto out;\r\n}\r\nwrite_zsdata(uap, cmdbyte);\r\nt = 5000;\r\nwhile ((read_zsreg(uap, R0) & Rx_CH_AV) == 0) {\r\nif (--t <= 0) {\r\npmz_error("irda_setup timed out on speed mode byte\n");\r\ngoto out;\r\n}\r\nudelay(10);\r\n}\r\nt = read_zsdata(uap);\r\nif (t != cmdbyte)\r\npmz_error("irda_setup speed mode byte = %x (%x)\n", t, cmdbyte);\r\npmz_info("IrDA setup for %ld bps, dongle version: %d\n",\r\n*baud, version);\r\n(void)read_zsdata(uap);\r\n(void)read_zsdata(uap);\r\n(void)read_zsdata(uap);\r\nout:\r\nuap->curregs[R5] &= ~DTR;\r\nwrite_zsreg(uap, R5, uap->curregs[R5]);\r\nzssync(uap);\r\n(void)read_zsdata(uap);\r\n(void)read_zsdata(uap);\r\n(void)read_zsdata(uap);\r\n}\r\nstatic void __pmz_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_pmac_port *uap = to_pmz(port);\r\nunsigned long baud;\r\npmz_debug("pmz: set_termios()\n");\r\nmemcpy(&uap->termios_cache, termios, sizeof(struct ktermios));\r\nif (ZS_IS_IRDA(uap)) {\r\nbaud = uart_get_baud_rate(port, termios, old, 1200, 4000000);\r\npmz_debug("pmz: switch IRDA to %ld bauds\n", baud);\r\npmz_irda_setup(uap, &baud);\r\npmz_convert_to_zs(uap, termios->c_cflag, termios->c_iflag, baud);\r\npmz_load_zsregs(uap, uap->curregs);\r\nzssync(uap);\r\n} else {\r\nbaud = uart_get_baud_rate(port, termios, old, 1200, 230400);\r\npmz_convert_to_zs(uap, termios->c_cflag, termios->c_iflag, baud);\r\nif (UART_ENABLE_MS(&uap->port, termios->c_cflag)) {\r\nuap->curregs[R15] |= DCDIE | SYNCIE | CTSIE;\r\nuap->flags |= PMACZILOG_FLAG_MODEM_STATUS;\r\n} else {\r\nuap->curregs[R15] &= ~(DCDIE | SYNCIE | CTSIE);\r\nuap->flags &= ~PMACZILOG_FLAG_MODEM_STATUS;\r\n}\r\npmz_maybe_update_regs(uap);\r\n}\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\npmz_debug("pmz: set_termios() done.\n");\r\n}\r\nstatic void pmz_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_pmac_port *uap = to_pmz(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\npmz_interrupt_control(uap, 0);\r\n__pmz_set_termios(port, termios, old);\r\nif (ZS_IS_OPEN(uap))\r\npmz_interrupt_control(uap, 1);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *pmz_type(struct uart_port *port)\r\n{\r\nstruct uart_pmac_port *uap = to_pmz(port);\r\nif (ZS_IS_IRDA(uap))\r\nreturn "Z85c30 ESCC - Infrared port";\r\nelse if (ZS_IS_INTMODEM(uap))\r\nreturn "Z85c30 ESCC - Internal modem";\r\nreturn "Z85c30 ESCC - Serial port";\r\n}\r\nstatic void pmz_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int pmz_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void pmz_config_port(struct uart_port *port, int flags)\r\n{\r\n}\r\nstatic int pmz_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int pmz_poll_get_char(struct uart_port *port)\r\n{\r\nstruct uart_pmac_port *uap = (struct uart_pmac_port *)port;\r\nint tries = 2;\r\nwhile (tries) {\r\nif ((read_zsreg(uap, R0) & Rx_CH_AV) != 0)\r\nreturn read_zsdata(uap);\r\nif (tries--)\r\nudelay(5);\r\n}\r\nreturn NO_POLL_CHAR;\r\n}\r\nstatic void pmz_poll_put_char(struct uart_port *port, unsigned char c)\r\n{\r\nstruct uart_pmac_port *uap = (struct uart_pmac_port *)port;\r\nwhile ((read_zsreg(uap, R0) & Tx_BUF_EMP) == 0)\r\nudelay(5);\r\nwrite_zsdata(uap, c);\r\n}\r\nstatic int __init pmz_init_port(struct uart_pmac_port *uap)\r\n{\r\nstruct device_node *np = uap->node;\r\nconst char *conn;\r\nconst struct slot_names_prop {\r\nint count;\r\nchar name[1];\r\n} *slots;\r\nint len;\r\nstruct resource r_ports, r_rxdma, r_txdma;\r\nif (of_address_to_resource(np, 0, &r_ports))\r\nreturn -ENODEV;\r\nuap->port.mapbase = r_ports.start;\r\nuap->port.membase = ioremap(uap->port.mapbase, 0x1000);\r\nuap->control_reg = uap->port.membase;\r\nuap->data_reg = uap->control_reg + 0x10;\r\n#ifdef HAS_DBDMA\r\nif (of_address_to_resource(np, 1, &r_txdma) == 0 &&\r\nof_address_to_resource(np, 2, &r_rxdma) == 0)\r\nuap->flags |= PMACZILOG_FLAG_HAS_DMA;\r\n#else\r\nmemset(&r_txdma, 0, sizeof(struct resource));\r\nmemset(&r_rxdma, 0, sizeof(struct resource));\r\n#endif\r\nif (ZS_HAS_DMA(uap)) {\r\nuap->tx_dma_regs = ioremap(r_txdma.start, 0x100);\r\nif (uap->tx_dma_regs == NULL) {\r\nuap->flags &= ~PMACZILOG_FLAG_HAS_DMA;\r\ngoto no_dma;\r\n}\r\nuap->rx_dma_regs = ioremap(r_rxdma.start, 0x100);\r\nif (uap->rx_dma_regs == NULL) {\r\niounmap(uap->tx_dma_regs);\r\nuap->tx_dma_regs = NULL;\r\nuap->flags &= ~PMACZILOG_FLAG_HAS_DMA;\r\ngoto no_dma;\r\n}\r\nuap->tx_dma_irq = irq_of_parse_and_map(np, 1);\r\nuap->rx_dma_irq = irq_of_parse_and_map(np, 2);\r\n}\r\nno_dma:\r\nif (of_device_is_compatible(np, "cobalt"))\r\nuap->flags |= PMACZILOG_FLAG_IS_INTMODEM;\r\nconn = of_get_property(np, "AAPL,connector", &len);\r\nif (conn && (strcmp(conn, "infrared") == 0))\r\nuap->flags |= PMACZILOG_FLAG_IS_IRDA;\r\nuap->port_type = PMAC_SCC_ASYNC;\r\nslots = of_get_property(np, "slot-names", &len);\r\nif (slots && slots->count > 0) {\r\nif (strcmp(slots->name, "IrDA") == 0)\r\nuap->flags |= PMACZILOG_FLAG_IS_IRDA;\r\nelse if (strcmp(slots->name, "Modem") == 0)\r\nuap->flags |= PMACZILOG_FLAG_IS_INTMODEM;\r\n}\r\nif (ZS_IS_IRDA(uap))\r\nuap->port_type = PMAC_SCC_IRDA;\r\nif (ZS_IS_INTMODEM(uap)) {\r\nstruct device_node* i2c_modem =\r\nof_find_node_by_name(NULL, "i2c-modem");\r\nif (i2c_modem) {\r\nconst char* mid =\r\nof_get_property(i2c_modem, "modem-id", NULL);\r\nif (mid) switch(*mid) {\r\ncase 0x04 :\r\ncase 0x05 :\r\ncase 0x07 :\r\ncase 0x08 :\r\ncase 0x0b :\r\ncase 0x0c :\r\nuap->port_type = PMAC_SCC_I2S1;\r\n}\r\nprintk(KERN_INFO "pmac_zilog: i2c-modem detected, id: %d\n",\r\nmid ? (*mid) : 0);\r\nof_node_put(i2c_modem);\r\n} else {\r\nprintk(KERN_INFO "pmac_zilog: serial modem detected\n");\r\n}\r\n}\r\nuap->port.iotype = UPIO_MEM;\r\nuap->port.irq = irq_of_parse_and_map(np, 0);\r\nuap->port.uartclk = ZS_CLOCK;\r\nuap->port.fifosize = 1;\r\nuap->port.ops = &pmz_pops;\r\nuap->port.type = PORT_PMAC_ZILOG;\r\nuap->port.flags = 0;\r\nif (uap->port.irq == 0 &&\r\nnp->parent && np->parent->parent &&\r\nof_device_is_compatible(np->parent->parent, "gatwick")) {\r\nuap->port.irq = irq_create_mapping(NULL, 64 + 15);\r\nuap->tx_dma_irq = irq_create_mapping(NULL, 64 + 4);\r\nuap->rx_dma_irq = irq_create_mapping(NULL, 64 + 5);\r\n}\r\npmz_convert_to_zs(uap, CS8, 0, 9600);\r\nreturn 0;\r\n}\r\nstatic void pmz_dispose_port(struct uart_pmac_port *uap)\r\n{\r\nstruct device_node *np;\r\nnp = uap->node;\r\niounmap(uap->rx_dma_regs);\r\niounmap(uap->tx_dma_regs);\r\niounmap(uap->control_reg);\r\nuap->node = NULL;\r\nof_node_put(np);\r\nmemset(uap, 0, sizeof(struct uart_pmac_port));\r\n}\r\nstatic int pmz_attach(struct macio_dev *mdev, const struct of_device_id *match)\r\n{\r\nstruct uart_pmac_port *uap;\r\nint i;\r\nfor (i = 0; i < MAX_ZS_PORTS; i++)\r\nif (pmz_ports[i].node == mdev->ofdev.dev.of_node)\r\nbreak;\r\nif (i >= MAX_ZS_PORTS)\r\nreturn -ENODEV;\r\nuap = &pmz_ports[i];\r\nuap->dev = mdev;\r\nuap->port.dev = &mdev->ofdev.dev;\r\ndev_set_drvdata(&mdev->ofdev.dev, uap);\r\nif (macio_request_resources(uap->dev, "pmac_zilog"))\r\nprintk(KERN_WARNING "%s: Failed to request resource"\r\n", port still active\n",\r\nuap->node->name);\r\nelse\r\nuap->flags |= PMACZILOG_FLAG_RSRC_REQUESTED;\r\nreturn uart_add_one_port(&pmz_uart_reg, &uap->port);\r\n}\r\nstatic int pmz_detach(struct macio_dev *mdev)\r\n{\r\nstruct uart_pmac_port *uap = dev_get_drvdata(&mdev->ofdev.dev);\r\nif (!uap)\r\nreturn -ENODEV;\r\nuart_remove_one_port(&pmz_uart_reg, &uap->port);\r\nif (uap->flags & PMACZILOG_FLAG_RSRC_REQUESTED) {\r\nmacio_release_resources(uap->dev);\r\nuap->flags &= ~PMACZILOG_FLAG_RSRC_REQUESTED;\r\n}\r\ndev_set_drvdata(&mdev->ofdev.dev, NULL);\r\nuap->dev = NULL;\r\nuap->port.dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int pmz_suspend(struct macio_dev *mdev, pm_message_t pm_state)\r\n{\r\nstruct uart_pmac_port *uap = dev_get_drvdata(&mdev->ofdev.dev);\r\nif (uap == NULL) {\r\nprintk("HRM... pmz_suspend with NULL uap\n");\r\nreturn 0;\r\n}\r\nuart_suspend_port(&pmz_uart_reg, &uap->port);\r\nreturn 0;\r\n}\r\nstatic int pmz_resume(struct macio_dev *mdev)\r\n{\r\nstruct uart_pmac_port *uap = dev_get_drvdata(&mdev->ofdev.dev);\r\nif (uap == NULL)\r\nreturn 0;\r\nuart_resume_port(&pmz_uart_reg, &uap->port);\r\nreturn 0;\r\n}\r\nstatic int __init pmz_probe(void)\r\n{\r\nstruct device_node *node_p, *node_a, *node_b, *np;\r\nint count = 0;\r\nint rc;\r\nnode_p = of_find_node_by_name(NULL, "escc");\r\nwhile (node_p) {\r\nnode_a = node_b = NULL;\r\nfor (np = NULL; (np = of_get_next_child(node_p, np)) != NULL;) {\r\nif (strncmp(np->name, "ch-a", 4) == 0)\r\nnode_a = of_node_get(np);\r\nelse if (strncmp(np->name, "ch-b", 4) == 0)\r\nnode_b = of_node_get(np);\r\n}\r\nif (!node_a && !node_b) {\r\nof_node_put(node_a);\r\nof_node_put(node_b);\r\nprintk(KERN_ERR "pmac_zilog: missing node %c for escc %s\n",\r\n(!node_a) ? 'a' : 'b', node_p->full_name);\r\ngoto next;\r\n}\r\nif (node_b != NULL) {\r\npmz_ports[count].mate = &pmz_ports[count+1];\r\npmz_ports[count+1].mate = &pmz_ports[count];\r\n}\r\npmz_ports[count].flags = PMACZILOG_FLAG_IS_CHANNEL_A;\r\npmz_ports[count].node = node_a;\r\npmz_ports[count+1].node = node_b;\r\npmz_ports[count].port.line = count;\r\npmz_ports[count+1].port.line = count+1;\r\nrc = pmz_init_port(&pmz_ports[count]);\r\nif (rc == 0 && node_b != NULL)\r\nrc = pmz_init_port(&pmz_ports[count+1]);\r\nif (rc != 0) {\r\nof_node_put(node_a);\r\nof_node_put(node_b);\r\nmemset(&pmz_ports[count], 0, sizeof(struct uart_pmac_port));\r\nmemset(&pmz_ports[count+1], 0, sizeof(struct uart_pmac_port));\r\ngoto next;\r\n}\r\ncount += 2;\r\nnext:\r\nnode_p = of_find_node_by_name(node_p, "escc");\r\n}\r\npmz_ports_count = count;\r\nreturn 0;\r\n}\r\nstatic int __init pmz_init_port(struct uart_pmac_port *uap)\r\n{\r\nstruct resource *r_ports;\r\nint irq;\r\nr_ports = platform_get_resource(uap->pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(uap->pdev, 0);\r\nif (!r_ports || !irq)\r\nreturn -ENODEV;\r\nuap->port.mapbase = r_ports->start;\r\nuap->port.membase = (unsigned char __iomem *) r_ports->start;\r\nuap->port.iotype = UPIO_MEM;\r\nuap->port.irq = irq;\r\nuap->port.uartclk = ZS_CLOCK;\r\nuap->port.fifosize = 1;\r\nuap->port.ops = &pmz_pops;\r\nuap->port.type = PORT_PMAC_ZILOG;\r\nuap->port.flags = 0;\r\nuap->control_reg = uap->port.membase;\r\nuap->data_reg = uap->control_reg + 4;\r\nuap->port_type = 0;\r\npmz_convert_to_zs(uap, CS8, 0, 9600);\r\nreturn 0;\r\n}\r\nstatic int __init pmz_probe(void)\r\n{\r\nint err;\r\npmz_ports_count = 0;\r\npmz_ports[0].port.line = 0;\r\npmz_ports[0].flags = PMACZILOG_FLAG_IS_CHANNEL_A;\r\npmz_ports[0].pdev = &scc_a_pdev;\r\nerr = pmz_init_port(&pmz_ports[0]);\r\nif (err)\r\nreturn err;\r\npmz_ports_count++;\r\npmz_ports[0].mate = &pmz_ports[1];\r\npmz_ports[1].mate = &pmz_ports[0];\r\npmz_ports[1].port.line = 1;\r\npmz_ports[1].flags = 0;\r\npmz_ports[1].pdev = &scc_b_pdev;\r\nerr = pmz_init_port(&pmz_ports[1]);\r\nif (err)\r\nreturn err;\r\npmz_ports_count++;\r\nreturn 0;\r\n}\r\nstatic void pmz_dispose_port(struct uart_pmac_port *uap)\r\n{\r\nmemset(uap, 0, sizeof(struct uart_pmac_port));\r\n}\r\nstatic int __init pmz_attach(struct platform_device *pdev)\r\n{\r\nstruct uart_pmac_port *uap;\r\nint i;\r\nfor (i = 0; i < pmz_ports_count; i++)\r\nif (pmz_ports[i].pdev == pdev)\r\nbreak;\r\nif (i >= pmz_ports_count)\r\nreturn -ENODEV;\r\nuap = &pmz_ports[i];\r\nuap->port.dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, uap);\r\nreturn uart_add_one_port(&pmz_uart_reg, &uap->port);\r\n}\r\nstatic int __exit pmz_detach(struct platform_device *pdev)\r\n{\r\nstruct uart_pmac_port *uap = platform_get_drvdata(pdev);\r\nif (!uap)\r\nreturn -ENODEV;\r\nuart_remove_one_port(&pmz_uart_reg, &uap->port);\r\nuap->port.dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init pmz_register(void)\r\n{\r\npmz_uart_reg.nr = pmz_ports_count;\r\npmz_uart_reg.cons = PMACZILOG_CONSOLE;\r\nreturn uart_register_driver(&pmz_uart_reg);\r\n}\r\nstatic int __init init_pmz(void)\r\n{\r\nint rc, i;\r\nprintk(KERN_INFO "%s\n", version);\r\nif (pmz_ports_count == 0)\r\npmz_probe();\r\nif (pmz_ports_count == 0)\r\nreturn -ENODEV;\r\nrc = pmz_register();\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"pmac_zilog: Error registering serial device, disabling pmac_zilog.\n"\r\n"pmac_zilog: Did another serial driver already claim the minors?\n");\r\nfor (i=0; i < pmz_ports_count; i++)\r\npmz_dispose_port(&pmz_ports[i]);\r\nreturn rc;\r\n}\r\n#ifdef CONFIG_PPC_PMAC\r\nreturn macio_register_driver(&pmz_driver);\r\n#else\r\nreturn platform_driver_probe(&pmz_driver, pmz_attach);\r\n#endif\r\n}\r\nstatic void __exit exit_pmz(void)\r\n{\r\nint i;\r\n#ifdef CONFIG_PPC_PMAC\r\nmacio_unregister_driver(&pmz_driver);\r\n#else\r\nplatform_driver_unregister(&pmz_driver);\r\n#endif\r\nfor (i = 0; i < pmz_ports_count; i++) {\r\nstruct uart_pmac_port *uport = &pmz_ports[i];\r\n#ifdef CONFIG_PPC_PMAC\r\nif (uport->node != NULL)\r\npmz_dispose_port(uport);\r\n#else\r\nif (uport->pdev != NULL)\r\npmz_dispose_port(uport);\r\n#endif\r\n}\r\nuart_unregister_driver(&pmz_uart_reg);\r\n}\r\nstatic void pmz_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct uart_pmac_port *uap = (struct uart_pmac_port *)port;\r\nwhile ((read_zsreg(uap, R0) & Tx_BUF_EMP) == 0)\r\nudelay(5);\r\nwrite_zsdata(uap, ch);\r\n}\r\nstatic void pmz_console_write(struct console *con, const char *s, unsigned int count)\r\n{\r\nstruct uart_pmac_port *uap = &pmz_ports[con->index];\r\nunsigned long flags;\r\nspin_lock_irqsave(&uap->port.lock, flags);\r\nwrite_zsreg(uap, R1, uap->curregs[1] & ~TxINT_ENAB);\r\nwrite_zsreg(uap, R5, uap->curregs[5] | TxENABLE | RTS | DTR);\r\nuart_console_write(&uap->port, s, count, pmz_console_putchar);\r\nwrite_zsreg(uap, R1, uap->curregs[1]);\r\nspin_unlock_irqrestore(&uap->port.lock, flags);\r\n}\r\nstatic int __init pmz_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_pmac_port *uap;\r\nstruct uart_port *port;\r\nint baud = 38400;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nunsigned long pwr_delay;\r\nif (of_machine_is_compatible("RackMac1,1")\r\n|| of_machine_is_compatible("RackMac1,2")\r\n|| of_machine_is_compatible("MacRISC4"))\r\nbaud = 57600;\r\nif (co->index >= pmz_ports_count)\r\nco->index = 0;\r\nuap = &pmz_ports[co->index];\r\n#ifdef CONFIG_PPC_PMAC\r\nif (uap->node == NULL)\r\nreturn -ENODEV;\r\n#else\r\nif (uap->pdev == NULL)\r\nreturn -ENODEV;\r\n#endif\r\nport = &uap->port;\r\nuap->flags |= PMACZILOG_FLAG_IS_CONS;\r\nspin_lock_init(&port->lock);\r\npwr_delay = __pmz_startup(uap);\r\nif (pwr_delay)\r\nmdelay(pwr_delay);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init pmz_console_init(void)\r\n{\r\npmz_probe();\r\nif (pmz_ports_count == 0)\r\nreturn -ENODEV;\r\nregister_console(&pmz_console);\r\nreturn 0;\r\n}
