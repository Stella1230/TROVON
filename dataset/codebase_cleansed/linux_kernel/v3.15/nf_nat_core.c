inline const struct nf_nat_l3proto *\r\n__nf_nat_l3proto_find(u8 family)\r\n{\r\nreturn rcu_dereference(nf_nat_l3protos[family]);\r\n}\r\ninline const struct nf_nat_l4proto *\r\n__nf_nat_l4proto_find(u8 family, u8 protonum)\r\n{\r\nreturn rcu_dereference(nf_nat_l4protos[family][protonum]);\r\n}\r\nstatic void __nf_nat_decode_session(struct sk_buff *skb, struct flowi *fl)\r\n{\r\nconst struct nf_nat_l3proto *l3proto;\r\nconst struct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nenum ip_conntrack_dir dir;\r\nunsigned long statusbit;\r\nu8 family;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct == NULL)\r\nreturn;\r\nfamily = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.l3num;\r\nrcu_read_lock();\r\nl3proto = __nf_nat_l3proto_find(family);\r\nif (l3proto == NULL)\r\ngoto out;\r\ndir = CTINFO2DIR(ctinfo);\r\nif (dir == IP_CT_DIR_ORIGINAL)\r\nstatusbit = IPS_DST_NAT;\r\nelse\r\nstatusbit = IPS_SRC_NAT;\r\nl3proto->decode_session(skb, ct, dir, statusbit, fl);\r\nout:\r\nrcu_read_unlock();\r\n}\r\nint nf_xfrm_me_harder(struct sk_buff *skb, unsigned int family)\r\n{\r\nstruct flowi fl;\r\nunsigned int hh_len;\r\nstruct dst_entry *dst;\r\nint err;\r\nerr = xfrm_decode_session(skb, &fl, family);\r\nif (err < 0)\r\nreturn err;\r\ndst = skb_dst(skb);\r\nif (dst->xfrm)\r\ndst = ((struct xfrm_dst *)dst)->route;\r\ndst_hold(dst);\r\ndst = xfrm_lookup(dev_net(dst->dev), dst, &fl, skb->sk, 0);\r\nif (IS_ERR(dst))\r\nreturn PTR_ERR(dst);\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, dst);\r\nhh_len = skb_dst(skb)->dev->hard_header_len;\r\nif (skb_headroom(skb) < hh_len &&\r\npskb_expand_head(skb, hh_len - skb_headroom(skb), 0, GFP_ATOMIC))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic inline unsigned int\r\nhash_by_src(const struct net *net, u16 zone,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nunsigned int hash;\r\nhash = jhash2((u32 *)&tuple->src, sizeof(tuple->src) / sizeof(u32),\r\ntuple->dst.protonum ^ zone ^ nf_conntrack_hash_rnd);\r\nreturn ((u64)hash * net->ct.nat_htable_size) >> 32;\r\n}\r\nint\r\nnf_nat_used_tuple(const struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conn *ignored_conntrack)\r\n{\r\nstruct nf_conntrack_tuple reply;\r\nnf_ct_invert_tuplepr(&reply, tuple);\r\nreturn nf_conntrack_tuple_taken(&reply, ignored_conntrack);\r\n}\r\nstatic int in_range(const struct nf_nat_l3proto *l3proto,\r\nconst struct nf_nat_l4proto *l4proto,\r\nconst struct nf_conntrack_tuple *tuple,\r\nconst struct nf_nat_range *range)\r\n{\r\nif (range->flags & NF_NAT_RANGE_MAP_IPS &&\r\n!l3proto->in_range(tuple, range))\r\nreturn 0;\r\nif (!(range->flags & NF_NAT_RANGE_PROTO_SPECIFIED) ||\r\nl4proto->in_range(tuple, NF_NAT_MANIP_SRC,\r\n&range->min_proto, &range->max_proto))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nsame_src(const struct nf_conn *ct,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nconst struct nf_conntrack_tuple *t;\r\nt = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\r\nreturn (t->dst.protonum == tuple->dst.protonum &&\r\nnf_inet_addr_cmp(&t->src.u3, &tuple->src.u3) &&\r\nt->src.u.all == tuple->src.u.all);\r\n}\r\nstatic int\r\nfind_appropriate_src(struct net *net, u16 zone,\r\nconst struct nf_nat_l3proto *l3proto,\r\nconst struct nf_nat_l4proto *l4proto,\r\nconst struct nf_conntrack_tuple *tuple,\r\nstruct nf_conntrack_tuple *result,\r\nconst struct nf_nat_range *range)\r\n{\r\nunsigned int h = hash_by_src(net, zone, tuple);\r\nconst struct nf_conn_nat *nat;\r\nconst struct nf_conn *ct;\r\nhlist_for_each_entry_rcu(nat, &net->ct.nat_bysource[h], bysource) {\r\nct = nat->ct;\r\nif (same_src(ct, tuple) && nf_ct_zone(ct) == zone) {\r\nnf_ct_invert_tuplepr(result,\r\n&ct->tuplehash[IP_CT_DIR_REPLY].tuple);\r\nresult->dst = tuple->dst;\r\nif (in_range(l3proto, l4proto, result, range))\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nfind_best_ips_proto(u16 zone, struct nf_conntrack_tuple *tuple,\r\nconst struct nf_nat_range *range,\r\nconst struct nf_conn *ct,\r\nenum nf_nat_manip_type maniptype)\r\n{\r\nunion nf_inet_addr *var_ipp;\r\nunsigned int i, max;\r\nu32 minip, maxip, j, dist;\r\nbool full_range;\r\nif (!(range->flags & NF_NAT_RANGE_MAP_IPS))\r\nreturn;\r\nif (maniptype == NF_NAT_MANIP_SRC)\r\nvar_ipp = &tuple->src.u3;\r\nelse\r\nvar_ipp = &tuple->dst.u3;\r\nif (nf_inet_addr_cmp(&range->min_addr, &range->max_addr)) {\r\n*var_ipp = range->min_addr;\r\nreturn;\r\n}\r\nif (nf_ct_l3num(ct) == NFPROTO_IPV4)\r\nmax = sizeof(var_ipp->ip) / sizeof(u32) - 1;\r\nelse\r\nmax = sizeof(var_ipp->ip6) / sizeof(u32) - 1;\r\nj = jhash2((u32 *)&tuple->src.u3, sizeof(tuple->src.u3) / sizeof(u32),\r\nrange->flags & NF_NAT_RANGE_PERSISTENT ?\r\n0 : (__force u32)tuple->dst.u3.all[max] ^ zone);\r\nfull_range = false;\r\nfor (i = 0; i <= max; i++) {\r\nif (!full_range) {\r\nminip = ntohl((__force __be32)range->min_addr.all[i]);\r\nmaxip = ntohl((__force __be32)range->max_addr.all[i]);\r\ndist = maxip - minip + 1;\r\n} else {\r\nminip = 0;\r\ndist = ~0;\r\n}\r\nvar_ipp->all[i] = (__force __u32)\r\nhtonl(minip + (((u64)j * dist) >> 32));\r\nif (var_ipp->all[i] != range->max_addr.all[i])\r\nfull_range = true;\r\nif (!(range->flags & NF_NAT_RANGE_PERSISTENT))\r\nj ^= (__force u32)tuple->dst.u3.all[i];\r\n}\r\n}\r\nstatic void\r\nget_unique_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig_tuple,\r\nconst struct nf_nat_range *range,\r\nstruct nf_conn *ct,\r\nenum nf_nat_manip_type maniptype)\r\n{\r\nconst struct nf_nat_l3proto *l3proto;\r\nconst struct nf_nat_l4proto *l4proto;\r\nstruct net *net = nf_ct_net(ct);\r\nu16 zone = nf_ct_zone(ct);\r\nrcu_read_lock();\r\nl3proto = __nf_nat_l3proto_find(orig_tuple->src.l3num);\r\nl4proto = __nf_nat_l4proto_find(orig_tuple->src.l3num,\r\norig_tuple->dst.protonum);\r\nif (maniptype == NF_NAT_MANIP_SRC &&\r\n!(range->flags & NF_NAT_RANGE_PROTO_RANDOM_ALL)) {\r\nif (in_range(l3proto, l4proto, orig_tuple, range)) {\r\nif (!nf_nat_used_tuple(orig_tuple, ct)) {\r\n*tuple = *orig_tuple;\r\ngoto out;\r\n}\r\n} else if (find_appropriate_src(net, zone, l3proto, l4proto,\r\norig_tuple, tuple, range)) {\r\npr_debug("get_unique_tuple: Found current src map\n");\r\nif (!nf_nat_used_tuple(tuple, ct))\r\ngoto out;\r\n}\r\n}\r\n*tuple = *orig_tuple;\r\nfind_best_ips_proto(zone, tuple, range, ct, maniptype);\r\nif (!(range->flags & NF_NAT_RANGE_PROTO_RANDOM_ALL)) {\r\nif (range->flags & NF_NAT_RANGE_PROTO_SPECIFIED) {\r\nif (l4proto->in_range(tuple, maniptype,\r\n&range->min_proto,\r\n&range->max_proto) &&\r\n(range->min_proto.all == range->max_proto.all ||\r\n!nf_nat_used_tuple(tuple, ct)))\r\ngoto out;\r\n} else if (!nf_nat_used_tuple(tuple, ct)) {\r\ngoto out;\r\n}\r\n}\r\nl4proto->unique_tuple(l3proto, tuple, range, maniptype, ct);\r\nout:\r\nrcu_read_unlock();\r\n}\r\nunsigned int\r\nnf_nat_setup_info(struct nf_conn *ct,\r\nconst struct nf_nat_range *range,\r\nenum nf_nat_manip_type maniptype)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\nstruct nf_conntrack_tuple curr_tuple, new_tuple;\r\nstruct nf_conn_nat *nat;\r\nnat = nfct_nat(ct);\r\nif (!nat) {\r\nnat = nf_ct_ext_add(ct, NF_CT_EXT_NAT, GFP_ATOMIC);\r\nif (nat == NULL) {\r\npr_debug("failed to add NAT extension\n");\r\nreturn NF_ACCEPT;\r\n}\r\n}\r\nNF_CT_ASSERT(maniptype == NF_NAT_MANIP_SRC ||\r\nmaniptype == NF_NAT_MANIP_DST);\r\nBUG_ON(nf_nat_initialized(ct, maniptype));\r\nnf_ct_invert_tuplepr(&curr_tuple,\r\n&ct->tuplehash[IP_CT_DIR_REPLY].tuple);\r\nget_unique_tuple(&new_tuple, &curr_tuple, range, ct, maniptype);\r\nif (!nf_ct_tuple_equal(&new_tuple, &curr_tuple)) {\r\nstruct nf_conntrack_tuple reply;\r\nnf_ct_invert_tuplepr(&reply, &new_tuple);\r\nnf_conntrack_alter_reply(ct, &reply);\r\nif (maniptype == NF_NAT_MANIP_SRC)\r\nct->status |= IPS_SRC_NAT;\r\nelse\r\nct->status |= IPS_DST_NAT;\r\nif (nfct_help(ct))\r\nnfct_seqadj_ext_add(ct);\r\n}\r\nif (maniptype == NF_NAT_MANIP_SRC) {\r\nunsigned int srchash;\r\nsrchash = hash_by_src(net, nf_ct_zone(ct),\r\n&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);\r\nspin_lock_bh(&nf_nat_lock);\r\nnat = nfct_nat(ct);\r\nnat->ct = ct;\r\nhlist_add_head_rcu(&nat->bysource,\r\n&net->ct.nat_bysource[srchash]);\r\nspin_unlock_bh(&nf_nat_lock);\r\n}\r\nif (maniptype == NF_NAT_MANIP_DST)\r\nct->status |= IPS_DST_NAT_DONE;\r\nelse\r\nct->status |= IPS_SRC_NAT_DONE;\r\nreturn NF_ACCEPT;\r\n}\r\nstatic unsigned int\r\n__nf_nat_alloc_null_binding(struct nf_conn *ct, enum nf_nat_manip_type manip)\r\n{\r\nunion nf_inet_addr ip =\r\n(manip == NF_NAT_MANIP_SRC ?\r\nct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3 :\r\nct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3);\r\nstruct nf_nat_range range = {\r\n.flags = NF_NAT_RANGE_MAP_IPS,\r\n.min_addr = ip,\r\n.max_addr = ip,\r\n};\r\nreturn nf_nat_setup_info(ct, &range, manip);\r\n}\r\nunsigned int\r\nnf_nat_alloc_null_binding(struct nf_conn *ct, unsigned int hooknum)\r\n{\r\nreturn __nf_nat_alloc_null_binding(ct, HOOK2MANIP(hooknum));\r\n}\r\nunsigned int nf_nat_packet(struct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int hooknum,\r\nstruct sk_buff *skb)\r\n{\r\nconst struct nf_nat_l3proto *l3proto;\r\nconst struct nf_nat_l4proto *l4proto;\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nunsigned long statusbit;\r\nenum nf_nat_manip_type mtype = HOOK2MANIP(hooknum);\r\nif (mtype == NF_NAT_MANIP_SRC)\r\nstatusbit = IPS_SRC_NAT;\r\nelse\r\nstatusbit = IPS_DST_NAT;\r\nif (dir == IP_CT_DIR_REPLY)\r\nstatusbit ^= IPS_NAT_MASK;\r\nif (ct->status & statusbit) {\r\nstruct nf_conntrack_tuple target;\r\nnf_ct_invert_tuplepr(&target, &ct->tuplehash[!dir].tuple);\r\nl3proto = __nf_nat_l3proto_find(target.src.l3num);\r\nl4proto = __nf_nat_l4proto_find(target.src.l3num,\r\ntarget.dst.protonum);\r\nif (!l3proto->manip_pkt(skb, 0, l4proto, &target, mtype))\r\nreturn NF_DROP;\r\n}\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int nf_nat_proto_remove(struct nf_conn *i, void *data)\r\n{\r\nconst struct nf_nat_proto_clean *clean = data;\r\nstruct nf_conn_nat *nat = nfct_nat(i);\r\nif (!nat)\r\nreturn 0;\r\nif ((clean->l3proto && nf_ct_l3num(i) != clean->l3proto) ||\r\n(clean->l4proto && nf_ct_protonum(i) != clean->l4proto))\r\nreturn 0;\r\nreturn i->status & IPS_NAT_MASK ? 1 : 0;\r\n}\r\nstatic void nf_nat_l4proto_clean(u8 l3proto, u8 l4proto)\r\n{\r\nstruct nf_nat_proto_clean clean = {\r\n.l3proto = l3proto,\r\n.l4proto = l4proto,\r\n};\r\nstruct net *net;\r\nrtnl_lock();\r\nfor_each_net(net)\r\nnf_ct_iterate_cleanup(net, nf_nat_proto_remove, &clean, 0, 0);\r\nrtnl_unlock();\r\n}\r\nstatic void nf_nat_l3proto_clean(u8 l3proto)\r\n{\r\nstruct nf_nat_proto_clean clean = {\r\n.l3proto = l3proto,\r\n};\r\nstruct net *net;\r\nrtnl_lock();\r\nfor_each_net(net)\r\nnf_ct_iterate_cleanup(net, nf_nat_proto_remove, &clean, 0, 0);\r\nrtnl_unlock();\r\n}\r\nint nf_nat_l4proto_register(u8 l3proto, const struct nf_nat_l4proto *l4proto)\r\n{\r\nconst struct nf_nat_l4proto **l4protos;\r\nunsigned int i;\r\nint ret = 0;\r\nmutex_lock(&nf_nat_proto_mutex);\r\nif (nf_nat_l4protos[l3proto] == NULL) {\r\nl4protos = kmalloc(IPPROTO_MAX * sizeof(struct nf_nat_l4proto *),\r\nGFP_KERNEL);\r\nif (l4protos == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < IPPROTO_MAX; i++)\r\nRCU_INIT_POINTER(l4protos[i], &nf_nat_l4proto_unknown);\r\nsmp_wmb();\r\nnf_nat_l4protos[l3proto] = l4protos;\r\n}\r\nif (rcu_dereference_protected(\r\nnf_nat_l4protos[l3proto][l4proto->l4proto],\r\nlockdep_is_held(&nf_nat_proto_mutex)\r\n) != &nf_nat_l4proto_unknown) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nRCU_INIT_POINTER(nf_nat_l4protos[l3proto][l4proto->l4proto], l4proto);\r\nout:\r\nmutex_unlock(&nf_nat_proto_mutex);\r\nreturn ret;\r\n}\r\nvoid nf_nat_l4proto_unregister(u8 l3proto, const struct nf_nat_l4proto *l4proto)\r\n{\r\nmutex_lock(&nf_nat_proto_mutex);\r\nRCU_INIT_POINTER(nf_nat_l4protos[l3proto][l4proto->l4proto],\r\n&nf_nat_l4proto_unknown);\r\nmutex_unlock(&nf_nat_proto_mutex);\r\nsynchronize_rcu();\r\nnf_nat_l4proto_clean(l3proto, l4proto->l4proto);\r\n}\r\nint nf_nat_l3proto_register(const struct nf_nat_l3proto *l3proto)\r\n{\r\nint err;\r\nerr = nf_ct_l3proto_try_module_get(l3proto->l3proto);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&nf_nat_proto_mutex);\r\nRCU_INIT_POINTER(nf_nat_l4protos[l3proto->l3proto][IPPROTO_TCP],\r\n&nf_nat_l4proto_tcp);\r\nRCU_INIT_POINTER(nf_nat_l4protos[l3proto->l3proto][IPPROTO_UDP],\r\n&nf_nat_l4proto_udp);\r\nmutex_unlock(&nf_nat_proto_mutex);\r\nRCU_INIT_POINTER(nf_nat_l3protos[l3proto->l3proto], l3proto);\r\nreturn 0;\r\n}\r\nvoid nf_nat_l3proto_unregister(const struct nf_nat_l3proto *l3proto)\r\n{\r\nmutex_lock(&nf_nat_proto_mutex);\r\nRCU_INIT_POINTER(nf_nat_l3protos[l3proto->l3proto], NULL);\r\nmutex_unlock(&nf_nat_proto_mutex);\r\nsynchronize_rcu();\r\nnf_nat_l3proto_clean(l3proto->l3proto);\r\nnf_ct_l3proto_module_put(l3proto->l3proto);\r\n}\r\nstatic void nf_nat_cleanup_conntrack(struct nf_conn *ct)\r\n{\r\nstruct nf_conn_nat *nat = nf_ct_ext_find(ct, NF_CT_EXT_NAT);\r\nif (nat == NULL || nat->ct == NULL)\r\nreturn;\r\nNF_CT_ASSERT(nat->ct->status & IPS_SRC_NAT_DONE);\r\nspin_lock_bh(&nf_nat_lock);\r\nhlist_del_rcu(&nat->bysource);\r\nspin_unlock_bh(&nf_nat_lock);\r\n}\r\nstatic void nf_nat_move_storage(void *new, void *old)\r\n{\r\nstruct nf_conn_nat *new_nat = new;\r\nstruct nf_conn_nat *old_nat = old;\r\nstruct nf_conn *ct = old_nat->ct;\r\nif (!ct || !(ct->status & IPS_SRC_NAT_DONE))\r\nreturn;\r\nspin_lock_bh(&nf_nat_lock);\r\nhlist_replace_rcu(&old_nat->bysource, &new_nat->bysource);\r\nspin_unlock_bh(&nf_nat_lock);\r\n}\r\nstatic int nfnetlink_parse_nat_proto(struct nlattr *attr,\r\nconst struct nf_conn *ct,\r\nstruct nf_nat_range *range)\r\n{\r\nstruct nlattr *tb[CTA_PROTONAT_MAX+1];\r\nconst struct nf_nat_l4proto *l4proto;\r\nint err;\r\nerr = nla_parse_nested(tb, CTA_PROTONAT_MAX, attr, protonat_nla_policy);\r\nif (err < 0)\r\nreturn err;\r\nl4proto = __nf_nat_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));\r\nif (l4proto->nlattr_to_range)\r\nerr = l4proto->nlattr_to_range(tb, range);\r\nreturn err;\r\n}\r\nstatic int\r\nnfnetlink_parse_nat(const struct nlattr *nat,\r\nconst struct nf_conn *ct, struct nf_nat_range *range,\r\nconst struct nf_nat_l3proto *l3proto)\r\n{\r\nstruct nlattr *tb[CTA_NAT_MAX+1];\r\nint err;\r\nmemset(range, 0, sizeof(*range));\r\nerr = nla_parse_nested(tb, CTA_NAT_MAX, nat, nat_nla_policy);\r\nif (err < 0)\r\nreturn err;\r\nerr = l3proto->nlattr_to_range(tb, range);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[CTA_NAT_PROTO])\r\nreturn 0;\r\nreturn nfnetlink_parse_nat_proto(tb[CTA_NAT_PROTO], ct, range);\r\n}\r\nstatic int\r\nnfnetlink_parse_nat_setup(struct nf_conn *ct,\r\nenum nf_nat_manip_type manip,\r\nconst struct nlattr *attr)\r\n{\r\nstruct nf_nat_range range;\r\nconst struct nf_nat_l3proto *l3proto;\r\nint err;\r\nif (WARN_ON_ONCE(nf_nat_initialized(ct, manip)))\r\nreturn -EEXIST;\r\nl3proto = __nf_nat_l3proto_find(nf_ct_l3num(ct));\r\nif (l3proto == NULL)\r\nreturn -EAGAIN;\r\nif (attr == NULL)\r\nreturn __nf_nat_alloc_null_binding(ct, manip);\r\nerr = nfnetlink_parse_nat(attr, ct, &range, l3proto);\r\nif (err < 0)\r\nreturn err;\r\nreturn nf_nat_setup_info(ct, &range, manip);\r\n}\r\nstatic int\r\nnfnetlink_parse_nat_setup(struct nf_conn *ct,\r\nenum nf_nat_manip_type manip,\r\nconst struct nlattr *attr)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int __net_init nf_nat_net_init(struct net *net)\r\n{\r\nnet->ct.nat_htable_size = net->ct.htable_size;\r\nnet->ct.nat_bysource = nf_ct_alloc_hashtable(&net->ct.nat_htable_size, 0);\r\nif (!net->ct.nat_bysource)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit nf_nat_net_exit(struct net *net)\r\n{\r\nstruct nf_nat_proto_clean clean = {};\r\nnf_ct_iterate_cleanup(net, &nf_nat_proto_remove, &clean, 0, 0);\r\nsynchronize_rcu();\r\nnf_ct_free_hashtable(net->ct.nat_bysource, net->ct.nat_htable_size);\r\n}\r\nstatic int __init nf_nat_init(void)\r\n{\r\nint ret;\r\nret = nf_ct_extend_register(&nat_extend);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "nf_nat_core: Unable to register extension\n");\r\nreturn ret;\r\n}\r\nret = register_pernet_subsys(&nf_nat_net_ops);\r\nif (ret < 0)\r\ngoto cleanup_extend;\r\nnf_ct_helper_expectfn_register(&follow_master_nat);\r\nnf_ct_untracked_status_or(IPS_NAT_DONE_MASK);\r\nBUG_ON(nfnetlink_parse_nat_setup_hook != NULL);\r\nRCU_INIT_POINTER(nfnetlink_parse_nat_setup_hook,\r\nnfnetlink_parse_nat_setup);\r\n#ifdef CONFIG_XFRM\r\nBUG_ON(nf_nat_decode_session_hook != NULL);\r\nRCU_INIT_POINTER(nf_nat_decode_session_hook, __nf_nat_decode_session);\r\n#endif\r\nreturn 0;\r\ncleanup_extend:\r\nnf_ct_extend_unregister(&nat_extend);\r\nreturn ret;\r\n}\r\nstatic void __exit nf_nat_cleanup(void)\r\n{\r\nunsigned int i;\r\nunregister_pernet_subsys(&nf_nat_net_ops);\r\nnf_ct_extend_unregister(&nat_extend);\r\nnf_ct_helper_expectfn_unregister(&follow_master_nat);\r\nRCU_INIT_POINTER(nfnetlink_parse_nat_setup_hook, NULL);\r\n#ifdef CONFIG_XFRM\r\nRCU_INIT_POINTER(nf_nat_decode_session_hook, NULL);\r\n#endif\r\nfor (i = 0; i < NFPROTO_NUMPROTO; i++)\r\nkfree(nf_nat_l4protos[i]);\r\nsynchronize_net();\r\n}
