static int\r\nsymlink_hash(unsigned int link_len, const char *link_str, u8 *md5_hash)\r\n{\r\nint rc;\r\nunsigned int size;\r\nstruct crypto_shash *md5;\r\nstruct sdesc *sdescmd5;\r\nmd5 = crypto_alloc_shash("md5", 0, 0);\r\nif (IS_ERR(md5)) {\r\nrc = PTR_ERR(md5);\r\ncifs_dbg(VFS, "%s: Crypto md5 allocation error %d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nsize = sizeof(struct shash_desc) + crypto_shash_descsize(md5);\r\nsdescmd5 = kmalloc(size, GFP_KERNEL);\r\nif (!sdescmd5) {\r\nrc = -ENOMEM;\r\ngoto symlink_hash_err;\r\n}\r\nsdescmd5->shash.tfm = md5;\r\nsdescmd5->shash.flags = 0x0;\r\nrc = crypto_shash_init(&sdescmd5->shash);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not init md5 shash\n", __func__);\r\ngoto symlink_hash_err;\r\n}\r\nrc = crypto_shash_update(&sdescmd5->shash, link_str, link_len);\r\nif (rc) {\r\ncifs_dbg(VFS, "%s: Could not update with link_str\n", __func__);\r\ngoto symlink_hash_err;\r\n}\r\nrc = crypto_shash_final(&sdescmd5->shash, md5_hash);\r\nif (rc)\r\ncifs_dbg(VFS, "%s: Could not generate md5 hash\n", __func__);\r\nsymlink_hash_err:\r\ncrypto_free_shash(md5);\r\nkfree(sdescmd5);\r\nreturn rc;\r\n}\r\nstatic int\r\nparse_mf_symlink(const u8 *buf, unsigned int buf_len, unsigned int *_link_len,\r\nchar **_link_str)\r\n{\r\nint rc;\r\nunsigned int link_len;\r\nconst char *md5_str1;\r\nconst char *link_str;\r\nu8 md5_hash[16];\r\nchar md5_str2[34];\r\nif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\r\nreturn -EINVAL;\r\nmd5_str1 = (const char *)&buf[CIFS_MF_SYMLINK_MD5_OFFSET];\r\nlink_str = (const char *)&buf[CIFS_MF_SYMLINK_LINK_OFFSET];\r\nrc = sscanf(buf, CIFS_MF_SYMLINK_LEN_FORMAT, &link_len);\r\nif (rc != 1)\r\nreturn -EINVAL;\r\nrc = symlink_hash(link_len, link_str, md5_hash);\r\nif (rc) {\r\ncifs_dbg(FYI, "%s: MD5 hash failure: %d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nsnprintf(md5_str2, sizeof(md5_str2),\r\nCIFS_MF_SYMLINK_MD5_FORMAT,\r\nCIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\r\nif (strncmp(md5_str1, md5_str2, 17) != 0)\r\nreturn -EINVAL;\r\nif (_link_str) {\r\n*_link_str = kstrndup(link_str, link_len, GFP_KERNEL);\r\nif (!*_link_str)\r\nreturn -ENOMEM;\r\n}\r\n*_link_len = link_len;\r\nreturn 0;\r\n}\r\nstatic int\r\nformat_mf_symlink(u8 *buf, unsigned int buf_len, const char *link_str)\r\n{\r\nint rc;\r\nunsigned int link_len;\r\nunsigned int ofs;\r\nu8 md5_hash[16];\r\nif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\r\nreturn -EINVAL;\r\nlink_len = strlen(link_str);\r\nif (link_len > CIFS_MF_SYMLINK_LINK_MAXLEN)\r\nreturn -ENAMETOOLONG;\r\nrc = symlink_hash(link_len, link_str, md5_hash);\r\nif (rc) {\r\ncifs_dbg(FYI, "%s: MD5 hash failure: %d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nsnprintf(buf, buf_len,\r\nCIFS_MF_SYMLINK_LEN_FORMAT CIFS_MF_SYMLINK_MD5_FORMAT,\r\nlink_len,\r\nCIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\r\nofs = CIFS_MF_SYMLINK_LINK_OFFSET;\r\nmemcpy(buf + ofs, link_str, link_len);\r\nofs += link_len;\r\nif (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\r\nbuf[ofs] = '\n';\r\nofs++;\r\n}\r\nwhile (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\r\nbuf[ofs] = ' ';\r\nofs++;\r\n}\r\nreturn 0;\r\n}\r\nbool\r\ncouldbe_mf_symlink(const struct cifs_fattr *fattr)\r\n{\r\nif (!S_ISREG(fattr->cf_mode))\r\nreturn false;\r\nif (fattr->cf_eof != CIFS_MF_SYMLINK_FILE_SIZE)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int\r\ncreate_mf_symlink(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_sb_info *cifs_sb, const char *fromName,\r\nconst char *toName)\r\n{\r\nint rc;\r\nu8 *buf;\r\nunsigned int bytes_written = 0;\r\nbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nrc = format_mf_symlink(buf, CIFS_MF_SYMLINK_FILE_SIZE, toName);\r\nif (rc)\r\ngoto out;\r\nrc = tcon->ses->server->ops->create_mf_symlink(xid, tcon, cifs_sb,\r\nfromName, buf, &bytes_written);\r\nif (rc)\r\ngoto out;\r\nif (bytes_written != CIFS_MF_SYMLINK_FILE_SIZE)\r\nrc = -EIO;\r\nout:\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nstatic int\r\nquery_mf_symlink(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_sb_info *cifs_sb, const unsigned char *path,\r\nchar **symlinkinfo)\r\n{\r\nint rc;\r\nu8 *buf = NULL;\r\nunsigned int link_len = 0;\r\nunsigned int bytes_read = 0;\r\nbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (tcon->ses->server->ops->query_mf_symlink)\r\nrc = tcon->ses->server->ops->query_mf_symlink(xid, tcon,\r\ncifs_sb, path, buf, &bytes_read);\r\nelse\r\nrc = -ENOSYS;\r\nif (rc)\r\ngoto out;\r\nif (bytes_read == 0) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = parse_mf_symlink(buf, bytes_read, &link_len, symlinkinfo);\r\nout:\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nint\r\ncheck_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\r\nconst unsigned char *path)\r\n{\r\nint rc;\r\nu8 *buf = NULL;\r\nunsigned int link_len = 0;\r\nunsigned int bytes_read = 0;\r\nif (!couldbe_mf_symlink(fattr))\r\nreturn 0;\r\nbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (tcon->ses->server->ops->query_mf_symlink)\r\nrc = tcon->ses->server->ops->query_mf_symlink(xid, tcon,\r\ncifs_sb, path, buf, &bytes_read);\r\nelse\r\nrc = -ENOSYS;\r\nif (rc)\r\ngoto out;\r\nif (bytes_read == 0)\r\ngoto out;\r\nrc = parse_mf_symlink(buf, bytes_read, &link_len, NULL);\r\nif (rc == -EINVAL) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nif (rc != 0)\r\ngoto out;\r\nfattr->cf_eof = link_len;\r\nfattr->cf_mode &= ~S_IFMT;\r\nfattr->cf_mode |= S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;\r\nfattr->cf_dtype = DT_LNK;\r\nout:\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nint\r\ncifs_query_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_sb_info *cifs_sb, const unsigned char *path,\r\nchar *pbuf, unsigned int *pbytes_read)\r\n{\r\nint rc;\r\nint oplock = 0;\r\nstruct cifs_fid fid;\r\nstruct cifs_open_parms oparms;\r\nstruct cifs_io_parms io_parms;\r\nint buf_type = CIFS_NO_BUFFER;\r\nFILE_ALL_INFO file_info;\r\noparms.tcon = tcon;\r\noparms.cifs_sb = cifs_sb;\r\noparms.desired_access = GENERIC_READ;\r\noparms.create_options = CREATE_NOT_DIR;\r\noparms.disposition = FILE_OPEN;\r\noparms.path = path;\r\noparms.fid = &fid;\r\noparms.reconnect = false;\r\nrc = CIFS_open(xid, &oparms, &oplock, &file_info);\r\nif (rc)\r\nreturn rc;\r\nif (file_info.EndOfFile != cpu_to_le64(CIFS_MF_SYMLINK_FILE_SIZE))\r\ngoto out;\r\nio_parms.netfid = fid.netfid;\r\nio_parms.pid = current->tgid;\r\nio_parms.tcon = tcon;\r\nio_parms.offset = 0;\r\nio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\r\nrc = CIFSSMBRead(xid, &io_parms, pbytes_read, &pbuf, &buf_type);\r\nout:\r\nCIFSSMBClose(xid, tcon, fid.netfid);\r\nreturn rc;\r\n}\r\nint\r\ncifs_create_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_sb_info *cifs_sb, const unsigned char *path,\r\nchar *pbuf, unsigned int *pbytes_written)\r\n{\r\nint rc;\r\nint oplock = 0;\r\nstruct cifs_fid fid;\r\nstruct cifs_open_parms oparms;\r\nstruct cifs_io_parms io_parms;\r\nint create_options = CREATE_NOT_DIR;\r\nif (backup_cred(cifs_sb))\r\ncreate_options |= CREATE_OPEN_BACKUP_INTENT;\r\noparms.tcon = tcon;\r\noparms.cifs_sb = cifs_sb;\r\noparms.desired_access = GENERIC_WRITE;\r\noparms.create_options = create_options;\r\noparms.disposition = FILE_OPEN;\r\noparms.path = path;\r\noparms.fid = &fid;\r\noparms.reconnect = false;\r\nrc = CIFS_open(xid, &oparms, &oplock, NULL);\r\nif (rc)\r\nreturn rc;\r\nio_parms.netfid = fid.netfid;\r\nio_parms.pid = current->tgid;\r\nio_parms.tcon = tcon;\r\nio_parms.offset = 0;\r\nio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\r\nrc = CIFSSMBWrite(xid, &io_parms, pbytes_written, pbuf, NULL, 0);\r\nCIFSSMBClose(xid, tcon, fid.netfid);\r\nreturn rc;\r\n}\r\nint\r\ncifs_hardlink(struct dentry *old_file, struct inode *inode,\r\nstruct dentry *direntry)\r\n{\r\nint rc = -EACCES;\r\nunsigned int xid;\r\nchar *from_name = NULL;\r\nchar *to_name = NULL;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\r\nstruct tcon_link *tlink;\r\nstruct cifs_tcon *tcon;\r\nstruct TCP_Server_Info *server;\r\nstruct cifsInodeInfo *cifsInode;\r\ntlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink))\r\nreturn PTR_ERR(tlink);\r\ntcon = tlink_tcon(tlink);\r\nxid = get_xid();\r\nfrom_name = build_path_from_dentry(old_file);\r\nto_name = build_path_from_dentry(direntry);\r\nif ((from_name == NULL) || (to_name == NULL)) {\r\nrc = -ENOMEM;\r\ngoto cifs_hl_exit;\r\n}\r\nif (tcon->unix_ext)\r\nrc = CIFSUnixCreateHardLink(xid, tcon, from_name, to_name,\r\ncifs_sb->local_nls,\r\ncifs_sb->mnt_cifs_flags &\r\nCIFS_MOUNT_MAP_SPECIAL_CHR);\r\nelse {\r\nserver = tcon->ses->server;\r\nif (!server->ops->create_hardlink) {\r\nrc = -ENOSYS;\r\ngoto cifs_hl_exit;\r\n}\r\nrc = server->ops->create_hardlink(xid, tcon, from_name, to_name,\r\ncifs_sb);\r\nif ((rc == -EIO) || (rc == -EINVAL))\r\nrc = -EOPNOTSUPP;\r\n}\r\nd_drop(direntry);\r\nif (old_file->d_inode) {\r\ncifsInode = CIFS_I(old_file->d_inode);\r\nif (rc == 0) {\r\nspin_lock(&old_file->d_inode->i_lock);\r\ninc_nlink(old_file->d_inode);\r\nspin_unlock(&old_file->d_inode->i_lock);\r\n}\r\ncifsInode->time = 0;\r\n}\r\ncifs_hl_exit:\r\nkfree(from_name);\r\nkfree(to_name);\r\nfree_xid(xid);\r\ncifs_put_tlink(tlink);\r\nreturn rc;\r\n}\r\nvoid *\r\ncifs_follow_link(struct dentry *direntry, struct nameidata *nd)\r\n{\r\nstruct inode *inode = direntry->d_inode;\r\nint rc = -ENOMEM;\r\nunsigned int xid;\r\nchar *full_path = NULL;\r\nchar *target_path = NULL;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\r\nstruct tcon_link *tlink = NULL;\r\nstruct cifs_tcon *tcon;\r\nstruct TCP_Server_Info *server;\r\nxid = get_xid();\r\ntlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink)) {\r\nrc = PTR_ERR(tlink);\r\ntlink = NULL;\r\ngoto out;\r\n}\r\ntcon = tlink_tcon(tlink);\r\nserver = tcon->ses->server;\r\nfull_path = build_path_from_dentry(direntry);\r\nif (!full_path)\r\ngoto out;\r\ncifs_dbg(FYI, "Full path: %s inode = 0x%p\n", full_path, inode);\r\nrc = -EACCES;\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\r\nrc = query_mf_symlink(xid, tcon, cifs_sb, full_path,\r\n&target_path);\r\nif (rc != 0 && server->ops->query_symlink)\r\nrc = server->ops->query_symlink(xid, tcon, full_path,\r\n&target_path, cifs_sb);\r\nkfree(full_path);\r\nout:\r\nif (rc != 0) {\r\nkfree(target_path);\r\ntarget_path = ERR_PTR(rc);\r\n}\r\nfree_xid(xid);\r\nif (tlink)\r\ncifs_put_tlink(tlink);\r\nnd_set_link(nd, target_path);\r\nreturn NULL;\r\n}\r\nint\r\ncifs_symlink(struct inode *inode, struct dentry *direntry, const char *symname)\r\n{\r\nint rc = -EOPNOTSUPP;\r\nunsigned int xid;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\r\nstruct tcon_link *tlink;\r\nstruct cifs_tcon *pTcon;\r\nchar *full_path = NULL;\r\nstruct inode *newinode = NULL;\r\nxid = get_xid();\r\ntlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink)) {\r\nrc = PTR_ERR(tlink);\r\ngoto symlink_exit;\r\n}\r\npTcon = tlink_tcon(tlink);\r\nfull_path = build_path_from_dentry(direntry);\r\nif (full_path == NULL) {\r\nrc = -ENOMEM;\r\ngoto symlink_exit;\r\n}\r\ncifs_dbg(FYI, "Full path: %s\n", full_path);\r\ncifs_dbg(FYI, "symname is %s\n", symname);\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\r\nrc = create_mf_symlink(xid, pTcon, cifs_sb, full_path, symname);\r\nelse if (pTcon->unix_ext)\r\nrc = CIFSUnixCreateSymLink(xid, pTcon, full_path, symname,\r\ncifs_sb->local_nls);\r\nif (rc == 0) {\r\nif (pTcon->unix_ext)\r\nrc = cifs_get_inode_info_unix(&newinode, full_path,\r\ninode->i_sb, xid);\r\nelse\r\nrc = cifs_get_inode_info(&newinode, full_path, NULL,\r\ninode->i_sb, xid, NULL);\r\nif (rc != 0) {\r\ncifs_dbg(FYI, "Create symlink ok, getinodeinfo fail rc = %d\n",\r\nrc);\r\n} else {\r\nd_instantiate(direntry, newinode);\r\n}\r\n}\r\nsymlink_exit:\r\nkfree(full_path);\r\ncifs_put_tlink(tlink);\r\nfree_xid(xid);\r\nreturn rc;\r\n}
