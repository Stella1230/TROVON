static unsigned int count_relocs(const Elf64_Rela *rela, unsigned int num)\r\n{\r\nunsigned int i, r_info, r_addend, _count_relocs;\r\n_count_relocs = 0;\r\nr_info = 0;\r\nr_addend = 0;\r\nfor (i = 0; i < num; i++)\r\nif (ELF64_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\r\n(r_info != ELF64_R_SYM(rela[i].r_info) ||\r\nr_addend != rela[i].r_addend)) {\r\n_count_relocs++;\r\nr_info = ELF64_R_SYM(rela[i].r_info);\r\nr_addend = rela[i].r_addend;\r\n}\r\nreturn _count_relocs;\r\n}\r\nstatic int relacmp(const void *_x, const void *_y)\r\n{\r\nconst Elf64_Rela *x, *y;\r\ny = (Elf64_Rela *)_x;\r\nx = (Elf64_Rela *)_y;\r\nif (x->r_info < y->r_info)\r\nreturn -1;\r\nelse if (x->r_info > y->r_info)\r\nreturn 1;\r\nelse if (x->r_addend < y->r_addend)\r\nreturn -1;\r\nelse if (x->r_addend > y->r_addend)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void relaswap(void *_x, void *_y, int size)\r\n{\r\nuint64_t *x, *y, tmp;\r\nint i;\r\ny = (uint64_t *)_x;\r\nx = (uint64_t *)_y;\r\nfor (i = 0; i < sizeof(Elf64_Rela) / sizeof(uint64_t); i++) {\r\ntmp = x[i];\r\nx[i] = y[i];\r\ny[i] = tmp;\r\n}\r\n}\r\nstatic unsigned long get_stubs_size(const Elf64_Ehdr *hdr,\r\nconst Elf64_Shdr *sechdrs)\r\n{\r\nunsigned long relocs = 1;\r\nunsigned i;\r\nfor (i = 1; i < hdr->e_shnum; i++) {\r\nif (sechdrs[i].sh_type == SHT_RELA) {\r\nDEBUGP("Found relocations in section %u\n", i);\r\nDEBUGP("Ptr: %p. Number: %lu\n",\r\n(void *)sechdrs[i].sh_addr,\r\nsechdrs[i].sh_size / sizeof(Elf64_Rela));\r\nsort((void *)sechdrs[i].sh_addr,\r\nsechdrs[i].sh_size / sizeof(Elf64_Rela),\r\nsizeof(Elf64_Rela), relacmp, relaswap);\r\nrelocs += count_relocs((void *)sechdrs[i].sh_addr,\r\nsechdrs[i].sh_size\r\n/ sizeof(Elf64_Rela));\r\n}\r\n}\r\n#ifdef CONFIG_DYNAMIC_FTRACE\r\nrelocs++;\r\n#endif\r\nDEBUGP("Looks like a total of %lu stubs, max\n", relocs);\r\nreturn relocs * sizeof(struct ppc64_stub_entry);\r\n}\r\nstatic void dedotify_versions(struct modversion_info *vers,\r\nunsigned long size)\r\n{\r\nstruct modversion_info *end;\r\nfor (end = (void *)vers + size; vers < end; vers++)\r\nif (vers->name[0] == '.')\r\nmemmove(vers->name, vers->name+1, strlen(vers->name));\r\n}\r\nstatic void dedotify(Elf64_Sym *syms, unsigned int numsyms, char *strtab)\r\n{\r\nunsigned int i;\r\nfor (i = 1; i < numsyms; i++) {\r\nif (syms[i].st_shndx == SHN_UNDEF) {\r\nchar *name = strtab + syms[i].st_name;\r\nif (name[0] == '.')\r\nmemmove(name, name+1, strlen(name));\r\n}\r\n}\r\n}\r\nint module_frob_arch_sections(Elf64_Ehdr *hdr,\r\nElf64_Shdr *sechdrs,\r\nchar *secstrings,\r\nstruct module *me)\r\n{\r\nunsigned int i;\r\nfor (i = 1; i < hdr->e_shnum; i++) {\r\nchar *p;\r\nif (strcmp(secstrings + sechdrs[i].sh_name, ".stubs") == 0)\r\nme->arch.stubs_section = i;\r\nelse if (strcmp(secstrings + sechdrs[i].sh_name, ".toc") == 0)\r\nme->arch.toc_section = i;\r\nelse if (strcmp(secstrings+sechdrs[i].sh_name,"__versions")==0)\r\ndedotify_versions((void *)hdr + sechdrs[i].sh_offset,\r\nsechdrs[i].sh_size);\r\nwhile ((p = strstr(secstrings + sechdrs[i].sh_name, ".init")))\r\np[0] = '_';\r\nif (sechdrs[i].sh_type == SHT_SYMTAB)\r\ndedotify((void *)hdr + sechdrs[i].sh_offset,\r\nsechdrs[i].sh_size / sizeof(Elf64_Sym),\r\n(void *)hdr\r\n+ sechdrs[sechdrs[i].sh_link].sh_offset);\r\n}\r\nif (!me->arch.stubs_section) {\r\nprintk("%s: doesn't contain .stubs.\n", me->name);\r\nreturn -ENOEXEC;\r\n}\r\nif (!me->arch.toc_section)\r\nme->arch.toc_section = me->arch.stubs_section;\r\nsechdrs[me->arch.stubs_section].sh_size = get_stubs_size(hdr, sechdrs);\r\nreturn 0;\r\n}\r\nstatic inline unsigned long my_r2(Elf64_Shdr *sechdrs, struct module *me)\r\n{\r\nreturn sechdrs[me->arch.toc_section].sh_addr + 0x8000;\r\n}\r\nstatic inline int create_stub(Elf64_Shdr *sechdrs,\r\nstruct ppc64_stub_entry *entry,\r\nstruct ppc64_opd_entry *opd,\r\nstruct module *me)\r\n{\r\nElf64_Half *loc1, *loc2;\r\nlong reladdr;\r\n*entry = ppc64_stub;\r\n#ifdef __LITTLE_ENDIAN__\r\nloc1 = (Elf64_Half *)&entry->jump[0];\r\nloc2 = (Elf64_Half *)&entry->jump[4];\r\n#else\r\nloc1 = (Elf64_Half *)&entry->jump[2];\r\nloc2 = (Elf64_Half *)&entry->jump[6];\r\n#endif\r\nreladdr = (unsigned long)entry - my_r2(sechdrs, me);\r\nif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\r\nprintk("%s: Address %p of stub out of range of %p.\n",\r\nme->name, (void *)reladdr, (void *)my_r2);\r\nreturn 0;\r\n}\r\nDEBUGP("Stub %p get data from reladdr %li\n", entry, reladdr);\r\n*loc1 = PPC_HA(reladdr);\r\n*loc2 = PPC_LO(reladdr);\r\nentry->opd.funcaddr = opd->funcaddr;\r\nentry->opd.r2 = opd->r2;\r\nreturn 1;\r\n}\r\nstatic unsigned long stub_for_addr(Elf64_Shdr *sechdrs,\r\nunsigned long opdaddr,\r\nstruct module *me)\r\n{\r\nstruct ppc64_stub_entry *stubs;\r\nstruct ppc64_opd_entry *opd = (void *)opdaddr;\r\nunsigned int i, num_stubs;\r\nnum_stubs = sechdrs[me->arch.stubs_section].sh_size / sizeof(*stubs);\r\nstubs = (void *)sechdrs[me->arch.stubs_section].sh_addr;\r\nfor (i = 0; stubs[i].opd.funcaddr; i++) {\r\nBUG_ON(i >= num_stubs);\r\nif (stubs[i].opd.funcaddr == opd->funcaddr)\r\nreturn (unsigned long)&stubs[i];\r\n}\r\nif (!create_stub(sechdrs, &stubs[i], opd, me))\r\nreturn 0;\r\nreturn (unsigned long)&stubs[i];\r\n}\r\nstatic int restore_r2(u32 *instruction, struct module *me)\r\n{\r\nif (*instruction != PPC_INST_NOP) {\r\nprintk("%s: Expect noop after relocate, got %08x\n",\r\nme->name, *instruction);\r\nreturn 0;\r\n}\r\n*instruction = 0xe8410028;\r\nreturn 1;\r\n}\r\nint apply_relocate_add(Elf64_Shdr *sechdrs,\r\nconst char *strtab,\r\nunsigned int symindex,\r\nunsigned int relsec,\r\nstruct module *me)\r\n{\r\nunsigned int i;\r\nElf64_Rela *rela = (void *)sechdrs[relsec].sh_addr;\r\nElf64_Sym *sym;\r\nunsigned long *location;\r\nunsigned long value;\r\nDEBUGP("Applying ADD relocate section %u to %u\n", relsec,\r\nsechdrs[relsec].sh_info);\r\nfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rela); i++) {\r\nlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\r\n+ rela[i].r_offset;\r\nsym = (Elf64_Sym *)sechdrs[symindex].sh_addr\r\n+ ELF64_R_SYM(rela[i].r_info);\r\nDEBUGP("RELOC at %p: %li-type as %s (%lu) + %li\n",\r\nlocation, (long)ELF64_R_TYPE(rela[i].r_info),\r\nstrtab + sym->st_name, (unsigned long)sym->st_value,\r\n(long)rela[i].r_addend);\r\nvalue = sym->st_value + rela[i].r_addend;\r\nswitch (ELF64_R_TYPE(rela[i].r_info)) {\r\ncase R_PPC64_ADDR32:\r\n*(u32 *)location = value;\r\nbreak;\r\ncase R_PPC64_ADDR64:\r\n*(unsigned long *)location = value;\r\nbreak;\r\ncase R_PPC64_TOC:\r\n*(unsigned long *)location = my_r2(sechdrs, me);\r\nbreak;\r\ncase R_PPC64_TOC16:\r\nvalue -= my_r2(sechdrs, me);\r\nif (value + 0x8000 > 0xffff) {\r\nprintk("%s: bad TOC16 relocation (%lu)\n",\r\nme->name, value);\r\nreturn -ENOEXEC;\r\n}\r\n*((uint16_t *) location)\r\n= (*((uint16_t *) location) & ~0xffff)\r\n| (value & 0xffff);\r\nbreak;\r\ncase R_PPC64_TOC16_LO:\r\nvalue -= my_r2(sechdrs, me);\r\n*((uint16_t *) location)\r\n= (*((uint16_t *) location) & ~0xffff)\r\n| (value & 0xffff);\r\nbreak;\r\ncase R_PPC64_TOC16_DS:\r\nvalue -= my_r2(sechdrs, me);\r\nif ((value & 3) != 0 || value + 0x8000 > 0xffff) {\r\nprintk("%s: bad TOC16_DS relocation (%lu)\n",\r\nme->name, value);\r\nreturn -ENOEXEC;\r\n}\r\n*((uint16_t *) location)\r\n= (*((uint16_t *) location) & ~0xfffc)\r\n| (value & 0xfffc);\r\nbreak;\r\ncase R_PPC64_TOC16_LO_DS:\r\nvalue -= my_r2(sechdrs, me);\r\nif ((value & 3) != 0) {\r\nprintk("%s: bad TOC16_LO_DS relocation (%lu)\n",\r\nme->name, value);\r\nreturn -ENOEXEC;\r\n}\r\n*((uint16_t *) location)\r\n= (*((uint16_t *) location) & ~0xfffc)\r\n| (value & 0xfffc);\r\nbreak;\r\ncase R_PPC64_TOC16_HA:\r\nvalue -= my_r2(sechdrs, me);\r\nvalue = ((value + 0x8000) >> 16);\r\n*((uint16_t *) location)\r\n= (*((uint16_t *) location) & ~0xffff)\r\n| (value & 0xffff);\r\nbreak;\r\ncase R_PPC_REL24:\r\nif (sym->st_shndx == SHN_UNDEF) {\r\nvalue = stub_for_addr(sechdrs, value, me);\r\nif (!value)\r\nreturn -ENOENT;\r\nif (!restore_r2((u32 *)location + 1, me))\r\nreturn -ENOEXEC;\r\n}\r\nvalue -= (unsigned long)location;\r\nif (value + 0x2000000 > 0x3ffffff || (value & 3) != 0){\r\nprintk("%s: REL24 %li out of range!\n",\r\nme->name, (long int)value);\r\nreturn -ENOEXEC;\r\n}\r\n*(uint32_t *)location\r\n= (*(uint32_t *)location & ~0x03fffffc)\r\n| (value & 0x03fffffc);\r\nbreak;\r\ncase R_PPC64_REL64:\r\n*location = value - (unsigned long)location;\r\nbreak;\r\ndefault:\r\nprintk("%s: Unknown ADD relocation: %lu\n",\r\nme->name,\r\n(unsigned long)ELF64_R_TYPE(rela[i].r_info));\r\nreturn -ENOEXEC;\r\n}\r\n}\r\n#ifdef CONFIG_DYNAMIC_FTRACE\r\nme->arch.toc = my_r2(sechdrs, me);\r\nme->arch.tramp = stub_for_addr(sechdrs,\r\n(unsigned long)ftrace_caller,\r\nme);\r\n#endif\r\nreturn 0;\r\n}
