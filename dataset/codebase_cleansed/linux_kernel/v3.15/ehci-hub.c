static int persist_enabled_on_companion(struct usb_device *udev, void *unused)\r\n{\r\nreturn !udev->maxchild && udev->persist_enabled &&\r\nudev->bus->root_hub->speed < USB_SPEED_HIGH;\r\n}\r\nstatic void ehci_handover_companion_ports(struct ehci_hcd *ehci)\r\n{\r\nu32 __iomem *reg;\r\nu32 status;\r\nint port;\r\n__le32 buf;\r\nstruct usb_hcd *hcd = ehci_to_hcd(ehci);\r\nif (!ehci->owned_ports)\r\nreturn;\r\nif (!usb_for_each_dev(NULL, persist_enabled_on_companion))\r\nreturn;\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nif (test_bit(port, &ehci->owned_ports)) {\r\nreg = &ehci->regs->port_status[port];\r\nstatus = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\r\nif (!(status & PORT_POWER)) {\r\nstatus |= PORT_POWER;\r\nehci_writel(ehci, status, reg);\r\n}\r\n}\r\n}\r\nmsleep(20);\r\nspin_lock_irq(&ehci->lock);\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nif (test_bit(port, &ehci->owned_ports)) {\r\nreg = &ehci->regs->port_status[port];\r\nstatus = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\r\nif (status & PORT_OWNER)\r\nclear_bit(port, &ehci->owned_ports);\r\nelse if (test_bit(port, &ehci->companion_ports))\r\nehci_writel(ehci, status & ~PORT_PE, reg);\r\nelse {\r\nspin_unlock_irq(&ehci->lock);\r\nehci_hub_control(hcd, SetPortFeature,\r\nUSB_PORT_FEAT_RESET, port + 1,\r\nNULL, 0);\r\nspin_lock_irq(&ehci->lock);\r\n}\r\n}\r\n}\r\nspin_unlock_irq(&ehci->lock);\r\nif (!ehci->owned_ports)\r\nreturn;\r\nmsleep(90);\r\nspin_lock_irq(&ehci->lock);\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nif (test_bit(port, &ehci->owned_ports)) {\r\nspin_unlock_irq(&ehci->lock);\r\nehci_hub_control(hcd, GetPortStatus,\r\n0, port + 1,\r\n(char *) &buf, sizeof(buf));\r\nspin_lock_irq(&ehci->lock);\r\nreg = &ehci->regs->port_status[port];\r\nstatus = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\r\nif (status & PORT_OWNER)\r\nehci_writel(ehci, status | PORT_CSC, reg);\r\nelse {\r\nehci_dbg(ehci, "failed handover port %d: %x\n",\r\nport + 1, status);\r\nehci_writel(ehci, status & ~PORT_PE, reg);\r\n}\r\n}\r\n}\r\nehci->owned_ports = 0;\r\nspin_unlock_irq(&ehci->lock);\r\n}\r\nstatic int ehci_port_change(struct ehci_hcd *ehci)\r\n{\r\nint i = HCS_N_PORTS(ehci->hcs_params);\r\nif (ehci_readl(ehci, &ehci->regs->status) & STS_PCD)\r\nreturn 1;\r\nwhile (i--)\r\nif (ehci_readl(ehci, &ehci->regs->port_status[i]) & PORT_CSC)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,\r\nbool suspending, bool do_wakeup)\r\n{\r\nint port;\r\nu32 temp;\r\nif (!ehci_to_hcd(ehci)->self.root_hub->do_remote_wakeup || do_wakeup)\r\nreturn;\r\nspin_lock_irq(&ehci->lock);\r\nif (ehci->has_tdi_phy_lpm) {\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nu32 __iomem *hostpc_reg = &ehci->regs->hostpc[port];\r\ntemp = ehci_readl(ehci, hostpc_reg);\r\nehci_writel(ehci, temp & ~HOSTPC_PHCD, hostpc_reg);\r\n}\r\nspin_unlock_irq(&ehci->lock);\r\nmsleep(5);\r\nspin_lock_irq(&ehci->lock);\r\n}\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nu32 __iomem *reg = &ehci->regs->port_status[port];\r\nu32 t1 = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\r\nu32 t2 = t1 & ~PORT_WAKE_BITS;\r\nif (!suspending) {\r\nif (t1 & PORT_CONNECT)\r\nt2 |= PORT_WKOC_E | PORT_WKDISC_E;\r\nelse\r\nt2 |= PORT_WKOC_E | PORT_WKCONN_E;\r\n}\r\nehci_writel(ehci, t2, reg);\r\n}\r\nif (ehci->has_tdi_phy_lpm) {\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nu32 __iomem *hostpc_reg = &ehci->regs->hostpc[port];\r\ntemp = ehci_readl(ehci, hostpc_reg);\r\nehci_writel(ehci, temp | HOSTPC_PHCD, hostpc_reg);\r\n}\r\n}\r\nif (!suspending && ehci_port_change(ehci))\r\nusb_hcd_resume_root_hub(ehci_to_hcd(ehci));\r\nspin_unlock_irq(&ehci->lock);\r\n}\r\nstatic int ehci_bus_suspend (struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nint port;\r\nint mask;\r\nint changed;\r\nbool fs_idle_delay;\r\nehci_dbg(ehci, "suspend root hub\n");\r\nif (time_before (jiffies, ehci->next_statechange))\r\nmsleep(5);\r\nehci_quiesce(ehci);\r\nspin_lock_irq (&ehci->lock);\r\nif (ehci->rh_state < EHCI_RH_RUNNING)\r\ngoto done;\r\nif (hcd->self.root_hub->do_remote_wakeup) {\r\nif (ehci->resuming_ports) {\r\nspin_unlock_irq(&ehci->lock);\r\nehci_dbg(ehci, "suspend failed because a port is resuming\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nehci->bus_suspended = 0;\r\nehci->owned_ports = 0;\r\nchanged = 0;\r\nfs_idle_delay = false;\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nu32 __iomem *reg = &ehci->regs->port_status [port];\r\nu32 t1 = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\r\nu32 t2 = t1 & ~PORT_WAKE_BITS;\r\nif (t1 & PORT_OWNER)\r\nset_bit(port, &ehci->owned_ports);\r\nelse if ((t1 & PORT_PE) && !(t1 & PORT_SUSPEND)) {\r\nt2 |= PORT_SUSPEND;\r\nset_bit(port, &ehci->bus_suspended);\r\n}\r\nif (hcd->self.root_hub->do_remote_wakeup) {\r\nif (t1 & PORT_CONNECT)\r\nt2 |= PORT_WKOC_E | PORT_WKDISC_E;\r\nelse\r\nt2 |= PORT_WKOC_E | PORT_WKCONN_E;\r\n}\r\nif (t1 != t2) {\r\nif ((t2 & PORT_WKDISC_E) &&\r\nehci_port_speed(ehci, t2) ==\r\nUSB_PORT_STAT_HIGH_SPEED)\r\nfs_idle_delay = true;\r\nehci_writel(ehci, t2, reg);\r\nchanged = 1;\r\n}\r\n}\r\nspin_unlock_irq(&ehci->lock);\r\nif ((changed && ehci->has_tdi_phy_lpm) || fs_idle_delay) {\r\nusleep_range(5000, 5500);\r\n}\r\nif (changed && ehci->has_tdi_phy_lpm) {\r\nspin_lock_irq(&ehci->lock);\r\nport = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (port--) {\r\nu32 __iomem *hostpc_reg = &ehci->regs->hostpc[port];\r\nu32 t3;\r\nt3 = ehci_readl(ehci, hostpc_reg);\r\nehci_writel(ehci, t3 | HOSTPC_PHCD, hostpc_reg);\r\nt3 = ehci_readl(ehci, hostpc_reg);\r\nehci_dbg(ehci, "Port %d phy low-power mode %s\n",\r\nport, (t3 & HOSTPC_PHCD) ?\r\n"succeeded" : "failed");\r\n}\r\nspin_unlock_irq(&ehci->lock);\r\n}\r\nif (ehci->bus_suspended)\r\nudelay(150);\r\nehci_halt (ehci);\r\nspin_lock_irq(&ehci->lock);\r\nif (ehci->enabled_hrtimer_events & BIT(EHCI_HRTIMER_POLL_DEAD))\r\nehci_handle_controller_death(ehci);\r\nif (ehci->rh_state != EHCI_RH_RUNNING)\r\ngoto done;\r\nehci->rh_state = EHCI_RH_SUSPENDED;\r\nend_unlink_async(ehci);\r\nunlink_empty_async_suspended(ehci);\r\nehci_handle_start_intr_unlinks(ehci);\r\nehci_handle_intr_unlinks(ehci);\r\nend_free_itds(ehci);\r\nmask = INTR_MASK;\r\nif (!hcd->self.root_hub->do_remote_wakeup)\r\nmask &= ~STS_PCD;\r\nehci_writel(ehci, mask, &ehci->regs->intr_enable);\r\nehci_readl(ehci, &ehci->regs->intr_enable);\r\ndone:\r\nehci->next_statechange = jiffies + msecs_to_jiffies(10);\r\nehci->enabled_hrtimer_events = 0;\r\nehci->next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;\r\nspin_unlock_irq (&ehci->lock);\r\nhrtimer_cancel(&ehci->hrtimer);\r\nreturn 0;\r\n}\r\nstatic int ehci_bus_resume (struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nu32 temp;\r\nu32 power_okay;\r\nint i;\r\nunsigned long resume_needed = 0;\r\nif (time_before (jiffies, ehci->next_statechange))\r\nmsleep(5);\r\nspin_lock_irq (&ehci->lock);\r\nif (!HCD_HW_ACCESSIBLE(hcd) || ehci->shutdown)\r\ngoto shutdown;\r\nif (unlikely(ehci->debug)) {\r\nif (!dbgp_reset_prep(hcd))\r\nehci->debug = NULL;\r\nelse\r\ndbgp_external_startup(hcd);\r\n}\r\npower_okay = ehci_readl(ehci, &ehci->regs->intr_enable);\r\nehci_dbg(ehci, "resume root hub%s\n",\r\npower_okay ? "" : " after power loss");\r\nehci_writel(ehci, 0, &ehci->regs->intr_enable);\r\nehci_writel(ehci, 0, &ehci->regs->segment);\r\nehci_writel(ehci, ehci->periodic_dma, &ehci->regs->frame_list);\r\nehci_writel(ehci, (u32) ehci->async->qh_dma, &ehci->regs->async_next);\r\nehci->command |= CMD_RUN;\r\nehci_writel(ehci, ehci->command, &ehci->regs->command);\r\nehci->rh_state = EHCI_RH_RUNNING;\r\ni = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (i--) {\r\ntemp = ehci_readl(ehci, &ehci->regs->port_status[i]);\r\nif ((temp & PORT_PE) &&\r\n!(temp & (PORT_SUSPEND | PORT_RESUME))) {\r\nehci_dbg(ehci, "Port status(0x%x) is wrong\n", temp);\r\nspin_unlock_irq(&ehci->lock);\r\nmsleep(8);\r\nspin_lock_irq(&ehci->lock);\r\nbreak;\r\n}\r\n}\r\nif (ehci->shutdown)\r\ngoto shutdown;\r\nif (ehci->bus_suspended && ehci->has_tdi_phy_lpm) {\r\ni = HCS_N_PORTS(ehci->hcs_params);\r\nwhile (i--) {\r\nif (test_bit(i, &ehci->bus_suspended)) {\r\nu32 __iomem *hostpc_reg =\r\n&ehci->regs->hostpc[i];\r\ntemp = ehci_readl(ehci, hostpc_reg);\r\nehci_writel(ehci, temp & ~HOSTPC_PHCD,\r\nhostpc_reg);\r\n}\r\n}\r\nspin_unlock_irq(&ehci->lock);\r\nmsleep(5);\r\nspin_lock_irq(&ehci->lock);\r\nif (ehci->shutdown)\r\ngoto shutdown;\r\n}\r\ni = HCS_N_PORTS (ehci->hcs_params);\r\nwhile (i--) {\r\ntemp = ehci_readl(ehci, &ehci->regs->port_status [i]);\r\ntemp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);\r\nif (test_bit(i, &ehci->bus_suspended) &&\r\n(temp & PORT_SUSPEND)) {\r\ntemp |= PORT_RESUME;\r\nset_bit(i, &resume_needed);\r\n}\r\nehci_writel(ehci, temp, &ehci->regs->port_status [i]);\r\n}\r\nif (resume_needed) {\r\nspin_unlock_irq(&ehci->lock);\r\nmsleep(20);\r\nspin_lock_irq(&ehci->lock);\r\nif (ehci->shutdown)\r\ngoto shutdown;\r\n}\r\ni = HCS_N_PORTS (ehci->hcs_params);\r\nwhile (i--) {\r\ntemp = ehci_readl(ehci, &ehci->regs->port_status [i]);\r\nif (test_bit(i, &resume_needed)) {\r\ntemp &= ~(PORT_RWC_BITS | PORT_SUSPEND | PORT_RESUME);\r\nehci_writel(ehci, temp, &ehci->regs->port_status [i]);\r\n}\r\n}\r\nehci->next_statechange = jiffies + msecs_to_jiffies(5);\r\nspin_unlock_irq(&ehci->lock);\r\nehci_handover_companion_ports(ehci);\r\nspin_lock_irq(&ehci->lock);\r\nif (ehci->shutdown)\r\ngoto shutdown;\r\nehci_writel(ehci, INTR_MASK, &ehci->regs->intr_enable);\r\n(void) ehci_readl(ehci, &ehci->regs->intr_enable);\r\nspin_unlock_irq(&ehci->lock);\r\nreturn 0;\r\nshutdown:\r\nspin_unlock_irq(&ehci->lock);\r\nreturn -ESHUTDOWN;\r\n}\r\nstatic void set_owner(struct ehci_hcd *ehci, int portnum, int new_owner)\r\n{\r\nu32 __iomem *status_reg;\r\nu32 port_status;\r\nint try;\r\nstatus_reg = &ehci->regs->port_status[portnum];\r\nfor (try = 4; try > 0; --try) {\r\nspin_lock_irq(&ehci->lock);\r\nport_status = ehci_readl(ehci, status_reg);\r\nif ((port_status & PORT_OWNER) == new_owner\r\n|| (port_status & (PORT_OWNER | PORT_CONNECT))\r\n== 0)\r\ntry = 0;\r\nelse {\r\nport_status ^= PORT_OWNER;\r\nport_status &= ~(PORT_PE | PORT_RWC_BITS);\r\nehci_writel(ehci, port_status, status_reg);\r\n}\r\nspin_unlock_irq(&ehci->lock);\r\nif (try > 1)\r\nmsleep(5);\r\n}\r\n}\r\nstatic int check_reset_complete (\r\nstruct ehci_hcd *ehci,\r\nint index,\r\nu32 __iomem *status_reg,\r\nint port_status\r\n) {\r\nif (!(port_status & PORT_CONNECT))\r\nreturn port_status;\r\nif (!(port_status & PORT_PE)) {\r\nif (ehci_is_TDI(ehci)) {\r\nehci_dbg (ehci,\r\n"Failed to enable port %d on root hub TT\n",\r\nindex+1);\r\nreturn port_status;\r\n}\r\nehci_dbg (ehci, "port %d full speed --> companion\n",\r\nindex + 1);\r\nport_status |= PORT_OWNER;\r\nport_status &= ~PORT_RWC_BITS;\r\nehci_writel(ehci, port_status, status_reg);\r\nif (ehci->has_amcc_usb23)\r\nset_ohci_hcfs(ehci, 1);\r\n} else {\r\nehci_dbg(ehci, "port %d reset complete, port enabled\n",\r\nindex + 1);\r\nif (ehci->has_amcc_usb23)\r\nset_ohci_hcfs(ehci, 0);\r\n}\r\nreturn port_status;\r\n}\r\nstatic int\r\nehci_hub_status_data (struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nu32 temp, status;\r\nu32 mask;\r\nint ports, i, retval = 1;\r\nunsigned long flags;\r\nu32 ppcd = ~0;\r\nbuf [0] = 0;\r\nports = HCS_N_PORTS (ehci->hcs_params);\r\nif (ports > 7) {\r\nbuf [1] = 0;\r\nretval++;\r\n}\r\nstatus = ehci->resuming_ports;\r\nif (!ignore_oc)\r\nmask = PORT_CSC | PORT_PEC | PORT_OCC;\r\nelse\r\nmask = PORT_CSC | PORT_PEC;\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nif (ehci->has_ppcd)\r\nppcd = ehci_readl(ehci, &ehci->regs->status) >> 16;\r\nfor (i = 0; i < ports; i++) {\r\nif (ppcd & (1 << i))\r\ntemp = ehci_readl(ehci, &ehci->regs->port_status[i]);\r\nelse\r\ntemp = 0;\r\nif ((temp & mask) != 0 || test_bit(i, &ehci->port_c_suspend)\r\n|| (ehci->reset_done[i] && time_after_eq(\r\njiffies, ehci->reset_done[i]))) {\r\nif (i < 7)\r\nbuf [0] |= 1 << (i + 1);\r\nelse\r\nbuf [1] |= 1 << (i - 7);\r\nstatus = STS_PCD;\r\n}\r\n}\r\nif (ehci->resuming_ports)\r\nmod_timer(&hcd->rh_timer, jiffies + msecs_to_jiffies(25));\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nreturn status ? retval : 0;\r\n}\r\nstatic void\r\nehci_hub_descriptor (\r\nstruct ehci_hcd *ehci,\r\nstruct usb_hub_descriptor *desc\r\n) {\r\nint ports = HCS_N_PORTS (ehci->hcs_params);\r\nu16 temp;\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bPwrOn2PwrGood = 10;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = ports;\r\ntemp = 1 + (ports / 8);\r\ndesc->bDescLength = 7 + 2 * temp;\r\nmemset(&desc->u.hs.DeviceRemovable[0], 0, temp);\r\nmemset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);\r\ntemp = 0x0008;\r\nif (HCS_PPC (ehci->hcs_params))\r\ntemp |= 0x0001;\r\nelse\r\ntemp |= 0x0002;\r\n#if 0\r\nif (HCS_INDICATOR (ehci->hcs_params))\r\ntemp |= 0x0080;\r\n#endif\r\ndesc->wHubCharacteristics = cpu_to_le16(temp);\r\n}\r\nstatic void usb_ehset_completion(struct urb *urb)\r\n{\r\nstruct completion *done = urb->context;\r\ncomplete(done);\r\n}\r\nstatic struct urb *request_single_step_set_feature_urb(\r\nstruct usb_device *udev,\r\nvoid *dr,\r\nvoid *buf,\r\nstruct completion *done\r\n) {\r\nstruct urb *urb;\r\nstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\r\nstruct usb_host_endpoint *ep;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn NULL;\r\nurb->pipe = usb_rcvctrlpipe(udev, 0);\r\nep = (usb_pipein(urb->pipe) ? udev->ep_in : udev->ep_out)\r\n[usb_pipeendpoint(urb->pipe)];\r\nif (!ep) {\r\nusb_free_urb(urb);\r\nreturn NULL;\r\n}\r\nurb->ep = ep;\r\nurb->dev = udev;\r\nurb->setup_packet = (void *)dr;\r\nurb->transfer_buffer = buf;\r\nurb->transfer_buffer_length = USB_DT_DEVICE_SIZE;\r\nurb->complete = usb_ehset_completion;\r\nurb->status = -EINPROGRESS;\r\nurb->actual_length = 0;\r\nurb->transfer_flags = URB_DIR_IN;\r\nusb_get_urb(urb);\r\natomic_inc(&urb->use_count);\r\natomic_inc(&urb->dev->urbnum);\r\nurb->setup_dma = dma_map_single(\r\nhcd->self.controller,\r\nurb->setup_packet,\r\nsizeof(struct usb_ctrlrequest),\r\nDMA_TO_DEVICE);\r\nurb->transfer_dma = dma_map_single(\r\nhcd->self.controller,\r\nurb->transfer_buffer,\r\nurb->transfer_buffer_length,\r\nDMA_FROM_DEVICE);\r\nurb->context = done;\r\nreturn urb;\r\n}\r\nstatic int ehset_single_step_set_feature(struct usb_hcd *hcd, int port)\r\n{\r\nint retval = -ENOMEM;\r\nstruct usb_ctrlrequest *dr;\r\nstruct urb *urb;\r\nstruct usb_device *udev;\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct usb_device_descriptor *buf;\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nudev = usb_hub_find_child(hcd->self.root_hub, port);\r\nif (!udev) {\r\nehci_err(ehci, "No device attached to the RootHub\n");\r\nreturn -ENODEV;\r\n}\r\nbuf = kmalloc(USB_DT_DEVICE_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ndr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\r\nif (!dr) {\r\nkfree(buf);\r\nreturn -ENOMEM;\r\n}\r\ndr->bRequestType = USB_DIR_IN;\r\ndr->bRequest = USB_REQ_GET_DESCRIPTOR;\r\ndr->wValue = cpu_to_le16(USB_DT_DEVICE << 8);\r\ndr->wIndex = 0;\r\ndr->wLength = cpu_to_le16(USB_DT_DEVICE_SIZE);\r\nurb = request_single_step_set_feature_urb(udev, dr, buf, &done);\r\nif (!urb)\r\ngoto cleanup;\r\nretval = submit_single_step_set_feature(hcd, urb, 1);\r\nif (retval)\r\ngoto out1;\r\nif (!wait_for_completion_timeout(&done, msecs_to_jiffies(2000))) {\r\nusb_kill_urb(urb);\r\nretval = -ETIMEDOUT;\r\nehci_err(ehci, "%s SETUP stage timed out on ep0\n", __func__);\r\ngoto out1;\r\n}\r\nmsleep(15 * 1000);\r\nurb->status = -EINPROGRESS;\r\nusb_get_urb(urb);\r\natomic_inc(&urb->use_count);\r\natomic_inc(&urb->dev->urbnum);\r\nretval = submit_single_step_set_feature(hcd, urb, 0);\r\nif (!retval && !wait_for_completion_timeout(&done,\r\nmsecs_to_jiffies(2000))) {\r\nusb_kill_urb(urb);\r\nretval = -ETIMEDOUT;\r\nehci_err(ehci, "%s IN stage timed out on ep0\n", __func__);\r\n}\r\nout1:\r\nusb_free_urb(urb);\r\ncleanup:\r\nkfree(dr);\r\nkfree(buf);\r\nreturn retval;\r\n}\r\nstatic int ehci_hub_control (\r\nstruct usb_hcd *hcd,\r\nu16 typeReq,\r\nu16 wValue,\r\nu16 wIndex,\r\nchar *buf,\r\nu16 wLength\r\n) {\r\nstruct ehci_hcd *ehci = hcd_to_ehci (hcd);\r\nint ports = HCS_N_PORTS (ehci->hcs_params);\r\nu32 __iomem *status_reg = &ehci->regs->port_status[\r\n(wIndex & 0xff) - 1];\r\nu32 __iomem *hostpc_reg = &ehci->regs->hostpc[(wIndex & 0xff) - 1];\r\nu32 temp, temp1, status;\r\nunsigned long flags;\r\nint retval = 0;\r\nunsigned selector;\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = ehci_readl(ehci, status_reg);\r\ntemp &= ~PORT_RWC_BITS;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nehci_writel(ehci, temp & ~PORT_PE, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\nehci_writel(ehci, temp | PORT_PEC, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (temp & PORT_RESET)\r\ngoto error;\r\nif (ehci->no_selective_suspend)\r\nbreak;\r\n#ifdef CONFIG_USB_OTG\r\nif ((hcd->self.otg_port == (wIndex + 1))\r\n&& hcd->self.b_hnp_enable) {\r\notg_start_hnp(hcd->phy->otg);\r\nbreak;\r\n}\r\n#endif\r\nif (!(temp & PORT_SUSPEND))\r\nbreak;\r\nif ((temp & PORT_PE) == 0)\r\ngoto error;\r\nif (ehci->has_tdi_phy_lpm) {\r\ntemp1 = ehci_readl(ehci, hostpc_reg);\r\nehci_writel(ehci, temp1 & ~HOSTPC_PHCD,\r\nhostpc_reg);\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nmsleep(5);\r\nspin_lock_irqsave(&ehci->lock, flags);\r\n}\r\ntemp &= ~PORT_WAKE_BITS;\r\nehci_writel(ehci, temp | PORT_RESUME, status_reg);\r\nehci->reset_done[wIndex] = jiffies\r\n+ msecs_to_jiffies(20);\r\nset_bit(wIndex, &ehci->resuming_ports);\r\nusb_hcd_start_port_resume(&hcd->self, wIndex);\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\nclear_bit(wIndex, &ehci->port_c_suspend);\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nif (HCS_PPC (ehci->hcs_params))\r\nehci_writel(ehci, temp & ~PORT_POWER,\r\nstatus_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\nehci_writel(ehci, temp | PORT_CSC, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\nehci_writel(ehci, temp | PORT_OCC, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nehci_readl(ehci, &ehci->regs->command);\r\nbreak;\r\ncase GetHubDescriptor:\r\nehci_hub_descriptor (ehci, (struct usb_hub_descriptor *)\r\nbuf);\r\nbreak;\r\ncase GetHubStatus:\r\nmemset (buf, 0, 4);\r\nbreak;\r\ncase GetPortStatus:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\nstatus = 0;\r\ntemp = ehci_readl(ehci, status_reg);\r\nif (temp & PORT_CSC)\r\nstatus |= USB_PORT_STAT_C_CONNECTION << 16;\r\nif (temp & PORT_PEC)\r\nstatus |= USB_PORT_STAT_C_ENABLE << 16;\r\nif ((temp & PORT_OCC) && !ignore_oc){\r\nstatus |= USB_PORT_STAT_C_OVERCURRENT << 16;\r\nif (((temp & PORT_OC) || (ehci->need_oc_pp_cycle))\r\n&& HCS_PPC(ehci->hcs_params)) {\r\nehci_writel(ehci,\r\ntemp & ~(PORT_RWC_BITS | PORT_POWER),\r\nstatus_reg);\r\ntemp = ehci_readl(ehci, status_reg);\r\n}\r\n}\r\nif (!ehci->reset_done[wIndex]) {\r\nif (temp & PORT_RESUME) {\r\nehci->reset_done[wIndex] = jiffies\r\n+ msecs_to_jiffies(20);\r\nusb_hcd_start_port_resume(&hcd->self, wIndex);\r\nset_bit(wIndex, &ehci->resuming_ports);\r\nmod_timer(&ehci_to_hcd(ehci)->rh_timer,\r\nehci->reset_done[wIndex]);\r\n}\r\n} else if (!time_after_eq(jiffies, ehci->reset_done[wIndex])) {\r\n;\r\n} else if (test_bit(wIndex, &ehci->resuming_ports)) {\r\nclear_bit(wIndex, &ehci->suspended_ports);\r\nset_bit(wIndex, &ehci->port_c_suspend);\r\nehci->reset_done[wIndex] = 0;\r\nusb_hcd_end_port_resume(&hcd->self, wIndex);\r\ntemp &= ~(PORT_RWC_BITS | PORT_SUSPEND | PORT_RESUME);\r\nehci_writel(ehci, temp, status_reg);\r\nclear_bit(wIndex, &ehci->resuming_ports);\r\nretval = ehci_handshake(ehci, status_reg,\r\nPORT_RESUME, 0, 2000 );\r\nif (retval != 0) {\r\nehci_err(ehci, "port %d resume error %d\n",\r\nwIndex + 1, retval);\r\ngoto error;\r\n}\r\ntemp = ehci_readl(ehci, status_reg);\r\n} else {\r\nstatus |= USB_PORT_STAT_C_RESET << 16;\r\nehci->reset_done [wIndex] = 0;\r\nehci_writel(ehci, temp & ~(PORT_RWC_BITS | PORT_RESET),\r\nstatus_reg);\r\nretval = ehci_handshake(ehci, status_reg,\r\nPORT_RESET, 0, 1000);\r\nif (retval != 0) {\r\nehci_err (ehci, "port %d reset error %d\n",\r\nwIndex + 1, retval);\r\ngoto error;\r\n}\r\ntemp = check_reset_complete (ehci, wIndex, status_reg,\r\nehci_readl(ehci, status_reg));\r\n}\r\nif ((temp & PORT_CONNECT) &&\r\ntest_bit(wIndex, &ehci->companion_ports)) {\r\ntemp &= ~PORT_RWC_BITS;\r\ntemp |= PORT_OWNER;\r\nehci_writel(ehci, temp, status_reg);\r\nehci_dbg(ehci, "port %d --> companion\n", wIndex + 1);\r\ntemp = ehci_readl(ehci, status_reg);\r\n}\r\nif (temp & PORT_CONNECT) {\r\nstatus |= USB_PORT_STAT_CONNECTION;\r\nif (ehci->has_hostpc) {\r\ntemp1 = ehci_readl(ehci, hostpc_reg);\r\nstatus |= ehci_port_speed(ehci, temp1);\r\n} else\r\nstatus |= ehci_port_speed(ehci, temp);\r\n}\r\nif (temp & PORT_PE)\r\nstatus |= USB_PORT_STAT_ENABLE;\r\nif (temp & (PORT_SUSPEND|PORT_RESUME)) {\r\nstatus |= USB_PORT_STAT_SUSPEND;\r\n} else if (test_bit(wIndex, &ehci->suspended_ports)) {\r\nclear_bit(wIndex, &ehci->suspended_ports);\r\nclear_bit(wIndex, &ehci->resuming_ports);\r\nehci->reset_done[wIndex] = 0;\r\nif (temp & PORT_PE)\r\nset_bit(wIndex, &ehci->port_c_suspend);\r\nusb_hcd_end_port_resume(&hcd->self, wIndex);\r\n}\r\nif (temp & PORT_OC)\r\nstatus |= USB_PORT_STAT_OVERCURRENT;\r\nif (temp & PORT_RESET)\r\nstatus |= USB_PORT_STAT_RESET;\r\nif (temp & PORT_POWER)\r\nstatus |= USB_PORT_STAT_POWER;\r\nif (test_bit(wIndex, &ehci->port_c_suspend))\r\nstatus |= USB_PORT_STAT_C_SUSPEND << 16;\r\nif (status & ~0xffff)\r\ndbg_port(ehci, "GetStatus", wIndex + 1, temp);\r\nput_unaligned_le32(status, buf);\r\nbreak;\r\ncase SetHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase SetPortFeature:\r\nselector = wIndex >> 8;\r\nwIndex &= 0xff;\r\nif (unlikely(ehci->debug)) {\r\nif (wIndex == HCS_DEBUG_PORT(ehci->hcs_params) &&\r\n(readl(&ehci->debug->control) & DBGP_ENABLED)) {\r\nretval = -ENODEV;\r\ngoto error_exit;\r\n}\r\n}\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = ehci_readl(ehci, status_reg);\r\nif (temp & PORT_OWNER)\r\nbreak;\r\ntemp &= ~PORT_RWC_BITS;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (ehci->no_selective_suspend)\r\nbreak;\r\nif ((temp & PORT_PE) == 0\r\n|| (temp & PORT_RESET) != 0)\r\ngoto error;\r\ntemp &= ~PORT_WKCONN_E;\r\ntemp |= PORT_WKDISC_E | PORT_WKOC_E;\r\nehci_writel(ehci, temp | PORT_SUSPEND, status_reg);\r\nif (ehci->has_tdi_phy_lpm) {\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nmsleep(5);\r\nspin_lock_irqsave(&ehci->lock, flags);\r\ntemp1 = ehci_readl(ehci, hostpc_reg);\r\nehci_writel(ehci, temp1 | HOSTPC_PHCD,\r\nhostpc_reg);\r\ntemp1 = ehci_readl(ehci, hostpc_reg);\r\nehci_dbg(ehci, "Port%d phy low pwr mode %s\n",\r\nwIndex, (temp1 & HOSTPC_PHCD) ?\r\n"succeeded" : "failed");\r\n}\r\nset_bit(wIndex, &ehci->suspended_ports);\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nif (HCS_PPC (ehci->hcs_params))\r\nehci_writel(ehci, temp | PORT_POWER,\r\nstatus_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nif (temp & (PORT_SUSPEND|PORT_RESUME))\r\ngoto error;\r\nif ((temp & (PORT_PE|PORT_CONNECT)) == PORT_CONNECT\r\n&& !ehci_is_TDI(ehci)\r\n&& PORT_USB11 (temp)) {\r\nehci_dbg (ehci,\r\n"port %d low speed --> companion\n",\r\nwIndex + 1);\r\ntemp |= PORT_OWNER;\r\n} else {\r\ntemp |= PORT_RESET;\r\ntemp &= ~PORT_PE;\r\nehci->reset_done [wIndex] = jiffies\r\n+ msecs_to_jiffies (50);\r\n}\r\nehci_writel(ehci, temp, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_TEST:\r\n#ifdef CONFIG_USB_HCD_TEST_MODE\r\nif (selector == EHSET_TEST_SINGLE_STEP_SET_FEATURE) {\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nretval = ehset_single_step_set_feature(hcd,\r\nwIndex);\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nbreak;\r\n}\r\n#endif\r\nif (!selector || selector > 5)\r\ngoto error;\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nehci_quiesce(ehci);\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nwhile (ports--) {\r\nu32 __iomem *sreg =\r\n&ehci->regs->port_status[ports];\r\ntemp = ehci_readl(ehci, sreg) & ~PORT_RWC_BITS;\r\nif (temp & PORT_PE)\r\nehci_writel(ehci, temp | PORT_SUSPEND,\r\nsreg);\r\n}\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nehci_halt(ehci);\r\nspin_lock_irqsave(&ehci->lock, flags);\r\ntemp = ehci_readl(ehci, status_reg);\r\ntemp |= selector << 16;\r\nehci_writel(ehci, temp, status_reg);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nehci_readl(ehci, &ehci->regs->command);\r\nbreak;\r\ndefault:\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nerror_exit:\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void ehci_relinquish_port(struct usb_hcd *hcd, int portnum)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nif (ehci_is_TDI(ehci))\r\nreturn;\r\nset_owner(ehci, --portnum, PORT_OWNER);\r\n}\r\nstatic int ehci_port_handed_over(struct usb_hcd *hcd, int portnum)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nu32 __iomem *reg;\r\nif (ehci_is_TDI(ehci))\r\nreturn 0;\r\nreg = &ehci->regs->port_status[portnum - 1];\r\nreturn ehci_readl(ehci, reg) & PORT_OWNER;\r\n}
