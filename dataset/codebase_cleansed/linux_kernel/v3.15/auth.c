static int param_set_hashtbl_sz(const char *val, const struct kernel_param *kp)\r\n{\r\nunsigned long num;\r\nunsigned int nbits;\r\nint ret;\r\nif (!val)\r\ngoto out_inval;\r\nret = strict_strtoul(val, 0, &num);\r\nif (ret == -EINVAL)\r\ngoto out_inval;\r\nnbits = fls(num);\r\nif (num > (1U << nbits))\r\nnbits++;\r\nif (nbits > MAX_HASHTABLE_BITS || nbits < 2)\r\ngoto out_inval;\r\n*(unsigned int *)kp->arg = nbits;\r\nreturn 0;\r\nout_inval:\r\nreturn -EINVAL;\r\n}\r\nstatic int param_get_hashtbl_sz(char *buffer, const struct kernel_param *kp)\r\n{\r\nunsigned int nbits;\r\nnbits = *(unsigned int *)kp->arg;\r\nreturn sprintf(buffer, "%u", 1U << nbits);\r\n}\r\nstatic u32\r\npseudoflavor_to_flavor(u32 flavor) {\r\nif (flavor > RPC_AUTH_MAXFLAVOR)\r\nreturn RPC_AUTH_GSS;\r\nreturn flavor;\r\n}\r\nint\r\nrpcauth_register(const struct rpc_authops *ops)\r\n{\r\nrpc_authflavor_t flavor;\r\nint ret = -EPERM;\r\nif ((flavor = ops->au_flavor) >= RPC_AUTH_MAXFLAVOR)\r\nreturn -EINVAL;\r\nspin_lock(&rpc_authflavor_lock);\r\nif (auth_flavors[flavor] == NULL) {\r\nauth_flavors[flavor] = ops;\r\nret = 0;\r\n}\r\nspin_unlock(&rpc_authflavor_lock);\r\nreturn ret;\r\n}\r\nint\r\nrpcauth_unregister(const struct rpc_authops *ops)\r\n{\r\nrpc_authflavor_t flavor;\r\nint ret = -EPERM;\r\nif ((flavor = ops->au_flavor) >= RPC_AUTH_MAXFLAVOR)\r\nreturn -EINVAL;\r\nspin_lock(&rpc_authflavor_lock);\r\nif (auth_flavors[flavor] == ops) {\r\nauth_flavors[flavor] = NULL;\r\nret = 0;\r\n}\r\nspin_unlock(&rpc_authflavor_lock);\r\nreturn ret;\r\n}\r\nrpc_authflavor_t\r\nrpcauth_get_pseudoflavor(rpc_authflavor_t flavor, struct rpcsec_gss_info *info)\r\n{\r\nconst struct rpc_authops *ops;\r\nrpc_authflavor_t pseudoflavor;\r\nops = auth_flavors[flavor];\r\nif (ops == NULL)\r\nrequest_module("rpc-auth-%u", flavor);\r\nspin_lock(&rpc_authflavor_lock);\r\nops = auth_flavors[flavor];\r\nif (ops == NULL || !try_module_get(ops->owner)) {\r\nspin_unlock(&rpc_authflavor_lock);\r\nreturn RPC_AUTH_MAXFLAVOR;\r\n}\r\nspin_unlock(&rpc_authflavor_lock);\r\npseudoflavor = flavor;\r\nif (ops->info2flavor != NULL)\r\npseudoflavor = ops->info2flavor(info);\r\nmodule_put(ops->owner);\r\nreturn pseudoflavor;\r\n}\r\nint\r\nrpcauth_get_gssinfo(rpc_authflavor_t pseudoflavor, struct rpcsec_gss_info *info)\r\n{\r\nrpc_authflavor_t flavor = pseudoflavor_to_flavor(pseudoflavor);\r\nconst struct rpc_authops *ops;\r\nint result;\r\nif (flavor >= RPC_AUTH_MAXFLAVOR)\r\nreturn -EINVAL;\r\nops = auth_flavors[flavor];\r\nif (ops == NULL)\r\nrequest_module("rpc-auth-%u", flavor);\r\nspin_lock(&rpc_authflavor_lock);\r\nops = auth_flavors[flavor];\r\nif (ops == NULL || !try_module_get(ops->owner)) {\r\nspin_unlock(&rpc_authflavor_lock);\r\nreturn -ENOENT;\r\n}\r\nspin_unlock(&rpc_authflavor_lock);\r\nresult = -ENOENT;\r\nif (ops->flavor2info != NULL)\r\nresult = ops->flavor2info(pseudoflavor, info);\r\nmodule_put(ops->owner);\r\nreturn result;\r\n}\r\nint\r\nrpcauth_list_flavors(rpc_authflavor_t *array, int size)\r\n{\r\nrpc_authflavor_t flavor;\r\nint result = 0;\r\nspin_lock(&rpc_authflavor_lock);\r\nfor (flavor = 0; flavor < RPC_AUTH_MAXFLAVOR; flavor++) {\r\nconst struct rpc_authops *ops = auth_flavors[flavor];\r\nrpc_authflavor_t pseudos[4];\r\nint i, len;\r\nif (result >= size) {\r\nresult = -ENOMEM;\r\nbreak;\r\n}\r\nif (ops == NULL)\r\ncontinue;\r\nif (ops->list_pseudoflavors == NULL) {\r\narray[result++] = ops->au_flavor;\r\ncontinue;\r\n}\r\nlen = ops->list_pseudoflavors(pseudos, ARRAY_SIZE(pseudos));\r\nif (len < 0) {\r\nresult = len;\r\nbreak;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nif (result >= size) {\r\nresult = -ENOMEM;\r\nbreak;\r\n}\r\narray[result++] = pseudos[i];\r\n}\r\n}\r\nspin_unlock(&rpc_authflavor_lock);\r\ndprintk("RPC: %s returns %d\n", __func__, result);\r\nreturn result;\r\n}\r\nstruct rpc_auth *\r\nrpcauth_create(struct rpc_auth_create_args *args, struct rpc_clnt *clnt)\r\n{\r\nstruct rpc_auth *auth;\r\nconst struct rpc_authops *ops;\r\nu32 flavor = pseudoflavor_to_flavor(args->pseudoflavor);\r\nauth = ERR_PTR(-EINVAL);\r\nif (flavor >= RPC_AUTH_MAXFLAVOR)\r\ngoto out;\r\nif ((ops = auth_flavors[flavor]) == NULL)\r\nrequest_module("rpc-auth-%u", flavor);\r\nspin_lock(&rpc_authflavor_lock);\r\nops = auth_flavors[flavor];\r\nif (ops == NULL || !try_module_get(ops->owner)) {\r\nspin_unlock(&rpc_authflavor_lock);\r\ngoto out;\r\n}\r\nspin_unlock(&rpc_authflavor_lock);\r\nauth = ops->create(args, clnt);\r\nmodule_put(ops->owner);\r\nif (IS_ERR(auth))\r\nreturn auth;\r\nif (clnt->cl_auth)\r\nrpcauth_release(clnt->cl_auth);\r\nclnt->cl_auth = auth;\r\nout:\r\nreturn auth;\r\n}\r\nvoid\r\nrpcauth_release(struct rpc_auth *auth)\r\n{\r\nif (!atomic_dec_and_test(&auth->au_count))\r\nreturn;\r\nauth->au_ops->destroy(auth);\r\n}\r\nstatic void\r\nrpcauth_unhash_cred_locked(struct rpc_cred *cred)\r\n{\r\nhlist_del_rcu(&cred->cr_hash);\r\nsmp_mb__before_clear_bit();\r\nclear_bit(RPCAUTH_CRED_HASHED, &cred->cr_flags);\r\n}\r\nstatic int\r\nrpcauth_unhash_cred(struct rpc_cred *cred)\r\n{\r\nspinlock_t *cache_lock;\r\nint ret;\r\ncache_lock = &cred->cr_auth->au_credcache->lock;\r\nspin_lock(cache_lock);\r\nret = atomic_read(&cred->cr_count) == 0;\r\nif (ret)\r\nrpcauth_unhash_cred_locked(cred);\r\nspin_unlock(cache_lock);\r\nreturn ret;\r\n}\r\nint\r\nrpcauth_init_credcache(struct rpc_auth *auth)\r\n{\r\nstruct rpc_cred_cache *new;\r\nunsigned int hashsize;\r\nnew = kmalloc(sizeof(*new), GFP_KERNEL);\r\nif (!new)\r\ngoto out_nocache;\r\nnew->hashbits = auth_hashbits;\r\nhashsize = 1U << new->hashbits;\r\nnew->hashtable = kcalloc(hashsize, sizeof(new->hashtable[0]), GFP_KERNEL);\r\nif (!new->hashtable)\r\ngoto out_nohashtbl;\r\nspin_lock_init(&new->lock);\r\nauth->au_credcache = new;\r\nreturn 0;\r\nout_nohashtbl:\r\nkfree(new);\r\nout_nocache:\r\nreturn -ENOMEM;\r\n}\r\nint\r\nrpcauth_key_timeout_notify(struct rpc_auth *auth, struct rpc_cred *cred)\r\n{\r\nif (!cred->cr_auth->au_ops->key_timeout)\r\nreturn 0;\r\nreturn cred->cr_auth->au_ops->key_timeout(auth, cred);\r\n}\r\nbool\r\nrpcauth_cred_key_to_expire(struct rpc_cred *cred)\r\n{\r\nif (!cred->cr_ops->crkey_to_expire)\r\nreturn false;\r\nreturn cred->cr_ops->crkey_to_expire(cred);\r\n}\r\nstatic inline\r\nvoid rpcauth_destroy_credlist(struct list_head *head)\r\n{\r\nstruct rpc_cred *cred;\r\nwhile (!list_empty(head)) {\r\ncred = list_entry(head->next, struct rpc_cred, cr_lru);\r\nlist_del_init(&cred->cr_lru);\r\nput_rpccred(cred);\r\n}\r\n}\r\nvoid\r\nrpcauth_clear_credcache(struct rpc_cred_cache *cache)\r\n{\r\nLIST_HEAD(free);\r\nstruct hlist_head *head;\r\nstruct rpc_cred *cred;\r\nunsigned int hashsize = 1U << cache->hashbits;\r\nint i;\r\nspin_lock(&rpc_credcache_lock);\r\nspin_lock(&cache->lock);\r\nfor (i = 0; i < hashsize; i++) {\r\nhead = &cache->hashtable[i];\r\nwhile (!hlist_empty(head)) {\r\ncred = hlist_entry(head->first, struct rpc_cred, cr_hash);\r\nget_rpccred(cred);\r\nif (!list_empty(&cred->cr_lru)) {\r\nlist_del(&cred->cr_lru);\r\nnumber_cred_unused--;\r\n}\r\nlist_add_tail(&cred->cr_lru, &free);\r\nrpcauth_unhash_cred_locked(cred);\r\n}\r\n}\r\nspin_unlock(&cache->lock);\r\nspin_unlock(&rpc_credcache_lock);\r\nrpcauth_destroy_credlist(&free);\r\n}\r\nvoid\r\nrpcauth_destroy_credcache(struct rpc_auth *auth)\r\n{\r\nstruct rpc_cred_cache *cache = auth->au_credcache;\r\nif (cache) {\r\nauth->au_credcache = NULL;\r\nrpcauth_clear_credcache(cache);\r\nkfree(cache->hashtable);\r\nkfree(cache);\r\n}\r\n}\r\nstatic long\r\nrpcauth_prune_expired(struct list_head *free, int nr_to_scan)\r\n{\r\nspinlock_t *cache_lock;\r\nstruct rpc_cred *cred, *next;\r\nunsigned long expired = jiffies - RPC_AUTH_EXPIRY_MORATORIUM;\r\nlong freed = 0;\r\nlist_for_each_entry_safe(cred, next, &cred_unused, cr_lru) {\r\nif (nr_to_scan-- == 0)\r\nbreak;\r\nif (time_in_range(cred->cr_expire, expired, jiffies) &&\r\ntest_bit(RPCAUTH_CRED_HASHED, &cred->cr_flags) != 0)\r\nbreak;\r\nlist_del_init(&cred->cr_lru);\r\nnumber_cred_unused--;\r\nfreed++;\r\nif (atomic_read(&cred->cr_count) != 0)\r\ncontinue;\r\ncache_lock = &cred->cr_auth->au_credcache->lock;\r\nspin_lock(cache_lock);\r\nif (atomic_read(&cred->cr_count) == 0) {\r\nget_rpccred(cred);\r\nlist_add_tail(&cred->cr_lru, free);\r\nrpcauth_unhash_cred_locked(cred);\r\n}\r\nspin_unlock(cache_lock);\r\n}\r\nreturn freed;\r\n}\r\nstatic unsigned long\r\nrpcauth_cache_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\r\n{\r\nLIST_HEAD(free);\r\nunsigned long freed;\r\nif ((sc->gfp_mask & GFP_KERNEL) != GFP_KERNEL)\r\nreturn SHRINK_STOP;\r\nif (list_empty(&cred_unused))\r\nreturn SHRINK_STOP;\r\nspin_lock(&rpc_credcache_lock);\r\nfreed = rpcauth_prune_expired(&free, sc->nr_to_scan);\r\nspin_unlock(&rpc_credcache_lock);\r\nrpcauth_destroy_credlist(&free);\r\nreturn freed;\r\n}\r\nstatic unsigned long\r\nrpcauth_cache_shrink_count(struct shrinker *shrink, struct shrink_control *sc)\r\n{\r\nreturn (number_cred_unused / 100) * sysctl_vfs_cache_pressure;\r\n}\r\nstruct rpc_cred *\r\nrpcauth_lookup_credcache(struct rpc_auth *auth, struct auth_cred * acred,\r\nint flags)\r\n{\r\nLIST_HEAD(free);\r\nstruct rpc_cred_cache *cache = auth->au_credcache;\r\nstruct rpc_cred *cred = NULL,\r\n*entry, *new;\r\nunsigned int nr;\r\nnr = hash_long(from_kuid(&init_user_ns, acred->uid), cache->hashbits);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(entry, &cache->hashtable[nr], cr_hash) {\r\nif (!entry->cr_ops->crmatch(acred, entry, flags))\r\ncontinue;\r\nspin_lock(&cache->lock);\r\nif (test_bit(RPCAUTH_CRED_HASHED, &entry->cr_flags) == 0) {\r\nspin_unlock(&cache->lock);\r\ncontinue;\r\n}\r\ncred = get_rpccred(entry);\r\nspin_unlock(&cache->lock);\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (cred != NULL)\r\ngoto found;\r\nnew = auth->au_ops->crcreate(auth, acred, flags);\r\nif (IS_ERR(new)) {\r\ncred = new;\r\ngoto out;\r\n}\r\nspin_lock(&cache->lock);\r\nhlist_for_each_entry(entry, &cache->hashtable[nr], cr_hash) {\r\nif (!entry->cr_ops->crmatch(acred, entry, flags))\r\ncontinue;\r\ncred = get_rpccred(entry);\r\nbreak;\r\n}\r\nif (cred == NULL) {\r\ncred = new;\r\nset_bit(RPCAUTH_CRED_HASHED, &cred->cr_flags);\r\nhlist_add_head_rcu(&cred->cr_hash, &cache->hashtable[nr]);\r\n} else\r\nlist_add_tail(&new->cr_lru, &free);\r\nspin_unlock(&cache->lock);\r\nfound:\r\nif (test_bit(RPCAUTH_CRED_NEW, &cred->cr_flags) &&\r\ncred->cr_ops->cr_init != NULL &&\r\n!(flags & RPCAUTH_LOOKUP_NEW)) {\r\nint res = cred->cr_ops->cr_init(auth, cred);\r\nif (res < 0) {\r\nput_rpccred(cred);\r\ncred = ERR_PTR(res);\r\n}\r\n}\r\nrpcauth_destroy_credlist(&free);\r\nout:\r\nreturn cred;\r\n}\r\nstruct rpc_cred *\r\nrpcauth_lookupcred(struct rpc_auth *auth, int flags)\r\n{\r\nstruct auth_cred acred;\r\nstruct rpc_cred *ret;\r\nconst struct cred *cred = current_cred();\r\ndprintk("RPC: looking up %s cred\n",\r\nauth->au_ops->au_name);\r\nmemset(&acred, 0, sizeof(acred));\r\nacred.uid = cred->fsuid;\r\nacred.gid = cred->fsgid;\r\nacred.group_info = get_group_info(((struct cred *)cred)->group_info);\r\nret = auth->au_ops->lookup_cred(auth, &acred, flags);\r\nput_group_info(acred.group_info);\r\nreturn ret;\r\n}\r\nvoid\r\nrpcauth_init_cred(struct rpc_cred *cred, const struct auth_cred *acred,\r\nstruct rpc_auth *auth, const struct rpc_credops *ops)\r\n{\r\nINIT_HLIST_NODE(&cred->cr_hash);\r\nINIT_LIST_HEAD(&cred->cr_lru);\r\natomic_set(&cred->cr_count, 1);\r\ncred->cr_auth = auth;\r\ncred->cr_ops = ops;\r\ncred->cr_expire = jiffies;\r\n#ifdef RPC_DEBUG\r\ncred->cr_magic = RPCAUTH_CRED_MAGIC;\r\n#endif\r\ncred->cr_uid = acred->uid;\r\n}\r\nstruct rpc_cred *\r\nrpcauth_generic_bind_cred(struct rpc_task *task, struct rpc_cred *cred, int lookupflags)\r\n{\r\ndprintk("RPC: %5u holding %s cred %p\n", task->tk_pid,\r\ncred->cr_auth->au_ops->au_name, cred);\r\nreturn get_rpccred(cred);\r\n}\r\nstatic struct rpc_cred *\r\nrpcauth_bind_root_cred(struct rpc_task *task, int lookupflags)\r\n{\r\nstruct rpc_auth *auth = task->tk_client->cl_auth;\r\nstruct auth_cred acred = {\r\n.uid = GLOBAL_ROOT_UID,\r\n.gid = GLOBAL_ROOT_GID,\r\n};\r\ndprintk("RPC: %5u looking up %s cred\n",\r\ntask->tk_pid, task->tk_client->cl_auth->au_ops->au_name);\r\nreturn auth->au_ops->lookup_cred(auth, &acred, lookupflags);\r\n}\r\nstatic struct rpc_cred *\r\nrpcauth_bind_new_cred(struct rpc_task *task, int lookupflags)\r\n{\r\nstruct rpc_auth *auth = task->tk_client->cl_auth;\r\ndprintk("RPC: %5u looking up %s cred\n",\r\ntask->tk_pid, auth->au_ops->au_name);\r\nreturn rpcauth_lookupcred(auth, lookupflags);\r\n}\r\nstatic int\r\nrpcauth_bindcred(struct rpc_task *task, struct rpc_cred *cred, int flags)\r\n{\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nstruct rpc_cred *new;\r\nint lookupflags = 0;\r\nif (flags & RPC_TASK_ASYNC)\r\nlookupflags |= RPCAUTH_LOOKUP_NEW;\r\nif (cred != NULL)\r\nnew = cred->cr_ops->crbind(task, cred, lookupflags);\r\nelse if (flags & RPC_TASK_ROOTCREDS)\r\nnew = rpcauth_bind_root_cred(task, lookupflags);\r\nelse\r\nnew = rpcauth_bind_new_cred(task, lookupflags);\r\nif (IS_ERR(new))\r\nreturn PTR_ERR(new);\r\nif (req->rq_cred != NULL)\r\nput_rpccred(req->rq_cred);\r\nreq->rq_cred = new;\r\nreturn 0;\r\n}\r\nvoid\r\nput_rpccred(struct rpc_cred *cred)\r\n{\r\nif (test_bit(RPCAUTH_CRED_HASHED, &cred->cr_flags) == 0) {\r\nif (atomic_dec_and_test(&cred->cr_count))\r\ncred->cr_ops->crdestroy(cred);\r\nreturn;\r\n}\r\nif (!atomic_dec_and_lock(&cred->cr_count, &rpc_credcache_lock))\r\nreturn;\r\nif (!list_empty(&cred->cr_lru)) {\r\nnumber_cred_unused--;\r\nlist_del_init(&cred->cr_lru);\r\n}\r\nif (test_bit(RPCAUTH_CRED_HASHED, &cred->cr_flags) != 0) {\r\nif (test_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags) != 0) {\r\ncred->cr_expire = jiffies;\r\nlist_add_tail(&cred->cr_lru, &cred_unused);\r\nnumber_cred_unused++;\r\ngoto out_nodestroy;\r\n}\r\nif (!rpcauth_unhash_cred(cred)) {\r\ngoto out_nodestroy;\r\n}\r\n}\r\nspin_unlock(&rpc_credcache_lock);\r\ncred->cr_ops->crdestroy(cred);\r\nreturn;\r\nout_nodestroy:\r\nspin_unlock(&rpc_credcache_lock);\r\n}\r\n__be32 *\r\nrpcauth_marshcred(struct rpc_task *task, __be32 *p)\r\n{\r\nstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\r\ndprintk("RPC: %5u marshaling %s cred %p\n",\r\ntask->tk_pid, cred->cr_auth->au_ops->au_name, cred);\r\nreturn cred->cr_ops->crmarshal(task, p);\r\n}\r\n__be32 *\r\nrpcauth_checkverf(struct rpc_task *task, __be32 *p)\r\n{\r\nstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\r\ndprintk("RPC: %5u validating %s cred %p\n",\r\ntask->tk_pid, cred->cr_auth->au_ops->au_name, cred);\r\nreturn cred->cr_ops->crvalidate(task, p);\r\n}\r\nstatic void rpcauth_wrap_req_encode(kxdreproc_t encode, struct rpc_rqst *rqstp,\r\n__be32 *data, void *obj)\r\n{\r\nstruct xdr_stream xdr;\r\nxdr_init_encode(&xdr, &rqstp->rq_snd_buf, data);\r\nencode(rqstp, &xdr, obj);\r\n}\r\nint\r\nrpcauth_wrap_req(struct rpc_task *task, kxdreproc_t encode, void *rqstp,\r\n__be32 *data, void *obj)\r\n{\r\nstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\r\ndprintk("RPC: %5u using %s cred %p to wrap rpc data\n",\r\ntask->tk_pid, cred->cr_ops->cr_name, cred);\r\nif (cred->cr_ops->crwrap_req)\r\nreturn cred->cr_ops->crwrap_req(task, encode, rqstp, data, obj);\r\nrpcauth_wrap_req_encode(encode, rqstp, data, obj);\r\nreturn 0;\r\n}\r\nstatic int\r\nrpcauth_unwrap_req_decode(kxdrdproc_t decode, struct rpc_rqst *rqstp,\r\n__be32 *data, void *obj)\r\n{\r\nstruct xdr_stream xdr;\r\nxdr_init_decode(&xdr, &rqstp->rq_rcv_buf, data);\r\nreturn decode(rqstp, &xdr, obj);\r\n}\r\nint\r\nrpcauth_unwrap_resp(struct rpc_task *task, kxdrdproc_t decode, void *rqstp,\r\n__be32 *data, void *obj)\r\n{\r\nstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\r\ndprintk("RPC: %5u using %s cred %p to unwrap rpc data\n",\r\ntask->tk_pid, cred->cr_ops->cr_name, cred);\r\nif (cred->cr_ops->crunwrap_resp)\r\nreturn cred->cr_ops->crunwrap_resp(task, decode, rqstp,\r\ndata, obj);\r\nreturn rpcauth_unwrap_req_decode(decode, rqstp, data, obj);\r\n}\r\nint\r\nrpcauth_refreshcred(struct rpc_task *task)\r\n{\r\nstruct rpc_cred *cred;\r\nint err;\r\ncred = task->tk_rqstp->rq_cred;\r\nif (cred == NULL) {\r\nerr = rpcauth_bindcred(task, task->tk_msg.rpc_cred, task->tk_flags);\r\nif (err < 0)\r\ngoto out;\r\ncred = task->tk_rqstp->rq_cred;\r\n}\r\ndprintk("RPC: %5u refreshing %s cred %p\n",\r\ntask->tk_pid, cred->cr_auth->au_ops->au_name, cred);\r\nerr = cred->cr_ops->crrefresh(task);\r\nout:\r\nif (err < 0)\r\ntask->tk_status = err;\r\nreturn err;\r\n}\r\nvoid\r\nrpcauth_invalcred(struct rpc_task *task)\r\n{\r\nstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\r\ndprintk("RPC: %5u invalidating %s cred %p\n",\r\ntask->tk_pid, cred->cr_auth->au_ops->au_name, cred);\r\nif (cred)\r\nclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\r\n}\r\nint\r\nrpcauth_uptodatecred(struct rpc_task *task)\r\n{\r\nstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\r\nreturn cred == NULL ||\r\ntest_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags) != 0;\r\n}\r\nint __init rpcauth_init_module(void)\r\n{\r\nint err;\r\nerr = rpc_init_authunix();\r\nif (err < 0)\r\ngoto out1;\r\nerr = rpc_init_generic_auth();\r\nif (err < 0)\r\ngoto out2;\r\nregister_shrinker(&rpc_cred_shrinker);\r\nreturn 0;\r\nout2:\r\nrpc_destroy_authunix();\r\nout1:\r\nreturn err;\r\n}\r\nvoid rpcauth_remove_module(void)\r\n{\r\nrpc_destroy_authunix();\r\nrpc_destroy_generic_auth();\r\nunregister_shrinker(&rpc_cred_shrinker);\r\n}
