static void ks8851_wrreg16(struct ks8851_net *ks, unsigned reg, unsigned val)\r\n{\r\nstruct spi_transfer *xfer = &ks->spi_xfer1;\r\nstruct spi_message *msg = &ks->spi_msg1;\r\n__le16 txb[2];\r\nint ret;\r\ntxb[0] = cpu_to_le16(MK_OP(reg & 2 ? 0xC : 0x03, reg) | KS_SPIOP_WR);\r\ntxb[1] = cpu_to_le16(val);\r\nxfer->tx_buf = txb;\r\nxfer->rx_buf = NULL;\r\nxfer->len = 4;\r\nret = spi_sync(ks->spidev, msg);\r\nif (ret < 0)\r\nnetdev_err(ks->netdev, "spi_sync() failed\n");\r\n}\r\nstatic void ks8851_wrreg8(struct ks8851_net *ks, unsigned reg, unsigned val)\r\n{\r\nstruct spi_transfer *xfer = &ks->spi_xfer1;\r\nstruct spi_message *msg = &ks->spi_msg1;\r\n__le16 txb[2];\r\nint ret;\r\nint bit;\r\nbit = 1 << (reg & 3);\r\ntxb[0] = cpu_to_le16(MK_OP(bit, reg) | KS_SPIOP_WR);\r\ntxb[1] = val;\r\nxfer->tx_buf = txb;\r\nxfer->rx_buf = NULL;\r\nxfer->len = 3;\r\nret = spi_sync(ks->spidev, msg);\r\nif (ret < 0)\r\nnetdev_err(ks->netdev, "spi_sync() failed\n");\r\n}\r\nstatic inline bool ks8851_rx_1msg(struct ks8851_net *ks)\r\n{\r\nreturn true;\r\n}\r\nstatic void ks8851_rdreg(struct ks8851_net *ks, unsigned op,\r\nu8 *rxb, unsigned rxl)\r\n{\r\nstruct spi_transfer *xfer;\r\nstruct spi_message *msg;\r\n__le16 *txb = (__le16 *)ks->txd;\r\nu8 *trx = ks->rxd;\r\nint ret;\r\ntxb[0] = cpu_to_le16(op | KS_SPIOP_RD);\r\nif (ks8851_rx_1msg(ks)) {\r\nmsg = &ks->spi_msg1;\r\nxfer = &ks->spi_xfer1;\r\nxfer->tx_buf = txb;\r\nxfer->rx_buf = trx;\r\nxfer->len = rxl + 2;\r\n} else {\r\nmsg = &ks->spi_msg2;\r\nxfer = ks->spi_xfer2;\r\nxfer->tx_buf = txb;\r\nxfer->rx_buf = NULL;\r\nxfer->len = 2;\r\nxfer++;\r\nxfer->tx_buf = NULL;\r\nxfer->rx_buf = trx;\r\nxfer->len = rxl;\r\n}\r\nret = spi_sync(ks->spidev, msg);\r\nif (ret < 0)\r\nnetdev_err(ks->netdev, "read: spi_sync() failed\n");\r\nelse if (ks8851_rx_1msg(ks))\r\nmemcpy(rxb, trx + 2, rxl);\r\nelse\r\nmemcpy(rxb, trx, rxl);\r\n}\r\nstatic unsigned ks8851_rdreg8(struct ks8851_net *ks, unsigned reg)\r\n{\r\nu8 rxb[1];\r\nks8851_rdreg(ks, MK_OP(1 << (reg & 3), reg), rxb, 1);\r\nreturn rxb[0];\r\n}\r\nstatic unsigned ks8851_rdreg16(struct ks8851_net *ks, unsigned reg)\r\n{\r\n__le16 rx = 0;\r\nks8851_rdreg(ks, MK_OP(reg & 2 ? 0xC : 0x3, reg), (u8 *)&rx, 2);\r\nreturn le16_to_cpu(rx);\r\n}\r\nstatic unsigned ks8851_rdreg32(struct ks8851_net *ks, unsigned reg)\r\n{\r\n__le32 rx = 0;\r\nWARN_ON(reg & 3);\r\nks8851_rdreg(ks, MK_OP(0xf, reg), (u8 *)&rx, 4);\r\nreturn le32_to_cpu(rx);\r\n}\r\nstatic void ks8851_soft_reset(struct ks8851_net *ks, unsigned op)\r\n{\r\nks8851_wrreg16(ks, KS_GRR, op);\r\nmdelay(1);\r\nks8851_wrreg16(ks, KS_GRR, 0);\r\nmdelay(1);\r\n}\r\nstatic void ks8851_set_powermode(struct ks8851_net *ks, unsigned pwrmode)\r\n{\r\nunsigned pmecr;\r\nnetif_dbg(ks, hw, ks->netdev, "setting power mode %d\n", pwrmode);\r\npmecr = ks8851_rdreg16(ks, KS_PMECR);\r\npmecr &= ~PMECR_PM_MASK;\r\npmecr |= pwrmode;\r\nks8851_wrreg16(ks, KS_PMECR, pmecr);\r\n}\r\nstatic int ks8851_write_mac_addr(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nint i;\r\nmutex_lock(&ks->lock);\r\nks8851_set_powermode(ks, PMECR_PM_NORMAL);\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nks8851_wrreg8(ks, KS_MAR(i), dev->dev_addr[i]);\r\nif (!netif_running(dev))\r\nks8851_set_powermode(ks, PMECR_PM_SOFTDOWN);\r\nmutex_unlock(&ks->lock);\r\nreturn 0;\r\n}\r\nstatic void ks8851_read_mac_addr(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nint i;\r\nmutex_lock(&ks->lock);\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ndev->dev_addr[i] = ks8851_rdreg8(ks, KS_MAR(i));\r\nmutex_unlock(&ks->lock);\r\n}\r\nstatic void ks8851_init_mac(struct ks8851_net *ks)\r\n{\r\nstruct net_device *dev = ks->netdev;\r\nif (ks->rc_ccr & CCR_EEPROM) {\r\nks8851_read_mac_addr(dev);\r\nif (is_valid_ether_addr(dev->dev_addr))\r\nreturn;\r\nnetdev_err(ks->netdev, "invalid mac address read %pM\n",\r\ndev->dev_addr);\r\n}\r\neth_hw_addr_random(dev);\r\nks8851_write_mac_addr(dev);\r\n}\r\nstatic void ks8851_rdfifo(struct ks8851_net *ks, u8 *buff, unsigned len)\r\n{\r\nstruct spi_transfer *xfer = ks->spi_xfer2;\r\nstruct spi_message *msg = &ks->spi_msg2;\r\nu8 txb[1];\r\nint ret;\r\nnetif_dbg(ks, rx_status, ks->netdev,\r\n"%s: %d@%p\n", __func__, len, buff);\r\ntxb[0] = KS_SPIOP_RXFIFO;\r\nxfer->tx_buf = txb;\r\nxfer->rx_buf = NULL;\r\nxfer->len = 1;\r\nxfer++;\r\nxfer->rx_buf = buff;\r\nxfer->tx_buf = NULL;\r\nxfer->len = len;\r\nret = spi_sync(ks->spidev, msg);\r\nif (ret < 0)\r\nnetdev_err(ks->netdev, "%s: spi_sync() failed\n", __func__);\r\n}\r\nstatic void ks8851_dbg_dumpkkt(struct ks8851_net *ks, u8 *rxpkt)\r\n{\r\nnetdev_dbg(ks->netdev,\r\n"pkt %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x\n",\r\nrxpkt[4], rxpkt[5], rxpkt[6], rxpkt[7],\r\nrxpkt[8], rxpkt[9], rxpkt[10], rxpkt[11],\r\nrxpkt[12], rxpkt[13], rxpkt[14], rxpkt[15]);\r\n}\r\nstatic void ks8851_rx_pkts(struct ks8851_net *ks)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned rxfc;\r\nunsigned rxlen;\r\nunsigned rxstat;\r\nu32 rxh;\r\nu8 *rxpkt;\r\nrxfc = ks8851_rdreg8(ks, KS_RXFC);\r\nnetif_dbg(ks, rx_status, ks->netdev,\r\n"%s: %d packets\n", __func__, rxfc);\r\nfor (; rxfc != 0; rxfc--) {\r\nrxh = ks8851_rdreg32(ks, KS_RXFHSR);\r\nrxstat = rxh & 0xffff;\r\nrxlen = (rxh >> 16) & 0xfff;\r\nnetif_dbg(ks, rx_status, ks->netdev,\r\n"rx: stat 0x%04x, len 0x%04x\n", rxstat, rxlen);\r\nks8851_wrreg16(ks, KS_RXFDPR, RXFDPR_RXFPAI | 0x00);\r\nks8851_wrreg16(ks, KS_RXQCR,\r\nks->rc_rxqcr | RXQCR_SDA | RXQCR_ADRFE);\r\nif (rxlen > 4) {\r\nunsigned int rxalign;\r\nrxlen -= 4;\r\nrxalign = ALIGN(rxlen, 4);\r\nskb = netdev_alloc_skb_ip_align(ks->netdev, rxalign);\r\nif (skb) {\r\nrxpkt = skb_put(skb, rxlen) - 8;\r\nks8851_rdfifo(ks, rxpkt, rxalign + 8);\r\nif (netif_msg_pktdata(ks))\r\nks8851_dbg_dumpkkt(ks, rxpkt);\r\nskb->protocol = eth_type_trans(skb, ks->netdev);\r\nnetif_rx_ni(skb);\r\nks->netdev->stats.rx_packets++;\r\nks->netdev->stats.rx_bytes += rxlen;\r\n}\r\n}\r\nks8851_wrreg16(ks, KS_RXQCR, ks->rc_rxqcr);\r\n}\r\n}\r\nstatic irqreturn_t ks8851_irq(int irq, void *_ks)\r\n{\r\nstruct ks8851_net *ks = _ks;\r\nunsigned status;\r\nunsigned handled = 0;\r\nmutex_lock(&ks->lock);\r\nstatus = ks8851_rdreg16(ks, KS_ISR);\r\nnetif_dbg(ks, intr, ks->netdev,\r\n"%s: status 0x%04x\n", __func__, status);\r\nif (status & IRQ_LCI)\r\nhandled |= IRQ_LCI;\r\nif (status & IRQ_LDI) {\r\nu16 pmecr = ks8851_rdreg16(ks, KS_PMECR);\r\npmecr &= ~PMECR_WKEVT_MASK;\r\nks8851_wrreg16(ks, KS_PMECR, pmecr | PMECR_WKEVT_LINK);\r\nhandled |= IRQ_LDI;\r\n}\r\nif (status & IRQ_RXPSI)\r\nhandled |= IRQ_RXPSI;\r\nif (status & IRQ_TXI) {\r\nhandled |= IRQ_TXI;\r\nks->tx_space = ks8851_rdreg16(ks, KS_TXMIR);\r\nnetif_dbg(ks, intr, ks->netdev,\r\n"%s: txspace %d\n", __func__, ks->tx_space);\r\n}\r\nif (status & IRQ_RXI)\r\nhandled |= IRQ_RXI;\r\nif (status & IRQ_SPIBEI) {\r\ndev_err(&ks->spidev->dev, "%s: spi bus error\n", __func__);\r\nhandled |= IRQ_SPIBEI;\r\n}\r\nks8851_wrreg16(ks, KS_ISR, handled);\r\nif (status & IRQ_RXI) {\r\nks8851_rx_pkts(ks);\r\n}\r\nif (status & IRQ_RXPSI) {\r\nstruct ks8851_rxctrl *rxc = &ks->rxctrl;\r\nks8851_wrreg16(ks, KS_MAHTR0, rxc->mchash[0]);\r\nks8851_wrreg16(ks, KS_MAHTR1, rxc->mchash[1]);\r\nks8851_wrreg16(ks, KS_MAHTR2, rxc->mchash[2]);\r\nks8851_wrreg16(ks, KS_MAHTR3, rxc->mchash[3]);\r\nks8851_wrreg16(ks, KS_RXCR2, rxc->rxcr2);\r\nks8851_wrreg16(ks, KS_RXCR1, rxc->rxcr1);\r\n}\r\nmutex_unlock(&ks->lock);\r\nif (status & IRQ_LCI)\r\nmii_check_link(&ks->mii);\r\nif (status & IRQ_TXI)\r\nnetif_wake_queue(ks->netdev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline unsigned calc_txlen(unsigned len)\r\n{\r\nreturn ALIGN(len + 4, 4);\r\n}\r\nstatic void ks8851_wrpkt(struct ks8851_net *ks, struct sk_buff *txp, bool irq)\r\n{\r\nstruct spi_transfer *xfer = ks->spi_xfer2;\r\nstruct spi_message *msg = &ks->spi_msg2;\r\nunsigned fid = 0;\r\nint ret;\r\nnetif_dbg(ks, tx_queued, ks->netdev, "%s: skb %p, %d@%p, irq %d\n",\r\n__func__, txp, txp->len, txp->data, irq);\r\nfid = ks->fid++;\r\nfid &= TXFR_TXFID_MASK;\r\nif (irq)\r\nfid |= TXFR_TXIC;\r\nks->txh.txb[1] = KS_SPIOP_TXFIFO;\r\nks->txh.txw[1] = cpu_to_le16(fid);\r\nks->txh.txw[2] = cpu_to_le16(txp->len);\r\nxfer->tx_buf = &ks->txh.txb[1];\r\nxfer->rx_buf = NULL;\r\nxfer->len = 5;\r\nxfer++;\r\nxfer->tx_buf = txp->data;\r\nxfer->rx_buf = NULL;\r\nxfer->len = ALIGN(txp->len, 4);\r\nret = spi_sync(ks->spidev, msg);\r\nif (ret < 0)\r\nnetdev_err(ks->netdev, "%s: spi_sync() failed\n", __func__);\r\n}\r\nstatic void ks8851_done_tx(struct ks8851_net *ks, struct sk_buff *txb)\r\n{\r\nstruct net_device *dev = ks->netdev;\r\ndev->stats.tx_bytes += txb->len;\r\ndev->stats.tx_packets++;\r\ndev_kfree_skb(txb);\r\n}\r\nstatic void ks8851_tx_work(struct work_struct *work)\r\n{\r\nstruct ks8851_net *ks = container_of(work, struct ks8851_net, tx_work);\r\nstruct sk_buff *txb;\r\nbool last = skb_queue_empty(&ks->txq);\r\nmutex_lock(&ks->lock);\r\nwhile (!last) {\r\ntxb = skb_dequeue(&ks->txq);\r\nlast = skb_queue_empty(&ks->txq);\r\nif (txb != NULL) {\r\nks8851_wrreg16(ks, KS_RXQCR, ks->rc_rxqcr | RXQCR_SDA);\r\nks8851_wrpkt(ks, txb, last);\r\nks8851_wrreg16(ks, KS_RXQCR, ks->rc_rxqcr);\r\nks8851_wrreg16(ks, KS_TXQCR, TXQCR_METFE);\r\nks8851_done_tx(ks, txb);\r\n}\r\n}\r\nmutex_unlock(&ks->lock);\r\n}\r\nstatic int ks8851_net_open(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nmutex_lock(&ks->lock);\r\nnetif_dbg(ks, ifup, ks->netdev, "opening\n");\r\nks8851_set_powermode(ks, PMECR_PM_NORMAL);\r\nks8851_soft_reset(ks, GRR_QMU);\r\nks8851_wrreg16(ks, KS_TXCR, (TXCR_TXE |\r\nTXCR_TXPE |\r\nTXCR_TXCRC |\r\nTXCR_TXFCE));\r\nks8851_wrreg16(ks, KS_TXFDPR, TXFDPR_TXFPAI);\r\nks8851_wrreg16(ks, KS_RXCR1, (RXCR1_RXPAFMA |\r\nRXCR1_RXFCE |\r\nRXCR1_RXBE |\r\nRXCR1_RXUE |\r\nRXCR1_RXE));\r\nks8851_wrreg16(ks, KS_RXCR2, RXCR2_SRDBL_FRAME);\r\nks8851_wrreg16(ks, KS_RXDTTR, 1000);\r\nks8851_wrreg16(ks, KS_RXDBCTR, 4096);\r\nks8851_wrreg16(ks, KS_RXFCTR, 10);\r\nks->rc_rxqcr = (RXQCR_RXFCTE |\r\nRXQCR_RXDBCTE |\r\nRXQCR_RXDTTE);\r\nks8851_wrreg16(ks, KS_RXQCR, ks->rc_rxqcr);\r\n#define STD_IRQ (IRQ_LCI | \\r\nIRQ_TXI | \\r\nIRQ_RXI | \\r\nIRQ_SPIBEI | \\r\nIRQ_TXPSI | \\r\nIRQ_RXPSI)\r\nks->rc_ier = STD_IRQ;\r\nks8851_wrreg16(ks, KS_ISR, STD_IRQ);\r\nks8851_wrreg16(ks, KS_IER, STD_IRQ);\r\nnetif_start_queue(ks->netdev);\r\nnetif_dbg(ks, ifup, ks->netdev, "network device up\n");\r\nmutex_unlock(&ks->lock);\r\nreturn 0;\r\n}\r\nstatic int ks8851_net_stop(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nnetif_info(ks, ifdown, dev, "shutting down\n");\r\nnetif_stop_queue(dev);\r\nmutex_lock(&ks->lock);\r\nks8851_wrreg16(ks, KS_IER, 0x0000);\r\nks8851_wrreg16(ks, KS_ISR, 0xffff);\r\nmutex_unlock(&ks->lock);\r\nflush_work(&ks->tx_work);\r\nflush_work(&ks->rxctrl_work);\r\nmutex_lock(&ks->lock);\r\nks8851_wrreg16(ks, KS_RXCR1, 0x0000);\r\nks8851_wrreg16(ks, KS_TXCR, 0x0000);\r\nks8851_set_powermode(ks, PMECR_PM_SOFTDOWN);\r\nmutex_unlock(&ks->lock);\r\nwhile (!skb_queue_empty(&ks->txq)) {\r\nstruct sk_buff *txb = skb_dequeue(&ks->txq);\r\nnetif_dbg(ks, ifdown, ks->netdev,\r\n"%s: freeing txb %p\n", __func__, txb);\r\ndev_kfree_skb(txb);\r\n}\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t ks8851_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nunsigned needed = calc_txlen(skb->len);\r\nnetdev_tx_t ret = NETDEV_TX_OK;\r\nnetif_dbg(ks, tx_queued, ks->netdev,\r\n"%s: skb %p, %d@%p\n", __func__, skb, skb->len, skb->data);\r\nspin_lock(&ks->statelock);\r\nif (needed > ks->tx_space) {\r\nnetif_stop_queue(dev);\r\nret = NETDEV_TX_BUSY;\r\n} else {\r\nks->tx_space -= needed;\r\nskb_queue_tail(&ks->txq, skb);\r\n}\r\nspin_unlock(&ks->statelock);\r\nschedule_work(&ks->tx_work);\r\nreturn ret;\r\n}\r\nstatic void ks8851_rxctrl_work(struct work_struct *work)\r\n{\r\nstruct ks8851_net *ks = container_of(work, struct ks8851_net, rxctrl_work);\r\nmutex_lock(&ks->lock);\r\nks8851_wrreg16(ks, KS_RXCR1, 0x00);\r\nmutex_unlock(&ks->lock);\r\n}\r\nstatic void ks8851_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nstruct ks8851_rxctrl rxctrl;\r\nmemset(&rxctrl, 0, sizeof(rxctrl));\r\nif (dev->flags & IFF_PROMISC) {\r\nrxctrl.rxcr1 = RXCR1_RXAE | RXCR1_RXINVF;\r\n} else if (dev->flags & IFF_ALLMULTI) {\r\nrxctrl.rxcr1 = (RXCR1_RXME | RXCR1_RXAE |\r\nRXCR1_RXPAFMA | RXCR1_RXMAFMA);\r\n} else if (dev->flags & IFF_MULTICAST && !netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\nu32 crc;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc(ETH_ALEN, ha->addr);\r\ncrc >>= (32 - 6);\r\nrxctrl.mchash[crc >> 4] |= (1 << (crc & 0xf));\r\n}\r\nrxctrl.rxcr1 = RXCR1_RXME | RXCR1_RXPAFMA;\r\n} else {\r\nrxctrl.rxcr1 = RXCR1_RXPAFMA;\r\n}\r\nrxctrl.rxcr1 |= (RXCR1_RXUE |\r\nRXCR1_RXBE |\r\nRXCR1_RXE |\r\nRXCR1_RXFCE);\r\nrxctrl.rxcr2 |= RXCR2_SRDBL_FRAME;\r\nspin_lock(&ks->statelock);\r\nif (memcmp(&rxctrl, &ks->rxctrl, sizeof(rxctrl)) != 0) {\r\nmemcpy(&ks->rxctrl, &rxctrl, sizeof(ks->rxctrl));\r\nschedule_work(&ks->rxctrl_work);\r\n}\r\nspin_unlock(&ks->statelock);\r\n}\r\nstatic int ks8851_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *sa = addr;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(sa->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, sa->sa_data, ETH_ALEN);\r\nreturn ks8851_write_mac_addr(dev);\r\n}\r\nstatic int ks8851_net_ioctl(struct net_device *dev, struct ifreq *req, int cmd)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nreturn generic_mii_ioctl(&ks->mii, if_mii(req), cmd, NULL);\r\n}\r\nstatic void ks8851_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *di)\r\n{\r\nstrlcpy(di->driver, "KS8851", sizeof(di->driver));\r\nstrlcpy(di->version, "1.00", sizeof(di->version));\r\nstrlcpy(di->bus_info, dev_name(dev->dev.parent), sizeof(di->bus_info));\r\n}\r\nstatic u32 ks8851_get_msglevel(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nreturn ks->msg_enable;\r\n}\r\nstatic void ks8851_set_msglevel(struct net_device *dev, u32 to)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nks->msg_enable = to;\r\n}\r\nstatic int ks8851_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nreturn mii_ethtool_gset(&ks->mii, cmd);\r\n}\r\nstatic int ks8851_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nreturn mii_ethtool_sset(&ks->mii, cmd);\r\n}\r\nstatic u32 ks8851_get_link(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nreturn mii_link_ok(&ks->mii);\r\n}\r\nstatic int ks8851_nway_reset(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nreturn mii_nway_restart(&ks->mii);\r\n}\r\nstatic void ks8851_eeprom_regread(struct eeprom_93cx6 *ee)\r\n{\r\nstruct ks8851_net *ks = ee->data;\r\nunsigned val;\r\nval = ks8851_rdreg16(ks, KS_EEPCR);\r\nee->reg_data_out = (val & EEPCR_EESB) ? 1 : 0;\r\nee->reg_data_clock = (val & EEPCR_EESCK) ? 1 : 0;\r\nee->reg_chip_select = (val & EEPCR_EECS) ? 1 : 0;\r\n}\r\nstatic void ks8851_eeprom_regwrite(struct eeprom_93cx6 *ee)\r\n{\r\nstruct ks8851_net *ks = ee->data;\r\nunsigned val = EEPCR_EESA;\r\nif (ee->drive_data)\r\nval |= EEPCR_EESRWA;\r\nif (ee->reg_data_in)\r\nval |= EEPCR_EEDO;\r\nif (ee->reg_data_clock)\r\nval |= EEPCR_EESCK;\r\nif (ee->reg_chip_select)\r\nval |= EEPCR_EECS;\r\nks8851_wrreg16(ks, KS_EEPCR, val);\r\n}\r\nstatic int ks8851_eeprom_claim(struct ks8851_net *ks)\r\n{\r\nif (!(ks->rc_ccr & CCR_EEPROM))\r\nreturn -ENOENT;\r\nmutex_lock(&ks->lock);\r\nks8851_wrreg16(ks, KS_EEPCR, EEPCR_EESA | EEPCR_EECS);\r\nreturn 0;\r\n}\r\nstatic void ks8851_eeprom_release(struct ks8851_net *ks)\r\n{\r\nunsigned val = ks8851_rdreg16(ks, KS_EEPCR);\r\nks8851_wrreg16(ks, KS_EEPCR, val & ~EEPCR_EESA);\r\nmutex_unlock(&ks->lock);\r\n}\r\nstatic int ks8851_set_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *ee, u8 *data)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nint offset = ee->offset;\r\nint len = ee->len;\r\nu16 tmp;\r\nif (len != 1)\r\nreturn -EINVAL;\r\nif (ee->magic != KS_EEPROM_MAGIC)\r\nreturn -EINVAL;\r\nif (ks8851_eeprom_claim(ks))\r\nreturn -ENOENT;\r\neeprom_93cx6_wren(&ks->eeprom, true);\r\neeprom_93cx6_read(&ks->eeprom, offset/2, &tmp);\r\nif (offset & 1) {\r\ntmp &= 0xff;\r\ntmp |= *data << 8;\r\n} else {\r\ntmp &= 0xff00;\r\ntmp |= *data;\r\n}\r\neeprom_93cx6_write(&ks->eeprom, offset/2, tmp);\r\neeprom_93cx6_wren(&ks->eeprom, false);\r\nks8851_eeprom_release(ks);\r\nreturn 0;\r\n}\r\nstatic int ks8851_get_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *ee, u8 *data)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nint offset = ee->offset;\r\nint len = ee->len;\r\nif (len & 1 || offset & 1)\r\nreturn -EINVAL;\r\nif (ks8851_eeprom_claim(ks))\r\nreturn -ENOENT;\r\nee->magic = KS_EEPROM_MAGIC;\r\neeprom_93cx6_multiread(&ks->eeprom, offset/2, (__le16 *)data, len/2);\r\nks8851_eeprom_release(ks);\r\nreturn 0;\r\n}\r\nstatic int ks8851_get_eeprom_len(struct net_device *dev)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nreturn ks->rc_ccr & CCR_EEPROM ? 128 : 0;\r\n}\r\nstatic int ks8851_phy_reg(int reg)\r\n{\r\nswitch (reg) {\r\ncase MII_BMCR:\r\nreturn KS_P1MBCR;\r\ncase MII_BMSR:\r\nreturn KS_P1MBSR;\r\ncase MII_PHYSID1:\r\nreturn KS_PHY1ILR;\r\ncase MII_PHYSID2:\r\nreturn KS_PHY1IHR;\r\ncase MII_ADVERTISE:\r\nreturn KS_P1ANAR;\r\ncase MII_LPA:\r\nreturn KS_P1ANLPR;\r\n}\r\nreturn 0x0;\r\n}\r\nstatic int ks8851_phy_read(struct net_device *dev, int phy_addr, int reg)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nint ksreg;\r\nint result;\r\nksreg = ks8851_phy_reg(reg);\r\nif (!ksreg)\r\nreturn 0x0;\r\nmutex_lock(&ks->lock);\r\nresult = ks8851_rdreg16(ks, ksreg);\r\nmutex_unlock(&ks->lock);\r\nreturn result;\r\n}\r\nstatic void ks8851_phy_write(struct net_device *dev,\r\nint phy, int reg, int value)\r\n{\r\nstruct ks8851_net *ks = netdev_priv(dev);\r\nint ksreg;\r\nksreg = ks8851_phy_reg(reg);\r\nif (ksreg) {\r\nmutex_lock(&ks->lock);\r\nks8851_wrreg16(ks, ksreg, value);\r\nmutex_unlock(&ks->lock);\r\n}\r\n}\r\nstatic int ks8851_read_selftest(struct ks8851_net *ks)\r\n{\r\nunsigned both_done = MBIR_TXMBF | MBIR_RXMBF;\r\nint ret = 0;\r\nunsigned rd;\r\nrd = ks8851_rdreg16(ks, KS_MBIR);\r\nif ((rd & both_done) != both_done) {\r\nnetdev_warn(ks->netdev, "Memory selftest not finished\n");\r\nreturn 0;\r\n}\r\nif (rd & MBIR_TXMBFA) {\r\nnetdev_err(ks->netdev, "TX memory selftest fail\n");\r\nret |= 1;\r\n}\r\nif (rd & MBIR_RXMBFA) {\r\nnetdev_err(ks->netdev, "RX memory selftest fail\n");\r\nret |= 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ks8851_suspend(struct device *dev)\r\n{\r\nstruct ks8851_net *ks = dev_get_drvdata(dev);\r\nstruct net_device *netdev = ks->netdev;\r\nif (netif_running(netdev)) {\r\nnetif_device_detach(netdev);\r\nks8851_net_stop(netdev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ks8851_resume(struct device *dev)\r\n{\r\nstruct ks8851_net *ks = dev_get_drvdata(dev);\r\nstruct net_device *netdev = ks->netdev;\r\nif (netif_running(netdev)) {\r\nks8851_net_open(netdev);\r\nnetif_device_attach(netdev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ks8851_probe(struct spi_device *spi)\r\n{\r\nstruct net_device *ndev;\r\nstruct ks8851_net *ks;\r\nint ret;\r\nunsigned cider;\r\nndev = alloc_etherdev(sizeof(struct ks8851_net));\r\nif (!ndev)\r\nreturn -ENOMEM;\r\nspi->bits_per_word = 8;\r\nks = netdev_priv(ndev);\r\nks->netdev = ndev;\r\nks->spidev = spi;\r\nks->tx_space = 6144;\r\nks->vdd_reg = regulator_get_optional(&spi->dev, "vdd");\r\nif (IS_ERR(ks->vdd_reg)) {\r\nret = PTR_ERR(ks->vdd_reg);\r\nif (ret == -EPROBE_DEFER)\r\ngoto err_reg;\r\n} else {\r\nret = regulator_enable(ks->vdd_reg);\r\nif (ret) {\r\ndev_err(&spi->dev, "regulator enable fail: %d\n",\r\nret);\r\ngoto err_reg_en;\r\n}\r\n}\r\nmutex_init(&ks->lock);\r\nspin_lock_init(&ks->statelock);\r\nINIT_WORK(&ks->tx_work, ks8851_tx_work);\r\nINIT_WORK(&ks->rxctrl_work, ks8851_rxctrl_work);\r\nspi_message_init(&ks->spi_msg1);\r\nspi_message_add_tail(&ks->spi_xfer1, &ks->spi_msg1);\r\nspi_message_init(&ks->spi_msg2);\r\nspi_message_add_tail(&ks->spi_xfer2[0], &ks->spi_msg2);\r\nspi_message_add_tail(&ks->spi_xfer2[1], &ks->spi_msg2);\r\nks->eeprom.data = ks;\r\nks->eeprom.width = PCI_EEPROM_WIDTH_93C46;\r\nks->eeprom.register_read = ks8851_eeprom_regread;\r\nks->eeprom.register_write = ks8851_eeprom_regwrite;\r\nks->mii.dev = ndev;\r\nks->mii.phy_id = 1,\r\nks->mii.phy_id_mask = 1;\r\nks->mii.reg_num_mask = 0xf;\r\nks->mii.mdio_read = ks8851_phy_read;\r\nks->mii.mdio_write = ks8851_phy_write;\r\ndev_info(&spi->dev, "message enable is %d\n", msg_enable);\r\nks->msg_enable = netif_msg_init(msg_enable, (NETIF_MSG_DRV |\r\nNETIF_MSG_PROBE |\r\nNETIF_MSG_LINK));\r\nskb_queue_head_init(&ks->txq);\r\nSET_ETHTOOL_OPS(ndev, &ks8851_ethtool_ops);\r\nSET_NETDEV_DEV(ndev, &spi->dev);\r\nspi_set_drvdata(spi, ks);\r\nndev->if_port = IF_PORT_100BASET;\r\nndev->netdev_ops = &ks8851_netdev_ops;\r\nndev->irq = spi->irq;\r\nks8851_soft_reset(ks, GRR_GSR);\r\ncider = ks8851_rdreg16(ks, KS_CIDER);\r\nif ((cider & ~CIDER_REV_MASK) != CIDER_ID) {\r\ndev_err(&spi->dev, "failed to read device ID\n");\r\nret = -ENODEV;\r\ngoto err_id;\r\n}\r\nks->rc_ccr = ks8851_rdreg16(ks, KS_CCR);\r\nif (ks->rc_ccr & CCR_EEPROM)\r\nks->eeprom_size = 128;\r\nelse\r\nks->eeprom_size = 0;\r\nks8851_read_selftest(ks);\r\nks8851_init_mac(ks);\r\nret = request_threaded_irq(spi->irq, NULL, ks8851_irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\nndev->name, ks);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "failed to get irq\n");\r\ngoto err_irq;\r\n}\r\nret = register_netdev(ndev);\r\nif (ret) {\r\ndev_err(&spi->dev, "failed to register network device\n");\r\ngoto err_netdev;\r\n}\r\nnetdev_info(ndev, "revision %d, MAC %pM, IRQ %d, %s EEPROM\n",\r\nCIDER_REV_GET(cider), ndev->dev_addr, ndev->irq,\r\nks->rc_ccr & CCR_EEPROM ? "has" : "no");\r\nreturn 0;\r\nerr_netdev:\r\nfree_irq(ndev->irq, ks);\r\nerr_irq:\r\nerr_id:\r\nif (!IS_ERR(ks->vdd_reg))\r\nregulator_disable(ks->vdd_reg);\r\nerr_reg_en:\r\nif (!IS_ERR(ks->vdd_reg))\r\nregulator_put(ks->vdd_reg);\r\nerr_reg:\r\nfree_netdev(ndev);\r\nreturn ret;\r\n}\r\nstatic int ks8851_remove(struct spi_device *spi)\r\n{\r\nstruct ks8851_net *priv = spi_get_drvdata(spi);\r\nif (netif_msg_drv(priv))\r\ndev_info(&spi->dev, "remove\n");\r\nunregister_netdev(priv->netdev);\r\nfree_irq(spi->irq, priv);\r\nif (!IS_ERR(priv->vdd_reg)) {\r\nregulator_disable(priv->vdd_reg);\r\nregulator_put(priv->vdd_reg);\r\n}\r\nfree_netdev(priv->netdev);\r\nreturn 0;\r\n}
