void __init cpm2_reset(void)\r\n{\r\n#ifdef CONFIG_PPC_85xx\r\ncpm2_immr = ioremap(get_immrbase() + 0x80000, CPM_MAP_SIZE);\r\n#else\r\ncpm2_immr = ioremap(get_immrbase(), CPM_MAP_SIZE);\r\n#endif\r\ncpm_muram_init();\r\ncpmp = &cpm2_immr->im_cpm;\r\n#ifndef CONFIG_PPC_EARLY_DEBUG_CPM\r\ncpm_command(CPM_CR_RST, 0);\r\n#endif\r\n}\r\nint cpm_command(u32 command, u8 opcode)\r\n{\r\nint i, ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cmd_lock, flags);\r\nret = 0;\r\nout_be32(&cpmp->cp_cpcr, command | opcode | CPM_CR_FLG);\r\nfor (i = 0; i < MAX_CR_CMD_LOOPS; i++)\r\nif ((in_be32(&cpmp->cp_cpcr) & CPM_CR_FLG) == 0)\r\ngoto out;\r\nprintk(KERN_ERR "%s(): Not able to issue CPM command\n", __func__);\r\nret = -EIO;\r\nout:\r\nspin_unlock_irqrestore(&cmd_lock, flags);\r\nreturn ret;\r\n}\r\nvoid __cpm2_setbrg(uint brg, uint rate, uint clk, int div16, int src)\r\n{\r\nu32 __iomem *bp;\r\nu32 val;\r\nif (brg < 4) {\r\nbp = cpm2_map_size(im_brgc1, 16);\r\n} else {\r\nbp = cpm2_map_size(im_brgc5, 16);\r\nbrg -= 4;\r\n}\r\nbp += brg;\r\nval = (((clk * 2 / rate) - 1) & ~1) | CPM_BRG_EN | src;\r\nif (div16)\r\nval |= CPM_BRG_DIV16;\r\nout_be32(bp, val);\r\ncpm2_unmap(bp);\r\n}\r\nint cpm2_clk_setup(enum cpm_clk_target target, int clock, int mode)\r\n{\r\nint ret = 0;\r\nint shift;\r\nint i, bits = 0;\r\ncpmux_t __iomem *im_cpmux;\r\nu32 __iomem *reg;\r\nu32 mask = 7;\r\nu8 clk_map[][3] = {\r\n{CPM_CLK_FCC1, CPM_BRG5, 0},\r\n{CPM_CLK_FCC1, CPM_BRG6, 1},\r\n{CPM_CLK_FCC1, CPM_BRG7, 2},\r\n{CPM_CLK_FCC1, CPM_BRG8, 3},\r\n{CPM_CLK_FCC1, CPM_CLK9, 4},\r\n{CPM_CLK_FCC1, CPM_CLK10, 5},\r\n{CPM_CLK_FCC1, CPM_CLK11, 6},\r\n{CPM_CLK_FCC1, CPM_CLK12, 7},\r\n{CPM_CLK_FCC2, CPM_BRG5, 0},\r\n{CPM_CLK_FCC2, CPM_BRG6, 1},\r\n{CPM_CLK_FCC2, CPM_BRG7, 2},\r\n{CPM_CLK_FCC2, CPM_BRG8, 3},\r\n{CPM_CLK_FCC2, CPM_CLK13, 4},\r\n{CPM_CLK_FCC2, CPM_CLK14, 5},\r\n{CPM_CLK_FCC2, CPM_CLK15, 6},\r\n{CPM_CLK_FCC2, CPM_CLK16, 7},\r\n{CPM_CLK_FCC3, CPM_BRG5, 0},\r\n{CPM_CLK_FCC3, CPM_BRG6, 1},\r\n{CPM_CLK_FCC3, CPM_BRG7, 2},\r\n{CPM_CLK_FCC3, CPM_BRG8, 3},\r\n{CPM_CLK_FCC3, CPM_CLK13, 4},\r\n{CPM_CLK_FCC3, CPM_CLK14, 5},\r\n{CPM_CLK_FCC3, CPM_CLK15, 6},\r\n{CPM_CLK_FCC3, CPM_CLK16, 7},\r\n{CPM_CLK_SCC1, CPM_BRG1, 0},\r\n{CPM_CLK_SCC1, CPM_BRG2, 1},\r\n{CPM_CLK_SCC1, CPM_BRG3, 2},\r\n{CPM_CLK_SCC1, CPM_BRG4, 3},\r\n{CPM_CLK_SCC1, CPM_CLK11, 4},\r\n{CPM_CLK_SCC1, CPM_CLK12, 5},\r\n{CPM_CLK_SCC1, CPM_CLK3, 6},\r\n{CPM_CLK_SCC1, CPM_CLK4, 7},\r\n{CPM_CLK_SCC2, CPM_BRG1, 0},\r\n{CPM_CLK_SCC2, CPM_BRG2, 1},\r\n{CPM_CLK_SCC2, CPM_BRG3, 2},\r\n{CPM_CLK_SCC2, CPM_BRG4, 3},\r\n{CPM_CLK_SCC2, CPM_CLK11, 4},\r\n{CPM_CLK_SCC2, CPM_CLK12, 5},\r\n{CPM_CLK_SCC2, CPM_CLK3, 6},\r\n{CPM_CLK_SCC2, CPM_CLK4, 7},\r\n{CPM_CLK_SCC3, CPM_BRG1, 0},\r\n{CPM_CLK_SCC3, CPM_BRG2, 1},\r\n{CPM_CLK_SCC3, CPM_BRG3, 2},\r\n{CPM_CLK_SCC3, CPM_BRG4, 3},\r\n{CPM_CLK_SCC3, CPM_CLK5, 4},\r\n{CPM_CLK_SCC3, CPM_CLK6, 5},\r\n{CPM_CLK_SCC3, CPM_CLK7, 6},\r\n{CPM_CLK_SCC3, CPM_CLK8, 7},\r\n{CPM_CLK_SCC4, CPM_BRG1, 0},\r\n{CPM_CLK_SCC4, CPM_BRG2, 1},\r\n{CPM_CLK_SCC4, CPM_BRG3, 2},\r\n{CPM_CLK_SCC4, CPM_BRG4, 3},\r\n{CPM_CLK_SCC4, CPM_CLK5, 4},\r\n{CPM_CLK_SCC4, CPM_CLK6, 5},\r\n{CPM_CLK_SCC4, CPM_CLK7, 6},\r\n{CPM_CLK_SCC4, CPM_CLK8, 7},\r\n};\r\nim_cpmux = cpm2_map(im_cpmux);\r\nswitch (target) {\r\ncase CPM_CLK_SCC1:\r\nreg = &im_cpmux->cmx_scr;\r\nshift = 24;\r\nbreak;\r\ncase CPM_CLK_SCC2:\r\nreg = &im_cpmux->cmx_scr;\r\nshift = 16;\r\nbreak;\r\ncase CPM_CLK_SCC3:\r\nreg = &im_cpmux->cmx_scr;\r\nshift = 8;\r\nbreak;\r\ncase CPM_CLK_SCC4:\r\nreg = &im_cpmux->cmx_scr;\r\nshift = 0;\r\nbreak;\r\ncase CPM_CLK_FCC1:\r\nreg = &im_cpmux->cmx_fcr;\r\nshift = 24;\r\nbreak;\r\ncase CPM_CLK_FCC2:\r\nreg = &im_cpmux->cmx_fcr;\r\nshift = 16;\r\nbreak;\r\ncase CPM_CLK_FCC3:\r\nreg = &im_cpmux->cmx_fcr;\r\nshift = 8;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "cpm2_clock_setup: invalid clock target\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(clk_map); i++) {\r\nif (clk_map[i][0] == target && clk_map[i][1] == clock) {\r\nbits = clk_map[i][2];\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(clk_map))\r\nret = -EINVAL;\r\nbits <<= shift;\r\nmask <<= shift;\r\nif (mode == CPM_CLK_RTX) {\r\nbits |= bits << 3;\r\nmask |= mask << 3;\r\n} else if (mode == CPM_CLK_RX) {\r\nbits <<= 3;\r\nmask <<= 3;\r\n}\r\nout_be32(reg, (in_be32(reg) & ~mask) | bits);\r\ncpm2_unmap(im_cpmux);\r\nreturn ret;\r\n}\r\nint cpm2_smc_clk_setup(enum cpm_clk_target target, int clock)\r\n{\r\nint ret = 0;\r\nint shift;\r\nint i, bits = 0;\r\ncpmux_t __iomem *im_cpmux;\r\nu8 __iomem *reg;\r\nu8 mask = 3;\r\nu8 clk_map[][3] = {\r\n{CPM_CLK_SMC1, CPM_BRG1, 0},\r\n{CPM_CLK_SMC1, CPM_BRG7, 1},\r\n{CPM_CLK_SMC1, CPM_CLK7, 2},\r\n{CPM_CLK_SMC1, CPM_CLK9, 3},\r\n{CPM_CLK_SMC2, CPM_BRG2, 0},\r\n{CPM_CLK_SMC2, CPM_BRG8, 1},\r\n{CPM_CLK_SMC2, CPM_CLK4, 2},\r\n{CPM_CLK_SMC2, CPM_CLK15, 3},\r\n};\r\nim_cpmux = cpm2_map(im_cpmux);\r\nswitch (target) {\r\ncase CPM_CLK_SMC1:\r\nreg = &im_cpmux->cmx_smr;\r\nmask = 3;\r\nshift = 4;\r\nbreak;\r\ncase CPM_CLK_SMC2:\r\nreg = &im_cpmux->cmx_smr;\r\nmask = 3;\r\nshift = 0;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "cpm2_smc_clock_setup: invalid clock target\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(clk_map); i++) {\r\nif (clk_map[i][0] == target && clk_map[i][1] == clock) {\r\nbits = clk_map[i][2];\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(clk_map))\r\nret = -EINVAL;\r\nbits <<= shift;\r\nmask <<= shift;\r\nout_8(reg, (in_8(reg) & ~mask) | bits);\r\ncpm2_unmap(im_cpmux);\r\nreturn ret;\r\n}\r\nvoid cpm2_set_pin(int port, int pin, int flags)\r\n{\r\nstruct cpm2_ioports __iomem *iop =\r\n(struct cpm2_ioports __iomem *)&cpm2_immr->im_ioport;\r\npin = 1 << (31 - pin);\r\nif (flags & CPM_PIN_OUTPUT)\r\nsetbits32(&iop[port].dir, pin);\r\nelse\r\nclrbits32(&iop[port].dir, pin);\r\nif (!(flags & CPM_PIN_GPIO))\r\nsetbits32(&iop[port].par, pin);\r\nelse\r\nclrbits32(&iop[port].par, pin);\r\nif (flags & CPM_PIN_SECONDARY)\r\nsetbits32(&iop[port].sor, pin);\r\nelse\r\nclrbits32(&iop[port].sor, pin);\r\nif (flags & CPM_PIN_OPENDRAIN)\r\nsetbits32(&iop[port].odr, pin);\r\nelse\r\nclrbits32(&iop[port].odr, pin);\r\n}\r\nstatic int cpm_init_par_io(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_compatible_node(np, NULL, "fsl,cpm2-pario-bank")\r\ncpm2_gpiochip_add32(np);\r\nreturn 0;\r\n}
