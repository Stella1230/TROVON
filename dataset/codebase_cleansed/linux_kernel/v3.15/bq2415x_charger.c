static int bq2415x_i2c_read(struct bq2415x_device *bq, u8 reg)\r\n{\r\nstruct i2c_client *client = to_i2c_client(bq->dev);\r\nstruct i2c_msg msg[2];\r\nu8 val;\r\nint ret;\r\nif (!client->adapter)\r\nreturn -ENODEV;\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].buf = &reg;\r\nmsg[0].len = sizeof(reg);\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].buf = &val;\r\nmsg[1].len = sizeof(val);\r\nmutex_lock(&bq2415x_i2c_mutex);\r\nret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\r\nmutex_unlock(&bq2415x_i2c_mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn val;\r\n}\r\nstatic int bq2415x_i2c_read_mask(struct bq2415x_device *bq, u8 reg,\r\nu8 mask, u8 shift)\r\n{\r\nint ret;\r\nif (shift > 8)\r\nreturn -EINVAL;\r\nret = bq2415x_i2c_read(bq, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (ret & mask) >> shift;\r\n}\r\nstatic int bq2415x_i2c_read_bit(struct bq2415x_device *bq, u8 reg, u8 bit)\r\n{\r\nif (bit > 8)\r\nreturn -EINVAL;\r\nreturn bq2415x_i2c_read_mask(bq, reg, BIT(bit), bit);\r\n}\r\nstatic int bq2415x_i2c_write(struct bq2415x_device *bq, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *client = to_i2c_client(bq->dev);\r\nstruct i2c_msg msg[1];\r\nu8 data[2];\r\nint ret;\r\ndata[0] = reg;\r\ndata[1] = val;\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].buf = data;\r\nmsg[0].len = ARRAY_SIZE(data);\r\nmutex_lock(&bq2415x_i2c_mutex);\r\nret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\r\nmutex_unlock(&bq2415x_i2c_mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int bq2415x_i2c_write_mask(struct bq2415x_device *bq, u8 reg, u8 val,\r\nu8 mask, u8 shift)\r\n{\r\nint ret;\r\nif (shift > 8)\r\nreturn -EINVAL;\r\nret = bq2415x_i2c_read(bq, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret &= ~mask;\r\nret |= val << shift;\r\nreturn bq2415x_i2c_write(bq, reg, ret);\r\n}\r\nstatic int bq2415x_i2c_write_bit(struct bq2415x_device *bq, u8 reg,\r\nbool val, u8 bit)\r\n{\r\nif (bit > 8)\r\nreturn -EINVAL;\r\nreturn bq2415x_i2c_write_mask(bq, reg, val, BIT(bit), bit);\r\n}\r\nstatic int bq2415x_exec_command(struct bq2415x_device *bq,\r\nenum bq2415x_command command)\r\n{\r\nint ret;\r\nswitch (command) {\r\ncase BQ2415X_TIMER_RESET:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_STATUS,\r\n1, BQ2415X_BIT_TMR_RST);\r\ncase BQ2415X_OTG_STATUS:\r\nreturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_STATUS,\r\nBQ2415X_BIT_OTG);\r\ncase BQ2415X_STAT_PIN_STATUS:\r\nreturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_STATUS,\r\nBQ2415X_BIT_EN_STAT);\r\ncase BQ2415X_STAT_PIN_ENABLE:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_STATUS, 1,\r\nBQ2415X_BIT_EN_STAT);\r\ncase BQ2415X_STAT_PIN_DISABLE:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_STATUS, 0,\r\nBQ2415X_BIT_EN_STAT);\r\ncase BQ2415X_CHARGE_STATUS:\r\nreturn bq2415x_i2c_read_mask(bq, BQ2415X_REG_STATUS,\r\nBQ2415X_MASK_STAT, BQ2415X_SHIFT_STAT);\r\ncase BQ2415X_BOOST_STATUS:\r\nreturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_STATUS,\r\nBQ2415X_BIT_BOOST);\r\ncase BQ2415X_FAULT_STATUS:\r\nreturn bq2415x_i2c_read_mask(bq, BQ2415X_REG_STATUS,\r\nBQ2415X_MASK_FAULT, BQ2415X_SHIFT_FAULT);\r\ncase BQ2415X_CHARGE_TERMINATION_STATUS:\r\nreturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_CONTROL,\r\nBQ2415X_BIT_TE);\r\ncase BQ2415X_CHARGE_TERMINATION_ENABLE:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\r\n1, BQ2415X_BIT_TE);\r\ncase BQ2415X_CHARGE_TERMINATION_DISABLE:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\r\n0, BQ2415X_BIT_TE);\r\ncase BQ2415X_CHARGER_STATUS:\r\nret = bq2415x_i2c_read_bit(bq, BQ2415X_REG_CONTROL,\r\nBQ2415X_BIT_CE);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn ret > 0 ? 0 : 1;\r\ncase BQ2415X_CHARGER_ENABLE:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\r\n0, BQ2415X_BIT_CE);\r\ncase BQ2415X_CHARGER_DISABLE:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\r\n1, BQ2415X_BIT_CE);\r\ncase BQ2415X_HIGH_IMPEDANCE_STATUS:\r\nreturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_CONTROL,\r\nBQ2415X_BIT_HZ_MODE);\r\ncase BQ2415X_HIGH_IMPEDANCE_ENABLE:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\r\n1, BQ2415X_BIT_HZ_MODE);\r\ncase BQ2415X_HIGH_IMPEDANCE_DISABLE:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\r\n0, BQ2415X_BIT_HZ_MODE);\r\ncase BQ2415X_BOOST_MODE_STATUS:\r\nreturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_CONTROL,\r\nBQ2415X_BIT_OPA_MODE);\r\ncase BQ2415X_BOOST_MODE_ENABLE:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\r\n1, BQ2415X_BIT_OPA_MODE);\r\ncase BQ2415X_BOOST_MODE_DISABLE:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_CONTROL,\r\n0, BQ2415X_BIT_OPA_MODE);\r\ncase BQ2415X_OTG_LEVEL:\r\nreturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_VOLTAGE,\r\nBQ2415X_BIT_OTG_PL);\r\ncase BQ2415X_OTG_ACTIVATE_HIGH:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_VOLTAGE,\r\n1, BQ2415X_BIT_OTG_PL);\r\ncase BQ2415X_OTG_ACTIVATE_LOW:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_VOLTAGE,\r\n0, BQ2415X_BIT_OTG_PL);\r\ncase BQ2415X_OTG_PIN_STATUS:\r\nreturn bq2415x_i2c_read_bit(bq, BQ2415X_REG_VOLTAGE,\r\nBQ2415X_BIT_OTG_EN);\r\ncase BQ2415X_OTG_PIN_ENABLE:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_VOLTAGE,\r\n1, BQ2415X_BIT_OTG_EN);\r\ncase BQ2415X_OTG_PIN_DISABLE:\r\nreturn bq2415x_i2c_write_bit(bq, BQ2415X_REG_VOLTAGE,\r\n0, BQ2415X_BIT_OTG_EN);\r\ncase BQ2415X_VENDER_CODE:\r\nreturn bq2415x_i2c_read_mask(bq, BQ2415X_REG_VENDER,\r\nBQ2415X_MASK_VENDER, BQ2415X_SHIFT_VENDER);\r\ncase BQ2415X_PART_NUMBER:\r\nreturn bq2415x_i2c_read_mask(bq, BQ2415X_REG_VENDER,\r\nBQ2415X_MASK_PN, BQ2415X_SHIFT_PN);\r\ncase BQ2415X_REVISION:\r\nreturn bq2415x_i2c_read_mask(bq, BQ2415X_REG_VENDER,\r\nBQ2415X_MASK_REVISION, BQ2415X_SHIFT_REVISION);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic enum bq2415x_chip bq2415x_detect_chip(struct bq2415x_device *bq)\r\n{\r\nstruct i2c_client *client = to_i2c_client(bq->dev);\r\nint ret = bq2415x_exec_command(bq, BQ2415X_PART_NUMBER);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (client->addr) {\r\ncase 0x6b:\r\nswitch (ret) {\r\ncase 0:\r\nif (bq->chip == BQ24151A)\r\nreturn bq->chip;\r\nelse\r\nreturn BQ24151;\r\ncase 1:\r\nif (bq->chip == BQ24150A ||\r\nbq->chip == BQ24152 ||\r\nbq->chip == BQ24155)\r\nreturn bq->chip;\r\nelse\r\nreturn BQ24150;\r\ncase 2:\r\nif (bq->chip == BQ24153A)\r\nreturn bq->chip;\r\nelse\r\nreturn BQ24153;\r\ndefault:\r\nreturn BQUNKNOWN;\r\n}\r\nbreak;\r\ncase 0x6a:\r\nswitch (ret) {\r\ncase 0:\r\nif (bq->chip == BQ24156A)\r\nreturn bq->chip;\r\nelse\r\nreturn BQ24156;\r\ncase 2:\r\nreturn BQ24158;\r\ndefault:\r\nreturn BQUNKNOWN;\r\n}\r\nbreak;\r\n}\r\nreturn BQUNKNOWN;\r\n}\r\nstatic int bq2415x_detect_revision(struct bq2415x_device *bq)\r\n{\r\nint ret = bq2415x_exec_command(bq, BQ2415X_REVISION);\r\nint chip = bq2415x_detect_chip(bq);\r\nif (ret < 0 || chip < 0)\r\nreturn -1;\r\nswitch (chip) {\r\ncase BQ24150:\r\ncase BQ24150A:\r\ncase BQ24151:\r\ncase BQ24151A:\r\ncase BQ24152:\r\nif (ret >= 0 && ret <= 3)\r\nreturn ret;\r\nelse\r\nreturn -1;\r\ncase BQ24153:\r\ncase BQ24153A:\r\ncase BQ24156:\r\ncase BQ24156A:\r\ncase BQ24158:\r\nif (ret == 3)\r\nreturn 0;\r\nelse if (ret == 1)\r\nreturn 1;\r\nelse\r\nreturn -1;\r\ncase BQ24155:\r\nif (ret == 3)\r\nreturn 3;\r\nelse\r\nreturn -1;\r\ncase BQUNKNOWN:\r\nreturn -1;\r\n}\r\nreturn -1;\r\n}\r\nstatic int bq2415x_get_vender_code(struct bq2415x_device *bq)\r\n{\r\nint ret;\r\nret = bq2415x_exec_command(bq, BQ2415X_VENDER_CODE);\r\nif (ret < 0)\r\nreturn 0;\r\nreturn (ret & 0x1) +\r\n((ret >> 1) & 0x1) * 10 +\r\n((ret >> 2) & 0x1) * 100;\r\n}\r\nstatic void bq2415x_reset_chip(struct bq2415x_device *bq)\r\n{\r\nbq2415x_i2c_write(bq, BQ2415X_REG_CURRENT, BQ2415X_RESET_CURRENT);\r\nbq2415x_i2c_write(bq, BQ2415X_REG_VOLTAGE, BQ2415X_RESET_VOLTAGE);\r\nbq2415x_i2c_write(bq, BQ2415X_REG_CONTROL, BQ2415X_RESET_CONTROL);\r\nbq2415x_i2c_write(bq, BQ2415X_REG_STATUS, BQ2415X_RESET_STATUS);\r\nbq->timer_error = NULL;\r\n}\r\nstatic int bq2415x_set_current_limit(struct bq2415x_device *bq, int mA)\r\n{\r\nint val;\r\nif (mA <= 100)\r\nval = 0;\r\nelse if (mA <= 500)\r\nval = 1;\r\nelse if (mA <= 800)\r\nval = 2;\r\nelse\r\nval = 3;\r\nreturn bq2415x_i2c_write_mask(bq, BQ2415X_REG_CONTROL, val,\r\nBQ2415X_MASK_LIMIT, BQ2415X_SHIFT_LIMIT);\r\n}\r\nstatic int bq2415x_get_current_limit(struct bq2415x_device *bq)\r\n{\r\nint ret;\r\nret = bq2415x_i2c_read_mask(bq, BQ2415X_REG_CONTROL,\r\nBQ2415X_MASK_LIMIT, BQ2415X_SHIFT_LIMIT);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret == 0)\r\nreturn 100;\r\nelse if (ret == 1)\r\nreturn 500;\r\nelse if (ret == 2)\r\nreturn 800;\r\nelse if (ret == 3)\r\nreturn 1800;\r\nreturn -EINVAL;\r\n}\r\nstatic int bq2415x_set_weak_battery_voltage(struct bq2415x_device *bq, int mV)\r\n{\r\nint val;\r\nif (mV <= 3400 + 50)\r\nval = 0;\r\nelse if (mV <= 3500 + 50)\r\nval = 1;\r\nelse if (mV <= 3600 + 50)\r\nval = 2;\r\nelse\r\nval = 3;\r\nreturn bq2415x_i2c_write_mask(bq, BQ2415X_REG_CONTROL, val,\r\nBQ2415X_MASK_VLOWV, BQ2415X_SHIFT_VLOWV);\r\n}\r\nstatic int bq2415x_get_weak_battery_voltage(struct bq2415x_device *bq)\r\n{\r\nint ret;\r\nret = bq2415x_i2c_read_mask(bq, BQ2415X_REG_CONTROL,\r\nBQ2415X_MASK_VLOWV, BQ2415X_SHIFT_VLOWV);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 100 * (34 + ret);\r\n}\r\nstatic int bq2415x_set_battery_regulation_voltage(struct bq2415x_device *bq,\r\nint mV)\r\n{\r\nint val = (mV/10 - 350) / 2;\r\nif (val < 0)\r\nval = 0;\r\nelse if (val > 47)\r\nreturn -EINVAL;\r\nreturn bq2415x_i2c_write_mask(bq, BQ2415X_REG_VOLTAGE, val,\r\nBQ2415X_MASK_VO, BQ2415X_SHIFT_VO);\r\n}\r\nstatic int bq2415x_get_battery_regulation_voltage(struct bq2415x_device *bq)\r\n{\r\nint ret = bq2415x_i2c_read_mask(bq, BQ2415X_REG_VOLTAGE,\r\nBQ2415X_MASK_VO, BQ2415X_SHIFT_VO);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 10 * (350 + 2*ret);\r\n}\r\nstatic int bq2415x_set_charge_current(struct bq2415x_device *bq, int mA)\r\n{\r\nint val;\r\nif (bq->init_data.resistor_sense <= 0)\r\nreturn -ENOSYS;\r\nval = (mA * bq->init_data.resistor_sense - 37400) / 6800;\r\nif (val < 0)\r\nval = 0;\r\nelse if (val > 7)\r\nval = 7;\r\nreturn bq2415x_i2c_write_mask(bq, BQ2415X_REG_CURRENT, val,\r\nBQ2415X_MASK_VI_CHRG | BQ2415X_MASK_RESET,\r\nBQ2415X_SHIFT_VI_CHRG);\r\n}\r\nstatic int bq2415x_get_charge_current(struct bq2415x_device *bq)\r\n{\r\nint ret;\r\nif (bq->init_data.resistor_sense <= 0)\r\nreturn -ENOSYS;\r\nret = bq2415x_i2c_read_mask(bq, BQ2415X_REG_CURRENT,\r\nBQ2415X_MASK_VI_CHRG, BQ2415X_SHIFT_VI_CHRG);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (37400 + 6800*ret) / bq->init_data.resistor_sense;\r\n}\r\nstatic int bq2415x_set_termination_current(struct bq2415x_device *bq, int mA)\r\n{\r\nint val;\r\nif (bq->init_data.resistor_sense <= 0)\r\nreturn -ENOSYS;\r\nval = (mA * bq->init_data.resistor_sense - 3400) / 3400;\r\nif (val < 0)\r\nval = 0;\r\nelse if (val > 7)\r\nval = 7;\r\nreturn bq2415x_i2c_write_mask(bq, BQ2415X_REG_CURRENT, val,\r\nBQ2415X_MASK_VI_TERM | BQ2415X_MASK_RESET,\r\nBQ2415X_SHIFT_VI_TERM);\r\n}\r\nstatic int bq2415x_get_termination_current(struct bq2415x_device *bq)\r\n{\r\nint ret;\r\nif (bq->init_data.resistor_sense <= 0)\r\nreturn -ENOSYS;\r\nret = bq2415x_i2c_read_mask(bq, BQ2415X_REG_CURRENT,\r\nBQ2415X_MASK_VI_TERM, BQ2415X_SHIFT_VI_TERM);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (3400 + 3400*ret) / bq->init_data.resistor_sense;\r\n}\r\nstatic int bq2415x_set_defaults(struct bq2415x_device *bq)\r\n{\r\nbq2415x_exec_command(bq, BQ2415X_BOOST_MODE_DISABLE);\r\nbq2415x_exec_command(bq, BQ2415X_CHARGER_DISABLE);\r\nbq2415x_exec_command(bq, BQ2415X_CHARGE_TERMINATION_DISABLE);\r\nbq2415x_set_default_value(bq, current_limit);\r\nbq2415x_set_default_value(bq, weak_battery_voltage);\r\nbq2415x_set_default_value(bq, battery_regulation_voltage);\r\nif (bq->init_data.resistor_sense > 0) {\r\nbq2415x_set_default_value(bq, charge_current);\r\nbq2415x_set_default_value(bq, termination_current);\r\nbq2415x_exec_command(bq, BQ2415X_CHARGE_TERMINATION_ENABLE);\r\n}\r\nbq2415x_exec_command(bq, BQ2415X_CHARGER_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int bq2415x_set_mode(struct bq2415x_device *bq, enum bq2415x_mode mode)\r\n{\r\nint ret = 0;\r\nint charger = 0;\r\nint boost = 0;\r\nif (mode == BQ2415X_MODE_BOOST)\r\nboost = 1;\r\nelse if (mode != BQ2415X_MODE_OFF)\r\ncharger = 1;\r\nif (!charger)\r\nret = bq2415x_exec_command(bq, BQ2415X_CHARGER_DISABLE);\r\nif (!boost)\r\nret = bq2415x_exec_command(bq, BQ2415X_BOOST_MODE_DISABLE);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (mode) {\r\ncase BQ2415X_MODE_OFF:\r\ndev_dbg(bq->dev, "changing mode to: Offline\n");\r\nret = bq2415x_set_current_limit(bq, 100);\r\nbreak;\r\ncase BQ2415X_MODE_NONE:\r\ndev_dbg(bq->dev, "changing mode to: N/A\n");\r\nret = bq2415x_set_current_limit(bq, 100);\r\nbreak;\r\ncase BQ2415X_MODE_HOST_CHARGER:\r\ndev_dbg(bq->dev, "changing mode to: Host/HUB charger\n");\r\nret = bq2415x_set_current_limit(bq, 500);\r\nbreak;\r\ncase BQ2415X_MODE_DEDICATED_CHARGER:\r\ndev_dbg(bq->dev, "changing mode to: Dedicated charger\n");\r\nret = bq2415x_set_current_limit(bq, 1800);\r\nbreak;\r\ncase BQ2415X_MODE_BOOST:\r\ndev_dbg(bq->dev, "changing mode to: Boost\n");\r\nret = bq2415x_set_current_limit(bq, 100);\r\nbreak;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nif (charger)\r\nret = bq2415x_exec_command(bq, BQ2415X_CHARGER_ENABLE);\r\nelse if (boost)\r\nret = bq2415x_exec_command(bq, BQ2415X_BOOST_MODE_ENABLE);\r\nif (ret < 0)\r\nreturn ret;\r\nbq2415x_set_default_value(bq, weak_battery_voltage);\r\nbq2415x_set_default_value(bq, battery_regulation_voltage);\r\nbq->mode = mode;\r\nsysfs_notify(&bq->charger.dev->kobj, NULL, "mode");\r\nreturn 0;\r\n}\r\nstatic int bq2415x_notifier_call(struct notifier_block *nb,\r\nunsigned long val, void *v)\r\n{\r\nstruct bq2415x_device *bq =\r\ncontainer_of(nb, struct bq2415x_device, nb);\r\nstruct power_supply *psy = v;\r\nenum bq2415x_mode mode;\r\nunion power_supply_propval prop;\r\nint ret;\r\nint mA;\r\nif (val != PSY_EVENT_PROP_CHANGED)\r\nreturn NOTIFY_OK;\r\nif (psy != bq->notify_psy)\r\nreturn NOTIFY_OK;\r\ndev_dbg(bq->dev, "notifier call was called\n");\r\nret = psy->get_property(psy, POWER_SUPPLY_PROP_CURRENT_MAX, &prop);\r\nif (ret != 0)\r\nreturn NOTIFY_OK;\r\nmA = prop.intval;\r\nif (mA == 0)\r\nmode = BQ2415X_MODE_OFF;\r\nelse if (mA < 500)\r\nmode = BQ2415X_MODE_NONE;\r\nelse if (mA < 1800)\r\nmode = BQ2415X_MODE_HOST_CHARGER;\r\nelse\r\nmode = BQ2415X_MODE_DEDICATED_CHARGER;\r\nif (bq->reported_mode == mode)\r\nreturn NOTIFY_OK;\r\nbq->reported_mode = mode;\r\nif (bq->automode < 1)\r\nreturn NOTIFY_OK;\r\nsysfs_notify(&bq->charger.dev->kobj, NULL, "reported_mode");\r\nbq2415x_set_mode(bq, bq->reported_mode);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void bq2415x_set_autotimer(struct bq2415x_device *bq, int state)\r\n{\r\nmutex_lock(&bq2415x_timer_mutex);\r\nif (bq->autotimer == state) {\r\nmutex_unlock(&bq2415x_timer_mutex);\r\nreturn;\r\n}\r\nbq->autotimer = state;\r\nif (state) {\r\nschedule_delayed_work(&bq->work, BQ2415X_TIMER_TIMEOUT * HZ);\r\nbq2415x_exec_command(bq, BQ2415X_TIMER_RESET);\r\nbq->timer_error = NULL;\r\n} else {\r\ncancel_delayed_work_sync(&bq->work);\r\n}\r\nmutex_unlock(&bq2415x_timer_mutex);\r\n}\r\nstatic void bq2415x_timer_error(struct bq2415x_device *bq, const char *msg)\r\n{\r\nbq->timer_error = msg;\r\nsysfs_notify(&bq->charger.dev->kobj, NULL, "timer");\r\ndev_err(bq->dev, "%s\n", msg);\r\nif (bq->automode > 0)\r\nbq->automode = 0;\r\nbq2415x_set_mode(bq, BQ2415X_MODE_OFF);\r\nbq2415x_set_autotimer(bq, 0);\r\n}\r\nstatic void bq2415x_timer_work(struct work_struct *work)\r\n{\r\nstruct bq2415x_device *bq = container_of(work, struct bq2415x_device,\r\nwork.work);\r\nint ret;\r\nint error;\r\nint boost;\r\nif (!bq->autotimer)\r\nreturn;\r\nret = bq2415x_exec_command(bq, BQ2415X_TIMER_RESET);\r\nif (ret < 0) {\r\nbq2415x_timer_error(bq, "Resetting timer failed");\r\nreturn;\r\n}\r\nboost = bq2415x_exec_command(bq, BQ2415X_BOOST_MODE_STATUS);\r\nif (boost < 0) {\r\nbq2415x_timer_error(bq, "Unknown error");\r\nreturn;\r\n}\r\nerror = bq2415x_exec_command(bq, BQ2415X_FAULT_STATUS);\r\nif (error < 0) {\r\nbq2415x_timer_error(bq, "Unknown error");\r\nreturn;\r\n}\r\nif (boost) {\r\nswitch (error) {\r\ncase 0:\r\nbreak;\r\ncase 6:\r\ndev_err(bq->dev, "Timer expired\n");\r\nbreak;\r\ncase 3:\r\ndev_err(bq->dev, "Battery voltage to low\n");\r\nbreak;\r\ncase 1:\r\nbq2415x_timer_error(bq,\r\n"Overvoltage protection (chip fried)");\r\nreturn;\r\ncase 2:\r\nbq2415x_timer_error(bq, "Overload");\r\nreturn;\r\ncase 4:\r\nbq2415x_timer_error(bq,\r\n"Battery overvoltage protection");\r\nreturn;\r\ncase 5:\r\nbq2415x_timer_error(bq,\r\n"Thermal shutdown (too hot)");\r\nreturn;\r\ncase 7:\r\nbq2415x_timer_error(bq, "Unknown error");\r\nreturn;\r\n}\r\n} else {\r\nswitch (error) {\r\ncase 0:\r\nbreak;\r\ncase 2:\r\ndev_err(bq->dev, "Sleep mode\n");\r\nbreak;\r\ncase 3:\r\ndev_err(bq->dev, "Poor input source\n");\r\nbreak;\r\ncase 6:\r\ndev_err(bq->dev, "Timer expired\n");\r\nbreak;\r\ncase 7:\r\ndev_err(bq->dev, "No battery\n");\r\nbreak;\r\ncase 1:\r\nbq2415x_timer_error(bq,\r\n"Overvoltage protection (chip fried)");\r\nreturn;\r\ncase 4:\r\nbq2415x_timer_error(bq,\r\n"Battery overvoltage protection");\r\nreturn;\r\ncase 5:\r\nbq2415x_timer_error(bq,\r\n"Thermal shutdown (too hot)");\r\nreturn;\r\n}\r\n}\r\nschedule_delayed_work(&bq->work, BQ2415X_TIMER_TIMEOUT * HZ);\r\n}\r\nstatic int bq2415x_power_supply_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct bq2415x_device *bq = container_of(psy, struct bq2415x_device,\r\ncharger);\r\nint ret;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nret = bq2415x_exec_command(bq, BQ2415X_CHARGE_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret == 0)\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse if (ret == 1)\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (ret == 2)\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = bq->model;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bq2415x_power_supply_init(struct bq2415x_device *bq)\r\n{\r\nint ret;\r\nint chip;\r\nchar revstr[8];\r\nbq->charger.name = bq->name;\r\nbq->charger.type = POWER_SUPPLY_TYPE_USB;\r\nbq->charger.properties = bq2415x_power_supply_props;\r\nbq->charger.num_properties = ARRAY_SIZE(bq2415x_power_supply_props);\r\nbq->charger.get_property = bq2415x_power_supply_get_property;\r\nret = bq2415x_detect_chip(bq);\r\nif (ret < 0)\r\nchip = BQUNKNOWN;\r\nelse\r\nchip = ret;\r\nret = bq2415x_detect_revision(bq);\r\nif (ret < 0)\r\nstrcpy(revstr, "unknown");\r\nelse\r\nsprintf(revstr, "1.%d", ret);\r\nbq->model = kasprintf(GFP_KERNEL,\r\n"chip %s, revision %s, vender code %.3d",\r\nbq2415x_chip_name[chip], revstr,\r\nbq2415x_get_vender_code(bq));\r\nif (!bq->model) {\r\ndev_err(bq->dev, "failed to allocate model name\n");\r\nreturn -ENOMEM;\r\n}\r\nret = power_supply_register(bq->dev, &bq->charger);\r\nif (ret) {\r\nkfree(bq->model);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bq2415x_power_supply_exit(struct bq2415x_device *bq)\r\n{\r\nbq->autotimer = 0;\r\nif (bq->automode > 0)\r\nbq->automode = 0;\r\ncancel_delayed_work_sync(&bq->work);\r\npower_supply_unregister(&bq->charger);\r\nkfree(bq->model);\r\n}\r\nstatic ssize_t bq2415x_sysfs_show_status(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq2415x_device *bq = container_of(psy, struct bq2415x_device,\r\ncharger);\r\nenum bq2415x_command command;\r\nint ret;\r\nif (strcmp(attr->attr.name, "otg_status") == 0)\r\ncommand = BQ2415X_OTG_STATUS;\r\nelse if (strcmp(attr->attr.name, "charge_status") == 0)\r\ncommand = BQ2415X_CHARGE_STATUS;\r\nelse if (strcmp(attr->attr.name, "boost_status") == 0)\r\ncommand = BQ2415X_BOOST_STATUS;\r\nelse if (strcmp(attr->attr.name, "fault_status") == 0)\r\ncommand = BQ2415X_FAULT_STATUS;\r\nelse\r\nreturn -EINVAL;\r\nret = bq2415x_exec_command(bq, command);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", ret);\r\n}\r\nstatic ssize_t bq2415x_sysfs_set_timer(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq2415x_device *bq = container_of(psy, struct bq2415x_device,\r\ncharger);\r\nint ret = 0;\r\nif (strncmp(buf, "auto", 4) == 0)\r\nbq2415x_set_autotimer(bq, 1);\r\nelse if (strncmp(buf, "off", 3) == 0)\r\nbq2415x_set_autotimer(bq, 0);\r\nelse\r\nret = bq2415x_exec_command(bq, BQ2415X_TIMER_RESET);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t bq2415x_sysfs_show_timer(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq2415x_device *bq = container_of(psy, struct bq2415x_device,\r\ncharger);\r\nif (bq->timer_error)\r\nreturn sprintf(buf, "%s\n", bq->timer_error);\r\nif (bq->autotimer)\r\nreturn sprintf(buf, "auto\n");\r\nreturn sprintf(buf, "off\n");\r\n}\r\nstatic ssize_t bq2415x_sysfs_set_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq2415x_device *bq = container_of(psy, struct bq2415x_device,\r\ncharger);\r\nenum bq2415x_mode mode;\r\nint ret = 0;\r\nif (strncmp(buf, "auto", 4) == 0) {\r\nif (bq->automode < 0)\r\nreturn -ENOSYS;\r\nbq->automode = 1;\r\nmode = bq->reported_mode;\r\n} else if (strncmp(buf, "off", 3) == 0) {\r\nif (bq->automode > 0)\r\nbq->automode = 0;\r\nmode = BQ2415X_MODE_OFF;\r\n} else if (strncmp(buf, "none", 4) == 0) {\r\nif (bq->automode > 0)\r\nbq->automode = 0;\r\nmode = BQ2415X_MODE_NONE;\r\n} else if (strncmp(buf, "host", 4) == 0) {\r\nif (bq->automode > 0)\r\nbq->automode = 0;\r\nmode = BQ2415X_MODE_HOST_CHARGER;\r\n} else if (strncmp(buf, "dedicated", 9) == 0) {\r\nif (bq->automode > 0)\r\nbq->automode = 0;\r\nmode = BQ2415X_MODE_DEDICATED_CHARGER;\r\n} else if (strncmp(buf, "boost", 5) == 0) {\r\nif (bq->automode > 0)\r\nbq->automode = 0;\r\nmode = BQ2415X_MODE_BOOST;\r\n} else if (strncmp(buf, "reset", 5) == 0) {\r\nbq2415x_reset_chip(bq);\r\nbq2415x_set_defaults(bq);\r\nif (bq->automode <= 0)\r\nreturn count;\r\nbq->automode = 1;\r\nmode = bq->reported_mode;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nret = bq2415x_set_mode(bq, mode);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t bq2415x_sysfs_show_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq2415x_device *bq = container_of(psy, struct bq2415x_device,\r\ncharger);\r\nssize_t ret = 0;\r\nif (bq->automode > 0)\r\nret += sprintf(buf+ret, "auto (");\r\nswitch (bq->mode) {\r\ncase BQ2415X_MODE_OFF:\r\nret += sprintf(buf+ret, "off");\r\nbreak;\r\ncase BQ2415X_MODE_NONE:\r\nret += sprintf(buf+ret, "none");\r\nbreak;\r\ncase BQ2415X_MODE_HOST_CHARGER:\r\nret += sprintf(buf+ret, "host");\r\nbreak;\r\ncase BQ2415X_MODE_DEDICATED_CHARGER:\r\nret += sprintf(buf+ret, "dedicated");\r\nbreak;\r\ncase BQ2415X_MODE_BOOST:\r\nret += sprintf(buf+ret, "boost");\r\nbreak;\r\n}\r\nif (bq->automode > 0)\r\nret += sprintf(buf+ret, ")");\r\nret += sprintf(buf+ret, "\n");\r\nreturn ret;\r\n}\r\nstatic ssize_t bq2415x_sysfs_show_reported_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq2415x_device *bq = container_of(psy, struct bq2415x_device,\r\ncharger);\r\nif (bq->automode < 0)\r\nreturn -EINVAL;\r\nswitch (bq->reported_mode) {\r\ncase BQ2415X_MODE_OFF:\r\nreturn sprintf(buf, "off\n");\r\ncase BQ2415X_MODE_NONE:\r\nreturn sprintf(buf, "none\n");\r\ncase BQ2415X_MODE_HOST_CHARGER:\r\nreturn sprintf(buf, "host\n");\r\ncase BQ2415X_MODE_DEDICATED_CHARGER:\r\nreturn sprintf(buf, "dedicated\n");\r\ncase BQ2415X_MODE_BOOST:\r\nreturn sprintf(buf, "boost\n");\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t bq2415x_sysfs_set_registers(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq2415x_device *bq = container_of(psy, struct bq2415x_device,\r\ncharger);\r\nssize_t ret = 0;\r\nunsigned int reg;\r\nunsigned int val;\r\nif (sscanf(buf, "%x %x", &reg, &val) != 2)\r\nreturn -EINVAL;\r\nif (reg > 4 || val > 255)\r\nreturn -EINVAL;\r\nret = bq2415x_i2c_write(bq, reg, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t bq2415x_sysfs_print_reg(struct bq2415x_device *bq,\r\nu8 reg,\r\nchar *buf)\r\n{\r\nint ret = bq2415x_i2c_read(bq, reg);\r\nif (ret < 0)\r\nreturn sprintf(buf, "%#.2x=error %d\n", reg, ret);\r\nreturn sprintf(buf, "%#.2x=%#.2x\n", reg, ret);\r\n}\r\nstatic ssize_t bq2415x_sysfs_show_registers(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq2415x_device *bq = container_of(psy, struct bq2415x_device,\r\ncharger);\r\nssize_t ret = 0;\r\nret += bq2415x_sysfs_print_reg(bq, BQ2415X_REG_STATUS, buf+ret);\r\nret += bq2415x_sysfs_print_reg(bq, BQ2415X_REG_CONTROL, buf+ret);\r\nret += bq2415x_sysfs_print_reg(bq, BQ2415X_REG_VOLTAGE, buf+ret);\r\nret += bq2415x_sysfs_print_reg(bq, BQ2415X_REG_VENDER, buf+ret);\r\nret += bq2415x_sysfs_print_reg(bq, BQ2415X_REG_CURRENT, buf+ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t bq2415x_sysfs_set_limit(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq2415x_device *bq = container_of(psy, struct bq2415x_device,\r\ncharger);\r\nlong val;\r\nint ret;\r\nif (kstrtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nif (strcmp(attr->attr.name, "current_limit") == 0)\r\nret = bq2415x_set_current_limit(bq, val);\r\nelse if (strcmp(attr->attr.name, "weak_battery_voltage") == 0)\r\nret = bq2415x_set_weak_battery_voltage(bq, val);\r\nelse if (strcmp(attr->attr.name, "battery_regulation_voltage") == 0)\r\nret = bq2415x_set_battery_regulation_voltage(bq, val);\r\nelse if (strcmp(attr->attr.name, "charge_current") == 0)\r\nret = bq2415x_set_charge_current(bq, val);\r\nelse if (strcmp(attr->attr.name, "termination_current") == 0)\r\nret = bq2415x_set_termination_current(bq, val);\r\nelse\r\nreturn -EINVAL;\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t bq2415x_sysfs_show_limit(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq2415x_device *bq = container_of(psy, struct bq2415x_device,\r\ncharger);\r\nint ret;\r\nif (strcmp(attr->attr.name, "current_limit") == 0)\r\nret = bq2415x_get_current_limit(bq);\r\nelse if (strcmp(attr->attr.name, "weak_battery_voltage") == 0)\r\nret = bq2415x_get_weak_battery_voltage(bq);\r\nelse if (strcmp(attr->attr.name, "battery_regulation_voltage") == 0)\r\nret = bq2415x_get_battery_regulation_voltage(bq);\r\nelse if (strcmp(attr->attr.name, "charge_current") == 0)\r\nret = bq2415x_get_charge_current(bq);\r\nelse if (strcmp(attr->attr.name, "termination_current") == 0)\r\nret = bq2415x_get_termination_current(bq);\r\nelse\r\nreturn -EINVAL;\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", ret);\r\n}\r\nstatic ssize_t bq2415x_sysfs_set_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq2415x_device *bq = container_of(psy, struct bq2415x_device,\r\ncharger);\r\nenum bq2415x_command command;\r\nlong val;\r\nint ret;\r\nif (kstrtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nif (strcmp(attr->attr.name, "charge_termination_enable") == 0)\r\ncommand = val ? BQ2415X_CHARGE_TERMINATION_ENABLE :\r\nBQ2415X_CHARGE_TERMINATION_DISABLE;\r\nelse if (strcmp(attr->attr.name, "high_impedance_enable") == 0)\r\ncommand = val ? BQ2415X_HIGH_IMPEDANCE_ENABLE :\r\nBQ2415X_HIGH_IMPEDANCE_DISABLE;\r\nelse if (strcmp(attr->attr.name, "otg_pin_enable") == 0)\r\ncommand = val ? BQ2415X_OTG_PIN_ENABLE :\r\nBQ2415X_OTG_PIN_DISABLE;\r\nelse if (strcmp(attr->attr.name, "stat_pin_enable") == 0)\r\ncommand = val ? BQ2415X_STAT_PIN_ENABLE :\r\nBQ2415X_STAT_PIN_DISABLE;\r\nelse\r\nreturn -EINVAL;\r\nret = bq2415x_exec_command(bq, command);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t bq2415x_sysfs_show_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct bq2415x_device *bq = container_of(psy, struct bq2415x_device,\r\ncharger);\r\nenum bq2415x_command command;\r\nint ret;\r\nif (strcmp(attr->attr.name, "charge_termination_enable") == 0)\r\ncommand = BQ2415X_CHARGE_TERMINATION_STATUS;\r\nelse if (strcmp(attr->attr.name, "high_impedance_enable") == 0)\r\ncommand = BQ2415X_HIGH_IMPEDANCE_STATUS;\r\nelse if (strcmp(attr->attr.name, "otg_pin_enable") == 0)\r\ncommand = BQ2415X_OTG_PIN_STATUS;\r\nelse if (strcmp(attr->attr.name, "stat_pin_enable") == 0)\r\ncommand = BQ2415X_STAT_PIN_STATUS;\r\nelse\r\nreturn -EINVAL;\r\nret = bq2415x_exec_command(bq, command);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", ret);\r\n}\r\nstatic int bq2415x_sysfs_init(struct bq2415x_device *bq)\r\n{\r\nreturn sysfs_create_group(&bq->charger.dev->kobj,\r\n&bq2415x_sysfs_attr_group);\r\n}\r\nstatic void bq2415x_sysfs_exit(struct bq2415x_device *bq)\r\n{\r\nsysfs_remove_group(&bq->charger.dev->kobj, &bq2415x_sysfs_attr_group);\r\n}\r\nstatic int bq2415x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nint num;\r\nchar *name;\r\nstruct bq2415x_device *bq;\r\nstruct device_node *np = client->dev.of_node;\r\nstruct bq2415x_platform_data *pdata = client->dev.platform_data;\r\nif (!np && !pdata) {\r\ndev_err(&client->dev, "platform data missing\n");\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&bq2415x_id_mutex);\r\nnum = idr_alloc(&bq2415x_id, client, 0, 0, GFP_KERNEL);\r\nmutex_unlock(&bq2415x_id_mutex);\r\nif (num < 0)\r\nreturn num;\r\nname = kasprintf(GFP_KERNEL, "%s-%d", id->name, num);\r\nif (!name) {\r\ndev_err(&client->dev, "failed to allocate device name\n");\r\nret = -ENOMEM;\r\ngoto error_1;\r\n}\r\nbq = devm_kzalloc(&client->dev, sizeof(*bq), GFP_KERNEL);\r\nif (!bq) {\r\ndev_err(&client->dev, "failed to allocate device data\n");\r\nret = -ENOMEM;\r\ngoto error_2;\r\n}\r\nif (np) {\r\nbq->notify_psy = power_supply_get_by_phandle(np, "ti,usb-charger-detection");\r\nif (!bq->notify_psy)\r\nreturn -EPROBE_DEFER;\r\n}\r\nelse if (pdata->notify_device)\r\nbq->notify_psy = power_supply_get_by_name(pdata->notify_device);\r\nelse\r\nbq->notify_psy = NULL;\r\ni2c_set_clientdata(client, bq);\r\nbq->id = num;\r\nbq->dev = &client->dev;\r\nbq->chip = id->driver_data;\r\nbq->name = name;\r\nbq->mode = BQ2415X_MODE_OFF;\r\nbq->reported_mode = BQ2415X_MODE_OFF;\r\nbq->autotimer = 0;\r\nbq->automode = 0;\r\nif (np) {\r\nret = of_property_read_u32(np, "ti,current-limit",\r\n&bq->init_data.current_limit);\r\nif (ret)\r\nreturn ret;\r\nret = of_property_read_u32(np, "ti,weak-battery-voltage",\r\n&bq->init_data.weak_battery_voltage);\r\nif (ret)\r\nreturn ret;\r\nret = of_property_read_u32(np, "ti,battery-regulation-voltage",\r\n&bq->init_data.battery_regulation_voltage);\r\nif (ret)\r\nreturn ret;\r\nret = of_property_read_u32(np, "ti,charge-current",\r\n&bq->init_data.charge_current);\r\nif (ret)\r\nreturn ret;\r\nret = of_property_read_u32(np, "ti,termination-current",\r\n&bq->init_data.termination_current);\r\nif (ret)\r\nreturn ret;\r\nret = of_property_read_u32(np, "ti,resistor-sense",\r\n&bq->init_data.resistor_sense);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nmemcpy(&bq->init_data, pdata, sizeof(bq->init_data));\r\n}\r\nbq2415x_reset_chip(bq);\r\nret = bq2415x_power_supply_init(bq);\r\nif (ret) {\r\ndev_err(bq->dev, "failed to register power supply: %d\n", ret);\r\ngoto error_2;\r\n}\r\nret = bq2415x_sysfs_init(bq);\r\nif (ret) {\r\ndev_err(bq->dev, "failed to create sysfs entries: %d\n", ret);\r\ngoto error_3;\r\n}\r\nret = bq2415x_set_defaults(bq);\r\nif (ret) {\r\ndev_err(bq->dev, "failed to set default values: %d\n", ret);\r\ngoto error_4;\r\n}\r\nif (bq->notify_psy) {\r\nbq->nb.notifier_call = bq2415x_notifier_call;\r\nret = power_supply_reg_notifier(&bq->nb);\r\nif (ret) {\r\ndev_err(bq->dev, "failed to reg notifier: %d\n", ret);\r\ngoto error_5;\r\n}\r\nbq2415x_notifier_call(&bq->nb, PSY_EVENT_PROP_CHANGED, bq->notify_psy);\r\nbq2415x_set_mode(bq, bq->reported_mode);\r\nbq->automode = 1;\r\ndev_info(bq->dev, "automode enabled\n");\r\n} else {\r\nbq->automode = -1;\r\ndev_info(bq->dev, "automode not supported\n");\r\n}\r\nINIT_DELAYED_WORK(&bq->work, bq2415x_timer_work);\r\nbq2415x_set_autotimer(bq, 1);\r\ndev_info(bq->dev, "driver registered\n");\r\nreturn 0;\r\nerror_5:\r\nerror_4:\r\nbq2415x_sysfs_exit(bq);\r\nerror_3:\r\nbq2415x_power_supply_exit(bq);\r\nerror_2:\r\nkfree(name);\r\nerror_1:\r\nmutex_lock(&bq2415x_id_mutex);\r\nidr_remove(&bq2415x_id, num);\r\nmutex_unlock(&bq2415x_id_mutex);\r\nreturn ret;\r\n}\r\nstatic int bq2415x_remove(struct i2c_client *client)\r\n{\r\nstruct bq2415x_device *bq = i2c_get_clientdata(client);\r\nif (bq->notify_psy)\r\npower_supply_unreg_notifier(&bq->nb);\r\nbq2415x_sysfs_exit(bq);\r\nbq2415x_power_supply_exit(bq);\r\nbq2415x_reset_chip(bq);\r\nmutex_lock(&bq2415x_id_mutex);\r\nidr_remove(&bq2415x_id, bq->id);\r\nmutex_unlock(&bq2415x_id_mutex);\r\ndev_info(bq->dev, "driver unregistered\n");\r\nkfree(bq->name);\r\nreturn 0;\r\n}
