static int dwc3_pci_register_phys(struct dwc3_pci *glue)\r\n{\r\nstruct usb_phy_gen_xceiv_platform_data pdata;\r\nstruct platform_device *pdev;\r\nint ret;\r\nmemset(&pdata, 0x00, sizeof(pdata));\r\npdev = platform_device_alloc("usb_phy_gen_xceiv", 0);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\nglue->usb2_phy = pdev;\r\npdata.type = USB_PHY_TYPE_USB2;\r\npdata.gpio_reset = -1;\r\nret = platform_device_add_data(glue->usb2_phy, &pdata, sizeof(pdata));\r\nif (ret)\r\ngoto err1;\r\npdev = platform_device_alloc("usb_phy_gen_xceiv", 1);\r\nif (!pdev) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nglue->usb3_phy = pdev;\r\npdata.type = USB_PHY_TYPE_USB3;\r\nret = platform_device_add_data(glue->usb3_phy, &pdata, sizeof(pdata));\r\nif (ret)\r\ngoto err2;\r\nret = platform_device_add(glue->usb2_phy);\r\nif (ret)\r\ngoto err2;\r\nret = platform_device_add(glue->usb3_phy);\r\nif (ret)\r\ngoto err3;\r\nreturn 0;\r\nerr3:\r\nplatform_device_del(glue->usb2_phy);\r\nerr2:\r\nplatform_device_put(glue->usb3_phy);\r\nerr1:\r\nplatform_device_put(glue->usb2_phy);\r\nreturn ret;\r\n}\r\nstatic int dwc3_pci_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct resource res[2];\r\nstruct platform_device *dwc3;\r\nstruct dwc3_pci *glue;\r\nint ret = -ENOMEM;\r\nstruct device *dev = &pci->dev;\r\nglue = devm_kzalloc(dev, sizeof(*glue), GFP_KERNEL);\r\nif (!glue) {\r\ndev_err(dev, "not enough memory\n");\r\nreturn -ENOMEM;\r\n}\r\nglue->dev = dev;\r\nret = pci_enable_device(pci);\r\nif (ret) {\r\ndev_err(dev, "failed to enable pci device\n");\r\nreturn -ENODEV;\r\n}\r\npci_set_master(pci);\r\nret = dwc3_pci_register_phys(glue);\r\nif (ret) {\r\ndev_err(dev, "couldn't register PHYs\n");\r\nreturn ret;\r\n}\r\ndwc3 = platform_device_alloc("dwc3", PLATFORM_DEVID_AUTO);\r\nif (!dwc3) {\r\ndev_err(dev, "couldn't allocate dwc3 device\n");\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nmemset(res, 0x00, sizeof(struct resource) * ARRAY_SIZE(res));\r\nres[0].start = pci_resource_start(pci, 0);\r\nres[0].end = pci_resource_end(pci, 0);\r\nres[0].name = "dwc_usb3";\r\nres[0].flags = IORESOURCE_MEM;\r\nres[1].start = pci->irq;\r\nres[1].name = "dwc_usb3";\r\nres[1].flags = IORESOURCE_IRQ;\r\nret = platform_device_add_resources(dwc3, res, ARRAY_SIZE(res));\r\nif (ret) {\r\ndev_err(dev, "couldn't add resources to dwc3 device\n");\r\ngoto err1;\r\n}\r\npci_set_drvdata(pci, glue);\r\ndma_set_coherent_mask(&dwc3->dev, dev->coherent_dma_mask);\r\ndwc3->dev.dma_mask = dev->dma_mask;\r\ndwc3->dev.dma_parms = dev->dma_parms;\r\ndwc3->dev.parent = dev;\r\nglue->dwc3 = dwc3;\r\nret = platform_device_add(dwc3);\r\nif (ret) {\r\ndev_err(dev, "failed to register dwc3 device\n");\r\ngoto err3;\r\n}\r\nreturn 0;\r\nerr3:\r\nplatform_device_put(dwc3);\r\nerr1:\r\npci_disable_device(pci);\r\nreturn ret;\r\n}\r\nstatic void dwc3_pci_remove(struct pci_dev *pci)\r\n{\r\nstruct dwc3_pci *glue = pci_get_drvdata(pci);\r\nplatform_device_unregister(glue->dwc3);\r\nplatform_device_unregister(glue->usb2_phy);\r\nplatform_device_unregister(glue->usb3_phy);\r\npci_disable_device(pci);\r\n}\r\nstatic int dwc3_pci_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\npci_disable_device(pci);\r\nreturn 0;\r\n}\r\nstatic int dwc3_pci_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nint ret;\r\nret = pci_enable_device(pci);\r\nif (ret) {\r\ndev_err(dev, "can't re-enable device --> %d\n", ret);\r\nreturn ret;\r\n}\r\npci_set_master(pci);\r\nreturn 0;\r\n}
