static void ioh_gpio_set(struct gpio_chip *gpio, unsigned nr, int val)\r\n{\r\nu32 reg_val;\r\nstruct ioh_gpio *chip = container_of(gpio, struct ioh_gpio, gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nreg_val = ioread32(&chip->reg->regs[chip->ch].po);\r\nif (val)\r\nreg_val |= (1 << nr);\r\nelse\r\nreg_val &= ~(1 << nr);\r\niowrite32(reg_val, &chip->reg->regs[chip->ch].po);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\n}\r\nstatic int ioh_gpio_get(struct gpio_chip *gpio, unsigned nr)\r\n{\r\nstruct ioh_gpio *chip = container_of(gpio, struct ioh_gpio, gpio);\r\nreturn ioread32(&chip->reg->regs[chip->ch].pi) & (1 << nr);\r\n}\r\nstatic int ioh_gpio_direction_output(struct gpio_chip *gpio, unsigned nr,\r\nint val)\r\n{\r\nstruct ioh_gpio *chip = container_of(gpio, struct ioh_gpio, gpio);\r\nu32 pm;\r\nu32 reg_val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\npm = ioread32(&chip->reg->regs[chip->ch].pm) &\r\n((1 << num_ports[chip->ch]) - 1);\r\npm |= (1 << nr);\r\niowrite32(pm, &chip->reg->regs[chip->ch].pm);\r\nreg_val = ioread32(&chip->reg->regs[chip->ch].po);\r\nif (val)\r\nreg_val |= (1 << nr);\r\nelse\r\nreg_val &= ~(1 << nr);\r\niowrite32(reg_val, &chip->reg->regs[chip->ch].po);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int ioh_gpio_direction_input(struct gpio_chip *gpio, unsigned nr)\r\n{\r\nstruct ioh_gpio *chip = container_of(gpio, struct ioh_gpio, gpio);\r\nu32 pm;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\npm = ioread32(&chip->reg->regs[chip->ch].pm) &\r\n((1 << num_ports[chip->ch]) - 1);\r\npm &= ~(1 << nr);\r\niowrite32(pm, &chip->reg->regs[chip->ch].pm);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic void ioh_gpio_save_reg_conf(struct ioh_gpio *chip)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i ++, chip++) {\r\nchip->ioh_gpio_reg.po_reg =\r\nioread32(&chip->reg->regs[chip->ch].po);\r\nchip->ioh_gpio_reg.pm_reg =\r\nioread32(&chip->reg->regs[chip->ch].pm);\r\nchip->ioh_gpio_reg.ien_reg =\r\nioread32(&chip->reg->regs[chip->ch].ien);\r\nchip->ioh_gpio_reg.imask_reg =\r\nioread32(&chip->reg->regs[chip->ch].imask);\r\nchip->ioh_gpio_reg.im0_reg =\r\nioread32(&chip->reg->regs[chip->ch].im_0);\r\nchip->ioh_gpio_reg.im1_reg =\r\nioread32(&chip->reg->regs[chip->ch].im_1);\r\nif (i < 4)\r\nchip->ioh_gpio_reg.use_sel_reg =\r\nioread32(&chip->reg->ioh_sel_reg[i]);\r\n}\r\n}\r\nstatic void ioh_gpio_restore_reg_conf(struct ioh_gpio *chip)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i ++, chip++) {\r\niowrite32(chip->ioh_gpio_reg.po_reg,\r\n&chip->reg->regs[chip->ch].po);\r\niowrite32(chip->ioh_gpio_reg.pm_reg,\r\n&chip->reg->regs[chip->ch].pm);\r\niowrite32(chip->ioh_gpio_reg.ien_reg,\r\n&chip->reg->regs[chip->ch].ien);\r\niowrite32(chip->ioh_gpio_reg.imask_reg,\r\n&chip->reg->regs[chip->ch].imask);\r\niowrite32(chip->ioh_gpio_reg.im0_reg,\r\n&chip->reg->regs[chip->ch].im_0);\r\niowrite32(chip->ioh_gpio_reg.im1_reg,\r\n&chip->reg->regs[chip->ch].im_1);\r\nif (i < 4)\r\niowrite32(chip->ioh_gpio_reg.use_sel_reg,\r\n&chip->reg->ioh_sel_reg[i]);\r\n}\r\n}\r\nstatic int ioh_gpio_to_irq(struct gpio_chip *gpio, unsigned offset)\r\n{\r\nstruct ioh_gpio *chip = container_of(gpio, struct ioh_gpio, gpio);\r\nreturn chip->irq_base + offset;\r\n}\r\nstatic void ioh_gpio_setup(struct ioh_gpio *chip, int num_port)\r\n{\r\nstruct gpio_chip *gpio = &chip->gpio;\r\ngpio->label = dev_name(chip->dev);\r\ngpio->owner = THIS_MODULE;\r\ngpio->direction_input = ioh_gpio_direction_input;\r\ngpio->get = ioh_gpio_get;\r\ngpio->direction_output = ioh_gpio_direction_output;\r\ngpio->set = ioh_gpio_set;\r\ngpio->dbg_show = NULL;\r\ngpio->base = -1;\r\ngpio->ngpio = num_port;\r\ngpio->can_sleep = false;\r\ngpio->to_irq = ioh_gpio_to_irq;\r\n}\r\nstatic int ioh_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nu32 im;\r\nvoid __iomem *im_reg;\r\nu32 ien;\r\nu32 im_pos;\r\nint ch;\r\nunsigned long flags;\r\nu32 val;\r\nint irq = d->irq;\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct ioh_gpio *chip = gc->private;\r\nch = irq - chip->irq_base;\r\nif (irq <= chip->irq_base + 7) {\r\nim_reg = &chip->reg->regs[chip->ch].im_0;\r\nim_pos = ch;\r\n} else {\r\nim_reg = &chip->reg->regs[chip->ch].im_1;\r\nim_pos = ch - 8;\r\n}\r\ndev_dbg(chip->dev, "%s:irq=%d type=%d ch=%d pos=%d type=%d\n",\r\n__func__, irq, type, ch, im_pos, type);\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nval = IOH_EDGE_RISING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nval = IOH_EDGE_FALLING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nval = IOH_EDGE_BOTH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nval = IOH_LEVEL_H;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nval = IOH_LEVEL_L;\r\nbreak;\r\ncase IRQ_TYPE_PROBE:\r\ngoto end;\r\ndefault:\r\ndev_warn(chip->dev, "%s: unknown type(%dd)",\r\n__func__, type);\r\ngoto end;\r\n}\r\nim = ioread32(im_reg) & ~(IOH_IM_MASK << (im_pos * 4));\r\niowrite32(im | (val << (im_pos * 4)), im_reg);\r\niowrite32(BIT(ch), &chip->reg->regs[chip->ch].iclr);\r\niowrite32(BIT(ch), &chip->reg->regs[chip->ch].imaskclr);\r\nien = ioread32(&chip->reg->regs[chip->ch].ien);\r\niowrite32(ien | BIT(ch), &chip->reg->regs[chip->ch].ien);\r\nend:\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic void ioh_irq_unmask(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct ioh_gpio *chip = gc->private;\r\niowrite32(1 << (d->irq - chip->irq_base),\r\n&chip->reg->regs[chip->ch].imaskclr);\r\n}\r\nstatic void ioh_irq_mask(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct ioh_gpio *chip = gc->private;\r\niowrite32(1 << (d->irq - chip->irq_base),\r\n&chip->reg->regs[chip->ch].imask);\r\n}\r\nstatic void ioh_irq_disable(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct ioh_gpio *chip = gc->private;\r\nunsigned long flags;\r\nu32 ien;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nien = ioread32(&chip->reg->regs[chip->ch].ien);\r\nien &= ~(1 << (d->irq - chip->irq_base));\r\niowrite32(ien, &chip->reg->regs[chip->ch].ien);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\n}\r\nstatic void ioh_irq_enable(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct ioh_gpio *chip = gc->private;\r\nunsigned long flags;\r\nu32 ien;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nien = ioread32(&chip->reg->regs[chip->ch].ien);\r\nien |= 1 << (d->irq - chip->irq_base);\r\niowrite32(ien, &chip->reg->regs[chip->ch].ien);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\n}\r\nstatic irqreturn_t ioh_gpio_handler(int irq, void *dev_id)\r\n{\r\nstruct ioh_gpio *chip = dev_id;\r\nu32 reg_val;\r\nint i, j;\r\nint ret = IRQ_NONE;\r\nfor (i = 0; i < 8; i++, chip++) {\r\nreg_val = ioread32(&chip->reg->regs[i].istatus);\r\nfor (j = 0; j < num_ports[i]; j++) {\r\nif (reg_val & BIT(j)) {\r\ndev_dbg(chip->dev,\r\n"%s:[%d]:irq=%d status=0x%x\n",\r\n__func__, j, irq, reg_val);\r\niowrite32(BIT(j),\r\n&chip->reg->regs[chip->ch].iclr);\r\ngeneric_handle_irq(chip->irq_base + j);\r\nret = IRQ_HANDLED;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void ioh_gpio_alloc_generic_chip(struct ioh_gpio *chip,\r\nunsigned int irq_start, unsigned int num)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\ngc = irq_alloc_generic_chip("ioh_gpio", 1, irq_start, chip->base,\r\nhandle_simple_irq);\r\ngc->private = chip;\r\nct = gc->chip_types;\r\nct->chip.irq_mask = ioh_irq_mask;\r\nct->chip.irq_unmask = ioh_irq_unmask;\r\nct->chip.irq_set_type = ioh_irq_type;\r\nct->chip.irq_disable = ioh_irq_disable;\r\nct->chip.irq_enable = ioh_irq_enable;\r\nirq_setup_generic_chip(gc, IRQ_MSK(num), IRQ_GC_INIT_MASK_CACHE,\r\nIRQ_NOREQUEST | IRQ_NOPROBE, 0);\r\n}\r\nstatic int ioh_gpio_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint ret;\r\nint i, j;\r\nstruct ioh_gpio *chip;\r\nvoid __iomem *base;\r\nvoid *chip_save;\r\nint irq_base;\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s : pci_enable_device failed", __func__);\r\ngoto err_pci_enable;\r\n}\r\nret = pci_request_regions(pdev, KBUILD_MODNAME);\r\nif (ret) {\r\ndev_err(&pdev->dev, "pci_request_regions failed-%d", ret);\r\ngoto err_request_regions;\r\n}\r\nbase = pci_iomap(pdev, 1, 0);\r\nif (!base) {\r\ndev_err(&pdev->dev, "%s : pci_iomap failed", __func__);\r\nret = -ENOMEM;\r\ngoto err_iomap;\r\n}\r\nchip_save = kzalloc(sizeof(*chip) * 8, GFP_KERNEL);\r\nif (chip_save == NULL) {\r\ndev_err(&pdev->dev, "%s : kzalloc failed", __func__);\r\nret = -ENOMEM;\r\ngoto err_kzalloc;\r\n}\r\nchip = chip_save;\r\nfor (i = 0; i < 8; i++, chip++) {\r\nchip->dev = &pdev->dev;\r\nchip->base = base;\r\nchip->reg = chip->base;\r\nchip->ch = i;\r\nspin_lock_init(&chip->spinlock);\r\nioh_gpio_setup(chip, num_ports[i]);\r\nret = gpiochip_add(&chip->gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev, "IOH gpio: Failed to register GPIO\n");\r\ngoto err_gpiochip_add;\r\n}\r\n}\r\nchip = chip_save;\r\nfor (j = 0; j < 8; j++, chip++) {\r\nirq_base = irq_alloc_descs(-1, IOH_IRQ_BASE, num_ports[j],\r\nNUMA_NO_NODE);\r\nif (irq_base < 0) {\r\ndev_warn(&pdev->dev,\r\n"ml_ioh_gpio: Failed to get IRQ base num\n");\r\nchip->irq_base = -1;\r\nret = irq_base;\r\ngoto err_irq_alloc_descs;\r\n}\r\nchip->irq_base = irq_base;\r\nioh_gpio_alloc_generic_chip(chip, irq_base, num_ports[j]);\r\n}\r\nchip = chip_save;\r\nret = request_irq(pdev->irq, ioh_gpio_handler,\r\nIRQF_SHARED, KBUILD_MODNAME, chip);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev,\r\n"%s request_irq failed\n", __func__);\r\ngoto err_request_irq;\r\n}\r\npci_set_drvdata(pdev, chip);\r\nreturn 0;\r\nerr_request_irq:\r\nchip = chip_save;\r\nerr_irq_alloc_descs:\r\nwhile (--j >= 0) {\r\nchip--;\r\nirq_free_descs(chip->irq_base, num_ports[j]);\r\n}\r\nchip = chip_save;\r\nerr_gpiochip_add:\r\nwhile (--i >= 0) {\r\nchip--;\r\nif (gpiochip_remove(&chip->gpio))\r\ndev_err(&pdev->dev, "Failed gpiochip_remove(%d)\n", i);\r\n}\r\nkfree(chip_save);\r\nerr_kzalloc:\r\npci_iounmap(pdev, base);\r\nerr_iomap:\r\npci_release_regions(pdev);\r\nerr_request_regions:\r\npci_disable_device(pdev);\r\nerr_pci_enable:\r\ndev_err(&pdev->dev, "%s Failed returns %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void ioh_gpio_remove(struct pci_dev *pdev)\r\n{\r\nint err;\r\nint i;\r\nstruct ioh_gpio *chip = pci_get_drvdata(pdev);\r\nvoid *chip_save;\r\nchip_save = chip;\r\nfree_irq(pdev->irq, chip);\r\nfor (i = 0; i < 8; i++, chip++) {\r\nirq_free_descs(chip->irq_base, num_ports[i]);\r\nerr = gpiochip_remove(&chip->gpio);\r\nif (err)\r\ndev_err(&pdev->dev, "Failed gpiochip_remove\n");\r\n}\r\nchip = chip_save;\r\npci_iounmap(pdev, chip->base);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nkfree(chip);\r\n}\r\nstatic int ioh_gpio_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\ns32 ret;\r\nstruct ioh_gpio *chip = pci_get_drvdata(pdev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\nioh_gpio_save_reg_conf(chip);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nret = pci_save_state(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "pci_save_state Failed-%d\n", ret);\r\nreturn ret;\r\n}\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, PCI_D0);\r\nret = pci_enable_wake(pdev, PCI_D0, 1);\r\nif (ret)\r\ndev_err(&pdev->dev, "pci_enable_wake Failed -%d\n", ret);\r\nreturn 0;\r\n}\r\nstatic int ioh_gpio_resume(struct pci_dev *pdev)\r\n{\r\ns32 ret;\r\nstruct ioh_gpio *chip = pci_get_drvdata(pdev);\r\nunsigned long flags;\r\nret = pci_enable_wake(pdev, PCI_D0, 0);\r\npci_set_power_state(pdev, PCI_D0);\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "pci_enable_device Failed-%d ", ret);\r\nreturn ret;\r\n}\r\npci_restore_state(pdev);\r\nspin_lock_irqsave(&chip->spinlock, flags);\r\niowrite32(0x01, &chip->reg->srst);\r\niowrite32(0x00, &chip->reg->srst);\r\nioh_gpio_restore_reg_conf(chip);\r\nspin_unlock_irqrestore(&chip->spinlock, flags);\r\nreturn 0;\r\n}
