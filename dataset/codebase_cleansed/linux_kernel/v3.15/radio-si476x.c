static inline bool si476x_radio_freq_is_inside_of_the_band(u32 freq, int band)\r\n{\r\nreturn freq >= si476x_bands[band].rangelow &&\r\nfreq <= si476x_bands[band].rangehigh;\r\n}\r\nstatic inline bool si476x_radio_range_is_inside_of_the_band(u32 low, u32 high,\r\nint band)\r\n{\r\nreturn low >= si476x_bands[band].rangelow &&\r\nhigh <= si476x_bands[band].rangehigh;\r\n}\r\nstatic inline enum phase_diversity_modes_idx\r\nsi476x_phase_diversity_mode_to_idx(enum si476x_phase_diversity_mode mode)\r\n{\r\nswitch (mode) {\r\ndefault:\r\ncase SI476X_PHDIV_DISABLED:\r\nreturn SI476X_IDX_PHDIV_DISABLED;\r\ncase SI476X_PHDIV_PRIMARY_COMBINING:\r\nreturn SI476X_IDX_PHDIV_PRIMARY_COMBINING;\r\ncase SI476X_PHDIV_PRIMARY_ANTENNA:\r\nreturn SI476X_IDX_PHDIV_PRIMARY_ANTENNA;\r\ncase SI476X_PHDIV_SECONDARY_ANTENNA:\r\nreturn SI476X_IDX_PHDIV_SECONDARY_ANTENNA;\r\ncase SI476X_PHDIV_SECONDARY_COMBINING:\r\nreturn SI476X_IDX_PHDIV_SECONDARY_COMBINING;\r\n}\r\n}\r\nstatic inline enum si476x_phase_diversity_mode\r\nsi476x_phase_diversity_idx_to_mode(enum phase_diversity_modes_idx idx)\r\n{\r\nstatic const int idx_to_value[] = {\r\n[SI476X_IDX_PHDIV_DISABLED] = SI476X_PHDIV_DISABLED,\r\n[SI476X_IDX_PHDIV_PRIMARY_COMBINING] = SI476X_PHDIV_PRIMARY_COMBINING,\r\n[SI476X_IDX_PHDIV_PRIMARY_ANTENNA] = SI476X_PHDIV_PRIMARY_ANTENNA,\r\n[SI476X_IDX_PHDIV_SECONDARY_ANTENNA] = SI476X_PHDIV_SECONDARY_ANTENNA,\r\n[SI476X_IDX_PHDIV_SECONDARY_COMBINING] = SI476X_PHDIV_SECONDARY_COMBINING,\r\n};\r\nreturn idx_to_value[idx];\r\n}\r\nstatic inline struct si476x_radio *\r\nv4l2_dev_to_radio(struct v4l2_device *d)\r\n{\r\nreturn container_of(d, struct si476x_radio, v4l2dev);\r\n}\r\nstatic inline struct si476x_radio *\r\nv4l2_ctrl_handler_to_radio(struct v4l2_ctrl_handler *d)\r\n{\r\nreturn container_of(d, struct si476x_radio, ctrl_handler);\r\n}\r\nstatic int si476x_radio_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *capability)\r\n{\r\nstruct si476x_radio *radio = video_drvdata(file);\r\nstrlcpy(capability->driver, radio->v4l2dev.name,\r\nsizeof(capability->driver));\r\nstrlcpy(capability->card, DRIVER_CARD, sizeof(capability->card));\r\nsnprintf(capability->bus_info, sizeof(capability->bus_info),\r\n"platform:%s", radio->v4l2dev.name);\r\ncapability->device_caps = V4L2_CAP_TUNER\r\n| V4L2_CAP_RADIO\r\n| V4L2_CAP_HW_FREQ_SEEK;\r\nsi476x_core_lock(radio->core);\r\nif (!si476x_core_is_a_secondary_tuner(radio->core))\r\ncapability->device_caps |= V4L2_CAP_RDS_CAPTURE\r\n| V4L2_CAP_READWRITE;\r\nsi476x_core_unlock(radio->core);\r\ncapability->capabilities = capability->device_caps\r\n| V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int si476x_radio_enum_freq_bands(struct file *file, void *priv,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nint err;\r\nstruct si476x_radio *radio = video_drvdata(file);\r\nif (band->tuner != 0)\r\nreturn -EINVAL;\r\nswitch (radio->core->chip_id) {\r\ncase SI476X_CHIP_SI4761:\r\ncase SI476X_CHIP_SI4764:\r\nif (band->index < ARRAY_SIZE(si476x_bands)) {\r\n*band = si476x_bands[band->index];\r\nerr = 0;\r\n} else {\r\nerr = -EINVAL;\r\n}\r\nbreak;\r\ncase SI476X_CHIP_SI4768:\r\nif (band->index == SI476X_BAND_FM) {\r\n*band = si476x_bands[band->index];\r\nerr = 0;\r\n} else {\r\nerr = -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int si476x_radio_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *tuner)\r\n{\r\nint err;\r\nstruct si476x_rsq_status_report report;\r\nstruct si476x_radio *radio = video_drvdata(file);\r\nstruct si476x_rsq_status_args args = {\r\n.primary = false,\r\n.rsqack = false,\r\n.attune = false,\r\n.cancel = false,\r\n.stcack = false,\r\n};\r\nif (tuner->index != 0)\r\nreturn -EINVAL;\r\ntuner->type = V4L2_TUNER_RADIO;\r\ntuner->capability = V4L2_TUNER_CAP_LOW\r\n| V4L2_TUNER_CAP_STEREO\r\n| V4L2_TUNER_CAP_HWSEEK_BOUNDED\r\n| V4L2_TUNER_CAP_HWSEEK_WRAP\r\n| V4L2_TUNER_CAP_HWSEEK_PROG_LIM;\r\nsi476x_core_lock(radio->core);\r\nif (si476x_core_is_a_secondary_tuner(radio->core)) {\r\nstrlcpy(tuner->name, "FM (secondary)", sizeof(tuner->name));\r\ntuner->rxsubchans = 0;\r\ntuner->rangelow = si476x_bands[SI476X_BAND_FM].rangelow;\r\n} else if (si476x_core_has_am(radio->core)) {\r\nif (si476x_core_is_a_primary_tuner(radio->core))\r\nstrlcpy(tuner->name, "AM/FM (primary)",\r\nsizeof(tuner->name));\r\nelse\r\nstrlcpy(tuner->name, "AM/FM", sizeof(tuner->name));\r\ntuner->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO\r\n| V4L2_TUNER_SUB_RDS;\r\ntuner->capability |= V4L2_TUNER_CAP_RDS\r\n| V4L2_TUNER_CAP_RDS_BLOCK_IO\r\n| V4L2_TUNER_CAP_FREQ_BANDS;\r\ntuner->rangelow = si476x_bands[SI476X_BAND_AM].rangelow;\r\n} else {\r\nstrlcpy(tuner->name, "FM", sizeof(tuner->name));\r\ntuner->rxsubchans = V4L2_TUNER_SUB_RDS;\r\ntuner->capability |= V4L2_TUNER_CAP_RDS\r\n| V4L2_TUNER_CAP_RDS_BLOCK_IO\r\n| V4L2_TUNER_CAP_FREQ_BANDS;\r\ntuner->rangelow = si476x_bands[SI476X_BAND_FM].rangelow;\r\n}\r\ntuner->audmode = radio->audmode;\r\ntuner->afc = 1;\r\ntuner->rangehigh = si476x_bands[SI476X_BAND_FM].rangehigh;\r\nerr = radio->ops->rsq_status(radio->core,\r\n&args, &report);\r\nif (err < 0) {\r\ntuner->signal = 0;\r\n} else {\r\ntuner->signal = (report.rssi + 128) * 257;\r\n}\r\nsi476x_core_unlock(radio->core);\r\nreturn err;\r\n}\r\nstatic int si476x_radio_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *tuner)\r\n{\r\nstruct si476x_radio *radio = video_drvdata(file);\r\nif (tuner->index != 0)\r\nreturn -EINVAL;\r\nif (tuner->audmode == V4L2_TUNER_MODE_MONO ||\r\ntuner->audmode == V4L2_TUNER_MODE_STEREO)\r\nradio->audmode = tuner->audmode;\r\nelse\r\nradio->audmode = V4L2_TUNER_MODE_STEREO;\r\nreturn 0;\r\n}\r\nstatic int si476x_radio_init_vtable(struct si476x_radio *radio,\r\nenum si476x_func func)\r\n{\r\nstatic const struct si476x_radio_ops fm_ops = {\r\n.tune_freq = si476x_core_cmd_fm_tune_freq,\r\n.seek_start = si476x_core_cmd_fm_seek_start,\r\n.rsq_status = si476x_core_cmd_fm_rsq_status,\r\n.rds_blckcnt = si476x_core_cmd_fm_rds_blockcount,\r\n.phase_diversity = si476x_core_cmd_fm_phase_diversity,\r\n.phase_div_status = si476x_core_cmd_fm_phase_div_status,\r\n.acf_status = si476x_core_cmd_fm_acf_status,\r\n.agc_status = si476x_core_cmd_agc_status,\r\n};\r\nstatic const struct si476x_radio_ops am_ops = {\r\n.tune_freq = si476x_core_cmd_am_tune_freq,\r\n.seek_start = si476x_core_cmd_am_seek_start,\r\n.rsq_status = si476x_core_cmd_am_rsq_status,\r\n.rds_blckcnt = NULL,\r\n.phase_diversity = NULL,\r\n.phase_div_status = NULL,\r\n.acf_status = si476x_core_cmd_am_acf_status,\r\n.agc_status = NULL,\r\n};\r\nswitch (func) {\r\ncase SI476X_FUNC_FM_RECEIVER:\r\nradio->ops = &fm_ops;\r\nreturn 0;\r\ncase SI476X_FUNC_AM_RECEIVER:\r\nradio->ops = &am_ops;\r\nreturn 0;\r\ndefault:\r\nWARN(1, "Unexpected tuner function value\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int si476x_radio_pretune(struct si476x_radio *radio,\r\nenum si476x_func func)\r\n{\r\nint retval;\r\nstruct si476x_tune_freq_args args = {\r\n.zifsr = false,\r\n.hd = false,\r\n.injside = SI476X_INJSIDE_AUTO,\r\n.tunemode = SI476X_TM_VALIDATED_NORMAL_TUNE,\r\n.smoothmetrics = SI476X_SM_INITIALIZE_AUDIO,\r\n.antcap = 0,\r\n};\r\nswitch (func) {\r\ncase SI476X_FUNC_FM_RECEIVER:\r\nargs.freq = v4l2_to_si476x(radio->core,\r\n92 * FREQ_MUL);\r\nretval = radio->ops->tune_freq(radio->core, &args);\r\nbreak;\r\ncase SI476X_FUNC_AM_RECEIVER:\r\nargs.freq = v4l2_to_si476x(radio->core,\r\n0.6 * FREQ_MUL);\r\nretval = radio->ops->tune_freq(radio->core, &args);\r\nbreak;\r\ndefault:\r\nWARN(1, "Unexpected tuner function value\n");\r\nretval = -EINVAL;\r\n}\r\nreturn retval;\r\n}\r\nstatic int si476x_radio_do_post_powerup_init(struct si476x_radio *radio,\r\nenum si476x_func func)\r\n{\r\nint err;\r\nerr = regcache_sync_region(radio->core->regmap,\r\nSI476X_PROP_DIGITAL_IO_INPUT_SAMPLE_RATE,\r\nSI476X_PROP_DIGITAL_IO_OUTPUT_FORMAT);\r\nif (err < 0)\r\nreturn err;\r\nerr = regcache_sync_region(radio->core->regmap,\r\nSI476X_PROP_AUDIO_DEEMPHASIS,\r\nSI476X_PROP_AUDIO_PWR_LINE_FILTER);\r\nif (err < 0)\r\nreturn err;\r\nerr = regcache_sync_region(radio->core->regmap,\r\nSI476X_PROP_INT_CTL_ENABLE,\r\nSI476X_PROP_INT_CTL_ENABLE);\r\nif (err < 0)\r\nreturn err;\r\nerr = regcache_sync_region(radio->core->regmap,\r\nSI476X_PROP_VALID_MAX_TUNE_ERROR,\r\nSI476X_PROP_VALID_MAX_TUNE_ERROR);\r\nif (err < 0)\r\nreturn err;\r\nerr = regcache_sync_region(radio->core->regmap,\r\nSI476X_PROP_VALID_SNR_THRESHOLD,\r\nSI476X_PROP_VALID_RSSI_THRESHOLD);\r\nif (err < 0)\r\nreturn err;\r\nif (func == SI476X_FUNC_FM_RECEIVER) {\r\nif (si476x_core_has_diversity(radio->core)) {\r\nerr = si476x_core_cmd_fm_phase_diversity(radio->core,\r\nradio->core->diversity_mode);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = regcache_sync_region(radio->core->regmap,\r\nSI476X_PROP_FM_RDS_INTERRUPT_SOURCE,\r\nSI476X_PROP_FM_RDS_CONFIG);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn si476x_radio_init_vtable(radio, func);\r\n}\r\nstatic int si476x_radio_change_func(struct si476x_radio *radio,\r\nenum si476x_func func)\r\n{\r\nint err;\r\nbool soft;\r\nif (func == radio->core->power_up_parameters.func)\r\nreturn 0;\r\nsoft = true;\r\nerr = si476x_core_stop(radio->core, soft);\r\nif (err < 0) {\r\nsoft = false;\r\nerr = si476x_core_stop(radio->core, soft);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nradio->core->power_up_parameters.func = func;\r\nerr = si476x_core_start(radio->core, soft);\r\nif (err < 0)\r\nreturn err;\r\nif (func != SI476X_FUNC_FM_RECEIVER &&\r\nfunc != SI476X_FUNC_AM_RECEIVER)\r\nreturn err;\r\nreturn si476x_radio_do_post_powerup_init(radio, func);\r\n}\r\nstatic int si476x_radio_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nint err;\r\nstruct si476x_radio *radio = video_drvdata(file);\r\nif (f->tuner != 0 ||\r\nf->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nsi476x_core_lock(radio->core);\r\nif (radio->ops->rsq_status) {\r\nstruct si476x_rsq_status_report report;\r\nstruct si476x_rsq_status_args args = {\r\n.primary = false,\r\n.rsqack = false,\r\n.attune = true,\r\n.cancel = false,\r\n.stcack = false,\r\n};\r\nerr = radio->ops->rsq_status(radio->core, &args, &report);\r\nif (!err)\r\nf->frequency = si476x_to_v4l2(radio->core,\r\nreport.readfreq);\r\n} else {\r\nerr = -EINVAL;\r\n}\r\nsi476x_core_unlock(radio->core);\r\nreturn err;\r\n}\r\nstatic int si476x_radio_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nint err;\r\nu32 freq = f->frequency;\r\nstruct si476x_tune_freq_args args;\r\nstruct si476x_radio *radio = video_drvdata(file);\r\nconst u32 midrange = (si476x_bands[SI476X_BAND_AM].rangehigh +\r\nsi476x_bands[SI476X_BAND_FM].rangelow) / 2;\r\nconst int band = (freq > midrange) ?\r\nSI476X_BAND_FM : SI476X_BAND_AM;\r\nconst enum si476x_func func = (band == SI476X_BAND_AM) ?\r\nSI476X_FUNC_AM_RECEIVER : SI476X_FUNC_FM_RECEIVER;\r\nif (f->tuner != 0 ||\r\nf->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nsi476x_core_lock(radio->core);\r\nfreq = clamp(freq,\r\nsi476x_bands[band].rangelow,\r\nsi476x_bands[band].rangehigh);\r\nif (si476x_radio_freq_is_inside_of_the_band(freq,\r\nSI476X_BAND_AM) &&\r\n(!si476x_core_has_am(radio->core) ||\r\nsi476x_core_is_a_secondary_tuner(radio->core))) {\r\nerr = -EINVAL;\r\ngoto unlock;\r\n}\r\nerr = si476x_radio_change_func(radio, func);\r\nif (err < 0)\r\ngoto unlock;\r\nargs.zifsr = false;\r\nargs.hd = false;\r\nargs.injside = SI476X_INJSIDE_AUTO;\r\nargs.freq = v4l2_to_si476x(radio->core, freq);\r\nargs.tunemode = SI476X_TM_VALIDATED_NORMAL_TUNE;\r\nargs.smoothmetrics = SI476X_SM_INITIALIZE_AUDIO;\r\nargs.antcap = 0;\r\nerr = radio->ops->tune_freq(radio->core, &args);\r\nunlock:\r\nsi476x_core_unlock(radio->core);\r\nreturn err;\r\n}\r\nstatic int si476x_radio_s_hw_freq_seek(struct file *file, void *priv,\r\nconst struct v4l2_hw_freq_seek *seek)\r\n{\r\nint err;\r\nenum si476x_func func;\r\nu32 rangelow, rangehigh;\r\nstruct si476x_radio *radio = video_drvdata(file);\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (seek->tuner != 0 ||\r\nseek->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nsi476x_core_lock(radio->core);\r\nif (!seek->rangelow) {\r\nerr = regmap_read(radio->core->regmap,\r\nSI476X_PROP_SEEK_BAND_BOTTOM,\r\n&rangelow);\r\nif (!err)\r\nrangelow = si476x_to_v4l2(radio->core, rangelow);\r\nelse\r\ngoto unlock;\r\n}\r\nif (!seek->rangehigh) {\r\nerr = regmap_read(radio->core->regmap,\r\nSI476X_PROP_SEEK_BAND_TOP,\r\n&rangehigh);\r\nif (!err)\r\nrangehigh = si476x_to_v4l2(radio->core, rangehigh);\r\nelse\r\ngoto unlock;\r\n}\r\nif (rangelow > rangehigh) {\r\nerr = -EINVAL;\r\ngoto unlock;\r\n}\r\nif (si476x_radio_range_is_inside_of_the_band(rangelow, rangehigh,\r\nSI476X_BAND_FM)) {\r\nfunc = SI476X_FUNC_FM_RECEIVER;\r\n} else if (si476x_core_has_am(radio->core) &&\r\nsi476x_radio_range_is_inside_of_the_band(rangelow, rangehigh,\r\nSI476X_BAND_AM)) {\r\nfunc = SI476X_FUNC_AM_RECEIVER;\r\n} else {\r\nerr = -EINVAL;\r\ngoto unlock;\r\n}\r\nerr = si476x_radio_change_func(radio, func);\r\nif (err < 0)\r\ngoto unlock;\r\nif (seek->rangehigh) {\r\nerr = regmap_write(radio->core->regmap,\r\nSI476X_PROP_SEEK_BAND_TOP,\r\nv4l2_to_si476x(radio->core,\r\nseek->rangehigh));\r\nif (err)\r\ngoto unlock;\r\n}\r\nif (seek->rangelow) {\r\nerr = regmap_write(radio->core->regmap,\r\nSI476X_PROP_SEEK_BAND_BOTTOM,\r\nv4l2_to_si476x(radio->core,\r\nseek->rangelow));\r\nif (err)\r\ngoto unlock;\r\n}\r\nif (seek->spacing) {\r\nerr = regmap_write(radio->core->regmap,\r\nSI476X_PROP_SEEK_FREQUENCY_SPACING,\r\nv4l2_to_si476x(radio->core,\r\nseek->spacing));\r\nif (err)\r\ngoto unlock;\r\n}\r\nerr = radio->ops->seek_start(radio->core,\r\nseek->seek_upward,\r\nseek->wrap_around);\r\nunlock:\r\nsi476x_core_unlock(radio->core);\r\nreturn err;\r\n}\r\nstatic int si476x_radio_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nint retval;\r\nstruct si476x_radio *radio = v4l2_ctrl_handler_to_radio(ctrl->handler);\r\nsi476x_core_lock(radio->core);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_SI476X_INTERCHIP_LINK:\r\nif (si476x_core_has_diversity(radio->core)) {\r\nif (radio->ops->phase_diversity) {\r\nretval = radio->ops->phase_div_status(radio->core);\r\nif (retval < 0)\r\nbreak;\r\nctrl->val = !!SI476X_PHDIV_STATUS_LINK_LOCKED(retval);\r\nretval = 0;\r\nbreak;\r\n} else {\r\nretval = -ENOTTY;\r\nbreak;\r\n}\r\n}\r\nretval = -EINVAL;\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nsi476x_core_unlock(radio->core);\r\nreturn retval;\r\n}\r\nstatic int si476x_radio_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nint retval;\r\nenum si476x_phase_diversity_mode mode;\r\nstruct si476x_radio *radio = v4l2_ctrl_handler_to_radio(ctrl->handler);\r\nsi476x_core_lock(radio->core);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_SI476X_HARMONICS_COUNT:\r\nretval = regmap_update_bits(radio->core->regmap,\r\nSI476X_PROP_AUDIO_PWR_LINE_FILTER,\r\nSI476X_PROP_PWR_HARMONICS_MASK,\r\nctrl->val);\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nswitch (ctrl->val) {\r\ncase V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:\r\nretval = regmap_update_bits(radio->core->regmap,\r\nSI476X_PROP_AUDIO_PWR_LINE_FILTER,\r\nSI476X_PROP_PWR_ENABLE_MASK,\r\n0);\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY_50HZ:\r\nretval = regmap_update_bits(radio->core->regmap,\r\nSI476X_PROP_AUDIO_PWR_LINE_FILTER,\r\nSI476X_PROP_PWR_GRID_MASK,\r\nSI476X_PROP_PWR_GRID_50HZ);\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY_60HZ:\r\nretval = regmap_update_bits(radio->core->regmap,\r\nSI476X_PROP_AUDIO_PWR_LINE_FILTER,\r\nSI476X_PROP_PWR_GRID_MASK,\r\nSI476X_PROP_PWR_GRID_60HZ);\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_CID_SI476X_RSSI_THRESHOLD:\r\nretval = regmap_write(radio->core->regmap,\r\nSI476X_PROP_VALID_RSSI_THRESHOLD,\r\nctrl->val);\r\nbreak;\r\ncase V4L2_CID_SI476X_SNR_THRESHOLD:\r\nretval = regmap_write(radio->core->regmap,\r\nSI476X_PROP_VALID_SNR_THRESHOLD,\r\nctrl->val);\r\nbreak;\r\ncase V4L2_CID_SI476X_MAX_TUNE_ERROR:\r\nretval = regmap_write(radio->core->regmap,\r\nSI476X_PROP_VALID_MAX_TUNE_ERROR,\r\nctrl->val);\r\nbreak;\r\ncase V4L2_CID_RDS_RECEPTION:\r\nif (si476x_core_is_in_am_receiver_mode(radio->core))\r\nregcache_cache_only(radio->core->regmap, true);\r\nif (ctrl->val) {\r\nretval = regmap_write(radio->core->regmap,\r\nSI476X_PROP_FM_RDS_INTERRUPT_FIFO_COUNT,\r\nradio->core->rds_fifo_depth);\r\nif (retval < 0)\r\nbreak;\r\nif (radio->core->client->irq) {\r\nretval = regmap_write(radio->core->regmap,\r\nSI476X_PROP_FM_RDS_INTERRUPT_SOURCE,\r\nSI476X_RDSRECV);\r\nif (retval < 0)\r\nbreak;\r\n}\r\nretval = si476x_core_cmd_fm_rds_status(radio->core,\r\nfalse,\r\ntrue,\r\ntrue,\r\nNULL);\r\nif (retval < 0)\r\nbreak;\r\nretval = regmap_update_bits(radio->core->regmap,\r\nSI476X_PROP_FM_RDS_CONFIG,\r\nSI476X_PROP_RDSEN_MASK,\r\nSI476X_PROP_RDSEN);\r\n} else {\r\nretval = regmap_update_bits(radio->core->regmap,\r\nSI476X_PROP_FM_RDS_CONFIG,\r\nSI476X_PROP_RDSEN_MASK,\r\n!SI476X_PROP_RDSEN);\r\n}\r\nif (si476x_core_is_in_am_receiver_mode(radio->core))\r\nregcache_cache_only(radio->core->regmap, false);\r\nbreak;\r\ncase V4L2_CID_TUNE_DEEMPHASIS:\r\nretval = regmap_write(radio->core->regmap,\r\nSI476X_PROP_AUDIO_DEEMPHASIS,\r\nctrl->val);\r\nbreak;\r\ncase V4L2_CID_SI476X_DIVERSITY_MODE:\r\nmode = si476x_phase_diversity_idx_to_mode(ctrl->val);\r\nif (mode == radio->core->diversity_mode) {\r\nretval = 0;\r\nbreak;\r\n}\r\nif (si476x_core_is_in_am_receiver_mode(radio->core)) {\r\nradio->core->diversity_mode = mode;\r\nretval = 0;\r\n} else {\r\nretval = radio->ops->phase_diversity(radio->core, mode);\r\nif (!retval)\r\nradio->core->diversity_mode = mode;\r\n}\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nsi476x_core_unlock(radio->core);\r\nreturn retval;\r\n}\r\nstatic int si476x_radio_g_register(struct file *file, void *fh,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nint err;\r\nunsigned int value;\r\nstruct si476x_radio *radio = video_drvdata(file);\r\nsi476x_core_lock(radio->core);\r\nreg->size = 2;\r\nerr = regmap_read(radio->core->regmap,\r\n(unsigned int)reg->reg, &value);\r\nreg->val = value;\r\nsi476x_core_unlock(radio->core);\r\nreturn err;\r\n}\r\nstatic int si476x_radio_s_register(struct file *file, void *fh,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nint err;\r\nstruct si476x_radio *radio = video_drvdata(file);\r\nsi476x_core_lock(radio->core);\r\nerr = regmap_write(radio->core->regmap,\r\n(unsigned int)reg->reg,\r\n(unsigned int)reg->val);\r\nsi476x_core_unlock(radio->core);\r\nreturn err;\r\n}\r\nstatic int si476x_radio_fops_open(struct file *file)\r\n{\r\nstruct si476x_radio *radio = video_drvdata(file);\r\nint err;\r\nerr = v4l2_fh_open(file);\r\nif (err)\r\nreturn err;\r\nif (v4l2_fh_is_singular_file(file)) {\r\nsi476x_core_lock(radio->core);\r\nerr = si476x_core_set_power_state(radio->core,\r\nSI476X_POWER_UP_FULL);\r\nif (err < 0)\r\ngoto done;\r\nerr = si476x_radio_do_post_powerup_init(radio,\r\nradio->core->power_up_parameters.func);\r\nif (err < 0)\r\ngoto power_down;\r\nerr = si476x_radio_pretune(radio,\r\nradio->core->power_up_parameters.func);\r\nif (err < 0)\r\ngoto power_down;\r\nsi476x_core_unlock(radio->core);\r\nv4l2_ctrl_handler_setup(&radio->ctrl_handler);\r\n}\r\nreturn err;\r\npower_down:\r\nsi476x_core_set_power_state(radio->core,\r\nSI476X_POWER_DOWN);\r\ndone:\r\nsi476x_core_unlock(radio->core);\r\nv4l2_fh_release(file);\r\nreturn err;\r\n}\r\nstatic int si476x_radio_fops_release(struct file *file)\r\n{\r\nint err;\r\nstruct si476x_radio *radio = video_drvdata(file);\r\nif (v4l2_fh_is_singular_file(file) &&\r\natomic_read(&radio->core->is_alive))\r\nsi476x_core_set_power_state(radio->core,\r\nSI476X_POWER_DOWN);\r\nerr = v4l2_fh_release(file);\r\nreturn err;\r\n}\r\nstatic ssize_t si476x_radio_fops_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nssize_t rval;\r\nsize_t fifo_len;\r\nunsigned int copied;\r\nstruct si476x_radio *radio = video_drvdata(file);\r\nif (kfifo_is_empty(&radio->core->rds_fifo)) {\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EWOULDBLOCK;\r\nrval = wait_event_interruptible(radio->core->rds_read_queue,\r\n(!kfifo_is_empty(&radio->core->rds_fifo) ||\r\n!atomic_read(&radio->core->is_alive)));\r\nif (rval < 0)\r\nreturn -EINTR;\r\nif (!atomic_read(&radio->core->is_alive))\r\nreturn -ENODEV;\r\n}\r\nfifo_len = kfifo_len(&radio->core->rds_fifo);\r\nif (kfifo_to_user(&radio->core->rds_fifo, buf,\r\nmin(fifo_len, count),\r\n&copied) != 0) {\r\ndev_warn(&radio->videodev.dev,\r\n"Error during FIFO to userspace copy\n");\r\nrval = -EIO;\r\n} else {\r\nrval = (ssize_t)copied;\r\n}\r\nreturn rval;\r\n}\r\nstatic unsigned int si476x_radio_fops_poll(struct file *file,\r\nstruct poll_table_struct *pts)\r\n{\r\nstruct si476x_radio *radio = video_drvdata(file);\r\nunsigned long req_events = poll_requested_events(pts);\r\nunsigned int err = v4l2_ctrl_poll(file, pts);\r\nif (req_events & (POLLIN | POLLRDNORM)) {\r\nif (atomic_read(&radio->core->is_alive))\r\npoll_wait(file, &radio->core->rds_read_queue, pts);\r\nif (!atomic_read(&radio->core->is_alive))\r\nerr = POLLHUP;\r\nif (!kfifo_is_empty(&radio->core->rds_fifo))\r\nerr = POLLIN | POLLRDNORM;\r\n}\r\nreturn err;\r\n}\r\nstatic ssize_t si476x_radio_read_acf_blob(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint err;\r\nstruct si476x_radio *radio = file->private_data;\r\nstruct si476x_acf_status_report report;\r\nsi476x_core_lock(radio->core);\r\nif (radio->ops->acf_status)\r\nerr = radio->ops->acf_status(radio->core, &report);\r\nelse\r\nerr = -ENOENT;\r\nsi476x_core_unlock(radio->core);\r\nif (err < 0)\r\nreturn err;\r\nreturn simple_read_from_buffer(user_buf, count, ppos, &report,\r\nsizeof(report));\r\n}\r\nstatic ssize_t si476x_radio_read_rds_blckcnt_blob(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint err;\r\nstruct si476x_radio *radio = file->private_data;\r\nstruct si476x_rds_blockcount_report report;\r\nsi476x_core_lock(radio->core);\r\nif (radio->ops->rds_blckcnt)\r\nerr = radio->ops->rds_blckcnt(radio->core, true,\r\n&report);\r\nelse\r\nerr = -ENOENT;\r\nsi476x_core_unlock(radio->core);\r\nif (err < 0)\r\nreturn err;\r\nreturn simple_read_from_buffer(user_buf, count, ppos, &report,\r\nsizeof(report));\r\n}\r\nstatic ssize_t si476x_radio_read_agc_blob(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint err;\r\nstruct si476x_radio *radio = file->private_data;\r\nstruct si476x_agc_status_report report;\r\nsi476x_core_lock(radio->core);\r\nif (radio->ops->rds_blckcnt)\r\nerr = radio->ops->agc_status(radio->core, &report);\r\nelse\r\nerr = -ENOENT;\r\nsi476x_core_unlock(radio->core);\r\nif (err < 0)\r\nreturn err;\r\nreturn simple_read_from_buffer(user_buf, count, ppos, &report,\r\nsizeof(report));\r\n}\r\nstatic ssize_t si476x_radio_read_rsq_blob(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint err;\r\nstruct si476x_radio *radio = file->private_data;\r\nstruct si476x_rsq_status_report report;\r\nstruct si476x_rsq_status_args args = {\r\n.primary = false,\r\n.rsqack = false,\r\n.attune = false,\r\n.cancel = false,\r\n.stcack = false,\r\n};\r\nsi476x_core_lock(radio->core);\r\nif (radio->ops->rds_blckcnt)\r\nerr = radio->ops->rsq_status(radio->core, &args, &report);\r\nelse\r\nerr = -ENOENT;\r\nsi476x_core_unlock(radio->core);\r\nif (err < 0)\r\nreturn err;\r\nreturn simple_read_from_buffer(user_buf, count, ppos, &report,\r\nsizeof(report));\r\n}\r\nstatic ssize_t si476x_radio_read_rsq_primary_blob(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint err;\r\nstruct si476x_radio *radio = file->private_data;\r\nstruct si476x_rsq_status_report report;\r\nstruct si476x_rsq_status_args args = {\r\n.primary = true,\r\n.rsqack = false,\r\n.attune = false,\r\n.cancel = false,\r\n.stcack = false,\r\n};\r\nsi476x_core_lock(radio->core);\r\nif (radio->ops->rds_blckcnt)\r\nerr = radio->ops->rsq_status(radio->core, &args, &report);\r\nelse\r\nerr = -ENOENT;\r\nsi476x_core_unlock(radio->core);\r\nif (err < 0)\r\nreturn err;\r\nreturn simple_read_from_buffer(user_buf, count, ppos, &report,\r\nsizeof(report));\r\n}\r\nstatic int si476x_radio_init_debugfs(struct si476x_radio *radio)\r\n{\r\nstruct dentry *dentry;\r\nint ret;\r\ndentry = debugfs_create_dir(dev_name(radio->v4l2dev.dev), NULL);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\ngoto exit;\r\n}\r\nradio->debugfs = dentry;\r\ndentry = debugfs_create_file("acf", S_IRUGO,\r\nradio->debugfs, radio, &radio_acf_fops);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\ngoto cleanup;\r\n}\r\ndentry = debugfs_create_file("rds_blckcnt", S_IRUGO,\r\nradio->debugfs, radio,\r\n&radio_rds_blckcnt_fops);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\ngoto cleanup;\r\n}\r\ndentry = debugfs_create_file("agc", S_IRUGO,\r\nradio->debugfs, radio, &radio_agc_fops);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\ngoto cleanup;\r\n}\r\ndentry = debugfs_create_file("rsq", S_IRUGO,\r\nradio->debugfs, radio, &radio_rsq_fops);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\ngoto cleanup;\r\n}\r\ndentry = debugfs_create_file("rsq_primary", S_IRUGO,\r\nradio->debugfs, radio,\r\n&radio_rsq_primary_fops);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\ngoto cleanup;\r\n}\r\nreturn 0;\r\ncleanup:\r\ndebugfs_remove_recursive(radio->debugfs);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int si476x_radio_add_new_custom(struct si476x_radio *radio,\r\nenum si476x_ctrl_idx idx)\r\n{\r\nint rval;\r\nstruct v4l2_ctrl *ctrl;\r\nctrl = v4l2_ctrl_new_custom(&radio->ctrl_handler,\r\n&si476x_ctrls[idx],\r\nNULL);\r\nrval = radio->ctrl_handler.error;\r\nif (ctrl == NULL && rval)\r\ndev_err(radio->v4l2dev.dev,\r\n"Could not initialize '%s' control %d\n",\r\nsi476x_ctrls[idx].name, rval);\r\nreturn rval;\r\n}\r\nstatic int si476x_radio_probe(struct platform_device *pdev)\r\n{\r\nint rval;\r\nstruct si476x_radio *radio;\r\nstruct v4l2_ctrl *ctrl;\r\nstatic atomic_t instance = ATOMIC_INIT(0);\r\nradio = devm_kzalloc(&pdev->dev, sizeof(*radio), GFP_KERNEL);\r\nif (!radio)\r\nreturn -ENOMEM;\r\nradio->core = i2c_mfd_cell_to_core(&pdev->dev);\r\nv4l2_device_set_name(&radio->v4l2dev, DRIVER_NAME, &instance);\r\nrval = v4l2_device_register(&pdev->dev, &radio->v4l2dev);\r\nif (rval) {\r\ndev_err(&pdev->dev, "Cannot register v4l2_device.\n");\r\nreturn rval;\r\n}\r\nmemcpy(&radio->videodev, &si476x_viddev_template,\r\nsizeof(struct video_device));\r\nradio->videodev.v4l2_dev = &radio->v4l2dev;\r\nradio->videodev.ioctl_ops = &si4761_ioctl_ops;\r\nvideo_set_drvdata(&radio->videodev, radio);\r\nplatform_set_drvdata(pdev, radio);\r\nset_bit(V4L2_FL_USE_FH_PRIO, &radio->videodev.flags);\r\nradio->v4l2dev.ctrl_handler = &radio->ctrl_handler;\r\nv4l2_ctrl_handler_init(&radio->ctrl_handler,\r\n1 + ARRAY_SIZE(si476x_ctrls));\r\nif (si476x_core_has_am(radio->core)) {\r\nctrl = v4l2_ctrl_new_std_menu(&radio->ctrl_handler,\r\n&si476x_ctrl_ops,\r\nV4L2_CID_POWER_LINE_FREQUENCY,\r\nV4L2_CID_POWER_LINE_FREQUENCY_60HZ,\r\n0, 0);\r\nrval = radio->ctrl_handler.error;\r\nif (ctrl == NULL && rval) {\r\ndev_err(&pdev->dev, "Could not initialize V4L2_CID_POWER_LINE_FREQUENCY control %d\n",\r\nrval);\r\ngoto exit;\r\n}\r\nrval = si476x_radio_add_new_custom(radio,\r\nSI476X_IDX_HARMONICS_COUNT);\r\nif (rval < 0)\r\ngoto exit;\r\n}\r\nrval = si476x_radio_add_new_custom(radio, SI476X_IDX_RSSI_THRESHOLD);\r\nif (rval < 0)\r\ngoto exit;\r\nrval = si476x_radio_add_new_custom(radio, SI476X_IDX_SNR_THRESHOLD);\r\nif (rval < 0)\r\ngoto exit;\r\nrval = si476x_radio_add_new_custom(radio, SI476X_IDX_MAX_TUNE_ERROR);\r\nif (rval < 0)\r\ngoto exit;\r\nctrl = v4l2_ctrl_new_std_menu(&radio->ctrl_handler,\r\n&si476x_ctrl_ops,\r\nV4L2_CID_TUNE_DEEMPHASIS,\r\nV4L2_DEEMPHASIS_75_uS, 0, 0);\r\nrval = radio->ctrl_handler.error;\r\nif (ctrl == NULL && rval) {\r\ndev_err(&pdev->dev, "Could not initialize V4L2_CID_TUNE_DEEMPHASIS control %d\n",\r\nrval);\r\ngoto exit;\r\n}\r\nctrl = v4l2_ctrl_new_std(&radio->ctrl_handler, &si476x_ctrl_ops,\r\nV4L2_CID_RDS_RECEPTION,\r\n0, 1, 1, 1);\r\nrval = radio->ctrl_handler.error;\r\nif (ctrl == NULL && rval) {\r\ndev_err(&pdev->dev, "Could not initialize V4L2_CID_RDS_RECEPTION control %d\n",\r\nrval);\r\ngoto exit;\r\n}\r\nif (si476x_core_has_diversity(radio->core)) {\r\nsi476x_ctrls[SI476X_IDX_DIVERSITY_MODE].def =\r\nsi476x_phase_diversity_mode_to_idx(radio->core->diversity_mode);\r\nsi476x_radio_add_new_custom(radio, SI476X_IDX_DIVERSITY_MODE);\r\nif (rval < 0)\r\ngoto exit;\r\nsi476x_radio_add_new_custom(radio, SI476X_IDX_INTERCHIP_LINK);\r\nif (rval < 0)\r\ngoto exit;\r\n}\r\nrval = video_register_device(&radio->videodev, VFL_TYPE_RADIO, -1);\r\nif (rval < 0) {\r\ndev_err(&pdev->dev, "Could not register video device\n");\r\ngoto exit;\r\n}\r\nrval = si476x_radio_init_debugfs(radio);\r\nif (rval < 0) {\r\ndev_err(&pdev->dev, "Could not creat debugfs interface\n");\r\ngoto exit;\r\n}\r\nreturn 0;\r\nexit:\r\nv4l2_ctrl_handler_free(radio->videodev.ctrl_handler);\r\nreturn rval;\r\n}\r\nstatic int si476x_radio_remove(struct platform_device *pdev)\r\n{\r\nstruct si476x_radio *radio = platform_get_drvdata(pdev);\r\nv4l2_ctrl_handler_free(radio->videodev.ctrl_handler);\r\nvideo_unregister_device(&radio->videodev);\r\nv4l2_device_unregister(&radio->v4l2dev);\r\ndebugfs_remove_recursive(radio->debugfs);\r\nreturn 0;\r\n}
