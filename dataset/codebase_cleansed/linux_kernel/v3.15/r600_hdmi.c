static void r600_hdmi_calc_cts(uint32_t clock, int *CTS, int *N, int freq)\r\n{\r\nint n, cts;\r\nunsigned long div, mul;\r\nn = 128 * freq;\r\ncts = clock * 1000;\r\ndiv = gcd(n, cts);\r\nn /= div;\r\ncts /= div;\r\nmul = ((128*freq/1000) + (n-1))/n;\r\nn *= mul;\r\ncts *= mul;\r\nif (n < (128*freq/1500))\r\nprintk(KERN_WARNING "Calculated ACR N value is too small. You may experience audio problems.\n");\r\nif (n > (128*freq/300))\r\nprintk(KERN_WARNING "Calculated ACR N value is too large. You may experience audio problems.\n");\r\n*N = n;\r\n*CTS = cts;\r\nDRM_DEBUG("Calculated ACR timing N=%d CTS=%d for frequency %d\n",\r\n*N, *CTS, freq);\r\n}\r\nstruct radeon_hdmi_acr r600_hdmi_acr(uint32_t clock)\r\n{\r\nstruct radeon_hdmi_acr res;\r\nu8 i;\r\nfor (i = 0; i < ARRAY_SIZE(r600_hdmi_predefined_acr); i++) {\r\nif (r600_hdmi_predefined_acr[i].clock == clock)\r\nreturn r600_hdmi_predefined_acr[i];\r\n}\r\nr600_hdmi_calc_cts(clock, &res.cts_32khz, &res.n_32khz, 32000);\r\nr600_hdmi_calc_cts(clock, &res.cts_44_1khz, &res.n_44_1khz, 44100);\r\nr600_hdmi_calc_cts(clock, &res.cts_48khz, &res.n_48khz, 48000);\r\nreturn res;\r\n}\r\nstatic void r600_hdmi_update_ACR(struct drm_encoder *encoder, uint32_t clock)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_hdmi_acr acr = r600_hdmi_acr(clock);\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nWREG32(HDMI0_ACR_32_0 + offset, HDMI0_ACR_CTS_32(acr.cts_32khz));\r\nWREG32(HDMI0_ACR_32_1 + offset, acr.n_32khz);\r\nWREG32(HDMI0_ACR_44_0 + offset, HDMI0_ACR_CTS_44(acr.cts_44_1khz));\r\nWREG32(HDMI0_ACR_44_1 + offset, acr.n_44_1khz);\r\nWREG32(HDMI0_ACR_48_0 + offset, HDMI0_ACR_CTS_48(acr.cts_48khz));\r\nWREG32(HDMI0_ACR_48_1 + offset, acr.n_48khz);\r\n}\r\nstatic void r600_hdmi_update_avi_infoframe(struct drm_encoder *encoder,\r\nvoid *buffer, size_t size)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nuint8_t *frame = buffer + 3;\r\nuint8_t *header = buffer;\r\nWREG32(HDMI0_AVI_INFO0 + offset,\r\nframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\r\nWREG32(HDMI0_AVI_INFO1 + offset,\r\nframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x7] << 24));\r\nWREG32(HDMI0_AVI_INFO2 + offset,\r\nframe[0x8] | (frame[0x9] << 8) | (frame[0xA] << 16) | (frame[0xB] << 24));\r\nWREG32(HDMI0_AVI_INFO3 + offset,\r\nframe[0xC] | (frame[0xD] << 8) | (header[1] << 24));\r\n}\r\nstatic void r600_hdmi_update_audio_infoframe(struct drm_encoder *encoder,\r\nconst void *buffer, size_t size)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nconst u8 *frame = buffer + 3;\r\nWREG32(HDMI0_AUDIO_INFO0 + offset,\r\nframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\r\nWREG32(HDMI0_AUDIO_INFO1 + offset,\r\nframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x8] << 24));\r\n}\r\nstatic bool r600_hdmi_is_audio_buffer_filled(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nreturn (RREG32(HDMI0_STATUS + offset) & 0x10) != 0;\r\n}\r\nint r600_hdmi_buffer_status_changed(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nint status, result;\r\nif (!dig->afmt || !dig->afmt->enabled)\r\nreturn 0;\r\nstatus = r600_hdmi_is_audio_buffer_filled(encoder);\r\nresult = dig->afmt->last_buffer_filled_status != status;\r\ndig->afmt->last_buffer_filled_status = status;\r\nreturn result;\r\n}\r\nstatic void r600_hdmi_audio_workaround(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nbool hdmi_audio_workaround = false;\r\nu32 value;\r\nif (!hdmi_audio_workaround ||\r\nr600_hdmi_is_audio_buffer_filled(encoder))\r\nvalue = 0;\r\nelse\r\nvalue = HDMI0_AUDIO_TEST_EN;\r\nWREG32_P(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nvalue, ~HDMI0_AUDIO_TEST_EN);\r\n}\r\nstatic void r600_audio_set_dto(struct drm_encoder *encoder, u32 clock)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nu32 base_rate = 24000;\r\nu32 max_ratio = clock / base_rate;\r\nu32 dto_phase;\r\nu32 dto_modulo = clock;\r\nu32 wallclock_ratio;\r\nu32 dto_cntl;\r\nif (!dig || !dig->afmt)\r\nreturn;\r\nif (max_ratio >= 8) {\r\ndto_phase = 192 * 1000;\r\nwallclock_ratio = 3;\r\n} else if (max_ratio >= 4) {\r\ndto_phase = 96 * 1000;\r\nwallclock_ratio = 2;\r\n} else if (max_ratio >= 2) {\r\ndto_phase = 48 * 1000;\r\nwallclock_ratio = 1;\r\n} else {\r\ndto_phase = 24 * 1000;\r\nwallclock_ratio = 0;\r\n}\r\nif (ASIC_IS_DCE32(rdev)) {\r\nif (dig->dig_encoder == 0) {\r\ndto_cntl = RREG32(DCCG_AUDIO_DTO0_CNTL) & ~DCCG_AUDIO_DTO_WALLCLOCK_RATIO_MASK;\r\ndto_cntl |= DCCG_AUDIO_DTO_WALLCLOCK_RATIO(wallclock_ratio);\r\nWREG32(DCCG_AUDIO_DTO0_CNTL, dto_cntl);\r\nWREG32(DCCG_AUDIO_DTO0_PHASE, dto_phase);\r\nWREG32(DCCG_AUDIO_DTO0_MODULE, dto_modulo);\r\nWREG32(DCCG_AUDIO_DTO_SELECT, 0);\r\n} else {\r\ndto_cntl = RREG32(DCCG_AUDIO_DTO1_CNTL) & ~DCCG_AUDIO_DTO_WALLCLOCK_RATIO_MASK;\r\ndto_cntl |= DCCG_AUDIO_DTO_WALLCLOCK_RATIO(wallclock_ratio);\r\nWREG32(DCCG_AUDIO_DTO1_CNTL, dto_cntl);\r\nWREG32(DCCG_AUDIO_DTO1_PHASE, dto_phase);\r\nWREG32(DCCG_AUDIO_DTO1_MODULE, dto_modulo);\r\nWREG32(DCCG_AUDIO_DTO_SELECT, 1);\r\n}\r\n} else {\r\nif (dig->dig_encoder == 0) {\r\nWREG32(DCCG_AUDIO_DTO0_PHASE, base_rate * 100);\r\nWREG32(DCCG_AUDIO_DTO0_MODULE, clock * 100);\r\nWREG32(DCCG_AUDIO_DTO_SELECT, 0);\r\n} else {\r\nWREG32(DCCG_AUDIO_DTO1_PHASE, base_rate * 100);\r\nWREG32(DCCG_AUDIO_DTO1_MODULE, clock * 100);\r\nWREG32(DCCG_AUDIO_DTO_SELECT, 1);\r\n}\r\n}\r\n}\r\nstatic void dce3_2_afmt_write_speaker_allocation(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_device *rdev = encoder->dev->dev_private;\r\nstruct drm_connector *connector;\r\nstruct radeon_connector *radeon_connector = NULL;\r\nu32 tmp;\r\nu8 *sadb;\r\nint sad_count;\r\nlist_for_each_entry(connector, &encoder->dev->mode_config.connector_list, head) {\r\nif (connector->encoder == encoder) {\r\nradeon_connector = to_radeon_connector(connector);\r\nbreak;\r\n}\r\n}\r\nif (!radeon_connector) {\r\nDRM_ERROR("Couldn't find encoder's connector\n");\r\nreturn;\r\n}\r\nsad_count = drm_edid_to_speaker_allocation(radeon_connector->edid, &sadb);\r\nif (sad_count < 0) {\r\nDRM_ERROR("Couldn't read Speaker Allocation Data Block: %d\n", sad_count);\r\nreturn;\r\n}\r\ntmp = RREG32(AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER);\r\ntmp &= ~(DP_CONNECTION | SPEAKER_ALLOCATION_MASK);\r\ntmp |= HDMI_CONNECTION;\r\nif (sad_count)\r\ntmp |= SPEAKER_ALLOCATION(sadb[0]);\r\nelse\r\ntmp |= SPEAKER_ALLOCATION(5);\r\nWREG32(AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER, tmp);\r\nkfree(sadb);\r\n}\r\nstatic void dce3_2_afmt_write_sad_regs(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_device *rdev = encoder->dev->dev_private;\r\nstruct drm_connector *connector;\r\nstruct radeon_connector *radeon_connector = NULL;\r\nstruct cea_sad *sads;\r\nint i, sad_count;\r\nstatic const u16 eld_reg_to_type[][2] = {\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR0, HDMI_AUDIO_CODING_TYPE_PCM },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR1, HDMI_AUDIO_CODING_TYPE_AC3 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR2, HDMI_AUDIO_CODING_TYPE_MPEG1 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR3, HDMI_AUDIO_CODING_TYPE_MP3 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR4, HDMI_AUDIO_CODING_TYPE_MPEG2 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR5, HDMI_AUDIO_CODING_TYPE_AAC_LC },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR6, HDMI_AUDIO_CODING_TYPE_DTS },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR7, HDMI_AUDIO_CODING_TYPE_ATRAC },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR9, HDMI_AUDIO_CODING_TYPE_EAC3 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR10, HDMI_AUDIO_CODING_TYPE_DTS_HD },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR11, HDMI_AUDIO_CODING_TYPE_MLP },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR13, HDMI_AUDIO_CODING_TYPE_WMA_PRO },\r\n};\r\nlist_for_each_entry(connector, &encoder->dev->mode_config.connector_list, head) {\r\nif (connector->encoder == encoder) {\r\nradeon_connector = to_radeon_connector(connector);\r\nbreak;\r\n}\r\n}\r\nif (!radeon_connector) {\r\nDRM_ERROR("Couldn't find encoder's connector\n");\r\nreturn;\r\n}\r\nsad_count = drm_edid_to_sad(radeon_connector->edid, &sads);\r\nif (sad_count < 0) {\r\nDRM_ERROR("Couldn't read SADs: %d\n", sad_count);\r\nreturn;\r\n}\r\nBUG_ON(!sads);\r\nfor (i = 0; i < ARRAY_SIZE(eld_reg_to_type); i++) {\r\nu32 value = 0;\r\nu8 stereo_freqs = 0;\r\nint max_channels = -1;\r\nint j;\r\nfor (j = 0; j < sad_count; j++) {\r\nstruct cea_sad *sad = &sads[j];\r\nif (sad->format == eld_reg_to_type[i][1]) {\r\nif (sad->channels > max_channels) {\r\nvalue = MAX_CHANNELS(sad->channels) |\r\nDESCRIPTOR_BYTE_2(sad->byte2) |\r\nSUPPORTED_FREQUENCIES(sad->freq);\r\nmax_channels = sad->channels;\r\n}\r\nif (sad->format == HDMI_AUDIO_CODING_TYPE_PCM)\r\nstereo_freqs |= sad->freq;\r\nelse\r\nbreak;\r\n}\r\n}\r\nvalue |= SUPPORTED_FREQUENCIES_STEREO(stereo_freqs);\r\nWREG32(eld_reg_to_type[i][0], value);\r\n}\r\nkfree(sads);\r\n}\r\nvoid r600_hdmi_setmode(struct drm_encoder *encoder, struct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nu8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];\r\nstruct hdmi_avi_infoframe frame;\r\nuint32_t offset;\r\nssize_t err;\r\nif (!dig || !dig->afmt)\r\nreturn;\r\nif (!dig->afmt->enabled)\r\nreturn;\r\noffset = dig->afmt->offset;\r\ndig->afmt->pin = r600_audio_get_pin(rdev);\r\nr600_audio_enable(rdev, dig->afmt->pin, false);\r\nr600_audio_set_dto(encoder, mode->clock);\r\nWREG32(HDMI0_VBI_PACKET_CONTROL + offset,\r\nHDMI0_NULL_SEND);\r\nWREG32(HDMI0_AUDIO_CRC_CONTROL + offset, 0x1000);\r\nif (ASIC_IS_DCE32(rdev)) {\r\nWREG32(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nHDMI0_AUDIO_DELAY_EN(1) |\r\nHDMI0_AUDIO_PACKETS_PER_LINE(3));\r\nWREG32(AFMT_AUDIO_PACKET_CONTROL + offset,\r\nAFMT_AUDIO_SAMPLE_SEND |\r\nAFMT_60958_CS_UPDATE);\r\n} else {\r\nWREG32(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nHDMI0_AUDIO_SAMPLE_SEND |\r\nHDMI0_AUDIO_DELAY_EN(1) |\r\nHDMI0_AUDIO_PACKETS_PER_LINE(3) |\r\nHDMI0_60958_CS_UPDATE);\r\n}\r\nif (ASIC_IS_DCE32(rdev)) {\r\ndce3_2_afmt_write_speaker_allocation(encoder);\r\ndce3_2_afmt_write_sad_regs(encoder);\r\n}\r\nWREG32(HDMI0_ACR_PACKET_CONTROL + offset,\r\nHDMI0_ACR_SOURCE |\r\nHDMI0_ACR_AUTO_SEND);\r\nWREG32(HDMI0_VBI_PACKET_CONTROL + offset,\r\nHDMI0_NULL_SEND |\r\nHDMI0_GC_SEND |\r\nHDMI0_GC_CONT);\r\nWREG32(HDMI0_INFOFRAME_CONTROL0 + offset,\r\nHDMI0_AVI_INFO_SEND |\r\nHDMI0_AVI_INFO_CONT |\r\nHDMI0_AUDIO_INFO_SEND |\r\nHDMI0_AUDIO_INFO_CONT);\r\nWREG32(HDMI0_INFOFRAME_CONTROL1 + offset,\r\nHDMI0_AVI_INFO_LINE(2) |\r\nHDMI0_AUDIO_INFO_LINE(2));\r\nWREG32(HDMI0_GC + offset, 0);\r\nerr = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode);\r\nif (err < 0) {\r\nDRM_ERROR("failed to setup AVI infoframe: %zd\n", err);\r\nreturn;\r\n}\r\nerr = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));\r\nif (err < 0) {\r\nDRM_ERROR("failed to pack AVI infoframe: %zd\n", err);\r\nreturn;\r\n}\r\nr600_hdmi_update_avi_infoframe(encoder, buffer, sizeof(buffer));\r\nr600_hdmi_update_ACR(encoder, mode->clock);\r\nWREG32(HDMI0_RAMP_CONTROL0 + offset, 0x00FFFFFF);\r\nWREG32(HDMI0_RAMP_CONTROL1 + offset, 0x007FFFFF);\r\nWREG32(HDMI0_RAMP_CONTROL2 + offset, 0x00000001);\r\nWREG32(HDMI0_RAMP_CONTROL3 + offset, 0x00000001);\r\nr600_hdmi_audio_workaround(encoder);\r\nr600_audio_enable(rdev, dig->afmt->pin, true);\r\n}\r\nvoid r600_hdmi_update_audio_settings(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nstruct r600_audio_pin audio = r600_audio_status(rdev);\r\nuint8_t buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AUDIO_INFOFRAME_SIZE];\r\nstruct hdmi_audio_infoframe frame;\r\nuint32_t offset;\r\nuint32_t iec;\r\nssize_t err;\r\nif (!dig->afmt || !dig->afmt->enabled)\r\nreturn;\r\noffset = dig->afmt->offset;\r\nDRM_DEBUG("%s with %d channels, %d Hz sampling rate, %d bits per sample,\n",\r\nr600_hdmi_is_audio_buffer_filled(encoder) ? "playing" : "stopped",\r\naudio.channels, audio.rate, audio.bits_per_sample);\r\nDRM_DEBUG("0x%02X IEC60958 status bits and 0x%02X category code\n",\r\n(int)audio.status_bits, (int)audio.category_code);\r\niec = 0;\r\nif (audio.status_bits & AUDIO_STATUS_PROFESSIONAL)\r\niec |= 1 << 0;\r\nif (audio.status_bits & AUDIO_STATUS_NONAUDIO)\r\niec |= 1 << 1;\r\nif (audio.status_bits & AUDIO_STATUS_COPYRIGHT)\r\niec |= 1 << 2;\r\nif (audio.status_bits & AUDIO_STATUS_EMPHASIS)\r\niec |= 1 << 3;\r\niec |= HDMI0_60958_CS_CATEGORY_CODE(audio.category_code);\r\nswitch (audio.rate) {\r\ncase 32000:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0x3);\r\nbreak;\r\ncase 44100:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0x0);\r\nbreak;\r\ncase 48000:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0x2);\r\nbreak;\r\ncase 88200:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0x8);\r\nbreak;\r\ncase 96000:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0xa);\r\nbreak;\r\ncase 176400:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0xc);\r\nbreak;\r\ncase 192000:\r\niec |= HDMI0_60958_CS_SAMPLING_FREQUENCY(0xe);\r\nbreak;\r\n}\r\nWREG32(HDMI0_60958_0 + offset, iec);\r\niec = 0;\r\nswitch (audio.bits_per_sample) {\r\ncase 16:\r\niec |= HDMI0_60958_CS_WORD_LENGTH(0x2);\r\nbreak;\r\ncase 20:\r\niec |= HDMI0_60958_CS_WORD_LENGTH(0x3);\r\nbreak;\r\ncase 24:\r\niec |= HDMI0_60958_CS_WORD_LENGTH(0xb);\r\nbreak;\r\n}\r\nif (audio.status_bits & AUDIO_STATUS_V)\r\niec |= 0x5 << 16;\r\nWREG32_P(HDMI0_60958_1 + offset, iec, ~0x5000f);\r\nerr = hdmi_audio_infoframe_init(&frame);\r\nif (err < 0) {\r\nDRM_ERROR("failed to setup audio infoframe\n");\r\nreturn;\r\n}\r\nframe.channels = audio.channels;\r\nerr = hdmi_audio_infoframe_pack(&frame, buffer, sizeof(buffer));\r\nif (err < 0) {\r\nDRM_ERROR("failed to pack audio infoframe\n");\r\nreturn;\r\n}\r\nr600_hdmi_update_audio_infoframe(encoder, buffer, sizeof(buffer));\r\nr600_hdmi_audio_workaround(encoder);\r\n}\r\nvoid r600_hdmi_enable(struct drm_encoder *encoder, bool enable)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nu32 hdmi = HDMI0_ERROR_ACK;\r\nif (!dig || !dig->afmt)\r\nreturn;\r\nif (enable && dig->afmt->enabled)\r\nreturn;\r\nif (!enable && !dig->afmt->enabled)\r\nreturn;\r\nif (!ASIC_IS_DCE3(rdev)) {\r\nif (enable)\r\nhdmi |= HDMI0_ENABLE;\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\nif (enable) {\r\nWREG32_OR(AVIVO_TMDSA_CNTL, AVIVO_TMDSA_CNTL_HDMI_EN);\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_TMDSA);\r\n} else {\r\nWREG32_AND(AVIVO_TMDSA_CNTL, ~AVIVO_TMDSA_CNTL_HDMI_EN);\r\n}\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nif (enable) {\r\nWREG32_OR(AVIVO_LVTMA_CNTL, AVIVO_LVTMA_CNTL_HDMI_EN);\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_LVTMA);\r\n} else {\r\nWREG32_AND(AVIVO_LVTMA_CNTL, ~AVIVO_LVTMA_CNTL_HDMI_EN);\r\n}\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\nif (enable) {\r\nWREG32_OR(DDIA_CNTL, DDIA_HDMI_EN);\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_DDIA);\r\n} else {\r\nWREG32_AND(DDIA_CNTL, ~DDIA_HDMI_EN);\r\n}\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\nif (enable)\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_DVOA);\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Invalid encoder for HDMI: 0x%X\n",\r\nradeon_encoder->encoder_id);\r\nbreak;\r\n}\r\nWREG32(HDMI0_CONTROL + dig->afmt->offset, hdmi);\r\n}\r\nif (rdev->irq.installed) {\r\nif (enable)\r\nradeon_irq_kms_enable_afmt(rdev, dig->afmt->id);\r\nelse\r\nradeon_irq_kms_disable_afmt(rdev, dig->afmt->id);\r\n}\r\ndig->afmt->enabled = enable;\r\nDRM_DEBUG("%sabling HDMI interface @ 0x%04X for encoder 0x%x\n",\r\nenable ? "En" : "Dis", dig->afmt->offset, radeon_encoder->encoder_id);\r\n}
