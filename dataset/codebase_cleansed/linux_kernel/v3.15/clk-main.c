static irqreturn_t clk_main_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct clk_main *clkmain = (struct clk_main *)dev_id;\r\nwake_up(&clkmain->wait);\r\ndisable_irq_nosync(clkmain->irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int clk_main_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_main *clkmain = to_clk_main(hw);\r\nstruct at91_pmc *pmc = clkmain->pmc;\r\nunsigned long halt_time, timeout;\r\nu32 tmp;\r\nwhile (!(pmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MOSCS)) {\r\nenable_irq(clkmain->irq);\r\nwait_event(clkmain->wait,\r\npmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MOSCS);\r\n}\r\nif (clkmain->rate)\r\nreturn 0;\r\ntimeout = jiffies + usecs_to_jiffies(MAINFRDY_TIMEOUT);\r\ndo {\r\nhalt_time = jiffies;\r\ntmp = pmc_read(pmc, AT91_CKGR_MCFR);\r\nif (tmp & AT91_PMC_MAINRDY)\r\nreturn 0;\r\nusleep_range(MAINF_LOOP_MIN_WAIT, MAINF_LOOP_MAX_WAIT);\r\n} while (time_before(halt_time, timeout));\r\nreturn 0;\r\n}\r\nstatic int clk_main_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_main *clkmain = to_clk_main(hw);\r\nreturn !!(pmc_read(clkmain->pmc, AT91_PMC_SR) & AT91_PMC_MOSCS);\r\n}\r\nstatic unsigned long clk_main_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nu32 tmp;\r\nstruct clk_main *clkmain = to_clk_main(hw);\r\nstruct at91_pmc *pmc = clkmain->pmc;\r\nif (clkmain->rate)\r\nreturn clkmain->rate;\r\ntmp = pmc_read(pmc, AT91_CKGR_MCFR) & AT91_PMC_MAINF;\r\nclkmain->rate = (tmp * parent_rate) / MAINF_DIV;\r\nreturn clkmain->rate;\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_main(struct at91_pmc *pmc,\r\nunsigned int irq,\r\nconst char *name,\r\nconst char *parent_name,\r\nunsigned long rate)\r\n{\r\nint ret;\r\nstruct clk_main *clkmain;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nif (!pmc || !irq || !name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!rate && !parent_name)\r\nreturn ERR_PTR(-EINVAL);\r\nclkmain = kzalloc(sizeof(*clkmain), GFP_KERNEL);\r\nif (!clkmain)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &main_ops;\r\ninit.parent_names = parent_name ? &parent_name : NULL;\r\ninit.num_parents = parent_name ? 1 : 0;\r\ninit.flags = parent_name ? 0 : CLK_IS_ROOT;\r\nclkmain->hw.init = &init;\r\nclkmain->rate = rate;\r\nclkmain->pmc = pmc;\r\nclkmain->irq = irq;\r\ninit_waitqueue_head(&clkmain->wait);\r\nirq_set_status_flags(clkmain->irq, IRQ_NOAUTOEN);\r\nret = request_irq(clkmain->irq, clk_main_irq_handler,\r\nIRQF_TRIGGER_HIGH, "clk-main", clkmain);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nclk = clk_register(NULL, &clkmain->hw);\r\nif (IS_ERR(clk)) {\r\nfree_irq(clkmain->irq, clkmain);\r\nkfree(clkmain);\r\n}\r\nreturn clk;\r\n}\r\nstatic void __init\r\nof_at91_clk_main_setup(struct device_node *np, struct at91_pmc *pmc)\r\n{\r\nstruct clk *clk;\r\nunsigned int irq;\r\nconst char *parent_name;\r\nconst char *name = np->name;\r\nu32 rate = 0;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nof_property_read_string(np, "clock-output-names", &name);\r\nof_property_read_u32(np, "clock-frequency", &rate);\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq)\r\nreturn;\r\nclk = at91_clk_register_main(pmc, irq, name, parent_name, rate);\r\nif (IS_ERR(clk))\r\nreturn;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\n}\r\nvoid __init of_at91rm9200_clk_main_setup(struct device_node *np,\r\nstruct at91_pmc *pmc)\r\n{\r\nof_at91_clk_main_setup(np, pmc);\r\n}
