int __init find_via_pmu(void)\r\n{\r\nu64 taddr;\r\nconst u32 *reg;\r\nif (via != 0)\r\nreturn 1;\r\nvias = of_find_node_by_name(NULL, "via-pmu");\r\nif (vias == NULL)\r\nreturn 0;\r\nreg = of_get_property(vias, "reg", NULL);\r\nif (reg == NULL) {\r\nprintk(KERN_ERR "via-pmu: No \"reg\" property !\n");\r\ngoto fail;\r\n}\r\ntaddr = of_translate_address(vias, reg);\r\nif (taddr == OF_BAD_ADDR) {\r\nprintk(KERN_ERR "via-pmu: Can't translate address !\n");\r\ngoto fail;\r\n}\r\nspin_lock_init(&pmu_lock);\r\npmu_has_adb = 1;\r\npmu_intr_mask = PMU_INT_PCEJECT |\r\nPMU_INT_SNDBRT |\r\nPMU_INT_ADB |\r\nPMU_INT_TICK;\r\nif (vias->parent->name && ((strcmp(vias->parent->name, "ohare") == 0)\r\n|| of_device_is_compatible(vias->parent, "ohare")))\r\npmu_kind = PMU_OHARE_BASED;\r\nelse if (of_device_is_compatible(vias->parent, "paddington"))\r\npmu_kind = PMU_PADDINGTON_BASED;\r\nelse if (of_device_is_compatible(vias->parent, "heathrow"))\r\npmu_kind = PMU_HEATHROW_BASED;\r\nelse if (of_device_is_compatible(vias->parent, "Keylargo")\r\n|| of_device_is_compatible(vias->parent, "K2-Keylargo")) {\r\nstruct device_node *gpiop;\r\nstruct device_node *adbp;\r\nu64 gaddr = OF_BAD_ADDR;\r\npmu_kind = PMU_KEYLARGO_BASED;\r\nadbp = of_find_node_by_type(NULL, "adb");\r\npmu_has_adb = (adbp != NULL);\r\nof_node_put(adbp);\r\npmu_intr_mask = PMU_INT_PCEJECT |\r\nPMU_INT_SNDBRT |\r\nPMU_INT_ADB |\r\nPMU_INT_TICK |\r\nPMU_INT_ENVIRONMENT;\r\ngpiop = of_find_node_by_name(NULL, "gpio");\r\nif (gpiop) {\r\nreg = of_get_property(gpiop, "reg", NULL);\r\nif (reg)\r\ngaddr = of_translate_address(gpiop, reg);\r\nif (gaddr != OF_BAD_ADDR)\r\ngpio_reg = ioremap(gaddr, 0x10);\r\n}\r\nif (gpio_reg == NULL) {\r\nprintk(KERN_ERR "via-pmu: Can't find GPIO reg !\n");\r\ngoto fail_gpio;\r\n}\r\n} else\r\npmu_kind = PMU_UNKNOWN;\r\nvia = ioremap(taddr, 0x2000);\r\nif (via == NULL) {\r\nprintk(KERN_ERR "via-pmu: Can't map address !\n");\r\ngoto fail;\r\n}\r\nout_8(&via[IER], IER_CLR | 0x7f);\r\nout_8(&via[IFR], 0x7f);\r\npmu_state = idle;\r\nif (!init_pmu()) {\r\nvia = NULL;\r\nreturn 0;\r\n}\r\nprintk(KERN_INFO "PMU driver v%d initialized for %s, firmware: %02x\n",\r\nPMU_DRIVER_VERSION, pbook_type[pmu_kind], pmu_version);\r\nsys_ctrler = SYS_CTRLER_PMU;\r\nreturn 1;\r\nfail:\r\nof_node_put(vias);\r\niounmap(gpio_reg);\r\ngpio_reg = NULL;\r\nfail_gpio:\r\nvias = NULL;\r\nreturn 0;\r\n}\r\nstatic int pmu_probe(void)\r\n{\r\nreturn vias == NULL? -ENODEV: 0;\r\n}\r\nstatic int __init pmu_init(void)\r\n{\r\nif (vias == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int __init via_pmu_start(void)\r\n{\r\nunsigned int irq;\r\nif (vias == NULL)\r\nreturn -ENODEV;\r\nbatt_req.complete = 1;\r\nirq = irq_of_parse_and_map(vias, 0);\r\nif (irq == NO_IRQ) {\r\nprintk(KERN_ERR "via-pmu: can't map interrupt\n");\r\nreturn -ENODEV;\r\n}\r\nif (request_irq(irq, via_pmu_interrupt, IRQF_NO_SUSPEND,\r\n"VIA-PMU", (void *)0)) {\r\nprintk(KERN_ERR "via-pmu: can't request irq %d\n", irq);\r\nreturn -ENODEV;\r\n}\r\nif (pmu_kind == PMU_KEYLARGO_BASED) {\r\ngpio_node = of_find_node_by_name(NULL, "extint-gpio1");\r\nif (gpio_node == NULL)\r\ngpio_node = of_find_node_by_name(NULL,\r\n"pmu-interrupt");\r\nif (gpio_node)\r\ngpio_irq = irq_of_parse_and_map(gpio_node, 0);\r\nif (gpio_irq != NO_IRQ) {\r\nif (request_irq(gpio_irq, gpio1_interrupt, IRQF_TIMER,\r\n"GPIO1 ADB", (void *)0))\r\nprintk(KERN_ERR "pmu: can't get irq %d"\r\n" (GPIO1)\n", gpio_irq);\r\nelse\r\ngpio_irq_enabled = 1;\r\n}\r\n}\r\nout_8(&via[IER], IER_SET | SR_INT | CB1_INT);\r\npmu_fully_inited = 1;\r\ndo {\r\npmu_poll();\r\n} while (pmu_state != idle);\r\nreturn 0;\r\n}\r\nstatic int __init via_pmu_dev_init(void)\r\n{\r\nif (vias == NULL)\r\nreturn -ENODEV;\r\n#ifdef CONFIG_PMAC_BACKLIGHT\r\npmu_backlight_init();\r\n#endif\r\n#ifdef CONFIG_PPC32\r\nif (of_machine_is_compatible("AAPL,3400/2400") ||\r\nof_machine_is_compatible("AAPL,3500")) {\r\nint mb = pmac_call_feature(PMAC_FTR_GET_MB_INFO,\r\nNULL, PMAC_MB_INFO_MODEL, 0);\r\npmu_battery_count = 1;\r\nif (mb == PMAC_TYPE_COMET)\r\npmu_batteries[0].flags |= PMU_BATT_TYPE_COMET;\r\nelse\r\npmu_batteries[0].flags |= PMU_BATT_TYPE_HOOPER;\r\n} else if (of_machine_is_compatible("AAPL,PowerBook1998") ||\r\nof_machine_is_compatible("PowerBook1,1")) {\r\npmu_battery_count = 2;\r\npmu_batteries[0].flags |= PMU_BATT_TYPE_SMART;\r\npmu_batteries[1].flags |= PMU_BATT_TYPE_SMART;\r\n} else {\r\nstruct device_node* prim =\r\nof_find_node_by_name(NULL, "power-mgt");\r\nconst u32 *prim_info = NULL;\r\nif (prim)\r\nprim_info = of_get_property(prim, "prim-info", NULL);\r\nif (prim_info) {\r\npmu_battery_count = (prim_info[6] >> 16) & 0xff;\r\npmu_batteries[0].flags |= PMU_BATT_TYPE_SMART;\r\nif (pmu_battery_count > 1)\r\npmu_batteries[1].flags |= PMU_BATT_TYPE_SMART;\r\n}\r\nof_node_put(prim);\r\n}\r\n#endif\r\nproc_pmu_root = proc_mkdir("pmu", NULL);\r\nif (proc_pmu_root) {\r\nlong i;\r\nfor (i=0; i<pmu_battery_count; i++) {\r\nchar title[16];\r\nsprintf(title, "battery_%ld", i);\r\nproc_pmu_batt[i] = proc_create_data(title, 0, proc_pmu_root,\r\n&pmu_battery_proc_fops, (void *)i);\r\n}\r\nproc_pmu_info = proc_create("info", 0, proc_pmu_root, &pmu_info_proc_fops);\r\nproc_pmu_irqstats = proc_create("interrupts", 0, proc_pmu_root,\r\n&pmu_irqstats_proc_fops);\r\nproc_pmu_options = proc_create("options", 0600, proc_pmu_root,\r\n&pmu_options_proc_fops);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ninit_pmu(void)\r\n{\r\nint timeout;\r\nstruct adb_request req;\r\nout_8(&via[B], via[B] | TREQ);\r\nout_8(&via[DIRB], (via[DIRB] | TREQ) & ~TACK);\r\npmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, pmu_intr_mask);\r\ntimeout = 100000;\r\nwhile (!req.complete) {\r\nif (--timeout < 0) {\r\nprintk(KERN_ERR "init_pmu: no response from PMU\n");\r\nreturn 0;\r\n}\r\nudelay(10);\r\npmu_poll();\r\n}\r\ntimeout = 100000;\r\ninterrupt_data[0][0] = 1;\r\nwhile (interrupt_data[0][0] || pmu_state != idle) {\r\nif (--timeout < 0) {\r\nprintk(KERN_ERR "init_pmu: timed out acking intrs\n");\r\nreturn 0;\r\n}\r\nif (pmu_state == idle)\r\nadb_int_pending = 1;\r\nvia_pmu_interrupt(0, NULL);\r\nudelay(10);\r\n}\r\nif (pmu_kind == PMU_KEYLARGO_BASED) {\r\npmu_request(&req, NULL, 2, PMU_SYSTEM_READY, 2);\r\nwhile (!req.complete)\r\npmu_poll();\r\n}\r\npmu_request(&req, NULL, 1, PMU_GET_VERSION);\r\npmu_wait_complete(&req);\r\nif (req.reply_len > 0)\r\npmu_version = req.reply[0];\r\nif (pmu_kind == PMU_KEYLARGO_BASED) {\r\npmu_request(&req, NULL, 2, PMU_POWER_EVENTS,\r\nPMU_PWR_GET_POWERUP_EVENTS);\r\npmu_wait_complete(&req);\r\nif (req.reply_len == 2) {\r\nif (req.reply[1] & PMU_PWR_WAKEUP_AC_INSERT)\r\noption_server_mode = 1;\r\nprintk(KERN_INFO "via-pmu: Server Mode is %s\n",\r\noption_server_mode ? "enabled" : "disabled");\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint\r\npmu_get_model(void)\r\n{\r\nreturn pmu_kind;\r\n}\r\nstatic void pmu_set_server_mode(int server_mode)\r\n{\r\nstruct adb_request req;\r\nif (pmu_kind != PMU_KEYLARGO_BASED)\r\nreturn;\r\noption_server_mode = server_mode;\r\npmu_request(&req, NULL, 2, PMU_POWER_EVENTS, PMU_PWR_GET_POWERUP_EVENTS);\r\npmu_wait_complete(&req);\r\nif (req.reply_len < 2)\r\nreturn;\r\nif (server_mode)\r\npmu_request(&req, NULL, 4, PMU_POWER_EVENTS,\r\nPMU_PWR_SET_POWERUP_EVENTS,\r\nreq.reply[0], PMU_PWR_WAKEUP_AC_INSERT);\r\nelse\r\npmu_request(&req, NULL, 4, PMU_POWER_EVENTS,\r\nPMU_PWR_CLR_POWERUP_EVENTS,\r\nreq.reply[0], PMU_PWR_WAKEUP_AC_INSERT);\r\npmu_wait_complete(&req);\r\n}\r\nstatic void\r\ndone_battery_state_ohare(struct adb_request* req)\r\n{\r\nunsigned int bat_flags = PMU_BATT_TYPE_HOOPER;\r\nlong pcharge, charge, vb, vmax, lmax;\r\nlong vmax_charging, vmax_charged;\r\nlong amperage, voltage, time, max;\r\nint mb = pmac_call_feature(PMAC_FTR_GET_MB_INFO,\r\nNULL, PMAC_MB_INFO_MODEL, 0);\r\nif (req->reply[0] & 0x01)\r\npmu_power_flags |= PMU_PWR_AC_PRESENT;\r\nelse\r\npmu_power_flags &= ~PMU_PWR_AC_PRESENT;\r\nif (mb == PMAC_TYPE_COMET) {\r\nvmax_charged = 189;\r\nvmax_charging = 213;\r\nlmax = 6500;\r\n} else {\r\nvmax_charged = 330;\r\nvmax_charging = 330;\r\nlmax = 6500;\r\n}\r\nvmax = vmax_charged;\r\nif (req->reply[0] & 0x04) {\r\nbat_flags |= PMU_BATT_PRESENT;\r\nif (req->reply[0] & 0x02)\r\nbat_flags |= PMU_BATT_CHARGING;\r\nvb = (req->reply[1] << 8) | req->reply[2];\r\nvoltage = (vb * 265 + 72665) / 10;\r\namperage = req->reply[5];\r\nif ((req->reply[0] & 0x01) == 0) {\r\nif (amperage > 200)\r\nvb += ((amperage - 200) * 15)/100;\r\n} else if (req->reply[0] & 0x02) {\r\nvb = (vb * 97) / 100;\r\nvmax = vmax_charging;\r\n}\r\ncharge = (100 * vb) / vmax;\r\nif (req->reply[0] & 0x40) {\r\npcharge = (req->reply[6] << 8) + req->reply[7];\r\nif (pcharge > lmax)\r\npcharge = lmax;\r\npcharge *= 100;\r\npcharge = 100 - pcharge / lmax;\r\nif (pcharge < charge)\r\ncharge = pcharge;\r\n}\r\nif (amperage > 0)\r\ntime = (charge * 16440) / amperage;\r\nelse\r\ntime = 0;\r\nmax = 100;\r\namperage = -amperage;\r\n} else\r\ncharge = max = amperage = voltage = time = 0;\r\npmu_batteries[pmu_cur_battery].flags = bat_flags;\r\npmu_batteries[pmu_cur_battery].charge = charge;\r\npmu_batteries[pmu_cur_battery].max_charge = max;\r\npmu_batteries[pmu_cur_battery].amperage = amperage;\r\npmu_batteries[pmu_cur_battery].voltage = voltage;\r\npmu_batteries[pmu_cur_battery].time_remaining = time;\r\nclear_bit(0, &async_req_locks);\r\n}\r\nstatic void\r\ndone_battery_state_smart(struct adb_request* req)\r\n{\r\nunsigned int bat_flags = PMU_BATT_TYPE_SMART;\r\nint amperage;\r\nunsigned int capa, max, voltage;\r\nif (req->reply[1] & 0x01)\r\npmu_power_flags |= PMU_PWR_AC_PRESENT;\r\nelse\r\npmu_power_flags &= ~PMU_PWR_AC_PRESENT;\r\ncapa = max = amperage = voltage = 0;\r\nif (req->reply[1] & 0x04) {\r\nbat_flags |= PMU_BATT_PRESENT;\r\nswitch(req->reply[0]) {\r\ncase 3:\r\ncase 4: capa = req->reply[2];\r\nmax = req->reply[3];\r\namperage = *((signed char *)&req->reply[4]);\r\nvoltage = req->reply[5];\r\nbreak;\r\ncase 5: capa = (req->reply[2] << 8) | req->reply[3];\r\nmax = (req->reply[4] << 8) | req->reply[5];\r\namperage = *((signed short *)&req->reply[6]);\r\nvoltage = (req->reply[8] << 8) | req->reply[9];\r\nbreak;\r\ndefault:\r\npr_warn("pmu.c: unrecognized battery info, "\r\n"len: %d, %4ph\n", req->reply_len,\r\nreq->reply);\r\nbreak;\r\n}\r\n}\r\nif ((req->reply[1] & 0x01) && (amperage > 0))\r\nbat_flags |= PMU_BATT_CHARGING;\r\npmu_batteries[pmu_cur_battery].flags = bat_flags;\r\npmu_batteries[pmu_cur_battery].charge = capa;\r\npmu_batteries[pmu_cur_battery].max_charge = max;\r\npmu_batteries[pmu_cur_battery].amperage = amperage;\r\npmu_batteries[pmu_cur_battery].voltage = voltage;\r\nif (amperage) {\r\nif ((req->reply[1] & 0x01) && (amperage > 0))\r\npmu_batteries[pmu_cur_battery].time_remaining\r\n= ((max-capa) * 3600) / amperage;\r\nelse\r\npmu_batteries[pmu_cur_battery].time_remaining\r\n= (capa * 3600) / (-amperage);\r\n} else\r\npmu_batteries[pmu_cur_battery].time_remaining = 0;\r\npmu_cur_battery = (pmu_cur_battery + 1) % pmu_battery_count;\r\nclear_bit(0, &async_req_locks);\r\n}\r\nstatic void\r\nquery_battery_state(void)\r\n{\r\nif (test_and_set_bit(0, &async_req_locks))\r\nreturn;\r\nif (pmu_kind == PMU_OHARE_BASED)\r\npmu_request(&batt_req, done_battery_state_ohare,\r\n1, PMU_BATTERY_STATE);\r\nelse\r\npmu_request(&batt_req, done_battery_state_smart,\r\n2, PMU_SMART_BATTERY_STATE, pmu_cur_battery+1);\r\n}\r\nstatic int pmu_info_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "PMU driver version : %d\n", PMU_DRIVER_VERSION);\r\nseq_printf(m, "PMU firmware version : %02x\n", pmu_version);\r\nseq_printf(m, "AC Power : %d\n",\r\n((pmu_power_flags & PMU_PWR_AC_PRESENT) != 0) || pmu_battery_count == 0);\r\nseq_printf(m, "Battery count : %d\n", pmu_battery_count);\r\nreturn 0;\r\n}\r\nstatic int pmu_info_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pmu_info_proc_show, NULL);\r\n}\r\nstatic int pmu_irqstats_proc_show(struct seq_file *m, void *v)\r\n{\r\nint i;\r\nstatic const char *irq_names[] = {\r\n"Total CB1 triggered events",\r\n"Total GPIO1 triggered events",\r\n"PC-Card eject button",\r\n"Sound/Brightness button",\r\n"ADB message",\r\n"Battery state change",\r\n"Environment interrupt",\r\n"Tick timer",\r\n"Ghost interrupt (zero len)",\r\n"Empty interrupt (empty mask)",\r\n"Max irqs in a row"\r\n};\r\nfor (i=0; i<11; i++) {\r\nseq_printf(m, " %2u: %10u (%s)\n",\r\ni, pmu_irq_stats[i], irq_names[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmu_irqstats_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pmu_irqstats_proc_show, NULL);\r\n}\r\nstatic int pmu_battery_proc_show(struct seq_file *m, void *v)\r\n{\r\nlong batnum = (long)m->private;\r\nseq_putc(m, '\n');\r\nseq_printf(m, "flags : %08x\n", pmu_batteries[batnum].flags);\r\nseq_printf(m, "charge : %d\n", pmu_batteries[batnum].charge);\r\nseq_printf(m, "max_charge : %d\n", pmu_batteries[batnum].max_charge);\r\nseq_printf(m, "current : %d\n", pmu_batteries[batnum].amperage);\r\nseq_printf(m, "voltage : %d\n", pmu_batteries[batnum].voltage);\r\nseq_printf(m, "time rem. : %d\n", pmu_batteries[batnum].time_remaining);\r\nreturn 0;\r\n}\r\nstatic int pmu_battery_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pmu_battery_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int pmu_options_proc_show(struct seq_file *m, void *v)\r\n{\r\n#if defined(CONFIG_SUSPEND) && defined(CONFIG_PPC32)\r\nif (pmu_kind == PMU_KEYLARGO_BASED &&\r\npmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,-1) >= 0)\r\nseq_printf(m, "lid_wakeup=%d\n", option_lid_wakeup);\r\n#endif\r\nif (pmu_kind == PMU_KEYLARGO_BASED)\r\nseq_printf(m, "server_mode=%d\n", option_server_mode);\r\nreturn 0;\r\n}\r\nstatic int pmu_options_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pmu_options_proc_show, NULL);\r\n}\r\nstatic ssize_t pmu_options_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *pos)\r\n{\r\nchar tmp[33];\r\nchar *label, *val;\r\nsize_t fcount = count;\r\nif (!count)\r\nreturn -EINVAL;\r\nif (count > 32)\r\ncount = 32;\r\nif (copy_from_user(tmp, buffer, count))\r\nreturn -EFAULT;\r\ntmp[count] = 0;\r\nlabel = tmp;\r\nwhile(*label == ' ')\r\nlabel++;\r\nval = label;\r\nwhile(*val && (*val != '=')) {\r\nif (*val == ' ')\r\n*val = 0;\r\nval++;\r\n}\r\nif ((*val) == 0)\r\nreturn -EINVAL;\r\n*(val++) = 0;\r\nwhile(*val == ' ')\r\nval++;\r\n#if defined(CONFIG_SUSPEND) && defined(CONFIG_PPC32)\r\nif (pmu_kind == PMU_KEYLARGO_BASED &&\r\npmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,-1) >= 0)\r\nif (!strcmp(label, "lid_wakeup"))\r\noption_lid_wakeup = ((*val) == '1');\r\n#endif\r\nif (pmu_kind == PMU_KEYLARGO_BASED && !strcmp(label, "server_mode")) {\r\nint new_value;\r\nnew_value = ((*val) == '1');\r\nif (new_value != option_server_mode)\r\npmu_set_server_mode(new_value);\r\n}\r\nreturn fcount;\r\n}\r\nstatic int pmu_send_request(struct adb_request *req, int sync)\r\n{\r\nint i, ret;\r\nif ((vias == NULL) || (!pmu_fully_inited)) {\r\nreq->complete = 1;\r\nreturn -ENXIO;\r\n}\r\nret = -EINVAL;\r\nswitch (req->data[0]) {\r\ncase PMU_PACKET:\r\nfor (i = 0; i < req->nbytes - 1; ++i)\r\nreq->data[i] = req->data[i+1];\r\n--req->nbytes;\r\nif (pmu_data_len[req->data[0]][1] != 0) {\r\nreq->reply[0] = ADB_RET_OK;\r\nreq->reply_len = 1;\r\n} else\r\nreq->reply_len = 0;\r\nret = pmu_queue_request(req);\r\nbreak;\r\ncase CUDA_PACKET:\r\nswitch (req->data[1]) {\r\ncase CUDA_GET_TIME:\r\nif (req->nbytes != 2)\r\nbreak;\r\nreq->data[0] = PMU_READ_RTC;\r\nreq->nbytes = 1;\r\nreq->reply_len = 3;\r\nreq->reply[0] = CUDA_PACKET;\r\nreq->reply[1] = 0;\r\nreq->reply[2] = CUDA_GET_TIME;\r\nret = pmu_queue_request(req);\r\nbreak;\r\ncase CUDA_SET_TIME:\r\nif (req->nbytes != 6)\r\nbreak;\r\nreq->data[0] = PMU_SET_RTC;\r\nreq->nbytes = 5;\r\nfor (i = 1; i <= 4; ++i)\r\nreq->data[i] = req->data[i+1];\r\nreq->reply_len = 3;\r\nreq->reply[0] = CUDA_PACKET;\r\nreq->reply[1] = 0;\r\nreq->reply[2] = CUDA_SET_TIME;\r\nret = pmu_queue_request(req);\r\nbreak;\r\n}\r\nbreak;\r\ncase ADB_PACKET:\r\nif (!pmu_has_adb)\r\nreturn -ENXIO;\r\nfor (i = req->nbytes - 1; i > 1; --i)\r\nreq->data[i+2] = req->data[i];\r\nreq->data[3] = req->nbytes - 2;\r\nreq->data[2] = pmu_adb_flags;\r\nreq->data[0] = PMU_ADB_CMD;\r\nreq->nbytes += 2;\r\nreq->reply_expected = 1;\r\nreq->reply_len = 0;\r\nret = pmu_queue_request(req);\r\nbreak;\r\n}\r\nif (ret) {\r\nreq->complete = 1;\r\nreturn ret;\r\n}\r\nif (sync)\r\nwhile (!req->complete)\r\npmu_poll();\r\nreturn 0;\r\n}\r\nstatic int __pmu_adb_autopoll(int devs)\r\n{\r\nstruct adb_request req;\r\nif (devs) {\r\npmu_request(&req, NULL, 5, PMU_ADB_CMD, 0, 0x86,\r\nadb_dev_map >> 8, adb_dev_map);\r\npmu_adb_flags = 2;\r\n} else {\r\npmu_request(&req, NULL, 1, PMU_ADB_POLL_OFF);\r\npmu_adb_flags = 0;\r\n}\r\nwhile (!req.complete)\r\npmu_poll();\r\nreturn 0;\r\n}\r\nstatic int pmu_adb_autopoll(int devs)\r\n{\r\nif ((vias == NULL) || (!pmu_fully_inited) || !pmu_has_adb)\r\nreturn -ENXIO;\r\nadb_dev_map = devs;\r\nreturn __pmu_adb_autopoll(devs);\r\n}\r\nstatic int pmu_adb_reset_bus(void)\r\n{\r\nstruct adb_request req;\r\nint save_autopoll = adb_dev_map;\r\nif ((vias == NULL) || (!pmu_fully_inited) || !pmu_has_adb)\r\nreturn -ENXIO;\r\n__pmu_adb_autopoll(0);\r\nreq.nbytes = 4;\r\nreq.done = NULL;\r\nreq.data[0] = PMU_ADB_CMD;\r\nreq.data[1] = ADB_BUSRESET;\r\nreq.data[2] = 0;\r\nreq.data[3] = 0;\r\nreq.data[4] = 0;\r\nreq.reply_len = 0;\r\nreq.reply_expected = 1;\r\nif (pmu_queue_request(&req) != 0) {\r\nprintk(KERN_ERR "pmu_adb_reset_bus: pmu_queue_request failed\n");\r\nreturn -EIO;\r\n}\r\npmu_wait_complete(&req);\r\nif (save_autopoll != 0)\r\n__pmu_adb_autopoll(save_autopoll);\r\nreturn 0;\r\n}\r\nint\r\npmu_request(struct adb_request *req, void (*done)(struct adb_request *),\r\nint nbytes, ...)\r\n{\r\nva_list list;\r\nint i;\r\nif (vias == NULL)\r\nreturn -ENXIO;\r\nif (nbytes < 0 || nbytes > 32) {\r\nprintk(KERN_ERR "pmu_request: bad nbytes (%d)\n", nbytes);\r\nreq->complete = 1;\r\nreturn -EINVAL;\r\n}\r\nreq->nbytes = nbytes;\r\nreq->done = done;\r\nva_start(list, nbytes);\r\nfor (i = 0; i < nbytes; ++i)\r\nreq->data[i] = va_arg(list, int);\r\nva_end(list);\r\nreq->reply_len = 0;\r\nreq->reply_expected = 0;\r\nreturn pmu_queue_request(req);\r\n}\r\nint\r\npmu_queue_request(struct adb_request *req)\r\n{\r\nunsigned long flags;\r\nint nsend;\r\nif (via == NULL) {\r\nreq->complete = 1;\r\nreturn -ENXIO;\r\n}\r\nif (req->nbytes <= 0) {\r\nreq->complete = 1;\r\nreturn 0;\r\n}\r\nnsend = pmu_data_len[req->data[0]][0];\r\nif (nsend >= 0 && req->nbytes != nsend + 1) {\r\nreq->complete = 1;\r\nreturn -EINVAL;\r\n}\r\nreq->next = NULL;\r\nreq->sent = 0;\r\nreq->complete = 0;\r\nspin_lock_irqsave(&pmu_lock, flags);\r\nif (current_req != 0) {\r\nlast_req->next = req;\r\nlast_req = req;\r\n} else {\r\ncurrent_req = req;\r\nlast_req = req;\r\nif (pmu_state == idle)\r\npmu_start();\r\n}\r\nspin_unlock_irqrestore(&pmu_lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nwait_for_ack(void)\r\n{\r\nint timeout = 4000;\r\nwhile ((in_8(&via[B]) & TACK) == 0) {\r\nif (--timeout < 0) {\r\nprintk(KERN_ERR "PMU not responding (!ack)\n");\r\nreturn;\r\n}\r\nudelay(10);\r\n}\r\n}\r\nstatic inline void\r\nsend_byte(int x)\r\n{\r\nvolatile unsigned char __iomem *v = via;\r\nout_8(&v[ACR], in_8(&v[ACR]) | SR_OUT | SR_EXT);\r\nout_8(&v[SR], x);\r\nout_8(&v[B], in_8(&v[B]) & ~TREQ);\r\n(void)in_8(&v[B]);\r\n}\r\nstatic inline void\r\nrecv_byte(void)\r\n{\r\nvolatile unsigned char __iomem *v = via;\r\nout_8(&v[ACR], (in_8(&v[ACR]) & ~SR_OUT) | SR_EXT);\r\nin_8(&v[SR]);\r\nout_8(&v[B], in_8(&v[B]) & ~TREQ);\r\n(void)in_8(&v[B]);\r\n}\r\nstatic inline void\r\npmu_done(struct adb_request *req)\r\n{\r\nvoid (*done)(struct adb_request *) = req->done;\r\nmb();\r\nreq->complete = 1;\r\nif (done)\r\n(*done)(req);\r\n}\r\nstatic void\r\npmu_start(void)\r\n{\r\nstruct adb_request *req;\r\nreq = current_req;\r\nif (req == 0 || pmu_state != idle\r\n|| (req_awaiting_reply))\r\nreturn;\r\npmu_state = sending;\r\ndata_index = 1;\r\ndata_len = pmu_data_len[req->data[0]][0];\r\nwait_for_ack();\r\nsend_byte(req->data[0]);\r\n}\r\nvoid\r\npmu_poll(void)\r\n{\r\nif (!via)\r\nreturn;\r\nif (disable_poll)\r\nreturn;\r\nvia_pmu_interrupt(0, NULL);\r\n}\r\nvoid\r\npmu_poll_adb(void)\r\n{\r\nif (!via)\r\nreturn;\r\nif (disable_poll)\r\nreturn;\r\nadb_int_pending = 1;\r\ndo {\r\nvia_pmu_interrupt(0, NULL);\r\n} while (pmu_suspended && (adb_int_pending || pmu_state != idle\r\n|| req_awaiting_reply));\r\n}\r\nvoid\r\npmu_wait_complete(struct adb_request *req)\r\n{\r\nif (!via)\r\nreturn;\r\nwhile((pmu_state != idle && pmu_state != locked) || !req->complete)\r\nvia_pmu_interrupt(0, NULL);\r\n}\r\nvoid\r\npmu_suspend(void)\r\n{\r\nunsigned long flags;\r\nif (!via)\r\nreturn;\r\nspin_lock_irqsave(&pmu_lock, flags);\r\npmu_suspended++;\r\nif (pmu_suspended > 1) {\r\nspin_unlock_irqrestore(&pmu_lock, flags);\r\nreturn;\r\n}\r\ndo {\r\nspin_unlock_irqrestore(&pmu_lock, flags);\r\nif (req_awaiting_reply)\r\nadb_int_pending = 1;\r\nvia_pmu_interrupt(0, NULL);\r\nspin_lock_irqsave(&pmu_lock, flags);\r\nif (!adb_int_pending && pmu_state == idle && !req_awaiting_reply) {\r\nif (gpio_irq >= 0)\r\ndisable_irq_nosync(gpio_irq);\r\nout_8(&via[IER], CB1_INT | IER_CLR);\r\nspin_unlock_irqrestore(&pmu_lock, flags);\r\nbreak;\r\n}\r\n} while (1);\r\n}\r\nvoid\r\npmu_resume(void)\r\n{\r\nunsigned long flags;\r\nif (!via || (pmu_suspended < 1))\r\nreturn;\r\nspin_lock_irqsave(&pmu_lock, flags);\r\npmu_suspended--;\r\nif (pmu_suspended > 0) {\r\nspin_unlock_irqrestore(&pmu_lock, flags);\r\nreturn;\r\n}\r\nadb_int_pending = 1;\r\nif (gpio_irq >= 0)\r\nenable_irq(gpio_irq);\r\nout_8(&via[IER], CB1_INT | IER_SET);\r\nspin_unlock_irqrestore(&pmu_lock, flags);\r\npmu_poll();\r\n}\r\nstatic void\r\npmu_handle_data(unsigned char *data, int len)\r\n{\r\nunsigned char ints, pirq;\r\nint i = 0;\r\nasleep = 0;\r\nif (drop_interrupts || len < 1) {\r\nadb_int_pending = 0;\r\npmu_irq_stats[8]++;\r\nreturn;\r\n}\r\nints = data[0];\r\nif (ints == 0)\r\npmu_irq_stats[9]++;\r\nif (ints & PMU_INT_ADB)\r\nints &= ~(PMU_INT_ADB_AUTO | PMU_INT_AUTO_SRQ_POLL);\r\nnext:\r\nif (ints == 0) {\r\nif (i > pmu_irq_stats[10])\r\npmu_irq_stats[10] = i;\r\nreturn;\r\n}\r\nfor (pirq = 0; pirq < 8; pirq++)\r\nif (ints & (1 << pirq))\r\nbreak;\r\npmu_irq_stats[pirq]++;\r\ni++;\r\nints &= ~(1 << pirq);\r\nif ((1 << pirq) & PMU_INT_ADB) {\r\nif ((data[0] & PMU_INT_ADB_AUTO) == 0) {\r\nstruct adb_request *req = req_awaiting_reply;\r\nif (req == 0) {\r\nprintk(KERN_ERR "PMU: extra ADB reply\n");\r\nreturn;\r\n}\r\nreq_awaiting_reply = NULL;\r\nif (len <= 2)\r\nreq->reply_len = 0;\r\nelse {\r\nmemcpy(req->reply, data + 1, len - 1);\r\nreq->reply_len = len - 1;\r\n}\r\npmu_done(req);\r\n} else {\r\nif (len == 4 && data[1] == 0x2c) {\r\nextern int xmon_wants_key, xmon_adb_keycode;\r\nif (xmon_wants_key) {\r\nxmon_adb_keycode = data[2];\r\nreturn;\r\n}\r\n}\r\n#ifdef CONFIG_ADB\r\nif (!(pmu_kind == PMU_OHARE_BASED && len == 4\r\n&& data[1] == 0x2c && data[3] == 0xff\r\n&& (data[2] & ~1) == 0xf4))\r\nadb_input(data+1, len-1, 1);\r\n#endif\r\n}\r\n}\r\nelse if ((1 << pirq) & PMU_INT_SNDBRT) {\r\n#ifdef CONFIG_PMAC_BACKLIGHT\r\nif (len == 3)\r\npmac_backlight_set_legacy_brightness_pmu(data[1] >> 4);\r\n#endif\r\n}\r\nelse if ((1 << pirq) & PMU_INT_TICK) {\r\nif (pmu_battery_count) {\r\nif ((--query_batt_timer) == 0) {\r\nquery_battery_state();\r\nquery_batt_timer = BATTERY_POLLING_COUNT;\r\n}\r\n}\r\n}\r\nelse if ((1 << pirq) & PMU_INT_ENVIRONMENT) {\r\nif (pmu_battery_count)\r\nquery_battery_state();\r\npmu_pass_intr(data, len);\r\nif (len == 6) {\r\nvia_pmu_event(PMU_EVT_POWER, !!(data[1]&8));\r\nvia_pmu_event(PMU_EVT_LID, data[1]&1);\r\n}\r\n} else {\r\npmu_pass_intr(data, len);\r\n}\r\ngoto next;\r\n}\r\nstatic struct adb_request*\r\npmu_sr_intr(void)\r\n{\r\nstruct adb_request *req;\r\nint bite = 0;\r\nif (via[B] & TREQ) {\r\nprintk(KERN_ERR "PMU: spurious SR intr (%x)\n", via[B]);\r\nout_8(&via[IFR], SR_INT);\r\nreturn NULL;\r\n}\r\nwhile ((in_8(&via[B]) & TACK) != 0)\r\n;\r\nif (pmu_state == reading || pmu_state == reading_intr)\r\nbite = in_8(&via[SR]);\r\nout_8(&via[B], in_8(&via[B]) | TREQ);\r\nwait_for_ack();\r\nswitch (pmu_state) {\r\ncase sending:\r\nreq = current_req;\r\nif (data_len < 0) {\r\ndata_len = req->nbytes - 1;\r\nsend_byte(data_len);\r\nbreak;\r\n}\r\nif (data_index <= data_len) {\r\nsend_byte(req->data[data_index++]);\r\nbreak;\r\n}\r\nreq->sent = 1;\r\ndata_len = pmu_data_len[req->data[0]][1];\r\nif (data_len == 0) {\r\npmu_state = idle;\r\ncurrent_req = req->next;\r\nif (req->reply_expected)\r\nreq_awaiting_reply = req;\r\nelse\r\nreturn req;\r\n} else {\r\npmu_state = reading;\r\ndata_index = 0;\r\nreply_ptr = req->reply + req->reply_len;\r\nrecv_byte();\r\n}\r\nbreak;\r\ncase intack:\r\ndata_index = 0;\r\ndata_len = -1;\r\npmu_state = reading_intr;\r\nreply_ptr = interrupt_data[int_data_last];\r\nrecv_byte();\r\nif (gpio_irq >= 0 && !gpio_irq_enabled) {\r\nenable_irq(gpio_irq);\r\ngpio_irq_enabled = 1;\r\n}\r\nbreak;\r\ncase reading:\r\ncase reading_intr:\r\nif (data_len == -1) {\r\ndata_len = bite;\r\nif (bite > 32)\r\nprintk(KERN_ERR "PMU: bad reply len %d\n", bite);\r\n} else if (data_index < 32) {\r\nreply_ptr[data_index++] = bite;\r\n}\r\nif (data_index < data_len) {\r\nrecv_byte();\r\nbreak;\r\n}\r\nif (pmu_state == reading_intr) {\r\npmu_state = idle;\r\nint_data_state[int_data_last] = int_data_ready;\r\ninterrupt_data_len[int_data_last] = data_len;\r\n} else {\r\nreq = current_req;\r\ncurrent_req = req->next;\r\nreq->reply_len += data_index;\r\nif (req->data[0] == PMU_SLEEP || req->data[0] == PMU_CPU_SPEED)\r\npmu_state = locked;\r\nelse\r\npmu_state = idle;\r\nreturn req;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "via_pmu_interrupt: unknown state %d?\n",\r\npmu_state);\r\n}\r\nreturn NULL;\r\n}\r\nstatic irqreturn_t\r\nvia_pmu_interrupt(int irq, void *arg)\r\n{\r\nunsigned long flags;\r\nint intr;\r\nint nloop = 0;\r\nint int_data = -1;\r\nstruct adb_request *req = NULL;\r\nint handled = 0;\r\nspin_lock_irqsave(&pmu_lock, flags);\r\n++disable_poll;\r\nfor (;;) {\r\nintr = in_8(&via[IFR]) & (SR_INT | CB1_INT);\r\nif (intr == 0)\r\nbreak;\r\nhandled = 1;\r\nif (++nloop > 1000) {\r\nprintk(KERN_DEBUG "PMU: stuck in intr loop, "\r\n"intr=%x, ier=%x pmu_state=%d\n",\r\nintr, in_8(&via[IER]), pmu_state);\r\nbreak;\r\n}\r\nout_8(&via[IFR], intr);\r\nif (intr & CB1_INT) {\r\nadb_int_pending = 1;\r\npmu_irq_stats[0]++;\r\n}\r\nif (intr & SR_INT) {\r\nreq = pmu_sr_intr();\r\nif (req)\r\nbreak;\r\n}\r\n}\r\nrecheck:\r\nif (pmu_state == idle) {\r\nif (adb_int_pending) {\r\nif (int_data_state[0] == int_data_empty)\r\nint_data_last = 0;\r\nelse if (int_data_state[1] == int_data_empty)\r\nint_data_last = 1;\r\nelse\r\ngoto no_free_slot;\r\npmu_state = intack;\r\nint_data_state[int_data_last] = int_data_fill;\r\nwait_for_ack();\r\nsend_byte(PMU_INT_ACK);\r\nadb_int_pending = 0;\r\n} else if (current_req)\r\npmu_start();\r\n}\r\nno_free_slot:\r\nif (int_data_state[!int_data_last] == int_data_ready) {\r\nint_data_state[!int_data_last] = int_data_flush;\r\nint_data = !int_data_last;\r\n} else if (int_data_state[int_data_last] == int_data_ready) {\r\nint_data_state[int_data_last] = int_data_flush;\r\nint_data = int_data_last;\r\n}\r\n--disable_poll;\r\nspin_unlock_irqrestore(&pmu_lock, flags);\r\nif (req) {\r\npmu_done(req);\r\nreq = NULL;\r\n}\r\nif (int_data >= 0) {\r\npmu_handle_data(interrupt_data[int_data], interrupt_data_len[int_data]);\r\nspin_lock_irqsave(&pmu_lock, flags);\r\n++disable_poll;\r\nint_data_state[int_data] = int_data_empty;\r\nint_data = -1;\r\ngoto recheck;\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nvoid\r\npmu_unlock(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pmu_lock, flags);\r\nif (pmu_state == locked)\r\npmu_state = idle;\r\nadb_int_pending = 1;\r\nspin_unlock_irqrestore(&pmu_lock, flags);\r\n}\r\nstatic irqreturn_t\r\ngpio1_interrupt(int irq, void *arg)\r\n{\r\nunsigned long flags;\r\nif ((in_8(gpio_reg + 0x9) & 0x02) == 0) {\r\nspin_lock_irqsave(&pmu_lock, flags);\r\nif (gpio_irq_enabled > 0) {\r\ndisable_irq_nosync(gpio_irq);\r\ngpio_irq_enabled = 0;\r\n}\r\npmu_irq_stats[1]++;\r\nadb_int_pending = 1;\r\nspin_unlock_irqrestore(&pmu_lock, flags);\r\nvia_pmu_interrupt(0, NULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nvoid\r\npmu_enable_irled(int on)\r\n{\r\nstruct adb_request req;\r\nif (vias == NULL)\r\nreturn ;\r\nif (pmu_kind == PMU_KEYLARGO_BASED)\r\nreturn ;\r\npmu_request(&req, NULL, 2, PMU_POWER_CTRL, PMU_POW_IRLED |\r\n(on ? PMU_POW_ON : PMU_POW_OFF));\r\npmu_wait_complete(&req);\r\n}\r\nvoid\r\npmu_restart(void)\r\n{\r\nstruct adb_request req;\r\nif (via == NULL)\r\nreturn;\r\nlocal_irq_disable();\r\ndrop_interrupts = 1;\r\nif (pmu_kind != PMU_KEYLARGO_BASED) {\r\npmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, PMU_INT_ADB |\r\nPMU_INT_TICK );\r\nwhile(!req.complete)\r\npmu_poll();\r\n}\r\npmu_request(&req, NULL, 1, PMU_RESET);\r\npmu_wait_complete(&req);\r\nfor (;;)\r\n;\r\n}\r\nvoid\r\npmu_shutdown(void)\r\n{\r\nstruct adb_request req;\r\nif (via == NULL)\r\nreturn;\r\nlocal_irq_disable();\r\ndrop_interrupts = 1;\r\nif (pmu_kind != PMU_KEYLARGO_BASED) {\r\npmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, PMU_INT_ADB |\r\nPMU_INT_TICK );\r\npmu_wait_complete(&req);\r\n} else {\r\npmu_set_server_mode(0);\r\n}\r\npmu_request(&req, NULL, 5, PMU_SHUTDOWN,\r\n'M', 'A', 'T', 'T');\r\npmu_wait_complete(&req);\r\nfor (;;)\r\n;\r\n}\r\nint\r\npmu_present(void)\r\n{\r\nreturn via != 0;\r\n}\r\nstatic void\r\nsave_via_state(void)\r\n{\r\nsave_via[0] = in_8(&via[ANH]);\r\nsave_via[1] = in_8(&via[DIRA]);\r\nsave_via[2] = in_8(&via[B]);\r\nsave_via[3] = in_8(&via[DIRB]);\r\nsave_via[4] = in_8(&via[PCR]);\r\nsave_via[5] = in_8(&via[ACR]);\r\nsave_via[6] = in_8(&via[T1CL]);\r\nsave_via[7] = in_8(&via[T1CH]);\r\n}\r\nstatic void\r\nrestore_via_state(void)\r\n{\r\nout_8(&via[ANH], save_via[0]);\r\nout_8(&via[DIRA], save_via[1]);\r\nout_8(&via[B], save_via[2]);\r\nout_8(&via[DIRB], save_via[3]);\r\nout_8(&via[PCR], save_via[4]);\r\nout_8(&via[ACR], save_via[5]);\r\nout_8(&via[T1CL], save_via[6]);\r\nout_8(&via[T1CH], save_via[7]);\r\nout_8(&via[IER], IER_CLR | 0x7f);\r\nout_8(&via[IFR], 0x7f);\r\nout_8(&via[IER], IER_SET | SR_INT | CB1_INT);\r\n}\r\nstatic int powerbook_sleep_grackle(void)\r\n{\r\nunsigned long save_l2cr;\r\nunsigned short pmcr1;\r\nstruct adb_request req;\r\nstruct pci_dev *grackle;\r\ngrackle = pci_get_bus_and_slot(0, 0);\r\nif (!grackle)\r\nreturn -ENODEV;\r\npmu_request(&req, NULL, 2, PMU_POWER_CTRL0, PMU_POW0_OFF|PMU_POW0_HARD_DRIVE);\r\npmu_wait_complete(&req);\r\npmu_request(&req, NULL, 2, PMU_POWER_CTRL,\r\nPMU_POW_OFF|PMU_POW_BACKLIGHT|PMU_POW_IRLED|PMU_POW_MEDIABAY);\r\npmu_wait_complete(&req);\r\nsave_l2cr = _get_L2CR();\r\nif (!__fake_sleep) {\r\npmu_request(&req, NULL, 5, PMU_SLEEP, 'M', 'A', 'T', 'T');\r\npmu_wait_complete(&req);\r\n}\r\nsave_via_state();\r\npmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,1);\r\npci_read_config_word(grackle, 0x70, &pmcr1);\r\npmcr1 &= ~(GRACKLE_DOZE|GRACKLE_SLEEP);\r\npmcr1 |= GRACKLE_PM|GRACKLE_NAP;\r\npci_write_config_word(grackle, 0x70, pmcr1);\r\nif (__fake_sleep)\r\nmdelay(5000);\r\nelse\r\nlow_sleep_handler();\r\npci_read_config_word(grackle, 0x70, &pmcr1);\r\npmcr1 &= ~(GRACKLE_PM|GRACKLE_DOZE|GRACKLE_SLEEP|GRACKLE_NAP);\r\npci_write_config_word(grackle, 0x70, pmcr1);\r\npci_dev_put(grackle);\r\npmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,0);\r\nrestore_via_state();\r\nif (save_l2cr != 0xffffffff && (save_l2cr & L2CR_L2E) != 0)\r\n_set_L2CR(save_l2cr);\r\nswitch_mmu_context(NULL, current->active_mm);\r\npmu_unlock();\r\npmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, pmu_intr_mask);\r\npmu_wait_complete(&req);\r\npmu_request(&req, NULL, 2, PMU_POWER_CTRL0,\r\nPMU_POW0_ON|PMU_POW0_HARD_DRIVE);\r\npmu_wait_complete(&req);\r\npmu_request(&req, NULL, 2, PMU_POWER_CTRL,\r\nPMU_POW_ON|PMU_POW_BACKLIGHT|PMU_POW_CHARGER|PMU_POW_IRLED|PMU_POW_MEDIABAY);\r\npmu_wait_complete(&req);\r\nreturn 0;\r\n}\r\nstatic int\r\npowerbook_sleep_Core99(void)\r\n{\r\nunsigned long save_l2cr;\r\nunsigned long save_l3cr;\r\nstruct adb_request req;\r\nif (pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,-1) < 0) {\r\nprintk(KERN_ERR "Sleep mode not supported on this machine\n");\r\nreturn -ENOSYS;\r\n}\r\nif (num_online_cpus() > 1 || cpu_is_offline(0))\r\nreturn -EAGAIN;\r\npmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, 0);\r\npmu_wait_complete(&req);\r\npmu_request(&req, NULL, 4, PMU_POWER_EVENTS, PMU_PWR_CLR_WAKEUP_EVENTS,\r\n0xff, 0xff);\r\npmu_wait_complete(&req);\r\npmu_request(&req, NULL, 4, PMU_POWER_EVENTS, PMU_PWR_SET_WAKEUP_EVENTS,\r\n0, PMU_PWR_WAKEUP_KEY |\r\n(option_lid_wakeup ? PMU_PWR_WAKEUP_LID_OPEN : 0));\r\npmu_wait_complete(&req);\r\nsave_l3cr = _get_L3CR();\r\nsave_l2cr = _get_L2CR();\r\nif (!__fake_sleep) {\r\npmu_request(&req, NULL, 5, PMU_SLEEP, 'M', 'A', 'T', 'T');\r\npmu_wait_complete(&req);\r\n}\r\nsave_via_state();\r\npmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, 1);\r\nif (__fake_sleep)\r\nmdelay(5000);\r\nelse\r\nlow_sleep_handler();\r\npmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, 0);\r\nrestore_via_state();\r\nloops_per_jiffy *= 2;\r\npmac_call_early_video_resume();\r\nif (save_l2cr != 0xffffffff && (save_l2cr & L2CR_L2E) != 0)\r\n_set_L2CR(save_l2cr);\r\nif (save_l3cr != 0xffffffff && (save_l3cr & L3CR_L3E) != 0)\r\n_set_L3CR(save_l3cr);\r\nswitch_mmu_context(NULL, current->active_mm);\r\npmu_unlock();\r\npmu_request(&req, NULL, 2, PMU_SYSTEM_READY, 2);\r\npmu_wait_complete(&req);\r\npmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, pmu_intr_mask);\r\npmu_wait_complete(&req);\r\nloops_per_jiffy /= 2;\r\nreturn 0;\r\n}\r\nstatic void powerbook_sleep_init_3400(void)\r\n{\r\npb3400_mem_ctrl = ioremap(PB3400_MEM_CTRL, 0x100);\r\nif (pb3400_mem_ctrl == NULL)\r\nprintk(KERN_WARNING "ioremap failed: sleep won't be possible");\r\n}\r\nstatic int powerbook_sleep_3400(void)\r\n{\r\nint i, x;\r\nunsigned int hid0;\r\nunsigned long msr;\r\nstruct adb_request sleep_req;\r\nunsigned int __iomem *mem_ctrl_sleep;\r\nif (pb3400_mem_ctrl == NULL)\r\nreturn -ENOMEM;\r\nmem_ctrl_sleep = pb3400_mem_ctrl + PB3400_MEM_CTRL_SLEEP;\r\nfor (i = 0x403f; i >= 0x4000; --i) {\r\nout_be32(mem_ctrl_sleep, i);\r\ndo {\r\nx = (in_be32(mem_ctrl_sleep) >> 16) & 0x3ff;\r\n} while (x == 0);\r\nif (x >= 0x100)\r\nbreak;\r\n}\r\npmu_request(&sleep_req, NULL, 5, PMU_SLEEP, 'M', 'A', 'T', 'T');\r\npmu_wait_complete(&sleep_req);\r\npmu_unlock();\r\npmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, 1);\r\nasleep = 1;\r\nhid0 = mfspr(SPRN_HID0);\r\nhid0 = (hid0 & ~(HID0_NAP | HID0_DOZE)) | HID0_SLEEP;\r\nmtspr(SPRN_HID0, hid0);\r\nlocal_irq_enable();\r\nmsr = mfmsr() | MSR_POW;\r\nwhile (asleep) {\r\nmb();\r\nmtmsr(msr);\r\nisync();\r\n}\r\nlocal_irq_disable();\r\nout_be32(mem_ctrl_sleep, 0x3f);\r\npmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, 0);\r\nreturn 0;\r\n}\r\nstatic void\r\npmu_pass_intr(unsigned char *data, int len)\r\n{\r\nstruct pmu_private *pp;\r\nstruct list_head *list;\r\nint i;\r\nunsigned long flags;\r\nif (len > sizeof(pp->rb_buf[0].data))\r\nlen = sizeof(pp->rb_buf[0].data);\r\nspin_lock_irqsave(&all_pvt_lock, flags);\r\nfor (list = &all_pmu_pvt; (list = list->next) != &all_pmu_pvt; ) {\r\npp = list_entry(list, struct pmu_private, list);\r\nspin_lock(&pp->lock);\r\ni = pp->rb_put + 1;\r\nif (i >= RB_SIZE)\r\ni = 0;\r\nif (i != pp->rb_get) {\r\nstruct rb_entry *rp = &pp->rb_buf[pp->rb_put];\r\nrp->len = len;\r\nmemcpy(rp->data, data, len);\r\npp->rb_put = i;\r\nwake_up_interruptible(&pp->wait);\r\n}\r\nspin_unlock(&pp->lock);\r\n}\r\nspin_unlock_irqrestore(&all_pvt_lock, flags);\r\n}\r\nstatic int\r\npmu_open(struct inode *inode, struct file *file)\r\n{\r\nstruct pmu_private *pp;\r\nunsigned long flags;\r\npp = kmalloc(sizeof(struct pmu_private), GFP_KERNEL);\r\nif (pp == 0)\r\nreturn -ENOMEM;\r\npp->rb_get = pp->rb_put = 0;\r\nspin_lock_init(&pp->lock);\r\ninit_waitqueue_head(&pp->wait);\r\nmutex_lock(&pmu_info_proc_mutex);\r\nspin_lock_irqsave(&all_pvt_lock, flags);\r\n#if defined(CONFIG_INPUT_ADBHID) && defined(CONFIG_PMAC_BACKLIGHT)\r\npp->backlight_locker = 0;\r\n#endif\r\nlist_add(&pp->list, &all_pmu_pvt);\r\nspin_unlock_irqrestore(&all_pvt_lock, flags);\r\nfile->private_data = pp;\r\nmutex_unlock(&pmu_info_proc_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\npmu_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct pmu_private *pp = file->private_data;\r\nDECLARE_WAITQUEUE(wait, current);\r\nunsigned long flags;\r\nint ret = 0;\r\nif (count < 1 || pp == 0)\r\nreturn -EINVAL;\r\nif (!access_ok(VERIFY_WRITE, buf, count))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&pp->lock, flags);\r\nadd_wait_queue(&pp->wait, &wait);\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nfor (;;) {\r\nret = -EAGAIN;\r\nif (pp->rb_get != pp->rb_put) {\r\nint i = pp->rb_get;\r\nstruct rb_entry *rp = &pp->rb_buf[i];\r\nret = rp->len;\r\nspin_unlock_irqrestore(&pp->lock, flags);\r\nif (ret > count)\r\nret = count;\r\nif (ret > 0 && copy_to_user(buf, rp->data, ret))\r\nret = -EFAULT;\r\nif (++i >= RB_SIZE)\r\ni = 0;\r\nspin_lock_irqsave(&pp->lock, flags);\r\npp->rb_get = i;\r\n}\r\nif (ret >= 0)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK)\r\nbreak;\r\nret = -ERESTARTSYS;\r\nif (signal_pending(current))\r\nbreak;\r\nspin_unlock_irqrestore(&pp->lock, flags);\r\nschedule();\r\nspin_lock_irqsave(&pp->lock, flags);\r\n}\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&pp->wait, &wait);\r\nspin_unlock_irqrestore(&pp->lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\npmu_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\npmu_fpoll(struct file *filp, poll_table *wait)\r\n{\r\nstruct pmu_private *pp = filp->private_data;\r\nunsigned int mask = 0;\r\nunsigned long flags;\r\nif (pp == 0)\r\nreturn 0;\r\npoll_wait(filp, &pp->wait, wait);\r\nspin_lock_irqsave(&pp->lock, flags);\r\nif (pp->rb_get != pp->rb_put)\r\nmask |= POLLIN;\r\nspin_unlock_irqrestore(&pp->lock, flags);\r\nreturn mask;\r\n}\r\nstatic int\r\npmu_release(struct inode *inode, struct file *file)\r\n{\r\nstruct pmu_private *pp = file->private_data;\r\nunsigned long flags;\r\nif (pp != 0) {\r\nfile->private_data = NULL;\r\nspin_lock_irqsave(&all_pvt_lock, flags);\r\nlist_del(&pp->list);\r\nspin_unlock_irqrestore(&all_pvt_lock, flags);\r\n#if defined(CONFIG_INPUT_ADBHID) && defined(CONFIG_PMAC_BACKLIGHT)\r\nif (pp->backlight_locker)\r\npmac_backlight_enable();\r\n#endif\r\nkfree(pp);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pmac_suspend_disable_irqs(void)\r\n{\r\npmac_pfunc_i2c_suspend();\r\npmac_pfunc_base_suspend();\r\n}\r\nstatic int powerbook_sleep(suspend_state_t state)\r\n{\r\nint error = 0;\r\nwhile (!batt_req.complete)\r\npmu_poll();\r\nenable_kernel_fp();\r\n#ifdef CONFIG_ALTIVEC\r\nif (cpu_has_feature(CPU_FTR_ALTIVEC))\r\nenable_kernel_altivec();\r\n#endif\r\nswitch (pmu_kind) {\r\ncase PMU_OHARE_BASED:\r\nerror = powerbook_sleep_3400();\r\nbreak;\r\ncase PMU_HEATHROW_BASED:\r\ncase PMU_PADDINGTON_BASED:\r\nerror = powerbook_sleep_grackle();\r\nbreak;\r\ncase PMU_KEYLARGO_BASED:\r\nerror = powerbook_sleep_Core99();\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nif (error)\r\nreturn error;\r\nmdelay(100);\r\nreturn 0;\r\n}\r\nstatic void pmac_suspend_enable_irqs(void)\r\n{\r\nadb_int_pending = 1;\r\nvia_pmu_interrupt(0, NULL);\r\nmdelay(10);\r\npmac_pfunc_base_resume();\r\npmac_pfunc_i2c_resume();\r\n}\r\nstatic int pmu_sleep_valid(suspend_state_t state)\r\n{\r\nreturn state == PM_SUSPEND_MEM\r\n&& (pmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, -1) >= 0);\r\n}\r\nstatic int register_pmu_pm_ops(void)\r\n{\r\nif (pmu_kind == PMU_OHARE_BASED)\r\npowerbook_sleep_init_3400();\r\nppc_md.suspend_disable_irqs = pmac_suspend_disable_irqs;\r\nppc_md.suspend_enable_irqs = pmac_suspend_enable_irqs;\r\nsuspend_set_ops(&pmu_pm_ops);\r\nreturn 0;\r\n}\r\nstatic int pmu_ioctl(struct file *filp,\r\nu_int cmd, u_long arg)\r\n{\r\n__u32 __user *argp = (__u32 __user *)arg;\r\nint error = -EINVAL;\r\nswitch (cmd) {\r\ncase PMU_IOC_SLEEP:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nreturn pm_suspend(PM_SUSPEND_MEM);\r\ncase PMU_IOC_CAN_SLEEP:\r\nif (pmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, -1) < 0)\r\nreturn put_user(0, argp);\r\nelse\r\nreturn put_user(1, argp);\r\n#ifdef CONFIG_PMAC_BACKLIGHT_LEGACY\r\ncase PMU_IOC_GET_BACKLIGHT:\r\n{\r\nint brightness;\r\nbrightness = pmac_backlight_get_legacy_brightness();\r\nif (brightness < 0)\r\nreturn brightness;\r\nelse\r\nreturn put_user(brightness, argp);\r\n}\r\ncase PMU_IOC_SET_BACKLIGHT:\r\n{\r\nint brightness;\r\nerror = get_user(brightness, argp);\r\nif (error)\r\nreturn error;\r\nreturn pmac_backlight_set_legacy_brightness(brightness);\r\n}\r\n#ifdef CONFIG_INPUT_ADBHID\r\ncase PMU_IOC_GRAB_BACKLIGHT: {\r\nstruct pmu_private *pp = filp->private_data;\r\nif (pp->backlight_locker)\r\nreturn 0;\r\npp->backlight_locker = 1;\r\npmac_backlight_disable();\r\nreturn 0;\r\n}\r\n#endif\r\n#endif\r\ncase PMU_IOC_GET_MODEL:\r\nreturn put_user(pmu_kind, argp);\r\ncase PMU_IOC_HAS_ADB:\r\nreturn put_user(pmu_has_adb, argp);\r\n}\r\nreturn error;\r\n}\r\nstatic long pmu_unlocked_ioctl(struct file *filp,\r\nu_int cmd, u_long arg)\r\n{\r\nint ret;\r\nmutex_lock(&pmu_info_proc_mutex);\r\nret = pmu_ioctl(filp, cmd, arg);\r\nmutex_unlock(&pmu_info_proc_mutex);\r\nreturn ret;\r\n}\r\nstatic long compat_pmu_ioctl (struct file *filp, u_int cmd, u_long arg)\r\n{\r\nswitch (cmd) {\r\ncase PMU_IOC_SLEEP:\r\nbreak;\r\ncase PMU_IOC_GET_BACKLIGHT32:\r\ncmd = PMU_IOC_GET_BACKLIGHT;\r\nbreak;\r\ncase PMU_IOC_SET_BACKLIGHT32:\r\ncmd = PMU_IOC_SET_BACKLIGHT;\r\nbreak;\r\ncase PMU_IOC_GET_MODEL32:\r\ncmd = PMU_IOC_GET_MODEL;\r\nbreak;\r\ncase PMU_IOC_HAS_ADB32:\r\ncmd = PMU_IOC_HAS_ADB;\r\nbreak;\r\ncase PMU_IOC_CAN_SLEEP32:\r\ncmd = PMU_IOC_CAN_SLEEP;\r\nbreak;\r\ncase PMU_IOC_GRAB_BACKLIGHT32:\r\ncmd = PMU_IOC_GRAB_BACKLIGHT;\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn pmu_unlocked_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic int pmu_device_init(void)\r\n{\r\nif (!via)\r\nreturn 0;\r\nif (misc_register(&pmu_device) < 0)\r\nprintk(KERN_ERR "via-pmu: cannot register misc device.\n");\r\nreturn 0;\r\n}\r\nstatic inline void\r\npolled_handshake(volatile unsigned char __iomem *via)\r\n{\r\nvia[B] &= ~TREQ; eieio();\r\nwhile ((via[B] & TACK) != 0)\r\n;\r\nvia[B] |= TREQ; eieio();\r\nwhile ((via[B] & TACK) == 0)\r\n;\r\n}\r\nstatic inline void\r\npolled_send_byte(volatile unsigned char __iomem *via, int x)\r\n{\r\nvia[ACR] |= SR_OUT | SR_EXT; eieio();\r\nvia[SR] = x; eieio();\r\npolled_handshake(via);\r\n}\r\nstatic inline int\r\npolled_recv_byte(volatile unsigned char __iomem *via)\r\n{\r\nint x;\r\nvia[ACR] = (via[ACR] & ~SR_OUT) | SR_EXT; eieio();\r\nx = via[SR]; eieio();\r\npolled_handshake(via);\r\nx = via[SR]; eieio();\r\nreturn x;\r\n}\r\nint\r\npmu_polled_request(struct adb_request *req)\r\n{\r\nunsigned long flags;\r\nint i, l, c;\r\nvolatile unsigned char __iomem *v = via;\r\nreq->complete = 1;\r\nc = req->data[0];\r\nl = pmu_data_len[c][0];\r\nif (l >= 0 && req->nbytes != l + 1)\r\nreturn -EINVAL;\r\nlocal_irq_save(flags);\r\nwhile (pmu_state != idle)\r\npmu_poll();\r\nwhile ((via[B] & TACK) == 0)\r\n;\r\npolled_send_byte(v, c);\r\nif (l < 0) {\r\nl = req->nbytes - 1;\r\npolled_send_byte(v, l);\r\n}\r\nfor (i = 1; i <= l; ++i)\r\npolled_send_byte(v, req->data[i]);\r\nl = pmu_data_len[c][1];\r\nif (l < 0)\r\nl = polled_recv_byte(v);\r\nfor (i = 0; i < l; ++i)\r\nreq->reply[i + req->reply_len] = polled_recv_byte(v);\r\nif (req->done)\r\n(*req->done)(req);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nvoid pmu_blink(int n)\r\n{\r\nstruct adb_request req;\r\nmemset(&req, 0, sizeof(req));\r\nfor (; n > 0; --n) {\r\nreq.nbytes = 4;\r\nreq.done = NULL;\r\nreq.data[0] = 0xee;\r\nreq.data[1] = 4;\r\nreq.data[2] = 0;\r\nreq.data[3] = 1;\r\nreq.reply[0] = ADB_RET_OK;\r\nreq.reply_len = 1;\r\nreq.reply_expected = 0;\r\npmu_polled_request(&req);\r\nmdelay(50);\r\nreq.nbytes = 4;\r\nreq.done = NULL;\r\nreq.data[0] = 0xee;\r\nreq.data[1] = 4;\r\nreq.data[2] = 0;\r\nreq.data[3] = 0;\r\nreq.reply[0] = ADB_RET_OK;\r\nreq.reply_len = 1;\r\nreq.reply_expected = 0;\r\npmu_polled_request(&req);\r\nmdelay(50);\r\n}\r\nmdelay(50);\r\n}\r\nstatic int pmu_syscore_suspend(void)\r\n{\r\npmu_suspend();\r\npmu_sys_suspended = 1;\r\n#ifdef CONFIG_PMAC_BACKLIGHT\r\npmu_backlight_set_sleep(1);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void pmu_syscore_resume(void)\r\n{\r\nstruct adb_request req;\r\nif (!pmu_sys_suspended)\r\nreturn;\r\npmu_request(&req, NULL, 2, PMU_SYSTEM_READY, 2);\r\npmu_wait_complete(&req);\r\n#ifdef CONFIG_PMAC_BACKLIGHT\r\npmu_backlight_set_sleep(0);\r\n#endif\r\npmu_resume();\r\npmu_sys_suspended = 0;\r\n}\r\nstatic int pmu_syscore_register(void)\r\n{\r\nregister_syscore_ops(&pmu_syscore_ops);\r\nreturn 0;\r\n}
