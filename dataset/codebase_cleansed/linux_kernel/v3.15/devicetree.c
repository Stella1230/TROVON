void __init early_init_dt_scan_chosen_arch(unsigned long node)\r\n{\r\nBUG();\r\n}\r\nvoid __init early_init_dt_add_memory_arch(u64 base, u64 size)\r\n{\r\nBUG();\r\n}\r\nvoid * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)\r\n{\r\nreturn __alloc_bootmem(size, align, __pa(MAX_DMA_ADDRESS));\r\n}\r\nvoid __init add_dtb(u64 data)\r\n{\r\ninitial_dtb = data + offsetof(struct setup_data, data);\r\n}\r\nstatic int __init add_bus_probe(void)\r\n{\r\nif (!of_have_populated_dt())\r\nreturn 0;\r\nreturn of_platform_bus_probe(NULL, ce4100_ids, NULL);\r\n}\r\nstruct device_node *pcibios_get_phb_of_node(struct pci_bus *bus)\r\n{\r\nstruct device_node *np;\r\nfor_each_node_by_type(np, "pci") {\r\nconst void *prop;\r\nunsigned int bus_min;\r\nprop = of_get_property(np, "bus-range", NULL);\r\nif (!prop)\r\ncontinue;\r\nbus_min = be32_to_cpup(prop);\r\nif (bus->number == bus_min)\r\nreturn np;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int x86_of_pci_irq_enable(struct pci_dev *dev)\r\n{\r\nu32 virq;\r\nint ret;\r\nu8 pin;\r\nret = pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);\r\nif (ret)\r\nreturn ret;\r\nif (!pin)\r\nreturn 0;\r\nvirq = of_irq_parse_and_map_pci(dev, 0, 0);\r\nif (virq == 0)\r\nreturn -EINVAL;\r\ndev->irq = virq;\r\nreturn 0;\r\n}\r\nstatic void x86_of_pci_irq_disable(struct pci_dev *dev)\r\n{\r\n}\r\nvoid x86_of_pci_init(void)\r\n{\r\npcibios_enable_irq = x86_of_pci_irq_enable;\r\npcibios_disable_irq = x86_of_pci_irq_disable;\r\n}\r\nstatic void __init dtb_setup_hpet(void)\r\n{\r\n#ifdef CONFIG_HPET_TIMER\r\nstruct device_node *dn;\r\nstruct resource r;\r\nint ret;\r\ndn = of_find_compatible_node(NULL, NULL, "intel,ce4100-hpet");\r\nif (!dn)\r\nreturn;\r\nret = of_address_to_resource(dn, 0, &r);\r\nif (ret) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nhpet_address = r.start;\r\n#endif\r\n}\r\nstatic void __init dtb_lapic_setup(void)\r\n{\r\n#ifdef CONFIG_X86_LOCAL_APIC\r\nstruct device_node *dn;\r\nstruct resource r;\r\nint ret;\r\ndn = of_find_compatible_node(NULL, NULL, "intel,ce4100-lapic");\r\nif (!dn)\r\nreturn;\r\nret = of_address_to_resource(dn, 0, &r);\r\nif (WARN_ON(ret))\r\nreturn;\r\nif (!cpu_has_apic) {\r\nif (apic_force_enable(r.start))\r\nreturn;\r\n}\r\nsmp_found_config = 1;\r\npic_mode = 1;\r\nregister_lapic_address(r.start);\r\ngeneric_processor_info(boot_cpu_physical_apicid,\r\nGET_APIC_VERSION(apic_read(APIC_LVR)));\r\n#endif\r\n}\r\nstatic void __init dtb_add_ioapic(struct device_node *dn)\r\n{\r\nstruct resource r;\r\nint ret;\r\nret = of_address_to_resource(dn, 0, &r);\r\nif (ret) {\r\nprintk(KERN_ERR "Can't obtain address from node %s.\n",\r\ndn->full_name);\r\nreturn;\r\n}\r\nmp_register_ioapic(++ioapic_id, r.start, gsi_top);\r\n}\r\nstatic void __init dtb_ioapic_setup(void)\r\n{\r\nstruct device_node *dn;\r\nfor_each_compatible_node(dn, NULL, "intel,ce4100-ioapic")\r\ndtb_add_ioapic(dn);\r\nif (nr_ioapics) {\r\nof_ioapic = 1;\r\nreturn;\r\n}\r\nprintk(KERN_ERR "Error: No information about IO-APIC in OF.\n");\r\n}\r\nstatic void __init dtb_ioapic_setup(void) {}\r\nstatic void __init dtb_apic_setup(void)\r\n{\r\ndtb_lapic_setup();\r\ndtb_ioapic_setup();\r\n}\r\nstatic void __init x86_flattree_get_config(void)\r\n{\r\nu32 size, map_len;\r\nstruct boot_param_header *dt;\r\nif (!initial_dtb)\r\nreturn;\r\nmap_len = max(PAGE_SIZE - (initial_dtb & ~PAGE_MASK),\r\n(u64)sizeof(struct boot_param_header));\r\ndt = early_memremap(initial_dtb, map_len);\r\nsize = be32_to_cpu(dt->totalsize);\r\nif (map_len < size) {\r\nearly_iounmap(dt, map_len);\r\ndt = early_memremap(initial_dtb, size);\r\nmap_len = size;\r\n}\r\ninitial_boot_params = dt;\r\nunflatten_and_copy_device_tree();\r\nearly_iounmap(dt, map_len);\r\n}\r\nstatic inline void x86_flattree_get_config(void) { }\r\nvoid __init x86_dtb_init(void)\r\n{\r\nx86_flattree_get_config();\r\nif (!of_have_populated_dt())\r\nreturn;\r\ndtb_setup_hpet();\r\ndtb_apic_setup();\r\n}\r\nstatic int ioapic_xlate(struct irq_domain *domain,\r\nstruct device_node *controller,\r\nconst u32 *intspec, u32 intsize,\r\nirq_hw_number_t *out_hwirq, u32 *out_type)\r\n{\r\nstruct io_apic_irq_attr attr;\r\nstruct of_ioapic_type *it;\r\nu32 line, idx;\r\nint rc;\r\nif (WARN_ON(intsize < 2))\r\nreturn -EINVAL;\r\nline = intspec[0];\r\nif (intspec[1] >= ARRAY_SIZE(of_ioapic_type))\r\nreturn -EINVAL;\r\nit = &of_ioapic_type[intspec[1]];\r\nidx = (u32) domain->host_data;\r\nset_io_apic_irq_attr(&attr, idx, line, it->trigger, it->polarity);\r\nrc = io_apic_setup_irq_pin_once(irq_find_mapping(domain, line),\r\ncpu_to_node(0), &attr);\r\nif (rc)\r\nreturn rc;\r\n*out_hwirq = line;\r\n*out_type = it->out_type;\r\nreturn 0;\r\n}\r\nstatic void dt_add_ioapic_domain(unsigned int ioapic_num,\r\nstruct device_node *np)\r\n{\r\nstruct irq_domain *id;\r\nstruct mp_ioapic_gsi *gsi_cfg;\r\nint ret;\r\nint num;\r\ngsi_cfg = mp_ioapic_gsi_routing(ioapic_num);\r\nnum = gsi_cfg->gsi_end - gsi_cfg->gsi_base + 1;\r\nid = irq_domain_add_linear(np, num, &ioapic_irq_domain_ops,\r\n(void *)ioapic_num);\r\nBUG_ON(!id);\r\nif (gsi_cfg->gsi_base == 0) {\r\nirq_domain_associate_many(id, 0, 0, NR_IRQS_LEGACY);\r\nif (num > NR_IRQS_LEGACY) {\r\nret = irq_create_strict_mappings(id, NR_IRQS_LEGACY,\r\nNR_IRQS_LEGACY, num - NR_IRQS_LEGACY);\r\nif (ret)\r\npr_err("Error creating mapping for the "\r\n"remaining IRQs: %d\n", ret);\r\n}\r\nirq_set_default_host(id);\r\n} else {\r\nret = irq_create_strict_mappings(id, gsi_cfg->gsi_base, 0, num);\r\nif (ret)\r\npr_err("Error creating IRQ mapping: %d\n", ret);\r\n}\r\n}\r\nstatic void __init ioapic_add_ofnode(struct device_node *np)\r\n{\r\nstruct resource r;\r\nint i, ret;\r\nret = of_address_to_resource(np, 0, &r);\r\nif (ret) {\r\nprintk(KERN_ERR "Failed to obtain address for %s\n",\r\nnp->full_name);\r\nreturn;\r\n}\r\nfor (i = 0; i < nr_ioapics; i++) {\r\nif (r.start == mpc_ioapic_addr(i)) {\r\ndt_add_ioapic_domain(i, np);\r\nreturn;\r\n}\r\n}\r\nprintk(KERN_ERR "IOxAPIC at %s is not registered.\n", np->full_name);\r\n}\r\nvoid __init x86_add_irq_domains(void)\r\n{\r\nstruct device_node *dp;\r\nif (!of_have_populated_dt())\r\nreturn;\r\nfor_each_node_with_property(dp, "interrupt-controller") {\r\nif (of_device_is_compatible(dp, "intel,ce4100-ioapic"))\r\nioapic_add_ofnode(dp);\r\n}\r\n}\r\nvoid __init x86_add_irq_domains(void) { }
