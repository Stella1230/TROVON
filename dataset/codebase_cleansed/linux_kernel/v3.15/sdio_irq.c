static int process_sdio_pending_irqs(struct mmc_host *host)\r\n{\r\nstruct mmc_card *card = host->card;\r\nint i, ret, count;\r\nunsigned char pending;\r\nstruct sdio_func *func;\r\nfunc = card->sdio_single_irq;\r\nif (func && host->sdio_irq_pending) {\r\nfunc->irq_handler(func);\r\nreturn 1;\r\n}\r\nret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0, &pending);\r\nif (ret) {\r\npr_debug("%s: error %d reading SDIO_CCCR_INTx\n",\r\nmmc_card_id(card), ret);\r\nreturn ret;\r\n}\r\nif (pending && mmc_card_broken_irq_polling(card) &&\r\n!(host->caps & MMC_CAP_SDIO_IRQ)) {\r\nunsigned char dummy;\r\nmmc_io_rw_direct(card, 0, 0, 0xff, 0, &dummy);\r\n}\r\ncount = 0;\r\nfor (i = 1; i <= 7; i++) {\r\nif (pending & (1 << i)) {\r\nfunc = card->sdio_func[i - 1];\r\nif (!func) {\r\npr_warning("%s: pending IRQ for "\r\n"non-existent function\n",\r\nmmc_card_id(card));\r\nret = -EINVAL;\r\n} else if (func->irq_handler) {\r\nfunc->irq_handler(func);\r\ncount++;\r\n} else {\r\npr_warning("%s: pending IRQ with no handler\n",\r\nsdio_func_id(func));\r\nret = -EINVAL;\r\n}\r\n}\r\n}\r\nif (count)\r\nreturn count;\r\nreturn ret;\r\n}\r\nstatic int sdio_irq_thread(void *_host)\r\n{\r\nstruct mmc_host *host = _host;\r\nstruct sched_param param = { .sched_priority = 1 };\r\nunsigned long period, idle_period;\r\nint ret;\r\nsched_setscheduler(current, SCHED_FIFO, &param);\r\nidle_period = msecs_to_jiffies(10);\r\nperiod = (host->caps & MMC_CAP_SDIO_IRQ) ?\r\nMAX_SCHEDULE_TIMEOUT : idle_period;\r\npr_debug("%s: IRQ thread started (poll period = %lu jiffies)\n",\r\nmmc_hostname(host), period);\r\ndo {\r\nret = __mmc_claim_host(host, &host->sdio_irq_thread_abort);\r\nif (ret)\r\nbreak;\r\nret = process_sdio_pending_irqs(host);\r\nhost->sdio_irq_pending = false;\r\nmmc_release_host(host);\r\nif (ret < 0) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!kthread_should_stop())\r\nschedule_timeout(HZ);\r\nset_current_state(TASK_RUNNING);\r\n}\r\nif (!(host->caps & MMC_CAP_SDIO_IRQ)) {\r\nif (ret > 0)\r\nperiod /= 2;\r\nelse {\r\nperiod++;\r\nif (period > idle_period)\r\nperiod = idle_period;\r\n}\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (host->caps & MMC_CAP_SDIO_IRQ) {\r\nmmc_host_clk_hold(host);\r\nhost->ops->enable_sdio_irq(host, 1);\r\nmmc_host_clk_release(host);\r\n}\r\nif (!kthread_should_stop())\r\nschedule_timeout(period);\r\nset_current_state(TASK_RUNNING);\r\n} while (!kthread_should_stop());\r\nif (host->caps & MMC_CAP_SDIO_IRQ) {\r\nmmc_host_clk_hold(host);\r\nhost->ops->enable_sdio_irq(host, 0);\r\nmmc_host_clk_release(host);\r\n}\r\npr_debug("%s: IRQ thread exiting with code %d\n",\r\nmmc_hostname(host), ret);\r\nreturn ret;\r\n}\r\nstatic int sdio_card_irq_get(struct mmc_card *card)\r\n{\r\nstruct mmc_host *host = card->host;\r\nWARN_ON(!host->claimed);\r\nif (!host->sdio_irqs++) {\r\natomic_set(&host->sdio_irq_thread_abort, 0);\r\nhost->sdio_irq_thread =\r\nkthread_run(sdio_irq_thread, host, "ksdioirqd/%s",\r\nmmc_hostname(host));\r\nif (IS_ERR(host->sdio_irq_thread)) {\r\nint err = PTR_ERR(host->sdio_irq_thread);\r\nhost->sdio_irqs--;\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdio_card_irq_put(struct mmc_card *card)\r\n{\r\nstruct mmc_host *host = card->host;\r\nWARN_ON(!host->claimed);\r\nBUG_ON(host->sdio_irqs < 1);\r\nif (!--host->sdio_irqs) {\r\natomic_set(&host->sdio_irq_thread_abort, 1);\r\nkthread_stop(host->sdio_irq_thread);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sdio_single_irq_set(struct mmc_card *card)\r\n{\r\nstruct sdio_func *func;\r\nint i;\r\ncard->sdio_single_irq = NULL;\r\nif ((card->host->caps & MMC_CAP_SDIO_IRQ) &&\r\ncard->host->sdio_irqs == 1)\r\nfor (i = 0; i < card->sdio_funcs; i++) {\r\nfunc = card->sdio_func[i];\r\nif (func && func->irq_handler) {\r\ncard->sdio_single_irq = func;\r\nbreak;\r\n}\r\n}\r\n}\r\nint sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler)\r\n{\r\nint ret;\r\nunsigned char reg;\r\nBUG_ON(!func);\r\nBUG_ON(!func->card);\r\npr_debug("SDIO: Enabling IRQ for %s...\n", sdio_func_id(func));\r\nif (func->irq_handler) {\r\npr_debug("SDIO: IRQ for %s already in use.\n", sdio_func_id(func));\r\nreturn -EBUSY;\r\n}\r\nret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IENx, 0, &reg);\r\nif (ret)\r\nreturn ret;\r\nreg |= 1 << func->num;\r\nreg |= 1;\r\nret = mmc_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, reg, NULL);\r\nif (ret)\r\nreturn ret;\r\nfunc->irq_handler = handler;\r\nret = sdio_card_irq_get(func->card);\r\nif (ret)\r\nfunc->irq_handler = NULL;\r\nsdio_single_irq_set(func->card);\r\nreturn ret;\r\n}\r\nint sdio_release_irq(struct sdio_func *func)\r\n{\r\nint ret;\r\nunsigned char reg;\r\nBUG_ON(!func);\r\nBUG_ON(!func->card);\r\npr_debug("SDIO: Disabling IRQ for %s...\n", sdio_func_id(func));\r\nif (func->irq_handler) {\r\nfunc->irq_handler = NULL;\r\nsdio_card_irq_put(func->card);\r\nsdio_single_irq_set(func->card);\r\n}\r\nret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IENx, 0, &reg);\r\nif (ret)\r\nreturn ret;\r\nreg &= ~(1 << func->num);\r\nif (!(reg & 0xFE))\r\nreg = 0;\r\nret = mmc_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, reg, NULL);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}
