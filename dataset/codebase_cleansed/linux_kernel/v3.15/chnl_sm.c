int bridge_chnl_add_io_req(struct chnl_object *chnl_obj, void *host_buf,\r\nu32 byte_size, u32 buf_size,\r\nu32 dw_dsp_addr, u32 dw_arg)\r\n{\r\nint status = 0;\r\nstruct chnl_object *pchnl = (struct chnl_object *)chnl_obj;\r\nstruct chnl_irp *chnl_packet_obj = NULL;\r\nstruct bridge_dev_context *dev_ctxt;\r\nstruct dev_object *dev_obj;\r\nu8 dw_state;\r\nbool is_eos;\r\nstruct chnl_mgr *chnl_mgr_obj;\r\nu8 *host_sys_buf = NULL;\r\nbool sched_dpc = false;\r\nu16 mb_val = 0;\r\nis_eos = (byte_size == 0);\r\nif (!host_buf || !pchnl)\r\nreturn -EFAULT;\r\nif (is_eos && CHNL_IS_INPUT(pchnl->chnl_mode))\r\nreturn -EPERM;\r\ndw_state = pchnl->state;\r\nif (dw_state != CHNL_STATEREADY) {\r\nif (dw_state & CHNL_STATECANCEL)\r\nreturn -ECANCELED;\r\nif ((dw_state & CHNL_STATEEOS) &&\r\nCHNL_IS_OUTPUT(pchnl->chnl_mode))\r\nreturn -EPIPE;\r\n}\r\ndev_obj = dev_get_first();\r\ndev_get_bridge_context(dev_obj, &dev_ctxt);\r\nif (!dev_ctxt)\r\nreturn -EFAULT;\r\nif (pchnl->chnl_type == CHNL_PCPY && pchnl->chnl_id > 1 && host_buf) {\r\nif (!(host_buf < (void *)USERMODE_ADDR)) {\r\nhost_sys_buf = host_buf;\r\ngoto func_cont;\r\n}\r\nhost_sys_buf = kmalloc(buf_size, GFP_KERNEL);\r\nif (host_sys_buf == NULL)\r\nreturn -ENOMEM;\r\nif (CHNL_IS_OUTPUT(pchnl->chnl_mode)) {\r\nstatus = copy_from_user(host_sys_buf, host_buf,\r\nbuf_size);\r\nif (status) {\r\nkfree(host_sys_buf);\r\nhost_sys_buf = NULL;\r\nreturn -EFAULT;\r\n}\r\n}\r\n}\r\nfunc_cont:\r\nchnl_mgr_obj = pchnl->chnl_mgr_obj;\r\nspin_lock_bh(&chnl_mgr_obj->chnl_mgr_lock);\r\nomap_mbox_disable_irq(dev_ctxt->mbox, IRQ_RX);\r\nif (pchnl->chnl_type == CHNL_PCPY) {\r\nif (CHNL_IS_OUTPUT(pchnl->chnl_mode)) {\r\nif (byte_size > io_buf_size(\r\npchnl->chnl_mgr_obj->iomgr)) {\r\nstatus = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\n}\r\nif (list_empty(&pchnl->free_packets_list)) {\r\nstatus = -EIO;\r\ngoto out;\r\n}\r\nchnl_packet_obj = list_first_entry(&pchnl->free_packets_list,\r\nstruct chnl_irp, link);\r\nlist_del(&chnl_packet_obj->link);\r\nchnl_packet_obj->host_user_buf = chnl_packet_obj->host_sys_buf =\r\nhost_buf;\r\nif (pchnl->chnl_type == CHNL_PCPY && pchnl->chnl_id > 1)\r\nchnl_packet_obj->host_sys_buf = host_sys_buf;\r\nchnl_packet_obj->dsp_tx_addr = dw_dsp_addr / chnl_mgr_obj->word_size;\r\nchnl_packet_obj->byte_size = byte_size;\r\nchnl_packet_obj->buf_size = buf_size;\r\nchnl_packet_obj->arg = dw_arg;\r\nchnl_packet_obj->status = (is_eos ? CHNL_IOCSTATEOS :\r\nCHNL_IOCSTATCOMPLETE);\r\nlist_add_tail(&chnl_packet_obj->link, &pchnl->io_requests);\r\npchnl->cio_reqs++;\r\nif (is_eos)\r\npchnl->state |= CHNL_STATEEOS;\r\nio_request_chnl(chnl_mgr_obj->iomgr, pchnl,\r\n(CHNL_IS_INPUT(pchnl->chnl_mode) ? IO_INPUT :\r\nIO_OUTPUT), &mb_val);\r\nsched_dpc = true;\r\nout:\r\nomap_mbox_enable_irq(dev_ctxt->mbox, IRQ_RX);\r\nspin_unlock_bh(&chnl_mgr_obj->chnl_mgr_lock);\r\nif (mb_val != 0)\r\nsm_interrupt_dsp(dev_ctxt, mb_val);\r\nif (sched_dpc)\r\niosm_schedule(chnl_mgr_obj->iomgr);\r\nreturn status;\r\n}\r\nint bridge_chnl_cancel_io(struct chnl_object *chnl_obj)\r\n{\r\nstruct chnl_object *pchnl = (struct chnl_object *)chnl_obj;\r\nu32 chnl_id = -1;\r\ns8 chnl_mode;\r\nstruct chnl_irp *chirp, *tmp;\r\nstruct chnl_mgr *chnl_mgr_obj = NULL;\r\nif (!pchnl || !pchnl->chnl_mgr_obj)\r\nreturn -EFAULT;\r\nchnl_id = pchnl->chnl_id;\r\nchnl_mode = pchnl->chnl_mode;\r\nchnl_mgr_obj = pchnl->chnl_mgr_obj;\r\nspin_lock_bh(&chnl_mgr_obj->chnl_mgr_lock);\r\npchnl->state |= CHNL_STATECANCEL;\r\nif (list_empty(&pchnl->io_requests)) {\r\nspin_unlock_bh(&chnl_mgr_obj->chnl_mgr_lock);\r\nreturn 0;\r\n}\r\nif (pchnl->chnl_type == CHNL_PCPY) {\r\nif (CHNL_IS_INPUT(pchnl->chnl_mode)) {\r\nio_cancel_chnl(chnl_mgr_obj->iomgr, chnl_id);\r\n} else {\r\nchnl_mgr_obj->output_mask &= ~(1 << chnl_id);\r\n}\r\n}\r\nlist_for_each_entry_safe(chirp, tmp, &pchnl->io_requests, link) {\r\nlist_del(&chirp->link);\r\nchirp->byte_size = 0;\r\nchirp->status |= CHNL_IOCSTATCANCEL;\r\nlist_add_tail(&chirp->link, &pchnl->io_completions);\r\npchnl->cio_cs++;\r\npchnl->cio_reqs--;\r\n}\r\nspin_unlock_bh(&chnl_mgr_obj->chnl_mgr_lock);\r\nreturn 0;\r\n}\r\nint bridge_chnl_close(struct chnl_object *chnl_obj)\r\n{\r\nint status;\r\nstruct chnl_object *pchnl = (struct chnl_object *)chnl_obj;\r\nif (!pchnl)\r\nreturn -EFAULT;\r\nstatus = bridge_chnl_cancel_io(chnl_obj);\r\nif (status)\r\nreturn status;\r\npchnl->chnl_mgr_obj->channels[pchnl->chnl_id] = NULL;\r\nspin_lock_bh(&pchnl->chnl_mgr_obj->chnl_mgr_lock);\r\npchnl->chnl_mgr_obj->open_channels -= 1;\r\nspin_unlock_bh(&pchnl->chnl_mgr_obj->chnl_mgr_lock);\r\nif (pchnl->ntfy_obj) {\r\nntfy_delete(pchnl->ntfy_obj);\r\nkfree(pchnl->ntfy_obj);\r\npchnl->ntfy_obj = NULL;\r\n}\r\nif (pchnl->sync_event) {\r\nsync_reset_event(pchnl->sync_event);\r\nkfree(pchnl->sync_event);\r\npchnl->sync_event = NULL;\r\n}\r\nfree_chirp_list(&pchnl->io_completions);\r\npchnl->cio_cs = 0;\r\nfree_chirp_list(&pchnl->io_requests);\r\npchnl->cio_reqs = 0;\r\nfree_chirp_list(&pchnl->free_packets_list);\r\nkfree(pchnl);\r\nreturn status;\r\n}\r\nint bridge_chnl_create(struct chnl_mgr **channel_mgr,\r\nstruct dev_object *hdev_obj,\r\nconst struct chnl_mgrattrs *mgr_attrts)\r\n{\r\nint status = 0;\r\nstruct chnl_mgr *chnl_mgr_obj = NULL;\r\nu8 max_channels;\r\nchnl_mgr_obj = kzalloc(sizeof(struct chnl_mgr), GFP_KERNEL);\r\nif (chnl_mgr_obj) {\r\nmax_channels = CHNL_MAXCHANNELS + CHNL_MAXCHANNELS * CHNL_PCPY;\r\nchnl_mgr_obj->channels = kzalloc(sizeof(struct chnl_object *)\r\n* max_channels, GFP_KERNEL);\r\nif (chnl_mgr_obj->channels) {\r\nchnl_mgr_obj->type = CHNL_TYPESM;\r\nchnl_mgr_obj->word_size = mgr_attrts->word_size;\r\nchnl_mgr_obj->max_channels = max_channels;\r\nchnl_mgr_obj->open_channels = 0;\r\nchnl_mgr_obj->output_mask = 0;\r\nchnl_mgr_obj->last_output = 0;\r\nchnl_mgr_obj->dev_obj = hdev_obj;\r\nspin_lock_init(&chnl_mgr_obj->chnl_mgr_lock);\r\n} else {\r\nstatus = -ENOMEM;\r\n}\r\n} else {\r\nstatus = -ENOMEM;\r\n}\r\nif (status) {\r\nbridge_chnl_destroy(chnl_mgr_obj);\r\n*channel_mgr = NULL;\r\n} else {\r\n*channel_mgr = chnl_mgr_obj;\r\n}\r\nreturn status;\r\n}\r\nint bridge_chnl_destroy(struct chnl_mgr *hchnl_mgr)\r\n{\r\nint status = 0;\r\nstruct chnl_mgr *chnl_mgr_obj = hchnl_mgr;\r\nu32 chnl_id;\r\nif (hchnl_mgr) {\r\nfor (chnl_id = 0; chnl_id < chnl_mgr_obj->max_channels;\r\nchnl_id++) {\r\nstatus =\r\nbridge_chnl_close(chnl_mgr_obj->channels\r\n[chnl_id]);\r\nif (status)\r\ndev_dbg(bridge, "%s: Error status 0x%x\n",\r\n__func__, status);\r\n}\r\nkfree(chnl_mgr_obj->channels);\r\ndev_set_chnl_mgr(chnl_mgr_obj->dev_obj, NULL);\r\nkfree(hchnl_mgr);\r\n} else {\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nint bridge_chnl_flush_io(struct chnl_object *chnl_obj, u32 timeout)\r\n{\r\nint status = 0;\r\nstruct chnl_object *pchnl = (struct chnl_object *)chnl_obj;\r\ns8 chnl_mode = -1;\r\nstruct chnl_mgr *chnl_mgr_obj;\r\nstruct chnl_ioc chnl_ioc_obj;\r\nif (pchnl) {\r\nif ((timeout == CHNL_IOCNOWAIT)\r\n&& CHNL_IS_OUTPUT(pchnl->chnl_mode)) {\r\nstatus = -EINVAL;\r\n} else {\r\nchnl_mode = pchnl->chnl_mode;\r\nchnl_mgr_obj = pchnl->chnl_mgr_obj;\r\n}\r\n} else {\r\nstatus = -EFAULT;\r\n}\r\nif (!status) {\r\nif (CHNL_IS_OUTPUT(chnl_mode)\r\n&& (pchnl->chnl_type == CHNL_PCPY)) {\r\nwhile (!list_empty(&pchnl->io_requests) && !status) {\r\nstatus = bridge_chnl_get_ioc(chnl_obj,\r\ntimeout, &chnl_ioc_obj);\r\nif (status)\r\ncontinue;\r\nif (chnl_ioc_obj.status & CHNL_IOCSTATTIMEOUT)\r\nstatus = -ETIMEDOUT;\r\n}\r\n} else {\r\nstatus = bridge_chnl_cancel_io(chnl_obj);\r\npchnl->state &= ~CHNL_STATECANCEL;\r\n}\r\n}\r\nreturn status;\r\n}\r\nint bridge_chnl_get_info(struct chnl_object *chnl_obj,\r\nstruct chnl_info *channel_info)\r\n{\r\nint status = 0;\r\nstruct chnl_object *pchnl = (struct chnl_object *)chnl_obj;\r\nif (channel_info != NULL) {\r\nif (pchnl) {\r\nchannel_info->chnl_mgr = pchnl->chnl_mgr_obj;\r\nchannel_info->event_obj = pchnl->user_event;\r\nchannel_info->cnhl_id = pchnl->chnl_id;\r\nchannel_info->mode = pchnl->chnl_mode;\r\nchannel_info->bytes_tx = pchnl->bytes_moved;\r\nchannel_info->process = pchnl->process;\r\nchannel_info->sync_event = pchnl->sync_event;\r\nchannel_info->cio_cs = pchnl->cio_cs;\r\nchannel_info->cio_reqs = pchnl->cio_reqs;\r\nchannel_info->state = pchnl->state;\r\n} else {\r\nstatus = -EFAULT;\r\n}\r\n} else {\r\nstatus = -EFAULT;\r\n}\r\nreturn status;\r\n}\r\nint bridge_chnl_get_ioc(struct chnl_object *chnl_obj, u32 timeout,\r\nstruct chnl_ioc *chan_ioc)\r\n{\r\nint status = 0;\r\nstruct chnl_object *pchnl = (struct chnl_object *)chnl_obj;\r\nstruct chnl_irp *chnl_packet_obj;\r\nint stat_sync;\r\nbool dequeue_ioc = true;\r\nstruct chnl_ioc ioc = { NULL, 0, 0, 0, 0 };\r\nu8 *host_sys_buf = NULL;\r\nstruct bridge_dev_context *dev_ctxt;\r\nstruct dev_object *dev_obj;\r\nif (!chan_ioc || !pchnl) {\r\nstatus = -EFAULT;\r\n} else if (timeout == CHNL_IOCNOWAIT) {\r\nif (list_empty(&pchnl->io_completions))\r\nstatus = -EREMOTEIO;\r\n}\r\ndev_obj = dev_get_first();\r\ndev_get_bridge_context(dev_obj, &dev_ctxt);\r\nif (!dev_ctxt)\r\nstatus = -EFAULT;\r\nif (status)\r\ngoto func_end;\r\nioc.status = CHNL_IOCSTATCOMPLETE;\r\nif (timeout !=\r\nCHNL_IOCNOWAIT && list_empty(&pchnl->io_completions)) {\r\nif (timeout == CHNL_IOCINFINITE)\r\ntimeout = SYNC_INFINITE;\r\nstat_sync = sync_wait_on_event(pchnl->sync_event, timeout);\r\nif (stat_sync == -ETIME) {\r\nioc.status |= CHNL_IOCSTATTIMEOUT;\r\ndequeue_ioc = false;\r\n} else if (stat_sync == -EPERM) {\r\nif (list_empty(&pchnl->io_completions)) {\r\nioc.status |= CHNL_IOCSTATCANCEL;\r\ndequeue_ioc = false;\r\n}\r\n}\r\n}\r\nspin_lock_bh(&pchnl->chnl_mgr_obj->chnl_mgr_lock);\r\nomap_mbox_disable_irq(dev_ctxt->mbox, IRQ_RX);\r\nif (dequeue_ioc) {\r\nchnl_packet_obj = list_first_entry(&pchnl->io_completions,\r\nstruct chnl_irp, link);\r\nlist_del(&chnl_packet_obj->link);\r\npchnl->cio_cs--;\r\nhost_sys_buf = chnl_packet_obj->host_sys_buf;\r\nioc.buf = chnl_packet_obj->host_user_buf;\r\nioc.byte_size = chnl_packet_obj->byte_size;\r\nioc.buf_size = chnl_packet_obj->buf_size;\r\nioc.arg = chnl_packet_obj->arg;\r\nioc.status |= chnl_packet_obj->status;\r\nlist_add_tail(&chnl_packet_obj->link,\r\n&pchnl->free_packets_list);\r\n} else {\r\nioc.buf = NULL;\r\nioc.byte_size = 0;\r\nioc.arg = 0;\r\nioc.buf_size = 0;\r\n}\r\nif (!list_empty(&pchnl->io_completions)) {\r\nsync_set_event(pchnl->sync_event);\r\n} else {\r\nsync_reset_event(pchnl->sync_event);\r\n}\r\nomap_mbox_enable_irq(dev_ctxt->mbox, IRQ_RX);\r\nspin_unlock_bh(&pchnl->chnl_mgr_obj->chnl_mgr_lock);\r\nif (dequeue_ioc\r\n&& (pchnl->chnl_type == CHNL_PCPY && pchnl->chnl_id > 1)) {\r\nif (!(ioc.buf < (void *)USERMODE_ADDR))\r\ngoto func_cont;\r\nif (!host_sys_buf || !ioc.buf) {\r\nstatus = -EFAULT;\r\ngoto func_cont;\r\n}\r\nif (!CHNL_IS_INPUT(pchnl->chnl_mode))\r\ngoto func_cont1;\r\nstatus = copy_to_user(ioc.buf, host_sys_buf, ioc.byte_size);\r\nif (status) {\r\nif (current->flags & PF_EXITING)\r\nstatus = 0;\r\n}\r\nif (status)\r\nstatus = -EFAULT;\r\nfunc_cont1:\r\nkfree(host_sys_buf);\r\n}\r\nfunc_cont:\r\n*chan_ioc = ioc;\r\nfunc_end:\r\nreturn status;\r\n}\r\nint bridge_chnl_get_mgr_info(struct chnl_mgr *hchnl_mgr, u32 ch_id,\r\nstruct chnl_mgrinfo *mgr_info)\r\n{\r\nstruct chnl_mgr *chnl_mgr_obj = (struct chnl_mgr *)hchnl_mgr;\r\nif (!mgr_info || !hchnl_mgr)\r\nreturn -EFAULT;\r\nif (ch_id > CHNL_MAXCHANNELS)\r\nreturn -ECHRNG;\r\nmgr_info->chnl_obj = chnl_mgr_obj->channels[ch_id];\r\nmgr_info->open_channels = chnl_mgr_obj->open_channels;\r\nmgr_info->type = chnl_mgr_obj->type;\r\nmgr_info->max_channels = chnl_mgr_obj->max_channels;\r\nreturn 0;\r\n}\r\nint bridge_chnl_idle(struct chnl_object *chnl_obj, u32 timeout,\r\nbool flush_data)\r\n{\r\ns8 chnl_mode;\r\nstruct chnl_mgr *chnl_mgr_obj;\r\nint status = 0;\r\nchnl_mode = chnl_obj->chnl_mode;\r\nchnl_mgr_obj = chnl_obj->chnl_mgr_obj;\r\nif (CHNL_IS_OUTPUT(chnl_mode) && !flush_data) {\r\nstatus = bridge_chnl_flush_io(chnl_obj, timeout);\r\n} else {\r\nstatus = bridge_chnl_cancel_io(chnl_obj);\r\nchnl_obj->bytes_moved = 0;\r\nchnl_obj->state &= ~CHNL_STATECANCEL;\r\n}\r\nreturn status;\r\n}\r\nint bridge_chnl_open(struct chnl_object **chnl,\r\nstruct chnl_mgr *hchnl_mgr, s8 chnl_mode,\r\nu32 ch_id, const struct chnl_attr *pattrs)\r\n{\r\nint status = 0;\r\nstruct chnl_mgr *chnl_mgr_obj = hchnl_mgr;\r\nstruct chnl_object *pchnl = NULL;\r\nstruct sync_object *sync_event = NULL;\r\n*chnl = NULL;\r\nif (!pattrs->uio_reqs)\r\nreturn -EINVAL;\r\nif (!hchnl_mgr)\r\nreturn -EFAULT;\r\nif (ch_id != CHNL_PICKFREE) {\r\nif (ch_id >= chnl_mgr_obj->max_channels)\r\nreturn -ECHRNG;\r\nif (chnl_mgr_obj->channels[ch_id] != NULL)\r\nreturn -EALREADY;\r\n} else {\r\nstatus = search_free_channel(chnl_mgr_obj, &ch_id);\r\nif (status)\r\nreturn status;\r\n}\r\npchnl = kzalloc(sizeof(struct chnl_object), GFP_KERNEL);\r\nif (!pchnl)\r\nreturn -ENOMEM;\r\npchnl->state = CHNL_STATECANCEL;\r\nstatus = create_chirp_list(&pchnl->free_packets_list,\r\npattrs->uio_reqs);\r\nif (status)\r\ngoto out_err;\r\nINIT_LIST_HEAD(&pchnl->io_requests);\r\nINIT_LIST_HEAD(&pchnl->io_completions);\r\npchnl->chnl_packets = pattrs->uio_reqs;\r\npchnl->cio_cs = 0;\r\npchnl->cio_reqs = 0;\r\nsync_event = kzalloc(sizeof(struct sync_object), GFP_KERNEL);\r\nif (!sync_event) {\r\nstatus = -ENOMEM;\r\ngoto out_err;\r\n}\r\nsync_init_event(sync_event);\r\npchnl->ntfy_obj = kmalloc(sizeof(struct ntfy_object), GFP_KERNEL);\r\nif (!pchnl->ntfy_obj) {\r\nstatus = -ENOMEM;\r\ngoto out_err;\r\n}\r\nntfy_init(pchnl->ntfy_obj);\r\npchnl->chnl_mgr_obj = chnl_mgr_obj;\r\npchnl->chnl_id = ch_id;\r\npchnl->chnl_mode = chnl_mode;\r\npchnl->user_event = sync_event;\r\npchnl->sync_event = sync_event;\r\npchnl->process = current->tgid;\r\npchnl->cb_arg = 0;\r\npchnl->bytes_moved = 0;\r\npchnl->chnl_type = CHNL_PCPY;\r\nchnl_mgr_obj->channels[pchnl->chnl_id] = pchnl;\r\nspin_lock_bh(&chnl_mgr_obj->chnl_mgr_lock);\r\nchnl_mgr_obj->open_channels++;\r\nspin_unlock_bh(&chnl_mgr_obj->chnl_mgr_lock);\r\npchnl->state = CHNL_STATEREADY;\r\n*chnl = pchnl;\r\nreturn status;\r\nout_err:\r\nfree_chirp_list(&pchnl->io_completions);\r\nfree_chirp_list(&pchnl->io_requests);\r\nfree_chirp_list(&pchnl->free_packets_list);\r\nkfree(sync_event);\r\nif (pchnl->ntfy_obj) {\r\nntfy_delete(pchnl->ntfy_obj);\r\nkfree(pchnl->ntfy_obj);\r\npchnl->ntfy_obj = NULL;\r\n}\r\nkfree(pchnl);\r\nreturn status;\r\n}\r\nint bridge_chnl_register_notify(struct chnl_object *chnl_obj,\r\nu32 event_mask, u32 notify_type,\r\nstruct dsp_notification *hnotification)\r\n{\r\nint status = 0;\r\nif (event_mask)\r\nstatus = ntfy_register(chnl_obj->ntfy_obj, hnotification,\r\nevent_mask, notify_type);\r\nelse\r\nstatus = ntfy_unregister(chnl_obj->ntfy_obj, hnotification);\r\nreturn status;\r\n}\r\nstatic int create_chirp_list(struct list_head *list, u32 chirps)\r\n{\r\nstruct chnl_irp *chirp;\r\nu32 i;\r\nINIT_LIST_HEAD(list);\r\nfor (i = 0; i < chirps; i++) {\r\nchirp = kzalloc(sizeof(struct chnl_irp), GFP_KERNEL);\r\nif (!chirp)\r\nbreak;\r\nlist_add_tail(&chirp->link, list);\r\n}\r\nif (i != chirps) {\r\nfree_chirp_list(list);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_chirp_list(struct list_head *chirp_list)\r\n{\r\nstruct chnl_irp *chirp, *tmp;\r\nlist_for_each_entry_safe(chirp, tmp, chirp_list, link) {\r\nlist_del(&chirp->link);\r\nkfree(chirp);\r\n}\r\n}\r\nstatic int search_free_channel(struct chnl_mgr *chnl_mgr_obj,\r\nu32 *chnl)\r\n{\r\nint status = -ENOSR;\r\nu32 i;\r\nfor (i = 0; i < chnl_mgr_obj->max_channels; i++) {\r\nif (chnl_mgr_obj->channels[i] == NULL) {\r\nstatus = 0;\r\n*chnl = i;\r\nbreak;\r\n}\r\n}\r\nreturn status;\r\n}
