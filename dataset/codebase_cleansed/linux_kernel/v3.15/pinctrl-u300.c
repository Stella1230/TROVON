static int u300_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(u300_pin_groups);\r\n}\r\nstatic const char *u300_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nreturn u300_pin_groups[selector].name;\r\n}\r\nstatic int u300_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\n*pins = u300_pin_groups[selector].pins;\r\n*num_pins = u300_pin_groups[selector].num_pins;\r\nreturn 0;\r\n}\r\nstatic void u300_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nunsigned offset)\r\n{\r\nseq_printf(s, " " DRIVER_NAME);\r\n}\r\nstatic void u300_pmx_endisable(struct u300_pmx *upmx, unsigned selector,\r\nbool enable)\r\n{\r\nu16 regval, val, mask;\r\nint i;\r\nconst struct u300_pmx_mask *upmx_mask;\r\nupmx_mask = u300_pmx_functions[selector].mask;\r\nfor (i = 0; i < ARRAY_SIZE(u300_pmx_registers); i++) {\r\nif (enable)\r\nval = upmx_mask->bits;\r\nelse\r\nval = 0;\r\nmask = upmx_mask->mask;\r\nif (mask != 0) {\r\nregval = readw(upmx->virtbase + u300_pmx_registers[i]);\r\nregval &= ~mask;\r\nregval |= val;\r\nwritew(regval, upmx->virtbase + u300_pmx_registers[i]);\r\n}\r\nupmx_mask++;\r\n}\r\n}\r\nstatic int u300_pmx_enable(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group)\r\n{\r\nstruct u300_pmx *upmx;\r\nif (selector == 0)\r\nreturn 0;\r\nupmx = pinctrl_dev_get_drvdata(pctldev);\r\nu300_pmx_endisable(upmx, selector, true);\r\nreturn 0;\r\n}\r\nstatic void u300_pmx_disable(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group)\r\n{\r\nstruct u300_pmx *upmx;\r\nif (selector == 0)\r\nreturn;\r\nupmx = pinctrl_dev_get_drvdata(pctldev);\r\nu300_pmx_endisable(upmx, selector, false);\r\n}\r\nstatic int u300_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(u300_pmx_functions);\r\n}\r\nstatic const char *u300_pmx_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nreturn u300_pmx_functions[selector].name;\r\n}\r\nstatic int u300_pmx_get_groups(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\n*groups = u300_pmx_functions[selector].groups;\r\n*num_groups = u300_pmx_functions[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic int u300_pin_config_get(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *config)\r\n{\r\nstruct pinctrl_gpio_range *range =\r\npinctrl_find_gpio_range_from_pin(pctldev, pin);\r\nif (!range)\r\nreturn -ENOTSUPP;\r\nreturn u300_gpio_config_get(range->gc,\r\n(pin - range->pin_base + range->base),\r\nconfig);\r\n}\r\nstatic int u300_pin_config_set(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstruct pinctrl_gpio_range *range =\r\npinctrl_find_gpio_range_from_pin(pctldev, pin);\r\nint ret, i;\r\nif (!range)\r\nreturn -EINVAL;\r\nfor (i = 0; i < num_configs; i++) {\r\nret = u300_gpio_config_set(range->gc,\r\n(pin - range->pin_base + range->base),\r\npinconf_to_config_param(configs[i]));\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int u300_pmx_probe(struct platform_device *pdev)\r\n{\r\nstruct u300_pmx *upmx;\r\nstruct resource *res;\r\nupmx = devm_kzalloc(&pdev->dev, sizeof(*upmx), GFP_KERNEL);\r\nif (!upmx)\r\nreturn -ENOMEM;\r\nupmx->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nupmx->virtbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(upmx->virtbase))\r\nreturn PTR_ERR(upmx->virtbase);\r\nupmx->pctl = pinctrl_register(&u300_pmx_desc, &pdev->dev, upmx);\r\nif (!upmx->pctl) {\r\ndev_err(&pdev->dev, "could not register U300 pinmux driver\n");\r\nreturn -EINVAL;\r\n}\r\nplatform_set_drvdata(pdev, upmx);\r\ndev_info(&pdev->dev, "initialized U300 pin control driver\n");\r\nreturn 0;\r\n}\r\nstatic int u300_pmx_remove(struct platform_device *pdev)\r\n{\r\nstruct u300_pmx *upmx = platform_get_drvdata(pdev);\r\npinctrl_unregister(upmx->pctl);\r\nreturn 0;\r\n}\r\nstatic int __init u300_pmx_init(void)\r\n{\r\nreturn platform_driver_register(&u300_pmx_driver);\r\n}\r\nstatic void __exit u300_pmx_exit(void)\r\n{\r\nplatform_driver_unregister(&u300_pmx_driver);\r\n}
