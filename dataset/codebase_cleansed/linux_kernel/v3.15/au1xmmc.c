static inline int has_dbdma(void)\r\n{\r\nswitch (alchemy_get_cputype()) {\r\ncase ALCHEMY_CPU_AU1200:\r\ncase ALCHEMY_CPU_AU1300:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline void IRQ_ON(struct au1xmmc_host *host, u32 mask)\r\n{\r\nu32 val = au_readl(HOST_CONFIG(host));\r\nval |= mask;\r\nau_writel(val, HOST_CONFIG(host));\r\nau_sync();\r\n}\r\nstatic inline void FLUSH_FIFO(struct au1xmmc_host *host)\r\n{\r\nu32 val = au_readl(HOST_CONFIG2(host));\r\nau_writel(val | SD_CONFIG2_FF, HOST_CONFIG2(host));\r\nau_sync_delay(1);\r\nval &= ~SD_CONFIG2_DF;\r\nau_writel(val, HOST_CONFIG2(host));\r\nau_sync();\r\n}\r\nstatic inline void IRQ_OFF(struct au1xmmc_host *host, u32 mask)\r\n{\r\nu32 val = au_readl(HOST_CONFIG(host));\r\nval &= ~mask;\r\nau_writel(val, HOST_CONFIG(host));\r\nau_sync();\r\n}\r\nstatic inline void SEND_STOP(struct au1xmmc_host *host)\r\n{\r\nu32 config2;\r\nWARN_ON(host->status != HOST_S_DATA);\r\nhost->status = HOST_S_STOP;\r\nconfig2 = au_readl(HOST_CONFIG2(host));\r\nau_writel(config2 | SD_CONFIG2_DF, HOST_CONFIG2(host));\r\nau_sync();\r\nau_writel(STOP_CMD, HOST_CMD(host));\r\n}\r\nstatic void au1xmmc_set_power(struct au1xmmc_host *host, int state)\r\n{\r\nif (host->platdata && host->platdata->set_power)\r\nhost->platdata->set_power(host->mmc, state);\r\n}\r\nstatic int au1xmmc_card_inserted(struct mmc_host *mmc)\r\n{\r\nstruct au1xmmc_host *host = mmc_priv(mmc);\r\nif (host->platdata && host->platdata->card_inserted)\r\nreturn !!host->platdata->card_inserted(host->mmc);\r\nreturn -ENOSYS;\r\n}\r\nstatic int au1xmmc_card_readonly(struct mmc_host *mmc)\r\n{\r\nstruct au1xmmc_host *host = mmc_priv(mmc);\r\nif (host->platdata && host->platdata->card_readonly)\r\nreturn !!host->platdata->card_readonly(mmc);\r\nreturn -ENOSYS;\r\n}\r\nstatic void au1xmmc_finish_request(struct au1xmmc_host *host)\r\n{\r\nstruct mmc_request *mrq = host->mrq;\r\nhost->mrq = NULL;\r\nhost->flags &= HOST_F_ACTIVE | HOST_F_DMA;\r\nhost->dma.len = 0;\r\nhost->dma.dir = 0;\r\nhost->pio.index = 0;\r\nhost->pio.offset = 0;\r\nhost->pio.len = 0;\r\nhost->status = HOST_S_IDLE;\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic void au1xmmc_tasklet_finish(unsigned long param)\r\n{\r\nstruct au1xmmc_host *host = (struct au1xmmc_host *) param;\r\nau1xmmc_finish_request(host);\r\n}\r\nstatic int au1xmmc_send_command(struct au1xmmc_host *host, int wait,\r\nstruct mmc_command *cmd, struct mmc_data *data)\r\n{\r\nu32 mmccmd = (cmd->opcode << SD_CMD_CI_SHIFT);\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_NONE:\r\nbreak;\r\ncase MMC_RSP_R1:\r\nmmccmd |= SD_CMD_RT_1;\r\nbreak;\r\ncase MMC_RSP_R1B:\r\nmmccmd |= SD_CMD_RT_1B;\r\nbreak;\r\ncase MMC_RSP_R2:\r\nmmccmd |= SD_CMD_RT_2;\r\nbreak;\r\ncase MMC_RSP_R3:\r\nmmccmd |= SD_CMD_RT_3;\r\nbreak;\r\ndefault:\r\npr_info("au1xmmc: unhandled response type %02x\n",\r\nmmc_resp_type(cmd));\r\nreturn -EINVAL;\r\n}\r\nif (data) {\r\nif (data->flags & MMC_DATA_READ) {\r\nif (data->blocks > 1)\r\nmmccmd |= SD_CMD_CT_4;\r\nelse\r\nmmccmd |= SD_CMD_CT_2;\r\n} else if (data->flags & MMC_DATA_WRITE) {\r\nif (data->blocks > 1)\r\nmmccmd |= SD_CMD_CT_3;\r\nelse\r\nmmccmd |= SD_CMD_CT_1;\r\n}\r\n}\r\nau_writel(cmd->arg, HOST_CMDARG(host));\r\nau_sync();\r\nif (wait)\r\nIRQ_OFF(host, SD_CONFIG_CR);\r\nau_writel((mmccmd | SD_CMD_GO), HOST_CMD(host));\r\nau_sync();\r\nwhile (au_readl(HOST_CMD(host)) & SD_CMD_GO)\r\n;\r\nif (wait) {\r\nu32 status = au_readl(HOST_STATUS(host));\r\nwhile (!(status & SD_STATUS_CR))\r\nstatus = au_readl(HOST_STATUS(host));\r\nau_writel(SD_STATUS_CR, HOST_STATUS(host));\r\nIRQ_ON(host, SD_CONFIG_CR);\r\n}\r\nreturn 0;\r\n}\r\nstatic void au1xmmc_data_complete(struct au1xmmc_host *host, u32 status)\r\n{\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mmc_data *data;\r\nu32 crc;\r\nWARN_ON((host->status != HOST_S_DATA) && (host->status != HOST_S_STOP));\r\nif (host->mrq == NULL)\r\nreturn;\r\ndata = mrq->cmd->data;\r\nif (status == 0)\r\nstatus = au_readl(HOST_STATUS(host));\r\nwhile ((host->flags & HOST_F_XMIT) && (status & SD_STATUS_DB))\r\nstatus = au_readl(HOST_STATUS(host));\r\ndata->error = 0;\r\ndma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len, host->dma.dir);\r\ncrc = (status & (SD_STATUS_WC | SD_STATUS_RC));\r\nif (host->flags & HOST_F_XMIT)\r\ncrc |= ((status & 0x07) == 0x02) ? 0 : 1;\r\nif (crc)\r\ndata->error = -EILSEQ;\r\nau_writel(SD_STATUS_WC | SD_STATUS_RC, HOST_STATUS(host));\r\ndata->bytes_xfered = 0;\r\nif (!data->error) {\r\nif (host->flags & (HOST_F_DMA | HOST_F_DBDMA)) {\r\nu32 chan = DMA_CHANNEL(host);\r\nchan_tab_t *c = *((chan_tab_t **)chan);\r\nau1x_dma_chan_t *cp = c->chan_ptr;\r\ndata->bytes_xfered = cp->ddma_bytecnt;\r\n} else\r\ndata->bytes_xfered =\r\n(data->blocks * data->blksz) - host->pio.len;\r\n}\r\nau1xmmc_finish_request(host);\r\n}\r\nstatic void au1xmmc_tasklet_data(unsigned long param)\r\n{\r\nstruct au1xmmc_host *host = (struct au1xmmc_host *)param;\r\nu32 status = au_readl(HOST_STATUS(host));\r\nau1xmmc_data_complete(host, status);\r\n}\r\nstatic void au1xmmc_send_pio(struct au1xmmc_host *host)\r\n{\r\nstruct mmc_data *data;\r\nint sg_len, max, count;\r\nunsigned char *sg_ptr, val;\r\nu32 status;\r\nstruct scatterlist *sg;\r\ndata = host->mrq->data;\r\nif (!(host->flags & HOST_F_XMIT))\r\nreturn;\r\nsg = &data->sg[host->pio.index];\r\nsg_ptr = sg_virt(sg) + host->pio.offset;\r\nsg_len = data->sg[host->pio.index].length - host->pio.offset;\r\nmax = (sg_len > host->pio.len) ? host->pio.len : sg_len;\r\nif (max > AU1XMMC_MAX_TRANSFER)\r\nmax = AU1XMMC_MAX_TRANSFER;\r\nfor (count = 0; count < max; count++) {\r\nstatus = au_readl(HOST_STATUS(host));\r\nif (!(status & SD_STATUS_TH))\r\nbreak;\r\nval = *sg_ptr++;\r\nau_writel((unsigned long)val, HOST_TXPORT(host));\r\nau_sync();\r\n}\r\nhost->pio.len -= count;\r\nhost->pio.offset += count;\r\nif (count == sg_len) {\r\nhost->pio.index++;\r\nhost->pio.offset = 0;\r\n}\r\nif (host->pio.len == 0) {\r\nIRQ_OFF(host, SD_CONFIG_TH);\r\nif (host->flags & HOST_F_STOP)\r\nSEND_STOP(host);\r\ntasklet_schedule(&host->data_task);\r\n}\r\n}\r\nstatic void au1xmmc_receive_pio(struct au1xmmc_host *host)\r\n{\r\nstruct mmc_data *data;\r\nint max, count, sg_len = 0;\r\nunsigned char *sg_ptr = NULL;\r\nu32 status, val;\r\nstruct scatterlist *sg;\r\ndata = host->mrq->data;\r\nif (!(host->flags & HOST_F_RECV))\r\nreturn;\r\nmax = host->pio.len;\r\nif (host->pio.index < host->dma.len) {\r\nsg = &data->sg[host->pio.index];\r\nsg_ptr = sg_virt(sg) + host->pio.offset;\r\nsg_len = sg_dma_len(&data->sg[host->pio.index]) - host->pio.offset;\r\nif (sg_len < max)\r\nmax = sg_len;\r\n}\r\nif (max > AU1XMMC_MAX_TRANSFER)\r\nmax = AU1XMMC_MAX_TRANSFER;\r\nfor (count = 0; count < max; count++) {\r\nstatus = au_readl(HOST_STATUS(host));\r\nif (!(status & SD_STATUS_NE))\r\nbreak;\r\nif (status & SD_STATUS_RC) {\r\nDBG("RX CRC Error [%d + %d].\n", host->pdev->id,\r\nhost->pio.len, count);\r\nbreak;\r\n}\r\nif (status & SD_STATUS_RO) {\r\nDBG("RX Overrun [%d + %d]\n", host->pdev->id,\r\nhost->pio.len, count);\r\nbreak;\r\n}\r\nelse if (status & SD_STATUS_RU) {\r\nDBG("RX Underrun [%d + %d]\n", host->pdev->id,\r\nhost->pio.len, count);\r\nbreak;\r\n}\r\nval = au_readl(HOST_RXPORT(host));\r\nif (sg_ptr)\r\n*sg_ptr++ = (unsigned char)(val & 0xFF);\r\n}\r\nhost->pio.len -= count;\r\nhost->pio.offset += count;\r\nif (sg_len && count == sg_len) {\r\nhost->pio.index++;\r\nhost->pio.offset = 0;\r\n}\r\nif (host->pio.len == 0) {\r\nIRQ_OFF(host, SD_CONFIG_NE);\r\nif (host->flags & HOST_F_STOP)\r\nSEND_STOP(host);\r\ntasklet_schedule(&host->data_task);\r\n}\r\n}\r\nstatic void au1xmmc_cmd_complete(struct au1xmmc_host *host, u32 status)\r\n{\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mmc_command *cmd;\r\nu32 r[4];\r\nint i, trans;\r\nif (!host->mrq)\r\nreturn;\r\ncmd = mrq->cmd;\r\ncmd->error = 0;\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136) {\r\nr[0] = au_readl(host->iobase + SD_RESP3);\r\nr[1] = au_readl(host->iobase + SD_RESP2);\r\nr[2] = au_readl(host->iobase + SD_RESP1);\r\nr[3] = au_readl(host->iobase + SD_RESP0);\r\nfor (i = 0; i < 4; i++) {\r\ncmd->resp[i] = (r[i] & 0x00FFFFFF) << 8;\r\nif (i != 3)\r\ncmd->resp[i] |= (r[i + 1] & 0xFF000000) >> 24;\r\n}\r\n} else {\r\ncmd->resp[0] = au_readl(host->iobase + SD_RESP0);\r\n}\r\n}\r\nif (status & (SD_STATUS_SC | SD_STATUS_WC | SD_STATUS_RC))\r\ncmd->error = -EILSEQ;\r\ntrans = host->flags & (HOST_F_XMIT | HOST_F_RECV);\r\nif (!trans || cmd->error) {\r\nIRQ_OFF(host, SD_CONFIG_TH | SD_CONFIG_RA | SD_CONFIG_RF);\r\ntasklet_schedule(&host->finish_task);\r\nreturn;\r\n}\r\nhost->status = HOST_S_DATA;\r\nif ((host->flags & (HOST_F_DMA | HOST_F_DBDMA))) {\r\nu32 channel = DMA_CHANNEL(host);\r\nif (host->flags & HOST_F_RECV) {\r\nu32 mask = SD_STATUS_DB | SD_STATUS_NE;\r\nwhile((status & mask) != mask)\r\nstatus = au_readl(HOST_STATUS(host));\r\n}\r\nau1xxx_dbdma_start(channel);\r\n}\r\n}\r\nstatic void au1xmmc_set_clock(struct au1xmmc_host *host, int rate)\r\n{\r\nunsigned int pbus = get_au1x00_speed();\r\nunsigned int divisor;\r\nu32 config;\r\npbus /= ((au_readl(SYS_POWERCTRL) & 0x3) + 2);\r\npbus /= 2;\r\ndivisor = ((pbus / rate) / 2) - 1;\r\nconfig = au_readl(HOST_CONFIG(host));\r\nconfig &= ~(SD_CONFIG_DIV);\r\nconfig |= (divisor & SD_CONFIG_DIV) | SD_CONFIG_DE;\r\nau_writel(config, HOST_CONFIG(host));\r\nau_sync();\r\n}\r\nstatic int au1xmmc_prepare_data(struct au1xmmc_host *host,\r\nstruct mmc_data *data)\r\n{\r\nint datalen = data->blocks * data->blksz;\r\nif (data->flags & MMC_DATA_READ)\r\nhost->flags |= HOST_F_RECV;\r\nelse\r\nhost->flags |= HOST_F_XMIT;\r\nif (host->mrq->stop)\r\nhost->flags |= HOST_F_STOP;\r\nhost->dma.dir = DMA_BIDIRECTIONAL;\r\nhost->dma.len = dma_map_sg(mmc_dev(host->mmc), data->sg,\r\ndata->sg_len, host->dma.dir);\r\nif (host->dma.len == 0)\r\nreturn -ETIMEDOUT;\r\nau_writel(data->blksz - 1, HOST_BLKSIZE(host));\r\nif (host->flags & (HOST_F_DMA | HOST_F_DBDMA)) {\r\nint i;\r\nu32 channel = DMA_CHANNEL(host);\r\nau1xxx_dbdma_stop(channel);\r\nfor (i = 0; i < host->dma.len; i++) {\r\nu32 ret = 0, flags = DDMA_FLAGS_NOIE;\r\nstruct scatterlist *sg = &data->sg[i];\r\nint sg_len = sg->length;\r\nint len = (datalen > sg_len) ? sg_len : datalen;\r\nif (i == host->dma.len - 1)\r\nflags = DDMA_FLAGS_IE;\r\nif (host->flags & HOST_F_XMIT) {\r\nret = au1xxx_dbdma_put_source(channel,\r\nsg_phys(sg), len, flags);\r\n} else {\r\nret = au1xxx_dbdma_put_dest(channel,\r\nsg_phys(sg), len, flags);\r\n}\r\nif (!ret)\r\ngoto dataerr;\r\ndatalen -= len;\r\n}\r\n} else {\r\nhost->pio.index = 0;\r\nhost->pio.offset = 0;\r\nhost->pio.len = datalen;\r\nif (host->flags & HOST_F_XMIT)\r\nIRQ_ON(host, SD_CONFIG_TH);\r\nelse\r\nIRQ_ON(host, SD_CONFIG_NE);\r\n}\r\nreturn 0;\r\ndataerr:\r\ndma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\r\nhost->dma.dir);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void au1xmmc_request(struct mmc_host* mmc, struct mmc_request* mrq)\r\n{\r\nstruct au1xmmc_host *host = mmc_priv(mmc);\r\nint ret = 0;\r\nWARN_ON(irqs_disabled());\r\nWARN_ON(host->status != HOST_S_IDLE);\r\nhost->mrq = mrq;\r\nhost->status = HOST_S_CMD;\r\nif (0 == au1xmmc_card_inserted(mmc)) {\r\nmrq->cmd->error = -ENOMEDIUM;\r\nau1xmmc_finish_request(host);\r\nreturn;\r\n}\r\nif (mrq->data) {\r\nFLUSH_FIFO(host);\r\nret = au1xmmc_prepare_data(host, mrq->data);\r\n}\r\nif (!ret)\r\nret = au1xmmc_send_command(host, 0, mrq->cmd, mrq->data);\r\nif (ret) {\r\nmrq->cmd->error = ret;\r\nau1xmmc_finish_request(host);\r\n}\r\n}\r\nstatic void au1xmmc_reset_controller(struct au1xmmc_host *host)\r\n{\r\nau_writel(SD_ENABLE_CE, HOST_ENABLE(host));\r\nau_sync_delay(1);\r\nau_writel(SD_ENABLE_R | SD_ENABLE_CE, HOST_ENABLE(host));\r\nau_sync_delay(5);\r\nau_writel(~0, HOST_STATUS(host));\r\nau_sync();\r\nau_writel(0, HOST_BLKSIZE(host));\r\nau_writel(0x001fffff, HOST_TIMEOUT(host));\r\nau_sync();\r\nau_writel(SD_CONFIG2_EN, HOST_CONFIG2(host));\r\nau_sync();\r\nau_writel(SD_CONFIG2_EN | SD_CONFIG2_FF, HOST_CONFIG2(host));\r\nau_sync_delay(1);\r\nau_writel(SD_CONFIG2_EN, HOST_CONFIG2(host));\r\nau_sync();\r\nau_writel(AU1XMMC_INTERRUPTS, HOST_CONFIG(host));\r\nau_sync();\r\n}\r\nstatic void au1xmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct au1xmmc_host *host = mmc_priv(mmc);\r\nu32 config2;\r\nif (ios->power_mode == MMC_POWER_OFF)\r\nau1xmmc_set_power(host, 0);\r\nelse if (ios->power_mode == MMC_POWER_ON) {\r\nau1xmmc_set_power(host, 1);\r\n}\r\nif (ios->clock && ios->clock != host->clock) {\r\nau1xmmc_set_clock(host, ios->clock);\r\nhost->clock = ios->clock;\r\n}\r\nconfig2 = au_readl(HOST_CONFIG2(host));\r\nswitch (ios->bus_width) {\r\ncase MMC_BUS_WIDTH_8:\r\nconfig2 |= SD_CONFIG2_BB;\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nconfig2 &= ~SD_CONFIG2_BB;\r\nconfig2 |= SD_CONFIG2_WB;\r\nbreak;\r\ncase MMC_BUS_WIDTH_1:\r\nconfig2 &= ~(SD_CONFIG2_WB | SD_CONFIG2_BB);\r\nbreak;\r\n}\r\nau_writel(config2, HOST_CONFIG2(host));\r\nau_sync();\r\n}\r\nstatic irqreturn_t au1xmmc_irq(int irq, void *dev_id)\r\n{\r\nstruct au1xmmc_host *host = dev_id;\r\nu32 status;\r\nstatus = au_readl(HOST_STATUS(host));\r\nif (!(status & SD_STATUS_I))\r\nreturn IRQ_NONE;\r\nif (status & SD_STATUS_SI)\r\nmmc_signal_sdio_irq(host->mmc);\r\nif (host->mrq && (status & STATUS_TIMEOUT)) {\r\nif (status & SD_STATUS_RAT)\r\nhost->mrq->cmd->error = -ETIMEDOUT;\r\nelse if (status & SD_STATUS_DT)\r\nhost->mrq->data->error = -ETIMEDOUT;\r\nIRQ_OFF(host, SD_CONFIG_NE | SD_CONFIG_TH);\r\ntasklet_schedule(&host->finish_task);\r\n}\r\n#if 0\r\nelse if (status & SD_STATUS_DD) {\r\nif (!(host->flags & HOST_F_DMA) && (status & SD_STATUS_NE))\r\nau1xmmc_receive_pio(host);\r\nelse {\r\nau1xmmc_data_complete(host, status);\r\n}\r\n}\r\n#endif\r\nelse if (status & SD_STATUS_CR) {\r\nif (host->status == HOST_S_CMD)\r\nau1xmmc_cmd_complete(host, status);\r\n} else if (!(host->flags & HOST_F_DMA)) {\r\nif ((host->flags & HOST_F_XMIT) && (status & STATUS_DATA_OUT))\r\nau1xmmc_send_pio(host);\r\nelse if ((host->flags & HOST_F_RECV) && (status & STATUS_DATA_IN))\r\nau1xmmc_receive_pio(host);\r\n} else if (status & 0x203F3C70) {\r\nDBG("Unhandled status %8.8x\n", host->pdev->id,\r\nstatus);\r\n}\r\nau_writel(status, HOST_STATUS(host));\r\nau_sync();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void au1xmmc_dbdma_callback(int irq, void *dev_id)\r\n{\r\nstruct au1xmmc_host *host = (struct au1xmmc_host *)dev_id;\r\nif (!host->mrq)\r\nreturn;\r\nif (host->flags & HOST_F_STOP)\r\nSEND_STOP(host);\r\ntasklet_schedule(&host->data_task);\r\n}\r\nstatic int au1xmmc_dbdma_init(struct au1xmmc_host *host)\r\n{\r\nstruct resource *res;\r\nint txid, rxid;\r\nres = platform_get_resource(host->pdev, IORESOURCE_DMA, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\ntxid = res->start;\r\nres = platform_get_resource(host->pdev, IORESOURCE_DMA, 1);\r\nif (!res)\r\nreturn -ENODEV;\r\nrxid = res->start;\r\nif (!memid)\r\nreturn -ENODEV;\r\nhost->tx_chan = au1xxx_dbdma_chan_alloc(memid, txid,\r\nau1xmmc_dbdma_callback, (void *)host);\r\nif (!host->tx_chan) {\r\ndev_err(&host->pdev->dev, "cannot allocate TX DMA\n");\r\nreturn -ENODEV;\r\n}\r\nhost->rx_chan = au1xxx_dbdma_chan_alloc(rxid, memid,\r\nau1xmmc_dbdma_callback, (void *)host);\r\nif (!host->rx_chan) {\r\ndev_err(&host->pdev->dev, "cannot allocate RX DMA\n");\r\nau1xxx_dbdma_chan_free(host->tx_chan);\r\nreturn -ENODEV;\r\n}\r\nau1xxx_dbdma_set_devwidth(host->tx_chan, 8);\r\nau1xxx_dbdma_set_devwidth(host->rx_chan, 8);\r\nau1xxx_dbdma_ring_alloc(host->tx_chan, AU1XMMC_DESCRIPTOR_COUNT);\r\nau1xxx_dbdma_ring_alloc(host->rx_chan, AU1XMMC_DESCRIPTOR_COUNT);\r\nhost->flags |= HOST_F_DMA | HOST_F_DBDMA;\r\nreturn 0;\r\n}\r\nstatic void au1xmmc_dbdma_shutdown(struct au1xmmc_host *host)\r\n{\r\nif (host->flags & HOST_F_DMA) {\r\nhost->flags &= ~HOST_F_DMA;\r\nau1xxx_dbdma_chan_free(host->tx_chan);\r\nau1xxx_dbdma_chan_free(host->rx_chan);\r\n}\r\n}\r\nstatic void au1xmmc_enable_sdio_irq(struct mmc_host *mmc, int en)\r\n{\r\nstruct au1xmmc_host *host = mmc_priv(mmc);\r\nif (en)\r\nIRQ_ON(host, SD_CONFIG_SI);\r\nelse\r\nIRQ_OFF(host, SD_CONFIG_SI);\r\n}\r\nstatic int au1xmmc_probe(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct au1xmmc_host *host;\r\nstruct resource *r;\r\nint ret, iflag;\r\nmmc = mmc_alloc_host(sizeof(struct au1xmmc_host), &pdev->dev);\r\nif (!mmc) {\r\ndev_err(&pdev->dev, "no memory for mmc_host\n");\r\nret = -ENOMEM;\r\ngoto out0;\r\n}\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->platdata = pdev->dev.platform_data;\r\nhost->pdev = pdev;\r\nret = -ENODEV;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "no mmio defined\n");\r\ngoto out1;\r\n}\r\nhost->ioarea = request_mem_region(r->start, resource_size(r),\r\npdev->name);\r\nif (!host->ioarea) {\r\ndev_err(&pdev->dev, "mmio already in use\n");\r\ngoto out1;\r\n}\r\nhost->iobase = (unsigned long)ioremap(r->start, 0x3c);\r\nif (!host->iobase) {\r\ndev_err(&pdev->dev, "cannot remap mmio\n");\r\ngoto out2;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "no IRQ defined\n");\r\ngoto out3;\r\n}\r\nhost->irq = r->start;\r\nmmc->ops = &au1xmmc_ops;\r\nmmc->f_min = 450000;\r\nmmc->f_max = 24000000;\r\nmmc->max_blk_size = 2048;\r\nmmc->max_blk_count = 512;\r\nmmc->ocr_avail = AU1XMMC_OCR;\r\nmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;\r\nmmc->max_segs = AU1XMMC_DESCRIPTOR_COUNT;\r\niflag = IRQF_SHARED;\r\nswitch (alchemy_get_cputype()) {\r\ncase ALCHEMY_CPU_AU1100:\r\nmmc->max_seg_size = AU1100_MMC_DESCRIPTOR_SIZE;\r\nbreak;\r\ncase ALCHEMY_CPU_AU1200:\r\nmmc->max_seg_size = AU1200_MMC_DESCRIPTOR_SIZE;\r\nbreak;\r\ncase ALCHEMY_CPU_AU1300:\r\niflag = 0;\r\nmmc->max_seg_size = AU1200_MMC_DESCRIPTOR_SIZE;\r\nmmc->f_max = 52000000;\r\nif (host->ioarea->start == AU1100_SD0_PHYS_ADDR)\r\nmmc->caps |= MMC_CAP_8_BIT_DATA;\r\nbreak;\r\n}\r\nret = request_irq(host->irq, au1xmmc_irq, iflag, DRIVER_NAME, host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot grab IRQ\n");\r\ngoto out3;\r\n}\r\nhost->status = HOST_S_IDLE;\r\nif (host->platdata && host->platdata->cd_setup) {\r\nret = host->platdata->cd_setup(mmc, 1);\r\nif (ret) {\r\ndev_warn(&pdev->dev, "board CD setup failed\n");\r\nmmc->caps |= MMC_CAP_NEEDS_POLL;\r\n}\r\n} else\r\nmmc->caps |= MMC_CAP_NEEDS_POLL;\r\nif (host->platdata)\r\nmmc->caps &= ~(host->platdata->mask_host_caps);\r\ntasklet_init(&host->data_task, au1xmmc_tasklet_data,\r\n(unsigned long)host);\r\ntasklet_init(&host->finish_task, au1xmmc_tasklet_finish,\r\n(unsigned long)host);\r\nif (has_dbdma()) {\r\nret = au1xmmc_dbdma_init(host);\r\nif (ret)\r\npr_info(DRIVER_NAME ": DBDMA init failed; using PIO\n");\r\n}\r\n#ifdef CONFIG_LEDS_CLASS\r\nif (host->platdata && host->platdata->led) {\r\nstruct led_classdev *led = host->platdata->led;\r\nled->name = mmc_hostname(mmc);\r\nled->brightness = LED_OFF;\r\nled->default_trigger = mmc_hostname(mmc);\r\nret = led_classdev_register(mmc_dev(mmc), led);\r\nif (ret)\r\ngoto out5;\r\n}\r\n#endif\r\nau1xmmc_reset_controller(host);\r\nret = mmc_add_host(mmc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot add mmc host\n");\r\ngoto out6;\r\n}\r\nplatform_set_drvdata(pdev, host);\r\npr_info(DRIVER_NAME ": MMC Controller %d set up at %8.8X"\r\n" (mode=%s)\n", pdev->id, host->iobase,\r\nhost->flags & HOST_F_DMA ? "dma" : "pio");\r\nreturn 0;\r\nout6:\r\n#ifdef CONFIG_LEDS_CLASS\r\nif (host->platdata && host->platdata->led)\r\nled_classdev_unregister(host->platdata->led);\r\nout5:\r\n#endif\r\nau_writel(0, HOST_ENABLE(host));\r\nau_writel(0, HOST_CONFIG(host));\r\nau_writel(0, HOST_CONFIG2(host));\r\nau_sync();\r\nif (host->flags & HOST_F_DBDMA)\r\nau1xmmc_dbdma_shutdown(host);\r\ntasklet_kill(&host->data_task);\r\ntasklet_kill(&host->finish_task);\r\nif (host->platdata && host->platdata->cd_setup &&\r\n!(mmc->caps & MMC_CAP_NEEDS_POLL))\r\nhost->platdata->cd_setup(mmc, 0);\r\nfree_irq(host->irq, host);\r\nout3:\r\niounmap((void *)host->iobase);\r\nout2:\r\nrelease_resource(host->ioarea);\r\nkfree(host->ioarea);\r\nout1:\r\nmmc_free_host(mmc);\r\nout0:\r\nreturn ret;\r\n}\r\nstatic int au1xmmc_remove(struct platform_device *pdev)\r\n{\r\nstruct au1xmmc_host *host = platform_get_drvdata(pdev);\r\nif (host) {\r\nmmc_remove_host(host->mmc);\r\n#ifdef CONFIG_LEDS_CLASS\r\nif (host->platdata && host->platdata->led)\r\nled_classdev_unregister(host->platdata->led);\r\n#endif\r\nif (host->platdata && host->platdata->cd_setup &&\r\n!(host->mmc->caps & MMC_CAP_NEEDS_POLL))\r\nhost->platdata->cd_setup(host->mmc, 0);\r\nau_writel(0, HOST_ENABLE(host));\r\nau_writel(0, HOST_CONFIG(host));\r\nau_writel(0, HOST_CONFIG2(host));\r\nau_sync();\r\ntasklet_kill(&host->data_task);\r\ntasklet_kill(&host->finish_task);\r\nif (host->flags & HOST_F_DBDMA)\r\nau1xmmc_dbdma_shutdown(host);\r\nau1xmmc_set_power(host, 0);\r\nfree_irq(host->irq, host);\r\niounmap((void *)host->iobase);\r\nrelease_resource(host->ioarea);\r\nkfree(host->ioarea);\r\nmmc_free_host(host->mmc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int au1xmmc_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct au1xmmc_host *host = platform_get_drvdata(pdev);\r\nau_writel(0, HOST_CONFIG2(host));\r\nau_writel(0, HOST_CONFIG(host));\r\nau_writel(0xffffffff, HOST_STATUS(host));\r\nau_writel(0, HOST_ENABLE(host));\r\nau_sync();\r\nreturn 0;\r\n}\r\nstatic int au1xmmc_resume(struct platform_device *pdev)\r\n{\r\nstruct au1xmmc_host *host = platform_get_drvdata(pdev);\r\nau1xmmc_reset_controller(host);\r\nreturn 0;\r\n}\r\nstatic int __init au1xmmc_init(void)\r\n{\r\nif (has_dbdma()) {\r\nmemid = au1xxx_ddma_add_device(&au1xmmc_mem_dbdev);\r\nif (!memid)\r\npr_err("au1xmmc: cannot add memory dbdma\n");\r\n}\r\nreturn platform_driver_register(&au1xmmc_driver);\r\n}\r\nstatic void __exit au1xmmc_exit(void)\r\n{\r\nif (has_dbdma() && memid)\r\nau1xxx_ddma_del_device(memid);\r\nplatform_driver_unregister(&au1xmmc_driver);\r\n}
