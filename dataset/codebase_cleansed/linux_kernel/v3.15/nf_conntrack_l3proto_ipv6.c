static bool ipv6_pkt_to_tuple(const struct sk_buff *skb, unsigned int nhoff,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nconst u_int32_t *ap;\r\nu_int32_t _addrs[8];\r\nap = skb_header_pointer(skb, nhoff + offsetof(struct ipv6hdr, saddr),\r\nsizeof(_addrs), _addrs);\r\nif (ap == NULL)\r\nreturn false;\r\nmemcpy(tuple->src.u3.ip6, ap, sizeof(tuple->src.u3.ip6));\r\nmemcpy(tuple->dst.u3.ip6, ap + 4, sizeof(tuple->dst.u3.ip6));\r\nreturn true;\r\n}\r\nstatic bool ipv6_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\nmemcpy(tuple->src.u3.ip6, orig->dst.u3.ip6, sizeof(tuple->src.u3.ip6));\r\nmemcpy(tuple->dst.u3.ip6, orig->src.u3.ip6, sizeof(tuple->dst.u3.ip6));\r\nreturn true;\r\n}\r\nstatic int ipv6_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nreturn seq_printf(s, "src=%pI6 dst=%pI6 ",\r\ntuple->src.u3.ip6, tuple->dst.u3.ip6);\r\n}\r\nstatic int ipv6_get_l4proto(const struct sk_buff *skb, unsigned int nhoff,\r\nunsigned int *dataoff, u_int8_t *protonum)\r\n{\r\nunsigned int extoff = nhoff + sizeof(struct ipv6hdr);\r\n__be16 frag_off;\r\nint protoff;\r\nu8 nexthdr;\r\nif (skb_copy_bits(skb, nhoff + offsetof(struct ipv6hdr, nexthdr),\r\n&nexthdr, sizeof(nexthdr)) != 0) {\r\npr_debug("ip6_conntrack_core: can't get nexthdr\n");\r\nreturn -NF_ACCEPT;\r\n}\r\nprotoff = ipv6_skip_exthdr(skb, extoff, &nexthdr, &frag_off);\r\nif (protoff < 0 || (frag_off & htons(~0x7)) != 0) {\r\npr_debug("ip6_conntrack_core: can't find proto in pkt\n");\r\nreturn -NF_ACCEPT;\r\n}\r\n*dataoff = protoff;\r\n*protonum = nexthdr;\r\nreturn NF_ACCEPT;\r\n}\r\nstatic unsigned int ipv6_helper(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct nf_conn *ct;\r\nconst struct nf_conn_help *help;\r\nconst struct nf_conntrack_helper *helper;\r\nenum ip_conntrack_info ctinfo;\r\n__be16 frag_off;\r\nint protoff;\r\nu8 nexthdr;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (!ct || ctinfo == IP_CT_RELATED_REPLY)\r\nreturn NF_ACCEPT;\r\nhelp = nfct_help(ct);\r\nif (!help)\r\nreturn NF_ACCEPT;\r\nhelper = rcu_dereference(help->helper);\r\nif (!helper)\r\nreturn NF_ACCEPT;\r\nnexthdr = ipv6_hdr(skb)->nexthdr;\r\nprotoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr,\r\n&frag_off);\r\nif (protoff < 0 || (frag_off & htons(~0x7)) != 0) {\r\npr_debug("proto header not found\n");\r\nreturn NF_ACCEPT;\r\n}\r\nreturn helper->help(skb, protoff, ct, ctinfo);\r\n}\r\nstatic unsigned int ipv6_confirm(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nunsigned char pnum = ipv6_hdr(skb)->nexthdr;\r\nint protoff;\r\n__be16 frag_off;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (!ct || ctinfo == IP_CT_RELATED_REPLY)\r\ngoto out;\r\nprotoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &pnum,\r\n&frag_off);\r\nif (protoff < 0 || (frag_off & htons(~0x7)) != 0) {\r\npr_debug("proto header not found\n");\r\ngoto out;\r\n}\r\nif (test_bit(IPS_SEQ_ADJUST_BIT, &ct->status) &&\r\n!nf_is_loopback_packet(skb)) {\r\nif (!nf_ct_seq_adjust(skb, ct, ctinfo, protoff)) {\r\nNF_CT_STAT_INC_ATOMIC(nf_ct_net(ct), drop);\r\nreturn NF_DROP;\r\n}\r\n}\r\nout:\r\nreturn nf_conntrack_confirm(skb);\r\n}\r\nstatic unsigned int ipv6_conntrack_in(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nreturn nf_conntrack_in(dev_net(in), PF_INET6, ops->hooknum, skb);\r\n}\r\nstatic unsigned int ipv6_conntrack_local(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nif (skb->len < sizeof(struct ipv6hdr)) {\r\nnet_notice_ratelimited("ipv6_conntrack_local: packet too short\n");\r\nreturn NF_ACCEPT;\r\n}\r\nreturn nf_conntrack_in(dev_net(out), PF_INET6, ops->hooknum, skb);\r\n}\r\nstatic int\r\nipv6_getorigdst(struct sock *sk, int optval, void __user *user, int *len)\r\n{\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nconst struct ipv6_pinfo *inet6 = inet6_sk(sk);\r\nconst struct nf_conntrack_tuple_hash *h;\r\nstruct sockaddr_in6 sin6;\r\nstruct nf_conntrack_tuple tuple = { .src.l3num = NFPROTO_IPV6 };\r\nstruct nf_conn *ct;\r\ntuple.src.u3.in6 = sk->sk_v6_rcv_saddr;\r\ntuple.src.u.tcp.port = inet->inet_sport;\r\ntuple.dst.u3.in6 = sk->sk_v6_daddr;\r\ntuple.dst.u.tcp.port = inet->inet_dport;\r\ntuple.dst.protonum = sk->sk_protocol;\r\nif (sk->sk_protocol != IPPROTO_TCP && sk->sk_protocol != IPPROTO_SCTP)\r\nreturn -ENOPROTOOPT;\r\nif (*len < 0 || (unsigned int) *len < sizeof(sin6))\r\nreturn -EINVAL;\r\nh = nf_conntrack_find_get(sock_net(sk), NF_CT_DEFAULT_ZONE, &tuple);\r\nif (!h) {\r\npr_debug("IP6T_SO_ORIGINAL_DST: Can't find %pI6c/%u-%pI6c/%u.\n",\r\n&tuple.src.u3.ip6, ntohs(tuple.src.u.tcp.port),\r\n&tuple.dst.u3.ip6, ntohs(tuple.dst.u.tcp.port));\r\nreturn -ENOENT;\r\n}\r\nct = nf_ct_tuplehash_to_ctrack(h);\r\nsin6.sin6_family = AF_INET6;\r\nsin6.sin6_port = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.tcp.port;\r\nsin6.sin6_flowinfo = inet6->flow_label & IPV6_FLOWINFO_MASK;\r\nmemcpy(&sin6.sin6_addr,\r\n&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.in6,\r\nsizeof(sin6.sin6_addr));\r\nnf_ct_put(ct);\r\nsin6.sin6_scope_id = ipv6_iface_scope_id(&sin6.sin6_addr,\r\nsk->sk_bound_dev_if);\r\nreturn copy_to_user(user, &sin6, sizeof(sin6)) ? -EFAULT : 0;\r\n}\r\nstatic int ipv6_tuple_to_nlattr(struct sk_buff *skb,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nif (nla_put(skb, CTA_IP_V6_SRC, sizeof(u_int32_t) * 4,\r\n&tuple->src.u3.ip6) ||\r\nnla_put(skb, CTA_IP_V6_DST, sizeof(u_int32_t) * 4,\r\n&tuple->dst.u3.ip6))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int ipv6_nlattr_to_tuple(struct nlattr *tb[],\r\nstruct nf_conntrack_tuple *t)\r\n{\r\nif (!tb[CTA_IP_V6_SRC] || !tb[CTA_IP_V6_DST])\r\nreturn -EINVAL;\r\nmemcpy(&t->src.u3.ip6, nla_data(tb[CTA_IP_V6_SRC]),\r\nsizeof(u_int32_t) * 4);\r\nmemcpy(&t->dst.u3.ip6, nla_data(tb[CTA_IP_V6_DST]),\r\nsizeof(u_int32_t) * 4);\r\nreturn 0;\r\n}\r\nstatic int ipv6_nlattr_tuple_size(void)\r\n{\r\nreturn nla_policy_len(ipv6_nla_policy, CTA_IP_MAX + 1);\r\n}\r\nstatic int ipv6_net_init(struct net *net)\r\n{\r\nint ret = 0;\r\nret = nf_ct_l4proto_pernet_register(net, &nf_conntrack_l4proto_tcp6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_tcp6: pernet registration failed\n");\r\ngoto out;\r\n}\r\nret = nf_ct_l4proto_pernet_register(net, &nf_conntrack_l4proto_udp6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_udp6: pernet registration failed\n");\r\ngoto cleanup_tcp6;\r\n}\r\nret = nf_ct_l4proto_pernet_register(net, &nf_conntrack_l4proto_icmpv6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_icmp6: pernet registration failed\n");\r\ngoto cleanup_udp6;\r\n}\r\nret = nf_ct_l3proto_pernet_register(net, &nf_conntrack_l3proto_ipv6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv6: pernet registration failed.\n");\r\ngoto cleanup_icmpv6;\r\n}\r\nreturn 0;\r\ncleanup_icmpv6:\r\nnf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_icmpv6);\r\ncleanup_udp6:\r\nnf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_udp6);\r\ncleanup_tcp6:\r\nnf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_tcp6);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ipv6_net_exit(struct net *net)\r\n{\r\nnf_ct_l3proto_pernet_unregister(net, &nf_conntrack_l3proto_ipv6);\r\nnf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_icmpv6);\r\nnf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_udp6);\r\nnf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_tcp6);\r\n}\r\nstatic int __init nf_conntrack_l3proto_ipv6_init(void)\r\n{\r\nint ret = 0;\r\nneed_conntrack();\r\nnf_defrag_ipv6_enable();\r\nret = nf_register_sockopt(&so_getorigdst6);\r\nif (ret < 0) {\r\npr_err("Unable to register netfilter socket option\n");\r\nreturn ret;\r\n}\r\nret = register_pernet_subsys(&ipv6_net_ops);\r\nif (ret < 0)\r\ngoto cleanup_sockopt;\r\nret = nf_register_hooks(ipv6_conntrack_ops,\r\nARRAY_SIZE(ipv6_conntrack_ops));\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv6: can't register pre-routing defrag "\r\n"hook.\n");\r\ngoto cleanup_pernet;\r\n}\r\nret = nf_ct_l4proto_register(&nf_conntrack_l4proto_tcp6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv6: can't register tcp6 proto.\n");\r\ngoto cleanup_hooks;\r\n}\r\nret = nf_ct_l4proto_register(&nf_conntrack_l4proto_udp6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv6: can't register udp6 proto.\n");\r\ngoto cleanup_tcp6;\r\n}\r\nret = nf_ct_l4proto_register(&nf_conntrack_l4proto_icmpv6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv6: can't register icmpv6 proto.\n");\r\ngoto cleanup_udp6;\r\n}\r\nret = nf_ct_l3proto_register(&nf_conntrack_l3proto_ipv6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv6: can't register ipv6 proto.\n");\r\ngoto cleanup_icmpv6;\r\n}\r\nreturn ret;\r\ncleanup_icmpv6:\r\nnf_ct_l4proto_unregister(&nf_conntrack_l4proto_icmpv6);\r\ncleanup_udp6:\r\nnf_ct_l4proto_unregister(&nf_conntrack_l4proto_udp6);\r\ncleanup_tcp6:\r\nnf_ct_l4proto_unregister(&nf_conntrack_l4proto_tcp6);\r\ncleanup_hooks:\r\nnf_unregister_hooks(ipv6_conntrack_ops, ARRAY_SIZE(ipv6_conntrack_ops));\r\ncleanup_pernet:\r\nunregister_pernet_subsys(&ipv6_net_ops);\r\ncleanup_sockopt:\r\nnf_unregister_sockopt(&so_getorigdst6);\r\nreturn ret;\r\n}\r\nstatic void __exit nf_conntrack_l3proto_ipv6_fini(void)\r\n{\r\nsynchronize_net();\r\nnf_ct_l3proto_unregister(&nf_conntrack_l3proto_ipv6);\r\nnf_ct_l4proto_unregister(&nf_conntrack_l4proto_tcp6);\r\nnf_ct_l4proto_unregister(&nf_conntrack_l4proto_udp6);\r\nnf_ct_l4proto_unregister(&nf_conntrack_l4proto_icmpv6);\r\nnf_unregister_hooks(ipv6_conntrack_ops, ARRAY_SIZE(ipv6_conntrack_ops));\r\nunregister_pernet_subsys(&ipv6_net_ops);\r\nnf_unregister_sockopt(&so_getorigdst6);\r\n}
