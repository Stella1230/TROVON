static int gpio_set_irq_type(struct irq_data *d, u32 type)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mxc_gpio_port *port = gc->private;\r\nu32 bit, val;\r\nu32 gpio_idx = d->hwirq;\r\nu32 gpio = port->bgc.gc.base + gpio_idx;\r\nint edge;\r\nvoid __iomem *reg = port->base;\r\nport->both_edges &= ~(1 << gpio_idx);\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nedge = GPIO_INT_RISE_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nedge = GPIO_INT_FALL_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nif (GPIO_EDGE_SEL >= 0) {\r\nedge = GPIO_INT_BOTH_EDGES;\r\n} else {\r\nval = gpio_get_value(gpio);\r\nif (val) {\r\nedge = GPIO_INT_LOW_LEV;\r\npr_debug("mxc: set GPIO %d to low trigger\n", gpio);\r\n} else {\r\nedge = GPIO_INT_HIGH_LEV;\r\npr_debug("mxc: set GPIO %d to high trigger\n", gpio);\r\n}\r\nport->both_edges |= 1 << gpio_idx;\r\n}\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nedge = GPIO_INT_LOW_LEV;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nedge = GPIO_INT_HIGH_LEV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (GPIO_EDGE_SEL >= 0) {\r\nval = readl(port->base + GPIO_EDGE_SEL);\r\nif (edge == GPIO_INT_BOTH_EDGES)\r\nwritel(val | (1 << gpio_idx),\r\nport->base + GPIO_EDGE_SEL);\r\nelse\r\nwritel(val & ~(1 << gpio_idx),\r\nport->base + GPIO_EDGE_SEL);\r\n}\r\nif (edge != GPIO_INT_BOTH_EDGES) {\r\nreg += GPIO_ICR1 + ((gpio_idx & 0x10) >> 2);\r\nbit = gpio_idx & 0xf;\r\nval = readl(reg) & ~(0x3 << (bit << 1));\r\nwritel(val | (edge << (bit << 1)), reg);\r\n}\r\nwritel(1 << gpio_idx, port->base + GPIO_ISR);\r\nreturn 0;\r\n}\r\nstatic void mxc_flip_edge(struct mxc_gpio_port *port, u32 gpio)\r\n{\r\nvoid __iomem *reg = port->base;\r\nu32 bit, val;\r\nint edge;\r\nreg += GPIO_ICR1 + ((gpio & 0x10) >> 2);\r\nbit = gpio & 0xf;\r\nval = readl(reg);\r\nedge = (val >> (bit << 1)) & 3;\r\nval &= ~(0x3 << (bit << 1));\r\nif (edge == GPIO_INT_HIGH_LEV) {\r\nedge = GPIO_INT_LOW_LEV;\r\npr_debug("mxc: switch GPIO %d to low trigger\n", gpio);\r\n} else if (edge == GPIO_INT_LOW_LEV) {\r\nedge = GPIO_INT_HIGH_LEV;\r\npr_debug("mxc: switch GPIO %d to high trigger\n", gpio);\r\n} else {\r\npr_err("mxc: invalid configuration for GPIO %d: %x\n",\r\ngpio, edge);\r\nreturn;\r\n}\r\nwritel(val | (edge << (bit << 1)), reg);\r\n}\r\nstatic void mxc_gpio_irq_handler(struct mxc_gpio_port *port, u32 irq_stat)\r\n{\r\nwhile (irq_stat != 0) {\r\nint irqoffset = fls(irq_stat) - 1;\r\nif (port->both_edges & (1 << irqoffset))\r\nmxc_flip_edge(port, irqoffset);\r\ngeneric_handle_irq(irq_find_mapping(port->domain, irqoffset));\r\nirq_stat &= ~(1 << irqoffset);\r\n}\r\n}\r\nstatic void mx3_gpio_irq_handler(u32 irq, struct irq_desc *desc)\r\n{\r\nu32 irq_stat;\r\nstruct mxc_gpio_port *port = irq_get_handler_data(irq);\r\nstruct irq_chip *chip = irq_get_chip(irq);\r\nchained_irq_enter(chip, desc);\r\nirq_stat = readl(port->base + GPIO_ISR) & readl(port->base + GPIO_IMR);\r\nmxc_gpio_irq_handler(port, irq_stat);\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void mx2_gpio_irq_handler(u32 irq, struct irq_desc *desc)\r\n{\r\nu32 irq_msk, irq_stat;\r\nstruct mxc_gpio_port *port;\r\nstruct irq_chip *chip = irq_get_chip(irq);\r\nchained_irq_enter(chip, desc);\r\nlist_for_each_entry(port, &mxc_gpio_ports, node) {\r\nirq_msk = readl(port->base + GPIO_IMR);\r\nif (!irq_msk)\r\ncontinue;\r\nirq_stat = readl(port->base + GPIO_ISR) & irq_msk;\r\nif (irq_stat)\r\nmxc_gpio_irq_handler(port, irq_stat);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int gpio_set_wake_irq(struct irq_data *d, u32 enable)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct mxc_gpio_port *port = gc->private;\r\nu32 gpio_idx = d->hwirq;\r\nif (enable) {\r\nif (port->irq_high && (gpio_idx >= 16))\r\nenable_irq_wake(port->irq_high);\r\nelse\r\nenable_irq_wake(port->irq);\r\n} else {\r\nif (port->irq_high && (gpio_idx >= 16))\r\ndisable_irq_wake(port->irq_high);\r\nelse\r\ndisable_irq_wake(port->irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init mxc_gpio_init_gc(struct mxc_gpio_port *port, int irq_base)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\ngc = irq_alloc_generic_chip("gpio-mxc", 1, irq_base,\r\nport->base, handle_level_irq);\r\ngc->private = port;\r\nct = gc->chip_types;\r\nct->chip.irq_ack = irq_gc_ack_set_bit;\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->chip.irq_set_type = gpio_set_irq_type;\r\nct->chip.irq_set_wake = gpio_set_wake_irq;\r\nct->regs.ack = GPIO_ISR;\r\nct->regs.mask = GPIO_IMR;\r\nirq_setup_generic_chip(gc, IRQ_MSK(32), IRQ_GC_INIT_NESTED_LOCK,\r\nIRQ_NOREQUEST, 0);\r\n}\r\nstatic void mxc_gpio_get_hw(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(mxc_gpio_dt_ids, &pdev->dev);\r\nenum mxc_gpio_hwtype hwtype;\r\nif (of_id)\r\npdev->id_entry = of_id->data;\r\nhwtype = pdev->id_entry->driver_data;\r\nif (mxc_gpio_hwtype) {\r\nBUG_ON(mxc_gpio_hwtype != hwtype);\r\nreturn;\r\n}\r\nif (hwtype == IMX35_GPIO)\r\nmxc_gpio_hwdata = &imx35_gpio_hwdata;\r\nelse if (hwtype == IMX31_GPIO)\r\nmxc_gpio_hwdata = &imx31_gpio_hwdata;\r\nelse\r\nmxc_gpio_hwdata = &imx1_imx21_gpio_hwdata;\r\nmxc_gpio_hwtype = hwtype;\r\n}\r\nstatic int mxc_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nstruct mxc_gpio_port *port =\r\ncontainer_of(bgc, struct mxc_gpio_port, bgc);\r\nreturn irq_find_mapping(port->domain, offset);\r\n}\r\nstatic int mxc_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct mxc_gpio_port *port;\r\nstruct resource *iores;\r\nint irq_base;\r\nint err;\r\nmxc_gpio_get_hw(pdev);\r\nport = devm_kzalloc(&pdev->dev, sizeof(*port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nport->base = devm_ioremap_resource(&pdev->dev, iores);\r\nif (IS_ERR(port->base))\r\nreturn PTR_ERR(port->base);\r\nport->irq_high = platform_get_irq(pdev, 1);\r\nport->irq = platform_get_irq(pdev, 0);\r\nif (port->irq < 0)\r\nreturn port->irq;\r\nwritel(0, port->base + GPIO_IMR);\r\nwritel(~0, port->base + GPIO_ISR);\r\nif (mxc_gpio_hwtype == IMX21_GPIO) {\r\nirq_set_chained_handler(port->irq, mx2_gpio_irq_handler);\r\n} else {\r\nirq_set_chained_handler(port->irq, mx3_gpio_irq_handler);\r\nirq_set_handler_data(port->irq, port);\r\nif (port->irq_high > 0) {\r\nirq_set_chained_handler(port->irq_high,\r\nmx3_gpio_irq_handler);\r\nirq_set_handler_data(port->irq_high, port);\r\n}\r\n}\r\nerr = bgpio_init(&port->bgc, &pdev->dev, 4,\r\nport->base + GPIO_PSR,\r\nport->base + GPIO_DR, NULL,\r\nport->base + GPIO_GDIR, NULL, 0);\r\nif (err)\r\ngoto out_bgio;\r\nport->bgc.gc.to_irq = mxc_gpio_to_irq;\r\nport->bgc.gc.base = (pdev->id < 0) ? of_alias_get_id(np, "gpio") * 32 :\r\npdev->id * 32;\r\nerr = gpiochip_add(&port->bgc.gc);\r\nif (err)\r\ngoto out_bgpio_remove;\r\nirq_base = irq_alloc_descs(-1, 0, 32, numa_node_id());\r\nif (irq_base < 0) {\r\nerr = irq_base;\r\ngoto out_gpiochip_remove;\r\n}\r\nport->domain = irq_domain_add_legacy(np, 32, irq_base, 0,\r\n&irq_domain_simple_ops, NULL);\r\nif (!port->domain) {\r\nerr = -ENODEV;\r\ngoto out_irqdesc_free;\r\n}\r\nmxc_gpio_init_gc(port, irq_base);\r\nlist_add_tail(&port->node, &mxc_gpio_ports);\r\nreturn 0;\r\nout_irqdesc_free:\r\nirq_free_descs(irq_base, 32);\r\nout_gpiochip_remove:\r\nWARN_ON(gpiochip_remove(&port->bgc.gc) < 0);\r\nout_bgpio_remove:\r\nbgpio_remove(&port->bgc);\r\nout_bgio:\r\ndev_info(&pdev->dev, "%s failed with errno %d\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic int __init gpio_mxc_init(void)\r\n{\r\nreturn platform_driver_register(&mxc_gpio_driver);\r\n}
