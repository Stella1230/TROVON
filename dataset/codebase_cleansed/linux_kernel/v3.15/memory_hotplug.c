void lock_memory_hotplug(void)\r\n{\r\nmutex_lock(&mem_hotplug_mutex);\r\n}\r\nvoid unlock_memory_hotplug(void)\r\n{\r\nmutex_unlock(&mem_hotplug_mutex);\r\n}\r\nstatic struct resource *register_memory_resource(u64 start, u64 size)\r\n{\r\nstruct resource *res;\r\nres = kzalloc(sizeof(struct resource), GFP_KERNEL);\r\nBUG_ON(!res);\r\nres->name = "System RAM";\r\nres->start = start;\r\nres->end = start + size - 1;\r\nres->flags = IORESOURCE_MEM | IORESOURCE_BUSY;\r\nif (request_resource(&iomem_resource, res) < 0) {\r\npr_debug("System RAM resource %pR cannot be added\n", res);\r\nkfree(res);\r\nres = NULL;\r\n}\r\nreturn res;\r\n}\r\nstatic void release_memory_resource(struct resource *res)\r\n{\r\nif (!res)\r\nreturn;\r\nrelease_resource(res);\r\nkfree(res);\r\nreturn;\r\n}\r\nvoid get_page_bootmem(unsigned long info, struct page *page,\r\nunsigned long type)\r\n{\r\npage->lru.next = (struct list_head *) type;\r\nSetPagePrivate(page);\r\nset_page_private(page, info);\r\natomic_inc(&page->_count);\r\n}\r\nvoid put_page_bootmem(struct page *page)\r\n{\r\nunsigned long type;\r\ntype = (unsigned long) page->lru.next;\r\nBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\r\ntype > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\r\nif (atomic_dec_return(&page->_count) == 1) {\r\nClearPagePrivate(page);\r\nset_page_private(page, 0);\r\nINIT_LIST_HEAD(&page->lru);\r\nfree_reserved_page(page);\r\n}\r\n}\r\nstatic void register_page_bootmem_info_section(unsigned long start_pfn)\r\n{\r\nunsigned long *usemap, mapsize, section_nr, i;\r\nstruct mem_section *ms;\r\nstruct page *page, *memmap;\r\nsection_nr = pfn_to_section_nr(start_pfn);\r\nms = __nr_to_section(section_nr);\r\nmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);\r\npage = virt_to_page(memmap);\r\nmapsize = sizeof(struct page) * PAGES_PER_SECTION;\r\nmapsize = PAGE_ALIGN(mapsize) >> PAGE_SHIFT;\r\nfor (i = 0; i < mapsize; i++, page++)\r\nget_page_bootmem(section_nr, page, SECTION_INFO);\r\nusemap = __nr_to_section(section_nr)->pageblock_flags;\r\npage = virt_to_page(usemap);\r\nmapsize = PAGE_ALIGN(usemap_size()) >> PAGE_SHIFT;\r\nfor (i = 0; i < mapsize; i++, page++)\r\nget_page_bootmem(section_nr, page, MIX_SECTION_INFO);\r\n}\r\nstatic void register_page_bootmem_info_section(unsigned long start_pfn)\r\n{\r\nunsigned long *usemap, mapsize, section_nr, i;\r\nstruct mem_section *ms;\r\nstruct page *page, *memmap;\r\nif (!pfn_valid(start_pfn))\r\nreturn;\r\nsection_nr = pfn_to_section_nr(start_pfn);\r\nms = __nr_to_section(section_nr);\r\nmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);\r\nregister_page_bootmem_memmap(section_nr, memmap, PAGES_PER_SECTION);\r\nusemap = __nr_to_section(section_nr)->pageblock_flags;\r\npage = virt_to_page(usemap);\r\nmapsize = PAGE_ALIGN(usemap_size()) >> PAGE_SHIFT;\r\nfor (i = 0; i < mapsize; i++, page++)\r\nget_page_bootmem(section_nr, page, MIX_SECTION_INFO);\r\n}\r\nvoid register_page_bootmem_info_node(struct pglist_data *pgdat)\r\n{\r\nunsigned long i, pfn, end_pfn, nr_pages;\r\nint node = pgdat->node_id;\r\nstruct page *page;\r\nstruct zone *zone;\r\nnr_pages = PAGE_ALIGN(sizeof(struct pglist_data)) >> PAGE_SHIFT;\r\npage = virt_to_page(pgdat);\r\nfor (i = 0; i < nr_pages; i++, page++)\r\nget_page_bootmem(node, page, NODE_INFO);\r\nzone = &pgdat->node_zones[0];\r\nfor (; zone < pgdat->node_zones + MAX_NR_ZONES - 1; zone++) {\r\nif (zone_is_initialized(zone)) {\r\nnr_pages = zone->wait_table_hash_nr_entries\r\n* sizeof(wait_queue_head_t);\r\nnr_pages = PAGE_ALIGN(nr_pages) >> PAGE_SHIFT;\r\npage = virt_to_page(zone->wait_table);\r\nfor (i = 0; i < nr_pages; i++, page++)\r\nget_page_bootmem(node, page, NODE_INFO);\r\n}\r\n}\r\npfn = pgdat->node_start_pfn;\r\nend_pfn = pgdat_end_pfn(pgdat);\r\nfor (; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\r\nif (pfn_valid(pfn) && (pfn_to_nid(pfn) == node))\r\nregister_page_bootmem_info_section(pfn);\r\n}\r\n}\r\nstatic void grow_zone_span(struct zone *zone, unsigned long start_pfn,\r\nunsigned long end_pfn)\r\n{\r\nunsigned long old_zone_end_pfn;\r\nzone_span_writelock(zone);\r\nold_zone_end_pfn = zone_end_pfn(zone);\r\nif (zone_is_empty(zone) || start_pfn < zone->zone_start_pfn)\r\nzone->zone_start_pfn = start_pfn;\r\nzone->spanned_pages = max(old_zone_end_pfn, end_pfn) -\r\nzone->zone_start_pfn;\r\nzone_span_writeunlock(zone);\r\n}\r\nstatic void resize_zone(struct zone *zone, unsigned long start_pfn,\r\nunsigned long end_pfn)\r\n{\r\nzone_span_writelock(zone);\r\nif (end_pfn - start_pfn) {\r\nzone->zone_start_pfn = start_pfn;\r\nzone->spanned_pages = end_pfn - start_pfn;\r\n} else {\r\nzone->zone_start_pfn = 0;\r\nzone->spanned_pages = 0;\r\n}\r\nzone_span_writeunlock(zone);\r\n}\r\nstatic void fix_zone_id(struct zone *zone, unsigned long start_pfn,\r\nunsigned long end_pfn)\r\n{\r\nenum zone_type zid = zone_idx(zone);\r\nint nid = zone->zone_pgdat->node_id;\r\nunsigned long pfn;\r\nfor (pfn = start_pfn; pfn < end_pfn; pfn++)\r\nset_page_links(pfn_to_page(pfn), zid, nid, pfn);\r\n}\r\nstatic int __ref ensure_zone_is_initialized(struct zone *zone,\r\nunsigned long start_pfn, unsigned long num_pages)\r\n{\r\nif (!zone_is_initialized(zone))\r\nreturn init_currently_empty_zone(zone, start_pfn, num_pages,\r\nMEMMAP_HOTPLUG);\r\nreturn 0;\r\n}\r\nstatic int __meminit move_pfn_range_left(struct zone *z1, struct zone *z2,\r\nunsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nunsigned long z1_start_pfn;\r\nret = ensure_zone_is_initialized(z1, start_pfn, end_pfn - start_pfn);\r\nif (ret)\r\nreturn ret;\r\npgdat_resize_lock(z1->zone_pgdat, &flags);\r\nif (end_pfn > zone_end_pfn(z2))\r\ngoto out_fail;\r\nif (start_pfn > z2->zone_start_pfn)\r\ngoto out_fail;\r\nif (end_pfn <= z2->zone_start_pfn)\r\ngoto out_fail;\r\nif (!zone_is_empty(z1))\r\nz1_start_pfn = z1->zone_start_pfn;\r\nelse\r\nz1_start_pfn = start_pfn;\r\nresize_zone(z1, z1_start_pfn, end_pfn);\r\nresize_zone(z2, end_pfn, zone_end_pfn(z2));\r\npgdat_resize_unlock(z1->zone_pgdat, &flags);\r\nfix_zone_id(z1, start_pfn, end_pfn);\r\nreturn 0;\r\nout_fail:\r\npgdat_resize_unlock(z1->zone_pgdat, &flags);\r\nreturn -1;\r\n}\r\nstatic int __meminit move_pfn_range_right(struct zone *z1, struct zone *z2,\r\nunsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nunsigned long z2_end_pfn;\r\nret = ensure_zone_is_initialized(z2, start_pfn, end_pfn - start_pfn);\r\nif (ret)\r\nreturn ret;\r\npgdat_resize_lock(z1->zone_pgdat, &flags);\r\nif (z1->zone_start_pfn > start_pfn)\r\ngoto out_fail;\r\nif (zone_end_pfn(z1) > end_pfn)\r\ngoto out_fail;\r\nif (start_pfn >= zone_end_pfn(z1))\r\ngoto out_fail;\r\nif (!zone_is_empty(z2))\r\nz2_end_pfn = zone_end_pfn(z2);\r\nelse\r\nz2_end_pfn = end_pfn;\r\nresize_zone(z1, z1->zone_start_pfn, start_pfn);\r\nresize_zone(z2, start_pfn, z2_end_pfn);\r\npgdat_resize_unlock(z1->zone_pgdat, &flags);\r\nfix_zone_id(z2, start_pfn, end_pfn);\r\nreturn 0;\r\nout_fail:\r\npgdat_resize_unlock(z1->zone_pgdat, &flags);\r\nreturn -1;\r\n}\r\nstatic void grow_pgdat_span(struct pglist_data *pgdat, unsigned long start_pfn,\r\nunsigned long end_pfn)\r\n{\r\nunsigned long old_pgdat_end_pfn = pgdat_end_pfn(pgdat);\r\nif (!pgdat->node_spanned_pages || start_pfn < pgdat->node_start_pfn)\r\npgdat->node_start_pfn = start_pfn;\r\npgdat->node_spanned_pages = max(old_pgdat_end_pfn, end_pfn) -\r\npgdat->node_start_pfn;\r\n}\r\nstatic int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)\r\n{\r\nstruct pglist_data *pgdat = zone->zone_pgdat;\r\nint nr_pages = PAGES_PER_SECTION;\r\nint nid = pgdat->node_id;\r\nint zone_type;\r\nunsigned long flags;\r\nint ret;\r\nzone_type = zone - pgdat->node_zones;\r\nret = ensure_zone_is_initialized(zone, phys_start_pfn, nr_pages);\r\nif (ret)\r\nreturn ret;\r\npgdat_resize_lock(zone->zone_pgdat, &flags);\r\ngrow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);\r\ngrow_pgdat_span(zone->zone_pgdat, phys_start_pfn,\r\nphys_start_pfn + nr_pages);\r\npgdat_resize_unlock(zone->zone_pgdat, &flags);\r\nmemmap_init_zone(nr_pages, nid, zone_type,\r\nphys_start_pfn, MEMMAP_HOTPLUG);\r\nreturn 0;\r\n}\r\nstatic int __meminit __add_section(int nid, struct zone *zone,\r\nunsigned long phys_start_pfn)\r\n{\r\nint ret;\r\nif (pfn_valid(phys_start_pfn))\r\nreturn -EEXIST;\r\nret = sparse_add_one_section(zone, phys_start_pfn);\r\nif (ret < 0)\r\nreturn ret;\r\nret = __add_zone(zone, phys_start_pfn);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn register_new_memory(nid, __pfn_to_section(phys_start_pfn));\r\n}\r\nint __ref __add_pages(int nid, struct zone *zone, unsigned long phys_start_pfn,\r\nunsigned long nr_pages)\r\n{\r\nunsigned long i;\r\nint err = 0;\r\nint start_sec, end_sec;\r\nstart_sec = pfn_to_section_nr(phys_start_pfn);\r\nend_sec = pfn_to_section_nr(phys_start_pfn + nr_pages - 1);\r\nfor (i = start_sec; i <= end_sec; i++) {\r\nerr = __add_section(nid, zone, i << PFN_SECTION_SHIFT);\r\nif (err && (err != -EEXIST))\r\nbreak;\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int find_smallest_section_pfn(int nid, struct zone *zone,\r\nunsigned long start_pfn,\r\nunsigned long end_pfn)\r\n{\r\nstruct mem_section *ms;\r\nfor (; start_pfn < end_pfn; start_pfn += PAGES_PER_SECTION) {\r\nms = __pfn_to_section(start_pfn);\r\nif (unlikely(!valid_section(ms)))\r\ncontinue;\r\nif (unlikely(pfn_to_nid(start_pfn) != nid))\r\ncontinue;\r\nif (zone && zone != page_zone(pfn_to_page(start_pfn)))\r\ncontinue;\r\nreturn start_pfn;\r\n}\r\nreturn 0;\r\n}\r\nstatic int find_biggest_section_pfn(int nid, struct zone *zone,\r\nunsigned long start_pfn,\r\nunsigned long end_pfn)\r\n{\r\nstruct mem_section *ms;\r\nunsigned long pfn;\r\npfn = end_pfn - 1;\r\nfor (; pfn >= start_pfn; pfn -= PAGES_PER_SECTION) {\r\nms = __pfn_to_section(pfn);\r\nif (unlikely(!valid_section(ms)))\r\ncontinue;\r\nif (unlikely(pfn_to_nid(pfn) != nid))\r\ncontinue;\r\nif (zone && zone != page_zone(pfn_to_page(pfn)))\r\ncontinue;\r\nreturn pfn;\r\n}\r\nreturn 0;\r\n}\r\nstatic void shrink_zone_span(struct zone *zone, unsigned long start_pfn,\r\nunsigned long end_pfn)\r\n{\r\nunsigned long zone_start_pfn = zone->zone_start_pfn;\r\nunsigned long z = zone_end_pfn(zone);\r\nunsigned long zone_end_pfn = z;\r\nunsigned long pfn;\r\nstruct mem_section *ms;\r\nint nid = zone_to_nid(zone);\r\nzone_span_writelock(zone);\r\nif (zone_start_pfn == start_pfn) {\r\npfn = find_smallest_section_pfn(nid, zone, end_pfn,\r\nzone_end_pfn);\r\nif (pfn) {\r\nzone->zone_start_pfn = pfn;\r\nzone->spanned_pages = zone_end_pfn - pfn;\r\n}\r\n} else if (zone_end_pfn == end_pfn) {\r\npfn = find_biggest_section_pfn(nid, zone, zone_start_pfn,\r\nstart_pfn);\r\nif (pfn)\r\nzone->spanned_pages = pfn - zone_start_pfn + 1;\r\n}\r\npfn = zone_start_pfn;\r\nfor (; pfn < zone_end_pfn; pfn += PAGES_PER_SECTION) {\r\nms = __pfn_to_section(pfn);\r\nif (unlikely(!valid_section(ms)))\r\ncontinue;\r\nif (page_zone(pfn_to_page(pfn)) != zone)\r\ncontinue;\r\nif (start_pfn == pfn)\r\ncontinue;\r\nzone_span_writeunlock(zone);\r\nreturn;\r\n}\r\nzone->zone_start_pfn = 0;\r\nzone->spanned_pages = 0;\r\nzone_span_writeunlock(zone);\r\n}\r\nstatic void shrink_pgdat_span(struct pglist_data *pgdat,\r\nunsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nunsigned long pgdat_start_pfn = pgdat->node_start_pfn;\r\nunsigned long p = pgdat_end_pfn(pgdat);\r\nunsigned long pgdat_end_pfn = p;\r\nunsigned long pfn;\r\nstruct mem_section *ms;\r\nint nid = pgdat->node_id;\r\nif (pgdat_start_pfn == start_pfn) {\r\npfn = find_smallest_section_pfn(nid, NULL, end_pfn,\r\npgdat_end_pfn);\r\nif (pfn) {\r\npgdat->node_start_pfn = pfn;\r\npgdat->node_spanned_pages = pgdat_end_pfn - pfn;\r\n}\r\n} else if (pgdat_end_pfn == end_pfn) {\r\npfn = find_biggest_section_pfn(nid, NULL, pgdat_start_pfn,\r\nstart_pfn);\r\nif (pfn)\r\npgdat->node_spanned_pages = pfn - pgdat_start_pfn + 1;\r\n}\r\npfn = pgdat_start_pfn;\r\nfor (; pfn < pgdat_end_pfn; pfn += PAGES_PER_SECTION) {\r\nms = __pfn_to_section(pfn);\r\nif (unlikely(!valid_section(ms)))\r\ncontinue;\r\nif (pfn_to_nid(pfn) != nid)\r\ncontinue;\r\nif (start_pfn == pfn)\r\ncontinue;\r\nreturn;\r\n}\r\npgdat->node_start_pfn = 0;\r\npgdat->node_spanned_pages = 0;\r\n}\r\nstatic void __remove_zone(struct zone *zone, unsigned long start_pfn)\r\n{\r\nstruct pglist_data *pgdat = zone->zone_pgdat;\r\nint nr_pages = PAGES_PER_SECTION;\r\nint zone_type;\r\nunsigned long flags;\r\nzone_type = zone - pgdat->node_zones;\r\npgdat_resize_lock(zone->zone_pgdat, &flags);\r\nshrink_zone_span(zone, start_pfn, start_pfn + nr_pages);\r\nshrink_pgdat_span(pgdat, start_pfn, start_pfn + nr_pages);\r\npgdat_resize_unlock(zone->zone_pgdat, &flags);\r\n}\r\nstatic int __remove_section(struct zone *zone, struct mem_section *ms)\r\n{\r\nunsigned long start_pfn;\r\nint scn_nr;\r\nint ret = -EINVAL;\r\nif (!valid_section(ms))\r\nreturn ret;\r\nret = unregister_memory_section(ms);\r\nif (ret)\r\nreturn ret;\r\nscn_nr = __section_nr(ms);\r\nstart_pfn = section_nr_to_pfn(scn_nr);\r\n__remove_zone(zone, start_pfn);\r\nsparse_remove_one_section(zone, ms);\r\nreturn 0;\r\n}\r\nint __remove_pages(struct zone *zone, unsigned long phys_start_pfn,\r\nunsigned long nr_pages)\r\n{\r\nunsigned long i;\r\nint sections_to_remove;\r\nresource_size_t start, size;\r\nint ret = 0;\r\nBUG_ON(phys_start_pfn & ~PAGE_SECTION_MASK);\r\nBUG_ON(nr_pages % PAGES_PER_SECTION);\r\nstart = phys_start_pfn << PAGE_SHIFT;\r\nsize = nr_pages * PAGE_SIZE;\r\nret = release_mem_region_adjustable(&iomem_resource, start, size);\r\nif (ret) {\r\nresource_size_t endres = start + size - 1;\r\npr_warn("Unable to release resource <%pa-%pa> (%d)\n",\r\n&start, &endres, ret);\r\n}\r\nsections_to_remove = nr_pages / PAGES_PER_SECTION;\r\nfor (i = 0; i < sections_to_remove; i++) {\r\nunsigned long pfn = phys_start_pfn + i*PAGES_PER_SECTION;\r\nret = __remove_section(zone, __pfn_to_section(pfn));\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint set_online_page_callback(online_page_callback_t callback)\r\n{\r\nint rc = -EINVAL;\r\nlock_memory_hotplug();\r\nif (online_page_callback == generic_online_page) {\r\nonline_page_callback = callback;\r\nrc = 0;\r\n}\r\nunlock_memory_hotplug();\r\nreturn rc;\r\n}\r\nint restore_online_page_callback(online_page_callback_t callback)\r\n{\r\nint rc = -EINVAL;\r\nlock_memory_hotplug();\r\nif (online_page_callback == callback) {\r\nonline_page_callback = generic_online_page;\r\nrc = 0;\r\n}\r\nunlock_memory_hotplug();\r\nreturn rc;\r\n}\r\nvoid __online_page_set_limits(struct page *page)\r\n{\r\n}\r\nvoid __online_page_increment_counters(struct page *page)\r\n{\r\nadjust_managed_page_count(page, 1);\r\n}\r\nvoid __online_page_free(struct page *page)\r\n{\r\n__free_reserved_page(page);\r\n}\r\nstatic void generic_online_page(struct page *page)\r\n{\r\n__online_page_set_limits(page);\r\n__online_page_increment_counters(page);\r\n__online_page_free(page);\r\n}\r\nstatic int online_pages_range(unsigned long start_pfn, unsigned long nr_pages,\r\nvoid *arg)\r\n{\r\nunsigned long i;\r\nunsigned long onlined_pages = *(unsigned long *)arg;\r\nstruct page *page;\r\nif (PageReserved(pfn_to_page(start_pfn)))\r\nfor (i = 0; i < nr_pages; i++) {\r\npage = pfn_to_page(start_pfn + i);\r\n(*online_page_callback)(page);\r\nonlined_pages++;\r\n}\r\n*(unsigned long *)arg = onlined_pages;\r\nreturn 0;\r\n}\r\nstatic bool can_online_high_movable(struct zone *zone)\r\n{\r\nreturn true;\r\n}\r\nstatic bool can_online_high_movable(struct zone *zone)\r\n{\r\nreturn node_state(zone_to_nid(zone), N_NORMAL_MEMORY);\r\n}\r\nstatic void node_states_check_changes_online(unsigned long nr_pages,\r\nstruct zone *zone, struct memory_notify *arg)\r\n{\r\nint nid = zone_to_nid(zone);\r\nenum zone_type zone_last = ZONE_NORMAL;\r\nif (N_MEMORY == N_NORMAL_MEMORY)\r\nzone_last = ZONE_MOVABLE;\r\nif (zone_idx(zone) <= zone_last && !node_state(nid, N_NORMAL_MEMORY))\r\narg->status_change_nid_normal = nid;\r\nelse\r\narg->status_change_nid_normal = -1;\r\n#ifdef CONFIG_HIGHMEM\r\nzone_last = ZONE_HIGHMEM;\r\nif (N_MEMORY == N_HIGH_MEMORY)\r\nzone_last = ZONE_MOVABLE;\r\nif (zone_idx(zone) <= zone_last && !node_state(nid, N_HIGH_MEMORY))\r\narg->status_change_nid_high = nid;\r\nelse\r\narg->status_change_nid_high = -1;\r\n#else\r\narg->status_change_nid_high = arg->status_change_nid_normal;\r\n#endif\r\nif (!node_state(nid, N_MEMORY))\r\narg->status_change_nid = nid;\r\nelse\r\narg->status_change_nid = -1;\r\n}\r\nstatic void node_states_set_node(int node, struct memory_notify *arg)\r\n{\r\nif (arg->status_change_nid_normal >= 0)\r\nnode_set_state(node, N_NORMAL_MEMORY);\r\nif (arg->status_change_nid_high >= 0)\r\nnode_set_state(node, N_HIGH_MEMORY);\r\nnode_set_state(node, N_MEMORY);\r\n}\r\nint __ref online_pages(unsigned long pfn, unsigned long nr_pages, int online_type)\r\n{\r\nunsigned long flags;\r\nunsigned long onlined_pages = 0;\r\nstruct zone *zone;\r\nint need_zonelists_rebuild = 0;\r\nint nid;\r\nint ret;\r\nstruct memory_notify arg;\r\nlock_memory_hotplug();\r\nzone = page_zone(pfn_to_page(pfn));\r\nif ((zone_idx(zone) > ZONE_NORMAL || online_type == ONLINE_MOVABLE) &&\r\n!can_online_high_movable(zone)) {\r\nunlock_memory_hotplug();\r\nreturn -EINVAL;\r\n}\r\nif (online_type == ONLINE_KERNEL && zone_idx(zone) == ZONE_MOVABLE) {\r\nif (move_pfn_range_left(zone - 1, zone, pfn, pfn + nr_pages)) {\r\nunlock_memory_hotplug();\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (online_type == ONLINE_MOVABLE && zone_idx(zone) == ZONE_MOVABLE - 1) {\r\nif (move_pfn_range_right(zone, zone + 1, pfn, pfn + nr_pages)) {\r\nunlock_memory_hotplug();\r\nreturn -EINVAL;\r\n}\r\n}\r\nzone = page_zone(pfn_to_page(pfn));\r\narg.start_pfn = pfn;\r\narg.nr_pages = nr_pages;\r\nnode_states_check_changes_online(nr_pages, zone, &arg);\r\nnid = pfn_to_nid(pfn);\r\nret = memory_notify(MEM_GOING_ONLINE, &arg);\r\nret = notifier_to_errno(ret);\r\nif (ret) {\r\nmemory_notify(MEM_CANCEL_ONLINE, &arg);\r\nunlock_memory_hotplug();\r\nreturn ret;\r\n}\r\nmutex_lock(&zonelists_mutex);\r\nif (!populated_zone(zone)) {\r\nneed_zonelists_rebuild = 1;\r\nbuild_all_zonelists(NULL, zone);\r\n}\r\nret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,\r\nonline_pages_range);\r\nif (ret) {\r\nif (need_zonelists_rebuild)\r\nzone_pcp_reset(zone);\r\nmutex_unlock(&zonelists_mutex);\r\nprintk(KERN_DEBUG "online_pages [mem %#010llx-%#010llx] failed\n",\r\n(unsigned long long) pfn << PAGE_SHIFT,\r\n(((unsigned long long) pfn + nr_pages)\r\n<< PAGE_SHIFT) - 1);\r\nmemory_notify(MEM_CANCEL_ONLINE, &arg);\r\nunlock_memory_hotplug();\r\nreturn ret;\r\n}\r\nzone->present_pages += onlined_pages;\r\npgdat_resize_lock(zone->zone_pgdat, &flags);\r\nzone->zone_pgdat->node_present_pages += onlined_pages;\r\npgdat_resize_unlock(zone->zone_pgdat, &flags);\r\nif (onlined_pages) {\r\nnode_states_set_node(zone_to_nid(zone), &arg);\r\nif (need_zonelists_rebuild)\r\nbuild_all_zonelists(NULL, NULL);\r\nelse\r\nzone_pcp_update(zone);\r\n}\r\nmutex_unlock(&zonelists_mutex);\r\ninit_per_zone_wmark_min();\r\nif (onlined_pages)\r\nkswapd_run(zone_to_nid(zone));\r\nvm_total_pages = nr_free_pagecache_pages();\r\nwriteback_set_ratelimit();\r\nif (onlined_pages)\r\nmemory_notify(MEM_ONLINE, &arg);\r\nunlock_memory_hotplug();\r\nreturn 0;\r\n}\r\nstatic pg_data_t __ref *hotadd_new_pgdat(int nid, u64 start)\r\n{\r\nstruct pglist_data *pgdat;\r\nunsigned long zones_size[MAX_NR_ZONES] = {0};\r\nunsigned long zholes_size[MAX_NR_ZONES] = {0};\r\nunsigned long start_pfn = start >> PAGE_SHIFT;\r\npgdat = NODE_DATA(nid);\r\nif (!pgdat) {\r\npgdat = arch_alloc_nodedata(nid);\r\nif (!pgdat)\r\nreturn NULL;\r\narch_refresh_nodedata(nid, pgdat);\r\n}\r\nfree_area_init_node(nid, zones_size, start_pfn, zholes_size);\r\nmutex_lock(&zonelists_mutex);\r\nbuild_all_zonelists(pgdat, NULL);\r\nmutex_unlock(&zonelists_mutex);\r\nreturn pgdat;\r\n}\r\nstatic void rollback_node_hotadd(int nid, pg_data_t *pgdat)\r\n{\r\narch_refresh_nodedata(nid, NULL);\r\narch_free_nodedata(pgdat);\r\nreturn;\r\n}\r\nint try_online_node(int nid)\r\n{\r\npg_data_t *pgdat;\r\nint ret;\r\nif (node_online(nid))\r\nreturn 0;\r\nlock_memory_hotplug();\r\npgdat = hotadd_new_pgdat(nid, 0);\r\nif (!pgdat) {\r\npr_err("Cannot online node %d due to NULL pgdat\n", nid);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nnode_set_online(nid);\r\nret = register_one_node(nid);\r\nBUG_ON(ret);\r\nif (pgdat->node_zonelists->_zonerefs->zone == NULL) {\r\nmutex_lock(&zonelists_mutex);\r\nbuild_all_zonelists(NULL, NULL);\r\nmutex_unlock(&zonelists_mutex);\r\n}\r\nout:\r\nunlock_memory_hotplug();\r\nreturn ret;\r\n}\r\nstatic int check_hotplug_memory_range(u64 start, u64 size)\r\n{\r\nu64 start_pfn = start >> PAGE_SHIFT;\r\nu64 nr_pages = size >> PAGE_SHIFT;\r\nif ((start_pfn & ~PAGE_SECTION_MASK) ||\r\n(nr_pages % PAGES_PER_SECTION) || (!nr_pages)) {\r\npr_err("Section-unaligned hotplug range: start 0x%llx, size 0x%llx\n",\r\n(unsigned long long)start,\r\n(unsigned long long)size);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint __ref add_memory(int nid, u64 start, u64 size)\r\n{\r\npg_data_t *pgdat = NULL;\r\nbool new_pgdat;\r\nbool new_node;\r\nstruct resource *res;\r\nint ret;\r\nret = check_hotplug_memory_range(start, size);\r\nif (ret)\r\nreturn ret;\r\nres = register_memory_resource(start, size);\r\nret = -EEXIST;\r\nif (!res)\r\nreturn ret;\r\n{\r\nvoid *p = NODE_DATA(nid);\r\nnew_pgdat = !p;\r\n}\r\nlock_memory_hotplug();\r\nnew_node = !node_online(nid);\r\nif (new_node) {\r\npgdat = hotadd_new_pgdat(nid, start);\r\nret = -ENOMEM;\r\nif (!pgdat)\r\ngoto error;\r\n}\r\nret = arch_add_memory(nid, start, size);\r\nif (ret < 0)\r\ngoto error;\r\nnode_set_online(nid);\r\nif (new_node) {\r\nret = register_one_node(nid);\r\nBUG_ON(ret);\r\n}\r\nfirmware_map_add_hotplug(start, start + size, "System RAM");\r\ngoto out;\r\nerror:\r\nif (new_pgdat)\r\nrollback_node_hotadd(nid, pgdat);\r\nrelease_memory_resource(res);\r\nout:\r\nunlock_memory_hotplug();\r\nreturn ret;\r\n}\r\nstatic inline int pageblock_free(struct page *page)\r\n{\r\nreturn PageBuddy(page) && page_order(page) >= pageblock_order;\r\n}\r\nstatic struct page *next_active_pageblock(struct page *page)\r\n{\r\nBUG_ON(page_to_pfn(page) & (pageblock_nr_pages - 1));\r\nif (pageblock_free(page)) {\r\nint order;\r\norder = page_order(page);\r\nif ((order < MAX_ORDER) && (order >= pageblock_order))\r\nreturn page + (1 << order);\r\n}\r\nreturn page + pageblock_nr_pages;\r\n}\r\nint is_mem_section_removable(unsigned long start_pfn, unsigned long nr_pages)\r\n{\r\nstruct page *page = pfn_to_page(start_pfn);\r\nstruct page *end_page = page + nr_pages;\r\nfor (; page < end_page; page = next_active_pageblock(page)) {\r\nif (!is_pageblock_removable_nolock(page))\r\nreturn 0;\r\ncond_resched();\r\n}\r\nreturn 1;\r\n}\r\nstatic int test_pages_in_a_zone(unsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nunsigned long pfn;\r\nstruct zone *zone = NULL;\r\nstruct page *page;\r\nint i;\r\nfor (pfn = start_pfn;\r\npfn < end_pfn;\r\npfn += MAX_ORDER_NR_PAGES) {\r\ni = 0;\r\nwhile ((i < MAX_ORDER_NR_PAGES) && !pfn_valid_within(pfn + i))\r\ni++;\r\nif (i == MAX_ORDER_NR_PAGES)\r\ncontinue;\r\npage = pfn_to_page(pfn + i);\r\nif (zone && page_zone(page) != zone)\r\nreturn 0;\r\nzone = page_zone(page);\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned long scan_movable_pages(unsigned long start, unsigned long end)\r\n{\r\nunsigned long pfn;\r\nstruct page *page;\r\nfor (pfn = start; pfn < end; pfn++) {\r\nif (pfn_valid(pfn)) {\r\npage = pfn_to_page(pfn);\r\nif (PageLRU(page))\r\nreturn pfn;\r\nif (PageHuge(page)) {\r\nif (is_hugepage_active(page))\r\nreturn pfn;\r\nelse\r\npfn = round_up(pfn + 1,\r\n1 << compound_order(page)) - 1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndo_migrate_range(unsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nunsigned long pfn;\r\nstruct page *page;\r\nint move_pages = NR_OFFLINE_AT_ONCE_PAGES;\r\nint not_managed = 0;\r\nint ret = 0;\r\nLIST_HEAD(source);\r\nfor (pfn = start_pfn; pfn < end_pfn && move_pages > 0; pfn++) {\r\nif (!pfn_valid(pfn))\r\ncontinue;\r\npage = pfn_to_page(pfn);\r\nif (PageHuge(page)) {\r\nstruct page *head = compound_head(page);\r\npfn = page_to_pfn(head) + (1<<compound_order(head)) - 1;\r\nif (compound_order(head) > PFN_SECTION_SHIFT) {\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nif (isolate_huge_page(page, &source))\r\nmove_pages -= 1 << compound_order(head);\r\ncontinue;\r\n}\r\nif (!get_page_unless_zero(page))\r\ncontinue;\r\nret = isolate_lru_page(page);\r\nif (!ret) {\r\nput_page(page);\r\nlist_add_tail(&page->lru, &source);\r\nmove_pages--;\r\ninc_zone_page_state(page, NR_ISOLATED_ANON +\r\npage_is_file_cache(page));\r\n} else {\r\n#ifdef CONFIG_DEBUG_VM\r\nprintk(KERN_ALERT "removing pfn %lx from LRU failed\n",\r\npfn);\r\ndump_page(page, "failed to remove from LRU");\r\n#endif\r\nput_page(page);\r\nif (page_count(page)) {\r\nnot_managed++;\r\nret = -EBUSY;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!list_empty(&source)) {\r\nif (not_managed) {\r\nputback_movable_pages(&source);\r\ngoto out;\r\n}\r\nret = migrate_pages(&source, alloc_migrate_target, 0,\r\nMIGRATE_SYNC, MR_MEMORY_HOTPLUG);\r\nif (ret)\r\nputback_movable_pages(&source);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\noffline_isolated_pages_cb(unsigned long start, unsigned long nr_pages,\r\nvoid *data)\r\n{\r\n__offline_isolated_pages(start, start + nr_pages);\r\nreturn 0;\r\n}\r\nstatic void\r\noffline_isolated_pages(unsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nwalk_system_ram_range(start_pfn, end_pfn - start_pfn, NULL,\r\noffline_isolated_pages_cb);\r\n}\r\nstatic int\r\ncheck_pages_isolated_cb(unsigned long start_pfn, unsigned long nr_pages,\r\nvoid *data)\r\n{\r\nint ret;\r\nlong offlined = *(long *)data;\r\nret = test_pages_isolated(start_pfn, start_pfn + nr_pages, true);\r\nofflined = nr_pages;\r\nif (!ret)\r\n*(long *)data += offlined;\r\nreturn ret;\r\n}\r\nstatic long\r\ncheck_pages_isolated(unsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nlong offlined = 0;\r\nint ret;\r\nret = walk_system_ram_range(start_pfn, end_pfn - start_pfn, &offlined,\r\ncheck_pages_isolated_cb);\r\nif (ret < 0)\r\nofflined = (long)ret;\r\nreturn offlined;\r\n}\r\nstatic bool can_offline_normal(struct zone *zone, unsigned long nr_pages)\r\n{\r\nreturn true;\r\n}\r\nstatic bool can_offline_normal(struct zone *zone, unsigned long nr_pages)\r\n{\r\nstruct pglist_data *pgdat = zone->zone_pgdat;\r\nunsigned long present_pages = 0;\r\nenum zone_type zt;\r\nfor (zt = 0; zt <= ZONE_NORMAL; zt++)\r\npresent_pages += pgdat->node_zones[zt].present_pages;\r\nif (present_pages > nr_pages)\r\nreturn true;\r\npresent_pages = 0;\r\nfor (; zt <= ZONE_MOVABLE; zt++)\r\npresent_pages += pgdat->node_zones[zt].present_pages;\r\nreturn present_pages == 0;\r\n}\r\nstatic int __init cmdline_parse_movable_node(char *p)\r\n{\r\n#ifdef CONFIG_MOVABLE_NODE\r\nmemblock_set_bottom_up(true);\r\nmovable_node_enabled = true;\r\n#else\r\npr_warn("movable_node option not supported\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void node_states_check_changes_offline(unsigned long nr_pages,\r\nstruct zone *zone, struct memory_notify *arg)\r\n{\r\nstruct pglist_data *pgdat = zone->zone_pgdat;\r\nunsigned long present_pages = 0;\r\nenum zone_type zt, zone_last = ZONE_NORMAL;\r\nif (N_MEMORY == N_NORMAL_MEMORY)\r\nzone_last = ZONE_MOVABLE;\r\nfor (zt = 0; zt <= zone_last; zt++)\r\npresent_pages += pgdat->node_zones[zt].present_pages;\r\nif (zone_idx(zone) <= zone_last && nr_pages >= present_pages)\r\narg->status_change_nid_normal = zone_to_nid(zone);\r\nelse\r\narg->status_change_nid_normal = -1;\r\n#ifdef CONFIG_HIGHMEM\r\nzone_last = ZONE_HIGHMEM;\r\nif (N_MEMORY == N_HIGH_MEMORY)\r\nzone_last = ZONE_MOVABLE;\r\nfor (; zt <= zone_last; zt++)\r\npresent_pages += pgdat->node_zones[zt].present_pages;\r\nif (zone_idx(zone) <= zone_last && nr_pages >= present_pages)\r\narg->status_change_nid_high = zone_to_nid(zone);\r\nelse\r\narg->status_change_nid_high = -1;\r\n#else\r\narg->status_change_nid_high = arg->status_change_nid_normal;\r\n#endif\r\nzone_last = ZONE_MOVABLE;\r\nfor (; zt <= zone_last; zt++)\r\npresent_pages += pgdat->node_zones[zt].present_pages;\r\nif (nr_pages >= present_pages)\r\narg->status_change_nid = zone_to_nid(zone);\r\nelse\r\narg->status_change_nid = -1;\r\n}\r\nstatic void node_states_clear_node(int node, struct memory_notify *arg)\r\n{\r\nif (arg->status_change_nid_normal >= 0)\r\nnode_clear_state(node, N_NORMAL_MEMORY);\r\nif ((N_MEMORY != N_NORMAL_MEMORY) &&\r\n(arg->status_change_nid_high >= 0))\r\nnode_clear_state(node, N_HIGH_MEMORY);\r\nif ((N_MEMORY != N_HIGH_MEMORY) &&\r\n(arg->status_change_nid >= 0))\r\nnode_clear_state(node, N_MEMORY);\r\n}\r\nstatic int __ref __offline_pages(unsigned long start_pfn,\r\nunsigned long end_pfn, unsigned long timeout)\r\n{\r\nunsigned long pfn, nr_pages, expire;\r\nlong offlined_pages;\r\nint ret, drain, retry_max, node;\r\nunsigned long flags;\r\nstruct zone *zone;\r\nstruct memory_notify arg;\r\nif (!IS_ALIGNED(start_pfn, pageblock_nr_pages))\r\nreturn -EINVAL;\r\nif (!IS_ALIGNED(end_pfn, pageblock_nr_pages))\r\nreturn -EINVAL;\r\nif (!test_pages_in_a_zone(start_pfn, end_pfn))\r\nreturn -EINVAL;\r\nlock_memory_hotplug();\r\nzone = page_zone(pfn_to_page(start_pfn));\r\nnode = zone_to_nid(zone);\r\nnr_pages = end_pfn - start_pfn;\r\nret = -EINVAL;\r\nif (zone_idx(zone) <= ZONE_NORMAL && !can_offline_normal(zone, nr_pages))\r\ngoto out;\r\nret = start_isolate_page_range(start_pfn, end_pfn,\r\nMIGRATE_MOVABLE, true);\r\nif (ret)\r\ngoto out;\r\narg.start_pfn = start_pfn;\r\narg.nr_pages = nr_pages;\r\nnode_states_check_changes_offline(nr_pages, zone, &arg);\r\nret = memory_notify(MEM_GOING_OFFLINE, &arg);\r\nret = notifier_to_errno(ret);\r\nif (ret)\r\ngoto failed_removal;\r\npfn = start_pfn;\r\nexpire = jiffies + timeout;\r\ndrain = 0;\r\nretry_max = 5;\r\nrepeat:\r\nret = -EAGAIN;\r\nif (time_after(jiffies, expire))\r\ngoto failed_removal;\r\nret = -EINTR;\r\nif (signal_pending(current))\r\ngoto failed_removal;\r\nret = 0;\r\nif (drain) {\r\nlru_add_drain_all();\r\ncond_resched();\r\ndrain_all_pages();\r\n}\r\npfn = scan_movable_pages(start_pfn, end_pfn);\r\nif (pfn) {\r\nret = do_migrate_range(pfn, end_pfn);\r\nif (!ret) {\r\ndrain = 1;\r\ngoto repeat;\r\n} else {\r\nif (ret < 0)\r\nif (--retry_max == 0)\r\ngoto failed_removal;\r\nyield();\r\ndrain = 1;\r\ngoto repeat;\r\n}\r\n}\r\nlru_add_drain_all();\r\nyield();\r\ndrain_all_pages();\r\ndissolve_free_huge_pages(start_pfn, end_pfn);\r\nofflined_pages = check_pages_isolated(start_pfn, end_pfn);\r\nif (offlined_pages < 0) {\r\nret = -EBUSY;\r\ngoto failed_removal;\r\n}\r\nprintk(KERN_INFO "Offlined Pages %ld\n", offlined_pages);\r\noffline_isolated_pages(start_pfn, end_pfn);\r\nundo_isolate_page_range(start_pfn, end_pfn, MIGRATE_MOVABLE);\r\nadjust_managed_page_count(pfn_to_page(start_pfn), -offlined_pages);\r\nzone->present_pages -= offlined_pages;\r\npgdat_resize_lock(zone->zone_pgdat, &flags);\r\nzone->zone_pgdat->node_present_pages -= offlined_pages;\r\npgdat_resize_unlock(zone->zone_pgdat, &flags);\r\ninit_per_zone_wmark_min();\r\nif (!populated_zone(zone)) {\r\nzone_pcp_reset(zone);\r\nmutex_lock(&zonelists_mutex);\r\nbuild_all_zonelists(NULL, NULL);\r\nmutex_unlock(&zonelists_mutex);\r\n} else\r\nzone_pcp_update(zone);\r\nnode_states_clear_node(node, &arg);\r\nif (arg.status_change_nid >= 0)\r\nkswapd_stop(node);\r\nvm_total_pages = nr_free_pagecache_pages();\r\nwriteback_set_ratelimit();\r\nmemory_notify(MEM_OFFLINE, &arg);\r\nunlock_memory_hotplug();\r\nreturn 0;\r\nfailed_removal:\r\nprintk(KERN_INFO "memory offlining [mem %#010llx-%#010llx] failed\n",\r\n(unsigned long long) start_pfn << PAGE_SHIFT,\r\n((unsigned long long) end_pfn << PAGE_SHIFT) - 1);\r\nmemory_notify(MEM_CANCEL_OFFLINE, &arg);\r\nundo_isolate_page_range(start_pfn, end_pfn, MIGRATE_MOVABLE);\r\nout:\r\nunlock_memory_hotplug();\r\nreturn ret;\r\n}\r\nint offline_pages(unsigned long start_pfn, unsigned long nr_pages)\r\n{\r\nreturn __offline_pages(start_pfn, start_pfn + nr_pages, 120 * HZ);\r\n}\r\nint walk_memory_range(unsigned long start_pfn, unsigned long end_pfn,\r\nvoid *arg, int (*func)(struct memory_block *, void *))\r\n{\r\nstruct memory_block *mem = NULL;\r\nstruct mem_section *section;\r\nunsigned long pfn, section_nr;\r\nint ret;\r\nfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\r\nsection_nr = pfn_to_section_nr(pfn);\r\nif (!present_section_nr(section_nr))\r\ncontinue;\r\nsection = __nr_to_section(section_nr);\r\nif (mem)\r\nif ((section_nr >= mem->start_section_nr) &&\r\n(section_nr <= mem->end_section_nr))\r\ncontinue;\r\nmem = find_memory_block_hinted(section, mem);\r\nif (!mem)\r\ncontinue;\r\nret = func(mem, arg);\r\nif (ret) {\r\nkobject_put(&mem->dev.kobj);\r\nreturn ret;\r\n}\r\n}\r\nif (mem)\r\nkobject_put(&mem->dev.kobj);\r\nreturn 0;\r\n}\r\nstatic int check_memblock_offlined_cb(struct memory_block *mem, void *arg)\r\n{\r\nint ret = !is_memblock_offlined(mem);\r\nif (unlikely(ret)) {\r\nphys_addr_t beginpa, endpa;\r\nbeginpa = PFN_PHYS(section_nr_to_pfn(mem->start_section_nr));\r\nendpa = PFN_PHYS(section_nr_to_pfn(mem->end_section_nr + 1))-1;\r\npr_warn("removing memory fails, because memory "\r\n"[%pa-%pa] is onlined\n",\r\n&beginpa, &endpa);\r\n}\r\nreturn ret;\r\n}\r\nstatic int check_cpu_on_node(pg_data_t *pgdat)\r\n{\r\nint cpu;\r\nfor_each_present_cpu(cpu) {\r\nif (cpu_to_node(cpu) == pgdat->node_id)\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void unmap_cpu_on_node(pg_data_t *pgdat)\r\n{\r\n#ifdef CONFIG_ACPI_NUMA\r\nint cpu;\r\nfor_each_possible_cpu(cpu)\r\nif (cpu_to_node(cpu) == pgdat->node_id)\r\nnuma_clear_node(cpu);\r\n#endif\r\n}\r\nstatic int check_and_unmap_cpu_on_node(pg_data_t *pgdat)\r\n{\r\nint ret;\r\nret = check_cpu_on_node(pgdat);\r\nif (ret)\r\nreturn ret;\r\nunmap_cpu_on_node(pgdat);\r\nreturn 0;\r\n}\r\nvoid try_offline_node(int nid)\r\n{\r\npg_data_t *pgdat = NODE_DATA(nid);\r\nunsigned long start_pfn = pgdat->node_start_pfn;\r\nunsigned long end_pfn = start_pfn + pgdat->node_spanned_pages;\r\nunsigned long pfn;\r\nstruct page *pgdat_page = virt_to_page(pgdat);\r\nint i;\r\nfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\r\nunsigned long section_nr = pfn_to_section_nr(pfn);\r\nif (!present_section_nr(section_nr))\r\ncontinue;\r\nif (pfn_to_nid(pfn) != nid)\r\ncontinue;\r\nreturn;\r\n}\r\nif (check_and_unmap_cpu_on_node(pgdat))\r\nreturn;\r\nnode_set_offline(nid);\r\nunregister_one_node(nid);\r\nif (!PageSlab(pgdat_page) && !PageCompound(pgdat_page))\r\nreturn;\r\nfor (i = 0; i < MAX_NR_ZONES; i++) {\r\nstruct zone *zone = pgdat->node_zones + i;\r\nif (is_vmalloc_addr(zone->wait_table))\r\nvfree(zone->wait_table);\r\n}\r\nmemset(pgdat, 0, sizeof(*pgdat));\r\n}\r\nvoid __ref remove_memory(int nid, u64 start, u64 size)\r\n{\r\nint ret;\r\nBUG_ON(check_hotplug_memory_range(start, size));\r\nlock_memory_hotplug();\r\nret = walk_memory_range(PFN_DOWN(start), PFN_UP(start + size - 1), NULL,\r\ncheck_memblock_offlined_cb);\r\nif (ret) {\r\nunlock_memory_hotplug();\r\nBUG();\r\n}\r\nfirmware_map_remove(start, start + size, "System RAM");\r\narch_remove_memory(start, size);\r\ntry_offline_node(nid);\r\nunlock_memory_hotplug();\r\n}
