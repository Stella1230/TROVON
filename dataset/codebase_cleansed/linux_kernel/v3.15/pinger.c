int ptlrpc_pinger_suppress_pings(void)\r\n{\r\nreturn suppress_pings;\r\n}\r\nstruct ptlrpc_request *\r\nptlrpc_prep_ping(struct obd_import *imp)\r\n{\r\nstruct ptlrpc_request *req;\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_OBD_PING,\r\nLUSTRE_OBD_VERSION, OBD_PING);\r\nif (req) {\r\nptlrpc_request_set_replen(req);\r\nreq->rq_no_resend = req->rq_no_delay = 1;\r\n}\r\nreturn req;\r\n}\r\nint ptlrpc_obd_ping(struct obd_device *obd)\r\n{\r\nint rc;\r\nstruct ptlrpc_request *req;\r\nreq = ptlrpc_prep_ping(obd->u.cli.cl_import);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nreq->rq_send_state = LUSTRE_IMP_FULL;\r\nrc = ptlrpc_queue_wait(req);\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nint ptlrpc_ping(struct obd_import *imp)\r\n{\r\nstruct ptlrpc_request *req;\r\nreq = ptlrpc_prep_ping(imp);\r\nif (req == NULL) {\r\nCERROR("OOM trying to ping %s->%s\n",\r\nimp->imp_obd->obd_uuid.uuid,\r\nobd2cli_tgt(imp->imp_obd));\r\nreturn -ENOMEM;\r\n}\r\nDEBUG_REQ(D_INFO, req, "pinging %s->%s",\r\nimp->imp_obd->obd_uuid.uuid, obd2cli_tgt(imp->imp_obd));\r\nptlrpcd_add_req(req, PDL_POLICY_ROUND, -1);\r\nreturn 0;\r\n}\r\nvoid ptlrpc_update_next_ping(struct obd_import *imp, int soon)\r\n{\r\nint time = soon ? PING_INTERVAL_SHORT : PING_INTERVAL;\r\nif (imp->imp_state == LUSTRE_IMP_DISCON) {\r\nint dtime = max_t(int, CONNECTION_SWITCH_MIN,\r\nAT_OFF ? 0 :\r\nat_get(&imp->imp_at.iat_net_latency));\r\ntime = min(time, dtime);\r\n}\r\nimp->imp_next_ping = cfs_time_shift(time);\r\n}\r\nvoid ptlrpc_ping_import_soon(struct obd_import *imp)\r\n{\r\nimp->imp_next_ping = cfs_time_current();\r\n}\r\nstatic inline int imp_is_deactive(struct obd_import *imp)\r\n{\r\nreturn (imp->imp_deactive ||\r\nOBD_FAIL_CHECK(OBD_FAIL_PTLRPC_IMP_DEACTIVE));\r\n}\r\nstatic inline int ptlrpc_next_reconnect(struct obd_import *imp)\r\n{\r\nif (imp->imp_server_timeout)\r\nreturn cfs_time_shift(obd_timeout / 2);\r\nelse\r\nreturn cfs_time_shift(obd_timeout);\r\n}\r\ncfs_duration_t pinger_check_timeout(cfs_time_t time)\r\n{\r\nstruct timeout_item *item;\r\ncfs_time_t timeout = PING_INTERVAL;\r\nmutex_lock(&pinger_mutex);\r\nlist_for_each_entry(item, &timeout_list, ti_chain) {\r\nint ti_timeout = item->ti_timeout;\r\nif (timeout > ti_timeout)\r\ntimeout = ti_timeout;\r\nbreak;\r\n}\r\nmutex_unlock(&pinger_mutex);\r\nreturn cfs_time_sub(cfs_time_add(time, cfs_time_seconds(timeout)),\r\ncfs_time_current());\r\n}\r\nvoid ptlrpc_pinger_ir_up(void)\r\n{\r\nCDEBUG(D_HA, "IR up\n");\r\nir_up = true;\r\n}\r\nvoid ptlrpc_pinger_ir_down(void)\r\n{\r\nCDEBUG(D_HA, "IR down\n");\r\nir_up = false;\r\n}\r\nstatic void ptlrpc_pinger_process_import(struct obd_import *imp,\r\nunsigned long this_ping)\r\n{\r\nint level;\r\nint force;\r\nint force_next;\r\nint suppress;\r\nspin_lock(&imp->imp_lock);\r\nlevel = imp->imp_state;\r\nforce = imp->imp_force_verify;\r\nforce_next = imp->imp_force_next_verify;\r\nsuppress = ir_up && OCD_HAS_FLAG(&imp->imp_connect_data, PINGLESS);\r\nimp->imp_force_verify = 0;\r\nif (cfs_time_aftereq(imp->imp_next_ping - 5 * CFS_TICK, this_ping) &&\r\n!force) {\r\nspin_unlock(&imp->imp_lock);\r\nreturn;\r\n}\r\nimp->imp_force_next_verify = 0;\r\nspin_unlock(&imp->imp_lock);\r\nCDEBUG(level == LUSTRE_IMP_FULL ? D_INFO : D_HA, "%s->%s: level %s/%u "\r\n"force %u force_next %u deactive %u pingable %u suppress %u\n",\r\nimp->imp_obd->obd_uuid.uuid, obd2cli_tgt(imp->imp_obd),\r\nptlrpc_import_state_name(level), level, force, force_next,\r\nimp->imp_deactive, imp->imp_pingable, suppress);\r\nif (level == LUSTRE_IMP_DISCON && !imp_is_deactive(imp)) {\r\nimp->imp_next_ping = ptlrpc_next_reconnect(imp);\r\nif (!imp->imp_no_pinger_recover)\r\nptlrpc_initiate_recovery(imp);\r\n} else if (level != LUSTRE_IMP_FULL ||\r\nimp->imp_obd->obd_no_recov ||\r\nimp_is_deactive(imp)) {\r\nCDEBUG(D_HA, "%s->%s: not pinging (in recovery "\r\n"or recovery disabled: %s)\n",\r\nimp->imp_obd->obd_uuid.uuid, obd2cli_tgt(imp->imp_obd),\r\nptlrpc_import_state_name(level));\r\n} else if ((imp->imp_pingable && !suppress) || force_next || force) {\r\nptlrpc_ping(imp);\r\n}\r\n}\r\nstatic int ptlrpc_pinger_main(void *arg)\r\n{\r\nstruct ptlrpc_thread *thread = (struct ptlrpc_thread *)arg;\r\nthread_set_flags(thread, SVC_RUNNING);\r\nwake_up(&thread->t_ctl_waitq);\r\nwhile (1) {\r\ncfs_time_t this_ping = cfs_time_current();\r\nstruct l_wait_info lwi;\r\ncfs_duration_t time_to_next_wake;\r\nstruct timeout_item *item;\r\nstruct list_head *iter;\r\nmutex_lock(&pinger_mutex);\r\nlist_for_each_entry(item, &timeout_list, ti_chain) {\r\nitem->ti_cb(item, item->ti_cb_data);\r\n}\r\nlist_for_each(iter, &pinger_imports) {\r\nstruct obd_import *imp =\r\nlist_entry(iter, struct obd_import,\r\nimp_pinger_chain);\r\nptlrpc_pinger_process_import(imp, this_ping);\r\nif (imp->imp_pingable && imp->imp_next_ping &&\r\ncfs_time_after(imp->imp_next_ping,\r\ncfs_time_add(this_ping,\r\ncfs_time_seconds(PING_INTERVAL))))\r\nptlrpc_update_next_ping(imp, 0);\r\n}\r\nmutex_unlock(&pinger_mutex);\r\nobd_update_maxusage();\r\ntime_to_next_wake = pinger_check_timeout(this_ping);\r\nCDEBUG(D_INFO, "next wakeup in "CFS_DURATION_T" ("\r\nCFS_TIME_T")\n", time_to_next_wake,\r\ncfs_time_add(this_ping,cfs_time_seconds(PING_INTERVAL)));\r\nif (time_to_next_wake > 0) {\r\nlwi = LWI_TIMEOUT(max_t(cfs_duration_t,\r\ntime_to_next_wake,\r\ncfs_time_seconds(1)),\r\nNULL, NULL);\r\nl_wait_event(thread->t_ctl_waitq,\r\nthread_is_stopping(thread) ||\r\nthread_is_event(thread),\r\n&lwi);\r\nif (thread_test_and_clear_flags(thread, SVC_STOPPING)) {\r\nbreak;\r\n} else {\r\nthread_test_and_clear_flags(thread, SVC_EVENT);\r\n}\r\n}\r\n}\r\nthread_set_flags(thread, SVC_STOPPED);\r\nwake_up(&thread->t_ctl_waitq);\r\nCDEBUG(D_NET, "pinger thread exiting, process %d\n", current_pid());\r\nreturn 0;\r\n}\r\nint ptlrpc_start_pinger(void)\r\n{\r\nstruct l_wait_info lwi = { 0 };\r\nint rc;\r\nif (!thread_is_init(&pinger_thread) &&\r\n!thread_is_stopped(&pinger_thread))\r\nreturn -EALREADY;\r\ninit_waitqueue_head(&pinger_thread.t_ctl_waitq);\r\nstrcpy(pinger_thread.t_name, "ll_ping");\r\nrc = PTR_ERR(kthread_run(ptlrpc_pinger_main, &pinger_thread,\r\n"%s", pinger_thread.t_name));\r\nif (IS_ERR_VALUE(rc)) {\r\nCERROR("cannot start thread: %d\n", rc);\r\nreturn rc;\r\n}\r\nl_wait_event(pinger_thread.t_ctl_waitq,\r\nthread_is_running(&pinger_thread), &lwi);\r\nif (suppress_pings)\r\nCWARN("Pings will be suppressed at the request of the "\r\n"administrator. The configuration shall meet the "\r\n"additional requirements described in the manual. "\r\n"(Search for the \"suppress_pings\" kernel module "\r\n"parameter.)\n");\r\nreturn 0;\r\n}\r\nint ptlrpc_stop_pinger(void)\r\n{\r\nstruct l_wait_info lwi = { 0 };\r\nint rc = 0;\r\nif (thread_is_init(&pinger_thread) ||\r\nthread_is_stopped(&pinger_thread))\r\nreturn -EALREADY;\r\nptlrpc_pinger_remove_timeouts();\r\nthread_set_flags(&pinger_thread, SVC_STOPPING);\r\nwake_up(&pinger_thread.t_ctl_waitq);\r\nl_wait_event(pinger_thread.t_ctl_waitq,\r\nthread_is_stopped(&pinger_thread), &lwi);\r\nreturn rc;\r\n}\r\nvoid ptlrpc_pinger_sending_on_import(struct obd_import *imp)\r\n{\r\nptlrpc_update_next_ping(imp, 0);\r\n}\r\nvoid ptlrpc_pinger_commit_expected(struct obd_import *imp)\r\n{\r\nptlrpc_update_next_ping(imp, 1);\r\nLASSERT(spin_is_locked(&imp->imp_lock));\r\nif (imp->imp_state != LUSTRE_IMP_FULL ||\r\nOCD_HAS_FLAG(&imp->imp_connect_data, PINGLESS))\r\nimp->imp_force_next_verify = 1;\r\n}\r\nint ptlrpc_pinger_add_import(struct obd_import *imp)\r\n{\r\nif (!list_empty(&imp->imp_pinger_chain))\r\nreturn -EALREADY;\r\nmutex_lock(&pinger_mutex);\r\nCDEBUG(D_HA, "adding pingable import %s->%s\n",\r\nimp->imp_obd->obd_uuid.uuid, obd2cli_tgt(imp->imp_obd));\r\nimp->imp_obd->obd_no_recov = 0;\r\nptlrpc_update_next_ping(imp, 0);\r\nlist_add_tail(&imp->imp_pinger_chain, &pinger_imports);\r\nclass_import_get(imp);\r\nptlrpc_pinger_wake_up();\r\nmutex_unlock(&pinger_mutex);\r\nreturn 0;\r\n}\r\nint ptlrpc_pinger_del_import(struct obd_import *imp)\r\n{\r\nif (list_empty(&imp->imp_pinger_chain))\r\nreturn -ENOENT;\r\nmutex_lock(&pinger_mutex);\r\nlist_del_init(&imp->imp_pinger_chain);\r\nCDEBUG(D_HA, "removing pingable import %s->%s\n",\r\nimp->imp_obd->obd_uuid.uuid, obd2cli_tgt(imp->imp_obd));\r\nimp->imp_obd->obd_no_recov = 1;\r\nclass_import_put(imp);\r\nmutex_unlock(&pinger_mutex);\r\nreturn 0;\r\n}\r\nstruct timeout_item* ptlrpc_new_timeout(int time, enum timeout_event event,\r\ntimeout_cb_t cb, void *data)\r\n{\r\nstruct timeout_item *ti;\r\nOBD_ALLOC_PTR(ti);\r\nif (!ti)\r\nreturn(NULL);\r\nINIT_LIST_HEAD(&ti->ti_obd_list);\r\nINIT_LIST_HEAD(&ti->ti_chain);\r\nti->ti_timeout = time;\r\nti->ti_event = event;\r\nti->ti_cb = cb;\r\nti->ti_cb_data = data;\r\nreturn ti;\r\n}\r\nstatic struct timeout_item*\r\nptlrpc_pinger_register_timeout(int time, enum timeout_event event,\r\ntimeout_cb_t cb, void *data)\r\n{\r\nstruct timeout_item *item, *tmp;\r\nLASSERT(mutex_is_locked(&pinger_mutex));\r\nlist_for_each_entry(item, &timeout_list, ti_chain)\r\nif (item->ti_event == event)\r\ngoto out;\r\nitem = ptlrpc_new_timeout(time, event, cb, data);\r\nif (item) {\r\nlist_for_each_entry_reverse(tmp, &timeout_list, ti_chain) {\r\nif (tmp->ti_timeout < time) {\r\nlist_add(&item->ti_chain, &tmp->ti_chain);\r\ngoto out;\r\n}\r\n}\r\nlist_add(&item->ti_chain, &timeout_list);\r\n}\r\nout:\r\nreturn item;\r\n}\r\nint ptlrpc_add_timeout_client(int time, enum timeout_event event,\r\ntimeout_cb_t cb, void *data,\r\nstruct list_head *obd_list)\r\n{\r\nstruct timeout_item *ti;\r\nmutex_lock(&pinger_mutex);\r\nti = ptlrpc_pinger_register_timeout(time, event, cb, data);\r\nif (!ti) {\r\nmutex_unlock(&pinger_mutex);\r\nreturn (-EINVAL);\r\n}\r\nlist_add(obd_list, &ti->ti_obd_list);\r\nmutex_unlock(&pinger_mutex);\r\nreturn 0;\r\n}\r\nint ptlrpc_del_timeout_client(struct list_head *obd_list,\r\nenum timeout_event event)\r\n{\r\nstruct timeout_item *ti = NULL, *item;\r\nif (list_empty(obd_list))\r\nreturn 0;\r\nmutex_lock(&pinger_mutex);\r\nlist_del_init(obd_list);\r\nlist_for_each_entry(item, &timeout_list, ti_chain) {\r\nif (item->ti_event == event) {\r\nti = item;\r\nbreak;\r\n}\r\n}\r\nLASSERTF(ti != NULL, "ti is NULL !\n");\r\nif (list_empty(&ti->ti_obd_list)) {\r\nlist_del(&ti->ti_chain);\r\nOBD_FREE_PTR(ti);\r\n}\r\nmutex_unlock(&pinger_mutex);\r\nreturn 0;\r\n}\r\nint ptlrpc_pinger_remove_timeouts(void)\r\n{\r\nstruct timeout_item *item, *tmp;\r\nmutex_lock(&pinger_mutex);\r\nlist_for_each_entry_safe(item, tmp, &timeout_list, ti_chain) {\r\nLASSERT(list_empty(&item->ti_obd_list));\r\nlist_del(&item->ti_chain);\r\nOBD_FREE_PTR(item);\r\n}\r\nmutex_unlock(&pinger_mutex);\r\nreturn 0;\r\n}\r\nvoid ptlrpc_pinger_wake_up(void)\r\n{\r\nthread_add_flags(&pinger_thread, SVC_EVENT);\r\nwake_up(&pinger_thread.t_ctl_waitq);\r\n}\r\nint ping_evictor_wake(struct obd_export *exp)\r\n{\r\nstruct obd_device *obd;\r\nspin_lock(&pet_lock);\r\nif (pet_state != PET_READY) {\r\nspin_unlock(&pet_lock);\r\nreturn 1;\r\n}\r\nobd = class_exp2obd(exp);\r\nif (list_empty(&obd->obd_evict_list)) {\r\nclass_incref(obd, "evictor", obd);\r\nlist_add(&obd->obd_evict_list, &pet_list);\r\n}\r\nspin_unlock(&pet_lock);\r\nwake_up(&pet_waitq);\r\nreturn 0;\r\n}\r\nstatic int ping_evictor_main(void *arg)\r\n{\r\nstruct obd_device *obd;\r\nstruct obd_export *exp;\r\nstruct l_wait_info lwi = { 0 };\r\ntime_t expire_time;\r\nunshare_fs_struct();\r\nCDEBUG(D_HA, "Starting Ping Evictor\n");\r\npet_state = PET_READY;\r\nwhile (1) {\r\nl_wait_event(pet_waitq, (!list_empty(&pet_list)) ||\r\n(pet_state == PET_TERMINATE), &lwi);\r\nif ((pet_state == PET_TERMINATE) && list_empty(&pet_list))\r\nbreak;\r\nspin_lock(&pet_lock);\r\nobd = list_entry(pet_list.next, struct obd_device,\r\nobd_evict_list);\r\nspin_unlock(&pet_lock);\r\nexpire_time = cfs_time_current_sec() - PING_EVICT_TIMEOUT;\r\nCDEBUG(D_HA, "evicting all exports of obd %s older than %ld\n",\r\nobd->obd_name, expire_time);\r\nspin_lock(&obd->obd_dev_lock);\r\nwhile (!list_empty(&obd->obd_exports_timed)) {\r\nexp = list_entry(obd->obd_exports_timed.next,\r\nstruct obd_export,\r\nexp_obd_chain_timed);\r\nif (expire_time > exp->exp_last_request_time) {\r\nclass_export_get(exp);\r\nspin_unlock(&obd->obd_dev_lock);\r\nLCONSOLE_WARN("%s: haven't heard from client %s"\r\n" (at %s) in %ld seconds. I think"\r\n" it's dead, and I am evicting"\r\n" it. exp %p, cur %ld expire %ld"\r\n" last %ld\n",\r\nobd->obd_name,\r\nobd_uuid2str(&exp->exp_client_uuid),\r\nobd_export_nid2str(exp),\r\n(long)(cfs_time_current_sec() -\r\nexp->exp_last_request_time),\r\nexp, (long)cfs_time_current_sec(),\r\n(long)expire_time,\r\n(long)exp->exp_last_request_time);\r\nCDEBUG(D_HA, "Last request was at %ld\n",\r\nexp->exp_last_request_time);\r\nclass_fail_export(exp);\r\nclass_export_put(exp);\r\nspin_lock(&obd->obd_dev_lock);\r\n} else {\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&obd->obd_dev_lock);\r\nspin_lock(&pet_lock);\r\nlist_del_init(&obd->obd_evict_list);\r\nspin_unlock(&pet_lock);\r\nclass_decref(obd, "evictor", obd);\r\n}\r\nCDEBUG(D_HA, "Exiting Ping Evictor\n");\r\nreturn 0;\r\n}\r\nvoid ping_evictor_start(void)\r\n{\r\nstruct task_struct *task;\r\nif (++pet_refcount > 1)\r\nreturn;\r\ninit_waitqueue_head(&pet_waitq);\r\ntask = kthread_run(ping_evictor_main, NULL, "ll_evictor");\r\nif (IS_ERR(task)) {\r\npet_refcount--;\r\nCERROR("Cannot start ping evictor thread: %ld\n",\r\nPTR_ERR(task));\r\n}\r\n}\r\nvoid ping_evictor_stop(void)\r\n{\r\nif (--pet_refcount > 0)\r\nreturn;\r\npet_state = PET_TERMINATE;\r\nwake_up(&pet_waitq);\r\n}
