static int s6e63m0_spi_write_byte(struct s6e63m0 *lcd, int addr, int data)\r\n{\r\nu16 buf[1];\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 2,\r\n.tx_buf = buf,\r\n};\r\nbuf[0] = (addr << 8) | data;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nreturn spi_sync(lcd->spi, &msg);\r\n}\r\nstatic int s6e63m0_spi_write(struct s6e63m0 *lcd, unsigned char address,\r\nunsigned char command)\r\n{\r\nint ret = 0;\r\nif (address != DATA_ONLY)\r\nret = s6e63m0_spi_write_byte(lcd, 0x0, address);\r\nif (command != COMMAND_ONLY)\r\nret = s6e63m0_spi_write_byte(lcd, 0x1, command);\r\nreturn ret;\r\n}\r\nstatic int s6e63m0_panel_send_sequence(struct s6e63m0 *lcd,\r\nconst unsigned short *wbuf)\r\n{\r\nint ret = 0, i = 0;\r\nwhile ((wbuf[i] & DEFMASK) != ENDDEF) {\r\nif ((wbuf[i] & DEFMASK) != SLEEPMSEC) {\r\nret = s6e63m0_spi_write(lcd, wbuf[i], wbuf[i+1]);\r\nif (ret)\r\nbreak;\r\n} else {\r\nmsleep(wbuf[i+1]);\r\n}\r\ni += 2;\r\n}\r\nreturn ret;\r\n}\r\nstatic int _s6e63m0_gamma_ctl(struct s6e63m0 *lcd, const unsigned int *gamma)\r\n{\r\nunsigned int i = 0;\r\nint ret = 0;\r\nret = s6e63m0_spi_write(lcd, 0xfa, 0x00);\r\nif (ret) {\r\ndev_err(lcd->dev, "failed to disable gamma table updating.\n");\r\ngoto gamma_err;\r\n}\r\nfor (i = 0 ; i < GAMMA_TABLE_COUNT; i++) {\r\nret = s6e63m0_spi_write(lcd, DATA_ONLY, gamma[i]);\r\nif (ret) {\r\ndev_err(lcd->dev, "failed to set gamma table.\n");\r\ngoto gamma_err;\r\n}\r\n}\r\nret = s6e63m0_spi_write(lcd, 0xfa, 0x01);\r\nif (ret)\r\ndev_err(lcd->dev, "failed to update gamma table.\n");\r\ngamma_err:\r\nreturn ret;\r\n}\r\nstatic int s6e63m0_gamma_ctl(struct s6e63m0 *lcd, int gamma)\r\n{\r\nint ret = 0;\r\nret = _s6e63m0_gamma_ctl(lcd, gamma_table.gamma_22_table[gamma]);\r\nreturn ret;\r\n}\r\nstatic int s6e63m0_ldi_init(struct s6e63m0 *lcd)\r\n{\r\nint ret, i;\r\nconst unsigned short *init_seq[] = {\r\nseq_panel_condition_set,\r\nseq_display_condition_set,\r\nseq_gamma_setting,\r\nseq_etc_condition_set,\r\nseq_acl_on,\r\nseq_elvss_on,\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(init_seq); i++) {\r\nret = s6e63m0_panel_send_sequence(lcd, init_seq[i]);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int s6e63m0_ldi_enable(struct s6e63m0 *lcd)\r\n{\r\nint ret = 0, i;\r\nconst unsigned short *enable_seq[] = {\r\nseq_stand_by_off,\r\nseq_display_on,\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(enable_seq); i++) {\r\nret = s6e63m0_panel_send_sequence(lcd, enable_seq[i]);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int s6e63m0_ldi_disable(struct s6e63m0 *lcd)\r\n{\r\nint ret;\r\nret = s6e63m0_panel_send_sequence(lcd, seq_stand_by_on);\r\nreturn ret;\r\n}\r\nstatic int s6e63m0_power_is_on(int power)\r\n{\r\nreturn power <= FB_BLANK_NORMAL;\r\n}\r\nstatic int s6e63m0_power_on(struct s6e63m0 *lcd)\r\n{\r\nint ret = 0;\r\nstruct lcd_platform_data *pd;\r\nstruct backlight_device *bd;\r\npd = lcd->lcd_pd;\r\nbd = lcd->bd;\r\nif (!pd->power_on) {\r\ndev_err(lcd->dev, "power_on is NULL.\n");\r\nreturn -EINVAL;\r\n} else {\r\npd->power_on(lcd->ld, 1);\r\nmsleep(pd->power_on_delay);\r\n}\r\nif (!pd->reset) {\r\ndev_err(lcd->dev, "reset is NULL.\n");\r\nreturn -EINVAL;\r\n} else {\r\npd->reset(lcd->ld);\r\nmsleep(pd->reset_delay);\r\n}\r\nret = s6e63m0_ldi_init(lcd);\r\nif (ret) {\r\ndev_err(lcd->dev, "failed to initialize ldi.\n");\r\nreturn ret;\r\n}\r\nret = s6e63m0_ldi_enable(lcd);\r\nif (ret) {\r\ndev_err(lcd->dev, "failed to enable ldi.\n");\r\nreturn ret;\r\n}\r\nret = s6e63m0_gamma_ctl(lcd, bd->props.brightness);\r\nif (ret) {\r\ndev_err(lcd->dev, "lcd gamma setting failed.\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s6e63m0_power_off(struct s6e63m0 *lcd)\r\n{\r\nint ret;\r\nstruct lcd_platform_data *pd;\r\npd = lcd->lcd_pd;\r\nret = s6e63m0_ldi_disable(lcd);\r\nif (ret) {\r\ndev_err(lcd->dev, "lcd setting failed.\n");\r\nreturn -EIO;\r\n}\r\nmsleep(pd->power_off_delay);\r\npd->power_on(lcd->ld, 0);\r\nreturn 0;\r\n}\r\nstatic int s6e63m0_power(struct s6e63m0 *lcd, int power)\r\n{\r\nint ret = 0;\r\nif (s6e63m0_power_is_on(power) && !s6e63m0_power_is_on(lcd->power))\r\nret = s6e63m0_power_on(lcd);\r\nelse if (!s6e63m0_power_is_on(power) && s6e63m0_power_is_on(lcd->power))\r\nret = s6e63m0_power_off(lcd);\r\nif (!ret)\r\nlcd->power = power;\r\nreturn ret;\r\n}\r\nstatic int s6e63m0_set_power(struct lcd_device *ld, int power)\r\n{\r\nstruct s6e63m0 *lcd = lcd_get_data(ld);\r\nif (power != FB_BLANK_UNBLANK && power != FB_BLANK_POWERDOWN &&\r\npower != FB_BLANK_NORMAL) {\r\ndev_err(lcd->dev, "power value should be 0, 1 or 4.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn s6e63m0_power(lcd, power);\r\n}\r\nstatic int s6e63m0_get_power(struct lcd_device *ld)\r\n{\r\nstruct s6e63m0 *lcd = lcd_get_data(ld);\r\nreturn lcd->power;\r\n}\r\nstatic int s6e63m0_get_brightness(struct backlight_device *bd)\r\n{\r\nreturn bd->props.brightness;\r\n}\r\nstatic int s6e63m0_set_brightness(struct backlight_device *bd)\r\n{\r\nint ret = 0, brightness = bd->props.brightness;\r\nstruct s6e63m0 *lcd = bl_get_data(bd);\r\nif (brightness < MIN_BRIGHTNESS ||\r\nbrightness > bd->props.max_brightness) {\r\ndev_err(&bd->dev, "lcd brightness should be %d to %d.\n",\r\nMIN_BRIGHTNESS, MAX_BRIGHTNESS);\r\nreturn -EINVAL;\r\n}\r\nret = s6e63m0_gamma_ctl(lcd, bd->props.brightness);\r\nif (ret) {\r\ndev_err(&bd->dev, "lcd brightness setting failed.\n");\r\nreturn -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t s6e63m0_sysfs_show_gamma_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct s6e63m0 *lcd = dev_get_drvdata(dev);\r\nchar temp[10];\r\nswitch (lcd->gamma_mode) {\r\ncase 0:\r\nsprintf(temp, "2.2 mode\n");\r\nstrcat(buf, temp);\r\nbreak;\r\ncase 1:\r\nsprintf(temp, "1.9 mode\n");\r\nstrcat(buf, temp);\r\nbreak;\r\ncase 2:\r\nsprintf(temp, "1.7 mode\n");\r\nstrcat(buf, temp);\r\nbreak;\r\ndefault:\r\ndev_info(dev, "gamma mode could be 0:2.2, 1:1.9 or 2:1.7)n");\r\nbreak;\r\n}\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t s6e63m0_sysfs_store_gamma_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct s6e63m0 *lcd = dev_get_drvdata(dev);\r\nstruct backlight_device *bd = NULL;\r\nint brightness, rc;\r\nrc = kstrtouint(buf, 0, &lcd->gamma_mode);\r\nif (rc < 0)\r\nreturn rc;\r\nbd = lcd->bd;\r\nbrightness = bd->props.brightness;\r\nswitch (lcd->gamma_mode) {\r\ncase 0:\r\n_s6e63m0_gamma_ctl(lcd, gamma_table.gamma_22_table[brightness]);\r\nbreak;\r\ncase 1:\r\n_s6e63m0_gamma_ctl(lcd, gamma_table.gamma_19_table[brightness]);\r\nbreak;\r\ncase 2:\r\n_s6e63m0_gamma_ctl(lcd, gamma_table.gamma_17_table[brightness]);\r\nbreak;\r\ndefault:\r\ndev_info(dev, "gamma mode could be 0:2.2, 1:1.9 or 2:1.7\n");\r\n_s6e63m0_gamma_ctl(lcd, gamma_table.gamma_22_table[brightness]);\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t s6e63m0_sysfs_show_gamma_table(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct s6e63m0 *lcd = dev_get_drvdata(dev);\r\nchar temp[3];\r\nsprintf(temp, "%d\n", lcd->gamma_table_count);\r\nstrcpy(buf, temp);\r\nreturn strlen(buf);\r\n}\r\nstatic int s6e63m0_probe(struct spi_device *spi)\r\n{\r\nint ret = 0;\r\nstruct s6e63m0 *lcd = NULL;\r\nstruct lcd_device *ld = NULL;\r\nstruct backlight_device *bd = NULL;\r\nstruct backlight_properties props;\r\nlcd = devm_kzalloc(&spi->dev, sizeof(struct s6e63m0), GFP_KERNEL);\r\nif (!lcd)\r\nreturn -ENOMEM;\r\nspi->bits_per_word = 9;\r\nret = spi_setup(spi);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "spi setup failed.\n");\r\nreturn ret;\r\n}\r\nlcd->spi = spi;\r\nlcd->dev = &spi->dev;\r\nlcd->lcd_pd = dev_get_platdata(&spi->dev);\r\nif (!lcd->lcd_pd) {\r\ndev_err(&spi->dev, "platform data is NULL.\n");\r\nreturn -EINVAL;\r\n}\r\nld = devm_lcd_device_register(&spi->dev, "s6e63m0", &spi->dev, lcd,\r\n&s6e63m0_lcd_ops);\r\nif (IS_ERR(ld))\r\nreturn PTR_ERR(ld);\r\nlcd->ld = ld;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = MAX_BRIGHTNESS;\r\nbd = devm_backlight_device_register(&spi->dev, "s6e63m0bl-bl",\r\n&spi->dev, lcd, &s6e63m0_backlight_ops,\r\n&props);\r\nif (IS_ERR(bd))\r\nreturn PTR_ERR(bd);\r\nbd->props.brightness = MAX_BRIGHTNESS;\r\nlcd->bd = bd;\r\nlcd->gamma_table_count =\r\nsizeof(gamma_table) / (MAX_GAMMA_LEVEL * sizeof(int *));\r\nret = device_create_file(&(spi->dev), &dev_attr_gamma_mode);\r\nif (ret < 0)\r\ndev_err(&(spi->dev), "failed to add sysfs entries\n");\r\nret = device_create_file(&(spi->dev), &dev_attr_gamma_table);\r\nif (ret < 0)\r\ndev_err(&(spi->dev), "failed to add sysfs entries\n");\r\nif (!lcd->lcd_pd->lcd_enabled) {\r\nlcd->power = FB_BLANK_POWERDOWN;\r\ns6e63m0_power(lcd, FB_BLANK_UNBLANK);\r\n} else {\r\nlcd->power = FB_BLANK_UNBLANK;\r\n}\r\nspi_set_drvdata(spi, lcd);\r\ndev_info(&spi->dev, "s6e63m0 panel driver has been probed.\n");\r\nreturn 0;\r\n}\r\nstatic int s6e63m0_remove(struct spi_device *spi)\r\n{\r\nstruct s6e63m0 *lcd = spi_get_drvdata(spi);\r\ns6e63m0_power(lcd, FB_BLANK_POWERDOWN);\r\ndevice_remove_file(&spi->dev, &dev_attr_gamma_table);\r\ndevice_remove_file(&spi->dev, &dev_attr_gamma_mode);\r\nreturn 0;\r\n}\r\nstatic int s6e63m0_suspend(struct device *dev)\r\n{\r\nstruct s6e63m0 *lcd = dev_get_drvdata(dev);\r\ndev_dbg(dev, "lcd->power = %d\n", lcd->power);\r\nreturn s6e63m0_power(lcd, FB_BLANK_POWERDOWN);\r\n}\r\nstatic int s6e63m0_resume(struct device *dev)\r\n{\r\nstruct s6e63m0 *lcd = dev_get_drvdata(dev);\r\nlcd->power = FB_BLANK_POWERDOWN;\r\nreturn s6e63m0_power(lcd, FB_BLANK_UNBLANK);\r\n}\r\nstatic void s6e63m0_shutdown(struct spi_device *spi)\r\n{\r\nstruct s6e63m0 *lcd = spi_get_drvdata(spi);\r\ns6e63m0_power(lcd, FB_BLANK_POWERDOWN);\r\n}
