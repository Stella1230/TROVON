static inline unsigned int usbatm_pdu_length(unsigned int length)\r\n{\r\nlength += ATM_CELL_PAYLOAD - 1 + ATM_AAL5_TRAILER;\r\nreturn length - length % ATM_CELL_PAYLOAD;\r\n}\r\nstatic inline void usbatm_pop(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nif (vcc->pop)\r\nvcc->pop(vcc, skb);\r\nelse\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic struct urb *usbatm_pop_urb(struct usbatm_channel *channel)\r\n{\r\nstruct urb *urb;\r\nspin_lock_irq(&channel->lock);\r\nif (list_empty(&channel->list)) {\r\nspin_unlock_irq(&channel->lock);\r\nreturn NULL;\r\n}\r\nurb = list_entry(channel->list.next, struct urb, urb_list);\r\nlist_del(&urb->urb_list);\r\nspin_unlock_irq(&channel->lock);\r\nreturn urb;\r\n}\r\nstatic int usbatm_submit_urb(struct urb *urb)\r\n{\r\nstruct usbatm_channel *channel = urb->context;\r\nint ret;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret) {\r\nif (printk_ratelimit())\r\natm_warn(channel->usbatm, "%s: urb 0x%p submission failed (%d)!\n",\r\n__func__, urb, ret);\r\nurb->status = -EAGAIN;\r\nspin_lock_irq(&channel->lock);\r\nlist_add(&urb->urb_list, &channel->list);\r\nspin_unlock_irq(&channel->lock);\r\nmod_timer(&channel->delay, jiffies + msecs_to_jiffies(THROTTLE_MSECS));\r\n}\r\nreturn ret;\r\n}\r\nstatic void usbatm_complete(struct urb *urb)\r\n{\r\nstruct usbatm_channel *channel = urb->context;\r\nunsigned long flags;\r\nint status = urb->status;\r\nspin_lock_irqsave(&channel->lock, flags);\r\nlist_add_tail(&urb->urb_list, &channel->list);\r\nspin_unlock_irqrestore(&channel->lock, flags);\r\nif (unlikely(status) &&\r\n(!(channel->usbatm->flags & UDSL_IGNORE_EILSEQ) ||\r\nstatus != -EILSEQ)) {\r\nif (status == -ESHUTDOWN)\r\nreturn;\r\nif (printk_ratelimit())\r\natm_warn(channel->usbatm, "%s: urb 0x%p failed (%d)!\n",\r\n__func__, urb, status);\r\nmod_timer(&channel->delay, jiffies + msecs_to_jiffies(THROTTLE_MSECS));\r\n} else\r\ntasklet_schedule(&channel->tasklet);\r\n}\r\nstatic inline struct usbatm_vcc_data *usbatm_find_vcc(struct usbatm_data *instance,\r\nshort vpi, int vci)\r\n{\r\nstruct usbatm_vcc_data *vcc_data;\r\nlist_for_each_entry(vcc_data, &instance->vcc_list, list)\r\nif ((vcc_data->vci == vci) && (vcc_data->vpi == vpi))\r\nreturn vcc_data;\r\nreturn NULL;\r\n}\r\nstatic void usbatm_extract_one_cell(struct usbatm_data *instance, unsigned char *source)\r\n{\r\nstruct atm_vcc *vcc;\r\nstruct sk_buff *sarb;\r\nshort vpi = ((source[0] & 0x0f) << 4) | (source[1] >> 4);\r\nint vci = ((source[1] & 0x0f) << 12) | (source[2] << 4) | (source[3] >> 4);\r\nu8 pti = ((source[3] & 0xe) >> 1);\r\nif ((vci != instance->cached_vci) || (vpi != instance->cached_vpi)) {\r\ninstance->cached_vpi = vpi;\r\ninstance->cached_vci = vci;\r\ninstance->cached_vcc = usbatm_find_vcc(instance, vpi, vci);\r\nif (!instance->cached_vcc)\r\natm_rldbg(instance, "%s: unknown vpi/vci (%hd/%d)!\n", __func__, vpi, vci);\r\n}\r\nif (!instance->cached_vcc)\r\nreturn;\r\nvcc = instance->cached_vcc->vcc;\r\nif (pti == ATM_PTI_E2EF5) {\r\nif (printk_ratelimit())\r\natm_warn(instance, "%s: OAM not supported (vpi %d, vci %d)!\n",\r\n__func__, vpi, vci);\r\natomic_inc(&vcc->stats->rx_err);\r\nreturn;\r\n}\r\nsarb = instance->cached_vcc->sarb;\r\nif (sarb->tail + ATM_CELL_PAYLOAD > sarb->end) {\r\natm_rldbg(instance, "%s: buffer overrun (sarb->len %u, vcc: 0x%p)!\n",\r\n__func__, sarb->len, vcc);\r\nskb_trim(sarb, 0);\r\n}\r\nmemcpy(skb_tail_pointer(sarb), source + ATM_CELL_HEADER, ATM_CELL_PAYLOAD);\r\n__skb_put(sarb, ATM_CELL_PAYLOAD);\r\nif (pti & 1) {\r\nstruct sk_buff *skb;\r\nunsigned int length;\r\nunsigned int pdu_length;\r\nlength = (source[ATM_CELL_SIZE - 6] << 8) + source[ATM_CELL_SIZE - 5];\r\nif (length > ATM_MAX_AAL5_PDU) {\r\natm_rldbg(instance, "%s: bogus length %u (vcc: 0x%p)!\n",\r\n__func__, length, vcc);\r\natomic_inc(&vcc->stats->rx_err);\r\ngoto out;\r\n}\r\npdu_length = usbatm_pdu_length(length);\r\nif (sarb->len < pdu_length) {\r\natm_rldbg(instance, "%s: bogus pdu_length %u (sarb->len: %u, vcc: 0x%p)!\n",\r\n__func__, pdu_length, sarb->len, vcc);\r\natomic_inc(&vcc->stats->rx_err);\r\ngoto out;\r\n}\r\nif (crc32_be(~0, skb_tail_pointer(sarb) - pdu_length, pdu_length) != 0xc704dd7b) {\r\natm_rldbg(instance, "%s: packet failed crc check (vcc: 0x%p)!\n",\r\n__func__, vcc);\r\natomic_inc(&vcc->stats->rx_err);\r\ngoto out;\r\n}\r\nvdbg(&instance->usb_intf->dev,\r\n"%s: got packet (length: %u, pdu_length: %u, vcc: 0x%p)",\r\n__func__, length, pdu_length, vcc);\r\nif (!(skb = dev_alloc_skb(length))) {\r\nif (printk_ratelimit())\r\natm_err(instance, "%s: no memory for skb (length: %u)!\n",\r\n__func__, length);\r\natomic_inc(&vcc->stats->rx_drop);\r\ngoto out;\r\n}\r\nvdbg(&instance->usb_intf->dev,\r\n"%s: allocated new sk_buff (skb: 0x%p, skb->truesize: %u)",\r\n__func__, skb, skb->truesize);\r\nif (!atm_charge(vcc, skb->truesize)) {\r\natm_rldbg(instance, "%s: failed atm_charge (skb->truesize: %u)!\n",\r\n__func__, skb->truesize);\r\ndev_kfree_skb_any(skb);\r\ngoto out;\r\n}\r\nskb_copy_to_linear_data(skb,\r\nskb_tail_pointer(sarb) - pdu_length,\r\nlength);\r\n__skb_put(skb, length);\r\nvdbg(&instance->usb_intf->dev,\r\n"%s: sending skb 0x%p, skb->len %u, skb->truesize %u",\r\n__func__, skb, skb->len, skb->truesize);\r\nPACKETDEBUG(instance, skb->data, skb->len);\r\nvcc->push(vcc, skb);\r\natomic_inc(&vcc->stats->rx);\r\nout:\r\nskb_trim(sarb, 0);\r\n}\r\n}\r\nstatic void usbatm_extract_cells(struct usbatm_data *instance,\r\nunsigned char *source, unsigned int avail_data)\r\n{\r\nunsigned int stride = instance->rx_channel.stride;\r\nunsigned int buf_usage = instance->buf_usage;\r\nif (buf_usage > 0) {\r\nunsigned char *cell_buf = instance->cell_buf;\r\nunsigned int space_left = stride - buf_usage;\r\nif (avail_data >= space_left) {\r\nmemcpy(cell_buf + buf_usage, source, space_left);\r\nsource += space_left;\r\navail_data -= space_left;\r\nusbatm_extract_one_cell(instance, cell_buf);\r\ninstance->buf_usage = 0;\r\n} else {\r\nmemcpy(cell_buf + buf_usage, source, avail_data);\r\ninstance->buf_usage = buf_usage + avail_data;\r\nreturn;\r\n}\r\n}\r\nfor (; avail_data >= stride; avail_data -= stride, source += stride)\r\nusbatm_extract_one_cell(instance, source);\r\nif (avail_data > 0) {\r\nmemcpy(instance->cell_buf, source, avail_data);\r\ninstance->buf_usage = avail_data;\r\n}\r\n}\r\nstatic unsigned int usbatm_write_cells(struct usbatm_data *instance,\r\nstruct sk_buff *skb,\r\nu8 *target, unsigned int avail_space)\r\n{\r\nstruct usbatm_control *ctrl = UDSL_SKB(skb);\r\nstruct atm_vcc *vcc = ctrl->atm.vcc;\r\nunsigned int bytes_written;\r\nunsigned int stride = instance->tx_channel.stride;\r\nfor (bytes_written = 0; bytes_written < avail_space && ctrl->len;\r\nbytes_written += stride, target += stride) {\r\nunsigned int data_len = min_t(unsigned int, skb->len, ATM_CELL_PAYLOAD);\r\nunsigned int left = ATM_CELL_PAYLOAD - data_len;\r\nu8 *ptr = target;\r\nptr[0] = vcc->vpi >> 4;\r\nptr[1] = (vcc->vpi << 4) | (vcc->vci >> 12);\r\nptr[2] = vcc->vci >> 4;\r\nptr[3] = vcc->vci << 4;\r\nptr[4] = 0xec;\r\nptr += ATM_CELL_HEADER;\r\nskb_copy_from_linear_data(skb, ptr, data_len);\r\nptr += data_len;\r\n__skb_pull(skb, data_len);\r\nif (!left)\r\ncontinue;\r\nmemset(ptr, 0, left);\r\nif (left >= ATM_AAL5_TRAILER) {\r\nu8 *trailer = target + ATM_CELL_SIZE - ATM_AAL5_TRAILER;\r\ntrailer[2] = ctrl->len >> 8;\r\ntrailer[3] = ctrl->len;\r\nctrl->crc = ~crc32_be(ctrl->crc, ptr, left - 4);\r\ntrailer[4] = ctrl->crc >> 24;\r\ntrailer[5] = ctrl->crc >> 16;\r\ntrailer[6] = ctrl->crc >> 8;\r\ntrailer[7] = ctrl->crc;\r\ntarget[3] |= 0x2;\r\nctrl->len = 0;\r\n} else\r\nctrl->crc = crc32_be(ctrl->crc, ptr, left);\r\n}\r\nreturn bytes_written;\r\n}\r\nstatic void usbatm_rx_process(unsigned long data)\r\n{\r\nstruct usbatm_data *instance = (struct usbatm_data *)data;\r\nstruct urb *urb;\r\nwhile ((urb = usbatm_pop_urb(&instance->rx_channel))) {\r\nvdbg(&instance->usb_intf->dev,\r\n"%s: processing urb 0x%p", __func__, urb);\r\nif (usb_pipeisoc(urb->pipe)) {\r\nunsigned char *merge_start = NULL;\r\nunsigned int merge_length = 0;\r\nconst unsigned int packet_size = instance->rx_channel.packet_size;\r\nint i;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nif (!urb->iso_frame_desc[i].status) {\r\nunsigned int actual_length = urb->iso_frame_desc[i].actual_length;\r\nif (!merge_length)\r\nmerge_start = (unsigned char *)urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nmerge_length += actual_length;\r\nif (merge_length && (actual_length < packet_size)) {\r\nusbatm_extract_cells(instance, merge_start, merge_length);\r\nmerge_length = 0;\r\n}\r\n} else {\r\natm_rldbg(instance, "%s: status %d in frame %d!\n", __func__, urb->status, i);\r\nif (merge_length)\r\nusbatm_extract_cells(instance, merge_start, merge_length);\r\nmerge_length = 0;\r\ninstance->buf_usage = 0;\r\n}\r\n}\r\nif (merge_length)\r\nusbatm_extract_cells(instance, merge_start, merge_length);\r\n} else\r\nif (!urb->status)\r\nusbatm_extract_cells(instance, urb->transfer_buffer, urb->actual_length);\r\nelse\r\ninstance->buf_usage = 0;\r\nif (usbatm_submit_urb(urb))\r\nreturn;\r\n}\r\n}\r\nstatic void usbatm_tx_process(unsigned long data)\r\n{\r\nstruct usbatm_data *instance = (struct usbatm_data *)data;\r\nstruct sk_buff *skb = instance->current_skb;\r\nstruct urb *urb = NULL;\r\nconst unsigned int buf_size = instance->tx_channel.buf_size;\r\nunsigned int bytes_written = 0;\r\nu8 *buffer = NULL;\r\nif (!skb)\r\nskb = skb_dequeue(&instance->sndqueue);\r\nwhile (skb) {\r\nif (!urb) {\r\nurb = usbatm_pop_urb(&instance->tx_channel);\r\nif (!urb)\r\nbreak;\r\nbuffer = urb->transfer_buffer;\r\nbytes_written = (urb->status == -EAGAIN) ?\r\nurb->transfer_buffer_length : 0;\r\n}\r\nbytes_written += usbatm_write_cells(instance, skb,\r\nbuffer + bytes_written,\r\nbuf_size - bytes_written);\r\nvdbg(&instance->usb_intf->dev,\r\n"%s: wrote %u bytes from skb 0x%p to urb 0x%p",\r\n__func__, bytes_written, skb, urb);\r\nif (!UDSL_SKB(skb)->len) {\r\nstruct atm_vcc *vcc = UDSL_SKB(skb)->atm.vcc;\r\nusbatm_pop(vcc, skb);\r\natomic_inc(&vcc->stats->tx);\r\nskb = skb_dequeue(&instance->sndqueue);\r\n}\r\nif (bytes_written == buf_size || (!skb && bytes_written)) {\r\nurb->transfer_buffer_length = bytes_written;\r\nif (usbatm_submit_urb(urb))\r\nbreak;\r\nurb = NULL;\r\n}\r\n}\r\ninstance->current_skb = skb;\r\n}\r\nstatic void usbatm_cancel_send(struct usbatm_data *instance,\r\nstruct atm_vcc *vcc)\r\n{\r\nstruct sk_buff *skb, *n;\r\nspin_lock_irq(&instance->sndqueue.lock);\r\nskb_queue_walk_safe(&instance->sndqueue, skb, n) {\r\nif (UDSL_SKB(skb)->atm.vcc == vcc) {\r\natm_dbg(instance, "%s: popping skb 0x%p\n", __func__, skb);\r\n__skb_unlink(skb, &instance->sndqueue);\r\nusbatm_pop(vcc, skb);\r\n}\r\n}\r\nspin_unlock_irq(&instance->sndqueue.lock);\r\ntasklet_disable(&instance->tx_channel.tasklet);\r\nif ((skb = instance->current_skb) && (UDSL_SKB(skb)->atm.vcc == vcc)) {\r\natm_dbg(instance, "%s: popping current skb (0x%p)\n", __func__, skb);\r\ninstance->current_skb = NULL;\r\nusbatm_pop(vcc, skb);\r\n}\r\ntasklet_enable(&instance->tx_channel.tasklet);\r\n}\r\nstatic int usbatm_atm_send(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nstruct usbatm_data *instance = vcc->dev->dev_data;\r\nstruct usbatm_control *ctrl = UDSL_SKB(skb);\r\nint err;\r\nif (!instance || instance->disconnected) {\r\n#ifdef VERBOSE_DEBUG\r\nprintk_ratelimited(KERN_DEBUG "%s: %s!\n", __func__, instance ? "disconnected" : "NULL instance");\r\n#endif\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nif (vcc->qos.aal != ATM_AAL5) {\r\natm_rldbg(instance, "%s: unsupported ATM type %d!\n", __func__, vcc->qos.aal);\r\nerr = -EINVAL;\r\ngoto fail;\r\n}\r\nif (skb->len > ATM_MAX_AAL5_PDU) {\r\natm_rldbg(instance, "%s: packet too long (%d vs %d)!\n",\r\n__func__, skb->len, ATM_MAX_AAL5_PDU);\r\nerr = -EINVAL;\r\ngoto fail;\r\n}\r\nPACKETDEBUG(instance, skb->data, skb->len);\r\nctrl->atm.vcc = vcc;\r\nctrl->len = skb->len;\r\nctrl->crc = crc32_be(~0, skb->data, skb->len);\r\nskb_queue_tail(&instance->sndqueue, skb);\r\ntasklet_schedule(&instance->tx_channel.tasklet);\r\nreturn 0;\r\nfail:\r\nusbatm_pop(vcc, skb);\r\nreturn err;\r\n}\r\nstatic void usbatm_destroy_instance(struct kref *kref)\r\n{\r\nstruct usbatm_data *instance = container_of(kref, struct usbatm_data, refcount);\r\ntasklet_kill(&instance->rx_channel.tasklet);\r\ntasklet_kill(&instance->tx_channel.tasklet);\r\nusb_put_dev(instance->usb_dev);\r\nkfree(instance);\r\n}\r\nstatic void usbatm_get_instance(struct usbatm_data *instance)\r\n{\r\nkref_get(&instance->refcount);\r\n}\r\nstatic void usbatm_put_instance(struct usbatm_data *instance)\r\n{\r\nkref_put(&instance->refcount, usbatm_destroy_instance);\r\n}\r\nstatic void usbatm_atm_dev_close(struct atm_dev *atm_dev)\r\n{\r\nstruct usbatm_data *instance = atm_dev->dev_data;\r\nif (!instance)\r\nreturn;\r\natm_dev->dev_data = NULL;\r\nusbatm_put_instance(instance);\r\n}\r\nstatic int usbatm_atm_proc_read(struct atm_dev *atm_dev, loff_t *pos, char *page)\r\n{\r\nstruct usbatm_data *instance = atm_dev->dev_data;\r\nint left = *pos;\r\nif (!instance)\r\nreturn -ENODEV;\r\nif (!left--)\r\nreturn sprintf(page, "%s\n", instance->description);\r\nif (!left--)\r\nreturn sprintf(page, "MAC: %pM\n", atm_dev->esi);\r\nif (!left--)\r\nreturn sprintf(page,\r\n"AAL5: tx %d ( %d err ), rx %d ( %d err, %d drop )\n",\r\natomic_read(&atm_dev->stats.aal5.tx),\r\natomic_read(&atm_dev->stats.aal5.tx_err),\r\natomic_read(&atm_dev->stats.aal5.rx),\r\natomic_read(&atm_dev->stats.aal5.rx_err),\r\natomic_read(&atm_dev->stats.aal5.rx_drop));\r\nif (!left--) {\r\nif (instance->disconnected)\r\nreturn sprintf(page, "Disconnected\n");\r\nelse\r\nswitch (atm_dev->signal) {\r\ncase ATM_PHY_SIG_FOUND:\r\nreturn sprintf(page, "Line up\n");\r\ncase ATM_PHY_SIG_LOST:\r\nreturn sprintf(page, "Line down\n");\r\ndefault:\r\nreturn sprintf(page, "Line state unknown\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbatm_atm_open(struct atm_vcc *vcc)\r\n{\r\nstruct usbatm_data *instance = vcc->dev->dev_data;\r\nstruct usbatm_vcc_data *new = NULL;\r\nint ret;\r\nint vci = vcc->vci;\r\nshort vpi = vcc->vpi;\r\nif (!instance)\r\nreturn -ENODEV;\r\nif ((vcc->qos.aal != ATM_AAL5)) {\r\natm_warn(instance, "%s: unsupported ATM type %d!\n", __func__, vcc->qos.aal);\r\nreturn -EINVAL;\r\n}\r\nif ((vcc->qos.rxtp.max_sdu < 0) || (vcc->qos.rxtp.max_sdu > ATM_MAX_AAL5_PDU)) {\r\natm_dbg(instance, "%s: max_sdu %d out of range!\n", __func__, vcc->qos.rxtp.max_sdu);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&instance->serialize);\r\nif (instance->disconnected) {\r\natm_dbg(instance, "%s: disconnected!\n", __func__);\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\nif (usbatm_find_vcc(instance, vpi, vci)) {\r\natm_dbg(instance, "%s: %hd/%d already in use!\n", __func__, vpi, vci);\r\nret = -EADDRINUSE;\r\ngoto fail;\r\n}\r\nif (!(new = kzalloc(sizeof(struct usbatm_vcc_data), GFP_KERNEL))) {\r\natm_err(instance, "%s: no memory for vcc_data!\n", __func__);\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nnew->vcc = vcc;\r\nnew->vpi = vpi;\r\nnew->vci = vci;\r\nnew->sarb = alloc_skb(usbatm_pdu_length(vcc->qos.rxtp.max_sdu), GFP_KERNEL);\r\nif (!new->sarb) {\r\natm_err(instance, "%s: no memory for SAR buffer!\n", __func__);\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nvcc->dev_data = new;\r\ntasklet_disable(&instance->rx_channel.tasklet);\r\ninstance->cached_vcc = new;\r\ninstance->cached_vpi = vpi;\r\ninstance->cached_vci = vci;\r\nlist_add(&new->list, &instance->vcc_list);\r\ntasklet_enable(&instance->rx_channel.tasklet);\r\nset_bit(ATM_VF_ADDR, &vcc->flags);\r\nset_bit(ATM_VF_PARTIAL, &vcc->flags);\r\nset_bit(ATM_VF_READY, &vcc->flags);\r\nmutex_unlock(&instance->serialize);\r\natm_dbg(instance, "%s: allocated vcc data 0x%p\n", __func__, new);\r\nreturn 0;\r\nfail:\r\nkfree(new);\r\nmutex_unlock(&instance->serialize);\r\nreturn ret;\r\n}\r\nstatic void usbatm_atm_close(struct atm_vcc *vcc)\r\n{\r\nstruct usbatm_data *instance = vcc->dev->dev_data;\r\nstruct usbatm_vcc_data *vcc_data = vcc->dev_data;\r\nif (!instance || !vcc_data)\r\nreturn;\r\nusbatm_cancel_send(instance, vcc);\r\nmutex_lock(&instance->serialize);\r\ntasklet_disable(&instance->rx_channel.tasklet);\r\nif (instance->cached_vcc == vcc_data) {\r\ninstance->cached_vcc = NULL;\r\ninstance->cached_vpi = ATM_VPI_UNSPEC;\r\ninstance->cached_vci = ATM_VCI_UNSPEC;\r\n}\r\nlist_del(&vcc_data->list);\r\ntasklet_enable(&instance->rx_channel.tasklet);\r\nkfree_skb(vcc_data->sarb);\r\nvcc_data->sarb = NULL;\r\nkfree(vcc_data);\r\nvcc->dev_data = NULL;\r\nvcc->vpi = ATM_VPI_UNSPEC;\r\nvcc->vci = ATM_VCI_UNSPEC;\r\nclear_bit(ATM_VF_READY, &vcc->flags);\r\nclear_bit(ATM_VF_PARTIAL, &vcc->flags);\r\nclear_bit(ATM_VF_ADDR, &vcc->flags);\r\nmutex_unlock(&instance->serialize);\r\n}\r\nstatic int usbatm_atm_ioctl(struct atm_dev *atm_dev, unsigned int cmd,\r\nvoid __user *arg)\r\n{\r\nstruct usbatm_data *instance = atm_dev->dev_data;\r\nif (!instance || instance->disconnected)\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase ATM_QUERYLOOP:\r\nreturn put_user(ATM_LM_NONE, (int __user *)arg) ? -EFAULT : 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int usbatm_atm_init(struct usbatm_data *instance)\r\n{\r\nstruct atm_dev *atm_dev;\r\nint ret, i;\r\natm_dev = atm_dev_register(instance->driver_name,\r\n&instance->usb_intf->dev, &usbatm_atm_devops,\r\n-1, NULL);\r\nif (!atm_dev) {\r\nusb_err(instance, "%s: failed to register ATM device!\n", __func__);\r\nreturn -1;\r\n}\r\ninstance->atm_dev = atm_dev;\r\natm_dev->ci_range.vpi_bits = ATM_CI_MAX;\r\natm_dev->ci_range.vci_bits = ATM_CI_MAX;\r\natm_dev->signal = ATM_PHY_SIG_UNKNOWN;\r\natm_dev->link_rate = 128 * 1000 / 424;\r\nif (instance->driver->atm_start && ((ret = instance->driver->atm_start(instance, atm_dev)) < 0)) {\r\natm_err(instance, "%s: atm_start failed: %d!\n", __func__, ret);\r\ngoto fail;\r\n}\r\nusbatm_get_instance(instance);\r\nmb();\r\natm_dev->dev_data = instance;\r\nfor (i = 0; i < num_rcv_urbs; i++)\r\nusbatm_submit_urb(instance->urbs[i]);\r\nreturn 0;\r\nfail:\r\ninstance->atm_dev = NULL;\r\natm_dev_deregister(atm_dev);\r\nreturn ret;\r\n}\r\nstatic int usbatm_do_heavy_init(void *arg)\r\n{\r\nstruct usbatm_data *instance = arg;\r\nint ret;\r\nallow_signal(SIGTERM);\r\ncomplete(&instance->thread_started);\r\nret = instance->driver->heavy_init(instance, instance->usb_intf);\r\nif (!ret)\r\nret = usbatm_atm_init(instance);\r\nmutex_lock(&instance->serialize);\r\ninstance->thread = NULL;\r\nmutex_unlock(&instance->serialize);\r\ncomplete_and_exit(&instance->thread_exited, ret);\r\n}\r\nstatic int usbatm_heavy_init(struct usbatm_data *instance)\r\n{\r\nstruct task_struct *t;\r\nt = kthread_create(usbatm_do_heavy_init, instance, "%s",\r\ninstance->driver->driver_name);\r\nif (IS_ERR(t)) {\r\nusb_err(instance, "%s: failed to create kernel_thread (%ld)!\n",\r\n__func__, PTR_ERR(t));\r\nreturn PTR_ERR(t);\r\n}\r\ninstance->thread = t;\r\nwake_up_process(t);\r\nwait_for_completion(&instance->thread_started);\r\nreturn 0;\r\n}\r\nstatic void usbatm_tasklet_schedule(unsigned long data)\r\n{\r\ntasklet_schedule((struct tasklet_struct *) data);\r\n}\r\nstatic void usbatm_init_channel(struct usbatm_channel *channel)\r\n{\r\nspin_lock_init(&channel->lock);\r\nINIT_LIST_HEAD(&channel->list);\r\nchannel->delay.function = usbatm_tasklet_schedule;\r\nchannel->delay.data = (unsigned long) &channel->tasklet;\r\ninit_timer(&channel->delay);\r\n}\r\nint usbatm_usb_probe(struct usb_interface *intf, const struct usb_device_id *id,\r\nstruct usbatm_driver *driver)\r\n{\r\nstruct device *dev = &intf->dev;\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nstruct usbatm_data *instance;\r\nchar *buf;\r\nint error = -ENOMEM;\r\nint i, length;\r\nunsigned int maxpacket, num_packets;\r\ninstance = kzalloc(sizeof(*instance) + sizeof(struct urb *) * (num_rcv_urbs + num_snd_urbs), GFP_KERNEL);\r\nif (!instance) {\r\ndev_err(dev, "%s: no memory for instance data!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ninstance->driver = driver;\r\nstrlcpy(instance->driver_name, driver->driver_name,\r\nsizeof(instance->driver_name));\r\ninstance->usb_dev = usb_dev;\r\ninstance->usb_intf = intf;\r\nbuf = instance->description;\r\nlength = sizeof(instance->description);\r\nif ((i = usb_string(usb_dev, usb_dev->descriptor.iProduct, buf, length)) < 0)\r\ngoto bind;\r\nbuf += i;\r\nlength -= i;\r\ni = scnprintf(buf, length, " (");\r\nbuf += i;\r\nlength -= i;\r\nif (length <= 0 || (i = usb_make_path(usb_dev, buf, length)) < 0)\r\ngoto bind;\r\nbuf += i;\r\nlength -= i;\r\nsnprintf(buf, length, ")");\r\nbind:\r\nif (driver->bind && (error = driver->bind(instance, intf, id)) < 0) {\r\ndev_err(dev, "%s: bind failed: %d!\n", __func__, error);\r\ngoto fail_free;\r\n}\r\nkref_init(&instance->refcount);\r\nmutex_init(&instance->serialize);\r\ninstance->thread = NULL;\r\ninit_completion(&instance->thread_started);\r\ninit_completion(&instance->thread_exited);\r\nINIT_LIST_HEAD(&instance->vcc_list);\r\nskb_queue_head_init(&instance->sndqueue);\r\nusbatm_init_channel(&instance->rx_channel);\r\nusbatm_init_channel(&instance->tx_channel);\r\ntasklet_init(&instance->rx_channel.tasklet, usbatm_rx_process, (unsigned long)instance);\r\ntasklet_init(&instance->tx_channel.tasklet, usbatm_tx_process, (unsigned long)instance);\r\ninstance->rx_channel.stride = ATM_CELL_SIZE + driver->rx_padding;\r\ninstance->tx_channel.stride = ATM_CELL_SIZE + driver->tx_padding;\r\ninstance->rx_channel.usbatm = instance->tx_channel.usbatm = instance;\r\nif ((instance->flags & UDSL_USE_ISOC) && driver->isoc_in)\r\ninstance->rx_channel.endpoint = usb_rcvisocpipe(usb_dev, driver->isoc_in);\r\nelse\r\ninstance->rx_channel.endpoint = usb_rcvbulkpipe(usb_dev, driver->bulk_in);\r\ninstance->tx_channel.endpoint = usb_sndbulkpipe(usb_dev, driver->bulk_out);\r\ninstance->tx_channel.buf_size = max(instance->tx_channel.stride,\r\nsnd_buf_bytes - (snd_buf_bytes % instance->tx_channel.stride));\r\nmaxpacket = usb_maxpacket(usb_dev, instance->rx_channel.endpoint, 0);\r\nif ((maxpacket < 1) || (maxpacket > UDSL_MAX_BUF_SIZE)) {\r\ndev_err(dev, "%s: invalid endpoint %02x!\n", __func__,\r\nusb_pipeendpoint(instance->rx_channel.endpoint));\r\nerror = -EINVAL;\r\ngoto fail_unbind;\r\n}\r\nnum_packets = max(1U, (rcv_buf_bytes + maxpacket / 2) / maxpacket);\r\nif (num_packets * maxpacket > UDSL_MAX_BUF_SIZE)\r\nnum_packets--;\r\ninstance->rx_channel.buf_size = num_packets * maxpacket;\r\ninstance->rx_channel.packet_size = maxpacket;\r\nfor (i = 0; i < 2; i++) {\r\nstruct usbatm_channel *channel = i ?\r\n&instance->tx_channel : &instance->rx_channel;\r\ndev_dbg(dev, "%s: using %d byte buffer for %s channel 0x%p\n",\r\n__func__, channel->buf_size, i ? "tx" : "rx", channel);\r\n}\r\nfor (i = 0; i < num_rcv_urbs + num_snd_urbs; i++) {\r\nu8 *buffer;\r\nstruct usbatm_channel *channel = i < num_rcv_urbs ?\r\n&instance->rx_channel : &instance->tx_channel;\r\nstruct urb *urb;\r\nunsigned int iso_packets = usb_pipeisoc(channel->endpoint) ? channel->buf_size / channel->packet_size : 0;\r\nurb = usb_alloc_urb(iso_packets, GFP_KERNEL);\r\nif (!urb) {\r\ndev_err(dev, "%s: no memory for urb %d!\n", __func__, i);\r\nerror = -ENOMEM;\r\ngoto fail_unbind;\r\n}\r\ninstance->urbs[i] = urb;\r\nbuffer = kzalloc(channel->buf_size, GFP_KERNEL);\r\nif (!buffer) {\r\ndev_err(dev, "%s: no memory for buffer %d!\n", __func__, i);\r\nerror = -ENOMEM;\r\ngoto fail_unbind;\r\n}\r\nusb_fill_bulk_urb(urb, instance->usb_dev, channel->endpoint,\r\nbuffer, channel->buf_size, usbatm_complete, channel);\r\nif (iso_packets) {\r\nint j;\r\nurb->interval = 1;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->number_of_packets = iso_packets;\r\nfor (j = 0; j < iso_packets; j++) {\r\nurb->iso_frame_desc[j].offset = channel->packet_size * j;\r\nurb->iso_frame_desc[j].length = channel->packet_size;\r\n}\r\n}\r\nif (i >= num_rcv_urbs)\r\nlist_add_tail(&urb->urb_list, &channel->list);\r\nvdbg(&intf->dev, "%s: alloced buffer 0x%p buf size %u urb 0x%p",\r\n__func__, urb->transfer_buffer, urb->transfer_buffer_length, urb);\r\n}\r\ninstance->cached_vpi = ATM_VPI_UNSPEC;\r\ninstance->cached_vci = ATM_VCI_UNSPEC;\r\ninstance->cell_buf = kmalloc(instance->rx_channel.stride, GFP_KERNEL);\r\nif (!instance->cell_buf) {\r\ndev_err(dev, "%s: no memory for cell buffer!\n", __func__);\r\nerror = -ENOMEM;\r\ngoto fail_unbind;\r\n}\r\nif (!(instance->flags & UDSL_SKIP_HEAVY_INIT) && driver->heavy_init) {\r\nerror = usbatm_heavy_init(instance);\r\n} else {\r\ncomplete(&instance->thread_exited);\r\nerror = usbatm_atm_init(instance);\r\n}\r\nif (error < 0)\r\ngoto fail_unbind;\r\nusb_get_dev(usb_dev);\r\nusb_set_intfdata(intf, instance);\r\nreturn 0;\r\nfail_unbind:\r\nif (instance->driver->unbind)\r\ninstance->driver->unbind(instance, intf);\r\nfail_free:\r\nkfree(instance->cell_buf);\r\nfor (i = 0; i < num_rcv_urbs + num_snd_urbs; i++) {\r\nif (instance->urbs[i])\r\nkfree(instance->urbs[i]->transfer_buffer);\r\nusb_free_urb(instance->urbs[i]);\r\n}\r\nkfree(instance);\r\nreturn error;\r\n}\r\nvoid usbatm_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct device *dev = &intf->dev;\r\nstruct usbatm_data *instance = usb_get_intfdata(intf);\r\nstruct usbatm_vcc_data *vcc_data;\r\nint i;\r\nif (!instance) {\r\ndev_dbg(dev, "%s: NULL instance!\n", __func__);\r\nreturn;\r\n}\r\nusb_set_intfdata(intf, NULL);\r\nmutex_lock(&instance->serialize);\r\ninstance->disconnected = 1;\r\nif (instance->thread != NULL)\r\nsend_sig(SIGTERM, instance->thread, 1);\r\nmutex_unlock(&instance->serialize);\r\nwait_for_completion(&instance->thread_exited);\r\nmutex_lock(&instance->serialize);\r\nlist_for_each_entry(vcc_data, &instance->vcc_list, list)\r\nvcc_release_async(vcc_data->vcc, -EPIPE);\r\nmutex_unlock(&instance->serialize);\r\ntasklet_disable(&instance->rx_channel.tasklet);\r\ntasklet_disable(&instance->tx_channel.tasklet);\r\nfor (i = 0; i < num_rcv_urbs + num_snd_urbs; i++)\r\nusb_kill_urb(instance->urbs[i]);\r\ndel_timer_sync(&instance->rx_channel.delay);\r\ndel_timer_sync(&instance->tx_channel.delay);\r\nINIT_LIST_HEAD(&instance->rx_channel.list);\r\nINIT_LIST_HEAD(&instance->tx_channel.list);\r\ntasklet_enable(&instance->rx_channel.tasklet);\r\ntasklet_enable(&instance->tx_channel.tasklet);\r\nif (instance->atm_dev && instance->driver->atm_stop)\r\ninstance->driver->atm_stop(instance, instance->atm_dev);\r\nif (instance->driver->unbind)\r\ninstance->driver->unbind(instance, intf);\r\ninstance->driver_data = NULL;\r\nfor (i = 0; i < num_rcv_urbs + num_snd_urbs; i++) {\r\nkfree(instance->urbs[i]->transfer_buffer);\r\nusb_free_urb(instance->urbs[i]);\r\n}\r\nkfree(instance->cell_buf);\r\nif (instance->atm_dev) {\r\natm_dev_deregister(instance->atm_dev);\r\ninstance->atm_dev = NULL;\r\n}\r\nusbatm_put_instance(instance);\r\n}\r\nstatic int __init usbatm_usb_init(void)\r\n{\r\nif (sizeof(struct usbatm_control) > FIELD_SIZEOF(struct sk_buff, cb)) {\r\nprintk(KERN_ERR "%s unusable with this kernel!\n", usbatm_driver_name);\r\nreturn -EIO;\r\n}\r\nif ((num_rcv_urbs > UDSL_MAX_RCV_URBS)\r\n|| (num_snd_urbs > UDSL_MAX_SND_URBS)\r\n|| (rcv_buf_bytes < 1)\r\n|| (rcv_buf_bytes > UDSL_MAX_BUF_SIZE)\r\n|| (snd_buf_bytes < 1)\r\n|| (snd_buf_bytes > UDSL_MAX_BUF_SIZE))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void __exit usbatm_usb_exit(void)\r\n{\r\n}\r\nstatic int usbatm_print_packet(struct usbatm_data *instance,\r\nconst unsigned char *data, int len)\r\n{\r\nunsigned char buffer[256];\r\nint i = 0, j = 0;\r\nfor (i = 0; i < len;) {\r\nbuffer[0] = '\0';\r\nsprintf(buffer, "%.3d :", i);\r\nfor (j = 0; (j < 16) && (i < len); j++, i++)\r\nsprintf(buffer, "%s %2.2x", buffer, data[i]);\r\ndev_dbg(&instance->usb_intf->dev, "%s", buffer);\r\n}\r\nreturn i;\r\n}
