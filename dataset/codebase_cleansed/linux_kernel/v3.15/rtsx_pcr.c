void rtsx_pci_start_run(struct rtsx_pcr *pcr)\r\n{\r\nif (pcr->remove_pci)\r\nreturn;\r\nif (pcr->state != PDEV_STAT_RUN) {\r\npcr->state = PDEV_STAT_RUN;\r\nif (pcr->ops->enable_auto_blink)\r\npcr->ops->enable_auto_blink(pcr);\r\nif (pcr->aspm_en)\r\nrtsx_pci_write_config_byte(pcr, LCTLR, 0);\r\n}\r\nmod_delayed_work(system_wq, &pcr->idle_work, msecs_to_jiffies(200));\r\n}\r\nint rtsx_pci_write_register(struct rtsx_pcr *pcr, u16 addr, u8 mask, u8 data)\r\n{\r\nint i;\r\nu32 val = HAIMR_WRITE_START;\r\nval |= (u32)(addr & 0x3FFF) << 16;\r\nval |= (u32)mask << 8;\r\nval |= (u32)data;\r\nrtsx_pci_writel(pcr, RTSX_HAIMR, val);\r\nfor (i = 0; i < MAX_RW_REG_CNT; i++) {\r\nval = rtsx_pci_readl(pcr, RTSX_HAIMR);\r\nif ((val & HAIMR_TRANS_END) == 0) {\r\nif (data != (u8)val)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nint rtsx_pci_read_register(struct rtsx_pcr *pcr, u16 addr, u8 *data)\r\n{\r\nu32 val = HAIMR_READ_START;\r\nint i;\r\nval |= (u32)(addr & 0x3FFF) << 16;\r\nrtsx_pci_writel(pcr, RTSX_HAIMR, val);\r\nfor (i = 0; i < MAX_RW_REG_CNT; i++) {\r\nval = rtsx_pci_readl(pcr, RTSX_HAIMR);\r\nif ((val & HAIMR_TRANS_END) == 0)\r\nbreak;\r\n}\r\nif (i >= MAX_RW_REG_CNT)\r\nreturn -ETIMEDOUT;\r\nif (data)\r\n*data = (u8)(val & 0xFF);\r\nreturn 0;\r\n}\r\nint rtsx_pci_write_phy_register(struct rtsx_pcr *pcr, u8 addr, u16 val)\r\n{\r\nint err, i, finished = 0;\r\nu8 tmp;\r\nrtsx_pci_init_cmd(pcr);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, PHYDATA0, 0xFF, (u8)val);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, PHYDATA1, 0xFF, (u8)(val >> 8));\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, PHYADDR, 0xFF, addr);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, PHYRWCTL, 0xFF, 0x81);\r\nerr = rtsx_pci_send_cmd(pcr, 100);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < 100000; i++) {\r\nerr = rtsx_pci_read_register(pcr, PHYRWCTL, &tmp);\r\nif (err < 0)\r\nreturn err;\r\nif (!(tmp & 0x80)) {\r\nfinished = 1;\r\nbreak;\r\n}\r\n}\r\nif (!finished)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nint rtsx_pci_read_phy_register(struct rtsx_pcr *pcr, u8 addr, u16 *val)\r\n{\r\nint err, i, finished = 0;\r\nu16 data;\r\nu8 *ptr, tmp;\r\nrtsx_pci_init_cmd(pcr);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, PHYADDR, 0xFF, addr);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, PHYRWCTL, 0xFF, 0x80);\r\nerr = rtsx_pci_send_cmd(pcr, 100);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < 100000; i++) {\r\nerr = rtsx_pci_read_register(pcr, PHYRWCTL, &tmp);\r\nif (err < 0)\r\nreturn err;\r\nif (!(tmp & 0x80)) {\r\nfinished = 1;\r\nbreak;\r\n}\r\n}\r\nif (!finished)\r\nreturn -ETIMEDOUT;\r\nrtsx_pci_init_cmd(pcr);\r\nrtsx_pci_add_cmd(pcr, READ_REG_CMD, PHYDATA0, 0, 0);\r\nrtsx_pci_add_cmd(pcr, READ_REG_CMD, PHYDATA1, 0, 0);\r\nerr = rtsx_pci_send_cmd(pcr, 100);\r\nif (err < 0)\r\nreturn err;\r\nptr = rtsx_pci_get_cmd_data(pcr);\r\ndata = ((u16)ptr[1] << 8) | ptr[0];\r\nif (val)\r\n*val = data;\r\nreturn 0;\r\n}\r\nvoid rtsx_pci_stop_cmd(struct rtsx_pcr *pcr)\r\n{\r\nrtsx_pci_writel(pcr, RTSX_HCBCTLR, STOP_CMD);\r\nrtsx_pci_writel(pcr, RTSX_HDBCTLR, STOP_DMA);\r\nrtsx_pci_write_register(pcr, DMACTL, 0x80, 0x80);\r\nrtsx_pci_write_register(pcr, RBCTL, 0x80, 0x80);\r\n}\r\nvoid rtsx_pci_add_cmd(struct rtsx_pcr *pcr,\r\nu8 cmd_type, u16 reg_addr, u8 mask, u8 data)\r\n{\r\nunsigned long flags;\r\nu32 val = 0;\r\nu32 *ptr = (u32 *)(pcr->host_cmds_ptr);\r\nval |= (u32)(cmd_type & 0x03) << 30;\r\nval |= (u32)(reg_addr & 0x3FFF) << 16;\r\nval |= (u32)mask << 8;\r\nval |= (u32)data;\r\nspin_lock_irqsave(&pcr->lock, flags);\r\nptr += pcr->ci;\r\nif (pcr->ci < (HOST_CMDS_BUF_LEN / 4)) {\r\nput_unaligned_le32(val, ptr);\r\nptr++;\r\npcr->ci++;\r\n}\r\nspin_unlock_irqrestore(&pcr->lock, flags);\r\n}\r\nvoid rtsx_pci_send_cmd_no_wait(struct rtsx_pcr *pcr)\r\n{\r\nu32 val = 1 << 31;\r\nrtsx_pci_writel(pcr, RTSX_HCBAR, pcr->host_cmds_addr);\r\nval |= (u32)(pcr->ci * 4) & 0x00FFFFFF;\r\nval |= 0x40000000;\r\nrtsx_pci_writel(pcr, RTSX_HCBCTLR, val);\r\n}\r\nint rtsx_pci_send_cmd(struct rtsx_pcr *pcr, int timeout)\r\n{\r\nstruct completion trans_done;\r\nu32 val = 1 << 31;\r\nlong timeleft;\r\nunsigned long flags;\r\nint err = 0;\r\nspin_lock_irqsave(&pcr->lock, flags);\r\npcr->done = &trans_done;\r\npcr->trans_result = TRANS_NOT_READY;\r\ninit_completion(&trans_done);\r\nrtsx_pci_writel(pcr, RTSX_HCBAR, pcr->host_cmds_addr);\r\nval |= (u32)(pcr->ci * 4) & 0x00FFFFFF;\r\nval |= 0x40000000;\r\nrtsx_pci_writel(pcr, RTSX_HCBCTLR, val);\r\nspin_unlock_irqrestore(&pcr->lock, flags);\r\ntimeleft = wait_for_completion_interruptible_timeout(\r\n&trans_done, msecs_to_jiffies(timeout));\r\nif (timeleft <= 0) {\r\ndev_dbg(&(pcr->pci->dev), "Timeout (%s %d)\n",\r\n__func__, __LINE__);\r\nerr = -ETIMEDOUT;\r\ngoto finish_send_cmd;\r\n}\r\nspin_lock_irqsave(&pcr->lock, flags);\r\nif (pcr->trans_result == TRANS_RESULT_FAIL)\r\nerr = -EINVAL;\r\nelse if (pcr->trans_result == TRANS_RESULT_OK)\r\nerr = 0;\r\nelse if (pcr->trans_result == TRANS_NO_DEVICE)\r\nerr = -ENODEV;\r\nspin_unlock_irqrestore(&pcr->lock, flags);\r\nfinish_send_cmd:\r\nspin_lock_irqsave(&pcr->lock, flags);\r\npcr->done = NULL;\r\nspin_unlock_irqrestore(&pcr->lock, flags);\r\nif ((err < 0) && (err != -ENODEV))\r\nrtsx_pci_stop_cmd(pcr);\r\nif (pcr->finish_me)\r\ncomplete(pcr->finish_me);\r\nreturn err;\r\n}\r\nstatic void rtsx_pci_add_sg_tbl(struct rtsx_pcr *pcr,\r\ndma_addr_t addr, unsigned int len, int end)\r\n{\r\nu64 *ptr = (u64 *)(pcr->host_sg_tbl_ptr) + pcr->sgi;\r\nu64 val;\r\nu8 option = SG_VALID | SG_TRANS_DATA;\r\ndev_dbg(&(pcr->pci->dev), "DMA addr: 0x%x, Len: 0x%x\n",\r\n(unsigned int)addr, len);\r\nif (end)\r\noption |= SG_END;\r\nval = ((u64)addr << 32) | ((u64)len << 12) | option;\r\nput_unaligned_le64(val, ptr);\r\npcr->sgi++;\r\n}\r\nint rtsx_pci_transfer_data(struct rtsx_pcr *pcr, struct scatterlist *sglist,\r\nint num_sg, bool read, int timeout)\r\n{\r\nstruct completion trans_done;\r\nu8 dir;\r\nint err = 0, i, count;\r\nlong timeleft;\r\nunsigned long flags;\r\nstruct scatterlist *sg;\r\nenum dma_data_direction dma_dir;\r\nu32 val;\r\ndma_addr_t addr;\r\nunsigned int len;\r\ndev_dbg(&(pcr->pci->dev), "--> %s: num_sg = %d\n", __func__, num_sg);\r\nif (pcr->remove_pci)\r\nreturn -EINVAL;\r\nif ((sglist == NULL) || (num_sg <= 0))\r\nreturn -EINVAL;\r\nif (read) {\r\ndir = DEVICE_TO_HOST;\r\ndma_dir = DMA_FROM_DEVICE;\r\n} else {\r\ndir = HOST_TO_DEVICE;\r\ndma_dir = DMA_TO_DEVICE;\r\n}\r\ncount = dma_map_sg(&(pcr->pci->dev), sglist, num_sg, dma_dir);\r\nif (count < 1) {\r\ndev_err(&(pcr->pci->dev), "scatterlist map failed\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&(pcr->pci->dev), "DMA mapping count: %d\n", count);\r\nval = ((u32)(dir & 0x01) << 29) | TRIG_DMA | ADMA_MODE;\r\npcr->sgi = 0;\r\nfor_each_sg(sglist, sg, count, i) {\r\naddr = sg_dma_address(sg);\r\nlen = sg_dma_len(sg);\r\nrtsx_pci_add_sg_tbl(pcr, addr, len, i == count - 1);\r\n}\r\nspin_lock_irqsave(&pcr->lock, flags);\r\npcr->done = &trans_done;\r\npcr->trans_result = TRANS_NOT_READY;\r\ninit_completion(&trans_done);\r\nrtsx_pci_writel(pcr, RTSX_HDBAR, pcr->host_sg_tbl_addr);\r\nrtsx_pci_writel(pcr, RTSX_HDBCTLR, val);\r\nspin_unlock_irqrestore(&pcr->lock, flags);\r\ntimeleft = wait_for_completion_interruptible_timeout(\r\n&trans_done, msecs_to_jiffies(timeout));\r\nif (timeleft <= 0) {\r\ndev_dbg(&(pcr->pci->dev), "Timeout (%s %d)\n",\r\n__func__, __LINE__);\r\nerr = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&pcr->lock, flags);\r\nif (pcr->trans_result == TRANS_RESULT_FAIL)\r\nerr = -EINVAL;\r\nelse if (pcr->trans_result == TRANS_NO_DEVICE)\r\nerr = -ENODEV;\r\nspin_unlock_irqrestore(&pcr->lock, flags);\r\nout:\r\nspin_lock_irqsave(&pcr->lock, flags);\r\npcr->done = NULL;\r\nspin_unlock_irqrestore(&pcr->lock, flags);\r\ndma_unmap_sg(&(pcr->pci->dev), sglist, num_sg, dma_dir);\r\nif ((err < 0) && (err != -ENODEV))\r\nrtsx_pci_stop_cmd(pcr);\r\nif (pcr->finish_me)\r\ncomplete(pcr->finish_me);\r\nreturn err;\r\n}\r\nint rtsx_pci_read_ppbuf(struct rtsx_pcr *pcr, u8 *buf, int buf_len)\r\n{\r\nint err;\r\nint i, j;\r\nu16 reg;\r\nu8 *ptr;\r\nif (buf_len > 512)\r\nbuf_len = 512;\r\nptr = buf;\r\nreg = PPBUF_BASE2;\r\nfor (i = 0; i < buf_len / 256; i++) {\r\nrtsx_pci_init_cmd(pcr);\r\nfor (j = 0; j < 256; j++)\r\nrtsx_pci_add_cmd(pcr, READ_REG_CMD, reg++, 0, 0);\r\nerr = rtsx_pci_send_cmd(pcr, 250);\r\nif (err < 0)\r\nreturn err;\r\nmemcpy(ptr, rtsx_pci_get_cmd_data(pcr), 256);\r\nptr += 256;\r\n}\r\nif (buf_len % 256) {\r\nrtsx_pci_init_cmd(pcr);\r\nfor (j = 0; j < buf_len % 256; j++)\r\nrtsx_pci_add_cmd(pcr, READ_REG_CMD, reg++, 0, 0);\r\nerr = rtsx_pci_send_cmd(pcr, 250);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nmemcpy(ptr, rtsx_pci_get_cmd_data(pcr), buf_len % 256);\r\nreturn 0;\r\n}\r\nint rtsx_pci_write_ppbuf(struct rtsx_pcr *pcr, u8 *buf, int buf_len)\r\n{\r\nint err;\r\nint i, j;\r\nu16 reg;\r\nu8 *ptr;\r\nif (buf_len > 512)\r\nbuf_len = 512;\r\nptr = buf;\r\nreg = PPBUF_BASE2;\r\nfor (i = 0; i < buf_len / 256; i++) {\r\nrtsx_pci_init_cmd(pcr);\r\nfor (j = 0; j < 256; j++) {\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD,\r\nreg++, 0xFF, *ptr);\r\nptr++;\r\n}\r\nerr = rtsx_pci_send_cmd(pcr, 250);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (buf_len % 256) {\r\nrtsx_pci_init_cmd(pcr);\r\nfor (j = 0; j < buf_len % 256; j++) {\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD,\r\nreg++, 0xFF, *ptr);\r\nptr++;\r\n}\r\nerr = rtsx_pci_send_cmd(pcr, 250);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtsx_pci_set_pull_ctl(struct rtsx_pcr *pcr, const u32 *tbl)\r\n{\r\nint err;\r\nrtsx_pci_init_cmd(pcr);\r\nwhile (*tbl & 0xFFFF0000) {\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD,\r\n(u16)(*tbl >> 16), 0xFF, (u8)(*tbl));\r\ntbl++;\r\n}\r\nerr = rtsx_pci_send_cmd(pcr, 100);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint rtsx_pci_card_pull_ctl_enable(struct rtsx_pcr *pcr, int card)\r\n{\r\nconst u32 *tbl;\r\nif (card == RTSX_SD_CARD)\r\ntbl = pcr->sd_pull_ctl_enable_tbl;\r\nelse if (card == RTSX_MS_CARD)\r\ntbl = pcr->ms_pull_ctl_enable_tbl;\r\nelse\r\nreturn -EINVAL;\r\nreturn rtsx_pci_set_pull_ctl(pcr, tbl);\r\n}\r\nint rtsx_pci_card_pull_ctl_disable(struct rtsx_pcr *pcr, int card)\r\n{\r\nconst u32 *tbl;\r\nif (card == RTSX_SD_CARD)\r\ntbl = pcr->sd_pull_ctl_disable_tbl;\r\nelse if (card == RTSX_MS_CARD)\r\ntbl = pcr->ms_pull_ctl_disable_tbl;\r\nelse\r\nreturn -EINVAL;\r\nreturn rtsx_pci_set_pull_ctl(pcr, tbl);\r\n}\r\nstatic void rtsx_pci_enable_bus_int(struct rtsx_pcr *pcr)\r\n{\r\npcr->bier = TRANS_OK_INT_EN | TRANS_FAIL_INT_EN | SD_INT_EN;\r\nif (pcr->num_slots > 1)\r\npcr->bier |= MS_INT_EN;\r\nrtsx_pci_writel(pcr, RTSX_BIER, pcr->bier);\r\ndev_dbg(&(pcr->pci->dev), "RTSX_BIER: 0x%08x\n", pcr->bier);\r\n}\r\nstatic inline u8 double_ssc_depth(u8 depth)\r\n{\r\nreturn ((depth > 1) ? (depth - 1) : depth);\r\n}\r\nstatic u8 revise_ssc_depth(u8 ssc_depth, u8 div)\r\n{\r\nif (div > CLK_DIV_1) {\r\nif (ssc_depth > (div - 1))\r\nssc_depth -= (div - 1);\r\nelse\r\nssc_depth = SSC_DEPTH_4M;\r\n}\r\nreturn ssc_depth;\r\n}\r\nint rtsx_pci_switch_clock(struct rtsx_pcr *pcr, unsigned int card_clock,\r\nu8 ssc_depth, bool initial_mode, bool double_clk, bool vpclk)\r\n{\r\nint err, clk;\r\nu8 n, clk_divider, mcu_cnt, div;\r\nu8 depth[] = {\r\n[RTSX_SSC_DEPTH_4M] = SSC_DEPTH_4M,\r\n[RTSX_SSC_DEPTH_2M] = SSC_DEPTH_2M,\r\n[RTSX_SSC_DEPTH_1M] = SSC_DEPTH_1M,\r\n[RTSX_SSC_DEPTH_500K] = SSC_DEPTH_500K,\r\n[RTSX_SSC_DEPTH_250K] = SSC_DEPTH_250K,\r\n};\r\nif (initial_mode) {\r\nclk_divider = SD_CLK_DIVIDE_128;\r\ncard_clock = 30000000;\r\n} else {\r\nclk_divider = SD_CLK_DIVIDE_0;\r\n}\r\nerr = rtsx_pci_write_register(pcr, SD_CFG1,\r\nSD_CLK_DIVIDE_MASK, clk_divider);\r\nif (err < 0)\r\nreturn err;\r\ncard_clock /= 1000000;\r\ndev_dbg(&(pcr->pci->dev), "Switch card clock to %dMHz\n", card_clock);\r\nclk = card_clock;\r\nif (!initial_mode && double_clk)\r\nclk = card_clock * 2;\r\ndev_dbg(&(pcr->pci->dev),\r\n"Internal SSC clock: %dMHz (cur_clock = %d)\n",\r\nclk, pcr->cur_clock);\r\nif (clk == pcr->cur_clock)\r\nreturn 0;\r\nif (pcr->ops->conv_clk_and_div_n)\r\nn = (u8)pcr->ops->conv_clk_and_div_n(clk, CLK_TO_DIV_N);\r\nelse\r\nn = (u8)(clk - 2);\r\nif ((clk <= 2) || (n > MAX_DIV_N_PCR))\r\nreturn -EINVAL;\r\nmcu_cnt = (u8)(125/clk + 3);\r\nif (mcu_cnt > 15)\r\nmcu_cnt = 15;\r\ndiv = CLK_DIV_1;\r\nwhile ((n < MIN_DIV_N_PCR) && (div < CLK_DIV_8)) {\r\nif (pcr->ops->conv_clk_and_div_n) {\r\nint dbl_clk = pcr->ops->conv_clk_and_div_n(n,\r\nDIV_N_TO_CLK) * 2;\r\nn = (u8)pcr->ops->conv_clk_and_div_n(dbl_clk,\r\nCLK_TO_DIV_N);\r\n} else {\r\nn = (n + 2) * 2 - 2;\r\n}\r\ndiv++;\r\n}\r\ndev_dbg(&(pcr->pci->dev), "n = %d, div = %d\n", n, div);\r\nssc_depth = depth[ssc_depth];\r\nif (double_clk)\r\nssc_depth = double_ssc_depth(ssc_depth);\r\nssc_depth = revise_ssc_depth(ssc_depth, div);\r\ndev_dbg(&(pcr->pci->dev), "ssc_depth = %d\n", ssc_depth);\r\nrtsx_pci_init_cmd(pcr);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_CTL,\r\nCLK_LOW_FREQ, CLK_LOW_FREQ);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_DIV,\r\n0xFF, (div << 4) | mcu_cnt);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL1, SSC_RSTB, 0);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL2,\r\nSSC_DEPTH_MASK, ssc_depth);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_DIV_N_0, 0xFF, n);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL1, SSC_RSTB, SSC_RSTB);\r\nif (vpclk) {\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_VPCLK0_CTL,\r\nPHASE_NOT_RESET, 0);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_VPCLK0_CTL,\r\nPHASE_NOT_RESET, PHASE_NOT_RESET);\r\n}\r\nerr = rtsx_pci_send_cmd(pcr, 2000);\r\nif (err < 0)\r\nreturn err;\r\nudelay(10);\r\nerr = rtsx_pci_write_register(pcr, CLK_CTL, CLK_LOW_FREQ, 0);\r\nif (err < 0)\r\nreturn err;\r\npcr->cur_clock = clk;\r\nreturn 0;\r\n}\r\nint rtsx_pci_card_power_on(struct rtsx_pcr *pcr, int card)\r\n{\r\nif (pcr->ops->card_power_on)\r\nreturn pcr->ops->card_power_on(pcr, card);\r\nreturn 0;\r\n}\r\nint rtsx_pci_card_power_off(struct rtsx_pcr *pcr, int card)\r\n{\r\nif (pcr->ops->card_power_off)\r\nreturn pcr->ops->card_power_off(pcr, card);\r\nreturn 0;\r\n}\r\nint rtsx_pci_card_exclusive_check(struct rtsx_pcr *pcr, int card)\r\n{\r\nunsigned int cd_mask[] = {\r\n[RTSX_SD_CARD] = SD_EXIST,\r\n[RTSX_MS_CARD] = MS_EXIST\r\n};\r\nif (!(pcr->flags & PCR_MS_PMOS)) {\r\nif (pcr->card_exist & (~cd_mask[card]))\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint rtsx_pci_switch_output_voltage(struct rtsx_pcr *pcr, u8 voltage)\r\n{\r\nif (pcr->ops->switch_output_voltage)\r\nreturn pcr->ops->switch_output_voltage(pcr, voltage);\r\nreturn 0;\r\n}\r\nunsigned int rtsx_pci_card_exist(struct rtsx_pcr *pcr)\r\n{\r\nunsigned int val;\r\nval = rtsx_pci_readl(pcr, RTSX_BIPR);\r\nif (pcr->ops->cd_deglitch)\r\nval = pcr->ops->cd_deglitch(pcr);\r\nreturn val;\r\n}\r\nvoid rtsx_pci_complete_unfinished_transfer(struct rtsx_pcr *pcr)\r\n{\r\nstruct completion finish;\r\npcr->finish_me = &finish;\r\ninit_completion(&finish);\r\nif (pcr->done)\r\ncomplete(pcr->done);\r\nif (!pcr->remove_pci)\r\nrtsx_pci_stop_cmd(pcr);\r\nwait_for_completion_interruptible_timeout(&finish,\r\nmsecs_to_jiffies(2));\r\npcr->finish_me = NULL;\r\n}\r\nstatic void rtsx_pci_card_detect(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork;\r\nstruct rtsx_pcr *pcr;\r\nunsigned long flags;\r\nunsigned int card_detect = 0, card_inserted, card_removed;\r\nu32 irq_status;\r\ndwork = to_delayed_work(work);\r\npcr = container_of(dwork, struct rtsx_pcr, carddet_work);\r\ndev_dbg(&(pcr->pci->dev), "--> %s\n", __func__);\r\nmutex_lock(&pcr->pcr_mutex);\r\nspin_lock_irqsave(&pcr->lock, flags);\r\nirq_status = rtsx_pci_readl(pcr, RTSX_BIPR);\r\ndev_dbg(&(pcr->pci->dev), "irq_status: 0x%08x\n", irq_status);\r\nirq_status &= CARD_EXIST;\r\ncard_inserted = pcr->card_inserted & irq_status;\r\ncard_removed = pcr->card_removed;\r\npcr->card_inserted = 0;\r\npcr->card_removed = 0;\r\nspin_unlock_irqrestore(&pcr->lock, flags);\r\nif (card_inserted || card_removed) {\r\ndev_dbg(&(pcr->pci->dev),\r\n"card_inserted: 0x%x, card_removed: 0x%x\n",\r\ncard_inserted, card_removed);\r\nif (pcr->ops->cd_deglitch)\r\ncard_inserted = pcr->ops->cd_deglitch(pcr);\r\ncard_detect = card_inserted | card_removed;\r\npcr->card_exist |= card_inserted;\r\npcr->card_exist &= ~card_removed;\r\n}\r\nmutex_unlock(&pcr->pcr_mutex);\r\nif ((card_detect & SD_EXIST) && pcr->slots[RTSX_SD_CARD].card_event)\r\npcr->slots[RTSX_SD_CARD].card_event(\r\npcr->slots[RTSX_SD_CARD].p_dev);\r\nif ((card_detect & MS_EXIST) && pcr->slots[RTSX_MS_CARD].card_event)\r\npcr->slots[RTSX_MS_CARD].card_event(\r\npcr->slots[RTSX_MS_CARD].p_dev);\r\n}\r\nstatic irqreturn_t rtsx_pci_isr(int irq, void *dev_id)\r\n{\r\nstruct rtsx_pcr *pcr = dev_id;\r\nu32 int_reg;\r\nif (!pcr)\r\nreturn IRQ_NONE;\r\nspin_lock(&pcr->lock);\r\nint_reg = rtsx_pci_readl(pcr, RTSX_BIPR);\r\nrtsx_pci_writel(pcr, RTSX_BIPR, int_reg);\r\nif ((int_reg & pcr->bier) == 0) {\r\nspin_unlock(&pcr->lock);\r\nreturn IRQ_NONE;\r\n}\r\nif (int_reg == 0xFFFFFFFF) {\r\nspin_unlock(&pcr->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nint_reg &= (pcr->bier | 0x7FFFFF);\r\nif (int_reg & SD_INT) {\r\nif (int_reg & SD_EXIST) {\r\npcr->card_inserted |= SD_EXIST;\r\n} else {\r\npcr->card_removed |= SD_EXIST;\r\npcr->card_inserted &= ~SD_EXIST;\r\n}\r\n}\r\nif (int_reg & MS_INT) {\r\nif (int_reg & MS_EXIST) {\r\npcr->card_inserted |= MS_EXIST;\r\n} else {\r\npcr->card_removed |= MS_EXIST;\r\npcr->card_inserted &= ~MS_EXIST;\r\n}\r\n}\r\nif (int_reg & (NEED_COMPLETE_INT | DELINK_INT)) {\r\nif (int_reg & (TRANS_FAIL_INT | DELINK_INT)) {\r\npcr->trans_result = TRANS_RESULT_FAIL;\r\nif (pcr->done)\r\ncomplete(pcr->done);\r\n} else if (int_reg & TRANS_OK_INT) {\r\npcr->trans_result = TRANS_RESULT_OK;\r\nif (pcr->done)\r\ncomplete(pcr->done);\r\n}\r\n}\r\nif (pcr->card_inserted || pcr->card_removed)\r\nschedule_delayed_work(&pcr->carddet_work,\r\nmsecs_to_jiffies(200));\r\nspin_unlock(&pcr->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rtsx_pci_acquire_irq(struct rtsx_pcr *pcr)\r\n{\r\ndev_info(&(pcr->pci->dev), "%s: pcr->msi_en = %d, pci->irq = %d\n",\r\n__func__, pcr->msi_en, pcr->pci->irq);\r\nif (request_irq(pcr->pci->irq, rtsx_pci_isr,\r\npcr->msi_en ? 0 : IRQF_SHARED,\r\nDRV_NAME_RTSX_PCI, pcr)) {\r\ndev_err(&(pcr->pci->dev),\r\n"rtsx_sdmmc: unable to grab IRQ %d, disabling device\n",\r\npcr->pci->irq);\r\nreturn -1;\r\n}\r\npcr->irq = pcr->pci->irq;\r\npci_intx(pcr->pci, !pcr->msi_en);\r\nreturn 0;\r\n}\r\nstatic void rtsx_pci_idle_work(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct rtsx_pcr *pcr = container_of(dwork, struct rtsx_pcr, idle_work);\r\ndev_dbg(&(pcr->pci->dev), "--> %s\n", __func__);\r\nmutex_lock(&pcr->pcr_mutex);\r\npcr->state = PDEV_STAT_IDLE;\r\nif (pcr->ops->disable_auto_blink)\r\npcr->ops->disable_auto_blink(pcr);\r\nif (pcr->ops->turn_off_led)\r\npcr->ops->turn_off_led(pcr);\r\nif (pcr->aspm_en)\r\nrtsx_pci_write_config_byte(pcr, LCTLR, pcr->aspm_en);\r\nmutex_unlock(&pcr->pcr_mutex);\r\n}\r\nstatic void rtsx_pci_power_off(struct rtsx_pcr *pcr, u8 pm_state)\r\n{\r\nif (pcr->ops->turn_off_led)\r\npcr->ops->turn_off_led(pcr);\r\nrtsx_pci_writel(pcr, RTSX_BIER, 0);\r\npcr->bier = 0;\r\nrtsx_pci_write_register(pcr, PETXCFG, 0x08, 0x08);\r\nrtsx_pci_write_register(pcr, HOST_SLEEP_STATE, 0x03, pm_state);\r\nif (pcr->ops->force_power_down)\r\npcr->ops->force_power_down(pcr, pm_state);\r\n}\r\nstatic int rtsx_pci_init_hw(struct rtsx_pcr *pcr)\r\n{\r\nint err;\r\nrtsx_pci_writel(pcr, RTSX_HCBAR, pcr->host_cmds_addr);\r\nrtsx_pci_enable_bus_int(pcr);\r\nerr = rtsx_pci_write_register(pcr, FPDCTL, SSC_POWER_DOWN, 0);\r\nif (err < 0)\r\nreturn err;\r\nudelay(200);\r\nif (pcr->ops->optimize_phy) {\r\nerr = pcr->ops->optimize_phy(pcr);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nrtsx_pci_init_cmd(pcr);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_DIV, 0x07, 0x07);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, HOST_SLEEP_STATE, 0x03, 0x00);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_CLK_EN, 0x1E, 0);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CHANGE_LINK_STATE, 0x0A, 0);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_DRIVE_SEL,\r\n0xFF, pcr->card_drive_sel);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL1,\r\n0xFF, SSC_8X_EN | SSC_SEL_4M);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SSC_CTL2, 0xFF, 0x12);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CHANGE_LINK_STATE, 0x16, 0x10);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, IRQSTAT0,\r\nLINK_RDY_INT, LINK_RDY_INT);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, PERST_GLITCH_WIDTH, 0xFF, 0x80);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, RCCTL, 0x01, 0x00);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, NFTS_TX_CTRL, 0x02, 0);\r\nerr = rtsx_pci_send_cmd(pcr, 100);\r\nif (err < 0)\r\nreturn err;\r\nrtsx_pci_write_config_byte(pcr, LCTLR, 0);\r\nrtsx_pci_write_config_byte(pcr, 0x81, 1);\r\nrtsx_pci_write_config_byte(pcr, 0x70F, 0x5B);\r\nif (pcr->ops->extra_init_hw) {\r\nerr = pcr->ops->extra_init_hw(pcr);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (pcr->ops->cd_deglitch)\r\npcr->card_exist = pcr->ops->cd_deglitch(pcr);\r\nelse\r\npcr->card_exist = rtsx_pci_readl(pcr, RTSX_BIPR) & CARD_EXIST;\r\nreturn 0;\r\n}\r\nstatic int rtsx_pci_init_chip(struct rtsx_pcr *pcr)\r\n{\r\nint err;\r\nspin_lock_init(&pcr->lock);\r\nmutex_init(&pcr->pcr_mutex);\r\nswitch (PCI_PID(pcr)) {\r\ndefault:\r\ncase 0x5209:\r\nrts5209_init_params(pcr);\r\nbreak;\r\ncase 0x5229:\r\nrts5229_init_params(pcr);\r\nbreak;\r\ncase 0x5289:\r\nrtl8411_init_params(pcr);\r\nbreak;\r\ncase 0x5227:\r\nrts5227_init_params(pcr);\r\nbreak;\r\ncase 0x5249:\r\nrts5249_init_params(pcr);\r\nbreak;\r\ncase 0x5287:\r\nrtl8411b_init_params(pcr);\r\nbreak;\r\ncase 0x5286:\r\nrtl8402_init_params(pcr);\r\nbreak;\r\n}\r\ndev_dbg(&(pcr->pci->dev), "PID: 0x%04x, IC version: 0x%02x\n",\r\nPCI_PID(pcr), pcr->ic_version);\r\npcr->slots = kcalloc(pcr->num_slots, sizeof(struct rtsx_slot),\r\nGFP_KERNEL);\r\nif (!pcr->slots)\r\nreturn -ENOMEM;\r\nif (pcr->ops->fetch_vendor_settings)\r\npcr->ops->fetch_vendor_settings(pcr);\r\ndev_dbg(&(pcr->pci->dev), "pcr->aspm_en = 0x%x\n", pcr->aspm_en);\r\ndev_dbg(&(pcr->pci->dev), "pcr->sd30_drive_sel_1v8 = 0x%x\n",\r\npcr->sd30_drive_sel_1v8);\r\ndev_dbg(&(pcr->pci->dev), "pcr->sd30_drive_sel_3v3 = 0x%x\n",\r\npcr->sd30_drive_sel_3v3);\r\ndev_dbg(&(pcr->pci->dev), "pcr->card_drive_sel = 0x%x\n",\r\npcr->card_drive_sel);\r\ndev_dbg(&(pcr->pci->dev), "pcr->flags = 0x%x\n", pcr->flags);\r\npcr->state = PDEV_STAT_IDLE;\r\nerr = rtsx_pci_init_hw(pcr);\r\nif (err < 0) {\r\nkfree(pcr->slots);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtsx_pci_probe(struct pci_dev *pcidev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct rtsx_pcr *pcr;\r\nstruct pcr_handle *handle;\r\nu32 base, len;\r\nint ret, i;\r\ndev_dbg(&(pcidev->dev),\r\n": Realtek PCI-E Card Reader found at %s [%04x:%04x] (rev %x)\n",\r\npci_name(pcidev), (int)pcidev->vendor, (int)pcidev->device,\r\n(int)pcidev->revision);\r\nret = pci_set_dma_mask(pcidev, DMA_BIT_MASK(32));\r\nif (ret < 0)\r\nreturn ret;\r\nret = pci_enable_device(pcidev);\r\nif (ret)\r\nreturn ret;\r\nret = pci_request_regions(pcidev, DRV_NAME_RTSX_PCI);\r\nif (ret)\r\ngoto disable;\r\npcr = kzalloc(sizeof(*pcr), GFP_KERNEL);\r\nif (!pcr) {\r\nret = -ENOMEM;\r\ngoto release_pci;\r\n}\r\nhandle = kzalloc(sizeof(*handle), GFP_KERNEL);\r\nif (!handle) {\r\nret = -ENOMEM;\r\ngoto free_pcr;\r\n}\r\nhandle->pcr = pcr;\r\nidr_preload(GFP_KERNEL);\r\nspin_lock(&rtsx_pci_lock);\r\nret = idr_alloc(&rtsx_pci_idr, pcr, 0, 0, GFP_NOWAIT);\r\nif (ret >= 0)\r\npcr->id = ret;\r\nspin_unlock(&rtsx_pci_lock);\r\nidr_preload_end();\r\nif (ret < 0)\r\ngoto free_handle;\r\npcr->pci = pcidev;\r\ndev_set_drvdata(&pcidev->dev, handle);\r\nlen = pci_resource_len(pcidev, 0);\r\nbase = pci_resource_start(pcidev, 0);\r\npcr->remap_addr = ioremap_nocache(base, len);\r\nif (!pcr->remap_addr) {\r\nret = -ENOMEM;\r\ngoto free_handle;\r\n}\r\npcr->rtsx_resv_buf = dma_alloc_coherent(&(pcidev->dev),\r\nRTSX_RESV_BUF_LEN, &(pcr->rtsx_resv_buf_addr),\r\nGFP_KERNEL);\r\nif (pcr->rtsx_resv_buf == NULL) {\r\nret = -ENXIO;\r\ngoto unmap;\r\n}\r\npcr->host_cmds_ptr = pcr->rtsx_resv_buf;\r\npcr->host_cmds_addr = pcr->rtsx_resv_buf_addr;\r\npcr->host_sg_tbl_ptr = pcr->rtsx_resv_buf + HOST_CMDS_BUF_LEN;\r\npcr->host_sg_tbl_addr = pcr->rtsx_resv_buf_addr + HOST_CMDS_BUF_LEN;\r\npcr->card_inserted = 0;\r\npcr->card_removed = 0;\r\nINIT_DELAYED_WORK(&pcr->carddet_work, rtsx_pci_card_detect);\r\nINIT_DELAYED_WORK(&pcr->idle_work, rtsx_pci_idle_work);\r\npcr->msi_en = msi_en;\r\nif (pcr->msi_en) {\r\nret = pci_enable_msi(pcidev);\r\nif (ret < 0)\r\npcr->msi_en = false;\r\n}\r\nret = rtsx_pci_acquire_irq(pcr);\r\nif (ret < 0)\r\ngoto disable_msi;\r\npci_set_master(pcidev);\r\nsynchronize_irq(pcr->irq);\r\nret = rtsx_pci_init_chip(pcr);\r\nif (ret < 0)\r\ngoto disable_irq;\r\nfor (i = 0; i < ARRAY_SIZE(rtsx_pcr_cells); i++) {\r\nrtsx_pcr_cells[i].platform_data = handle;\r\nrtsx_pcr_cells[i].pdata_size = sizeof(*handle);\r\n}\r\nret = mfd_add_devices(&pcidev->dev, pcr->id, rtsx_pcr_cells,\r\nARRAY_SIZE(rtsx_pcr_cells), NULL, 0, NULL);\r\nif (ret < 0)\r\ngoto disable_irq;\r\nschedule_delayed_work(&pcr->idle_work, msecs_to_jiffies(200));\r\nreturn 0;\r\ndisable_irq:\r\nfree_irq(pcr->irq, (void *)pcr);\r\ndisable_msi:\r\nif (pcr->msi_en)\r\npci_disable_msi(pcr->pci);\r\ndma_free_coherent(&(pcr->pci->dev), RTSX_RESV_BUF_LEN,\r\npcr->rtsx_resv_buf, pcr->rtsx_resv_buf_addr);\r\nunmap:\r\niounmap(pcr->remap_addr);\r\nfree_handle:\r\nkfree(handle);\r\nfree_pcr:\r\nkfree(pcr);\r\nrelease_pci:\r\npci_release_regions(pcidev);\r\ndisable:\r\npci_disable_device(pcidev);\r\nreturn ret;\r\n}\r\nstatic void rtsx_pci_remove(struct pci_dev *pcidev)\r\n{\r\nstruct pcr_handle *handle = pci_get_drvdata(pcidev);\r\nstruct rtsx_pcr *pcr = handle->pcr;\r\npcr->remove_pci = true;\r\nspin_lock_irq(&pcr->lock);\r\nrtsx_pci_writel(pcr, RTSX_BIER, 0);\r\npcr->bier = 0;\r\nspin_unlock_irq(&pcr->lock);\r\ncancel_delayed_work_sync(&pcr->carddet_work);\r\ncancel_delayed_work_sync(&pcr->idle_work);\r\nmfd_remove_devices(&pcidev->dev);\r\ndma_free_coherent(&(pcr->pci->dev), RTSX_RESV_BUF_LEN,\r\npcr->rtsx_resv_buf, pcr->rtsx_resv_buf_addr);\r\nfree_irq(pcr->irq, (void *)pcr);\r\nif (pcr->msi_en)\r\npci_disable_msi(pcr->pci);\r\niounmap(pcr->remap_addr);\r\npci_release_regions(pcidev);\r\npci_disable_device(pcidev);\r\nspin_lock(&rtsx_pci_lock);\r\nidr_remove(&rtsx_pci_idr, pcr->id);\r\nspin_unlock(&rtsx_pci_lock);\r\nkfree(pcr->slots);\r\nkfree(pcr);\r\nkfree(handle);\r\ndev_dbg(&(pcidev->dev),\r\n": Realtek PCI-E Card Reader at %s [%04x:%04x] has been removed\n",\r\npci_name(pcidev), (int)pcidev->vendor, (int)pcidev->device);\r\n}\r\nstatic int rtsx_pci_suspend(struct pci_dev *pcidev, pm_message_t state)\r\n{\r\nstruct pcr_handle *handle;\r\nstruct rtsx_pcr *pcr;\r\ndev_dbg(&(pcidev->dev), "--> %s\n", __func__);\r\nhandle = pci_get_drvdata(pcidev);\r\npcr = handle->pcr;\r\ncancel_delayed_work(&pcr->carddet_work);\r\ncancel_delayed_work(&pcr->idle_work);\r\nmutex_lock(&pcr->pcr_mutex);\r\nrtsx_pci_power_off(pcr, HOST_ENTER_S3);\r\npci_save_state(pcidev);\r\npci_enable_wake(pcidev, pci_choose_state(pcidev, state), 0);\r\npci_disable_device(pcidev);\r\npci_set_power_state(pcidev, pci_choose_state(pcidev, state));\r\nmutex_unlock(&pcr->pcr_mutex);\r\nreturn 0;\r\n}\r\nstatic int rtsx_pci_resume(struct pci_dev *pcidev)\r\n{\r\nstruct pcr_handle *handle;\r\nstruct rtsx_pcr *pcr;\r\nint ret = 0;\r\ndev_dbg(&(pcidev->dev), "--> %s\n", __func__);\r\nhandle = pci_get_drvdata(pcidev);\r\npcr = handle->pcr;\r\nmutex_lock(&pcr->pcr_mutex);\r\npci_set_power_state(pcidev, PCI_D0);\r\npci_restore_state(pcidev);\r\nret = pci_enable_device(pcidev);\r\nif (ret)\r\ngoto out;\r\npci_set_master(pcidev);\r\nret = rtsx_pci_write_register(pcr, HOST_SLEEP_STATE, 0x03, 0x00);\r\nif (ret)\r\ngoto out;\r\nret = rtsx_pci_init_hw(pcr);\r\nif (ret)\r\ngoto out;\r\nschedule_delayed_work(&pcr->idle_work, msecs_to_jiffies(200));\r\nout:\r\nmutex_unlock(&pcr->pcr_mutex);\r\nreturn ret;\r\n}\r\nstatic void rtsx_pci_shutdown(struct pci_dev *pcidev)\r\n{\r\nstruct pcr_handle *handle;\r\nstruct rtsx_pcr *pcr;\r\ndev_dbg(&(pcidev->dev), "--> %s\n", __func__);\r\nhandle = pci_get_drvdata(pcidev);\r\npcr = handle->pcr;\r\nrtsx_pci_power_off(pcr, HOST_ENTER_S1);\r\npci_disable_device(pcidev);\r\n}
