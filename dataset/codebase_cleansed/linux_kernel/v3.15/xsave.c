void __sanitize_i387_state(struct task_struct *tsk)\r\n{\r\nstruct i387_fxsave_struct *fx = &tsk->thread.fpu.state->fxsave;\r\nint feature_bit = 0x2;\r\nu64 xstate_bv;\r\nif (!fx)\r\nreturn;\r\nxstate_bv = tsk->thread.fpu.state->xsave.xsave_hdr.xstate_bv;\r\nif ((xstate_bv & pcntxt_mask) == pcntxt_mask)\r\nreturn;\r\nif (!(xstate_bv & XSTATE_FP)) {\r\nfx->cwd = 0x37f;\r\nfx->swd = 0;\r\nfx->twd = 0;\r\nfx->fop = 0;\r\nfx->rip = 0;\r\nfx->rdp = 0;\r\nmemset(&fx->st_space[0], 0, 128);\r\n}\r\nif (!(xstate_bv & XSTATE_SSE))\r\nmemset(&fx->xmm_space[0], 0, 256);\r\nxstate_bv = (pcntxt_mask & ~xstate_bv) >> 2;\r\nwhile (xstate_bv) {\r\nif (xstate_bv & 0x1) {\r\nint offset = xstate_offsets[feature_bit];\r\nint size = xstate_sizes[feature_bit];\r\nmemcpy(((void *) fx) + offset,\r\n((void *) init_xstate_buf) + offset,\r\nsize);\r\n}\r\nxstate_bv >>= 1;\r\nfeature_bit++;\r\n}\r\n}\r\nstatic inline int check_for_xstate(struct i387_fxsave_struct __user *buf,\r\nvoid __user *fpstate,\r\nstruct _fpx_sw_bytes *fx_sw)\r\n{\r\nint min_xstate_size = sizeof(struct i387_fxsave_struct) +\r\nsizeof(struct xsave_hdr_struct);\r\nunsigned int magic2;\r\nif (__copy_from_user(fx_sw, &buf->sw_reserved[0], sizeof(*fx_sw)))\r\nreturn -1;\r\nif (fx_sw->magic1 != FP_XSTATE_MAGIC1 ||\r\nfx_sw->xstate_size < min_xstate_size ||\r\nfx_sw->xstate_size > xstate_size ||\r\nfx_sw->xstate_size > fx_sw->extended_size)\r\nreturn -1;\r\nif (__get_user(magic2, (__u32 __user *)(fpstate + fx_sw->xstate_size))\r\n|| magic2 != FP_XSTATE_MAGIC2)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic inline int save_fsave_header(struct task_struct *tsk, void __user *buf)\r\n{\r\nif (use_fxsr()) {\r\nstruct xsave_struct *xsave = &tsk->thread.fpu.state->xsave;\r\nstruct user_i387_ia32_struct env;\r\nstruct _fpstate_ia32 __user *fp = buf;\r\nconvert_from_fxsr(&env, tsk);\r\nif (__copy_to_user(buf, &env, sizeof(env)) ||\r\n__put_user(xsave->i387.swd, &fp->status) ||\r\n__put_user(X86_FXSR_MAGIC, &fp->magic))\r\nreturn -1;\r\n} else {\r\nstruct i387_fsave_struct __user *fp = buf;\r\nu32 swd;\r\nif (__get_user(swd, &fp->swd) || __put_user(swd, &fp->status))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int save_xstate_epilog(void __user *buf, int ia32_frame)\r\n{\r\nstruct xsave_struct __user *x = buf;\r\nstruct _fpx_sw_bytes *sw_bytes;\r\nu32 xstate_bv;\r\nint err;\r\nsw_bytes = ia32_frame ? &fx_sw_reserved_ia32 : &fx_sw_reserved;\r\nerr = __copy_to_user(&x->i387.sw_reserved, sw_bytes, sizeof(*sw_bytes));\r\nif (!use_xsave())\r\nreturn err;\r\nerr |= __put_user(FP_XSTATE_MAGIC2, (__u32 *)(buf + xstate_size));\r\nerr |= __get_user(xstate_bv, (__u32 *)&x->xsave_hdr.xstate_bv);\r\nxstate_bv |= XSTATE_FPSSE;\r\nerr |= __put_user(xstate_bv, (__u32 *)&x->xsave_hdr.xstate_bv);\r\nreturn err;\r\n}\r\nstatic inline int save_user_xstate(struct xsave_struct __user *buf)\r\n{\r\nint err;\r\nif (use_xsave())\r\nerr = xsave_user(buf);\r\nelse if (use_fxsr())\r\nerr = fxsave_user((struct i387_fxsave_struct __user *) buf);\r\nelse\r\nerr = fsave_user((struct i387_fsave_struct __user *) buf);\r\nif (unlikely(err) && __clear_user(buf, xstate_size))\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nint save_xstate_sig(void __user *buf, void __user *buf_fx, int size)\r\n{\r\nstruct xsave_struct *xsave = &current->thread.fpu.state->xsave;\r\nstruct task_struct *tsk = current;\r\nint ia32_fxstate = (buf != buf_fx);\r\nia32_fxstate &= (config_enabled(CONFIG_X86_32) ||\r\nconfig_enabled(CONFIG_IA32_EMULATION));\r\nif (!access_ok(VERIFY_WRITE, buf, size))\r\nreturn -EACCES;\r\nif (!static_cpu_has(X86_FEATURE_FPU))\r\nreturn fpregs_soft_get(current, NULL, 0,\r\nsizeof(struct user_i387_ia32_struct), NULL,\r\n(struct _fpstate_ia32 __user *) buf) ? -1 : 1;\r\nif (user_has_fpu()) {\r\nif (save_user_xstate(buf_fx))\r\nreturn -1;\r\nif (ia32_fxstate)\r\nfpu_fxsave(&tsk->thread.fpu);\r\n} else {\r\nsanitize_i387_state(tsk);\r\nif (__copy_to_user(buf_fx, xsave, xstate_size))\r\nreturn -1;\r\n}\r\nif ((ia32_fxstate || !use_fxsr()) && save_fsave_header(tsk, buf))\r\nreturn -1;\r\nif (use_fxsr() && save_xstate_epilog(buf_fx, ia32_fxstate))\r\nreturn -1;\r\ndrop_init_fpu(tsk);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nsanitize_restored_xstate(struct task_struct *tsk,\r\nstruct user_i387_ia32_struct *ia32_env,\r\nu64 xstate_bv, int fx_only)\r\n{\r\nstruct xsave_struct *xsave = &tsk->thread.fpu.state->xsave;\r\nstruct xsave_hdr_struct *xsave_hdr = &xsave->xsave_hdr;\r\nif (use_xsave()) {\r\nxsave_hdr->reserved1[0] = xsave_hdr->reserved1[1] = 0;\r\nif (fx_only)\r\nxsave_hdr->xstate_bv = XSTATE_FPSSE;\r\nelse\r\nxsave_hdr->xstate_bv &= (pcntxt_mask & xstate_bv);\r\n}\r\nif (use_fxsr()) {\r\nxsave->i387.mxcsr &= mxcsr_feature_mask;\r\nconvert_to_fxsr(tsk, ia32_env);\r\n}\r\n}\r\nstatic inline int restore_user_xstate(void __user *buf, u64 xbv, int fx_only)\r\n{\r\nif (use_xsave()) {\r\nif ((unsigned long)buf % 64 || fx_only) {\r\nu64 init_bv = pcntxt_mask & ~XSTATE_FPSSE;\r\nxrstor_state(init_xstate_buf, init_bv);\r\nreturn fxrstor_user(buf);\r\n} else {\r\nu64 init_bv = pcntxt_mask & ~xbv;\r\nif (unlikely(init_bv))\r\nxrstor_state(init_xstate_buf, init_bv);\r\nreturn xrestore_user(buf, xbv);\r\n}\r\n} else if (use_fxsr()) {\r\nreturn fxrstor_user(buf);\r\n} else\r\nreturn frstor_user(buf);\r\n}\r\nint __restore_xstate_sig(void __user *buf, void __user *buf_fx, int size)\r\n{\r\nint ia32_fxstate = (buf != buf_fx);\r\nstruct task_struct *tsk = current;\r\nint state_size = xstate_size;\r\nu64 xstate_bv = 0;\r\nint fx_only = 0;\r\nia32_fxstate &= (config_enabled(CONFIG_X86_32) ||\r\nconfig_enabled(CONFIG_IA32_EMULATION));\r\nif (!buf) {\r\ndrop_init_fpu(tsk);\r\nreturn 0;\r\n}\r\nif (!access_ok(VERIFY_READ, buf, size))\r\nreturn -EACCES;\r\nif (!used_math() && init_fpu(tsk))\r\nreturn -1;\r\nif (!static_cpu_has(X86_FEATURE_FPU))\r\nreturn fpregs_soft_set(current, NULL,\r\n0, sizeof(struct user_i387_ia32_struct),\r\nNULL, buf) != 0;\r\nif (use_xsave()) {\r\nstruct _fpx_sw_bytes fx_sw_user;\r\nif (unlikely(check_for_xstate(buf_fx, buf_fx, &fx_sw_user))) {\r\nstate_size = sizeof(struct i387_fxsave_struct);\r\nfx_only = 1;\r\n} else {\r\nstate_size = fx_sw_user.xstate_size;\r\nxstate_bv = fx_sw_user.xstate_bv;\r\n}\r\n}\r\nif (ia32_fxstate) {\r\nstruct xsave_struct *xsave = &tsk->thread.fpu.state->xsave;\r\nstruct user_i387_ia32_struct env;\r\nint err = 0;\r\ndrop_fpu(tsk);\r\nif (__copy_from_user(xsave, buf_fx, state_size) ||\r\n__copy_from_user(&env, buf, sizeof(env))) {\r\nerr = -1;\r\n} else {\r\nsanitize_restored_xstate(tsk, &env, xstate_bv, fx_only);\r\nset_used_math();\r\n}\r\nif (use_eager_fpu())\r\nmath_state_restore();\r\nreturn err;\r\n} else {\r\nuser_fpu_begin();\r\nif (restore_user_xstate(buf_fx, xstate_bv, fx_only)) {\r\ndrop_init_fpu(tsk);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void prepare_fx_sw_frame(void)\r\n{\r\nint fsave_header_size = sizeof(struct i387_fsave_struct);\r\nint size = xstate_size + FP_XSTATE_MAGIC2_SIZE;\r\nif (config_enabled(CONFIG_X86_32))\r\nsize += fsave_header_size;\r\nfx_sw_reserved.magic1 = FP_XSTATE_MAGIC1;\r\nfx_sw_reserved.extended_size = size;\r\nfx_sw_reserved.xstate_bv = pcntxt_mask;\r\nfx_sw_reserved.xstate_size = xstate_size;\r\nif (config_enabled(CONFIG_IA32_EMULATION)) {\r\nfx_sw_reserved_ia32 = fx_sw_reserved;\r\nfx_sw_reserved_ia32.extended_size += fsave_header_size;\r\n}\r\n}\r\nstatic inline void xstate_enable(void)\r\n{\r\nset_in_cr4(X86_CR4_OSXSAVE);\r\nxsetbv(XCR_XFEATURE_ENABLED_MASK, pcntxt_mask);\r\n}\r\nstatic void __init setup_xstate_features(void)\r\n{\r\nint eax, ebx, ecx, edx, leaf = 0x2;\r\nxstate_features = fls64(pcntxt_mask);\r\nxstate_offsets = alloc_bootmem(xstate_features * sizeof(int));\r\nxstate_sizes = alloc_bootmem(xstate_features * sizeof(int));\r\ndo {\r\ncpuid_count(XSTATE_CPUID, leaf, &eax, &ebx, &ecx, &edx);\r\nif (eax == 0)\r\nbreak;\r\nxstate_offsets[leaf] = ebx;\r\nxstate_sizes[leaf] = eax;\r\nleaf++;\r\n} while (1);\r\n}\r\nstatic void __init setup_init_fpu_buf(void)\r\n{\r\ninit_xstate_buf = alloc_bootmem_align(xstate_size,\r\n__alignof__(struct xsave_struct));\r\nfx_finit(&init_xstate_buf->i387);\r\nif (!cpu_has_xsave)\r\nreturn;\r\nsetup_xstate_features();\r\nxrstor_state(init_xstate_buf, -1);\r\nxsave_state(init_xstate_buf, -1);\r\n}\r\nstatic int __init eager_fpu_setup(char *s)\r\n{\r\nif (!strcmp(s, "on"))\r\neagerfpu = ENABLE;\r\nelse if (!strcmp(s, "off"))\r\neagerfpu = DISABLE;\r\nelse if (!strcmp(s, "auto"))\r\neagerfpu = AUTO;\r\nreturn 1;\r\n}\r\nstatic void __init xstate_enable_boot_cpu(void)\r\n{\r\nunsigned int eax, ebx, ecx, edx;\r\nif (boot_cpu_data.cpuid_level < XSTATE_CPUID) {\r\nWARN(1, KERN_ERR "XSTATE_CPUID missing\n");\r\nreturn;\r\n}\r\ncpuid_count(XSTATE_CPUID, 0, &eax, &ebx, &ecx, &edx);\r\npcntxt_mask = eax + ((u64)edx << 32);\r\nif ((pcntxt_mask & XSTATE_FPSSE) != XSTATE_FPSSE) {\r\npr_err("FP/SSE not shown under xsave features 0x%llx\n",\r\npcntxt_mask);\r\nBUG();\r\n}\r\npcntxt_mask = pcntxt_mask & XCNTXT_MASK;\r\nxstate_enable();\r\ncpuid_count(XSTATE_CPUID, 0, &eax, &ebx, &ecx, &edx);\r\nxstate_size = ebx;\r\nupdate_regset_xstate_info(xstate_size, pcntxt_mask);\r\nprepare_fx_sw_frame();\r\nsetup_init_fpu_buf();\r\nif (cpu_has_xsaveopt && eagerfpu != DISABLE)\r\neagerfpu = ENABLE;\r\nif (pcntxt_mask & XSTATE_EAGER) {\r\nif (eagerfpu == DISABLE) {\r\npr_err("eagerfpu not present, disabling some xstate features: 0x%llx\n",\r\npcntxt_mask & XSTATE_EAGER);\r\npcntxt_mask &= ~XSTATE_EAGER;\r\n} else {\r\neagerfpu = ENABLE;\r\n}\r\n}\r\npr_info("enabled xstate_bv 0x%llx, cntxt size 0x%x\n",\r\npcntxt_mask, xstate_size);\r\n}\r\nvoid xsave_init(void)\r\n{\r\nstatic __refdata void (*next_func)(void) = xstate_enable_boot_cpu;\r\nvoid (*this_func)(void);\r\nif (!cpu_has_xsave)\r\nreturn;\r\nthis_func = next_func;\r\nnext_func = xstate_enable;\r\nthis_func();\r\n}\r\nstatic inline void __init eager_fpu_init_bp(void)\r\n{\r\ncurrent->thread.fpu.state =\r\nalloc_bootmem_align(xstate_size, __alignof__(struct xsave_struct));\r\nif (!init_xstate_buf)\r\nsetup_init_fpu_buf();\r\n}\r\nvoid eager_fpu_init(void)\r\n{\r\nstatic __refdata void (*boot_func)(void) = eager_fpu_init_bp;\r\nclear_used_math();\r\ncurrent_thread_info()->status = 0;\r\nif (eagerfpu == ENABLE)\r\nsetup_force_cpu_cap(X86_FEATURE_EAGER_FPU);\r\nif (!cpu_has_eager_fpu) {\r\nstts();\r\nreturn;\r\n}\r\nif (boot_func) {\r\nboot_func();\r\nboot_func = NULL;\r\n}\r\ninit_fpu(current);\r\n__thread_fpu_begin(current);\r\nif (cpu_has_xsave)\r\nxrstor_state(init_xstate_buf, -1);\r\nelse\r\nfxrstor_checking(&init_xstate_buf->i387);\r\n}
