static int clk_rcg2_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nu32 cmd;\r\nint ret;\r\nret = regmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CMD_REG, &cmd);\r\nif (ret)\r\nreturn ret;\r\nreturn (cmd & CMD_ROOT_OFF) != 0;\r\n}\r\nstatic u8 clk_rcg2_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nint num_parents = __clk_get_num_parents(hw->clk);\r\nu32 cfg;\r\nint i, ret;\r\nret = regmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG, &cfg);\r\nif (ret)\r\nreturn ret;\r\ncfg &= CFG_SRC_SEL_MASK;\r\ncfg >>= CFG_SRC_SEL_SHIFT;\r\nfor (i = 0; i < num_parents; i++)\r\nif (cfg == rcg->parent_map[i])\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic int update_config(struct clk_rcg2 *rcg)\r\n{\r\nint count, ret;\r\nu32 cmd;\r\nstruct clk_hw *hw = &rcg->clkr.hw;\r\nconst char *name = __clk_get_name(hw->clk);\r\nret = regmap_update_bits(rcg->clkr.regmap, rcg->cmd_rcgr + CMD_REG,\r\nCMD_UPDATE, CMD_UPDATE);\r\nif (ret)\r\nreturn ret;\r\nfor (count = 500; count > 0; count--) {\r\nret = regmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CMD_REG, &cmd);\r\nif (ret)\r\nreturn ret;\r\nif (!(cmd & CMD_UPDATE))\r\nreturn 0;\r\nudelay(1);\r\n}\r\nWARN(1, "%s: rcg didn't update its configuration.", name);\r\nreturn 0;\r\n}\r\nstatic int clk_rcg2_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nint ret;\r\nret = regmap_update_bits(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG,\r\nCFG_SRC_SEL_MASK,\r\nrcg->parent_map[index] << CFG_SRC_SEL_SHIFT);\r\nif (ret)\r\nreturn ret;\r\nreturn update_config(rcg);\r\n}\r\nstatic unsigned long\r\ncalc_rate(unsigned long rate, u32 m, u32 n, u32 mode, u32 hid_div)\r\n{\r\nif (hid_div) {\r\nrate *= 2;\r\nrate /= hid_div + 1;\r\n}\r\nif (mode) {\r\nu64 tmp = rate;\r\ntmp *= m;\r\ndo_div(tmp, n);\r\nrate = tmp;\r\n}\r\nreturn rate;\r\n}\r\nstatic unsigned long\r\nclk_rcg2_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nu32 cfg, hid_div, m = 0, n = 0, mode = 0, mask;\r\nregmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG, &cfg);\r\nif (rcg->mnd_width) {\r\nmask = BIT(rcg->mnd_width) - 1;\r\nregmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + M_REG, &m);\r\nm &= mask;\r\nregmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + N_REG, &n);\r\nn = ~n;\r\nn &= mask;\r\nn += m;\r\nmode = cfg & CFG_MODE_MASK;\r\nmode >>= CFG_MODE_SHIFT;\r\n}\r\nmask = BIT(rcg->hid_width) - 1;\r\nhid_div = cfg >> CFG_SRC_DIV_SHIFT;\r\nhid_div &= mask;\r\nreturn calc_rate(parent_rate, m, n, mode, hid_div);\r\n}\r\nstatic const\r\nstruct freq_tbl *find_freq(const struct freq_tbl *f, unsigned long rate)\r\n{\r\nif (!f)\r\nreturn NULL;\r\nfor (; f->freq; f++)\r\nif (rate <= f->freq)\r\nreturn f;\r\nreturn NULL;\r\n}\r\nstatic long _freq_tbl_determine_rate(struct clk_hw *hw,\r\nconst struct freq_tbl *f, unsigned long rate,\r\nunsigned long *p_rate, struct clk **p)\r\n{\r\nunsigned long clk_flags;\r\nf = find_freq(f, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nclk_flags = __clk_get_flags(hw->clk);\r\n*p = clk_get_parent_by_index(hw->clk, f->src);\r\nif (clk_flags & CLK_SET_RATE_PARENT) {\r\nif (f->pre_div) {\r\nrate /= 2;\r\nrate *= f->pre_div + 1;\r\n}\r\nif (f->n) {\r\nu64 tmp = rate;\r\ntmp = tmp * f->n;\r\ndo_div(tmp, f->m);\r\nrate = tmp;\r\n}\r\n} else {\r\nrate = __clk_get_rate(*p);\r\n}\r\n*p_rate = rate;\r\nreturn f->freq;\r\n}\r\nstatic long clk_rcg2_determine_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *p_rate, struct clk **p)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nreturn _freq_tbl_determine_rate(hw, rcg->freq_tbl, rate, p_rate, p);\r\n}\r\nstatic int __clk_rcg2_set_rate(struct clk_hw *hw, unsigned long rate)\r\n{\r\nstruct clk_rcg2 *rcg = to_clk_rcg2(hw);\r\nconst struct freq_tbl *f;\r\nu32 cfg, mask;\r\nint ret;\r\nf = find_freq(rcg->freq_tbl, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nif (rcg->mnd_width && f->n) {\r\nmask = BIT(rcg->mnd_width) - 1;\r\nret = regmap_update_bits(rcg->clkr.regmap, rcg->cmd_rcgr + M_REG,\r\nmask, f->m);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(rcg->clkr.regmap, rcg->cmd_rcgr + N_REG,\r\nmask, ~(f->n - f->m));\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(rcg->clkr.regmap, rcg->cmd_rcgr + D_REG,\r\nmask, ~f->n);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmask = BIT(rcg->hid_width) - 1;\r\nmask |= CFG_SRC_SEL_MASK | CFG_MODE_MASK;\r\ncfg = f->pre_div << CFG_SRC_DIV_SHIFT;\r\ncfg |= rcg->parent_map[f->src] << CFG_SRC_SEL_SHIFT;\r\nif (rcg->mnd_width && f->n)\r\ncfg |= CFG_MODE_DUAL_EDGE;\r\nret = regmap_update_bits(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG, mask,\r\ncfg);\r\nif (ret)\r\nreturn ret;\r\nreturn update_config(rcg);\r\n}\r\nstatic int clk_rcg2_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nreturn __clk_rcg2_set_rate(hw, rate);\r\n}\r\nstatic int clk_rcg2_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate, u8 index)\r\n{\r\nreturn __clk_rcg2_set_rate(hw, rate);\r\n}
