static int apci2032_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ns->state = inl(dev->iobase + APCI2032_DO_REG);\r\nif (comedi_dio_update_state(s, data))\r\noutl(s->state, dev->iobase + APCI2032_DO_REG);\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int apci2032_int_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[1] = inl(dev->iobase + APCI2032_INT_STATUS_REG) & 3;\r\nreturn insn->n;\r\n}\r\nstatic void apci2032_int_stop(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct apci2032_int_private *subpriv = s->private;\r\nsubpriv->active = false;\r\nsubpriv->enabled_isns = 0;\r\noutl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);\r\n}\r\nstatic bool apci2032_int_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned char enabled_isns)\r\n{\r\nstruct apci2032_int_private *subpriv = s->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nbool do_event;\r\nsubpriv->enabled_isns = enabled_isns;\r\nsubpriv->stop_count = cmd->stop_arg;\r\nif (cmd->stop_src == TRIG_COUNT && subpriv->stop_count == 0) {\r\ns->async->events |= COMEDI_CB_EOA;\r\nsubpriv->active = false;\r\ndo_event = true;\r\n} else {\r\nsubpriv->active = true;\r\noutl(enabled_isns, dev->iobase + APCI2032_INT_CTRL_REG);\r\ndo_event = false;\r\n}\r\nreturn do_event;\r\n}\r\nstatic int apci2032_int_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_NONE)\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int apci2032_int_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nstruct apci2032_int_private *subpriv = s->private;\r\nunsigned char enabled_isns;\r\nunsigned int n;\r\nunsigned long flags;\r\nbool do_event;\r\nenabled_isns = 0;\r\nfor (n = 0; n < cmd->chanlist_len; n++)\r\nenabled_isns |= 1 << CR_CHAN(cmd->chanlist[n]);\r\nspin_lock_irqsave(&subpriv->spinlock, flags);\r\ndo_event = apci2032_int_start(dev, s, enabled_isns);\r\nspin_unlock_irqrestore(&subpriv->spinlock, flags);\r\nif (do_event)\r\ncomedi_event(dev, s);\r\nreturn 0;\r\n}\r\nstatic int apci2032_int_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct apci2032_int_private *subpriv = s->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&subpriv->spinlock, flags);\r\nif (subpriv->active)\r\napci2032_int_stop(dev, s);\r\nspin_unlock_irqrestore(&subpriv->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t apci2032_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct apci2032_int_private *subpriv;\r\nunsigned int val;\r\nbool do_event = false;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nval = inl(dev->iobase + APCI2032_STATUS_REG) & APCI2032_STATUS_IRQ;\r\nif (!val)\r\nreturn IRQ_NONE;\r\nsubpriv = s->private;\r\nspin_lock(&subpriv->spinlock);\r\nval = inl(dev->iobase + APCI2032_INT_STATUS_REG) & 3;\r\noutl(~val & 3, dev->iobase + APCI2032_INT_CTRL_REG);\r\nif (subpriv->active && (val & subpriv->enabled_isns) != 0) {\r\nunsigned short bits;\r\nunsigned int n, len;\r\nunsigned int *chanlist;\r\nbits = 0;\r\nlen = s->async->cmd.chanlist_len;\r\nchanlist = &s->async->cmd.chanlist[0];\r\nfor (n = 0; n < len; n++)\r\nif ((val & (1U << CR_CHAN(chanlist[n]))) != 0)\r\nbits |= 1U << n;\r\nif (comedi_buf_put(s->async, bits)) {\r\ns->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOS;\r\nif (s->async->cmd.stop_src == TRIG_COUNT &&\r\nsubpriv->stop_count > 0) {\r\nsubpriv->stop_count--;\r\nif (subpriv->stop_count == 0) {\r\ns->async->events |= COMEDI_CB_EOA;\r\napci2032_int_stop(dev, s);\r\n}\r\n}\r\n} else {\r\napci2032_int_stop(dev, s);\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\n}\r\ndo_event = true;\r\n}\r\nspin_unlock(&subpriv->spinlock);\r\nif (do_event)\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int apci2032_reset(struct comedi_device *dev)\r\n{\r\noutl(0x0, dev->iobase + APCI2032_DO_REG);\r\noutl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);\r\naddi_watchdog_reset(dev->iobase + APCI2032_WDOG_REG);\r\nreturn 0;\r\n}\r\nstatic int apci2032_auto_attach(struct comedi_device *dev,\r\nunsigned long context_unused)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndev->iobase = pci_resource_start(pcidev, 1);\r\napci2032_reset(dev);\r\nif (pcidev->irq > 0) {\r\nret = request_irq(pcidev->irq, apci2032_interrupt,\r\nIRQF_SHARED, dev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = pcidev->irq;\r\n}\r\nret = comedi_alloc_subdevices(dev, 3);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITEABLE;\r\ns->n_chan = 32;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = apci2032_do_insn_bits;\r\ns = &dev->subdevices[1];\r\nret = addi_watchdog_init(s, dev->iobase + APCI2032_WDOG_REG);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 2;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = apci2032_int_insn_bits;\r\nif (dev->irq) {\r\nstruct apci2032_int_private *subpriv;\r\ndev->read_subdev = s;\r\nsubpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);\r\nif (!subpriv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&subpriv->spinlock);\r\ns->private = subpriv;\r\ns->subdev_flags = SDF_READABLE | SDF_CMD_READ;\r\ns->len_chanlist = 2;\r\ns->do_cmdtest = apci2032_int_cmdtest;\r\ns->do_cmd = apci2032_int_cmd;\r\ns->cancel = apci2032_int_cancel;\r\n}\r\nreturn 0;\r\n}\r\nstatic void apci2032_detach(struct comedi_device *dev)\r\n{\r\nif (dev->iobase)\r\napci2032_reset(dev);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (dev->read_subdev)\r\nkfree(dev->read_subdev->private);\r\ncomedi_pci_disable(dev);\r\n}\r\nstatic int apci2032_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &apci2032_driver, id->driver_data);\r\n}
