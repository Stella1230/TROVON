static void\r\nload_plugin(struct pevent *pevent, const char *path,\r\nconst char *file, void *data)\r\n{\r\nstruct plugin_list **plugin_list = data;\r\npevent_plugin_load_func func;\r\nstruct plugin_list *list;\r\nconst char *alias;\r\nchar *plugin;\r\nvoid *handle;\r\nplugin = malloc(strlen(path) + strlen(file) + 2);\r\nif (!plugin) {\r\nwarning("could not allocate plugin memory\n");\r\nreturn;\r\n}\r\nstrcpy(plugin, path);\r\nstrcat(plugin, "/");\r\nstrcat(plugin, file);\r\nhandle = dlopen(plugin, RTLD_NOW | RTLD_GLOBAL);\r\nif (!handle) {\r\nwarning("could not load plugin '%s'\n%s\n",\r\nplugin, dlerror());\r\ngoto out_free;\r\n}\r\nalias = dlsym(handle, PEVENT_PLUGIN_ALIAS_NAME);\r\nif (!alias)\r\nalias = file;\r\nfunc = dlsym(handle, PEVENT_PLUGIN_LOADER_NAME);\r\nif (!func) {\r\nwarning("could not find func '%s' in plugin '%s'\n%s\n",\r\nPEVENT_PLUGIN_LOADER_NAME, plugin, dlerror());\r\ngoto out_free;\r\n}\r\nlist = malloc(sizeof(*list));\r\nif (!list) {\r\nwarning("could not allocate plugin memory\n");\r\ngoto out_free;\r\n}\r\nlist->next = *plugin_list;\r\nlist->handle = handle;\r\nlist->name = plugin;\r\n*plugin_list = list;\r\npr_stat("registering plugin: %s", plugin);\r\nfunc(pevent);\r\nreturn;\r\nout_free:\r\nfree(plugin);\r\n}\r\nstatic void\r\nload_plugins_dir(struct pevent *pevent, const char *suffix,\r\nconst char *path,\r\nvoid (*load_plugin)(struct pevent *pevent,\r\nconst char *path,\r\nconst char *name,\r\nvoid *data),\r\nvoid *data)\r\n{\r\nstruct dirent *dent;\r\nstruct stat st;\r\nDIR *dir;\r\nint ret;\r\nret = stat(path, &st);\r\nif (ret < 0)\r\nreturn;\r\nif (!S_ISDIR(st.st_mode))\r\nreturn;\r\ndir = opendir(path);\r\nif (!dir)\r\nreturn;\r\nwhile ((dent = readdir(dir))) {\r\nconst char *name = dent->d_name;\r\nif (strcmp(name, ".") == 0 ||\r\nstrcmp(name, "..") == 0)\r\ncontinue;\r\nif (strcmp(name + (strlen(name) - strlen(suffix)), suffix) != 0)\r\ncontinue;\r\nload_plugin(pevent, path, name, data);\r\n}\r\nclosedir(dir);\r\n}\r\nstatic void\r\nload_plugins(struct pevent *pevent, const char *suffix,\r\nvoid (*load_plugin)(struct pevent *pevent,\r\nconst char *path,\r\nconst char *name,\r\nvoid *data),\r\nvoid *data)\r\n{\r\nchar *home;\r\nchar *path;\r\nchar *envdir;\r\n#ifdef PLUGIN_DIR\r\nload_plugins_dir(pevent, suffix, PLUGIN_DIR, load_plugin, data);\r\n#endif\r\nenvdir = getenv("TRACEEVENT_PLUGIN_DIR");\r\nif (envdir)\r\nload_plugins_dir(pevent, suffix, envdir, load_plugin, data);\r\nhome = getenv("HOME");\r\nif (!home)\r\nreturn;\r\npath = malloc(strlen(home) + strlen(LOCAL_PLUGIN_DIR) + 2);\r\nif (!path) {\r\nwarning("could not allocate plugin memory\n");\r\nreturn;\r\n}\r\nstrcpy(path, home);\r\nstrcat(path, "/");\r\nstrcat(path, LOCAL_PLUGIN_DIR);\r\nload_plugins_dir(pevent, suffix, path, load_plugin, data);\r\nfree(path);\r\n}\r\nstruct plugin_list*\r\ntraceevent_load_plugins(struct pevent *pevent)\r\n{\r\nstruct plugin_list *list = NULL;\r\nload_plugins(pevent, ".so", load_plugin, &list);\r\nreturn list;\r\n}\r\nvoid\r\ntraceevent_unload_plugins(struct plugin_list *plugin_list, struct pevent *pevent)\r\n{\r\npevent_plugin_unload_func func;\r\nstruct plugin_list *list;\r\nwhile (plugin_list) {\r\nlist = plugin_list;\r\nplugin_list = list->next;\r\nfunc = dlsym(list->handle, PEVENT_PLUGIN_UNLOADER_NAME);\r\nif (func)\r\nfunc(pevent);\r\ndlclose(list->handle);\r\nfree(list->name);\r\nfree(list);\r\n}\r\n}
