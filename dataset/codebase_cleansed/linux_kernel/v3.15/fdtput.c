static void report_error(const char *name, int namelen, int err)\r\n{\r\nif (namelen == -1)\r\nnamelen = strlen(name);\r\nfprintf(stderr, "Error at '%1.*s': %s\n", namelen, name,\r\nfdt_strerror(err));\r\n}\r\nstatic int encode_value(struct display_info *disp, char **arg, int arg_count,\r\nchar **valuep, int *value_len)\r\n{\r\nchar *value = NULL;\r\nint value_size = 0;\r\nchar *ptr;\r\nint len;\r\nint ival;\r\nint upto;\r\nchar fmt[3];\r\nupto = 0;\r\nif (disp->verbose)\r\nfprintf(stderr, "Decoding value:\n");\r\nfmt[0] = '%';\r\nfmt[1] = disp->type ? disp->type : 'd';\r\nfmt[2] = '\0';\r\nfor (; arg_count > 0; arg++, arg_count--, upto += len) {\r\nif (disp->type == 's')\r\nlen = strlen(*arg) + 1;\r\nelse\r\nlen = disp->size == -1 ? 4 : disp->size;\r\nif (upto + len > value_size) {\r\nvalue_size = (upto + len) + 500;\r\nvalue = realloc(value, value_size);\r\nif (!value) {\r\nfprintf(stderr, "Out of mmory: cannot alloc "\r\n"%d bytes\n", value_size);\r\nreturn -1;\r\n}\r\n}\r\nptr = value + upto;\r\nif (disp->type == 's') {\r\nmemcpy(ptr, *arg, len);\r\nif (disp->verbose)\r\nfprintf(stderr, "\tstring: '%s'\n", ptr);\r\n} else {\r\nint *iptr = (int *)ptr;\r\nsscanf(*arg, fmt, &ival);\r\nif (len == 4)\r\n*iptr = cpu_to_fdt32(ival);\r\nelse\r\n*ptr = (uint8_t)ival;\r\nif (disp->verbose) {\r\nfprintf(stderr, "\t%s: %d\n",\r\ndisp->size == 1 ? "byte" :\r\ndisp->size == 2 ? "short" : "int",\r\nival);\r\n}\r\n}\r\n}\r\n*value_len = upto;\r\n*valuep = value;\r\nif (disp->verbose)\r\nfprintf(stderr, "Value size %d\n", upto);\r\nreturn 0;\r\n}\r\nstatic int store_key_value(void *blob, const char *node_name,\r\nconst char *property, const char *buf, int len)\r\n{\r\nint node;\r\nint err;\r\nnode = fdt_path_offset(blob, node_name);\r\nif (node < 0) {\r\nreport_error(node_name, -1, node);\r\nreturn -1;\r\n}\r\nerr = fdt_setprop(blob, node, property, buf, len);\r\nif (err) {\r\nreport_error(property, -1, err);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_paths(void *blob, const char *in_path)\r\n{\r\nconst char *path = in_path;\r\nconst char *sep;\r\nint node, offset = 0;\r\nwhile (*path == '/')\r\npath++;\r\nfor (sep = path; *sep; path = sep + 1, offset = node) {\r\nsep = strchr(path, '/');\r\nif (!sep)\r\nsep = path + strlen(path);\r\nnode = fdt_subnode_offset_namelen(blob, offset, path,\r\nsep - path);\r\nif (node == -FDT_ERR_NOTFOUND) {\r\nnode = fdt_add_subnode_namelen(blob, offset, path,\r\nsep - path);\r\n}\r\nif (node < 0) {\r\nreport_error(path, sep - path, node);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_node(void *blob, const char *node_name)\r\n{\r\nint node = 0;\r\nchar *p;\r\np = strrchr(node_name, '/');\r\nif (!p) {\r\nreport_error(node_name, -1, -FDT_ERR_BADPATH);\r\nreturn -1;\r\n}\r\n*p = '\0';\r\nif (p > node_name) {\r\nnode = fdt_path_offset(blob, node_name);\r\nif (node < 0) {\r\nreport_error(node_name, -1, node);\r\nreturn -1;\r\n}\r\n}\r\nnode = fdt_add_subnode(blob, node, p + 1);\r\nif (node < 0) {\r\nreport_error(p + 1, -1, node);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_fdtput(struct display_info *disp, const char *filename,\r\nchar **arg, int arg_count)\r\n{\r\nchar *value;\r\nchar *blob;\r\nint len, ret = 0;\r\nblob = utilfdt_read(filename);\r\nif (!blob)\r\nreturn -1;\r\nswitch (disp->oper) {\r\ncase OPER_WRITE_PROP:\r\nassert(arg_count >= 2);\r\nif (disp->auto_path && create_paths(blob, *arg))\r\nreturn -1;\r\nif (encode_value(disp, arg + 2, arg_count - 2, &value, &len) ||\r\nstore_key_value(blob, *arg, arg[1], value, len))\r\nret = -1;\r\nbreak;\r\ncase OPER_CREATE_NODE:\r\nfor (; ret >= 0 && arg_count--; arg++) {\r\nif (disp->auto_path)\r\nret = create_paths(blob, *arg);\r\nelse\r\nret = create_node(blob, *arg);\r\n}\r\nbreak;\r\n}\r\nif (ret >= 0)\r\nret = utilfdt_write(filename, blob);\r\nfree(blob);\r\nreturn ret;\r\n}\r\nstatic void usage(const char *msg)\r\n{\r\nif (msg)\r\nfprintf(stderr, "Error: %s\n\n", msg);\r\nfprintf(stderr, "%s", usage_msg);\r\nexit(2);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nstruct display_info disp;\r\nchar *filename = NULL;\r\nmemset(&disp, '\0', sizeof(disp));\r\ndisp.size = -1;\r\ndisp.oper = OPER_WRITE_PROP;\r\nfor (;;) {\r\nint c = getopt(argc, argv, "chpt:v");\r\nif (c == -1)\r\nbreak;\r\nswitch (c) {\r\ncase 'c':\r\ndisp.oper = OPER_CREATE_NODE;\r\nbreak;\r\ncase 'h':\r\ncase '?':\r\nusage(NULL);\r\ncase 'p':\r\ndisp.auto_path = 1;\r\nbreak;\r\ncase 't':\r\nif (utilfdt_decode_type(optarg, &disp.type,\r\n&disp.size))\r\nusage("Invalid type string");\r\nbreak;\r\ncase 'v':\r\ndisp.verbose = 1;\r\nbreak;\r\n}\r\n}\r\nif (optind < argc)\r\nfilename = argv[optind++];\r\nif (!filename)\r\nusage("Missing filename");\r\nargv += optind;\r\nargc -= optind;\r\nif (disp.oper == OPER_WRITE_PROP) {\r\nif (argc < 1)\r\nusage("Missing node");\r\nif (argc < 2)\r\nusage("Missing property");\r\n}\r\nif (do_fdtput(&disp, filename, argv, argc))\r\nreturn 1;\r\nreturn 0;\r\n}
