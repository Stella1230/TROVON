static void memcpyw(volatile u_short *dest, u_short *src, int len)\r\n{\r\nwhile (len >= 2) {\r\n*(dest++) = *(src++);\r\nlen -= 2;\r\n}\r\nif (len == 1)\r\n*dest = (*(u_char *)src) << 8;\r\n}\r\nstatic void ariadne_init_ring(struct net_device *dev)\r\n{\r\nstruct ariadne_private *priv = netdev_priv(dev);\r\nvolatile struct lancedata *lancedata = (struct lancedata *)dev->mem_start;\r\nint i;\r\nnetif_stop_queue(dev);\r\npriv->tx_full = 0;\r\npriv->cur_rx = priv->cur_tx = 0;\r\npriv->dirty_tx = 0;\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nvolatile struct TDRE *t = &lancedata->tx_ring[i];\r\nt->TMD0 = swloww(ARIADNE_RAM +\r\noffsetof(struct lancedata, tx_buff[i]));\r\nt->TMD1 = swhighw(ARIADNE_RAM +\r\noffsetof(struct lancedata, tx_buff[i])) |\r\nTF_STP | TF_ENP;\r\nt->TMD2 = swapw((u_short)-PKT_BUF_SIZE);\r\nt->TMD3 = 0;\r\npriv->tx_ring[i] = &lancedata->tx_ring[i];\r\npriv->tx_buff[i] = lancedata->tx_buff[i];\r\nnetdev_dbg(dev, "TX Entry %2d at %p, Buf at %p\n",\r\ni, &lancedata->tx_ring[i], lancedata->tx_buff[i]);\r\n}\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nvolatile struct RDRE *r = &lancedata->rx_ring[i];\r\nr->RMD0 = swloww(ARIADNE_RAM +\r\noffsetof(struct lancedata, rx_buff[i]));\r\nr->RMD1 = swhighw(ARIADNE_RAM +\r\noffsetof(struct lancedata, rx_buff[i])) |\r\nRF_OWN;\r\nr->RMD2 = swapw((u_short)-PKT_BUF_SIZE);\r\nr->RMD3 = 0x0000;\r\npriv->rx_ring[i] = &lancedata->rx_ring[i];\r\npriv->rx_buff[i] = lancedata->rx_buff[i];\r\nnetdev_dbg(dev, "RX Entry %2d at %p, Buf at %p\n",\r\ni, &lancedata->rx_ring[i], lancedata->rx_buff[i]);\r\n}\r\n}\r\nstatic int ariadne_rx(struct net_device *dev)\r\n{\r\nstruct ariadne_private *priv = netdev_priv(dev);\r\nint entry = priv->cur_rx % RX_RING_SIZE;\r\nint i;\r\nwhile (!(lowb(priv->rx_ring[entry]->RMD1) & RF_OWN)) {\r\nint status = lowb(priv->rx_ring[entry]->RMD1);\r\nif (status != (RF_STP | RF_ENP)) {\r\nif (status & RF_ENP)\r\ndev->stats.rx_errors++;\r\nif (status & RF_FRAM)\r\ndev->stats.rx_frame_errors++;\r\nif (status & RF_OFLO)\r\ndev->stats.rx_over_errors++;\r\nif (status & RF_CRC)\r\ndev->stats.rx_crc_errors++;\r\nif (status & RF_BUFF)\r\ndev->stats.rx_fifo_errors++;\r\npriv->rx_ring[entry]->RMD1 &= 0xff00 | RF_STP | RF_ENP;\r\n} else {\r\nshort pkt_len = swapw(priv->rx_ring[entry]->RMD3);\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb(dev, pkt_len + 2);\r\nif (skb == NULL) {\r\nfor (i = 0; i < RX_RING_SIZE; i++)\r\nif (lowb(priv->rx_ring[(entry + i) % RX_RING_SIZE]->RMD1) & RF_OWN)\r\nbreak;\r\nif (i > RX_RING_SIZE - 2) {\r\ndev->stats.rx_dropped++;\r\npriv->rx_ring[entry]->RMD1 |= RF_OWN;\r\npriv->cur_rx++;\r\n}\r\nbreak;\r\n}\r\nskb_reserve(skb, 2);\r\nskb_put(skb, pkt_len);\r\nskb_copy_to_linear_data(skb,\r\n(const void *)priv->rx_buff[entry],\r\npkt_len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetdev_dbg(dev, "RX pkt type 0x%04x from %pM to %pM data %p len %u\n",\r\n((u_short *)skb->data)[6],\r\nskb->data + 6, skb->data,\r\nskb->data, skb->len);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\npriv->rx_ring[entry]->RMD1 |= RF_OWN;\r\nentry = (++priv->cur_rx) % RX_RING_SIZE;\r\n}\r\npriv->cur_rx = priv->cur_rx % RX_RING_SIZE;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ariadne_interrupt(int irq, void *data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\r\nstruct ariadne_private *priv;\r\nint csr0, boguscnt;\r\nint handled = 0;\r\nlance->RAP = CSR0;\r\nif (!(lance->RDP & INTR))\r\nreturn IRQ_NONE;\r\npriv = netdev_priv(dev);\r\nboguscnt = 10;\r\nwhile ((csr0 = lance->RDP) & (ERR | RINT | TINT) && --boguscnt >= 0) {\r\nlance->RDP = csr0 & ~(INEA | TDMD | STOP | STRT | INIT);\r\n#ifdef DEBUG\r\nif (ariadne_debug > 5) {\r\nnetdev_dbg(dev, "interrupt csr0=%#02x new csr=%#02x [",\r\ncsr0, lance->RDP);\r\nif (csr0 & INTR)\r\npr_cont(" INTR");\r\nif (csr0 & INEA)\r\npr_cont(" INEA");\r\nif (csr0 & RXON)\r\npr_cont(" RXON");\r\nif (csr0 & TXON)\r\npr_cont(" TXON");\r\nif (csr0 & TDMD)\r\npr_cont(" TDMD");\r\nif (csr0 & STOP)\r\npr_cont(" STOP");\r\nif (csr0 & STRT)\r\npr_cont(" STRT");\r\nif (csr0 & INIT)\r\npr_cont(" INIT");\r\nif (csr0 & ERR)\r\npr_cont(" ERR");\r\nif (csr0 & BABL)\r\npr_cont(" BABL");\r\nif (csr0 & CERR)\r\npr_cont(" CERR");\r\nif (csr0 & MISS)\r\npr_cont(" MISS");\r\nif (csr0 & MERR)\r\npr_cont(" MERR");\r\nif (csr0 & RINT)\r\npr_cont(" RINT");\r\nif (csr0 & TINT)\r\npr_cont(" TINT");\r\nif (csr0 & IDON)\r\npr_cont(" IDON");\r\npr_cont(" ]\n");\r\n}\r\n#endif\r\nif (csr0 & RINT) {\r\nhandled = 1;\r\nariadne_rx(dev);\r\n}\r\nif (csr0 & TINT) {\r\nint dirty_tx = priv->dirty_tx;\r\nhandled = 1;\r\nwhile (dirty_tx < priv->cur_tx) {\r\nint entry = dirty_tx % TX_RING_SIZE;\r\nint status = lowb(priv->tx_ring[entry]->TMD1);\r\nif (status & TF_OWN)\r\nbreak;\r\npriv->tx_ring[entry]->TMD1 &= 0xff00;\r\nif (status & TF_ERR) {\r\nint err_status = priv->tx_ring[entry]->TMD3;\r\ndev->stats.tx_errors++;\r\nif (err_status & EF_RTRY)\r\ndev->stats.tx_aborted_errors++;\r\nif (err_status & EF_LCAR)\r\ndev->stats.tx_carrier_errors++;\r\nif (err_status & EF_LCOL)\r\ndev->stats.tx_window_errors++;\r\nif (err_status & EF_UFLO) {\r\ndev->stats.tx_fifo_errors++;\r\nnetdev_err(dev, "Tx FIFO error! Status %04x\n",\r\ncsr0);\r\nlance->RDP = STRT;\r\n}\r\n} else {\r\nif (status & (TF_MORE | TF_ONE))\r\ndev->stats.collisions++;\r\ndev->stats.tx_packets++;\r\n}\r\ndirty_tx++;\r\n}\r\n#ifndef final_version\r\nif (priv->cur_tx - dirty_tx >= TX_RING_SIZE) {\r\nnetdev_err(dev, "out-of-sync dirty pointer, %d vs. %d, full=%d\n",\r\ndirty_tx, priv->cur_tx,\r\npriv->tx_full);\r\ndirty_tx += TX_RING_SIZE;\r\n}\r\n#endif\r\nif (priv->tx_full && netif_queue_stopped(dev) &&\r\ndirty_tx > priv->cur_tx - TX_RING_SIZE + 2) {\r\npriv->tx_full = 0;\r\nnetif_wake_queue(dev);\r\n}\r\npriv->dirty_tx = dirty_tx;\r\n}\r\nif (csr0 & BABL) {\r\nhandled = 1;\r\ndev->stats.tx_errors++;\r\n}\r\nif (csr0 & MISS) {\r\nhandled = 1;\r\ndev->stats.rx_errors++;\r\n}\r\nif (csr0 & MERR) {\r\nhandled = 1;\r\nnetdev_err(dev, "Bus master arbitration failure, status %04x\n",\r\ncsr0);\r\nlance->RDP = STRT;\r\n}\r\n}\r\nlance->RAP = CSR0;\r\nlance->RDP = INEA | BABL | CERR | MISS | MERR | IDON;\r\nif (ariadne_debug > 4)\r\nnetdev_dbg(dev, "exiting interrupt, csr%d=%#04x\n",\r\nlance->RAP, lance->RDP);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int ariadne_open(struct net_device *dev)\r\n{\r\nvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\r\nu_short in;\r\nu_long version;\r\nint i;\r\nin = lance->Reset;\r\nlance->RAP = CSR0;\r\nlance->RDP = STOP;\r\nlance->RAP = CSR88;\r\nversion = swapw(lance->RDP);\r\nlance->RAP = CSR89;\r\nversion |= swapw(lance->RDP) << 16;\r\nif ((version & 0x00000fff) != 0x00000003) {\r\npr_warn("Couldn't find AMD Ethernet Chip\n");\r\nreturn -EAGAIN;\r\n}\r\nif ((version & 0x0ffff000) != 0x00003000) {\r\npr_warn("Couldn't find Am79C960 (Wrong part number = %ld)\n",\r\n(version & 0x0ffff000) >> 12);\r\nreturn -EAGAIN;\r\n}\r\nnetdev_dbg(dev, "Am79C960 (PCnet-ISA) Revision %ld\n",\r\n(version & 0xf0000000) >> 28);\r\nariadne_init_ring(dev);\r\nlance->RAP = CSR3;\r\nlance->RDP = 0x0000;\r\nlance->RAP = CSR4;\r\nlance->RDP = DPOLL | APAD_XMT | MFCOM | RCVCCOM | TXSTRTM | JABM;\r\nlance->RAP = CSR8;\r\nlance->RDP = 0x0000;\r\nlance->RAP = CSR9;\r\nlance->RDP = 0x0000;\r\nlance->RAP = CSR10;\r\nlance->RDP = 0x0000;\r\nlance->RAP = CSR11;\r\nlance->RDP = 0x0000;\r\nlance->RAP = CSR12;\r\nlance->RDP = ((u_short *)&dev->dev_addr[0])[0];\r\nlance->RAP = CSR13;\r\nlance->RDP = ((u_short *)&dev->dev_addr[0])[1];\r\nlance->RAP = CSR14;\r\nlance->RDP = ((u_short *)&dev->dev_addr[0])[2];\r\nlance->RAP = CSR15;\r\nlance->RDP = 0x0000;\r\nlance->RAP = CSR30;\r\nlance->RDP = swloww(ARIADNE_RAM + offsetof(struct lancedata, tx_ring));\r\nlance->RAP = CSR31;\r\nlance->RDP = swhighw(ARIADNE_RAM + offsetof(struct lancedata, tx_ring));\r\nlance->RAP = CSR24;\r\nlance->RDP = swloww(ARIADNE_RAM + offsetof(struct lancedata, rx_ring));\r\nlance->RAP = CSR25;\r\nlance->RDP = swhighw(ARIADNE_RAM + offsetof(struct lancedata, rx_ring));\r\nlance->RAP = CSR76;\r\nlance->RDP = swapw(((u_short)-RX_RING_SIZE));\r\nlance->RAP = CSR78;\r\nlance->RDP = swapw(((u_short)-TX_RING_SIZE));\r\nlance->RAP = ISACSR2;\r\nlance->IDP = ASEL;\r\nlance->RAP = ISACSR5;\r\nlance->IDP = PSE|XMTE;\r\nlance->RAP = ISACSR6;\r\nlance->IDP = PSE|COLE;\r\nlance->RAP = ISACSR7;\r\nlance->IDP = PSE|RCVE;\r\nnetif_start_queue(dev);\r\ni = request_irq(IRQ_AMIGA_PORTS, ariadne_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (i)\r\nreturn i;\r\nlance->RAP = CSR0;\r\nlance->RDP = INEA | STRT;\r\nreturn 0;\r\n}\r\nstatic int ariadne_close(struct net_device *dev)\r\n{\r\nvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\r\nnetif_stop_queue(dev);\r\nlance->RAP = CSR112;\r\ndev->stats.rx_missed_errors = swapw(lance->RDP);\r\nlance->RAP = CSR0;\r\nif (ariadne_debug > 1) {\r\nnetdev_dbg(dev, "Shutting down ethercard, status was %02x\n",\r\nlance->RDP);\r\nnetdev_dbg(dev, "%lu packets missed\n",\r\ndev->stats.rx_missed_errors);\r\n}\r\nlance->RDP = STOP;\r\nfree_irq(IRQ_AMIGA_PORTS, dev);\r\nreturn 0;\r\n}\r\nstatic inline void ariadne_reset(struct net_device *dev)\r\n{\r\nvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\r\nlance->RAP = CSR0;\r\nlance->RDP = STOP;\r\nariadne_init_ring(dev);\r\nlance->RDP = INEA | STRT;\r\nnetif_start_queue(dev);\r\n}\r\nstatic void ariadne_tx_timeout(struct net_device *dev)\r\n{\r\nvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\r\nnetdev_err(dev, "transmit timed out, status %04x, resetting\n",\r\nlance->RDP);\r\nariadne_reset(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t ariadne_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct ariadne_private *priv = netdev_priv(dev);\r\nvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\r\nint entry;\r\nunsigned long flags;\r\nint len = skb->len;\r\n#if 0\r\nif (ariadne_debug > 3) {\r\nlance->RAP = CSR0;\r\nnetdev_dbg(dev, "%s: csr0 %04x\n", __func__, lance->RDP);\r\nlance->RDP = 0x0000;\r\n}\r\n#endif\r\nif (skb->len < ETH_ZLEN) {\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nlen = ETH_ZLEN;\r\n}\r\nnetdev_dbg(dev, "TX pkt type 0x%04x from %pM to %pM data %p len %u\n",\r\n((u_short *)skb->data)[6],\r\nskb->data + 6, skb->data,\r\nskb->data, skb->len);\r\nlocal_irq_save(flags);\r\nentry = priv->cur_tx % TX_RING_SIZE;\r\npriv->tx_ring[entry]->TMD2 = swapw((u_short)-skb->len);\r\npriv->tx_ring[entry]->TMD3 = 0x0000;\r\nmemcpyw(priv->tx_buff[entry], (u_short *)skb->data, len);\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_DEBUG, "tx_buff: ", DUMP_PREFIX_OFFSET, 16, 1,\r\n(void *)priv->tx_buff[entry],\r\nskb->len > 64 ? 64 : skb->len, true);\r\n#endif\r\npriv->tx_ring[entry]->TMD1 = (priv->tx_ring[entry]->TMD1 & 0xff00)\r\n| TF_OWN | TF_STP | TF_ENP;\r\ndev_kfree_skb(skb);\r\npriv->cur_tx++;\r\nif ((priv->cur_tx >= TX_RING_SIZE) &&\r\n(priv->dirty_tx >= TX_RING_SIZE)) {\r\nnetdev_dbg(dev, "*** Subtracting TX_RING_SIZE from cur_tx (%d) and dirty_tx (%d)\n",\r\npriv->cur_tx, priv->dirty_tx);\r\npriv->cur_tx -= TX_RING_SIZE;\r\npriv->dirty_tx -= TX_RING_SIZE;\r\n}\r\ndev->stats.tx_bytes += len;\r\nlance->RAP = CSR0;\r\nlance->RDP = INEA | TDMD;\r\nif (lowb(priv->tx_ring[(entry + 1) % TX_RING_SIZE]->TMD1) != 0) {\r\nnetif_stop_queue(dev);\r\npriv->tx_full = 1;\r\n}\r\nlocal_irq_restore(flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *ariadne_get_stats(struct net_device *dev)\r\n{\r\nvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\r\nshort saved_addr;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nsaved_addr = lance->RAP;\r\nlance->RAP = CSR112;\r\ndev->stats.rx_missed_errors = swapw(lance->RDP);\r\nlance->RAP = saved_addr;\r\nlocal_irq_restore(flags);\r\nreturn &dev->stats;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nvolatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;\r\nif (!netif_running(dev))\r\nreturn;\r\nnetif_stop_queue(dev);\r\nlance->RAP = CSR0;\r\nlance->RDP = STOP;\r\nariadne_init_ring(dev);\r\nif (dev->flags & IFF_PROMISC) {\r\nlance->RAP = CSR15;\r\nlance->RDP = PROM;\r\n} else {\r\nshort multicast_table[4];\r\nint num_addrs = netdev_mc_count(dev);\r\nint i;\r\nmemset(multicast_table, (num_addrs == 0) ? 0 : -1,\r\nsizeof(multicast_table));\r\nfor (i = 0; i < 4; i++) {\r\nlance->RAP = CSR8 + (i << 8);\r\nlance->RDP = swapw(multicast_table[i]);\r\n}\r\nlance->RAP = CSR15;\r\nlance->RDP = 0x0000;\r\n}\r\nlance->RAP = CSR0;\r\nlance->RDP = INEA | STRT | IDON;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void ariadne_remove_one(struct zorro_dev *z)\r\n{\r\nstruct net_device *dev = zorro_get_drvdata(z);\r\nunregister_netdev(dev);\r\nrelease_mem_region(ZTWO_PADDR(dev->base_addr), sizeof(struct Am79C960));\r\nrelease_mem_region(ZTWO_PADDR(dev->mem_start), ARIADNE_RAM_SIZE);\r\nfree_netdev(dev);\r\n}\r\nstatic int ariadne_init_one(struct zorro_dev *z,\r\nconst struct zorro_device_id *ent)\r\n{\r\nunsigned long board = z->resource.start;\r\nunsigned long base_addr = board + ARIADNE_LANCE;\r\nunsigned long mem_start = board + ARIADNE_RAM;\r\nstruct resource *r1, *r2;\r\nstruct net_device *dev;\r\nstruct ariadne_private *priv;\r\nu32 serial;\r\nint err;\r\nr1 = request_mem_region(base_addr, sizeof(struct Am79C960), "Am79C960");\r\nif (!r1)\r\nreturn -EBUSY;\r\nr2 = request_mem_region(mem_start, ARIADNE_RAM_SIZE, "RAM");\r\nif (!r2) {\r\nrelease_mem_region(base_addr, sizeof(struct Am79C960));\r\nreturn -EBUSY;\r\n}\r\ndev = alloc_etherdev(sizeof(struct ariadne_private));\r\nif (dev == NULL) {\r\nrelease_mem_region(base_addr, sizeof(struct Am79C960));\r\nrelease_mem_region(mem_start, ARIADNE_RAM_SIZE);\r\nreturn -ENOMEM;\r\n}\r\npriv = netdev_priv(dev);\r\nr1->name = dev->name;\r\nr2->name = dev->name;\r\nserial = be32_to_cpu(z->rom.er_SerialNumber);\r\ndev->dev_addr[0] = 0x00;\r\ndev->dev_addr[1] = 0x60;\r\ndev->dev_addr[2] = 0x30;\r\ndev->dev_addr[3] = (serial >> 16) & 0xff;\r\ndev->dev_addr[4] = (serial >> 8) & 0xff;\r\ndev->dev_addr[5] = serial & 0xff;\r\ndev->base_addr = (unsigned long)ZTWO_VADDR(base_addr);\r\ndev->mem_start = (unsigned long)ZTWO_VADDR(mem_start);\r\ndev->mem_end = dev->mem_start + ARIADNE_RAM_SIZE;\r\ndev->netdev_ops = &ariadne_netdev_ops;\r\ndev->watchdog_timeo = 5 * HZ;\r\nerr = register_netdev(dev);\r\nif (err) {\r\nrelease_mem_region(base_addr, sizeof(struct Am79C960));\r\nrelease_mem_region(mem_start, ARIADNE_RAM_SIZE);\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nzorro_set_drvdata(z, dev);\r\nnetdev_info(dev, "Ariadne at 0x%08lx, Ethernet Address %pM\n",\r\nboard, dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic int __init ariadne_init_module(void)\r\n{\r\nreturn zorro_register_driver(&ariadne_driver);\r\n}\r\nstatic void __exit ariadne_cleanup_module(void)\r\n{\r\nzorro_unregister_driver(&ariadne_driver);\r\n}
