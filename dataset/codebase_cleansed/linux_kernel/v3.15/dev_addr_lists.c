static int __hw_addr_create_ex(struct netdev_hw_addr_list *list,\r\nconst unsigned char *addr, int addr_len,\r\nunsigned char addr_type, bool global,\r\nbool sync)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nint alloc_size;\r\nalloc_size = sizeof(*ha);\r\nif (alloc_size < L1_CACHE_BYTES)\r\nalloc_size = L1_CACHE_BYTES;\r\nha = kmalloc(alloc_size, GFP_ATOMIC);\r\nif (!ha)\r\nreturn -ENOMEM;\r\nmemcpy(ha->addr, addr, addr_len);\r\nha->type = addr_type;\r\nha->refcount = 1;\r\nha->global_use = global;\r\nha->synced = sync ? 1 : 0;\r\nha->sync_cnt = 0;\r\nlist_add_tail_rcu(&ha->list, &list->list);\r\nlist->count++;\r\nreturn 0;\r\n}\r\nstatic int __hw_addr_add_ex(struct netdev_hw_addr_list *list,\r\nconst unsigned char *addr, int addr_len,\r\nunsigned char addr_type, bool global, bool sync,\r\nint sync_count)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nif (addr_len > MAX_ADDR_LEN)\r\nreturn -EINVAL;\r\nlist_for_each_entry(ha, &list->list, list) {\r\nif (!memcmp(ha->addr, addr, addr_len) &&\r\nha->type == addr_type) {\r\nif (global) {\r\nif (ha->global_use)\r\nreturn 0;\r\nelse\r\nha->global_use = true;\r\n}\r\nif (sync) {\r\nif (ha->synced && sync_count)\r\nreturn -EEXIST;\r\nelse\r\nha->synced++;\r\n}\r\nha->refcount++;\r\nreturn 0;\r\n}\r\n}\r\nreturn __hw_addr_create_ex(list, addr, addr_len, addr_type, global,\r\nsync);\r\n}\r\nstatic int __hw_addr_add(struct netdev_hw_addr_list *list,\r\nconst unsigned char *addr, int addr_len,\r\nunsigned char addr_type)\r\n{\r\nreturn __hw_addr_add_ex(list, addr, addr_len, addr_type, false, false,\r\n0);\r\n}\r\nstatic int __hw_addr_del_entry(struct netdev_hw_addr_list *list,\r\nstruct netdev_hw_addr *ha, bool global,\r\nbool sync)\r\n{\r\nif (global && !ha->global_use)\r\nreturn -ENOENT;\r\nif (sync && !ha->synced)\r\nreturn -ENOENT;\r\nif (global)\r\nha->global_use = false;\r\nif (sync)\r\nha->synced--;\r\nif (--ha->refcount)\r\nreturn 0;\r\nlist_del_rcu(&ha->list);\r\nkfree_rcu(ha, rcu_head);\r\nlist->count--;\r\nreturn 0;\r\n}\r\nstatic int __hw_addr_del_ex(struct netdev_hw_addr_list *list,\r\nconst unsigned char *addr, int addr_len,\r\nunsigned char addr_type, bool global, bool sync)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nlist_for_each_entry(ha, &list->list, list) {\r\nif (!memcmp(ha->addr, addr, addr_len) &&\r\n(ha->type == addr_type || !addr_type))\r\nreturn __hw_addr_del_entry(list, ha, global, sync);\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int __hw_addr_del(struct netdev_hw_addr_list *list,\r\nconst unsigned char *addr, int addr_len,\r\nunsigned char addr_type)\r\n{\r\nreturn __hw_addr_del_ex(list, addr, addr_len, addr_type, false, false);\r\n}\r\nstatic int __hw_addr_sync_one(struct netdev_hw_addr_list *to_list,\r\nstruct netdev_hw_addr *ha,\r\nint addr_len)\r\n{\r\nint err;\r\nerr = __hw_addr_add_ex(to_list, ha->addr, addr_len, ha->type,\r\nfalse, true, ha->sync_cnt);\r\nif (err && err != -EEXIST)\r\nreturn err;\r\nif (!err) {\r\nha->sync_cnt++;\r\nha->refcount++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __hw_addr_unsync_one(struct netdev_hw_addr_list *to_list,\r\nstruct netdev_hw_addr_list *from_list,\r\nstruct netdev_hw_addr *ha,\r\nint addr_len)\r\n{\r\nint err;\r\nerr = __hw_addr_del_ex(to_list, ha->addr, addr_len, ha->type,\r\nfalse, true);\r\nif (err)\r\nreturn;\r\nha->sync_cnt--;\r\n__hw_addr_del_entry(from_list, ha, false, false);\r\n}\r\nstatic int __hw_addr_sync_multiple(struct netdev_hw_addr_list *to_list,\r\nstruct netdev_hw_addr_list *from_list,\r\nint addr_len)\r\n{\r\nint err = 0;\r\nstruct netdev_hw_addr *ha, *tmp;\r\nlist_for_each_entry_safe(ha, tmp, &from_list->list, list) {\r\nif (ha->sync_cnt == ha->refcount) {\r\n__hw_addr_unsync_one(to_list, from_list, ha, addr_len);\r\n} else {\r\nerr = __hw_addr_sync_one(to_list, ha, addr_len);\r\nif (err)\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nint __hw_addr_sync(struct netdev_hw_addr_list *to_list,\r\nstruct netdev_hw_addr_list *from_list,\r\nint addr_len)\r\n{\r\nint err = 0;\r\nstruct netdev_hw_addr *ha, *tmp;\r\nlist_for_each_entry_safe(ha, tmp, &from_list->list, list) {\r\nif (!ha->sync_cnt) {\r\nerr = __hw_addr_sync_one(to_list, ha, addr_len);\r\nif (err)\r\nbreak;\r\n} else if (ha->refcount == 1)\r\n__hw_addr_unsync_one(to_list, from_list, ha, addr_len);\r\n}\r\nreturn err;\r\n}\r\nvoid __hw_addr_unsync(struct netdev_hw_addr_list *to_list,\r\nstruct netdev_hw_addr_list *from_list,\r\nint addr_len)\r\n{\r\nstruct netdev_hw_addr *ha, *tmp;\r\nlist_for_each_entry_safe(ha, tmp, &from_list->list, list) {\r\nif (ha->sync_cnt)\r\n__hw_addr_unsync_one(to_list, from_list, ha, addr_len);\r\n}\r\n}\r\nstatic void __hw_addr_flush(struct netdev_hw_addr_list *list)\r\n{\r\nstruct netdev_hw_addr *ha, *tmp;\r\nlist_for_each_entry_safe(ha, tmp, &list->list, list) {\r\nlist_del_rcu(&ha->list);\r\nkfree_rcu(ha, rcu_head);\r\n}\r\nlist->count = 0;\r\n}\r\nvoid __hw_addr_init(struct netdev_hw_addr_list *list)\r\n{\r\nINIT_LIST_HEAD(&list->list);\r\nlist->count = 0;\r\n}\r\nvoid dev_addr_flush(struct net_device *dev)\r\n{\r\n__hw_addr_flush(&dev->dev_addrs);\r\ndev->dev_addr = NULL;\r\n}\r\nint dev_addr_init(struct net_device *dev)\r\n{\r\nunsigned char addr[MAX_ADDR_LEN];\r\nstruct netdev_hw_addr *ha;\r\nint err;\r\n__hw_addr_init(&dev->dev_addrs);\r\nmemset(addr, 0, sizeof(addr));\r\nerr = __hw_addr_add(&dev->dev_addrs, addr, sizeof(addr),\r\nNETDEV_HW_ADDR_T_LAN);\r\nif (!err) {\r\nha = list_first_entry(&dev->dev_addrs.list,\r\nstruct netdev_hw_addr, list);\r\ndev->dev_addr = ha->addr;\r\n}\r\nreturn err;\r\n}\r\nint dev_addr_add(struct net_device *dev, const unsigned char *addr,\r\nunsigned char addr_type)\r\n{\r\nint err;\r\nASSERT_RTNL();\r\nerr = __hw_addr_add(&dev->dev_addrs, addr, dev->addr_len, addr_type);\r\nif (!err)\r\ncall_netdevice_notifiers(NETDEV_CHANGEADDR, dev);\r\nreturn err;\r\n}\r\nint dev_addr_del(struct net_device *dev, const unsigned char *addr,\r\nunsigned char addr_type)\r\n{\r\nint err;\r\nstruct netdev_hw_addr *ha;\r\nASSERT_RTNL();\r\nha = list_first_entry(&dev->dev_addrs.list,\r\nstruct netdev_hw_addr, list);\r\nif (!memcmp(ha->addr, addr, dev->addr_len) &&\r\nha->type == addr_type && ha->refcount == 1)\r\nreturn -ENOENT;\r\nerr = __hw_addr_del(&dev->dev_addrs, addr, dev->addr_len,\r\naddr_type);\r\nif (!err)\r\ncall_netdevice_notifiers(NETDEV_CHANGEADDR, dev);\r\nreturn err;\r\n}\r\nint dev_uc_add_excl(struct net_device *dev, const unsigned char *addr)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nint err;\r\nnetif_addr_lock_bh(dev);\r\nlist_for_each_entry(ha, &dev->uc.list, list) {\r\nif (!memcmp(ha->addr, addr, dev->addr_len) &&\r\nha->type == NETDEV_HW_ADDR_T_UNICAST) {\r\nerr = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nerr = __hw_addr_create_ex(&dev->uc, addr, dev->addr_len,\r\nNETDEV_HW_ADDR_T_UNICAST, true, false);\r\nif (!err)\r\n__dev_set_rx_mode(dev);\r\nout:\r\nnetif_addr_unlock_bh(dev);\r\nreturn err;\r\n}\r\nint dev_uc_add(struct net_device *dev, const unsigned char *addr)\r\n{\r\nint err;\r\nnetif_addr_lock_bh(dev);\r\nerr = __hw_addr_add(&dev->uc, addr, dev->addr_len,\r\nNETDEV_HW_ADDR_T_UNICAST);\r\nif (!err)\r\n__dev_set_rx_mode(dev);\r\nnetif_addr_unlock_bh(dev);\r\nreturn err;\r\n}\r\nint dev_uc_del(struct net_device *dev, const unsigned char *addr)\r\n{\r\nint err;\r\nnetif_addr_lock_bh(dev);\r\nerr = __hw_addr_del(&dev->uc, addr, dev->addr_len,\r\nNETDEV_HW_ADDR_T_UNICAST);\r\nif (!err)\r\n__dev_set_rx_mode(dev);\r\nnetif_addr_unlock_bh(dev);\r\nreturn err;\r\n}\r\nint dev_uc_sync(struct net_device *to, struct net_device *from)\r\n{\r\nint err = 0;\r\nif (to->addr_len != from->addr_len)\r\nreturn -EINVAL;\r\nnetif_addr_lock_nested(to);\r\nerr = __hw_addr_sync(&to->uc, &from->uc, to->addr_len);\r\nif (!err)\r\n__dev_set_rx_mode(to);\r\nnetif_addr_unlock(to);\r\nreturn err;\r\n}\r\nint dev_uc_sync_multiple(struct net_device *to, struct net_device *from)\r\n{\r\nint err = 0;\r\nif (to->addr_len != from->addr_len)\r\nreturn -EINVAL;\r\nnetif_addr_lock_nested(to);\r\nerr = __hw_addr_sync_multiple(&to->uc, &from->uc, to->addr_len);\r\nif (!err)\r\n__dev_set_rx_mode(to);\r\nnetif_addr_unlock(to);\r\nreturn err;\r\n}\r\nvoid dev_uc_unsync(struct net_device *to, struct net_device *from)\r\n{\r\nif (to->addr_len != from->addr_len)\r\nreturn;\r\nnetif_addr_lock_bh(from);\r\nnetif_addr_lock_nested(to);\r\n__hw_addr_unsync(&to->uc, &from->uc, to->addr_len);\r\n__dev_set_rx_mode(to);\r\nnetif_addr_unlock(to);\r\nnetif_addr_unlock_bh(from);\r\n}\r\nvoid dev_uc_flush(struct net_device *dev)\r\n{\r\nnetif_addr_lock_bh(dev);\r\n__hw_addr_flush(&dev->uc);\r\nnetif_addr_unlock_bh(dev);\r\n}\r\nvoid dev_uc_init(struct net_device *dev)\r\n{\r\n__hw_addr_init(&dev->uc);\r\n}\r\nint dev_mc_add_excl(struct net_device *dev, const unsigned char *addr)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nint err;\r\nnetif_addr_lock_bh(dev);\r\nlist_for_each_entry(ha, &dev->mc.list, list) {\r\nif (!memcmp(ha->addr, addr, dev->addr_len) &&\r\nha->type == NETDEV_HW_ADDR_T_MULTICAST) {\r\nerr = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nerr = __hw_addr_create_ex(&dev->mc, addr, dev->addr_len,\r\nNETDEV_HW_ADDR_T_MULTICAST, true, false);\r\nif (!err)\r\n__dev_set_rx_mode(dev);\r\nout:\r\nnetif_addr_unlock_bh(dev);\r\nreturn err;\r\n}\r\nstatic int __dev_mc_add(struct net_device *dev, const unsigned char *addr,\r\nbool global)\r\n{\r\nint err;\r\nnetif_addr_lock_bh(dev);\r\nerr = __hw_addr_add_ex(&dev->mc, addr, dev->addr_len,\r\nNETDEV_HW_ADDR_T_MULTICAST, global, false, 0);\r\nif (!err)\r\n__dev_set_rx_mode(dev);\r\nnetif_addr_unlock_bh(dev);\r\nreturn err;\r\n}\r\nint dev_mc_add(struct net_device *dev, const unsigned char *addr)\r\n{\r\nreturn __dev_mc_add(dev, addr, false);\r\n}\r\nint dev_mc_add_global(struct net_device *dev, const unsigned char *addr)\r\n{\r\nreturn __dev_mc_add(dev, addr, true);\r\n}\r\nstatic int __dev_mc_del(struct net_device *dev, const unsigned char *addr,\r\nbool global)\r\n{\r\nint err;\r\nnetif_addr_lock_bh(dev);\r\nerr = __hw_addr_del_ex(&dev->mc, addr, dev->addr_len,\r\nNETDEV_HW_ADDR_T_MULTICAST, global, false);\r\nif (!err)\r\n__dev_set_rx_mode(dev);\r\nnetif_addr_unlock_bh(dev);\r\nreturn err;\r\n}\r\nint dev_mc_del(struct net_device *dev, const unsigned char *addr)\r\n{\r\nreturn __dev_mc_del(dev, addr, false);\r\n}\r\nint dev_mc_del_global(struct net_device *dev, const unsigned char *addr)\r\n{\r\nreturn __dev_mc_del(dev, addr, true);\r\n}\r\nint dev_mc_sync(struct net_device *to, struct net_device *from)\r\n{\r\nint err = 0;\r\nif (to->addr_len != from->addr_len)\r\nreturn -EINVAL;\r\nnetif_addr_lock_nested(to);\r\nerr = __hw_addr_sync(&to->mc, &from->mc, to->addr_len);\r\nif (!err)\r\n__dev_set_rx_mode(to);\r\nnetif_addr_unlock(to);\r\nreturn err;\r\n}\r\nint dev_mc_sync_multiple(struct net_device *to, struct net_device *from)\r\n{\r\nint err = 0;\r\nif (to->addr_len != from->addr_len)\r\nreturn -EINVAL;\r\nnetif_addr_lock_nested(to);\r\nerr = __hw_addr_sync_multiple(&to->mc, &from->mc, to->addr_len);\r\nif (!err)\r\n__dev_set_rx_mode(to);\r\nnetif_addr_unlock(to);\r\nreturn err;\r\n}\r\nvoid dev_mc_unsync(struct net_device *to, struct net_device *from)\r\n{\r\nif (to->addr_len != from->addr_len)\r\nreturn;\r\nnetif_addr_lock_bh(from);\r\nnetif_addr_lock_nested(to);\r\n__hw_addr_unsync(&to->mc, &from->mc, to->addr_len);\r\n__dev_set_rx_mode(to);\r\nnetif_addr_unlock(to);\r\nnetif_addr_unlock_bh(from);\r\n}\r\nvoid dev_mc_flush(struct net_device *dev)\r\n{\r\nnetif_addr_lock_bh(dev);\r\n__hw_addr_flush(&dev->mc);\r\nnetif_addr_unlock_bh(dev);\r\n}\r\nvoid dev_mc_init(struct net_device *dev)\r\n{\r\n__hw_addr_init(&dev->mc);\r\n}
