static int iforce_playback(struct input_dev *dev, int effect_id, int value)\r\n{\r\nstruct iforce *iforce = input_get_drvdata(dev);\r\nstruct iforce_core_effect *core_effect = &iforce->core_effects[effect_id];\r\nif (value > 0)\r\nset_bit(FF_CORE_SHOULD_PLAY, core_effect->flags);\r\nelse\r\nclear_bit(FF_CORE_SHOULD_PLAY, core_effect->flags);\r\niforce_control_playback(iforce, effect_id, value);\r\nreturn 0;\r\n}\r\nstatic void iforce_set_gain(struct input_dev *dev, u16 gain)\r\n{\r\nstruct iforce *iforce = input_get_drvdata(dev);\r\nunsigned char data[3];\r\ndata[0] = gain >> 9;\r\niforce_send_packet(iforce, FF_CMD_GAIN, data);\r\n}\r\nstatic void iforce_set_autocenter(struct input_dev *dev, u16 magnitude)\r\n{\r\nstruct iforce *iforce = input_get_drvdata(dev);\r\nunsigned char data[3];\r\ndata[0] = 0x03;\r\ndata[1] = magnitude >> 9;\r\niforce_send_packet(iforce, FF_CMD_AUTOCENTER, data);\r\ndata[0] = 0x04;\r\ndata[1] = 0x01;\r\niforce_send_packet(iforce, FF_CMD_AUTOCENTER, data);\r\n}\r\nstatic int iforce_upload_effect(struct input_dev *dev, struct ff_effect *effect, struct ff_effect *old)\r\n{\r\nstruct iforce *iforce = input_get_drvdata(dev);\r\nstruct iforce_core_effect *core_effect = &iforce->core_effects[effect->id];\r\nint ret;\r\nif (__test_and_set_bit(FF_CORE_IS_USED, core_effect->flags)) {\r\nif (test_bit(FF_CORE_UPDATE, core_effect->flags))\r\nreturn -EAGAIN;\r\n}\r\nswitch (effect->type) {\r\ncase FF_PERIODIC:\r\nret = iforce_upload_periodic(iforce, effect, old);\r\nbreak;\r\ncase FF_CONSTANT:\r\nret = iforce_upload_constant(iforce, effect, old);\r\nbreak;\r\ncase FF_SPRING:\r\ncase FF_DAMPER:\r\nret = iforce_upload_condition(iforce, effect, old);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (ret == 0) {\r\nset_bit(FF_CORE_UPDATE, core_effect->flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic int iforce_erase_effect(struct input_dev *dev, int effect_id)\r\n{\r\nstruct iforce *iforce = input_get_drvdata(dev);\r\nstruct iforce_core_effect *core_effect = &iforce->core_effects[effect_id];\r\nint err = 0;\r\nif (test_bit(FF_MOD1_IS_USED, core_effect->flags))\r\nerr = release_resource(&core_effect->mod1_chunk);\r\nif (!err && test_bit(FF_MOD2_IS_USED, core_effect->flags))\r\nerr = release_resource(&core_effect->mod2_chunk);\r\ncore_effect->flags[0] = 0;\r\nreturn err;\r\n}\r\nstatic int iforce_open(struct input_dev *dev)\r\n{\r\nstruct iforce *iforce = input_get_drvdata(dev);\r\nswitch (iforce->bus) {\r\n#ifdef CONFIG_JOYSTICK_IFORCE_USB\r\ncase IFORCE_USB:\r\niforce->irq->dev = iforce->usbdev;\r\nif (usb_submit_urb(iforce->irq, GFP_KERNEL))\r\nreturn -EIO;\r\nbreak;\r\n#endif\r\n}\r\nif (test_bit(EV_FF, dev->evbit)) {\r\niforce_send_packet(iforce, FF_CMD_ENABLE, "\004");\r\n}\r\nreturn 0;\r\n}\r\nstatic void iforce_close(struct input_dev *dev)\r\n{\r\nstruct iforce *iforce = input_get_drvdata(dev);\r\nint i;\r\nif (test_bit(EV_FF, dev->evbit)) {\r\nfor (i = 0; i < dev->ff->max_effects; i++) {\r\nif (test_bit(FF_CORE_IS_USED, iforce->core_effects[i].flags)) {\r\ndev_warn(&dev->dev,\r\n"%s: Device still owns effects\n",\r\n__func__);\r\nbreak;\r\n}\r\n}\r\niforce_send_packet(iforce, FF_CMD_ENABLE, "\001");\r\nwait_event_interruptible(iforce->wait,\r\n!test_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags));\r\n}\r\nswitch (iforce->bus) {\r\n#ifdef CONFIG_JOYSTICK_IFORCE_USB\r\ncase IFORCE_USB:\r\nusb_kill_urb(iforce->irq);\r\nusb_kill_urb(iforce->out);\r\nusb_kill_urb(iforce->ctrl);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_JOYSTICK_IFORCE_232\r\ncase IFORCE_232:\r\nbreak;\r\n#endif\r\n}\r\n}\r\nint iforce_init_device(struct iforce *iforce)\r\n{\r\nstruct input_dev *input_dev;\r\nstruct ff_device *ff;\r\nunsigned char c[] = "CEOV";\r\nint i, error;\r\nint ff_effects = 0;\r\ninput_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\ninit_waitqueue_head(&iforce->wait);\r\nspin_lock_init(&iforce->xmit_lock);\r\nmutex_init(&iforce->mem_mutex);\r\niforce->xmit.buf = iforce->xmit_data;\r\niforce->dev = input_dev;\r\nswitch (iforce->bus) {\r\n#ifdef CONFIG_JOYSTICK_IFORCE_USB\r\ncase IFORCE_USB:\r\ninput_dev->id.bustype = BUS_USB;\r\ninput_dev->dev.parent = &iforce->usbdev->dev;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_JOYSTICK_IFORCE_232\r\ncase IFORCE_232:\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->dev.parent = &iforce->serio->dev;\r\nbreak;\r\n#endif\r\n}\r\ninput_set_drvdata(input_dev, iforce);\r\ninput_dev->name = "Unknown I-Force device";\r\ninput_dev->open = iforce_open;\r\ninput_dev->close = iforce_close;\r\niforce->device_memory.name = "I-Force device effect memory";\r\niforce->device_memory.start = 0;\r\niforce->device_memory.end = 200;\r\niforce->device_memory.flags = IORESOURCE_MEM;\r\niforce->device_memory.parent = NULL;\r\niforce->device_memory.child = NULL;\r\niforce->device_memory.sibling = NULL;\r\nfor (i = 0; i < 20; i++)\r\nif (!iforce_get_id_packet(iforce, "O"))\r\nbreak;\r\nif (i == 20) {\r\ndev_err(&input_dev->dev,\r\n"Timeout waiting for response from device.\n");\r\nerror = -ENODEV;\r\ngoto fail;\r\n}\r\nif (!iforce_get_id_packet(iforce, "M"))\r\ninput_dev->id.vendor = (iforce->edata[2] << 8) | iforce->edata[1];\r\nelse\r\ndev_warn(&iforce->dev->dev, "Device does not respond to id packet M\n");\r\nif (!iforce_get_id_packet(iforce, "P"))\r\ninput_dev->id.product = (iforce->edata[2] << 8) | iforce->edata[1];\r\nelse\r\ndev_warn(&iforce->dev->dev, "Device does not respond to id packet P\n");\r\nif (!iforce_get_id_packet(iforce, "B"))\r\niforce->device_memory.end = (iforce->edata[2] << 8) | iforce->edata[1];\r\nelse\r\ndev_warn(&iforce->dev->dev, "Device does not respond to id packet B\n");\r\nif (!iforce_get_id_packet(iforce, "N"))\r\nff_effects = iforce->edata[1];\r\nelse\r\ndev_warn(&iforce->dev->dev, "Device does not respond to id packet N\n");\r\nif (ff_effects > IFORCE_EFFECTS_MAX) {\r\ndev_warn(&iforce->dev->dev, "Limiting number of effects to %d (device reports %d)\n",\r\nIFORCE_EFFECTS_MAX, ff_effects);\r\nff_effects = IFORCE_EFFECTS_MAX;\r\n}\r\nfor (i = 0; c[i]; i++)\r\nif (!iforce_get_id_packet(iforce, c + i))\r\niforce_dump_packet("info", iforce->ecmd, iforce->edata);\r\niforce_set_autocenter(input_dev, 0);\r\nfor (i = 0; iforce_device[i].idvendor; i++)\r\nif (iforce_device[i].idvendor == input_dev->id.vendor &&\r\niforce_device[i].idproduct == input_dev->id.product)\r\nbreak;\r\niforce->type = iforce_device + i;\r\ninput_dev->name = iforce->type->name;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) |\r\nBIT_MASK(EV_FF_STATUS);\r\nfor (i = 0; iforce->type->btn[i] >= 0; i++)\r\nset_bit(iforce->type->btn[i], input_dev->keybit);\r\nset_bit(BTN_DEAD, input_dev->keybit);\r\nfor (i = 0; iforce->type->abs[i] >= 0; i++) {\r\nsigned short t = iforce->type->abs[i];\r\nswitch (t) {\r\ncase ABS_X:\r\ncase ABS_Y:\r\ncase ABS_WHEEL:\r\ninput_set_abs_params(input_dev, t, -1920, 1920, 16, 128);\r\nset_bit(t, input_dev->ffbit);\r\nbreak;\r\ncase ABS_THROTTLE:\r\ncase ABS_GAS:\r\ncase ABS_BRAKE:\r\ninput_set_abs_params(input_dev, t, 0, 255, 0, 0);\r\nbreak;\r\ncase ABS_RUDDER:\r\ninput_set_abs_params(input_dev, t, -128, 127, 0, 0);\r\nbreak;\r\ncase ABS_HAT0X:\r\ncase ABS_HAT0Y:\r\ncase ABS_HAT1X:\r\ncase ABS_HAT1Y:\r\ninput_set_abs_params(input_dev, t, -1, 1, 0, 0);\r\nbreak;\r\n}\r\n}\r\nif (ff_effects) {\r\nfor (i = 0; iforce->type->ff[i] >= 0; i++)\r\nset_bit(iforce->type->ff[i], input_dev->ffbit);\r\nerror = input_ff_create(input_dev, ff_effects);\r\nif (error)\r\ngoto fail;\r\nff = input_dev->ff;\r\nff->upload = iforce_upload_effect;\r\nff->erase = iforce_erase_effect;\r\nff->set_gain = iforce_set_gain;\r\nff->set_autocenter = iforce_set_autocenter;\r\nff->playback = iforce_playback;\r\n}\r\nerror = input_register_device(iforce->dev);\r\nif (error)\r\ngoto fail;\r\nreturn 0;\r\nfail: input_free_device(input_dev);\r\nreturn error;\r\n}\r\nstatic int __init iforce_init(void)\r\n{\r\nint err = 0;\r\n#ifdef CONFIG_JOYSTICK_IFORCE_USB\r\nerr = usb_register(&iforce_usb_driver);\r\nif (err)\r\nreturn err;\r\n#endif\r\n#ifdef CONFIG_JOYSTICK_IFORCE_232\r\nerr = serio_register_driver(&iforce_serio_drv);\r\n#ifdef CONFIG_JOYSTICK_IFORCE_USB\r\nif (err)\r\nusb_deregister(&iforce_usb_driver);\r\n#endif\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit iforce_exit(void)\r\n{\r\n#ifdef CONFIG_JOYSTICK_IFORCE_USB\r\nusb_deregister(&iforce_usb_driver);\r\n#endif\r\n#ifdef CONFIG_JOYSTICK_IFORCE_232\r\nserio_unregister_driver(&iforce_serio_drv);\r\n#endif\r\n}
