void rose_start_ftimer(struct rose_neigh *neigh)\r\n{\r\ndel_timer(&neigh->ftimer);\r\nneigh->ftimer.data = (unsigned long)neigh;\r\nneigh->ftimer.function = &rose_ftimer_expiry;\r\nneigh->ftimer.expires =\r\njiffies + msecs_to_jiffies(sysctl_rose_link_fail_timeout);\r\nadd_timer(&neigh->ftimer);\r\n}\r\nstatic void rose_start_t0timer(struct rose_neigh *neigh)\r\n{\r\ndel_timer(&neigh->t0timer);\r\nneigh->t0timer.data = (unsigned long)neigh;\r\nneigh->t0timer.function = &rose_t0timer_expiry;\r\nneigh->t0timer.expires =\r\njiffies + msecs_to_jiffies(sysctl_rose_restart_request_timeout);\r\nadd_timer(&neigh->t0timer);\r\n}\r\nvoid rose_stop_ftimer(struct rose_neigh *neigh)\r\n{\r\ndel_timer(&neigh->ftimer);\r\n}\r\nvoid rose_stop_t0timer(struct rose_neigh *neigh)\r\n{\r\ndel_timer(&neigh->t0timer);\r\n}\r\nint rose_ftimer_running(struct rose_neigh *neigh)\r\n{\r\nreturn timer_pending(&neigh->ftimer);\r\n}\r\nstatic int rose_t0timer_running(struct rose_neigh *neigh)\r\n{\r\nreturn timer_pending(&neigh->t0timer);\r\n}\r\nstatic void rose_ftimer_expiry(unsigned long param)\r\n{\r\n}\r\nstatic void rose_t0timer_expiry(unsigned long param)\r\n{\r\nstruct rose_neigh *neigh = (struct rose_neigh *)param;\r\nrose_transmit_restart_request(neigh);\r\nneigh->dce_mode = 0;\r\nrose_start_t0timer(neigh);\r\n}\r\nstatic int rose_send_frame(struct sk_buff *skb, struct rose_neigh *neigh)\r\n{\r\nax25_address *rose_call;\r\nax25_cb *ax25s;\r\nif (ax25cmp(&rose_callsign, &null_ax25_address) == 0)\r\nrose_call = (ax25_address *)neigh->dev->dev_addr;\r\nelse\r\nrose_call = &rose_callsign;\r\nax25s = neigh->ax25;\r\nneigh->ax25 = ax25_send_frame(skb, 260, rose_call, &neigh->callsign, neigh->digipeat, neigh->dev);\r\nif (ax25s)\r\nax25_cb_put(ax25s);\r\nreturn neigh->ax25 != NULL;\r\n}\r\nstatic int rose_link_up(struct rose_neigh *neigh)\r\n{\r\nax25_address *rose_call;\r\nax25_cb *ax25s;\r\nif (ax25cmp(&rose_callsign, &null_ax25_address) == 0)\r\nrose_call = (ax25_address *)neigh->dev->dev_addr;\r\nelse\r\nrose_call = &rose_callsign;\r\nax25s = neigh->ax25;\r\nneigh->ax25 = ax25_find_cb(rose_call, &neigh->callsign, neigh->digipeat, neigh->dev);\r\nif (ax25s)\r\nax25_cb_put(ax25s);\r\nreturn neigh->ax25 != NULL;\r\n}\r\nvoid rose_link_rx_restart(struct sk_buff *skb, struct rose_neigh *neigh, unsigned short frametype)\r\n{\r\nstruct sk_buff *skbn;\r\nswitch (frametype) {\r\ncase ROSE_RESTART_REQUEST:\r\nrose_stop_t0timer(neigh);\r\nneigh->restarted = 1;\r\nneigh->dce_mode = (skb->data[3] == ROSE_DTE_ORIGINATED);\r\nrose_transmit_restart_confirmation(neigh);\r\nbreak;\r\ncase ROSE_RESTART_CONFIRMATION:\r\nrose_stop_t0timer(neigh);\r\nneigh->restarted = 1;\r\nbreak;\r\ncase ROSE_DIAGNOSTIC:\r\nprintk(KERN_WARNING "ROSE: received diagnostic #%d - %02X %02X %02X\n", skb->data[3], skb->data[4], skb->data[5], skb->data[6]);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "ROSE: received unknown %02X with LCI 000\n", frametype);\r\nbreak;\r\n}\r\nif (neigh->restarted) {\r\nwhile ((skbn = skb_dequeue(&neigh->queue)) != NULL)\r\nif (!rose_send_frame(skbn, neigh))\r\nkfree_skb(skbn);\r\n}\r\n}\r\nstatic void rose_transmit_restart_request(struct rose_neigh *neigh)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *dptr;\r\nint len;\r\nlen = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 3;\r\nif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN);\r\ndptr = skb_put(skb, ROSE_MIN_LEN + 3);\r\n*dptr++ = AX25_P_ROSE;\r\n*dptr++ = ROSE_GFI;\r\n*dptr++ = 0x00;\r\n*dptr++ = ROSE_RESTART_REQUEST;\r\n*dptr++ = ROSE_DTE_ORIGINATED;\r\n*dptr++ = 0;\r\nif (!rose_send_frame(skb, neigh))\r\nkfree_skb(skb);\r\n}\r\nstatic void rose_transmit_restart_confirmation(struct rose_neigh *neigh)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *dptr;\r\nint len;\r\nlen = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1;\r\nif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN);\r\ndptr = skb_put(skb, ROSE_MIN_LEN + 1);\r\n*dptr++ = AX25_P_ROSE;\r\n*dptr++ = ROSE_GFI;\r\n*dptr++ = 0x00;\r\n*dptr++ = ROSE_RESTART_CONFIRMATION;\r\nif (!rose_send_frame(skb, neigh))\r\nkfree_skb(skb);\r\n}\r\nvoid rose_transmit_clear_request(struct rose_neigh *neigh, unsigned int lci, unsigned char cause, unsigned char diagnostic)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *dptr;\r\nint len;\r\nlen = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 3;\r\nif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN);\r\ndptr = skb_put(skb, ROSE_MIN_LEN + 3);\r\n*dptr++ = AX25_P_ROSE;\r\n*dptr++ = ((lci >> 8) & 0x0F) | ROSE_GFI;\r\n*dptr++ = ((lci >> 0) & 0xFF);\r\n*dptr++ = ROSE_CLEAR_REQUEST;\r\n*dptr++ = cause;\r\n*dptr++ = diagnostic;\r\nif (!rose_send_frame(skb, neigh))\r\nkfree_skb(skb);\r\n}\r\nvoid rose_transmit_link(struct sk_buff *skb, struct rose_neigh *neigh)\r\n{\r\nunsigned char *dptr;\r\nif (neigh->loopback) {\r\nrose_loopback_queue(skb, neigh);\r\nreturn;\r\n}\r\nif (!rose_link_up(neigh))\r\nneigh->restarted = 0;\r\ndptr = skb_push(skb, 1);\r\n*dptr++ = AX25_P_ROSE;\r\nif (neigh->restarted) {\r\nif (!rose_send_frame(skb, neigh))\r\nkfree_skb(skb);\r\n} else {\r\nskb_queue_tail(&neigh->queue, skb);\r\nif (!rose_t0timer_running(neigh)) {\r\nrose_transmit_restart_request(neigh);\r\nneigh->dce_mode = 0;\r\nrose_start_t0timer(neigh);\r\n}\r\n}\r\n}
