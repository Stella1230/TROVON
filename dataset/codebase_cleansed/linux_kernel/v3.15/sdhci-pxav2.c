static void pxav2_set_private_registers(struct sdhci_host *host, u8 mask)\r\n{\r\nstruct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));\r\nstruct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;\r\nif (mask == SDHCI_RESET_ALL) {\r\nu16 tmp = 0;\r\nif (pdata && pdata->clk_delay_sel == 1) {\r\ntmp = readw(host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);\r\ntmp &= ~(SDCLK_DELAY_MASK << SDCLK_DELAY_SHIFT);\r\ntmp |= (pdata->clk_delay_cycles & SDCLK_DELAY_MASK)\r\n<< SDCLK_DELAY_SHIFT;\r\ntmp &= ~(SDCLK_SEL_MASK << SDCLK_SEL_SHIFT);\r\ntmp |= (1 & SDCLK_SEL_MASK) << SDCLK_SEL_SHIFT;\r\nwritew(tmp, host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);\r\n}\r\nif (pdata && (pdata->flags & PXA_FLAG_ENABLE_CLOCK_GATING)) {\r\ntmp = readw(host->ioaddr + SD_FIFO_PARAM);\r\ntmp &= ~CLK_GATE_SETTING_BITS;\r\nwritew(tmp, host->ioaddr + SD_FIFO_PARAM);\r\n} else {\r\ntmp = readw(host->ioaddr + SD_FIFO_PARAM);\r\ntmp &= ~CLK_GATE_SETTING_BITS;\r\ntmp |= CLK_GATE_SETTING_BITS;\r\nwritew(tmp, host->ioaddr + SD_FIFO_PARAM);\r\n}\r\n}\r\n}\r\nstatic int pxav2_mmc_set_width(struct sdhci_host *host, int width)\r\n{\r\nu8 ctrl;\r\nu16 tmp;\r\nctrl = readb(host->ioaddr + SDHCI_HOST_CONTROL);\r\ntmp = readw(host->ioaddr + SD_CE_ATA_2);\r\nif (width == MMC_BUS_WIDTH_8) {\r\nctrl &= ~SDHCI_CTRL_4BITBUS;\r\ntmp |= MMC_CARD | MMC_WIDTH;\r\n} else {\r\ntmp &= ~(MMC_CARD | MMC_WIDTH);\r\nif (width == MMC_BUS_WIDTH_4)\r\nctrl |= SDHCI_CTRL_4BITBUS;\r\nelse\r\nctrl &= ~SDHCI_CTRL_4BITBUS;\r\n}\r\nwritew(tmp, host->ioaddr + SD_CE_ATA_2);\r\nwriteb(ctrl, host->ioaddr + SDHCI_HOST_CONTROL);\r\nreturn 0;\r\n}\r\nstatic struct sdhci_pxa_platdata *pxav2_get_mmc_pdata(struct device *dev)\r\n{\r\nstruct sdhci_pxa_platdata *pdata;\r\nstruct device_node *np = dev->of_node;\r\nu32 bus_width;\r\nu32 clk_delay_cycles;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nif (of_find_property(np, "non-removable", NULL))\r\npdata->flags |= PXA_FLAG_CARD_PERMANENT;\r\nof_property_read_u32(np, "bus-width", &bus_width);\r\nif (bus_width == 8)\r\npdata->flags |= PXA_FLAG_SD_8_BIT_CAPABLE_SLOT;\r\nof_property_read_u32(np, "mrvl,clk-delay-cycles", &clk_delay_cycles);\r\nif (clk_delay_cycles > 0) {\r\npdata->clk_delay_sel = 1;\r\npdata->clk_delay_cycles = clk_delay_cycles;\r\n}\r\nreturn pdata;\r\n}\r\nstatic inline struct sdhci_pxa_platdata *pxav2_get_mmc_pdata(struct device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int sdhci_pxav2_probe(struct platform_device *pdev)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host;\r\nstruct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct sdhci_host *host = NULL;\r\nstruct sdhci_pxa *pxa = NULL;\r\nconst struct of_device_id *match;\r\nint ret;\r\nstruct clk *clk;\r\npxa = kzalloc(sizeof(struct sdhci_pxa), GFP_KERNEL);\r\nif (!pxa)\r\nreturn -ENOMEM;\r\nhost = sdhci_pltfm_init(pdev, NULL, 0);\r\nif (IS_ERR(host)) {\r\nkfree(pxa);\r\nreturn PTR_ERR(host);\r\n}\r\npltfm_host = sdhci_priv(host);\r\npltfm_host->priv = pxa;\r\nclk = clk_get(dev, "PXA-SDHCLK");\r\nif (IS_ERR(clk)) {\r\ndev_err(dev, "failed to get io clock\n");\r\nret = PTR_ERR(clk);\r\ngoto err_clk_get;\r\n}\r\npltfm_host->clk = clk;\r\nclk_prepare_enable(clk);\r\nhost->quirks = SDHCI_QUIRK_BROKEN_ADMA\r\n| SDHCI_QUIRK_BROKEN_TIMEOUT_VAL\r\n| SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN;\r\nmatch = of_match_device(of_match_ptr(sdhci_pxav2_of_match), &pdev->dev);\r\nif (match) {\r\npdata = pxav2_get_mmc_pdata(dev);\r\n}\r\nif (pdata) {\r\nif (pdata->flags & PXA_FLAG_CARD_PERMANENT) {\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;\r\nhost->mmc->caps |= MMC_CAP_NONREMOVABLE;\r\n}\r\nif (pdata->flags & PXA_FLAG_SD_8_BIT_CAPABLE_SLOT)\r\nhost->mmc->caps |= MMC_CAP_8_BIT_DATA;\r\nif (pdata->quirks)\r\nhost->quirks |= pdata->quirks;\r\nif (pdata->host_caps)\r\nhost->mmc->caps |= pdata->host_caps;\r\nif (pdata->pm_caps)\r\nhost->mmc->pm_caps |= pdata->pm_caps;\r\n}\r\nhost->ops = &pxav2_sdhci_ops;\r\nret = sdhci_add_host(host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add host\n");\r\ngoto err_add_host;\r\n}\r\nplatform_set_drvdata(pdev, host);\r\nreturn 0;\r\nerr_add_host:\r\nclk_disable_unprepare(clk);\r\nclk_put(clk);\r\nerr_clk_get:\r\nsdhci_pltfm_free(pdev);\r\nkfree(pxa);\r\nreturn ret;\r\n}\r\nstatic int sdhci_pxav2_remove(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host = platform_get_drvdata(pdev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_pxa *pxa = pltfm_host->priv;\r\nsdhci_remove_host(host, 1);\r\nclk_disable_unprepare(pltfm_host->clk);\r\nclk_put(pltfm_host->clk);\r\nsdhci_pltfm_free(pdev);\r\nkfree(pxa);\r\nreturn 0;\r\n}
