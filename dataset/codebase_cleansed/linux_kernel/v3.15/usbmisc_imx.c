static int usbmisc_imx25_post(struct imx_usbmisc_data *data)\r\n{\r\nvoid __iomem *reg;\r\nunsigned long flags;\r\nu32 val;\r\nif (data->index > 2)\r\nreturn -EINVAL;\r\nreg = usbmisc->base + MX25_USB_PHY_CTRL_OFFSET;\r\nif (data->evdo) {\r\nspin_lock_irqsave(&usbmisc->lock, flags);\r\nval = readl(reg);\r\nwritel(val | MX25_BM_EXTERNAL_VBUS_DIVIDER, reg);\r\nspin_unlock_irqrestore(&usbmisc->lock, flags);\r\nusleep_range(5000, 10000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbmisc_imx27_init(struct imx_usbmisc_data *data)\r\n{\r\nunsigned long flags;\r\nu32 val;\r\nswitch (data->index) {\r\ncase 0:\r\nval = MX27_OTG_PM_BIT;\r\nbreak;\r\ncase 1:\r\nval = MX27_H1_PM_BIT;\r\nbreak;\r\ncase 2:\r\nval = MX27_H2_PM_BIT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\nspin_lock_irqsave(&usbmisc->lock, flags);\r\nif (data->disable_oc)\r\nval = readl(usbmisc->base) | val;\r\nelse\r\nval = readl(usbmisc->base) & ~val;\r\nwritel(val, usbmisc->base);\r\nspin_unlock_irqrestore(&usbmisc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int usbmisc_imx53_init(struct imx_usbmisc_data *data)\r\n{\r\nvoid __iomem *reg = NULL;\r\nunsigned long flags;\r\nu32 val = 0;\r\nif (data->index > 3)\r\nreturn -EINVAL;\r\nif (data->disable_oc) {\r\nspin_lock_irqsave(&usbmisc->lock, flags);\r\nswitch (data->index) {\r\ncase 0:\r\nreg = usbmisc->base + MX53_USB_OTG_PHY_CTRL_0_OFFSET;\r\nval = readl(reg) | MX53_BM_OVER_CUR_DIS_OTG;\r\nbreak;\r\ncase 1:\r\nreg = usbmisc->base + MX53_USB_OTG_PHY_CTRL_0_OFFSET;\r\nval = readl(reg) | MX53_BM_OVER_CUR_DIS_H1;\r\nbreak;\r\ncase 2:\r\nreg = usbmisc->base + MX53_USB_UH2_CTRL_OFFSET;\r\nval = readl(reg) | MX53_BM_OVER_CUR_DIS_UHx;\r\nbreak;\r\ncase 3:\r\nreg = usbmisc->base + MX53_USB_UH3_CTRL_OFFSET;\r\nval = readl(reg) | MX53_BM_OVER_CUR_DIS_UHx;\r\nbreak;\r\n}\r\nif (reg && val)\r\nwritel(val, reg);\r\nspin_unlock_irqrestore(&usbmisc->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbmisc_imx6q_init(struct imx_usbmisc_data *data)\r\n{\r\nunsigned long flags;\r\nu32 reg;\r\nif (data->index > 3)\r\nreturn -EINVAL;\r\nif (data->disable_oc) {\r\nspin_lock_irqsave(&usbmisc->lock, flags);\r\nreg = readl(usbmisc->base + data->index * 4);\r\nwritel(reg | MX6_BM_OVER_CUR_DIS,\r\nusbmisc->base + data->index * 4);\r\nspin_unlock_irqrestore(&usbmisc->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nint imx_usbmisc_init(struct imx_usbmisc_data *data)\r\n{\r\nif (!usbmisc)\r\nreturn -EPROBE_DEFER;\r\nif (!usbmisc->ops->init)\r\nreturn 0;\r\nreturn usbmisc->ops->init(data);\r\n}\r\nint imx_usbmisc_init_post(struct imx_usbmisc_data *data)\r\n{\r\nif (!usbmisc)\r\nreturn -EPROBE_DEFER;\r\nif (!usbmisc->ops->post)\r\nreturn 0;\r\nreturn usbmisc->ops->post(data);\r\n}\r\nstatic int usbmisc_imx_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct imx_usbmisc *data;\r\nint ret;\r\nstruct of_device_id *tmp_dev;\r\nif (usbmisc)\r\nreturn -EBUSY;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nspin_lock_init(&data->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(data->base))\r\nreturn PTR_ERR(data->base);\r\ndata->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(data->clk)) {\r\ndev_err(&pdev->dev,\r\n"failed to get clock, err=%ld\n", PTR_ERR(data->clk));\r\nreturn PTR_ERR(data->clk);\r\n}\r\nret = clk_prepare_enable(data->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"clk_prepare_enable failed, err=%d\n", ret);\r\nreturn ret;\r\n}\r\ntmp_dev = (struct of_device_id *)\r\nof_match_device(usbmisc_imx_dt_ids, &pdev->dev);\r\ndata->ops = (const struct usbmisc_ops *)tmp_dev->data;\r\nusbmisc = data;\r\nreturn 0;\r\n}\r\nstatic int usbmisc_imx_remove(struct platform_device *pdev)\r\n{\r\nclk_disable_unprepare(usbmisc->clk);\r\nusbmisc = NULL;\r\nreturn 0;\r\n}
