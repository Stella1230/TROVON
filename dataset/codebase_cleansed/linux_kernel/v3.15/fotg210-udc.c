static void fotg210_disable_fifo_int(struct fotg210_ep *ep)\r\n{\r\nu32 value = ioread32(ep->fotg210->reg + FOTG210_DMISGR1);\r\nif (ep->dir_in)\r\nvalue |= DMISGR1_MF_IN_INT(ep->epnum - 1);\r\nelse\r\nvalue |= DMISGR1_MF_OUTSPK_INT(ep->epnum - 1);\r\niowrite32(value, ep->fotg210->reg + FOTG210_DMISGR1);\r\n}\r\nstatic void fotg210_enable_fifo_int(struct fotg210_ep *ep)\r\n{\r\nu32 value = ioread32(ep->fotg210->reg + FOTG210_DMISGR1);\r\nif (ep->dir_in)\r\nvalue &= ~DMISGR1_MF_IN_INT(ep->epnum - 1);\r\nelse\r\nvalue &= ~DMISGR1_MF_OUTSPK_INT(ep->epnum - 1);\r\niowrite32(value, ep->fotg210->reg + FOTG210_DMISGR1);\r\n}\r\nstatic void fotg210_set_cxdone(struct fotg210_udc *fotg210)\r\n{\r\nu32 value = ioread32(fotg210->reg + FOTG210_DCFESR);\r\nvalue |= DCFESR_CX_DONE;\r\niowrite32(value, fotg210->reg + FOTG210_DCFESR);\r\n}\r\nstatic void fotg210_done(struct fotg210_ep *ep, struct fotg210_request *req,\r\nint status)\r\n{\r\nlist_del_init(&req->queue);\r\nif (ep->fotg210->gadget.speed == USB_SPEED_UNKNOWN)\r\nreq->req.status = -ESHUTDOWN;\r\nelse\r\nreq->req.status = status;\r\nspin_unlock(&ep->fotg210->lock);\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&ep->fotg210->lock);\r\nif (ep->epnum) {\r\nif (list_empty(&ep->queue))\r\nfotg210_disable_fifo_int(ep);\r\n} else {\r\nfotg210_set_cxdone(ep->fotg210);\r\n}\r\n}\r\nstatic void fotg210_fifo_ep_mapping(struct fotg210_ep *ep, u32 epnum,\r\nu32 dir_in)\r\n{\r\nstruct fotg210_udc *fotg210 = ep->fotg210;\r\nu32 val;\r\nval = ioread32(fotg210->reg + FOTG210_EPMAP);\r\nval &= ~EPMAP_FIFONOMSK(epnum, dir_in);\r\nval |= EPMAP_FIFONO(epnum, dir_in);\r\niowrite32(val, fotg210->reg + FOTG210_EPMAP);\r\nval = ioread32(fotg210->reg + FOTG210_FIFOMAP);\r\nval &= ~FIFOMAP_EPNOMSK(epnum);\r\nval |= FIFOMAP_EPNO(epnum);\r\niowrite32(val, fotg210->reg + FOTG210_FIFOMAP);\r\nval = ioread32(fotg210->reg + FOTG210_FIFOCF);\r\nval |= FIFOCF_FIFO_EN(epnum - 1);\r\niowrite32(val, fotg210->reg + FOTG210_FIFOCF);\r\n}\r\nstatic void fotg210_set_fifo_dir(struct fotg210_ep *ep, u32 epnum, u32 dir_in)\r\n{\r\nstruct fotg210_udc *fotg210 = ep->fotg210;\r\nu32 val;\r\nval = ioread32(fotg210->reg + FOTG210_FIFOMAP);\r\nval |= (dir_in ? FIFOMAP_DIRIN(epnum - 1) : FIFOMAP_DIROUT(epnum - 1));\r\niowrite32(val, fotg210->reg + FOTG210_FIFOMAP);\r\n}\r\nstatic void fotg210_set_tfrtype(struct fotg210_ep *ep, u32 epnum, u32 type)\r\n{\r\nstruct fotg210_udc *fotg210 = ep->fotg210;\r\nu32 val;\r\nval = ioread32(fotg210->reg + FOTG210_FIFOCF);\r\nval |= FIFOCF_TYPE(type, epnum - 1);\r\niowrite32(val, fotg210->reg + FOTG210_FIFOCF);\r\n}\r\nstatic void fotg210_set_mps(struct fotg210_ep *ep, u32 epnum, u32 mps,\r\nu32 dir_in)\r\n{\r\nstruct fotg210_udc *fotg210 = ep->fotg210;\r\nu32 val;\r\nu32 offset = dir_in ? FOTG210_INEPMPSR(epnum) :\r\nFOTG210_OUTEPMPSR(epnum);\r\nval = ioread32(fotg210->reg + offset);\r\nval |= INOUTEPMPSR_MPS(mps);\r\niowrite32(val, fotg210->reg + offset);\r\n}\r\nstatic int fotg210_config_ep(struct fotg210_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct fotg210_udc *fotg210 = ep->fotg210;\r\nfotg210_set_fifo_dir(ep, ep->epnum, ep->dir_in);\r\nfotg210_set_tfrtype(ep, ep->epnum, ep->type);\r\nfotg210_set_mps(ep, ep->epnum, ep->ep.maxpacket, ep->dir_in);\r\nfotg210_fifo_ep_mapping(ep, ep->epnum, ep->dir_in);\r\nfotg210->ep[ep->epnum] = ep;\r\nreturn 0;\r\n}\r\nstatic int fotg210_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct fotg210_ep *ep;\r\nep = container_of(_ep, struct fotg210_ep, ep);\r\nep->desc = desc;\r\nep->epnum = usb_endpoint_num(desc);\r\nep->type = usb_endpoint_type(desc);\r\nep->dir_in = usb_endpoint_dir_in(desc);\r\nep->ep.maxpacket = usb_endpoint_maxp(desc);\r\nreturn fotg210_config_ep(ep, desc);\r\n}\r\nstatic void fotg210_reset_tseq(struct fotg210_udc *fotg210, u8 epnum)\r\n{\r\nstruct fotg210_ep *ep = fotg210->ep[epnum];\r\nu32 value;\r\nvoid __iomem *reg;\r\nreg = (ep->dir_in) ?\r\nfotg210->reg + FOTG210_INEPMPSR(epnum) :\r\nfotg210->reg + FOTG210_OUTEPMPSR(epnum);\r\nvalue = ioread32(reg);\r\nvalue |= INOUTEPMPSR_RESET_TSEQ;\r\niowrite32(value, reg);\r\nvalue = ioread32(reg);\r\nvalue &= ~INOUTEPMPSR_RESET_TSEQ;\r\niowrite32(value, reg);\r\n}\r\nstatic int fotg210_ep_release(struct fotg210_ep *ep)\r\n{\r\nif (!ep->epnum)\r\nreturn 0;\r\nep->epnum = 0;\r\nep->stall = 0;\r\nep->wedged = 0;\r\nfotg210_reset_tseq(ep->fotg210, ep->epnum);\r\nreturn 0;\r\n}\r\nstatic int fotg210_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct fotg210_ep *ep;\r\nstruct fotg210_request *req;\r\nunsigned long flags;\r\nBUG_ON(!_ep);\r\nep = container_of(_ep, struct fotg210_ep, ep);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next,\r\nstruct fotg210_request, queue);\r\nspin_lock_irqsave(&ep->fotg210->lock, flags);\r\nfotg210_done(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&ep->fotg210->lock, flags);\r\n}\r\nreturn fotg210_ep_release(ep);\r\n}\r\nstatic struct usb_request *fotg210_ep_alloc_request(struct usb_ep *_ep,\r\ngfp_t gfp_flags)\r\n{\r\nstruct fotg210_request *req;\r\nreq = kzalloc(sizeof(struct fotg210_request), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void fotg210_ep_free_request(struct usb_ep *_ep,\r\nstruct usb_request *_req)\r\n{\r\nstruct fotg210_request *req;\r\nreq = container_of(_req, struct fotg210_request, req);\r\nkfree(req);\r\n}\r\nstatic void fotg210_enable_dma(struct fotg210_ep *ep,\r\ndma_addr_t d, u32 len)\r\n{\r\nu32 value;\r\nstruct fotg210_udc *fotg210 = ep->fotg210;\r\nvalue = ioread32(fotg210->reg + FOTG210_DMACPSR1);\r\nvalue &= ~(DMACPSR1_DMA_LEN(0xFFFF) | DMACPSR1_DMA_TYPE(1));\r\nvalue |= DMACPSR1_DMA_LEN(len) | DMACPSR1_DMA_TYPE(ep->dir_in);\r\niowrite32(value, fotg210->reg + FOTG210_DMACPSR1);\r\nvalue = ioread32(fotg210->reg + FOTG210_DMATFNR);\r\nif (ep->epnum)\r\nvalue |= DMATFNR_ACC_FN(ep->epnum - 1);\r\nelse\r\nvalue |= DMATFNR_ACC_CXF;\r\niowrite32(value, fotg210->reg + FOTG210_DMATFNR);\r\niowrite32(d, fotg210->reg + FOTG210_DMACPSR2);\r\nvalue = ioread32(fotg210->reg + FOTG210_DMISGR2);\r\nvalue &= ~(DMISGR2_MDMA_CMPLT | DMISGR2_MDMA_ERROR);\r\niowrite32(value, fotg210->reg + FOTG210_DMISGR2);\r\nvalue = ioread32(fotg210->reg + FOTG210_DMACPSR1);\r\nvalue |= DMACPSR1_DMA_START;\r\niowrite32(value, fotg210->reg + FOTG210_DMACPSR1);\r\n}\r\nstatic void fotg210_disable_dma(struct fotg210_ep *ep)\r\n{\r\niowrite32(DMATFNR_DISDMA, ep->fotg210->reg + FOTG210_DMATFNR);\r\n}\r\nstatic void fotg210_wait_dma_done(struct fotg210_ep *ep)\r\n{\r\nu32 value;\r\ndo {\r\nvalue = ioread32(ep->fotg210->reg + FOTG210_DISGR2);\r\nif ((value & DISGR2_USBRST_INT) ||\r\n(value & DISGR2_DMA_ERROR))\r\ngoto dma_reset;\r\n} while (!(value & DISGR2_DMA_CMPLT));\r\nvalue &= ~DISGR2_DMA_CMPLT;\r\niowrite32(value, ep->fotg210->reg + FOTG210_DISGR2);\r\nreturn;\r\ndma_reset:\r\nvalue = ioread32(ep->fotg210->reg + FOTG210_DMACPSR1);\r\nvalue |= DMACPSR1_DMA_ABORT;\r\niowrite32(value, ep->fotg210->reg + FOTG210_DMACPSR1);\r\nif (ep->epnum) {\r\nvalue = ioread32(ep->fotg210->reg +\r\nFOTG210_FIBCR(ep->epnum - 1));\r\nvalue |= FIBCR_FFRST;\r\niowrite32(value, ep->fotg210->reg +\r\nFOTG210_FIBCR(ep->epnum - 1));\r\n} else {\r\nvalue = ioread32(ep->fotg210->reg + FOTG210_DCFESR);\r\nvalue |= DCFESR_CX_CLR;\r\niowrite32(value, ep->fotg210->reg + FOTG210_DCFESR);\r\n}\r\n}\r\nstatic void fotg210_start_dma(struct fotg210_ep *ep,\r\nstruct fotg210_request *req)\r\n{\r\ndma_addr_t d;\r\nu8 *buffer;\r\nu32 length;\r\nif (ep->epnum) {\r\nif (ep->dir_in) {\r\nbuffer = req->req.buf;\r\nlength = req->req.length;\r\n} else {\r\nbuffer = req->req.buf + req->req.actual;\r\nlength = ioread32(ep->fotg210->reg +\r\nFOTG210_FIBCR(ep->epnum - 1));\r\nlength &= FIBCR_BCFX;\r\n}\r\n} else {\r\nbuffer = req->req.buf + req->req.actual;\r\nif (req->req.length - req->req.actual > ep->ep.maxpacket)\r\nlength = ep->ep.maxpacket;\r\nelse\r\nlength = req->req.length;\r\n}\r\nd = dma_map_single(NULL, buffer, length,\r\nep->dir_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nif (dma_mapping_error(NULL, d)) {\r\npr_err("dma_mapping_error\n");\r\nreturn;\r\n}\r\ndma_sync_single_for_device(NULL, d, length,\r\nep->dir_in ? DMA_TO_DEVICE :\r\nDMA_FROM_DEVICE);\r\nfotg210_enable_dma(ep, d, length);\r\nfotg210_wait_dma_done(ep);\r\nfotg210_disable_dma(ep);\r\nreq->req.actual += length;\r\ndma_unmap_single(NULL, d, length, DMA_TO_DEVICE);\r\n}\r\nstatic void fotg210_ep0_queue(struct fotg210_ep *ep,\r\nstruct fotg210_request *req)\r\n{\r\nif (!req->req.length) {\r\nfotg210_done(ep, req, 0);\r\nreturn;\r\n}\r\nif (ep->dir_in) {\r\nif (req->req.length) {\r\nfotg210_start_dma(ep, req);\r\n} else {\r\npr_err("%s : req->req.length = 0x%x\n",\r\n__func__, req->req.length);\r\n}\r\nif ((req->req.length == req->req.actual) ||\r\n(req->req.actual < ep->ep.maxpacket))\r\nfotg210_done(ep, req, 0);\r\n} else {\r\nif (!req->req.length) {\r\nfotg210_done(ep, req, 0);\r\n} else {\r\nu32 value = ioread32(ep->fotg210->reg +\r\nFOTG210_DMISGR0);\r\nvalue &= ~DMISGR0_MCX_OUT_INT;\r\niowrite32(value, ep->fotg210->reg + FOTG210_DMISGR0);\r\n}\r\n}\r\n}\r\nstatic int fotg210_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct fotg210_ep *ep;\r\nstruct fotg210_request *req;\r\nunsigned long flags;\r\nint request = 0;\r\nep = container_of(_ep, struct fotg210_ep, ep);\r\nreq = container_of(_req, struct fotg210_request, req);\r\nif (ep->fotg210->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&ep->fotg210->lock, flags);\r\nif (list_empty(&ep->queue))\r\nrequest = 1;\r\nlist_add_tail(&req->queue, &ep->queue);\r\nreq->req.actual = 0;\r\nreq->req.status = -EINPROGRESS;\r\nif (!ep->epnum)\r\nfotg210_ep0_queue(ep, req);\r\nelse if (request && !ep->stall)\r\nfotg210_enable_fifo_int(ep);\r\nspin_unlock_irqrestore(&ep->fotg210->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fotg210_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct fotg210_ep *ep;\r\nstruct fotg210_request *req;\r\nunsigned long flags;\r\nep = container_of(_ep, struct fotg210_ep, ep);\r\nreq = container_of(_req, struct fotg210_request, req);\r\nspin_lock_irqsave(&ep->fotg210->lock, flags);\r\nif (!list_empty(&ep->queue))\r\nfotg210_done(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&ep->fotg210->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void fotg210_set_epnstall(struct fotg210_ep *ep)\r\n{\r\nstruct fotg210_udc *fotg210 = ep->fotg210;\r\nu32 value;\r\nvoid __iomem *reg;\r\nif (ep->dir_in) {\r\ndo {\r\nvalue = ioread32(fotg210->reg + FOTG210_DCFESR);\r\n} while (!(value & DCFESR_FIFO_EMPTY(ep->epnum - 1)));\r\n}\r\nreg = (ep->dir_in) ?\r\nfotg210->reg + FOTG210_INEPMPSR(ep->epnum) :\r\nfotg210->reg + FOTG210_OUTEPMPSR(ep->epnum);\r\nvalue = ioread32(reg);\r\nvalue |= INOUTEPMPSR_STL_EP;\r\niowrite32(value, reg);\r\n}\r\nstatic void fotg210_clear_epnstall(struct fotg210_ep *ep)\r\n{\r\nstruct fotg210_udc *fotg210 = ep->fotg210;\r\nu32 value;\r\nvoid __iomem *reg;\r\nreg = (ep->dir_in) ?\r\nfotg210->reg + FOTG210_INEPMPSR(ep->epnum) :\r\nfotg210->reg + FOTG210_OUTEPMPSR(ep->epnum);\r\nvalue = ioread32(reg);\r\nvalue &= ~INOUTEPMPSR_STL_EP;\r\niowrite32(value, reg);\r\n}\r\nstatic int fotg210_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedge)\r\n{\r\nstruct fotg210_ep *ep;\r\nstruct fotg210_udc *fotg210;\r\nunsigned long flags;\r\nint ret = 0;\r\nep = container_of(_ep, struct fotg210_ep, ep);\r\nfotg210 = ep->fotg210;\r\nspin_lock_irqsave(&ep->fotg210->lock, flags);\r\nif (value) {\r\nfotg210_set_epnstall(ep);\r\nep->stall = 1;\r\nif (wedge)\r\nep->wedged = 1;\r\n} else {\r\nfotg210_reset_tseq(fotg210, ep->epnum);\r\nfotg210_clear_epnstall(ep);\r\nep->stall = 0;\r\nep->wedged = 0;\r\nif (!list_empty(&ep->queue))\r\nfotg210_enable_fifo_int(ep);\r\n}\r\nspin_unlock_irqrestore(&ep->fotg210->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int fotg210_ep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nreturn fotg210_set_halt_and_wedge(_ep, value, 0);\r\n}\r\nstatic int fotg210_ep_set_wedge(struct usb_ep *_ep)\r\n{\r\nreturn fotg210_set_halt_and_wedge(_ep, 1, 1);\r\n}\r\nstatic void fotg210_ep_fifo_flush(struct usb_ep *_ep)\r\n{\r\n}\r\nstatic void fotg210_clear_tx0byte(struct fotg210_udc *fotg210)\r\n{\r\nu32 value = ioread32(fotg210->reg + FOTG210_TX0BYTE);\r\nvalue &= ~(TX0BYTE_EP1 | TX0BYTE_EP2 | TX0BYTE_EP3\r\n| TX0BYTE_EP4);\r\niowrite32(value, fotg210->reg + FOTG210_TX0BYTE);\r\n}\r\nstatic void fotg210_clear_rx0byte(struct fotg210_udc *fotg210)\r\n{\r\nu32 value = ioread32(fotg210->reg + FOTG210_RX0BYTE);\r\nvalue &= ~(RX0BYTE_EP1 | RX0BYTE_EP2 | RX0BYTE_EP3\r\n| RX0BYTE_EP4);\r\niowrite32(value, fotg210->reg + FOTG210_RX0BYTE);\r\n}\r\nstatic void fotg210_rdsetupp(struct fotg210_udc *fotg210,\r\nu8 *buffer)\r\n{\r\nint i = 0;\r\nu8 *tmp = buffer;\r\nu32 data;\r\nu32 length = 8;\r\niowrite32(DMATFNR_ACC_CXF, fotg210->reg + FOTG210_DMATFNR);\r\nfor (i = (length >> 2); i > 0; i--) {\r\ndata = ioread32(fotg210->reg + FOTG210_CXPORT);\r\n*tmp = data & 0xFF;\r\n*(tmp + 1) = (data >> 8) & 0xFF;\r\n*(tmp + 2) = (data >> 16) & 0xFF;\r\n*(tmp + 3) = (data >> 24) & 0xFF;\r\ntmp = tmp + 4;\r\n}\r\nswitch (length % 4) {\r\ncase 1:\r\ndata = ioread32(fotg210->reg + FOTG210_CXPORT);\r\n*tmp = data & 0xFF;\r\nbreak;\r\ncase 2:\r\ndata = ioread32(fotg210->reg + FOTG210_CXPORT);\r\n*tmp = data & 0xFF;\r\n*(tmp + 1) = (data >> 8) & 0xFF;\r\nbreak;\r\ncase 3:\r\ndata = ioread32(fotg210->reg + FOTG210_CXPORT);\r\n*tmp = data & 0xFF;\r\n*(tmp + 1) = (data >> 8) & 0xFF;\r\n*(tmp + 2) = (data >> 16) & 0xFF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\niowrite32(DMATFNR_DISDMA, fotg210->reg + FOTG210_DMATFNR);\r\n}\r\nstatic void fotg210_set_configuration(struct fotg210_udc *fotg210)\r\n{\r\nu32 value = ioread32(fotg210->reg + FOTG210_DAR);\r\nvalue |= DAR_AFT_CONF;\r\niowrite32(value, fotg210->reg + FOTG210_DAR);\r\n}\r\nstatic void fotg210_set_dev_addr(struct fotg210_udc *fotg210, u32 addr)\r\n{\r\nu32 value = ioread32(fotg210->reg + FOTG210_DAR);\r\nvalue |= (addr & 0x7F);\r\niowrite32(value, fotg210->reg + FOTG210_DAR);\r\n}\r\nstatic void fotg210_set_cxstall(struct fotg210_udc *fotg210)\r\n{\r\nu32 value = ioread32(fotg210->reg + FOTG210_DCFESR);\r\nvalue |= DCFESR_CX_STL;\r\niowrite32(value, fotg210->reg + FOTG210_DCFESR);\r\n}\r\nstatic void fotg210_request_error(struct fotg210_udc *fotg210)\r\n{\r\nfotg210_set_cxstall(fotg210);\r\npr_err("request error!!\n");\r\n}\r\nstatic void fotg210_set_address(struct fotg210_udc *fotg210,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nif (ctrl->wValue >= 0x0100) {\r\nfotg210_request_error(fotg210);\r\n} else {\r\nfotg210_set_dev_addr(fotg210, ctrl->wValue);\r\nfotg210_set_cxdone(fotg210);\r\n}\r\n}\r\nstatic void fotg210_set_feature(struct fotg210_udc *fotg210,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nfotg210_set_cxdone(fotg210);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nfotg210_set_cxdone(fotg210);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT: {\r\nu8 epnum;\r\nepnum = le16_to_cpu(ctrl->wIndex) & USB_ENDPOINT_NUMBER_MASK;\r\nif (epnum)\r\nfotg210_set_epnstall(fotg210->ep[epnum]);\r\nelse\r\nfotg210_set_cxstall(fotg210);\r\nfotg210_set_cxdone(fotg210);\r\n}\r\nbreak;\r\ndefault:\r\nfotg210_request_error(fotg210);\r\nbreak;\r\n}\r\n}\r\nstatic void fotg210_clear_feature(struct fotg210_udc *fotg210,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct fotg210_ep *ep =\r\nfotg210->ep[ctrl->wIndex & USB_ENDPOINT_NUMBER_MASK];\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nfotg210_set_cxdone(fotg210);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nfotg210_set_cxdone(fotg210);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nif (ctrl->wIndex & USB_ENDPOINT_NUMBER_MASK) {\r\nif (ep->wedged) {\r\nfotg210_set_cxdone(fotg210);\r\nbreak;\r\n}\r\nif (ep->stall)\r\nfotg210_set_halt_and_wedge(&ep->ep, 0, 0);\r\n}\r\nfotg210_set_cxdone(fotg210);\r\nbreak;\r\ndefault:\r\nfotg210_request_error(fotg210);\r\nbreak;\r\n}\r\n}\r\nstatic int fotg210_is_epnstall(struct fotg210_ep *ep)\r\n{\r\nstruct fotg210_udc *fotg210 = ep->fotg210;\r\nu32 value;\r\nvoid __iomem *reg;\r\nreg = (ep->dir_in) ?\r\nfotg210->reg + FOTG210_INEPMPSR(ep->epnum) :\r\nfotg210->reg + FOTG210_OUTEPMPSR(ep->epnum);\r\nvalue = ioread32(reg);\r\nreturn value & INOUTEPMPSR_STL_EP ? 1 : 0;\r\n}\r\nstatic void fotg210_get_status(struct fotg210_udc *fotg210,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nu8 epnum;\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nfotg210->ep0_data = 1 << USB_DEVICE_SELF_POWERED;\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nfotg210->ep0_data = 0;\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nepnum = ctrl->wIndex & USB_ENDPOINT_NUMBER_MASK;\r\nif (epnum)\r\nfotg210->ep0_data =\r\nfotg210_is_epnstall(fotg210->ep[epnum])\r\n<< USB_ENDPOINT_HALT;\r\nelse\r\nfotg210_request_error(fotg210);\r\nbreak;\r\ndefault:\r\nfotg210_request_error(fotg210);\r\nreturn;\r\n}\r\nfotg210->ep0_req->buf = &fotg210->ep0_data;\r\nfotg210->ep0_req->length = 2;\r\nspin_unlock(&fotg210->lock);\r\nfotg210_ep_queue(fotg210->gadget.ep0, fotg210->ep0_req, GFP_KERNEL);\r\nspin_lock(&fotg210->lock);\r\n}\r\nstatic int fotg210_setup_packet(struct fotg210_udc *fotg210,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nu8 *p = (u8 *)ctrl;\r\nu8 ret = 0;\r\nfotg210_rdsetupp(fotg210, p);\r\nfotg210->ep[0]->dir_in = ctrl->bRequestType & USB_DIR_IN;\r\nif (fotg210->gadget.speed == USB_SPEED_UNKNOWN) {\r\nu32 value = ioread32(fotg210->reg + FOTG210_DMCR);\r\nfotg210->gadget.speed = value & DMCR_HS_EN ?\r\nUSB_SPEED_HIGH : USB_SPEED_FULL;\r\n}\r\nif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\nswitch (ctrl->bRequest) {\r\ncase USB_REQ_GET_STATUS:\r\nfotg210_get_status(fotg210, ctrl);\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nfotg210_clear_feature(fotg210, ctrl);\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nfotg210_set_feature(fotg210, ctrl);\r\nbreak;\r\ncase USB_REQ_SET_ADDRESS:\r\nfotg210_set_address(fotg210, ctrl);\r\nbreak;\r\ncase USB_REQ_SET_CONFIGURATION:\r\nfotg210_set_configuration(fotg210);\r\nret = 1;\r\nbreak;\r\ndefault:\r\nret = 1;\r\nbreak;\r\n}\r\n} else {\r\nret = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic void fotg210_ep0out(struct fotg210_udc *fotg210)\r\n{\r\nstruct fotg210_ep *ep = fotg210->ep[0];\r\nif (!list_empty(&ep->queue) && !ep->dir_in) {\r\nstruct fotg210_request *req;\r\nreq = list_first_entry(&ep->queue,\r\nstruct fotg210_request, queue);\r\nif (req->req.length)\r\nfotg210_start_dma(ep, req);\r\nif ((req->req.length - req->req.actual) < ep->ep.maxpacket)\r\nfotg210_done(ep, req, 0);\r\n} else {\r\npr_err("%s : empty queue\n", __func__);\r\n}\r\n}\r\nstatic void fotg210_ep0in(struct fotg210_udc *fotg210)\r\n{\r\nstruct fotg210_ep *ep = fotg210->ep[0];\r\nif ((!list_empty(&ep->queue)) && (ep->dir_in)) {\r\nstruct fotg210_request *req;\r\nreq = list_entry(ep->queue.next,\r\nstruct fotg210_request, queue);\r\nif (req->req.length)\r\nfotg210_start_dma(ep, req);\r\nif ((req->req.length - req->req.actual) < ep->ep.maxpacket)\r\nfotg210_done(ep, req, 0);\r\n} else {\r\nfotg210_set_cxdone(fotg210);\r\n}\r\n}\r\nstatic void fotg210_clear_comabt_int(struct fotg210_udc *fotg210)\r\n{\r\nu32 value = ioread32(fotg210->reg + FOTG210_DISGR0);\r\nvalue &= ~DISGR0_CX_COMABT_INT;\r\niowrite32(value, fotg210->reg + FOTG210_DISGR0);\r\n}\r\nstatic void fotg210_in_fifo_handler(struct fotg210_ep *ep)\r\n{\r\nstruct fotg210_request *req = list_entry(ep->queue.next,\r\nstruct fotg210_request, queue);\r\nif (req->req.length)\r\nfotg210_start_dma(ep, req);\r\nfotg210_done(ep, req, 0);\r\n}\r\nstatic void fotg210_out_fifo_handler(struct fotg210_ep *ep)\r\n{\r\nstruct fotg210_request *req = list_entry(ep->queue.next,\r\nstruct fotg210_request, queue);\r\nfotg210_start_dma(ep, req);\r\nif (req->req.length == req->req.actual ||\r\nreq->req.actual < ep->ep.maxpacket)\r\nfotg210_done(ep, req, 0);\r\n}\r\nstatic irqreturn_t fotg210_irq(int irq, void *_fotg210)\r\n{\r\nstruct fotg210_udc *fotg210 = _fotg210;\r\nu32 int_grp = ioread32(fotg210->reg + FOTG210_DIGR);\r\nu32 int_msk = ioread32(fotg210->reg + FOTG210_DMIGR);\r\nint_grp &= ~int_msk;\r\nspin_lock(&fotg210->lock);\r\nif (int_grp & DIGR_INT_G2) {\r\nvoid __iomem *reg = fotg210->reg + FOTG210_DISGR2;\r\nu32 int_grp2 = ioread32(reg);\r\nu32 int_msk2 = ioread32(fotg210->reg + FOTG210_DMISGR2);\r\nu32 value;\r\nint_grp2 &= ~int_msk2;\r\nif (int_grp2 & DISGR2_USBRST_INT) {\r\nvalue = ioread32(reg);\r\nvalue &= ~DISGR2_USBRST_INT;\r\niowrite32(value, reg);\r\npr_info("fotg210 udc reset\n");\r\n}\r\nif (int_grp2 & DISGR2_SUSP_INT) {\r\nvalue = ioread32(reg);\r\nvalue &= ~DISGR2_SUSP_INT;\r\niowrite32(value, reg);\r\npr_info("fotg210 udc suspend\n");\r\n}\r\nif (int_grp2 & DISGR2_RESM_INT) {\r\nvalue = ioread32(reg);\r\nvalue &= ~DISGR2_RESM_INT;\r\niowrite32(value, reg);\r\npr_info("fotg210 udc resume\n");\r\n}\r\nif (int_grp2 & DISGR2_ISO_SEQ_ERR_INT) {\r\nvalue = ioread32(reg);\r\nvalue &= ~DISGR2_ISO_SEQ_ERR_INT;\r\niowrite32(value, reg);\r\npr_info("fotg210 iso sequence error\n");\r\n}\r\nif (int_grp2 & DISGR2_ISO_SEQ_ABORT_INT) {\r\nvalue = ioread32(reg);\r\nvalue &= ~DISGR2_ISO_SEQ_ABORT_INT;\r\niowrite32(value, reg);\r\npr_info("fotg210 iso sequence abort\n");\r\n}\r\nif (int_grp2 & DISGR2_TX0BYTE_INT) {\r\nfotg210_clear_tx0byte(fotg210);\r\nvalue = ioread32(reg);\r\nvalue &= ~DISGR2_TX0BYTE_INT;\r\niowrite32(value, reg);\r\npr_info("fotg210 transferred 0 byte\n");\r\n}\r\nif (int_grp2 & DISGR2_RX0BYTE_INT) {\r\nfotg210_clear_rx0byte(fotg210);\r\nvalue = ioread32(reg);\r\nvalue &= ~DISGR2_RX0BYTE_INT;\r\niowrite32(value, reg);\r\npr_info("fotg210 received 0 byte\n");\r\n}\r\nif (int_grp2 & DISGR2_DMA_ERROR) {\r\nvalue = ioread32(reg);\r\nvalue &= ~DISGR2_DMA_ERROR;\r\niowrite32(value, reg);\r\n}\r\n}\r\nif (int_grp & DIGR_INT_G0) {\r\nvoid __iomem *reg = fotg210->reg + FOTG210_DISGR0;\r\nu32 int_grp0 = ioread32(reg);\r\nu32 int_msk0 = ioread32(fotg210->reg + FOTG210_DMISGR0);\r\nstruct usb_ctrlrequest ctrl;\r\nint_grp0 &= ~int_msk0;\r\nif (int_grp0 & DISGR0_CX_COMABT_INT) {\r\nfotg210_clear_comabt_int(fotg210);\r\npr_info("fotg210 CX command abort\n");\r\n}\r\nif (int_grp0 & DISGR0_CX_SETUP_INT) {\r\nif (fotg210_setup_packet(fotg210, &ctrl)) {\r\nspin_unlock(&fotg210->lock);\r\nif (fotg210->driver->setup(&fotg210->gadget,\r\n&ctrl) < 0)\r\nfotg210_set_cxstall(fotg210);\r\nspin_lock(&fotg210->lock);\r\n}\r\n}\r\nif (int_grp0 & DISGR0_CX_COMEND_INT)\r\npr_info("fotg210 cmd end\n");\r\nif (int_grp0 & DISGR0_CX_IN_INT)\r\nfotg210_ep0in(fotg210);\r\nif (int_grp0 & DISGR0_CX_OUT_INT)\r\nfotg210_ep0out(fotg210);\r\nif (int_grp0 & DISGR0_CX_COMFAIL_INT) {\r\nfotg210_set_cxstall(fotg210);\r\npr_info("fotg210 ep0 fail\n");\r\n}\r\n}\r\nif (int_grp & DIGR_INT_G1) {\r\nvoid __iomem *reg = fotg210->reg + FOTG210_DISGR1;\r\nu32 int_grp1 = ioread32(reg);\r\nu32 int_msk1 = ioread32(fotg210->reg + FOTG210_DMISGR1);\r\nint fifo;\r\nint_grp1 &= ~int_msk1;\r\nfor (fifo = 0; fifo < FOTG210_MAX_FIFO_NUM; fifo++) {\r\nif (int_grp1 & DISGR1_IN_INT(fifo))\r\nfotg210_in_fifo_handler(fotg210->ep[fifo + 1]);\r\nif ((int_grp1 & DISGR1_OUT_INT(fifo)) ||\r\n(int_grp1 & DISGR1_SPK_INT(fifo)))\r\nfotg210_out_fifo_handler(fotg210->ep[fifo + 1]);\r\n}\r\n}\r\nspin_unlock(&fotg210->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void fotg210_disable_unplug(struct fotg210_udc *fotg210)\r\n{\r\nu32 reg = ioread32(fotg210->reg + FOTG210_PHYTMSR);\r\nreg &= ~PHYTMSR_UNPLUG;\r\niowrite32(reg, fotg210->reg + FOTG210_PHYTMSR);\r\n}\r\nstatic int fotg210_udc_start(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct fotg210_udc *fotg210 = gadget_to_fotg210(g);\r\nu32 value;\r\ndriver->driver.bus = NULL;\r\nfotg210->driver = driver;\r\nvalue = ioread32(fotg210->reg + FOTG210_DMCR);\r\nvalue |= DMCR_GLINT_EN;\r\niowrite32(value, fotg210->reg + FOTG210_DMCR);\r\nreturn 0;\r\n}\r\nstatic void fotg210_init(struct fotg210_udc *fotg210)\r\n{\r\nu32 value;\r\niowrite32(GMIR_MHC_INT | GMIR_MOTG_INT | GMIR_INT_POLARITY,\r\nfotg210->reg + FOTG210_GMIR);\r\nvalue = ioread32(fotg210->reg + FOTG210_DMCR);\r\nvalue &= ~DMCR_GLINT_EN;\r\niowrite32(value, fotg210->reg + FOTG210_DMCR);\r\niowrite32(~(u32)0, fotg210->reg + FOTG210_DMISGR1);\r\nvalue = ioread32(fotg210->reg + FOTG210_DMISGR0);\r\nvalue |= DMISGR0_MCX_COMEND;\r\niowrite32(value, fotg210->reg + FOTG210_DMISGR0);\r\n}\r\nstatic int fotg210_udc_stop(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct fotg210_udc *fotg210 = gadget_to_fotg210(g);\r\nunsigned long flags;\r\nspin_lock_irqsave(&fotg210->lock, flags);\r\nfotg210_init(fotg210);\r\nfotg210->driver = NULL;\r\nspin_unlock_irqrestore(&fotg210->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fotg210_udc_remove(struct platform_device *pdev)\r\n{\r\nstruct fotg210_udc *fotg210 = platform_get_drvdata(pdev);\r\nusb_del_gadget_udc(&fotg210->gadget);\r\niounmap(fotg210->reg);\r\nfree_irq(platform_get_irq(pdev, 0), fotg210);\r\nfotg210_ep_free_request(&fotg210->ep[0]->ep, fotg210->ep0_req);\r\nkfree(fotg210);\r\nreturn 0;\r\n}\r\nstatic int fotg210_udc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res, *ires;\r\nstruct fotg210_udc *fotg210 = NULL;\r\nstruct fotg210_ep *_ep[FOTG210_MAX_NUM_EP];\r\nint ret = 0;\r\nint i;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\npr_err("platform_get_resource error.\n");\r\nreturn -ENODEV;\r\n}\r\nires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!ires) {\r\npr_err("platform_get_resource IORESOURCE_IRQ error.\n");\r\nreturn -ENODEV;\r\n}\r\nret = -ENOMEM;\r\nfotg210 = kzalloc(sizeof(struct fotg210_udc), GFP_KERNEL);\r\nif (fotg210 == NULL) {\r\npr_err("kzalloc error\n");\r\ngoto err_alloc;\r\n}\r\nfor (i = 0; i < FOTG210_MAX_NUM_EP; i++) {\r\n_ep[i] = kzalloc(sizeof(struct fotg210_ep), GFP_KERNEL);\r\nif (_ep[i] == NULL) {\r\npr_err("_ep kzalloc error\n");\r\ngoto err_alloc;\r\n}\r\nfotg210->ep[i] = _ep[i];\r\n}\r\nfotg210->reg = ioremap(res->start, resource_size(res));\r\nif (fotg210->reg == NULL) {\r\npr_err("ioremap error.\n");\r\ngoto err_map;\r\n}\r\nspin_lock_init(&fotg210->lock);\r\nplatform_set_drvdata(pdev, fotg210);\r\nfotg210->gadget.ops = &fotg210_gadget_ops;\r\nfotg210->gadget.max_speed = USB_SPEED_HIGH;\r\nfotg210->gadget.dev.parent = &pdev->dev;\r\nfotg210->gadget.dev.dma_mask = pdev->dev.dma_mask;\r\nfotg210->gadget.name = udc_name;\r\nINIT_LIST_HEAD(&fotg210->gadget.ep_list);\r\nfor (i = 0; i < FOTG210_MAX_NUM_EP; i++) {\r\nstruct fotg210_ep *ep = fotg210->ep[i];\r\nif (i) {\r\nINIT_LIST_HEAD(&fotg210->ep[i]->ep.ep_list);\r\nlist_add_tail(&fotg210->ep[i]->ep.ep_list,\r\n&fotg210->gadget.ep_list);\r\n}\r\nep->fotg210 = fotg210;\r\nINIT_LIST_HEAD(&ep->queue);\r\nep->ep.name = fotg210_ep_name[i];\r\nep->ep.ops = &fotg210_ep_ops;\r\nusb_ep_set_maxpacket_limit(&ep->ep, (unsigned short) ~0);\r\n}\r\nusb_ep_set_maxpacket_limit(&fotg210->ep[0]->ep, 0x40);\r\nfotg210->gadget.ep0 = &fotg210->ep[0]->ep;\r\nINIT_LIST_HEAD(&fotg210->gadget.ep0->ep_list);\r\nfotg210->ep0_req = fotg210_ep_alloc_request(&fotg210->ep[0]->ep,\r\nGFP_KERNEL);\r\nif (fotg210->ep0_req == NULL)\r\ngoto err_req;\r\nfotg210_init(fotg210);\r\nfotg210_disable_unplug(fotg210);\r\nret = request_irq(ires->start, fotg210_irq, IRQF_SHARED,\r\nudc_name, fotg210);\r\nif (ret < 0) {\r\npr_err("request_irq error (%d)\n", ret);\r\ngoto err_irq;\r\n}\r\nret = usb_add_gadget_udc(&pdev->dev, &fotg210->gadget);\r\nif (ret)\r\ngoto err_add_udc;\r\ndev_info(&pdev->dev, "version %s\n", DRIVER_VERSION);\r\nreturn 0;\r\nerr_add_udc:\r\nerr_irq:\r\nfree_irq(ires->start, fotg210);\r\nerr_req:\r\nfotg210_ep_free_request(&fotg210->ep[0]->ep, fotg210->ep0_req);\r\nerr_map:\r\nif (fotg210->reg)\r\niounmap(fotg210->reg);\r\nerr_alloc:\r\nkfree(fotg210);\r\nreturn ret;\r\n}
