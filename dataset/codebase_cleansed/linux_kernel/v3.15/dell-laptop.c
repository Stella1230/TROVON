static int dmi_matched(const struct dmi_system_id *dmi)\r\n{\r\nquirks = dmi->driver_data;\r\nreturn 1;\r\n}\r\nstatic void get_buffer(void)\r\n{\r\nmutex_lock(&buffer_mutex);\r\nmemset(buffer, 0, sizeof(struct calling_interface_buffer));\r\n}\r\nstatic void release_buffer(void)\r\n{\r\nmutex_unlock(&buffer_mutex);\r\n}\r\nstatic void __init parse_da_table(const struct dmi_header *dm)\r\n{\r\nint tokens = (dm->length-11)/sizeof(struct calling_interface_token)-1;\r\nstruct calling_interface_token *new_da_tokens;\r\nstruct calling_interface_structure *table =\r\ncontainer_of(dm, struct calling_interface_structure, header);\r\nif (dm->length < 17)\r\nreturn;\r\nda_command_address = table->cmdIOAddress;\r\nda_command_code = table->cmdIOCode;\r\nnew_da_tokens = krealloc(da_tokens, (da_num_tokens + tokens) *\r\nsizeof(struct calling_interface_token),\r\nGFP_KERNEL);\r\nif (!new_da_tokens)\r\nreturn;\r\nda_tokens = new_da_tokens;\r\nmemcpy(da_tokens+da_num_tokens, table->tokens,\r\nsizeof(struct calling_interface_token) * tokens);\r\nda_num_tokens += tokens;\r\n}\r\nstatic void __init find_tokens(const struct dmi_header *dm, void *dummy)\r\n{\r\nswitch (dm->type) {\r\ncase 0xd4:\r\ncase 0xd5:\r\ncase 0xd6:\r\nbreak;\r\ncase 0xda:\r\nparse_da_table(dm);\r\nbreak;\r\n}\r\n}\r\nstatic int find_token_location(int tokenid)\r\n{\r\nint i;\r\nfor (i = 0; i < da_num_tokens; i++) {\r\nif (da_tokens[i].tokenID == tokenid)\r\nreturn da_tokens[i].location;\r\n}\r\nreturn -1;\r\n}\r\nstatic struct calling_interface_buffer *\r\ndell_send_request(struct calling_interface_buffer *buffer, int class,\r\nint select)\r\n{\r\nstruct smi_cmd command;\r\ncommand.magic = SMI_CMD_MAGIC;\r\ncommand.command_address = da_command_address;\r\ncommand.command_code = da_command_code;\r\ncommand.ebx = virt_to_phys(buffer);\r\ncommand.ecx = 0x42534931;\r\nbuffer->class = class;\r\nbuffer->select = select;\r\ndcdbas_smi_request(&command);\r\nreturn buffer;\r\n}\r\nstatic int dell_rfkill_set(void *data, bool blocked)\r\n{\r\nint disable = blocked ? 1 : 0;\r\nunsigned long radio = (unsigned long)data;\r\nint hwswitch_bit = (unsigned long)data - 1;\r\nget_buffer();\r\ndell_send_request(buffer, 17, 11);\r\nif ((hwswitch_state & BIT(hwswitch_bit)) &&\r\n!(buffer->output[1] & BIT(16)))\r\ndisable = 1;\r\nbuffer->input[0] = (1 | (radio<<8) | (disable << 16));\r\ndell_send_request(buffer, 17, 11);\r\nrelease_buffer();\r\nreturn 0;\r\n}\r\nstatic void dell_rfkill_update_sw_state(struct rfkill *rfkill, int radio,\r\nint status)\r\n{\r\nif (status & BIT(0)) {\r\nint block = rfkill_blocked(rfkill);\r\nbuffer->input[0] = (1 | (radio << 8) | (block << 16));\r\ndell_send_request(buffer, 17, 11);\r\n} else {\r\nrfkill_set_sw_state(rfkill, !!(status & BIT(radio + 16)));\r\n}\r\n}\r\nstatic void dell_rfkill_update_hw_state(struct rfkill *rfkill, int radio,\r\nint status)\r\n{\r\nif (hwswitch_state & (BIT(radio - 1)))\r\nrfkill_set_hw_state(rfkill, !(status & BIT(16)));\r\n}\r\nstatic void dell_rfkill_query(struct rfkill *rfkill, void *data)\r\n{\r\nint status;\r\nget_buffer();\r\ndell_send_request(buffer, 17, 11);\r\nstatus = buffer->output[1];\r\ndell_rfkill_update_hw_state(rfkill, (unsigned long)data, status);\r\nrelease_buffer();\r\n}\r\nstatic int dell_debugfs_show(struct seq_file *s, void *data)\r\n{\r\nint status;\r\nget_buffer();\r\ndell_send_request(buffer, 17, 11);\r\nstatus = buffer->output[1];\r\nrelease_buffer();\r\nseq_printf(s, "status:\t0x%X\n", status);\r\nseq_printf(s, "Bit 0 : Hardware switch supported: %lu\n",\r\nstatus & BIT(0));\r\nseq_printf(s, "Bit 1 : Wifi locator supported: %lu\n",\r\n(status & BIT(1)) >> 1);\r\nseq_printf(s, "Bit 2 : Wifi is supported: %lu\n",\r\n(status & BIT(2)) >> 2);\r\nseq_printf(s, "Bit 3 : Bluetooth is supported: %lu\n",\r\n(status & BIT(3)) >> 3);\r\nseq_printf(s, "Bit 4 : WWAN is supported: %lu\n",\r\n(status & BIT(4)) >> 4);\r\nseq_printf(s, "Bit 5 : Wireless keyboard supported: %lu\n",\r\n(status & BIT(5)) >> 5);\r\nseq_printf(s, "Bit 8 : Wifi is installed: %lu\n",\r\n(status & BIT(8)) >> 8);\r\nseq_printf(s, "Bit 9 : Bluetooth is installed: %lu\n",\r\n(status & BIT(9)) >> 9);\r\nseq_printf(s, "Bit 10: WWAN is installed: %lu\n",\r\n(status & BIT(10)) >> 10);\r\nseq_printf(s, "Bit 16: Hardware switch is on: %lu\n",\r\n(status & BIT(16)) >> 16);\r\nseq_printf(s, "Bit 17: Wifi is blocked: %lu\n",\r\n(status & BIT(17)) >> 17);\r\nseq_printf(s, "Bit 18: Bluetooth is blocked: %lu\n",\r\n(status & BIT(18)) >> 18);\r\nseq_printf(s, "Bit 19: WWAN is blocked: %lu\n",\r\n(status & BIT(19)) >> 19);\r\nseq_printf(s, "\nhwswitch_state:\t0x%X\n", hwswitch_state);\r\nseq_printf(s, "Bit 0 : Wifi controlled by switch: %lu\n",\r\nhwswitch_state & BIT(0));\r\nseq_printf(s, "Bit 1 : Bluetooth controlled by switch: %lu\n",\r\n(hwswitch_state & BIT(1)) >> 1);\r\nseq_printf(s, "Bit 2 : WWAN controlled by switch: %lu\n",\r\n(hwswitch_state & BIT(2)) >> 2);\r\nseq_printf(s, "Bit 7 : Wireless switch config locked: %lu\n",\r\n(hwswitch_state & BIT(7)) >> 7);\r\nseq_printf(s, "Bit 8 : Wifi locator enabled: %lu\n",\r\n(hwswitch_state & BIT(8)) >> 8);\r\nseq_printf(s, "Bit 15: Wifi locator setting locked: %lu\n",\r\n(hwswitch_state & BIT(15)) >> 15);\r\nreturn 0;\r\n}\r\nstatic int dell_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dell_debugfs_show, inode->i_private);\r\n}\r\nstatic void dell_update_rfkill(struct work_struct *ignored)\r\n{\r\nint status;\r\nget_buffer();\r\ndell_send_request(buffer, 17, 11);\r\nstatus = buffer->output[1];\r\nif (wifi_rfkill) {\r\ndell_rfkill_update_hw_state(wifi_rfkill, 1, status);\r\ndell_rfkill_update_sw_state(wifi_rfkill, 1, status);\r\n}\r\nif (bluetooth_rfkill) {\r\ndell_rfkill_update_hw_state(bluetooth_rfkill, 2, status);\r\ndell_rfkill_update_sw_state(bluetooth_rfkill, 2, status);\r\n}\r\nif (wwan_rfkill) {\r\ndell_rfkill_update_hw_state(wwan_rfkill, 3, status);\r\ndell_rfkill_update_sw_state(wwan_rfkill, 3, status);\r\n}\r\nrelease_buffer();\r\n}\r\nstatic bool dell_laptop_i8042_filter(unsigned char data, unsigned char str,\r\nstruct serio *port)\r\n{\r\nstatic bool extended;\r\nif (str & 0x20)\r\nreturn false;\r\nif (unlikely(data == 0xe0)) {\r\nextended = true;\r\nreturn false;\r\n} else if (unlikely(extended)) {\r\nswitch (data) {\r\ncase 0x8:\r\nschedule_delayed_work(&dell_rfkill_work,\r\nround_jiffies_relative(HZ / 4));\r\nbreak;\r\n}\r\nextended = false;\r\n}\r\nreturn false;\r\n}\r\nstatic int __init dell_setup_rfkill(void)\r\n{\r\nint status, ret, whitelisted;\r\nconst char *product;\r\nwhitelisted = 0;\r\nproduct = dmi_get_system_info(DMI_PRODUCT_NAME);\r\nif (product && (strncmp(product, "Latitude", 8) == 0 ||\r\nstrncmp(product, "Precision", 9) == 0))\r\nwhitelisted = 1;\r\nif (!force_rfkill && !whitelisted)\r\nreturn 0;\r\nget_buffer();\r\ndell_send_request(buffer, 17, 11);\r\nstatus = buffer->output[1];\r\nbuffer->input[0] = 0x2;\r\ndell_send_request(buffer, 17, 11);\r\nhwswitch_state = buffer->output[1];\r\nrelease_buffer();\r\nif (!(status & BIT(0))) {\r\nif (force_rfkill) {\r\nhwswitch_state &= ~7;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nif ((status & (1<<2|1<<8)) == (1<<2|1<<8)) {\r\nwifi_rfkill = rfkill_alloc("dell-wifi", &platform_device->dev,\r\nRFKILL_TYPE_WLAN,\r\n&dell_rfkill_ops, (void *) 1);\r\nif (!wifi_rfkill) {\r\nret = -ENOMEM;\r\ngoto err_wifi;\r\n}\r\nret = rfkill_register(wifi_rfkill);\r\nif (ret)\r\ngoto err_wifi;\r\n}\r\nif ((status & (1<<3|1<<9)) == (1<<3|1<<9)) {\r\nbluetooth_rfkill = rfkill_alloc("dell-bluetooth",\r\n&platform_device->dev,\r\nRFKILL_TYPE_BLUETOOTH,\r\n&dell_rfkill_ops, (void *) 2);\r\nif (!bluetooth_rfkill) {\r\nret = -ENOMEM;\r\ngoto err_bluetooth;\r\n}\r\nret = rfkill_register(bluetooth_rfkill);\r\nif (ret)\r\ngoto err_bluetooth;\r\n}\r\nif ((status & (1<<4|1<<10)) == (1<<4|1<<10)) {\r\nwwan_rfkill = rfkill_alloc("dell-wwan",\r\n&platform_device->dev,\r\nRFKILL_TYPE_WWAN,\r\n&dell_rfkill_ops, (void *) 3);\r\nif (!wwan_rfkill) {\r\nret = -ENOMEM;\r\ngoto err_wwan;\r\n}\r\nret = rfkill_register(wwan_rfkill);\r\nif (ret)\r\ngoto err_wwan;\r\n}\r\nret = i8042_install_filter(dell_laptop_i8042_filter);\r\nif (ret) {\r\npr_warn("Unable to install key filter\n");\r\ngoto err_filter;\r\n}\r\nreturn 0;\r\nerr_filter:\r\nif (wwan_rfkill)\r\nrfkill_unregister(wwan_rfkill);\r\nerr_wwan:\r\nrfkill_destroy(wwan_rfkill);\r\nif (bluetooth_rfkill)\r\nrfkill_unregister(bluetooth_rfkill);\r\nerr_bluetooth:\r\nrfkill_destroy(bluetooth_rfkill);\r\nif (wifi_rfkill)\r\nrfkill_unregister(wifi_rfkill);\r\nerr_wifi:\r\nrfkill_destroy(wifi_rfkill);\r\nreturn ret;\r\n}\r\nstatic void dell_cleanup_rfkill(void)\r\n{\r\nif (wifi_rfkill) {\r\nrfkill_unregister(wifi_rfkill);\r\nrfkill_destroy(wifi_rfkill);\r\n}\r\nif (bluetooth_rfkill) {\r\nrfkill_unregister(bluetooth_rfkill);\r\nrfkill_destroy(bluetooth_rfkill);\r\n}\r\nif (wwan_rfkill) {\r\nrfkill_unregister(wwan_rfkill);\r\nrfkill_destroy(wwan_rfkill);\r\n}\r\n}\r\nstatic int dell_send_intensity(struct backlight_device *bd)\r\n{\r\nint ret = 0;\r\nget_buffer();\r\nbuffer->input[0] = find_token_location(BRIGHTNESS_TOKEN);\r\nbuffer->input[1] = bd->props.brightness;\r\nif (buffer->input[0] == -1) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (power_supply_is_system_supplied() > 0)\r\ndell_send_request(buffer, 1, 2);\r\nelse\r\ndell_send_request(buffer, 1, 1);\r\nout:\r\nrelease_buffer();\r\nreturn ret;\r\n}\r\nstatic int dell_get_intensity(struct backlight_device *bd)\r\n{\r\nint ret = 0;\r\nget_buffer();\r\nbuffer->input[0] = find_token_location(BRIGHTNESS_TOKEN);\r\nif (buffer->input[0] == -1) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (power_supply_is_system_supplied() > 0)\r\ndell_send_request(buffer, 0, 2);\r\nelse\r\ndell_send_request(buffer, 0, 1);\r\nret = buffer->output[1];\r\nout:\r\nrelease_buffer();\r\nreturn ret;\r\n}\r\nstatic void touchpad_led_on(void)\r\n{\r\nint command = 0x97;\r\nchar data = 1;\r\ni8042_command(&data, command | 1 << 12);\r\n}\r\nstatic void touchpad_led_off(void)\r\n{\r\nint command = 0x97;\r\nchar data = 2;\r\ni8042_command(&data, command | 1 << 12);\r\n}\r\nstatic void touchpad_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nif (value > 0)\r\ntouchpad_led_on();\r\nelse\r\ntouchpad_led_off();\r\n}\r\nstatic int touchpad_led_init(struct device *dev)\r\n{\r\nreturn led_classdev_register(dev, &touchpad_led);\r\n}\r\nstatic void touchpad_led_exit(void)\r\n{\r\nled_classdev_unregister(&touchpad_led);\r\n}\r\nstatic int __init dell_init(void)\r\n{\r\nint max_intensity = 0;\r\nint ret;\r\nif (!dmi_check_system(dell_device_table))\r\nreturn -ENODEV;\r\nquirks = NULL;\r\ndmi_check_system(dell_quirks);\r\ndmi_walk(find_tokens, NULL);\r\nif (!da_tokens) {\r\npr_info("Unable to find dmi tokens\n");\r\nreturn -ENODEV;\r\n}\r\nret = platform_driver_register(&platform_driver);\r\nif (ret)\r\ngoto fail_platform_driver;\r\nplatform_device = platform_device_alloc("dell-laptop", -1);\r\nif (!platform_device) {\r\nret = -ENOMEM;\r\ngoto fail_platform_device1;\r\n}\r\nret = platform_device_add(platform_device);\r\nif (ret)\r\ngoto fail_platform_device2;\r\nbufferpage = alloc_page(GFP_KERNEL | GFP_DMA32);\r\nif (!bufferpage) {\r\nret = -ENOMEM;\r\ngoto fail_buffer;\r\n}\r\nbuffer = page_address(bufferpage);\r\nret = dell_setup_rfkill();\r\nif (ret) {\r\npr_warn("Unable to setup rfkill\n");\r\ngoto fail_rfkill;\r\n}\r\nif (quirks && quirks->touchpad_led)\r\ntouchpad_led_init(&platform_device->dev);\r\ndell_laptop_dir = debugfs_create_dir("dell_laptop", NULL);\r\nif (dell_laptop_dir != NULL)\r\ndebugfs_create_file("rfkill", 0444, dell_laptop_dir, NULL,\r\n&dell_debugfs_fops);\r\n#ifdef CONFIG_ACPI\r\nif (acpi_video_backlight_support())\r\nreturn 0;\r\n#endif\r\nget_buffer();\r\nbuffer->input[0] = find_token_location(BRIGHTNESS_TOKEN);\r\nif (buffer->input[0] != -1) {\r\ndell_send_request(buffer, 0, 2);\r\nmax_intensity = buffer->output[3];\r\n}\r\nrelease_buffer();\r\nif (max_intensity) {\r\nstruct backlight_properties props;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = max_intensity;\r\ndell_backlight_device = backlight_device_register("dell_backlight",\r\n&platform_device->dev,\r\nNULL,\r\n&dell_ops,\r\n&props);\r\nif (IS_ERR(dell_backlight_device)) {\r\nret = PTR_ERR(dell_backlight_device);\r\ndell_backlight_device = NULL;\r\ngoto fail_backlight;\r\n}\r\ndell_backlight_device->props.brightness =\r\ndell_get_intensity(dell_backlight_device);\r\nbacklight_update_status(dell_backlight_device);\r\n}\r\nreturn 0;\r\nfail_backlight:\r\ni8042_remove_filter(dell_laptop_i8042_filter);\r\ncancel_delayed_work_sync(&dell_rfkill_work);\r\ndell_cleanup_rfkill();\r\nfail_rfkill:\r\nfree_page((unsigned long)bufferpage);\r\nfail_buffer:\r\nplatform_device_del(platform_device);\r\nfail_platform_device2:\r\nplatform_device_put(platform_device);\r\nfail_platform_device1:\r\nplatform_driver_unregister(&platform_driver);\r\nfail_platform_driver:\r\nkfree(da_tokens);\r\nreturn ret;\r\n}\r\nstatic void __exit dell_exit(void)\r\n{\r\ndebugfs_remove_recursive(dell_laptop_dir);\r\nif (quirks && quirks->touchpad_led)\r\ntouchpad_led_exit();\r\ni8042_remove_filter(dell_laptop_i8042_filter);\r\ncancel_delayed_work_sync(&dell_rfkill_work);\r\nbacklight_device_unregister(dell_backlight_device);\r\ndell_cleanup_rfkill();\r\nif (platform_device) {\r\nplatform_device_unregister(platform_device);\r\nplatform_driver_unregister(&platform_driver);\r\n}\r\nkfree(da_tokens);\r\nfree_page((unsigned long)buffer);\r\n}
