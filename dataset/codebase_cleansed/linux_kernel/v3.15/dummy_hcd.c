static inline struct dummy_ep *usb_ep_to_dummy_ep(struct usb_ep *_ep)\r\n{\r\nreturn container_of(_ep, struct dummy_ep, ep);\r\n}\r\nstatic inline struct dummy_request *usb_request_to_dummy_request\r\n(struct usb_request *_req)\r\n{\r\nreturn container_of(_req, struct dummy_request, req);\r\n}\r\nstatic inline struct dummy_hcd *hcd_to_dummy_hcd(struct usb_hcd *hcd)\r\n{\r\nreturn (struct dummy_hcd *) (hcd->hcd_priv);\r\n}\r\nstatic inline struct usb_hcd *dummy_hcd_to_hcd(struct dummy_hcd *dum)\r\n{\r\nreturn container_of((void *) dum, struct usb_hcd, hcd_priv);\r\n}\r\nstatic inline struct device *dummy_dev(struct dummy_hcd *dum)\r\n{\r\nreturn dummy_hcd_to_hcd(dum)->self.controller;\r\n}\r\nstatic inline struct device *udc_dev(struct dummy *dum)\r\n{\r\nreturn dum->gadget.dev.parent;\r\n}\r\nstatic inline struct dummy *ep_to_dummy(struct dummy_ep *ep)\r\n{\r\nreturn container_of(ep->gadget, struct dummy, gadget);\r\n}\r\nstatic inline struct dummy_hcd *gadget_to_dummy_hcd(struct usb_gadget *gadget)\r\n{\r\nstruct dummy *dum = container_of(gadget, struct dummy, gadget);\r\nif (dum->gadget.speed == USB_SPEED_SUPER)\r\nreturn dum->ss_hcd;\r\nelse\r\nreturn dum->hs_hcd;\r\n}\r\nstatic inline struct dummy *gadget_dev_to_dummy(struct device *dev)\r\n{\r\nreturn container_of(dev, struct dummy, gadget.dev);\r\n}\r\nstatic void nuke(struct dummy *dum, struct dummy_ep *ep)\r\n{\r\nwhile (!list_empty(&ep->queue)) {\r\nstruct dummy_request *req;\r\nreq = list_entry(ep->queue.next, struct dummy_request, queue);\r\nlist_del_init(&req->queue);\r\nreq->req.status = -ESHUTDOWN;\r\nspin_unlock(&dum->lock);\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&dum->lock);\r\n}\r\n}\r\nstatic void stop_activity(struct dummy *dum)\r\n{\r\nstruct dummy_ep *ep;\r\ndum->address = 0;\r\nlist_for_each_entry(ep, &dum->gadget.ep_list, ep.ep_list)\r\nnuke(dum, ep);\r\n}\r\nstatic void set_link_state_by_speed(struct dummy_hcd *dum_hcd)\r\n{\r\nstruct dummy *dum = dum_hcd->dum;\r\nif (dummy_hcd_to_hcd(dum_hcd)->speed == HCD_USB3) {\r\nif ((dum_hcd->port_status & USB_SS_PORT_STAT_POWER) == 0) {\r\ndum_hcd->port_status = 0;\r\n} else if (!dum->pullup || dum->udc_suspended) {\r\ndum_hcd->port_status &= ~(USB_PORT_STAT_CONNECTION |\r\nUSB_PORT_STAT_ENABLE);\r\nif ((dum_hcd->old_status &\r\nUSB_PORT_STAT_CONNECTION) != 0)\r\ndum_hcd->port_status |=\r\n(USB_PORT_STAT_C_CONNECTION << 16);\r\n} else {\r\ndum_hcd->port_status |= (USB_PORT_STAT_CONNECTION |\r\nUSB_PORT_STAT_SPEED_5GBPS) ;\r\nif ((dum_hcd->old_status &\r\nUSB_PORT_STAT_CONNECTION) == 0)\r\ndum_hcd->port_status |=\r\n(USB_PORT_STAT_C_CONNECTION << 16);\r\nif ((dum_hcd->port_status &\r\nUSB_PORT_STAT_ENABLE) == 1 &&\r\n(dum_hcd->port_status &\r\nUSB_SS_PORT_LS_U0) == 1 &&\r\ndum_hcd->rh_state != DUMMY_RH_SUSPENDED)\r\ndum_hcd->active = 1;\r\n}\r\n} else {\r\nif ((dum_hcd->port_status & USB_PORT_STAT_POWER) == 0) {\r\ndum_hcd->port_status = 0;\r\n} else if (!dum->pullup || dum->udc_suspended) {\r\ndum_hcd->port_status &= ~(USB_PORT_STAT_CONNECTION |\r\nUSB_PORT_STAT_ENABLE |\r\nUSB_PORT_STAT_LOW_SPEED |\r\nUSB_PORT_STAT_HIGH_SPEED |\r\nUSB_PORT_STAT_SUSPEND);\r\nif ((dum_hcd->old_status &\r\nUSB_PORT_STAT_CONNECTION) != 0)\r\ndum_hcd->port_status |=\r\n(USB_PORT_STAT_C_CONNECTION << 16);\r\n} else {\r\ndum_hcd->port_status |= USB_PORT_STAT_CONNECTION;\r\nif ((dum_hcd->old_status &\r\nUSB_PORT_STAT_CONNECTION) == 0)\r\ndum_hcd->port_status |=\r\n(USB_PORT_STAT_C_CONNECTION << 16);\r\nif ((dum_hcd->port_status & USB_PORT_STAT_ENABLE) == 0)\r\ndum_hcd->port_status &= ~USB_PORT_STAT_SUSPEND;\r\nelse if ((dum_hcd->port_status &\r\nUSB_PORT_STAT_SUSPEND) == 0 &&\r\ndum_hcd->rh_state != DUMMY_RH_SUSPENDED)\r\ndum_hcd->active = 1;\r\n}\r\n}\r\n}\r\nstatic void set_link_state(struct dummy_hcd *dum_hcd)\r\n{\r\nstruct dummy *dum = dum_hcd->dum;\r\ndum_hcd->active = 0;\r\nif (dum->pullup)\r\nif ((dummy_hcd_to_hcd(dum_hcd)->speed == HCD_USB3 &&\r\ndum->gadget.speed != USB_SPEED_SUPER) ||\r\n(dummy_hcd_to_hcd(dum_hcd)->speed != HCD_USB3 &&\r\ndum->gadget.speed == USB_SPEED_SUPER))\r\nreturn;\r\nset_link_state_by_speed(dum_hcd);\r\nif ((dum_hcd->port_status & USB_PORT_STAT_ENABLE) == 0 ||\r\ndum_hcd->active)\r\ndum_hcd->resuming = 0;\r\nif ((dum_hcd->port_status & USB_PORT_STAT_CONNECTION) == 0 ||\r\n(dum_hcd->port_status & USB_PORT_STAT_RESET) != 0) {\r\nif ((dum_hcd->old_status & USB_PORT_STAT_CONNECTION) != 0 &&\r\n(dum_hcd->old_status & USB_PORT_STAT_RESET) == 0 &&\r\ndum->driver) {\r\nstop_activity(dum);\r\nspin_unlock(&dum->lock);\r\ndum->driver->disconnect(&dum->gadget);\r\nspin_lock(&dum->lock);\r\n}\r\n} else if (dum_hcd->active != dum_hcd->old_active) {\r\nif (dum_hcd->old_active && dum->driver->suspend) {\r\nspin_unlock(&dum->lock);\r\ndum->driver->suspend(&dum->gadget);\r\nspin_lock(&dum->lock);\r\n} else if (!dum_hcd->old_active && dum->driver->resume) {\r\nspin_unlock(&dum->lock);\r\ndum->driver->resume(&dum->gadget);\r\nspin_lock(&dum->lock);\r\n}\r\n}\r\ndum_hcd->old_status = dum_hcd->port_status;\r\ndum_hcd->old_active = dum_hcd->active;\r\n}\r\nstatic int dummy_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct dummy *dum;\r\nstruct dummy_hcd *dum_hcd;\r\nstruct dummy_ep *ep;\r\nunsigned max;\r\nint retval;\r\nep = usb_ep_to_dummy_ep(_ep);\r\nif (!_ep || !desc || ep->desc || _ep->name == ep0name\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT)\r\nreturn -EINVAL;\r\ndum = ep_to_dummy(ep);\r\nif (!dum->driver)\r\nreturn -ESHUTDOWN;\r\ndum_hcd = gadget_to_dummy_hcd(&dum->gadget);\r\nif (!is_enabled(dum_hcd))\r\nreturn -ESHUTDOWN;\r\nmax = usb_endpoint_maxp(desc) & 0x7ff;\r\nretval = -EINVAL;\r\nswitch (usb_endpoint_type(desc)) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (strstr(ep->ep.name, "-iso")\r\n|| strstr(ep->ep.name, "-int")) {\r\ngoto done;\r\n}\r\nswitch (dum->gadget.speed) {\r\ncase USB_SPEED_SUPER:\r\nif (max == 1024)\r\nbreak;\r\ngoto done;\r\ncase USB_SPEED_HIGH:\r\nif (max == 512)\r\nbreak;\r\ngoto done;\r\ncase USB_SPEED_FULL:\r\nif (max == 8 || max == 16 || max == 32 || max == 64)\r\nbreak;\r\ndefault:\r\ngoto done;\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (strstr(ep->ep.name, "-iso"))\r\ngoto done;\r\nswitch (dum->gadget.speed) {\r\ncase USB_SPEED_SUPER:\r\ncase USB_SPEED_HIGH:\r\nif (max <= 1024)\r\nbreak;\r\ncase USB_SPEED_FULL:\r\nif (max <= 64)\r\nbreak;\r\ndefault:\r\nif (max <= 8)\r\nbreak;\r\ngoto done;\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (strstr(ep->ep.name, "-bulk")\r\n|| strstr(ep->ep.name, "-int"))\r\ngoto done;\r\nswitch (dum->gadget.speed) {\r\ncase USB_SPEED_SUPER:\r\ncase USB_SPEED_HIGH:\r\nif (max <= 1024)\r\nbreak;\r\ncase USB_SPEED_FULL:\r\nif (max <= 1023)\r\nbreak;\r\ndefault:\r\ngoto done;\r\n}\r\nbreak;\r\ndefault:\r\ngoto done;\r\n}\r\n_ep->maxpacket = max;\r\nif (usb_ss_max_streams(_ep->comp_desc)) {\r\nif (!usb_endpoint_xfer_bulk(desc)) {\r\ndev_err(udc_dev(dum), "Can't enable stream support on "\r\n"non-bulk ep %s\n", _ep->name);\r\nreturn -EINVAL;\r\n}\r\nep->stream_en = 1;\r\n}\r\nep->desc = desc;\r\ndev_dbg(udc_dev(dum), "enabled %s (ep%d%s-%s) maxpacket %d stream %s\n",\r\n_ep->name,\r\ndesc->bEndpointAddress & 0x0f,\r\n(desc->bEndpointAddress & USB_DIR_IN) ? "in" : "out",\r\n({ char *val;\r\nswitch (usb_endpoint_type(desc)) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nval = "bulk";\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nval = "iso";\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nval = "intr";\r\nbreak;\r\ndefault:\r\nval = "ctrl";\r\nbreak;\r\n} val; }),\r\nmax, ep->stream_en ? "enabled" : "disabled");\r\nep->halted = ep->wedged = 0;\r\nretval = 0;\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int dummy_disable(struct usb_ep *_ep)\r\n{\r\nstruct dummy_ep *ep;\r\nstruct dummy *dum;\r\nunsigned long flags;\r\nint retval;\r\nep = usb_ep_to_dummy_ep(_ep);\r\nif (!_ep || !ep->desc || _ep->name == ep0name)\r\nreturn -EINVAL;\r\ndum = ep_to_dummy(ep);\r\nspin_lock_irqsave(&dum->lock, flags);\r\nep->desc = NULL;\r\nep->stream_en = 0;\r\nretval = 0;\r\nnuke(dum, ep);\r\nspin_unlock_irqrestore(&dum->lock, flags);\r\ndev_dbg(udc_dev(dum), "disabled %s\n", _ep->name);\r\nreturn retval;\r\n}\r\nstatic struct usb_request *dummy_alloc_request(struct usb_ep *_ep,\r\ngfp_t mem_flags)\r\n{\r\nstruct dummy_ep *ep;\r\nstruct dummy_request *req;\r\nif (!_ep)\r\nreturn NULL;\r\nep = usb_ep_to_dummy_ep(_ep);\r\nreq = kzalloc(sizeof(*req), mem_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void dummy_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct dummy_request *req;\r\nif (!_ep || !_req) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nreq = usb_request_to_dummy_request(_req);\r\nWARN_ON(!list_empty(&req->queue));\r\nkfree(req);\r\n}\r\nstatic void fifo_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\n}\r\nstatic int dummy_queue(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t mem_flags)\r\n{\r\nstruct dummy_ep *ep;\r\nstruct dummy_request *req;\r\nstruct dummy *dum;\r\nstruct dummy_hcd *dum_hcd;\r\nunsigned long flags;\r\nreq = usb_request_to_dummy_request(_req);\r\nif (!_req || !list_empty(&req->queue) || !_req->complete)\r\nreturn -EINVAL;\r\nep = usb_ep_to_dummy_ep(_ep);\r\nif (!_ep || (!ep->desc && _ep->name != ep0name))\r\nreturn -EINVAL;\r\ndum = ep_to_dummy(ep);\r\ndum_hcd = gadget_to_dummy_hcd(&dum->gadget);\r\nif (!dum->driver || !is_enabled(dum_hcd))\r\nreturn -ESHUTDOWN;\r\n#if 0\r\ndev_dbg(udc_dev(dum), "ep %p queue req %p to %s, len %d buf %p\n",\r\nep, _req, _ep->name, _req->length, _req->buf);\r\n#endif\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nspin_lock_irqsave(&dum->lock, flags);\r\nif (ep->desc && (ep->desc->bEndpointAddress & USB_DIR_IN) &&\r\nlist_empty(&dum->fifo_req.queue) &&\r\nlist_empty(&ep->queue) &&\r\n_req->length <= FIFO_SIZE) {\r\nreq = &dum->fifo_req;\r\nreq->req = *_req;\r\nreq->req.buf = dum->fifo_buf;\r\nmemcpy(dum->fifo_buf, _req->buf, _req->length);\r\nreq->req.context = dum;\r\nreq->req.complete = fifo_complete;\r\nlist_add_tail(&req->queue, &ep->queue);\r\nspin_unlock(&dum->lock);\r\n_req->actual = _req->length;\r\n_req->status = 0;\r\n_req->complete(_ep, _req);\r\nspin_lock(&dum->lock);\r\n} else\r\nlist_add_tail(&req->queue, &ep->queue);\r\nspin_unlock_irqrestore(&dum->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dummy_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct dummy_ep *ep;\r\nstruct dummy *dum;\r\nint retval = -EINVAL;\r\nunsigned long flags;\r\nstruct dummy_request *req = NULL;\r\nif (!_ep || !_req)\r\nreturn retval;\r\nep = usb_ep_to_dummy_ep(_ep);\r\ndum = ep_to_dummy(ep);\r\nif (!dum->driver)\r\nreturn -ESHUTDOWN;\r\nlocal_irq_save(flags);\r\nspin_lock(&dum->lock);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == _req) {\r\nlist_del_init(&req->queue);\r\n_req->status = -ECONNRESET;\r\nretval = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&dum->lock);\r\nif (retval == 0) {\r\ndev_dbg(udc_dev(dum),\r\n"dequeued req %p from %s, len %d buf %p\n",\r\nreq, _ep->name, _req->length, _req->buf);\r\n_req->complete(_ep, _req);\r\n}\r\nlocal_irq_restore(flags);\r\nreturn retval;\r\n}\r\nstatic int\r\ndummy_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedged)\r\n{\r\nstruct dummy_ep *ep;\r\nstruct dummy *dum;\r\nif (!_ep)\r\nreturn -EINVAL;\r\nep = usb_ep_to_dummy_ep(_ep);\r\ndum = ep_to_dummy(ep);\r\nif (!dum->driver)\r\nreturn -ESHUTDOWN;\r\nif (!value)\r\nep->halted = ep->wedged = 0;\r\nelse if (ep->desc && (ep->desc->bEndpointAddress & USB_DIR_IN) &&\r\n!list_empty(&ep->queue))\r\nreturn -EAGAIN;\r\nelse {\r\nep->halted = 1;\r\nif (wedged)\r\nep->wedged = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndummy_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nreturn dummy_set_halt_and_wedge(_ep, value, 0);\r\n}\r\nstatic int dummy_set_wedge(struct usb_ep *_ep)\r\n{\r\nif (!_ep || _ep->name == ep0name)\r\nreturn -EINVAL;\r\nreturn dummy_set_halt_and_wedge(_ep, 1, 1);\r\n}\r\nstatic int dummy_g_get_frame(struct usb_gadget *_gadget)\r\n{\r\nstruct timeval tv;\r\ndo_gettimeofday(&tv);\r\nreturn tv.tv_usec / 1000;\r\n}\r\nstatic int dummy_wakeup(struct usb_gadget *_gadget)\r\n{\r\nstruct dummy_hcd *dum_hcd;\r\ndum_hcd = gadget_to_dummy_hcd(_gadget);\r\nif (!(dum_hcd->dum->devstatus & ((1 << USB_DEVICE_B_HNP_ENABLE)\r\n| (1 << USB_DEVICE_REMOTE_WAKEUP))))\r\nreturn -EINVAL;\r\nif ((dum_hcd->port_status & USB_PORT_STAT_CONNECTION) == 0)\r\nreturn -ENOLINK;\r\nif ((dum_hcd->port_status & USB_PORT_STAT_SUSPEND) == 0 &&\r\ndum_hcd->rh_state != DUMMY_RH_SUSPENDED)\r\nreturn -EIO;\r\ndum_hcd->resuming = 1;\r\ndum_hcd->re_timeout = jiffies + msecs_to_jiffies(20);\r\nmod_timer(&dummy_hcd_to_hcd(dum_hcd)->rh_timer, dum_hcd->re_timeout);\r\nreturn 0;\r\n}\r\nstatic int dummy_set_selfpowered(struct usb_gadget *_gadget, int value)\r\n{\r\nstruct dummy *dum;\r\ndum = gadget_to_dummy_hcd(_gadget)->dum;\r\nif (value)\r\ndum->devstatus |= (1 << USB_DEVICE_SELF_POWERED);\r\nelse\r\ndum->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);\r\nreturn 0;\r\n}\r\nstatic void dummy_udc_update_ep0(struct dummy *dum)\r\n{\r\nif (dum->gadget.speed == USB_SPEED_SUPER)\r\ndum->ep[0].ep.maxpacket = 9;\r\nelse\r\ndum->ep[0].ep.maxpacket = 64;\r\n}\r\nstatic int dummy_pullup(struct usb_gadget *_gadget, int value)\r\n{\r\nstruct dummy_hcd *dum_hcd;\r\nstruct dummy *dum;\r\nunsigned long flags;\r\ndum = gadget_dev_to_dummy(&_gadget->dev);\r\nif (value && dum->driver) {\r\nif (mod_data.is_super_speed)\r\ndum->gadget.speed = dum->driver->max_speed;\r\nelse if (mod_data.is_high_speed)\r\ndum->gadget.speed = min_t(u8, USB_SPEED_HIGH,\r\ndum->driver->max_speed);\r\nelse\r\ndum->gadget.speed = USB_SPEED_FULL;\r\ndummy_udc_update_ep0(dum);\r\nif (dum->gadget.speed < dum->driver->max_speed)\r\ndev_dbg(udc_dev(dum), "This device can perform faster"\r\n" if you connect it to a %s port...\n",\r\nusb_speed_string(dum->driver->max_speed));\r\n}\r\ndum_hcd = gadget_to_dummy_hcd(_gadget);\r\nspin_lock_irqsave(&dum->lock, flags);\r\ndum->pullup = (value != 0);\r\nset_link_state(dum_hcd);\r\nspin_unlock_irqrestore(&dum->lock, flags);\r\nusb_hcd_poll_rh_status(dummy_hcd_to_hcd(dum_hcd));\r\nreturn 0;\r\n}\r\nstatic ssize_t function_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dummy *dum = gadget_dev_to_dummy(dev);\r\nif (!dum->driver || !dum->driver->function)\r\nreturn 0;\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", dum->driver->function);\r\n}\r\nstatic int dummy_udc_start(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct dummy_hcd *dum_hcd = gadget_to_dummy_hcd(g);\r\nstruct dummy *dum = dum_hcd->dum;\r\nif (driver->max_speed == USB_SPEED_UNKNOWN)\r\nreturn -EINVAL;\r\ndum->devstatus = 0;\r\ndum->driver = driver;\r\ndev_dbg(udc_dev(dum), "binding gadget driver '%s'\n",\r\ndriver->driver.name);\r\nreturn 0;\r\n}\r\nstatic int dummy_udc_stop(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct dummy_hcd *dum_hcd = gadget_to_dummy_hcd(g);\r\nstruct dummy *dum = dum_hcd->dum;\r\nif (driver)\r\ndev_dbg(udc_dev(dum), "unregister gadget driver '%s'\n",\r\ndriver->driver.name);\r\ndum->driver = NULL;\r\nreturn 0;\r\n}\r\nstatic void init_dummy_udc_hw(struct dummy *dum)\r\n{\r\nint i;\r\nINIT_LIST_HEAD(&dum->gadget.ep_list);\r\nfor (i = 0; i < DUMMY_ENDPOINTS; i++) {\r\nstruct dummy_ep *ep = &dum->ep[i];\r\nif (!ep_name[i])\r\nbreak;\r\nep->ep.name = ep_name[i];\r\nep->ep.ops = &dummy_ep_ops;\r\nlist_add_tail(&ep->ep.ep_list, &dum->gadget.ep_list);\r\nep->halted = ep->wedged = ep->already_seen =\r\nep->setup_stage = 0;\r\nusb_ep_set_maxpacket_limit(&ep->ep, ~0);\r\nep->ep.max_streams = 16;\r\nep->last_io = jiffies;\r\nep->gadget = &dum->gadget;\r\nep->desc = NULL;\r\nINIT_LIST_HEAD(&ep->queue);\r\n}\r\ndum->gadget.ep0 = &dum->ep[0].ep;\r\nlist_del_init(&dum->ep[0].ep.ep_list);\r\nINIT_LIST_HEAD(&dum->fifo_req.queue);\r\n#ifdef CONFIG_USB_OTG\r\ndum->gadget.is_otg = 1;\r\n#endif\r\n}\r\nstatic int dummy_udc_probe(struct platform_device *pdev)\r\n{\r\nstruct dummy *dum;\r\nint rc;\r\ndum = *((void **)dev_get_platdata(&pdev->dev));\r\ndum->gadget.name = gadget_name;\r\ndum->gadget.ops = &dummy_ops;\r\ndum->gadget.max_speed = USB_SPEED_SUPER;\r\ndum->gadget.dev.parent = &pdev->dev;\r\ninit_dummy_udc_hw(dum);\r\nrc = usb_add_gadget_udc(&pdev->dev, &dum->gadget);\r\nif (rc < 0)\r\ngoto err_udc;\r\nrc = device_create_file(&dum->gadget.dev, &dev_attr_function);\r\nif (rc < 0)\r\ngoto err_dev;\r\nplatform_set_drvdata(pdev, dum);\r\nreturn rc;\r\nerr_dev:\r\nusb_del_gadget_udc(&dum->gadget);\r\nerr_udc:\r\nreturn rc;\r\n}\r\nstatic int dummy_udc_remove(struct platform_device *pdev)\r\n{\r\nstruct dummy *dum = platform_get_drvdata(pdev);\r\ndevice_remove_file(&dum->gadget.dev, &dev_attr_function);\r\nusb_del_gadget_udc(&dum->gadget);\r\nreturn 0;\r\n}\r\nstatic void dummy_udc_pm(struct dummy *dum, struct dummy_hcd *dum_hcd,\r\nint suspend)\r\n{\r\nspin_lock_irq(&dum->lock);\r\ndum->udc_suspended = suspend;\r\nset_link_state(dum_hcd);\r\nspin_unlock_irq(&dum->lock);\r\n}\r\nstatic int dummy_udc_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct dummy *dum = platform_get_drvdata(pdev);\r\nstruct dummy_hcd *dum_hcd = gadget_to_dummy_hcd(&dum->gadget);\r\ndev_dbg(&pdev->dev, "%s\n", __func__);\r\ndummy_udc_pm(dum, dum_hcd, 1);\r\nusb_hcd_poll_rh_status(dummy_hcd_to_hcd(dum_hcd));\r\nreturn 0;\r\n}\r\nstatic int dummy_udc_resume(struct platform_device *pdev)\r\n{\r\nstruct dummy *dum = platform_get_drvdata(pdev);\r\nstruct dummy_hcd *dum_hcd = gadget_to_dummy_hcd(&dum->gadget);\r\ndev_dbg(&pdev->dev, "%s\n", __func__);\r\ndummy_udc_pm(dum, dum_hcd, 0);\r\nusb_hcd_poll_rh_status(dummy_hcd_to_hcd(dum_hcd));\r\nreturn 0;\r\n}\r\nstatic unsigned int dummy_get_ep_idx(const struct usb_endpoint_descriptor *desc)\r\n{\r\nunsigned int index;\r\nindex = usb_endpoint_num(desc) << 1;\r\nif (usb_endpoint_dir_in(desc))\r\nindex |= 1;\r\nreturn index;\r\n}\r\nstatic int dummy_ep_stream_en(struct dummy_hcd *dum_hcd, struct urb *urb)\r\n{\r\nconst struct usb_endpoint_descriptor *desc = &urb->ep->desc;\r\nu32 index;\r\nif (!usb_endpoint_xfer_bulk(desc))\r\nreturn 0;\r\nindex = dummy_get_ep_idx(desc);\r\nreturn (1 << index) & dum_hcd->stream_en_ep;\r\n}\r\nstatic int get_max_streams_for_pipe(struct dummy_hcd *dum_hcd,\r\nunsigned int pipe)\r\n{\r\nint max_streams;\r\nmax_streams = dum_hcd->num_stream[usb_pipeendpoint(pipe)];\r\nif (usb_pipeout(pipe))\r\nmax_streams >>= 4;\r\nelse\r\nmax_streams &= 0xf;\r\nmax_streams++;\r\nreturn max_streams;\r\n}\r\nstatic void set_max_streams_for_pipe(struct dummy_hcd *dum_hcd,\r\nunsigned int pipe, unsigned int streams)\r\n{\r\nint max_streams;\r\nstreams--;\r\nmax_streams = dum_hcd->num_stream[usb_pipeendpoint(pipe)];\r\nif (usb_pipeout(pipe)) {\r\nstreams <<= 4;\r\nmax_streams &= 0xf;\r\n} else {\r\nmax_streams &= 0xf0;\r\n}\r\nmax_streams |= streams;\r\ndum_hcd->num_stream[usb_pipeendpoint(pipe)] = max_streams;\r\n}\r\nstatic int dummy_validate_stream(struct dummy_hcd *dum_hcd, struct urb *urb)\r\n{\r\nunsigned int max_streams;\r\nint enabled;\r\nenabled = dummy_ep_stream_en(dum_hcd, urb);\r\nif (!urb->stream_id) {\r\nif (enabled)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nif (!enabled)\r\nreturn -EINVAL;\r\nmax_streams = get_max_streams_for_pipe(dum_hcd,\r\nusb_pipeendpoint(urb->pipe));\r\nif (urb->stream_id > max_streams) {\r\ndev_err(dummy_dev(dum_hcd), "Stream id %d is out of range.\n",\r\nurb->stream_id);\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dummy_urb_enqueue(\r\nstruct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mem_flags\r\n) {\r\nstruct dummy_hcd *dum_hcd;\r\nstruct urbp *urbp;\r\nunsigned long flags;\r\nint rc;\r\nurbp = kmalloc(sizeof *urbp, mem_flags);\r\nif (!urbp)\r\nreturn -ENOMEM;\r\nurbp->urb = urb;\r\nurbp->miter_started = 0;\r\ndum_hcd = hcd_to_dummy_hcd(hcd);\r\nspin_lock_irqsave(&dum_hcd->dum->lock, flags);\r\nrc = dummy_validate_stream(dum_hcd, urb);\r\nif (rc) {\r\nkfree(urbp);\r\ngoto done;\r\n}\r\nrc = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (rc) {\r\nkfree(urbp);\r\ngoto done;\r\n}\r\nif (!dum_hcd->udev) {\r\ndum_hcd->udev = urb->dev;\r\nusb_get_dev(dum_hcd->udev);\r\n} else if (unlikely(dum_hcd->udev != urb->dev))\r\ndev_err(dummy_dev(dum_hcd), "usb_device address has changed!\n");\r\nlist_add_tail(&urbp->urbp_list, &dum_hcd->urbp_list);\r\nurb->hcpriv = urbp;\r\nif (usb_pipetype(urb->pipe) == PIPE_CONTROL)\r\nurb->error_count = 1;\r\nif (!timer_pending(&dum_hcd->timer))\r\nmod_timer(&dum_hcd->timer, jiffies + 1);\r\ndone:\r\nspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int dummy_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct dummy_hcd *dum_hcd;\r\nunsigned long flags;\r\nint rc;\r\ndum_hcd = hcd_to_dummy_hcd(hcd);\r\nspin_lock_irqsave(&dum_hcd->dum->lock, flags);\r\nrc = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (!rc && dum_hcd->rh_state != DUMMY_RH_RUNNING &&\r\n!list_empty(&dum_hcd->urbp_list))\r\nmod_timer(&dum_hcd->timer, jiffies);\r\nspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int dummy_perform_transfer(struct urb *urb, struct dummy_request *req,\r\nu32 len)\r\n{\r\nvoid *ubuf, *rbuf;\r\nstruct urbp *urbp = urb->hcpriv;\r\nint to_host;\r\nstruct sg_mapping_iter *miter = &urbp->miter;\r\nu32 trans = 0;\r\nu32 this_sg;\r\nbool next_sg;\r\nto_host = usb_pipein(urb->pipe);\r\nrbuf = req->req.buf + req->req.actual;\r\nif (!urb->num_sgs) {\r\nubuf = urb->transfer_buffer + urb->actual_length;\r\nif (to_host)\r\nmemcpy(ubuf, rbuf, len);\r\nelse\r\nmemcpy(rbuf, ubuf, len);\r\nreturn len;\r\n}\r\nif (!urbp->miter_started) {\r\nu32 flags = SG_MITER_ATOMIC;\r\nif (to_host)\r\nflags |= SG_MITER_TO_SG;\r\nelse\r\nflags |= SG_MITER_FROM_SG;\r\nsg_miter_start(miter, urb->sg, urb->num_sgs, flags);\r\nurbp->miter_started = 1;\r\n}\r\nnext_sg = sg_miter_next(miter);\r\nif (next_sg == false) {\r\nWARN_ON_ONCE(1);\r\nreturn -EINVAL;\r\n}\r\ndo {\r\nubuf = miter->addr;\r\nthis_sg = min_t(u32, len, miter->length);\r\nmiter->consumed = this_sg;\r\ntrans += this_sg;\r\nif (to_host)\r\nmemcpy(ubuf, rbuf, this_sg);\r\nelse\r\nmemcpy(rbuf, ubuf, this_sg);\r\nlen -= this_sg;\r\nif (!len)\r\nbreak;\r\nnext_sg = sg_miter_next(miter);\r\nif (next_sg == false) {\r\nWARN_ON_ONCE(1);\r\nreturn -EINVAL;\r\n}\r\nrbuf += this_sg;\r\n} while (1);\r\nsg_miter_stop(miter);\r\nreturn trans;\r\n}\r\nstatic int transfer(struct dummy_hcd *dum_hcd, struct urb *urb,\r\nstruct dummy_ep *ep, int limit, int *status)\r\n{\r\nstruct dummy *dum = dum_hcd->dum;\r\nstruct dummy_request *req;\r\ntop:\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nunsigned host_len, dev_len, len;\r\nint is_short, to_host;\r\nint rescan = 0;\r\nif (dummy_ep_stream_en(dum_hcd, urb)) {\r\nif ((urb->stream_id != req->req.stream_id))\r\ncontinue;\r\n}\r\nhost_len = urb->transfer_buffer_length - urb->actual_length;\r\ndev_len = req->req.length - req->req.actual;\r\nlen = min(host_len, dev_len);\r\nto_host = usb_pipein(urb->pipe);\r\nif (unlikely(len == 0))\r\nis_short = 1;\r\nelse {\r\nif (limit < ep->ep.maxpacket && limit < len)\r\nbreak;\r\nlen = min_t(unsigned, len, limit);\r\nif (len == 0)\r\nbreak;\r\nif (len > ep->ep.maxpacket) {\r\nrescan = 1;\r\nlen -= (len % ep->ep.maxpacket);\r\n}\r\nis_short = (len % ep->ep.maxpacket) != 0;\r\nlen = dummy_perform_transfer(urb, req, len);\r\nep->last_io = jiffies;\r\nif ((int)len < 0) {\r\nreq->req.status = len;\r\n} else {\r\nlimit -= len;\r\nurb->actual_length += len;\r\nreq->req.actual += len;\r\n}\r\n}\r\nif (is_short) {\r\nif (host_len == dev_len) {\r\nreq->req.status = 0;\r\n*status = 0;\r\n} else if (to_host) {\r\nreq->req.status = 0;\r\nif (dev_len > host_len)\r\n*status = -EOVERFLOW;\r\nelse\r\n*status = 0;\r\n} else if (!to_host) {\r\n*status = 0;\r\nif (host_len > dev_len)\r\nreq->req.status = -EOVERFLOW;\r\nelse\r\nreq->req.status = 0;\r\n}\r\n} else {\r\nif (req->req.length == req->req.actual\r\n&& !req->req.zero)\r\nreq->req.status = 0;\r\nif (urb->transfer_buffer_length == urb->actual_length\r\n&& !(urb->transfer_flags\r\n& URB_ZERO_PACKET))\r\n*status = 0;\r\n}\r\nif (req->req.status != -EINPROGRESS) {\r\nlist_del_init(&req->queue);\r\nspin_unlock(&dum->lock);\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&dum->lock);\r\nrescan = 1;\r\n}\r\nif (*status != -EINPROGRESS)\r\nbreak;\r\nif (rescan)\r\ngoto top;\r\n}\r\nreturn limit;\r\n}\r\nstatic int periodic_bytes(struct dummy *dum, struct dummy_ep *ep)\r\n{\r\nint limit = ep->ep.maxpacket;\r\nif (dum->gadget.speed == USB_SPEED_HIGH) {\r\nint tmp;\r\ntmp = usb_endpoint_maxp(ep->desc);\r\ntmp = (tmp >> 11) & 0x03;\r\ntmp *= 8 ;\r\nlimit += limit * tmp;\r\n}\r\nif (dum->gadget.speed == USB_SPEED_SUPER) {\r\nswitch (usb_endpoint_type(ep->desc)) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nlimit = 3 * 16 * 1024 * 8;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nlimit = 3 * 1024 * 8;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn limit;\r\n}\r\nstatic struct dummy_ep *find_endpoint(struct dummy *dum, u8 address)\r\n{\r\nint i;\r\nif (!is_active((dum->gadget.speed == USB_SPEED_SUPER ?\r\ndum->ss_hcd : dum->hs_hcd)))\r\nreturn NULL;\r\nif ((address & ~USB_DIR_IN) == 0)\r\nreturn &dum->ep[0];\r\nfor (i = 1; i < DUMMY_ENDPOINTS; i++) {\r\nstruct dummy_ep *ep = &dum->ep[i];\r\nif (!ep->desc)\r\ncontinue;\r\nif (ep->desc->bEndpointAddress == address)\r\nreturn ep;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int handle_control_request(struct dummy_hcd *dum_hcd, struct urb *urb,\r\nstruct usb_ctrlrequest *setup,\r\nint *status)\r\n{\r\nstruct dummy_ep *ep2;\r\nstruct dummy *dum = dum_hcd->dum;\r\nint ret_val = 1;\r\nunsigned w_index;\r\nunsigned w_value;\r\nw_index = le16_to_cpu(setup->wIndex);\r\nw_value = le16_to_cpu(setup->wValue);\r\nswitch (setup->bRequest) {\r\ncase USB_REQ_SET_ADDRESS:\r\nif (setup->bRequestType != Dev_Request)\r\nbreak;\r\ndum->address = w_value;\r\n*status = 0;\r\ndev_dbg(udc_dev(dum), "set_address = %d\n",\r\nw_value);\r\nret_val = 0;\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nif (setup->bRequestType == Dev_Request) {\r\nret_val = 0;\r\nswitch (w_value) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\nbreak;\r\ncase USB_DEVICE_B_HNP_ENABLE:\r\ndum->gadget.b_hnp_enable = 1;\r\nbreak;\r\ncase USB_DEVICE_A_HNP_SUPPORT:\r\ndum->gadget.a_hnp_support = 1;\r\nbreak;\r\ncase USB_DEVICE_A_ALT_HNP_SUPPORT:\r\ndum->gadget.a_alt_hnp_support = 1;\r\nbreak;\r\ncase USB_DEVICE_U1_ENABLE:\r\nif (dummy_hcd_to_hcd(dum_hcd)->speed ==\r\nHCD_USB3)\r\nw_value = USB_DEV_STAT_U1_ENABLED;\r\nelse\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\ncase USB_DEVICE_U2_ENABLE:\r\nif (dummy_hcd_to_hcd(dum_hcd)->speed ==\r\nHCD_USB3)\r\nw_value = USB_DEV_STAT_U2_ENABLED;\r\nelse\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\ncase USB_DEVICE_LTM_ENABLE:\r\nif (dummy_hcd_to_hcd(dum_hcd)->speed ==\r\nHCD_USB3)\r\nw_value = USB_DEV_STAT_LTM_ENABLED;\r\nelse\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\ndefault:\r\nret_val = -EOPNOTSUPP;\r\n}\r\nif (ret_val == 0) {\r\ndum->devstatus |= (1 << w_value);\r\n*status = 0;\r\n}\r\n} else if (setup->bRequestType == Ep_Request) {\r\nep2 = find_endpoint(dum, w_index);\r\nif (!ep2 || ep2->ep.name == ep0name) {\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nep2->halted = 1;\r\nret_val = 0;\r\n*status = 0;\r\n}\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nif (setup->bRequestType == Dev_Request) {\r\nret_val = 0;\r\nswitch (w_value) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\nw_value = USB_DEVICE_REMOTE_WAKEUP;\r\nbreak;\r\ncase USB_DEVICE_U1_ENABLE:\r\nif (dummy_hcd_to_hcd(dum_hcd)->speed ==\r\nHCD_USB3)\r\nw_value = USB_DEV_STAT_U1_ENABLED;\r\nelse\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\ncase USB_DEVICE_U2_ENABLE:\r\nif (dummy_hcd_to_hcd(dum_hcd)->speed ==\r\nHCD_USB3)\r\nw_value = USB_DEV_STAT_U2_ENABLED;\r\nelse\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\ncase USB_DEVICE_LTM_ENABLE:\r\nif (dummy_hcd_to_hcd(dum_hcd)->speed ==\r\nHCD_USB3)\r\nw_value = USB_DEV_STAT_LTM_ENABLED;\r\nelse\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\ndefault:\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (ret_val == 0) {\r\ndum->devstatus &= ~(1 << w_value);\r\n*status = 0;\r\n}\r\n} else if (setup->bRequestType == Ep_Request) {\r\nep2 = find_endpoint(dum, w_index);\r\nif (!ep2) {\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (!ep2->wedged)\r\nep2->halted = 0;\r\nret_val = 0;\r\n*status = 0;\r\n}\r\nbreak;\r\ncase USB_REQ_GET_STATUS:\r\nif (setup->bRequestType == Dev_InRequest\r\n|| setup->bRequestType == Intf_InRequest\r\n|| setup->bRequestType == Ep_InRequest) {\r\nchar *buf;\r\nbuf = (char *)urb->transfer_buffer;\r\nif (urb->transfer_buffer_length > 0) {\r\nif (setup->bRequestType == Ep_InRequest) {\r\nep2 = find_endpoint(dum, w_index);\r\nif (!ep2) {\r\nret_val = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nbuf[0] = ep2->halted;\r\n} else if (setup->bRequestType ==\r\nDev_InRequest) {\r\nbuf[0] = (u8)dum->devstatus;\r\n} else\r\nbuf[0] = 0;\r\n}\r\nif (urb->transfer_buffer_length > 1)\r\nbuf[1] = 0;\r\nurb->actual_length = min_t(u32, 2,\r\nurb->transfer_buffer_length);\r\nret_val = 0;\r\n*status = 0;\r\n}\r\nbreak;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic void dummy_timer(unsigned long _dum_hcd)\r\n{\r\nstruct dummy_hcd *dum_hcd = (struct dummy_hcd *) _dum_hcd;\r\nstruct dummy *dum = dum_hcd->dum;\r\nstruct urbp *urbp, *tmp;\r\nunsigned long flags;\r\nint limit, total;\r\nint i;\r\nswitch (dum->gadget.speed) {\r\ncase USB_SPEED_LOW:\r\ntotal = 8 * 12;\r\nbreak;\r\ncase USB_SPEED_FULL:\r\ntotal = 64 * 19;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ntotal = 512 * 13 * 8;\r\nbreak;\r\ncase USB_SPEED_SUPER:\r\ntotal = 490000;\r\nbreak;\r\ndefault:\r\ndev_err(dummy_dev(dum_hcd), "bogus device speed\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&dum->lock, flags);\r\nif (!dum_hcd->udev) {\r\ndev_err(dummy_dev(dum_hcd),\r\n"timer fired with no URBs pending?\n");\r\nspin_unlock_irqrestore(&dum->lock, flags);\r\nreturn;\r\n}\r\nfor (i = 0; i < DUMMY_ENDPOINTS; i++) {\r\nif (!ep_name[i])\r\nbreak;\r\ndum->ep[i].already_seen = 0;\r\n}\r\nrestart:\r\nlist_for_each_entry_safe(urbp, tmp, &dum_hcd->urbp_list, urbp_list) {\r\nstruct urb *urb;\r\nstruct dummy_request *req;\r\nu8 address;\r\nstruct dummy_ep *ep = NULL;\r\nint type;\r\nint status = -EINPROGRESS;\r\nurb = urbp->urb;\r\nif (urb->unlinked)\r\ngoto return_urb;\r\nelse if (dum_hcd->rh_state != DUMMY_RH_RUNNING)\r\ncontinue;\r\ntype = usb_pipetype(urb->pipe);\r\nif (total <= 0 && type == PIPE_BULK)\r\ncontinue;\r\naddress = usb_pipeendpoint (urb->pipe);\r\nif (usb_pipein(urb->pipe))\r\naddress |= USB_DIR_IN;\r\nep = find_endpoint(dum, address);\r\nif (!ep) {\r\ndev_dbg(dummy_dev(dum_hcd),\r\n"no ep configured for urb %p\n",\r\nurb);\r\nstatus = -EPROTO;\r\ngoto return_urb;\r\n}\r\nif (ep->already_seen)\r\ncontinue;\r\nep->already_seen = 1;\r\nif (ep == &dum->ep[0] && urb->error_count) {\r\nep->setup_stage = 1;\r\nurb->error_count = 0;\r\n}\r\nif (ep->halted && !ep->setup_stage) {\r\ndev_dbg(dummy_dev(dum_hcd), "ep %s halted, urb %p\n",\r\nep->ep.name, urb);\r\nstatus = -EPIPE;\r\ngoto return_urb;\r\n}\r\nif (ep == &dum->ep[0] && ep->setup_stage) {\r\nstruct usb_ctrlrequest setup;\r\nint value = 1;\r\nsetup = *(struct usb_ctrlrequest *) urb->setup_packet;\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nlist_del_init(&req->queue);\r\nreq->req.status = -EOVERFLOW;\r\ndev_dbg(udc_dev(dum), "stale req = %p\n",\r\nreq);\r\nspin_unlock(&dum->lock);\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&dum->lock);\r\nep->already_seen = 0;\r\ngoto restart;\r\n}\r\nep->last_io = jiffies;\r\nep->setup_stage = 0;\r\nep->halted = 0;\r\nvalue = handle_control_request(dum_hcd, urb, &setup,\r\n&status);\r\nif (value > 0) {\r\nspin_unlock(&dum->lock);\r\nvalue = dum->driver->setup(&dum->gadget,\r\n&setup);\r\nspin_lock(&dum->lock);\r\nif (value >= 0) {\r\nlimit = 64*1024;\r\ngoto treat_control_like_bulk;\r\n}\r\n}\r\nif (value < 0) {\r\nif (value != -EOPNOTSUPP)\r\ndev_dbg(udc_dev(dum),\r\n"setup --> %d\n",\r\nvalue);\r\nstatus = -EPIPE;\r\nurb->actual_length = 0;\r\n}\r\ngoto return_urb;\r\n}\r\nlimit = total;\r\nswitch (usb_pipetype(urb->pipe)) {\r\ncase PIPE_ISOCHRONOUS:\r\nlimit = max(limit, periodic_bytes(dum, ep));\r\nstatus = -ENOSYS;\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\nlimit = max(limit, periodic_bytes(dum, ep));\r\ndefault:\r\ntreat_control_like_bulk:\r\nep->last_io = jiffies;\r\ntotal = transfer(dum_hcd, urb, ep, limit, &status);\r\nbreak;\r\n}\r\nif (status == -EINPROGRESS)\r\ncontinue;\r\nreturn_urb:\r\nlist_del(&urbp->urbp_list);\r\nkfree(urbp);\r\nif (ep)\r\nep->already_seen = ep->setup_stage = 0;\r\nusb_hcd_unlink_urb_from_ep(dummy_hcd_to_hcd(dum_hcd), urb);\r\nspin_unlock(&dum->lock);\r\nusb_hcd_giveback_urb(dummy_hcd_to_hcd(dum_hcd), urb, status);\r\nspin_lock(&dum->lock);\r\ngoto restart;\r\n}\r\nif (list_empty(&dum_hcd->urbp_list)) {\r\nusb_put_dev(dum_hcd->udev);\r\ndum_hcd->udev = NULL;\r\n} else if (dum_hcd->rh_state == DUMMY_RH_RUNNING) {\r\nmod_timer(&dum_hcd->timer, jiffies + msecs_to_jiffies(1));\r\n}\r\nspin_unlock_irqrestore(&dum->lock, flags);\r\n}\r\nstatic int dummy_hub_status(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct dummy_hcd *dum_hcd;\r\nunsigned long flags;\r\nint retval = 0;\r\ndum_hcd = hcd_to_dummy_hcd(hcd);\r\nspin_lock_irqsave(&dum_hcd->dum->lock, flags);\r\nif (!HCD_HW_ACCESSIBLE(hcd))\r\ngoto done;\r\nif (dum_hcd->resuming && time_after_eq(jiffies, dum_hcd->re_timeout)) {\r\ndum_hcd->port_status |= (USB_PORT_STAT_C_SUSPEND << 16);\r\ndum_hcd->port_status &= ~USB_PORT_STAT_SUSPEND;\r\nset_link_state(dum_hcd);\r\n}\r\nif ((dum_hcd->port_status & PORT_C_MASK) != 0) {\r\n*buf = (1 << 1);\r\ndev_dbg(dummy_dev(dum_hcd), "port status 0x%08x has changes\n",\r\ndum_hcd->port_status);\r\nretval = 1;\r\nif (dum_hcd->rh_state == DUMMY_RH_SUSPENDED)\r\nusb_hcd_resume_root_hub(hcd);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\r\nreturn retval;\r\n}\r\nstatic inline void\r\nss_hub_descriptor(struct usb_hub_descriptor *desc)\r\n{\r\nmemset(desc, 0, sizeof *desc);\r\ndesc->bDescriptorType = 0x2a;\r\ndesc->bDescLength = 12;\r\ndesc->wHubCharacteristics = cpu_to_le16(0x0001);\r\ndesc->bNbrPorts = 1;\r\ndesc->u.ss.bHubHdrDecLat = 0x04;\r\ndesc->u.ss.DeviceRemovable = 0xffff;\r\n}\r\nstatic inline void hub_descriptor(struct usb_hub_descriptor *desc)\r\n{\r\nmemset(desc, 0, sizeof *desc);\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bDescLength = 9;\r\ndesc->wHubCharacteristics = cpu_to_le16(0x0001);\r\ndesc->bNbrPorts = 1;\r\ndesc->u.hs.DeviceRemovable[0] = 0xff;\r\ndesc->u.hs.DeviceRemovable[1] = 0xff;\r\n}\r\nstatic int dummy_hub_control(\r\nstruct usb_hcd *hcd,\r\nu16 typeReq,\r\nu16 wValue,\r\nu16 wIndex,\r\nchar *buf,\r\nu16 wLength\r\n) {\r\nstruct dummy_hcd *dum_hcd;\r\nint retval = 0;\r\nunsigned long flags;\r\nif (!HCD_HW_ACCESSIBLE(hcd))\r\nreturn -ETIMEDOUT;\r\ndum_hcd = hcd_to_dummy_hcd(hcd);\r\nspin_lock_irqsave(&dum_hcd->dum->lock, flags);\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\nbreak;\r\ncase ClearPortFeature:\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (hcd->speed == HCD_USB3) {\r\ndev_dbg(dummy_dev(dum_hcd),\r\n"USB_PORT_FEAT_SUSPEND req not "\r\n"supported for USB 3.0 roothub\n");\r\ngoto error;\r\n}\r\nif (dum_hcd->port_status & USB_PORT_STAT_SUSPEND) {\r\ndum_hcd->resuming = 1;\r\ndum_hcd->re_timeout = jiffies +\r\nmsecs_to_jiffies(20);\r\n}\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nif (hcd->speed == HCD_USB3) {\r\nif (dum_hcd->port_status & USB_PORT_STAT_POWER)\r\ndev_dbg(dummy_dev(dum_hcd),\r\n"power-off\n");\r\n} else\r\nif (dum_hcd->port_status &\r\nUSB_SS_PORT_STAT_POWER)\r\ndev_dbg(dummy_dev(dum_hcd),\r\n"power-off\n");\r\ndefault:\r\ndum_hcd->port_status &= ~(1 << wValue);\r\nset_link_state(dum_hcd);\r\n}\r\nbreak;\r\ncase GetHubDescriptor:\r\nif (hcd->speed == HCD_USB3 &&\r\n(wLength < USB_DT_SS_HUB_SIZE ||\r\nwValue != (USB_DT_SS_HUB << 8))) {\r\ndev_dbg(dummy_dev(dum_hcd),\r\n"Wrong hub descriptor type for "\r\n"USB 3.0 roothub.\n");\r\ngoto error;\r\n}\r\nif (hcd->speed == HCD_USB3)\r\nss_hub_descriptor((struct usb_hub_descriptor *) buf);\r\nelse\r\nhub_descriptor((struct usb_hub_descriptor *) buf);\r\nbreak;\r\ncase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\r\nif (hcd->speed != HCD_USB3)\r\ngoto error;\r\nif ((wValue >> 8) != USB_DT_BOS)\r\ngoto error;\r\nmemcpy(buf, &usb3_bos_desc, sizeof(usb3_bos_desc));\r\nretval = sizeof(usb3_bos_desc);\r\nbreak;\r\ncase GetHubStatus:\r\n*(__le32 *) buf = cpu_to_le32(0);\r\nbreak;\r\ncase GetPortStatus:\r\nif (wIndex != 1)\r\nretval = -EPIPE;\r\nif (dum_hcd->resuming &&\r\ntime_after_eq(jiffies, dum_hcd->re_timeout)) {\r\ndum_hcd->port_status |= (USB_PORT_STAT_C_SUSPEND << 16);\r\ndum_hcd->port_status &= ~USB_PORT_STAT_SUSPEND;\r\n}\r\nif ((dum_hcd->port_status & USB_PORT_STAT_RESET) != 0 &&\r\ntime_after_eq(jiffies, dum_hcd->re_timeout)) {\r\ndum_hcd->port_status |= (USB_PORT_STAT_C_RESET << 16);\r\ndum_hcd->port_status &= ~USB_PORT_STAT_RESET;\r\nif (dum_hcd->dum->pullup) {\r\ndum_hcd->port_status |= USB_PORT_STAT_ENABLE;\r\nif (hcd->speed < HCD_USB3) {\r\nswitch (dum_hcd->dum->gadget.speed) {\r\ncase USB_SPEED_HIGH:\r\ndum_hcd->port_status |=\r\nUSB_PORT_STAT_HIGH_SPEED;\r\nbreak;\r\ncase USB_SPEED_LOW:\r\ndum_hcd->dum->gadget.ep0->\r\nmaxpacket = 8;\r\ndum_hcd->port_status |=\r\nUSB_PORT_STAT_LOW_SPEED;\r\nbreak;\r\ndefault:\r\ndum_hcd->dum->gadget.speed =\r\nUSB_SPEED_FULL;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nset_link_state(dum_hcd);\r\n((__le16 *) buf)[0] = cpu_to_le16(dum_hcd->port_status);\r\n((__le16 *) buf)[1] = cpu_to_le16(dum_hcd->port_status >> 16);\r\nbreak;\r\ncase SetHubFeature:\r\nretval = -EPIPE;\r\nbreak;\r\ncase SetPortFeature:\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_LINK_STATE:\r\nif (hcd->speed != HCD_USB3) {\r\ndev_dbg(dummy_dev(dum_hcd),\r\n"USB_PORT_FEAT_LINK_STATE req not "\r\n"supported for USB 2.0 roothub\n");\r\ngoto error;\r\n}\r\nbreak;\r\ncase USB_PORT_FEAT_U1_TIMEOUT:\r\ncase USB_PORT_FEAT_U2_TIMEOUT:\r\nif (hcd->speed != HCD_USB3) {\r\ndev_dbg(dummy_dev(dum_hcd),\r\n"USB_PORT_FEAT_U1/2_TIMEOUT req not "\r\n"supported for USB 2.0 roothub\n");\r\ngoto error;\r\n}\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (hcd->speed == HCD_USB3) {\r\ndev_dbg(dummy_dev(dum_hcd),\r\n"USB_PORT_FEAT_SUSPEND req not "\r\n"supported for USB 3.0 roothub\n");\r\ngoto error;\r\n}\r\nif (dum_hcd->active) {\r\ndum_hcd->port_status |= USB_PORT_STAT_SUSPEND;\r\nset_link_state(dum_hcd);\r\nif (((1 << USB_DEVICE_B_HNP_ENABLE)\r\n& dum_hcd->dum->devstatus) != 0)\r\ndev_dbg(dummy_dev(dum_hcd),\r\n"no HNP yet!\n");\r\n}\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nif (hcd->speed == HCD_USB3)\r\ndum_hcd->port_status |= USB_SS_PORT_STAT_POWER;\r\nelse\r\ndum_hcd->port_status |= USB_PORT_STAT_POWER;\r\nset_link_state(dum_hcd);\r\nbreak;\r\ncase USB_PORT_FEAT_BH_PORT_RESET:\r\nif (hcd->speed != HCD_USB3) {\r\ndev_dbg(dummy_dev(dum_hcd),\r\n"USB_PORT_FEAT_BH_PORT_RESET req not "\r\n"supported for USB 2.0 roothub\n");\r\ngoto error;\r\n}\r\ncase USB_PORT_FEAT_RESET:\r\nif (hcd->speed == HCD_USB3) {\r\ndum_hcd->port_status = 0;\r\ndum_hcd->port_status =\r\n(USB_SS_PORT_STAT_POWER |\r\nUSB_PORT_STAT_CONNECTION |\r\nUSB_PORT_STAT_RESET);\r\n} else\r\ndum_hcd->port_status &= ~(USB_PORT_STAT_ENABLE\r\n| USB_PORT_STAT_LOW_SPEED\r\n| USB_PORT_STAT_HIGH_SPEED);\r\ndum_hcd->dum->devstatus &=\r\n(1 << USB_DEVICE_SELF_POWERED);\r\ndum_hcd->re_timeout = jiffies + msecs_to_jiffies(50);\r\ndefault:\r\nif (hcd->speed == HCD_USB3) {\r\nif ((dum_hcd->port_status &\r\nUSB_SS_PORT_STAT_POWER) != 0) {\r\ndum_hcd->port_status |= (1 << wValue);\r\nset_link_state(dum_hcd);\r\n}\r\n} else\r\nif ((dum_hcd->port_status &\r\nUSB_PORT_STAT_POWER) != 0) {\r\ndum_hcd->port_status |= (1 << wValue);\r\nset_link_state(dum_hcd);\r\n}\r\n}\r\nbreak;\r\ncase GetPortErrorCount:\r\nif (hcd->speed != HCD_USB3) {\r\ndev_dbg(dummy_dev(dum_hcd),\r\n"GetPortErrorCount req not "\r\n"supported for USB 2.0 roothub\n");\r\ngoto error;\r\n}\r\n*(__le32 *) buf = cpu_to_le32(0);\r\nbreak;\r\ncase SetHubDepth:\r\nif (hcd->speed != HCD_USB3) {\r\ndev_dbg(dummy_dev(dum_hcd),\r\n"SetHubDepth req not supported for "\r\n"USB 2.0 roothub\n");\r\ngoto error;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(dummy_dev(dum_hcd),\r\n"hub control req%04x v%04x i%04x l%d\n",\r\ntypeReq, wValue, wIndex, wLength);\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\r\nif ((dum_hcd->port_status & PORT_C_MASK) != 0)\r\nusb_hcd_poll_rh_status(hcd);\r\nreturn retval;\r\n}\r\nstatic int dummy_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nstruct dummy_hcd *dum_hcd = hcd_to_dummy_hcd(hcd);\r\ndev_dbg(&hcd->self.root_hub->dev, "%s\n", __func__);\r\nspin_lock_irq(&dum_hcd->dum->lock);\r\ndum_hcd->rh_state = DUMMY_RH_SUSPENDED;\r\nset_link_state(dum_hcd);\r\nhcd->state = HC_STATE_SUSPENDED;\r\nspin_unlock_irq(&dum_hcd->dum->lock);\r\nreturn 0;\r\n}\r\nstatic int dummy_bus_resume(struct usb_hcd *hcd)\r\n{\r\nstruct dummy_hcd *dum_hcd = hcd_to_dummy_hcd(hcd);\r\nint rc = 0;\r\ndev_dbg(&hcd->self.root_hub->dev, "%s\n", __func__);\r\nspin_lock_irq(&dum_hcd->dum->lock);\r\nif (!HCD_HW_ACCESSIBLE(hcd)) {\r\nrc = -ESHUTDOWN;\r\n} else {\r\ndum_hcd->rh_state = DUMMY_RH_RUNNING;\r\nset_link_state(dum_hcd);\r\nif (!list_empty(&dum_hcd->urbp_list))\r\nmod_timer(&dum_hcd->timer, jiffies);\r\nhcd->state = HC_STATE_RUNNING;\r\n}\r\nspin_unlock_irq(&dum_hcd->dum->lock);\r\nreturn rc;\r\n}\r\nstatic inline ssize_t show_urb(char *buf, size_t size, struct urb *urb)\r\n{\r\nint ep = usb_pipeendpoint(urb->pipe);\r\nreturn snprintf(buf, size,\r\n"urb/%p %s ep%d%s%s len %d/%d\n",\r\nurb,\r\n({ char *s;\r\nswitch (urb->dev->speed) {\r\ncase USB_SPEED_LOW:\r\ns = "ls";\r\nbreak;\r\ncase USB_SPEED_FULL:\r\ns = "fs";\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ns = "hs";\r\nbreak;\r\ncase USB_SPEED_SUPER:\r\ns = "ss";\r\nbreak;\r\ndefault:\r\ns = "?";\r\nbreak;\r\n} s; }),\r\nep, ep ? (usb_pipein(urb->pipe) ? "in" : "out") : "",\r\n({ char *s; \\r\nswitch (usb_pipetype(urb->pipe)) { \\r\ncase PIPE_CONTROL: \\r\ns = ""; \\r\nbreak; \\r\ncase PIPE_BULK: \\r\ns = "-bulk"; \\r\nbreak; \\r\ncase PIPE_INTERRUPT: \\r\ns = "-int"; \\r\nbreak; \\r\ndefault: \\r\ns = "-iso"; \\r\nbreak; \\r\n} s; }),\r\nurb->actual_length, urb->transfer_buffer_length);\r\n}\r\nstatic ssize_t urbs_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct dummy_hcd *dum_hcd = hcd_to_dummy_hcd(hcd);\r\nstruct urbp *urbp;\r\nsize_t size = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dum_hcd->dum->lock, flags);\r\nlist_for_each_entry(urbp, &dum_hcd->urbp_list, urbp_list) {\r\nsize_t temp;\r\ntemp = show_urb(buf, PAGE_SIZE - size, urbp->urb);\r\nbuf += temp;\r\nsize += temp;\r\n}\r\nspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\r\nreturn size;\r\n}\r\nstatic int dummy_start_ss(struct dummy_hcd *dum_hcd)\r\n{\r\ninit_timer(&dum_hcd->timer);\r\ndum_hcd->timer.function = dummy_timer;\r\ndum_hcd->timer.data = (unsigned long)dum_hcd;\r\ndum_hcd->rh_state = DUMMY_RH_RUNNING;\r\ndum_hcd->stream_en_ep = 0;\r\nINIT_LIST_HEAD(&dum_hcd->urbp_list);\r\ndummy_hcd_to_hcd(dum_hcd)->power_budget = POWER_BUDGET;\r\ndummy_hcd_to_hcd(dum_hcd)->state = HC_STATE_RUNNING;\r\ndummy_hcd_to_hcd(dum_hcd)->uses_new_polling = 1;\r\n#ifdef CONFIG_USB_OTG\r\ndummy_hcd_to_hcd(dum_hcd)->self.otg_port = 1;\r\n#endif\r\nreturn 0;\r\nreturn device_create_file(dummy_dev(dum_hcd), &dev_attr_urbs);\r\n}\r\nstatic int dummy_start(struct usb_hcd *hcd)\r\n{\r\nstruct dummy_hcd *dum_hcd = hcd_to_dummy_hcd(hcd);\r\nif (!usb_hcd_is_primary_hcd(hcd))\r\nreturn dummy_start_ss(dum_hcd);\r\nspin_lock_init(&dum_hcd->dum->lock);\r\ninit_timer(&dum_hcd->timer);\r\ndum_hcd->timer.function = dummy_timer;\r\ndum_hcd->timer.data = (unsigned long)dum_hcd;\r\ndum_hcd->rh_state = DUMMY_RH_RUNNING;\r\nINIT_LIST_HEAD(&dum_hcd->urbp_list);\r\nhcd->power_budget = POWER_BUDGET;\r\nhcd->state = HC_STATE_RUNNING;\r\nhcd->uses_new_polling = 1;\r\n#ifdef CONFIG_USB_OTG\r\nhcd->self.otg_port = 1;\r\n#endif\r\nreturn device_create_file(dummy_dev(dum_hcd), &dev_attr_urbs);\r\n}\r\nstatic void dummy_stop(struct usb_hcd *hcd)\r\n{\r\nstruct dummy *dum;\r\ndum = hcd_to_dummy_hcd(hcd)->dum;\r\ndevice_remove_file(dummy_dev(hcd_to_dummy_hcd(hcd)), &dev_attr_urbs);\r\nusb_gadget_unregister_driver(dum->driver);\r\ndev_info(dummy_dev(hcd_to_dummy_hcd(hcd)), "stopped\n");\r\n}\r\nstatic int dummy_h_get_frame(struct usb_hcd *hcd)\r\n{\r\nreturn dummy_g_get_frame(NULL);\r\n}\r\nstatic int dummy_setup(struct usb_hcd *hcd)\r\n{\r\nstruct dummy *dum;\r\ndum = *((void **)dev_get_platdata(hcd->self.controller));\r\nhcd->self.sg_tablesize = ~0;\r\nif (usb_hcd_is_primary_hcd(hcd)) {\r\ndum->hs_hcd = hcd_to_dummy_hcd(hcd);\r\ndum->hs_hcd->dum = dum;\r\nhcd->speed = HCD_USB2;\r\nhcd->self.root_hub->speed = USB_SPEED_HIGH;\r\n} else {\r\ndum->ss_hcd = hcd_to_dummy_hcd(hcd);\r\ndum->ss_hcd->dum = dum;\r\nhcd->speed = HCD_USB3;\r\nhcd->self.root_hub->speed = USB_SPEED_SUPER;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dummy_alloc_streams(struct usb_hcd *hcd, struct usb_device *udev,\r\nstruct usb_host_endpoint **eps, unsigned int num_eps,\r\nunsigned int num_streams, gfp_t mem_flags)\r\n{\r\nstruct dummy_hcd *dum_hcd = hcd_to_dummy_hcd(hcd);\r\nunsigned long flags;\r\nint max_stream;\r\nint ret_streams = num_streams;\r\nunsigned int index;\r\nunsigned int i;\r\nif (!num_eps)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&dum_hcd->dum->lock, flags);\r\nfor (i = 0; i < num_eps; i++) {\r\nindex = dummy_get_ep_idx(&eps[i]->desc);\r\nif ((1 << index) & dum_hcd->stream_en_ep) {\r\nret_streams = -EINVAL;\r\ngoto out;\r\n}\r\nmax_stream = usb_ss_max_streams(&eps[i]->ss_ep_comp);\r\nif (!max_stream) {\r\nret_streams = -EINVAL;\r\ngoto out;\r\n}\r\nif (max_stream < ret_streams) {\r\ndev_dbg(dummy_dev(dum_hcd), "Ep 0x%x only supports %u "\r\n"stream IDs.\n",\r\neps[i]->desc.bEndpointAddress,\r\nmax_stream);\r\nret_streams = max_stream;\r\n}\r\n}\r\nfor (i = 0; i < num_eps; i++) {\r\nindex = dummy_get_ep_idx(&eps[i]->desc);\r\ndum_hcd->stream_en_ep |= 1 << index;\r\nset_max_streams_for_pipe(dum_hcd,\r\nusb_endpoint_num(&eps[i]->desc), ret_streams);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\r\nreturn ret_streams;\r\n}\r\nstatic int dummy_free_streams(struct usb_hcd *hcd, struct usb_device *udev,\r\nstruct usb_host_endpoint **eps, unsigned int num_eps,\r\ngfp_t mem_flags)\r\n{\r\nstruct dummy_hcd *dum_hcd = hcd_to_dummy_hcd(hcd);\r\nunsigned long flags;\r\nint ret;\r\nunsigned int index;\r\nunsigned int i;\r\nspin_lock_irqsave(&dum_hcd->dum->lock, flags);\r\nfor (i = 0; i < num_eps; i++) {\r\nindex = dummy_get_ep_idx(&eps[i]->desc);\r\nif (!((1 << index) & dum_hcd->stream_en_ep)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < num_eps; i++) {\r\nindex = dummy_get_ep_idx(&eps[i]->desc);\r\ndum_hcd->stream_en_ep &= ~(1 << index);\r\nset_max_streams_for_pipe(dum_hcd,\r\nusb_endpoint_num(&eps[i]->desc), 0);\r\n}\r\nret = 0;\r\nout:\r\nspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int dummy_hcd_probe(struct platform_device *pdev)\r\n{\r\nstruct dummy *dum;\r\nstruct usb_hcd *hs_hcd;\r\nstruct usb_hcd *ss_hcd;\r\nint retval;\r\ndev_info(&pdev->dev, "%s, driver " DRIVER_VERSION "\n", driver_desc);\r\ndum = *((void **)dev_get_platdata(&pdev->dev));\r\nif (!mod_data.is_super_speed)\r\ndummy_hcd.flags = HCD_USB2;\r\nhs_hcd = usb_create_hcd(&dummy_hcd, &pdev->dev, dev_name(&pdev->dev));\r\nif (!hs_hcd)\r\nreturn -ENOMEM;\r\nhs_hcd->has_tt = 1;\r\nretval = usb_add_hcd(hs_hcd, 0, 0);\r\nif (retval)\r\ngoto put_usb2_hcd;\r\nif (mod_data.is_super_speed) {\r\nss_hcd = usb_create_shared_hcd(&dummy_hcd, &pdev->dev,\r\ndev_name(&pdev->dev), hs_hcd);\r\nif (!ss_hcd) {\r\nretval = -ENOMEM;\r\ngoto dealloc_usb2_hcd;\r\n}\r\nretval = usb_add_hcd(ss_hcd, 0, 0);\r\nif (retval)\r\ngoto put_usb3_hcd;\r\n}\r\nreturn 0;\r\nput_usb3_hcd:\r\nusb_put_hcd(ss_hcd);\r\ndealloc_usb2_hcd:\r\nusb_remove_hcd(hs_hcd);\r\nput_usb2_hcd:\r\nusb_put_hcd(hs_hcd);\r\ndum->hs_hcd = dum->ss_hcd = NULL;\r\nreturn retval;\r\n}\r\nstatic int dummy_hcd_remove(struct platform_device *pdev)\r\n{\r\nstruct dummy *dum;\r\ndum = hcd_to_dummy_hcd(platform_get_drvdata(pdev))->dum;\r\nif (dum->ss_hcd) {\r\nusb_remove_hcd(dummy_hcd_to_hcd(dum->ss_hcd));\r\nusb_put_hcd(dummy_hcd_to_hcd(dum->ss_hcd));\r\n}\r\nusb_remove_hcd(dummy_hcd_to_hcd(dum->hs_hcd));\r\nusb_put_hcd(dummy_hcd_to_hcd(dum->hs_hcd));\r\ndum->hs_hcd = NULL;\r\ndum->ss_hcd = NULL;\r\nreturn 0;\r\n}\r\nstatic int dummy_hcd_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct dummy_hcd *dum_hcd;\r\nint rc = 0;\r\ndev_dbg(&pdev->dev, "%s\n", __func__);\r\nhcd = platform_get_drvdata(pdev);\r\ndum_hcd = hcd_to_dummy_hcd(hcd);\r\nif (dum_hcd->rh_state == DUMMY_RH_RUNNING) {\r\ndev_warn(&pdev->dev, "Root hub isn't suspended!\n");\r\nrc = -EBUSY;\r\n} else\r\nclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nreturn rc;\r\n}\r\nstatic int dummy_hcd_resume(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd;\r\ndev_dbg(&pdev->dev, "%s\n", __func__);\r\nhcd = platform_get_drvdata(pdev);\r\nset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nusb_hcd_poll_rh_status(hcd);\r\nreturn 0;\r\n}\r\nstatic int __init init(void)\r\n{\r\nint retval = -ENOMEM;\r\nint i;\r\nstruct dummy *dum[MAX_NUM_UDC];\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nif (!mod_data.is_high_speed && mod_data.is_super_speed)\r\nreturn -EINVAL;\r\nif (mod_data.num < 1 || mod_data.num > MAX_NUM_UDC) {\r\npr_err("Number of emulated UDC must be in range of 1ÃƒÂ¢Ã‚&#8364;Ã‚Â¦%d\n",\r\nMAX_NUM_UDC);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < mod_data.num; i++) {\r\nthe_hcd_pdev[i] = platform_device_alloc(driver_name, i);\r\nif (!the_hcd_pdev[i]) {\r\ni--;\r\nwhile (i >= 0)\r\nplatform_device_put(the_hcd_pdev[i--]);\r\nreturn retval;\r\n}\r\n}\r\nfor (i = 0; i < mod_data.num; i++) {\r\nthe_udc_pdev[i] = platform_device_alloc(gadget_name, i);\r\nif (!the_udc_pdev[i]) {\r\ni--;\r\nwhile (i >= 0)\r\nplatform_device_put(the_udc_pdev[i--]);\r\ngoto err_alloc_udc;\r\n}\r\n}\r\nfor (i = 0; i < mod_data.num; i++) {\r\ndum[i] = kzalloc(sizeof(struct dummy), GFP_KERNEL);\r\nif (!dum[i]) {\r\nretval = -ENOMEM;\r\ngoto err_add_pdata;\r\n}\r\nretval = platform_device_add_data(the_hcd_pdev[i], &dum[i],\r\nsizeof(void *));\r\nif (retval)\r\ngoto err_add_pdata;\r\nretval = platform_device_add_data(the_udc_pdev[i], &dum[i],\r\nsizeof(void *));\r\nif (retval)\r\ngoto err_add_pdata;\r\n}\r\nretval = platform_driver_register(&dummy_hcd_driver);\r\nif (retval < 0)\r\ngoto err_add_pdata;\r\nretval = platform_driver_register(&dummy_udc_driver);\r\nif (retval < 0)\r\ngoto err_register_udc_driver;\r\nfor (i = 0; i < mod_data.num; i++) {\r\nretval = platform_device_add(the_hcd_pdev[i]);\r\nif (retval < 0) {\r\ni--;\r\nwhile (i >= 0)\r\nplatform_device_del(the_hcd_pdev[i--]);\r\ngoto err_add_hcd;\r\n}\r\n}\r\nfor (i = 0; i < mod_data.num; i++) {\r\nif (!dum[i]->hs_hcd ||\r\n(!dum[i]->ss_hcd && mod_data.is_super_speed)) {\r\nretval = -EINVAL;\r\ngoto err_add_udc;\r\n}\r\n}\r\nfor (i = 0; i < mod_data.num; i++) {\r\nretval = platform_device_add(the_udc_pdev[i]);\r\nif (retval < 0) {\r\ni--;\r\nwhile (i >= 0)\r\nplatform_device_del(the_udc_pdev[i]);\r\ngoto err_add_udc;\r\n}\r\n}\r\nfor (i = 0; i < mod_data.num; i++) {\r\nif (!platform_get_drvdata(the_udc_pdev[i])) {\r\nretval = -EINVAL;\r\ngoto err_probe_udc;\r\n}\r\n}\r\nreturn retval;\r\nerr_probe_udc:\r\nfor (i = 0; i < mod_data.num; i++)\r\nplatform_device_del(the_udc_pdev[i]);\r\nerr_add_udc:\r\nfor (i = 0; i < mod_data.num; i++)\r\nplatform_device_del(the_hcd_pdev[i]);\r\nerr_add_hcd:\r\nplatform_driver_unregister(&dummy_udc_driver);\r\nerr_register_udc_driver:\r\nplatform_driver_unregister(&dummy_hcd_driver);\r\nerr_add_pdata:\r\nfor (i = 0; i < mod_data.num; i++)\r\nkfree(dum[i]);\r\nfor (i = 0; i < mod_data.num; i++)\r\nplatform_device_put(the_udc_pdev[i]);\r\nerr_alloc_udc:\r\nfor (i = 0; i < mod_data.num; i++)\r\nplatform_device_put(the_hcd_pdev[i]);\r\nreturn retval;\r\n}\r\nstatic void __exit cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < mod_data.num; i++) {\r\nstruct dummy *dum;\r\ndum = *((void **)dev_get_platdata(&the_udc_pdev[i]->dev));\r\nplatform_device_unregister(the_udc_pdev[i]);\r\nplatform_device_unregister(the_hcd_pdev[i]);\r\nkfree(dum);\r\n}\r\nplatform_driver_unregister(&dummy_udc_driver);\r\nplatform_driver_unregister(&dummy_hcd_driver);\r\n}
