int afs_mntpt_check_symlink(struct afs_vnode *vnode, struct key *key)\r\n{\r\nstruct page *page;\r\nsize_t size;\r\nchar *buf;\r\nint ret;\r\n_enter("{%x:%u,%u}",\r\nvnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\r\npage = read_cache_page(AFS_VNODE_TO_I(vnode)->i_mapping, 0,\r\nafs_page_filler, key);\r\nif (IS_ERR(page)) {\r\nret = PTR_ERR(page);\r\ngoto out;\r\n}\r\nret = -EIO;\r\nif (PageError(page))\r\ngoto out_free;\r\nbuf = kmap(page);\r\nsize = vnode->status.size;\r\n_debug("symlink to %*.*s", (int) size, (int) size, buf);\r\nif (size > 2 &&\r\n(buf[0] == '%' || buf[0] == '#') &&\r\nbuf[size - 1] == '.'\r\n) {\r\n_debug("symlink is a mountpoint");\r\nspin_lock(&vnode->lock);\r\nset_bit(AFS_VNODE_MOUNTPOINT, &vnode->flags);\r\nvnode->vfs_inode.i_flags |= S_AUTOMOUNT;\r\nspin_unlock(&vnode->lock);\r\n}\r\nret = 0;\r\nkunmap(page);\r\nout_free:\r\npage_cache_release(page);\r\nout:\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic struct dentry *afs_mntpt_lookup(struct inode *dir,\r\nstruct dentry *dentry,\r\nunsigned int flags)\r\n{\r\n_enter("%p,%p{%p{%s},%s}",\r\ndir,\r\ndentry,\r\ndentry->d_parent,\r\ndentry->d_parent ?\r\ndentry->d_parent->d_name.name : (const unsigned char *) "",\r\ndentry->d_name.name);\r\nreturn ERR_PTR(-EREMOTE);\r\n}\r\nstatic int afs_mntpt_open(struct inode *inode, struct file *file)\r\n{\r\n_enter("%p,%p{%p{%s},%s}",\r\ninode, file,\r\nfile->f_path.dentry->d_parent,\r\nfile->f_path.dentry->d_parent ?\r\nfile->f_path.dentry->d_parent->d_name.name :\r\n(const unsigned char *) "",\r\nfile->f_path.dentry->d_name.name);\r\nreturn -EREMOTE;\r\n}\r\nstatic struct vfsmount *afs_mntpt_do_automount(struct dentry *mntpt)\r\n{\r\nstruct afs_super_info *super;\r\nstruct vfsmount *mnt;\r\nstruct afs_vnode *vnode;\r\nstruct page *page;\r\nchar *devname, *options;\r\nbool rwpath = false;\r\nint ret;\r\n_enter("{%s}", mntpt->d_name.name);\r\nBUG_ON(!mntpt->d_inode);\r\nret = -ENOMEM;\r\ndevname = (char *) get_zeroed_page(GFP_KERNEL);\r\nif (!devname)\r\ngoto error_no_devname;\r\noptions = (char *) get_zeroed_page(GFP_KERNEL);\r\nif (!options)\r\ngoto error_no_options;\r\nvnode = AFS_FS_I(mntpt->d_inode);\r\nif (test_bit(AFS_VNODE_PSEUDODIR, &vnode->flags)) {\r\nstatic const char afs_root_cell[] = ":root.cell.";\r\nunsigned size = mntpt->d_name.len;\r\nret = -ENOENT;\r\nif (size < 2 || size > AFS_MAXCELLNAME)\r\ngoto error_no_page;\r\nif (mntpt->d_name.name[0] == '.') {\r\ndevname[0] = '#';\r\nmemcpy(devname + 1, mntpt->d_name.name, size - 1);\r\nmemcpy(devname + size, afs_root_cell,\r\nsizeof(afs_root_cell));\r\nrwpath = true;\r\n} else {\r\ndevname[0] = '%';\r\nmemcpy(devname + 1, mntpt->d_name.name, size);\r\nmemcpy(devname + size + 1, afs_root_cell,\r\nsizeof(afs_root_cell));\r\n}\r\n} else {\r\nloff_t size = i_size_read(mntpt->d_inode);\r\nchar *buf;\r\nret = -EINVAL;\r\nif (size > PAGE_SIZE - 1)\r\ngoto error_no_page;\r\npage = read_mapping_page(mntpt->d_inode->i_mapping, 0, NULL);\r\nif (IS_ERR(page)) {\r\nret = PTR_ERR(page);\r\ngoto error_no_page;\r\n}\r\nret = -EIO;\r\nif (PageError(page))\r\ngoto error;\r\nbuf = kmap_atomic(page);\r\nmemcpy(devname, buf, size);\r\nkunmap_atomic(buf);\r\npage_cache_release(page);\r\npage = NULL;\r\n}\r\nsuper = AFS_FS_S(mntpt->d_sb);\r\nmemcpy(options, "cell=", 5);\r\nstrcpy(options + 5, super->volume->cell->name);\r\nif (super->volume->type == AFSVL_RWVOL || rwpath)\r\nstrcat(options, ",rwpath");\r\n_debug("--- attempting mount %s -o %s ---", devname, options);\r\nmnt = vfs_kern_mount(&afs_fs_type, 0, devname, options);\r\n_debug("--- mount result %p ---", mnt);\r\nfree_page((unsigned long) devname);\r\nfree_page((unsigned long) options);\r\n_leave(" = %p", mnt);\r\nreturn mnt;\r\nerror:\r\npage_cache_release(page);\r\nerror_no_page:\r\nfree_page((unsigned long) options);\r\nerror_no_options:\r\nfree_page((unsigned long) devname);\r\nerror_no_devname:\r\n_leave(" = %d", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct vfsmount *afs_d_automount(struct path *path)\r\n{\r\nstruct vfsmount *newmnt;\r\n_enter("{%s}", path->dentry->d_name.name);\r\nnewmnt = afs_mntpt_do_automount(path->dentry);\r\nif (IS_ERR(newmnt))\r\nreturn newmnt;\r\nmntget(newmnt);\r\nmnt_set_expiry(newmnt, &afs_vfsmounts);\r\nqueue_delayed_work(afs_wq, &afs_mntpt_expiry_timer,\r\nafs_mntpt_expiry_timeout * HZ);\r\n_leave(" = %p", newmnt);\r\nreturn newmnt;\r\n}\r\nstatic void afs_mntpt_expiry_timed_out(struct work_struct *work)\r\n{\r\n_enter("");\r\nif (!list_empty(&afs_vfsmounts)) {\r\nmark_mounts_for_expiry(&afs_vfsmounts);\r\nqueue_delayed_work(afs_wq, &afs_mntpt_expiry_timer,\r\nafs_mntpt_expiry_timeout * HZ);\r\n}\r\n_leave("");\r\n}\r\nvoid afs_mntpt_kill_timer(void)\r\n{\r\n_enter("");\r\nASSERT(list_empty(&afs_vfsmounts));\r\ncancel_delayed_work_sync(&afs_mntpt_expiry_timer);\r\n}
