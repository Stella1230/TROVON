static inline void msm_irq_write_all_regs(void __iomem *base, unsigned int val)\r\n{\r\nint i;\r\nfor (i = 0; i < VIC_NUM_REGS; i++)\r\nwritel(val, base + (i * 4));\r\n}\r\nstatic void msm_irq_ack(struct irq_data *d)\r\n{\r\nvoid __iomem *reg = VIC_INT_TO_REG_ADDR(VIC_INT_CLEAR0, d->irq);\r\nwritel(1 << (d->irq & 31), reg);\r\n}\r\nstatic void msm_irq_mask(struct irq_data *d)\r\n{\r\nvoid __iomem *reg = VIC_INT_TO_REG_ADDR(VIC_INT_ENCLEAR0, d->irq);\r\nunsigned index = VIC_INT_TO_REG_INDEX(d->irq);\r\nuint32_t mask = 1UL << (d->irq & 31);\r\nint smsm_irq = msm_irq_to_smsm[d->irq];\r\nmsm_irq_shadow_reg[index].int_en[0] &= ~mask;\r\nwritel(mask, reg);\r\nif (smsm_irq == 0)\r\nmsm_irq_idle_disable[index] &= ~mask;\r\nelse {\r\nmask = 1UL << (smsm_irq - 1);\r\nmsm_irq_smsm_wake_enable[0] &= ~mask;\r\n}\r\n}\r\nstatic void msm_irq_unmask(struct irq_data *d)\r\n{\r\nvoid __iomem *reg = VIC_INT_TO_REG_ADDR(VIC_INT_ENSET0, d->irq);\r\nunsigned index = VIC_INT_TO_REG_INDEX(d->irq);\r\nuint32_t mask = 1UL << (d->irq & 31);\r\nint smsm_irq = msm_irq_to_smsm[d->irq];\r\nmsm_irq_shadow_reg[index].int_en[0] |= mask;\r\nwritel(mask, reg);\r\nif (smsm_irq == 0)\r\nmsm_irq_idle_disable[index] |= mask;\r\nelse {\r\nmask = 1UL << (smsm_irq - 1);\r\nmsm_irq_smsm_wake_enable[0] |= mask;\r\n}\r\n}\r\nstatic int msm_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nunsigned index = VIC_INT_TO_REG_INDEX(d->irq);\r\nuint32_t mask = 1UL << (d->irq & 31);\r\nint smsm_irq = msm_irq_to_smsm[d->irq];\r\nif (smsm_irq == 0) {\r\nprintk(KERN_ERR "msm_irq_set_wake: bad wakeup irq %d\n", d->irq);\r\nreturn -EINVAL;\r\n}\r\nif (on)\r\nmsm_irq_shadow_reg[index].int_en[1] |= mask;\r\nelse\r\nmsm_irq_shadow_reg[index].int_en[1] &= ~mask;\r\nif (smsm_irq == SMSM_FAKE_IRQ)\r\nreturn 0;\r\nmask = 1UL << (smsm_irq - 1);\r\nif (on)\r\nmsm_irq_smsm_wake_enable[1] |= mask;\r\nelse\r\nmsm_irq_smsm_wake_enable[1] &= ~mask;\r\nreturn 0;\r\n}\r\nstatic int msm_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nvoid __iomem *treg = VIC_INT_TO_REG_ADDR(VIC_INT_TYPE0, d->irq);\r\nvoid __iomem *preg = VIC_INT_TO_REG_ADDR(VIC_INT_POLARITY0, d->irq);\r\nunsigned index = VIC_INT_TO_REG_INDEX(d->irq);\r\nint b = 1 << (d->irq & 31);\r\nuint32_t polarity;\r\nuint32_t type;\r\npolarity = msm_irq_shadow_reg[index].int_polarity;\r\nif (flow_type & (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_LOW))\r\npolarity |= b;\r\nif (flow_type & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_HIGH))\r\npolarity &= ~b;\r\nwritel(polarity, preg);\r\nmsm_irq_shadow_reg[index].int_polarity = polarity;\r\ntype = msm_irq_shadow_reg[index].int_type;\r\nif (flow_type & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)) {\r\ntype |= b;\r\n__irq_set_handler_locked(d->irq, handle_edge_irq);\r\n}\r\nif (flow_type & (IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW)) {\r\ntype &= ~b;\r\n__irq_set_handler_locked(d->irq, handle_level_irq);\r\n}\r\nwritel(type, treg);\r\nmsm_irq_shadow_reg[index].int_type = type;\r\nreturn 0;\r\n}\r\nvoid __init msm_init_irq(void)\r\n{\r\nunsigned n;\r\nmsm_irq_write_all_regs(VIC_INT_TYPE0, 0);\r\nmsm_irq_write_all_regs(VIC_INT_POLARITY0, 0);\r\nmsm_irq_write_all_regs(VIC_INT_SELECT0, 0);\r\nmsm_irq_write_all_regs(VIC_INT_EN0, 0);\r\nwritel(0, VIC_CONFIG);\r\nwritel(3, VIC_INT_MASTEREN);\r\nfor (n = 0; n < NR_MSM_IRQS; n++) {\r\nirq_set_chip_and_handler(n, &msm_irq_chip, handle_level_irq);\r\nset_irq_flags(n, IRQF_VALID);\r\n}\r\n}
