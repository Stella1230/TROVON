fnic_trace_data_t *fnic_trace_get_buf(void)\r\n{\r\nunsigned long fnic_buf_head;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fnic_trace_lock, flags);\r\nfnic_buf_head =\r\nfnic_trace_entries.page_offset[fnic_trace_entries.wr_idx];\r\nfnic_trace_entries.wr_idx++;\r\nif (fnic_trace_entries.wr_idx >= fnic_max_trace_entries)\r\nfnic_trace_entries.wr_idx = 0;\r\nif (fnic_trace_entries.wr_idx == fnic_trace_entries.rd_idx) {\r\nfnic_trace_entries.rd_idx++;\r\nif (fnic_trace_entries.rd_idx >= fnic_max_trace_entries)\r\nfnic_trace_entries.rd_idx = 0;\r\n}\r\nspin_unlock_irqrestore(&fnic_trace_lock, flags);\r\nreturn (fnic_trace_data_t *)fnic_buf_head;\r\n}\r\nint fnic_get_trace_data(fnic_dbgfs_t *fnic_dbgfs_prt)\r\n{\r\nint rd_idx;\r\nint wr_idx;\r\nint len = 0;\r\nunsigned long flags;\r\nchar str[KSYM_SYMBOL_LEN];\r\nstruct timespec val;\r\nfnic_trace_data_t *tbp;\r\nspin_lock_irqsave(&fnic_trace_lock, flags);\r\nrd_idx = fnic_trace_entries.rd_idx;\r\nwr_idx = fnic_trace_entries.wr_idx;\r\nif (wr_idx < rd_idx) {\r\nwhile (1) {\r\ntbp = (fnic_trace_data_t *)\r\nfnic_trace_entries.page_offset[rd_idx];\r\nif (!tbp) {\r\nspin_unlock_irqrestore(&fnic_trace_lock, flags);\r\nreturn 0;\r\n}\r\nif (sizeof(unsigned long) < 8) {\r\nsprint_symbol(str, tbp->fnaddr.low);\r\njiffies_to_timespec(tbp->timestamp.low, &val);\r\n} else {\r\nsprint_symbol(str, tbp->fnaddr.val);\r\njiffies_to_timespec(tbp->timestamp.val, &val);\r\n}\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\n(trace_max_pages * PAGE_SIZE * 3) - len,\r\n"%16lu.%16lu %-50s %8x %8x %16llx %16llx "\r\n"%16llx %16llx %16llx\n", val.tv_sec,\r\nval.tv_nsec, str, tbp->host_no, tbp->tag,\r\ntbp->data[0], tbp->data[1], tbp->data[2],\r\ntbp->data[3], tbp->data[4]);\r\nrd_idx++;\r\nif (rd_idx > (fnic_max_trace_entries-1))\r\nrd_idx = 0;\r\nif (rd_idx == wr_idx)\r\nbreak;\r\n}\r\n} else if (wr_idx > rd_idx) {\r\nwhile (1) {\r\ntbp = (fnic_trace_data_t *)\r\nfnic_trace_entries.page_offset[rd_idx];\r\nif (!tbp) {\r\nspin_unlock_irqrestore(&fnic_trace_lock, flags);\r\nreturn 0;\r\n}\r\nif (sizeof(unsigned long) < 8) {\r\nsprint_symbol(str, tbp->fnaddr.low);\r\njiffies_to_timespec(tbp->timestamp.low, &val);\r\n} else {\r\nsprint_symbol(str, tbp->fnaddr.val);\r\njiffies_to_timespec(tbp->timestamp.val, &val);\r\n}\r\nlen += snprintf(fnic_dbgfs_prt->buffer + len,\r\n(trace_max_pages * PAGE_SIZE * 3) - len,\r\n"%16lu.%16lu %-50s %8x %8x %16llx %16llx "\r\n"%16llx %16llx %16llx\n", val.tv_sec,\r\nval.tv_nsec, str, tbp->host_no, tbp->tag,\r\ntbp->data[0], tbp->data[1], tbp->data[2],\r\ntbp->data[3], tbp->data[4]);\r\nrd_idx++;\r\nif (rd_idx == wr_idx)\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&fnic_trace_lock, flags);\r\nreturn len;\r\n}\r\nint fnic_get_stats_data(struct stats_debug_info *debug,\r\nstruct fnic_stats *stats)\r\n{\r\nint len = 0;\r\nint buf_size = debug->buf_size;\r\nstruct timespec val1, val2;\r\nlen = snprintf(debug->debug_buffer + len, buf_size - len,\r\n"------------------------------------------\n"\r\n"\t\tIO Statistics\n"\r\n"------------------------------------------\n");\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Number of Active IOs: %lld\nMaximum Active IOs: %lld\n"\r\n"Number of IOs: %lld\nNumber of IO Completions: %lld\n"\r\n"Number of IO Failures: %lld\nNumber of IO NOT Found: %lld\n"\r\n"Number of Memory alloc Failures: %lld\n"\r\n"Number of IOREQ Null: %lld\n"\r\n"Number of SCSI cmd pointer Null: %lld\n",\r\n(u64)atomic64_read(&stats->io_stats.active_ios),\r\n(u64)atomic64_read(&stats->io_stats.max_active_ios),\r\n(u64)atomic64_read(&stats->io_stats.num_ios),\r\n(u64)atomic64_read(&stats->io_stats.io_completions),\r\n(u64)atomic64_read(&stats->io_stats.io_failures),\r\n(u64)atomic64_read(&stats->io_stats.io_not_found),\r\n(u64)atomic64_read(&stats->io_stats.alloc_failures),\r\n(u64)atomic64_read(&stats->io_stats.ioreq_null),\r\n(u64)atomic64_read(&stats->io_stats.sc_null));\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"\n------------------------------------------\n"\r\n"\t\tAbort Statistics\n"\r\n"------------------------------------------\n");\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Number of Aborts: %lld\n"\r\n"Number of Abort Failures: %lld\n"\r\n"Number of Abort Driver Timeouts: %lld\n"\r\n"Number of Abort FW Timeouts: %lld\n"\r\n"Number of Abort IO NOT Found: %lld\n",\r\n(u64)atomic64_read(&stats->abts_stats.aborts),\r\n(u64)atomic64_read(&stats->abts_stats.abort_failures),\r\n(u64)atomic64_read(&stats->abts_stats.abort_drv_timeouts),\r\n(u64)atomic64_read(&stats->abts_stats.abort_fw_timeouts),\r\n(u64)atomic64_read(&stats->abts_stats.abort_io_not_found));\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"\n------------------------------------------\n"\r\n"\t\tTerminate Statistics\n"\r\n"------------------------------------------\n");\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Number of Terminates: %lld\n"\r\n"Maximum Terminates: %lld\n"\r\n"Number of Terminate Driver Timeouts: %lld\n"\r\n"Number of Terminate FW Timeouts: %lld\n"\r\n"Number of Terminate IO NOT Found: %lld\n"\r\n"Number of Terminate Failures: %lld\n",\r\n(u64)atomic64_read(&stats->term_stats.terminates),\r\n(u64)atomic64_read(&stats->term_stats.max_terminates),\r\n(u64)atomic64_read(&stats->term_stats.terminate_drv_timeouts),\r\n(u64)atomic64_read(&stats->term_stats.terminate_fw_timeouts),\r\n(u64)atomic64_read(&stats->term_stats.terminate_io_not_found),\r\n(u64)atomic64_read(&stats->term_stats.terminate_failures));\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"\n------------------------------------------\n"\r\n"\t\tReset Statistics\n"\r\n"------------------------------------------\n");\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Number of Device Resets: %lld\n"\r\n"Number of Device Reset Failures: %lld\n"\r\n"Number of Device Reset Aborts: %lld\n"\r\n"Number of Device Reset Timeouts: %lld\n"\r\n"Number of Device Reset Terminates: %lld\n"\r\n"Number of FW Resets: %lld\n"\r\n"Number of FW Reset Completions: %lld\n"\r\n"Number of FW Reset Failures: %lld\n"\r\n"Number of Fnic Reset: %lld\n"\r\n"Number of Fnic Reset Completions: %lld\n"\r\n"Number of Fnic Reset Failures: %lld\n",\r\n(u64)atomic64_read(&stats->reset_stats.device_resets),\r\n(u64)atomic64_read(&stats->reset_stats.device_reset_failures),\r\n(u64)atomic64_read(&stats->reset_stats.device_reset_aborts),\r\n(u64)atomic64_read(&stats->reset_stats.device_reset_timeouts),\r\n(u64)atomic64_read(\r\n&stats->reset_stats.device_reset_terminates),\r\n(u64)atomic64_read(&stats->reset_stats.fw_resets),\r\n(u64)atomic64_read(&stats->reset_stats.fw_reset_completions),\r\n(u64)atomic64_read(&stats->reset_stats.fw_reset_failures),\r\n(u64)atomic64_read(&stats->reset_stats.fnic_resets),\r\n(u64)atomic64_read(\r\n&stats->reset_stats.fnic_reset_completions),\r\n(u64)atomic64_read(&stats->reset_stats.fnic_reset_failures));\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"\n------------------------------------------\n"\r\n"\t\tFirmware Statistics\n"\r\n"------------------------------------------\n");\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Number of Active FW Requests %lld\n"\r\n"Maximum FW Requests: %lld\n"\r\n"Number of FW out of resources: %lld\n"\r\n"Number of FW IO errors: %lld\n",\r\n(u64)atomic64_read(&stats->fw_stats.active_fw_reqs),\r\n(u64)atomic64_read(&stats->fw_stats.max_fw_reqs),\r\n(u64)atomic64_read(&stats->fw_stats.fw_out_of_resources),\r\n(u64)atomic64_read(&stats->fw_stats.io_fw_errs));\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"\n------------------------------------------\n"\r\n"\t\tVlan Discovery Statistics\n"\r\n"------------------------------------------\n");\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Number of Vlan Discovery Requests Sent %lld\n"\r\n"Vlan Response Received with no FCF VLAN ID: %lld\n"\r\n"No solicitations recvd after vlan set, expiry count: %lld\n"\r\n"Flogi rejects count: %lld\n",\r\n(u64)atomic64_read(&stats->vlan_stats.vlan_disc_reqs),\r\n(u64)atomic64_read(&stats->vlan_stats.resp_withno_vlanID),\r\n(u64)atomic64_read(&stats->vlan_stats.sol_expiry_count),\r\n(u64)atomic64_read(&stats->vlan_stats.flogi_rejects));\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"\n------------------------------------------\n"\r\n"\t\tOther Important Statistics\n"\r\n"------------------------------------------\n");\r\njiffies_to_timespec(stats->misc_stats.last_isr_time, &val1);\r\njiffies_to_timespec(stats->misc_stats.last_ack_time, &val2);\r\nlen += snprintf(debug->debug_buffer + len, buf_size - len,\r\n"Last ISR time: %llu (%8lu.%8lu)\n"\r\n"Last ACK time: %llu (%8lu.%8lu)\n"\r\n"Number of ISRs: %lld\n"\r\n"Maximum CQ Entries: %lld\n"\r\n"Number of ACK index out of range: %lld\n"\r\n"Number of data count mismatch: %lld\n"\r\n"Number of FCPIO Timeouts: %lld\n"\r\n"Number of FCPIO Aborted: %lld\n"\r\n"Number of SGL Invalid: %lld\n"\r\n"Number of Copy WQ Alloc Failures for ABTs: %lld\n"\r\n"Number of Copy WQ Alloc Failures for Device Reset: %lld\n"\r\n"Number of Copy WQ Alloc Failures for IOs: %lld\n"\r\n"Number of no icmnd itmf Completions: %lld\n"\r\n"Number of QUEUE Fulls: %lld\n"\r\n"Number of rport not ready: %lld\n"\r\n"Number of receive frame errors: %lld\n",\r\n(u64)stats->misc_stats.last_isr_time,\r\nval1.tv_sec, val1.tv_nsec,\r\n(u64)stats->misc_stats.last_ack_time,\r\nval2.tv_sec, val2.tv_nsec,\r\n(u64)atomic64_read(&stats->misc_stats.isr_count),\r\n(u64)atomic64_read(&stats->misc_stats.max_cq_entries),\r\n(u64)atomic64_read(&stats->misc_stats.ack_index_out_of_range),\r\n(u64)atomic64_read(&stats->misc_stats.data_count_mismatch),\r\n(u64)atomic64_read(&stats->misc_stats.fcpio_timeout),\r\n(u64)atomic64_read(&stats->misc_stats.fcpio_aborted),\r\n(u64)atomic64_read(&stats->misc_stats.sgl_invalid),\r\n(u64)atomic64_read(\r\n&stats->misc_stats.abts_cpwq_alloc_failures),\r\n(u64)atomic64_read(\r\n&stats->misc_stats.devrst_cpwq_alloc_failures),\r\n(u64)atomic64_read(&stats->misc_stats.io_cpwq_alloc_failures),\r\n(u64)atomic64_read(&stats->misc_stats.no_icmnd_itmf_cmpls),\r\n(u64)atomic64_read(&stats->misc_stats.queue_fulls),\r\n(u64)atomic64_read(&stats->misc_stats.rport_not_ready),\r\n(u64)atomic64_read(&stats->misc_stats.frame_errors));\r\nreturn len;\r\n}\r\nint fnic_trace_buf_init(void)\r\n{\r\nunsigned long fnic_buf_head;\r\nint i;\r\nint err = 0;\r\ntrace_max_pages = fnic_trace_max_pages;\r\nfnic_max_trace_entries = (trace_max_pages * PAGE_SIZE)/\r\nFNIC_ENTRY_SIZE_BYTES;\r\nfnic_trace_buf_p = (unsigned long)vmalloc((trace_max_pages * PAGE_SIZE));\r\nif (!fnic_trace_buf_p) {\r\nprintk(KERN_ERR PFX "Failed to allocate memory "\r\n"for fnic_trace_buf_p\n");\r\nerr = -ENOMEM;\r\ngoto err_fnic_trace_buf_init;\r\n}\r\nmemset((void *)fnic_trace_buf_p, 0, (trace_max_pages * PAGE_SIZE));\r\nfnic_trace_entries.page_offset = vmalloc(fnic_max_trace_entries *\r\nsizeof(unsigned long));\r\nif (!fnic_trace_entries.page_offset) {\r\nprintk(KERN_ERR PFX "Failed to allocate memory for"\r\n" page_offset\n");\r\nif (fnic_trace_buf_p) {\r\nvfree((void *)fnic_trace_buf_p);\r\nfnic_trace_buf_p = 0;\r\n}\r\nerr = -ENOMEM;\r\ngoto err_fnic_trace_buf_init;\r\n}\r\nmemset((void *)fnic_trace_entries.page_offset, 0,\r\n(fnic_max_trace_entries * sizeof(unsigned long)));\r\nfnic_trace_entries.wr_idx = fnic_trace_entries.rd_idx = 0;\r\nfnic_buf_head = fnic_trace_buf_p;\r\nfor (i = 0; i < fnic_max_trace_entries; i++) {\r\nfnic_trace_entries.page_offset[i] = fnic_buf_head;\r\nfnic_buf_head += FNIC_ENTRY_SIZE_BYTES;\r\n}\r\nerr = fnic_trace_debugfs_init();\r\nif (err < 0) {\r\nprintk(KERN_ERR PFX "Failed to initialize debugfs for tracing\n");\r\ngoto err_fnic_trace_debugfs_init;\r\n}\r\nprintk(KERN_INFO PFX "Successfully Initialized Trace Buffer\n");\r\nreturn err;\r\nerr_fnic_trace_debugfs_init:\r\nfnic_trace_free();\r\nerr_fnic_trace_buf_init:\r\nreturn err;\r\n}\r\nvoid fnic_trace_free(void)\r\n{\r\nfnic_tracing_enabled = 0;\r\nfnic_trace_debugfs_terminate();\r\nif (fnic_trace_entries.page_offset) {\r\nvfree((void *)fnic_trace_entries.page_offset);\r\nfnic_trace_entries.page_offset = NULL;\r\n}\r\nif (fnic_trace_buf_p) {\r\nvfree((void *)fnic_trace_buf_p);\r\nfnic_trace_buf_p = 0;\r\n}\r\nprintk(KERN_INFO PFX "Successfully Freed Trace Buffer\n");\r\n}
