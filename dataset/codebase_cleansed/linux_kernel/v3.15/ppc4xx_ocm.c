static struct ocm_info *ocm_get_node(unsigned int index)\r\n{\r\nif (index >= ocm_count) {\r\nprintk(KERN_ERR "PPC4XX OCM: invalid index");\r\nreturn NULL;\r\n}\r\nreturn &ocm_nodes[index];\r\n}\r\nstatic int ocm_free_region(struct ocm_region *ocm_reg, const void *addr)\r\n{\r\nstruct ocm_block *blk, *tmp;\r\nunsigned long offset;\r\nif (!ocm_reg->virt)\r\nreturn 0;\r\nlist_for_each_entry_safe(blk, tmp, &ocm_reg->list, list) {\r\nif (blk->addr == addr) {\r\noffset = addr - ocm_reg->virt;\r\nocm_reg->memfree += blk->size;\r\nrh_free(ocm_reg->rh, offset);\r\nlist_del(&blk->list);\r\nkfree(blk);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init ocm_init_node(int count, struct device_node *node)\r\n{\r\nstruct ocm_info *ocm;\r\nconst unsigned int *cell_index;\r\nconst unsigned int *cache_size;\r\nint len;\r\nstruct resource rsrc;\r\nint ioflags;\r\nocm = ocm_get_node(count);\r\ncell_index = of_get_property(node, "cell-index", &len);\r\nif (!cell_index) {\r\nprintk(KERN_ERR "PPC4XX OCM: missing cell-index property");\r\nreturn;\r\n}\r\nocm->index = *cell_index;\r\nif (of_device_is_available(node))\r\nocm->status = OCM_ENABLED;\r\ncache_size = of_get_property(node, "cached-region-size", &len);\r\nif (cache_size)\r\nocm->cache_size = *cache_size;\r\nif (of_address_to_resource(node, 0, &rsrc)) {\r\nprintk(KERN_ERR "PPC4XX OCM%d: could not get resource address\n",\r\nocm->index);\r\nreturn;\r\n}\r\nocm->phys = rsrc.start;\r\nocm->memtotal = (rsrc.end - rsrc.start + 1);\r\nprintk(KERN_INFO "PPC4XX OCM%d: %d Bytes (%s)\n",\r\nocm->index, ocm->memtotal,\r\n(ocm->status == OCM_DISABLED) ? "disabled" : "enabled");\r\nif (ocm->status == OCM_DISABLED)\r\nreturn;\r\nif (!request_mem_region(ocm->phys, ocm->memtotal, "ppc4xx_ocm")) {\r\nprintk(KERN_ERR "PPC4XX OCM%d: could not request region\n",\r\nocm->index);\r\nreturn;\r\n}\r\nocm->nc.phys = ocm->phys;\r\nocm->nc.memtotal = ocm->memtotal - ocm->cache_size;\r\nocm->nc.memfree = ocm->nc.memtotal;\r\nocm->c.phys = ocm->phys + ocm->nc.memtotal;\r\nocm->c.memtotal = ocm->cache_size;\r\nocm->c.memfree = ocm->c.memtotal;\r\nif (ocm->nc.memtotal == 0)\r\nocm->nc.phys = 0;\r\nif (ocm->c.memtotal == 0)\r\nocm->c.phys = 0;\r\nprintk(KERN_INFO "PPC4XX OCM%d: %d Bytes (non-cached)\n",\r\nocm->index, ocm->nc.memtotal);\r\nprintk(KERN_INFO "PPC4XX OCM%d: %d Bytes (cached)\n",\r\nocm->index, ocm->c.memtotal);\r\nif (ocm->nc.memtotal) {\r\nioflags = _PAGE_NO_CACHE | _PAGE_GUARDED | _PAGE_EXEC;\r\nocm->nc.virt = __ioremap(ocm->nc.phys, ocm->nc.memtotal,\r\nioflags);\r\nif (!ocm->nc.virt) {\r\nprintk(KERN_ERR\r\n"PPC4XX OCM%d: failed to ioremap non-cached memory\n",\r\nocm->index);\r\nocm->nc.memfree = 0;\r\nreturn;\r\n}\r\n}\r\nif (ocm->c.memtotal) {\r\nioflags = _PAGE_EXEC;\r\nocm->c.virt = __ioremap(ocm->c.phys, ocm->c.memtotal,\r\nioflags);\r\nif (!ocm->c.virt) {\r\nprintk(KERN_ERR\r\n"PPC4XX OCM%d: failed to ioremap cached memory\n",\r\nocm->index);\r\nocm->c.memfree = 0;\r\nreturn;\r\n}\r\n}\r\nocm->alignment = 4;\r\nif (ocm->nc.virt) {\r\nocm->nc.rh = rh_create(ocm->alignment);\r\nrh_attach_region(ocm->nc.rh, 0, ocm->nc.memtotal);\r\n}\r\nif (ocm->c.virt) {\r\nocm->c.rh = rh_create(ocm->alignment);\r\nrh_attach_region(ocm->c.rh, 0, ocm->c.memtotal);\r\n}\r\nINIT_LIST_HEAD(&ocm->nc.list);\r\nINIT_LIST_HEAD(&ocm->c.list);\r\nocm->ready = 1;\r\nreturn;\r\n}\r\nstatic int ocm_debugfs_show(struct seq_file *m, void *v)\r\n{\r\nstruct ocm_block *blk, *tmp;\r\nunsigned int i;\r\nfor (i = 0; i < ocm_count; i++) {\r\nstruct ocm_info *ocm = ocm_get_node(i);\r\nif (!ocm || !ocm->ready)\r\ncontinue;\r\nseq_printf(m, "PPC4XX OCM : %d\n", ocm->index);\r\nseq_printf(m, "PhysAddr : 0x%llx\n", ocm->phys);\r\nseq_printf(m, "MemTotal : %d Bytes\n", ocm->memtotal);\r\nseq_printf(m, "MemTotal(NC) : %d Bytes\n", ocm->nc.memtotal);\r\nseq_printf(m, "MemTotal(C) : %d Bytes\n", ocm->c.memtotal);\r\nseq_printf(m, "\n");\r\nseq_printf(m, "NC.PhysAddr : 0x%llx\n", ocm->nc.phys);\r\nseq_printf(m, "NC.VirtAddr : 0x%p\n", ocm->nc.virt);\r\nseq_printf(m, "NC.MemTotal : %d Bytes\n", ocm->nc.memtotal);\r\nseq_printf(m, "NC.MemFree : %d Bytes\n", ocm->nc.memfree);\r\nlist_for_each_entry_safe(blk, tmp, &ocm->nc.list, list) {\r\nseq_printf(m, "NC.MemUsed : %d Bytes (%s)\n",\r\nblk->size, blk->owner);\r\n}\r\nseq_printf(m, "\n");\r\nseq_printf(m, "C.PhysAddr : 0x%llx\n", ocm->c.phys);\r\nseq_printf(m, "C.VirtAddr : 0x%p\n", ocm->c.virt);\r\nseq_printf(m, "C.MemTotal : %d Bytes\n", ocm->c.memtotal);\r\nseq_printf(m, "C.MemFree : %d Bytes\n", ocm->c.memfree);\r\nlist_for_each_entry_safe(blk, tmp, &ocm->c.list, list) {\r\nseq_printf(m, "C.MemUsed : %d Bytes (%s)\n",\r\nblk->size, blk->owner);\r\n}\r\nseq_printf(m, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ocm_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ocm_debugfs_show, NULL);\r\n}\r\nstatic int ocm_debugfs_init(void)\r\n{\r\nstruct dentry *junk;\r\njunk = debugfs_create_dir("ppc4xx_ocm", 0);\r\nif (!junk) {\r\nprintk(KERN_ALERT "debugfs ppc4xx ocm: failed to create dir\n");\r\nreturn -1;\r\n}\r\nif (debugfs_create_file("info", 0644, junk, NULL, &ocm_debugfs_fops)) {\r\nprintk(KERN_ALERT "debugfs ppc4xx ocm: failed to create file\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid *ppc4xx_ocm_alloc(phys_addr_t *phys, int size, int align,\r\nint flags, const char *owner)\r\n{\r\nvoid __iomem *addr = NULL;\r\nunsigned long offset;\r\nstruct ocm_info *ocm;\r\nstruct ocm_region *ocm_reg;\r\nstruct ocm_block *ocm_blk;\r\nint i;\r\nfor (i = 0; i < ocm_count; i++) {\r\nocm = ocm_get_node(i);\r\nif (!ocm || !ocm->ready)\r\ncontinue;\r\nif (flags == PPC4XX_OCM_NON_CACHED)\r\nocm_reg = &ocm->nc;\r\nelse\r\nocm_reg = &ocm->c;\r\nif (!ocm_reg->virt)\r\ncontinue;\r\nif (align < ocm->alignment)\r\nalign = ocm->alignment;\r\noffset = rh_alloc_align(ocm_reg->rh, size, align, NULL);\r\nif (IS_ERR_VALUE(offset))\r\ncontinue;\r\nocm_blk = kzalloc(sizeof(struct ocm_block), GFP_KERNEL);\r\nif (!ocm_blk) {\r\nprintk(KERN_ERR "PPC4XX OCM: could not allocate ocm block");\r\nrh_free(ocm_reg->rh, offset);\r\nbreak;\r\n}\r\n*phys = ocm_reg->phys + offset;\r\naddr = ocm_reg->virt + offset;\r\nsize = ALIGN(size, align);\r\nocm_blk->addr = addr;\r\nocm_blk->size = size;\r\nocm_blk->owner = owner;\r\nlist_add_tail(&ocm_blk->list, &ocm_reg->list);\r\nocm_reg->memfree -= size;\r\nbreak;\r\n}\r\nreturn addr;\r\n}\r\nvoid ppc4xx_ocm_free(const void *addr)\r\n{\r\nint i;\r\nif (!addr)\r\nreturn;\r\nfor (i = 0; i < ocm_count; i++) {\r\nstruct ocm_info *ocm = ocm_get_node(i);\r\nif (!ocm || !ocm->ready)\r\ncontinue;\r\nif (ocm_free_region(&ocm->nc, addr) ||\r\nocm_free_region(&ocm->c, addr))\r\nreturn;\r\n}\r\n}\r\nstatic int __init ppc4xx_ocm_init(void)\r\n{\r\nstruct device_node *np;\r\nint count;\r\ncount = 0;\r\nfor_each_compatible_node(np, NULL, "ibm,ocm")\r\ncount++;\r\nif (!count)\r\nreturn 0;\r\nocm_nodes = kzalloc((count * sizeof(struct ocm_info)), GFP_KERNEL);\r\nif (!ocm_nodes) {\r\nprintk(KERN_ERR "PPC4XX OCM: failed to allocate OCM nodes!\n");\r\nreturn -ENOMEM;\r\n}\r\nocm_count = count;\r\ncount = 0;\r\nfor_each_compatible_node(np, NULL, "ibm,ocm") {\r\nocm_init_node(count, np);\r\ncount++;\r\n}\r\nocm_debugfs_init();\r\nreturn 0;\r\n}
