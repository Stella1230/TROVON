static struct sunxi_pinctrl_group *\r\nsunxi_pinctrl_find_group_by_name(struct sunxi_pinctrl *pctl, const char *group)\r\n{\r\nint i;\r\nfor (i = 0; i < pctl->ngroups; i++) {\r\nstruct sunxi_pinctrl_group *grp = pctl->groups + i;\r\nif (!strcmp(grp->name, group))\r\nreturn grp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sunxi_pinctrl_function *\r\nsunxi_pinctrl_find_function_by_name(struct sunxi_pinctrl *pctl,\r\nconst char *name)\r\n{\r\nstruct sunxi_pinctrl_function *func = pctl->functions;\r\nint i;\r\nfor (i = 0; i < pctl->nfunctions; i++) {\r\nif (!func[i].name)\r\nbreak;\r\nif (!strcmp(func[i].name, name))\r\nreturn func + i;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sunxi_desc_function *\r\nsunxi_pinctrl_desc_find_function_by_name(struct sunxi_pinctrl *pctl,\r\nconst char *pin_name,\r\nconst char *func_name)\r\n{\r\nint i;\r\nfor (i = 0; i < pctl->desc->npins; i++) {\r\nconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\r\nif (!strcmp(pin->pin.name, pin_name)) {\r\nstruct sunxi_desc_function *func = pin->functions;\r\nwhile (func->name) {\r\nif (!strcmp(func->name, func_name))\r\nreturn func;\r\nfunc++;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sunxi_desc_function *\r\nsunxi_pinctrl_desc_find_function_by_pin(struct sunxi_pinctrl *pctl,\r\nconst u16 pin_num,\r\nconst char *func_name)\r\n{\r\nint i;\r\nfor (i = 0; i < pctl->desc->npins; i++) {\r\nconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\r\nif (pin->pin.number == pin_num) {\r\nstruct sunxi_desc_function *func = pin->functions;\r\nwhile (func->name) {\r\nif (!strcmp(func->name, func_name))\r\nreturn func;\r\nfunc++;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int sunxi_pctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->ngroups;\r\n}\r\nstatic const char *sunxi_pctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->groups[group].name;\r\n}\r\nstatic int sunxi_pctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = (unsigned *)&pctl->groups[group].pin;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic int sunxi_pctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *node,\r\nstruct pinctrl_map **map,\r\nunsigned *num_maps)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned long *pinconfig;\r\nstruct property *prop;\r\nconst char *function;\r\nconst char *group;\r\nint ret, nmaps, i = 0;\r\nu32 val;\r\n*map = NULL;\r\n*num_maps = 0;\r\nret = of_property_read_string(node, "allwinner,function", &function);\r\nif (ret) {\r\ndev_err(pctl->dev,\r\n"missing allwinner,function property in node %s\n",\r\nnode->name);\r\nreturn -EINVAL;\r\n}\r\nnmaps = of_property_count_strings(node, "allwinner,pins") * 2;\r\nif (nmaps < 0) {\r\ndev_err(pctl->dev,\r\n"missing allwinner,pins property in node %s\n",\r\nnode->name);\r\nreturn -EINVAL;\r\n}\r\n*map = kmalloc(nmaps * sizeof(struct pinctrl_map), GFP_KERNEL);\r\nif (!*map)\r\nreturn -ENOMEM;\r\nof_property_for_each_string(node, "allwinner,pins", prop, group) {\r\nstruct sunxi_pinctrl_group *grp =\r\nsunxi_pinctrl_find_group_by_name(pctl, group);\r\nint j = 0, configlen = 0;\r\nif (!grp) {\r\ndev_err(pctl->dev, "unknown pin %s", group);\r\ncontinue;\r\n}\r\nif (!sunxi_pinctrl_desc_find_function_by_name(pctl,\r\ngrp->name,\r\nfunction)) {\r\ndev_err(pctl->dev, "unsupported function %s on pin %s",\r\nfunction, group);\r\ncontinue;\r\n}\r\n(*map)[i].type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)[i].data.mux.group = group;\r\n(*map)[i].data.mux.function = function;\r\ni++;\r\n(*map)[i].type = PIN_MAP_TYPE_CONFIGS_GROUP;\r\n(*map)[i].data.configs.group_or_pin = group;\r\nif (of_find_property(node, "allwinner,drive", NULL))\r\nconfiglen++;\r\nif (of_find_property(node, "allwinner,pull", NULL))\r\nconfiglen++;\r\npinconfig = kzalloc(configlen * sizeof(*pinconfig), GFP_KERNEL);\r\nif (!of_property_read_u32(node, "allwinner,drive", &val)) {\r\nu16 strength = (val + 1) * 10;\r\npinconfig[j++] =\r\npinconf_to_config_packed(PIN_CONFIG_DRIVE_STRENGTH,\r\nstrength);\r\n}\r\nif (!of_property_read_u32(node, "allwinner,pull", &val)) {\r\nenum pin_config_param pull = PIN_CONFIG_END;\r\nif (val == 1)\r\npull = PIN_CONFIG_BIAS_PULL_UP;\r\nelse if (val == 2)\r\npull = PIN_CONFIG_BIAS_PULL_DOWN;\r\npinconfig[j++] = pinconf_to_config_packed(pull, 0);\r\n}\r\n(*map)[i].data.configs.configs = pinconfig;\r\n(*map)[i].data.configs.num_configs = configlen;\r\ni++;\r\n}\r\n*num_maps = nmaps;\r\nreturn 0;\r\n}\r\nstatic void sunxi_pctrl_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map,\r\nunsigned num_maps)\r\n{\r\nint i;\r\nfor (i = 0; i < num_maps; i++) {\r\nif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP)\r\nkfree(map[i].data.configs.configs);\r\n}\r\nkfree(map);\r\n}\r\nstatic int sunxi_pconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nunsigned long *config)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*config = pctl->groups[group].config;\r\nreturn 0;\r\n}\r\nstatic int sunxi_pconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sunxi_pinctrl_group *g = &pctl->groups[group];\r\nunsigned long flags;\r\nu32 val, mask;\r\nu16 strength;\r\nu8 dlevel;\r\nint i;\r\nspin_lock_irqsave(&pctl->lock, flags);\r\nfor (i = 0; i < num_configs; i++) {\r\nswitch (pinconf_to_config_param(configs[i])) {\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nstrength = pinconf_to_config_argument(configs[i]);\r\nif (strength > 40) {\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\nreturn -EINVAL;\r\n}\r\ndlevel = strength / 10 - 1;\r\nval = readl(pctl->membase + sunxi_dlevel_reg(g->pin));\r\nmask = DLEVEL_PINS_MASK << sunxi_dlevel_offset(g->pin);\r\nwritel((val & ~mask)\r\n| dlevel << sunxi_dlevel_offset(g->pin),\r\npctl->membase + sunxi_dlevel_reg(g->pin));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nval = readl(pctl->membase + sunxi_pull_reg(g->pin));\r\nmask = PULL_PINS_MASK << sunxi_pull_offset(g->pin);\r\nwritel((val & ~mask) | 1 << sunxi_pull_offset(g->pin),\r\npctl->membase + sunxi_pull_reg(g->pin));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nval = readl(pctl->membase + sunxi_pull_reg(g->pin));\r\nmask = PULL_PINS_MASK << sunxi_pull_offset(g->pin);\r\nwritel((val & ~mask) | 2 << sunxi_pull_offset(g->pin),\r\npctl->membase + sunxi_pull_reg(g->pin));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ng->config = configs[i];\r\n}\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sunxi_pmx_get_funcs_cnt(struct pinctrl_dev *pctldev)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->nfunctions;\r\n}\r\nstatic const char *sunxi_pmx_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->functions[function].name;\r\n}\r\nstatic int sunxi_pmx_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pctl->functions[function].groups;\r\n*num_groups = pctl->functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic void sunxi_pmx_set(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nu8 config)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned long flags;\r\nu32 val, mask;\r\nspin_lock_irqsave(&pctl->lock, flags);\r\nval = readl(pctl->membase + sunxi_mux_reg(pin));\r\nmask = MUX_PINS_MASK << sunxi_mux_offset(pin);\r\nwritel((val & ~mask) | config << sunxi_mux_offset(pin),\r\npctl->membase + sunxi_mux_reg(pin));\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\n}\r\nstatic int sunxi_pmx_enable(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nunsigned group)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sunxi_pinctrl_group *g = pctl->groups + group;\r\nstruct sunxi_pinctrl_function *func = pctl->functions + function;\r\nstruct sunxi_desc_function *desc =\r\nsunxi_pinctrl_desc_find_function_by_name(pctl,\r\ng->name,\r\nfunc->name);\r\nif (!desc)\r\nreturn -EINVAL;\r\nsunxi_pmx_set(pctldev, g->pin, desc->muxval);\r\nreturn 0;\r\n}\r\nstatic int\r\nsunxi_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset,\r\nbool input)\r\n{\r\nstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sunxi_desc_function *desc;\r\nconst char *func;\r\nif (input)\r\nfunc = "gpio_in";\r\nelse\r\nfunc = "gpio_out";\r\ndesc = sunxi_pinctrl_desc_find_function_by_pin(pctl, offset, func);\r\nif (!desc)\r\nreturn -EINVAL;\r\nsunxi_pmx_set(pctldev, offset, desc->muxval);\r\nreturn 0;\r\n}\r\nstatic int sunxi_pinctrl_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_request_gpio(chip->base + offset);\r\n}\r\nstatic void sunxi_pinctrl_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\npinctrl_free_gpio(chip->base + offset);\r\n}\r\nstatic int sunxi_pinctrl_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nreturn pinctrl_gpio_direction_input(chip->base + offset);\r\n}\r\nstatic int sunxi_pinctrl_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct sunxi_pinctrl *pctl = dev_get_drvdata(chip->dev);\r\nu32 reg = sunxi_data_reg(offset);\r\nu8 index = sunxi_data_offset(offset);\r\nu32 val = (readl(pctl->membase + reg) >> index) & DATA_PINS_MASK;\r\nreturn val;\r\n}\r\nstatic void sunxi_pinctrl_gpio_set(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct sunxi_pinctrl *pctl = dev_get_drvdata(chip->dev);\r\nu32 reg = sunxi_data_reg(offset);\r\nu8 index = sunxi_data_offset(offset);\r\nunsigned long flags;\r\nu32 regval;\r\nspin_lock_irqsave(&pctl->lock, flags);\r\nregval = readl(pctl->membase + reg);\r\nif (value)\r\nregval |= BIT(index);\r\nelse\r\nregval &= ~(BIT(index));\r\nwritel(regval, pctl->membase + reg);\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\n}\r\nstatic int sunxi_pinctrl_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nsunxi_pinctrl_gpio_set(chip, offset, value);\r\nreturn pinctrl_gpio_direction_output(chip->base + offset);\r\n}\r\nstatic int sunxi_pinctrl_gpio_of_xlate(struct gpio_chip *gc,\r\nconst struct of_phandle_args *gpiospec,\r\nu32 *flags)\r\n{\r\nint pin, base;\r\nbase = PINS_PER_BANK * gpiospec->args[0];\r\npin = base + gpiospec->args[1];\r\nif (pin > (gc->base + gc->ngpio))\r\nreturn -EINVAL;\r\nif (flags)\r\n*flags = gpiospec->args[2];\r\nreturn pin;\r\n}\r\nstatic int sunxi_pinctrl_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct sunxi_pinctrl *pctl = dev_get_drvdata(chip->dev);\r\nstruct sunxi_desc_function *desc;\r\nif (offset >= chip->ngpio)\r\nreturn -ENXIO;\r\ndesc = sunxi_pinctrl_desc_find_function_by_pin(pctl, offset, "irq");\r\nif (!desc)\r\nreturn -EINVAL;\r\npctl->irq_array[desc->irqnum] = offset;\r\ndev_dbg(chip->dev, "%s: request IRQ for GPIO %d, return %d\n",\r\nchip->label, offset + chip->base, desc->irqnum);\r\nreturn irq_find_mapping(pctl->domain, desc->irqnum);\r\n}\r\nstatic int sunxi_pinctrl_irq_set_type(struct irq_data *d,\r\nunsigned int type)\r\n{\r\nstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nu32 reg = sunxi_irq_cfg_reg(d->hwirq);\r\nu8 index = sunxi_irq_cfg_offset(d->hwirq);\r\nunsigned long flags;\r\nu32 regval;\r\nu8 mode;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nmode = IRQ_EDGE_RISING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nmode = IRQ_EDGE_FALLING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nmode = IRQ_EDGE_BOTH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nmode = IRQ_LEVEL_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nmode = IRQ_LEVEL_LOW;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&pctl->lock, flags);\r\nregval = readl(pctl->membase + reg);\r\nregval &= ~(IRQ_CFG_IRQ_MASK << index);\r\nwritel(regval | (mode << index), pctl->membase + reg);\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void sunxi_pinctrl_irq_mask_ack(struct irq_data *d)\r\n{\r\nstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nu32 ctrl_reg = sunxi_irq_ctrl_reg(d->hwirq);\r\nu8 ctrl_idx = sunxi_irq_ctrl_offset(d->hwirq);\r\nu32 status_reg = sunxi_irq_status_reg(d->hwirq);\r\nu8 status_idx = sunxi_irq_status_offset(d->hwirq);\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&pctl->lock, flags);\r\nval = readl(pctl->membase + ctrl_reg);\r\nwritel(val & ~(1 << ctrl_idx), pctl->membase + ctrl_reg);\r\nwritel(1 << status_idx, pctl->membase + status_reg);\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\n}\r\nstatic void sunxi_pinctrl_irq_mask(struct irq_data *d)\r\n{\r\nstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nu32 reg = sunxi_irq_ctrl_reg(d->hwirq);\r\nu8 idx = sunxi_irq_ctrl_offset(d->hwirq);\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&pctl->lock, flags);\r\nval = readl(pctl->membase + reg);\r\nwritel(val & ~(1 << idx), pctl->membase + reg);\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\n}\r\nstatic void sunxi_pinctrl_irq_unmask(struct irq_data *d)\r\n{\r\nstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nstruct sunxi_desc_function *func;\r\nu32 reg = sunxi_irq_ctrl_reg(d->hwirq);\r\nu8 idx = sunxi_irq_ctrl_offset(d->hwirq);\r\nunsigned long flags;\r\nu32 val;\r\nfunc = sunxi_pinctrl_desc_find_function_by_pin(pctl,\r\npctl->irq_array[d->hwirq],\r\n"irq");\r\nsunxi_pmx_set(pctl->pctl_dev, pctl->irq_array[d->hwirq], func->muxval);\r\nspin_lock_irqsave(&pctl->lock, flags);\r\nval = readl(pctl->membase + reg);\r\nwritel(val | (1 << idx), pctl->membase + reg);\r\nspin_unlock_irqrestore(&pctl->lock, flags);\r\n}\r\nstatic void sunxi_pinctrl_irq_handler(unsigned irq, struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_get_chip(irq);\r\nstruct sunxi_pinctrl *pctl = irq_get_handler_data(irq);\r\nconst unsigned long reg = readl(pctl->membase + IRQ_STATUS_REG);\r\nwritel(reg, pctl->membase + IRQ_STATUS_REG);\r\nif (reg) {\r\nint irqoffset;\r\nchained_irq_enter(chip, desc);\r\nfor_each_set_bit(irqoffset, &reg, SUNXI_IRQ_NUMBER) {\r\nint pin_irq = irq_find_mapping(pctl->domain, irqoffset);\r\ngeneric_handle_irq(pin_irq);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\n}\r\nstatic int sunxi_pinctrl_add_function(struct sunxi_pinctrl *pctl,\r\nconst char *name)\r\n{\r\nstruct sunxi_pinctrl_function *func = pctl->functions;\r\nwhile (func->name) {\r\nif (strcmp(func->name, name) == 0) {\r\nfunc->ngroups++;\r\nreturn -EEXIST;\r\n}\r\nfunc++;\r\n}\r\nfunc->name = name;\r\nfunc->ngroups = 1;\r\npctl->nfunctions++;\r\nreturn 0;\r\n}\r\nstatic int sunxi_pinctrl_build_state(struct platform_device *pdev)\r\n{\r\nstruct sunxi_pinctrl *pctl = platform_get_drvdata(pdev);\r\nint i;\r\npctl->ngroups = pctl->desc->npins;\r\npctl->groups = devm_kzalloc(&pdev->dev,\r\npctl->ngroups * sizeof(*pctl->groups),\r\nGFP_KERNEL);\r\nif (!pctl->groups)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pctl->desc->npins; i++) {\r\nconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\r\nstruct sunxi_pinctrl_group *group = pctl->groups + i;\r\ngroup->name = pin->pin.name;\r\ngroup->pin = pin->pin.number;\r\n}\r\npctl->functions = devm_kzalloc(&pdev->dev,\r\npctl->desc->npins * sizeof(*pctl->functions),\r\nGFP_KERNEL);\r\nif (!pctl->functions)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pctl->desc->npins; i++) {\r\nconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\r\nstruct sunxi_desc_function *func = pin->functions;\r\nwhile (func->name) {\r\nsunxi_pinctrl_add_function(pctl, func->name);\r\nfunc++;\r\n}\r\n}\r\npctl->functions = krealloc(pctl->functions,\r\npctl->nfunctions * sizeof(*pctl->functions),\r\nGFP_KERNEL);\r\nfor (i = 0; i < pctl->desc->npins; i++) {\r\nconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\r\nstruct sunxi_desc_function *func = pin->functions;\r\nwhile (func->name) {\r\nstruct sunxi_pinctrl_function *func_item;\r\nconst char **func_grp;\r\nfunc_item = sunxi_pinctrl_find_function_by_name(pctl,\r\nfunc->name);\r\nif (!func_item)\r\nreturn -EINVAL;\r\nif (!func_item->groups) {\r\nfunc_item->groups =\r\ndevm_kzalloc(&pdev->dev,\r\nfunc_item->ngroups * sizeof(*func_item->groups),\r\nGFP_KERNEL);\r\nif (!func_item->groups)\r\nreturn -ENOMEM;\r\n}\r\nfunc_grp = func_item->groups;\r\nwhile (*func_grp)\r\nfunc_grp++;\r\n*func_grp = pin->pin.name;\r\nfunc++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sunxi_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst struct of_device_id *device;\r\nstruct pinctrl_pin_desc *pins;\r\nstruct sunxi_pinctrl *pctl;\r\nint i, ret, last_pin;\r\nstruct clk *clk;\r\npctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);\r\nif (!pctl)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, pctl);\r\nspin_lock_init(&pctl->lock);\r\npctl->membase = of_iomap(node, 0);\r\nif (!pctl->membase)\r\nreturn -ENOMEM;\r\ndevice = of_match_device(sunxi_pinctrl_match, &pdev->dev);\r\nif (!device)\r\nreturn -ENODEV;\r\npctl->desc = (struct sunxi_pinctrl_desc *)device->data;\r\nret = sunxi_pinctrl_build_state(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "dt probe failed: %d\n", ret);\r\nreturn ret;\r\n}\r\npins = devm_kzalloc(&pdev->dev,\r\npctl->desc->npins * sizeof(*pins),\r\nGFP_KERNEL);\r\nif (!pins)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pctl->desc->npins; i++)\r\npins[i] = pctl->desc->pins[i].pin;\r\nsunxi_pctrl_desc.name = dev_name(&pdev->dev);\r\nsunxi_pctrl_desc.owner = THIS_MODULE;\r\nsunxi_pctrl_desc.pins = pins;\r\nsunxi_pctrl_desc.npins = pctl->desc->npins;\r\npctl->dev = &pdev->dev;\r\npctl->pctl_dev = pinctrl_register(&sunxi_pctrl_desc,\r\n&pdev->dev, pctl);\r\nif (!pctl->pctl_dev) {\r\ndev_err(&pdev->dev, "couldn't register pinctrl driver\n");\r\nreturn -EINVAL;\r\n}\r\npctl->chip = devm_kzalloc(&pdev->dev, sizeof(*pctl->chip), GFP_KERNEL);\r\nif (!pctl->chip) {\r\nret = -ENOMEM;\r\ngoto pinctrl_error;\r\n}\r\nlast_pin = pctl->desc->pins[pctl->desc->npins - 1].pin.number;\r\npctl->chip = &sunxi_pinctrl_gpio_chip;\r\npctl->chip->ngpio = round_up(last_pin, PINS_PER_BANK);\r\npctl->chip->label = dev_name(&pdev->dev);\r\npctl->chip->dev = &pdev->dev;\r\npctl->chip->base = 0;\r\nret = gpiochip_add(pctl->chip);\r\nif (ret)\r\ngoto pinctrl_error;\r\nfor (i = 0; i < pctl->desc->npins; i++) {\r\nconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\r\nret = gpiochip_add_pin_range(pctl->chip, dev_name(&pdev->dev),\r\npin->pin.number,\r\npin->pin.number, 1);\r\nif (ret)\r\ngoto gpiochip_error;\r\n}\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\ngoto gpiochip_error;\r\n}\r\nclk_prepare_enable(clk);\r\npctl->irq = irq_of_parse_and_map(node, 0);\r\nif (!pctl->irq) {\r\nret = -EINVAL;\r\ngoto gpiochip_error;\r\n}\r\npctl->domain = irq_domain_add_linear(node, SUNXI_IRQ_NUMBER,\r\n&irq_domain_simple_ops, NULL);\r\nif (!pctl->domain) {\r\ndev_err(&pdev->dev, "Couldn't register IRQ domain\n");\r\nret = -ENOMEM;\r\ngoto gpiochip_error;\r\n}\r\nfor (i = 0; i < SUNXI_IRQ_NUMBER; i++) {\r\nint irqno = irq_create_mapping(pctl->domain, i);\r\nirq_set_chip_and_handler(irqno, &sunxi_pinctrl_irq_chip,\r\nhandle_simple_irq);\r\nirq_set_chip_data(irqno, pctl);\r\n};\r\nirq_set_chained_handler(pctl->irq, sunxi_pinctrl_irq_handler);\r\nirq_set_handler_data(pctl->irq, pctl);\r\ndev_info(&pdev->dev, "initialized sunXi PIO driver\n");\r\nreturn 0;\r\ngpiochip_error:\r\nif (gpiochip_remove(pctl->chip))\r\ndev_err(&pdev->dev, "failed to remove gpio chip\n");\r\npinctrl_error:\r\npinctrl_unregister(pctl->pctl_dev);\r\nreturn ret;\r\n}
