u16\r\nnvbios_disp_table(struct nouveau_bios *bios,\r\nu8 *ver, u8 *hdr, u8 *cnt, u8 *len, u8 *sub)\r\n{\r\nstruct bit_entry U;\r\nif (!bit_entry(bios, 'U', &U)) {\r\nif (U.version == 1) {\r\nu16 data = nv_ro16(bios, U.offset);\r\nif (data) {\r\n*ver = nv_ro08(bios, data + 0x00);\r\nswitch (*ver) {\r\ncase 0x20:\r\ncase 0x21:\r\n*hdr = nv_ro08(bios, data + 0x01);\r\n*len = nv_ro08(bios, data + 0x02);\r\n*cnt = nv_ro08(bios, data + 0x03);\r\n*sub = nv_ro08(bios, data + 0x04);\r\nreturn data;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0x0000;\r\n}\r\nu16\r\nnvbios_disp_entry(struct nouveau_bios *bios, u8 idx,\r\nu8 *ver, u8 *len, u8 *sub)\r\n{\r\nu8 hdr, cnt;\r\nu16 data = nvbios_disp_table(bios, ver, &hdr, &cnt, len, sub);\r\nif (data && idx < cnt)\r\nreturn data + hdr + (idx * *len);\r\n*ver = 0x00;\r\nreturn 0x0000;\r\n}\r\nu16\r\nnvbios_disp_parse(struct nouveau_bios *bios, u8 idx,\r\nu8 *ver, u8 *len, u8 *sub,\r\nstruct nvbios_disp *info)\r\n{\r\nu16 data = nvbios_disp_entry(bios, idx, ver, len, sub);\r\nif (data && *len >= 2) {\r\ninfo->data = nv_ro16(bios, data + 0);\r\nreturn data;\r\n}\r\nreturn 0x0000;\r\n}\r\nu16\r\nnvbios_outp_entry(struct nouveau_bios *bios, u8 idx,\r\nu8 *ver, u8 *hdr, u8 *cnt, u8 *len)\r\n{\r\nstruct nvbios_disp info;\r\nu16 data = nvbios_disp_parse(bios, idx, ver, len, hdr, &info);\r\nif (data) {\r\n*cnt = nv_ro08(bios, info.data + 0x05);\r\n*len = 0x06;\r\ndata = info.data;\r\n}\r\nreturn data;\r\n}\r\nu16\r\nnvbios_outp_parse(struct nouveau_bios *bios, u8 idx,\r\nu8 *ver, u8 *hdr, u8 *cnt, u8 *len,\r\nstruct nvbios_outp *info)\r\n{\r\nu16 data = nvbios_outp_entry(bios, idx, ver, hdr, cnt, len);\r\nif (data && *hdr >= 0x0a) {\r\ninfo->type = nv_ro16(bios, data + 0x00);\r\ninfo->mask = nv_ro32(bios, data + 0x02);\r\nif (*ver <= 0x20)\r\ninfo->mask |= 0x00c0;\r\ninfo->script[0] = nv_ro16(bios, data + 0x06);\r\ninfo->script[1] = nv_ro16(bios, data + 0x08);\r\ninfo->script[2] = 0x0000;\r\nif (*hdr >= 0x0c)\r\ninfo->script[2] = nv_ro16(bios, data + 0x0a);\r\nreturn data;\r\n}\r\nreturn 0x0000;\r\n}\r\nu16\r\nnvbios_outp_match(struct nouveau_bios *bios, u16 type, u16 mask,\r\nu8 *ver, u8 *hdr, u8 *cnt, u8 *len,\r\nstruct nvbios_outp *info)\r\n{\r\nu16 data, idx = 0;\r\nwhile ((data = nvbios_outp_parse(bios, idx++, ver, hdr, cnt, len, info)) || *ver) {\r\nif (data && info->type == type) {\r\nif ((info->mask & mask) == mask)\r\nbreak;\r\n}\r\n}\r\nreturn data;\r\n}\r\nu16\r\nnvbios_ocfg_entry(struct nouveau_bios *bios, u16 outp, u8 idx,\r\nu8 *ver, u8 *hdr, u8 *cnt, u8 *len)\r\n{\r\nif (idx < *cnt)\r\nreturn outp + *hdr + (idx * *len);\r\nreturn 0x0000;\r\n}\r\nu16\r\nnvbios_ocfg_parse(struct nouveau_bios *bios, u16 outp, u8 idx,\r\nu8 *ver, u8 *hdr, u8 *cnt, u8 *len,\r\nstruct nvbios_ocfg *info)\r\n{\r\nu16 data = nvbios_ocfg_entry(bios, outp, idx, ver, hdr, cnt, len);\r\nif (data) {\r\ninfo->match = nv_ro16(bios, data + 0x00);\r\ninfo->clkcmp[0] = nv_ro16(bios, data + 0x02);\r\ninfo->clkcmp[1] = nv_ro16(bios, data + 0x04);\r\n}\r\nreturn data;\r\n}\r\nu16\r\nnvbios_ocfg_match(struct nouveau_bios *bios, u16 outp, u16 type,\r\nu8 *ver, u8 *hdr, u8 *cnt, u8 *len,\r\nstruct nvbios_ocfg *info)\r\n{\r\nu16 data, idx = 0;\r\nwhile ((data = nvbios_ocfg_parse(bios, outp, idx++, ver, hdr, cnt, len, info))) {\r\nif (info->match == type)\r\nbreak;\r\n}\r\nreturn data;\r\n}\r\nu16\r\nnvbios_oclk_match(struct nouveau_bios *bios, u16 cmp, u32 khz)\r\n{\r\nwhile (cmp) {\r\nif (khz / 10 >= nv_ro16(bios, cmp + 0x00))\r\nreturn nv_ro16(bios, cmp + 0x02);\r\ncmp += 0x04;\r\n}\r\nreturn 0x0000;\r\n}
