static int\r\ntap_configure(struct mic_info *mic, char *dev)\r\n{\r\npid_t pid;\r\nchar *ifargv[7];\r\nchar ipaddr[IFNAMSIZ];\r\nint ret = 0;\r\npid = fork();\r\nif (pid == 0) {\r\nifargv[0] = "ip";\r\nifargv[1] = "link";\r\nifargv[2] = "set";\r\nifargv[3] = dev;\r\nifargv[4] = "up";\r\nifargv[5] = NULL;\r\nmpsslog("Configuring %s\n", dev);\r\nret = execvp("ip", ifargv);\r\nif (ret < 0) {\r\nmpsslog("%s execvp failed errno %s\n",\r\nmic->name, strerror(errno));\r\nreturn ret;\r\n}\r\n}\r\nif (pid < 0) {\r\nmpsslog("%s fork failed errno %s\n",\r\nmic->name, strerror(errno));\r\nreturn ret;\r\n}\r\nret = waitpid(pid, NULL, 0);\r\nif (ret < 0) {\r\nmpsslog("%s waitpid failed errno %s\n",\r\nmic->name, strerror(errno));\r\nreturn ret;\r\n}\r\nsnprintf(ipaddr, IFNAMSIZ, "172.31.%d.254/24", mic->id);\r\npid = fork();\r\nif (pid == 0) {\r\nifargv[0] = "ip";\r\nifargv[1] = "addr";\r\nifargv[2] = "add";\r\nifargv[3] = ipaddr;\r\nifargv[4] = "dev";\r\nifargv[5] = dev;\r\nifargv[6] = NULL;\r\nmpsslog("Configuring %s ipaddr %s\n", dev, ipaddr);\r\nret = execvp("ip", ifargv);\r\nif (ret < 0) {\r\nmpsslog("%s execvp failed errno %s\n",\r\nmic->name, strerror(errno));\r\nreturn ret;\r\n}\r\n}\r\nif (pid < 0) {\r\nmpsslog("%s fork failed errno %s\n",\r\nmic->name, strerror(errno));\r\nreturn ret;\r\n}\r\nret = waitpid(pid, NULL, 0);\r\nif (ret < 0) {\r\nmpsslog("%s waitpid failed errno %s\n",\r\nmic->name, strerror(errno));\r\nreturn ret;\r\n}\r\nmpsslog("MIC name %s %s %d DONE!\n",\r\nmic->name, __func__, __LINE__);\r\nreturn 0;\r\n}\r\nstatic int tun_alloc(struct mic_info *mic, char *dev)\r\n{\r\nstruct ifreq ifr;\r\nint fd, err;\r\n#if GSO_ENABLED\r\nunsigned offload;\r\n#endif\r\nfd = open("/dev/net/tun", O_RDWR);\r\nif (fd < 0) {\r\nmpsslog("Could not open /dev/net/tun %s\n", strerror(errno));\r\ngoto done;\r\n}\r\nmemset(&ifr, 0, sizeof(ifr));\r\nifr.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_VNET_HDR;\r\nif (*dev)\r\nstrncpy(ifr.ifr_name, dev, IFNAMSIZ);\r\nerr = ioctl(fd, TUNSETIFF, (void *)&ifr);\r\nif (err < 0) {\r\nmpsslog("%s %s %d TUNSETIFF failed %s\n",\r\nmic->name, __func__, __LINE__, strerror(errno));\r\nclose(fd);\r\nreturn err;\r\n}\r\n#if GSO_ENABLED\r\noffload = TUN_F_CSUM | TUN_F_TSO4 | TUN_F_TSO6 |\r\nTUN_F_TSO_ECN | TUN_F_UFO;\r\nerr = ioctl(fd, TUNSETOFFLOAD, offload);\r\nif (err < 0) {\r\nmpsslog("%s %s %d TUNSETOFFLOAD failed %s\n",\r\nmic->name, __func__, __LINE__, strerror(errno));\r\nclose(fd);\r\nreturn err;\r\n}\r\n#endif\r\nstrcpy(dev, ifr.ifr_name);\r\nmpsslog("Created TAP %s\n", dev);\r\ndone:\r\nreturn fd;\r\n}\r\nstatic void set_dp(struct mic_info *mic, int type, void *dp)\r\n{\r\nswitch (type) {\r\ncase VIRTIO_ID_CONSOLE:\r\nmic->mic_console.console_dp = dp;\r\nreturn;\r\ncase VIRTIO_ID_NET:\r\nmic->mic_net.net_dp = dp;\r\nreturn;\r\ncase VIRTIO_ID_BLOCK:\r\nmic->mic_virtblk.block_dp = dp;\r\nreturn;\r\n}\r\nmpsslog("%s %s %d not found\n", mic->name, __func__, type);\r\nassert(0);\r\n}\r\nstatic void *get_dp(struct mic_info *mic, int type)\r\n{\r\nswitch (type) {\r\ncase VIRTIO_ID_CONSOLE:\r\nreturn mic->mic_console.console_dp;\r\ncase VIRTIO_ID_NET:\r\nreturn mic->mic_net.net_dp;\r\ncase VIRTIO_ID_BLOCK:\r\nreturn mic->mic_virtblk.block_dp;\r\n}\r\nmpsslog("%s %s %d not found\n", mic->name, __func__, type);\r\nassert(0);\r\nreturn NULL;\r\n}\r\nstatic struct mic_device_desc *get_device_desc(struct mic_info *mic, int type)\r\n{\r\nstruct mic_device_desc *d;\r\nint i;\r\nvoid *dp = get_dp(mic, type);\r\nfor (i = sizeof(struct mic_bootparam); i < PAGE_SIZE;\r\ni += mic_total_desc_size(d)) {\r\nd = dp + i;\r\nif (d->type == 0)\r\nbreak;\r\nif (d->type == -1)\r\ncontinue;\r\nmpsslog("%s %s d-> type %d d %p\n",\r\nmic->name, __func__, d->type, d);\r\nif (d->type == (__u8)type)\r\nreturn d;\r\n}\r\nmpsslog("%s %s %d not found\n", mic->name, __func__, type);\r\nassert(0);\r\nreturn NULL;\r\n}\r\nstatic unsigned next_desc(struct vring_desc *desc)\r\n{\r\nunsigned int next;\r\nif (!(le16toh(desc->flags) & VRING_DESC_F_NEXT))\r\nreturn -1U;\r\nnext = le16toh(desc->next);\r\nreturn next;\r\n}\r\nstatic ssize_t\r\nsum_iovec_len(struct mic_copy_desc *copy)\r\n{\r\nssize_t sum = 0;\r\nint i;\r\nfor (i = 0; i < copy->iovcnt; i++)\r\nsum += copy->iov[i].iov_len;\r\nreturn sum;\r\n}\r\nstatic inline void verify_out_len(struct mic_info *mic,\r\nstruct mic_copy_desc *copy)\r\n{\r\nif (copy->out_len != sum_iovec_len(copy)) {\r\nmpsslog("%s %s %d BUG copy->out_len 0x%x len 0x%zx\n",\r\nmic->name, __func__, __LINE__,\r\ncopy->out_len, sum_iovec_len(copy));\r\nassert(copy->out_len == sum_iovec_len(copy));\r\n}\r\n}\r\nstatic void\r\ndisp_iovec(struct mic_info *mic, struct mic_copy_desc *copy,\r\nconst char *s, int line)\r\n{\r\nint i;\r\nfor (i = 0; i < copy->iovcnt; i++)\r\nmpsslog("%s %s %d copy->iov[%d] addr %p len 0x%zx\n",\r\nmic->name, s, line, i,\r\ncopy->iov[i].iov_base, copy->iov[i].iov_len);\r\n}\r\nstatic inline __u16 read_avail_idx(struct mic_vring *vr)\r\n{\r\nreturn ACCESS_ONCE(vr->info->avail_idx);\r\n}\r\nstatic inline void txrx_prepare(int type, bool tx, struct mic_vring *vr,\r\nstruct mic_copy_desc *copy, ssize_t len)\r\n{\r\ncopy->vr_idx = tx ? 0 : 1;\r\ncopy->update_used = true;\r\nif (type == VIRTIO_ID_NET)\r\ncopy->iov[1].iov_len = len - sizeof(struct virtio_net_hdr);\r\nelse\r\ncopy->iov[0].iov_len = len;\r\n}\r\nstatic int\r\nmic_virtio_copy(struct mic_info *mic, int fd,\r\nstruct mic_vring *vr, struct mic_copy_desc *copy)\r\n{\r\nint ret;\r\nret = ioctl(fd, MIC_VIRTIO_COPY_DESC, copy);\r\nif (ret) {\r\nmpsslog("%s %s %d errno %s ret %d\n",\r\nmic->name, __func__, __LINE__,\r\nstrerror(errno), ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void *\r\ninit_vr(struct mic_info *mic, int fd, int type,\r\nstruct mic_vring *vr0, struct mic_vring *vr1, int num_vq)\r\n{\r\nint vr_size;\r\nchar *va;\r\nvr_size = PAGE_ALIGN(vring_size(MIC_VRING_ENTRIES,\r\nMIC_VIRTIO_RING_ALIGN) + sizeof(struct _mic_vring_info));\r\nva = mmap(NULL, MIC_DEVICE_PAGE_END + vr_size * num_vq,\r\nPROT_READ, MAP_SHARED, fd, 0);\r\nif (MAP_FAILED == va) {\r\nmpsslog("%s %s %d mmap failed errno %s\n",\r\nmic->name, __func__, __LINE__,\r\nstrerror(errno));\r\ngoto done;\r\n}\r\nset_dp(mic, type, va);\r\nvr0->va = (struct mic_vring *)&va[MIC_DEVICE_PAGE_END];\r\nvr0->info = vr0->va +\r\nvring_size(MIC_VRING_ENTRIES, MIC_VIRTIO_RING_ALIGN);\r\nvring_init(&vr0->vr,\r\nMIC_VRING_ENTRIES, vr0->va, MIC_VIRTIO_RING_ALIGN);\r\nmpsslog("%s %s vr0 %p vr0->info %p vr_size 0x%x vring 0x%x ",\r\n__func__, mic->name, vr0->va, vr0->info, vr_size,\r\nvring_size(MIC_VRING_ENTRIES, MIC_VIRTIO_RING_ALIGN));\r\nmpsslog("magic 0x%x expected 0x%x\n",\r\nle32toh(vr0->info->magic), MIC_MAGIC + type);\r\nassert(le32toh(vr0->info->magic) == MIC_MAGIC + type);\r\nif (vr1) {\r\nvr1->va = (struct mic_vring *)\r\n&va[MIC_DEVICE_PAGE_END + vr_size];\r\nvr1->info = vr1->va + vring_size(MIC_VRING_ENTRIES,\r\nMIC_VIRTIO_RING_ALIGN);\r\nvring_init(&vr1->vr,\r\nMIC_VRING_ENTRIES, vr1->va, MIC_VIRTIO_RING_ALIGN);\r\nmpsslog("%s %s vr1 %p vr1->info %p vr_size 0x%x vring 0x%x ",\r\n__func__, mic->name, vr1->va, vr1->info, vr_size,\r\nvring_size(MIC_VRING_ENTRIES, MIC_VIRTIO_RING_ALIGN));\r\nmpsslog("magic 0x%x expected 0x%x\n",\r\nle32toh(vr1->info->magic), MIC_MAGIC + type + 1);\r\nassert(le32toh(vr1->info->magic) == MIC_MAGIC + type + 1);\r\n}\r\ndone:\r\nreturn va;\r\n}\r\nstatic void\r\nwait_for_card_driver(struct mic_info *mic, int fd, int type)\r\n{\r\nstruct pollfd pollfd;\r\nint err;\r\nstruct mic_device_desc *desc = get_device_desc(mic, type);\r\npollfd.fd = fd;\r\nmpsslog("%s %s Waiting .... desc-> type %d status 0x%x\n",\r\nmic->name, __func__, type, desc->status);\r\nwhile (1) {\r\npollfd.events = POLLIN;\r\npollfd.revents = 0;\r\nerr = poll(&pollfd, 1, -1);\r\nif (err < 0) {\r\nmpsslog("%s %s poll failed %s\n",\r\nmic->name, __func__, strerror(errno));\r\ncontinue;\r\n}\r\nif (pollfd.revents) {\r\nmpsslog("%s %s Waiting... desc-> type %d status 0x%x\n",\r\nmic->name, __func__, type, desc->status);\r\nif (desc->status & VIRTIO_CONFIG_S_DRIVER_OK) {\r\nmpsslog("%s %s poll.revents %d\n",\r\nmic->name, __func__, pollfd.revents);\r\nmpsslog("%s %s desc-> type %d status 0x%x\n",\r\nmic->name, __func__, type,\r\ndesc->status);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nspin_for_descriptors(struct mic_info *mic, struct mic_vring *vr)\r\n{\r\n__u16 avail_idx = read_avail_idx(vr);\r\nwhile (avail_idx == le16toh(ACCESS_ONCE(vr->vr.avail->idx))) {\r\n#ifdef DEBUG\r\nmpsslog("%s %s waiting for desc avail %d info_avail %d\n",\r\nmic->name, __func__,\r\nle16toh(vr->vr.avail->idx), vr->info->avail_idx);\r\n#endif\r\nsched_yield();\r\n}\r\n}\r\nstatic void *\r\nvirtio_net(void *arg)\r\n{\r\nstatic __u8 vnet_hdr[2][sizeof(struct virtio_net_hdr)];\r\nstatic __u8 vnet_buf[2][MAX_NET_PKT_SIZE] __attribute__ ((aligned(64)));\r\nstruct iovec vnet_iov[2][2] = {\r\n{ { .iov_base = vnet_hdr[0], .iov_len = sizeof(vnet_hdr[0]) },\r\n{ .iov_base = vnet_buf[0], .iov_len = sizeof(vnet_buf[0]) } },\r\n{ { .iov_base = vnet_hdr[1], .iov_len = sizeof(vnet_hdr[1]) },\r\n{ .iov_base = vnet_buf[1], .iov_len = sizeof(vnet_buf[1]) } },\r\n};\r\nstruct iovec *iov0 = vnet_iov[0], *iov1 = vnet_iov[1];\r\nstruct mic_info *mic = (struct mic_info *)arg;\r\nchar if_name[IFNAMSIZ];\r\nstruct pollfd net_poll[MAX_NET_FD];\r\nstruct mic_vring tx_vr, rx_vr;\r\nstruct mic_copy_desc copy;\r\nstruct mic_device_desc *desc;\r\nint err;\r\nsnprintf(if_name, IFNAMSIZ, "mic%d", mic->id);\r\nmic->mic_net.tap_fd = tun_alloc(mic, if_name);\r\nif (mic->mic_net.tap_fd < 0)\r\ngoto done;\r\nif (tap_configure(mic, if_name))\r\ngoto done;\r\nmpsslog("MIC name %s id %d\n", mic->name, mic->id);\r\nnet_poll[NET_FD_VIRTIO_NET].fd = mic->mic_net.virtio_net_fd;\r\nnet_poll[NET_FD_VIRTIO_NET].events = POLLIN;\r\nnet_poll[NET_FD_TUN].fd = mic->mic_net.tap_fd;\r\nnet_poll[NET_FD_TUN].events = POLLIN;\r\nif (MAP_FAILED == init_vr(mic, mic->mic_net.virtio_net_fd,\r\nVIRTIO_ID_NET, &tx_vr, &rx_vr,\r\nvirtnet_dev_page.dd.num_vq)) {\r\nmpsslog("%s init_vr failed %s\n",\r\nmic->name, strerror(errno));\r\ngoto done;\r\n}\r\ncopy.iovcnt = 2;\r\ndesc = get_device_desc(mic, VIRTIO_ID_NET);\r\nwhile (1) {\r\nssize_t len;\r\nnet_poll[NET_FD_VIRTIO_NET].revents = 0;\r\nnet_poll[NET_FD_TUN].revents = 0;\r\nerr = poll(net_poll, 2, -1);\r\nif (err < 0) {\r\nmpsslog("%s poll failed %s\n",\r\n__func__, strerror(errno));\r\ncontinue;\r\n}\r\nif (!(desc->status & VIRTIO_CONFIG_S_DRIVER_OK))\r\nwait_for_card_driver(mic, mic->mic_net.virtio_net_fd,\r\nVIRTIO_ID_NET);\r\nif (net_poll[NET_FD_TUN].revents & POLLIN) {\r\ncopy.iov = iov0;\r\nlen = readv(net_poll[NET_FD_TUN].fd,\r\ncopy.iov, copy.iovcnt);\r\nif (len > 0) {\r\nstruct virtio_net_hdr *hdr\r\n= (struct virtio_net_hdr *)vnet_hdr[0];\r\nhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\r\n#ifdef DEBUG\r\nmpsslog("%s %s %d hdr->flags 0x%x ", mic->name,\r\n__func__, __LINE__, hdr->flags);\r\nmpsslog("copy.out_len %d hdr->gso_type 0x%x\n",\r\ncopy.out_len, hdr->gso_type);\r\n#endif\r\n#ifdef DEBUG\r\ndisp_iovec(mic, copy, __func__, __LINE__);\r\nmpsslog("%s %s %d read from tap 0x%lx\n",\r\nmic->name, __func__, __LINE__,\r\nlen);\r\n#endif\r\nspin_for_descriptors(mic, &tx_vr);\r\ntxrx_prepare(VIRTIO_ID_NET, 1, &tx_vr, &copy,\r\nlen);\r\nerr = mic_virtio_copy(mic,\r\nmic->mic_net.virtio_net_fd, &tx_vr,\r\n&copy);\r\nif (err < 0) {\r\nmpsslog("%s %s %d mic_virtio_copy %s\n",\r\nmic->name, __func__, __LINE__,\r\nstrerror(errno));\r\n}\r\nif (!err)\r\nverify_out_len(mic, &copy);\r\n#ifdef DEBUG\r\ndisp_iovec(mic, copy, __func__, __LINE__);\r\nmpsslog("%s %s %d wrote to net 0x%lx\n",\r\nmic->name, __func__, __LINE__,\r\nsum_iovec_len(&copy));\r\n#endif\r\niov0[1].iov_len = MAX_NET_PKT_SIZE;\r\n} else if (len < 0) {\r\ndisp_iovec(mic, &copy, __func__, __LINE__);\r\nmpsslog("%s %s %d read failed %s ", mic->name,\r\n__func__, __LINE__, strerror(errno));\r\nmpsslog("cnt %d sum %zd\n",\r\ncopy.iovcnt, sum_iovec_len(&copy));\r\n}\r\n}\r\nif (net_poll[NET_FD_VIRTIO_NET].revents & POLLIN) {\r\nwhile (rx_vr.info->avail_idx !=\r\nle16toh(rx_vr.vr.avail->idx)) {\r\ncopy.iov = iov1;\r\ntxrx_prepare(VIRTIO_ID_NET, 0, &rx_vr, &copy,\r\nMAX_NET_PKT_SIZE\r\n+ sizeof(struct virtio_net_hdr));\r\nerr = mic_virtio_copy(mic,\r\nmic->mic_net.virtio_net_fd, &rx_vr,\r\n&copy);\r\nif (!err) {\r\n#ifdef DEBUG\r\nstruct virtio_net_hdr *hdr\r\n= (struct virtio_net_hdr *)\r\nvnet_hdr[1];\r\nmpsslog("%s %s %d hdr->flags 0x%x, ",\r\nmic->name, __func__, __LINE__,\r\nhdr->flags);\r\nmpsslog("out_len %d gso_type 0x%x\n",\r\ncopy.out_len,\r\nhdr->gso_type);\r\n#endif\r\niov1[1].iov_len = copy.out_len -\r\nsizeof(struct virtio_net_hdr);\r\nverify_out_len(mic, &copy);\r\n#ifdef DEBUG\r\ndisp_iovec(mic, copy, __func__,\r\n__LINE__);\r\nmpsslog("%s %s %d ",\r\nmic->name, __func__, __LINE__);\r\nmpsslog("read from net 0x%lx\n",\r\nsum_iovec_len(copy));\r\n#endif\r\nlen = writev(net_poll[NET_FD_TUN].fd,\r\ncopy.iov, copy.iovcnt);\r\nif (len != sum_iovec_len(&copy)) {\r\nmpsslog("Tun write failed %s ",\r\nstrerror(errno));\r\nmpsslog("len 0x%zx ", len);\r\nmpsslog("read_len 0x%zx\n",\r\nsum_iovec_len(&copy));\r\n} else {\r\n#ifdef DEBUG\r\ndisp_iovec(mic, &copy, __func__,\r\n__LINE__);\r\nmpsslog("%s %s %d ",\r\nmic->name, __func__,\r\n__LINE__);\r\nmpsslog("wrote to tap 0x%lx\n",\r\nlen);\r\n#endif\r\n}\r\n} else {\r\nmpsslog("%s %s %d mic_virtio_copy %s\n",\r\nmic->name, __func__, __LINE__,\r\nstrerror(errno));\r\nbreak;\r\n}\r\n}\r\n}\r\nif (net_poll[NET_FD_VIRTIO_NET].revents & POLLERR)\r\nmpsslog("%s: %s: POLLERR\n", __func__, mic->name);\r\n}\r\ndone:\r\npthread_exit(NULL);\r\n}\r\nstatic void *\r\nvirtio_console(void *arg)\r\n{\r\nstatic __u8 vcons_buf[2][PAGE_SIZE];\r\nstruct iovec vcons_iov[2] = {\r\n{ .iov_base = vcons_buf[0], .iov_len = sizeof(vcons_buf[0]) },\r\n{ .iov_base = vcons_buf[1], .iov_len = sizeof(vcons_buf[1]) },\r\n};\r\nstruct iovec *iov0 = &vcons_iov[0], *iov1 = &vcons_iov[1];\r\nstruct mic_info *mic = (struct mic_info *)arg;\r\nint err;\r\nstruct pollfd console_poll[MAX_CONSOLE_FD];\r\nint pty_fd;\r\nchar *pts_name;\r\nssize_t len;\r\nstruct mic_vring tx_vr, rx_vr;\r\nstruct mic_copy_desc copy;\r\nstruct mic_device_desc *desc;\r\npty_fd = posix_openpt(O_RDWR);\r\nif (pty_fd < 0) {\r\nmpsslog("can't open a pseudoterminal master device: %s\n",\r\nstrerror(errno));\r\ngoto _return;\r\n}\r\npts_name = ptsname(pty_fd);\r\nif (pts_name == NULL) {\r\nmpsslog("can't get pts name\n");\r\ngoto _close_pty;\r\n}\r\nprintf("%s console message goes to %s\n", mic->name, pts_name);\r\nmpsslog("%s console message goes to %s\n", mic->name, pts_name);\r\nerr = grantpt(pty_fd);\r\nif (err < 0) {\r\nmpsslog("can't grant access: %s %s\n",\r\npts_name, strerror(errno));\r\ngoto _close_pty;\r\n}\r\nerr = unlockpt(pty_fd);\r\nif (err < 0) {\r\nmpsslog("can't unlock a pseudoterminal: %s %s\n",\r\npts_name, strerror(errno));\r\ngoto _close_pty;\r\n}\r\nconsole_poll[MONITOR_FD].fd = pty_fd;\r\nconsole_poll[MONITOR_FD].events = POLLIN;\r\nconsole_poll[VIRTIO_CONSOLE_FD].fd = mic->mic_console.virtio_console_fd;\r\nconsole_poll[VIRTIO_CONSOLE_FD].events = POLLIN;\r\nif (MAP_FAILED == init_vr(mic, mic->mic_console.virtio_console_fd,\r\nVIRTIO_ID_CONSOLE, &tx_vr, &rx_vr,\r\nvirtcons_dev_page.dd.num_vq)) {\r\nmpsslog("%s init_vr failed %s\n",\r\nmic->name, strerror(errno));\r\ngoto _close_pty;\r\n}\r\ncopy.iovcnt = 1;\r\ndesc = get_device_desc(mic, VIRTIO_ID_CONSOLE);\r\nfor (;;) {\r\nconsole_poll[MONITOR_FD].revents = 0;\r\nconsole_poll[VIRTIO_CONSOLE_FD].revents = 0;\r\nerr = poll(console_poll, MAX_CONSOLE_FD, -1);\r\nif (err < 0) {\r\nmpsslog("%s %d: poll failed: %s\n", __func__, __LINE__,\r\nstrerror(errno));\r\ncontinue;\r\n}\r\nif (!(desc->status & VIRTIO_CONFIG_S_DRIVER_OK))\r\nwait_for_card_driver(mic,\r\nmic->mic_console.virtio_console_fd,\r\nVIRTIO_ID_CONSOLE);\r\nif (console_poll[MONITOR_FD].revents & POLLIN) {\r\ncopy.iov = iov0;\r\nlen = readv(pty_fd, copy.iov, copy.iovcnt);\r\nif (len > 0) {\r\n#ifdef DEBUG\r\ndisp_iovec(mic, copy, __func__, __LINE__);\r\nmpsslog("%s %s %d read from tap 0x%lx\n",\r\nmic->name, __func__, __LINE__,\r\nlen);\r\n#endif\r\nspin_for_descriptors(mic, &tx_vr);\r\ntxrx_prepare(VIRTIO_ID_CONSOLE, 1, &tx_vr,\r\n&copy, len);\r\nerr = mic_virtio_copy(mic,\r\nmic->mic_console.virtio_console_fd,\r\n&tx_vr, &copy);\r\nif (err < 0) {\r\nmpsslog("%s %s %d mic_virtio_copy %s\n",\r\nmic->name, __func__, __LINE__,\r\nstrerror(errno));\r\n}\r\nif (!err)\r\nverify_out_len(mic, &copy);\r\n#ifdef DEBUG\r\ndisp_iovec(mic, copy, __func__, __LINE__);\r\nmpsslog("%s %s %d wrote to net 0x%lx\n",\r\nmic->name, __func__, __LINE__,\r\nsum_iovec_len(copy));\r\n#endif\r\niov0->iov_len = PAGE_SIZE;\r\n} else if (len < 0) {\r\ndisp_iovec(mic, &copy, __func__, __LINE__);\r\nmpsslog("%s %s %d read failed %s ",\r\nmic->name, __func__, __LINE__,\r\nstrerror(errno));\r\nmpsslog("cnt %d sum %zd\n",\r\ncopy.iovcnt, sum_iovec_len(&copy));\r\n}\r\n}\r\nif (console_poll[VIRTIO_CONSOLE_FD].revents & POLLIN) {\r\nwhile (rx_vr.info->avail_idx !=\r\nle16toh(rx_vr.vr.avail->idx)) {\r\ncopy.iov = iov1;\r\ntxrx_prepare(VIRTIO_ID_CONSOLE, 0, &rx_vr,\r\n&copy, PAGE_SIZE);\r\nerr = mic_virtio_copy(mic,\r\nmic->mic_console.virtio_console_fd,\r\n&rx_vr, &copy);\r\nif (!err) {\r\niov1->iov_len = copy.out_len;\r\nverify_out_len(mic, &copy);\r\n#ifdef DEBUG\r\ndisp_iovec(mic, copy, __func__,\r\n__LINE__);\r\nmpsslog("%s %s %d ",\r\nmic->name, __func__, __LINE__);\r\nmpsslog("read from net 0x%lx\n",\r\nsum_iovec_len(copy));\r\n#endif\r\nlen = writev(pty_fd,\r\ncopy.iov, copy.iovcnt);\r\nif (len != sum_iovec_len(&copy)) {\r\nmpsslog("Tun write failed %s ",\r\nstrerror(errno));\r\nmpsslog("len 0x%zx ", len);\r\nmpsslog("read_len 0x%zx\n",\r\nsum_iovec_len(&copy));\r\n} else {\r\n#ifdef DEBUG\r\ndisp_iovec(mic, copy, __func__,\r\n__LINE__);\r\nmpsslog("%s %s %d ",\r\nmic->name, __func__,\r\n__LINE__);\r\nmpsslog("wrote to tap 0x%lx\n",\r\nlen);\r\n#endif\r\n}\r\n} else {\r\nmpsslog("%s %s %d mic_virtio_copy %s\n",\r\nmic->name, __func__, __LINE__,\r\nstrerror(errno));\r\nbreak;\r\n}\r\n}\r\n}\r\nif (console_poll[NET_FD_VIRTIO_NET].revents & POLLERR)\r\nmpsslog("%s: %s: POLLERR\n", __func__, mic->name);\r\n}\r\n_close_pty:\r\nclose(pty_fd);\r\n_return:\r\npthread_exit(NULL);\r\n}\r\nstatic void\r\nadd_virtio_device(struct mic_info *mic, struct mic_device_desc *dd)\r\n{\r\nchar path[PATH_MAX];\r\nint fd, err;\r\nsnprintf(path, PATH_MAX, "/dev/mic%d", mic->id);\r\nfd = open(path, O_RDWR);\r\nif (fd < 0) {\r\nmpsslog("Could not open %s %s\n", path, strerror(errno));\r\nreturn;\r\n}\r\nerr = ioctl(fd, MIC_VIRTIO_ADD_DEVICE, dd);\r\nif (err < 0) {\r\nmpsslog("Could not add %d %s\n", dd->type, strerror(errno));\r\nclose(fd);\r\nreturn;\r\n}\r\nswitch (dd->type) {\r\ncase VIRTIO_ID_NET:\r\nmic->mic_net.virtio_net_fd = fd;\r\nmpsslog("Added VIRTIO_ID_NET for %s\n", mic->name);\r\nbreak;\r\ncase VIRTIO_ID_CONSOLE:\r\nmic->mic_console.virtio_console_fd = fd;\r\nmpsslog("Added VIRTIO_ID_CONSOLE for %s\n", mic->name);\r\nbreak;\r\ncase VIRTIO_ID_BLOCK:\r\nmic->mic_virtblk.virtio_block_fd = fd;\r\nmpsslog("Added VIRTIO_ID_BLOCK for %s\n", mic->name);\r\nbreak;\r\n}\r\n}\r\nstatic bool\r\nset_backend_file(struct mic_info *mic)\r\n{\r\nFILE *config;\r\nchar buff[PATH_MAX], *line, *evv, *p;\r\nsnprintf(buff, PATH_MAX, "%s/mpssd%03d.conf", mic_config_dir, mic->id);\r\nconfig = fopen(buff, "r");\r\nif (config == NULL)\r\nreturn false;\r\ndo {\r\nline = fgets(buff, PATH_MAX, config);\r\nif (line == NULL)\r\nbreak;\r\nif (*line == '#')\r\ncontinue;\r\np = strchr(line, '\n');\r\nif (p)\r\n*p = '\0';\r\n} while (strncmp(line, virtblk_backend, strlen(virtblk_backend)) != 0);\r\nfclose(config);\r\nif (line == NULL)\r\nreturn false;\r\nevv = strchr(line, '=');\r\nif (evv == NULL)\r\nreturn false;\r\nmic->mic_virtblk.backend_file = malloc(strlen(evv) + 1);\r\nif (mic->mic_virtblk.backend_file == NULL) {\r\nmpsslog("%s %d can't allocate memory\n", mic->name, mic->id);\r\nreturn false;\r\n}\r\nstrcpy(mic->mic_virtblk.backend_file, evv + 1);\r\nreturn true;\r\n}\r\nstatic bool\r\nset_backend_size(struct mic_info *mic)\r\n{\r\nmic->mic_virtblk.backend_size = lseek(mic->mic_virtblk.backend, 0,\r\nSEEK_END);\r\nif (mic->mic_virtblk.backend_size < 0) {\r\nmpsslog("%s: can't seek: %s\n",\r\nmic->name, mic->mic_virtblk.backend_file);\r\nreturn false;\r\n}\r\nvirtblk_dev_page.blk_config.capacity =\r\nmic->mic_virtblk.backend_size / SECTOR_SIZE;\r\nif ((mic->mic_virtblk.backend_size % SECTOR_SIZE) != 0)\r\nvirtblk_dev_page.blk_config.capacity++;\r\nvirtblk_dev_page.blk_config.capacity =\r\nhtole64(virtblk_dev_page.blk_config.capacity);\r\nreturn true;\r\n}\r\nstatic bool\r\nopen_backend(struct mic_info *mic)\r\n{\r\nif (!set_backend_file(mic))\r\ngoto _error_exit;\r\nmic->mic_virtblk.backend = open(mic->mic_virtblk.backend_file, O_RDWR);\r\nif (mic->mic_virtblk.backend < 0) {\r\nmpsslog("%s: can't open: %s\n", mic->name,\r\nmic->mic_virtblk.backend_file);\r\ngoto _error_free;\r\n}\r\nif (!set_backend_size(mic))\r\ngoto _error_close;\r\nmic->mic_virtblk.backend_addr = mmap(NULL,\r\nmic->mic_virtblk.backend_size,\r\nPROT_READ|PROT_WRITE, MAP_SHARED,\r\nmic->mic_virtblk.backend, 0L);\r\nif (mic->mic_virtblk.backend_addr == MAP_FAILED) {\r\nmpsslog("%s: can't map: %s %s\n",\r\nmic->name, mic->mic_virtblk.backend_file,\r\nstrerror(errno));\r\ngoto _error_close;\r\n}\r\nreturn true;\r\n_error_close:\r\nclose(mic->mic_virtblk.backend);\r\n_error_free:\r\nfree(mic->mic_virtblk.backend_file);\r\n_error_exit:\r\nreturn false;\r\n}\r\nstatic void\r\nclose_backend(struct mic_info *mic)\r\n{\r\nmunmap(mic->mic_virtblk.backend_addr, mic->mic_virtblk.backend_size);\r\nclose(mic->mic_virtblk.backend);\r\nfree(mic->mic_virtblk.backend_file);\r\n}\r\nstatic bool\r\nstart_virtblk(struct mic_info *mic, struct mic_vring *vring)\r\n{\r\nif (((unsigned long)&virtblk_dev_page.blk_config % 8) != 0) {\r\nmpsslog("%s: blk_config is not 8 byte aligned.\n",\r\nmic->name);\r\nreturn false;\r\n}\r\nadd_virtio_device(mic, &virtblk_dev_page.dd);\r\nif (MAP_FAILED == init_vr(mic, mic->mic_virtblk.virtio_block_fd,\r\nVIRTIO_ID_BLOCK, vring, NULL,\r\nvirtblk_dev_page.dd.num_vq)) {\r\nmpsslog("%s init_vr failed %s\n",\r\nmic->name, strerror(errno));\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\nstop_virtblk(struct mic_info *mic)\r\n{\r\nint vr_size, ret;\r\nvr_size = PAGE_ALIGN(vring_size(MIC_VRING_ENTRIES,\r\nMIC_VIRTIO_RING_ALIGN) + sizeof(struct _mic_vring_info));\r\nret = munmap(mic->mic_virtblk.block_dp,\r\nMIC_DEVICE_PAGE_END + vr_size * virtblk_dev_page.dd.num_vq);\r\nif (ret < 0)\r\nmpsslog("%s munmap errno %d\n", mic->name, errno);\r\nclose(mic->mic_virtblk.virtio_block_fd);\r\n}\r\nstatic __u8\r\nheader_error_check(struct vring_desc *desc)\r\n{\r\nif (le32toh(desc->len) != sizeof(struct virtio_blk_outhdr)) {\r\nmpsslog("%s() %d: length is not sizeof(virtio_blk_outhd)\n",\r\n__func__, __LINE__);\r\nreturn -EIO;\r\n}\r\nif (!(le16toh(desc->flags) & VRING_DESC_F_NEXT)) {\r\nmpsslog("%s() %d: alone\n",\r\n__func__, __LINE__);\r\nreturn -EIO;\r\n}\r\nif (le16toh(desc->flags) & VRING_DESC_F_WRITE) {\r\nmpsslog("%s() %d: not read\n",\r\n__func__, __LINE__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nread_header(int fd, struct virtio_blk_outhdr *hdr, __u32 desc_idx)\r\n{\r\nstruct iovec iovec;\r\nstruct mic_copy_desc copy;\r\niovec.iov_len = sizeof(*hdr);\r\niovec.iov_base = hdr;\r\ncopy.iov = &iovec;\r\ncopy.iovcnt = 1;\r\ncopy.vr_idx = 0;\r\ncopy.update_used = false;\r\nreturn ioctl(fd, MIC_VIRTIO_COPY_DESC, &copy);\r\n}\r\nstatic int\r\ntransfer_blocks(int fd, struct iovec *iovec, __u32 iovcnt)\r\n{\r\nstruct mic_copy_desc copy;\r\ncopy.iov = iovec;\r\ncopy.iovcnt = iovcnt;\r\ncopy.vr_idx = 0;\r\ncopy.update_used = false;\r\nreturn ioctl(fd, MIC_VIRTIO_COPY_DESC, &copy);\r\n}\r\nstatic __u8\r\nstatus_error_check(struct vring_desc *desc)\r\n{\r\nif (le32toh(desc->len) != sizeof(__u8)) {\r\nmpsslog("%s() %d: length is not sizeof(status)\n",\r\n__func__, __LINE__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nwrite_status(int fd, __u8 *status)\r\n{\r\nstruct iovec iovec;\r\nstruct mic_copy_desc copy;\r\niovec.iov_base = status;\r\niovec.iov_len = sizeof(*status);\r\ncopy.iov = &iovec;\r\ncopy.iovcnt = 1;\r\ncopy.vr_idx = 0;\r\ncopy.update_used = true;\r\nreturn ioctl(fd, MIC_VIRTIO_COPY_DESC, &copy);\r\n}\r\nstatic void *\r\nvirtio_block(void *arg)\r\n{\r\nstruct mic_info *mic = (struct mic_info *)arg;\r\nint ret;\r\nstruct pollfd block_poll;\r\nstruct mic_vring vring;\r\n__u16 avail_idx;\r\n__u32 desc_idx;\r\nstruct vring_desc *desc;\r\nstruct iovec *iovec, *piov;\r\n__u8 status;\r\n__u32 buffer_desc_idx;\r\nstruct virtio_blk_outhdr hdr;\r\nvoid *fos;\r\nfor (;;) {\r\nif (!open_backend(mic)) {\r\nfor (mic->mic_virtblk.signaled = 0;\r\n!mic->mic_virtblk.signaled;)\r\nsleep(1);\r\ncontinue;\r\n}\r\nif (!start_virtblk(mic, &vring))\r\ngoto _close_backend;\r\niovec = malloc(sizeof(*iovec) *\r\nle32toh(virtblk_dev_page.blk_config.seg_max));\r\nif (!iovec) {\r\nmpsslog("%s: can't alloc iovec: %s\n",\r\nmic->name, strerror(ENOMEM));\r\ngoto _stop_virtblk;\r\n}\r\nblock_poll.fd = mic->mic_virtblk.virtio_block_fd;\r\nblock_poll.events = POLLIN;\r\nfor (mic->mic_virtblk.signaled = 0;\r\n!mic->mic_virtblk.signaled;) {\r\nblock_poll.revents = 0;\r\nret = poll(&block_poll, 1, 1000);\r\nif (ret < 0) {\r\nmpsslog("%s %d: poll failed: %s\n",\r\n__func__, __LINE__,\r\nstrerror(errno));\r\ncontinue;\r\n}\r\nif (!(block_poll.revents & POLLIN)) {\r\n#ifdef DEBUG\r\nmpsslog("%s %d: block_poll.revents=0x%x\n",\r\n__func__, __LINE__, block_poll.revents);\r\n#endif\r\ncontinue;\r\n}\r\nwhile (vring.info->avail_idx !=\r\nle16toh(vring.vr.avail->idx)) {\r\navail_idx =\r\nvring.info->avail_idx &\r\n(vring.vr.num - 1);\r\ndesc_idx = le16toh(\r\nvring.vr.avail->ring[avail_idx]);\r\ndesc = &vring.vr.desc[desc_idx];\r\n#ifdef DEBUG\r\nmpsslog("%s() %d: avail_idx=%d ",\r\n__func__, __LINE__,\r\nvring.info->avail_idx);\r\nmpsslog("vring.vr.num=%d desc=%p\n",\r\nvring.vr.num, desc);\r\n#endif\r\nstatus = header_error_check(desc);\r\nret = read_header(\r\nmic->mic_virtblk.virtio_block_fd,\r\n&hdr, desc_idx);\r\nif (ret < 0) {\r\nmpsslog("%s() %d %s: ret=%d %s\n",\r\n__func__, __LINE__,\r\nmic->name, ret,\r\nstrerror(errno));\r\nbreak;\r\n}\r\npiov = iovec;\r\nstatus = 0;\r\nfos = mic->mic_virtblk.backend_addr +\r\n(hdr.sector * SECTOR_SIZE);\r\nbuffer_desc_idx = next_desc(desc);\r\ndesc_idx = buffer_desc_idx;\r\nfor (desc = &vring.vr.desc[buffer_desc_idx];\r\ndesc->flags & VRING_DESC_F_NEXT;\r\ndesc_idx = next_desc(desc),\r\ndesc = &vring.vr.desc[desc_idx]) {\r\npiov->iov_len = desc->len;\r\npiov->iov_base = fos;\r\npiov++;\r\nfos += desc->len;\r\n}\r\nif (hdr.type & ~(VIRTIO_BLK_T_OUT |\r\nVIRTIO_BLK_T_GET_ID)) {\r\nmpsslog("%s() %d: type %x ",\r\n__func__, __LINE__,\r\nhdr.type);\r\nmpsslog("is not supported\n");\r\nstatus = -ENOTSUP;\r\n} else {\r\nret = transfer_blocks(\r\nmic->mic_virtblk.virtio_block_fd,\r\niovec,\r\npiov - iovec);\r\nif (ret < 0 &&\r\nstatus != 0)\r\nstatus = ret;\r\n}\r\nif (status != 0)\r\nstatus = status_error_check(desc);\r\nret = write_status(\r\nmic->mic_virtblk.virtio_block_fd,\r\n&status);\r\n#ifdef DEBUG\r\nmpsslog("%s() %d: write status=%d on desc=%p\n",\r\n__func__, __LINE__,\r\nstatus, desc);\r\n#endif\r\n}\r\n}\r\nfree(iovec);\r\n_stop_virtblk:\r\nstop_virtblk(mic);\r\n_close_backend:\r\nclose_backend(mic);\r\n}\r\npthread_exit(NULL);\r\n}\r\nstatic void\r\nreset(struct mic_info *mic)\r\n{\r\n#define RESET_TIMEOUT 120\r\nint i = RESET_TIMEOUT;\r\nsetsysfs(mic->name, "state", "reset");\r\nwhile (i) {\r\nchar *state;\r\nstate = readsysfs(mic->name, "state");\r\nif (!state)\r\ngoto retry;\r\nmpsslog("%s: %s %d state %s\n",\r\nmic->name, __func__, __LINE__, state);\r\nif ((!strcmp(state, "offline")) ||\r\n(!strcmp(state, "suspended"))) {\r\nfree(state);\r\nbreak;\r\n}\r\nfree(state);\r\nretry:\r\nsleep(1);\r\ni--;\r\n}\r\n}\r\nstatic int\r\nget_mic_shutdown_status(struct mic_info *mic, char *shutdown_status)\r\n{\r\nif (!strcmp(shutdown_status, "nop"))\r\nreturn MIC_NOP;\r\nif (!strcmp(shutdown_status, "crashed"))\r\nreturn MIC_CRASHED;\r\nif (!strcmp(shutdown_status, "halted"))\r\nreturn MIC_HALTED;\r\nif (!strcmp(shutdown_status, "poweroff"))\r\nreturn MIC_POWER_OFF;\r\nif (!strcmp(shutdown_status, "restart"))\r\nreturn MIC_RESTART;\r\nmpsslog("%s: BUG invalid status %s\n", mic->name, shutdown_status);\r\nassert(0);\r\n}\r\nstatic int get_mic_state(struct mic_info *mic, char *state)\r\n{\r\nif (!strcmp(state, "offline"))\r\nreturn MIC_OFFLINE;\r\nif (!strcmp(state, "online"))\r\nreturn MIC_ONLINE;\r\nif (!strcmp(state, "shutting_down"))\r\nreturn MIC_SHUTTING_DOWN;\r\nif (!strcmp(state, "reset_failed"))\r\nreturn MIC_RESET_FAILED;\r\nif (!strcmp(state, "suspending"))\r\nreturn MIC_SUSPENDING;\r\nif (!strcmp(state, "suspended"))\r\nreturn MIC_SUSPENDED;\r\nmpsslog("%s: BUG invalid state %s\n", mic->name, state);\r\nassert(0);\r\n}\r\nstatic void mic_handle_shutdown(struct mic_info *mic)\r\n{\r\n#define SHUTDOWN_TIMEOUT 60\r\nint i = SHUTDOWN_TIMEOUT, ret, stat = 0;\r\nchar *shutdown_status;\r\nwhile (i) {\r\nshutdown_status = readsysfs(mic->name, "shutdown_status");\r\nif (!shutdown_status)\r\ncontinue;\r\nmpsslog("%s: %s %d shutdown_status %s\n",\r\nmic->name, __func__, __LINE__, shutdown_status);\r\nswitch (get_mic_shutdown_status(mic, shutdown_status)) {\r\ncase MIC_RESTART:\r\nmic->restart = 1;\r\ncase MIC_HALTED:\r\ncase MIC_POWER_OFF:\r\ncase MIC_CRASHED:\r\nfree(shutdown_status);\r\ngoto reset;\r\ndefault:\r\nbreak;\r\n}\r\nfree(shutdown_status);\r\nsleep(1);\r\ni--;\r\n}\r\nreset:\r\nret = kill(mic->pid, SIGTERM);\r\nmpsslog("%s: %s %d kill pid %d ret %d\n",\r\nmic->name, __func__, __LINE__,\r\nmic->pid, ret);\r\nif (!ret) {\r\nret = waitpid(mic->pid, &stat,\r\nWIFSIGNALED(stat));\r\nmpsslog("%s: %s %d waitpid ret %d pid %d\n",\r\nmic->name, __func__, __LINE__,\r\nret, mic->pid);\r\n}\r\nif (ret == mic->pid)\r\nreset(mic);\r\n}\r\nstatic void *\r\nmic_config(void *arg)\r\n{\r\nstruct mic_info *mic = (struct mic_info *)arg;\r\nchar *state = NULL;\r\nchar pathname[PATH_MAX];\r\nint fd, ret;\r\nstruct pollfd ufds[1];\r\nchar value[4096];\r\nsnprintf(pathname, PATH_MAX - 1, "%s/%s/%s",\r\nMICSYSFSDIR, mic->name, "state");\r\nfd = open(pathname, O_RDONLY);\r\nif (fd < 0) {\r\nmpsslog("%s: opening file %s failed %s\n",\r\nmic->name, pathname, strerror(errno));\r\ngoto error;\r\n}\r\ndo {\r\nret = lseek(fd, 0, SEEK_SET);\r\nif (ret < 0) {\r\nmpsslog("%s: Failed to seek to file start '%s': %s\n",\r\nmic->name, pathname, strerror(errno));\r\ngoto close_error1;\r\n}\r\nret = read(fd, value, sizeof(value));\r\nif (ret < 0) {\r\nmpsslog("%s: Failed to read sysfs entry '%s': %s\n",\r\nmic->name, pathname, strerror(errno));\r\ngoto close_error1;\r\n}\r\nretry:\r\nstate = readsysfs(mic->name, "state");\r\nif (!state)\r\ngoto retry;\r\nmpsslog("%s: %s %d state %s\n",\r\nmic->name, __func__, __LINE__, state);\r\nswitch (get_mic_state(mic, state)) {\r\ncase MIC_SHUTTING_DOWN:\r\nmic_handle_shutdown(mic);\r\ngoto close_error;\r\ncase MIC_SUSPENDING:\r\nmic->boot_on_resume = 1;\r\nsetsysfs(mic->name, "state", "suspend");\r\nmic_handle_shutdown(mic);\r\ngoto close_error;\r\ncase MIC_OFFLINE:\r\nif (mic->boot_on_resume) {\r\nsetsysfs(mic->name, "state", "boot");\r\nmic->boot_on_resume = 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfree(state);\r\nufds[0].fd = fd;\r\nufds[0].events = POLLERR | POLLPRI;\r\nret = poll(ufds, 1, -1);\r\nif (ret < 0) {\r\nmpsslog("%s: poll failed %s\n",\r\nmic->name, strerror(errno));\r\ngoto close_error1;\r\n}\r\n} while (1);\r\nclose_error:\r\nfree(state);\r\nclose_error1:\r\nclose(fd);\r\nerror:\r\ninit_mic(mic);\r\npthread_exit(NULL);\r\n}\r\nstatic void\r\nset_cmdline(struct mic_info *mic)\r\n{\r\nchar buffer[PATH_MAX];\r\nint len;\r\nlen = snprintf(buffer, PATH_MAX,\r\n"clocksource=tsc highres=off nohz=off ");\r\nlen += snprintf(buffer + len, PATH_MAX,\r\n"cpufreq_on;corec6_off;pc3_off;pc6_off ");\r\nlen += snprintf(buffer + len, PATH_MAX,\r\n"ifcfg=static;address,172.31.%d.1;netmask,255.255.255.0",\r\nmic->id);\r\nsetsysfs(mic->name, "cmdline", buffer);\r\nmpsslog("%s: Command line: \"%s\"\n", mic->name, buffer);\r\nsnprintf(buffer, PATH_MAX, "172.31.%d.1", mic->id);\r\nmpsslog("%s: IPADDR: \"%s\"\n", mic->name, buffer);\r\n}\r\nstatic void\r\nset_log_buf_info(struct mic_info *mic)\r\n{\r\nint fd;\r\noff_t len;\r\nchar system_map[] = "/lib/firmware/mic/System.map";\r\nchar *map, *temp, log_buf[17] = {'\0'};\r\nfd = open(system_map, O_RDONLY);\r\nif (fd < 0) {\r\nmpsslog("%s: Opening System.map failed: %d\n",\r\nmic->name, errno);\r\nreturn;\r\n}\r\nlen = lseek(fd, 0, SEEK_END);\r\nif (len < 0) {\r\nmpsslog("%s: Reading System.map size failed: %d\n",\r\nmic->name, errno);\r\nclose(fd);\r\nreturn;\r\n}\r\nmap = mmap(NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);\r\nif (map == MAP_FAILED) {\r\nmpsslog("%s: mmap of System.map failed: %d\n",\r\nmic->name, errno);\r\nclose(fd);\r\nreturn;\r\n}\r\ntemp = strstr(map, "__log_buf");\r\nif (!temp) {\r\nmpsslog("%s: __log_buf not found: %d\n", mic->name, errno);\r\nmunmap(map, len);\r\nclose(fd);\r\nreturn;\r\n}\r\nstrncpy(log_buf, temp - 19, 16);\r\nsetsysfs(mic->name, "log_buf_addr", log_buf);\r\nmpsslog("%s: log_buf_addr: %s\n", mic->name, log_buf);\r\ntemp = strstr(map, "log_buf_len");\r\nif (!temp) {\r\nmpsslog("%s: log_buf_len not found: %d\n", mic->name, errno);\r\nmunmap(map, len);\r\nclose(fd);\r\nreturn;\r\n}\r\nstrncpy(log_buf, temp - 19, 16);\r\nsetsysfs(mic->name, "log_buf_len", log_buf);\r\nmpsslog("%s: log_buf_len: %s\n", mic->name, log_buf);\r\nmunmap(map, len);\r\nclose(fd);\r\n}\r\nstatic void\r\nchange_virtblk_backend(int x, siginfo_t *siginfo, void *p)\r\n{\r\nstruct mic_info *mic;\r\nfor (mic = mic_list.next; mic != NULL; mic = mic->next)\r\nmic->mic_virtblk.signaled = 1;\r\n}\r\nstatic void\r\ninit_mic(struct mic_info *mic)\r\n{\r\nstruct sigaction ignore = {\r\n.sa_flags = 0,\r\n.sa_handler = SIG_IGN\r\n};\r\nstruct sigaction act = {\r\n.sa_flags = SA_SIGINFO,\r\n.sa_sigaction = change_virtblk_backend,\r\n};\r\nchar buffer[PATH_MAX];\r\nint err;\r\nsigaction(SIGUSR1, &ignore, NULL);\r\nmic->pid = fork();\r\nswitch (mic->pid) {\r\ncase 0:\r\nset_log_buf_info(mic);\r\nset_cmdline(mic);\r\nadd_virtio_device(mic, &virtcons_dev_page.dd);\r\nadd_virtio_device(mic, &virtnet_dev_page.dd);\r\nerr = pthread_create(&mic->mic_console.console_thread, NULL,\r\nvirtio_console, mic);\r\nif (err)\r\nmpsslog("%s virtcons pthread_create failed %s\n",\r\nmic->name, strerror(err));\r\nerr = pthread_create(&mic->mic_net.net_thread, NULL,\r\nvirtio_net, mic);\r\nif (err)\r\nmpsslog("%s virtnet pthread_create failed %s\n",\r\nmic->name, strerror(err));\r\nerr = pthread_create(&mic->mic_virtblk.block_thread, NULL,\r\nvirtio_block, mic);\r\nif (err)\r\nmpsslog("%s virtblk pthread_create failed %s\n",\r\nmic->name, strerror(err));\r\nsigemptyset(&act.sa_mask);\r\nerr = sigaction(SIGUSR1, &act, NULL);\r\nif (err)\r\nmpsslog("%s sigaction SIGUSR1 failed %s\n",\r\nmic->name, strerror(errno));\r\nwhile (1)\r\nsleep(60);\r\ncase -1:\r\nmpsslog("fork failed MIC name %s id %d errno %d\n",\r\nmic->name, mic->id, errno);\r\nbreak;\r\ndefault:\r\nif (mic->restart) {\r\nsnprintf(buffer, PATH_MAX, "boot");\r\nsetsysfs(mic->name, "state", buffer);\r\nmpsslog("%s restarting mic %d\n",\r\nmic->name, mic->restart);\r\nmic->restart = 0;\r\n}\r\npthread_create(&mic->config_thread, NULL, mic_config, mic);\r\n}\r\n}\r\nstatic void\r\nstart_daemon(void)\r\n{\r\nstruct mic_info *mic;\r\nfor (mic = mic_list.next; mic != NULL; mic = mic->next)\r\ninit_mic(mic);\r\nwhile (1)\r\nsleep(60);\r\n}\r\nstatic int\r\ninit_mic_list(void)\r\n{\r\nstruct mic_info *mic = &mic_list;\r\nstruct dirent *file;\r\nDIR *dp;\r\nint cnt = 0;\r\ndp = opendir(MICSYSFSDIR);\r\nif (!dp)\r\nreturn 0;\r\nwhile ((file = readdir(dp)) != NULL) {\r\nif (!strncmp(file->d_name, "mic", 3)) {\r\nmic->next = calloc(1, sizeof(struct mic_info));\r\nif (mic->next) {\r\nmic = mic->next;\r\nmic->id = atoi(&file->d_name[3]);\r\nmic->name = malloc(strlen(file->d_name) + 16);\r\nif (mic->name)\r\nstrcpy(mic->name, file->d_name);\r\nmpsslog("MIC name %s id %d\n", mic->name,\r\nmic->id);\r\ncnt++;\r\n}\r\n}\r\n}\r\nclosedir(dp);\r\nreturn cnt;\r\n}\r\nvoid\r\nmpsslog(char *format, ...)\r\n{\r\nva_list args;\r\nchar buffer[4096];\r\nchar ts[52], *ts1;\r\ntime_t t;\r\nif (logfp == NULL)\r\nreturn;\r\nva_start(args, format);\r\nvsprintf(buffer, format, args);\r\nva_end(args);\r\ntime(&t);\r\nts1 = ctime_r(&t, ts);\r\nts1[strlen(ts1) - 1] = '\0';\r\nfprintf(logfp, "%s: %s", ts1, buffer);\r\nfflush(logfp);\r\n}\r\nint\r\nmain(int argc, char *argv[])\r\n{\r\nint cnt;\r\npid_t pid;\r\nmyname = argv[0];\r\nlogfp = fopen(LOGFILE_NAME, "a+");\r\nif (!logfp) {\r\nfprintf(stderr, "cannot open logfile '%s'\n", LOGFILE_NAME);\r\nexit(1);\r\n}\r\npid = fork();\r\nswitch (pid) {\r\ncase 0:\r\nbreak;\r\ncase -1:\r\nexit(2);\r\ndefault:\r\nexit(0);\r\n}\r\nmpsslog("MIC Daemon start\n");\r\ncnt = init_mic_list();\r\nif (cnt == 0) {\r\nmpsslog("MIC module not loaded\n");\r\nexit(3);\r\n}\r\nmpsslog("MIC found %d devices\n", cnt);\r\nstart_daemon();\r\nexit(0);\r\n}
