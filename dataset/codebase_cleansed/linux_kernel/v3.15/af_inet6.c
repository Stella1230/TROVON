static int inet6_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct inet_sock *inet;\r\nstruct ipv6_pinfo *np;\r\nstruct sock *sk;\r\nstruct inet_protosw *answer;\r\nstruct proto *answer_prot;\r\nunsigned char answer_flags;\r\nchar answer_no_check;\r\nint try_loading_module = 0;\r\nint err;\r\nlookup_protocol:\r\nerr = -ESOCKTNOSUPPORT;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(answer, &inetsw6[sock->type], list) {\r\nerr = 0;\r\nif (protocol == answer->protocol) {\r\nif (protocol != IPPROTO_IP)\r\nbreak;\r\n} else {\r\nif (IPPROTO_IP == protocol) {\r\nprotocol = answer->protocol;\r\nbreak;\r\n}\r\nif (IPPROTO_IP == answer->protocol)\r\nbreak;\r\n}\r\nerr = -EPROTONOSUPPORT;\r\n}\r\nif (err) {\r\nif (try_loading_module < 2) {\r\nrcu_read_unlock();\r\nif (++try_loading_module == 1)\r\nrequest_module("net-pf-%d-proto-%d-type-%d",\r\nPF_INET6, protocol, sock->type);\r\nelse\r\nrequest_module("net-pf-%d-proto-%d",\r\nPF_INET6, protocol);\r\ngoto lookup_protocol;\r\n} else\r\ngoto out_rcu_unlock;\r\n}\r\nerr = -EPERM;\r\nif (sock->type == SOCK_RAW && !kern &&\r\n!ns_capable(net->user_ns, CAP_NET_RAW))\r\ngoto out_rcu_unlock;\r\nsock->ops = answer->ops;\r\nanswer_prot = answer->prot;\r\nanswer_no_check = answer->no_check;\r\nanswer_flags = answer->flags;\r\nrcu_read_unlock();\r\nWARN_ON(answer_prot->slab == NULL);\r\nerr = -ENOBUFS;\r\nsk = sk_alloc(net, PF_INET6, GFP_KERNEL, answer_prot);\r\nif (sk == NULL)\r\ngoto out;\r\nsock_init_data(sock, sk);\r\nerr = 0;\r\nsk->sk_no_check = answer_no_check;\r\nif (INET_PROTOSW_REUSE & answer_flags)\r\nsk->sk_reuse = SK_CAN_REUSE;\r\ninet = inet_sk(sk);\r\ninet->is_icsk = (INET_PROTOSW_ICSK & answer_flags) != 0;\r\nif (SOCK_RAW == sock->type) {\r\ninet->inet_num = protocol;\r\nif (IPPROTO_RAW == protocol)\r\ninet->hdrincl = 1;\r\n}\r\nsk->sk_destruct = inet_sock_destruct;\r\nsk->sk_family = PF_INET6;\r\nsk->sk_protocol = protocol;\r\nsk->sk_backlog_rcv = answer->prot->backlog_rcv;\r\ninet_sk(sk)->pinet6 = np = inet6_sk_generic(sk);\r\nnp->hop_limit = -1;\r\nnp->mcast_hops = IPV6_DEFAULT_MCASTHOPS;\r\nnp->mc_loop = 1;\r\nnp->pmtudisc = IPV6_PMTUDISC_WANT;\r\nnp->ipv6only = net->ipv6.sysctl.bindv6only;\r\ninet->uc_ttl = -1;\r\ninet->mc_loop = 1;\r\ninet->mc_ttl = 1;\r\ninet->mc_index = 0;\r\ninet->mc_list = NULL;\r\ninet->rcv_tos = 0;\r\nif (net->ipv4.sysctl_ip_no_pmtu_disc)\r\ninet->pmtudisc = IP_PMTUDISC_DONT;\r\nelse\r\ninet->pmtudisc = IP_PMTUDISC_WANT;\r\nsk_refcnt_debug_inc(sk);\r\nif (inet->inet_num) {\r\ninet->inet_sport = htons(inet->inet_num);\r\nsk->sk_prot->hash(sk);\r\n}\r\nif (sk->sk_prot->init) {\r\nerr = sk->sk_prot->init(sk);\r\nif (err) {\r\nsk_common_release(sk);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn err;\r\nout_rcu_unlock:\r\nrcu_read_unlock();\r\ngoto out;\r\n}\r\nint inet6_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sockaddr_in6 *addr = (struct sockaddr_in6 *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct net *net = sock_net(sk);\r\n__be32 v4addr = 0;\r\nunsigned short snum;\r\nint addr_type = 0;\r\nint err = 0;\r\nif (sk->sk_prot->bind)\r\nreturn sk->sk_prot->bind(sk, uaddr, addr_len);\r\nif (addr_len < SIN6_LEN_RFC2133)\r\nreturn -EINVAL;\r\nif (addr->sin6_family != AF_INET6)\r\nreturn -EAFNOSUPPORT;\r\naddr_type = ipv6_addr_type(&addr->sin6_addr);\r\nif ((addr_type & IPV6_ADDR_MULTICAST) && sock->type == SOCK_STREAM)\r\nreturn -EINVAL;\r\nsnum = ntohs(addr->sin6_port);\r\nif (snum && snum < PROT_SOCK && !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\r\nreturn -EACCES;\r\nlock_sock(sk);\r\nif (sk->sk_state != TCP_CLOSE || inet->inet_num) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (addr_type == IPV6_ADDR_MAPPED) {\r\nint chk_addr_ret;\r\nif (np->ipv6only) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nv4addr = addr->sin6_addr.s6_addr32[3];\r\nchk_addr_ret = inet_addr_type(net, v4addr);\r\nif (!sysctl_ip_nonlocal_bind &&\r\n!(inet->freebind || inet->transparent) &&\r\nv4addr != htonl(INADDR_ANY) &&\r\nchk_addr_ret != RTN_LOCAL &&\r\nchk_addr_ret != RTN_MULTICAST &&\r\nchk_addr_ret != RTN_BROADCAST) {\r\nerr = -EADDRNOTAVAIL;\r\ngoto out;\r\n}\r\n} else {\r\nif (addr_type != IPV6_ADDR_ANY) {\r\nstruct net_device *dev = NULL;\r\nrcu_read_lock();\r\nif (__ipv6_addr_needs_scope_id(addr_type)) {\r\nif (addr_len >= sizeof(struct sockaddr_in6) &&\r\naddr->sin6_scope_id) {\r\nsk->sk_bound_dev_if = addr->sin6_scope_id;\r\n}\r\nif (!sk->sk_bound_dev_if) {\r\nerr = -EINVAL;\r\ngoto out_unlock;\r\n}\r\ndev = dev_get_by_index_rcu(net, sk->sk_bound_dev_if);\r\nif (!dev) {\r\nerr = -ENODEV;\r\ngoto out_unlock;\r\n}\r\n}\r\nv4addr = LOOPBACK4_IPV6;\r\nif (!(addr_type & IPV6_ADDR_MULTICAST)) {\r\nif (!(inet->freebind || inet->transparent) &&\r\n!ipv6_chk_addr(net, &addr->sin6_addr,\r\ndev, 0)) {\r\nerr = -EADDRNOTAVAIL;\r\ngoto out_unlock;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\n}\r\ninet->inet_rcv_saddr = v4addr;\r\ninet->inet_saddr = v4addr;\r\nsk->sk_v6_rcv_saddr = addr->sin6_addr;\r\nif (!(addr_type & IPV6_ADDR_MULTICAST))\r\nnp->saddr = addr->sin6_addr;\r\nif (sk->sk_prot->get_port(sk, snum)) {\r\ninet_reset_saddr(sk);\r\nerr = -EADDRINUSE;\r\ngoto out;\r\n}\r\nif (addr_type != IPV6_ADDR_ANY) {\r\nsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\r\nif (addr_type != IPV6_ADDR_MAPPED)\r\nnp->ipv6only = 1;\r\n}\r\nif (snum)\r\nsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\r\ninet->inet_sport = htons(inet->inet_num);\r\ninet->inet_dport = 0;\r\ninet->inet_daddr = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\nout_unlock:\r\nrcu_read_unlock();\r\ngoto out;\r\n}\r\nint inet6_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (sk == NULL)\r\nreturn -EINVAL;\r\nipv6_sock_mc_close(sk);\r\nipv6_sock_ac_close(sk);\r\nreturn inet_release(sock);\r\n}\r\nvoid inet6_destroy_sock(struct sock *sk)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct sk_buff *skb;\r\nstruct ipv6_txoptions *opt;\r\nskb = xchg(&np->pktoptions, NULL);\r\nif (skb != NULL)\r\nkfree_skb(skb);\r\nskb = xchg(&np->rxpmtu, NULL);\r\nif (skb != NULL)\r\nkfree_skb(skb);\r\nfl6_free_socklist(sk);\r\nopt = xchg(&np->opt, NULL);\r\nif (opt != NULL)\r\nsock_kfree_s(sk, opt, opt->tot_len);\r\n}\r\nint inet6_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddr_len, int peer)\r\n{\r\nstruct sockaddr_in6 *sin = (struct sockaddr_in6 *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nsin->sin6_family = AF_INET6;\r\nsin->sin6_flowinfo = 0;\r\nsin->sin6_scope_id = 0;\r\nif (peer) {\r\nif (!inet->inet_dport)\r\nreturn -ENOTCONN;\r\nif (((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_SYN_SENT)) &&\r\npeer == 1)\r\nreturn -ENOTCONN;\r\nsin->sin6_port = inet->inet_dport;\r\nsin->sin6_addr = sk->sk_v6_daddr;\r\nif (np->sndflow)\r\nsin->sin6_flowinfo = np->flow_label;\r\n} else {\r\nif (ipv6_addr_any(&sk->sk_v6_rcv_saddr))\r\nsin->sin6_addr = np->saddr;\r\nelse\r\nsin->sin6_addr = sk->sk_v6_rcv_saddr;\r\nsin->sin6_port = inet->inet_sport;\r\n}\r\nsin->sin6_scope_id = ipv6_iface_scope_id(&sin->sin6_addr,\r\nsk->sk_bound_dev_if);\r\n*uaddr_len = sizeof(*sin);\r\nreturn 0;\r\n}\r\nint inet6_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct net *net = sock_net(sk);\r\nswitch (cmd) {\r\ncase SIOCGSTAMP:\r\nreturn sock_get_timestamp(sk, (struct timeval __user *)arg);\r\ncase SIOCGSTAMPNS:\r\nreturn sock_get_timestampns(sk, (struct timespec __user *)arg);\r\ncase SIOCADDRT:\r\ncase SIOCDELRT:\r\nreturn ipv6_route_ioctl(net, cmd, (void __user *)arg);\r\ncase SIOCSIFADDR:\r\nreturn addrconf_add_ifaddr(net, (void __user *) arg);\r\ncase SIOCDIFADDR:\r\nreturn addrconf_del_ifaddr(net, (void __user *) arg);\r\ncase SIOCSIFDSTADDR:\r\nreturn addrconf_set_dstaddr(net, (void __user *) arg);\r\ndefault:\r\nif (!sk->sk_prot->ioctl)\r\nreturn -ENOIOCTLCMD;\r\nreturn sk->sk_prot->ioctl(sk, cmd, arg);\r\n}\r\nreturn 0;\r\n}\r\nint inet6_register_protosw(struct inet_protosw *p)\r\n{\r\nstruct list_head *lh;\r\nstruct inet_protosw *answer;\r\nstruct list_head *last_perm;\r\nint protocol = p->protocol;\r\nint ret;\r\nspin_lock_bh(&inetsw6_lock);\r\nret = -EINVAL;\r\nif (p->type >= SOCK_MAX)\r\ngoto out_illegal;\r\nanswer = NULL;\r\nret = -EPERM;\r\nlast_perm = &inetsw6[p->type];\r\nlist_for_each(lh, &inetsw6[p->type]) {\r\nanswer = list_entry(lh, struct inet_protosw, list);\r\nif (INET_PROTOSW_PERMANENT & answer->flags) {\r\nif (protocol == answer->protocol)\r\nbreak;\r\nlast_perm = lh;\r\n}\r\nanswer = NULL;\r\n}\r\nif (answer)\r\ngoto out_permanent;\r\nlist_add_rcu(&p->list, last_perm);\r\nret = 0;\r\nout:\r\nspin_unlock_bh(&inetsw6_lock);\r\nreturn ret;\r\nout_permanent:\r\npr_err("Attempt to override permanent protocol %d\n", protocol);\r\ngoto out;\r\nout_illegal:\r\npr_err("Ignoring attempt to register invalid socket type %d\n",\r\np->type);\r\ngoto out;\r\n}\r\nvoid\r\ninet6_unregister_protosw(struct inet_protosw *p)\r\n{\r\nif (INET_PROTOSW_PERMANENT & p->flags) {\r\npr_err("Attempt to unregister permanent protocol %d\n",\r\np->protocol);\r\n} else {\r\nspin_lock_bh(&inetsw6_lock);\r\nlist_del_rcu(&p->list);\r\nspin_unlock_bh(&inetsw6_lock);\r\nsynchronize_net();\r\n}\r\n}\r\nint inet6_sk_rebuild_header(struct sock *sk)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct dst_entry *dst;\r\ndst = __sk_dst_check(sk, np->dst_cookie);\r\nif (dst == NULL) {\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct in6_addr *final_p, final;\r\nstruct flowi6 fl6;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.flowi6_proto = sk->sk_protocol;\r\nfl6.daddr = sk->sk_v6_daddr;\r\nfl6.saddr = np->saddr;\r\nfl6.flowlabel = np->flow_label;\r\nfl6.flowi6_oif = sk->sk_bound_dev_if;\r\nfl6.flowi6_mark = sk->sk_mark;\r\nfl6.fl6_dport = inet->inet_dport;\r\nfl6.fl6_sport = inet->inet_sport;\r\nsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\r\nfinal_p = fl6_update_dst(&fl6, np->opt, &final);\r\ndst = ip6_dst_lookup_flow(sk, &fl6, final_p);\r\nif (IS_ERR(dst)) {\r\nsk->sk_route_caps = 0;\r\nsk->sk_err_soft = -PTR_ERR(dst);\r\nreturn PTR_ERR(dst);\r\n}\r\n__ip6_dst_store(sk, dst, NULL, NULL);\r\n}\r\nreturn 0;\r\n}\r\nbool ipv6_opt_accepted(const struct sock *sk, const struct sk_buff *skb)\r\n{\r\nconst struct ipv6_pinfo *np = inet6_sk(sk);\r\nconst struct inet6_skb_parm *opt = IP6CB(skb);\r\nif (np->rxopt.all) {\r\nif ((opt->hop && (np->rxopt.bits.hopopts ||\r\nnp->rxopt.bits.ohopopts)) ||\r\n(ip6_flowinfo((struct ipv6hdr *) skb_network_header(skb)) &&\r\nnp->rxopt.bits.rxflow) ||\r\n(opt->srcrt && (np->rxopt.bits.srcrt ||\r\nnp->rxopt.bits.osrcrt)) ||\r\n((opt->dst1 || opt->dst0) &&\r\n(np->rxopt.bits.dstopts || np->rxopt.bits.odstopts)))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int __init ipv6_packet_init(void)\r\n{\r\ndev_add_pack(&ipv6_packet_type);\r\nreturn 0;\r\n}\r\nstatic void ipv6_packet_cleanup(void)\r\n{\r\ndev_remove_pack(&ipv6_packet_type);\r\n}\r\nstatic int __net_init ipv6_init_mibs(struct net *net)\r\n{\r\nint i;\r\nif (snmp_mib_init((void __percpu **)net->mib.udp_stats_in6,\r\nsizeof(struct udp_mib),\r\n__alignof__(struct udp_mib)) < 0)\r\nreturn -ENOMEM;\r\nif (snmp_mib_init((void __percpu **)net->mib.udplite_stats_in6,\r\nsizeof(struct udp_mib),\r\n__alignof__(struct udp_mib)) < 0)\r\ngoto err_udplite_mib;\r\nif (snmp_mib_init((void __percpu **)net->mib.ipv6_statistics,\r\nsizeof(struct ipstats_mib),\r\n__alignof__(struct ipstats_mib)) < 0)\r\ngoto err_ip_mib;\r\nfor_each_possible_cpu(i) {\r\nstruct ipstats_mib *af_inet6_stats;\r\naf_inet6_stats = per_cpu_ptr(net->mib.ipv6_statistics[0], i);\r\nu64_stats_init(&af_inet6_stats->syncp);\r\n#if SNMP_ARRAY_SZ == 2\r\naf_inet6_stats = per_cpu_ptr(net->mib.ipv6_statistics[1], i);\r\nu64_stats_init(&af_inet6_stats->syncp);\r\n#endif\r\n}\r\nif (snmp_mib_init((void __percpu **)net->mib.icmpv6_statistics,\r\nsizeof(struct icmpv6_mib),\r\n__alignof__(struct icmpv6_mib)) < 0)\r\ngoto err_icmp_mib;\r\nnet->mib.icmpv6msg_statistics = kzalloc(sizeof(struct icmpv6msg_mib),\r\nGFP_KERNEL);\r\nif (!net->mib.icmpv6msg_statistics)\r\ngoto err_icmpmsg_mib;\r\nreturn 0;\r\nerr_icmpmsg_mib:\r\nsnmp_mib_free((void __percpu **)net->mib.icmpv6_statistics);\r\nerr_icmp_mib:\r\nsnmp_mib_free((void __percpu **)net->mib.ipv6_statistics);\r\nerr_ip_mib:\r\nsnmp_mib_free((void __percpu **)net->mib.udplite_stats_in6);\r\nerr_udplite_mib:\r\nsnmp_mib_free((void __percpu **)net->mib.udp_stats_in6);\r\nreturn -ENOMEM;\r\n}\r\nstatic void ipv6_cleanup_mibs(struct net *net)\r\n{\r\nsnmp_mib_free((void __percpu **)net->mib.udp_stats_in6);\r\nsnmp_mib_free((void __percpu **)net->mib.udplite_stats_in6);\r\nsnmp_mib_free((void __percpu **)net->mib.ipv6_statistics);\r\nsnmp_mib_free((void __percpu **)net->mib.icmpv6_statistics);\r\nkfree(net->mib.icmpv6msg_statistics);\r\n}\r\nstatic int __net_init inet6_net_init(struct net *net)\r\n{\r\nint err = 0;\r\nnet->ipv6.sysctl.bindv6only = 0;\r\nnet->ipv6.sysctl.icmpv6_time = 1*HZ;\r\nnet->ipv6.sysctl.flowlabel_consistency = 1;\r\natomic_set(&net->ipv6.rt_genid, 0);\r\nerr = ipv6_init_mibs(net);\r\nif (err)\r\nreturn err;\r\n#ifdef CONFIG_PROC_FS\r\nerr = udp6_proc_init(net);\r\nif (err)\r\ngoto out;\r\nerr = tcp6_proc_init(net);\r\nif (err)\r\ngoto proc_tcp6_fail;\r\nerr = ac6_proc_init(net);\r\nif (err)\r\ngoto proc_ac6_fail;\r\n#endif\r\nreturn err;\r\n#ifdef CONFIG_PROC_FS\r\nproc_ac6_fail:\r\ntcp6_proc_exit(net);\r\nproc_tcp6_fail:\r\nudp6_proc_exit(net);\r\nout:\r\nipv6_cleanup_mibs(net);\r\nreturn err;\r\n#endif\r\n}\r\nstatic void __net_exit inet6_net_exit(struct net *net)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nudp6_proc_exit(net);\r\ntcp6_proc_exit(net);\r\nac6_proc_exit(net);\r\n#endif\r\nipv6_cleanup_mibs(net);\r\n}\r\nstatic int __init inet6_init(void)\r\n{\r\nstruct list_head *r;\r\nint err = 0;\r\nBUILD_BUG_ON(sizeof(struct inet6_skb_parm) > FIELD_SIZEOF(struct sk_buff, cb));\r\nfor (r = &inetsw6[0]; r < &inetsw6[SOCK_MAX]; ++r)\r\nINIT_LIST_HEAD(r);\r\nif (disable_ipv6_mod) {\r\npr_info("Loaded, but administratively disabled, reboot required to enable\n");\r\ngoto out;\r\n}\r\nerr = proto_register(&tcpv6_prot, 1);\r\nif (err)\r\ngoto out;\r\nerr = proto_register(&udpv6_prot, 1);\r\nif (err)\r\ngoto out_unregister_tcp_proto;\r\nerr = proto_register(&udplitev6_prot, 1);\r\nif (err)\r\ngoto out_unregister_udp_proto;\r\nerr = proto_register(&rawv6_prot, 1);\r\nif (err)\r\ngoto out_unregister_udplite_proto;\r\nerr = proto_register(&pingv6_prot, 1);\r\nif (err)\r\ngoto out_unregister_ping_proto;\r\nerr = rawv6_init();\r\nif (err)\r\ngoto out_unregister_raw_proto;\r\nerr = sock_register(&inet6_family_ops);\r\nif (err)\r\ngoto out_sock_register_fail;\r\nerr = register_pernet_subsys(&inet6_net_ops);\r\nif (err)\r\ngoto register_pernet_fail;\r\nerr = icmpv6_init();\r\nif (err)\r\ngoto icmp_fail;\r\nerr = ip6_mr_init();\r\nif (err)\r\ngoto ipmr_fail;\r\nerr = ndisc_init();\r\nif (err)\r\ngoto ndisc_fail;\r\nerr = igmp6_init();\r\nif (err)\r\ngoto igmp_fail;\r\nipv6_stub = &ipv6_stub_impl;\r\nerr = ipv6_netfilter_init();\r\nif (err)\r\ngoto netfilter_fail;\r\n#ifdef CONFIG_PROC_FS\r\nerr = -ENOMEM;\r\nif (raw6_proc_init())\r\ngoto proc_raw6_fail;\r\nif (udplite6_proc_init())\r\ngoto proc_udplite6_fail;\r\nif (ipv6_misc_proc_init())\r\ngoto proc_misc6_fail;\r\nif (if6_proc_init())\r\ngoto proc_if6_fail;\r\n#endif\r\nerr = ip6_route_init();\r\nif (err)\r\ngoto ip6_route_fail;\r\nerr = ndisc_late_init();\r\nif (err)\r\ngoto ndisc_late_fail;\r\nerr = ip6_flowlabel_init();\r\nif (err)\r\ngoto ip6_flowlabel_fail;\r\nerr = addrconf_init();\r\nif (err)\r\ngoto addrconf_fail;\r\nerr = ipv6_exthdrs_init();\r\nif (err)\r\ngoto ipv6_exthdrs_fail;\r\nerr = ipv6_frag_init();\r\nif (err)\r\ngoto ipv6_frag_fail;\r\nerr = udpv6_init();\r\nif (err)\r\ngoto udpv6_fail;\r\nerr = udplitev6_init();\r\nif (err)\r\ngoto udplitev6_fail;\r\nerr = tcpv6_init();\r\nif (err)\r\ngoto tcpv6_fail;\r\nerr = ipv6_packet_init();\r\nif (err)\r\ngoto ipv6_packet_fail;\r\nerr = pingv6_init();\r\nif (err)\r\ngoto pingv6_fail;\r\n#ifdef CONFIG_SYSCTL\r\nerr = ipv6_sysctl_register();\r\nif (err)\r\ngoto sysctl_fail;\r\n#endif\r\nout:\r\nreturn err;\r\n#ifdef CONFIG_SYSCTL\r\nsysctl_fail:\r\npingv6_exit();\r\n#endif\r\npingv6_fail:\r\nipv6_packet_cleanup();\r\nipv6_packet_fail:\r\ntcpv6_exit();\r\ntcpv6_fail:\r\nudplitev6_exit();\r\nudplitev6_fail:\r\nudpv6_exit();\r\nudpv6_fail:\r\nipv6_frag_exit();\r\nipv6_frag_fail:\r\nipv6_exthdrs_exit();\r\nipv6_exthdrs_fail:\r\naddrconf_cleanup();\r\naddrconf_fail:\r\nip6_flowlabel_cleanup();\r\nip6_flowlabel_fail:\r\nndisc_late_cleanup();\r\nndisc_late_fail:\r\nip6_route_cleanup();\r\nip6_route_fail:\r\n#ifdef CONFIG_PROC_FS\r\nif6_proc_exit();\r\nproc_if6_fail:\r\nipv6_misc_proc_exit();\r\nproc_misc6_fail:\r\nudplite6_proc_exit();\r\nproc_udplite6_fail:\r\nraw6_proc_exit();\r\nproc_raw6_fail:\r\n#endif\r\nipv6_netfilter_fini();\r\nnetfilter_fail:\r\nigmp6_cleanup();\r\nigmp_fail:\r\nndisc_cleanup();\r\nndisc_fail:\r\nip6_mr_cleanup();\r\nipmr_fail:\r\nicmpv6_cleanup();\r\nicmp_fail:\r\nunregister_pernet_subsys(&inet6_net_ops);\r\nregister_pernet_fail:\r\nsock_unregister(PF_INET6);\r\nrtnl_unregister_all(PF_INET6);\r\nout_sock_register_fail:\r\nrawv6_exit();\r\nout_unregister_ping_proto:\r\nproto_unregister(&pingv6_prot);\r\nout_unregister_raw_proto:\r\nproto_unregister(&rawv6_prot);\r\nout_unregister_udplite_proto:\r\nproto_unregister(&udplitev6_prot);\r\nout_unregister_udp_proto:\r\nproto_unregister(&udpv6_prot);\r\nout_unregister_tcp_proto:\r\nproto_unregister(&tcpv6_prot);\r\ngoto out;\r\n}
