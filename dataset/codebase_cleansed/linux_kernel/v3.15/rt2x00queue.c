struct sk_buff *rt2x00queue_alloc_rxskb(struct queue_entry *entry, gfp_t gfp)\r\n{\r\nstruct data_queue *queue = entry->queue;\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nstruct sk_buff *skb;\r\nstruct skb_frame_desc *skbdesc;\r\nunsigned int frame_size;\r\nunsigned int head_size = 0;\r\nunsigned int tail_size = 0;\r\nframe_size = queue->data_size + queue->desc_size + queue->winfo_size;\r\nhead_size = 4;\r\nif (rt2x00_has_cap_hw_crypto(rt2x00dev)) {\r\nhead_size += 8;\r\ntail_size += 8;\r\n}\r\nskb = __dev_alloc_skb(frame_size + head_size + tail_size, gfp);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, head_size);\r\nskb_put(skb, frame_size);\r\nskbdesc = get_skb_frame_desc(skb);\r\nmemset(skbdesc, 0, sizeof(*skbdesc));\r\nskbdesc->entry = entry;\r\nif (test_bit(REQUIRE_DMA, &rt2x00dev->cap_flags)) {\r\ndma_addr_t skb_dma;\r\nskb_dma = dma_map_single(rt2x00dev->dev, skb->data, skb->len,\r\nDMA_FROM_DEVICE);\r\nif (unlikely(dma_mapping_error(rt2x00dev->dev, skb_dma))) {\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nskbdesc->skb_dma = skb_dma;\r\nskbdesc->flags |= SKBDESC_DMA_MAPPED_RX;\r\n}\r\nreturn skb;\r\n}\r\nint rt2x00queue_map_txskb(struct queue_entry *entry)\r\n{\r\nstruct device *dev = entry->queue->rt2x00dev->dev;\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\r\nskbdesc->skb_dma =\r\ndma_map_single(dev, entry->skb->data, entry->skb->len, DMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(dev, skbdesc->skb_dma)))\r\nreturn -ENOMEM;\r\nskbdesc->flags |= SKBDESC_DMA_MAPPED_TX;\r\nreturn 0;\r\n}\r\nvoid rt2x00queue_unmap_skb(struct queue_entry *entry)\r\n{\r\nstruct device *dev = entry->queue->rt2x00dev->dev;\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\r\nif (skbdesc->flags & SKBDESC_DMA_MAPPED_RX) {\r\ndma_unmap_single(dev, skbdesc->skb_dma, entry->skb->len,\r\nDMA_FROM_DEVICE);\r\nskbdesc->flags &= ~SKBDESC_DMA_MAPPED_RX;\r\n} else if (skbdesc->flags & SKBDESC_DMA_MAPPED_TX) {\r\ndma_unmap_single(dev, skbdesc->skb_dma, entry->skb->len,\r\nDMA_TO_DEVICE);\r\nskbdesc->flags &= ~SKBDESC_DMA_MAPPED_TX;\r\n}\r\n}\r\nvoid rt2x00queue_free_skb(struct queue_entry *entry)\r\n{\r\nif (!entry->skb)\r\nreturn;\r\nrt2x00queue_unmap_skb(entry);\r\ndev_kfree_skb_any(entry->skb);\r\nentry->skb = NULL;\r\n}\r\nvoid rt2x00queue_align_frame(struct sk_buff *skb)\r\n{\r\nunsigned int frame_length = skb->len;\r\nunsigned int align = ALIGN_SIZE(skb, 0);\r\nif (!align)\r\nreturn;\r\nskb_push(skb, align);\r\nmemmove(skb->data, skb->data + align, frame_length);\r\nskb_trim(skb, frame_length);\r\n}\r\nvoid rt2x00queue_insert_l2pad(struct sk_buff *skb, unsigned int header_length)\r\n{\r\nunsigned int payload_length = skb->len - header_length;\r\nunsigned int header_align = ALIGN_SIZE(skb, 0);\r\nunsigned int payload_align = ALIGN_SIZE(skb, header_length);\r\nunsigned int l2pad = payload_length ? L2PAD_SIZE(header_length) : 0;\r\nif (payload_align > header_align)\r\nheader_align += 4;\r\nif (!header_align)\r\nreturn;\r\nskb_push(skb, header_align);\r\nmemmove(skb->data, skb->data + header_align, header_length);\r\nif (payload_length && payload_align)\r\nmemmove(skb->data + header_length + l2pad,\r\nskb->data + header_length + l2pad + payload_align,\r\npayload_length);\r\nskb_trim(skb, header_length + l2pad + payload_length);\r\n}\r\nvoid rt2x00queue_remove_l2pad(struct sk_buff *skb, unsigned int header_length)\r\n{\r\nunsigned int l2pad = (skb->len > header_length) ?\r\nL2PAD_SIZE(header_length) : 0;\r\nif (!l2pad)\r\nreturn;\r\nmemmove(skb->data + l2pad, skb->data, header_length);\r\nskb_pull(skb, l2pad);\r\n}\r\nstatic void rt2x00queue_create_tx_descriptor_seq(struct rt2x00_dev *rt2x00dev,\r\nstruct sk_buff *skb,\r\nstruct txentry_desc *txdesc)\r\n{\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct rt2x00_intf *intf = vif_to_intf(tx_info->control.vif);\r\nu16 seqno;\r\nif (!(tx_info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ))\r\nreturn;\r\n__set_bit(ENTRY_TXD_GENERATE_SEQ, &txdesc->flags);\r\nif (!test_bit(REQUIRE_SW_SEQNO, &rt2x00dev->cap_flags)) {\r\nif (test_bit(CONFIG_QOS_DISABLED, &rt2x00dev->flags))\r\n__clear_bit(ENTRY_TXD_GENERATE_SEQ, &txdesc->flags);\r\nelse\r\nreturn;\r\n}\r\nif (test_bit(ENTRY_TXD_FIRST_FRAGMENT, &txdesc->flags))\r\nseqno = atomic_add_return(0x10, &intf->seqno);\r\nelse\r\nseqno = atomic_read(&intf->seqno);\r\nhdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\r\nhdr->seq_ctrl |= cpu_to_le16(seqno);\r\n}\r\nstatic void rt2x00queue_create_tx_descriptor_plcp(struct rt2x00_dev *rt2x00dev,\r\nstruct sk_buff *skb,\r\nstruct txentry_desc *txdesc,\r\nconst struct rt2x00_rate *hwrate)\r\n{\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_tx_rate *txrate = &tx_info->control.rates[0];\r\nunsigned int data_length;\r\nunsigned int duration;\r\nunsigned int residual;\r\nif (test_bit(ENTRY_TXD_FIRST_FRAGMENT, &txdesc->flags))\r\ntxdesc->u.plcp.ifs = IFS_BACKOFF;\r\nelse\r\ntxdesc->u.plcp.ifs = IFS_SIFS;\r\ndata_length = skb->len + 4;\r\ndata_length += rt2x00crypto_tx_overhead(rt2x00dev, skb);\r\ntxdesc->u.plcp.signal = hwrate->plcp;\r\ntxdesc->u.plcp.service = 0x04;\r\nif (hwrate->flags & DEV_RATE_OFDM) {\r\ntxdesc->u.plcp.length_high = (data_length >> 6) & 0x3f;\r\ntxdesc->u.plcp.length_low = data_length & 0x3f;\r\n} else {\r\nresidual = GET_DURATION_RES(data_length, hwrate->bitrate);\r\nduration = GET_DURATION(data_length, hwrate->bitrate);\r\nif (residual != 0) {\r\nduration++;\r\nif (hwrate->bitrate == 110 && residual <= 30)\r\ntxdesc->u.plcp.service |= 0x80;\r\n}\r\ntxdesc->u.plcp.length_high = (duration >> 8) & 0xff;\r\ntxdesc->u.plcp.length_low = duration & 0xff;\r\nif (txrate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\r\ntxdesc->u.plcp.signal |= 0x08;\r\n}\r\n}\r\nstatic void rt2x00queue_create_tx_descriptor_ht(struct rt2x00_dev *rt2x00dev,\r\nstruct sk_buff *skb,\r\nstruct txentry_desc *txdesc,\r\nstruct ieee80211_sta *sta,\r\nconst struct rt2x00_rate *hwrate)\r\n{\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_tx_rate *txrate = &tx_info->control.rates[0];\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct rt2x00_sta *sta_priv = NULL;\r\nif (sta) {\r\ntxdesc->u.ht.mpdu_density =\r\nsta->ht_cap.ampdu_density;\r\nsta_priv = sta_to_rt2x00_sta(sta);\r\ntxdesc->u.ht.wcid = sta_priv->wcid;\r\n}\r\nif (txrate->flags & IEEE80211_TX_RC_MCS) {\r\ntxdesc->u.ht.mcs = txrate->idx;\r\nif (sta && txdesc->u.ht.mcs > 7 &&\r\nsta->smps_mode == IEEE80211_SMPS_DYNAMIC)\r\n__set_bit(ENTRY_TXD_HT_MIMO_PS, &txdesc->flags);\r\n} else {\r\ntxdesc->u.ht.mcs = rt2x00_get_rate_mcs(hwrate->mcs);\r\nif (txrate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\r\ntxdesc->u.ht.mcs |= 0x08;\r\n}\r\nif (test_bit(CONFIG_HT_DISABLED, &rt2x00dev->flags)) {\r\nif (!(tx_info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT))\r\ntxdesc->u.ht.txop = TXOP_SIFS;\r\nelse\r\ntxdesc->u.ht.txop = TXOP_BACKOFF;\r\nreturn;\r\n}\r\ntxdesc->u.ht.ba_size = 7;\r\nif (tx_info->flags & IEEE80211_TX_CTL_STBC)\r\ntxdesc->u.ht.stbc = 1;\r\nif (tx_info->flags & IEEE80211_TX_CTL_AMPDU &&\r\n!(tx_info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE))\r\n__set_bit(ENTRY_TXD_HT_AMPDU, &txdesc->flags);\r\nif (txrate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH ||\r\ntxrate->flags & IEEE80211_TX_RC_DUP_DATA)\r\n__set_bit(ENTRY_TXD_HT_BW_40, &txdesc->flags);\r\nif (txrate->flags & IEEE80211_TX_RC_SHORT_GI)\r\n__set_bit(ENTRY_TXD_HT_SHORT_GI, &txdesc->flags);\r\nif (ieee80211_is_mgmt(hdr->frame_control) &&\r\n!ieee80211_is_beacon(hdr->frame_control))\r\ntxdesc->u.ht.txop = TXOP_BACKOFF;\r\nelse if (!(tx_info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT))\r\ntxdesc->u.ht.txop = TXOP_SIFS;\r\nelse\r\ntxdesc->u.ht.txop = TXOP_HTTXOP;\r\n}\r\nstatic void rt2x00queue_create_tx_descriptor(struct rt2x00_dev *rt2x00dev,\r\nstruct sk_buff *skb,\r\nstruct txentry_desc *txdesc,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct ieee80211_tx_rate *txrate = &tx_info->control.rates[0];\r\nstruct ieee80211_rate *rate;\r\nconst struct rt2x00_rate *hwrate = NULL;\r\nmemset(txdesc, 0, sizeof(*txdesc));\r\ntxdesc->length = skb->len;\r\ntxdesc->header_length = ieee80211_get_hdrlen_from_skb(skb);\r\nif (!(tx_info->flags & IEEE80211_TX_CTL_NO_ACK))\r\n__set_bit(ENTRY_TXD_ACK, &txdesc->flags);\r\nif (ieee80211_is_rts(hdr->frame_control) ||\r\nieee80211_is_cts(hdr->frame_control)) {\r\n__set_bit(ENTRY_TXD_BURST, &txdesc->flags);\r\nif (ieee80211_is_rts(hdr->frame_control))\r\n__set_bit(ENTRY_TXD_RTS_FRAME, &txdesc->flags);\r\nelse\r\n__set_bit(ENTRY_TXD_CTS_FRAME, &txdesc->flags);\r\nif (tx_info->control.rts_cts_rate_idx >= 0)\r\nrate =\r\nieee80211_get_rts_cts_rate(rt2x00dev->hw, tx_info);\r\n}\r\ntxdesc->retry_limit = tx_info->control.rates[0].count - 1;\r\nif (txdesc->retry_limit >= rt2x00dev->long_retry)\r\n__set_bit(ENTRY_TXD_RETRY_MODE, &txdesc->flags);\r\nif (ieee80211_has_morefrags(hdr->frame_control)) {\r\n__set_bit(ENTRY_TXD_BURST, &txdesc->flags);\r\n__set_bit(ENTRY_TXD_MORE_FRAG, &txdesc->flags);\r\n}\r\nif (tx_info->flags & IEEE80211_TX_CTL_MORE_FRAMES)\r\n__set_bit(ENTRY_TXD_BURST, &txdesc->flags);\r\nif (ieee80211_is_beacon(hdr->frame_control) ||\r\nieee80211_is_probe_resp(hdr->frame_control))\r\n__set_bit(ENTRY_TXD_REQ_TIMESTAMP, &txdesc->flags);\r\nif ((tx_info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT) &&\r\n!test_bit(ENTRY_TXD_RTS_FRAME, &txdesc->flags))\r\n__set_bit(ENTRY_TXD_FIRST_FRAGMENT, &txdesc->flags);\r\nif (txrate->flags & IEEE80211_TX_RC_GREEN_FIELD)\r\ntxdesc->rate_mode = RATE_MODE_HT_GREENFIELD;\r\nelse if (txrate->flags & IEEE80211_TX_RC_MCS)\r\ntxdesc->rate_mode = RATE_MODE_HT_MIX;\r\nelse {\r\nrate = ieee80211_get_tx_rate(rt2x00dev->hw, tx_info);\r\nhwrate = rt2x00_get_rate(rate->hw_value);\r\nif (hwrate->flags & DEV_RATE_OFDM)\r\ntxdesc->rate_mode = RATE_MODE_OFDM;\r\nelse\r\ntxdesc->rate_mode = RATE_MODE_CCK;\r\n}\r\nrt2x00crypto_create_tx_descriptor(rt2x00dev, skb, txdesc);\r\nrt2x00queue_create_tx_descriptor_seq(rt2x00dev, skb, txdesc);\r\nif (test_bit(REQUIRE_HT_TX_DESC, &rt2x00dev->cap_flags))\r\nrt2x00queue_create_tx_descriptor_ht(rt2x00dev, skb, txdesc,\r\nsta, hwrate);\r\nelse\r\nrt2x00queue_create_tx_descriptor_plcp(rt2x00dev, skb, txdesc,\r\nhwrate);\r\n}\r\nstatic int rt2x00queue_write_tx_data(struct queue_entry *entry,\r\nstruct txentry_desc *txdesc)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nif (unlikely(rt2x00dev->ops->lib->get_entry_state &&\r\nrt2x00dev->ops->lib->get_entry_state(entry))) {\r\nrt2x00_err(rt2x00dev,\r\n"Corrupt queue %d, accessing entry which is not ours\n"\r\n"Please file bug report to %s\n",\r\nentry->queue->qid, DRV_PROJECT);\r\nreturn -EINVAL;\r\n}\r\nskb_push(entry->skb, rt2x00dev->extra_tx_headroom);\r\nmemset(entry->skb->data, 0, rt2x00dev->extra_tx_headroom);\r\nif (rt2x00dev->ops->lib->write_tx_data)\r\nrt2x00dev->ops->lib->write_tx_data(entry, txdesc);\r\nif (test_bit(REQUIRE_DMA, &rt2x00dev->cap_flags) &&\r\nrt2x00queue_map_txskb(entry))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void rt2x00queue_write_tx_descriptor(struct queue_entry *entry,\r\nstruct txentry_desc *txdesc)\r\n{\r\nstruct data_queue *queue = entry->queue;\r\nqueue->rt2x00dev->ops->lib->write_tx_desc(entry, txdesc);\r\nrt2x00debug_dump_frame(queue->rt2x00dev, DUMP_FRAME_TX, entry->skb);\r\n}\r\nstatic void rt2x00queue_kick_tx_queue(struct data_queue *queue,\r\nstruct txentry_desc *txdesc)\r\n{\r\nif (rt2x00queue_threshold(queue) ||\r\n!test_bit(ENTRY_TXD_BURST, &txdesc->flags))\r\nqueue->rt2x00dev->ops->lib->kick_queue(queue);\r\n}\r\nstatic void rt2x00queue_bar_check(struct queue_entry *entry)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nstruct ieee80211_bar *bar = (void *) (entry->skb->data +\r\nrt2x00dev->extra_tx_headroom);\r\nstruct rt2x00_bar_list_entry *bar_entry;\r\nif (likely(!ieee80211_is_back_req(bar->frame_control)))\r\nreturn;\r\nbar_entry = kmalloc(sizeof(*bar_entry), GFP_ATOMIC);\r\nif (!bar_entry)\r\nreturn;\r\nbar_entry->entry = entry;\r\nbar_entry->block_acked = 0;\r\nmemcpy(bar_entry->ra, bar->ra, sizeof(bar->ra));\r\nmemcpy(bar_entry->ta, bar->ta, sizeof(bar->ta));\r\nbar_entry->control = bar->control;\r\nbar_entry->start_seq_num = bar->start_seq_num;\r\nspin_lock_bh(&rt2x00dev->bar_list_lock);\r\nlist_add_tail_rcu(&bar_entry->list, &rt2x00dev->bar_list);\r\nspin_unlock_bh(&rt2x00dev->bar_list_lock);\r\n}\r\nint rt2x00queue_write_tx_frame(struct data_queue *queue, struct sk_buff *skb,\r\nstruct ieee80211_sta *sta, bool local)\r\n{\r\nstruct ieee80211_tx_info *tx_info;\r\nstruct queue_entry *entry;\r\nstruct txentry_desc txdesc;\r\nstruct skb_frame_desc *skbdesc;\r\nu8 rate_idx, rate_flags;\r\nint ret = 0;\r\nrt2x00queue_create_tx_descriptor(queue->rt2x00dev, skb, &txdesc, sta);\r\ntx_info = IEEE80211_SKB_CB(skb);\r\nrate_idx = tx_info->control.rates[0].idx;\r\nrate_flags = tx_info->control.rates[0].flags;\r\nskbdesc = get_skb_frame_desc(skb);\r\nmemset(skbdesc, 0, sizeof(*skbdesc));\r\nskbdesc->tx_rate_idx = rate_idx;\r\nskbdesc->tx_rate_flags = rate_flags;\r\nif (local)\r\nskbdesc->flags |= SKBDESC_NOT_MAC80211;\r\nif (test_bit(ENTRY_TXD_ENCRYPT, &txdesc.flags) &&\r\n!test_bit(ENTRY_TXD_ENCRYPT_IV, &txdesc.flags)) {\r\nif (test_bit(REQUIRE_COPY_IV, &queue->rt2x00dev->cap_flags))\r\nrt2x00crypto_tx_copy_iv(skb, &txdesc);\r\nelse\r\nrt2x00crypto_tx_remove_iv(skb, &txdesc);\r\n}\r\nif (test_bit(REQUIRE_L2PAD, &queue->rt2x00dev->cap_flags))\r\nrt2x00queue_insert_l2pad(skb, txdesc.header_length);\r\nelse if (test_bit(REQUIRE_DMA, &queue->rt2x00dev->cap_flags))\r\nrt2x00queue_align_frame(skb);\r\nspin_lock(&queue->tx_lock);\r\nif (unlikely(rt2x00queue_full(queue))) {\r\nrt2x00_err(queue->rt2x00dev, "Dropping frame due to full tx queue %d\n",\r\nqueue->qid);\r\nret = -ENOBUFS;\r\ngoto out;\r\n}\r\nentry = rt2x00queue_get_entry(queue, Q_INDEX);\r\nif (unlikely(test_and_set_bit(ENTRY_OWNER_DEVICE_DATA,\r\n&entry->flags))) {\r\nrt2x00_err(queue->rt2x00dev,\r\n"Arrived at non-free entry in the non-full queue %d\n"\r\n"Please file bug report to %s\n",\r\nqueue->qid, DRV_PROJECT);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nskbdesc->entry = entry;\r\nentry->skb = skb;\r\nif (unlikely(rt2x00queue_write_tx_data(entry, &txdesc))) {\r\nclear_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags);\r\nentry->skb = NULL;\r\nret = -EIO;\r\ngoto out;\r\n}\r\nrt2x00queue_bar_check(entry);\r\nset_bit(ENTRY_DATA_PENDING, &entry->flags);\r\nrt2x00queue_index_inc(entry, Q_INDEX);\r\nrt2x00queue_write_tx_descriptor(entry, &txdesc);\r\nrt2x00queue_kick_tx_queue(queue, &txdesc);\r\nout:\r\nspin_unlock(&queue->tx_lock);\r\nreturn ret;\r\n}\r\nint rt2x00queue_clear_beacon(struct rt2x00_dev *rt2x00dev,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rt2x00_intf *intf = vif_to_intf(vif);\r\nif (unlikely(!intf->beacon))\r\nreturn -ENOBUFS;\r\nmutex_lock(&intf->beacon_skb_mutex);\r\nrt2x00queue_free_skb(intf->beacon);\r\nif (rt2x00dev->ops->lib->clear_beacon)\r\nrt2x00dev->ops->lib->clear_beacon(intf->beacon);\r\nmutex_unlock(&intf->beacon_skb_mutex);\r\nreturn 0;\r\n}\r\nint rt2x00queue_update_beacon_locked(struct rt2x00_dev *rt2x00dev,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rt2x00_intf *intf = vif_to_intf(vif);\r\nstruct skb_frame_desc *skbdesc;\r\nstruct txentry_desc txdesc;\r\nif (unlikely(!intf->beacon))\r\nreturn -ENOBUFS;\r\nrt2x00queue_free_skb(intf->beacon);\r\nintf->beacon->skb = ieee80211_beacon_get(rt2x00dev->hw, vif);\r\nif (!intf->beacon->skb)\r\nreturn -ENOMEM;\r\nrt2x00queue_create_tx_descriptor(rt2x00dev, intf->beacon->skb, &txdesc, NULL);\r\nskbdesc = get_skb_frame_desc(intf->beacon->skb);\r\nmemset(skbdesc, 0, sizeof(*skbdesc));\r\nskbdesc->entry = intf->beacon;\r\nrt2x00dev->ops->lib->write_beacon(intf->beacon, &txdesc);\r\nreturn 0;\r\n}\r\nint rt2x00queue_update_beacon(struct rt2x00_dev *rt2x00dev,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rt2x00_intf *intf = vif_to_intf(vif);\r\nint ret;\r\nmutex_lock(&intf->beacon_skb_mutex);\r\nret = rt2x00queue_update_beacon_locked(rt2x00dev, vif);\r\nmutex_unlock(&intf->beacon_skb_mutex);\r\nreturn ret;\r\n}\r\nbool rt2x00queue_for_each_entry(struct data_queue *queue,\r\nenum queue_index start,\r\nenum queue_index end,\r\nvoid *data,\r\nbool (*fn)(struct queue_entry *entry,\r\nvoid *data))\r\n{\r\nunsigned long irqflags;\r\nunsigned int index_start;\r\nunsigned int index_end;\r\nunsigned int i;\r\nif (unlikely(start >= Q_INDEX_MAX || end >= Q_INDEX_MAX)) {\r\nrt2x00_err(queue->rt2x00dev,\r\n"Entry requested from invalid index range (%d - %d)\n",\r\nstart, end);\r\nreturn true;\r\n}\r\nspin_lock_irqsave(&queue->index_lock, irqflags);\r\nindex_start = queue->index[start];\r\nindex_end = queue->index[end];\r\nspin_unlock_irqrestore(&queue->index_lock, irqflags);\r\nif (index_start < index_end) {\r\nfor (i = index_start; i < index_end; i++) {\r\nif (fn(&queue->entries[i], data))\r\nreturn true;\r\n}\r\n} else {\r\nfor (i = index_start; i < queue->limit; i++) {\r\nif (fn(&queue->entries[i], data))\r\nreturn true;\r\n}\r\nfor (i = 0; i < index_end; i++) {\r\nif (fn(&queue->entries[i], data))\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstruct queue_entry *rt2x00queue_get_entry(struct data_queue *queue,\r\nenum queue_index index)\r\n{\r\nstruct queue_entry *entry;\r\nunsigned long irqflags;\r\nif (unlikely(index >= Q_INDEX_MAX)) {\r\nrt2x00_err(queue->rt2x00dev, "Entry requested from invalid index type (%d)\n",\r\nindex);\r\nreturn NULL;\r\n}\r\nspin_lock_irqsave(&queue->index_lock, irqflags);\r\nentry = &queue->entries[queue->index[index]];\r\nspin_unlock_irqrestore(&queue->index_lock, irqflags);\r\nreturn entry;\r\n}\r\nvoid rt2x00queue_index_inc(struct queue_entry *entry, enum queue_index index)\r\n{\r\nstruct data_queue *queue = entry->queue;\r\nunsigned long irqflags;\r\nif (unlikely(index >= Q_INDEX_MAX)) {\r\nrt2x00_err(queue->rt2x00dev,\r\n"Index change on invalid index type (%d)\n", index);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&queue->index_lock, irqflags);\r\nqueue->index[index]++;\r\nif (queue->index[index] >= queue->limit)\r\nqueue->index[index] = 0;\r\nentry->last_action = jiffies;\r\nif (index == Q_INDEX) {\r\nqueue->length++;\r\n} else if (index == Q_INDEX_DONE) {\r\nqueue->length--;\r\nqueue->count++;\r\n}\r\nspin_unlock_irqrestore(&queue->index_lock, irqflags);\r\n}\r\nstatic void rt2x00queue_pause_queue_nocheck(struct data_queue *queue)\r\n{\r\nswitch (queue->qid) {\r\ncase QID_AC_VO:\r\ncase QID_AC_VI:\r\ncase QID_AC_BE:\r\ncase QID_AC_BK:\r\nieee80211_stop_queue(queue->rt2x00dev->hw, queue->qid);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid rt2x00queue_pause_queue(struct data_queue *queue)\r\n{\r\nif (!test_bit(DEVICE_STATE_PRESENT, &queue->rt2x00dev->flags) ||\r\n!test_bit(QUEUE_STARTED, &queue->flags) ||\r\ntest_and_set_bit(QUEUE_PAUSED, &queue->flags))\r\nreturn;\r\nrt2x00queue_pause_queue_nocheck(queue);\r\n}\r\nvoid rt2x00queue_unpause_queue(struct data_queue *queue)\r\n{\r\nif (!test_bit(DEVICE_STATE_PRESENT, &queue->rt2x00dev->flags) ||\r\n!test_bit(QUEUE_STARTED, &queue->flags) ||\r\n!test_and_clear_bit(QUEUE_PAUSED, &queue->flags))\r\nreturn;\r\nswitch (queue->qid) {\r\ncase QID_AC_VO:\r\ncase QID_AC_VI:\r\ncase QID_AC_BE:\r\ncase QID_AC_BK:\r\nieee80211_wake_queue(queue->rt2x00dev->hw, queue->qid);\r\nbreak;\r\ncase QID_RX:\r\nqueue->rt2x00dev->ops->lib->kick_queue(queue);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid rt2x00queue_start_queue(struct data_queue *queue)\r\n{\r\nmutex_lock(&queue->status_lock);\r\nif (!test_bit(DEVICE_STATE_PRESENT, &queue->rt2x00dev->flags) ||\r\ntest_and_set_bit(QUEUE_STARTED, &queue->flags)) {\r\nmutex_unlock(&queue->status_lock);\r\nreturn;\r\n}\r\nset_bit(QUEUE_PAUSED, &queue->flags);\r\nqueue->rt2x00dev->ops->lib->start_queue(queue);\r\nrt2x00queue_unpause_queue(queue);\r\nmutex_unlock(&queue->status_lock);\r\n}\r\nvoid rt2x00queue_stop_queue(struct data_queue *queue)\r\n{\r\nmutex_lock(&queue->status_lock);\r\nif (!test_and_clear_bit(QUEUE_STARTED, &queue->flags)) {\r\nmutex_unlock(&queue->status_lock);\r\nreturn;\r\n}\r\nrt2x00queue_pause_queue_nocheck(queue);\r\nqueue->rt2x00dev->ops->lib->stop_queue(queue);\r\nmutex_unlock(&queue->status_lock);\r\n}\r\nvoid rt2x00queue_flush_queue(struct data_queue *queue, bool drop)\r\n{\r\nbool tx_queue =\r\n(queue->qid == QID_AC_VO) ||\r\n(queue->qid == QID_AC_VI) ||\r\n(queue->qid == QID_AC_BE) ||\r\n(queue->qid == QID_AC_BK);\r\nif (!drop && tx_queue)\r\nqueue->rt2x00dev->ops->lib->kick_queue(queue);\r\nif (likely(queue->rt2x00dev->ops->lib->flush_queue))\r\nqueue->rt2x00dev->ops->lib->flush_queue(queue, drop);\r\nif (unlikely(!rt2x00queue_empty(queue)))\r\nrt2x00_warn(queue->rt2x00dev, "Queue %d failed to flush\n",\r\nqueue->qid);\r\n}\r\nvoid rt2x00queue_start_queues(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\ntx_queue_for_each(rt2x00dev, queue)\r\nrt2x00queue_start_queue(queue);\r\nrt2x00queue_start_queue(rt2x00dev->rx);\r\n}\r\nvoid rt2x00queue_stop_queues(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nieee80211_stop_queues(rt2x00dev->hw);\r\ntx_queue_for_each(rt2x00dev, queue)\r\nrt2x00queue_stop_queue(queue);\r\nrt2x00queue_stop_queue(rt2x00dev->rx);\r\n}\r\nvoid rt2x00queue_flush_queues(struct rt2x00_dev *rt2x00dev, bool drop)\r\n{\r\nstruct data_queue *queue;\r\ntx_queue_for_each(rt2x00dev, queue)\r\nrt2x00queue_flush_queue(queue, drop);\r\nrt2x00queue_flush_queue(rt2x00dev->rx, drop);\r\n}\r\nstatic void rt2x00queue_reset(struct data_queue *queue)\r\n{\r\nunsigned long irqflags;\r\nunsigned int i;\r\nspin_lock_irqsave(&queue->index_lock, irqflags);\r\nqueue->count = 0;\r\nqueue->length = 0;\r\nfor (i = 0; i < Q_INDEX_MAX; i++)\r\nqueue->index[i] = 0;\r\nspin_unlock_irqrestore(&queue->index_lock, irqflags);\r\n}\r\nvoid rt2x00queue_init_queues(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nunsigned int i;\r\nqueue_for_each(rt2x00dev, queue) {\r\nrt2x00queue_reset(queue);\r\nfor (i = 0; i < queue->limit; i++)\r\nrt2x00dev->ops->lib->clear_entry(&queue->entries[i]);\r\n}\r\n}\r\nstatic int rt2x00queue_alloc_entries(struct data_queue *queue)\r\n{\r\nstruct queue_entry *entries;\r\nunsigned int entry_size;\r\nunsigned int i;\r\nrt2x00queue_reset(queue);\r\nentry_size = sizeof(*entries) + queue->priv_size;\r\nentries = kcalloc(queue->limit, entry_size, GFP_KERNEL);\r\nif (!entries)\r\nreturn -ENOMEM;\r\n#define QUEUE_ENTRY_PRIV_OFFSET(__base, __index, __limit, __esize, __psize) \\r\n(((char *)(__base)) + ((__limit) * (__esize)) + \\r\n((__index) * (__psize)))\r\nfor (i = 0; i < queue->limit; i++) {\r\nentries[i].flags = 0;\r\nentries[i].queue = queue;\r\nentries[i].skb = NULL;\r\nentries[i].entry_idx = i;\r\nentries[i].priv_data =\r\nQUEUE_ENTRY_PRIV_OFFSET(entries, i, queue->limit,\r\nsizeof(*entries), queue->priv_size);\r\n}\r\n#undef QUEUE_ENTRY_PRIV_OFFSET\r\nqueue->entries = entries;\r\nreturn 0;\r\n}\r\nstatic void rt2x00queue_free_skbs(struct data_queue *queue)\r\n{\r\nunsigned int i;\r\nif (!queue->entries)\r\nreturn;\r\nfor (i = 0; i < queue->limit; i++) {\r\nrt2x00queue_free_skb(&queue->entries[i]);\r\n}\r\n}\r\nstatic int rt2x00queue_alloc_rxskbs(struct data_queue *queue)\r\n{\r\nunsigned int i;\r\nstruct sk_buff *skb;\r\nfor (i = 0; i < queue->limit; i++) {\r\nskb = rt2x00queue_alloc_rxskb(&queue->entries[i], GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nqueue->entries[i].skb = skb;\r\n}\r\nreturn 0;\r\n}\r\nint rt2x00queue_initialize(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nint status;\r\nstatus = rt2x00queue_alloc_entries(rt2x00dev->rx);\r\nif (status)\r\ngoto exit;\r\ntx_queue_for_each(rt2x00dev, queue) {\r\nstatus = rt2x00queue_alloc_entries(queue);\r\nif (status)\r\ngoto exit;\r\n}\r\nstatus = rt2x00queue_alloc_entries(rt2x00dev->bcn);\r\nif (status)\r\ngoto exit;\r\nif (test_bit(REQUIRE_ATIM_QUEUE, &rt2x00dev->cap_flags)) {\r\nstatus = rt2x00queue_alloc_entries(rt2x00dev->atim);\r\nif (status)\r\ngoto exit;\r\n}\r\nstatus = rt2x00queue_alloc_rxskbs(rt2x00dev->rx);\r\nif (status)\r\ngoto exit;\r\nreturn 0;\r\nexit:\r\nrt2x00_err(rt2x00dev, "Queue entries allocation failed\n");\r\nrt2x00queue_uninitialize(rt2x00dev);\r\nreturn status;\r\n}\r\nvoid rt2x00queue_uninitialize(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nrt2x00queue_free_skbs(rt2x00dev->rx);\r\nqueue_for_each(rt2x00dev, queue) {\r\nkfree(queue->entries);\r\nqueue->entries = NULL;\r\n}\r\n}\r\nstatic void rt2x00queue_init(struct rt2x00_dev *rt2x00dev,\r\nstruct data_queue *queue, enum data_queue_qid qid)\r\n{\r\nmutex_init(&queue->status_lock);\r\nspin_lock_init(&queue->tx_lock);\r\nspin_lock_init(&queue->index_lock);\r\nqueue->rt2x00dev = rt2x00dev;\r\nqueue->qid = qid;\r\nqueue->txop = 0;\r\nqueue->aifs = 2;\r\nqueue->cw_min = 5;\r\nqueue->cw_max = 10;\r\nrt2x00dev->ops->queue_init(queue);\r\nqueue->threshold = DIV_ROUND_UP(queue->limit, 10);\r\n}\r\nint rt2x00queue_allocate(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nenum data_queue_qid qid;\r\nunsigned int req_atim =\r\n!!test_bit(REQUIRE_ATIM_QUEUE, &rt2x00dev->cap_flags);\r\nrt2x00dev->data_queues = 2 + rt2x00dev->ops->tx_queues + req_atim;\r\nqueue = kcalloc(rt2x00dev->data_queues, sizeof(*queue), GFP_KERNEL);\r\nif (!queue) {\r\nrt2x00_err(rt2x00dev, "Queue allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nrt2x00dev->rx = queue;\r\nrt2x00dev->tx = &queue[1];\r\nrt2x00dev->bcn = &queue[1 + rt2x00dev->ops->tx_queues];\r\nrt2x00dev->atim = req_atim ? &queue[2 + rt2x00dev->ops->tx_queues] : NULL;\r\nrt2x00queue_init(rt2x00dev, rt2x00dev->rx, QID_RX);\r\nqid = QID_AC_VO;\r\ntx_queue_for_each(rt2x00dev, queue)\r\nrt2x00queue_init(rt2x00dev, queue, qid++);\r\nrt2x00queue_init(rt2x00dev, rt2x00dev->bcn, QID_BEACON);\r\nif (req_atim)\r\nrt2x00queue_init(rt2x00dev, rt2x00dev->atim, QID_ATIM);\r\nreturn 0;\r\n}\r\nvoid rt2x00queue_free(struct rt2x00_dev *rt2x00dev)\r\n{\r\nkfree(rt2x00dev->rx);\r\nrt2x00dev->rx = NULL;\r\nrt2x00dev->tx = NULL;\r\nrt2x00dev->bcn = NULL;\r\n}
