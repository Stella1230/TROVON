static u8 ec_read_u8(u8 addr)\r\n{\r\nu8 value;\r\nec_read(addr, &value);\r\nreturn value;\r\n}\r\nstatic s8 ec_read_s8(u8 addr)\r\n{\r\nreturn (s8)ec_read_u8(addr);\r\n}\r\nstatic u16 ec_read_u16(u8 addr)\r\n{\r\nint hi, lo;\r\nlo = ec_read_u8(addr);\r\nhi = ec_read_u8(addr + 1);\r\nreturn (hi << 8) + lo;\r\n}\r\nstatic s16 ec_read_s16(u8 addr)\r\n{\r\nreturn (s16) ec_read_u16(addr);\r\n}\r\nstatic void ec_read_sequence(u8 addr, u8 *buf, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nec_read(addr + i, buf + i);\r\n}\r\nstatic int set_backlight_level(int level)\r\n{\r\nif (level < 0 || level > BACKLIGHT_LEVEL_MAX)\r\nreturn -EINVAL;\r\nec_write(BACKLIGHT_LEVEL_ADDR, level);\r\nreturn 0;\r\n}\r\nstatic int get_backlight_level(void)\r\n{\r\nreturn (int) ec_read_u8(BACKLIGHT_LEVEL_ADDR);\r\n}\r\nstatic void set_backlight_state(bool on)\r\n{\r\nu8 data = on ? BACKLIGHT_STATE_ON_DATA : BACKLIGHT_STATE_OFF_DATA;\r\nec_transaction(BACKLIGHT_STATE_ADDR, &data, 1, NULL, 0);\r\n}\r\nstatic void pwm_enable_control(void)\r\n{\r\nunsigned char writeData = PWM_ENABLE_DATA;\r\nec_transaction(PWM_ENABLE_ADDR, &writeData, 1, NULL, 0);\r\n}\r\nstatic void pwm_disable_control(void)\r\n{\r\nunsigned char writeData = PWM_DISABLE_DATA;\r\nec_transaction(PWM_DISABLE_ADDR, &writeData, 1, NULL, 0);\r\n}\r\nstatic void set_pwm(int pwm)\r\n{\r\nec_transaction(PWM_ADDRESS, &pwm_lookup_table[pwm], 1, NULL, 0);\r\n}\r\nstatic int get_fan_rpm(void)\r\n{\r\nu8 value, data = FAN_DATA;\r\nec_transaction(FAN_ADDRESS, &data, 1, &value, 1);\r\nreturn 100 * (int)value;\r\n}\r\nstatic int bl_get_brightness(struct backlight_device *b)\r\n{\r\nreturn get_backlight_level();\r\n}\r\nstatic int bl_update_status(struct backlight_device *b)\r\n{\r\nint ret = set_backlight_level(b->props.brightness);\r\nif (ret)\r\nreturn ret;\r\nset_backlight_state((b->props.power == FB_BLANK_UNBLANK)\r\n&& !(b->props.state & BL_CORE_SUSPENDED)\r\n&& !(b->props.state & BL_CORE_FBBLANK));\r\nreturn 0;\r\n}\r\nstatic int compal_rfkill_set(void *data, bool blocked)\r\n{\r\nunsigned long radio = (unsigned long) data;\r\nu8 result = ec_read_u8(WIRELESS_ADDR);\r\nu8 value;\r\nif (!blocked)\r\nvalue = (u8) (result | radio);\r\nelse\r\nvalue = (u8) (result & ~radio);\r\nec_write(WIRELESS_ADDR, value);\r\nreturn 0;\r\n}\r\nstatic void compal_rfkill_poll(struct rfkill *rfkill, void *data)\r\n{\r\nu8 result = ec_read_u8(WIRELESS_ADDR);\r\nbool hw_blocked = !(result & WIRELESS_KILLSWITCH);\r\nrfkill_set_hw_state(rfkill, hw_blocked);\r\n}\r\nstatic ssize_t pwm_enable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct compal_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm_enable);\r\n}\r\nstatic ssize_t pwm_enable_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct compal_data *data = dev_get_drvdata(dev);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val < 0)\r\nreturn -EINVAL;\r\ndata->pwm_enable = val;\r\nswitch (val) {\r\ncase 0:\r\npwm_enable_control();\r\nset_pwm(255);\r\nbreak;\r\ncase 1:\r\npwm_enable_control();\r\nset_pwm(data->curr_pwm);\r\nbreak;\r\ndefault:\r\npwm_disable_control();\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t pwm_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct compal_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%hhu\n", data->curr_pwm);\r\n}\r\nstatic ssize_t pwm_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct compal_data *data = dev_get_drvdata(dev);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val < 0 || val > 255)\r\nreturn -EINVAL;\r\ndata->curr_pwm = val;\r\nif (data->pwm_enable != 1)\r\nreturn count;\r\nset_pwm(val);\r\nreturn count;\r\n}\r\nstatic ssize_t fan_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", get_fan_rpm());\r\n}\r\nstatic int bat_status(void)\r\n{\r\nu8 status0 = ec_read_u8(BAT_STATUS0);\r\nu8 status1 = ec_read_u8(BAT_STATUS1);\r\nif (status0 & BAT_S0_CHARGING)\r\nreturn POWER_SUPPLY_STATUS_CHARGING;\r\nif (status0 & BAT_S0_DISCHARGE)\r\nreturn POWER_SUPPLY_STATUS_DISCHARGING;\r\nif (status1 & BAT_S1_FULL)\r\nreturn POWER_SUPPLY_STATUS_FULL;\r\nreturn POWER_SUPPLY_STATUS_NOT_CHARGING;\r\n}\r\nstatic int bat_health(void)\r\n{\r\nu8 status = ec_read_u8(BAT_STOP_CHARGE1);\r\nif (status & BAT_STOP_CHRG1_OVERTEMPERATURE)\r\nreturn POWER_SUPPLY_HEALTH_OVERHEAT;\r\nif (status & BAT_STOP_CHRG1_OVERVOLTAGE)\r\nreturn POWER_SUPPLY_HEALTH_OVERVOLTAGE;\r\nif (status & BAT_STOP_CHRG1_BAD_CELL)\r\nreturn POWER_SUPPLY_HEALTH_DEAD;\r\nif (status & BAT_STOP_CHRG1_COMM_FAIL)\r\nreturn POWER_SUPPLY_HEALTH_UNKNOWN;\r\nreturn POWER_SUPPLY_HEALTH_GOOD;\r\n}\r\nstatic int bat_is_present(void)\r\n{\r\nu8 status = ec_read_u8(BAT_STATUS2);\r\nreturn ((status & BAT_S1_EXISTS) != 0);\r\n}\r\nstatic int bat_technology(void)\r\n{\r\nu8 status = ec_read_u8(BAT_STATUS1);\r\nif (status & BAT_S1_LiION_OR_NiMH)\r\nreturn POWER_SUPPLY_TECHNOLOGY_LION;\r\nreturn POWER_SUPPLY_TECHNOLOGY_NiMH;\r\n}\r\nstatic int bat_capacity_level(void)\r\n{\r\nu8 status0 = ec_read_u8(BAT_STATUS0);\r\nu8 status1 = ec_read_u8(BAT_STATUS1);\r\nu8 status2 = ec_read_u8(BAT_STATUS2);\r\nif (status0 & BAT_S0_DISCHRG_CRITICAL\r\n|| status1 & BAT_S1_EMPTY\r\n|| status2 & BAT_S2_LOW_LOW)\r\nreturn POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\r\nif (status0 & BAT_S0_LOW)\r\nreturn POWER_SUPPLY_CAPACITY_LEVEL_LOW;\r\nif (status1 & BAT_S1_FULL)\r\nreturn POWER_SUPPLY_CAPACITY_LEVEL_FULL;\r\nreturn POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\r\n}\r\nstatic int bat_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct compal_data *data;\r\ndata = container_of(psy, struct compal_data, psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nval->intval = bat_status();\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nval->intval = bat_health();\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = bat_is_present();\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = bat_technology();\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\nval->intval = ec_read_u16(BAT_VOLTAGE_DESIGN) * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nval->intval = ec_read_u16(BAT_VOLTAGE_NOW) * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nval->intval = ec_read_s16(BAT_CURRENT_NOW) * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_AVG:\r\nval->intval = ec_read_s16(BAT_CURRENT_AVG) * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_POWER_NOW:\r\nval->intval = ec_read_u8(BAT_POWER) * 1000000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nval->intval = ec_read_u16(BAT_CHARGE_DESIGN) * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nval->intval = ec_read_u16(BAT_CHARGE_NOW) * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nval->intval = ec_read_u8(BAT_CAPACITY);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\r\nval->intval = bat_capacity_level();\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nval->intval = ((222 - (int)ec_read_u8(BAT_TEMP)) * 1000) >> 8;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP_AMBIENT:\r\nval->intval = ec_read_s8(BAT_TEMP_AVG) * 10;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = data->bat_model_name;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MANUFACTURER:\r\nval->strval = data->bat_manufacturer_name;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SERIAL_NUMBER:\r\nval->strval = data->bat_serial_number;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dmi_check_cb(const struct dmi_system_id *id)\r\n{\r\npr_info("Identified laptop model '%s'\n", id->ident);\r\nextra_features = false;\r\nreturn 1;\r\n}\r\nstatic int dmi_check_cb_extra(const struct dmi_system_id *id)\r\n{\r\npr_info("Identified laptop model '%s', enabling extra features\n",\r\nid->ident);\r\nextra_features = true;\r\nreturn 1;\r\n}\r\nstatic void initialize_power_supply_data(struct compal_data *data)\r\n{\r\ndata->psy.name = DRIVER_NAME;\r\ndata->psy.type = POWER_SUPPLY_TYPE_BATTERY;\r\ndata->psy.properties = compal_bat_properties;\r\ndata->psy.num_properties = ARRAY_SIZE(compal_bat_properties);\r\ndata->psy.get_property = bat_get_property;\r\nec_read_sequence(BAT_MANUFACTURER_NAME_ADDR,\r\ndata->bat_manufacturer_name,\r\nBAT_MANUFACTURER_NAME_LEN);\r\ndata->bat_manufacturer_name[BAT_MANUFACTURER_NAME_LEN] = 0;\r\nec_read_sequence(BAT_MODEL_NAME_ADDR,\r\ndata->bat_model_name,\r\nBAT_MODEL_NAME_LEN);\r\ndata->bat_model_name[BAT_MODEL_NAME_LEN] = 0;\r\nscnprintf(data->bat_serial_number, BAT_SERIAL_NUMBER_LEN + 1, "%d",\r\nec_read_u16(BAT_SERIAL_NUMBER_ADDR));\r\n}\r\nstatic void initialize_fan_control_data(struct compal_data *data)\r\n{\r\ndata->pwm_enable = 2;\r\ndata->curr_pwm = 255;\r\n}\r\nstatic int setup_rfkill(void)\r\n{\r\nint ret;\r\nwifi_rfkill = rfkill_alloc("compal-wifi", &compal_device->dev,\r\nRFKILL_TYPE_WLAN, &compal_rfkill_ops,\r\n(void *) WIRELESS_WLAN);\r\nif (!wifi_rfkill)\r\nreturn -ENOMEM;\r\nret = rfkill_register(wifi_rfkill);\r\nif (ret)\r\ngoto err_wifi;\r\nbt_rfkill = rfkill_alloc("compal-bluetooth", &compal_device->dev,\r\nRFKILL_TYPE_BLUETOOTH, &compal_rfkill_ops,\r\n(void *) WIRELESS_BT);\r\nif (!bt_rfkill) {\r\nret = -ENOMEM;\r\ngoto err_allocate_bt;\r\n}\r\nret = rfkill_register(bt_rfkill);\r\nif (ret)\r\ngoto err_register_bt;\r\nreturn 0;\r\nerr_register_bt:\r\nrfkill_destroy(bt_rfkill);\r\nerr_allocate_bt:\r\nrfkill_unregister(wifi_rfkill);\r\nerr_wifi:\r\nrfkill_destroy(wifi_rfkill);\r\nreturn ret;\r\n}\r\nstatic int __init compal_init(void)\r\n{\r\nint ret;\r\nif (acpi_disabled) {\r\npr_err("ACPI needs to be enabled for this driver to work!\n");\r\nreturn -ENODEV;\r\n}\r\nif (!force && !dmi_check_system(compal_dmi_table)) {\r\npr_err("Motherboard not recognized (You could try the module's force-parameter)\n");\r\nreturn -ENODEV;\r\n}\r\nif (!acpi_video_backlight_support()) {\r\nstruct backlight_properties props;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = BACKLIGHT_LEVEL_MAX;\r\ncompalbl_device = backlight_device_register(DRIVER_NAME,\r\nNULL, NULL,\r\n&compalbl_ops,\r\n&props);\r\nif (IS_ERR(compalbl_device))\r\nreturn PTR_ERR(compalbl_device);\r\n}\r\nret = platform_driver_register(&compal_driver);\r\nif (ret)\r\ngoto err_backlight;\r\ncompal_device = platform_device_alloc(DRIVER_NAME, -1);\r\nif (!compal_device) {\r\nret = -ENOMEM;\r\ngoto err_platform_driver;\r\n}\r\nret = platform_device_add(compal_device);\r\nif (ret)\r\ngoto err_platform_device;\r\nret = setup_rfkill();\r\nif (ret)\r\ngoto err_rfkill;\r\npr_info("Driver " DRIVER_VERSION " successfully loaded\n");\r\nreturn 0;\r\nerr_rfkill:\r\nplatform_device_del(compal_device);\r\nerr_platform_device:\r\nplatform_device_put(compal_device);\r\nerr_platform_driver:\r\nplatform_driver_unregister(&compal_driver);\r\nerr_backlight:\r\nbacklight_device_unregister(compalbl_device);\r\nreturn ret;\r\n}\r\nstatic int compal_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nstruct compal_data *data;\r\nstruct device *hwmon_dev;\r\nif (!extra_features)\r\nreturn 0;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct compal_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ninitialize_fan_control_data(data);\r\nerr = sysfs_create_group(&pdev->dev.kobj, &compal_platform_attr_group);\r\nif (err)\r\nreturn err;\r\nhwmon_dev = hwmon_device_register_with_groups(&pdev->dev,\r\nDRIVER_NAME, data,\r\ncompal_hwmon_groups);\r\nif (IS_ERR(hwmon_dev)) {\r\nerr = PTR_ERR(hwmon_dev);\r\ngoto remove;\r\n}\r\ninitialize_power_supply_data(data);\r\npower_supply_register(&compal_device->dev, &data->psy);\r\nplatform_set_drvdata(pdev, data);\r\nreturn 0;\r\nremove:\r\nsysfs_remove_group(&pdev->dev.kobj, &compal_platform_attr_group);\r\nreturn err;\r\n}\r\nstatic void __exit compal_cleanup(void)\r\n{\r\nplatform_device_unregister(compal_device);\r\nplatform_driver_unregister(&compal_driver);\r\nbacklight_device_unregister(compalbl_device);\r\nrfkill_unregister(wifi_rfkill);\r\nrfkill_unregister(bt_rfkill);\r\nrfkill_destroy(wifi_rfkill);\r\nrfkill_destroy(bt_rfkill);\r\npr_info("Driver unloaded\n");\r\n}\r\nstatic int compal_remove(struct platform_device *pdev)\r\n{\r\nstruct compal_data *data;\r\nif (!extra_features)\r\nreturn 0;\r\npr_info("Unloading: resetting fan control to motherboard\n");\r\npwm_disable_control();\r\ndata = platform_get_drvdata(pdev);\r\npower_supply_unregister(&data->psy);\r\nsysfs_remove_group(&pdev->dev.kobj, &compal_platform_attr_group);\r\nreturn 0;\r\n}
