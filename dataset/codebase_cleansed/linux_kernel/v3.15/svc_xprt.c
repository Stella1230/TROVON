int svc_reg_xprt_class(struct svc_xprt_class *xcl)\r\n{\r\nstruct svc_xprt_class *cl;\r\nint res = -EEXIST;\r\ndprintk("svc: Adding svc transport class '%s'\n", xcl->xcl_name);\r\nINIT_LIST_HEAD(&xcl->xcl_list);\r\nspin_lock(&svc_xprt_class_lock);\r\nlist_for_each_entry(cl, &svc_xprt_class_list, xcl_list) {\r\nif (strcmp(xcl->xcl_name, cl->xcl_name) == 0)\r\ngoto out;\r\n}\r\nlist_add_tail(&xcl->xcl_list, &svc_xprt_class_list);\r\nres = 0;\r\nout:\r\nspin_unlock(&svc_xprt_class_lock);\r\nreturn res;\r\n}\r\nvoid svc_unreg_xprt_class(struct svc_xprt_class *xcl)\r\n{\r\ndprintk("svc: Removing svc transport class '%s'\n", xcl->xcl_name);\r\nspin_lock(&svc_xprt_class_lock);\r\nlist_del_init(&xcl->xcl_list);\r\nspin_unlock(&svc_xprt_class_lock);\r\n}\r\nint svc_print_xprts(char *buf, int maxlen)\r\n{\r\nstruct svc_xprt_class *xcl;\r\nchar tmpstr[80];\r\nint len = 0;\r\nbuf[0] = '\0';\r\nspin_lock(&svc_xprt_class_lock);\r\nlist_for_each_entry(xcl, &svc_xprt_class_list, xcl_list) {\r\nint slen;\r\nsprintf(tmpstr, "%s %d\n", xcl->xcl_name, xcl->xcl_max_payload);\r\nslen = strlen(tmpstr);\r\nif (len + slen > maxlen)\r\nbreak;\r\nlen += slen;\r\nstrcat(buf, tmpstr);\r\n}\r\nspin_unlock(&svc_xprt_class_lock);\r\nreturn len;\r\n}\r\nstatic void svc_xprt_free(struct kref *kref)\r\n{\r\nstruct svc_xprt *xprt =\r\ncontainer_of(kref, struct svc_xprt, xpt_ref);\r\nstruct module *owner = xprt->xpt_class->xcl_owner;\r\nif (test_bit(XPT_CACHE_AUTH, &xprt->xpt_flags))\r\nsvcauth_unix_info_release(xprt);\r\nput_net(xprt->xpt_net);\r\nif (xprt->xpt_bc_xprt)\r\nxprt_put(xprt->xpt_bc_xprt);\r\nxprt->xpt_ops->xpo_free(xprt);\r\nmodule_put(owner);\r\n}\r\nvoid svc_xprt_put(struct svc_xprt *xprt)\r\n{\r\nkref_put(&xprt->xpt_ref, svc_xprt_free);\r\n}\r\nvoid svc_xprt_init(struct net *net, struct svc_xprt_class *xcl,\r\nstruct svc_xprt *xprt, struct svc_serv *serv)\r\n{\r\nmemset(xprt, 0, sizeof(*xprt));\r\nxprt->xpt_class = xcl;\r\nxprt->xpt_ops = xcl->xcl_ops;\r\nkref_init(&xprt->xpt_ref);\r\nxprt->xpt_server = serv;\r\nINIT_LIST_HEAD(&xprt->xpt_list);\r\nINIT_LIST_HEAD(&xprt->xpt_ready);\r\nINIT_LIST_HEAD(&xprt->xpt_deferred);\r\nINIT_LIST_HEAD(&xprt->xpt_users);\r\nmutex_init(&xprt->xpt_mutex);\r\nspin_lock_init(&xprt->xpt_lock);\r\nset_bit(XPT_BUSY, &xprt->xpt_flags);\r\nrpc_init_wait_queue(&xprt->xpt_bc_pending, "xpt_bc_pending");\r\nxprt->xpt_net = get_net(net);\r\n}\r\nstatic struct svc_xprt *__svc_xpo_create(struct svc_xprt_class *xcl,\r\nstruct svc_serv *serv,\r\nstruct net *net,\r\nconst int family,\r\nconst unsigned short port,\r\nint flags)\r\n{\r\nstruct sockaddr_in sin = {\r\n.sin_family = AF_INET,\r\n.sin_addr.s_addr = htonl(INADDR_ANY),\r\n.sin_port = htons(port),\r\n};\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstruct sockaddr_in6 sin6 = {\r\n.sin6_family = AF_INET6,\r\n.sin6_addr = IN6ADDR_ANY_INIT,\r\n.sin6_port = htons(port),\r\n};\r\n#endif\r\nstruct sockaddr *sap;\r\nsize_t len;\r\nswitch (family) {\r\ncase PF_INET:\r\nsap = (struct sockaddr *)&sin;\r\nlen = sizeof(sin);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase PF_INET6:\r\nsap = (struct sockaddr *)&sin6;\r\nlen = sizeof(sin6);\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn ERR_PTR(-EAFNOSUPPORT);\r\n}\r\nreturn xcl->xcl_ops->xpo_create(serv, net, sap, len, flags);\r\n}\r\nstatic void svc_xprt_received(struct svc_xprt *xprt)\r\n{\r\nWARN_ON_ONCE(!test_bit(XPT_BUSY, &xprt->xpt_flags));\r\nif (!test_bit(XPT_BUSY, &xprt->xpt_flags))\r\nreturn;\r\nsvc_xprt_get(xprt);\r\nclear_bit(XPT_BUSY, &xprt->xpt_flags);\r\nsvc_xprt_enqueue(xprt);\r\nsvc_xprt_put(xprt);\r\n}\r\nvoid svc_add_new_perm_xprt(struct svc_serv *serv, struct svc_xprt *new)\r\n{\r\nclear_bit(XPT_TEMP, &new->xpt_flags);\r\nspin_lock_bh(&serv->sv_lock);\r\nlist_add(&new->xpt_list, &serv->sv_permsocks);\r\nspin_unlock_bh(&serv->sv_lock);\r\nsvc_xprt_received(new);\r\n}\r\nint svc_create_xprt(struct svc_serv *serv, const char *xprt_name,\r\nstruct net *net, const int family,\r\nconst unsigned short port, int flags)\r\n{\r\nstruct svc_xprt_class *xcl;\r\ndprintk("svc: creating transport %s[%d]\n", xprt_name, port);\r\nspin_lock(&svc_xprt_class_lock);\r\nlist_for_each_entry(xcl, &svc_xprt_class_list, xcl_list) {\r\nstruct svc_xprt *newxprt;\r\nunsigned short newport;\r\nif (strcmp(xprt_name, xcl->xcl_name))\r\ncontinue;\r\nif (!try_module_get(xcl->xcl_owner))\r\ngoto err;\r\nspin_unlock(&svc_xprt_class_lock);\r\nnewxprt = __svc_xpo_create(xcl, serv, net, family, port, flags);\r\nif (IS_ERR(newxprt)) {\r\nmodule_put(xcl->xcl_owner);\r\nreturn PTR_ERR(newxprt);\r\n}\r\nsvc_add_new_perm_xprt(serv, newxprt);\r\nnewport = svc_xprt_local_port(newxprt);\r\nreturn newport;\r\n}\r\nerr:\r\nspin_unlock(&svc_xprt_class_lock);\r\ndprintk("svc: transport %s not found\n", xprt_name);\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nvoid svc_xprt_copy_addrs(struct svc_rqst *rqstp, struct svc_xprt *xprt)\r\n{\r\nmemcpy(&rqstp->rq_addr, &xprt->xpt_remote, xprt->xpt_remotelen);\r\nrqstp->rq_addrlen = xprt->xpt_remotelen;\r\nmemcpy(&rqstp->rq_daddr, &xprt->xpt_local, xprt->xpt_locallen);\r\nrqstp->rq_daddrlen = xprt->xpt_locallen;\r\n}\r\nchar *svc_print_addr(struct svc_rqst *rqstp, char *buf, size_t len)\r\n{\r\nreturn __svc_print_addr(svc_addr(rqstp), buf, len);\r\n}\r\nstatic void svc_thread_enqueue(struct svc_pool *pool, struct svc_rqst *rqstp)\r\n{\r\nlist_add(&rqstp->rq_list, &pool->sp_threads);\r\n}\r\nstatic void svc_thread_dequeue(struct svc_pool *pool, struct svc_rqst *rqstp)\r\n{\r\nlist_del(&rqstp->rq_list);\r\n}\r\nstatic bool svc_xprt_has_something_to_do(struct svc_xprt *xprt)\r\n{\r\nif (xprt->xpt_flags & ((1<<XPT_CONN)|(1<<XPT_CLOSE)))\r\nreturn true;\r\nif (xprt->xpt_flags & ((1<<XPT_DATA)|(1<<XPT_DEFERRED)))\r\nreturn xprt->xpt_ops->xpo_has_wspace(xprt);\r\nreturn false;\r\n}\r\nvoid svc_xprt_enqueue(struct svc_xprt *xprt)\r\n{\r\nstruct svc_pool *pool;\r\nstruct svc_rqst *rqstp;\r\nint cpu;\r\nif (!svc_xprt_has_something_to_do(xprt))\r\nreturn;\r\ncpu = get_cpu();\r\npool = svc_pool_for_cpu(xprt->xpt_server, cpu);\r\nput_cpu();\r\nspin_lock_bh(&pool->sp_lock);\r\nif (!list_empty(&pool->sp_threads) &&\r\n!list_empty(&pool->sp_sockets))\r\nprintk(KERN_ERR\r\n"svc_xprt_enqueue: "\r\n"threads and transports both waiting??\n");\r\npool->sp_stats.packets++;\r\nif (test_and_set_bit(XPT_BUSY, &xprt->xpt_flags)) {\r\ndprintk("svc: transport %p busy, not enqueued\n", xprt);\r\ngoto out_unlock;\r\n}\r\nif (!list_empty(&pool->sp_threads)) {\r\nrqstp = list_entry(pool->sp_threads.next,\r\nstruct svc_rqst,\r\nrq_list);\r\ndprintk("svc: transport %p served by daemon %p\n",\r\nxprt, rqstp);\r\nsvc_thread_dequeue(pool, rqstp);\r\nif (rqstp->rq_xprt)\r\nprintk(KERN_ERR\r\n"svc_xprt_enqueue: server %p, rq_xprt=%p!\n",\r\nrqstp, rqstp->rq_xprt);\r\nrqstp->rq_xprt = xprt;\r\nsvc_xprt_get(xprt);\r\npool->sp_stats.threads_woken++;\r\nwake_up(&rqstp->rq_wait);\r\n} else {\r\ndprintk("svc: transport %p put into queue\n", xprt);\r\nlist_add_tail(&xprt->xpt_ready, &pool->sp_sockets);\r\npool->sp_stats.sockets_queued++;\r\n}\r\nout_unlock:\r\nspin_unlock_bh(&pool->sp_lock);\r\n}\r\nstatic struct svc_xprt *svc_xprt_dequeue(struct svc_pool *pool)\r\n{\r\nstruct svc_xprt *xprt;\r\nif (list_empty(&pool->sp_sockets))\r\nreturn NULL;\r\nxprt = list_entry(pool->sp_sockets.next,\r\nstruct svc_xprt, xpt_ready);\r\nlist_del_init(&xprt->xpt_ready);\r\ndprintk("svc: transport %p dequeued, inuse=%d\n",\r\nxprt, atomic_read(&xprt->xpt_ref.refcount));\r\nreturn xprt;\r\n}\r\nvoid svc_reserve(struct svc_rqst *rqstp, int space)\r\n{\r\nspace += rqstp->rq_res.head[0].iov_len;\r\nif (space < rqstp->rq_reserved) {\r\nstruct svc_xprt *xprt = rqstp->rq_xprt;\r\natomic_sub((rqstp->rq_reserved - space), &xprt->xpt_reserved);\r\nrqstp->rq_reserved = space;\r\nsvc_xprt_enqueue(xprt);\r\n}\r\n}\r\nstatic void svc_xprt_release(struct svc_rqst *rqstp)\r\n{\r\nstruct svc_xprt *xprt = rqstp->rq_xprt;\r\nrqstp->rq_xprt->xpt_ops->xpo_release_rqst(rqstp);\r\nkfree(rqstp->rq_deferred);\r\nrqstp->rq_deferred = NULL;\r\nsvc_free_res_pages(rqstp);\r\nrqstp->rq_res.page_len = 0;\r\nrqstp->rq_res.page_base = 0;\r\nif ((rqstp->rq_res.len) > rqstp->rq_reserved)\r\nprintk(KERN_ERR "RPC request reserved %d but used %d\n",\r\nrqstp->rq_reserved,\r\nrqstp->rq_res.len);\r\nrqstp->rq_res.head[0].iov_len = 0;\r\nsvc_reserve(rqstp, 0);\r\nrqstp->rq_xprt = NULL;\r\nsvc_xprt_put(xprt);\r\n}\r\nvoid svc_wake_up(struct svc_serv *serv)\r\n{\r\nstruct svc_rqst *rqstp;\r\nunsigned int i;\r\nstruct svc_pool *pool;\r\nfor (i = 0; i < serv->sv_nrpools; i++) {\r\npool = &serv->sv_pools[i];\r\nspin_lock_bh(&pool->sp_lock);\r\nif (!list_empty(&pool->sp_threads)) {\r\nrqstp = list_entry(pool->sp_threads.next,\r\nstruct svc_rqst,\r\nrq_list);\r\ndprintk("svc: daemon %p woken up.\n", rqstp);\r\nwake_up(&rqstp->rq_wait);\r\n} else\r\npool->sp_task_pending = 1;\r\nspin_unlock_bh(&pool->sp_lock);\r\n}\r\n}\r\nint svc_port_is_privileged(struct sockaddr *sin)\r\n{\r\nswitch (sin->sa_family) {\r\ncase AF_INET:\r\nreturn ntohs(((struct sockaddr_in *)sin)->sin_port)\r\n< PROT_SOCK;\r\ncase AF_INET6:\r\nreturn ntohs(((struct sockaddr_in6 *)sin)->sin6_port)\r\n< PROT_SOCK;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void svc_check_conn_limits(struct svc_serv *serv)\r\n{\r\nunsigned int limit = serv->sv_maxconn ? serv->sv_maxconn :\r\n(serv->sv_nrthreads+3) * 20;\r\nif (serv->sv_tmpcnt > limit) {\r\nstruct svc_xprt *xprt = NULL;\r\nspin_lock_bh(&serv->sv_lock);\r\nif (!list_empty(&serv->sv_tempsocks)) {\r\nnet_notice_ratelimited("%s: too many open connections, consider increasing the %s\n",\r\nserv->sv_name, serv->sv_maxconn ?\r\n"max number of connections" :\r\n"number of threads");\r\nxprt = list_entry(serv->sv_tempsocks.prev,\r\nstruct svc_xprt,\r\nxpt_list);\r\nset_bit(XPT_CLOSE, &xprt->xpt_flags);\r\nsvc_xprt_get(xprt);\r\n}\r\nspin_unlock_bh(&serv->sv_lock);\r\nif (xprt) {\r\nsvc_xprt_enqueue(xprt);\r\nsvc_xprt_put(xprt);\r\n}\r\n}\r\n}\r\nstatic int svc_alloc_arg(struct svc_rqst *rqstp)\r\n{\r\nstruct svc_serv *serv = rqstp->rq_server;\r\nstruct xdr_buf *arg;\r\nint pages;\r\nint i;\r\npages = (serv->sv_max_mesg + PAGE_SIZE) / PAGE_SIZE;\r\nWARN_ON_ONCE(pages >= RPCSVC_MAXPAGES);\r\nif (pages >= RPCSVC_MAXPAGES)\r\npages = RPCSVC_MAXPAGES - 1;\r\nfor (i = 0; i < pages ; i++)\r\nwhile (rqstp->rq_pages[i] == NULL) {\r\nstruct page *p = alloc_page(GFP_KERNEL);\r\nif (!p) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (signalled() || kthread_should_stop()) {\r\nset_current_state(TASK_RUNNING);\r\nreturn -EINTR;\r\n}\r\nschedule_timeout(msecs_to_jiffies(500));\r\n}\r\nrqstp->rq_pages[i] = p;\r\n}\r\nrqstp->rq_pages[i++] = NULL;\r\narg = &rqstp->rq_arg;\r\narg->head[0].iov_base = page_address(rqstp->rq_pages[0]);\r\narg->head[0].iov_len = PAGE_SIZE;\r\narg->pages = rqstp->rq_pages + 1;\r\narg->page_base = 0;\r\narg->page_len = (pages-2)*PAGE_SIZE;\r\narg->len = (pages-1)*PAGE_SIZE;\r\narg->tail[0].iov_len = 0;\r\nreturn 0;\r\n}\r\nstatic struct svc_xprt *svc_get_next_xprt(struct svc_rqst *rqstp, long timeout)\r\n{\r\nstruct svc_xprt *xprt;\r\nstruct svc_pool *pool = rqstp->rq_pool;\r\nDECLARE_WAITQUEUE(wait, current);\r\nlong time_left;\r\nrqstp->rq_chandle.thread_wait = 5*HZ;\r\nspin_lock_bh(&pool->sp_lock);\r\nxprt = svc_xprt_dequeue(pool);\r\nif (xprt) {\r\nrqstp->rq_xprt = xprt;\r\nsvc_xprt_get(xprt);\r\nrqstp->rq_chandle.thread_wait = 1*HZ;\r\npool->sp_task_pending = 0;\r\n} else {\r\nif (pool->sp_task_pending) {\r\npool->sp_task_pending = 0;\r\nspin_unlock_bh(&pool->sp_lock);\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\nsvc_thread_enqueue(pool, rqstp);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (kthread_should_stop()) {\r\nset_current_state(TASK_RUNNING);\r\nspin_unlock_bh(&pool->sp_lock);\r\nreturn ERR_PTR(-EINTR);\r\n}\r\nadd_wait_queue(&rqstp->rq_wait, &wait);\r\nspin_unlock_bh(&pool->sp_lock);\r\ntime_left = schedule_timeout(timeout);\r\ntry_to_freeze();\r\nspin_lock_bh(&pool->sp_lock);\r\nremove_wait_queue(&rqstp->rq_wait, &wait);\r\nif (!time_left)\r\npool->sp_stats.threads_timedout++;\r\nxprt = rqstp->rq_xprt;\r\nif (!xprt) {\r\nsvc_thread_dequeue(pool, rqstp);\r\nspin_unlock_bh(&pool->sp_lock);\r\ndprintk("svc: server %p, no data yet\n", rqstp);\r\nif (signalled() || kthread_should_stop())\r\nreturn ERR_PTR(-EINTR);\r\nelse\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\n}\r\nspin_unlock_bh(&pool->sp_lock);\r\nreturn xprt;\r\n}\r\nstatic void svc_add_new_temp_xprt(struct svc_serv *serv, struct svc_xprt *newxpt)\r\n{\r\nspin_lock_bh(&serv->sv_lock);\r\nset_bit(XPT_TEMP, &newxpt->xpt_flags);\r\nlist_add(&newxpt->xpt_list, &serv->sv_tempsocks);\r\nserv->sv_tmpcnt++;\r\nif (serv->sv_temptimer.function == NULL) {\r\nsetup_timer(&serv->sv_temptimer, svc_age_temp_xprts,\r\n(unsigned long)serv);\r\nmod_timer(&serv->sv_temptimer,\r\njiffies + svc_conn_age_period * HZ);\r\n}\r\nspin_unlock_bh(&serv->sv_lock);\r\nsvc_xprt_received(newxpt);\r\n}\r\nstatic int svc_handle_xprt(struct svc_rqst *rqstp, struct svc_xprt *xprt)\r\n{\r\nstruct svc_serv *serv = rqstp->rq_server;\r\nint len = 0;\r\nif (test_bit(XPT_CLOSE, &xprt->xpt_flags)) {\r\ndprintk("svc_recv: found XPT_CLOSE\n");\r\nsvc_delete_xprt(xprt);\r\nreturn 0;\r\n}\r\nif (test_bit(XPT_LISTENER, &xprt->xpt_flags)) {\r\nstruct svc_xprt *newxpt;\r\n__module_get(xprt->xpt_class->xcl_owner);\r\nsvc_check_conn_limits(xprt->xpt_server);\r\nnewxpt = xprt->xpt_ops->xpo_accept(xprt);\r\nif (newxpt)\r\nsvc_add_new_temp_xprt(serv, newxpt);\r\n} else if (xprt->xpt_ops->xpo_has_wspace(xprt)) {\r\ndprintk("svc: server %p, pool %u, transport %p, inuse=%d\n",\r\nrqstp, rqstp->rq_pool->sp_id, xprt,\r\natomic_read(&xprt->xpt_ref.refcount));\r\nrqstp->rq_deferred = svc_deferred_dequeue(xprt);\r\nif (rqstp->rq_deferred)\r\nlen = svc_deferred_recv(rqstp);\r\nelse\r\nlen = xprt->xpt_ops->xpo_recvfrom(rqstp);\r\ndprintk("svc: got len=%d\n", len);\r\nrqstp->rq_reserved = serv->sv_max_mesg;\r\natomic_add(rqstp->rq_reserved, &xprt->xpt_reserved);\r\n}\r\nsvc_xprt_received(xprt);\r\nreturn len;\r\n}\r\nint svc_recv(struct svc_rqst *rqstp, long timeout)\r\n{\r\nstruct svc_xprt *xprt = NULL;\r\nstruct svc_serv *serv = rqstp->rq_server;\r\nint len, err;\r\ndprintk("svc: server %p waiting for data (to = %ld)\n",\r\nrqstp, timeout);\r\nif (rqstp->rq_xprt)\r\nprintk(KERN_ERR\r\n"svc_recv: service %p, transport not NULL!\n",\r\nrqstp);\r\nif (waitqueue_active(&rqstp->rq_wait))\r\nprintk(KERN_ERR\r\n"svc_recv: service %p, wait queue active!\n",\r\nrqstp);\r\nerr = svc_alloc_arg(rqstp);\r\nif (err)\r\nreturn err;\r\ntry_to_freeze();\r\ncond_resched();\r\nif (signalled() || kthread_should_stop())\r\nreturn -EINTR;\r\nxprt = svc_get_next_xprt(rqstp, timeout);\r\nif (IS_ERR(xprt))\r\nreturn PTR_ERR(xprt);\r\nlen = svc_handle_xprt(rqstp, xprt);\r\nif (len <= 0)\r\ngoto out;\r\nclear_bit(XPT_OLD, &xprt->xpt_flags);\r\nrqstp->rq_secure = svc_port_is_privileged(svc_addr(rqstp));\r\nrqstp->rq_chandle.defer = svc_defer;\r\nif (serv->sv_stats)\r\nserv->sv_stats->netcnt++;\r\nreturn len;\r\nout:\r\nrqstp->rq_res.len = 0;\r\nsvc_xprt_release(rqstp);\r\nreturn -EAGAIN;\r\n}\r\nvoid svc_drop(struct svc_rqst *rqstp)\r\n{\r\ndprintk("svc: xprt %p dropped request\n", rqstp->rq_xprt);\r\nsvc_xprt_release(rqstp);\r\n}\r\nint svc_send(struct svc_rqst *rqstp)\r\n{\r\nstruct svc_xprt *xprt;\r\nint len;\r\nstruct xdr_buf *xb;\r\nxprt = rqstp->rq_xprt;\r\nif (!xprt)\r\nreturn -EFAULT;\r\nrqstp->rq_xprt->xpt_ops->xpo_release_rqst(rqstp);\r\nxb = &rqstp->rq_res;\r\nxb->len = xb->head[0].iov_len +\r\nxb->page_len +\r\nxb->tail[0].iov_len;\r\nmutex_lock(&xprt->xpt_mutex);\r\nif (test_bit(XPT_DEAD, &xprt->xpt_flags)\r\n|| test_bit(XPT_CLOSE, &xprt->xpt_flags))\r\nlen = -ENOTCONN;\r\nelse\r\nlen = xprt->xpt_ops->xpo_sendto(rqstp);\r\nmutex_unlock(&xprt->xpt_mutex);\r\nrpc_wake_up(&xprt->xpt_bc_pending);\r\nsvc_xprt_release(rqstp);\r\nif (len == -ECONNREFUSED || len == -ENOTCONN || len == -EAGAIN)\r\nreturn 0;\r\nreturn len;\r\n}\r\nstatic void svc_age_temp_xprts(unsigned long closure)\r\n{\r\nstruct svc_serv *serv = (struct svc_serv *)closure;\r\nstruct svc_xprt *xprt;\r\nstruct list_head *le, *next;\r\ndprintk("svc_age_temp_xprts\n");\r\nif (!spin_trylock_bh(&serv->sv_lock)) {\r\ndprintk("svc_age_temp_xprts: busy\n");\r\nmod_timer(&serv->sv_temptimer, jiffies + HZ);\r\nreturn;\r\n}\r\nlist_for_each_safe(le, next, &serv->sv_tempsocks) {\r\nxprt = list_entry(le, struct svc_xprt, xpt_list);\r\nif (!test_and_set_bit(XPT_OLD, &xprt->xpt_flags))\r\ncontinue;\r\nif (atomic_read(&xprt->xpt_ref.refcount) > 1 ||\r\ntest_bit(XPT_BUSY, &xprt->xpt_flags))\r\ncontinue;\r\nlist_del_init(le);\r\nset_bit(XPT_CLOSE, &xprt->xpt_flags);\r\nset_bit(XPT_DETACHED, &xprt->xpt_flags);\r\ndprintk("queuing xprt %p for closing\n", xprt);\r\nsvc_xprt_enqueue(xprt);\r\n}\r\nspin_unlock_bh(&serv->sv_lock);\r\nmod_timer(&serv->sv_temptimer, jiffies + svc_conn_age_period * HZ);\r\n}\r\nstatic void call_xpt_users(struct svc_xprt *xprt)\r\n{\r\nstruct svc_xpt_user *u;\r\nspin_lock(&xprt->xpt_lock);\r\nwhile (!list_empty(&xprt->xpt_users)) {\r\nu = list_first_entry(&xprt->xpt_users, struct svc_xpt_user, list);\r\nlist_del(&u->list);\r\nu->callback(u);\r\n}\r\nspin_unlock(&xprt->xpt_lock);\r\n}\r\nstatic void svc_delete_xprt(struct svc_xprt *xprt)\r\n{\r\nstruct svc_serv *serv = xprt->xpt_server;\r\nstruct svc_deferred_req *dr;\r\nif (test_and_set_bit(XPT_DEAD, &xprt->xpt_flags))\r\nBUG();\r\ndprintk("svc: svc_delete_xprt(%p)\n", xprt);\r\nxprt->xpt_ops->xpo_detach(xprt);\r\nspin_lock_bh(&serv->sv_lock);\r\nif (!test_and_set_bit(XPT_DETACHED, &xprt->xpt_flags))\r\nlist_del_init(&xprt->xpt_list);\r\nWARN_ON_ONCE(!list_empty(&xprt->xpt_ready));\r\nif (test_bit(XPT_TEMP, &xprt->xpt_flags))\r\nserv->sv_tmpcnt--;\r\nspin_unlock_bh(&serv->sv_lock);\r\nwhile ((dr = svc_deferred_dequeue(xprt)) != NULL)\r\nkfree(dr);\r\ncall_xpt_users(xprt);\r\nsvc_xprt_put(xprt);\r\n}\r\nvoid svc_close_xprt(struct svc_xprt *xprt)\r\n{\r\nset_bit(XPT_CLOSE, &xprt->xpt_flags);\r\nif (test_and_set_bit(XPT_BUSY, &xprt->xpt_flags))\r\nreturn;\r\nsvc_delete_xprt(xprt);\r\n}\r\nstatic int svc_close_list(struct svc_serv *serv, struct list_head *xprt_list, struct net *net)\r\n{\r\nstruct svc_xprt *xprt;\r\nint ret = 0;\r\nspin_lock(&serv->sv_lock);\r\nlist_for_each_entry(xprt, xprt_list, xpt_list) {\r\nif (xprt->xpt_net != net)\r\ncontinue;\r\nret++;\r\nset_bit(XPT_CLOSE, &xprt->xpt_flags);\r\nsvc_xprt_enqueue(xprt);\r\n}\r\nspin_unlock(&serv->sv_lock);\r\nreturn ret;\r\n}\r\nstatic struct svc_xprt *svc_dequeue_net(struct svc_serv *serv, struct net *net)\r\n{\r\nstruct svc_pool *pool;\r\nstruct svc_xprt *xprt;\r\nstruct svc_xprt *tmp;\r\nint i;\r\nfor (i = 0; i < serv->sv_nrpools; i++) {\r\npool = &serv->sv_pools[i];\r\nspin_lock_bh(&pool->sp_lock);\r\nlist_for_each_entry_safe(xprt, tmp, &pool->sp_sockets, xpt_ready) {\r\nif (xprt->xpt_net != net)\r\ncontinue;\r\nlist_del_init(&xprt->xpt_ready);\r\nspin_unlock_bh(&pool->sp_lock);\r\nreturn xprt;\r\n}\r\nspin_unlock_bh(&pool->sp_lock);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void svc_clean_up_xprts(struct svc_serv *serv, struct net *net)\r\n{\r\nstruct svc_xprt *xprt;\r\nwhile ((xprt = svc_dequeue_net(serv, net))) {\r\nset_bit(XPT_CLOSE, &xprt->xpt_flags);\r\nsvc_delete_xprt(xprt);\r\n}\r\n}\r\nvoid svc_close_net(struct svc_serv *serv, struct net *net)\r\n{\r\nint delay = 0;\r\nwhile (svc_close_list(serv, &serv->sv_permsocks, net) +\r\nsvc_close_list(serv, &serv->sv_tempsocks, net)) {\r\nsvc_clean_up_xprts(serv, net);\r\nmsleep(delay++);\r\n}\r\n}\r\nstatic void svc_revisit(struct cache_deferred_req *dreq, int too_many)\r\n{\r\nstruct svc_deferred_req *dr =\r\ncontainer_of(dreq, struct svc_deferred_req, handle);\r\nstruct svc_xprt *xprt = dr->xprt;\r\nspin_lock(&xprt->xpt_lock);\r\nset_bit(XPT_DEFERRED, &xprt->xpt_flags);\r\nif (too_many || test_bit(XPT_DEAD, &xprt->xpt_flags)) {\r\nspin_unlock(&xprt->xpt_lock);\r\ndprintk("revisit canceled\n");\r\nsvc_xprt_put(xprt);\r\nkfree(dr);\r\nreturn;\r\n}\r\ndprintk("revisit queued\n");\r\ndr->xprt = NULL;\r\nlist_add(&dr->handle.recent, &xprt->xpt_deferred);\r\nspin_unlock(&xprt->xpt_lock);\r\nsvc_xprt_enqueue(xprt);\r\nsvc_xprt_put(xprt);\r\n}\r\nstatic struct cache_deferred_req *svc_defer(struct cache_req *req)\r\n{\r\nstruct svc_rqst *rqstp = container_of(req, struct svc_rqst, rq_chandle);\r\nstruct svc_deferred_req *dr;\r\nif (rqstp->rq_arg.page_len || !rqstp->rq_usedeferral)\r\nreturn NULL;\r\nif (rqstp->rq_deferred) {\r\ndr = rqstp->rq_deferred;\r\nrqstp->rq_deferred = NULL;\r\n} else {\r\nsize_t skip;\r\nsize_t size;\r\nsize = sizeof(struct svc_deferred_req) + rqstp->rq_arg.len;\r\ndr = kmalloc(size, GFP_KERNEL);\r\nif (dr == NULL)\r\nreturn NULL;\r\ndr->handle.owner = rqstp->rq_server;\r\ndr->prot = rqstp->rq_prot;\r\nmemcpy(&dr->addr, &rqstp->rq_addr, rqstp->rq_addrlen);\r\ndr->addrlen = rqstp->rq_addrlen;\r\ndr->daddr = rqstp->rq_daddr;\r\ndr->argslen = rqstp->rq_arg.len >> 2;\r\ndr->xprt_hlen = rqstp->rq_xprt_hlen;\r\nskip = rqstp->rq_arg.len - rqstp->rq_arg.head[0].iov_len;\r\nmemcpy(dr->args, rqstp->rq_arg.head[0].iov_base - skip,\r\ndr->argslen << 2);\r\n}\r\nsvc_xprt_get(rqstp->rq_xprt);\r\ndr->xprt = rqstp->rq_xprt;\r\nrqstp->rq_dropme = true;\r\ndr->handle.revisit = svc_revisit;\r\nreturn &dr->handle;\r\n}\r\nstatic int svc_deferred_recv(struct svc_rqst *rqstp)\r\n{\r\nstruct svc_deferred_req *dr = rqstp->rq_deferred;\r\nrqstp->rq_arg.head[0].iov_base = dr->args + (dr->xprt_hlen>>2);\r\nrqstp->rq_arg.head[0].iov_len = (dr->argslen<<2) - dr->xprt_hlen;\r\nrqstp->rq_arg.page_len = 0;\r\nrqstp->rq_arg.len = dr->argslen<<2;\r\nrqstp->rq_prot = dr->prot;\r\nmemcpy(&rqstp->rq_addr, &dr->addr, dr->addrlen);\r\nrqstp->rq_addrlen = dr->addrlen;\r\nrqstp->rq_xprt_hlen = dr->xprt_hlen;\r\nrqstp->rq_daddr = dr->daddr;\r\nrqstp->rq_respages = rqstp->rq_pages;\r\nreturn (dr->argslen<<2) - dr->xprt_hlen;\r\n}\r\nstatic struct svc_deferred_req *svc_deferred_dequeue(struct svc_xprt *xprt)\r\n{\r\nstruct svc_deferred_req *dr = NULL;\r\nif (!test_bit(XPT_DEFERRED, &xprt->xpt_flags))\r\nreturn NULL;\r\nspin_lock(&xprt->xpt_lock);\r\nif (!list_empty(&xprt->xpt_deferred)) {\r\ndr = list_entry(xprt->xpt_deferred.next,\r\nstruct svc_deferred_req,\r\nhandle.recent);\r\nlist_del_init(&dr->handle.recent);\r\n} else\r\nclear_bit(XPT_DEFERRED, &xprt->xpt_flags);\r\nspin_unlock(&xprt->xpt_lock);\r\nreturn dr;\r\n}\r\nstruct svc_xprt *svc_find_xprt(struct svc_serv *serv, const char *xcl_name,\r\nstruct net *net, const sa_family_t af,\r\nconst unsigned short port)\r\n{\r\nstruct svc_xprt *xprt;\r\nstruct svc_xprt *found = NULL;\r\nif (serv == NULL || xcl_name == NULL)\r\nreturn found;\r\nspin_lock_bh(&serv->sv_lock);\r\nlist_for_each_entry(xprt, &serv->sv_permsocks, xpt_list) {\r\nif (xprt->xpt_net != net)\r\ncontinue;\r\nif (strcmp(xprt->xpt_class->xcl_name, xcl_name))\r\ncontinue;\r\nif (af != AF_UNSPEC && af != xprt->xpt_local.ss_family)\r\ncontinue;\r\nif (port != 0 && port != svc_xprt_local_port(xprt))\r\ncontinue;\r\nfound = xprt;\r\nsvc_xprt_get(xprt);\r\nbreak;\r\n}\r\nspin_unlock_bh(&serv->sv_lock);\r\nreturn found;\r\n}\r\nstatic int svc_one_xprt_name(const struct svc_xprt *xprt,\r\nchar *pos, int remaining)\r\n{\r\nint len;\r\nlen = snprintf(pos, remaining, "%s %u\n",\r\nxprt->xpt_class->xcl_name,\r\nsvc_xprt_local_port(xprt));\r\nif (len >= remaining)\r\nreturn -ENAMETOOLONG;\r\nreturn len;\r\n}\r\nint svc_xprt_names(struct svc_serv *serv, char *buf, const int buflen)\r\n{\r\nstruct svc_xprt *xprt;\r\nint len, totlen;\r\nchar *pos;\r\nif (!serv)\r\nreturn 0;\r\nspin_lock_bh(&serv->sv_lock);\r\npos = buf;\r\ntotlen = 0;\r\nlist_for_each_entry(xprt, &serv->sv_permsocks, xpt_list) {\r\nlen = svc_one_xprt_name(xprt, pos, buflen - totlen);\r\nif (len < 0) {\r\n*buf = '\0';\r\ntotlen = len;\r\n}\r\nif (len <= 0)\r\nbreak;\r\npos += len;\r\ntotlen += len;\r\n}\r\nspin_unlock_bh(&serv->sv_lock);\r\nreturn totlen;\r\n}\r\nstatic void *svc_pool_stats_start(struct seq_file *m, loff_t *pos)\r\n{\r\nunsigned int pidx = (unsigned int)*pos;\r\nstruct svc_serv *serv = m->private;\r\ndprintk("svc_pool_stats_start, *pidx=%u\n", pidx);\r\nif (!pidx)\r\nreturn SEQ_START_TOKEN;\r\nreturn (pidx > serv->sv_nrpools ? NULL : &serv->sv_pools[pidx-1]);\r\n}\r\nstatic void *svc_pool_stats_next(struct seq_file *m, void *p, loff_t *pos)\r\n{\r\nstruct svc_pool *pool = p;\r\nstruct svc_serv *serv = m->private;\r\ndprintk("svc_pool_stats_next, *pos=%llu\n", *pos);\r\nif (p == SEQ_START_TOKEN) {\r\npool = &serv->sv_pools[0];\r\n} else {\r\nunsigned int pidx = (pool - &serv->sv_pools[0]);\r\nif (pidx < serv->sv_nrpools-1)\r\npool = &serv->sv_pools[pidx+1];\r\nelse\r\npool = NULL;\r\n}\r\n++*pos;\r\nreturn pool;\r\n}\r\nstatic void svc_pool_stats_stop(struct seq_file *m, void *p)\r\n{\r\n}\r\nstatic int svc_pool_stats_show(struct seq_file *m, void *p)\r\n{\r\nstruct svc_pool *pool = p;\r\nif (p == SEQ_START_TOKEN) {\r\nseq_puts(m, "# pool packets-arrived sockets-enqueued threads-woken threads-timedout\n");\r\nreturn 0;\r\n}\r\nseq_printf(m, "%u %lu %lu %lu %lu\n",\r\npool->sp_id,\r\npool->sp_stats.packets,\r\npool->sp_stats.sockets_queued,\r\npool->sp_stats.threads_woken,\r\npool->sp_stats.threads_timedout);\r\nreturn 0;\r\n}\r\nint svc_pool_stats_open(struct svc_serv *serv, struct file *file)\r\n{\r\nint err;\r\nerr = seq_open(file, &svc_pool_stats_seq_ops);\r\nif (!err)\r\n((struct seq_file *) file->private_data)->private = serv;\r\nreturn err;\r\n}
