static int\r\nuec_get_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nstruct phy_device *phydev = ugeth->phydev;\r\nstruct ucc_geth_info *ug_info = ugeth->ug_info;\r\nif (!phydev)\r\nreturn -ENODEV;\r\necmd->maxtxpkt = 1;\r\necmd->maxrxpkt = ug_info->interruptcoalescingmaxvalue[0];\r\nreturn phy_ethtool_gset(phydev, ecmd);\r\n}\r\nstatic int\r\nuec_set_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nstruct phy_device *phydev = ugeth->phydev;\r\nif (!phydev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_sset(phydev, ecmd);\r\n}\r\nstatic void\r\nuec_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\npause->autoneg = ugeth->phydev->autoneg;\r\nif (ugeth->ug_info->receiveFlowControl)\r\npause->rx_pause = 1;\r\nif (ugeth->ug_info->transmitFlowControl)\r\npause->tx_pause = 1;\r\n}\r\nstatic int\r\nuec_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nint ret = 0;\r\nugeth->ug_info->receiveFlowControl = pause->rx_pause;\r\nugeth->ug_info->transmitFlowControl = pause->tx_pause;\r\nif (ugeth->phydev->autoneg) {\r\nif (netif_running(netdev)) {\r\nnetdev_info(netdev, "Please re-open the interface\n");\r\n}\r\n} else {\r\nstruct ucc_geth_info *ug_info = ugeth->ug_info;\r\nret = init_flow_control_params(ug_info->aufc,\r\nug_info->receiveFlowControl,\r\nug_info->transmitFlowControl,\r\nug_info->pausePeriod,\r\nug_info->extensionField,\r\n&ugeth->uccf->uf_regs->upsmr,\r\n&ugeth->ug_regs->uempr,\r\n&ugeth->ug_regs->maccfg1);\r\n}\r\nreturn ret;\r\n}\r\nstatic uint32_t\r\nuec_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nreturn ugeth->msg_enable;\r\n}\r\nstatic void\r\nuec_set_msglevel(struct net_device *netdev, uint32_t data)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nugeth->msg_enable = data;\r\n}\r\nstatic int\r\nuec_get_regs_len(struct net_device *netdev)\r\n{\r\nreturn sizeof(struct ucc_geth);\r\n}\r\nstatic void\r\nuec_get_regs(struct net_device *netdev,\r\nstruct ethtool_regs *regs, void *p)\r\n{\r\nint i;\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nu32 __iomem *ug_regs = (u32 __iomem *)ugeth->ug_regs;\r\nu32 *buff = p;\r\nfor (i = 0; i < sizeof(struct ucc_geth) / sizeof(u32); i++)\r\nbuff[i] = in_be32(&ug_regs[i]);\r\n}\r\nstatic void\r\nuec_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nstruct ucc_geth_info *ug_info = ugeth->ug_info;\r\nint queue = 0;\r\nring->rx_max_pending = UCC_GETH_BD_RING_SIZE_MAX;\r\nring->rx_mini_max_pending = UCC_GETH_BD_RING_SIZE_MAX;\r\nring->rx_jumbo_max_pending = UCC_GETH_BD_RING_SIZE_MAX;\r\nring->tx_max_pending = UCC_GETH_BD_RING_SIZE_MAX;\r\nring->rx_pending = ug_info->bdRingLenRx[queue];\r\nring->rx_mini_pending = ug_info->bdRingLenRx[queue];\r\nring->rx_jumbo_pending = ug_info->bdRingLenRx[queue];\r\nring->tx_pending = ug_info->bdRingLenTx[queue];\r\n}\r\nstatic int\r\nuec_set_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nstruct ucc_geth_info *ug_info = ugeth->ug_info;\r\nint queue = 0, ret = 0;\r\nif (ring->rx_pending < UCC_GETH_RX_BD_RING_SIZE_MIN) {\r\nnetdev_info(netdev, "RxBD ring size must be no smaller than %d\n",\r\nUCC_GETH_RX_BD_RING_SIZE_MIN);\r\nreturn -EINVAL;\r\n}\r\nif (ring->rx_pending % UCC_GETH_RX_BD_RING_SIZE_ALIGNMENT) {\r\nnetdev_info(netdev, "RxBD ring size must be multiple of %d\n",\r\nUCC_GETH_RX_BD_RING_SIZE_ALIGNMENT);\r\nreturn -EINVAL;\r\n}\r\nif (ring->tx_pending < UCC_GETH_TX_BD_RING_SIZE_MIN) {\r\nnetdev_info(netdev, "TxBD ring size must be no smaller than %d\n",\r\nUCC_GETH_TX_BD_RING_SIZE_MIN);\r\nreturn -EINVAL;\r\n}\r\nug_info->bdRingLenRx[queue] = ring->rx_pending;\r\nug_info->bdRingLenTx[queue] = ring->tx_pending;\r\nif (netif_running(netdev)) {\r\nnetdev_info(netdev, "Please re-open the interface\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int uec_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nu32 stats_mode = ugeth->ug_info->statisticsMode;\r\nint len = 0;\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_HARDWARE)\r\nlen += UEC_HW_STATS_LEN;\r\nif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX)\r\nlen += UEC_TX_FW_STATS_LEN;\r\nif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX)\r\nlen += UEC_RX_FW_STATS_LEN;\r\nreturn len;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void uec_get_strings(struct net_device *netdev, u32 stringset, u8 *buf)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nu32 stats_mode = ugeth->ug_info->statisticsMode;\r\nif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_HARDWARE) {\r\nmemcpy(buf, hw_stat_gstrings, UEC_HW_STATS_LEN *\r\nETH_GSTRING_LEN);\r\nbuf += UEC_HW_STATS_LEN * ETH_GSTRING_LEN;\r\n}\r\nif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX) {\r\nmemcpy(buf, tx_fw_stat_gstrings, UEC_TX_FW_STATS_LEN *\r\nETH_GSTRING_LEN);\r\nbuf += UEC_TX_FW_STATS_LEN * ETH_GSTRING_LEN;\r\n}\r\nif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX)\r\nmemcpy(buf, rx_fw_stat_gstrings, UEC_RX_FW_STATS_LEN *\r\nETH_GSTRING_LEN);\r\n}\r\nstatic void uec_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, uint64_t *data)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nu32 stats_mode = ugeth->ug_info->statisticsMode;\r\nu32 __iomem *base;\r\nint i, j = 0;\r\nif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_HARDWARE) {\r\nif (ugeth->ug_regs)\r\nbase = (u32 __iomem *)&ugeth->ug_regs->tx64;\r\nelse\r\nbase = NULL;\r\nfor (i = 0; i < UEC_HW_STATS_LEN; i++)\r\ndata[j++] = base ? in_be32(&base[i]) : 0;\r\n}\r\nif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX) {\r\nbase = (u32 __iomem *)ugeth->p_tx_fw_statistics_pram;\r\nfor (i = 0; i < UEC_TX_FW_STATS_LEN; i++)\r\ndata[j++] = base ? in_be32(&base[i]) : 0;\r\n}\r\nif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX) {\r\nbase = (u32 __iomem *)ugeth->p_rx_fw_statistics_pram;\r\nfor (i = 0; i < UEC_RX_FW_STATS_LEN; i++)\r\ndata[j++] = base ? in_be32(&base[i]) : 0;\r\n}\r\n}\r\nstatic int uec_nway_reset(struct net_device *netdev)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nreturn phy_start_aneg(ugeth->phydev);\r\n}\r\nstatic void\r\nuec_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstrlcpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, DRV_VERSION, sizeof(drvinfo->version));\r\nstrlcpy(drvinfo->fw_version, "N/A", sizeof(drvinfo->fw_version));\r\nstrlcpy(drvinfo->bus_info, "QUICC ENGINE", sizeof(drvinfo->bus_info));\r\ndrvinfo->eedump_len = 0;\r\ndrvinfo->regdump_len = uec_get_regs_len(netdev);\r\n}\r\nstatic void uec_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nstruct phy_device *phydev = ugeth->phydev;\r\nif (phydev && phydev->irq)\r\nwol->supported |= WAKE_PHY;\r\nif (qe_alive_during_sleep())\r\nwol->supported |= WAKE_MAGIC;\r\nwol->wolopts = ugeth->wol_en;\r\n}\r\nstatic int uec_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct ucc_geth_private *ugeth = netdev_priv(netdev);\r\nstruct phy_device *phydev = ugeth->phydev;\r\nif (wol->wolopts & ~(WAKE_PHY | WAKE_MAGIC))\r\nreturn -EINVAL;\r\nelse if (wol->wolopts & WAKE_PHY && (!phydev || !phydev->irq))\r\nreturn -EINVAL;\r\nelse if (wol->wolopts & WAKE_MAGIC && !qe_alive_during_sleep())\r\nreturn -EINVAL;\r\nugeth->wol_en = wol->wolopts;\r\ndevice_set_wakeup_enable(&netdev->dev, ugeth->wol_en);\r\nreturn 0;\r\n}\r\nvoid uec_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nSET_ETHTOOL_OPS(netdev, &uec_ethtool_ops);\r\n}
