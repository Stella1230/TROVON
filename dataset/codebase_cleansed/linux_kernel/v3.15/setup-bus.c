static void free_list(struct list_head *head)\r\n{\r\nstruct pci_dev_resource *dev_res, *tmp;\r\nlist_for_each_entry_safe(dev_res, tmp, head, list) {\r\nlist_del(&dev_res->list);\r\nkfree(dev_res);\r\n}\r\n}\r\nstatic int add_to_list(struct list_head *head,\r\nstruct pci_dev *dev, struct resource *res,\r\nresource_size_t add_size, resource_size_t min_align)\r\n{\r\nstruct pci_dev_resource *tmp;\r\ntmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\r\nif (!tmp) {\r\npr_warning("add_to_list: kmalloc() failed!\n");\r\nreturn -ENOMEM;\r\n}\r\ntmp->res = res;\r\ntmp->dev = dev;\r\ntmp->start = res->start;\r\ntmp->end = res->end;\r\ntmp->flags = res->flags;\r\ntmp->add_size = add_size;\r\ntmp->min_align = min_align;\r\nlist_add(&tmp->list, head);\r\nreturn 0;\r\n}\r\nstatic void remove_from_list(struct list_head *head,\r\nstruct resource *res)\r\n{\r\nstruct pci_dev_resource *dev_res, *tmp;\r\nlist_for_each_entry_safe(dev_res, tmp, head, list) {\r\nif (dev_res->res == res) {\r\nlist_del(&dev_res->list);\r\nkfree(dev_res);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic resource_size_t get_res_add_size(struct list_head *head,\r\nstruct resource *res)\r\n{\r\nstruct pci_dev_resource *dev_res;\r\nlist_for_each_entry(dev_res, head, list) {\r\nif (dev_res->res == res) {\r\nint idx = res - &dev_res->dev->resource[0];\r\ndev_printk(KERN_DEBUG, &dev_res->dev->dev,\r\n"res[%d]=%pR get_res_add_size add_size %llx\n",\r\nidx, dev_res->res,\r\n(unsigned long long)dev_res->add_size);\r\nreturn dev_res->add_size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pdev_sort_resources(struct pci_dev *dev, struct list_head *head)\r\n{\r\nint i;\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\nstruct resource *r;\r\nstruct pci_dev_resource *dev_res, *tmp;\r\nresource_size_t r_align;\r\nstruct list_head *n;\r\nr = &dev->resource[i];\r\nif (r->flags & IORESOURCE_PCI_FIXED)\r\ncontinue;\r\nif (!(r->flags) || r->parent)\r\ncontinue;\r\nr_align = pci_resource_alignment(dev, r);\r\nif (!r_align) {\r\ndev_warn(&dev->dev, "BAR %d: %pR has bogus alignment\n",\r\ni, r);\r\ncontinue;\r\n}\r\ntmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\r\nif (!tmp)\r\npanic("pdev_sort_resources(): "\r\n"kmalloc() failed!\n");\r\ntmp->res = r;\r\ntmp->dev = dev;\r\nn = head;\r\nlist_for_each_entry(dev_res, head, list) {\r\nresource_size_t align;\r\nalign = pci_resource_alignment(dev_res->dev,\r\ndev_res->res);\r\nif (r_align > align) {\r\nn = &dev_res->list;\r\nbreak;\r\n}\r\n}\r\nlist_add_tail(&tmp->list, n);\r\n}\r\n}\r\nstatic void __dev_sort_resources(struct pci_dev *dev,\r\nstruct list_head *head)\r\n{\r\nu16 class = dev->class >> 8;\r\nif (class == PCI_CLASS_NOT_DEFINED || class == PCI_CLASS_BRIDGE_HOST)\r\nreturn;\r\nif (class == PCI_CLASS_SYSTEM_PIC) {\r\nu16 command;\r\npci_read_config_word(dev, PCI_COMMAND, &command);\r\nif (command & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY))\r\nreturn;\r\n}\r\npdev_sort_resources(dev, head);\r\n}\r\nstatic inline void reset_resource(struct resource *res)\r\n{\r\nres->start = 0;\r\nres->end = 0;\r\nres->flags = 0;\r\n}\r\nstatic void reassign_resources_sorted(struct list_head *realloc_head,\r\nstruct list_head *head)\r\n{\r\nstruct resource *res;\r\nstruct pci_dev_resource *add_res, *tmp;\r\nstruct pci_dev_resource *dev_res;\r\nresource_size_t add_size;\r\nint idx;\r\nlist_for_each_entry_safe(add_res, tmp, realloc_head, list) {\r\nbool found_match = false;\r\nres = add_res->res;\r\nif (!res->flags)\r\ngoto out;\r\nlist_for_each_entry(dev_res, head, list) {\r\nif (dev_res->res == res) {\r\nfound_match = true;\r\nbreak;\r\n}\r\n}\r\nif (!found_match)\r\ncontinue;\r\nidx = res - &add_res->dev->resource[0];\r\nadd_size = add_res->add_size;\r\nif (!resource_size(res)) {\r\nres->start = add_res->start;\r\nres->end = res->start + add_size - 1;\r\nif (pci_assign_resource(add_res->dev, idx))\r\nreset_resource(res);\r\n} else {\r\nresource_size_t align = add_res->min_align;\r\nres->flags |= add_res->flags &\r\n(IORESOURCE_STARTALIGN|IORESOURCE_SIZEALIGN);\r\nif (pci_reassign_resource(add_res->dev, idx,\r\nadd_size, align))\r\ndev_printk(KERN_DEBUG, &add_res->dev->dev,\r\n"failed to add %llx res[%d]=%pR\n",\r\n(unsigned long long)add_size,\r\nidx, res);\r\n}\r\nout:\r\nlist_del(&add_res->list);\r\nkfree(add_res);\r\n}\r\n}\r\nstatic void assign_requested_resources_sorted(struct list_head *head,\r\nstruct list_head *fail_head)\r\n{\r\nstruct resource *res;\r\nstruct pci_dev_resource *dev_res;\r\nint idx;\r\nlist_for_each_entry(dev_res, head, list) {\r\nres = dev_res->res;\r\nidx = res - &dev_res->dev->resource[0];\r\nif (resource_size(res) &&\r\npci_assign_resource(dev_res->dev, idx)) {\r\nif (fail_head) {\r\nif (!((idx == PCI_ROM_RESOURCE) &&\r\n(!(res->flags & IORESOURCE_ROM_ENABLE))))\r\nadd_to_list(fail_head,\r\ndev_res->dev, res,\r\n0 ,\r\n0 );\r\n}\r\nreset_resource(res);\r\n}\r\n}\r\n}\r\nstatic unsigned long pci_fail_res_type_mask(struct list_head *fail_head)\r\n{\r\nstruct pci_dev_resource *fail_res;\r\nunsigned long mask = 0;\r\nlist_for_each_entry(fail_res, fail_head, list)\r\nmask |= fail_res->flags;\r\nreturn mask & (IORESOURCE_IO | IORESOURCE_MEM | IORESOURCE_PREFETCH);\r\n}\r\nstatic bool pci_need_to_release(unsigned long mask, struct resource *res)\r\n{\r\nif (res->flags & IORESOURCE_IO)\r\nreturn !!(mask & IORESOURCE_IO);\r\nif (res->flags & IORESOURCE_PREFETCH) {\r\nif (mask & IORESOURCE_PREFETCH)\r\nreturn true;\r\nelse if ((mask & IORESOURCE_MEM) &&\r\n!(res->parent->flags & IORESOURCE_PREFETCH))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nif (res->flags & IORESOURCE_MEM)\r\nreturn !!(mask & IORESOURCE_MEM);\r\nreturn false;\r\n}\r\nstatic void __assign_resources_sorted(struct list_head *head,\r\nstruct list_head *realloc_head,\r\nstruct list_head *fail_head)\r\n{\r\nLIST_HEAD(save_head);\r\nLIST_HEAD(local_fail_head);\r\nstruct pci_dev_resource *save_res;\r\nstruct pci_dev_resource *dev_res, *tmp_res;\r\nunsigned long fail_type;\r\nif (!realloc_head || list_empty(realloc_head))\r\ngoto requested_and_reassign;\r\nlist_for_each_entry(dev_res, head, list) {\r\nif (add_to_list(&save_head, dev_res->dev, dev_res->res, 0, 0)) {\r\nfree_list(&save_head);\r\ngoto requested_and_reassign;\r\n}\r\n}\r\nlist_for_each_entry(dev_res, head, list)\r\ndev_res->res->end += get_res_add_size(realloc_head,\r\ndev_res->res);\r\nassign_requested_resources_sorted(head, &local_fail_head);\r\nif (list_empty(&local_fail_head)) {\r\nlist_for_each_entry(dev_res, head, list)\r\nremove_from_list(realloc_head, dev_res->res);\r\nfree_list(&save_head);\r\nfree_list(head);\r\nreturn;\r\n}\r\nfail_type = pci_fail_res_type_mask(&local_fail_head);\r\nlist_for_each_entry_safe(dev_res, tmp_res, head, list)\r\nif (dev_res->res->parent &&\r\n!pci_need_to_release(fail_type, dev_res->res)) {\r\nremove_from_list(realloc_head, dev_res->res);\r\nremove_from_list(&save_head, dev_res->res);\r\nlist_del(&dev_res->list);\r\nkfree(dev_res);\r\n}\r\nfree_list(&local_fail_head);\r\nlist_for_each_entry(dev_res, head, list)\r\nif (dev_res->res->parent)\r\nrelease_resource(dev_res->res);\r\nlist_for_each_entry(save_res, &save_head, list) {\r\nstruct resource *res = save_res->res;\r\nres->start = save_res->start;\r\nres->end = save_res->end;\r\nres->flags = save_res->flags;\r\n}\r\nfree_list(&save_head);\r\nrequested_and_reassign:\r\nassign_requested_resources_sorted(head, fail_head);\r\nif (realloc_head)\r\nreassign_resources_sorted(realloc_head, head);\r\nfree_list(head);\r\n}\r\nstatic void pdev_assign_resources_sorted(struct pci_dev *dev,\r\nstruct list_head *add_head,\r\nstruct list_head *fail_head)\r\n{\r\nLIST_HEAD(head);\r\n__dev_sort_resources(dev, &head);\r\n__assign_resources_sorted(&head, add_head, fail_head);\r\n}\r\nstatic void pbus_assign_resources_sorted(const struct pci_bus *bus,\r\nstruct list_head *realloc_head,\r\nstruct list_head *fail_head)\r\n{\r\nstruct pci_dev *dev;\r\nLIST_HEAD(head);\r\nlist_for_each_entry(dev, &bus->devices, bus_list)\r\n__dev_sort_resources(dev, &head);\r\n__assign_resources_sorted(&head, realloc_head, fail_head);\r\n}\r\nvoid pci_setup_cardbus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *res;\r\nstruct pci_bus_region region;\r\ndev_info(&bridge->dev, "CardBus bridge to %pR\n",\r\n&bus->busn_res);\r\nres = bus->resource[0];\r\npcibios_resource_to_bus(bridge->bus, &region, res);\r\nif (res->flags & IORESOURCE_IO) {\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\npci_write_config_dword(bridge, PCI_CB_IO_BASE_0,\r\nregion.start);\r\npci_write_config_dword(bridge, PCI_CB_IO_LIMIT_0,\r\nregion.end);\r\n}\r\nres = bus->resource[1];\r\npcibios_resource_to_bus(bridge->bus, &region, res);\r\nif (res->flags & IORESOURCE_IO) {\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\npci_write_config_dword(bridge, PCI_CB_IO_BASE_1,\r\nregion.start);\r\npci_write_config_dword(bridge, PCI_CB_IO_LIMIT_1,\r\nregion.end);\r\n}\r\nres = bus->resource[2];\r\npcibios_resource_to_bus(bridge->bus, &region, res);\r\nif (res->flags & IORESOURCE_MEM) {\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\npci_write_config_dword(bridge, PCI_CB_MEMORY_BASE_0,\r\nregion.start);\r\npci_write_config_dword(bridge, PCI_CB_MEMORY_LIMIT_0,\r\nregion.end);\r\n}\r\nres = bus->resource[3];\r\npcibios_resource_to_bus(bridge->bus, &region, res);\r\nif (res->flags & IORESOURCE_MEM) {\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\npci_write_config_dword(bridge, PCI_CB_MEMORY_BASE_1,\r\nregion.start);\r\npci_write_config_dword(bridge, PCI_CB_MEMORY_LIMIT_1,\r\nregion.end);\r\n}\r\n}\r\nstatic void pci_setup_bridge_io(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *res;\r\nstruct pci_bus_region region;\r\nunsigned long io_mask;\r\nu8 io_base_lo, io_limit_lo;\r\nu16 l;\r\nu32 io_upper16;\r\nio_mask = PCI_IO_RANGE_MASK;\r\nif (bridge->io_window_1k)\r\nio_mask = PCI_IO_1K_RANGE_MASK;\r\nres = bus->resource[0];\r\npcibios_resource_to_bus(bridge->bus, &region, res);\r\nif (res->flags & IORESOURCE_IO) {\r\npci_read_config_word(bridge, PCI_IO_BASE, &l);\r\nio_base_lo = (region.start >> 8) & io_mask;\r\nio_limit_lo = (region.end >> 8) & io_mask;\r\nl = ((u16) io_limit_lo << 8) | io_base_lo;\r\nio_upper16 = (region.end & 0xffff0000) | (region.start >> 16);\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\n} else {\r\nio_upper16 = 0;\r\nl = 0x00f0;\r\n}\r\npci_write_config_dword(bridge, PCI_IO_BASE_UPPER16, 0x0000ffff);\r\npci_write_config_word(bridge, PCI_IO_BASE, l);\r\npci_write_config_dword(bridge, PCI_IO_BASE_UPPER16, io_upper16);\r\n}\r\nstatic void pci_setup_bridge_mmio(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *res;\r\nstruct pci_bus_region region;\r\nu32 l;\r\nres = bus->resource[1];\r\npcibios_resource_to_bus(bridge->bus, &region, res);\r\nif (res->flags & IORESOURCE_MEM) {\r\nl = (region.start >> 16) & 0xfff0;\r\nl |= region.end & 0xfff00000;\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\n} else {\r\nl = 0x0000fff0;\r\n}\r\npci_write_config_dword(bridge, PCI_MEMORY_BASE, l);\r\n}\r\nstatic void pci_setup_bridge_mmio_pref(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *res;\r\nstruct pci_bus_region region;\r\nu32 l, bu, lu;\r\npci_write_config_dword(bridge, PCI_PREF_LIMIT_UPPER32, 0);\r\nbu = lu = 0;\r\nres = bus->resource[2];\r\npcibios_resource_to_bus(bridge->bus, &region, res);\r\nif (res->flags & IORESOURCE_PREFETCH) {\r\nl = (region.start >> 16) & 0xfff0;\r\nl |= region.end & 0xfff00000;\r\nif (res->flags & IORESOURCE_MEM_64) {\r\nbu = upper_32_bits(region.start);\r\nlu = upper_32_bits(region.end);\r\n}\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\n} else {\r\nl = 0x0000fff0;\r\n}\r\npci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE, l);\r\npci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32, bu);\r\npci_write_config_dword(bridge, PCI_PREF_LIMIT_UPPER32, lu);\r\n}\r\nstatic void __pci_setup_bridge(struct pci_bus *bus, unsigned long type)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\ndev_info(&bridge->dev, "PCI bridge to %pR\n",\r\n&bus->busn_res);\r\nif (type & IORESOURCE_IO)\r\npci_setup_bridge_io(bus);\r\nif (type & IORESOURCE_MEM)\r\npci_setup_bridge_mmio(bus);\r\nif (type & IORESOURCE_PREFETCH)\r\npci_setup_bridge_mmio_pref(bus);\r\npci_write_config_word(bridge, PCI_BRIDGE_CONTROL, bus->bridge_ctl);\r\n}\r\nvoid pci_setup_bridge(struct pci_bus *bus)\r\n{\r\nunsigned long type = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\n__pci_setup_bridge(bus, type);\r\n}\r\nstatic void pci_bridge_check_ranges(struct pci_bus *bus)\r\n{\r\nu16 io;\r\nu32 pmem;\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *b_res;\r\nb_res = &bridge->resource[PCI_BRIDGE_RESOURCES];\r\nb_res[1].flags |= IORESOURCE_MEM;\r\npci_read_config_word(bridge, PCI_IO_BASE, &io);\r\nif (!io) {\r\npci_write_config_word(bridge, PCI_IO_BASE, 0xe0f0);\r\npci_read_config_word(bridge, PCI_IO_BASE, &io);\r\npci_write_config_word(bridge, PCI_IO_BASE, 0x0);\r\n}\r\nif (io)\r\nb_res[0].flags |= IORESOURCE_IO;\r\nif (bridge->vendor == PCI_VENDOR_ID_DEC && bridge->device == 0x0001)\r\nreturn;\r\npci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);\r\nif (!pmem) {\r\npci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE,\r\n0xffe0fff0);\r\npci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);\r\npci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE, 0x0);\r\n}\r\nif (pmem) {\r\nb_res[2].flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH;\r\nif ((pmem & PCI_PREF_RANGE_TYPE_MASK) ==\r\nPCI_PREF_RANGE_TYPE_64) {\r\nb_res[2].flags |= IORESOURCE_MEM_64;\r\nb_res[2].flags |= PCI_PREF_RANGE_TYPE_64;\r\n}\r\n}\r\nif (b_res[2].flags & IORESOURCE_MEM_64) {\r\nu32 mem_base_hi, tmp;\r\npci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32,\r\n&mem_base_hi);\r\npci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32,\r\n0xffffffff);\r\npci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32, &tmp);\r\nif (!tmp)\r\nb_res[2].flags &= ~IORESOURCE_MEM_64;\r\npci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32,\r\nmem_base_hi);\r\n}\r\n}\r\nstatic struct resource *find_free_bus_resource(struct pci_bus *bus, unsigned long type)\r\n{\r\nint i;\r\nstruct resource *r;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\npci_bus_for_each_resource(bus, r, i) {\r\nif (r == &ioport_resource || r == &iomem_resource)\r\ncontinue;\r\nif (r && (r->flags & type_mask) == type && !r->parent)\r\nreturn r;\r\n}\r\nreturn NULL;\r\n}\r\nstatic resource_size_t calculate_iosize(resource_size_t size,\r\nresource_size_t min_size,\r\nresource_size_t size1,\r\nresource_size_t old_size,\r\nresource_size_t align)\r\n{\r\nif (size < min_size)\r\nsize = min_size;\r\nif (old_size == 1 )\r\nold_size = 0;\r\n#if defined(CONFIG_ISA) || defined(CONFIG_EISA)\r\nsize = (size & 0xff) + ((size & ~0xffUL) << 2);\r\n#endif\r\nsize = ALIGN(size + size1, align);\r\nif (size < old_size)\r\nsize = old_size;\r\nreturn size;\r\n}\r\nstatic resource_size_t calculate_memsize(resource_size_t size,\r\nresource_size_t min_size,\r\nresource_size_t size1,\r\nresource_size_t old_size,\r\nresource_size_t align)\r\n{\r\nif (size < min_size)\r\nsize = min_size;\r\nif (old_size == 1 )\r\nold_size = 0;\r\nif (size < old_size)\r\nsize = old_size;\r\nsize = ALIGN(size + size1, align);\r\nreturn size;\r\n}\r\nresource_size_t __weak pcibios_window_alignment(struct pci_bus *bus,\r\nunsigned long type)\r\n{\r\nreturn 1;\r\n}\r\nstatic resource_size_t window_alignment(struct pci_bus *bus,\r\nunsigned long type)\r\n{\r\nresource_size_t align = 1, arch_align;\r\nif (type & IORESOURCE_MEM)\r\nalign = PCI_P2P_DEFAULT_MEM_ALIGN;\r\nelse if (type & IORESOURCE_IO) {\r\nif (bus->self->io_window_1k)\r\nalign = PCI_P2P_DEFAULT_IO_ALIGN_1K;\r\nelse\r\nalign = PCI_P2P_DEFAULT_IO_ALIGN;\r\n}\r\narch_align = pcibios_window_alignment(bus, type);\r\nreturn max(align, arch_align);\r\n}\r\nstatic void pbus_size_io(struct pci_bus *bus, resource_size_t min_size,\r\nresource_size_t add_size, struct list_head *realloc_head)\r\n{\r\nstruct pci_dev *dev;\r\nstruct resource *b_res = find_free_bus_resource(bus, IORESOURCE_IO);\r\nresource_size_t size = 0, size0 = 0, size1 = 0;\r\nresource_size_t children_add_size = 0;\r\nresource_size_t min_align, align;\r\nif (!b_res)\r\nreturn;\r\nmin_align = window_alignment(bus, IORESOURCE_IO);\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nint i;\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\nstruct resource *r = &dev->resource[i];\r\nunsigned long r_size;\r\nif (r->parent || !(r->flags & IORESOURCE_IO))\r\ncontinue;\r\nr_size = resource_size(r);\r\nif (r_size < 0x400)\r\nsize += r_size;\r\nelse\r\nsize1 += r_size;\r\nalign = pci_resource_alignment(dev, r);\r\nif (align > min_align)\r\nmin_align = align;\r\nif (realloc_head)\r\nchildren_add_size += get_res_add_size(realloc_head, r);\r\n}\r\n}\r\nsize0 = calculate_iosize(size, min_size, size1,\r\nresource_size(b_res), min_align);\r\nif (children_add_size > add_size)\r\nadd_size = children_add_size;\r\nsize1 = (!realloc_head || (realloc_head && !add_size)) ? size0 :\r\ncalculate_iosize(size, min_size, add_size + size1,\r\nresource_size(b_res), min_align);\r\nif (!size0 && !size1) {\r\nif (b_res->start || b_res->end)\r\ndev_info(&bus->self->dev, "disabling bridge window "\r\n"%pR to %pR (unused)\n", b_res,\r\n&bus->busn_res);\r\nb_res->flags = 0;\r\nreturn;\r\n}\r\nb_res->start = min_align;\r\nb_res->end = b_res->start + size0 - 1;\r\nb_res->flags |= IORESOURCE_STARTALIGN;\r\nif (size1 > size0 && realloc_head) {\r\nadd_to_list(realloc_head, bus->self, b_res, size1-size0,\r\nmin_align);\r\ndev_printk(KERN_DEBUG, &bus->self->dev, "bridge window "\r\n"%pR to %pR add_size %llx\n", b_res,\r\n&bus->busn_res,\r\n(unsigned long long)size1-size0);\r\n}\r\n}\r\nstatic inline resource_size_t calculate_mem_align(resource_size_t *aligns,\r\nint max_order)\r\n{\r\nresource_size_t align = 0;\r\nresource_size_t min_align = 0;\r\nint order;\r\nfor (order = 0; order <= max_order; order++) {\r\nresource_size_t align1 = 1;\r\nalign1 <<= (order + 20);\r\nif (!align)\r\nmin_align = align1;\r\nelse if (ALIGN(align + min_align, min_align) < align1)\r\nmin_align = align1 >> 1;\r\nalign += aligns[order];\r\n}\r\nreturn min_align;\r\n}\r\nstatic int pbus_size_mem(struct pci_bus *bus, unsigned long mask,\r\nunsigned long type, resource_size_t min_size,\r\nresource_size_t add_size,\r\nstruct list_head *realloc_head)\r\n{\r\nstruct pci_dev *dev;\r\nresource_size_t min_align, align, size, size0, size1;\r\nresource_size_t aligns[12];\r\nint order, max_order;\r\nstruct resource *b_res = find_free_bus_resource(bus, type);\r\nunsigned int mem64_mask = 0;\r\nresource_size_t children_add_size = 0;\r\nif (!b_res)\r\nreturn 0;\r\nmemset(aligns, 0, sizeof(aligns));\r\nmax_order = 0;\r\nsize = 0;\r\nmem64_mask = b_res->flags & IORESOURCE_MEM_64;\r\nb_res->flags &= ~IORESOURCE_MEM_64;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nint i;\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\nstruct resource *r = &dev->resource[i];\r\nresource_size_t r_size;\r\nif (r->parent || (r->flags & mask) != type)\r\ncontinue;\r\nr_size = resource_size(r);\r\n#ifdef CONFIG_PCI_IOV\r\nif (realloc_head && i >= PCI_IOV_RESOURCES &&\r\ni <= PCI_IOV_RESOURCE_END) {\r\nr->end = r->start - 1;\r\nadd_to_list(realloc_head, dev, r, r_size, 0);\r\nchildren_add_size += r_size;\r\ncontinue;\r\n}\r\n#endif\r\nalign = pci_resource_alignment(dev, r);\r\norder = __ffs(align) - 20;\r\nif (order > 11) {\r\ndev_warn(&dev->dev, "disabling BAR %d: %pR "\r\n"(bad alignment %#llx)\n", i, r,\r\n(unsigned long long) align);\r\nr->flags = 0;\r\ncontinue;\r\n}\r\nsize += r_size;\r\nif (order < 0)\r\norder = 0;\r\nif (r_size == align)\r\naligns[order] += align;\r\nif (order > max_order)\r\nmax_order = order;\r\nmem64_mask &= r->flags & IORESOURCE_MEM_64;\r\nif (realloc_head)\r\nchildren_add_size += get_res_add_size(realloc_head, r);\r\n}\r\n}\r\nmin_align = calculate_mem_align(aligns, max_order);\r\nmin_align = max(min_align, window_alignment(bus, b_res->flags));\r\nsize0 = calculate_memsize(size, min_size, 0, resource_size(b_res), min_align);\r\nif (children_add_size > add_size)\r\nadd_size = children_add_size;\r\nsize1 = (!realloc_head || (realloc_head && !add_size)) ? size0 :\r\ncalculate_memsize(size, min_size, add_size,\r\nresource_size(b_res), min_align);\r\nif (!size0 && !size1) {\r\nif (b_res->start || b_res->end)\r\ndev_info(&bus->self->dev, "disabling bridge window "\r\n"%pR to %pR (unused)\n", b_res,\r\n&bus->busn_res);\r\nb_res->flags = 0;\r\nreturn 1;\r\n}\r\nb_res->start = min_align;\r\nb_res->end = size0 + min_align - 1;\r\nb_res->flags |= IORESOURCE_STARTALIGN | mem64_mask;\r\nif (size1 > size0 && realloc_head) {\r\nadd_to_list(realloc_head, bus->self, b_res, size1-size0, min_align);\r\ndev_printk(KERN_DEBUG, &bus->self->dev, "bridge window "\r\n"%pR to %pR add_size %llx\n", b_res,\r\n&bus->busn_res, (unsigned long long)size1-size0);\r\n}\r\nreturn 1;\r\n}\r\nunsigned long pci_cardbus_resource_alignment(struct resource *res)\r\n{\r\nif (res->flags & IORESOURCE_IO)\r\nreturn pci_cardbus_io_size;\r\nif (res->flags & IORESOURCE_MEM)\r\nreturn pci_cardbus_mem_size;\r\nreturn 0;\r\n}\r\nstatic void pci_bus_size_cardbus(struct pci_bus *bus,\r\nstruct list_head *realloc_head)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *b_res = &bridge->resource[PCI_BRIDGE_RESOURCES];\r\nresource_size_t b_res_3_size = pci_cardbus_mem_size * 2;\r\nu16 ctrl;\r\nif (b_res[0].parent)\r\ngoto handle_b_res_1;\r\nb_res[0].start = pci_cardbus_io_size;\r\nb_res[0].end = b_res[0].start + pci_cardbus_io_size - 1;\r\nb_res[0].flags |= IORESOURCE_IO | IORESOURCE_STARTALIGN;\r\nif (realloc_head) {\r\nb_res[0].end -= pci_cardbus_io_size;\r\nadd_to_list(realloc_head, bridge, b_res, pci_cardbus_io_size,\r\npci_cardbus_io_size);\r\n}\r\nhandle_b_res_1:\r\nif (b_res[1].parent)\r\ngoto handle_b_res_2;\r\nb_res[1].start = pci_cardbus_io_size;\r\nb_res[1].end = b_res[1].start + pci_cardbus_io_size - 1;\r\nb_res[1].flags |= IORESOURCE_IO | IORESOURCE_STARTALIGN;\r\nif (realloc_head) {\r\nb_res[1].end -= pci_cardbus_io_size;\r\nadd_to_list(realloc_head, bridge, b_res+1, pci_cardbus_io_size,\r\npci_cardbus_io_size);\r\n}\r\nhandle_b_res_2:\r\npci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\r\nif (ctrl & PCI_CB_BRIDGE_CTL_PREFETCH_MEM1) {\r\nctrl &= ~PCI_CB_BRIDGE_CTL_PREFETCH_MEM1;\r\npci_write_config_word(bridge, PCI_CB_BRIDGE_CONTROL, ctrl);\r\npci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\r\n}\r\npci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\r\nif (!(ctrl & PCI_CB_BRIDGE_CTL_PREFETCH_MEM0)) {\r\nctrl |= PCI_CB_BRIDGE_CTL_PREFETCH_MEM0;\r\npci_write_config_word(bridge, PCI_CB_BRIDGE_CONTROL, ctrl);\r\npci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\r\n}\r\nif (b_res[2].parent)\r\ngoto handle_b_res_3;\r\nif (ctrl & PCI_CB_BRIDGE_CTL_PREFETCH_MEM0) {\r\nb_res[2].start = pci_cardbus_mem_size;\r\nb_res[2].end = b_res[2].start + pci_cardbus_mem_size - 1;\r\nb_res[2].flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH |\r\nIORESOURCE_STARTALIGN;\r\nif (realloc_head) {\r\nb_res[2].end -= pci_cardbus_mem_size;\r\nadd_to_list(realloc_head, bridge, b_res+2,\r\npci_cardbus_mem_size, pci_cardbus_mem_size);\r\n}\r\nb_res_3_size = pci_cardbus_mem_size;\r\n}\r\nhandle_b_res_3:\r\nif (b_res[3].parent)\r\ngoto handle_done;\r\nb_res[3].start = pci_cardbus_mem_size;\r\nb_res[3].end = b_res[3].start + b_res_3_size - 1;\r\nb_res[3].flags |= IORESOURCE_MEM | IORESOURCE_STARTALIGN;\r\nif (realloc_head) {\r\nb_res[3].end -= b_res_3_size;\r\nadd_to_list(realloc_head, bridge, b_res+3, b_res_3_size,\r\npci_cardbus_mem_size);\r\n}\r\nhandle_done:\r\n;\r\n}\r\nvoid __ref __pci_bus_size_bridges(struct pci_bus *bus,\r\nstruct list_head *realloc_head)\r\n{\r\nstruct pci_dev *dev;\r\nunsigned long mask, prefmask;\r\nresource_size_t additional_mem_size = 0, additional_io_size = 0;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nstruct pci_bus *b = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\nswitch (dev->class >> 8) {\r\ncase PCI_CLASS_BRIDGE_CARDBUS:\r\npci_bus_size_cardbus(b, realloc_head);\r\nbreak;\r\ncase PCI_CLASS_BRIDGE_PCI:\r\ndefault:\r\n__pci_bus_size_bridges(b, realloc_head);\r\nbreak;\r\n}\r\n}\r\nif (pci_is_root_bus(bus))\r\nreturn;\r\nswitch (bus->self->class >> 8) {\r\ncase PCI_CLASS_BRIDGE_CARDBUS:\r\nbreak;\r\ncase PCI_CLASS_BRIDGE_PCI:\r\npci_bridge_check_ranges(bus);\r\nif (bus->self->is_hotplug_bridge) {\r\nadditional_io_size = pci_hotplug_io_size;\r\nadditional_mem_size = pci_hotplug_mem_size;\r\n}\r\ndefault:\r\npbus_size_io(bus, realloc_head ? 0 : additional_io_size,\r\nadditional_io_size, realloc_head);\r\nmask = IORESOURCE_MEM;\r\nprefmask = IORESOURCE_MEM | IORESOURCE_PREFETCH;\r\nif (pbus_size_mem(bus, prefmask, prefmask,\r\nrealloc_head ? 0 : additional_mem_size,\r\nadditional_mem_size, realloc_head))\r\nmask = prefmask;\r\nelse\r\nadditional_mem_size += additional_mem_size;\r\npbus_size_mem(bus, mask, IORESOURCE_MEM,\r\nrealloc_head ? 0 : additional_mem_size,\r\nadditional_mem_size, realloc_head);\r\nbreak;\r\n}\r\n}\r\nvoid __ref pci_bus_size_bridges(struct pci_bus *bus)\r\n{\r\n__pci_bus_size_bridges(bus, NULL);\r\n}\r\nvoid __ref __pci_bus_assign_resources(const struct pci_bus *bus,\r\nstruct list_head *realloc_head,\r\nstruct list_head *fail_head)\r\n{\r\nstruct pci_bus *b;\r\nstruct pci_dev *dev;\r\npbus_assign_resources_sorted(bus, realloc_head, fail_head);\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nb = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\n__pci_bus_assign_resources(b, realloc_head, fail_head);\r\nswitch (dev->class >> 8) {\r\ncase PCI_CLASS_BRIDGE_PCI:\r\nif (!pci_is_enabled(dev))\r\npci_setup_bridge(b);\r\nbreak;\r\ncase PCI_CLASS_BRIDGE_CARDBUS:\r\npci_setup_cardbus(b);\r\nbreak;\r\ndefault:\r\ndev_info(&dev->dev, "not setting up bridge for bus "\r\n"%04x:%02x\n", pci_domain_nr(b), b->number);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid __ref pci_bus_assign_resources(const struct pci_bus *bus)\r\n{\r\n__pci_bus_assign_resources(bus, NULL, NULL);\r\n}\r\nstatic void __ref __pci_bridge_assign_resources(const struct pci_dev *bridge,\r\nstruct list_head *add_head,\r\nstruct list_head *fail_head)\r\n{\r\nstruct pci_bus *b;\r\npdev_assign_resources_sorted((struct pci_dev *)bridge,\r\nadd_head, fail_head);\r\nb = bridge->subordinate;\r\nif (!b)\r\nreturn;\r\n__pci_bus_assign_resources(b, add_head, fail_head);\r\nswitch (bridge->class >> 8) {\r\ncase PCI_CLASS_BRIDGE_PCI:\r\npci_setup_bridge(b);\r\nbreak;\r\ncase PCI_CLASS_BRIDGE_CARDBUS:\r\npci_setup_cardbus(b);\r\nbreak;\r\ndefault:\r\ndev_info(&bridge->dev, "not setting up bridge for bus "\r\n"%04x:%02x\n", pci_domain_nr(b), b->number);\r\nbreak;\r\n}\r\n}\r\nstatic void pci_bridge_release_resources(struct pci_bus *bus,\r\nunsigned long type)\r\n{\r\nint idx;\r\nbool changed = false;\r\nstruct pci_dev *dev;\r\nstruct resource *r;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\ndev = bus->self;\r\nfor (idx = PCI_BRIDGE_RESOURCES; idx <= PCI_BRIDGE_RESOURCE_END;\r\nidx++) {\r\nr = &dev->resource[idx];\r\nif ((r->flags & type_mask) != type)\r\ncontinue;\r\nif (!r->parent)\r\ncontinue;\r\nrelease_child_resources(r);\r\nif (!release_resource(r)) {\r\ndev_printk(KERN_DEBUG, &dev->dev,\r\n"resource %d %pR released\n", idx, r);\r\nr->end = resource_size(r) - 1;\r\nr->start = 0;\r\nr->flags = 0;\r\nchanged = true;\r\n}\r\n}\r\nif (changed) {\r\nif (type & IORESOURCE_PREFETCH)\r\ntype = IORESOURCE_PREFETCH;\r\n__pci_setup_bridge(bus, type);\r\n}\r\n}\r\nstatic void __ref pci_bus_release_bridge_resources(struct pci_bus *bus,\r\nunsigned long type,\r\nenum release_type rel_type)\r\n{\r\nstruct pci_dev *dev;\r\nbool is_leaf_bridge = true;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nstruct pci_bus *b = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\nis_leaf_bridge = false;\r\nif ((dev->class >> 8) != PCI_CLASS_BRIDGE_PCI)\r\ncontinue;\r\nif (rel_type == whole_subtree)\r\npci_bus_release_bridge_resources(b, type,\r\nwhole_subtree);\r\n}\r\nif (pci_is_root_bus(bus))\r\nreturn;\r\nif ((bus->self->class >> 8) != PCI_CLASS_BRIDGE_PCI)\r\nreturn;\r\nif ((rel_type == whole_subtree) || is_leaf_bridge)\r\npci_bridge_release_resources(bus, type);\r\n}\r\nstatic void pci_bus_dump_res(struct pci_bus *bus)\r\n{\r\nstruct resource *res;\r\nint i;\r\npci_bus_for_each_resource(bus, res, i) {\r\nif (!res || !res->end || !res->flags)\r\ncontinue;\r\ndev_printk(KERN_DEBUG, &bus->dev, "resource %d %pR\n", i, res);\r\n}\r\n}\r\nstatic void pci_bus_dump_resources(struct pci_bus *bus)\r\n{\r\nstruct pci_bus *b;\r\nstruct pci_dev *dev;\r\npci_bus_dump_res(bus);\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nb = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\npci_bus_dump_resources(b);\r\n}\r\n}\r\nstatic int pci_bus_get_depth(struct pci_bus *bus)\r\n{\r\nint depth = 0;\r\nstruct pci_bus *child_bus;\r\nlist_for_each_entry(child_bus, &bus->children, node){\r\nint ret;\r\nret = pci_bus_get_depth(child_bus);\r\nif (ret + 1 > depth)\r\ndepth = ret + 1;\r\n}\r\nreturn depth;\r\n}\r\nvoid __init pci_realloc_get_opt(char *str)\r\n{\r\nif (!strncmp(str, "off", 3))\r\npci_realloc_enable = user_disabled;\r\nelse if (!strncmp(str, "on", 2))\r\npci_realloc_enable = user_enabled;\r\n}\r\nstatic bool pci_realloc_enabled(enum enable_type enable)\r\n{\r\nreturn enable >= user_enabled;\r\n}\r\nstatic int iov_resources_unassigned(struct pci_dev *dev, void *data)\r\n{\r\nint i;\r\nbool *unassigned = data;\r\nfor (i = PCI_IOV_RESOURCES; i <= PCI_IOV_RESOURCE_END; i++) {\r\nstruct resource *r = &dev->resource[i];\r\nstruct pci_bus_region region;\r\nif (!r->flags)\r\ncontinue;\r\npcibios_resource_to_bus(dev->bus, &region, r);\r\nif (!region.start) {\r\n*unassigned = true;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic enum enable_type pci_realloc_detect(struct pci_bus *bus,\r\nenum enable_type enable_local)\r\n{\r\nbool unassigned = false;\r\nif (enable_local != undefined)\r\nreturn enable_local;\r\npci_walk_bus(bus, iov_resources_unassigned, &unassigned);\r\nif (unassigned)\r\nreturn auto_enabled;\r\nreturn enable_local;\r\n}\r\nstatic enum enable_type pci_realloc_detect(struct pci_bus *bus,\r\nenum enable_type enable_local)\r\n{\r\nreturn enable_local;\r\n}\r\nvoid pci_assign_unassigned_root_bus_resources(struct pci_bus *bus)\r\n{\r\nLIST_HEAD(realloc_head);\r\nstruct list_head *add_list = NULL;\r\nint tried_times = 0;\r\nenum release_type rel_type = leaf_only;\r\nLIST_HEAD(fail_head);\r\nstruct pci_dev_resource *fail_res;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\nint pci_try_num = 1;\r\nenum enable_type enable_local;\r\nenable_local = pci_realloc_detect(bus, pci_realloc_enable);\r\nif (pci_realloc_enabled(enable_local)) {\r\nint max_depth = pci_bus_get_depth(bus);\r\npci_try_num = max_depth + 1;\r\ndev_printk(KERN_DEBUG, &bus->dev,\r\n"max bus depth: %d pci_try_num: %d\n",\r\nmax_depth, pci_try_num);\r\n}\r\nagain:\r\nif (tried_times + 1 == pci_try_num)\r\nadd_list = &realloc_head;\r\n__pci_bus_size_bridges(bus, add_list);\r\n__pci_bus_assign_resources(bus, add_list, &fail_head);\r\nif (add_list)\r\nBUG_ON(!list_empty(add_list));\r\ntried_times++;\r\nif (list_empty(&fail_head))\r\ngoto dump;\r\nif (tried_times >= pci_try_num) {\r\nif (enable_local == undefined)\r\ndev_info(&bus->dev, "Some PCI device resources are unassigned, try booting with pci=realloc\n");\r\nelse if (enable_local == auto_enabled)\r\ndev_info(&bus->dev, "Automatically enabled pci realloc, if you have problem, try booting with pci=realloc=off\n");\r\nfree_list(&fail_head);\r\ngoto dump;\r\n}\r\ndev_printk(KERN_DEBUG, &bus->dev,\r\n"No. %d try to assign unassigned res\n", tried_times + 1);\r\nif ((tried_times + 1) > 2)\r\nrel_type = whole_subtree;\r\nlist_for_each_entry(fail_res, &fail_head, list)\r\npci_bus_release_bridge_resources(fail_res->dev->bus,\r\nfail_res->flags & type_mask,\r\nrel_type);\r\nlist_for_each_entry(fail_res, &fail_head, list) {\r\nstruct resource *res = fail_res->res;\r\nres->start = fail_res->start;\r\nres->end = fail_res->end;\r\nres->flags = fail_res->flags;\r\nif (fail_res->dev->subordinate)\r\nres->flags = 0;\r\n}\r\nfree_list(&fail_head);\r\ngoto again;\r\ndump:\r\npci_bus_dump_resources(bus);\r\n}\r\nvoid __init pci_assign_unassigned_resources(void)\r\n{\r\nstruct pci_bus *root_bus;\r\nlist_for_each_entry(root_bus, &pci_root_buses, node)\r\npci_assign_unassigned_root_bus_resources(root_bus);\r\n}\r\nvoid pci_assign_unassigned_bridge_resources(struct pci_dev *bridge)\r\n{\r\nstruct pci_bus *parent = bridge->subordinate;\r\nLIST_HEAD(add_list);\r\nint tried_times = 0;\r\nLIST_HEAD(fail_head);\r\nstruct pci_dev_resource *fail_res;\r\nint retval;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\nagain:\r\n__pci_bus_size_bridges(parent, &add_list);\r\n__pci_bridge_assign_resources(bridge, &add_list, &fail_head);\r\nBUG_ON(!list_empty(&add_list));\r\ntried_times++;\r\nif (list_empty(&fail_head))\r\ngoto enable_all;\r\nif (tried_times >= 2) {\r\nfree_list(&fail_head);\r\ngoto enable_all;\r\n}\r\nprintk(KERN_DEBUG "PCI: No. %d try to assign unassigned res\n",\r\ntried_times + 1);\r\nlist_for_each_entry(fail_res, &fail_head, list)\r\npci_bus_release_bridge_resources(fail_res->dev->bus,\r\nfail_res->flags & type_mask,\r\nwhole_subtree);\r\nlist_for_each_entry(fail_res, &fail_head, list) {\r\nstruct resource *res = fail_res->res;\r\nres->start = fail_res->start;\r\nres->end = fail_res->end;\r\nres->flags = fail_res->flags;\r\nif (fail_res->dev->subordinate)\r\nres->flags = 0;\r\n}\r\nfree_list(&fail_head);\r\ngoto again;\r\nenable_all:\r\nretval = pci_reenable_device(bridge);\r\nif (retval)\r\ndev_err(&bridge->dev, "Error reenabling bridge (%d)\n", retval);\r\npci_set_master(bridge);\r\n}\r\nvoid pci_assign_unassigned_bus_resources(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nLIST_HEAD(add_list);\r\ndown_read(&pci_bus_sem);\r\nlist_for_each_entry(dev, &bus->devices, bus_list)\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||\r\ndev->hdr_type == PCI_HEADER_TYPE_CARDBUS)\r\nif (dev->subordinate)\r\n__pci_bus_size_bridges(dev->subordinate,\r\n&add_list);\r\nup_read(&pci_bus_sem);\r\n__pci_bus_assign_resources(bus, &add_list, NULL);\r\nBUG_ON(!list_empty(&add_list));\r\n}
