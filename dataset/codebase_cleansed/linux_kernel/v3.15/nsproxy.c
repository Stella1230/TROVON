static inline struct nsproxy *create_nsproxy(void)\r\n{\r\nstruct nsproxy *nsproxy;\r\nnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);\r\nif (nsproxy)\r\natomic_set(&nsproxy->count, 1);\r\nreturn nsproxy;\r\n}\r\nstatic struct nsproxy *create_new_namespaces(unsigned long flags,\r\nstruct task_struct *tsk, struct user_namespace *user_ns,\r\nstruct fs_struct *new_fs)\r\n{\r\nstruct nsproxy *new_nsp;\r\nint err;\r\nnew_nsp = create_nsproxy();\r\nif (!new_nsp)\r\nreturn ERR_PTR(-ENOMEM);\r\nnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\r\nif (IS_ERR(new_nsp->mnt_ns)) {\r\nerr = PTR_ERR(new_nsp->mnt_ns);\r\ngoto out_ns;\r\n}\r\nnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\r\nif (IS_ERR(new_nsp->uts_ns)) {\r\nerr = PTR_ERR(new_nsp->uts_ns);\r\ngoto out_uts;\r\n}\r\nnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\r\nif (IS_ERR(new_nsp->ipc_ns)) {\r\nerr = PTR_ERR(new_nsp->ipc_ns);\r\ngoto out_ipc;\r\n}\r\nnew_nsp->pid_ns_for_children =\r\ncopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\r\nif (IS_ERR(new_nsp->pid_ns_for_children)) {\r\nerr = PTR_ERR(new_nsp->pid_ns_for_children);\r\ngoto out_pid;\r\n}\r\nnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\r\nif (IS_ERR(new_nsp->net_ns)) {\r\nerr = PTR_ERR(new_nsp->net_ns);\r\ngoto out_net;\r\n}\r\nreturn new_nsp;\r\nout_net:\r\nif (new_nsp->pid_ns_for_children)\r\nput_pid_ns(new_nsp->pid_ns_for_children);\r\nout_pid:\r\nif (new_nsp->ipc_ns)\r\nput_ipc_ns(new_nsp->ipc_ns);\r\nout_ipc:\r\nif (new_nsp->uts_ns)\r\nput_uts_ns(new_nsp->uts_ns);\r\nout_uts:\r\nif (new_nsp->mnt_ns)\r\nput_mnt_ns(new_nsp->mnt_ns);\r\nout_ns:\r\nkmem_cache_free(nsproxy_cachep, new_nsp);\r\nreturn ERR_PTR(err);\r\n}\r\nint copy_namespaces(unsigned long flags, struct task_struct *tsk)\r\n{\r\nstruct nsproxy *old_ns = tsk->nsproxy;\r\nstruct user_namespace *user_ns = task_cred_xxx(tsk, user_ns);\r\nstruct nsproxy *new_ns;\r\nif (likely(!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\r\nCLONE_NEWPID | CLONE_NEWNET)))) {\r\nget_nsproxy(old_ns);\r\nreturn 0;\r\n}\r\nif (!ns_capable(user_ns, CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif ((flags & (CLONE_NEWIPC | CLONE_SYSVSEM)) ==\r\n(CLONE_NEWIPC | CLONE_SYSVSEM))\r\nreturn -EINVAL;\r\nnew_ns = create_new_namespaces(flags, tsk, user_ns, tsk->fs);\r\nif (IS_ERR(new_ns))\r\nreturn PTR_ERR(new_ns);\r\ntsk->nsproxy = new_ns;\r\nreturn 0;\r\n}\r\nvoid free_nsproxy(struct nsproxy *ns)\r\n{\r\nif (ns->mnt_ns)\r\nput_mnt_ns(ns->mnt_ns);\r\nif (ns->uts_ns)\r\nput_uts_ns(ns->uts_ns);\r\nif (ns->ipc_ns)\r\nput_ipc_ns(ns->ipc_ns);\r\nif (ns->pid_ns_for_children)\r\nput_pid_ns(ns->pid_ns_for_children);\r\nput_net(ns->net_ns);\r\nkmem_cache_free(nsproxy_cachep, ns);\r\n}\r\nint unshare_nsproxy_namespaces(unsigned long unshare_flags,\r\nstruct nsproxy **new_nsp, struct cred *new_cred, struct fs_struct *new_fs)\r\n{\r\nstruct user_namespace *user_ns;\r\nint err = 0;\r\nif (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\r\nCLONE_NEWNET | CLONE_NEWPID)))\r\nreturn 0;\r\nuser_ns = new_cred ? new_cred->user_ns : current_user_ns();\r\nif (!ns_capable(user_ns, CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\n*new_nsp = create_new_namespaces(unshare_flags, current, user_ns,\r\nnew_fs ? new_fs : current->fs);\r\nif (IS_ERR(*new_nsp)) {\r\nerr = PTR_ERR(*new_nsp);\r\ngoto out;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nvoid switch_task_namespaces(struct task_struct *p, struct nsproxy *new)\r\n{\r\nstruct nsproxy *ns;\r\nmight_sleep();\r\nns = p->nsproxy;\r\nrcu_assign_pointer(p->nsproxy, new);\r\nif (ns && atomic_dec_and_test(&ns->count)) {\r\nsynchronize_rcu();\r\nfree_nsproxy(ns);\r\n}\r\n}\r\nvoid exit_task_namespaces(struct task_struct *p)\r\n{\r\nswitch_task_namespaces(p, NULL);\r\n}\r\nint __init nsproxy_cache_init(void)\r\n{\r\nnsproxy_cachep = KMEM_CACHE(nsproxy, SLAB_PANIC);\r\nreturn 0;\r\n}
