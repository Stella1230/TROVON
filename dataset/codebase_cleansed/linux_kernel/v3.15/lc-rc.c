static int uwb_rc_index_match(struct device *dev, const void *data)\r\n{\r\nconst int *index = data;\r\nstruct uwb_rc *rc = dev_get_drvdata(dev);\r\nif (rc->index == *index)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct uwb_rc *uwb_rc_find_by_index(int index)\r\n{\r\nstruct device *dev;\r\nstruct uwb_rc *rc = NULL;\r\ndev = class_find_device(&uwb_rc_class, NULL, &index, uwb_rc_index_match);\r\nif (dev)\r\nrc = dev_get_drvdata(dev);\r\nreturn rc;\r\n}\r\nstatic int uwb_rc_new_index(void)\r\n{\r\nint index = 0;\r\nfor (;;) {\r\nif (!uwb_rc_find_by_index(index))\r\nreturn index;\r\nif (++index < 0)\r\nindex = 0;\r\n}\r\n}\r\nstatic void uwb_rc_sys_release(struct device *dev)\r\n{\r\nstruct uwb_dev *uwb_dev = container_of(dev, struct uwb_dev, dev);\r\nstruct uwb_rc *rc = container_of(uwb_dev, struct uwb_rc, uwb_dev);\r\nuwb_rc_ie_release(rc);\r\nkfree(rc);\r\n}\r\nvoid uwb_rc_init(struct uwb_rc *rc)\r\n{\r\nstruct uwb_dev *uwb_dev = &rc->uwb_dev;\r\nuwb_dev_init(uwb_dev);\r\nrc->uwb_dev.dev.class = &uwb_rc_class;\r\nrc->uwb_dev.dev.release = uwb_rc_sys_release;\r\nuwb_rc_neh_create(rc);\r\nrc->beaconing = -1;\r\nrc->scan_type = UWB_SCAN_DISABLED;\r\nINIT_LIST_HEAD(&rc->notifs_chain.list);\r\nmutex_init(&rc->notifs_chain.mutex);\r\nINIT_LIST_HEAD(&rc->uwb_beca.list);\r\nmutex_init(&rc->uwb_beca.mutex);\r\nuwb_drp_avail_init(rc);\r\nuwb_rc_ie_init(rc);\r\nuwb_rsv_init(rc);\r\nuwb_rc_pal_init(rc);\r\n}\r\nstruct uwb_rc *uwb_rc_alloc(void)\r\n{\r\nstruct uwb_rc *rc;\r\nrc = kzalloc(sizeof(*rc), GFP_KERNEL);\r\nif (rc == NULL)\r\nreturn NULL;\r\nuwb_rc_init(rc);\r\nreturn rc;\r\n}\r\nstatic int uwb_rc_sys_add(struct uwb_rc *rc)\r\n{\r\nreturn sysfs_create_group(&rc->uwb_dev.dev.kobj, &rc_attr_group);\r\n}\r\nstatic void __uwb_rc_sys_rm(struct uwb_rc *rc)\r\n{\r\nsysfs_remove_group(&rc->uwb_dev.dev.kobj, &rc_attr_group);\r\n}\r\nstatic\r\nint uwb_rc_mac_addr_setup(struct uwb_rc *rc)\r\n{\r\nint result;\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nstruct uwb_dev *uwb_dev = &rc->uwb_dev;\r\nchar devname[UWB_ADDR_STRSIZE];\r\nstruct uwb_mac_addr addr;\r\nresult = uwb_rc_mac_addr_get(rc, &addr);\r\nif (result < 0) {\r\ndev_err(dev, "cannot retrieve UWB EUI-48 address: %d\n", result);\r\nreturn result;\r\n}\r\nif (uwb_mac_addr_unset(&addr) || uwb_mac_addr_bcast(&addr)) {\r\naddr.data[0] = 0x02;\r\nget_random_bytes(&addr.data[1], sizeof(addr.data)-1);\r\nresult = uwb_rc_mac_addr_set(rc, &addr);\r\nif (result < 0) {\r\nuwb_mac_addr_print(devname, sizeof(devname), &addr);\r\ndev_err(dev, "cannot set EUI-48 address %s: %d\n",\r\ndevname, result);\r\nreturn result;\r\n}\r\n}\r\nuwb_dev->mac_addr = addr;\r\nreturn 0;\r\n}\r\nstatic int uwb_rc_setup(struct uwb_rc *rc)\r\n{\r\nint result;\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nresult = uwb_radio_setup(rc);\r\nif (result < 0) {\r\ndev_err(dev, "cannot setup UWB radio: %d\n", result);\r\ngoto error;\r\n}\r\nresult = uwb_rc_mac_addr_setup(rc);\r\nif (result < 0) {\r\ndev_err(dev, "cannot setup UWB MAC address: %d\n", result);\r\ngoto error;\r\n}\r\nresult = uwb_rc_dev_addr_assign(rc);\r\nif (result < 0) {\r\ndev_err(dev, "cannot assign UWB DevAddr: %d\n", result);\r\ngoto error;\r\n}\r\nresult = uwb_rc_ie_setup(rc);\r\nif (result < 0) {\r\ndev_err(dev, "cannot setup IE subsystem: %d\n", result);\r\ngoto error_ie_setup;\r\n}\r\nresult = uwb_rsv_setup(rc);\r\nif (result < 0) {\r\ndev_err(dev, "cannot setup reservation subsystem: %d\n", result);\r\ngoto error_rsv_setup;\r\n}\r\nuwb_dbg_add_rc(rc);\r\nreturn 0;\r\nerror_rsv_setup:\r\nuwb_rc_ie_release(rc);\r\nerror_ie_setup:\r\nerror:\r\nreturn result;\r\n}\r\nint uwb_rc_add(struct uwb_rc *rc, struct device *parent_dev, void *priv)\r\n{\r\nint result;\r\nstruct device *dev;\r\nchar macbuf[UWB_ADDR_STRSIZE], devbuf[UWB_ADDR_STRSIZE];\r\nrc->index = uwb_rc_new_index();\r\ndev = &rc->uwb_dev.dev;\r\ndev_set_name(dev, "uwb%d", rc->index);\r\nrc->priv = priv;\r\ninit_waitqueue_head(&rc->uwbd.wq);\r\nINIT_LIST_HEAD(&rc->uwbd.event_list);\r\nspin_lock_init(&rc->uwbd.event_list_lock);\r\nuwbd_start(rc);\r\nresult = rc->start(rc);\r\nif (result < 0)\r\ngoto error_rc_start;\r\nresult = uwb_rc_setup(rc);\r\nif (result < 0) {\r\ndev_err(dev, "cannot setup UWB radio controller: %d\n", result);\r\ngoto error_rc_setup;\r\n}\r\nresult = uwb_dev_add(&rc->uwb_dev, parent_dev, rc);\r\nif (result < 0 && result != -EADDRNOTAVAIL)\r\ngoto error_dev_add;\r\nresult = uwb_rc_sys_add(rc);\r\nif (result < 0) {\r\ndev_err(parent_dev, "cannot register UWB radio controller "\r\n"dev attributes: %d\n", result);\r\ngoto error_sys_add;\r\n}\r\nuwb_mac_addr_print(macbuf, sizeof(macbuf), &rc->uwb_dev.mac_addr);\r\nuwb_dev_addr_print(devbuf, sizeof(devbuf), &rc->uwb_dev.dev_addr);\r\ndev_info(dev,\r\n"new uwb radio controller (mac %s dev %s) on %s %s\n",\r\nmacbuf, devbuf, parent_dev->bus->name, dev_name(parent_dev));\r\nrc->ready = 1;\r\nreturn 0;\r\nerror_sys_add:\r\nuwb_dev_rm(&rc->uwb_dev);\r\nerror_dev_add:\r\nerror_rc_setup:\r\nrc->stop(rc);\r\nerror_rc_start:\r\nuwbd_stop(rc);\r\nreturn result;\r\n}\r\nstatic int uwb_dev_offair_helper(struct device *dev, void *priv)\r\n{\r\nstruct uwb_dev *uwb_dev = to_uwb_dev(dev);\r\nreturn __uwb_dev_offair(uwb_dev, uwb_dev->rc);\r\n}\r\nvoid uwb_rc_rm(struct uwb_rc *rc)\r\n{\r\nrc->ready = 0;\r\nuwb_dbg_del_rc(rc);\r\nuwb_rsv_remove_all(rc);\r\nuwb_radio_shutdown(rc);\r\nrc->stop(rc);\r\nuwbd_stop(rc);\r\nuwb_rc_neh_destroy(rc);\r\nuwb_dev_lock(&rc->uwb_dev);\r\nrc->priv = NULL;\r\nrc->cmd = NULL;\r\nuwb_dev_unlock(&rc->uwb_dev);\r\nmutex_lock(&rc->uwb_beca.mutex);\r\nuwb_dev_for_each(rc, uwb_dev_offair_helper, NULL);\r\n__uwb_rc_sys_rm(rc);\r\nmutex_unlock(&rc->uwb_beca.mutex);\r\nuwb_rsv_cleanup(rc);\r\nuwb_beca_release(rc);\r\nuwb_dev_rm(&rc->uwb_dev);\r\n}\r\nstatic int find_rc_try_get(struct device *dev, const void *data)\r\n{\r\nconst struct uwb_rc *target_rc = data;\r\nstruct uwb_rc *rc = dev_get_drvdata(dev);\r\nif (rc == NULL) {\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nif (rc == target_rc) {\r\nif (rc->ready == 0)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstruct uwb_rc *__uwb_rc_try_get(struct uwb_rc *target_rc)\r\n{\r\nstruct device *dev;\r\nstruct uwb_rc *rc = NULL;\r\ndev = class_find_device(&uwb_rc_class, NULL, target_rc,\r\nfind_rc_try_get);\r\nif (dev) {\r\nrc = dev_get_drvdata(dev);\r\n__uwb_rc_get(rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic inline struct uwb_rc *uwb_rc_get(struct uwb_rc *rc)\r\n{\r\nif (rc->ready == 0)\r\nreturn NULL;\r\nuwb_dev_get(&rc->uwb_dev);\r\nreturn rc;\r\n}\r\nstatic int find_rc_grandpa(struct device *dev, const void *data)\r\n{\r\nconst struct device *grandpa_dev = data;\r\nstruct uwb_rc *rc = dev_get_drvdata(dev);\r\nif (rc->uwb_dev.dev.parent->parent == grandpa_dev) {\r\nrc = uwb_rc_get(rc);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstruct uwb_rc *uwb_rc_get_by_grandpa(const struct device *grandpa_dev)\r\n{\r\nstruct device *dev;\r\nstruct uwb_rc *rc = NULL;\r\ndev = class_find_device(&uwb_rc_class, NULL, grandpa_dev,\r\nfind_rc_grandpa);\r\nif (dev)\r\nrc = dev_get_drvdata(dev);\r\nreturn rc;\r\n}\r\nstatic int find_rc_dev(struct device *dev, const void *data)\r\n{\r\nconst struct uwb_dev_addr *addr = data;\r\nstruct uwb_rc *rc = dev_get_drvdata(dev);\r\nif (rc == NULL) {\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nif (!uwb_dev_addr_cmp(&rc->uwb_dev.dev_addr, addr)) {\r\nrc = uwb_rc_get(rc);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstruct uwb_rc *uwb_rc_get_by_dev(const struct uwb_dev_addr *addr)\r\n{\r\nstruct device *dev;\r\nstruct uwb_rc *rc = NULL;\r\ndev = class_find_device(&uwb_rc_class, NULL, addr, find_rc_dev);\r\nif (dev)\r\nrc = dev_get_drvdata(dev);\r\nreturn rc;\r\n}\r\nvoid uwb_rc_put(struct uwb_rc *rc)\r\n{\r\n__uwb_rc_put(rc);\r\n}
