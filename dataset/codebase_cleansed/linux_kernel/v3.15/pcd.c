static int pcd_block_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct pcd_unit *cd = bdev->bd_disk->private_data;\r\nint ret;\r\nmutex_lock(&pcd_mutex);\r\nret = cdrom_open(&cd->info, bdev, mode);\r\nmutex_unlock(&pcd_mutex);\r\nreturn ret;\r\n}\r\nstatic void pcd_block_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct pcd_unit *cd = disk->private_data;\r\nmutex_lock(&pcd_mutex);\r\ncdrom_release(&cd->info, mode);\r\nmutex_unlock(&pcd_mutex);\r\n}\r\nstatic int pcd_block_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned cmd, unsigned long arg)\r\n{\r\nstruct pcd_unit *cd = bdev->bd_disk->private_data;\r\nint ret;\r\nmutex_lock(&pcd_mutex);\r\nret = cdrom_ioctl(&cd->info, bdev, mode, cmd, arg);\r\nmutex_unlock(&pcd_mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned int pcd_block_check_events(struct gendisk *disk,\r\nunsigned int clearing)\r\n{\r\nstruct pcd_unit *cd = disk->private_data;\r\nreturn cdrom_check_events(&cd->info, clearing);\r\n}\r\nstatic void pcd_init_units(void)\r\n{\r\nstruct pcd_unit *cd;\r\nint unit;\r\npcd_drive_count = 0;\r\nfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\r\nstruct gendisk *disk = alloc_disk(1);\r\nif (!disk)\r\ncontinue;\r\ncd->disk = disk;\r\ncd->pi = &cd->pia;\r\ncd->present = 0;\r\ncd->last_sense = 0;\r\ncd->changed = 1;\r\ncd->drive = (*drives[unit])[D_SLV];\r\nif ((*drives[unit])[D_PRT])\r\npcd_drive_count++;\r\ncd->name = &cd->info.name[0];\r\nsnprintf(cd->name, sizeof(cd->info.name), "%s%d", name, unit);\r\ncd->info.ops = &pcd_dops;\r\ncd->info.handle = cd;\r\ncd->info.speed = 0;\r\ncd->info.capacity = 1;\r\ncd->info.mask = 0;\r\ndisk->major = major;\r\ndisk->first_minor = unit;\r\nstrcpy(disk->disk_name, cd->name);\r\ndisk->fops = &pcd_bdops;\r\ndisk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;\r\n}\r\n}\r\nstatic int pcd_open(struct cdrom_device_info *cdi, int purpose)\r\n{\r\nstruct pcd_unit *cd = cdi->handle;\r\nif (!cd->present)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void pcd_release(struct cdrom_device_info *cdi)\r\n{\r\n}\r\nstatic inline int status_reg(struct pcd_unit *cd)\r\n{\r\nreturn pi_read_regr(cd->pi, 1, 6);\r\n}\r\nstatic inline int read_reg(struct pcd_unit *cd, int reg)\r\n{\r\nreturn pi_read_regr(cd->pi, 0, reg);\r\n}\r\nstatic inline void write_reg(struct pcd_unit *cd, int reg, int val)\r\n{\r\npi_write_regr(cd->pi, 0, reg, val);\r\n}\r\nstatic int pcd_wait(struct pcd_unit *cd, int go, int stop, char *fun, char *msg)\r\n{\r\nint j, r, e, s, p;\r\nj = 0;\r\nwhile ((((r = status_reg(cd)) & go) || (stop && (!(r & stop))))\r\n&& (j++ < PCD_SPIN))\r\nudelay(PCD_DELAY);\r\nif ((r & (IDE_ERR & stop)) || (j > PCD_SPIN)) {\r\ns = read_reg(cd, 7);\r\ne = read_reg(cd, 1);\r\np = read_reg(cd, 2);\r\nif (j > PCD_SPIN)\r\ne |= 0x100;\r\nif (fun)\r\nprintk("%s: %s %s: alt=0x%x stat=0x%x err=0x%x"\r\n" loop=%d phase=%d\n",\r\ncd->name, fun, msg, r, s, e, j, p);\r\nreturn (s << 8) + r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcd_command(struct pcd_unit *cd, char *cmd, int dlen, char *fun)\r\n{\r\npi_connect(cd->pi);\r\nwrite_reg(cd, 6, 0xa0 + 0x10 * cd->drive);\r\nif (pcd_wait(cd, IDE_BUSY | IDE_DRQ, 0, fun, "before command")) {\r\npi_disconnect(cd->pi);\r\nreturn -1;\r\n}\r\nwrite_reg(cd, 4, dlen % 256);\r\nwrite_reg(cd, 5, dlen / 256);\r\nwrite_reg(cd, 7, 0xa0);\r\nif (pcd_wait(cd, IDE_BUSY, IDE_DRQ, fun, "command DRQ")) {\r\npi_disconnect(cd->pi);\r\nreturn -1;\r\n}\r\nif (read_reg(cd, 2) != 1) {\r\nprintk("%s: %s: command phase error\n", cd->name, fun);\r\npi_disconnect(cd->pi);\r\nreturn -1;\r\n}\r\npi_write_block(cd->pi, cmd, 12);\r\nreturn 0;\r\n}\r\nstatic int pcd_completion(struct pcd_unit *cd, char *buf, char *fun)\r\n{\r\nint r, d, p, n, k, j;\r\nr = -1;\r\nk = 0;\r\nj = 0;\r\nif (!pcd_wait(cd, IDE_BUSY, IDE_DRQ | IDE_READY | IDE_ERR,\r\nfun, "completion")) {\r\nr = 0;\r\nwhile (read_reg(cd, 7) & IDE_DRQ) {\r\nd = read_reg(cd, 4) + 256 * read_reg(cd, 5);\r\nn = (d + 3) & 0xfffc;\r\np = read_reg(cd, 2) & 3;\r\nif ((p == 2) && (n > 0) && (j == 0)) {\r\npi_read_block(cd->pi, buf, n);\r\nif (verbose > 1)\r\nprintk("%s: %s: Read %d bytes\n",\r\ncd->name, fun, n);\r\nr = 0;\r\nj++;\r\n} else {\r\nif (verbose > 1)\r\nprintk\r\n("%s: %s: Unexpected phase %d, d=%d, k=%d\n",\r\ncd->name, fun, p, d, k);\r\nif (verbose < 2)\r\nprintk_once(\r\n"%s: WARNING: ATAPI phase errors\n",\r\ncd->name);\r\nmdelay(1);\r\n}\r\nif (k++ > PCD_TMO) {\r\nprintk("%s: Stuck DRQ\n", cd->name);\r\nbreak;\r\n}\r\nif (pcd_wait\r\n(cd, IDE_BUSY, IDE_DRQ | IDE_READY | IDE_ERR, fun,\r\n"completion")) {\r\nr = -1;\r\nbreak;\r\n}\r\n}\r\n}\r\npi_disconnect(cd->pi);\r\nreturn r;\r\n}\r\nstatic void pcd_req_sense(struct pcd_unit *cd, char *fun)\r\n{\r\nchar rs_cmd[12] = { 0x03, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0 };\r\nchar buf[16];\r\nint r, c;\r\nr = pcd_command(cd, rs_cmd, 16, "Request sense");\r\nmdelay(1);\r\nif (!r)\r\npcd_completion(cd, buf, "Request sense");\r\ncd->last_sense = -1;\r\nc = 2;\r\nif (!r) {\r\nif (fun)\r\nprintk("%s: %s: Sense key: %x, ASC: %x, ASQ: %x\n",\r\ncd->name, fun, buf[2] & 0xf, buf[12], buf[13]);\r\nc = buf[2] & 0xf;\r\ncd->last_sense =\r\nc | ((buf[12] & 0xff) << 8) | ((buf[13] & 0xff) << 16);\r\n}\r\nif ((c == 2) || (c == 6))\r\ncd->changed = 1;\r\n}\r\nstatic int pcd_atapi(struct pcd_unit *cd, char *cmd, int dlen, char *buf, char *fun)\r\n{\r\nint r;\r\nr = pcd_command(cd, cmd, dlen, fun);\r\nmdelay(1);\r\nif (!r)\r\nr = pcd_completion(cd, buf, fun);\r\nif (r)\r\npcd_req_sense(cd, fun);\r\nreturn r;\r\n}\r\nstatic int pcd_packet(struct cdrom_device_info *cdi, struct packet_command *cgc)\r\n{\r\nreturn pcd_atapi(cdi->handle, cgc->cmd, cgc->buflen, cgc->buffer,\r\n"generic packet");\r\n}\r\nstatic unsigned int pcd_check_events(struct cdrom_device_info *cdi,\r\nunsigned int clearing, int slot_nr)\r\n{\r\nstruct pcd_unit *cd = cdi->handle;\r\nint res = cd->changed;\r\nif (res)\r\ncd->changed = 0;\r\nreturn res ? DISK_EVENT_MEDIA_CHANGE : 0;\r\n}\r\nstatic int pcd_lock_door(struct cdrom_device_info *cdi, int lock)\r\n{\r\nchar un_cmd[12] = { 0x1e, 0, 0, 0, lock, 0, 0, 0, 0, 0, 0, 0 };\r\nreturn pcd_atapi(cdi->handle, un_cmd, 0, pcd_scratch,\r\nlock ? "lock door" : "unlock door");\r\n}\r\nstatic int pcd_tray_move(struct cdrom_device_info *cdi, int position)\r\n{\r\nchar ej_cmd[12] = { 0x1b, 0, 0, 0, 3 - position, 0, 0, 0, 0, 0, 0, 0 };\r\nreturn pcd_atapi(cdi->handle, ej_cmd, 0, pcd_scratch,\r\nposition ? "eject" : "close tray");\r\n}\r\nstatic void pcd_sleep(int cs)\r\n{\r\nschedule_timeout_interruptible(cs);\r\n}\r\nstatic int pcd_reset(struct pcd_unit *cd)\r\n{\r\nint i, k, flg;\r\nint expect[5] = { 1, 1, 1, 0x14, 0xeb };\r\npi_connect(cd->pi);\r\nwrite_reg(cd, 6, 0xa0 + 0x10 * cd->drive);\r\nwrite_reg(cd, 7, 8);\r\npcd_sleep(20 * HZ / 1000);\r\nk = 0;\r\nwhile ((k++ < PCD_RESET_TMO) && (status_reg(cd) & IDE_BUSY))\r\npcd_sleep(HZ / 10);\r\nflg = 1;\r\nfor (i = 0; i < 5; i++)\r\nflg &= (read_reg(cd, i + 1) == expect[i]);\r\nif (verbose) {\r\nprintk("%s: Reset (%d) signature = ", cd->name, k);\r\nfor (i = 0; i < 5; i++)\r\nprintk("%3x", read_reg(cd, i + 1));\r\nif (!flg)\r\nprintk(" (incorrect)");\r\nprintk("\n");\r\n}\r\npi_disconnect(cd->pi);\r\nreturn flg - 1;\r\n}\r\nstatic int pcd_drive_reset(struct cdrom_device_info *cdi)\r\n{\r\nreturn pcd_reset(cdi->handle);\r\n}\r\nstatic int pcd_ready_wait(struct pcd_unit *cd, int tmo)\r\n{\r\nchar tr_cmd[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\nint k, p;\r\nk = 0;\r\nwhile (k < tmo) {\r\ncd->last_sense = 0;\r\npcd_atapi(cd, tr_cmd, 0, NULL, DBMSG("test unit ready"));\r\np = cd->last_sense;\r\nif (!p)\r\nreturn 0;\r\nif (!(((p & 0xffff) == 0x0402) || ((p & 0xff) == 6)))\r\nreturn p;\r\nk++;\r\npcd_sleep(HZ);\r\n}\r\nreturn 0x000020;\r\n}\r\nstatic int pcd_drive_status(struct cdrom_device_info *cdi, int slot_nr)\r\n{\r\nchar rc_cmd[12] = { 0x25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\nstruct pcd_unit *cd = cdi->handle;\r\nif (pcd_ready_wait(cd, PCD_READY_TMO))\r\nreturn CDS_DRIVE_NOT_READY;\r\nif (pcd_atapi(cd, rc_cmd, 8, pcd_scratch, DBMSG("check media")))\r\nreturn CDS_NO_DISC;\r\nreturn CDS_DISC_OK;\r\n}\r\nstatic int pcd_identify(struct pcd_unit *cd, char *id)\r\n{\r\nint k, s;\r\nchar id_cmd[12] = { 0x12, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0 };\r\npcd_bufblk = -1;\r\ns = pcd_atapi(cd, id_cmd, 36, pcd_buffer, "identify");\r\nif (s)\r\nreturn -1;\r\nif ((pcd_buffer[0] & 0x1f) != 5) {\r\nif (verbose)\r\nprintk("%s: %s is not a CD-ROM\n",\r\ncd->name, cd->drive ? "Slave" : "Master");\r\nreturn -1;\r\n}\r\nmemcpy(id, pcd_buffer + 16, 16);\r\nid[16] = 0;\r\nk = 16;\r\nwhile ((k >= 0) && (id[k] <= 0x20)) {\r\nid[k] = 0;\r\nk--;\r\n}\r\nprintk("%s: %s: %s\n", cd->name, cd->drive ? "Slave" : "Master", id);\r\nreturn 0;\r\n}\r\nstatic int pcd_probe(struct pcd_unit *cd, int ms, char *id)\r\n{\r\nif (ms == -1) {\r\nfor (cd->drive = 0; cd->drive <= 1; cd->drive++)\r\nif (!pcd_reset(cd) && !pcd_identify(cd, id))\r\nreturn 0;\r\n} else {\r\ncd->drive = ms;\r\nif (!pcd_reset(cd) && !pcd_identify(cd, id))\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic void pcd_probe_capabilities(void)\r\n{\r\nint unit, r;\r\nchar buffer[32];\r\nchar cmd[12] = { 0x5a, 1 << 3, 0x2a, 0, 0, 0, 0, 18, 0, 0, 0, 0 };\r\nstruct pcd_unit *cd;\r\nfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\r\nif (!cd->present)\r\ncontinue;\r\nr = pcd_atapi(cd, cmd, 18, buffer, "mode sense capabilities");\r\nif (r)\r\ncontinue;\r\nif ((buffer[11] & 1) == 0)\r\ncd->info.mask |= CDC_CD_R;\r\nif ((buffer[11] & 2) == 0)\r\ncd->info.mask |= CDC_CD_RW;\r\nif ((buffer[12] & 1) == 0)\r\ncd->info.mask |= CDC_PLAY_AUDIO;\r\nif ((buffer[14] & 1) == 0)\r\ncd->info.mask |= CDC_LOCK;\r\nif ((buffer[14] & 8) == 0)\r\ncd->info.mask |= CDC_OPEN_TRAY;\r\nif ((buffer[14] >> 6) == 0)\r\ncd->info.mask |= CDC_CLOSE_TRAY;\r\n}\r\n}\r\nstatic int pcd_detect(void)\r\n{\r\nchar id[18];\r\nint k, unit;\r\nstruct pcd_unit *cd;\r\nprintk("%s: %s version %s, major %d, nice %d\n",\r\nname, name, PCD_VERSION, major, nice);\r\nk = 0;\r\nif (pcd_drive_count == 0) {\r\ncd = pcd;\r\nif (pi_init(cd->pi, 1, -1, -1, -1, -1, -1, pcd_buffer,\r\nPI_PCD, verbose, cd->name)) {\r\nif (!pcd_probe(cd, -1, id) && cd->disk) {\r\ncd->present = 1;\r\nk++;\r\n} else\r\npi_release(cd->pi);\r\n}\r\n} else {\r\nfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\r\nint *conf = *drives[unit];\r\nif (!conf[D_PRT])\r\ncontinue;\r\nif (!pi_init(cd->pi, 0, conf[D_PRT], conf[D_MOD],\r\nconf[D_UNI], conf[D_PRO], conf[D_DLY],\r\npcd_buffer, PI_PCD, verbose, cd->name))\r\ncontinue;\r\nif (!pcd_probe(cd, conf[D_SLV], id) && cd->disk) {\r\ncd->present = 1;\r\nk++;\r\n} else\r\npi_release(cd->pi);\r\n}\r\n}\r\nif (k)\r\nreturn 0;\r\nprintk("%s: No CD-ROM drive found\n", name);\r\nfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\r\nput_disk(cd->disk);\r\nreturn -1;\r\n}\r\nstatic void do_pcd_request(struct request_queue * q)\r\n{\r\nif (pcd_busy)\r\nreturn;\r\nwhile (1) {\r\nif (!pcd_req) {\r\npcd_req = blk_fetch_request(q);\r\nif (!pcd_req)\r\nreturn;\r\n}\r\nif (rq_data_dir(pcd_req) == READ) {\r\nstruct pcd_unit *cd = pcd_req->rq_disk->private_data;\r\nif (cd != pcd_current)\r\npcd_bufblk = -1;\r\npcd_current = cd;\r\npcd_sector = blk_rq_pos(pcd_req);\r\npcd_count = blk_rq_cur_sectors(pcd_req);\r\npcd_buf = pcd_req->buffer;\r\npcd_busy = 1;\r\nps_set_intr(do_pcd_read, NULL, 0, nice);\r\nreturn;\r\n} else {\r\n__blk_end_request_all(pcd_req, -EIO);\r\npcd_req = NULL;\r\n}\r\n}\r\n}\r\nstatic inline void next_request(int err)\r\n{\r\nunsigned long saved_flags;\r\nspin_lock_irqsave(&pcd_lock, saved_flags);\r\nif (!__blk_end_request_cur(pcd_req, err))\r\npcd_req = NULL;\r\npcd_busy = 0;\r\ndo_pcd_request(pcd_queue);\r\nspin_unlock_irqrestore(&pcd_lock, saved_flags);\r\n}\r\nstatic int pcd_ready(void)\r\n{\r\nreturn (((status_reg(pcd_current) & (IDE_BUSY | IDE_DRQ)) == IDE_DRQ));\r\n}\r\nstatic void pcd_transfer(void)\r\n{\r\nwhile (pcd_count && (pcd_sector / 4 == pcd_bufblk)) {\r\nint o = (pcd_sector % 4) * 512;\r\nmemcpy(pcd_buf, pcd_buffer + o, 512);\r\npcd_count--;\r\npcd_buf += 512;\r\npcd_sector++;\r\n}\r\n}\r\nstatic void pcd_start(void)\r\n{\r\nint b, i;\r\nchar rd_cmd[12] = { 0xa8, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 };\r\npcd_bufblk = pcd_sector / 4;\r\nb = pcd_bufblk;\r\nfor (i = 0; i < 4; i++) {\r\nrd_cmd[5 - i] = b & 0xff;\r\nb = b >> 8;\r\n}\r\nif (pcd_command(pcd_current, rd_cmd, 2048, "read block")) {\r\npcd_bufblk = -1;\r\nnext_request(-EIO);\r\nreturn;\r\n}\r\nmdelay(1);\r\nps_set_intr(do_pcd_read_drq, pcd_ready, PCD_TMO, nice);\r\n}\r\nstatic void do_pcd_read(void)\r\n{\r\npcd_busy = 1;\r\npcd_retries = 0;\r\npcd_transfer();\r\nif (!pcd_count) {\r\nnext_request(0);\r\nreturn;\r\n}\r\npi_do_claimed(pcd_current->pi, pcd_start);\r\n}\r\nstatic void do_pcd_read_drq(void)\r\n{\r\nunsigned long saved_flags;\r\nif (pcd_completion(pcd_current, pcd_buffer, "read block")) {\r\nif (pcd_retries < PCD_RETRIES) {\r\nmdelay(1);\r\npcd_retries++;\r\npi_do_claimed(pcd_current->pi, pcd_start);\r\nreturn;\r\n}\r\npcd_bufblk = -1;\r\nnext_request(-EIO);\r\nreturn;\r\n}\r\ndo_pcd_read();\r\nspin_lock_irqsave(&pcd_lock, saved_flags);\r\ndo_pcd_request(pcd_queue);\r\nspin_unlock_irqrestore(&pcd_lock, saved_flags);\r\n}\r\nstatic int pcd_audio_ioctl(struct cdrom_device_info *cdi, unsigned int cmd, void *arg)\r\n{\r\nstruct pcd_unit *cd = cdi->handle;\r\nswitch (cmd) {\r\ncase CDROMREADTOCHDR:\r\n{\r\nchar cmd[12] =\r\n{ GPCMD_READ_TOC_PMA_ATIP, 0, 0, 0, 0, 0, 0, 0, 12,\r\n0, 0, 0 };\r\nstruct cdrom_tochdr *tochdr =\r\n(struct cdrom_tochdr *) arg;\r\nchar buffer[32];\r\nint r;\r\nr = pcd_atapi(cd, cmd, 12, buffer, "read toc header");\r\ntochdr->cdth_trk0 = buffer[2];\r\ntochdr->cdth_trk1 = buffer[3];\r\nreturn r ? -EIO : 0;\r\n}\r\ncase CDROMREADTOCENTRY:\r\n{\r\nchar cmd[12] =\r\n{ GPCMD_READ_TOC_PMA_ATIP, 0, 0, 0, 0, 0, 0, 0, 12,\r\n0, 0, 0 };\r\nstruct cdrom_tocentry *tocentry =\r\n(struct cdrom_tocentry *) arg;\r\nunsigned char buffer[32];\r\nint r;\r\ncmd[1] =\r\n(tocentry->cdte_format == CDROM_MSF ? 0x02 : 0);\r\ncmd[6] = tocentry->cdte_track;\r\nr = pcd_atapi(cd, cmd, 12, buffer, "read toc entry");\r\ntocentry->cdte_ctrl = buffer[5] & 0xf;\r\ntocentry->cdte_adr = buffer[5] >> 4;\r\ntocentry->cdte_datamode =\r\n(tocentry->cdte_ctrl & 0x04) ? 1 : 0;\r\nif (tocentry->cdte_format == CDROM_MSF) {\r\ntocentry->cdte_addr.msf.minute = buffer[9];\r\ntocentry->cdte_addr.msf.second = buffer[10];\r\ntocentry->cdte_addr.msf.frame = buffer[11];\r\n} else\r\ntocentry->cdte_addr.lba =\r\n(((((buffer[8] << 8) + buffer[9]) << 8)\r\n+ buffer[10]) << 8) + buffer[11];\r\nreturn r ? -EIO : 0;\r\n}\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\n}\r\nstatic int pcd_get_mcn(struct cdrom_device_info *cdi, struct cdrom_mcn *mcn)\r\n{\r\nchar cmd[12] =\r\n{ GPCMD_READ_SUBCHANNEL, 0, 0x40, 2, 0, 0, 0, 0, 24, 0, 0, 0 };\r\nchar buffer[32];\r\nif (pcd_atapi(cdi->handle, cmd, 24, buffer, "get mcn"))\r\nreturn -EIO;\r\nmemcpy(mcn->medium_catalog_number, buffer + 9, 13);\r\nmcn->medium_catalog_number[13] = 0;\r\nreturn 0;\r\n}\r\nstatic int __init pcd_init(void)\r\n{\r\nstruct pcd_unit *cd;\r\nint unit;\r\nif (disable)\r\nreturn -EINVAL;\r\npcd_init_units();\r\nif (pcd_detect())\r\nreturn -ENODEV;\r\npcd_probe_capabilities();\r\nif (register_blkdev(major, name)) {\r\nfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\r\nput_disk(cd->disk);\r\nreturn -EBUSY;\r\n}\r\npcd_queue = blk_init_queue(do_pcd_request, &pcd_lock);\r\nif (!pcd_queue) {\r\nunregister_blkdev(major, name);\r\nfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\r\nput_disk(cd->disk);\r\nreturn -ENOMEM;\r\n}\r\nfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\r\nif (cd->present) {\r\nregister_cdrom(&cd->info);\r\ncd->disk->private_data = cd;\r\ncd->disk->queue = pcd_queue;\r\nadd_disk(cd->disk);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit pcd_exit(void)\r\n{\r\nstruct pcd_unit *cd;\r\nint unit;\r\nfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\r\nif (cd->present) {\r\ndel_gendisk(cd->disk);\r\npi_release(cd->pi);\r\nunregister_cdrom(&cd->info);\r\n}\r\nput_disk(cd->disk);\r\n}\r\nblk_cleanup_queue(pcd_queue);\r\nunregister_blkdev(major, name);\r\n}
