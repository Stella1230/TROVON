static int s3c2443_setparent_hsmmc(struct clk *clk, struct clk *parent)\r\n{\r\nunsigned long clksrc = __raw_readl(S3C2443_SCLKCON);\r\nclksrc &= ~(S3C2443_SCLKCON_HSMMCCLK_EXT |\r\nS3C2443_SCLKCON_HSMMCCLK_EPLL);\r\nif (parent == &clk_epll)\r\nclksrc |= S3C2443_SCLKCON_HSMMCCLK_EPLL;\r\nelse if (parent == &clk_ext)\r\nclksrc |= S3C2443_SCLKCON_HSMMCCLK_EXT;\r\nelse\r\nreturn -EINVAL;\r\nif (clk->usage > 0) {\r\n__raw_writel(clksrc, S3C2443_SCLKCON);\r\n}\r\nclk->parent = parent;\r\nreturn 0;\r\n}\r\nstatic int s3c2443_enable_hsmmc(struct clk *clk, int enable)\r\n{\r\nreturn s3c2443_setparent_hsmmc(clk, clk->parent);\r\n}\r\nvoid __init s3c2443_init_clocks(int xtal)\r\n{\r\nunsigned long epllcon = __raw_readl(S3C2443_EPLLCON);\r\nint ptr;\r\nclk_epll.rate = s3c2443_get_epll(epllcon, xtal);\r\nclk_epll.parent = &clk_epllref.clk;\r\ns3c2443_common_init_clocks(xtal, s3c2443_get_mpll,\r\narmdiv, ARRAY_SIZE(armdiv),\r\nS3C2443_CLKDIV0_ARMDIV_MASK);\r\ns3c24xx_register_clocks(clks, ARRAY_SIZE(clks));\r\nfor (ptr = 0; ptr < ARRAY_SIZE(clksrcs); ptr++)\r\ns3c_register_clksrc(clksrcs[ptr], 1);\r\ns3c_register_clocks(init_clocks_off, ARRAY_SIZE(init_clocks_off));\r\ns3c_disable_clocks(init_clocks_off, ARRAY_SIZE(init_clocks_off));\r\nclkdev_add_table(s3c2443_clk_lookup, ARRAY_SIZE(s3c2443_clk_lookup));\r\n}
