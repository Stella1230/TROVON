static int omap_hdmi_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct hdmi_priv *priv = snd_soc_dai_get_drvdata(dai);\r\nint err;\r\nerr = snd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES, 128);\r\nif (err < 0) {\r\ndev_err(dai->dev, "could not apply constraint\n");\r\nreturn err;\r\n}\r\nif (!priv->dssdev->driver->audio_supported(priv->dssdev)) {\r\ndev_err(dai->dev, "audio not supported\n");\r\nreturn -ENODEV;\r\n}\r\nsnd_soc_dai_set_dma_data(dai, substream, &priv->dma_data);\r\nreturn 0;\r\n}\r\nstatic int omap_hdmi_dai_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct hdmi_priv *priv = snd_soc_dai_get_drvdata(dai);\r\nreturn priv->dssdev->driver->audio_enable(priv->dssdev);\r\n}\r\nstatic int omap_hdmi_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct hdmi_priv *priv = snd_soc_dai_get_drvdata(dai);\r\nstruct snd_aes_iec958 *iec = &priv->iec;\r\nstruct snd_cea_861_aud_if *cea = &priv->cea;\r\nint err = 0;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\npriv->dma_data.maxburst = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\npriv->dma_data.maxburst = 32;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "format not supported!\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(iec->status, 0, sizeof(iec->status));\r\niec->status[0] &= ~IEC958_AES0_PROFESSIONAL;\r\niec->status[0] &= ~IEC958_AES0_NONAUDIO;\r\niec->status[0] |= IEC958_AES0_CON_NOT_COPYRIGHT;\r\niec->status[0] |= IEC958_AES0_CON_EMPHASIS_NONE;\r\niec->status[0] |= IEC958_AES1_PRO_MODE_NOTID;\r\niec->status[1] = IEC958_AES1_CON_GENERAL;\r\niec->status[2] |= IEC958_AES2_CON_SOURCE_UNSPEC;\r\niec->status[2] |= IEC958_AES2_CON_CHANNEL_UNSPEC;\r\nswitch (params_rate(params)) {\r\ncase 32000:\r\niec->status[3] |= IEC958_AES3_CON_FS_32000;\r\nbreak;\r\ncase 44100:\r\niec->status[3] |= IEC958_AES3_CON_FS_44100;\r\nbreak;\r\ncase 48000:\r\niec->status[3] |= IEC958_AES3_CON_FS_48000;\r\nbreak;\r\ncase 88200:\r\niec->status[3] |= IEC958_AES3_CON_FS_88200;\r\nbreak;\r\ncase 96000:\r\niec->status[3] |= IEC958_AES3_CON_FS_96000;\r\nbreak;\r\ncase 176400:\r\niec->status[3] |= IEC958_AES3_CON_FS_176400;\r\nbreak;\r\ncase 192000:\r\niec->status[3] |= IEC958_AES3_CON_FS_192000;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "rate not supported!\n");\r\nreturn -EINVAL;\r\n}\r\niec->status[3] |= IEC958_AES3_CON_CLOCK_1000PPM;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\niec->status[4] |= IEC958_AES4_CON_WORDLEN_20_16;\r\niec->status[4] &= ~IEC958_AES4_CON_MAX_WORDLEN_24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\niec->status[4] |= IEC958_AES4_CON_WORDLEN_24_20;\r\niec->status[4] |= IEC958_AES4_CON_MAX_WORDLEN_24;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "format not supported!\n");\r\nreturn -EINVAL;\r\n}\r\ncea->db1_ct_cc = (params_channels(params) - 1)\r\n& CEA861_AUDIO_INFOFRAME_DB1CC;\r\ncea->db1_ct_cc |= CEA861_AUDIO_INFOFRAME_DB1CT_FROM_STREAM;\r\ncea->db2_sf_ss = CEA861_AUDIO_INFOFRAME_DB2SF_FROM_STREAM;\r\ncea->db2_sf_ss |= CEA861_AUDIO_INFOFRAME_DB2SS_FROM_STREAM;\r\ncea->db3 = 0;\r\nif (params_channels(params) == 2)\r\ncea->db4_ca = 0x0;\r\nelse\r\ncea->db4_ca = 0x13;\r\ncea->db5_dminh_lsv = CEA861_AUDIO_INFOFRAME_DB5_DM_INH_PROHIBITED;\r\ncea->db5_dminh_lsv |= (0 & CEA861_AUDIO_INFOFRAME_DB5_LSV);\r\npriv->dss_audio.iec = iec;\r\npriv->dss_audio.cea = cea;\r\nerr = priv->dssdev->driver->audio_config(priv->dssdev,\r\n&priv->dss_audio);\r\nreturn err;\r\n}\r\nstatic int omap_hdmi_dai_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct hdmi_priv *priv = snd_soc_dai_get_drvdata(dai);\r\nint err = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nerr = priv->dssdev->driver->audio_start(priv->dssdev);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\npriv->dssdev->driver->audio_stop(priv->dssdev);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic void omap_hdmi_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct hdmi_priv *priv = snd_soc_dai_get_drvdata(dai);\r\npriv->dssdev->driver->audio_disable(priv->dssdev);\r\n}\r\nstatic int omap_hdmi_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct resource *hdmi_rsrc;\r\nstruct hdmi_priv *hdmi_data;\r\nbool hdmi_dev_found = false;\r\nhdmi_data = devm_kzalloc(&pdev->dev, sizeof(*hdmi_data), GFP_KERNEL);\r\nif (hdmi_data == NULL) {\r\ndev_err(&pdev->dev, "Cannot allocate memory for HDMI data\n");\r\nreturn -ENOMEM;\r\n}\r\nhdmi_rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!hdmi_rsrc) {\r\ndev_err(&pdev->dev, "Cannot obtain IORESOURCE_MEM HDMI\n");\r\nreturn -ENODEV;\r\n}\r\nhdmi_data->dma_data.addr = hdmi_rsrc->start + OMAP_HDMI_AUDIO_DMA_PORT;\r\nhdmi_rsrc = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!hdmi_rsrc) {\r\ndev_err(&pdev->dev, "Cannot obtain IORESOURCE_DMA HDMI\n");\r\nreturn -ENODEV;\r\n}\r\nhdmi_data->dma_req = hdmi_rsrc->start;\r\nhdmi_data->dma_data.filter_data = &hdmi_data->dma_req;\r\nhdmi_data->dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nfor_each_dss_dev(hdmi_data->dssdev) {\r\nomap_dss_get_device(hdmi_data->dssdev);\r\nif (!hdmi_data->dssdev->driver) {\r\nomap_dss_put_device(hdmi_data->dssdev);\r\ncontinue;\r\n}\r\nif (hdmi_data->dssdev->type == OMAP_DISPLAY_TYPE_HDMI) {\r\nhdmi_dev_found = true;\r\nbreak;\r\n}\r\n}\r\nif (!hdmi_dev_found) {\r\ndev_err(&pdev->dev, "no driver for HDMI display found\n");\r\nreturn -ENODEV;\r\n}\r\ndev_set_drvdata(&pdev->dev, hdmi_data);\r\nret = snd_soc_register_component(&pdev->dev, &omap_hdmi_component,\r\n&omap_hdmi_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int omap_hdmi_remove(struct platform_device *pdev)\r\n{\r\nstruct hdmi_priv *hdmi_data = dev_get_drvdata(&pdev->dev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nif (hdmi_data == NULL) {\r\ndev_err(&pdev->dev, "cannot obtain HDMi data\n");\r\nreturn -ENODEV;\r\n}\r\nomap_dss_put_device(hdmi_data->dssdev);\r\nreturn 0;\r\n}
