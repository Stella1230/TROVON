static inline int route4_fastmap_hash(u32 id, int iif)\r\n{\r\nreturn id & 0xF;\r\n}\r\nstatic void\r\nroute4_reset_fastmap(struct Qdisc *q, struct route4_head *head, u32 id)\r\n{\r\nspinlock_t *root_lock = qdisc_root_sleeping_lock(q);\r\nspin_lock_bh(root_lock);\r\nmemset(head->fastmap, 0, sizeof(head->fastmap));\r\nspin_unlock_bh(root_lock);\r\n}\r\nstatic void\r\nroute4_set_fastmap(struct route4_head *head, u32 id, int iif,\r\nstruct route4_filter *f)\r\n{\r\nint h = route4_fastmap_hash(id, iif);\r\nhead->fastmap[h].id = id;\r\nhead->fastmap[h].iif = iif;\r\nhead->fastmap[h].filter = f;\r\n}\r\nstatic inline int route4_hash_to(u32 id)\r\n{\r\nreturn id & 0xFF;\r\n}\r\nstatic inline int route4_hash_from(u32 id)\r\n{\r\nreturn (id >> 16) & 0xF;\r\n}\r\nstatic inline int route4_hash_iif(int iif)\r\n{\r\nreturn 16 + ((iif >> 16) & 0xF);\r\n}\r\nstatic inline int route4_hash_wild(void)\r\n{\r\nreturn 32;\r\n}\r\nstatic int route4_classify(struct sk_buff *skb, const struct tcf_proto *tp,\r\nstruct tcf_result *res)\r\n{\r\nstruct route4_head *head = tp->root;\r\nstruct dst_entry *dst;\r\nstruct route4_bucket *b;\r\nstruct route4_filter *f;\r\nu32 id, h;\r\nint iif, dont_cache = 0;\r\ndst = skb_dst(skb);\r\nif (!dst)\r\ngoto failure;\r\nid = dst->tclassid;\r\nif (head == NULL)\r\ngoto old_method;\r\niif = inet_iif(skb);\r\nh = route4_fastmap_hash(id, iif);\r\nif (id == head->fastmap[h].id &&\r\niif == head->fastmap[h].iif &&\r\n(f = head->fastmap[h].filter) != NULL) {\r\nif (f == ROUTE4_FAILURE)\r\ngoto failure;\r\n*res = f->res;\r\nreturn 0;\r\n}\r\nh = route4_hash_to(id);\r\nrestart:\r\nb = head->table[h];\r\nif (b) {\r\nfor (f = b->ht[route4_hash_from(id)]; f; f = f->next)\r\nif (f->id == id)\r\nROUTE4_APPLY_RESULT();\r\nfor (f = b->ht[route4_hash_iif(iif)]; f; f = f->next)\r\nif (f->iif == iif)\r\nROUTE4_APPLY_RESULT();\r\nfor (f = b->ht[route4_hash_wild()]; f; f = f->next)\r\nROUTE4_APPLY_RESULT();\r\n}\r\nif (h < 256) {\r\nh = 256;\r\nid &= ~0xFFFF;\r\ngoto restart;\r\n}\r\nif (!dont_cache)\r\nroute4_set_fastmap(head, id, iif, ROUTE4_FAILURE);\r\nfailure:\r\nreturn -1;\r\nold_method:\r\nif (id && (TC_H_MAJ(id) == 0 ||\r\n!(TC_H_MAJ(id^tp->q->handle)))) {\r\nres->classid = id;\r\nres->class = 0;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic inline u32 to_hash(u32 id)\r\n{\r\nu32 h = id & 0xFF;\r\nif (id & 0x8000)\r\nh += 256;\r\nreturn h;\r\n}\r\nstatic inline u32 from_hash(u32 id)\r\n{\r\nid &= 0xFFFF;\r\nif (id == 0xFFFF)\r\nreturn 32;\r\nif (!(id & 0x8000)) {\r\nif (id > 255)\r\nreturn 256;\r\nreturn id & 0xF;\r\n}\r\nreturn 16 + (id & 0xF);\r\n}\r\nstatic unsigned long route4_get(struct tcf_proto *tp, u32 handle)\r\n{\r\nstruct route4_head *head = tp->root;\r\nstruct route4_bucket *b;\r\nstruct route4_filter *f;\r\nunsigned int h1, h2;\r\nif (!head)\r\nreturn 0;\r\nh1 = to_hash(handle);\r\nif (h1 > 256)\r\nreturn 0;\r\nh2 = from_hash(handle >> 16);\r\nif (h2 > 32)\r\nreturn 0;\r\nb = head->table[h1];\r\nif (b) {\r\nfor (f = b->ht[h2]; f; f = f->next)\r\nif (f->handle == handle)\r\nreturn (unsigned long)f;\r\n}\r\nreturn 0;\r\n}\r\nstatic void route4_put(struct tcf_proto *tp, unsigned long f)\r\n{\r\n}\r\nstatic int route4_init(struct tcf_proto *tp)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nroute4_delete_filter(struct tcf_proto *tp, struct route4_filter *f)\r\n{\r\ntcf_unbind_filter(tp, &f->res);\r\ntcf_exts_destroy(tp, &f->exts);\r\nkfree(f);\r\n}\r\nstatic void route4_destroy(struct tcf_proto *tp)\r\n{\r\nstruct route4_head *head = tp->root;\r\nint h1, h2;\r\nif (head == NULL)\r\nreturn;\r\nfor (h1 = 0; h1 <= 256; h1++) {\r\nstruct route4_bucket *b;\r\nb = head->table[h1];\r\nif (b) {\r\nfor (h2 = 0; h2 <= 32; h2++) {\r\nstruct route4_filter *f;\r\nwhile ((f = b->ht[h2]) != NULL) {\r\nb->ht[h2] = f->next;\r\nroute4_delete_filter(tp, f);\r\n}\r\n}\r\nkfree(b);\r\n}\r\n}\r\nkfree(head);\r\n}\r\nstatic int route4_delete(struct tcf_proto *tp, unsigned long arg)\r\n{\r\nstruct route4_head *head = tp->root;\r\nstruct route4_filter **fp, *f = (struct route4_filter *)arg;\r\nunsigned int h = 0;\r\nstruct route4_bucket *b;\r\nint i;\r\nif (!head || !f)\r\nreturn -EINVAL;\r\nh = f->handle;\r\nb = f->bkt;\r\nfor (fp = &b->ht[from_hash(h >> 16)]; *fp; fp = &(*fp)->next) {\r\nif (*fp == f) {\r\ntcf_tree_lock(tp);\r\n*fp = f->next;\r\ntcf_tree_unlock(tp);\r\nroute4_reset_fastmap(tp->q, head, f->id);\r\nroute4_delete_filter(tp, f);\r\nfor (i = 0; i <= 32; i++)\r\nif (b->ht[i])\r\nreturn 0;\r\ntcf_tree_lock(tp);\r\nhead->table[to_hash(h)] = NULL;\r\ntcf_tree_unlock(tp);\r\nkfree(b);\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int route4_set_parms(struct net *net, struct tcf_proto *tp,\r\nunsigned long base, struct route4_filter *f,\r\nu32 handle, struct route4_head *head,\r\nstruct nlattr **tb, struct nlattr *est, int new)\r\n{\r\nint err;\r\nu32 id = 0, to = 0, nhandle = 0x8000;\r\nstruct route4_filter *fp;\r\nunsigned int h1;\r\nstruct route4_bucket *b;\r\nstruct tcf_exts e;\r\ntcf_exts_init(&e, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);\r\nerr = tcf_exts_validate(net, tp, tb, est, &e);\r\nif (err < 0)\r\nreturn err;\r\nerr = -EINVAL;\r\nif (tb[TCA_ROUTE4_TO]) {\r\nif (new && handle & 0x8000)\r\ngoto errout;\r\nto = nla_get_u32(tb[TCA_ROUTE4_TO]);\r\nif (to > 0xFF)\r\ngoto errout;\r\nnhandle = to;\r\n}\r\nif (tb[TCA_ROUTE4_FROM]) {\r\nif (tb[TCA_ROUTE4_IIF])\r\ngoto errout;\r\nid = nla_get_u32(tb[TCA_ROUTE4_FROM]);\r\nif (id > 0xFF)\r\ngoto errout;\r\nnhandle |= id << 16;\r\n} else if (tb[TCA_ROUTE4_IIF]) {\r\nid = nla_get_u32(tb[TCA_ROUTE4_IIF]);\r\nif (id > 0x7FFF)\r\ngoto errout;\r\nnhandle |= (id | 0x8000) << 16;\r\n} else\r\nnhandle |= 0xFFFF << 16;\r\nif (handle && new) {\r\nnhandle |= handle & 0x7F00;\r\nif (nhandle != handle)\r\ngoto errout;\r\n}\r\nh1 = to_hash(nhandle);\r\nb = head->table[h1];\r\nif (!b) {\r\nerr = -ENOBUFS;\r\nb = kzalloc(sizeof(struct route4_bucket), GFP_KERNEL);\r\nif (b == NULL)\r\ngoto errout;\r\ntcf_tree_lock(tp);\r\nhead->table[h1] = b;\r\ntcf_tree_unlock(tp);\r\n} else {\r\nunsigned int h2 = from_hash(nhandle >> 16);\r\nerr = -EEXIST;\r\nfor (fp = b->ht[h2]; fp; fp = fp->next)\r\nif (fp->handle == f->handle)\r\ngoto errout;\r\n}\r\ntcf_tree_lock(tp);\r\nif (tb[TCA_ROUTE4_TO])\r\nf->id = to;\r\nif (tb[TCA_ROUTE4_FROM])\r\nf->id = to | id<<16;\r\nelse if (tb[TCA_ROUTE4_IIF])\r\nf->iif = id;\r\nf->handle = nhandle;\r\nf->bkt = b;\r\ntcf_tree_unlock(tp);\r\nif (tb[TCA_ROUTE4_CLASSID]) {\r\nf->res.classid = nla_get_u32(tb[TCA_ROUTE4_CLASSID]);\r\ntcf_bind_filter(tp, &f->res, base);\r\n}\r\ntcf_exts_change(tp, &f->exts, &e);\r\nreturn 0;\r\nerrout:\r\ntcf_exts_destroy(tp, &e);\r\nreturn err;\r\n}\r\nstatic int route4_change(struct net *net, struct sk_buff *in_skb,\r\nstruct tcf_proto *tp, unsigned long base,\r\nu32 handle,\r\nstruct nlattr **tca,\r\nunsigned long *arg)\r\n{\r\nstruct route4_head *head = tp->root;\r\nstruct route4_filter *f, *f1, **fp;\r\nstruct route4_bucket *b;\r\nstruct nlattr *opt = tca[TCA_OPTIONS];\r\nstruct nlattr *tb[TCA_ROUTE4_MAX + 1];\r\nunsigned int h, th;\r\nu32 old_handle = 0;\r\nint err;\r\nif (opt == NULL)\r\nreturn handle ? -EINVAL : 0;\r\nerr = nla_parse_nested(tb, TCA_ROUTE4_MAX, opt, route4_policy);\r\nif (err < 0)\r\nreturn err;\r\nf = (struct route4_filter *)*arg;\r\nif (f) {\r\nif (f->handle != handle && handle)\r\nreturn -EINVAL;\r\nif (f->bkt)\r\nold_handle = f->handle;\r\nerr = route4_set_parms(net, tp, base, f, handle, head, tb,\r\ntca[TCA_RATE], 0);\r\nif (err < 0)\r\nreturn err;\r\ngoto reinsert;\r\n}\r\nerr = -ENOBUFS;\r\nif (head == NULL) {\r\nhead = kzalloc(sizeof(struct route4_head), GFP_KERNEL);\r\nif (head == NULL)\r\ngoto errout;\r\ntcf_tree_lock(tp);\r\ntp->root = head;\r\ntcf_tree_unlock(tp);\r\n}\r\nf = kzalloc(sizeof(struct route4_filter), GFP_KERNEL);\r\nif (f == NULL)\r\ngoto errout;\r\ntcf_exts_init(&f->exts, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);\r\nerr = route4_set_parms(net, tp, base, f, handle, head, tb,\r\ntca[TCA_RATE], 1);\r\nif (err < 0)\r\ngoto errout;\r\nreinsert:\r\nh = from_hash(f->handle >> 16);\r\nfor (fp = &f->bkt->ht[h]; (f1 = *fp) != NULL; fp = &f1->next)\r\nif (f->handle < f1->handle)\r\nbreak;\r\nf->next = f1;\r\ntcf_tree_lock(tp);\r\n*fp = f;\r\nif (old_handle && f->handle != old_handle) {\r\nth = to_hash(old_handle);\r\nh = from_hash(old_handle >> 16);\r\nb = head->table[th];\r\nif (b) {\r\nfor (fp = &b->ht[h]; *fp; fp = &(*fp)->next) {\r\nif (*fp == f) {\r\n*fp = f->next;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\ntcf_tree_unlock(tp);\r\nroute4_reset_fastmap(tp->q, head, f->id);\r\n*arg = (unsigned long)f;\r\nreturn 0;\r\nerrout:\r\nkfree(f);\r\nreturn err;\r\n}\r\nstatic void route4_walk(struct tcf_proto *tp, struct tcf_walker *arg)\r\n{\r\nstruct route4_head *head = tp->root;\r\nunsigned int h, h1;\r\nif (head == NULL)\r\narg->stop = 1;\r\nif (arg->stop)\r\nreturn;\r\nfor (h = 0; h <= 256; h++) {\r\nstruct route4_bucket *b = head->table[h];\r\nif (b) {\r\nfor (h1 = 0; h1 <= 32; h1++) {\r\nstruct route4_filter *f;\r\nfor (f = b->ht[h1]; f; f = f->next) {\r\nif (arg->count < arg->skip) {\r\narg->count++;\r\ncontinue;\r\n}\r\nif (arg->fn(tp, (unsigned long)f, arg) < 0) {\r\narg->stop = 1;\r\nreturn;\r\n}\r\narg->count++;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int route4_dump(struct net *net, struct tcf_proto *tp, unsigned long fh,\r\nstruct sk_buff *skb, struct tcmsg *t)\r\n{\r\nstruct route4_filter *f = (struct route4_filter *)fh;\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct nlattr *nest;\r\nu32 id;\r\nif (f == NULL)\r\nreturn skb->len;\r\nt->tcm_handle = f->handle;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (!(f->handle & 0x8000)) {\r\nid = f->id & 0xFF;\r\nif (nla_put_u32(skb, TCA_ROUTE4_TO, id))\r\ngoto nla_put_failure;\r\n}\r\nif (f->handle & 0x80000000) {\r\nif ((f->handle >> 16) != 0xFFFF &&\r\nnla_put_u32(skb, TCA_ROUTE4_IIF, f->iif))\r\ngoto nla_put_failure;\r\n} else {\r\nid = f->id >> 16;\r\nif (nla_put_u32(skb, TCA_ROUTE4_FROM, id))\r\ngoto nla_put_failure;\r\n}\r\nif (f->res.classid &&\r\nnla_put_u32(skb, TCA_ROUTE4_CLASSID, f->res.classid))\r\ngoto nla_put_failure;\r\nif (tcf_exts_dump(skb, &f->exts) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nif (tcf_exts_dump_stats(skb, &f->exts) < 0)\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int __init init_route4(void)\r\n{\r\nreturn register_tcf_proto_ops(&cls_route4_ops);\r\n}\r\nstatic void __exit exit_route4(void)\r\n{\r\nunregister_tcf_proto_ops(&cls_route4_ops);\r\n}
