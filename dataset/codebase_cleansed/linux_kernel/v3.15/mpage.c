static void mpage_end_io(struct bio *bio, int err)\r\n{\r\nstruct bio_vec *bv;\r\nint i;\r\nbio_for_each_segment_all(bv, bio, i) {\r\nstruct page *page = bv->bv_page;\r\nif (bio_data_dir(bio) == READ) {\r\nif (!err) {\r\nSetPageUptodate(page);\r\n} else {\r\nClearPageUptodate(page);\r\nSetPageError(page);\r\n}\r\nunlock_page(page);\r\n} else {\r\nif (err) {\r\nSetPageError(page);\r\nif (page->mapping)\r\nset_bit(AS_EIO, &page->mapping->flags);\r\n}\r\nend_page_writeback(page);\r\n}\r\n}\r\nbio_put(bio);\r\n}\r\nstatic struct bio *mpage_bio_submit(int rw, struct bio *bio)\r\n{\r\nbio->bi_end_io = mpage_end_io;\r\nsubmit_bio(rw, bio);\r\nreturn NULL;\r\n}\r\nstatic struct bio *\r\nmpage_alloc(struct block_device *bdev,\r\nsector_t first_sector, int nr_vecs,\r\ngfp_t gfp_flags)\r\n{\r\nstruct bio *bio;\r\nbio = bio_alloc(gfp_flags, nr_vecs);\r\nif (bio == NULL && (current->flags & PF_MEMALLOC)) {\r\nwhile (!bio && (nr_vecs /= 2))\r\nbio = bio_alloc(gfp_flags, nr_vecs);\r\n}\r\nif (bio) {\r\nbio->bi_bdev = bdev;\r\nbio->bi_iter.bi_sector = first_sector;\r\n}\r\nreturn bio;\r\n}\r\nstatic void\r\nmap_buffer_to_page(struct page *page, struct buffer_head *bh, int page_block)\r\n{\r\nstruct inode *inode = page->mapping->host;\r\nstruct buffer_head *page_bh, *head;\r\nint block = 0;\r\nif (!page_has_buffers(page)) {\r\nif (inode->i_blkbits == PAGE_CACHE_SHIFT &&\r\nbuffer_uptodate(bh)) {\r\nSetPageUptodate(page);\r\nreturn;\r\n}\r\ncreate_empty_buffers(page, 1 << inode->i_blkbits, 0);\r\n}\r\nhead = page_buffers(page);\r\npage_bh = head;\r\ndo {\r\nif (block == page_block) {\r\npage_bh->b_state = bh->b_state;\r\npage_bh->b_bdev = bh->b_bdev;\r\npage_bh->b_blocknr = bh->b_blocknr;\r\nbreak;\r\n}\r\npage_bh = page_bh->b_this_page;\r\nblock++;\r\n} while (page_bh != head);\r\n}\r\nstatic struct bio *\r\ndo_mpage_readpage(struct bio *bio, struct page *page, unsigned nr_pages,\r\nsector_t *last_block_in_bio, struct buffer_head *map_bh,\r\nunsigned long *first_logical_block, get_block_t get_block)\r\n{\r\nstruct inode *inode = page->mapping->host;\r\nconst unsigned blkbits = inode->i_blkbits;\r\nconst unsigned blocks_per_page = PAGE_CACHE_SIZE >> blkbits;\r\nconst unsigned blocksize = 1 << blkbits;\r\nsector_t block_in_file;\r\nsector_t last_block;\r\nsector_t last_block_in_file;\r\nsector_t blocks[MAX_BUF_PER_PAGE];\r\nunsigned page_block;\r\nunsigned first_hole = blocks_per_page;\r\nstruct block_device *bdev = NULL;\r\nint length;\r\nint fully_mapped = 1;\r\nunsigned nblocks;\r\nunsigned relative_block;\r\nif (page_has_buffers(page))\r\ngoto confused;\r\nblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\r\nlast_block = block_in_file + nr_pages * blocks_per_page;\r\nlast_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;\r\nif (last_block > last_block_in_file)\r\nlast_block = last_block_in_file;\r\npage_block = 0;\r\nnblocks = map_bh->b_size >> blkbits;\r\nif (buffer_mapped(map_bh) && block_in_file > *first_logical_block &&\r\nblock_in_file < (*first_logical_block + nblocks)) {\r\nunsigned map_offset = block_in_file - *first_logical_block;\r\nunsigned last = nblocks - map_offset;\r\nfor (relative_block = 0; ; relative_block++) {\r\nif (relative_block == last) {\r\nclear_buffer_mapped(map_bh);\r\nbreak;\r\n}\r\nif (page_block == blocks_per_page)\r\nbreak;\r\nblocks[page_block] = map_bh->b_blocknr + map_offset +\r\nrelative_block;\r\npage_block++;\r\nblock_in_file++;\r\n}\r\nbdev = map_bh->b_bdev;\r\n}\r\nmap_bh->b_page = page;\r\nwhile (page_block < blocks_per_page) {\r\nmap_bh->b_state = 0;\r\nmap_bh->b_size = 0;\r\nif (block_in_file < last_block) {\r\nmap_bh->b_size = (last_block-block_in_file) << blkbits;\r\nif (get_block(inode, block_in_file, map_bh, 0))\r\ngoto confused;\r\n*first_logical_block = block_in_file;\r\n}\r\nif (!buffer_mapped(map_bh)) {\r\nfully_mapped = 0;\r\nif (first_hole == blocks_per_page)\r\nfirst_hole = page_block;\r\npage_block++;\r\nblock_in_file++;\r\ncontinue;\r\n}\r\nif (buffer_uptodate(map_bh)) {\r\nmap_buffer_to_page(page, map_bh, page_block);\r\ngoto confused;\r\n}\r\nif (first_hole != blocks_per_page)\r\ngoto confused;\r\nif (page_block && blocks[page_block-1] != map_bh->b_blocknr-1)\r\ngoto confused;\r\nnblocks = map_bh->b_size >> blkbits;\r\nfor (relative_block = 0; ; relative_block++) {\r\nif (relative_block == nblocks) {\r\nclear_buffer_mapped(map_bh);\r\nbreak;\r\n} else if (page_block == blocks_per_page)\r\nbreak;\r\nblocks[page_block] = map_bh->b_blocknr+relative_block;\r\npage_block++;\r\nblock_in_file++;\r\n}\r\nbdev = map_bh->b_bdev;\r\n}\r\nif (first_hole != blocks_per_page) {\r\nzero_user_segment(page, first_hole << blkbits, PAGE_CACHE_SIZE);\r\nif (first_hole == 0) {\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\ngoto out;\r\n}\r\n} else if (fully_mapped) {\r\nSetPageMappedToDisk(page);\r\n}\r\nif (fully_mapped && blocks_per_page == 1 && !PageUptodate(page) &&\r\ncleancache_get_page(page) == 0) {\r\nSetPageUptodate(page);\r\ngoto confused;\r\n}\r\nif (bio && (*last_block_in_bio != blocks[0] - 1))\r\nbio = mpage_bio_submit(READ, bio);\r\nalloc_new:\r\nif (bio == NULL) {\r\nbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\r\nmin_t(int, nr_pages, bio_get_nr_vecs(bdev)),\r\nGFP_KERNEL);\r\nif (bio == NULL)\r\ngoto confused;\r\n}\r\nlength = first_hole << blkbits;\r\nif (bio_add_page(bio, page, length, 0) < length) {\r\nbio = mpage_bio_submit(READ, bio);\r\ngoto alloc_new;\r\n}\r\nrelative_block = block_in_file - *first_logical_block;\r\nnblocks = map_bh->b_size >> blkbits;\r\nif ((buffer_boundary(map_bh) && relative_block == nblocks) ||\r\n(first_hole != blocks_per_page))\r\nbio = mpage_bio_submit(READ, bio);\r\nelse\r\n*last_block_in_bio = blocks[blocks_per_page - 1];\r\nout:\r\nreturn bio;\r\nconfused:\r\nif (bio)\r\nbio = mpage_bio_submit(READ, bio);\r\nif (!PageUptodate(page))\r\nblock_read_full_page(page, get_block);\r\nelse\r\nunlock_page(page);\r\ngoto out;\r\n}\r\nint\r\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\r\nunsigned nr_pages, get_block_t get_block)\r\n{\r\nstruct bio *bio = NULL;\r\nunsigned page_idx;\r\nsector_t last_block_in_bio = 0;\r\nstruct buffer_head map_bh;\r\nunsigned long first_logical_block = 0;\r\nmap_bh.b_state = 0;\r\nmap_bh.b_size = 0;\r\nfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\r\nstruct page *page = list_entry(pages->prev, struct page, lru);\r\nprefetchw(&page->flags);\r\nlist_del(&page->lru);\r\nif (!add_to_page_cache_lru(page, mapping,\r\npage->index, GFP_KERNEL)) {\r\nbio = do_mpage_readpage(bio, page,\r\nnr_pages - page_idx,\r\n&last_block_in_bio, &map_bh,\r\n&first_logical_block,\r\nget_block);\r\n}\r\npage_cache_release(page);\r\n}\r\nBUG_ON(!list_empty(pages));\r\nif (bio)\r\nmpage_bio_submit(READ, bio);\r\nreturn 0;\r\n}\r\nint mpage_readpage(struct page *page, get_block_t get_block)\r\n{\r\nstruct bio *bio = NULL;\r\nsector_t last_block_in_bio = 0;\r\nstruct buffer_head map_bh;\r\nunsigned long first_logical_block = 0;\r\nmap_bh.b_state = 0;\r\nmap_bh.b_size = 0;\r\nbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\r\n&map_bh, &first_logical_block, get_block);\r\nif (bio)\r\nmpage_bio_submit(READ, bio);\r\nreturn 0;\r\n}\r\nstatic int __mpage_writepage(struct page *page, struct writeback_control *wbc,\r\nvoid *data)\r\n{\r\nstruct mpage_data *mpd = data;\r\nstruct bio *bio = mpd->bio;\r\nstruct address_space *mapping = page->mapping;\r\nstruct inode *inode = page->mapping->host;\r\nconst unsigned blkbits = inode->i_blkbits;\r\nunsigned long end_index;\r\nconst unsigned blocks_per_page = PAGE_CACHE_SIZE >> blkbits;\r\nsector_t last_block;\r\nsector_t block_in_file;\r\nsector_t blocks[MAX_BUF_PER_PAGE];\r\nunsigned page_block;\r\nunsigned first_unmapped = blocks_per_page;\r\nstruct block_device *bdev = NULL;\r\nint boundary = 0;\r\nsector_t boundary_block = 0;\r\nstruct block_device *boundary_bdev = NULL;\r\nint length;\r\nstruct buffer_head map_bh;\r\nloff_t i_size = i_size_read(inode);\r\nint ret = 0;\r\nif (page_has_buffers(page)) {\r\nstruct buffer_head *head = page_buffers(page);\r\nstruct buffer_head *bh = head;\r\npage_block = 0;\r\ndo {\r\nBUG_ON(buffer_locked(bh));\r\nif (!buffer_mapped(bh)) {\r\nif (buffer_dirty(bh))\r\ngoto confused;\r\nif (first_unmapped == blocks_per_page)\r\nfirst_unmapped = page_block;\r\ncontinue;\r\n}\r\nif (first_unmapped != blocks_per_page)\r\ngoto confused;\r\nif (!buffer_dirty(bh) || !buffer_uptodate(bh))\r\ngoto confused;\r\nif (page_block) {\r\nif (bh->b_blocknr != blocks[page_block-1] + 1)\r\ngoto confused;\r\n}\r\nblocks[page_block++] = bh->b_blocknr;\r\nboundary = buffer_boundary(bh);\r\nif (boundary) {\r\nboundary_block = bh->b_blocknr;\r\nboundary_bdev = bh->b_bdev;\r\n}\r\nbdev = bh->b_bdev;\r\n} while ((bh = bh->b_this_page) != head);\r\nif (first_unmapped)\r\ngoto page_is_mapped;\r\ngoto confused;\r\n}\r\nBUG_ON(!PageUptodate(page));\r\nblock_in_file = (sector_t)page->index << (PAGE_CACHE_SHIFT - blkbits);\r\nlast_block = (i_size - 1) >> blkbits;\r\nmap_bh.b_page = page;\r\nfor (page_block = 0; page_block < blocks_per_page; ) {\r\nmap_bh.b_state = 0;\r\nmap_bh.b_size = 1 << blkbits;\r\nif (mpd->get_block(inode, block_in_file, &map_bh, 1))\r\ngoto confused;\r\nif (buffer_new(&map_bh))\r\nunmap_underlying_metadata(map_bh.b_bdev,\r\nmap_bh.b_blocknr);\r\nif (buffer_boundary(&map_bh)) {\r\nboundary_block = map_bh.b_blocknr;\r\nboundary_bdev = map_bh.b_bdev;\r\n}\r\nif (page_block) {\r\nif (map_bh.b_blocknr != blocks[page_block-1] + 1)\r\ngoto confused;\r\n}\r\nblocks[page_block++] = map_bh.b_blocknr;\r\nboundary = buffer_boundary(&map_bh);\r\nbdev = map_bh.b_bdev;\r\nif (block_in_file == last_block)\r\nbreak;\r\nblock_in_file++;\r\n}\r\nBUG_ON(page_block == 0);\r\nfirst_unmapped = page_block;\r\npage_is_mapped:\r\nend_index = i_size >> PAGE_CACHE_SHIFT;\r\nif (page->index >= end_index) {\r\nunsigned offset = i_size & (PAGE_CACHE_SIZE - 1);\r\nif (page->index > end_index || !offset)\r\ngoto confused;\r\nzero_user_segment(page, offset, PAGE_CACHE_SIZE);\r\n}\r\nif (bio && mpd->last_block_in_bio != blocks[0] - 1)\r\nbio = mpage_bio_submit(WRITE, bio);\r\nalloc_new:\r\nif (bio == NULL) {\r\nbio = mpage_alloc(bdev, blocks[0] << (blkbits - 9),\r\nbio_get_nr_vecs(bdev), GFP_NOFS|__GFP_HIGH);\r\nif (bio == NULL)\r\ngoto confused;\r\n}\r\nlength = first_unmapped << blkbits;\r\nif (bio_add_page(bio, page, length, 0) < length) {\r\nbio = mpage_bio_submit(WRITE, bio);\r\ngoto alloc_new;\r\n}\r\nif (page_has_buffers(page)) {\r\nstruct buffer_head *head = page_buffers(page);\r\nstruct buffer_head *bh = head;\r\nunsigned buffer_counter = 0;\r\ndo {\r\nif (buffer_counter++ == first_unmapped)\r\nbreak;\r\nclear_buffer_dirty(bh);\r\nbh = bh->b_this_page;\r\n} while (bh != head);\r\nif (buffer_heads_over_limit && PageUptodate(page))\r\ntry_to_free_buffers(page);\r\n}\r\nBUG_ON(PageWriteback(page));\r\nset_page_writeback(page);\r\nunlock_page(page);\r\nif (boundary || (first_unmapped != blocks_per_page)) {\r\nbio = mpage_bio_submit(WRITE, bio);\r\nif (boundary_block) {\r\nwrite_boundary_block(boundary_bdev,\r\nboundary_block, 1 << blkbits);\r\n}\r\n} else {\r\nmpd->last_block_in_bio = blocks[blocks_per_page - 1];\r\n}\r\ngoto out;\r\nconfused:\r\nif (bio)\r\nbio = mpage_bio_submit(WRITE, bio);\r\nif (mpd->use_writepage) {\r\nret = mapping->a_ops->writepage(page, wbc);\r\n} else {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nmapping_set_error(mapping, ret);\r\nout:\r\nmpd->bio = bio;\r\nreturn ret;\r\n}\r\nint\r\nmpage_writepages(struct address_space *mapping,\r\nstruct writeback_control *wbc, get_block_t get_block)\r\n{\r\nstruct blk_plug plug;\r\nint ret;\r\nblk_start_plug(&plug);\r\nif (!get_block)\r\nret = generic_writepages(mapping, wbc);\r\nelse {\r\nstruct mpage_data mpd = {\r\n.bio = NULL,\r\n.last_block_in_bio = 0,\r\n.get_block = get_block,\r\n.use_writepage = 1,\r\n};\r\nret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\r\nif (mpd.bio)\r\nmpage_bio_submit(WRITE, mpd.bio);\r\n}\r\nblk_finish_plug(&plug);\r\nreturn ret;\r\n}\r\nint mpage_writepage(struct page *page, get_block_t get_block,\r\nstruct writeback_control *wbc)\r\n{\r\nstruct mpage_data mpd = {\r\n.bio = NULL,\r\n.last_block_in_bio = 0,\r\n.get_block = get_block,\r\n.use_writepage = 0,\r\n};\r\nint ret = __mpage_writepage(page, wbc, &mpd);\r\nif (mpd.bio)\r\nmpage_bio_submit(WRITE, mpd.bio);\r\nreturn ret;\r\n}
