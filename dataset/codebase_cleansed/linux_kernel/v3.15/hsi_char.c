static void hsc_add_tail(struct hsc_channel *channel, struct hsi_msg *msg,\r\nstruct list_head *queue)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&channel->lock, flags);\r\nlist_add_tail(&msg->link, queue);\r\nspin_unlock_irqrestore(&channel->lock, flags);\r\n}\r\nstatic struct hsi_msg *hsc_get_first_msg(struct hsc_channel *channel,\r\nstruct list_head *queue)\r\n{\r\nstruct hsi_msg *msg = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&channel->lock, flags);\r\nif (list_empty(queue))\r\ngoto out;\r\nmsg = list_first_entry(queue, struct hsi_msg, link);\r\nlist_del(&msg->link);\r\nout:\r\nspin_unlock_irqrestore(&channel->lock, flags);\r\nreturn msg;\r\n}\r\nstatic inline void hsc_msg_free(struct hsi_msg *msg)\r\n{\r\nkfree(sg_virt(msg->sgt.sgl));\r\nhsi_free_msg(msg);\r\n}\r\nstatic void hsc_free_list(struct list_head *list)\r\n{\r\nstruct hsi_msg *msg, *tmp;\r\nlist_for_each_entry_safe(msg, tmp, list, link) {\r\nlist_del(&msg->link);\r\nhsc_msg_free(msg);\r\n}\r\n}\r\nstatic void hsc_reset_list(struct hsc_channel *channel, struct list_head *l)\r\n{\r\nunsigned long flags;\r\nLIST_HEAD(list);\r\nspin_lock_irqsave(&channel->lock, flags);\r\nlist_splice_init(l, &list);\r\nspin_unlock_irqrestore(&channel->lock, flags);\r\nhsc_free_list(&list);\r\n}\r\nstatic inline struct hsi_msg *hsc_msg_alloc(unsigned int alloc_size)\r\n{\r\nstruct hsi_msg *msg;\r\nvoid *buf;\r\nmsg = hsi_alloc_msg(1, GFP_KERNEL);\r\nif (!msg)\r\ngoto out;\r\nbuf = kmalloc(alloc_size, GFP_KERNEL);\r\nif (!buf) {\r\nhsi_free_msg(msg);\r\ngoto out;\r\n}\r\nsg_init_one(msg->sgt.sgl, buf, alloc_size);\r\nkmemleak_ignore(buf);\r\nreturn msg;\r\nout:\r\nreturn NULL;\r\n}\r\nstatic inline int hsc_msgs_alloc(struct hsc_channel *channel)\r\n{\r\nstruct hsi_msg *msg;\r\nint i;\r\nfor (i = 0; i < HSC_MSGS; i++) {\r\nmsg = hsc_msg_alloc(max_data_size);\r\nif (!msg)\r\ngoto out;\r\nmsg->channel = channel->ch;\r\nlist_add_tail(&msg->link, &channel->free_msgs_list);\r\n}\r\nreturn 0;\r\nout:\r\nhsc_free_list(&channel->free_msgs_list);\r\nreturn -ENOMEM;\r\n}\r\nstatic inline unsigned int hsc_msg_len_get(struct hsi_msg *msg)\r\n{\r\nreturn msg->sgt.sgl->length;\r\n}\r\nstatic inline void hsc_msg_len_set(struct hsi_msg *msg, unsigned int len)\r\n{\r\nmsg->sgt.sgl->length = len;\r\n}\r\nstatic void hsc_rx_completed(struct hsi_msg *msg)\r\n{\r\nstruct hsc_client_data *cl_data = hsi_client_drvdata(msg->cl);\r\nstruct hsc_channel *channel = cl_data->channels + msg->channel;\r\nif (test_bit(HSC_CH_READ, &channel->flags)) {\r\nhsc_add_tail(channel, msg, &channel->rx_msgs_queue);\r\nwake_up(&channel->rx_wait);\r\n} else {\r\nhsc_add_tail(channel, msg, &channel->free_msgs_list);\r\n}\r\n}\r\nstatic void hsc_rx_msg_destructor(struct hsi_msg *msg)\r\n{\r\nmsg->status = HSI_STATUS_ERROR;\r\nhsc_msg_len_set(msg, 0);\r\nhsc_rx_completed(msg);\r\n}\r\nstatic void hsc_tx_completed(struct hsi_msg *msg)\r\n{\r\nstruct hsc_client_data *cl_data = hsi_client_drvdata(msg->cl);\r\nstruct hsc_channel *channel = cl_data->channels + msg->channel;\r\nif (test_bit(HSC_CH_WRITE, &channel->flags)) {\r\nhsc_add_tail(channel, msg, &channel->tx_msgs_queue);\r\nwake_up(&channel->tx_wait);\r\n} else {\r\nhsc_add_tail(channel, msg, &channel->free_msgs_list);\r\n}\r\n}\r\nstatic void hsc_tx_msg_destructor(struct hsi_msg *msg)\r\n{\r\nmsg->status = HSI_STATUS_ERROR;\r\nhsc_msg_len_set(msg, 0);\r\nhsc_tx_completed(msg);\r\n}\r\nstatic void hsc_break_req_destructor(struct hsi_msg *msg)\r\n{\r\nstruct hsc_client_data *cl_data = hsi_client_drvdata(msg->cl);\r\nhsi_free_msg(msg);\r\nclear_bit(HSC_RXBREAK, &cl_data->flags);\r\n}\r\nstatic void hsc_break_received(struct hsi_msg *msg)\r\n{\r\nstruct hsc_client_data *cl_data = hsi_client_drvdata(msg->cl);\r\nstruct hsc_channel *channel = cl_data->channels;\r\nint i, ret;\r\nfor (i = 0; i < HSC_DEVS; i++, channel++) {\r\nstruct hsi_msg *msg2;\r\nif (!test_bit(HSC_CH_READ, &channel->flags))\r\ncontinue;\r\nmsg2 = hsc_get_first_msg(channel, &channel->free_msgs_list);\r\nif (!msg2)\r\ncontinue;\r\nclear_bit(HSC_CH_READ, &channel->flags);\r\nhsc_msg_len_set(msg2, 0);\r\nmsg2->status = HSI_STATUS_COMPLETED;\r\nhsc_add_tail(channel, msg2, &channel->rx_msgs_queue);\r\nwake_up(&channel->rx_wait);\r\n}\r\nhsi_flush(msg->cl);\r\nret = hsi_async_read(msg->cl, msg);\r\nif (ret < 0)\r\nhsc_break_req_destructor(msg);\r\n}\r\nstatic int hsc_break_request(struct hsi_client *cl)\r\n{\r\nstruct hsc_client_data *cl_data = hsi_client_drvdata(cl);\r\nstruct hsi_msg *msg;\r\nint ret;\r\nif (test_and_set_bit(HSC_RXBREAK, &cl_data->flags))\r\nreturn -EBUSY;\r\nmsg = hsi_alloc_msg(0, GFP_KERNEL);\r\nif (!msg) {\r\nclear_bit(HSC_RXBREAK, &cl_data->flags);\r\nreturn -ENOMEM;\r\n}\r\nmsg->break_frame = 1;\r\nmsg->complete = hsc_break_received;\r\nmsg->destructor = hsc_break_req_destructor;\r\nret = hsi_async_read(cl, msg);\r\nif (ret < 0)\r\nhsc_break_req_destructor(msg);\r\nreturn ret;\r\n}\r\nstatic int hsc_break_send(struct hsi_client *cl)\r\n{\r\nstruct hsi_msg *msg;\r\nint ret;\r\nmsg = hsi_alloc_msg(0, GFP_ATOMIC);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->break_frame = 1;\r\nmsg->complete = hsi_free_msg;\r\nmsg->destructor = hsi_free_msg;\r\nret = hsi_async_write(cl, msg);\r\nif (ret < 0)\r\nhsi_free_msg(msg);\r\nreturn ret;\r\n}\r\nstatic int hsc_rx_set(struct hsi_client *cl, struct hsc_rx_config *rxc)\r\n{\r\nstruct hsi_config tmp;\r\nint ret;\r\nif ((rxc->mode != HSI_MODE_STREAM) && (rxc->mode != HSI_MODE_FRAME))\r\nreturn -EINVAL;\r\nif ((rxc->channels == 0) || (rxc->channels > HSC_DEVS))\r\nreturn -EINVAL;\r\nif (rxc->channels & (rxc->channels - 1))\r\nreturn -EINVAL;\r\nif ((rxc->flow != HSI_FLOW_SYNC) && (rxc->flow != HSI_FLOW_PIPE))\r\nreturn -EINVAL;\r\ntmp = cl->rx_cfg;\r\ncl->rx_cfg.mode = rxc->mode;\r\ncl->rx_cfg.channels = rxc->channels;\r\ncl->rx_cfg.flow = rxc->flow;\r\nret = hsi_setup(cl);\r\nif (ret < 0) {\r\ncl->rx_cfg = tmp;\r\nreturn ret;\r\n}\r\nif (rxc->mode == HSI_MODE_FRAME)\r\nhsc_break_request(cl);\r\nreturn ret;\r\n}\r\nstatic inline void hsc_rx_get(struct hsi_client *cl, struct hsc_rx_config *rxc)\r\n{\r\nrxc->mode = cl->rx_cfg.mode;\r\nrxc->channels = cl->rx_cfg.channels;\r\nrxc->flow = cl->rx_cfg.flow;\r\n}\r\nstatic int hsc_tx_set(struct hsi_client *cl, struct hsc_tx_config *txc)\r\n{\r\nstruct hsi_config tmp;\r\nint ret;\r\nif ((txc->mode != HSI_MODE_STREAM) && (txc->mode != HSI_MODE_FRAME))\r\nreturn -EINVAL;\r\nif ((txc->channels == 0) || (txc->channels > HSC_DEVS))\r\nreturn -EINVAL;\r\nif (txc->channels & (txc->channels - 1))\r\nreturn -EINVAL;\r\nif ((txc->arb_mode != HSI_ARB_RR) && (txc->arb_mode != HSI_ARB_PRIO))\r\nreturn -EINVAL;\r\ntmp = cl->tx_cfg;\r\ncl->tx_cfg.mode = txc->mode;\r\ncl->tx_cfg.channels = txc->channels;\r\ncl->tx_cfg.speed = txc->speed;\r\ncl->tx_cfg.arb_mode = txc->arb_mode;\r\nret = hsi_setup(cl);\r\nif (ret < 0) {\r\ncl->tx_cfg = tmp;\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void hsc_tx_get(struct hsi_client *cl, struct hsc_tx_config *txc)\r\n{\r\ntxc->mode = cl->tx_cfg.mode;\r\ntxc->channels = cl->tx_cfg.channels;\r\ntxc->speed = cl->tx_cfg.speed;\r\ntxc->arb_mode = cl->tx_cfg.arb_mode;\r\n}\r\nstatic ssize_t hsc_read(struct file *file, char __user *buf, size_t len,\r\nloff_t *ppos __maybe_unused)\r\n{\r\nstruct hsc_channel *channel = file->private_data;\r\nstruct hsi_msg *msg;\r\nssize_t ret;\r\nif (len == 0)\r\nreturn 0;\r\nif (!IS_ALIGNED(len, sizeof(u32)))\r\nreturn -EINVAL;\r\nif (len > max_data_size)\r\nlen = max_data_size;\r\nif (channel->ch >= channel->cl->rx_cfg.channels)\r\nreturn -ECHRNG;\r\nif (test_and_set_bit(HSC_CH_READ, &channel->flags))\r\nreturn -EBUSY;\r\nmsg = hsc_get_first_msg(channel, &channel->free_msgs_list);\r\nif (!msg) {\r\nret = -ENOSPC;\r\ngoto out;\r\n}\r\nhsc_msg_len_set(msg, len);\r\nmsg->complete = hsc_rx_completed;\r\nmsg->destructor = hsc_rx_msg_destructor;\r\nret = hsi_async_read(channel->cl, msg);\r\nif (ret < 0) {\r\nhsc_add_tail(channel, msg, &channel->free_msgs_list);\r\ngoto out;\r\n}\r\nret = wait_event_interruptible(channel->rx_wait,\r\n!list_empty(&channel->rx_msgs_queue));\r\nif (ret < 0) {\r\nclear_bit(HSC_CH_READ, &channel->flags);\r\nhsi_flush(channel->cl);\r\nreturn -EINTR;\r\n}\r\nmsg = hsc_get_first_msg(channel, &channel->rx_msgs_queue);\r\nif (msg) {\r\nif (msg->status != HSI_STATUS_ERROR) {\r\nret = copy_to_user((void __user *)buf,\r\nsg_virt(msg->sgt.sgl), hsc_msg_len_get(msg));\r\nif (ret)\r\nret = -EFAULT;\r\nelse\r\nret = hsc_msg_len_get(msg);\r\n} else {\r\nret = -EIO;\r\n}\r\nhsc_add_tail(channel, msg, &channel->free_msgs_list);\r\n}\r\nout:\r\nclear_bit(HSC_CH_READ, &channel->flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t hsc_write(struct file *file, const char __user *buf, size_t len,\r\nloff_t *ppos __maybe_unused)\r\n{\r\nstruct hsc_channel *channel = file->private_data;\r\nstruct hsi_msg *msg;\r\nssize_t ret;\r\nif ((len == 0) || !IS_ALIGNED(len, sizeof(u32)))\r\nreturn -EINVAL;\r\nif (len > max_data_size)\r\nlen = max_data_size;\r\nif (channel->ch >= channel->cl->tx_cfg.channels)\r\nreturn -ECHRNG;\r\nif (test_and_set_bit(HSC_CH_WRITE, &channel->flags))\r\nreturn -EBUSY;\r\nmsg = hsc_get_first_msg(channel, &channel->free_msgs_list);\r\nif (!msg) {\r\nclear_bit(HSC_CH_WRITE, &channel->flags);\r\nreturn -ENOSPC;\r\n}\r\nif (copy_from_user(sg_virt(msg->sgt.sgl), (void __user *)buf, len)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nhsc_msg_len_set(msg, len);\r\nmsg->complete = hsc_tx_completed;\r\nmsg->destructor = hsc_tx_msg_destructor;\r\nret = hsi_async_write(channel->cl, msg);\r\nif (ret < 0)\r\ngoto out;\r\nret = wait_event_interruptible(channel->tx_wait,\r\n!list_empty(&channel->tx_msgs_queue));\r\nif (ret < 0) {\r\nclear_bit(HSC_CH_WRITE, &channel->flags);\r\nhsi_flush(channel->cl);\r\nreturn -EINTR;\r\n}\r\nmsg = hsc_get_first_msg(channel, &channel->tx_msgs_queue);\r\nif (msg) {\r\nif (msg->status == HSI_STATUS_ERROR)\r\nret = -EIO;\r\nelse\r\nret = hsc_msg_len_get(msg);\r\nhsc_add_tail(channel, msg, &channel->free_msgs_list);\r\n}\r\nout:\r\nclear_bit(HSC_CH_WRITE, &channel->flags);\r\nreturn ret;\r\n}\r\nstatic long hsc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct hsc_channel *channel = file->private_data;\r\nunsigned int state;\r\nstruct hsc_rx_config rxc;\r\nstruct hsc_tx_config txc;\r\nlong ret = 0;\r\nswitch (cmd) {\r\ncase HSC_RESET:\r\nhsi_flush(channel->cl);\r\nbreak;\r\ncase HSC_SET_PM:\r\nif (copy_from_user(&state, (void __user *)arg, sizeof(state)))\r\nreturn -EFAULT;\r\nif (state == HSC_PM_DISABLE) {\r\nif (test_and_set_bit(HSC_CH_WLINE, &channel->flags))\r\nreturn -EINVAL;\r\nret = hsi_start_tx(channel->cl);\r\n} else if (state == HSC_PM_ENABLE) {\r\nif (!test_and_clear_bit(HSC_CH_WLINE, &channel->flags))\r\nreturn -EINVAL;\r\nret = hsi_stop_tx(channel->cl);\r\n} else {\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase HSC_SEND_BREAK:\r\nreturn hsc_break_send(channel->cl);\r\ncase HSC_SET_RX:\r\nif (copy_from_user(&rxc, (void __user *)arg, sizeof(rxc)))\r\nreturn -EFAULT;\r\nreturn hsc_rx_set(channel->cl, &rxc);\r\ncase HSC_GET_RX:\r\nhsc_rx_get(channel->cl, &rxc);\r\nif (copy_to_user((void __user *)arg, &rxc, sizeof(rxc)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase HSC_SET_TX:\r\nif (copy_from_user(&txc, (void __user *)arg, sizeof(txc)))\r\nreturn -EFAULT;\r\nreturn hsc_tx_set(channel->cl, &txc);\r\ncase HSC_GET_TX:\r\nhsc_tx_get(channel->cl, &txc);\r\nif (copy_to_user((void __user *)arg, &txc, sizeof(txc)))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void __hsc_port_release(struct hsc_client_data *cl_data)\r\n{\r\nBUG_ON(cl_data->usecnt == 0);\r\nif (--cl_data->usecnt == 0) {\r\nhsi_flush(cl_data->cl);\r\nhsi_release_port(cl_data->cl);\r\n}\r\n}\r\nstatic int hsc_open(struct inode *inode, struct file *file)\r\n{\r\nstruct hsc_client_data *cl_data;\r\nstruct hsc_channel *channel;\r\nint ret = 0;\r\npr_debug("open, minor = %d\n", iminor(inode));\r\ncl_data = container_of(inode->i_cdev, struct hsc_client_data, cdev);\r\nmutex_lock(&cl_data->lock);\r\nchannel = cl_data->channels + (iminor(inode) & HSC_CH_MASK);\r\nif (test_and_set_bit(HSC_CH_OPEN, &channel->flags)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (cl_data->usecnt == 0) {\r\nret = hsi_claim_port(cl_data->cl, 0);\r\nif (ret < 0)\r\ngoto out;\r\nhsi_setup(cl_data->cl);\r\n}\r\ncl_data->usecnt++;\r\nret = hsc_msgs_alloc(channel);\r\nif (ret < 0) {\r\n__hsc_port_release(cl_data);\r\ngoto out;\r\n}\r\nfile->private_data = channel;\r\nmutex_unlock(&cl_data->lock);\r\nreturn ret;\r\nout:\r\nmutex_unlock(&cl_data->lock);\r\nreturn ret;\r\n}\r\nstatic int hsc_release(struct inode *inode __maybe_unused, struct file *file)\r\n{\r\nstruct hsc_channel *channel = file->private_data;\r\nstruct hsc_client_data *cl_data = channel->cl_data;\r\nmutex_lock(&cl_data->lock);\r\nfile->private_data = NULL;\r\nif (test_and_clear_bit(HSC_CH_WLINE, &channel->flags))\r\nhsi_stop_tx(channel->cl);\r\n__hsc_port_release(cl_data);\r\nhsc_reset_list(channel, &channel->rx_msgs_queue);\r\nhsc_reset_list(channel, &channel->tx_msgs_queue);\r\nhsc_reset_list(channel, &channel->free_msgs_list);\r\nclear_bit(HSC_CH_READ, &channel->flags);\r\nclear_bit(HSC_CH_WRITE, &channel->flags);\r\nclear_bit(HSC_CH_OPEN, &channel->flags);\r\nwake_up(&channel->rx_wait);\r\nwake_up(&channel->tx_wait);\r\nmutex_unlock(&cl_data->lock);\r\nreturn 0;\r\n}\r\nstatic void hsc_channel_init(struct hsc_channel *channel)\r\n{\r\ninit_waitqueue_head(&channel->rx_wait);\r\ninit_waitqueue_head(&channel->tx_wait);\r\nspin_lock_init(&channel->lock);\r\nINIT_LIST_HEAD(&channel->free_msgs_list);\r\nINIT_LIST_HEAD(&channel->rx_msgs_queue);\r\nINIT_LIST_HEAD(&channel->tx_msgs_queue);\r\n}\r\nstatic int hsc_probe(struct device *dev)\r\n{\r\nconst char devname[] = "hsi_char";\r\nstruct hsc_client_data *cl_data;\r\nstruct hsc_channel *channel;\r\nstruct hsi_client *cl = to_hsi_client(dev);\r\nunsigned int hsc_baseminor;\r\ndev_t hsc_dev;\r\nint ret;\r\nint i;\r\ncl_data = kzalloc(sizeof(*cl_data), GFP_KERNEL);\r\nif (!cl_data) {\r\ndev_err(dev, "Could not allocate hsc_client_data\n");\r\nreturn -ENOMEM;\r\n}\r\nhsc_baseminor = HSC_BASEMINOR(hsi_id(cl), hsi_port_id(cl));\r\nif (!hsc_major) {\r\nret = alloc_chrdev_region(&hsc_dev, hsc_baseminor,\r\nHSC_DEVS, devname);\r\nif (ret > 0)\r\nhsc_major = MAJOR(hsc_dev);\r\n} else {\r\nhsc_dev = MKDEV(hsc_major, hsc_baseminor);\r\nret = register_chrdev_region(hsc_dev, HSC_DEVS, devname);\r\n}\r\nif (ret < 0) {\r\ndev_err(dev, "Device %s allocation failed %d\n",\r\nhsc_major ? "minor" : "major", ret);\r\ngoto out1;\r\n}\r\nmutex_init(&cl_data->lock);\r\nhsi_client_set_drvdata(cl, cl_data);\r\ncdev_init(&cl_data->cdev, &hsc_fops);\r\ncl_data->cdev.owner = THIS_MODULE;\r\ncl_data->cl = cl;\r\nfor (i = 0, channel = cl_data->channels; i < HSC_DEVS; i++, channel++) {\r\nhsc_channel_init(channel);\r\nchannel->ch = i;\r\nchannel->cl = cl;\r\nchannel->cl_data = cl_data;\r\n}\r\nret = cdev_add(&cl_data->cdev, hsc_dev, HSC_DEVS);\r\nif (ret) {\r\ndev_err(dev, "Could not add char device %d\n", ret);\r\ngoto out2;\r\n}\r\nreturn 0;\r\nout2:\r\nunregister_chrdev_region(hsc_dev, HSC_DEVS);\r\nout1:\r\nkfree(cl_data);\r\nreturn ret;\r\n}\r\nstatic int hsc_remove(struct device *dev)\r\n{\r\nstruct hsi_client *cl = to_hsi_client(dev);\r\nstruct hsc_client_data *cl_data = hsi_client_drvdata(cl);\r\ndev_t hsc_dev = cl_data->cdev.dev;\r\ncdev_del(&cl_data->cdev);\r\nunregister_chrdev_region(hsc_dev, HSC_DEVS);\r\nhsi_client_set_drvdata(cl, NULL);\r\nkfree(cl_data);\r\nreturn 0;\r\n}\r\nstatic int __init hsc_init(void)\r\n{\r\nint ret;\r\nif ((max_data_size < 4) || (max_data_size > 0x10000) ||\r\n(max_data_size & (max_data_size - 1))) {\r\npr_err("Invalid max read/write data size");\r\nreturn -EINVAL;\r\n}\r\nret = hsi_register_client_driver(&hsc_driver);\r\nif (ret) {\r\npr_err("Error while registering HSI/SSI driver %d", ret);\r\nreturn ret;\r\n}\r\npr_info("HSI/SSI char device loaded\n");\r\nreturn 0;\r\n}\r\nstatic void __exit hsc_exit(void)\r\n{\r\nhsi_unregister_client_driver(&hsc_driver);\r\npr_info("HSI char device removed\n");\r\n}
