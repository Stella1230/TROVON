static int ch_find_errno(struct scsi_sense_hdr *sshdr)\r\n{\r\nint i,errno = 0;\r\nif (scsi_sense_valid(sshdr) &&\r\nsshdr->asc != 0) {\r\nfor (i = 0; ch_err[i].errno != 0; i++) {\r\nif (ch_err[i].sense == sshdr->sense_key &&\r\nch_err[i].asc == sshdr->asc &&\r\nch_err[i].ascq == sshdr->ascq) {\r\nerrno = -ch_err[i].errno;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (errno == 0)\r\nerrno = -EIO;\r\nreturn errno;\r\n}\r\nstatic int\r\nch_do_scsi(scsi_changer *ch, unsigned char *cmd,\r\nvoid *buffer, unsigned buflength,\r\nenum dma_data_direction direction)\r\n{\r\nint errno, retries = 0, timeout, result;\r\nstruct scsi_sense_hdr sshdr;\r\ntimeout = (cmd[0] == INITIALIZE_ELEMENT_STATUS)\r\n? timeout_init : timeout_move;\r\nretry:\r\nerrno = 0;\r\nif (debug) {\r\nDPRINTK("command: ");\r\n__scsi_print_command(cmd);\r\n}\r\nresult = scsi_execute_req(ch->device, cmd, direction, buffer,\r\nbuflength, &sshdr, timeout * HZ,\r\nMAX_RETRIES, NULL);\r\nDPRINTK("result: 0x%x\n",result);\r\nif (driver_byte(result) & DRIVER_SENSE) {\r\nif (debug)\r\nscsi_print_sense_hdr(ch->name, &sshdr);\r\nerrno = ch_find_errno(&sshdr);\r\nswitch(sshdr.sense_key) {\r\ncase UNIT_ATTENTION:\r\nch->unit_attention = 1;\r\nif (retries++ < 3)\r\ngoto retry;\r\nbreak;\r\n}\r\n}\r\nreturn errno;\r\n}\r\nstatic int\r\nch_elem_to_typecode(scsi_changer *ch, u_int elem)\r\n{\r\nint i;\r\nfor (i = 0; i < CH_TYPES; i++) {\r\nif (elem >= ch->firsts[i] &&\r\nelem < ch->firsts[i] +\r\nch->counts[i])\r\nreturn i+1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nch_read_element_status(scsi_changer *ch, u_int elem, char *data)\r\n{\r\nu_char cmd[12];\r\nu_char *buffer;\r\nint result;\r\nbuffer = kmalloc(512, GFP_KERNEL | GFP_DMA);\r\nif(!buffer)\r\nreturn -ENOMEM;\r\nretry:\r\nmemset(cmd,0,sizeof(cmd));\r\ncmd[0] = READ_ELEMENT_STATUS;\r\ncmd[1] = (ch->device->lun << 5) |\r\n(ch->voltags ? 0x10 : 0) |\r\nch_elem_to_typecode(ch,elem);\r\ncmd[2] = (elem >> 8) & 0xff;\r\ncmd[3] = elem & 0xff;\r\ncmd[5] = 1;\r\ncmd[9] = 255;\r\nif (0 == (result = ch_do_scsi(ch, cmd, buffer, 256, DMA_FROM_DEVICE))) {\r\nif (((buffer[16] << 8) | buffer[17]) != elem) {\r\nDPRINTK("asked for element 0x%02x, got 0x%02x\n",\r\nelem,(buffer[16] << 8) | buffer[17]);\r\nkfree(buffer);\r\nreturn -EIO;\r\n}\r\nmemcpy(data,buffer+16,16);\r\n} else {\r\nif (ch->voltags) {\r\nch->voltags = 0;\r\nVPRINTK(KERN_INFO, "device has no volume tag support\n");\r\ngoto retry;\r\n}\r\nDPRINTK("READ ELEMENT STATUS for element 0x%x failed\n",elem);\r\n}\r\nkfree(buffer);\r\nreturn result;\r\n}\r\nstatic int\r\nch_init_elem(scsi_changer *ch)\r\n{\r\nint err;\r\nu_char cmd[6];\r\nVPRINTK(KERN_INFO, "INITIALIZE ELEMENT STATUS, may take some time ...\n");\r\nmemset(cmd,0,sizeof(cmd));\r\ncmd[0] = INITIALIZE_ELEMENT_STATUS;\r\ncmd[1] = ch->device->lun << 5;\r\nerr = ch_do_scsi(ch, cmd, NULL, 0, DMA_NONE);\r\nVPRINTK(KERN_INFO, "... finished\n");\r\nreturn err;\r\n}\r\nstatic int\r\nch_readconfig(scsi_changer *ch)\r\n{\r\nu_char cmd[10], data[16];\r\nu_char *buffer;\r\nint result,id,lun,i;\r\nu_int elem;\r\nbuffer = kzalloc(512, GFP_KERNEL | GFP_DMA);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmemset(cmd,0,sizeof(cmd));\r\ncmd[0] = MODE_SENSE;\r\ncmd[1] = ch->device->lun << 5;\r\ncmd[2] = 0x1d;\r\ncmd[4] = 255;\r\nresult = ch_do_scsi(ch, cmd, buffer, 255, DMA_FROM_DEVICE);\r\nif (0 != result) {\r\ncmd[1] |= (1<<3);\r\nresult = ch_do_scsi(ch, cmd, buffer, 255, DMA_FROM_DEVICE);\r\n}\r\nif (0 == result) {\r\nch->firsts[CHET_MT] =\r\n(buffer[buffer[3]+ 6] << 8) | buffer[buffer[3]+ 7];\r\nch->counts[CHET_MT] =\r\n(buffer[buffer[3]+ 8] << 8) | buffer[buffer[3]+ 9];\r\nch->firsts[CHET_ST] =\r\n(buffer[buffer[3]+10] << 8) | buffer[buffer[3]+11];\r\nch->counts[CHET_ST] =\r\n(buffer[buffer[3]+12] << 8) | buffer[buffer[3]+13];\r\nch->firsts[CHET_IE] =\r\n(buffer[buffer[3]+14] << 8) | buffer[buffer[3]+15];\r\nch->counts[CHET_IE] =\r\n(buffer[buffer[3]+16] << 8) | buffer[buffer[3]+17];\r\nch->firsts[CHET_DT] =\r\n(buffer[buffer[3]+18] << 8) | buffer[buffer[3]+19];\r\nch->counts[CHET_DT] =\r\n(buffer[buffer[3]+20] << 8) | buffer[buffer[3]+21];\r\nVPRINTK(KERN_INFO, "type #1 (mt): 0x%x+%d [medium transport]\n",\r\nch->firsts[CHET_MT],\r\nch->counts[CHET_MT]);\r\nVPRINTK(KERN_INFO, "type #2 (st): 0x%x+%d [storage]\n",\r\nch->firsts[CHET_ST],\r\nch->counts[CHET_ST]);\r\nVPRINTK(KERN_INFO, "type #3 (ie): 0x%x+%d [import/export]\n",\r\nch->firsts[CHET_IE],\r\nch->counts[CHET_IE]);\r\nVPRINTK(KERN_INFO, "type #4 (dt): 0x%x+%d [data transfer]\n",\r\nch->firsts[CHET_DT],\r\nch->counts[CHET_DT]);\r\n} else {\r\nVPRINTK(KERN_INFO, "reading element address assigment page failed!\n");\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nif (0 == vendor_counts[i])\r\ncontinue;\r\nif (NULL == vendor_labels[i])\r\ncontinue;\r\nch->firsts[CHET_V1+i] = vendor_firsts[i];\r\nch->counts[CHET_V1+i] = vendor_counts[i];\r\nVPRINTK(KERN_INFO, "type #%d (v%d): 0x%x+%d [%s, vendor specific]\n",\r\ni+5,i+1,vendor_firsts[i],vendor_counts[i],\r\nvendor_labels[i]);\r\n}\r\nch->dt = kcalloc(ch->counts[CHET_DT], sizeof(*ch->dt),\r\nGFP_KERNEL);\r\nif (!ch->dt) {\r\nkfree(buffer);\r\nreturn -ENOMEM;\r\n}\r\nfor (elem = 0; elem < ch->counts[CHET_DT]; elem++) {\r\nid = -1;\r\nlun = 0;\r\nif (elem < CH_DT_MAX && -1 != dt_id[elem]) {\r\nid = dt_id[elem];\r\nlun = dt_lun[elem];\r\nVPRINTK(KERN_INFO, "dt 0x%x: [insmod option] ",\r\nelem+ch->firsts[CHET_DT]);\r\n} else if (0 != ch_read_element_status\r\n(ch,elem+ch->firsts[CHET_DT],data)) {\r\nVPRINTK(KERN_INFO, "dt 0x%x: READ ELEMENT STATUS failed\n",\r\nelem+ch->firsts[CHET_DT]);\r\n} else {\r\nVPRINTK(KERN_INFO, "dt 0x%x: ",elem+ch->firsts[CHET_DT]);\r\nif (data[6] & 0x80) {\r\nVPRINTK(KERN_CONT, "not this SCSI bus\n");\r\nch->dt[elem] = NULL;\r\n} else if (0 == (data[6] & 0x30)) {\r\nVPRINTK(KERN_CONT, "ID/LUN unknown\n");\r\nch->dt[elem] = NULL;\r\n} else {\r\nid = ch->device->id;\r\nlun = 0;\r\nif (data[6] & 0x20) id = data[7];\r\nif (data[6] & 0x10) lun = data[6] & 7;\r\n}\r\n}\r\nif (-1 != id) {\r\nVPRINTK(KERN_CONT, "ID %i, LUN %i, ",id,lun);\r\nch->dt[elem] =\r\nscsi_device_lookup(ch->device->host,\r\nch->device->channel,\r\nid,lun);\r\nif (!ch->dt[elem]) {\r\nVPRINTK(KERN_CONT, "Huh? device not found!\n");\r\n} else {\r\nVPRINTK(KERN_CONT, "name: %8.8s %16.16s %4.4s\n",\r\nch->dt[elem]->vendor,\r\nch->dt[elem]->model,\r\nch->dt[elem]->rev);\r\n}\r\n}\r\n}\r\nch->voltags = 1;\r\nkfree(buffer);\r\nreturn 0;\r\n}\r\nstatic int\r\nch_position(scsi_changer *ch, u_int trans, u_int elem, int rotate)\r\n{\r\nu_char cmd[10];\r\nDPRINTK("position: 0x%x\n",elem);\r\nif (0 == trans)\r\ntrans = ch->firsts[CHET_MT];\r\nmemset(cmd,0,sizeof(cmd));\r\ncmd[0] = POSITION_TO_ELEMENT;\r\ncmd[1] = ch->device->lun << 5;\r\ncmd[2] = (trans >> 8) & 0xff;\r\ncmd[3] = trans & 0xff;\r\ncmd[4] = (elem >> 8) & 0xff;\r\ncmd[5] = elem & 0xff;\r\ncmd[8] = rotate ? 1 : 0;\r\nreturn ch_do_scsi(ch, cmd, NULL, 0, DMA_NONE);\r\n}\r\nstatic int\r\nch_move(scsi_changer *ch, u_int trans, u_int src, u_int dest, int rotate)\r\n{\r\nu_char cmd[12];\r\nDPRINTK("move: 0x%x => 0x%x\n",src,dest);\r\nif (0 == trans)\r\ntrans = ch->firsts[CHET_MT];\r\nmemset(cmd,0,sizeof(cmd));\r\ncmd[0] = MOVE_MEDIUM;\r\ncmd[1] = ch->device->lun << 5;\r\ncmd[2] = (trans >> 8) & 0xff;\r\ncmd[3] = trans & 0xff;\r\ncmd[4] = (src >> 8) & 0xff;\r\ncmd[5] = src & 0xff;\r\ncmd[6] = (dest >> 8) & 0xff;\r\ncmd[7] = dest & 0xff;\r\ncmd[10] = rotate ? 1 : 0;\r\nreturn ch_do_scsi(ch, cmd, NULL,0, DMA_NONE);\r\n}\r\nstatic int\r\nch_exchange(scsi_changer *ch, u_int trans, u_int src,\r\nu_int dest1, u_int dest2, int rotate1, int rotate2)\r\n{\r\nu_char cmd[12];\r\nDPRINTK("exchange: 0x%x => 0x%x => 0x%x\n",\r\nsrc,dest1,dest2);\r\nif (0 == trans)\r\ntrans = ch->firsts[CHET_MT];\r\nmemset(cmd,0,sizeof(cmd));\r\ncmd[0] = EXCHANGE_MEDIUM;\r\ncmd[1] = ch->device->lun << 5;\r\ncmd[2] = (trans >> 8) & 0xff;\r\ncmd[3] = trans & 0xff;\r\ncmd[4] = (src >> 8) & 0xff;\r\ncmd[5] = src & 0xff;\r\ncmd[6] = (dest1 >> 8) & 0xff;\r\ncmd[7] = dest1 & 0xff;\r\ncmd[8] = (dest2 >> 8) & 0xff;\r\ncmd[9] = dest2 & 0xff;\r\ncmd[10] = (rotate1 ? 1 : 0) | (rotate2 ? 2 : 0);\r\nreturn ch_do_scsi(ch, cmd, NULL,0, DMA_NONE);\r\n}\r\nstatic void\r\nch_check_voltag(char *tag)\r\n{\r\nint i;\r\nfor (i = 0; i < 32; i++) {\r\nif (tag[i] >= 0x7f || tag[i] < 0x20)\r\ntag[i] = ' ';\r\nif (tag[i] == '?' ||\r\ntag[i] == '*')\r\ntag[i] = ' ';\r\n}\r\n}\r\nstatic int\r\nch_set_voltag(scsi_changer *ch, u_int elem,\r\nint alternate, int clear, u_char *tag)\r\n{\r\nu_char cmd[12];\r\nu_char *buffer;\r\nint result;\r\nbuffer = kzalloc(512, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nDPRINTK("%s %s voltag: 0x%x => \"%s\"\n",\r\nclear ? "clear" : "set",\r\nalternate ? "alternate" : "primary",\r\nelem, tag);\r\nmemset(cmd,0,sizeof(cmd));\r\ncmd[0] = SEND_VOLUME_TAG;\r\ncmd[1] = (ch->device->lun << 5) |\r\nch_elem_to_typecode(ch,elem);\r\ncmd[2] = (elem >> 8) & 0xff;\r\ncmd[3] = elem & 0xff;\r\ncmd[5] = clear\r\n? (alternate ? 0x0d : 0x0c)\r\n: (alternate ? 0x0b : 0x0a);\r\ncmd[9] = 255;\r\nmemcpy(buffer,tag,32);\r\nch_check_voltag(buffer);\r\nresult = ch_do_scsi(ch, cmd, buffer, 256, DMA_TO_DEVICE);\r\nkfree(buffer);\r\nreturn result;\r\n}\r\nstatic int ch_gstatus(scsi_changer *ch, int type, unsigned char __user *dest)\r\n{\r\nint retval = 0;\r\nu_char data[16];\r\nunsigned int i;\r\nmutex_lock(&ch->lock);\r\nfor (i = 0; i < ch->counts[type]; i++) {\r\nif (0 != ch_read_element_status\r\n(ch, ch->firsts[type]+i,data)) {\r\nretval = -EIO;\r\nbreak;\r\n}\r\nput_user(data[2], dest+i);\r\nif (data[2] & CESTATUS_EXCEPT)\r\nVPRINTK(KERN_INFO, "element 0x%x: asc=0x%x, ascq=0x%x\n",\r\nch->firsts[type]+i,\r\n(int)data[4],(int)data[5]);\r\nretval = ch_read_element_status\r\n(ch, ch->firsts[type]+i,data);\r\nif (0 != retval)\r\nbreak;\r\n}\r\nmutex_unlock(&ch->lock);\r\nreturn retval;\r\n}\r\nstatic int\r\nch_release(struct inode *inode, struct file *file)\r\n{\r\nscsi_changer *ch = file->private_data;\r\nscsi_device_put(ch->device);\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nch_open(struct inode *inode, struct file *file)\r\n{\r\nscsi_changer *ch;\r\nint minor = iminor(inode);\r\nmutex_lock(&ch_mutex);\r\nspin_lock(&ch_index_lock);\r\nch = idr_find(&ch_index_idr, minor);\r\nif (NULL == ch || scsi_device_get(ch->device)) {\r\nspin_unlock(&ch_index_lock);\r\nmutex_unlock(&ch_mutex);\r\nreturn -ENXIO;\r\n}\r\nspin_unlock(&ch_index_lock);\r\nfile->private_data = ch;\r\nmutex_unlock(&ch_mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\nch_checkrange(scsi_changer *ch, unsigned int type, unsigned int unit)\r\n{\r\nif (type >= CH_TYPES || unit >= ch->counts[type])\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic long ch_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nscsi_changer *ch = file->private_data;\r\nint retval;\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase CHIOGPARAMS:\r\n{\r\nstruct changer_params params;\r\nparams.cp_curpicker = 0;\r\nparams.cp_npickers = ch->counts[CHET_MT];\r\nparams.cp_nslots = ch->counts[CHET_ST];\r\nparams.cp_nportals = ch->counts[CHET_IE];\r\nparams.cp_ndrives = ch->counts[CHET_DT];\r\nif (copy_to_user(argp, &params, sizeof(params)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase CHIOGVPARAMS:\r\n{\r\nstruct changer_vendor_params vparams;\r\nmemset(&vparams,0,sizeof(vparams));\r\nif (ch->counts[CHET_V1]) {\r\nvparams.cvp_n1 = ch->counts[CHET_V1];\r\nstrncpy(vparams.cvp_label1,vendor_labels[0],16);\r\n}\r\nif (ch->counts[CHET_V2]) {\r\nvparams.cvp_n2 = ch->counts[CHET_V2];\r\nstrncpy(vparams.cvp_label2,vendor_labels[1],16);\r\n}\r\nif (ch->counts[CHET_V3]) {\r\nvparams.cvp_n3 = ch->counts[CHET_V3];\r\nstrncpy(vparams.cvp_label3,vendor_labels[2],16);\r\n}\r\nif (ch->counts[CHET_V4]) {\r\nvparams.cvp_n4 = ch->counts[CHET_V4];\r\nstrncpy(vparams.cvp_label4,vendor_labels[3],16);\r\n}\r\nif (copy_to_user(argp, &vparams, sizeof(vparams)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase CHIOPOSITION:\r\n{\r\nstruct changer_position pos;\r\nif (copy_from_user(&pos, argp, sizeof (pos)))\r\nreturn -EFAULT;\r\nif (0 != ch_checkrange(ch, pos.cp_type, pos.cp_unit)) {\r\nDPRINTK("CHIOPOSITION: invalid parameter\n");\r\nreturn -EBADSLT;\r\n}\r\nmutex_lock(&ch->lock);\r\nretval = ch_position(ch,0,\r\nch->firsts[pos.cp_type] + pos.cp_unit,\r\npos.cp_flags & CP_INVERT);\r\nmutex_unlock(&ch->lock);\r\nreturn retval;\r\n}\r\ncase CHIOMOVE:\r\n{\r\nstruct changer_move mv;\r\nif (copy_from_user(&mv, argp, sizeof (mv)))\r\nreturn -EFAULT;\r\nif (0 != ch_checkrange(ch, mv.cm_fromtype, mv.cm_fromunit) ||\r\n0 != ch_checkrange(ch, mv.cm_totype, mv.cm_tounit )) {\r\nDPRINTK("CHIOMOVE: invalid parameter\n");\r\nreturn -EBADSLT;\r\n}\r\nmutex_lock(&ch->lock);\r\nretval = ch_move(ch,0,\r\nch->firsts[mv.cm_fromtype] + mv.cm_fromunit,\r\nch->firsts[mv.cm_totype] + mv.cm_tounit,\r\nmv.cm_flags & CM_INVERT);\r\nmutex_unlock(&ch->lock);\r\nreturn retval;\r\n}\r\ncase CHIOEXCHANGE:\r\n{\r\nstruct changer_exchange mv;\r\nif (copy_from_user(&mv, argp, sizeof (mv)))\r\nreturn -EFAULT;\r\nif (0 != ch_checkrange(ch, mv.ce_srctype, mv.ce_srcunit ) ||\r\n0 != ch_checkrange(ch, mv.ce_fdsttype, mv.ce_fdstunit) ||\r\n0 != ch_checkrange(ch, mv.ce_sdsttype, mv.ce_sdstunit)) {\r\nDPRINTK("CHIOEXCHANGE: invalid parameter\n");\r\nreturn -EBADSLT;\r\n}\r\nmutex_lock(&ch->lock);\r\nretval = ch_exchange\r\n(ch,0,\r\nch->firsts[mv.ce_srctype] + mv.ce_srcunit,\r\nch->firsts[mv.ce_fdsttype] + mv.ce_fdstunit,\r\nch->firsts[mv.ce_sdsttype] + mv.ce_sdstunit,\r\nmv.ce_flags & CE_INVERT1, mv.ce_flags & CE_INVERT2);\r\nmutex_unlock(&ch->lock);\r\nreturn retval;\r\n}\r\ncase CHIOGSTATUS:\r\n{\r\nstruct changer_element_status ces;\r\nif (copy_from_user(&ces, argp, sizeof (ces)))\r\nreturn -EFAULT;\r\nif (ces.ces_type < 0 || ces.ces_type >= CH_TYPES)\r\nreturn -EINVAL;\r\nreturn ch_gstatus(ch, ces.ces_type, ces.ces_data);\r\n}\r\ncase CHIOGELEM:\r\n{\r\nstruct changer_get_element cge;\r\nu_char ch_cmd[12];\r\nu_char *buffer;\r\nunsigned int elem;\r\nint result,i;\r\nif (copy_from_user(&cge, argp, sizeof (cge)))\r\nreturn -EFAULT;\r\nif (0 != ch_checkrange(ch, cge.cge_type, cge.cge_unit))\r\nreturn -EINVAL;\r\nelem = ch->firsts[cge.cge_type] + cge.cge_unit;\r\nbuffer = kmalloc(512, GFP_KERNEL | GFP_DMA);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmutex_lock(&ch->lock);\r\nvoltag_retry:\r\nmemset(ch_cmd, 0, sizeof(ch_cmd));\r\nch_cmd[0] = READ_ELEMENT_STATUS;\r\nch_cmd[1] = (ch->device->lun << 5) |\r\n(ch->voltags ? 0x10 : 0) |\r\nch_elem_to_typecode(ch,elem);\r\nch_cmd[2] = (elem >> 8) & 0xff;\r\nch_cmd[3] = elem & 0xff;\r\nch_cmd[5] = 1;\r\nch_cmd[9] = 255;\r\nresult = ch_do_scsi(ch, ch_cmd, buffer, 256, DMA_FROM_DEVICE);\r\nif (!result) {\r\ncge.cge_status = buffer[18];\r\ncge.cge_flags = 0;\r\nif (buffer[18] & CESTATUS_EXCEPT) {\r\ncge.cge_errno = EIO;\r\n}\r\nif (buffer[25] & 0x80) {\r\ncge.cge_flags |= CGE_SRC;\r\nif (buffer[25] & 0x40)\r\ncge.cge_flags |= CGE_INVERT;\r\nelem = (buffer[26]<<8) | buffer[27];\r\nfor (i = 0; i < 4; i++) {\r\nif (elem >= ch->firsts[i] &&\r\nelem < ch->firsts[i] + ch->counts[i]) {\r\ncge.cge_srctype = i;\r\ncge.cge_srcunit = elem-ch->firsts[i];\r\n}\r\n}\r\n}\r\nif ((buffer[22] & 0x30) == 0x30) {\r\ncge.cge_flags |= CGE_IDLUN;\r\ncge.cge_id = buffer[23];\r\ncge.cge_lun = buffer[22] & 7;\r\n}\r\nif (buffer[9] & 0x80) {\r\ncge.cge_flags |= CGE_PVOLTAG;\r\nmemcpy(cge.cge_pvoltag,buffer+28,36);\r\n}\r\nif (buffer[9] & 0x40) {\r\ncge.cge_flags |= CGE_AVOLTAG;\r\nmemcpy(cge.cge_avoltag,buffer+64,36);\r\n}\r\n} else if (ch->voltags) {\r\nch->voltags = 0;\r\nVPRINTK(KERN_INFO, "device has no volume tag support\n");\r\ngoto voltag_retry;\r\n}\r\nkfree(buffer);\r\nmutex_unlock(&ch->lock);\r\nif (copy_to_user(argp, &cge, sizeof (cge)))\r\nreturn -EFAULT;\r\nreturn result;\r\n}\r\ncase CHIOINITELEM:\r\n{\r\nmutex_lock(&ch->lock);\r\nretval = ch_init_elem(ch);\r\nmutex_unlock(&ch->lock);\r\nreturn retval;\r\n}\r\ncase CHIOSVOLTAG:\r\n{\r\nstruct changer_set_voltag csv;\r\nint elem;\r\nif (copy_from_user(&csv, argp, sizeof(csv)))\r\nreturn -EFAULT;\r\nif (0 != ch_checkrange(ch, csv.csv_type, csv.csv_unit)) {\r\nDPRINTK("CHIOSVOLTAG: invalid parameter\n");\r\nreturn -EBADSLT;\r\n}\r\nelem = ch->firsts[csv.csv_type] + csv.csv_unit;\r\nmutex_lock(&ch->lock);\r\nretval = ch_set_voltag(ch, elem,\r\ncsv.csv_flags & CSV_AVOLTAG,\r\ncsv.csv_flags & CSV_CLEARTAG,\r\ncsv.csv_voltag);\r\nmutex_unlock(&ch->lock);\r\nreturn retval;\r\n}\r\ndefault:\r\nreturn scsi_ioctl(ch->device, cmd, argp);\r\n}\r\n}\r\nstatic long ch_ioctl_compat(struct file * file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nscsi_changer *ch = file->private_data;\r\nswitch (cmd) {\r\ncase CHIOGPARAMS:\r\ncase CHIOGVPARAMS:\r\ncase CHIOPOSITION:\r\ncase CHIOMOVE:\r\ncase CHIOEXCHANGE:\r\ncase CHIOGELEM:\r\ncase CHIOINITELEM:\r\ncase CHIOSVOLTAG:\r\nreturn ch_ioctl(file, cmd, arg);\r\ncase CHIOGSTATUS32:\r\n{\r\nstruct changer_element_status32 ces32;\r\nunsigned char __user *data;\r\nif (copy_from_user(&ces32, (void __user *)arg, sizeof (ces32)))\r\nreturn -EFAULT;\r\nif (ces32.ces_type < 0 || ces32.ces_type >= CH_TYPES)\r\nreturn -EINVAL;\r\ndata = compat_ptr(ces32.ces_data);\r\nreturn ch_gstatus(ch, ces32.ces_type, data);\r\n}\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int ch_probe(struct device *dev)\r\n{\r\nstruct scsi_device *sd = to_scsi_device(dev);\r\nstruct device *class_dev;\r\nint ret;\r\nscsi_changer *ch;\r\nif (sd->type != TYPE_MEDIUM_CHANGER)\r\nreturn -ENODEV;\r\nch = kzalloc(sizeof(*ch), GFP_KERNEL);\r\nif (NULL == ch)\r\nreturn -ENOMEM;\r\nidr_preload(GFP_KERNEL);\r\nspin_lock(&ch_index_lock);\r\nret = idr_alloc(&ch_index_idr, ch, 0, CH_MAX_DEVS + 1, GFP_NOWAIT);\r\nspin_unlock(&ch_index_lock);\r\nidr_preload_end();\r\nif (ret < 0) {\r\nif (ret == -ENOSPC)\r\nret = -ENODEV;\r\ngoto free_ch;\r\n}\r\nch->minor = ret;\r\nsprintf(ch->name,"ch%d",ch->minor);\r\nclass_dev = device_create(ch_sysfs_class, dev,\r\nMKDEV(SCSI_CHANGER_MAJOR, ch->minor), ch,\r\n"s%s", ch->name);\r\nif (IS_ERR(class_dev)) {\r\nprintk(KERN_WARNING "ch%d: device_create failed\n",\r\nch->minor);\r\nret = PTR_ERR(class_dev);\r\ngoto remove_idr;\r\n}\r\nmutex_init(&ch->lock);\r\nch->device = sd;\r\nch_readconfig(ch);\r\nif (init)\r\nch_init_elem(ch);\r\ndev_set_drvdata(dev, ch);\r\nsdev_printk(KERN_INFO, sd, "Attached scsi changer %s\n", ch->name);\r\nreturn 0;\r\nremove_idr:\r\nidr_remove(&ch_index_idr, ch->minor);\r\nfree_ch:\r\nkfree(ch);\r\nreturn ret;\r\n}\r\nstatic int ch_remove(struct device *dev)\r\n{\r\nscsi_changer *ch = dev_get_drvdata(dev);\r\nspin_lock(&ch_index_lock);\r\nidr_remove(&ch_index_idr, ch->minor);\r\nspin_unlock(&ch_index_lock);\r\ndevice_destroy(ch_sysfs_class, MKDEV(SCSI_CHANGER_MAJOR,ch->minor));\r\nkfree(ch->dt);\r\nkfree(ch);\r\nreturn 0;\r\n}\r\nstatic int __init init_ch_module(void)\r\n{\r\nint rc;\r\nprintk(KERN_INFO "SCSI Media Changer driver v" VERSION " \n");\r\nch_sysfs_class = class_create(THIS_MODULE, "scsi_changer");\r\nif (IS_ERR(ch_sysfs_class)) {\r\nrc = PTR_ERR(ch_sysfs_class);\r\nreturn rc;\r\n}\r\nrc = register_chrdev(SCSI_CHANGER_MAJOR,"ch",&changer_fops);\r\nif (rc < 0) {\r\nprintk("Unable to get major %d for SCSI-Changer\n",\r\nSCSI_CHANGER_MAJOR);\r\ngoto fail1;\r\n}\r\nrc = scsi_register_driver(&ch_template.gendrv);\r\nif (rc < 0)\r\ngoto fail2;\r\nreturn 0;\r\nfail2:\r\nunregister_chrdev(SCSI_CHANGER_MAJOR, "ch");\r\nfail1:\r\nclass_destroy(ch_sysfs_class);\r\nreturn rc;\r\n}\r\nstatic void __exit exit_ch_module(void)\r\n{\r\nscsi_unregister_driver(&ch_template.gendrv);\r\nunregister_chrdev(SCSI_CHANGER_MAJOR, "ch");\r\nclass_destroy(ch_sysfs_class);\r\nidr_destroy(&ch_index_idr);\r\n}
