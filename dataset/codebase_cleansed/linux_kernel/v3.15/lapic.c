static inline void apic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\r\n{\r\n*((u32 *) (apic->regs + reg_off)) = val;\r\n}\r\nstatic inline int apic_test_vector(int vec, void *bitmap)\r\n{\r\nreturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\r\n}\r\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nreturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\r\napic_test_vector(vector, apic->regs + APIC_IRR);\r\n}\r\nstatic inline void apic_set_vector(int vec, void *bitmap)\r\n{\r\nset_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\r\n}\r\nstatic inline void apic_clear_vector(int vec, void *bitmap)\r\n{\r\nclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\r\n}\r\nstatic inline int __apic_test_and_set_vector(int vec, void *bitmap)\r\n{\r\nreturn __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\r\n}\r\nstatic inline int __apic_test_and_clear_vector(int vec, void *bitmap)\r\n{\r\nreturn __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\r\n}\r\nstatic inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\r\n{\r\nif ((kvm_apic_get_reg(apic, APIC_SPIV) ^ val) & APIC_SPIV_APIC_ENABLED) {\r\nif (val & APIC_SPIV_APIC_ENABLED)\r\nstatic_key_slow_dec_deferred(&apic_sw_disabled);\r\nelse\r\nstatic_key_slow_inc(&apic_sw_disabled.key);\r\n}\r\napic_set_reg(apic, APIC_SPIV, val);\r\n}\r\nstatic inline int apic_enabled(struct kvm_lapic *apic)\r\n{\r\nreturn kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);\r\n}\r\nstatic inline int kvm_apic_id(struct kvm_lapic *apic)\r\n{\r\nreturn (kvm_apic_get_reg(apic, APIC_ID) >> 24) & 0xff;\r\n}\r\nstatic void recalculate_apic_map(struct kvm *kvm)\r\n{\r\nstruct kvm_apic_map *new, *old = NULL;\r\nstruct kvm_vcpu *vcpu;\r\nint i;\r\nnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\r\nmutex_lock(&kvm->arch.apic_map_lock);\r\nif (!new)\r\ngoto out;\r\nnew->ldr_bits = 8;\r\nnew->cid_shift = 8;\r\nnew->cid_mask = 0;\r\nnew->lid_mask = 0xff;\r\nkvm_for_each_vcpu(i, vcpu, kvm) {\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nu16 cid, lid;\r\nu32 ldr;\r\nif (!kvm_apic_present(vcpu))\r\ncontinue;\r\nif (apic_x2apic_mode(apic)) {\r\nnew->ldr_bits = 32;\r\nnew->cid_shift = 16;\r\nnew->cid_mask = (1 << KVM_X2APIC_CID_BITS) - 1;\r\nnew->lid_mask = 0xffff;\r\n} else if (kvm_apic_sw_enabled(apic) &&\r\n!new->cid_mask &&\r\nkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\r\nnew->cid_shift = 4;\r\nnew->cid_mask = 0xf;\r\nnew->lid_mask = 0xf;\r\n}\r\nnew->phys_map[kvm_apic_id(apic)] = apic;\r\nldr = kvm_apic_get_reg(apic, APIC_LDR);\r\ncid = apic_cluster_id(new, ldr);\r\nlid = apic_logical_id(new, ldr);\r\nif (lid)\r\nnew->logical_map[cid][ffs(lid) - 1] = apic;\r\n}\r\nout:\r\nold = rcu_dereference_protected(kvm->arch.apic_map,\r\nlockdep_is_held(&kvm->arch.apic_map_lock));\r\nrcu_assign_pointer(kvm->arch.apic_map, new);\r\nmutex_unlock(&kvm->arch.apic_map_lock);\r\nif (old)\r\nkfree_rcu(old, rcu);\r\nkvm_vcpu_request_scan_ioapic(kvm);\r\n}\r\nstatic inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\r\n{\r\napic_set_reg(apic, APIC_ID, id << 24);\r\nrecalculate_apic_map(apic->vcpu->kvm);\r\n}\r\nstatic inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\r\n{\r\napic_set_reg(apic, APIC_LDR, id);\r\nrecalculate_apic_map(apic->vcpu->kvm);\r\n}\r\nstatic inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)\r\n{\r\nreturn !(kvm_apic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);\r\n}\r\nstatic inline int apic_lvt_vector(struct kvm_lapic *apic, int lvt_type)\r\n{\r\nreturn kvm_apic_get_reg(apic, lvt_type) & APIC_VECTOR_MASK;\r\n}\r\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\r\n{\r\nreturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\r\napic->lapic_timer.timer_mode_mask) == APIC_LVT_TIMER_ONESHOT);\r\n}\r\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\r\n{\r\nreturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\r\napic->lapic_timer.timer_mode_mask) == APIC_LVT_TIMER_PERIODIC);\r\n}\r\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\r\n{\r\nreturn ((kvm_apic_get_reg(apic, APIC_LVTT) &\r\napic->lapic_timer.timer_mode_mask) ==\r\nAPIC_LVT_TIMER_TSCDEADLINE);\r\n}\r\nstatic inline int apic_lvt_nmi_mode(u32 lvt_val)\r\n{\r\nreturn (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;\r\n}\r\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nstruct kvm_cpuid_entry2 *feat;\r\nu32 v = APIC_VERSION;\r\nif (!kvm_vcpu_has_lapic(vcpu))\r\nreturn;\r\nfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\r\nif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\r\nv |= APIC_LVR_DIRECTED_EOI;\r\napic_set_reg(apic, APIC_LVR, v);\r\n}\r\nstatic int find_highest_vector(void *bitmap)\r\n{\r\nint vec;\r\nu32 *reg;\r\nfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\r\nvec >= 0; vec -= APIC_VECTORS_PER_REG) {\r\nreg = bitmap + REG_POS(vec);\r\nif (*reg)\r\nreturn fls(*reg) - 1 + vec;\r\n}\r\nreturn -1;\r\n}\r\nstatic u8 count_vectors(void *bitmap)\r\n{\r\nint vec;\r\nu32 *reg;\r\nu8 count = 0;\r\nfor (vec = 0; vec < MAX_APIC_VECTOR; vec += APIC_VECTORS_PER_REG) {\r\nreg = bitmap + REG_POS(vec);\r\ncount += hweight32(*reg);\r\n}\r\nreturn count;\r\n}\r\nvoid kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir)\r\n{\r\nu32 i, pir_val;\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nfor (i = 0; i <= 7; i++) {\r\npir_val = xchg(&pir[i], 0);\r\nif (pir_val)\r\n*((u32 *)(apic->regs + APIC_IRR + i * 0x10)) |= pir_val;\r\n}\r\n}\r\nstatic inline void apic_set_irr(int vec, struct kvm_lapic *apic)\r\n{\r\napic->irr_pending = true;\r\napic_set_vector(vec, apic->regs + APIC_IRR);\r\n}\r\nstatic inline int apic_search_irr(struct kvm_lapic *apic)\r\n{\r\nreturn find_highest_vector(apic->regs + APIC_IRR);\r\n}\r\nstatic inline int apic_find_highest_irr(struct kvm_lapic *apic)\r\n{\r\nint result;\r\nif (!apic->irr_pending)\r\nreturn -1;\r\nkvm_x86_ops->sync_pir_to_irr(apic->vcpu);\r\nresult = apic_search_irr(apic);\r\nASSERT(result == -1 || result >= 16);\r\nreturn result;\r\n}\r\nstatic inline void apic_clear_irr(int vec, struct kvm_lapic *apic)\r\n{\r\napic->irr_pending = false;\r\napic_clear_vector(vec, apic->regs + APIC_IRR);\r\nif (apic_search_irr(apic) != -1)\r\napic->irr_pending = true;\r\n}\r\nstatic inline void apic_set_isr(int vec, struct kvm_lapic *apic)\r\n{\r\nif (!__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))\r\n++apic->isr_count;\r\nBUG_ON(apic->isr_count > MAX_APIC_VECTOR);\r\napic->highest_isr_cache = vec;\r\n}\r\nstatic inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\r\n{\r\nif (__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\r\n--apic->isr_count;\r\nBUG_ON(apic->isr_count < 0);\r\napic->highest_isr_cache = -1;\r\n}\r\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\r\n{\r\nint highest_irr;\r\nif (!kvm_vcpu_has_lapic(vcpu))\r\nreturn 0;\r\nhighest_irr = apic_find_highest_irr(vcpu->arch.apic);\r\nreturn highest_irr;\r\n}\r\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\r\nunsigned long *dest_map)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nreturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\r\nirq->level, irq->trig_mode, dest_map);\r\n}\r\nstatic int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\r\n{\r\nreturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\r\nsizeof(val));\r\n}\r\nstatic int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\r\n{\r\nreturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\r\nsizeof(*val));\r\n}\r\nstatic inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\r\n{\r\nreturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\r\n}\r\nstatic bool pv_eoi_get_pending(struct kvm_vcpu *vcpu)\r\n{\r\nu8 val;\r\nif (pv_eoi_get_user(vcpu, &val) < 0)\r\napic_debug("Can't read EOI MSR value: 0x%llx\n",\r\n(unsigned long long)vcpu->arch.pv_eoi.msr_val);\r\nreturn val & 0x1;\r\n}\r\nstatic void pv_eoi_set_pending(struct kvm_vcpu *vcpu)\r\n{\r\nif (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) < 0) {\r\napic_debug("Can't set EOI MSR value: 0x%llx\n",\r\n(unsigned long long)vcpu->arch.pv_eoi.msr_val);\r\nreturn;\r\n}\r\n__set_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\r\n}\r\nstatic void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\r\n{\r\nif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\r\napic_debug("Can't clear EOI MSR value: 0x%llx\n",\r\n(unsigned long long)vcpu->arch.pv_eoi.msr_val);\r\nreturn;\r\n}\r\n__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\r\n}\r\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\r\n{\r\nint result;\r\nif (!apic->isr_count)\r\nreturn -1;\r\nif (likely(apic->highest_isr_cache != -1))\r\nreturn apic->highest_isr_cache;\r\nresult = find_highest_vector(apic->regs + APIC_ISR);\r\nASSERT(result == -1 || result >= 16);\r\nreturn result;\r\n}\r\nvoid kvm_apic_update_tmr(struct kvm_vcpu *vcpu, u32 *tmr)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\napic_set_reg(apic, APIC_TMR + 0x10 * i, tmr[i]);\r\n}\r\nstatic void apic_update_ppr(struct kvm_lapic *apic)\r\n{\r\nu32 tpr, isrv, ppr, old_ppr;\r\nint isr;\r\nold_ppr = kvm_apic_get_reg(apic, APIC_PROCPRI);\r\ntpr = kvm_apic_get_reg(apic, APIC_TASKPRI);\r\nisr = apic_find_highest_isr(apic);\r\nisrv = (isr != -1) ? isr : 0;\r\nif ((tpr & 0xf0) >= (isrv & 0xf0))\r\nppr = tpr & 0xff;\r\nelse\r\nppr = isrv & 0xf0;\r\napic_debug("vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x",\r\napic, ppr, isr, isrv);\r\nif (old_ppr != ppr) {\r\napic_set_reg(apic, APIC_PROCPRI, ppr);\r\nif (ppr < old_ppr)\r\nkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\r\n}\r\n}\r\nstatic void apic_set_tpr(struct kvm_lapic *apic, u32 tpr)\r\n{\r\napic_set_reg(apic, APIC_TASKPRI, tpr);\r\napic_update_ppr(apic);\r\n}\r\nint kvm_apic_match_physical_addr(struct kvm_lapic *apic, u16 dest)\r\n{\r\nreturn dest == 0xff || kvm_apic_id(apic) == dest;\r\n}\r\nint kvm_apic_match_logical_addr(struct kvm_lapic *apic, u8 mda)\r\n{\r\nint result = 0;\r\nu32 logical_id;\r\nif (apic_x2apic_mode(apic)) {\r\nlogical_id = kvm_apic_get_reg(apic, APIC_LDR);\r\nreturn logical_id & mda;\r\n}\r\nlogical_id = GET_APIC_LOGICAL_ID(kvm_apic_get_reg(apic, APIC_LDR));\r\nswitch (kvm_apic_get_reg(apic, APIC_DFR)) {\r\ncase APIC_DFR_FLAT:\r\nif (logical_id & mda)\r\nresult = 1;\r\nbreak;\r\ncase APIC_DFR_CLUSTER:\r\nif (((logical_id >> 4) == (mda >> 0x4))\r\n&& (logical_id & mda & 0xf))\r\nresult = 1;\r\nbreak;\r\ndefault:\r\napic_debug("Bad DFR vcpu %d: %08x\n",\r\napic->vcpu->vcpu_id, kvm_apic_get_reg(apic, APIC_DFR));\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nint kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\r\nint short_hand, int dest, int dest_mode)\r\n{\r\nint result = 0;\r\nstruct kvm_lapic *target = vcpu->arch.apic;\r\napic_debug("target %p, source %p, dest 0x%x, "\r\n"dest_mode 0x%x, short_hand 0x%x\n",\r\ntarget, source, dest, dest_mode, short_hand);\r\nASSERT(target);\r\nswitch (short_hand) {\r\ncase APIC_DEST_NOSHORT:\r\nif (dest_mode == 0)\r\nresult = kvm_apic_match_physical_addr(target, dest);\r\nelse\r\nresult = kvm_apic_match_logical_addr(target, dest);\r\nbreak;\r\ncase APIC_DEST_SELF:\r\nresult = (target == source);\r\nbreak;\r\ncase APIC_DEST_ALLINC:\r\nresult = 1;\r\nbreak;\r\ncase APIC_DEST_ALLBUT:\r\nresult = (target != source);\r\nbreak;\r\ndefault:\r\napic_debug("kvm: apic: Bad dest shorthand value %x\n",\r\nshort_hand);\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nbool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\r\nstruct kvm_lapic_irq *irq, int *r, unsigned long *dest_map)\r\n{\r\nstruct kvm_apic_map *map;\r\nunsigned long bitmap = 1;\r\nstruct kvm_lapic **dst;\r\nint i;\r\nbool ret = false;\r\n*r = -1;\r\nif (irq->shorthand == APIC_DEST_SELF) {\r\n*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\r\nreturn true;\r\n}\r\nif (irq->shorthand)\r\nreturn false;\r\nrcu_read_lock();\r\nmap = rcu_dereference(kvm->arch.apic_map);\r\nif (!map)\r\ngoto out;\r\nif (irq->dest_mode == 0) {\r\nif (irq->delivery_mode == APIC_DM_LOWEST ||\r\nirq->dest_id == 0xff)\r\ngoto out;\r\ndst = &map->phys_map[irq->dest_id & 0xff];\r\n} else {\r\nu32 mda = irq->dest_id << (32 - map->ldr_bits);\r\ndst = map->logical_map[apic_cluster_id(map, mda)];\r\nbitmap = apic_logical_id(map, mda);\r\nif (irq->delivery_mode == APIC_DM_LOWEST) {\r\nint l = -1;\r\nfor_each_set_bit(i, &bitmap, 16) {\r\nif (!dst[i])\r\ncontinue;\r\nif (l < 0)\r\nl = i;\r\nelse if (kvm_apic_compare_prio(dst[i]->vcpu, dst[l]->vcpu) < 0)\r\nl = i;\r\n}\r\nbitmap = (l >= 0) ? 1 << l : 0;\r\n}\r\n}\r\nfor_each_set_bit(i, &bitmap, 16) {\r\nif (!dst[i])\r\ncontinue;\r\nif (*r < 0)\r\n*r = 0;\r\n*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\r\n}\r\nret = true;\r\nout:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\r\nint vector, int level, int trig_mode,\r\nunsigned long *dest_map)\r\n{\r\nint result = 0;\r\nstruct kvm_vcpu *vcpu = apic->vcpu;\r\nswitch (delivery_mode) {\r\ncase APIC_DM_LOWEST:\r\nvcpu->arch.apic_arb_prio++;\r\ncase APIC_DM_FIXED:\r\nif (unlikely(!apic_enabled(apic)))\r\nbreak;\r\nresult = 1;\r\nif (dest_map)\r\n__set_bit(vcpu->vcpu_id, dest_map);\r\nif (kvm_x86_ops->deliver_posted_interrupt)\r\nkvm_x86_ops->deliver_posted_interrupt(vcpu, vector);\r\nelse {\r\napic_set_irr(vector, apic);\r\nkvm_make_request(KVM_REQ_EVENT, vcpu);\r\nkvm_vcpu_kick(vcpu);\r\n}\r\ntrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\r\ntrig_mode, vector, false);\r\nbreak;\r\ncase APIC_DM_REMRD:\r\nresult = 1;\r\nvcpu->arch.pv.pv_unhalted = 1;\r\nkvm_make_request(KVM_REQ_EVENT, vcpu);\r\nkvm_vcpu_kick(vcpu);\r\nbreak;\r\ncase APIC_DM_SMI:\r\napic_debug("Ignoring guest SMI\n");\r\nbreak;\r\ncase APIC_DM_NMI:\r\nresult = 1;\r\nkvm_inject_nmi(vcpu);\r\nkvm_vcpu_kick(vcpu);\r\nbreak;\r\ncase APIC_DM_INIT:\r\nif (!trig_mode || level) {\r\nresult = 1;\r\napic->pending_events = (1UL << KVM_APIC_INIT);\r\nsmp_wmb();\r\nkvm_make_request(KVM_REQ_EVENT, vcpu);\r\nkvm_vcpu_kick(vcpu);\r\n} else {\r\napic_debug("Ignoring de-assert INIT to vcpu %d\n",\r\nvcpu->vcpu_id);\r\n}\r\nbreak;\r\ncase APIC_DM_STARTUP:\r\napic_debug("SIPI to vcpu %d vector 0x%02x\n",\r\nvcpu->vcpu_id, vector);\r\nresult = 1;\r\napic->sipi_vector = vector;\r\nsmp_wmb();\r\nset_bit(KVM_APIC_SIPI, &apic->pending_events);\r\nkvm_make_request(KVM_REQ_EVENT, vcpu);\r\nkvm_vcpu_kick(vcpu);\r\nbreak;\r\ncase APIC_DM_EXTINT:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "TODO: unsupported delivery mode %x\n",\r\ndelivery_mode);\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nint kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\r\n{\r\nreturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\r\n}\r\nstatic void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\r\n{\r\nif (!(kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI) &&\r\nkvm_ioapic_handles_vector(apic->vcpu->kvm, vector)) {\r\nint trigger_mode;\r\nif (apic_test_vector(vector, apic->regs + APIC_TMR))\r\ntrigger_mode = IOAPIC_LEVEL_TRIG;\r\nelse\r\ntrigger_mode = IOAPIC_EDGE_TRIG;\r\nkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\r\n}\r\n}\r\nstatic int apic_set_eoi(struct kvm_lapic *apic)\r\n{\r\nint vector = apic_find_highest_isr(apic);\r\ntrace_kvm_eoi(apic, vector);\r\nif (vector == -1)\r\nreturn vector;\r\napic_clear_isr(vector, apic);\r\napic_update_ppr(apic);\r\nkvm_ioapic_send_eoi(apic, vector);\r\nkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\r\nreturn vector;\r\n}\r\nvoid kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\ntrace_kvm_eoi(apic, vector);\r\nkvm_ioapic_send_eoi(apic, vector);\r\nkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\r\n}\r\nstatic void apic_send_ipi(struct kvm_lapic *apic)\r\n{\r\nu32 icr_low = kvm_apic_get_reg(apic, APIC_ICR);\r\nu32 icr_high = kvm_apic_get_reg(apic, APIC_ICR2);\r\nstruct kvm_lapic_irq irq;\r\nirq.vector = icr_low & APIC_VECTOR_MASK;\r\nirq.delivery_mode = icr_low & APIC_MODE_MASK;\r\nirq.dest_mode = icr_low & APIC_DEST_MASK;\r\nirq.level = icr_low & APIC_INT_ASSERT;\r\nirq.trig_mode = icr_low & APIC_INT_LEVELTRIG;\r\nirq.shorthand = icr_low & APIC_SHORT_MASK;\r\nif (apic_x2apic_mode(apic))\r\nirq.dest_id = icr_high;\r\nelse\r\nirq.dest_id = GET_APIC_DEST_FIELD(icr_high);\r\ntrace_kvm_apic_ipi(icr_low, irq.dest_id);\r\napic_debug("icr_high 0x%x, icr_low 0x%x, "\r\n"short_hand 0x%x, dest 0x%x, trig_mode 0x%x, level 0x%x, "\r\n"dest_mode 0x%x, delivery_mode 0x%x, vector 0x%x\n",\r\nicr_high, icr_low, irq.shorthand, irq.dest_id,\r\nirq.trig_mode, irq.level, irq.dest_mode, irq.delivery_mode,\r\nirq.vector);\r\nkvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);\r\n}\r\nstatic u32 apic_get_tmcct(struct kvm_lapic *apic)\r\n{\r\nktime_t remaining;\r\ns64 ns;\r\nu32 tmcct;\r\nASSERT(apic != NULL);\r\nif (kvm_apic_get_reg(apic, APIC_TMICT) == 0 ||\r\napic->lapic_timer.period == 0)\r\nreturn 0;\r\nremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\r\nif (ktime_to_ns(remaining) < 0)\r\nremaining = ktime_set(0, 0);\r\nns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\r\ntmcct = div64_u64(ns,\r\n(APIC_BUS_CYCLE_NS * apic->divide_count));\r\nreturn tmcct;\r\n}\r\nstatic void __report_tpr_access(struct kvm_lapic *apic, bool write)\r\n{\r\nstruct kvm_vcpu *vcpu = apic->vcpu;\r\nstruct kvm_run *run = vcpu->run;\r\nkvm_make_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu);\r\nrun->tpr_access.rip = kvm_rip_read(vcpu);\r\nrun->tpr_access.is_write = write;\r\n}\r\nstatic inline void report_tpr_access(struct kvm_lapic *apic, bool write)\r\n{\r\nif (apic->vcpu->arch.tpr_access_reporting)\r\n__report_tpr_access(apic, write);\r\n}\r\nstatic u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)\r\n{\r\nu32 val = 0;\r\nif (offset >= LAPIC_MMIO_LENGTH)\r\nreturn 0;\r\nswitch (offset) {\r\ncase APIC_ID:\r\nif (apic_x2apic_mode(apic))\r\nval = kvm_apic_id(apic);\r\nelse\r\nval = kvm_apic_id(apic) << 24;\r\nbreak;\r\ncase APIC_ARBPRI:\r\napic_debug("Access APIC ARBPRI register which is for P6\n");\r\nbreak;\r\ncase APIC_TMCCT:\r\nif (apic_lvtt_tscdeadline(apic))\r\nreturn 0;\r\nval = apic_get_tmcct(apic);\r\nbreak;\r\ncase APIC_PROCPRI:\r\napic_update_ppr(apic);\r\nval = kvm_apic_get_reg(apic, offset);\r\nbreak;\r\ncase APIC_TASKPRI:\r\nreport_tpr_access(apic, false);\r\ndefault:\r\nval = kvm_apic_get_reg(apic, offset);\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\r\n{\r\nreturn container_of(dev, struct kvm_lapic, dev);\r\n}\r\nstatic int apic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\r\nvoid *data)\r\n{\r\nunsigned char alignment = offset & 0xf;\r\nu32 result;\r\nstatic const u64 rmask = 0x43ff01ffffffe70cULL;\r\nif ((alignment + len) > 4) {\r\napic_debug("KVM_APIC_READ: alignment error %x %d\n",\r\noffset, len);\r\nreturn 1;\r\n}\r\nif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\r\napic_debug("KVM_APIC_READ: read reserved register %x\n",\r\noffset);\r\nreturn 1;\r\n}\r\nresult = __apic_read(apic, offset & ~0xf);\r\ntrace_kvm_apic_read(offset, result);\r\nswitch (len) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\nmemcpy(data, (char *)&result + alignment, len);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Local APIC read with len = %x, "\r\n"should be 1,2, or 4 instead\n", len);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\r\n{\r\nreturn kvm_apic_hw_enabled(apic) &&\r\naddr >= apic->base_address &&\r\naddr < apic->base_address + LAPIC_MMIO_LENGTH;\r\n}\r\nstatic int apic_mmio_read(struct kvm_io_device *this,\r\ngpa_t address, int len, void *data)\r\n{\r\nstruct kvm_lapic *apic = to_lapic(this);\r\nu32 offset = address - apic->base_address;\r\nif (!apic_mmio_in_range(apic, address))\r\nreturn -EOPNOTSUPP;\r\napic_reg_read(apic, offset, len, data);\r\nreturn 0;\r\n}\r\nstatic void update_divide_count(struct kvm_lapic *apic)\r\n{\r\nu32 tmp1, tmp2, tdcr;\r\ntdcr = kvm_apic_get_reg(apic, APIC_TDCR);\r\ntmp1 = tdcr & 0xf;\r\ntmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\r\napic->divide_count = 0x1 << (tmp2 & 0x7);\r\napic_debug("timer divide count is 0x%x\n",\r\napic->divide_count);\r\n}\r\nstatic void start_apic_timer(struct kvm_lapic *apic)\r\n{\r\nktime_t now;\r\natomic_set(&apic->lapic_timer.pending, 0);\r\nif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {\r\nnow = apic->lapic_timer.timer.base->get_time();\r\napic->lapic_timer.period = (u64)kvm_apic_get_reg(apic, APIC_TMICT)\r\n* APIC_BUS_CYCLE_NS * apic->divide_count;\r\nif (!apic->lapic_timer.period)\r\nreturn;\r\nif (apic_lvtt_period(apic)) {\r\ns64 min_period = min_timer_period_us * 1000LL;\r\nif (apic->lapic_timer.period < min_period) {\r\npr_info_ratelimited(\r\n"kvm: vcpu %i: requested %lld ns "\r\n"lapic timer period limited to %lld ns\n",\r\napic->vcpu->vcpu_id,\r\napic->lapic_timer.period, min_period);\r\napic->lapic_timer.period = min_period;\r\n}\r\n}\r\nhrtimer_start(&apic->lapic_timer.timer,\r\nktime_add_ns(now, apic->lapic_timer.period),\r\nHRTIMER_MODE_ABS);\r\napic_debug("%s: bus cycle is %" PRId64 "ns, now 0x%016"\r\nPRIx64 ", "\r\n"timer initial count 0x%x, period %lldns, "\r\n"expire @ 0x%016" PRIx64 ".\n", __func__,\r\nAPIC_BUS_CYCLE_NS, ktime_to_ns(now),\r\nkvm_apic_get_reg(apic, APIC_TMICT),\r\napic->lapic_timer.period,\r\nktime_to_ns(ktime_add_ns(now,\r\napic->lapic_timer.period)));\r\n} else if (apic_lvtt_tscdeadline(apic)) {\r\nu64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;\r\nu64 ns = 0;\r\nstruct kvm_vcpu *vcpu = apic->vcpu;\r\nunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\r\nunsigned long flags;\r\nif (unlikely(!tscdeadline || !this_tsc_khz))\r\nreturn;\r\nlocal_irq_save(flags);\r\nnow = apic->lapic_timer.timer.base->get_time();\r\nguest_tsc = kvm_x86_ops->read_l1_tsc(vcpu, native_read_tsc());\r\nif (likely(tscdeadline > guest_tsc)) {\r\nns = (tscdeadline - guest_tsc) * 1000000ULL;\r\ndo_div(ns, this_tsc_khz);\r\n}\r\nhrtimer_start(&apic->lapic_timer.timer,\r\nktime_add_ns(now, ns), HRTIMER_MODE_ABS);\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nstatic void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\r\n{\r\nint nmi_wd_enabled = apic_lvt_nmi_mode(kvm_apic_get_reg(apic, APIC_LVT0));\r\nif (apic_lvt_nmi_mode(lvt0_val)) {\r\nif (!nmi_wd_enabled) {\r\napic_debug("Receive NMI setting on APIC_LVT0 "\r\n"for cpu %d\n", apic->vcpu->vcpu_id);\r\napic->vcpu->kvm->arch.vapics_in_nmi_mode++;\r\n}\r\n} else if (nmi_wd_enabled)\r\napic->vcpu->kvm->arch.vapics_in_nmi_mode--;\r\n}\r\nstatic int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\r\n{\r\nint ret = 0;\r\ntrace_kvm_apic_write(reg, val);\r\nswitch (reg) {\r\ncase APIC_ID:\r\nif (!apic_x2apic_mode(apic))\r\nkvm_apic_set_id(apic, val >> 24);\r\nelse\r\nret = 1;\r\nbreak;\r\ncase APIC_TASKPRI:\r\nreport_tpr_access(apic, true);\r\napic_set_tpr(apic, val & 0xff);\r\nbreak;\r\ncase APIC_EOI:\r\napic_set_eoi(apic);\r\nbreak;\r\ncase APIC_LDR:\r\nif (!apic_x2apic_mode(apic))\r\nkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\r\nelse\r\nret = 1;\r\nbreak;\r\ncase APIC_DFR:\r\nif (!apic_x2apic_mode(apic)) {\r\napic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\r\nrecalculate_apic_map(apic->vcpu->kvm);\r\n} else\r\nret = 1;\r\nbreak;\r\ncase APIC_SPIV: {\r\nu32 mask = 0x3ff;\r\nif (kvm_apic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\r\nmask |= APIC_SPIV_DIRECTED_EOI;\r\napic_set_spiv(apic, val & mask);\r\nif (!(val & APIC_SPIV_APIC_ENABLED)) {\r\nint i;\r\nu32 lvt_val;\r\nfor (i = 0; i < APIC_LVT_NUM; i++) {\r\nlvt_val = kvm_apic_get_reg(apic,\r\nAPIC_LVTT + 0x10 * i);\r\napic_set_reg(apic, APIC_LVTT + 0x10 * i,\r\nlvt_val | APIC_LVT_MASKED);\r\n}\r\natomic_set(&apic->lapic_timer.pending, 0);\r\n}\r\nbreak;\r\n}\r\ncase APIC_ICR:\r\napic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\r\napic_send_ipi(apic);\r\nbreak;\r\ncase APIC_ICR2:\r\nif (!apic_x2apic_mode(apic))\r\nval &= 0xff000000;\r\napic_set_reg(apic, APIC_ICR2, val);\r\nbreak;\r\ncase APIC_LVT0:\r\napic_manage_nmi_watchdog(apic, val);\r\ncase APIC_LVTTHMR:\r\ncase APIC_LVTPC:\r\ncase APIC_LVT1:\r\ncase APIC_LVTERR:\r\nif (!kvm_apic_sw_enabled(apic))\r\nval |= APIC_LVT_MASKED;\r\nval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\r\napic_set_reg(apic, reg, val);\r\nbreak;\r\ncase APIC_LVTT:\r\nif ((kvm_apic_get_reg(apic, APIC_LVTT) &\r\napic->lapic_timer.timer_mode_mask) !=\r\n(val & apic->lapic_timer.timer_mode_mask))\r\nhrtimer_cancel(&apic->lapic_timer.timer);\r\nif (!kvm_apic_sw_enabled(apic))\r\nval |= APIC_LVT_MASKED;\r\nval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\r\napic_set_reg(apic, APIC_LVTT, val);\r\nbreak;\r\ncase APIC_TMICT:\r\nif (apic_lvtt_tscdeadline(apic))\r\nbreak;\r\nhrtimer_cancel(&apic->lapic_timer.timer);\r\napic_set_reg(apic, APIC_TMICT, val);\r\nstart_apic_timer(apic);\r\nbreak;\r\ncase APIC_TDCR:\r\nif (val & 4)\r\napic_debug("KVM_WRITE:TDCR %x\n", val);\r\napic_set_reg(apic, APIC_TDCR, val);\r\nupdate_divide_count(apic);\r\nbreak;\r\ncase APIC_ESR:\r\nif (apic_x2apic_mode(apic) && val != 0) {\r\napic_debug("KVM_WRITE:ESR not zero %x\n", val);\r\nret = 1;\r\n}\r\nbreak;\r\ncase APIC_SELF_IPI:\r\nif (apic_x2apic_mode(apic)) {\r\napic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\r\n} else\r\nret = 1;\r\nbreak;\r\ndefault:\r\nret = 1;\r\nbreak;\r\n}\r\nif (ret)\r\napic_debug("Local APIC Write to read-only register %x\n", reg);\r\nreturn ret;\r\n}\r\nstatic int apic_mmio_write(struct kvm_io_device *this,\r\ngpa_t address, int len, const void *data)\r\n{\r\nstruct kvm_lapic *apic = to_lapic(this);\r\nunsigned int offset = address - apic->base_address;\r\nu32 val;\r\nif (!apic_mmio_in_range(apic, address))\r\nreturn -EOPNOTSUPP;\r\nif (len != 4 || (offset & 0xf)) {\r\napic_debug("apic write: bad size=%d %lx\n", len, (long)address);\r\nreturn 0;\r\n}\r\nval = *(u32*)data;\r\nif (offset != APIC_EOI)\r\napic_debug("%s: offset 0x%x with length 0x%x, and value is "\r\n"0x%x\n", __func__, offset, len, val);\r\napic_reg_write(apic, offset & 0xff0, val);\r\nreturn 0;\r\n}\r\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\r\n{\r\nif (kvm_vcpu_has_lapic(vcpu))\r\napic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\r\n}\r\nvoid kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)\r\n{\r\nu32 val = 0;\r\noffset &= 0xff0;\r\napic_reg_read(vcpu->arch.apic, offset, 4, &val);\r\napic_reg_write(vcpu->arch.apic, offset, val);\r\n}\r\nvoid kvm_free_lapic(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nif (!vcpu->arch.apic)\r\nreturn;\r\nhrtimer_cancel(&apic->lapic_timer.timer);\r\nif (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))\r\nstatic_key_slow_dec_deferred(&apic_hw_disabled);\r\nif (!(kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_APIC_ENABLED))\r\nstatic_key_slow_dec_deferred(&apic_sw_disabled);\r\nif (apic->regs)\r\nfree_page((unsigned long)apic->regs);\r\nkfree(apic);\r\n}\r\nu64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nif (!kvm_vcpu_has_lapic(vcpu) || apic_lvtt_oneshot(apic) ||\r\napic_lvtt_period(apic))\r\nreturn 0;\r\nreturn apic->lapic_timer.tscdeadline;\r\n}\r\nvoid kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nif (!kvm_vcpu_has_lapic(vcpu) || apic_lvtt_oneshot(apic) ||\r\napic_lvtt_period(apic))\r\nreturn;\r\nhrtimer_cancel(&apic->lapic_timer.timer);\r\napic->lapic_timer.tscdeadline = data;\r\nstart_apic_timer(apic);\r\n}\r\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nif (!kvm_vcpu_has_lapic(vcpu))\r\nreturn;\r\napic_set_tpr(apic, ((cr8 & 0x0f) << 4)\r\n| (kvm_apic_get_reg(apic, APIC_TASKPRI) & 4));\r\n}\r\nu64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\r\n{\r\nu64 tpr;\r\nif (!kvm_vcpu_has_lapic(vcpu))\r\nreturn 0;\r\ntpr = (u64) kvm_apic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\r\nreturn (tpr & 0xf0) >> 4;\r\n}\r\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\r\n{\r\nu64 old_value = vcpu->arch.apic_base;\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nif (!apic) {\r\nvalue |= MSR_IA32_APICBASE_BSP;\r\nvcpu->arch.apic_base = value;\r\nreturn;\r\n}\r\nif (!kvm_vcpu_is_bsp(apic->vcpu))\r\nvalue &= ~MSR_IA32_APICBASE_BSP;\r\nvcpu->arch.apic_base = value;\r\nif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\r\nif (value & MSR_IA32_APICBASE_ENABLE)\r\nstatic_key_slow_dec_deferred(&apic_hw_disabled);\r\nelse\r\nstatic_key_slow_inc(&apic_hw_disabled.key);\r\nrecalculate_apic_map(vcpu->kvm);\r\n}\r\nif ((old_value ^ value) & X2APIC_ENABLE) {\r\nif (value & X2APIC_ENABLE) {\r\nu32 id = kvm_apic_id(apic);\r\nu32 ldr = ((id >> 4) << 16) | (1 << (id & 0xf));\r\nkvm_apic_set_ldr(apic, ldr);\r\nkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\r\n} else\r\nkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\r\n}\r\napic->base_address = apic->vcpu->arch.apic_base &\r\nMSR_IA32_APICBASE_BASE;\r\napic_debug("apic base msr is 0x%016" PRIx64 ", and base address is "\r\n"0x%lx.\n", apic->vcpu->arch.apic_base, apic->base_address);\r\n}\r\nvoid kvm_lapic_reset(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_lapic *apic;\r\nint i;\r\napic_debug("%s\n", __func__);\r\nASSERT(vcpu);\r\napic = vcpu->arch.apic;\r\nASSERT(apic != NULL);\r\nhrtimer_cancel(&apic->lapic_timer.timer);\r\nkvm_apic_set_id(apic, vcpu->vcpu_id);\r\nkvm_apic_set_version(apic->vcpu);\r\nfor (i = 0; i < APIC_LVT_NUM; i++)\r\napic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);\r\napic_set_reg(apic, APIC_LVT0,\r\nSET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));\r\napic_set_reg(apic, APIC_DFR, 0xffffffffU);\r\napic_set_spiv(apic, 0xff);\r\napic_set_reg(apic, APIC_TASKPRI, 0);\r\nkvm_apic_set_ldr(apic, 0);\r\napic_set_reg(apic, APIC_ESR, 0);\r\napic_set_reg(apic, APIC_ICR, 0);\r\napic_set_reg(apic, APIC_ICR2, 0);\r\napic_set_reg(apic, APIC_TDCR, 0);\r\napic_set_reg(apic, APIC_TMICT, 0);\r\nfor (i = 0; i < 8; i++) {\r\napic_set_reg(apic, APIC_IRR + 0x10 * i, 0);\r\napic_set_reg(apic, APIC_ISR + 0x10 * i, 0);\r\napic_set_reg(apic, APIC_TMR + 0x10 * i, 0);\r\n}\r\napic->irr_pending = kvm_apic_vid_enabled(vcpu->kvm);\r\napic->isr_count = kvm_apic_vid_enabled(vcpu->kvm);\r\napic->highest_isr_cache = -1;\r\nupdate_divide_count(apic);\r\natomic_set(&apic->lapic_timer.pending, 0);\r\nif (kvm_vcpu_is_bsp(vcpu))\r\nkvm_lapic_set_base(vcpu,\r\nvcpu->arch.apic_base | MSR_IA32_APICBASE_BSP);\r\nvcpu->arch.pv_eoi.msr_val = 0;\r\napic_update_ppr(apic);\r\nvcpu->arch.apic_arb_prio = 0;\r\nvcpu->arch.apic_attention = 0;\r\napic_debug(KERN_INFO "%s: vcpu=%p, id=%d, base_msr="\r\n"0x%016" PRIx64 ", base_address=0x%0lx.\n", __func__,\r\nvcpu, kvm_apic_id(apic),\r\nvcpu->arch.apic_base, apic->base_address);\r\n}\r\nstatic bool lapic_is_periodic(struct kvm_lapic *apic)\r\n{\r\nreturn apic_lvtt_period(apic);\r\n}\r\nint apic_has_pending_timer(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nif (kvm_vcpu_has_lapic(vcpu) && apic_enabled(apic) &&\r\napic_lvt_enabled(apic, APIC_LVTT))\r\nreturn atomic_read(&apic->lapic_timer.pending);\r\nreturn 0;\r\n}\r\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\r\n{\r\nu32 reg = kvm_apic_get_reg(apic, lvt_type);\r\nint vector, mode, trig_mode;\r\nif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\r\nvector = reg & APIC_VECTOR_MASK;\r\nmode = reg & APIC_MODE_MASK;\r\ntrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\r\nreturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\r\nNULL);\r\n}\r\nreturn 0;\r\n}\r\nvoid kvm_apic_nmi_wd_deliver(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nif (apic)\r\nkvm_apic_local_deliver(apic, APIC_LVT0);\r\n}\r\nstatic enum hrtimer_restart apic_timer_fn(struct hrtimer *data)\r\n{\r\nstruct kvm_timer *ktimer = container_of(data, struct kvm_timer, timer);\r\nstruct kvm_lapic *apic = container_of(ktimer, struct kvm_lapic, lapic_timer);\r\nstruct kvm_vcpu *vcpu = apic->vcpu;\r\nwait_queue_head_t *q = &vcpu->wq;\r\nif (!atomic_read(&ktimer->pending)) {\r\natomic_inc(&ktimer->pending);\r\nkvm_make_request(KVM_REQ_PENDING_TIMER, vcpu);\r\n}\r\nif (waitqueue_active(q))\r\nwake_up_interruptible(q);\r\nif (lapic_is_periodic(apic)) {\r\nhrtimer_add_expires_ns(&ktimer->timer, ktimer->period);\r\nreturn HRTIMER_RESTART;\r\n} else\r\nreturn HRTIMER_NORESTART;\r\n}\r\nint kvm_create_lapic(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_lapic *apic;\r\nASSERT(vcpu != NULL);\r\napic_debug("apic_init %d\n", vcpu->vcpu_id);\r\napic = kzalloc(sizeof(*apic), GFP_KERNEL);\r\nif (!apic)\r\ngoto nomem;\r\nvcpu->arch.apic = apic;\r\napic->regs = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (!apic->regs) {\r\nprintk(KERN_ERR "malloc apic regs error for vcpu %x\n",\r\nvcpu->vcpu_id);\r\ngoto nomem_free_apic;\r\n}\r\napic->vcpu = vcpu;\r\nhrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,\r\nHRTIMER_MODE_ABS);\r\napic->lapic_timer.timer.function = apic_timer_fn;\r\nvcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;\r\nkvm_lapic_set_base(vcpu,\r\nAPIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE);\r\nstatic_key_slow_inc(&apic_sw_disabled.key);\r\nkvm_lapic_reset(vcpu);\r\nkvm_iodevice_init(&apic->dev, &apic_mmio_ops);\r\nreturn 0;\r\nnomem_free_apic:\r\nkfree(apic);\r\nnomem:\r\nreturn -ENOMEM;\r\n}\r\nint kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nint highest_irr;\r\nif (!kvm_vcpu_has_lapic(vcpu) || !apic_enabled(apic))\r\nreturn -1;\r\napic_update_ppr(apic);\r\nhighest_irr = apic_find_highest_irr(apic);\r\nif ((highest_irr == -1) ||\r\n((highest_irr & 0xF0) <= kvm_apic_get_reg(apic, APIC_PROCPRI)))\r\nreturn -1;\r\nreturn highest_irr;\r\n}\r\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\r\n{\r\nu32 lvt0 = kvm_apic_get_reg(vcpu->arch.apic, APIC_LVT0);\r\nint r = 0;\r\nif (!kvm_apic_hw_enabled(vcpu->arch.apic))\r\nr = 1;\r\nif ((lvt0 & APIC_LVT_MASKED) == 0 &&\r\nGET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\r\nr = 1;\r\nreturn r;\r\n}\r\nvoid kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nif (!kvm_vcpu_has_lapic(vcpu))\r\nreturn;\r\nif (atomic_read(&apic->lapic_timer.pending) > 0) {\r\nkvm_apic_local_deliver(apic, APIC_LVTT);\r\natomic_set(&apic->lapic_timer.pending, 0);\r\n}\r\n}\r\nint kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)\r\n{\r\nint vector = kvm_apic_has_interrupt(vcpu);\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nif (vector == -1)\r\nreturn -1;\r\napic_set_isr(vector, apic);\r\napic_update_ppr(apic);\r\napic_clear_irr(vector, apic);\r\nreturn vector;\r\n}\r\nvoid kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,\r\nstruct kvm_lapic_state *s)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nkvm_lapic_set_base(vcpu, vcpu->arch.apic_base);\r\napic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));\r\nmemcpy(vcpu->arch.apic->regs, s->regs, sizeof *s);\r\nkvm_apic_set_id(apic, kvm_apic_id(apic));\r\nkvm_apic_set_version(vcpu);\r\napic_update_ppr(apic);\r\nhrtimer_cancel(&apic->lapic_timer.timer);\r\nupdate_divide_count(apic);\r\nstart_apic_timer(apic);\r\napic->irr_pending = true;\r\napic->isr_count = kvm_apic_vid_enabled(vcpu->kvm) ?\r\n1 : count_vectors(apic->regs + APIC_ISR);\r\napic->highest_isr_cache = -1;\r\nkvm_x86_ops->hwapic_isr_update(vcpu->kvm, apic_find_highest_isr(apic));\r\nkvm_make_request(KVM_REQ_EVENT, vcpu);\r\nkvm_rtc_eoi_tracking_restore_one(vcpu);\r\n}\r\nvoid __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)\r\n{\r\nstruct hrtimer *timer;\r\nif (!kvm_vcpu_has_lapic(vcpu))\r\nreturn;\r\ntimer = &vcpu->arch.apic->lapic_timer.timer;\r\nif (hrtimer_cancel(timer))\r\nhrtimer_start_expires(timer, HRTIMER_MODE_ABS);\r\n}\r\nstatic void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\r\nstruct kvm_lapic *apic)\r\n{\r\nbool pending;\r\nint vector;\r\nBUG_ON(!pv_eoi_enabled(vcpu));\r\npending = pv_eoi_get_pending(vcpu);\r\npv_eoi_clr_pending(vcpu);\r\nif (pending)\r\nreturn;\r\nvector = apic_set_eoi(apic);\r\ntrace_kvm_pv_eoi(apic, vector);\r\n}\r\nvoid kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\r\n{\r\nu32 data;\r\nif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\r\napic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\r\nif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\r\nreturn;\r\nkvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\r\nsizeof(u32));\r\napic_set_tpr(vcpu->arch.apic, data & 0xff);\r\n}\r\nstatic void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,\r\nstruct kvm_lapic *apic)\r\n{\r\nif (!pv_eoi_enabled(vcpu) ||\r\napic->irr_pending ||\r\napic->highest_isr_cache == -1 ||\r\nkvm_ioapic_handles_vector(vcpu->kvm, apic->highest_isr_cache)) {\r\nreturn;\r\n}\r\npv_eoi_set_pending(apic->vcpu);\r\n}\r\nvoid kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\r\n{\r\nu32 data, tpr;\r\nint max_irr, max_isr;\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\napic_sync_pv_eoi_to_guest(vcpu, apic);\r\nif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\r\nreturn;\r\ntpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\r\nmax_irr = apic_find_highest_irr(apic);\r\nif (max_irr < 0)\r\nmax_irr = 0;\r\nmax_isr = apic_find_highest_isr(apic);\r\nif (max_isr < 0)\r\nmax_isr = 0;\r\ndata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\r\nkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\r\nsizeof(u32));\r\n}\r\nint kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\r\n{\r\nif (vapic_addr) {\r\nif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\r\n&vcpu->arch.apic->vapic_cache,\r\nvapic_addr, sizeof(u32)))\r\nreturn -EINVAL;\r\n__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\r\n} else {\r\n__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\r\n}\r\nvcpu->arch.apic->vapic_addr = vapic_addr;\r\nreturn 0;\r\n}\r\nint kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nu32 reg = (msr - APIC_BASE_MSR) << 4;\r\nif (!irqchip_in_kernel(vcpu->kvm) || !apic_x2apic_mode(apic))\r\nreturn 1;\r\nif (msr == 0x830)\r\napic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\r\nreturn apic_reg_write(apic, reg, (u32)data);\r\n}\r\nint kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nu32 reg = (msr - APIC_BASE_MSR) << 4, low, high = 0;\r\nif (!irqchip_in_kernel(vcpu->kvm) || !apic_x2apic_mode(apic))\r\nreturn 1;\r\nif (apic_reg_read(apic, reg, 4, &low))\r\nreturn 1;\r\nif (msr == 0x830)\r\napic_reg_read(apic, APIC_ICR2, 4, &high);\r\n*data = (((u64)high) << 32) | low;\r\nreturn 0;\r\n}\r\nint kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nif (!kvm_vcpu_has_lapic(vcpu))\r\nreturn 1;\r\nif (reg == APIC_ICR)\r\napic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\r\nreturn apic_reg_write(apic, reg, (u32)data);\r\n}\r\nint kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nu32 low, high = 0;\r\nif (!kvm_vcpu_has_lapic(vcpu))\r\nreturn 1;\r\nif (apic_reg_read(apic, reg, 4, &low))\r\nreturn 1;\r\nif (reg == APIC_ICR)\r\napic_reg_read(apic, APIC_ICR2, 4, &high);\r\n*data = (((u64)high) << 32) | low;\r\nreturn 0;\r\n}\r\nint kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data)\r\n{\r\nu64 addr = data & ~KVM_MSR_ENABLED;\r\nif (!IS_ALIGNED(addr, 4))\r\nreturn 1;\r\nvcpu->arch.pv_eoi.msr_val = data;\r\nif (!pv_eoi_enabled(vcpu))\r\nreturn 0;\r\nreturn kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.pv_eoi.data,\r\naddr, sizeof(u8));\r\n}\r\nvoid kvm_apic_accept_events(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_lapic *apic = vcpu->arch.apic;\r\nunsigned int sipi_vector;\r\nunsigned long pe;\r\nif (!kvm_vcpu_has_lapic(vcpu) || !apic->pending_events)\r\nreturn;\r\npe = xchg(&apic->pending_events, 0);\r\nif (test_bit(KVM_APIC_INIT, &pe)) {\r\nkvm_lapic_reset(vcpu);\r\nkvm_vcpu_reset(vcpu);\r\nif (kvm_vcpu_is_bsp(apic->vcpu))\r\nvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\r\nelse\r\nvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\r\n}\r\nif (test_bit(KVM_APIC_SIPI, &pe) &&\r\nvcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\r\nsmp_rmb();\r\nsipi_vector = apic->sipi_vector;\r\npr_debug("vcpu %d received sipi with vector # %x\n",\r\nvcpu->vcpu_id, sipi_vector);\r\nkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\r\nvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\r\n}\r\n}\r\nvoid kvm_lapic_init(void)\r\n{\r\njump_label_rate_limit(&apic_hw_disabled, HZ);\r\njump_label_rate_limit(&apic_sw_disabled, HZ);\r\n}
