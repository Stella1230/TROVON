int\r\nmedia_entity_init(struct media_entity *entity, u16 num_pads,\r\nstruct media_pad *pads, u16 extra_links)\r\n{\r\nstruct media_link *links;\r\nunsigned int max_links = num_pads + extra_links;\r\nunsigned int i;\r\nlinks = kzalloc(max_links * sizeof(links[0]), GFP_KERNEL);\r\nif (links == NULL)\r\nreturn -ENOMEM;\r\nentity->group_id = 0;\r\nentity->max_links = max_links;\r\nentity->num_links = 0;\r\nentity->num_backlinks = 0;\r\nentity->num_pads = num_pads;\r\nentity->pads = pads;\r\nentity->links = links;\r\nfor (i = 0; i < num_pads; i++) {\r\npads[i].entity = entity;\r\npads[i].index = i;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nmedia_entity_cleanup(struct media_entity *entity)\r\n{\r\nkfree(entity->links);\r\n}\r\nstatic struct media_entity *\r\nmedia_entity_other(struct media_entity *entity, struct media_link *link)\r\n{\r\nif (link->source->entity == entity)\r\nreturn link->sink->entity;\r\nelse\r\nreturn link->source->entity;\r\n}\r\nstatic void stack_push(struct media_entity_graph *graph,\r\nstruct media_entity *entity)\r\n{\r\nif (graph->top == MEDIA_ENTITY_ENUM_MAX_DEPTH - 1) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\ngraph->top++;\r\ngraph->stack[graph->top].link = 0;\r\ngraph->stack[graph->top].entity = entity;\r\n}\r\nstatic struct media_entity *stack_pop(struct media_entity_graph *graph)\r\n{\r\nstruct media_entity *entity;\r\nentity = graph->stack[graph->top].entity;\r\ngraph->top--;\r\nreturn entity;\r\n}\r\nvoid media_entity_graph_walk_start(struct media_entity_graph *graph,\r\nstruct media_entity *entity)\r\n{\r\ngraph->top = 0;\r\ngraph->stack[graph->top].entity = NULL;\r\nbitmap_zero(graph->entities, MEDIA_ENTITY_ENUM_MAX_ID);\r\nif (WARN_ON(entity->id >= MEDIA_ENTITY_ENUM_MAX_ID))\r\nreturn;\r\n__set_bit(entity->id, graph->entities);\r\nstack_push(graph, entity);\r\n}\r\nstruct media_entity *\r\nmedia_entity_graph_walk_next(struct media_entity_graph *graph)\r\n{\r\nif (stack_top(graph) == NULL)\r\nreturn NULL;\r\nwhile (link_top(graph) < stack_top(graph)->num_links) {\r\nstruct media_entity *entity = stack_top(graph);\r\nstruct media_link *link = &entity->links[link_top(graph)];\r\nstruct media_entity *next;\r\nif (!(link->flags & MEDIA_LNK_FL_ENABLED)) {\r\nlink_top(graph)++;\r\ncontinue;\r\n}\r\nnext = media_entity_other(entity, link);\r\nif (WARN_ON(next->id >= MEDIA_ENTITY_ENUM_MAX_ID))\r\nreturn NULL;\r\nif (__test_and_set_bit(next->id, graph->entities)) {\r\nlink_top(graph)++;\r\ncontinue;\r\n}\r\nlink_top(graph)++;\r\nstack_push(graph, next);\r\n}\r\nreturn stack_pop(graph);\r\n}\r\n__must_check int media_entity_pipeline_start(struct media_entity *entity,\r\nstruct media_pipeline *pipe)\r\n{\r\nstruct media_device *mdev = entity->parent;\r\nstruct media_entity_graph graph;\r\nstruct media_entity *entity_err = entity;\r\nint ret;\r\nmutex_lock(&mdev->graph_mutex);\r\nmedia_entity_graph_walk_start(&graph, entity);\r\nwhile ((entity = media_entity_graph_walk_next(&graph))) {\r\nDECLARE_BITMAP(active, entity->num_pads);\r\nDECLARE_BITMAP(has_no_links, entity->num_pads);\r\nunsigned int i;\r\nentity->stream_count++;\r\nWARN_ON(entity->pipe && entity->pipe != pipe);\r\nentity->pipe = pipe;\r\nif (entity->stream_count > 1)\r\ncontinue;\r\nif (!entity->ops || !entity->ops->link_validate)\r\ncontinue;\r\nbitmap_zero(active, entity->num_pads);\r\nbitmap_fill(has_no_links, entity->num_pads);\r\nfor (i = 0; i < entity->num_links; i++) {\r\nstruct media_link *link = &entity->links[i];\r\nstruct media_pad *pad = link->sink->entity == entity\r\n? link->sink : link->source;\r\nbitmap_clear(has_no_links, pad->index, 1);\r\nif (!(pad->flags & MEDIA_PAD_FL_MUST_CONNECT) ||\r\nlink->flags & MEDIA_LNK_FL_ENABLED)\r\nbitmap_set(active, pad->index, 1);\r\nif (link->sink != pad ||\r\n!(link->flags & MEDIA_LNK_FL_ENABLED))\r\ncontinue;\r\nret = entity->ops->link_validate(link);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\ngoto error;\r\n}\r\nbitmap_or(active, active, has_no_links, entity->num_pads);\r\nif (!bitmap_full(active, entity->num_pads)) {\r\nret = -EPIPE;\r\ngoto error;\r\n}\r\n}\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn 0;\r\nerror:\r\nmedia_entity_graph_walk_start(&graph, entity_err);\r\nwhile ((entity_err = media_entity_graph_walk_next(&graph))) {\r\nentity_err->stream_count--;\r\nif (entity_err->stream_count == 0)\r\nentity_err->pipe = NULL;\r\nif (entity_err == entity)\r\nbreak;\r\n}\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn ret;\r\n}\r\nvoid media_entity_pipeline_stop(struct media_entity *entity)\r\n{\r\nstruct media_device *mdev = entity->parent;\r\nstruct media_entity_graph graph;\r\nmutex_lock(&mdev->graph_mutex);\r\nmedia_entity_graph_walk_start(&graph, entity);\r\nwhile ((entity = media_entity_graph_walk_next(&graph))) {\r\nentity->stream_count--;\r\nif (entity->stream_count == 0)\r\nentity->pipe = NULL;\r\n}\r\nmutex_unlock(&mdev->graph_mutex);\r\n}\r\nstruct media_entity *media_entity_get(struct media_entity *entity)\r\n{\r\nif (entity == NULL)\r\nreturn NULL;\r\nif (entity->parent->dev &&\r\n!try_module_get(entity->parent->dev->driver->owner))\r\nreturn NULL;\r\nreturn entity;\r\n}\r\nvoid media_entity_put(struct media_entity *entity)\r\n{\r\nif (entity == NULL)\r\nreturn;\r\nif (entity->parent->dev)\r\nmodule_put(entity->parent->dev->driver->owner);\r\n}\r\nstatic struct media_link *media_entity_add_link(struct media_entity *entity)\r\n{\r\nif (entity->num_links >= entity->max_links) {\r\nstruct media_link *links = entity->links;\r\nunsigned int max_links = entity->max_links + 2;\r\nunsigned int i;\r\nlinks = krealloc(links, max_links * sizeof(*links), GFP_KERNEL);\r\nif (links == NULL)\r\nreturn NULL;\r\nfor (i = 0; i < entity->num_links; i++)\r\nlinks[i].reverse->reverse = &links[i];\r\nentity->max_links = max_links;\r\nentity->links = links;\r\n}\r\nreturn &entity->links[entity->num_links++];\r\n}\r\nint\r\nmedia_entity_create_link(struct media_entity *source, u16 source_pad,\r\nstruct media_entity *sink, u16 sink_pad, u32 flags)\r\n{\r\nstruct media_link *link;\r\nstruct media_link *backlink;\r\nBUG_ON(source == NULL || sink == NULL);\r\nBUG_ON(source_pad >= source->num_pads);\r\nBUG_ON(sink_pad >= sink->num_pads);\r\nlink = media_entity_add_link(source);\r\nif (link == NULL)\r\nreturn -ENOMEM;\r\nlink->source = &source->pads[source_pad];\r\nlink->sink = &sink->pads[sink_pad];\r\nlink->flags = flags;\r\nbacklink = media_entity_add_link(sink);\r\nif (backlink == NULL) {\r\nsource->num_links--;\r\nreturn -ENOMEM;\r\n}\r\nbacklink->source = &source->pads[source_pad];\r\nbacklink->sink = &sink->pads[sink_pad];\r\nbacklink->flags = flags;\r\nlink->reverse = backlink;\r\nbacklink->reverse = link;\r\nsink->num_backlinks++;\r\nreturn 0;\r\n}\r\nvoid __media_entity_remove_links(struct media_entity *entity)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < entity->num_links; i++) {\r\nstruct media_link *link = &entity->links[i];\r\nstruct media_entity *remote;\r\nunsigned int r = 0;\r\nif (link->source->entity == entity)\r\nremote = link->sink->entity;\r\nelse\r\nremote = link->source->entity;\r\nwhile (r < remote->num_links) {\r\nstruct media_link *rlink = &remote->links[r];\r\nif (rlink != link->reverse) {\r\nr++;\r\ncontinue;\r\n}\r\nif (link->source->entity == entity)\r\nremote->num_backlinks--;\r\nif (--remote->num_links == 0)\r\nbreak;\r\n*rlink = remote->links[remote->num_links];\r\n}\r\n}\r\nentity->num_links = 0;\r\nentity->num_backlinks = 0;\r\n}\r\nvoid media_entity_remove_links(struct media_entity *entity)\r\n{\r\nif (entity->parent == NULL)\r\nreturn;\r\nmutex_lock(&entity->parent->graph_mutex);\r\n__media_entity_remove_links(entity);\r\nmutex_unlock(&entity->parent->graph_mutex);\r\n}\r\nstatic int __media_entity_setup_link_notify(struct media_link *link, u32 flags)\r\n{\r\nint ret;\r\nret = media_entity_call(link->source->entity, link_setup,\r\nlink->source, link->sink, flags);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\nret = media_entity_call(link->sink->entity, link_setup,\r\nlink->sink, link->source, flags);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\nmedia_entity_call(link->source->entity, link_setup,\r\nlink->source, link->sink, link->flags);\r\nreturn ret;\r\n}\r\nlink->flags = flags;\r\nlink->reverse->flags = link->flags;\r\nreturn 0;\r\n}\r\nint __media_entity_setup_link(struct media_link *link, u32 flags)\r\n{\r\nconst u32 mask = MEDIA_LNK_FL_ENABLED;\r\nstruct media_device *mdev;\r\nstruct media_entity *source, *sink;\r\nint ret = -EBUSY;\r\nif (link == NULL)\r\nreturn -EINVAL;\r\nif ((link->flags & ~mask) != (flags & ~mask))\r\nreturn -EINVAL;\r\nif (link->flags & MEDIA_LNK_FL_IMMUTABLE)\r\nreturn link->flags == flags ? 0 : -EINVAL;\r\nif (link->flags == flags)\r\nreturn 0;\r\nsource = link->source->entity;\r\nsink = link->sink->entity;\r\nif (!(link->flags & MEDIA_LNK_FL_DYNAMIC) &&\r\n(source->stream_count || sink->stream_count))\r\nreturn -EBUSY;\r\nmdev = source->parent;\r\nif (mdev->link_notify) {\r\nret = mdev->link_notify(link, flags,\r\nMEDIA_DEV_NOTIFY_PRE_LINK_CH);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = __media_entity_setup_link_notify(link, flags);\r\nif (mdev->link_notify)\r\nmdev->link_notify(link, flags, MEDIA_DEV_NOTIFY_POST_LINK_CH);\r\nreturn ret;\r\n}\r\nint media_entity_setup_link(struct media_link *link, u32 flags)\r\n{\r\nint ret;\r\nmutex_lock(&link->source->entity->parent->graph_mutex);\r\nret = __media_entity_setup_link(link, flags);\r\nmutex_unlock(&link->source->entity->parent->graph_mutex);\r\nreturn ret;\r\n}\r\nstruct media_link *\r\nmedia_entity_find_link(struct media_pad *source, struct media_pad *sink)\r\n{\r\nstruct media_link *link;\r\nunsigned int i;\r\nfor (i = 0; i < source->entity->num_links; ++i) {\r\nlink = &source->entity->links[i];\r\nif (link->source->entity == source->entity &&\r\nlink->source->index == source->index &&\r\nlink->sink->entity == sink->entity &&\r\nlink->sink->index == sink->index)\r\nreturn link;\r\n}\r\nreturn NULL;\r\n}\r\nstruct media_pad *media_entity_remote_pad(struct media_pad *pad)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < pad->entity->num_links; i++) {\r\nstruct media_link *link = &pad->entity->links[i];\r\nif (!(link->flags & MEDIA_LNK_FL_ENABLED))\r\ncontinue;\r\nif (link->source == pad)\r\nreturn link->sink;\r\nif (link->sink == pad)\r\nreturn link->source;\r\n}\r\nreturn NULL;\r\n}
