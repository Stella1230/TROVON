static void lirc_irctl_init(struct irctl *ir)\r\n{\r\nmutex_init(&ir->irctl_lock);\r\nir->d.minor = NOPLUG;\r\n}\r\nstatic void lirc_irctl_cleanup(struct irctl *ir)\r\n{\r\ndev_dbg(ir->d.dev, LOGHEAD "cleaning up\n", ir->d.name, ir->d.minor);\r\ndevice_destroy(lirc_class, MKDEV(MAJOR(lirc_base_dev), ir->d.minor));\r\nif (ir->buf != ir->d.rbuf) {\r\nlirc_buffer_free(ir->buf);\r\nkfree(ir->buf);\r\n}\r\nir->buf = NULL;\r\n}\r\nstatic int lirc_add_to_buf(struct irctl *ir)\r\n{\r\nif (ir->d.add_to_buf) {\r\nint res = -ENODATA;\r\nint got_data = 0;\r\nget_data:\r\nres = ir->d.add_to_buf(ir->d.data, ir->buf);\r\nif (res == 0) {\r\ngot_data++;\r\ngoto get_data;\r\n}\r\nif (res == -ENODEV)\r\nkthread_stop(ir->task);\r\nreturn got_data ? 0 : res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lirc_thread(void *irctl)\r\n{\r\nstruct irctl *ir = irctl;\r\ndev_dbg(ir->d.dev, LOGHEAD "poll thread started\n",\r\nir->d.name, ir->d.minor);\r\ndo {\r\nif (ir->open) {\r\nif (ir->jiffies_to_wait) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(ir->jiffies_to_wait);\r\n}\r\nif (kthread_should_stop())\r\nbreak;\r\nif (!lirc_add_to_buf(ir))\r\nwake_up_interruptible(&ir->buf->wait_poll);\r\n} else {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\n}\r\n} while (!kthread_should_stop());\r\ndev_dbg(ir->d.dev, LOGHEAD "poll thread ended\n",\r\nir->d.name, ir->d.minor);\r\nreturn 0;\r\n}\r\nstatic int lirc_cdev_add(struct irctl *ir)\r\n{\r\nint retval = -ENOMEM;\r\nstruct lirc_driver *d = &ir->d;\r\nstruct cdev *cdev;\r\ncdev = kzalloc(sizeof(*cdev), GFP_KERNEL);\r\nif (!cdev)\r\ngoto err_out;\r\nif (d->fops) {\r\ncdev_init(cdev, d->fops);\r\ncdev->owner = d->owner;\r\n} else {\r\ncdev_init(cdev, &lirc_dev_fops);\r\ncdev->owner = THIS_MODULE;\r\n}\r\nretval = kobject_set_name(&cdev->kobj, "lirc%d", d->minor);\r\nif (retval)\r\ngoto err_out;\r\nretval = cdev_add(cdev, MKDEV(MAJOR(lirc_base_dev), d->minor), 1);\r\nif (retval) {\r\nkobject_put(&cdev->kobj);\r\ngoto err_out;\r\n}\r\nir->cdev = cdev;\r\nreturn 0;\r\nerr_out:\r\nkfree(cdev);\r\nreturn retval;\r\n}\r\nint lirc_register_driver(struct lirc_driver *d)\r\n{\r\nstruct irctl *ir;\r\nint minor;\r\nint bytes_in_key;\r\nunsigned int chunk_size;\r\nunsigned int buffer_size;\r\nint err;\r\nif (!d) {\r\nprintk(KERN_ERR "lirc_dev: lirc_register_driver: "\r\n"driver pointer must be not NULL!\n");\r\nerr = -EBADRQC;\r\ngoto out;\r\n}\r\nif (!d->dev) {\r\nprintk(KERN_ERR "%s: dev pointer not filled in!\n", __func__);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (MAX_IRCTL_DEVICES <= d->minor) {\r\ndev_err(d->dev, "lirc_dev: lirc_register_driver: "\r\n"\"minor\" must be between 0 and %d (%d)!\n",\r\nMAX_IRCTL_DEVICES - 1, d->minor);\r\nerr = -EBADRQC;\r\ngoto out;\r\n}\r\nif (1 > d->code_length || (BUFLEN * 8) < d->code_length) {\r\ndev_err(d->dev, "lirc_dev: lirc_register_driver: "\r\n"code length in bits for minor (%d) "\r\n"must be less than %d!\n",\r\nd->minor, BUFLEN * 8);\r\nerr = -EBADRQC;\r\ngoto out;\r\n}\r\ndev_dbg(d->dev, "lirc_dev: lirc_register_driver: sample_rate: %d\n",\r\nd->sample_rate);\r\nif (d->sample_rate) {\r\nif (2 > d->sample_rate || HZ < d->sample_rate) {\r\ndev_err(d->dev, "lirc_dev: lirc_register_driver: "\r\n"sample_rate must be between 2 and %d!\n", HZ);\r\nerr = -EBADRQC;\r\ngoto out;\r\n}\r\nif (!d->add_to_buf) {\r\ndev_err(d->dev, "lirc_dev: lirc_register_driver: "\r\n"add_to_buf cannot be NULL when "\r\n"sample_rate is set\n");\r\nerr = -EBADRQC;\r\ngoto out;\r\n}\r\n} else if (!(d->fops && d->fops->read) && !d->rbuf) {\r\ndev_err(d->dev, "lirc_dev: lirc_register_driver: "\r\n"fops->read and rbuf cannot all be NULL!\n");\r\nerr = -EBADRQC;\r\ngoto out;\r\n} else if (!d->rbuf) {\r\nif (!(d->fops && d->fops->read && d->fops->poll &&\r\nd->fops->unlocked_ioctl)) {\r\ndev_err(d->dev, "lirc_dev: lirc_register_driver: "\r\n"neither read, poll nor unlocked_ioctl can be NULL!\n");\r\nerr = -EBADRQC;\r\ngoto out;\r\n}\r\n}\r\nmutex_lock(&lirc_dev_lock);\r\nminor = d->minor;\r\nif (minor < 0) {\r\nfor (minor = 0; minor < MAX_IRCTL_DEVICES; minor++)\r\nif (!irctls[minor])\r\nbreak;\r\nif (MAX_IRCTL_DEVICES == minor) {\r\ndev_err(d->dev, "lirc_dev: lirc_register_driver: "\r\n"no free slots for drivers!\n");\r\nerr = -ENOMEM;\r\ngoto out_lock;\r\n}\r\n} else if (irctls[minor]) {\r\ndev_err(d->dev, "lirc_dev: lirc_register_driver: "\r\n"minor (%d) just registered!\n", minor);\r\nerr = -EBUSY;\r\ngoto out_lock;\r\n}\r\nir = kzalloc(sizeof(struct irctl), GFP_KERNEL);\r\nif (!ir) {\r\nerr = -ENOMEM;\r\ngoto out_lock;\r\n}\r\nlirc_irctl_init(ir);\r\nirctls[minor] = ir;\r\nd->minor = minor;\r\nif (d->sample_rate) {\r\nir->jiffies_to_wait = HZ / d->sample_rate;\r\n} else {\r\nir->jiffies_to_wait = 0;\r\n}\r\nd->name[sizeof(d->name)-1] = '\0';\r\nbytes_in_key = BITS_TO_LONGS(d->code_length) +\r\n(d->code_length % 8 ? 1 : 0);\r\nbuffer_size = d->buffer_size ? d->buffer_size : BUFLEN / bytes_in_key;\r\nchunk_size = d->chunk_size ? d->chunk_size : bytes_in_key;\r\nif (d->rbuf) {\r\nir->buf = d->rbuf;\r\n} else {\r\nir->buf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL);\r\nif (!ir->buf) {\r\nerr = -ENOMEM;\r\ngoto out_lock;\r\n}\r\nerr = lirc_buffer_init(ir->buf, chunk_size, buffer_size);\r\nif (err) {\r\nkfree(ir->buf);\r\ngoto out_lock;\r\n}\r\n}\r\nir->chunk_size = ir->buf->chunk_size;\r\nif (d->features == 0)\r\nd->features = LIRC_CAN_REC_LIRCCODE;\r\nir->d = *d;\r\ndevice_create(lirc_class, ir->d.dev,\r\nMKDEV(MAJOR(lirc_base_dev), ir->d.minor), NULL,\r\n"lirc%u", ir->d.minor);\r\nif (d->sample_rate) {\r\nir->task = kthread_run(lirc_thread, (void *)ir, "lirc_dev");\r\nif (IS_ERR(ir->task)) {\r\ndev_err(d->dev, "lirc_dev: lirc_register_driver: "\r\n"cannot run poll thread for minor = %d\n",\r\nd->minor);\r\nerr = -ECHILD;\r\ngoto out_sysfs;\r\n}\r\n}\r\nerr = lirc_cdev_add(ir);\r\nif (err)\r\ngoto out_sysfs;\r\nir->attached = 1;\r\nmutex_unlock(&lirc_dev_lock);\r\ndev_info(ir->d.dev, "lirc_dev: driver %s registered at minor = %d\n",\r\nir->d.name, ir->d.minor);\r\nreturn minor;\r\nout_sysfs:\r\ndevice_destroy(lirc_class, MKDEV(MAJOR(lirc_base_dev), ir->d.minor));\r\nout_lock:\r\nmutex_unlock(&lirc_dev_lock);\r\nout:\r\nreturn err;\r\n}\r\nint lirc_unregister_driver(int minor)\r\n{\r\nstruct irctl *ir;\r\nstruct cdev *cdev;\r\nif (minor < 0 || minor >= MAX_IRCTL_DEVICES) {\r\nprintk(KERN_ERR "lirc_dev: %s: minor (%d) must be between "\r\n"0 and %d!\n", __func__, minor, MAX_IRCTL_DEVICES - 1);\r\nreturn -EBADRQC;\r\n}\r\nir = irctls[minor];\r\nif (!ir) {\r\nprintk(KERN_ERR "lirc_dev: %s: failed to get irctl struct "\r\n"for minor %d!\n", __func__, minor);\r\nreturn -ENOENT;\r\n}\r\ncdev = ir->cdev;\r\nmutex_lock(&lirc_dev_lock);\r\nif (ir->d.minor != minor) {\r\nprintk(KERN_ERR "lirc_dev: %s: minor (%d) device not "\r\n"registered!\n", __func__, minor);\r\nmutex_unlock(&lirc_dev_lock);\r\nreturn -ENOENT;\r\n}\r\nif (ir->task)\r\nkthread_stop(ir->task);\r\ndev_dbg(ir->d.dev, "lirc_dev: driver %s unregistered from minor = %d\n",\r\nir->d.name, ir->d.minor);\r\nir->attached = 0;\r\nif (ir->open) {\r\ndev_dbg(ir->d.dev, LOGHEAD "releasing opened driver\n",\r\nir->d.name, ir->d.minor);\r\nwake_up_interruptible(&ir->buf->wait_poll);\r\nmutex_lock(&ir->irctl_lock);\r\nir->d.set_use_dec(ir->d.data);\r\nmodule_put(cdev->owner);\r\nmutex_unlock(&ir->irctl_lock);\r\n} else {\r\nlirc_irctl_cleanup(ir);\r\ncdev_del(cdev);\r\nkfree(cdev);\r\nkfree(ir);\r\nirctls[minor] = NULL;\r\n}\r\nmutex_unlock(&lirc_dev_lock);\r\nreturn 0;\r\n}\r\nint lirc_dev_fop_open(struct inode *inode, struct file *file)\r\n{\r\nstruct irctl *ir;\r\nstruct cdev *cdev;\r\nint retval = 0;\r\nif (iminor(inode) >= MAX_IRCTL_DEVICES) {\r\nprintk(KERN_WARNING "lirc_dev [%d]: open result = -ENODEV\n",\r\niminor(inode));\r\nreturn -ENODEV;\r\n}\r\nif (mutex_lock_interruptible(&lirc_dev_lock))\r\nreturn -ERESTARTSYS;\r\nir = irctls[iminor(inode)];\r\nif (!ir) {\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\ndev_dbg(ir->d.dev, LOGHEAD "open called\n", ir->d.name, ir->d.minor);\r\nif (ir->d.minor == NOPLUG) {\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\nif (ir->open) {\r\nretval = -EBUSY;\r\ngoto error;\r\n}\r\nif (ir->d.rdev) {\r\nretval = rc_open(ir->d.rdev);\r\nif (retval)\r\ngoto error;\r\n}\r\ncdev = ir->cdev;\r\nif (try_module_get(cdev->owner)) {\r\nir->open++;\r\nretval = ir->d.set_use_inc(ir->d.data);\r\nif (retval) {\r\nmodule_put(cdev->owner);\r\nir->open--;\r\n} else {\r\nlirc_buffer_clear(ir->buf);\r\n}\r\nif (ir->task)\r\nwake_up_process(ir->task);\r\n}\r\nerror:\r\nif (ir)\r\ndev_dbg(ir->d.dev, LOGHEAD "open result = %d\n",\r\nir->d.name, ir->d.minor, retval);\r\nmutex_unlock(&lirc_dev_lock);\r\nnonseekable_open(inode, file);\r\nreturn retval;\r\n}\r\nint lirc_dev_fop_close(struct inode *inode, struct file *file)\r\n{\r\nstruct irctl *ir = irctls[iminor(inode)];\r\nstruct cdev *cdev;\r\nif (!ir) {\r\nprintk(KERN_ERR "%s: called with invalid irctl\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ncdev = ir->cdev;\r\ndev_dbg(ir->d.dev, LOGHEAD "close called\n", ir->d.name, ir->d.minor);\r\nWARN_ON(mutex_lock_killable(&lirc_dev_lock));\r\nif (ir->d.rdev)\r\nrc_close(ir->d.rdev);\r\nir->open--;\r\nif (ir->attached) {\r\nir->d.set_use_dec(ir->d.data);\r\nmodule_put(cdev->owner);\r\n} else {\r\nlirc_irctl_cleanup(ir);\r\ncdev_del(cdev);\r\nirctls[ir->d.minor] = NULL;\r\nkfree(cdev);\r\nkfree(ir);\r\n}\r\nmutex_unlock(&lirc_dev_lock);\r\nreturn 0;\r\n}\r\nunsigned int lirc_dev_fop_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct irctl *ir = irctls[iminor(file_inode(file))];\r\nunsigned int ret;\r\nif (!ir) {\r\nprintk(KERN_ERR "%s: called with invalid irctl\n", __func__);\r\nreturn POLLERR;\r\n}\r\ndev_dbg(ir->d.dev, LOGHEAD "poll called\n", ir->d.name, ir->d.minor);\r\nif (!ir->attached)\r\nreturn POLLERR;\r\npoll_wait(file, &ir->buf->wait_poll, wait);\r\nif (ir->buf)\r\nif (lirc_buffer_empty(ir->buf))\r\nret = 0;\r\nelse\r\nret = POLLIN | POLLRDNORM;\r\nelse\r\nret = POLLERR;\r\ndev_dbg(ir->d.dev, LOGHEAD "poll result = %d\n",\r\nir->d.name, ir->d.minor, ret);\r\nreturn ret;\r\n}\r\nlong lirc_dev_fop_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\n__u32 mode;\r\nint result = 0;\r\nstruct irctl *ir = irctls[iminor(file_inode(file))];\r\nif (!ir) {\r\nprintk(KERN_ERR "lirc_dev: %s: no irctl found!\n", __func__);\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(ir->d.dev, LOGHEAD "ioctl called (0x%x)\n",\r\nir->d.name, ir->d.minor, cmd);\r\nif (ir->d.minor == NOPLUG || !ir->attached) {\r\ndev_dbg(ir->d.dev, LOGHEAD "ioctl result = -ENODEV\n",\r\nir->d.name, ir->d.minor);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&ir->irctl_lock);\r\nswitch (cmd) {\r\ncase LIRC_GET_FEATURES:\r\nresult = put_user(ir->d.features, (__u32 *)arg);\r\nbreak;\r\ncase LIRC_GET_REC_MODE:\r\nif (!(ir->d.features & LIRC_CAN_REC_MASK)) {\r\nresult = -ENOSYS;\r\nbreak;\r\n}\r\nresult = put_user(LIRC_REC2MODE\r\n(ir->d.features & LIRC_CAN_REC_MASK),\r\n(__u32 *)arg);\r\nbreak;\r\ncase LIRC_SET_REC_MODE:\r\nif (!(ir->d.features & LIRC_CAN_REC_MASK)) {\r\nresult = -ENOSYS;\r\nbreak;\r\n}\r\nresult = get_user(mode, (__u32 *)arg);\r\nif (!result && !(LIRC_MODE2REC(mode) & ir->d.features))\r\nresult = -EINVAL;\r\nbreak;\r\ncase LIRC_GET_LENGTH:\r\nresult = put_user(ir->d.code_length, (__u32 *)arg);\r\nbreak;\r\ncase LIRC_GET_MIN_TIMEOUT:\r\nif (!(ir->d.features & LIRC_CAN_SET_REC_TIMEOUT) ||\r\nir->d.min_timeout == 0) {\r\nresult = -ENOSYS;\r\nbreak;\r\n}\r\nresult = put_user(ir->d.min_timeout, (__u32 *)arg);\r\nbreak;\r\ncase LIRC_GET_MAX_TIMEOUT:\r\nif (!(ir->d.features & LIRC_CAN_SET_REC_TIMEOUT) ||\r\nir->d.max_timeout == 0) {\r\nresult = -ENOSYS;\r\nbreak;\r\n}\r\nresult = put_user(ir->d.max_timeout, (__u32 *)arg);\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\n}\r\ndev_dbg(ir->d.dev, LOGHEAD "ioctl result = %d\n",\r\nir->d.name, ir->d.minor, result);\r\nmutex_unlock(&ir->irctl_lock);\r\nreturn result;\r\n}\r\nssize_t lirc_dev_fop_read(struct file *file,\r\nchar __user *buffer,\r\nsize_t length,\r\nloff_t *ppos)\r\n{\r\nstruct irctl *ir = irctls[iminor(file_inode(file))];\r\nunsigned char *buf;\r\nint ret = 0, written = 0;\r\nDECLARE_WAITQUEUE(wait, current);\r\nif (!ir) {\r\nprintk(KERN_ERR "%s: called with invalid irctl\n", __func__);\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(ir->d.dev, LOGHEAD "read called\n", ir->d.name, ir->d.minor);\r\nbuf = kzalloc(ir->chunk_size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (mutex_lock_interruptible(&ir->irctl_lock)) {\r\nret = -ERESTARTSYS;\r\ngoto out_unlocked;\r\n}\r\nif (!ir->attached) {\r\nret = -ENODEV;\r\ngoto out_locked;\r\n}\r\nif (length % ir->chunk_size) {\r\nret = -EINVAL;\r\ngoto out_locked;\r\n}\r\nadd_wait_queue(&ir->buf->wait_poll, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (written < length && ret == 0) {\r\nif (lirc_buffer_empty(ir->buf)) {\r\nif (written)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EWOULDBLOCK;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nmutex_unlock(&ir->irctl_lock);\r\nschedule();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (mutex_lock_interruptible(&ir->irctl_lock)) {\r\nret = -ERESTARTSYS;\r\nremove_wait_queue(&ir->buf->wait_poll, &wait);\r\nset_current_state(TASK_RUNNING);\r\ngoto out_unlocked;\r\n}\r\nif (!ir->attached) {\r\nret = -ENODEV;\r\nbreak;\r\n}\r\n} else {\r\nlirc_buffer_read(ir->buf, buf);\r\nret = copy_to_user((void *)buffer+written, buf,\r\nir->buf->chunk_size);\r\nif (!ret)\r\nwritten += ir->buf->chunk_size;\r\nelse\r\nret = -EFAULT;\r\n}\r\n}\r\nremove_wait_queue(&ir->buf->wait_poll, &wait);\r\nset_current_state(TASK_RUNNING);\r\nout_locked:\r\nmutex_unlock(&ir->irctl_lock);\r\nout_unlocked:\r\nkfree(buf);\r\ndev_dbg(ir->d.dev, LOGHEAD "read result = %s (%d)\n",\r\nir->d.name, ir->d.minor, ret ? "<fail>" : "<ok>", ret);\r\nreturn ret ? ret : written;\r\n}\r\nvoid *lirc_get_pdata(struct file *file)\r\n{\r\nreturn irctls[iminor(file_inode(file))]->d.data;\r\n}\r\nssize_t lirc_dev_fop_write(struct file *file, const char __user *buffer,\r\nsize_t length, loff_t *ppos)\r\n{\r\nstruct irctl *ir = irctls[iminor(file_inode(file))];\r\nif (!ir) {\r\nprintk(KERN_ERR "%s: called with invalid irctl\n", __func__);\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(ir->d.dev, LOGHEAD "write called\n", ir->d.name, ir->d.minor);\r\nif (!ir->attached)\r\nreturn -ENODEV;\r\nreturn -EINVAL;\r\n}\r\nstatic int __init lirc_dev_init(void)\r\n{\r\nint retval;\r\nlirc_class = class_create(THIS_MODULE, "lirc");\r\nif (IS_ERR(lirc_class)) {\r\nretval = PTR_ERR(lirc_class);\r\nprintk(KERN_ERR "lirc_dev: class_create failed\n");\r\ngoto error;\r\n}\r\nretval = alloc_chrdev_region(&lirc_base_dev, 0, MAX_IRCTL_DEVICES,\r\nIRCTL_DEV_NAME);\r\nif (retval) {\r\nclass_destroy(lirc_class);\r\nprintk(KERN_ERR "lirc_dev: alloc_chrdev_region failed\n");\r\ngoto error;\r\n}\r\nprintk(KERN_INFO "lirc_dev: IR Remote Control driver registered, "\r\n"major %d \n", MAJOR(lirc_base_dev));\r\nerror:\r\nreturn retval;\r\n}\r\nstatic void __exit lirc_dev_exit(void)\r\n{\r\nclass_destroy(lirc_class);\r\nunregister_chrdev_region(lirc_base_dev, MAX_IRCTL_DEVICES);\r\nprintk(KERN_INFO "lirc_dev: module unloaded\n");\r\n}
