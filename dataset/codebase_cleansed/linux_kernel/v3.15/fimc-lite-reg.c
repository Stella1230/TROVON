void flite_hw_reset(struct fimc_lite *dev)\r\n{\r\nunsigned long end = jiffies + msecs_to_jiffies(FLITE_RESET_TIMEOUT);\r\nu32 cfg;\r\ncfg = readl(dev->regs + FLITE_REG_CIGCTRL);\r\ncfg |= FLITE_REG_CIGCTRL_SWRST_REQ;\r\nwritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\r\nwhile (time_is_after_jiffies(end)) {\r\ncfg = readl(dev->regs + FLITE_REG_CIGCTRL);\r\nif (cfg & FLITE_REG_CIGCTRL_SWRST_RDY)\r\nbreak;\r\nusleep_range(1000, 5000);\r\n}\r\ncfg |= FLITE_REG_CIGCTRL_SWRST;\r\nwritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\r\n}\r\nvoid flite_hw_clear_pending_irq(struct fimc_lite *dev)\r\n{\r\nu32 cfg = readl(dev->regs + FLITE_REG_CISTATUS);\r\ncfg &= ~FLITE_REG_CISTATUS_IRQ_CAM;\r\nwritel(cfg, dev->regs + FLITE_REG_CISTATUS);\r\n}\r\nu32 flite_hw_get_interrupt_source(struct fimc_lite *dev)\r\n{\r\nu32 intsrc = readl(dev->regs + FLITE_REG_CISTATUS);\r\nreturn intsrc & FLITE_REG_CISTATUS_IRQ_MASK;\r\n}\r\nvoid flite_hw_clear_last_capture_end(struct fimc_lite *dev)\r\n{\r\nu32 cfg = readl(dev->regs + FLITE_REG_CISTATUS2);\r\ncfg &= ~FLITE_REG_CISTATUS2_LASTCAPEND;\r\nwritel(cfg, dev->regs + FLITE_REG_CISTATUS2);\r\n}\r\nvoid flite_hw_set_interrupt_mask(struct fimc_lite *dev)\r\n{\r\nu32 cfg, intsrc;\r\nif (atomic_read(&dev->out_path) == FIMC_IO_DMA) {\r\nintsrc = FLITE_REG_CIGCTRL_IRQ_OVFEN |\r\nFLITE_REG_CIGCTRL_IRQ_LASTEN |\r\nFLITE_REG_CIGCTRL_IRQ_STARTEN |\r\nFLITE_REG_CIGCTRL_IRQ_ENDEN;\r\n} else {\r\nintsrc = FLITE_REG_CIGCTRL_IRQ_OVFEN |\r\nFLITE_REG_CIGCTRL_IRQ_LASTEN;\r\n}\r\ncfg = readl(dev->regs + FLITE_REG_CIGCTRL);\r\ncfg |= FLITE_REG_CIGCTRL_IRQ_DISABLE_MASK;\r\ncfg &= ~intsrc;\r\nwritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\r\n}\r\nvoid flite_hw_capture_start(struct fimc_lite *dev)\r\n{\r\nu32 cfg = readl(dev->regs + FLITE_REG_CIIMGCPT);\r\ncfg |= FLITE_REG_CIIMGCPT_IMGCPTEN;\r\nwritel(cfg, dev->regs + FLITE_REG_CIIMGCPT);\r\n}\r\nvoid flite_hw_capture_stop(struct fimc_lite *dev)\r\n{\r\nu32 cfg = readl(dev->regs + FLITE_REG_CIIMGCPT);\r\ncfg &= ~FLITE_REG_CIIMGCPT_IMGCPTEN;\r\nwritel(cfg, dev->regs + FLITE_REG_CIIMGCPT);\r\n}\r\nvoid flite_hw_set_test_pattern(struct fimc_lite *dev, bool on)\r\n{\r\nu32 cfg = readl(dev->regs + FLITE_REG_CIGCTRL);\r\nif (on)\r\ncfg |= FLITE_REG_CIGCTRL_TEST_PATTERN_COLORBAR;\r\nelse\r\ncfg &= ~FLITE_REG_CIGCTRL_TEST_PATTERN_COLORBAR;\r\nwritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\r\n}\r\nvoid flite_hw_set_source_format(struct fimc_lite *dev, struct flite_frame *f)\r\n{\r\nenum v4l2_mbus_pixelcode pixelcode = f->fmt->mbus_code;\r\nint i = ARRAY_SIZE(src_pixfmt_map);\r\nu32 cfg;\r\nwhile (--i) {\r\nif (src_pixfmt_map[i][0] == pixelcode)\r\nbreak;\r\n}\r\nif (i == 0 && src_pixfmt_map[i][0] != pixelcode) {\r\nv4l2_err(&dev->ve.vdev,\r\n"Unsupported pixel code, falling back to %#08x\n",\r\nsrc_pixfmt_map[i][0]);\r\n}\r\ncfg = readl(dev->regs + FLITE_REG_CIGCTRL);\r\ncfg &= ~FLITE_REG_CIGCTRL_FMT_MASK;\r\ncfg |= src_pixfmt_map[i][2];\r\nwritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\r\ncfg = readl(dev->regs + FLITE_REG_CISRCSIZE);\r\ncfg &= ~(FLITE_REG_CISRCSIZE_ORDER422_MASK |\r\nFLITE_REG_CISRCSIZE_SIZE_CAM_MASK);\r\ncfg |= (f->f_width << 16) | f->f_height;\r\ncfg |= src_pixfmt_map[i][1];\r\nwritel(cfg, dev->regs + FLITE_REG_CISRCSIZE);\r\n}\r\nvoid flite_hw_set_window_offset(struct fimc_lite *dev, struct flite_frame *f)\r\n{\r\nu32 hoff2, voff2;\r\nu32 cfg;\r\ncfg = readl(dev->regs + FLITE_REG_CIWDOFST);\r\ncfg &= ~FLITE_REG_CIWDOFST_OFST_MASK;\r\ncfg |= (f->rect.left << 16) | f->rect.top;\r\ncfg |= FLITE_REG_CIWDOFST_WINOFSEN;\r\nwritel(cfg, dev->regs + FLITE_REG_CIWDOFST);\r\nhoff2 = f->f_width - f->rect.width - f->rect.left;\r\nvoff2 = f->f_height - f->rect.height - f->rect.top;\r\ncfg = (hoff2 << 16) | voff2;\r\nwritel(cfg, dev->regs + FLITE_REG_CIWDOFST2);\r\n}\r\nstatic void flite_hw_set_camera_port(struct fimc_lite *dev, int id)\r\n{\r\nu32 cfg = readl(dev->regs + FLITE_REG_CIGENERAL);\r\nif (id == 0)\r\ncfg &= ~FLITE_REG_CIGENERAL_CAM_B;\r\nelse\r\ncfg |= FLITE_REG_CIGENERAL_CAM_B;\r\nwritel(cfg, dev->regs + FLITE_REG_CIGENERAL);\r\n}\r\nvoid flite_hw_set_camera_bus(struct fimc_lite *dev,\r\nstruct fimc_source_info *si)\r\n{\r\nu32 cfg = readl(dev->regs + FLITE_REG_CIGCTRL);\r\nunsigned int flags = si->flags;\r\nif (si->sensor_bus_type != FIMC_BUS_TYPE_MIPI_CSI2) {\r\ncfg &= ~(FLITE_REG_CIGCTRL_SELCAM_MIPI |\r\nFLITE_REG_CIGCTRL_INVPOLPCLK |\r\nFLITE_REG_CIGCTRL_INVPOLVSYNC |\r\nFLITE_REG_CIGCTRL_INVPOLHREF);\r\nif (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\ncfg |= FLITE_REG_CIGCTRL_INVPOLPCLK;\r\nif (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\r\ncfg |= FLITE_REG_CIGCTRL_INVPOLVSYNC;\r\nif (flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\ncfg |= FLITE_REG_CIGCTRL_INVPOLHREF;\r\n} else {\r\ncfg |= FLITE_REG_CIGCTRL_SELCAM_MIPI;\r\n}\r\nwritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\r\nflite_hw_set_camera_port(dev, si->mux_id);\r\n}\r\nstatic void flite_hw_set_pack12(struct fimc_lite *dev, int on)\r\n{\r\nu32 cfg = readl(dev->regs + FLITE_REG_CIODMAFMT);\r\ncfg &= ~FLITE_REG_CIODMAFMT_PACK12;\r\nif (on)\r\ncfg |= FLITE_REG_CIODMAFMT_PACK12;\r\nwritel(cfg, dev->regs + FLITE_REG_CIODMAFMT);\r\n}\r\nstatic void flite_hw_set_out_order(struct fimc_lite *dev, struct flite_frame *f)\r\n{\r\nstatic const u32 pixcode[4][2] = {\r\n{ V4L2_MBUS_FMT_YUYV8_2X8, FLITE_REG_CIODMAFMT_YCBYCR },\r\n{ V4L2_MBUS_FMT_YVYU8_2X8, FLITE_REG_CIODMAFMT_YCRYCB },\r\n{ V4L2_MBUS_FMT_UYVY8_2X8, FLITE_REG_CIODMAFMT_CBYCRY },\r\n{ V4L2_MBUS_FMT_VYUY8_2X8, FLITE_REG_CIODMAFMT_CRYCBY },\r\n};\r\nu32 cfg = readl(dev->regs + FLITE_REG_CIODMAFMT);\r\nint i = ARRAY_SIZE(pixcode);\r\nwhile (--i)\r\nif (pixcode[i][0] == f->fmt->mbus_code)\r\nbreak;\r\ncfg &= ~FLITE_REG_CIODMAFMT_YCBCR_ORDER_MASK;\r\nwritel(cfg | pixcode[i][1], dev->regs + FLITE_REG_CIODMAFMT);\r\n}\r\nvoid flite_hw_set_dma_window(struct fimc_lite *dev, struct flite_frame *f)\r\n{\r\nu32 cfg;\r\ncfg = readl(dev->regs + FLITE_REG_CIOCAN);\r\ncfg &= ~FLITE_REG_CIOCAN_MASK;\r\ncfg = (f->f_height << 16) | f->f_width;\r\nwritel(cfg, dev->regs + FLITE_REG_CIOCAN);\r\ncfg = readl(dev->regs + FLITE_REG_CIOOFF);\r\ncfg &= ~FLITE_REG_CIOOFF_MASK;\r\ncfg |= (f->rect.top << 16) | f->rect.left;\r\nwritel(cfg, dev->regs + FLITE_REG_CIOOFF);\r\n}\r\nvoid flite_hw_set_dma_buffer(struct fimc_lite *dev, struct flite_buffer *buf)\r\n{\r\nunsigned int index;\r\nu32 cfg;\r\nif (dev->dd->max_dma_bufs == 1)\r\nindex = 0;\r\nelse\r\nindex = buf->index;\r\nif (index == 0)\r\nwritel(buf->paddr, dev->regs + FLITE_REG_CIOSA);\r\nelse\r\nwritel(buf->paddr, dev->regs + FLITE_REG_CIOSAN(index - 1));\r\ncfg = readl(dev->regs + FLITE_REG_CIFCNTSEQ);\r\ncfg |= BIT(index);\r\nwritel(cfg, dev->regs + FLITE_REG_CIFCNTSEQ);\r\n}\r\nvoid flite_hw_mask_dma_buffer(struct fimc_lite *dev, u32 index)\r\n{\r\nu32 cfg;\r\nif (dev->dd->max_dma_bufs == 1)\r\nindex = 0;\r\ncfg = readl(dev->regs + FLITE_REG_CIFCNTSEQ);\r\ncfg &= ~BIT(index);\r\nwritel(cfg, dev->regs + FLITE_REG_CIFCNTSEQ);\r\n}\r\nvoid flite_hw_set_output_dma(struct fimc_lite *dev, struct flite_frame *f,\r\nbool enable)\r\n{\r\nu32 cfg = readl(dev->regs + FLITE_REG_CIGCTRL);\r\nif (!enable) {\r\ncfg |= FLITE_REG_CIGCTRL_ODMA_DISABLE;\r\nwritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\r\nreturn;\r\n}\r\ncfg &= ~FLITE_REG_CIGCTRL_ODMA_DISABLE;\r\nwritel(cfg, dev->regs + FLITE_REG_CIGCTRL);\r\nflite_hw_set_out_order(dev, f);\r\nflite_hw_set_dma_window(dev, f);\r\nflite_hw_set_pack12(dev, 0);\r\n}\r\nvoid flite_hw_dump_regs(struct fimc_lite *dev, const char *label)\r\n{\r\nstruct {\r\nu32 offset;\r\nconst char * const name;\r\n} registers[] = {\r\n{ 0x00, "CISRCSIZE" },\r\n{ 0x04, "CIGCTRL" },\r\n{ 0x08, "CIIMGCPT" },\r\n{ 0x0c, "CICPTSEQ" },\r\n{ 0x10, "CIWDOFST" },\r\n{ 0x14, "CIWDOFST2" },\r\n{ 0x18, "CIODMAFMT" },\r\n{ 0x20, "CIOCAN" },\r\n{ 0x24, "CIOOFF" },\r\n{ 0x30, "CIOSA" },\r\n{ 0x40, "CISTATUS" },\r\n{ 0x44, "CISTATUS2" },\r\n{ 0xf0, "CITHOLD" },\r\n{ 0xfc, "CIGENERAL" },\r\n};\r\nu32 i;\r\nv4l2_info(&dev->subdev, "--- %s ---\n", label);\r\nfor (i = 0; i < ARRAY_SIZE(registers); i++) {\r\nu32 cfg = readl(dev->regs + registers[i].offset);\r\nv4l2_info(&dev->subdev, "%9s: 0x%08x\n",\r\nregisters[i].name, cfg);\r\n}\r\n}
