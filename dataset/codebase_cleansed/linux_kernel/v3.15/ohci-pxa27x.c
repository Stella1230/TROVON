static int pxa27x_ohci_select_pmm(struct pxa27x_ohci *pxa_ohci, int mode)\r\n{\r\nuint32_t uhcrhda = __raw_readl(pxa_ohci->mmio_base + UHCRHDA);\r\nuint32_t uhcrhdb = __raw_readl(pxa_ohci->mmio_base + UHCRHDB);\r\nswitch (mode) {\r\ncase PMM_NPS_MODE:\r\nuhcrhda |= RH_A_NPS;\r\nbreak;\r\ncase PMM_GLOBAL_MODE:\r\nuhcrhda &= ~(RH_A_NPS & RH_A_PSM);\r\nbreak;\r\ncase PMM_PERPORT_MODE:\r\nuhcrhda &= ~(RH_A_NPS);\r\nuhcrhda |= RH_A_PSM;\r\nuhcrhdb |= (0x7<<17);\r\nbreak;\r\ndefault:\r\nprintk( KERN_ERR\r\n"Invalid mode %d, set to non-power switch mode.\n",\r\nmode );\r\nuhcrhda |= RH_A_NPS;\r\n}\r\n__raw_writel(uhcrhda, pxa_ohci->mmio_base + UHCRHDA);\r\n__raw_writel(uhcrhdb, pxa_ohci->mmio_base + UHCRHDB);\r\nreturn 0;\r\n}\r\nstatic inline void pxa27x_setup_hc(struct pxa27x_ohci *pxa_ohci,\r\nstruct pxaohci_platform_data *inf)\r\n{\r\nuint32_t uhchr = __raw_readl(pxa_ohci->mmio_base + UHCHR);\r\nuint32_t uhcrhda = __raw_readl(pxa_ohci->mmio_base + UHCRHDA);\r\nif (inf->flags & ENABLE_PORT1)\r\nuhchr &= ~UHCHR_SSEP1;\r\nif (inf->flags & ENABLE_PORT2)\r\nuhchr &= ~UHCHR_SSEP2;\r\nif (inf->flags & ENABLE_PORT3)\r\nuhchr &= ~UHCHR_SSEP3;\r\nif (inf->flags & POWER_CONTROL_LOW)\r\nuhchr |= UHCHR_PCPL;\r\nif (inf->flags & POWER_SENSE_LOW)\r\nuhchr |= UHCHR_PSPL;\r\nif (inf->flags & NO_OC_PROTECTION)\r\nuhcrhda |= UHCRHDA_NOCP;\r\nelse\r\nuhcrhda &= ~UHCRHDA_NOCP;\r\nif (inf->flags & OC_MODE_PERPORT)\r\nuhcrhda |= UHCRHDA_OCPM;\r\nelse\r\nuhcrhda &= ~UHCRHDA_OCPM;\r\nif (inf->power_on_delay) {\r\nuhcrhda &= ~UHCRHDA_POTPGT(0xff);\r\nuhcrhda |= UHCRHDA_POTPGT(inf->power_on_delay / 2);\r\n}\r\n__raw_writel(uhchr, pxa_ohci->mmio_base + UHCHR);\r\n__raw_writel(uhcrhda, pxa_ohci->mmio_base + UHCRHDA);\r\n}\r\nstatic inline void pxa27x_reset_hc(struct pxa27x_ohci *pxa_ohci)\r\n{\r\nuint32_t uhchr = __raw_readl(pxa_ohci->mmio_base + UHCHR);\r\n__raw_writel(uhchr | UHCHR_FHR, pxa_ohci->mmio_base + UHCHR);\r\nudelay(11);\r\n__raw_writel(uhchr & ~UHCHR_FHR, pxa_ohci->mmio_base + UHCHR);\r\n}\r\nstatic int pxa27x_start_hc(struct pxa27x_ohci *pxa_ohci, struct device *dev)\r\n{\r\nint retval = 0;\r\nstruct pxaohci_platform_data *inf;\r\nuint32_t uhchr;\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\ninf = dev_get_platdata(dev);\r\nclk_prepare_enable(pxa_ohci->clk);\r\npxa27x_reset_hc(pxa_ohci);\r\nuhchr = __raw_readl(pxa_ohci->mmio_base + UHCHR) | UHCHR_FSBIR;\r\n__raw_writel(uhchr, pxa_ohci->mmio_base + UHCHR);\r\nwhile (__raw_readl(pxa_ohci->mmio_base + UHCHR) & UHCHR_FSBIR)\r\ncpu_relax();\r\npxa27x_setup_hc(pxa_ohci, inf);\r\nif (inf->init)\r\nretval = inf->init(dev);\r\nif (retval < 0)\r\nreturn retval;\r\nif (cpu_is_pxa3xx())\r\npxa3xx_u2d_start_hc(&hcd->self);\r\nuhchr = __raw_readl(pxa_ohci->mmio_base + UHCHR) & ~UHCHR_SSE;\r\n__raw_writel(uhchr, pxa_ohci->mmio_base + UHCHR);\r\n__raw_writel(UHCHIE_UPRIE | UHCHIE_RWIE, pxa_ohci->mmio_base + UHCHIE);\r\npxa27x_clear_otgph();\r\nreturn 0;\r\n}\r\nstatic void pxa27x_stop_hc(struct pxa27x_ohci *pxa_ohci, struct device *dev)\r\n{\r\nstruct pxaohci_platform_data *inf;\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nuint32_t uhccoms;\r\ninf = dev_get_platdata(dev);\r\nif (cpu_is_pxa3xx())\r\npxa3xx_u2d_stop_hc(&hcd->self);\r\nif (inf->exit)\r\ninf->exit(dev);\r\npxa27x_reset_hc(pxa_ohci);\r\nuhccoms = __raw_readl(pxa_ohci->mmio_base + UHCCOMS) | 0x01;\r\n__raw_writel(uhccoms, pxa_ohci->mmio_base + UHCCOMS);\r\nudelay(10);\r\nclk_disable_unprepare(pxa_ohci->clk);\r\n}\r\nstatic int ohci_pxa_of_init(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct pxaohci_platform_data *pdata;\r\nu32 tmp;\r\nint ret;\r\nif (!np)\r\nreturn 0;\r\nret = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nif (of_get_property(np, "marvell,enable-port1", NULL))\r\npdata->flags |= ENABLE_PORT1;\r\nif (of_get_property(np, "marvell,enable-port2", NULL))\r\npdata->flags |= ENABLE_PORT2;\r\nif (of_get_property(np, "marvell,enable-port3", NULL))\r\npdata->flags |= ENABLE_PORT3;\r\nif (of_get_property(np, "marvell,port-sense-low", NULL))\r\npdata->flags |= POWER_SENSE_LOW;\r\nif (of_get_property(np, "marvell,power-control-low", NULL))\r\npdata->flags |= POWER_CONTROL_LOW;\r\nif (of_get_property(np, "marvell,no-oc-protection", NULL))\r\npdata->flags |= NO_OC_PROTECTION;\r\nif (of_get_property(np, "marvell,oc-mode-perport", NULL))\r\npdata->flags |= OC_MODE_PERPORT;\r\nif (!of_property_read_u32(np, "marvell,power-on-delay", &tmp))\r\npdata->power_on_delay = tmp;\r\nif (!of_property_read_u32(np, "marvell,port-mode", &tmp))\r\npdata->port_mode = tmp;\r\nif (!of_property_read_u32(np, "marvell,power-budget", &tmp))\r\npdata->power_budget = tmp;\r\npdev->dev.platform_data = pdata;\r\nreturn 0;\r\n}\r\nstatic int ohci_pxa_of_init(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nint usb_hcd_pxa27x_probe (const struct hc_driver *driver, struct platform_device *pdev)\r\n{\r\nint retval, irq;\r\nstruct usb_hcd *hcd;\r\nstruct pxaohci_platform_data *inf;\r\nstruct pxa27x_ohci *pxa_ohci;\r\nstruct ohci_hcd *ohci;\r\nstruct resource *r;\r\nstruct clk *usb_clk;\r\nretval = ohci_pxa_of_init(pdev);\r\nif (retval)\r\nreturn retval;\r\ninf = dev_get_platdata(&pdev->dev);\r\nif (!inf)\r\nreturn -ENODEV;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\npr_err("no resource of IORESOURCE_IRQ");\r\nreturn -ENXIO;\r\n}\r\nusb_clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(usb_clk))\r\nreturn PTR_ERR(usb_clk);\r\nhcd = usb_create_hcd (driver, &pdev->dev, "pxa27x");\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\npr_err("no resource of IORESOURCE_MEM");\r\nretval = -ENXIO;\r\ngoto err;\r\n}\r\nhcd->rsrc_start = r->start;\r\nhcd->rsrc_len = resource_size(r);\r\nhcd->regs = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(hcd->regs)) {\r\nretval = PTR_ERR(hcd->regs);\r\ngoto err;\r\n}\r\npxa_ohci = to_pxa27x_ohci(hcd);\r\npxa_ohci->clk = usb_clk;\r\npxa_ohci->mmio_base = (void __iomem *)hcd->regs;\r\nretval = pxa27x_start_hc(pxa_ohci, &pdev->dev);\r\nif (retval < 0) {\r\npr_debug("pxa27x_start_hc failed");\r\ngoto err;\r\n}\r\npxa27x_ohci_select_pmm(pxa_ohci, inf->port_mode);\r\nif (inf->power_budget)\r\nhcd->power_budget = inf->power_budget;\r\nohci = hcd_to_ohci(hcd);\r\nohci->num_ports = 3;\r\nretval = usb_add_hcd(hcd, irq, 0);\r\nif (retval == 0) {\r\ndevice_wakeup_enable(hcd->self.controller);\r\nreturn retval;\r\n}\r\npxa27x_stop_hc(pxa_ohci, &pdev->dev);\r\nerr:\r\nusb_put_hcd(hcd);\r\nreturn retval;\r\n}\r\nvoid usb_hcd_pxa27x_remove (struct usb_hcd *hcd, struct platform_device *pdev)\r\n{\r\nstruct pxa27x_ohci *pxa_ohci = to_pxa27x_ohci(hcd);\r\nusb_remove_hcd(hcd);\r\npxa27x_stop_hc(pxa_ohci, &pdev->dev);\r\nusb_put_hcd(hcd);\r\n}\r\nstatic int ohci_hcd_pxa27x_drv_probe(struct platform_device *pdev)\r\n{\r\npr_debug ("In ohci_hcd_pxa27x_drv_probe");\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nreturn usb_hcd_pxa27x_probe(&ohci_pxa27x_hc_driver, pdev);\r\n}\r\nstatic int ohci_hcd_pxa27x_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nusb_hcd_pxa27x_remove(hcd, pdev);\r\nreturn 0;\r\n}\r\nstatic int ohci_hcd_pxa27x_drv_suspend(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct pxa27x_ohci *pxa_ohci = to_pxa27x_ohci(hcd);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nbool do_wakeup = device_may_wakeup(dev);\r\nint ret;\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nret = ohci_suspend(hcd, do_wakeup);\r\nif (ret)\r\nreturn ret;\r\npxa27x_stop_hc(pxa_ohci, dev);\r\nreturn ret;\r\n}\r\nstatic int ohci_hcd_pxa27x_drv_resume(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct pxa27x_ohci *pxa_ohci = to_pxa27x_ohci(hcd);\r\nstruct pxaohci_platform_data *inf = dev_get_platdata(dev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nint status;\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nstatus = pxa27x_start_hc(pxa_ohci, dev);\r\nif (status < 0)\r\nreturn status;\r\npxa27x_ohci_select_pmm(pxa_ohci, inf->port_mode);\r\nohci_resume(hcd, false);\r\nreturn 0;\r\n}\r\nstatic int __init ohci_pxa27x_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", hcd_name);\r\nohci_init_driver(&ohci_pxa27x_hc_driver, &pxa27x_overrides);\r\nreturn platform_driver_register(&ohci_hcd_pxa27x_driver);\r\n}\r\nstatic void __exit ohci_pxa27x_cleanup(void)\r\n{\r\nplatform_driver_unregister(&ohci_hcd_pxa27x_driver);\r\n}
