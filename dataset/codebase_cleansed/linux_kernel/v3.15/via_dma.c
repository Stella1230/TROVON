static uint32_t via_cmdbuf_space(drm_via_private_t *dev_priv)\r\n{\r\nuint32_t agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;\r\nuint32_t hw_addr = *(dev_priv->hw_addr_ptr) - agp_base;\r\nreturn ((hw_addr <= dev_priv->dma_low) ?\r\n(dev_priv->dma_high + hw_addr - dev_priv->dma_low) :\r\n(hw_addr - dev_priv->dma_low));\r\n}\r\nstatic uint32_t via_cmdbuf_lag(drm_via_private_t *dev_priv)\r\n{\r\nuint32_t agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;\r\nuint32_t hw_addr = *(dev_priv->hw_addr_ptr) - agp_base;\r\nreturn ((hw_addr <= dev_priv->dma_low) ?\r\n(dev_priv->dma_low - hw_addr) :\r\n(dev_priv->dma_wrap + dev_priv->dma_low - hw_addr));\r\n}\r\nstatic inline int\r\nvia_cmdbuf_wait(drm_via_private_t *dev_priv, unsigned int size)\r\n{\r\nuint32_t agp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;\r\nuint32_t cur_addr, hw_addr, next_addr;\r\nvolatile uint32_t *hw_addr_ptr;\r\nuint32_t count;\r\nhw_addr_ptr = dev_priv->hw_addr_ptr;\r\ncur_addr = dev_priv->dma_low;\r\nnext_addr = cur_addr + size + 512 * 1024;\r\ncount = 1000000;\r\ndo {\r\nhw_addr = *hw_addr_ptr - agp_base;\r\nif (count-- == 0) {\r\nDRM_ERROR\r\n("via_cmdbuf_wait timed out hw %x cur_addr %x next_addr %x\n",\r\nhw_addr, cur_addr, next_addr);\r\nreturn -1;\r\n}\r\nif ((cur_addr < hw_addr) && (next_addr >= hw_addr))\r\nmsleep(1);\r\n} while ((cur_addr < hw_addr) && (next_addr >= hw_addr));\r\nreturn 0;\r\n}\r\nstatic inline uint32_t *via_check_dma(drm_via_private_t * dev_priv,\r\nunsigned int size)\r\n{\r\nif ((dev_priv->dma_low + size + 4 * CMDBUF_ALIGNMENT_SIZE) >\r\ndev_priv->dma_high) {\r\nvia_cmdbuf_rewind(dev_priv);\r\n}\r\nif (via_cmdbuf_wait(dev_priv, size) != 0)\r\nreturn NULL;\r\nreturn (uint32_t *) (dev_priv->dma_ptr + dev_priv->dma_low);\r\n}\r\nint via_dma_cleanup(struct drm_device *dev)\r\n{\r\nif (dev->dev_private) {\r\ndrm_via_private_t *dev_priv =\r\n(drm_via_private_t *) dev->dev_private;\r\nif (dev_priv->ring.virtual_start) {\r\nvia_cmdbuf_reset(dev_priv);\r\ndrm_core_ioremapfree(&dev_priv->ring.map, dev);\r\ndev_priv->ring.virtual_start = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int via_initialize(struct drm_device *dev,\r\ndrm_via_private_t *dev_priv,\r\ndrm_via_dma_init_t *init)\r\n{\r\nif (!dev_priv || !dev_priv->mmio) {\r\nDRM_ERROR("via_dma_init called before via_map_init\n");\r\nreturn -EFAULT;\r\n}\r\nif (dev_priv->ring.virtual_start != NULL) {\r\nDRM_ERROR("called again without calling cleanup\n");\r\nreturn -EFAULT;\r\n}\r\nif (!dev->agp || !dev->agp->base) {\r\nDRM_ERROR("called with no agp memory available\n");\r\nreturn -EFAULT;\r\n}\r\nif (dev_priv->chipset == VIA_DX9_0) {\r\nDRM_ERROR("AGP DMA is not supported on this chip\n");\r\nreturn -EINVAL;\r\n}\r\ndev_priv->ring.map.offset = dev->agp->base + init->offset;\r\ndev_priv->ring.map.size = init->size;\r\ndev_priv->ring.map.type = 0;\r\ndev_priv->ring.map.flags = 0;\r\ndev_priv->ring.map.mtrr = 0;\r\ndrm_core_ioremap(&dev_priv->ring.map, dev);\r\nif (dev_priv->ring.map.handle == NULL) {\r\nvia_dma_cleanup(dev);\r\nDRM_ERROR("can not ioremap virtual address for"\r\n" ring buffer\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_priv->ring.virtual_start = dev_priv->ring.map.handle;\r\ndev_priv->dma_ptr = dev_priv->ring.virtual_start;\r\ndev_priv->dma_low = 0;\r\ndev_priv->dma_high = init->size;\r\ndev_priv->dma_wrap = init->size;\r\ndev_priv->dma_offset = init->offset;\r\ndev_priv->last_pause_ptr = NULL;\r\ndev_priv->hw_addr_ptr =\r\n(volatile uint32_t *)((char *)dev_priv->mmio->handle +\r\ninit->reg_pause_addr);\r\nvia_cmdbuf_start(dev_priv);\r\nreturn 0;\r\n}\r\nstatic int via_dma_init(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\ndrm_via_dma_init_t *init = data;\r\nint retcode = 0;\r\nswitch (init->func) {\r\ncase VIA_INIT_DMA:\r\nif (!capable(CAP_SYS_ADMIN))\r\nretcode = -EPERM;\r\nelse\r\nretcode = via_initialize(dev, dev_priv, init);\r\nbreak;\r\ncase VIA_CLEANUP_DMA:\r\nif (!capable(CAP_SYS_ADMIN))\r\nretcode = -EPERM;\r\nelse\r\nretcode = via_dma_cleanup(dev);\r\nbreak;\r\ncase VIA_DMA_INITIALIZED:\r\nretcode = (dev_priv->ring.virtual_start != NULL) ?\r\n0 : -EFAULT;\r\nbreak;\r\ndefault:\r\nretcode = -EINVAL;\r\nbreak;\r\n}\r\nreturn retcode;\r\n}\r\nstatic int via_dispatch_cmdbuffer(struct drm_device *dev, drm_via_cmdbuffer_t *cmd)\r\n{\r\ndrm_via_private_t *dev_priv;\r\nuint32_t *vb;\r\nint ret;\r\ndev_priv = (drm_via_private_t *) dev->dev_private;\r\nif (dev_priv->ring.virtual_start == NULL) {\r\nDRM_ERROR("called without initializing AGP ring buffer.\n");\r\nreturn -EFAULT;\r\n}\r\nif (cmd->size > VIA_PCI_BUF_SIZE)\r\nreturn -ENOMEM;\r\nif (copy_from_user(dev_priv->pci_buf, cmd->buf, cmd->size))\r\nreturn -EFAULT;\r\nif ((ret =\r\nvia_verify_command_stream((uint32_t *) dev_priv->pci_buf,\r\ncmd->size, dev, 1))) {\r\nreturn ret;\r\n}\r\nvb = via_check_dma(dev_priv, (cmd->size < 0x100) ? 0x102 : cmd->size);\r\nif (vb == NULL)\r\nreturn -EAGAIN;\r\nmemcpy(vb, dev_priv->pci_buf, cmd->size);\r\ndev_priv->dma_low += cmd->size;\r\nif (cmd->size < 0x100)\r\nvia_pad_cache(dev_priv, (0x100 - cmd->size) >> 3);\r\nvia_cmdbuf_pause(dev_priv);\r\nreturn 0;\r\n}\r\nint via_driver_dma_quiescent(struct drm_device *dev)\r\n{\r\ndrm_via_private_t *dev_priv = dev->dev_private;\r\nif (!via_wait_idle(dev_priv))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int via_flush_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nreturn via_driver_dma_quiescent(dev);\r\n}\r\nstatic int via_cmdbuffer(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_via_cmdbuffer_t *cmdbuf = data;\r\nint ret;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDRM_DEBUG("buf %p size %lu\n", cmdbuf->buf, cmdbuf->size);\r\nret = via_dispatch_cmdbuffer(dev, cmdbuf);\r\nreturn ret;\r\n}\r\nstatic int via_dispatch_pci_cmdbuffer(struct drm_device *dev,\r\ndrm_via_cmdbuffer_t *cmd)\r\n{\r\ndrm_via_private_t *dev_priv = dev->dev_private;\r\nint ret;\r\nif (cmd->size > VIA_PCI_BUF_SIZE)\r\nreturn -ENOMEM;\r\nif (copy_from_user(dev_priv->pci_buf, cmd->buf, cmd->size))\r\nreturn -EFAULT;\r\nif ((ret =\r\nvia_verify_command_stream((uint32_t *) dev_priv->pci_buf,\r\ncmd->size, dev, 0))) {\r\nreturn ret;\r\n}\r\nret =\r\nvia_parse_command_stream(dev, (const uint32_t *)dev_priv->pci_buf,\r\ncmd->size);\r\nreturn ret;\r\n}\r\nstatic int via_pci_cmdbuffer(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_via_cmdbuffer_t *cmdbuf = data;\r\nint ret;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDRM_DEBUG("buf %p size %lu\n", cmdbuf->buf, cmdbuf->size);\r\nret = via_dispatch_pci_cmdbuffer(dev, cmdbuf);\r\nreturn ret;\r\n}\r\nstatic inline uint32_t *via_align_buffer(drm_via_private_t *dev_priv,\r\nuint32_t * vb, int qw_count)\r\n{\r\nfor (; qw_count > 0; --qw_count)\r\nVIA_OUT_RING_QW(HC_DUMMY, HC_DUMMY);\r\nreturn vb;\r\n}\r\nstatic inline uint32_t *via_get_dma(drm_via_private_t *dev_priv)\r\n{\r\nreturn (uint32_t *) (dev_priv->dma_ptr + dev_priv->dma_low);\r\n}\r\nstatic int via_hook_segment(drm_via_private_t *dev_priv,\r\nuint32_t pause_addr_hi, uint32_t pause_addr_lo,\r\nint no_pci_fire)\r\n{\r\nint paused, count;\r\nvolatile uint32_t *paused_at = dev_priv->last_pause_ptr;\r\nuint32_t reader, ptr;\r\nuint32_t diff;\r\npaused = 0;\r\nvia_flush_write_combine();\r\n(void) *(volatile uint32_t *)(via_get_dma(dev_priv) - 1);\r\n*paused_at = pause_addr_lo;\r\nvia_flush_write_combine();\r\n(void) *paused_at;\r\nreader = *(dev_priv->hw_addr_ptr);\r\nptr = ((volatile char *)paused_at - dev_priv->dma_ptr) +\r\ndev_priv->dma_offset + (uint32_t) dev_priv->agpAddr + 4;\r\ndev_priv->last_pause_ptr = via_get_dma(dev_priv) - 1;\r\ndiff = (uint32_t) (ptr - reader) - dev_priv->dma_diff;\r\ncount = 10000000;\r\nwhile (diff == 0 && count--) {\r\npaused = (VIA_READ(0x41c) & 0x80000000);\r\nif (paused)\r\nbreak;\r\nreader = *(dev_priv->hw_addr_ptr);\r\ndiff = (uint32_t) (ptr - reader) - dev_priv->dma_diff;\r\n}\r\npaused = VIA_READ(0x41c) & 0x80000000;\r\nif (paused && !no_pci_fire) {\r\nreader = *(dev_priv->hw_addr_ptr);\r\ndiff = (uint32_t) (ptr - reader) - dev_priv->dma_diff;\r\ndiff &= (dev_priv->dma_high - 1);\r\nif (diff != 0 && diff < (dev_priv->dma_high >> 1)) {\r\nDRM_ERROR("Paused at incorrect address. "\r\n"0x%08x, 0x%08x 0x%08x\n",\r\nptr, reader, dev_priv->dma_diff);\r\n} else if (diff == 0) {\r\nVIA_WRITE(VIA_REG_TRANSET, (HC_ParaType_PreCR << 16));\r\nVIA_WRITE(VIA_REG_TRANSPACE, pause_addr_hi);\r\nVIA_WRITE(VIA_REG_TRANSPACE, pause_addr_lo);\r\nVIA_READ(VIA_REG_TRANSPACE);\r\n}\r\n}\r\nreturn paused;\r\n}\r\nstatic int via_wait_idle(drm_via_private_t *dev_priv)\r\n{\r\nint count = 10000000;\r\nwhile (!(VIA_READ(VIA_REG_STATUS) & VIA_VR_QUEUE_BUSY) && --count)\r\n;\r\nwhile (count && (VIA_READ(VIA_REG_STATUS) &\r\n(VIA_CMD_RGTR_BUSY | VIA_2D_ENG_BUSY |\r\nVIA_3D_ENG_BUSY)))\r\n--count;\r\nreturn count;\r\n}\r\nstatic uint32_t *via_align_cmd(drm_via_private_t *dev_priv, uint32_t cmd_type,\r\nuint32_t addr, uint32_t *cmd_addr_hi,\r\nuint32_t *cmd_addr_lo, int skip_wait)\r\n{\r\nuint32_t agp_base;\r\nuint32_t cmd_addr, addr_lo, addr_hi;\r\nuint32_t *vb;\r\nuint32_t qw_pad_count;\r\nif (!skip_wait)\r\nvia_cmdbuf_wait(dev_priv, 2 * CMDBUF_ALIGNMENT_SIZE);\r\nvb = via_get_dma(dev_priv);\r\nVIA_OUT_RING_QW(HC_HEADER2 | ((VIA_REG_TRANSET >> 2) << 12) |\r\n(VIA_REG_TRANSPACE >> 2), HC_ParaType_PreCR << 16);\r\nagp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;\r\nqw_pad_count = (CMDBUF_ALIGNMENT_SIZE >> 3) -\r\n((dev_priv->dma_low & CMDBUF_ALIGNMENT_MASK) >> 3);\r\ncmd_addr = (addr) ? addr :\r\nagp_base + dev_priv->dma_low - 8 + (qw_pad_count << 3);\r\naddr_lo = ((HC_SubA_HAGPBpL << 24) | (cmd_type & HC_HAGPBpID_MASK) |\r\n(cmd_addr & HC_HAGPBpL_MASK));\r\naddr_hi = ((HC_SubA_HAGPBpH << 24) | (cmd_addr >> 24));\r\nvb = via_align_buffer(dev_priv, vb, qw_pad_count - 1);\r\nVIA_OUT_RING_QW(*cmd_addr_hi = addr_hi, *cmd_addr_lo = addr_lo);\r\nreturn vb;\r\n}\r\nstatic void via_cmdbuf_start(drm_via_private_t *dev_priv)\r\n{\r\nuint32_t pause_addr_lo, pause_addr_hi;\r\nuint32_t start_addr, start_addr_lo;\r\nuint32_t end_addr, end_addr_lo;\r\nuint32_t command;\r\nuint32_t agp_base;\r\nuint32_t ptr;\r\nuint32_t reader;\r\nint count;\r\ndev_priv->dma_low = 0;\r\nagp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;\r\nstart_addr = agp_base;\r\nend_addr = agp_base + dev_priv->dma_high;\r\nstart_addr_lo = ((HC_SubA_HAGPBstL << 24) | (start_addr & 0xFFFFFF));\r\nend_addr_lo = ((HC_SubA_HAGPBendL << 24) | (end_addr & 0xFFFFFF));\r\ncommand = ((HC_SubA_HAGPCMNT << 24) | (start_addr >> 24) |\r\n((end_addr & 0xff000000) >> 16));\r\ndev_priv->last_pause_ptr =\r\nvia_align_cmd(dev_priv, HC_HAGPBpID_PAUSE, 0,\r\n&pause_addr_hi, &pause_addr_lo, 1) - 1;\r\nvia_flush_write_combine();\r\n(void) *(volatile uint32_t *)dev_priv->last_pause_ptr;\r\nVIA_WRITE(VIA_REG_TRANSET, (HC_ParaType_PreCR << 16));\r\nVIA_WRITE(VIA_REG_TRANSPACE, command);\r\nVIA_WRITE(VIA_REG_TRANSPACE, start_addr_lo);\r\nVIA_WRITE(VIA_REG_TRANSPACE, end_addr_lo);\r\nVIA_WRITE(VIA_REG_TRANSPACE, pause_addr_hi);\r\nVIA_WRITE(VIA_REG_TRANSPACE, pause_addr_lo);\r\nwmb();\r\nVIA_WRITE(VIA_REG_TRANSPACE, command | HC_HAGPCMNT_MASK);\r\nVIA_READ(VIA_REG_TRANSPACE);\r\ndev_priv->dma_diff = 0;\r\ncount = 10000000;\r\nwhile (!(VIA_READ(0x41c) & 0x80000000) && count--);\r\nreader = *(dev_priv->hw_addr_ptr);\r\nptr = ((volatile char *)dev_priv->last_pause_ptr - dev_priv->dma_ptr) +\r\ndev_priv->dma_offset + (uint32_t) dev_priv->agpAddr + 4;\r\ndev_priv->dma_diff = ptr - reader;\r\n}\r\nstatic void via_pad_cache(drm_via_private_t *dev_priv, int qwords)\r\n{\r\nuint32_t *vb;\r\nvia_cmdbuf_wait(dev_priv, qwords + 2);\r\nvb = via_get_dma(dev_priv);\r\nVIA_OUT_RING_QW(HC_HEADER2, HC_ParaType_NotTex << 16);\r\nvia_align_buffer(dev_priv, vb, qwords);\r\n}\r\nstatic inline void via_dummy_bitblt(drm_via_private_t *dev_priv)\r\n{\r\nuint32_t *vb = via_get_dma(dev_priv);\r\nSetReg2DAGP(0x0C, (0 | (0 << 16)));\r\nSetReg2DAGP(0x10, 0 | (0 << 16));\r\nSetReg2DAGP(0x0, 0x1 | 0x2000 | 0xAA000000);\r\n}\r\nstatic void via_cmdbuf_jump(drm_via_private_t *dev_priv)\r\n{\r\nuint32_t agp_base;\r\nuint32_t pause_addr_lo, pause_addr_hi;\r\nuint32_t jump_addr_lo, jump_addr_hi;\r\nvolatile uint32_t *last_pause_ptr;\r\nuint32_t dma_low_save1, dma_low_save2;\r\nagp_base = dev_priv->dma_offset + (uint32_t) dev_priv->agpAddr;\r\nvia_align_cmd(dev_priv, HC_HAGPBpID_JUMP, 0, &jump_addr_hi,\r\n&jump_addr_lo, 0);\r\ndev_priv->dma_wrap = dev_priv->dma_low;\r\ndev_priv->dma_low = 0;\r\nif (via_cmdbuf_wait(dev_priv, CMDBUF_ALIGNMENT_SIZE) != 0)\r\nDRM_ERROR("via_cmdbuf_jump failed\n");\r\nvia_dummy_bitblt(dev_priv);\r\nvia_dummy_bitblt(dev_priv);\r\nlast_pause_ptr =\r\nvia_align_cmd(dev_priv, HC_HAGPBpID_PAUSE, 0, &pause_addr_hi,\r\n&pause_addr_lo, 0) - 1;\r\nvia_align_cmd(dev_priv, HC_HAGPBpID_PAUSE, 0, &pause_addr_hi,\r\n&pause_addr_lo, 0);\r\n*last_pause_ptr = pause_addr_lo;\r\ndma_low_save1 = dev_priv->dma_low;\r\nlast_pause_ptr =\r\nvia_align_cmd(dev_priv, HC_HAGPBpID_PAUSE, 0, &pause_addr_hi,\r\n&pause_addr_lo, 0) - 1;\r\nvia_align_cmd(dev_priv, HC_HAGPBpID_PAUSE, 0, &pause_addr_hi,\r\n&pause_addr_lo, 0);\r\n*last_pause_ptr = pause_addr_lo;\r\ndma_low_save2 = dev_priv->dma_low;\r\ndev_priv->dma_low = dma_low_save1;\r\nvia_hook_segment(dev_priv, jump_addr_hi, jump_addr_lo, 0);\r\ndev_priv->dma_low = dma_low_save2;\r\nvia_hook_segment(dev_priv, pause_addr_hi, pause_addr_lo, 0);\r\n}\r\nstatic void via_cmdbuf_rewind(drm_via_private_t *dev_priv)\r\n{\r\nvia_cmdbuf_jump(dev_priv);\r\n}\r\nstatic void via_cmdbuf_flush(drm_via_private_t *dev_priv, uint32_t cmd_type)\r\n{\r\nuint32_t pause_addr_lo, pause_addr_hi;\r\nvia_align_cmd(dev_priv, cmd_type, 0, &pause_addr_hi, &pause_addr_lo, 0);\r\nvia_hook_segment(dev_priv, pause_addr_hi, pause_addr_lo, 0);\r\n}\r\nstatic void via_cmdbuf_pause(drm_via_private_t *dev_priv)\r\n{\r\nvia_cmdbuf_flush(dev_priv, HC_HAGPBpID_PAUSE);\r\n}\r\nstatic void via_cmdbuf_reset(drm_via_private_t *dev_priv)\r\n{\r\nvia_cmdbuf_flush(dev_priv, HC_HAGPBpID_STOP);\r\nvia_wait_idle(dev_priv);\r\n}\r\nstatic int via_cmdbuf_size(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_via_cmdbuf_size_t *d_siz = data;\r\nint ret = 0;\r\nuint32_t tmp_size, count;\r\ndrm_via_private_t *dev_priv;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\ndev_priv = (drm_via_private_t *) dev->dev_private;\r\nif (dev_priv->ring.virtual_start == NULL) {\r\nDRM_ERROR("called without initializing AGP ring buffer.\n");\r\nreturn -EFAULT;\r\n}\r\ncount = 1000000;\r\ntmp_size = d_siz->size;\r\nswitch (d_siz->func) {\r\ncase VIA_CMDBUF_SPACE:\r\nwhile (((tmp_size = via_cmdbuf_space(dev_priv)) < d_siz->size)\r\n&& --count) {\r\nif (!d_siz->wait)\r\nbreak;\r\n}\r\nif (!count) {\r\nDRM_ERROR("VIA_CMDBUF_SPACE timed out.\n");\r\nret = -EAGAIN;\r\n}\r\nbreak;\r\ncase VIA_CMDBUF_LAG:\r\nwhile (((tmp_size = via_cmdbuf_lag(dev_priv)) > d_siz->size)\r\n&& --count) {\r\nif (!d_siz->wait)\r\nbreak;\r\n}\r\nif (!count) {\r\nDRM_ERROR("VIA_CMDBUF_LAG timed out.\n");\r\nret = -EAGAIN;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EFAULT;\r\n}\r\nd_siz->size = tmp_size;\r\nreturn ret;\r\n}
