static inline int nx842_header_size(const struct nx842_header *hdr)\r\n{\r\nreturn sizeof(struct nx842_header) +\r\nhdr->blocks_nr * sizeof(hdr->sizes[0]);\r\n}\r\nstatic void ibm_nx842_incr_hist(atomic64_t *times, unsigned int time)\r\n{\r\nint bucket = fls(time);\r\nif (bucket)\r\nbucket = min((NX842_HIST_SLOTS - 1), bucket - 1);\r\natomic64_inc(&times[bucket]);\r\n}\r\nstatic unsigned long nx842_get_desired_dma(struct vio_dev *viodev)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline unsigned long nx842_get_scatterlist_size(\r\nstruct nx842_scatterlist *sl)\r\n{\r\nreturn sl->entry_nr * sizeof(struct nx842_slentry);\r\n}\r\nstatic inline unsigned long nx842_get_pa(void *addr)\r\n{\r\nif (is_vmalloc_addr(addr))\r\nreturn page_to_phys(vmalloc_to_page(addr))\r\n+ offset_in_page(addr);\r\nelse\r\nreturn __pa(addr);\r\n}\r\nstatic int nx842_build_scatterlist(unsigned long buf, int len,\r\nstruct nx842_scatterlist *sl)\r\n{\r\nunsigned long nextpage;\r\nstruct nx842_slentry *entry;\r\nsl->entry_nr = 0;\r\nentry = sl->entries;\r\nwhile (len) {\r\nentry->ptr = nx842_get_pa((void *)buf);\r\nnextpage = ALIGN(buf + 1, NX842_HW_PAGE_SIZE);\r\nif (nextpage < buf + len) {\r\nif (IS_ALIGNED(buf, NX842_HW_PAGE_SIZE))\r\nentry->len = NX842_HW_PAGE_SIZE;\r\nelse\r\nentry->len = nextpage - buf;\r\n} else {\r\nentry->len = len;\r\n}\r\nlen -= entry->len;\r\nbuf += entry->len;\r\nsl->entry_nr++;\r\nentry++;\r\n}\r\nreturn 0;\r\n}\r\nint nx842_get_workmem_size(void)\r\n{\r\nreturn sizeof(struct nx842_workmem) + NX842_HW_PAGE_SIZE;\r\n}\r\nint nx842_get_workmem_size_aligned(void)\r\n{\r\nreturn sizeof(struct nx842_workmem);\r\n}\r\nstatic int nx842_validate_result(struct device *dev,\r\nstruct cop_status_block *csb)\r\n{\r\nif (!NX842_CSBCBP_VALID_CHK(csb->valid)) {\r\ndev_err(dev, "%s: cspcbp not valid upon completion.\n",\r\n__func__);\r\ndev_dbg(dev, "valid:0x%02x cs:0x%02x cc:0x%02x ce:0x%02x\n",\r\ncsb->valid,\r\ncsb->crb_seq_number,\r\ncsb->completion_code,\r\ncsb->completion_extension);\r\ndev_dbg(dev, "processed_bytes:%d address:0x%016lx\n",\r\ncsb->processed_byte_count,\r\n(unsigned long)csb->address);\r\nreturn -EIO;\r\n}\r\nswitch (csb->completion_code) {\r\ncase 0:\r\nbreak;\r\ncase 64:\r\ncase 13:\r\ndev_dbg(dev, "%s: Compression output larger than input\n",\r\n__func__);\r\nreturn -ENOSPC;\r\ncase 66:\r\ncase 67:\r\ndev_dbg(dev, "%s: Bad data for decompression (code:%d)\n",\r\n__func__, csb->completion_code);\r\nreturn -EINVAL;\r\ndefault:\r\ndev_dbg(dev, "%s: Unspecified error (code:%d)\n",\r\n__func__, csb->completion_code);\r\nreturn -EIO;\r\n}\r\nif (!NX842_CSBCPB_CE2(csb->completion_extension)) {\r\ndev_err(dev, "%s: No error returned by hardware, but "\r\n"data returned is unusable, contact support.\n"\r\n"(Additional info: csbcbp->processed bytes "\r\n"does not specify processed bytes for the "\r\n"target buffer.)\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint nx842_compress(const unsigned char *in, unsigned int inlen,\r\nunsigned char *out, unsigned int *outlen, void *wmem)\r\n{\r\nstruct nx842_header *hdr;\r\nstruct nx842_devdata *local_devdata;\r\nstruct device *dev = NULL;\r\nstruct nx842_workmem *workmem;\r\nstruct nx842_scatterlist slin, slout;\r\nstruct nx_csbcpb *csbcpb;\r\nint ret = 0, max_sync_size, i, bytesleft, size, hdrsize;\r\nunsigned long inbuf, outbuf, padding;\r\nstruct vio_pfo_op op = {\r\n.done = NULL,\r\n.handle = 0,\r\n.timeout = 0,\r\n};\r\nunsigned long start_time = get_tb();\r\ninbuf = (unsigned long)in;\r\nif (!IS_ALIGNED(inbuf, PAGE_SIZE) || inlen != PAGE_SIZE)\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nlocal_devdata = rcu_dereference(devdata);\r\nif (!local_devdata || !local_devdata->dev) {\r\nrcu_read_unlock();\r\nreturn -ENODEV;\r\n}\r\nmax_sync_size = local_devdata->max_sync_size;\r\ndev = local_devdata->dev;\r\nhdr = (struct nx842_header *)out;\r\nhdr->blocks_nr = PAGE_SIZE / max_sync_size;\r\nhdrsize = nx842_header_size(hdr);\r\noutbuf = (unsigned long)out + hdrsize;\r\nbytesleft = *outlen - hdrsize;\r\nworkmem = (struct nx842_workmem *)ALIGN((unsigned long)wmem,\r\nNX842_HW_PAGE_SIZE);\r\nslin.entries = (struct nx842_slentry *)workmem->slin;\r\nslout.entries = (struct nx842_slentry *)workmem->slout;\r\nop.flags = NX842_OP_COMPRESS;\r\ncsbcpb = &workmem->csbcpb;\r\nmemset(csbcpb, 0, sizeof(*csbcpb));\r\nop.csbcpb = nx842_get_pa(csbcpb);\r\nop.out = nx842_get_pa(slout.entries);\r\nfor (i = 0; i < hdr->blocks_nr; i++) {\r\npadding = ALIGN(outbuf, IO_BUFFER_ALIGN) - outbuf;\r\noutbuf += padding;\r\nbytesleft -= padding;\r\nif (i == 0)\r\nhdr->offset = padding + hdrsize;\r\nif (bytesleft <= 0) {\r\nret = -ENOSPC;\r\ngoto unlock;\r\n}\r\nif (likely(max_sync_size == NX842_HW_PAGE_SIZE)) {\r\nop.in = nx842_get_pa((void *)inbuf);\r\nop.inlen = max_sync_size;\r\n} else {\r\nnx842_build_scatterlist(inbuf, max_sync_size, &slin);\r\nop.in = nx842_get_pa(slin.entries);\r\nop.inlen = -nx842_get_scatterlist_size(&slin);\r\n}\r\nnx842_build_scatterlist(outbuf,\r\nmin(bytesleft, max_sync_size), &slout);\r\nop.outlen = -nx842_get_scatterlist_size(&slout);\r\nret = vio_h_cop_sync(local_devdata->vdev, &op);\r\nif (ret) {\r\ndev_dbg(dev, "%s: vio_h_cop_sync error (ret=%d, hret=%ld)\n",\r\n__func__, ret, op.hcall_err);\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\nret = nx842_validate_result(dev, &csbcpb->csb);\r\nif (ret && ret != -ENOSPC)\r\ngoto unlock;\r\nif (unlikely(ret == -ENOSPC)) {\r\nif (bytesleft < max_sync_size) {\r\ngoto unlock;\r\n} else {\r\nmemcpy((void *)outbuf, (void *)inbuf,\r\nmax_sync_size);\r\nhdr->sizes[i] = -max_sync_size;\r\noutbuf += max_sync_size;\r\nbytesleft -= max_sync_size;\r\nret = 0;\r\n}\r\n} else {\r\nsize = csbcpb->csb.processed_byte_count;\r\ndev_dbg(dev, "%s: processed_bytes=%d\n",\r\n__func__, size);\r\nhdr->sizes[i] = size;\r\noutbuf += size;\r\nbytesleft -= size;\r\n}\r\ninbuf += max_sync_size;\r\n}\r\n*outlen = (unsigned int)(outbuf - (unsigned long)out);\r\nunlock:\r\nif (ret)\r\nnx842_inc_comp_failed(local_devdata);\r\nelse {\r\nnx842_inc_comp_complete(local_devdata);\r\nibm_nx842_incr_hist(local_devdata->counters->comp_times,\r\n(get_tb() - start_time) / tb_ticks_per_usec);\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nint nx842_decompress(const unsigned char *in, unsigned int inlen,\r\nunsigned char *out, unsigned int *outlen, void *wmem)\r\n{\r\nstruct nx842_header *hdr;\r\nstruct nx842_devdata *local_devdata;\r\nstruct device *dev = NULL;\r\nstruct nx842_workmem *workmem;\r\nstruct nx842_scatterlist slin, slout;\r\nstruct nx_csbcpb *csbcpb;\r\nint ret = 0, i, size, max_sync_size;\r\nunsigned long inbuf, outbuf;\r\nstruct vio_pfo_op op = {\r\n.done = NULL,\r\n.handle = 0,\r\n.timeout = 0,\r\n};\r\nunsigned long start_time = get_tb();\r\noutbuf = (unsigned long)out;\r\nif (!IS_ALIGNED(outbuf, PAGE_SIZE) || *outlen != PAGE_SIZE)\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nlocal_devdata = rcu_dereference(devdata);\r\nif (local_devdata)\r\ndev = local_devdata->dev;\r\nhdr = (struct nx842_header *)in;\r\nworkmem = (struct nx842_workmem *)ALIGN((unsigned long)wmem,\r\nNX842_HW_PAGE_SIZE);\r\ninbuf = (unsigned long)in + hdr->offset;\r\nif (likely(!IS_ALIGNED(inbuf, IO_BUFFER_ALIGN))) {\r\nmemcpy(workmem->bounce, in + hdr->offset, inlen - hdr->offset);\r\ninbuf = (unsigned long)workmem->bounce;\r\n}\r\nslin.entries = (struct nx842_slentry *)workmem->slin;\r\nslout.entries = (struct nx842_slentry *)workmem->slout;\r\nop.flags = NX842_OP_DECOMPRESS;\r\ncsbcpb = &workmem->csbcpb;\r\nmemset(csbcpb, 0, sizeof(*csbcpb));\r\nop.csbcpb = nx842_get_pa(csbcpb);\r\nmax_sync_size = PAGE_SIZE / hdr->blocks_nr;\r\nfor (i = 0; i < hdr->blocks_nr; i++) {\r\ninbuf = ALIGN(inbuf, IO_BUFFER_ALIGN);\r\nif (hdr->sizes[i] < 0) {\r\nsize = abs(hdr->sizes[i]);\r\nmemcpy((void *)outbuf, (void *)inbuf, size);\r\noutbuf += size;\r\ninbuf += size;\r\ncontinue;\r\n}\r\nif (!dev)\r\ngoto sw;\r\nif (likely((inbuf & NX842_HW_PAGE_MASK) ==\r\n((inbuf + hdr->sizes[i] - 1) & NX842_HW_PAGE_MASK))) {\r\nop.in = nx842_get_pa((void *)inbuf);\r\nop.inlen = hdr->sizes[i];\r\n} else {\r\nnx842_build_scatterlist(inbuf, hdr->sizes[i] , &slin);\r\nop.in = nx842_get_pa(slin.entries);\r\nop.inlen = -nx842_get_scatterlist_size(&slin);\r\n}\r\nif (likely(max_sync_size == NX842_HW_PAGE_SIZE)) {\r\nop.out = nx842_get_pa((void *)outbuf);\r\nop.outlen = max_sync_size;\r\n} else {\r\nnx842_build_scatterlist(outbuf, max_sync_size, &slout);\r\nop.out = nx842_get_pa(slout.entries);\r\nop.outlen = -nx842_get_scatterlist_size(&slout);\r\n}\r\nret = vio_h_cop_sync(local_devdata->vdev, &op);\r\nif (ret) {\r\ndev_dbg(dev, "%s: vio_h_cop_sync error (ret=%d, hret=%ld)\n",\r\n__func__, ret, op.hcall_err);\r\ndev = NULL;\r\ngoto sw;\r\n}\r\nret = nx842_validate_result(dev, &csbcpb->csb);\r\nif (ret) {\r\ndev = NULL;\r\ngoto sw;\r\n}\r\ninbuf += hdr->sizes[i];\r\noutbuf += csbcpb->csb.processed_byte_count;\r\ncontinue;\r\nsw:\r\nsize = max_sync_size;\r\nret = sw842_decompress(\r\n(unsigned char *)inbuf, hdr->sizes[i],\r\n(unsigned char *)outbuf, &size, wmem);\r\nif (ret)\r\npr_debug("%s: sw842_decompress failed with %d\n",\r\n__func__, ret);\r\nif (ret) {\r\nif (ret != -ENOSPC && ret != -EINVAL &&\r\nret != -EMSGSIZE)\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\ninbuf += hdr->sizes[i];\r\noutbuf += size;\r\n}\r\n*outlen = (unsigned int)(outbuf - (unsigned long)out);\r\nunlock:\r\nif (ret)\r\nnx842_inc_decomp_failed(local_devdata);\r\nelse {\r\nif (!dev)\r\nnx842_inc_swdecomp(local_devdata);\r\nnx842_inc_decomp_complete(local_devdata);\r\nibm_nx842_incr_hist(local_devdata->counters->decomp_times,\r\n(get_tb() - start_time) / tb_ticks_per_usec);\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic int nx842_OF_set_defaults(struct nx842_devdata *devdata)\r\n{\r\nif (devdata) {\r\ndevdata->max_sync_size = 0;\r\ndevdata->max_sync_sg = 0;\r\ndevdata->max_sg_len = 0;\r\ndevdata->status = UNAVAILABLE;\r\nreturn 0;\r\n} else\r\nreturn -ENOENT;\r\n}\r\nstatic int nx842_OF_upd_status(struct nx842_devdata *devdata,\r\nstruct property *prop) {\r\nint ret = 0;\r\nconst char *status = (const char *)prop->value;\r\nif (!strncmp(status, "okay", (size_t)prop->length)) {\r\ndevdata->status = AVAILABLE;\r\n} else {\r\ndev_info(devdata->dev, "%s: status '%s' is not 'okay'\n",\r\n__func__, status);\r\ndevdata->status = UNAVAILABLE;\r\n}\r\nreturn ret;\r\n}\r\nstatic int nx842_OF_upd_maxsglen(struct nx842_devdata *devdata,\r\nstruct property *prop) {\r\nint ret = 0;\r\nconst int *maxsglen = prop->value;\r\nif (prop->length != sizeof(*maxsglen)) {\r\ndev_err(devdata->dev, "%s: unexpected format for ibm,max-sg-len property\n", __func__);\r\ndev_dbg(devdata->dev, "%s: ibm,max-sg-len is %d bytes long, expected %lu bytes\n", __func__,\r\nprop->length, sizeof(*maxsglen));\r\nret = -EINVAL;\r\n} else {\r\ndevdata->max_sg_len = (unsigned int)min(*maxsglen,\r\n(int)NX842_HW_PAGE_SIZE);\r\n}\r\nreturn ret;\r\n}\r\nstatic int nx842_OF_upd_maxsyncop(struct nx842_devdata *devdata,\r\nstruct property *prop) {\r\nint ret = 0;\r\nconst struct maxsynccop_t {\r\nint comp_elements;\r\nint comp_data_limit;\r\nint comp_sg_limit;\r\nint decomp_elements;\r\nint decomp_data_limit;\r\nint decomp_sg_limit;\r\n} *maxsynccop;\r\nif (prop->length != sizeof(*maxsynccop)) {\r\ndev_err(devdata->dev, "%s: unexpected format for ibm,max-sync-cop property\n", __func__);\r\ndev_dbg(devdata->dev, "%s: ibm,max-sync-cop is %d bytes long, expected %lu bytes\n", __func__, prop->length,\r\nsizeof(*maxsynccop));\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmaxsynccop = (const struct maxsynccop_t *)prop->value;\r\ndevdata->max_sync_size =\r\n(unsigned int)min(maxsynccop->comp_data_limit,\r\nmaxsynccop->decomp_data_limit);\r\ndevdata->max_sync_size = min_t(unsigned int, devdata->max_sync_size,\r\nSIZE_64K);\r\nif (devdata->max_sync_size < SIZE_4K) {\r\ndev_err(devdata->dev, "%s: hardware max data size (%u) is "\r\n"less than the driver minimum, unable to use "\r\n"the hardware device\n",\r\n__func__, devdata->max_sync_size);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ndevdata->max_sync_sg = (unsigned int)min(maxsynccop->comp_sg_limit,\r\nmaxsynccop->decomp_sg_limit);\r\nif (devdata->max_sync_sg < 1) {\r\ndev_err(devdata->dev, "%s: hardware max sg size (%u) is "\r\n"less than the driver minimum, unable to use "\r\n"the hardware device\n",\r\n__func__, devdata->max_sync_sg);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int nx842_OF_upd(struct property *new_prop)\r\n{\r\nstruct nx842_devdata *old_devdata = NULL;\r\nstruct nx842_devdata *new_devdata = NULL;\r\nstruct device_node *of_node = NULL;\r\nstruct property *status = NULL;\r\nstruct property *maxsglen = NULL;\r\nstruct property *maxsyncop = NULL;\r\nint ret = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devdata_mutex, flags);\r\nold_devdata = rcu_dereference_check(devdata,\r\nlockdep_is_held(&devdata_mutex));\r\nif (old_devdata)\r\nof_node = old_devdata->dev->of_node;\r\nif (!old_devdata || !of_node) {\r\npr_err("%s: device is not available\n", __func__);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nreturn -ENODEV;\r\n}\r\nnew_devdata = kzalloc(sizeof(*new_devdata), GFP_NOFS);\r\nif (!new_devdata) {\r\ndev_err(old_devdata->dev, "%s: Could not allocate memory for device data\n", __func__);\r\nret = -ENOMEM;\r\ngoto error_out;\r\n}\r\nmemcpy(new_devdata, old_devdata, sizeof(*old_devdata));\r\nnew_devdata->counters = old_devdata->counters;\r\nstatus = of_find_property(of_node, "status", NULL);\r\nmaxsglen = of_find_property(of_node, "ibm,max-sg-len", NULL);\r\nmaxsyncop = of_find_property(of_node, "ibm,max-sync-cop", NULL);\r\nif (!status || !maxsglen || !maxsyncop) {\r\ndev_err(old_devdata->dev, "%s: Could not locate device properties\n", __func__);\r\nret = -EINVAL;\r\ngoto error_out;\r\n}\r\nif (new_prop) {\r\nif (!strncmp(new_prop->name, "status", new_prop->length)) {\r\nstatus = new_prop;\r\n} else if (!strncmp(new_prop->name, "ibm,max-sg-len",\r\nnew_prop->length)) {\r\nmaxsglen = new_prop;\r\n} else if (!strncmp(new_prop->name, "ibm,max-sync-cop",\r\nnew_prop->length)) {\r\nmaxsyncop = new_prop;\r\n} else {\r\ngoto out;\r\n}\r\n}\r\nret = nx842_OF_upd_status(new_devdata, status);\r\nif (ret)\r\ngoto error_out;\r\nret = nx842_OF_upd_maxsglen(new_devdata, maxsglen);\r\nif (ret)\r\ngoto error_out;\r\nret = nx842_OF_upd_maxsyncop(new_devdata, maxsyncop);\r\nif (ret)\r\ngoto error_out;\r\nout:\r\ndev_info(old_devdata->dev, "%s: max_sync_size new:%u old:%u\n",\r\n__func__, new_devdata->max_sync_size,\r\nold_devdata->max_sync_size);\r\ndev_info(old_devdata->dev, "%s: max_sync_sg new:%u old:%u\n",\r\n__func__, new_devdata->max_sync_sg,\r\nold_devdata->max_sync_sg);\r\ndev_info(old_devdata->dev, "%s: max_sg_len new:%u old:%u\n",\r\n__func__, new_devdata->max_sg_len,\r\nold_devdata->max_sg_len);\r\nrcu_assign_pointer(devdata, new_devdata);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nsynchronize_rcu();\r\ndev_set_drvdata(new_devdata->dev, new_devdata);\r\nkfree(old_devdata);\r\nreturn 0;\r\nerror_out:\r\nif (new_devdata) {\r\ndev_info(old_devdata->dev, "%s: device disabled\n", __func__);\r\nnx842_OF_set_defaults(new_devdata);\r\nrcu_assign_pointer(devdata, new_devdata);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nsynchronize_rcu();\r\ndev_set_drvdata(new_devdata->dev, new_devdata);\r\nkfree(old_devdata);\r\n} else {\r\ndev_err(old_devdata->dev, "%s: could not update driver from hardware\n", __func__);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\n}\r\nif (!ret)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int nx842_OF_notifier(struct notifier_block *np, unsigned long action,\r\nvoid *update)\r\n{\r\nstruct of_prop_reconfig *upd = update;\r\nstruct nx842_devdata *local_devdata;\r\nstruct device_node *node = NULL;\r\nrcu_read_lock();\r\nlocal_devdata = rcu_dereference(devdata);\r\nif (local_devdata)\r\nnode = local_devdata->dev->of_node;\r\nif (local_devdata &&\r\naction == OF_RECONFIG_UPDATE_PROPERTY &&\r\n!strcmp(upd->dn->name, node->name)) {\r\nrcu_read_unlock();\r\nnx842_OF_upd(upd->prop);\r\n} else\r\nrcu_read_unlock();\r\nreturn NOTIFY_OK;\r\n}\r\nstatic ssize_t nx842_timehist_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf) {\r\nchar *p = buf;\r\nstruct nx842_devdata *local_devdata;\r\natomic64_t *times;\r\nint bytes_remain = PAGE_SIZE;\r\nint bytes;\r\nint i;\r\nrcu_read_lock();\r\nlocal_devdata = rcu_dereference(devdata);\r\nif (!local_devdata) {\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nif (attr == &dev_attr_comp_times)\r\ntimes = local_devdata->counters->comp_times;\r\nelse if (attr == &dev_attr_decomp_times)\r\ntimes = local_devdata->counters->decomp_times;\r\nelse {\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nfor (i = 0; i < (NX842_HIST_SLOTS - 2); i++) {\r\nbytes = snprintf(p, bytes_remain, "%u-%uus:\t%ld\n",\r\ni ? (2<<(i-1)) : 0, (2<<i)-1,\r\natomic64_read(&times[i]));\r\nbytes_remain -= bytes;\r\np += bytes;\r\n}\r\nbytes = snprintf(p, bytes_remain, "%uus - :\t%ld\n",\r\n2<<(NX842_HIST_SLOTS - 2),\r\natomic64_read(&times[(NX842_HIST_SLOTS - 1)]));\r\np += bytes;\r\nrcu_read_unlock();\r\nreturn p - buf;\r\n}\r\nstatic int __init nx842_probe(struct vio_dev *viodev,\r\nconst struct vio_device_id *id)\r\n{\r\nstruct nx842_devdata *old_devdata, *new_devdata = NULL;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&devdata_mutex, flags);\r\nold_devdata = rcu_dereference_check(devdata,\r\nlockdep_is_held(&devdata_mutex));\r\nif (old_devdata && old_devdata->vdev != NULL) {\r\ndev_err(&viodev->dev, "%s: Attempt to register more than one instance of the hardware\n", __func__);\r\nret = -1;\r\ngoto error_unlock;\r\n}\r\ndev_set_drvdata(&viodev->dev, NULL);\r\nnew_devdata = kzalloc(sizeof(*new_devdata), GFP_NOFS);\r\nif (!new_devdata) {\r\ndev_err(&viodev->dev, "%s: Could not allocate memory for device data\n", __func__);\r\nret = -ENOMEM;\r\ngoto error_unlock;\r\n}\r\nnew_devdata->counters = kzalloc(sizeof(*new_devdata->counters),\r\nGFP_NOFS);\r\nif (!new_devdata->counters) {\r\ndev_err(&viodev->dev, "%s: Could not allocate memory for performance counters\n", __func__);\r\nret = -ENOMEM;\r\ngoto error_unlock;\r\n}\r\nnew_devdata->vdev = viodev;\r\nnew_devdata->dev = &viodev->dev;\r\nnx842_OF_set_defaults(new_devdata);\r\nrcu_assign_pointer(devdata, new_devdata);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nsynchronize_rcu();\r\nkfree(old_devdata);\r\nof_reconfig_notifier_register(&nx842_of_nb);\r\nret = nx842_OF_upd(NULL);\r\nif (ret && ret != -ENODEV) {\r\ndev_err(&viodev->dev, "could not parse device tree. %d\n", ret);\r\nret = -1;\r\ngoto error;\r\n}\r\nrcu_read_lock();\r\nif (dev_set_drvdata(&viodev->dev, rcu_dereference(devdata))) {\r\nrcu_read_unlock();\r\ndev_err(&viodev->dev, "failed to set driver data for device\n");\r\nret = -1;\r\ngoto error;\r\n}\r\nrcu_read_unlock();\r\nif (sysfs_create_group(&viodev->dev.kobj, &nx842_attribute_group)) {\r\ndev_err(&viodev->dev, "could not create sysfs device attributes\n");\r\nret = -1;\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror_unlock:\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nif (new_devdata)\r\nkfree(new_devdata->counters);\r\nkfree(new_devdata);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int __exit nx842_remove(struct vio_dev *viodev)\r\n{\r\nstruct nx842_devdata *old_devdata;\r\nunsigned long flags;\r\npr_info("Removing IBM Power 842 compression device\n");\r\nsysfs_remove_group(&viodev->dev.kobj, &nx842_attribute_group);\r\nspin_lock_irqsave(&devdata_mutex, flags);\r\nold_devdata = rcu_dereference_check(devdata,\r\nlockdep_is_held(&devdata_mutex));\r\nof_reconfig_notifier_unregister(&nx842_of_nb);\r\nrcu_assign_pointer(devdata, NULL);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nsynchronize_rcu();\r\ndev_set_drvdata(&viodev->dev, NULL);\r\nif (old_devdata)\r\nkfree(old_devdata->counters);\r\nkfree(old_devdata);\r\nreturn 0;\r\n}\r\nstatic int __init nx842_init(void)\r\n{\r\nstruct nx842_devdata *new_devdata;\r\npr_info("Registering IBM Power 842 compression driver\n");\r\nRCU_INIT_POINTER(devdata, NULL);\r\nnew_devdata = kzalloc(sizeof(*new_devdata), GFP_KERNEL);\r\nif (!new_devdata) {\r\npr_err("Could not allocate memory for device data\n");\r\nreturn -ENOMEM;\r\n}\r\nnew_devdata->status = UNAVAILABLE;\r\nRCU_INIT_POINTER(devdata, new_devdata);\r\nreturn vio_register_driver(&nx842_driver);\r\n}\r\nstatic void __exit nx842_exit(void)\r\n{\r\nstruct nx842_devdata *old_devdata;\r\nunsigned long flags;\r\npr_info("Exiting IBM Power 842 compression driver\n");\r\nspin_lock_irqsave(&devdata_mutex, flags);\r\nold_devdata = rcu_dereference_check(devdata,\r\nlockdep_is_held(&devdata_mutex));\r\nrcu_assign_pointer(devdata, NULL);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nsynchronize_rcu();\r\nif (old_devdata)\r\ndev_set_drvdata(old_devdata->dev, NULL);\r\nkfree(old_devdata);\r\nvio_unregister_driver(&nx842_driver);\r\n}\r\nstatic uint8_t sw842_get_byte(const char *buf, int bit)\r\n{\r\nuint8_t tmpl;\r\nuint16_t tmp;\r\ntmp = htons(*(uint16_t *)(buf));\r\ntmp = (uint16_t)(tmp << bit);\r\ntmp = ntohs(tmp);\r\nmemcpy(&tmpl, &tmp, 1);\r\nreturn tmpl;\r\n}\r\nstatic uint8_t sw842_get_template(const char **buf, int *bit)\r\n{\r\nuint8_t byte;\r\nbyte = sw842_get_byte(*buf, *bit);\r\nbyte = byte >> 3;\r\nbyte &= 0x1F;\r\n*buf += (*bit + 5) / 8;\r\n*bit = (*bit + 5) % 8;\r\nreturn byte;\r\n}\r\nstatic uint8_t sw842_get_repeat_count(const char **buf, int *bit)\r\n{\r\nuint8_t byte;\r\nbyte = sw842_get_byte(*buf, *bit);\r\nbyte = byte >> 2;\r\nbyte &= 0x3F;\r\n*buf += (*bit + 6) / 8;\r\n*bit = (*bit + 6) % 8;\r\nreturn byte;\r\n}\r\nstatic uint8_t sw842_get_ptr2(const char **buf, int *bit)\r\n{\r\nuint8_t ptr;\r\nptr = sw842_get_byte(*buf, *bit);\r\n(*buf)++;\r\nreturn ptr;\r\n}\r\nstatic uint16_t sw842_get_ptr4(const char **buf, int *bit,\r\nstruct sw842_fifo *fifo)\r\n{\r\nuint16_t ptr;\r\nptr = htons(*(uint16_t *)(*buf));\r\nptr = (uint16_t)(ptr << *bit);\r\nptr = ptr >> 7;\r\nptr &= 0x01FF;\r\n*buf += (*bit + 9) / 8;\r\n*bit = (*bit + 9) % 8;\r\nreturn ptr;\r\n}\r\nstatic uint8_t sw842_get_ptr8(const char **buf, int *bit,\r\nstruct sw842_fifo *fifo)\r\n{\r\nreturn sw842_get_ptr2(buf, bit);\r\n}\r\nstatic int sw842_data8(const char **inbuf, int *inbit,\r\nunsigned char **outbuf, struct sw842_fifo *fifo)\r\n{\r\nint ret;\r\nret = sw842_data4(inbuf, inbit, outbuf, fifo);\r\nif (ret)\r\nreturn ret;\r\nret = sw842_data4(inbuf, inbit, outbuf, fifo);\r\nreturn ret;\r\n}\r\nstatic int sw842_data4(const char **inbuf, int *inbit,\r\nunsigned char **outbuf, struct sw842_fifo *fifo)\r\n{\r\nint ret;\r\nret = sw842_data2(inbuf, inbit, outbuf, fifo);\r\nif (ret)\r\nreturn ret;\r\nret = sw842_data2(inbuf, inbit, outbuf, fifo);\r\nreturn ret;\r\n}\r\nstatic int sw842_data2(const char **inbuf, int *inbit,\r\nunsigned char **outbuf, struct sw842_fifo *fifo)\r\n{\r\n**outbuf = sw842_get_byte(*inbuf, *inbit);\r\n(*inbuf)++;\r\n(*outbuf)++;\r\n**outbuf = sw842_get_byte(*inbuf, *inbit);\r\n(*inbuf)++;\r\n(*outbuf)++;\r\nreturn 0;\r\n}\r\nstatic int sw842_ptr8(const char **inbuf, int *inbit,\r\nunsigned char **outbuf, struct sw842_fifo *fifo)\r\n{\r\nuint8_t ptr;\r\nptr = sw842_get_ptr8(inbuf, inbit, fifo);\r\nif (!fifo->f84_full && (ptr >= fifo->f8_count))\r\nreturn 1;\r\nmemcpy(*outbuf, fifo->f8[ptr], 8);\r\n*outbuf += 8;\r\nreturn 0;\r\n}\r\nstatic int sw842_ptr4(const char **inbuf, int *inbit,\r\nunsigned char **outbuf, struct sw842_fifo *fifo)\r\n{\r\nuint16_t ptr;\r\nptr = sw842_get_ptr4(inbuf, inbit, fifo);\r\nif (!fifo->f84_full && (ptr >= fifo->f4_count))\r\nreturn 1;\r\nmemcpy(*outbuf, fifo->f4[ptr], 4);\r\n*outbuf += 4;\r\nreturn 0;\r\n}\r\nstatic int sw842_ptr2(const char **inbuf, int *inbit,\r\nunsigned char **outbuf, struct sw842_fifo *fifo)\r\n{\r\nuint8_t ptr;\r\nptr = sw842_get_ptr2(inbuf, inbit);\r\nif (!fifo->f2_full && (ptr >= fifo->f2_count))\r\nreturn 1;\r\nmemcpy(*outbuf, fifo->f2[ptr], 2);\r\n*outbuf += 2;\r\nreturn 0;\r\n}\r\nstatic void sw842_copy_to_fifo(const char *buf, struct sw842_fifo *fifo)\r\n{\r\nunsigned char initial_f2count = fifo->f2_count;\r\nmemcpy(fifo->f8[fifo->f8_count], buf, 8);\r\nfifo->f4_count += 2;\r\nfifo->f8_count += 1;\r\nif (!fifo->f84_full && fifo->f4_count >= 512) {\r\nfifo->f84_full = 1;\r\nfifo->f4_count /= 512;\r\n}\r\nmemcpy(fifo->f2[fifo->f2_count++], buf, 2);\r\nmemcpy(fifo->f2[fifo->f2_count++], buf + 2, 2);\r\nmemcpy(fifo->f2[fifo->f2_count++], buf + 4, 2);\r\nmemcpy(fifo->f2[fifo->f2_count++], buf + 6, 2);\r\nif (fifo->f2_count < initial_f2count)\r\nfifo->f2_full = 1;\r\n}\r\nstatic int sw842_decompress(const unsigned char *src, int srclen,\r\nunsigned char *dst, int *destlen,\r\nconst void *wrkmem)\r\n{\r\nuint8_t tmpl;\r\nconst char *inbuf;\r\nint inbit = 0;\r\nunsigned char *outbuf, *outbuf_end, *origbuf, *prevbuf;\r\nconst char *inbuf_end;\r\nsw842_template_op op;\r\nint opindex;\r\nint i, repeat_count;\r\nstruct sw842_fifo *fifo;\r\nint ret = 0;\r\nfifo = &((struct nx842_workmem *)(wrkmem))->swfifo;\r\nmemset(fifo, 0, sizeof(*fifo));\r\norigbuf = NULL;\r\ninbuf = src;\r\ninbuf_end = src + srclen;\r\noutbuf = dst;\r\noutbuf_end = dst + *destlen;\r\nwhile ((tmpl = sw842_get_template(&inbuf, &inbit)) != SW842_TMPL_EOF) {\r\nif (inbuf >= inbuf_end) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nopindex = 0;\r\nprevbuf = origbuf;\r\norigbuf = outbuf;\r\nswitch (tmpl) {\r\ncase SW842_TMPL_REPEAT:\r\nif (prevbuf == NULL) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nrepeat_count = sw842_get_repeat_count(&inbuf,\r\n&inbit) + 1;\r\nif (inbuf > inbuf_end) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < repeat_count; i++) {\r\nif ((outbuf + 8) > outbuf_end) {\r\nret = -ENOSPC;\r\ngoto out;\r\n}\r\nmemcpy(outbuf, prevbuf, 8);\r\nsw842_copy_to_fifo(outbuf, fifo);\r\noutbuf += 8;\r\n}\r\nbreak;\r\ncase SW842_TMPL_ZEROS:\r\nif ((outbuf + 8) > outbuf_end) {\r\nret = -ENOSPC;\r\ngoto out;\r\n}\r\nmemset(outbuf, 0, 8);\r\nsw842_copy_to_fifo(outbuf, fifo);\r\noutbuf += 8;\r\nbreak;\r\ndefault:\r\nif (tmpl > 25) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif ((inbuf + 2) > inbuf_end) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif ((outbuf + 8) > outbuf_end) {\r\nret = -ENOSPC;\r\ngoto out;\r\n}\r\nwhile (opindex < 4 &&\r\n(op = sw842_tmpl_ops[tmpl][opindex++])\r\n!= NULL) {\r\nret = (*op)(&inbuf, &inbit, &outbuf, fifo);\r\nif (ret) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nsw842_copy_to_fifo(origbuf, fifo);\r\n}\r\n}\r\n}\r\nout:\r\nif (!ret)\r\n*destlen = (unsigned int)(outbuf - dst);\r\nelse\r\n*destlen = 0;\r\nreturn ret;\r\n}
