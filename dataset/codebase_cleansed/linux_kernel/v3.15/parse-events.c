static int tp_event_has_id(struct dirent *sys_dir, struct dirent *evt_dir)\r\n{\r\nchar evt_path[MAXPATHLEN];\r\nint fd;\r\nsnprintf(evt_path, MAXPATHLEN, "%s/%s/%s/id", tracing_events_path,\r\nsys_dir->d_name, evt_dir->d_name);\r\nfd = open(evt_path, O_RDONLY);\r\nif (fd < 0)\r\nreturn -EINVAL;\r\nclose(fd);\r\nreturn 0;\r\n}\r\nstruct tracepoint_path *tracepoint_id_to_path(u64 config)\r\n{\r\nstruct tracepoint_path *path = NULL;\r\nDIR *sys_dir, *evt_dir;\r\nstruct dirent *sys_next, *evt_next, sys_dirent, evt_dirent;\r\nchar id_buf[24];\r\nint fd;\r\nu64 id;\r\nchar evt_path[MAXPATHLEN];\r\nchar dir_path[MAXPATHLEN];\r\nif (debugfs_valid_mountpoint(tracing_events_path))\r\nreturn NULL;\r\nsys_dir = opendir(tracing_events_path);\r\nif (!sys_dir)\r\nreturn NULL;\r\nfor_each_subsystem(sys_dir, sys_dirent, sys_next) {\r\nsnprintf(dir_path, MAXPATHLEN, "%s/%s", tracing_events_path,\r\nsys_dirent.d_name);\r\nevt_dir = opendir(dir_path);\r\nif (!evt_dir)\r\ncontinue;\r\nfor_each_event(sys_dirent, evt_dir, evt_dirent, evt_next) {\r\nsnprintf(evt_path, MAXPATHLEN, "%s/%s/id", dir_path,\r\nevt_dirent.d_name);\r\nfd = open(evt_path, O_RDONLY);\r\nif (fd < 0)\r\ncontinue;\r\nif (read(fd, id_buf, sizeof(id_buf)) < 0) {\r\nclose(fd);\r\ncontinue;\r\n}\r\nclose(fd);\r\nid = atoll(id_buf);\r\nif (id == config) {\r\nclosedir(evt_dir);\r\nclosedir(sys_dir);\r\npath = zalloc(sizeof(*path));\r\npath->system = malloc(MAX_EVENT_LENGTH);\r\nif (!path->system) {\r\nfree(path);\r\nreturn NULL;\r\n}\r\npath->name = malloc(MAX_EVENT_LENGTH);\r\nif (!path->name) {\r\nzfree(&path->system);\r\nfree(path);\r\nreturn NULL;\r\n}\r\nstrncpy(path->system, sys_dirent.d_name,\r\nMAX_EVENT_LENGTH);\r\nstrncpy(path->name, evt_dirent.d_name,\r\nMAX_EVENT_LENGTH);\r\nreturn path;\r\n}\r\n}\r\nclosedir(evt_dir);\r\n}\r\nclosedir(sys_dir);\r\nreturn NULL;\r\n}\r\nstruct tracepoint_path *tracepoint_name_to_path(const char *name)\r\n{\r\nstruct tracepoint_path *path = zalloc(sizeof(*path));\r\nchar *str = strchr(name, ':');\r\nif (path == NULL || str == NULL) {\r\nfree(path);\r\nreturn NULL;\r\n}\r\npath->system = strndup(name, str - name);\r\npath->name = strdup(str+1);\r\nif (path->system == NULL || path->name == NULL) {\r\nzfree(&path->system);\r\nzfree(&path->name);\r\nfree(path);\r\npath = NULL;\r\n}\r\nreturn path;\r\n}\r\nconst char *event_type(int type)\r\n{\r\nswitch (type) {\r\ncase PERF_TYPE_HARDWARE:\r\nreturn "hardware";\r\ncase PERF_TYPE_SOFTWARE:\r\nreturn "software";\r\ncase PERF_TYPE_TRACEPOINT:\r\nreturn "tracepoint";\r\ncase PERF_TYPE_HW_CACHE:\r\nreturn "hardware-cache";\r\ndefault:\r\nbreak;\r\n}\r\nreturn "unknown";\r\n}\r\nstatic struct perf_evsel *\r\n__add_event(struct list_head *list, int *idx,\r\nstruct perf_event_attr *attr,\r\nchar *name, struct cpu_map *cpus)\r\n{\r\nstruct perf_evsel *evsel;\r\nevent_attr_init(attr);\r\nevsel = perf_evsel__new_idx(attr, (*idx)++);\r\nif (!evsel)\r\nreturn NULL;\r\nevsel->cpus = cpus;\r\nif (name)\r\nevsel->name = strdup(name);\r\nlist_add_tail(&evsel->node, list);\r\nreturn evsel;\r\n}\r\nstatic int add_event(struct list_head *list, int *idx,\r\nstruct perf_event_attr *attr, char *name)\r\n{\r\nreturn __add_event(list, idx, attr, name, NULL) ? 0 : -ENOMEM;\r\n}\r\nstatic int parse_aliases(char *str, const char *names[][PERF_EVSEL__MAX_ALIASES], int size)\r\n{\r\nint i, j;\r\nint n, longest = -1;\r\nfor (i = 0; i < size; i++) {\r\nfor (j = 0; j < PERF_EVSEL__MAX_ALIASES && names[i][j]; j++) {\r\nn = strlen(names[i][j]);\r\nif (n > longest && !strncasecmp(str, names[i][j], n))\r\nlongest = n;\r\n}\r\nif (longest > 0)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nint parse_events_add_cache(struct list_head *list, int *idx,\r\nchar *type, char *op_result1, char *op_result2)\r\n{\r\nstruct perf_event_attr attr;\r\nchar name[MAX_NAME_LEN];\r\nint cache_type = -1, cache_op = -1, cache_result = -1;\r\nchar *op_result[2] = { op_result1, op_result2 };\r\nint i, n;\r\ncache_type = parse_aliases(type, perf_evsel__hw_cache,\r\nPERF_COUNT_HW_CACHE_MAX);\r\nif (cache_type == -1)\r\nreturn -EINVAL;\r\nn = snprintf(name, MAX_NAME_LEN, "%s", type);\r\nfor (i = 0; (i < 2) && (op_result[i]); i++) {\r\nchar *str = op_result[i];\r\nn += snprintf(name + n, MAX_NAME_LEN - n, "-%s", str);\r\nif (cache_op == -1) {\r\ncache_op = parse_aliases(str, perf_evsel__hw_cache_op,\r\nPERF_COUNT_HW_CACHE_OP_MAX);\r\nif (cache_op >= 0) {\r\nif (!perf_evsel__is_cache_op_valid(cache_type, cache_op))\r\nreturn -EINVAL;\r\ncontinue;\r\n}\r\n}\r\nif (cache_result == -1) {\r\ncache_result = parse_aliases(str, perf_evsel__hw_cache_result,\r\nPERF_COUNT_HW_CACHE_RESULT_MAX);\r\nif (cache_result >= 0)\r\ncontinue;\r\n}\r\n}\r\nif (cache_op == -1)\r\ncache_op = PERF_COUNT_HW_CACHE_OP_READ;\r\nif (cache_result == -1)\r\ncache_result = PERF_COUNT_HW_CACHE_RESULT_ACCESS;\r\nmemset(&attr, 0, sizeof(attr));\r\nattr.config = cache_type | (cache_op << 8) | (cache_result << 16);\r\nattr.type = PERF_TYPE_HW_CACHE;\r\nreturn add_event(list, idx, &attr, name);\r\n}\r\nstatic int add_tracepoint(struct list_head *list, int *idx,\r\nchar *sys_name, char *evt_name)\r\n{\r\nstruct perf_evsel *evsel;\r\nevsel = perf_evsel__newtp_idx(sys_name, evt_name, (*idx)++);\r\nif (!evsel)\r\nreturn -ENOMEM;\r\nlist_add_tail(&evsel->node, list);\r\nreturn 0;\r\n}\r\nstatic int add_tracepoint_multi_event(struct list_head *list, int *idx,\r\nchar *sys_name, char *evt_name)\r\n{\r\nchar evt_path[MAXPATHLEN];\r\nstruct dirent *evt_ent;\r\nDIR *evt_dir;\r\nint ret = 0;\r\nsnprintf(evt_path, MAXPATHLEN, "%s/%s", tracing_events_path, sys_name);\r\nevt_dir = opendir(evt_path);\r\nif (!evt_dir) {\r\nperror("Can't open event dir");\r\nreturn -1;\r\n}\r\nwhile (!ret && (evt_ent = readdir(evt_dir))) {\r\nif (!strcmp(evt_ent->d_name, ".")\r\n|| !strcmp(evt_ent->d_name, "..")\r\n|| !strcmp(evt_ent->d_name, "enable")\r\n|| !strcmp(evt_ent->d_name, "filter"))\r\ncontinue;\r\nif (!strglobmatch(evt_ent->d_name, evt_name))\r\ncontinue;\r\nret = add_tracepoint(list, idx, sys_name, evt_ent->d_name);\r\n}\r\nclosedir(evt_dir);\r\nreturn ret;\r\n}\r\nstatic int add_tracepoint_event(struct list_head *list, int *idx,\r\nchar *sys_name, char *evt_name)\r\n{\r\nreturn strpbrk(evt_name, "*?") ?\r\nadd_tracepoint_multi_event(list, idx, sys_name, evt_name) :\r\nadd_tracepoint(list, idx, sys_name, evt_name);\r\n}\r\nstatic int add_tracepoint_multi_sys(struct list_head *list, int *idx,\r\nchar *sys_name, char *evt_name)\r\n{\r\nstruct dirent *events_ent;\r\nDIR *events_dir;\r\nint ret = 0;\r\nevents_dir = opendir(tracing_events_path);\r\nif (!events_dir) {\r\nperror("Can't open event dir");\r\nreturn -1;\r\n}\r\nwhile (!ret && (events_ent = readdir(events_dir))) {\r\nif (!strcmp(events_ent->d_name, ".")\r\n|| !strcmp(events_ent->d_name, "..")\r\n|| !strcmp(events_ent->d_name, "enable")\r\n|| !strcmp(events_ent->d_name, "header_event")\r\n|| !strcmp(events_ent->d_name, "header_page"))\r\ncontinue;\r\nif (!strglobmatch(events_ent->d_name, sys_name))\r\ncontinue;\r\nret = add_tracepoint_event(list, idx, events_ent->d_name,\r\nevt_name);\r\n}\r\nclosedir(events_dir);\r\nreturn ret;\r\n}\r\nint parse_events_add_tracepoint(struct list_head *list, int *idx,\r\nchar *sys, char *event)\r\n{\r\nint ret;\r\nret = debugfs_valid_mountpoint(tracing_events_path);\r\nif (ret)\r\nreturn ret;\r\nif (strpbrk(sys, "*?"))\r\nreturn add_tracepoint_multi_sys(list, idx, sys, event);\r\nelse\r\nreturn add_tracepoint_event(list, idx, sys, event);\r\n}\r\nstatic int\r\nparse_breakpoint_type(const char *type, struct perf_event_attr *attr)\r\n{\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nif (!type || !type[i])\r\nbreak;\r\n#define CHECK_SET_TYPE(bit) \\r\ndo { \\r\nif (attr->bp_type & bit) \\r\nreturn -EINVAL; \\r\nelse \\r\nattr->bp_type |= bit; \\r\n} while (0)\r\nswitch (type[i]) {\r\ncase 'r':\r\nCHECK_SET_TYPE(HW_BREAKPOINT_R);\r\nbreak;\r\ncase 'w':\r\nCHECK_SET_TYPE(HW_BREAKPOINT_W);\r\nbreak;\r\ncase 'x':\r\nCHECK_SET_TYPE(HW_BREAKPOINT_X);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\n#undef CHECK_SET_TYPE\r\nif (!attr->bp_type)\r\nattr->bp_type = HW_BREAKPOINT_R | HW_BREAKPOINT_W;\r\nreturn 0;\r\n}\r\nint parse_events_add_breakpoint(struct list_head *list, int *idx,\r\nvoid *ptr, char *type)\r\n{\r\nstruct perf_event_attr attr;\r\nmemset(&attr, 0, sizeof(attr));\r\nattr.bp_addr = (unsigned long) ptr;\r\nif (parse_breakpoint_type(type, &attr))\r\nreturn -EINVAL;\r\nif (attr.bp_type == HW_BREAKPOINT_X)\r\nattr.bp_len = sizeof(long);\r\nelse\r\nattr.bp_len = HW_BREAKPOINT_LEN_4;\r\nattr.type = PERF_TYPE_BREAKPOINT;\r\nattr.sample_period = 1;\r\nreturn add_event(list, idx, &attr, NULL);\r\n}\r\nstatic int config_term(struct perf_event_attr *attr,\r\nstruct parse_events_term *term)\r\n{\r\n#define CHECK_TYPE_VAL(type) \\r\ndo { \\r\nif (PARSE_EVENTS__TERM_TYPE_ ## type != term->type_val) \\r\nreturn -EINVAL; \\r\n} while (0)\r\nswitch (term->type_term) {\r\ncase PARSE_EVENTS__TERM_TYPE_CONFIG:\r\nCHECK_TYPE_VAL(NUM);\r\nattr->config = term->val.num;\r\nbreak;\r\ncase PARSE_EVENTS__TERM_TYPE_CONFIG1:\r\nCHECK_TYPE_VAL(NUM);\r\nattr->config1 = term->val.num;\r\nbreak;\r\ncase PARSE_EVENTS__TERM_TYPE_CONFIG2:\r\nCHECK_TYPE_VAL(NUM);\r\nattr->config2 = term->val.num;\r\nbreak;\r\ncase PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD:\r\nCHECK_TYPE_VAL(NUM);\r\nattr->sample_period = term->val.num;\r\nbreak;\r\ncase PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE:\r\nbreak;\r\ncase PARSE_EVENTS__TERM_TYPE_NAME:\r\nCHECK_TYPE_VAL(STR);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n#undef CHECK_TYPE_VAL\r\n}\r\nstatic int config_attr(struct perf_event_attr *attr,\r\nstruct list_head *head, int fail)\r\n{\r\nstruct parse_events_term *term;\r\nlist_for_each_entry(term, head, list)\r\nif (config_term(attr, term) && fail)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint parse_events_add_numeric(struct list_head *list, int *idx,\r\nu32 type, u64 config,\r\nstruct list_head *head_config)\r\n{\r\nstruct perf_event_attr attr;\r\nmemset(&attr, 0, sizeof(attr));\r\nattr.type = type;\r\nattr.config = config;\r\nif (head_config &&\r\nconfig_attr(&attr, head_config, 1))\r\nreturn -EINVAL;\r\nreturn add_event(list, idx, &attr, NULL);\r\n}\r\nstatic int parse_events__is_name_term(struct parse_events_term *term)\r\n{\r\nreturn term->type_term == PARSE_EVENTS__TERM_TYPE_NAME;\r\n}\r\nstatic char *pmu_event_name(struct list_head *head_terms)\r\n{\r\nstruct parse_events_term *term;\r\nlist_for_each_entry(term, head_terms, list)\r\nif (parse_events__is_name_term(term))\r\nreturn term->val.str;\r\nreturn NULL;\r\n}\r\nint parse_events_add_pmu(struct list_head *list, int *idx,\r\nchar *name, struct list_head *head_config)\r\n{\r\nstruct perf_event_attr attr;\r\nstruct perf_pmu *pmu;\r\nstruct perf_evsel *evsel;\r\nconst char *unit;\r\ndouble scale;\r\npmu = perf_pmu__find(name);\r\nif (!pmu)\r\nreturn -EINVAL;\r\nmemset(&attr, 0, sizeof(attr));\r\nif (perf_pmu__check_alias(pmu, head_config, &unit, &scale))\r\nreturn -EINVAL;\r\nconfig_attr(&attr, head_config, 0);\r\nif (perf_pmu__config(pmu, &attr, head_config))\r\nreturn -EINVAL;\r\nevsel = __add_event(list, idx, &attr, pmu_event_name(head_config),\r\npmu->cpus);\r\nif (evsel) {\r\nevsel->unit = unit;\r\nevsel->scale = scale;\r\n}\r\nreturn evsel ? 0 : -ENOMEM;\r\n}\r\nint parse_events__modifier_group(struct list_head *list,\r\nchar *event_mod)\r\n{\r\nreturn parse_events__modifier_event(list, event_mod, true);\r\n}\r\nvoid parse_events__set_leader(char *name, struct list_head *list)\r\n{\r\nstruct perf_evsel *leader;\r\n__perf_evlist__set_leader(list);\r\nleader = list_entry(list->next, struct perf_evsel, node);\r\nleader->group_name = name ? strdup(name) : NULL;\r\n}\r\nvoid parse_events_update_lists(struct list_head *list_event,\r\nstruct list_head *list_all)\r\n{\r\nlist_splice_tail(list_event, list_all);\r\nfree(list_event);\r\n}\r\nstatic int get_event_modifier(struct event_modifier *mod, char *str,\r\nstruct perf_evsel *evsel)\r\n{\r\nint eu = evsel ? evsel->attr.exclude_user : 0;\r\nint ek = evsel ? evsel->attr.exclude_kernel : 0;\r\nint eh = evsel ? evsel->attr.exclude_hv : 0;\r\nint eH = evsel ? evsel->attr.exclude_host : 0;\r\nint eG = evsel ? evsel->attr.exclude_guest : 0;\r\nint precise = evsel ? evsel->attr.precise_ip : 0;\r\nint sample_read = 0;\r\nint pinned = evsel ? evsel->attr.pinned : 0;\r\nint exclude = eu | ek | eh;\r\nint exclude_GH = evsel ? evsel->exclude_GH : 0;\r\nmemset(mod, 0, sizeof(*mod));\r\nwhile (*str) {\r\nif (*str == 'u') {\r\nif (!exclude)\r\nexclude = eu = ek = eh = 1;\r\neu = 0;\r\n} else if (*str == 'k') {\r\nif (!exclude)\r\nexclude = eu = ek = eh = 1;\r\nek = 0;\r\n} else if (*str == 'h') {\r\nif (!exclude)\r\nexclude = eu = ek = eh = 1;\r\neh = 0;\r\n} else if (*str == 'G') {\r\nif (!exclude_GH)\r\nexclude_GH = eG = eH = 1;\r\neG = 0;\r\n} else if (*str == 'H') {\r\nif (!exclude_GH)\r\nexclude_GH = eG = eH = 1;\r\neH = 0;\r\n} else if (*str == 'p') {\r\nprecise++;\r\nif (!exclude_GH)\r\neG = 1;\r\n} else if (*str == 'S') {\r\nsample_read = 1;\r\n} else if (*str == 'D') {\r\npinned = 1;\r\n} else\r\nbreak;\r\n++str;\r\n}\r\nif (precise > 3)\r\nreturn -EINVAL;\r\nmod->eu = eu;\r\nmod->ek = ek;\r\nmod->eh = eh;\r\nmod->eH = eH;\r\nmod->eG = eG;\r\nmod->precise = precise;\r\nmod->exclude_GH = exclude_GH;\r\nmod->sample_read = sample_read;\r\nmod->pinned = pinned;\r\nreturn 0;\r\n}\r\nstatic int check_modifier(char *str)\r\n{\r\nchar *p = str;\r\nif (strlen(str) > (sizeof("ukhGHpppSD") - 1))\r\nreturn -1;\r\nwhile (*p) {\r\nif (*p != 'p' && strchr(p + 1, *p))\r\nreturn -1;\r\np++;\r\n}\r\nreturn 0;\r\n}\r\nint parse_events__modifier_event(struct list_head *list, char *str, bool add)\r\n{\r\nstruct perf_evsel *evsel;\r\nstruct event_modifier mod;\r\nif (str == NULL)\r\nreturn 0;\r\nif (check_modifier(str))\r\nreturn -EINVAL;\r\nif (!add && get_event_modifier(&mod, str, NULL))\r\nreturn -EINVAL;\r\n__evlist__for_each(list, evsel) {\r\nif (add && get_event_modifier(&mod, str, evsel))\r\nreturn -EINVAL;\r\nevsel->attr.exclude_user = mod.eu;\r\nevsel->attr.exclude_kernel = mod.ek;\r\nevsel->attr.exclude_hv = mod.eh;\r\nevsel->attr.precise_ip = mod.precise;\r\nevsel->attr.exclude_host = mod.eH;\r\nevsel->attr.exclude_guest = mod.eG;\r\nevsel->exclude_GH = mod.exclude_GH;\r\nevsel->sample_read = mod.sample_read;\r\nif (perf_evsel__is_group_leader(evsel))\r\nevsel->attr.pinned = mod.pinned;\r\n}\r\nreturn 0;\r\n}\r\nint parse_events_name(struct list_head *list, char *name)\r\n{\r\nstruct perf_evsel *evsel;\r\n__evlist__for_each(list, evsel) {\r\nif (!evsel->name)\r\nevsel->name = strdup(name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_events_fixup(int ret, const char *str, void *data,\r\nint start_token)\r\n{\r\nchar *o = strdup(str);\r\nchar *s = NULL;\r\nchar *t = o;\r\nchar *p;\r\nint len = 0;\r\nif (!o)\r\nreturn ret;\r\nwhile ((p = strsep(&t, ",")) != NULL) {\r\nif (s)\r\nstr_append(&s, &len, ",");\r\nstr_append(&s, &len, "cpu/");\r\nstr_append(&s, &len, p);\r\nstr_append(&s, &len, "/");\r\n}\r\nfree(o);\r\nif (!s)\r\nreturn -ENOMEM;\r\nreturn parse_events__scanner(s, data, start_token);\r\n}\r\nstatic int parse_events__scanner(const char *str, void *data, int start_token)\r\n{\r\nYY_BUFFER_STATE buffer;\r\nvoid *scanner;\r\nint ret;\r\nret = parse_events_lex_init_extra(start_token, &scanner);\r\nif (ret)\r\nreturn ret;\r\nbuffer = parse_events__scan_string(str, scanner);\r\n#ifdef PARSER_DEBUG\r\nparse_events_debug = 1;\r\n#endif\r\nret = parse_events_parse(data, scanner);\r\nparse_events__flush_buffer(buffer, scanner);\r\nparse_events__delete_buffer(buffer, scanner);\r\nparse_events_lex_destroy(scanner);\r\nif (ret && !strchr(str, '/'))\r\nret = parse_events_fixup(ret, str, data, start_token);\r\nreturn ret;\r\n}\r\nint parse_events_terms(struct list_head *terms, const char *str)\r\n{\r\nstruct parse_events_terms data = {\r\n.terms = NULL,\r\n};\r\nint ret;\r\nret = parse_events__scanner(str, &data, PE_START_TERMS);\r\nif (!ret) {\r\nlist_splice(data.terms, terms);\r\nzfree(&data.terms);\r\nreturn 0;\r\n}\r\nif (data.terms)\r\nparse_events__free_terms(data.terms);\r\nreturn ret;\r\n}\r\nint parse_events(struct perf_evlist *evlist, const char *str)\r\n{\r\nstruct parse_events_evlist data = {\r\n.list = LIST_HEAD_INIT(data.list),\r\n.idx = evlist->nr_entries,\r\n};\r\nint ret;\r\nret = parse_events__scanner(str, &data, PE_START_EVENTS);\r\nif (!ret) {\r\nint entries = data.idx - evlist->nr_entries;\r\nperf_evlist__splice_list_tail(evlist, &data.list, entries);\r\nevlist->nr_groups += data.nr_groups;\r\nreturn 0;\r\n}\r\nreturn ret;\r\n}\r\nint parse_events_option(const struct option *opt, const char *str,\r\nint unset __maybe_unused)\r\n{\r\nstruct perf_evlist *evlist = *(struct perf_evlist **)opt->value;\r\nint ret = parse_events(evlist, str);\r\nif (ret) {\r\nfprintf(stderr, "invalid or unsupported event: '%s'\n", str);\r\nfprintf(stderr, "Run 'perf list' for a list of valid events\n");\r\n}\r\nreturn ret;\r\n}\r\nint parse_filter(const struct option *opt, const char *str,\r\nint unset __maybe_unused)\r\n{\r\nstruct perf_evlist *evlist = *(struct perf_evlist **)opt->value;\r\nstruct perf_evsel *last = NULL;\r\nif (evlist->nr_entries > 0)\r\nlast = perf_evlist__last(evlist);\r\nif (last == NULL || last->attr.type != PERF_TYPE_TRACEPOINT) {\r\nfprintf(stderr,\r\n"-F option should follow a -e tracepoint option\n");\r\nreturn -1;\r\n}\r\nlast->filter = strdup(str);\r\nif (last->filter == NULL) {\r\nfprintf(stderr, "not enough memory to hold filter string\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid print_tracepoint_events(const char *subsys_glob, const char *event_glob,\r\nbool name_only)\r\n{\r\nDIR *sys_dir, *evt_dir;\r\nstruct dirent *sys_next, *evt_next, sys_dirent, evt_dirent;\r\nchar evt_path[MAXPATHLEN];\r\nchar dir_path[MAXPATHLEN];\r\nif (debugfs_valid_mountpoint(tracing_events_path)) {\r\nprintf(" [ Tracepoints not available: %s ]\n", strerror(errno));\r\nreturn;\r\n}\r\nsys_dir = opendir(tracing_events_path);\r\nif (!sys_dir)\r\nreturn;\r\nfor_each_subsystem(sys_dir, sys_dirent, sys_next) {\r\nif (subsys_glob != NULL &&\r\n!strglobmatch(sys_dirent.d_name, subsys_glob))\r\ncontinue;\r\nsnprintf(dir_path, MAXPATHLEN, "%s/%s", tracing_events_path,\r\nsys_dirent.d_name);\r\nevt_dir = opendir(dir_path);\r\nif (!evt_dir)\r\ncontinue;\r\nfor_each_event(sys_dirent, evt_dir, evt_dirent, evt_next) {\r\nif (event_glob != NULL &&\r\n!strglobmatch(evt_dirent.d_name, event_glob))\r\ncontinue;\r\nif (name_only) {\r\nprintf("%s:%s ", sys_dirent.d_name, evt_dirent.d_name);\r\ncontinue;\r\n}\r\nsnprintf(evt_path, MAXPATHLEN, "%s:%s",\r\nsys_dirent.d_name, evt_dirent.d_name);\r\nprintf(" %-50s [%s]\n", evt_path,\r\nevent_type_descriptors[PERF_TYPE_TRACEPOINT]);\r\n}\r\nclosedir(evt_dir);\r\n}\r\nclosedir(sys_dir);\r\n}\r\nint is_valid_tracepoint(const char *event_string)\r\n{\r\nDIR *sys_dir, *evt_dir;\r\nstruct dirent *sys_next, *evt_next, sys_dirent, evt_dirent;\r\nchar evt_path[MAXPATHLEN];\r\nchar dir_path[MAXPATHLEN];\r\nif (debugfs_valid_mountpoint(tracing_events_path))\r\nreturn 0;\r\nsys_dir = opendir(tracing_events_path);\r\nif (!sys_dir)\r\nreturn 0;\r\nfor_each_subsystem(sys_dir, sys_dirent, sys_next) {\r\nsnprintf(dir_path, MAXPATHLEN, "%s/%s", tracing_events_path,\r\nsys_dirent.d_name);\r\nevt_dir = opendir(dir_path);\r\nif (!evt_dir)\r\ncontinue;\r\nfor_each_event(sys_dirent, evt_dir, evt_dirent, evt_next) {\r\nsnprintf(evt_path, MAXPATHLEN, "%s:%s",\r\nsys_dirent.d_name, evt_dirent.d_name);\r\nif (!strcmp(evt_path, event_string)) {\r\nclosedir(evt_dir);\r\nclosedir(sys_dir);\r\nreturn 1;\r\n}\r\n}\r\nclosedir(evt_dir);\r\n}\r\nclosedir(sys_dir);\r\nreturn 0;\r\n}\r\nstatic bool is_event_supported(u8 type, unsigned config)\r\n{\r\nbool ret = true;\r\nint open_return;\r\nstruct perf_evsel *evsel;\r\nstruct perf_event_attr attr = {\r\n.type = type,\r\n.config = config,\r\n.disabled = 1,\r\n};\r\nstruct {\r\nstruct thread_map map;\r\nint threads[1];\r\n} tmap = {\r\n.map.nr = 1,\r\n.threads = { 0 },\r\n};\r\nevsel = perf_evsel__new(&attr);\r\nif (evsel) {\r\nopen_return = perf_evsel__open(evsel, NULL, &tmap.map);\r\nret = open_return >= 0;\r\nif (open_return == -EACCES) {\r\nevsel->attr.exclude_kernel = 1;\r\nret = perf_evsel__open(evsel, NULL, &tmap.map) >= 0;\r\n}\r\nperf_evsel__delete(evsel);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __print_events_type(u8 type, struct event_symbol *syms,\r\nunsigned max)\r\n{\r\nchar name[64];\r\nunsigned i;\r\nfor (i = 0; i < max ; i++, syms++) {\r\nif (!is_event_supported(type, i))\r\ncontinue;\r\nif (strlen(syms->alias))\r\nsnprintf(name, sizeof(name), "%s OR %s",\r\nsyms->symbol, syms->alias);\r\nelse\r\nsnprintf(name, sizeof(name), "%s", syms->symbol);\r\nprintf(" %-50s [%s]\n", name, event_type_descriptors[type]);\r\n}\r\n}\r\nvoid print_events_type(u8 type)\r\n{\r\nif (type == PERF_TYPE_SOFTWARE)\r\n__print_events_type(type, event_symbols_sw, PERF_COUNT_SW_MAX);\r\nelse\r\n__print_events_type(type, event_symbols_hw, PERF_COUNT_HW_MAX);\r\n}\r\nint print_hwcache_events(const char *event_glob, bool name_only)\r\n{\r\nunsigned int type, op, i, printed = 0;\r\nchar name[64];\r\nfor (type = 0; type < PERF_COUNT_HW_CACHE_MAX; type++) {\r\nfor (op = 0; op < PERF_COUNT_HW_CACHE_OP_MAX; op++) {\r\nif (!perf_evsel__is_cache_op_valid(type, op))\r\ncontinue;\r\nfor (i = 0; i < PERF_COUNT_HW_CACHE_RESULT_MAX; i++) {\r\n__perf_evsel__hw_cache_type_op_res_name(type, op, i,\r\nname, sizeof(name));\r\nif (event_glob != NULL && !strglobmatch(name, event_glob))\r\ncontinue;\r\nif (!is_event_supported(PERF_TYPE_HW_CACHE,\r\ntype | (op << 8) | (i << 16)))\r\ncontinue;\r\nif (name_only)\r\nprintf("%s ", name);\r\nelse\r\nprintf(" %-50s [%s]\n", name,\r\nevent_type_descriptors[PERF_TYPE_HW_CACHE]);\r\n++printed;\r\n}\r\n}\r\n}\r\nif (printed)\r\nprintf("\n");\r\nreturn printed;\r\n}\r\nstatic void print_symbol_events(const char *event_glob, unsigned type,\r\nstruct event_symbol *syms, unsigned max,\r\nbool name_only)\r\n{\r\nunsigned i, printed = 0;\r\nchar name[MAX_NAME_LEN];\r\nfor (i = 0; i < max; i++, syms++) {\r\nif (event_glob != NULL &&\r\n!(strglobmatch(syms->symbol, event_glob) ||\r\n(syms->alias && strglobmatch(syms->alias, event_glob))))\r\ncontinue;\r\nif (!is_event_supported(type, i))\r\ncontinue;\r\nif (name_only) {\r\nprintf("%s ", syms->symbol);\r\ncontinue;\r\n}\r\nif (strlen(syms->alias))\r\nsnprintf(name, MAX_NAME_LEN, "%s OR %s", syms->symbol, syms->alias);\r\nelse\r\nstrncpy(name, syms->symbol, MAX_NAME_LEN);\r\nprintf(" %-50s [%s]\n", name, event_type_descriptors[type]);\r\nprinted++;\r\n}\r\nif (printed)\r\nprintf("\n");\r\n}\r\nvoid print_events(const char *event_glob, bool name_only)\r\n{\r\nif (!name_only) {\r\nprintf("\n");\r\nprintf("List of pre-defined events (to be used in -e):\n");\r\n}\r\nprint_symbol_events(event_glob, PERF_TYPE_HARDWARE,\r\nevent_symbols_hw, PERF_COUNT_HW_MAX, name_only);\r\nprint_symbol_events(event_glob, PERF_TYPE_SOFTWARE,\r\nevent_symbols_sw, PERF_COUNT_SW_MAX, name_only);\r\nprint_hwcache_events(event_glob, name_only);\r\nprint_pmu_events(event_glob, name_only);\r\nif (event_glob != NULL)\r\nreturn;\r\nif (!name_only) {\r\nprintf(" %-50s [%s]\n",\r\n"rNNN",\r\nevent_type_descriptors[PERF_TYPE_RAW]);\r\nprintf(" %-50s [%s]\n",\r\n"cpu/t1=v1[,t2=v2,t3 ...]/modifier",\r\nevent_type_descriptors[PERF_TYPE_RAW]);\r\nprintf(" (see 'man perf-list' on how to encode it)\n");\r\nprintf("\n");\r\nprintf(" %-50s [%s]\n",\r\n"mem:<addr>[:access]",\r\nevent_type_descriptors[PERF_TYPE_BREAKPOINT]);\r\nprintf("\n");\r\n}\r\nprint_tracepoint_events(NULL, NULL, name_only);\r\n}\r\nint parse_events__is_hardcoded_term(struct parse_events_term *term)\r\n{\r\nreturn term->type_term != PARSE_EVENTS__TERM_TYPE_USER;\r\n}\r\nstatic int new_term(struct parse_events_term **_term, int type_val,\r\nint type_term, char *config,\r\nchar *str, u64 num)\r\n{\r\nstruct parse_events_term *term;\r\nterm = zalloc(sizeof(*term));\r\nif (!term)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&term->list);\r\nterm->type_val = type_val;\r\nterm->type_term = type_term;\r\nterm->config = config;\r\nswitch (type_val) {\r\ncase PARSE_EVENTS__TERM_TYPE_NUM:\r\nterm->val.num = num;\r\nbreak;\r\ncase PARSE_EVENTS__TERM_TYPE_STR:\r\nterm->val.str = str;\r\nbreak;\r\ndefault:\r\nfree(term);\r\nreturn -EINVAL;\r\n}\r\n*_term = term;\r\nreturn 0;\r\n}\r\nint parse_events_term__num(struct parse_events_term **term,\r\nint type_term, char *config, u64 num)\r\n{\r\nreturn new_term(term, PARSE_EVENTS__TERM_TYPE_NUM, type_term,\r\nconfig, NULL, num);\r\n}\r\nint parse_events_term__str(struct parse_events_term **term,\r\nint type_term, char *config, char *str)\r\n{\r\nreturn new_term(term, PARSE_EVENTS__TERM_TYPE_STR, type_term,\r\nconfig, str, 0);\r\n}\r\nint parse_events_term__sym_hw(struct parse_events_term **term,\r\nchar *config, unsigned idx)\r\n{\r\nstruct event_symbol *sym;\r\nBUG_ON(idx >= PERF_COUNT_HW_MAX);\r\nsym = &event_symbols_hw[idx];\r\nif (config)\r\nreturn new_term(term, PARSE_EVENTS__TERM_TYPE_STR,\r\nPARSE_EVENTS__TERM_TYPE_USER, config,\r\n(char *) sym->symbol, 0);\r\nelse\r\nreturn new_term(term, PARSE_EVENTS__TERM_TYPE_STR,\r\nPARSE_EVENTS__TERM_TYPE_USER,\r\n(char *) "event", (char *) sym->symbol, 0);\r\n}\r\nint parse_events_term__clone(struct parse_events_term **new,\r\nstruct parse_events_term *term)\r\n{\r\nreturn new_term(new, term->type_val, term->type_term, term->config,\r\nterm->val.str, term->val.num);\r\n}\r\nvoid parse_events__free_terms(struct list_head *terms)\r\n{\r\nstruct parse_events_term *term, *h;\r\nlist_for_each_entry_safe(term, h, terms, list)\r\nfree(term);\r\n}
