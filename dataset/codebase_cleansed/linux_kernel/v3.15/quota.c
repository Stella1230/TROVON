static int check_quotactl_permission(struct super_block *sb, int type, int cmd,\r\nqid_t id)\r\n{\r\nswitch (cmd) {\r\ncase Q_GETFMT:\r\ncase Q_SYNC:\r\ncase Q_GETINFO:\r\ncase Q_XGETQSTAT:\r\ncase Q_XGETQSTATV:\r\ncase Q_XQUOTASYNC:\r\nbreak;\r\ncase Q_GETQUOTA:\r\ncase Q_XGETQUOTA:\r\nif ((type == USRQUOTA && uid_eq(current_euid(), make_kuid(current_user_ns(), id))) ||\r\n(type == GRPQUOTA && in_egroup_p(make_kgid(current_user_ns(), id))))\r\nbreak;\r\ndefault:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\n}\r\nreturn security_quotactl(cmd, type, id, sb);\r\n}\r\nstatic void quota_sync_one(struct super_block *sb, void *arg)\r\n{\r\nif (sb->s_qcop && sb->s_qcop->quota_sync)\r\nsb->s_qcop->quota_sync(sb, *(int *)arg);\r\n}\r\nstatic int quota_sync_all(int type)\r\n{\r\nint ret;\r\nif (type >= MAXQUOTAS)\r\nreturn -EINVAL;\r\nret = security_quotactl(Q_SYNC, type, 0, NULL);\r\nif (!ret)\r\niterate_supers(quota_sync_one, &type);\r\nreturn ret;\r\n}\r\nstatic int quota_quotaon(struct super_block *sb, int type, int cmd, qid_t id,\r\nstruct path *path)\r\n{\r\nif (!sb->s_qcop->quota_on && !sb->s_qcop->quota_on_meta)\r\nreturn -ENOSYS;\r\nif (sb->s_qcop->quota_on_meta)\r\nreturn sb->s_qcop->quota_on_meta(sb, type, id);\r\nif (IS_ERR(path))\r\nreturn PTR_ERR(path);\r\nreturn sb->s_qcop->quota_on(sb, type, id, path);\r\n}\r\nstatic int quota_getfmt(struct super_block *sb, int type, void __user *addr)\r\n{\r\n__u32 fmt;\r\ndown_read(&sb_dqopt(sb)->dqptr_sem);\r\nif (!sb_has_quota_active(sb, type)) {\r\nup_read(&sb_dqopt(sb)->dqptr_sem);\r\nreturn -ESRCH;\r\n}\r\nfmt = sb_dqopt(sb)->info[type].dqi_format->qf_fmt_id;\r\nup_read(&sb_dqopt(sb)->dqptr_sem);\r\nif (copy_to_user(addr, &fmt, sizeof(fmt)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int quota_getinfo(struct super_block *sb, int type, void __user *addr)\r\n{\r\nstruct if_dqinfo info;\r\nint ret;\r\nif (!sb->s_qcop->get_info)\r\nreturn -ENOSYS;\r\nret = sb->s_qcop->get_info(sb, type, &info);\r\nif (!ret && copy_to_user(addr, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nstatic int quota_setinfo(struct super_block *sb, int type, void __user *addr)\r\n{\r\nstruct if_dqinfo info;\r\nif (copy_from_user(&info, addr, sizeof(info)))\r\nreturn -EFAULT;\r\nif (!sb->s_qcop->set_info)\r\nreturn -ENOSYS;\r\nreturn sb->s_qcop->set_info(sb, type, &info);\r\n}\r\nstatic void copy_to_if_dqblk(struct if_dqblk *dst, struct fs_disk_quota *src)\r\n{\r\nmemset(dst, 0, sizeof(*dst));\r\ndst->dqb_bhardlimit = src->d_blk_hardlimit;\r\ndst->dqb_bsoftlimit = src->d_blk_softlimit;\r\ndst->dqb_curspace = src->d_bcount;\r\ndst->dqb_ihardlimit = src->d_ino_hardlimit;\r\ndst->dqb_isoftlimit = src->d_ino_softlimit;\r\ndst->dqb_curinodes = src->d_icount;\r\ndst->dqb_btime = src->d_btimer;\r\ndst->dqb_itime = src->d_itimer;\r\ndst->dqb_valid = QIF_ALL;\r\n}\r\nstatic int quota_getquota(struct super_block *sb, int type, qid_t id,\r\nvoid __user *addr)\r\n{\r\nstruct kqid qid;\r\nstruct fs_disk_quota fdq;\r\nstruct if_dqblk idq;\r\nint ret;\r\nif (!sb->s_qcop->get_dqblk)\r\nreturn -ENOSYS;\r\nqid = make_kqid(current_user_ns(), type, id);\r\nif (!qid_valid(qid))\r\nreturn -EINVAL;\r\nret = sb->s_qcop->get_dqblk(sb, qid, &fdq);\r\nif (ret)\r\nreturn ret;\r\ncopy_to_if_dqblk(&idq, &fdq);\r\nif (copy_to_user(addr, &idq, sizeof(idq)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void copy_from_if_dqblk(struct fs_disk_quota *dst, struct if_dqblk *src)\r\n{\r\ndst->d_blk_hardlimit = src->dqb_bhardlimit;\r\ndst->d_blk_softlimit = src->dqb_bsoftlimit;\r\ndst->d_bcount = src->dqb_curspace;\r\ndst->d_ino_hardlimit = src->dqb_ihardlimit;\r\ndst->d_ino_softlimit = src->dqb_isoftlimit;\r\ndst->d_icount = src->dqb_curinodes;\r\ndst->d_btimer = src->dqb_btime;\r\ndst->d_itimer = src->dqb_itime;\r\ndst->d_fieldmask = 0;\r\nif (src->dqb_valid & QIF_BLIMITS)\r\ndst->d_fieldmask |= FS_DQ_BSOFT | FS_DQ_BHARD;\r\nif (src->dqb_valid & QIF_SPACE)\r\ndst->d_fieldmask |= FS_DQ_BCOUNT;\r\nif (src->dqb_valid & QIF_ILIMITS)\r\ndst->d_fieldmask |= FS_DQ_ISOFT | FS_DQ_IHARD;\r\nif (src->dqb_valid & QIF_INODES)\r\ndst->d_fieldmask |= FS_DQ_ICOUNT;\r\nif (src->dqb_valid & QIF_BTIME)\r\ndst->d_fieldmask |= FS_DQ_BTIMER;\r\nif (src->dqb_valid & QIF_ITIME)\r\ndst->d_fieldmask |= FS_DQ_ITIMER;\r\n}\r\nstatic int quota_setquota(struct super_block *sb, int type, qid_t id,\r\nvoid __user *addr)\r\n{\r\nstruct fs_disk_quota fdq;\r\nstruct if_dqblk idq;\r\nstruct kqid qid;\r\nif (copy_from_user(&idq, addr, sizeof(idq)))\r\nreturn -EFAULT;\r\nif (!sb->s_qcop->set_dqblk)\r\nreturn -ENOSYS;\r\nqid = make_kqid(current_user_ns(), type, id);\r\nif (!qid_valid(qid))\r\nreturn -EINVAL;\r\ncopy_from_if_dqblk(&fdq, &idq);\r\nreturn sb->s_qcop->set_dqblk(sb, qid, &fdq);\r\n}\r\nstatic int quota_setxstate(struct super_block *sb, int cmd, void __user *addr)\r\n{\r\n__u32 flags;\r\nif (copy_from_user(&flags, addr, sizeof(flags)))\r\nreturn -EFAULT;\r\nif (!sb->s_qcop->set_xstate)\r\nreturn -ENOSYS;\r\nreturn sb->s_qcop->set_xstate(sb, flags, cmd);\r\n}\r\nstatic int quota_getxstate(struct super_block *sb, void __user *addr)\r\n{\r\nstruct fs_quota_stat fqs;\r\nint ret;\r\nif (!sb->s_qcop->get_xstate)\r\nreturn -ENOSYS;\r\nret = sb->s_qcop->get_xstate(sb, &fqs);\r\nif (!ret && copy_to_user(addr, &fqs, sizeof(fqs)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nstatic int quota_getxstatev(struct super_block *sb, void __user *addr)\r\n{\r\nstruct fs_quota_statv fqs;\r\nint ret;\r\nif (!sb->s_qcop->get_xstatev)\r\nreturn -ENOSYS;\r\nmemset(&fqs, 0, sizeof(fqs));\r\nif (copy_from_user(&fqs, addr, 1))\r\nreturn -EFAULT;\r\nswitch (fqs.qs_version) {\r\ncase FS_QSTATV_VERSION1:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = sb->s_qcop->get_xstatev(sb, &fqs);\r\nif (!ret && copy_to_user(addr, &fqs, sizeof(fqs)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nstatic int quota_setxquota(struct super_block *sb, int type, qid_t id,\r\nvoid __user *addr)\r\n{\r\nstruct fs_disk_quota fdq;\r\nstruct kqid qid;\r\nif (copy_from_user(&fdq, addr, sizeof(fdq)))\r\nreturn -EFAULT;\r\nif (!sb->s_qcop->set_dqblk)\r\nreturn -ENOSYS;\r\nqid = make_kqid(current_user_ns(), type, id);\r\nif (!qid_valid(qid))\r\nreturn -EINVAL;\r\nreturn sb->s_qcop->set_dqblk(sb, qid, &fdq);\r\n}\r\nstatic int quota_getxquota(struct super_block *sb, int type, qid_t id,\r\nvoid __user *addr)\r\n{\r\nstruct fs_disk_quota fdq;\r\nstruct kqid qid;\r\nint ret;\r\nif (!sb->s_qcop->get_dqblk)\r\nreturn -ENOSYS;\r\nqid = make_kqid(current_user_ns(), type, id);\r\nif (!qid_valid(qid))\r\nreturn -EINVAL;\r\nret = sb->s_qcop->get_dqblk(sb, qid, &fdq);\r\nif (!ret && copy_to_user(addr, &fdq, sizeof(fdq)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nstatic int do_quotactl(struct super_block *sb, int type, int cmd, qid_t id,\r\nvoid __user *addr, struct path *path)\r\n{\r\nint ret;\r\nif (type >= (XQM_COMMAND(cmd) ? XQM_MAXQUOTAS : MAXQUOTAS))\r\nreturn -EINVAL;\r\nif (!sb->s_qcop)\r\nreturn -ENOSYS;\r\nret = check_quotactl_permission(sb, type, cmd, id);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (cmd) {\r\ncase Q_QUOTAON:\r\nreturn quota_quotaon(sb, type, cmd, id, path);\r\ncase Q_QUOTAOFF:\r\nif (!sb->s_qcop->quota_off)\r\nreturn -ENOSYS;\r\nreturn sb->s_qcop->quota_off(sb, type);\r\ncase Q_GETFMT:\r\nreturn quota_getfmt(sb, type, addr);\r\ncase Q_GETINFO:\r\nreturn quota_getinfo(sb, type, addr);\r\ncase Q_SETINFO:\r\nreturn quota_setinfo(sb, type, addr);\r\ncase Q_GETQUOTA:\r\nreturn quota_getquota(sb, type, id, addr);\r\ncase Q_SETQUOTA:\r\nreturn quota_setquota(sb, type, id, addr);\r\ncase Q_SYNC:\r\nif (!sb->s_qcop->quota_sync)\r\nreturn -ENOSYS;\r\nreturn sb->s_qcop->quota_sync(sb, type);\r\ncase Q_XQUOTAON:\r\ncase Q_XQUOTAOFF:\r\ncase Q_XQUOTARM:\r\nreturn quota_setxstate(sb, cmd, addr);\r\ncase Q_XGETQSTAT:\r\nreturn quota_getxstate(sb, addr);\r\ncase Q_XGETQSTATV:\r\nreturn quota_getxstatev(sb, addr);\r\ncase Q_XSETQLIM:\r\nreturn quota_setxquota(sb, type, id, addr);\r\ncase Q_XGETQUOTA:\r\nreturn quota_getxquota(sb, type, id, addr);\r\ncase Q_XQUOTASYNC:\r\nif (sb->s_flags & MS_RDONLY)\r\nreturn -EROFS;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int quotactl_cmd_write(int cmd)\r\n{\r\nswitch (cmd) {\r\ncase Q_GETFMT:\r\ncase Q_GETINFO:\r\ncase Q_SYNC:\r\ncase Q_XGETQSTAT:\r\ncase Q_XGETQSTATV:\r\ncase Q_XGETQUOTA:\r\ncase Q_XQUOTASYNC:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct super_block *quotactl_block(const char __user *special, int cmd)\r\n{\r\n#ifdef CONFIG_BLOCK\r\nstruct block_device *bdev;\r\nstruct super_block *sb;\r\nstruct filename *tmp = getname(special);\r\nif (IS_ERR(tmp))\r\nreturn ERR_CAST(tmp);\r\nbdev = lookup_bdev(tmp->name);\r\nputname(tmp);\r\nif (IS_ERR(bdev))\r\nreturn ERR_CAST(bdev);\r\nif (quotactl_cmd_write(cmd))\r\nsb = get_super_thawed(bdev);\r\nelse\r\nsb = get_super(bdev);\r\nbdput(bdev);\r\nif (!sb)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn sb;\r\n#else\r\nreturn ERR_PTR(-ENODEV);\r\n#endif\r\n}
