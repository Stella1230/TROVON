static int pix_rdi_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nint i;\r\nint ret = 0;\r\nu32 val;\r\nstruct clk_pix_rdi *rdi = to_clk_pix_rdi(hw);\r\nstruct clk *clk = hw->clk;\r\nint num_parents = __clk_get_num_parents(hw->clk);\r\nfor (i = 0; i < num_parents; i++) {\r\nret = clk_prepare_enable(clk_get_parent_by_index(clk, i));\r\nif (ret)\r\ngoto err;\r\n}\r\nif (index == 2)\r\nval = rdi->s2_mask;\r\nelse\r\nval = 0;\r\nregmap_update_bits(rdi->clkr.regmap, rdi->s2_reg, rdi->s2_mask, val);\r\nudelay(1);\r\nif (index == 1)\r\nval = rdi->s_mask;\r\nelse\r\nval = 0;\r\nregmap_update_bits(rdi->clkr.regmap, rdi->s_reg, rdi->s_mask, val);\r\nudelay(1);\r\nerr:\r\nfor (i--; i >= 0; i--)\r\nclk_disable_unprepare(clk_get_parent_by_index(clk, i));\r\nreturn ret;\r\n}\r\nstatic u8 pix_rdi_get_parent(struct clk_hw *hw)\r\n{\r\nu32 val;\r\nstruct clk_pix_rdi *rdi = to_clk_pix_rdi(hw);\r\nregmap_read(rdi->clkr.regmap, rdi->s2_reg, &val);\r\nif (val & rdi->s2_mask)\r\nreturn 2;\r\nregmap_read(rdi->clkr.regmap, rdi->s_reg, &val);\r\nif (val & rdi->s_mask)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int mmcc_msm8960_probe(struct platform_device *pdev)\r\n{\r\nvoid __iomem *base;\r\nstruct resource *res;\r\nint i, ret;\r\nstruct device *dev = &pdev->dev;\r\nstruct clk *clk;\r\nstruct clk_onecell_data *data;\r\nstruct clk **clks;\r\nstruct regmap *regmap;\r\nsize_t num_clks;\r\nstruct qcom_reset_controller *reset;\r\nstruct qcom_cc *cc;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nregmap = devm_regmap_init_mmio(dev, base, &mmcc_msm8960_regmap_config);\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nnum_clks = ARRAY_SIZE(mmcc_msm8960_clks);\r\ncc = devm_kzalloc(dev, sizeof(*cc) + sizeof(*clks) * num_clks,\r\nGFP_KERNEL);\r\nif (!cc)\r\nreturn -ENOMEM;\r\nclks = cc->clks;\r\ndata = &cc->data;\r\ndata->clks = clks;\r\ndata->clk_num = num_clks;\r\nfor (i = 0; i < num_clks; i++) {\r\nif (!mmcc_msm8960_clks[i])\r\ncontinue;\r\nclk = devm_clk_register_regmap(dev, mmcc_msm8960_clks[i]);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nclks[i] = clk;\r\n}\r\nret = of_clk_add_provider(dev->of_node, of_clk_src_onecell_get, data);\r\nif (ret)\r\nreturn ret;\r\nreset = &cc->reset;\r\nreset->rcdev.of_node = dev->of_node;\r\nreset->rcdev.ops = &qcom_reset_ops,\r\nreset->rcdev.owner = THIS_MODULE,\r\nreset->rcdev.nr_resets = ARRAY_SIZE(mmcc_msm8960_resets),\r\nreset->regmap = regmap;\r\nreset->reset_map = mmcc_msm8960_resets,\r\nplatform_set_drvdata(pdev, &reset->rcdev);\r\nret = reset_controller_register(&reset->rcdev);\r\nif (ret)\r\nof_clk_del_provider(dev->of_node);\r\nreturn ret;\r\n}\r\nstatic int mmcc_msm8960_remove(struct platform_device *pdev)\r\n{\r\nof_clk_del_provider(pdev->dev.of_node);\r\nreset_controller_unregister(platform_get_drvdata(pdev));\r\nreturn 0;\r\n}
