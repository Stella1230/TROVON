static inline MFT_RECORD *map_mft_record_page(ntfs_inode *ni)\r\n{\r\nloff_t i_size;\r\nntfs_volume *vol = ni->vol;\r\nstruct inode *mft_vi = vol->mft_ino;\r\nstruct page *page;\r\nunsigned long index, end_index;\r\nunsigned ofs;\r\nBUG_ON(ni->page);\r\nindex = (u64)ni->mft_no << vol->mft_record_size_bits >>\r\nPAGE_CACHE_SHIFT;\r\nofs = (ni->mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\r\ni_size = i_size_read(mft_vi);\r\nend_index = i_size >> PAGE_CACHE_SHIFT;\r\nif (unlikely(index >= end_index)) {\r\nif (index > end_index || (i_size & ~PAGE_CACHE_MASK) < ofs +\r\nvol->mft_record_size) {\r\npage = ERR_PTR(-ENOENT);\r\nntfs_error(vol->sb, "Attempt to read mft record 0x%lx, "\r\n"which is beyond the end of the mft. "\r\n"This is probably a bug in the ntfs "\r\n"driver.", ni->mft_no);\r\ngoto err_out;\r\n}\r\n}\r\npage = ntfs_map_page(mft_vi->i_mapping, index);\r\nif (likely(!IS_ERR(page))) {\r\nif (likely(ntfs_is_mft_recordp((le32*)(page_address(page) +\r\nofs)))) {\r\nni->page = page;\r\nni->page_ofs = ofs;\r\nreturn page_address(page) + ofs;\r\n}\r\nntfs_error(vol->sb, "Mft record 0x%lx is corrupt. "\r\n"Run chkdsk.", ni->mft_no);\r\nntfs_unmap_page(page);\r\npage = ERR_PTR(-EIO);\r\nNVolSetErrors(vol);\r\n}\r\nerr_out:\r\nni->page = NULL;\r\nni->page_ofs = 0;\r\nreturn (void*)page;\r\n}\r\nMFT_RECORD *map_mft_record(ntfs_inode *ni)\r\n{\r\nMFT_RECORD *m;\r\nntfs_debug("Entering for mft_no 0x%lx.", ni->mft_no);\r\natomic_inc(&ni->count);\r\nmutex_lock(&ni->mrec_lock);\r\nm = map_mft_record_page(ni);\r\nif (likely(!IS_ERR(m)))\r\nreturn m;\r\nmutex_unlock(&ni->mrec_lock);\r\natomic_dec(&ni->count);\r\nntfs_error(ni->vol->sb, "Failed with error code %lu.", -PTR_ERR(m));\r\nreturn m;\r\n}\r\nstatic inline void unmap_mft_record_page(ntfs_inode *ni)\r\n{\r\nBUG_ON(!ni->page);\r\nntfs_unmap_page(ni->page);\r\nni->page = NULL;\r\nni->page_ofs = 0;\r\nreturn;\r\n}\r\nvoid unmap_mft_record(ntfs_inode *ni)\r\n{\r\nstruct page *page = ni->page;\r\nBUG_ON(!page);\r\nntfs_debug("Entering for mft_no 0x%lx.", ni->mft_no);\r\nunmap_mft_record_page(ni);\r\nmutex_unlock(&ni->mrec_lock);\r\natomic_dec(&ni->count);\r\nreturn;\r\n}\r\nMFT_RECORD *map_extent_mft_record(ntfs_inode *base_ni, MFT_REF mref,\r\nntfs_inode **ntfs_ino)\r\n{\r\nMFT_RECORD *m;\r\nntfs_inode *ni = NULL;\r\nntfs_inode **extent_nis = NULL;\r\nint i;\r\nunsigned long mft_no = MREF(mref);\r\nu16 seq_no = MSEQNO(mref);\r\nbool destroy_ni = false;\r\nntfs_debug("Mapping extent mft record 0x%lx (base mft record 0x%lx).",\r\nmft_no, base_ni->mft_no);\r\natomic_inc(&base_ni->count);\r\nmutex_lock(&base_ni->extent_lock);\r\nif (base_ni->nr_extents > 0) {\r\nextent_nis = base_ni->ext.extent_ntfs_inos;\r\nfor (i = 0; i < base_ni->nr_extents; i++) {\r\nif (mft_no != extent_nis[i]->mft_no)\r\ncontinue;\r\nni = extent_nis[i];\r\natomic_inc(&ni->count);\r\nbreak;\r\n}\r\n}\r\nif (likely(ni != NULL)) {\r\nmutex_unlock(&base_ni->extent_lock);\r\natomic_dec(&base_ni->count);\r\nm = map_mft_record(ni);\r\natomic_dec(&ni->count);\r\nif (likely(!IS_ERR(m))) {\r\nif (likely(le16_to_cpu(m->sequence_number) == seq_no)) {\r\nntfs_debug("Done 1.");\r\n*ntfs_ino = ni;\r\nreturn m;\r\n}\r\nunmap_mft_record(ni);\r\nntfs_error(base_ni->vol->sb, "Found stale extent mft "\r\n"reference! Corrupt filesystem. "\r\n"Run chkdsk.");\r\nreturn ERR_PTR(-EIO);\r\n}\r\nmap_err_out:\r\nntfs_error(base_ni->vol->sb, "Failed to map extent "\r\n"mft record, error code %ld.", -PTR_ERR(m));\r\nreturn m;\r\n}\r\nni = ntfs_new_extent_inode(base_ni->vol->sb, mft_no);\r\nif (unlikely(!ni)) {\r\nmutex_unlock(&base_ni->extent_lock);\r\natomic_dec(&base_ni->count);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nni->vol = base_ni->vol;\r\nni->seq_no = seq_no;\r\nni->nr_extents = -1;\r\nni->ext.base_ntfs_ino = base_ni;\r\nm = map_mft_record(ni);\r\nif (IS_ERR(m)) {\r\nmutex_unlock(&base_ni->extent_lock);\r\natomic_dec(&base_ni->count);\r\nntfs_clear_extent_inode(ni);\r\ngoto map_err_out;\r\n}\r\nif (seq_no && (le16_to_cpu(m->sequence_number) != seq_no)) {\r\nntfs_error(base_ni->vol->sb, "Found stale extent mft "\r\n"reference! Corrupt filesystem. Run chkdsk.");\r\ndestroy_ni = true;\r\nm = ERR_PTR(-EIO);\r\ngoto unm_err_out;\r\n}\r\nif (!(base_ni->nr_extents & 3)) {\r\nntfs_inode **tmp;\r\nint new_size = (base_ni->nr_extents + 4) * sizeof(ntfs_inode *);\r\ntmp = kmalloc(new_size, GFP_NOFS);\r\nif (unlikely(!tmp)) {\r\nntfs_error(base_ni->vol->sb, "Failed to allocate "\r\n"internal buffer.");\r\ndestroy_ni = true;\r\nm = ERR_PTR(-ENOMEM);\r\ngoto unm_err_out;\r\n}\r\nif (base_ni->nr_extents) {\r\nBUG_ON(!base_ni->ext.extent_ntfs_inos);\r\nmemcpy(tmp, base_ni->ext.extent_ntfs_inos, new_size -\r\n4 * sizeof(ntfs_inode *));\r\nkfree(base_ni->ext.extent_ntfs_inos);\r\n}\r\nbase_ni->ext.extent_ntfs_inos = tmp;\r\n}\r\nbase_ni->ext.extent_ntfs_inos[base_ni->nr_extents++] = ni;\r\nmutex_unlock(&base_ni->extent_lock);\r\natomic_dec(&base_ni->count);\r\nntfs_debug("Done 2.");\r\n*ntfs_ino = ni;\r\nreturn m;\r\nunm_err_out:\r\nunmap_mft_record(ni);\r\nmutex_unlock(&base_ni->extent_lock);\r\natomic_dec(&base_ni->count);\r\nif (destroy_ni)\r\nntfs_clear_extent_inode(ni);\r\nreturn m;\r\n}\r\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\r\n{\r\nntfs_inode *base_ni;\r\nntfs_debug("Entering for inode 0x%lx.", ni->mft_no);\r\nBUG_ON(NInoAttr(ni));\r\nmark_ntfs_record_dirty(ni->page, ni->page_ofs);\r\nmutex_lock(&ni->extent_lock);\r\nif (likely(ni->nr_extents >= 0))\r\nbase_ni = ni;\r\nelse\r\nbase_ni = ni->ext.base_ntfs_ino;\r\nmutex_unlock(&ni->extent_lock);\r\n__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\r\n}\r\nstatic int ntfs_sync_mft_mirror_umount(ntfs_volume *vol,\r\nconst unsigned long mft_no, MFT_RECORD *m)\r\n{\r\nBUG_ON(vol->mftmirr_ino);\r\nntfs_error(vol->sb, "Umount time mft mirror syncing is not "\r\n"implemented yet. %s", ntfs_please_email);\r\nreturn -EOPNOTSUPP;\r\n}\r\nint ntfs_sync_mft_mirror(ntfs_volume *vol, const unsigned long mft_no,\r\nMFT_RECORD *m, int sync)\r\n{\r\nstruct page *page;\r\nunsigned int blocksize = vol->sb->s_blocksize;\r\nint max_bhs = vol->mft_record_size / blocksize;\r\nstruct buffer_head *bhs[max_bhs];\r\nstruct buffer_head *bh, *head;\r\nu8 *kmirr;\r\nrunlist_element *rl;\r\nunsigned int block_start, block_end, m_start, m_end, page_ofs;\r\nint i_bhs, nr_bhs, err = 0;\r\nunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\r\nntfs_debug("Entering for inode 0x%lx.", mft_no);\r\nBUG_ON(!max_bhs);\r\nif (unlikely(!vol->mftmirr_ino)) {\r\nerr = ntfs_sync_mft_mirror_umount(vol, mft_no, m);\r\nif (likely(!err))\r\nreturn err;\r\ngoto err_out;\r\n}\r\npage = ntfs_map_page(vol->mftmirr_ino->i_mapping, mft_no >>\r\n(PAGE_CACHE_SHIFT - vol->mft_record_size_bits));\r\nif (IS_ERR(page)) {\r\nntfs_error(vol->sb, "Failed to map mft mirror page.");\r\nerr = PTR_ERR(page);\r\ngoto err_out;\r\n}\r\nlock_page(page);\r\nBUG_ON(!PageUptodate(page));\r\nClearPageUptodate(page);\r\npage_ofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\r\nkmirr = page_address(page) + page_ofs;\r\nmemcpy(kmirr, m, vol->mft_record_size);\r\nif (unlikely(!page_has_buffers(page))) {\r\nstruct buffer_head *tail;\r\nbh = head = alloc_page_buffers(page, blocksize, 1);\r\ndo {\r\nset_buffer_uptodate(bh);\r\ntail = bh;\r\nbh = bh->b_this_page;\r\n} while (bh);\r\ntail->b_this_page = head;\r\nattach_page_buffers(page, head);\r\n}\r\nbh = head = page_buffers(page);\r\nBUG_ON(!bh);\r\nrl = NULL;\r\nnr_bhs = 0;\r\nblock_start = 0;\r\nm_start = kmirr - (u8*)page_address(page);\r\nm_end = m_start + vol->mft_record_size;\r\ndo {\r\nblock_end = block_start + blocksize;\r\nif (block_end <= m_start)\r\ncontinue;\r\nif (unlikely(block_start >= m_end))\r\nbreak;\r\nif (unlikely(!buffer_mapped(bh))) {\r\nVCN vcn;\r\nLCN lcn;\r\nunsigned int vcn_ofs;\r\nbh->b_bdev = vol->sb->s_bdev;\r\nvcn = ((VCN)mft_no << vol->mft_record_size_bits) +\r\n(block_start - m_start);\r\nvcn_ofs = vcn & vol->cluster_size_mask;\r\nvcn >>= vol->cluster_size_bits;\r\nif (!rl) {\r\ndown_read(&NTFS_I(vol->mftmirr_ino)->\r\nrunlist.lock);\r\nrl = NTFS_I(vol->mftmirr_ino)->runlist.rl;\r\nBUG_ON(!rl);\r\n}\r\nwhile (rl->length && rl[1].vcn <= vcn)\r\nrl++;\r\nlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\r\nif (likely(lcn >= 0)) {\r\nbh->b_blocknr = ((lcn <<\r\nvol->cluster_size_bits) +\r\nvcn_ofs) >> blocksize_bits;\r\nset_buffer_mapped(bh);\r\n} else {\r\nbh->b_blocknr = -1;\r\nntfs_error(vol->sb, "Cannot write mft mirror "\r\n"record 0x%lx because its "\r\n"location on disk could not "\r\n"be determined (error code "\r\n"%lli).", mft_no,\r\n(long long)lcn);\r\nerr = -EIO;\r\n}\r\n}\r\nBUG_ON(!buffer_uptodate(bh));\r\nBUG_ON(!nr_bhs && (m_start != block_start));\r\nBUG_ON(nr_bhs >= max_bhs);\r\nbhs[nr_bhs++] = bh;\r\nBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\r\n} while (block_start = block_end, (bh = bh->b_this_page) != head);\r\nif (unlikely(rl))\r\nup_read(&NTFS_I(vol->mftmirr_ino)->runlist.lock);\r\nif (likely(!err)) {\r\nfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\r\nstruct buffer_head *tbh = bhs[i_bhs];\r\nif (!trylock_buffer(tbh))\r\nBUG();\r\nBUG_ON(!buffer_uptodate(tbh));\r\nclear_buffer_dirty(tbh);\r\nget_bh(tbh);\r\ntbh->b_end_io = end_buffer_write_sync;\r\nsubmit_bh(WRITE, tbh);\r\n}\r\nfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\r\nstruct buffer_head *tbh = bhs[i_bhs];\r\nwait_on_buffer(tbh);\r\nif (unlikely(!buffer_uptodate(tbh))) {\r\nerr = -EIO;\r\nset_buffer_uptodate(tbh);\r\n}\r\n}\r\n} else {\r\nfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\r\nclear_buffer_dirty(bhs[i_bhs]);\r\n}\r\npost_write_mst_fixup((NTFS_RECORD*)kmirr);\r\nflush_dcache_page(page);\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\nntfs_unmap_page(page);\r\nif (likely(!err)) {\r\nntfs_debug("Done.");\r\n} else {\r\nntfs_error(vol->sb, "I/O error while writing mft mirror "\r\n"record 0x%lx!", mft_no);\r\nerr_out:\r\nntfs_error(vol->sb, "Failed to synchronize $MFTMirr (error "\r\n"code %i). Volume will be left marked dirty "\r\n"on umount. Run ntfsfix on the partition "\r\n"after umounting to correct this.", -err);\r\nNVolSetErrors(vol);\r\n}\r\nreturn err;\r\n}\r\nint write_mft_record_nolock(ntfs_inode *ni, MFT_RECORD *m, int sync)\r\n{\r\nntfs_volume *vol = ni->vol;\r\nstruct page *page = ni->page;\r\nunsigned int blocksize = vol->sb->s_blocksize;\r\nunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\r\nint max_bhs = vol->mft_record_size / blocksize;\r\nstruct buffer_head *bhs[max_bhs];\r\nstruct buffer_head *bh, *head;\r\nrunlist_element *rl;\r\nunsigned int block_start, block_end, m_start, m_end;\r\nint i_bhs, nr_bhs, err = 0;\r\nntfs_debug("Entering for inode 0x%lx.", ni->mft_no);\r\nBUG_ON(NInoAttr(ni));\r\nBUG_ON(!max_bhs);\r\nBUG_ON(!PageLocked(page));\r\nif (!NInoTestClearDirty(ni))\r\ngoto done;\r\nbh = head = page_buffers(page);\r\nBUG_ON(!bh);\r\nrl = NULL;\r\nnr_bhs = 0;\r\nblock_start = 0;\r\nm_start = ni->page_ofs;\r\nm_end = m_start + vol->mft_record_size;\r\ndo {\r\nblock_end = block_start + blocksize;\r\nif (block_end <= m_start)\r\ncontinue;\r\nif (unlikely(block_start >= m_end))\r\nbreak;\r\nif (block_start == m_start) {\r\nif (!buffer_dirty(bh)) {\r\nBUG_ON(nr_bhs);\r\nbreak;\r\n}\r\n}\r\nif (unlikely(!buffer_mapped(bh))) {\r\nVCN vcn;\r\nLCN lcn;\r\nunsigned int vcn_ofs;\r\nbh->b_bdev = vol->sb->s_bdev;\r\nvcn = ((VCN)ni->mft_no << vol->mft_record_size_bits) +\r\n(block_start - m_start);\r\nvcn_ofs = vcn & vol->cluster_size_mask;\r\nvcn >>= vol->cluster_size_bits;\r\nif (!rl) {\r\ndown_read(&NTFS_I(vol->mft_ino)->runlist.lock);\r\nrl = NTFS_I(vol->mft_ino)->runlist.rl;\r\nBUG_ON(!rl);\r\n}\r\nwhile (rl->length && rl[1].vcn <= vcn)\r\nrl++;\r\nlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\r\nif (likely(lcn >= 0)) {\r\nbh->b_blocknr = ((lcn <<\r\nvol->cluster_size_bits) +\r\nvcn_ofs) >> blocksize_bits;\r\nset_buffer_mapped(bh);\r\n} else {\r\nbh->b_blocknr = -1;\r\nntfs_error(vol->sb, "Cannot write mft record "\r\n"0x%lx because its location "\r\n"on disk could not be "\r\n"determined (error code %lli).",\r\nni->mft_no, (long long)lcn);\r\nerr = -EIO;\r\n}\r\n}\r\nBUG_ON(!buffer_uptodate(bh));\r\nBUG_ON(!nr_bhs && (m_start != block_start));\r\nBUG_ON(nr_bhs >= max_bhs);\r\nbhs[nr_bhs++] = bh;\r\nBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\r\n} while (block_start = block_end, (bh = bh->b_this_page) != head);\r\nif (unlikely(rl))\r\nup_read(&NTFS_I(vol->mft_ino)->runlist.lock);\r\nif (!nr_bhs)\r\ngoto done;\r\nif (unlikely(err))\r\ngoto cleanup_out;\r\nerr = pre_write_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size);\r\nif (err) {\r\nntfs_error(vol->sb, "Failed to apply mst fixups!");\r\ngoto cleanup_out;\r\n}\r\nflush_dcache_mft_record_page(ni);\r\nfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\r\nstruct buffer_head *tbh = bhs[i_bhs];\r\nif (!trylock_buffer(tbh))\r\nBUG();\r\nBUG_ON(!buffer_uptodate(tbh));\r\nclear_buffer_dirty(tbh);\r\nget_bh(tbh);\r\ntbh->b_end_io = end_buffer_write_sync;\r\nsubmit_bh(WRITE, tbh);\r\n}\r\nif (!sync && ni->mft_no < vol->mftmirr_size)\r\nntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\r\nfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\r\nstruct buffer_head *tbh = bhs[i_bhs];\r\nwait_on_buffer(tbh);\r\nif (unlikely(!buffer_uptodate(tbh))) {\r\nerr = -EIO;\r\nif (PageUptodate(page))\r\nset_buffer_uptodate(tbh);\r\n}\r\n}\r\nif (sync && ni->mft_no < vol->mftmirr_size)\r\nntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\r\npost_write_mst_fixup((NTFS_RECORD*)m);\r\nflush_dcache_mft_record_page(ni);\r\nif (unlikely(err)) {\r\nntfs_error(vol->sb, "I/O error while writing mft record "\r\n"0x%lx! Marking base inode as bad. You "\r\n"should unmount the volume and run chkdsk.",\r\nni->mft_no);\r\ngoto err_out;\r\n}\r\ndone:\r\nntfs_debug("Done.");\r\nreturn 0;\r\ncleanup_out:\r\nfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\r\nclear_buffer_dirty(bhs[i_bhs]);\r\nerr_out:\r\nif (err == -ENOMEM) {\r\nntfs_error(vol->sb, "Not enough memory to write mft record. "\r\n"Redirtying so the write is retried later.");\r\nmark_mft_record_dirty(ni);\r\nerr = 0;\r\n} else\r\nNVolSetErrors(vol);\r\nreturn err;\r\n}\r\nbool ntfs_may_write_mft_record(ntfs_volume *vol, const unsigned long mft_no,\r\nconst MFT_RECORD *m, ntfs_inode **locked_ni)\r\n{\r\nstruct super_block *sb = vol->sb;\r\nstruct inode *mft_vi = vol->mft_ino;\r\nstruct inode *vi;\r\nntfs_inode *ni, *eni, **extent_nis;\r\nint i;\r\nntfs_attr na;\r\nntfs_debug("Entering for inode 0x%lx.", mft_no);\r\nBUG_ON(!locked_ni);\r\n*locked_ni = NULL;\r\nntfs_debug("Looking for inode 0x%lx in icache.", mft_no);\r\nna.mft_no = mft_no;\r\nna.name = NULL;\r\nna.name_len = 0;\r\nna.type = AT_UNUSED;\r\nif (!mft_no) {\r\nvi = igrab(mft_vi);\r\nBUG_ON(vi != mft_vi);\r\n} else {\r\nvi = ilookup5_nowait(sb, mft_no, (test_t)ntfs_test_inode, &na);\r\n}\r\nif (vi) {\r\nntfs_debug("Base inode 0x%lx is in icache.", mft_no);\r\nni = NTFS_I(vi);\r\natomic_inc(&ni->count);\r\nif (NInoDirty(ni)) {\r\nntfs_debug("Inode 0x%lx is dirty, do not write it.",\r\nmft_no);\r\natomic_dec(&ni->count);\r\niput(vi);\r\nreturn false;\r\n}\r\nntfs_debug("Inode 0x%lx is not dirty.", mft_no);\r\nif (unlikely(!mutex_trylock(&ni->mrec_lock))) {\r\nntfs_debug("Mft record 0x%lx is already locked, do "\r\n"not write it.", mft_no);\r\natomic_dec(&ni->count);\r\niput(vi);\r\nreturn false;\r\n}\r\nntfs_debug("Managed to lock mft record 0x%lx, write it.",\r\nmft_no);\r\n*locked_ni = ni;\r\nreturn true;\r\n}\r\nntfs_debug("Inode 0x%lx is not in icache.", mft_no);\r\nif (!ntfs_is_mft_record(m->magic)) {\r\nntfs_debug("Mft record 0x%lx is not a FILE record, write it.",\r\nmft_no);\r\nreturn true;\r\n}\r\nif (!m->base_mft_record) {\r\nntfs_debug("Mft record 0x%lx is a base record, write it.",\r\nmft_no);\r\nreturn true;\r\n}\r\nna.mft_no = MREF_LE(m->base_mft_record);\r\nntfs_debug("Mft record 0x%lx is an extent record. Looking for base "\r\n"inode 0x%lx in icache.", mft_no, na.mft_no);\r\nif (!na.mft_no) {\r\nvi = igrab(mft_vi);\r\nBUG_ON(vi != mft_vi);\r\n} else\r\nvi = ilookup5_nowait(sb, na.mft_no, (test_t)ntfs_test_inode,\r\n&na);\r\nif (!vi) {\r\nntfs_debug("Base inode 0x%lx is not in icache, write the "\r\n"extent record.", na.mft_no);\r\nreturn true;\r\n}\r\nntfs_debug("Base inode 0x%lx is in icache.", na.mft_no);\r\nni = NTFS_I(vi);\r\nmutex_lock(&ni->extent_lock);\r\nif (ni->nr_extents <= 0) {\r\nmutex_unlock(&ni->extent_lock);\r\niput(vi);\r\nntfs_debug("Base inode 0x%lx has no attached extent inodes, "\r\n"write the extent record.", na.mft_no);\r\nreturn true;\r\n}\r\nextent_nis = ni->ext.extent_ntfs_inos;\r\nfor (eni = NULL, i = 0; i < ni->nr_extents; ++i) {\r\nif (mft_no == extent_nis[i]->mft_no) {\r\neni = extent_nis[i];\r\nbreak;\r\n}\r\n}\r\nif (!eni) {\r\nmutex_unlock(&ni->extent_lock);\r\niput(vi);\r\nntfs_debug("Extent inode 0x%lx is not attached to its base "\r\n"inode 0x%lx, write the extent record.",\r\nmft_no, na.mft_no);\r\nreturn true;\r\n}\r\nntfs_debug("Extent inode 0x%lx is attached to its base inode 0x%lx.",\r\nmft_no, na.mft_no);\r\natomic_inc(&eni->count);\r\nmutex_unlock(&ni->extent_lock);\r\nif (unlikely(!mutex_trylock(&eni->mrec_lock))) {\r\natomic_dec(&eni->count);\r\niput(vi);\r\nntfs_debug("Extent mft record 0x%lx is already locked, do "\r\n"not write it.", mft_no);\r\nreturn false;\r\n}\r\nntfs_debug("Managed to lock extent mft record 0x%lx, write it.",\r\nmft_no);\r\nif (NInoTestClearDirty(eni))\r\nntfs_debug("Extent inode 0x%lx is dirty, marking it clean.",\r\nmft_no);\r\n*locked_ni = eni;\r\nreturn true;\r\n}\r\nstatic int ntfs_mft_bitmap_find_and_alloc_free_rec_nolock(ntfs_volume *vol,\r\nntfs_inode *base_ni)\r\n{\r\ns64 pass_end, ll, data_pos, pass_start, ofs, bit;\r\nunsigned long flags;\r\nstruct address_space *mftbmp_mapping;\r\nu8 *buf, *byte;\r\nstruct page *page;\r\nunsigned int page_ofs, size;\r\nu8 pass, b;\r\nntfs_debug("Searching for free mft record in the currently "\r\n"initialized mft bitmap.");\r\nmftbmp_mapping = vol->mftbmp_ino->i_mapping;\r\nread_lock_irqsave(&NTFS_I(vol->mft_ino)->size_lock, flags);\r\npass_end = NTFS_I(vol->mft_ino)->allocated_size >>\r\nvol->mft_record_size_bits;\r\nread_unlock_irqrestore(&NTFS_I(vol->mft_ino)->size_lock, flags);\r\nread_lock_irqsave(&NTFS_I(vol->mftbmp_ino)->size_lock, flags);\r\nll = NTFS_I(vol->mftbmp_ino)->initialized_size << 3;\r\nread_unlock_irqrestore(&NTFS_I(vol->mftbmp_ino)->size_lock, flags);\r\nif (pass_end > ll)\r\npass_end = ll;\r\npass = 1;\r\nif (!base_ni)\r\ndata_pos = vol->mft_data_pos;\r\nelse\r\ndata_pos = base_ni->mft_no + 1;\r\nif (data_pos < 24)\r\ndata_pos = 24;\r\nif (data_pos >= pass_end) {\r\ndata_pos = 24;\r\npass = 2;\r\nif (data_pos >= pass_end)\r\nreturn -ENOSPC;\r\n}\r\npass_start = data_pos;\r\nntfs_debug("Starting bitmap search: pass %u, pass_start 0x%llx, "\r\n"pass_end 0x%llx, data_pos 0x%llx.", pass,\r\n(long long)pass_start, (long long)pass_end,\r\n(long long)data_pos);\r\nfor (; pass <= 2;) {\r\nofs = data_pos >> 3;\r\npage_ofs = ofs & ~PAGE_CACHE_MASK;\r\nsize = PAGE_CACHE_SIZE - page_ofs;\r\nll = ((pass_end + 7) >> 3) - ofs;\r\nif (size > ll)\r\nsize = ll;\r\nsize <<= 3;\r\nif (size) {\r\npage = ntfs_map_page(mftbmp_mapping,\r\nofs >> PAGE_CACHE_SHIFT);\r\nif (IS_ERR(page)) {\r\nntfs_error(vol->sb, "Failed to read mft "\r\n"bitmap, aborting.");\r\nreturn PTR_ERR(page);\r\n}\r\nbuf = (u8*)page_address(page) + page_ofs;\r\nbit = data_pos & 7;\r\ndata_pos &= ~7ull;\r\nntfs_debug("Before inner for loop: size 0x%x, "\r\n"data_pos 0x%llx, bit 0x%llx", size,\r\n(long long)data_pos, (long long)bit);\r\nfor (; bit < size && data_pos + bit < pass_end;\r\nbit &= ~7ull, bit += 8) {\r\nbyte = buf + (bit >> 3);\r\nif (*byte == 0xff)\r\ncontinue;\r\nb = ffz((unsigned long)*byte);\r\nif (b < 8 && b >= (bit & 7)) {\r\nll = data_pos + (bit & ~7ull) + b;\r\nif (unlikely(ll > (1ll << 32))) {\r\nntfs_unmap_page(page);\r\nreturn -ENOSPC;\r\n}\r\n*byte |= 1 << b;\r\nflush_dcache_page(page);\r\nset_page_dirty(page);\r\nntfs_unmap_page(page);\r\nntfs_debug("Done. (Found and "\r\n"allocated mft record "\r\n"0x%llx.)",\r\n(long long)ll);\r\nreturn ll;\r\n}\r\n}\r\nntfs_debug("After inner for loop: size 0x%x, "\r\n"data_pos 0x%llx, bit 0x%llx", size,\r\n(long long)data_pos, (long long)bit);\r\ndata_pos += size;\r\nntfs_unmap_page(page);\r\nif (data_pos < pass_end)\r\ncontinue;\r\n}\r\nif (++pass == 2) {\r\npass_end = pass_start;\r\ndata_pos = pass_start = 24;\r\nntfs_debug("pass %i, pass_start 0x%llx, pass_end "\r\n"0x%llx.", pass, (long long)pass_start,\r\n(long long)pass_end);\r\nif (data_pos >= pass_end)\r\nbreak;\r\n}\r\n}\r\nntfs_debug("Done. (No free mft records left in currently initialized "\r\n"mft bitmap.)");\r\nreturn -ENOSPC;\r\n}\r\nstatic int ntfs_mft_bitmap_extend_allocation_nolock(ntfs_volume *vol)\r\n{\r\nLCN lcn;\r\ns64 ll;\r\nunsigned long flags;\r\nstruct page *page;\r\nntfs_inode *mft_ni, *mftbmp_ni;\r\nrunlist_element *rl, *rl2 = NULL;\r\nntfs_attr_search_ctx *ctx = NULL;\r\nMFT_RECORD *mrec;\r\nATTR_RECORD *a = NULL;\r\nint ret, mp_size;\r\nu32 old_alen = 0;\r\nu8 *b, tb;\r\nstruct {\r\nu8 added_cluster:1;\r\nu8 added_run:1;\r\nu8 mp_rebuilt:1;\r\n} status = { 0, 0, 0 };\r\nntfs_debug("Extending mft bitmap allocation.");\r\nmft_ni = NTFS_I(vol->mft_ino);\r\nmftbmp_ni = NTFS_I(vol->mftbmp_ino);\r\ndown_write(&mftbmp_ni->runlist.lock);\r\nread_lock_irqsave(&mftbmp_ni->size_lock, flags);\r\nll = mftbmp_ni->allocated_size;\r\nread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\r\nrl = ntfs_attr_find_vcn_nolock(mftbmp_ni,\r\n(ll - 1) >> vol->cluster_size_bits, NULL);\r\nif (unlikely(IS_ERR(rl) || !rl->length || rl->lcn < 0)) {\r\nup_write(&mftbmp_ni->runlist.lock);\r\nntfs_error(vol->sb, "Failed to determine last allocated "\r\n"cluster of mft bitmap attribute.");\r\nif (!IS_ERR(rl))\r\nret = -EIO;\r\nelse\r\nret = PTR_ERR(rl);\r\nreturn ret;\r\n}\r\nlcn = rl->lcn + rl->length;\r\nntfs_debug("Last lcn of mft bitmap attribute is 0x%llx.",\r\n(long long)lcn);\r\nll = lcn >> 3;\r\npage = ntfs_map_page(vol->lcnbmp_ino->i_mapping,\r\nll >> PAGE_CACHE_SHIFT);\r\nif (IS_ERR(page)) {\r\nup_write(&mftbmp_ni->runlist.lock);\r\nntfs_error(vol->sb, "Failed to read from lcn bitmap.");\r\nreturn PTR_ERR(page);\r\n}\r\nb = (u8*)page_address(page) + (ll & ~PAGE_CACHE_MASK);\r\ntb = 1 << (lcn & 7ull);\r\ndown_write(&vol->lcnbmp_lock);\r\nif (*b != 0xff && !(*b & tb)) {\r\n*b |= tb;\r\nflush_dcache_page(page);\r\nset_page_dirty(page);\r\nup_write(&vol->lcnbmp_lock);\r\nntfs_unmap_page(page);\r\nrl->length++;\r\nrl[1].vcn++;\r\nstatus.added_cluster = 1;\r\nntfs_debug("Appending one cluster to mft bitmap.");\r\n} else {\r\nup_write(&vol->lcnbmp_lock);\r\nntfs_unmap_page(page);\r\nrl2 = ntfs_cluster_alloc(vol, rl[1].vcn, 1, lcn, DATA_ZONE,\r\ntrue);\r\nif (IS_ERR(rl2)) {\r\nup_write(&mftbmp_ni->runlist.lock);\r\nntfs_error(vol->sb, "Failed to allocate a cluster for "\r\n"the mft bitmap.");\r\nreturn PTR_ERR(rl2);\r\n}\r\nrl = ntfs_runlists_merge(mftbmp_ni->runlist.rl, rl2);\r\nif (IS_ERR(rl)) {\r\nup_write(&mftbmp_ni->runlist.lock);\r\nntfs_error(vol->sb, "Failed to merge runlists for mft "\r\n"bitmap.");\r\nif (ntfs_cluster_free_from_rl(vol, rl2)) {\r\nntfs_error(vol->sb, "Failed to deallocate "\r\n"allocated cluster.%s", es);\r\nNVolSetErrors(vol);\r\n}\r\nntfs_free(rl2);\r\nreturn PTR_ERR(rl);\r\n}\r\nmftbmp_ni->runlist.rl = rl;\r\nstatus.added_run = 1;\r\nntfs_debug("Adding one run to mft bitmap.");\r\nfor (; rl[1].length; rl++)\r\n;\r\n}\r\nmrec = map_mft_record(mft_ni);\r\nif (IS_ERR(mrec)) {\r\nntfs_error(vol->sb, "Failed to map mft record.");\r\nret = PTR_ERR(mrec);\r\ngoto undo_alloc;\r\n}\r\nctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\r\nif (unlikely(!ctx)) {\r\nntfs_error(vol->sb, "Failed to get search context.");\r\nret = -ENOMEM;\r\ngoto undo_alloc;\r\n}\r\nret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\r\nmftbmp_ni->name_len, CASE_SENSITIVE, rl[1].vcn, NULL,\r\n0, ctx);\r\nif (unlikely(ret)) {\r\nntfs_error(vol->sb, "Failed to find last attribute extent of "\r\n"mft bitmap attribute.");\r\nif (ret == -ENOENT)\r\nret = -EIO;\r\ngoto undo_alloc;\r\n}\r\na = ctx->attr;\r\nll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\r\nfor (rl2 = rl; rl2 > mftbmp_ni->runlist.rl; rl2--) {\r\nif (ll >= rl2->vcn)\r\nbreak;\r\n}\r\nBUG_ON(ll < rl2->vcn);\r\nBUG_ON(ll >= rl2->vcn + rl2->length);\r\nmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\r\nif (unlikely(mp_size <= 0)) {\r\nntfs_error(vol->sb, "Get size for mapping pairs failed for "\r\n"mft bitmap attribute extent.");\r\nret = mp_size;\r\nif (!ret)\r\nret = -EIO;\r\ngoto undo_alloc;\r\n}\r\nold_alen = le32_to_cpu(a->length);\r\nret = ntfs_attr_record_resize(ctx->mrec, a, mp_size +\r\nle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\r\nif (unlikely(ret)) {\r\nif (ret != -ENOSPC) {\r\nntfs_error(vol->sb, "Failed to resize attribute "\r\n"record for mft bitmap attribute.");\r\ngoto undo_alloc;\r\n}\r\nntfs_error(vol->sb, "Not enough space in this mft record to "\r\n"accommodate extended mft bitmap attribute "\r\n"extent. Cannot handle this yet.");\r\nret = -EOPNOTSUPP;\r\ngoto undo_alloc;\r\n}\r\nstatus.mp_rebuilt = 1;\r\nret = ntfs_mapping_pairs_build(vol, (u8*)a +\r\nle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\r\nmp_size, rl2, ll, -1, NULL);\r\nif (unlikely(ret)) {\r\nntfs_error(vol->sb, "Failed to build mapping pairs array for "\r\n"mft bitmap attribute.");\r\ngoto undo_alloc;\r\n}\r\na->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 1);\r\nif (a->data.non_resident.lowest_vcn) {\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\nntfs_attr_reinit_search_ctx(ctx);\r\nret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\r\nmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL,\r\n0, ctx);\r\nif (unlikely(ret)) {\r\nntfs_error(vol->sb, "Failed to find first attribute "\r\n"extent of mft bitmap attribute.");\r\ngoto restore_undo_alloc;\r\n}\r\na = ctx->attr;\r\n}\r\nwrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\r\nmftbmp_ni->allocated_size += vol->cluster_size;\r\na->data.non_resident.allocated_size =\r\ncpu_to_sle64(mftbmp_ni->allocated_size);\r\nwrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(mft_ni);\r\nup_write(&mftbmp_ni->runlist.lock);\r\nntfs_debug("Done.");\r\nreturn 0;\r\nrestore_undo_alloc:\r\nntfs_attr_reinit_search_ctx(ctx);\r\nif (ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\r\nmftbmp_ni->name_len, CASE_SENSITIVE, rl[1].vcn, NULL,\r\n0, ctx)) {\r\nntfs_error(vol->sb, "Failed to find last attribute extent of "\r\n"mft bitmap attribute.%s", es);\r\nwrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\r\nmftbmp_ni->allocated_size += vol->cluster_size;\r\nwrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(mft_ni);\r\nup_write(&mftbmp_ni->runlist.lock);\r\nNVolSetErrors(vol);\r\nreturn ret;\r\n}\r\na = ctx->attr;\r\na->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 2);\r\nundo_alloc:\r\nif (status.added_cluster) {\r\nrl->length--;\r\nrl[1].vcn--;\r\n} else if (status.added_run) {\r\nlcn = rl->lcn;\r\nrl->lcn = rl[1].lcn;\r\nrl->length = 0;\r\n}\r\ndown_write(&vol->lcnbmp_lock);\r\nif (ntfs_bitmap_clear_bit(vol->lcnbmp_ino, lcn)) {\r\nntfs_error(vol->sb, "Failed to free allocated cluster.%s", es);\r\nNVolSetErrors(vol);\r\n}\r\nup_write(&vol->lcnbmp_lock);\r\nif (status.mp_rebuilt) {\r\nif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\r\na->data.non_resident.mapping_pairs_offset),\r\nold_alen - le16_to_cpu(\r\na->data.non_resident.mapping_pairs_offset),\r\nrl2, ll, -1, NULL)) {\r\nntfs_error(vol->sb, "Failed to restore mapping pairs "\r\n"array.%s", es);\r\nNVolSetErrors(vol);\r\n}\r\nif (ntfs_attr_record_resize(ctx->mrec, a, old_alen)) {\r\nntfs_error(vol->sb, "Failed to restore attribute "\r\n"record.%s", es);\r\nNVolSetErrors(vol);\r\n}\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\n}\r\nif (ctx)\r\nntfs_attr_put_search_ctx(ctx);\r\nif (!IS_ERR(mrec))\r\nunmap_mft_record(mft_ni);\r\nup_write(&mftbmp_ni->runlist.lock);\r\nreturn ret;\r\n}\r\nstatic int ntfs_mft_bitmap_extend_initialized_nolock(ntfs_volume *vol)\r\n{\r\ns64 old_data_size, old_initialized_size;\r\nunsigned long flags;\r\nstruct inode *mftbmp_vi;\r\nntfs_inode *mft_ni, *mftbmp_ni;\r\nntfs_attr_search_ctx *ctx;\r\nMFT_RECORD *mrec;\r\nATTR_RECORD *a;\r\nint ret;\r\nntfs_debug("Extending mft bitmap initiailized (and data) size.");\r\nmft_ni = NTFS_I(vol->mft_ino);\r\nmftbmp_vi = vol->mftbmp_ino;\r\nmftbmp_ni = NTFS_I(mftbmp_vi);\r\nmrec = map_mft_record(mft_ni);\r\nif (IS_ERR(mrec)) {\r\nntfs_error(vol->sb, "Failed to map mft record.");\r\nreturn PTR_ERR(mrec);\r\n}\r\nctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\r\nif (unlikely(!ctx)) {\r\nntfs_error(vol->sb, "Failed to get search context.");\r\nret = -ENOMEM;\r\ngoto unm_err_out;\r\n}\r\nret = ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\r\nmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL, 0, ctx);\r\nif (unlikely(ret)) {\r\nntfs_error(vol->sb, "Failed to find first attribute extent of "\r\n"mft bitmap attribute.");\r\nif (ret == -ENOENT)\r\nret = -EIO;\r\ngoto put_err_out;\r\n}\r\na = ctx->attr;\r\nwrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\r\nold_data_size = i_size_read(mftbmp_vi);\r\nold_initialized_size = mftbmp_ni->initialized_size;\r\nmftbmp_ni->initialized_size += 8;\r\na->data.non_resident.initialized_size =\r\ncpu_to_sle64(mftbmp_ni->initialized_size);\r\nif (mftbmp_ni->initialized_size > old_data_size) {\r\ni_size_write(mftbmp_vi, mftbmp_ni->initialized_size);\r\na->data.non_resident.data_size =\r\ncpu_to_sle64(mftbmp_ni->initialized_size);\r\n}\r\nwrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(mft_ni);\r\nret = ntfs_attr_set(mftbmp_ni, old_initialized_size, 8, 0);\r\nif (likely(!ret)) {\r\nntfs_debug("Done. (Wrote eight initialized bytes to mft "\r\n"bitmap.");\r\nreturn 0;\r\n}\r\nntfs_error(vol->sb, "Failed to write to mft bitmap.");\r\nmrec = map_mft_record(mft_ni);\r\nif (IS_ERR(mrec)) {\r\nntfs_error(vol->sb, "Failed to map mft record.%s", es);\r\nNVolSetErrors(vol);\r\nreturn ret;\r\n}\r\nctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\r\nif (unlikely(!ctx)) {\r\nntfs_error(vol->sb, "Failed to get search context.%s", es);\r\nNVolSetErrors(vol);\r\ngoto unm_err_out;\r\n}\r\nif (ntfs_attr_lookup(mftbmp_ni->type, mftbmp_ni->name,\r\nmftbmp_ni->name_len, CASE_SENSITIVE, 0, NULL, 0, ctx)) {\r\nntfs_error(vol->sb, "Failed to find first attribute extent of "\r\n"mft bitmap attribute.%s", es);\r\nNVolSetErrors(vol);\r\nput_err_out:\r\nntfs_attr_put_search_ctx(ctx);\r\nunm_err_out:\r\nunmap_mft_record(mft_ni);\r\ngoto err_out;\r\n}\r\na = ctx->attr;\r\nwrite_lock_irqsave(&mftbmp_ni->size_lock, flags);\r\nmftbmp_ni->initialized_size = old_initialized_size;\r\na->data.non_resident.initialized_size =\r\ncpu_to_sle64(old_initialized_size);\r\nif (i_size_read(mftbmp_vi) != old_data_size) {\r\ni_size_write(mftbmp_vi, old_data_size);\r\na->data.non_resident.data_size = cpu_to_sle64(old_data_size);\r\n}\r\nwrite_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(mft_ni);\r\n#ifdef DEBUG\r\nread_lock_irqsave(&mftbmp_ni->size_lock, flags);\r\nntfs_debug("Restored status of mftbmp: allocated_size 0x%llx, "\r\n"data_size 0x%llx, initialized_size 0x%llx.",\r\n(long long)mftbmp_ni->allocated_size,\r\n(long long)i_size_read(mftbmp_vi),\r\n(long long)mftbmp_ni->initialized_size);\r\nread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\r\n#endif\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int ntfs_mft_data_extend_allocation_nolock(ntfs_volume *vol)\r\n{\r\nLCN lcn;\r\nVCN old_last_vcn;\r\ns64 min_nr, nr, ll;\r\nunsigned long flags;\r\nntfs_inode *mft_ni;\r\nrunlist_element *rl, *rl2;\r\nntfs_attr_search_ctx *ctx = NULL;\r\nMFT_RECORD *mrec;\r\nATTR_RECORD *a = NULL;\r\nint ret, mp_size;\r\nu32 old_alen = 0;\r\nbool mp_rebuilt = false;\r\nntfs_debug("Extending mft data allocation.");\r\nmft_ni = NTFS_I(vol->mft_ino);\r\ndown_write(&mft_ni->runlist.lock);\r\nread_lock_irqsave(&mft_ni->size_lock, flags);\r\nll = mft_ni->allocated_size;\r\nread_unlock_irqrestore(&mft_ni->size_lock, flags);\r\nrl = ntfs_attr_find_vcn_nolock(mft_ni,\r\n(ll - 1) >> vol->cluster_size_bits, NULL);\r\nif (unlikely(IS_ERR(rl) || !rl->length || rl->lcn < 0)) {\r\nup_write(&mft_ni->runlist.lock);\r\nntfs_error(vol->sb, "Failed to determine last allocated "\r\n"cluster of mft data attribute.");\r\nif (!IS_ERR(rl))\r\nret = -EIO;\r\nelse\r\nret = PTR_ERR(rl);\r\nreturn ret;\r\n}\r\nlcn = rl->lcn + rl->length;\r\nntfs_debug("Last lcn of mft data attribute is 0x%llx.", (long long)lcn);\r\nmin_nr = vol->mft_record_size >> vol->cluster_size_bits;\r\nif (!min_nr)\r\nmin_nr = 1;\r\nnr = vol->mft_record_size << 4 >> vol->cluster_size_bits;\r\nif (!nr)\r\nnr = min_nr;\r\nread_lock_irqsave(&mft_ni->size_lock, flags);\r\nll = mft_ni->allocated_size;\r\nread_unlock_irqrestore(&mft_ni->size_lock, flags);\r\nif (unlikely((ll + (nr << vol->cluster_size_bits)) >>\r\nvol->mft_record_size_bits >= (1ll << 32))) {\r\nnr = min_nr;\r\nif (unlikely((ll + (nr << vol->cluster_size_bits)) >>\r\nvol->mft_record_size_bits >= (1ll << 32))) {\r\nntfs_warning(vol->sb, "Cannot allocate mft record "\r\n"because the maximum number of inodes "\r\n"(2^32) has already been reached.");\r\nup_write(&mft_ni->runlist.lock);\r\nreturn -ENOSPC;\r\n}\r\n}\r\nntfs_debug("Trying mft data allocation with %s cluster count %lli.",\r\nnr > min_nr ? "default" : "minimal", (long long)nr);\r\nold_last_vcn = rl[1].vcn;\r\ndo {\r\nrl2 = ntfs_cluster_alloc(vol, old_last_vcn, nr, lcn, MFT_ZONE,\r\ntrue);\r\nif (likely(!IS_ERR(rl2)))\r\nbreak;\r\nif (PTR_ERR(rl2) != -ENOSPC || nr == min_nr) {\r\nntfs_error(vol->sb, "Failed to allocate the minimal "\r\n"number of clusters (%lli) for the "\r\n"mft data attribute.", (long long)nr);\r\nup_write(&mft_ni->runlist.lock);\r\nreturn PTR_ERR(rl2);\r\n}\r\nnr = min_nr;\r\nntfs_debug("Retrying mft data allocation with minimal cluster "\r\n"count %lli.", (long long)nr);\r\n} while (1);\r\nrl = ntfs_runlists_merge(mft_ni->runlist.rl, rl2);\r\nif (IS_ERR(rl)) {\r\nup_write(&mft_ni->runlist.lock);\r\nntfs_error(vol->sb, "Failed to merge runlists for mft data "\r\n"attribute.");\r\nif (ntfs_cluster_free_from_rl(vol, rl2)) {\r\nntfs_error(vol->sb, "Failed to deallocate clusters "\r\n"from the mft data attribute.%s", es);\r\nNVolSetErrors(vol);\r\n}\r\nntfs_free(rl2);\r\nreturn PTR_ERR(rl);\r\n}\r\nmft_ni->runlist.rl = rl;\r\nntfs_debug("Allocated %lli clusters.", (long long)nr);\r\nfor (; rl[1].length; rl++)\r\n;\r\nmrec = map_mft_record(mft_ni);\r\nif (IS_ERR(mrec)) {\r\nntfs_error(vol->sb, "Failed to map mft record.");\r\nret = PTR_ERR(mrec);\r\ngoto undo_alloc;\r\n}\r\nctx = ntfs_attr_get_search_ctx(mft_ni, mrec);\r\nif (unlikely(!ctx)) {\r\nntfs_error(vol->sb, "Failed to get search context.");\r\nret = -ENOMEM;\r\ngoto undo_alloc;\r\n}\r\nret = ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\r\nCASE_SENSITIVE, rl[1].vcn, NULL, 0, ctx);\r\nif (unlikely(ret)) {\r\nntfs_error(vol->sb, "Failed to find last attribute extent of "\r\n"mft data attribute.");\r\nif (ret == -ENOENT)\r\nret = -EIO;\r\ngoto undo_alloc;\r\n}\r\na = ctx->attr;\r\nll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\r\nfor (rl2 = rl; rl2 > mft_ni->runlist.rl; rl2--) {\r\nif (ll >= rl2->vcn)\r\nbreak;\r\n}\r\nBUG_ON(ll < rl2->vcn);\r\nBUG_ON(ll >= rl2->vcn + rl2->length);\r\nmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\r\nif (unlikely(mp_size <= 0)) {\r\nntfs_error(vol->sb, "Get size for mapping pairs failed for "\r\n"mft data attribute extent.");\r\nret = mp_size;\r\nif (!ret)\r\nret = -EIO;\r\ngoto undo_alloc;\r\n}\r\nold_alen = le32_to_cpu(a->length);\r\nret = ntfs_attr_record_resize(ctx->mrec, a, mp_size +\r\nle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\r\nif (unlikely(ret)) {\r\nif (ret != -ENOSPC) {\r\nntfs_error(vol->sb, "Failed to resize attribute "\r\n"record for mft data attribute.");\r\ngoto undo_alloc;\r\n}\r\nntfs_error(vol->sb, "Not enough space in this mft record to "\r\n"accommodate extended mft data attribute "\r\n"extent. Cannot handle this yet.");\r\nret = -EOPNOTSUPP;\r\ngoto undo_alloc;\r\n}\r\nmp_rebuilt = true;\r\nret = ntfs_mapping_pairs_build(vol, (u8*)a +\r\nle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\r\nmp_size, rl2, ll, -1, NULL);\r\nif (unlikely(ret)) {\r\nntfs_error(vol->sb, "Failed to build mapping pairs array of "\r\n"mft data attribute.");\r\ngoto undo_alloc;\r\n}\r\na->data.non_resident.highest_vcn = cpu_to_sle64(rl[1].vcn - 1);\r\nif (a->data.non_resident.lowest_vcn) {\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\nntfs_attr_reinit_search_ctx(ctx);\r\nret = ntfs_attr_lookup(mft_ni->type, mft_ni->name,\r\nmft_ni->name_len, CASE_SENSITIVE, 0, NULL, 0,\r\nctx);\r\nif (unlikely(ret)) {\r\nntfs_error(vol->sb, "Failed to find first attribute "\r\n"extent of mft data attribute.");\r\ngoto restore_undo_alloc;\r\n}\r\na = ctx->attr;\r\n}\r\nwrite_lock_irqsave(&mft_ni->size_lock, flags);\r\nmft_ni->allocated_size += nr << vol->cluster_size_bits;\r\na->data.non_resident.allocated_size =\r\ncpu_to_sle64(mft_ni->allocated_size);\r\nwrite_unlock_irqrestore(&mft_ni->size_lock, flags);\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(mft_ni);\r\nup_write(&mft_ni->runlist.lock);\r\nntfs_debug("Done.");\r\nreturn 0;\r\nrestore_undo_alloc:\r\nntfs_attr_reinit_search_ctx(ctx);\r\nif (ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\r\nCASE_SENSITIVE, rl[1].vcn, NULL, 0, ctx)) {\r\nntfs_error(vol->sb, "Failed to find last attribute extent of "\r\n"mft data attribute.%s", es);\r\nwrite_lock_irqsave(&mft_ni->size_lock, flags);\r\nmft_ni->allocated_size += nr << vol->cluster_size_bits;\r\nwrite_unlock_irqrestore(&mft_ni->size_lock, flags);\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(mft_ni);\r\nup_write(&mft_ni->runlist.lock);\r\nNVolSetErrors(vol);\r\nreturn ret;\r\n}\r\nctx->attr->data.non_resident.highest_vcn =\r\ncpu_to_sle64(old_last_vcn - 1);\r\nundo_alloc:\r\nif (ntfs_cluster_free(mft_ni, old_last_vcn, -1, ctx) < 0) {\r\nntfs_error(vol->sb, "Failed to free clusters from mft data "\r\n"attribute.%s", es);\r\nNVolSetErrors(vol);\r\n}\r\na = ctx->attr;\r\nif (ntfs_rl_truncate_nolock(vol, &mft_ni->runlist, old_last_vcn)) {\r\nntfs_error(vol->sb, "Failed to truncate mft data attribute "\r\n"runlist.%s", es);\r\nNVolSetErrors(vol);\r\n}\r\nif (mp_rebuilt && !IS_ERR(ctx->mrec)) {\r\nif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\r\na->data.non_resident.mapping_pairs_offset),\r\nold_alen - le16_to_cpu(\r\na->data.non_resident.mapping_pairs_offset),\r\nrl2, ll, -1, NULL)) {\r\nntfs_error(vol->sb, "Failed to restore mapping pairs "\r\n"array.%s", es);\r\nNVolSetErrors(vol);\r\n}\r\nif (ntfs_attr_record_resize(ctx->mrec, a, old_alen)) {\r\nntfs_error(vol->sb, "Failed to restore attribute "\r\n"record.%s", es);\r\nNVolSetErrors(vol);\r\n}\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\n} else if (IS_ERR(ctx->mrec)) {\r\nntfs_error(vol->sb, "Failed to restore attribute search "\r\n"context.%s", es);\r\nNVolSetErrors(vol);\r\n}\r\nif (ctx)\r\nntfs_attr_put_search_ctx(ctx);\r\nif (!IS_ERR(mrec))\r\nunmap_mft_record(mft_ni);\r\nup_write(&mft_ni->runlist.lock);\r\nreturn ret;\r\n}\r\nstatic int ntfs_mft_record_layout(const ntfs_volume *vol, const s64 mft_no,\r\nMFT_RECORD *m)\r\n{\r\nATTR_RECORD *a;\r\nntfs_debug("Entering for mft record 0x%llx.", (long long)mft_no);\r\nif (mft_no >= (1ll << 32)) {\r\nntfs_error(vol->sb, "Mft record number 0x%llx exceeds "\r\n"maximum of 2^32.", (long long)mft_no);\r\nreturn -ERANGE;\r\n}\r\nmemset(m, 0, vol->mft_record_size);\r\nif (vol->major_ver < 3 || (vol->major_ver == 3 && !vol->minor_ver))\r\nm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD_OLD) + 1) & ~1);\r\nelse {\r\nm->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD) + 1) & ~1);\r\nm->reserved = 0;\r\nm->mft_record_number = cpu_to_le32((u32)mft_no);\r\n}\r\nm->magic = magic_FILE;\r\nif (vol->mft_record_size >= NTFS_BLOCK_SIZE)\r\nm->usa_count = cpu_to_le16(vol->mft_record_size /\r\nNTFS_BLOCK_SIZE + 1);\r\nelse {\r\nm->usa_count = cpu_to_le16(1);\r\nntfs_warning(vol->sb, "Sector size is bigger than mft record "\r\n"size. Setting usa_count to 1. If chkdsk "\r\n"reports this as corruption, please email "\r\n"linux-ntfs-dev@lists.sourceforge.net stating "\r\n"that you saw this message and that the "\r\n"modified filesystem created was corrupt. "\r\n"Thank you.");\r\n}\r\n*(le16*)((u8*)m + le16_to_cpu(m->usa_ofs)) = cpu_to_le16(1);\r\nm->lsn = 0;\r\nm->sequence_number = cpu_to_le16(1);\r\nm->link_count = 0;\r\nm->attrs_offset = cpu_to_le16((le16_to_cpu(m->usa_ofs) +\r\n(le16_to_cpu(m->usa_count) << 1) + 7) & ~7);\r\nm->flags = 0;\r\nm->bytes_in_use = cpu_to_le32(le16_to_cpu(m->attrs_offset) + 8);\r\nm->bytes_allocated = cpu_to_le32(vol->mft_record_size);\r\nm->base_mft_record = 0;\r\nm->next_attr_instance = 0;\r\na = (ATTR_RECORD*)((u8*)m + le16_to_cpu(m->attrs_offset));\r\na->type = AT_END;\r\na->length = 0;\r\nntfs_debug("Done.");\r\nreturn 0;\r\n}\r\nstatic int ntfs_mft_record_format(const ntfs_volume *vol, const s64 mft_no)\r\n{\r\nloff_t i_size;\r\nstruct inode *mft_vi = vol->mft_ino;\r\nstruct page *page;\r\nMFT_RECORD *m;\r\npgoff_t index, end_index;\r\nunsigned int ofs;\r\nint err;\r\nntfs_debug("Entering for mft record 0x%llx.", (long long)mft_no);\r\nindex = mft_no << vol->mft_record_size_bits >> PAGE_CACHE_SHIFT;\r\nofs = (mft_no << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\r\ni_size = i_size_read(mft_vi);\r\nend_index = i_size >> PAGE_CACHE_SHIFT;\r\nif (unlikely(index >= end_index)) {\r\nif (unlikely(index > end_index || ofs + vol->mft_record_size >=\r\n(i_size & ~PAGE_CACHE_MASK))) {\r\nntfs_error(vol->sb, "Tried to format non-existing mft "\r\n"record 0x%llx.", (long long)mft_no);\r\nreturn -ENOENT;\r\n}\r\n}\r\npage = ntfs_map_page(mft_vi->i_mapping, index);\r\nif (IS_ERR(page)) {\r\nntfs_error(vol->sb, "Failed to map page containing mft record "\r\n"to format 0x%llx.", (long long)mft_no);\r\nreturn PTR_ERR(page);\r\n}\r\nlock_page(page);\r\nBUG_ON(!PageUptodate(page));\r\nClearPageUptodate(page);\r\nm = (MFT_RECORD*)((u8*)page_address(page) + ofs);\r\nerr = ntfs_mft_record_layout(vol, mft_no, m);\r\nif (unlikely(err)) {\r\nntfs_error(vol->sb, "Failed to layout mft record 0x%llx.",\r\n(long long)mft_no);\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\nntfs_unmap_page(page);\r\nreturn err;\r\n}\r\nflush_dcache_page(page);\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\nmark_ntfs_record_dirty(page, ofs);\r\nntfs_unmap_page(page);\r\nntfs_debug("Done.");\r\nreturn 0;\r\n}\r\nntfs_inode *ntfs_mft_record_alloc(ntfs_volume *vol, const int mode,\r\nntfs_inode *base_ni, MFT_RECORD **mrec)\r\n{\r\ns64 ll, bit, old_data_initialized, old_data_size;\r\nunsigned long flags;\r\nstruct inode *vi;\r\nstruct page *page;\r\nntfs_inode *mft_ni, *mftbmp_ni, *ni;\r\nntfs_attr_search_ctx *ctx;\r\nMFT_RECORD *m;\r\nATTR_RECORD *a;\r\npgoff_t index;\r\nunsigned int ofs;\r\nint err;\r\nle16 seq_no, usn;\r\nbool record_formatted = false;\r\nif (base_ni) {\r\nntfs_debug("Entering (allocating an extent mft record for "\r\n"base mft record 0x%llx).",\r\n(long long)base_ni->mft_no);\r\nBUG_ON(mode);\r\n} else\r\nntfs_debug("Entering (allocating a base mft record).");\r\nif (mode) {\r\nBUG_ON(base_ni);\r\nif (!S_ISREG(mode) && !S_ISDIR(mode))\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\nBUG_ON(!mrec);\r\nmft_ni = NTFS_I(vol->mft_ino);\r\nmftbmp_ni = NTFS_I(vol->mftbmp_ino);\r\ndown_write(&vol->mftbmp_lock);\r\nbit = ntfs_mft_bitmap_find_and_alloc_free_rec_nolock(vol, base_ni);\r\nif (bit >= 0) {\r\nntfs_debug("Found and allocated free record (#1), bit 0x%llx.",\r\n(long long)bit);\r\ngoto have_alloc_rec;\r\n}\r\nif (bit != -ENOSPC) {\r\nup_write(&vol->mftbmp_lock);\r\nreturn ERR_PTR(bit);\r\n}\r\nread_lock_irqsave(&mft_ni->size_lock, flags);\r\nll = mft_ni->initialized_size >> vol->mft_record_size_bits;\r\nread_unlock_irqrestore(&mft_ni->size_lock, flags);\r\nread_lock_irqsave(&mftbmp_ni->size_lock, flags);\r\nold_data_initialized = mftbmp_ni->initialized_size;\r\nread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\r\nif (old_data_initialized << 3 > ll && old_data_initialized > 3) {\r\nbit = ll;\r\nif (bit < 24)\r\nbit = 24;\r\nif (unlikely(bit >= (1ll << 32)))\r\ngoto max_err_out;\r\nntfs_debug("Found free record (#2), bit 0x%llx.",\r\n(long long)bit);\r\ngoto found_free_rec;\r\n}\r\nbit = old_data_initialized << 3;\r\nif (unlikely(bit >= (1ll << 32)))\r\ngoto max_err_out;\r\nread_lock_irqsave(&mftbmp_ni->size_lock, flags);\r\nold_data_size = mftbmp_ni->allocated_size;\r\nntfs_debug("Status of mftbmp before extension: allocated_size 0x%llx, "\r\n"data_size 0x%llx, initialized_size 0x%llx.",\r\n(long long)old_data_size,\r\n(long long)i_size_read(vol->mftbmp_ino),\r\n(long long)old_data_initialized);\r\nread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\r\nif (old_data_initialized + 8 > old_data_size) {\r\nntfs_debug("mftbmp: initialized_size + 8 > allocated_size.");\r\nerr = ntfs_mft_bitmap_extend_allocation_nolock(vol);\r\nif (unlikely(err)) {\r\nup_write(&vol->mftbmp_lock);\r\ngoto err_out;\r\n}\r\n#ifdef DEBUG\r\nread_lock_irqsave(&mftbmp_ni->size_lock, flags);\r\nntfs_debug("Status of mftbmp after allocation extension: "\r\n"allocated_size 0x%llx, data_size 0x%llx, "\r\n"initialized_size 0x%llx.",\r\n(long long)mftbmp_ni->allocated_size,\r\n(long long)i_size_read(vol->mftbmp_ino),\r\n(long long)mftbmp_ni->initialized_size);\r\nread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\r\n#endif\r\n}\r\nerr = ntfs_mft_bitmap_extend_initialized_nolock(vol);\r\nif (unlikely(err)) {\r\nup_write(&vol->mftbmp_lock);\r\ngoto err_out;\r\n}\r\n#ifdef DEBUG\r\nread_lock_irqsave(&mftbmp_ni->size_lock, flags);\r\nntfs_debug("Status of mftbmp after initialized extension: "\r\n"allocated_size 0x%llx, data_size 0x%llx, "\r\n"initialized_size 0x%llx.",\r\n(long long)mftbmp_ni->allocated_size,\r\n(long long)i_size_read(vol->mftbmp_ino),\r\n(long long)mftbmp_ni->initialized_size);\r\nread_unlock_irqrestore(&mftbmp_ni->size_lock, flags);\r\n#endif\r\nntfs_debug("Found free record (#3), bit 0x%llx.", (long long)bit);\r\nfound_free_rec:\r\nntfs_debug("At found_free_rec.");\r\nerr = ntfs_bitmap_set_bit(vol->mftbmp_ino, bit);\r\nif (unlikely(err)) {\r\nntfs_error(vol->sb, "Failed to allocate bit in mft bitmap.");\r\nup_write(&vol->mftbmp_lock);\r\ngoto err_out;\r\n}\r\nntfs_debug("Set bit 0x%llx in mft bitmap.", (long long)bit);\r\nhave_alloc_rec:\r\nll = (bit + 1) << vol->mft_record_size_bits;\r\nread_lock_irqsave(&mft_ni->size_lock, flags);\r\nold_data_initialized = mft_ni->initialized_size;\r\nread_unlock_irqrestore(&mft_ni->size_lock, flags);\r\nif (ll <= old_data_initialized) {\r\nntfs_debug("Allocated mft record already initialized.");\r\ngoto mft_rec_already_initialized;\r\n}\r\nntfs_debug("Initializing allocated mft record.");\r\nread_lock_irqsave(&mft_ni->size_lock, flags);\r\nntfs_debug("Status of mft data before extension: "\r\n"allocated_size 0x%llx, data_size 0x%llx, "\r\n"initialized_size 0x%llx.",\r\n(long long)mft_ni->allocated_size,\r\n(long long)i_size_read(vol->mft_ino),\r\n(long long)mft_ni->initialized_size);\r\nwhile (ll > mft_ni->allocated_size) {\r\nread_unlock_irqrestore(&mft_ni->size_lock, flags);\r\nerr = ntfs_mft_data_extend_allocation_nolock(vol);\r\nif (unlikely(err)) {\r\nntfs_error(vol->sb, "Failed to extend mft data "\r\n"allocation.");\r\ngoto undo_mftbmp_alloc_nolock;\r\n}\r\nread_lock_irqsave(&mft_ni->size_lock, flags);\r\nntfs_debug("Status of mft data after allocation extension: "\r\n"allocated_size 0x%llx, data_size 0x%llx, "\r\n"initialized_size 0x%llx.",\r\n(long long)mft_ni->allocated_size,\r\n(long long)i_size_read(vol->mft_ino),\r\n(long long)mft_ni->initialized_size);\r\n}\r\nread_unlock_irqrestore(&mft_ni->size_lock, flags);\r\nwrite_lock_irqsave(&mft_ni->size_lock, flags);\r\nold_data_initialized = mft_ni->initialized_size;\r\nold_data_size = vol->mft_ino->i_size;\r\nwhile (ll > mft_ni->initialized_size) {\r\ns64 new_initialized_size, mft_no;\r\nnew_initialized_size = mft_ni->initialized_size +\r\nvol->mft_record_size;\r\nmft_no = mft_ni->initialized_size >> vol->mft_record_size_bits;\r\nif (new_initialized_size > i_size_read(vol->mft_ino))\r\ni_size_write(vol->mft_ino, new_initialized_size);\r\nwrite_unlock_irqrestore(&mft_ni->size_lock, flags);\r\nntfs_debug("Initializing mft record 0x%llx.",\r\n(long long)mft_no);\r\nerr = ntfs_mft_record_format(vol, mft_no);\r\nif (unlikely(err)) {\r\nntfs_error(vol->sb, "Failed to format mft record.");\r\ngoto undo_data_init;\r\n}\r\nwrite_lock_irqsave(&mft_ni->size_lock, flags);\r\nmft_ni->initialized_size = new_initialized_size;\r\n}\r\nwrite_unlock_irqrestore(&mft_ni->size_lock, flags);\r\nrecord_formatted = true;\r\nm = map_mft_record(mft_ni);\r\nif (IS_ERR(m)) {\r\nntfs_error(vol->sb, "Failed to map mft record.");\r\nerr = PTR_ERR(m);\r\ngoto undo_data_init;\r\n}\r\nctx = ntfs_attr_get_search_ctx(mft_ni, m);\r\nif (unlikely(!ctx)) {\r\nntfs_error(vol->sb, "Failed to get search context.");\r\nerr = -ENOMEM;\r\nunmap_mft_record(mft_ni);\r\ngoto undo_data_init;\r\n}\r\nerr = ntfs_attr_lookup(mft_ni->type, mft_ni->name, mft_ni->name_len,\r\nCASE_SENSITIVE, 0, NULL, 0, ctx);\r\nif (unlikely(err)) {\r\nntfs_error(vol->sb, "Failed to find first attribute extent of "\r\n"mft data attribute.");\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(mft_ni);\r\ngoto undo_data_init;\r\n}\r\na = ctx->attr;\r\nread_lock_irqsave(&mft_ni->size_lock, flags);\r\na->data.non_resident.initialized_size =\r\ncpu_to_sle64(mft_ni->initialized_size);\r\na->data.non_resident.data_size =\r\ncpu_to_sle64(i_size_read(vol->mft_ino));\r\nread_unlock_irqrestore(&mft_ni->size_lock, flags);\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(mft_ni);\r\nread_lock_irqsave(&mft_ni->size_lock, flags);\r\nntfs_debug("Status of mft data after mft record initialization: "\r\n"allocated_size 0x%llx, data_size 0x%llx, "\r\n"initialized_size 0x%llx.",\r\n(long long)mft_ni->allocated_size,\r\n(long long)i_size_read(vol->mft_ino),\r\n(long long)mft_ni->initialized_size);\r\nBUG_ON(i_size_read(vol->mft_ino) > mft_ni->allocated_size);\r\nBUG_ON(mft_ni->initialized_size > i_size_read(vol->mft_ino));\r\nread_unlock_irqrestore(&mft_ni->size_lock, flags);\r\nmft_rec_already_initialized:\r\nup_write(&vol->mftbmp_lock);\r\nindex = bit << vol->mft_record_size_bits >> PAGE_CACHE_SHIFT;\r\nofs = (bit << vol->mft_record_size_bits) & ~PAGE_CACHE_MASK;\r\npage = ntfs_map_page(vol->mft_ino->i_mapping, index);\r\nif (IS_ERR(page)) {\r\nntfs_error(vol->sb, "Failed to map page containing allocated "\r\n"mft record 0x%llx.", (long long)bit);\r\nerr = PTR_ERR(page);\r\ngoto undo_mftbmp_alloc;\r\n}\r\nlock_page(page);\r\nBUG_ON(!PageUptodate(page));\r\nClearPageUptodate(page);\r\nm = (MFT_RECORD*)((u8*)page_address(page) + ofs);\r\nif (!record_formatted) {\r\nif (ntfs_is_file_record(m->magic) &&\r\n(m->flags & MFT_RECORD_IN_USE)) {\r\nntfs_error(vol->sb, "Mft record 0x%llx was marked "\r\n"free in mft bitmap but is marked "\r\n"used itself. Corrupt filesystem. "\r\n"Unmount and run chkdsk.",\r\n(long long)bit);\r\nerr = -EIO;\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\nntfs_unmap_page(page);\r\nNVolSetErrors(vol);\r\ngoto undo_mftbmp_alloc;\r\n}\r\nseq_no = m->sequence_number;\r\nusn = *(le16*)((u8*)m + le16_to_cpu(m->usa_ofs));\r\nerr = ntfs_mft_record_layout(vol, bit, m);\r\nif (unlikely(err)) {\r\nntfs_error(vol->sb, "Failed to layout allocated mft "\r\n"record 0x%llx.", (long long)bit);\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\nntfs_unmap_page(page);\r\ngoto undo_mftbmp_alloc;\r\n}\r\nif (seq_no)\r\nm->sequence_number = seq_no;\r\nif (usn && le16_to_cpu(usn) != 0xffff)\r\n*(le16*)((u8*)m + le16_to_cpu(m->usa_ofs)) = usn;\r\n}\r\nm->flags |= MFT_RECORD_IN_USE;\r\nif (S_ISDIR(mode))\r\nm->flags |= MFT_RECORD_IS_DIRECTORY;\r\nflush_dcache_page(page);\r\nSetPageUptodate(page);\r\nif (base_ni) {\r\nMFT_RECORD *m_tmp;\r\nm->base_mft_record = MK_LE_MREF(base_ni->mft_no,\r\nbase_ni->seq_no);\r\nm_tmp = map_extent_mft_record(base_ni, bit, &ni);\r\nif (IS_ERR(m_tmp)) {\r\nntfs_error(vol->sb, "Failed to map allocated extent "\r\n"mft record 0x%llx.", (long long)bit);\r\nerr = PTR_ERR(m_tmp);\r\nm->flags &= cpu_to_le16(\r\n~le16_to_cpu(MFT_RECORD_IN_USE));\r\nflush_dcache_page(page);\r\nmark_ntfs_record_dirty(page, ofs);\r\nunlock_page(page);\r\nntfs_unmap_page(page);\r\ngoto undo_mftbmp_alloc;\r\n}\r\nBUG_ON(m != m_tmp);\r\nmark_ntfs_record_dirty(page, ofs);\r\nunlock_page(page);\r\nntfs_unmap_page(page);\r\n} else {\r\nvi = new_inode(vol->sb);\r\nif (unlikely(!vi)) {\r\nerr = -ENOMEM;\r\nm->flags &= cpu_to_le16(\r\n~le16_to_cpu(MFT_RECORD_IN_USE));\r\nflush_dcache_page(page);\r\nmark_ntfs_record_dirty(page, ofs);\r\nunlock_page(page);\r\nntfs_unmap_page(page);\r\ngoto undo_mftbmp_alloc;\r\n}\r\nvi->i_ino = bit;\r\nvi->i_version = 1;\r\nvi->i_uid = vol->uid;\r\nvi->i_gid = vol->gid;\r\nntfs_init_big_inode(vi);\r\nni = NTFS_I(vi);\r\nif (S_ISDIR(mode)) {\r\nvi->i_mode = S_IFDIR | S_IRWXUGO;\r\nvi->i_mode &= ~vol->dmask;\r\nNInoSetMstProtected(ni);\r\nni->type = AT_INDEX_ALLOCATION;\r\nni->name = I30;\r\nni->name_len = 4;\r\nni->itype.index.block_size = 4096;\r\nni->itype.index.block_size_bits = ntfs_ffs(4096) - 1;\r\nni->itype.index.collation_rule = COLLATION_FILE_NAME;\r\nif (vol->cluster_size <= ni->itype.index.block_size) {\r\nni->itype.index.vcn_size = vol->cluster_size;\r\nni->itype.index.vcn_size_bits =\r\nvol->cluster_size_bits;\r\n} else {\r\nni->itype.index.vcn_size = vol->sector_size;\r\nni->itype.index.vcn_size_bits =\r\nvol->sector_size_bits;\r\n}\r\n} else {\r\nvi->i_mode = S_IFREG | S_IRWXUGO;\r\nvi->i_mode &= ~vol->fmask;\r\nni->type = AT_DATA;\r\nni->name = NULL;\r\nni->name_len = 0;\r\n}\r\nif (IS_RDONLY(vi))\r\nvi->i_mode &= ~S_IWUGO;\r\nvi->i_atime = vi->i_mtime = vi->i_ctime =\r\ncurrent_fs_time(vi->i_sb);\r\nvi->i_size = 0;\r\nvi->i_blocks = 0;\r\nvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\r\natomic_inc(&ni->count);\r\nmutex_lock(&ni->mrec_lock);\r\nni->page = page;\r\nni->page_ofs = ofs;\r\nmark_ntfs_record_dirty(page, ofs);\r\nunlock_page(page);\r\ninsert_inode_hash(vi);\r\nvol->mft_data_pos = bit + 1;\r\n}\r\nntfs_debug("Returning opened, allocated %sinode 0x%llx.",\r\nbase_ni ? "extent " : "", (long long)bit);\r\n*mrec = m;\r\nreturn ni;\r\nundo_data_init:\r\nwrite_lock_irqsave(&mft_ni->size_lock, flags);\r\nmft_ni->initialized_size = old_data_initialized;\r\ni_size_write(vol->mft_ino, old_data_size);\r\nwrite_unlock_irqrestore(&mft_ni->size_lock, flags);\r\ngoto undo_mftbmp_alloc_nolock;\r\nundo_mftbmp_alloc:\r\ndown_write(&vol->mftbmp_lock);\r\nundo_mftbmp_alloc_nolock:\r\nif (ntfs_bitmap_clear_bit(vol->mftbmp_ino, bit)) {\r\nntfs_error(vol->sb, "Failed to clear bit in mft bitmap.%s", es);\r\nNVolSetErrors(vol);\r\n}\r\nup_write(&vol->mftbmp_lock);\r\nerr_out:\r\nreturn ERR_PTR(err);\r\nmax_err_out:\r\nntfs_warning(vol->sb, "Cannot allocate mft record because the maximum "\r\n"number of inodes (2^32) has already been reached.");\r\nup_write(&vol->mftbmp_lock);\r\nreturn ERR_PTR(-ENOSPC);\r\n}\r\nint ntfs_extent_mft_record_free(ntfs_inode *ni, MFT_RECORD *m)\r\n{\r\nunsigned long mft_no = ni->mft_no;\r\nntfs_volume *vol = ni->vol;\r\nntfs_inode *base_ni;\r\nntfs_inode **extent_nis;\r\nint i, err;\r\nle16 old_seq_no;\r\nu16 seq_no;\r\nBUG_ON(NInoAttr(ni));\r\nBUG_ON(ni->nr_extents != -1);\r\nmutex_lock(&ni->extent_lock);\r\nbase_ni = ni->ext.base_ntfs_ino;\r\nmutex_unlock(&ni->extent_lock);\r\nBUG_ON(base_ni->nr_extents <= 0);\r\nntfs_debug("Entering for extent inode 0x%lx, base inode 0x%lx.\n",\r\nmft_no, base_ni->mft_no);\r\nmutex_lock(&base_ni->extent_lock);\r\nif (atomic_read(&ni->count) > 2) {\r\nntfs_error(vol->sb, "Tried to free busy extent inode 0x%lx, "\r\n"not freeing.", base_ni->mft_no);\r\nmutex_unlock(&base_ni->extent_lock);\r\nreturn -EBUSY;\r\n}\r\nextent_nis = base_ni->ext.extent_ntfs_inos;\r\nerr = -ENOENT;\r\nfor (i = 0; i < base_ni->nr_extents; i++) {\r\nif (ni != extent_nis[i])\r\ncontinue;\r\nextent_nis += i;\r\nbase_ni->nr_extents--;\r\nmemmove(extent_nis, extent_nis + 1, (base_ni->nr_extents - i) *\r\nsizeof(ntfs_inode*));\r\nerr = 0;\r\nbreak;\r\n}\r\nmutex_unlock(&base_ni->extent_lock);\r\nif (unlikely(err)) {\r\nntfs_error(vol->sb, "Extent inode 0x%lx is not attached to "\r\n"its base inode 0x%lx.", mft_no,\r\nbase_ni->mft_no);\r\nBUG();\r\n}\r\nm->flags &= ~MFT_RECORD_IN_USE;\r\nold_seq_no = m->sequence_number;\r\nseq_no = le16_to_cpu(old_seq_no);\r\nif (seq_no == 0xffff)\r\nseq_no = 1;\r\nelse if (seq_no)\r\nseq_no++;\r\nm->sequence_number = cpu_to_le16(seq_no);\r\nNInoSetDirty(ni);\r\nerr = write_mft_record(ni, m, 0);\r\nif (unlikely(err)) {\r\nntfs_error(vol->sb, "Failed to write mft record 0x%lx, not "\r\n"freeing.", mft_no);\r\ngoto rollback;\r\n}\r\nrollback_error:\r\nunmap_extent_mft_record(ni);\r\nntfs_clear_extent_inode(ni);\r\ndown_write(&vol->mftbmp_lock);\r\nerr = ntfs_bitmap_clear_bit(vol->mftbmp_ino, mft_no);\r\nup_write(&vol->mftbmp_lock);\r\nif (unlikely(err)) {\r\nntfs_error(vol->sb, "Failed to clear bit in mft bitmap.%s", es);\r\nNVolSetErrors(vol);\r\n}\r\nreturn 0;\r\nrollback:\r\nmutex_lock(&base_ni->extent_lock);\r\nextent_nis = base_ni->ext.extent_ntfs_inos;\r\nif (!(base_ni->nr_extents & 3)) {\r\nint new_size = (base_ni->nr_extents + 4) * sizeof(ntfs_inode*);\r\nextent_nis = kmalloc(new_size, GFP_NOFS);\r\nif (unlikely(!extent_nis)) {\r\nntfs_error(vol->sb, "Failed to allocate internal "\r\n"buffer during rollback.%s", es);\r\nmutex_unlock(&base_ni->extent_lock);\r\nNVolSetErrors(vol);\r\ngoto rollback_error;\r\n}\r\nif (base_ni->nr_extents) {\r\nBUG_ON(!base_ni->ext.extent_ntfs_inos);\r\nmemcpy(extent_nis, base_ni->ext.extent_ntfs_inos,\r\nnew_size - 4 * sizeof(ntfs_inode*));\r\nkfree(base_ni->ext.extent_ntfs_inos);\r\n}\r\nbase_ni->ext.extent_ntfs_inos = extent_nis;\r\n}\r\nm->flags |= MFT_RECORD_IN_USE;\r\nm->sequence_number = old_seq_no;\r\nextent_nis[base_ni->nr_extents++] = ni;\r\nmutex_unlock(&base_ni->extent_lock);\r\nmark_mft_record_dirty(ni);\r\nreturn err;\r\n}
