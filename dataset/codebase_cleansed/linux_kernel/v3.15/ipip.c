static int ipip_err(struct sk_buff *skb, u32 info)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct ip_tunnel_net *itn = net_generic(net, ipip_net_id);\r\nconst struct iphdr *iph = (const struct iphdr *)skb->data;\r\nstruct ip_tunnel *t;\r\nint err;\r\nconst int type = icmp_hdr(skb)->type;\r\nconst int code = icmp_hdr(skb)->code;\r\nerr = -ENOENT;\r\nt = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,\r\niph->daddr, iph->saddr, 0);\r\nif (t == NULL)\r\ngoto out;\r\nif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED) {\r\nipv4_update_pmtu(skb, dev_net(skb->dev), info,\r\nt->dev->ifindex, 0, IPPROTO_IPIP, 0);\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (type == ICMP_REDIRECT) {\r\nipv4_redirect(skb, dev_net(skb->dev), t->dev->ifindex, 0,\r\nIPPROTO_IPIP, 0);\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (t->parms.iph.daddr == 0)\r\ngoto out;\r\nerr = 0;\r\nif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\r\ngoto out;\r\nif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\r\nt->err_count++;\r\nelse\r\nt->err_count = 1;\r\nt->err_time = jiffies;\r\nout:\r\nreturn err;\r\n}\r\nstatic int ipip_rcv(struct sk_buff *skb)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct ip_tunnel_net *itn = net_generic(net, ipip_net_id);\r\nstruct ip_tunnel *tunnel;\r\nconst struct iphdr *iph;\r\niph = ip_hdr(skb);\r\ntunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,\r\niph->saddr, iph->daddr, 0);\r\nif (tunnel) {\r\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\r\ngoto drop;\r\nif (iptunnel_pull_header(skb, 0, tpi.proto))\r\ngoto drop;\r\nreturn ip_tunnel_rcv(tunnel, skb, &tpi, log_ecn_error);\r\n}\r\nreturn -1;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t ipip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nconst struct iphdr *tiph = &tunnel->parms.iph;\r\nif (unlikely(skb->protocol != htons(ETH_P_IP)))\r\ngoto tx_error;\r\nskb = iptunnel_handle_offloads(skb, false, SKB_GSO_IPIP);\r\nif (IS_ERR(skb))\r\ngoto out;\r\nip_tunnel_xmit(skb, dev, tiph, tiph->protocol);\r\nreturn NETDEV_TX_OK;\r\ntx_error:\r\nkfree_skb(skb);\r\nout:\r\ndev->stats.tx_errors++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int\r\nipip_tunnel_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nint err = 0;\r\nstruct ip_tunnel_parm p;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\r\nreturn -EFAULT;\r\nif (cmd == SIOCADDTUNNEL || cmd == SIOCCHGTUNNEL) {\r\nif (p.iph.version != 4 || p.iph.protocol != IPPROTO_IPIP ||\r\np.iph.ihl != 5 || (p.iph.frag_off&htons(~IP_DF)))\r\nreturn -EINVAL;\r\n}\r\np.i_key = p.o_key = p.i_flags = p.o_flags = 0;\r\nif (p.iph.ttl)\r\np.iph.frag_off |= htons(IP_DF);\r\nerr = ip_tunnel_ioctl(dev, &p, cmd);\r\nif (err)\r\nreturn err;\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void ipip_tunnel_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &ipip_netdev_ops;\r\ndev->type = ARPHRD_TUNNEL;\r\ndev->flags = IFF_NOARP;\r\ndev->iflink = 0;\r\ndev->addr_len = 4;\r\ndev->features |= NETIF_F_LLTX;\r\ndev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\r\ndev->features |= IPIP_FEATURES;\r\ndev->hw_features |= IPIP_FEATURES;\r\nip_tunnel_setup(dev, ipip_net_id);\r\n}\r\nstatic int ipip_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nmemcpy(dev->dev_addr, &tunnel->parms.iph.saddr, 4);\r\nmemcpy(dev->broadcast, &tunnel->parms.iph.daddr, 4);\r\ntunnel->hlen = 0;\r\ntunnel->parms.iph.protocol = IPPROTO_IPIP;\r\nreturn ip_tunnel_init(dev);\r\n}\r\nstatic void ipip_netlink_parms(struct nlattr *data[],\r\nstruct ip_tunnel_parm *parms)\r\n{\r\nmemset(parms, 0, sizeof(*parms));\r\nparms->iph.version = 4;\r\nparms->iph.protocol = IPPROTO_IPIP;\r\nparms->iph.ihl = 5;\r\nif (!data)\r\nreturn;\r\nif (data[IFLA_IPTUN_LINK])\r\nparms->link = nla_get_u32(data[IFLA_IPTUN_LINK]);\r\nif (data[IFLA_IPTUN_LOCAL])\r\nparms->iph.saddr = nla_get_be32(data[IFLA_IPTUN_LOCAL]);\r\nif (data[IFLA_IPTUN_REMOTE])\r\nparms->iph.daddr = nla_get_be32(data[IFLA_IPTUN_REMOTE]);\r\nif (data[IFLA_IPTUN_TTL]) {\r\nparms->iph.ttl = nla_get_u8(data[IFLA_IPTUN_TTL]);\r\nif (parms->iph.ttl)\r\nparms->iph.frag_off = htons(IP_DF);\r\n}\r\nif (data[IFLA_IPTUN_TOS])\r\nparms->iph.tos = nla_get_u8(data[IFLA_IPTUN_TOS]);\r\nif (!data[IFLA_IPTUN_PMTUDISC] || nla_get_u8(data[IFLA_IPTUN_PMTUDISC]))\r\nparms->iph.frag_off = htons(IP_DF);\r\n}\r\nstatic int ipip_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct ip_tunnel_parm p;\r\nipip_netlink_parms(data, &p);\r\nreturn ip_tunnel_newlink(dev, tb, &p);\r\n}\r\nstatic int ipip_changelink(struct net_device *dev, struct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\nstruct ip_tunnel_parm p;\r\nipip_netlink_parms(data, &p);\r\nif (((dev->flags & IFF_POINTOPOINT) && !p.iph.daddr) ||\r\n(!(dev->flags & IFF_POINTOPOINT) && p.iph.daddr))\r\nreturn -EINVAL;\r\nreturn ip_tunnel_changelink(dev, tb, &p);\r\n}\r\nstatic size_t ipip_get_size(const struct net_device *dev)\r\n{\r\nreturn\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(1) +\r\nnla_total_size(1) +\r\nnla_total_size(1) +\r\n0;\r\n}\r\nstatic int ipip_fill_info(struct sk_buff *skb, const struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct ip_tunnel_parm *parm = &tunnel->parms;\r\nif (nla_put_u32(skb, IFLA_IPTUN_LINK, parm->link) ||\r\nnla_put_be32(skb, IFLA_IPTUN_LOCAL, parm->iph.saddr) ||\r\nnla_put_be32(skb, IFLA_IPTUN_REMOTE, parm->iph.daddr) ||\r\nnla_put_u8(skb, IFLA_IPTUN_TTL, parm->iph.ttl) ||\r\nnla_put_u8(skb, IFLA_IPTUN_TOS, parm->iph.tos) ||\r\nnla_put_u8(skb, IFLA_IPTUN_PMTUDISC,\r\n!!(parm->iph.frag_off & htons(IP_DF))))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int __net_init ipip_init_net(struct net *net)\r\n{\r\nreturn ip_tunnel_init_net(net, ipip_net_id, &ipip_link_ops, "tunl0");\r\n}\r\nstatic void __net_exit ipip_exit_net(struct net *net)\r\n{\r\nstruct ip_tunnel_net *itn = net_generic(net, ipip_net_id);\r\nip_tunnel_delete_net(itn, &ipip_link_ops);\r\n}\r\nstatic int __init ipip_init(void)\r\n{\r\nint err;\r\npr_info("ipip: IPv4 over IPv4 tunneling driver\n");\r\nerr = register_pernet_device(&ipip_net_ops);\r\nif (err < 0)\r\nreturn err;\r\nerr = xfrm4_tunnel_register(&ipip_handler, AF_INET);\r\nif (err < 0) {\r\npr_info("%s: can't register tunnel\n", __func__);\r\ngoto xfrm_tunnel_failed;\r\n}\r\nerr = rtnl_link_register(&ipip_link_ops);\r\nif (err < 0)\r\ngoto rtnl_link_failed;\r\nout:\r\nreturn err;\r\nrtnl_link_failed:\r\nxfrm4_tunnel_deregister(&ipip_handler, AF_INET);\r\nxfrm_tunnel_failed:\r\nunregister_pernet_device(&ipip_net_ops);\r\ngoto out;\r\n}\r\nstatic void __exit ipip_fini(void)\r\n{\r\nrtnl_link_unregister(&ipip_link_ops);\r\nif (xfrm4_tunnel_deregister(&ipip_handler, AF_INET))\r\npr_info("%s: can't deregister tunnel\n", __func__);\r\nunregister_pernet_device(&ipip_net_ops);\r\n}
