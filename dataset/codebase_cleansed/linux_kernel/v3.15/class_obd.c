int lustre_get_jobid(char *jobid)\r\n{\r\nint jobid_len = JOBSTATS_JOBID_SIZE;\r\nint rc = 0;\r\nmemset(jobid, 0, JOBSTATS_JOBID_SIZE);\r\nif (strcmp(obd_jobid_var, JOBSTATS_DISABLE) == 0)\r\nreturn 0;\r\nif (strcmp(obd_jobid_var, JOBSTATS_PROCNAME_UID) == 0) {\r\nsnprintf(jobid, JOBSTATS_JOBID_SIZE, "%s.%u",\r\ncurrent_comm(),\r\nfrom_kuid(&init_user_ns, current_fsuid()));\r\nreturn 0;\r\n}\r\nrc = cfs_get_environ(obd_jobid_var, jobid, &jobid_len);\r\nif (rc) {\r\nif (rc == -EOVERFLOW) {\r\nstatic bool printed;\r\nif (unlikely(!printed)) {\r\nLCONSOLE_ERROR_MSG(0x16b, "%s value too large "\r\n"for JobID buffer (%d)\n",\r\nobd_jobid_var, jobid_len);\r\nprinted = true;\r\n}\r\n} else {\r\nCDEBUG((rc == -ENOENT || rc == -EINVAL ||\r\nrc == -EDEADLK) ? D_INFO : D_ERROR,\r\n"Get jobid for (%s) failed: rc = %d\n",\r\nobd_jobid_var, rc);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nint obd_alloc_fail(const void *ptr, const char *name, const char *type,\r\nsize_t size, const char *file, int line)\r\n{\r\nif (ptr == NULL ||\r\n(cfs_rand() & OBD_ALLOC_FAIL_MASK) < obd_alloc_fail_rate) {\r\nCERROR("%s%salloc of %s ("LPU64" bytes) failed at %s:%d\n",\r\nptr ? "force " :"", type, name, (__u64)size, file,\r\nline);\r\nCERROR(LPU64" total bytes and "LPU64" total pages "\r\n"("LPU64" bytes) allocated by Lustre, "\r\n"%d total bytes by LNET\n",\r\nobd_memory_sum(),\r\nobd_pages_sum() << PAGE_CACHE_SHIFT,\r\nobd_pages_sum(),\r\natomic_read(&libcfs_kmemory));\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void obd_data2conn(struct lustre_handle *conn,\r\nstruct obd_ioctl_data *data)\r\n{\r\nmemset(conn, 0, sizeof(*conn));\r\nconn->cookie = data->ioc_cookie;\r\n}\r\nstatic inline void obd_conn2data(struct obd_ioctl_data *data,\r\nstruct lustre_handle *conn)\r\n{\r\ndata->ioc_cookie = conn->cookie;\r\n}\r\nint class_resolve_dev_name(__u32 len, const char *name)\r\n{\r\nint rc;\r\nint dev;\r\nif (!len || !name) {\r\nCERROR("No name passed,!\n");\r\nGOTO(out, rc = -EINVAL);\r\n}\r\nif (name[len - 1] != 0) {\r\nCERROR("Name not nul terminated!\n");\r\nGOTO(out, rc = -EINVAL);\r\n}\r\nCDEBUG(D_IOCTL, "device name %s\n", name);\r\ndev = class_name2dev(name);\r\nif (dev == -1) {\r\nCDEBUG(D_IOCTL, "No device for name %s!\n", name);\r\nGOTO(out, rc = -EINVAL);\r\n}\r\nCDEBUG(D_IOCTL, "device name %s, dev %d\n", name, dev);\r\nrc = dev;\r\nout:\r\nreturn rc;\r\n}\r\nint class_handle_ioctl(unsigned int cmd, unsigned long arg)\r\n{\r\nchar *buf = NULL;\r\nstruct obd_ioctl_data *data;\r\nstruct libcfs_debug_ioctl_data *debug_data;\r\nstruct obd_device *obd = NULL;\r\nint err = 0, len = 0;\r\nif (cmd == LIBCFS_IOC_DEBUG_MASK) {\r\ndebug_data = (struct libcfs_debug_ioctl_data*)arg;\r\nlibcfs_subsystem_debug = debug_data->subs;\r\nlibcfs_debug = debug_data->debug;\r\nreturn 0;\r\n}\r\nCDEBUG(D_IOCTL, "cmd = %x\n", cmd);\r\nif (obd_ioctl_getdata(&buf, &len, (void *)arg)) {\r\nCERROR("OBD ioctl: data error\n");\r\nreturn -EINVAL;\r\n}\r\ndata = (struct obd_ioctl_data *)buf;\r\nswitch (cmd) {\r\ncase OBD_IOC_PROCESS_CFG: {\r\nstruct lustre_cfg *lcfg;\r\nif (!data->ioc_plen1 || !data->ioc_pbuf1) {\r\nCERROR("No config buffer passed!\n");\r\nGOTO(out, err = -EINVAL);\r\n}\r\nOBD_ALLOC(lcfg, data->ioc_plen1);\r\nif (lcfg == NULL)\r\nGOTO(out, err = -ENOMEM);\r\nerr = copy_from_user(lcfg, data->ioc_pbuf1,\r\ndata->ioc_plen1);\r\nif (!err)\r\nerr = lustre_cfg_sanity_check(lcfg, data->ioc_plen1);\r\nif (!err)\r\nerr = class_process_config(lcfg);\r\nOBD_FREE(lcfg, data->ioc_plen1);\r\nGOTO(out, err);\r\n}\r\ncase OBD_GET_VERSION:\r\nif (!data->ioc_inlbuf1) {\r\nCERROR("No buffer passed in ioctl\n");\r\nGOTO(out, err = -EINVAL);\r\n}\r\nif (strlen(BUILD_VERSION) + 1 > data->ioc_inllen1) {\r\nCERROR("ioctl buffer too small to hold version\n");\r\nGOTO(out, err = -EINVAL);\r\n}\r\nmemcpy(data->ioc_bulk, BUILD_VERSION,\r\nstrlen(BUILD_VERSION) + 1);\r\nerr = obd_ioctl_popdata((void *)arg, data, len);\r\nif (err)\r\nerr = -EFAULT;\r\nGOTO(out, err);\r\ncase OBD_IOC_NAME2DEV: {\r\nint dev;\r\ndev = class_resolve_dev_name(data->ioc_inllen1,\r\ndata->ioc_inlbuf1);\r\ndata->ioc_dev = dev;\r\nif (dev < 0)\r\nGOTO(out, err = -EINVAL);\r\nerr = obd_ioctl_popdata((void *)arg, data, sizeof(*data));\r\nif (err)\r\nerr = -EFAULT;\r\nGOTO(out, err);\r\n}\r\ncase OBD_IOC_UUID2DEV: {\r\nint dev;\r\nstruct obd_uuid uuid;\r\nif (!data->ioc_inllen1 || !data->ioc_inlbuf1) {\r\nCERROR("No UUID passed!\n");\r\nGOTO(out, err = -EINVAL);\r\n}\r\nif (data->ioc_inlbuf1[data->ioc_inllen1 - 1] != 0) {\r\nCERROR("UUID not NUL terminated!\n");\r\nGOTO(out, err = -EINVAL);\r\n}\r\nCDEBUG(D_IOCTL, "device name %s\n", data->ioc_inlbuf1);\r\nobd_str2uuid(&uuid, data->ioc_inlbuf1);\r\ndev = class_uuid2dev(&uuid);\r\ndata->ioc_dev = dev;\r\nif (dev == -1) {\r\nCDEBUG(D_IOCTL, "No device for UUID %s!\n",\r\ndata->ioc_inlbuf1);\r\nGOTO(out, err = -EINVAL);\r\n}\r\nCDEBUG(D_IOCTL, "device name %s, dev %d\n", data->ioc_inlbuf1,\r\ndev);\r\nerr = obd_ioctl_popdata((void *)arg, data, sizeof(*data));\r\nif (err)\r\nerr = -EFAULT;\r\nGOTO(out, err);\r\n}\r\ncase OBD_IOC_CLOSE_UUID: {\r\nCDEBUG(D_IOCTL, "closing all connections to uuid %s (NOOP)\n",\r\ndata->ioc_inlbuf1);\r\nGOTO(out, err = 0);\r\n}\r\ncase OBD_IOC_GETDEVICE: {\r\nint index = data->ioc_count;\r\nchar *status, *str;\r\nif (!data->ioc_inlbuf1) {\r\nCERROR("No buffer passed in ioctl\n");\r\nGOTO(out, err = -EINVAL);\r\n}\r\nif (data->ioc_inllen1 < 128) {\r\nCERROR("ioctl buffer too small to hold version\n");\r\nGOTO(out, err = -EINVAL);\r\n}\r\nobd = class_num2obd(index);\r\nif (!obd)\r\nGOTO(out, err = -ENOENT);\r\nif (obd->obd_stopping)\r\nstatus = "ST";\r\nelse if (obd->obd_set_up)\r\nstatus = "UP";\r\nelse if (obd->obd_attached)\r\nstatus = "AT";\r\nelse\r\nstatus = "--";\r\nstr = (char *)data->ioc_bulk;\r\nsnprintf(str, len - sizeof(*data), "%3d %s %s %s %s %d",\r\n(int)index, status, obd->obd_type->typ_name,\r\nobd->obd_name, obd->obd_uuid.uuid,\r\natomic_read(&obd->obd_refcount));\r\nerr = obd_ioctl_popdata((void *)arg, data, len);\r\nGOTO(out, err = 0);\r\n}\r\n}\r\nif (data->ioc_dev == OBD_DEV_BY_DEVNAME) {\r\nif (data->ioc_inllen4 <= 0 || data->ioc_inlbuf4 == NULL)\r\nGOTO(out, err = -EINVAL);\r\nif (strnlen(data->ioc_inlbuf4, MAX_OBD_NAME) >= MAX_OBD_NAME)\r\nGOTO(out, err = -EINVAL);\r\nobd = class_name2obd(data->ioc_inlbuf4);\r\n} else if (data->ioc_dev < class_devno_max()) {\r\nobd = class_num2obd(data->ioc_dev);\r\n} else {\r\nCERROR("OBD ioctl: No device\n");\r\nGOTO(out, err = -EINVAL);\r\n}\r\nif (obd == NULL) {\r\nCERROR("OBD ioctl : No Device %d\n", data->ioc_dev);\r\nGOTO(out, err = -EINVAL);\r\n}\r\nLASSERT(obd->obd_magic == OBD_DEVICE_MAGIC);\r\nif (!obd->obd_set_up || obd->obd_stopping) {\r\nCERROR("OBD ioctl: device not setup %d \n", data->ioc_dev);\r\nGOTO(out, err = -EINVAL);\r\n}\r\nswitch(cmd) {\r\ncase OBD_IOC_NO_TRANSNO: {\r\nif (!obd->obd_attached) {\r\nCERROR("Device %d not attached\n", obd->obd_minor);\r\nGOTO(out, err = -ENODEV);\r\n}\r\nCDEBUG(D_HA, "%s: disabling committed-transno notification\n",\r\nobd->obd_name);\r\nobd->obd_no_transno = 1;\r\nGOTO(out, err = 0);\r\n}\r\ndefault: {\r\nerr = obd_iocontrol(cmd, obd->obd_self_export, len, data, NULL);\r\nif (err)\r\nGOTO(out, err);\r\nerr = obd_ioctl_popdata((void *)arg, data, len);\r\nif (err)\r\nerr = -EFAULT;\r\nGOTO(out, err);\r\n}\r\n}\r\nout:\r\nif (buf)\r\nobd_ioctl_freedata(buf, len);\r\nreturn err;\r\n}\r\nint obd_init_checks(void)\r\n{\r\n__u64 u64val, div64val;\r\nchar buf[64];\r\nint len, ret = 0;\r\nCDEBUG(D_INFO, "LPU64=%s, LPD64=%s, LPX64=%s\n", LPU64, LPD64, LPX64);\r\nCDEBUG(D_INFO, "OBD_OBJECT_EOF = "LPX64"\n", (__u64)OBD_OBJECT_EOF);\r\nu64val = OBD_OBJECT_EOF;\r\nCDEBUG(D_INFO, "u64val OBD_OBJECT_EOF = "LPX64"\n", u64val);\r\nif (u64val != OBD_OBJECT_EOF) {\r\nCERROR("__u64 "LPX64"(%d) != 0xffffffffffffffff\n",\r\nu64val, (int)sizeof(u64val));\r\nret = -EINVAL;\r\n}\r\nlen = snprintf(buf, sizeof(buf), LPX64, u64val);\r\nif (len != 18) {\r\nCWARN("LPX64 wrong length! strlen(%s)=%d != 18\n", buf, len);\r\nret = -EINVAL;\r\n}\r\ndiv64val = OBD_OBJECT_EOF;\r\nCDEBUG(D_INFO, "u64val OBD_OBJECT_EOF = "LPX64"\n", u64val);\r\nif (u64val != OBD_OBJECT_EOF) {\r\nCERROR("__u64 "LPX64"(%d) != 0xffffffffffffffff\n",\r\nu64val, (int)sizeof(u64val));\r\nret = -EOVERFLOW;\r\n}\r\nif (u64val >> 8 != OBD_OBJECT_EOF >> 8) {\r\nCERROR("__u64 "LPX64"(%d) != 0xffffffffffffffff\n",\r\nu64val, (int)sizeof(u64val));\r\nreturn -EOVERFLOW;\r\n}\r\nif (do_div(div64val, 256) != (u64val & 255)) {\r\nCERROR("do_div("LPX64",256) != "LPU64"\n", u64val, u64val &255);\r\nreturn -EOVERFLOW;\r\n}\r\nif (u64val >> 8 != div64val) {\r\nCERROR("do_div("LPX64",256) "LPU64" != "LPU64"\n",\r\nu64val, div64val, u64val >> 8);\r\nreturn -EOVERFLOW;\r\n}\r\nlen = snprintf(buf, sizeof(buf), LPX64, u64val);\r\nif (len != 18) {\r\nCWARN("LPX64 wrong length! strlen(%s)=%d != 18\n", buf, len);\r\nret = -EINVAL;\r\n}\r\nlen = snprintf(buf, sizeof(buf), LPU64, u64val);\r\nif (len != 20) {\r\nCWARN("LPU64 wrong length! strlen(%s)=%d != 20\n", buf, len);\r\nret = -EINVAL;\r\n}\r\nlen = snprintf(buf, sizeof(buf), LPD64, u64val);\r\nif (len != 2) {\r\nCWARN("LPD64 wrong length! strlen(%s)=%d != 2\n", buf, len);\r\nret = -EINVAL;\r\n}\r\nif ((u64val & ~CFS_PAGE_MASK) >= PAGE_CACHE_SIZE) {\r\nCWARN("mask failed: u64val "LPU64" >= "LPU64"\n", u64val,\r\n(__u64)PAGE_CACHE_SIZE);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int class_procfs_init(void)\r\n{ return 0; }\r\nstatic inline int class_procfs_clean(void)\r\n{ return 0; }\r\nstatic int __init init_obdclass(void)\r\n{\r\nint i, err;\r\nint lustre_register_fs(void);\r\nfor (i = CAPA_SITE_CLIENT; i < CAPA_SITE_MAX; i++)\r\nINIT_LIST_HEAD(&capa_list[i]);\r\nLCONSOLE_INFO("Lustre: Build Version: "BUILD_VERSION"\n");\r\nspin_lock_init(&obd_types_lock);\r\nobd_zombie_impexp_init();\r\nobd_memory = lprocfs_alloc_stats(OBD_STATS_NUM,\r\nLPROCFS_STATS_FLAG_NONE |\r\nLPROCFS_STATS_FLAG_IRQ_SAFE);\r\nif (obd_memory == NULL) {\r\nCERROR("kmalloc of 'obd_memory' failed\n");\r\nreturn -ENOMEM;\r\n}\r\nlprocfs_counter_init(obd_memory, OBD_MEMORY_STAT,\r\nLPROCFS_CNTR_AVGMINMAX,\r\n"memused", "bytes");\r\nlprocfs_counter_init(obd_memory, OBD_MEMORY_PAGES_STAT,\r\nLPROCFS_CNTR_AVGMINMAX,\r\n"pagesused", "pages");\r\nerr = obd_init_checks();\r\nif (err == -EOVERFLOW)\r\nreturn err;\r\nclass_init_uuidlist();\r\nerr = class_handle_init();\r\nif (err)\r\nreturn err;\r\nINIT_LIST_HEAD(&obd_types);\r\nerr = misc_register(&obd_psdev);\r\nif (err) {\r\nCERROR("cannot register %d err %d\n", OBD_DEV_MINOR, err);\r\nreturn err;\r\n}\r\nfor (i = 0; i < class_devno_max(); i++)\r\nobd_devs[i] = NULL;\r\nif (totalram_pages <= 512 << (20 - PAGE_CACHE_SHIFT))\r\nobd_max_dirty_pages = totalram_pages / 4;\r\nelse\r\nobd_max_dirty_pages = totalram_pages / 2;\r\nerr = obd_init_caches();\r\nif (err)\r\nreturn err;\r\nobd_sysctl_init();\r\nerr = class_procfs_init();\r\nif (err)\r\nreturn err;\r\nerr = lu_global_init();\r\nif (err)\r\nreturn err;\r\nerr = cl_global_init();\r\nif (err != 0)\r\nreturn err;\r\nerr = llog_info_init();\r\nif (err)\r\nreturn err;\r\nerr = lustre_register_fs();\r\nreturn err;\r\n}\r\nvoid obd_update_maxusage(void)\r\n{\r\n__u64 max1, max2;\r\nmax1 = obd_pages_sum();\r\nmax2 = obd_memory_sum();\r\nspin_lock(&obd_updatemax_lock);\r\nif (max1 > obd_max_pages)\r\nobd_max_pages = max1;\r\nif (max2 > obd_max_alloc)\r\nobd_max_alloc = max2;\r\nspin_unlock(&obd_updatemax_lock);\r\n}\r\n__u64 obd_memory_max(void)\r\n{\r\n__u64 ret;\r\nspin_lock(&obd_updatemax_lock);\r\nret = obd_max_alloc;\r\nspin_unlock(&obd_updatemax_lock);\r\nreturn ret;\r\n}\r\n__u64 obd_pages_max(void)\r\n{\r\n__u64 ret;\r\nspin_lock(&obd_updatemax_lock);\r\nret = obd_max_pages;\r\nspin_unlock(&obd_updatemax_lock);\r\nreturn ret;\r\n}\r\nstatic void cleanup_obdclass(void)\r\n{\r\nint i;\r\nint lustre_unregister_fs(void);\r\n__u64 memory_leaked, pages_leaked;\r\n__u64 memory_max, pages_max;\r\nlustre_unregister_fs();\r\nmisc_deregister(&obd_psdev);\r\nfor (i = 0; i < class_devno_max(); i++) {\r\nstruct obd_device *obd = class_num2obd(i);\r\nif (obd && obd->obd_set_up &&\r\nOBT(obd) && OBP(obd, detach)) {\r\nLASSERT(obd->obd_magic == OBD_DEVICE_MAGIC);\r\nOBP(obd, detach)(obd);\r\n}\r\n}\r\nllog_info_fini();\r\ncl_global_fini();\r\nlu_global_fini();\r\nobd_cleanup_caches();\r\nobd_sysctl_clean();\r\nclass_procfs_clean();\r\nclass_handle_cleanup();\r\nclass_exit_uuidlist();\r\nobd_zombie_impexp_stop();\r\nmemory_leaked = obd_memory_sum();\r\npages_leaked = obd_pages_sum();\r\nmemory_max = obd_memory_max();\r\npages_max = obd_pages_max();\r\nlprocfs_free_stats(&obd_memory);\r\nCDEBUG((memory_leaked) ? D_ERROR : D_INFO,\r\n"obd_memory max: "LPU64", leaked: "LPU64"\n",\r\nmemory_max, memory_leaked);\r\nCDEBUG((pages_leaked) ? D_ERROR : D_INFO,\r\n"obd_memory_pages max: "LPU64", leaked: "LPU64"\n",\r\npages_max, pages_leaked);\r\n}
