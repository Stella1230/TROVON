bool usb_acpi_power_manageable(struct usb_device *hdev, int index)\r\n{\r\nacpi_handle port_handle;\r\nint port1 = index + 1;\r\nport_handle = usb_get_hub_port_acpi_handle(hdev,\r\nport1);\r\nif (port_handle)\r\nreturn acpi_bus_power_manageable(port_handle);\r\nelse\r\nreturn false;\r\n}\r\nint usb_acpi_set_power_state(struct usb_device *hdev, int index, bool enable)\r\n{\r\nacpi_handle port_handle;\r\nunsigned char state;\r\nint port1 = index + 1;\r\nint error = -EINVAL;\r\nport_handle = (acpi_handle)usb_get_hub_port_acpi_handle(hdev,\r\nport1);\r\nif (!port_handle)\r\nreturn error;\r\nif (enable)\r\nstate = ACPI_STATE_D0;\r\nelse\r\nstate = ACPI_STATE_D3_COLD;\r\nerror = acpi_bus_set_power(port_handle, state);\r\nif (!error)\r\ndev_dbg(&hdev->dev, "The power of hub port %d was set to %d\n",\r\nport1, enable);\r\nelse\r\ndev_dbg(&hdev->dev, "The power of hub port failed to be set\n");\r\nreturn error;\r\n}\r\nstatic int usb_acpi_check_port_connect_type(struct usb_device *hdev,\r\nacpi_handle handle, int port1)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *upc;\r\nstruct acpi_pld_info *pld;\r\nint ret = 0;\r\nstatus = acpi_get_physical_device_location(handle, &pld);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nstatus = acpi_evaluate_object(handle, "_UPC", NULL, &buffer);\r\nupc = buffer.pointer;\r\nif (!upc || (upc->type != ACPI_TYPE_PACKAGE)\r\n|| upc->package.count != 4) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (upc->package.elements[0].integer.value)\r\nif (pld->user_visible)\r\nusb_set_hub_port_connect_type(hdev, port1,\r\nUSB_PORT_CONNECT_TYPE_HOT_PLUG);\r\nelse\r\nusb_set_hub_port_connect_type(hdev, port1,\r\nUSB_PORT_CONNECT_TYPE_HARD_WIRED);\r\nelse if (!pld->user_visible)\r\nusb_set_hub_port_connect_type(hdev, port1, USB_PORT_NOT_USED);\r\nout:\r\nACPI_FREE(pld);\r\nkfree(upc);\r\nreturn ret;\r\n}\r\nstatic struct acpi_device *usb_acpi_find_companion(struct device *dev)\r\n{\r\nstruct usb_device *udev;\r\nacpi_handle *parent_handle;\r\nint port_num;\r\nif (is_usb_device(dev)) {\r\nudev = to_usb_device(dev);\r\nif (udev->parent) {\r\nenum usb_port_connect_type type;\r\ntype = usb_get_hub_port_connect_type(udev->parent,\r\nudev->portnum);\r\nswitch (type) {\r\ncase USB_PORT_CONNECT_TYPE_HOT_PLUG:\r\nudev->removable = USB_DEVICE_REMOVABLE;\r\nbreak;\r\ncase USB_PORT_CONNECT_TYPE_HARD_WIRED:\r\nudev->removable = USB_DEVICE_FIXED;\r\nbreak;\r\ndefault:\r\nudev->removable = USB_DEVICE_REMOVABLE_UNKNOWN;\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nreturn acpi_find_child_device(ACPI_COMPANION(dev->parent),\r\nudev->portnum, false);\r\n} else if (is_usb_port(dev)) {\r\nstruct acpi_device *adev = NULL;\r\nsscanf(dev_name(dev), "port%d", &port_num);\r\nudev = to_usb_device(dev->parent->parent);\r\nif (!udev->parent) {\r\nstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\r\nint raw_port_num;\r\nraw_port_num = usb_hcd_find_raw_port_number(hcd,\r\nport_num);\r\nadev = acpi_find_child_device(ACPI_COMPANION(&udev->dev),\r\nraw_port_num, false);\r\nif (!adev)\r\nreturn NULL;\r\n} else {\r\nparent_handle =\r\nusb_get_hub_port_acpi_handle(udev->parent,\r\nudev->portnum);\r\nif (!parent_handle)\r\nreturn NULL;\r\nacpi_bus_get_device(parent_handle, &adev);\r\nadev = acpi_find_child_device(adev, port_num, false);\r\nif (!adev)\r\nreturn NULL;\r\n}\r\nusb_acpi_check_port_connect_type(udev, adev->handle, port_num);\r\nreturn adev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool usb_acpi_bus_match(struct device *dev)\r\n{\r\nreturn is_usb_device(dev) || is_usb_port(dev);\r\n}\r\nint usb_acpi_register(void)\r\n{\r\nreturn register_acpi_bus_type(&usb_acpi_bus);\r\n}\r\nvoid usb_acpi_unregister(void)\r\n{\r\nunregister_acpi_bus_type(&usb_acpi_bus);\r\n}
