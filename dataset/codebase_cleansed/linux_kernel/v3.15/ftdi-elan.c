static void ftdi_elan_delete(struct kref *kref)\r\n{\r\nstruct usb_ftdi *ftdi = kref_to_usb_ftdi(kref);\r\ndev_warn(&ftdi->udev->dev, "FREEING ftdi=%p\n", ftdi);\r\nusb_put_dev(ftdi->udev);\r\nftdi->disconnected += 1;\r\nmutex_lock(&ftdi_module_lock);\r\nlist_del_init(&ftdi->ftdi_list);\r\nftdi_instances -= 1;\r\nmutex_unlock(&ftdi_module_lock);\r\nkfree(ftdi->bulk_in_buffer);\r\nftdi->bulk_in_buffer = NULL;\r\n}\r\nstatic void ftdi_elan_put_kref(struct usb_ftdi *ftdi)\r\n{\r\nkref_put(&ftdi->kref, ftdi_elan_delete);\r\n}\r\nstatic void ftdi_elan_get_kref(struct usb_ftdi *ftdi)\r\n{\r\nkref_get(&ftdi->kref);\r\n}\r\nstatic void ftdi_elan_init_kref(struct usb_ftdi *ftdi)\r\n{\r\nkref_init(&ftdi->kref);\r\n}\r\nstatic void ftdi_status_requeue_work(struct usb_ftdi *ftdi, unsigned int delta)\r\n{\r\nif (!queue_delayed_work(status_queue, &ftdi->status_work, delta))\r\nkref_put(&ftdi->kref, ftdi_elan_delete);\r\n}\r\nstatic void ftdi_status_queue_work(struct usb_ftdi *ftdi, unsigned int delta)\r\n{\r\nif (queue_delayed_work(status_queue, &ftdi->status_work, delta))\r\nkref_get(&ftdi->kref);\r\n}\r\nstatic void ftdi_status_cancel_work(struct usb_ftdi *ftdi)\r\n{\r\nif (cancel_delayed_work(&ftdi->status_work))\r\nkref_put(&ftdi->kref, ftdi_elan_delete);\r\n}\r\nstatic void ftdi_command_requeue_work(struct usb_ftdi *ftdi, unsigned int delta)\r\n{\r\nif (!queue_delayed_work(command_queue, &ftdi->command_work, delta))\r\nkref_put(&ftdi->kref, ftdi_elan_delete);\r\n}\r\nstatic void ftdi_command_queue_work(struct usb_ftdi *ftdi, unsigned int delta)\r\n{\r\nif (queue_delayed_work(command_queue, &ftdi->command_work, delta))\r\nkref_get(&ftdi->kref);\r\n}\r\nstatic void ftdi_command_cancel_work(struct usb_ftdi *ftdi)\r\n{\r\nif (cancel_delayed_work(&ftdi->command_work))\r\nkref_put(&ftdi->kref, ftdi_elan_delete);\r\n}\r\nstatic void ftdi_response_requeue_work(struct usb_ftdi *ftdi,\r\nunsigned int delta)\r\n{\r\nif (!queue_delayed_work(respond_queue, &ftdi->respond_work, delta))\r\nkref_put(&ftdi->kref, ftdi_elan_delete);\r\n}\r\nstatic void ftdi_respond_queue_work(struct usb_ftdi *ftdi, unsigned int delta)\r\n{\r\nif (queue_delayed_work(respond_queue, &ftdi->respond_work, delta))\r\nkref_get(&ftdi->kref);\r\n}\r\nstatic void ftdi_response_cancel_work(struct usb_ftdi *ftdi)\r\n{\r\nif (cancel_delayed_work(&ftdi->respond_work))\r\nkref_put(&ftdi->kref, ftdi_elan_delete);\r\n}\r\nvoid ftdi_elan_gone_away(struct platform_device *pdev)\r\n{\r\nstruct usb_ftdi *ftdi = platform_device_to_usb_ftdi(pdev);\r\nftdi->gone_away += 1;\r\nftdi_elan_put_kref(ftdi);\r\n}\r\nstatic void ftdi_release_platform_dev(struct device *dev)\r\n{\r\ndev->parent = NULL;\r\n}\r\nstatic int ftdi_elan_hcd_init(struct usb_ftdi *ftdi)\r\n{\r\nint result;\r\nif (ftdi->platform_dev.dev.parent)\r\nreturn -EBUSY;\r\nftdi_elan_get_kref(ftdi);\r\nftdi->platform_data.potpg = 100;\r\nftdi->platform_data.reset = NULL;\r\nftdi->platform_dev.id = ftdi->sequence_num;\r\nftdi->platform_dev.resource = ftdi->resources;\r\nftdi->platform_dev.num_resources = ARRAY_SIZE(ftdi->resources);\r\nftdi->platform_dev.dev.platform_data = &ftdi->platform_data;\r\nftdi->platform_dev.dev.parent = NULL;\r\nftdi->platform_dev.dev.release = ftdi_release_platform_dev;\r\nftdi->platform_dev.dev.dma_mask = NULL;\r\nsnprintf(ftdi->device_name, sizeof(ftdi->device_name), "u132_hcd");\r\nftdi->platform_dev.name = ftdi->device_name;\r\ndev_info(&ftdi->udev->dev, "requesting module '%s'\n", "u132_hcd");\r\nrequest_module("u132_hcd");\r\ndev_info(&ftdi->udev->dev, "registering '%s'\n",\r\nftdi->platform_dev.name);\r\nresult = platform_device_register(&ftdi->platform_dev);\r\nreturn result;\r\n}\r\nstatic void ftdi_elan_abandon_completions(struct usb_ftdi *ftdi)\r\n{\r\nmutex_lock(&ftdi->u132_lock);\r\nwhile (ftdi->respond_next > ftdi->respond_head) {\r\nstruct u132_respond *respond = &ftdi->respond[RESPOND_MASK &\r\nftdi->respond_head++];\r\n*respond->result = -ESHUTDOWN;\r\n*respond->value = 0;\r\ncomplete(&respond->wait_completion);\r\n} mutex_unlock(&ftdi->u132_lock);\r\n}\r\nstatic void ftdi_elan_abandon_targets(struct usb_ftdi *ftdi)\r\n{\r\nint ed_number = 4;\r\nmutex_lock(&ftdi->u132_lock);\r\nwhile (ed_number-- > 0) {\r\nstruct u132_target *target = &ftdi->target[ed_number];\r\nif (target->active == 1) {\r\ntarget->condition_code = TD_DEVNOTRESP;\r\nmutex_unlock(&ftdi->u132_lock);\r\nftdi_elan_do_callback(ftdi, target, NULL, 0);\r\nmutex_lock(&ftdi->u132_lock);\r\n}\r\n}\r\nftdi->received = 0;\r\nftdi->expected = 4;\r\nftdi->ed_found = 0;\r\nmutex_unlock(&ftdi->u132_lock);\r\n}\r\nstatic void ftdi_elan_flush_targets(struct usb_ftdi *ftdi)\r\n{\r\nint ed_number = 4;\r\nmutex_lock(&ftdi->u132_lock);\r\nwhile (ed_number-- > 0) {\r\nstruct u132_target *target = &ftdi->target[ed_number];\r\ntarget->abandoning = 1;\r\nwait_1:if (target->active == 1) {\r\nint command_size = ftdi->command_next -\r\nftdi->command_head;\r\nif (command_size < COMMAND_SIZE) {\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\ncommand->header = 0x80 | (ed_number << 5) | 0x4;\r\ncommand->length = 0x00;\r\ncommand->address = 0x00;\r\ncommand->width = 0x00;\r\ncommand->follows = 0;\r\ncommand->value = 0;\r\ncommand->buffer = &command->value;\r\nftdi->command_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\nmutex_lock(&ftdi->u132_lock);\r\ngoto wait_1;\r\n}\r\n}\r\nwait_2:if (target->active == 1) {\r\nint command_size = ftdi->command_next -\r\nftdi->command_head;\r\nif (command_size < COMMAND_SIZE) {\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\ncommand->header = 0x90 | (ed_number << 5);\r\ncommand->length = 0x00;\r\ncommand->address = 0x00;\r\ncommand->width = 0x00;\r\ncommand->follows = 0;\r\ncommand->value = 0;\r\ncommand->buffer = &command->value;\r\nftdi->command_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\nmutex_lock(&ftdi->u132_lock);\r\ngoto wait_2;\r\n}\r\n}\r\n}\r\nftdi->received = 0;\r\nftdi->expected = 4;\r\nftdi->ed_found = 0;\r\nmutex_unlock(&ftdi->u132_lock);\r\n}\r\nstatic void ftdi_elan_cancel_targets(struct usb_ftdi *ftdi)\r\n{\r\nint ed_number = 4;\r\nmutex_lock(&ftdi->u132_lock);\r\nwhile (ed_number-- > 0) {\r\nstruct u132_target *target = &ftdi->target[ed_number];\r\ntarget->abandoning = 1;\r\nwait:if (target->active == 1) {\r\nint command_size = ftdi->command_next -\r\nftdi->command_head;\r\nif (command_size < COMMAND_SIZE) {\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\ncommand->header = 0x80 | (ed_number << 5) | 0x4;\r\ncommand->length = 0x00;\r\ncommand->address = 0x00;\r\ncommand->width = 0x00;\r\ncommand->follows = 0;\r\ncommand->value = 0;\r\ncommand->buffer = &command->value;\r\nftdi->command_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\nmutex_lock(&ftdi->u132_lock);\r\ngoto wait;\r\n}\r\n}\r\n}\r\nftdi->received = 0;\r\nftdi->expected = 4;\r\nftdi->ed_found = 0;\r\nmutex_unlock(&ftdi->u132_lock);\r\n}\r\nstatic void ftdi_elan_kick_command_queue(struct usb_ftdi *ftdi)\r\n{\r\nftdi_command_queue_work(ftdi, 0);\r\n}\r\nstatic void ftdi_elan_command_work(struct work_struct *work)\r\n{\r\nstruct usb_ftdi *ftdi =\r\ncontainer_of(work, struct usb_ftdi, command_work.work);\r\nif (ftdi->disconnected > 0) {\r\nftdi_elan_put_kref(ftdi);\r\nreturn;\r\n} else {\r\nint retval = ftdi_elan_command_engine(ftdi);\r\nif (retval == -ESHUTDOWN) {\r\nftdi->disconnected += 1;\r\n} else if (retval == -ENODEV) {\r\nftdi->disconnected += 1;\r\n} else if (retval)\r\ndev_err(&ftdi->udev->dev, "command error %d\n", retval);\r\nftdi_command_requeue_work(ftdi, msecs_to_jiffies(10));\r\nreturn;\r\n}\r\n}\r\nstatic void ftdi_elan_kick_respond_queue(struct usb_ftdi *ftdi)\r\n{\r\nftdi_respond_queue_work(ftdi, 0);\r\n}\r\nstatic void ftdi_elan_respond_work(struct work_struct *work)\r\n{\r\nstruct usb_ftdi *ftdi =\r\ncontainer_of(work, struct usb_ftdi, respond_work.work);\r\nif (ftdi->disconnected > 0) {\r\nftdi_elan_put_kref(ftdi);\r\nreturn;\r\n} else {\r\nint retval = ftdi_elan_respond_engine(ftdi);\r\nif (retval == 0) {\r\n} else if (retval == -ESHUTDOWN) {\r\nftdi->disconnected += 1;\r\n} else if (retval == -ENODEV) {\r\nftdi->disconnected += 1;\r\n} else if (retval == -EILSEQ) {\r\nftdi->disconnected += 1;\r\n} else {\r\nftdi->disconnected += 1;\r\ndev_err(&ftdi->udev->dev, "respond error %d\n", retval);\r\n}\r\nif (ftdi->disconnected > 0) {\r\nftdi_elan_abandon_completions(ftdi);\r\nftdi_elan_abandon_targets(ftdi);\r\n}\r\nftdi_response_requeue_work(ftdi, msecs_to_jiffies(10));\r\nreturn;\r\n}\r\n}\r\nstatic void ftdi_elan_status_work(struct work_struct *work)\r\n{\r\nstruct usb_ftdi *ftdi =\r\ncontainer_of(work, struct usb_ftdi, status_work.work);\r\nint work_delay_in_msec = 0;\r\nif (ftdi->disconnected > 0) {\r\nftdi_elan_put_kref(ftdi);\r\nreturn;\r\n} else if (ftdi->synchronized == 0) {\r\ndown(&ftdi->sw_lock);\r\nif (ftdi_elan_synchronize(ftdi) == 0) {\r\nftdi->synchronized = 1;\r\nftdi_command_queue_work(ftdi, 1);\r\nftdi_respond_queue_work(ftdi, 1);\r\nup(&ftdi->sw_lock);\r\nwork_delay_in_msec = 100;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "synchronize failed\n");\r\nup(&ftdi->sw_lock);\r\nwork_delay_in_msec = 10 *1000;\r\n}\r\n} else if (ftdi->stuck_status > 0) {\r\nif (ftdi_elan_stuck_waiting(ftdi) == 0) {\r\nftdi->stuck_status = 0;\r\nftdi->synchronized = 0;\r\n} else if ((ftdi->stuck_status++ % 60) == 1) {\r\ndev_err(&ftdi->udev->dev, "WRONG type of card inserted "\r\n"- please remove\n");\r\n} else\r\ndev_err(&ftdi->udev->dev, "WRONG type of card inserted "\r\n"- checked %d times\n", ftdi->stuck_status);\r\nwork_delay_in_msec = 100;\r\n} else if (ftdi->enumerated == 0) {\r\nif (ftdi_elan_enumeratePCI(ftdi) == 0) {\r\nftdi->enumerated = 1;\r\nwork_delay_in_msec = 250;\r\n} else\r\nwork_delay_in_msec = 1000;\r\n} else if (ftdi->initialized == 0) {\r\nif (ftdi_elan_setupOHCI(ftdi) == 0) {\r\nftdi->initialized = 1;\r\nwork_delay_in_msec = 500;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "initialized failed - trying "\r\n"again in 10 seconds\n");\r\nwork_delay_in_msec = 1 *1000;\r\n}\r\n} else if (ftdi->registered == 0) {\r\nwork_delay_in_msec = 10;\r\nif (ftdi_elan_hcd_init(ftdi) == 0) {\r\nftdi->registered = 1;\r\n} else\r\ndev_err(&ftdi->udev->dev, "register failed\n");\r\nwork_delay_in_msec = 250;\r\n} else {\r\nif (ftdi_elan_checkingPCI(ftdi) == 0) {\r\nwork_delay_in_msec = 250;\r\n} else if (ftdi->controlreg & 0x00400000) {\r\nif (ftdi->gone_away > 0) {\r\ndev_err(&ftdi->udev->dev, "PCI device eject con"\r\n"firmed platform_dev.dev.parent=%p plat"\r\n"form_dev.dev=%p\n",\r\nftdi->platform_dev.dev.parent,\r\n&ftdi->platform_dev.dev);\r\nplatform_device_unregister(&ftdi->platform_dev);\r\nftdi->platform_dev.dev.parent = NULL;\r\nftdi->registered = 0;\r\nftdi->enumerated = 0;\r\nftdi->card_ejected = 0;\r\nftdi->initialized = 0;\r\nftdi->gone_away = 0;\r\n} else\r\nftdi_elan_flush_targets(ftdi);\r\nwork_delay_in_msec = 250;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "PCI device has disappeared\n"\r\n);\r\nftdi_elan_cancel_targets(ftdi);\r\nwork_delay_in_msec = 500;\r\nftdi->enumerated = 0;\r\nftdi->initialized = 0;\r\n}\r\n}\r\nif (ftdi->disconnected > 0) {\r\nftdi_elan_put_kref(ftdi);\r\nreturn;\r\n} else {\r\nftdi_status_requeue_work(ftdi,\r\nmsecs_to_jiffies(work_delay_in_msec));\r\nreturn;\r\n}\r\n}\r\nstatic int ftdi_elan_open(struct inode *inode, struct file *file)\r\n{\r\nint subminor;\r\nstruct usb_interface *interface;\r\nsubminor = iminor(inode);\r\ninterface = usb_find_interface(&ftdi_elan_driver, subminor);\r\nif (!interface) {\r\nprintk(KERN_ERR "can't find device for minor %d\n", subminor);\r\nreturn -ENODEV;\r\n} else {\r\nstruct usb_ftdi *ftdi = usb_get_intfdata(interface);\r\nif (!ftdi) {\r\nreturn -ENODEV;\r\n} else {\r\nif (down_interruptible(&ftdi->sw_lock)) {\r\nreturn -EINTR;\r\n} else {\r\nftdi_elan_get_kref(ftdi);\r\nfile->private_data = ftdi;\r\nreturn 0;\r\n}\r\n}\r\n}\r\n}\r\nstatic int ftdi_elan_release(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_ftdi *ftdi = file->private_data;\r\nif (ftdi == NULL)\r\nreturn -ENODEV;\r\nup(&ftdi->sw_lock);\r\nftdi_elan_put_kref(ftdi);\r\nreturn 0;\r\n}\r\nstatic ssize_t ftdi_elan_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar data[30 *3 + 4];\r\nchar *d = data;\r\nint m = (sizeof(data) - 1) / 3;\r\nint bytes_read = 0;\r\nint retry_on_empty = 10;\r\nint retry_on_timeout = 5;\r\nstruct usb_ftdi *ftdi = file->private_data;\r\nif (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n}\r\ndata[0] = 0;\r\nhave:if (ftdi->bulk_in_left > 0) {\r\nif (count-- > 0) {\r\nchar *p = ++ftdi->bulk_in_last + ftdi->bulk_in_buffer;\r\nftdi->bulk_in_left -= 1;\r\nif (bytes_read < m) {\r\nd += sprintf(d, " %02X", 0x000000FF & *p);\r\n} else if (bytes_read > m) {\r\n} else\r\nd += sprintf(d, " ..");\r\nif (copy_to_user(buffer++, p, 1)) {\r\nreturn -EFAULT;\r\n} else {\r\nbytes_read += 1;\r\ngoto have;\r\n}\r\n} else\r\nreturn bytes_read;\r\n}\r\nmore:if (count > 0) {\r\nint packet_bytes = 0;\r\nint retval = usb_bulk_msg(ftdi->udev,\r\nusb_rcvbulkpipe(ftdi->udev, ftdi->bulk_in_endpointAddr),\r\nftdi->bulk_in_buffer, ftdi->bulk_in_size,\r\n&packet_bytes, 50);\r\nif (packet_bytes > 2) {\r\nftdi->bulk_in_left = packet_bytes - 2;\r\nftdi->bulk_in_last = 1;\r\ngoto have;\r\n} else if (retval == -ETIMEDOUT) {\r\nif (retry_on_timeout-- > 0) {\r\ngoto more;\r\n} else if (bytes_read > 0) {\r\nreturn bytes_read;\r\n} else\r\nreturn retval;\r\n} else if (retval == 0) {\r\nif (retry_on_empty-- > 0) {\r\ngoto more;\r\n} else\r\nreturn bytes_read;\r\n} else\r\nreturn retval;\r\n} else\r\nreturn bytes_read;\r\n}\r\nstatic void ftdi_elan_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_ftdi *ftdi = urb->context;\r\nint status = urb->status;\r\nif (status && !(status == -ENOENT || status == -ECONNRESET ||\r\nstatus == -ESHUTDOWN)) {\r\ndev_err(&ftdi->udev->dev, "urb=%p write bulk status received: %"\r\n"d\n", urb, status);\r\n}\r\nusb_free_coherent(urb->dev, urb->transfer_buffer_length,\r\nurb->transfer_buffer, urb->transfer_dma);\r\n}\r\nstatic int fill_buffer_with_all_queued_commands(struct usb_ftdi *ftdi,\r\nchar *buf, int command_size, int total_size)\r\n{\r\nint ed_commands = 0;\r\nint b = 0;\r\nint I = command_size;\r\nint i = ftdi->command_head;\r\nwhile (I-- > 0) {\r\nstruct u132_command *command = &ftdi->command[COMMAND_MASK &\r\ni++];\r\nint F = command->follows;\r\nu8 *f = command->buffer;\r\nif (command->header & 0x80) {\r\ned_commands |= 1 << (0x3 & (command->header >> 5));\r\n}\r\nbuf[b++] = command->header;\r\nbuf[b++] = (command->length >> 0) & 0x00FF;\r\nbuf[b++] = (command->length >> 8) & 0x00FF;\r\nbuf[b++] = command->address;\r\nbuf[b++] = command->width;\r\nwhile (F-- > 0) {\r\nbuf[b++] = *f++;\r\n}\r\n}\r\nreturn ed_commands;\r\n}\r\nstatic int ftdi_elan_total_command_size(struct usb_ftdi *ftdi, int command_size)\r\n{\r\nint total_size = 0;\r\nint I = command_size;\r\nint i = ftdi->command_head;\r\nwhile (I-- > 0) {\r\nstruct u132_command *command = &ftdi->command[COMMAND_MASK &\r\ni++];\r\ntotal_size += 5 + command->follows;\r\n} return total_size;\r\n}\r\nstatic int ftdi_elan_command_engine(struct usb_ftdi *ftdi)\r\n{\r\nint retval;\r\nchar *buf;\r\nint ed_commands;\r\nint total_size;\r\nstruct urb *urb;\r\nint command_size = ftdi->command_next - ftdi->command_head;\r\nif (command_size == 0)\r\nreturn 0;\r\ntotal_size = ftdi_elan_total_command_size(ftdi, command_size);\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\ndev_err(&ftdi->udev->dev, "could not get a urb to write %d comm"\r\n"ands totaling %d bytes to the Uxxx\n", command_size,\r\ntotal_size);\r\nreturn -ENOMEM;\r\n}\r\nbuf = usb_alloc_coherent(ftdi->udev, total_size, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\ndev_err(&ftdi->udev->dev, "could not get a buffer to write %d c"\r\n"ommands totaling %d bytes to the Uxxx\n", command_size,\r\ntotal_size);\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\ned_commands = fill_buffer_with_all_queued_commands(ftdi, buf,\r\ncommand_size, total_size);\r\nusb_fill_bulk_urb(urb, ftdi->udev, usb_sndbulkpipe(ftdi->udev,\r\nftdi->bulk_out_endpointAddr), buf, total_size,\r\nftdi_elan_write_bulk_callback, ftdi);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nif (ed_commands) {\r\nchar diag[40 *3 + 4];\r\nchar *d = diag;\r\nint m = total_size;\r\nu8 *c = buf;\r\nint s = (sizeof(diag) - 1) / 3;\r\ndiag[0] = 0;\r\nwhile (s-- > 0 && m-- > 0) {\r\nif (s > 0 || m == 0) {\r\nd += sprintf(d, " %02X", *c++);\r\n} else\r\nd += sprintf(d, " ..");\r\n}\r\n}\r\nretval = usb_submit_urb(urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&ftdi->udev->dev, "failed %d to submit urb %p to write "\r\n"%d commands totaling %d bytes to the Uxxx\n", retval,\r\nurb, command_size, total_size);\r\nusb_free_coherent(ftdi->udev, total_size, buf, urb->transfer_dma);\r\nusb_free_urb(urb);\r\nreturn retval;\r\n}\r\nusb_free_urb(urb);\r\nftdi->command_head += command_size;\r\nftdi_elan_kick_respond_queue(ftdi);\r\nreturn 0;\r\n}\r\nstatic void ftdi_elan_do_callback(struct usb_ftdi *ftdi,\r\nstruct u132_target *target, u8 *buffer, int length)\r\n{\r\nstruct urb *urb = target->urb;\r\nint halted = target->halted;\r\nint skipped = target->skipped;\r\nint actual = target->actual;\r\nint non_null = target->non_null;\r\nint toggle_bits = target->toggle_bits;\r\nint error_count = target->error_count;\r\nint condition_code = target->condition_code;\r\nint repeat_number = target->repeat_number;\r\nvoid (*callback) (void *, struct urb *, u8 *, int, int, int, int, int,\r\nint, int, int, int) = target->callback;\r\ntarget->active -= 1;\r\ntarget->callback = NULL;\r\n(*callback) (target->endp, urb, buffer, length, toggle_bits,\r\nerror_count, condition_code, repeat_number, halted, skipped,\r\nactual, non_null);\r\n}\r\nstatic char *have_ed_set_response(struct usb_ftdi *ftdi,\r\nstruct u132_target *target, u16 ed_length, int ed_number, int ed_type,\r\nchar *b)\r\n{\r\nint payload = (ed_length >> 0) & 0x07FF;\r\nmutex_lock(&ftdi->u132_lock);\r\ntarget->actual = 0;\r\ntarget->non_null = (ed_length >> 15) & 0x0001;\r\ntarget->repeat_number = (ed_length >> 11) & 0x000F;\r\nif (ed_type == 0x02) {\r\nif (payload == 0 || target->abandoning > 0) {\r\ntarget->abandoning = 0;\r\nmutex_unlock(&ftdi->u132_lock);\r\nftdi_elan_do_callback(ftdi, target, 4 + ftdi->response,\r\npayload);\r\nftdi->received = 0;\r\nftdi->expected = 4;\r\nftdi->ed_found = 0;\r\nreturn ftdi->response;\r\n} else {\r\nftdi->expected = 4 + payload;\r\nftdi->ed_found = 1;\r\nmutex_unlock(&ftdi->u132_lock);\r\nreturn b;\r\n}\r\n} else if (ed_type == 0x03) {\r\nif (payload == 0 || target->abandoning > 0) {\r\ntarget->abandoning = 0;\r\nmutex_unlock(&ftdi->u132_lock);\r\nftdi_elan_do_callback(ftdi, target, 4 + ftdi->response,\r\npayload);\r\nftdi->received = 0;\r\nftdi->expected = 4;\r\nftdi->ed_found = 0;\r\nreturn ftdi->response;\r\n} else {\r\nftdi->expected = 4 + payload;\r\nftdi->ed_found = 1;\r\nmutex_unlock(&ftdi->u132_lock);\r\nreturn b;\r\n}\r\n} else if (ed_type == 0x01) {\r\ntarget->abandoning = 0;\r\nmutex_unlock(&ftdi->u132_lock);\r\nftdi_elan_do_callback(ftdi, target, 4 + ftdi->response,\r\npayload);\r\nftdi->received = 0;\r\nftdi->expected = 4;\r\nftdi->ed_found = 0;\r\nreturn ftdi->response;\r\n} else {\r\ntarget->abandoning = 0;\r\nmutex_unlock(&ftdi->u132_lock);\r\nftdi_elan_do_callback(ftdi, target, 4 + ftdi->response,\r\npayload);\r\nftdi->received = 0;\r\nftdi->expected = 4;\r\nftdi->ed_found = 0;\r\nreturn ftdi->response;\r\n}\r\n}\r\nstatic char *have_ed_get_response(struct usb_ftdi *ftdi,\r\nstruct u132_target *target, u16 ed_length, int ed_number, int ed_type,\r\nchar *b)\r\n{\r\nmutex_lock(&ftdi->u132_lock);\r\ntarget->condition_code = TD_DEVNOTRESP;\r\ntarget->actual = (ed_length >> 0) & 0x01FF;\r\ntarget->non_null = (ed_length >> 15) & 0x0001;\r\ntarget->repeat_number = (ed_length >> 11) & 0x000F;\r\nmutex_unlock(&ftdi->u132_lock);\r\nif (target->active)\r\nftdi_elan_do_callback(ftdi, target, NULL, 0);\r\ntarget->abandoning = 0;\r\nftdi->received = 0;\r\nftdi->expected = 4;\r\nftdi->ed_found = 0;\r\nreturn ftdi->response;\r\n}\r\nstatic int ftdi_elan_respond_engine(struct usb_ftdi *ftdi)\r\n{\r\nu8 *b = ftdi->response + ftdi->received;\r\nint bytes_read = 0;\r\nint retry_on_empty = 1;\r\nint retry_on_timeout = 3;\r\nint empty_packets = 0;\r\nread:{\r\nint packet_bytes = 0;\r\nint retval = usb_bulk_msg(ftdi->udev,\r\nusb_rcvbulkpipe(ftdi->udev, ftdi->bulk_in_endpointAddr),\r\nftdi->bulk_in_buffer, ftdi->bulk_in_size,\r\n&packet_bytes, 500);\r\nchar diag[30 *3 + 4];\r\nchar *d = diag;\r\nint m = packet_bytes;\r\nu8 *c = ftdi->bulk_in_buffer;\r\nint s = (sizeof(diag) - 1) / 3;\r\ndiag[0] = 0;\r\nwhile (s-- > 0 && m-- > 0) {\r\nif (s > 0 || m == 0) {\r\nd += sprintf(d, " %02X", *c++);\r\n} else\r\nd += sprintf(d, " ..");\r\n}\r\nif (packet_bytes > 2) {\r\nftdi->bulk_in_left = packet_bytes - 2;\r\nftdi->bulk_in_last = 1;\r\ngoto have;\r\n} else if (retval == -ETIMEDOUT) {\r\nif (retry_on_timeout-- > 0) {\r\ndev_err(&ftdi->udev->dev, "TIMED OUT with packe"\r\n"t_bytes = %d with total %d bytes%s\n",\r\npacket_bytes, bytes_read, diag);\r\ngoto more;\r\n} else if (bytes_read > 0) {\r\ndev_err(&ftdi->udev->dev, "ONLY %d bytes%s\n",\r\nbytes_read, diag);\r\nreturn -ENOMEM;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "TIMED OUT with packe"\r\n"t_bytes = %d with total %d bytes%s\n",\r\npacket_bytes, bytes_read, diag);\r\nreturn -ENOMEM;\r\n}\r\n} else if (retval == -EILSEQ) {\r\ndev_err(&ftdi->udev->dev, "error = %d with packet_bytes"\r\n" = %d with total %d bytes%s\n", retval,\r\npacket_bytes, bytes_read, diag);\r\nreturn retval;\r\n} else if (retval) {\r\ndev_err(&ftdi->udev->dev, "error = %d with packet_bytes"\r\n" = %d with total %d bytes%s\n", retval,\r\npacket_bytes, bytes_read, diag);\r\nreturn retval;\r\n} else if (packet_bytes == 2) {\r\nunsigned char s0 = ftdi->bulk_in_buffer[0];\r\nunsigned char s1 = ftdi->bulk_in_buffer[1];\r\nempty_packets += 1;\r\nif (s0 == 0x31 && s1 == 0x60) {\r\nif (retry_on_empty-- > 0) {\r\ngoto more;\r\n} else\r\nreturn 0;\r\n} else if (s0 == 0x31 && s1 == 0x00) {\r\nif (retry_on_empty-- > 0) {\r\ngoto more;\r\n} else\r\nreturn 0;\r\n} else {\r\nif (retry_on_empty-- > 0) {\r\ngoto more;\r\n} else\r\nreturn 0;\r\n}\r\n} else if (packet_bytes == 1) {\r\nif (retry_on_empty-- > 0) {\r\ngoto more;\r\n} else\r\nreturn 0;\r\n} else {\r\nif (retry_on_empty-- > 0) {\r\ngoto more;\r\n} else\r\nreturn 0;\r\n}\r\n}\r\nmore:{\r\ngoto read;\r\n}\r\nhave:if (ftdi->bulk_in_left > 0) {\r\nu8 c = ftdi->bulk_in_buffer[++ftdi->bulk_in_last];\r\nbytes_read += 1;\r\nftdi->bulk_in_left -= 1;\r\nif (ftdi->received == 0 && c == 0xFF) {\r\ngoto have;\r\n} else\r\n*b++ = c;\r\nif (++ftdi->received < ftdi->expected) {\r\ngoto have;\r\n} else if (ftdi->ed_found) {\r\nint ed_number = (ftdi->response[0] >> 5) & 0x03;\r\nu16 ed_length = (ftdi->response[2] << 8) |\r\nftdi->response[1];\r\nstruct u132_target *target = &ftdi->target[ed_number];\r\nint payload = (ed_length >> 0) & 0x07FF;\r\nchar diag[30 *3 + 4];\r\nchar *d = diag;\r\nint m = payload;\r\nu8 *c = 4 + ftdi->response;\r\nint s = (sizeof(diag) - 1) / 3;\r\ndiag[0] = 0;\r\nwhile (s-- > 0 && m-- > 0) {\r\nif (s > 0 || m == 0) {\r\nd += sprintf(d, " %02X", *c++);\r\n} else\r\nd += sprintf(d, " ..");\r\n}\r\nftdi_elan_do_callback(ftdi, target, 4 + ftdi->response,\r\npayload);\r\nftdi->received = 0;\r\nftdi->expected = 4;\r\nftdi->ed_found = 0;\r\nb = ftdi->response;\r\ngoto have;\r\n} else if (ftdi->expected == 8) {\r\nu8 buscmd;\r\nint respond_head = ftdi->respond_head++;\r\nstruct u132_respond *respond = &ftdi->respond[\r\nRESPOND_MASK & respond_head];\r\nu32 data = ftdi->response[7];\r\ndata <<= 8;\r\ndata |= ftdi->response[6];\r\ndata <<= 8;\r\ndata |= ftdi->response[5];\r\ndata <<= 8;\r\ndata |= ftdi->response[4];\r\n*respond->value = data;\r\n*respond->result = 0;\r\ncomplete(&respond->wait_completion);\r\nftdi->received = 0;\r\nftdi->expected = 4;\r\nftdi->ed_found = 0;\r\nb = ftdi->response;\r\nbuscmd = (ftdi->response[0] >> 0) & 0x0F;\r\nif (buscmd == 0x00) {\r\n} else if (buscmd == 0x02) {\r\n} else if (buscmd == 0x06) {\r\n} else if (buscmd == 0x0A) {\r\n} else\r\ndev_err(&ftdi->udev->dev, "Uxxx unknown(%0X) va"\r\n"lue = %08X\n", buscmd, data);\r\ngoto have;\r\n} else {\r\nif ((ftdi->response[0] & 0x80) == 0x00) {\r\nftdi->expected = 8;\r\ngoto have;\r\n} else {\r\nint ed_number = (ftdi->response[0] >> 5) & 0x03;\r\nint ed_type = (ftdi->response[0] >> 0) & 0x03;\r\nu16 ed_length = (ftdi->response[2] << 8) |\r\nftdi->response[1];\r\nstruct u132_target *target = &ftdi->target[\r\ned_number];\r\ntarget->halted = (ftdi->response[0] >> 3) &\r\n0x01;\r\ntarget->skipped = (ftdi->response[0] >> 2) &\r\n0x01;\r\ntarget->toggle_bits = (ftdi->response[3] >> 6)\r\n& 0x03;\r\ntarget->error_count = (ftdi->response[3] >> 4)\r\n& 0x03;\r\ntarget->condition_code = (ftdi->response[\r\n3] >> 0) & 0x0F;\r\nif ((ftdi->response[0] & 0x10) == 0x00) {\r\nb = have_ed_set_response(ftdi, target,\r\ned_length, ed_number, ed_type,\r\nb);\r\ngoto have;\r\n} else {\r\nb = have_ed_get_response(ftdi, target,\r\ned_length, ed_number, ed_type,\r\nb);\r\ngoto have;\r\n}\r\n}\r\n}\r\n} else\r\ngoto more;\r\n}\r\nstatic ssize_t ftdi_elan_write(struct file *file,\r\nconst char __user *user_buffer, size_t count,\r\nloff_t *ppos)\r\n{\r\nint retval = 0;\r\nstruct urb *urb;\r\nchar *buf;\r\nstruct usb_ftdi *ftdi = file->private_data;\r\nif (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n}\r\nif (count == 0) {\r\ngoto exit;\r\n}\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nretval = -ENOMEM;\r\ngoto error_1;\r\n}\r\nbuf = usb_alloc_coherent(ftdi->udev, count, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\nretval = -ENOMEM;\r\ngoto error_2;\r\n}\r\nif (copy_from_user(buf, user_buffer, count)) {\r\nretval = -EFAULT;\r\ngoto error_3;\r\n}\r\nusb_fill_bulk_urb(urb, ftdi->udev, usb_sndbulkpipe(ftdi->udev,\r\nftdi->bulk_out_endpointAddr), buf, count,\r\nftdi_elan_write_bulk_callback, ftdi);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nretval = usb_submit_urb(urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&ftdi->udev->dev, "failed submitting write urb, error %"\r\n"d\n", retval);\r\ngoto error_3;\r\n}\r\nusb_free_urb(urb);\r\nexit:\r\nreturn count;\r\nerror_3:\r\nusb_free_coherent(ftdi->udev, count, buf, urb->transfer_dma);\r\nerror_2:\r\nusb_free_urb(urb);\r\nerror_1:\r\nreturn retval;\r\n}\r\nstatic int ftdi_elan_write_reg(struct usb_ftdi *ftdi, u32 data)\r\n{\r\nwait:if (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n} else {\r\nint command_size;\r\nmutex_lock(&ftdi->u132_lock);\r\ncommand_size = ftdi->command_next - ftdi->command_head;\r\nif (command_size < COMMAND_SIZE) {\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\ncommand->header = 0x00 | cPCIu132wr;\r\ncommand->length = 0x04;\r\ncommand->address = 0x00;\r\ncommand->width = 0x00;\r\ncommand->follows = 4;\r\ncommand->value = data;\r\ncommand->buffer = &command->value;\r\nftdi->command_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\nmutex_unlock(&ftdi->u132_lock);\r\nreturn 0;\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\ngoto wait;\r\n}\r\n}\r\n}\r\nstatic int ftdi_elan_write_config(struct usb_ftdi *ftdi, int config_offset,\r\nu8 width, u32 data)\r\n{\r\nu8 addressofs = config_offset / 4;\r\nwait:if (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n} else {\r\nint command_size;\r\nmutex_lock(&ftdi->u132_lock);\r\ncommand_size = ftdi->command_next - ftdi->command_head;\r\nif (command_size < COMMAND_SIZE) {\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\ncommand->header = 0x00 | (cPCIcfgwr & 0x0F);\r\ncommand->length = 0x04;\r\ncommand->address = addressofs;\r\ncommand->width = 0x00 | (width & 0x0F);\r\ncommand->follows = 4;\r\ncommand->value = data;\r\ncommand->buffer = &command->value;\r\nftdi->command_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\nmutex_unlock(&ftdi->u132_lock);\r\nreturn 0;\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\ngoto wait;\r\n}\r\n}\r\n}\r\nstatic int ftdi_elan_write_pcimem(struct usb_ftdi *ftdi, int mem_offset,\r\nu8 width, u32 data)\r\n{\r\nu8 addressofs = mem_offset / 4;\r\nwait:if (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n} else {\r\nint command_size;\r\nmutex_lock(&ftdi->u132_lock);\r\ncommand_size = ftdi->command_next - ftdi->command_head;\r\nif (command_size < COMMAND_SIZE) {\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\ncommand->header = 0x00 | (cPCImemwr & 0x0F);\r\ncommand->length = 0x04;\r\ncommand->address = addressofs;\r\ncommand->width = 0x00 | (width & 0x0F);\r\ncommand->follows = 4;\r\ncommand->value = data;\r\ncommand->buffer = &command->value;\r\nftdi->command_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\nmutex_unlock(&ftdi->u132_lock);\r\nreturn 0;\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\ngoto wait;\r\n}\r\n}\r\n}\r\nint usb_ftdi_elan_write_pcimem(struct platform_device *pdev, int mem_offset,\r\nu8 width, u32 data)\r\n{\r\nstruct usb_ftdi *ftdi = platform_device_to_usb_ftdi(pdev);\r\nreturn ftdi_elan_write_pcimem(ftdi, mem_offset, width, data);\r\n}\r\nstatic int ftdi_elan_read_reg(struct usb_ftdi *ftdi, u32 *data)\r\n{\r\nwait:if (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n} else {\r\nint command_size;\r\nint respond_size;\r\nmutex_lock(&ftdi->u132_lock);\r\ncommand_size = ftdi->command_next - ftdi->command_head;\r\nrespond_size = ftdi->respond_next - ftdi->respond_head;\r\nif (command_size < COMMAND_SIZE && respond_size < RESPOND_SIZE)\r\n{\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\nstruct u132_respond *respond = &ftdi->respond[\r\nRESPOND_MASK & ftdi->respond_next];\r\nint result = -ENODEV;\r\nrespond->result = &result;\r\nrespond->header = command->header = 0x00 | cPCIu132rd;\r\ncommand->length = 0x04;\r\nrespond->address = command->address = cU132cmd_status;\r\ncommand->width = 0x00;\r\ncommand->follows = 0;\r\ncommand->value = 0;\r\ncommand->buffer = NULL;\r\nrespond->value = data;\r\ninit_completion(&respond->wait_completion);\r\nftdi->command_next += 1;\r\nftdi->respond_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\nmutex_unlock(&ftdi->u132_lock);\r\nwait_for_completion(&respond->wait_completion);\r\nreturn result;\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\ngoto wait;\r\n}\r\n}\r\n}\r\nstatic int ftdi_elan_read_config(struct usb_ftdi *ftdi, int config_offset,\r\nu8 width, u32 *data)\r\n{\r\nu8 addressofs = config_offset / 4;\r\nwait:if (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n} else {\r\nint command_size;\r\nint respond_size;\r\nmutex_lock(&ftdi->u132_lock);\r\ncommand_size = ftdi->command_next - ftdi->command_head;\r\nrespond_size = ftdi->respond_next - ftdi->respond_head;\r\nif (command_size < COMMAND_SIZE && respond_size < RESPOND_SIZE)\r\n{\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\nstruct u132_respond *respond = &ftdi->respond[\r\nRESPOND_MASK & ftdi->respond_next];\r\nint result = -ENODEV;\r\nrespond->result = &result;\r\nrespond->header = command->header = 0x00 | (cPCIcfgrd &\r\n0x0F);\r\ncommand->length = 0x04;\r\nrespond->address = command->address = addressofs;\r\ncommand->width = 0x00 | (width & 0x0F);\r\ncommand->follows = 0;\r\ncommand->value = 0;\r\ncommand->buffer = NULL;\r\nrespond->value = data;\r\ninit_completion(&respond->wait_completion);\r\nftdi->command_next += 1;\r\nftdi->respond_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\nmutex_unlock(&ftdi->u132_lock);\r\nwait_for_completion(&respond->wait_completion);\r\nreturn result;\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\ngoto wait;\r\n}\r\n}\r\n}\r\nstatic int ftdi_elan_read_pcimem(struct usb_ftdi *ftdi, int mem_offset,\r\nu8 width, u32 *data)\r\n{\r\nu8 addressofs = mem_offset / 4;\r\nwait:if (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n} else {\r\nint command_size;\r\nint respond_size;\r\nmutex_lock(&ftdi->u132_lock);\r\ncommand_size = ftdi->command_next - ftdi->command_head;\r\nrespond_size = ftdi->respond_next - ftdi->respond_head;\r\nif (command_size < COMMAND_SIZE && respond_size < RESPOND_SIZE)\r\n{\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\nstruct u132_respond *respond = &ftdi->respond[\r\nRESPOND_MASK & ftdi->respond_next];\r\nint result = -ENODEV;\r\nrespond->result = &result;\r\nrespond->header = command->header = 0x00 | (cPCImemrd &\r\n0x0F);\r\ncommand->length = 0x04;\r\nrespond->address = command->address = addressofs;\r\ncommand->width = 0x00 | (width & 0x0F);\r\ncommand->follows = 0;\r\ncommand->value = 0;\r\ncommand->buffer = NULL;\r\nrespond->value = data;\r\ninit_completion(&respond->wait_completion);\r\nftdi->command_next += 1;\r\nftdi->respond_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\nmutex_unlock(&ftdi->u132_lock);\r\nwait_for_completion(&respond->wait_completion);\r\nreturn result;\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\ngoto wait;\r\n}\r\n}\r\n}\r\nint usb_ftdi_elan_read_pcimem(struct platform_device *pdev, int mem_offset,\r\nu8 width, u32 *data)\r\n{\r\nstruct usb_ftdi *ftdi = platform_device_to_usb_ftdi(pdev);\r\nif (ftdi->initialized == 0) {\r\nreturn -ENODEV;\r\n} else\r\nreturn ftdi_elan_read_pcimem(ftdi, mem_offset, width, data);\r\n}\r\nstatic int ftdi_elan_edset_setup(struct usb_ftdi *ftdi, u8 ed_number,\r\nvoid *endp, struct urb *urb, u8 address, u8 ep_number, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nu8 ed = ed_number - 1;\r\nwait:if (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n} else if (ftdi->initialized == 0) {\r\nreturn -ENODEV;\r\n} else {\r\nint command_size;\r\nmutex_lock(&ftdi->u132_lock);\r\ncommand_size = ftdi->command_next - ftdi->command_head;\r\nif (command_size < COMMAND_SIZE) {\r\nstruct u132_target *target = &ftdi->target[ed];\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\ncommand->header = 0x80 | (ed << 5);\r\ncommand->length = 0x8007;\r\ncommand->address = (toggle_bits << 6) | (ep_number << 2)\r\n| (address << 0);\r\ncommand->width = usb_maxpacket(urb->dev, urb->pipe,\r\nusb_pipeout(urb->pipe));\r\ncommand->follows = 8;\r\ncommand->value = 0;\r\ncommand->buffer = urb->setup_packet;\r\ntarget->callback = callback;\r\ntarget->endp = endp;\r\ntarget->urb = urb;\r\ntarget->active = 1;\r\nftdi->command_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\nmutex_unlock(&ftdi->u132_lock);\r\nreturn 0;\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\ngoto wait;\r\n}\r\n}\r\n}\r\nint usb_ftdi_elan_edset_setup(struct platform_device *pdev, u8 ed_number,\r\nvoid *endp, struct urb *urb, u8 address, u8 ep_number, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nstruct usb_ftdi *ftdi = platform_device_to_usb_ftdi(pdev);\r\nreturn ftdi_elan_edset_setup(ftdi, ed_number, endp, urb, address,\r\nep_number, toggle_bits, callback);\r\n}\r\nstatic int ftdi_elan_edset_input(struct usb_ftdi *ftdi, u8 ed_number,\r\nvoid *endp, struct urb *urb, u8 address, u8 ep_number, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nu8 ed = ed_number - 1;\r\nwait:if (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n} else if (ftdi->initialized == 0) {\r\nreturn -ENODEV;\r\n} else {\r\nint command_size;\r\nmutex_lock(&ftdi->u132_lock);\r\ncommand_size = ftdi->command_next - ftdi->command_head;\r\nif (command_size < COMMAND_SIZE) {\r\nstruct u132_target *target = &ftdi->target[ed];\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\nu32 remaining_length = urb->transfer_buffer_length -\r\nurb->actual_length;\r\ncommand->header = 0x82 | (ed << 5);\r\nif (remaining_length == 0) {\r\ncommand->length = 0x0000;\r\n} else if (remaining_length > 1024) {\r\ncommand->length = 0x8000 | 1023;\r\n} else\r\ncommand->length = 0x8000 | (remaining_length -\r\n1);\r\ncommand->address = (toggle_bits << 6) | (ep_number << 2)\r\n| (address << 0);\r\ncommand->width = usb_maxpacket(urb->dev, urb->pipe,\r\nusb_pipeout(urb->pipe));\r\ncommand->follows = 0;\r\ncommand->value = 0;\r\ncommand->buffer = NULL;\r\ntarget->callback = callback;\r\ntarget->endp = endp;\r\ntarget->urb = urb;\r\ntarget->active = 1;\r\nftdi->command_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\nmutex_unlock(&ftdi->u132_lock);\r\nreturn 0;\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\ngoto wait;\r\n}\r\n}\r\n}\r\nint usb_ftdi_elan_edset_input(struct platform_device *pdev, u8 ed_number,\r\nvoid *endp, struct urb *urb, u8 address, u8 ep_number, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nstruct usb_ftdi *ftdi = platform_device_to_usb_ftdi(pdev);\r\nreturn ftdi_elan_edset_input(ftdi, ed_number, endp, urb, address,\r\nep_number, toggle_bits, callback);\r\n}\r\nstatic int ftdi_elan_edset_empty(struct usb_ftdi *ftdi, u8 ed_number,\r\nvoid *endp, struct urb *urb, u8 address, u8 ep_number, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nu8 ed = ed_number - 1;\r\nwait:if (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n} else if (ftdi->initialized == 0) {\r\nreturn -ENODEV;\r\n} else {\r\nint command_size;\r\nmutex_lock(&ftdi->u132_lock);\r\ncommand_size = ftdi->command_next - ftdi->command_head;\r\nif (command_size < COMMAND_SIZE) {\r\nstruct u132_target *target = &ftdi->target[ed];\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\ncommand->header = 0x81 | (ed << 5);\r\ncommand->length = 0x0000;\r\ncommand->address = (toggle_bits << 6) | (ep_number << 2)\r\n| (address << 0);\r\ncommand->width = usb_maxpacket(urb->dev, urb->pipe,\r\nusb_pipeout(urb->pipe));\r\ncommand->follows = 0;\r\ncommand->value = 0;\r\ncommand->buffer = NULL;\r\ntarget->callback = callback;\r\ntarget->endp = endp;\r\ntarget->urb = urb;\r\ntarget->active = 1;\r\nftdi->command_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\nmutex_unlock(&ftdi->u132_lock);\r\nreturn 0;\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\ngoto wait;\r\n}\r\n}\r\n}\r\nint usb_ftdi_elan_edset_empty(struct platform_device *pdev, u8 ed_number,\r\nvoid *endp, struct urb *urb, u8 address, u8 ep_number, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nstruct usb_ftdi *ftdi = platform_device_to_usb_ftdi(pdev);\r\nreturn ftdi_elan_edset_empty(ftdi, ed_number, endp, urb, address,\r\nep_number, toggle_bits, callback);\r\n}\r\nstatic int ftdi_elan_edset_output(struct usb_ftdi *ftdi, u8 ed_number,\r\nvoid *endp, struct urb *urb, u8 address, u8 ep_number, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nu8 ed = ed_number - 1;\r\nwait:if (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n} else if (ftdi->initialized == 0) {\r\nreturn -ENODEV;\r\n} else {\r\nint command_size;\r\nmutex_lock(&ftdi->u132_lock);\r\ncommand_size = ftdi->command_next - ftdi->command_head;\r\nif (command_size < COMMAND_SIZE) {\r\nu8 *b;\r\nu16 urb_size;\r\nint i = 0;\r\nchar data[30 *3 + 4];\r\nchar *d = data;\r\nint m = (sizeof(data) - 1) / 3;\r\nint l = 0;\r\nstruct u132_target *target = &ftdi->target[ed];\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\ncommand->header = 0x81 | (ed << 5);\r\ncommand->address = (toggle_bits << 6) | (ep_number << 2)\r\n| (address << 0);\r\ncommand->width = usb_maxpacket(urb->dev, urb->pipe,\r\nusb_pipeout(urb->pipe));\r\ncommand->follows = min_t(u32, 1024,\r\nurb->transfer_buffer_length -\r\nurb->actual_length);\r\ncommand->value = 0;\r\ncommand->buffer = urb->transfer_buffer +\r\nurb->actual_length;\r\ncommand->length = 0x8000 | (command->follows - 1);\r\nb = command->buffer;\r\nurb_size = command->follows;\r\ndata[0] = 0;\r\nwhile (urb_size-- > 0) {\r\nif (i > m) {\r\n} else if (i++ < m) {\r\nint w = sprintf(d, " %02X", *b++);\r\nd += w;\r\nl += w;\r\n} else\r\nd += sprintf(d, " ..");\r\n}\r\ntarget->callback = callback;\r\ntarget->endp = endp;\r\ntarget->urb = urb;\r\ntarget->active = 1;\r\nftdi->command_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\nmutex_unlock(&ftdi->u132_lock);\r\nreturn 0;\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\ngoto wait;\r\n}\r\n}\r\n}\r\nint usb_ftdi_elan_edset_output(struct platform_device *pdev, u8 ed_number,\r\nvoid *endp, struct urb *urb, u8 address, u8 ep_number, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nstruct usb_ftdi *ftdi = platform_device_to_usb_ftdi(pdev);\r\nreturn ftdi_elan_edset_output(ftdi, ed_number, endp, urb, address,\r\nep_number, toggle_bits, callback);\r\n}\r\nstatic int ftdi_elan_edset_single(struct usb_ftdi *ftdi, u8 ed_number,\r\nvoid *endp, struct urb *urb, u8 address, u8 ep_number, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nu8 ed = ed_number - 1;\r\nwait:if (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n} else if (ftdi->initialized == 0) {\r\nreturn -ENODEV;\r\n} else {\r\nint command_size;\r\nmutex_lock(&ftdi->u132_lock);\r\ncommand_size = ftdi->command_next - ftdi->command_head;\r\nif (command_size < COMMAND_SIZE) {\r\nu32 remaining_length = urb->transfer_buffer_length -\r\nurb->actual_length;\r\nstruct u132_target *target = &ftdi->target[ed];\r\nstruct u132_command *command = &ftdi->command[\r\nCOMMAND_MASK & ftdi->command_next];\r\ncommand->header = 0x83 | (ed << 5);\r\nif (remaining_length == 0) {\r\ncommand->length = 0x0000;\r\n} else if (remaining_length > 1024) {\r\ncommand->length = 0x8000 | 1023;\r\n} else\r\ncommand->length = 0x8000 | (remaining_length -\r\n1);\r\ncommand->address = (toggle_bits << 6) | (ep_number << 2)\r\n| (address << 0);\r\ncommand->width = usb_maxpacket(urb->dev, urb->pipe,\r\nusb_pipeout(urb->pipe));\r\ncommand->follows = 0;\r\ncommand->value = 0;\r\ncommand->buffer = NULL;\r\ntarget->callback = callback;\r\ntarget->endp = endp;\r\ntarget->urb = urb;\r\ntarget->active = 1;\r\nftdi->command_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\nmutex_unlock(&ftdi->u132_lock);\r\nreturn 0;\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\ngoto wait;\r\n}\r\n}\r\n}\r\nint usb_ftdi_elan_edset_single(struct platform_device *pdev, u8 ed_number,\r\nvoid *endp, struct urb *urb, u8 address, u8 ep_number, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nstruct usb_ftdi *ftdi = platform_device_to_usb_ftdi(pdev);\r\nreturn ftdi_elan_edset_single(ftdi, ed_number, endp, urb, address,\r\nep_number, toggle_bits, callback);\r\n}\r\nstatic int ftdi_elan_edset_flush(struct usb_ftdi *ftdi, u8 ed_number,\r\nvoid *endp)\r\n{\r\nu8 ed = ed_number - 1;\r\nif (ftdi->disconnected > 0) {\r\nreturn -ENODEV;\r\n} else if (ftdi->initialized == 0) {\r\nreturn -ENODEV;\r\n} else {\r\nstruct u132_target *target = &ftdi->target[ed];\r\nmutex_lock(&ftdi->u132_lock);\r\nif (target->abandoning > 0) {\r\nmutex_unlock(&ftdi->u132_lock);\r\nreturn 0;\r\n} else {\r\ntarget->abandoning = 1;\r\nwait_1:if (target->active == 1) {\r\nint command_size = ftdi->command_next -\r\nftdi->command_head;\r\nif (command_size < COMMAND_SIZE) {\r\nstruct u132_command *command =\r\n&ftdi->command[COMMAND_MASK &\r\nftdi->command_next];\r\ncommand->header = 0x80 | (ed << 5) |\r\n0x4;\r\ncommand->length = 0x00;\r\ncommand->address = 0x00;\r\ncommand->width = 0x00;\r\ncommand->follows = 0;\r\ncommand->value = 0;\r\ncommand->buffer = &command->value;\r\nftdi->command_next += 1;\r\nftdi_elan_kick_command_queue(ftdi);\r\n} else {\r\nmutex_unlock(&ftdi->u132_lock);\r\nmsleep(100);\r\nmutex_lock(&ftdi->u132_lock);\r\ngoto wait_1;\r\n}\r\n}\r\nmutex_unlock(&ftdi->u132_lock);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nint usb_ftdi_elan_edset_flush(struct platform_device *pdev, u8 ed_number,\r\nvoid *endp)\r\n{\r\nstruct usb_ftdi *ftdi = platform_device_to_usb_ftdi(pdev);\r\nreturn ftdi_elan_edset_flush(ftdi, ed_number, endp);\r\n}\r\nstatic int ftdi_elan_flush_input_fifo(struct usb_ftdi *ftdi)\r\n{\r\nint retry_on_empty = 10;\r\nint retry_on_timeout = 5;\r\nint retry_on_status = 20;\r\nmore:{\r\nint packet_bytes = 0;\r\nint retval = usb_bulk_msg(ftdi->udev,\r\nusb_rcvbulkpipe(ftdi->udev, ftdi->bulk_in_endpointAddr),\r\nftdi->bulk_in_buffer, ftdi->bulk_in_size,\r\n&packet_bytes, 100);\r\nif (packet_bytes > 2) {\r\nchar diag[30 *3 + 4];\r\nchar *d = diag;\r\nint m = (sizeof(diag) - 1) / 3;\r\nchar *b = ftdi->bulk_in_buffer;\r\nint bytes_read = 0;\r\ndiag[0] = 0;\r\nwhile (packet_bytes-- > 0) {\r\nchar c = *b++;\r\nif (bytes_read < m) {\r\nd += sprintf(d, " %02X",\r\n0x000000FF & c);\r\n} else if (bytes_read > m) {\r\n} else\r\nd += sprintf(d, " ..");\r\nbytes_read += 1;\r\ncontinue;\r\n}\r\ngoto more;\r\n} else if (packet_bytes > 1) {\r\nchar s1 = ftdi->bulk_in_buffer[0];\r\nchar s2 = ftdi->bulk_in_buffer[1];\r\nif (s1 == 0x31 && s2 == 0x60) {\r\nreturn 0;\r\n} else if (retry_on_status-- > 0) {\r\ngoto more;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "STATUS ERROR retry l"\r\n"imit reached\n");\r\nreturn -EFAULT;\r\n}\r\n} else if (packet_bytes > 0) {\r\nchar b1 = ftdi->bulk_in_buffer[0];\r\ndev_err(&ftdi->udev->dev, "only one byte flushed from F"\r\n"TDI = %02X\n", b1);\r\nif (retry_on_status-- > 0) {\r\ngoto more;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "STATUS ERROR retry l"\r\n"imit reached\n");\r\nreturn -EFAULT;\r\n}\r\n} else if (retval == -ETIMEDOUT) {\r\nif (retry_on_timeout-- > 0) {\r\ngoto more;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "TIMED OUT retry limi"\r\n"t reached\n");\r\nreturn -ENOMEM;\r\n}\r\n} else if (retval == 0) {\r\nif (retry_on_empty-- > 0) {\r\ngoto more;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "empty packet retry l"\r\n"imit reached\n");\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\ndev_err(&ftdi->udev->dev, "error = %d\n", retval);\r\nreturn retval;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int ftdi_elan_synchronize_flush(struct usb_ftdi *ftdi)\r\n{\r\nint retval;\r\nstruct urb *urb;\r\nchar *buf;\r\nint I = 257;\r\nint i = 0;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\ndev_err(&ftdi->udev->dev, "could not alloc a urb for flush sequ"\r\n"ence\n");\r\nreturn -ENOMEM;\r\n}\r\nbuf = usb_alloc_coherent(ftdi->udev, I, GFP_KERNEL, &urb->transfer_dma);\r\nif (!buf) {\r\ndev_err(&ftdi->udev->dev, "could not get a buffer for flush seq"\r\n"uence\n");\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\nwhile (I-- > 0)\r\nbuf[i++] = 0x55;\r\nusb_fill_bulk_urb(urb, ftdi->udev, usb_sndbulkpipe(ftdi->udev,\r\nftdi->bulk_out_endpointAddr), buf, i,\r\nftdi_elan_write_bulk_callback, ftdi);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nretval = usb_submit_urb(urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&ftdi->udev->dev, "failed to submit urb containing the "\r\n"flush sequence\n");\r\nusb_free_coherent(ftdi->udev, i, buf, urb->transfer_dma);\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\nusb_free_urb(urb);\r\nreturn 0;\r\n}\r\nstatic int ftdi_elan_synchronize_reset(struct usb_ftdi *ftdi)\r\n{\r\nint retval;\r\nstruct urb *urb;\r\nchar *buf;\r\nint I = 4;\r\nint i = 0;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\ndev_err(&ftdi->udev->dev, "could not get a urb for the reset se"\r\n"quence\n");\r\nreturn -ENOMEM;\r\n}\r\nbuf = usb_alloc_coherent(ftdi->udev, I, GFP_KERNEL, &urb->transfer_dma);\r\nif (!buf) {\r\ndev_err(&ftdi->udev->dev, "could not get a buffer for the reset"\r\n" sequence\n");\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\nbuf[i++] = 0x55;\r\nbuf[i++] = 0xAA;\r\nbuf[i++] = 0x5A;\r\nbuf[i++] = 0xA5;\r\nusb_fill_bulk_urb(urb, ftdi->udev, usb_sndbulkpipe(ftdi->udev,\r\nftdi->bulk_out_endpointAddr), buf, i,\r\nftdi_elan_write_bulk_callback, ftdi);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nretval = usb_submit_urb(urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&ftdi->udev->dev, "failed to submit urb containing the "\r\n"reset sequence\n");\r\nusb_free_coherent(ftdi->udev, i, buf, urb->transfer_dma);\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\nusb_free_urb(urb);\r\nreturn 0;\r\n}\r\nstatic int ftdi_elan_synchronize(struct usb_ftdi *ftdi)\r\n{\r\nint retval;\r\nint long_stop = 10;\r\nint retry_on_timeout = 5;\r\nint retry_on_empty = 10;\r\nint err_count = 0;\r\nretval = ftdi_elan_flush_input_fifo(ftdi);\r\nif (retval)\r\nreturn retval;\r\nftdi->bulk_in_left = 0;\r\nftdi->bulk_in_last = -1;\r\nwhile (long_stop-- > 0) {\r\nint read_stop;\r\nint read_stuck;\r\nretval = ftdi_elan_synchronize_flush(ftdi);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_elan_flush_input_fifo(ftdi);\r\nif (retval)\r\nreturn retval;\r\nreset:retval = ftdi_elan_synchronize_reset(ftdi);\r\nif (retval)\r\nreturn retval;\r\nread_stop = 100;\r\nread_stuck = 10;\r\nread:{\r\nint packet_bytes = 0;\r\nretval = usb_bulk_msg(ftdi->udev,\r\nusb_rcvbulkpipe(ftdi->udev,\r\nftdi->bulk_in_endpointAddr),\r\nftdi->bulk_in_buffer, ftdi->bulk_in_size,\r\n&packet_bytes, 500);\r\nif (packet_bytes > 2) {\r\nchar diag[30 *3 + 4];\r\nchar *d = diag;\r\nint m = (sizeof(diag) - 1) / 3;\r\nchar *b = ftdi->bulk_in_buffer;\r\nint bytes_read = 0;\r\nunsigned char c = 0;\r\ndiag[0] = 0;\r\nwhile (packet_bytes-- > 0) {\r\nc = *b++;\r\nif (bytes_read < m) {\r\nd += sprintf(d, " %02X", c);\r\n} else if (bytes_read > m) {\r\n} else\r\nd += sprintf(d, " ..");\r\nbytes_read += 1;\r\ncontinue;\r\n}\r\nif (c == 0x7E) {\r\nreturn 0;\r\n} else {\r\nif (c == 0x55) {\r\ngoto read;\r\n} else if (read_stop-- > 0) {\r\ngoto read;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "retr"\r\n"y limit reached\n");\r\ncontinue;\r\n}\r\n}\r\n} else if (packet_bytes > 1) {\r\nunsigned char s1 = ftdi->bulk_in_buffer[0];\r\nunsigned char s2 = ftdi->bulk_in_buffer[1];\r\nif (s1 == 0x31 && s2 == 0x00) {\r\nif (read_stuck-- > 0) {\r\ngoto read;\r\n} else\r\ngoto reset;\r\n} else if (s1 == 0x31 && s2 == 0x60) {\r\nif (read_stop-- > 0) {\r\ngoto read;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "retr"\r\n"y limit reached\n");\r\ncontinue;\r\n}\r\n} else {\r\nif (read_stop-- > 0) {\r\ngoto read;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "retr"\r\n"y limit reached\n");\r\ncontinue;\r\n}\r\n}\r\n} else if (packet_bytes > 0) {\r\nif (read_stop-- > 0) {\r\ngoto read;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "retry limit "\r\n"reached\n");\r\ncontinue;\r\n}\r\n} else if (retval == -ETIMEDOUT) {\r\nif (retry_on_timeout-- > 0) {\r\ngoto read;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "TIMED OUT re"\r\n"try limit reached\n");\r\ncontinue;\r\n}\r\n} else if (retval == 0) {\r\nif (retry_on_empty-- > 0) {\r\ngoto read;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "empty packet"\r\n" retry limit reached\n");\r\ncontinue;\r\n}\r\n} else {\r\nerr_count += 1;\r\ndev_err(&ftdi->udev->dev, "error = %d\n",\r\nretval);\r\nif (read_stop-- > 0) {\r\ngoto read;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "retry limit "\r\n"reached\n");\r\ncontinue;\r\n}\r\n}\r\n}\r\n}\r\ndev_err(&ftdi->udev->dev, "failed to synchronize\n");\r\nreturn -EFAULT;\r\n}\r\nstatic int ftdi_elan_stuck_waiting(struct usb_ftdi *ftdi)\r\n{\r\nint retry_on_empty = 10;\r\nint retry_on_timeout = 5;\r\nint retry_on_status = 50;\r\nmore:{\r\nint packet_bytes = 0;\r\nint retval = usb_bulk_msg(ftdi->udev,\r\nusb_rcvbulkpipe(ftdi->udev, ftdi->bulk_in_endpointAddr),\r\nftdi->bulk_in_buffer, ftdi->bulk_in_size,\r\n&packet_bytes, 1000);\r\nif (packet_bytes > 2) {\r\nchar diag[30 *3 + 4];\r\nchar *d = diag;\r\nint m = (sizeof(diag) - 1) / 3;\r\nchar *b = ftdi->bulk_in_buffer;\r\nint bytes_read = 0;\r\ndiag[0] = 0;\r\nwhile (packet_bytes-- > 0) {\r\nchar c = *b++;\r\nif (bytes_read < m) {\r\nd += sprintf(d, " %02X",\r\n0x000000FF & c);\r\n} else if (bytes_read > m) {\r\n} else\r\nd += sprintf(d, " ..");\r\nbytes_read += 1;\r\ncontinue;\r\n}\r\ngoto more;\r\n} else if (packet_bytes > 1) {\r\nchar s1 = ftdi->bulk_in_buffer[0];\r\nchar s2 = ftdi->bulk_in_buffer[1];\r\nif (s1 == 0x31 && s2 == 0x60) {\r\nreturn 0;\r\n} else if (retry_on_status-- > 0) {\r\nmsleep(5);\r\ngoto more;\r\n} else\r\nreturn -EFAULT;\r\n} else if (packet_bytes > 0) {\r\nchar b1 = ftdi->bulk_in_buffer[0];\r\ndev_err(&ftdi->udev->dev, "only one byte flushed from F"\r\n"TDI = %02X\n", b1);\r\nif (retry_on_status-- > 0) {\r\nmsleep(5);\r\ngoto more;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "STATUS ERROR retry l"\r\n"imit reached\n");\r\nreturn -EFAULT;\r\n}\r\n} else if (retval == -ETIMEDOUT) {\r\nif (retry_on_timeout-- > 0) {\r\ngoto more;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "TIMED OUT retry limi"\r\n"t reached\n");\r\nreturn -ENOMEM;\r\n}\r\n} else if (retval == 0) {\r\nif (retry_on_empty-- > 0) {\r\ngoto more;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "empty packet retry l"\r\n"imit reached\n");\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\ndev_err(&ftdi->udev->dev, "error = %d\n", retval);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int ftdi_elan_checkingPCI(struct usb_ftdi *ftdi)\r\n{\r\nint UxxxStatus = ftdi_elan_read_reg(ftdi, &ftdi->controlreg);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nif (ftdi->controlreg & 0x00400000) {\r\nif (ftdi->card_ejected) {\r\n} else {\r\nftdi->card_ejected = 1;\r\ndev_err(&ftdi->udev->dev, "CARD EJECTED - controlreg = "\r\n"%08X\n", ftdi->controlreg);\r\n}\r\nreturn -ENODEV;\r\n} else {\r\nu8 fn = ftdi->function - 1;\r\nint activePCIfn = fn << 8;\r\nu32 pcidata;\r\nu32 pciVID;\r\nu32 pciPID;\r\nint reg = 0;\r\nUxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,\r\n&pcidata);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\npciVID = pcidata & 0xFFFF;\r\npciPID = (pcidata >> 16) & 0xFFFF;\r\nif (pciVID == ftdi->platform_data.vendor && pciPID ==\r\nftdi->platform_data.device) {\r\nreturn 0;\r\n} else {\r\ndev_err(&ftdi->udev->dev, "vendor=%04X pciVID=%04X devi"\r\n"ce=%04X pciPID=%04X\n",\r\nftdi->platform_data.vendor, pciVID,\r\nftdi->platform_data.device, pciPID);\r\nreturn -ENODEV;\r\n}\r\n}\r\n}\r\nstatic int ftdi_elan_check_controller(struct usb_ftdi *ftdi, int quirk)\r\n{\r\nint devices = 0;\r\nint retval;\r\nu32 hc_control;\r\nint num_ports;\r\nu32 control;\r\nu32 rh_a = -1;\r\nu32 status;\r\nu32 fminterval;\r\nu32 hc_fminterval;\r\nu32 periodicstart;\r\nu32 cmdstatus;\r\nu32 roothub_a;\r\nint mask = OHCI_INTR_INIT;\r\nint sleep_time = 0;\r\nint reset_timeout = 30;\r\nint temp;\r\nretval = ftdi_write_pcimem(ftdi, intrdisable, OHCI_INTR_MIE);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_read_pcimem(ftdi, control, &control);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_read_pcimem(ftdi, roothub.a, &rh_a);\r\nif (retval)\r\nreturn retval;\r\nnum_ports = rh_a & RH_A_NDP;\r\nretval = ftdi_read_pcimem(ftdi, fminterval, &hc_fminterval);\r\nif (retval)\r\nreturn retval;\r\nhc_fminterval &= 0x3fff;\r\nif (hc_fminterval != FI) {\r\n}\r\nhc_fminterval |= FSMP(hc_fminterval) << 16;\r\nretval = ftdi_read_pcimem(ftdi, control, &hc_control);\r\nif (retval)\r\nreturn retval;\r\nswitch (hc_control & OHCI_CTRL_HCFS) {\r\ncase OHCI_USB_OPER:\r\nsleep_time = 0;\r\nbreak;\r\ncase OHCI_USB_SUSPEND:\r\ncase OHCI_USB_RESUME:\r\nhc_control &= OHCI_CTRL_RWC;\r\nhc_control |= OHCI_USB_RESUME;\r\nsleep_time = 10;\r\nbreak;\r\ndefault:\r\nhc_control &= OHCI_CTRL_RWC;\r\nhc_control |= OHCI_USB_RESET;\r\nsleep_time = 50;\r\nbreak;\r\n}\r\nretval = ftdi_write_pcimem(ftdi, control, hc_control);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_read_pcimem(ftdi, control, &control);\r\nif (retval)\r\nreturn retval;\r\nmsleep(sleep_time);\r\nretval = ftdi_read_pcimem(ftdi, roothub.a, &roothub_a);\r\nif (retval)\r\nreturn retval;\r\nif (!(roothub_a & RH_A_NPS)) {\r\nfor (temp = 0; temp < num_ports; temp++) {\r\nretval = ftdi_write_pcimem(ftdi,\r\nroothub.portstatus[temp], RH_PS_LSDA);\r\nif (retval)\r\nreturn retval;\r\n}\r\n}\r\nretval = ftdi_read_pcimem(ftdi, control, &control);\r\nif (retval)\r\nreturn retval;\r\nretry:retval = ftdi_read_pcimem(ftdi, cmdstatus, &status);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_write_pcimem(ftdi, cmdstatus, OHCI_HCR);\r\nif (retval)\r\nreturn retval;\r\nextra:{\r\nretval = ftdi_read_pcimem(ftdi, cmdstatus, &status);\r\nif (retval)\r\nreturn retval;\r\nif (0 != (status & OHCI_HCR)) {\r\nif (--reset_timeout == 0) {\r\ndev_err(&ftdi->udev->dev, "USB HC reset timed o"\r\n"ut!\n");\r\nreturn -ENODEV;\r\n} else {\r\nmsleep(5);\r\ngoto extra;\r\n}\r\n}\r\n}\r\nif (quirk & OHCI_QUIRK_INITRESET) {\r\nretval = ftdi_write_pcimem(ftdi, control, hc_control);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_read_pcimem(ftdi, control, &control);\r\nif (retval)\r\nreturn retval;\r\n}\r\nretval = ftdi_write_pcimem(ftdi, ed_controlhead, 0x00000000);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_write_pcimem(ftdi, ed_bulkhead, 0x11000000);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_write_pcimem(ftdi, hcca, 0x00000000);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_read_pcimem(ftdi, fminterval, &fminterval);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_write_pcimem(ftdi, fminterval,\r\n((fminterval & FIT) ^ FIT) | hc_fminterval);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_write_pcimem(ftdi, periodicstart,\r\n((9 *hc_fminterval) / 10) & 0x3fff);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_read_pcimem(ftdi, fminterval, &fminterval);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_read_pcimem(ftdi, periodicstart, &periodicstart);\r\nif (retval)\r\nreturn retval;\r\nif (0 == (fminterval & 0x3fff0000) || 0 == periodicstart) {\r\nif (!(quirk & OHCI_QUIRK_INITRESET)) {\r\nquirk |= OHCI_QUIRK_INITRESET;\r\ngoto retry;\r\n} else\r\ndev_err(&ftdi->udev->dev, "init err(%08x %04x)\n",\r\nfminterval, periodicstart);\r\n}\r\nhc_control &= OHCI_CTRL_RWC;\r\nhc_control |= OHCI_CONTROL_INIT | OHCI_CTRL_BLE | OHCI_USB_OPER;\r\nretval = ftdi_write_pcimem(ftdi, control, hc_control);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_write_pcimem(ftdi, cmdstatus, OHCI_BLF);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_read_pcimem(ftdi, cmdstatus, &cmdstatus);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_read_pcimem(ftdi, control, &control);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_write_pcimem(ftdi, roothub.status, RH_HS_DRWE);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_write_pcimem(ftdi, intrstatus, mask);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_write_pcimem(ftdi, intrdisable,\r\nOHCI_INTR_MIE | OHCI_INTR_OC | OHCI_INTR_RHSC | OHCI_INTR_FNO |\r\nOHCI_INTR_UE | OHCI_INTR_RD | OHCI_INTR_SF | OHCI_INTR_WDH |\r\nOHCI_INTR_SO);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_read_pcimem(ftdi, roothub.a, &roothub_a);\r\nif (retval)\r\nreturn retval;\r\nroothub_a &= ~(RH_A_PSM | RH_A_OCPM);\r\nif (quirk & OHCI_QUIRK_SUPERIO) {\r\nroothub_a |= RH_A_NOCP;\r\nroothub_a &= ~(RH_A_POTPGT | RH_A_NPS);\r\nretval = ftdi_write_pcimem(ftdi, roothub.a, roothub_a);\r\nif (retval)\r\nreturn retval;\r\n} else if ((quirk & OHCI_QUIRK_AMD756) || distrust_firmware) {\r\nroothub_a |= RH_A_NPS;\r\nretval = ftdi_write_pcimem(ftdi, roothub.a, roothub_a);\r\nif (retval)\r\nreturn retval;\r\n}\r\nretval = ftdi_write_pcimem(ftdi, roothub.status, RH_HS_LPSC);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_write_pcimem(ftdi, roothub.b,\r\n(roothub_a & RH_A_NPS) ? 0 : RH_B_PPCM);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_read_pcimem(ftdi, control, &control);\r\nif (retval)\r\nreturn retval;\r\nmdelay((roothub_a >> 23) & 0x1fe);\r\nfor (temp = 0; temp < num_ports; temp++) {\r\nu32 portstatus;\r\nretval = ftdi_read_pcimem(ftdi, roothub.portstatus[temp],\r\n&portstatus);\r\nif (retval)\r\nreturn retval;\r\nif (1 & portstatus)\r\ndevices += 1;\r\n}\r\nreturn devices;\r\n}\r\nstatic int ftdi_elan_setup_controller(struct usb_ftdi *ftdi, int fn)\r\n{\r\nu32 latence_timer;\r\nint UxxxStatus;\r\nu32 pcidata;\r\nint reg = 0;\r\nint activePCIfn = fn << 8;\r\nUxxxStatus = ftdi_elan_write_reg(ftdi, 0x0000025FL | 0x2800);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nreg = 16;\r\nUxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0,\r\n0xFFFFFFFF);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,\r\n&pcidata);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0,\r\n0xF0000000);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,\r\n&pcidata);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nreg = 12;\r\nUxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,\r\n&latence_timer);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nlatence_timer &= 0xFFFF00FF;\r\nlatence_timer |= 0x00001600;\r\nUxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0x00,\r\nlatence_timer);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,\r\n&pcidata);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nreg = 4;\r\nUxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0x00,\r\n0x06);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,\r\n&pcidata);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nfor (reg = 0; reg <= 0x54; reg += 4) {\r\nUxxxStatus = ftdi_elan_read_pcimem(ftdi, reg, 0, &pcidata);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ftdi_elan_close_controller(struct usb_ftdi *ftdi, int fn)\r\n{\r\nu32 latence_timer;\r\nint UxxxStatus;\r\nu32 pcidata;\r\nint reg = 0;\r\nint activePCIfn = fn << 8;\r\nUxxxStatus = ftdi_elan_write_reg(ftdi, 0x0000025FL | 0x2800);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nreg = 16;\r\nUxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0,\r\n0xFFFFFFFF);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,\r\n&pcidata);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0,\r\n0x00000000);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,\r\n&pcidata);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nreg = 12;\r\nUxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,\r\n&latence_timer);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nlatence_timer &= 0xFFFF00FF;\r\nlatence_timer |= 0x00001600;\r\nUxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0x00,\r\nlatence_timer);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,\r\n&pcidata);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nreg = 4;\r\nUxxxStatus = ftdi_elan_write_config(ftdi, activePCIfn | reg, 0x00,\r\n0x00);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,\r\n&pcidata);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nreturn 0;\r\n}\r\nstatic int ftdi_elan_found_controller(struct usb_ftdi *ftdi, int fn, int quirk)\r\n{\r\nint result;\r\nint UxxxStatus;\r\nUxxxStatus = ftdi_elan_setup_controller(ftdi, fn);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nresult = ftdi_elan_check_controller(ftdi, quirk);\r\nUxxxStatus = ftdi_elan_close_controller(ftdi, fn);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nreturn result;\r\n}\r\nstatic int ftdi_elan_enumeratePCI(struct usb_ftdi *ftdi)\r\n{\r\nu32 controlreg;\r\nu8 sensebits;\r\nint UxxxStatus;\r\nUxxxStatus = ftdi_elan_read_reg(ftdi, &controlreg);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_write_reg(ftdi, 0x00000000L);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nmsleep(750);\r\nUxxxStatus = ftdi_elan_write_reg(ftdi, 0x00000200L | 0x100);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_write_reg(ftdi, 0x00000200L | 0x500);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_read_reg(ftdi, &controlreg);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_write_reg(ftdi, 0x0000020CL | 0x000);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_write_reg(ftdi, 0x0000020DL | 0x000);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nmsleep(250);\r\nUxxxStatus = ftdi_elan_write_reg(ftdi, 0x0000020FL | 0x000);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_read_reg(ftdi, &controlreg);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_write_reg(ftdi, 0x0000025FL | 0x800);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_read_reg(ftdi, &controlreg);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nUxxxStatus = ftdi_elan_read_reg(ftdi, &controlreg);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nmsleep(1000);\r\nsensebits = (controlreg >> 16) & 0x000F;\r\nif (0x0D == sensebits)\r\nreturn 0;\r\nelse\r\nreturn - ENXIO;\r\n}\r\nstatic int ftdi_elan_setupOHCI(struct usb_ftdi *ftdi)\r\n{\r\nint UxxxStatus;\r\nu32 pcidata;\r\nint reg = 0;\r\nu8 fn;\r\nint activePCIfn = 0;\r\nint max_devices = 0;\r\nint controllers = 0;\r\nint unrecognized = 0;\r\nftdi->function = 0;\r\nfor (fn = 0; (fn < 4); fn++) {\r\nu32 pciVID = 0;\r\nu32 pciPID = 0;\r\nint devices = 0;\r\nactivePCIfn = fn << 8;\r\nUxxxStatus = ftdi_elan_read_config(ftdi, activePCIfn | reg, 0,\r\n&pcidata);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\npciVID = pcidata & 0xFFFF;\r\npciPID = (pcidata >> 16) & 0xFFFF;\r\nif ((pciVID == PCI_VENDOR_ID_OPTI) && (pciPID == 0xc861)) {\r\ndevices = ftdi_elan_found_controller(ftdi, fn, 0);\r\ncontrollers += 1;\r\n} else if ((pciVID == PCI_VENDOR_ID_NEC) && (pciPID == 0x0035))\r\n{\r\ndevices = ftdi_elan_found_controller(ftdi, fn, 0);\r\ncontrollers += 1;\r\n} else if ((pciVID == PCI_VENDOR_ID_AL) && (pciPID == 0x5237)) {\r\ndevices = ftdi_elan_found_controller(ftdi, fn, 0);\r\ncontrollers += 1;\r\n} else if ((pciVID == PCI_VENDOR_ID_ATT) && (pciPID == 0x5802))\r\n{\r\ndevices = ftdi_elan_found_controller(ftdi, fn, 0);\r\ncontrollers += 1;\r\n} else if (pciVID == PCI_VENDOR_ID_AMD && pciPID == 0x740c) {\r\ndevices = ftdi_elan_found_controller(ftdi, fn,\r\nOHCI_QUIRK_AMD756);\r\ncontrollers += 1;\r\n} else if (pciVID == PCI_VENDOR_ID_COMPAQ && pciPID == 0xa0f8) {\r\ndevices = ftdi_elan_found_controller(ftdi, fn,\r\nOHCI_QUIRK_ZFMICRO);\r\ncontrollers += 1;\r\n} else if (0 == pcidata) {\r\n} else\r\nunrecognized += 1;\r\nif (devices > max_devices) {\r\nmax_devices = devices;\r\nftdi->function = fn + 1;\r\nftdi->platform_data.vendor = pciVID;\r\nftdi->platform_data.device = pciPID;\r\n}\r\n}\r\nif (ftdi->function > 0) {\r\nUxxxStatus = ftdi_elan_setup_controller(ftdi,\r\nftdi->function - 1);\r\nif (UxxxStatus)\r\nreturn UxxxStatus;\r\nreturn 0;\r\n} else if (controllers > 0) {\r\nreturn -ENXIO;\r\n} else if (unrecognized > 0) {\r\nreturn -ENXIO;\r\n} else {\r\nftdi->enumerated = 0;\r\nreturn -ENXIO;\r\n}\r\n}\r\nstatic int ftdi_elan_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nsize_t buffer_size;\r\nint i;\r\nint retval = -ENOMEM;\r\nstruct usb_ftdi *ftdi;\r\nftdi = kzalloc(sizeof(struct usb_ftdi), GFP_KERNEL);\r\nif (!ftdi) {\r\nprintk(KERN_ERR "Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&ftdi_module_lock);\r\nlist_add_tail(&ftdi->ftdi_list, &ftdi_static_list);\r\nftdi->sequence_num = ++ftdi_instances;\r\nmutex_unlock(&ftdi_module_lock);\r\nftdi_elan_init_kref(ftdi);\r\nsema_init(&ftdi->sw_lock, 1);\r\nftdi->udev = usb_get_dev(interface_to_usbdev(interface));\r\nftdi->interface = interface;\r\nmutex_init(&ftdi->u132_lock);\r\nftdi->expected = 4;\r\niface_desc = interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!ftdi->bulk_in_endpointAddr &&\r\nusb_endpoint_is_bulk_in(endpoint)) {\r\nbuffer_size = usb_endpoint_maxp(endpoint);\r\nftdi->bulk_in_size = buffer_size;\r\nftdi->bulk_in_endpointAddr = endpoint->bEndpointAddress;\r\nftdi->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);\r\nif (!ftdi->bulk_in_buffer) {\r\ndev_err(&ftdi->udev->dev, "Could not allocate b"\r\n"ulk_in_buffer\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\nif (!ftdi->bulk_out_endpointAddr &&\r\nusb_endpoint_is_bulk_out(endpoint)) {\r\nftdi->bulk_out_endpointAddr =\r\nendpoint->bEndpointAddress;\r\n}\r\n}\r\nif (!(ftdi->bulk_in_endpointAddr && ftdi->bulk_out_endpointAddr)) {\r\ndev_err(&ftdi->udev->dev, "Could not find both bulk-in and bulk"\r\n"-out endpoints\n");\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\ndev_info(&ftdi->udev->dev, "interface %d has I=%02X O=%02X\n",\r\niface_desc->desc.bInterfaceNumber, ftdi->bulk_in_endpointAddr,\r\nftdi->bulk_out_endpointAddr);\r\nusb_set_intfdata(interface, ftdi);\r\nif (iface_desc->desc.bInterfaceNumber == 0 &&\r\nftdi->bulk_in_endpointAddr == 0x81 &&\r\nftdi->bulk_out_endpointAddr == 0x02) {\r\nretval = usb_register_dev(interface, &ftdi_elan_jtag_class);\r\nif (retval) {\r\ndev_err(&ftdi->udev->dev, "Not able to get a minor for "\r\n"this device.\n");\r\nusb_set_intfdata(interface, NULL);\r\nretval = -ENOMEM;\r\ngoto error;\r\n} else {\r\nftdi->class = &ftdi_elan_jtag_class;\r\ndev_info(&ftdi->udev->dev, "USB FDTI=%p JTAG interface "\r\n"%d now attached to ftdi%d\n", ftdi,\r\niface_desc->desc.bInterfaceNumber,\r\ninterface->minor);\r\nreturn 0;\r\n}\r\n} else if (iface_desc->desc.bInterfaceNumber == 1 &&\r\nftdi->bulk_in_endpointAddr == 0x83 &&\r\nftdi->bulk_out_endpointAddr == 0x04) {\r\nftdi->class = NULL;\r\ndev_info(&ftdi->udev->dev, "USB FDTI=%p ELAN interface %d now a"\r\n"ctivated\n", ftdi, iface_desc->desc.bInterfaceNumber);\r\nINIT_DELAYED_WORK(&ftdi->status_work, ftdi_elan_status_work);\r\nINIT_DELAYED_WORK(&ftdi->command_work, ftdi_elan_command_work);\r\nINIT_DELAYED_WORK(&ftdi->respond_work, ftdi_elan_respond_work);\r\nftdi_status_queue_work(ftdi, msecs_to_jiffies(3 *1000));\r\nreturn 0;\r\n} else {\r\ndev_err(&ftdi->udev->dev,\r\n"Could not find ELAN's U132 device\n");\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\nerror:if (ftdi) {\r\nftdi_elan_put_kref(ftdi);\r\n}\r\nreturn retval;\r\n}\r\nstatic void ftdi_elan_disconnect(struct usb_interface *interface)\r\n{\r\nstruct usb_ftdi *ftdi = usb_get_intfdata(interface);\r\nftdi->disconnected += 1;\r\nif (ftdi->class) {\r\nint minor = interface->minor;\r\nstruct usb_class_driver *class = ftdi->class;\r\nusb_set_intfdata(interface, NULL);\r\nusb_deregister_dev(interface, class);\r\ndev_info(&ftdi->udev->dev, "USB FTDI U132 jtag interface on min"\r\n"or %d now disconnected\n", minor);\r\n} else {\r\nftdi_status_cancel_work(ftdi);\r\nftdi_command_cancel_work(ftdi);\r\nftdi_response_cancel_work(ftdi);\r\nftdi_elan_abandon_completions(ftdi);\r\nftdi_elan_abandon_targets(ftdi);\r\nif (ftdi->registered) {\r\nplatform_device_unregister(&ftdi->platform_dev);\r\nftdi->synchronized = 0;\r\nftdi->enumerated = 0;\r\nftdi->initialized = 0;\r\nftdi->registered = 0;\r\n}\r\nflush_workqueue(status_queue);\r\nflush_workqueue(command_queue);\r\nflush_workqueue(respond_queue);\r\nftdi->disconnected += 1;\r\nusb_set_intfdata(interface, NULL);\r\ndev_info(&ftdi->udev->dev, "USB FTDI U132 host controller inter"\r\n"face now disconnected\n");\r\n}\r\nftdi_elan_put_kref(ftdi);\r\n}\r\nstatic int __init ftdi_elan_init(void)\r\n{\r\nint result;\r\nprintk(KERN_INFO "driver %s\n", ftdi_elan_driver.name);\r\nmutex_init(&ftdi_module_lock);\r\nINIT_LIST_HEAD(&ftdi_static_list);\r\nstatus_queue = create_singlethread_workqueue("ftdi-status-control");\r\nif (!status_queue)\r\ngoto err_status_queue;\r\ncommand_queue = create_singlethread_workqueue("ftdi-command-engine");\r\nif (!command_queue)\r\ngoto err_command_queue;\r\nrespond_queue = create_singlethread_workqueue("ftdi-respond-engine");\r\nif (!respond_queue)\r\ngoto err_respond_queue;\r\nresult = usb_register(&ftdi_elan_driver);\r\nif (result) {\r\ndestroy_workqueue(status_queue);\r\ndestroy_workqueue(command_queue);\r\ndestroy_workqueue(respond_queue);\r\nprintk(KERN_ERR "usb_register failed. Error number %d\n",\r\nresult);\r\n}\r\nreturn result;\r\nerr_respond_queue:\r\ndestroy_workqueue(command_queue);\r\nerr_command_queue:\r\ndestroy_workqueue(status_queue);\r\nerr_status_queue:\r\nprintk(KERN_ERR "%s couldn't create workqueue\n", ftdi_elan_driver.name);\r\nreturn -ENOMEM;\r\n}\r\nstatic void __exit ftdi_elan_exit(void)\r\n{\r\nstruct usb_ftdi *ftdi;\r\nstruct usb_ftdi *temp;\r\nusb_deregister(&ftdi_elan_driver);\r\nprintk(KERN_INFO "ftdi_u132 driver deregistered\n");\r\nlist_for_each_entry_safe(ftdi, temp, &ftdi_static_list, ftdi_list) {\r\nftdi_status_cancel_work(ftdi);\r\nftdi_command_cancel_work(ftdi);\r\nftdi_response_cancel_work(ftdi);\r\n} flush_workqueue(status_queue);\r\ndestroy_workqueue(status_queue);\r\nstatus_queue = NULL;\r\nflush_workqueue(command_queue);\r\ndestroy_workqueue(command_queue);\r\ncommand_queue = NULL;\r\nflush_workqueue(respond_queue);\r\ndestroy_workqueue(respond_queue);\r\nrespond_queue = NULL;\r\n}
