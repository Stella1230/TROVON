static void ipoib_cm_dma_unmap_rx(struct ipoib_dev_priv *priv, int frags,\r\nu64 mapping[IPOIB_CM_RX_SG])\r\n{\r\nint i;\r\nib_dma_unmap_single(priv->ca, mapping[0], IPOIB_CM_HEAD_SIZE, DMA_FROM_DEVICE);\r\nfor (i = 0; i < frags; ++i)\r\nib_dma_unmap_page(priv->ca, mapping[i + 1], PAGE_SIZE, DMA_FROM_DEVICE);\r\n}\r\nstatic int ipoib_cm_post_receive_srq(struct net_device *dev, int id)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_recv_wr *bad_wr;\r\nint i, ret;\r\npriv->cm.rx_wr.wr_id = id | IPOIB_OP_CM | IPOIB_OP_RECV;\r\nfor (i = 0; i < priv->cm.num_frags; ++i)\r\npriv->cm.rx_sge[i].addr = priv->cm.srq_ring[id].mapping[i];\r\nret = ib_post_srq_recv(priv->cm.srq, &priv->cm.rx_wr, &bad_wr);\r\nif (unlikely(ret)) {\r\nipoib_warn(priv, "post srq failed for buf %d (%d)\n", id, ret);\r\nipoib_cm_dma_unmap_rx(priv, priv->cm.num_frags - 1,\r\npriv->cm.srq_ring[id].mapping);\r\ndev_kfree_skb_any(priv->cm.srq_ring[id].skb);\r\npriv->cm.srq_ring[id].skb = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ipoib_cm_post_receive_nonsrq(struct net_device *dev,\r\nstruct ipoib_cm_rx *rx,\r\nstruct ib_recv_wr *wr,\r\nstruct ib_sge *sge, int id)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_recv_wr *bad_wr;\r\nint i, ret;\r\nwr->wr_id = id | IPOIB_OP_CM | IPOIB_OP_RECV;\r\nfor (i = 0; i < IPOIB_CM_RX_SG; ++i)\r\nsge[i].addr = rx->rx_ring[id].mapping[i];\r\nret = ib_post_recv(rx->qp, wr, &bad_wr);\r\nif (unlikely(ret)) {\r\nipoib_warn(priv, "post recv failed for buf %d (%d)\n", id, ret);\r\nipoib_cm_dma_unmap_rx(priv, IPOIB_CM_RX_SG - 1,\r\nrx->rx_ring[id].mapping);\r\ndev_kfree_skb_any(rx->rx_ring[id].skb);\r\nrx->rx_ring[id].skb = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct sk_buff *ipoib_cm_alloc_rx_skb(struct net_device *dev,\r\nstruct ipoib_cm_rx_buf *rx_ring,\r\nint id, int frags,\r\nu64 mapping[IPOIB_CM_RX_SG],\r\ngfp_t gfp)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nint i;\r\nskb = dev_alloc_skb(IPOIB_CM_HEAD_SIZE + 12);\r\nif (unlikely(!skb))\r\nreturn NULL;\r\nskb_reserve(skb, 12);\r\nmapping[0] = ib_dma_map_single(priv->ca, skb->data, IPOIB_CM_HEAD_SIZE,\r\nDMA_FROM_DEVICE);\r\nif (unlikely(ib_dma_mapping_error(priv->ca, mapping[0]))) {\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < frags; i++) {\r\nstruct page *page = alloc_page(gfp);\r\nif (!page)\r\ngoto partial_error;\r\nskb_fill_page_desc(skb, i, page, 0, PAGE_SIZE);\r\nmapping[i + 1] = ib_dma_map_page(priv->ca, page,\r\n0, PAGE_SIZE, DMA_FROM_DEVICE);\r\nif (unlikely(ib_dma_mapping_error(priv->ca, mapping[i + 1])))\r\ngoto partial_error;\r\n}\r\nrx_ring[id].skb = skb;\r\nreturn skb;\r\npartial_error:\r\nib_dma_unmap_single(priv->ca, mapping[0], IPOIB_CM_HEAD_SIZE, DMA_FROM_DEVICE);\r\nfor (; i > 0; --i)\r\nib_dma_unmap_page(priv->ca, mapping[i], PAGE_SIZE, DMA_FROM_DEVICE);\r\ndev_kfree_skb_any(skb);\r\nreturn NULL;\r\n}\r\nstatic void ipoib_cm_free_rx_ring(struct net_device *dev,\r\nstruct ipoib_cm_rx_buf *rx_ring)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < ipoib_recvq_size; ++i)\r\nif (rx_ring[i].skb) {\r\nipoib_cm_dma_unmap_rx(priv, IPOIB_CM_RX_SG - 1,\r\nrx_ring[i].mapping);\r\ndev_kfree_skb_any(rx_ring[i].skb);\r\n}\r\nvfree(rx_ring);\r\n}\r\nstatic void ipoib_cm_start_rx_drain(struct ipoib_dev_priv *priv)\r\n{\r\nstruct ib_send_wr *bad_wr;\r\nstruct ipoib_cm_rx *p;\r\nif (list_empty(&priv->cm.rx_flush_list) ||\r\n!list_empty(&priv->cm.rx_drain_list))\r\nreturn;\r\np = list_entry(priv->cm.rx_flush_list.next, typeof(*p), list);\r\nif (ib_post_send(p->qp, &ipoib_cm_rx_drain_wr, &bad_wr))\r\nipoib_warn(priv, "failed to post drain wr\n");\r\nlist_splice_init(&priv->cm.rx_flush_list, &priv->cm.rx_drain_list);\r\n}\r\nstatic void ipoib_cm_rx_event_handler(struct ib_event *event, void *ctx)\r\n{\r\nstruct ipoib_cm_rx *p = ctx;\r\nstruct ipoib_dev_priv *priv = netdev_priv(p->dev);\r\nunsigned long flags;\r\nif (event->event != IB_EVENT_QP_LAST_WQE_REACHED)\r\nreturn;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nlist_move(&p->list, &priv->cm.rx_flush_list);\r\np->state = IPOIB_CM_RX_FLUSH;\r\nipoib_cm_start_rx_drain(priv);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic struct ib_qp *ipoib_cm_create_rx_qp(struct net_device *dev,\r\nstruct ipoib_cm_rx *p)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_qp_init_attr attr = {\r\n.event_handler = ipoib_cm_rx_event_handler,\r\n.send_cq = priv->recv_cq,\r\n.recv_cq = priv->recv_cq,\r\n.srq = priv->cm.srq,\r\n.cap.max_send_wr = 1,\r\n.cap.max_send_sge = 1,\r\n.sq_sig_type = IB_SIGNAL_ALL_WR,\r\n.qp_type = IB_QPT_RC,\r\n.qp_context = p,\r\n};\r\nif (!ipoib_cm_has_srq(dev)) {\r\nattr.cap.max_recv_wr = ipoib_recvq_size;\r\nattr.cap.max_recv_sge = IPOIB_CM_RX_SG;\r\n}\r\nreturn ib_create_qp(priv->pd, &attr);\r\n}\r\nstatic int ipoib_cm_modify_rx_qp(struct net_device *dev,\r\nstruct ib_cm_id *cm_id, struct ib_qp *qp,\r\nunsigned psn)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_qp_attr qp_attr;\r\nint qp_attr_mask, ret;\r\nqp_attr.qp_state = IB_QPS_INIT;\r\nret = ib_cm_init_qp_attr(cm_id, &qp_attr, &qp_attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to init QP attr for INIT: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ib_modify_qp(qp, &qp_attr, qp_attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify QP to INIT: %d\n", ret);\r\nreturn ret;\r\n}\r\nqp_attr.qp_state = IB_QPS_RTR;\r\nret = ib_cm_init_qp_attr(cm_id, &qp_attr, &qp_attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to init QP attr for RTR: %d\n", ret);\r\nreturn ret;\r\n}\r\nqp_attr.rq_psn = psn;\r\nret = ib_modify_qp(qp, &qp_attr, qp_attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify QP to RTR: %d\n", ret);\r\nreturn ret;\r\n}\r\nqp_attr.qp_state = IB_QPS_RTS;\r\nret = ib_cm_init_qp_attr(cm_id, &qp_attr, &qp_attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to init QP attr for RTS: %d\n", ret);\r\nreturn 0;\r\n}\r\nret = ib_modify_qp(qp, &qp_attr, qp_attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify QP to RTS: %d\n", ret);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipoib_cm_init_rx_wr(struct net_device *dev,\r\nstruct ib_recv_wr *wr,\r\nstruct ib_sge *sge)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < priv->cm.num_frags; ++i)\r\nsge[i].lkey = priv->mr->lkey;\r\nsge[0].length = IPOIB_CM_HEAD_SIZE;\r\nfor (i = 1; i < priv->cm.num_frags; ++i)\r\nsge[i].length = PAGE_SIZE;\r\nwr->next = NULL;\r\nwr->sg_list = sge;\r\nwr->num_sge = priv->cm.num_frags;\r\n}\r\nstatic int ipoib_cm_nonsrq_init_rx(struct net_device *dev, struct ib_cm_id *cm_id,\r\nstruct ipoib_cm_rx *rx)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct {\r\nstruct ib_recv_wr wr;\r\nstruct ib_sge sge[IPOIB_CM_RX_SG];\r\n} *t;\r\nint ret;\r\nint i;\r\nrx->rx_ring = vzalloc(ipoib_recvq_size * sizeof *rx->rx_ring);\r\nif (!rx->rx_ring) {\r\nprintk(KERN_WARNING "%s: failed to allocate CM non-SRQ ring (%d entries)\n",\r\npriv->ca->name, ipoib_recvq_size);\r\nreturn -ENOMEM;\r\n}\r\nt = kmalloc(sizeof *t, GFP_KERNEL);\r\nif (!t) {\r\nret = -ENOMEM;\r\ngoto err_free;\r\n}\r\nipoib_cm_init_rx_wr(dev, &t->wr, t->sge);\r\nspin_lock_irq(&priv->lock);\r\nif (priv->cm.nonsrq_conn_qp >= ipoib_max_conn_qp) {\r\nspin_unlock_irq(&priv->lock);\r\nib_send_cm_rej(cm_id, IB_CM_REJ_NO_QP, NULL, 0, NULL, 0);\r\nret = -EINVAL;\r\ngoto err_free;\r\n} else\r\n++priv->cm.nonsrq_conn_qp;\r\nspin_unlock_irq(&priv->lock);\r\nfor (i = 0; i < ipoib_recvq_size; ++i) {\r\nif (!ipoib_cm_alloc_rx_skb(dev, rx->rx_ring, i, IPOIB_CM_RX_SG - 1,\r\nrx->rx_ring[i].mapping,\r\nGFP_KERNEL)) {\r\nipoib_warn(priv, "failed to allocate receive buffer %d\n", i);\r\nret = -ENOMEM;\r\ngoto err_count;\r\n}\r\nret = ipoib_cm_post_receive_nonsrq(dev, rx, &t->wr, t->sge, i);\r\nif (ret) {\r\nipoib_warn(priv, "ipoib_cm_post_receive_nonsrq "\r\n"failed for buf %d\n", i);\r\nret = -EIO;\r\ngoto err_count;\r\n}\r\n}\r\nrx->recv_count = ipoib_recvq_size;\r\nkfree(t);\r\nreturn 0;\r\nerr_count:\r\nspin_lock_irq(&priv->lock);\r\n--priv->cm.nonsrq_conn_qp;\r\nspin_unlock_irq(&priv->lock);\r\nerr_free:\r\nkfree(t);\r\nipoib_cm_free_rx_ring(dev, rx->rx_ring);\r\nreturn ret;\r\n}\r\nstatic int ipoib_cm_send_rep(struct net_device *dev, struct ib_cm_id *cm_id,\r\nstruct ib_qp *qp, struct ib_cm_req_event_param *req,\r\nunsigned psn)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_cm_data data = {};\r\nstruct ib_cm_rep_param rep = {};\r\ndata.qpn = cpu_to_be32(priv->qp->qp_num);\r\ndata.mtu = cpu_to_be32(IPOIB_CM_BUF_SIZE);\r\nrep.private_data = &data;\r\nrep.private_data_len = sizeof data;\r\nrep.flow_control = 0;\r\nrep.rnr_retry_count = req->rnr_retry_count;\r\nrep.srq = ipoib_cm_has_srq(dev);\r\nrep.qp_num = qp->qp_num;\r\nrep.starting_psn = psn;\r\nreturn ib_send_cm_rep(cm_id, &rep);\r\n}\r\nstatic int ipoib_cm_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *event)\r\n{\r\nstruct net_device *dev = cm_id->context;\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_cm_rx *p;\r\nunsigned psn;\r\nint ret;\r\nipoib_dbg(priv, "REQ arrived\n");\r\np = kzalloc(sizeof *p, GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->dev = dev;\r\np->id = cm_id;\r\ncm_id->context = p;\r\np->state = IPOIB_CM_RX_LIVE;\r\np->jiffies = jiffies;\r\nINIT_LIST_HEAD(&p->list);\r\np->qp = ipoib_cm_create_rx_qp(dev, p);\r\nif (IS_ERR(p->qp)) {\r\nret = PTR_ERR(p->qp);\r\ngoto err_qp;\r\n}\r\npsn = prandom_u32() & 0xffffff;\r\nret = ipoib_cm_modify_rx_qp(dev, cm_id, p->qp, psn);\r\nif (ret)\r\ngoto err_modify;\r\nif (!ipoib_cm_has_srq(dev)) {\r\nret = ipoib_cm_nonsrq_init_rx(dev, cm_id, p);\r\nif (ret)\r\ngoto err_modify;\r\n}\r\nspin_lock_irq(&priv->lock);\r\nqueue_delayed_work(ipoib_workqueue,\r\n&priv->cm.stale_task, IPOIB_CM_RX_DELAY);\r\np->jiffies = jiffies;\r\nif (p->state == IPOIB_CM_RX_LIVE)\r\nlist_move(&p->list, &priv->cm.passive_ids);\r\nspin_unlock_irq(&priv->lock);\r\nret = ipoib_cm_send_rep(dev, cm_id, p->qp, &event->param.req_rcvd, psn);\r\nif (ret) {\r\nipoib_warn(priv, "failed to send REP: %d\n", ret);\r\nif (ib_modify_qp(p->qp, &ipoib_cm_err_attr, IB_QP_STATE))\r\nipoib_warn(priv, "unable to move qp to error state\n");\r\n}\r\nreturn 0;\r\nerr_modify:\r\nib_destroy_qp(p->qp);\r\nerr_qp:\r\nkfree(p);\r\nreturn ret;\r\n}\r\nstatic int ipoib_cm_rx_handler(struct ib_cm_id *cm_id,\r\nstruct ib_cm_event *event)\r\n{\r\nstruct ipoib_cm_rx *p;\r\nstruct ipoib_dev_priv *priv;\r\nswitch (event->event) {\r\ncase IB_CM_REQ_RECEIVED:\r\nreturn ipoib_cm_req_handler(cm_id, event);\r\ncase IB_CM_DREQ_RECEIVED:\r\np = cm_id->context;\r\nib_send_cm_drep(cm_id, NULL, 0);\r\ncase IB_CM_REJ_RECEIVED:\r\np = cm_id->context;\r\npriv = netdev_priv(p->dev);\r\nif (ib_modify_qp(p->qp, &ipoib_cm_err_attr, IB_QP_STATE))\r\nipoib_warn(priv, "unable to move qp to error state\n");\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void skb_put_frags(struct sk_buff *skb, unsigned int hdr_space,\r\nunsigned int length, struct sk_buff *toskb)\r\n{\r\nint i, num_frags;\r\nunsigned int size;\r\nsize = min(length, hdr_space);\r\nskb->tail += size;\r\nskb->len += size;\r\nlength -= size;\r\nnum_frags = skb_shinfo(skb)->nr_frags;\r\nfor (i = 0; i < num_frags; i++) {\r\nskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nif (length == 0) {\r\nskb_fill_page_desc(toskb, i, skb_frag_page(frag),\r\n0, PAGE_SIZE);\r\n--skb_shinfo(skb)->nr_frags;\r\n} else {\r\nsize = min(length, (unsigned) PAGE_SIZE);\r\nskb_frag_size_set(frag, size);\r\nskb->data_len += size;\r\nskb->truesize += size;\r\nskb->len += size;\r\nlength -= size;\r\n}\r\n}\r\n}\r\nvoid ipoib_cm_handle_rx_wc(struct net_device *dev, struct ib_wc *wc)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_cm_rx_buf *rx_ring;\r\nunsigned int wr_id = wc->wr_id & ~(IPOIB_OP_CM | IPOIB_OP_RECV);\r\nstruct sk_buff *skb, *newskb;\r\nstruct ipoib_cm_rx *p;\r\nunsigned long flags;\r\nu64 mapping[IPOIB_CM_RX_SG];\r\nint frags;\r\nint has_srq;\r\nstruct sk_buff *small_skb;\r\nipoib_dbg_data(priv, "cm recv completion: id %d, status: %d\n",\r\nwr_id, wc->status);\r\nif (unlikely(wr_id >= ipoib_recvq_size)) {\r\nif (wr_id == (IPOIB_CM_RX_DRAIN_WRID & ~(IPOIB_OP_CM | IPOIB_OP_RECV))) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\nlist_splice_init(&priv->cm.rx_drain_list, &priv->cm.rx_reap_list);\r\nipoib_cm_start_rx_drain(priv);\r\nqueue_work(ipoib_workqueue, &priv->cm.rx_reap_task);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n} else\r\nipoib_warn(priv, "cm recv completion event with wrid %d (> %d)\n",\r\nwr_id, ipoib_recvq_size);\r\nreturn;\r\n}\r\np = wc->qp->qp_context;\r\nhas_srq = ipoib_cm_has_srq(dev);\r\nrx_ring = has_srq ? priv->cm.srq_ring : p->rx_ring;\r\nskb = rx_ring[wr_id].skb;\r\nif (unlikely(wc->status != IB_WC_SUCCESS)) {\r\nipoib_dbg(priv, "cm recv error "\r\n"(status=%d, wrid=%d vend_err %x)\n",\r\nwc->status, wr_id, wc->vendor_err);\r\n++dev->stats.rx_dropped;\r\nif (has_srq)\r\ngoto repost;\r\nelse {\r\nif (!--p->recv_count) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\nlist_move(&p->list, &priv->cm.rx_reap_list);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nqueue_work(ipoib_workqueue, &priv->cm.rx_reap_task);\r\n}\r\nreturn;\r\n}\r\n}\r\nif (unlikely(!(wr_id & IPOIB_CM_RX_UPDATE_MASK))) {\r\nif (p && time_after_eq(jiffies, p->jiffies + IPOIB_CM_RX_UPDATE_TIME)) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\np->jiffies = jiffies;\r\nif (p->state == IPOIB_CM_RX_LIVE)\r\nlist_move(&p->list, &priv->cm.passive_ids);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\n}\r\nif (wc->byte_len < IPOIB_CM_COPYBREAK) {\r\nint dlen = wc->byte_len;\r\nsmall_skb = dev_alloc_skb(dlen + 12);\r\nif (small_skb) {\r\nskb_reserve(small_skb, 12);\r\nib_dma_sync_single_for_cpu(priv->ca, rx_ring[wr_id].mapping[0],\r\ndlen, DMA_FROM_DEVICE);\r\nskb_copy_from_linear_data(skb, small_skb->data, dlen);\r\nib_dma_sync_single_for_device(priv->ca, rx_ring[wr_id].mapping[0],\r\ndlen, DMA_FROM_DEVICE);\r\nskb_put(small_skb, dlen);\r\nskb = small_skb;\r\ngoto copied;\r\n}\r\n}\r\nfrags = PAGE_ALIGN(wc->byte_len - min(wc->byte_len,\r\n(unsigned)IPOIB_CM_HEAD_SIZE)) / PAGE_SIZE;\r\nnewskb = ipoib_cm_alloc_rx_skb(dev, rx_ring, wr_id, frags,\r\nmapping, GFP_ATOMIC);\r\nif (unlikely(!newskb)) {\r\nipoib_dbg(priv, "failed to allocate receive buffer %d\n", wr_id);\r\n++dev->stats.rx_dropped;\r\ngoto repost;\r\n}\r\nipoib_cm_dma_unmap_rx(priv, frags, rx_ring[wr_id].mapping);\r\nmemcpy(rx_ring[wr_id].mapping, mapping, (frags + 1) * sizeof *mapping);\r\nipoib_dbg_data(priv, "received %d bytes, SLID 0x%04x\n",\r\nwc->byte_len, wc->slid);\r\nskb_put_frags(skb, IPOIB_CM_HEAD_SIZE, wc->byte_len, newskb);\r\ncopied:\r\nskb->protocol = ((struct ipoib_header *) skb->data)->proto;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, IPOIB_ENCAP_LEN);\r\n++dev->stats.rx_packets;\r\ndev->stats.rx_bytes += skb->len;\r\nskb->dev = dev;\r\nskb->pkt_type = PACKET_HOST;\r\nnetif_receive_skb(skb);\r\nrepost:\r\nif (has_srq) {\r\nif (unlikely(ipoib_cm_post_receive_srq(dev, wr_id)))\r\nipoib_warn(priv, "ipoib_cm_post_receive_srq failed "\r\n"for buf %d\n", wr_id);\r\n} else {\r\nif (unlikely(ipoib_cm_post_receive_nonsrq(dev, p,\r\n&priv->cm.rx_wr,\r\npriv->cm.rx_sge,\r\nwr_id))) {\r\n--p->recv_count;\r\nipoib_warn(priv, "ipoib_cm_post_receive_nonsrq failed "\r\n"for buf %d\n", wr_id);\r\n}\r\n}\r\n}\r\nstatic inline int post_send(struct ipoib_dev_priv *priv,\r\nstruct ipoib_cm_tx *tx,\r\nunsigned int wr_id,\r\nu64 addr, int len)\r\n{\r\nstruct ib_send_wr *bad_wr;\r\npriv->tx_sge[0].addr = addr;\r\npriv->tx_sge[0].length = len;\r\npriv->tx_wr.num_sge = 1;\r\npriv->tx_wr.wr_id = wr_id | IPOIB_OP_CM;\r\nreturn ib_post_send(tx->qp, &priv->tx_wr, &bad_wr);\r\n}\r\nvoid ipoib_cm_send(struct net_device *dev, struct sk_buff *skb, struct ipoib_cm_tx *tx)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_cm_tx_buf *tx_req;\r\nu64 addr;\r\nint rc;\r\nif (unlikely(skb->len > tx->mtu)) {\r\nipoib_warn(priv, "packet len %d (> %d) too long to send, dropping\n",\r\nskb->len, tx->mtu);\r\n++dev->stats.tx_dropped;\r\n++dev->stats.tx_errors;\r\nipoib_cm_skb_too_long(dev, skb, tx->mtu - IPOIB_ENCAP_LEN);\r\nreturn;\r\n}\r\nipoib_dbg_data(priv, "sending packet: head 0x%x length %d connection 0x%x\n",\r\ntx->tx_head, skb->len, tx->qp->qp_num);\r\ntx_req = &tx->tx_ring[tx->tx_head & (ipoib_sendq_size - 1)];\r\ntx_req->skb = skb;\r\naddr = ib_dma_map_single(priv->ca, skb->data, skb->len, DMA_TO_DEVICE);\r\nif (unlikely(ib_dma_mapping_error(priv->ca, addr))) {\r\n++dev->stats.tx_errors;\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\ntx_req->mapping = addr;\r\nskb_orphan(skb);\r\nskb_dst_drop(skb);\r\nrc = post_send(priv, tx, tx->tx_head & (ipoib_sendq_size - 1),\r\naddr, skb->len);\r\nif (unlikely(rc)) {\r\nipoib_warn(priv, "post_send failed, error %d\n", rc);\r\n++dev->stats.tx_errors;\r\nib_dma_unmap_single(priv->ca, addr, skb->len, DMA_TO_DEVICE);\r\ndev_kfree_skb_any(skb);\r\n} else {\r\ndev->trans_start = jiffies;\r\n++tx->tx_head;\r\nif (++priv->tx_outstanding == ipoib_sendq_size) {\r\nipoib_dbg(priv, "TX ring 0x%x full, stopping kernel net queue\n",\r\ntx->qp->qp_num);\r\nnetif_stop_queue(dev);\r\nrc = ib_req_notify_cq(priv->send_cq,\r\nIB_CQ_NEXT_COMP | IB_CQ_REPORT_MISSED_EVENTS);\r\nif (rc < 0)\r\nipoib_warn(priv, "request notify on send CQ failed\n");\r\nelse if (rc)\r\nipoib_send_comp_handler(priv->send_cq, dev);\r\n}\r\n}\r\n}\r\nvoid ipoib_cm_handle_tx_wc(struct net_device *dev, struct ib_wc *wc)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_cm_tx *tx = wc->qp->qp_context;\r\nunsigned int wr_id = wc->wr_id & ~IPOIB_OP_CM;\r\nstruct ipoib_cm_tx_buf *tx_req;\r\nunsigned long flags;\r\nipoib_dbg_data(priv, "cm send completion: id %d, status: %d\n",\r\nwr_id, wc->status);\r\nif (unlikely(wr_id >= ipoib_sendq_size)) {\r\nipoib_warn(priv, "cm send completion event with wrid %d (> %d)\n",\r\nwr_id, ipoib_sendq_size);\r\nreturn;\r\n}\r\ntx_req = &tx->tx_ring[wr_id];\r\nib_dma_unmap_single(priv->ca, tx_req->mapping, tx_req->skb->len, DMA_TO_DEVICE);\r\n++dev->stats.tx_packets;\r\ndev->stats.tx_bytes += tx_req->skb->len;\r\ndev_kfree_skb_any(tx_req->skb);\r\nnetif_tx_lock(dev);\r\n++tx->tx_tail;\r\nif (unlikely(--priv->tx_outstanding == ipoib_sendq_size >> 1) &&\r\nnetif_queue_stopped(dev) &&\r\ntest_bit(IPOIB_FLAG_ADMIN_UP, &priv->flags))\r\nnetif_wake_queue(dev);\r\nif (wc->status != IB_WC_SUCCESS &&\r\nwc->status != IB_WC_WR_FLUSH_ERR) {\r\nstruct ipoib_neigh *neigh;\r\nipoib_dbg(priv, "failed cm send event "\r\n"(status=%d, wrid=%d vend_err %x)\n",\r\nwc->status, wr_id, wc->vendor_err);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nneigh = tx->neigh;\r\nif (neigh) {\r\nneigh->cm = NULL;\r\nipoib_neigh_free(neigh);\r\ntx->neigh = NULL;\r\n}\r\nif (test_and_clear_bit(IPOIB_FLAG_INITIALIZED, &tx->flags)) {\r\nlist_move(&tx->list, &priv->cm.reap_list);\r\nqueue_work(ipoib_workqueue, &priv->cm.reap_task);\r\n}\r\nclear_bit(IPOIB_FLAG_OPER_UP, &tx->flags);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nnetif_tx_unlock(dev);\r\n}\r\nint ipoib_cm_dev_open(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nint ret;\r\nif (!IPOIB_CM_SUPPORTED(dev->dev_addr))\r\nreturn 0;\r\npriv->cm.id = ib_create_cm_id(priv->ca, ipoib_cm_rx_handler, dev);\r\nif (IS_ERR(priv->cm.id)) {\r\nprintk(KERN_WARNING "%s: failed to create CM ID\n", priv->ca->name);\r\nret = PTR_ERR(priv->cm.id);\r\ngoto err_cm;\r\n}\r\nret = ib_cm_listen(priv->cm.id, cpu_to_be64(IPOIB_CM_IETF_ID | priv->qp->qp_num),\r\n0, NULL);\r\nif (ret) {\r\nprintk(KERN_WARNING "%s: failed to listen on ID 0x%llx\n", priv->ca->name,\r\nIPOIB_CM_IETF_ID | priv->qp->qp_num);\r\ngoto err_listen;\r\n}\r\nreturn 0;\r\nerr_listen:\r\nib_destroy_cm_id(priv->cm.id);\r\nerr_cm:\r\npriv->cm.id = NULL;\r\nreturn ret;\r\n}\r\nstatic void ipoib_cm_free_rx_reap_list(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_cm_rx *rx, *n;\r\nLIST_HEAD(list);\r\nspin_lock_irq(&priv->lock);\r\nlist_splice_init(&priv->cm.rx_reap_list, &list);\r\nspin_unlock_irq(&priv->lock);\r\nlist_for_each_entry_safe(rx, n, &list, list) {\r\nib_destroy_cm_id(rx->id);\r\nib_destroy_qp(rx->qp);\r\nif (!ipoib_cm_has_srq(dev)) {\r\nipoib_cm_free_rx_ring(priv->dev, rx->rx_ring);\r\nspin_lock_irq(&priv->lock);\r\n--priv->cm.nonsrq_conn_qp;\r\nspin_unlock_irq(&priv->lock);\r\n}\r\nkfree(rx);\r\n}\r\n}\r\nvoid ipoib_cm_dev_stop(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_cm_rx *p;\r\nunsigned long begin;\r\nint ret;\r\nif (!IPOIB_CM_SUPPORTED(dev->dev_addr) || !priv->cm.id)\r\nreturn;\r\nib_destroy_cm_id(priv->cm.id);\r\npriv->cm.id = NULL;\r\nspin_lock_irq(&priv->lock);\r\nwhile (!list_empty(&priv->cm.passive_ids)) {\r\np = list_entry(priv->cm.passive_ids.next, typeof(*p), list);\r\nlist_move(&p->list, &priv->cm.rx_error_list);\r\np->state = IPOIB_CM_RX_ERROR;\r\nspin_unlock_irq(&priv->lock);\r\nret = ib_modify_qp(p->qp, &ipoib_cm_err_attr, IB_QP_STATE);\r\nif (ret)\r\nipoib_warn(priv, "unable to move qp to error state: %d\n", ret);\r\nspin_lock_irq(&priv->lock);\r\n}\r\nbegin = jiffies;\r\nwhile (!list_empty(&priv->cm.rx_error_list) ||\r\n!list_empty(&priv->cm.rx_flush_list) ||\r\n!list_empty(&priv->cm.rx_drain_list)) {\r\nif (time_after(jiffies, begin + 5 * HZ)) {\r\nipoib_warn(priv, "RX drain timing out\n");\r\nlist_splice_init(&priv->cm.rx_flush_list,\r\n&priv->cm.rx_reap_list);\r\nlist_splice_init(&priv->cm.rx_error_list,\r\n&priv->cm.rx_reap_list);\r\nlist_splice_init(&priv->cm.rx_drain_list,\r\n&priv->cm.rx_reap_list);\r\nbreak;\r\n}\r\nspin_unlock_irq(&priv->lock);\r\nmsleep(1);\r\nipoib_drain_cq(dev);\r\nspin_lock_irq(&priv->lock);\r\n}\r\nspin_unlock_irq(&priv->lock);\r\nipoib_cm_free_rx_reap_list(dev);\r\ncancel_delayed_work(&priv->cm.stale_task);\r\n}\r\nstatic int ipoib_cm_rep_handler(struct ib_cm_id *cm_id, struct ib_cm_event *event)\r\n{\r\nstruct ipoib_cm_tx *p = cm_id->context;\r\nstruct ipoib_dev_priv *priv = netdev_priv(p->dev);\r\nstruct ipoib_cm_data *data = event->private_data;\r\nstruct sk_buff_head skqueue;\r\nstruct ib_qp_attr qp_attr;\r\nint qp_attr_mask, ret;\r\nstruct sk_buff *skb;\r\np->mtu = be32_to_cpu(data->mtu);\r\nif (p->mtu <= IPOIB_ENCAP_LEN) {\r\nipoib_warn(priv, "Rejecting connection: mtu %d <= %d\n",\r\np->mtu, IPOIB_ENCAP_LEN);\r\nreturn -EINVAL;\r\n}\r\nqp_attr.qp_state = IB_QPS_RTR;\r\nret = ib_cm_init_qp_attr(cm_id, &qp_attr, &qp_attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to init QP attr for RTR: %d\n", ret);\r\nreturn ret;\r\n}\r\nqp_attr.rq_psn = 0 ;\r\nret = ib_modify_qp(p->qp, &qp_attr, qp_attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify QP to RTR: %d\n", ret);\r\nreturn ret;\r\n}\r\nqp_attr.qp_state = IB_QPS_RTS;\r\nret = ib_cm_init_qp_attr(cm_id, &qp_attr, &qp_attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to init QP attr for RTS: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ib_modify_qp(p->qp, &qp_attr, qp_attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify QP to RTS: %d\n", ret);\r\nreturn ret;\r\n}\r\nskb_queue_head_init(&skqueue);\r\nspin_lock_irq(&priv->lock);\r\nset_bit(IPOIB_FLAG_OPER_UP, &p->flags);\r\nif (p->neigh)\r\nwhile ((skb = __skb_dequeue(&p->neigh->queue)))\r\n__skb_queue_tail(&skqueue, skb);\r\nspin_unlock_irq(&priv->lock);\r\nwhile ((skb = __skb_dequeue(&skqueue))) {\r\nskb->dev = p->dev;\r\nif (dev_queue_xmit(skb))\r\nipoib_warn(priv, "dev_queue_xmit failed "\r\n"to requeue packet\n");\r\n}\r\nret = ib_send_cm_rtu(cm_id, NULL, 0);\r\nif (ret) {\r\nipoib_warn(priv, "failed to send RTU: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct ib_qp *ipoib_cm_create_tx_qp(struct net_device *dev, struct ipoib_cm_tx *tx)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_qp_init_attr attr = {\r\n.send_cq = priv->recv_cq,\r\n.recv_cq = priv->recv_cq,\r\n.srq = priv->cm.srq,\r\n.cap.max_send_wr = ipoib_sendq_size,\r\n.cap.max_send_sge = 1,\r\n.sq_sig_type = IB_SIGNAL_ALL_WR,\r\n.qp_type = IB_QPT_RC,\r\n.qp_context = tx\r\n};\r\nreturn ib_create_qp(priv->pd, &attr);\r\n}\r\nstatic int ipoib_cm_send_req(struct net_device *dev,\r\nstruct ib_cm_id *id, struct ib_qp *qp,\r\nu32 qpn,\r\nstruct ib_sa_path_rec *pathrec)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_cm_data data = {};\r\nstruct ib_cm_req_param req = {};\r\ndata.qpn = cpu_to_be32(priv->qp->qp_num);\r\ndata.mtu = cpu_to_be32(IPOIB_CM_BUF_SIZE);\r\nreq.primary_path = pathrec;\r\nreq.alternate_path = NULL;\r\nreq.service_id = cpu_to_be64(IPOIB_CM_IETF_ID | qpn);\r\nreq.qp_num = qp->qp_num;\r\nreq.qp_type = qp->qp_type;\r\nreq.private_data = &data;\r\nreq.private_data_len = sizeof data;\r\nreq.flow_control = 0;\r\nreq.starting_psn = 0;\r\nreq.responder_resources = 4;\r\nreq.remote_cm_response_timeout = 20;\r\nreq.local_cm_response_timeout = 20;\r\nreq.retry_count = 0;\r\nreq.rnr_retry_count = 0;\r\nreq.max_cm_retries = 15;\r\nreq.srq = ipoib_cm_has_srq(dev);\r\nreturn ib_send_cm_req(id, &req);\r\n}\r\nstatic int ipoib_cm_modify_tx_init(struct net_device *dev,\r\nstruct ib_cm_id *cm_id, struct ib_qp *qp)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_qp_attr qp_attr;\r\nint qp_attr_mask, ret;\r\nret = ib_find_pkey(priv->ca, priv->port, priv->pkey, &qp_attr.pkey_index);\r\nif (ret) {\r\nipoib_warn(priv, "pkey 0x%x not found: %d\n", priv->pkey, ret);\r\nreturn ret;\r\n}\r\nqp_attr.qp_state = IB_QPS_INIT;\r\nqp_attr.qp_access_flags = IB_ACCESS_LOCAL_WRITE;\r\nqp_attr.port_num = priv->port;\r\nqp_attr_mask = IB_QP_STATE | IB_QP_ACCESS_FLAGS | IB_QP_PKEY_INDEX | IB_QP_PORT;\r\nret = ib_modify_qp(qp, &qp_attr, qp_attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify tx QP to INIT: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipoib_cm_tx_init(struct ipoib_cm_tx *p, u32 qpn,\r\nstruct ib_sa_path_rec *pathrec)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(p->dev);\r\nint ret;\r\np->tx_ring = vzalloc(ipoib_sendq_size * sizeof *p->tx_ring);\r\nif (!p->tx_ring) {\r\nipoib_warn(priv, "failed to allocate tx ring\n");\r\nret = -ENOMEM;\r\ngoto err_tx;\r\n}\r\np->qp = ipoib_cm_create_tx_qp(p->dev, p);\r\nif (IS_ERR(p->qp)) {\r\nret = PTR_ERR(p->qp);\r\nipoib_warn(priv, "failed to allocate tx qp: %d\n", ret);\r\ngoto err_qp;\r\n}\r\np->id = ib_create_cm_id(priv->ca, ipoib_cm_tx_handler, p);\r\nif (IS_ERR(p->id)) {\r\nret = PTR_ERR(p->id);\r\nipoib_warn(priv, "failed to create tx cm id: %d\n", ret);\r\ngoto err_id;\r\n}\r\nret = ipoib_cm_modify_tx_init(p->dev, p->id, p->qp);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify tx qp to rtr: %d\n", ret);\r\ngoto err_modify;\r\n}\r\nret = ipoib_cm_send_req(p->dev, p->id, p->qp, qpn, pathrec);\r\nif (ret) {\r\nipoib_warn(priv, "failed to send cm req: %d\n", ret);\r\ngoto err_send_cm;\r\n}\r\nipoib_dbg(priv, "Request connection 0x%x for gid %pI6 qpn 0x%x\n",\r\np->qp->qp_num, pathrec->dgid.raw, qpn);\r\nreturn 0;\r\nerr_send_cm:\r\nerr_modify:\r\nib_destroy_cm_id(p->id);\r\nerr_id:\r\np->id = NULL;\r\nib_destroy_qp(p->qp);\r\nerr_qp:\r\np->qp = NULL;\r\nvfree(p->tx_ring);\r\nerr_tx:\r\nreturn ret;\r\n}\r\nstatic void ipoib_cm_tx_destroy(struct ipoib_cm_tx *p)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(p->dev);\r\nstruct ipoib_cm_tx_buf *tx_req;\r\nunsigned long begin;\r\nipoib_dbg(priv, "Destroy active connection 0x%x head 0x%x tail 0x%x\n",\r\np->qp ? p->qp->qp_num : 0, p->tx_head, p->tx_tail);\r\nif (p->id)\r\nib_destroy_cm_id(p->id);\r\nif (p->tx_ring) {\r\nbegin = jiffies;\r\nwhile ((int) p->tx_tail - (int) p->tx_head < 0) {\r\nif (time_after(jiffies, begin + 5 * HZ)) {\r\nipoib_warn(priv, "timing out; %d sends not completed\n",\r\np->tx_head - p->tx_tail);\r\ngoto timeout;\r\n}\r\nmsleep(1);\r\n}\r\n}\r\ntimeout:\r\nwhile ((int) p->tx_tail - (int) p->tx_head < 0) {\r\ntx_req = &p->tx_ring[p->tx_tail & (ipoib_sendq_size - 1)];\r\nib_dma_unmap_single(priv->ca, tx_req->mapping, tx_req->skb->len,\r\nDMA_TO_DEVICE);\r\ndev_kfree_skb_any(tx_req->skb);\r\n++p->tx_tail;\r\nnetif_tx_lock_bh(p->dev);\r\nif (unlikely(--priv->tx_outstanding == ipoib_sendq_size >> 1) &&\r\nnetif_queue_stopped(p->dev) &&\r\ntest_bit(IPOIB_FLAG_ADMIN_UP, &priv->flags))\r\nnetif_wake_queue(p->dev);\r\nnetif_tx_unlock_bh(p->dev);\r\n}\r\nif (p->qp)\r\nib_destroy_qp(p->qp);\r\nvfree(p->tx_ring);\r\nkfree(p);\r\n}\r\nstatic int ipoib_cm_tx_handler(struct ib_cm_id *cm_id,\r\nstruct ib_cm_event *event)\r\n{\r\nstruct ipoib_cm_tx *tx = cm_id->context;\r\nstruct ipoib_dev_priv *priv = netdev_priv(tx->dev);\r\nstruct net_device *dev = priv->dev;\r\nstruct ipoib_neigh *neigh;\r\nunsigned long flags;\r\nint ret;\r\nswitch (event->event) {\r\ncase IB_CM_DREQ_RECEIVED:\r\nipoib_dbg(priv, "DREQ received.\n");\r\nib_send_cm_drep(cm_id, NULL, 0);\r\nbreak;\r\ncase IB_CM_REP_RECEIVED:\r\nipoib_dbg(priv, "REP received.\n");\r\nret = ipoib_cm_rep_handler(cm_id, event);\r\nif (ret)\r\nib_send_cm_rej(cm_id, IB_CM_REJ_CONSUMER_DEFINED,\r\nNULL, 0, NULL, 0);\r\nbreak;\r\ncase IB_CM_REQ_ERROR:\r\ncase IB_CM_REJ_RECEIVED:\r\ncase IB_CM_TIMEWAIT_EXIT:\r\nipoib_dbg(priv, "CM error %d.\n", event->event);\r\nnetif_tx_lock_bh(dev);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nneigh = tx->neigh;\r\nif (neigh) {\r\nneigh->cm = NULL;\r\nipoib_neigh_free(neigh);\r\ntx->neigh = NULL;\r\n}\r\nif (test_and_clear_bit(IPOIB_FLAG_INITIALIZED, &tx->flags)) {\r\nlist_move(&tx->list, &priv->cm.reap_list);\r\nqueue_work(ipoib_workqueue, &priv->cm.reap_task);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nnetif_tx_unlock_bh(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstruct ipoib_cm_tx *ipoib_cm_create_tx(struct net_device *dev, struct ipoib_path *path,\r\nstruct ipoib_neigh *neigh)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_cm_tx *tx;\r\ntx = kzalloc(sizeof *tx, GFP_ATOMIC);\r\nif (!tx)\r\nreturn NULL;\r\nneigh->cm = tx;\r\ntx->neigh = neigh;\r\ntx->path = path;\r\ntx->dev = dev;\r\nlist_add(&tx->list, &priv->cm.start_list);\r\nset_bit(IPOIB_FLAG_INITIALIZED, &tx->flags);\r\nqueue_work(ipoib_workqueue, &priv->cm.start_task);\r\nreturn tx;\r\n}\r\nvoid ipoib_cm_destroy_tx(struct ipoib_cm_tx *tx)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(tx->dev);\r\nunsigned long flags;\r\nif (test_and_clear_bit(IPOIB_FLAG_INITIALIZED, &tx->flags)) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\nlist_move(&tx->list, &priv->cm.reap_list);\r\nqueue_work(ipoib_workqueue, &priv->cm.reap_task);\r\nipoib_dbg(priv, "Reap connection for gid %pI6\n",\r\ntx->neigh->daddr + 4);\r\ntx->neigh = NULL;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\n}\r\nstatic void ipoib_cm_tx_start(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,\r\ncm.start_task);\r\nstruct net_device *dev = priv->dev;\r\nstruct ipoib_neigh *neigh;\r\nstruct ipoib_cm_tx *p;\r\nunsigned long flags;\r\nint ret;\r\nstruct ib_sa_path_rec pathrec;\r\nu32 qpn;\r\nnetif_tx_lock_bh(dev);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nwhile (!list_empty(&priv->cm.start_list)) {\r\np = list_entry(priv->cm.start_list.next, typeof(*p), list);\r\nlist_del_init(&p->list);\r\nneigh = p->neigh;\r\nqpn = IPOIB_QPN(neigh->daddr);\r\nmemcpy(&pathrec, &p->path->pathrec, sizeof pathrec);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nnetif_tx_unlock_bh(dev);\r\nret = ipoib_cm_tx_init(p, qpn, &pathrec);\r\nnetif_tx_lock_bh(dev);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (ret) {\r\nneigh = p->neigh;\r\nif (neigh) {\r\nneigh->cm = NULL;\r\nipoib_neigh_free(neigh);\r\n}\r\nlist_del(&p->list);\r\nkfree(p);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nnetif_tx_unlock_bh(dev);\r\n}\r\nstatic void ipoib_cm_tx_reap(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,\r\ncm.reap_task);\r\nstruct net_device *dev = priv->dev;\r\nstruct ipoib_cm_tx *p;\r\nunsigned long flags;\r\nnetif_tx_lock_bh(dev);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nwhile (!list_empty(&priv->cm.reap_list)) {\r\np = list_entry(priv->cm.reap_list.next, typeof(*p), list);\r\nlist_del(&p->list);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nnetif_tx_unlock_bh(dev);\r\nipoib_cm_tx_destroy(p);\r\nnetif_tx_lock_bh(dev);\r\nspin_lock_irqsave(&priv->lock, flags);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nnetif_tx_unlock_bh(dev);\r\n}\r\nstatic void ipoib_cm_skb_reap(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,\r\ncm.skb_task);\r\nstruct net_device *dev = priv->dev;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nunsigned mtu = priv->mcast_mtu;\r\nnetif_tx_lock_bh(dev);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nwhile ((skb = skb_dequeue(&priv->cm.skb_queue))) {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nnetif_tx_unlock_bh(dev);\r\nif (skb->protocol == htons(ETH_P_IP))\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED, htonl(mtu));\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse if (skb->protocol == htons(ETH_P_IPV6))\r\nicmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\r\n#endif\r\ndev_kfree_skb_any(skb);\r\nnetif_tx_lock_bh(dev);\r\nspin_lock_irqsave(&priv->lock, flags);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nnetif_tx_unlock_bh(dev);\r\n}\r\nvoid ipoib_cm_skb_too_long(struct net_device *dev, struct sk_buff *skb,\r\nunsigned int mtu)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nint e = skb_queue_empty(&priv->cm.skb_queue);\r\nif (skb_dst(skb))\r\nskb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL, skb, mtu);\r\nskb_queue_tail(&priv->cm.skb_queue, skb);\r\nif (e)\r\nqueue_work(ipoib_workqueue, &priv->cm.skb_task);\r\n}\r\nstatic void ipoib_cm_rx_reap(struct work_struct *work)\r\n{\r\nipoib_cm_free_rx_reap_list(container_of(work, struct ipoib_dev_priv,\r\ncm.rx_reap_task)->dev);\r\n}\r\nstatic void ipoib_cm_stale_task(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,\r\ncm.stale_task.work);\r\nstruct ipoib_cm_rx *p;\r\nint ret;\r\nspin_lock_irq(&priv->lock);\r\nwhile (!list_empty(&priv->cm.passive_ids)) {\r\np = list_entry(priv->cm.passive_ids.prev, typeof(*p), list);\r\nif (time_before_eq(jiffies, p->jiffies + IPOIB_CM_RX_TIMEOUT))\r\nbreak;\r\nlist_move(&p->list, &priv->cm.rx_error_list);\r\np->state = IPOIB_CM_RX_ERROR;\r\nspin_unlock_irq(&priv->lock);\r\nret = ib_modify_qp(p->qp, &ipoib_cm_err_attr, IB_QP_STATE);\r\nif (ret)\r\nipoib_warn(priv, "unable to move qp to error state: %d\n", ret);\r\nspin_lock_irq(&priv->lock);\r\n}\r\nif (!list_empty(&priv->cm.passive_ids))\r\nqueue_delayed_work(ipoib_workqueue,\r\n&priv->cm.stale_task, IPOIB_CM_RX_DELAY);\r\nspin_unlock_irq(&priv->lock);\r\n}\r\nstatic ssize_t show_mode(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(to_net_dev(d));\r\nif (test_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags))\r\nreturn sprintf(buf, "connected\n");\r\nelse\r\nreturn sprintf(buf, "datagram\n");\r\n}\r\nstatic ssize_t set_mode(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct net_device *dev = to_net_dev(d);\r\nint ret;\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\nret = ipoib_set_mode(dev, buf);\r\nrtnl_unlock();\r\nif (!ret)\r\nreturn count;\r\nreturn ret;\r\n}\r\nint ipoib_cm_add_mode_attr(struct net_device *dev)\r\n{\r\nreturn device_create_file(&dev->dev, &dev_attr_mode);\r\n}\r\nstatic void ipoib_cm_create_srq(struct net_device *dev, int max_sge)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_srq_init_attr srq_init_attr = {\r\n.srq_type = IB_SRQT_BASIC,\r\n.attr = {\r\n.max_wr = ipoib_recvq_size,\r\n.max_sge = max_sge\r\n}\r\n};\r\npriv->cm.srq = ib_create_srq(priv->pd, &srq_init_attr);\r\nif (IS_ERR(priv->cm.srq)) {\r\nif (PTR_ERR(priv->cm.srq) != -ENOSYS)\r\nprintk(KERN_WARNING "%s: failed to allocate SRQ, error %ld\n",\r\npriv->ca->name, PTR_ERR(priv->cm.srq));\r\npriv->cm.srq = NULL;\r\nreturn;\r\n}\r\npriv->cm.srq_ring = vzalloc(ipoib_recvq_size * sizeof *priv->cm.srq_ring);\r\nif (!priv->cm.srq_ring) {\r\nprintk(KERN_WARNING "%s: failed to allocate CM SRQ ring (%d entries)\n",\r\npriv->ca->name, ipoib_recvq_size);\r\nib_destroy_srq(priv->cm.srq);\r\npriv->cm.srq = NULL;\r\nreturn;\r\n}\r\n}\r\nint ipoib_cm_dev_init(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nint i, ret;\r\nstruct ib_device_attr attr;\r\nINIT_LIST_HEAD(&priv->cm.passive_ids);\r\nINIT_LIST_HEAD(&priv->cm.reap_list);\r\nINIT_LIST_HEAD(&priv->cm.start_list);\r\nINIT_LIST_HEAD(&priv->cm.rx_error_list);\r\nINIT_LIST_HEAD(&priv->cm.rx_flush_list);\r\nINIT_LIST_HEAD(&priv->cm.rx_drain_list);\r\nINIT_LIST_HEAD(&priv->cm.rx_reap_list);\r\nINIT_WORK(&priv->cm.start_task, ipoib_cm_tx_start);\r\nINIT_WORK(&priv->cm.reap_task, ipoib_cm_tx_reap);\r\nINIT_WORK(&priv->cm.skb_task, ipoib_cm_skb_reap);\r\nINIT_WORK(&priv->cm.rx_reap_task, ipoib_cm_rx_reap);\r\nINIT_DELAYED_WORK(&priv->cm.stale_task, ipoib_cm_stale_task);\r\nskb_queue_head_init(&priv->cm.skb_queue);\r\nret = ib_query_device(priv->ca, &attr);\r\nif (ret) {\r\nprintk(KERN_WARNING "ib_query_device() failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nipoib_dbg(priv, "max_srq_sge=%d\n", attr.max_srq_sge);\r\nattr.max_srq_sge = min_t(int, IPOIB_CM_RX_SG, attr.max_srq_sge);\r\nipoib_cm_create_srq(dev, attr.max_srq_sge);\r\nif (ipoib_cm_has_srq(dev)) {\r\npriv->cm.max_cm_mtu = attr.max_srq_sge * PAGE_SIZE - 0x10;\r\npriv->cm.num_frags = attr.max_srq_sge;\r\nipoib_dbg(priv, "max_cm_mtu = 0x%x, num_frags=%d\n",\r\npriv->cm.max_cm_mtu, priv->cm.num_frags);\r\n} else {\r\npriv->cm.max_cm_mtu = IPOIB_CM_MTU;\r\npriv->cm.num_frags = IPOIB_CM_RX_SG;\r\n}\r\nipoib_cm_init_rx_wr(dev, &priv->cm.rx_wr, priv->cm.rx_sge);\r\nif (ipoib_cm_has_srq(dev)) {\r\nfor (i = 0; i < ipoib_recvq_size; ++i) {\r\nif (!ipoib_cm_alloc_rx_skb(dev, priv->cm.srq_ring, i,\r\npriv->cm.num_frags - 1,\r\npriv->cm.srq_ring[i].mapping,\r\nGFP_KERNEL)) {\r\nipoib_warn(priv, "failed to allocate "\r\n"receive buffer %d\n", i);\r\nipoib_cm_dev_cleanup(dev);\r\nreturn -ENOMEM;\r\n}\r\nif (ipoib_cm_post_receive_srq(dev, i)) {\r\nipoib_warn(priv, "ipoib_cm_post_receive_srq "\r\n"failed for buf %d\n", i);\r\nipoib_cm_dev_cleanup(dev);\r\nreturn -EIO;\r\n}\r\n}\r\n}\r\npriv->dev->dev_addr[0] = IPOIB_FLAGS_RC;\r\nreturn 0;\r\n}\r\nvoid ipoib_cm_dev_cleanup(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nint ret;\r\nif (!priv->cm.srq)\r\nreturn;\r\nipoib_dbg(priv, "Cleanup ipoib connected mode.\n");\r\nret = ib_destroy_srq(priv->cm.srq);\r\nif (ret)\r\nipoib_warn(priv, "ib_destroy_srq failed: %d\n", ret);\r\npriv->cm.srq = NULL;\r\nif (!priv->cm.srq_ring)\r\nreturn;\r\nipoib_cm_free_rx_ring(dev, priv->cm.srq_ring);\r\npriv->cm.srq_ring = NULL;\r\n}
