static int nxt6000_writereg(struct nxt6000_state* state, u8 reg, u8 data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = {.addr = state->config->demod_address,.flags = 0,.buf = buf,.len = 2 };\r\nint ret;\r\nif ((ret = i2c_transfer(state->i2c, &msg, 1)) != 1)\r\ndprintk("nxt6000: nxt6000_write error (reg: 0x%02X, data: 0x%02X, ret: %d)\n", reg, data, ret);\r\nreturn (ret != 1) ? -EIO : 0;\r\n}\r\nstatic u8 nxt6000_readreg(struct nxt6000_state* state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msgs[] = {\r\n{.addr = state->config->demod_address,.flags = 0,.buf = b0,.len = 1},\r\n{.addr = state->config->demod_address,.flags = I2C_M_RD,.buf = b1,.len = 1}\r\n};\r\nret = i2c_transfer(state->i2c, msgs, 2);\r\nif (ret != 2)\r\ndprintk("nxt6000: nxt6000_read error (reg: 0x%02X, ret: %d)\n", reg, ret);\r\nreturn b1[0];\r\n}\r\nstatic void nxt6000_reset(struct nxt6000_state* state)\r\n{\r\nu8 val;\r\nval = nxt6000_readreg(state, OFDM_COR_CTL);\r\nnxt6000_writereg(state, OFDM_COR_CTL, val & ~COREACT);\r\nnxt6000_writereg(state, OFDM_COR_CTL, val | COREACT);\r\n}\r\nstatic int nxt6000_set_bandwidth(struct nxt6000_state *state, u32 bandwidth)\r\n{\r\nu16 nominal_rate;\r\nint result;\r\nswitch (bandwidth) {\r\ncase 6000000:\r\nnominal_rate = 0x55B7;\r\nbreak;\r\ncase 7000000:\r\nnominal_rate = 0x6400;\r\nbreak;\r\ncase 8000000:\r\nnominal_rate = 0x7249;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((result = nxt6000_writereg(state, OFDM_TRL_NOMINALRATE_1, nominal_rate & 0xFF)) < 0)\r\nreturn result;\r\nreturn nxt6000_writereg(state, OFDM_TRL_NOMINALRATE_2, (nominal_rate >> 8) & 0xFF);\r\n}\r\nstatic int nxt6000_set_guard_interval(struct nxt6000_state* state, fe_guard_interval_t guard_interval)\r\n{\r\nswitch (guard_interval) {\r\ncase GUARD_INTERVAL_1_32:\r\nreturn nxt6000_writereg(state, OFDM_COR_MODEGUARD, 0x00 | (nxt6000_readreg(state, OFDM_COR_MODEGUARD) & ~0x03));\r\ncase GUARD_INTERVAL_1_16:\r\nreturn nxt6000_writereg(state, OFDM_COR_MODEGUARD, 0x01 | (nxt6000_readreg(state, OFDM_COR_MODEGUARD) & ~0x03));\r\ncase GUARD_INTERVAL_AUTO:\r\ncase GUARD_INTERVAL_1_8:\r\nreturn nxt6000_writereg(state, OFDM_COR_MODEGUARD, 0x02 | (nxt6000_readreg(state, OFDM_COR_MODEGUARD) & ~0x03));\r\ncase GUARD_INTERVAL_1_4:\r\nreturn nxt6000_writereg(state, OFDM_COR_MODEGUARD, 0x03 | (nxt6000_readreg(state, OFDM_COR_MODEGUARD) & ~0x03));\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int nxt6000_set_inversion(struct nxt6000_state* state, fe_spectral_inversion_t inversion)\r\n{\r\nswitch (inversion) {\r\ncase INVERSION_OFF:\r\nreturn nxt6000_writereg(state, OFDM_ITB_CTL, 0x00);\r\ncase INVERSION_ON:\r\nreturn nxt6000_writereg(state, OFDM_ITB_CTL, ITBINV);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int nxt6000_set_transmission_mode(struct nxt6000_state* state, fe_transmit_mode_t transmission_mode)\r\n{\r\nint result;\r\nswitch (transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nif ((result = nxt6000_writereg(state, EN_DMD_RACQ, 0x00 | (nxt6000_readreg(state, EN_DMD_RACQ) & ~0x03))) < 0)\r\nreturn result;\r\nreturn nxt6000_writereg(state, OFDM_COR_MODEGUARD, (0x00 << 2) | (nxt6000_readreg(state, OFDM_COR_MODEGUARD) & ~0x04));\r\ncase TRANSMISSION_MODE_8K:\r\ncase TRANSMISSION_MODE_AUTO:\r\nif ((result = nxt6000_writereg(state, EN_DMD_RACQ, 0x02 | (nxt6000_readreg(state, EN_DMD_RACQ) & ~0x03))) < 0)\r\nreturn result;\r\nreturn nxt6000_writereg(state, OFDM_COR_MODEGUARD, (0x01 << 2) | (nxt6000_readreg(state, OFDM_COR_MODEGUARD) & ~0x04));\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void nxt6000_setup(struct dvb_frontend* fe)\r\n{\r\nstruct nxt6000_state* state = fe->demodulator_priv;\r\nnxt6000_writereg(state, RS_COR_SYNC_PARAM, SYNC_PARAM);\r\nnxt6000_writereg(state, BER_CTRL, (0x01 << 1) | 0x01);\r\nnxt6000_writereg(state, VIT_BERTIME_2, 0x00);\r\nnxt6000_writereg(state, VIT_BERTIME_1, 0x02);\r\nnxt6000_writereg(state, VIT_BERTIME_0, 0x00);\r\nnxt6000_writereg(state, VIT_COR_INTEN, 0x98);\r\nnxt6000_writereg(state, VIT_COR_CTL, 0x82);\r\nnxt6000_writereg(state, VIT_COR_CTL, VIT_COR_RESYNC | 0x02 );\r\nnxt6000_writereg(state, OFDM_COR_CTL, (0x01 << 5) | (nxt6000_readreg(state, OFDM_COR_CTL) & 0x0F));\r\nnxt6000_writereg(state, OFDM_COR_MODEGUARD, FORCEMODE8K | 0x02);\r\nnxt6000_writereg(state, OFDM_AGC_CTL, AGCLAST | INITIAL_AGC_BW);\r\nnxt6000_writereg(state, OFDM_ITB_FREQ_1, 0x06);\r\nnxt6000_writereg(state, OFDM_ITB_FREQ_2, 0x31);\r\nnxt6000_writereg(state, OFDM_CAS_CTL, (0x01 << 7) | (0x02 << 3) | 0x04);\r\nnxt6000_writereg(state, CAS_FREQ, 0xBB);\r\nnxt6000_writereg(state, OFDM_SYR_CTL, 1 << 2);\r\nnxt6000_writereg(state, OFDM_PPM_CTL_1, PPM256);\r\nnxt6000_writereg(state, OFDM_TRL_NOMINALRATE_1, 0x49);\r\nnxt6000_writereg(state, OFDM_TRL_NOMINALRATE_2, 0x72);\r\nnxt6000_writereg(state, ANALOG_CONTROL_0, 1 << 5);\r\nnxt6000_writereg(state, EN_DMD_RACQ, (1 << 7) | (3 << 4) | 2);\r\nnxt6000_writereg(state, DIAG_CONFIG, TB_SET);\r\nif (state->config->clock_inversion)\r\nnxt6000_writereg(state, SUB_DIAG_MODE_SEL, CLKINVERSION);\r\nelse\r\nnxt6000_writereg(state, SUB_DIAG_MODE_SEL, 0);\r\nnxt6000_writereg(state, TS_FORMAT, 0);\r\n}\r\nstatic void nxt6000_dump_status(struct nxt6000_state *state)\r\n{\r\nu8 val;\r\nprintk("NXT6000 status:");\r\nval = nxt6000_readreg(state, RS_COR_STAT);\r\nprintk(" DATA DESCR LOCK: %d,", val & 0x01);\r\nprintk(" DATA SYNC LOCK: %d,", (val >> 1) & 0x01);\r\nval = nxt6000_readreg(state, VIT_SYNC_STATUS);\r\nprintk(" VITERBI LOCK: %d,", (val >> 7) & 0x01);\r\nswitch ((val >> 4) & 0x07) {\r\ncase 0x00:\r\nprintk(" VITERBI CODERATE: 1/2,");\r\nbreak;\r\ncase 0x01:\r\nprintk(" VITERBI CODERATE: 2/3,");\r\nbreak;\r\ncase 0x02:\r\nprintk(" VITERBI CODERATE: 3/4,");\r\nbreak;\r\ncase 0x03:\r\nprintk(" VITERBI CODERATE: 5/6,");\r\nbreak;\r\ncase 0x04:\r\nprintk(" VITERBI CODERATE: 7/8,");\r\nbreak;\r\ndefault:\r\nprintk(" VITERBI CODERATE: Reserved,");\r\n}\r\nval = nxt6000_readreg(state, OFDM_COR_STAT);\r\nprintk(" CHCTrack: %d,", (val >> 7) & 0x01);\r\nprintk(" TPSLock: %d,", (val >> 6) & 0x01);\r\nprintk(" SYRLock: %d,", (val >> 5) & 0x01);\r\nprintk(" AGCLock: %d,", (val >> 4) & 0x01);\r\nswitch (val & 0x0F) {\r\ncase 0x00:\r\nprintk(" CoreState: IDLE,");\r\nbreak;\r\ncase 0x02:\r\nprintk(" CoreState: WAIT_AGC,");\r\nbreak;\r\ncase 0x03:\r\nprintk(" CoreState: WAIT_SYR,");\r\nbreak;\r\ncase 0x04:\r\nprintk(" CoreState: WAIT_PPM,");\r\nbreak;\r\ncase 0x01:\r\nprintk(" CoreState: WAIT_TRL,");\r\nbreak;\r\ncase 0x05:\r\nprintk(" CoreState: WAIT_TPS,");\r\nbreak;\r\ncase 0x06:\r\nprintk(" CoreState: MONITOR_TPS,");\r\nbreak;\r\ndefault:\r\nprintk(" CoreState: Reserved,");\r\n}\r\nval = nxt6000_readreg(state, OFDM_SYR_STAT);\r\nprintk(" SYRLock: %d,", (val >> 4) & 0x01);\r\nprintk(" SYRMode: %s,", (val >> 2) & 0x01 ? "8K" : "2K");\r\nswitch ((val >> 4) & 0x03) {\r\ncase 0x00:\r\nprintk(" SYRGuard: 1/32,");\r\nbreak;\r\ncase 0x01:\r\nprintk(" SYRGuard: 1/16,");\r\nbreak;\r\ncase 0x02:\r\nprintk(" SYRGuard: 1/8,");\r\nbreak;\r\ncase 0x03:\r\nprintk(" SYRGuard: 1/4,");\r\nbreak;\r\n}\r\nval = nxt6000_readreg(state, OFDM_TPS_RCVD_3);\r\nswitch ((val >> 4) & 0x07) {\r\ncase 0x00:\r\nprintk(" TPSLP: 1/2,");\r\nbreak;\r\ncase 0x01:\r\nprintk(" TPSLP: 2/3,");\r\nbreak;\r\ncase 0x02:\r\nprintk(" TPSLP: 3/4,");\r\nbreak;\r\ncase 0x03:\r\nprintk(" TPSLP: 5/6,");\r\nbreak;\r\ncase 0x04:\r\nprintk(" TPSLP: 7/8,");\r\nbreak;\r\ndefault:\r\nprintk(" TPSLP: Reserved,");\r\n}\r\nswitch (val & 0x07) {\r\ncase 0x00:\r\nprintk(" TPSHP: 1/2,");\r\nbreak;\r\ncase 0x01:\r\nprintk(" TPSHP: 2/3,");\r\nbreak;\r\ncase 0x02:\r\nprintk(" TPSHP: 3/4,");\r\nbreak;\r\ncase 0x03:\r\nprintk(" TPSHP: 5/6,");\r\nbreak;\r\ncase 0x04:\r\nprintk(" TPSHP: 7/8,");\r\nbreak;\r\ndefault:\r\nprintk(" TPSHP: Reserved,");\r\n}\r\nval = nxt6000_readreg(state, OFDM_TPS_RCVD_4);\r\nprintk(" TPSMode: %s,", val & 0x01 ? "8K" : "2K");\r\nswitch ((val >> 4) & 0x03) {\r\ncase 0x00:\r\nprintk(" TPSGuard: 1/32,");\r\nbreak;\r\ncase 0x01:\r\nprintk(" TPSGuard: 1/16,");\r\nbreak;\r\ncase 0x02:\r\nprintk(" TPSGuard: 1/8,");\r\nbreak;\r\ncase 0x03:\r\nprintk(" TPSGuard: 1/4,");\r\nbreak;\r\n}\r\nnxt6000_readreg(state, RF_AGC_VAL_1);\r\nval = nxt6000_readreg(state, RF_AGC_STATUS);\r\nval = nxt6000_readreg(state, RF_AGC_STATUS);\r\nprintk(" RF AGC LOCK: %d,", (val >> 4) & 0x01);\r\nprintk("\n");\r\n}\r\nstatic int nxt6000_read_status(struct dvb_frontend* fe, fe_status_t* status)\r\n{\r\nu8 core_status;\r\nstruct nxt6000_state* state = fe->demodulator_priv;\r\n*status = 0;\r\ncore_status = nxt6000_readreg(state, OFDM_COR_STAT);\r\nif (core_status & AGCLOCKED)\r\n*status |= FE_HAS_SIGNAL;\r\nif (nxt6000_readreg(state, OFDM_SYR_STAT) & GI14_SYR_LOCK)\r\n*status |= FE_HAS_CARRIER;\r\nif (nxt6000_readreg(state, VIT_SYNC_STATUS) & VITINSYNC)\r\n*status |= FE_HAS_VITERBI;\r\nif (nxt6000_readreg(state, RS_COR_STAT) & RSCORESTATUS)\r\n*status |= FE_HAS_SYNC;\r\nif ((core_status & TPSLOCKED) && (*status == (FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC)))\r\n*status |= FE_HAS_LOCK;\r\nif (debug)\r\nnxt6000_dump_status(state);\r\nreturn 0;\r\n}\r\nstatic int nxt6000_init(struct dvb_frontend* fe)\r\n{\r\nstruct nxt6000_state* state = fe->demodulator_priv;\r\nnxt6000_reset(state);\r\nnxt6000_setup(fe);\r\nreturn 0;\r\n}\r\nstatic int nxt6000_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct nxt6000_state* state = fe->demodulator_priv;\r\nint result;\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nresult = nxt6000_set_bandwidth(state, p->bandwidth_hz);\r\nif (result < 0)\r\nreturn result;\r\nresult = nxt6000_set_guard_interval(state, p->guard_interval);\r\nif (result < 0)\r\nreturn result;\r\nresult = nxt6000_set_transmission_mode(state, p->transmission_mode);\r\nif (result < 0)\r\nreturn result;\r\nresult = nxt6000_set_inversion(state, p->inversion);\r\nif (result < 0)\r\nreturn result;\r\nmsleep(500);\r\nreturn 0;\r\n}\r\nstatic void nxt6000_release(struct dvb_frontend* fe)\r\n{\r\nstruct nxt6000_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstatic int nxt6000_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct nxt6000_state* state = fe->demodulator_priv;\r\n*snr = nxt6000_readreg( state, OFDM_CHC_SNR) / 8;\r\nreturn 0;\r\n}\r\nstatic int nxt6000_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct nxt6000_state* state = fe->demodulator_priv;\r\nnxt6000_writereg( state, VIT_COR_INTSTAT, 0x18 );\r\n*ber = (nxt6000_readreg( state, VIT_BER_1 ) << 8 ) |\r\nnxt6000_readreg( state, VIT_BER_0 );\r\nnxt6000_writereg( state, VIT_COR_INTSTAT, 0x18);\r\nreturn 0;\r\n}\r\nstatic int nxt6000_read_signal_strength(struct dvb_frontend* fe, u16* signal_strength)\r\n{\r\nstruct nxt6000_state* state = fe->demodulator_priv;\r\n*signal_strength = (short) (511 -\r\n(nxt6000_readreg(state, AGC_GAIN_1) +\r\n((nxt6000_readreg(state, AGC_GAIN_2) & 0x03) << 8)));\r\nreturn 0;\r\n}\r\nstatic int nxt6000_fe_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 500;\r\nreturn 0;\r\n}\r\nstatic int nxt6000_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\r\n{\r\nstruct nxt6000_state* state = fe->demodulator_priv;\r\nif (enable) {\r\nreturn nxt6000_writereg(state, ENABLE_TUNER_IIC, 0x01);\r\n} else {\r\nreturn nxt6000_writereg(state, ENABLE_TUNER_IIC, 0x00);\r\n}\r\n}\r\nstruct dvb_frontend* nxt6000_attach(const struct nxt6000_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct nxt6000_state* state = NULL;\r\nstate = kzalloc(sizeof(struct nxt6000_state), GFP_KERNEL);\r\nif (state == NULL) goto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nif (nxt6000_readreg(state, OFDM_MSC_REV) != NXT6000ASICDEVICE) goto error;\r\nmemcpy(&state->frontend.ops, &nxt6000_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
