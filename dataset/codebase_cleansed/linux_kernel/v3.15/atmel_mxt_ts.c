static bool mxt_object_readable(unsigned int type)\r\n{\r\nswitch (type) {\r\ncase MXT_GEN_COMMAND_T6:\r\ncase MXT_GEN_POWER_T7:\r\ncase MXT_GEN_ACQUIRE_T8:\r\ncase MXT_GEN_DATASOURCE_T53:\r\ncase MXT_TOUCH_MULTI_T9:\r\ncase MXT_TOUCH_KEYARRAY_T15:\r\ncase MXT_TOUCH_PROXIMITY_T23:\r\ncase MXT_TOUCH_PROXKEY_T52:\r\ncase MXT_PROCI_GRIPFACE_T20:\r\ncase MXT_PROCG_NOISE_T22:\r\ncase MXT_PROCI_ONETOUCH_T24:\r\ncase MXT_PROCI_TWOTOUCH_T27:\r\ncase MXT_PROCI_GRIP_T40:\r\ncase MXT_PROCI_PALM_T41:\r\ncase MXT_PROCI_TOUCHSUPPRESSION_T42:\r\ncase MXT_PROCI_STYLUS_T47:\r\ncase MXT_PROCG_NOISESUPPRESSION_T48:\r\ncase MXT_SPT_COMMSCONFIG_T18:\r\ncase MXT_SPT_GPIOPWM_T19:\r\ncase MXT_SPT_SELFTEST_T25:\r\ncase MXT_SPT_CTECONFIG_T28:\r\ncase MXT_SPT_USERDATA_T38:\r\ncase MXT_SPT_DIGITIZER_T43:\r\ncase MXT_SPT_CTECONFIG_T46:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool mxt_object_writable(unsigned int type)\r\n{\r\nswitch (type) {\r\ncase MXT_GEN_COMMAND_T6:\r\ncase MXT_GEN_POWER_T7:\r\ncase MXT_GEN_ACQUIRE_T8:\r\ncase MXT_TOUCH_MULTI_T9:\r\ncase MXT_TOUCH_KEYARRAY_T15:\r\ncase MXT_TOUCH_PROXIMITY_T23:\r\ncase MXT_TOUCH_PROXKEY_T52:\r\ncase MXT_PROCI_GRIPFACE_T20:\r\ncase MXT_PROCG_NOISE_T22:\r\ncase MXT_PROCI_ONETOUCH_T24:\r\ncase MXT_PROCI_TWOTOUCH_T27:\r\ncase MXT_PROCI_GRIP_T40:\r\ncase MXT_PROCI_PALM_T41:\r\ncase MXT_PROCI_TOUCHSUPPRESSION_T42:\r\ncase MXT_PROCI_STYLUS_T47:\r\ncase MXT_PROCG_NOISESUPPRESSION_T48:\r\ncase MXT_SPT_COMMSCONFIG_T18:\r\ncase MXT_SPT_GPIOPWM_T19:\r\ncase MXT_SPT_SELFTEST_T25:\r\ncase MXT_SPT_CTECONFIG_T28:\r\ncase MXT_SPT_DIGITIZER_T43:\r\ncase MXT_SPT_CTECONFIG_T46:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void mxt_dump_message(struct device *dev,\r\nstruct mxt_message *message)\r\n{\r\ndev_dbg(dev, "reportid: %u\tmessage: %*ph\n",\r\nmessage->reportid, 7, message->message);\r\n}\r\nstatic int mxt_check_bootloader(struct i2c_client *client,\r\nunsigned int state)\r\n{\r\nu8 val;\r\nrecheck:\r\nif (i2c_master_recv(client, &val, 1) != 1) {\r\ndev_err(&client->dev, "%s: i2c recv failed\n", __func__);\r\nreturn -EIO;\r\n}\r\nswitch (state) {\r\ncase MXT_WAITING_BOOTLOAD_CMD:\r\ncase MXT_WAITING_FRAME_DATA:\r\nval &= ~MXT_BOOT_STATUS_MASK;\r\nbreak;\r\ncase MXT_FRAME_CRC_PASS:\r\nif (val == MXT_FRAME_CRC_CHECK)\r\ngoto recheck;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (val != state) {\r\ndev_err(&client->dev, "Unvalid bootloader mode state\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_unlock_bootloader(struct i2c_client *client)\r\n{\r\nu8 buf[2];\r\nbuf[0] = MXT_UNLOCK_CMD_LSB;\r\nbuf[1] = MXT_UNLOCK_CMD_MSB;\r\nif (i2c_master_send(client, buf, 2) != 2) {\r\ndev_err(&client->dev, "%s: i2c send failed\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_fw_write(struct i2c_client *client,\r\nconst u8 *data, unsigned int frame_size)\r\n{\r\nif (i2c_master_send(client, data, frame_size) != frame_size) {\r\ndev_err(&client->dev, "%s: i2c send failed\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __mxt_read_reg(struct i2c_client *client,\r\nu16 reg, u16 len, void *val)\r\n{\r\nstruct i2c_msg xfer[2];\r\nu8 buf[2];\r\nint ret;\r\nbuf[0] = reg & 0xff;\r\nbuf[1] = (reg >> 8) & 0xff;\r\nxfer[0].addr = client->addr;\r\nxfer[0].flags = 0;\r\nxfer[0].len = 2;\r\nxfer[0].buf = buf;\r\nxfer[1].addr = client->addr;\r\nxfer[1].flags = I2C_M_RD;\r\nxfer[1].len = len;\r\nxfer[1].buf = val;\r\nret = i2c_transfer(client->adapter, xfer, 2);\r\nif (ret == 2) {\r\nret = 0;\r\n} else {\r\nif (ret >= 0)\r\nret = -EIO;\r\ndev_err(&client->dev, "%s: i2c transfer failed (%d)\n",\r\n__func__, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mxt_read_reg(struct i2c_client *client, u16 reg, u8 *val)\r\n{\r\nreturn __mxt_read_reg(client, reg, 1, val);\r\n}\r\nstatic int __mxt_write_reg(struct i2c_client *client, u16 reg, u16 len,\r\nconst void *val)\r\n{\r\nu8 *buf;\r\nsize_t count;\r\nint ret;\r\ncount = len + 2;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = reg & 0xff;\r\nbuf[1] = (reg >> 8) & 0xff;\r\nmemcpy(&buf[2], val, len);\r\nret = i2c_master_send(client, buf, count);\r\nif (ret == count) {\r\nret = 0;\r\n} else {\r\nif (ret >= 0)\r\nret = -EIO;\r\ndev_err(&client->dev, "%s: i2c send failed (%d)\n",\r\n__func__, ret);\r\n}\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int mxt_write_reg(struct i2c_client *client, u16 reg, u8 val)\r\n{\r\nreturn __mxt_write_reg(client, reg, 1, &val);\r\n}\r\nstatic struct mxt_object *\r\nmxt_get_object(struct mxt_data *data, u8 type)\r\n{\r\nstruct mxt_object *object;\r\nint i;\r\nfor (i = 0; i < data->info.object_num; i++) {\r\nobject = data->object_table + i;\r\nif (object->type == type)\r\nreturn object;\r\n}\r\ndev_err(&data->client->dev, "Invalid object type\n");\r\nreturn NULL;\r\n}\r\nstatic int mxt_read_message(struct mxt_data *data,\r\nstruct mxt_message *message)\r\n{\r\nstruct mxt_object *object;\r\nu16 reg;\r\nobject = mxt_get_object(data, MXT_GEN_MESSAGE_T5);\r\nif (!object)\r\nreturn -EINVAL;\r\nreg = object->start_address;\r\nreturn __mxt_read_reg(data->client, reg,\r\nsizeof(struct mxt_message), message);\r\n}\r\nstatic int mxt_write_object(struct mxt_data *data,\r\nu8 type, u8 offset, u8 val)\r\n{\r\nstruct mxt_object *object;\r\nu16 reg;\r\nobject = mxt_get_object(data, type);\r\nif (!object || offset >= object->size + 1)\r\nreturn -EINVAL;\r\nreg = object->start_address;\r\nreturn mxt_write_reg(data->client, reg + offset, val);\r\n}\r\nstatic void mxt_input_button(struct mxt_data *data, struct mxt_message *message)\r\n{\r\nstruct input_dev *input = data->input_dev;\r\nbool button;\r\nint i;\r\nfor (i = 0; i < MXT_NUM_GPIO; i++) {\r\nif (data->pdata->key_map[i] == KEY_RESERVED)\r\ncontinue;\r\nbutton = !(message->message[0] & MXT_GPIO0_MASK << i);\r\ninput_report_key(input, data->pdata->key_map[i], button);\r\n}\r\n}\r\nstatic void mxt_input_touchevent(struct mxt_data *data,\r\nstruct mxt_message *message, int id)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nu8 status = message->message[0];\r\nstruct input_dev *input_dev = data->input_dev;\r\nint x;\r\nint y;\r\nint area;\r\nint pressure;\r\nx = (message->message[1] << 4) | ((message->message[3] >> 4) & 0xf);\r\ny = (message->message[2] << 4) | ((message->message[3] & 0xf));\r\nif (data->max_x < 1024)\r\nx = x >> 2;\r\nif (data->max_y < 1024)\r\ny = y >> 2;\r\narea = message->message[4];\r\npressure = message->message[5];\r\ndev_dbg(dev,\r\n"[%u] %c%c%c%c%c%c%c%c x: %5u y: %5u area: %3u amp: %3u\n",\r\nid,\r\n(status & MXT_DETECT) ? 'D' : '.',\r\n(status & MXT_PRESS) ? 'P' : '.',\r\n(status & MXT_RELEASE) ? 'R' : '.',\r\n(status & MXT_MOVE) ? 'M' : '.',\r\n(status & MXT_VECTOR) ? 'V' : '.',\r\n(status & MXT_AMP) ? 'A' : '.',\r\n(status & MXT_SUPPRESS) ? 'S' : '.',\r\n(status & MXT_UNGRIP) ? 'U' : '.',\r\nx, y, area, pressure);\r\ninput_mt_slot(input_dev, id);\r\ninput_mt_report_slot_state(input_dev, MT_TOOL_FINGER,\r\nstatus & MXT_DETECT);\r\nif (status & MXT_DETECT) {\r\ninput_report_abs(input_dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input_dev, ABS_MT_POSITION_Y, y);\r\ninput_report_abs(input_dev, ABS_MT_PRESSURE, pressure);\r\ninput_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, area);\r\n}\r\n}\r\nstatic unsigned mxt_extract_T6_csum(const u8 *csum)\r\n{\r\nreturn csum[0] | (csum[1] << 8) | (csum[2] << 16);\r\n}\r\nstatic bool mxt_is_T9_message(struct mxt_data *data, struct mxt_message *msg)\r\n{\r\nu8 id = msg->reportid;\r\nreturn (id >= data->T9_reportid_min && id <= data->T9_reportid_max);\r\n}\r\nstatic irqreturn_t mxt_interrupt(int irq, void *dev_id)\r\n{\r\nstruct mxt_data *data = dev_id;\r\nstruct mxt_message message;\r\nconst u8 *payload = &message.message[0];\r\nstruct device *dev = &data->client->dev;\r\nu8 reportid;\r\nbool update_input = false;\r\ndo {\r\nif (mxt_read_message(data, &message)) {\r\ndev_err(dev, "Failed to read message\n");\r\ngoto end;\r\n}\r\nreportid = message.reportid;\r\nif (reportid == data->T6_reportid) {\r\nu8 status = payload[0];\r\nunsigned csum = mxt_extract_T6_csum(&payload[1]);\r\ndev_dbg(dev, "Status: %02x Config Checksum: %06x\n",\r\nstatus, csum);\r\n} else if (mxt_is_T9_message(data, &message)) {\r\nint id = reportid - data->T9_reportid_min;\r\nmxt_input_touchevent(data, &message, id);\r\nupdate_input = true;\r\n} else if (message.reportid == data->T19_reportid) {\r\nmxt_input_button(data, &message);\r\nupdate_input = true;\r\n} else {\r\nmxt_dump_message(dev, &message);\r\n}\r\n} while (reportid != 0xff);\r\nif (update_input) {\r\ninput_mt_report_pointer_emulation(data->input_dev, false);\r\ninput_sync(data->input_dev);\r\n}\r\nend:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mxt_check_reg_init(struct mxt_data *data)\r\n{\r\nconst struct mxt_platform_data *pdata = data->pdata;\r\nstruct mxt_object *object;\r\nstruct device *dev = &data->client->dev;\r\nint index = 0;\r\nint i, size;\r\nint ret;\r\nif (!pdata->config) {\r\ndev_dbg(dev, "No cfg data defined, skipping reg init\n");\r\nreturn 0;\r\n}\r\nfor (i = 0; i < data->info.object_num; i++) {\r\nobject = data->object_table + i;\r\nif (!mxt_object_writable(object->type))\r\ncontinue;\r\nsize = (object->size + 1) * (object->instances + 1);\r\nif (index + size > pdata->config_length) {\r\ndev_err(dev, "Not enough config data!\n");\r\nreturn -EINVAL;\r\n}\r\nret = __mxt_write_reg(data->client, object->start_address,\r\nsize, &pdata->config[index]);\r\nif (ret)\r\nreturn ret;\r\nindex += size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_make_highchg(struct mxt_data *data)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nstruct mxt_message message;\r\nint count = 10;\r\nint error;\r\ndo {\r\nerror = mxt_read_message(data, &message);\r\nif (error)\r\nreturn error;\r\n} while (message.reportid != 0xff && --count);\r\nif (!count) {\r\ndev_err(dev, "CHG pin isn't cleared\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mxt_handle_pdata(struct mxt_data *data)\r\n{\r\nconst struct mxt_platform_data *pdata = data->pdata;\r\nu8 voltage;\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9, MXT_TOUCH_XSIZE,\r\npdata->x_line);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9, MXT_TOUCH_YSIZE,\r\npdata->y_line);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9, MXT_TOUCH_ORIENT,\r\npdata->orient);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9,\r\nMXT_TOUCH_BLEN, pdata->blen);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9,\r\nMXT_TOUCH_TCHTHR, pdata->threshold);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9,\r\nMXT_TOUCH_XRANGE_LSB, (pdata->x_size - 1) & 0xff);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9,\r\nMXT_TOUCH_XRANGE_MSB, (pdata->x_size - 1) >> 8);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9,\r\nMXT_TOUCH_YRANGE_LSB, (pdata->y_size - 1) & 0xff);\r\nmxt_write_object(data, MXT_TOUCH_MULTI_T9,\r\nMXT_TOUCH_YRANGE_MSB, (pdata->y_size - 1) >> 8);\r\nif (pdata->voltage) {\r\nif (pdata->voltage < MXT_VOLTAGE_DEFAULT) {\r\nvoltage = (MXT_VOLTAGE_DEFAULT - pdata->voltage) /\r\nMXT_VOLTAGE_STEP;\r\nvoltage = 0xff - voltage + 1;\r\n} else\r\nvoltage = (pdata->voltage - MXT_VOLTAGE_DEFAULT) /\r\nMXT_VOLTAGE_STEP;\r\nmxt_write_object(data, MXT_SPT_CTECONFIG_T28,\r\nMXT_CTE_VOLTAGE, voltage);\r\n}\r\n}\r\nstatic int mxt_get_info(struct mxt_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nstruct mxt_info *info = &data->info;\r\nint error;\r\nerror = __mxt_read_reg(client, MXT_INFO, sizeof(*info), info);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int mxt_get_object_table(struct mxt_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nsize_t table_size;\r\nint error;\r\nint i;\r\nu8 reportid;\r\ntable_size = data->info.object_num * sizeof(struct mxt_object);\r\nerror = __mxt_read_reg(client, MXT_OBJECT_START, table_size,\r\ndata->object_table);\r\nif (error)\r\nreturn error;\r\nreportid = 1;\r\nfor (i = 0; i < data->info.object_num; i++) {\r\nstruct mxt_object *object = data->object_table + i;\r\nu8 min_id, max_id;\r\nle16_to_cpus(&object->start_address);\r\nif (object->num_report_ids) {\r\nmin_id = reportid;\r\nreportid += object->num_report_ids *\r\n(object->instances + 1);\r\nmax_id = reportid - 1;\r\n} else {\r\nmin_id = 0;\r\nmax_id = 0;\r\n}\r\ndev_dbg(&data->client->dev,\r\n"Type %2d Start %3d Size %3d Instances %2d ReportIDs %3u : %3u\n",\r\nobject->type, object->start_address, object->size + 1,\r\nobject->instances + 1, min_id, max_id);\r\nswitch (object->type) {\r\ncase MXT_GEN_COMMAND_T6:\r\ndata->T6_reportid = min_id;\r\nbreak;\r\ncase MXT_TOUCH_MULTI_T9:\r\ndata->T9_reportid_min = min_id;\r\ndata->T9_reportid_max = max_id;\r\nbreak;\r\ncase MXT_SPT_GPIOPWM_T19:\r\ndata->T19_reportid = min_id;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mxt_free_object_table(struct mxt_data *data)\r\n{\r\nkfree(data->object_table);\r\ndata->object_table = NULL;\r\ndata->T6_reportid = 0;\r\ndata->T9_reportid_min = 0;\r\ndata->T9_reportid_max = 0;\r\ndata->T19_reportid = 0;\r\n}\r\nstatic int mxt_initialize(struct mxt_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nstruct mxt_info *info = &data->info;\r\nint error;\r\nu8 val;\r\nerror = mxt_get_info(data);\r\nif (error)\r\nreturn error;\r\ndata->object_table = kcalloc(info->object_num,\r\nsizeof(struct mxt_object),\r\nGFP_KERNEL);\r\nif (!data->object_table) {\r\ndev_err(&client->dev, "Failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nerror = mxt_get_object_table(data);\r\nif (error)\r\ngoto err_free_object_table;\r\nerror = mxt_check_reg_init(data);\r\nif (error)\r\ngoto err_free_object_table;\r\nmxt_handle_pdata(data);\r\nmxt_write_object(data, MXT_GEN_COMMAND_T6,\r\nMXT_COMMAND_BACKUPNV,\r\nMXT_BACKUP_VALUE);\r\nmsleep(MXT_BACKUP_TIME);\r\nmxt_write_object(data, MXT_GEN_COMMAND_T6,\r\nMXT_COMMAND_RESET, 1);\r\nmsleep(MXT_RESET_TIME);\r\nerror = mxt_read_reg(client, MXT_MATRIX_X_SIZE, &val);\r\nif (error)\r\ngoto err_free_object_table;\r\ninfo->matrix_xsize = val;\r\nerror = mxt_read_reg(client, MXT_MATRIX_Y_SIZE, &val);\r\nif (error)\r\ngoto err_free_object_table;\r\ninfo->matrix_ysize = val;\r\ndev_info(&client->dev,\r\n"Family ID: %u Variant ID: %u Major.Minor.Build: %u.%u.%02X\n",\r\ninfo->family_id, info->variant_id, info->version >> 4,\r\ninfo->version & 0xf, info->build);\r\ndev_info(&client->dev,\r\n"Matrix X Size: %u Matrix Y Size: %u Object Num: %u\n",\r\ninfo->matrix_xsize, info->matrix_ysize,\r\ninfo->object_num);\r\nreturn 0;\r\nerr_free_object_table:\r\nmxt_free_object_table(data);\r\nreturn error;\r\n}\r\nstatic void mxt_calc_resolution(struct mxt_data *data)\r\n{\r\nunsigned int max_x = data->pdata->x_size - 1;\r\nunsigned int max_y = data->pdata->y_size - 1;\r\nif (data->pdata->orient & MXT_XY_SWITCH) {\r\ndata->max_x = max_y;\r\ndata->max_y = max_x;\r\n} else {\r\ndata->max_x = max_x;\r\ndata->max_y = max_y;\r\n}\r\n}\r\nstatic ssize_t mxt_fw_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mxt_data *data = dev_get_drvdata(dev);\r\nstruct mxt_info *info = &data->info;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u.%u.%02X\n",\r\ninfo->version >> 4, info->version & 0xf, info->build);\r\n}\r\nstatic ssize_t mxt_hw_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mxt_data *data = dev_get_drvdata(dev);\r\nstruct mxt_info *info = &data->info;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u.%u\n",\r\ninfo->family_id, info->variant_id);\r\n}\r\nstatic ssize_t mxt_show_instance(char *buf, int count,\r\nstruct mxt_object *object, int instance,\r\nconst u8 *val)\r\n{\r\nint i;\r\nif (object->instances > 0)\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Instance %u\n", instance);\r\nfor (i = 0; i < object->size + 1; i++)\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"\t[%2u]: %02x (%d)\n", i, val[i], val[i]);\r\ncount += scnprintf(buf + count, PAGE_SIZE - count, "\n");\r\nreturn count;\r\n}\r\nstatic ssize_t mxt_object_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mxt_data *data = dev_get_drvdata(dev);\r\nstruct mxt_object *object;\r\nint count = 0;\r\nint i, j;\r\nint error;\r\nu8 *obuf;\r\nobuf = kmalloc(256, GFP_KERNEL);\r\nif (!obuf)\r\nreturn -ENOMEM;\r\nerror = 0;\r\nfor (i = 0; i < data->info.object_num; i++) {\r\nobject = data->object_table + i;\r\nif (!mxt_object_readable(object->type))\r\ncontinue;\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"T%u:\n", object->type);\r\nfor (j = 0; j < object->instances + 1; j++) {\r\nu16 size = object->size + 1;\r\nu16 addr = object->start_address + j * size;\r\nerror = __mxt_read_reg(data->client, addr, size, obuf);\r\nif (error)\r\ngoto done;\r\ncount = mxt_show_instance(buf, count, object, j, obuf);\r\n}\r\n}\r\ndone:\r\nkfree(obuf);\r\nreturn error ?: count;\r\n}\r\nstatic int mxt_load_fw(struct device *dev, const char *fn)\r\n{\r\nstruct mxt_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nconst struct firmware *fw = NULL;\r\nunsigned int frame_size;\r\nunsigned int pos = 0;\r\nint ret;\r\nret = request_firmware(&fw, fn, dev);\r\nif (ret) {\r\ndev_err(dev, "Unable to open firmware %s\n", fn);\r\nreturn ret;\r\n}\r\nmxt_write_object(data, MXT_GEN_COMMAND_T6,\r\nMXT_COMMAND_RESET, MXT_BOOT_VALUE);\r\nmsleep(MXT_RESET_TIME);\r\nif (client->addr == MXT_APP_LOW)\r\nclient->addr = MXT_BOOT_LOW;\r\nelse\r\nclient->addr = MXT_BOOT_HIGH;\r\nret = mxt_check_bootloader(client, MXT_WAITING_BOOTLOAD_CMD);\r\nif (ret)\r\ngoto out;\r\nmxt_unlock_bootloader(client);\r\nwhile (pos < fw->size) {\r\nret = mxt_check_bootloader(client,\r\nMXT_WAITING_FRAME_DATA);\r\nif (ret)\r\ngoto out;\r\nframe_size = ((*(fw->data + pos) << 8) | *(fw->data + pos + 1));\r\nframe_size += 2;\r\nmxt_fw_write(client, fw->data + pos, frame_size);\r\nret = mxt_check_bootloader(client,\r\nMXT_FRAME_CRC_PASS);\r\nif (ret)\r\ngoto out;\r\npos += frame_size;\r\ndev_dbg(dev, "Updated %d bytes / %zd bytes\n", pos, fw->size);\r\n}\r\nout:\r\nrelease_firmware(fw);\r\nif (client->addr == MXT_BOOT_LOW)\r\nclient->addr = MXT_APP_LOW;\r\nelse\r\nclient->addr = MXT_APP_HIGH;\r\nreturn ret;\r\n}\r\nstatic ssize_t mxt_update_fw_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct mxt_data *data = dev_get_drvdata(dev);\r\nint error;\r\ndisable_irq(data->irq);\r\nerror = mxt_load_fw(dev, MXT_FW_NAME);\r\nif (error) {\r\ndev_err(dev, "The firmware update failed(%d)\n", error);\r\ncount = error;\r\n} else {\r\ndev_dbg(dev, "The firmware update succeeded\n");\r\nmsleep(MXT_FWRESET_TIME);\r\nmxt_free_object_table(data);\r\nmxt_initialize(data);\r\n}\r\nenable_irq(data->irq);\r\nerror = mxt_make_highchg(data);\r\nif (error)\r\nreturn error;\r\nreturn count;\r\n}\r\nstatic void mxt_start(struct mxt_data *data)\r\n{\r\nmxt_write_object(data,\r\nMXT_TOUCH_MULTI_T9, MXT_TOUCH_CTRL, 0x83);\r\n}\r\nstatic void mxt_stop(struct mxt_data *data)\r\n{\r\nmxt_write_object(data,\r\nMXT_TOUCH_MULTI_T9, MXT_TOUCH_CTRL, 0);\r\n}\r\nstatic int mxt_input_open(struct input_dev *dev)\r\n{\r\nstruct mxt_data *data = input_get_drvdata(dev);\r\nmxt_start(data);\r\nreturn 0;\r\n}\r\nstatic void mxt_input_close(struct input_dev *dev)\r\n{\r\nstruct mxt_data *data = input_get_drvdata(dev);\r\nmxt_stop(data);\r\n}\r\nstatic int mxt_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct mxt_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct mxt_data *data;\r\nstruct input_dev *input_dev;\r\nint error;\r\nunsigned int num_mt_slots;\r\nif (!pdata)\r\nreturn -EINVAL;\r\ndata = kzalloc(sizeof(struct mxt_data), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!data || !input_dev) {\r\ndev_err(&client->dev, "Failed to allocate memory\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ndata->is_tp = pdata && pdata->is_tp;\r\ninput_dev->name = (data->is_tp) ? "Atmel maXTouch Touchpad" :\r\n"Atmel maXTouch Touchscreen";\r\nsnprintf(data->phys, sizeof(data->phys), "i2c-%u-%04x/input0",\r\nclient->adapter->nr, client->addr);\r\ninput_dev->phys = data->phys;\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = &client->dev;\r\ninput_dev->open = mxt_input_open;\r\ninput_dev->close = mxt_input_close;\r\ndata->client = client;\r\ndata->input_dev = input_dev;\r\ndata->pdata = pdata;\r\ndata->irq = client->irq;\r\nmxt_calc_resolution(data);\r\nerror = mxt_initialize(data);\r\nif (error)\r\ngoto err_free_mem;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\nif (data->is_tp) {\r\nint i;\r\n__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\r\n__set_bit(INPUT_PROP_BUTTONPAD, input_dev->propbit);\r\nfor (i = 0; i < MXT_NUM_GPIO; i++)\r\nif (pdata->key_map[i] != KEY_RESERVED)\r\n__set_bit(pdata->key_map[i], input_dev->keybit);\r\n__set_bit(BTN_TOOL_FINGER, input_dev->keybit);\r\n__set_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);\r\n__set_bit(BTN_TOOL_TRIPLETAP, input_dev->keybit);\r\n__set_bit(BTN_TOOL_QUADTAP, input_dev->keybit);\r\n__set_bit(BTN_TOOL_QUINTTAP, input_dev->keybit);\r\ninput_abs_set_res(input_dev, ABS_X, MXT_PIXELS_PER_MM);\r\ninput_abs_set_res(input_dev, ABS_Y, MXT_PIXELS_PER_MM);\r\ninput_abs_set_res(input_dev, ABS_MT_POSITION_X,\r\nMXT_PIXELS_PER_MM);\r\ninput_abs_set_res(input_dev, ABS_MT_POSITION_Y,\r\nMXT_PIXELS_PER_MM);\r\n}\r\ninput_set_abs_params(input_dev, ABS_X,\r\n0, data->max_x, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y,\r\n0, data->max_y, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE,\r\n0, 255, 0, 0);\r\nnum_mt_slots = data->T9_reportid_max - data->T9_reportid_min + 1;\r\nerror = input_mt_init_slots(input_dev, num_mt_slots, 0);\r\nif (error)\r\ngoto err_free_object;\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,\r\n0, MXT_MAX_AREA, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_X,\r\n0, data->max_x, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_Y,\r\n0, data->max_y, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_PRESSURE,\r\n0, 255, 0, 0);\r\ninput_set_drvdata(input_dev, data);\r\ni2c_set_clientdata(client, data);\r\nerror = request_threaded_irq(client->irq, NULL, mxt_interrupt,\r\npdata->irqflags | IRQF_ONESHOT,\r\nclient->name, data);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\ngoto err_free_object;\r\n}\r\nerror = mxt_make_highchg(data);\r\nif (error)\r\ngoto err_free_irq;\r\nerror = input_register_device(input_dev);\r\nif (error)\r\ngoto err_free_irq;\r\nerror = sysfs_create_group(&client->dev.kobj, &mxt_attr_group);\r\nif (error)\r\ngoto err_unregister_device;\r\nreturn 0;\r\nerr_unregister_device:\r\ninput_unregister_device(input_dev);\r\ninput_dev = NULL;\r\nerr_free_irq:\r\nfree_irq(client->irq, data);\r\nerr_free_object:\r\nkfree(data->object_table);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(data);\r\nreturn error;\r\n}\r\nstatic int mxt_remove(struct i2c_client *client)\r\n{\r\nstruct mxt_data *data = i2c_get_clientdata(client);\r\nsysfs_remove_group(&client->dev.kobj, &mxt_attr_group);\r\nfree_irq(data->irq, data);\r\ninput_unregister_device(data->input_dev);\r\nkfree(data->object_table);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int mxt_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mxt_data *data = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = data->input_dev;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nmxt_stop(data);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int mxt_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mxt_data *data = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = data->input_dev;\r\nmxt_write_object(data, MXT_GEN_COMMAND_T6,\r\nMXT_COMMAND_RESET, 1);\r\nmsleep(MXT_RESET_TIME);\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nmxt_start(data);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}
