int eth_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type,\r\nconst void *daddr, const void *saddr, unsigned int len)\r\n{\r\nstruct ethhdr *eth = (struct ethhdr *)skb_push(skb, ETH_HLEN);\r\nif (type != ETH_P_802_3 && type != ETH_P_802_2)\r\neth->h_proto = htons(type);\r\nelse\r\neth->h_proto = htons(len);\r\nif (!saddr)\r\nsaddr = dev->dev_addr;\r\nmemcpy(eth->h_source, saddr, ETH_ALEN);\r\nif (daddr) {\r\nmemcpy(eth->h_dest, daddr, ETH_ALEN);\r\nreturn ETH_HLEN;\r\n}\r\nif (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {\r\nmemset(eth->h_dest, 0, ETH_ALEN);\r\nreturn ETH_HLEN;\r\n}\r\nreturn -ETH_HLEN;\r\n}\r\nint eth_rebuild_header(struct sk_buff *skb)\r\n{\r\nstruct ethhdr *eth = (struct ethhdr *)skb->data;\r\nstruct net_device *dev = skb->dev;\r\nswitch (eth->h_proto) {\r\n#ifdef CONFIG_INET\r\ncase htons(ETH_P_IP):\r\nreturn arp_find(eth->h_dest, skb);\r\n#endif\r\ndefault:\r\nnetdev_dbg(dev,\r\n"%s: unable to resolve type %X addresses.\n",\r\ndev->name, ntohs(eth->h_proto));\r\nmemcpy(eth->h_source, dev->dev_addr, ETH_ALEN);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\n__be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nunsigned short _service_access_point;\r\nconst unsigned short *sap;\r\nconst struct ethhdr *eth;\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb_pull_inline(skb, ETH_HLEN);\r\neth = eth_hdr(skb);\r\nif (unlikely(is_multicast_ether_addr(eth->h_dest))) {\r\nif (ether_addr_equal_64bits(eth->h_dest, dev->broadcast))\r\nskb->pkt_type = PACKET_BROADCAST;\r\nelse\r\nskb->pkt_type = PACKET_MULTICAST;\r\n}\r\nelse if (unlikely(!ether_addr_equal_64bits(eth->h_dest,\r\ndev->dev_addr)))\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nif (unlikely(netdev_uses_dsa_tags(dev)))\r\nreturn htons(ETH_P_DSA);\r\nif (unlikely(netdev_uses_trailer_tags(dev)))\r\nreturn htons(ETH_P_TRAILER);\r\nif (likely(ntohs(eth->h_proto) >= ETH_P_802_3_MIN))\r\nreturn eth->h_proto;\r\nsap = skb_header_pointer(skb, 0, sizeof(*sap), &_service_access_point);\r\nif (sap && *sap == 0xFFFF)\r\nreturn htons(ETH_P_802_3);\r\nreturn htons(ETH_P_802_2);\r\n}\r\nint eth_header_parse(const struct sk_buff *skb, unsigned char *haddr)\r\n{\r\nconst struct ethhdr *eth = eth_hdr(skb);\r\nmemcpy(haddr, eth->h_source, ETH_ALEN);\r\nreturn ETH_ALEN;\r\n}\r\nint eth_header_cache(const struct neighbour *neigh, struct hh_cache *hh, __be16 type)\r\n{\r\nstruct ethhdr *eth;\r\nconst struct net_device *dev = neigh->dev;\r\neth = (struct ethhdr *)\r\n(((u8 *) hh->hh_data) + (HH_DATA_OFF(sizeof(*eth))));\r\nif (type == htons(ETH_P_802_3))\r\nreturn -1;\r\neth->h_proto = type;\r\nmemcpy(eth->h_source, dev->dev_addr, ETH_ALEN);\r\nmemcpy(eth->h_dest, neigh->ha, ETH_ALEN);\r\nhh->hh_len = ETH_HLEN;\r\nreturn 0;\r\n}\r\nvoid eth_header_cache_update(struct hh_cache *hh,\r\nconst struct net_device *dev,\r\nconst unsigned char *haddr)\r\n{\r\nmemcpy(((u8 *) hh->hh_data) + HH_DATA_OFF(sizeof(struct ethhdr)),\r\nhaddr, ETH_ALEN);\r\n}\r\nint eth_prepare_mac_addr_change(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nif (!(dev->priv_flags & IFF_LIVE_ADDR_CHANGE) && netif_running(dev))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nreturn 0;\r\n}\r\nvoid eth_commit_mac_addr_change(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\n}\r\nint eth_mac_addr(struct net_device *dev, void *p)\r\n{\r\nint ret;\r\nret = eth_prepare_mac_addr_change(dev, p);\r\nif (ret < 0)\r\nreturn ret;\r\neth_commit_mac_addr_change(dev, p);\r\nreturn 0;\r\n}\r\nint eth_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (new_mtu < 68 || new_mtu > ETH_DATA_LEN)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nint eth_validate_addr(struct net_device *dev)\r\n{\r\nif (!is_valid_ether_addr(dev->dev_addr))\r\nreturn -EADDRNOTAVAIL;\r\nreturn 0;\r\n}\r\nvoid ether_setup(struct net_device *dev)\r\n{\r\ndev->header_ops = &eth_header_ops;\r\ndev->type = ARPHRD_ETHER;\r\ndev->hard_header_len = ETH_HLEN;\r\ndev->mtu = ETH_DATA_LEN;\r\ndev->addr_len = ETH_ALEN;\r\ndev->tx_queue_len = 1000;\r\ndev->flags = IFF_BROADCAST|IFF_MULTICAST;\r\ndev->priv_flags |= IFF_TX_SKB_SHARING;\r\nmemset(dev->broadcast, 0xFF, ETH_ALEN);\r\n}\r\nstruct net_device *alloc_etherdev_mqs(int sizeof_priv, unsigned int txqs,\r\nunsigned int rxqs)\r\n{\r\nreturn alloc_netdev_mqs(sizeof_priv, "eth%d", ether_setup, txqs, rxqs);\r\n}\r\nssize_t sysfs_format_mac(char *buf, const unsigned char *addr, int len)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%*phC\n", len, addr);\r\n}
