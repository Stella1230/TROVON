int install_user_keyrings(void)\r\n{\r\nstruct user_struct *user;\r\nconst struct cred *cred;\r\nstruct key *uid_keyring, *session_keyring;\r\nkey_perm_t user_keyring_perm;\r\nchar buf[20];\r\nint ret;\r\nuid_t uid;\r\nuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\r\ncred = current_cred();\r\nuser = cred->user;\r\nuid = from_kuid(cred->user_ns, user->uid);\r\nkenter("%p{%u}", user, uid);\r\nif (user->uid_keyring && user->session_keyring) {\r\nkleave(" = 0 [exist]");\r\nreturn 0;\r\n}\r\nmutex_lock(&key_user_keyring_mutex);\r\nret = 0;\r\nif (!user->uid_keyring) {\r\nsprintf(buf, "_uid.%u", uid);\r\nuid_keyring = find_keyring_by_name(buf, true);\r\nif (IS_ERR(uid_keyring)) {\r\nuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\r\ncred, user_keyring_perm,\r\nKEY_ALLOC_IN_QUOTA, NULL);\r\nif (IS_ERR(uid_keyring)) {\r\nret = PTR_ERR(uid_keyring);\r\ngoto error;\r\n}\r\n}\r\nsprintf(buf, "_uid_ses.%u", uid);\r\nsession_keyring = find_keyring_by_name(buf, true);\r\nif (IS_ERR(session_keyring)) {\r\nsession_keyring =\r\nkeyring_alloc(buf, user->uid, INVALID_GID,\r\ncred, user_keyring_perm,\r\nKEY_ALLOC_IN_QUOTA, NULL);\r\nif (IS_ERR(session_keyring)) {\r\nret = PTR_ERR(session_keyring);\r\ngoto error_release;\r\n}\r\nret = key_link(session_keyring, uid_keyring);\r\nif (ret < 0)\r\ngoto error_release_both;\r\n}\r\nuser->uid_keyring = uid_keyring;\r\nuser->session_keyring = session_keyring;\r\n}\r\nmutex_unlock(&key_user_keyring_mutex);\r\nkleave(" = 0");\r\nreturn 0;\r\nerror_release_both:\r\nkey_put(session_keyring);\r\nerror_release:\r\nkey_put(uid_keyring);\r\nerror:\r\nmutex_unlock(&key_user_keyring_mutex);\r\nkleave(" = %d", ret);\r\nreturn ret;\r\n}\r\nint install_thread_keyring_to_cred(struct cred *new)\r\n{\r\nstruct key *keyring;\r\nkeyring = keyring_alloc("_tid", new->uid, new->gid, new,\r\nKEY_POS_ALL | KEY_USR_VIEW,\r\nKEY_ALLOC_QUOTA_OVERRUN, NULL);\r\nif (IS_ERR(keyring))\r\nreturn PTR_ERR(keyring);\r\nnew->thread_keyring = keyring;\r\nreturn 0;\r\n}\r\nstatic int install_thread_keyring(void)\r\n{\r\nstruct cred *new;\r\nint ret;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nBUG_ON(new->thread_keyring);\r\nret = install_thread_keyring_to_cred(new);\r\nif (ret < 0) {\r\nabort_creds(new);\r\nreturn ret;\r\n}\r\nreturn commit_creds(new);\r\n}\r\nint install_process_keyring_to_cred(struct cred *new)\r\n{\r\nstruct key *keyring;\r\nif (new->process_keyring)\r\nreturn -EEXIST;\r\nkeyring = keyring_alloc("_pid", new->uid, new->gid, new,\r\nKEY_POS_ALL | KEY_USR_VIEW,\r\nKEY_ALLOC_QUOTA_OVERRUN, NULL);\r\nif (IS_ERR(keyring))\r\nreturn PTR_ERR(keyring);\r\nnew->process_keyring = keyring;\r\nreturn 0;\r\n}\r\nstatic int install_process_keyring(void)\r\n{\r\nstruct cred *new;\r\nint ret;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nret = install_process_keyring_to_cred(new);\r\nif (ret < 0) {\r\nabort_creds(new);\r\nreturn ret != -EEXIST ? ret : 0;\r\n}\r\nreturn commit_creds(new);\r\n}\r\nint install_session_keyring_to_cred(struct cred *cred, struct key *keyring)\r\n{\r\nunsigned long flags;\r\nstruct key *old;\r\nmight_sleep();\r\nif (!keyring) {\r\nflags = KEY_ALLOC_QUOTA_OVERRUN;\r\nif (cred->session_keyring)\r\nflags = KEY_ALLOC_IN_QUOTA;\r\nkeyring = keyring_alloc("_ses", cred->uid, cred->gid, cred,\r\nKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\r\nflags, NULL);\r\nif (IS_ERR(keyring))\r\nreturn PTR_ERR(keyring);\r\n} else {\r\n__key_get(keyring);\r\n}\r\nold = cred->session_keyring;\r\nrcu_assign_pointer(cred->session_keyring, keyring);\r\nif (old)\r\nkey_put(old);\r\nreturn 0;\r\n}\r\nstatic int install_session_keyring(struct key *keyring)\r\n{\r\nstruct cred *new;\r\nint ret;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nret = install_session_keyring_to_cred(new, keyring);\r\nif (ret < 0) {\r\nabort_creds(new);\r\nreturn ret;\r\n}\r\nreturn commit_creds(new);\r\n}\r\nvoid key_fsuid_changed(struct task_struct *tsk)\r\n{\r\nBUG_ON(!tsk->cred);\r\nif (tsk->cred->thread_keyring) {\r\ndown_write(&tsk->cred->thread_keyring->sem);\r\ntsk->cred->thread_keyring->uid = tsk->cred->fsuid;\r\nup_write(&tsk->cred->thread_keyring->sem);\r\n}\r\n}\r\nvoid key_fsgid_changed(struct task_struct *tsk)\r\n{\r\nBUG_ON(!tsk->cred);\r\nif (tsk->cred->thread_keyring) {\r\ndown_write(&tsk->cred->thread_keyring->sem);\r\ntsk->cred->thread_keyring->gid = tsk->cred->fsgid;\r\nup_write(&tsk->cred->thread_keyring->sem);\r\n}\r\n}\r\nkey_ref_t search_my_process_keyrings(struct keyring_search_context *ctx)\r\n{\r\nkey_ref_t key_ref, ret, err;\r\nkey_ref = NULL;\r\nret = NULL;\r\nerr = ERR_PTR(-EAGAIN);\r\nif (ctx->cred->thread_keyring) {\r\nkey_ref = keyring_search_aux(\r\nmake_key_ref(ctx->cred->thread_keyring, 1), ctx);\r\nif (!IS_ERR(key_ref))\r\ngoto found;\r\nswitch (PTR_ERR(key_ref)) {\r\ncase -EAGAIN:\r\ncase -ENOKEY:\r\nret = key_ref;\r\nbreak;\r\ndefault:\r\nerr = key_ref;\r\nbreak;\r\n}\r\n}\r\nif (ctx->cred->process_keyring) {\r\nkey_ref = keyring_search_aux(\r\nmake_key_ref(ctx->cred->process_keyring, 1), ctx);\r\nif (!IS_ERR(key_ref))\r\ngoto found;\r\nswitch (PTR_ERR(key_ref)) {\r\ncase -EAGAIN:\r\nif (ret)\r\nbreak;\r\ncase -ENOKEY:\r\nret = key_ref;\r\nbreak;\r\ndefault:\r\nerr = key_ref;\r\nbreak;\r\n}\r\n}\r\nif (ctx->cred->session_keyring) {\r\nrcu_read_lock();\r\nkey_ref = keyring_search_aux(\r\nmake_key_ref(rcu_dereference(ctx->cred->session_keyring), 1),\r\nctx);\r\nrcu_read_unlock();\r\nif (!IS_ERR(key_ref))\r\ngoto found;\r\nswitch (PTR_ERR(key_ref)) {\r\ncase -EAGAIN:\r\nif (ret)\r\nbreak;\r\ncase -ENOKEY:\r\nret = key_ref;\r\nbreak;\r\ndefault:\r\nerr = key_ref;\r\nbreak;\r\n}\r\n}\r\nelse if (ctx->cred->user->session_keyring) {\r\nkey_ref = keyring_search_aux(\r\nmake_key_ref(ctx->cred->user->session_keyring, 1),\r\nctx);\r\nif (!IS_ERR(key_ref))\r\ngoto found;\r\nswitch (PTR_ERR(key_ref)) {\r\ncase -EAGAIN:\r\nif (ret)\r\nbreak;\r\ncase -ENOKEY:\r\nret = key_ref;\r\nbreak;\r\ndefault:\r\nerr = key_ref;\r\nbreak;\r\n}\r\n}\r\nkey_ref = ret ? ret : err;\r\nfound:\r\nreturn key_ref;\r\n}\r\nkey_ref_t search_process_keyrings(struct keyring_search_context *ctx)\r\n{\r\nstruct request_key_auth *rka;\r\nkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\r\nmight_sleep();\r\nkey_ref = search_my_process_keyrings(ctx);\r\nif (!IS_ERR(key_ref))\r\ngoto found;\r\nerr = key_ref;\r\nif (ctx->cred->request_key_auth &&\r\nctx->cred == current_cred() &&\r\nctx->index_key.type != &key_type_request_key_auth\r\n) {\r\nconst struct cred *cred = ctx->cred;\r\ndown_read(&cred->request_key_auth->sem);\r\nif (key_validate(ctx->cred->request_key_auth) == 0) {\r\nrka = ctx->cred->request_key_auth->payload.data;\r\nctx->cred = rka->cred;\r\nkey_ref = search_process_keyrings(ctx);\r\nctx->cred = cred;\r\nup_read(&cred->request_key_auth->sem);\r\nif (!IS_ERR(key_ref))\r\ngoto found;\r\nret = key_ref;\r\n} else {\r\nup_read(&cred->request_key_auth->sem);\r\n}\r\n}\r\nif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\r\nkey_ref = ERR_PTR(-ENOKEY);\r\nelse if (err == ERR_PTR(-EACCES))\r\nkey_ref = ret;\r\nelse\r\nkey_ref = err;\r\nfound:\r\nreturn key_ref;\r\n}\r\nint lookup_user_key_possessed(const struct key *key, const void *target)\r\n{\r\nreturn key == target;\r\n}\r\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\r\nkey_perm_t perm)\r\n{\r\nstruct keyring_search_context ctx = {\r\n.match = lookup_user_key_possessed,\r\n.flags = (KEYRING_SEARCH_NO_STATE_CHECK |\r\nKEYRING_SEARCH_LOOKUP_DIRECT),\r\n};\r\nstruct request_key_auth *rka;\r\nstruct key *key;\r\nkey_ref_t key_ref, skey_ref;\r\nint ret;\r\ntry_again:\r\nctx.cred = get_current_cred();\r\nkey_ref = ERR_PTR(-ENOKEY);\r\nswitch (id) {\r\ncase KEY_SPEC_THREAD_KEYRING:\r\nif (!ctx.cred->thread_keyring) {\r\nif (!(lflags & KEY_LOOKUP_CREATE))\r\ngoto error;\r\nret = install_thread_keyring();\r\nif (ret < 0) {\r\nkey_ref = ERR_PTR(ret);\r\ngoto error;\r\n}\r\ngoto reget_creds;\r\n}\r\nkey = ctx.cred->thread_keyring;\r\n__key_get(key);\r\nkey_ref = make_key_ref(key, 1);\r\nbreak;\r\ncase KEY_SPEC_PROCESS_KEYRING:\r\nif (!ctx.cred->process_keyring) {\r\nif (!(lflags & KEY_LOOKUP_CREATE))\r\ngoto error;\r\nret = install_process_keyring();\r\nif (ret < 0) {\r\nkey_ref = ERR_PTR(ret);\r\ngoto error;\r\n}\r\ngoto reget_creds;\r\n}\r\nkey = ctx.cred->process_keyring;\r\n__key_get(key);\r\nkey_ref = make_key_ref(key, 1);\r\nbreak;\r\ncase KEY_SPEC_SESSION_KEYRING:\r\nif (!ctx.cred->session_keyring) {\r\nret = install_user_keyrings();\r\nif (ret < 0)\r\ngoto error;\r\nif (lflags & KEY_LOOKUP_CREATE)\r\nret = join_session_keyring(NULL);\r\nelse\r\nret = install_session_keyring(\r\nctx.cred->user->session_keyring);\r\nif (ret < 0)\r\ngoto error;\r\ngoto reget_creds;\r\n} else if (ctx.cred->session_keyring ==\r\nctx.cred->user->session_keyring &&\r\nlflags & KEY_LOOKUP_CREATE) {\r\nret = join_session_keyring(NULL);\r\nif (ret < 0)\r\ngoto error;\r\ngoto reget_creds;\r\n}\r\nrcu_read_lock();\r\nkey = rcu_dereference(ctx.cred->session_keyring);\r\n__key_get(key);\r\nrcu_read_unlock();\r\nkey_ref = make_key_ref(key, 1);\r\nbreak;\r\ncase KEY_SPEC_USER_KEYRING:\r\nif (!ctx.cred->user->uid_keyring) {\r\nret = install_user_keyrings();\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nkey = ctx.cred->user->uid_keyring;\r\n__key_get(key);\r\nkey_ref = make_key_ref(key, 1);\r\nbreak;\r\ncase KEY_SPEC_USER_SESSION_KEYRING:\r\nif (!ctx.cred->user->session_keyring) {\r\nret = install_user_keyrings();\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nkey = ctx.cred->user->session_keyring;\r\n__key_get(key);\r\nkey_ref = make_key_ref(key, 1);\r\nbreak;\r\ncase KEY_SPEC_GROUP_KEYRING:\r\nkey_ref = ERR_PTR(-EINVAL);\r\ngoto error;\r\ncase KEY_SPEC_REQKEY_AUTH_KEY:\r\nkey = ctx.cred->request_key_auth;\r\nif (!key)\r\ngoto error;\r\n__key_get(key);\r\nkey_ref = make_key_ref(key, 1);\r\nbreak;\r\ncase KEY_SPEC_REQUESTOR_KEYRING:\r\nif (!ctx.cred->request_key_auth)\r\ngoto error;\r\ndown_read(&ctx.cred->request_key_auth->sem);\r\nif (test_bit(KEY_FLAG_REVOKED,\r\n&ctx.cred->request_key_auth->flags)) {\r\nkey_ref = ERR_PTR(-EKEYREVOKED);\r\nkey = NULL;\r\n} else {\r\nrka = ctx.cred->request_key_auth->payload.data;\r\nkey = rka->dest_keyring;\r\n__key_get(key);\r\n}\r\nup_read(&ctx.cred->request_key_auth->sem);\r\nif (!key)\r\ngoto error;\r\nkey_ref = make_key_ref(key, 1);\r\nbreak;\r\ndefault:\r\nkey_ref = ERR_PTR(-EINVAL);\r\nif (id < 1)\r\ngoto error;\r\nkey = key_lookup(id);\r\nif (IS_ERR(key)) {\r\nkey_ref = ERR_CAST(key);\r\ngoto error;\r\n}\r\nkey_ref = make_key_ref(key, 0);\r\nctx.index_key.type = key->type;\r\nctx.index_key.description = key->description;\r\nctx.index_key.desc_len = strlen(key->description);\r\nctx.match_data = key;\r\nkdebug("check possessed");\r\nskey_ref = search_process_keyrings(&ctx);\r\nkdebug("possessed=%p", skey_ref);\r\nif (!IS_ERR(skey_ref)) {\r\nkey_put(key);\r\nkey_ref = skey_ref;\r\n}\r\nbreak;\r\n}\r\nif (lflags & KEY_LOOKUP_FOR_UNLINK) {\r\nret = 0;\r\ngoto error;\r\n}\r\nif (!(lflags & KEY_LOOKUP_PARTIAL)) {\r\nret = wait_for_key_construction(key, true);\r\nswitch (ret) {\r\ncase -ERESTARTSYS:\r\ngoto invalid_key;\r\ndefault:\r\nif (perm)\r\ngoto invalid_key;\r\ncase 0:\r\nbreak;\r\n}\r\n} else if (perm) {\r\nret = key_validate(key);\r\nif (ret < 0)\r\ngoto invalid_key;\r\n}\r\nret = -EIO;\r\nif (!(lflags & KEY_LOOKUP_PARTIAL) &&\r\n!test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\r\ngoto invalid_key;\r\nret = key_task_permission(key_ref, ctx.cred, perm);\r\nif (ret < 0)\r\ngoto invalid_key;\r\nkey->last_used_at = current_kernel_time().tv_sec;\r\nerror:\r\nput_cred(ctx.cred);\r\nreturn key_ref;\r\ninvalid_key:\r\nkey_ref_put(key_ref);\r\nkey_ref = ERR_PTR(ret);\r\ngoto error;\r\nreget_creds:\r\nput_cred(ctx.cred);\r\ngoto try_again;\r\n}\r\nlong join_session_keyring(const char *name)\r\n{\r\nconst struct cred *old;\r\nstruct cred *new;\r\nstruct key *keyring;\r\nlong ret, serial;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nold = current_cred();\r\nif (!name) {\r\nret = install_session_keyring_to_cred(new, NULL);\r\nif (ret < 0)\r\ngoto error;\r\nserial = new->session_keyring->serial;\r\nret = commit_creds(new);\r\nif (ret == 0)\r\nret = serial;\r\ngoto okay;\r\n}\r\nmutex_lock(&key_session_mutex);\r\nkeyring = find_keyring_by_name(name, false);\r\nif (PTR_ERR(keyring) == -ENOKEY) {\r\nkeyring = keyring_alloc(\r\nname, old->uid, old->gid, old,\r\nKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\r\nKEY_ALLOC_IN_QUOTA, NULL);\r\nif (IS_ERR(keyring)) {\r\nret = PTR_ERR(keyring);\r\ngoto error2;\r\n}\r\n} else if (IS_ERR(keyring)) {\r\nret = PTR_ERR(keyring);\r\ngoto error2;\r\n} else if (keyring == new->session_keyring) {\r\nret = 0;\r\ngoto error2;\r\n}\r\nret = install_session_keyring_to_cred(new, keyring);\r\nif (ret < 0)\r\ngoto error2;\r\ncommit_creds(new);\r\nmutex_unlock(&key_session_mutex);\r\nret = keyring->serial;\r\nkey_put(keyring);\r\nokay:\r\nreturn ret;\r\nerror2:\r\nmutex_unlock(&key_session_mutex);\r\nerror:\r\nabort_creds(new);\r\nreturn ret;\r\n}\r\nvoid key_change_session_keyring(struct callback_head *twork)\r\n{\r\nconst struct cred *old = current_cred();\r\nstruct cred *new = container_of(twork, struct cred, rcu);\r\nif (unlikely(current->flags & PF_EXITING)) {\r\nput_cred(new);\r\nreturn;\r\n}\r\nnew-> uid = old-> uid;\r\nnew-> euid = old-> euid;\r\nnew-> suid = old-> suid;\r\nnew->fsuid = old->fsuid;\r\nnew-> gid = old-> gid;\r\nnew-> egid = old-> egid;\r\nnew-> sgid = old-> sgid;\r\nnew->fsgid = old->fsgid;\r\nnew->user = get_uid(old->user);\r\nnew->user_ns = get_user_ns(old->user_ns);\r\nnew->group_info = get_group_info(old->group_info);\r\nnew->securebits = old->securebits;\r\nnew->cap_inheritable = old->cap_inheritable;\r\nnew->cap_permitted = old->cap_permitted;\r\nnew->cap_effective = old->cap_effective;\r\nnew->cap_bset = old->cap_bset;\r\nnew->jit_keyring = old->jit_keyring;\r\nnew->thread_keyring = key_get(old->thread_keyring);\r\nnew->process_keyring = key_get(old->process_keyring);\r\nsecurity_transfer_creds(new, old);\r\ncommit_creds(new);\r\n}\r\nstatic int __init init_root_keyring(void)\r\n{\r\nreturn install_user_keyrings();\r\n}
