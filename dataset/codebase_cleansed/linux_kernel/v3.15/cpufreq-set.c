static void print_error(void)\r\n{\r\nprintf(_("Error setting new values. Common errors:\n"\r\n"- Do you have proper administration rights? (super-user?)\n"\r\n"- Is the governor you requested available and modprobed?\n"\r\n"- Trying to set an invalid policy?\n"\r\n"- Trying to set a specific frequency, but userspace governor is not available,\n"\r\n" for example because of hardware which cannot be set to a specific frequency\n"\r\n" or because the userspace governor isn't loaded?\n"));\r\n}\r\nstatic void print_unknown_arg(void)\r\n{\r\nprintf(_("invalid or unknown argument\n"));\r\n}\r\nstatic unsigned long string_to_frequency(const char *str)\r\n{\r\nchar normalized[NORM_FREQ_LEN];\r\nconst struct freq_units *unit;\r\nconst char *scan;\r\nchar *end;\r\nunsigned long freq;\r\nint power = 0, match_count = 0, i, cp, pad;\r\nwhile (*str == '0')\r\nstr++;\r\nfor (scan = str; isdigit(*scan) || *scan == '.'; scan++) {\r\nif (*scan == '.' && match_count == 0)\r\nmatch_count = 1;\r\nelse if (*scan == '.' && match_count == 1)\r\nreturn 0;\r\n}\r\nif (*scan) {\r\nmatch_count = 0;\r\nfor (unit = def_units; unit->str_unit; unit++) {\r\nfor (i = 0;\r\nscan[i] && tolower(scan[i]) == unit->str_unit[i];\r\n++i)\r\ncontinue;\r\nif (scan[i])\r\ncontinue;\r\nmatch_count++;\r\npower = unit->power_of_ten;\r\n}\r\nif (match_count != 1)\r\nreturn 0;\r\n}\r\nfor (cp = 0; isdigit(str[cp]); cp++)\r\ncontinue;\r\nif (str[cp] == '.') {\r\nwhile (power > -1 && isdigit(str[cp+1]))\r\ncp++, power--;\r\n}\r\nif (power >= -1)\r\npad = power + 1;\r\nelse\r\npad = 0, cp += power + 1;\r\nif (cp <= 0 || cp + pad > NORM_FREQ_LEN - 1)\r\nreturn 0;\r\nfor (i = 0; i < cp; i++, str++) {\r\nif (*str == '.')\r\nstr++;\r\nnormalized[i] = *str;\r\n}\r\nfor (; i < cp + pad; i++)\r\nnormalized[i] = '0';\r\nmatch_count = (normalized[i-1] >= '5');\r\nnormalized[i-1] = 0;\r\nerrno = 0;\r\nfreq = strtoul(normalized, &end, 10);\r\nif (errno)\r\nreturn 0;\r\nelse {\r\nif (match_count && freq != ULONG_MAX)\r\nfreq++;\r\nreturn freq;\r\n}\r\n}\r\nstatic int do_new_policy(unsigned int cpu, struct cpufreq_policy *new_pol)\r\n{\r\nstruct cpufreq_policy *cur_pol = cpufreq_get_policy(cpu);\r\nint ret;\r\nif (!cur_pol) {\r\nprintf(_("wrong, unknown or unhandled CPU?\n"));\r\nreturn -EINVAL;\r\n}\r\nif (!new_pol->min)\r\nnew_pol->min = cur_pol->min;\r\nif (!new_pol->max)\r\nnew_pol->max = cur_pol->max;\r\nif (!new_pol->governor)\r\nnew_pol->governor = cur_pol->governor;\r\nret = cpufreq_set_policy(cpu, new_pol);\r\ncpufreq_put_policy(cur_pol);\r\nreturn ret;\r\n}\r\nstatic int do_one_cpu(unsigned int cpu, struct cpufreq_policy *new_pol,\r\nunsigned long freq, unsigned int pc)\r\n{\r\nswitch (pc) {\r\ncase 0:\r\nreturn cpufreq_set_frequency(cpu, freq);\r\ncase 1:\r\nif (new_pol->min)\r\nreturn cpufreq_modify_policy_min(cpu, new_pol->min);\r\nelse if (new_pol->max)\r\nreturn cpufreq_modify_policy_max(cpu, new_pol->max);\r\nelse if (new_pol->governor)\r\nreturn cpufreq_modify_policy_governor(cpu,\r\nnew_pol->governor);\r\ndefault:\r\nreturn do_new_policy(cpu, new_pol);\r\n}\r\n}\r\nint cmd_freq_set(int argc, char **argv)\r\n{\r\nextern char *optarg;\r\nextern int optind, opterr, optopt;\r\nint ret = 0, cont = 1;\r\nint double_parm = 0, related = 0, policychange = 0;\r\nunsigned long freq = 0;\r\nchar gov[20];\r\nunsigned int cpu;\r\nstruct cpufreq_policy new_pol = {\r\n.min = 0,\r\n.max = 0,\r\n.governor = NULL,\r\n};\r\ndo {\r\nret = getopt_long(argc, argv, "d:u:g:f:r", set_opts, NULL);\r\nswitch (ret) {\r\ncase '?':\r\nprint_unknown_arg();\r\nreturn -EINVAL;\r\ncase -1:\r\ncont = 0;\r\nbreak;\r\ncase 'r':\r\nif (related)\r\ndouble_parm++;\r\nrelated++;\r\nbreak;\r\ncase 'd':\r\nif (new_pol.min)\r\ndouble_parm++;\r\npolicychange++;\r\nnew_pol.min = string_to_frequency(optarg);\r\nif (new_pol.min == 0) {\r\nprint_unknown_arg();\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 'u':\r\nif (new_pol.max)\r\ndouble_parm++;\r\npolicychange++;\r\nnew_pol.max = string_to_frequency(optarg);\r\nif (new_pol.max == 0) {\r\nprint_unknown_arg();\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 'f':\r\nif (freq)\r\ndouble_parm++;\r\nfreq = string_to_frequency(optarg);\r\nif (freq == 0) {\r\nprint_unknown_arg();\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 'g':\r\nif (new_pol.governor)\r\ndouble_parm++;\r\npolicychange++;\r\nif ((strlen(optarg) < 3) || (strlen(optarg) > 18)) {\r\nprint_unknown_arg();\r\nreturn -EINVAL;\r\n}\r\nif ((sscanf(optarg, "%19s", gov)) != 1) {\r\nprint_unknown_arg();\r\nreturn -EINVAL;\r\n}\r\nnew_pol.governor = gov;\r\nbreak;\r\n}\r\n} while (cont);\r\nif (double_parm) {\r\nprintf("the same parameter was passed more than once\n");\r\nreturn -EINVAL;\r\n}\r\nif (freq && policychange) {\r\nprintf(_("the -f/--freq parameter cannot be combined with -d/--min, -u/--max or\n"\r\n"-g/--governor parameters\n"));\r\nreturn -EINVAL;\r\n}\r\nif (!freq && !policychange) {\r\nprintf(_("At least one parameter out of -f/--freq, -d/--min, -u/--max, and\n"\r\n"-g/--governor must be passed\n"));\r\nreturn -EINVAL;\r\n}\r\nif (bitmask_isallclear(cpus_chosen))\r\nbitmask_setall(cpus_chosen);\r\nif (related) {\r\nfor (cpu = bitmask_first(cpus_chosen);\r\ncpu <= bitmask_last(cpus_chosen); cpu++) {\r\nstruct cpufreq_affected_cpus *cpus;\r\nif (!bitmask_isbitset(cpus_chosen, cpu) ||\r\ncpufreq_cpu_exists(cpu))\r\ncontinue;\r\ncpus = cpufreq_get_related_cpus(cpu);\r\nif (!cpus)\r\nbreak;\r\nwhile (cpus->next) {\r\nbitmask_setbit(cpus_chosen, cpus->cpu);\r\ncpus = cpus->next;\r\n}\r\ncpufreq_put_related_cpus(cpus);\r\n}\r\n}\r\nfor (cpu = bitmask_first(cpus_chosen);\r\ncpu <= bitmask_last(cpus_chosen); cpu++) {\r\nif (!bitmask_isbitset(cpus_chosen, cpu) ||\r\ncpufreq_cpu_exists(cpu))\r\ncontinue;\r\nprintf(_("Setting cpu: %d\n"), cpu);\r\nret = do_one_cpu(cpu, &new_pol, freq, policychange);\r\nif (ret)\r\nbreak;\r\n}\r\nif (ret)\r\nprint_error();\r\nreturn ret;\r\n}
