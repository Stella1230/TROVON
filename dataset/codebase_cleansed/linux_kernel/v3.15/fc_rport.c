static struct fc_rport_priv *fc_rport_lookup(const struct fc_lport *lport,\r\nu32 port_id)\r\n{\r\nstruct fc_rport_priv *rdata;\r\nlist_for_each_entry_rcu(rdata, &lport->disc.rports, peers)\r\nif (rdata->ids.port_id == port_id)\r\nreturn rdata;\r\nreturn NULL;\r\n}\r\nstatic struct fc_rport_priv *fc_rport_create(struct fc_lport *lport,\r\nu32 port_id)\r\n{\r\nstruct fc_rport_priv *rdata;\r\nrdata = lport->tt.rport_lookup(lport, port_id);\r\nif (rdata)\r\nreturn rdata;\r\nrdata = kzalloc(sizeof(*rdata) + lport->rport_priv_size, GFP_KERNEL);\r\nif (!rdata)\r\nreturn NULL;\r\nrdata->ids.node_name = -1;\r\nrdata->ids.port_name = -1;\r\nrdata->ids.port_id = port_id;\r\nrdata->ids.roles = FC_RPORT_ROLE_UNKNOWN;\r\nkref_init(&rdata->kref);\r\nmutex_init(&rdata->rp_mutex);\r\nrdata->local_port = lport;\r\nrdata->rp_state = RPORT_ST_INIT;\r\nrdata->event = RPORT_EV_NONE;\r\nrdata->flags = FC_RP_FLAGS_REC_SUPPORTED;\r\nrdata->e_d_tov = lport->e_d_tov;\r\nrdata->r_a_tov = lport->r_a_tov;\r\nrdata->maxframe_size = FC_MIN_MAX_PAYLOAD;\r\nINIT_DELAYED_WORK(&rdata->retry_work, fc_rport_timeout);\r\nINIT_WORK(&rdata->event_work, fc_rport_work);\r\nif (port_id != FC_FID_DIR_SERV) {\r\nrdata->lld_event_callback = lport->tt.rport_event_callback;\r\nlist_add_rcu(&rdata->peers, &lport->disc.rports);\r\n}\r\nreturn rdata;\r\n}\r\nstatic void fc_rport_destroy(struct kref *kref)\r\n{\r\nstruct fc_rport_priv *rdata;\r\nrdata = container_of(kref, struct fc_rport_priv, kref);\r\nkfree_rcu(rdata, rcu);\r\n}\r\nstatic const char *fc_rport_state(struct fc_rport_priv *rdata)\r\n{\r\nconst char *cp;\r\ncp = fc_rport_state_names[rdata->rp_state];\r\nif (!cp)\r\ncp = "Unknown";\r\nreturn cp;\r\n}\r\nvoid fc_set_rport_loss_tmo(struct fc_rport *rport, u32 timeout)\r\n{\r\nif (timeout)\r\nrport->dev_loss_tmo = timeout;\r\nelse\r\nrport->dev_loss_tmo = 1;\r\n}\r\nstatic unsigned int fc_plogi_get_maxframe(struct fc_els_flogi *flp,\r\nunsigned int maxval)\r\n{\r\nunsigned int mfs;\r\nmfs = ntohs(flp->fl_csp.sp_bb_data) & FC_SP_BB_DATA_MASK;\r\nif (mfs >= FC_SP_MIN_MAX_PAYLOAD && mfs < maxval)\r\nmaxval = mfs;\r\nmfs = ntohs(flp->fl_cssp[3 - 1].cp_rdfs);\r\nif (mfs >= FC_SP_MIN_MAX_PAYLOAD && mfs < maxval)\r\nmaxval = mfs;\r\nreturn maxval;\r\n}\r\nstatic void fc_rport_state_enter(struct fc_rport_priv *rdata,\r\nenum fc_rport_state new)\r\n{\r\nif (rdata->rp_state != new)\r\nrdata->retries = 0;\r\nrdata->rp_state = new;\r\n}\r\nstatic void fc_rport_work(struct work_struct *work)\r\n{\r\nu32 port_id;\r\nstruct fc_rport_priv *rdata =\r\ncontainer_of(work, struct fc_rport_priv, event_work);\r\nstruct fc_rport_libfc_priv *rpriv;\r\nenum fc_rport_event event;\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct fc_rport_operations *rport_ops;\r\nstruct fc_rport_identifiers ids;\r\nstruct fc_rport *rport;\r\nstruct fc4_prov *prov;\r\nu8 type;\r\nmutex_lock(&rdata->rp_mutex);\r\nevent = rdata->event;\r\nrport_ops = rdata->ops;\r\nrport = rdata->rport;\r\nFC_RPORT_DBG(rdata, "work event %u\n", event);\r\nswitch (event) {\r\ncase RPORT_EV_READY:\r\nids = rdata->ids;\r\nrdata->event = RPORT_EV_NONE;\r\nrdata->major_retries = 0;\r\nkref_get(&rdata->kref);\r\nmutex_unlock(&rdata->rp_mutex);\r\nif (!rport)\r\nrport = fc_remote_port_add(lport->host, 0, &ids);\r\nif (!rport) {\r\nFC_RPORT_DBG(rdata, "Failed to add the rport\n");\r\nlport->tt.rport_logoff(rdata);\r\nkref_put(&rdata->kref, lport->tt.rport_destroy);\r\nreturn;\r\n}\r\nmutex_lock(&rdata->rp_mutex);\r\nif (rdata->rport)\r\nFC_RPORT_DBG(rdata, "rport already allocated\n");\r\nrdata->rport = rport;\r\nrport->maxframe_size = rdata->maxframe_size;\r\nrport->supported_classes = rdata->supported_classes;\r\nrpriv = rport->dd_data;\r\nrpriv->local_port = lport;\r\nrpriv->rp_state = rdata->rp_state;\r\nrpriv->flags = rdata->flags;\r\nrpriv->e_d_tov = rdata->e_d_tov;\r\nrpriv->r_a_tov = rdata->r_a_tov;\r\nmutex_unlock(&rdata->rp_mutex);\r\nif (rport_ops && rport_ops->event_callback) {\r\nFC_RPORT_DBG(rdata, "callback ev %d\n", event);\r\nrport_ops->event_callback(lport, rdata, event);\r\n}\r\nif (rdata->lld_event_callback) {\r\nFC_RPORT_DBG(rdata, "lld callback ev %d\n", event);\r\nrdata->lld_event_callback(lport, rdata, event);\r\n}\r\nkref_put(&rdata->kref, lport->tt.rport_destroy);\r\nbreak;\r\ncase RPORT_EV_FAILED:\r\ncase RPORT_EV_LOGO:\r\ncase RPORT_EV_STOP:\r\nif (rdata->prli_count) {\r\nmutex_lock(&fc_prov_mutex);\r\nfor (type = 1; type < FC_FC4_PROV_SIZE; type++) {\r\nprov = fc_passive_prov[type];\r\nif (prov && prov->prlo)\r\nprov->prlo(rdata);\r\n}\r\nmutex_unlock(&fc_prov_mutex);\r\n}\r\nport_id = rdata->ids.port_id;\r\nmutex_unlock(&rdata->rp_mutex);\r\nif (rport_ops && rport_ops->event_callback) {\r\nFC_RPORT_DBG(rdata, "callback ev %d\n", event);\r\nrport_ops->event_callback(lport, rdata, event);\r\n}\r\nif (rdata->lld_event_callback) {\r\nFC_RPORT_DBG(rdata, "lld callback ev %d\n", event);\r\nrdata->lld_event_callback(lport, rdata, event);\r\n}\r\ncancel_delayed_work_sync(&rdata->retry_work);\r\nlport->tt.exch_mgr_reset(lport, 0, port_id);\r\nlport->tt.exch_mgr_reset(lport, port_id, 0);\r\nif (rport) {\r\nrpriv = rport->dd_data;\r\nrpriv->rp_state = RPORT_ST_DELETE;\r\nmutex_lock(&rdata->rp_mutex);\r\nrdata->rport = NULL;\r\nmutex_unlock(&rdata->rp_mutex);\r\nfc_remote_port_delete(rport);\r\n}\r\nmutex_lock(&lport->disc.disc_mutex);\r\nmutex_lock(&rdata->rp_mutex);\r\nif (rdata->rp_state == RPORT_ST_DELETE) {\r\nif (port_id == FC_FID_DIR_SERV) {\r\nrdata->event = RPORT_EV_NONE;\r\nmutex_unlock(&rdata->rp_mutex);\r\nkref_put(&rdata->kref, lport->tt.rport_destroy);\r\n} else if ((rdata->flags & FC_RP_STARTED) &&\r\nrdata->major_retries <\r\nlport->max_rport_retry_count) {\r\nrdata->major_retries++;\r\nrdata->event = RPORT_EV_NONE;\r\nFC_RPORT_DBG(rdata, "work restart\n");\r\nfc_rport_enter_flogi(rdata);\r\nmutex_unlock(&rdata->rp_mutex);\r\n} else {\r\nFC_RPORT_DBG(rdata, "work delete\n");\r\nlist_del_rcu(&rdata->peers);\r\nmutex_unlock(&rdata->rp_mutex);\r\nkref_put(&rdata->kref, lport->tt.rport_destroy);\r\n}\r\n} else {\r\nrdata->event = RPORT_EV_NONE;\r\nif (rdata->rp_state == RPORT_ST_READY)\r\nfc_rport_enter_ready(rdata);\r\nmutex_unlock(&rdata->rp_mutex);\r\n}\r\nmutex_unlock(&lport->disc.disc_mutex);\r\nbreak;\r\ndefault:\r\nmutex_unlock(&rdata->rp_mutex);\r\nbreak;\r\n}\r\n}\r\nstatic int fc_rport_login(struct fc_rport_priv *rdata)\r\n{\r\nmutex_lock(&rdata->rp_mutex);\r\nrdata->flags |= FC_RP_STARTED;\r\nswitch (rdata->rp_state) {\r\ncase RPORT_ST_READY:\r\nFC_RPORT_DBG(rdata, "ADISC port\n");\r\nfc_rport_enter_adisc(rdata);\r\nbreak;\r\ncase RPORT_ST_DELETE:\r\nFC_RPORT_DBG(rdata, "Restart deleted port\n");\r\nbreak;\r\ndefault:\r\nFC_RPORT_DBG(rdata, "Login to port\n");\r\nfc_rport_enter_flogi(rdata);\r\nbreak;\r\n}\r\nmutex_unlock(&rdata->rp_mutex);\r\nreturn 0;\r\n}\r\nstatic void fc_rport_enter_delete(struct fc_rport_priv *rdata,\r\nenum fc_rport_event event)\r\n{\r\nif (rdata->rp_state == RPORT_ST_DELETE)\r\nreturn;\r\nFC_RPORT_DBG(rdata, "Delete port\n");\r\nfc_rport_state_enter(rdata, RPORT_ST_DELETE);\r\nif (rdata->event == RPORT_EV_NONE)\r\nqueue_work(rport_event_queue, &rdata->event_work);\r\nrdata->event = event;\r\n}\r\nstatic int fc_rport_logoff(struct fc_rport_priv *rdata)\r\n{\r\nmutex_lock(&rdata->rp_mutex);\r\nFC_RPORT_DBG(rdata, "Remove port\n");\r\nrdata->flags &= ~FC_RP_STARTED;\r\nif (rdata->rp_state == RPORT_ST_DELETE) {\r\nFC_RPORT_DBG(rdata, "Port in Delete state, not removing\n");\r\ngoto out;\r\n}\r\nfc_rport_enter_logo(rdata);\r\nfc_rport_enter_delete(rdata, RPORT_EV_STOP);\r\nout:\r\nmutex_unlock(&rdata->rp_mutex);\r\nreturn 0;\r\n}\r\nstatic void fc_rport_enter_ready(struct fc_rport_priv *rdata)\r\n{\r\nfc_rport_state_enter(rdata, RPORT_ST_READY);\r\nFC_RPORT_DBG(rdata, "Port is Ready\n");\r\nif (rdata->event == RPORT_EV_NONE)\r\nqueue_work(rport_event_queue, &rdata->event_work);\r\nrdata->event = RPORT_EV_READY;\r\n}\r\nstatic void fc_rport_timeout(struct work_struct *work)\r\n{\r\nstruct fc_rport_priv *rdata =\r\ncontainer_of(work, struct fc_rport_priv, retry_work.work);\r\nmutex_lock(&rdata->rp_mutex);\r\nswitch (rdata->rp_state) {\r\ncase RPORT_ST_FLOGI:\r\nfc_rport_enter_flogi(rdata);\r\nbreak;\r\ncase RPORT_ST_PLOGI:\r\nfc_rport_enter_plogi(rdata);\r\nbreak;\r\ncase RPORT_ST_PRLI:\r\nfc_rport_enter_prli(rdata);\r\nbreak;\r\ncase RPORT_ST_RTV:\r\nfc_rport_enter_rtv(rdata);\r\nbreak;\r\ncase RPORT_ST_ADISC:\r\nfc_rport_enter_adisc(rdata);\r\nbreak;\r\ncase RPORT_ST_PLOGI_WAIT:\r\ncase RPORT_ST_READY:\r\ncase RPORT_ST_INIT:\r\ncase RPORT_ST_DELETE:\r\nbreak;\r\n}\r\nmutex_unlock(&rdata->rp_mutex);\r\n}\r\nstatic void fc_rport_error(struct fc_rport_priv *rdata, struct fc_frame *fp)\r\n{\r\nFC_RPORT_DBG(rdata, "Error %ld in state %s, retries %d\n",\r\nIS_ERR(fp) ? -PTR_ERR(fp) : 0,\r\nfc_rport_state(rdata), rdata->retries);\r\nswitch (rdata->rp_state) {\r\ncase RPORT_ST_FLOGI:\r\ncase RPORT_ST_PLOGI:\r\nrdata->flags &= ~FC_RP_STARTED;\r\nfc_rport_enter_delete(rdata, RPORT_EV_FAILED);\r\nbreak;\r\ncase RPORT_ST_RTV:\r\nfc_rport_enter_ready(rdata);\r\nbreak;\r\ncase RPORT_ST_PRLI:\r\ncase RPORT_ST_ADISC:\r\nfc_rport_enter_logo(rdata);\r\nbreak;\r\ncase RPORT_ST_PLOGI_WAIT:\r\ncase RPORT_ST_DELETE:\r\ncase RPORT_ST_READY:\r\ncase RPORT_ST_INIT:\r\nbreak;\r\n}\r\n}\r\nstatic void fc_rport_error_retry(struct fc_rport_priv *rdata,\r\nstruct fc_frame *fp)\r\n{\r\nunsigned long delay = msecs_to_jiffies(FC_DEF_E_D_TOV);\r\nif (PTR_ERR(fp) == -FC_EX_CLOSED)\r\ngoto out;\r\nif (rdata->retries < rdata->local_port->max_rport_retry_count) {\r\nFC_RPORT_DBG(rdata, "Error %ld in state %s, retrying\n",\r\nPTR_ERR(fp), fc_rport_state(rdata));\r\nrdata->retries++;\r\nif (PTR_ERR(fp) == -FC_EX_TIMEOUT)\r\ndelay = 0;\r\nschedule_delayed_work(&rdata->retry_work, delay);\r\nreturn;\r\n}\r\nout:\r\nfc_rport_error(rdata, fp);\r\n}\r\nstatic int fc_rport_login_complete(struct fc_rport_priv *rdata,\r\nstruct fc_frame *fp)\r\n{\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct fc_els_flogi *flogi;\r\nunsigned int e_d_tov;\r\nu16 csp_flags;\r\nflogi = fc_frame_payload_get(fp, sizeof(*flogi));\r\nif (!flogi)\r\nreturn -EINVAL;\r\ncsp_flags = ntohs(flogi->fl_csp.sp_features);\r\nif (fc_frame_payload_op(fp) == ELS_FLOGI) {\r\nif (csp_flags & FC_SP_FT_FPORT) {\r\nFC_RPORT_DBG(rdata, "Fabric bit set in FLOGI\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ne_d_tov = ntohl(flogi->fl_csp.sp_e_d_tov);\r\nif (csp_flags & FC_SP_FT_EDTR)\r\ne_d_tov /= 1000000;\r\nif (e_d_tov > rdata->e_d_tov)\r\nrdata->e_d_tov = e_d_tov;\r\n}\r\nrdata->maxframe_size = fc_plogi_get_maxframe(flogi, lport->mfs);\r\nreturn 0;\r\n}\r\nstatic void fc_rport_flogi_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *rp_arg)\r\n{\r\nstruct fc_rport_priv *rdata = rp_arg;\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct fc_els_flogi *flogi;\r\nunsigned int r_a_tov;\r\nFC_RPORT_DBG(rdata, "Received a FLOGI %s\n", fc_els_resp_type(fp));\r\nif (fp == ERR_PTR(-FC_EX_CLOSED))\r\ngoto put;\r\nmutex_lock(&rdata->rp_mutex);\r\nif (rdata->rp_state != RPORT_ST_FLOGI) {\r\nFC_RPORT_DBG(rdata, "Received a FLOGI response, but in state "\r\n"%s\n", fc_rport_state(rdata));\r\nif (IS_ERR(fp))\r\ngoto err;\r\ngoto out;\r\n}\r\nif (IS_ERR(fp)) {\r\nfc_rport_error(rdata, fp);\r\ngoto err;\r\n}\r\nif (fc_frame_payload_op(fp) != ELS_LS_ACC)\r\ngoto bad;\r\nif (fc_rport_login_complete(rdata, fp))\r\ngoto bad;\r\nflogi = fc_frame_payload_get(fp, sizeof(*flogi));\r\nif (!flogi)\r\ngoto bad;\r\nr_a_tov = ntohl(flogi->fl_csp.sp_r_a_tov);\r\nif (r_a_tov > rdata->r_a_tov)\r\nrdata->r_a_tov = r_a_tov;\r\nif (rdata->ids.port_name < lport->wwpn)\r\nfc_rport_enter_plogi(rdata);\r\nelse\r\nfc_rport_state_enter(rdata, RPORT_ST_PLOGI_WAIT);\r\nout:\r\nfc_frame_free(fp);\r\nerr:\r\nmutex_unlock(&rdata->rp_mutex);\r\nput:\r\nkref_put(&rdata->kref, rdata->local_port->tt.rport_destroy);\r\nreturn;\r\nbad:\r\nFC_RPORT_DBG(rdata, "Bad FLOGI response\n");\r\nfc_rport_error_retry(rdata, fp);\r\ngoto out;\r\n}\r\nstatic void fc_rport_enter_flogi(struct fc_rport_priv *rdata)\r\n{\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct fc_frame *fp;\r\nif (!lport->point_to_multipoint)\r\nreturn fc_rport_enter_plogi(rdata);\r\nFC_RPORT_DBG(rdata, "Entered FLOGI state from %s state\n",\r\nfc_rport_state(rdata));\r\nfc_rport_state_enter(rdata, RPORT_ST_FLOGI);\r\nfp = fc_frame_alloc(lport, sizeof(struct fc_els_flogi));\r\nif (!fp)\r\nreturn fc_rport_error_retry(rdata, fp);\r\nif (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_FLOGI,\r\nfc_rport_flogi_resp, rdata,\r\n2 * lport->r_a_tov))\r\nfc_rport_error_retry(rdata, NULL);\r\nelse\r\nkref_get(&rdata->kref);\r\n}\r\nstatic void fc_rport_recv_flogi_req(struct fc_lport *lport,\r\nstruct fc_frame *rx_fp)\r\n{\r\nstruct fc_disc *disc;\r\nstruct fc_els_flogi *flp;\r\nstruct fc_rport_priv *rdata;\r\nstruct fc_frame *fp = rx_fp;\r\nstruct fc_seq_els_data rjt_data;\r\nu32 sid;\r\nsid = fc_frame_sid(fp);\r\nFC_RPORT_ID_DBG(lport, sid, "Received FLOGI request\n");\r\ndisc = &lport->disc;\r\nmutex_lock(&disc->disc_mutex);\r\nif (!lport->point_to_multipoint) {\r\nrjt_data.reason = ELS_RJT_UNSUP;\r\nrjt_data.explan = ELS_EXPL_NONE;\r\ngoto reject;\r\n}\r\nflp = fc_frame_payload_get(fp, sizeof(*flp));\r\nif (!flp) {\r\nrjt_data.reason = ELS_RJT_LOGIC;\r\nrjt_data.explan = ELS_EXPL_INV_LEN;\r\ngoto reject;\r\n}\r\nrdata = lport->tt.rport_lookup(lport, sid);\r\nif (!rdata) {\r\nrjt_data.reason = ELS_RJT_FIP;\r\nrjt_data.explan = ELS_EXPL_NOT_NEIGHBOR;\r\ngoto reject;\r\n}\r\nmutex_lock(&rdata->rp_mutex);\r\nFC_RPORT_DBG(rdata, "Received FLOGI in %s state\n",\r\nfc_rport_state(rdata));\r\nswitch (rdata->rp_state) {\r\ncase RPORT_ST_INIT:\r\nif (lport->point_to_multipoint)\r\nbreak;\r\ncase RPORT_ST_DELETE:\r\nmutex_unlock(&rdata->rp_mutex);\r\nrjt_data.reason = ELS_RJT_FIP;\r\nrjt_data.explan = ELS_EXPL_NOT_NEIGHBOR;\r\ngoto reject;\r\ncase RPORT_ST_FLOGI:\r\ncase RPORT_ST_PLOGI_WAIT:\r\ncase RPORT_ST_PLOGI:\r\nbreak;\r\ncase RPORT_ST_PRLI:\r\ncase RPORT_ST_RTV:\r\ncase RPORT_ST_READY:\r\ncase RPORT_ST_ADISC:\r\nfc_rport_enter_delete(rdata, RPORT_EV_LOGO);\r\nmutex_unlock(&rdata->rp_mutex);\r\nrjt_data.reason = ELS_RJT_BUSY;\r\nrjt_data.explan = ELS_EXPL_NONE;\r\ngoto reject;\r\n}\r\nif (fc_rport_login_complete(rdata, fp)) {\r\nmutex_unlock(&rdata->rp_mutex);\r\nrjt_data.reason = ELS_RJT_LOGIC;\r\nrjt_data.explan = ELS_EXPL_NONE;\r\ngoto reject;\r\n}\r\nfp = fc_frame_alloc(lport, sizeof(*flp));\r\nif (!fp)\r\ngoto out;\r\nfc_flogi_fill(lport, fp);\r\nflp = fc_frame_payload_get(fp, sizeof(*flp));\r\nflp->fl_cmd = ELS_LS_ACC;\r\nfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\r\nlport->tt.frame_send(lport, fp);\r\nif (rdata->ids.port_name < lport->wwpn)\r\nfc_rport_enter_plogi(rdata);\r\nelse\r\nfc_rport_state_enter(rdata, RPORT_ST_PLOGI_WAIT);\r\nout:\r\nmutex_unlock(&rdata->rp_mutex);\r\nmutex_unlock(&disc->disc_mutex);\r\nfc_frame_free(rx_fp);\r\nreturn;\r\nreject:\r\nmutex_unlock(&disc->disc_mutex);\r\nlport->tt.seq_els_rsp_send(rx_fp, ELS_LS_RJT, &rjt_data);\r\nfc_frame_free(rx_fp);\r\n}\r\nstatic void fc_rport_plogi_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *rdata_arg)\r\n{\r\nstruct fc_rport_priv *rdata = rdata_arg;\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct fc_els_flogi *plp = NULL;\r\nu16 csp_seq;\r\nu16 cssp_seq;\r\nu8 op;\r\nmutex_lock(&rdata->rp_mutex);\r\nFC_RPORT_DBG(rdata, "Received a PLOGI %s\n", fc_els_resp_type(fp));\r\nif (rdata->rp_state != RPORT_ST_PLOGI) {\r\nFC_RPORT_DBG(rdata, "Received a PLOGI response, but in state "\r\n"%s\n", fc_rport_state(rdata));\r\nif (IS_ERR(fp))\r\ngoto err;\r\ngoto out;\r\n}\r\nif (IS_ERR(fp)) {\r\nfc_rport_error_retry(rdata, fp);\r\ngoto err;\r\n}\r\nop = fc_frame_payload_op(fp);\r\nif (op == ELS_LS_ACC &&\r\n(plp = fc_frame_payload_get(fp, sizeof(*plp))) != NULL) {\r\nrdata->ids.port_name = get_unaligned_be64(&plp->fl_wwpn);\r\nrdata->ids.node_name = get_unaligned_be64(&plp->fl_wwnn);\r\nrdata->sp_features = ntohs(plp->fl_csp.sp_features);\r\nif (lport->point_to_multipoint)\r\nfc_rport_login_complete(rdata, fp);\r\ncsp_seq = ntohs(plp->fl_csp.sp_tot_seq);\r\ncssp_seq = ntohs(plp->fl_cssp[3 - 1].cp_con_seq);\r\nif (cssp_seq < csp_seq)\r\ncsp_seq = cssp_seq;\r\nrdata->max_seq = csp_seq;\r\nrdata->maxframe_size = fc_plogi_get_maxframe(plp, lport->mfs);\r\nfc_rport_enter_prli(rdata);\r\n} else\r\nfc_rport_error_retry(rdata, fp);\r\nout:\r\nfc_frame_free(fp);\r\nerr:\r\nmutex_unlock(&rdata->rp_mutex);\r\nkref_put(&rdata->kref, rdata->local_port->tt.rport_destroy);\r\n}\r\nstatic bool\r\nfc_rport_compatible_roles(struct fc_lport *lport, struct fc_rport_priv *rdata)\r\n{\r\nif (rdata->ids.roles == FC_PORT_ROLE_UNKNOWN)\r\nreturn true;\r\nif ((rdata->ids.roles & FC_PORT_ROLE_FCP_TARGET) &&\r\n(lport->service_params & FCP_SPPF_INIT_FCN))\r\nreturn true;\r\nif ((rdata->ids.roles & FC_PORT_ROLE_FCP_INITIATOR) &&\r\n(lport->service_params & FCP_SPPF_TARG_FCN))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void fc_rport_enter_plogi(struct fc_rport_priv *rdata)\r\n{\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct fc_frame *fp;\r\nif (!fc_rport_compatible_roles(lport, rdata)) {\r\nFC_RPORT_DBG(rdata, "PLOGI suppressed for incompatible role\n");\r\nfc_rport_state_enter(rdata, RPORT_ST_PLOGI_WAIT);\r\nreturn;\r\n}\r\nFC_RPORT_DBG(rdata, "Port entered PLOGI state from %s state\n",\r\nfc_rport_state(rdata));\r\nfc_rport_state_enter(rdata, RPORT_ST_PLOGI);\r\nrdata->maxframe_size = FC_MIN_MAX_PAYLOAD;\r\nfp = fc_frame_alloc(lport, sizeof(struct fc_els_flogi));\r\nif (!fp) {\r\nFC_RPORT_DBG(rdata, "%s frame alloc failed\n", __func__);\r\nfc_rport_error_retry(rdata, fp);\r\nreturn;\r\n}\r\nrdata->e_d_tov = lport->e_d_tov;\r\nif (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_PLOGI,\r\nfc_rport_plogi_resp, rdata,\r\n2 * lport->r_a_tov))\r\nfc_rport_error_retry(rdata, NULL);\r\nelse\r\nkref_get(&rdata->kref);\r\n}\r\nstatic void fc_rport_prli_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *rdata_arg)\r\n{\r\nstruct fc_rport_priv *rdata = rdata_arg;\r\nstruct {\r\nstruct fc_els_prli prli;\r\nstruct fc_els_spp spp;\r\n} *pp;\r\nstruct fc_els_spp temp_spp;\r\nstruct fc4_prov *prov;\r\nu32 roles = FC_RPORT_ROLE_UNKNOWN;\r\nu32 fcp_parm = 0;\r\nu8 op;\r\nu8 resp_code = 0;\r\nmutex_lock(&rdata->rp_mutex);\r\nFC_RPORT_DBG(rdata, "Received a PRLI %s\n", fc_els_resp_type(fp));\r\nif (rdata->rp_state != RPORT_ST_PRLI) {\r\nFC_RPORT_DBG(rdata, "Received a PRLI response, but in state "\r\n"%s\n", fc_rport_state(rdata));\r\nif (IS_ERR(fp))\r\ngoto err;\r\ngoto out;\r\n}\r\nif (IS_ERR(fp)) {\r\nfc_rport_error_retry(rdata, fp);\r\ngoto err;\r\n}\r\nrdata->ids.roles = FC_RPORT_ROLE_UNKNOWN;\r\nop = fc_frame_payload_op(fp);\r\nif (op == ELS_LS_ACC) {\r\npp = fc_frame_payload_get(fp, sizeof(*pp));\r\nif (!pp)\r\ngoto out;\r\nresp_code = (pp->spp.spp_flags & FC_SPP_RESP_MASK);\r\nFC_RPORT_DBG(rdata, "PRLI spp_flags = 0x%x\n",\r\npp->spp.spp_flags);\r\nrdata->spp_type = pp->spp.spp_type;\r\nif (resp_code != FC_SPP_RESP_ACK) {\r\nif (resp_code == FC_SPP_RESP_CONF)\r\nfc_rport_error(rdata, fp);\r\nelse\r\nfc_rport_error_retry(rdata, fp);\r\ngoto out;\r\n}\r\nif (pp->prli.prli_spp_len < sizeof(pp->spp))\r\ngoto out;\r\nfcp_parm = ntohl(pp->spp.spp_params);\r\nif (fcp_parm & FCP_SPPF_RETRY)\r\nrdata->flags |= FC_RP_FLAGS_RETRY;\r\nif (fcp_parm & FCP_SPPF_CONF_COMPL)\r\nrdata->flags |= FC_RP_FLAGS_CONF_REQ;\r\nprov = fc_passive_prov[FC_TYPE_FCP];\r\nif (prov) {\r\nmemset(&temp_spp, 0, sizeof(temp_spp));\r\nprov->prli(rdata, pp->prli.prli_spp_len,\r\n&pp->spp, &temp_spp);\r\n}\r\nrdata->supported_classes = FC_COS_CLASS3;\r\nif (fcp_parm & FCP_SPPF_INIT_FCN)\r\nroles |= FC_RPORT_ROLE_FCP_INITIATOR;\r\nif (fcp_parm & FCP_SPPF_TARG_FCN)\r\nroles |= FC_RPORT_ROLE_FCP_TARGET;\r\nrdata->ids.roles = roles;\r\nfc_rport_enter_rtv(rdata);\r\n} else {\r\nFC_RPORT_DBG(rdata, "Bad ELS response for PRLI command\n");\r\nfc_rport_error_retry(rdata, fp);\r\n}\r\nout:\r\nfc_frame_free(fp);\r\nerr:\r\nmutex_unlock(&rdata->rp_mutex);\r\nkref_put(&rdata->kref, rdata->local_port->tt.rport_destroy);\r\n}\r\nstatic void fc_rport_enter_prli(struct fc_rport_priv *rdata)\r\n{\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct {\r\nstruct fc_els_prli prli;\r\nstruct fc_els_spp spp;\r\n} *pp;\r\nstruct fc_frame *fp;\r\nstruct fc4_prov *prov;\r\nif (rdata->ids.port_id >= FC_FID_DOM_MGR) {\r\nfc_rport_enter_ready(rdata);\r\nreturn;\r\n}\r\nFC_RPORT_DBG(rdata, "Port entered PRLI state from %s state\n",\r\nfc_rport_state(rdata));\r\nfc_rport_state_enter(rdata, RPORT_ST_PRLI);\r\nfp = fc_frame_alloc(lport, sizeof(*pp));\r\nif (!fp) {\r\nfc_rport_error_retry(rdata, fp);\r\nreturn;\r\n}\r\nfc_prli_fill(lport, fp);\r\nprov = fc_passive_prov[FC_TYPE_FCP];\r\nif (prov) {\r\npp = fc_frame_payload_get(fp, sizeof(*pp));\r\nprov->prli(rdata, sizeof(pp->spp), NULL, &pp->spp);\r\n}\r\nfc_fill_fc_hdr(fp, FC_RCTL_ELS_REQ, rdata->ids.port_id,\r\nfc_host_port_id(lport->host), FC_TYPE_ELS,\r\nFC_FC_FIRST_SEQ | FC_FC_END_SEQ | FC_FC_SEQ_INIT, 0);\r\nif (!lport->tt.exch_seq_send(lport, fp, fc_rport_prli_resp,\r\nNULL, rdata, 2 * lport->r_a_tov))\r\nfc_rport_error_retry(rdata, NULL);\r\nelse\r\nkref_get(&rdata->kref);\r\n}\r\nstatic void fc_rport_rtv_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *rdata_arg)\r\n{\r\nstruct fc_rport_priv *rdata = rdata_arg;\r\nu8 op;\r\nmutex_lock(&rdata->rp_mutex);\r\nFC_RPORT_DBG(rdata, "Received a RTV %s\n", fc_els_resp_type(fp));\r\nif (rdata->rp_state != RPORT_ST_RTV) {\r\nFC_RPORT_DBG(rdata, "Received a RTV response, but in state "\r\n"%s\n", fc_rport_state(rdata));\r\nif (IS_ERR(fp))\r\ngoto err;\r\ngoto out;\r\n}\r\nif (IS_ERR(fp)) {\r\nfc_rport_error(rdata, fp);\r\ngoto err;\r\n}\r\nop = fc_frame_payload_op(fp);\r\nif (op == ELS_LS_ACC) {\r\nstruct fc_els_rtv_acc *rtv;\r\nu32 toq;\r\nu32 tov;\r\nrtv = fc_frame_payload_get(fp, sizeof(*rtv));\r\nif (rtv) {\r\ntoq = ntohl(rtv->rtv_toq);\r\ntov = ntohl(rtv->rtv_r_a_tov);\r\nif (tov == 0)\r\ntov = 1;\r\nrdata->r_a_tov = tov;\r\ntov = ntohl(rtv->rtv_e_d_tov);\r\nif (toq & FC_ELS_RTV_EDRES)\r\ntov /= 1000000;\r\nif (tov == 0)\r\ntov = 1;\r\nrdata->e_d_tov = tov;\r\n}\r\n}\r\nfc_rport_enter_ready(rdata);\r\nout:\r\nfc_frame_free(fp);\r\nerr:\r\nmutex_unlock(&rdata->rp_mutex);\r\nkref_put(&rdata->kref, rdata->local_port->tt.rport_destroy);\r\n}\r\nstatic void fc_rport_enter_rtv(struct fc_rport_priv *rdata)\r\n{\r\nstruct fc_frame *fp;\r\nstruct fc_lport *lport = rdata->local_port;\r\nFC_RPORT_DBG(rdata, "Port entered RTV state from %s state\n",\r\nfc_rport_state(rdata));\r\nfc_rport_state_enter(rdata, RPORT_ST_RTV);\r\nfp = fc_frame_alloc(lport, sizeof(struct fc_els_rtv));\r\nif (!fp) {\r\nfc_rport_error_retry(rdata, fp);\r\nreturn;\r\n}\r\nif (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_RTV,\r\nfc_rport_rtv_resp, rdata,\r\n2 * lport->r_a_tov))\r\nfc_rport_error_retry(rdata, NULL);\r\nelse\r\nkref_get(&rdata->kref);\r\n}\r\nstatic void fc_rport_logo_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *lport_arg)\r\n{\r\nstruct fc_lport *lport = lport_arg;\r\nFC_RPORT_ID_DBG(lport, fc_seq_exch(sp)->did,\r\n"Received a LOGO %s\n", fc_els_resp_type(fp));\r\nif (IS_ERR(fp))\r\nreturn;\r\nfc_frame_free(fp);\r\n}\r\nstatic void fc_rport_enter_logo(struct fc_rport_priv *rdata)\r\n{\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct fc_frame *fp;\r\nFC_RPORT_DBG(rdata, "Port sending LOGO from %s state\n",\r\nfc_rport_state(rdata));\r\nfp = fc_frame_alloc(lport, sizeof(struct fc_els_logo));\r\nif (!fp)\r\nreturn;\r\n(void)lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_LOGO,\r\nfc_rport_logo_resp, lport, 0);\r\n}\r\nstatic void fc_rport_adisc_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *rdata_arg)\r\n{\r\nstruct fc_rport_priv *rdata = rdata_arg;\r\nstruct fc_els_adisc *adisc;\r\nu8 op;\r\nmutex_lock(&rdata->rp_mutex);\r\nFC_RPORT_DBG(rdata, "Received a ADISC response\n");\r\nif (rdata->rp_state != RPORT_ST_ADISC) {\r\nFC_RPORT_DBG(rdata, "Received a ADISC resp but in state %s\n",\r\nfc_rport_state(rdata));\r\nif (IS_ERR(fp))\r\ngoto err;\r\ngoto out;\r\n}\r\nif (IS_ERR(fp)) {\r\nfc_rport_error(rdata, fp);\r\ngoto err;\r\n}\r\nop = fc_frame_payload_op(fp);\r\nadisc = fc_frame_payload_get(fp, sizeof(*adisc));\r\nif (op != ELS_LS_ACC || !adisc ||\r\nntoh24(adisc->adisc_port_id) != rdata->ids.port_id ||\r\nget_unaligned_be64(&adisc->adisc_wwpn) != rdata->ids.port_name ||\r\nget_unaligned_be64(&adisc->adisc_wwnn) != rdata->ids.node_name) {\r\nFC_RPORT_DBG(rdata, "ADISC error or mismatch\n");\r\nfc_rport_enter_flogi(rdata);\r\n} else {\r\nFC_RPORT_DBG(rdata, "ADISC OK\n");\r\nfc_rport_enter_ready(rdata);\r\n}\r\nout:\r\nfc_frame_free(fp);\r\nerr:\r\nmutex_unlock(&rdata->rp_mutex);\r\nkref_put(&rdata->kref, rdata->local_port->tt.rport_destroy);\r\n}\r\nstatic void fc_rport_enter_adisc(struct fc_rport_priv *rdata)\r\n{\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct fc_frame *fp;\r\nFC_RPORT_DBG(rdata, "sending ADISC from %s state\n",\r\nfc_rport_state(rdata));\r\nfc_rport_state_enter(rdata, RPORT_ST_ADISC);\r\nfp = fc_frame_alloc(lport, sizeof(struct fc_els_adisc));\r\nif (!fp) {\r\nfc_rport_error_retry(rdata, fp);\r\nreturn;\r\n}\r\nif (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_ADISC,\r\nfc_rport_adisc_resp, rdata,\r\n2 * lport->r_a_tov))\r\nfc_rport_error_retry(rdata, NULL);\r\nelse\r\nkref_get(&rdata->kref);\r\n}\r\nstatic void fc_rport_recv_adisc_req(struct fc_rport_priv *rdata,\r\nstruct fc_frame *in_fp)\r\n{\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct fc_frame *fp;\r\nstruct fc_els_adisc *adisc;\r\nstruct fc_seq_els_data rjt_data;\r\nFC_RPORT_DBG(rdata, "Received ADISC request\n");\r\nadisc = fc_frame_payload_get(in_fp, sizeof(*adisc));\r\nif (!adisc) {\r\nrjt_data.reason = ELS_RJT_PROT;\r\nrjt_data.explan = ELS_EXPL_INV_LEN;\r\nlport->tt.seq_els_rsp_send(in_fp, ELS_LS_RJT, &rjt_data);\r\ngoto drop;\r\n}\r\nfp = fc_frame_alloc(lport, sizeof(*adisc));\r\nif (!fp)\r\ngoto drop;\r\nfc_adisc_fill(lport, fp);\r\nadisc = fc_frame_payload_get(fp, sizeof(*adisc));\r\nadisc->adisc_cmd = ELS_LS_ACC;\r\nfc_fill_reply_hdr(fp, in_fp, FC_RCTL_ELS_REP, 0);\r\nlport->tt.frame_send(lport, fp);\r\ndrop:\r\nfc_frame_free(in_fp);\r\n}\r\nstatic void fc_rport_recv_rls_req(struct fc_rport_priv *rdata,\r\nstruct fc_frame *rx_fp)\r\n{\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct fc_frame *fp;\r\nstruct fc_els_rls *rls;\r\nstruct fc_els_rls_resp *rsp;\r\nstruct fc_els_lesb *lesb;\r\nstruct fc_seq_els_data rjt_data;\r\nstruct fc_host_statistics *hst;\r\nFC_RPORT_DBG(rdata, "Received RLS request while in state %s\n",\r\nfc_rport_state(rdata));\r\nrls = fc_frame_payload_get(rx_fp, sizeof(*rls));\r\nif (!rls) {\r\nrjt_data.reason = ELS_RJT_PROT;\r\nrjt_data.explan = ELS_EXPL_INV_LEN;\r\ngoto out_rjt;\r\n}\r\nfp = fc_frame_alloc(lport, sizeof(*rsp));\r\nif (!fp) {\r\nrjt_data.reason = ELS_RJT_UNAB;\r\nrjt_data.explan = ELS_EXPL_INSUF_RES;\r\ngoto out_rjt;\r\n}\r\nrsp = fc_frame_payload_get(fp, sizeof(*rsp));\r\nmemset(rsp, 0, sizeof(*rsp));\r\nrsp->rls_cmd = ELS_LS_ACC;\r\nlesb = &rsp->rls_lesb;\r\nif (lport->tt.get_lesb) {\r\nlport->tt.get_lesb(lport, lesb);\r\n} else {\r\nfc_get_host_stats(lport->host);\r\nhst = &lport->host_stats;\r\nlesb->lesb_link_fail = htonl(hst->link_failure_count);\r\nlesb->lesb_sync_loss = htonl(hst->loss_of_sync_count);\r\nlesb->lesb_sig_loss = htonl(hst->loss_of_signal_count);\r\nlesb->lesb_prim_err = htonl(hst->prim_seq_protocol_err_count);\r\nlesb->lesb_inv_word = htonl(hst->invalid_tx_word_count);\r\nlesb->lesb_inv_crc = htonl(hst->invalid_crc_count);\r\n}\r\nfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\r\nlport->tt.frame_send(lport, fp);\r\ngoto out;\r\nout_rjt:\r\nlport->tt.seq_els_rsp_send(rx_fp, ELS_LS_RJT, &rjt_data);\r\nout:\r\nfc_frame_free(rx_fp);\r\n}\r\nstatic void fc_rport_recv_els_req(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nstruct fc_rport_priv *rdata;\r\nstruct fc_seq_els_data els_data;\r\nmutex_lock(&lport->disc.disc_mutex);\r\nrdata = lport->tt.rport_lookup(lport, fc_frame_sid(fp));\r\nif (!rdata) {\r\nmutex_unlock(&lport->disc.disc_mutex);\r\ngoto reject;\r\n}\r\nmutex_lock(&rdata->rp_mutex);\r\nmutex_unlock(&lport->disc.disc_mutex);\r\nswitch (rdata->rp_state) {\r\ncase RPORT_ST_PRLI:\r\ncase RPORT_ST_RTV:\r\ncase RPORT_ST_READY:\r\ncase RPORT_ST_ADISC:\r\nbreak;\r\ndefault:\r\nmutex_unlock(&rdata->rp_mutex);\r\ngoto reject;\r\n}\r\nswitch (fc_frame_payload_op(fp)) {\r\ncase ELS_PRLI:\r\nfc_rport_recv_prli_req(rdata, fp);\r\nbreak;\r\ncase ELS_PRLO:\r\nfc_rport_recv_prlo_req(rdata, fp);\r\nbreak;\r\ncase ELS_ADISC:\r\nfc_rport_recv_adisc_req(rdata, fp);\r\nbreak;\r\ncase ELS_RRQ:\r\nlport->tt.seq_els_rsp_send(fp, ELS_RRQ, NULL);\r\nfc_frame_free(fp);\r\nbreak;\r\ncase ELS_REC:\r\nlport->tt.seq_els_rsp_send(fp, ELS_REC, NULL);\r\nfc_frame_free(fp);\r\nbreak;\r\ncase ELS_RLS:\r\nfc_rport_recv_rls_req(rdata, fp);\r\nbreak;\r\ndefault:\r\nfc_frame_free(fp);\r\nbreak;\r\n}\r\nmutex_unlock(&rdata->rp_mutex);\r\nreturn;\r\nreject:\r\nels_data.reason = ELS_RJT_UNAB;\r\nels_data.explan = ELS_EXPL_PLOGI_REQD;\r\nlport->tt.seq_els_rsp_send(fp, ELS_LS_RJT, &els_data);\r\nfc_frame_free(fp);\r\n}\r\nstatic void fc_rport_recv_req(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nstruct fc_seq_els_data els_data;\r\nswitch (fc_frame_payload_op(fp)) {\r\ncase ELS_FLOGI:\r\nfc_rport_recv_flogi_req(lport, fp);\r\nbreak;\r\ncase ELS_PLOGI:\r\nfc_rport_recv_plogi_req(lport, fp);\r\nbreak;\r\ncase ELS_LOGO:\r\nfc_rport_recv_logo_req(lport, fp);\r\nbreak;\r\ncase ELS_PRLI:\r\ncase ELS_PRLO:\r\ncase ELS_ADISC:\r\ncase ELS_RRQ:\r\ncase ELS_REC:\r\ncase ELS_RLS:\r\nfc_rport_recv_els_req(lport, fp);\r\nbreak;\r\ndefault:\r\nels_data.reason = ELS_RJT_UNSUP;\r\nels_data.explan = ELS_EXPL_NONE;\r\nlport->tt.seq_els_rsp_send(fp, ELS_LS_RJT, &els_data);\r\nfc_frame_free(fp);\r\nbreak;\r\n}\r\n}\r\nstatic void fc_rport_recv_plogi_req(struct fc_lport *lport,\r\nstruct fc_frame *rx_fp)\r\n{\r\nstruct fc_disc *disc;\r\nstruct fc_rport_priv *rdata;\r\nstruct fc_frame *fp = rx_fp;\r\nstruct fc_els_flogi *pl;\r\nstruct fc_seq_els_data rjt_data;\r\nu32 sid;\r\nsid = fc_frame_sid(fp);\r\nFC_RPORT_ID_DBG(lport, sid, "Received PLOGI request\n");\r\npl = fc_frame_payload_get(fp, sizeof(*pl));\r\nif (!pl) {\r\nFC_RPORT_ID_DBG(lport, sid, "Received PLOGI too short\n");\r\nrjt_data.reason = ELS_RJT_PROT;\r\nrjt_data.explan = ELS_EXPL_INV_LEN;\r\ngoto reject;\r\n}\r\ndisc = &lport->disc;\r\nmutex_lock(&disc->disc_mutex);\r\nrdata = lport->tt.rport_create(lport, sid);\r\nif (!rdata) {\r\nmutex_unlock(&disc->disc_mutex);\r\nrjt_data.reason = ELS_RJT_UNAB;\r\nrjt_data.explan = ELS_EXPL_INSUF_RES;\r\ngoto reject;\r\n}\r\nmutex_lock(&rdata->rp_mutex);\r\nmutex_unlock(&disc->disc_mutex);\r\nrdata->ids.port_name = get_unaligned_be64(&pl->fl_wwpn);\r\nrdata->ids.node_name = get_unaligned_be64(&pl->fl_wwnn);\r\nswitch (rdata->rp_state) {\r\ncase RPORT_ST_INIT:\r\nFC_RPORT_DBG(rdata, "Received PLOGI in INIT state\n");\r\nbreak;\r\ncase RPORT_ST_PLOGI_WAIT:\r\nFC_RPORT_DBG(rdata, "Received PLOGI in PLOGI_WAIT state\n");\r\nbreak;\r\ncase RPORT_ST_PLOGI:\r\nFC_RPORT_DBG(rdata, "Received PLOGI in PLOGI state\n");\r\nif (rdata->ids.port_name < lport->wwpn) {\r\nmutex_unlock(&rdata->rp_mutex);\r\nrjt_data.reason = ELS_RJT_INPROG;\r\nrjt_data.explan = ELS_EXPL_NONE;\r\ngoto reject;\r\n}\r\nbreak;\r\ncase RPORT_ST_PRLI:\r\ncase RPORT_ST_RTV:\r\ncase RPORT_ST_READY:\r\ncase RPORT_ST_ADISC:\r\nFC_RPORT_DBG(rdata, "Received PLOGI in logged-in state %d "\r\n"- ignored for now\n", rdata->rp_state);\r\nbreak;\r\ncase RPORT_ST_FLOGI:\r\ncase RPORT_ST_DELETE:\r\nFC_RPORT_DBG(rdata, "Received PLOGI in state %s - send busy\n",\r\nfc_rport_state(rdata));\r\nmutex_unlock(&rdata->rp_mutex);\r\nrjt_data.reason = ELS_RJT_BUSY;\r\nrjt_data.explan = ELS_EXPL_NONE;\r\ngoto reject;\r\n}\r\nif (!fc_rport_compatible_roles(lport, rdata)) {\r\nFC_RPORT_DBG(rdata, "Received PLOGI for incompatible role\n");\r\nmutex_unlock(&rdata->rp_mutex);\r\nrjt_data.reason = ELS_RJT_LOGIC;\r\nrjt_data.explan = ELS_EXPL_NONE;\r\ngoto reject;\r\n}\r\nrdata->maxframe_size = fc_plogi_get_maxframe(pl, lport->mfs);\r\nfp = fc_frame_alloc(lport, sizeof(*pl));\r\nif (!fp)\r\ngoto out;\r\nfc_plogi_fill(lport, fp, ELS_LS_ACC);\r\nfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\r\nlport->tt.frame_send(lport, fp);\r\nfc_rport_enter_prli(rdata);\r\nout:\r\nmutex_unlock(&rdata->rp_mutex);\r\nfc_frame_free(rx_fp);\r\nreturn;\r\nreject:\r\nlport->tt.seq_els_rsp_send(fp, ELS_LS_RJT, &rjt_data);\r\nfc_frame_free(fp);\r\n}\r\nstatic void fc_rport_recv_prli_req(struct fc_rport_priv *rdata,\r\nstruct fc_frame *rx_fp)\r\n{\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct fc_frame *fp;\r\nstruct {\r\nstruct fc_els_prli prli;\r\nstruct fc_els_spp spp;\r\n} *pp;\r\nstruct fc_els_spp *rspp;\r\nstruct fc_els_spp *spp;\r\nunsigned int len;\r\nunsigned int plen;\r\nenum fc_els_spp_resp resp;\r\nenum fc_els_spp_resp passive;\r\nstruct fc_seq_els_data rjt_data;\r\nstruct fc4_prov *prov;\r\nFC_RPORT_DBG(rdata, "Received PRLI request while in state %s\n",\r\nfc_rport_state(rdata));\r\nlen = fr_len(rx_fp) - sizeof(struct fc_frame_header);\r\npp = fc_frame_payload_get(rx_fp, sizeof(*pp));\r\nif (!pp)\r\ngoto reject_len;\r\nplen = ntohs(pp->prli.prli_len);\r\nif ((plen % 4) != 0 || plen > len || plen < 16)\r\ngoto reject_len;\r\nif (plen < len)\r\nlen = plen;\r\nplen = pp->prli.prli_spp_len;\r\nif ((plen % 4) != 0 || plen < sizeof(*spp) ||\r\nplen > len || len < sizeof(*pp) || plen < 12)\r\ngoto reject_len;\r\nrspp = &pp->spp;\r\nfp = fc_frame_alloc(lport, len);\r\nif (!fp) {\r\nrjt_data.reason = ELS_RJT_UNAB;\r\nrjt_data.explan = ELS_EXPL_INSUF_RES;\r\ngoto reject;\r\n}\r\npp = fc_frame_payload_get(fp, len);\r\nWARN_ON(!pp);\r\nmemset(pp, 0, len);\r\npp->prli.prli_cmd = ELS_LS_ACC;\r\npp->prli.prli_spp_len = plen;\r\npp->prli.prli_len = htons(len);\r\nlen -= sizeof(struct fc_els_prli);\r\nspp = &pp->spp;\r\nmutex_lock(&fc_prov_mutex);\r\nwhile (len >= plen) {\r\nrdata->spp_type = rspp->spp_type;\r\nspp->spp_type = rspp->spp_type;\r\nspp->spp_type_ext = rspp->spp_type_ext;\r\nresp = 0;\r\nif (rspp->spp_type < FC_FC4_PROV_SIZE) {\r\nprov = fc_active_prov[rspp->spp_type];\r\nif (prov)\r\nresp = prov->prli(rdata, plen, rspp, spp);\r\nprov = fc_passive_prov[rspp->spp_type];\r\nif (prov) {\r\npassive = prov->prli(rdata, plen, rspp, spp);\r\nif (!resp || passive == FC_SPP_RESP_ACK)\r\nresp = passive;\r\n}\r\n}\r\nif (!resp) {\r\nif (spp->spp_flags & FC_SPP_EST_IMG_PAIR)\r\nresp |= FC_SPP_RESP_CONF;\r\nelse\r\nresp |= FC_SPP_RESP_INVL;\r\n}\r\nspp->spp_flags |= resp;\r\nlen -= plen;\r\nrspp = (struct fc_els_spp *)((char *)rspp + plen);\r\nspp = (struct fc_els_spp *)((char *)spp + plen);\r\n}\r\nmutex_unlock(&fc_prov_mutex);\r\nfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\r\nlport->tt.frame_send(lport, fp);\r\nswitch (rdata->rp_state) {\r\ncase RPORT_ST_PRLI:\r\nfc_rport_enter_ready(rdata);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ngoto drop;\r\nreject_len:\r\nrjt_data.reason = ELS_RJT_PROT;\r\nrjt_data.explan = ELS_EXPL_INV_LEN;\r\nreject:\r\nlport->tt.seq_els_rsp_send(rx_fp, ELS_LS_RJT, &rjt_data);\r\ndrop:\r\nfc_frame_free(rx_fp);\r\n}\r\nstatic void fc_rport_recv_prlo_req(struct fc_rport_priv *rdata,\r\nstruct fc_frame *rx_fp)\r\n{\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct fc_frame *fp;\r\nstruct {\r\nstruct fc_els_prlo prlo;\r\nstruct fc_els_spp spp;\r\n} *pp;\r\nstruct fc_els_spp *rspp;\r\nstruct fc_els_spp *spp;\r\nunsigned int len;\r\nunsigned int plen;\r\nstruct fc_seq_els_data rjt_data;\r\nFC_RPORT_DBG(rdata, "Received PRLO request while in state %s\n",\r\nfc_rport_state(rdata));\r\nlen = fr_len(rx_fp) - sizeof(struct fc_frame_header);\r\npp = fc_frame_payload_get(rx_fp, sizeof(*pp));\r\nif (!pp)\r\ngoto reject_len;\r\nplen = ntohs(pp->prlo.prlo_len);\r\nif (plen != 20)\r\ngoto reject_len;\r\nif (plen < len)\r\nlen = plen;\r\nrspp = &pp->spp;\r\nfp = fc_frame_alloc(lport, len);\r\nif (!fp) {\r\nrjt_data.reason = ELS_RJT_UNAB;\r\nrjt_data.explan = ELS_EXPL_INSUF_RES;\r\ngoto reject;\r\n}\r\npp = fc_frame_payload_get(fp, len);\r\nWARN_ON(!pp);\r\nmemset(pp, 0, len);\r\npp->prlo.prlo_cmd = ELS_LS_ACC;\r\npp->prlo.prlo_obs = 0x10;\r\npp->prlo.prlo_len = htons(len);\r\nspp = &pp->spp;\r\nspp->spp_type = rspp->spp_type;\r\nspp->spp_type_ext = rspp->spp_type_ext;\r\nspp->spp_flags = FC_SPP_RESP_ACK;\r\nfc_rport_enter_delete(rdata, RPORT_EV_LOGO);\r\nfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\r\nlport->tt.frame_send(lport, fp);\r\ngoto drop;\r\nreject_len:\r\nrjt_data.reason = ELS_RJT_PROT;\r\nrjt_data.explan = ELS_EXPL_INV_LEN;\r\nreject:\r\nlport->tt.seq_els_rsp_send(rx_fp, ELS_LS_RJT, &rjt_data);\r\ndrop:\r\nfc_frame_free(rx_fp);\r\n}\r\nstatic void fc_rport_recv_logo_req(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nstruct fc_rport_priv *rdata;\r\nu32 sid;\r\nlport->tt.seq_els_rsp_send(fp, ELS_LS_ACC, NULL);\r\nsid = fc_frame_sid(fp);\r\nmutex_lock(&lport->disc.disc_mutex);\r\nrdata = lport->tt.rport_lookup(lport, sid);\r\nif (rdata) {\r\nmutex_lock(&rdata->rp_mutex);\r\nFC_RPORT_DBG(rdata, "Received LOGO request while in state %s\n",\r\nfc_rport_state(rdata));\r\nfc_rport_enter_delete(rdata, RPORT_EV_LOGO);\r\nmutex_unlock(&rdata->rp_mutex);\r\n} else\r\nFC_RPORT_ID_DBG(lport, sid,\r\n"Received LOGO from non-logged-in port\n");\r\nmutex_unlock(&lport->disc.disc_mutex);\r\nfc_frame_free(fp);\r\n}\r\nstatic void fc_rport_flush_queue(void)\r\n{\r\nflush_workqueue(rport_event_queue);\r\n}\r\nint fc_rport_init(struct fc_lport *lport)\r\n{\r\nif (!lport->tt.rport_lookup)\r\nlport->tt.rport_lookup = fc_rport_lookup;\r\nif (!lport->tt.rport_create)\r\nlport->tt.rport_create = fc_rport_create;\r\nif (!lport->tt.rport_login)\r\nlport->tt.rport_login = fc_rport_login;\r\nif (!lport->tt.rport_logoff)\r\nlport->tt.rport_logoff = fc_rport_logoff;\r\nif (!lport->tt.rport_recv_req)\r\nlport->tt.rport_recv_req = fc_rport_recv_req;\r\nif (!lport->tt.rport_flush_queue)\r\nlport->tt.rport_flush_queue = fc_rport_flush_queue;\r\nif (!lport->tt.rport_destroy)\r\nlport->tt.rport_destroy = fc_rport_destroy;\r\nreturn 0;\r\n}\r\nstatic int fc_rport_fcp_prli(struct fc_rport_priv *rdata, u32 spp_len,\r\nconst struct fc_els_spp *rspp,\r\nstruct fc_els_spp *spp)\r\n{\r\nstruct fc_lport *lport = rdata->local_port;\r\nu32 fcp_parm;\r\nfcp_parm = ntohl(rspp->spp_params);\r\nrdata->ids.roles = FC_RPORT_ROLE_UNKNOWN;\r\nif (fcp_parm & FCP_SPPF_INIT_FCN)\r\nrdata->ids.roles |= FC_RPORT_ROLE_FCP_INITIATOR;\r\nif (fcp_parm & FCP_SPPF_TARG_FCN)\r\nrdata->ids.roles |= FC_RPORT_ROLE_FCP_TARGET;\r\nif (fcp_parm & FCP_SPPF_RETRY)\r\nrdata->flags |= FC_RP_FLAGS_RETRY;\r\nrdata->supported_classes = FC_COS_CLASS3;\r\nif (!(lport->service_params & FCP_SPPF_INIT_FCN))\r\nreturn 0;\r\nspp->spp_flags |= rspp->spp_flags & FC_SPP_EST_IMG_PAIR;\r\nfcp_parm = ntohl(spp->spp_params);\r\nspp->spp_params = htonl(fcp_parm | lport->service_params);\r\nreturn FC_SPP_RESP_ACK;\r\n}\r\nstatic int fc_rport_t0_prli(struct fc_rport_priv *rdata, u32 spp_len,\r\nconst struct fc_els_spp *rspp,\r\nstruct fc_els_spp *spp)\r\n{\r\nif (rspp->spp_flags & FC_SPP_EST_IMG_PAIR)\r\nreturn FC_SPP_RESP_INVL;\r\nreturn FC_SPP_RESP_ACK;\r\n}\r\nint fc_setup_rport(void)\r\n{\r\nrport_event_queue = create_singlethread_workqueue("fc_rport_eq");\r\nif (!rport_event_queue)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid fc_destroy_rport(void)\r\n{\r\ndestroy_workqueue(rport_event_queue);\r\n}\r\nvoid fc_rport_terminate_io(struct fc_rport *rport)\r\n{\r\nstruct fc_rport_libfc_priv *rpriv = rport->dd_data;\r\nstruct fc_lport *lport = rpriv->local_port;\r\nlport->tt.exch_mgr_reset(lport, 0, rport->port_id);\r\nlport->tt.exch_mgr_reset(lport, rport->port_id, 0);\r\n}
