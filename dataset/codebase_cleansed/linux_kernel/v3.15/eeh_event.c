static int eeh_event_handler(void * dummy)\r\n{\r\nunsigned long flags;\r\nstruct eeh_event *event;\r\nstruct eeh_pe *pe;\r\nwhile (!kthread_should_stop()) {\r\nif (down_interruptible(&eeh_eventlist_sem))\r\nbreak;\r\nspin_lock_irqsave(&eeh_eventlist_lock, flags);\r\nevent = NULL;\r\nif (!list_empty(&eeh_eventlist)) {\r\nevent = list_entry(eeh_eventlist.next,\r\nstruct eeh_event, list);\r\nlist_del(&event->list);\r\n}\r\nspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\r\nif (!event)\r\ncontinue;\r\npe = event->pe;\r\nif (pe) {\r\neeh_pe_state_mark(pe, EEH_PE_RECOVERING);\r\nif (pe->type & EEH_PE_PHB)\r\npr_info("EEH: Detected error on PHB#%d\n",\r\npe->phb->global_number);\r\nelse\r\npr_info("EEH: Detected PCI bus error on "\r\n"PHB#%d-PE#%x\n",\r\npe->phb->global_number, pe->addr);\r\neeh_handle_event(pe);\r\neeh_pe_state_clear(pe, EEH_PE_RECOVERING);\r\n} else {\r\neeh_handle_event(NULL);\r\n}\r\nkfree(event);\r\n}\r\nreturn 0;\r\n}\r\nint eeh_event_init(void)\r\n{\r\nstruct task_struct *t;\r\nint ret = 0;\r\nsema_init(&eeh_eventlist_sem, 0);\r\nt = kthread_run(eeh_event_handler, NULL, "eehd");\r\nif (IS_ERR(t)) {\r\nret = PTR_ERR(t);\r\npr_err("%s: Failed to start EEH daemon (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint eeh_send_failure_event(struct eeh_pe *pe)\r\n{\r\nunsigned long flags;\r\nstruct eeh_event *event;\r\nevent = kzalloc(sizeof(*event), GFP_ATOMIC);\r\nif (!event) {\r\npr_err("EEH: out of memory, event not handled\n");\r\nreturn -ENOMEM;\r\n}\r\nevent->pe = pe;\r\nspin_lock_irqsave(&eeh_eventlist_lock, flags);\r\nlist_add(&event->list, &eeh_eventlist);\r\nspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\r\nup(&eeh_eventlist_sem);\r\nreturn 0;\r\n}\r\nvoid eeh_remove_event(struct eeh_pe *pe)\r\n{\r\nunsigned long flags;\r\nstruct eeh_event *event, *tmp;\r\nspin_lock_irqsave(&eeh_eventlist_lock, flags);\r\nlist_for_each_entry_safe(event, tmp, &eeh_eventlist, list) {\r\nif (!pe) {\r\nlist_del(&event->list);\r\nkfree(event);\r\n} else if (pe->type & EEH_PE_PHB) {\r\nif (event->pe && event->pe->phb == pe->phb) {\r\nlist_del(&event->list);\r\nkfree(event);\r\n}\r\n} else if (event->pe == pe) {\r\nlist_del(&event->list);\r\nkfree(event);\r\n}\r\n}\r\nspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\r\n}
