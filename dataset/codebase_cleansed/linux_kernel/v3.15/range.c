int add_range(struct range *range, int az, int nr_range, u64 start, u64 end)\r\n{\r\nif (start >= end)\r\nreturn nr_range;\r\nif (nr_range >= az)\r\nreturn nr_range;\r\nrange[nr_range].start = start;\r\nrange[nr_range].end = end;\r\nnr_range++;\r\nreturn nr_range;\r\n}\r\nint add_range_with_merge(struct range *range, int az, int nr_range,\r\nu64 start, u64 end)\r\n{\r\nint i;\r\nif (start >= end)\r\nreturn nr_range;\r\nfor (i = 0; i < nr_range; i++) {\r\nu64 common_start, common_end;\r\nif (!range[i].end)\r\ncontinue;\r\ncommon_start = max(range[i].start, start);\r\ncommon_end = min(range[i].end, end);\r\nif (common_start > common_end)\r\ncontinue;\r\nstart = min(range[i].start, start);\r\nend = max(range[i].end, end);\r\nmemmove(&range[i], &range[i + 1],\r\n(nr_range - (i + 1)) * sizeof(range[i]));\r\nrange[nr_range - 1].start = 0;\r\nrange[nr_range - 1].end = 0;\r\nnr_range--;\r\ni--;\r\n}\r\nreturn add_range(range, az, nr_range, start, end);\r\n}\r\nvoid subtract_range(struct range *range, int az, u64 start, u64 end)\r\n{\r\nint i, j;\r\nif (start >= end)\r\nreturn;\r\nfor (j = 0; j < az; j++) {\r\nif (!range[j].end)\r\ncontinue;\r\nif (start <= range[j].start && end >= range[j].end) {\r\nrange[j].start = 0;\r\nrange[j].end = 0;\r\ncontinue;\r\n}\r\nif (start <= range[j].start && end < range[j].end &&\r\nrange[j].start < end) {\r\nrange[j].start = end;\r\ncontinue;\r\n}\r\nif (start > range[j].start && end >= range[j].end &&\r\nrange[j].end > start) {\r\nrange[j].end = start;\r\ncontinue;\r\n}\r\nif (start > range[j].start && end < range[j].end) {\r\nfor (i = 0; i < az; i++) {\r\nif (range[i].end == 0)\r\nbreak;\r\n}\r\nif (i < az) {\r\nrange[i].end = range[j].end;\r\nrange[i].start = end;\r\n} else {\r\npr_err("%s: run out of slot in ranges\n",\r\n__func__);\r\n}\r\nrange[j].end = start;\r\ncontinue;\r\n}\r\n}\r\n}\r\nstatic int cmp_range(const void *x1, const void *x2)\r\n{\r\nconst struct range *r1 = x1;\r\nconst struct range *r2 = x2;\r\ns64 start1, start2;\r\nstart1 = r1->start;\r\nstart2 = r2->start;\r\nreturn start1 - start2;\r\n}\r\nint clean_sort_range(struct range *range, int az)\r\n{\r\nint i, j, k = az - 1, nr_range = az;\r\nfor (i = 0; i < k; i++) {\r\nif (range[i].end)\r\ncontinue;\r\nfor (j = k; j > i; j--) {\r\nif (range[j].end) {\r\nk = j;\r\nbreak;\r\n}\r\n}\r\nif (j == i)\r\nbreak;\r\nrange[i].start = range[k].start;\r\nrange[i].end = range[k].end;\r\nrange[k].start = 0;\r\nrange[k].end = 0;\r\nk--;\r\n}\r\nfor (i = 0; i < az; i++) {\r\nif (!range[i].end) {\r\nnr_range = i;\r\nbreak;\r\n}\r\n}\r\nsort(range, nr_range, sizeof(struct range), cmp_range, NULL);\r\nreturn nr_range;\r\n}\r\nvoid sort_range(struct range *range, int nr_range)\r\n{\r\nsort(range, nr_range, sizeof(struct range), cmp_range, NULL);\r\n}
