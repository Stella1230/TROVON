inline void irlmp_send_data_pdu(struct lap_cb *self, __u8 dlsap, __u8 slsap,\r\nint expedited, struct sk_buff *skb)\r\n{\r\nskb->data[0] = dlsap;\r\nskb->data[1] = slsap;\r\nif (expedited) {\r\nIRDA_DEBUG(4, "%s(), sending expedited data\n", __func__);\r\nirlap_data_request(self->irlap, skb, TRUE);\r\n} else\r\nirlap_data_request(self->irlap, skb, FALSE);\r\n}\r\nvoid irlmp_send_lcf_pdu(struct lap_cb *self, __u8 dlsap, __u8 slsap,\r\n__u8 opcode, struct sk_buff *skb)\r\n{\r\n__u8 *frame;\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LAP_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nframe = skb->data;\r\nframe[0] = dlsap | CONTROL_BIT;\r\nframe[1] = slsap;\r\nframe[2] = opcode;\r\nif (opcode == DISCONNECT)\r\nframe[3] = 0x01;\r\nelse\r\nframe[3] = 0x00;\r\nirlap_data_request(self->irlap, skb, FALSE);\r\n}\r\nvoid irlmp_link_data_indication(struct lap_cb *self, struct sk_buff *skb,\r\nint unreliable)\r\n{\r\nstruct lsap_cb *lsap;\r\n__u8 slsap_sel;\r\n__u8 dlsap_sel;\r\n__u8 *fp;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LAP_MAGIC, return;);\r\nIRDA_ASSERT(skb->len > 2, return;);\r\nfp = skb->data;\r\nslsap_sel = fp[0] & LSAP_MASK;\r\ndlsap_sel = fp[1];\r\nif ((fp[0] & CONTROL_BIT) && (fp[2] == CONNECT_CMD)) {\r\nIRDA_DEBUG(3, "%s(), incoming connection, "\r\n"source LSAP=%d, dest LSAP=%d\n",\r\n__func__, slsap_sel, dlsap_sel);\r\nlsap = irlmp_find_lsap(self, dlsap_sel, slsap_sel, CONNECT_CMD,\r\nirlmp->unconnected_lsaps);\r\nif (!lsap) {\r\nIRDA_DEBUG(1, "%s(), incoming connection for LSAP already connected\n", __func__);\r\nlsap = irlmp_find_lsap(self, dlsap_sel, slsap_sel, 0,\r\nself->lsaps);\r\n}\r\n} else\r\nlsap = irlmp_find_lsap(self, dlsap_sel, slsap_sel, 0,\r\nself->lsaps);\r\nif (lsap == NULL) {\r\nIRDA_DEBUG(2, "IrLMP, Sorry, no LSAP for received frame!\n");\r\nIRDA_DEBUG(2, "%s(), slsap_sel = %02x, dlsap_sel = %02x\n",\r\n__func__, slsap_sel, dlsap_sel);\r\nif (fp[0] & CONTROL_BIT) {\r\nIRDA_DEBUG(2, "%s(), received control frame %02x\n",\r\n__func__, fp[2]);\r\n} else {\r\nIRDA_DEBUG(2, "%s(), received data frame\n", __func__);\r\n}\r\nreturn;\r\n}\r\nif (fp[0] & CONTROL_BIT) {\r\nswitch (fp[2]) {\r\ncase CONNECT_CMD:\r\nlsap->lap = self;\r\nirlmp_do_lsap_event(lsap, LM_CONNECT_INDICATION, skb);\r\nbreak;\r\ncase CONNECT_CNF:\r\nirlmp_do_lsap_event(lsap, LM_CONNECT_CONFIRM, skb);\r\nbreak;\r\ncase DISCONNECT:\r\nIRDA_DEBUG(4, "%s(), Disconnect indication!\n",\r\n__func__);\r\nirlmp_do_lsap_event(lsap, LM_DISCONNECT_INDICATION,\r\nskb);\r\nbreak;\r\ncase ACCESSMODE_CMD:\r\nIRDA_DEBUG(0, "Access mode cmd not implemented!\n");\r\nbreak;\r\ncase ACCESSMODE_CNF:\r\nIRDA_DEBUG(0, "Access mode cnf not implemented!\n");\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), Unknown control frame %02x\n",\r\n__func__, fp[2]);\r\nbreak;\r\n}\r\n} else if (unreliable) {\r\nif (lsap->lsap_state == LSAP_DATA_TRANSFER_READY)\r\nirlmp_udata_indication(lsap, skb);\r\nelse\r\nirlmp_do_lsap_event(lsap, LM_UDATA_INDICATION, skb);\r\n} else {\r\nif (lsap->lsap_state == LSAP_DATA_TRANSFER_READY)\r\nirlmp_data_indication(lsap, skb);\r\nelse\r\nirlmp_do_lsap_event(lsap, LM_DATA_INDICATION, skb);\r\n}\r\n}\r\nvoid irlmp_link_unitdata_indication(struct lap_cb *self, struct sk_buff *skb)\r\n{\r\nstruct lsap_cb *lsap;\r\n__u8 slsap_sel;\r\n__u8 dlsap_sel;\r\n__u8 pid;\r\n__u8 *fp;\r\nunsigned long flags;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LAP_MAGIC, return;);\r\nIRDA_ASSERT(skb->len > 2, return;);\r\nfp = skb->data;\r\nslsap_sel = fp[0] & LSAP_MASK;\r\ndlsap_sel = fp[1];\r\npid = fp[2];\r\nif (pid & 0x80) {\r\nIRDA_DEBUG(0, "%s(), extension in PID not supp!\n",\r\n__func__);\r\nreturn;\r\n}\r\nif ((slsap_sel != LSAP_CONNLESS) || (dlsap_sel != LSAP_CONNLESS)) {\r\nIRDA_DEBUG(0, "%s(), dropping frame!\n", __func__);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&irlmp->unconnected_lsaps->hb_spinlock, flags);\r\nlsap = (struct lsap_cb *) hashbin_get_first(irlmp->unconnected_lsaps);\r\nwhile (lsap != NULL) {\r\nif ((lsap->slsap_sel == slsap_sel) &&\r\n(lsap->dlsap_sel == dlsap_sel) &&\r\n(lsap->pid == pid))\r\n{\r\nbreak;\r\n}\r\nlsap = (struct lsap_cb *) hashbin_get_next(irlmp->unconnected_lsaps);\r\n}\r\nspin_unlock_irqrestore(&irlmp->unconnected_lsaps->hb_spinlock, flags);\r\nif (lsap)\r\nirlmp_connless_data_indication(lsap, skb);\r\nelse {\r\nIRDA_DEBUG(0, "%s(), found no matching LSAP!\n", __func__);\r\n}\r\n}\r\nvoid irlmp_link_disconnect_indication(struct lap_cb *lap,\r\nstruct irlap_cb *irlap,\r\nLAP_REASON reason,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nIRDA_ASSERT(lap != NULL, return;);\r\nIRDA_ASSERT(lap->magic == LMP_LAP_MAGIC, return;);\r\nlap->reason = reason;\r\nlap->daddr = DEV_ADDR_ANY;\r\nirlmp_do_lap_event(lap, LM_LAP_DISCONNECT_INDICATION, NULL);\r\n}\r\nvoid irlmp_link_connect_indication(struct lap_cb *self, __u32 saddr,\r\n__u32 daddr, struct qos_info *qos,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nself->qos = qos;\r\nself->daddr = daddr;\r\nIRDA_ASSERT(self->saddr == saddr, return;);\r\nirlmp_do_lap_event(self, LM_LAP_CONNECT_INDICATION, skb);\r\n}\r\nvoid irlmp_link_connect_confirm(struct lap_cb *self, struct qos_info *qos,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LAP_MAGIC, return;);\r\nIRDA_ASSERT(qos != NULL, return;);\r\nself->qos = qos;\r\nirlmp_do_lap_event(self, LM_LAP_CONNECT_CONFIRM, NULL);\r\n}\r\nvoid irlmp_link_discovery_indication(struct lap_cb *self,\r\ndiscovery_t *discovery)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LAP_MAGIC, return;);\r\nirlmp_add_discovery(irlmp->cachelog, discovery);\r\nirlmp_discovery_confirm(irlmp->cachelog, DISCOVERY_PASSIVE);\r\n}\r\nvoid irlmp_link_discovery_confirm(struct lap_cb *self, hashbin_t *log)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LAP_MAGIC, return;);\r\nirlmp_add_discovery_log(irlmp->cachelog, log);\r\nirlmp_discovery_confirm(irlmp->cachelog, DISCOVERY_ACTIVE);\r\n}\r\nstatic inline void irlmp_update_cache(struct lap_cb *lap,\r\nstruct lsap_cb *lsap)\r\n{\r\nlap->cache.valid = FALSE;\r\nlap->cache.dlsap_sel = lsap->dlsap_sel;\r\nlap->cache.slsap_sel = lsap->slsap_sel;\r\nlap->cache.lsap = lsap;\r\nlap->cache.valid = TRUE;\r\n}\r\nstatic struct lsap_cb *irlmp_find_lsap(struct lap_cb *self, __u8 dlsap_sel,\r\n__u8 slsap_sel, int status,\r\nhashbin_t *queue)\r\n{\r\nstruct lsap_cb *lsap;\r\nunsigned long flags;\r\n#ifdef CONFIG_IRDA_CACHE_LAST_LSAP\r\nif ((self->cache.valid) &&\r\n(self->cache.slsap_sel == slsap_sel) &&\r\n(self->cache.dlsap_sel == dlsap_sel))\r\n{\r\nreturn self->cache.lsap;\r\n}\r\n#endif\r\nspin_lock_irqsave(&queue->hb_spinlock, flags);\r\nlsap = (struct lsap_cb *) hashbin_get_first(queue);\r\nwhile (lsap != NULL) {\r\nif ((status == CONNECT_CMD) &&\r\n(lsap->slsap_sel == slsap_sel) &&\r\n(lsap->dlsap_sel == LSAP_ANY)) {\r\nlsap->dlsap_sel = dlsap_sel;\r\nbreak;\r\n}\r\nif ((lsap->slsap_sel == slsap_sel) &&\r\n(lsap->dlsap_sel == dlsap_sel))\r\nbreak;\r\nlsap = (struct lsap_cb *) hashbin_get_next(queue);\r\n}\r\n#ifdef CONFIG_IRDA_CACHE_LAST_LSAP\r\nif(lsap)\r\nirlmp_update_cache(self, lsap);\r\n#endif\r\nspin_unlock_irqrestore(&queue->hb_spinlock, flags);\r\nreturn lsap;\r\n}
