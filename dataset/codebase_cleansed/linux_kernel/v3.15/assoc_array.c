static int assoc_array_subtree_iterate(const struct assoc_array_ptr *root,\r\nconst struct assoc_array_ptr *stop,\r\nint (*iterator)(const void *leaf,\r\nvoid *iterator_data),\r\nvoid *iterator_data)\r\n{\r\nconst struct assoc_array_shortcut *shortcut;\r\nconst struct assoc_array_node *node;\r\nconst struct assoc_array_ptr *cursor, *ptr, *parent;\r\nunsigned long has_meta;\r\nint slot, ret;\r\ncursor = root;\r\nbegin_node:\r\nif (assoc_array_ptr_is_shortcut(cursor)) {\r\nshortcut = assoc_array_ptr_to_shortcut(cursor);\r\nsmp_read_barrier_depends();\r\ncursor = ACCESS_ONCE(shortcut->next_node);\r\n}\r\nnode = assoc_array_ptr_to_node(cursor);\r\nsmp_read_barrier_depends();\r\nslot = 0;\r\nhas_meta = 0;\r\nfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\r\nptr = ACCESS_ONCE(node->slots[slot]);\r\nhas_meta |= (unsigned long)ptr;\r\nif (ptr && assoc_array_ptr_is_leaf(ptr)) {\r\nsmp_read_barrier_depends();\r\nret = iterator(assoc_array_ptr_to_leaf(ptr),\r\niterator_data);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nif (!(has_meta & ASSOC_ARRAY_PTR_META_TYPE))\r\ngoto finished_node;\r\nslot = 0;\r\ncontinue_node:\r\nnode = assoc_array_ptr_to_node(cursor);\r\nsmp_read_barrier_depends();\r\nfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\r\nptr = ACCESS_ONCE(node->slots[slot]);\r\nif (assoc_array_ptr_is_meta(ptr)) {\r\ncursor = ptr;\r\ngoto begin_node;\r\n}\r\n}\r\nfinished_node:\r\nparent = ACCESS_ONCE(node->back_pointer);\r\nslot = node->parent_slot;\r\nif (parent == stop)\r\nreturn 0;\r\nif (assoc_array_ptr_is_shortcut(parent)) {\r\nshortcut = assoc_array_ptr_to_shortcut(parent);\r\nsmp_read_barrier_depends();\r\ncursor = parent;\r\nparent = ACCESS_ONCE(shortcut->back_pointer);\r\nslot = shortcut->parent_slot;\r\nif (parent == stop)\r\nreturn 0;\r\n}\r\ncursor = parent;\r\nslot++;\r\ngoto continue_node;\r\n}\r\nint assoc_array_iterate(const struct assoc_array *array,\r\nint (*iterator)(const void *object,\r\nvoid *iterator_data),\r\nvoid *iterator_data)\r\n{\r\nstruct assoc_array_ptr *root = ACCESS_ONCE(array->root);\r\nif (!root)\r\nreturn 0;\r\nreturn assoc_array_subtree_iterate(root, NULL, iterator, iterator_data);\r\n}\r\nstatic enum assoc_array_walk_status\r\nassoc_array_walk(const struct assoc_array *array,\r\nconst struct assoc_array_ops *ops,\r\nconst void *index_key,\r\nstruct assoc_array_walk_result *result)\r\n{\r\nstruct assoc_array_shortcut *shortcut;\r\nstruct assoc_array_node *node;\r\nstruct assoc_array_ptr *cursor, *ptr;\r\nunsigned long sc_segments, dissimilarity;\r\nunsigned long segments;\r\nint level, sc_level, next_sc_level;\r\nint slot;\r\npr_devel("-->%s()\n", __func__);\r\ncursor = ACCESS_ONCE(array->root);\r\nif (!cursor)\r\nreturn assoc_array_walk_tree_empty;\r\nlevel = 0;\r\njumped:\r\nsegments = ops->get_key_chunk(index_key, level);\r\npr_devel("segments[%d]: %lx\n", level, segments);\r\nif (assoc_array_ptr_is_shortcut(cursor))\r\ngoto follow_shortcut;\r\nconsider_node:\r\nnode = assoc_array_ptr_to_node(cursor);\r\nsmp_read_barrier_depends();\r\nslot = segments >> (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\r\nslot &= ASSOC_ARRAY_FAN_MASK;\r\nptr = ACCESS_ONCE(node->slots[slot]);\r\npr_devel("consider slot %x [ix=%d type=%lu]\n",\r\nslot, level, (unsigned long)ptr & 3);\r\nif (!assoc_array_ptr_is_meta(ptr)) {\r\nresult->terminal_node.node = node;\r\nresult->terminal_node.level = level;\r\nresult->terminal_node.slot = slot;\r\npr_devel("<--%s() = terminal_node\n", __func__);\r\nreturn assoc_array_walk_found_terminal_node;\r\n}\r\nif (assoc_array_ptr_is_node(ptr)) {\r\ncursor = ptr;\r\nlevel += ASSOC_ARRAY_LEVEL_STEP;\r\nif ((level & ASSOC_ARRAY_KEY_CHUNK_MASK) != 0)\r\ngoto consider_node;\r\ngoto jumped;\r\n}\r\ncursor = ptr;\r\nfollow_shortcut:\r\nshortcut = assoc_array_ptr_to_shortcut(cursor);\r\nsmp_read_barrier_depends();\r\npr_devel("shortcut to %d\n", shortcut->skip_to_level);\r\nsc_level = level + ASSOC_ARRAY_LEVEL_STEP;\r\nBUG_ON(sc_level > shortcut->skip_to_level);\r\ndo {\r\nif ((sc_level & ASSOC_ARRAY_KEY_CHUNK_MASK) == 0)\r\nsegments = ops->get_key_chunk(index_key, sc_level);\r\nsc_segments = shortcut->index_key[sc_level >> ASSOC_ARRAY_KEY_CHUNK_SHIFT];\r\ndissimilarity = segments ^ sc_segments;\r\nif (round_up(sc_level, ASSOC_ARRAY_KEY_CHUNK_SIZE) > shortcut->skip_to_level) {\r\nint shift = shortcut->skip_to_level & ASSOC_ARRAY_KEY_CHUNK_MASK;\r\ndissimilarity &= ~(ULONG_MAX << shift);\r\nnext_sc_level = shortcut->skip_to_level;\r\n} else {\r\nnext_sc_level = sc_level + ASSOC_ARRAY_KEY_CHUNK_SIZE;\r\nnext_sc_level = round_down(next_sc_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\r\n}\r\nif (dissimilarity != 0) {\r\nresult->wrong_shortcut.shortcut = shortcut;\r\nresult->wrong_shortcut.level = level;\r\nresult->wrong_shortcut.sc_level = sc_level;\r\nresult->wrong_shortcut.sc_segments = sc_segments;\r\nresult->wrong_shortcut.dissimilarity = dissimilarity;\r\nreturn assoc_array_walk_found_wrong_shortcut;\r\n}\r\nsc_level = next_sc_level;\r\n} while (sc_level < shortcut->skip_to_level);\r\ncursor = ACCESS_ONCE(shortcut->next_node);\r\nif (((level ^ sc_level) & ~ASSOC_ARRAY_KEY_CHUNK_MASK) != 0) {\r\nlevel = sc_level;\r\ngoto jumped;\r\n} else {\r\nlevel = sc_level;\r\ngoto consider_node;\r\n}\r\n}\r\nvoid *assoc_array_find(const struct assoc_array *array,\r\nconst struct assoc_array_ops *ops,\r\nconst void *index_key)\r\n{\r\nstruct assoc_array_walk_result result;\r\nconst struct assoc_array_node *node;\r\nconst struct assoc_array_ptr *ptr;\r\nconst void *leaf;\r\nint slot;\r\nif (assoc_array_walk(array, ops, index_key, &result) !=\r\nassoc_array_walk_found_terminal_node)\r\nreturn NULL;\r\nnode = result.terminal_node.node;\r\nsmp_read_barrier_depends();\r\nfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\r\nptr = ACCESS_ONCE(node->slots[slot]);\r\nif (ptr && assoc_array_ptr_is_leaf(ptr)) {\r\nleaf = assoc_array_ptr_to_leaf(ptr);\r\nsmp_read_barrier_depends();\r\nif (ops->compare_object(leaf, index_key))\r\nreturn (void *)leaf;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void assoc_array_destroy_subtree(struct assoc_array_ptr *root,\r\nconst struct assoc_array_ops *ops)\r\n{\r\nstruct assoc_array_shortcut *shortcut;\r\nstruct assoc_array_node *node;\r\nstruct assoc_array_ptr *cursor, *parent = NULL;\r\nint slot = -1;\r\npr_devel("-->%s()\n", __func__);\r\ncursor = root;\r\nif (!cursor) {\r\npr_devel("empty\n");\r\nreturn;\r\n}\r\nmove_to_meta:\r\nif (assoc_array_ptr_is_shortcut(cursor)) {\r\npr_devel("[%d] shortcut\n", slot);\r\nBUG_ON(!assoc_array_ptr_is_shortcut(cursor));\r\nshortcut = assoc_array_ptr_to_shortcut(cursor);\r\nBUG_ON(shortcut->back_pointer != parent);\r\nBUG_ON(slot != -1 && shortcut->parent_slot != slot);\r\nparent = cursor;\r\ncursor = shortcut->next_node;\r\nslot = -1;\r\nBUG_ON(!assoc_array_ptr_is_node(cursor));\r\n}\r\npr_devel("[%d] node\n", slot);\r\nnode = assoc_array_ptr_to_node(cursor);\r\nBUG_ON(node->back_pointer != parent);\r\nBUG_ON(slot != -1 && node->parent_slot != slot);\r\nslot = 0;\r\ncontinue_node:\r\npr_devel("Node %p [back=%p]\n", node, node->back_pointer);\r\nfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\r\nstruct assoc_array_ptr *ptr = node->slots[slot];\r\nif (!ptr)\r\ncontinue;\r\nif (assoc_array_ptr_is_meta(ptr)) {\r\nparent = cursor;\r\ncursor = ptr;\r\ngoto move_to_meta;\r\n}\r\nif (ops) {\r\npr_devel("[%d] free leaf\n", slot);\r\nops->free_object(assoc_array_ptr_to_leaf(ptr));\r\n}\r\n}\r\nparent = node->back_pointer;\r\nslot = node->parent_slot;\r\npr_devel("free node\n");\r\nkfree(node);\r\nif (!parent)\r\nreturn;\r\nif (assoc_array_ptr_is_shortcut(parent)) {\r\nshortcut = assoc_array_ptr_to_shortcut(parent);\r\nBUG_ON(shortcut->next_node != cursor);\r\ncursor = parent;\r\nparent = shortcut->back_pointer;\r\nslot = shortcut->parent_slot;\r\npr_devel("free shortcut\n");\r\nkfree(shortcut);\r\nif (!parent)\r\nreturn;\r\nBUG_ON(!assoc_array_ptr_is_node(parent));\r\n}\r\npr_devel("ascend to %p[%d]\n", parent, slot);\r\ncursor = parent;\r\nnode = assoc_array_ptr_to_node(cursor);\r\nslot++;\r\ngoto continue_node;\r\n}\r\nvoid assoc_array_destroy(struct assoc_array *array,\r\nconst struct assoc_array_ops *ops)\r\n{\r\nassoc_array_destroy_subtree(array->root, ops);\r\narray->root = NULL;\r\n}\r\nstatic bool assoc_array_insert_in_empty_tree(struct assoc_array_edit *edit)\r\n{\r\nstruct assoc_array_node *new_n0;\r\npr_devel("-->%s()\n", __func__);\r\nnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\r\nif (!new_n0)\r\nreturn false;\r\nedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\r\nedit->leaf_p = &new_n0->slots[0];\r\nedit->adjust_count_on = new_n0;\r\nedit->set[0].ptr = &edit->array->root;\r\nedit->set[0].to = assoc_array_node_to_ptr(new_n0);\r\npr_devel("<--%s() = ok [no root]\n", __func__);\r\nreturn true;\r\n}\r\nstatic bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\r\nconst struct assoc_array_ops *ops,\r\nconst void *index_key,\r\nstruct assoc_array_walk_result *result)\r\n{\r\nstruct assoc_array_shortcut *shortcut, *new_s0;\r\nstruct assoc_array_node *node, *new_n0, *new_n1, *side;\r\nstruct assoc_array_ptr *ptr;\r\nunsigned long dissimilarity, base_seg, blank;\r\nsize_t keylen;\r\nbool have_meta;\r\nint level, diff;\r\nint slot, next_slot, free_slot, i, j;\r\nnode = result->terminal_node.node;\r\nlevel = result->terminal_node.level;\r\nedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;\r\npr_devel("-->%s()\n", __func__);\r\nfree_slot = -1;\r\nfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\r\nptr = node->slots[i];\r\nif (!ptr) {\r\nfree_slot = i;\r\ncontinue;\r\n}\r\nif (ops->compare_object(assoc_array_ptr_to_leaf(ptr), index_key)) {\r\npr_devel("replace in slot %d\n", i);\r\nedit->leaf_p = &node->slots[i];\r\nedit->dead_leaf = node->slots[i];\r\npr_devel("<--%s() = ok [replace]\n", __func__);\r\nreturn true;\r\n}\r\n}\r\nif (free_slot >= 0) {\r\npr_devel("insert in free slot %d\n", free_slot);\r\nedit->leaf_p = &node->slots[free_slot];\r\nedit->adjust_count_on = node;\r\npr_devel("<--%s() = ok [insert]\n", __func__);\r\nreturn true;\r\n}\r\nnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\r\nif (!new_n0)\r\nreturn false;\r\nedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\r\nnew_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\r\nif (!new_n1)\r\nreturn false;\r\nedit->new_meta[1] = assoc_array_node_to_ptr(new_n1);\r\npr_devel("no spare slots\n");\r\nhave_meta = false;\r\nfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\r\nptr = node->slots[i];\r\nif (assoc_array_ptr_is_meta(ptr)) {\r\nedit->segment_cache[i] = 0xff;\r\nhave_meta = true;\r\ncontinue;\r\n}\r\nbase_seg = ops->get_object_key_chunk(\r\nassoc_array_ptr_to_leaf(ptr), level);\r\nbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\r\nedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\r\n}\r\nif (have_meta) {\r\npr_devel("have meta\n");\r\ngoto split_node;\r\n}\r\ndissimilarity = 0;\r\nbase_seg = edit->segment_cache[0];\r\nfor (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)\r\ndissimilarity |= edit->segment_cache[i] ^ base_seg;\r\npr_devel("only leaves; dissimilarity=%lx\n", dissimilarity);\r\nif ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {\r\nif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\r\ngoto all_leaves_cluster_together;\r\ngoto present_leaves_cluster_but_not_new_leaf;\r\n}\r\nsplit_node:\r\npr_devel("split node\n");\r\nedit->set[0].to = assoc_array_node_to_ptr(new_n0);\r\nnew_n0->back_pointer = node->back_pointer;\r\nnew_n0->parent_slot = node->parent_slot;\r\nnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\r\nnew_n1->parent_slot = -1;\r\ndo_split_node:\r\npr_devel("do_split_node\n");\r\nnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\r\nnew_n1->nr_leaves_on_branch = 0;\r\nfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\r\nslot = edit->segment_cache[i];\r\nif (slot != 0xff)\r\nfor (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)\r\nif (edit->segment_cache[j] == slot)\r\ngoto found_slot_for_multiple_occupancy;\r\n}\r\nfound_slot_for_multiple_occupancy:\r\npr_devel("same slot: %x %x [%02x]\n", i, j, slot);\r\nBUG_ON(i >= ASSOC_ARRAY_FAN_OUT);\r\nBUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);\r\nBUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);\r\nnew_n1->parent_slot = slot;\r\nfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\r\nif (assoc_array_ptr_is_meta(node->slots[i]))\r\nnew_n0->slots[i] = node->slots[i];\r\nelse\r\nnew_n0->slots[i] = NULL;\r\nBUG_ON(new_n0->slots[slot] != NULL);\r\nnew_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);\r\nfree_slot = -1;\r\nnext_slot = 0;\r\nfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\r\nif (assoc_array_ptr_is_meta(node->slots[i]))\r\ncontinue;\r\nif (edit->segment_cache[i] == slot) {\r\nnew_n1->slots[next_slot++] = node->slots[i];\r\nnew_n1->nr_leaves_on_branch++;\r\n} else {\r\ndo {\r\nfree_slot++;\r\n} while (new_n0->slots[free_slot] != NULL);\r\nnew_n0->slots[free_slot] = node->slots[i];\r\n}\r\n}\r\npr_devel("filtered: f=%x n=%x\n", free_slot, next_slot);\r\nif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\r\ndo {\r\nfree_slot++;\r\n} while (new_n0->slots[free_slot] != NULL);\r\nedit->leaf_p = &new_n0->slots[free_slot];\r\nedit->adjust_count_on = new_n0;\r\n} else {\r\nedit->leaf_p = &new_n1->slots[next_slot++];\r\nedit->adjust_count_on = new_n1;\r\n}\r\nBUG_ON(next_slot <= 1);\r\nedit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);\r\nfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\r\nif (edit->segment_cache[i] == 0xff) {\r\nptr = node->slots[i];\r\nBUG_ON(assoc_array_ptr_is_leaf(ptr));\r\nif (assoc_array_ptr_is_node(ptr)) {\r\nside = assoc_array_ptr_to_node(ptr);\r\nedit->set_backpointers[i] = &side->back_pointer;\r\n} else {\r\nshortcut = assoc_array_ptr_to_shortcut(ptr);\r\nedit->set_backpointers[i] = &shortcut->back_pointer;\r\n}\r\n}\r\n}\r\nptr = node->back_pointer;\r\nif (!ptr)\r\nedit->set[0].ptr = &edit->array->root;\r\nelse if (assoc_array_ptr_is_node(ptr))\r\nedit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];\r\nelse\r\nedit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;\r\nedit->excised_meta[0] = assoc_array_node_to_ptr(node);\r\npr_devel("<--%s() = ok [split node]\n", __func__);\r\nreturn true;\r\npresent_leaves_cluster_but_not_new_leaf:\r\npr_devel("present leaves cluster but not new leaf\n");\r\nnew_n0->back_pointer = node->back_pointer;\r\nnew_n0->parent_slot = node->parent_slot;\r\nnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\r\nnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\r\nnew_n1->parent_slot = edit->segment_cache[0];\r\nnew_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;\r\nedit->adjust_count_on = new_n0;\r\nfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\r\nnew_n1->slots[i] = node->slots[i];\r\nnew_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);\r\nedit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];\r\nedit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];\r\nedit->set[0].to = assoc_array_node_to_ptr(new_n0);\r\nedit->excised_meta[0] = assoc_array_node_to_ptr(node);\r\npr_devel("<--%s() = ok [insert node before]\n", __func__);\r\nreturn true;\r\nall_leaves_cluster_together:\r\npr_devel("all leaves cluster together\n");\r\ndiff = INT_MAX;\r\nfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\r\nint x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),\r\nindex_key);\r\nif (x < diff) {\r\nBUG_ON(x < 0);\r\ndiff = x;\r\n}\r\n}\r\nBUG_ON(diff == INT_MAX);\r\nBUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);\r\nkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\r\nkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\r\nnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\r\nkeylen * sizeof(unsigned long), GFP_KERNEL);\r\nif (!new_s0)\r\nreturn false;\r\nedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);\r\nedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\r\nnew_s0->back_pointer = node->back_pointer;\r\nnew_s0->parent_slot = node->parent_slot;\r\nnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\r\nnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\r\nnew_n0->parent_slot = 0;\r\nnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\r\nnew_n1->parent_slot = -1;\r\nnew_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;\r\npr_devel("skip_to_level = %d [diff %d]\n", level, diff);\r\nBUG_ON(level <= 0);\r\nfor (i = 0; i < keylen; i++)\r\nnew_s0->index_key[i] =\r\nops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\r\nblank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\r\npr_devel("blank off [%zu] %d: %lx\n", keylen - 1, level, blank);\r\nnew_s0->index_key[keylen - 1] &= ~blank;\r\nfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\r\nptr = node->slots[i];\r\nbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),\r\nlevel);\r\nbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\r\nedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\r\n}\r\nbase_seg = ops->get_key_chunk(index_key, level);\r\nbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\r\nedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;\r\ngoto do_split_node;\r\n}\r\nstatic bool assoc_array_insert_mid_shortcut(struct assoc_array_edit *edit,\r\nconst struct assoc_array_ops *ops,\r\nstruct assoc_array_walk_result *result)\r\n{\r\nstruct assoc_array_shortcut *shortcut, *new_s0, *new_s1;\r\nstruct assoc_array_node *node, *new_n0, *side;\r\nunsigned long sc_segments, dissimilarity, blank;\r\nsize_t keylen;\r\nint level, sc_level, diff;\r\nint sc_slot;\r\nshortcut = result->wrong_shortcut.shortcut;\r\nlevel = result->wrong_shortcut.level;\r\nsc_level = result->wrong_shortcut.sc_level;\r\nsc_segments = result->wrong_shortcut.sc_segments;\r\ndissimilarity = result->wrong_shortcut.dissimilarity;\r\npr_devel("-->%s(ix=%d dis=%lx scix=%d)\n",\r\n__func__, level, dissimilarity, sc_level);\r\ndiff = __ffs(dissimilarity);\r\ndiff &= ~ASSOC_ARRAY_LEVEL_STEP_MASK;\r\ndiff += sc_level & ~ASSOC_ARRAY_KEY_CHUNK_MASK;\r\npr_devel("diff=%d\n", diff);\r\nif (!shortcut->back_pointer) {\r\nedit->set[0].ptr = &edit->array->root;\r\n} else if (assoc_array_ptr_is_node(shortcut->back_pointer)) {\r\nnode = assoc_array_ptr_to_node(shortcut->back_pointer);\r\nedit->set[0].ptr = &node->slots[shortcut->parent_slot];\r\n} else {\r\nBUG();\r\n}\r\nedit->excised_meta[0] = assoc_array_shortcut_to_ptr(shortcut);\r\nnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\r\nif (!new_n0)\r\nreturn false;\r\nedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\r\nedit->adjust_count_on = new_n0;\r\nlevel += ASSOC_ARRAY_LEVEL_STEP;\r\nif (diff > level) {\r\npr_devel("pre-shortcut %d...%d\n", level, diff);\r\nkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\r\nkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\r\nnew_s0 = kzalloc(sizeof(struct assoc_array_shortcut) +\r\nkeylen * sizeof(unsigned long), GFP_KERNEL);\r\nif (!new_s0)\r\nreturn false;\r\nedit->new_meta[1] = assoc_array_shortcut_to_ptr(new_s0);\r\nedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\r\nnew_s0->back_pointer = shortcut->back_pointer;\r\nnew_s0->parent_slot = shortcut->parent_slot;\r\nnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\r\nnew_s0->skip_to_level = diff;\r\nnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\r\nnew_n0->parent_slot = 0;\r\nmemcpy(new_s0->index_key, shortcut->index_key,\r\nkeylen * sizeof(unsigned long));\r\nblank = ULONG_MAX << (diff & ASSOC_ARRAY_KEY_CHUNK_MASK);\r\npr_devel("blank off [%zu] %d: %lx\n", keylen - 1, diff, blank);\r\nnew_s0->index_key[keylen - 1] &= ~blank;\r\n} else {\r\npr_devel("no pre-shortcut\n");\r\nedit->set[0].to = assoc_array_node_to_ptr(new_n0);\r\nnew_n0->back_pointer = shortcut->back_pointer;\r\nnew_n0->parent_slot = shortcut->parent_slot;\r\n}\r\nside = assoc_array_ptr_to_node(shortcut->next_node);\r\nnew_n0->nr_leaves_on_branch = side->nr_leaves_on_branch;\r\nsc_slot = sc_segments >> (diff & ASSOC_ARRAY_KEY_CHUNK_MASK);\r\nsc_slot &= ASSOC_ARRAY_FAN_MASK;\r\npr_devel("new slot %lx >> %d -> %d\n",\r\nsc_segments, diff & ASSOC_ARRAY_KEY_CHUNK_MASK, sc_slot);\r\nlevel = diff + ASSOC_ARRAY_LEVEL_STEP;\r\nif (level < shortcut->skip_to_level) {\r\npr_devel("post-shortcut %d...%d\n", level, shortcut->skip_to_level);\r\nkeylen = round_up(shortcut->skip_to_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\r\nkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\r\nnew_s1 = kzalloc(sizeof(struct assoc_array_shortcut) +\r\nkeylen * sizeof(unsigned long), GFP_KERNEL);\r\nif (!new_s1)\r\nreturn false;\r\nedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s1);\r\nnew_s1->back_pointer = assoc_array_node_to_ptr(new_n0);\r\nnew_s1->parent_slot = sc_slot;\r\nnew_s1->next_node = shortcut->next_node;\r\nnew_s1->skip_to_level = shortcut->skip_to_level;\r\nnew_n0->slots[sc_slot] = assoc_array_shortcut_to_ptr(new_s1);\r\nmemcpy(new_s1->index_key, shortcut->index_key,\r\nkeylen * sizeof(unsigned long));\r\nedit->set[1].ptr = &side->back_pointer;\r\nedit->set[1].to = assoc_array_shortcut_to_ptr(new_s1);\r\n} else {\r\npr_devel("no post-shortcut\n");\r\nnew_n0->slots[sc_slot] = shortcut->next_node;\r\nedit->set_parent_slot[0].p = &side->parent_slot;\r\nedit->set_parent_slot[0].to = sc_slot;\r\nedit->set[1].ptr = &side->back_pointer;\r\nedit->set[1].to = assoc_array_node_to_ptr(new_n0);\r\n}\r\nif (sc_slot == 0)\r\nedit->leaf_p = &new_n0->slots[1];\r\nelse\r\nedit->leaf_p = &new_n0->slots[0];\r\npr_devel("<--%s() = ok [split shortcut]\n", __func__);\r\nreturn edit;\r\n}\r\nstruct assoc_array_edit *assoc_array_insert(struct assoc_array *array,\r\nconst struct assoc_array_ops *ops,\r\nconst void *index_key,\r\nvoid *object)\r\n{\r\nstruct assoc_array_walk_result result;\r\nstruct assoc_array_edit *edit;\r\npr_devel("-->%s()\n", __func__);\r\nBUG_ON(assoc_array_ptr_is_meta(object));\r\nedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\r\nif (!edit)\r\nreturn ERR_PTR(-ENOMEM);\r\nedit->array = array;\r\nedit->ops = ops;\r\nedit->leaf = assoc_array_leaf_to_ptr(object);\r\nedit->adjust_count_by = 1;\r\nswitch (assoc_array_walk(array, ops, index_key, &result)) {\r\ncase assoc_array_walk_tree_empty:\r\nif (!assoc_array_insert_in_empty_tree(edit))\r\ngoto enomem;\r\nreturn edit;\r\ncase assoc_array_walk_found_terminal_node:\r\nif (!assoc_array_insert_into_terminal_node(edit, ops, index_key,\r\n&result))\r\ngoto enomem;\r\nreturn edit;\r\ncase assoc_array_walk_found_wrong_shortcut:\r\nif (!assoc_array_insert_mid_shortcut(edit, ops, &result))\r\ngoto enomem;\r\nreturn edit;\r\n}\r\nenomem:\r\npr_devel("enomem\n");\r\nassoc_array_cancel_edit(edit);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nvoid assoc_array_insert_set_object(struct assoc_array_edit *edit, void *object)\r\n{\r\nBUG_ON(!object);\r\nedit->leaf = assoc_array_leaf_to_ptr(object);\r\n}\r\nstatic int assoc_array_delete_collapse_iterator(const void *leaf,\r\nvoid *iterator_data)\r\n{\r\nstruct assoc_array_delete_collapse_context *collapse = iterator_data;\r\nif (leaf == collapse->skip_leaf)\r\nreturn 0;\r\nBUG_ON(collapse->slot >= ASSOC_ARRAY_FAN_OUT);\r\ncollapse->node->slots[collapse->slot++] = assoc_array_leaf_to_ptr(leaf);\r\nreturn 0;\r\n}\r\nstruct assoc_array_edit *assoc_array_delete(struct assoc_array *array,\r\nconst struct assoc_array_ops *ops,\r\nconst void *index_key)\r\n{\r\nstruct assoc_array_delete_collapse_context collapse;\r\nstruct assoc_array_walk_result result;\r\nstruct assoc_array_node *node, *new_n0;\r\nstruct assoc_array_edit *edit;\r\nstruct assoc_array_ptr *ptr;\r\nbool has_meta;\r\nint slot, i;\r\npr_devel("-->%s()\n", __func__);\r\nedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\r\nif (!edit)\r\nreturn ERR_PTR(-ENOMEM);\r\nedit->array = array;\r\nedit->ops = ops;\r\nedit->adjust_count_by = -1;\r\nswitch (assoc_array_walk(array, ops, index_key, &result)) {\r\ncase assoc_array_walk_found_terminal_node:\r\npr_devel("terminal_node\n");\r\nnode = result.terminal_node.node;\r\nfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\r\nptr = node->slots[slot];\r\nif (ptr &&\r\nassoc_array_ptr_is_leaf(ptr) &&\r\nops->compare_object(assoc_array_ptr_to_leaf(ptr),\r\nindex_key))\r\ngoto found_leaf;\r\n}\r\ncase assoc_array_walk_tree_empty:\r\ncase assoc_array_walk_found_wrong_shortcut:\r\ndefault:\r\nassoc_array_cancel_edit(edit);\r\npr_devel("not found\n");\r\nreturn NULL;\r\n}\r\nfound_leaf:\r\nBUG_ON(array->nr_leaves_on_tree <= 0);\r\nedit->dead_leaf = node->slots[slot];\r\nedit->set[0].ptr = &node->slots[slot];\r\nedit->set[0].to = NULL;\r\nedit->adjust_count_on = node;\r\nif (array->nr_leaves_on_tree == 1) {\r\nedit->set[1].ptr = &array->root;\r\nedit->set[1].to = NULL;\r\nedit->adjust_count_on = NULL;\r\nedit->excised_subtree = array->root;\r\npr_devel("all gone\n");\r\nreturn edit;\r\n}\r\nif (node->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT + 1) {\r\nstruct assoc_array_node *parent, *grandparent;\r\nstruct assoc_array_ptr *ptr;\r\nhas_meta = false;\r\nfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\r\nptr = node->slots[i];\r\nif (assoc_array_ptr_is_meta(ptr)) {\r\nhas_meta = true;\r\nbreak;\r\n}\r\n}\r\npr_devel("leaves: %ld [m=%d]\n",\r\nnode->nr_leaves_on_branch - 1, has_meta);\r\nparent = node;\r\ncollapse_up:\r\npr_devel("collapse subtree: %ld\n", parent->nr_leaves_on_branch);\r\nptr = parent->back_pointer;\r\nif (!ptr)\r\ngoto do_collapse;\r\nif (assoc_array_ptr_is_shortcut(ptr)) {\r\nstruct assoc_array_shortcut *s = assoc_array_ptr_to_shortcut(ptr);\r\nptr = s->back_pointer;\r\nif (!ptr)\r\ngoto do_collapse;\r\n}\r\ngrandparent = assoc_array_ptr_to_node(ptr);\r\nif (grandparent->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT + 1) {\r\nparent = grandparent;\r\ngoto collapse_up;\r\n}\r\ndo_collapse:\r\nif (has_meta || parent != node) {\r\nnode = parent;\r\nnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\r\nif (!new_n0)\r\ngoto enomem;\r\nedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\r\nnew_n0->back_pointer = node->back_pointer;\r\nnew_n0->parent_slot = node->parent_slot;\r\nnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\r\nedit->adjust_count_on = new_n0;\r\ncollapse.node = new_n0;\r\ncollapse.skip_leaf = assoc_array_ptr_to_leaf(edit->dead_leaf);\r\ncollapse.slot = 0;\r\nassoc_array_subtree_iterate(assoc_array_node_to_ptr(node),\r\nnode->back_pointer,\r\nassoc_array_delete_collapse_iterator,\r\n&collapse);\r\npr_devel("collapsed %d,%lu\n", collapse.slot, new_n0->nr_leaves_on_branch);\r\nBUG_ON(collapse.slot != new_n0->nr_leaves_on_branch - 1);\r\nif (!node->back_pointer) {\r\nedit->set[1].ptr = &array->root;\r\n} else if (assoc_array_ptr_is_leaf(node->back_pointer)) {\r\nBUG();\r\n} else if (assoc_array_ptr_is_node(node->back_pointer)) {\r\nstruct assoc_array_node *p =\r\nassoc_array_ptr_to_node(node->back_pointer);\r\nedit->set[1].ptr = &p->slots[node->parent_slot];\r\n} else if (assoc_array_ptr_is_shortcut(node->back_pointer)) {\r\nstruct assoc_array_shortcut *s =\r\nassoc_array_ptr_to_shortcut(node->back_pointer);\r\nedit->set[1].ptr = &s->next_node;\r\n}\r\nedit->set[1].to = assoc_array_node_to_ptr(new_n0);\r\nedit->excised_subtree = assoc_array_node_to_ptr(node);\r\n}\r\n}\r\nreturn edit;\r\nenomem:\r\npr_devel("enomem\n");\r\nassoc_array_cancel_edit(edit);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstruct assoc_array_edit *assoc_array_clear(struct assoc_array *array,\r\nconst struct assoc_array_ops *ops)\r\n{\r\nstruct assoc_array_edit *edit;\r\npr_devel("-->%s()\n", __func__);\r\nif (!array->root)\r\nreturn NULL;\r\nedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\r\nif (!edit)\r\nreturn ERR_PTR(-ENOMEM);\r\nedit->array = array;\r\nedit->ops = ops;\r\nedit->set[1].ptr = &array->root;\r\nedit->set[1].to = NULL;\r\nedit->excised_subtree = array->root;\r\nedit->ops_for_excised_subtree = ops;\r\npr_devel("all gone\n");\r\nreturn edit;\r\n}\r\nstatic void assoc_array_rcu_cleanup(struct rcu_head *head)\r\n{\r\nstruct assoc_array_edit *edit =\r\ncontainer_of(head, struct assoc_array_edit, rcu);\r\nint i;\r\npr_devel("-->%s()\n", __func__);\r\nif (edit->dead_leaf)\r\nedit->ops->free_object(assoc_array_ptr_to_leaf(edit->dead_leaf));\r\nfor (i = 0; i < ARRAY_SIZE(edit->excised_meta); i++)\r\nif (edit->excised_meta[i])\r\nkfree(assoc_array_ptr_to_node(edit->excised_meta[i]));\r\nif (edit->excised_subtree) {\r\nBUG_ON(assoc_array_ptr_is_leaf(edit->excised_subtree));\r\nif (assoc_array_ptr_is_node(edit->excised_subtree)) {\r\nstruct assoc_array_node *n =\r\nassoc_array_ptr_to_node(edit->excised_subtree);\r\nn->back_pointer = NULL;\r\n} else {\r\nstruct assoc_array_shortcut *s =\r\nassoc_array_ptr_to_shortcut(edit->excised_subtree);\r\ns->back_pointer = NULL;\r\n}\r\nassoc_array_destroy_subtree(edit->excised_subtree,\r\nedit->ops_for_excised_subtree);\r\n}\r\nkfree(edit);\r\n}\r\nvoid assoc_array_apply_edit(struct assoc_array_edit *edit)\r\n{\r\nstruct assoc_array_shortcut *shortcut;\r\nstruct assoc_array_node *node;\r\nstruct assoc_array_ptr *ptr;\r\nint i;\r\npr_devel("-->%s()\n", __func__);\r\nsmp_wmb();\r\nif (edit->leaf_p)\r\n*edit->leaf_p = edit->leaf;\r\nsmp_wmb();\r\nfor (i = 0; i < ARRAY_SIZE(edit->set_parent_slot); i++)\r\nif (edit->set_parent_slot[i].p)\r\n*edit->set_parent_slot[i].p = edit->set_parent_slot[i].to;\r\nsmp_wmb();\r\nfor (i = 0; i < ARRAY_SIZE(edit->set_backpointers); i++)\r\nif (edit->set_backpointers[i])\r\n*edit->set_backpointers[i] = edit->set_backpointers_to;\r\nsmp_wmb();\r\nfor (i = 0; i < ARRAY_SIZE(edit->set); i++)\r\nif (edit->set[i].ptr)\r\n*edit->set[i].ptr = edit->set[i].to;\r\nif (edit->array->root == NULL) {\r\nedit->array->nr_leaves_on_tree = 0;\r\n} else if (edit->adjust_count_on) {\r\nnode = edit->adjust_count_on;\r\nfor (;;) {\r\nnode->nr_leaves_on_branch += edit->adjust_count_by;\r\nptr = node->back_pointer;\r\nif (!ptr)\r\nbreak;\r\nif (assoc_array_ptr_is_shortcut(ptr)) {\r\nshortcut = assoc_array_ptr_to_shortcut(ptr);\r\nptr = shortcut->back_pointer;\r\nif (!ptr)\r\nbreak;\r\n}\r\nBUG_ON(!assoc_array_ptr_is_node(ptr));\r\nnode = assoc_array_ptr_to_node(ptr);\r\n}\r\nedit->array->nr_leaves_on_tree += edit->adjust_count_by;\r\n}\r\ncall_rcu(&edit->rcu, assoc_array_rcu_cleanup);\r\n}\r\nvoid assoc_array_cancel_edit(struct assoc_array_edit *edit)\r\n{\r\nstruct assoc_array_ptr *ptr;\r\nint i;\r\npr_devel("-->%s()\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(edit->new_meta); i++) {\r\nptr = edit->new_meta[i];\r\nif (ptr) {\r\nif (assoc_array_ptr_is_node(ptr))\r\nkfree(assoc_array_ptr_to_node(ptr));\r\nelse\r\nkfree(assoc_array_ptr_to_shortcut(ptr));\r\n}\r\n}\r\nkfree(edit);\r\n}\r\nint assoc_array_gc(struct assoc_array *array,\r\nconst struct assoc_array_ops *ops,\r\nbool (*iterator)(void *object, void *iterator_data),\r\nvoid *iterator_data)\r\n{\r\nstruct assoc_array_shortcut *shortcut, *new_s;\r\nstruct assoc_array_node *node, *new_n;\r\nstruct assoc_array_edit *edit;\r\nstruct assoc_array_ptr *cursor, *ptr;\r\nstruct assoc_array_ptr *new_root, *new_parent, **new_ptr_pp;\r\nunsigned long nr_leaves_on_tree;\r\nint keylen, slot, nr_free, next_slot, i;\r\npr_devel("-->%s()\n", __func__);\r\nif (!array->root)\r\nreturn 0;\r\nedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\r\nif (!edit)\r\nreturn -ENOMEM;\r\nedit->array = array;\r\nedit->ops = ops;\r\nedit->ops_for_excised_subtree = ops;\r\nedit->set[0].ptr = &array->root;\r\nedit->excised_subtree = array->root;\r\nnew_root = new_parent = NULL;\r\nnew_ptr_pp = &new_root;\r\ncursor = array->root;\r\ndescend:\r\nif (assoc_array_ptr_is_shortcut(cursor)) {\r\nshortcut = assoc_array_ptr_to_shortcut(cursor);\r\nkeylen = round_up(shortcut->skip_to_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\r\nkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\r\nnew_s = kmalloc(sizeof(struct assoc_array_shortcut) +\r\nkeylen * sizeof(unsigned long), GFP_KERNEL);\r\nif (!new_s)\r\ngoto enomem;\r\npr_devel("dup shortcut %p -> %p\n", shortcut, new_s);\r\nmemcpy(new_s, shortcut, (sizeof(struct assoc_array_shortcut) +\r\nkeylen * sizeof(unsigned long)));\r\nnew_s->back_pointer = new_parent;\r\nnew_s->parent_slot = shortcut->parent_slot;\r\n*new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr(new_s);\r\nnew_ptr_pp = &new_s->next_node;\r\ncursor = shortcut->next_node;\r\n}\r\nnode = assoc_array_ptr_to_node(cursor);\r\nnew_n = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\r\nif (!new_n)\r\ngoto enomem;\r\npr_devel("dup node %p -> %p\n", node, new_n);\r\nnew_n->back_pointer = new_parent;\r\nnew_n->parent_slot = node->parent_slot;\r\n*new_ptr_pp = new_parent = assoc_array_node_to_ptr(new_n);\r\nnew_ptr_pp = NULL;\r\nslot = 0;\r\ncontinue_node:\r\nfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\r\nptr = node->slots[slot];\r\nif (!ptr)\r\ncontinue;\r\nif (assoc_array_ptr_is_leaf(ptr)) {\r\nif (iterator(assoc_array_ptr_to_leaf(ptr),\r\niterator_data))\r\nnew_n->slots[slot] = ptr;\r\ncontinue;\r\n}\r\nnew_ptr_pp = &new_n->slots[slot];\r\ncursor = ptr;\r\ngoto descend;\r\n}\r\npr_devel("-- compress node %p --\n", new_n);\r\nnew_n->nr_leaves_on_branch = 0;\r\nnr_free = 0;\r\nfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\r\nptr = new_n->slots[slot];\r\nif (!ptr)\r\nnr_free++;\r\nelse if (assoc_array_ptr_is_leaf(ptr))\r\nnew_n->nr_leaves_on_branch++;\r\n}\r\npr_devel("free=%d, leaves=%lu\n", nr_free, new_n->nr_leaves_on_branch);\r\nnext_slot = 0;\r\nfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\r\nstruct assoc_array_shortcut *s;\r\nstruct assoc_array_node *child;\r\nptr = new_n->slots[slot];\r\nif (!ptr || assoc_array_ptr_is_leaf(ptr))\r\ncontinue;\r\ns = NULL;\r\nif (assoc_array_ptr_is_shortcut(ptr)) {\r\ns = assoc_array_ptr_to_shortcut(ptr);\r\nptr = s->next_node;\r\n}\r\nchild = assoc_array_ptr_to_node(ptr);\r\nnew_n->nr_leaves_on_branch += child->nr_leaves_on_branch;\r\nif (child->nr_leaves_on_branch <= nr_free + 1) {\r\npr_devel("[%d] fold node %lu/%d [nx %d]\n",\r\nslot, child->nr_leaves_on_branch, nr_free + 1,\r\nnext_slot);\r\nBUG_ON(s);\r\nnew_n->slots[slot] = NULL;\r\nnr_free++;\r\nif (slot < next_slot)\r\nnext_slot = slot;\r\nfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\r\nstruct assoc_array_ptr *p = child->slots[i];\r\nif (!p)\r\ncontinue;\r\nBUG_ON(assoc_array_ptr_is_meta(p));\r\nwhile (new_n->slots[next_slot])\r\nnext_slot++;\r\nBUG_ON(next_slot >= ASSOC_ARRAY_FAN_OUT);\r\nnew_n->slots[next_slot++] = p;\r\nnr_free--;\r\n}\r\nkfree(child);\r\n} else {\r\npr_devel("[%d] retain node %lu/%d [nx %d]\n",\r\nslot, child->nr_leaves_on_branch, nr_free + 1,\r\nnext_slot);\r\n}\r\n}\r\npr_devel("after: %lu\n", new_n->nr_leaves_on_branch);\r\nnr_leaves_on_tree = new_n->nr_leaves_on_branch;\r\nif (nr_free == ASSOC_ARRAY_FAN_OUT - 1) {\r\nfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++)\r\nif ((ptr = new_n->slots[slot]))\r\nbreak;\r\nif (assoc_array_ptr_is_meta(ptr) &&\r\nassoc_array_ptr_is_shortcut(ptr)) {\r\npr_devel("excise node %p with 1 shortcut\n", new_n);\r\nnew_s = assoc_array_ptr_to_shortcut(ptr);\r\nnew_parent = new_n->back_pointer;\r\nslot = new_n->parent_slot;\r\nkfree(new_n);\r\nif (!new_parent) {\r\nnew_s->back_pointer = NULL;\r\nnew_s->parent_slot = 0;\r\nnew_root = ptr;\r\ngoto gc_complete;\r\n}\r\nif (assoc_array_ptr_is_shortcut(new_parent)) {\r\nstruct assoc_array_shortcut *s =\r\nassoc_array_ptr_to_shortcut(new_parent);\r\npr_devel("excise preceding shortcut\n");\r\nnew_parent = new_s->back_pointer = s->back_pointer;\r\nslot = new_s->parent_slot = s->parent_slot;\r\nkfree(s);\r\nif (!new_parent) {\r\nnew_s->back_pointer = NULL;\r\nnew_s->parent_slot = 0;\r\nnew_root = ptr;\r\ngoto gc_complete;\r\n}\r\n}\r\nnew_s->back_pointer = new_parent;\r\nnew_s->parent_slot = slot;\r\nnew_n = assoc_array_ptr_to_node(new_parent);\r\nnew_n->slots[slot] = ptr;\r\ngoto ascend_old_tree;\r\n}\r\n}\r\nptr = new_n->back_pointer;\r\nif (!ptr)\r\ngoto gc_complete;\r\nif (assoc_array_ptr_is_shortcut(ptr)) {\r\nnew_s = assoc_array_ptr_to_shortcut(ptr);\r\nnew_parent = new_s->back_pointer;\r\nslot = new_s->parent_slot;\r\nif (new_n->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT) {\r\nstruct assoc_array_node *n;\r\npr_devel("excise shortcut\n");\r\nnew_n->back_pointer = new_parent;\r\nnew_n->parent_slot = slot;\r\nkfree(new_s);\r\nif (!new_parent) {\r\nnew_root = assoc_array_node_to_ptr(new_n);\r\ngoto gc_complete;\r\n}\r\nn = assoc_array_ptr_to_node(new_parent);\r\nn->slots[slot] = assoc_array_node_to_ptr(new_n);\r\n}\r\n} else {\r\nnew_parent = ptr;\r\n}\r\nnew_n = assoc_array_ptr_to_node(new_parent);\r\nascend_old_tree:\r\nptr = node->back_pointer;\r\nif (assoc_array_ptr_is_shortcut(ptr)) {\r\nshortcut = assoc_array_ptr_to_shortcut(ptr);\r\nslot = shortcut->parent_slot;\r\ncursor = shortcut->back_pointer;\r\n} else {\r\nslot = node->parent_slot;\r\ncursor = ptr;\r\n}\r\nBUG_ON(!ptr);\r\nnode = assoc_array_ptr_to_node(cursor);\r\nslot++;\r\ngoto continue_node;\r\ngc_complete:\r\nedit->set[0].to = new_root;\r\nassoc_array_apply_edit(edit);\r\nedit->array->nr_leaves_on_tree = nr_leaves_on_tree;\r\nreturn 0;\r\nenomem:\r\npr_devel("enomem\n");\r\nassoc_array_destroy_subtree(new_root, edit->ops);\r\nkfree(edit);\r\nreturn -ENOMEM;\r\n}
