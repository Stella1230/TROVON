static struct drm_buf *i810_freelist_get(struct drm_device * dev)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\nint i;\r\nint used;\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nstruct drm_buf *buf = dma->buflist[i];\r\ndrm_i810_buf_priv_t *buf_priv = buf->dev_private;\r\nused = cmpxchg(buf_priv->in_use, I810_BUF_FREE,\r\nI810_BUF_CLIENT);\r\nif (used == I810_BUF_FREE)\r\nreturn buf;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int i810_freelist_put(struct drm_device *dev, struct drm_buf *buf)\r\n{\r\ndrm_i810_buf_priv_t *buf_priv = buf->dev_private;\r\nint used;\r\nused = cmpxchg(buf_priv->in_use, I810_BUF_CLIENT, I810_BUF_FREE);\r\nif (used != I810_BUF_CLIENT) {\r\nDRM_ERROR("Freeing buffer thats not in use : %d\n", buf->idx);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i810_mmap_buffers(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *priv = filp->private_data;\r\nstruct drm_device *dev;\r\ndrm_i810_private_t *dev_priv;\r\nstruct drm_buf *buf;\r\ndrm_i810_buf_priv_t *buf_priv;\r\ndev = priv->minor->dev;\r\ndev_priv = dev->dev_private;\r\nbuf = dev_priv->mmap_buffer;\r\nbuf_priv = buf->dev_private;\r\nvma->vm_flags |= VM_DONTCOPY;\r\nbuf_priv->currently_mapped = I810_BUF_MAPPED;\r\nif (io_remap_pfn_range(vma, vma->vm_start,\r\nvma->vm_pgoff,\r\nvma->vm_end - vma->vm_start, vma->vm_page_prot))\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int i810_map_buffer(struct drm_buf *buf, struct drm_file *file_priv)\r\n{\r\nstruct drm_device *dev = file_priv->minor->dev;\r\ndrm_i810_buf_priv_t *buf_priv = buf->dev_private;\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\nconst struct file_operations *old_fops;\r\nint retcode = 0;\r\nif (buf_priv->currently_mapped == I810_BUF_MAPPED)\r\nreturn -EINVAL;\r\nold_fops = file_priv->filp->f_op;\r\nfile_priv->filp->f_op = &i810_buffer_fops;\r\ndev_priv->mmap_buffer = buf;\r\nbuf_priv->virtual = (void *)vm_mmap(file_priv->filp, 0, buf->total,\r\nPROT_READ | PROT_WRITE,\r\nMAP_SHARED, buf->bus_address);\r\ndev_priv->mmap_buffer = NULL;\r\nfile_priv->filp->f_op = old_fops;\r\nif (IS_ERR(buf_priv->virtual)) {\r\nDRM_ERROR("mmap error\n");\r\nretcode = PTR_ERR(buf_priv->virtual);\r\nbuf_priv->virtual = NULL;\r\n}\r\nreturn retcode;\r\n}\r\nstatic int i810_unmap_buffer(struct drm_buf *buf)\r\n{\r\ndrm_i810_buf_priv_t *buf_priv = buf->dev_private;\r\nint retcode = 0;\r\nif (buf_priv->currently_mapped != I810_BUF_MAPPED)\r\nreturn -EINVAL;\r\nretcode = vm_munmap((unsigned long)buf_priv->virtual,\r\n(size_t) buf->total);\r\nbuf_priv->currently_mapped = I810_BUF_UNMAPPED;\r\nbuf_priv->virtual = NULL;\r\nreturn retcode;\r\n}\r\nstatic int i810_dma_get_buffer(struct drm_device *dev, drm_i810_dma_t *d,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_buf *buf;\r\ndrm_i810_buf_priv_t *buf_priv;\r\nint retcode = 0;\r\nbuf = i810_freelist_get(dev);\r\nif (!buf) {\r\nretcode = -ENOMEM;\r\nDRM_DEBUG("retcode=%d\n", retcode);\r\nreturn retcode;\r\n}\r\nretcode = i810_map_buffer(buf, file_priv);\r\nif (retcode) {\r\ni810_freelist_put(dev, buf);\r\nDRM_ERROR("mapbuf failed, retcode %d\n", retcode);\r\nreturn retcode;\r\n}\r\nbuf->file_priv = file_priv;\r\nbuf_priv = buf->dev_private;\r\nd->granted = 1;\r\nd->request_idx = buf->idx;\r\nd->request_size = buf->total;\r\nd->virtual = buf_priv->virtual;\r\nreturn retcode;\r\n}\r\nstatic int i810_dma_cleanup(struct drm_device *dev)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\nif (drm_core_check_feature(dev, DRIVER_HAVE_IRQ) && dev->irq_enabled)\r\ndrm_irq_uninstall(dev);\r\nif (dev->dev_private) {\r\nint i;\r\ndrm_i810_private_t *dev_priv =\r\n(drm_i810_private_t *) dev->dev_private;\r\nif (dev_priv->ring.virtual_start)\r\ndrm_core_ioremapfree(&dev_priv->ring.map, dev);\r\nif (dev_priv->hw_status_page) {\r\npci_free_consistent(dev->pdev, PAGE_SIZE,\r\ndev_priv->hw_status_page,\r\ndev_priv->dma_status_page);\r\n}\r\nkfree(dev->dev_private);\r\ndev->dev_private = NULL;\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nstruct drm_buf *buf = dma->buflist[i];\r\ndrm_i810_buf_priv_t *buf_priv = buf->dev_private;\r\nif (buf_priv->kernel_virtual && buf->total)\r\ndrm_core_ioremapfree(&buf_priv->map, dev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int i810_wait_ring(struct drm_device *dev, int n)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\ndrm_i810_ring_buffer_t *ring = &(dev_priv->ring);\r\nint iters = 0;\r\nunsigned long end;\r\nunsigned int last_head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;\r\nend = jiffies + (HZ * 3);\r\nwhile (ring->space < n) {\r\nring->head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;\r\nring->space = ring->head - (ring->tail + 8);\r\nif (ring->space < 0)\r\nring->space += ring->Size;\r\nif (ring->head != last_head) {\r\nend = jiffies + (HZ * 3);\r\nlast_head = ring->head;\r\n}\r\niters++;\r\nif (time_before(end, jiffies)) {\r\nDRM_ERROR("space: %d wanted %d\n", ring->space, n);\r\nDRM_ERROR("lockup\n");\r\ngoto out_wait_ring;\r\n}\r\nudelay(1);\r\n}\r\nout_wait_ring:\r\nreturn iters;\r\n}\r\nstatic void i810_kernel_lost_context(struct drm_device *dev)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\ndrm_i810_ring_buffer_t *ring = &(dev_priv->ring);\r\nring->head = I810_READ(LP_RING + RING_HEAD) & HEAD_ADDR;\r\nring->tail = I810_READ(LP_RING + RING_TAIL);\r\nring->space = ring->head - (ring->tail + 8);\r\nif (ring->space < 0)\r\nring->space += ring->Size;\r\n}\r\nstatic int i810_freelist_init(struct drm_device *dev, drm_i810_private_t *dev_priv)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\nint my_idx = 24;\r\nu32 *hw_status = (u32 *) (dev_priv->hw_status_page + my_idx);\r\nint i;\r\nif (dma->buf_count > 1019) {\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nstruct drm_buf *buf = dma->buflist[i];\r\ndrm_i810_buf_priv_t *buf_priv = buf->dev_private;\r\nbuf_priv->in_use = hw_status++;\r\nbuf_priv->my_use_idx = my_idx;\r\nmy_idx += 4;\r\n*buf_priv->in_use = I810_BUF_FREE;\r\nbuf_priv->map.offset = buf->bus_address;\r\nbuf_priv->map.size = buf->total;\r\nbuf_priv->map.type = _DRM_AGP;\r\nbuf_priv->map.flags = 0;\r\nbuf_priv->map.mtrr = 0;\r\ndrm_core_ioremap(&buf_priv->map, dev);\r\nbuf_priv->kernel_virtual = buf_priv->map.handle;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i810_dma_initialize(struct drm_device *dev,\r\ndrm_i810_private_t *dev_priv,\r\ndrm_i810_init_t *init)\r\n{\r\nstruct drm_map_list *r_list;\r\nmemset(dev_priv, 0, sizeof(drm_i810_private_t));\r\nlist_for_each_entry(r_list, &dev->maplist, head) {\r\nif (r_list->map &&\r\nr_list->map->type == _DRM_SHM &&\r\nr_list->map->flags & _DRM_CONTAINS_LOCK) {\r\ndev_priv->sarea_map = r_list->map;\r\nbreak;\r\n}\r\n}\r\nif (!dev_priv->sarea_map) {\r\ndev->dev_private = (void *)dev_priv;\r\ni810_dma_cleanup(dev);\r\nDRM_ERROR("can not find sarea!\n");\r\nreturn -EINVAL;\r\n}\r\ndev_priv->mmio_map = drm_core_findmap(dev, init->mmio_offset);\r\nif (!dev_priv->mmio_map) {\r\ndev->dev_private = (void *)dev_priv;\r\ni810_dma_cleanup(dev);\r\nDRM_ERROR("can not find mmio map!\n");\r\nreturn -EINVAL;\r\n}\r\ndev->agp_buffer_token = init->buffers_offset;\r\ndev->agp_buffer_map = drm_core_findmap(dev, init->buffers_offset);\r\nif (!dev->agp_buffer_map) {\r\ndev->dev_private = (void *)dev_priv;\r\ni810_dma_cleanup(dev);\r\nDRM_ERROR("can not find dma buffer map!\n");\r\nreturn -EINVAL;\r\n}\r\ndev_priv->sarea_priv = (drm_i810_sarea_t *)\r\n((u8 *) dev_priv->sarea_map->handle + init->sarea_priv_offset);\r\ndev_priv->ring.Start = init->ring_start;\r\ndev_priv->ring.End = init->ring_end;\r\ndev_priv->ring.Size = init->ring_size;\r\ndev_priv->ring.map.offset = dev->agp->base + init->ring_start;\r\ndev_priv->ring.map.size = init->ring_size;\r\ndev_priv->ring.map.type = _DRM_AGP;\r\ndev_priv->ring.map.flags = 0;\r\ndev_priv->ring.map.mtrr = 0;\r\ndrm_core_ioremap(&dev_priv->ring.map, dev);\r\nif (dev_priv->ring.map.handle == NULL) {\r\ndev->dev_private = (void *)dev_priv;\r\ni810_dma_cleanup(dev);\r\nDRM_ERROR("can not ioremap virtual address for"\r\n" ring buffer\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_priv->ring.virtual_start = dev_priv->ring.map.handle;\r\ndev_priv->ring.tail_mask = dev_priv->ring.Size - 1;\r\ndev_priv->w = init->w;\r\ndev_priv->h = init->h;\r\ndev_priv->pitch = init->pitch;\r\ndev_priv->back_offset = init->back_offset;\r\ndev_priv->depth_offset = init->depth_offset;\r\ndev_priv->front_offset = init->front_offset;\r\ndev_priv->overlay_offset = init->overlay_offset;\r\ndev_priv->overlay_physical = init->overlay_physical;\r\ndev_priv->front_di1 = init->front_offset | init->pitch_bits;\r\ndev_priv->back_di1 = init->back_offset | init->pitch_bits;\r\ndev_priv->zi1 = init->depth_offset | init->pitch_bits;\r\ndev_priv->hw_status_page =\r\npci_alloc_consistent(dev->pdev, PAGE_SIZE,\r\n&dev_priv->dma_status_page);\r\nif (!dev_priv->hw_status_page) {\r\ndev->dev_private = (void *)dev_priv;\r\ni810_dma_cleanup(dev);\r\nDRM_ERROR("Can not allocate hardware status page\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(dev_priv->hw_status_page, 0, PAGE_SIZE);\r\nDRM_DEBUG("hw status page @ %p\n", dev_priv->hw_status_page);\r\nI810_WRITE(0x02080, dev_priv->dma_status_page);\r\nDRM_DEBUG("Enabled hardware status page\n");\r\nif (i810_freelist_init(dev, dev_priv) != 0) {\r\ndev->dev_private = (void *)dev_priv;\r\ni810_dma_cleanup(dev);\r\nDRM_ERROR("Not enough space in the status page for"\r\n" the freelist\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->dev_private = (void *)dev_priv;\r\nreturn 0;\r\n}\r\nstatic int i810_dma_init(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_i810_private_t *dev_priv;\r\ndrm_i810_init_t *init = data;\r\nint retcode = 0;\r\nswitch (init->func) {\r\ncase I810_INIT_DMA_1_4:\r\nDRM_INFO("Using v1.4 init.\n");\r\ndev_priv = kmalloc(sizeof(drm_i810_private_t), GFP_KERNEL);\r\nif (dev_priv == NULL)\r\nreturn -ENOMEM;\r\nretcode = i810_dma_initialize(dev, dev_priv, init);\r\nbreak;\r\ncase I810_CLEANUP_DMA:\r\nDRM_INFO("DMA Cleanup\n");\r\nretcode = i810_dma_cleanup(dev);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn retcode;\r\n}\r\nstatic void i810EmitContextVerified(struct drm_device *dev,\r\nvolatile unsigned int *code)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\nint i, j = 0;\r\nunsigned int tmp;\r\nRING_LOCALS;\r\nBEGIN_LP_RING(I810_CTX_SETUP_SIZE);\r\nOUT_RING(GFX_OP_COLOR_FACTOR);\r\nOUT_RING(code[I810_CTXREG_CF1]);\r\nOUT_RING(GFX_OP_STIPPLE);\r\nOUT_RING(code[I810_CTXREG_ST1]);\r\nfor (i = 4; i < I810_CTX_SETUP_SIZE; i++) {\r\ntmp = code[i];\r\nif ((tmp & (7 << 29)) == (3 << 29) &&\r\n(tmp & (0x1f << 24)) < (0x1d << 24)) {\r\nOUT_RING(tmp);\r\nj++;\r\n} else\r\nprintk("constext state dropped!!!\n");\r\n}\r\nif (j & 1)\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\n}\r\nstatic void i810EmitTexVerified(struct drm_device *dev, volatile unsigned int *code)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\nint i, j = 0;\r\nunsigned int tmp;\r\nRING_LOCALS;\r\nBEGIN_LP_RING(I810_TEX_SETUP_SIZE);\r\nOUT_RING(GFX_OP_MAP_INFO);\r\nOUT_RING(code[I810_TEXREG_MI1]);\r\nOUT_RING(code[I810_TEXREG_MI2]);\r\nOUT_RING(code[I810_TEXREG_MI3]);\r\nfor (i = 4; i < I810_TEX_SETUP_SIZE; i++) {\r\ntmp = code[i];\r\nif ((tmp & (7 << 29)) == (3 << 29) &&\r\n(tmp & (0x1f << 24)) < (0x1d << 24)) {\r\nOUT_RING(tmp);\r\nj++;\r\n} else\r\nprintk("texture state dropped!!!\n");\r\n}\r\nif (j & 1)\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\n}\r\nstatic void i810EmitDestVerified(struct drm_device *dev,\r\nvolatile unsigned int *code)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\nunsigned int tmp;\r\nRING_LOCALS;\r\nBEGIN_LP_RING(I810_DEST_SETUP_SIZE + 2);\r\ntmp = code[I810_DESTREG_DI1];\r\nif (tmp == dev_priv->front_di1 || tmp == dev_priv->back_di1) {\r\nOUT_RING(CMD_OP_DESTBUFFER_INFO);\r\nOUT_RING(tmp);\r\n} else\r\nDRM_DEBUG("bad di1 %x (allow %x or %x)\n",\r\ntmp, dev_priv->front_di1, dev_priv->back_di1);\r\nOUT_RING(CMD_OP_Z_BUFFER_INFO);\r\nOUT_RING(dev_priv->zi1);\r\nOUT_RING(GFX_OP_DESTBUFFER_VARS);\r\nOUT_RING(code[I810_DESTREG_DV1]);\r\nOUT_RING(GFX_OP_DRAWRECT_INFO);\r\nOUT_RING(code[I810_DESTREG_DR1]);\r\nOUT_RING(code[I810_DESTREG_DR2]);\r\nOUT_RING(code[I810_DESTREG_DR3]);\r\nOUT_RING(code[I810_DESTREG_DR4]);\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\n}\r\nstatic void i810EmitState(struct drm_device *dev)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\ndrm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nunsigned int dirty = sarea_priv->dirty;\r\nDRM_DEBUG("%x\n", dirty);\r\nif (dirty & I810_UPLOAD_BUFFERS) {\r\ni810EmitDestVerified(dev, sarea_priv->BufferState);\r\nsarea_priv->dirty &= ~I810_UPLOAD_BUFFERS;\r\n}\r\nif (dirty & I810_UPLOAD_CTX) {\r\ni810EmitContextVerified(dev, sarea_priv->ContextState);\r\nsarea_priv->dirty &= ~I810_UPLOAD_CTX;\r\n}\r\nif (dirty & I810_UPLOAD_TEX0) {\r\ni810EmitTexVerified(dev, sarea_priv->TexState[0]);\r\nsarea_priv->dirty &= ~I810_UPLOAD_TEX0;\r\n}\r\nif (dirty & I810_UPLOAD_TEX1) {\r\ni810EmitTexVerified(dev, sarea_priv->TexState[1]);\r\nsarea_priv->dirty &= ~I810_UPLOAD_TEX1;\r\n}\r\n}\r\nstatic void i810_dma_dispatch_clear(struct drm_device *dev, int flags,\r\nunsigned int clear_color,\r\nunsigned int clear_zval)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\ndrm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nint nbox = sarea_priv->nbox;\r\nstruct drm_clip_rect *pbox = sarea_priv->boxes;\r\nint pitch = dev_priv->pitch;\r\nint cpp = 2;\r\nint i;\r\nRING_LOCALS;\r\nif (dev_priv->current_page == 1) {\r\nunsigned int tmp = flags;\r\nflags &= ~(I810_FRONT | I810_BACK);\r\nif (tmp & I810_FRONT)\r\nflags |= I810_BACK;\r\nif (tmp & I810_BACK)\r\nflags |= I810_FRONT;\r\n}\r\ni810_kernel_lost_context(dev);\r\nif (nbox > I810_NR_SAREA_CLIPRECTS)\r\nnbox = I810_NR_SAREA_CLIPRECTS;\r\nfor (i = 0; i < nbox; i++, pbox++) {\r\nunsigned int x = pbox->x1;\r\nunsigned int y = pbox->y1;\r\nunsigned int width = (pbox->x2 - x) * cpp;\r\nunsigned int height = pbox->y2 - y;\r\nunsigned int start = y * pitch + x * cpp;\r\nif (pbox->x1 > pbox->x2 ||\r\npbox->y1 > pbox->y2 ||\r\npbox->x2 > dev_priv->w || pbox->y2 > dev_priv->h)\r\ncontinue;\r\nif (flags & I810_FRONT) {\r\nBEGIN_LP_RING(6);\r\nOUT_RING(BR00_BITBLT_CLIENT | BR00_OP_COLOR_BLT | 0x3);\r\nOUT_RING(BR13_SOLID_PATTERN | (0xF0 << 16) | pitch);\r\nOUT_RING((height << 16) | width);\r\nOUT_RING(start);\r\nOUT_RING(clear_color);\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\n}\r\nif (flags & I810_BACK) {\r\nBEGIN_LP_RING(6);\r\nOUT_RING(BR00_BITBLT_CLIENT | BR00_OP_COLOR_BLT | 0x3);\r\nOUT_RING(BR13_SOLID_PATTERN | (0xF0 << 16) | pitch);\r\nOUT_RING((height << 16) | width);\r\nOUT_RING(dev_priv->back_offset + start);\r\nOUT_RING(clear_color);\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\n}\r\nif (flags & I810_DEPTH) {\r\nBEGIN_LP_RING(6);\r\nOUT_RING(BR00_BITBLT_CLIENT | BR00_OP_COLOR_BLT | 0x3);\r\nOUT_RING(BR13_SOLID_PATTERN | (0xF0 << 16) | pitch);\r\nOUT_RING((height << 16) | width);\r\nOUT_RING(dev_priv->depth_offset + start);\r\nOUT_RING(clear_zval);\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\n}\r\n}\r\n}\r\nstatic void i810_dma_dispatch_swap(struct drm_device *dev)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\ndrm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nint nbox = sarea_priv->nbox;\r\nstruct drm_clip_rect *pbox = sarea_priv->boxes;\r\nint pitch = dev_priv->pitch;\r\nint cpp = 2;\r\nint i;\r\nRING_LOCALS;\r\nDRM_DEBUG("swapbuffers\n");\r\ni810_kernel_lost_context(dev);\r\nif (nbox > I810_NR_SAREA_CLIPRECTS)\r\nnbox = I810_NR_SAREA_CLIPRECTS;\r\nfor (i = 0; i < nbox; i++, pbox++) {\r\nunsigned int w = pbox->x2 - pbox->x1;\r\nunsigned int h = pbox->y2 - pbox->y1;\r\nunsigned int dst = pbox->x1 * cpp + pbox->y1 * pitch;\r\nunsigned int start = dst;\r\nif (pbox->x1 > pbox->x2 ||\r\npbox->y1 > pbox->y2 ||\r\npbox->x2 > dev_priv->w || pbox->y2 > dev_priv->h)\r\ncontinue;\r\nBEGIN_LP_RING(6);\r\nOUT_RING(BR00_BITBLT_CLIENT | BR00_OP_SRC_COPY_BLT | 0x4);\r\nOUT_RING(pitch | (0xCC << 16));\r\nOUT_RING((h << 16) | (w * cpp));\r\nif (dev_priv->current_page == 0)\r\nOUT_RING(dev_priv->front_offset + start);\r\nelse\r\nOUT_RING(dev_priv->back_offset + start);\r\nOUT_RING(pitch);\r\nif (dev_priv->current_page == 0)\r\nOUT_RING(dev_priv->back_offset + start);\r\nelse\r\nOUT_RING(dev_priv->front_offset + start);\r\nADVANCE_LP_RING();\r\n}\r\n}\r\nstatic void i810_dma_dispatch_vertex(struct drm_device *dev,\r\nstruct drm_buf *buf, int discard, int used)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\ndrm_i810_buf_priv_t *buf_priv = buf->dev_private;\r\ndrm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nstruct drm_clip_rect *box = sarea_priv->boxes;\r\nint nbox = sarea_priv->nbox;\r\nunsigned long address = (unsigned long)buf->bus_address;\r\nunsigned long start = address - dev->agp->base;\r\nint i = 0;\r\nRING_LOCALS;\r\ni810_kernel_lost_context(dev);\r\nif (nbox > I810_NR_SAREA_CLIPRECTS)\r\nnbox = I810_NR_SAREA_CLIPRECTS;\r\nif (used > 4 * 1024)\r\nused = 0;\r\nif (sarea_priv->dirty)\r\ni810EmitState(dev);\r\nif (buf_priv->currently_mapped == I810_BUF_MAPPED) {\r\nunsigned int prim = (sarea_priv->vertex_prim & PR_MASK);\r\n*(u32 *) buf_priv->kernel_virtual =\r\n((GFX_OP_PRIMITIVE | prim | ((used / 4) - 2)));\r\nif (used & 4) {\r\n*(u32 *) ((char *) buf_priv->kernel_virtual + used) = 0;\r\nused += 4;\r\n}\r\ni810_unmap_buffer(buf);\r\n}\r\nif (used) {\r\ndo {\r\nif (i < nbox) {\r\nBEGIN_LP_RING(4);\r\nOUT_RING(GFX_OP_SCISSOR | SC_UPDATE_SCISSOR |\r\nSC_ENABLE);\r\nOUT_RING(GFX_OP_SCISSOR_INFO);\r\nOUT_RING(box[i].x1 | (box[i].y1 << 16));\r\nOUT_RING((box[i].x2 -\r\n1) | ((box[i].y2 - 1) << 16));\r\nADVANCE_LP_RING();\r\n}\r\nBEGIN_LP_RING(4);\r\nOUT_RING(CMD_OP_BATCH_BUFFER);\r\nOUT_RING(start | BB1_PROTECTED);\r\nOUT_RING(start + used - 4);\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\n} while (++i < nbox);\r\n}\r\nif (discard) {\r\ndev_priv->counter++;\r\n(void)cmpxchg(buf_priv->in_use, I810_BUF_CLIENT,\r\nI810_BUF_HARDWARE);\r\nBEGIN_LP_RING(8);\r\nOUT_RING(CMD_STORE_DWORD_IDX);\r\nOUT_RING(20);\r\nOUT_RING(dev_priv->counter);\r\nOUT_RING(CMD_STORE_DWORD_IDX);\r\nOUT_RING(buf_priv->my_use_idx);\r\nOUT_RING(I810_BUF_FREE);\r\nOUT_RING(CMD_REPORT_HEAD);\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\n}\r\n}\r\nstatic void i810_dma_dispatch_flip(struct drm_device *dev)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\nint pitch = dev_priv->pitch;\r\nRING_LOCALS;\r\nDRM_DEBUG("page=%d pfCurrentPage=%d\n",\r\ndev_priv->current_page,\r\ndev_priv->sarea_priv->pf_current_page);\r\ni810_kernel_lost_context(dev);\r\nBEGIN_LP_RING(2);\r\nOUT_RING(INST_PARSER_CLIENT | INST_OP_FLUSH | INST_FLUSH_MAP_CACHE);\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\nBEGIN_LP_RING(I810_DEST_SETUP_SIZE + 2);\r\nOUT_RING(CMD_OP_FRONTBUFFER_INFO | (pitch << 5) );\r\nif (dev_priv->current_page == 0) {\r\nOUT_RING(dev_priv->back_offset);\r\ndev_priv->current_page = 1;\r\n} else {\r\nOUT_RING(dev_priv->front_offset);\r\ndev_priv->current_page = 0;\r\n}\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\nBEGIN_LP_RING(2);\r\nOUT_RING(CMD_OP_WAIT_FOR_EVENT | WAIT_FOR_PLANE_A_FLIP);\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\ndev_priv->sarea_priv->pf_current_page = dev_priv->current_page;\r\n}\r\nstatic void i810_dma_quiescent(struct drm_device *dev)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\nRING_LOCALS;\r\ni810_kernel_lost_context(dev);\r\nBEGIN_LP_RING(4);\r\nOUT_RING(INST_PARSER_CLIENT | INST_OP_FLUSH | INST_FLUSH_MAP_CACHE);\r\nOUT_RING(CMD_REPORT_HEAD);\r\nOUT_RING(0);\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\ni810_wait_ring(dev, dev_priv->ring.Size - 8);\r\n}\r\nstatic int i810_flush_queue(struct drm_device *dev)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\nstruct drm_device_dma *dma = dev->dma;\r\nint i, ret = 0;\r\nRING_LOCALS;\r\ni810_kernel_lost_context(dev);\r\nBEGIN_LP_RING(2);\r\nOUT_RING(CMD_REPORT_HEAD);\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\ni810_wait_ring(dev, dev_priv->ring.Size - 8);\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nstruct drm_buf *buf = dma->buflist[i];\r\ndrm_i810_buf_priv_t *buf_priv = buf->dev_private;\r\nint used = cmpxchg(buf_priv->in_use, I810_BUF_HARDWARE,\r\nI810_BUF_FREE);\r\nif (used == I810_BUF_HARDWARE)\r\nDRM_DEBUG("reclaimed from HARDWARE\n");\r\nif (used == I810_BUF_CLIENT)\r\nDRM_DEBUG("still on client\n");\r\n}\r\nreturn ret;\r\n}\r\nvoid i810_driver_reclaim_buffers(struct drm_device *dev,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\nint i;\r\nif (!dma)\r\nreturn;\r\nif (!dev->dev_private)\r\nreturn;\r\nif (!dma->buflist)\r\nreturn;\r\ni810_flush_queue(dev);\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nstruct drm_buf *buf = dma->buflist[i];\r\ndrm_i810_buf_priv_t *buf_priv = buf->dev_private;\r\nif (buf->file_priv == file_priv && buf_priv) {\r\nint used = cmpxchg(buf_priv->in_use, I810_BUF_CLIENT,\r\nI810_BUF_FREE);\r\nif (used == I810_BUF_CLIENT)\r\nDRM_DEBUG("reclaimed from client\n");\r\nif (buf_priv->currently_mapped == I810_BUF_MAPPED)\r\nbuf_priv->currently_mapped = I810_BUF_UNMAPPED;\r\n}\r\n}\r\n}\r\nstatic int i810_flush_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\ni810_flush_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int i810_dma_vertex(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\ndrm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;\r\nu32 *hw_status = dev_priv->hw_status_page;\r\ndrm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *)\r\ndev_priv->sarea_priv;\r\ndrm_i810_vertex_t *vertex = data;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDRM_DEBUG("idx %d used %d discard %d\n",\r\nvertex->idx, vertex->used, vertex->discard);\r\nif (vertex->idx < 0 || vertex->idx > dma->buf_count)\r\nreturn -EINVAL;\r\ni810_dma_dispatch_vertex(dev,\r\ndma->buflist[vertex->idx],\r\nvertex->discard, vertex->used);\r\nsarea_priv->last_enqueue = dev_priv->counter - 1;\r\nsarea_priv->last_dispatch = (int)hw_status[5];\r\nreturn 0;\r\n}\r\nstatic int i810_clear_bufs(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_i810_clear_t *clear = data;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (!dev->dev_private)\r\nreturn -EINVAL;\r\ni810_dma_dispatch_clear(dev, clear->flags,\r\nclear->clear_color, clear->clear_depth);\r\nreturn 0;\r\n}\r\nstatic int i810_swap_bufs(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\ni810_dma_dispatch_swap(dev);\r\nreturn 0;\r\n}\r\nstatic int i810_getage(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;\r\nu32 *hw_status = dev_priv->hw_status_page;\r\ndrm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *)\r\ndev_priv->sarea_priv;\r\nsarea_priv->last_dispatch = (int)hw_status[5];\r\nreturn 0;\r\n}\r\nstatic int i810_getbuf(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nint retcode = 0;\r\ndrm_i810_dma_t *d = data;\r\ndrm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;\r\nu32 *hw_status = dev_priv->hw_status_page;\r\ndrm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *)\r\ndev_priv->sarea_priv;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nd->granted = 0;\r\nretcode = i810_dma_get_buffer(dev, d, file_priv);\r\nDRM_DEBUG("i810_dma: %d returning %d, granted = %d\n",\r\ntask_pid_nr(current), retcode, d->granted);\r\nsarea_priv->last_dispatch = (int)hw_status[5];\r\nreturn retcode;\r\n}\r\nstatic int i810_copybuf(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nreturn 0;\r\n}\r\nstatic int i810_docopy(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nreturn 0;\r\n}\r\nstatic void i810_dma_dispatch_mc(struct drm_device *dev, struct drm_buf *buf, int used,\r\nunsigned int last_render)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\ndrm_i810_buf_priv_t *buf_priv = buf->dev_private;\r\ndrm_i810_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nunsigned long address = (unsigned long)buf->bus_address;\r\nunsigned long start = address - dev->agp->base;\r\nint u;\r\nRING_LOCALS;\r\ni810_kernel_lost_context(dev);\r\nu = cmpxchg(buf_priv->in_use, I810_BUF_CLIENT, I810_BUF_HARDWARE);\r\nif (u != I810_BUF_CLIENT)\r\nDRM_DEBUG("MC found buffer that isn't mine!\n");\r\nif (used > 4 * 1024)\r\nused = 0;\r\nsarea_priv->dirty = 0x7f;\r\nDRM_DEBUG("addr 0x%lx, used 0x%x\n", address, used);\r\ndev_priv->counter++;\r\nDRM_DEBUG("dispatch counter : %ld\n", dev_priv->counter);\r\nDRM_DEBUG("start : %lx\n", start);\r\nDRM_DEBUG("used : %d\n", used);\r\nDRM_DEBUG("start + used - 4 : %ld\n", start + used - 4);\r\nif (buf_priv->currently_mapped == I810_BUF_MAPPED) {\r\nif (used & 4) {\r\n*(u32 *) ((char *) buf_priv->virtual + used) = 0;\r\nused += 4;\r\n}\r\ni810_unmap_buffer(buf);\r\n}\r\nBEGIN_LP_RING(4);\r\nOUT_RING(CMD_OP_BATCH_BUFFER);\r\nOUT_RING(start | BB1_PROTECTED);\r\nOUT_RING(start + used - 4);\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\nBEGIN_LP_RING(8);\r\nOUT_RING(CMD_STORE_DWORD_IDX);\r\nOUT_RING(buf_priv->my_use_idx);\r\nOUT_RING(I810_BUF_FREE);\r\nOUT_RING(0);\r\nOUT_RING(CMD_STORE_DWORD_IDX);\r\nOUT_RING(16);\r\nOUT_RING(last_render);\r\nOUT_RING(0);\r\nADVANCE_LP_RING();\r\n}\r\nstatic int i810_dma_mc(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\ndrm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;\r\nu32 *hw_status = dev_priv->hw_status_page;\r\ndrm_i810_sarea_t *sarea_priv = (drm_i810_sarea_t *)\r\ndev_priv->sarea_priv;\r\ndrm_i810_mc_t *mc = data;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (mc->idx >= dma->buf_count || mc->idx < 0)\r\nreturn -EINVAL;\r\ni810_dma_dispatch_mc(dev, dma->buflist[mc->idx], mc->used,\r\nmc->last_render);\r\nsarea_priv->last_enqueue = dev_priv->counter - 1;\r\nsarea_priv->last_dispatch = (int)hw_status[5];\r\nreturn 0;\r\n}\r\nstatic int i810_rstatus(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;\r\nreturn (int)(((u32 *) (dev_priv->hw_status_page))[4]);\r\n}\r\nstatic int i810_ov0_info(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;\r\ndrm_i810_overlay_t *ov = data;\r\nov->offset = dev_priv->overlay_offset;\r\nov->physical = dev_priv->overlay_physical;\r\nreturn 0;\r\n}\r\nstatic int i810_fstatus(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nreturn I810_READ(0x30008);\r\n}\r\nstatic int i810_ov0_flip(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_i810_private_t *dev_priv = (drm_i810_private_t *) dev->dev_private;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nI810_WRITE(0x30000, dev_priv->overlay_physical | 0x80000000);\r\nreturn 0;\r\n}\r\nstatic void i810_do_init_pageflip(struct drm_device *dev)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\nDRM_DEBUG("\n");\r\ndev_priv->page_flipping = 1;\r\ndev_priv->current_page = 0;\r\ndev_priv->sarea_priv->pf_current_page = dev_priv->current_page;\r\n}\r\nstatic int i810_do_cleanup_pageflip(struct drm_device *dev)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\nDRM_DEBUG("\n");\r\nif (dev_priv->current_page != 0)\r\ni810_dma_dispatch_flip(dev);\r\ndev_priv->page_flipping = 0;\r\nreturn 0;\r\n}\r\nstatic int i810_flip_bufs(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (!dev_priv->page_flipping)\r\ni810_do_init_pageflip(dev);\r\ni810_dma_dispatch_flip(dev);\r\nreturn 0;\r\n}\r\nint i810_driver_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nif (!dev->agp)\r\nreturn -EINVAL;\r\npci_set_master(dev->pdev);\r\nreturn 0;\r\n}\r\nvoid i810_driver_lastclose(struct drm_device *dev)\r\n{\r\ni810_dma_cleanup(dev);\r\n}\r\nvoid i810_driver_preclose(struct drm_device *dev, struct drm_file *file_priv)\r\n{\r\nif (dev->dev_private) {\r\ndrm_i810_private_t *dev_priv = dev->dev_private;\r\nif (dev_priv->page_flipping)\r\ni810_do_cleanup_pageflip(dev);\r\n}\r\nif (file_priv->master && file_priv->master->lock.hw_lock) {\r\ndrm_idlelock_take(&file_priv->master->lock);\r\ni810_driver_reclaim_buffers(dev, file_priv);\r\ndrm_idlelock_release(&file_priv->master->lock);\r\n} else {\r\ni810_driver_reclaim_buffers(dev, file_priv);\r\n}\r\n}\r\nint i810_driver_dma_quiescent(struct drm_device *dev)\r\n{\r\ni810_dma_quiescent(dev);\r\nreturn 0;\r\n}\r\nint i810_driver_device_is_agp(struct drm_device *dev)\r\n{\r\nreturn 1;\r\n}
