int drm_name_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_minor *minor = node->minor;\r\nstruct drm_device *dev = minor->dev;\r\nstruct drm_master *master = minor->master;\r\nconst char *bus_name;\r\nif (!master)\r\nreturn 0;\r\nbus_name = dev->driver->bus->get_name(dev);\r\nif (master->unique) {\r\nseq_printf(m, "%s %s %s\n",\r\nbus_name,\r\ndev_name(dev->dev), master->unique);\r\n} else {\r\nseq_printf(m, "%s %s\n",\r\nbus_name, dev_name(dev->dev));\r\n}\r\nreturn 0;\r\n}\r\nint drm_vm_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct drm_local_map *map;\r\nstruct drm_map_list *r_list;\r\nconst char *types[] = { "FB", "REG", "SHM", "AGP", "SG", "PCI" };\r\nconst char *type;\r\nint i;\r\nmutex_lock(&dev->struct_mutex);\r\nseq_printf(m, "slot offset size type flags address mtrr\n\n");\r\ni = 0;\r\nlist_for_each_entry(r_list, &dev->maplist, head) {\r\nmap = r_list->map;\r\nif (!map)\r\ncontinue;\r\nif (map->type < 0 || map->type > 5)\r\ntype = "??";\r\nelse\r\ntype = types[map->type];\r\nseq_printf(m, "%4d 0x%016llx 0x%08lx %4.4s 0x%02x 0x%08lx ",\r\ni,\r\n(unsigned long long)map->offset,\r\nmap->size, type, map->flags,\r\n(unsigned long) r_list->user_token);\r\nif (map->mtrr < 0)\r\nseq_printf(m, "none\n");\r\nelse\r\nseq_printf(m, "%4d\n", map->mtrr);\r\ni++;\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nint drm_bufs_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct drm_device_dma *dma;\r\nint i, seg_pages;\r\nmutex_lock(&dev->struct_mutex);\r\ndma = dev->dma;\r\nif (!dma) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nseq_printf(m, " o size count free segs pages kB\n\n");\r\nfor (i = 0; i <= DRM_MAX_ORDER; i++) {\r\nif (dma->bufs[i].buf_count) {\r\nseg_pages = dma->bufs[i].seg_count * (1 << dma->bufs[i].page_order);\r\nseq_printf(m, "%2d %8d %5d %5d %5d %5d %5ld\n",\r\ni,\r\ndma->bufs[i].buf_size,\r\ndma->bufs[i].buf_count,\r\natomic_read(&dma->bufs[i].freelist.count),\r\ndma->bufs[i].seg_count,\r\nseg_pages,\r\nseg_pages * PAGE_SIZE / 1024);\r\n}\r\n}\r\nseq_printf(m, "\n");\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nif (i && !(i % 32))\r\nseq_printf(m, "\n");\r\nseq_printf(m, " %d", dma->buflist[i]->list);\r\n}\r\nseq_printf(m, "\n");\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nint drm_vblank_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nint crtc;\r\nmutex_lock(&dev->struct_mutex);\r\nfor (crtc = 0; crtc < dev->num_crtcs; crtc++) {\r\nseq_printf(m, "CRTC %d enable: %d\n",\r\ncrtc, atomic_read(&dev->vblank[crtc].refcount));\r\nseq_printf(m, "CRTC %d counter: %d\n",\r\ncrtc, drm_vblank_count(dev, crtc));\r\nseq_printf(m, "CRTC %d last wait: %d\n",\r\ncrtc, dev->vblank[crtc].last_wait);\r\nseq_printf(m, "CRTC %d in modeset: %d\n",\r\ncrtc, dev->vblank[crtc].inmodeset);\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nint drm_clients_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct drm_file *priv;\r\nmutex_lock(&dev->struct_mutex);\r\nseq_printf(m, "a dev pid uid magic\n\n");\r\nlist_for_each_entry(priv, &dev->filelist, lhead) {\r\nseq_printf(m, "%c %3d %5d %5d %10u\n",\r\npriv->authenticated ? 'y' : 'n',\r\npriv->minor->index,\r\npid_vnr(priv->pid),\r\nfrom_kuid_munged(seq_user_ns(m), priv->uid),\r\npriv->magic);\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nstatic int drm_gem_one_name_info(int id, void *ptr, void *data)\r\n{\r\nstruct drm_gem_object *obj = ptr;\r\nstruct seq_file *m = data;\r\nseq_printf(m, "%6d %8zd %7d %8d\n",\r\nobj->name, obj->size,\r\nobj->handle_count,\r\natomic_read(&obj->refcount.refcount));\r\nreturn 0;\r\n}\r\nint drm_gem_name_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nseq_printf(m, " name size handles refcount\n");\r\nmutex_lock(&dev->object_name_lock);\r\nidr_for_each(&dev->object_name_idr, drm_gem_one_name_info, m);\r\nmutex_unlock(&dev->object_name_lock);\r\nreturn 0;\r\n}\r\nint drm_vma_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct drm_vma_entry *pt;\r\nstruct vm_area_struct *vma;\r\nunsigned long vma_count = 0;\r\n#if defined(__i386__)\r\nunsigned int pgprot;\r\n#endif\r\nmutex_lock(&dev->struct_mutex);\r\nlist_for_each_entry(pt, &dev->vmalist, head)\r\nvma_count++;\r\nseq_printf(m, "vma use count: %lu, high_memory = %pK, 0x%pK\n",\r\nvma_count, high_memory,\r\n(void *)(unsigned long)virt_to_phys(high_memory));\r\nlist_for_each_entry(pt, &dev->vmalist, head) {\r\nvma = pt->vma;\r\nif (!vma)\r\ncontinue;\r\nseq_printf(m,\r\n"\n%5d 0x%pK-0x%pK %c%c%c%c%c%c 0x%08lx000",\r\npt->pid,\r\n(void *)vma->vm_start, (void *)vma->vm_end,\r\nvma->vm_flags & VM_READ ? 'r' : '-',\r\nvma->vm_flags & VM_WRITE ? 'w' : '-',\r\nvma->vm_flags & VM_EXEC ? 'x' : '-',\r\nvma->vm_flags & VM_MAYSHARE ? 's' : 'p',\r\nvma->vm_flags & VM_LOCKED ? 'l' : '-',\r\nvma->vm_flags & VM_IO ? 'i' : '-',\r\nvma->vm_pgoff);\r\n#if defined(__i386__)\r\npgprot = pgprot_val(vma->vm_page_prot);\r\nseq_printf(m, " %c%c%c%c%c%c%c%c%c",\r\npgprot & _PAGE_PRESENT ? 'p' : '-',\r\npgprot & _PAGE_RW ? 'w' : 'r',\r\npgprot & _PAGE_USER ? 'u' : 's',\r\npgprot & _PAGE_PWT ? 't' : 'b',\r\npgprot & _PAGE_PCD ? 'u' : 'c',\r\npgprot & _PAGE_ACCESSED ? 'a' : '-',\r\npgprot & _PAGE_DIRTY ? 'd' : '-',\r\npgprot & _PAGE_PSE ? 'm' : 'k',\r\npgprot & _PAGE_GLOBAL ? 'g' : 'l');\r\n#endif\r\nseq_printf(m, "\n");\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}
