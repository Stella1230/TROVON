static void ts_reset_encoder(struct saa7134_dev* dev)\r\n{\r\nif (!dev->empress_started)\r\nreturn;\r\nsaa_writeb(SAA7134_SPECIAL_MODE, 0x00);\r\nmsleep(10);\r\nsaa_writeb(SAA7134_SPECIAL_MODE, 0x01);\r\nmsleep(100);\r\ndev->empress_started = 0;\r\n}\r\nstatic int ts_init_encoder(struct saa7134_dev* dev)\r\n{\r\nu32 leading_null_bytes = 0;\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_BEHOLD_M6:\r\ncase SAA7134_BOARD_BEHOLD_M63:\r\ncase SAA7134_BOARD_BEHOLD_M6_EXTRA:\r\nleading_null_bytes = 1;\r\nbreak;\r\n}\r\nts_reset_encoder(dev);\r\nsaa_call_all(dev, core, init, leading_null_bytes);\r\ndev->empress_started = 1;\r\nreturn 0;\r\n}\r\nstatic int ts_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct saa7134_fh *fh;\r\nfh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (NULL == fh)\r\nreturn -ENOMEM;\r\nv4l2_fh_init(&fh->fh, vdev);\r\nfile->private_data = fh;\r\nfh->is_empress = true;\r\nv4l2_fh_add(&fh->fh);\r\nsaa_writeb(SAA7134_AUDIO_MUTE_CTRL,\r\nsaa_readb(SAA7134_AUDIO_MUTE_CTRL) & ~(1 << 6));\r\nreturn 0;\r\n}\r\nstatic int ts_release(struct file *file)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct saa7134_fh *fh = file->private_data;\r\nif (res_check(fh, RESOURCE_EMPRESS)) {\r\nvideobuf_stop(&dev->empress_tsq);\r\nvideobuf_mmap_free(&dev->empress_tsq);\r\nts_reset_encoder(dev);\r\nsaa_writeb(SAA7134_AUDIO_MUTE_CTRL,\r\nsaa_readb(SAA7134_AUDIO_MUTE_CTRL) | (1 << 6));\r\n}\r\nv4l2_fh_del(&fh->fh);\r\nv4l2_fh_exit(&fh->fh);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nts_read(struct file *file, char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nif (res_locked(dev, RESOURCE_EMPRESS))\r\nreturn -EBUSY;\r\nif (!dev->empress_started)\r\nts_init_encoder(dev);\r\nreturn videobuf_read_stream(&dev->empress_tsq,\r\ndata, count, ppos, 0,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic unsigned int\r\nts_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nunsigned long req_events = poll_requested_events(wait);\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct saa7134_fh *fh = file->private_data;\r\nunsigned int rc = 0;\r\nif (v4l2_event_pending(&fh->fh))\r\nrc = POLLPRI;\r\nelse if (req_events & POLLPRI)\r\npoll_wait(file, &fh->fh.wait, wait);\r\nreturn rc | videobuf_poll_stream(file, &dev->empress_tsq, wait);\r\n}\r\nstatic int\r\nts_mmap(struct file *file, struct vm_area_struct * vma)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nreturn videobuf_mmap_mapper(&dev->empress_tsq, vma);\r\n}\r\nstatic int empress_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, "MPEG TS", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nreturn 0;\r\n}\r\nstatic int empress_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nsaa_call_all(dev, video, g_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(&f->fmt.pix, &mbus_fmt);\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.sizeimage = TS_PACKET_SIZE * dev->ts.nr_packets;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int empress_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nv4l2_fill_mbus_format(&mbus_fmt, &f->fmt.pix, V4L2_MBUS_FMT_FIXED);\r\nsaa_call_all(dev, video, s_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(&f->fmt.pix, &mbus_fmt);\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.sizeimage = TS_PACKET_SIZE * dev->ts.nr_packets;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int empress_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nv4l2_fill_mbus_format(&mbus_fmt, &f->fmt.pix, V4L2_MBUS_FMT_FIXED);\r\nsaa_call_all(dev, video, try_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(&f->fmt.pix, &mbus_fmt);\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.sizeimage = TS_PACKET_SIZE * dev->ts.nr_packets;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic void empress_signal_update(struct work_struct *work)\r\n{\r\nstruct saa7134_dev* dev =\r\ncontainer_of(work, struct saa7134_dev, empress_workqueue);\r\nif (dev->nosignal) {\r\ndprintk("no video signal\n");\r\n} else {\r\ndprintk("video signal acquired\n");\r\n}\r\n}\r\nstatic void empress_signal_change(struct saa7134_dev *dev)\r\n{\r\nschedule_work(&dev->empress_workqueue);\r\n}\r\nstatic bool empress_ctrl_filter(const struct v4l2_ctrl *ctrl)\r\n{\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncase V4L2_CID_HUE:\r\ncase V4L2_CID_CONTRAST:\r\ncase V4L2_CID_SATURATION:\r\ncase V4L2_CID_AUDIO_MUTE:\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ncase V4L2_CID_PRIVATE_INVERT:\r\ncase V4L2_CID_PRIVATE_AUTOMUTE:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int empress_init(struct saa7134_dev *dev)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &dev->empress_ctrl_handler;\r\nint err;\r\ndprintk("%s: %s\n",dev->name,__func__);\r\ndev->empress_dev = video_device_alloc();\r\nif (NULL == dev->empress_dev)\r\nreturn -ENOMEM;\r\n*(dev->empress_dev) = saa7134_empress_template;\r\ndev->empress_dev->v4l2_dev = &dev->v4l2_dev;\r\ndev->empress_dev->release = video_device_release;\r\nsnprintf(dev->empress_dev->name, sizeof(dev->empress_dev->name),\r\n"%s empress (%s)", dev->name,\r\nsaa7134_boards[dev->board].name);\r\nset_bit(V4L2_FL_USE_FH_PRIO, &dev->empress_dev->flags);\r\nv4l2_ctrl_handler_init(hdl, 21);\r\nv4l2_ctrl_add_handler(hdl, &dev->ctrl_handler, empress_ctrl_filter);\r\nif (dev->empress_sd)\r\nv4l2_ctrl_add_handler(hdl, dev->empress_sd->ctrl_handler, NULL);\r\nif (hdl->error) {\r\nvideo_device_release(dev->empress_dev);\r\nreturn hdl->error;\r\n}\r\ndev->empress_dev->ctrl_handler = hdl;\r\nINIT_WORK(&dev->empress_workqueue, empress_signal_update);\r\nvideo_set_drvdata(dev->empress_dev, dev);\r\nerr = video_register_device(dev->empress_dev,VFL_TYPE_GRABBER,\r\nempress_nr[dev->nr]);\r\nif (err < 0) {\r\nprintk(KERN_INFO "%s: can't register video device\n",\r\ndev->name);\r\nvideo_device_release(dev->empress_dev);\r\ndev->empress_dev = NULL;\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "%s: registered device %s [mpeg]\n",\r\ndev->name, video_device_node_name(dev->empress_dev));\r\nvideobuf_queue_sg_init(&dev->empress_tsq, &saa7134_ts_qops,\r\n&dev->pci->dev, &dev->slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_ALTERNATE,\r\nsizeof(struct saa7134_buf),\r\ndev, NULL);\r\nempress_signal_update(&dev->empress_workqueue);\r\nreturn 0;\r\n}\r\nstatic int empress_fini(struct saa7134_dev *dev)\r\n{\r\ndprintk("%s: %s\n",dev->name,__func__);\r\nif (NULL == dev->empress_dev)\r\nreturn 0;\r\nflush_work(&dev->empress_workqueue);\r\nvideo_unregister_device(dev->empress_dev);\r\nv4l2_ctrl_handler_free(&dev->empress_ctrl_handler);\r\ndev->empress_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init empress_register(void)\r\n{\r\nreturn saa7134_ts_register(&empress_ops);\r\n}\r\nstatic void __exit empress_unregister(void)\r\n{\r\nsaa7134_ts_unregister(&empress_ops);\r\n}
