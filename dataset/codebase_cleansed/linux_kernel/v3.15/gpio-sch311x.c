static inline struct sch311x_gpio_block *\r\nto_sch311x_gpio_block(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct sch311x_gpio_block, chip);\r\n}\r\nstatic inline int sch311x_sio_enter(int sio_config_port)\r\n{\r\nif (!request_muxed_region(sio_config_port, 2, DRV_NAME)) {\r\npr_err(DRV_NAME "I/O address 0x%04x already in use\n",\r\nsio_config_port);\r\nreturn -EBUSY;\r\n}\r\noutb(SIO_CONFIG_KEY_ENTER, sio_config_port);\r\nreturn 0;\r\n}\r\nstatic inline void sch311x_sio_exit(int sio_config_port)\r\n{\r\noutb(SIO_CONFIG_KEY_EXIT, sio_config_port);\r\nrelease_region(sio_config_port, 2);\r\n}\r\nstatic inline int sch311x_sio_inb(int sio_config_port, int reg)\r\n{\r\noutb(reg, sio_config_port);\r\nreturn inb(sio_config_port + 1);\r\n}\r\nstatic inline void sch311x_sio_outb(int sio_config_port, int reg, int val)\r\n{\r\noutb(reg, sio_config_port);\r\noutb(val, sio_config_port + 1);\r\n}\r\nstatic int sch311x_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct sch311x_gpio_block *block = to_sch311x_gpio_block(chip);\r\nif (block->config_regs[offset] == 0)\r\nreturn -ENODEV;\r\nif (!request_region(block->runtime_reg + block->config_regs[offset],\r\n1, DRV_NAME)) {\r\ndev_err(chip->dev, "Failed to request region 0x%04x.\n",\r\nblock->runtime_reg + block->config_regs[offset]);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sch311x_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct sch311x_gpio_block *block = to_sch311x_gpio_block(chip);\r\nif (block->config_regs[offset] == 0)\r\nreturn;\r\nrelease_region(block->runtime_reg + block->config_regs[offset], 1);\r\n}\r\nstatic int sch311x_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct sch311x_gpio_block *block = to_sch311x_gpio_block(chip);\r\nunsigned char data;\r\nspin_lock(&block->lock);\r\ndata = inb(block->runtime_reg + block->data_reg);\r\nspin_unlock(&block->lock);\r\nreturn !!(data & BIT(offset));\r\n}\r\nstatic void __sch311x_gpio_set(struct sch311x_gpio_block *block,\r\nunsigned offset, int value)\r\n{\r\nunsigned char data = inb(block->runtime_reg + block->data_reg);\r\nif (value)\r\ndata |= BIT(offset);\r\nelse\r\ndata &= ~BIT(offset);\r\noutb(data, block->runtime_reg + block->data_reg);\r\n}\r\nstatic void sch311x_gpio_set(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct sch311x_gpio_block *block = to_sch311x_gpio_block(chip);\r\nspin_lock(&block->lock);\r\n__sch311x_gpio_set(block, offset, value);\r\nspin_unlock(&block->lock);\r\n}\r\nstatic int sch311x_gpio_direction_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct sch311x_gpio_block *block = to_sch311x_gpio_block(chip);\r\nspin_lock(&block->lock);\r\noutb(SCH311X_GPIO_CONF_IN, block->runtime_reg +\r\nblock->config_regs[offset]);\r\nspin_unlock(&block->lock);\r\nreturn 0;\r\n}\r\nstatic int sch311x_gpio_direction_out(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct sch311x_gpio_block *block = to_sch311x_gpio_block(chip);\r\nspin_lock(&block->lock);\r\noutb(SCH311X_GPIO_CONF_OUT, block->runtime_reg +\r\nblock->config_regs[offset]);\r\n__sch311x_gpio_set(block, offset, value);\r\nspin_unlock(&block->lock);\r\nreturn 0;\r\n}\r\nstatic int sch311x_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct sch311x_pdev_data *pdata = pdev->dev.platform_data;\r\nstruct sch311x_gpio_priv *priv;\r\nstruct sch311x_gpio_block *block;\r\nint err, i;\r\nif (!request_region(pdata->runtime_reg + GP1, 6, DRV_NAME)) {\r\ndev_err(&pdev->dev, "Failed to request region 0x%04x-0x%04x.\n",\r\npdata->runtime_reg + GP1, pdata->runtime_reg + GP1 + 5);\r\nreturn -EBUSY;\r\n}\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, priv);\r\nfor (i = 0; i < ARRAY_SIZE(priv->blocks); i++) {\r\nblock = &priv->blocks[i];\r\nspin_lock_init(&block->lock);\r\nblock->chip.label = DRV_NAME;\r\nblock->chip.owner = THIS_MODULE;\r\nblock->chip.request = sch311x_gpio_request;\r\nblock->chip.free = sch311x_gpio_free;\r\nblock->chip.direction_input = sch311x_gpio_direction_in;\r\nblock->chip.direction_output = sch311x_gpio_direction_out;\r\nblock->chip.get = sch311x_gpio_get;\r\nblock->chip.set = sch311x_gpio_set;\r\nblock->chip.ngpio = 8;\r\nblock->chip.dev = &pdev->dev;\r\nblock->chip.base = sch311x_gpio_blocks[i].base;\r\nblock->config_regs = sch311x_gpio_blocks[i].config_regs;\r\nblock->data_reg = sch311x_gpio_blocks[i].data_reg;\r\nblock->runtime_reg = pdata->runtime_reg;\r\nerr = gpiochip_add(&block->chip);\r\nif (err < 0) {\r\ndev_err(&pdev->dev,\r\n"Could not register gpiochip, %d\n", err);\r\ngoto exit_err;\r\n}\r\ndev_info(&pdev->dev,\r\n"SMSC SCH311x GPIO block %d registered.\n", i);\r\n}\r\nreturn 0;\r\nexit_err:\r\nrelease_region(pdata->runtime_reg + GP1, 6);\r\nfor (--i; i >= 0; i--)\r\ngpiochip_remove(&priv->blocks[i].chip);\r\nreturn err;\r\n}\r\nstatic int sch311x_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct sch311x_pdev_data *pdata = pdev->dev.platform_data;\r\nstruct sch311x_gpio_priv *priv = platform_get_drvdata(pdev);\r\nint err, i;\r\nrelease_region(pdata->runtime_reg + GP1, 6);\r\nfor (i = 0; i < ARRAY_SIZE(priv->blocks); i++) {\r\nerr = gpiochip_remove(&priv->blocks[i].chip);\r\nif (err)\r\nreturn err;\r\ndev_info(&pdev->dev,\r\n"SMSC SCH311x GPIO block %d unregistered.\n", i);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init sch311x_detect(int sio_config_port, unsigned short *addr)\r\n{\r\nint err = 0, reg;\r\nunsigned short base_addr;\r\nunsigned char dev_id;\r\nerr = sch311x_sio_enter(sio_config_port);\r\nif (err)\r\nreturn err;\r\nreg = sch311x_sio_inb(sio_config_port, 0x20);\r\nif (!(reg == 0x7c || reg == 0x7d || reg == 0x7f)) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\ndev_id = reg == 0x7c ? 2 : reg == 0x7d ? 4 : 6;\r\nsch311x_sio_outb(sio_config_port, 0x07, 0x0a);\r\nif ((sch311x_sio_inb(sio_config_port, 0x30) & 0x01) == 0)\r\npr_info("Seems that LDN 0x0a is not active...\n");\r\nbase_addr = (sch311x_sio_inb(sio_config_port, 0x60) << 8) |\r\nsch311x_sio_inb(sio_config_port, 0x61);\r\nif (!base_addr) {\r\npr_err("Base address not set\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\n*addr = base_addr;\r\npr_info("Found an SMSC SCH311%d chip at 0x%04x\n", dev_id, base_addr);\r\nexit:\r\nsch311x_sio_exit(sio_config_port);\r\nreturn err;\r\n}\r\nstatic int __init sch311x_gpio_pdev_add(const unsigned short addr)\r\n{\r\nstruct sch311x_pdev_data pdata;\r\nint err;\r\npdata.runtime_reg = addr;\r\nsch311x_gpio_pdev = platform_device_alloc(DRV_NAME, -1);\r\nif (!sch311x_gpio_pdev)\r\nreturn -ENOMEM;\r\nerr = platform_device_add_data(sch311x_gpio_pdev,\r\n&pdata, sizeof(pdata));\r\nif (err) {\r\npr_err(DRV_NAME "Platform data allocation failed\n");\r\ngoto err;\r\n}\r\nerr = platform_device_add(sch311x_gpio_pdev);\r\nif (err) {\r\npr_err(DRV_NAME "Device addition failed\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nplatform_device_put(sch311x_gpio_pdev);\r\nreturn err;\r\n}\r\nstatic int __init sch311x_gpio_init(void)\r\n{\r\nint err, i;\r\nunsigned short addr = 0;\r\nfor (i = 0; i < ARRAY_SIZE(sch311x_ioports); i++)\r\nif (sch311x_detect(sch311x_ioports[i], &addr) == 0)\r\nbreak;\r\nif (!addr)\r\nreturn -ENODEV;\r\nerr = platform_driver_register(&sch311x_gpio_driver);\r\nif (err)\r\nreturn err;\r\nerr = sch311x_gpio_pdev_add(addr);\r\nif (err)\r\ngoto unreg_platform_driver;\r\nreturn 0;\r\nunreg_platform_driver:\r\nplatform_driver_unregister(&sch311x_gpio_driver);\r\nreturn err;\r\n}\r\nstatic void __exit sch311x_gpio_exit(void)\r\n{\r\nplatform_device_unregister(sch311x_gpio_pdev);\r\nplatform_driver_unregister(&sch311x_gpio_driver);\r\n}
