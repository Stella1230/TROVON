void sptlrpc_gc_add_sec(struct ptlrpc_sec *sec)\r\n{\r\nLASSERT(sec->ps_policy->sp_cops->gc_ctx);\r\nLASSERT(sec->ps_gc_interval > 0);\r\nLASSERT(list_empty(&sec->ps_gc_list));\r\nsec->ps_gc_next = cfs_time_current_sec() + sec->ps_gc_interval;\r\nspin_lock(&sec_gc_list_lock);\r\nlist_add_tail(&sec_gc_list, &sec->ps_gc_list);\r\nspin_unlock(&sec_gc_list_lock);\r\nCDEBUG(D_SEC, "added sec %p(%s)\n", sec, sec->ps_policy->sp_name);\r\n}\r\nvoid sptlrpc_gc_del_sec(struct ptlrpc_sec *sec)\r\n{\r\nif (list_empty(&sec->ps_gc_list))\r\nreturn;\r\nmight_sleep();\r\natomic_inc(&sec_gc_wait_del);\r\nspin_lock(&sec_gc_list_lock);\r\nlist_del_init(&sec->ps_gc_list);\r\nspin_unlock(&sec_gc_list_lock);\r\nmutex_lock(&sec_gc_mutex);\r\nmutex_unlock(&sec_gc_mutex);\r\natomic_dec(&sec_gc_wait_del);\r\nCDEBUG(D_SEC, "del sec %p(%s)\n", sec, sec->ps_policy->sp_name);\r\n}\r\nvoid sptlrpc_gc_add_ctx(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nLASSERT(list_empty(&ctx->cc_gc_chain));\r\nCDEBUG(D_SEC, "hand over ctx %p(%u->%s)\n",\r\nctx, ctx->cc_vcred.vc_uid, sec2target_str(ctx->cc_sec));\r\nspin_lock(&sec_gc_ctx_list_lock);\r\nlist_add(&ctx->cc_gc_chain, &sec_gc_ctx_list);\r\nspin_unlock(&sec_gc_ctx_list_lock);\r\nthread_add_flags(&sec_gc_thread, SVC_SIGNAL);\r\nwake_up(&sec_gc_thread.t_ctl_waitq);\r\n}\r\nstatic void sec_process_ctx_list(void)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx;\r\nspin_lock(&sec_gc_ctx_list_lock);\r\nwhile (!list_empty(&sec_gc_ctx_list)) {\r\nctx = list_entry(sec_gc_ctx_list.next,\r\nstruct ptlrpc_cli_ctx, cc_gc_chain);\r\nlist_del_init(&ctx->cc_gc_chain);\r\nspin_unlock(&sec_gc_ctx_list_lock);\r\nLASSERT(ctx->cc_sec);\r\nLASSERT(atomic_read(&ctx->cc_refcount) == 1);\r\nCDEBUG(D_SEC, "gc pick up ctx %p(%u->%s)\n",\r\nctx, ctx->cc_vcred.vc_uid, sec2target_str(ctx->cc_sec));\r\nsptlrpc_cli_ctx_put(ctx, 1);\r\nspin_lock(&sec_gc_ctx_list_lock);\r\n}\r\nspin_unlock(&sec_gc_ctx_list_lock);\r\n}\r\nstatic void sec_do_gc(struct ptlrpc_sec *sec)\r\n{\r\nLASSERT(sec->ps_policy->sp_cops->gc_ctx);\r\nif (unlikely(sec->ps_gc_next == 0)) {\r\nCDEBUG(D_SEC, "sec %p(%s) has 0 gc time\n",\r\nsec, sec->ps_policy->sp_name);\r\nreturn;\r\n}\r\nCDEBUG(D_SEC, "check on sec %p(%s)\n", sec, sec->ps_policy->sp_name);\r\nif (cfs_time_after(sec->ps_gc_next, cfs_time_current_sec()))\r\nreturn;\r\nsec->ps_policy->sp_cops->gc_ctx(sec);\r\nsec->ps_gc_next = cfs_time_current_sec() + sec->ps_gc_interval;\r\n}\r\nstatic int sec_gc_main(void *arg)\r\n{\r\nstruct ptlrpc_thread *thread = (struct ptlrpc_thread *) arg;\r\nstruct l_wait_info lwi;\r\nunshare_fs_struct();\r\nthread_set_flags(thread, SVC_RUNNING);\r\nwake_up(&thread->t_ctl_waitq);\r\nwhile (1) {\r\nstruct ptlrpc_sec *sec;\r\nthread_clear_flags(thread, SVC_SIGNAL);\r\nsec_process_ctx_list();\r\nagain:\r\nmutex_lock(&sec_gc_mutex);\r\nlist_for_each_entry(sec, &sec_gc_list, ps_gc_list) {\r\nif (atomic_read(&sec_gc_wait_del)) {\r\nCDEBUG(D_SEC, "deletion pending, start over\n");\r\nmutex_unlock(&sec_gc_mutex);\r\ngoto again;\r\n}\r\nsec_do_gc(sec);\r\n}\r\nmutex_unlock(&sec_gc_mutex);\r\nsec_process_ctx_list();\r\nlwi = LWI_TIMEOUT(SEC_GC_INTERVAL * HZ, NULL, NULL);\r\nl_wait_event(thread->t_ctl_waitq,\r\nthread_is_stopping(thread) ||\r\nthread_is_signal(thread),\r\n&lwi);\r\nif (thread_test_and_clear_flags(thread, SVC_STOPPING))\r\nbreak;\r\n}\r\nthread_set_flags(thread, SVC_STOPPED);\r\nwake_up(&thread->t_ctl_waitq);\r\nreturn 0;\r\n}\r\nint sptlrpc_gc_init(void)\r\n{\r\nstruct l_wait_info lwi = { 0 };\r\nstruct task_struct *task;\r\nmutex_init(&sec_gc_mutex);\r\nspin_lock_init(&sec_gc_list_lock);\r\nspin_lock_init(&sec_gc_ctx_list_lock);\r\nmemset(&sec_gc_thread, 0, sizeof(sec_gc_thread));\r\ninit_waitqueue_head(&sec_gc_thread.t_ctl_waitq);\r\ntask = kthread_run(sec_gc_main, &sec_gc_thread, "sptlrpc_gc");\r\nif (IS_ERR(task)) {\r\nCERROR("can't start gc thread: %ld\n", PTR_ERR(task));\r\nreturn PTR_ERR(task);\r\n}\r\nl_wait_event(sec_gc_thread.t_ctl_waitq,\r\nthread_is_running(&sec_gc_thread), &lwi);\r\nreturn 0;\r\n}\r\nvoid sptlrpc_gc_fini(void)\r\n{\r\nstruct l_wait_info lwi = { 0 };\r\nthread_set_flags(&sec_gc_thread, SVC_STOPPING);\r\nwake_up(&sec_gc_thread.t_ctl_waitq);\r\nl_wait_event(sec_gc_thread.t_ctl_waitq,\r\nthread_is_stopped(&sec_gc_thread), &lwi);\r\n}
