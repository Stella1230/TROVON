static int ll_blksize_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = (struct super_block *)m->private;\r\nstruct obd_statfs osfs;\r\nint rc;\r\nLASSERT(sb != NULL);\r\nrc = ll_statfs_internal(sb, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc)\r\nrc = seq_printf(m, "%u\n", osfs.os_bsize);\r\nreturn rc;\r\n}\r\nstatic int ll_kbytestotal_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = (struct super_block *)m->private;\r\nstruct obd_statfs osfs;\r\nint rc;\r\nLASSERT(sb != NULL);\r\nrc = ll_statfs_internal(sb, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_blocks;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\nrc = seq_printf(m, LPU64"\n", result);\r\n}\r\nreturn rc;\r\n}\r\nstatic int ll_kbytesfree_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = (struct super_block *)m->private;\r\nstruct obd_statfs osfs;\r\nint rc;\r\nLASSERT(sb != NULL);\r\nrc = ll_statfs_internal(sb, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_bfree;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\nrc = seq_printf(m, LPU64"\n", result);\r\n}\r\nreturn rc;\r\n}\r\nstatic int ll_kbytesavail_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = (struct super_block *)m->private;\r\nstruct obd_statfs osfs;\r\nint rc;\r\nLASSERT(sb != NULL);\r\nrc = ll_statfs_internal(sb, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_bavail;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\nrc = seq_printf(m, LPU64"\n", result);\r\n}\r\nreturn rc;\r\n}\r\nstatic int ll_filestotal_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = (struct super_block *)m->private;\r\nstruct obd_statfs osfs;\r\nint rc;\r\nLASSERT(sb != NULL);\r\nrc = ll_statfs_internal(sb, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc)\r\nrc = seq_printf(m, LPU64"\n", osfs.os_files);\r\nreturn rc;\r\n}\r\nstatic int ll_filesfree_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = (struct super_block *)m->private;\r\nstruct obd_statfs osfs;\r\nint rc;\r\nLASSERT(sb != NULL);\r\nrc = ll_statfs_internal(sb, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc)\r\nrc = seq_printf(m, LPU64"\n", osfs.os_ffree);\r\nreturn rc;\r\n}\r\nstatic int ll_client_type_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct ll_sb_info *sbi = ll_s2sbi((struct super_block *)m->private);\r\nint rc;\r\nLASSERT(sbi != NULL);\r\nif (sbi->ll_flags & LL_SBI_RMT_CLIENT)\r\nrc = seq_printf(m, "remote client\n");\r\nelse\r\nrc = seq_printf(m, "local client\n");\r\nreturn rc;\r\n}\r\nstatic int ll_fstype_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = (struct super_block *)m->private;\r\nLASSERT(sb != NULL);\r\nreturn seq_printf(m, "%s\n", sb->s_type->name);\r\n}\r\nstatic int ll_sb_uuid_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = (struct super_block *)m->private;\r\nLASSERT(sb != NULL);\r\nreturn seq_printf(m, "%s\n", ll_s2sbi(sb)->ll_sb_uuid.uuid);\r\n}\r\nstatic int ll_site_stats_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nreturn cl_site_stats_print(lu2cl_site(ll_s2sbi(sb)->ll_site), m);\r\n}\r\nstatic int ll_max_readahead_mb_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nlong pages_number;\r\nint mult;\r\nspin_lock(&sbi->ll_lock);\r\npages_number = sbi->ll_ra_info.ra_max_pages;\r\nspin_unlock(&sbi->ll_lock);\r\nmult = 1 << (20 - PAGE_CACHE_SHIFT);\r\nreturn lprocfs_seq_read_frac_helper(m, pages_number, mult);\r\n}\r\nstatic ssize_t ll_max_readahead_mb_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct super_block *sb = ((struct seq_file *)file->private_data)->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nint mult, rc, pages_number;\r\nmult = 1 << (20 - PAGE_CACHE_SHIFT);\r\nrc = lprocfs_write_frac_helper(buffer, count, &pages_number, mult);\r\nif (rc)\r\nreturn rc;\r\nif (pages_number < 0 || pages_number > totalram_pages / 2) {\r\nCERROR("can't set file readahead more than %lu MB\n",\r\ntotalram_pages >> (20 - PAGE_CACHE_SHIFT + 1));\r\nreturn -ERANGE;\r\n}\r\nspin_lock(&sbi->ll_lock);\r\nsbi->ll_ra_info.ra_max_pages = pages_number;\r\nspin_unlock(&sbi->ll_lock);\r\nreturn count;\r\n}\r\nstatic int ll_max_readahead_per_file_mb_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nlong pages_number;\r\nint mult;\r\nspin_lock(&sbi->ll_lock);\r\npages_number = sbi->ll_ra_info.ra_max_pages_per_file;\r\nspin_unlock(&sbi->ll_lock);\r\nmult = 1 << (20 - PAGE_CACHE_SHIFT);\r\nreturn lprocfs_seq_read_frac_helper(m, pages_number, mult);\r\n}\r\nstatic ssize_t ll_max_readahead_per_file_mb_seq_write(struct file *file,\r\nconst char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct super_block *sb = ((struct seq_file *)file->private_data)->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nint mult, rc, pages_number;\r\nmult = 1 << (20 - PAGE_CACHE_SHIFT);\r\nrc = lprocfs_write_frac_helper(buffer, count, &pages_number, mult);\r\nif (rc)\r\nreturn rc;\r\nif (pages_number < 0 ||\r\npages_number > sbi->ll_ra_info.ra_max_pages) {\r\nCERROR("can't set file readahead more than"\r\n"max_read_ahead_mb %lu MB\n",\r\nsbi->ll_ra_info.ra_max_pages);\r\nreturn -ERANGE;\r\n}\r\nspin_lock(&sbi->ll_lock);\r\nsbi->ll_ra_info.ra_max_pages_per_file = pages_number;\r\nspin_unlock(&sbi->ll_lock);\r\nreturn count;\r\n}\r\nstatic int ll_max_read_ahead_whole_mb_seq_show(struct seq_file *m, void *unused)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nlong pages_number;\r\nint mult;\r\nspin_lock(&sbi->ll_lock);\r\npages_number = sbi->ll_ra_info.ra_max_read_ahead_whole_pages;\r\nspin_unlock(&sbi->ll_lock);\r\nmult = 1 << (20 - PAGE_CACHE_SHIFT);\r\nreturn lprocfs_seq_read_frac_helper(m, pages_number, mult);\r\n}\r\nstatic ssize_t ll_max_read_ahead_whole_mb_seq_write(struct file *file,\r\nconst char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct super_block *sb = ((struct seq_file *)file->private_data)->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nint mult, rc, pages_number;\r\nmult = 1 << (20 - PAGE_CACHE_SHIFT);\r\nrc = lprocfs_write_frac_helper(buffer, count, &pages_number, mult);\r\nif (rc)\r\nreturn rc;\r\nif (pages_number < 0 ||\r\npages_number > sbi->ll_ra_info.ra_max_pages_per_file) {\r\nCERROR("can't set max_read_ahead_whole_mb more than "\r\n"max_read_ahead_per_file_mb: %lu\n",\r\nsbi->ll_ra_info.ra_max_pages_per_file >> (20 - PAGE_CACHE_SHIFT));\r\nreturn -ERANGE;\r\n}\r\nspin_lock(&sbi->ll_lock);\r\nsbi->ll_ra_info.ra_max_read_ahead_whole_pages = pages_number;\r\nspin_unlock(&sbi->ll_lock);\r\nreturn count;\r\n}\r\nstatic int ll_max_cached_mb_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nstruct cl_client_cache *cache = &sbi->ll_cache;\r\nint shift = 20 - PAGE_CACHE_SHIFT;\r\nint max_cached_mb;\r\nint unused_mb;\r\nmax_cached_mb = cache->ccc_lru_max >> shift;\r\nunused_mb = atomic_read(&cache->ccc_lru_left) >> shift;\r\nreturn seq_printf(m,\r\n"users: %d\n"\r\n"max_cached_mb: %d\n"\r\n"used_mb: %d\n"\r\n"unused_mb: %d\n"\r\n"reclaim_count: %u\n",\r\natomic_read(&cache->ccc_users),\r\nmax_cached_mb,\r\nmax_cached_mb - unused_mb,\r\nunused_mb,\r\ncache->ccc_lru_shrinkers);\r\n}\r\nstatic ssize_t ll_max_cached_mb_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct super_block *sb = ((struct seq_file *)file->private_data)->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nstruct cl_client_cache *cache = &sbi->ll_cache;\r\nint mult, rc, pages_number;\r\nint diff = 0;\r\nint nrpages = 0;\r\nmult = 1 << (20 - PAGE_CACHE_SHIFT);\r\nbuffer = lprocfs_find_named_value(buffer, "max_cached_mb:", &count);\r\nrc = lprocfs_write_frac_helper(buffer, count, &pages_number, mult);\r\nif (rc)\r\nreturn rc;\r\nif (pages_number < 0 || pages_number > totalram_pages) {\r\nCERROR("%s: can't set max cache more than %lu MB\n",\r\nll_get_fsname(sb, NULL, 0),\r\ntotalram_pages >> (20 - PAGE_CACHE_SHIFT));\r\nreturn -ERANGE;\r\n}\r\nif (sbi->ll_dt_exp == NULL)\r\nreturn -ENODEV;\r\nspin_lock(&sbi->ll_lock);\r\ndiff = pages_number - cache->ccc_lru_max;\r\nspin_unlock(&sbi->ll_lock);\r\nif (diff >= 0) {\r\natomic_add(diff, &cache->ccc_lru_left);\r\nGOTO(out, rc = 0);\r\n}\r\ndiff = -diff;\r\nwhile (diff > 0) {\r\nint tmp;\r\ndo {\r\nint ov, nv;\r\nov = atomic_read(&cache->ccc_lru_left);\r\nif (ov == 0)\r\nbreak;\r\nnv = ov > diff ? ov - diff : 0;\r\nrc = atomic_cmpxchg(&cache->ccc_lru_left, ov, nv);\r\nif (likely(ov == rc)) {\r\ndiff -= ov - nv;\r\nnrpages += ov - nv;\r\nbreak;\r\n}\r\n} while (1);\r\nif (diff <= 0)\r\nbreak;\r\ntmp = diff << 1;\r\nrc = obd_set_info_async(NULL, sbi->ll_dt_exp,\r\nsizeof(KEY_CACHE_LRU_SHRINK),\r\nKEY_CACHE_LRU_SHRINK,\r\nsizeof(tmp), &tmp, NULL);\r\nif (rc < 0)\r\nbreak;\r\n}\r\nout:\r\nif (rc >= 0) {\r\nspin_lock(&sbi->ll_lock);\r\ncache->ccc_lru_max = pages_number;\r\nspin_unlock(&sbi->ll_lock);\r\nrc = count;\r\n} else {\r\natomic_add(nrpages, &cache->ccc_lru_left);\r\n}\r\nreturn rc;\r\n}\r\nstatic int ll_checksum_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nreturn seq_printf(m, "%u\n", (sbi->ll_flags & LL_SBI_CHECKSUM) ? 1 : 0);\r\n}\r\nstatic ssize_t ll_checksum_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct super_block *sb = ((struct seq_file *)file->private_data)->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nint val, rc;\r\nif (!sbi->ll_dt_exp)\r\nreturn -EAGAIN;\r\nrc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val)\r\nsbi->ll_flags |= LL_SBI_CHECKSUM;\r\nelse\r\nsbi->ll_flags &= ~LL_SBI_CHECKSUM;\r\nrc = obd_set_info_async(NULL, sbi->ll_dt_exp, sizeof(KEY_CHECKSUM),\r\nKEY_CHECKSUM, sizeof(val), &val, NULL);\r\nif (rc)\r\nCWARN("Failed to set OSC checksum flags: %d\n", rc);\r\nreturn count;\r\n}\r\nstatic int ll_max_rw_chunk_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nreturn seq_printf(m, "%lu\n", ll_s2sbi(sb)->ll_max_rw_chunk);\r\n}\r\nstatic ssize_t ll_max_rw_chunk_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct super_block *sb = ((struct seq_file *)file->private_data)->private;\r\nint rc, val;\r\nrc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc)\r\nreturn rc;\r\nll_s2sbi(sb)->ll_max_rw_chunk = val;\r\nreturn count;\r\n}\r\nstatic int ll_rd_track_id(struct seq_file *m, enum stats_track_type type)\r\n{\r\nstruct super_block *sb = m->private;\r\nif (ll_s2sbi(sb)->ll_stats_track_type == type) {\r\nreturn seq_printf(m, "%d\n",\r\nll_s2sbi(sb)->ll_stats_track_id);\r\n} else if (ll_s2sbi(sb)->ll_stats_track_type == STATS_TRACK_ALL) {\r\nreturn seq_printf(m, "0 (all)\n");\r\n} else {\r\nreturn seq_printf(m, "untracked\n");\r\n}\r\n}\r\nstatic int ll_wr_track_id(const char *buffer, unsigned long count, void *data,\r\nenum stats_track_type type)\r\n{\r\nstruct super_block *sb = data;\r\nint rc, pid;\r\nrc = lprocfs_write_helper(buffer, count, &pid);\r\nif (rc)\r\nreturn rc;\r\nll_s2sbi(sb)->ll_stats_track_id = pid;\r\nif (pid == 0)\r\nll_s2sbi(sb)->ll_stats_track_type = STATS_TRACK_ALL;\r\nelse\r\nll_s2sbi(sb)->ll_stats_track_type = type;\r\nlprocfs_clear_stats(ll_s2sbi(sb)->ll_stats);\r\nreturn count;\r\n}\r\nstatic int ll_track_pid_seq_show(struct seq_file *m, void *v)\r\n{\r\nreturn ll_rd_track_id(m, STATS_TRACK_PID);\r\n}\r\nstatic ssize_t ll_track_pid_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nreturn ll_wr_track_id(buffer, count, seq->private, STATS_TRACK_PID);\r\n}\r\nstatic int ll_track_ppid_seq_show(struct seq_file *m, void *v)\r\n{\r\nreturn ll_rd_track_id(m, STATS_TRACK_PPID);\r\n}\r\nstatic ssize_t ll_track_ppid_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nreturn ll_wr_track_id(buffer, count, seq->private, STATS_TRACK_PPID);\r\n}\r\nstatic int ll_track_gid_seq_show(struct seq_file *m, void *v)\r\n{\r\nreturn ll_rd_track_id(m, STATS_TRACK_GID);\r\n}\r\nstatic ssize_t ll_track_gid_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nreturn ll_wr_track_id(buffer, count, seq->private, STATS_TRACK_GID);\r\n}\r\nstatic int ll_statahead_max_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nreturn seq_printf(m, "%u\n", sbi->ll_sa_max);\r\n}\r\nstatic ssize_t ll_statahead_max_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct super_block *sb = ((struct seq_file *)file->private_data)->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nint val, rc;\r\nrc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val >= 0 && val <= LL_SA_RPC_MAX)\r\nsbi->ll_sa_max = val;\r\nelse\r\nCERROR("Bad statahead_max value %d. Valid values are in the "\r\n"range [0, %d]\n", val, LL_SA_RPC_MAX);\r\nreturn count;\r\n}\r\nstatic int ll_statahead_agl_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nreturn seq_printf(m, "%u\n",\r\nsbi->ll_flags & LL_SBI_AGL_ENABLED ? 1 : 0);\r\n}\r\nstatic ssize_t ll_statahead_agl_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct super_block *sb = ((struct seq_file *)file->private_data)->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nint val, rc;\r\nrc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val)\r\nsbi->ll_flags |= LL_SBI_AGL_ENABLED;\r\nelse\r\nsbi->ll_flags &= ~LL_SBI_AGL_ENABLED;\r\nreturn count;\r\n}\r\nstatic int ll_statahead_stats_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nreturn seq_printf(m,\r\n"statahead total: %u\n"\r\n"statahead wrong: %u\n"\r\n"agl total: %u\n",\r\natomic_read(&sbi->ll_sa_total),\r\natomic_read(&sbi->ll_sa_wrong),\r\natomic_read(&sbi->ll_agl_total));\r\n}\r\nstatic int ll_lazystatfs_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nreturn seq_printf(m, "%u\n",\r\n(sbi->ll_flags & LL_SBI_LAZYSTATFS) ? 1 : 0);\r\n}\r\nstatic ssize_t ll_lazystatfs_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct super_block *sb = ((struct seq_file *)file->private_data)->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nint val, rc;\r\nrc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val)\r\nsbi->ll_flags |= LL_SBI_LAZYSTATFS;\r\nelse\r\nsbi->ll_flags &= ~LL_SBI_LAZYSTATFS;\r\nreturn count;\r\n}\r\nstatic int ll_maxea_size_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nunsigned int ealen;\r\nint rc;\r\nrc = ll_get_max_mdsize(sbi, &ealen);\r\nif (rc)\r\nreturn rc;\r\nreturn seq_printf(m, "%u\n", ealen);\r\n}\r\nstatic int ll_sbi_flags_seq_show(struct seq_file *m, void *v)\r\n{\r\nconst char *str[] = LL_SBI_FLAGS;\r\nstruct super_block *sb = m->private;\r\nint flags = ll_s2sbi(sb)->ll_flags;\r\nint i = 0;\r\nwhile (flags != 0) {\r\nif (ARRAY_SIZE(str) <= i) {\r\nCERROR("%s: Revise array LL_SBI_FLAGS to match sbi "\r\n"flags please.\n", ll_get_fsname(sb, NULL, 0));\r\nreturn -EINVAL;\r\n}\r\nif (flags & 0x1)\r\nseq_printf(m, "%s ", str[i]);\r\nflags >>= 1;\r\n++i;\r\n}\r\nseq_printf(m, "\b\n");\r\nreturn 0;\r\n}\r\nstatic int ll_xattr_cache_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nint rc;\r\nrc = seq_printf(m, "%u\n", sbi->ll_xattr_cache_enabled);\r\nreturn rc;\r\n}\r\nstatic ssize_t ll_xattr_cache_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct super_block *sb = seq->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nint val, rc;\r\nrc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val != 0 && val != 1)\r\nreturn -ERANGE;\r\nif (val == 1 && !(sbi->ll_flags & LL_SBI_XATTR_CACHE))\r\nreturn -ENOTSUPP;\r\nsbi->ll_xattr_cache_enabled = val;\r\nreturn count;\r\n}\r\nvoid ll_stats_ops_tally(struct ll_sb_info *sbi, int op, int count)\r\n{\r\nif (!sbi->ll_stats)\r\nreturn;\r\nif (sbi->ll_stats_track_type == STATS_TRACK_ALL)\r\nlprocfs_counter_add(sbi->ll_stats, op, count);\r\nelse if (sbi->ll_stats_track_type == STATS_TRACK_PID &&\r\nsbi->ll_stats_track_id == current->pid)\r\nlprocfs_counter_add(sbi->ll_stats, op, count);\r\nelse if (sbi->ll_stats_track_type == STATS_TRACK_PPID &&\r\nsbi->ll_stats_track_id == current->parent->pid)\r\nlprocfs_counter_add(sbi->ll_stats, op, count);\r\nelse if (sbi->ll_stats_track_type == STATS_TRACK_GID &&\r\nsbi->ll_stats_track_id ==\r\nfrom_kgid(&init_user_ns, current_gid()))\r\nlprocfs_counter_add(sbi->ll_stats, op, count);\r\n}\r\nint lprocfs_register_mountpoint(struct proc_dir_entry *parent,\r\nstruct super_block *sb, char *osc, char *mdc)\r\n{\r\nstruct lprocfs_vars lvars[2];\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nstruct obd_device *obd;\r\nstruct proc_dir_entry *dir;\r\nchar name[MAX_STRING_SIZE + 1], *ptr;\r\nint err, id, len, rc;\r\nmemset(lvars, 0, sizeof(lvars));\r\nname[MAX_STRING_SIZE] = '\0';\r\nlvars[0].name = name;\r\nLASSERT(sbi != NULL);\r\nLASSERT(mdc != NULL);\r\nLASSERT(osc != NULL);\r\nlen = strlen(lsi->lsi_lmd->lmd_profile);\r\nptr = strrchr(lsi->lsi_lmd->lmd_profile, '-');\r\nif (ptr && (strcmp(ptr, "-client") == 0))\r\nlen -= 7;\r\nsnprintf(name, MAX_STRING_SIZE, "%.*s-%p", len,\r\nlsi->lsi_lmd->lmd_profile, sb);\r\nsbi->ll_proc_root = lprocfs_register(name, parent, NULL, NULL);\r\nif (IS_ERR(sbi->ll_proc_root)) {\r\nerr = PTR_ERR(sbi->ll_proc_root);\r\nsbi->ll_proc_root = NULL;\r\nreturn err;\r\n}\r\nrc = lprocfs_seq_create(sbi->ll_proc_root, "dump_page_cache", 0444,\r\n&vvp_dump_pgcache_file_ops, sbi);\r\nif (rc)\r\nCWARN("Error adding the dump_page_cache file\n");\r\nrc = lprocfs_seq_create(sbi->ll_proc_root, "extents_stats", 0644,\r\n&ll_rw_extents_stats_fops, sbi);\r\nif (rc)\r\nCWARN("Error adding the extent_stats file\n");\r\nrc = lprocfs_seq_create(sbi->ll_proc_root, "extents_stats_per_process",\r\n0644, &ll_rw_extents_stats_pp_fops, sbi);\r\nif (rc)\r\nCWARN("Error adding the extents_stats_per_process file\n");\r\nrc = lprocfs_seq_create(sbi->ll_proc_root, "offset_stats", 0644,\r\n&ll_rw_offset_stats_fops, sbi);\r\nif (rc)\r\nCWARN("Error adding the offset_stats file\n");\r\nsbi->ll_stats = lprocfs_alloc_stats(LPROC_LL_FILE_OPCODES,\r\nLPROCFS_STATS_FLAG_NONE);\r\nif (sbi->ll_stats == NULL)\r\nGOTO(out, err = -ENOMEM);\r\nfor (id = 0; id < LPROC_LL_FILE_OPCODES; id++) {\r\n__u32 type = llite_opcode_table[id].type;\r\nvoid *ptr = NULL;\r\nif (type & LPROCFS_TYPE_REGS)\r\nptr = "regs";\r\nelse if (type & LPROCFS_TYPE_BYTES)\r\nptr = "bytes";\r\nelse if (type & LPROCFS_TYPE_PAGES)\r\nptr = "pages";\r\nlprocfs_counter_init(sbi->ll_stats,\r\nllite_opcode_table[id].opcode,\r\n(type & LPROCFS_CNTR_AVGMINMAX),\r\nllite_opcode_table[id].opname, ptr);\r\n}\r\nerr = lprocfs_register_stats(sbi->ll_proc_root, "stats", sbi->ll_stats);\r\nif (err)\r\nGOTO(out, err);\r\nsbi->ll_ra_stats = lprocfs_alloc_stats(ARRAY_SIZE(ra_stat_string),\r\nLPROCFS_STATS_FLAG_NONE);\r\nif (sbi->ll_ra_stats == NULL)\r\nGOTO(out, err = -ENOMEM);\r\nfor (id = 0; id < ARRAY_SIZE(ra_stat_string); id++)\r\nlprocfs_counter_init(sbi->ll_ra_stats, id, 0,\r\nra_stat_string[id], "pages");\r\nerr = lprocfs_register_stats(sbi->ll_proc_root, "read_ahead_stats",\r\nsbi->ll_ra_stats);\r\nif (err)\r\nGOTO(out, err);\r\nerr = lprocfs_add_vars(sbi->ll_proc_root, lprocfs_llite_obd_vars, sb);\r\nif (err)\r\nGOTO(out, err);\r\nobd = class_name2obd(mdc);\r\nLASSERT(obd != NULL);\r\nLASSERT(obd->obd_magic == OBD_DEVICE_MAGIC);\r\nLASSERT(obd->obd_type->typ_name != NULL);\r\ndir = proc_mkdir(obd->obd_type->typ_name, sbi->ll_proc_root);\r\nif (dir == NULL)\r\nGOTO(out, err = -ENOMEM);\r\nsnprintf(name, MAX_STRING_SIZE, "common_name");\r\nlvars[0].fops = &llite_name_fops;\r\nerr = lprocfs_add_vars(dir, lvars, obd);\r\nif (err)\r\nGOTO(out, err);\r\nsnprintf(name, MAX_STRING_SIZE, "uuid");\r\nlvars[0].fops = &llite_uuid_fops;\r\nerr = lprocfs_add_vars(dir, lvars, obd);\r\nif (err)\r\nGOTO(out, err);\r\nobd = class_name2obd(osc);\r\nLASSERT(obd != NULL);\r\nLASSERT(obd->obd_magic == OBD_DEVICE_MAGIC);\r\nLASSERT(obd->obd_type->typ_name != NULL);\r\ndir = proc_mkdir(obd->obd_type->typ_name, sbi->ll_proc_root);\r\nif (dir == NULL)\r\nGOTO(out, err = -ENOMEM);\r\nsnprintf(name, MAX_STRING_SIZE, "common_name");\r\nlvars[0].fops = &llite_name_fops;\r\nerr = lprocfs_add_vars(dir, lvars, obd);\r\nif (err)\r\nGOTO(out, err);\r\nsnprintf(name, MAX_STRING_SIZE, "uuid");\r\nlvars[0].fops = &llite_uuid_fops;\r\nerr = lprocfs_add_vars(dir, lvars, obd);\r\nout:\r\nif (err) {\r\nlprocfs_remove(&sbi->ll_proc_root);\r\nlprocfs_free_stats(&sbi->ll_ra_stats);\r\nlprocfs_free_stats(&sbi->ll_stats);\r\n}\r\nreturn err;\r\n}\r\nvoid lprocfs_unregister_mountpoint(struct ll_sb_info *sbi)\r\n{\r\nif (sbi->ll_proc_root) {\r\nlprocfs_remove(&sbi->ll_proc_root);\r\nlprocfs_free_stats(&sbi->ll_ra_stats);\r\nlprocfs_free_stats(&sbi->ll_stats);\r\n}\r\n}\r\nstatic void ll_display_extents_info(struct ll_rw_extents_info *io_extents,\r\nstruct seq_file *seq, int which)\r\n{\r\nunsigned long read_tot = 0, write_tot = 0, read_cum, write_cum;\r\nunsigned long start, end, r, w;\r\nchar *unitp = "KMGTPEZY";\r\nint i, units = 10;\r\nstruct per_process_info *pp_info = &io_extents->pp_extents[which];\r\nread_cum = 0;\r\nwrite_cum = 0;\r\nstart = 0;\r\nfor(i = 0; i < LL_HIST_MAX; i++) {\r\nread_tot += pp_info->pp_r_hist.oh_buckets[i];\r\nwrite_tot += pp_info->pp_w_hist.oh_buckets[i];\r\n}\r\nfor(i = 0; i < LL_HIST_MAX; i++) {\r\nr = pp_info->pp_r_hist.oh_buckets[i];\r\nw = pp_info->pp_w_hist.oh_buckets[i];\r\nread_cum += r;\r\nwrite_cum += w;\r\nend = 1 << (i + LL_HIST_START - units);\r\nseq_printf(seq, "%4lu%c - %4lu%c%c: %14lu %4lu %4lu | "\r\n"%14lu %4lu %4lu\n", start, *unitp, end, *unitp,\r\n(i == LL_HIST_MAX - 1) ? '+' : ' ',\r\nr, pct(r, read_tot), pct(read_cum, read_tot),\r\nw, pct(w, write_tot), pct(write_cum, write_tot));\r\nstart = end;\r\nif (start == 1<<10) {\r\nstart = 1;\r\nunits += 10;\r\nunitp++;\r\n}\r\nif (read_cum == read_tot && write_cum == write_tot)\r\nbreak;\r\n}\r\n}\r\nstatic int ll_rw_extents_stats_pp_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct timeval now;\r\nstruct ll_sb_info *sbi = seq->private;\r\nstruct ll_rw_extents_info *io_extents = &sbi->ll_rw_extents_info;\r\nint k;\r\ndo_gettimeofday(&now);\r\nif (!sbi->ll_rw_stats_on) {\r\nseq_printf(seq, "disabled\n"\r\n"write anything in this file to activate, "\r\n"then 0 or \"[D/d]isabled\" to deactivate\n");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "snapshot_time: %lu.%lu (secs.usecs)\n",\r\nnow.tv_sec, (unsigned long)now.tv_usec);\r\nseq_printf(seq, "%15s %19s | %20s\n", " ", "read", "write");\r\nseq_printf(seq, "%13s %14s %4s %4s | %14s %4s %4s\n",\r\n"extents", "calls", "%", "cum%",\r\n"calls", "%", "cum%");\r\nspin_lock(&sbi->ll_pp_extent_lock);\r\nfor (k = 0; k < LL_PROCESS_HIST_MAX; k++) {\r\nif (io_extents->pp_extents[k].pid != 0) {\r\nseq_printf(seq, "\nPID: %d\n",\r\nio_extents->pp_extents[k].pid);\r\nll_display_extents_info(io_extents, seq, k);\r\n}\r\n}\r\nspin_unlock(&sbi->ll_pp_extent_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t ll_rw_extents_stats_pp_seq_write(struct file *file,\r\nconst char *buf, size_t len,\r\nloff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct ll_sb_info *sbi = seq->private;\r\nstruct ll_rw_extents_info *io_extents = &sbi->ll_rw_extents_info;\r\nint i;\r\nint value = 1, rc = 0;\r\nrc = lprocfs_write_helper(buf, len, &value);\r\nif (rc < 0 && (strcmp(buf, "disabled") == 0 ||\r\nstrcmp(buf, "Disabled") == 0))\r\nvalue = 0;\r\nif (value == 0)\r\nsbi->ll_rw_stats_on = 0;\r\nelse\r\nsbi->ll_rw_stats_on = 1;\r\nspin_lock(&sbi->ll_pp_extent_lock);\r\nfor (i = 0; i < LL_PROCESS_HIST_MAX; i++) {\r\nio_extents->pp_extents[i].pid = 0;\r\nlprocfs_oh_clear(&io_extents->pp_extents[i].pp_r_hist);\r\nlprocfs_oh_clear(&io_extents->pp_extents[i].pp_w_hist);\r\n}\r\nspin_unlock(&sbi->ll_pp_extent_lock);\r\nreturn len;\r\n}\r\nstatic int ll_rw_extents_stats_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct timeval now;\r\nstruct ll_sb_info *sbi = seq->private;\r\nstruct ll_rw_extents_info *io_extents = &sbi->ll_rw_extents_info;\r\ndo_gettimeofday(&now);\r\nif (!sbi->ll_rw_stats_on) {\r\nseq_printf(seq, "disabled\n"\r\n"write anything in this file to activate, "\r\n"then 0 or \"[D/d]isabled\" to deactivate\n");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "snapshot_time: %lu.%lu (secs.usecs)\n",\r\nnow.tv_sec, (unsigned long)now.tv_usec);\r\nseq_printf(seq, "%15s %19s | %20s\n", " ", "read", "write");\r\nseq_printf(seq, "%13s %14s %4s %4s | %14s %4s %4s\n",\r\n"extents", "calls", "%", "cum%",\r\n"calls", "%", "cum%");\r\nspin_lock(&sbi->ll_lock);\r\nll_display_extents_info(io_extents, seq, LL_PROCESS_HIST_MAX);\r\nspin_unlock(&sbi->ll_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t ll_rw_extents_stats_seq_write(struct file *file, const char *buf,\r\nsize_t len, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct ll_sb_info *sbi = seq->private;\r\nstruct ll_rw_extents_info *io_extents = &sbi->ll_rw_extents_info;\r\nint i;\r\nint value = 1, rc = 0;\r\nrc = lprocfs_write_helper(buf, len, &value);\r\nif (rc < 0 && (strcmp(buf, "disabled") == 0 ||\r\nstrcmp(buf, "Disabled") == 0))\r\nvalue = 0;\r\nif (value == 0)\r\nsbi->ll_rw_stats_on = 0;\r\nelse\r\nsbi->ll_rw_stats_on = 1;\r\nspin_lock(&sbi->ll_pp_extent_lock);\r\nfor (i = 0; i <= LL_PROCESS_HIST_MAX; i++) {\r\nio_extents->pp_extents[i].pid = 0;\r\nlprocfs_oh_clear(&io_extents->pp_extents[i].pp_r_hist);\r\nlprocfs_oh_clear(&io_extents->pp_extents[i].pp_w_hist);\r\n}\r\nspin_unlock(&sbi->ll_pp_extent_lock);\r\nreturn len;\r\n}\r\nvoid ll_rw_stats_tally(struct ll_sb_info *sbi, pid_t pid,\r\nstruct ll_file_data *file, loff_t pos,\r\nsize_t count, int rw)\r\n{\r\nint i, cur = -1;\r\nstruct ll_rw_process_info *process;\r\nstruct ll_rw_process_info *offset;\r\nint *off_count = &sbi->ll_rw_offset_entry_count;\r\nint *process_count = &sbi->ll_offset_process_count;\r\nstruct ll_rw_extents_info *io_extents = &sbi->ll_rw_extents_info;\r\nif(!sbi->ll_rw_stats_on)\r\nreturn;\r\nprocess = sbi->ll_rw_process_info;\r\noffset = sbi->ll_rw_offset_info;\r\nspin_lock(&sbi->ll_pp_extent_lock);\r\nfor(i = 0; i < LL_PROCESS_HIST_MAX; i++) {\r\nif(io_extents->pp_extents[i].pid == pid) {\r\ncur = i;\r\nbreak;\r\n}\r\n}\r\nif (cur == -1) {\r\nsbi->ll_extent_process_count =\r\n(sbi->ll_extent_process_count + 1) % LL_PROCESS_HIST_MAX;\r\ncur = sbi->ll_extent_process_count;\r\nio_extents->pp_extents[cur].pid = pid;\r\nlprocfs_oh_clear(&io_extents->pp_extents[cur].pp_r_hist);\r\nlprocfs_oh_clear(&io_extents->pp_extents[cur].pp_w_hist);\r\n}\r\nfor(i = 0; (count >= (1 << LL_HIST_START << i)) &&\r\n(i < (LL_HIST_MAX - 1)); i++);\r\nif (rw == 0) {\r\nio_extents->pp_extents[cur].pp_r_hist.oh_buckets[i]++;\r\nio_extents->pp_extents[LL_PROCESS_HIST_MAX].pp_r_hist.oh_buckets[i]++;\r\n} else {\r\nio_extents->pp_extents[cur].pp_w_hist.oh_buckets[i]++;\r\nio_extents->pp_extents[LL_PROCESS_HIST_MAX].pp_w_hist.oh_buckets[i]++;\r\n}\r\nspin_unlock(&sbi->ll_pp_extent_lock);\r\nspin_lock(&sbi->ll_process_lock);\r\nfor (i = 0; i < LL_PROCESS_HIST_MAX; i++) {\r\nif (process[i].rw_pid == pid) {\r\nif (process[i].rw_last_file != file) {\r\nprocess[i].rw_range_start = pos;\r\nprocess[i].rw_last_file_pos = pos + count;\r\nprocess[i].rw_smallest_extent = count;\r\nprocess[i].rw_largest_extent = count;\r\nprocess[i].rw_offset = 0;\r\nprocess[i].rw_last_file = file;\r\nspin_unlock(&sbi->ll_process_lock);\r\nreturn;\r\n}\r\nif (process[i].rw_last_file_pos != pos) {\r\n*off_count =\r\n(*off_count + 1) % LL_OFFSET_HIST_MAX;\r\noffset[*off_count].rw_op = process[i].rw_op;\r\noffset[*off_count].rw_pid = pid;\r\noffset[*off_count].rw_range_start =\r\nprocess[i].rw_range_start;\r\noffset[*off_count].rw_range_end =\r\nprocess[i].rw_last_file_pos;\r\noffset[*off_count].rw_smallest_extent =\r\nprocess[i].rw_smallest_extent;\r\noffset[*off_count].rw_largest_extent =\r\nprocess[i].rw_largest_extent;\r\noffset[*off_count].rw_offset =\r\nprocess[i].rw_offset;\r\nprocess[i].rw_op = rw;\r\nprocess[i].rw_range_start = pos;\r\nprocess[i].rw_smallest_extent = count;\r\nprocess[i].rw_largest_extent = count;\r\nprocess[i].rw_offset = pos -\r\nprocess[i].rw_last_file_pos;\r\n}\r\nif(process[i].rw_smallest_extent > count)\r\nprocess[i].rw_smallest_extent = count;\r\nif(process[i].rw_largest_extent < count)\r\nprocess[i].rw_largest_extent = count;\r\nprocess[i].rw_last_file_pos = pos + count;\r\nspin_unlock(&sbi->ll_process_lock);\r\nreturn;\r\n}\r\n}\r\n*process_count = (*process_count + 1) % LL_PROCESS_HIST_MAX;\r\nprocess[*process_count].rw_pid = pid;\r\nprocess[*process_count].rw_op = rw;\r\nprocess[*process_count].rw_range_start = pos;\r\nprocess[*process_count].rw_last_file_pos = pos + count;\r\nprocess[*process_count].rw_smallest_extent = count;\r\nprocess[*process_count].rw_largest_extent = count;\r\nprocess[*process_count].rw_offset = 0;\r\nprocess[*process_count].rw_last_file = file;\r\nspin_unlock(&sbi->ll_process_lock);\r\n}\r\nstatic int ll_rw_offset_stats_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct timeval now;\r\nstruct ll_sb_info *sbi = seq->private;\r\nstruct ll_rw_process_info *offset = sbi->ll_rw_offset_info;\r\nstruct ll_rw_process_info *process = sbi->ll_rw_process_info;\r\nint i;\r\ndo_gettimeofday(&now);\r\nif (!sbi->ll_rw_stats_on) {\r\nseq_printf(seq, "disabled\n"\r\n"write anything in this file to activate, "\r\n"then 0 or \"[D/d]isabled\" to deactivate\n");\r\nreturn 0;\r\n}\r\nspin_lock(&sbi->ll_process_lock);\r\nseq_printf(seq, "snapshot_time: %lu.%lu (secs.usecs)\n",\r\nnow.tv_sec, (unsigned long)now.tv_usec);\r\nseq_printf(seq, "%3s %10s %14s %14s %17s %17s %14s\n",\r\n"R/W", "PID", "RANGE START", "RANGE END",\r\n"SMALLEST EXTENT", "LARGEST EXTENT", "OFFSET");\r\nfor(i = 0; i < LL_OFFSET_HIST_MAX; i++) {\r\nif (offset[i].rw_pid != 0)\r\nseq_printf(seq,\r\n"%3c %10d %14Lu %14Lu %17lu %17lu %14Lu",\r\noffset[i].rw_op == READ ? 'R' : 'W',\r\noffset[i].rw_pid,\r\noffset[i].rw_range_start,\r\noffset[i].rw_range_end,\r\n(unsigned long)offset[i].rw_smallest_extent,\r\n(unsigned long)offset[i].rw_largest_extent,\r\noffset[i].rw_offset);\r\n}\r\nfor(i = 0; i < LL_PROCESS_HIST_MAX; i++) {\r\nif (process[i].rw_pid != 0)\r\nseq_printf(seq,\r\n"%3c %10d %14Lu %14Lu %17lu %17lu %14Lu",\r\nprocess[i].rw_op == READ ? 'R' : 'W',\r\nprocess[i].rw_pid,\r\nprocess[i].rw_range_start,\r\nprocess[i].rw_last_file_pos,\r\n(unsigned long)process[i].rw_smallest_extent,\r\n(unsigned long)process[i].rw_largest_extent,\r\nprocess[i].rw_offset);\r\n}\r\nspin_unlock(&sbi->ll_process_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t ll_rw_offset_stats_seq_write(struct file *file, const char *buf,\r\nsize_t len, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct ll_sb_info *sbi = seq->private;\r\nstruct ll_rw_process_info *process_info = sbi->ll_rw_process_info;\r\nstruct ll_rw_process_info *offset_info = sbi->ll_rw_offset_info;\r\nint value = 1, rc = 0;\r\nrc = lprocfs_write_helper(buf, len, &value);\r\nif (rc < 0 && (strcmp(buf, "disabled") == 0 ||\r\nstrcmp(buf, "Disabled") == 0))\r\nvalue = 0;\r\nif (value == 0)\r\nsbi->ll_rw_stats_on = 0;\r\nelse\r\nsbi->ll_rw_stats_on = 1;\r\nspin_lock(&sbi->ll_process_lock);\r\nsbi->ll_offset_process_count = 0;\r\nsbi->ll_rw_offset_entry_count = 0;\r\nmemset(process_info, 0, sizeof(struct ll_rw_process_info) *\r\nLL_PROCESS_HIST_MAX);\r\nmemset(offset_info, 0, sizeof(struct ll_rw_process_info) *\r\nLL_OFFSET_HIST_MAX);\r\nspin_unlock(&sbi->ll_process_lock);\r\nreturn len;\r\n}\r\nvoid lprocfs_llite_init_vars(struct lprocfs_static_vars *lvars)\r\n{\r\nlvars->module_vars = NULL;\r\nlvars->obd_vars = lprocfs_llite_obd_vars;\r\n}
