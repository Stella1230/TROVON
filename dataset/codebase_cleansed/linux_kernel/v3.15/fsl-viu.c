struct viu_fmt *format_by_fourcc(int fourcc)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_FORMATS; i++) {\r\nif (formats[i].pixelformat == fourcc)\r\nreturn formats + i;\r\n}\r\ndprintk(0, "unknown pixelformat:'%4.4s'\n", (char *)&fourcc);\r\nreturn NULL;\r\n}\r\nvoid viu_start_dma(struct viu_dev *dev)\r\n{\r\nstruct viu_reg *vr = dev->vr;\r\ndev->field = 0;\r\nout_be32(&vr->status_cfg, SOFT_RST);\r\nout_be32(&vr->status_cfg, INT_FIELD_EN);\r\n}\r\nvoid viu_stop_dma(struct viu_dev *dev)\r\n{\r\nstruct viu_reg *vr = dev->vr;\r\nint cnt = 100;\r\nu32 status_cfg;\r\nout_be32(&vr->status_cfg, 0);\r\nstatus_cfg = in_be32(&vr->status_cfg);\r\nif (status_cfg & 0x3f0000)\r\nout_be32(&vr->status_cfg, status_cfg & 0x3f0000);\r\nif (status_cfg & DMA_ACT) {\r\ndo {\r\nstatus_cfg = in_be32(&vr->status_cfg);\r\nif (status_cfg & INT_DMA_END_STATUS)\r\nbreak;\r\n} while (cnt--);\r\nif (cnt < 0) {\r\nout_be32(&vr->status_cfg, SOFT_RST);\r\nout_be32(&vr->status_cfg, 0);\r\n} else {\r\nout_be32(&vr->status_cfg, status_cfg & 0x3f0000);\r\n}\r\n}\r\ndev->field = 0;\r\n}\r\nstatic int restart_video_queue(struct viu_dmaqueue *vidq)\r\n{\r\nstruct viu_buf *buf, *prev;\r\ndprintk(1, "%s vidq=0x%08lx\n", __func__, (unsigned long)vidq);\r\nif (!list_empty(&vidq->active)) {\r\nbuf = list_entry(vidq->active.next, struct viu_buf, vb.queue);\r\ndprintk(2, "restart_queue [%p/%d]: restart dma\n",\r\nbuf, buf->vb.i);\r\nviu_stop_dma(vidq->dev);\r\nlist_for_each_entry_safe(buf, prev, &vidq->active, vb.queue) {\r\nlist_del(&buf->vb.queue);\r\nbuf->vb.state = VIDEOBUF_ERROR;\r\nwake_up(&buf->vb.done);\r\n}\r\nmod_timer(&vidq->timeout, jiffies+BUFFER_TIMEOUT);\r\nreturn 0;\r\n}\r\nprev = NULL;\r\nfor (;;) {\r\nif (list_empty(&vidq->queued))\r\nreturn 0;\r\nbuf = list_entry(vidq->queued.next, struct viu_buf, vb.queue);\r\nif (prev == NULL) {\r\nlist_move_tail(&buf->vb.queue, &vidq->active);\r\ndprintk(1, "Restarting video dma\n");\r\nviu_stop_dma(vidq->dev);\r\nviu_start_dma(vidq->dev);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nmod_timer(&vidq->timeout, jiffies+BUFFER_TIMEOUT);\r\ndprintk(2, "[%p/%d] restart_queue - first active\n",\r\nbuf, buf->vb.i);\r\n} else if (prev->vb.width == buf->vb.width &&\r\nprev->vb.height == buf->vb.height &&\r\nprev->fmt == buf->fmt) {\r\nlist_move_tail(&buf->vb.queue, &vidq->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\ndprintk(2, "[%p/%d] restart_queue - move to active\n",\r\nbuf, buf->vb.i);\r\n} else {\r\nreturn 0;\r\n}\r\nprev = buf;\r\n}\r\n}\r\nstatic void viu_vid_timeout(unsigned long data)\r\n{\r\nstruct viu_dev *dev = (struct viu_dev *)data;\r\nstruct viu_buf *buf;\r\nstruct viu_dmaqueue *vidq = &dev->vidq;\r\nwhile (!list_empty(&vidq->active)) {\r\nbuf = list_entry(vidq->active.next, struct viu_buf, vb.queue);\r\nlist_del(&buf->vb.queue);\r\nbuf->vb.state = VIDEOBUF_ERROR;\r\nwake_up(&buf->vb.done);\r\ndprintk(1, "viu/0: [%p/%d] timeout\n", buf, buf->vb.i);\r\n}\r\nrestart_video_queue(vidq);\r\n}\r\nstatic int buffer_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct viu_fh *fh = vq->priv_data;\r\n*size = fh->width * fh->height * fh->fmt->depth >> 3;\r\nif (*count == 0)\r\n*count = 32;\r\nwhile (*size * *count > VIU_VID_MEM_LIMIT * 1024 * 1024)\r\n(*count)--;\r\ndprintk(1, "%s, count=%d, size=%d\n", __func__, *count, *size);\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct viu_buf *buf)\r\n{\r\nstruct videobuf_buffer *vb = &buf->vb;\r\nvoid *vaddr = NULL;\r\nBUG_ON(in_interrupt());\r\nvideobuf_waiton(vq, &buf->vb, 0, 0);\r\nif (vq->int_ops && vq->int_ops->vaddr)\r\nvaddr = vq->int_ops->vaddr(vb);\r\nif (vaddr)\r\nvideobuf_dma_contig_free(vq, &buf->vb);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\ninline int buffer_activate(struct viu_dev *dev, struct viu_buf *buf)\r\n{\r\nstruct viu_reg *vr = dev->vr;\r\nint bpp;\r\nreg_val.field_base_addr = videobuf_to_dma_contig(&buf->vb);\r\ndprintk(1, "buffer_activate [%p/%d]: dma addr 0x%lx\n",\r\nbuf, buf->vb.i, (unsigned long)reg_val.field_base_addr);\r\nreg_val.status_cfg = 0;\r\nbpp = buf->fmt->depth >> 3;\r\nswitch (bpp) {\r\ncase 2:\r\nreg_val.status_cfg &= ~MODE_32BIT;\r\nreg_val.dma_inc = buf->vb.width * 2;\r\nbreak;\r\ncase 4:\r\nreg_val.status_cfg |= MODE_32BIT;\r\nreg_val.dma_inc = buf->vb.width * 4;\r\nbreak;\r\ndefault:\r\ndprintk(0, "doesn't support color depth(%d)\n",\r\nbpp * 8);\r\nreturn -EINVAL;\r\n}\r\nreg_val.picture_count = (buf->vb.height / 2) << 16 |\r\nbuf->vb.width;\r\nreg_val.status_cfg |= DMA_ACT | INT_DMA_END_EN | INT_FIELD_EN;\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\ndev->capfield = buf->vb.field;\r\nif (!V4L2_FIELD_HAS_BOTH(buf->vb.field))\r\nreg_val.dma_inc = 0;\r\nout_be32(&vr->dma_inc, reg_val.dma_inc);\r\nout_be32(&vr->picture_count, reg_val.picture_count);\r\nout_be32(&vr->field_base_addr, reg_val.field_base_addr);\r\nmod_timer(&dev->vidq.timeout, jiffies + BUFFER_TIMEOUT);\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct viu_fh *fh = vq->priv_data;\r\nstruct viu_buf *buf = container_of(vb, struct viu_buf, vb);\r\nint rc;\r\nBUG_ON(fh->fmt == NULL);\r\nif (fh->width < 48 || fh->width > norm_maxw() ||\r\nfh->height < 32 || fh->height > norm_maxh())\r\nreturn -EINVAL;\r\nbuf->vb.size = (fh->width * fh->height * fh->fmt->depth) >> 3;\r\nif (buf->vb.baddr != 0 && buf->vb.bsize < buf->vb.size)\r\nreturn -EINVAL;\r\nif (buf->fmt != fh->fmt ||\r\nbuf->vb.width != fh->width ||\r\nbuf->vb.height != fh->height ||\r\nbuf->vb.field != field) {\r\nbuf->fmt = fh->fmt;\r\nbuf->vb.width = fh->width;\r\nbuf->vb.height = fh->height;\r\nbuf->vb.field = field;\r\n}\r\nif (buf->vb.state == VIDEOBUF_NEEDS_INIT) {\r\nrc = videobuf_iolock(vq, &buf->vb, NULL);\r\nif (rc != 0)\r\ngoto fail;\r\nbuf->vb.width = fh->width;\r\nbuf->vb.height = fh->height;\r\nbuf->vb.field = field;\r\nbuf->fmt = fh->fmt;\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\nfree_buffer(vq, buf);\r\nreturn rc;\r\n}\r\nstatic void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct viu_buf *buf = container_of(vb, struct viu_buf, vb);\r\nstruct viu_fh *fh = vq->priv_data;\r\nstruct viu_dev *dev = fh->dev;\r\nstruct viu_dmaqueue *vidq = &dev->vidq;\r\nstruct viu_buf *prev;\r\nif (!list_empty(&vidq->queued)) {\r\ndprintk(1, "adding vb queue=0x%08lx\n",\r\n(unsigned long)&buf->vb.queue);\r\ndprintk(1, "vidq pointer 0x%p, queued 0x%p\n",\r\nvidq, &vidq->queued);\r\ndprintk(1, "dev %p, queued: self %p, next %p, head %p\n",\r\ndev, &vidq->queued, vidq->queued.next,\r\nvidq->queued.prev);\r\nlist_add_tail(&buf->vb.queue, &vidq->queued);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\ndprintk(2, "[%p/%d] buffer_queue - append to queued\n",\r\nbuf, buf->vb.i);\r\n} else if (list_empty(&vidq->active)) {\r\ndprintk(1, "adding vb active=0x%08lx\n",\r\n(unsigned long)&buf->vb.queue);\r\nlist_add_tail(&buf->vb.queue, &vidq->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nmod_timer(&vidq->timeout, jiffies+BUFFER_TIMEOUT);\r\ndprintk(2, "[%p/%d] buffer_queue - first active\n",\r\nbuf, buf->vb.i);\r\nbuffer_activate(dev, buf);\r\n} else {\r\ndprintk(1, "adding vb queue2=0x%08lx\n",\r\n(unsigned long)&buf->vb.queue);\r\nprev = list_entry(vidq->active.prev, struct viu_buf, vb.queue);\r\nif (prev->vb.width == buf->vb.width &&\r\nprev->vb.height == buf->vb.height &&\r\nprev->fmt == buf->fmt) {\r\nlist_add_tail(&buf->vb.queue, &vidq->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\ndprintk(2, "[%p/%d] buffer_queue - append to active\n",\r\nbuf, buf->vb.i);\r\n} else {\r\nlist_add_tail(&buf->vb.queue, &vidq->queued);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\ndprintk(2, "[%p/%d] buffer_queue - first queued\n",\r\nbuf, buf->vb.i);\r\n}\r\n}\r\n}\r\nstatic void buffer_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct viu_buf *buf = container_of(vb, struct viu_buf, vb);\r\nstruct viu_fh *fh = vq->priv_data;\r\nstruct viu_dev *dev = (struct viu_dev *)fh->dev;\r\nviu_stop_dma(dev);\r\nfree_buffer(vq, buf);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrcpy(cap->driver, "viu");\r\nstrcpy(cap->card, "viu");\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_STREAMING |\r\nV4L2_CAP_VIDEO_OVERLAY |\r\nV4L2_CAP_READWRITE;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nint index = f->index;\r\nif (f->index > NUM_FORMATS)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[index].name, sizeof(f->description));\r\nf->pixelformat = formats[index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct viu_fh *fh = priv;\r\nf->fmt.pix.width = fh->width;\r\nf->fmt.pix.height = fh->height;\r\nf->fmt.pix.field = fh->vb_vidq.field;\r\nf->fmt.pix.pixelformat = fh->fmt->pixelformat;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fh->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage = fh->sizeimage;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct viu_fmt *fmt;\r\nenum v4l2_field field;\r\nunsigned int maxw, maxh;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (!fmt) {\r\ndprintk(1, "Fourcc format (0x%08x) invalid.",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nfield = f->fmt.pix.field;\r\nif (field == V4L2_FIELD_ANY) {\r\nfield = V4L2_FIELD_INTERLACED;\r\n} else if (field != V4L2_FIELD_INTERLACED) {\r\ndprintk(1, "Field type invalid.\n");\r\nreturn -EINVAL;\r\n}\r\nmaxw = norm_maxw();\r\nmaxh = norm_maxh();\r\nf->fmt.pix.field = field;\r\nif (f->fmt.pix.height < 32)\r\nf->fmt.pix.height = 32;\r\nif (f->fmt.pix.height > maxh)\r\nf->fmt.pix.height = maxh;\r\nif (f->fmt.pix.width < 48)\r\nf->fmt.pix.width = 48;\r\nif (f->fmt.pix.width > maxw)\r\nf->fmt.pix.width = maxw;\r\nf->fmt.pix.width &= ~0x03;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fmt->depth) >> 3;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct viu_fh *fh = priv;\r\nint ret;\r\nret = vidioc_try_fmt_cap(file, fh, f);\r\nif (ret < 0)\r\nreturn ret;\r\nfh->fmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nfh->width = f->fmt.pix.width;\r\nfh->height = f->fmt.pix.height;\r\nfh->sizeimage = f->fmt.pix.sizeimage;\r\nfh->vb_vidq.field = f->fmt.pix.field;\r\nfh->type = f->type;\r\ndprintk(1, "set to pixelformat '%4.6s'\n", (char *)&fh->fmt->name);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct viu_fh *fh = priv;\r\nf->fmt.win = fh->win;\r\nreturn 0;\r\n}\r\nstatic int verify_preview(struct viu_dev *dev, struct v4l2_window *win)\r\n{\r\nenum v4l2_field field;\r\nint maxw, maxh;\r\nif (dev->ovbuf.base == NULL)\r\nreturn -EINVAL;\r\nif (dev->ovfmt == NULL)\r\nreturn -EINVAL;\r\nif (win->w.width < 48 || win->w.height < 32)\r\nreturn -EINVAL;\r\nfield = win->field;\r\nmaxw = dev->crop_current.width;\r\nmaxh = dev->crop_current.height;\r\nif (field == V4L2_FIELD_ANY) {\r\nfield = (win->w.height > maxh/2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_TOP;\r\n}\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nmaxh = maxh / 2;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwin->field = field;\r\nif (win->w.width > maxw)\r\nwin->w.width = maxw;\r\nif (win->w.height > maxh)\r\nwin->w.height = maxh;\r\nreturn 0;\r\n}\r\ninline void viu_activate_overlay(struct viu_reg *viu_reg)\r\n{\r\nstruct viu_reg *vr = viu_reg;\r\nout_be32(&vr->field_base_addr, reg_val.field_base_addr);\r\nout_be32(&vr->dma_inc, reg_val.dma_inc);\r\nout_be32(&vr->picture_count, reg_val.picture_count);\r\n}\r\nstatic int viu_setup_preview(struct viu_dev *dev, struct viu_fh *fh)\r\n{\r\nint bpp;\r\ndprintk(1, "%s %dx%d %s\n", __func__,\r\nfh->win.w.width, fh->win.w.height, dev->ovfmt->name);\r\nreg_val.status_cfg = 0;\r\nreg_val.picture_count = (fh->win.w.height / 2) << 16 |\r\nfh->win.w.width;\r\nbpp = dev->ovfmt->depth / 8;\r\nswitch (bpp) {\r\ncase 2:\r\nreg_val.status_cfg &= ~MODE_32BIT;\r\nreg_val.dma_inc = fh->win.w.width * 2;\r\nbreak;\r\ncase 4:\r\nreg_val.status_cfg |= MODE_32BIT;\r\nreg_val.dma_inc = fh->win.w.width * 4;\r\nbreak;\r\ndefault:\r\ndprintk(0, "device doesn't support color depth(%d)\n",\r\nbpp * 8);\r\nreturn -EINVAL;\r\n}\r\ndev->ovfield = fh->win.field;\r\nif (!V4L2_FIELD_HAS_BOTH(dev->ovfield))\r\nreg_val.dma_inc = 0;\r\nreg_val.status_cfg |= DMA_ACT | INT_DMA_END_EN | INT_FIELD_EN;\r\nreg_val.field_base_addr = (u32)dev->ovbuf.base;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct viu_fh *fh = priv;\r\nstruct viu_dev *dev = (struct viu_dev *)fh->dev;\r\nunsigned long flags;\r\nint err;\r\nerr = verify_preview(dev, &f->fmt.win);\r\nif (err)\r\nreturn err;\r\nfh->win = f->fmt.win;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nviu_setup_preview(dev, fh);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vidioc_overlay(struct file *file, void *priv, unsigned int on)\r\n{\r\nstruct viu_fh *fh = priv;\r\nstruct viu_dev *dev = (struct viu_dev *)fh->dev;\r\nunsigned long flags;\r\nif (on) {\r\nspin_lock_irqsave(&dev->slock, flags);\r\nviu_activate_overlay(dev->vr);\r\ndev->ovenable = 1;\r\nviu_start_dma(dev);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n} else {\r\nviu_stop_dma(dev);\r\ndev->ovenable = 0;\r\n}\r\nreturn 0;\r\n}\r\nint vidioc_g_fbuf(struct file *file, void *priv, struct v4l2_framebuffer *arg)\r\n{\r\nstruct viu_fh *fh = priv;\r\nstruct viu_dev *dev = fh->dev;\r\nstruct v4l2_framebuffer *fb = arg;\r\n*fb = dev->ovbuf;\r\nfb->capability = V4L2_FBUF_CAP_LIST_CLIPPING;\r\nreturn 0;\r\n}\r\nint vidioc_s_fbuf(struct file *file, void *priv, const struct v4l2_framebuffer *arg)\r\n{\r\nstruct viu_fh *fh = priv;\r\nstruct viu_dev *dev = fh->dev;\r\nconst struct v4l2_framebuffer *fb = arg;\r\nstruct viu_fmt *fmt;\r\nif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nfmt = format_by_fourcc(fb->fmt.pixelformat);\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\ndev->ovbuf = *fb;\r\ndev->ovfmt = fmt;\r\nif (dev->ovbuf.fmt.bytesperline == 0) {\r\ndev->ovbuf.fmt.bytesperline =\r\ndev->ovbuf.fmt.width * fmt->depth / 8;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct viu_fh *fh = priv;\r\nreturn videobuf_reqbufs(&fh->vb_vidq, p);\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct viu_fh *fh = priv;\r\nreturn videobuf_querybuf(&fh->vb_vidq, p);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct viu_fh *fh = priv;\r\nreturn videobuf_qbuf(&fh->vb_vidq, p);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct viu_fh *fh = priv;\r\nreturn videobuf_dqbuf(&fh->vb_vidq, p,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct viu_fh *fh = priv;\r\nstruct viu_dev *dev = fh->dev;\r\nif (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (fh->type != i)\r\nreturn -EINVAL;\r\nif (dev->ovenable)\r\ndev->ovenable = 0;\r\nviu_start_dma(fh->dev);\r\nreturn videobuf_streamon(&fh->vb_vidq);\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct viu_fh *fh = priv;\r\nif (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (fh->type != i)\r\nreturn -EINVAL;\r\nviu_stop_dma(fh->dev);\r\nreturn videobuf_streamoff(&fh->vb_vidq);\r\n}\r\nstatic int vidioc_querystd(struct file *file, void *priv, v4l2_std_id *std_id)\r\n{\r\nstruct viu_fh *fh = priv;\r\ndecoder_call(fh->dev, video, querystd, std_id);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct viu_fh *fh = priv;\r\nfh->dev->std = id;\r\ndecoder_call(fh->dev, core, s_std, id);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *std_id)\r\n{\r\nstruct viu_fh *fh = priv;\r\n*std_id = fh->dev->std;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nstruct viu_fh *fh = priv;\r\nif (inp->index != 0)\r\nreturn -EINVAL;\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\ninp->std = fh->dev->vdev->tvnorms;\r\nstrcpy(inp->name, "Camera");\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct viu_fh *fh = priv;\r\nif (i > 1)\r\nreturn -EINVAL;\r\ndecoder_call(fh->dev, video, s_routing, i, 0, 0);\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(viu_qctrl); i++) {\r\nif (qc->id && qc->id == viu_qctrl[i].id) {\r\nmemcpy(qc, &(viu_qctrl[i]), sizeof(*qc));\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(viu_qctrl); i++) {\r\nif (ctrl->id == viu_qctrl[i].id) {\r\nctrl->value = qctl_regs[i];\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(viu_qctrl); i++) {\r\nif (ctrl->id == viu_qctrl[i].id) {\r\nif (ctrl->value < viu_qctrl[i].minimum\r\n|| ctrl->value > viu_qctrl[i].maximum)\r\nreturn -ERANGE;\r\nqctl_regs[i] = ctrl->value;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\ninline void viu_activate_next_buf(struct viu_dev *dev,\r\nstruct viu_dmaqueue *viuq)\r\n{\r\nstruct viu_dmaqueue *vidq = viuq;\r\nstruct viu_buf *buf;\r\nif (!list_empty(&vidq->active)) {\r\nbuf = list_entry(vidq->active.next, struct viu_buf,\r\nvb.queue);\r\ndprintk(1, "start another queued buffer: 0x%p\n", buf);\r\nbuffer_activate(dev, buf);\r\n} else if (!list_empty(&vidq->queued)) {\r\nbuf = list_entry(vidq->queued.next, struct viu_buf,\r\nvb.queue);\r\nlist_del(&buf->vb.queue);\r\ndprintk(1, "start another queued buffer: 0x%p\n", buf);\r\nlist_add_tail(&buf->vb.queue, &vidq->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuffer_activate(dev, buf);\r\n}\r\n}\r\ninline void viu_default_settings(struct viu_reg *viu_reg)\r\n{\r\nstruct viu_reg *vr = viu_reg;\r\nout_be32(&vr->luminance, 0x9512A254);\r\nout_be32(&vr->chroma_r, 0x03310000);\r\nout_be32(&vr->chroma_g, 0x06600F38);\r\nout_be32(&vr->chroma_b, 0x00000409);\r\nout_be32(&vr->alpha, 0x000000ff);\r\nout_be32(&vr->req_alarm, 0x00000090);\r\ndprintk(1, "status reg: 0x%08x, field base: 0x%08x\n",\r\nin_be32(&vr->status_cfg), in_be32(&vr->field_base_addr));\r\n}\r\nstatic void viu_overlay_intr(struct viu_dev *dev, u32 status)\r\n{\r\nstruct viu_reg *vr = dev->vr;\r\nif (status & INT_DMA_END_STATUS)\r\ndev->dma_done = 1;\r\nif (status & INT_FIELD_STATUS) {\r\nif (dev->dma_done) {\r\nu32 addr = reg_val.field_base_addr;\r\ndev->dma_done = 0;\r\nif (status & FIELD_NO)\r\naddr += reg_val.dma_inc;\r\nout_be32(&vr->field_base_addr, addr);\r\nout_be32(&vr->dma_inc, reg_val.dma_inc);\r\nout_be32(&vr->status_cfg,\r\n(status & 0xffc0ffff) |\r\n(status & INT_ALL_STATUS) |\r\nreg_val.status_cfg);\r\n} else if (status & INT_VSYNC_STATUS) {\r\nout_be32(&vr->status_cfg,\r\n(status & 0xffc0ffff) |\r\n(status & INT_ALL_STATUS) |\r\nreg_val.status_cfg);\r\n}\r\n}\r\n}\r\nstatic void viu_capture_intr(struct viu_dev *dev, u32 status)\r\n{\r\nstruct viu_dmaqueue *vidq = &dev->vidq;\r\nstruct viu_reg *vr = dev->vr;\r\nstruct viu_buf *buf;\r\nint field_num;\r\nint need_two;\r\nint dma_done = 0;\r\nfield_num = status & FIELD_NO;\r\nneed_two = V4L2_FIELD_HAS_BOTH(dev->capfield);\r\nif (status & INT_DMA_END_STATUS) {\r\ndma_done = 1;\r\nif (((field_num == 0) && (dev->field == 0)) ||\r\n(field_num && (dev->field == 1)))\r\ndev->field++;\r\n}\r\nif (status & INT_FIELD_STATUS) {\r\ndprintk(1, "irq: field %d, done %d\n",\r\n!!field_num, dma_done);\r\nif (unlikely(dev->first)) {\r\nif (field_num == 0) {\r\ndev->first = 0;\r\ndprintk(1, "activate first buf\n");\r\nviu_activate_next_buf(dev, vidq);\r\n} else\r\ndprintk(1, "wait field 0\n");\r\nreturn;\r\n}\r\nif (!list_empty(&vidq->active)) {\r\nu32 addr = reg_val.field_base_addr;\r\nif (field_num && need_two) {\r\naddr += reg_val.dma_inc;\r\ndprintk(1, "field 1, 0x%lx, dev field %d\n",\r\n(unsigned long)addr, dev->field);\r\n}\r\nout_be32(&vr->field_base_addr, addr);\r\nout_be32(&vr->dma_inc, reg_val.dma_inc);\r\nout_be32(&vr->status_cfg,\r\n(status & 0xffc0ffff) |\r\n(status & INT_ALL_STATUS) |\r\nreg_val.status_cfg);\r\nreturn;\r\n}\r\n}\r\nif (dma_done && field_num && (dev->field == 2)) {\r\ndev->field = 0;\r\nbuf = list_entry(vidq->active.next,\r\nstruct viu_buf, vb.queue);\r\ndprintk(1, "viu/0: [%p/%d] 0x%lx/0x%lx: dma complete\n",\r\nbuf, buf->vb.i,\r\n(unsigned long)videobuf_to_dma_contig(&buf->vb),\r\n(unsigned long)in_be32(&vr->field_base_addr));\r\nif (waitqueue_active(&buf->vb.done)) {\r\nlist_del(&buf->vb.queue);\r\nv4l2_get_timestamp(&buf->vb.ts);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nbuf->vb.field_count++;\r\nwake_up(&buf->vb.done);\r\n}\r\nviu_activate_next_buf(dev, vidq);\r\n}\r\n}\r\nstatic irqreturn_t viu_intr(int irq, void *dev_id)\r\n{\r\nstruct viu_dev *dev = (struct viu_dev *)dev_id;\r\nstruct viu_reg *vr = dev->vr;\r\nu32 status;\r\nu32 error;\r\nstatus = in_be32(&vr->status_cfg);\r\nif (status & INT_ERROR_STATUS) {\r\ndev->irqs.error_irq++;\r\nerror = status & ERR_MASK;\r\nif (error)\r\ndprintk(1, "Err: error(%d), times:%d!\n",\r\nerror >> 4, dev->irqs.error_irq);\r\nout_be32(&vr->status_cfg,\r\n(status & 0xffc0ffff) | INT_ERROR_STATUS);\r\n}\r\nif (status & INT_DMA_END_STATUS) {\r\ndev->irqs.dma_end_irq++;\r\ndev->dma_done = 1;\r\ndprintk(2, "VIU DMA end interrupt times: %d\n",\r\ndev->irqs.dma_end_irq);\r\n}\r\nif (status & INT_HSYNC_STATUS)\r\ndev->irqs.hsync_irq++;\r\nif (status & INT_FIELD_STATUS) {\r\ndev->irqs.field_irq++;\r\ndprintk(2, "VIU field interrupt times: %d\n",\r\ndev->irqs.field_irq);\r\n}\r\nif (status & INT_VSTART_STATUS)\r\ndev->irqs.vstart_irq++;\r\nif (status & INT_VSYNC_STATUS) {\r\ndev->irqs.vsync_irq++;\r\ndprintk(2, "VIU vsync interrupt times: %d\n",\r\ndev->irqs.vsync_irq);\r\n}\r\nstatus = in_be32(&vr->status_cfg);\r\nout_be32(&vr->status_cfg,\r\n(status & 0xffc0ffff) | (status & INT_ALL_STATUS));\r\nif (dev->ovenable) {\r\nviu_overlay_intr(dev, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nviu_capture_intr(dev, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int viu_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct viu_dev *dev = video_get_drvdata(vdev);\r\nstruct viu_fh *fh;\r\nstruct viu_reg *vr;\r\nint minor = vdev->minor;\r\nu32 status_cfg;\r\nint i;\r\ndprintk(1, "viu: open (minor=%d)\n", minor);\r\ndev->users++;\r\nif (dev->users > 1) {\r\ndev->users--;\r\nreturn -EBUSY;\r\n}\r\nvr = dev->vr;\r\ndprintk(1, "open minor=%d type=%s users=%d\n", minor,\r\nv4l2_type_names[V4L2_BUF_TYPE_VIDEO_CAPTURE], dev->users);\r\nif (mutex_lock_interruptible(&dev->lock)) {\r\ndev->users--;\r\nreturn -ERESTARTSYS;\r\n}\r\nfh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (!fh) {\r\ndev->users--;\r\nmutex_unlock(&dev->lock);\r\nreturn -ENOMEM;\r\n}\r\nfile->private_data = fh;\r\nfh->dev = dev;\r\nfh->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nfh->fmt = format_by_fourcc(V4L2_PIX_FMT_RGB32);\r\nfh->width = norm_maxw();\r\nfh->height = norm_maxh();\r\ndev->crop_current.width = fh->width;\r\ndev->crop_current.height = fh->height;\r\nfor (i = 0; i < ARRAY_SIZE(viu_qctrl); i++)\r\nqctl_regs[i] = viu_qctrl[i].default_value;\r\ndprintk(1, "Open: fh=0x%08lx, dev=0x%08lx, dev->vidq=0x%08lx\n",\r\n(unsigned long)fh, (unsigned long)dev,\r\n(unsigned long)&dev->vidq);\r\ndprintk(1, "Open: list_empty queued=%d\n",\r\nlist_empty(&dev->vidq.queued));\r\ndprintk(1, "Open: list_empty active=%d\n",\r\nlist_empty(&dev->vidq.active));\r\nviu_default_settings(vr);\r\nstatus_cfg = in_be32(&vr->status_cfg);\r\nout_be32(&vr->status_cfg,\r\nstatus_cfg & ~(INT_VSYNC_EN | INT_HSYNC_EN |\r\nINT_FIELD_EN | INT_VSTART_EN |\r\nINT_DMA_END_EN | INT_ERROR_EN | INT_ECC_EN));\r\nstatus_cfg = in_be32(&vr->status_cfg);\r\nout_be32(&vr->status_cfg, status_cfg | INT_ALL_STATUS);\r\nspin_lock_init(&fh->vbq_lock);\r\nvideobuf_queue_dma_contig_init(&fh->vb_vidq, &viu_video_qops,\r\ndev->dev, &fh->vbq_lock,\r\nfh->type, V4L2_FIELD_INTERLACED,\r\nsizeof(struct viu_buf), fh,\r\n&fh->dev->lock);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t viu_read(struct file *file, char __user *data, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct viu_fh *fh = file->private_data;\r\nstruct viu_dev *dev = fh->dev;\r\nint ret = 0;\r\ndprintk(2, "%s\n", __func__);\r\nif (dev->ovenable)\r\ndev->ovenable = 0;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nviu_start_dma(dev);\r\nret = videobuf_read_stream(&fh->vb_vidq, data, count,\r\nppos, 0, file->f_flags & O_NONBLOCK);\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int viu_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct viu_fh *fh = file->private_data;\r\nstruct videobuf_queue *q = &fh->vb_vidq;\r\nstruct viu_dev *dev = fh->dev;\r\nunsigned int res;\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != fh->type)\r\nreturn POLLERR;\r\nmutex_lock(&dev->lock);\r\nres = videobuf_poll_stream(file, q, wait);\r\nmutex_unlock(&dev->lock);\r\nreturn res;\r\n}\r\nstatic int viu_release(struct file *file)\r\n{\r\nstruct viu_fh *fh = file->private_data;\r\nstruct viu_dev *dev = fh->dev;\r\nint minor = video_devdata(file)->minor;\r\nmutex_lock(&dev->lock);\r\nviu_stop_dma(dev);\r\nvideobuf_stop(&fh->vb_vidq);\r\nvideobuf_mmap_free(&fh->vb_vidq);\r\nmutex_unlock(&dev->lock);\r\nkfree(fh);\r\ndev->users--;\r\ndprintk(1, "close (minor=%d, users=%d)\n",\r\nminor, dev->users);\r\nreturn 0;\r\n}\r\nvoid viu_reset(struct viu_reg *reg)\r\n{\r\nout_be32(&reg->status_cfg, 0);\r\nout_be32(&reg->luminance, 0x9512a254);\r\nout_be32(&reg->chroma_r, 0x03310000);\r\nout_be32(&reg->chroma_g, 0x06600f38);\r\nout_be32(&reg->chroma_b, 0x00000409);\r\nout_be32(&reg->field_base_addr, 0);\r\nout_be32(&reg->dma_inc, 0);\r\nout_be32(&reg->picture_count, 0x01e002d0);\r\nout_be32(&reg->req_alarm, 0x00000090);\r\nout_be32(&reg->alpha, 0x000000ff);\r\n}\r\nstatic int viu_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct viu_fh *fh = file->private_data;\r\nstruct viu_dev *dev = fh->dev;\r\nint ret;\r\ndprintk(1, "mmap called, vma=0x%08lx\n", (unsigned long)vma);\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nret = videobuf_mmap_mapper(&fh->vb_vidq, vma);\r\nmutex_unlock(&dev->lock);\r\ndprintk(1, "vma start=0x%08lx, size=%ld, ret=%d\n",\r\n(unsigned long)vma->vm_start,\r\n(unsigned long)vma->vm_end-(unsigned long)vma->vm_start,\r\nret);\r\nreturn ret;\r\n}\r\nstatic int viu_of_probe(struct platform_device *op)\r\n{\r\nstruct viu_dev *viu_dev;\r\nstruct video_device *vdev;\r\nstruct resource r;\r\nstruct viu_reg __iomem *viu_regs;\r\nstruct i2c_adapter *ad;\r\nint ret, viu_irq;\r\nstruct clk *clk;\r\nret = of_address_to_resource(op->dev.of_node, 0, &r);\r\nif (ret) {\r\ndev_err(&op->dev, "Can't parse device node resource\n");\r\nreturn -ENODEV;\r\n}\r\nviu_irq = irq_of_parse_and_map(op->dev.of_node, 0);\r\nif (viu_irq == NO_IRQ) {\r\ndev_err(&op->dev, "Error while mapping the irq\n");\r\nreturn -EINVAL;\r\n}\r\nif (!devm_request_mem_region(&op->dev, r.start,\r\nsizeof(struct viu_reg), DRV_NAME)) {\r\ndev_err(&op->dev, "Error while requesting mem region\n");\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nviu_regs = devm_ioremap(&op->dev, r.start, sizeof(struct viu_reg));\r\nif (!viu_regs) {\r\ndev_err(&op->dev, "Can't map register set\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nviu_dev = devm_kzalloc(&op->dev, sizeof(struct viu_dev), GFP_ATOMIC);\r\nif (!viu_dev) {\r\ndev_err(&op->dev, "Can't allocate private structure\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nviu_dev->vr = viu_regs;\r\nviu_dev->irq = viu_irq;\r\nviu_dev->dev = &op->dev;\r\nINIT_LIST_HEAD(&viu_dev->vidq.active);\r\nINIT_LIST_HEAD(&viu_dev->vidq.queued);\r\nsnprintf(viu_dev->v4l2_dev.name,\r\nsizeof(viu_dev->v4l2_dev.name), "%s", "VIU");\r\nret = v4l2_device_register(viu_dev->dev, &viu_dev->v4l2_dev);\r\nif (ret < 0) {\r\ndev_err(&op->dev, "v4l2_device_register() failed: %d\n", ret);\r\ngoto err;\r\n}\r\nad = i2c_get_adapter(0);\r\nviu_dev->decoder = v4l2_i2c_new_subdev(&viu_dev->v4l2_dev, ad,\r\n"saa7113", VIU_VIDEO_DECODER_ADDR, NULL);\r\nviu_dev->vidq.timeout.function = viu_vid_timeout;\r\nviu_dev->vidq.timeout.data = (unsigned long)viu_dev;\r\ninit_timer(&viu_dev->vidq.timeout);\r\nviu_dev->std = V4L2_STD_NTSC_M;\r\nviu_dev->first = 1;\r\nvdev = video_device_alloc();\r\nif (vdev == NULL) {\r\nret = -ENOMEM;\r\ngoto err_vdev;\r\n}\r\nmemcpy(vdev, &viu_template, sizeof(viu_template));\r\nvdev->v4l2_dev = &viu_dev->v4l2_dev;\r\nviu_dev->vdev = vdev;\r\nmutex_init(&viu_dev->lock);\r\nviu_dev->vdev->lock = &viu_dev->lock;\r\nspin_lock_init(&viu_dev->slock);\r\nvideo_set_drvdata(viu_dev->vdev, viu_dev);\r\nmutex_lock(&viu_dev->lock);\r\nret = video_register_device(viu_dev->vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0) {\r\nvideo_device_release(viu_dev->vdev);\r\ngoto err_vdev;\r\n}\r\nclk = devm_clk_get(&op->dev, "ipg");\r\nif (IS_ERR(clk)) {\r\ndev_err(&op->dev, "failed to lookup the clock!\n");\r\nret = PTR_ERR(clk);\r\ngoto err_clk;\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\ndev_err(&op->dev, "failed to enable the clock!\n");\r\ngoto err_clk;\r\n}\r\nviu_dev->clk = clk;\r\nviu_reset(viu_dev->vr);\r\nif (request_irq(viu_dev->irq, viu_intr, 0, "viu", (void *)viu_dev)) {\r\ndev_err(&op->dev, "Request VIU IRQ failed.\n");\r\nret = -ENODEV;\r\ngoto err_irq;\r\n}\r\nmutex_unlock(&viu_dev->lock);\r\ndev_info(&op->dev, "Freescale VIU Video Capture Board\n");\r\nreturn ret;\r\nerr_irq:\r\nclk_disable_unprepare(viu_dev->clk);\r\nerr_clk:\r\nvideo_unregister_device(viu_dev->vdev);\r\nerr_vdev:\r\nmutex_unlock(&viu_dev->lock);\r\ni2c_put_adapter(ad);\r\nv4l2_device_unregister(&viu_dev->v4l2_dev);\r\nerr:\r\nirq_dispose_mapping(viu_irq);\r\nreturn ret;\r\n}\r\nstatic int viu_of_remove(struct platform_device *op)\r\n{\r\nstruct v4l2_device *v4l2_dev = dev_get_drvdata(&op->dev);\r\nstruct viu_dev *dev = container_of(v4l2_dev, struct viu_dev, v4l2_dev);\r\nstruct v4l2_subdev *sdev = list_entry(v4l2_dev->subdevs.next,\r\nstruct v4l2_subdev, list);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sdev);\r\nfree_irq(dev->irq, (void *)dev);\r\nirq_dispose_mapping(dev->irq);\r\nclk_disable_unprepare(dev->clk);\r\nvideo_unregister_device(dev->vdev);\r\ni2c_put_adapter(client->adapter);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nreturn 0;\r\n}\r\nstatic int viu_suspend(struct platform_device *op, pm_message_t state)\r\n{\r\nstruct v4l2_device *v4l2_dev = dev_get_drvdata(&op->dev);\r\nstruct viu_dev *dev = container_of(v4l2_dev, struct viu_dev, v4l2_dev);\r\nclk_disable(dev->clk);\r\nreturn 0;\r\n}\r\nstatic int viu_resume(struct platform_device *op)\r\n{\r\nstruct v4l2_device *v4l2_dev = dev_get_drvdata(&op->dev);\r\nstruct viu_dev *dev = container_of(v4l2_dev, struct viu_dev, v4l2_dev);\r\nclk_enable(dev->clk);\r\nreturn 0;\r\n}
