void qxl_fence_add_release_locked(struct qxl_fence *qfence, uint32_t rel_id)\r\n{\r\nradix_tree_insert(&qfence->tree, rel_id, qfence);\r\nqfence->num_active_releases++;\r\n}\r\nint qxl_fence_remove_release(struct qxl_fence *qfence, uint32_t rel_id)\r\n{\r\nvoid *ret;\r\nint retval = 0;\r\nstruct qxl_bo *bo = container_of(qfence, struct qxl_bo, fence);\r\nspin_lock(&bo->tbo.bdev->fence_lock);\r\nret = radix_tree_delete(&qfence->tree, rel_id);\r\nif (ret == qfence)\r\nqfence->num_active_releases--;\r\nelse {\r\nDRM_DEBUG("didn't find fence in radix tree for %d\n", rel_id);\r\nretval = -ENOENT;\r\n}\r\nspin_unlock(&bo->tbo.bdev->fence_lock);\r\nreturn retval;\r\n}\r\nint qxl_fence_init(struct qxl_device *qdev, struct qxl_fence *qfence)\r\n{\r\nqfence->qdev = qdev;\r\nqfence->num_active_releases = 0;\r\nINIT_RADIX_TREE(&qfence->tree, GFP_ATOMIC);\r\nreturn 0;\r\n}\r\nvoid qxl_fence_fini(struct qxl_fence *qfence)\r\n{\r\nkfree(qfence->release_ids);\r\nqfence->num_active_releases = 0;\r\n}
