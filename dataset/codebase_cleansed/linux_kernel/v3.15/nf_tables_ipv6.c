static unsigned int nft_do_chain_ipv6(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct nft_pktinfo pkt;\r\nif (nft_set_pktinfo_ipv6(&pkt, ops, skb, in, out) < 0)\r\nreturn NF_DROP;\r\nreturn nft_do_chain(&pkt, ops);\r\n}\r\nstatic unsigned int nft_ipv6_output(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nif (unlikely(skb->len < sizeof(struct ipv6hdr))) {\r\nif (net_ratelimit())\r\npr_info("nf_tables_ipv6: ignoring short SOCK_RAW "\r\n"packet\n");\r\nreturn NF_ACCEPT;\r\n}\r\nreturn nft_do_chain_ipv6(ops, skb, in, out, okfn);\r\n}\r\nstatic int nf_tables_ipv6_init_net(struct net *net)\r\n{\r\nnet->nft.ipv6 = kmalloc(sizeof(struct nft_af_info), GFP_KERNEL);\r\nif (net->nft.ipv6 == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(net->nft.ipv6, &nft_af_ipv6, sizeof(nft_af_ipv6));\r\nif (nft_register_afinfo(net, net->nft.ipv6) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkfree(net->nft.ipv6);\r\nreturn -ENOMEM;\r\n}\r\nstatic void nf_tables_ipv6_exit_net(struct net *net)\r\n{\r\nnft_unregister_afinfo(net->nft.ipv6);\r\nkfree(net->nft.ipv6);\r\n}\r\nstatic int __init nf_tables_ipv6_init(void)\r\n{\r\nint ret;\r\nnft_register_chain_type(&filter_ipv6);\r\nret = register_pernet_subsys(&nf_tables_ipv6_net_ops);\r\nif (ret < 0)\r\nnft_unregister_chain_type(&filter_ipv6);\r\nreturn ret;\r\n}\r\nstatic void __exit nf_tables_ipv6_exit(void)\r\n{\r\nunregister_pernet_subsys(&nf_tables_ipv6_net_ops);\r\nnft_unregister_chain_type(&filter_ipv6);\r\n}
