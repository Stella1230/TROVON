static void snd_ice1712_akm4xxx_lock(struct snd_akm4xxx *ak, int chip)\r\n{\r\nstruct snd_ice1712 *ice = ak->private_data[0];\r\nsnd_ice1712_save_gpio_status(ice);\r\n}\r\nstatic void snd_ice1712_akm4xxx_unlock(struct snd_akm4xxx *ak, int chip)\r\n{\r\nstruct snd_ice1712 *ice = ak->private_data[0];\r\nsnd_ice1712_restore_gpio_status(ice);\r\n}\r\nstatic void snd_ice1712_akm4xxx_write(struct snd_akm4xxx *ak, int chip,\r\nunsigned char addr, unsigned char data)\r\n{\r\nunsigned int tmp;\r\nint idx;\r\nunsigned int addrdata;\r\nstruct snd_ak4xxx_private *priv = (void *)ak->private_value[0];\r\nstruct snd_ice1712 *ice = ak->private_data[0];\r\nif (snd_BUG_ON(chip < 0 || chip >= 4))\r\nreturn;\r\ntmp = snd_ice1712_gpio_read(ice);\r\ntmp |= priv->add_flags;\r\ntmp &= ~priv->mask_flags;\r\nif (priv->cs_mask == priv->cs_addr) {\r\nif (priv->cif) {\r\ntmp |= priv->cs_mask;\r\n} else {\r\ntmp &= ~priv->cs_mask;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\n}\r\n} else {\r\ntmp &= ~priv->cs_mask;\r\ntmp |= priv->cs_addr;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\n}\r\naddrdata = (priv->caddr << 6) | 0x20 | (addr & 0x1f);\r\naddrdata = (addrdata << 8) | data;\r\nfor (idx = 15; idx >= 0; idx--) {\r\ntmp &= ~priv->clk_mask;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\nif (addrdata & (1 << idx))\r\ntmp |= priv->data_mask;\r\nelse\r\ntmp &= ~priv->data_mask;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\ntmp |= priv->clk_mask;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\n}\r\nif (priv->cs_mask == priv->cs_addr) {\r\nif (priv->cif) {\r\ntmp &= ~priv->cs_mask;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\n}\r\ntmp |= priv->cs_mask;\r\n} else {\r\ntmp &= ~priv->cs_mask;\r\ntmp |= priv->cs_none;\r\n}\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\n}\r\nint snd_ice1712_akm4xxx_init(struct snd_akm4xxx *ak, const struct snd_akm4xxx *temp,\r\nconst struct snd_ak4xxx_private *_priv, struct snd_ice1712 *ice)\r\n{\r\nstruct snd_ak4xxx_private *priv;\r\nif (_priv != NULL) {\r\npriv = kmalloc(sizeof(*priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn -ENOMEM;\r\n*priv = *_priv;\r\n} else {\r\npriv = NULL;\r\n}\r\n*ak = *temp;\r\nak->card = ice->card;\r\nak->private_value[0] = (unsigned long)priv;\r\nak->private_data[0] = ice;\r\nif (ak->ops.lock == NULL)\r\nak->ops.lock = snd_ice1712_akm4xxx_lock;\r\nif (ak->ops.unlock == NULL)\r\nak->ops.unlock = snd_ice1712_akm4xxx_unlock;\r\nif (ak->ops.write == NULL)\r\nak->ops.write = snd_ice1712_akm4xxx_write;\r\nsnd_akm4xxx_init(ak);\r\nreturn 0;\r\n}\r\nvoid snd_ice1712_akm4xxx_free(struct snd_ice1712 *ice)\r\n{\r\nunsigned int akidx;\r\nif (ice->akm == NULL)\r\nreturn;\r\nfor (akidx = 0; akidx < ice->akm_codecs; akidx++) {\r\nstruct snd_akm4xxx *ak = &ice->akm[akidx];\r\nkfree((void*)ak->private_value[0]);\r\n}\r\nkfree(ice->akm);\r\n}\r\nint snd_ice1712_akm4xxx_build_controls(struct snd_ice1712 *ice)\r\n{\r\nunsigned int akidx;\r\nint err;\r\nfor (akidx = 0; akidx < ice->akm_codecs; akidx++) {\r\nstruct snd_akm4xxx *ak = &ice->akm[akidx];\r\nerr = snd_akm4xxx_build_controls(ak);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init alsa_ice1712_akm4xxx_module_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_ice1712_akm4xxx_module_exit(void)\r\n{\r\n}
