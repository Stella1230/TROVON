int v4l2_ctrl_check(struct v4l2_ext_control *ctrl, struct v4l2_queryctrl *qctrl,\r\nconst char * const *menu_items)\r\n{\r\nif (qctrl->flags & V4L2_CTRL_FLAG_DISABLED)\r\nreturn -EINVAL;\r\nif (qctrl->flags & V4L2_CTRL_FLAG_GRABBED)\r\nreturn -EBUSY;\r\nif (qctrl->type == V4L2_CTRL_TYPE_STRING)\r\nreturn 0;\r\nif (qctrl->type == V4L2_CTRL_TYPE_BUTTON ||\r\nqctrl->type == V4L2_CTRL_TYPE_INTEGER64 ||\r\nqctrl->type == V4L2_CTRL_TYPE_CTRL_CLASS)\r\nreturn 0;\r\nif (ctrl->value < qctrl->minimum || ctrl->value > qctrl->maximum)\r\nreturn -ERANGE;\r\nif (qctrl->type == V4L2_CTRL_TYPE_MENU && menu_items != NULL) {\r\nif (menu_items[ctrl->value] == NULL ||\r\nmenu_items[ctrl->value][0] == '\0')\r\nreturn -EINVAL;\r\n}\r\nif (qctrl->type == V4L2_CTRL_TYPE_BITMASK &&\r\n(ctrl->value & ~qctrl->maximum))\r\nreturn -ERANGE;\r\nreturn 0;\r\n}\r\nint v4l2_ctrl_query_fill(struct v4l2_queryctrl *qctrl, s32 min, s32 max, s32 step, s32 def)\r\n{\r\nconst char *name;\r\nv4l2_ctrl_fill(qctrl->id, &name, &qctrl->type,\r\n&min, &max, &step, &def, &qctrl->flags);\r\nif (name == NULL)\r\nreturn -EINVAL;\r\nqctrl->minimum = min;\r\nqctrl->maximum = max;\r\nqctrl->step = step;\r\nqctrl->default_value = def;\r\nqctrl->reserved[0] = qctrl->reserved[1] = 0;\r\nstrlcpy(qctrl->name, name, sizeof(qctrl->name));\r\nreturn 0;\r\n}\r\nint v4l2_ctrl_query_menu(struct v4l2_querymenu *qmenu, struct v4l2_queryctrl *qctrl,\r\nconst char * const *menu_items)\r\n{\r\nint i;\r\nqmenu->reserved = 0;\r\nif (menu_items == NULL)\r\nmenu_items = v4l2_ctrl_get_menu(qmenu->id);\r\nif (menu_items == NULL ||\r\n(qctrl && (qmenu->index < qctrl->minimum || qmenu->index > qctrl->maximum)))\r\nreturn -EINVAL;\r\nfor (i = 0; i < qmenu->index && menu_items[i]; i++) ;\r\nif (menu_items[i] == NULL || menu_items[i][0] == '\0')\r\nreturn -EINVAL;\r\nstrlcpy(qmenu->name, menu_items[qmenu->index], sizeof(qmenu->name));\r\nreturn 0;\r\n}\r\nint v4l2_ctrl_query_menu_valid_items(struct v4l2_querymenu *qmenu, const u32 *ids)\r\n{\r\nconst char * const *menu_items = v4l2_ctrl_get_menu(qmenu->id);\r\nqmenu->reserved = 0;\r\nif (menu_items == NULL || ids == NULL)\r\nreturn -EINVAL;\r\nwhile (*ids != V4L2_CTRL_MENU_IDS_END) {\r\nif (*ids++ == qmenu->index) {\r\nstrlcpy(qmenu->name, menu_items[qmenu->index],\r\nsizeof(qmenu->name));\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nu32 v4l2_ctrl_next(const u32 * const * ctrl_classes, u32 id)\r\n{\r\nu32 ctrl_class = V4L2_CTRL_ID2CLASS(id);\r\nconst u32 *pctrl;\r\nif (ctrl_classes == NULL)\r\nreturn 0;\r\nif ((id & V4L2_CTRL_FLAG_NEXT_CTRL) == 0) {\r\nwhile (*ctrl_classes && V4L2_CTRL_ID2CLASS(**ctrl_classes) != ctrl_class)\r\nctrl_classes++;\r\nif (*ctrl_classes == NULL)\r\nreturn 0;\r\npctrl = *ctrl_classes;\r\nwhile (*pctrl && *pctrl != id) pctrl++;\r\nreturn *pctrl ? id : 0;\r\n}\r\nid &= V4L2_CTRL_ID_MASK;\r\nid++;\r\nwhile (*ctrl_classes && V4L2_CTRL_ID2CLASS(**ctrl_classes) < ctrl_class)\r\nctrl_classes++;\r\nif (*ctrl_classes == NULL)\r\nreturn 0;\r\npctrl = *ctrl_classes;\r\nwhile (*pctrl && *pctrl < id) pctrl++;\r\nif (*pctrl)\r\nreturn *pctrl;\r\nctrl_classes++;\r\nif (*ctrl_classes == NULL)\r\nreturn 0;\r\nreturn **ctrl_classes;\r\n}\r\nvoid v4l2_i2c_subdev_init(struct v4l2_subdev *sd, struct i2c_client *client,\r\nconst struct v4l2_subdev_ops *ops)\r\n{\r\nv4l2_subdev_init(sd, ops);\r\nsd->flags |= V4L2_SUBDEV_FL_IS_I2C;\r\nsd->owner = client->dev.driver->owner;\r\nsd->dev = &client->dev;\r\nv4l2_set_subdevdata(sd, client);\r\ni2c_set_clientdata(client, sd);\r\nsnprintf(sd->name, sizeof(sd->name), "%s %d-%04x",\r\nclient->dev.driver->name, i2c_adapter_id(client->adapter),\r\nclient->addr);\r\n}\r\nstruct v4l2_subdev *v4l2_i2c_new_subdev_board(struct v4l2_device *v4l2_dev,\r\nstruct i2c_adapter *adapter, struct i2c_board_info *info,\r\nconst unsigned short *probe_addrs)\r\n{\r\nstruct v4l2_subdev *sd = NULL;\r\nstruct i2c_client *client;\r\nBUG_ON(!v4l2_dev);\r\nrequest_module(I2C_MODULE_PREFIX "%s", info->type);\r\nif (info->addr == 0 && probe_addrs)\r\nclient = i2c_new_probed_device(adapter, info, probe_addrs,\r\nNULL);\r\nelse\r\nclient = i2c_new_device(adapter, info);\r\nif (client == NULL || client->dev.driver == NULL)\r\ngoto error;\r\nif (!try_module_get(client->dev.driver->owner))\r\ngoto error;\r\nsd = i2c_get_clientdata(client);\r\nif (v4l2_device_register_subdev(v4l2_dev, sd))\r\nsd = NULL;\r\nmodule_put(client->dev.driver->owner);\r\nerror:\r\nif (client && sd == NULL)\r\ni2c_unregister_device(client);\r\nreturn sd;\r\n}\r\nstruct v4l2_subdev *v4l2_i2c_new_subdev(struct v4l2_device *v4l2_dev,\r\nstruct i2c_adapter *adapter, const char *client_type,\r\nu8 addr, const unsigned short *probe_addrs)\r\n{\r\nstruct i2c_board_info info;\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.type, client_type, sizeof(info.type));\r\ninfo.addr = addr;\r\nreturn v4l2_i2c_new_subdev_board(v4l2_dev, adapter, &info, probe_addrs);\r\n}\r\nunsigned short v4l2_i2c_subdev_addr(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn client ? client->addr : I2C_CLIENT_END;\r\n}\r\nconst unsigned short *v4l2_i2c_tuner_addrs(enum v4l2_i2c_tuner_type type)\r\n{\r\nstatic const unsigned short radio_addrs[] = {\r\n#if IS_ENABLED(CONFIG_MEDIA_TUNER_TEA5761)\r\n0x10,\r\n#endif\r\n0x60,\r\nI2C_CLIENT_END\r\n};\r\nstatic const unsigned short demod_addrs[] = {\r\n0x42, 0x43, 0x4a, 0x4b,\r\nI2C_CLIENT_END\r\n};\r\nstatic const unsigned short tv_addrs[] = {\r\n0x42, 0x43, 0x4a, 0x4b,\r\n0x60, 0x61, 0x62, 0x63, 0x64,\r\nI2C_CLIENT_END\r\n};\r\nswitch (type) {\r\ncase ADDRS_RADIO:\r\nreturn radio_addrs;\r\ncase ADDRS_DEMOD:\r\nreturn demod_addrs;\r\ncase ADDRS_TV:\r\nreturn tv_addrs;\r\ncase ADDRS_TV_WITH_DEMOD:\r\nreturn tv_addrs + 4;\r\n}\r\nreturn NULL;\r\n}\r\nvoid v4l2_spi_subdev_init(struct v4l2_subdev *sd, struct spi_device *spi,\r\nconst struct v4l2_subdev_ops *ops)\r\n{\r\nv4l2_subdev_init(sd, ops);\r\nsd->flags |= V4L2_SUBDEV_FL_IS_SPI;\r\nsd->owner = spi->dev.driver->owner;\r\nsd->dev = &spi->dev;\r\nv4l2_set_subdevdata(sd, spi);\r\nspi_set_drvdata(spi, sd);\r\nstrlcpy(sd->name, spi->dev.driver->name, sizeof(sd->name));\r\n}\r\nstruct v4l2_subdev *v4l2_spi_new_subdev(struct v4l2_device *v4l2_dev,\r\nstruct spi_master *master, struct spi_board_info *info)\r\n{\r\nstruct v4l2_subdev *sd = NULL;\r\nstruct spi_device *spi = NULL;\r\nBUG_ON(!v4l2_dev);\r\nif (info->modalias[0])\r\nrequest_module(info->modalias);\r\nspi = spi_new_device(master, info);\r\nif (spi == NULL || spi->dev.driver == NULL)\r\ngoto error;\r\nif (!try_module_get(spi->dev.driver->owner))\r\ngoto error;\r\nsd = spi_get_drvdata(spi);\r\nif (v4l2_device_register_subdev(v4l2_dev, sd))\r\nsd = NULL;\r\nmodule_put(spi->dev.driver->owner);\r\nerror:\r\nif (spi && sd == NULL)\r\nspi_unregister_device(spi);\r\nreturn sd;\r\n}\r\nstatic unsigned int clamp_align(unsigned int x, unsigned int min,\r\nunsigned int max, unsigned int align)\r\n{\r\nunsigned int mask = ~((1 << align) - 1);\r\nif (align)\r\nx = (x + (1 << (align - 1))) & mask;\r\nif (x < min)\r\nx = (min + ~mask) & mask;\r\nelse if (x > max)\r\nx = max & mask;\r\nreturn x;\r\n}\r\nvoid v4l_bound_align_image(u32 *w, unsigned int wmin, unsigned int wmax,\r\nunsigned int walign,\r\nu32 *h, unsigned int hmin, unsigned int hmax,\r\nunsigned int halign, unsigned int salign)\r\n{\r\n*w = clamp_align(*w, wmin, wmax, walign);\r\n*h = clamp_align(*h, hmin, hmax, halign);\r\nif (!salign)\r\nreturn;\r\nwalign = __ffs(*w);\r\nhalign = __ffs(*h);\r\nif (walign + halign < salign) {\r\nunsigned int wmaxa = __fls(wmax ^ (wmin - 1));\r\nunsigned int hmaxa = __fls(hmax ^ (hmin - 1));\r\ndo {\r\nif (halign >= hmaxa ||\r\n(walign <= halign && walign < wmaxa)) {\r\n*w = clamp_align(*w, wmin, wmax, walign + 1);\r\nwalign = __ffs(*w);\r\n} else {\r\n*h = clamp_align(*h, hmin, hmax, halign + 1);\r\nhalign = __ffs(*h);\r\n}\r\n} while (halign + walign < salign);\r\n}\r\n}\r\nconst struct v4l2_frmsize_discrete *v4l2_find_nearest_format(\r\nconst struct v4l2_discrete_probe *probe,\r\ns32 width, s32 height)\r\n{\r\nint i;\r\nu32 error, min_error = UINT_MAX;\r\nconst struct v4l2_frmsize_discrete *size, *best = NULL;\r\nif (!probe)\r\nreturn best;\r\nfor (i = 0, size = probe->sizes; i < probe->num_sizes; i++, size++) {\r\nerror = abs(size->width - width) + abs(size->height - height);\r\nif (error < min_error) {\r\nmin_error = error;\r\nbest = size;\r\n}\r\nif (!error)\r\nbreak;\r\n}\r\nreturn best;\r\n}\r\nvoid v4l2_get_timestamp(struct timeval *tv)\r\n{\r\nstruct timespec ts;\r\nktime_get_ts(&ts);\r\ntv->tv_sec = ts.tv_sec;\r\ntv->tv_usec = ts.tv_nsec / NSEC_PER_USEC;\r\n}
