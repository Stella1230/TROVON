static int map_foreign_page(unsigned long lpfn, unsigned long fgmfn,\r\nunsigned int domid)\r\n{\r\nint rc;\r\nstruct xen_add_to_physmap_range xatp = {\r\n.domid = DOMID_SELF,\r\n.foreign_domid = domid,\r\n.size = 1,\r\n.space = XENMAPSPACE_gmfn_foreign,\r\n};\r\nxen_ulong_t idx = fgmfn;\r\nxen_pfn_t gpfn = lpfn;\r\nint err = 0;\r\nset_xen_guest_handle(xatp.idxs, &idx);\r\nset_xen_guest_handle(xatp.gpfns, &gpfn);\r\nset_xen_guest_handle(xatp.errs, &err);\r\nrc = HYPERVISOR_memory_op(XENMEM_add_to_physmap_range, &xatp);\r\nif (rc || err) {\r\npr_warn("Failed to map pfn to mfn rc:%d:%d pfn:%lx mfn:%lx\n",\r\nrc, err, lpfn, fgmfn);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int remap_pte_fn(pte_t *ptep, pgtable_t token, unsigned long addr,\r\nvoid *data)\r\n{\r\nstruct remap_data *info = data;\r\nstruct page *page = info->pages[info->index++];\r\nunsigned long pfn = page_to_pfn(page);\r\npte_t pte = pte_mkspecial(pfn_pte(pfn, info->prot));\r\nif (map_foreign_page(pfn, info->fgmfn, info->domid))\r\nreturn -EFAULT;\r\nset_pte_at(info->vma->vm_mm, addr, ptep, pte);\r\nreturn 0;\r\n}\r\nint xen_remap_domain_mfn_range(struct vm_area_struct *vma,\r\nunsigned long addr,\r\nxen_pfn_t mfn, int nr,\r\npgprot_t prot, unsigned domid,\r\nstruct page **pages)\r\n{\r\nint err;\r\nstruct remap_data data;\r\nif (nr > 1)\r\nreturn -EINVAL;\r\ndata.fgmfn = mfn;\r\ndata.prot = prot;\r\ndata.domid = domid;\r\ndata.vma = vma;\r\ndata.index = 0;\r\ndata.pages = pages;\r\nerr = apply_to_page_range(vma->vm_mm, addr, nr << PAGE_SHIFT,\r\nremap_pte_fn, &data);\r\nreturn err;\r\n}\r\nint xen_unmap_domain_mfn_range(struct vm_area_struct *vma,\r\nint nr, struct page **pages)\r\n{\r\nint i;\r\nfor (i = 0; i < nr; i++) {\r\nstruct xen_remove_from_physmap xrp;\r\nunsigned long rc, pfn;\r\npfn = page_to_pfn(pages[i]);\r\nxrp.domid = DOMID_SELF;\r\nxrp.gpfn = pfn;\r\nrc = HYPERVISOR_memory_op(XENMEM_remove_from_physmap, &xrp);\r\nif (rc) {\r\npr_warn("Failed to unmap pfn:%lx rc:%ld\n",\r\npfn, rc);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void xen_percpu_init(void)\r\n{\r\nstruct vcpu_register_vcpu_info info;\r\nstruct vcpu_info *vcpup;\r\nint err;\r\nint cpu = get_cpu();\r\npr_info("Xen: initializing cpu%d\n", cpu);\r\nvcpup = per_cpu_ptr(xen_vcpu_info, cpu);\r\ninfo.mfn = __pa(vcpup) >> PAGE_SHIFT;\r\ninfo.offset = offset_in_page(vcpup);\r\nerr = HYPERVISOR_vcpu_op(VCPUOP_register_vcpu_info, cpu, &info);\r\nBUG_ON(err);\r\nper_cpu(xen_vcpu, cpu) = vcpup;\r\nenable_percpu_irq(xen_events_irq, 0);\r\nput_cpu();\r\n}\r\nstatic void xen_restart(enum reboot_mode reboot_mode, const char *cmd)\r\n{\r\nstruct sched_shutdown r = { .reason = SHUTDOWN_reboot };\r\nint rc;\r\nrc = HYPERVISOR_sched_op(SCHEDOP_shutdown, &r);\r\nif (rc)\r\nBUG();\r\n}\r\nstatic void xen_power_off(void)\r\n{\r\nstruct sched_shutdown r = { .reason = SHUTDOWN_poweroff };\r\nint rc;\r\nrc = HYPERVISOR_sched_op(SCHEDOP_shutdown, &r);\r\nif (rc)\r\nBUG();\r\n}\r\nstatic int xen_cpu_notification(struct notifier_block *self,\r\nunsigned long action,\r\nvoid *hcpu)\r\n{\r\nswitch (action) {\r\ncase CPU_STARTING:\r\nxen_percpu_init();\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic irqreturn_t xen_arm_callback(int irq, void *arg)\r\n{\r\nxen_hvm_evtchn_do_upcall();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init xen_guest_init(void)\r\n{\r\nstruct xen_add_to_physmap xatp;\r\nstatic struct shared_info *shared_info_page = 0;\r\nstruct device_node *node;\r\nint len;\r\nconst char *s = NULL;\r\nconst char *version = NULL;\r\nconst char *xen_prefix = "xen,xen-";\r\nstruct resource res;\r\nphys_addr_t grant_frames;\r\nnode = of_find_compatible_node(NULL, NULL, "xen,xen");\r\nif (!node) {\r\npr_debug("No Xen support\n");\r\nreturn 0;\r\n}\r\ns = of_get_property(node, "compatible", &len);\r\nif (strlen(xen_prefix) + 3 < len &&\r\n!strncmp(xen_prefix, s, strlen(xen_prefix)))\r\nversion = s + strlen(xen_prefix);\r\nif (version == NULL) {\r\npr_debug("Xen version not found\n");\r\nreturn 0;\r\n}\r\nif (of_address_to_resource(node, GRANT_TABLE_PHYSADDR, &res))\r\nreturn 0;\r\ngrant_frames = res.start;\r\nxen_events_irq = irq_of_parse_and_map(node, 0);\r\npr_info("Xen %s support found, events_irq=%d gnttab_frame=%pa\n",\r\nversion, xen_events_irq, &grant_frames);\r\nif (xen_events_irq < 0)\r\nreturn -ENODEV;\r\nxen_domain_type = XEN_HVM_DOMAIN;\r\nxen_setup_features();\r\nif (xen_feature(XENFEAT_dom0))\r\nxen_start_info->flags |= SIF_INITDOMAIN|SIF_PRIVILEGED;\r\nelse\r\nxen_start_info->flags &= ~(SIF_INITDOMAIN|SIF_PRIVILEGED);\r\nif (!shared_info_page)\r\nshared_info_page = (struct shared_info *)\r\nget_zeroed_page(GFP_KERNEL);\r\nif (!shared_info_page) {\r\npr_err("not enough memory\n");\r\nreturn -ENOMEM;\r\n}\r\nxatp.domid = DOMID_SELF;\r\nxatp.idx = 0;\r\nxatp.space = XENMAPSPACE_shared_info;\r\nxatp.gpfn = __pa(shared_info_page) >> PAGE_SHIFT;\r\nif (HYPERVISOR_memory_op(XENMEM_add_to_physmap, &xatp))\r\nBUG();\r\nHYPERVISOR_shared_info = (struct shared_info *)shared_info_page;\r\nxen_vcpu_info = __alloc_percpu(sizeof(struct vcpu_info),\r\nsizeof(struct vcpu_info));\r\nif (xen_vcpu_info == NULL)\r\nreturn -ENOMEM;\r\nif (gnttab_setup_auto_xlat_frames(grant_frames)) {\r\nfree_percpu(xen_vcpu_info);\r\nreturn -ENOMEM;\r\n}\r\ngnttab_init();\r\nif (!xen_initial_domain())\r\nxenbus_probe(NULL);\r\ndisable_cpuidle();\r\ndisable_cpufreq();\r\nxen_init_IRQ();\r\nif (request_percpu_irq(xen_events_irq, xen_arm_callback,\r\n"events", &xen_vcpu)) {\r\npr_err("Error request IRQ %d\n", xen_events_irq);\r\nreturn -EINVAL;\r\n}\r\nxen_percpu_init();\r\nregister_cpu_notifier(&xen_cpu_notifier);\r\nreturn 0;\r\n}\r\nstatic int __init xen_pm_init(void)\r\n{\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\npm_power_off = xen_power_off;\r\narm_pm_restart = xen_restart;\r\nreturn 0;\r\n}
