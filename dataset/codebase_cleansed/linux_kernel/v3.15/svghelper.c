static double cpu2slot(int cpu)\r\n{\r\nreturn 2 * cpu + 1;\r\n}\r\nstatic double cpu2y(int cpu)\r\n{\r\nif (topology_map)\r\nreturn cpu2slot(topology_map[cpu]) * SLOT_MULT;\r\nelse\r\nreturn cpu2slot(cpu) * SLOT_MULT;\r\n}\r\nstatic double time2pixels(u64 __time)\r\n{\r\ndouble X;\r\nX = 1.0 * svg_page_width * (__time - first_time) / (last_time - first_time);\r\nreturn X;\r\n}\r\nstatic double round_text_size(double size)\r\n{\r\nint loop = 100;\r\ndouble target = 10.0;\r\nif (size >= 10.0)\r\nreturn size;\r\nwhile (loop--) {\r\nif (size >= target)\r\nreturn target;\r\ntarget = target / 2.0;\r\n}\r\nreturn size;\r\n}\r\nvoid open_svg(const char *filename, int cpus, int rows, u64 start, u64 end)\r\n{\r\nint new_width;\r\nsvgfile = fopen(filename, "w");\r\nif (!svgfile) {\r\nfprintf(stderr, "Cannot open %s for output\n", filename);\r\nreturn;\r\n}\r\nfirst_time = start;\r\nfirst_time = first_time / 100000000 * 100000000;\r\nlast_time = end;\r\nnew_width = (last_time - first_time) / 5000000;\r\nif (new_width > svg_page_width)\r\nsvg_page_width = new_width;\r\ntotal_height = (1 + rows + cpu2slot(cpus)) * SLOT_MULT;\r\nfprintf(svgfile, "<?xml version=\"1.0\" standalone=\"no\"?> \n");\r\nfprintf(svgfile, "<!DOCTYPE svg SYSTEM \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n");\r\nfprintf(svgfile, "<svg width=\"%i\" height=\"%" PRIu64 "\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n", svg_page_width, total_height);\r\nfprintf(svgfile, "<defs>\n <style type=\"text/css\">\n <![CDATA[\n");\r\nfprintf(svgfile, " rect { stroke-width: 1; }\n");\r\nfprintf(svgfile, " rect.process { fill:rgb(180,180,180); fill-opacity:0.9; stroke-width:1; stroke:rgb( 0, 0, 0); } \n");\r\nfprintf(svgfile, " rect.process2 { fill:rgb(180,180,180); fill-opacity:0.9; stroke-width:0; stroke:rgb( 0, 0, 0); } \n");\r\nfprintf(svgfile, " rect.sample { fill:rgb( 0, 0,255); fill-opacity:0.8; stroke-width:0; stroke:rgb( 0, 0, 0); } \n");\r\nfprintf(svgfile, " rect.sample_hi{ fill:rgb(255,128, 0); fill-opacity:0.8; stroke-width:0; stroke:rgb( 0, 0, 0); } \n");\r\nfprintf(svgfile, " rect.blocked { fill:rgb(255, 0, 0); fill-opacity:0.5; stroke-width:0; stroke:rgb( 0, 0, 0); } \n");\r\nfprintf(svgfile, " rect.waiting { fill:rgb(224,214, 0); fill-opacity:0.8; stroke-width:0; stroke:rgb( 0, 0, 0); } \n");\r\nfprintf(svgfile, " rect.WAITING { fill:rgb(255,214, 48); fill-opacity:0.6; stroke-width:0; stroke:rgb( 0, 0, 0); } \n");\r\nfprintf(svgfile, " rect.cpu { fill:rgb(192,192,192); fill-opacity:0.2; stroke-width:0.5; stroke:rgb(128,128,128); } \n");\r\nfprintf(svgfile, " rect.pstate { fill:rgb(128,128,128); fill-opacity:0.8; stroke-width:0; } \n");\r\nfprintf(svgfile, " rect.c1 { fill:rgb(255,214,214); fill-opacity:0.5; stroke-width:0; } \n");\r\nfprintf(svgfile, " rect.c2 { fill:rgb(255,172,172); fill-opacity:0.5; stroke-width:0; } \n");\r\nfprintf(svgfile, " rect.c3 { fill:rgb(255,130,130); fill-opacity:0.5; stroke-width:0; } \n");\r\nfprintf(svgfile, " rect.c4 { fill:rgb(255, 88, 88); fill-opacity:0.5; stroke-width:0; } \n");\r\nfprintf(svgfile, " rect.c5 { fill:rgb(255, 44, 44); fill-opacity:0.5; stroke-width:0; } \n");\r\nfprintf(svgfile, " rect.c6 { fill:rgb(255, 0, 0); fill-opacity:0.5; stroke-width:0; } \n");\r\nfprintf(svgfile, " line.pstate { stroke:rgb(255,255, 0); stroke-opacity:0.8; stroke-width:2; } \n");\r\nfprintf(svgfile, " ]]>\n </style>\n</defs>\n");\r\n}\r\nvoid svg_box(int Yslot, u64 start, u64 end, const char *type)\r\n{\r\nif (!svgfile)\r\nreturn;\r\nfprintf(svgfile, "<rect x=\"%4.8f\" width=\"%4.8f\" y=\"%4.1f\" height=\"%4.1f\" class=\"%s\"/>\n",\r\ntime2pixels(start), time2pixels(end)-time2pixels(start), Yslot * SLOT_MULT, SLOT_HEIGHT, type);\r\n}\r\nvoid svg_blocked(int Yslot, int cpu, u64 start, u64 end, const char *backtrace)\r\n{\r\nif (!svgfile)\r\nreturn;\r\nfprintf(svgfile, "<g>\n");\r\nfprintf(svgfile, "<title>#%d blocked %s</title>\n", cpu,\r\ntime_to_string(end - start));\r\nif (backtrace)\r\nfprintf(svgfile, "<desc>Blocked on:\n%s</desc>\n", backtrace);\r\nsvg_box(Yslot, start, end, "blocked");\r\nfprintf(svgfile, "</g>\n");\r\n}\r\nvoid svg_running(int Yslot, int cpu, u64 start, u64 end, const char *backtrace)\r\n{\r\ndouble text_size;\r\nconst char *type;\r\nif (!svgfile)\r\nreturn;\r\nif (svg_highlight && end - start > svg_highlight)\r\ntype = "sample_hi";\r\nelse\r\ntype = "sample";\r\nfprintf(svgfile, "<g>\n");\r\nfprintf(svgfile, "<title>#%d running %s</title>\n",\r\ncpu, time_to_string(end - start));\r\nif (backtrace)\r\nfprintf(svgfile, "<desc>Switched because:\n%s</desc>\n", backtrace);\r\nfprintf(svgfile, "<rect x=\"%4.8f\" width=\"%4.8f\" y=\"%4.1f\" height=\"%4.1f\" class=\"%s\"/>\n",\r\ntime2pixels(start), time2pixels(end)-time2pixels(start), Yslot * SLOT_MULT, SLOT_HEIGHT,\r\ntype);\r\ntext_size = (time2pixels(end)-time2pixels(start));\r\nif (cpu > 9)\r\ntext_size = text_size/2;\r\nif (text_size > 1.25)\r\ntext_size = 1.25;\r\ntext_size = round_text_size(text_size);\r\nif (text_size > MIN_TEXT_SIZE)\r\nfprintf(svgfile, "<text x=\"%1.8f\" y=\"%1.8f\" font-size=\"%1.8fpt\">%i</text>\n",\r\ntime2pixels(start), Yslot * SLOT_MULT + SLOT_HEIGHT - 1, text_size, cpu + 1);\r\nfprintf(svgfile, "</g>\n");\r\n}\r\nstatic char *time_to_string(u64 duration)\r\n{\r\nstatic char text[80];\r\ntext[0] = 0;\r\nif (duration < 1000)\r\nreturn text;\r\nif (duration < 1000 * 1000) {\r\nsprintf(text, "%4.1f us", duration / 1000.0);\r\nreturn text;\r\n}\r\nsprintf(text, "%4.1f ms", duration / 1000.0 / 1000);\r\nreturn text;\r\n}\r\nvoid svg_waiting(int Yslot, int cpu, u64 start, u64 end, const char *backtrace)\r\n{\r\nchar *text;\r\nconst char *style;\r\ndouble font_size;\r\nif (!svgfile)\r\nreturn;\r\nstyle = "waiting";\r\nif (end-start > 10 * 1000000)\r\nstyle = "WAITING";\r\ntext = time_to_string(end-start);\r\nfont_size = 1.0 * (time2pixels(end)-time2pixels(start));\r\nif (font_size > 3)\r\nfont_size = 3;\r\nfont_size = round_text_size(font_size);\r\nfprintf(svgfile, "<g transform=\"translate(%4.8f,%4.8f)\">\n", time2pixels(start), Yslot * SLOT_MULT);\r\nfprintf(svgfile, "<title>#%d waiting %s</title>\n", cpu, time_to_string(end - start));\r\nif (backtrace)\r\nfprintf(svgfile, "<desc>Waiting on:\n%s</desc>\n", backtrace);\r\nfprintf(svgfile, "<rect x=\"0\" width=\"%4.8f\" y=\"0\" height=\"%4.1f\" class=\"%s\"/>\n",\r\ntime2pixels(end)-time2pixels(start), SLOT_HEIGHT, style);\r\nif (font_size > MIN_TEXT_SIZE)\r\nfprintf(svgfile, "<text transform=\"rotate(90)\" font-size=\"%1.8fpt\"> %s</text>\n",\r\nfont_size, text);\r\nfprintf(svgfile, "</g>\n");\r\n}\r\nstatic char *cpu_model(void)\r\n{\r\nstatic char cpu_m[255];\r\nchar buf[256];\r\nFILE *file;\r\ncpu_m[0] = 0;\r\nfile = fopen("/proc/cpuinfo", "r");\r\nif (file) {\r\nwhile (fgets(buf, 255, file)) {\r\nif (strstr(buf, "model name")) {\r\nstrncpy(cpu_m, &buf[13], 255);\r\nbreak;\r\n}\r\n}\r\nfclose(file);\r\n}\r\nfile = fopen("/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies", "r");\r\nif (file) {\r\nwhile (fgets(buf, 255, file)) {\r\nunsigned int freq;\r\nfreq = strtoull(buf, NULL, 10);\r\nif (freq > max_freq)\r\nmax_freq = freq;\r\n}\r\nfclose(file);\r\n}\r\nreturn cpu_m;\r\n}\r\nvoid svg_cpu_box(int cpu, u64 __max_freq, u64 __turbo_freq)\r\n{\r\nchar cpu_string[80];\r\nif (!svgfile)\r\nreturn;\r\nmax_freq = __max_freq;\r\nturbo_frequency = __turbo_freq;\r\nfprintf(svgfile, "<g>\n");\r\nfprintf(svgfile, "<rect x=\"%4.8f\" width=\"%4.8f\" y=\"%4.1f\" height=\"%4.1f\" class=\"cpu\"/>\n",\r\ntime2pixels(first_time),\r\ntime2pixels(last_time)-time2pixels(first_time),\r\ncpu2y(cpu), SLOT_MULT+SLOT_HEIGHT);\r\nsprintf(cpu_string, "CPU %i", (int)cpu);\r\nfprintf(svgfile, "<text x=\"%4.8f\" y=\"%4.8f\">%s</text>\n",\r\n10+time2pixels(first_time), cpu2y(cpu) + SLOT_HEIGHT/2, cpu_string);\r\nfprintf(svgfile, "<text transform=\"translate(%4.8f,%4.8f)\" font-size=\"1.25pt\">%s</text>\n",\r\n10+time2pixels(first_time), cpu2y(cpu) + SLOT_MULT + SLOT_HEIGHT - 4, cpu_model());\r\nfprintf(svgfile, "</g>\n");\r\n}\r\nvoid svg_process(int cpu, u64 start, u64 end, int pid, const char *name, const char *backtrace)\r\n{\r\ndouble width;\r\nconst char *type;\r\nif (!svgfile)\r\nreturn;\r\nif (svg_highlight && end - start >= svg_highlight)\r\ntype = "sample_hi";\r\nelse if (svg_highlight_name && strstr(name, svg_highlight_name))\r\ntype = "sample_hi";\r\nelse\r\ntype = "sample";\r\nfprintf(svgfile, "<g transform=\"translate(%4.8f,%4.8f)\">\n", time2pixels(start), cpu2y(cpu));\r\nfprintf(svgfile, "<title>%d %s running %s</title>\n", pid, name, time_to_string(end - start));\r\nif (backtrace)\r\nfprintf(svgfile, "<desc>Switched because:\n%s</desc>\n", backtrace);\r\nfprintf(svgfile, "<rect x=\"0\" width=\"%4.8f\" y=\"0\" height=\"%4.1f\" class=\"%s\"/>\n",\r\ntime2pixels(end)-time2pixels(start), SLOT_MULT+SLOT_HEIGHT, type);\r\nwidth = time2pixels(end)-time2pixels(start);\r\nif (width > 6)\r\nwidth = 6;\r\nwidth = round_text_size(width);\r\nif (width > MIN_TEXT_SIZE)\r\nfprintf(svgfile, "<text transform=\"rotate(90)\" font-size=\"%3.8fpt\">%s</text>\n",\r\nwidth, name);\r\nfprintf(svgfile, "</g>\n");\r\n}\r\nvoid svg_cstate(int cpu, u64 start, u64 end, int type)\r\n{\r\ndouble width;\r\nchar style[128];\r\nif (!svgfile)\r\nreturn;\r\nfprintf(svgfile, "<g>\n");\r\nif (type > 6)\r\ntype = 6;\r\nsprintf(style, "c%i", type);\r\nfprintf(svgfile, "<rect class=\"%s\" x=\"%4.8f\" width=\"%4.8f\" y=\"%4.1f\" height=\"%4.1f\"/>\n",\r\nstyle,\r\ntime2pixels(start), time2pixels(end)-time2pixels(start),\r\ncpu2y(cpu), SLOT_MULT+SLOT_HEIGHT);\r\nwidth = (time2pixels(end)-time2pixels(start))/2.0;\r\nif (width > 6)\r\nwidth = 6;\r\nwidth = round_text_size(width);\r\nif (width > MIN_TEXT_SIZE)\r\nfprintf(svgfile, "<text x=\"%4.8f\" y=\"%4.8f\" font-size=\"%3.8fpt\">C%i</text>\n",\r\ntime2pixels(start), cpu2y(cpu)+width, width, type);\r\nfprintf(svgfile, "</g>\n");\r\n}\r\nstatic char *HzToHuman(unsigned long hz)\r\n{\r\nstatic char buffer[1024];\r\nunsigned long long Hz;\r\nmemset(buffer, 0, 1024);\r\nHz = hz;\r\nsprintf(buffer, "%9lli", Hz);\r\nif (Hz > 1000)\r\nsprintf(buffer, " %6lli Mhz", (Hz+500)/1000);\r\nif (Hz > 1500000)\r\nsprintf(buffer, " %6.2f Ghz", (Hz+5000.0)/1000000);\r\nif (Hz == turbo_frequency)\r\nsprintf(buffer, "Turbo");\r\nreturn buffer;\r\n}\r\nvoid svg_pstate(int cpu, u64 start, u64 end, u64 freq)\r\n{\r\ndouble height = 0;\r\nif (!svgfile)\r\nreturn;\r\nfprintf(svgfile, "<g>\n");\r\nif (max_freq)\r\nheight = freq * 1.0 / max_freq * (SLOT_HEIGHT + SLOT_MULT);\r\nheight = 1 + cpu2y(cpu) + SLOT_MULT + SLOT_HEIGHT - height;\r\nfprintf(svgfile, "<line x1=\"%4.8f\" x2=\"%4.8f\" y1=\"%4.1f\" y2=\"%4.1f\" class=\"pstate\"/>\n",\r\ntime2pixels(start), time2pixels(end), height, height);\r\nfprintf(svgfile, "<text x=\"%4.8f\" y=\"%4.8f\" font-size=\"0.25pt\">%s</text>\n",\r\ntime2pixels(start), height+0.9, HzToHuman(freq));\r\nfprintf(svgfile, "</g>\n");\r\n}\r\nvoid svg_partial_wakeline(u64 start, int row1, char *desc1, int row2, char *desc2, const char *backtrace)\r\n{\r\ndouble height;\r\nif (!svgfile)\r\nreturn;\r\nfprintf(svgfile, "<g>\n");\r\nfprintf(svgfile, "<title>%s wakes up %s</title>\n",\r\ndesc1 ? desc1 : "?",\r\ndesc2 ? desc2 : "?");\r\nif (backtrace)\r\nfprintf(svgfile, "<desc>%s</desc>\n", backtrace);\r\nif (row1 < row2) {\r\nif (row1) {\r\nfprintf(svgfile, "<line x1=\"%4.8f\" y1=\"%4.2f\" x2=\"%4.8f\" y2=\"%4.2f\" style=\"stroke:rgb(32,255,32);stroke-width:0.009\"/>\n",\r\ntime2pixels(start), row1 * SLOT_MULT + SLOT_HEIGHT, time2pixels(start), row1 * SLOT_MULT + SLOT_HEIGHT + SLOT_MULT/32);\r\nif (desc2)\r\nfprintf(svgfile, "<g transform=\"translate(%4.8f,%4.8f)\"><text transform=\"rotate(90)\" font-size=\"0.02pt\">%s &gt;</text></g>\n",\r\ntime2pixels(start), row1 * SLOT_MULT + SLOT_HEIGHT + SLOT_HEIGHT/48, desc2);\r\n}\r\nif (row2) {\r\nfprintf(svgfile, "<line x1=\"%4.8f\" y1=\"%4.2f\" x2=\"%4.8f\" y2=\"%4.2f\" style=\"stroke:rgb(32,255,32);stroke-width:0.009\"/>\n",\r\ntime2pixels(start), row2 * SLOT_MULT - SLOT_MULT/32, time2pixels(start), row2 * SLOT_MULT);\r\nif (desc1)\r\nfprintf(svgfile, "<g transform=\"translate(%4.8f,%4.8f)\"><text transform=\"rotate(90)\" font-size=\"0.02pt\">%s &gt;</text></g>\n",\r\ntime2pixels(start), row2 * SLOT_MULT - SLOT_MULT/32, desc1);\r\n}\r\n} else {\r\nif (row2) {\r\nfprintf(svgfile, "<line x1=\"%4.8f\" y1=\"%4.2f\" x2=\"%4.8f\" y2=\"%4.2f\" style=\"stroke:rgb(32,255,32);stroke-width:0.009\"/>\n",\r\ntime2pixels(start), row2 * SLOT_MULT + SLOT_HEIGHT, time2pixels(start), row2 * SLOT_MULT + SLOT_HEIGHT + SLOT_MULT/32);\r\nif (desc1)\r\nfprintf(svgfile, "<g transform=\"translate(%4.8f,%4.8f)\"><text transform=\"rotate(90)\" font-size=\"0.02pt\">%s &lt;</text></g>\n",\r\ntime2pixels(start), row2 * SLOT_MULT + SLOT_HEIGHT + SLOT_MULT/48, desc1);\r\n}\r\nif (row1) {\r\nfprintf(svgfile, "<line x1=\"%4.8f\" y1=\"%4.2f\" x2=\"%4.8f\" y2=\"%4.2f\" style=\"stroke:rgb(32,255,32);stroke-width:0.009\"/>\n",\r\ntime2pixels(start), row1 * SLOT_MULT - SLOT_MULT/32, time2pixels(start), row1 * SLOT_MULT);\r\nif (desc2)\r\nfprintf(svgfile, "<g transform=\"translate(%4.8f,%4.8f)\"><text transform=\"rotate(90)\" font-size=\"0.02pt\">%s &lt;</text></g>\n",\r\ntime2pixels(start), row1 * SLOT_MULT - SLOT_HEIGHT/32, desc2);\r\n}\r\n}\r\nheight = row1 * SLOT_MULT;\r\nif (row2 > row1)\r\nheight += SLOT_HEIGHT;\r\nif (row1)\r\nfprintf(svgfile, "<circle cx=\"%4.8f\" cy=\"%4.2f\" r = \"0.01\" style=\"fill:rgb(32,255,32)\"/>\n",\r\ntime2pixels(start), height);\r\nfprintf(svgfile, "</g>\n");\r\n}\r\nvoid svg_wakeline(u64 start, int row1, int row2, const char *backtrace)\r\n{\r\ndouble height;\r\nif (!svgfile)\r\nreturn;\r\nfprintf(svgfile, "<g>\n");\r\nif (backtrace)\r\nfprintf(svgfile, "<desc>%s</desc>\n", backtrace);\r\nif (row1 < row2)\r\nfprintf(svgfile, "<line x1=\"%4.8f\" y1=\"%4.2f\" x2=\"%4.8f\" y2=\"%4.2f\" style=\"stroke:rgb(32,255,32);stroke-width:0.009\"/>\n",\r\ntime2pixels(start), row1 * SLOT_MULT + SLOT_HEIGHT, time2pixels(start), row2 * SLOT_MULT);\r\nelse\r\nfprintf(svgfile, "<line x1=\"%4.8f\" y1=\"%4.2f\" x2=\"%4.8f\" y2=\"%4.2f\" style=\"stroke:rgb(32,255,32);stroke-width:0.009\"/>\n",\r\ntime2pixels(start), row2 * SLOT_MULT + SLOT_HEIGHT, time2pixels(start), row1 * SLOT_MULT);\r\nheight = row1 * SLOT_MULT;\r\nif (row2 > row1)\r\nheight += SLOT_HEIGHT;\r\nfprintf(svgfile, "<circle cx=\"%4.8f\" cy=\"%4.2f\" r = \"0.01\" style=\"fill:rgb(32,255,32)\"/>\n",\r\ntime2pixels(start), height);\r\nfprintf(svgfile, "</g>\n");\r\n}\r\nvoid svg_interrupt(u64 start, int row, const char *backtrace)\r\n{\r\nif (!svgfile)\r\nreturn;\r\nfprintf(svgfile, "<g>\n");\r\nfprintf(svgfile, "<title>Wakeup from interrupt</title>\n");\r\nif (backtrace)\r\nfprintf(svgfile, "<desc>%s</desc>\n", backtrace);\r\nfprintf(svgfile, "<circle cx=\"%4.8f\" cy=\"%4.2f\" r = \"0.01\" style=\"fill:rgb(255,128,128)\"/>\n",\r\ntime2pixels(start), row * SLOT_MULT);\r\nfprintf(svgfile, "<circle cx=\"%4.8f\" cy=\"%4.2f\" r = \"0.01\" style=\"fill:rgb(255,128,128)\"/>\n",\r\ntime2pixels(start), row * SLOT_MULT + SLOT_HEIGHT);\r\nfprintf(svgfile, "</g>\n");\r\n}\r\nvoid svg_text(int Yslot, u64 start, const char *text)\r\n{\r\nif (!svgfile)\r\nreturn;\r\nfprintf(svgfile, "<text x=\"%4.8f\" y=\"%4.8f\">%s</text>\n",\r\ntime2pixels(start), Yslot * SLOT_MULT+SLOT_HEIGHT/2, text);\r\n}\r\nstatic void svg_legenda_box(int X, const char *text, const char *style)\r\n{\r\ndouble boxsize;\r\nboxsize = SLOT_HEIGHT / 2;\r\nfprintf(svgfile, "<rect x=\"%i\" width=\"%4.8f\" y=\"0\" height=\"%4.1f\" class=\"%s\"/>\n",\r\nX, boxsize, boxsize, style);\r\nfprintf(svgfile, "<text transform=\"translate(%4.8f, %4.8f)\" font-size=\"%4.8fpt\">%s</text>\n",\r\nX + boxsize + 5, boxsize, 0.8 * boxsize, text);\r\n}\r\nvoid svg_legenda(void)\r\n{\r\nif (!svgfile)\r\nreturn;\r\nfprintf(svgfile, "<g>\n");\r\nsvg_legenda_box(0, "Running", "sample");\r\nsvg_legenda_box(100, "Idle","c1");\r\nsvg_legenda_box(200, "Deeper Idle", "c3");\r\nsvg_legenda_box(350, "Deepest Idle", "c6");\r\nsvg_legenda_box(550, "Sleeping", "process2");\r\nsvg_legenda_box(650, "Waiting for cpu", "waiting");\r\nsvg_legenda_box(800, "Blocked on IO", "blocked");\r\nfprintf(svgfile, "</g>\n");\r\n}\r\nvoid svg_time_grid(void)\r\n{\r\nu64 i;\r\nif (!svgfile)\r\nreturn;\r\ni = first_time;\r\nwhile (i < last_time) {\r\nint color = 220;\r\ndouble thickness = 0.075;\r\nif ((i % 100000000) == 0) {\r\nthickness = 0.5;\r\ncolor = 192;\r\n}\r\nif ((i % 1000000000) == 0) {\r\nthickness = 2.0;\r\ncolor = 128;\r\n}\r\nfprintf(svgfile, "<line x1=\"%4.8f\" y1=\"%4.2f\" x2=\"%4.8f\" y2=\"%" PRIu64 "\" style=\"stroke:rgb(%i,%i,%i);stroke-width:%1.3f\"/>\n",\r\ntime2pixels(i), SLOT_MULT/2, time2pixels(i), total_height, color, color, color, thickness);\r\ni += 10000000;\r\n}\r\n}\r\nvoid svg_close(void)\r\n{\r\nif (svgfile) {\r\nfprintf(svgfile, "</svg>\n");\r\nfclose(svgfile);\r\nsvgfile = NULL;\r\n}\r\n}\r\nstatic void scan_thread_topology(int *map, struct topology *t, int cpu, int *pos)\r\n{\r\nint i;\r\nint thr;\r\nfor (i = 0; i < t->sib_thr_nr; i++) {\r\nif (!test_bit(cpu, cpumask_bits(&t->sib_thr[i])))\r\ncontinue;\r\nfor_each_set_bit(thr,\r\ncpumask_bits(&t->sib_thr[i]),\r\nMAX_NR_CPUS)\r\nif (map[thr] == -1)\r\nmap[thr] = (*pos)++;\r\n}\r\n}\r\nstatic void scan_core_topology(int *map, struct topology *t)\r\n{\r\nint pos = 0;\r\nint i;\r\nint cpu;\r\nfor (i = 0; i < t->sib_core_nr; i++)\r\nfor_each_set_bit(cpu,\r\ncpumask_bits(&t->sib_core[i]),\r\nMAX_NR_CPUS)\r\nscan_thread_topology(map, t, cpu, &pos);\r\n}\r\nstatic int str_to_bitmap(char *s, cpumask_t *b)\r\n{\r\nint i;\r\nint ret = 0;\r\nstruct cpu_map *m;\r\nint c;\r\nm = cpu_map__new(s);\r\nif (!m)\r\nreturn -1;\r\nfor (i = 0; i < m->nr; i++) {\r\nc = m->map[i];\r\nif (c >= MAX_NR_CPUS) {\r\nret = -1;\r\nbreak;\r\n}\r\nset_bit(c, cpumask_bits(b));\r\n}\r\ncpu_map__delete(m);\r\nreturn ret;\r\n}\r\nint svg_build_topology_map(char *sib_core, int sib_core_nr,\r\nchar *sib_thr, int sib_thr_nr)\r\n{\r\nint i;\r\nstruct topology t;\r\nt.sib_core_nr = sib_core_nr;\r\nt.sib_thr_nr = sib_thr_nr;\r\nt.sib_core = calloc(sib_core_nr, sizeof(cpumask_t));\r\nt.sib_thr = calloc(sib_thr_nr, sizeof(cpumask_t));\r\nif (!t.sib_core || !t.sib_thr) {\r\nfprintf(stderr, "topology: no memory\n");\r\ngoto exit;\r\n}\r\nfor (i = 0; i < sib_core_nr; i++) {\r\nif (str_to_bitmap(sib_core, &t.sib_core[i])) {\r\nfprintf(stderr, "topology: can't parse siblings map\n");\r\ngoto exit;\r\n}\r\nsib_core += strlen(sib_core) + 1;\r\n}\r\nfor (i = 0; i < sib_thr_nr; i++) {\r\nif (str_to_bitmap(sib_thr, &t.sib_thr[i])) {\r\nfprintf(stderr, "topology: can't parse siblings map\n");\r\ngoto exit;\r\n}\r\nsib_thr += strlen(sib_thr) + 1;\r\n}\r\ntopology_map = malloc(sizeof(int) * MAX_NR_CPUS);\r\nif (!topology_map) {\r\nfprintf(stderr, "topology: no memory\n");\r\ngoto exit;\r\n}\r\nfor (i = 0; i < MAX_NR_CPUS; i++)\r\ntopology_map[i] = -1;\r\nscan_core_topology(topology_map, &t);\r\nreturn 0;\r\nexit:\r\nzfree(&t.sib_core);\r\nzfree(&t.sib_thr);\r\nreturn -1;\r\n}
