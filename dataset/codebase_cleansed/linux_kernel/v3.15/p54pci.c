static int p54p_upload_firmware(struct ieee80211_hw *dev)\r\n{\r\nstruct p54p_priv *priv = dev->priv;\r\n__le32 reg;\r\nint err;\r\n__le32 *data;\r\nu32 remains, left, device_addr;\r\nP54P_WRITE(int_enable, cpu_to_le32(0));\r\nP54P_READ(int_enable);\r\nudelay(10);\r\nreg = P54P_READ(ctrl_stat);\r\nreg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RESET);\r\nreg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RAMBOOT);\r\nP54P_WRITE(ctrl_stat, reg);\r\nP54P_READ(ctrl_stat);\r\nudelay(10);\r\nreg |= cpu_to_le32(ISL38XX_CTRL_STAT_RESET);\r\nP54P_WRITE(ctrl_stat, reg);\r\nwmb();\r\nudelay(10);\r\nreg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RESET);\r\nP54P_WRITE(ctrl_stat, reg);\r\nwmb();\r\nmdelay(10);\r\nerr = p54_parse_firmware(dev, priv->firmware);\r\nif (err)\r\nreturn err;\r\nif (priv->common.fw_interface != FW_LM86) {\r\ndev_err(&priv->pdev->dev, "wrong firmware, "\r\n"please get a LM86(PCI) firmware a try again.\n");\r\nreturn -EINVAL;\r\n}\r\ndata = (__le32 *) priv->firmware->data;\r\nremains = priv->firmware->size;\r\ndevice_addr = ISL38XX_DEV_FIRMWARE_ADDR;\r\nwhile (remains) {\r\nu32 i = 0;\r\nleft = min((u32)0x1000, remains);\r\nP54P_WRITE(direct_mem_base, cpu_to_le32(device_addr));\r\nP54P_READ(int_enable);\r\ndevice_addr += 0x1000;\r\nwhile (i < left) {\r\nP54P_WRITE(direct_mem_win[i], *data++);\r\ni += sizeof(u32);\r\n}\r\nremains -= left;\r\nP54P_READ(int_enable);\r\n}\r\nreg = P54P_READ(ctrl_stat);\r\nreg &= cpu_to_le32(~ISL38XX_CTRL_STAT_CLKRUN);\r\nreg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RESET);\r\nreg |= cpu_to_le32(ISL38XX_CTRL_STAT_RAMBOOT);\r\nP54P_WRITE(ctrl_stat, reg);\r\nP54P_READ(ctrl_stat);\r\nudelay(10);\r\nreg |= cpu_to_le32(ISL38XX_CTRL_STAT_RESET);\r\nP54P_WRITE(ctrl_stat, reg);\r\nwmb();\r\nudelay(10);\r\nreg &= cpu_to_le32(~ISL38XX_CTRL_STAT_RESET);\r\nP54P_WRITE(ctrl_stat, reg);\r\nwmb();\r\nudelay(10);\r\nmdelay(100);\r\nreturn 0;\r\n}\r\nstatic void p54p_refill_rx_ring(struct ieee80211_hw *dev,\r\nint ring_index, struct p54p_desc *ring, u32 ring_limit,\r\nstruct sk_buff **rx_buf, u32 index)\r\n{\r\nstruct p54p_priv *priv = dev->priv;\r\nstruct p54p_ring_control *ring_control = priv->ring_control;\r\nu32 limit, idx, i;\r\nidx = le32_to_cpu(ring_control->host_idx[ring_index]);\r\nlimit = idx;\r\nlimit -= index;\r\nlimit = ring_limit - limit;\r\ni = idx % ring_limit;\r\nwhile (limit-- > 1) {\r\nstruct p54p_desc *desc = &ring[i];\r\nif (!desc->host_addr) {\r\nstruct sk_buff *skb;\r\ndma_addr_t mapping;\r\nskb = dev_alloc_skb(priv->common.rx_mtu + 32);\r\nif (!skb)\r\nbreak;\r\nmapping = pci_map_single(priv->pdev,\r\nskb_tail_pointer(skb),\r\npriv->common.rx_mtu + 32,\r\nPCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(priv->pdev, mapping)) {\r\ndev_kfree_skb_any(skb);\r\ndev_err(&priv->pdev->dev,\r\n"RX DMA Mapping error\n");\r\nbreak;\r\n}\r\ndesc->host_addr = cpu_to_le32(mapping);\r\ndesc->device_addr = 0;\r\ndesc->len = cpu_to_le16(priv->common.rx_mtu + 32);\r\ndesc->flags = 0;\r\nrx_buf[i] = skb;\r\n}\r\ni++;\r\nidx++;\r\ni %= ring_limit;\r\n}\r\nwmb();\r\nring_control->host_idx[ring_index] = cpu_to_le32(idx);\r\n}\r\nstatic void p54p_check_rx_ring(struct ieee80211_hw *dev, u32 *index,\r\nint ring_index, struct p54p_desc *ring, u32 ring_limit,\r\nstruct sk_buff **rx_buf)\r\n{\r\nstruct p54p_priv *priv = dev->priv;\r\nstruct p54p_ring_control *ring_control = priv->ring_control;\r\nstruct p54p_desc *desc;\r\nu32 idx, i;\r\ni = (*index) % ring_limit;\r\n(*index) = idx = le32_to_cpu(ring_control->device_idx[ring_index]);\r\nidx %= ring_limit;\r\nwhile (i != idx) {\r\nu16 len;\r\nstruct sk_buff *skb;\r\ndma_addr_t dma_addr;\r\ndesc = &ring[i];\r\nlen = le16_to_cpu(desc->len);\r\nskb = rx_buf[i];\r\nif (!skb) {\r\ni++;\r\ni %= ring_limit;\r\ncontinue;\r\n}\r\nif (unlikely(len > priv->common.rx_mtu)) {\r\nif (net_ratelimit())\r\ndev_err(&priv->pdev->dev, "rx'd frame size "\r\n"exceeds length threshold.\n");\r\nlen = priv->common.rx_mtu;\r\n}\r\ndma_addr = le32_to_cpu(desc->host_addr);\r\npci_dma_sync_single_for_cpu(priv->pdev, dma_addr,\r\npriv->common.rx_mtu + 32, PCI_DMA_FROMDEVICE);\r\nskb_put(skb, len);\r\nif (p54_rx(dev, skb)) {\r\npci_unmap_single(priv->pdev, dma_addr,\r\npriv->common.rx_mtu + 32, PCI_DMA_FROMDEVICE);\r\nrx_buf[i] = NULL;\r\ndesc->host_addr = cpu_to_le32(0);\r\n} else {\r\nskb_trim(skb, 0);\r\npci_dma_sync_single_for_device(priv->pdev, dma_addr,\r\npriv->common.rx_mtu + 32, PCI_DMA_FROMDEVICE);\r\ndesc->len = cpu_to_le16(priv->common.rx_mtu + 32);\r\n}\r\ni++;\r\ni %= ring_limit;\r\n}\r\np54p_refill_rx_ring(dev, ring_index, ring, ring_limit, rx_buf, *index);\r\n}\r\nstatic void p54p_check_tx_ring(struct ieee80211_hw *dev, u32 *index,\r\nint ring_index, struct p54p_desc *ring, u32 ring_limit,\r\nstruct sk_buff **tx_buf)\r\n{\r\nstruct p54p_priv *priv = dev->priv;\r\nstruct p54p_ring_control *ring_control = priv->ring_control;\r\nstruct p54p_desc *desc;\r\nstruct sk_buff *skb;\r\nu32 idx, i;\r\ni = (*index) % ring_limit;\r\n(*index) = idx = le32_to_cpu(ring_control->device_idx[ring_index]);\r\nidx %= ring_limit;\r\nwhile (i != idx) {\r\ndesc = &ring[i];\r\nskb = tx_buf[i];\r\ntx_buf[i] = NULL;\r\npci_unmap_single(priv->pdev, le32_to_cpu(desc->host_addr),\r\nle16_to_cpu(desc->len), PCI_DMA_TODEVICE);\r\ndesc->host_addr = 0;\r\ndesc->device_addr = 0;\r\ndesc->len = 0;\r\ndesc->flags = 0;\r\nif (skb && FREE_AFTER_TX(skb))\r\np54_free_skb(dev, skb);\r\ni++;\r\ni %= ring_limit;\r\n}\r\n}\r\nstatic void p54p_tasklet(unsigned long dev_id)\r\n{\r\nstruct ieee80211_hw *dev = (struct ieee80211_hw *)dev_id;\r\nstruct p54p_priv *priv = dev->priv;\r\nstruct p54p_ring_control *ring_control = priv->ring_control;\r\np54p_check_tx_ring(dev, &priv->tx_idx_mgmt, 3, ring_control->tx_mgmt,\r\nARRAY_SIZE(ring_control->tx_mgmt),\r\npriv->tx_buf_mgmt);\r\np54p_check_tx_ring(dev, &priv->tx_idx_data, 1, ring_control->tx_data,\r\nARRAY_SIZE(ring_control->tx_data),\r\npriv->tx_buf_data);\r\np54p_check_rx_ring(dev, &priv->rx_idx_mgmt, 2, ring_control->rx_mgmt,\r\nARRAY_SIZE(ring_control->rx_mgmt), priv->rx_buf_mgmt);\r\np54p_check_rx_ring(dev, &priv->rx_idx_data, 0, ring_control->rx_data,\r\nARRAY_SIZE(ring_control->rx_data), priv->rx_buf_data);\r\nwmb();\r\nP54P_WRITE(dev_int, cpu_to_le32(ISL38XX_DEV_INT_UPDATE));\r\n}\r\nstatic irqreturn_t p54p_interrupt(int irq, void *dev_id)\r\n{\r\nstruct ieee80211_hw *dev = dev_id;\r\nstruct p54p_priv *priv = dev->priv;\r\n__le32 reg;\r\nreg = P54P_READ(int_ident);\r\nif (unlikely(reg == cpu_to_le32(0xFFFFFFFF))) {\r\ngoto out;\r\n}\r\nP54P_WRITE(int_ack, reg);\r\nreg &= P54P_READ(int_enable);\r\nif (reg & cpu_to_le32(ISL38XX_INT_IDENT_UPDATE))\r\ntasklet_schedule(&priv->tasklet);\r\nelse if (reg & cpu_to_le32(ISL38XX_INT_IDENT_INIT))\r\ncomplete(&priv->boot_comp);\r\nout:\r\nreturn reg ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void p54p_tx(struct ieee80211_hw *dev, struct sk_buff *skb)\r\n{\r\nunsigned long flags;\r\nstruct p54p_priv *priv = dev->priv;\r\nstruct p54p_ring_control *ring_control = priv->ring_control;\r\nstruct p54p_desc *desc;\r\ndma_addr_t mapping;\r\nu32 idx, i;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nidx = le32_to_cpu(ring_control->host_idx[1]);\r\ni = idx % ARRAY_SIZE(ring_control->tx_data);\r\nmapping = pci_map_single(priv->pdev, skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(priv->pdev, mapping)) {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\np54_free_skb(dev, skb);\r\ndev_err(&priv->pdev->dev, "TX DMA mapping error\n");\r\nreturn ;\r\n}\r\npriv->tx_buf_data[i] = skb;\r\ndesc = &ring_control->tx_data[i];\r\ndesc->host_addr = cpu_to_le32(mapping);\r\ndesc->device_addr = ((struct p54_hdr *)skb->data)->req_id;\r\ndesc->len = cpu_to_le16(skb->len);\r\ndesc->flags = 0;\r\nwmb();\r\nring_control->host_idx[1] = cpu_to_le32(idx + 1);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nP54P_WRITE(dev_int, cpu_to_le32(ISL38XX_DEV_INT_UPDATE));\r\nP54P_READ(dev_int);\r\n}\r\nstatic void p54p_stop(struct ieee80211_hw *dev)\r\n{\r\nstruct p54p_priv *priv = dev->priv;\r\nstruct p54p_ring_control *ring_control = priv->ring_control;\r\nunsigned int i;\r\nstruct p54p_desc *desc;\r\nP54P_WRITE(int_enable, cpu_to_le32(0));\r\nP54P_READ(int_enable);\r\nudelay(10);\r\nfree_irq(priv->pdev->irq, dev);\r\ntasklet_kill(&priv->tasklet);\r\nP54P_WRITE(dev_int, cpu_to_le32(ISL38XX_DEV_INT_RESET));\r\nfor (i = 0; i < ARRAY_SIZE(priv->rx_buf_data); i++) {\r\ndesc = &ring_control->rx_data[i];\r\nif (desc->host_addr)\r\npci_unmap_single(priv->pdev,\r\nle32_to_cpu(desc->host_addr),\r\npriv->common.rx_mtu + 32,\r\nPCI_DMA_FROMDEVICE);\r\nkfree_skb(priv->rx_buf_data[i]);\r\npriv->rx_buf_data[i] = NULL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(priv->rx_buf_mgmt); i++) {\r\ndesc = &ring_control->rx_mgmt[i];\r\nif (desc->host_addr)\r\npci_unmap_single(priv->pdev,\r\nle32_to_cpu(desc->host_addr),\r\npriv->common.rx_mtu + 32,\r\nPCI_DMA_FROMDEVICE);\r\nkfree_skb(priv->rx_buf_mgmt[i]);\r\npriv->rx_buf_mgmt[i] = NULL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(priv->tx_buf_data); i++) {\r\ndesc = &ring_control->tx_data[i];\r\nif (desc->host_addr)\r\npci_unmap_single(priv->pdev,\r\nle32_to_cpu(desc->host_addr),\r\nle16_to_cpu(desc->len),\r\nPCI_DMA_TODEVICE);\r\np54_free_skb(dev, priv->tx_buf_data[i]);\r\npriv->tx_buf_data[i] = NULL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(priv->tx_buf_mgmt); i++) {\r\ndesc = &ring_control->tx_mgmt[i];\r\nif (desc->host_addr)\r\npci_unmap_single(priv->pdev,\r\nle32_to_cpu(desc->host_addr),\r\nle16_to_cpu(desc->len),\r\nPCI_DMA_TODEVICE);\r\np54_free_skb(dev, priv->tx_buf_mgmt[i]);\r\npriv->tx_buf_mgmt[i] = NULL;\r\n}\r\nmemset(ring_control, 0, sizeof(*ring_control));\r\n}\r\nstatic int p54p_open(struct ieee80211_hw *dev)\r\n{\r\nstruct p54p_priv *priv = dev->priv;\r\nint err;\r\ninit_completion(&priv->boot_comp);\r\nerr = request_irq(priv->pdev->irq, p54p_interrupt,\r\nIRQF_SHARED, "p54pci", dev);\r\nif (err) {\r\ndev_err(&priv->pdev->dev, "failed to register IRQ handler\n");\r\nreturn err;\r\n}\r\nmemset(priv->ring_control, 0, sizeof(*priv->ring_control));\r\nerr = p54p_upload_firmware(dev);\r\nif (err) {\r\nfree_irq(priv->pdev->irq, dev);\r\nreturn err;\r\n}\r\npriv->rx_idx_data = priv->tx_idx_data = 0;\r\npriv->rx_idx_mgmt = priv->tx_idx_mgmt = 0;\r\np54p_refill_rx_ring(dev, 0, priv->ring_control->rx_data,\r\nARRAY_SIZE(priv->ring_control->rx_data), priv->rx_buf_data, 0);\r\np54p_refill_rx_ring(dev, 2, priv->ring_control->rx_mgmt,\r\nARRAY_SIZE(priv->ring_control->rx_mgmt), priv->rx_buf_mgmt, 0);\r\nP54P_WRITE(ring_control_base, cpu_to_le32(priv->ring_control_dma));\r\nP54P_READ(ring_control_base);\r\nwmb();\r\nudelay(10);\r\nP54P_WRITE(int_enable, cpu_to_le32(ISL38XX_INT_IDENT_INIT));\r\nP54P_READ(int_enable);\r\nwmb();\r\nudelay(10);\r\nP54P_WRITE(dev_int, cpu_to_le32(ISL38XX_DEV_INT_RESET));\r\nP54P_READ(dev_int);\r\nif (!wait_for_completion_interruptible_timeout(&priv->boot_comp, HZ)) {\r\nwiphy_err(dev->wiphy, "Cannot boot firmware!\n");\r\np54p_stop(dev);\r\nreturn -ETIMEDOUT;\r\n}\r\nP54P_WRITE(int_enable, cpu_to_le32(ISL38XX_INT_IDENT_UPDATE));\r\nP54P_READ(int_enable);\r\nwmb();\r\nudelay(10);\r\nP54P_WRITE(dev_int, cpu_to_le32(ISL38XX_DEV_INT_UPDATE));\r\nP54P_READ(dev_int);\r\nwmb();\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic void p54p_firmware_step2(const struct firmware *fw,\r\nvoid *context)\r\n{\r\nstruct p54p_priv *priv = context;\r\nstruct ieee80211_hw *dev = priv->common.hw;\r\nstruct pci_dev *pdev = priv->pdev;\r\nint err;\r\nif (!fw) {\r\ndev_err(&pdev->dev, "Cannot find firmware (isl3886pci)\n");\r\nerr = -ENOENT;\r\ngoto out;\r\n}\r\npriv->firmware = fw;\r\nerr = p54p_open(dev);\r\nif (err)\r\ngoto out;\r\nerr = p54_read_eeprom(dev);\r\np54p_stop(dev);\r\nif (err)\r\ngoto out;\r\nerr = p54_register_common(dev, &pdev->dev);\r\nif (err)\r\ngoto out;\r\nout:\r\ncomplete(&priv->fw_loaded);\r\nif (err) {\r\nstruct device *parent = pdev->dev.parent;\r\nif (parent)\r\ndevice_lock(parent);\r\ndevice_release_driver(&pdev->dev);\r\nif (parent)\r\ndevice_unlock(parent);\r\n}\r\npci_dev_put(pdev);\r\n}\r\nstatic int p54p_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct p54p_priv *priv;\r\nstruct ieee80211_hw *dev;\r\nunsigned long mem_addr, mem_len;\r\nint err;\r\npci_dev_get(pdev);\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot enable new PCI device\n");\r\nreturn err;\r\n}\r\nmem_addr = pci_resource_start(pdev, 0);\r\nmem_len = pci_resource_len(pdev, 0);\r\nif (mem_len < sizeof(struct p54p_csr)) {\r\ndev_err(&pdev->dev, "Too short PCI resources\n");\r\nerr = -ENODEV;\r\ngoto err_disable_dev;\r\n}\r\nerr = pci_request_regions(pdev, "p54pci");\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot obtain PCI resources\n");\r\ngoto err_disable_dev;\r\n}\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (!err)\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_err(&pdev->dev, "No suitable DMA available\n");\r\ngoto err_free_reg;\r\n}\r\npci_set_master(pdev);\r\npci_try_set_mwi(pdev);\r\npci_write_config_byte(pdev, 0x40, 0);\r\npci_write_config_byte(pdev, 0x41, 0);\r\ndev = p54_init_common(sizeof(*priv));\r\nif (!dev) {\r\ndev_err(&pdev->dev, "ieee80211 alloc failed\n");\r\nerr = -ENOMEM;\r\ngoto err_free_reg;\r\n}\r\npriv = dev->priv;\r\npriv->pdev = pdev;\r\ninit_completion(&priv->fw_loaded);\r\nSET_IEEE80211_DEV(dev, &pdev->dev);\r\npci_set_drvdata(pdev, dev);\r\npriv->map = ioremap(mem_addr, mem_len);\r\nif (!priv->map) {\r\ndev_err(&pdev->dev, "Cannot map device memory\n");\r\nerr = -ENOMEM;\r\ngoto err_free_dev;\r\n}\r\npriv->ring_control = pci_alloc_consistent(pdev, sizeof(*priv->ring_control),\r\n&priv->ring_control_dma);\r\nif (!priv->ring_control) {\r\ndev_err(&pdev->dev, "Cannot allocate rings\n");\r\nerr = -ENOMEM;\r\ngoto err_iounmap;\r\n}\r\npriv->common.open = p54p_open;\r\npriv->common.stop = p54p_stop;\r\npriv->common.tx = p54p_tx;\r\nspin_lock_init(&priv->lock);\r\ntasklet_init(&priv->tasklet, p54p_tasklet, (unsigned long)dev);\r\nerr = request_firmware_nowait(THIS_MODULE, 1, "isl3886pci",\r\n&priv->pdev->dev, GFP_KERNEL,\r\npriv, p54p_firmware_step2);\r\nif (!err)\r\nreturn 0;\r\npci_free_consistent(pdev, sizeof(*priv->ring_control),\r\npriv->ring_control, priv->ring_control_dma);\r\nerr_iounmap:\r\niounmap(priv->map);\r\nerr_free_dev:\r\np54_free_common(dev);\r\nerr_free_reg:\r\npci_release_regions(pdev);\r\nerr_disable_dev:\r\npci_disable_device(pdev);\r\npci_dev_put(pdev);\r\nreturn err;\r\n}\r\nstatic void p54p_remove(struct pci_dev *pdev)\r\n{\r\nstruct ieee80211_hw *dev = pci_get_drvdata(pdev);\r\nstruct p54p_priv *priv;\r\nif (!dev)\r\nreturn;\r\npriv = dev->priv;\r\nwait_for_completion(&priv->fw_loaded);\r\np54_unregister_common(dev);\r\nrelease_firmware(priv->firmware);\r\npci_free_consistent(pdev, sizeof(*priv->ring_control),\r\npriv->ring_control, priv->ring_control_dma);\r\niounmap(priv->map);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\np54_free_common(dev);\r\n}\r\nstatic int p54p_suspend(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, PCI_D3hot);\r\npci_disable_device(pdev);\r\nreturn 0;\r\n}\r\nstatic int p54p_resume(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nint err;\r\nerr = pci_reenable_device(pdev);\r\nif (err)\r\nreturn err;\r\nreturn pci_set_power_state(pdev, PCI_D0);\r\n}
