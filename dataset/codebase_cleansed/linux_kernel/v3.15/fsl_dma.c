static void fsl_dma_abort_stream(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags;\r\nsnd_pcm_stream_lock_irqsave(substream, flags);\r\nif (snd_pcm_running(substream))\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock_irqrestore(substream, flags);\r\n}\r\nstatic void fsl_dma_update_pointers(struct fsl_dma_private *dma_private)\r\n{\r\nstruct fsl_dma_link_descriptor *link =\r\n&dma_private->link[dma_private->current_link];\r\nif (dma_private->substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nlink->source_addr = cpu_to_be32(dma_private->dma_buf_next);\r\n#ifdef CONFIG_PHYS_64BIT\r\nlink->source_attr = cpu_to_be32(CCSR_DMA_ATR_SNOOP |\r\nupper_32_bits(dma_private->dma_buf_next));\r\n#endif\r\n} else {\r\nlink->dest_addr = cpu_to_be32(dma_private->dma_buf_next);\r\n#ifdef CONFIG_PHYS_64BIT\r\nlink->dest_attr = cpu_to_be32(CCSR_DMA_ATR_SNOOP |\r\nupper_32_bits(dma_private->dma_buf_next));\r\n#endif\r\n}\r\ndma_private->dma_buf_next += dma_private->period_size;\r\nif (dma_private->dma_buf_next >= dma_private->dma_buf_end)\r\ndma_private->dma_buf_next = dma_private->dma_buf_phys;\r\nif (++dma_private->current_link >= NUM_DMA_LINKS)\r\ndma_private->current_link = 0;\r\n}\r\nstatic irqreturn_t fsl_dma_isr(int irq, void *dev_id)\r\n{\r\nstruct fsl_dma_private *dma_private = dev_id;\r\nstruct snd_pcm_substream *substream = dma_private->substream;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct device *dev = rtd->platform->dev;\r\nstruct ccsr_dma_channel __iomem *dma_channel = dma_private->dma_channel;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 sr, sr2 = 0;\r\nsr = in_be32(&dma_channel->sr);\r\nif (sr & CCSR_DMA_SR_TE) {\r\ndev_err(dev, "dma transmit error\n");\r\nfsl_dma_abort_stream(substream);\r\nsr2 |= CCSR_DMA_SR_TE;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sr & CCSR_DMA_SR_CH)\r\nret = IRQ_HANDLED;\r\nif (sr & CCSR_DMA_SR_PE) {\r\ndev_err(dev, "dma programming error\n");\r\nfsl_dma_abort_stream(substream);\r\nsr2 |= CCSR_DMA_SR_PE;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sr & CCSR_DMA_SR_EOLNI) {\r\nsr2 |= CCSR_DMA_SR_EOLNI;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sr & CCSR_DMA_SR_CB)\r\nret = IRQ_HANDLED;\r\nif (sr & CCSR_DMA_SR_EOSI) {\r\nsnd_pcm_period_elapsed(substream);\r\nif (dma_private->num_periods != NUM_DMA_LINKS)\r\nfsl_dma_update_pointers(dma_private);\r\nsr2 |= CCSR_DMA_SR_EOSI;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sr & CCSR_DMA_SR_EOLSI) {\r\nsr2 |= CCSR_DMA_SR_EOLSI;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sr2)\r\nout_be32(&dma_channel->sr, sr2);\r\nreturn ret;\r\n}\r\nstatic int fsl_dma_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint ret;\r\nret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(36));\r\nif (ret)\r\nreturn ret;\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {\r\nret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, card->dev,\r\nfsl_dma_hardware.buffer_bytes_max,\r\n&pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->dma_buffer);\r\nif (ret) {\r\ndev_err(card->dev, "can't alloc playback dma buffer\n");\r\nreturn ret;\r\n}\r\n}\r\nif (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {\r\nret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, card->dev,\r\nfsl_dma_hardware.buffer_bytes_max,\r\n&pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->dma_buffer);\r\nif (ret) {\r\ndev_err(card->dev, "can't alloc capture dma buffer\n");\r\nsnd_dma_free_pages(&pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->dma_buffer);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_dma_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct device *dev = rtd->platform->dev;\r\nstruct dma_object *dma =\r\ncontainer_of(rtd->platform->driver, struct dma_object, dai);\r\nstruct fsl_dma_private *dma_private;\r\nstruct ccsr_dma_channel __iomem *dma_channel;\r\ndma_addr_t ld_buf_phys;\r\nu64 temp_link;\r\nu32 mr;\r\nunsigned int channel;\r\nint ret = 0;\r\nunsigned int i;\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0) {\r\ndev_err(dev, "invalid buffer size\n");\r\nreturn ret;\r\n}\r\nchannel = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0 : 1;\r\nif (dma->assigned) {\r\ndev_err(dev, "dma channel already assigned\n");\r\nreturn -EBUSY;\r\n}\r\ndma_private = dma_alloc_coherent(dev, sizeof(struct fsl_dma_private),\r\n&ld_buf_phys, GFP_KERNEL);\r\nif (!dma_private) {\r\ndev_err(dev, "can't allocate dma private data\n");\r\nreturn -ENOMEM;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndma_private->ssi_sxx_phys = dma->ssi_stx_phys;\r\nelse\r\ndma_private->ssi_sxx_phys = dma->ssi_srx_phys;\r\ndma_private->ssi_fifo_depth = dma->ssi_fifo_depth;\r\ndma_private->dma_channel = dma->channel;\r\ndma_private->irq = dma->irq;\r\ndma_private->substream = substream;\r\ndma_private->ld_buf_phys = ld_buf_phys;\r\ndma_private->dma_buf_phys = substream->dma_buffer.addr;\r\nret = request_irq(dma_private->irq, fsl_dma_isr, 0, "fsldma-audio",\r\ndma_private);\r\nif (ret) {\r\ndev_err(dev, "can't register ISR for IRQ %u (ret=%i)\n",\r\ndma_private->irq, ret);\r\ndma_free_coherent(dev, sizeof(struct fsl_dma_private),\r\ndma_private, dma_private->ld_buf_phys);\r\nreturn ret;\r\n}\r\ndma->assigned = 1;\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nsnd_soc_set_runtime_hwparams(substream, &fsl_dma_hardware);\r\nruntime->private_data = dma_private;\r\ndma_channel = dma_private->dma_channel;\r\ntemp_link = dma_private->ld_buf_phys +\r\nsizeof(struct fsl_dma_link_descriptor);\r\nfor (i = 0; i < NUM_DMA_LINKS; i++) {\r\ndma_private->link[i].next = cpu_to_be64(temp_link);\r\ntemp_link += sizeof(struct fsl_dma_link_descriptor);\r\n}\r\ndma_private->link[i - 1].next = cpu_to_be64(dma_private->ld_buf_phys);\r\nout_be32(&dma_channel->clndar,\r\nCCSR_DMA_CLNDAR_ADDR(dma_private->ld_buf_phys));\r\nout_be32(&dma_channel->eclndar,\r\nCCSR_DMA_ECLNDAR_ADDR(dma_private->ld_buf_phys));\r\nout_be32(&dma_channel->bcr, 0);\r\nmr = in_be32(&dma_channel->mr) &\r\n~(CCSR_DMA_MR_CA | CCSR_DMA_MR_DAHE | CCSR_DMA_MR_SAHE);\r\nmr |= CCSR_DMA_MR_EOSIE | CCSR_DMA_MR_EIE | CCSR_DMA_MR_EMP_EN |\r\nCCSR_DMA_MR_EMS_EN;\r\nmr |= (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?\r\nCCSR_DMA_MR_DAHE : CCSR_DMA_MR_SAHE;\r\nout_be32(&dma_channel->mr, mr);\r\nreturn 0;\r\n}\r\nstatic int fsl_dma_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_dma_private *dma_private = runtime->private_data;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct device *dev = rtd->platform->dev;\r\nunsigned int sample_bits =\r\nsnd_pcm_format_physical_width(params_format(hw_params));\r\nunsigned int sample_bytes = sample_bits / 8;\r\ndma_addr_t ssi_sxx_phys = dma_private->ssi_sxx_phys;\r\nsize_t buffer_size = params_buffer_bytes(hw_params);\r\nsize_t period_size = params_period_bytes(hw_params);\r\ndma_addr_t temp_addr = substream->dma_buffer.addr;\r\nstruct ccsr_dma_channel __iomem *dma_channel = dma_private->dma_channel;\r\nu32 mr;\r\nunsigned int i;\r\ndma_private->period_size = period_size;\r\ndma_private->num_periods = params_periods(hw_params);\r\ndma_private->dma_buf_end = dma_private->dma_buf_phys + buffer_size;\r\ndma_private->dma_buf_next = dma_private->dma_buf_phys +\r\n(NUM_DMA_LINKS * period_size);\r\nif (dma_private->dma_buf_next >= dma_private->dma_buf_end)\r\ndma_private->dma_buf_next = dma_private->dma_buf_phys;\r\nmr = in_be32(&dma_channel->mr) & ~(CCSR_DMA_MR_BWC_MASK |\r\nCCSR_DMA_MR_SAHTS_MASK | CCSR_DMA_MR_DAHTS_MASK);\r\nswitch (sample_bits) {\r\ncase 8:\r\nmr |= CCSR_DMA_MR_DAHTS_1 | CCSR_DMA_MR_SAHTS_1;\r\nssi_sxx_phys += 3;\r\nbreak;\r\ncase 16:\r\nmr |= CCSR_DMA_MR_DAHTS_2 | CCSR_DMA_MR_SAHTS_2;\r\nssi_sxx_phys += 2;\r\nbreak;\r\ncase 32:\r\nmr |= CCSR_DMA_MR_DAHTS_4 | CCSR_DMA_MR_SAHTS_4;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "unsupported sample size %u\n", sample_bits);\r\nreturn -EINVAL;\r\n}\r\nmr |= CCSR_DMA_MR_BWC((dma_private->ssi_fifo_depth - 2) * sample_bytes);\r\nout_be32(&dma_channel->mr, mr);\r\nfor (i = 0; i < NUM_DMA_LINKS; i++) {\r\nstruct fsl_dma_link_descriptor *link = &dma_private->link[i];\r\nlink->count = cpu_to_be32(period_size);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nlink->source_addr = cpu_to_be32(temp_addr);\r\nlink->source_attr = cpu_to_be32(CCSR_DMA_ATR_SNOOP |\r\nupper_32_bits(temp_addr));\r\nlink->dest_addr = cpu_to_be32(ssi_sxx_phys);\r\nlink->dest_attr = cpu_to_be32(CCSR_DMA_ATR_NOSNOOP |\r\nupper_32_bits(ssi_sxx_phys));\r\n} else {\r\nlink->source_addr = cpu_to_be32(ssi_sxx_phys);\r\nlink->source_attr = cpu_to_be32(CCSR_DMA_ATR_NOSNOOP |\r\nupper_32_bits(ssi_sxx_phys));\r\nlink->dest_addr = cpu_to_be32(temp_addr);\r\nlink->dest_attr = cpu_to_be32(CCSR_DMA_ATR_SNOOP |\r\nupper_32_bits(temp_addr));\r\n}\r\ntemp_addr += period_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t fsl_dma_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_dma_private *dma_private = runtime->private_data;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct device *dev = rtd->platform->dev;\r\nstruct ccsr_dma_channel __iomem *dma_channel = dma_private->dma_channel;\r\ndma_addr_t position;\r\nsnd_pcm_uframes_t frames;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nposition = in_be32(&dma_channel->sar);\r\n#ifdef CONFIG_PHYS_64BIT\r\nposition |= (u64)(in_be32(&dma_channel->satr) &\r\nCCSR_DMA_ATR_ESAD_MASK) << 32;\r\n#endif\r\n} else {\r\nposition = in_be32(&dma_channel->dar);\r\n#ifdef CONFIG_PHYS_64BIT\r\nposition |= (u64)(in_be32(&dma_channel->datr) &\r\nCCSR_DMA_ATR_ESAD_MASK) << 32;\r\n#endif\r\n}\r\nif (!position)\r\nreturn 0;\r\nif ((position < dma_private->dma_buf_phys) ||\r\n(position > dma_private->dma_buf_end)) {\r\ndev_err(dev, "dma pointer is out of range, halting stream\n");\r\nreturn SNDRV_PCM_POS_XRUN;\r\n}\r\nframes = bytes_to_frames(runtime, position - dma_private->dma_buf_phys);\r\nif (frames == runtime->buffer_size)\r\nframes = 0;\r\nreturn frames;\r\n}\r\nstatic int fsl_dma_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_dma_private *dma_private = runtime->private_data;\r\nif (dma_private) {\r\nstruct ccsr_dma_channel __iomem *dma_channel;\r\ndma_channel = dma_private->dma_channel;\r\nout_be32(&dma_channel->mr, CCSR_DMA_MR_CA);\r\nout_be32(&dma_channel->mr, 0);\r\nout_be32(&dma_channel->sr, -1);\r\nout_be32(&dma_channel->clndar, 0);\r\nout_be32(&dma_channel->eclndar, 0);\r\nout_be32(&dma_channel->satr, 0);\r\nout_be32(&dma_channel->sar, 0);\r\nout_be32(&dma_channel->datr, 0);\r\nout_be32(&dma_channel->dar, 0);\r\nout_be32(&dma_channel->bcr, 0);\r\nout_be32(&dma_channel->nlndar, 0);\r\nout_be32(&dma_channel->enlndar, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_dma_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsl_dma_private *dma_private = runtime->private_data;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct device *dev = rtd->platform->dev;\r\nstruct dma_object *dma =\r\ncontainer_of(rtd->platform->driver, struct dma_object, dai);\r\nif (dma_private) {\r\nif (dma_private->irq)\r\nfree_irq(dma_private->irq, dma_private);\r\ndma_free_coherent(dev, sizeof(struct fsl_dma_private),\r\ndma_private, dma_private->ld_buf_phys);\r\nsubstream->runtime->private_data = NULL;\r\n}\r\ndma->assigned = 0;\r\nreturn 0;\r\n}\r\nstatic void fsl_dma_free_dma_buffers(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(pcm->streams); i++) {\r\nsubstream = pcm->streams[i].substream;\r\nif (substream) {\r\nsnd_dma_free_pages(&substream->dma_buffer);\r\nsubstream->dma_buffer.area = NULL;\r\nsubstream->dma_buffer.addr = 0;\r\n}\r\n}\r\n}\r\nstatic struct device_node *find_ssi_node(struct device_node *dma_channel_np)\r\n{\r\nstruct device_node *ssi_np, *np;\r\nfor_each_compatible_node(ssi_np, NULL, "fsl,mpc8610-ssi") {\r\nnp = of_parse_phandle(ssi_np, "fsl,playback-dma", 0);\r\nof_node_put(np);\r\nif (np == dma_channel_np)\r\nreturn ssi_np;\r\nnp = of_parse_phandle(ssi_np, "fsl,capture-dma", 0);\r\nof_node_put(np);\r\nif (np == dma_channel_np)\r\nreturn ssi_np;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int fsl_soc_dma_probe(struct platform_device *pdev)\r\n{\r\nstruct dma_object *dma;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *ssi_np;\r\nstruct resource res;\r\nconst uint32_t *iprop;\r\nint ret;\r\nssi_np = find_ssi_node(np);\r\nif (!ssi_np) {\r\ndev_err(&pdev->dev, "cannot find parent SSI node\n");\r\nreturn -ENODEV;\r\n}\r\nret = of_address_to_resource(ssi_np, 0, &res);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not determine resources for %s\n",\r\nssi_np->full_name);\r\nof_node_put(ssi_np);\r\nreturn ret;\r\n}\r\ndma = kzalloc(sizeof(*dma) + strlen(np->full_name), GFP_KERNEL);\r\nif (!dma) {\r\ndev_err(&pdev->dev, "could not allocate dma object\n");\r\nof_node_put(ssi_np);\r\nreturn -ENOMEM;\r\n}\r\nstrcpy(dma->path, np->full_name);\r\ndma->dai.ops = &fsl_dma_ops;\r\ndma->dai.pcm_new = fsl_dma_new;\r\ndma->dai.pcm_free = fsl_dma_free_dma_buffers;\r\ndma->ssi_stx_phys = res.start + offsetof(struct ccsr_ssi, stx0);\r\ndma->ssi_srx_phys = res.start + offsetof(struct ccsr_ssi, srx0);\r\niprop = of_get_property(ssi_np, "fsl,fifo-depth", NULL);\r\nif (iprop)\r\ndma->ssi_fifo_depth = be32_to_cpup(iprop);\r\nelse\r\ndma->ssi_fifo_depth = 8;\r\nof_node_put(ssi_np);\r\nret = snd_soc_register_platform(&pdev->dev, &dma->dai);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not register platform\n");\r\nkfree(dma);\r\nreturn ret;\r\n}\r\ndma->channel = of_iomap(np, 0);\r\ndma->irq = irq_of_parse_and_map(np, 0);\r\ndev_set_drvdata(&pdev->dev, dma);\r\nreturn 0;\r\n}\r\nstatic int fsl_soc_dma_remove(struct platform_device *pdev)\r\n{\r\nstruct dma_object *dma = dev_get_drvdata(&pdev->dev);\r\nsnd_soc_unregister_platform(&pdev->dev);\r\niounmap(dma->channel);\r\nirq_dispose_mapping(dma->irq);\r\nkfree(dma);\r\nreturn 0;\r\n}
