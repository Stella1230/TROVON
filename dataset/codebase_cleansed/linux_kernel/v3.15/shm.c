void shm_init_ns(struct ipc_namespace *ns)\r\n{\r\nns->shm_ctlmax = SHMMAX;\r\nns->shm_ctlall = SHMALL;\r\nns->shm_ctlmni = SHMMNI;\r\nns->shm_rmid_forced = 0;\r\nns->shm_tot = 0;\r\nipc_init_ids(&shm_ids(ns));\r\n}\r\nstatic void do_shm_rmid(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\r\n{\r\nstruct shmid_kernel *shp;\r\nshp = container_of(ipcp, struct shmid_kernel, shm_perm);\r\nif (shp->shm_nattch) {\r\nshp->shm_perm.mode |= SHM_DEST;\r\nshp->shm_perm.key = IPC_PRIVATE;\r\nshm_unlock(shp);\r\n} else\r\nshm_destroy(ns, shp);\r\n}\r\nvoid shm_exit_ns(struct ipc_namespace *ns)\r\n{\r\nfree_ipcs(ns, &shm_ids(ns), do_shm_rmid);\r\nidr_destroy(&ns->ids[IPC_SHM_IDS].ipcs_idr);\r\n}\r\nstatic int __init ipc_ns_init(void)\r\n{\r\nshm_init_ns(&init_ipc_ns);\r\nreturn 0;\r\n}\r\nvoid __init shm_init(void)\r\n{\r\nipc_init_proc_interface("sysvipc/shm",\r\n#if BITS_PER_LONG <= 32\r\n" key shmid perms size cpid lpid nattch uid gid cuid cgid atime dtime ctime rss swap\n",\r\n#else\r\n" key shmid perms size cpid lpid nattch uid gid cuid cgid atime dtime ctime rss swap\n",\r\n#endif\r\nIPC_SHM_IDS, sysvipc_shm_proc_show);\r\n}\r\nstatic inline struct shmid_kernel *shm_obtain_object(struct ipc_namespace *ns, int id)\r\n{\r\nstruct kern_ipc_perm *ipcp = ipc_obtain_object(&shm_ids(ns), id);\r\nif (IS_ERR(ipcp))\r\nreturn ERR_CAST(ipcp);\r\nreturn container_of(ipcp, struct shmid_kernel, shm_perm);\r\n}\r\nstatic inline struct shmid_kernel *shm_obtain_object_check(struct ipc_namespace *ns, int id)\r\n{\r\nstruct kern_ipc_perm *ipcp = ipc_obtain_object_check(&shm_ids(ns), id);\r\nif (IS_ERR(ipcp))\r\nreturn ERR_CAST(ipcp);\r\nreturn container_of(ipcp, struct shmid_kernel, shm_perm);\r\n}\r\nstatic inline struct shmid_kernel *shm_lock(struct ipc_namespace *ns, int id)\r\n{\r\nstruct kern_ipc_perm *ipcp = ipc_lock(&shm_ids(ns), id);\r\nif (IS_ERR(ipcp))\r\nreturn (struct shmid_kernel *)ipcp;\r\nreturn container_of(ipcp, struct shmid_kernel, shm_perm);\r\n}\r\nstatic inline void shm_lock_by_ptr(struct shmid_kernel *ipcp)\r\n{\r\nrcu_read_lock();\r\nipc_lock_object(&ipcp->shm_perm);\r\n}\r\nstatic void shm_rcu_free(struct rcu_head *head)\r\n{\r\nstruct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);\r\nstruct shmid_kernel *shp = ipc_rcu_to_struct(p);\r\nsecurity_shm_free(shp);\r\nipc_rcu_free(head);\r\n}\r\nstatic inline void shm_rmid(struct ipc_namespace *ns, struct shmid_kernel *s)\r\n{\r\nipc_rmid(&shm_ids(ns), &s->shm_perm);\r\n}\r\nstatic void shm_open(struct vm_area_struct *vma)\r\n{\r\nstruct file *file = vma->vm_file;\r\nstruct shm_file_data *sfd = shm_file_data(file);\r\nstruct shmid_kernel *shp;\r\nshp = shm_lock(sfd->ns, sfd->id);\r\nBUG_ON(IS_ERR(shp));\r\nshp->shm_atim = get_seconds();\r\nshp->shm_lprid = task_tgid_vnr(current);\r\nshp->shm_nattch++;\r\nshm_unlock(shp);\r\n}\r\nstatic void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\r\n{\r\nstruct file *shm_file;\r\nshm_file = shp->shm_file;\r\nshp->shm_file = NULL;\r\nns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nshm_rmid(ns, shp);\r\nshm_unlock(shp);\r\nif (!is_file_hugepages(shm_file))\r\nshmem_lock(shm_file, 0, shp->mlock_user);\r\nelse if (shp->mlock_user)\r\nuser_shm_unlock(file_inode(shm_file)->i_size, shp->mlock_user);\r\nfput(shm_file);\r\nipc_rcu_putref(shp, shm_rcu_free);\r\n}\r\nstatic bool shm_may_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\r\n{\r\nreturn (shp->shm_nattch == 0) &&\r\n(ns->shm_rmid_forced ||\r\n(shp->shm_perm.mode & SHM_DEST));\r\n}\r\nstatic void shm_close(struct vm_area_struct *vma)\r\n{\r\nstruct file *file = vma->vm_file;\r\nstruct shm_file_data *sfd = shm_file_data(file);\r\nstruct shmid_kernel *shp;\r\nstruct ipc_namespace *ns = sfd->ns;\r\ndown_write(&shm_ids(ns).rwsem);\r\nshp = shm_lock(ns, sfd->id);\r\nBUG_ON(IS_ERR(shp));\r\nshp->shm_lprid = task_tgid_vnr(current);\r\nshp->shm_dtim = get_seconds();\r\nshp->shm_nattch--;\r\nif (shm_may_destroy(ns, shp))\r\nshm_destroy(ns, shp);\r\nelse\r\nshm_unlock(shp);\r\nup_write(&shm_ids(ns).rwsem);\r\n}\r\nstatic int shm_try_destroy_current(int id, void *p, void *data)\r\n{\r\nstruct ipc_namespace *ns = data;\r\nstruct kern_ipc_perm *ipcp = p;\r\nstruct shmid_kernel *shp = container_of(ipcp, struct shmid_kernel, shm_perm);\r\nif (shp->shm_creator != current)\r\nreturn 0;\r\nshp->shm_creator = NULL;\r\nif (!ns->shm_rmid_forced)\r\nreturn 0;\r\nif (shm_may_destroy(ns, shp)) {\r\nshm_lock_by_ptr(shp);\r\nshm_destroy(ns, shp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int shm_try_destroy_orphaned(int id, void *p, void *data)\r\n{\r\nstruct ipc_namespace *ns = data;\r\nstruct kern_ipc_perm *ipcp = p;\r\nstruct shmid_kernel *shp = container_of(ipcp, struct shmid_kernel, shm_perm);\r\nif (shp->shm_creator != NULL)\r\nreturn 0;\r\nif (shm_may_destroy(ns, shp)) {\r\nshm_lock_by_ptr(shp);\r\nshm_destroy(ns, shp);\r\n}\r\nreturn 0;\r\n}\r\nvoid shm_destroy_orphaned(struct ipc_namespace *ns)\r\n{\r\ndown_write(&shm_ids(ns).rwsem);\r\nif (shm_ids(ns).in_use)\r\nidr_for_each(&shm_ids(ns).ipcs_idr, &shm_try_destroy_orphaned, ns);\r\nup_write(&shm_ids(ns).rwsem);\r\n}\r\nvoid exit_shm(struct task_struct *task)\r\n{\r\nstruct ipc_namespace *ns = task->nsproxy->ipc_ns;\r\nif (shm_ids(ns).in_use == 0)\r\nreturn;\r\ndown_write(&shm_ids(ns).rwsem);\r\nif (shm_ids(ns).in_use)\r\nidr_for_each(&shm_ids(ns).ipcs_idr, &shm_try_destroy_current, ns);\r\nup_write(&shm_ids(ns).rwsem);\r\n}\r\nstatic int shm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct file *file = vma->vm_file;\r\nstruct shm_file_data *sfd = shm_file_data(file);\r\nreturn sfd->vm_ops->fault(vma, vmf);\r\n}\r\nstatic int shm_set_policy(struct vm_area_struct *vma, struct mempolicy *new)\r\n{\r\nstruct file *file = vma->vm_file;\r\nstruct shm_file_data *sfd = shm_file_data(file);\r\nint err = 0;\r\nif (sfd->vm_ops->set_policy)\r\nerr = sfd->vm_ops->set_policy(vma, new);\r\nreturn err;\r\n}\r\nstatic struct mempolicy *shm_get_policy(struct vm_area_struct *vma,\r\nunsigned long addr)\r\n{\r\nstruct file *file = vma->vm_file;\r\nstruct shm_file_data *sfd = shm_file_data(file);\r\nstruct mempolicy *pol = NULL;\r\nif (sfd->vm_ops->get_policy)\r\npol = sfd->vm_ops->get_policy(vma, addr);\r\nelse if (vma->vm_policy)\r\npol = vma->vm_policy;\r\nreturn pol;\r\n}\r\nstatic int shm_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct shm_file_data *sfd = shm_file_data(file);\r\nint ret;\r\nret = sfd->file->f_op->mmap(sfd->file, vma);\r\nif (ret != 0)\r\nreturn ret;\r\nsfd->vm_ops = vma->vm_ops;\r\n#ifdef CONFIG_MMU\r\nBUG_ON(!sfd->vm_ops->fault);\r\n#endif\r\nvma->vm_ops = &shm_vm_ops;\r\nshm_open(vma);\r\nreturn ret;\r\n}\r\nstatic int shm_release(struct inode *ino, struct file *file)\r\n{\r\nstruct shm_file_data *sfd = shm_file_data(file);\r\nput_ipc_ns(sfd->ns);\r\nshm_file_data(file) = NULL;\r\nkfree(sfd);\r\nreturn 0;\r\n}\r\nstatic int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)\r\n{\r\nstruct shm_file_data *sfd = shm_file_data(file);\r\nif (!sfd->file->f_op->fsync)\r\nreturn -EINVAL;\r\nreturn sfd->file->f_op->fsync(sfd->file, start, end, datasync);\r\n}\r\nstatic long shm_fallocate(struct file *file, int mode, loff_t offset,\r\nloff_t len)\r\n{\r\nstruct shm_file_data *sfd = shm_file_data(file);\r\nif (!sfd->file->f_op->fallocate)\r\nreturn -EOPNOTSUPP;\r\nreturn sfd->file->f_op->fallocate(file, mode, offset, len);\r\n}\r\nstatic unsigned long shm_get_unmapped_area(struct file *file,\r\nunsigned long addr, unsigned long len, unsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nstruct shm_file_data *sfd = shm_file_data(file);\r\nreturn sfd->file->f_op->get_unmapped_area(sfd->file, addr, len,\r\npgoff, flags);\r\n}\r\nint is_file_shm_hugepages(struct file *file)\r\n{\r\nreturn file->f_op == &shm_file_operations_huge;\r\n}\r\nstatic int newseg(struct ipc_namespace *ns, struct ipc_params *params)\r\n{\r\nkey_t key = params->key;\r\nint shmflg = params->flg;\r\nsize_t size = params->u.size;\r\nint error;\r\nstruct shmid_kernel *shp;\r\nsize_t numpages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nstruct file *file;\r\nchar name[13];\r\nint id;\r\nvm_flags_t acctflag = 0;\r\nif (size < SHMMIN || size > ns->shm_ctlmax)\r\nreturn -EINVAL;\r\nif (ns->shm_tot + numpages > ns->shm_ctlall)\r\nreturn -ENOSPC;\r\nshp = ipc_rcu_alloc(sizeof(*shp));\r\nif (!shp)\r\nreturn -ENOMEM;\r\nshp->shm_perm.key = key;\r\nshp->shm_perm.mode = (shmflg & S_IRWXUGO);\r\nshp->mlock_user = NULL;\r\nshp->shm_perm.security = NULL;\r\nerror = security_shm_alloc(shp);\r\nif (error) {\r\nipc_rcu_putref(shp, ipc_rcu_free);\r\nreturn error;\r\n}\r\nsprintf(name, "SYSV%08x", key);\r\nif (shmflg & SHM_HUGETLB) {\r\nstruct hstate *hs;\r\nsize_t hugesize;\r\nhs = hstate_sizelog((shmflg >> SHM_HUGE_SHIFT) & SHM_HUGE_MASK);\r\nif (!hs) {\r\nerror = -EINVAL;\r\ngoto no_file;\r\n}\r\nhugesize = ALIGN(size, huge_page_size(hs));\r\nif (shmflg & SHM_NORESERVE)\r\nacctflag = VM_NORESERVE;\r\nfile = hugetlb_file_setup(name, hugesize, acctflag,\r\n&shp->mlock_user, HUGETLB_SHMFS_INODE,\r\n(shmflg >> SHM_HUGE_SHIFT) & SHM_HUGE_MASK);\r\n} else {\r\nif ((shmflg & SHM_NORESERVE) &&\r\nsysctl_overcommit_memory != OVERCOMMIT_NEVER)\r\nacctflag = VM_NORESERVE;\r\nfile = shmem_file_setup(name, size, acctflag);\r\n}\r\nerror = PTR_ERR(file);\r\nif (IS_ERR(file))\r\ngoto no_file;\r\nid = ipc_addid(&shm_ids(ns), &shp->shm_perm, ns->shm_ctlmni);\r\nif (id < 0) {\r\nerror = id;\r\ngoto no_id;\r\n}\r\nshp->shm_cprid = task_tgid_vnr(current);\r\nshp->shm_lprid = 0;\r\nshp->shm_atim = shp->shm_dtim = 0;\r\nshp->shm_ctim = get_seconds();\r\nshp->shm_segsz = size;\r\nshp->shm_nattch = 0;\r\nshp->shm_file = file;\r\nshp->shm_creator = current;\r\nfile_inode(file)->i_ino = shp->shm_perm.id;\r\nns->shm_tot += numpages;\r\nerror = shp->shm_perm.id;\r\nipc_unlock_object(&shp->shm_perm);\r\nrcu_read_unlock();\r\nreturn error;\r\nno_id:\r\nif (is_file_hugepages(file) && shp->mlock_user)\r\nuser_shm_unlock(size, shp->mlock_user);\r\nfput(file);\r\nno_file:\r\nipc_rcu_putref(shp, shm_rcu_free);\r\nreturn error;\r\n}\r\nstatic inline int shm_security(struct kern_ipc_perm *ipcp, int shmflg)\r\n{\r\nstruct shmid_kernel *shp;\r\nshp = container_of(ipcp, struct shmid_kernel, shm_perm);\r\nreturn security_shm_associate(shp, shmflg);\r\n}\r\nstatic inline int shm_more_checks(struct kern_ipc_perm *ipcp,\r\nstruct ipc_params *params)\r\n{\r\nstruct shmid_kernel *shp;\r\nshp = container_of(ipcp, struct shmid_kernel, shm_perm);\r\nif (shp->shm_segsz < params->u.size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)\r\n{\r\nswitch (version) {\r\ncase IPC_64:\r\nreturn copy_to_user(buf, in, sizeof(*in));\r\ncase IPC_OLD:\r\n{\r\nstruct shmid_ds out;\r\nmemset(&out, 0, sizeof(out));\r\nipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);\r\nout.shm_segsz = in->shm_segsz;\r\nout.shm_atime = in->shm_atime;\r\nout.shm_dtime = in->shm_dtime;\r\nout.shm_ctime = in->shm_ctime;\r\nout.shm_cpid = in->shm_cpid;\r\nout.shm_lpid = in->shm_lpid;\r\nout.shm_nattch = in->shm_nattch;\r\nreturn copy_to_user(buf, &out, sizeof(out));\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline unsigned long\r\ncopy_shmid_from_user(struct shmid64_ds *out, void __user *buf, int version)\r\n{\r\nswitch (version) {\r\ncase IPC_64:\r\nif (copy_from_user(out, buf, sizeof(*out)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IPC_OLD:\r\n{\r\nstruct shmid_ds tbuf_old;\r\nif (copy_from_user(&tbuf_old, buf, sizeof(tbuf_old)))\r\nreturn -EFAULT;\r\nout->shm_perm.uid = tbuf_old.shm_perm.uid;\r\nout->shm_perm.gid = tbuf_old.shm_perm.gid;\r\nout->shm_perm.mode = tbuf_old.shm_perm.mode;\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline unsigned long copy_shminfo_to_user(void __user *buf, struct shminfo64 *in, int version)\r\n{\r\nswitch (version) {\r\ncase IPC_64:\r\nreturn copy_to_user(buf, in, sizeof(*in));\r\ncase IPC_OLD:\r\n{\r\nstruct shminfo out;\r\nif (in->shmmax > INT_MAX)\r\nout.shmmax = INT_MAX;\r\nelse\r\nout.shmmax = (int)in->shmmax;\r\nout.shmmin = in->shmmin;\r\nout.shmmni = in->shmmni;\r\nout.shmseg = in->shmseg;\r\nout.shmall = in->shmall;\r\nreturn copy_to_user(buf, &out, sizeof(out));\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void shm_add_rss_swap(struct shmid_kernel *shp,\r\nunsigned long *rss_add, unsigned long *swp_add)\r\n{\r\nstruct inode *inode;\r\ninode = file_inode(shp->shm_file);\r\nif (is_file_hugepages(shp->shm_file)) {\r\nstruct address_space *mapping = inode->i_mapping;\r\nstruct hstate *h = hstate_file(shp->shm_file);\r\n*rss_add += pages_per_huge_page(h) * mapping->nrpages;\r\n} else {\r\n#ifdef CONFIG_SHMEM\r\nstruct shmem_inode_info *info = SHMEM_I(inode);\r\nspin_lock(&info->lock);\r\n*rss_add += inode->i_mapping->nrpages;\r\n*swp_add += info->swapped;\r\nspin_unlock(&info->lock);\r\n#else\r\n*rss_add += inode->i_mapping->nrpages;\r\n#endif\r\n}\r\n}\r\nstatic void shm_get_stat(struct ipc_namespace *ns, unsigned long *rss,\r\nunsigned long *swp)\r\n{\r\nint next_id;\r\nint total, in_use;\r\n*rss = 0;\r\n*swp = 0;\r\nin_use = shm_ids(ns).in_use;\r\nfor (total = 0, next_id = 0; total < in_use; next_id++) {\r\nstruct kern_ipc_perm *ipc;\r\nstruct shmid_kernel *shp;\r\nipc = idr_find(&shm_ids(ns).ipcs_idr, next_id);\r\nif (ipc == NULL)\r\ncontinue;\r\nshp = container_of(ipc, struct shmid_kernel, shm_perm);\r\nshm_add_rss_swap(shp, rss, swp);\r\ntotal++;\r\n}\r\n}\r\nstatic int shmctl_down(struct ipc_namespace *ns, int shmid, int cmd,\r\nstruct shmid_ds __user *buf, int version)\r\n{\r\nstruct kern_ipc_perm *ipcp;\r\nstruct shmid64_ds shmid64;\r\nstruct shmid_kernel *shp;\r\nint err;\r\nif (cmd == IPC_SET) {\r\nif (copy_shmid_from_user(&shmid64, buf, version))\r\nreturn -EFAULT;\r\n}\r\ndown_write(&shm_ids(ns).rwsem);\r\nrcu_read_lock();\r\nipcp = ipcctl_pre_down_nolock(ns, &shm_ids(ns), shmid, cmd,\r\n&shmid64.shm_perm, 0);\r\nif (IS_ERR(ipcp)) {\r\nerr = PTR_ERR(ipcp);\r\ngoto out_unlock1;\r\n}\r\nshp = container_of(ipcp, struct shmid_kernel, shm_perm);\r\nerr = security_shm_shmctl(shp, cmd);\r\nif (err)\r\ngoto out_unlock1;\r\nswitch (cmd) {\r\ncase IPC_RMID:\r\nipc_lock_object(&shp->shm_perm);\r\ndo_shm_rmid(ns, ipcp);\r\ngoto out_up;\r\ncase IPC_SET:\r\nipc_lock_object(&shp->shm_perm);\r\nerr = ipc_update_perm(&shmid64.shm_perm, ipcp);\r\nif (err)\r\ngoto out_unlock0;\r\nshp->shm_ctim = get_seconds();\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto out_unlock1;\r\n}\r\nout_unlock0:\r\nipc_unlock_object(&shp->shm_perm);\r\nout_unlock1:\r\nrcu_read_unlock();\r\nout_up:\r\nup_write(&shm_ids(ns).rwsem);\r\nreturn err;\r\n}\r\nstatic int shmctl_nolock(struct ipc_namespace *ns, int shmid,\r\nint cmd, int version, void __user *buf)\r\n{\r\nint err;\r\nstruct shmid_kernel *shp;\r\nif (cmd == IPC_INFO || cmd == SHM_INFO) {\r\nerr = security_shm_shmctl(NULL, cmd);\r\nif (err)\r\nreturn err;\r\n}\r\nswitch (cmd) {\r\ncase IPC_INFO:\r\n{\r\nstruct shminfo64 shminfo;\r\nmemset(&shminfo, 0, sizeof(shminfo));\r\nshminfo.shmmni = shminfo.shmseg = ns->shm_ctlmni;\r\nshminfo.shmmax = ns->shm_ctlmax;\r\nshminfo.shmall = ns->shm_ctlall;\r\nshminfo.shmmin = SHMMIN;\r\nif (copy_shminfo_to_user(buf, &shminfo, version))\r\nreturn -EFAULT;\r\ndown_read(&shm_ids(ns).rwsem);\r\nerr = ipc_get_maxid(&shm_ids(ns));\r\nup_read(&shm_ids(ns).rwsem);\r\nif (err < 0)\r\nerr = 0;\r\ngoto out;\r\n}\r\ncase SHM_INFO:\r\n{\r\nstruct shm_info shm_info;\r\nmemset(&shm_info, 0, sizeof(shm_info));\r\ndown_read(&shm_ids(ns).rwsem);\r\nshm_info.used_ids = shm_ids(ns).in_use;\r\nshm_get_stat(ns, &shm_info.shm_rss, &shm_info.shm_swp);\r\nshm_info.shm_tot = ns->shm_tot;\r\nshm_info.swap_attempts = 0;\r\nshm_info.swap_successes = 0;\r\nerr = ipc_get_maxid(&shm_ids(ns));\r\nup_read(&shm_ids(ns).rwsem);\r\nif (copy_to_user(buf, &shm_info, sizeof(shm_info))) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nerr = err < 0 ? 0 : err;\r\ngoto out;\r\n}\r\ncase SHM_STAT:\r\ncase IPC_STAT:\r\n{\r\nstruct shmid64_ds tbuf;\r\nint result;\r\nrcu_read_lock();\r\nif (cmd == SHM_STAT) {\r\nshp = shm_obtain_object(ns, shmid);\r\nif (IS_ERR(shp)) {\r\nerr = PTR_ERR(shp);\r\ngoto out_unlock;\r\n}\r\nresult = shp->shm_perm.id;\r\n} else {\r\nshp = shm_obtain_object_check(ns, shmid);\r\nif (IS_ERR(shp)) {\r\nerr = PTR_ERR(shp);\r\ngoto out_unlock;\r\n}\r\nresult = 0;\r\n}\r\nerr = -EACCES;\r\nif (ipcperms(ns, &shp->shm_perm, S_IRUGO))\r\ngoto out_unlock;\r\nerr = security_shm_shmctl(shp, cmd);\r\nif (err)\r\ngoto out_unlock;\r\nmemset(&tbuf, 0, sizeof(tbuf));\r\nkernel_to_ipc64_perm(&shp->shm_perm, &tbuf.shm_perm);\r\ntbuf.shm_segsz = shp->shm_segsz;\r\ntbuf.shm_atime = shp->shm_atim;\r\ntbuf.shm_dtime = shp->shm_dtim;\r\ntbuf.shm_ctime = shp->shm_ctim;\r\ntbuf.shm_cpid = shp->shm_cprid;\r\ntbuf.shm_lpid = shp->shm_lprid;\r\ntbuf.shm_nattch = shp->shm_nattch;\r\nrcu_read_unlock();\r\nif (copy_shmid_to_user(buf, &tbuf, version))\r\nerr = -EFAULT;\r\nelse\r\nerr = result;\r\ngoto out;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nout_unlock:\r\nrcu_read_unlock();\r\nout:\r\nreturn err;\r\n}\r\nlong do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,\r\nunsigned long shmlba)\r\n{\r\nstruct shmid_kernel *shp;\r\nunsigned long addr;\r\nunsigned long size;\r\nstruct file *file;\r\nint err;\r\nunsigned long flags;\r\nunsigned long prot;\r\nint acc_mode;\r\nstruct ipc_namespace *ns;\r\nstruct shm_file_data *sfd;\r\nstruct path path;\r\nfmode_t f_mode;\r\nunsigned long populate = 0;\r\nerr = -EINVAL;\r\nif (shmid < 0)\r\ngoto out;\r\nelse if ((addr = (ulong)shmaddr)) {\r\nif (addr & (shmlba - 1)) {\r\nif (shmflg & SHM_RND)\r\naddr &= ~(shmlba - 1);\r\nelse\r\n#ifndef __ARCH_FORCE_SHMLBA\r\nif (addr & ~PAGE_MASK)\r\n#endif\r\ngoto out;\r\n}\r\nflags = MAP_SHARED | MAP_FIXED;\r\n} else {\r\nif ((shmflg & SHM_REMAP))\r\ngoto out;\r\nflags = MAP_SHARED;\r\n}\r\nif (shmflg & SHM_RDONLY) {\r\nprot = PROT_READ;\r\nacc_mode = S_IRUGO;\r\nf_mode = FMODE_READ;\r\n} else {\r\nprot = PROT_READ | PROT_WRITE;\r\nacc_mode = S_IRUGO | S_IWUGO;\r\nf_mode = FMODE_READ | FMODE_WRITE;\r\n}\r\nif (shmflg & SHM_EXEC) {\r\nprot |= PROT_EXEC;\r\nacc_mode |= S_IXUGO;\r\n}\r\nns = current->nsproxy->ipc_ns;\r\nrcu_read_lock();\r\nshp = shm_obtain_object_check(ns, shmid);\r\nif (IS_ERR(shp)) {\r\nerr = PTR_ERR(shp);\r\ngoto out_unlock;\r\n}\r\nerr = -EACCES;\r\nif (ipcperms(ns, &shp->shm_perm, acc_mode))\r\ngoto out_unlock;\r\nerr = security_shm_shmat(shp, shmaddr, shmflg);\r\nif (err)\r\ngoto out_unlock;\r\nipc_lock_object(&shp->shm_perm);\r\nif (!ipc_valid_object(&shp->shm_perm)) {\r\nipc_unlock_object(&shp->shm_perm);\r\nerr = -EIDRM;\r\ngoto out_unlock;\r\n}\r\npath = shp->shm_file->f_path;\r\npath_get(&path);\r\nshp->shm_nattch++;\r\nsize = i_size_read(path.dentry->d_inode);\r\nipc_unlock_object(&shp->shm_perm);\r\nrcu_read_unlock();\r\nerr = -ENOMEM;\r\nsfd = kzalloc(sizeof(*sfd), GFP_KERNEL);\r\nif (!sfd) {\r\npath_put(&path);\r\ngoto out_nattch;\r\n}\r\nfile = alloc_file(&path, f_mode,\r\nis_file_hugepages(shp->shm_file) ?\r\n&shm_file_operations_huge :\r\n&shm_file_operations);\r\nerr = PTR_ERR(file);\r\nif (IS_ERR(file)) {\r\nkfree(sfd);\r\npath_put(&path);\r\ngoto out_nattch;\r\n}\r\nfile->private_data = sfd;\r\nfile->f_mapping = shp->shm_file->f_mapping;\r\nsfd->id = shp->shm_perm.id;\r\nsfd->ns = get_ipc_ns(ns);\r\nsfd->file = shp->shm_file;\r\nsfd->vm_ops = NULL;\r\nerr = security_mmap_file(file, prot, flags);\r\nif (err)\r\ngoto out_fput;\r\ndown_write(&current->mm->mmap_sem);\r\nif (addr && !(shmflg & SHM_REMAP)) {\r\nerr = -EINVAL;\r\nif (find_vma_intersection(current->mm, addr, addr + size))\r\ngoto invalid;\r\nif (addr < current->mm->start_stack &&\r\naddr > current->mm->start_stack - size - PAGE_SIZE * 5)\r\ngoto invalid;\r\n}\r\naddr = do_mmap_pgoff(file, addr, size, prot, flags, 0, &populate);\r\n*raddr = addr;\r\nerr = 0;\r\nif (IS_ERR_VALUE(addr))\r\nerr = (long)addr;\r\ninvalid:\r\nup_write(&current->mm->mmap_sem);\r\nif (populate)\r\nmm_populate(addr, populate);\r\nout_fput:\r\nfput(file);\r\nout_nattch:\r\ndown_write(&shm_ids(ns).rwsem);\r\nshp = shm_lock(ns, shmid);\r\nBUG_ON(IS_ERR(shp));\r\nshp->shm_nattch--;\r\nif (shm_may_destroy(ns, shp))\r\nshm_destroy(ns, shp);\r\nelse\r\nshm_unlock(shp);\r\nup_write(&shm_ids(ns).rwsem);\r\nreturn err;\r\nout_unlock:\r\nrcu_read_unlock();\r\nout:\r\nreturn err;\r\n}\r\nstatic int sysvipc_shm_proc_show(struct seq_file *s, void *it)\r\n{\r\nstruct user_namespace *user_ns = seq_user_ns(s);\r\nstruct shmid_kernel *shp = it;\r\nunsigned long rss = 0, swp = 0;\r\nshm_add_rss_swap(shp, &rss, &swp);\r\n#if BITS_PER_LONG <= 32\r\n#define SIZE_SPEC "%10lu"\r\n#else\r\n#define SIZE_SPEC "%21lu"\r\n#endif\r\nreturn seq_printf(s,\r\n"%10d %10d %4o " SIZE_SPEC " %5u %5u "\r\n"%5lu %5u %5u %5u %5u %10lu %10lu %10lu "\r\nSIZE_SPEC " " SIZE_SPEC "\n",\r\nshp->shm_perm.key,\r\nshp->shm_perm.id,\r\nshp->shm_perm.mode,\r\nshp->shm_segsz,\r\nshp->shm_cprid,\r\nshp->shm_lprid,\r\nshp->shm_nattch,\r\nfrom_kuid_munged(user_ns, shp->shm_perm.uid),\r\nfrom_kgid_munged(user_ns, shp->shm_perm.gid),\r\nfrom_kuid_munged(user_ns, shp->shm_perm.cuid),\r\nfrom_kgid_munged(user_ns, shp->shm_perm.cgid),\r\nshp->shm_atim,\r\nshp->shm_dtim,\r\nshp->shm_ctim,\r\nrss * PAGE_SIZE,\r\nswp * PAGE_SIZE);\r\n}
