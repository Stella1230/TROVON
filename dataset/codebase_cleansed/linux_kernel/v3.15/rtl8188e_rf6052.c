void rtl8188e_RF_ChangeTxPath(struct adapter *Adapter, u16 DataRate)\r\n{\r\n}\r\nvoid rtl8188e_PHY_RF6052SetBandwidth(struct adapter *Adapter,\r\nenum ht_channel_width Bandwidth)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(Adapter);\r\nswitch (Bandwidth) {\r\ncase HT_CHANNEL_WIDTH_20:\r\npHalData->RfRegChnlVal[0] = ((pHalData->RfRegChnlVal[0] & 0xfffff3ff) | BIT(10) | BIT(11));\r\nPHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, pHalData->RfRegChnlVal[0]);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_40:\r\npHalData->RfRegChnlVal[0] = ((pHalData->RfRegChnlVal[0] & 0xfffff3ff) | BIT(10));\r\nPHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, pHalData->RfRegChnlVal[0]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid\r\nrtl8188e_PHY_RF6052SetCckTxPower(\r\nstruct adapter *Adapter,\r\nu8 *pPowerlevel)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(Adapter);\r\nstruct dm_priv *pdmpriv = &pHalData->dmpriv;\r\nstruct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;\r\nu32 TxAGC[2] = {0, 0}, tmpval = 0, pwrtrac_value;\r\nbool TurboScanOff = false;\r\nu8 idx1, idx2;\r\nu8 *ptr;\r\nu8 direction;\r\nTurboScanOff = true;\r\nif (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {\r\nTxAGC[RF_PATH_A] = 0x3f3f3f3f;\r\nTxAGC[RF_PATH_B] = 0x3f3f3f3f;\r\nTurboScanOff = true;\r\nif (TurboScanOff) {\r\nfor (idx1 = RF_PATH_A; idx1 <= RF_PATH_B; idx1++) {\r\nTxAGC[idx1] =\r\npPowerlevel[idx1] | (pPowerlevel[idx1]<<8) |\r\n(pPowerlevel[idx1]<<16) | (pPowerlevel[idx1]<<24);\r\nif (TxAGC[idx1] > 0x20 && pHalData->ExternalPA)\r\nTxAGC[idx1] = 0x20;\r\n}\r\n}\r\n} else {\r\nif (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level1) {\r\nTxAGC[RF_PATH_A] = 0x10101010;\r\nTxAGC[RF_PATH_B] = 0x10101010;\r\n} else if (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level2) {\r\nTxAGC[RF_PATH_A] = 0x00000000;\r\nTxAGC[RF_PATH_B] = 0x00000000;\r\n} else {\r\nfor (idx1 = RF_PATH_A; idx1 <= RF_PATH_B; idx1++) {\r\nTxAGC[idx1] =\r\npPowerlevel[idx1] | (pPowerlevel[idx1]<<8) |\r\n(pPowerlevel[idx1]<<16) | (pPowerlevel[idx1]<<24);\r\n}\r\nif (pHalData->EEPROMRegulatory == 0) {\r\ntmpval = (pHalData->MCSTxPowerLevelOriginalOffset[0][6]) +\r\n(pHalData->MCSTxPowerLevelOriginalOffset[0][7]<<8);\r\nTxAGC[RF_PATH_A] += tmpval;\r\ntmpval = (pHalData->MCSTxPowerLevelOriginalOffset[0][14]) +\r\n(pHalData->MCSTxPowerLevelOriginalOffset[0][15]<<24);\r\nTxAGC[RF_PATH_B] += tmpval;\r\n}\r\n}\r\n}\r\nfor (idx1 = RF_PATH_A; idx1 <= RF_PATH_B; idx1++) {\r\nptr = (u8 *)(&(TxAGC[idx1]));\r\nfor (idx2 = 0; idx2 < 4; idx2++) {\r\nif (*ptr > RF6052_MAX_TX_PWR)\r\n*ptr = RF6052_MAX_TX_PWR;\r\nptr++;\r\n}\r\n}\r\nODM_TxPwrTrackAdjust88E(&pHalData->odmpriv, 1, &direction, &pwrtrac_value);\r\nif (direction == 1) {\r\nTxAGC[0] += pwrtrac_value;\r\nTxAGC[1] += pwrtrac_value;\r\n} else if (direction == 2) {\r\nTxAGC[0] -= pwrtrac_value;\r\nTxAGC[1] -= pwrtrac_value;\r\n}\r\ntmpval = TxAGC[RF_PATH_A]&0xff;\r\nPHY_SetBBReg(Adapter, rTxAGC_A_CCK1_Mcs32, bMaskByte1, tmpval);\r\ntmpval = TxAGC[RF_PATH_A]>>8;\r\nPHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, 0xffffff00, tmpval);\r\ntmpval = TxAGC[RF_PATH_B]>>24;\r\nPHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, bMaskByte0, tmpval);\r\ntmpval = TxAGC[RF_PATH_B]&0x00ffffff;\r\nPHY_SetBBReg(Adapter, rTxAGC_B_CCK1_55_Mcs32, 0xffffff00, tmpval);\r\n}\r\nstatic void getpowerbase88e(struct adapter *Adapter, u8 *pPowerLevelOFDM,\r\nu8 *pPowerLevelBW20, u8 *pPowerLevelBW40, u8 Channel, u32 *OfdmBase, u32 *MCSBase)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(Adapter);\r\nu32 powerBase0, powerBase1;\r\nu8 i, powerlevel[2];\r\nfor (i = 0; i < 2; i++) {\r\npowerBase0 = pPowerLevelOFDM[i];\r\npowerBase0 = (powerBase0<<24) | (powerBase0<<16) | (powerBase0<<8) | powerBase0;\r\n*(OfdmBase+i) = powerBase0;\r\n}\r\nfor (i = 0; i < pHalData->NumTotalRFPath; i++) {\r\nif (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)\r\npowerlevel[i] = pPowerLevelBW20[i];\r\nelse\r\npowerlevel[i] = pPowerLevelBW40[i];\r\npowerBase1 = powerlevel[i];\r\npowerBase1 = (powerBase1<<24) | (powerBase1<<16) | (powerBase1<<8) | powerBase1;\r\n*(MCSBase+i) = powerBase1;\r\n}\r\n}\r\nstatic void get_rx_power_val_by_reg(struct adapter *Adapter, u8 Channel,\r\nu8 index, u32 *powerBase0, u32 *powerBase1,\r\nu32 *pOutWriteVal)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(Adapter);\r\nstruct dm_priv *pdmpriv = &pHalData->dmpriv;\r\nu8 i, chnlGroup = 0, pwr_diff_limit[4], customer_pwr_limit;\r\ns8 pwr_diff = 0;\r\nu32 writeVal, customer_limit, rf;\r\nu8 Regulatory = pHalData->EEPROMRegulatory;\r\nfor (rf = 0; rf < 2; rf++) {\r\nswitch (Regulatory) {\r\ncase 0:\r\nchnlGroup = 0;\r\nwriteVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf ? 8 : 0)] +\r\n((index < 2) ? powerBase0[rf] : powerBase1[rf]);\r\nbreak;\r\ncase 1:\r\nif (pHalData->pwrGroupCnt == 1)\r\nchnlGroup = 0;\r\nif (pHalData->pwrGroupCnt >= pHalData->PGMaxGroup) {\r\nif (Channel < 3)\r\nchnlGroup = 0;\r\nelse if (Channel < 6)\r\nchnlGroup = 1;\r\nelse if (Channel < 9)\r\nchnlGroup = 2;\r\nelse if (Channel < 12)\r\nchnlGroup = 3;\r\nelse if (Channel < 14)\r\nchnlGroup = 4;\r\nelse if (Channel == 14)\r\nchnlGroup = 5;\r\n}\r\nwriteVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf ? 8 : 0)] +\r\n((index < 2) ? powerBase0[rf] : powerBase1[rf]);\r\nbreak;\r\ncase 2:\r\nwriteVal = ((index < 2) ? powerBase0[rf] : powerBase1[rf]);\r\nbreak;\r\ncase 3:\r\nchnlGroup = 0;\r\nif (index < 2)\r\npwr_diff = pHalData->TxPwrLegacyHtDiff[rf][Channel-1];\r\nelse if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)\r\npwr_diff = pHalData->TxPwrHt20Diff[rf][Channel-1];\r\nif (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_40)\r\ncustomer_pwr_limit = pHalData->PwrGroupHT40[rf][Channel-1];\r\nelse\r\ncustomer_pwr_limit = pHalData->PwrGroupHT20[rf][Channel-1];\r\nif (pwr_diff >= customer_pwr_limit)\r\npwr_diff = 0;\r\nelse\r\npwr_diff = customer_pwr_limit - pwr_diff;\r\nfor (i = 0; i < 4; i++) {\r\npwr_diff_limit[i] = (u8)((pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf ? 8 : 0)]&(0x7f<<(i*8)))>>(i*8));\r\nif (pwr_diff_limit[i] > pwr_diff)\r\npwr_diff_limit[i] = pwr_diff;\r\n}\r\ncustomer_limit = (pwr_diff_limit[3]<<24) | (pwr_diff_limit[2]<<16) |\r\n(pwr_diff_limit[1]<<8) | (pwr_diff_limit[0]);\r\nwriteVal = customer_limit + ((index < 2) ? powerBase0[rf] : powerBase1[rf]);\r\nbreak;\r\ndefault:\r\nchnlGroup = 0;\r\nwriteVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf ? 8 : 0)] +\r\n((index < 2) ? powerBase0[rf] : powerBase1[rf]);\r\nbreak;\r\n}\r\nif (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level1)\r\nwriteVal = 0x14141414;\r\nelse if (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level2)\r\nwriteVal = 0x00000000;\r\nif (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_BT1)\r\nwriteVal = writeVal - 0x06060606;\r\nelse if (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_BT2)\r\nwriteVal = writeVal;\r\n*(pOutWriteVal+rf) = writeVal;\r\n}\r\n}\r\nstatic void writeOFDMPowerReg88E(struct adapter *Adapter, u8 index, u32 *pValue)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(Adapter);\r\nu16 regoffset_a[6] = {\r\nrTxAGC_A_Rate18_06, rTxAGC_A_Rate54_24,\r\nrTxAGC_A_Mcs03_Mcs00, rTxAGC_A_Mcs07_Mcs04,\r\nrTxAGC_A_Mcs11_Mcs08, rTxAGC_A_Mcs15_Mcs12};\r\nu16 regoffset_b[6] = {\r\nrTxAGC_B_Rate18_06, rTxAGC_B_Rate54_24,\r\nrTxAGC_B_Mcs03_Mcs00, rTxAGC_B_Mcs07_Mcs04,\r\nrTxAGC_B_Mcs11_Mcs08, rTxAGC_B_Mcs15_Mcs12};\r\nu8 i, rf, pwr_val[4];\r\nu32 writeVal;\r\nu16 regoffset;\r\nfor (rf = 0; rf < 2; rf++) {\r\nwriteVal = pValue[rf];\r\nfor (i = 0; i < 4; i++) {\r\npwr_val[i] = (u8)((writeVal & (0x7f<<(i*8)))>>(i*8));\r\nif (pwr_val[i] > RF6052_MAX_TX_PWR)\r\npwr_val[i] = RF6052_MAX_TX_PWR;\r\n}\r\nwriteVal = (pwr_val[3]<<24) | (pwr_val[2]<<16) | (pwr_val[1]<<8) | pwr_val[0];\r\nif (rf == 0)\r\nregoffset = regoffset_a[index];\r\nelse\r\nregoffset = regoffset_b[index];\r\nPHY_SetBBReg(Adapter, regoffset, bMaskDWord, writeVal);\r\nif (((pHalData->rf_type == RF_2T2R) &&\r\n(regoffset == rTxAGC_A_Mcs15_Mcs12 || regoffset == rTxAGC_B_Mcs15_Mcs12)) ||\r\n((pHalData->rf_type != RF_2T2R) &&\r\n(regoffset == rTxAGC_A_Mcs07_Mcs04 || regoffset == rTxAGC_B_Mcs07_Mcs04))) {\r\nwriteVal = pwr_val[3];\r\nif (regoffset == rTxAGC_A_Mcs15_Mcs12 || regoffset == rTxAGC_A_Mcs07_Mcs04)\r\nregoffset = 0xc90;\r\nif (regoffset == rTxAGC_B_Mcs15_Mcs12 || regoffset == rTxAGC_B_Mcs07_Mcs04)\r\nregoffset = 0xc98;\r\nfor (i = 0; i < 3; i++) {\r\nif (i != 2)\r\nwriteVal = (writeVal > 8) ? (writeVal-8) : 0;\r\nelse\r\nwriteVal = (writeVal > 6) ? (writeVal-6) : 0;\r\nrtw_write8(Adapter, (u32)(regoffset+i), (u8)writeVal);\r\n}\r\n}\r\n}\r\n}\r\nvoid\r\nrtl8188e_PHY_RF6052SetOFDMTxPower(\r\nstruct adapter *Adapter,\r\nu8 *pPowerLevelOFDM,\r\nu8 *pPowerLevelBW20,\r\nu8 *pPowerLevelBW40,\r\nu8 Channel)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(Adapter);\r\nu32 writeVal[2], powerBase0[2], powerBase1[2], pwrtrac_value;\r\nu8 direction;\r\nu8 index = 0;\r\ngetpowerbase88e(Adapter, pPowerLevelOFDM, pPowerLevelBW20, pPowerLevelBW40, Channel, &powerBase0[0], &powerBase1[0]);\r\nODM_TxPwrTrackAdjust88E(&pHalData->odmpriv, 0, &direction, &pwrtrac_value);\r\nfor (index = 0; index < 6; index++) {\r\nget_rx_power_val_by_reg(Adapter, Channel, index,\r\n&powerBase0[0], &powerBase1[0],\r\n&writeVal[0]);\r\nif (direction == 1) {\r\nwriteVal[0] += pwrtrac_value;\r\nwriteVal[1] += pwrtrac_value;\r\n} else if (direction == 2) {\r\nwriteVal[0] -= pwrtrac_value;\r\nwriteVal[1] -= pwrtrac_value;\r\n}\r\nwriteOFDMPowerReg88E(Adapter, index, &writeVal[0]);\r\n}\r\n}\r\nstatic int phy_RF6052_Config_ParaFile(struct adapter *Adapter)\r\n{\r\nstruct bb_reg_def *pPhyReg;\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(Adapter);\r\nu32 u4RegValue = 0;\r\nu8 eRFPath;\r\nint rtStatus = _SUCCESS;\r\nfor (eRFPath = 0; eRFPath < pHalData->NumTotalRFPath; eRFPath++) {\r\npPhyReg = &pHalData->PHYRegDef[eRFPath];\r\nswitch (eRFPath) {\r\ncase RF_PATH_A:\r\ncase RF_PATH_C:\r\nu4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs, bRFSI_RFENV);\r\nbreak;\r\ncase RF_PATH_B:\r\ncase RF_PATH_D:\r\nu4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs, bRFSI_RFENV<<16);\r\nbreak;\r\n}\r\nPHY_SetBBReg(Adapter, pPhyReg->rfintfe, bRFSI_RFENV<<16, 0x1);\r\nudelay(1);\r\nPHY_SetBBReg(Adapter, pPhyReg->rfintfo, bRFSI_RFENV, 0x1);\r\nudelay(1);\r\nPHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, b3WireAddressLength, 0x0);\r\nudelay(1);\r\nPHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, b3WireDataLength, 0x0);\r\nudelay(1);\r\nswitch (eRFPath) {\r\ncase RF_PATH_A:\r\nif (HAL_STATUS_FAILURE == ODM_ConfigRFWithHeaderFile(&pHalData->odmpriv, (enum rf_radio_path)eRFPath, (enum rf_radio_path)eRFPath))\r\nrtStatus = _FAIL;\r\nbreak;\r\ncase RF_PATH_B:\r\nif (HAL_STATUS_FAILURE == ODM_ConfigRFWithHeaderFile(&pHalData->odmpriv, (enum rf_radio_path)eRFPath, (enum rf_radio_path)eRFPath))\r\nrtStatus = _FAIL;\r\nbreak;\r\ncase RF_PATH_C:\r\nbreak;\r\ncase RF_PATH_D:\r\nbreak;\r\n}\r\n;\r\nswitch (eRFPath) {\r\ncase RF_PATH_A:\r\ncase RF_PATH_C:\r\nPHY_SetBBReg(Adapter, pPhyReg->rfintfs, bRFSI_RFENV, u4RegValue);\r\nbreak;\r\ncase RF_PATH_B:\r\ncase RF_PATH_D:\r\nPHY_SetBBReg(Adapter, pPhyReg->rfintfs, bRFSI_RFENV<<16, u4RegValue);\r\nbreak;\r\n}\r\nif (rtStatus != _SUCCESS)\r\ngoto phy_RF6052_Config_ParaFile_Fail;\r\n}\r\nreturn rtStatus;\r\nphy_RF6052_Config_ParaFile_Fail:\r\nreturn rtStatus;\r\n}\r\nint PHY_RF6052_Config8188E(struct adapter *Adapter)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(Adapter);\r\nint rtStatus = _SUCCESS;\r\nif (pHalData->rf_type == RF_1T1R)\r\npHalData->NumTotalRFPath = 1;\r\nelse\r\npHalData->NumTotalRFPath = 2;\r\nrtStatus = phy_RF6052_Config_ParaFile(Adapter);\r\nreturn rtStatus;\r\n}
