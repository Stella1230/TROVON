static void ch7006_encoder_set_config(struct drm_encoder *encoder,\r\nvoid *params)\r\n{\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\npriv->params = *(struct ch7006_encoder_params *)params;\r\n}\r\nstatic void ch7006_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\ndrm_property_destroy(encoder->dev, priv->scale_property);\r\nkfree(priv);\r\nto_encoder_slave(encoder)->slave_priv = NULL;\r\ndrm_i2c_encoder_destroy(encoder);\r\n}\r\nstatic void ch7006_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nstruct ch7006_state *state = &priv->state;\r\nch7006_dbg(client, "\n");\r\nif (mode == priv->last_dpms)\r\nreturn;\r\npriv->last_dpms = mode;\r\nch7006_setup_power_state(encoder);\r\nch7006_load_reg(client, state, CH7006_POWER);\r\n}\r\nstatic void ch7006_encoder_save(struct drm_encoder *encoder)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nch7006_dbg(client, "\n");\r\nch7006_state_save(client, &priv->saved_state);\r\n}\r\nstatic void ch7006_encoder_restore(struct drm_encoder *encoder)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nch7006_dbg(client, "\n");\r\nch7006_state_load(client, &priv->saved_state);\r\n}\r\nstatic bool ch7006_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\npriv->mode = ch7006_lookup_mode(encoder, mode);\r\nreturn !!priv->mode;\r\n}\r\nstatic int ch7006_encoder_mode_valid(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode)\r\n{\r\nif (ch7006_lookup_mode(encoder, mode))\r\nreturn MODE_OK;\r\nelse\r\nreturn MODE_BAD;\r\n}\r\nstatic void ch7006_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *drm_mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nstruct ch7006_encoder_params *params = &priv->params;\r\nstruct ch7006_state *state = &priv->state;\r\nuint8_t *regs = state->regs;\r\nstruct ch7006_mode *mode = priv->mode;\r\nstruct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];\r\nint start_active;\r\nch7006_dbg(client, "\n");\r\nregs[CH7006_DISPMODE] = norm->dispmode | mode->dispmode;\r\nregs[CH7006_BWIDTH] = 0;\r\nregs[CH7006_INPUT_FORMAT] = bitf(CH7006_INPUT_FORMAT_FORMAT,\r\nparams->input_format);\r\nregs[CH7006_CLKMODE] = CH7006_CLKMODE_SUBC_LOCK\r\n| bitf(CH7006_CLKMODE_XCM, params->xcm)\r\n| bitf(CH7006_CLKMODE_PCM, params->pcm);\r\nif (params->clock_mode)\r\nregs[CH7006_CLKMODE] |= CH7006_CLKMODE_MASTER;\r\nif (params->clock_edge)\r\nregs[CH7006_CLKMODE] |= CH7006_CLKMODE_POS_EDGE;\r\nstart_active = (drm_mode->htotal & ~0x7) - (drm_mode->hsync_start & ~0x7);\r\nregs[CH7006_POV] = bitf(CH7006_POV_START_ACTIVE_8, start_active);\r\nregs[CH7006_START_ACTIVE] = bitf(CH7006_START_ACTIVE_0, start_active);\r\nregs[CH7006_INPUT_SYNC] = 0;\r\nif (params->sync_direction)\r\nregs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_OUTPUT;\r\nif (params->sync_encoding)\r\nregs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_EMBEDDED;\r\nif (drm_mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nregs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_PVSYNC;\r\nif (drm_mode->flags & DRM_MODE_FLAG_PHSYNC)\r\nregs[CH7006_INPUT_SYNC] |= CH7006_INPUT_SYNC_PHSYNC;\r\nregs[CH7006_DETECT] = 0;\r\nregs[CH7006_BCLKOUT] = 0;\r\nregs[CH7006_SUBC_INC3] = 0;\r\nif (params->pout_level)\r\nregs[CH7006_SUBC_INC3] |= CH7006_SUBC_INC3_POUT_3_3V;\r\nregs[CH7006_SUBC_INC4] = 0;\r\nif (params->active_detect)\r\nregs[CH7006_SUBC_INC4] |= CH7006_SUBC_INC4_DS_INPUT;\r\nregs[CH7006_PLL_CONTROL] = priv->saved_state.regs[CH7006_PLL_CONTROL];\r\nch7006_setup_levels(encoder);\r\nch7006_setup_subcarrier(encoder);\r\nch7006_setup_pll(encoder);\r\nch7006_setup_power_state(encoder);\r\nch7006_setup_properties(encoder);\r\nch7006_state_load(client, state);\r\n}\r\nstatic enum drm_connector_status ch7006_encoder_detect(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nstruct ch7006_state *state = &priv->state;\r\nint det;\r\nch7006_dbg(client, "\n");\r\nch7006_save_reg(client, state, CH7006_DETECT);\r\nch7006_save_reg(client, state, CH7006_POWER);\r\nch7006_save_reg(client, state, CH7006_CLKMODE);\r\nch7006_write(client, CH7006_POWER, CH7006_POWER_RESET |\r\nbitfs(CH7006_POWER_LEVEL, NORMAL));\r\nch7006_write(client, CH7006_CLKMODE, CH7006_CLKMODE_MASTER);\r\nch7006_write(client, CH7006_DETECT, CH7006_DETECT_SENSE);\r\nch7006_write(client, CH7006_DETECT, 0);\r\ndet = ch7006_read(client, CH7006_DETECT);\r\nch7006_load_reg(client, state, CH7006_CLKMODE);\r\nch7006_load_reg(client, state, CH7006_POWER);\r\nch7006_load_reg(client, state, CH7006_DETECT);\r\nif ((det & (CH7006_DETECT_SVIDEO_Y_TEST|\r\nCH7006_DETECT_SVIDEO_C_TEST|\r\nCH7006_DETECT_CVBS_TEST)) == 0)\r\npriv->subconnector = DRM_MODE_SUBCONNECTOR_SCART;\r\nelse if ((det & (CH7006_DETECT_SVIDEO_Y_TEST|\r\nCH7006_DETECT_SVIDEO_C_TEST)) == 0)\r\npriv->subconnector = DRM_MODE_SUBCONNECTOR_SVIDEO;\r\nelse if ((det & CH7006_DETECT_CVBS_TEST) == 0)\r\npriv->subconnector = DRM_MODE_SUBCONNECTOR_Composite;\r\nelse\r\npriv->subconnector = DRM_MODE_SUBCONNECTOR_Unknown;\r\ndrm_object_property_set_value(&connector->base,\r\nencoder->dev->mode_config.tv_subconnector_property,\r\npriv->subconnector);\r\nreturn priv->subconnector ? connector_status_connected :\r\nconnector_status_disconnected;\r\n}\r\nstatic int ch7006_encoder_get_modes(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nstruct ch7006_mode *mode;\r\nint n = 0;\r\nfor (mode = ch7006_modes; mode->mode.clock; mode++) {\r\nif (~mode->valid_scales & 1<<priv->scale ||\r\n~mode->valid_norms & 1<<priv->norm)\r\ncontinue;\r\ndrm_mode_probed_add(connector,\r\ndrm_mode_duplicate(encoder->dev, &mode->mode));\r\nn++;\r\n}\r\nreturn n;\r\n}\r\nstatic int ch7006_encoder_create_resources(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_mode_config *conf = &dev->mode_config;\r\ndrm_mode_create_tv_properties(dev, NUM_TV_NORMS, ch7006_tv_norm_names);\r\npriv->scale_property = drm_property_create_range(dev, 0, "scale", 0, 2);\r\ndrm_object_attach_property(&connector->base, conf->tv_select_subconnector_property,\r\npriv->select_subconnector);\r\ndrm_object_attach_property(&connector->base, conf->tv_subconnector_property,\r\npriv->subconnector);\r\ndrm_object_attach_property(&connector->base, conf->tv_left_margin_property,\r\npriv->hmargin);\r\ndrm_object_attach_property(&connector->base, conf->tv_bottom_margin_property,\r\npriv->vmargin);\r\ndrm_object_attach_property(&connector->base, conf->tv_mode_property,\r\npriv->norm);\r\ndrm_object_attach_property(&connector->base, conf->tv_brightness_property,\r\npriv->brightness);\r\ndrm_object_attach_property(&connector->base, conf->tv_contrast_property,\r\npriv->contrast);\r\ndrm_object_attach_property(&connector->base, conf->tv_flicker_reduction_property,\r\npriv->flicker);\r\ndrm_object_attach_property(&connector->base, priv->scale_property,\r\npriv->scale);\r\nreturn 0;\r\n}\r\nstatic int ch7006_encoder_set_property(struct drm_encoder *encoder,\r\nstruct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nstruct ch7006_state *state = &priv->state;\r\nstruct drm_mode_config *conf = &encoder->dev->mode_config;\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nbool modes_changed = false;\r\nch7006_dbg(client, "\n");\r\nif (property == conf->tv_select_subconnector_property) {\r\npriv->select_subconnector = val;\r\nch7006_setup_power_state(encoder);\r\nch7006_load_reg(client, state, CH7006_POWER);\r\n} else if (property == conf->tv_left_margin_property) {\r\npriv->hmargin = val;\r\nch7006_setup_properties(encoder);\r\nch7006_load_reg(client, state, CH7006_POV);\r\nch7006_load_reg(client, state, CH7006_HPOS);\r\n} else if (property == conf->tv_bottom_margin_property) {\r\npriv->vmargin = val;\r\nch7006_setup_properties(encoder);\r\nch7006_load_reg(client, state, CH7006_POV);\r\nch7006_load_reg(client, state, CH7006_VPOS);\r\n} else if (property == conf->tv_mode_property) {\r\nif (connector->dpms != DRM_MODE_DPMS_OFF)\r\nreturn -EINVAL;\r\npriv->norm = val;\r\nmodes_changed = true;\r\n} else if (property == conf->tv_brightness_property) {\r\npriv->brightness = val;\r\nch7006_setup_levels(encoder);\r\nch7006_load_reg(client, state, CH7006_BLACK_LEVEL);\r\n} else if (property == conf->tv_contrast_property) {\r\npriv->contrast = val;\r\nch7006_setup_properties(encoder);\r\nch7006_load_reg(client, state, CH7006_CONTRAST);\r\n} else if (property == conf->tv_flicker_reduction_property) {\r\npriv->flicker = val;\r\nch7006_setup_properties(encoder);\r\nch7006_load_reg(client, state, CH7006_FFILTER);\r\n} else if (property == priv->scale_property) {\r\nif (connector->dpms != DRM_MODE_DPMS_OFF)\r\nreturn -EINVAL;\r\npriv->scale = val;\r\nmodes_changed = true;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (modes_changed) {\r\ndrm_helper_probe_single_connector_modes(connector, 0, 0);\r\nif (crtc) {\r\nstruct drm_mode_set modeset = {\r\n.crtc = crtc,\r\n};\r\ndrm_mode_set_config_internal(&modeset);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ch7006_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nuint8_t addr = CH7006_VERSION_ID;\r\nuint8_t val;\r\nint ret;\r\nch7006_dbg(client, "\n");\r\nret = i2c_master_send(client, &addr, sizeof(addr));\r\nif (ret < 0)\r\ngoto fail;\r\nret = i2c_master_recv(client, &val, sizeof(val));\r\nif (ret < 0)\r\ngoto fail;\r\nch7006_info(client, "Detected version ID: %x\n", val);\r\nch7006_write(client, 0x3d, 0x0);\r\nreturn 0;\r\nfail:\r\nch7006_err(client, "Error %d reading version ID\n", ret);\r\nreturn -ENODEV;\r\n}\r\nstatic int ch7006_remove(struct i2c_client *client)\r\n{\r\nch7006_dbg(client, "\n");\r\nreturn 0;\r\n}\r\nstatic int ch7006_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nch7006_dbg(client, "\n");\r\nch7006_write(client, 0x3d, 0x0);\r\nreturn 0;\r\n}\r\nstatic int ch7006_encoder_init(struct i2c_client *client,\r\nstruct drm_device *dev,\r\nstruct drm_encoder_slave *encoder)\r\n{\r\nstruct ch7006_priv *priv;\r\nint i;\r\nch7006_dbg(client, "\n");\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nencoder->slave_priv = priv;\r\nencoder->slave_funcs = &ch7006_encoder_funcs;\r\npriv->norm = TV_NORM_PAL;\r\npriv->select_subconnector = DRM_MODE_SUBCONNECTOR_Automatic;\r\npriv->subconnector = DRM_MODE_SUBCONNECTOR_Unknown;\r\npriv->scale = 1;\r\npriv->contrast = 50;\r\npriv->brightness = 50;\r\npriv->flicker = 50;\r\npriv->hmargin = 50;\r\npriv->vmargin = 50;\r\npriv->last_dpms = -1;\r\npriv->chip_version = ch7006_read(client, CH7006_VERSION_ID);\r\nif (ch7006_tv_norm) {\r\nfor (i = 0; i < NUM_TV_NORMS; i++) {\r\nif (!strcmp(ch7006_tv_norm_names[i], ch7006_tv_norm)) {\r\npriv->norm = i;\r\nbreak;\r\n}\r\n}\r\nif (i == NUM_TV_NORMS)\r\nch7006_err(client, "Invalid TV norm setting \"%s\".\n",\r\nch7006_tv_norm);\r\n}\r\nif (ch7006_scale >= 0 && ch7006_scale <= 2)\r\npriv->scale = ch7006_scale;\r\nelse\r\nch7006_err(client, "Invalid scale setting \"%d\".\n",\r\nch7006_scale);\r\nreturn 0;\r\n}\r\nstatic int __init ch7006_init(void)\r\n{\r\nreturn drm_i2c_encoder_register(THIS_MODULE, &ch7006_driver);\r\n}\r\nstatic void __exit ch7006_exit(void)\r\n{\r\ndrm_i2c_encoder_unregister(&ch7006_driver);\r\n}
