static int check_usb_db(struct ft1000_usb *ft1000dev)\r\n{\r\nint loopcnt;\r\nu16 temp;\r\nint status;\r\nloopcnt = 0;\r\nwhile (loopcnt < 10) {\r\nstatus = ft1000_read_register(ft1000dev, &temp,\r\nFT1000_REG_DOORBELL);\r\nDEBUG("check_usb_db: read FT1000_REG_DOORBELL value is %x\n",\r\ntemp);\r\nif (temp & 0x0080) {\r\nDEBUG("FT1000:Got checkusb doorbell\n");\r\nstatus = ft1000_write_register(ft1000dev, 0x0080,\r\nFT1000_REG_DOORBELL);\r\nstatus = ft1000_write_register(ft1000dev, 0x0100,\r\nFT1000_REG_DOORBELL);\r\nstatus = ft1000_write_register(ft1000dev, 0x8000,\r\nFT1000_REG_DOORBELL);\r\nbreak;\r\n} else {\r\nloopcnt++;\r\nmsleep(10);\r\n}\r\n}\r\nloopcnt = 0;\r\nwhile (loopcnt < 20) {\r\nstatus = ft1000_read_register(ft1000dev, &temp,\r\nFT1000_REG_DOORBELL);\r\nDEBUG("FT1000:check_usb_db:Doorbell = 0x%x\n", temp);\r\nif (temp & 0x8000) {\r\nloopcnt++;\r\nmsleep(10);\r\n} else {\r\nDEBUG("check_usb_db: door bell is cleared, return 0\n");\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic u16 get_handshake(struct ft1000_usb *ft1000dev, u16 expected_value)\r\n{\r\nu16 handshake;\r\nint loopcnt;\r\nint status = 0;\r\nloopcnt = 0;\r\nwhile (loopcnt < 100) {\r\nstatus = ft1000_write_register(ft1000dev, FT1000_DB_DNLD_RX,\r\nFT1000_REG_DOORBELL);\r\nif (ft1000dev->fcodeldr) {\r\nDEBUG(" get_handshake: fcodeldr is %d\n",\r\nft1000dev->fcodeldr);\r\nft1000dev->fcodeldr = 0;\r\nstatus = check_usb_db(ft1000dev);\r\nif (status != 0) {\r\nDEBUG("get_handshake: check_usb_db failed\n");\r\nbreak;\r\n}\r\nstatus = ft1000_write_register(ft1000dev,\r\nFT1000_DB_DNLD_RX,\r\nFT1000_REG_DOORBELL);\r\n}\r\nstatus = ft1000_read_dpram16(ft1000dev,\r\nDWNLD_MAG1_HANDSHAKE_LOC, (u8 *)&handshake, 1);\r\nhandshake = ntohs(handshake);\r\nif (status)\r\nreturn HANDSHAKE_TIMEOUT_VALUE;\r\nif ((handshake == expected_value) ||\r\n(handshake == HANDSHAKE_RESET_VALUE_USB)) {\r\nreturn handshake;\r\n} else {\r\nloopcnt++;\r\nmsleep(10);\r\n}\r\n}\r\nreturn HANDSHAKE_TIMEOUT_VALUE;\r\n}\r\nstatic void put_handshake(struct ft1000_usb *ft1000dev, u16 handshake_value)\r\n{\r\nu32 tempx;\r\nu16 tempword;\r\nint status;\r\ntempx = (u32)handshake_value;\r\ntempx = ntohl(tempx);\r\ntempword = (u16)(tempx & 0xffff);\r\nstatus = ft1000_write_dpram16(ft1000dev, DWNLD_MAG1_HANDSHAKE_LOC,\r\ntempword, 0);\r\ntempword = (u16)(tempx >> 16);\r\nstatus = ft1000_write_dpram16(ft1000dev, DWNLD_MAG1_HANDSHAKE_LOC,\r\ntempword, 1);\r\nstatus = ft1000_write_register(ft1000dev, FT1000_DB_DNLD_TX,\r\nFT1000_REG_DOORBELL);\r\n}\r\nstatic u16 get_handshake_usb(struct ft1000_usb *ft1000dev, u16 expected_value)\r\n{\r\nu16 handshake;\r\nint loopcnt;\r\nu16 temp;\r\nint status = 0;\r\nloopcnt = 0;\r\nhandshake = 0;\r\nwhile (loopcnt < 100) {\r\nif (ft1000dev->usbboot == 2) {\r\nstatus = ft1000_read_dpram32(ft1000dev, 0,\r\n(u8 *)&(ft1000dev->tempbuf[0]), 64);\r\nfor (temp = 0; temp < 16; temp++) {\r\nDEBUG("tempbuf %d = 0x%x\n", temp,\r\nft1000dev->tempbuf[temp]);\r\n}\r\nstatus = ft1000_read_dpram16(ft1000dev,\r\nDWNLD_MAG1_HANDSHAKE_LOC,\r\n(u8 *)&handshake, 1);\r\nDEBUG("handshake from read_dpram16 = 0x%x\n",\r\nhandshake);\r\nif (ft1000dev->dspalive == ft1000dev->tempbuf[6]) {\r\nhandshake = 0;\r\n} else {\r\nhandshake = ft1000dev->tempbuf[1];\r\nft1000dev->dspalive =\r\nft1000dev->tempbuf[6];\r\n}\r\n} else {\r\nstatus = ft1000_read_dpram16(ft1000dev,\r\nDWNLD_MAG1_HANDSHAKE_LOC,\r\n(u8 *)&handshake, 1);\r\n}\r\nloopcnt++;\r\nmsleep(10);\r\nhandshake = ntohs(handshake);\r\nif ((handshake == expected_value) ||\r\n(handshake == HANDSHAKE_RESET_VALUE_USB))\r\nreturn handshake;\r\n}\r\nreturn HANDSHAKE_TIMEOUT_VALUE;\r\n}\r\nstatic void put_handshake_usb(struct ft1000_usb *ft1000dev, u16 handshake_value)\r\n{\r\nint i;\r\nfor (i = 0; i < 1000; i++)\r\n;\r\n}\r\nstatic u16 get_request_type(struct ft1000_usb *ft1000dev)\r\n{\r\nu16 request_type;\r\nint status;\r\nu16 tempword;\r\nu32 tempx;\r\nif (ft1000dev->bootmode == 1) {\r\nstatus = fix_ft1000_read_dpram32(ft1000dev,\r\nDWNLD_MAG1_TYPE_LOC, (u8 *)&tempx);\r\ntempx = ntohl(tempx);\r\n} else {\r\ntempx = 0;\r\nstatus = ft1000_read_dpram16(ft1000dev,\r\nDWNLD_MAG1_TYPE_LOC, (u8 *)&tempword, 1);\r\ntempx |= (tempword << 16);\r\ntempx = ntohl(tempx);\r\n}\r\nrequest_type = (u16)tempx;\r\nreturn request_type;\r\n}\r\nstatic u16 get_request_type_usb(struct ft1000_usb *ft1000dev)\r\n{\r\nu16 request_type;\r\nint status;\r\nu16 tempword;\r\nu32 tempx;\r\nif (ft1000dev->bootmode == 1) {\r\nstatus = fix_ft1000_read_dpram32(ft1000dev,\r\nDWNLD_MAG1_TYPE_LOC, (u8 *)&tempx);\r\ntempx = ntohl(tempx);\r\n} else {\r\nif (ft1000dev->usbboot == 2) {\r\ntempx = ft1000dev->tempbuf[2];\r\ntempword = ft1000dev->tempbuf[3];\r\n} else {\r\ntempx = 0;\r\nstatus = ft1000_read_dpram16(ft1000dev,\r\nDWNLD_MAG1_TYPE_LOC,\r\n(u8 *)&tempword, 1);\r\n}\r\ntempx |= (tempword << 16);\r\ntempx = ntohl(tempx);\r\n}\r\nrequest_type = (u16)tempx;\r\nreturn request_type;\r\n}\r\nstatic long get_request_value(struct ft1000_usb *ft1000dev)\r\n{\r\nu32 value;\r\nu16 tempword;\r\nint status;\r\nif (ft1000dev->bootmode == 1) {\r\nstatus = fix_ft1000_read_dpram32(ft1000dev,\r\nDWNLD_MAG1_SIZE_LOC, (u8 *)&value);\r\nvalue = ntohl(value);\r\n} else {\r\nstatus = ft1000_read_dpram16(ft1000dev,\r\nDWNLD_MAG1_SIZE_LOC, (u8 *)&tempword, 0);\r\nvalue = tempword;\r\nstatus = ft1000_read_dpram16(ft1000dev,\r\nDWNLD_MAG1_SIZE_LOC, (u8 *)&tempword, 1);\r\nvalue |= (tempword << 16);\r\nvalue = ntohl(value);\r\n}\r\nreturn value;\r\n}\r\nstatic void put_request_value(struct ft1000_usb *ft1000dev, long lvalue)\r\n{\r\nu32 tempx;\r\nint status;\r\ntempx = ntohl(lvalue);\r\nstatus = fix_ft1000_write_dpram32(ft1000dev, DWNLD_MAG1_SIZE_LOC,\r\n(u8 *)&tempx);\r\n}\r\nstatic u16 hdr_checksum(struct pseudo_hdr *pHdr)\r\n{\r\nu16 *usPtr = (u16 *)pHdr;\r\nu16 chksum;\r\nchksum = ((((((usPtr[0] ^ usPtr[1]) ^ usPtr[2]) ^ usPtr[3]) ^\r\nusPtr[4]) ^ usPtr[5]) ^ usPtr[6]);\r\nreturn chksum;\r\n}\r\nstatic int check_buffers(u16 *buff_w, u16 *buff_r, int len, int offset)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nif (buff_w[i] != buff_r[i + offset])\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_dpram32_and_check(struct ft1000_usb *ft1000dev,\r\nu16 tempbuffer[], u16 dpram)\r\n{\r\nint status;\r\nu16 resultbuffer[64];\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nstatus = ft1000_write_dpram32(ft1000dev, dpram,\r\n(u8 *)&tempbuffer[0], 64);\r\nif (status == 0) {\r\nif ((tempbuffer[31] & 0xfe00) == 0xfe00) {\r\nstatus = ft1000_write_dpram32(ft1000dev,\r\ndpram+12, (u8 *)&tempbuffer[24],\r\n64);\r\n}\r\nstatus = ft1000_read_dpram32(ft1000dev, dpram,\r\n(u8 *)&resultbuffer[0], 64);\r\nif ((tempbuffer[31] & 0xfe00) == 0xfe00) {\r\nif (check_buffers(tempbuffer, resultbuffer, 28,\r\n0)) {\r\nDEBUG("FT1000:download:DPRAM write failed 1 during bootloading\n");\r\nusleep_range(9000, 11000);\r\nbreak;\r\n}\r\nstatus = ft1000_read_dpram32(ft1000dev,\r\ndpram+12,\r\n(u8 *)&resultbuffer[0], 64);\r\nif (check_buffers(tempbuffer, resultbuffer, 16,\r\n24)) {\r\nDEBUG("FT1000:download:DPRAM write failed 2 during bootloading\n");\r\nusleep_range(9000, 11000);\r\nbreak;\r\n}\r\n} else {\r\nif (check_buffers(tempbuffer, resultbuffer, 32,\r\n0)) {\r\nDEBUG("FT1000:download:DPRAM write failed 3 during bootloading\n");\r\nusleep_range(9000, 11000);\r\nbreak;\r\n}\r\n}\r\nif (status == 0)\r\nbreak;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int write_blk(struct ft1000_usb *ft1000dev, u16 **pUsFile, u8 **pUcFile,\r\nlong word_length)\r\n{\r\nint status = 0;\r\nu16 dpram;\r\nint loopcnt, i;\r\nu16 tempword;\r\nu16 tempbuffer[64];\r\ndpram = (u16)DWNLD_MAG1_PS_HDR_LOC;\r\ntempword = *(*pUsFile);\r\n(*pUsFile)++;\r\nstatus = ft1000_write_dpram16(ft1000dev, dpram, tempword, 0);\r\ntempword = *(*pUsFile);\r\n(*pUsFile)++;\r\nstatus = ft1000_write_dpram16(ft1000dev, dpram++, tempword, 1);\r\n*pUcFile = *pUcFile + 4;\r\nword_length--;\r\ntempword = (u16)word_length;\r\nword_length = (word_length / 16) + 1;\r\nfor (; word_length > 0; word_length--) {\r\nloopcnt = 0;\r\nfor (i = 0; i < 32; i++) {\r\nif (tempword != 0) {\r\ntempbuffer[i++] = *(*pUsFile);\r\n(*pUsFile)++;\r\ntempbuffer[i] = *(*pUsFile);\r\n(*pUsFile)++;\r\n*pUcFile = *pUcFile + 4;\r\nloopcnt++;\r\ntempword--;\r\n} else {\r\ntempbuffer[i++] = 0;\r\ntempbuffer[i] = 0;\r\n}\r\n}\r\nif (ft1000dev->bootmode == 0) {\r\nif (dpram >= 0x3F4)\r\nstatus = ft1000_write_dpram32(ft1000dev, dpram,\r\n(u8 *)&tempbuffer[0], 8);\r\nelse\r\nstatus = ft1000_write_dpram32(ft1000dev, dpram,\r\n(u8 *)&tempbuffer[0], 64);\r\n} else {\r\nstatus = write_dpram32_and_check(ft1000dev, tempbuffer,\r\ndpram);\r\nif (status != 0) {\r\nDEBUG("FT1000:download:Write failed tempbuffer[31] = 0x%x\n", tempbuffer[31]);\r\nbreak;\r\n}\r\n}\r\ndpram = dpram + loopcnt;\r\n}\r\nreturn status;\r\n}\r\nstatic void usb_dnld_complete(struct urb *urb)\r\n{\r\n}\r\nstatic int write_blk_fifo(struct ft1000_usb *ft1000dev, u16 **pUsFile,\r\nu8 **pUcFile, long word_length)\r\n{\r\nint Status = 0;\r\nint byte_length;\r\nbyte_length = word_length * 4;\r\nif (byte_length && ((byte_length % 64) == 0))\r\nbyte_length += 4;\r\nif (byte_length < 64)\r\nbyte_length = 68;\r\nusb_init_urb(ft1000dev->tx_urb);\r\nmemcpy(ft1000dev->tx_buf, *pUcFile, byte_length);\r\nusb_fill_bulk_urb(ft1000dev->tx_urb,\r\nft1000dev->dev,\r\nusb_sndbulkpipe(ft1000dev->dev,\r\nft1000dev->bulk_out_endpointAddr),\r\nft1000dev->tx_buf, byte_length, usb_dnld_complete,\r\n(void *)ft1000dev);\r\nusb_submit_urb(ft1000dev->tx_urb, GFP_ATOMIC);\r\n*pUsFile = *pUsFile + (word_length << 1);\r\n*pUcFile = *pUcFile + (word_length << 2);\r\nreturn Status;\r\n}\r\nstatic int scram_start_dwnld(struct ft1000_usb *ft1000dev, u16 *hshake,\r\nu32 *state)\r\n{\r\nint status = 0;\r\nDEBUG("FT1000:STATE_START_DWNLD\n");\r\nif (ft1000dev->usbboot)\r\n*hshake = get_handshake_usb(ft1000dev, HANDSHAKE_DSP_BL_READY);\r\nelse\r\n*hshake = get_handshake(ft1000dev, HANDSHAKE_DSP_BL_READY);\r\nif (*hshake == HANDSHAKE_DSP_BL_READY) {\r\nDEBUG("scram_dnldr: handshake is HANDSHAKE_DSP_BL_READY, call put_handshake(HANDSHAKE_DRIVER_READY)\n");\r\nput_handshake(ft1000dev, HANDSHAKE_DRIVER_READY);\r\n} else if (*hshake == HANDSHAKE_TIMEOUT_VALUE) {\r\nstatus = -ETIMEDOUT;\r\n} else {\r\nDEBUG("FT1000:download:Download error: Handshake failed\n");\r\nstatus = -ENETRESET;\r\n}\r\n*state = STATE_BOOT_DWNLD;\r\nreturn status;\r\n}\r\nstatic int request_code_segment(struct ft1000_usb *ft1000dev, u16 **s_file,\r\nu8 **c_file, const u8 *endpoint, bool boot_case)\r\n{\r\nlong word_length;\r\nint status = 0;\r\nword_length = get_request_value(ft1000dev);\r\nif (word_length > MAX_LENGTH) {\r\nDEBUG("FT1000:download:Download error: Max length exceeded\n");\r\nreturn -1;\r\n}\r\nif ((word_length * 2 + (long)c_file) > (long)endpoint) {\r\nDEBUG("FT1000:download:Download error: Requested len=%d exceeds BOOT code boundary.\n", (int)word_length);\r\nreturn -1;\r\n}\r\nif (word_length & 0x1)\r\nword_length++;\r\nword_length = word_length / 2;\r\nif (boot_case) {\r\nstatus = write_blk(ft1000dev, s_file, c_file, word_length);\r\n} else {\r\nstatus = write_blk_fifo(ft1000dev, s_file, c_file, word_length);\r\nif (ft1000dev->usbboot == 0)\r\nft1000dev->usbboot++;\r\nif (ft1000dev->usbboot == 1)\r\nstatus |= ft1000_write_dpram16(ft1000dev,\r\nDWNLD_MAG1_PS_HDR_LOC, 0, 0);\r\n}\r\nreturn status;\r\n}\r\nint scram_dnldr(struct ft1000_usb *ft1000dev, void *pFileStart,\r\nu32 FileLength)\r\n{\r\nint status = 0;\r\nu32 state;\r\nu16 handshake;\r\nstruct pseudo_hdr *pseudo_header;\r\nu16 pseudo_header_len;\r\nlong word_length;\r\nu16 request;\r\nu16 temp;\r\nstruct dsp_file_hdr *file_hdr;\r\nstruct dsp_image_info *dsp_img_info = NULL;\r\nlong requested_version;\r\nbool correct_version;\r\nstruct drv_msg *mailbox_data;\r\nu16 *data = NULL;\r\nu16 *s_file = NULL;\r\nu8 *c_file = NULL;\r\nu8 *boot_end = NULL, *code_end = NULL;\r\nint image;\r\nlong loader_code_address, loader_code_size = 0;\r\nlong run_address = 0, run_size = 0;\r\nu32 templong;\r\nu32 image_chksum = 0;\r\nu16 dpram = 0;\r\nu8 *pbuffer;\r\nstruct prov_record *pprov_record;\r\nstruct ft1000_info *pft1000info = netdev_priv(ft1000dev->net);\r\nDEBUG("Entered scram_dnldr...\n");\r\nft1000dev->fcodeldr = 0;\r\nft1000dev->usbboot = 0;\r\nft1000dev->dspalive = 0xffff;\r\nstate = STATE_START_DWNLD;\r\nfile_hdr = (struct dsp_file_hdr *)pFileStart;\r\nft1000_write_register(ft1000dev, 0x800, FT1000_REG_MAG_WATERMARK);\r\ns_file = (u16 *) (pFileStart + file_hdr->loader_offset);\r\nc_file = (u8 *) (pFileStart + file_hdr->loader_offset);\r\nboot_end = (u8 *) (pFileStart + file_hdr->loader_code_end);\r\nloader_code_address = file_hdr->loader_code_address;\r\nloader_code_size = file_hdr->loader_code_size;\r\ncorrect_version = false;\r\nwhile ((status == 0) && (state != STATE_DONE_FILE)) {\r\nswitch (state) {\r\ncase STATE_START_DWNLD:\r\nstatus = scram_start_dwnld(ft1000dev, &handshake,\r\n&state);\r\nbreak;\r\ncase STATE_BOOT_DWNLD:\r\nDEBUG("FT1000:STATE_BOOT_DWNLD\n");\r\nft1000dev->bootmode = 1;\r\nhandshake = get_handshake(ft1000dev, HANDSHAKE_REQUEST);\r\nif (handshake == HANDSHAKE_REQUEST) {\r\nrequest = get_request_type(ft1000dev);\r\nswitch (request) {\r\ncase REQUEST_RUN_ADDRESS:\r\nDEBUG("FT1000:REQUEST_RUN_ADDRESS\n");\r\nput_request_value(ft1000dev,\r\nloader_code_address);\r\nbreak;\r\ncase REQUEST_CODE_LENGTH:\r\nDEBUG("FT1000:REQUEST_CODE_LENGTH\n");\r\nput_request_value(ft1000dev,\r\nloader_code_size);\r\nbreak;\r\ncase REQUEST_DONE_BL:\r\nDEBUG("FT1000:REQUEST_DONE_BL\n");\r\ns_file = (u16 *) (boot_end);\r\nc_file = (u8 *) (boot_end);\r\nstate = STATE_CODE_DWNLD;\r\nft1000dev->fcodeldr = 1;\r\nbreak;\r\ncase REQUEST_CODE_SEGMENT:\r\nstatus = request_code_segment(ft1000dev,\r\n&s_file, &c_file,\r\n(const u8 *)boot_end,\r\ntrue);\r\nbreak;\r\ndefault:\r\nDEBUG\r\n("FT1000:download:Download error: Bad request type=%d in BOOT download state.\n",\r\nrequest);\r\nstatus = -1;\r\nbreak;\r\n}\r\nif (ft1000dev->usbboot)\r\nput_handshake_usb(ft1000dev,\r\nHANDSHAKE_RESPONSE);\r\nelse\r\nput_handshake(ft1000dev,\r\nHANDSHAKE_RESPONSE);\r\n} else {\r\nDEBUG\r\n("FT1000:download:Download error: Handshake failed\n");\r\nstatus = -1;\r\n}\r\nbreak;\r\ncase STATE_CODE_DWNLD:\r\nft1000dev->bootmode = 0;\r\nif (ft1000dev->usbboot)\r\nhandshake =\r\nget_handshake_usb(ft1000dev,\r\nHANDSHAKE_REQUEST);\r\nelse\r\nhandshake =\r\nget_handshake(ft1000dev, HANDSHAKE_REQUEST);\r\nif (handshake == HANDSHAKE_REQUEST) {\r\nif (ft1000dev->usbboot)\r\nrequest =\r\nget_request_type_usb(ft1000dev);\r\nelse\r\nrequest = get_request_type(ft1000dev);\r\nswitch (request) {\r\ncase REQUEST_FILE_CHECKSUM:\r\nDEBUG\r\n("FT1000:download:image_chksum = 0x%8x\n",\r\nimage_chksum);\r\nput_request_value(ft1000dev,\r\nimage_chksum);\r\nbreak;\r\ncase REQUEST_RUN_ADDRESS:\r\nDEBUG\r\n("FT1000:download: REQUEST_RUN_ADDRESS\n");\r\nif (correct_version) {\r\nDEBUG\r\n("FT1000:download:run_address = 0x%8x\n",\r\n(int)run_address);\r\nput_request_value(ft1000dev,\r\nrun_address);\r\n} else {\r\nDEBUG\r\n("FT1000:download:Download error: Got Run address request before image offset request.\n");\r\nstatus = -1;\r\nbreak;\r\n}\r\nbreak;\r\ncase REQUEST_CODE_LENGTH:\r\nDEBUG\r\n("FT1000:download:REQUEST_CODE_LENGTH\n");\r\nif (correct_version) {\r\nDEBUG\r\n("FT1000:download:run_size = 0x%8x\n",\r\n(int)run_size);\r\nput_request_value(ft1000dev,\r\nrun_size);\r\n} else {\r\nDEBUG\r\n("FT1000:download:Download error: Got Size request before image offset request.\n");\r\nstatus = -1;\r\nbreak;\r\n}\r\nbreak;\r\ncase REQUEST_DONE_CL:\r\nft1000dev->usbboot = 3;\r\ns_file =\r\n(u16 *) (pFileStart +\r\nfile_hdr->commands_offset);\r\nc_file =\r\n(u8 *) (pFileStart +\r\nfile_hdr->commands_offset);\r\nstate = STATE_DONE_DWNLD;\r\nbreak;\r\ncase REQUEST_CODE_SEGMENT:\r\nif (!correct_version) {\r\nDEBUG\r\n("FT1000:download:Download error: Got Code Segment request before image offset request.\n");\r\nstatus = -1;\r\nbreak;\r\n}\r\nstatus = request_code_segment(ft1000dev,\r\n&s_file, &c_file,\r\n(const u8 *)code_end,\r\nfalse);\r\nbreak;\r\ncase REQUEST_MAILBOX_DATA:\r\nDEBUG\r\n("FT1000:download: REQUEST_MAILBOX_DATA\n");\r\nword_length =\r\n(long)(pft1000info->DSPInfoBlklen +\r\n1) / 2;\r\nput_request_value(ft1000dev,\r\nword_length);\r\nmailbox_data =\r\n(struct drv_msg *)&(pft1000info->\r\nDSPInfoBlk[0]);\r\ndata = (u16 *) &mailbox_data->data[0];\r\ndpram = (u16) DWNLD_MAG1_PS_HDR_LOC;\r\nif (word_length & 0x1)\r\nword_length++;\r\nword_length = (word_length / 2);\r\nfor (; word_length > 0; word_length--) {\r\ntemplong = *data++;\r\ntemplong |= (*data++ << 16);\r\nstatus =\r\nfix_ft1000_write_dpram32\r\n(ft1000dev, dpram++,\r\n(u8 *) &templong);\r\n}\r\nbreak;\r\ncase REQUEST_VERSION_INFO:\r\nDEBUG\r\n("FT1000:download:REQUEST_VERSION_INFO\n");\r\nword_length =\r\nfile_hdr->version_data_size;\r\nput_request_value(ft1000dev,\r\nword_length);\r\ns_file =\r\n(u16 *) (pFileStart +\r\nfile_hdr->\r\nversion_data_offset);\r\ndpram = (u16) DWNLD_MAG1_PS_HDR_LOC;\r\nif (word_length & 0x1)\r\nword_length++;\r\nword_length = (word_length / 2);\r\nfor (; word_length > 0; word_length--) {\r\ntemplong = ntohs(*s_file++);\r\ntemp = ntohs(*s_file++);\r\ntemplong |= (temp << 16);\r\nstatus =\r\nfix_ft1000_write_dpram32\r\n(ft1000dev, dpram++,\r\n(u8 *) &templong);\r\n}\r\nbreak;\r\ncase REQUEST_CODE_BY_VERSION:\r\nDEBUG\r\n("FT1000:download:REQUEST_CODE_BY_VERSION\n");\r\ncorrect_version = false;\r\nrequested_version =\r\nget_request_value(ft1000dev);\r\ndsp_img_info =\r\n(struct dsp_image_info *)(pFileStart\r\n+\r\nsizeof\r\n(struct\r\ndsp_file_hdr));\r\nfor (image = 0;\r\nimage < file_hdr->nDspImages;\r\nimage++) {\r\nif (dsp_img_info->version ==\r\nrequested_version) {\r\ncorrect_version = true;\r\nDEBUG\r\n("FT1000:download: correct_version is TRUE\n");\r\ns_file =\r\n(u16 *) (pFileStart\r\n+\r\ndsp_img_info->\r\nbegin_offset);\r\nc_file =\r\n(u8 *) (pFileStart +\r\ndsp_img_info->\r\nbegin_offset);\r\ncode_end =\r\n(u8 *) (pFileStart +\r\ndsp_img_info->\r\nend_offset);\r\nrun_address =\r\ndsp_img_info->\r\nrun_address;\r\nrun_size =\r\ndsp_img_info->\r\nimage_size;\r\nimage_chksum =\r\n(u32) dsp_img_info->\r\nchecksum;\r\nbreak;\r\n}\r\ndsp_img_info++;\r\n}\r\nif (!correct_version) {\r\nDEBUG\r\n("FT1000:download:Download error: Bad Version Request = 0x%x.\n",\r\n(int)requested_version);\r\nstatus = -1;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nDEBUG\r\n("FT1000:download:Download error: Bad request type=%d in CODE download state.\n",\r\nrequest);\r\nstatus = -1;\r\nbreak;\r\n}\r\nif (ft1000dev->usbboot)\r\nput_handshake_usb(ft1000dev,\r\nHANDSHAKE_RESPONSE);\r\nelse\r\nput_handshake(ft1000dev,\r\nHANDSHAKE_RESPONSE);\r\n} else {\r\nDEBUG\r\n("FT1000:download:Download error: Handshake failed\n");\r\nstatus = -1;\r\n}\r\nbreak;\r\ncase STATE_DONE_DWNLD:\r\nDEBUG("FT1000:download:Code loader is done...\n");\r\nstate = STATE_SECTION_PROV;\r\nbreak;\r\ncase STATE_SECTION_PROV:\r\nDEBUG("FT1000:download:STATE_SECTION_PROV\n");\r\npseudo_header = (struct pseudo_hdr *)c_file;\r\nif (pseudo_header->checksum ==\r\nhdr_checksum(pseudo_header)) {\r\nif (pseudo_header->portdest !=\r\n0x80 ) {\r\nstate = STATE_DONE_PROV;\r\nbreak;\r\n}\r\npseudo_header_len = ntohs(pseudo_header->length);\r\npbuffer =\r\nkmalloc((pseudo_header_len +\r\nsizeof(struct pseudo_hdr)),\r\nGFP_ATOMIC);\r\nif (pbuffer) {\r\nmemcpy(pbuffer, (void *)c_file,\r\n(u32) (pseudo_header_len +\r\nsizeof(struct\r\npseudo_hdr)));\r\npprov_record =\r\nkmalloc(sizeof(struct prov_record),\r\nGFP_ATOMIC);\r\nif (pprov_record) {\r\npprov_record->pprov_data =\r\npbuffer;\r\nlist_add_tail(&pprov_record->\r\nlist,\r\n&pft1000info->\r\nprov_list);\r\nc_file =\r\n(u8 *) ((unsigned long)\r\nc_file +\r\n(u32) ((pseudo_header_len + 1) & 0xFFFFFFFE) + sizeof(struct pseudo_hdr));\r\nif ((unsigned long)(c_file) -\r\n(unsigned long)(pFileStart)\r\n>=\r\n(unsigned long)FileLength) {\r\nstate = STATE_DONE_FILE;\r\n}\r\n} else {\r\nkfree(pbuffer);\r\nstatus = -1;\r\n}\r\n} else {\r\nstatus = -1;\r\n}\r\n} else {\r\nstatus = -1;\r\n}\r\nDEBUG\r\n("ft1000:download: after STATE_SECTION_PROV, state = %d, status= %d\n",\r\nstate, status);\r\nbreak;\r\ncase STATE_DONE_PROV:\r\nDEBUG("FT1000:download:STATE_DONE_PROV\n");\r\nstate = STATE_DONE_FILE;\r\nbreak;\r\ndefault:\r\nstatus = -1;\r\nbreak;\r\n}\r\nif (status != 0)\r\nbreak;\r\n}\r\nDEBUG("Download exiting with status = 0x%8x\n", status);\r\nft1000_write_register(ft1000dev, FT1000_DB_DNLD_TX,\r\nFT1000_REG_DOORBELL);\r\nreturn status;\r\n}
