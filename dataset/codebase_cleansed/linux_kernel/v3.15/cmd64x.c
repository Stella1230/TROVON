static void cmd64x_program_timings(ide_drive_t *drive, u8 mode)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(drive->hwif->dev);\r\nint bus_speed = ide_pci_clk ? ide_pci_clk : 33;\r\nconst unsigned long T = 1000000 / bus_speed;\r\nstatic const u8 recovery_values[] =\r\n{15, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0};\r\nstatic const u8 setup_values[] = {0x40, 0x40, 0x40, 0x80, 0, 0xc0};\r\nstatic const u8 arttim_regs[4] = {ARTTIM0, ARTTIM1, ARTTIM23, ARTTIM23};\r\nstatic const u8 drwtim_regs[4] = {DRWTIM0, DRWTIM1, DRWTIM2, DRWTIM3};\r\nstruct ide_timing t;\r\nu8 arttim = 0;\r\nide_timing_compute(drive, mode, &t, T, 0);\r\nif (t.recover > 16) {\r\nt.active += t.recover - 16;\r\nt.recover = 16;\r\n}\r\nif (t.active > 16)\r\nt.active = 16;\r\nt.recover = recovery_values[t.recover];\r\nt.active &= 0x0f;\r\npci_write_config_byte(dev, drwtim_regs[drive->dn],\r\n(t.active << 4) | t.recover);\r\nif (hwif->channel) {\r\nide_drive_t *pair = ide_get_pair_dev(drive);\r\nif (pair) {\r\nstruct ide_timing tp;\r\nide_timing_compute(pair, pair->pio_mode, &tp, T, 0);\r\nide_timing_merge(&t, &tp, &t, IDE_TIMING_SETUP);\r\nif (pair->dma_mode) {\r\nide_timing_compute(pair, pair->dma_mode,\r\n&tp, T, 0);\r\nide_timing_merge(&tp, &t, &t, IDE_TIMING_SETUP);\r\n}\r\n}\r\n}\r\nif (t.setup > 5)\r\nt.setup = 5;\r\n(void) pci_read_config_byte (dev, arttim_regs[drive->dn], &arttim);\r\nif (hwif->channel)\r\narttim &= ~ARTTIM23_INTR_CH1;\r\narttim &= ~0xc0;\r\narttim |= setup_values[t.setup];\r\n(void) pci_write_config_byte(dev, arttim_regs[drive->dn], arttim);\r\n}\r\nstatic void cmd64x_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nconst u8 pio = drive->pio_mode - XFER_PIO_0;\r\nif (pio == 8 || pio == 9)\r\nreturn;\r\ncmd64x_program_timings(drive, XFER_PIO_0 + pio);\r\n}\r\nstatic void cmd64x_set_dma_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nu8 unit = drive->dn & 0x01;\r\nu8 regU = 0, pciU = hwif->channel ? UDIDETCR1 : UDIDETCR0;\r\nconst u8 speed = drive->dma_mode;\r\npci_read_config_byte(dev, pciU, &regU);\r\nregU &= ~(unit ? 0xCA : 0x35);\r\nswitch(speed) {\r\ncase XFER_UDMA_5:\r\nregU |= unit ? 0x0A : 0x05;\r\nbreak;\r\ncase XFER_UDMA_4:\r\nregU |= unit ? 0x4A : 0x15;\r\nbreak;\r\ncase XFER_UDMA_3:\r\nregU |= unit ? 0x8A : 0x25;\r\nbreak;\r\ncase XFER_UDMA_2:\r\nregU |= unit ? 0x42 : 0x11;\r\nbreak;\r\ncase XFER_UDMA_1:\r\nregU |= unit ? 0x82 : 0x21;\r\nbreak;\r\ncase XFER_UDMA_0:\r\nregU |= unit ? 0xC2 : 0x31;\r\nbreak;\r\ncase XFER_MW_DMA_2:\r\ncase XFER_MW_DMA_1:\r\ncase XFER_MW_DMA_0:\r\ncmd64x_program_timings(drive, speed);\r\nbreak;\r\n}\r\npci_write_config_byte(dev, pciU, regU);\r\n}\r\nstatic void cmd648_clear_irq(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nunsigned long base = pci_resource_start(dev, 4);\r\nu8 irq_mask = hwif->channel ? MRDMODE_INTR_CH1 :\r\nMRDMODE_INTR_CH0;\r\nu8 mrdmode = inb(base + 1);\r\noutb((mrdmode & ~(MRDMODE_INTR_CH0 | MRDMODE_INTR_CH1)) | irq_mask,\r\nbase + 1);\r\n}\r\nstatic void cmd64x_clear_irq(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nint irq_reg = hwif->channel ? ARTTIM23 : CFR;\r\nu8 irq_mask = hwif->channel ? ARTTIM23_INTR_CH1 :\r\nCFR_INTR_CH0;\r\nu8 irq_stat = 0;\r\n(void) pci_read_config_byte(dev, irq_reg, &irq_stat);\r\n(void) pci_write_config_byte(dev, irq_reg, irq_stat | irq_mask);\r\n}\r\nstatic int cmd648_test_irq(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nunsigned long base = pci_resource_start(dev, 4);\r\nu8 irq_mask = hwif->channel ? MRDMODE_INTR_CH1 :\r\nMRDMODE_INTR_CH0;\r\nu8 mrdmode = inb(base + 1);\r\npr_debug("%s: mrdmode: 0x%02x irq_mask: 0x%02x\n",\r\nhwif->name, mrdmode, irq_mask);\r\nreturn (mrdmode & irq_mask) ? 1 : 0;\r\n}\r\nstatic int cmd64x_test_irq(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nint irq_reg = hwif->channel ? ARTTIM23 : CFR;\r\nu8 irq_mask = hwif->channel ? ARTTIM23_INTR_CH1 :\r\nCFR_INTR_CH0;\r\nu8 irq_stat = 0;\r\n(void) pci_read_config_byte(dev, irq_reg, &irq_stat);\r\npr_debug("%s: irq_stat: 0x%02x irq_mask: 0x%02x\n",\r\nhwif->name, irq_stat, irq_mask);\r\nreturn (irq_stat & irq_mask) ? 1 : 0;\r\n}\r\nstatic int cmd646_1_dma_end(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 dma_stat = 0, dma_cmd = 0;\r\ndma_stat = inb(hwif->dma_base + ATA_DMA_STATUS);\r\ndma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);\r\noutb(dma_cmd & ~1, hwif->dma_base + ATA_DMA_CMD);\r\noutb(dma_stat | 6, hwif->dma_base + ATA_DMA_STATUS);\r\nreturn (dma_stat & 7) != 4;\r\n}\r\nstatic int init_chipset_cmd64x(struct pci_dev *dev)\r\n{\r\nu8 mrdmode = 0;\r\n(void) pci_write_config_byte(dev, PCI_LATENCY_TIMER, 64);\r\n(void) pci_read_config_byte (dev, MRDMODE, &mrdmode);\r\nmrdmode &= ~0x30;\r\n(void) pci_write_config_byte(dev, MRDMODE, (mrdmode | 0x02));\r\nreturn 0;\r\n}\r\nstatic u8 cmd64x_cable_detect(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nu8 bmidecsr = 0, mask = hwif->channel ? 0x02 : 0x01;\r\nswitch (dev->device) {\r\ncase PCI_DEVICE_ID_CMD_648:\r\ncase PCI_DEVICE_ID_CMD_649:\r\npci_read_config_byte(dev, BMIDECSR, &bmidecsr);\r\nreturn (bmidecsr & mask) ? ATA_CBL_PATA80 : ATA_CBL_PATA40;\r\ndefault:\r\nreturn ATA_CBL_PATA40;\r\n}\r\n}\r\nstatic int cmd64x_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct ide_port_info d;\r\nu8 idx = id->driver_data;\r\nd = cmd64x_chipsets[idx];\r\nif (idx == 1) {\r\nif (dev->revision < 5) {\r\nd.udma_mask = 0x00;\r\nif (dev->revision < 3) {\r\nd.enablebits[0].reg = 0;\r\nd.port_ops = &cmd64x_port_ops;\r\nif (dev->revision == 1)\r\nd.dma_ops = &cmd646_rev1_dma_ops;\r\n}\r\n}\r\n}\r\nreturn ide_pci_init_one(dev, &d, NULL);\r\n}\r\nstatic int __init cmd64x_ide_init(void)\r\n{\r\nreturn ide_pci_register_driver(&cmd64x_pci_driver);\r\n}\r\nstatic void __exit cmd64x_ide_exit(void)\r\n{\r\npci_unregister_driver(&cmd64x_pci_driver);\r\n}
