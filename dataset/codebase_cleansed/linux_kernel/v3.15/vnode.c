static void afs_install_vnode(struct afs_vnode *vnode,\r\nstruct afs_server *server)\r\n{\r\nstruct afs_server *old_server = vnode->server;\r\nstruct afs_vnode *xvnode;\r\nstruct rb_node *parent, **p;\r\n_enter("%p,%p", vnode, server);\r\nif (old_server) {\r\nspin_lock(&old_server->fs_lock);\r\nrb_erase(&vnode->server_rb, &old_server->fs_vnodes);\r\nspin_unlock(&old_server->fs_lock);\r\n}\r\nafs_get_server(server);\r\nvnode->server = server;\r\nafs_put_server(old_server);\r\nspin_lock(&server->fs_lock);\r\nparent = NULL;\r\np = &server->fs_vnodes.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\nxvnode = rb_entry(parent, struct afs_vnode, server_rb);\r\nif (vnode->fid.vid < xvnode->fid.vid)\r\np = &(*p)->rb_left;\r\nelse if (vnode->fid.vid > xvnode->fid.vid)\r\np = &(*p)->rb_right;\r\nelse if (vnode->fid.vnode < xvnode->fid.vnode)\r\np = &(*p)->rb_left;\r\nelse if (vnode->fid.vnode > xvnode->fid.vnode)\r\np = &(*p)->rb_right;\r\nelse if (vnode->fid.unique < xvnode->fid.unique)\r\np = &(*p)->rb_left;\r\nelse if (vnode->fid.unique > xvnode->fid.unique)\r\np = &(*p)->rb_right;\r\nelse\r\nBUG();\r\n}\r\nrb_link_node(&vnode->server_rb, parent, p);\r\nrb_insert_color(&vnode->server_rb, &server->fs_vnodes);\r\nspin_unlock(&server->fs_lock);\r\n_leave("");\r\n}\r\nstatic void afs_vnode_note_promise(struct afs_vnode *vnode,\r\nstruct afs_server *server)\r\n{\r\nstruct afs_server *old_server;\r\nstruct afs_vnode *xvnode;\r\nstruct rb_node *parent, **p;\r\n_enter("%p,%p", vnode, server);\r\nASSERT(server != NULL);\r\nold_server = vnode->server;\r\nif (vnode->cb_promised) {\r\nif (server == old_server &&\r\nvnode->cb_expires == vnode->cb_expires_at) {\r\n_leave(" [no change]");\r\nreturn;\r\n}\r\nspin_lock(&old_server->cb_lock);\r\nif (vnode->cb_promised) {\r\n_debug("delete");\r\nrb_erase(&vnode->cb_promise, &old_server->cb_promises);\r\nvnode->cb_promised = false;\r\n}\r\nspin_unlock(&old_server->cb_lock);\r\n}\r\nif (vnode->server != server)\r\nafs_install_vnode(vnode, server);\r\nvnode->cb_expires_at = vnode->cb_expires;\r\n_debug("PROMISE on %p {%lu}",\r\nvnode, (unsigned long) vnode->cb_expires_at);\r\nspin_lock(&server->cb_lock);\r\nparent = NULL;\r\np = &server->cb_promises.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\nxvnode = rb_entry(parent, struct afs_vnode, cb_promise);\r\nif (vnode->cb_expires_at < xvnode->cb_expires_at)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&vnode->cb_promise, parent, p);\r\nrb_insert_color(&vnode->cb_promise, &server->cb_promises);\r\nvnode->cb_promised = true;\r\nspin_unlock(&server->cb_lock);\r\n_leave("");\r\n}\r\nstatic void afs_vnode_deleted_remotely(struct afs_vnode *vnode)\r\n{\r\nstruct afs_server *server;\r\n_enter("{%p}", vnode->server);\r\nset_bit(AFS_VNODE_DELETED, &vnode->flags);\r\nserver = vnode->server;\r\nif (server) {\r\nif (vnode->cb_promised) {\r\nspin_lock(&server->cb_lock);\r\nif (vnode->cb_promised) {\r\nrb_erase(&vnode->cb_promise,\r\n&server->cb_promises);\r\nvnode->cb_promised = false;\r\n}\r\nspin_unlock(&server->cb_lock);\r\n}\r\nspin_lock(&server->fs_lock);\r\nrb_erase(&vnode->server_rb, &server->fs_vnodes);\r\nspin_unlock(&server->fs_lock);\r\nvnode->server = NULL;\r\nafs_put_server(server);\r\n} else {\r\nASSERT(!vnode->cb_promised);\r\n}\r\n_leave("");\r\n}\r\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\r\nstruct afs_server *server)\r\n{\r\nstruct afs_server *oldserver = NULL;\r\n_enter("%p,%p", vnode, server);\r\nspin_lock(&vnode->lock);\r\nclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\r\nafs_vnode_note_promise(vnode, server);\r\nvnode->update_cnt--;\r\nASSERTCMP(vnode->update_cnt, >=, 0);\r\nspin_unlock(&vnode->lock);\r\nwake_up_all(&vnode->update_waitq);\r\nafs_put_server(oldserver);\r\n_leave("");\r\n}\r\nstatic void afs_vnode_status_update_failed(struct afs_vnode *vnode, int ret)\r\n{\r\n_enter("{%x:%u},%d", vnode->fid.vid, vnode->fid.vnode, ret);\r\nspin_lock(&vnode->lock);\r\nclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\r\nif (ret == -ENOENT) {\r\n_debug("got NOENT from server - marking file deleted");\r\nafs_vnode_deleted_remotely(vnode);\r\n}\r\nvnode->update_cnt--;\r\nASSERTCMP(vnode->update_cnt, >=, 0);\r\nspin_unlock(&vnode->lock);\r\nwake_up_all(&vnode->update_waitq);\r\n_leave("");\r\n}\r\nint afs_vnode_fetch_status(struct afs_vnode *vnode,\r\nstruct afs_vnode *auth_vnode, struct key *key)\r\n{\r\nstruct afs_server *server;\r\nunsigned long acl_order;\r\nint ret;\r\nDECLARE_WAITQUEUE(myself, current);\r\n_enter("%s,{%x:%u.%u}",\r\nvnode->volume->vlocation->vldb.name,\r\nvnode->fid.vid, vnode->fid.vnode, vnode->fid.unique);\r\nif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\r\nvnode->cb_promised) {\r\n_leave(" [unchanged]");\r\nreturn 0;\r\n}\r\nif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\r\n_leave(" [deleted]");\r\nreturn -ENOENT;\r\n}\r\nacl_order = 0;\r\nif (auth_vnode)\r\nacl_order = auth_vnode->acl_order;\r\nspin_lock(&vnode->lock);\r\nif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\r\nvnode->cb_promised) {\r\nspin_unlock(&vnode->lock);\r\n_leave(" [unchanged]");\r\nreturn 0;\r\n}\r\nASSERTCMP(vnode->update_cnt, >=, 0);\r\nif (vnode->update_cnt > 0) {\r\n_debug("wait on fetch %d", vnode->update_cnt);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nASSERT(myself.func != NULL);\r\nadd_wait_queue(&vnode->update_waitq, &myself);\r\nfor (;;) {\r\nif (!test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\r\nbreak;\r\nif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\r\nbreak;\r\nif (vnode->update_cnt == 0) {\r\nremove_wait_queue(&vnode->update_waitq,\r\n&myself);\r\nset_current_state(TASK_RUNNING);\r\ngoto get_anyway;\r\n}\r\nspin_unlock(&vnode->lock);\r\nschedule();\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nspin_lock(&vnode->lock);\r\n}\r\nremove_wait_queue(&vnode->update_waitq, &myself);\r\nspin_unlock(&vnode->lock);\r\nset_current_state(TASK_RUNNING);\r\nreturn test_bit(AFS_VNODE_DELETED, &vnode->flags) ?\r\n-ENOENT : 0;\r\n}\r\nget_anyway:\r\nvnode->update_cnt++;\r\nspin_unlock(&vnode->lock);\r\ndo {\r\nserver = afs_volume_pick_fileserver(vnode);\r\nif (IS_ERR(server))\r\ngoto no_server;\r\n_debug("USING SERVER: %p{%08x}",\r\nserver, ntohl(server->addr.s_addr));\r\nret = afs_fs_fetch_file_status(server, key, vnode, NULL,\r\n&afs_sync_call);\r\n} while (!afs_volume_release_fileserver(vnode, server, ret));\r\nif (ret == 0) {\r\n_debug("adjust");\r\nif (auth_vnode)\r\nafs_cache_permit(vnode, key, acl_order);\r\nafs_vnode_finalise_status_update(vnode, server);\r\nafs_put_server(server);\r\n} else {\r\n_debug("failed [%d]", ret);\r\nafs_vnode_status_update_failed(vnode, ret);\r\n}\r\nASSERTCMP(vnode->update_cnt, >=, 0);\r\n_leave(" = %d [cnt %d]", ret, vnode->update_cnt);\r\nreturn ret;\r\nno_server:\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt--;\r\nASSERTCMP(vnode->update_cnt, >=, 0);\r\nspin_unlock(&vnode->lock);\r\n_leave(" = %ld [cnt %d]", PTR_ERR(server), vnode->update_cnt);\r\nreturn PTR_ERR(server);\r\n}\r\nint afs_vnode_fetch_data(struct afs_vnode *vnode, struct key *key,\r\noff_t offset, size_t length, struct page *page)\r\n{\r\nstruct afs_server *server;\r\nint ret;\r\n_enter("%s{%x:%u.%u},%x,,,",\r\nvnode->volume->vlocation->vldb.name,\r\nvnode->fid.vid,\r\nvnode->fid.vnode,\r\nvnode->fid.unique,\r\nkey_serial(key));\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt++;\r\nspin_unlock(&vnode->lock);\r\ndo {\r\nserver = afs_volume_pick_fileserver(vnode);\r\nif (IS_ERR(server))\r\ngoto no_server;\r\n_debug("USING SERVER: %08x\n", ntohl(server->addr.s_addr));\r\nret = afs_fs_fetch_data(server, key, vnode, offset, length,\r\npage, &afs_sync_call);\r\n} while (!afs_volume_release_fileserver(vnode, server, ret));\r\nif (ret == 0) {\r\nafs_vnode_finalise_status_update(vnode, server);\r\nafs_put_server(server);\r\n} else {\r\nafs_vnode_status_update_failed(vnode, ret);\r\n}\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nno_server:\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt--;\r\nASSERTCMP(vnode->update_cnt, >=, 0);\r\nspin_unlock(&vnode->lock);\r\nreturn PTR_ERR(server);\r\n}\r\nint afs_vnode_create(struct afs_vnode *vnode, struct key *key,\r\nconst char *name, umode_t mode, struct afs_fid *newfid,\r\nstruct afs_file_status *newstatus,\r\nstruct afs_callback *newcb, struct afs_server **_server)\r\n{\r\nstruct afs_server *server;\r\nint ret;\r\n_enter("%s{%x:%u.%u},%x,%s,,",\r\nvnode->volume->vlocation->vldb.name,\r\nvnode->fid.vid,\r\nvnode->fid.vnode,\r\nvnode->fid.unique,\r\nkey_serial(key),\r\nname);\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt++;\r\nspin_unlock(&vnode->lock);\r\ndo {\r\nserver = afs_volume_pick_fileserver(vnode);\r\nif (IS_ERR(server))\r\ngoto no_server;\r\n_debug("USING SERVER: %08x\n", ntohl(server->addr.s_addr));\r\nret = afs_fs_create(server, key, vnode, name, mode, newfid,\r\nnewstatus, newcb, &afs_sync_call);\r\n} while (!afs_volume_release_fileserver(vnode, server, ret));\r\nif (ret == 0) {\r\nafs_vnode_finalise_status_update(vnode, server);\r\n*_server = server;\r\n} else {\r\nafs_vnode_status_update_failed(vnode, ret);\r\n*_server = NULL;\r\n}\r\n_leave(" = %d [cnt %d]", ret, vnode->update_cnt);\r\nreturn ret;\r\nno_server:\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt--;\r\nASSERTCMP(vnode->update_cnt, >=, 0);\r\nspin_unlock(&vnode->lock);\r\n_leave(" = %ld [cnt %d]", PTR_ERR(server), vnode->update_cnt);\r\nreturn PTR_ERR(server);\r\n}\r\nint afs_vnode_remove(struct afs_vnode *vnode, struct key *key, const char *name,\r\nbool isdir)\r\n{\r\nstruct afs_server *server;\r\nint ret;\r\n_enter("%s{%x:%u.%u},%x,%s",\r\nvnode->volume->vlocation->vldb.name,\r\nvnode->fid.vid,\r\nvnode->fid.vnode,\r\nvnode->fid.unique,\r\nkey_serial(key),\r\nname);\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt++;\r\nspin_unlock(&vnode->lock);\r\ndo {\r\nserver = afs_volume_pick_fileserver(vnode);\r\nif (IS_ERR(server))\r\ngoto no_server;\r\n_debug("USING SERVER: %08x\n", ntohl(server->addr.s_addr));\r\nret = afs_fs_remove(server, key, vnode, name, isdir,\r\n&afs_sync_call);\r\n} while (!afs_volume_release_fileserver(vnode, server, ret));\r\nif (ret == 0) {\r\nafs_vnode_finalise_status_update(vnode, server);\r\nafs_put_server(server);\r\n} else {\r\nafs_vnode_status_update_failed(vnode, ret);\r\n}\r\n_leave(" = %d [cnt %d]", ret, vnode->update_cnt);\r\nreturn ret;\r\nno_server:\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt--;\r\nASSERTCMP(vnode->update_cnt, >=, 0);\r\nspin_unlock(&vnode->lock);\r\n_leave(" = %ld [cnt %d]", PTR_ERR(server), vnode->update_cnt);\r\nreturn PTR_ERR(server);\r\n}\r\nint afs_vnode_link(struct afs_vnode *dvnode, struct afs_vnode *vnode,\r\nstruct key *key, const char *name)\r\n{\r\nstruct afs_server *server;\r\nint ret;\r\n_enter("%s{%x:%u.%u},%s{%x:%u.%u},%x,%s",\r\ndvnode->volume->vlocation->vldb.name,\r\ndvnode->fid.vid,\r\ndvnode->fid.vnode,\r\ndvnode->fid.unique,\r\nvnode->volume->vlocation->vldb.name,\r\nvnode->fid.vid,\r\nvnode->fid.vnode,\r\nvnode->fid.unique,\r\nkey_serial(key),\r\nname);\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt++;\r\nspin_unlock(&vnode->lock);\r\nspin_lock(&dvnode->lock);\r\ndvnode->update_cnt++;\r\nspin_unlock(&dvnode->lock);\r\ndo {\r\nserver = afs_volume_pick_fileserver(dvnode);\r\nif (IS_ERR(server))\r\ngoto no_server;\r\n_debug("USING SERVER: %08x\n", ntohl(server->addr.s_addr));\r\nret = afs_fs_link(server, key, dvnode, vnode, name,\r\n&afs_sync_call);\r\n} while (!afs_volume_release_fileserver(dvnode, server, ret));\r\nif (ret == 0) {\r\nafs_vnode_finalise_status_update(vnode, server);\r\nafs_vnode_finalise_status_update(dvnode, server);\r\nafs_put_server(server);\r\n} else {\r\nafs_vnode_status_update_failed(vnode, ret);\r\nafs_vnode_status_update_failed(dvnode, ret);\r\n}\r\n_leave(" = %d [cnt %d]", ret, vnode->update_cnt);\r\nreturn ret;\r\nno_server:\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt--;\r\nASSERTCMP(vnode->update_cnt, >=, 0);\r\nspin_unlock(&vnode->lock);\r\nspin_lock(&dvnode->lock);\r\ndvnode->update_cnt--;\r\nASSERTCMP(dvnode->update_cnt, >=, 0);\r\nspin_unlock(&dvnode->lock);\r\n_leave(" = %ld [cnt %d]", PTR_ERR(server), vnode->update_cnt);\r\nreturn PTR_ERR(server);\r\n}\r\nint afs_vnode_symlink(struct afs_vnode *vnode, struct key *key,\r\nconst char *name, const char *content,\r\nstruct afs_fid *newfid,\r\nstruct afs_file_status *newstatus,\r\nstruct afs_server **_server)\r\n{\r\nstruct afs_server *server;\r\nint ret;\r\n_enter("%s{%x:%u.%u},%x,%s,%s,,,",\r\nvnode->volume->vlocation->vldb.name,\r\nvnode->fid.vid,\r\nvnode->fid.vnode,\r\nvnode->fid.unique,\r\nkey_serial(key),\r\nname, content);\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt++;\r\nspin_unlock(&vnode->lock);\r\ndo {\r\nserver = afs_volume_pick_fileserver(vnode);\r\nif (IS_ERR(server))\r\ngoto no_server;\r\n_debug("USING SERVER: %08x\n", ntohl(server->addr.s_addr));\r\nret = afs_fs_symlink(server, key, vnode, name, content,\r\nnewfid, newstatus, &afs_sync_call);\r\n} while (!afs_volume_release_fileserver(vnode, server, ret));\r\nif (ret == 0) {\r\nafs_vnode_finalise_status_update(vnode, server);\r\n*_server = server;\r\n} else {\r\nafs_vnode_status_update_failed(vnode, ret);\r\n*_server = NULL;\r\n}\r\n_leave(" = %d [cnt %d]", ret, vnode->update_cnt);\r\nreturn ret;\r\nno_server:\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt--;\r\nASSERTCMP(vnode->update_cnt, >=, 0);\r\nspin_unlock(&vnode->lock);\r\n_leave(" = %ld [cnt %d]", PTR_ERR(server), vnode->update_cnt);\r\nreturn PTR_ERR(server);\r\n}\r\nint afs_vnode_rename(struct afs_vnode *orig_dvnode,\r\nstruct afs_vnode *new_dvnode,\r\nstruct key *key,\r\nconst char *orig_name,\r\nconst char *new_name)\r\n{\r\nstruct afs_server *server;\r\nint ret;\r\n_enter("%s{%x:%u.%u},%s{%u,%u,%u},%x,%s,%s",\r\norig_dvnode->volume->vlocation->vldb.name,\r\norig_dvnode->fid.vid,\r\norig_dvnode->fid.vnode,\r\norig_dvnode->fid.unique,\r\nnew_dvnode->volume->vlocation->vldb.name,\r\nnew_dvnode->fid.vid,\r\nnew_dvnode->fid.vnode,\r\nnew_dvnode->fid.unique,\r\nkey_serial(key),\r\norig_name,\r\nnew_name);\r\nspin_lock(&orig_dvnode->lock);\r\norig_dvnode->update_cnt++;\r\nspin_unlock(&orig_dvnode->lock);\r\nif (new_dvnode != orig_dvnode) {\r\nspin_lock(&new_dvnode->lock);\r\nnew_dvnode->update_cnt++;\r\nspin_unlock(&new_dvnode->lock);\r\n}\r\ndo {\r\nserver = afs_volume_pick_fileserver(orig_dvnode);\r\nif (IS_ERR(server))\r\ngoto no_server;\r\n_debug("USING SERVER: %08x\n", ntohl(server->addr.s_addr));\r\nret = afs_fs_rename(server, key, orig_dvnode, orig_name,\r\nnew_dvnode, new_name, &afs_sync_call);\r\n} while (!afs_volume_release_fileserver(orig_dvnode, server, ret));\r\nif (ret == 0) {\r\nafs_vnode_finalise_status_update(orig_dvnode, server);\r\nif (new_dvnode != orig_dvnode)\r\nafs_vnode_finalise_status_update(new_dvnode, server);\r\nafs_put_server(server);\r\n} else {\r\nafs_vnode_status_update_failed(orig_dvnode, ret);\r\nif (new_dvnode != orig_dvnode)\r\nafs_vnode_status_update_failed(new_dvnode, ret);\r\n}\r\n_leave(" = %d [cnt %d]", ret, orig_dvnode->update_cnt);\r\nreturn ret;\r\nno_server:\r\nspin_lock(&orig_dvnode->lock);\r\norig_dvnode->update_cnt--;\r\nASSERTCMP(orig_dvnode->update_cnt, >=, 0);\r\nspin_unlock(&orig_dvnode->lock);\r\nif (new_dvnode != orig_dvnode) {\r\nspin_lock(&new_dvnode->lock);\r\nnew_dvnode->update_cnt--;\r\nASSERTCMP(new_dvnode->update_cnt, >=, 0);\r\nspin_unlock(&new_dvnode->lock);\r\n}\r\n_leave(" = %ld [cnt %d]", PTR_ERR(server), orig_dvnode->update_cnt);\r\nreturn PTR_ERR(server);\r\n}\r\nint afs_vnode_store_data(struct afs_writeback *wb, pgoff_t first, pgoff_t last,\r\nunsigned offset, unsigned to)\r\n{\r\nstruct afs_server *server;\r\nstruct afs_vnode *vnode = wb->vnode;\r\nint ret;\r\n_enter("%s{%x:%u.%u},%x,%lx,%lx,%x,%x",\r\nvnode->volume->vlocation->vldb.name,\r\nvnode->fid.vid,\r\nvnode->fid.vnode,\r\nvnode->fid.unique,\r\nkey_serial(wb->key),\r\nfirst, last, offset, to);\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt++;\r\nspin_unlock(&vnode->lock);\r\ndo {\r\nserver = afs_volume_pick_fileserver(vnode);\r\nif (IS_ERR(server))\r\ngoto no_server;\r\n_debug("USING SERVER: %08x\n", ntohl(server->addr.s_addr));\r\nret = afs_fs_store_data(server, wb, first, last, offset, to,\r\n&afs_sync_call);\r\n} while (!afs_volume_release_fileserver(vnode, server, ret));\r\nif (ret == 0) {\r\nafs_vnode_finalise_status_update(vnode, server);\r\nafs_put_server(server);\r\n} else {\r\nafs_vnode_status_update_failed(vnode, ret);\r\n}\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nno_server:\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt--;\r\nASSERTCMP(vnode->update_cnt, >=, 0);\r\nspin_unlock(&vnode->lock);\r\nreturn PTR_ERR(server);\r\n}\r\nint afs_vnode_setattr(struct afs_vnode *vnode, struct key *key,\r\nstruct iattr *attr)\r\n{\r\nstruct afs_server *server;\r\nint ret;\r\n_enter("%s{%x:%u.%u},%x",\r\nvnode->volume->vlocation->vldb.name,\r\nvnode->fid.vid,\r\nvnode->fid.vnode,\r\nvnode->fid.unique,\r\nkey_serial(key));\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt++;\r\nspin_unlock(&vnode->lock);\r\ndo {\r\nserver = afs_volume_pick_fileserver(vnode);\r\nif (IS_ERR(server))\r\ngoto no_server;\r\n_debug("USING SERVER: %08x\n", ntohl(server->addr.s_addr));\r\nret = afs_fs_setattr(server, key, vnode, attr, &afs_sync_call);\r\n} while (!afs_volume_release_fileserver(vnode, server, ret));\r\nif (ret == 0) {\r\nafs_vnode_finalise_status_update(vnode, server);\r\nafs_put_server(server);\r\n} else {\r\nafs_vnode_status_update_failed(vnode, ret);\r\n}\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nno_server:\r\nspin_lock(&vnode->lock);\r\nvnode->update_cnt--;\r\nASSERTCMP(vnode->update_cnt, >=, 0);\r\nspin_unlock(&vnode->lock);\r\nreturn PTR_ERR(server);\r\n}\r\nint afs_vnode_get_volume_status(struct afs_vnode *vnode, struct key *key,\r\nstruct afs_volume_status *vs)\r\n{\r\nstruct afs_server *server;\r\nint ret;\r\n_enter("%s{%x:%u.%u},%x,",\r\nvnode->volume->vlocation->vldb.name,\r\nvnode->fid.vid,\r\nvnode->fid.vnode,\r\nvnode->fid.unique,\r\nkey_serial(key));\r\ndo {\r\nserver = afs_volume_pick_fileserver(vnode);\r\nif (IS_ERR(server))\r\ngoto no_server;\r\n_debug("USING SERVER: %08x\n", ntohl(server->addr.s_addr));\r\nret = afs_fs_get_volume_status(server, key, vnode, vs, &afs_sync_call);\r\n} while (!afs_volume_release_fileserver(vnode, server, ret));\r\nif (ret == 0)\r\nafs_put_server(server);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nno_server:\r\nreturn PTR_ERR(server);\r\n}\r\nint afs_vnode_set_lock(struct afs_vnode *vnode, struct key *key,\r\nafs_lock_type_t type)\r\n{\r\nstruct afs_server *server;\r\nint ret;\r\n_enter("%s{%x:%u.%u},%x,%u",\r\nvnode->volume->vlocation->vldb.name,\r\nvnode->fid.vid,\r\nvnode->fid.vnode,\r\nvnode->fid.unique,\r\nkey_serial(key), type);\r\ndo {\r\nserver = afs_volume_pick_fileserver(vnode);\r\nif (IS_ERR(server))\r\ngoto no_server;\r\n_debug("USING SERVER: %08x\n", ntohl(server->addr.s_addr));\r\nret = afs_fs_set_lock(server, key, vnode, type, &afs_sync_call);\r\n} while (!afs_volume_release_fileserver(vnode, server, ret));\r\nif (ret == 0)\r\nafs_put_server(server);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nno_server:\r\nreturn PTR_ERR(server);\r\n}\r\nint afs_vnode_extend_lock(struct afs_vnode *vnode, struct key *key)\r\n{\r\nstruct afs_server *server;\r\nint ret;\r\n_enter("%s{%x:%u.%u},%x",\r\nvnode->volume->vlocation->vldb.name,\r\nvnode->fid.vid,\r\nvnode->fid.vnode,\r\nvnode->fid.unique,\r\nkey_serial(key));\r\ndo {\r\nserver = afs_volume_pick_fileserver(vnode);\r\nif (IS_ERR(server))\r\ngoto no_server;\r\n_debug("USING SERVER: %08x\n", ntohl(server->addr.s_addr));\r\nret = afs_fs_extend_lock(server, key, vnode, &afs_sync_call);\r\n} while (!afs_volume_release_fileserver(vnode, server, ret));\r\nif (ret == 0)\r\nafs_put_server(server);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nno_server:\r\nreturn PTR_ERR(server);\r\n}\r\nint afs_vnode_release_lock(struct afs_vnode *vnode, struct key *key)\r\n{\r\nstruct afs_server *server;\r\nint ret;\r\n_enter("%s{%x:%u.%u},%x",\r\nvnode->volume->vlocation->vldb.name,\r\nvnode->fid.vid,\r\nvnode->fid.vnode,\r\nvnode->fid.unique,\r\nkey_serial(key));\r\ndo {\r\nserver = afs_volume_pick_fileserver(vnode);\r\nif (IS_ERR(server))\r\ngoto no_server;\r\n_debug("USING SERVER: %08x\n", ntohl(server->addr.s_addr));\r\nret = afs_fs_release_lock(server, key, vnode, &afs_sync_call);\r\n} while (!afs_volume_release_fileserver(vnode, server, ret));\r\nif (ret == 0)\r\nafs_put_server(server);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nno_server:\r\nreturn PTR_ERR(server);\r\n}
