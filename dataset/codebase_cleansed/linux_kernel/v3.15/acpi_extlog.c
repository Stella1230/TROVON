static struct acpi_generic_status *extlog_elog_entry_check(int cpu, int bank)\r\n{\r\nint idx;\r\nu64 data;\r\nstruct acpi_generic_status *estatus;\r\nWARN_ON(cpu < 0);\r\nidx = ELOG_IDX(cpu, bank);\r\ndata = ELOG_ENTRY_DATA(idx);\r\nif ((data & ELOG_ENTRY_VALID) == 0)\r\nreturn NULL;\r\ndata &= EXT_ELOG_ENTRY_MASK;\r\nestatus = (struct acpi_generic_status *)ELOG_ENTRY_ADDR(data);\r\nif (estatus->block_status == 0)\r\nreturn NULL;\r\nreturn estatus;\r\n}\r\nstatic void __print_extlog_rcd(const char *pfx,\r\nstruct acpi_generic_status *estatus, int cpu)\r\n{\r\nstatic atomic_t seqno;\r\nunsigned int curr_seqno;\r\nchar pfx_seq[64];\r\nif (!pfx) {\r\nif (estatus->error_severity <= CPER_SEV_CORRECTED)\r\npfx = KERN_INFO;\r\nelse\r\npfx = KERN_ERR;\r\n}\r\ncurr_seqno = atomic_inc_return(&seqno);\r\nsnprintf(pfx_seq, sizeof(pfx_seq), "%s{%u}", pfx, curr_seqno);\r\nprintk("%s""Hardware error detected on CPU%d\n", pfx_seq, cpu);\r\ncper_estatus_print(pfx_seq, estatus);\r\n}\r\nstatic int print_extlog_rcd(const char *pfx,\r\nstruct acpi_generic_status *estatus, int cpu)\r\n{\r\n/* Not more than 2 messages every 5 seconds */\r\nstatic DEFINE_RATELIMIT_STATE(ratelimit_corrected, 5*HZ, 2);\r\nstatic DEFINE_RATELIMIT_STATE(ratelimit_uncorrected, 5*HZ, 2);\r\nstruct ratelimit_state *ratelimit;\r\nif (estatus->error_severity == CPER_SEV_CORRECTED ||\r\n(estatus->error_severity == CPER_SEV_INFORMATIONAL))\r\nratelimit = &ratelimit_corrected;\r\nelse\r\nratelimit = &ratelimit_uncorrected;\r\nif (__ratelimit(ratelimit)) {\r\n__print_extlog_rcd(pfx, estatus, cpu);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int extlog_print(struct notifier_block *nb, unsigned long val,\r\nvoid *data)\r\n{\r\nstruct mce *mce = (struct mce *)data;\r\nint bank = mce->bank;\r\nint cpu = mce->extcpu;\r\nstruct acpi_generic_status *estatus;\r\nint rc;\r\nestatus = extlog_elog_entry_check(cpu, bank);\r\nif (estatus == NULL)\r\nreturn NOTIFY_DONE;\r\nmemcpy(elog_buf, (void *)estatus, ELOG_ENTRY_LEN);\r\n/* clear record status to enable BIOS to update it again */\r\nestatus->block_status = 0;\r\nrc = print_extlog_rcd(NULL, (struct acpi_generic_status *)elog_buf, cpu);\r\nreturn NOTIFY_STOP;\r\n}\r\nstatic bool __init extlog_get_l1addr(void)\r\n{\r\nu8 uuid[16];\r\nacpi_handle handle;\r\nunion acpi_object *obj;\r\nacpi_str_to_uuid(extlog_dsm_uuid, uuid);\r\nif (ACPI_FAILURE(acpi_get_handle(NULL, "\\_SB", &handle)))\r\nreturn false;\r\nif (!acpi_check_dsm(handle, uuid, EXTLOG_DSM_REV, 1 << EXTLOG_FN_ADDR))\r\nreturn false;\r\nobj = acpi_evaluate_dsm_typed(handle, uuid, EXTLOG_DSM_REV,\r\nEXTLOG_FN_ADDR, NULL, ACPI_TYPE_INTEGER);\r\nif (!obj) {\r\nreturn false;\r\n} else {\r\nl1_dirbase = obj->integer.value;\r\nACPI_FREE(obj);\r\n}\r\n/* Spec says L1 directory must be 4K aligned, bail out if it isn't */\r\nif (l1_dirbase & ((1 << 12) - 1)) {\r\npr_warn(FW_BUG "L1 Directory is invalid at physical %llx\n",\r\nl1_dirbase);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic struct notifier_block extlog_mce_dec = {\r\n.notifier_call = extlog_print,\r\n};\r\nstatic int __init extlog_init(void)\r\n{\r\nstruct extlog_l1_head *l1_head;\r\nvoid __iomem *extlog_l1_hdr;\r\nsize_t l1_hdr_size;\r\nstruct resource *r;\r\nu64 cap;\r\nint rc;\r\nif (get_edac_report_status() == EDAC_REPORTING_FORCE) {\r\npr_warn("Not loading eMCA, error reporting force-enabled through EDAC.\n");\r\nreturn -EPERM;\r\n}\r\nrc = -ENODEV;\r\nrdmsrl(MSR_IA32_MCG_CAP, cap);\r\nif (!(cap & MCG_ELOG_P))\r\nreturn rc;\r\nif (!extlog_get_l1addr())\r\nreturn rc;\r\nrc = -EINVAL;\r\n/* get L1 header to fetch necessary information */\r\nl1_hdr_size = sizeof(struct extlog_l1_head);\r\nr = request_mem_region(l1_dirbase, l1_hdr_size, "L1 DIR HDR");\r\nif (!r) {\r\npr_warn(FW_BUG EMCA_BUG,\r\n(unsigned long long)l1_dirbase,\r\n(unsigned long long)l1_dirbase + l1_hdr_size);\r\ngoto err;\r\n}\r\nextlog_l1_hdr = acpi_os_map_memory(l1_dirbase, l1_hdr_size);\r\nl1_head = (struct extlog_l1_head *)extlog_l1_hdr;\r\nl1_size = l1_head->total_len;\r\nl1_percpu_entry = l1_head->entries;\r\nelog_base = l1_head->elog_base;\r\nelog_size = l1_head->elog_len;\r\nacpi_os_unmap_memory(extlog_l1_hdr, l1_hdr_size);\r\nrelease_mem_region(l1_dirbase, l1_hdr_size);\r\n/* remap L1 header again based on completed information */\r\nr = request_mem_region(l1_dirbase, l1_size, "L1 Table");\r\nif (!r) {\r\npr_warn(FW_BUG EMCA_BUG,\r\n(unsigned long long)l1_dirbase,\r\n(unsigned long long)l1_dirbase + l1_size);\r\ngoto err;\r\n}\r\nextlog_l1_addr = acpi_os_map_memory(l1_dirbase, l1_size);\r\nl1_entry_base = (u64 *)((u8 *)extlog_l1_addr + l1_hdr_size);\r\n/* remap elog table */\r\nr = request_mem_region(elog_base, elog_size, "Elog Table");\r\nif (!r) {\r\npr_warn(FW_BUG EMCA_BUG,\r\n(unsigned long long)elog_base,\r\n(unsigned long long)elog_base + elog_size);\r\ngoto err_release_l1_dir;\r\n}\r\nelog_addr = acpi_os_map_memory(elog_base, elog_size);\r\nrc = -ENOMEM;\r\n/* allocate buffer to save elog record */\r\nelog_buf = kmalloc(ELOG_ENTRY_LEN, GFP_KERNEL);\r\nif (elog_buf == NULL)\r\ngoto err_release_elog;\r\n/*\r\n* eMCA event report method has higher priority than EDAC method,\r\n* unless EDAC event report method is mandatory.\r\n*/\r\nold_edac_report_status = get_edac_report_status();\r\nset_edac_report_status(EDAC_REPORTING_DISABLED);\r\nmce_register_decode_chain(&extlog_mce_dec);\r\n/* enable OS to be involved to take over management from BIOS */\r\n((struct extlog_l1_head *)extlog_l1_addr)->flags |= FLAG_OS_OPTIN;\r\nreturn 0;\r\nerr_release_elog:\r\nif (elog_addr)\r\nacpi_os_unmap_memory(elog_addr, elog_size);\r\nrelease_mem_region(elog_base, elog_size);\r\nerr_release_l1_dir:\r\nif (extlog_l1_addr)\r\nacpi_os_unmap_memory(extlog_l1_addr, l1_size);\r\nrelease_mem_region(l1_dirbase, l1_size);\r\nerr:\r\npr_warn(FW_BUG "Extended error log disabled because of problems parsing f/w tables\n");\r\nreturn rc;\r\n}\r\nstatic void __exit extlog_exit(void)\r\n{\r\nset_edac_report_status(old_edac_report_status);\r\nmce_unregister_decode_chain(&extlog_mce_dec);\r\n((struct extlog_l1_head *)extlog_l1_addr)->flags &= ~FLAG_OS_OPTIN;\r\nif (extlog_l1_addr)\r\nacpi_os_unmap_memory(extlog_l1_addr, l1_size);\r\nif (elog_addr)\r\nacpi_os_unmap_memory(elog_addr, elog_size);\r\nrelease_mem_region(elog_base, elog_size);\r\nrelease_mem_region(l1_dirbase, l1_size);\r\nkfree(elog_buf);\r\n}\r\nmodule_init(extlog_init);\r\nmodule_exit(extlog_exit);\r\nMODULE_AUTHOR("Chen, Gong <gong.chen@intel.com>");\r\nMODULE_DESCRIPTION("Extended MCA Error Log Driver");\r\nMODULE_LICENSE("GPL"
