int __init irttp_init(void)\r\n{\r\nirttp = kzalloc(sizeof(struct irttp_cb), GFP_KERNEL);\r\nif (irttp == NULL)\r\nreturn -ENOMEM;\r\nirttp->magic = TTP_MAGIC;\r\nirttp->tsaps = hashbin_new(HB_LOCK);\r\nif (!irttp->tsaps) {\r\nIRDA_ERROR("%s: can't allocate IrTTP hashbin!\n",\r\n__func__);\r\nkfree(irttp);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid irttp_cleanup(void)\r\n{\r\nIRDA_ASSERT(irttp->magic == TTP_MAGIC, return;);\r\nhashbin_delete(irttp->tsaps, (FREE_FUNC) __irttp_close_tsap);\r\nirttp->magic = 0;\r\nkfree(irttp);\r\nirttp = NULL;\r\n}\r\nstatic inline void irttp_start_todo_timer(struct tsap_cb *self, int timeout)\r\n{\r\nmod_timer(&self->todo_timer, jiffies + timeout);\r\n}\r\nstatic void irttp_todo_expired(unsigned long data)\r\n{\r\nstruct tsap_cb *self = (struct tsap_cb *) data;\r\nif (!self || self->magic != TTP_TSAP_MAGIC)\r\nreturn;\r\nIRDA_DEBUG(4, "%s(instance=%p)\n", __func__, self);\r\nirttp_run_rx_queue(self);\r\nirttp_run_tx_queue(self);\r\nif (test_bit(0, &self->disconnect_pend)) {\r\nif (skb_queue_empty(&self->tx_queue)) {\r\nclear_bit(0, &self->disconnect_pend);\r\nirttp_disconnect_request(self, self->disconnect_skb,\r\nP_NORMAL);\r\nself->disconnect_skb = NULL;\r\n} else {\r\nirttp_start_todo_timer(self, HZ/10);\r\nreturn;\r\n}\r\n}\r\nif (self->close_pend)\r\nirttp_close_tsap(self);\r\n}\r\nstatic void irttp_flush_queues(struct tsap_cb *self)\r\n{\r\nstruct sk_buff *skb;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return;);\r\nwhile ((skb = skb_dequeue(&self->tx_queue)) != NULL)\r\ndev_kfree_skb(skb);\r\nwhile ((skb = skb_dequeue(&self->rx_queue)) != NULL)\r\ndev_kfree_skb(skb);\r\nwhile ((skb = skb_dequeue(&self->rx_fragments)) != NULL)\r\ndev_kfree_skb(skb);\r\n}\r\nstatic struct sk_buff *irttp_reassemble_skb(struct tsap_cb *self)\r\n{\r\nstruct sk_buff *skb, *frag;\r\nint n = 0;\r\nIRDA_ASSERT(self != NULL, return NULL;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return NULL;);\r\nIRDA_DEBUG(2, "%s(), self->rx_sdu_size=%d\n", __func__,\r\nself->rx_sdu_size);\r\nskb = dev_alloc_skb(TTP_HEADER + self->rx_sdu_size);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, TTP_HEADER);\r\nskb_put(skb, self->rx_sdu_size);\r\nwhile ((frag = skb_dequeue(&self->rx_fragments)) != NULL) {\r\nskb_copy_to_linear_data_offset(skb, n, frag->data, frag->len);\r\nn += frag->len;\r\ndev_kfree_skb(frag);\r\n}\r\nIRDA_DEBUG(2,\r\n"%s(), frame len=%d, rx_sdu_size=%d, rx_max_sdu_size=%d\n",\r\n__func__, n, self->rx_sdu_size, self->rx_max_sdu_size);\r\nIRDA_ASSERT(n <= self->rx_sdu_size, n = self->rx_sdu_size;);\r\nskb_trim(skb, n);\r\nself->rx_sdu_size = 0;\r\nreturn skb;\r\n}\r\nstatic inline void irttp_fragment_skb(struct tsap_cb *self,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff *frag;\r\n__u8 *frame;\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nwhile (skb->len > self->max_seg_size) {\r\nIRDA_DEBUG(2, "%s(), fragmenting ...\n", __func__);\r\nfrag = alloc_skb(self->max_seg_size+self->max_header_size,\r\nGFP_ATOMIC);\r\nif (!frag)\r\nreturn;\r\nskb_reserve(frag, self->max_header_size);\r\nskb_copy_from_linear_data(skb, skb_put(frag, self->max_seg_size),\r\nself->max_seg_size);\r\nframe = skb_push(frag, TTP_HEADER);\r\nframe[0] = TTP_MORE;\r\nskb_pull(skb, self->max_seg_size);\r\nskb_queue_tail(&self->tx_queue, frag);\r\n}\r\nIRDA_DEBUG(2, "%s(), queuing last segment\n", __func__);\r\nframe = skb_push(skb, TTP_HEADER);\r\nframe[0] = 0x00;\r\nskb_queue_tail(&self->tx_queue, skb);\r\n}\r\nstatic int irttp_param_max_sdu_size(void *instance, irda_param_t *param,\r\nint get)\r\n{\r\nstruct tsap_cb *self;\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return -1;);\r\nif (get)\r\nparam->pv.i = self->tx_max_sdu_size;\r\nelse\r\nself->tx_max_sdu_size = param->pv.i;\r\nIRDA_DEBUG(1, "%s(), MaxSduSize=%d\n", __func__, param->pv.i);\r\nreturn 0;\r\n}\r\nstatic void irttp_init_tsap(struct tsap_cb *tsap)\r\n{\r\nspin_lock_init(&tsap->lock);\r\ninit_timer(&tsap->todo_timer);\r\nskb_queue_head_init(&tsap->rx_queue);\r\nskb_queue_head_init(&tsap->tx_queue);\r\nskb_queue_head_init(&tsap->rx_fragments);\r\n}\r\nstruct tsap_cb *irttp_open_tsap(__u8 stsap_sel, int credit, notify_t *notify)\r\n{\r\nstruct tsap_cb *self;\r\nstruct lsap_cb *lsap;\r\nnotify_t ttp_notify;\r\nIRDA_ASSERT(irttp->magic == TTP_MAGIC, return NULL;);\r\nif ((stsap_sel != LSAP_ANY) &&\r\n((stsap_sel < 0x01) || (stsap_sel >= 0x70))) {\r\nIRDA_DEBUG(0, "%s(), invalid tsap!\n", __func__);\r\nreturn NULL;\r\n}\r\nself = kzalloc(sizeof(struct tsap_cb), GFP_ATOMIC);\r\nif (self == NULL) {\r\nIRDA_DEBUG(0, "%s(), unable to kmalloc!\n", __func__);\r\nreturn NULL;\r\n}\r\nirttp_init_tsap(self);\r\nself->todo_timer.data = (unsigned long) self;\r\nself->todo_timer.function = &irttp_todo_expired;\r\nirda_notify_init(&ttp_notify);\r\nttp_notify.connect_confirm = irttp_connect_confirm;\r\nttp_notify.connect_indication = irttp_connect_indication;\r\nttp_notify.disconnect_indication = irttp_disconnect_indication;\r\nttp_notify.data_indication = irttp_data_indication;\r\nttp_notify.udata_indication = irttp_udata_indication;\r\nttp_notify.flow_indication = irttp_flow_indication;\r\nif (notify->status_indication != NULL)\r\nttp_notify.status_indication = irttp_status_indication;\r\nttp_notify.instance = self;\r\nstrncpy(ttp_notify.name, notify->name, NOTIFY_MAX_NAME);\r\nself->magic = TTP_TSAP_MAGIC;\r\nself->connected = FALSE;\r\nlsap = irlmp_open_lsap(stsap_sel, &ttp_notify, 0);\r\nif (lsap == NULL) {\r\nIRDA_DEBUG(0, "%s: unable to allocate LSAP!!\n", __func__);\r\n__irttp_close_tsap(self);\r\nreturn NULL;\r\n}\r\nself->stsap_sel = lsap->slsap_sel;\r\nIRDA_DEBUG(4, "%s(), stsap_sel=%02x\n", __func__, self->stsap_sel);\r\nself->notify = *notify;\r\nself->lsap = lsap;\r\nhashbin_insert(irttp->tsaps, (irda_queue_t *) self, (long) self, NULL);\r\nif (credit > TTP_RX_MAX_CREDIT)\r\nself->initial_credit = TTP_RX_MAX_CREDIT;\r\nelse\r\nself->initial_credit = credit;\r\nreturn self;\r\n}\r\nstatic void __irttp_close_tsap(struct tsap_cb *self)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return;);\r\nirttp_flush_queues(self);\r\ndel_timer(&self->todo_timer);\r\nif (self->disconnect_skb)\r\ndev_kfree_skb(self->disconnect_skb);\r\nself->connected = FALSE;\r\nself->magic = ~TTP_TSAP_MAGIC;\r\nkfree(self);\r\n}\r\nint irttp_close_tsap(struct tsap_cb *self)\r\n{\r\nstruct tsap_cb *tsap;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return -1;);\r\nif (self->connected) {\r\nif (!test_bit(0, &self->disconnect_pend)) {\r\nIRDA_WARNING("%s: TSAP still connected!\n",\r\n__func__);\r\nirttp_disconnect_request(self, NULL, P_NORMAL);\r\n}\r\nself->close_pend = TRUE;\r\nirttp_start_todo_timer(self, HZ/10);\r\nreturn 0;\r\n}\r\ntsap = hashbin_remove(irttp->tsaps, (long) self, NULL);\r\nIRDA_ASSERT(tsap == self, return -1;);\r\nif (self->lsap) {\r\nirlmp_close_lsap(self->lsap);\r\nself->lsap = NULL;\r\n}\r\n__irttp_close_tsap(self);\r\nreturn 0;\r\n}\r\nint irttp_udata_request(struct tsap_cb *self, struct sk_buff *skb)\r\n{\r\nint ret;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return -1;);\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nif (skb->len == 0) {\r\nret = 0;\r\ngoto err;\r\n}\r\nif (!self->connected) {\r\nIRDA_WARNING("%s(), Not connected\n", __func__);\r\nret = -ENOTCONN;\r\ngoto err;\r\n}\r\nif (skb->len > self->max_seg_size) {\r\nIRDA_ERROR("%s(), UData is too large for IrLAP!\n", __func__);\r\nret = -EMSGSIZE;\r\ngoto err;\r\n}\r\nirlmp_udata_request(self->lsap, skb);\r\nself->stats.tx_packets++;\r\nreturn 0;\r\nerr:\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nint irttp_data_request(struct tsap_cb *self, struct sk_buff *skb)\r\n{\r\n__u8 *frame;\r\nint ret;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return -1;);\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\nIRDA_DEBUG(2, "%s() : queue len = %d\n", __func__,\r\nskb_queue_len(&self->tx_queue));\r\nif (skb->len == 0) {\r\nret = 0;\r\ngoto err;\r\n}\r\nif (!self->connected) {\r\nIRDA_WARNING("%s: Not connected\n", __func__);\r\nret = -ENOTCONN;\r\ngoto err;\r\n}\r\nif ((self->tx_max_sdu_size == 0) && (skb->len > self->max_seg_size)) {\r\nIRDA_ERROR("%s: SAR disabled, and data is too large for IrLAP!\n",\r\n__func__);\r\nret = -EMSGSIZE;\r\ngoto err;\r\n}\r\nif ((self->tx_max_sdu_size != 0) &&\r\n(self->tx_max_sdu_size != TTP_SAR_UNBOUND) &&\r\n(skb->len > self->tx_max_sdu_size)) {\r\nIRDA_ERROR("%s: SAR enabled, but data is larger than TxMaxSduSize!\n",\r\n__func__);\r\nret = -EMSGSIZE;\r\ngoto err;\r\n}\r\nif (skb_queue_len(&self->tx_queue) >= TTP_TX_MAX_QUEUE) {\r\nirttp_run_tx_queue(self);\r\nret = -ENOBUFS;\r\ngoto err;\r\n}\r\nif ((self->tx_max_sdu_size == 0) || (skb->len < self->max_seg_size)) {\r\nIRDA_ASSERT(skb_headroom(skb) >= TTP_HEADER, return -1;);\r\nframe = skb_push(skb, TTP_HEADER);\r\nframe[0] = 0x00;\r\nskb_queue_tail(&self->tx_queue, skb);\r\n} else {\r\nirttp_fragment_skb(self, skb);\r\n}\r\nif ((!self->tx_sdu_busy) &&\r\n(skb_queue_len(&self->tx_queue) > TTP_TX_HIGH_THRESHOLD)) {\r\nif (self->notify.flow_indication) {\r\nself->notify.flow_indication(self->notify.instance,\r\nself, FLOW_STOP);\r\n}\r\nself->tx_sdu_busy = TRUE;\r\n}\r\nirttp_run_tx_queue(self);\r\nreturn 0;\r\nerr:\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic void irttp_run_tx_queue(struct tsap_cb *self)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nint n;\r\nIRDA_DEBUG(2, "%s() : send_credit = %d, queue_len = %d\n",\r\n__func__,\r\nself->send_credit, skb_queue_len(&self->tx_queue));\r\nif (irda_lock(&self->tx_queue_lock) == FALSE)\r\nreturn;\r\nwhile ((self->send_credit > 0) &&\r\n(!irlmp_lap_tx_queue_full(self->lsap)) &&\r\n(skb = skb_dequeue(&self->tx_queue))) {\r\nspin_lock_irqsave(&self->lock, flags);\r\nn = self->avail_credit;\r\nself->avail_credit = 0;\r\nif (n > 127) {\r\nself->avail_credit = n-127;\r\nn = 127;\r\n}\r\nself->remote_credit += n;\r\nself->send_credit--;\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nskb->data[0] |= (n & 0x7f);\r\nif (skb->sk != NULL) {\r\nskb_orphan(skb);\r\n}\r\nirlmp_data_request(self->lsap, skb);\r\nself->stats.tx_packets++;\r\n}\r\nif ((self->tx_sdu_busy) &&\r\n(skb_queue_len(&self->tx_queue) < TTP_TX_LOW_THRESHOLD) &&\r\n(!self->close_pend)) {\r\nif (self->notify.flow_indication)\r\nself->notify.flow_indication(self->notify.instance,\r\nself, FLOW_START);\r\nself->tx_sdu_busy = FALSE;\r\n}\r\nself->tx_queue_lock = 0;\r\n}\r\nstatic inline void irttp_give_credit(struct tsap_cb *self)\r\n{\r\nstruct sk_buff *tx_skb = NULL;\r\nunsigned long flags;\r\nint n;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return;);\r\nIRDA_DEBUG(4, "%s() send=%d,avail=%d,remote=%d\n",\r\n__func__,\r\nself->send_credit, self->avail_credit, self->remote_credit);\r\ntx_skb = alloc_skb(TTP_MAX_HEADER, GFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn;\r\nskb_reserve(tx_skb, LMP_MAX_HEADER);\r\nspin_lock_irqsave(&self->lock, flags);\r\nn = self->avail_credit;\r\nself->avail_credit = 0;\r\nif (n > 127) {\r\nself->avail_credit = n - 127;\r\nn = 127;\r\n}\r\nself->remote_credit += n;\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nskb_put(tx_skb, 1);\r\ntx_skb->data[0] = (__u8) (n & 0x7f);\r\nirlmp_data_request(self->lsap, tx_skb);\r\nself->stats.tx_packets++;\r\n}\r\nstatic int irttp_udata_indication(void *instance, void *sap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct tsap_cb *self;\r\nint err;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return -1;);\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\nself->stats.rx_packets++;\r\nif (self->notify.udata_indication) {\r\nerr = self->notify.udata_indication(self->notify.instance,\r\nself, skb);\r\nif (!err)\r\nreturn 0;\r\n}\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int irttp_data_indication(void *instance, void *sap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct tsap_cb *self;\r\nunsigned long flags;\r\nint n;\r\nself = instance;\r\nn = skb->data[0] & 0x7f;\r\nself->stats.rx_packets++;\r\nspin_lock_irqsave(&self->lock, flags);\r\nself->send_credit += n;\r\nif (skb->len > 1)\r\nself->remote_credit--;\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nif (skb->len > 1) {\r\nskb_queue_tail(&self->rx_queue, skb);\r\n} else {\r\ndev_kfree_skb(skb);\r\n}\r\nirttp_run_rx_queue(self);\r\nif (self->send_credit == n) {\r\nirttp_run_tx_queue(self);\r\n}\r\nreturn 0;\r\n}\r\nstatic void irttp_status_indication(void *instance,\r\nLINK_STATUS link, LOCK_STATUS lock)\r\n{\r\nstruct tsap_cb *self;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return;);\r\nif (self->close_pend)\r\nreturn;\r\nif (self->notify.status_indication != NULL)\r\nself->notify.status_indication(self->notify.instance,\r\nlink, lock);\r\nelse\r\nIRDA_DEBUG(2, "%s(), no handler\n", __func__);\r\n}\r\nstatic void irttp_flow_indication(void *instance, void *sap, LOCAL_FLOW flow)\r\n{\r\nstruct tsap_cb *self;\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return;);\r\nIRDA_DEBUG(4, "%s(instance=%p)\n", __func__, self);\r\nirttp_run_tx_queue(self);\r\nif (self->disconnect_pend)\r\nirttp_start_todo_timer(self, 0);\r\n}\r\nvoid irttp_flow_request(struct tsap_cb *self, LOCAL_FLOW flow)\r\n{\r\nIRDA_DEBUG(1, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return;);\r\nswitch (flow) {\r\ncase FLOW_STOP:\r\nIRDA_DEBUG(1, "%s(), flow stop\n", __func__);\r\nself->rx_sdu_busy = TRUE;\r\nbreak;\r\ncase FLOW_START:\r\nIRDA_DEBUG(1, "%s(), flow start\n", __func__);\r\nself->rx_sdu_busy = FALSE;\r\nirttp_run_rx_queue(self);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(1, "%s(), Unknown flow command!\n", __func__);\r\n}\r\n}\r\nint irttp_connect_request(struct tsap_cb *self, __u8 dtsap_sel,\r\n__u32 saddr, __u32 daddr,\r\nstruct qos_info *qos, __u32 max_sdu_size,\r\nstruct sk_buff *userdata)\r\n{\r\nstruct sk_buff *tx_skb;\r\n__u8 *frame;\r\n__u8 n;\r\nIRDA_DEBUG(4, "%s(), max_sdu_size=%d\n", __func__, max_sdu_size);\r\nIRDA_ASSERT(self != NULL, return -EBADR;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return -EBADR;);\r\nif (self->connected) {\r\nif (userdata)\r\ndev_kfree_skb(userdata);\r\nreturn -EISCONN;\r\n}\r\nif (userdata == NULL) {\r\ntx_skb = alloc_skb(TTP_MAX_HEADER + TTP_SAR_HEADER,\r\nGFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn -ENOMEM;\r\nskb_reserve(tx_skb, TTP_MAX_HEADER + TTP_SAR_HEADER);\r\n} else {\r\ntx_skb = userdata;\r\nIRDA_ASSERT(skb_headroom(userdata) >= TTP_MAX_HEADER,\r\n{ dev_kfree_skb(userdata); return -1; });\r\n}\r\nself->connected = FALSE;\r\nself->avail_credit = 0;\r\nself->rx_max_sdu_size = max_sdu_size;\r\nself->rx_sdu_size = 0;\r\nself->rx_sdu_busy = FALSE;\r\nself->dtsap_sel = dtsap_sel;\r\nn = self->initial_credit;\r\nself->remote_credit = 0;\r\nself->send_credit = 0;\r\nif (n > 127) {\r\nself->avail_credit = n - 127;\r\nn = 127;\r\n}\r\nself->remote_credit = n;\r\nif (max_sdu_size > 0) {\r\nIRDA_ASSERT(skb_headroom(tx_skb) >= (TTP_MAX_HEADER + TTP_SAR_HEADER),\r\n{ dev_kfree_skb(tx_skb); return -1; });\r\nframe = skb_push(tx_skb, TTP_HEADER + TTP_SAR_HEADER);\r\nframe[0] = TTP_PARAMETERS | n;\r\nframe[1] = 0x04;\r\nframe[2] = 0x01;\r\nframe[3] = 0x02;\r\nput_unaligned(cpu_to_be16((__u16) max_sdu_size),\r\n(__be16 *)(frame+4));\r\n} else {\r\nframe = skb_push(tx_skb, TTP_HEADER);\r\nframe[0] = n & 0x7f;\r\n}\r\nreturn irlmp_connect_request(self->lsap, dtsap_sel, saddr, daddr, qos,\r\ntx_skb);\r\n}\r\nstatic void irttp_connect_confirm(void *instance, void *sap,\r\nstruct qos_info *qos, __u32 max_seg_size,\r\n__u8 max_header_size, struct sk_buff *skb)\r\n{\r\nstruct tsap_cb *self;\r\nint parameters;\r\nint ret;\r\n__u8 plen;\r\n__u8 n;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nself->max_seg_size = max_seg_size - TTP_HEADER;\r\nself->max_header_size = max_header_size + TTP_HEADER;\r\nif (qos) {\r\nIRDA_DEBUG(4, "IrTTP, Negotiated BAUD_RATE: %02x\n",\r\nqos->baud_rate.bits);\r\nIRDA_DEBUG(4, "IrTTP, Negotiated BAUD_RATE: %d bps.\n",\r\nqos->baud_rate.value);\r\n}\r\nn = skb->data[0] & 0x7f;\r\nIRDA_DEBUG(4, "%s(), Initial send_credit=%d\n", __func__, n);\r\nself->send_credit = n;\r\nself->tx_max_sdu_size = 0;\r\nself->connected = TRUE;\r\nparameters = skb->data[0] & 0x80;\r\nIRDA_ASSERT(skb->len >= TTP_HEADER, return;);\r\nskb_pull(skb, TTP_HEADER);\r\nif (parameters) {\r\nplen = skb->data[0];\r\nret = irda_param_extract_all(self, skb->data+1,\r\nIRDA_MIN(skb->len-1, plen),\r\n&param_info);\r\nif (ret < 0) {\r\nIRDA_WARNING("%s: error extracting parameters\n",\r\n__func__);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nskb_pull(skb, IRDA_MIN(skb->len, plen+1));\r\n}\r\nIRDA_DEBUG(4, "%s() send=%d,avail=%d,remote=%d\n", __func__,\r\nself->send_credit, self->avail_credit, self->remote_credit);\r\nIRDA_DEBUG(2, "%s(), MaxSduSize=%d\n", __func__,\r\nself->tx_max_sdu_size);\r\nif (self->notify.connect_confirm) {\r\nself->notify.connect_confirm(self->notify.instance, self, qos,\r\nself->tx_max_sdu_size,\r\nself->max_header_size, skb);\r\n} else\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void irttp_connect_indication(void *instance, void *sap,\r\nstruct qos_info *qos, __u32 max_seg_size, __u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct tsap_cb *self;\r\nstruct lsap_cb *lsap;\r\nint parameters;\r\nint ret;\r\n__u8 plen;\r\n__u8 n;\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nlsap = sap;\r\nself->max_seg_size = max_seg_size - TTP_HEADER;\r\nself->max_header_size = max_header_size+TTP_HEADER;\r\nIRDA_DEBUG(4, "%s(), TSAP sel=%02x\n", __func__, self->stsap_sel);\r\nself->dtsap_sel = lsap->dlsap_sel;\r\nn = skb->data[0] & 0x7f;\r\nself->send_credit = n;\r\nself->tx_max_sdu_size = 0;\r\nparameters = skb->data[0] & 0x80;\r\nIRDA_ASSERT(skb->len >= TTP_HEADER, return;);\r\nskb_pull(skb, TTP_HEADER);\r\nif (parameters) {\r\nplen = skb->data[0];\r\nret = irda_param_extract_all(self, skb->data+1,\r\nIRDA_MIN(skb->len-1, plen),\r\n&param_info);\r\nif (ret < 0) {\r\nIRDA_WARNING("%s: error extracting parameters\n",\r\n__func__);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nskb_pull(skb, IRDA_MIN(skb->len, plen+1));\r\n}\r\nif (self->notify.connect_indication) {\r\nself->notify.connect_indication(self->notify.instance, self,\r\nqos, self->tx_max_sdu_size,\r\nself->max_header_size, skb);\r\n} else\r\ndev_kfree_skb(skb);\r\n}\r\nint irttp_connect_response(struct tsap_cb *self, __u32 max_sdu_size,\r\nstruct sk_buff *userdata)\r\n{\r\nstruct sk_buff *tx_skb;\r\n__u8 *frame;\r\nint ret;\r\n__u8 n;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return -1;);\r\nIRDA_DEBUG(4, "%s(), Source TSAP selector=%02x\n", __func__,\r\nself->stsap_sel);\r\nif (userdata == NULL) {\r\ntx_skb = alloc_skb(TTP_MAX_HEADER + TTP_SAR_HEADER,\r\nGFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn -ENOMEM;\r\nskb_reserve(tx_skb, TTP_MAX_HEADER + TTP_SAR_HEADER);\r\n} else {\r\ntx_skb = userdata;\r\nIRDA_ASSERT(skb_headroom(userdata) >= TTP_MAX_HEADER,\r\n{ dev_kfree_skb(userdata); return -1; });\r\n}\r\nself->avail_credit = 0;\r\nself->remote_credit = 0;\r\nself->rx_max_sdu_size = max_sdu_size;\r\nself->rx_sdu_size = 0;\r\nself->rx_sdu_busy = FALSE;\r\nn = self->initial_credit;\r\nif (n > 127) {\r\nself->avail_credit = n - 127;\r\nn = 127;\r\n}\r\nself->remote_credit = n;\r\nself->connected = TRUE;\r\nif (max_sdu_size > 0) {\r\nIRDA_ASSERT(skb_headroom(tx_skb) >= (TTP_MAX_HEADER + TTP_SAR_HEADER),\r\n{ dev_kfree_skb(tx_skb); return -1; });\r\nframe = skb_push(tx_skb, TTP_HEADER + TTP_SAR_HEADER);\r\nframe[0] = TTP_PARAMETERS | n;\r\nframe[1] = 0x04;\r\nframe[2] = 0x01;\r\nframe[3] = 0x02;\r\nput_unaligned(cpu_to_be16((__u16) max_sdu_size),\r\n(__be16 *)(frame+4));\r\n} else {\r\nframe = skb_push(tx_skb, TTP_HEADER);\r\nframe[0] = n & 0x7f;\r\n}\r\nret = irlmp_connect_response(self->lsap, tx_skb);\r\nreturn ret;\r\n}\r\nstruct tsap_cb *irttp_dup(struct tsap_cb *orig, void *instance)\r\n{\r\nstruct tsap_cb *new;\r\nunsigned long flags;\r\nIRDA_DEBUG(1, "%s()\n", __func__);\r\nspin_lock_irqsave(&irttp->tsaps->hb_spinlock, flags);\r\nif (!hashbin_find(irttp->tsaps, (long) orig, NULL)) {\r\nIRDA_DEBUG(0, "%s(), unable to find TSAP\n", __func__);\r\nspin_unlock_irqrestore(&irttp->tsaps->hb_spinlock, flags);\r\nreturn NULL;\r\n}\r\nnew = kmemdup(orig, sizeof(struct tsap_cb), GFP_ATOMIC);\r\nif (!new) {\r\nIRDA_DEBUG(0, "%s(), unable to kmalloc\n", __func__);\r\nspin_unlock_irqrestore(&irttp->tsaps->hb_spinlock, flags);\r\nreturn NULL;\r\n}\r\nspin_lock_init(&new->lock);\r\nspin_unlock_irqrestore(&irttp->tsaps->hb_spinlock, flags);\r\nnew->lsap = irlmp_dup(orig->lsap, new);\r\nif (!new->lsap) {\r\nIRDA_DEBUG(0, "%s(), dup failed!\n", __func__);\r\nkfree(new);\r\nreturn NULL;\r\n}\r\nnew->notify.instance = instance;\r\nirttp_init_tsap(new);\r\nhashbin_insert(irttp->tsaps, (irda_queue_t *) new, (long) new, NULL);\r\nreturn new;\r\n}\r\nint irttp_disconnect_request(struct tsap_cb *self, struct sk_buff *userdata,\r\nint priority)\r\n{\r\nint ret;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return -1;);\r\nif (!self->connected) {\r\nIRDA_DEBUG(4, "%s(), already disconnected!\n", __func__);\r\nif (userdata)\r\ndev_kfree_skb(userdata);\r\nreturn -1;\r\n}\r\nif (test_and_set_bit(0, &self->disconnect_pend)) {\r\nIRDA_DEBUG(0, "%s(), disconnect already pending\n",\r\n__func__);\r\nif (userdata)\r\ndev_kfree_skb(userdata);\r\nirttp_run_tx_queue(self);\r\nreturn -1;\r\n}\r\nif (!skb_queue_empty(&self->tx_queue)) {\r\nif (priority == P_HIGH) {\r\nIRDA_DEBUG(1, "%s(): High priority!!()\n", __func__);\r\nirttp_flush_queues(self);\r\n} else if (priority == P_NORMAL) {\r\nself->disconnect_skb = userdata;\r\nirttp_run_tx_queue(self);\r\nirttp_start_todo_timer(self, HZ/10);\r\nreturn -1;\r\n}\r\n}\r\nIRDA_DEBUG(1, "%s(), Disconnecting ...\n", __func__);\r\nself->connected = FALSE;\r\nif (!userdata) {\r\nstruct sk_buff *tx_skb;\r\ntx_skb = alloc_skb(LMP_MAX_HEADER, GFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn -ENOMEM;\r\nskb_reserve(tx_skb, LMP_MAX_HEADER);\r\nuserdata = tx_skb;\r\n}\r\nret = irlmp_disconnect_request(self->lsap, userdata);\r\nclear_bit(0, &self->disconnect_pend);\r\nreturn ret;\r\n}\r\nstatic void irttp_disconnect_indication(void *instance, void *sap,\r\nLM_REASON reason, struct sk_buff *skb)\r\n{\r\nstruct tsap_cb *self;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == TTP_TSAP_MAGIC, return;);\r\nself->connected = FALSE;\r\nif (self->close_pend) {\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nirttp_close_tsap(self);\r\nreturn;\r\n}\r\nif (self->notify.disconnect_indication)\r\nself->notify.disconnect_indication(self->notify.instance, self,\r\nreason, skb);\r\nelse\r\nif (skb)\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void irttp_do_data_indication(struct tsap_cb *self, struct sk_buff *skb)\r\n{\r\nint err;\r\nif (self->close_pend) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nerr = self->notify.data_indication(self->notify.instance, self, skb);\r\nif (err) {\r\nIRDA_DEBUG(0, "%s() requeueing skb!\n", __func__);\r\nself->rx_sdu_busy = TRUE;\r\nskb_push(skb, TTP_HEADER);\r\nskb->data[0] = 0x00;\r\nskb_queue_head(&self->rx_queue, skb);\r\n}\r\n}\r\nstatic void irttp_run_rx_queue(struct tsap_cb *self)\r\n{\r\nstruct sk_buff *skb;\r\nint more = 0;\r\nIRDA_DEBUG(2, "%s() send=%d,avail=%d,remote=%d\n", __func__,\r\nself->send_credit, self->avail_credit, self->remote_credit);\r\nif (irda_lock(&self->rx_queue_lock) == FALSE)\r\nreturn;\r\nwhile (!self->rx_sdu_busy && (skb = skb_dequeue(&self->rx_queue))) {\r\nmore = skb->data[0] & 0x80;\r\nskb_pull(skb, TTP_HEADER);\r\nself->rx_sdu_size += skb->len;\r\nif (self->rx_max_sdu_size == TTP_SAR_DISABLE) {\r\nirttp_do_data_indication(self, skb);\r\nself->rx_sdu_size = 0;\r\ncontinue;\r\n}\r\nif (more) {\r\nif (self->rx_sdu_size <= self->rx_max_sdu_size) {\r\nIRDA_DEBUG(4, "%s(), queueing frag\n",\r\n__func__);\r\nskb_queue_tail(&self->rx_fragments, skb);\r\n} else {\r\ndev_kfree_skb(skb);\r\n}\r\ncontinue;\r\n}\r\nif ((self->rx_sdu_size <= self->rx_max_sdu_size) ||\r\n(self->rx_max_sdu_size == TTP_SAR_UNBOUND)) {\r\nif (!skb_queue_empty(&self->rx_fragments)) {\r\nskb_queue_tail(&self->rx_fragments,\r\nskb);\r\nskb = irttp_reassemble_skb(self);\r\n}\r\nirttp_do_data_indication(self, skb);\r\n} else {\r\nIRDA_DEBUG(1, "%s(), Truncated frame\n", __func__);\r\ndev_kfree_skb(skb);\r\nskb = irttp_reassemble_skb(self);\r\nirttp_do_data_indication(self, skb);\r\n}\r\nself->rx_sdu_size = 0;\r\n}\r\nself->avail_credit = (self->initial_credit -\r\n(self->remote_credit +\r\nskb_queue_len(&self->rx_queue) +\r\nskb_queue_len(&self->rx_fragments)));\r\nif ((self->remote_credit <= TTP_RX_MIN_CREDIT) &&\r\n(self->avail_credit > 0)) {\r\nirttp_give_credit(self);\r\n}\r\nself->rx_queue_lock = 0;\r\n}\r\nstatic void *irttp_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct irttp_iter_state *iter = seq->private;\r\nstruct tsap_cb *self;\r\nspin_lock_irq(&irttp->tsaps->hb_spinlock);\r\niter->id = 0;\r\nfor (self = (struct tsap_cb *) hashbin_get_first(irttp->tsaps);\r\nself != NULL;\r\nself = (struct tsap_cb *) hashbin_get_next(irttp->tsaps)) {\r\nif (iter->id == *pos)\r\nbreak;\r\n++iter->id;\r\n}\r\nreturn self;\r\n}\r\nstatic void *irttp_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct irttp_iter_state *iter = seq->private;\r\n++*pos;\r\n++iter->id;\r\nreturn (void *) hashbin_get_next(irttp->tsaps);\r\n}\r\nstatic void irttp_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nspin_unlock_irq(&irttp->tsaps->hb_spinlock);\r\n}\r\nstatic int irttp_seq_show(struct seq_file *seq, void *v)\r\n{\r\nconst struct irttp_iter_state *iter = seq->private;\r\nconst struct tsap_cb *self = v;\r\nseq_printf(seq, "TSAP %d, ", iter->id);\r\nseq_printf(seq, "stsap_sel: %02x, ",\r\nself->stsap_sel);\r\nseq_printf(seq, "dtsap_sel: %02x\n",\r\nself->dtsap_sel);\r\nseq_printf(seq, " connected: %s, ",\r\nself->connected ? "TRUE" : "FALSE");\r\nseq_printf(seq, "avail credit: %d, ",\r\nself->avail_credit);\r\nseq_printf(seq, "remote credit: %d, ",\r\nself->remote_credit);\r\nseq_printf(seq, "send credit: %d\n",\r\nself->send_credit);\r\nseq_printf(seq, " tx packets: %lu, ",\r\nself->stats.tx_packets);\r\nseq_printf(seq, "rx packets: %lu, ",\r\nself->stats.rx_packets);\r\nseq_printf(seq, "tx_queue len: %u ",\r\nskb_queue_len(&self->tx_queue));\r\nseq_printf(seq, "rx_queue len: %u\n",\r\nskb_queue_len(&self->rx_queue));\r\nseq_printf(seq, " tx_sdu_busy: %s, ",\r\nself->tx_sdu_busy ? "TRUE" : "FALSE");\r\nseq_printf(seq, "rx_sdu_busy: %s\n",\r\nself->rx_sdu_busy ? "TRUE" : "FALSE");\r\nseq_printf(seq, " max_seg_size: %u, ",\r\nself->max_seg_size);\r\nseq_printf(seq, "tx_max_sdu_size: %u, ",\r\nself->tx_max_sdu_size);\r\nseq_printf(seq, "rx_max_sdu_size: %u\n",\r\nself->rx_max_sdu_size);\r\nseq_printf(seq, " Used by (%s)\n\n",\r\nself->notify.name);\r\nreturn 0;\r\n}\r\nstatic int irttp_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_private(file, &irttp_seq_ops,\r\nsizeof(struct irttp_iter_state));\r\n}
