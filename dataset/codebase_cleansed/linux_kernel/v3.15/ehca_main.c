void *ehca_alloc_fw_ctrlblock(gfp_t flags)\r\n{\r\nvoid *ret = kmem_cache_zalloc(ctblk_cache, flags);\r\nif (!ret)\r\nehca_gen_err("Out of memory for ctblk");\r\nreturn ret;\r\n}\r\nvoid ehca_free_fw_ctrlblock(void *ptr)\r\n{\r\nif (ptr)\r\nkmem_cache_free(ctblk_cache, ptr);\r\n}\r\nint ehca2ib_return_code(u64 ehca_rc)\r\n{\r\nswitch (ehca_rc) {\r\ncase H_SUCCESS:\r\nreturn 0;\r\ncase H_RESOURCE:\r\ncase H_BUSY:\r\nreturn -EBUSY;\r\ncase H_NOT_ENOUGH_RESOURCES:\r\ncase H_CONSTRAINED:\r\ncase H_NO_MEM:\r\nreturn -ENOMEM;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ehca_create_slab_caches(void)\r\n{\r\nint ret;\r\nret = ehca_init_pd_cache();\r\nif (ret) {\r\nehca_gen_err("Cannot create PD SLAB cache.");\r\nreturn ret;\r\n}\r\nret = ehca_init_cq_cache();\r\nif (ret) {\r\nehca_gen_err("Cannot create CQ SLAB cache.");\r\ngoto create_slab_caches2;\r\n}\r\nret = ehca_init_qp_cache();\r\nif (ret) {\r\nehca_gen_err("Cannot create QP SLAB cache.");\r\ngoto create_slab_caches3;\r\n}\r\nret = ehca_init_av_cache();\r\nif (ret) {\r\nehca_gen_err("Cannot create AV SLAB cache.");\r\ngoto create_slab_caches4;\r\n}\r\nret = ehca_init_mrmw_cache();\r\nif (ret) {\r\nehca_gen_err("Cannot create MR&MW SLAB cache.");\r\ngoto create_slab_caches5;\r\n}\r\nret = ehca_init_small_qp_cache();\r\nif (ret) {\r\nehca_gen_err("Cannot create small queue SLAB cache.");\r\ngoto create_slab_caches6;\r\n}\r\n#ifdef CONFIG_PPC_64K_PAGES\r\nctblk_cache = kmem_cache_create("ehca_cache_ctblk",\r\nEHCA_PAGESIZE, H_CB_ALIGNMENT,\r\nSLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!ctblk_cache) {\r\nehca_gen_err("Cannot create ctblk SLAB cache.");\r\nehca_cleanup_small_qp_cache();\r\nret = -ENOMEM;\r\ngoto create_slab_caches6;\r\n}\r\n#endif\r\nreturn 0;\r\ncreate_slab_caches6:\r\nehca_cleanup_mrmw_cache();\r\ncreate_slab_caches5:\r\nehca_cleanup_av_cache();\r\ncreate_slab_caches4:\r\nehca_cleanup_qp_cache();\r\ncreate_slab_caches3:\r\nehca_cleanup_cq_cache();\r\ncreate_slab_caches2:\r\nehca_cleanup_pd_cache();\r\nreturn ret;\r\n}\r\nstatic void ehca_destroy_slab_caches(void)\r\n{\r\nehca_cleanup_small_qp_cache();\r\nehca_cleanup_mrmw_cache();\r\nehca_cleanup_av_cache();\r\nehca_cleanup_qp_cache();\r\nehca_cleanup_cq_cache();\r\nehca_cleanup_pd_cache();\r\n#ifdef CONFIG_PPC_64K_PAGES\r\nif (ctblk_cache)\r\nkmem_cache_destroy(ctblk_cache);\r\n#endif\r\n}\r\nstatic int ehca_sense_attributes(struct ehca_shca *shca)\r\n{\r\nint i, ret = 0;\r\nu64 h_ret;\r\nstruct hipz_query_hca *rblock;\r\nstruct hipz_query_port *port;\r\nconst char *loc_code;\r\nstatic const u32 pgsize_map[] = {\r\nHCA_CAP_MR_PGSIZE_4K, 0x1000,\r\nHCA_CAP_MR_PGSIZE_64K, 0x10000,\r\nHCA_CAP_MR_PGSIZE_1M, 0x100000,\r\nHCA_CAP_MR_PGSIZE_16M, 0x1000000,\r\n};\r\nehca_gen_dbg("Probing adapter %s...",\r\nshca->ofdev->dev.of_node->full_name);\r\nloc_code = of_get_property(shca->ofdev->dev.of_node, "ibm,loc-code",\r\nNULL);\r\nif (loc_code)\r\nehca_gen_dbg(" ... location lode=%s", loc_code);\r\nrblock = ehca_alloc_fw_ctrlblock(GFP_KERNEL);\r\nif (!rblock) {\r\nehca_gen_err("Cannot allocate rblock memory.");\r\nreturn -ENOMEM;\r\n}\r\nh_ret = hipz_h_query_hca(shca->ipz_hca_handle, rblock);\r\nif (h_ret != H_SUCCESS) {\r\nehca_gen_err("Cannot query device properties. h_ret=%lli",\r\nh_ret);\r\nret = -EPERM;\r\ngoto sense_attributes1;\r\n}\r\nif (ehca_nr_ports == 1)\r\nshca->num_ports = 1;\r\nelse\r\nshca->num_ports = (u8)rblock->num_ports;\r\nehca_gen_dbg(" ... found %x ports", rblock->num_ports);\r\nif (ehca_hw_level == 0) {\r\nu32 hcaaver;\r\nu32 revid;\r\nhcaaver = EHCA_BMASK_GET(EHCA_HCAAVER, rblock->hw_ver);\r\nrevid = EHCA_BMASK_GET(EHCA_REVID, rblock->hw_ver);\r\nehca_gen_dbg(" ... hardware version=%x:%x", hcaaver, revid);\r\nif (hcaaver == 1) {\r\nif (revid <= 3)\r\nshca->hw_level = 0x10 | (revid + 1);\r\nelse\r\nshca->hw_level = 0x14;\r\n} else if (hcaaver == 2) {\r\nif (revid == 0)\r\nshca->hw_level = 0x21;\r\nelse if (revid == 0x10)\r\nshca->hw_level = 0x22;\r\nelse if (revid == 0x20 || revid == 0x21)\r\nshca->hw_level = 0x23;\r\n}\r\nif (!shca->hw_level) {\r\nehca_gen_warn("unknown hardware version"\r\n" - assuming default level");\r\nshca->hw_level = 0x22;\r\n}\r\n} else\r\nshca->hw_level = ehca_hw_level;\r\nehca_gen_dbg(" ... hardware level=%x", shca->hw_level);\r\nshca->hca_cap = rblock->hca_cap_indicators;\r\nehca_gen_dbg(" ... HCA capabilities:");\r\nfor (i = 0; i < ARRAY_SIZE(hca_cap_descr); i++)\r\nif (EHCA_BMASK_GET(hca_cap_descr[i].mask, shca->hca_cap))\r\nehca_gen_dbg(" %s", hca_cap_descr[i].descr);\r\nif (ehca_lock_hcalls == -1)\r\nehca_lock_hcalls = !EHCA_BMASK_GET(HCA_CAP_H_ALLOC_RES_SYNC,\r\nshca->hca_cap);\r\nshca->hca_cap_mr_pgsize = EHCA_PAGESIZE;\r\nfor (i = 0; i < ARRAY_SIZE(pgsize_map); i += 2)\r\nif (rblock->memory_page_size_supported & pgsize_map[i])\r\nshca->hca_cap_mr_pgsize |= pgsize_map[i + 1];\r\nif (shca->max_num_qps == -1)\r\nshca->max_num_qps = min_t(int, rblock->max_qp,\r\nEHCA_MAX_NUM_QUEUES);\r\nelse if (shca->max_num_qps < 1 || shca->max_num_qps > rblock->max_qp) {\r\nehca_gen_warn("The requested number of QPs is out of range "\r\n"(1 - %i) specified by HW. Value is set to %i",\r\nrblock->max_qp, rblock->max_qp);\r\nshca->max_num_qps = rblock->max_qp;\r\n}\r\nif (shca->max_num_cqs == -1)\r\nshca->max_num_cqs = min_t(int, rblock->max_cq,\r\nEHCA_MAX_NUM_QUEUES);\r\nelse if (shca->max_num_cqs < 1 || shca->max_num_cqs > rblock->max_cq) {\r\nehca_gen_warn("The requested number of CQs is out of range "\r\n"(1 - %i) specified by HW. Value is set to %i",\r\nrblock->max_cq, rblock->max_cq);\r\n}\r\nport = (struct hipz_query_port *)rblock;\r\nh_ret = hipz_h_query_port(shca->ipz_hca_handle, 1, port);\r\nif (h_ret != H_SUCCESS) {\r\nehca_gen_err("Cannot query port properties. h_ret=%lli",\r\nh_ret);\r\nret = -EPERM;\r\ngoto sense_attributes1;\r\n}\r\nshca->max_mtu = port->max_mtu;\r\nsense_attributes1:\r\nehca_free_fw_ctrlblock(rblock);\r\nreturn ret;\r\n}\r\nstatic int init_node_guid(struct ehca_shca *shca)\r\n{\r\nint ret = 0;\r\nstruct hipz_query_hca *rblock;\r\nrblock = ehca_alloc_fw_ctrlblock(GFP_KERNEL);\r\nif (!rblock) {\r\nehca_err(&shca->ib_device, "Can't allocate rblock memory.");\r\nreturn -ENOMEM;\r\n}\r\nif (hipz_h_query_hca(shca->ipz_hca_handle, rblock) != H_SUCCESS) {\r\nehca_err(&shca->ib_device, "Can't query device properties");\r\nret = -EINVAL;\r\ngoto init_node_guid1;\r\n}\r\nmemcpy(&shca->ib_device.node_guid, &rblock->node_guid, sizeof(u64));\r\ninit_node_guid1:\r\nehca_free_fw_ctrlblock(rblock);\r\nreturn ret;\r\n}\r\nstatic int ehca_init_device(struct ehca_shca *shca)\r\n{\r\nint ret;\r\nret = init_node_guid(shca);\r\nif (ret)\r\nreturn ret;\r\nstrlcpy(shca->ib_device.name, "ehca%d", IB_DEVICE_NAME_MAX);\r\nshca->ib_device.owner = THIS_MODULE;\r\nshca->ib_device.uverbs_abi_ver = 8;\r\nshca->ib_device.uverbs_cmd_mask =\r\n(1ull << IB_USER_VERBS_CMD_GET_CONTEXT) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_DEVICE) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_PORT) |\r\n(1ull << IB_USER_VERBS_CMD_ALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_DEALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_REG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_DEREG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_QP) |\r\n(1ull << IB_USER_VERBS_CMD_MODIFY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_ATTACH_MCAST) |\r\n(1ull << IB_USER_VERBS_CMD_DETACH_MCAST);\r\nshca->ib_device.node_type = RDMA_NODE_IB_CA;\r\nshca->ib_device.phys_port_cnt = shca->num_ports;\r\nshca->ib_device.num_comp_vectors = 1;\r\nshca->ib_device.dma_device = &shca->ofdev->dev;\r\nshca->ib_device.query_device = ehca_query_device;\r\nshca->ib_device.query_port = ehca_query_port;\r\nshca->ib_device.query_gid = ehca_query_gid;\r\nshca->ib_device.query_pkey = ehca_query_pkey;\r\nshca->ib_device.modify_port = ehca_modify_port;\r\nshca->ib_device.alloc_ucontext = ehca_alloc_ucontext;\r\nshca->ib_device.dealloc_ucontext = ehca_dealloc_ucontext;\r\nshca->ib_device.alloc_pd = ehca_alloc_pd;\r\nshca->ib_device.dealloc_pd = ehca_dealloc_pd;\r\nshca->ib_device.create_ah = ehca_create_ah;\r\nshca->ib_device.query_ah = ehca_query_ah;\r\nshca->ib_device.destroy_ah = ehca_destroy_ah;\r\nshca->ib_device.create_qp = ehca_create_qp;\r\nshca->ib_device.modify_qp = ehca_modify_qp;\r\nshca->ib_device.query_qp = ehca_query_qp;\r\nshca->ib_device.destroy_qp = ehca_destroy_qp;\r\nshca->ib_device.post_send = ehca_post_send;\r\nshca->ib_device.post_recv = ehca_post_recv;\r\nshca->ib_device.create_cq = ehca_create_cq;\r\nshca->ib_device.destroy_cq = ehca_destroy_cq;\r\nshca->ib_device.resize_cq = ehca_resize_cq;\r\nshca->ib_device.poll_cq = ehca_poll_cq;\r\nshca->ib_device.req_notify_cq = ehca_req_notify_cq;\r\nshca->ib_device.get_dma_mr = ehca_get_dma_mr;\r\nshca->ib_device.reg_phys_mr = ehca_reg_phys_mr;\r\nshca->ib_device.reg_user_mr = ehca_reg_user_mr;\r\nshca->ib_device.query_mr = ehca_query_mr;\r\nshca->ib_device.dereg_mr = ehca_dereg_mr;\r\nshca->ib_device.rereg_phys_mr = ehca_rereg_phys_mr;\r\nshca->ib_device.alloc_mw = ehca_alloc_mw;\r\nshca->ib_device.bind_mw = ehca_bind_mw;\r\nshca->ib_device.dealloc_mw = ehca_dealloc_mw;\r\nshca->ib_device.alloc_fmr = ehca_alloc_fmr;\r\nshca->ib_device.map_phys_fmr = ehca_map_phys_fmr;\r\nshca->ib_device.unmap_fmr = ehca_unmap_fmr;\r\nshca->ib_device.dealloc_fmr = ehca_dealloc_fmr;\r\nshca->ib_device.attach_mcast = ehca_attach_mcast;\r\nshca->ib_device.detach_mcast = ehca_detach_mcast;\r\nshca->ib_device.process_mad = ehca_process_mad;\r\nshca->ib_device.mmap = ehca_mmap;\r\nshca->ib_device.dma_ops = &ehca_dma_mapping_ops;\r\nif (EHCA_BMASK_GET(HCA_CAP_SRQ, shca->hca_cap)) {\r\nshca->ib_device.uverbs_cmd_mask |=\r\n(1ull << IB_USER_VERBS_CMD_CREATE_SRQ) |\r\n(1ull << IB_USER_VERBS_CMD_MODIFY_SRQ) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_SRQ) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_SRQ);\r\nshca->ib_device.create_srq = ehca_create_srq;\r\nshca->ib_device.modify_srq = ehca_modify_srq;\r\nshca->ib_device.query_srq = ehca_query_srq;\r\nshca->ib_device.destroy_srq = ehca_destroy_srq;\r\nshca->ib_device.post_srq_recv = ehca_post_srq_recv;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ehca_create_aqp1(struct ehca_shca *shca, u32 port)\r\n{\r\nstruct ehca_sport *sport = &shca->sport[port - 1];\r\nstruct ib_cq *ibcq;\r\nstruct ib_qp *ibqp;\r\nstruct ib_qp_init_attr qp_init_attr;\r\nint ret;\r\nif (sport->ibcq_aqp1) {\r\nehca_err(&shca->ib_device, "AQP1 CQ is already created.");\r\nreturn -EPERM;\r\n}\r\nibcq = ib_create_cq(&shca->ib_device, NULL, NULL, (void *)(-1), 10, 0);\r\nif (IS_ERR(ibcq)) {\r\nehca_err(&shca->ib_device, "Cannot create AQP1 CQ.");\r\nreturn PTR_ERR(ibcq);\r\n}\r\nsport->ibcq_aqp1 = ibcq;\r\nif (sport->ibqp_sqp[IB_QPT_GSI]) {\r\nehca_err(&shca->ib_device, "AQP1 QP is already created.");\r\nret = -EPERM;\r\ngoto create_aqp1;\r\n}\r\nmemset(&qp_init_attr, 0, sizeof(struct ib_qp_init_attr));\r\nqp_init_attr.send_cq = ibcq;\r\nqp_init_attr.recv_cq = ibcq;\r\nqp_init_attr.sq_sig_type = IB_SIGNAL_ALL_WR;\r\nqp_init_attr.cap.max_send_wr = 100;\r\nqp_init_attr.cap.max_recv_wr = 100;\r\nqp_init_attr.cap.max_send_sge = 2;\r\nqp_init_attr.cap.max_recv_sge = 1;\r\nqp_init_attr.qp_type = IB_QPT_GSI;\r\nqp_init_attr.port_num = port;\r\nqp_init_attr.qp_context = NULL;\r\nqp_init_attr.event_handler = NULL;\r\nqp_init_attr.srq = NULL;\r\nibqp = ib_create_qp(&shca->pd->ib_pd, &qp_init_attr);\r\nif (IS_ERR(ibqp)) {\r\nehca_err(&shca->ib_device, "Cannot create AQP1 QP.");\r\nret = PTR_ERR(ibqp);\r\ngoto create_aqp1;\r\n}\r\nsport->ibqp_sqp[IB_QPT_GSI] = ibqp;\r\nreturn 0;\r\ncreate_aqp1:\r\nib_destroy_cq(sport->ibcq_aqp1);\r\nreturn ret;\r\n}\r\nstatic int ehca_destroy_aqp1(struct ehca_sport *sport)\r\n{\r\nint ret;\r\nret = ib_destroy_qp(sport->ibqp_sqp[IB_QPT_GSI]);\r\nif (ret) {\r\nehca_gen_err("Cannot destroy AQP1 QP. ret=%i", ret);\r\nreturn ret;\r\n}\r\nret = ib_destroy_cq(sport->ibcq_aqp1);\r\nif (ret)\r\nehca_gen_err("Cannot destroy AQP1 CQ. ret=%i", ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t ehca_show_debug_level(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ehca_debug_level);\r\n}\r\nstatic ssize_t ehca_store_debug_level(struct device_driver *ddp,\r\nconst char *buf, size_t count)\r\n{\r\nint value = (*buf) - '0';\r\nif (value >= 0 && value <= 9)\r\nehca_debug_level = value;\r\nreturn 1;\r\n}\r\nstatic ssize_t ehca_show_adapter_handle(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ehca_shca *shca = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%llx\n", shca->ipz_hca_handle.handle);\r\n}\r\nstatic int ehca_probe(struct platform_device *dev)\r\n{\r\nstruct ehca_shca *shca;\r\nconst u64 *handle;\r\nstruct ib_pd *ibpd;\r\nint ret, i, eq_size;\r\nunsigned long flags;\r\nhandle = of_get_property(dev->dev.of_node, "ibm,hca-handle", NULL);\r\nif (!handle) {\r\nehca_gen_err("Cannot get eHCA handle for adapter: %s.",\r\ndev->dev.of_node->full_name);\r\nreturn -ENODEV;\r\n}\r\nif (!(*handle)) {\r\nehca_gen_err("Wrong eHCA handle for adapter: %s.",\r\ndev->dev.of_node->full_name);\r\nreturn -ENODEV;\r\n}\r\nshca = (struct ehca_shca *)ib_alloc_device(sizeof(*shca));\r\nif (!shca) {\r\nehca_gen_err("Cannot allocate shca memory.");\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&shca->modify_mutex);\r\natomic_set(&shca->num_cqs, 0);\r\natomic_set(&shca->num_qps, 0);\r\nshca->max_num_qps = ehca_max_qp;\r\nshca->max_num_cqs = ehca_max_cq;\r\nfor (i = 0; i < ARRAY_SIZE(shca->sport); i++)\r\nspin_lock_init(&shca->sport[i].mod_sqp_lock);\r\nshca->ofdev = dev;\r\nshca->ipz_hca_handle.handle = *handle;\r\ndev_set_drvdata(&dev->dev, shca);\r\nret = ehca_sense_attributes(shca);\r\nif (ret < 0) {\r\nehca_gen_err("Cannot sense eHCA attributes.");\r\ngoto probe1;\r\n}\r\nret = ehca_init_device(shca);\r\nif (ret) {\r\nehca_gen_err("Cannot init ehca device struct");\r\ngoto probe1;\r\n}\r\neq_size = 2 * shca->max_num_cqs + 4 * shca->max_num_qps;\r\nret = ehca_create_eq(shca, &shca->eq, EHCA_EQ, eq_size);\r\nif (ret) {\r\nehca_err(&shca->ib_device, "Cannot create EQ.");\r\ngoto probe1;\r\n}\r\nret = ehca_create_eq(shca, &shca->neq, EHCA_NEQ, 513);\r\nif (ret) {\r\nehca_err(&shca->ib_device, "Cannot create NEQ.");\r\ngoto probe3;\r\n}\r\nibpd = ehca_alloc_pd(&shca->ib_device, (void *)(-1), NULL);\r\nif (IS_ERR(ibpd)) {\r\nehca_err(&shca->ib_device, "Cannot create internal PD.");\r\nret = PTR_ERR(ibpd);\r\ngoto probe4;\r\n}\r\nshca->pd = container_of(ibpd, struct ehca_pd, ib_pd);\r\nshca->pd->ib_pd.device = &shca->ib_device;\r\nret = ehca_reg_internal_maxmr(shca, shca->pd, &shca->maxmr);\r\nif (ret) {\r\nehca_err(&shca->ib_device, "Cannot create internal MR ret=%i",\r\nret);\r\ngoto probe5;\r\n}\r\nret = ib_register_device(&shca->ib_device, NULL);\r\nif (ret) {\r\nehca_err(&shca->ib_device,\r\n"ib_register_device() failed ret=%i", ret);\r\ngoto probe6;\r\n}\r\nif (ehca_open_aqp1 == 1) {\r\nshca->sport[0].port_state = IB_PORT_DOWN;\r\nret = ehca_create_aqp1(shca, 1);\r\nif (ret) {\r\nehca_err(&shca->ib_device,\r\n"Cannot create AQP1 for port 1.");\r\ngoto probe7;\r\n}\r\n}\r\nif ((ehca_open_aqp1 == 1) && (shca->num_ports == 2)) {\r\nshca->sport[1].port_state = IB_PORT_DOWN;\r\nret = ehca_create_aqp1(shca, 2);\r\nif (ret) {\r\nehca_err(&shca->ib_device,\r\n"Cannot create AQP1 for port 2.");\r\ngoto probe8;\r\n}\r\n}\r\nret = sysfs_create_group(&dev->dev.kobj, &ehca_dev_attr_grp);\r\nif (ret)\r\nehca_err(&shca->ib_device,\r\n"Cannot create device attributes ret=%d", ret);\r\nspin_lock_irqsave(&shca_list_lock, flags);\r\nlist_add(&shca->shca_list, &shca_list);\r\nspin_unlock_irqrestore(&shca_list_lock, flags);\r\nreturn 0;\r\nprobe8:\r\nret = ehca_destroy_aqp1(&shca->sport[0]);\r\nif (ret)\r\nehca_err(&shca->ib_device,\r\n"Cannot destroy AQP1 for port 1. ret=%i", ret);\r\nprobe7:\r\nib_unregister_device(&shca->ib_device);\r\nprobe6:\r\nret = ehca_dereg_internal_maxmr(shca);\r\nif (ret)\r\nehca_err(&shca->ib_device,\r\n"Cannot destroy internal MR. ret=%x", ret);\r\nprobe5:\r\nret = ehca_dealloc_pd(&shca->pd->ib_pd);\r\nif (ret)\r\nehca_err(&shca->ib_device,\r\n"Cannot destroy internal PD. ret=%x", ret);\r\nprobe4:\r\nret = ehca_destroy_eq(shca, &shca->neq);\r\nif (ret)\r\nehca_err(&shca->ib_device,\r\n"Cannot destroy NEQ. ret=%x", ret);\r\nprobe3:\r\nret = ehca_destroy_eq(shca, &shca->eq);\r\nif (ret)\r\nehca_err(&shca->ib_device,\r\n"Cannot destroy EQ. ret=%x", ret);\r\nprobe1:\r\nib_dealloc_device(&shca->ib_device);\r\nreturn -EINVAL;\r\n}\r\nstatic int ehca_remove(struct platform_device *dev)\r\n{\r\nstruct ehca_shca *shca = dev_get_drvdata(&dev->dev);\r\nunsigned long flags;\r\nint ret;\r\nsysfs_remove_group(&dev->dev.kobj, &ehca_dev_attr_grp);\r\nif (ehca_open_aqp1 == 1) {\r\nint i;\r\nfor (i = 0; i < shca->num_ports; i++) {\r\nret = ehca_destroy_aqp1(&shca->sport[i]);\r\nif (ret)\r\nehca_err(&shca->ib_device,\r\n"Cannot destroy AQP1 for port %x "\r\n"ret=%i", ret, i);\r\n}\r\n}\r\nib_unregister_device(&shca->ib_device);\r\nret = ehca_dereg_internal_maxmr(shca);\r\nif (ret)\r\nehca_err(&shca->ib_device,\r\n"Cannot destroy internal MR. ret=%i", ret);\r\nret = ehca_dealloc_pd(&shca->pd->ib_pd);\r\nif (ret)\r\nehca_err(&shca->ib_device,\r\n"Cannot destroy internal PD. ret=%i", ret);\r\nret = ehca_destroy_eq(shca, &shca->eq);\r\nif (ret)\r\nehca_err(&shca->ib_device, "Cannot destroy EQ. ret=%i", ret);\r\nret = ehca_destroy_eq(shca, &shca->neq);\r\nif (ret)\r\nehca_err(&shca->ib_device, "Canot destroy NEQ. ret=%i", ret);\r\nib_dealloc_device(&shca->ib_device);\r\nspin_lock_irqsave(&shca_list_lock, flags);\r\nlist_del(&shca->shca_list);\r\nspin_unlock_irqrestore(&shca_list_lock, flags);\r\nreturn ret;\r\n}\r\nvoid ehca_poll_eqs(unsigned long data)\r\n{\r\nstruct ehca_shca *shca;\r\nspin_lock(&shca_list_lock);\r\nlist_for_each_entry(shca, &shca_list, shca_list) {\r\nif (shca->eq.is_initialized) {\r\nstruct ehca_eq *eq = &shca->eq;\r\nint max = 3;\r\nvolatile u64 q_ofs, q_ofs2;\r\nunsigned long flags;\r\nspin_lock_irqsave(&eq->spinlock, flags);\r\nq_ofs = eq->ipz_queue.current_q_offset;\r\nspin_unlock_irqrestore(&eq->spinlock, flags);\r\ndo {\r\nspin_lock_irqsave(&eq->spinlock, flags);\r\nq_ofs2 = eq->ipz_queue.current_q_offset;\r\nspin_unlock_irqrestore(&eq->spinlock, flags);\r\nmax--;\r\n} while (q_ofs == q_ofs2 && max > 0);\r\nif (q_ofs == q_ofs2)\r\nehca_process_eq(shca, 0);\r\n}\r\n}\r\nmod_timer(&poll_eqs_timer, round_jiffies(jiffies + HZ));\r\nspin_unlock(&shca_list_lock);\r\n}\r\nstatic int ehca_mem_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstatic unsigned long ehca_dmem_warn_time;\r\nunsigned long flags;\r\nswitch (action) {\r\ncase MEM_CANCEL_OFFLINE:\r\ncase MEM_CANCEL_ONLINE:\r\ncase MEM_ONLINE:\r\ncase MEM_OFFLINE:\r\nreturn NOTIFY_OK;\r\ncase MEM_GOING_ONLINE:\r\ncase MEM_GOING_OFFLINE:\r\nspin_lock_irqsave(&shca_list_lock, flags);\r\nif (list_empty(&shca_list)) {\r\nspin_unlock_irqrestore(&shca_list_lock, flags);\r\nreturn NOTIFY_OK;\r\n} else {\r\nspin_unlock_irqrestore(&shca_list_lock, flags);\r\nif (printk_timed_ratelimit(&ehca_dmem_warn_time,\r\n30 * 1000))\r\nehca_gen_err("DMEM operations are not allowed"\r\n"in conjunction with eHCA");\r\nreturn NOTIFY_BAD;\r\n}\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init ehca_module_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "eHCA Infiniband Device Driver "\r\n"(Version " HCAD_VERSION ")\n");\r\nret = ehca_create_comp_pool();\r\nif (ret) {\r\nehca_gen_err("Cannot create comp pool.");\r\nreturn ret;\r\n}\r\nret = ehca_create_slab_caches();\r\nif (ret) {\r\nehca_gen_err("Cannot create SLAB caches");\r\nret = -ENOMEM;\r\ngoto module_init1;\r\n}\r\nret = ehca_create_busmap();\r\nif (ret) {\r\nehca_gen_err("Cannot create busmap.");\r\ngoto module_init2;\r\n}\r\nret = ibmebus_register_driver(&ehca_driver);\r\nif (ret) {\r\nehca_gen_err("Cannot register eHCA device driver");\r\nret = -EINVAL;\r\ngoto module_init3;\r\n}\r\nret = register_memory_notifier(&ehca_mem_nb);\r\nif (ret) {\r\nehca_gen_err("Failed registering memory add/remove notifier");\r\ngoto module_init4;\r\n}\r\nif (ehca_poll_all_eqs != 1) {\r\nehca_gen_err("WARNING!!!");\r\nehca_gen_err("It is possible to lose interrupts.");\r\n} else {\r\ninit_timer(&poll_eqs_timer);\r\npoll_eqs_timer.function = ehca_poll_eqs;\r\npoll_eqs_timer.expires = jiffies + HZ;\r\nadd_timer(&poll_eqs_timer);\r\n}\r\nreturn 0;\r\nmodule_init4:\r\nibmebus_unregister_driver(&ehca_driver);\r\nmodule_init3:\r\nehca_destroy_busmap();\r\nmodule_init2:\r\nehca_destroy_slab_caches();\r\nmodule_init1:\r\nehca_destroy_comp_pool();\r\nreturn ret;\r\n}\r\nstatic void __exit ehca_module_exit(void)\r\n{\r\nif (ehca_poll_all_eqs == 1)\r\ndel_timer_sync(&poll_eqs_timer);\r\nibmebus_unregister_driver(&ehca_driver);\r\nunregister_memory_notifier(&ehca_mem_nb);\r\nehca_destroy_busmap();\r\nehca_destroy_slab_caches();\r\nehca_destroy_comp_pool();\r\nidr_destroy(&ehca_cq_idr);\r\nidr_destroy(&ehca_qp_idr);\r\n}
