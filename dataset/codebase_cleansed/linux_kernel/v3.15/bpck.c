static int bpck_read_regr( PIA *pi, int cont, int regr )\r\n{ int r, l, h;\r\nr = regr + cont_map[cont];\r\nswitch (pi->mode) {\r\ncase 0: w0(r & 0xf); w0(r); t2(2); t2(4);\r\nl = r1();\r\nt2(4);\r\nh = r1();\r\nreturn j44(l,h);\r\ncase 1: w0(r & 0xf); w0(r); t2(2);\r\ne2(); t2(0x20);\r\nt2(4); h = r0();\r\nt2(1); t2(0x20);\r\nreturn h;\r\ncase 2:\r\ncase 3:\r\ncase 4: w0(r); w2(9); w2(0); w2(0x20);\r\nh = r4();\r\nw2(0);\r\nreturn h;\r\n}\r\nreturn -1;\r\n}\r\nstatic void bpck_write_regr( PIA *pi, int cont, int regr, int val )\r\n{ int r;\r\nr = regr + cont_map[cont];\r\nswitch (pi->mode) {\r\ncase 0:\r\ncase 1: w0(r);\r\nt2(2);\r\nw0(val);\r\no2(); t2(4); t2(1);\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ncase 4: w0(r); w2(9); w2(0);\r\nw0(val); w2(1); w2(3); w2(0);\r\nbreak;\r\n}\r\n}\r\nstatic void bpck_write_block( PIA *pi, char * buf, int count )\r\n{ int i;\r\nswitch (pi->mode) {\r\ncase 0: WR(4,0x40);\r\nw0(0x40); t2(2); t2(1);\r\nfor (i=0;i<count;i++) { w0(buf[i]); t2(4); }\r\nWR(4,0);\r\nbreak;\r\ncase 1: WR(4,0x50);\r\nw0(0x40); t2(2); t2(1);\r\nfor (i=0;i<count;i++) { w0(buf[i]); t2(4); }\r\nWR(4,0x10);\r\nbreak;\r\ncase 2: WR(4,0x48);\r\nw0(0x40); w2(9); w2(0); w2(1);\r\nfor (i=0;i<count;i++) w4(buf[i]);\r\nw2(0);\r\nWR(4,8);\r\nbreak;\r\ncase 3: WR(4,0x48);\r\nw0(0x40); w2(9); w2(0); w2(1);\r\nfor (i=0;i<count/2;i++) w4w(((u16 *)buf)[i]);\r\nw2(0);\r\nWR(4,8);\r\nbreak;\r\ncase 4: WR(4,0x48);\r\nw0(0x40); w2(9); w2(0); w2(1);\r\nfor (i=0;i<count/4;i++) w4l(((u32 *)buf)[i]);\r\nw2(0);\r\nWR(4,8);\r\nbreak;\r\n}\r\n}\r\nstatic void bpck_read_block( PIA *pi, char * buf, int count )\r\n{ int i, l, h;\r\nswitch (pi->mode) {\r\ncase 0: WR(4,0x40);\r\nw0(0x40); t2(2);\r\nfor (i=0;i<count;i++) {\r\nt2(4); l = r1();\r\nt2(4); h = r1();\r\nbuf[i] = j44(l,h);\r\n}\r\nWR(4,0);\r\nbreak;\r\ncase 1: WR(4,0x50);\r\nw0(0x40); t2(2); t2(0x20);\r\nfor(i=0;i<count;i++) { t2(4); buf[i] = r0(); }\r\nt2(1); t2(0x20);\r\nWR(4,0x10);\r\nbreak;\r\ncase 2: WR(4,0x48);\r\nw0(0x40); w2(9); w2(0); w2(0x20);\r\nfor (i=0;i<count;i++) buf[i] = r4();\r\nw2(0);\r\nWR(4,8);\r\nbreak;\r\ncase 3: WR(4,0x48);\r\nw0(0x40); w2(9); w2(0); w2(0x20);\r\nfor (i=0;i<count/2;i++) ((u16 *)buf)[i] = r4w();\r\nw2(0);\r\nWR(4,8);\r\nbreak;\r\ncase 4: WR(4,0x48);\r\nw0(0x40); w2(9); w2(0); w2(0x20);\r\nfor (i=0;i<count/4;i++) ((u32 *)buf)[i] = r4l();\r\nw2(0);\r\nWR(4,8);\r\nbreak;\r\n}\r\n}\r\nstatic int bpck_probe_unit ( PIA *pi )\r\n{ int o1, o0, f7, id;\r\nint t, s;\r\nid = pi->unit;\r\ns = 0;\r\nw2(4); w2(0xe); r2(); t2(2);\r\no1 = r1()&0xf8;\r\no0 = r0();\r\nw0(255-id); w2(4); w0(id);\r\nt2(8); t2(8); t2(8);\r\nt2(2); t = r1()&0xf8;\r\nf7 = ((id % 8) == 7);\r\nif ((f7) || (t != o1)) { t2(2); s = r1()&0xf8; }\r\nif ((t == o1) && ((!f7) || (s == o1))) {\r\nw2(0x4c); w0(o0);\r\nreturn 0;\r\n}\r\nt2(8); w0(0); t2(2); w2(0x4c); w0(o0);\r\nreturn 1;\r\n}\r\nstatic void bpck_connect ( PIA *pi )\r\n{ pi->saved_r0 = r0();\r\nw0(0xff-pi->unit); w2(4); w0(pi->unit);\r\nt2(8); t2(8); t2(8);\r\nt2(2); t2(2);\r\nswitch (pi->mode) {\r\ncase 0: t2(8); WR(4,0);\r\nbreak;\r\ncase 1: t2(8); WR(4,0x10);\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ncase 4: w2(0); WR(4,8);\r\nbreak;\r\n}\r\nWR(5,8);\r\nif (pi->devtype == PI_PCD) {\r\nWR(0x46,0x10);\r\nWR(0x4c,0x38);\r\nWR(0x4d,0x88);\r\nWR(0x46,0xa0);\r\nWR(0x41,0);\r\nWR(0x4e,8);\r\n}\r\n}\r\nstatic void bpck_disconnect ( PIA *pi )\r\n{ w0(0);\r\nif (pi->mode >= 2) { w2(9); w2(0); } else t2(2);\r\nw2(0x4c); w0(pi->saved_r0);\r\n}\r\nstatic void bpck_force_spp ( PIA *pi )\r\n{ pi->saved_r0 = r0();\r\nw0(0xff-pi->unit); w2(4); w0(pi->unit);\r\nt2(8); t2(8); t2(8);\r\nt2(2); t2(2);\r\nw2(0);\r\nw0(4); w2(9); w2(0);\r\nw0(0); w2(1); w2(3); w2(0);\r\nw0(0); w2(9); w2(0);\r\nw2(0x4c); w0(pi->saved_r0);\r\n}\r\nstatic int bpck_test_proto( PIA *pi, char * scratch, int verbose )\r\n{ int i, e, l, h, om;\r\nchar buf[TEST_LEN];\r\nbpck_force_spp(pi);\r\nswitch (pi->mode) {\r\ncase 0: bpck_connect(pi);\r\nWR(0x13,0x7f);\r\nw0(0x13); t2(2);\r\nfor(i=0;i<TEST_LEN;i++) {\r\nt2(4); l = r1();\r\nt2(4); h = r1();\r\nbuf[i] = j44(l,h);\r\n}\r\nbpck_disconnect(pi);\r\nbreak;\r\ncase 1: bpck_connect(pi);\r\nWR(0x13,0x7f);\r\nw0(0x13); t2(2); t2(0x20);\r\nfor(i=0;i<TEST_LEN;i++) { t2(4); buf[i] = r0(); }\r\nt2(1); t2(0x20);\r\nbpck_disconnect(pi);\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ncase 4: om = pi->mode;\r\npi->mode = 0;\r\nbpck_connect(pi);\r\nWR(7,3);\r\nWR(4,8);\r\nbpck_disconnect(pi);\r\npi->mode = om;\r\nbpck_connect(pi);\r\nw0(0x13); w2(9); w2(1); w0(0); w2(3); w2(0); w2(0xe0);\r\nswitch (pi->mode) {\r\ncase 2: for (i=0;i<TEST_LEN;i++) buf[i] = r4();\r\nbreak;\r\ncase 3: for (i=0;i<TEST_LEN/2;i++) ((u16 *)buf)[i] = r4w();\r\nbreak;\r\ncase 4: for (i=0;i<TEST_LEN/4;i++) ((u32 *)buf)[i] = r4l();\r\nbreak;\r\n}\r\nw2(0);\r\nWR(7,0);\r\nbpck_disconnect(pi);\r\nbreak;\r\n}\r\nif (verbose) {\r\nprintk("%s: bpck: 0x%x unit %d mode %d: ",\r\npi->device,pi->port,pi->unit,pi->mode);\r\nfor (i=0;i<TEST_LEN;i++) printk("%3d",buf[i]);\r\nprintk("\n");\r\n}\r\ne = 0;\r\nfor (i=0;i<TEST_LEN;i++) if (buf[i] != (i+1)) e++;\r\nreturn e;\r\n}\r\nstatic void bpck_read_eeprom ( PIA *pi, char * buf )\r\n{ int i,j,k,n,p,v,f, om, od;\r\nbpck_force_spp(pi);\r\nom = pi->mode; od = pi->delay;\r\npi->mode = 0; pi->delay = 6;\r\nbpck_connect(pi);\r\nn = 0;\r\nWR(4,0);\r\nfor (i=0;i<64;i++) {\r\nWR(6,8);\r\nWR(6,0xc);\r\np = 0x100;\r\nfor (k=0;k<9;k++) {\r\nf = (((i + 0x180) & p) != 0) * 2;\r\nWR(6,f+0xc);\r\nWR(6,f+0xd);\r\nWR(6,f+0xc);\r\np = (p >> 1);\r\n}\r\nfor (j=0;j<2;j++) {\r\nv = 0;\r\nfor (k=0;k<8;k++) {\r\nWR(6,0xc);\r\nWR(6,0xd);\r\nWR(6,0xc);\r\nf = RR(0);\r\nv = 2*v + (f == 0x84);\r\n}\r\nbuf[2*i+1-j] = v;\r\n}\r\n}\r\nWR(6,8);\r\nWR(6,0);\r\nWR(5,8);\r\nbpck_disconnect(pi);\r\nif (om >= 2) {\r\nbpck_connect(pi);\r\nWR(7,3);\r\nWR(4,8);\r\nbpck_disconnect(pi);\r\n}\r\npi->mode = om; pi->delay = od;\r\n}\r\nstatic int bpck_test_port ( PIA *pi )\r\n{ int i, r, m;\r\nw2(0x2c); i = r0(); w0(255-i); r = r0(); w0(i);\r\nm = -1;\r\nif (r == i) m = 2;\r\nif (r == (255-i)) m = 0;\r\nw2(0xc); i = r0(); w0(255-i); r = r0(); w0(i);\r\nif (r != (255-i)) m = -1;\r\nif (m == 0) { w2(6); w2(0xc); r = r0(); w0(0xaa); w0(r); w0(0xaa); }\r\nif (m == 2) { w2(0x26); w2(0xc); }\r\nif (m == -1) return 0;\r\nreturn 5;\r\n}\r\nstatic void bpck_log_adapter( PIA *pi, char * scratch, int verbose )\r\n{ char *mode_string[5] = { "4-bit","8-bit","EPP-8",\r\n"EPP-16","EPP-32" };\r\n#ifdef DUMP_EEPROM\r\nint i;\r\n#endif\r\nbpck_read_eeprom(pi,scratch);\r\n#ifdef DUMP_EEPROM\r\nif (verbose) {\r\nfor(i=0;i<128;i++)\r\nif ((scratch[i] < ' ') || (scratch[i] > '~'))\r\nscratch[i] = '.';\r\nprintk("%s: bpck EEPROM: %64.64s\n",pi->device,scratch);\r\nprintk("%s: %64.64s\n",pi->device,&scratch[64]);\r\n}\r\n#endif\r\nprintk("%s: bpck %s, backpack %8.8s unit %d",\r\npi->device,BPCK_VERSION,&scratch[110],pi->unit);\r\nprintk(" at 0x%x, mode %d (%s), delay %d\n",pi->port,\r\npi->mode,mode_string[pi->mode],pi->delay);\r\n}\r\nstatic int __init bpck_init(void)\r\n{\r\nreturn paride_register(&bpck);\r\n}\r\nstatic void __exit bpck_exit(void)\r\n{\r\nparide_unregister(&bpck);\r\n}
