void x25_clear_queues(struct sock *sk)\r\n{\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nskb_queue_purge(&sk->sk_write_queue);\r\nskb_queue_purge(&x25->ack_queue);\r\nskb_queue_purge(&x25->interrupt_in_queue);\r\nskb_queue_purge(&x25->interrupt_out_queue);\r\nskb_queue_purge(&x25->fragment_queue);\r\n}\r\nvoid x25_frames_acked(struct sock *sk, unsigned short nr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nint modulus = x25->neighbour->extended ? X25_EMODULUS : X25_SMODULUS;\r\nif (x25->va != nr)\r\nwhile (skb_peek(&x25->ack_queue) && x25->va != nr) {\r\nskb = skb_dequeue(&x25->ack_queue);\r\nkfree_skb(skb);\r\nx25->va = (x25->va + 1) % modulus;\r\n}\r\n}\r\nvoid x25_requeue_frames(struct sock *sk)\r\n{\r\nstruct sk_buff *skb, *skb_prev = NULL;\r\nwhile ((skb = skb_dequeue(&x25_sk(sk)->ack_queue)) != NULL) {\r\nif (!skb_prev)\r\nskb_queue_head(&sk->sk_write_queue, skb);\r\nelse\r\nskb_append(skb_prev, skb, &sk->sk_write_queue);\r\nskb_prev = skb;\r\n}\r\n}\r\nint x25_validate_nr(struct sock *sk, unsigned short nr)\r\n{\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nunsigned short vc = x25->va;\r\nint modulus = x25->neighbour->extended ? X25_EMODULUS : X25_SMODULUS;\r\nwhile (vc != x25->vs) {\r\nif (nr == vc)\r\nreturn 1;\r\nvc = (vc + 1) % modulus;\r\n}\r\nreturn nr == x25->vs ? 1 : 0;\r\n}\r\nvoid x25_write_internal(struct sock *sk, int frametype)\r\n{\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nstruct sk_buff *skb;\r\nunsigned char *dptr;\r\nunsigned char facilities[X25_MAX_FAC_LEN];\r\nunsigned char addresses[1 + X25_ADDR_LEN];\r\nunsigned char lci1, lci2;\r\nint len = X25_MAX_L2_LEN + X25_EXT_MIN_LEN;\r\nswitch (frametype) {\r\ncase X25_CALL_REQUEST:\r\nlen += 1 + X25_ADDR_LEN + X25_MAX_FAC_LEN + X25_MAX_CUD_LEN;\r\nbreak;\r\ncase X25_CALL_ACCEPTED:\r\nif (x25->facilities.reverse & 0x80) {\r\nlen += 1 + X25_MAX_FAC_LEN + X25_MAX_CUD_LEN;\r\n} else {\r\nlen += 1 + X25_MAX_FAC_LEN;\r\n}\r\nbreak;\r\ncase X25_CLEAR_REQUEST:\r\ncase X25_RESET_REQUEST:\r\nlen += 2;\r\nbreak;\r\ncase X25_RR:\r\ncase X25_RNR:\r\ncase X25_REJ:\r\ncase X25_CLEAR_CONFIRMATION:\r\ncase X25_INTERRUPT_CONFIRMATION:\r\ncase X25_RESET_CONFIRMATION:\r\nbreak;\r\ndefault:\r\npr_err("invalid frame type %02X\n", frametype);\r\nreturn;\r\n}\r\nif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb_reserve(skb, X25_MAX_L2_LEN);\r\ndptr = skb_put(skb, 2);\r\nlci1 = (x25->lci >> 8) & 0x0F;\r\nlci2 = (x25->lci >> 0) & 0xFF;\r\nif (x25->neighbour->extended) {\r\n*dptr++ = lci1 | X25_GFI_EXTSEQ;\r\n*dptr++ = lci2;\r\n} else {\r\n*dptr++ = lci1 | X25_GFI_STDSEQ;\r\n*dptr++ = lci2;\r\n}\r\nswitch (frametype) {\r\ncase X25_CALL_REQUEST:\r\ndptr = skb_put(skb, 1);\r\n*dptr++ = X25_CALL_REQUEST;\r\nlen = x25_addr_aton(addresses, &x25->dest_addr,\r\n&x25->source_addr);\r\ndptr = skb_put(skb, len);\r\nmemcpy(dptr, addresses, len);\r\nlen = x25_create_facilities(facilities,\r\n&x25->facilities,\r\n&x25->dte_facilities,\r\nx25->neighbour->global_facil_mask);\r\ndptr = skb_put(skb, len);\r\nmemcpy(dptr, facilities, len);\r\ndptr = skb_put(skb, x25->calluserdata.cudlength);\r\nmemcpy(dptr, x25->calluserdata.cuddata,\r\nx25->calluserdata.cudlength);\r\nx25->calluserdata.cudlength = 0;\r\nbreak;\r\ncase X25_CALL_ACCEPTED:\r\ndptr = skb_put(skb, 2);\r\n*dptr++ = X25_CALL_ACCEPTED;\r\n*dptr++ = 0x00;\r\nlen = x25_create_facilities(facilities,\r\n&x25->facilities,\r\n&x25->dte_facilities,\r\nx25->vc_facil_mask);\r\ndptr = skb_put(skb, len);\r\nmemcpy(dptr, facilities, len);\r\nif(x25->facilities.reverse & 0x80) {\r\ndptr = skb_put(skb,\r\nx25->calluserdata.cudlength);\r\nmemcpy(dptr, x25->calluserdata.cuddata,\r\nx25->calluserdata.cudlength);\r\n}\r\nx25->calluserdata.cudlength = 0;\r\nbreak;\r\ncase X25_CLEAR_REQUEST:\r\ndptr = skb_put(skb, 3);\r\n*dptr++ = frametype;\r\n*dptr++ = x25->causediag.cause;\r\n*dptr++ = x25->causediag.diagnostic;\r\nbreak;\r\ncase X25_RESET_REQUEST:\r\ndptr = skb_put(skb, 3);\r\n*dptr++ = frametype;\r\n*dptr++ = 0x00;\r\n*dptr++ = 0x00;\r\nbreak;\r\ncase X25_RR:\r\ncase X25_RNR:\r\ncase X25_REJ:\r\nif (x25->neighbour->extended) {\r\ndptr = skb_put(skb, 2);\r\n*dptr++ = frametype;\r\n*dptr++ = (x25->vr << 1) & 0xFE;\r\n} else {\r\ndptr = skb_put(skb, 1);\r\n*dptr = frametype;\r\n*dptr++ |= (x25->vr << 5) & 0xE0;\r\n}\r\nbreak;\r\ncase X25_CLEAR_CONFIRMATION:\r\ncase X25_INTERRUPT_CONFIRMATION:\r\ncase X25_RESET_CONFIRMATION:\r\ndptr = skb_put(skb, 1);\r\n*dptr = frametype;\r\nbreak;\r\n}\r\nx25_transmit_link(skb, x25->neighbour);\r\n}\r\nint x25_decode(struct sock *sk, struct sk_buff *skb, int *ns, int *nr, int *q,\r\nint *d, int *m)\r\n{\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nunsigned char *frame;\r\nif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\r\nreturn X25_ILLEGAL;\r\nframe = skb->data;\r\n*ns = *nr = *q = *d = *m = 0;\r\nswitch (frame[2]) {\r\ncase X25_CALL_REQUEST:\r\ncase X25_CALL_ACCEPTED:\r\ncase X25_CLEAR_REQUEST:\r\ncase X25_CLEAR_CONFIRMATION:\r\ncase X25_INTERRUPT:\r\ncase X25_INTERRUPT_CONFIRMATION:\r\ncase X25_RESET_REQUEST:\r\ncase X25_RESET_CONFIRMATION:\r\ncase X25_RESTART_REQUEST:\r\ncase X25_RESTART_CONFIRMATION:\r\ncase X25_REGISTRATION_REQUEST:\r\ncase X25_REGISTRATION_CONFIRMATION:\r\ncase X25_DIAGNOSTIC:\r\nreturn frame[2];\r\n}\r\nif (x25->neighbour->extended) {\r\nif (frame[2] == X25_RR ||\r\nframe[2] == X25_RNR ||\r\nframe[2] == X25_REJ) {\r\nif (!pskb_may_pull(skb, X25_EXT_MIN_LEN))\r\nreturn X25_ILLEGAL;\r\nframe = skb->data;\r\n*nr = (frame[3] >> 1) & 0x7F;\r\nreturn frame[2];\r\n}\r\n} else {\r\nif ((frame[2] & 0x1F) == X25_RR ||\r\n(frame[2] & 0x1F) == X25_RNR ||\r\n(frame[2] & 0x1F) == X25_REJ) {\r\n*nr = (frame[2] >> 5) & 0x07;\r\nreturn frame[2] & 0x1F;\r\n}\r\n}\r\nif (x25->neighbour->extended) {\r\nif ((frame[2] & 0x01) == X25_DATA) {\r\nif (!pskb_may_pull(skb, X25_EXT_MIN_LEN))\r\nreturn X25_ILLEGAL;\r\nframe = skb->data;\r\n*q = (frame[0] & X25_Q_BIT) == X25_Q_BIT;\r\n*d = (frame[0] & X25_D_BIT) == X25_D_BIT;\r\n*m = (frame[3] & X25_EXT_M_BIT) == X25_EXT_M_BIT;\r\n*nr = (frame[3] >> 1) & 0x7F;\r\n*ns = (frame[2] >> 1) & 0x7F;\r\nreturn X25_DATA;\r\n}\r\n} else {\r\nif ((frame[2] & 0x01) == X25_DATA) {\r\n*q = (frame[0] & X25_Q_BIT) == X25_Q_BIT;\r\n*d = (frame[0] & X25_D_BIT) == X25_D_BIT;\r\n*m = (frame[2] & X25_STD_M_BIT) == X25_STD_M_BIT;\r\n*nr = (frame[2] >> 5) & 0x07;\r\n*ns = (frame[2] >> 1) & 0x07;\r\nreturn X25_DATA;\r\n}\r\n}\r\npr_debug("invalid PLP frame %02X %02X %02X\n",\r\nframe[0], frame[1], frame[2]);\r\nreturn X25_ILLEGAL;\r\n}\r\nvoid x25_disconnect(struct sock *sk, int reason, unsigned char cause,\r\nunsigned char diagnostic)\r\n{\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nx25_clear_queues(sk);\r\nx25_stop_timer(sk);\r\nx25->lci = 0;\r\nx25->state = X25_STATE_0;\r\nx25->causediag.cause = cause;\r\nx25->causediag.diagnostic = diagnostic;\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_err = reason;\r\nsk->sk_shutdown |= SEND_SHUTDOWN;\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\nsk->sk_state_change(sk);\r\nsock_set_flag(sk, SOCK_DEAD);\r\n}\r\n}\r\nvoid x25_check_rbuf(struct sock *sk)\r\n{\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nif (atomic_read(&sk->sk_rmem_alloc) < (sk->sk_rcvbuf >> 1) &&\r\n(x25->condition & X25_COND_OWN_RX_BUSY)) {\r\nx25->condition &= ~X25_COND_OWN_RX_BUSY;\r\nx25->condition &= ~X25_COND_ACK_PENDING;\r\nx25->vl = x25->vr;\r\nx25_write_internal(sk, X25_RR);\r\nx25_stop_timer(sk);\r\n}\r\n}
