int drm_irq_by_busid(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_irq_busid *p = data;\r\nif (!dev->driver->bus->irq_by_busid)\r\nreturn -EINVAL;\r\nif (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\r\nreturn -EINVAL;\r\nreturn dev->driver->bus->irq_by_busid(dev, p);\r\n}\r\nstatic void clear_vblank_timestamps(struct drm_device *dev, int crtc)\r\n{\r\nmemset(dev->vblank[crtc].time, 0, sizeof(dev->vblank[crtc].time));\r\n}\r\nstatic void vblank_disable_and_save(struct drm_device *dev, int crtc)\r\n{\r\nunsigned long irqflags;\r\nu32 vblcount;\r\ns64 diff_ns;\r\nint vblrc;\r\nstruct timeval tvblank;\r\nint count = DRM_TIMESTAMP_MAXRETRIES;\r\nspin_lock_irqsave(&dev->vblank_time_lock, irqflags);\r\ndev->driver->disable_vblank(dev, crtc);\r\ndev->vblank[crtc].enabled = false;\r\ndo {\r\ndev->vblank[crtc].last = dev->driver->get_vblank_counter(dev, crtc);\r\nvblrc = drm_get_last_vbltimestamp(dev, crtc, &tvblank, 0);\r\n} while (dev->vblank[crtc].last != dev->driver->get_vblank_counter(dev, crtc) && (--count) && vblrc);\r\nif (!count)\r\nvblrc = 0;\r\nvblcount = atomic_read(&dev->vblank[crtc].count);\r\ndiff_ns = timeval_to_ns(&tvblank) -\r\ntimeval_to_ns(&vblanktimestamp(dev, crtc, vblcount));\r\nif ((vblrc > 0) && (abs64(diff_ns) > 1000000)) {\r\natomic_inc(&dev->vblank[crtc].count);\r\nsmp_mb__after_atomic_inc();\r\n}\r\nclear_vblank_timestamps(dev, crtc);\r\nspin_unlock_irqrestore(&dev->vblank_time_lock, irqflags);\r\n}\r\nstatic void vblank_disable_fn(unsigned long arg)\r\n{\r\nstruct drm_device *dev = (struct drm_device *)arg;\r\nunsigned long irqflags;\r\nint i;\r\nif (!dev->vblank_disable_allowed)\r\nreturn;\r\nfor (i = 0; i < dev->num_crtcs; i++) {\r\nspin_lock_irqsave(&dev->vbl_lock, irqflags);\r\nif (atomic_read(&dev->vblank[i].refcount) == 0 &&\r\ndev->vblank[i].enabled) {\r\nDRM_DEBUG("disabling vblank on crtc %d\n", i);\r\nvblank_disable_and_save(dev, i);\r\n}\r\nspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\r\n}\r\n}\r\nvoid drm_vblank_cleanup(struct drm_device *dev)\r\n{\r\nif (dev->num_crtcs == 0)\r\nreturn;\r\ndel_timer_sync(&dev->vblank_disable_timer);\r\nvblank_disable_fn((unsigned long)dev);\r\nkfree(dev->vblank);\r\ndev->num_crtcs = 0;\r\n}\r\nint drm_vblank_init(struct drm_device *dev, int num_crtcs)\r\n{\r\nint i, ret = -ENOMEM;\r\nsetup_timer(&dev->vblank_disable_timer, vblank_disable_fn,\r\n(unsigned long)dev);\r\nspin_lock_init(&dev->vbl_lock);\r\nspin_lock_init(&dev->vblank_time_lock);\r\ndev->num_crtcs = num_crtcs;\r\ndev->vblank = kcalloc(num_crtcs, sizeof(*dev->vblank), GFP_KERNEL);\r\nif (!dev->vblank)\r\ngoto err;\r\nfor (i = 0; i < num_crtcs; i++)\r\ninit_waitqueue_head(&dev->vblank[i].queue);\r\nDRM_INFO("Supports vblank timestamp caching Rev 2 (21.10.2013).\n");\r\nif (dev->driver->get_vblank_timestamp)\r\nDRM_INFO("Driver supports precise vblank timestamp query.\n");\r\nelse\r\nDRM_INFO("No driver support for vblank timestamp query.\n");\r\ndev->vblank_disable_allowed = false;\r\nreturn 0;\r\nerr:\r\ndrm_vblank_cleanup(dev);\r\nreturn ret;\r\n}\r\nstatic void drm_irq_vgaarb_nokms(void *cookie, bool state)\r\n{\r\nstruct drm_device *dev = cookie;\r\nif (dev->driver->vgaarb_irq) {\r\ndev->driver->vgaarb_irq(dev, state);\r\nreturn;\r\n}\r\nif (!dev->irq_enabled)\r\nreturn;\r\nif (state) {\r\nif (dev->driver->irq_uninstall)\r\ndev->driver->irq_uninstall(dev);\r\n} else {\r\nif (dev->driver->irq_preinstall)\r\ndev->driver->irq_preinstall(dev);\r\nif (dev->driver->irq_postinstall)\r\ndev->driver->irq_postinstall(dev);\r\n}\r\n}\r\nint drm_irq_install(struct drm_device *dev)\r\n{\r\nint ret;\r\nunsigned long sh_flags = 0;\r\nchar *irqname;\r\nif (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\r\nreturn -EINVAL;\r\nif (drm_dev_to_irq(dev) == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->struct_mutex);\r\nif (!dev->dev_private) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\nif (dev->irq_enabled) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EBUSY;\r\n}\r\ndev->irq_enabled = true;\r\nmutex_unlock(&dev->struct_mutex);\r\nDRM_DEBUG("irq=%d\n", drm_dev_to_irq(dev));\r\nif (dev->driver->irq_preinstall)\r\ndev->driver->irq_preinstall(dev);\r\nif (drm_core_check_feature(dev, DRIVER_IRQ_SHARED))\r\nsh_flags = IRQF_SHARED;\r\nif (dev->devname)\r\nirqname = dev->devname;\r\nelse\r\nirqname = dev->driver->name;\r\nret = request_irq(drm_dev_to_irq(dev), dev->driver->irq_handler,\r\nsh_flags, irqname, dev);\r\nif (ret < 0) {\r\nmutex_lock(&dev->struct_mutex);\r\ndev->irq_enabled = false;\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\nif (!drm_core_check_feature(dev, DRIVER_MODESET))\r\nvga_client_register(dev->pdev, (void *)dev, drm_irq_vgaarb_nokms, NULL);\r\nif (dev->driver->irq_postinstall)\r\nret = dev->driver->irq_postinstall(dev);\r\nif (ret < 0) {\r\nmutex_lock(&dev->struct_mutex);\r\ndev->irq_enabled = false;\r\nmutex_unlock(&dev->struct_mutex);\r\nif (!drm_core_check_feature(dev, DRIVER_MODESET))\r\nvga_client_register(dev->pdev, NULL, NULL, NULL);\r\nfree_irq(drm_dev_to_irq(dev), dev);\r\n}\r\nreturn ret;\r\n}\r\nint drm_irq_uninstall(struct drm_device *dev)\r\n{\r\nunsigned long irqflags;\r\nbool irq_enabled;\r\nint i;\r\nif (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\r\nreturn -EINVAL;\r\nmutex_lock(&dev->struct_mutex);\r\nirq_enabled = dev->irq_enabled;\r\ndev->irq_enabled = false;\r\nmutex_unlock(&dev->struct_mutex);\r\nif (dev->num_crtcs) {\r\nspin_lock_irqsave(&dev->vbl_lock, irqflags);\r\nfor (i = 0; i < dev->num_crtcs; i++) {\r\nwake_up(&dev->vblank[i].queue);\r\ndev->vblank[i].enabled = false;\r\ndev->vblank[i].last =\r\ndev->driver->get_vblank_counter(dev, i);\r\n}\r\nspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\r\n}\r\nif (!irq_enabled)\r\nreturn -EINVAL;\r\nDRM_DEBUG("irq=%d\n", drm_dev_to_irq(dev));\r\nif (!drm_core_check_feature(dev, DRIVER_MODESET))\r\nvga_client_register(dev->pdev, NULL, NULL, NULL);\r\nif (dev->driver->irq_uninstall)\r\ndev->driver->irq_uninstall(dev);\r\nfree_irq(drm_dev_to_irq(dev), dev);\r\nreturn 0;\r\n}\r\nint drm_control(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_control *ctl = data;\r\nswitch (ctl->func) {\r\ncase DRM_INST_HANDLER:\r\nif (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\r\nreturn 0;\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn 0;\r\nif (dev->if_version < DRM_IF_VERSION(1, 2) &&\r\nctl->irq != drm_dev_to_irq(dev))\r\nreturn -EINVAL;\r\nreturn drm_irq_install(dev);\r\ncase DRM_UNINST_HANDLER:\r\nif (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\r\nreturn 0;\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn 0;\r\nreturn drm_irq_uninstall(dev);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nvoid drm_calc_timestamping_constants(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode)\r\n{\r\nint linedur_ns = 0, pixeldur_ns = 0, framedur_ns = 0;\r\nint dotclock = mode->crtc_clock;\r\nif (dotclock > 0) {\r\nint frame_size = mode->crtc_htotal * mode->crtc_vtotal;\r\npixeldur_ns = 1000000 / dotclock;\r\nlinedur_ns = div_u64((u64) mode->crtc_htotal * 1000000, dotclock);\r\nframedur_ns = div_u64((u64) frame_size * 1000000, dotclock);\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nframedur_ns /= 2;\r\n} else\r\nDRM_ERROR("crtc %d: Can't calculate constants, dotclock = 0!\n",\r\ncrtc->base.id);\r\ncrtc->pixeldur_ns = pixeldur_ns;\r\ncrtc->linedur_ns = linedur_ns;\r\ncrtc->framedur_ns = framedur_ns;\r\nDRM_DEBUG("crtc %d: hwmode: htotal %d, vtotal %d, vdisplay %d\n",\r\ncrtc->base.id, mode->crtc_htotal,\r\nmode->crtc_vtotal, mode->crtc_vdisplay);\r\nDRM_DEBUG("crtc %d: clock %d kHz framedur %d linedur %d, pixeldur %d\n",\r\ncrtc->base.id, dotclock, framedur_ns,\r\nlinedur_ns, pixeldur_ns);\r\n}\r\nint drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev, int crtc,\r\nint *max_error,\r\nstruct timeval *vblank_time,\r\nunsigned flags,\r\nconst struct drm_crtc *refcrtc,\r\nconst struct drm_display_mode *mode)\r\n{\r\nktime_t stime, etime, mono_time_offset;\r\nstruct timeval tv_etime;\r\nint vbl_status;\r\nint vpos, hpos, i;\r\nint framedur_ns, linedur_ns, pixeldur_ns, delta_ns, duration_ns;\r\nbool invbl;\r\nif (crtc < 0 || crtc >= dev->num_crtcs) {\r\nDRM_ERROR("Invalid crtc %d\n", crtc);\r\nreturn -EINVAL;\r\n}\r\nif (!dev->driver->get_scanout_position) {\r\nDRM_ERROR("Called from driver w/o get_scanout_position()!?\n");\r\nreturn -EIO;\r\n}\r\nframedur_ns = refcrtc->framedur_ns;\r\nlinedur_ns = refcrtc->linedur_ns;\r\npixeldur_ns = refcrtc->pixeldur_ns;\r\nif (framedur_ns == 0) {\r\nDRM_DEBUG("crtc %d: Noop due to uninitialized mode.\n", crtc);\r\nreturn -EAGAIN;\r\n}\r\nfor (i = 0; i < DRM_TIMESTAMP_MAXRETRIES; i++) {\r\nvbl_status = dev->driver->get_scanout_position(dev, crtc, flags, &vpos,\r\n&hpos, &stime, &etime);\r\nif (!drm_timestamp_monotonic)\r\nmono_time_offset = ktime_get_monotonic_offset();\r\nif (!(vbl_status & DRM_SCANOUTPOS_VALID)) {\r\nDRM_DEBUG("crtc %d : scanoutpos query failed [%d].\n",\r\ncrtc, vbl_status);\r\nreturn -EIO;\r\n}\r\nduration_ns = ktime_to_ns(etime) - ktime_to_ns(stime);\r\nif (duration_ns <= *max_error)\r\nbreak;\r\n}\r\nif (i == DRM_TIMESTAMP_MAXRETRIES) {\r\nDRM_DEBUG("crtc %d: Noisy timestamp %d us > %d us [%d reps].\n",\r\ncrtc, duration_ns/1000, *max_error/1000, i);\r\n}\r\n*max_error = duration_ns;\r\ninvbl = vbl_status & DRM_SCANOUTPOS_INVBL;\r\ndelta_ns = vpos * linedur_ns + hpos * pixeldur_ns;\r\nif (!drm_timestamp_monotonic)\r\netime = ktime_sub(etime, mono_time_offset);\r\ntv_etime = ktime_to_timeval(etime);\r\nif (delta_ns < 0)\r\netime = ktime_add_ns(etime, -delta_ns);\r\nelse\r\netime = ktime_sub_ns(etime, delta_ns);\r\n*vblank_time = ktime_to_timeval(etime);\r\nDRM_DEBUG("crtc %d : v %d p(%d,%d)@ %ld.%ld -> %ld.%ld [e %d us, %d rep]\n",\r\ncrtc, (int)vbl_status, hpos, vpos,\r\n(long)tv_etime.tv_sec, (long)tv_etime.tv_usec,\r\n(long)vblank_time->tv_sec, (long)vblank_time->tv_usec,\r\nduration_ns/1000, i);\r\nvbl_status = DRM_VBLANKTIME_SCANOUTPOS_METHOD;\r\nif (invbl)\r\nvbl_status |= DRM_VBLANKTIME_INVBL;\r\nreturn vbl_status;\r\n}\r\nstatic struct timeval get_drm_timestamp(void)\r\n{\r\nktime_t now;\r\nnow = ktime_get();\r\nif (!drm_timestamp_monotonic)\r\nnow = ktime_sub(now, ktime_get_monotonic_offset());\r\nreturn ktime_to_timeval(now);\r\n}\r\nu32 drm_get_last_vbltimestamp(struct drm_device *dev, int crtc,\r\nstruct timeval *tvblank, unsigned flags)\r\n{\r\nint ret;\r\nint max_error = (int) drm_timestamp_precision * 1000;\r\nif (dev->driver->get_vblank_timestamp && (max_error > 0)) {\r\nret = dev->driver->get_vblank_timestamp(dev, crtc, &max_error,\r\ntvblank, flags);\r\nif (ret > 0)\r\nreturn (u32) ret;\r\n}\r\n*tvblank = get_drm_timestamp();\r\nreturn 0;\r\n}\r\nu32 drm_vblank_count(struct drm_device *dev, int crtc)\r\n{\r\nreturn atomic_read(&dev->vblank[crtc].count);\r\n}\r\nu32 drm_vblank_count_and_time(struct drm_device *dev, int crtc,\r\nstruct timeval *vblanktime)\r\n{\r\nu32 cur_vblank;\r\ndo {\r\ncur_vblank = atomic_read(&dev->vblank[crtc].count);\r\n*vblanktime = vblanktimestamp(dev, crtc, cur_vblank);\r\nsmp_rmb();\r\n} while (cur_vblank != atomic_read(&dev->vblank[crtc].count));\r\nreturn cur_vblank;\r\n}\r\nstatic void send_vblank_event(struct drm_device *dev,\r\nstruct drm_pending_vblank_event *e,\r\nunsigned long seq, struct timeval *now)\r\n{\r\nWARN_ON_SMP(!spin_is_locked(&dev->event_lock));\r\ne->event.sequence = seq;\r\ne->event.tv_sec = now->tv_sec;\r\ne->event.tv_usec = now->tv_usec;\r\nlist_add_tail(&e->base.link,\r\n&e->base.file_priv->event_list);\r\nwake_up_interruptible(&e->base.file_priv->event_wait);\r\ntrace_drm_vblank_event_delivered(e->base.pid, e->pipe,\r\ne->event.sequence);\r\n}\r\nvoid drm_send_vblank_event(struct drm_device *dev, int crtc,\r\nstruct drm_pending_vblank_event *e)\r\n{\r\nstruct timeval now;\r\nunsigned int seq;\r\nif (crtc >= 0) {\r\nseq = drm_vblank_count_and_time(dev, crtc, &now);\r\n} else {\r\nseq = 0;\r\nnow = get_drm_timestamp();\r\n}\r\ne->pipe = crtc;\r\nsend_vblank_event(dev, e, seq, &now);\r\n}\r\nstatic void drm_update_vblank_count(struct drm_device *dev, int crtc)\r\n{\r\nu32 cur_vblank, diff, tslot, rc;\r\nstruct timeval t_vblank;\r\ndo {\r\ncur_vblank = dev->driver->get_vblank_counter(dev, crtc);\r\nrc = drm_get_last_vbltimestamp(dev, crtc, &t_vblank, 0);\r\n} while (cur_vblank != dev->driver->get_vblank_counter(dev, crtc));\r\ndiff = cur_vblank - dev->vblank[crtc].last;\r\nif (cur_vblank < dev->vblank[crtc].last) {\r\ndiff += dev->max_vblank_count;\r\nDRM_DEBUG("last_vblank[%d]=0x%x, cur_vblank=0x%x => diff=0x%x\n",\r\ncrtc, dev->vblank[crtc].last, cur_vblank, diff);\r\n}\r\nDRM_DEBUG("enabling vblank interrupts on crtc %d, missed %d\n",\r\ncrtc, diff);\r\nif (rc) {\r\ntslot = atomic_read(&dev->vblank[crtc].count) + diff;\r\nvblanktimestamp(dev, crtc, tslot) = t_vblank;\r\n}\r\nsmp_mb__before_atomic_inc();\r\natomic_add(diff, &dev->vblank[crtc].count);\r\nsmp_mb__after_atomic_inc();\r\n}\r\nint drm_vblank_get(struct drm_device *dev, int crtc)\r\n{\r\nunsigned long irqflags, irqflags2;\r\nint ret = 0;\r\nspin_lock_irqsave(&dev->vbl_lock, irqflags);\r\nif (atomic_add_return(1, &dev->vblank[crtc].refcount) == 1) {\r\nspin_lock_irqsave(&dev->vblank_time_lock, irqflags2);\r\nif (!dev->vblank[crtc].enabled) {\r\nret = dev->driver->enable_vblank(dev, crtc);\r\nDRM_DEBUG("enabling vblank on crtc %d, ret: %d\n",\r\ncrtc, ret);\r\nif (ret)\r\natomic_dec(&dev->vblank[crtc].refcount);\r\nelse {\r\ndev->vblank[crtc].enabled = true;\r\ndrm_update_vblank_count(dev, crtc);\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->vblank_time_lock, irqflags2);\r\n} else {\r\nif (!dev->vblank[crtc].enabled) {\r\natomic_dec(&dev->vblank[crtc].refcount);\r\nret = -EINVAL;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\r\nreturn ret;\r\n}\r\nvoid drm_vblank_put(struct drm_device *dev, int crtc)\r\n{\r\nBUG_ON(atomic_read(&dev->vblank[crtc].refcount) == 0);\r\nif (atomic_dec_and_test(&dev->vblank[crtc].refcount) &&\r\n(drm_vblank_offdelay > 0))\r\nmod_timer(&dev->vblank_disable_timer,\r\njiffies + ((drm_vblank_offdelay * HZ)/1000));\r\n}\r\nvoid drm_vblank_off(struct drm_device *dev, int crtc)\r\n{\r\nstruct drm_pending_vblank_event *e, *t;\r\nstruct timeval now;\r\nunsigned long irqflags;\r\nunsigned int seq;\r\nspin_lock_irqsave(&dev->vbl_lock, irqflags);\r\nvblank_disable_and_save(dev, crtc);\r\nwake_up(&dev->vblank[crtc].queue);\r\nseq = drm_vblank_count_and_time(dev, crtc, &now);\r\nspin_lock(&dev->event_lock);\r\nlist_for_each_entry_safe(e, t, &dev->vblank_event_list, base.link) {\r\nif (e->pipe != crtc)\r\ncontinue;\r\nDRM_DEBUG("Sending premature vblank event on disable: \\r\nwanted %d, current %d\n",\r\ne->event.sequence, seq);\r\nlist_del(&e->base.link);\r\ndrm_vblank_put(dev, e->pipe);\r\nsend_vblank_event(dev, e, seq, &now);\r\n}\r\nspin_unlock(&dev->event_lock);\r\nspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\r\n}\r\nvoid drm_vblank_pre_modeset(struct drm_device *dev, int crtc)\r\n{\r\nif (!dev->num_crtcs)\r\nreturn;\r\nif (!dev->vblank[crtc].inmodeset) {\r\ndev->vblank[crtc].inmodeset = 0x1;\r\nif (drm_vblank_get(dev, crtc) == 0)\r\ndev->vblank[crtc].inmodeset |= 0x2;\r\n}\r\n}\r\nvoid drm_vblank_post_modeset(struct drm_device *dev, int crtc)\r\n{\r\nunsigned long irqflags;\r\nif (!dev->num_crtcs)\r\nreturn;\r\nif (dev->vblank[crtc].inmodeset) {\r\nspin_lock_irqsave(&dev->vbl_lock, irqflags);\r\ndev->vblank_disable_allowed = true;\r\nspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\r\nif (dev->vblank[crtc].inmodeset & 0x2)\r\ndrm_vblank_put(dev, crtc);\r\ndev->vblank[crtc].inmodeset = 0;\r\n}\r\n}\r\nint drm_modeset_ctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_modeset_ctl *modeset = data;\r\nunsigned int crtc;\r\nif (!dev->num_crtcs)\r\nreturn 0;\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn 0;\r\ncrtc = modeset->crtc;\r\nif (crtc >= dev->num_crtcs)\r\nreturn -EINVAL;\r\nswitch (modeset->cmd) {\r\ncase _DRM_PRE_MODESET:\r\ndrm_vblank_pre_modeset(dev, crtc);\r\nbreak;\r\ncase _DRM_POST_MODESET:\r\ndrm_vblank_post_modeset(dev, crtc);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int drm_queue_vblank_event(struct drm_device *dev, int pipe,\r\nunion drm_wait_vblank *vblwait,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_pending_vblank_event *e;\r\nstruct timeval now;\r\nunsigned long flags;\r\nunsigned int seq;\r\nint ret;\r\ne = kzalloc(sizeof *e, GFP_KERNEL);\r\nif (e == NULL) {\r\nret = -ENOMEM;\r\ngoto err_put;\r\n}\r\ne->pipe = pipe;\r\ne->base.pid = current->pid;\r\ne->event.base.type = DRM_EVENT_VBLANK;\r\ne->event.base.length = sizeof e->event;\r\ne->event.user_data = vblwait->request.signal;\r\ne->base.event = &e->event.base;\r\ne->base.file_priv = file_priv;\r\ne->base.destroy = (void (*) (struct drm_pending_event *)) kfree;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (file_priv->event_space < sizeof e->event) {\r\nret = -EBUSY;\r\ngoto err_unlock;\r\n}\r\nfile_priv->event_space -= sizeof e->event;\r\nseq = drm_vblank_count_and_time(dev, pipe, &now);\r\nif ((vblwait->request.type & _DRM_VBLANK_NEXTONMISS) &&\r\n(seq - vblwait->request.sequence) <= (1 << 23)) {\r\nvblwait->request.sequence = seq + 1;\r\nvblwait->reply.sequence = vblwait->request.sequence;\r\n}\r\nDRM_DEBUG("event on vblank count %d, current %d, crtc %d\n",\r\nvblwait->request.sequence, seq, pipe);\r\ntrace_drm_vblank_event_queued(current->pid, pipe,\r\nvblwait->request.sequence);\r\ne->event.sequence = vblwait->request.sequence;\r\nif ((seq - vblwait->request.sequence) <= (1 << 23)) {\r\ndrm_vblank_put(dev, pipe);\r\nsend_vblank_event(dev, e, seq, &now);\r\nvblwait->reply.sequence = seq;\r\n} else {\r\nlist_add_tail(&e->base.link, &dev->vblank_event_list);\r\nvblwait->reply.sequence = vblwait->request.sequence;\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn 0;\r\nerr_unlock:\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nkfree(e);\r\nerr_put:\r\ndrm_vblank_put(dev, pipe);\r\nreturn ret;\r\n}\r\nint drm_wait_vblank(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nunion drm_wait_vblank *vblwait = data;\r\nint ret;\r\nunsigned int flags, seq, crtc, high_crtc;\r\nif (drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\r\nif ((!drm_dev_to_irq(dev)) || (!dev->irq_enabled))\r\nreturn -EINVAL;\r\nif (vblwait->request.type & _DRM_VBLANK_SIGNAL)\r\nreturn -EINVAL;\r\nif (vblwait->request.type &\r\n~(_DRM_VBLANK_TYPES_MASK | _DRM_VBLANK_FLAGS_MASK |\r\n_DRM_VBLANK_HIGH_CRTC_MASK)) {\r\nDRM_ERROR("Unsupported type value 0x%x, supported mask 0x%x\n",\r\nvblwait->request.type,\r\n(_DRM_VBLANK_TYPES_MASK | _DRM_VBLANK_FLAGS_MASK |\r\n_DRM_VBLANK_HIGH_CRTC_MASK));\r\nreturn -EINVAL;\r\n}\r\nflags = vblwait->request.type & _DRM_VBLANK_FLAGS_MASK;\r\nhigh_crtc = (vblwait->request.type & _DRM_VBLANK_HIGH_CRTC_MASK);\r\nif (high_crtc)\r\ncrtc = high_crtc >> _DRM_VBLANK_HIGH_CRTC_SHIFT;\r\nelse\r\ncrtc = flags & _DRM_VBLANK_SECONDARY ? 1 : 0;\r\nif (crtc >= dev->num_crtcs)\r\nreturn -EINVAL;\r\nret = drm_vblank_get(dev, crtc);\r\nif (ret) {\r\nDRM_DEBUG("failed to acquire vblank counter, %d\n", ret);\r\nreturn ret;\r\n}\r\nseq = drm_vblank_count(dev, crtc);\r\nswitch (vblwait->request.type & _DRM_VBLANK_TYPES_MASK) {\r\ncase _DRM_VBLANK_RELATIVE:\r\nvblwait->request.sequence += seq;\r\nvblwait->request.type &= ~_DRM_VBLANK_RELATIVE;\r\ncase _DRM_VBLANK_ABSOLUTE:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (flags & _DRM_VBLANK_EVENT) {\r\nreturn drm_queue_vblank_event(dev, crtc, vblwait, file_priv);\r\n}\r\nif ((flags & _DRM_VBLANK_NEXTONMISS) &&\r\n(seq - vblwait->request.sequence) <= (1<<23)) {\r\nvblwait->request.sequence = seq + 1;\r\n}\r\nDRM_DEBUG("waiting on vblank count %d, crtc %d\n",\r\nvblwait->request.sequence, crtc);\r\ndev->vblank[crtc].last_wait = vblwait->request.sequence;\r\nDRM_WAIT_ON(ret, dev->vblank[crtc].queue, 3 * HZ,\r\n(((drm_vblank_count(dev, crtc) -\r\nvblwait->request.sequence) <= (1 << 23)) ||\r\n!dev->irq_enabled));\r\nif (ret != -EINTR) {\r\nstruct timeval now;\r\nvblwait->reply.sequence = drm_vblank_count_and_time(dev, crtc, &now);\r\nvblwait->reply.tval_sec = now.tv_sec;\r\nvblwait->reply.tval_usec = now.tv_usec;\r\nDRM_DEBUG("returning %d to client\n",\r\nvblwait->reply.sequence);\r\n} else {\r\nDRM_DEBUG("vblank wait interrupted by signal\n");\r\n}\r\ndone:\r\ndrm_vblank_put(dev, crtc);\r\nreturn ret;\r\n}\r\nstatic void drm_handle_vblank_events(struct drm_device *dev, int crtc)\r\n{\r\nstruct drm_pending_vblank_event *e, *t;\r\nstruct timeval now;\r\nunsigned long flags;\r\nunsigned int seq;\r\nseq = drm_vblank_count_and_time(dev, crtc, &now);\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nlist_for_each_entry_safe(e, t, &dev->vblank_event_list, base.link) {\r\nif (e->pipe != crtc)\r\ncontinue;\r\nif ((seq - e->event.sequence) > (1<<23))\r\ncontinue;\r\nDRM_DEBUG("vblank event on %d, current %d\n",\r\ne->event.sequence, seq);\r\nlist_del(&e->base.link);\r\ndrm_vblank_put(dev, e->pipe);\r\nsend_vblank_event(dev, e, seq, &now);\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\ntrace_drm_vblank_event(crtc, seq);\r\n}\r\nbool drm_handle_vblank(struct drm_device *dev, int crtc)\r\n{\r\nu32 vblcount;\r\ns64 diff_ns;\r\nstruct timeval tvblank;\r\nunsigned long irqflags;\r\nif (!dev->num_crtcs)\r\nreturn false;\r\nspin_lock_irqsave(&dev->vblank_time_lock, irqflags);\r\nif (!dev->vblank[crtc].enabled) {\r\nspin_unlock_irqrestore(&dev->vblank_time_lock, irqflags);\r\nreturn false;\r\n}\r\nvblcount = atomic_read(&dev->vblank[crtc].count);\r\ndrm_get_last_vbltimestamp(dev, crtc, &tvblank, DRM_CALLED_FROM_VBLIRQ);\r\ndiff_ns = timeval_to_ns(&tvblank) -\r\ntimeval_to_ns(&vblanktimestamp(dev, crtc, vblcount));\r\nif (abs64(diff_ns) > DRM_REDUNDANT_VBLIRQ_THRESH_NS) {\r\nvblanktimestamp(dev, crtc, vblcount + 1) = tvblank;\r\nsmp_mb__before_atomic_inc();\r\natomic_inc(&dev->vblank[crtc].count);\r\nsmp_mb__after_atomic_inc();\r\n} else {\r\nDRM_DEBUG("crtc %d: Redundant vblirq ignored. diff_ns = %d\n",\r\ncrtc, (int) diff_ns);\r\n}\r\nwake_up(&dev->vblank[crtc].queue);\r\ndrm_handle_vblank_events(dev, crtc);\r\nspin_unlock_irqrestore(&dev->vblank_time_lock, irqflags);\r\nreturn true;\r\n}
