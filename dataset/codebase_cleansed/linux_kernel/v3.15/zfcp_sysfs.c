static ssize_t zfcp_sysfs_port_failed_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct zfcp_port *port = container_of(dev, struct zfcp_port, dev);\r\nif (atomic_read(&port->status) & ZFCP_STATUS_COMMON_ERP_FAILED)\r\nreturn sprintf(buf, "1\n");\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t zfcp_sysfs_port_failed_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct zfcp_port *port = container_of(dev, struct zfcp_port, dev);\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val) || val != 0)\r\nreturn -EINVAL;\r\nzfcp_erp_set_port_status(port, ZFCP_STATUS_COMMON_RUNNING);\r\nzfcp_erp_port_reopen(port, ZFCP_STATUS_COMMON_ERP_FAILED, "sypfai2");\r\nzfcp_erp_wait(port->adapter);\r\nreturn count;\r\n}\r\nstatic ssize_t zfcp_sysfs_unit_failed_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct zfcp_unit *unit = container_of(dev, struct zfcp_unit, dev);\r\nstruct scsi_device *sdev;\r\nunsigned int status, failed = 1;\r\nsdev = zfcp_unit_sdev(unit);\r\nif (sdev) {\r\nstatus = atomic_read(&sdev_to_zfcp(sdev)->status);\r\nfailed = status & ZFCP_STATUS_COMMON_ERP_FAILED ? 1 : 0;\r\nscsi_device_put(sdev);\r\n}\r\nreturn sprintf(buf, "%d\n", failed);\r\n}\r\nstatic ssize_t zfcp_sysfs_unit_failed_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct zfcp_unit *unit = container_of(dev, struct zfcp_unit, dev);\r\nunsigned long val;\r\nstruct scsi_device *sdev;\r\nif (kstrtoul(buf, 0, &val) || val != 0)\r\nreturn -EINVAL;\r\nsdev = zfcp_unit_sdev(unit);\r\nif (sdev) {\r\nzfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_RUNNING);\r\nzfcp_erp_lun_reopen(sdev, ZFCP_STATUS_COMMON_ERP_FAILED,\r\n"syufai2");\r\nzfcp_erp_wait(unit->port->adapter);\r\n} else\r\nzfcp_unit_scsi_scan(unit);\r\nreturn count;\r\n}\r\nstatic ssize_t zfcp_sysfs_adapter_failed_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ccw_device *cdev = to_ccwdev(dev);\r\nstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\r\nint i;\r\nif (!adapter)\r\nreturn -ENODEV;\r\nif (atomic_read(&adapter->status) & ZFCP_STATUS_COMMON_ERP_FAILED)\r\ni = sprintf(buf, "1\n");\r\nelse\r\ni = sprintf(buf, "0\n");\r\nzfcp_ccw_adapter_put(adapter);\r\nreturn i;\r\n}\r\nstatic ssize_t zfcp_sysfs_adapter_failed_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ccw_device *cdev = to_ccwdev(dev);\r\nstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\r\nunsigned long val;\r\nint retval = 0;\r\nif (!adapter)\r\nreturn -ENODEV;\r\nif (kstrtoul(buf, 0, &val) || val != 0) {\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nzfcp_erp_set_adapter_status(adapter, ZFCP_STATUS_COMMON_RUNNING);\r\nzfcp_erp_adapter_reopen(adapter, ZFCP_STATUS_COMMON_ERP_FAILED,\r\n"syafai2");\r\nzfcp_erp_wait(adapter);\r\nout:\r\nzfcp_ccw_adapter_put(adapter);\r\nreturn retval ? retval : (ssize_t) count;\r\n}\r\nstatic ssize_t zfcp_sysfs_port_rescan_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ccw_device *cdev = to_ccwdev(dev);\r\nstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\r\nif (!adapter)\r\nreturn -ENODEV;\r\nqueue_work(adapter->work_queue, &adapter->scan_work);\r\nflush_work(&adapter->scan_work);\r\nzfcp_ccw_adapter_put(adapter);\r\nreturn (ssize_t) count;\r\n}\r\nstatic ssize_t zfcp_sysfs_port_remove_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ccw_device *cdev = to_ccwdev(dev);\r\nstruct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);\r\nstruct zfcp_port *port;\r\nu64 wwpn;\r\nint retval = -EINVAL;\r\nif (!adapter)\r\nreturn -ENODEV;\r\nif (kstrtoull(buf, 0, (unsigned long long *) &wwpn))\r\ngoto out;\r\nport = zfcp_get_port_by_wwpn(adapter, wwpn);\r\nif (!port)\r\ngoto out;\r\nelse\r\nretval = 0;\r\nmutex_lock(&zfcp_sysfs_port_units_mutex);\r\nif (atomic_read(&port->units) > 0) {\r\nretval = -EBUSY;\r\nmutex_unlock(&zfcp_sysfs_port_units_mutex);\r\ngoto out;\r\n}\r\natomic_set(&port->units, -1);\r\nmutex_unlock(&zfcp_sysfs_port_units_mutex);\r\nwrite_lock_irq(&adapter->port_list_lock);\r\nlist_del(&port->list);\r\nwrite_unlock_irq(&adapter->port_list_lock);\r\nput_device(&port->dev);\r\nzfcp_erp_port_shutdown(port, 0, "syprs_1");\r\ndevice_unregister(&port->dev);\r\nout:\r\nzfcp_ccw_adapter_put(adapter);\r\nreturn retval ? retval : (ssize_t) count;\r\n}\r\nstatic ssize_t zfcp_sysfs_unit_add_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct zfcp_port *port = container_of(dev, struct zfcp_port, dev);\r\nu64 fcp_lun;\r\nint retval;\r\nif (kstrtoull(buf, 0, (unsigned long long *) &fcp_lun))\r\nreturn -EINVAL;\r\nretval = zfcp_unit_add(port, fcp_lun);\r\nif (retval)\r\nreturn retval;\r\nreturn count;\r\n}\r\nstatic ssize_t zfcp_sysfs_unit_remove_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct zfcp_port *port = container_of(dev, struct zfcp_port, dev);\r\nu64 fcp_lun;\r\nif (kstrtoull(buf, 0, (unsigned long long *) &fcp_lun))\r\nreturn -EINVAL;\r\nif (zfcp_unit_remove(port, fcp_lun))\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic ssize_t zfcp_sysfs_scsi_fcp_lun_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nreturn sprintf(buf, "0x%016llx\n", zfcp_scsi_dev_lun(sdev));\r\n}\r\nstatic ssize_t zfcp_sysfs_adapter_util_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *scsi_host = dev_to_shost(dev);\r\nstruct fsf_qtcb_bottom_port *qtcb_port;\r\nstruct zfcp_adapter *adapter;\r\nint retval;\r\nadapter = (struct zfcp_adapter *) scsi_host->hostdata[0];\r\nif (!(adapter->adapter_features & FSF_FEATURE_MEASUREMENT_DATA))\r\nreturn -EOPNOTSUPP;\r\nqtcb_port = kzalloc(sizeof(struct fsf_qtcb_bottom_port), GFP_KERNEL);\r\nif (!qtcb_port)\r\nreturn -ENOMEM;\r\nretval = zfcp_fsf_exchange_port_data_sync(adapter->qdio, qtcb_port);\r\nif (!retval)\r\nretval = sprintf(buf, "%u %u %u\n", qtcb_port->cp_util,\r\nqtcb_port->cb_util, qtcb_port->a_util);\r\nkfree(qtcb_port);\r\nreturn retval;\r\n}\r\nstatic int zfcp_sysfs_adapter_ex_config(struct device *dev,\r\nstruct fsf_statistics_info *stat_inf)\r\n{\r\nstruct Scsi_Host *scsi_host = dev_to_shost(dev);\r\nstruct fsf_qtcb_bottom_config *qtcb_config;\r\nstruct zfcp_adapter *adapter;\r\nint retval;\r\nadapter = (struct zfcp_adapter *) scsi_host->hostdata[0];\r\nif (!(adapter->adapter_features & FSF_FEATURE_MEASUREMENT_DATA))\r\nreturn -EOPNOTSUPP;\r\nqtcb_config = kzalloc(sizeof(struct fsf_qtcb_bottom_config),\r\nGFP_KERNEL);\r\nif (!qtcb_config)\r\nreturn -ENOMEM;\r\nretval = zfcp_fsf_exchange_config_data_sync(adapter->qdio, qtcb_config);\r\nif (!retval)\r\n*stat_inf = qtcb_config->stat_info;\r\nkfree(qtcb_config);\r\nreturn retval;\r\n}\r\nstatic ssize_t zfcp_sysfs_adapter_q_full_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *scsi_host = class_to_shost(dev);\r\nstruct zfcp_qdio *qdio =\r\n((struct zfcp_adapter *) scsi_host->hostdata[0])->qdio;\r\nu64 util;\r\nspin_lock_bh(&qdio->stat_lock);\r\nutil = qdio->req_q_util;\r\nspin_unlock_bh(&qdio->stat_lock);\r\nreturn sprintf(buf, "%d %llu\n", atomic_read(&qdio->req_q_full),\r\n(unsigned long long)util);\r\n}
