static inline u32 cstamp_delta(unsigned long cstamp)\r\n{\r\nreturn (cstamp - INITIAL_JIFFIES) * 100UL / HZ;\r\n}\r\nstatic inline void addrconf_sysctl_register(struct inet6_dev *idev)\r\n{\r\n}\r\nstatic inline void addrconf_sysctl_unregister(struct inet6_dev *idev)\r\n{\r\n}\r\nstatic inline bool addrconf_qdisc_ok(const struct net_device *dev)\r\n{\r\nreturn !qdisc_tx_is_noop(dev);\r\n}\r\nstatic void addrconf_del_rs_timer(struct inet6_dev *idev)\r\n{\r\nif (del_timer(&idev->rs_timer))\r\n__in6_dev_put(idev);\r\n}\r\nstatic void addrconf_del_dad_work(struct inet6_ifaddr *ifp)\r\n{\r\nif (cancel_delayed_work(&ifp->dad_work))\r\n__in6_ifa_put(ifp);\r\n}\r\nstatic void addrconf_mod_rs_timer(struct inet6_dev *idev,\r\nunsigned long when)\r\n{\r\nif (!timer_pending(&idev->rs_timer))\r\nin6_dev_hold(idev);\r\nmod_timer(&idev->rs_timer, jiffies + when);\r\n}\r\nstatic void addrconf_mod_dad_work(struct inet6_ifaddr *ifp,\r\nunsigned long delay)\r\n{\r\nif (!delayed_work_pending(&ifp->dad_work))\r\nin6_ifa_hold(ifp);\r\nmod_delayed_work(addrconf_wq, &ifp->dad_work, delay);\r\n}\r\nstatic int snmp6_alloc_dev(struct inet6_dev *idev)\r\n{\r\nint i;\r\nif (snmp_mib_init((void __percpu **)idev->stats.ipv6,\r\nsizeof(struct ipstats_mib),\r\n__alignof__(struct ipstats_mib)) < 0)\r\ngoto err_ip;\r\nfor_each_possible_cpu(i) {\r\nstruct ipstats_mib *addrconf_stats;\r\naddrconf_stats = per_cpu_ptr(idev->stats.ipv6[0], i);\r\nu64_stats_init(&addrconf_stats->syncp);\r\n#if SNMP_ARRAY_SZ == 2\r\naddrconf_stats = per_cpu_ptr(idev->stats.ipv6[1], i);\r\nu64_stats_init(&addrconf_stats->syncp);\r\n#endif\r\n}\r\nidev->stats.icmpv6dev = kzalloc(sizeof(struct icmpv6_mib_device),\r\nGFP_KERNEL);\r\nif (!idev->stats.icmpv6dev)\r\ngoto err_icmp;\r\nidev->stats.icmpv6msgdev = kzalloc(sizeof(struct icmpv6msg_mib_device),\r\nGFP_KERNEL);\r\nif (!idev->stats.icmpv6msgdev)\r\ngoto err_icmpmsg;\r\nreturn 0;\r\nerr_icmpmsg:\r\nkfree(idev->stats.icmpv6dev);\r\nerr_icmp:\r\nsnmp_mib_free((void __percpu **)idev->stats.ipv6);\r\nerr_ip:\r\nreturn -ENOMEM;\r\n}\r\nstatic struct inet6_dev *ipv6_add_dev(struct net_device *dev)\r\n{\r\nstruct inet6_dev *ndev;\r\nASSERT_RTNL();\r\nif (dev->mtu < IPV6_MIN_MTU)\r\nreturn NULL;\r\nndev = kzalloc(sizeof(struct inet6_dev), GFP_KERNEL);\r\nif (ndev == NULL)\r\nreturn NULL;\r\nrwlock_init(&ndev->lock);\r\nndev->dev = dev;\r\nINIT_LIST_HEAD(&ndev->addr_list);\r\nsetup_timer(&ndev->rs_timer, addrconf_rs_timer,\r\n(unsigned long)ndev);\r\nmemcpy(&ndev->cnf, dev_net(dev)->ipv6.devconf_dflt, sizeof(ndev->cnf));\r\nndev->cnf.mtu6 = dev->mtu;\r\nndev->cnf.sysctl = NULL;\r\nndev->nd_parms = neigh_parms_alloc(dev, &nd_tbl);\r\nif (ndev->nd_parms == NULL) {\r\nkfree(ndev);\r\nreturn NULL;\r\n}\r\nif (ndev->cnf.forwarding)\r\ndev_disable_lro(dev);\r\ndev_hold(dev);\r\nif (snmp6_alloc_dev(ndev) < 0) {\r\nADBG(KERN_WARNING\r\n"%s: cannot allocate memory for statistics; dev=%s.\n",\r\n__func__, dev->name);\r\nneigh_parms_release(&nd_tbl, ndev->nd_parms);\r\ndev_put(dev);\r\nkfree(ndev);\r\nreturn NULL;\r\n}\r\nif (snmp6_register_dev(ndev) < 0) {\r\nADBG(KERN_WARNING\r\n"%s: cannot create /proc/net/dev_snmp6/%s\n",\r\n__func__, dev->name);\r\nneigh_parms_release(&nd_tbl, ndev->nd_parms);\r\nndev->dead = 1;\r\nin6_dev_finish_destroy(ndev);\r\nreturn NULL;\r\n}\r\nin6_dev_hold(ndev);\r\nif (dev->flags & (IFF_NOARP | IFF_LOOPBACK))\r\nndev->cnf.accept_dad = -1;\r\n#if IS_ENABLED(CONFIG_IPV6_SIT)\r\nif (dev->type == ARPHRD_SIT && (dev->priv_flags & IFF_ISATAP)) {\r\npr_info("%s: Disabled Multicast RS\n", dev->name);\r\nndev->cnf.rtr_solicits = 0;\r\n}\r\n#endif\r\nINIT_LIST_HEAD(&ndev->tempaddr_list);\r\nsetup_timer(&ndev->regen_timer, ipv6_regen_rndid, (unsigned long)ndev);\r\nif ((dev->flags&IFF_LOOPBACK) ||\r\ndev->type == ARPHRD_TUNNEL ||\r\ndev->type == ARPHRD_TUNNEL6 ||\r\ndev->type == ARPHRD_SIT ||\r\ndev->type == ARPHRD_NONE) {\r\nndev->cnf.use_tempaddr = -1;\r\n} else {\r\nin6_dev_hold(ndev);\r\nipv6_regen_rndid((unsigned long) ndev);\r\n}\r\nndev->token = in6addr_any;\r\nif (netif_running(dev) && addrconf_qdisc_ok(dev))\r\nndev->if_flags |= IF_READY;\r\nipv6_mc_init_dev(ndev);\r\nndev->tstamp = jiffies;\r\naddrconf_sysctl_register(ndev);\r\nrcu_assign_pointer(dev->ip6_ptr, ndev);\r\nipv6_dev_mc_inc(dev, &in6addr_interfacelocal_allnodes);\r\nipv6_dev_mc_inc(dev, &in6addr_linklocal_allnodes);\r\nif (ndev->cnf.forwarding && (dev->flags & IFF_MULTICAST))\r\nipv6_dev_mc_inc(dev, &in6addr_linklocal_allrouters);\r\nreturn ndev;\r\n}\r\nstatic struct inet6_dev *ipv6_find_idev(struct net_device *dev)\r\n{\r\nstruct inet6_dev *idev;\r\nASSERT_RTNL();\r\nidev = __in6_dev_get(dev);\r\nif (!idev) {\r\nidev = ipv6_add_dev(dev);\r\nif (!idev)\r\nreturn NULL;\r\n}\r\nif (dev->flags&IFF_UP)\r\nipv6_mc_up(idev);\r\nreturn idev;\r\n}\r\nstatic int inet6_netconf_msgsize_devconf(int type)\r\n{\r\nint size = NLMSG_ALIGN(sizeof(struct netconfmsg))\r\n+ nla_total_size(4);\r\nif (type == -1 || type == NETCONFA_FORWARDING)\r\nsize += nla_total_size(4);\r\n#ifdef CONFIG_IPV6_MROUTE\r\nif (type == -1 || type == NETCONFA_MC_FORWARDING)\r\nsize += nla_total_size(4);\r\n#endif\r\nif (type == -1 || type == NETCONFA_PROXY_NEIGH)\r\nsize += nla_total_size(4);\r\nreturn size;\r\n}\r\nstatic int inet6_netconf_fill_devconf(struct sk_buff *skb, int ifindex,\r\nstruct ipv6_devconf *devconf, u32 portid,\r\nu32 seq, int event, unsigned int flags,\r\nint type)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct netconfmsg *ncm;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct netconfmsg),\r\nflags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nncm = nlmsg_data(nlh);\r\nncm->ncm_family = AF_INET6;\r\nif (nla_put_s32(skb, NETCONFA_IFINDEX, ifindex) < 0)\r\ngoto nla_put_failure;\r\nif ((type == -1 || type == NETCONFA_FORWARDING) &&\r\nnla_put_s32(skb, NETCONFA_FORWARDING, devconf->forwarding) < 0)\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_IPV6_MROUTE\r\nif ((type == -1 || type == NETCONFA_MC_FORWARDING) &&\r\nnla_put_s32(skb, NETCONFA_MC_FORWARDING,\r\ndevconf->mc_forwarding) < 0)\r\ngoto nla_put_failure;\r\n#endif\r\nif ((type == -1 || type == NETCONFA_PROXY_NEIGH) &&\r\nnla_put_s32(skb, NETCONFA_PROXY_NEIGH, devconf->proxy_ndp) < 0)\r\ngoto nla_put_failure;\r\nreturn nlmsg_end(skb, nlh);\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nvoid inet6_netconf_notify_devconf(struct net *net, int type, int ifindex,\r\nstruct ipv6_devconf *devconf)\r\n{\r\nstruct sk_buff *skb;\r\nint err = -ENOBUFS;\r\nskb = nlmsg_new(inet6_netconf_msgsize_devconf(type), GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = inet6_netconf_fill_devconf(skb, ifindex, devconf, 0, 0,\r\nRTM_NEWNETCONF, 0, type);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, 0, RTNLGRP_IPV6_NETCONF, NULL, GFP_ATOMIC);\r\nreturn;\r\nerrout:\r\nrtnl_set_sk_err(net, RTNLGRP_IPV6_NETCONF, err);\r\n}\r\nstatic int inet6_netconf_get_devconf(struct sk_buff *in_skb,\r\nstruct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(in_skb->sk);\r\nstruct nlattr *tb[NETCONFA_MAX+1];\r\nstruct netconfmsg *ncm;\r\nstruct sk_buff *skb;\r\nstruct ipv6_devconf *devconf;\r\nstruct inet6_dev *in6_dev;\r\nstruct net_device *dev;\r\nint ifindex;\r\nint err;\r\nerr = nlmsg_parse(nlh, sizeof(*ncm), tb, NETCONFA_MAX,\r\ndevconf_ipv6_policy);\r\nif (err < 0)\r\ngoto errout;\r\nerr = EINVAL;\r\nif (!tb[NETCONFA_IFINDEX])\r\ngoto errout;\r\nifindex = nla_get_s32(tb[NETCONFA_IFINDEX]);\r\nswitch (ifindex) {\r\ncase NETCONFA_IFINDEX_ALL:\r\ndevconf = net->ipv6.devconf_all;\r\nbreak;\r\ncase NETCONFA_IFINDEX_DEFAULT:\r\ndevconf = net->ipv6.devconf_dflt;\r\nbreak;\r\ndefault:\r\ndev = __dev_get_by_index(net, ifindex);\r\nif (dev == NULL)\r\ngoto errout;\r\nin6_dev = __in6_dev_get(dev);\r\nif (in6_dev == NULL)\r\ngoto errout;\r\ndevconf = &in6_dev->cnf;\r\nbreak;\r\n}\r\nerr = -ENOBUFS;\r\nskb = nlmsg_new(inet6_netconf_msgsize_devconf(-1), GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = inet6_netconf_fill_devconf(skb, ifindex, devconf,\r\nNETLINK_CB(in_skb).portid,\r\nnlh->nlmsg_seq, RTM_NEWNETCONF, 0,\r\n-1);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nerr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int inet6_netconf_dump_devconf(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nint h, s_h;\r\nint idx, s_idx;\r\nstruct net_device *dev;\r\nstruct inet6_dev *idev;\r\nstruct hlist_head *head;\r\ns_h = cb->args[0];\r\ns_idx = idx = cb->args[1];\r\nfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\r\nidx = 0;\r\nhead = &net->dev_index_head[h];\r\nrcu_read_lock();\r\ncb->seq = atomic_read(&net->ipv6.dev_addr_genid) ^\r\nnet->dev_base_seq;\r\nhlist_for_each_entry_rcu(dev, head, index_hlist) {\r\nif (idx < s_idx)\r\ngoto cont;\r\nidev = __in6_dev_get(dev);\r\nif (!idev)\r\ngoto cont;\r\nif (inet6_netconf_fill_devconf(skb, dev->ifindex,\r\n&idev->cnf,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWNETCONF,\r\nNLM_F_MULTI,\r\n-1) <= 0) {\r\nrcu_read_unlock();\r\ngoto done;\r\n}\r\nnl_dump_check_consistent(cb, nlmsg_hdr(skb));\r\ncont:\r\nidx++;\r\n}\r\nrcu_read_unlock();\r\n}\r\nif (h == NETDEV_HASHENTRIES) {\r\nif (inet6_netconf_fill_devconf(skb, NETCONFA_IFINDEX_ALL,\r\nnet->ipv6.devconf_all,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWNETCONF, NLM_F_MULTI,\r\n-1) <= 0)\r\ngoto done;\r\nelse\r\nh++;\r\n}\r\nif (h == NETDEV_HASHENTRIES + 1) {\r\nif (inet6_netconf_fill_devconf(skb, NETCONFA_IFINDEX_DEFAULT,\r\nnet->ipv6.devconf_dflt,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWNETCONF, NLM_F_MULTI,\r\n-1) <= 0)\r\ngoto done;\r\nelse\r\nh++;\r\n}\r\ndone:\r\ncb->args[0] = h;\r\ncb->args[1] = idx;\r\nreturn skb->len;\r\n}\r\nstatic void dev_forward_change(struct inet6_dev *idev)\r\n{\r\nstruct net_device *dev;\r\nstruct inet6_ifaddr *ifa;\r\nif (!idev)\r\nreturn;\r\ndev = idev->dev;\r\nif (idev->cnf.forwarding)\r\ndev_disable_lro(dev);\r\nif (dev->flags & IFF_MULTICAST) {\r\nif (idev->cnf.forwarding) {\r\nipv6_dev_mc_inc(dev, &in6addr_linklocal_allrouters);\r\nipv6_dev_mc_inc(dev, &in6addr_interfacelocal_allrouters);\r\nipv6_dev_mc_inc(dev, &in6addr_sitelocal_allrouters);\r\n} else {\r\nipv6_dev_mc_dec(dev, &in6addr_linklocal_allrouters);\r\nipv6_dev_mc_dec(dev, &in6addr_interfacelocal_allrouters);\r\nipv6_dev_mc_dec(dev, &in6addr_sitelocal_allrouters);\r\n}\r\n}\r\nlist_for_each_entry(ifa, &idev->addr_list, if_list) {\r\nif (ifa->flags&IFA_F_TENTATIVE)\r\ncontinue;\r\nif (idev->cnf.forwarding)\r\naddrconf_join_anycast(ifa);\r\nelse\r\naddrconf_leave_anycast(ifa);\r\n}\r\ninet6_netconf_notify_devconf(dev_net(dev), NETCONFA_FORWARDING,\r\ndev->ifindex, &idev->cnf);\r\n}\r\nstatic void addrconf_forward_change(struct net *net, __s32 newf)\r\n{\r\nstruct net_device *dev;\r\nstruct inet6_dev *idev;\r\nfor_each_netdev(net, dev) {\r\nidev = __in6_dev_get(dev);\r\nif (idev) {\r\nint changed = (!idev->cnf.forwarding) ^ (!newf);\r\nidev->cnf.forwarding = newf;\r\nif (changed)\r\ndev_forward_change(idev);\r\n}\r\n}\r\n}\r\nstatic int addrconf_fixup_forwarding(struct ctl_table *table, int *p, int newf)\r\n{\r\nstruct net *net;\r\nint old;\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\nnet = (struct net *)table->extra2;\r\nold = *p;\r\n*p = newf;\r\nif (p == &net->ipv6.devconf_dflt->forwarding) {\r\nif ((!newf) ^ (!old))\r\ninet6_netconf_notify_devconf(net, NETCONFA_FORWARDING,\r\nNETCONFA_IFINDEX_DEFAULT,\r\nnet->ipv6.devconf_dflt);\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nif (p == &net->ipv6.devconf_all->forwarding) {\r\nnet->ipv6.devconf_dflt->forwarding = newf;\r\naddrconf_forward_change(net, newf);\r\nif ((!newf) ^ (!old))\r\ninet6_netconf_notify_devconf(net, NETCONFA_FORWARDING,\r\nNETCONFA_IFINDEX_ALL,\r\nnet->ipv6.devconf_all);\r\n} else if ((!newf) ^ (!old))\r\ndev_forward_change((struct inet6_dev *)table->extra1);\r\nrtnl_unlock();\r\nif (newf)\r\nrt6_purge_dflt_routers(net);\r\nreturn 1;\r\n}\r\nvoid inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp)\r\n{\r\nWARN_ON(!hlist_unhashed(&ifp->addr_lst));\r\n#ifdef NET_REFCNT_DEBUG\r\npr_debug("%s\n", __func__);\r\n#endif\r\nin6_dev_put(ifp->idev);\r\nif (cancel_delayed_work(&ifp->dad_work))\r\npr_notice("delayed DAD work was pending while freeing ifa=%p\n",\r\nifp);\r\nif (ifp->state != INET6_IFADDR_STATE_DEAD) {\r\npr_warn("Freeing alive inet6 address %p\n", ifp);\r\nreturn;\r\n}\r\nip6_rt_put(ifp->rt);\r\nkfree_rcu(ifp, rcu);\r\n}\r\nstatic void\r\nipv6_link_dev_addr(struct inet6_dev *idev, struct inet6_ifaddr *ifp)\r\n{\r\nstruct list_head *p;\r\nint ifp_scope = ipv6_addr_src_scope(&ifp->addr);\r\nlist_for_each(p, &idev->addr_list) {\r\nstruct inet6_ifaddr *ifa\r\n= list_entry(p, struct inet6_ifaddr, if_list);\r\nif (ifp_scope >= ipv6_addr_src_scope(&ifa->addr))\r\nbreak;\r\n}\r\nlist_add_tail(&ifp->if_list, p);\r\n}\r\nstatic u32 inet6_addr_hash(const struct in6_addr *addr)\r\n{\r\nreturn hash_32(ipv6_addr_hash(addr), IN6_ADDR_HSIZE_SHIFT);\r\n}\r\nstatic struct inet6_ifaddr *\r\nipv6_add_addr(struct inet6_dev *idev, const struct in6_addr *addr,\r\nconst struct in6_addr *peer_addr, int pfxlen,\r\nint scope, u32 flags, u32 valid_lft, u32 prefered_lft)\r\n{\r\nstruct inet6_ifaddr *ifa = NULL;\r\nstruct rt6_info *rt;\r\nunsigned int hash;\r\nint err = 0;\r\nint addr_type = ipv6_addr_type(addr);\r\nif (addr_type == IPV6_ADDR_ANY ||\r\naddr_type & IPV6_ADDR_MULTICAST ||\r\n(!(idev->dev->flags & IFF_LOOPBACK) &&\r\naddr_type & IPV6_ADDR_LOOPBACK))\r\nreturn ERR_PTR(-EADDRNOTAVAIL);\r\nrcu_read_lock_bh();\r\nif (idev->dead) {\r\nerr = -ENODEV;\r\ngoto out2;\r\n}\r\nif (idev->cnf.disable_ipv6) {\r\nerr = -EACCES;\r\ngoto out2;\r\n}\r\nspin_lock(&addrconf_hash_lock);\r\nif (ipv6_chk_same_addr(dev_net(idev->dev), addr, idev->dev)) {\r\nADBG("ipv6_add_addr: already assigned\n");\r\nerr = -EEXIST;\r\ngoto out;\r\n}\r\nifa = kzalloc(sizeof(struct inet6_ifaddr), GFP_ATOMIC);\r\nif (ifa == NULL) {\r\nADBG("ipv6_add_addr: malloc failed\n");\r\nerr = -ENOBUFS;\r\ngoto out;\r\n}\r\nrt = addrconf_dst_alloc(idev, addr, false);\r\nif (IS_ERR(rt)) {\r\nerr = PTR_ERR(rt);\r\ngoto out;\r\n}\r\nneigh_parms_data_state_setall(idev->nd_parms);\r\nifa->addr = *addr;\r\nif (peer_addr)\r\nifa->peer_addr = *peer_addr;\r\nspin_lock_init(&ifa->lock);\r\nspin_lock_init(&ifa->state_lock);\r\nINIT_DELAYED_WORK(&ifa->dad_work, addrconf_dad_work);\r\nINIT_HLIST_NODE(&ifa->addr_lst);\r\nifa->scope = scope;\r\nifa->prefix_len = pfxlen;\r\nifa->flags = flags | IFA_F_TENTATIVE;\r\nifa->valid_lft = valid_lft;\r\nifa->prefered_lft = prefered_lft;\r\nifa->cstamp = ifa->tstamp = jiffies;\r\nifa->tokenized = false;\r\nifa->rt = rt;\r\nifa->idev = idev;\r\nin6_dev_hold(idev);\r\nin6_ifa_hold(ifa);\r\nhash = inet6_addr_hash(addr);\r\nhlist_add_head_rcu(&ifa->addr_lst, &inet6_addr_lst[hash]);\r\nspin_unlock(&addrconf_hash_lock);\r\nwrite_lock(&idev->lock);\r\nipv6_link_dev_addr(idev, ifa);\r\nif (ifa->flags&IFA_F_TEMPORARY) {\r\nlist_add(&ifa->tmp_list, &idev->tempaddr_list);\r\nin6_ifa_hold(ifa);\r\n}\r\nin6_ifa_hold(ifa);\r\nwrite_unlock(&idev->lock);\r\nout2:\r\nrcu_read_unlock_bh();\r\nif (likely(err == 0))\r\ninet6addr_notifier_call_chain(NETDEV_UP, ifa);\r\nelse {\r\nkfree(ifa);\r\nifa = ERR_PTR(err);\r\n}\r\nreturn ifa;\r\nout:\r\nspin_unlock(&addrconf_hash_lock);\r\ngoto out2;\r\n}\r\nstatic enum cleanup_prefix_rt_t\r\ncheck_cleanup_prefix_route(struct inet6_ifaddr *ifp, unsigned long *expires)\r\n{\r\nstruct inet6_ifaddr *ifa;\r\nstruct inet6_dev *idev = ifp->idev;\r\nunsigned long lifetime;\r\nenum cleanup_prefix_rt_t action = CLEANUP_PREFIX_RT_DEL;\r\n*expires = jiffies;\r\nlist_for_each_entry(ifa, &idev->addr_list, if_list) {\r\nif (ifa == ifp)\r\ncontinue;\r\nif (!ipv6_prefix_equal(&ifa->addr, &ifp->addr,\r\nifp->prefix_len))\r\ncontinue;\r\nif (ifa->flags & (IFA_F_PERMANENT | IFA_F_NOPREFIXROUTE))\r\nreturn CLEANUP_PREFIX_RT_NOP;\r\naction = CLEANUP_PREFIX_RT_EXPIRE;\r\nspin_lock(&ifa->lock);\r\nlifetime = addrconf_timeout_fixup(ifa->valid_lft, HZ);\r\nif (time_before(*expires, ifa->tstamp + lifetime * HZ))\r\n*expires = ifa->tstamp + lifetime * HZ;\r\nspin_unlock(&ifa->lock);\r\n}\r\nreturn action;\r\n}\r\nstatic void\r\ncleanup_prefix_route(struct inet6_ifaddr *ifp, unsigned long expires, bool del_rt)\r\n{\r\nstruct rt6_info *rt;\r\nrt = addrconf_get_prefix_route(&ifp->addr,\r\nifp->prefix_len,\r\nifp->idev->dev,\r\n0, RTF_GATEWAY | RTF_DEFAULT);\r\nif (rt) {\r\nif (del_rt)\r\nip6_del_rt(rt);\r\nelse {\r\nif (!(rt->rt6i_flags & RTF_EXPIRES))\r\nrt6_set_expires(rt, expires);\r\nip6_rt_put(rt);\r\n}\r\n}\r\n}\r\nstatic void ipv6_del_addr(struct inet6_ifaddr *ifp)\r\n{\r\nint state;\r\nenum cleanup_prefix_rt_t action = CLEANUP_PREFIX_RT_NOP;\r\nunsigned long expires;\r\nASSERT_RTNL();\r\nspin_lock_bh(&ifp->state_lock);\r\nstate = ifp->state;\r\nifp->state = INET6_IFADDR_STATE_DEAD;\r\nspin_unlock_bh(&ifp->state_lock);\r\nif (state == INET6_IFADDR_STATE_DEAD)\r\ngoto out;\r\nspin_lock_bh(&addrconf_hash_lock);\r\nhlist_del_init_rcu(&ifp->addr_lst);\r\nspin_unlock_bh(&addrconf_hash_lock);\r\nwrite_lock_bh(&ifp->idev->lock);\r\nif (ifp->flags&IFA_F_TEMPORARY) {\r\nlist_del(&ifp->tmp_list);\r\nif (ifp->ifpub) {\r\nin6_ifa_put(ifp->ifpub);\r\nifp->ifpub = NULL;\r\n}\r\n__in6_ifa_put(ifp);\r\n}\r\nif (ifp->flags & IFA_F_PERMANENT && !(ifp->flags & IFA_F_NOPREFIXROUTE))\r\naction = check_cleanup_prefix_route(ifp, &expires);\r\nlist_del_init(&ifp->if_list);\r\n__in6_ifa_put(ifp);\r\nwrite_unlock_bh(&ifp->idev->lock);\r\naddrconf_del_dad_work(ifp);\r\nipv6_ifa_notify(RTM_DELADDR, ifp);\r\ninet6addr_notifier_call_chain(NETDEV_DOWN, ifp);\r\nif (action != CLEANUP_PREFIX_RT_NOP) {\r\ncleanup_prefix_route(ifp, expires,\r\naction == CLEANUP_PREFIX_RT_DEL);\r\n}\r\nrt6_remove_prefsrc(ifp);\r\nout:\r\nin6_ifa_put(ifp);\r\n}\r\nstatic int ipv6_create_tempaddr(struct inet6_ifaddr *ifp, struct inet6_ifaddr *ift)\r\n{\r\nstruct inet6_dev *idev = ifp->idev;\r\nstruct in6_addr addr, *tmpaddr;\r\nunsigned long tmp_prefered_lft, tmp_valid_lft, tmp_tstamp, age;\r\nunsigned long regen_advance;\r\nint tmp_plen;\r\nint ret = 0;\r\nu32 addr_flags;\r\nunsigned long now = jiffies;\r\nwrite_lock_bh(&idev->lock);\r\nif (ift) {\r\nspin_lock_bh(&ift->lock);\r\nmemcpy(&addr.s6_addr[8], &ift->addr.s6_addr[8], 8);\r\nspin_unlock_bh(&ift->lock);\r\ntmpaddr = &addr;\r\n} else {\r\ntmpaddr = NULL;\r\n}\r\nretry:\r\nin6_dev_hold(idev);\r\nif (idev->cnf.use_tempaddr <= 0) {\r\nwrite_unlock_bh(&idev->lock);\r\npr_info("%s: use_tempaddr is disabled\n", __func__);\r\nin6_dev_put(idev);\r\nret = -1;\r\ngoto out;\r\n}\r\nspin_lock_bh(&ifp->lock);\r\nif (ifp->regen_count++ >= idev->cnf.regen_max_retry) {\r\nidev->cnf.use_tempaddr = -1;\r\nspin_unlock_bh(&ifp->lock);\r\nwrite_unlock_bh(&idev->lock);\r\npr_warn("%s: regeneration time exceeded - disabled temporary address support\n",\r\n__func__);\r\nin6_dev_put(idev);\r\nret = -1;\r\ngoto out;\r\n}\r\nin6_ifa_hold(ifp);\r\nmemcpy(addr.s6_addr, ifp->addr.s6_addr, 8);\r\n__ipv6_try_regen_rndid(idev, tmpaddr);\r\nmemcpy(&addr.s6_addr[8], idev->rndid, 8);\r\nage = (now - ifp->tstamp) / HZ;\r\ntmp_valid_lft = min_t(__u32,\r\nifp->valid_lft,\r\nidev->cnf.temp_valid_lft + age);\r\ntmp_prefered_lft = min_t(__u32,\r\nifp->prefered_lft,\r\nidev->cnf.temp_prefered_lft + age -\r\nidev->cnf.max_desync_factor);\r\ntmp_plen = ifp->prefix_len;\r\ntmp_tstamp = ifp->tstamp;\r\nspin_unlock_bh(&ifp->lock);\r\nregen_advance = idev->cnf.regen_max_retry *\r\nidev->cnf.dad_transmits *\r\nNEIGH_VAR(idev->nd_parms, RETRANS_TIME) / HZ;\r\nwrite_unlock_bh(&idev->lock);\r\nage = (now - tmp_tstamp + ADDRCONF_TIMER_FUZZ_MINUS) / HZ;\r\nif (tmp_prefered_lft <= regen_advance + age) {\r\nin6_ifa_put(ifp);\r\nin6_dev_put(idev);\r\nret = -1;\r\ngoto out;\r\n}\r\naddr_flags = IFA_F_TEMPORARY;\r\nif (ifp->flags & IFA_F_OPTIMISTIC)\r\naddr_flags |= IFA_F_OPTIMISTIC;\r\nift = ipv6_add_addr(idev, &addr, NULL, tmp_plen,\r\nipv6_addr_scope(&addr), addr_flags,\r\ntmp_valid_lft, tmp_prefered_lft);\r\nif (IS_ERR(ift)) {\r\nin6_ifa_put(ifp);\r\nin6_dev_put(idev);\r\npr_info("%s: retry temporary address regeneration\n", __func__);\r\ntmpaddr = &addr;\r\nwrite_lock_bh(&idev->lock);\r\ngoto retry;\r\n}\r\nspin_lock_bh(&ift->lock);\r\nift->ifpub = ifp;\r\nift->cstamp = now;\r\nift->tstamp = tmp_tstamp;\r\nspin_unlock_bh(&ift->lock);\r\naddrconf_dad_start(ift);\r\nin6_ifa_put(ift);\r\nin6_dev_put(idev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic inline int ipv6_saddr_preferred(int type)\r\n{\r\nif (type & (IPV6_ADDR_MAPPED|IPV6_ADDR_COMPATv4|IPV6_ADDR_LOOPBACK))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ipv6_get_saddr_eval(struct net *net,\r\nstruct ipv6_saddr_score *score,\r\nstruct ipv6_saddr_dst *dst,\r\nint i)\r\n{\r\nint ret;\r\nif (i <= score->rule) {\r\nswitch (i) {\r\ncase IPV6_SADDR_RULE_SCOPE:\r\nret = score->scopedist;\r\nbreak;\r\ncase IPV6_SADDR_RULE_PREFIX:\r\nret = score->matchlen;\r\nbreak;\r\ndefault:\r\nret = !!test_bit(i, score->scorebits);\r\n}\r\ngoto out;\r\n}\r\nswitch (i) {\r\ncase IPV6_SADDR_RULE_INIT:\r\nret = !!score->ifa;\r\nbreak;\r\ncase IPV6_SADDR_RULE_LOCAL:\r\nret = ipv6_addr_equal(&score->ifa->addr, dst->addr);\r\nbreak;\r\ncase IPV6_SADDR_RULE_SCOPE:\r\nret = __ipv6_addr_src_scope(score->addr_type);\r\nif (ret >= dst->scope)\r\nret = -ret;\r\nelse\r\nret -= 128;\r\nscore->scopedist = ret;\r\nbreak;\r\ncase IPV6_SADDR_RULE_PREFERRED:\r\nret = ipv6_saddr_preferred(score->addr_type) ||\r\n!(score->ifa->flags & (IFA_F_DEPRECATED|IFA_F_OPTIMISTIC));\r\nbreak;\r\n#ifdef CONFIG_IPV6_MIP6\r\ncase IPV6_SADDR_RULE_HOA:\r\n{\r\nint prefhome = !(dst->prefs & IPV6_PREFER_SRC_COA);\r\nret = !(score->ifa->flags & IFA_F_HOMEADDRESS) ^ prefhome;\r\nbreak;\r\n}\r\n#endif\r\ncase IPV6_SADDR_RULE_OIF:\r\nret = (!dst->ifindex ||\r\ndst->ifindex == score->ifa->idev->dev->ifindex);\r\nbreak;\r\ncase IPV6_SADDR_RULE_LABEL:\r\nret = ipv6_addr_label(net,\r\n&score->ifa->addr, score->addr_type,\r\nscore->ifa->idev->dev->ifindex) == dst->label;\r\nbreak;\r\ncase IPV6_SADDR_RULE_PRIVACY:\r\n{\r\nint preftmp = dst->prefs & (IPV6_PREFER_SRC_PUBLIC|IPV6_PREFER_SRC_TMP) ?\r\n!!(dst->prefs & IPV6_PREFER_SRC_TMP) :\r\nscore->ifa->idev->cnf.use_tempaddr >= 2;\r\nret = (!(score->ifa->flags & IFA_F_TEMPORARY)) ^ preftmp;\r\nbreak;\r\n}\r\ncase IPV6_SADDR_RULE_ORCHID:\r\nret = !(ipv6_addr_orchid(&score->ifa->addr) ^\r\nipv6_addr_orchid(dst->addr));\r\nbreak;\r\ncase IPV6_SADDR_RULE_PREFIX:\r\nret = ipv6_addr_diff(&score->ifa->addr, dst->addr);\r\nif (ret > score->ifa->prefix_len)\r\nret = score->ifa->prefix_len;\r\nscore->matchlen = ret;\r\nbreak;\r\ndefault:\r\nret = 0;\r\n}\r\nif (ret)\r\n__set_bit(i, score->scorebits);\r\nscore->rule = i;\r\nout:\r\nreturn ret;\r\n}\r\nint ipv6_dev_get_saddr(struct net *net, const struct net_device *dst_dev,\r\nconst struct in6_addr *daddr, unsigned int prefs,\r\nstruct in6_addr *saddr)\r\n{\r\nstruct ipv6_saddr_score scores[2],\r\n*score = &scores[0], *hiscore = &scores[1];\r\nstruct ipv6_saddr_dst dst;\r\nstruct net_device *dev;\r\nint dst_type;\r\ndst_type = __ipv6_addr_type(daddr);\r\ndst.addr = daddr;\r\ndst.ifindex = dst_dev ? dst_dev->ifindex : 0;\r\ndst.scope = __ipv6_addr_src_scope(dst_type);\r\ndst.label = ipv6_addr_label(net, daddr, dst_type, dst.ifindex);\r\ndst.prefs = prefs;\r\nhiscore->rule = -1;\r\nhiscore->ifa = NULL;\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(net, dev) {\r\nstruct inet6_dev *idev;\r\nif (((dst_type & IPV6_ADDR_MULTICAST) ||\r\ndst.scope <= IPV6_ADDR_SCOPE_LINKLOCAL) &&\r\ndst.ifindex && dev->ifindex != dst.ifindex)\r\ncontinue;\r\nidev = __in6_dev_get(dev);\r\nif (!idev)\r\ncontinue;\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry(score->ifa, &idev->addr_list, if_list) {\r\nint i;\r\nif ((score->ifa->flags & IFA_F_TENTATIVE) &&\r\n(!(score->ifa->flags & IFA_F_OPTIMISTIC)))\r\ncontinue;\r\nscore->addr_type = __ipv6_addr_type(&score->ifa->addr);\r\nif (unlikely(score->addr_type == IPV6_ADDR_ANY ||\r\nscore->addr_type & IPV6_ADDR_MULTICAST)) {\r\nLIMIT_NETDEBUG(KERN_DEBUG\r\n"ADDRCONF: unspecified / multicast address "\r\n"assigned as unicast address on %s",\r\ndev->name);\r\ncontinue;\r\n}\r\nscore->rule = -1;\r\nbitmap_zero(score->scorebits, IPV6_SADDR_RULE_MAX);\r\nfor (i = 0; i < IPV6_SADDR_RULE_MAX; i++) {\r\nint minihiscore, miniscore;\r\nminihiscore = ipv6_get_saddr_eval(net, hiscore, &dst, i);\r\nminiscore = ipv6_get_saddr_eval(net, score, &dst, i);\r\nif (minihiscore > miniscore) {\r\nif (i == IPV6_SADDR_RULE_SCOPE &&\r\nscore->scopedist > 0) {\r\ngoto try_nextdev;\r\n}\r\nbreak;\r\n} else if (minihiscore < miniscore) {\r\nif (hiscore->ifa)\r\nin6_ifa_put(hiscore->ifa);\r\nin6_ifa_hold(score->ifa);\r\nswap(hiscore, score);\r\nscore->ifa = hiscore->ifa;\r\nbreak;\r\n}\r\n}\r\n}\r\ntry_nextdev:\r\nread_unlock_bh(&idev->lock);\r\n}\r\nrcu_read_unlock();\r\nif (!hiscore->ifa)\r\nreturn -EADDRNOTAVAIL;\r\n*saddr = hiscore->ifa->addr;\r\nin6_ifa_put(hiscore->ifa);\r\nreturn 0;\r\n}\r\nint __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,\r\nu32 banned_flags)\r\n{\r\nstruct inet6_ifaddr *ifp;\r\nint err = -EADDRNOTAVAIL;\r\nlist_for_each_entry_reverse(ifp, &idev->addr_list, if_list) {\r\nif (ifp->scope > IFA_LINK)\r\nbreak;\r\nif (ifp->scope == IFA_LINK &&\r\n!(ifp->flags & banned_flags)) {\r\n*addr = ifp->addr;\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nint ipv6_get_lladdr(struct net_device *dev, struct in6_addr *addr,\r\nu32 banned_flags)\r\n{\r\nstruct inet6_dev *idev;\r\nint err = -EADDRNOTAVAIL;\r\nrcu_read_lock();\r\nidev = __in6_dev_get(dev);\r\nif (idev) {\r\nread_lock_bh(&idev->lock);\r\nerr = __ipv6_get_lladdr(idev, addr, banned_flags);\r\nread_unlock_bh(&idev->lock);\r\n}\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic int ipv6_count_addresses(struct inet6_dev *idev)\r\n{\r\nint cnt = 0;\r\nstruct inet6_ifaddr *ifp;\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry(ifp, &idev->addr_list, if_list)\r\ncnt++;\r\nread_unlock_bh(&idev->lock);\r\nreturn cnt;\r\n}\r\nint ipv6_chk_addr(struct net *net, const struct in6_addr *addr,\r\nconst struct net_device *dev, int strict)\r\n{\r\nstruct inet6_ifaddr *ifp;\r\nunsigned int hash = inet6_addr_hash(addr);\r\nrcu_read_lock_bh();\r\nhlist_for_each_entry_rcu(ifp, &inet6_addr_lst[hash], addr_lst) {\r\nif (!net_eq(dev_net(ifp->idev->dev), net))\r\ncontinue;\r\nif (ipv6_addr_equal(&ifp->addr, addr) &&\r\n!(ifp->flags&IFA_F_TENTATIVE) &&\r\n(dev == NULL || ifp->idev->dev == dev ||\r\n!(ifp->scope&(IFA_LINK|IFA_HOST) || strict))) {\r\nrcu_read_unlock_bh();\r\nreturn 1;\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nreturn 0;\r\n}\r\nstatic bool ipv6_chk_same_addr(struct net *net, const struct in6_addr *addr,\r\nstruct net_device *dev)\r\n{\r\nunsigned int hash = inet6_addr_hash(addr);\r\nstruct inet6_ifaddr *ifp;\r\nhlist_for_each_entry(ifp, &inet6_addr_lst[hash], addr_lst) {\r\nif (!net_eq(dev_net(ifp->idev->dev), net))\r\ncontinue;\r\nif (ipv6_addr_equal(&ifp->addr, addr)) {\r\nif (dev == NULL || ifp->idev->dev == dev)\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nbool ipv6_chk_custom_prefix(const struct in6_addr *addr,\r\nconst unsigned int prefix_len, struct net_device *dev)\r\n{\r\nstruct inet6_dev *idev;\r\nstruct inet6_ifaddr *ifa;\r\nbool ret = false;\r\nrcu_read_lock();\r\nidev = __in6_dev_get(dev);\r\nif (idev) {\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry(ifa, &idev->addr_list, if_list) {\r\nret = ipv6_prefix_equal(addr, &ifa->addr, prefix_len);\r\nif (ret)\r\nbreak;\r\n}\r\nread_unlock_bh(&idev->lock);\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nint ipv6_chk_prefix(const struct in6_addr *addr, struct net_device *dev)\r\n{\r\nstruct inet6_dev *idev;\r\nstruct inet6_ifaddr *ifa;\r\nint onlink;\r\nonlink = 0;\r\nrcu_read_lock();\r\nidev = __in6_dev_get(dev);\r\nif (idev) {\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry(ifa, &idev->addr_list, if_list) {\r\nonlink = ipv6_prefix_equal(addr, &ifa->addr,\r\nifa->prefix_len);\r\nif (onlink)\r\nbreak;\r\n}\r\nread_unlock_bh(&idev->lock);\r\n}\r\nrcu_read_unlock();\r\nreturn onlink;\r\n}\r\nstruct inet6_ifaddr *ipv6_get_ifaddr(struct net *net, const struct in6_addr *addr,\r\nstruct net_device *dev, int strict)\r\n{\r\nstruct inet6_ifaddr *ifp, *result = NULL;\r\nunsigned int hash = inet6_addr_hash(addr);\r\nrcu_read_lock_bh();\r\nhlist_for_each_entry_rcu_bh(ifp, &inet6_addr_lst[hash], addr_lst) {\r\nif (!net_eq(dev_net(ifp->idev->dev), net))\r\ncontinue;\r\nif (ipv6_addr_equal(&ifp->addr, addr)) {\r\nif (dev == NULL || ifp->idev->dev == dev ||\r\n!(ifp->scope&(IFA_LINK|IFA_HOST) || strict)) {\r\nresult = ifp;\r\nin6_ifa_hold(ifp);\r\nbreak;\r\n}\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nreturn result;\r\n}\r\nstatic void addrconf_dad_stop(struct inet6_ifaddr *ifp, int dad_failed)\r\n{\r\nif (ifp->flags&IFA_F_PERMANENT) {\r\nspin_lock_bh(&ifp->lock);\r\naddrconf_del_dad_work(ifp);\r\nifp->flags |= IFA_F_TENTATIVE;\r\nif (dad_failed)\r\nifp->flags |= IFA_F_DADFAILED;\r\nspin_unlock_bh(&ifp->lock);\r\nif (dad_failed)\r\nipv6_ifa_notify(0, ifp);\r\nin6_ifa_put(ifp);\r\n} else if (ifp->flags&IFA_F_TEMPORARY) {\r\nstruct inet6_ifaddr *ifpub;\r\nspin_lock_bh(&ifp->lock);\r\nifpub = ifp->ifpub;\r\nif (ifpub) {\r\nin6_ifa_hold(ifpub);\r\nspin_unlock_bh(&ifp->lock);\r\nipv6_create_tempaddr(ifpub, ifp);\r\nin6_ifa_put(ifpub);\r\n} else {\r\nspin_unlock_bh(&ifp->lock);\r\n}\r\nipv6_del_addr(ifp);\r\n} else {\r\nipv6_del_addr(ifp);\r\n}\r\n}\r\nstatic int addrconf_dad_end(struct inet6_ifaddr *ifp)\r\n{\r\nint err = -ENOENT;\r\nspin_lock_bh(&ifp->state_lock);\r\nif (ifp->state == INET6_IFADDR_STATE_DAD) {\r\nifp->state = INET6_IFADDR_STATE_POSTDAD;\r\nerr = 0;\r\n}\r\nspin_unlock_bh(&ifp->state_lock);\r\nreturn err;\r\n}\r\nvoid addrconf_dad_failure(struct inet6_ifaddr *ifp)\r\n{\r\nstruct inet6_dev *idev = ifp->idev;\r\nif (addrconf_dad_end(ifp)) {\r\nin6_ifa_put(ifp);\r\nreturn;\r\n}\r\nnet_info_ratelimited("%s: IPv6 duplicate address %pI6c detected!\n",\r\nifp->idev->dev->name, &ifp->addr);\r\nif (idev->cnf.accept_dad > 1 && !idev->cnf.disable_ipv6) {\r\nstruct in6_addr addr;\r\naddr.s6_addr32[0] = htonl(0xfe800000);\r\naddr.s6_addr32[1] = 0;\r\nif (!ipv6_generate_eui64(addr.s6_addr + 8, idev->dev) &&\r\nipv6_addr_equal(&ifp->addr, &addr)) {\r\nidev->cnf.disable_ipv6 = 1;\r\npr_info("%s: IPv6 being disabled!\n",\r\nifp->idev->dev->name);\r\n}\r\n}\r\nspin_lock_bh(&ifp->state_lock);\r\nifp->state = INET6_IFADDR_STATE_ERRDAD;\r\nspin_unlock_bh(&ifp->state_lock);\r\naddrconf_mod_dad_work(ifp, 0);\r\n}\r\nvoid addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr)\r\n{\r\nstruct in6_addr maddr;\r\nASSERT_RTNL();\r\nif (dev->flags&(IFF_LOOPBACK|IFF_NOARP))\r\nreturn;\r\naddrconf_addr_solict_mult(addr, &maddr);\r\nipv6_dev_mc_inc(dev, &maddr);\r\n}\r\nvoid addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr)\r\n{\r\nstruct in6_addr maddr;\r\nASSERT_RTNL();\r\nif (idev->dev->flags&(IFF_LOOPBACK|IFF_NOARP))\r\nreturn;\r\naddrconf_addr_solict_mult(addr, &maddr);\r\n__ipv6_dev_mc_dec(idev, &maddr);\r\n}\r\nstatic void addrconf_join_anycast(struct inet6_ifaddr *ifp)\r\n{\r\nstruct in6_addr addr;\r\nASSERT_RTNL();\r\nif (ifp->prefix_len >= 127)\r\nreturn;\r\nipv6_addr_prefix(&addr, &ifp->addr, ifp->prefix_len);\r\nif (ipv6_addr_any(&addr))\r\nreturn;\r\nipv6_dev_ac_inc(ifp->idev->dev, &addr);\r\n}\r\nstatic void addrconf_leave_anycast(struct inet6_ifaddr *ifp)\r\n{\r\nstruct in6_addr addr;\r\nASSERT_RTNL();\r\nif (ifp->prefix_len >= 127)\r\nreturn;\r\nipv6_addr_prefix(&addr, &ifp->addr, ifp->prefix_len);\r\nif (ipv6_addr_any(&addr))\r\nreturn;\r\n__ipv6_dev_ac_dec(ifp->idev, &addr);\r\n}\r\nstatic int addrconf_ifid_eui48(u8 *eui, struct net_device *dev)\r\n{\r\nif (dev->addr_len != ETH_ALEN)\r\nreturn -1;\r\nmemcpy(eui, dev->dev_addr, 3);\r\nmemcpy(eui + 5, dev->dev_addr + 3, 3);\r\nif (dev->dev_id) {\r\neui[3] = (dev->dev_id >> 8) & 0xFF;\r\neui[4] = dev->dev_id & 0xFF;\r\n} else {\r\neui[3] = 0xFF;\r\neui[4] = 0xFE;\r\neui[0] ^= 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int addrconf_ifid_eui64(u8 *eui, struct net_device *dev)\r\n{\r\nif (dev->addr_len != IEEE802154_ADDR_LEN)\r\nreturn -1;\r\nmemcpy(eui, dev->dev_addr, 8);\r\neui[0] ^= 2;\r\nreturn 0;\r\n}\r\nstatic int addrconf_ifid_ieee1394(u8 *eui, struct net_device *dev)\r\n{\r\nunion fwnet_hwaddr *ha;\r\nif (dev->addr_len != FWNET_ALEN)\r\nreturn -1;\r\nha = (union fwnet_hwaddr *)dev->dev_addr;\r\nmemcpy(eui, &ha->uc.uniq_id, sizeof(ha->uc.uniq_id));\r\neui[0] ^= 2;\r\nreturn 0;\r\n}\r\nstatic int addrconf_ifid_arcnet(u8 *eui, struct net_device *dev)\r\n{\r\nif (dev->addr_len != ARCNET_ALEN)\r\nreturn -1;\r\nmemset(eui, 0, 7);\r\neui[7] = *(u8 *)dev->dev_addr;\r\nreturn 0;\r\n}\r\nstatic int addrconf_ifid_infiniband(u8 *eui, struct net_device *dev)\r\n{\r\nif (dev->addr_len != INFINIBAND_ALEN)\r\nreturn -1;\r\nmemcpy(eui, dev->dev_addr + 12, 8);\r\neui[0] |= 2;\r\nreturn 0;\r\n}\r\nstatic int __ipv6_isatap_ifid(u8 *eui, __be32 addr)\r\n{\r\nif (addr == 0)\r\nreturn -1;\r\neui[0] = (ipv4_is_zeronet(addr) || ipv4_is_private_10(addr) ||\r\nipv4_is_loopback(addr) || ipv4_is_linklocal_169(addr) ||\r\nipv4_is_private_172(addr) || ipv4_is_test_192(addr) ||\r\nipv4_is_anycast_6to4(addr) || ipv4_is_private_192(addr) ||\r\nipv4_is_test_198(addr) || ipv4_is_multicast(addr) ||\r\nipv4_is_lbcast(addr)) ? 0x00 : 0x02;\r\neui[1] = 0;\r\neui[2] = 0x5E;\r\neui[3] = 0xFE;\r\nmemcpy(eui + 4, &addr, 4);\r\nreturn 0;\r\n}\r\nstatic int addrconf_ifid_sit(u8 *eui, struct net_device *dev)\r\n{\r\nif (dev->priv_flags & IFF_ISATAP)\r\nreturn __ipv6_isatap_ifid(eui, *(__be32 *)dev->dev_addr);\r\nreturn -1;\r\n}\r\nstatic int addrconf_ifid_gre(u8 *eui, struct net_device *dev)\r\n{\r\nreturn __ipv6_isatap_ifid(eui, *(__be32 *)dev->dev_addr);\r\n}\r\nstatic int addrconf_ifid_ip6tnl(u8 *eui, struct net_device *dev)\r\n{\r\nmemcpy(eui, dev->perm_addr, 3);\r\nmemcpy(eui + 5, dev->perm_addr + 3, 3);\r\neui[3] = 0xFF;\r\neui[4] = 0xFE;\r\neui[0] ^= 2;\r\nreturn 0;\r\n}\r\nstatic int ipv6_generate_eui64(u8 *eui, struct net_device *dev)\r\n{\r\nswitch (dev->type) {\r\ncase ARPHRD_ETHER:\r\ncase ARPHRD_FDDI:\r\nreturn addrconf_ifid_eui48(eui, dev);\r\ncase ARPHRD_ARCNET:\r\nreturn addrconf_ifid_arcnet(eui, dev);\r\ncase ARPHRD_INFINIBAND:\r\nreturn addrconf_ifid_infiniband(eui, dev);\r\ncase ARPHRD_SIT:\r\nreturn addrconf_ifid_sit(eui, dev);\r\ncase ARPHRD_IPGRE:\r\nreturn addrconf_ifid_gre(eui, dev);\r\ncase ARPHRD_6LOWPAN:\r\ncase ARPHRD_IEEE802154:\r\nreturn addrconf_ifid_eui64(eui, dev);\r\ncase ARPHRD_IEEE1394:\r\nreturn addrconf_ifid_ieee1394(eui, dev);\r\ncase ARPHRD_TUNNEL6:\r\nreturn addrconf_ifid_ip6tnl(eui, dev);\r\n}\r\nreturn -1;\r\n}\r\nstatic int ipv6_inherit_eui64(u8 *eui, struct inet6_dev *idev)\r\n{\r\nint err = -1;\r\nstruct inet6_ifaddr *ifp;\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry_reverse(ifp, &idev->addr_list, if_list) {\r\nif (ifp->scope > IFA_LINK)\r\nbreak;\r\nif (ifp->scope == IFA_LINK && !(ifp->flags&IFA_F_TENTATIVE)) {\r\nmemcpy(eui, ifp->addr.s6_addr+8, 8);\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nread_unlock_bh(&idev->lock);\r\nreturn err;\r\n}\r\nstatic void __ipv6_regen_rndid(struct inet6_dev *idev)\r\n{\r\nregen:\r\nget_random_bytes(idev->rndid, sizeof(idev->rndid));\r\nidev->rndid[0] &= ~0x02;\r\nif (idev->rndid[0] == 0xfd &&\r\n(idev->rndid[1]&idev->rndid[2]&idev->rndid[3]&idev->rndid[4]&idev->rndid[5]&idev->rndid[6]) == 0xff &&\r\n(idev->rndid[7]&0x80))\r\ngoto regen;\r\nif ((idev->rndid[0]|idev->rndid[1]) == 0) {\r\nif (idev->rndid[2] == 0x5e && idev->rndid[3] == 0xfe)\r\ngoto regen;\r\nif ((idev->rndid[2]|idev->rndid[3]|idev->rndid[4]|idev->rndid[5]|idev->rndid[6]|idev->rndid[7]) == 0x00)\r\ngoto regen;\r\n}\r\n}\r\nstatic void ipv6_regen_rndid(unsigned long data)\r\n{\r\nstruct inet6_dev *idev = (struct inet6_dev *) data;\r\nunsigned long expires;\r\nrcu_read_lock_bh();\r\nwrite_lock_bh(&idev->lock);\r\nif (idev->dead)\r\ngoto out;\r\n__ipv6_regen_rndid(idev);\r\nexpires = jiffies +\r\nidev->cnf.temp_prefered_lft * HZ -\r\nidev->cnf.regen_max_retry * idev->cnf.dad_transmits *\r\nNEIGH_VAR(idev->nd_parms, RETRANS_TIME) -\r\nidev->cnf.max_desync_factor * HZ;\r\nif (time_before(expires, jiffies)) {\r\npr_warn("%s: too short regeneration interval; timer disabled for %s\n",\r\n__func__, idev->dev->name);\r\ngoto out;\r\n}\r\nif (!mod_timer(&idev->regen_timer, expires))\r\nin6_dev_hold(idev);\r\nout:\r\nwrite_unlock_bh(&idev->lock);\r\nrcu_read_unlock_bh();\r\nin6_dev_put(idev);\r\n}\r\nstatic void __ipv6_try_regen_rndid(struct inet6_dev *idev, struct in6_addr *tmpaddr)\r\n{\r\nif (tmpaddr && memcmp(idev->rndid, &tmpaddr->s6_addr[8], 8) == 0)\r\n__ipv6_regen_rndid(idev);\r\n}\r\nstatic void\r\naddrconf_prefix_route(struct in6_addr *pfx, int plen, struct net_device *dev,\r\nunsigned long expires, u32 flags)\r\n{\r\nstruct fib6_config cfg = {\r\n.fc_table = RT6_TABLE_PREFIX,\r\n.fc_metric = IP6_RT_PRIO_ADDRCONF,\r\n.fc_ifindex = dev->ifindex,\r\n.fc_expires = expires,\r\n.fc_dst_len = plen,\r\n.fc_flags = RTF_UP | flags,\r\n.fc_nlinfo.nl_net = dev_net(dev),\r\n.fc_protocol = RTPROT_KERNEL,\r\n};\r\ncfg.fc_dst = *pfx;\r\n#if IS_ENABLED(CONFIG_IPV6_SIT)\r\nif (dev->type == ARPHRD_SIT && (dev->flags & IFF_POINTOPOINT))\r\ncfg.fc_flags |= RTF_NONEXTHOP;\r\n#endif\r\nip6_route_add(&cfg);\r\n}\r\nstatic struct rt6_info *addrconf_get_prefix_route(const struct in6_addr *pfx,\r\nint plen,\r\nconst struct net_device *dev,\r\nu32 flags, u32 noflags)\r\n{\r\nstruct fib6_node *fn;\r\nstruct rt6_info *rt = NULL;\r\nstruct fib6_table *table;\r\ntable = fib6_get_table(dev_net(dev), RT6_TABLE_PREFIX);\r\nif (table == NULL)\r\nreturn NULL;\r\nread_lock_bh(&table->tb6_lock);\r\nfn = fib6_locate(&table->tb6_root, pfx, plen, NULL, 0);\r\nif (!fn)\r\ngoto out;\r\nfor (rt = fn->leaf; rt; rt = rt->dst.rt6_next) {\r\nif (rt->dst.dev->ifindex != dev->ifindex)\r\ncontinue;\r\nif ((rt->rt6i_flags & flags) != flags)\r\ncontinue;\r\nif ((rt->rt6i_flags & noflags) != 0)\r\ncontinue;\r\ndst_hold(&rt->dst);\r\nbreak;\r\n}\r\nout:\r\nread_unlock_bh(&table->tb6_lock);\r\nreturn rt;\r\n}\r\nstatic void addrconf_add_mroute(struct net_device *dev)\r\n{\r\nstruct fib6_config cfg = {\r\n.fc_table = RT6_TABLE_LOCAL,\r\n.fc_metric = IP6_RT_PRIO_ADDRCONF,\r\n.fc_ifindex = dev->ifindex,\r\n.fc_dst_len = 8,\r\n.fc_flags = RTF_UP,\r\n.fc_nlinfo.nl_net = dev_net(dev),\r\n};\r\nipv6_addr_set(&cfg.fc_dst, htonl(0xFF000000), 0, 0, 0);\r\nip6_route_add(&cfg);\r\n}\r\nstatic struct inet6_dev *addrconf_add_dev(struct net_device *dev)\r\n{\r\nstruct inet6_dev *idev;\r\nASSERT_RTNL();\r\nidev = ipv6_find_idev(dev);\r\nif (!idev)\r\nreturn ERR_PTR(-ENOBUFS);\r\nif (idev->cnf.disable_ipv6)\r\nreturn ERR_PTR(-EACCES);\r\nif (!(dev->flags & IFF_LOOPBACK))\r\naddrconf_add_mroute(dev);\r\nreturn idev;\r\n}\r\nstatic void manage_tempaddrs(struct inet6_dev *idev,\r\nstruct inet6_ifaddr *ifp,\r\n__u32 valid_lft, __u32 prefered_lft,\r\nbool create, unsigned long now)\r\n{\r\nu32 flags;\r\nstruct inet6_ifaddr *ift;\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry(ift, &idev->tempaddr_list, tmp_list) {\r\nint age, max_valid, max_prefered;\r\nif (ifp != ift->ifpub)\r\ncontinue;\r\nage = (now - ift->cstamp) / HZ;\r\nmax_valid = idev->cnf.temp_valid_lft - age;\r\nif (max_valid < 0)\r\nmax_valid = 0;\r\nmax_prefered = idev->cnf.temp_prefered_lft -\r\nidev->cnf.max_desync_factor - age;\r\nif (max_prefered < 0)\r\nmax_prefered = 0;\r\nif (valid_lft > max_valid)\r\nvalid_lft = max_valid;\r\nif (prefered_lft > max_prefered)\r\nprefered_lft = max_prefered;\r\nspin_lock(&ift->lock);\r\nflags = ift->flags;\r\nift->valid_lft = valid_lft;\r\nift->prefered_lft = prefered_lft;\r\nift->tstamp = now;\r\nif (prefered_lft > 0)\r\nift->flags &= ~IFA_F_DEPRECATED;\r\nspin_unlock(&ift->lock);\r\nif (!(flags&IFA_F_TENTATIVE))\r\nipv6_ifa_notify(0, ift);\r\n}\r\nif ((create || list_empty(&idev->tempaddr_list)) &&\r\nidev->cnf.use_tempaddr > 0) {\r\nread_unlock_bh(&idev->lock);\r\nipv6_create_tempaddr(ifp, NULL);\r\n} else {\r\nread_unlock_bh(&idev->lock);\r\n}\r\n}\r\nvoid addrconf_prefix_rcv(struct net_device *dev, u8 *opt, int len, bool sllao)\r\n{\r\nstruct prefix_info *pinfo;\r\n__u32 valid_lft;\r\n__u32 prefered_lft;\r\nint addr_type;\r\nstruct inet6_dev *in6_dev;\r\nstruct net *net = dev_net(dev);\r\npinfo = (struct prefix_info *) opt;\r\nif (len < sizeof(struct prefix_info)) {\r\nADBG("addrconf: prefix option too short\n");\r\nreturn;\r\n}\r\naddr_type = ipv6_addr_type(&pinfo->prefix);\r\nif (addr_type & (IPV6_ADDR_MULTICAST|IPV6_ADDR_LINKLOCAL))\r\nreturn;\r\nvalid_lft = ntohl(pinfo->valid);\r\nprefered_lft = ntohl(pinfo->prefered);\r\nif (prefered_lft > valid_lft) {\r\nnet_warn_ratelimited("addrconf: prefix option has invalid lifetime\n");\r\nreturn;\r\n}\r\nin6_dev = in6_dev_get(dev);\r\nif (in6_dev == NULL) {\r\nnet_dbg_ratelimited("addrconf: device %s not configured\n",\r\ndev->name);\r\nreturn;\r\n}\r\nif (pinfo->onlink) {\r\nstruct rt6_info *rt;\r\nunsigned long rt_expires;\r\nif (HZ > USER_HZ)\r\nrt_expires = addrconf_timeout_fixup(valid_lft, HZ);\r\nelse\r\nrt_expires = addrconf_timeout_fixup(valid_lft, USER_HZ);\r\nif (addrconf_finite_timeout(rt_expires))\r\nrt_expires *= HZ;\r\nrt = addrconf_get_prefix_route(&pinfo->prefix,\r\npinfo->prefix_len,\r\ndev,\r\nRTF_ADDRCONF | RTF_PREFIX_RT,\r\nRTF_GATEWAY | RTF_DEFAULT);\r\nif (rt) {\r\nif (valid_lft == 0) {\r\nip6_del_rt(rt);\r\nrt = NULL;\r\n} else if (addrconf_finite_timeout(rt_expires)) {\r\nrt6_set_expires(rt, jiffies + rt_expires);\r\n} else {\r\nrt6_clean_expires(rt);\r\n}\r\n} else if (valid_lft) {\r\nclock_t expires = 0;\r\nint flags = RTF_ADDRCONF | RTF_PREFIX_RT;\r\nif (addrconf_finite_timeout(rt_expires)) {\r\nflags |= RTF_EXPIRES;\r\nexpires = jiffies_to_clock_t(rt_expires);\r\n}\r\naddrconf_prefix_route(&pinfo->prefix, pinfo->prefix_len,\r\ndev, expires, flags);\r\n}\r\nip6_rt_put(rt);\r\n}\r\nif (pinfo->autoconf && in6_dev->cnf.autoconf) {\r\nstruct inet6_ifaddr *ifp;\r\nstruct in6_addr addr;\r\nint create = 0, update_lft = 0;\r\nbool tokenized = false;\r\nif (pinfo->prefix_len == 64) {\r\nmemcpy(&addr, &pinfo->prefix, 8);\r\nif (!ipv6_addr_any(&in6_dev->token)) {\r\nread_lock_bh(&in6_dev->lock);\r\nmemcpy(addr.s6_addr + 8,\r\nin6_dev->token.s6_addr + 8, 8);\r\nread_unlock_bh(&in6_dev->lock);\r\ntokenized = true;\r\n} else if (ipv6_generate_eui64(addr.s6_addr + 8, dev) &&\r\nipv6_inherit_eui64(addr.s6_addr + 8, in6_dev)) {\r\nin6_dev_put(in6_dev);\r\nreturn;\r\n}\r\ngoto ok;\r\n}\r\nnet_dbg_ratelimited("IPv6 addrconf: prefix with wrong length %d\n",\r\npinfo->prefix_len);\r\nin6_dev_put(in6_dev);\r\nreturn;\r\nok:\r\nifp = ipv6_get_ifaddr(net, &addr, dev, 1);\r\nif (ifp == NULL && valid_lft) {\r\nint max_addresses = in6_dev->cnf.max_addresses;\r\nu32 addr_flags = 0;\r\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\r\nif (in6_dev->cnf.optimistic_dad &&\r\n!net->ipv6.devconf_all->forwarding && sllao)\r\naddr_flags = IFA_F_OPTIMISTIC;\r\n#endif\r\nif (!max_addresses ||\r\nipv6_count_addresses(in6_dev) < max_addresses)\r\nifp = ipv6_add_addr(in6_dev, &addr, NULL,\r\npinfo->prefix_len,\r\naddr_type&IPV6_ADDR_SCOPE_MASK,\r\naddr_flags, valid_lft,\r\nprefered_lft);\r\nif (IS_ERR_OR_NULL(ifp)) {\r\nin6_dev_put(in6_dev);\r\nreturn;\r\n}\r\nupdate_lft = 0;\r\ncreate = 1;\r\nspin_lock_bh(&ifp->lock);\r\nifp->flags |= IFA_F_MANAGETEMPADDR;\r\nifp->cstamp = jiffies;\r\nifp->tokenized = tokenized;\r\nspin_unlock_bh(&ifp->lock);\r\naddrconf_dad_start(ifp);\r\n}\r\nif (ifp) {\r\nu32 flags;\r\nunsigned long now;\r\nu32 stored_lft;\r\nspin_lock(&ifp->lock);\r\nnow = jiffies;\r\nif (ifp->valid_lft > (now - ifp->tstamp) / HZ)\r\nstored_lft = ifp->valid_lft - (now - ifp->tstamp) / HZ;\r\nelse\r\nstored_lft = 0;\r\nif (!update_lft && !create && stored_lft) {\r\nconst u32 minimum_lft = min(\r\nstored_lft, (u32)MIN_VALID_LIFETIME);\r\nvalid_lft = max(valid_lft, minimum_lft);\r\nupdate_lft = 1;\r\n}\r\nif (update_lft) {\r\nifp->valid_lft = valid_lft;\r\nifp->prefered_lft = prefered_lft;\r\nifp->tstamp = now;\r\nflags = ifp->flags;\r\nifp->flags &= ~IFA_F_DEPRECATED;\r\nspin_unlock(&ifp->lock);\r\nif (!(flags&IFA_F_TENTATIVE))\r\nipv6_ifa_notify(0, ifp);\r\n} else\r\nspin_unlock(&ifp->lock);\r\nmanage_tempaddrs(in6_dev, ifp, valid_lft, prefered_lft,\r\ncreate, now);\r\nin6_ifa_put(ifp);\r\naddrconf_verify();\r\n}\r\n}\r\ninet6_prefix_notify(RTM_NEWPREFIX, in6_dev, pinfo);\r\nin6_dev_put(in6_dev);\r\n}\r\nint addrconf_set_dstaddr(struct net *net, void __user *arg)\r\n{\r\nstruct in6_ifreq ireq;\r\nstruct net_device *dev;\r\nint err = -EINVAL;\r\nrtnl_lock();\r\nerr = -EFAULT;\r\nif (copy_from_user(&ireq, arg, sizeof(struct in6_ifreq)))\r\ngoto err_exit;\r\ndev = __dev_get_by_index(net, ireq.ifr6_ifindex);\r\nerr = -ENODEV;\r\nif (dev == NULL)\r\ngoto err_exit;\r\n#if IS_ENABLED(CONFIG_IPV6_SIT)\r\nif (dev->type == ARPHRD_SIT) {\r\nconst struct net_device_ops *ops = dev->netdev_ops;\r\nstruct ifreq ifr;\r\nstruct ip_tunnel_parm p;\r\nerr = -EADDRNOTAVAIL;\r\nif (!(ipv6_addr_type(&ireq.ifr6_addr) & IPV6_ADDR_COMPATv4))\r\ngoto err_exit;\r\nmemset(&p, 0, sizeof(p));\r\np.iph.daddr = ireq.ifr6_addr.s6_addr32[3];\r\np.iph.saddr = 0;\r\np.iph.version = 4;\r\np.iph.ihl = 5;\r\np.iph.protocol = IPPROTO_IPV6;\r\np.iph.ttl = 64;\r\nifr.ifr_ifru.ifru_data = (__force void __user *)&p;\r\nif (ops->ndo_do_ioctl) {\r\nmm_segment_t oldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nerr = ops->ndo_do_ioctl(dev, &ifr, SIOCADDTUNNEL);\r\nset_fs(oldfs);\r\n} else\r\nerr = -EOPNOTSUPP;\r\nif (err == 0) {\r\nerr = -ENOBUFS;\r\ndev = __dev_get_by_name(net, p.name);\r\nif (!dev)\r\ngoto err_exit;\r\nerr = dev_open(dev);\r\n}\r\n}\r\n#endif\r\nerr_exit:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic int inet6_addr_add(struct net *net, int ifindex,\r\nconst struct in6_addr *pfx,\r\nconst struct in6_addr *peer_pfx,\r\nunsigned int plen, __u32 ifa_flags,\r\n__u32 prefered_lft, __u32 valid_lft)\r\n{\r\nstruct inet6_ifaddr *ifp;\r\nstruct inet6_dev *idev;\r\nstruct net_device *dev;\r\nint scope;\r\nu32 flags;\r\nclock_t expires;\r\nunsigned long timeout;\r\nASSERT_RTNL();\r\nif (plen > 128)\r\nreturn -EINVAL;\r\nif (!valid_lft || prefered_lft > valid_lft)\r\nreturn -EINVAL;\r\nif (ifa_flags & IFA_F_MANAGETEMPADDR && plen != 64)\r\nreturn -EINVAL;\r\ndev = __dev_get_by_index(net, ifindex);\r\nif (!dev)\r\nreturn -ENODEV;\r\nidev = addrconf_add_dev(dev);\r\nif (IS_ERR(idev))\r\nreturn PTR_ERR(idev);\r\nscope = ipv6_addr_scope(pfx);\r\ntimeout = addrconf_timeout_fixup(valid_lft, HZ);\r\nif (addrconf_finite_timeout(timeout)) {\r\nexpires = jiffies_to_clock_t(timeout * HZ);\r\nvalid_lft = timeout;\r\nflags = RTF_EXPIRES;\r\n} else {\r\nexpires = 0;\r\nflags = 0;\r\nifa_flags |= IFA_F_PERMANENT;\r\n}\r\ntimeout = addrconf_timeout_fixup(prefered_lft, HZ);\r\nif (addrconf_finite_timeout(timeout)) {\r\nif (timeout == 0)\r\nifa_flags |= IFA_F_DEPRECATED;\r\nprefered_lft = timeout;\r\n}\r\nifp = ipv6_add_addr(idev, pfx, peer_pfx, plen, scope, ifa_flags,\r\nvalid_lft, prefered_lft);\r\nif (!IS_ERR(ifp)) {\r\nif (!(ifa_flags & IFA_F_NOPREFIXROUTE)) {\r\naddrconf_prefix_route(&ifp->addr, ifp->prefix_len, dev,\r\nexpires, flags);\r\n}\r\naddrconf_dad_start(ifp);\r\nif (ifa_flags & IFA_F_MANAGETEMPADDR)\r\nmanage_tempaddrs(idev, ifp, valid_lft, prefered_lft,\r\ntrue, jiffies);\r\nin6_ifa_put(ifp);\r\naddrconf_verify_rtnl();\r\nreturn 0;\r\n}\r\nreturn PTR_ERR(ifp);\r\n}\r\nstatic int inet6_addr_del(struct net *net, int ifindex, const struct in6_addr *pfx,\r\nunsigned int plen)\r\n{\r\nstruct inet6_ifaddr *ifp;\r\nstruct inet6_dev *idev;\r\nstruct net_device *dev;\r\nif (plen > 128)\r\nreturn -EINVAL;\r\ndev = __dev_get_by_index(net, ifindex);\r\nif (!dev)\r\nreturn -ENODEV;\r\nif ((idev = __in6_dev_get(dev)) == NULL)\r\nreturn -ENXIO;\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry(ifp, &idev->addr_list, if_list) {\r\nif (ifp->prefix_len == plen &&\r\nipv6_addr_equal(pfx, &ifp->addr)) {\r\nin6_ifa_hold(ifp);\r\nread_unlock_bh(&idev->lock);\r\nipv6_del_addr(ifp);\r\nreturn 0;\r\n}\r\n}\r\nread_unlock_bh(&idev->lock);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nint addrconf_add_ifaddr(struct net *net, void __user *arg)\r\n{\r\nstruct in6_ifreq ireq;\r\nint err;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&ireq, arg, sizeof(struct in6_ifreq)))\r\nreturn -EFAULT;\r\nrtnl_lock();\r\nerr = inet6_addr_add(net, ireq.ifr6_ifindex, &ireq.ifr6_addr, NULL,\r\nireq.ifr6_prefixlen, IFA_F_PERMANENT,\r\nINFINITY_LIFE_TIME, INFINITY_LIFE_TIME);\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nint addrconf_del_ifaddr(struct net *net, void __user *arg)\r\n{\r\nstruct in6_ifreq ireq;\r\nint err;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&ireq, arg, sizeof(struct in6_ifreq)))\r\nreturn -EFAULT;\r\nrtnl_lock();\r\nerr = inet6_addr_del(net, ireq.ifr6_ifindex, &ireq.ifr6_addr,\r\nireq.ifr6_prefixlen);\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic void add_addr(struct inet6_dev *idev, const struct in6_addr *addr,\r\nint plen, int scope)\r\n{\r\nstruct inet6_ifaddr *ifp;\r\nifp = ipv6_add_addr(idev, addr, NULL, plen,\r\nscope, IFA_F_PERMANENT,\r\nINFINITY_LIFE_TIME, INFINITY_LIFE_TIME);\r\nif (!IS_ERR(ifp)) {\r\nspin_lock_bh(&ifp->lock);\r\nifp->flags &= ~IFA_F_TENTATIVE;\r\nspin_unlock_bh(&ifp->lock);\r\nipv6_ifa_notify(RTM_NEWADDR, ifp);\r\nin6_ifa_put(ifp);\r\n}\r\n}\r\nstatic void sit_add_v4_addrs(struct inet6_dev *idev)\r\n{\r\nstruct in6_addr addr;\r\nstruct net_device *dev;\r\nstruct net *net = dev_net(idev->dev);\r\nint scope, plen;\r\nu32 pflags = 0;\r\nASSERT_RTNL();\r\nmemset(&addr, 0, sizeof(struct in6_addr));\r\nmemcpy(&addr.s6_addr32[3], idev->dev->dev_addr, 4);\r\nif (idev->dev->flags&IFF_POINTOPOINT) {\r\naddr.s6_addr32[0] = htonl(0xfe800000);\r\nscope = IFA_LINK;\r\nplen = 64;\r\n} else {\r\nscope = IPV6_ADDR_COMPATv4;\r\nplen = 96;\r\npflags |= RTF_NONEXTHOP;\r\n}\r\nif (addr.s6_addr32[3]) {\r\nadd_addr(idev, &addr, plen, scope);\r\naddrconf_prefix_route(&addr, plen, idev->dev, 0, pflags);\r\nreturn;\r\n}\r\nfor_each_netdev(net, dev) {\r\nstruct in_device *in_dev = __in_dev_get_rtnl(dev);\r\nif (in_dev && (dev->flags & IFF_UP)) {\r\nstruct in_ifaddr *ifa;\r\nint flag = scope;\r\nfor (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next) {\r\naddr.s6_addr32[3] = ifa->ifa_local;\r\nif (ifa->ifa_scope == RT_SCOPE_LINK)\r\ncontinue;\r\nif (ifa->ifa_scope >= RT_SCOPE_HOST) {\r\nif (idev->dev->flags&IFF_POINTOPOINT)\r\ncontinue;\r\nflag |= IFA_HOST;\r\n}\r\nadd_addr(idev, &addr, plen, flag);\r\naddrconf_prefix_route(&addr, plen, idev->dev, 0,\r\npflags);\r\n}\r\n}\r\n}\r\n}\r\nstatic void init_loopback(struct net_device *dev)\r\n{\r\nstruct inet6_dev *idev;\r\nstruct net_device *sp_dev;\r\nstruct inet6_ifaddr *sp_ifa;\r\nstruct rt6_info *sp_rt;\r\nASSERT_RTNL();\r\nif ((idev = ipv6_find_idev(dev)) == NULL) {\r\npr_debug("%s: add_dev failed\n", __func__);\r\nreturn;\r\n}\r\nadd_addr(idev, &in6addr_loopback, 128, IFA_HOST);\r\nfor_each_netdev(dev_net(dev), sp_dev) {\r\nif (!strcmp(sp_dev->name, dev->name))\r\ncontinue;\r\nidev = __in6_dev_get(sp_dev);\r\nif (!idev)\r\ncontinue;\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry(sp_ifa, &idev->addr_list, if_list) {\r\nif (sp_ifa->flags & (IFA_F_DADFAILED | IFA_F_TENTATIVE))\r\ncontinue;\r\nif (sp_ifa->rt) {\r\nif (sp_ifa->rt->dst.obsolete > 0) {\r\nip6_rt_put(sp_ifa->rt);\r\nsp_ifa->rt = NULL;\r\n} else {\r\ncontinue;\r\n}\r\n}\r\nsp_rt = addrconf_dst_alloc(idev, &sp_ifa->addr, false);\r\nif (!IS_ERR(sp_rt)) {\r\nsp_ifa->rt = sp_rt;\r\nip6_ins_rt(sp_rt);\r\n}\r\n}\r\nread_unlock_bh(&idev->lock);\r\n}\r\n}\r\nstatic void addrconf_add_linklocal(struct inet6_dev *idev, const struct in6_addr *addr)\r\n{\r\nstruct inet6_ifaddr *ifp;\r\nu32 addr_flags = IFA_F_PERMANENT;\r\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\r\nif (idev->cnf.optimistic_dad &&\r\n!dev_net(idev->dev)->ipv6.devconf_all->forwarding)\r\naddr_flags |= IFA_F_OPTIMISTIC;\r\n#endif\r\nifp = ipv6_add_addr(idev, addr, NULL, 64, IFA_LINK, addr_flags,\r\nINFINITY_LIFE_TIME, INFINITY_LIFE_TIME);\r\nif (!IS_ERR(ifp)) {\r\naddrconf_prefix_route(&ifp->addr, ifp->prefix_len, idev->dev, 0, 0);\r\naddrconf_dad_start(ifp);\r\nin6_ifa_put(ifp);\r\n}\r\n}\r\nstatic void addrconf_dev_config(struct net_device *dev)\r\n{\r\nstruct in6_addr addr;\r\nstruct inet6_dev *idev;\r\nASSERT_RTNL();\r\nif ((dev->type != ARPHRD_ETHER) &&\r\n(dev->type != ARPHRD_FDDI) &&\r\n(dev->type != ARPHRD_ARCNET) &&\r\n(dev->type != ARPHRD_INFINIBAND) &&\r\n(dev->type != ARPHRD_IEEE802154) &&\r\n(dev->type != ARPHRD_IEEE1394) &&\r\n(dev->type != ARPHRD_TUNNEL6) &&\r\n(dev->type != ARPHRD_6LOWPAN)) {\r\nreturn;\r\n}\r\nidev = addrconf_add_dev(dev);\r\nif (IS_ERR(idev))\r\nreturn;\r\nmemset(&addr, 0, sizeof(struct in6_addr));\r\naddr.s6_addr32[0] = htonl(0xFE800000);\r\nif (ipv6_generate_eui64(addr.s6_addr + 8, dev) == 0)\r\naddrconf_add_linklocal(idev, &addr);\r\n}\r\nstatic void addrconf_sit_config(struct net_device *dev)\r\n{\r\nstruct inet6_dev *idev;\r\nASSERT_RTNL();\r\nif ((idev = ipv6_find_idev(dev)) == NULL) {\r\npr_debug("%s: add_dev failed\n", __func__);\r\nreturn;\r\n}\r\nif (dev->priv_flags & IFF_ISATAP) {\r\nstruct in6_addr addr;\r\nipv6_addr_set(&addr, htonl(0xFE800000), 0, 0, 0);\r\nif (!ipv6_generate_eui64(addr.s6_addr + 8, dev))\r\naddrconf_add_linklocal(idev, &addr);\r\nreturn;\r\n}\r\nsit_add_v4_addrs(idev);\r\nif (dev->flags&IFF_POINTOPOINT)\r\naddrconf_add_mroute(dev);\r\n}\r\nstatic void addrconf_gre_config(struct net_device *dev)\r\n{\r\nstruct inet6_dev *idev;\r\nstruct in6_addr addr;\r\nASSERT_RTNL();\r\nif ((idev = ipv6_find_idev(dev)) == NULL) {\r\npr_debug("%s: add_dev failed\n", __func__);\r\nreturn;\r\n}\r\nipv6_addr_set(&addr, htonl(0xFE800000), 0, 0, 0);\r\nif (!ipv6_generate_eui64(addr.s6_addr + 8, dev))\r\naddrconf_add_linklocal(idev, &addr);\r\nelse\r\naddrconf_prefix_route(&addr, 64, dev, 0, 0);\r\n}\r\nstatic inline int\r\nipv6_inherit_linklocal(struct inet6_dev *idev, struct net_device *link_dev)\r\n{\r\nstruct in6_addr lladdr;\r\nif (!ipv6_get_lladdr(link_dev, &lladdr, IFA_F_TENTATIVE)) {\r\naddrconf_add_linklocal(idev, &lladdr);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int addrconf_notify(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct inet6_dev *idev = __in6_dev_get(dev);\r\nint run_pending = 0;\r\nint err;\r\nswitch (event) {\r\ncase NETDEV_REGISTER:\r\nif (!idev && dev->mtu >= IPV6_MIN_MTU) {\r\nidev = ipv6_add_dev(dev);\r\nif (!idev)\r\nreturn notifier_from_errno(-ENOMEM);\r\n}\r\nbreak;\r\ncase NETDEV_UP:\r\ncase NETDEV_CHANGE:\r\nif (dev->flags & IFF_SLAVE)\r\nbreak;\r\nif (event == NETDEV_UP) {\r\nif (!addrconf_qdisc_ok(dev)) {\r\npr_info("ADDRCONF(NETDEV_UP): %s: link is not ready\n",\r\ndev->name);\r\nbreak;\r\n}\r\nif (!idev && dev->mtu >= IPV6_MIN_MTU)\r\nidev = ipv6_add_dev(dev);\r\nif (idev) {\r\nidev->if_flags |= IF_READY;\r\nrun_pending = 1;\r\n}\r\n} else {\r\nif (!addrconf_qdisc_ok(dev)) {\r\nbreak;\r\n}\r\nif (idev) {\r\nif (idev->if_flags & IF_READY)\r\nbreak;\r\nidev->if_flags |= IF_READY;\r\n}\r\npr_info("ADDRCONF(NETDEV_CHANGE): %s: link becomes ready\n",\r\ndev->name);\r\nrun_pending = 1;\r\n}\r\nswitch (dev->type) {\r\n#if IS_ENABLED(CONFIG_IPV6_SIT)\r\ncase ARPHRD_SIT:\r\naddrconf_sit_config(dev);\r\nbreak;\r\n#endif\r\n#if IS_ENABLED(CONFIG_NET_IPGRE)\r\ncase ARPHRD_IPGRE:\r\naddrconf_gre_config(dev);\r\nbreak;\r\n#endif\r\ncase ARPHRD_LOOPBACK:\r\ninit_loopback(dev);\r\nbreak;\r\ndefault:\r\naddrconf_dev_config(dev);\r\nbreak;\r\n}\r\nif (idev) {\r\nif (run_pending)\r\naddrconf_dad_run(idev);\r\nif (idev->cnf.mtu6 != dev->mtu &&\r\ndev->mtu >= IPV6_MIN_MTU) {\r\nrt6_mtu_change(dev, dev->mtu);\r\nidev->cnf.mtu6 = dev->mtu;\r\n}\r\nidev->tstamp = jiffies;\r\ninet6_ifinfo_notify(RTM_NEWLINK, idev);\r\nif (dev->mtu < IPV6_MIN_MTU)\r\naddrconf_ifdown(dev, 1);\r\n}\r\nbreak;\r\ncase NETDEV_CHANGEMTU:\r\nif (idev && dev->mtu >= IPV6_MIN_MTU) {\r\nrt6_mtu_change(dev, dev->mtu);\r\nidev->cnf.mtu6 = dev->mtu;\r\nbreak;\r\n}\r\nif (!idev && dev->mtu >= IPV6_MIN_MTU) {\r\nidev = ipv6_add_dev(dev);\r\nif (idev)\r\nbreak;\r\n}\r\ncase NETDEV_DOWN:\r\ncase NETDEV_UNREGISTER:\r\naddrconf_ifdown(dev, event != NETDEV_DOWN);\r\nbreak;\r\ncase NETDEV_CHANGENAME:\r\nif (idev) {\r\nsnmp6_unregister_dev(idev);\r\naddrconf_sysctl_unregister(idev);\r\naddrconf_sysctl_register(idev);\r\nerr = snmp6_register_dev(idev);\r\nif (err)\r\nreturn notifier_from_errno(err);\r\n}\r\nbreak;\r\ncase NETDEV_PRE_TYPE_CHANGE:\r\ncase NETDEV_POST_TYPE_CHANGE:\r\naddrconf_type_change(dev, event);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void addrconf_type_change(struct net_device *dev, unsigned long event)\r\n{\r\nstruct inet6_dev *idev;\r\nASSERT_RTNL();\r\nidev = __in6_dev_get(dev);\r\nif (event == NETDEV_POST_TYPE_CHANGE)\r\nipv6_mc_remap(idev);\r\nelse if (event == NETDEV_PRE_TYPE_CHANGE)\r\nipv6_mc_unmap(idev);\r\n}\r\nstatic int addrconf_ifdown(struct net_device *dev, int how)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct inet6_dev *idev;\r\nstruct inet6_ifaddr *ifa;\r\nint state, i;\r\nASSERT_RTNL();\r\nrt6_ifdown(net, dev);\r\nneigh_ifdown(&nd_tbl, dev);\r\nidev = __in6_dev_get(dev);\r\nif (idev == NULL)\r\nreturn -ENODEV;\r\nif (how) {\r\nidev->dead = 1;\r\nRCU_INIT_POINTER(dev->ip6_ptr, NULL);\r\nsnmp6_unregister_dev(idev);\r\n}\r\nfor (i = 0; i < IN6_ADDR_HSIZE; i++) {\r\nstruct hlist_head *h = &inet6_addr_lst[i];\r\nspin_lock_bh(&addrconf_hash_lock);\r\nrestart:\r\nhlist_for_each_entry_rcu(ifa, h, addr_lst) {\r\nif (ifa->idev == idev) {\r\nhlist_del_init_rcu(&ifa->addr_lst);\r\naddrconf_del_dad_work(ifa);\r\ngoto restart;\r\n}\r\n}\r\nspin_unlock_bh(&addrconf_hash_lock);\r\n}\r\nwrite_lock_bh(&idev->lock);\r\naddrconf_del_rs_timer(idev);\r\nif (!how)\r\nidev->if_flags &= ~(IF_RS_SENT|IF_RA_RCVD|IF_READY);\r\nif (how && del_timer(&idev->regen_timer))\r\nin6_dev_put(idev);\r\nwhile (!list_empty(&idev->tempaddr_list)) {\r\nifa = list_first_entry(&idev->tempaddr_list,\r\nstruct inet6_ifaddr, tmp_list);\r\nlist_del(&ifa->tmp_list);\r\nwrite_unlock_bh(&idev->lock);\r\nspin_lock_bh(&ifa->lock);\r\nif (ifa->ifpub) {\r\nin6_ifa_put(ifa->ifpub);\r\nifa->ifpub = NULL;\r\n}\r\nspin_unlock_bh(&ifa->lock);\r\nin6_ifa_put(ifa);\r\nwrite_lock_bh(&idev->lock);\r\n}\r\nwhile (!list_empty(&idev->addr_list)) {\r\nifa = list_first_entry(&idev->addr_list,\r\nstruct inet6_ifaddr, if_list);\r\naddrconf_del_dad_work(ifa);\r\nlist_del(&ifa->if_list);\r\nwrite_unlock_bh(&idev->lock);\r\nspin_lock_bh(&ifa->state_lock);\r\nstate = ifa->state;\r\nifa->state = INET6_IFADDR_STATE_DEAD;\r\nspin_unlock_bh(&ifa->state_lock);\r\nif (state != INET6_IFADDR_STATE_DEAD) {\r\n__ipv6_ifa_notify(RTM_DELADDR, ifa);\r\ninet6addr_notifier_call_chain(NETDEV_DOWN, ifa);\r\n}\r\nin6_ifa_put(ifa);\r\nwrite_lock_bh(&idev->lock);\r\n}\r\nwrite_unlock_bh(&idev->lock);\r\nif (how)\r\nipv6_mc_destroy_dev(idev);\r\nelse\r\nipv6_mc_down(idev);\r\nidev->tstamp = jiffies;\r\nif (how) {\r\naddrconf_sysctl_unregister(idev);\r\nneigh_parms_release(&nd_tbl, idev->nd_parms);\r\nneigh_ifdown(&nd_tbl, dev);\r\nin6_dev_put(idev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void addrconf_rs_timer(unsigned long data)\r\n{\r\nstruct inet6_dev *idev = (struct inet6_dev *)data;\r\nstruct net_device *dev = idev->dev;\r\nstruct in6_addr lladdr;\r\nwrite_lock(&idev->lock);\r\nif (idev->dead || !(idev->if_flags & IF_READY))\r\ngoto out;\r\nif (!ipv6_accept_ra(idev))\r\ngoto out;\r\nif (idev->if_flags & IF_RA_RCVD)\r\ngoto out;\r\nif (idev->rs_probes++ < idev->cnf.rtr_solicits) {\r\nwrite_unlock(&idev->lock);\r\nif (!ipv6_get_lladdr(dev, &lladdr, IFA_F_TENTATIVE))\r\nndisc_send_rs(dev, &lladdr,\r\n&in6addr_linklocal_allrouters);\r\nelse\r\ngoto put;\r\nwrite_lock(&idev->lock);\r\naddrconf_mod_rs_timer(idev, (idev->rs_probes ==\r\nidev->cnf.rtr_solicits) ?\r\nidev->cnf.rtr_solicit_delay :\r\nidev->cnf.rtr_solicit_interval);\r\n} else {\r\npr_debug("%s: no IPv6 routers present\n", idev->dev->name);\r\n}\r\nout:\r\nwrite_unlock(&idev->lock);\r\nput:\r\nin6_dev_put(idev);\r\n}\r\nstatic void addrconf_dad_kick(struct inet6_ifaddr *ifp)\r\n{\r\nunsigned long rand_num;\r\nstruct inet6_dev *idev = ifp->idev;\r\nif (ifp->flags & IFA_F_OPTIMISTIC)\r\nrand_num = 0;\r\nelse\r\nrand_num = prandom_u32() % (idev->cnf.rtr_solicit_delay ? : 1);\r\nifp->dad_probes = idev->cnf.dad_transmits;\r\naddrconf_mod_dad_work(ifp, rand_num);\r\n}\r\nstatic void addrconf_dad_begin(struct inet6_ifaddr *ifp)\r\n{\r\nstruct inet6_dev *idev = ifp->idev;\r\nstruct net_device *dev = idev->dev;\r\naddrconf_join_solict(dev, &ifp->addr);\r\nprandom_seed((__force u32) ifp->addr.s6_addr32[3]);\r\nread_lock_bh(&idev->lock);\r\nspin_lock(&ifp->lock);\r\nif (ifp->state == INET6_IFADDR_STATE_DEAD)\r\ngoto out;\r\nif (dev->flags&(IFF_NOARP|IFF_LOOPBACK) ||\r\nidev->cnf.accept_dad < 1 ||\r\n!(ifp->flags&IFA_F_TENTATIVE) ||\r\nifp->flags & IFA_F_NODAD) {\r\nifp->flags &= ~(IFA_F_TENTATIVE|IFA_F_OPTIMISTIC|IFA_F_DADFAILED);\r\nspin_unlock(&ifp->lock);\r\nread_unlock_bh(&idev->lock);\r\naddrconf_dad_completed(ifp);\r\nreturn;\r\n}\r\nif (!(idev->if_flags & IF_READY)) {\r\nspin_unlock(&ifp->lock);\r\nread_unlock_bh(&idev->lock);\r\nin6_ifa_hold(ifp);\r\naddrconf_dad_stop(ifp, 0);\r\nreturn;\r\n}\r\nif (ifp->flags & IFA_F_OPTIMISTIC)\r\nip6_ins_rt(ifp->rt);\r\naddrconf_dad_kick(ifp);\r\nout:\r\nspin_unlock(&ifp->lock);\r\nread_unlock_bh(&idev->lock);\r\n}\r\nstatic void addrconf_dad_start(struct inet6_ifaddr *ifp)\r\n{\r\nbool begin_dad = false;\r\nspin_lock_bh(&ifp->state_lock);\r\nif (ifp->state != INET6_IFADDR_STATE_DEAD) {\r\nifp->state = INET6_IFADDR_STATE_PREDAD;\r\nbegin_dad = true;\r\n}\r\nspin_unlock_bh(&ifp->state_lock);\r\nif (begin_dad)\r\naddrconf_mod_dad_work(ifp, 0);\r\n}\r\nstatic void addrconf_dad_work(struct work_struct *w)\r\n{\r\nstruct inet6_ifaddr *ifp = container_of(to_delayed_work(w),\r\nstruct inet6_ifaddr,\r\ndad_work);\r\nstruct inet6_dev *idev = ifp->idev;\r\nstruct in6_addr mcaddr;\r\nenum {\r\nDAD_PROCESS,\r\nDAD_BEGIN,\r\nDAD_ABORT,\r\n} action = DAD_PROCESS;\r\nrtnl_lock();\r\nspin_lock_bh(&ifp->state_lock);\r\nif (ifp->state == INET6_IFADDR_STATE_PREDAD) {\r\naction = DAD_BEGIN;\r\nifp->state = INET6_IFADDR_STATE_DAD;\r\n} else if (ifp->state == INET6_IFADDR_STATE_ERRDAD) {\r\naction = DAD_ABORT;\r\nifp->state = INET6_IFADDR_STATE_POSTDAD;\r\n}\r\nspin_unlock_bh(&ifp->state_lock);\r\nif (action == DAD_BEGIN) {\r\naddrconf_dad_begin(ifp);\r\ngoto out;\r\n} else if (action == DAD_ABORT) {\r\naddrconf_dad_stop(ifp, 1);\r\ngoto out;\r\n}\r\nif (!ifp->dad_probes && addrconf_dad_end(ifp))\r\ngoto out;\r\nwrite_lock_bh(&idev->lock);\r\nif (idev->dead || !(idev->if_flags & IF_READY)) {\r\nwrite_unlock_bh(&idev->lock);\r\ngoto out;\r\n}\r\nspin_lock(&ifp->lock);\r\nif (ifp->state == INET6_IFADDR_STATE_DEAD) {\r\nspin_unlock(&ifp->lock);\r\nwrite_unlock_bh(&idev->lock);\r\ngoto out;\r\n}\r\nif (ifp->dad_probes == 0) {\r\nifp->flags &= ~(IFA_F_TENTATIVE|IFA_F_OPTIMISTIC|IFA_F_DADFAILED);\r\nspin_unlock(&ifp->lock);\r\nwrite_unlock_bh(&idev->lock);\r\naddrconf_dad_completed(ifp);\r\ngoto out;\r\n}\r\nifp->dad_probes--;\r\naddrconf_mod_dad_work(ifp,\r\nNEIGH_VAR(ifp->idev->nd_parms, RETRANS_TIME));\r\nspin_unlock(&ifp->lock);\r\nwrite_unlock_bh(&idev->lock);\r\naddrconf_addr_solict_mult(&ifp->addr, &mcaddr);\r\nndisc_send_ns(ifp->idev->dev, NULL, &ifp->addr, &mcaddr, &in6addr_any);\r\nout:\r\nin6_ifa_put(ifp);\r\nrtnl_unlock();\r\n}\r\nstatic bool ipv6_lonely_lladdr(struct inet6_ifaddr *ifp)\r\n{\r\nstruct inet6_ifaddr *ifpiter;\r\nstruct inet6_dev *idev = ifp->idev;\r\nlist_for_each_entry_reverse(ifpiter, &idev->addr_list, if_list) {\r\nif (ifpiter->scope > IFA_LINK)\r\nbreak;\r\nif (ifp != ifpiter && ifpiter->scope == IFA_LINK &&\r\n(ifpiter->flags & (IFA_F_PERMANENT|IFA_F_TENTATIVE|\r\nIFA_F_OPTIMISTIC|IFA_F_DADFAILED)) ==\r\nIFA_F_PERMANENT)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void addrconf_dad_completed(struct inet6_ifaddr *ifp)\r\n{\r\nstruct net_device *dev = ifp->idev->dev;\r\nstruct in6_addr lladdr;\r\nbool send_rs, send_mld;\r\naddrconf_del_dad_work(ifp);\r\nipv6_ifa_notify(RTM_NEWADDR, ifp);\r\nread_lock_bh(&ifp->idev->lock);\r\nsend_mld = ifp->scope == IFA_LINK && ipv6_lonely_lladdr(ifp);\r\nsend_rs = send_mld &&\r\nipv6_accept_ra(ifp->idev) &&\r\nifp->idev->cnf.rtr_solicits > 0 &&\r\n(dev->flags&IFF_LOOPBACK) == 0;\r\nread_unlock_bh(&ifp->idev->lock);\r\nif (send_mld)\r\nipv6_mc_dad_complete(ifp->idev);\r\nif (send_rs) {\r\nif (ipv6_get_lladdr(dev, &lladdr, IFA_F_TENTATIVE))\r\nreturn;\r\nndisc_send_rs(dev, &lladdr, &in6addr_linklocal_allrouters);\r\nwrite_lock_bh(&ifp->idev->lock);\r\nspin_lock(&ifp->lock);\r\nifp->idev->rs_probes = 1;\r\nifp->idev->if_flags |= IF_RS_SENT;\r\naddrconf_mod_rs_timer(ifp->idev,\r\nifp->idev->cnf.rtr_solicit_interval);\r\nspin_unlock(&ifp->lock);\r\nwrite_unlock_bh(&ifp->idev->lock);\r\n}\r\n}\r\nstatic void addrconf_dad_run(struct inet6_dev *idev)\r\n{\r\nstruct inet6_ifaddr *ifp;\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry(ifp, &idev->addr_list, if_list) {\r\nspin_lock(&ifp->lock);\r\nif (ifp->flags & IFA_F_TENTATIVE &&\r\nifp->state == INET6_IFADDR_STATE_DAD)\r\naddrconf_dad_kick(ifp);\r\nspin_unlock(&ifp->lock);\r\n}\r\nread_unlock_bh(&idev->lock);\r\n}\r\nstatic struct inet6_ifaddr *if6_get_first(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct inet6_ifaddr *ifa = NULL;\r\nstruct if6_iter_state *state = seq->private;\r\nstruct net *net = seq_file_net(seq);\r\nint p = 0;\r\nif (pos == 0) {\r\nstate->bucket = 0;\r\nstate->offset = 0;\r\n}\r\nfor (; state->bucket < IN6_ADDR_HSIZE; ++state->bucket) {\r\nhlist_for_each_entry_rcu_bh(ifa, &inet6_addr_lst[state->bucket],\r\naddr_lst) {\r\nif (!net_eq(dev_net(ifa->idev->dev), net))\r\ncontinue;\r\nif (p < state->offset) {\r\np++;\r\ncontinue;\r\n}\r\nstate->offset++;\r\nreturn ifa;\r\n}\r\nstate->offset = 0;\r\np = 0;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct inet6_ifaddr *if6_get_next(struct seq_file *seq,\r\nstruct inet6_ifaddr *ifa)\r\n{\r\nstruct if6_iter_state *state = seq->private;\r\nstruct net *net = seq_file_net(seq);\r\nhlist_for_each_entry_continue_rcu_bh(ifa, addr_lst) {\r\nif (!net_eq(dev_net(ifa->idev->dev), net))\r\ncontinue;\r\nstate->offset++;\r\nreturn ifa;\r\n}\r\nwhile (++state->bucket < IN6_ADDR_HSIZE) {\r\nstate->offset = 0;\r\nhlist_for_each_entry_rcu_bh(ifa,\r\n&inet6_addr_lst[state->bucket], addr_lst) {\r\nif (!net_eq(dev_net(ifa->idev->dev), net))\r\ncontinue;\r\nstate->offset++;\r\nreturn ifa;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *if6_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(rcu_bh)\r\n{\r\nrcu_read_lock_bh();\r\nreturn if6_get_first(seq, *pos);\r\n}\r\nstatic void *if6_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct inet6_ifaddr *ifa;\r\nifa = if6_get_next(seq, v);\r\n++*pos;\r\nreturn ifa;\r\n}\r\nstatic void if6_seq_stop(struct seq_file *seq, void *v)\r\n__releases(rcu_bh)\r\n{\r\nrcu_read_unlock_bh();\r\n}\r\nstatic int if6_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct inet6_ifaddr *ifp = (struct inet6_ifaddr *)v;\r\nseq_printf(seq, "%pi6 %02x %02x %02x %02x %8s\n",\r\n&ifp->addr,\r\nifp->idev->dev->ifindex,\r\nifp->prefix_len,\r\nifp->scope,\r\n(u8) ifp->flags,\r\nifp->idev->dev->name);\r\nreturn 0;\r\n}\r\nstatic int if6_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &if6_seq_ops,\r\nsizeof(struct if6_iter_state));\r\n}\r\nstatic int __net_init if6_proc_net_init(struct net *net)\r\n{\r\nif (!proc_create("if_inet6", S_IRUGO, net->proc_net, &if6_fops))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit if6_proc_net_exit(struct net *net)\r\n{\r\nremove_proc_entry("if_inet6", net->proc_net);\r\n}\r\nint __init if6_proc_init(void)\r\n{\r\nreturn register_pernet_subsys(&if6_proc_net_ops);\r\n}\r\nvoid if6_proc_exit(void)\r\n{\r\nunregister_pernet_subsys(&if6_proc_net_ops);\r\n}\r\nint ipv6_chk_home_addr(struct net *net, const struct in6_addr *addr)\r\n{\r\nint ret = 0;\r\nstruct inet6_ifaddr *ifp = NULL;\r\nunsigned int hash = inet6_addr_hash(addr);\r\nrcu_read_lock_bh();\r\nhlist_for_each_entry_rcu_bh(ifp, &inet6_addr_lst[hash], addr_lst) {\r\nif (!net_eq(dev_net(ifp->idev->dev), net))\r\ncontinue;\r\nif (ipv6_addr_equal(&ifp->addr, addr) &&\r\n(ifp->flags & IFA_F_HOMEADDRESS)) {\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock_bh();\r\nreturn ret;\r\n}\r\nstatic void addrconf_verify_rtnl(void)\r\n{\r\nunsigned long now, next, next_sec, next_sched;\r\nstruct inet6_ifaddr *ifp;\r\nint i;\r\nASSERT_RTNL();\r\nrcu_read_lock_bh();\r\nnow = jiffies;\r\nnext = round_jiffies_up(now + ADDR_CHECK_FREQUENCY);\r\ncancel_delayed_work(&addr_chk_work);\r\nfor (i = 0; i < IN6_ADDR_HSIZE; i++) {\r\nrestart:\r\nhlist_for_each_entry_rcu_bh(ifp, &inet6_addr_lst[i], addr_lst) {\r\nunsigned long age;\r\nif ((ifp->flags & IFA_F_PERMANENT) &&\r\n(ifp->prefered_lft == INFINITY_LIFE_TIME))\r\ncontinue;\r\nspin_lock(&ifp->lock);\r\nage = (now - ifp->tstamp + ADDRCONF_TIMER_FUZZ_MINUS) / HZ;\r\nif (ifp->valid_lft != INFINITY_LIFE_TIME &&\r\nage >= ifp->valid_lft) {\r\nspin_unlock(&ifp->lock);\r\nin6_ifa_hold(ifp);\r\nipv6_del_addr(ifp);\r\ngoto restart;\r\n} else if (ifp->prefered_lft == INFINITY_LIFE_TIME) {\r\nspin_unlock(&ifp->lock);\r\ncontinue;\r\n} else if (age >= ifp->prefered_lft) {\r\nint deprecate = 0;\r\nif (!(ifp->flags&IFA_F_DEPRECATED)) {\r\ndeprecate = 1;\r\nifp->flags |= IFA_F_DEPRECATED;\r\n}\r\nif ((ifp->valid_lft != INFINITY_LIFE_TIME) &&\r\n(time_before(ifp->tstamp + ifp->valid_lft * HZ, next)))\r\nnext = ifp->tstamp + ifp->valid_lft * HZ;\r\nspin_unlock(&ifp->lock);\r\nif (deprecate) {\r\nin6_ifa_hold(ifp);\r\nipv6_ifa_notify(0, ifp);\r\nin6_ifa_put(ifp);\r\ngoto restart;\r\n}\r\n} else if ((ifp->flags&IFA_F_TEMPORARY) &&\r\n!(ifp->flags&IFA_F_TENTATIVE)) {\r\nunsigned long regen_advance = ifp->idev->cnf.regen_max_retry *\r\nifp->idev->cnf.dad_transmits *\r\nNEIGH_VAR(ifp->idev->nd_parms, RETRANS_TIME) / HZ;\r\nif (age >= ifp->prefered_lft - regen_advance) {\r\nstruct inet6_ifaddr *ifpub = ifp->ifpub;\r\nif (time_before(ifp->tstamp + ifp->prefered_lft * HZ, next))\r\nnext = ifp->tstamp + ifp->prefered_lft * HZ;\r\nif (!ifp->regen_count && ifpub) {\r\nifp->regen_count++;\r\nin6_ifa_hold(ifp);\r\nin6_ifa_hold(ifpub);\r\nspin_unlock(&ifp->lock);\r\nspin_lock(&ifpub->lock);\r\nifpub->regen_count = 0;\r\nspin_unlock(&ifpub->lock);\r\nipv6_create_tempaddr(ifpub, ifp);\r\nin6_ifa_put(ifpub);\r\nin6_ifa_put(ifp);\r\ngoto restart;\r\n}\r\n} else if (time_before(ifp->tstamp + ifp->prefered_lft * HZ - regen_advance * HZ, next))\r\nnext = ifp->tstamp + ifp->prefered_lft * HZ - regen_advance * HZ;\r\nspin_unlock(&ifp->lock);\r\n} else {\r\nif (time_before(ifp->tstamp + ifp->prefered_lft * HZ, next))\r\nnext = ifp->tstamp + ifp->prefered_lft * HZ;\r\nspin_unlock(&ifp->lock);\r\n}\r\n}\r\n}\r\nnext_sec = round_jiffies_up(next);\r\nnext_sched = next;\r\nif (time_before(next_sec, next + ADDRCONF_TIMER_FUZZ))\r\nnext_sched = next_sec;\r\nif (time_before(next_sched, jiffies + ADDRCONF_TIMER_FUZZ_MAX))\r\nnext_sched = jiffies + ADDRCONF_TIMER_FUZZ_MAX;\r\nADBG(KERN_DEBUG "now = %lu, schedule = %lu, rounded schedule = %lu => %lu\n",\r\nnow, next, next_sec, next_sched);\r\nmod_delayed_work(addrconf_wq, &addr_chk_work, next_sched - now);\r\nrcu_read_unlock_bh();\r\n}\r\nstatic void addrconf_verify_work(struct work_struct *w)\r\n{\r\nrtnl_lock();\r\naddrconf_verify_rtnl();\r\nrtnl_unlock();\r\n}\r\nstatic void addrconf_verify(void)\r\n{\r\nmod_delayed_work(addrconf_wq, &addr_chk_work, 0);\r\n}\r\nstatic struct in6_addr *extract_addr(struct nlattr *addr, struct nlattr *local,\r\nstruct in6_addr **peer_pfx)\r\n{\r\nstruct in6_addr *pfx = NULL;\r\n*peer_pfx = NULL;\r\nif (addr)\r\npfx = nla_data(addr);\r\nif (local) {\r\nif (pfx && nla_memcmp(local, pfx, sizeof(*pfx)))\r\n*peer_pfx = pfx;\r\npfx = nla_data(local);\r\n}\r\nreturn pfx;\r\n}\r\nstatic int\r\ninet6_rtm_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct ifaddrmsg *ifm;\r\nstruct nlattr *tb[IFA_MAX+1];\r\nstruct in6_addr *pfx, *peer_pfx;\r\nint err;\r\nerr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv6_policy);\r\nif (err < 0)\r\nreturn err;\r\nifm = nlmsg_data(nlh);\r\npfx = extract_addr(tb[IFA_ADDRESS], tb[IFA_LOCAL], &peer_pfx);\r\nif (pfx == NULL)\r\nreturn -EINVAL;\r\nreturn inet6_addr_del(net, ifm->ifa_index, pfx, ifm->ifa_prefixlen);\r\n}\r\nstatic int inet6_addr_modify(struct inet6_ifaddr *ifp, u32 ifa_flags,\r\nu32 prefered_lft, u32 valid_lft)\r\n{\r\nu32 flags;\r\nclock_t expires;\r\nunsigned long timeout;\r\nbool was_managetempaddr;\r\nbool had_prefixroute;\r\nASSERT_RTNL();\r\nif (!valid_lft || (prefered_lft > valid_lft))\r\nreturn -EINVAL;\r\nif (ifa_flags & IFA_F_MANAGETEMPADDR &&\r\n(ifp->flags & IFA_F_TEMPORARY || ifp->prefix_len != 64))\r\nreturn -EINVAL;\r\ntimeout = addrconf_timeout_fixup(valid_lft, HZ);\r\nif (addrconf_finite_timeout(timeout)) {\r\nexpires = jiffies_to_clock_t(timeout * HZ);\r\nvalid_lft = timeout;\r\nflags = RTF_EXPIRES;\r\n} else {\r\nexpires = 0;\r\nflags = 0;\r\nifa_flags |= IFA_F_PERMANENT;\r\n}\r\ntimeout = addrconf_timeout_fixup(prefered_lft, HZ);\r\nif (addrconf_finite_timeout(timeout)) {\r\nif (timeout == 0)\r\nifa_flags |= IFA_F_DEPRECATED;\r\nprefered_lft = timeout;\r\n}\r\nspin_lock_bh(&ifp->lock);\r\nwas_managetempaddr = ifp->flags & IFA_F_MANAGETEMPADDR;\r\nhad_prefixroute = ifp->flags & IFA_F_PERMANENT &&\r\n!(ifp->flags & IFA_F_NOPREFIXROUTE);\r\nifp->flags &= ~(IFA_F_DEPRECATED | IFA_F_PERMANENT | IFA_F_NODAD |\r\nIFA_F_HOMEADDRESS | IFA_F_MANAGETEMPADDR |\r\nIFA_F_NOPREFIXROUTE);\r\nifp->flags |= ifa_flags;\r\nifp->tstamp = jiffies;\r\nifp->valid_lft = valid_lft;\r\nifp->prefered_lft = prefered_lft;\r\nspin_unlock_bh(&ifp->lock);\r\nif (!(ifp->flags&IFA_F_TENTATIVE))\r\nipv6_ifa_notify(0, ifp);\r\nif (!(ifa_flags & IFA_F_NOPREFIXROUTE)) {\r\naddrconf_prefix_route(&ifp->addr, ifp->prefix_len, ifp->idev->dev,\r\nexpires, flags);\r\n} else if (had_prefixroute) {\r\nenum cleanup_prefix_rt_t action;\r\nunsigned long rt_expires;\r\nwrite_lock_bh(&ifp->idev->lock);\r\naction = check_cleanup_prefix_route(ifp, &rt_expires);\r\nwrite_unlock_bh(&ifp->idev->lock);\r\nif (action != CLEANUP_PREFIX_RT_NOP) {\r\ncleanup_prefix_route(ifp, rt_expires,\r\naction == CLEANUP_PREFIX_RT_DEL);\r\n}\r\n}\r\nif (was_managetempaddr || ifp->flags & IFA_F_MANAGETEMPADDR) {\r\nif (was_managetempaddr && !(ifp->flags & IFA_F_MANAGETEMPADDR))\r\nvalid_lft = prefered_lft = 0;\r\nmanage_tempaddrs(ifp->idev, ifp, valid_lft, prefered_lft,\r\n!was_managetempaddr, jiffies);\r\n}\r\naddrconf_verify_rtnl();\r\nreturn 0;\r\n}\r\nstatic int\r\ninet6_rtm_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct ifaddrmsg *ifm;\r\nstruct nlattr *tb[IFA_MAX+1];\r\nstruct in6_addr *pfx, *peer_pfx;\r\nstruct inet6_ifaddr *ifa;\r\nstruct net_device *dev;\r\nu32 valid_lft = INFINITY_LIFE_TIME, preferred_lft = INFINITY_LIFE_TIME;\r\nu32 ifa_flags;\r\nint err;\r\nerr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv6_policy);\r\nif (err < 0)\r\nreturn err;\r\nifm = nlmsg_data(nlh);\r\npfx = extract_addr(tb[IFA_ADDRESS], tb[IFA_LOCAL], &peer_pfx);\r\nif (pfx == NULL)\r\nreturn -EINVAL;\r\nif (tb[IFA_CACHEINFO]) {\r\nstruct ifa_cacheinfo *ci;\r\nci = nla_data(tb[IFA_CACHEINFO]);\r\nvalid_lft = ci->ifa_valid;\r\npreferred_lft = ci->ifa_prefered;\r\n} else {\r\npreferred_lft = INFINITY_LIFE_TIME;\r\nvalid_lft = INFINITY_LIFE_TIME;\r\n}\r\ndev = __dev_get_by_index(net, ifm->ifa_index);\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nifa_flags = tb[IFA_FLAGS] ? nla_get_u32(tb[IFA_FLAGS]) : ifm->ifa_flags;\r\nifa_flags &= IFA_F_NODAD | IFA_F_HOMEADDRESS | IFA_F_MANAGETEMPADDR |\r\nIFA_F_NOPREFIXROUTE;\r\nifa = ipv6_get_ifaddr(net, pfx, dev, 1);\r\nif (ifa == NULL) {\r\nreturn inet6_addr_add(net, ifm->ifa_index, pfx, peer_pfx,\r\nifm->ifa_prefixlen, ifa_flags,\r\npreferred_lft, valid_lft);\r\n}\r\nif (nlh->nlmsg_flags & NLM_F_EXCL ||\r\n!(nlh->nlmsg_flags & NLM_F_REPLACE))\r\nerr = -EEXIST;\r\nelse\r\nerr = inet6_addr_modify(ifa, ifa_flags, preferred_lft, valid_lft);\r\nin6_ifa_put(ifa);\r\nreturn err;\r\n}\r\nstatic void put_ifaddrmsg(struct nlmsghdr *nlh, u8 prefixlen, u32 flags,\r\nu8 scope, int ifindex)\r\n{\r\nstruct ifaddrmsg *ifm;\r\nifm = nlmsg_data(nlh);\r\nifm->ifa_family = AF_INET6;\r\nifm->ifa_prefixlen = prefixlen;\r\nifm->ifa_flags = flags;\r\nifm->ifa_scope = scope;\r\nifm->ifa_index = ifindex;\r\n}\r\nstatic int put_cacheinfo(struct sk_buff *skb, unsigned long cstamp,\r\nunsigned long tstamp, u32 preferred, u32 valid)\r\n{\r\nstruct ifa_cacheinfo ci;\r\nci.cstamp = cstamp_delta(cstamp);\r\nci.tstamp = cstamp_delta(tstamp);\r\nci.ifa_prefered = preferred;\r\nci.ifa_valid = valid;\r\nreturn nla_put(skb, IFA_CACHEINFO, sizeof(ci), &ci);\r\n}\r\nstatic inline int rt_scope(int ifa_scope)\r\n{\r\nif (ifa_scope & IFA_HOST)\r\nreturn RT_SCOPE_HOST;\r\nelse if (ifa_scope & IFA_LINK)\r\nreturn RT_SCOPE_LINK;\r\nelse if (ifa_scope & IFA_SITE)\r\nreturn RT_SCOPE_SITE;\r\nelse\r\nreturn RT_SCOPE_UNIVERSE;\r\n}\r\nstatic inline int inet6_ifaddr_msgsize(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct ifaddrmsg))\r\n+ nla_total_size(16)\r\n+ nla_total_size(16)\r\n+ nla_total_size(sizeof(struct ifa_cacheinfo))\r\n+ nla_total_size(4) ;\r\n}\r\nstatic int inet6_fill_ifaddr(struct sk_buff *skb, struct inet6_ifaddr *ifa,\r\nu32 portid, u32 seq, int event, unsigned int flags)\r\n{\r\nstruct nlmsghdr *nlh;\r\nu32 preferred, valid;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct ifaddrmsg), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nput_ifaddrmsg(nlh, ifa->prefix_len, ifa->flags, rt_scope(ifa->scope),\r\nifa->idev->dev->ifindex);\r\nif (!((ifa->flags&IFA_F_PERMANENT) &&\r\n(ifa->prefered_lft == INFINITY_LIFE_TIME))) {\r\npreferred = ifa->prefered_lft;\r\nvalid = ifa->valid_lft;\r\nif (preferred != INFINITY_LIFE_TIME) {\r\nlong tval = (jiffies - ifa->tstamp)/HZ;\r\nif (preferred > tval)\r\npreferred -= tval;\r\nelse\r\npreferred = 0;\r\nif (valid != INFINITY_LIFE_TIME) {\r\nif (valid > tval)\r\nvalid -= tval;\r\nelse\r\nvalid = 0;\r\n}\r\n}\r\n} else {\r\npreferred = INFINITY_LIFE_TIME;\r\nvalid = INFINITY_LIFE_TIME;\r\n}\r\nif (!ipv6_addr_any(&ifa->peer_addr)) {\r\nif (nla_put(skb, IFA_LOCAL, 16, &ifa->addr) < 0 ||\r\nnla_put(skb, IFA_ADDRESS, 16, &ifa->peer_addr) < 0)\r\ngoto error;\r\n} else\r\nif (nla_put(skb, IFA_ADDRESS, 16, &ifa->addr) < 0)\r\ngoto error;\r\nif (put_cacheinfo(skb, ifa->cstamp, ifa->tstamp, preferred, valid) < 0)\r\ngoto error;\r\nif (nla_put_u32(skb, IFA_FLAGS, ifa->flags) < 0)\r\ngoto error;\r\nreturn nlmsg_end(skb, nlh);\r\nerror:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int inet6_fill_ifmcaddr(struct sk_buff *skb, struct ifmcaddr6 *ifmca,\r\nu32 portid, u32 seq, int event, u16 flags)\r\n{\r\nstruct nlmsghdr *nlh;\r\nu8 scope = RT_SCOPE_UNIVERSE;\r\nint ifindex = ifmca->idev->dev->ifindex;\r\nif (ipv6_addr_scope(&ifmca->mca_addr) & IFA_SITE)\r\nscope = RT_SCOPE_SITE;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct ifaddrmsg), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nput_ifaddrmsg(nlh, 128, IFA_F_PERMANENT, scope, ifindex);\r\nif (nla_put(skb, IFA_MULTICAST, 16, &ifmca->mca_addr) < 0 ||\r\nput_cacheinfo(skb, ifmca->mca_cstamp, ifmca->mca_tstamp,\r\nINFINITY_LIFE_TIME, INFINITY_LIFE_TIME) < 0) {\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nreturn nlmsg_end(skb, nlh);\r\n}\r\nstatic int inet6_fill_ifacaddr(struct sk_buff *skb, struct ifacaddr6 *ifaca,\r\nu32 portid, u32 seq, int event, unsigned int flags)\r\n{\r\nstruct nlmsghdr *nlh;\r\nu8 scope = RT_SCOPE_UNIVERSE;\r\nint ifindex = ifaca->aca_idev->dev->ifindex;\r\nif (ipv6_addr_scope(&ifaca->aca_addr) & IFA_SITE)\r\nscope = RT_SCOPE_SITE;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct ifaddrmsg), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nput_ifaddrmsg(nlh, 128, IFA_F_PERMANENT, scope, ifindex);\r\nif (nla_put(skb, IFA_ANYCAST, 16, &ifaca->aca_addr) < 0 ||\r\nput_cacheinfo(skb, ifaca->aca_cstamp, ifaca->aca_tstamp,\r\nINFINITY_LIFE_TIME, INFINITY_LIFE_TIME) < 0) {\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nreturn nlmsg_end(skb, nlh);\r\n}\r\nstatic int in6_dump_addrs(struct inet6_dev *idev, struct sk_buff *skb,\r\nstruct netlink_callback *cb, enum addr_type_t type,\r\nint s_ip_idx, int *p_ip_idx)\r\n{\r\nstruct ifmcaddr6 *ifmca;\r\nstruct ifacaddr6 *ifaca;\r\nint err = 1;\r\nint ip_idx = *p_ip_idx;\r\nread_lock_bh(&idev->lock);\r\nswitch (type) {\r\ncase UNICAST_ADDR: {\r\nstruct inet6_ifaddr *ifa;\r\nlist_for_each_entry(ifa, &idev->addr_list, if_list) {\r\nif (++ip_idx < s_ip_idx)\r\ncontinue;\r\nerr = inet6_fill_ifaddr(skb, ifa,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWADDR,\r\nNLM_F_MULTI);\r\nif (err <= 0)\r\nbreak;\r\nnl_dump_check_consistent(cb, nlmsg_hdr(skb));\r\n}\r\nbreak;\r\n}\r\ncase MULTICAST_ADDR:\r\nfor (ifmca = idev->mc_list; ifmca;\r\nifmca = ifmca->next, ip_idx++) {\r\nif (ip_idx < s_ip_idx)\r\ncontinue;\r\nerr = inet6_fill_ifmcaddr(skb, ifmca,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_GETMULTICAST,\r\nNLM_F_MULTI);\r\nif (err <= 0)\r\nbreak;\r\n}\r\nbreak;\r\ncase ANYCAST_ADDR:\r\nfor (ifaca = idev->ac_list; ifaca;\r\nifaca = ifaca->aca_next, ip_idx++) {\r\nif (ip_idx < s_ip_idx)\r\ncontinue;\r\nerr = inet6_fill_ifacaddr(skb, ifaca,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_GETANYCAST,\r\nNLM_F_MULTI);\r\nif (err <= 0)\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nread_unlock_bh(&idev->lock);\r\n*p_ip_idx = ip_idx;\r\nreturn err;\r\n}\r\nstatic int inet6_dump_addr(struct sk_buff *skb, struct netlink_callback *cb,\r\nenum addr_type_t type)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nint h, s_h;\r\nint idx, ip_idx;\r\nint s_idx, s_ip_idx;\r\nstruct net_device *dev;\r\nstruct inet6_dev *idev;\r\nstruct hlist_head *head;\r\ns_h = cb->args[0];\r\ns_idx = idx = cb->args[1];\r\ns_ip_idx = ip_idx = cb->args[2];\r\nrcu_read_lock();\r\ncb->seq = atomic_read(&net->ipv6.dev_addr_genid) ^ net->dev_base_seq;\r\nfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\r\nidx = 0;\r\nhead = &net->dev_index_head[h];\r\nhlist_for_each_entry_rcu(dev, head, index_hlist) {\r\nif (idx < s_idx)\r\ngoto cont;\r\nif (h > s_h || idx > s_idx)\r\ns_ip_idx = 0;\r\nip_idx = 0;\r\nidev = __in6_dev_get(dev);\r\nif (!idev)\r\ngoto cont;\r\nif (in6_dump_addrs(idev, skb, cb, type,\r\ns_ip_idx, &ip_idx) <= 0)\r\ngoto done;\r\ncont:\r\nidx++;\r\n}\r\n}\r\ndone:\r\nrcu_read_unlock();\r\ncb->args[0] = h;\r\ncb->args[1] = idx;\r\ncb->args[2] = ip_idx;\r\nreturn skb->len;\r\n}\r\nstatic int inet6_dump_ifaddr(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nenum addr_type_t type = UNICAST_ADDR;\r\nreturn inet6_dump_addr(skb, cb, type);\r\n}\r\nstatic int inet6_dump_ifmcaddr(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nenum addr_type_t type = MULTICAST_ADDR;\r\nreturn inet6_dump_addr(skb, cb, type);\r\n}\r\nstatic int inet6_dump_ifacaddr(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nenum addr_type_t type = ANYCAST_ADDR;\r\nreturn inet6_dump_addr(skb, cb, type);\r\n}\r\nstatic int inet6_rtm_getaddr(struct sk_buff *in_skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(in_skb->sk);\r\nstruct ifaddrmsg *ifm;\r\nstruct nlattr *tb[IFA_MAX+1];\r\nstruct in6_addr *addr = NULL, *peer;\r\nstruct net_device *dev = NULL;\r\nstruct inet6_ifaddr *ifa;\r\nstruct sk_buff *skb;\r\nint err;\r\nerr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv6_policy);\r\nif (err < 0)\r\ngoto errout;\r\naddr = extract_addr(tb[IFA_ADDRESS], tb[IFA_LOCAL], &peer);\r\nif (addr == NULL) {\r\nerr = -EINVAL;\r\ngoto errout;\r\n}\r\nifm = nlmsg_data(nlh);\r\nif (ifm->ifa_index)\r\ndev = __dev_get_by_index(net, ifm->ifa_index);\r\nifa = ipv6_get_ifaddr(net, addr, dev, 1);\r\nif (!ifa) {\r\nerr = -EADDRNOTAVAIL;\r\ngoto errout;\r\n}\r\nskb = nlmsg_new(inet6_ifaddr_msgsize(), GFP_KERNEL);\r\nif (!skb) {\r\nerr = -ENOBUFS;\r\ngoto errout_ifa;\r\n}\r\nerr = inet6_fill_ifaddr(skb, ifa, NETLINK_CB(in_skb).portid,\r\nnlh->nlmsg_seq, RTM_NEWADDR, 0);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout_ifa;\r\n}\r\nerr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\r\nerrout_ifa:\r\nin6_ifa_put(ifa);\r\nerrout:\r\nreturn err;\r\n}\r\nstatic void inet6_ifa_notify(int event, struct inet6_ifaddr *ifa)\r\n{\r\nstruct sk_buff *skb;\r\nstruct net *net = dev_net(ifa->idev->dev);\r\nint err = -ENOBUFS;\r\nskb = nlmsg_new(inet6_ifaddr_msgsize(), GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = inet6_fill_ifaddr(skb, ifa, 0, 0, event, 0);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, 0, RTNLGRP_IPV6_IFADDR, NULL, GFP_ATOMIC);\r\nreturn;\r\nerrout:\r\nif (err < 0)\r\nrtnl_set_sk_err(net, RTNLGRP_IPV6_IFADDR, err);\r\n}\r\nstatic inline void ipv6_store_devconf(struct ipv6_devconf *cnf,\r\n__s32 *array, int bytes)\r\n{\r\nBUG_ON(bytes < (DEVCONF_MAX * 4));\r\nmemset(array, 0, bytes);\r\narray[DEVCONF_FORWARDING] = cnf->forwarding;\r\narray[DEVCONF_HOPLIMIT] = cnf->hop_limit;\r\narray[DEVCONF_MTU6] = cnf->mtu6;\r\narray[DEVCONF_ACCEPT_RA] = cnf->accept_ra;\r\narray[DEVCONF_ACCEPT_REDIRECTS] = cnf->accept_redirects;\r\narray[DEVCONF_AUTOCONF] = cnf->autoconf;\r\narray[DEVCONF_DAD_TRANSMITS] = cnf->dad_transmits;\r\narray[DEVCONF_RTR_SOLICITS] = cnf->rtr_solicits;\r\narray[DEVCONF_RTR_SOLICIT_INTERVAL] =\r\njiffies_to_msecs(cnf->rtr_solicit_interval);\r\narray[DEVCONF_RTR_SOLICIT_DELAY] =\r\njiffies_to_msecs(cnf->rtr_solicit_delay);\r\narray[DEVCONF_FORCE_MLD_VERSION] = cnf->force_mld_version;\r\narray[DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL] =\r\njiffies_to_msecs(cnf->mldv1_unsolicited_report_interval);\r\narray[DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL] =\r\njiffies_to_msecs(cnf->mldv2_unsolicited_report_interval);\r\narray[DEVCONF_USE_TEMPADDR] = cnf->use_tempaddr;\r\narray[DEVCONF_TEMP_VALID_LFT] = cnf->temp_valid_lft;\r\narray[DEVCONF_TEMP_PREFERED_LFT] = cnf->temp_prefered_lft;\r\narray[DEVCONF_REGEN_MAX_RETRY] = cnf->regen_max_retry;\r\narray[DEVCONF_MAX_DESYNC_FACTOR] = cnf->max_desync_factor;\r\narray[DEVCONF_MAX_ADDRESSES] = cnf->max_addresses;\r\narray[DEVCONF_ACCEPT_RA_DEFRTR] = cnf->accept_ra_defrtr;\r\narray[DEVCONF_ACCEPT_RA_PINFO] = cnf->accept_ra_pinfo;\r\n#ifdef CONFIG_IPV6_ROUTER_PREF\r\narray[DEVCONF_ACCEPT_RA_RTR_PREF] = cnf->accept_ra_rtr_pref;\r\narray[DEVCONF_RTR_PROBE_INTERVAL] =\r\njiffies_to_msecs(cnf->rtr_probe_interval);\r\n#ifdef CONFIG_IPV6_ROUTE_INFO\r\narray[DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN] = cnf->accept_ra_rt_info_max_plen;\r\n#endif\r\n#endif\r\narray[DEVCONF_PROXY_NDP] = cnf->proxy_ndp;\r\narray[DEVCONF_ACCEPT_SOURCE_ROUTE] = cnf->accept_source_route;\r\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\r\narray[DEVCONF_OPTIMISTIC_DAD] = cnf->optimistic_dad;\r\n#endif\r\n#ifdef CONFIG_IPV6_MROUTE\r\narray[DEVCONF_MC_FORWARDING] = cnf->mc_forwarding;\r\n#endif\r\narray[DEVCONF_DISABLE_IPV6] = cnf->disable_ipv6;\r\narray[DEVCONF_ACCEPT_DAD] = cnf->accept_dad;\r\narray[DEVCONF_FORCE_TLLAO] = cnf->force_tllao;\r\narray[DEVCONF_NDISC_NOTIFY] = cnf->ndisc_notify;\r\narray[DEVCONF_SUPPRESS_FRAG_NDISC] = cnf->suppress_frag_ndisc;\r\n}\r\nstatic inline size_t inet6_ifla6_size(void)\r\n{\r\nreturn nla_total_size(4)\r\n+ nla_total_size(sizeof(struct ifla_cacheinfo))\r\n+ nla_total_size(DEVCONF_MAX * 4)\r\n+ nla_total_size(IPSTATS_MIB_MAX * 8)\r\n+ nla_total_size(ICMP6_MIB_MAX * 8)\r\n+ nla_total_size(sizeof(struct in6_addr));\r\n}\r\nstatic inline size_t inet6_if_nlmsg_size(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\r\n+ nla_total_size(IFNAMSIZ)\r\n+ nla_total_size(MAX_ADDR_LEN)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(inet6_ifla6_size());\r\n}\r\nstatic inline void __snmp6_fill_statsdev(u64 *stats, atomic_long_t *mib,\r\nint items, int bytes)\r\n{\r\nint i;\r\nint pad = bytes - sizeof(u64) * items;\r\nBUG_ON(pad < 0);\r\nput_unaligned(items, &stats[0]);\r\nfor (i = 1; i < items; i++)\r\nput_unaligned(atomic_long_read(&mib[i]), &stats[i]);\r\nmemset(&stats[items], 0, pad);\r\n}\r\nstatic inline void __snmp6_fill_stats64(u64 *stats, void __percpu **mib,\r\nint items, int bytes, size_t syncpoff)\r\n{\r\nint i;\r\nint pad = bytes - sizeof(u64) * items;\r\nBUG_ON(pad < 0);\r\nput_unaligned(items, &stats[0]);\r\nfor (i = 1; i < items; i++)\r\nput_unaligned(snmp_fold_field64(mib, i, syncpoff), &stats[i]);\r\nmemset(&stats[items], 0, pad);\r\n}\r\nstatic void snmp6_fill_stats(u64 *stats, struct inet6_dev *idev, int attrtype,\r\nint bytes)\r\n{\r\nswitch (attrtype) {\r\ncase IFLA_INET6_STATS:\r\n__snmp6_fill_stats64(stats, (void __percpu **)idev->stats.ipv6,\r\nIPSTATS_MIB_MAX, bytes, offsetof(struct ipstats_mib, syncp));\r\nbreak;\r\ncase IFLA_INET6_ICMP6STATS:\r\n__snmp6_fill_statsdev(stats, idev->stats.icmpv6dev->mibs, ICMP6_MIB_MAX, bytes);\r\nbreak;\r\n}\r\n}\r\nstatic int inet6_fill_ifla6_attrs(struct sk_buff *skb, struct inet6_dev *idev)\r\n{\r\nstruct nlattr *nla;\r\nstruct ifla_cacheinfo ci;\r\nif (nla_put_u32(skb, IFLA_INET6_FLAGS, idev->if_flags))\r\ngoto nla_put_failure;\r\nci.max_reasm_len = IPV6_MAXPLEN;\r\nci.tstamp = cstamp_delta(idev->tstamp);\r\nci.reachable_time = jiffies_to_msecs(idev->nd_parms->reachable_time);\r\nci.retrans_time = jiffies_to_msecs(NEIGH_VAR(idev->nd_parms, RETRANS_TIME));\r\nif (nla_put(skb, IFLA_INET6_CACHEINFO, sizeof(ci), &ci))\r\ngoto nla_put_failure;\r\nnla = nla_reserve(skb, IFLA_INET6_CONF, DEVCONF_MAX * sizeof(s32));\r\nif (nla == NULL)\r\ngoto nla_put_failure;\r\nipv6_store_devconf(&idev->cnf, nla_data(nla), nla_len(nla));\r\nnla = nla_reserve(skb, IFLA_INET6_STATS, IPSTATS_MIB_MAX * sizeof(u64));\r\nif (nla == NULL)\r\ngoto nla_put_failure;\r\nsnmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_STATS, nla_len(nla));\r\nnla = nla_reserve(skb, IFLA_INET6_ICMP6STATS, ICMP6_MIB_MAX * sizeof(u64));\r\nif (nla == NULL)\r\ngoto nla_put_failure;\r\nsnmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_ICMP6STATS, nla_len(nla));\r\nnla = nla_reserve(skb, IFLA_INET6_TOKEN, sizeof(struct in6_addr));\r\nif (nla == NULL)\r\ngoto nla_put_failure;\r\nread_lock_bh(&idev->lock);\r\nmemcpy(nla_data(nla), idev->token.s6_addr, nla_len(nla));\r\nread_unlock_bh(&idev->lock);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic size_t inet6_get_link_af_size(const struct net_device *dev)\r\n{\r\nif (!__in6_dev_get(dev))\r\nreturn 0;\r\nreturn inet6_ifla6_size();\r\n}\r\nstatic int inet6_fill_link_af(struct sk_buff *skb, const struct net_device *dev)\r\n{\r\nstruct inet6_dev *idev = __in6_dev_get(dev);\r\nif (!idev)\r\nreturn -ENODATA;\r\nif (inet6_fill_ifla6_attrs(skb, idev) < 0)\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int inet6_set_iftoken(struct inet6_dev *idev, struct in6_addr *token)\r\n{\r\nstruct inet6_ifaddr *ifp;\r\nstruct net_device *dev = idev->dev;\r\nbool update_rs = false;\r\nstruct in6_addr ll_addr;\r\nASSERT_RTNL();\r\nif (token == NULL)\r\nreturn -EINVAL;\r\nif (ipv6_addr_any(token))\r\nreturn -EINVAL;\r\nif (dev->flags & (IFF_LOOPBACK | IFF_NOARP))\r\nreturn -EINVAL;\r\nif (!ipv6_accept_ra(idev))\r\nreturn -EINVAL;\r\nif (idev->cnf.rtr_solicits <= 0)\r\nreturn -EINVAL;\r\nwrite_lock_bh(&idev->lock);\r\nBUILD_BUG_ON(sizeof(token->s6_addr) != 16);\r\nmemcpy(idev->token.s6_addr + 8, token->s6_addr + 8, 8);\r\nwrite_unlock_bh(&idev->lock);\r\nif (!idev->dead && (idev->if_flags & IF_READY) &&\r\n!ipv6_get_lladdr(dev, &ll_addr, IFA_F_TENTATIVE |\r\nIFA_F_OPTIMISTIC)) {\r\nndisc_send_rs(dev, &ll_addr, &in6addr_linklocal_allrouters);\r\nupdate_rs = true;\r\n}\r\nwrite_lock_bh(&idev->lock);\r\nif (update_rs) {\r\nidev->if_flags |= IF_RS_SENT;\r\nidev->rs_probes = 1;\r\naddrconf_mod_rs_timer(idev, idev->cnf.rtr_solicit_interval);\r\n}\r\nlist_for_each_entry(ifp, &idev->addr_list, if_list) {\r\nspin_lock(&ifp->lock);\r\nif (ifp->tokenized) {\r\nifp->valid_lft = 0;\r\nifp->prefered_lft = 0;\r\n}\r\nspin_unlock(&ifp->lock);\r\n}\r\nwrite_unlock_bh(&idev->lock);\r\naddrconf_verify_rtnl();\r\nreturn 0;\r\n}\r\nstatic int inet6_set_link_af(struct net_device *dev, const struct nlattr *nla)\r\n{\r\nint err = -EINVAL;\r\nstruct inet6_dev *idev = __in6_dev_get(dev);\r\nstruct nlattr *tb[IFLA_INET6_MAX + 1];\r\nif (!idev)\r\nreturn -EAFNOSUPPORT;\r\nif (nla_parse_nested(tb, IFLA_INET6_MAX, nla, NULL) < 0)\r\nBUG();\r\nif (tb[IFLA_INET6_TOKEN])\r\nerr = inet6_set_iftoken(idev, nla_data(tb[IFLA_INET6_TOKEN]));\r\nreturn err;\r\n}\r\nstatic int inet6_fill_ifinfo(struct sk_buff *skb, struct inet6_dev *idev,\r\nu32 portid, u32 seq, int event, unsigned int flags)\r\n{\r\nstruct net_device *dev = idev->dev;\r\nstruct ifinfomsg *hdr;\r\nstruct nlmsghdr *nlh;\r\nvoid *protoinfo;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*hdr), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nhdr = nlmsg_data(nlh);\r\nhdr->ifi_family = AF_INET6;\r\nhdr->__ifi_pad = 0;\r\nhdr->ifi_type = dev->type;\r\nhdr->ifi_index = dev->ifindex;\r\nhdr->ifi_flags = dev_get_flags(dev);\r\nhdr->ifi_change = 0;\r\nif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\r\n(dev->addr_len &&\r\nnla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr)) ||\r\nnla_put_u32(skb, IFLA_MTU, dev->mtu) ||\r\n(dev->ifindex != dev->iflink &&\r\nnla_put_u32(skb, IFLA_LINK, dev->iflink)))\r\ngoto nla_put_failure;\r\nprotoinfo = nla_nest_start(skb, IFLA_PROTINFO);\r\nif (protoinfo == NULL)\r\ngoto nla_put_failure;\r\nif (inet6_fill_ifla6_attrs(skb, idev) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, protoinfo);\r\nreturn nlmsg_end(skb, nlh);\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int inet6_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nint h, s_h;\r\nint idx = 0, s_idx;\r\nstruct net_device *dev;\r\nstruct inet6_dev *idev;\r\nstruct hlist_head *head;\r\ns_h = cb->args[0];\r\ns_idx = cb->args[1];\r\nrcu_read_lock();\r\nfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\r\nidx = 0;\r\nhead = &net->dev_index_head[h];\r\nhlist_for_each_entry_rcu(dev, head, index_hlist) {\r\nif (idx < s_idx)\r\ngoto cont;\r\nidev = __in6_dev_get(dev);\r\nif (!idev)\r\ngoto cont;\r\nif (inet6_fill_ifinfo(skb, idev,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWLINK, NLM_F_MULTI) <= 0)\r\ngoto out;\r\ncont:\r\nidx++;\r\n}\r\n}\r\nout:\r\nrcu_read_unlock();\r\ncb->args[1] = idx;\r\ncb->args[0] = h;\r\nreturn skb->len;\r\n}\r\nvoid inet6_ifinfo_notify(int event, struct inet6_dev *idev)\r\n{\r\nstruct sk_buff *skb;\r\nstruct net *net = dev_net(idev->dev);\r\nint err = -ENOBUFS;\r\nskb = nlmsg_new(inet6_if_nlmsg_size(), GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = inet6_fill_ifinfo(skb, idev, 0, 0, event, 0);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, 0, RTNLGRP_IPV6_IFINFO, NULL, GFP_ATOMIC);\r\nreturn;\r\nerrout:\r\nif (err < 0)\r\nrtnl_set_sk_err(net, RTNLGRP_IPV6_IFINFO, err);\r\n}\r\nstatic inline size_t inet6_prefix_nlmsg_size(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct prefixmsg))\r\n+ nla_total_size(sizeof(struct in6_addr))\r\n+ nla_total_size(sizeof(struct prefix_cacheinfo));\r\n}\r\nstatic int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,\r\nstruct prefix_info *pinfo, u32 portid, u32 seq,\r\nint event, unsigned int flags)\r\n{\r\nstruct prefixmsg *pmsg;\r\nstruct nlmsghdr *nlh;\r\nstruct prefix_cacheinfo ci;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*pmsg), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\npmsg = nlmsg_data(nlh);\r\npmsg->prefix_family = AF_INET6;\r\npmsg->prefix_pad1 = 0;\r\npmsg->prefix_pad2 = 0;\r\npmsg->prefix_ifindex = idev->dev->ifindex;\r\npmsg->prefix_len = pinfo->prefix_len;\r\npmsg->prefix_type = pinfo->type;\r\npmsg->prefix_pad3 = 0;\r\npmsg->prefix_flags = 0;\r\nif (pinfo->onlink)\r\npmsg->prefix_flags |= IF_PREFIX_ONLINK;\r\nif (pinfo->autoconf)\r\npmsg->prefix_flags |= IF_PREFIX_AUTOCONF;\r\nif (nla_put(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix))\r\ngoto nla_put_failure;\r\nci.preferred_time = ntohl(pinfo->prefered);\r\nci.valid_time = ntohl(pinfo->valid);\r\nif (nla_put(skb, PREFIX_CACHEINFO, sizeof(ci), &ci))\r\ngoto nla_put_failure;\r\nreturn nlmsg_end(skb, nlh);\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic void inet6_prefix_notify(int event, struct inet6_dev *idev,\r\nstruct prefix_info *pinfo)\r\n{\r\nstruct sk_buff *skb;\r\nstruct net *net = dev_net(idev->dev);\r\nint err = -ENOBUFS;\r\nskb = nlmsg_new(inet6_prefix_nlmsg_size(), GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = inet6_fill_prefix(skb, idev, pinfo, 0, 0, event, 0);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, 0, RTNLGRP_IPV6_PREFIX, NULL, GFP_ATOMIC);\r\nreturn;\r\nerrout:\r\nif (err < 0)\r\nrtnl_set_sk_err(net, RTNLGRP_IPV6_PREFIX, err);\r\n}\r\nstatic void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)\r\n{\r\nstruct net *net = dev_net(ifp->idev->dev);\r\nif (event)\r\nASSERT_RTNL();\r\ninet6_ifa_notify(event ? : RTM_NEWADDR, ifp);\r\nswitch (event) {\r\ncase RTM_NEWADDR:\r\nif (!(ifp->rt->rt6i_node))\r\nip6_ins_rt(ifp->rt);\r\nif (ifp->idev->cnf.forwarding)\r\naddrconf_join_anycast(ifp);\r\nif (!ipv6_addr_any(&ifp->peer_addr))\r\naddrconf_prefix_route(&ifp->peer_addr, 128,\r\nifp->idev->dev, 0, 0);\r\nbreak;\r\ncase RTM_DELADDR:\r\nif (ifp->idev->cnf.forwarding)\r\naddrconf_leave_anycast(ifp);\r\naddrconf_leave_solict(ifp->idev, &ifp->addr);\r\nif (!ipv6_addr_any(&ifp->peer_addr)) {\r\nstruct rt6_info *rt;\r\nstruct net_device *dev = ifp->idev->dev;\r\nrt = rt6_lookup(dev_net(dev), &ifp->peer_addr, NULL,\r\ndev->ifindex, 1);\r\nif (rt) {\r\ndst_hold(&rt->dst);\r\nif (ip6_del_rt(rt))\r\ndst_free(&rt->dst);\r\n}\r\n}\r\ndst_hold(&ifp->rt->dst);\r\nif (ip6_del_rt(ifp->rt))\r\ndst_free(&ifp->rt->dst);\r\nbreak;\r\n}\r\natomic_inc(&net->ipv6.dev_addr_genid);\r\nrt_genid_bump_ipv6(net);\r\n}\r\nstatic void ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)\r\n{\r\nrcu_read_lock_bh();\r\nif (likely(ifp->idev->dead == 0))\r\n__ipv6_ifa_notify(event, ifp);\r\nrcu_read_unlock_bh();\r\n}\r\nstatic\r\nint addrconf_sysctl_forward(struct ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint *valp = ctl->data;\r\nint val = *valp;\r\nloff_t pos = *ppos;\r\nstruct ctl_table lctl;\r\nint ret;\r\nlctl = *ctl;\r\nlctl.data = &val;\r\nret = proc_dointvec(&lctl, write, buffer, lenp, ppos);\r\nif (write)\r\nret = addrconf_fixup_forwarding(ctl, valp, val);\r\nif (ret)\r\n*ppos = pos;\r\nreturn ret;\r\n}\r\nstatic void dev_disable_change(struct inet6_dev *idev)\r\n{\r\nstruct netdev_notifier_info info;\r\nif (!idev || !idev->dev)\r\nreturn;\r\nnetdev_notifier_info_init(&info, idev->dev);\r\nif (idev->cnf.disable_ipv6)\r\naddrconf_notify(NULL, NETDEV_DOWN, &info);\r\nelse\r\naddrconf_notify(NULL, NETDEV_UP, &info);\r\n}\r\nstatic void addrconf_disable_change(struct net *net, __s32 newf)\r\n{\r\nstruct net_device *dev;\r\nstruct inet6_dev *idev;\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(net, dev) {\r\nidev = __in6_dev_get(dev);\r\nif (idev) {\r\nint changed = (!idev->cnf.disable_ipv6) ^ (!newf);\r\nidev->cnf.disable_ipv6 = newf;\r\nif (changed)\r\ndev_disable_change(idev);\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int addrconf_disable_ipv6(struct ctl_table *table, int *p, int newf)\r\n{\r\nstruct net *net;\r\nint old;\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\nnet = (struct net *)table->extra2;\r\nold = *p;\r\n*p = newf;\r\nif (p == &net->ipv6.devconf_dflt->disable_ipv6) {\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nif (p == &net->ipv6.devconf_all->disable_ipv6) {\r\nnet->ipv6.devconf_dflt->disable_ipv6 = newf;\r\naddrconf_disable_change(net, newf);\r\n} else if ((!newf) ^ (!old))\r\ndev_disable_change((struct inet6_dev *)table->extra1);\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nstatic\r\nint addrconf_sysctl_disable(struct ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint *valp = ctl->data;\r\nint val = *valp;\r\nloff_t pos = *ppos;\r\nstruct ctl_table lctl;\r\nint ret;\r\nlctl = *ctl;\r\nlctl.data = &val;\r\nret = proc_dointvec(&lctl, write, buffer, lenp, ppos);\r\nif (write)\r\nret = addrconf_disable_ipv6(ctl, valp, val);\r\nif (ret)\r\n*ppos = pos;\r\nreturn ret;\r\n}\r\nstatic\r\nint addrconf_sysctl_proxy_ndp(struct ctl_table *ctl, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint *valp = ctl->data;\r\nint ret;\r\nint old, new;\r\nold = *valp;\r\nret = proc_dointvec(ctl, write, buffer, lenp, ppos);\r\nnew = *valp;\r\nif (write && old != new) {\r\nstruct net *net = ctl->extra2;\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\nif (valp == &net->ipv6.devconf_dflt->proxy_ndp)\r\ninet6_netconf_notify_devconf(net, NETCONFA_PROXY_NEIGH,\r\nNETCONFA_IFINDEX_DEFAULT,\r\nnet->ipv6.devconf_dflt);\r\nelse if (valp == &net->ipv6.devconf_all->proxy_ndp)\r\ninet6_netconf_notify_devconf(net, NETCONFA_PROXY_NEIGH,\r\nNETCONFA_IFINDEX_ALL,\r\nnet->ipv6.devconf_all);\r\nelse {\r\nstruct inet6_dev *idev = ctl->extra1;\r\ninet6_netconf_notify_devconf(net, NETCONFA_PROXY_NEIGH,\r\nidev->dev->ifindex,\r\n&idev->cnf);\r\n}\r\nrtnl_unlock();\r\n}\r\nreturn ret;\r\n}\r\nstatic int __addrconf_sysctl_register(struct net *net, char *dev_name,\r\nstruct inet6_dev *idev, struct ipv6_devconf *p)\r\n{\r\nint i;\r\nstruct addrconf_sysctl_table *t;\r\nchar path[sizeof("net/ipv6/conf/") + IFNAMSIZ];\r\nt = kmemdup(&addrconf_sysctl, sizeof(*t), GFP_KERNEL);\r\nif (t == NULL)\r\ngoto out;\r\nfor (i = 0; t->addrconf_vars[i].data; i++) {\r\nt->addrconf_vars[i].data += (char *)p - (char *)&ipv6_devconf;\r\nt->addrconf_vars[i].extra1 = idev;\r\nt->addrconf_vars[i].extra2 = net;\r\n}\r\nsnprintf(path, sizeof(path), "net/ipv6/conf/%s", dev_name);\r\nt->sysctl_header = register_net_sysctl(net, path, t->addrconf_vars);\r\nif (t->sysctl_header == NULL)\r\ngoto free;\r\np->sysctl = t;\r\nreturn 0;\r\nfree:\r\nkfree(t);\r\nout:\r\nreturn -ENOBUFS;\r\n}\r\nstatic void __addrconf_sysctl_unregister(struct ipv6_devconf *p)\r\n{\r\nstruct addrconf_sysctl_table *t;\r\nif (p->sysctl == NULL)\r\nreturn;\r\nt = p->sysctl;\r\np->sysctl = NULL;\r\nunregister_net_sysctl_table(t->sysctl_header);\r\nkfree(t);\r\n}\r\nstatic void addrconf_sysctl_register(struct inet6_dev *idev)\r\n{\r\nneigh_sysctl_register(idev->dev, idev->nd_parms,\r\n&ndisc_ifinfo_sysctl_change);\r\n__addrconf_sysctl_register(dev_net(idev->dev), idev->dev->name,\r\nidev, &idev->cnf);\r\n}\r\nstatic void addrconf_sysctl_unregister(struct inet6_dev *idev)\r\n{\r\n__addrconf_sysctl_unregister(&idev->cnf);\r\nneigh_sysctl_unregister(idev->nd_parms);\r\n}\r\nstatic int __net_init addrconf_init_net(struct net *net)\r\n{\r\nint err = -ENOMEM;\r\nstruct ipv6_devconf *all, *dflt;\r\nall = kmemdup(&ipv6_devconf, sizeof(ipv6_devconf), GFP_KERNEL);\r\nif (all == NULL)\r\ngoto err_alloc_all;\r\ndflt = kmemdup(&ipv6_devconf_dflt, sizeof(ipv6_devconf_dflt), GFP_KERNEL);\r\nif (dflt == NULL)\r\ngoto err_alloc_dflt;\r\ndflt->autoconf = ipv6_defaults.autoconf;\r\ndflt->disable_ipv6 = ipv6_defaults.disable_ipv6;\r\nnet->ipv6.devconf_all = all;\r\nnet->ipv6.devconf_dflt = dflt;\r\n#ifdef CONFIG_SYSCTL\r\nerr = __addrconf_sysctl_register(net, "all", NULL, all);\r\nif (err < 0)\r\ngoto err_reg_all;\r\nerr = __addrconf_sysctl_register(net, "default", NULL, dflt);\r\nif (err < 0)\r\ngoto err_reg_dflt;\r\n#endif\r\nreturn 0;\r\n#ifdef CONFIG_SYSCTL\r\nerr_reg_dflt:\r\n__addrconf_sysctl_unregister(all);\r\nerr_reg_all:\r\nkfree(dflt);\r\n#endif\r\nerr_alloc_dflt:\r\nkfree(all);\r\nerr_alloc_all:\r\nreturn err;\r\n}\r\nstatic void __net_exit addrconf_exit_net(struct net *net)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\n__addrconf_sysctl_unregister(net->ipv6.devconf_dflt);\r\n__addrconf_sysctl_unregister(net->ipv6.devconf_all);\r\n#endif\r\nif (!net_eq(net, &init_net)) {\r\nkfree(net->ipv6.devconf_dflt);\r\nkfree(net->ipv6.devconf_all);\r\n}\r\n}\r\nint __init addrconf_init(void)\r\n{\r\nint i, err;\r\nerr = ipv6_addr_label_init();\r\nif (err < 0) {\r\npr_crit("%s: cannot initialize default policy table: %d\n",\r\n__func__, err);\r\ngoto out;\r\n}\r\nerr = register_pernet_subsys(&addrconf_ops);\r\nif (err < 0)\r\ngoto out_addrlabel;\r\naddrconf_wq = create_workqueue("ipv6_addrconf");\r\nif (!addrconf_wq) {\r\nerr = -ENOMEM;\r\ngoto out_nowq;\r\n}\r\nrtnl_lock();\r\nif (!ipv6_add_dev(init_net.loopback_dev))\r\nerr = -ENOMEM;\r\nrtnl_unlock();\r\nif (err)\r\ngoto errlo;\r\nfor (i = 0; i < IN6_ADDR_HSIZE; i++)\r\nINIT_HLIST_HEAD(&inet6_addr_lst[i]);\r\nregister_netdevice_notifier(&ipv6_dev_notf);\r\naddrconf_verify();\r\nrtnl_af_register(&inet6_ops);\r\nerr = __rtnl_register(PF_INET6, RTM_GETLINK, NULL, inet6_dump_ifinfo,\r\nNULL);\r\nif (err < 0)\r\ngoto errout;\r\n__rtnl_register(PF_INET6, RTM_NEWADDR, inet6_rtm_newaddr, NULL, NULL);\r\n__rtnl_register(PF_INET6, RTM_DELADDR, inet6_rtm_deladdr, NULL, NULL);\r\n__rtnl_register(PF_INET6, RTM_GETADDR, inet6_rtm_getaddr,\r\ninet6_dump_ifaddr, NULL);\r\n__rtnl_register(PF_INET6, RTM_GETMULTICAST, NULL,\r\ninet6_dump_ifmcaddr, NULL);\r\n__rtnl_register(PF_INET6, RTM_GETANYCAST, NULL,\r\ninet6_dump_ifacaddr, NULL);\r\n__rtnl_register(PF_INET6, RTM_GETNETCONF, inet6_netconf_get_devconf,\r\ninet6_netconf_dump_devconf, NULL);\r\nipv6_addr_label_rtnl_register();\r\nreturn 0;\r\nerrout:\r\nrtnl_af_unregister(&inet6_ops);\r\nunregister_netdevice_notifier(&ipv6_dev_notf);\r\nerrlo:\r\ndestroy_workqueue(addrconf_wq);\r\nout_nowq:\r\nunregister_pernet_subsys(&addrconf_ops);\r\nout_addrlabel:\r\nipv6_addr_label_cleanup();\r\nout:\r\nreturn err;\r\n}\r\nvoid addrconf_cleanup(void)\r\n{\r\nstruct net_device *dev;\r\nint i;\r\nunregister_netdevice_notifier(&ipv6_dev_notf);\r\nunregister_pernet_subsys(&addrconf_ops);\r\nipv6_addr_label_cleanup();\r\nrtnl_lock();\r\n__rtnl_af_unregister(&inet6_ops);\r\nfor_each_netdev(&init_net, dev) {\r\nif (__in6_dev_get(dev) == NULL)\r\ncontinue;\r\naddrconf_ifdown(dev, 1);\r\n}\r\naddrconf_ifdown(init_net.loopback_dev, 2);\r\nspin_lock_bh(&addrconf_hash_lock);\r\nfor (i = 0; i < IN6_ADDR_HSIZE; i++)\r\nWARN_ON(!hlist_empty(&inet6_addr_lst[i]));\r\nspin_unlock_bh(&addrconf_hash_lock);\r\ncancel_delayed_work(&addr_chk_work);\r\nrtnl_unlock();\r\ndestroy_workqueue(addrconf_wq);\r\n}
