static inline u8 IN_TO_REG(unsigned long val)\r\n{\r\nunsigned long nval = clamp_val(val, 0, 4080);\r\nreturn (nval + 8) / 16;\r\n}\r\nstatic inline u8 FAN_TO_REG(long rpm, int div)\r\n{\r\nif (rpm <= 0)\r\nreturn 255;\r\nif (rpm > 1350000)\r\nreturn 1;\r\nreturn clamp_val((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\r\n}\r\nstatic inline int FAN_FROM_REG(u8 val, int div)\r\n{\r\nreturn val == 0 ? -1 : val == 255 ? 0 : 1350000 / (val * div);\r\n}\r\nstatic inline s8 TEMP_TO_REG(int val)\r\n{\r\nint nval = clamp_val(val, -128000, 127000) ;\r\nreturn nval < 0 ? (nval - 500) / 1000 : (nval + 500) / 1000;\r\n}\r\nstatic inline int TEMP_FROM_REG(s8 val)\r\n{\r\nreturn val * 1000;\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct lm78_data *data = lm78_update_device(dev);\r\nreturn sprintf(buf, "%d\n", IN_FROM_REG(data->in[attr->index]));\r\n}\r\nstatic ssize_t show_in_min(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct lm78_data *data = lm78_update_device(dev);\r\nreturn sprintf(buf, "%d\n", IN_FROM_REG(data->in_min[attr->index]));\r\n}\r\nstatic ssize_t show_in_max(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct lm78_data *data = lm78_update_device(dev);\r\nreturn sprintf(buf, "%d\n", IN_FROM_REG(data->in_max[attr->index]));\r\n}\r\nstatic ssize_t set_in_min(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct lm78_data *data = dev_get_drvdata(dev);\r\nint nr = attr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in_min[nr] = IN_TO_REG(val);\r\nlm78_write_value(data, LM78_REG_IN_MIN(nr), data->in_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_in_max(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct lm78_data *data = dev_get_drvdata(dev);\r\nint nr = attr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in_max[nr] = IN_TO_REG(val);\r\nlm78_write_value(data, LM78_REG_IN_MAX(nr), data->in_max[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct lm78_data *data = lm78_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp));\r\n}\r\nstatic ssize_t show_temp_over(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct lm78_data *data = lm78_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_over));\r\n}\r\nstatic ssize_t set_temp_over(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct lm78_data *data = dev_get_drvdata(dev);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_over = TEMP_TO_REG(val);\r\nlm78_write_value(data, LM78_REG_TEMP_OVER, data->temp_over);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_hyst(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct lm78_data *data = lm78_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_hyst));\r\n}\r\nstatic ssize_t set_temp_hyst(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct lm78_data *data = dev_get_drvdata(dev);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_hyst = TEMP_TO_REG(val);\r\nlm78_write_value(data, LM78_REG_TEMP_HYST, data->temp_hyst);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct lm78_data *data = lm78_update_device(dev);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%d\n", FAN_FROM_REG(data->fan[nr],\r\nDIV_FROM_REG(data->fan_div[nr])));\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct lm78_data *data = lm78_update_device(dev);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%d\n", FAN_FROM_REG(data->fan_min[nr],\r\nDIV_FROM_REG(data->fan_div[nr])));\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct lm78_data *data = dev_get_drvdata(dev);\r\nint nr = attr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\r\nlm78_write_value(data, LM78_REG_FAN_MIN(nr), data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan_div(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct lm78_data *data = lm78_update_device(dev);\r\nreturn sprintf(buf, "%d\n", DIV_FROM_REG(data->fan_div[attr->index]));\r\n}\r\nstatic ssize_t set_fan_div(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct lm78_data *data = dev_get_drvdata(dev);\r\nint nr = attr->index;\r\nunsigned long min;\r\nu8 reg;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nmin = FAN_FROM_REG(data->fan_min[nr],\r\nDIV_FROM_REG(data->fan_div[nr]));\r\nswitch (val) {\r\ncase 1:\r\ndata->fan_div[nr] = 0;\r\nbreak;\r\ncase 2:\r\ndata->fan_div[nr] = 1;\r\nbreak;\r\ncase 4:\r\ndata->fan_div[nr] = 2;\r\nbreak;\r\ncase 8:\r\ndata->fan_div[nr] = 3;\r\nbreak;\r\ndefault:\r\ndev_err(dev,\r\n"fan_div value %ld not supported. Choose one of 1, 2, 4 or 8!\n",\r\nval);\r\nmutex_unlock(&data->update_lock);\r\nreturn -EINVAL;\r\n}\r\nreg = lm78_read_value(data, LM78_REG_VID_FANDIV);\r\nswitch (nr) {\r\ncase 0:\r\nreg = (reg & 0xcf) | (data->fan_div[nr] << 4);\r\nbreak;\r\ncase 1:\r\nreg = (reg & 0x3f) | (data->fan_div[nr] << 6);\r\nbreak;\r\n}\r\nlm78_write_value(data, LM78_REG_VID_FANDIV, reg);\r\ndata->fan_min[nr] =\r\nFAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));\r\nlm78_write_value(data, LM78_REG_FAN_MIN(nr), data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_vid(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct lm78_data *data = lm78_update_device(dev);\r\nreturn sprintf(buf, "%d\n", vid_from_reg(data->vid, 82));\r\n}\r\nstatic ssize_t show_alarms(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct lm78_data *data = lm78_update_device(dev);\r\nreturn sprintf(buf, "%u\n", data->alarms);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct lm78_data *data = lm78_update_device(dev);\r\nint nr = to_sensor_dev_attr(da)->index;\r\nreturn sprintf(buf, "%u\n", (data->alarms >> nr) & 1);\r\n}\r\nstatic ssize_t show_name(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct lm78_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", data->name);\r\n}\r\nstatic struct lm78_data *lm78_data_if_isa(void)\r\n{\r\nreturn pdev ? platform_get_drvdata(pdev) : NULL;\r\n}\r\nstatic int lm78_alias_detect(struct i2c_client *client, u8 chipid)\r\n{\r\nstruct lm78_data *isa;\r\nint i;\r\nif (!pdev)\r\nreturn 0;\r\nisa = platform_get_drvdata(pdev);\r\nif (lm78_read_value(isa, LM78_REG_I2C_ADDR) != client->addr)\r\nreturn 0;\r\nif ((lm78_read_value(isa, LM78_REG_CHIPID) & 0xfe) != (chipid & 0xfe))\r\nreturn 0;\r\nfor (i = 0x2b; i <= 0x3d; i++) {\r\nif (lm78_read_value(isa, i) !=\r\ni2c_smbus_read_byte_data(client, i))\r\nreturn 0;\r\n}\r\nif (lm78_read_value(isa, LM78_REG_CONFIG) !=\r\ni2c_smbus_read_byte_data(client, LM78_REG_CONFIG))\r\nreturn 0;\r\nfor (i = 0x43; i <= 0x46; i++) {\r\nif (lm78_read_value(isa, i) !=\r\ni2c_smbus_read_byte_data(client, i))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int lm78_alias_detect(struct i2c_client *client, u8 chipid)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct lm78_data *lm78_data_if_isa(void)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int lm78_i2c_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nint i;\r\nstruct lm78_data *isa = lm78_data_if_isa();\r\nconst char *client_name;\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint address = client->addr;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nif (isa)\r\nmutex_lock(&isa->update_lock);\r\nif ((i2c_smbus_read_byte_data(client, LM78_REG_CONFIG) & 0x80)\r\n|| i2c_smbus_read_byte_data(client, LM78_REG_I2C_ADDR) != address)\r\ngoto err_nodev;\r\ni = i2c_smbus_read_byte_data(client, 0x4f);\r\nif (i == 0xa3 || i == 0x5c)\r\ngoto err_nodev;\r\ni = i2c_smbus_read_byte_data(client, LM78_REG_CHIPID);\r\nif (i == 0x00 || i == 0x20\r\n|| i == 0x40)\r\nclient_name = "lm78";\r\nelse if ((i & 0xfe) == 0xc0)\r\nclient_name = "lm79";\r\nelse\r\ngoto err_nodev;\r\nif (lm78_alias_detect(client, i)) {\r\ndev_dbg(&adapter->dev,\r\n"Device at 0x%02x appears to be the same as ISA device\n",\r\naddress);\r\ngoto err_nodev;\r\n}\r\nif (isa)\r\nmutex_unlock(&isa->update_lock);\r\nstrlcpy(info->type, client_name, I2C_NAME_SIZE);\r\nreturn 0;\r\nerr_nodev:\r\nif (isa)\r\nmutex_unlock(&isa->update_lock);\r\nreturn -ENODEV;\r\n}\r\nstatic int lm78_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lm78_data *data;\r\nint err;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct lm78_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\ndata->client = client;\r\ndata->type = id->driver_data;\r\nlm78_init_device(data);\r\nerr = sysfs_create_group(&client->dev.kobj, &lm78_group);\r\nif (err)\r\nreturn err;\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nsysfs_remove_group(&client->dev.kobj, &lm78_group);\r\nreturn err;\r\n}\r\nstatic int lm78_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct lm78_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &lm78_group);\r\nreturn 0;\r\n}\r\nstatic int lm78_read_value(struct lm78_data *data, u8 reg)\r\n{\r\nstruct i2c_client *client = data->client;\r\n#ifdef CONFIG_ISA\r\nif (!client) {\r\nint res;\r\nmutex_lock(&data->lock);\r\noutb_p(reg, data->isa_addr + LM78_ADDR_REG_OFFSET);\r\nres = inb_p(data->isa_addr + LM78_DATA_REG_OFFSET);\r\nmutex_unlock(&data->lock);\r\nreturn res;\r\n} else\r\n#endif\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int lm78_write_value(struct lm78_data *data, u8 reg, u8 value)\r\n{\r\nstruct i2c_client *client = data->client;\r\n#ifdef CONFIG_ISA\r\nif (!client) {\r\nmutex_lock(&data->lock);\r\noutb_p(reg, data->isa_addr + LM78_ADDR_REG_OFFSET);\r\noutb_p(value, data->isa_addr + LM78_DATA_REG_OFFSET);\r\nmutex_unlock(&data->lock);\r\nreturn 0;\r\n} else\r\n#endif\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic void lm78_init_device(struct lm78_data *data)\r\n{\r\nu8 config;\r\nint i;\r\nconfig = lm78_read_value(data, LM78_REG_CONFIG);\r\nif ((config & 0x09) != 0x01)\r\nlm78_write_value(data, LM78_REG_CONFIG,\r\n(config & 0xf7) | 0x01);\r\nfor (i = 0; i < 3; i++) {\r\ndata->fan_min[i] = lm78_read_value(data,\r\nLM78_REG_FAN_MIN(i));\r\n}\r\nmutex_init(&data->update_lock);\r\n}\r\nstatic struct lm78_data *lm78_update_device(struct device *dev)\r\n{\r\nstruct lm78_data *data = dev_get_drvdata(dev);\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\r\n|| !data->valid) {\r\ndev_dbg(dev, "Starting lm78 update\n");\r\nfor (i = 0; i <= 6; i++) {\r\ndata->in[i] =\r\nlm78_read_value(data, LM78_REG_IN(i));\r\ndata->in_min[i] =\r\nlm78_read_value(data, LM78_REG_IN_MIN(i));\r\ndata->in_max[i] =\r\nlm78_read_value(data, LM78_REG_IN_MAX(i));\r\n}\r\nfor (i = 0; i < 3; i++) {\r\ndata->fan[i] =\r\nlm78_read_value(data, LM78_REG_FAN(i));\r\ndata->fan_min[i] =\r\nlm78_read_value(data, LM78_REG_FAN_MIN(i));\r\n}\r\ndata->temp = lm78_read_value(data, LM78_REG_TEMP);\r\ndata->temp_over =\r\nlm78_read_value(data, LM78_REG_TEMP_OVER);\r\ndata->temp_hyst =\r\nlm78_read_value(data, LM78_REG_TEMP_HYST);\r\ni = lm78_read_value(data, LM78_REG_VID_FANDIV);\r\ndata->vid = i & 0x0f;\r\nif (data->type == lm79)\r\ndata->vid |=\r\n(lm78_read_value(data, LM78_REG_CHIPID) &\r\n0x01) << 4;\r\nelse\r\ndata->vid |= 0x10;\r\ndata->fan_div[0] = (i >> 4) & 0x03;\r\ndata->fan_div[1] = i >> 6;\r\ndata->alarms = lm78_read_value(data, LM78_REG_ALARM1) +\r\n(lm78_read_value(data, LM78_REG_ALARM2) << 8);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\ndata->fan_div[2] = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic int lm78_isa_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nstruct lm78_data *data;\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!devm_request_region(&pdev->dev, res->start + LM78_ADDR_REG_OFFSET,\r\n2, "lm78"))\r\nreturn -EBUSY;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct lm78_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nmutex_init(&data->lock);\r\ndata->isa_addr = res->start;\r\nplatform_set_drvdata(pdev, data);\r\nif (lm78_read_value(data, LM78_REG_CHIPID) & 0x80) {\r\ndata->type = lm79;\r\ndata->name = "lm79";\r\n} else {\r\ndata->type = lm78;\r\ndata->name = "lm78";\r\n}\r\nlm78_init_device(data);\r\nerr = sysfs_create_group(&pdev->dev.kobj, &lm78_group);\r\nif (err)\r\ngoto exit_remove_files;\r\nerr = device_create_file(&pdev->dev, &dev_attr_name);\r\nif (err)\r\ngoto exit_remove_files;\r\ndata->hwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove_files;\r\n}\r\nreturn 0;\r\nexit_remove_files:\r\nsysfs_remove_group(&pdev->dev.kobj, &lm78_group);\r\ndevice_remove_file(&pdev->dev, &dev_attr_name);\r\nreturn err;\r\n}\r\nstatic int lm78_isa_remove(struct platform_device *pdev)\r\n{\r\nstruct lm78_data *data = platform_get_drvdata(pdev);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&pdev->dev.kobj, &lm78_group);\r\ndevice_remove_file(&pdev->dev, &dev_attr_name);\r\nreturn 0;\r\n}\r\nstatic int __init lm78_isa_found(unsigned short address)\r\n{\r\nint val, save, found = 0;\r\nint port;\r\nfor (port = address; port < address + LM78_EXTENT; port++) {\r\nif (!request_region(port, 1, "lm78")) {\r\npr_debug("Failed to request port 0x%x\n", port);\r\ngoto release;\r\n}\r\n}\r\n#define REALLY_SLOW_IO\r\nval = inb_p(address + 1);\r\nif (inb_p(address + 2) != val\r\n|| inb_p(address + 3) != val\r\n|| inb_p(address + 7) != val)\r\ngoto release;\r\n#undef REALLY_SLOW_IO\r\nsave = inb_p(address + LM78_ADDR_REG_OFFSET);\r\nif (save & 0x80)\r\ngoto release;\r\nval = ~save & 0x7f;\r\noutb_p(val, address + LM78_ADDR_REG_OFFSET);\r\nif (inb_p(address + LM78_ADDR_REG_OFFSET) != (val | 0x80)) {\r\noutb_p(save, address + LM78_ADDR_REG_OFFSET);\r\ngoto release;\r\n}\r\noutb_p(LM78_REG_CONFIG, address + LM78_ADDR_REG_OFFSET);\r\nval = inb_p(address + LM78_DATA_REG_OFFSET);\r\nif (val & 0x80)\r\ngoto release;\r\noutb_p(LM78_REG_I2C_ADDR, address + LM78_ADDR_REG_OFFSET);\r\nval = inb_p(address + LM78_DATA_REG_OFFSET);\r\nif (val < 0x03 || val > 0x77)\r\ngoto release;\r\nif (inb_p(address + LM78_ADDR_REG_OFFSET) & 0x80)\r\ngoto release;\r\noutb_p(0x4f, address + LM78_ADDR_REG_OFFSET);\r\nval = inb_p(address + LM78_DATA_REG_OFFSET);\r\nif (val == 0xa3 || val == 0x5c)\r\ngoto release;\r\noutb_p(0x58, address + LM78_ADDR_REG_OFFSET);\r\nval = inb_p(address + LM78_DATA_REG_OFFSET);\r\nif (val == 0x90)\r\ngoto release;\r\noutb_p(LM78_REG_CHIPID, address + LM78_ADDR_REG_OFFSET);\r\nval = inb_p(address + LM78_DATA_REG_OFFSET);\r\nif (val == 0x00 || val == 0x20\r\n|| val == 0x40\r\n|| (val & 0xfe) == 0xc0)\r\nfound = 1;\r\nif (found)\r\npr_info("Found an %s chip at %#x\n",\r\nval & 0x80 ? "LM79" : "LM78", (int)address);\r\nrelease:\r\nfor (port--; port >= address; port--)\r\nrelease_region(port, 1);\r\nreturn found;\r\n}\r\nstatic int __init lm78_isa_device_add(unsigned short address)\r\n{\r\nstruct resource res = {\r\n.start = address,\r\n.end = address + LM78_EXTENT - 1,\r\n.name = "lm78",\r\n.flags = IORESOURCE_IO,\r\n};\r\nint err;\r\npdev = platform_device_alloc("lm78", address);\r\nif (!pdev) {\r\nerr = -ENOMEM;\r\npr_err("Device allocation failed\n");\r\ngoto exit;\r\n}\r\nerr = platform_device_add_resources(pdev, &res, 1);\r\nif (err) {\r\npr_err("Device resource addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\npr_err("Device addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(pdev);\r\nexit:\r\npdev = NULL;\r\nreturn err;\r\n}\r\nstatic int __init lm78_isa_register(void)\r\n{\r\nint res;\r\nif (lm78_isa_found(isa_address)) {\r\nres = platform_driver_register(&lm78_isa_driver);\r\nif (res)\r\ngoto exit;\r\nres = lm78_isa_device_add(isa_address);\r\nif (res)\r\ngoto exit_unreg_isa_driver;\r\n}\r\nreturn 0;\r\nexit_unreg_isa_driver:\r\nplatform_driver_unregister(&lm78_isa_driver);\r\nexit:\r\nreturn res;\r\n}\r\nstatic void lm78_isa_unregister(void)\r\n{\r\nif (pdev) {\r\nplatform_device_unregister(pdev);\r\nplatform_driver_unregister(&lm78_isa_driver);\r\n}\r\n}\r\nstatic int __init lm78_isa_register(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void lm78_isa_unregister(void)\r\n{\r\n}\r\nstatic int __init sm_lm78_init(void)\r\n{\r\nint res;\r\nres = lm78_isa_register();\r\nif (res)\r\ngoto exit;\r\nres = i2c_add_driver(&lm78_driver);\r\nif (res)\r\ngoto exit_unreg_isa_device;\r\nreturn 0;\r\nexit_unreg_isa_device:\r\nlm78_isa_unregister();\r\nexit:\r\nreturn res;\r\n}\r\nstatic void __exit sm_lm78_exit(void)\r\n{\r\nlm78_isa_unregister();\r\ni2c_del_driver(&lm78_driver);\r\n}
