void\r\ncsio_reg_rnode(struct csio_rnode *rn)\r\n{\r\nstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\r\nstruct Scsi_Host *shost = csio_ln_to_shost(ln);\r\nstruct fc_rport_identifiers ids;\r\nstruct fc_rport *rport;\r\nstruct csio_service_parms *sp;\r\nids.node_name = wwn_to_u64(csio_rn_wwnn(rn));\r\nids.port_name = wwn_to_u64(csio_rn_wwpn(rn));\r\nids.port_id = rn->nport_id;\r\nids.roles = FC_RPORT_ROLE_UNKNOWN;\r\nif (rn->role & CSIO_RNFR_INITIATOR || rn->role & CSIO_RNFR_TARGET) {\r\nrport = rn->rport;\r\nCSIO_ASSERT(rport != NULL);\r\ngoto update_role;\r\n}\r\nrn->rport = fc_remote_port_add(shost, 0, &ids);\r\nif (!rn->rport) {\r\ncsio_ln_err(ln, "Failed to register rport = 0x%x.\n",\r\nrn->nport_id);\r\nreturn;\r\n}\r\nln->num_reg_rnodes++;\r\nrport = rn->rport;\r\nspin_lock_irq(shost->host_lock);\r\n*((struct csio_rnode **)rport->dd_data) = rn;\r\nspin_unlock_irq(shost->host_lock);\r\nsp = &rn->rn_sparm;\r\nrport->maxframe_size = ntohs(sp->csp.sp_bb_data);\r\nif (ntohs(sp->clsp[2].cp_class) & FC_CPC_VALID)\r\nrport->supported_classes = FC_COS_CLASS3;\r\nelse\r\nrport->supported_classes = FC_COS_UNSPECIFIED;\r\nupdate_role:\r\nif (rn->role & CSIO_RNFR_INITIATOR)\r\nids.roles |= FC_RPORT_ROLE_FCP_INITIATOR;\r\nif (rn->role & CSIO_RNFR_TARGET)\r\nids.roles |= FC_RPORT_ROLE_FCP_TARGET;\r\nif (ids.roles != FC_RPORT_ROLE_UNKNOWN)\r\nfc_remote_port_rolechg(rport, ids.roles);\r\nrn->scsi_id = rport->scsi_target_id;\r\ncsio_ln_dbg(ln, "Remote port x%x role 0x%x registered\n",\r\nrn->nport_id, ids.roles);\r\n}\r\nvoid\r\ncsio_unreg_rnode(struct csio_rnode *rn)\r\n{\r\nstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\r\nstruct fc_rport *rport = rn->rport;\r\nrn->role &= ~(CSIO_RNFR_INITIATOR | CSIO_RNFR_TARGET);\r\nfc_remote_port_delete(rport);\r\nln->num_reg_rnodes--;\r\ncsio_ln_dbg(ln, "Remote port x%x un-registered\n", rn->nport_id);\r\n}\r\nvoid\r\ncsio_lnode_async_event(struct csio_lnode *ln, enum csio_ln_fc_evt fc_evt)\r\n{\r\nswitch (fc_evt) {\r\ncase CSIO_LN_FC_RSCN:\r\nbreak;\r\ncase CSIO_LN_FC_LINKUP:\r\nif (csio_is_npiv_ln(ln))\r\ncsio_vport_set_state(ln);\r\nbreak;\r\ncase CSIO_LN_FC_LINKDOWN:\r\nif (csio_is_npiv_ln(ln))\r\ncsio_vport_set_state(ln);\r\nbreak;\r\ncase CSIO_LN_FC_ATTRIB_UPDATE:\r\ncsio_fchost_attr_init(ln);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid\r\ncsio_fchost_attr_init(struct csio_lnode *ln)\r\n{\r\nstruct Scsi_Host *shost = csio_ln_to_shost(ln);\r\nfc_host_node_name(shost) = wwn_to_u64(csio_ln_wwnn(ln));\r\nfc_host_port_name(shost) = wwn_to_u64(csio_ln_wwpn(ln));\r\nfc_host_supported_classes(shost) = FC_COS_CLASS3;\r\nfc_host_max_npiv_vports(shost) =\r\n(csio_lnode_to_hw(ln))->fres_info.max_vnps;\r\nfc_host_supported_speeds(shost) = FC_PORTSPEED_10GBIT |\r\nFC_PORTSPEED_1GBIT;\r\nfc_host_maxframe_size(shost) = ntohs(ln->ln_sparm.csp.sp_bb_data);\r\nmemset(fc_host_supported_fc4s(shost), 0,\r\nsizeof(fc_host_supported_fc4s(shost)));\r\nfc_host_supported_fc4s(shost)[7] = 1;\r\nmemset(fc_host_active_fc4s(shost), 0,\r\nsizeof(fc_host_active_fc4s(shost)));\r\nfc_host_active_fc4s(shost)[7] = 1;\r\n}\r\nstatic void\r\ncsio_get_host_port_id(struct Scsi_Host *shost)\r\n{\r\nstruct csio_lnode *ln = shost_priv(shost);\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nspin_lock_irq(&hw->lock);\r\nfc_host_port_id(shost) = ln->nport_id;\r\nspin_unlock_irq(&hw->lock);\r\n}\r\nstatic void\r\ncsio_get_host_port_type(struct Scsi_Host *shost)\r\n{\r\nstruct csio_lnode *ln = shost_priv(shost);\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nspin_lock_irq(&hw->lock);\r\nif (csio_is_npiv_ln(ln))\r\nfc_host_port_type(shost) = FC_PORTTYPE_NPIV;\r\nelse\r\nfc_host_port_type(shost) = FC_PORTTYPE_NPORT;\r\nspin_unlock_irq(&hw->lock);\r\n}\r\nstatic void\r\ncsio_get_host_port_state(struct Scsi_Host *shost)\r\n{\r\nstruct csio_lnode *ln = shost_priv(shost);\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nchar state[16];\r\nspin_lock_irq(&hw->lock);\r\ncsio_lnode_state_to_str(ln, state);\r\nif (!strcmp(state, "READY"))\r\nfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\r\nelse if (!strcmp(state, "OFFLINE"))\r\nfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\r\nelse\r\nfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\r\nspin_unlock_irq(&hw->lock);\r\n}\r\nstatic void\r\ncsio_get_host_speed(struct Scsi_Host *shost)\r\n{\r\nstruct csio_lnode *ln = shost_priv(shost);\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nspin_lock_irq(&hw->lock);\r\nswitch (hw->pport[ln->portid].link_speed) {\r\ncase FW_PORT_CAP_SPEED_1G:\r\nfc_host_speed(shost) = FC_PORTSPEED_1GBIT;\r\nbreak;\r\ncase FW_PORT_CAP_SPEED_10G:\r\nfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\r\nbreak;\r\ndefault:\r\nfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\r\nbreak;\r\n}\r\nspin_unlock_irq(&hw->lock);\r\n}\r\nstatic void\r\ncsio_get_host_fabric_name(struct Scsi_Host *shost)\r\n{\r\nstruct csio_lnode *ln = shost_priv(shost);\r\nstruct csio_rnode *rn = NULL;\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nspin_lock_irq(&hw->lock);\r\nrn = csio_rnode_lookup_portid(ln, FC_FID_FLOGI);\r\nif (rn)\r\nfc_host_fabric_name(shost) = wwn_to_u64(csio_rn_wwnn(rn));\r\nelse\r\nfc_host_fabric_name(shost) = 0;\r\nspin_unlock_irq(&hw->lock);\r\n}\r\nstatic struct fc_host_statistics *\r\ncsio_get_stats(struct Scsi_Host *shost)\r\n{\r\nstruct csio_lnode *ln = shost_priv(shost);\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nstruct fc_host_statistics *fhs = &ln->fch_stats;\r\nstruct fw_fcoe_port_stats fcoe_port_stats;\r\nuint64_t seconds;\r\nmemset(&fcoe_port_stats, 0, sizeof(struct fw_fcoe_port_stats));\r\ncsio_get_phy_port_stats(hw, ln->portid, &fcoe_port_stats);\r\nfhs->tx_frames += (be64_to_cpu(fcoe_port_stats.tx_bcast_frames) +\r\nbe64_to_cpu(fcoe_port_stats.tx_mcast_frames) +\r\nbe64_to_cpu(fcoe_port_stats.tx_ucast_frames) +\r\nbe64_to_cpu(fcoe_port_stats.tx_offload_frames));\r\nfhs->tx_words += (be64_to_cpu(fcoe_port_stats.tx_bcast_bytes) +\r\nbe64_to_cpu(fcoe_port_stats.tx_mcast_bytes) +\r\nbe64_to_cpu(fcoe_port_stats.tx_ucast_bytes) +\r\nbe64_to_cpu(fcoe_port_stats.tx_offload_bytes)) /\r\nCSIO_WORD_TO_BYTE;\r\nfhs->rx_frames += (be64_to_cpu(fcoe_port_stats.rx_bcast_frames) +\r\nbe64_to_cpu(fcoe_port_stats.rx_mcast_frames) +\r\nbe64_to_cpu(fcoe_port_stats.rx_ucast_frames));\r\nfhs->rx_words += (be64_to_cpu(fcoe_port_stats.rx_bcast_bytes) +\r\nbe64_to_cpu(fcoe_port_stats.rx_mcast_bytes) +\r\nbe64_to_cpu(fcoe_port_stats.rx_ucast_bytes)) /\r\nCSIO_WORD_TO_BYTE;\r\nfhs->error_frames += be64_to_cpu(fcoe_port_stats.rx_err_frames);\r\nfhs->fcp_input_requests += ln->stats.n_input_requests;\r\nfhs->fcp_output_requests += ln->stats.n_output_requests;\r\nfhs->fcp_control_requests += ln->stats.n_control_requests;\r\nfhs->fcp_input_megabytes += ln->stats.n_input_bytes >> 20;\r\nfhs->fcp_output_megabytes += ln->stats.n_output_bytes >> 20;\r\nfhs->link_failure_count = ln->stats.n_link_down;\r\nseconds = jiffies_to_msecs(jiffies) - hw->stats.n_reset_start;\r\ndo_div(seconds, 1000);\r\nfhs->seconds_since_last_reset = seconds;\r\nreturn fhs;\r\n}\r\nstatic void\r\ncsio_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout)\r\n{\r\nif (timeout)\r\nrport->dev_loss_tmo = timeout;\r\nelse\r\nrport->dev_loss_tmo = 1;\r\n}\r\nstatic void\r\ncsio_vport_set_state(struct csio_lnode *ln)\r\n{\r\nstruct fc_vport *fc_vport = ln->fc_vport;\r\nstruct csio_lnode *pln = ln->pln;\r\nchar state[16];\r\ncsio_lnode_state_to_str(pln, state);\r\nif (strcmp(state, "READY")) {\r\nfc_vport_set_state(fc_vport, FC_VPORT_LINKDOWN);\r\nreturn;\r\n}\r\nif (!(pln->flags & CSIO_LNF_NPIVSUPP)) {\r\nfc_vport_set_state(fc_vport, FC_VPORT_NO_FABRIC_SUPP);\r\nreturn;\r\n}\r\ncsio_lnode_state_to_str(ln, state);\r\nif (strcmp(state, "READY")) {\r\nfc_vport_set_state(fc_vport, FC_VPORT_LINKDOWN);\r\nreturn;\r\n}\r\nfc_vport_set_state(fc_vport, FC_VPORT_ACTIVE);\r\n}\r\nstatic int\r\ncsio_fcoe_alloc_vnp(struct csio_hw *hw, struct csio_lnode *ln)\r\n{\r\nstruct csio_lnode *pln;\r\nstruct csio_mb *mbp;\r\nstruct fw_fcoe_vnp_cmd *rsp;\r\nint ret = 0;\r\nint retry = 0;\r\nspin_lock_irq(&hw->lock);\r\nmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\r\nif (!mbp) {\r\nCSIO_INC_STATS(hw, n_err_nomem);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npln = ln->pln;\r\nln->fcf_flowid = pln->fcf_flowid;\r\nln->portid = pln->portid;\r\ncsio_fcoe_vnp_alloc_init_mb(ln, mbp, CSIO_MB_DEFAULT_TMO,\r\npln->fcf_flowid, pln->vnp_flowid, 0,\r\ncsio_ln_wwnn(ln), csio_ln_wwpn(ln), NULL);\r\nfor (retry = 0; retry < 3; retry++) {\r\nret = csio_mb_issue(hw, mbp);\r\nif (ret != -EBUSY)\r\nbreak;\r\nspin_unlock_irq(&hw->lock);\r\nmsleep(2000);\r\nspin_lock_irq(&hw->lock);\r\n}\r\nif (ret) {\r\ncsio_ln_err(ln, "Failed to issue mbox FCoE VNP command\n");\r\ngoto out_free;\r\n}\r\nrsp = (struct fw_fcoe_vnp_cmd *)(mbp->mb);\r\nif (FW_CMD_RETVAL_GET(ntohl(rsp->alloc_to_len16)) != FW_SUCCESS) {\r\ncsio_ln_err(ln, "FCOE VNP ALLOC cmd returned 0x%x!\n",\r\nFW_CMD_RETVAL_GET(ntohl(rsp->alloc_to_len16)));\r\nret = -EINVAL;\r\ngoto out_free;\r\n}\r\nln->vnp_flowid = FW_FCOE_VNP_CMD_VNPI_GET(\r\nntohl(rsp->gen_wwn_to_vnpi));\r\nmemcpy(csio_ln_wwnn(ln), rsp->vnport_wwnn, 8);\r\nmemcpy(csio_ln_wwpn(ln), rsp->vnport_wwpn, 8);\r\ncsio_ln_dbg(ln, "FCOE VNPI: 0x%x\n", ln->vnp_flowid);\r\ncsio_ln_dbg(ln, "\tWWNN: %x%x%x%x%x%x%x%x\n",\r\nln->ln_sparm.wwnn[0], ln->ln_sparm.wwnn[1],\r\nln->ln_sparm.wwnn[2], ln->ln_sparm.wwnn[3],\r\nln->ln_sparm.wwnn[4], ln->ln_sparm.wwnn[5],\r\nln->ln_sparm.wwnn[6], ln->ln_sparm.wwnn[7]);\r\ncsio_ln_dbg(ln, "\tWWPN: %x%x%x%x%x%x%x%x\n",\r\nln->ln_sparm.wwpn[0], ln->ln_sparm.wwpn[1],\r\nln->ln_sparm.wwpn[2], ln->ln_sparm.wwpn[3],\r\nln->ln_sparm.wwpn[4], ln->ln_sparm.wwpn[5],\r\nln->ln_sparm.wwpn[6], ln->ln_sparm.wwpn[7]);\r\nout_free:\r\nmempool_free(mbp, hw->mb_mempool);\r\nout:\r\nspin_unlock_irq(&hw->lock);\r\nreturn ret;\r\n}\r\nstatic int\r\ncsio_fcoe_free_vnp(struct csio_hw *hw, struct csio_lnode *ln)\r\n{\r\nstruct csio_lnode *pln;\r\nstruct csio_mb *mbp;\r\nstruct fw_fcoe_vnp_cmd *rsp;\r\nint ret = 0;\r\nint retry = 0;\r\nspin_lock_irq(&hw->lock);\r\nmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\r\nif (!mbp) {\r\nCSIO_INC_STATS(hw, n_err_nomem);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npln = ln->pln;\r\ncsio_fcoe_vnp_free_init_mb(ln, mbp, CSIO_MB_DEFAULT_TMO,\r\nln->fcf_flowid, ln->vnp_flowid,\r\nNULL);\r\nfor (retry = 0; retry < 3; retry++) {\r\nret = csio_mb_issue(hw, mbp);\r\nif (ret != -EBUSY)\r\nbreak;\r\nspin_unlock_irq(&hw->lock);\r\nmsleep(2000);\r\nspin_lock_irq(&hw->lock);\r\n}\r\nif (ret) {\r\ncsio_ln_err(ln, "Failed to issue mbox FCoE VNP command\n");\r\ngoto out_free;\r\n}\r\nrsp = (struct fw_fcoe_vnp_cmd *)(mbp->mb);\r\nif (FW_CMD_RETVAL_GET(ntohl(rsp->alloc_to_len16)) != FW_SUCCESS) {\r\ncsio_ln_err(ln, "FCOE VNP FREE cmd returned 0x%x!\n",\r\nFW_CMD_RETVAL_GET(ntohl(rsp->alloc_to_len16)));\r\nret = -EINVAL;\r\n}\r\nout_free:\r\nmempool_free(mbp, hw->mb_mempool);\r\nout:\r\nspin_unlock_irq(&hw->lock);\r\nreturn ret;\r\n}\r\nstatic int\r\ncsio_vport_create(struct fc_vport *fc_vport, bool disable)\r\n{\r\nstruct Scsi_Host *shost = fc_vport->shost;\r\nstruct csio_lnode *pln = shost_priv(shost);\r\nstruct csio_lnode *ln = NULL;\r\nstruct csio_hw *hw = csio_lnode_to_hw(pln);\r\nuint8_t wwn[8];\r\nint ret = -1;\r\nln = csio_shost_init(hw, &fc_vport->dev, false, pln);\r\nif (!ln)\r\ngoto error;\r\nif (fc_vport->node_name != 0) {\r\nu64_to_wwn(fc_vport->node_name, wwn);\r\nif (!CSIO_VALID_WWN(wwn)) {\r\ncsio_ln_err(ln,\r\n"vport create failed. Invalid wwnn\n");\r\ngoto error;\r\n}\r\nmemcpy(csio_ln_wwnn(ln), wwn, 8);\r\n}\r\nif (fc_vport->port_name != 0) {\r\nu64_to_wwn(fc_vport->port_name, wwn);\r\nif (!CSIO_VALID_WWN(wwn)) {\r\ncsio_ln_err(ln,\r\n"vport create failed. Invalid wwpn\n");\r\ngoto error;\r\n}\r\nif (csio_lnode_lookup_by_wwpn(hw, wwn)) {\r\ncsio_ln_err(ln,\r\n"vport create failed. wwpn already exists\n");\r\ngoto error;\r\n}\r\nmemcpy(csio_ln_wwpn(ln), wwn, 8);\r\n}\r\nfc_vport_set_state(fc_vport, FC_VPORT_INITIALIZING);\r\nif (csio_fcoe_alloc_vnp(hw, ln))\r\ngoto error;\r\n*(struct csio_lnode **)fc_vport->dd_data = ln;\r\nln->fc_vport = fc_vport;\r\nif (!fc_vport->node_name)\r\nfc_vport->node_name = wwn_to_u64(csio_ln_wwnn(ln));\r\nif (!fc_vport->port_name)\r\nfc_vport->port_name = wwn_to_u64(csio_ln_wwpn(ln));\r\ncsio_fchost_attr_init(ln);\r\nreturn 0;\r\nerror:\r\nif (ln)\r\ncsio_shost_exit(ln);\r\nreturn ret;\r\n}\r\nstatic int\r\ncsio_vport_delete(struct fc_vport *fc_vport)\r\n{\r\nstruct csio_lnode *ln = *(struct csio_lnode **)fc_vport->dd_data;\r\nstruct Scsi_Host *shost = csio_ln_to_shost(ln);\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nint rmv;\r\nspin_lock_irq(&hw->lock);\r\nrmv = csio_is_hw_removing(hw);\r\nspin_unlock_irq(&hw->lock);\r\nif (rmv) {\r\ncsio_shost_exit(ln);\r\nreturn 0;\r\n}\r\nscsi_block_requests(shost);\r\nspin_lock_irq(&hw->lock);\r\ncsio_scsim_cleanup_io_lnode(csio_hw_to_scsim(hw), ln);\r\ncsio_lnode_close(ln);\r\nspin_unlock_irq(&hw->lock);\r\nscsi_unblock_requests(shost);\r\nif (fc_vport->vport_state != FC_VPORT_DISABLED)\r\ncsio_fcoe_free_vnp(hw, ln);\r\ncsio_shost_exit(ln);\r\nreturn 0;\r\n}\r\nstatic int\r\ncsio_vport_disable(struct fc_vport *fc_vport, bool disable)\r\n{\r\nstruct csio_lnode *ln = *(struct csio_lnode **)fc_vport->dd_data;\r\nstruct Scsi_Host *shost = csio_ln_to_shost(ln);\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nif (disable) {\r\nscsi_block_requests(shost);\r\nspin_lock_irq(&hw->lock);\r\ncsio_scsim_cleanup_io_lnode(csio_hw_to_scsim(hw), ln);\r\ncsio_lnode_stop(ln);\r\nspin_unlock_irq(&hw->lock);\r\nscsi_unblock_requests(shost);\r\ncsio_fcoe_free_vnp(hw, ln);\r\nfc_vport_set_state(fc_vport, FC_VPORT_DISABLED);\r\ncsio_ln_err(ln, "vport disabled\n");\r\nreturn 0;\r\n} else {\r\nfc_vport_set_state(fc_vport, FC_VPORT_INITIALIZING);\r\nif (csio_fcoe_alloc_vnp(hw, ln)) {\r\ncsio_ln_err(ln, "vport enabled failed.\n");\r\nreturn -1;\r\n}\r\ncsio_ln_err(ln, "vport enabled\n");\r\nreturn 0;\r\n}\r\n}\r\nstatic void\r\ncsio_dev_loss_tmo_callbk(struct fc_rport *rport)\r\n{\r\nstruct csio_rnode *rn;\r\nstruct csio_hw *hw;\r\nstruct csio_lnode *ln;\r\nrn = *((struct csio_rnode **)rport->dd_data);\r\nln = csio_rnode_to_lnode(rn);\r\nhw = csio_lnode_to_hw(ln);\r\nspin_lock_irq(&hw->lock);\r\nif (csio_is_hw_removing(hw) || csio_is_rnode_ready(rn))\r\ngoto out;\r\ncsio_ln_dbg(ln, "devloss timeout on rnode:%p portid:x%x flowid:x%x\n",\r\nrn, rn->nport_id, csio_rn_flowid(rn));\r\nCSIO_INC_STATS(ln, n_dev_loss_tmo);\r\nif (csio_enqueue_evt(hw, CSIO_EVT_DEV_LOSS, &rn, sizeof(rn))) {\r\nCSIO_INC_STATS(hw, n_evt_drop);\r\ngoto out;\r\n}\r\nif (!(hw->flags & CSIO_HWF_FWEVT_PENDING)) {\r\nhw->flags |= CSIO_HWF_FWEVT_PENDING;\r\nspin_unlock_irq(&hw->lock);\r\nschedule_work(&hw->evtq_work);\r\nreturn;\r\n}\r\nout:\r\nspin_unlock_irq(&hw->lock);\r\n}
