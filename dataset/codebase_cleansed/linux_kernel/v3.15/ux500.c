static void ux500_musb_set_vbus(struct musb *musb, int is_on)\r\n{\r\nu8 devctl;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif (is_on) {\r\nif (musb->xceiv->state == OTG_STATE_A_IDLE) {\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\nwhile (musb_readb(musb->mregs, MUSB_DEVCTL) & 0x80) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(musb->controller,\r\n"configured as A device timeout");\r\nbreak;\r\n}\r\n}\r\n} else {\r\nmusb->is_active = 1;\r\nmusb->xceiv->otg->default_a = 1;\r\nmusb->xceiv->state = OTG_STATE_A_WAIT_VRISE;\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\nMUSB_HST_MODE(musb);\r\n}\r\n} else {\r\nmusb->is_active = 0;\r\nmusb->xceiv->otg->default_a = 0;\r\ndevctl &= ~MUSB_DEVCTL_SESSION;\r\nMUSB_DEV_MODE(musb);\r\n}\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\nif (!is_on)\r\nmdelay(200);\r\ndev_dbg(musb->controller, "VBUS %s, devctl %02x\n",\r\nusb_otg_state_string(musb->xceiv->state),\r\nmusb_readb(musb->mregs, MUSB_DEVCTL));\r\n}\r\nstatic int musb_otg_notifications(struct notifier_block *nb,\r\nunsigned long event, void *unused)\r\n{\r\nstruct musb *musb = container_of(nb, struct musb, nb);\r\ndev_dbg(musb->controller, "musb_otg_notifications %ld %s\n",\r\nevent, usb_otg_state_string(musb->xceiv->state));\r\nswitch (event) {\r\ncase UX500_MUSB_ID:\r\ndev_dbg(musb->controller, "ID GND\n");\r\nux500_musb_set_vbus(musb, 1);\r\nbreak;\r\ncase UX500_MUSB_VBUS:\r\ndev_dbg(musb->controller, "VBUS Connect\n");\r\nbreak;\r\ncase UX500_MUSB_NONE:\r\ndev_dbg(musb->controller, "VBUS Disconnect\n");\r\nif (is_host_active(musb))\r\nux500_musb_set_vbus(musb, 0);\r\nelse\r\nmusb->xceiv->state = OTG_STATE_B_IDLE;\r\nbreak;\r\ndefault:\r\ndev_dbg(musb->controller, "ID float\n");\r\nreturn NOTIFY_DONE;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic irqreturn_t ux500_musb_interrupt(int irq, void *__hci)\r\n{\r\nunsigned long flags;\r\nirqreturn_t retval = IRQ_NONE;\r\nstruct musb *musb = __hci;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nmusb->int_usb = musb_readb(musb->mregs, MUSB_INTRUSB);\r\nmusb->int_tx = musb_readw(musb->mregs, MUSB_INTRTX);\r\nmusb->int_rx = musb_readw(musb->mregs, MUSB_INTRRX);\r\nif (musb->int_usb || musb->int_tx || musb->int_rx)\r\nretval = musb_interrupt(musb);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int ux500_musb_init(struct musb *musb)\r\n{\r\nint status;\r\nmusb->xceiv = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (IS_ERR_OR_NULL(musb->xceiv)) {\r\npr_err("HS USB OTG: no transceiver configured\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\nmusb->nb.notifier_call = musb_otg_notifications;\r\nstatus = usb_register_notifier(musb->xceiv, &musb->nb);\r\nif (status < 0) {\r\ndev_dbg(musb->controller, "notification register failed\n");\r\nreturn status;\r\n}\r\nmusb->isr = ux500_musb_interrupt;\r\nreturn 0;\r\n}\r\nstatic int ux500_musb_exit(struct musb *musb)\r\n{\r\nusb_unregister_notifier(musb->xceiv, &musb->nb);\r\nusb_put_phy(musb->xceiv);\r\nreturn 0;\r\n}\r\nstatic struct musb_hdrc_platform_data *\r\nux500_of_probe(struct platform_device *pdev, struct device_node *np)\r\n{\r\nstruct musb_hdrc_platform_data *pdata;\r\nconst char *mode;\r\nint strlen;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nmode = of_get_property(np, "dr_mode", &strlen);\r\nif (!mode) {\r\ndev_err(&pdev->dev, "No 'dr_mode' property found\n");\r\nreturn NULL;\r\n}\r\nif (strlen > 0) {\r\nif (!strcmp(mode, "host"))\r\npdata->mode = MUSB_HOST;\r\nif (!strcmp(mode, "otg"))\r\npdata->mode = MUSB_OTG;\r\nif (!strcmp(mode, "peripheral"))\r\npdata->mode = MUSB_PERIPHERAL;\r\n}\r\nreturn pdata;\r\n}\r\nstatic int ux500_probe(struct platform_device *pdev)\r\n{\r\nstruct resource musb_resources[2];\r\nstruct musb_hdrc_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct platform_device *musb;\r\nstruct ux500_glue *glue;\r\nstruct clk *clk;\r\nint ret = -ENOMEM;\r\nif (!pdata) {\r\nif (np) {\r\npdata = ux500_of_probe(pdev, np);\r\nif (!pdata)\r\ngoto err0;\r\npdev->dev.platform_data = pdata;\r\n} else {\r\ndev_err(&pdev->dev, "no pdata or device tree found\n");\r\ngoto err0;\r\n}\r\n}\r\nglue = kzalloc(sizeof(*glue), GFP_KERNEL);\r\nif (!glue) {\r\ndev_err(&pdev->dev, "failed to allocate glue context\n");\r\ngoto err0;\r\n}\r\nmusb = platform_device_alloc("musb-hdrc", PLATFORM_DEVID_AUTO);\r\nif (!musb) {\r\ndev_err(&pdev->dev, "failed to allocate musb device\n");\r\ngoto err1;\r\n}\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nret = PTR_ERR(clk);\r\ngoto err3;\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable clock\n");\r\ngoto err4;\r\n}\r\nmusb->dev.parent = &pdev->dev;\r\nmusb->dev.dma_mask = &pdev->dev.coherent_dma_mask;\r\nmusb->dev.coherent_dma_mask = pdev->dev.coherent_dma_mask;\r\nmusb->dev.of_node = pdev->dev.of_node;\r\nglue->dev = &pdev->dev;\r\nglue->musb = musb;\r\nglue->clk = clk;\r\npdata->platform_ops = &ux500_ops;\r\npdata->config = &ux500_musb_hdrc_config;\r\nplatform_set_drvdata(pdev, glue);\r\nmemset(musb_resources, 0x00, sizeof(*musb_resources) *\r\nARRAY_SIZE(musb_resources));\r\nmusb_resources[0].name = pdev->resource[0].name;\r\nmusb_resources[0].start = pdev->resource[0].start;\r\nmusb_resources[0].end = pdev->resource[0].end;\r\nmusb_resources[0].flags = pdev->resource[0].flags;\r\nmusb_resources[1].name = pdev->resource[1].name;\r\nmusb_resources[1].start = pdev->resource[1].start;\r\nmusb_resources[1].end = pdev->resource[1].end;\r\nmusb_resources[1].flags = pdev->resource[1].flags;\r\nret = platform_device_add_resources(musb, musb_resources,\r\nARRAY_SIZE(musb_resources));\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add resources\n");\r\ngoto err5;\r\n}\r\nret = platform_device_add_data(musb, pdata, sizeof(*pdata));\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add platform_data\n");\r\ngoto err5;\r\n}\r\nret = platform_device_add(musb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register musb device\n");\r\ngoto err5;\r\n}\r\nreturn 0;\r\nerr5:\r\nclk_disable_unprepare(clk);\r\nerr4:\r\nclk_put(clk);\r\nerr3:\r\nplatform_device_put(musb);\r\nerr1:\r\nkfree(glue);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int ux500_remove(struct platform_device *pdev)\r\n{\r\nstruct ux500_glue *glue = platform_get_drvdata(pdev);\r\nplatform_device_unregister(glue->musb);\r\nclk_disable_unprepare(glue->clk);\r\nclk_put(glue->clk);\r\nkfree(glue);\r\nreturn 0;\r\n}\r\nstatic int ux500_suspend(struct device *dev)\r\n{\r\nstruct ux500_glue *glue = dev_get_drvdata(dev);\r\nstruct musb *musb = glue_to_musb(glue);\r\nusb_phy_set_suspend(musb->xceiv, 1);\r\nclk_disable_unprepare(glue->clk);\r\nreturn 0;\r\n}\r\nstatic int ux500_resume(struct device *dev)\r\n{\r\nstruct ux500_glue *glue = dev_get_drvdata(dev);\r\nstruct musb *musb = glue_to_musb(glue);\r\nint ret;\r\nret = clk_prepare_enable(glue->clk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable clock\n");\r\nreturn ret;\r\n}\r\nusb_phy_set_suspend(musb->xceiv, 0);\r\nreturn 0;\r\n}
