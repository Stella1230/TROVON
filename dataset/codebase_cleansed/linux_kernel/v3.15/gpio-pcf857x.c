static int i2c_write_le8(struct i2c_client *client, unsigned data)\r\n{\r\nreturn i2c_smbus_write_byte(client, data);\r\n}\r\nstatic int i2c_read_le8(struct i2c_client *client)\r\n{\r\nreturn (int)i2c_smbus_read_byte(client);\r\n}\r\nstatic int i2c_write_le16(struct i2c_client *client, unsigned word)\r\n{\r\nu8 buf[2] = { word & 0xff, word >> 8, };\r\nint status;\r\nstatus = i2c_master_send(client, buf, 2);\r\nreturn (status < 0) ? status : 0;\r\n}\r\nstatic int i2c_read_le16(struct i2c_client *client)\r\n{\r\nu8 buf[2];\r\nint status;\r\nstatus = i2c_master_recv(client, buf, 2);\r\nif (status < 0)\r\nreturn status;\r\nreturn (buf[1] << 8) | buf[0];\r\n}\r\nstatic int pcf857x_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\nint status;\r\nmutex_lock(&gpio->lock);\r\ngpio->out |= (1 << offset);\r\nstatus = gpio->write(gpio->client, gpio->out);\r\nmutex_unlock(&gpio->lock);\r\nreturn status;\r\n}\r\nstatic int pcf857x_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\nint value;\r\nvalue = gpio->read(gpio->client);\r\nreturn (value < 0) ? 0 : (value & (1 << offset));\r\n}\r\nstatic int pcf857x_output(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\nunsigned bit = 1 << offset;\r\nint status;\r\nmutex_lock(&gpio->lock);\r\nif (value)\r\ngpio->out |= bit;\r\nelse\r\ngpio->out &= ~bit;\r\nstatus = gpio->write(gpio->client, gpio->out);\r\nmutex_unlock(&gpio->lock);\r\nreturn status;\r\n}\r\nstatic void pcf857x_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\npcf857x_output(chip, offset, value);\r\n}\r\nstatic int pcf857x_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\nint ret;\r\nret = irq_create_mapping(gpio->irq_domain, offset);\r\nif (ret > 0)\r\ngpio->irq_mapped |= (1 << offset);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t pcf857x_irq(int irq, void *data)\r\n{\r\nstruct pcf857x *gpio = data;\r\nunsigned long change, i, status, flags;\r\nstatus = gpio->read(gpio->client);\r\nspin_lock_irqsave(&gpio->slock, flags);\r\nchange = ((gpio->status ^ status) & gpio->irq_mapped);\r\nfor_each_set_bit(i, &change, gpio->chip.ngpio)\r\ngeneric_handle_irq(irq_find_mapping(gpio->irq_domain, i));\r\ngpio->status = status;\r\nspin_unlock_irqrestore(&gpio->slock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pcf857x_irq_domain_map(struct irq_domain *domain, unsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct pcf857x *gpio = domain->host_data;\r\nirq_set_chip_and_handler(irq,\r\n&dummy_irq_chip,\r\nhandle_level_irq);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(irq);\r\n#endif\r\ngpio->irq_mapped |= (1 << hw);\r\nreturn 0;\r\n}\r\nstatic void pcf857x_irq_domain_cleanup(struct pcf857x *gpio)\r\n{\r\nif (gpio->irq_domain)\r\nirq_domain_remove(gpio->irq_domain);\r\n}\r\nstatic int pcf857x_irq_domain_init(struct pcf857x *gpio,\r\nstruct i2c_client *client)\r\n{\r\nint status;\r\ngpio->irq_domain = irq_domain_add_linear(client->dev.of_node,\r\ngpio->chip.ngpio,\r\n&pcf857x_irq_domain_ops,\r\ngpio);\r\nif (!gpio->irq_domain)\r\ngoto fail;\r\nstatus = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, pcf857x_irq, IRQF_ONESHOT |\r\nIRQF_TRIGGER_FALLING,\r\ndev_name(&client->dev), gpio);\r\nif (status)\r\ngoto fail;\r\ngpio->chip.to_irq = pcf857x_to_irq;\r\nreturn 0;\r\nfail:\r\npcf857x_irq_domain_cleanup(gpio);\r\nreturn -EINVAL;\r\n}\r\nstatic int pcf857x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pcf857x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct device_node *np = client->dev.of_node;\r\nstruct pcf857x *gpio;\r\nunsigned int n_latch = 0;\r\nint status;\r\nif (IS_ENABLED(CONFIG_OF) && np)\r\nof_property_read_u32(np, "lines-initial-states", &n_latch);\r\nelse if (pdata)\r\nn_latch = pdata->n_latch;\r\nelse\r\ndev_dbg(&client->dev, "no platform data\n");\r\ngpio = devm_kzalloc(&client->dev, sizeof(*gpio), GFP_KERNEL);\r\nif (!gpio)\r\nreturn -ENOMEM;\r\nmutex_init(&gpio->lock);\r\nspin_lock_init(&gpio->slock);\r\ngpio->chip.base = pdata ? pdata->gpio_base : -1;\r\ngpio->chip.can_sleep = true;\r\ngpio->chip.dev = &client->dev;\r\ngpio->chip.owner = THIS_MODULE;\r\ngpio->chip.get = pcf857x_get;\r\ngpio->chip.set = pcf857x_set;\r\ngpio->chip.direction_input = pcf857x_input;\r\ngpio->chip.direction_output = pcf857x_output;\r\ngpio->chip.ngpio = id->driver_data;\r\nif (client->irq) {\r\nstatus = pcf857x_irq_domain_init(gpio, client);\r\nif (status < 0) {\r\ndev_err(&client->dev, "irq_domain init failed\n");\r\ngoto fail;\r\n}\r\n}\r\nif (gpio->chip.ngpio == 8) {\r\ngpio->write = i2c_write_le8;\r\ngpio->read = i2c_read_le8;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE))\r\nstatus = -EIO;\r\nelse\r\nstatus = i2c_smbus_read_byte(client);\r\n} else if (gpio->chip.ngpio == 16) {\r\ngpio->write = i2c_write_le16;\r\ngpio->read = i2c_read_le16;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nstatus = -EIO;\r\nelse\r\nstatus = i2c_read_le16(client);\r\n} else {\r\ndev_dbg(&client->dev, "unsupported number of gpios\n");\r\nstatus = -EINVAL;\r\n}\r\nif (status < 0)\r\ngoto fail;\r\ngpio->chip.label = client->name;\r\ngpio->client = client;\r\ni2c_set_clientdata(client, gpio);\r\ngpio->out = ~n_latch;\r\ngpio->status = gpio->out;\r\nstatus = gpiochip_add(&gpio->chip);\r\nif (status < 0)\r\ngoto fail;\r\nif (pdata && pdata->setup) {\r\nstatus = pdata->setup(client,\r\ngpio->chip.base, gpio->chip.ngpio,\r\npdata->context);\r\nif (status < 0)\r\ndev_warn(&client->dev, "setup --> %d\n", status);\r\n}\r\ndev_info(&client->dev, "probed\n");\r\nreturn 0;\r\nfail:\r\ndev_dbg(&client->dev, "probe error %d for '%s'\n",\r\nstatus, client->name);\r\nif (client->irq)\r\npcf857x_irq_domain_cleanup(gpio);\r\nreturn status;\r\n}\r\nstatic int pcf857x_remove(struct i2c_client *client)\r\n{\r\nstruct pcf857x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct pcf857x *gpio = i2c_get_clientdata(client);\r\nint status = 0;\r\nif (pdata && pdata->teardown) {\r\nstatus = pdata->teardown(client,\r\ngpio->chip.base, gpio->chip.ngpio,\r\npdata->context);\r\nif (status < 0) {\r\ndev_err(&client->dev, "%s --> %d\n",\r\n"teardown", status);\r\nreturn status;\r\n}\r\n}\r\nif (client->irq)\r\npcf857x_irq_domain_cleanup(gpio);\r\nstatus = gpiochip_remove(&gpio->chip);\r\nif (status)\r\ndev_err(&client->dev, "%s --> %d\n", "remove", status);\r\nreturn status;\r\n}\r\nstatic int __init pcf857x_init(void)\r\n{\r\nreturn i2c_add_driver(&pcf857x_driver);\r\n}\r\nstatic void __exit pcf857x_exit(void)\r\n{\r\ni2c_del_driver(&pcf857x_driver);\r\n}
