static int key_create_persistent_register(struct user_namespace *ns)\r\n{\r\nstruct key *reg = keyring_alloc(".persistent_register",\r\nKUIDT_INIT(0), KGIDT_INIT(0),\r\ncurrent_cred(),\r\n((KEY_POS_ALL & ~KEY_POS_SETATTR) |\r\nKEY_USR_VIEW | KEY_USR_READ),\r\nKEY_ALLOC_NOT_IN_QUOTA, NULL);\r\nif (IS_ERR(reg))\r\nreturn PTR_ERR(reg);\r\nns->persistent_keyring_register = reg;\r\nreturn 0;\r\n}\r\nstatic key_ref_t key_create_persistent(struct user_namespace *ns, kuid_t uid,\r\nstruct keyring_index_key *index_key)\r\n{\r\nstruct key *persistent;\r\nkey_ref_t reg_ref, persistent_ref;\r\nif (!ns->persistent_keyring_register) {\r\nlong err = key_create_persistent_register(ns);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\n} else {\r\nreg_ref = make_key_ref(ns->persistent_keyring_register, true);\r\npersistent_ref = find_key_to_update(reg_ref, index_key);\r\nif (persistent_ref)\r\nreturn persistent_ref;\r\n}\r\npersistent = keyring_alloc(index_key->description,\r\nuid, INVALID_GID, current_cred(),\r\n((KEY_POS_ALL & ~KEY_POS_SETATTR) |\r\nKEY_USR_VIEW | KEY_USR_READ),\r\nKEY_ALLOC_NOT_IN_QUOTA,\r\nns->persistent_keyring_register);\r\nif (IS_ERR(persistent))\r\nreturn ERR_CAST(persistent);\r\nreturn make_key_ref(persistent, true);\r\n}\r\nstatic long key_get_persistent(struct user_namespace *ns, kuid_t uid,\r\nkey_ref_t dest_ref)\r\n{\r\nstruct keyring_index_key index_key;\r\nstruct key *persistent;\r\nkey_ref_t reg_ref, persistent_ref;\r\nchar buf[32];\r\nlong ret;\r\nindex_key.type = &key_type_keyring;\r\nindex_key.description = buf;\r\nindex_key.desc_len = sprintf(buf, "_persistent.%u", from_kuid(ns, uid));\r\nif (ns->persistent_keyring_register) {\r\nreg_ref = make_key_ref(ns->persistent_keyring_register, true);\r\ndown_read(&ns->persistent_keyring_register_sem);\r\npersistent_ref = find_key_to_update(reg_ref, &index_key);\r\nup_read(&ns->persistent_keyring_register_sem);\r\nif (persistent_ref)\r\ngoto found;\r\n}\r\ndown_write(&ns->persistent_keyring_register_sem);\r\npersistent_ref = key_create_persistent(ns, uid, &index_key);\r\nup_write(&ns->persistent_keyring_register_sem);\r\nif (!IS_ERR(persistent_ref))\r\ngoto found;\r\nreturn PTR_ERR(persistent_ref);\r\nfound:\r\nret = key_task_permission(persistent_ref, current_cred(), KEY_LINK);\r\nif (ret == 0) {\r\npersistent = key_ref_to_ptr(persistent_ref);\r\nret = key_link(key_ref_to_ptr(dest_ref), persistent);\r\nif (ret == 0) {\r\nkey_set_timeout(persistent, persistent_keyring_expiry);\r\nret = persistent->serial;\r\n}\r\n}\r\nkey_ref_put(persistent_ref);\r\nreturn ret;\r\n}\r\nlong keyctl_get_persistent(uid_t _uid, key_serial_t destid)\r\n{\r\nstruct user_namespace *ns = current_user_ns();\r\nkey_ref_t dest_ref;\r\nkuid_t uid;\r\nlong ret;\r\nif (_uid == (uid_t)-1) {\r\nuid = current_uid();\r\n} else {\r\nuid = make_kuid(ns, _uid);\r\nif (!uid_valid(uid))\r\nreturn -EINVAL;\r\nif (!uid_eq(uid, current_uid()) &&\r\n!uid_eq(uid, current_euid()) &&\r\n!ns_capable(ns, CAP_SETUID))\r\nreturn -EPERM;\r\n}\r\ndest_ref = lookup_user_key(destid, KEY_LOOKUP_CREATE, KEY_WRITE);\r\nif (IS_ERR(dest_ref))\r\nreturn PTR_ERR(dest_ref);\r\nif (key_ref_to_ptr(dest_ref)->type != &key_type_keyring) {\r\nret = -ENOTDIR;\r\ngoto out_put_dest;\r\n}\r\nret = key_get_persistent(ns, uid, dest_ref);\r\nout_put_dest:\r\nkey_ref_put(dest_ref);\r\nreturn ret;\r\n}
