static irqreturn_t rtc_update_handler(int irq, void *data)\r\n{\r\nstruct pm860x_rtc_info *info = (struct pm860x_rtc_info *)data;\r\nint mask;\r\nmask = ALARM | ALARM_WAKEUP;\r\npm860x_set_bits(info->i2c, PM8607_RTC1, mask | ALARM_EN, mask);\r\nrtc_update_irq(info->rtc_dev, 1, RTC_AF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pm860x_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct pm860x_rtc_info *info = dev_get_drvdata(dev);\r\nif (enabled)\r\npm860x_set_bits(info->i2c, PM8607_RTC1, ALARM_EN, ALARM_EN);\r\nelse\r\npm860x_set_bits(info->i2c, PM8607_RTC1, ALARM_EN, 0);\r\nreturn 0;\r\n}\r\nstatic void rtc_next_alarm_time(struct rtc_time *next, struct rtc_time *now,\r\nstruct rtc_time *alrm)\r\n{\r\nunsigned long next_time;\r\nunsigned long now_time;\r\nnext->tm_year = now->tm_year;\r\nnext->tm_mon = now->tm_mon;\r\nnext->tm_mday = now->tm_mday;\r\nnext->tm_hour = alrm->tm_hour;\r\nnext->tm_min = alrm->tm_min;\r\nnext->tm_sec = alrm->tm_sec;\r\nrtc_tm_to_time(now, &now_time);\r\nrtc_tm_to_time(next, &next_time);\r\nif (next_time < now_time) {\r\nnext_time += 60 * 60 * 24;\r\nrtc_time_to_tm(next_time, next);\r\n}\r\n}\r\nstatic int pm860x_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct pm860x_rtc_info *info = dev_get_drvdata(dev);\r\nunsigned char buf[8];\r\nunsigned long ticks, base, data;\r\npm860x_page_bulk_read(info->i2c, REG0_ADDR, 8, buf);\r\ndev_dbg(info->dev, "%x-%x-%x-%x-%x-%x-%x-%x\n", buf[0], buf[1],\r\nbuf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);\r\nbase = (buf[1] << 24) | (buf[3] << 16) | (buf[5] << 8) | buf[7];\r\npm860x_bulk_read(info->i2c, PM8607_RTC_COUNTER1, 4, buf);\r\ndata = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\nticks = base + data;\r\ndev_dbg(info->dev, "get base:0x%lx, RO count:0x%lx, ticks:0x%lx\n",\r\nbase, data, ticks);\r\nrtc_time_to_tm(ticks, tm);\r\nreturn 0;\r\n}\r\nstatic int pm860x_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct pm860x_rtc_info *info = dev_get_drvdata(dev);\r\nunsigned char buf[4];\r\nunsigned long ticks, base, data;\r\nif ((tm->tm_year < 70) || (tm->tm_year > 138)) {\r\ndev_dbg(info->dev, "Set time %d out of range. "\r\n"Please set time between 1970 to 2038.\n",\r\n1900 + tm->tm_year);\r\nreturn -EINVAL;\r\n}\r\nrtc_tm_to_time(tm, &ticks);\r\npm860x_bulk_read(info->i2c, PM8607_RTC_COUNTER1, 4, buf);\r\ndata = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\nbase = ticks - data;\r\ndev_dbg(info->dev, "set base:0x%lx, RO count:0x%lx, ticks:0x%lx\n",\r\nbase, data, ticks);\r\npm860x_page_reg_write(info->i2c, REG0_DATA, (base >> 24) & 0xFF);\r\npm860x_page_reg_write(info->i2c, REG1_DATA, (base >> 16) & 0xFF);\r\npm860x_page_reg_write(info->i2c, REG2_DATA, (base >> 8) & 0xFF);\r\npm860x_page_reg_write(info->i2c, REG3_DATA, base & 0xFF);\r\nif (info->sync)\r\ninfo->sync(ticks);\r\nreturn 0;\r\n}\r\nstatic int pm860x_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct pm860x_rtc_info *info = dev_get_drvdata(dev);\r\nunsigned char buf[8];\r\nunsigned long ticks, base, data;\r\nint ret;\r\npm860x_page_bulk_read(info->i2c, REG0_ADDR, 8, buf);\r\ndev_dbg(info->dev, "%x-%x-%x-%x-%x-%x-%x-%x\n", buf[0], buf[1],\r\nbuf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);\r\nbase = (buf[1] << 24) | (buf[3] << 16) | (buf[5] << 8) | buf[7];\r\npm860x_bulk_read(info->i2c, PM8607_RTC_EXPIRE1, 4, buf);\r\ndata = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\nticks = base + data;\r\ndev_dbg(info->dev, "get base:0x%lx, RO count:0x%lx, ticks:0x%lx\n",\r\nbase, data, ticks);\r\nrtc_time_to_tm(ticks, &alrm->time);\r\nret = pm860x_reg_read(info->i2c, PM8607_RTC1);\r\nalrm->enabled = (ret & ALARM_EN) ? 1 : 0;\r\nalrm->pending = (ret & (ALARM | ALARM_WAKEUP)) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int pm860x_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct pm860x_rtc_info *info = dev_get_drvdata(dev);\r\nstruct rtc_time now_tm, alarm_tm;\r\nunsigned long ticks, base, data;\r\nunsigned char buf[8];\r\nint mask;\r\npm860x_set_bits(info->i2c, PM8607_RTC1, ALARM_EN, 0);\r\npm860x_page_bulk_read(info->i2c, REG0_ADDR, 8, buf);\r\ndev_dbg(info->dev, "%x-%x-%x-%x-%x-%x-%x-%x\n", buf[0], buf[1],\r\nbuf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);\r\nbase = (buf[1] << 24) | (buf[3] << 16) | (buf[5] << 8) | buf[7];\r\npm860x_bulk_read(info->i2c, PM8607_RTC_COUNTER1, 4, buf);\r\ndata = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];\r\nticks = base + data;\r\ndev_dbg(info->dev, "get base:0x%lx, RO count:0x%lx, ticks:0x%lx\n",\r\nbase, data, ticks);\r\nrtc_time_to_tm(ticks, &now_tm);\r\nrtc_next_alarm_time(&alarm_tm, &now_tm, &alrm->time);\r\nrtc_tm_to_time(&alarm_tm, &ticks);\r\ndata = ticks - base;\r\nbuf[0] = data & 0xff;\r\nbuf[1] = (data >> 8) & 0xff;\r\nbuf[2] = (data >> 16) & 0xff;\r\nbuf[3] = (data >> 24) & 0xff;\r\npm860x_bulk_write(info->i2c, PM8607_RTC_EXPIRE1, 4, buf);\r\nif (alrm->enabled) {\r\nmask = ALARM | ALARM_WAKEUP | ALARM_EN;\r\npm860x_set_bits(info->i2c, PM8607_RTC1, mask, mask);\r\n} else {\r\nmask = ALARM | ALARM_WAKEUP | ALARM_EN;\r\npm860x_set_bits(info->i2c, PM8607_RTC1, mask,\r\nALARM | ALARM_WAKEUP);\r\n}\r\nreturn 0;\r\n}\r\nstatic void calibrate_vrtc_work(struct work_struct *work)\r\n{\r\nstruct pm860x_rtc_info *info = container_of(work,\r\nstruct pm860x_rtc_info, calib_work.work);\r\nunsigned char buf[2];\r\nunsigned int sum, data, mean, vrtc_set;\r\nint i;\r\nfor (i = 0, sum = 0; i < 16; i++) {\r\nmsleep(100);\r\npm860x_bulk_read(info->i2c, REG_VRTC_MEAS1, 2, buf);\r\ndata = (buf[0] << 4) | buf[1];\r\ndata = (data * 5400) >> 12;\r\nsum += data;\r\n}\r\nmean = sum >> 4;\r\nvrtc_set = 2700 + (info->vrtc & 0x3) * 200;\r\ndev_dbg(info->dev, "mean:%d, vrtc_set:%d\n", mean, vrtc_set);\r\nsum = pm860x_reg_read(info->i2c, PM8607_RTC_MISC1);\r\ndata = sum & 0x3;\r\nif ((mean + 200) < vrtc_set) {\r\nif (++data == 4)\r\ngoto out;\r\ndata = (sum & 0xf8) | (data & 0x3);\r\npm860x_reg_write(info->i2c, PM8607_RTC_MISC1, data);\r\n} else if ((mean - 200) > vrtc_set) {\r\nif (data-- == 0)\r\ngoto out;\r\ndata = (sum & 0xf8) | (data & 0x3);\r\npm860x_reg_write(info->i2c, PM8607_RTC_MISC1, data);\r\n} else\r\ngoto out;\r\ndev_dbg(info->dev, "set 0x%x to RTC_MISC1\n", data);\r\nschedule_delayed_work(&info->calib_work, VRTC_CALIB_INTERVAL);\r\nreturn;\r\nout:\r\npm860x_set_bits(info->i2c, PM8607_MEAS_EN2, MEAS2_VRTC, 0);\r\ndev_dbg(info->dev, "finish VRTC calibration\n");\r\nreturn;\r\n}\r\nstatic int pm860x_rtc_dt_init(struct platform_device *pdev,\r\nstruct pm860x_rtc_info *info)\r\n{\r\nstruct device_node *np = pdev->dev.parent->of_node;\r\nint ret;\r\nif (!np)\r\nreturn -ENODEV;\r\nnp = of_find_node_by_name(np, "rtc");\r\nif (!np) {\r\ndev_err(&pdev->dev, "failed to find rtc node\n");\r\nreturn -ENODEV;\r\n}\r\nret = of_property_read_u32(np, "marvell,88pm860x-vrtc", &info->vrtc);\r\nif (ret)\r\ninfo->vrtc = 0;\r\nreturn 0;\r\n}\r\nstatic int pm860x_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\r\nstruct pm860x_rtc_pdata *pdata = NULL;\r\nstruct pm860x_rtc_info *info;\r\nstruct rtc_time tm;\r\nunsigned long ticks = 0;\r\nint ret;\r\npdata = dev_get_platdata(&pdev->dev);\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(struct pm860x_rtc_info),\r\nGFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->irq = platform_get_irq(pdev, 0);\r\nif (info->irq < 0) {\r\ndev_err(&pdev->dev, "No IRQ resource!\n");\r\nreturn info->irq;\r\n}\r\ninfo->chip = chip;\r\ninfo->i2c = (chip->id == CHIP_PM8607) ? chip->client : chip->companion;\r\ninfo->dev = &pdev->dev;\r\ndev_set_drvdata(&pdev->dev, info);\r\nret = devm_request_threaded_irq(&pdev->dev, info->irq, NULL,\r\nrtc_update_handler, IRQF_ONESHOT, "rtc",\r\ninfo);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to request IRQ: #%d: %d\n",\r\ninfo->irq, ret);\r\nreturn ret;\r\n}\r\npm860x_page_reg_write(info->i2c, REG0_ADDR, REG0_DATA);\r\npm860x_page_reg_write(info->i2c, REG1_ADDR, REG1_DATA);\r\npm860x_page_reg_write(info->i2c, REG2_ADDR, REG2_DATA);\r\npm860x_page_reg_write(info->i2c, REG3_ADDR, REG3_DATA);\r\nret = pm860x_rtc_read_time(&pdev->dev, &tm);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to read initial time.\n");\r\nreturn ret;\r\n}\r\nif ((tm.tm_year < 70) || (tm.tm_year > 138)) {\r\ntm.tm_year = 70;\r\ntm.tm_mon = 0;\r\ntm.tm_mday = 1;\r\ntm.tm_hour = 0;\r\ntm.tm_min = 0;\r\ntm.tm_sec = 0;\r\nret = pm860x_rtc_set_time(&pdev->dev, &tm);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to set initial time.\n");\r\nreturn ret;\r\n}\r\n}\r\nrtc_tm_to_time(&tm, &ticks);\r\nif (pm860x_rtc_dt_init(pdev, info)) {\r\nif (pdata && pdata->sync) {\r\npdata->sync(ticks);\r\ninfo->sync = pdata->sync;\r\n}\r\n}\r\ninfo->rtc_dev = devm_rtc_device_register(&pdev->dev, "88pm860x-rtc",\r\n&pm860x_rtc_ops, THIS_MODULE);\r\nret = PTR_ERR(info->rtc_dev);\r\nif (IS_ERR(info->rtc_dev)) {\r\ndev_err(&pdev->dev, "Failed to register RTC device: %d\n", ret);\r\nreturn ret;\r\n}\r\npm860x_set_bits(info->i2c, PM8607_RTC1, RTC1_USE_XO, RTC1_USE_XO);\r\n#ifdef VRTC_CALIBRATION\r\nif (pm860x_rtc_dt_init(pdev, info)) {\r\nif (pdata && pdata->vrtc)\r\ninfo->vrtc = pdata->vrtc & 0x3;\r\nelse\r\ninfo->vrtc = 1;\r\n}\r\npm860x_set_bits(info->i2c, PM8607_MEAS_EN2, MEAS2_VRTC, MEAS2_VRTC);\r\nINIT_DELAYED_WORK(&info->calib_work, calibrate_vrtc_work);\r\nschedule_delayed_work(&info->calib_work, VRTC_CALIB_INTERVAL);\r\n#endif\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn 0;\r\n}\r\nstatic int pm860x_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct pm860x_rtc_info *info = platform_get_drvdata(pdev);\r\n#ifdef VRTC_CALIBRATION\r\nflush_scheduled_work();\r\npm860x_set_bits(info->i2c, PM8607_MEAS_EN2, MEAS2_VRTC, 0);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int pm860x_rtc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\r\nif (device_may_wakeup(dev))\r\nchip->wakeup_flag |= 1 << PM8607_IRQ_RTC;\r\nreturn 0;\r\n}\r\nstatic int pm860x_rtc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\r\nif (device_may_wakeup(dev))\r\nchip->wakeup_flag &= ~(1 << PM8607_IRQ_RTC);\r\nreturn 0;\r\n}
