static irqreturn_t wake_waiting(int irq, void *unused)\r\n{\r\nif (unlikely(xenstored_ready == 0)) {\r\nxenstored_ready = 1;\r\nschedule_work(&probe_work);\r\n}\r\nwake_up(&xb_waitq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int check_indexes(XENSTORE_RING_IDX cons, XENSTORE_RING_IDX prod)\r\n{\r\nreturn ((prod - cons) <= XENSTORE_RING_SIZE);\r\n}\r\nstatic void *get_output_chunk(XENSTORE_RING_IDX cons,\r\nXENSTORE_RING_IDX prod,\r\nchar *buf, uint32_t *len)\r\n{\r\n*len = XENSTORE_RING_SIZE - MASK_XENSTORE_IDX(prod);\r\nif ((XENSTORE_RING_SIZE - (prod - cons)) < *len)\r\n*len = XENSTORE_RING_SIZE - (prod - cons);\r\nreturn buf + MASK_XENSTORE_IDX(prod);\r\n}\r\nstatic const void *get_input_chunk(XENSTORE_RING_IDX cons,\r\nXENSTORE_RING_IDX prod,\r\nconst char *buf, uint32_t *len)\r\n{\r\n*len = XENSTORE_RING_SIZE - MASK_XENSTORE_IDX(cons);\r\nif ((prod - cons) < *len)\r\n*len = prod - cons;\r\nreturn buf + MASK_XENSTORE_IDX(cons);\r\n}\r\nint xb_write(const void *data, unsigned len)\r\n{\r\nstruct xenstore_domain_interface *intf = xen_store_interface;\r\nXENSTORE_RING_IDX cons, prod;\r\nint rc;\r\nwhile (len != 0) {\r\nvoid *dst;\r\nunsigned int avail;\r\nrc = wait_event_interruptible(\r\nxb_waitq,\r\n(intf->req_prod - intf->req_cons) !=\r\nXENSTORE_RING_SIZE);\r\nif (rc < 0)\r\nreturn rc;\r\ncons = intf->req_cons;\r\nprod = intf->req_prod;\r\nif (!check_indexes(cons, prod)) {\r\nintf->req_cons = intf->req_prod = 0;\r\nreturn -EIO;\r\n}\r\ndst = get_output_chunk(cons, prod, intf->req, &avail);\r\nif (avail == 0)\r\ncontinue;\r\nif (avail > len)\r\navail = len;\r\nmb();\r\nmemcpy(dst, data, avail);\r\ndata += avail;\r\nlen -= avail;\r\nwmb();\r\nintf->req_prod += avail;\r\nnotify_remote_via_evtchn(xen_store_evtchn);\r\n}\r\nreturn 0;\r\n}\r\nint xb_data_to_read(void)\r\n{\r\nstruct xenstore_domain_interface *intf = xen_store_interface;\r\nreturn (intf->rsp_cons != intf->rsp_prod);\r\n}\r\nint xb_wait_for_data_to_read(void)\r\n{\r\nreturn wait_event_interruptible(xb_waitq, xb_data_to_read());\r\n}\r\nint xb_read(void *data, unsigned len)\r\n{\r\nstruct xenstore_domain_interface *intf = xen_store_interface;\r\nXENSTORE_RING_IDX cons, prod;\r\nint rc;\r\nwhile (len != 0) {\r\nunsigned int avail;\r\nconst char *src;\r\nrc = xb_wait_for_data_to_read();\r\nif (rc < 0)\r\nreturn rc;\r\ncons = intf->rsp_cons;\r\nprod = intf->rsp_prod;\r\nif (!check_indexes(cons, prod)) {\r\nintf->rsp_cons = intf->rsp_prod = 0;\r\nreturn -EIO;\r\n}\r\nsrc = get_input_chunk(cons, prod, intf->rsp, &avail);\r\nif (avail == 0)\r\ncontinue;\r\nif (avail > len)\r\navail = len;\r\nrmb();\r\nmemcpy(data, src, avail);\r\ndata += avail;\r\nlen -= avail;\r\nmb();\r\nintf->rsp_cons += avail;\r\npr_debug("Finished read of %i bytes (%i to go)\n", avail, len);\r\nnotify_remote_via_evtchn(xen_store_evtchn);\r\n}\r\nreturn 0;\r\n}\r\nint xb_init_comms(void)\r\n{\r\nstruct xenstore_domain_interface *intf = xen_store_interface;\r\nif (intf->req_prod != intf->req_cons)\r\npr_err("request ring is not quiescent (%08x:%08x)!\n",\r\nintf->req_cons, intf->req_prod);\r\nif (intf->rsp_prod != intf->rsp_cons) {\r\npr_warn("response ring is not quiescent (%08x:%08x): fixing up\n",\r\nintf->rsp_cons, intf->rsp_prod);\r\nif (!reset_devices)\r\nintf->rsp_cons = intf->rsp_prod;\r\n}\r\nif (xenbus_irq) {\r\nrebind_evtchn_irq(xen_store_evtchn, xenbus_irq);\r\n} else {\r\nint err;\r\nerr = bind_evtchn_to_irqhandler(xen_store_evtchn, wake_waiting,\r\n0, "xenbus", &xb_waitq);\r\nif (err < 0) {\r\npr_err("request irq failed %i\n", err);\r\nreturn err;\r\n}\r\nxenbus_irq = err;\r\n}\r\nreturn 0;\r\n}\r\nvoid xb_deinit_comms(void)\r\n{\r\nunbind_from_irqhandler(xenbus_irq, &xb_waitq);\r\nxenbus_irq = 0;\r\n}
