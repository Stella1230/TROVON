bool bcma_core_pci_is_in_hostmode(struct bcma_drv_pci *pc)\r\n{\r\nstruct bcma_bus *bus = pc->core->bus;\r\nu16 chipid_top;\r\nu32 tmp;\r\nchipid_top = (bus->chipinfo.id & 0xFF00);\r\nif (chipid_top != 0x4700 &&\r\nchipid_top != 0x5300)\r\nreturn false;\r\nbcma_core_enable(pc->core, 0);\r\nreturn !mips_busprobe32(tmp, pc->core->io_addr);\r\n}\r\nstatic u32 bcma_pcie_read_config(struct bcma_drv_pci *pc, u32 address)\r\n{\r\npcicore_write32(pc, BCMA_CORE_PCI_CONFIG_ADDR, address);\r\npcicore_read32(pc, BCMA_CORE_PCI_CONFIG_ADDR);\r\nreturn pcicore_read32(pc, BCMA_CORE_PCI_CONFIG_DATA);\r\n}\r\nstatic void bcma_pcie_write_config(struct bcma_drv_pci *pc, u32 address,\r\nu32 data)\r\n{\r\npcicore_write32(pc, BCMA_CORE_PCI_CONFIG_ADDR, address);\r\npcicore_read32(pc, BCMA_CORE_PCI_CONFIG_ADDR);\r\npcicore_write32(pc, BCMA_CORE_PCI_CONFIG_DATA, data);\r\n}\r\nstatic u32 bcma_get_cfgspace_addr(struct bcma_drv_pci *pc, unsigned int dev,\r\nunsigned int func, unsigned int off)\r\n{\r\nu32 addr = 0;\r\nif (dev >= 2 || !(bcma_pcie_read(pc, BCMA_CORE_PCI_DLLP_LSREG)\r\n& BCMA_CORE_PCI_DLLP_LSREG_LINKUP))\r\ngoto out;\r\npcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI1, BCMA_CORE_PCI_SBTOPCI_CFG0);\r\naddr = pc->host_controller->host_cfg_addr;\r\naddr |= (dev << BCMA_CORE_PCI_CFG_SLOT_SHIFT);\r\naddr |= (func << BCMA_CORE_PCI_CFG_FUN_SHIFT);\r\naddr |= (off & ~3);\r\nout:\r\nreturn addr;\r\n}\r\nstatic int bcma_extpci_read_config(struct bcma_drv_pci *pc, unsigned int dev,\r\nunsigned int func, unsigned int off,\r\nvoid *buf, int len)\r\n{\r\nint err = -EINVAL;\r\nu32 addr, val;\r\nvoid __iomem *mmio = 0;\r\nWARN_ON(!pc->hostmode);\r\nif (unlikely(len != 1 && len != 2 && len != 4))\r\ngoto out;\r\nif (dev == 0) {\r\nif (func > 1)\r\ngoto out;\r\nif (off >= PCI_CONFIG_SPACE_SIZE) {\r\naddr = (func << 12);\r\naddr |= (off & 0x0FFC);\r\nval = bcma_pcie_read_config(pc, addr);\r\n} else {\r\naddr = BCMA_CORE_PCI_PCICFG0;\r\naddr |= (func << 8);\r\naddr |= (off & 0xFC);\r\nval = pcicore_read32(pc, addr);\r\n}\r\n} else {\r\naddr = bcma_get_cfgspace_addr(pc, dev, func, off);\r\nif (unlikely(!addr))\r\ngoto out;\r\nerr = -ENOMEM;\r\nmmio = ioremap_nocache(addr, sizeof(val));\r\nif (!mmio)\r\ngoto out;\r\nif (mips_busprobe32(val, mmio)) {\r\nval = 0xFFFFFFFF;\r\ngoto unmap;\r\n}\r\n}\r\nval >>= (8 * (off & 3));\r\nswitch (len) {\r\ncase 1:\r\n*((u8 *)buf) = (u8)val;\r\nbreak;\r\ncase 2:\r\n*((u16 *)buf) = (u16)val;\r\nbreak;\r\ncase 4:\r\n*((u32 *)buf) = (u32)val;\r\nbreak;\r\n}\r\nerr = 0;\r\nunmap:\r\nif (mmio)\r\niounmap(mmio);\r\nout:\r\nreturn err;\r\n}\r\nstatic int bcma_extpci_write_config(struct bcma_drv_pci *pc, unsigned int dev,\r\nunsigned int func, unsigned int off,\r\nconst void *buf, int len)\r\n{\r\nint err = -EINVAL;\r\nu32 addr, val;\r\nvoid __iomem *mmio = 0;\r\nu16 chipid = pc->core->bus->chipinfo.id;\r\nWARN_ON(!pc->hostmode);\r\nif (unlikely(len != 1 && len != 2 && len != 4))\r\ngoto out;\r\nif (dev == 0) {\r\nif (func > 1)\r\ngoto out;\r\nif (off >= PCI_CONFIG_SPACE_SIZE) {\r\naddr = (func << 12);\r\naddr |= (off & 0x0FFC);\r\nval = bcma_pcie_read_config(pc, addr);\r\n} else {\r\naddr = BCMA_CORE_PCI_PCICFG0;\r\naddr |= (func << 8);\r\naddr |= (off & 0xFC);\r\nval = pcicore_read32(pc, addr);\r\n}\r\n} else {\r\naddr = bcma_get_cfgspace_addr(pc, dev, func, off);\r\nif (unlikely(!addr))\r\ngoto out;\r\nerr = -ENOMEM;\r\nmmio = ioremap_nocache(addr, sizeof(val));\r\nif (!mmio)\r\ngoto out;\r\nif (mips_busprobe32(val, mmio)) {\r\nval = 0xFFFFFFFF;\r\ngoto unmap;\r\n}\r\n}\r\nswitch (len) {\r\ncase 1:\r\nval &= ~(0xFF << (8 * (off & 3)));\r\nval |= *((const u8 *)buf) << (8 * (off & 3));\r\nbreak;\r\ncase 2:\r\nval &= ~(0xFFFF << (8 * (off & 3)));\r\nval |= *((const u16 *)buf) << (8 * (off & 3));\r\nbreak;\r\ncase 4:\r\nval = *((const u32 *)buf);\r\nbreak;\r\n}\r\nif (dev == 0) {\r\nif (off >= PCI_CONFIG_SPACE_SIZE)\r\nbcma_pcie_write_config(pc, addr, val);\r\nelse\r\npcicore_write32(pc, addr, val);\r\n} else {\r\nwritel(val, mmio);\r\nif (chipid == BCMA_CHIP_ID_BCM4716 ||\r\nchipid == BCMA_CHIP_ID_BCM4748)\r\nreadl(mmio);\r\n}\r\nerr = 0;\r\nunmap:\r\nif (mmio)\r\niounmap(mmio);\r\nout:\r\nreturn err;\r\n}\r\nstatic int bcma_core_pci_hostmode_read_config(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint reg, int size, u32 *val)\r\n{\r\nunsigned long flags;\r\nint err;\r\nstruct bcma_drv_pci *pc;\r\nstruct bcma_drv_pci_host *pc_host;\r\npc_host = container_of(bus->ops, struct bcma_drv_pci_host, pci_ops);\r\npc = pc_host->pdev;\r\nspin_lock_irqsave(&pc_host->cfgspace_lock, flags);\r\nerr = bcma_extpci_read_config(pc, PCI_SLOT(devfn),\r\nPCI_FUNC(devfn), reg, val, size);\r\nspin_unlock_irqrestore(&pc_host->cfgspace_lock, flags);\r\nreturn err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int bcma_core_pci_hostmode_write_config(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint reg, int size, u32 val)\r\n{\r\nunsigned long flags;\r\nint err;\r\nstruct bcma_drv_pci *pc;\r\nstruct bcma_drv_pci_host *pc_host;\r\npc_host = container_of(bus->ops, struct bcma_drv_pci_host, pci_ops);\r\npc = pc_host->pdev;\r\nspin_lock_irqsave(&pc_host->cfgspace_lock, flags);\r\nerr = bcma_extpci_write_config(pc, PCI_SLOT(devfn),\r\nPCI_FUNC(devfn), reg, &val, size);\r\nspin_unlock_irqrestore(&pc_host->cfgspace_lock, flags);\r\nreturn err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic u8 bcma_find_pci_capability(struct bcma_drv_pci *pc, unsigned int dev,\r\nunsigned int func, u8 req_cap_id,\r\nunsigned char *buf, u32 *buflen)\r\n{\r\nu8 cap_id;\r\nu8 cap_ptr = 0;\r\nu32 bufsize;\r\nu8 byte_val;\r\nbcma_extpci_read_config(pc, dev, func, PCI_HEADER_TYPE, &byte_val,\r\nsizeof(u8));\r\nif ((byte_val & 0x7F) != PCI_HEADER_TYPE_NORMAL)\r\nreturn cap_ptr;\r\nbcma_extpci_read_config(pc, dev, func, PCI_STATUS, &byte_val,\r\nsizeof(u8));\r\nif (!(byte_val & PCI_STATUS_CAP_LIST))\r\nreturn cap_ptr;\r\nbcma_extpci_read_config(pc, dev, func, PCI_CAPABILITY_LIST, &cap_ptr,\r\nsizeof(u8));\r\nif (cap_ptr == 0x00)\r\nreturn cap_ptr;\r\nbcma_extpci_read_config(pc, dev, func, cap_ptr, &cap_id, sizeof(u8));\r\nwhile (cap_id != req_cap_id) {\r\nbcma_extpci_read_config(pc, dev, func, cap_ptr + 1, &cap_ptr,\r\nsizeof(u8));\r\nif (cap_ptr == 0x00)\r\nreturn cap_ptr;\r\nbcma_extpci_read_config(pc, dev, func, cap_ptr, &cap_id,\r\nsizeof(u8));\r\n}\r\nif ((buf != NULL) && (buflen != NULL)) {\r\nu8 cap_data;\r\nbufsize = *buflen;\r\nif (!bufsize)\r\nreturn cap_ptr;\r\n*buflen = 0;\r\ncap_data = cap_ptr + 2;\r\nif ((bufsize + cap_data) > PCI_CONFIG_SPACE_SIZE)\r\nbufsize = PCI_CONFIG_SPACE_SIZE - cap_data;\r\n*buflen = bufsize;\r\nwhile (bufsize--) {\r\nbcma_extpci_read_config(pc, dev, func, cap_data, buf,\r\nsizeof(u8));\r\ncap_data++;\r\nbuf++;\r\n}\r\n}\r\nreturn cap_ptr;\r\n}\r\nstatic void bcma_core_pci_enable_crs(struct bcma_drv_pci *pc)\r\n{\r\nstruct bcma_bus *bus = pc->core->bus;\r\nu8 cap_ptr, root_ctrl, root_cap, dev;\r\nu16 val16;\r\nint i;\r\ncap_ptr = bcma_find_pci_capability(pc, 0, 0, PCI_CAP_ID_EXP, NULL,\r\nNULL);\r\nroot_cap = cap_ptr + PCI_EXP_RTCAP;\r\nbcma_extpci_read_config(pc, 0, 0, root_cap, &val16, sizeof(u16));\r\nif (val16 & BCMA_CORE_PCI_RC_CRS_VISIBILITY) {\r\nroot_ctrl = cap_ptr + PCI_EXP_RTCTL;\r\nval16 = PCI_EXP_RTCTL_CRSSVE;\r\nbcma_extpci_read_config(pc, 0, 0, root_ctrl, &val16,\r\nsizeof(u16));\r\nfor (dev = 1; dev < BCMA_PCI_SLOT_MAX; dev++) {\r\nfor (i = 0; i < 100000; i++) {\r\nbcma_extpci_read_config(pc, dev, 0,\r\nPCI_VENDOR_ID, &val16,\r\nsizeof(val16));\r\nif (val16 != 0x1)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (val16 == 0x1)\r\nbcma_err(bus, "PCI: Broken device in slot %d\n",\r\ndev);\r\n}\r\n}\r\n}\r\nvoid bcma_core_pci_hostmode_init(struct bcma_drv_pci *pc)\r\n{\r\nstruct bcma_bus *bus = pc->core->bus;\r\nstruct bcma_drv_pci_host *pc_host;\r\nu32 tmp;\r\nu32 pci_membase_1G;\r\nunsigned long io_map_base;\r\nbcma_info(bus, "PCIEcore in host mode found\n");\r\nif (bus->sprom.boardflags_lo & BCMA_CORE_PCI_BFL_NOPCI) {\r\nbcma_info(bus, "This PCIE core is disabled and not working\n");\r\nreturn;\r\n}\r\npc_host = kzalloc(sizeof(*pc_host), GFP_KERNEL);\r\nif (!pc_host) {\r\nbcma_err(bus, "can not allocate memory");\r\nreturn;\r\n}\r\nspin_lock_init(&pc_host->cfgspace_lock);\r\npc->host_controller = pc_host;\r\npc_host->pci_controller.io_resource = &pc_host->io_resource;\r\npc_host->pci_controller.mem_resource = &pc_host->mem_resource;\r\npc_host->pci_controller.pci_ops = &pc_host->pci_ops;\r\npc_host->pdev = pc;\r\npci_membase_1G = BCMA_SOC_PCI_DMA;\r\npc_host->host_cfg_addr = BCMA_SOC_PCI_CFG;\r\npc_host->pci_ops.read = bcma_core_pci_hostmode_read_config;\r\npc_host->pci_ops.write = bcma_core_pci_hostmode_write_config;\r\npc_host->mem_resource.name = "BCMA PCIcore external memory",\r\npc_host->mem_resource.start = BCMA_SOC_PCI_DMA;\r\npc_host->mem_resource.end = BCMA_SOC_PCI_DMA + BCMA_SOC_PCI_DMA_SZ - 1;\r\npc_host->mem_resource.flags = IORESOURCE_MEM | IORESOURCE_PCI_FIXED;\r\npc_host->io_resource.name = "BCMA PCIcore external I/O",\r\npc_host->io_resource.start = 0x100;\r\npc_host->io_resource.end = 0x7FF;\r\npc_host->io_resource.flags = IORESOURCE_IO | IORESOURCE_PCI_FIXED;\r\nusleep_range(3000, 5000);\r\npcicore_write32(pc, BCMA_CORE_PCI_CTL, BCMA_CORE_PCI_CTL_RST_OE);\r\nmsleep(50);\r\npcicore_write32(pc, BCMA_CORE_PCI_CTL, BCMA_CORE_PCI_CTL_RST |\r\nBCMA_CORE_PCI_CTL_RST_OE);\r\nif (bus->chipinfo.id == BCMA_CHIP_ID_BCM4716 ||\r\nbus->chipinfo.id == BCMA_CHIP_ID_BCM4748) {\r\npc_host->mem_resource.start = BCMA_SOC_PCI_MEM;\r\npc_host->mem_resource.end = BCMA_SOC_PCI_MEM +\r\nBCMA_SOC_PCI_MEM_SZ - 1;\r\npcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI0,\r\nBCMA_CORE_PCI_SBTOPCI_MEM | BCMA_SOC_PCI_MEM);\r\n} else if (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {\r\ntmp = BCMA_CORE_PCI_SBTOPCI_MEM;\r\ntmp |= BCMA_CORE_PCI_SBTOPCI_PREF;\r\ntmp |= BCMA_CORE_PCI_SBTOPCI_BURST;\r\nif (pc->core->core_unit == 0) {\r\npc_host->mem_resource.start = BCMA_SOC_PCI_MEM;\r\npc_host->mem_resource.end = BCMA_SOC_PCI_MEM +\r\nBCMA_SOC_PCI_MEM_SZ - 1;\r\npc_host->io_resource.start = 0x100;\r\npc_host->io_resource.end = 0x47F;\r\npci_membase_1G = BCMA_SOC_PCIE_DMA_H32;\r\npcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI0,\r\ntmp | BCMA_SOC_PCI_MEM);\r\n} else if (pc->core->core_unit == 1) {\r\npc_host->mem_resource.start = BCMA_SOC_PCI1_MEM;\r\npc_host->mem_resource.end = BCMA_SOC_PCI1_MEM +\r\nBCMA_SOC_PCI_MEM_SZ - 1;\r\npc_host->io_resource.start = 0x480;\r\npc_host->io_resource.end = 0x7FF;\r\npci_membase_1G = BCMA_SOC_PCIE1_DMA_H32;\r\npc_host->host_cfg_addr = BCMA_SOC_PCI1_CFG;\r\npcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI0,\r\ntmp | BCMA_SOC_PCI1_MEM);\r\n}\r\n} else\r\npcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI0,\r\nBCMA_CORE_PCI_SBTOPCI_IO);\r\npcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI1, BCMA_CORE_PCI_SBTOPCI_CFG0);\r\npcicore_write32(pc, BCMA_CORE_PCI_SBTOPCI2,\r\nBCMA_CORE_PCI_SBTOPCI_MEM | pci_membase_1G);\r\nmsleep(100);\r\nbcma_core_pci_enable_crs(pc);\r\nif (bus->chipinfo.id == BCMA_CHIP_ID_BCM4706 ||\r\nbus->chipinfo.id == BCMA_CHIP_ID_BCM4716) {\r\nu16 val16;\r\nbcma_extpci_read_config(pc, 0, 0, BCMA_CORE_PCI_CFG_DEVCTRL,\r\n&val16, sizeof(val16));\r\nval16 |= (2 << 5);\r\nval16 |= (2 << 12);\r\nbcma_extpci_write_config(pc, 0, 0, BCMA_CORE_PCI_CFG_DEVCTRL,\r\n&val16, sizeof(val16));\r\n}\r\ntmp = PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;\r\nbcma_extpci_write_config(pc, 0, 0, PCI_COMMAND, &tmp, sizeof(tmp));\r\npcicore_write32(pc, BCMA_CORE_PCI_IMASK, BCMA_CORE_PCI_IMASK_INTA);\r\nio_map_base = (unsigned long)ioremap_nocache(pc_host->mem_resource.start,\r\nresource_size(&pc_host->mem_resource));\r\npc_host->pci_controller.io_map_base = io_map_base;\r\nset_io_port_base(pc_host->pci_controller.io_map_base);\r\nusleep_range(10000, 15000);\r\nregister_pci_controller(&pc_host->pci_controller);\r\nreturn;\r\n}\r\nstatic void bcma_core_pci_fixup_pcibridge(struct pci_dev *dev)\r\n{\r\nif (dev->bus->ops->read != bcma_core_pci_hostmode_read_config) {\r\nreturn;\r\n}\r\nif (PCI_SLOT(dev->devfn) != 0)\r\nreturn;\r\npr_info("PCI: Fixing up bridge %s\n", pci_name(dev));\r\npci_set_master(dev);\r\nif (pcibios_enable_device(dev, ~0) < 0) {\r\npr_err("PCI: BCMA bridge enable failed\n");\r\nreturn;\r\n}\r\npci_write_config_dword(dev, BCMA_PCI_BAR1_CONTROL, 3);\r\n}\r\nstatic void bcma_core_pci_fixup_addresses(struct pci_dev *dev)\r\n{\r\nstruct resource *res;\r\nint pos, err;\r\nif (dev->bus->ops->read != bcma_core_pci_hostmode_read_config) {\r\nreturn;\r\n}\r\nif (PCI_SLOT(dev->devfn) == 0)\r\nreturn;\r\npr_info("PCI: Fixing up addresses %s\n", pci_name(dev));\r\nfor (pos = 0; pos < 6; pos++) {\r\nres = &dev->resource[pos];\r\nif (res->flags & (IORESOURCE_IO | IORESOURCE_MEM)) {\r\nerr = pci_assign_resource(dev, pos);\r\nif (err)\r\npr_err("PCI: Problem fixing up the addresses on %s\n",\r\npci_name(dev));\r\n}\r\n}\r\n}\r\nint bcma_core_pci_plat_dev_init(struct pci_dev *dev)\r\n{\r\nstruct bcma_drv_pci_host *pc_host;\r\nint readrq;\r\nif (dev->bus->ops->read != bcma_core_pci_hostmode_read_config) {\r\nreturn -ENODEV;\r\n}\r\npc_host = container_of(dev->bus->ops, struct bcma_drv_pci_host,\r\npci_ops);\r\npr_info("PCI: Fixing up device %s\n", pci_name(dev));\r\ndev->irq = bcma_core_irq(pc_host->pdev->core);\r\npci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);\r\nreadrq = pcie_get_readrq(dev);\r\nif (readrq > 128) {\r\npr_info("change PCIe max read request size from %i to 128\n", readrq);\r\npcie_set_readrq(dev, 128);\r\n}\r\nreturn 0;\r\n}\r\nint bcma_core_pci_pcibios_map_irq(const struct pci_dev *dev)\r\n{\r\nstruct bcma_drv_pci_host *pc_host;\r\nif (dev->bus->ops->read != bcma_core_pci_hostmode_read_config) {\r\nreturn -ENODEV;\r\n}\r\npc_host = container_of(dev->bus->ops, struct bcma_drv_pci_host,\r\npci_ops);\r\nreturn bcma_core_irq(pc_host->pdev->core);\r\n}
