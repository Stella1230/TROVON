static int max17042_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct max17042_chip *chip = container_of(psy,\r\nstruct max17042_chip, battery);\r\nstruct regmap *map = chip->regmap;\r\nint ret;\r\nu32 data;\r\nif (!chip->init_complete)\r\nreturn -EAGAIN;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nret = regmap_read(map, MAX17042_STATUS, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (data & MAX17042_STATUS_BattAbsent)\r\nval->intval = 0;\r\nelse\r\nval->intval = 1;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CYCLE_COUNT:\r\nret = regmap_read(map, MAX17042_Cycles, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = data;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX:\r\nret = regmap_read(map, MAX17042_MinMaxVolt, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = data >> 8;\r\nval->intval *= 20000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\nif (chip->chip_type == MAX17042)\r\nret = regmap_read(map, MAX17042_V_empty, &data);\r\nelse\r\nret = regmap_read(map, MAX17047_V_empty, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = data >> 7;\r\nval->intval *= 10000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nret = regmap_read(map, MAX17042_VCELL, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = data * 625 / 8;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_AVG:\r\nret = regmap_read(map, MAX17042_AvgVCELL, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = data * 625 / 8;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_OCV:\r\nret = regmap_read(map, MAX17042_OCVInternal, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = data * 625 / 8;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nret = regmap_read(map, MAX17042_RepSOC, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = data >> 8;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\nret = regmap_read(map, MAX17042_FullCAP, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = data * 1000 / 2;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_COUNTER:\r\nret = regmap_read(map, MAX17042_QH, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = data * 1000 / 2;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nret = regmap_read(map, MAX17042_TEMP, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = data;\r\nif (val->intval & 0x8000) {\r\nval->intval = (0x7fff & ~val->intval) + 1;\r\nval->intval *= -1;\r\n}\r\nval->intval = val->intval * 10 / 256;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nif (chip->pdata->enable_current_sense) {\r\nret = regmap_read(map, MAX17042_Current, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = data;\r\nif (val->intval & 0x8000) {\r\nval->intval = ~val->intval & 0x7fff;\r\nval->intval++;\r\nval->intval *= -1;\r\n}\r\nval->intval *= 1562500 / chip->pdata->r_sns;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_AVG:\r\nif (chip->pdata->enable_current_sense) {\r\nret = regmap_read(map, MAX17042_AvgCurrent, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = data;\r\nif (val->intval & 0x8000) {\r\nval->intval = ~val->intval & 0x7fff;\r\nval->intval++;\r\nval->intval *= -1;\r\n}\r\nval->intval *= 1562500 / chip->pdata->r_sns;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max17042_write_verify_reg(struct regmap *map, u8 reg, u32 value)\r\n{\r\nint retries = 8;\r\nint ret;\r\nu32 read_value;\r\ndo {\r\nret = regmap_write(map, reg, value);\r\nregmap_read(map, reg, &read_value);\r\nif (read_value != value) {\r\nret = -EIO;\r\nretries--;\r\n}\r\n} while (retries && read_value != value);\r\nif (ret < 0)\r\npr_err("%s: err %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic inline void max17042_override_por(struct regmap *map,\r\nu8 reg, u16 value)\r\n{\r\nif (value)\r\nregmap_write(map, reg, value);\r\n}\r\nstatic inline void max10742_unlock_model(struct max17042_chip *chip)\r\n{\r\nstruct regmap *map = chip->regmap;\r\nregmap_write(map, MAX17042_MLOCKReg1, MODEL_UNLOCK1);\r\nregmap_write(map, MAX17042_MLOCKReg2, MODEL_UNLOCK2);\r\n}\r\nstatic inline void max10742_lock_model(struct max17042_chip *chip)\r\n{\r\nstruct regmap *map = chip->regmap;\r\nregmap_write(map, MAX17042_MLOCKReg1, MODEL_LOCK1);\r\nregmap_write(map, MAX17042_MLOCKReg2, MODEL_LOCK2);\r\n}\r\nstatic inline void max17042_write_model_data(struct max17042_chip *chip,\r\nu8 addr, int size)\r\n{\r\nstruct regmap *map = chip->regmap;\r\nint i;\r\nfor (i = 0; i < size; i++)\r\nregmap_write(map, addr + i,\r\nchip->pdata->config_data->cell_char_tbl[i]);\r\n}\r\nstatic inline void max17042_read_model_data(struct max17042_chip *chip,\r\nu8 addr, u32 *data, int size)\r\n{\r\nstruct regmap *map = chip->regmap;\r\nint i;\r\nfor (i = 0; i < size; i++)\r\nregmap_read(map, addr + i, &data[i]);\r\n}\r\nstatic inline int max17042_model_data_compare(struct max17042_chip *chip,\r\nu16 *data1, u16 *data2, int size)\r\n{\r\nint i;\r\nif (memcmp(data1, data2, size)) {\r\ndev_err(&chip->client->dev, "%s compare failed\n", __func__);\r\nfor (i = 0; i < size; i++)\r\ndev_info(&chip->client->dev, "0x%x, 0x%x",\r\ndata1[i], data2[i]);\r\ndev_info(&chip->client->dev, "\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max17042_init_model(struct max17042_chip *chip)\r\n{\r\nint ret;\r\nint table_size = ARRAY_SIZE(chip->pdata->config_data->cell_char_tbl);\r\nu32 *temp_data;\r\ntemp_data = kcalloc(table_size, sizeof(*temp_data), GFP_KERNEL);\r\nif (!temp_data)\r\nreturn -ENOMEM;\r\nmax10742_unlock_model(chip);\r\nmax17042_write_model_data(chip, MAX17042_MODELChrTbl,\r\ntable_size);\r\nmax17042_read_model_data(chip, MAX17042_MODELChrTbl, temp_data,\r\ntable_size);\r\nret = max17042_model_data_compare(\r\nchip,\r\nchip->pdata->config_data->cell_char_tbl,\r\n(u16 *)temp_data,\r\ntable_size);\r\nmax10742_lock_model(chip);\r\nkfree(temp_data);\r\nreturn ret;\r\n}\r\nstatic int max17042_verify_model_lock(struct max17042_chip *chip)\r\n{\r\nint i;\r\nint table_size = ARRAY_SIZE(chip->pdata->config_data->cell_char_tbl);\r\nu32 *temp_data;\r\nint ret = 0;\r\ntemp_data = kcalloc(table_size, sizeof(*temp_data), GFP_KERNEL);\r\nif (!temp_data)\r\nreturn -ENOMEM;\r\nmax17042_read_model_data(chip, MAX17042_MODELChrTbl, temp_data,\r\ntable_size);\r\nfor (i = 0; i < table_size; i++)\r\nif (temp_data[i])\r\nret = -EINVAL;\r\nkfree(temp_data);\r\nreturn ret;\r\n}\r\nstatic void max17042_write_config_regs(struct max17042_chip *chip)\r\n{\r\nstruct max17042_config_data *config = chip->pdata->config_data;\r\nstruct regmap *map = chip->regmap;\r\nregmap_write(map, MAX17042_CONFIG, config->config);\r\nregmap_write(map, MAX17042_LearnCFG, config->learn_cfg);\r\nregmap_write(map, MAX17042_FilterCFG,\r\nconfig->filter_cfg);\r\nregmap_write(map, MAX17042_RelaxCFG, config->relax_cfg);\r\nif (chip->chip_type == MAX17047)\r\nregmap_write(map, MAX17047_FullSOCThr,\r\nconfig->full_soc_thresh);\r\n}\r\nstatic void max17042_write_custom_regs(struct max17042_chip *chip)\r\n{\r\nstruct max17042_config_data *config = chip->pdata->config_data;\r\nstruct regmap *map = chip->regmap;\r\nmax17042_write_verify_reg(map, MAX17042_RCOMP0, config->rcomp0);\r\nmax17042_write_verify_reg(map, MAX17042_TempCo, config->tcompc0);\r\nmax17042_write_verify_reg(map, MAX17042_ICHGTerm, config->ichgt_term);\r\nif (chip->chip_type == MAX17042) {\r\nregmap_write(map, MAX17042_EmptyTempCo, config->empty_tempco);\r\nmax17042_write_verify_reg(map, MAX17042_K_empty0,\r\nconfig->kempty0);\r\n} else {\r\nmax17042_write_verify_reg(map, MAX17047_QRTbl00,\r\nconfig->qrtbl00);\r\nmax17042_write_verify_reg(map, MAX17047_QRTbl10,\r\nconfig->qrtbl10);\r\nmax17042_write_verify_reg(map, MAX17047_QRTbl20,\r\nconfig->qrtbl20);\r\nmax17042_write_verify_reg(map, MAX17047_QRTbl30,\r\nconfig->qrtbl30);\r\n}\r\n}\r\nstatic void max17042_update_capacity_regs(struct max17042_chip *chip)\r\n{\r\nstruct max17042_config_data *config = chip->pdata->config_data;\r\nstruct regmap *map = chip->regmap;\r\nmax17042_write_verify_reg(map, MAX17042_FullCAP,\r\nconfig->fullcap);\r\nregmap_write(map, MAX17042_DesignCap, config->design_cap);\r\nmax17042_write_verify_reg(map, MAX17042_FullCAPNom,\r\nconfig->fullcapnom);\r\n}\r\nstatic void max17042_reset_vfsoc0_reg(struct max17042_chip *chip)\r\n{\r\nunsigned int vfSoc;\r\nstruct regmap *map = chip->regmap;\r\nregmap_read(map, MAX17042_VFSOC, &vfSoc);\r\nregmap_write(map, MAX17042_VFSOC0Enable, VFSOC0_UNLOCK);\r\nmax17042_write_verify_reg(map, MAX17042_VFSOC0, vfSoc);\r\nregmap_write(map, MAX17042_VFSOC0Enable, VFSOC0_LOCK);\r\n}\r\nstatic void max17042_load_new_capacity_params(struct max17042_chip *chip)\r\n{\r\nu32 full_cap0, rep_cap, dq_acc, vfSoc;\r\nu32 rem_cap;\r\nstruct max17042_config_data *config = chip->pdata->config_data;\r\nstruct regmap *map = chip->regmap;\r\nregmap_read(map, MAX17042_FullCAP0, &full_cap0);\r\nregmap_read(map, MAX17042_VFSOC, &vfSoc);\r\nrem_cap = ((vfSoc >> 8) * full_cap0) / 100;\r\nmax17042_write_verify_reg(map, MAX17042_RemCap, rem_cap);\r\nrep_cap = rem_cap;\r\nmax17042_write_verify_reg(map, MAX17042_RepCap, rep_cap);\r\ndq_acc = config->fullcap / dQ_ACC_DIV;\r\nmax17042_write_verify_reg(map, MAX17042_dQacc, dq_acc);\r\nmax17042_write_verify_reg(map, MAX17042_dPacc, dP_ACC_200);\r\nmax17042_write_verify_reg(map, MAX17042_FullCAP,\r\nconfig->fullcap);\r\nregmap_write(map, MAX17042_DesignCap,\r\nconfig->design_cap);\r\nmax17042_write_verify_reg(map, MAX17042_FullCAPNom,\r\nconfig->fullcapnom);\r\nregmap_write(map, MAX17042_RepSOC, vfSoc);\r\n}\r\nstatic inline void max17042_override_por_values(struct max17042_chip *chip)\r\n{\r\nstruct regmap *map = chip->regmap;\r\nstruct max17042_config_data *config = chip->pdata->config_data;\r\nmax17042_override_por(map, MAX17042_TGAIN, config->tgain);\r\nmax17042_override_por(map, MAx17042_TOFF, config->toff);\r\nmax17042_override_por(map, MAX17042_CGAIN, config->cgain);\r\nmax17042_override_por(map, MAX17042_COFF, config->coff);\r\nmax17042_override_por(map, MAX17042_VALRT_Th, config->valrt_thresh);\r\nmax17042_override_por(map, MAX17042_TALRT_Th, config->talrt_thresh);\r\nmax17042_override_por(map, MAX17042_SALRT_Th,\r\nconfig->soc_alrt_thresh);\r\nmax17042_override_por(map, MAX17042_CONFIG, config->config);\r\nmax17042_override_por(map, MAX17042_SHDNTIMER, config->shdntimer);\r\nmax17042_override_por(map, MAX17042_DesignCap, config->design_cap);\r\nmax17042_override_por(map, MAX17042_ICHGTerm, config->ichgt_term);\r\nmax17042_override_por(map, MAX17042_AtRate, config->at_rate);\r\nmax17042_override_por(map, MAX17042_LearnCFG, config->learn_cfg);\r\nmax17042_override_por(map, MAX17042_FilterCFG, config->filter_cfg);\r\nmax17042_override_por(map, MAX17042_RelaxCFG, config->relax_cfg);\r\nmax17042_override_por(map, MAX17042_MiscCFG, config->misc_cfg);\r\nmax17042_override_por(map, MAX17042_MaskSOC, config->masksoc);\r\nmax17042_override_por(map, MAX17042_FullCAP, config->fullcap);\r\nmax17042_override_por(map, MAX17042_FullCAPNom, config->fullcapnom);\r\nif (chip->chip_type == MAX17042)\r\nmax17042_override_por(map, MAX17042_SOC_empty,\r\nconfig->socempty);\r\nmax17042_override_por(map, MAX17042_LAvg_empty, config->lavg_empty);\r\nmax17042_override_por(map, MAX17042_dQacc, config->dqacc);\r\nmax17042_override_por(map, MAX17042_dPacc, config->dpacc);\r\nif (chip->chip_type == MAX17042)\r\nmax17042_override_por(map, MAX17042_V_empty, config->vempty);\r\nelse\r\nmax17042_override_por(map, MAX17047_V_empty, config->vempty);\r\nmax17042_override_por(map, MAX17042_TempNom, config->temp_nom);\r\nmax17042_override_por(map, MAX17042_TempLim, config->temp_lim);\r\nmax17042_override_por(map, MAX17042_FCTC, config->fctc);\r\nmax17042_override_por(map, MAX17042_RCOMP0, config->rcomp0);\r\nmax17042_override_por(map, MAX17042_TempCo, config->tcompc0);\r\nif (chip->chip_type) {\r\nmax17042_override_por(map, MAX17042_EmptyTempCo,\r\nconfig->empty_tempco);\r\nmax17042_override_por(map, MAX17042_K_empty0,\r\nconfig->kempty0);\r\n}\r\n}\r\nstatic int max17042_init_chip(struct max17042_chip *chip)\r\n{\r\nstruct regmap *map = chip->regmap;\r\nint ret;\r\nint val;\r\nmax17042_override_por_values(chip);\r\nmsleep(500);\r\nmax17042_write_config_regs(chip);\r\nret = max17042_init_model(chip);\r\nif (ret) {\r\ndev_err(&chip->client->dev, "%s init failed\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\nret = max17042_verify_model_lock(chip);\r\nif (ret) {\r\ndev_err(&chip->client->dev, "%s lock verify failed\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\nmax17042_write_custom_regs(chip);\r\nmax17042_update_capacity_regs(chip);\r\nmsleep(350);\r\nmax17042_reset_vfsoc0_reg(chip);\r\nmax17042_load_new_capacity_params(chip);\r\nregmap_read(map, MAX17042_STATUS, &val);\r\nregmap_write(map, MAX17042_STATUS, val & (~STATUS_POR_BIT));\r\nreturn 0;\r\n}\r\nstatic void max17042_set_soc_threshold(struct max17042_chip *chip, u16 off)\r\n{\r\nstruct regmap *map = chip->regmap;\r\nu32 soc, soc_tr;\r\nregmap_read(map, MAX17042_RepSOC, &soc);\r\nsoc >>= 8;\r\nsoc_tr = (soc + off) << 8;\r\nsoc_tr |= (soc - off);\r\nregmap_write(map, MAX17042_SALRT_Th, soc_tr);\r\n}\r\nstatic irqreturn_t max17042_thread_handler(int id, void *dev)\r\n{\r\nstruct max17042_chip *chip = dev;\r\nu32 val;\r\nregmap_read(chip->regmap, MAX17042_STATUS, &val);\r\nif ((val & STATUS_INTR_SOCMIN_BIT) ||\r\n(val & STATUS_INTR_SOCMAX_BIT)) {\r\ndev_info(&chip->client->dev, "SOC threshold INTR\n");\r\nmax17042_set_soc_threshold(chip, 1);\r\n}\r\npower_supply_changed(&chip->battery);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void max17042_init_worker(struct work_struct *work)\r\n{\r\nstruct max17042_chip *chip = container_of(work,\r\nstruct max17042_chip, work);\r\nint ret;\r\nif (chip->pdata->enable_por_init && chip->pdata->config_data) {\r\nret = max17042_init_chip(chip);\r\nif (ret)\r\nreturn;\r\n}\r\nchip->init_complete = 1;\r\n}\r\nstatic struct max17042_platform_data *\r\nmax17042_get_pdata(struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nu32 prop;\r\nstruct max17042_platform_data *pdata;\r\nif (!np)\r\nreturn dev->platform_data;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nif (of_property_read_u32(np, "maxim,rsns-microohm", &prop) == 0) {\r\npdata->r_sns = prop;\r\npdata->enable_current_sense = true;\r\n}\r\nreturn pdata;\r\n}\r\nstatic struct max17042_platform_data *\r\nmax17042_get_pdata(struct device *dev)\r\n{\r\nreturn dev->platform_data;\r\n}\r\nstatic int max17042_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct max17042_chip *chip;\r\nint ret;\r\nint i;\r\nu32 val;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -EIO;\r\nchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->client = client;\r\nchip->regmap = devm_regmap_init_i2c(client, &max17042_regmap_config);\r\nif (IS_ERR(chip->regmap)) {\r\ndev_err(&client->dev, "Failed to initialize regmap\n");\r\nreturn -EINVAL;\r\n}\r\nchip->pdata = max17042_get_pdata(&client->dev);\r\nif (!chip->pdata) {\r\ndev_err(&client->dev, "no platform data provided\n");\r\nreturn -EINVAL;\r\n}\r\ni2c_set_clientdata(client, chip);\r\nregmap_read(chip->regmap, MAX17042_DevName, &val);\r\nif (val == MAX17042_IC_VERSION) {\r\ndev_dbg(&client->dev, "chip type max17042 detected\n");\r\nchip->chip_type = MAX17042;\r\n} else if (val == MAX17047_IC_VERSION) {\r\ndev_dbg(&client->dev, "chip type max17047/50 detected\n");\r\nchip->chip_type = MAX17047;\r\n} else {\r\ndev_err(&client->dev, "device version mismatch: %x\n", val);\r\nreturn -EIO;\r\n}\r\nchip->battery.name = "max170xx_battery";\r\nchip->battery.type = POWER_SUPPLY_TYPE_BATTERY;\r\nchip->battery.get_property = max17042_get_property;\r\nchip->battery.properties = max17042_battery_props;\r\nchip->battery.num_properties = ARRAY_SIZE(max17042_battery_props);\r\nif (!chip->pdata->enable_current_sense)\r\nchip->battery.num_properties -= 2;\r\nif (chip->pdata->r_sns == 0)\r\nchip->pdata->r_sns = MAX17042_DEFAULT_SNS_RESISTOR;\r\nif (chip->pdata->init_data)\r\nfor (i = 0; i < chip->pdata->num_init_data; i++)\r\nregmap_write(chip->regmap,\r\nchip->pdata->init_data[i].addr,\r\nchip->pdata->init_data[i].data);\r\nif (!chip->pdata->enable_current_sense) {\r\nregmap_write(chip->regmap, MAX17042_CGAIN, 0x0000);\r\nregmap_write(chip->regmap, MAX17042_MiscCFG, 0x0003);\r\nregmap_write(chip->regmap, MAX17042_LearnCFG, 0x0007);\r\n}\r\nret = power_supply_register(&client->dev, &chip->battery);\r\nif (ret) {\r\ndev_err(&client->dev, "failed: power supply register\n");\r\nreturn ret;\r\n}\r\nif (client->irq) {\r\nret = request_threaded_irq(client->irq, NULL,\r\nmax17042_thread_handler,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nchip->battery.name, chip);\r\nif (!ret) {\r\nregmap_read(chip->regmap, MAX17042_CONFIG, &val);\r\nval |= CONFIG_ALRT_BIT_ENBL;\r\nregmap_write(chip->regmap, MAX17042_CONFIG, val);\r\nmax17042_set_soc_threshold(chip, 1);\r\n} else {\r\nclient->irq = 0;\r\ndev_err(&client->dev, "%s(): cannot get IRQ\n",\r\n__func__);\r\n}\r\n}\r\nregmap_read(chip->regmap, MAX17042_STATUS, &val);\r\nif (val & STATUS_POR_BIT) {\r\nINIT_WORK(&chip->work, max17042_init_worker);\r\nschedule_work(&chip->work);\r\n} else {\r\nchip->init_complete = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max17042_remove(struct i2c_client *client)\r\n{\r\nstruct max17042_chip *chip = i2c_get_clientdata(client);\r\nif (client->irq)\r\nfree_irq(client->irq, chip);\r\npower_supply_unregister(&chip->battery);\r\nreturn 0;\r\n}\r\nstatic int max17042_suspend(struct device *dev)\r\n{\r\nstruct max17042_chip *chip = dev_get_drvdata(dev);\r\nif (chip->client->irq) {\r\ndisable_irq(chip->client->irq);\r\nenable_irq_wake(chip->client->irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max17042_resume(struct device *dev)\r\n{\r\nstruct max17042_chip *chip = dev_get_drvdata(dev);\r\nif (chip->client->irq) {\r\ndisable_irq_wake(chip->client->irq);\r\nenable_irq(chip->client->irq);\r\nmax17042_set_soc_threshold(chip, 1);\r\n}\r\nreturn 0;\r\n}
