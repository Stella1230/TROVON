static unsigned int nf_nat_fn(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nstruct nf_conn_nat *nat;\r\nenum nf_nat_manip_type maniptype = HOOK2MANIP(ops->hooknum);\r\nstruct nft_pktinfo pkt;\r\nunsigned int ret;\r\nif (ct == NULL || nf_ct_is_untracked(ct))\r\nreturn NF_ACCEPT;\r\nNF_CT_ASSERT(!(ip_hdr(skb)->frag_off & htons(IP_MF | IP_OFFSET)));\r\nnat = nfct_nat(ct);\r\nif (nat == NULL) {\r\nif (nf_ct_is_confirmed(ct))\r\nreturn NF_ACCEPT;\r\nnat = nf_ct_ext_add(ct, NF_CT_EXT_NAT, GFP_ATOMIC);\r\nif (nat == NULL)\r\nreturn NF_ACCEPT;\r\n}\r\nswitch (ctinfo) {\r\ncase IP_CT_RELATED:\r\ncase IP_CT_RELATED + IP_CT_IS_REPLY:\r\nif (ip_hdr(skb)->protocol == IPPROTO_ICMP) {\r\nif (!nf_nat_icmp_reply_translation(skb, ct, ctinfo,\r\nops->hooknum))\r\nreturn NF_DROP;\r\nelse\r\nreturn NF_ACCEPT;\r\n}\r\ncase IP_CT_NEW:\r\nif (nf_nat_initialized(ct, maniptype))\r\nbreak;\r\nnft_set_pktinfo_ipv4(&pkt, ops, skb, in, out);\r\nret = nft_do_chain(&pkt, ops);\r\nif (ret != NF_ACCEPT)\r\nreturn ret;\r\nif (!nf_nat_initialized(ct, maniptype)) {\r\nret = nf_nat_alloc_null_binding(ct, ops->hooknum);\r\nif (ret != NF_ACCEPT)\r\nreturn ret;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn nf_nat_packet(ct, ctinfo, ops->hooknum, skb);\r\n}\r\nstatic unsigned int nf_nat_prerouting(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\n__be32 daddr = ip_hdr(skb)->daddr;\r\nunsigned int ret;\r\nret = nf_nat_fn(ops, skb, in, out, okfn);\r\nif (ret != NF_DROP && ret != NF_STOLEN &&\r\nip_hdr(skb)->daddr != daddr) {\r\nskb_dst_drop(skb);\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int nf_nat_postrouting(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nenum ip_conntrack_info ctinfo __maybe_unused;\r\nconst struct nf_conn *ct __maybe_unused;\r\nunsigned int ret;\r\nret = nf_nat_fn(ops, skb, in, out, okfn);\r\n#ifdef CONFIG_XFRM\r\nif (ret != NF_DROP && ret != NF_STOLEN &&\r\n(ct = nf_ct_get(skb, &ctinfo)) != NULL) {\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nif (ct->tuplehash[dir].tuple.src.u3.ip !=\r\nct->tuplehash[!dir].tuple.dst.u3.ip ||\r\nct->tuplehash[dir].tuple.src.u.all !=\r\nct->tuplehash[!dir].tuple.dst.u.all)\r\nreturn nf_xfrm_me_harder(skb, AF_INET) == 0 ?\r\nret : NF_DROP;\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic unsigned int nf_nat_output(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nconst struct nf_conn *ct;\r\nunsigned int ret;\r\nret = nf_nat_fn(ops, skb, in, out, okfn);\r\nif (ret != NF_DROP && ret != NF_STOLEN &&\r\n(ct = nf_ct_get(skb, &ctinfo)) != NULL) {\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nif (ct->tuplehash[dir].tuple.dst.u3.ip !=\r\nct->tuplehash[!dir].tuple.src.u3.ip) {\r\nif (ip_route_me_harder(skb, RTN_UNSPEC))\r\nret = NF_DROP;\r\n}\r\n#ifdef CONFIG_XFRM\r\nelse if (ct->tuplehash[dir].tuple.dst.u.all !=\r\nct->tuplehash[!dir].tuple.src.u.all)\r\nif (nf_xfrm_me_harder(skb, AF_INET))\r\nret = NF_DROP;\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init nft_chain_nat_init(void)\r\n{\r\nint err;\r\nerr = nft_register_chain_type(&nft_chain_nat_ipv4);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void __exit nft_chain_nat_exit(void)\r\n{\r\nnft_unregister_chain_type(&nft_chain_nat_ipv4);\r\n}
