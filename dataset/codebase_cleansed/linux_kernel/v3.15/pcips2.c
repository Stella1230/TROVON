static int pcips2_write(struct serio *io, unsigned char val)\r\n{\r\nstruct pcips2_data *ps2if = io->port_data;\r\nunsigned int stat;\r\ndo {\r\nstat = inb(ps2if->base + PS2_STATUS);\r\ncpu_relax();\r\n} while (!(stat & PS2_STAT_TXEMPTY));\r\noutb(val, ps2if->base + PS2_DATA);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pcips2_interrupt(int irq, void *devid)\r\n{\r\nstruct pcips2_data *ps2if = devid;\r\nunsigned char status, scancode;\r\nint handled = 0;\r\ndo {\r\nunsigned int flag;\r\nstatus = inb(ps2if->base + PS2_STATUS);\r\nif (!(status & PS2_STAT_RXFULL))\r\nbreak;\r\nhandled = 1;\r\nscancode = inb(ps2if->base + PS2_DATA);\r\nif (status == 0xff && scancode == 0xff)\r\nbreak;\r\nflag = (status & PS2_STAT_PARITY) ? 0 : SERIO_PARITY;\r\nif (hweight8(scancode) & 1)\r\nflag ^= SERIO_PARITY;\r\nserio_interrupt(ps2if->io, scancode, flag);\r\n} while (1);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void pcips2_flush_input(struct pcips2_data *ps2if)\r\n{\r\nunsigned char status, scancode;\r\ndo {\r\nstatus = inb(ps2if->base + PS2_STATUS);\r\nif (!(status & PS2_STAT_RXFULL))\r\nbreak;\r\nscancode = inb(ps2if->base + PS2_DATA);\r\nif (status == 0xff && scancode == 0xff)\r\nbreak;\r\n} while (1);\r\n}\r\nstatic int pcips2_open(struct serio *io)\r\n{\r\nstruct pcips2_data *ps2if = io->port_data;\r\nint ret, val = 0;\r\noutb(PS2_CTRL_ENABLE, ps2if->base);\r\npcips2_flush_input(ps2if);\r\nret = request_irq(ps2if->dev->irq, pcips2_interrupt, IRQF_SHARED,\r\n"pcips2", ps2if);\r\nif (ret == 0)\r\nval = PS2_CTRL_ENABLE | PS2_CTRL_RXIRQ;\r\noutb(val, ps2if->base);\r\nreturn ret;\r\n}\r\nstatic void pcips2_close(struct serio *io)\r\n{\r\nstruct pcips2_data *ps2if = io->port_data;\r\noutb(0, ps2if->base);\r\nfree_irq(ps2if->dev->irq, ps2if);\r\n}\r\nstatic int pcips2_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct pcips2_data *ps2if;\r\nstruct serio *serio;\r\nint ret;\r\nret = pci_enable_device(dev);\r\nif (ret)\r\ngoto out;\r\nret = pci_request_regions(dev, "pcips2");\r\nif (ret)\r\ngoto disable;\r\nps2if = kzalloc(sizeof(struct pcips2_data), GFP_KERNEL);\r\nserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!ps2if || !serio) {\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\nserio->id.type = SERIO_8042;\r\nserio->write = pcips2_write;\r\nserio->open = pcips2_open;\r\nserio->close = pcips2_close;\r\nstrlcpy(serio->name, pci_name(dev), sizeof(serio->name));\r\nstrlcpy(serio->phys, dev_name(&dev->dev), sizeof(serio->phys));\r\nserio->port_data = ps2if;\r\nserio->dev.parent = &dev->dev;\r\nps2if->io = serio;\r\nps2if->dev = dev;\r\nps2if->base = pci_resource_start(dev, 0);\r\npci_set_drvdata(dev, ps2if);\r\nserio_register_port(ps2if->io);\r\nreturn 0;\r\nrelease:\r\nkfree(ps2if);\r\nkfree(serio);\r\npci_release_regions(dev);\r\ndisable:\r\npci_disable_device(dev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void pcips2_remove(struct pci_dev *dev)\r\n{\r\nstruct pcips2_data *ps2if = pci_get_drvdata(dev);\r\nserio_unregister_port(ps2if->io);\r\nkfree(ps2if);\r\npci_release_regions(dev);\r\npci_disable_device(dev);\r\n}
