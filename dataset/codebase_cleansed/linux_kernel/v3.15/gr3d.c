static inline struct gr3d *to_gr3d(struct tegra_drm_client *client)\r\n{\r\nreturn container_of(client, struct gr3d, client);\r\n}\r\nstatic int gr3d_init(struct host1x_client *client)\r\n{\r\nstruct tegra_drm_client *drm = host1x_to_drm_client(client);\r\nstruct tegra_drm *tegra = dev_get_drvdata(client->parent);\r\nunsigned long flags = HOST1X_SYNCPT_HAS_BASE;\r\nstruct gr3d *gr3d = to_gr3d(drm);\r\ngr3d->channel = host1x_channel_request(client->dev);\r\nif (!gr3d->channel)\r\nreturn -ENOMEM;\r\nclient->syncpts[0] = host1x_syncpt_request(client->dev, flags);\r\nif (!client->syncpts[0]) {\r\nhost1x_channel_free(gr3d->channel);\r\nreturn -ENOMEM;\r\n}\r\nreturn tegra_drm_register_client(tegra, drm);\r\n}\r\nstatic int gr3d_exit(struct host1x_client *client)\r\n{\r\nstruct tegra_drm_client *drm = host1x_to_drm_client(client);\r\nstruct tegra_drm *tegra = dev_get_drvdata(client->parent);\r\nstruct gr3d *gr3d = to_gr3d(drm);\r\nint err;\r\nerr = tegra_drm_unregister_client(tegra, drm);\r\nif (err < 0)\r\nreturn err;\r\nhost1x_syncpt_free(client->syncpts[0]);\r\nhost1x_channel_free(gr3d->channel);\r\nreturn 0;\r\n}\r\nstatic int gr3d_open_channel(struct tegra_drm_client *client,\r\nstruct tegra_drm_context *context)\r\n{\r\nstruct gr3d *gr3d = to_gr3d(client);\r\ncontext->channel = host1x_channel_get(gr3d->channel);\r\nif (!context->channel)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void gr3d_close_channel(struct tegra_drm_context *context)\r\n{\r\nhost1x_channel_put(context->channel);\r\n}\r\nstatic int gr3d_is_addr_reg(struct device *dev, u32 class, u32 offset)\r\n{\r\nstruct gr3d *gr3d = dev_get_drvdata(dev);\r\nswitch (class) {\r\ncase HOST1X_CLASS_HOST1X:\r\nif (offset == 0x2b)\r\nreturn 1;\r\nbreak;\r\ncase HOST1X_CLASS_GR3D:\r\nif (offset >= GR3D_NUM_REGS)\r\nbreak;\r\nif (test_bit(offset, gr3d->addr_regs))\r\nreturn 1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gr3d_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct host1x_syncpt **syncpts;\r\nstruct gr3d *gr3d;\r\nunsigned int i;\r\nint err;\r\ngr3d = devm_kzalloc(&pdev->dev, sizeof(*gr3d), GFP_KERNEL);\r\nif (!gr3d)\r\nreturn -ENOMEM;\r\nsyncpts = devm_kzalloc(&pdev->dev, sizeof(*syncpts), GFP_KERNEL);\r\nif (!syncpts)\r\nreturn -ENOMEM;\r\ngr3d->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(gr3d->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nreturn PTR_ERR(gr3d->clk);\r\n}\r\ngr3d->rst = devm_reset_control_get(&pdev->dev, "3d");\r\nif (IS_ERR(gr3d->rst)) {\r\ndev_err(&pdev->dev, "cannot get reset\n");\r\nreturn PTR_ERR(gr3d->rst);\r\n}\r\nif (of_device_is_compatible(np, "nvidia,tegra30-gr3d")) {\r\ngr3d->clk_secondary = devm_clk_get(&pdev->dev, "3d2");\r\nif (IS_ERR(gr3d->clk)) {\r\ndev_err(&pdev->dev, "cannot get secondary clock\n");\r\nreturn PTR_ERR(gr3d->clk);\r\n}\r\ngr3d->rst_secondary = devm_reset_control_get(&pdev->dev,\r\n"3d2");\r\nif (IS_ERR(gr3d->rst_secondary)) {\r\ndev_err(&pdev->dev, "cannot get secondary reset\n");\r\nreturn PTR_ERR(gr3d->rst_secondary);\r\n}\r\n}\r\nerr = tegra_powergate_sequence_power_up(TEGRA_POWERGATE_3D, gr3d->clk,\r\ngr3d->rst);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to power up 3D unit\n");\r\nreturn err;\r\n}\r\nif (gr3d->clk_secondary) {\r\nerr = tegra_powergate_sequence_power_up(TEGRA_POWERGATE_3D1,\r\ngr3d->clk_secondary,\r\ngr3d->rst_secondary);\r\nif (err < 0) {\r\ndev_err(&pdev->dev,\r\n"failed to power up secondary 3D unit\n");\r\nreturn err;\r\n}\r\n}\r\nINIT_LIST_HEAD(&gr3d->client.base.list);\r\ngr3d->client.base.ops = &gr3d_client_ops;\r\ngr3d->client.base.dev = &pdev->dev;\r\ngr3d->client.base.class = HOST1X_CLASS_GR3D;\r\ngr3d->client.base.syncpts = syncpts;\r\ngr3d->client.base.num_syncpts = 1;\r\nINIT_LIST_HEAD(&gr3d->client.list);\r\ngr3d->client.ops = &gr3d_ops;\r\nerr = host1x_client_register(&gr3d->client.base);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to register host1x client: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(gr3d_addr_regs); i++)\r\nset_bit(gr3d_addr_regs[i], gr3d->addr_regs);\r\nplatform_set_drvdata(pdev, gr3d);\r\nreturn 0;\r\n}\r\nstatic int gr3d_remove(struct platform_device *pdev)\r\n{\r\nstruct gr3d *gr3d = platform_get_drvdata(pdev);\r\nint err;\r\nerr = host1x_client_unregister(&gr3d->client.base);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to unregister host1x client: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nif (gr3d->clk_secondary) {\r\ntegra_powergate_power_off(TEGRA_POWERGATE_3D1);\r\nclk_disable_unprepare(gr3d->clk_secondary);\r\n}\r\ntegra_powergate_power_off(TEGRA_POWERGATE_3D);\r\nclk_disable_unprepare(gr3d->clk);\r\nreturn 0;\r\n}
