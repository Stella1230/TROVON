static int cx25840_set_audclk_freq(struct i2c_client *client, u32 freq)\r\n{\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nif (state->aud_input != CX25840_AUDIO_SERIAL) {\r\nswitch (freq) {\r\ncase 32000:\r\ncx25840_write4(client, 0x108, 0x1006040f);\r\ncx25840_write4(client, 0x110, 0x01bb39ee);\r\ncx25840_write(client, 0x127, 0x50);\r\nif (is_cx2583x(state))\r\nbreak;\r\ncx25840_write4(client, 0x900, 0x0801f77f);\r\ncx25840_write4(client, 0x904, 0x0801f77f);\r\ncx25840_write4(client, 0x90c, 0x0801f77f);\r\nbreak;\r\ncase 44100:\r\ncx25840_write4(client, 0x108, 0x1009040f);\r\ncx25840_write4(client, 0x110, 0x00ec6bd6);\r\ncx25840_write(client, 0x127, 0x50);\r\nif (is_cx2583x(state))\r\nbreak;\r\ncx25840_write4(client, 0x900, 0x08016d59);\r\ncx25840_write4(client, 0x904, 0x08016d59);\r\ncx25840_write4(client, 0x90c, 0x08016d59);\r\nbreak;\r\ncase 48000:\r\ncx25840_write4(client, 0x108, 0x100a040f);\r\ncx25840_write4(client, 0x110, 0x0098d6e5);\r\ncx25840_write(client, 0x127, 0x50);\r\nif (is_cx2583x(state))\r\nbreak;\r\ncx25840_write4(client, 0x900, 0x08014faa);\r\ncx25840_write4(client, 0x904, 0x08014faa);\r\ncx25840_write4(client, 0x90c, 0x08014faa);\r\nbreak;\r\n}\r\n} else {\r\nswitch (freq) {\r\ncase 32000:\r\ncx25840_write4(client, 0x108, 0x1e08040f);\r\ncx25840_write4(client, 0x110, 0x012a0869);\r\ncx25840_write(client, 0x127, 0x54);\r\nif (is_cx2583x(state))\r\nbreak;\r\ncx25840_write4(client, 0x8f8, 0x08010000);\r\ncx25840_write4(client, 0x900, 0x08020000);\r\ncx25840_write4(client, 0x904, 0x08020000);\r\ncx25840_write4(client, 0x90c, 0x08020000);\r\nbreak;\r\ncase 44100:\r\ncx25840_write4(client, 0x108, 0x1809040f);\r\ncx25840_write4(client, 0x110, 0x00ec6bd6);\r\ncx25840_write(client, 0x127, 0x50);\r\nif (is_cx2583x(state))\r\nbreak;\r\ncx25840_write4(client, 0x8f8, 0x080160cd);\r\ncx25840_write4(client, 0x900, 0x08017385);\r\ncx25840_write4(client, 0x904, 0x08017385);\r\ncx25840_write4(client, 0x90c, 0x08017385);\r\nbreak;\r\ncase 48000:\r\ncx25840_write4(client, 0x108, 0x180a040f);\r\ncx25840_write4(client, 0x110, 0x0098d6e5);\r\ncx25840_write(client, 0x127, 0x50);\r\nif (is_cx2583x(state))\r\nbreak;\r\ncx25840_write4(client, 0x8f8, 0x08018000);\r\ncx25840_write4(client, 0x900, 0x08015555);\r\ncx25840_write4(client, 0x904, 0x08015555);\r\ncx25840_write4(client, 0x90c, 0x08015555);\r\nbreak;\r\n}\r\n}\r\nstate->audclk_freq = freq;\r\nreturn 0;\r\n}\r\nstatic inline int cx25836_set_audclk_freq(struct i2c_client *client, u32 freq)\r\n{\r\nreturn cx25840_set_audclk_freq(client, freq);\r\n}\r\nstatic int cx23885_set_audclk_freq(struct i2c_client *client, u32 freq)\r\n{\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nif (state->aud_input != CX25840_AUDIO_SERIAL) {\r\nswitch (freq) {\r\ncase 32000:\r\ncase 44100:\r\ncase 48000:\r\nbreak;\r\n}\r\n} else {\r\nswitch (freq) {\r\ncase 32000:\r\ncase 44100:\r\nbreak;\r\ncase 48000:\r\ncx25840_write4(client, 0x8f8, 0x0801867c);\r\ncx25840_write4(client, 0x900, 0x08014faa);\r\ncx25840_write4(client, 0x904, 0x08014faa);\r\ncx25840_write4(client, 0x90c, 0x08014faa);\r\nbreak;\r\n}\r\n}\r\nstate->audclk_freq = freq;\r\nreturn 0;\r\n}\r\nstatic int cx231xx_set_audclk_freq(struct i2c_client *client, u32 freq)\r\n{\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nif (state->aud_input != CX25840_AUDIO_SERIAL) {\r\nswitch (freq) {\r\ncase 32000:\r\ncx25840_write4(client, 0x900, 0x0801f77f);\r\ncx25840_write4(client, 0x904, 0x0801f77f);\r\ncx25840_write4(client, 0x90c, 0x0801f77f);\r\nbreak;\r\ncase 44100:\r\ncx25840_write4(client, 0x900, 0x08016d59);\r\ncx25840_write4(client, 0x904, 0x08016d59);\r\ncx25840_write4(client, 0x90c, 0x08016d59);\r\nbreak;\r\ncase 48000:\r\ncx25840_write4(client, 0x900, 0x08014faa);\r\ncx25840_write4(client, 0x904, 0x08014faa);\r\ncx25840_write4(client, 0x90c, 0x08014faa);\r\nbreak;\r\n}\r\n} else {\r\nswitch (freq) {\r\ncase 32000:\r\ncx25840_write4(client, 0x8f8, 0x08010000);\r\ncx25840_write4(client, 0x900, 0x08020000);\r\ncx25840_write4(client, 0x904, 0x08020000);\r\ncx25840_write4(client, 0x90c, 0x08020000);\r\nbreak;\r\ncase 44100:\r\ncx25840_write4(client, 0x8f8, 0x080160cd);\r\ncx25840_write4(client, 0x900, 0x08017385);\r\ncx25840_write4(client, 0x904, 0x08017385);\r\ncx25840_write4(client, 0x90c, 0x08017385);\r\nbreak;\r\ncase 48000:\r\ncx25840_write4(client, 0x8f8, 0x0801867c);\r\ncx25840_write4(client, 0x900, 0x08014faa);\r\ncx25840_write4(client, 0x904, 0x08014faa);\r\ncx25840_write4(client, 0x90c, 0x08014faa);\r\nbreak;\r\n}\r\n}\r\nstate->audclk_freq = freq;\r\nreturn 0;\r\n}\r\nstatic int set_audclk_freq(struct i2c_client *client, u32 freq)\r\n{\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nif (freq != 32000 && freq != 44100 && freq != 48000)\r\nreturn -EINVAL;\r\nif (is_cx231xx(state))\r\nreturn cx231xx_set_audclk_freq(client, freq);\r\nif (is_cx2388x(state))\r\nreturn cx23885_set_audclk_freq(client, freq);\r\nif (is_cx2583x(state))\r\nreturn cx25836_set_audclk_freq(client, freq);\r\nreturn cx25840_set_audclk_freq(client, freq);\r\n}\r\nvoid cx25840_audio_set_path(struct i2c_client *client)\r\n{\r\nstruct cx25840_state *state = to_state(i2c_get_clientdata(client));\r\nif (!is_cx2583x(state)) {\r\ncx25840_and_or(client, 0x810, ~0x1, 0x01);\r\ncx25840_and_or(client, 0x803, ~0x10, 0);\r\ncx25840_write(client, 0x8d3, 0x1f);\r\nif (state->aud_input == CX25840_AUDIO_SERIAL) {\r\ncx25840_write4(client, 0x8d0, 0x01011012);\r\n} else {\r\ncx25840_write4(client, 0x8d0, 0x1f063870);\r\n}\r\n}\r\nset_audclk_freq(client, state->audclk_freq);\r\nif (!is_cx2583x(state)) {\r\nif (state->aud_input != CX25840_AUDIO_SERIAL) {\r\ncx25840_and_or(client, 0x803, ~0x10, 0x10);\r\n}\r\ncx25840_and_or(client, 0x810, ~0x1, 0x00);\r\nif (is_cx2388x(state) || is_cx231xx(state))\r\ncx25840_and_or(client, 0x803, ~0x10, 0x10);\r\n}\r\n}\r\nstatic void set_volume(struct i2c_client *client, int volume)\r\n{\r\nint vol;\r\nvol = volume >> 9;\r\nif (vol <= 23) {\r\nvol = 0;\r\n} else {\r\nvol -= 23;\r\n}\r\ncx25840_write(client, 0x8d4, 228 - (vol * 2));\r\n}\r\nstatic void set_balance(struct i2c_client *client, int balance)\r\n{\r\nint bal = balance >> 8;\r\nif (bal > 0x80) {\r\ncx25840_and_or(client, 0x8d5, 0x7f, 0x80);\r\ncx25840_and_or(client, 0x8d5, ~0x7f, bal & 0x7f);\r\n} else {\r\ncx25840_and_or(client, 0x8d5, 0x7f, 0x00);\r\ncx25840_and_or(client, 0x8d5, ~0x7f, 0x80 - bal);\r\n}\r\n}\r\nint cx25840_s_clock_freq(struct v4l2_subdev *sd, u32 freq)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct cx25840_state *state = to_state(sd);\r\nint retval;\r\nif (!is_cx2583x(state))\r\ncx25840_and_or(client, 0x810, ~0x1, 1);\r\nif (state->aud_input != CX25840_AUDIO_SERIAL) {\r\ncx25840_and_or(client, 0x803, ~0x10, 0);\r\ncx25840_write(client, 0x8d3, 0x1f);\r\n}\r\nretval = set_audclk_freq(client, freq);\r\nif (state->aud_input != CX25840_AUDIO_SERIAL)\r\ncx25840_and_or(client, 0x803, ~0x10, 0x10);\r\nif (!is_cx2583x(state))\r\ncx25840_and_or(client, 0x810, ~0x1, 0);\r\nreturn retval;\r\n}\r\nstatic int cx25840_audio_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct cx25840_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nif (state->mute->val)\r\nset_volume(client, 0);\r\nelse\r\nset_volume(client, state->volume->val);\r\nbreak;\r\ncase V4L2_CID_AUDIO_BASS:\r\ncx25840_and_or(client, 0x8d9, ~0x3f,\r\n48 - (ctrl->val * 48 / 0xffff));\r\nbreak;\r\ncase V4L2_CID_AUDIO_TREBLE:\r\ncx25840_and_or(client, 0x8db, ~0x3f,\r\n48 - (ctrl->val * 48 / 0xffff));\r\nbreak;\r\ncase V4L2_CID_AUDIO_BALANCE:\r\nset_balance(client, ctrl->val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}
