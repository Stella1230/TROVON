int bridge_probe(nasid_t nasid, int widget_id, int masterwid)\r\n{\r\nunsigned long offset = NODE_OFFSET(nasid);\r\nstruct bridge_controller *bc;\r\nstatic int num_bridges = 0;\r\nbridge_t *bridge;\r\nint slot;\r\npci_set_flags(PCI_PROBE_ONLY);\r\nprintk("a bridge\n");\r\nif (!num_bridges)\r\nioport_resource.end = ~0UL;\r\nbc = &bridges[num_bridges];\r\nbc->pc.pci_ops = &bridge_pci_ops;\r\nbc->pc.mem_resource = &bc->mem;\r\nbc->pc.io_resource = &bc->io;\r\nbc->pc.index = num_bridges;\r\nbc->mem.name = "Bridge PCI MEM";\r\nbc->pc.mem_offset = offset;\r\nbc->mem.start = 0;\r\nbc->mem.end = ~0UL;\r\nbc->mem.flags = IORESOURCE_MEM;\r\nbc->io.name = "Bridge IO MEM";\r\nbc->pc.io_offset = offset;\r\nbc->io.start = 0UL;\r\nbc->io.end = ~0UL;\r\nbc->io.flags = IORESOURCE_IO;\r\nbc->irq_cpu = smp_processor_id();\r\nbc->widget_id = widget_id;\r\nbc->nasid = nasid;\r\nbc->baddr = (u64)masterwid << 60 | PCI64_ATTR_BAR;\r\nbridge = (bridge_t *) RAW_NODE_SWIN_BASE(nasid, widget_id);\r\nbridge->b_int_rst_stat = BRIDGE_IRR_ALL_CLR;\r\nbridge->b_int_device = 0x0;\r\nbridge->b_wid_control |= BRIDGE_CTRL_IO_SWAP |\r\nBRIDGE_CTRL_MEM_SWAP;\r\n#ifdef CONFIG_PAGE_SIZE_4KB\r\nbridge->b_wid_control &= ~BRIDGE_CTRL_PAGE_SIZE;\r\n#else\r\nbridge->b_wid_control |= BRIDGE_CTRL_PAGE_SIZE;\r\n#endif\r\nbridge->b_wid_int_upper = 0x8000 | (masterwid << 16);\r\nbridge->b_wid_int_lower = 0x01800090;\r\nbridge->b_dir_map = (masterwid << 20);\r\nbridge->b_int_enable = 0;\r\nfor (slot = 0; slot < 8; slot ++) {\r\nbridge->b_device[slot].reg |= BRIDGE_DEV_SWAP_DIR;\r\nbc->pci_int[slot] = -1;\r\n}\r\nbridge->b_wid_tflush;\r\nbc->base = bridge;\r\nregister_pci_controller(&bc->pc);\r\nnum_bridges++;\r\nreturn 0;\r\n}\r\nint pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline struct pci_dev *bridge_root_dev(struct pci_dev *dev)\r\n{\r\nwhile (dev->bus->parent) {\r\ndev = dev->bus->self;\r\n}\r\nreturn dev;\r\n}\r\nint pcibios_plat_dev_init(struct pci_dev *dev)\r\n{\r\nstruct bridge_controller *bc = BRIDGE_CONTROLLER(dev->bus);\r\nstruct pci_dev *rdev = bridge_root_dev(dev);\r\nint slot = PCI_SLOT(rdev->devfn);\r\nint irq;\r\nirq = bc->pci_int[slot];\r\nif (irq == -1) {\r\nirq = request_bridge_irq(bc);\r\nif (irq < 0)\r\nreturn irq;\r\nbc->pci_int[slot] = irq;\r\n}\r\nirq_to_bridge[irq] = bc;\r\nirq_to_slot[irq] = slot;\r\ndev->irq = irq;\r\nreturn 0;\r\n}\r\nstatic inline void pci_disable_swapping(struct pci_dev *dev)\r\n{\r\nstruct bridge_controller *bc = BRIDGE_CONTROLLER(dev->bus);\r\nbridge_t *bridge = bc->base;\r\nint slot = PCI_SLOT(dev->devfn);\r\nbridge->b_device[slot].reg &= ~BRIDGE_DEV_SWAP_DIR;\r\nbridge->b_widget.w_tflush;\r\n}\r\nstatic inline void pci_enable_swapping(struct pci_dev *dev)\r\n{\r\nstruct bridge_controller *bc = BRIDGE_CONTROLLER(dev->bus);\r\nbridge_t *bridge = bc->base;\r\nint slot = PCI_SLOT(dev->devfn);\r\nbridge->b_device[slot].reg |= BRIDGE_DEV_SWAP_DIR;\r\nbridge->b_widget.w_tflush;\r\n}\r\nstatic void pci_fixup_ioc3(struct pci_dev *d)\r\n{\r\npci_disable_swapping(d);\r\n}\r\nint pcibus_to_node(struct pci_bus *bus)\r\n{\r\nstruct bridge_controller *bc = BRIDGE_CONTROLLER(bus);\r\nreturn bc->nasid;\r\n}
