static bool __power_supply_is_supplied_by(struct power_supply *supplier,\r\nstruct power_supply *supply)\r\n{\r\nint i;\r\nif (!supply->supplied_from && !supplier->supplied_to)\r\nreturn false;\r\nif (supply->supplied_from) {\r\nif (!supplier->name)\r\nreturn false;\r\nfor (i = 0; i < supply->num_supplies; i++)\r\nif (!strcmp(supplier->name, supply->supplied_from[i]))\r\nreturn true;\r\n} else {\r\nif (!supply->name)\r\nreturn false;\r\nfor (i = 0; i < supplier->num_supplicants; i++)\r\nif (!strcmp(supplier->supplied_to[i], supply->name))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int __power_supply_changed_work(struct device *dev, void *data)\r\n{\r\nstruct power_supply *psy = (struct power_supply *)data;\r\nstruct power_supply *pst = dev_get_drvdata(dev);\r\nif (__power_supply_is_supplied_by(psy, pst)) {\r\nif (pst->external_power_changed)\r\npst->external_power_changed(pst);\r\n}\r\nreturn 0;\r\n}\r\nstatic void power_supply_changed_work(struct work_struct *work)\r\n{\r\nunsigned long flags;\r\nstruct power_supply *psy = container_of(work, struct power_supply,\r\nchanged_work);\r\ndev_dbg(psy->dev, "%s\n", __func__);\r\nspin_lock_irqsave(&psy->changed_lock, flags);\r\nif (psy->changed) {\r\npsy->changed = false;\r\nspin_unlock_irqrestore(&psy->changed_lock, flags);\r\nclass_for_each_device(power_supply_class, NULL, psy,\r\n__power_supply_changed_work);\r\npower_supply_update_leds(psy);\r\natomic_notifier_call_chain(&power_supply_notifier,\r\nPSY_EVENT_PROP_CHANGED, psy);\r\nkobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);\r\nspin_lock_irqsave(&psy->changed_lock, flags);\r\n}\r\nif (!psy->changed)\r\npm_relax(psy->dev);\r\nspin_unlock_irqrestore(&psy->changed_lock, flags);\r\n}\r\nvoid power_supply_changed(struct power_supply *psy)\r\n{\r\nunsigned long flags;\r\ndev_dbg(psy->dev, "%s\n", __func__);\r\nspin_lock_irqsave(&psy->changed_lock, flags);\r\npsy->changed = true;\r\npm_stay_awake(psy->dev);\r\nspin_unlock_irqrestore(&psy->changed_lock, flags);\r\nschedule_work(&psy->changed_work);\r\n}\r\nstatic int __power_supply_populate_supplied_from(struct device *dev,\r\nvoid *data)\r\n{\r\nstruct power_supply *psy = (struct power_supply *)data;\r\nstruct power_supply *epsy = dev_get_drvdata(dev);\r\nstruct device_node *np;\r\nint i = 0;\r\ndo {\r\nnp = of_parse_phandle(psy->of_node, "power-supplies", i++);\r\nif (!np)\r\ncontinue;\r\nif (np == epsy->of_node) {\r\ndev_info(psy->dev, "%s: Found supply : %s\n",\r\npsy->name, epsy->name);\r\npsy->supplied_from[i-1] = (char *)epsy->name;\r\npsy->num_supplies++;\r\nof_node_put(np);\r\nbreak;\r\n}\r\nof_node_put(np);\r\n} while (np);\r\nreturn 0;\r\n}\r\nstatic int power_supply_populate_supplied_from(struct power_supply *psy)\r\n{\r\nint error;\r\nerror = class_for_each_device(power_supply_class, NULL, psy,\r\n__power_supply_populate_supplied_from);\r\ndev_dbg(psy->dev, "%s %d\n", __func__, error);\r\nreturn error;\r\n}\r\nstatic int __power_supply_find_supply_from_node(struct device *dev,\r\nvoid *data)\r\n{\r\nstruct device_node *np = (struct device_node *)data;\r\nstruct power_supply *epsy = dev_get_drvdata(dev);\r\nif (epsy->of_node == np)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int power_supply_find_supply_from_node(struct device_node *supply_node)\r\n{\r\nint error;\r\nstruct device *dev;\r\nstruct class_dev_iter iter;\r\nclass_dev_iter_init(&iter, power_supply_class, NULL, NULL);\r\ndev = class_dev_iter_next(&iter);\r\nif (!dev)\r\nreturn -EPROBE_DEFER;\r\nerror = class_for_each_device(power_supply_class, NULL, supply_node,\r\n__power_supply_find_supply_from_node);\r\nreturn error ? 0 : -EPROBE_DEFER;\r\n}\r\nstatic int power_supply_check_supplies(struct power_supply *psy)\r\n{\r\nstruct device_node *np;\r\nint cnt = 0;\r\nif (psy->supplied_from && psy->num_supplies > 0)\r\nreturn 0;\r\nif (!psy->of_node)\r\nreturn 0;\r\ndo {\r\nint ret;\r\nnp = of_parse_phandle(psy->of_node, "power-supplies", cnt++);\r\nif (!np)\r\ncontinue;\r\nret = power_supply_find_supply_from_node(np);\r\nif (ret) {\r\ndev_dbg(psy->dev, "Failed to find supply, defer!\n");\r\nof_node_put(np);\r\nreturn -EPROBE_DEFER;\r\n}\r\nof_node_put(np);\r\n} while (np);\r\npsy->supplied_from = devm_kzalloc(psy->dev, sizeof(psy->supplied_from),\r\nGFP_KERNEL);\r\nif (!psy->supplied_from) {\r\ndev_err(psy->dev, "Couldn't allocate memory for supply list\n");\r\nreturn -ENOMEM;\r\n}\r\n*psy->supplied_from = devm_kzalloc(psy->dev, sizeof(char *) * cnt,\r\nGFP_KERNEL);\r\nif (!*psy->supplied_from) {\r\ndev_err(psy->dev, "Couldn't allocate memory for supply list\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn power_supply_populate_supplied_from(psy);\r\n}\r\nstatic inline int power_supply_check_supplies(struct power_supply *psy)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __power_supply_am_i_supplied(struct device *dev, void *data)\r\n{\r\nunion power_supply_propval ret = {0,};\r\nstruct power_supply *psy = (struct power_supply *)data;\r\nstruct power_supply *epsy = dev_get_drvdata(dev);\r\nif (__power_supply_is_supplied_by(epsy, psy))\r\nif (!epsy->get_property(epsy, POWER_SUPPLY_PROP_ONLINE, &ret)) {\r\nif (ret.intval)\r\nreturn ret.intval;\r\n}\r\nreturn 0;\r\n}\r\nint power_supply_am_i_supplied(struct power_supply *psy)\r\n{\r\nint error;\r\nerror = class_for_each_device(power_supply_class, NULL, psy,\r\n__power_supply_am_i_supplied);\r\ndev_dbg(psy->dev, "%s %d\n", __func__, error);\r\nreturn error;\r\n}\r\nstatic int __power_supply_is_system_supplied(struct device *dev, void *data)\r\n{\r\nunion power_supply_propval ret = {0,};\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nunsigned int *count = data;\r\n(*count)++;\r\nif (psy->type != POWER_SUPPLY_TYPE_BATTERY) {\r\nif (psy->get_property(psy, POWER_SUPPLY_PROP_ONLINE, &ret))\r\nreturn 0;\r\nif (ret.intval)\r\nreturn ret.intval;\r\n}\r\nreturn 0;\r\n}\r\nint power_supply_is_system_supplied(void)\r\n{\r\nint error;\r\nunsigned int count = 0;\r\nerror = class_for_each_device(power_supply_class, NULL, &count,\r\n__power_supply_is_system_supplied);\r\nif (count == 0)\r\nreturn 1;\r\nreturn error;\r\n}\r\nint power_supply_set_battery_charged(struct power_supply *psy)\r\n{\r\nif (psy->type == POWER_SUPPLY_TYPE_BATTERY && psy->set_charged) {\r\npsy->set_charged(psy);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int power_supply_match_device_by_name(struct device *dev, const void *data)\r\n{\r\nconst char *name = data;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nreturn strcmp(psy->name, name) == 0;\r\n}\r\nstruct power_supply *power_supply_get_by_name(const char *name)\r\n{\r\nstruct device *dev = class_find_device(power_supply_class, NULL, name,\r\npower_supply_match_device_by_name);\r\nreturn dev ? dev_get_drvdata(dev) : NULL;\r\n}\r\nstatic int power_supply_match_device_node(struct device *dev, const void *data)\r\n{\r\nreturn dev->parent && dev->parent->of_node == data;\r\n}\r\nstruct power_supply *power_supply_get_by_phandle(struct device_node *np,\r\nconst char *property)\r\n{\r\nstruct device_node *power_supply_np;\r\nstruct device *dev;\r\npower_supply_np = of_parse_phandle(np, property, 0);\r\nif (!power_supply_np)\r\nreturn ERR_PTR(-ENODEV);\r\ndev = class_find_device(power_supply_class, NULL, power_supply_np,\r\npower_supply_match_device_node);\r\nof_node_put(power_supply_np);\r\nreturn dev ? dev_get_drvdata(dev) : NULL;\r\n}\r\nint power_supply_powers(struct power_supply *psy, struct device *dev)\r\n{\r\nreturn sysfs_create_link(&psy->dev->kobj, &dev->kobj, "powers");\r\n}\r\nstatic void power_supply_dev_release(struct device *dev)\r\n{\r\npr_debug("device: '%s': %s\n", dev_name(dev), __func__);\r\nkfree(dev);\r\n}\r\nint power_supply_reg_notifier(struct notifier_block *nb)\r\n{\r\nreturn atomic_notifier_chain_register(&power_supply_notifier, nb);\r\n}\r\nvoid power_supply_unreg_notifier(struct notifier_block *nb)\r\n{\r\natomic_notifier_chain_unregister(&power_supply_notifier, nb);\r\n}\r\nstatic int power_supply_read_temp(struct thermal_zone_device *tzd,\r\nunsigned long *temp)\r\n{\r\nstruct power_supply *psy;\r\nunion power_supply_propval val;\r\nint ret;\r\nWARN_ON(tzd == NULL);\r\npsy = tzd->devdata;\r\nret = psy->get_property(psy, POWER_SUPPLY_PROP_TEMP, &val);\r\nif (!ret)\r\n*temp = val.intval * 100;\r\nreturn ret;\r\n}\r\nstatic int psy_register_thermal(struct power_supply *psy)\r\n{\r\nint i;\r\nfor (i = 0; i < psy->num_properties; i++) {\r\nif (psy->properties[i] == POWER_SUPPLY_PROP_TEMP) {\r\npsy->tzd = thermal_zone_device_register(psy->name, 0, 0,\r\npsy, &psy_tzd_ops, NULL, 0, 0);\r\nif (IS_ERR(psy->tzd))\r\nreturn PTR_ERR(psy->tzd);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void psy_unregister_thermal(struct power_supply *psy)\r\n{\r\nif (IS_ERR_OR_NULL(psy->tzd))\r\nreturn;\r\nthermal_zone_device_unregister(psy->tzd);\r\n}\r\nstatic int ps_get_max_charge_cntl_limit(struct thermal_cooling_device *tcd,\r\nunsigned long *state)\r\n{\r\nstruct power_supply *psy;\r\nunion power_supply_propval val;\r\nint ret;\r\npsy = tcd->devdata;\r\nret = psy->get_property(psy,\r\nPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX, &val);\r\nif (!ret)\r\n*state = val.intval;\r\nreturn ret;\r\n}\r\nstatic int ps_get_cur_chrage_cntl_limit(struct thermal_cooling_device *tcd,\r\nunsigned long *state)\r\n{\r\nstruct power_supply *psy;\r\nunion power_supply_propval val;\r\nint ret;\r\npsy = tcd->devdata;\r\nret = psy->get_property(psy,\r\nPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT, &val);\r\nif (!ret)\r\n*state = val.intval;\r\nreturn ret;\r\n}\r\nstatic int ps_set_cur_charge_cntl_limit(struct thermal_cooling_device *tcd,\r\nunsigned long state)\r\n{\r\nstruct power_supply *psy;\r\nunion power_supply_propval val;\r\nint ret;\r\npsy = tcd->devdata;\r\nval.intval = state;\r\nret = psy->set_property(psy,\r\nPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT, &val);\r\nreturn ret;\r\n}\r\nstatic int psy_register_cooler(struct power_supply *psy)\r\n{\r\nint i;\r\nfor (i = 0; i < psy->num_properties; i++) {\r\nif (psy->properties[i] ==\r\nPOWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT) {\r\npsy->tcd = thermal_cooling_device_register(\r\n(char *)psy->name,\r\npsy, &psy_tcd_ops);\r\nif (IS_ERR(psy->tcd))\r\nreturn PTR_ERR(psy->tcd);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void psy_unregister_cooler(struct power_supply *psy)\r\n{\r\nif (IS_ERR_OR_NULL(psy->tcd))\r\nreturn;\r\nthermal_cooling_device_unregister(psy->tcd);\r\n}\r\nstatic int psy_register_thermal(struct power_supply *psy)\r\n{\r\nreturn 0;\r\n}\r\nstatic void psy_unregister_thermal(struct power_supply *psy)\r\n{\r\n}\r\nstatic int psy_register_cooler(struct power_supply *psy)\r\n{\r\nreturn 0;\r\n}\r\nstatic void psy_unregister_cooler(struct power_supply *psy)\r\n{\r\n}\r\nint power_supply_register(struct device *parent, struct power_supply *psy)\r\n{\r\nstruct device *dev;\r\nint rc;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndevice_initialize(dev);\r\ndev->class = power_supply_class;\r\ndev->type = &power_supply_dev_type;\r\ndev->parent = parent;\r\ndev->release = power_supply_dev_release;\r\ndev_set_drvdata(dev, psy);\r\npsy->dev = dev;\r\nrc = dev_set_name(dev, "%s", psy->name);\r\nif (rc)\r\ngoto dev_set_name_failed;\r\nINIT_WORK(&psy->changed_work, power_supply_changed_work);\r\nrc = power_supply_check_supplies(psy);\r\nif (rc) {\r\ndev_info(dev, "Not all required supplies found, defer probe\n");\r\ngoto check_supplies_failed;\r\n}\r\nspin_lock_init(&psy->changed_lock);\r\nrc = device_init_wakeup(dev, true);\r\nif (rc)\r\ngoto wakeup_init_failed;\r\nrc = device_add(dev);\r\nif (rc)\r\ngoto device_add_failed;\r\nrc = psy_register_thermal(psy);\r\nif (rc)\r\ngoto register_thermal_failed;\r\nrc = psy_register_cooler(psy);\r\nif (rc)\r\ngoto register_cooler_failed;\r\nrc = power_supply_create_triggers(psy);\r\nif (rc)\r\ngoto create_triggers_failed;\r\npower_supply_changed(psy);\r\ngoto success;\r\ncreate_triggers_failed:\r\npsy_unregister_cooler(psy);\r\nregister_cooler_failed:\r\npsy_unregister_thermal(psy);\r\nregister_thermal_failed:\r\ndevice_del(dev);\r\ndevice_add_failed:\r\nwakeup_init_failed:\r\ncheck_supplies_failed:\r\ndev_set_name_failed:\r\nput_device(dev);\r\nsuccess:\r\nreturn rc;\r\n}\r\nvoid power_supply_unregister(struct power_supply *psy)\r\n{\r\ncancel_work_sync(&psy->changed_work);\r\nsysfs_remove_link(&psy->dev->kobj, "powers");\r\npower_supply_remove_triggers(psy);\r\npsy_unregister_cooler(psy);\r\npsy_unregister_thermal(psy);\r\ndevice_init_wakeup(psy->dev, false);\r\ndevice_unregister(psy->dev);\r\n}\r\nstatic int __init power_supply_class_init(void)\r\n{\r\npower_supply_class = class_create(THIS_MODULE, "power_supply");\r\nif (IS_ERR(power_supply_class))\r\nreturn PTR_ERR(power_supply_class);\r\npower_supply_class->dev_uevent = power_supply_uevent;\r\npower_supply_init_attrs(&power_supply_dev_type);\r\nreturn 0;\r\n}\r\nstatic void __exit power_supply_class_exit(void)\r\n{\r\nclass_destroy(power_supply_class);\r\n}
