static u16\r\npll_limits_table(struct nouveau_bios *bios, u8 *ver, u8 *hdr, u8 *cnt, u8 *len)\r\n{\r\nstruct bit_entry bit_C;\r\nif (!bit_entry(bios, 'C', &bit_C) && bit_C.length >= 10) {\r\nu16 data = nv_ro16(bios, bit_C.offset + 8);\r\nif (data) {\r\n*ver = nv_ro08(bios, data + 0);\r\n*hdr = nv_ro08(bios, data + 1);\r\n*len = nv_ro08(bios, data + 2);\r\n*cnt = nv_ro08(bios, data + 3);\r\nreturn data;\r\n}\r\n}\r\nif (bmp_version(bios) >= 0x0524) {\r\nu16 data = nv_ro16(bios, bios->bmp_offset + 142);\r\nif (data) {\r\n*ver = nv_ro08(bios, data + 0);\r\n*hdr = 1;\r\n*cnt = 1;\r\n*len = 0x18;\r\nreturn data;\r\n}\r\n}\r\n*ver = 0x00;\r\nreturn 0x0000;\r\n}\r\nstatic struct pll_mapping *\r\npll_map(struct nouveau_bios *bios)\r\n{\r\nswitch (nv_device(bios)->card_type) {\r\ncase NV_04:\r\ncase NV_10:\r\ncase NV_11:\r\ncase NV_20:\r\ncase NV_30:\r\nreturn nv04_pll_mapping;\r\nbreak;\r\ncase NV_40:\r\nreturn nv40_pll_mapping;\r\ncase NV_50:\r\nif (nv_device(bios)->chipset == 0x50)\r\nreturn nv50_pll_mapping;\r\nelse\r\nif (nv_device(bios)->chipset < 0xa3 ||\r\nnv_device(bios)->chipset == 0xaa ||\r\nnv_device(bios)->chipset == 0xac)\r\nreturn nv84_pll_mapping;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic u16\r\npll_map_reg(struct nouveau_bios *bios, u32 reg, u32 *type, u8 *ver, u8 *len)\r\n{\r\nstruct pll_mapping *map;\r\nu8 hdr, cnt;\r\nu16 data;\r\ndata = pll_limits_table(bios, ver, &hdr, &cnt, len);\r\nif (data && *ver >= 0x30) {\r\ndata += hdr;\r\nwhile (cnt--) {\r\nif (nv_ro32(bios, data + 3) == reg) {\r\n*type = nv_ro08(bios, data + 0);\r\nreturn data;\r\n}\r\ndata += *len;\r\n}\r\nreturn 0x0000;\r\n}\r\nmap = pll_map(bios);\r\nwhile (map->reg) {\r\nif (map->reg == reg && *ver >= 0x20) {\r\nu16 addr = (data += hdr);\r\n*type = map->type;\r\nwhile (cnt--) {\r\nif (nv_ro32(bios, data) == map->reg)\r\nreturn data;\r\ndata += *len;\r\n}\r\nreturn addr;\r\n} else\r\nif (map->reg == reg) {\r\n*type = map->type;\r\nreturn data + 1;\r\n}\r\nmap++;\r\n}\r\nreturn 0x0000;\r\n}\r\nstatic u16\r\npll_map_type(struct nouveau_bios *bios, u8 type, u32 *reg, u8 *ver, u8 *len)\r\n{\r\nstruct pll_mapping *map;\r\nu8 hdr, cnt;\r\nu16 data;\r\ndata = pll_limits_table(bios, ver, &hdr, &cnt, len);\r\nif (data && *ver >= 0x30) {\r\ndata += hdr;\r\nwhile (cnt--) {\r\nif (nv_ro08(bios, data + 0) == type) {\r\n*reg = nv_ro32(bios, data + 3);\r\nreturn data;\r\n}\r\ndata += *len;\r\n}\r\nreturn 0x0000;\r\n}\r\nmap = pll_map(bios);\r\nwhile (map->reg) {\r\nif (map->type == type && *ver >= 0x20) {\r\nu16 addr = (data += hdr);\r\n*reg = map->reg;\r\nwhile (cnt--) {\r\nif (nv_ro32(bios, data) == map->reg)\r\nreturn data;\r\ndata += *len;\r\n}\r\nreturn addr;\r\n} else\r\nif (map->type == type) {\r\n*reg = map->reg;\r\nreturn data + 1;\r\n}\r\nmap++;\r\n}\r\nreturn 0x0000;\r\n}\r\nint\r\nnvbios_pll_parse(struct nouveau_bios *bios, u32 type, struct nvbios_pll *info)\r\n{\r\nu8 ver, len;\r\nu32 reg = type;\r\nu16 data;\r\nif (type > PLL_MAX) {\r\nreg = type;\r\ndata = pll_map_reg(bios, reg, &type, &ver, &len);\r\n} else {\r\ndata = pll_map_type(bios, type, &reg, &ver, &len);\r\n}\r\nif (ver && !data)\r\nreturn -ENOENT;\r\nmemset(info, 0, sizeof(*info));\r\ninfo->type = type;\r\ninfo->reg = reg;\r\nswitch (ver) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x10:\r\ncase 0x11:\r\ninfo->vco1.min_freq = nv_ro32(bios, data + 0);\r\ninfo->vco1.max_freq = nv_ro32(bios, data + 4);\r\ninfo->vco2.min_freq = nv_ro32(bios, data + 8);\r\ninfo->vco2.max_freq = nv_ro32(bios, data + 12);\r\ninfo->vco1.min_inputfreq = nv_ro32(bios, data + 16);\r\ninfo->vco2.min_inputfreq = nv_ro32(bios, data + 20);\r\ninfo->vco1.max_inputfreq = INT_MAX;\r\ninfo->vco2.max_inputfreq = INT_MAX;\r\ninfo->max_p = 0x7;\r\ninfo->max_p_usable = 0x6;\r\nswitch (bios->version.chip) {\r\ncase 0x36:\r\ninfo->vco1.min_n = 0x5;\r\nbreak;\r\ndefault:\r\ninfo->vco1.min_n = 0x1;\r\nbreak;\r\n}\r\ninfo->vco1.max_n = 0xff;\r\ninfo->vco1.min_m = 0x1;\r\ninfo->vco1.max_m = 0xd;\r\ninfo->vco2.min_n = 0x4;\r\nswitch (bios->version.chip) {\r\ncase 0x30:\r\ncase 0x35:\r\ninfo->vco2.max_n = 0x1f;\r\nbreak;\r\ndefault:\r\ninfo->vco2.max_n = 0x28;\r\nbreak;\r\n}\r\ninfo->vco2.min_m = 0x1;\r\ninfo->vco2.max_m = 0x4;\r\nbreak;\r\ncase 0x20:\r\ncase 0x21:\r\ninfo->vco1.min_freq = nv_ro16(bios, data + 4) * 1000;\r\ninfo->vco1.max_freq = nv_ro16(bios, data + 6) * 1000;\r\ninfo->vco2.min_freq = nv_ro16(bios, data + 8) * 1000;\r\ninfo->vco2.max_freq = nv_ro16(bios, data + 10) * 1000;\r\ninfo->vco1.min_inputfreq = nv_ro16(bios, data + 12) * 1000;\r\ninfo->vco2.min_inputfreq = nv_ro16(bios, data + 14) * 1000;\r\ninfo->vco1.max_inputfreq = nv_ro16(bios, data + 16) * 1000;\r\ninfo->vco2.max_inputfreq = nv_ro16(bios, data + 18) * 1000;\r\ninfo->vco1.min_n = nv_ro08(bios, data + 20);\r\ninfo->vco1.max_n = nv_ro08(bios, data + 21);\r\ninfo->vco1.min_m = nv_ro08(bios, data + 22);\r\ninfo->vco1.max_m = nv_ro08(bios, data + 23);\r\ninfo->vco2.min_n = nv_ro08(bios, data + 24);\r\ninfo->vco2.max_n = nv_ro08(bios, data + 25);\r\ninfo->vco2.min_m = nv_ro08(bios, data + 26);\r\ninfo->vco2.max_m = nv_ro08(bios, data + 27);\r\ninfo->max_p = nv_ro08(bios, data + 29);\r\ninfo->max_p_usable = info->max_p;\r\nif (bios->version.chip < 0x60)\r\ninfo->max_p_usable = 0x6;\r\ninfo->bias_p = nv_ro08(bios, data + 30);\r\nif (len > 0x22)\r\ninfo->refclk = nv_ro32(bios, data + 31);\r\nbreak;\r\ncase 0x30:\r\ndata = nv_ro16(bios, data + 1);\r\ninfo->vco1.min_freq = nv_ro16(bios, data + 0) * 1000;\r\ninfo->vco1.max_freq = nv_ro16(bios, data + 2) * 1000;\r\ninfo->vco2.min_freq = nv_ro16(bios, data + 4) * 1000;\r\ninfo->vco2.max_freq = nv_ro16(bios, data + 6) * 1000;\r\ninfo->vco1.min_inputfreq = nv_ro16(bios, data + 8) * 1000;\r\ninfo->vco2.min_inputfreq = nv_ro16(bios, data + 10) * 1000;\r\ninfo->vco1.max_inputfreq = nv_ro16(bios, data + 12) * 1000;\r\ninfo->vco2.max_inputfreq = nv_ro16(bios, data + 14) * 1000;\r\ninfo->vco1.min_n = nv_ro08(bios, data + 16);\r\ninfo->vco1.max_n = nv_ro08(bios, data + 17);\r\ninfo->vco1.min_m = nv_ro08(bios, data + 18);\r\ninfo->vco1.max_m = nv_ro08(bios, data + 19);\r\ninfo->vco2.min_n = nv_ro08(bios, data + 20);\r\ninfo->vco2.max_n = nv_ro08(bios, data + 21);\r\ninfo->vco2.min_m = nv_ro08(bios, data + 22);\r\ninfo->vco2.max_m = nv_ro08(bios, data + 23);\r\ninfo->max_p_usable = info->max_p = nv_ro08(bios, data + 25);\r\ninfo->bias_p = nv_ro08(bios, data + 27);\r\ninfo->refclk = nv_ro32(bios, data + 28);\r\nbreak;\r\ncase 0x40:\r\ninfo->refclk = nv_ro16(bios, data + 9) * 1000;\r\ndata = nv_ro16(bios, data + 1);\r\ninfo->vco1.min_freq = nv_ro16(bios, data + 0) * 1000;\r\ninfo->vco1.max_freq = nv_ro16(bios, data + 2) * 1000;\r\ninfo->vco1.min_inputfreq = nv_ro16(bios, data + 4) * 1000;\r\ninfo->vco1.max_inputfreq = nv_ro16(bios, data + 6) * 1000;\r\ninfo->vco1.min_m = nv_ro08(bios, data + 8);\r\ninfo->vco1.max_m = nv_ro08(bios, data + 9);\r\ninfo->vco1.min_n = nv_ro08(bios, data + 10);\r\ninfo->vco1.max_n = nv_ro08(bios, data + 11);\r\ninfo->min_p = nv_ro08(bios, data + 12);\r\ninfo->max_p = nv_ro08(bios, data + 13);\r\nbreak;\r\ndefault:\r\nnv_error(bios, "unknown pll limits version 0x%02x\n", ver);\r\nreturn -EINVAL;\r\n}\r\nif (!info->refclk) {\r\ninfo->refclk = nv_device(bios)->crystal;\r\nif (bios->version.chip == 0x51) {\r\nu32 sel_clk = nv_rd32(bios, 0x680524);\r\nif ((info->reg == 0x680508 && sel_clk & 0x20) ||\r\n(info->reg == 0x680520 && sel_clk & 0x80)) {\r\nif (nv_rdvgac(bios, 0, 0x27) < 0xa3)\r\ninfo->refclk = 200000;\r\nelse\r\ninfo->refclk = 25000;\r\n}\r\n}\r\n}\r\nif (!info->vco1.max_freq) {\r\ninfo->vco1.max_freq = nv_ro32(bios, bios->bmp_offset + 67);\r\ninfo->vco1.min_freq = nv_ro32(bios, bios->bmp_offset + 71);\r\nif (bmp_version(bios) < 0x0506) {\r\ninfo->vco1.max_freq = 256000;\r\ninfo->vco1.min_freq = 128000;\r\n}\r\ninfo->vco1.min_inputfreq = 0;\r\ninfo->vco1.max_inputfreq = INT_MAX;\r\ninfo->vco1.min_n = 0x1;\r\ninfo->vco1.max_n = 0xff;\r\ninfo->vco1.min_m = 0x1;\r\nif (nv_device(bios)->crystal == 13500) {\r\nif (bios->version.chip < 0x11)\r\ninfo->vco1.min_m = 0x7;\r\ninfo->vco1.max_m = 0xd;\r\n} else {\r\nif (bios->version.chip < 0x11)\r\ninfo->vco1.min_m = 0x8;\r\ninfo->vco1.max_m = 0xe;\r\n}\r\nif (bios->version.chip < 0x17 ||\r\nbios->version.chip == 0x1a ||\r\nbios->version.chip == 0x20)\r\ninfo->max_p = 4;\r\nelse\r\ninfo->max_p = 5;\r\ninfo->max_p_usable = info->max_p;\r\n}\r\nreturn 0;\r\n}
