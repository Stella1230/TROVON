const struct gsc_fmt *get_format(int index)\r\n{\r\nif (index >= ARRAY_SIZE(gsc_formats))\r\nreturn NULL;\r\nreturn (struct gsc_fmt *)&gsc_formats[index];\r\n}\r\nconst struct gsc_fmt *find_fmt(u32 *pixelformat, u32 *mbus_code, u32 index)\r\n{\r\nconst struct gsc_fmt *fmt, *def_fmt = NULL;\r\nunsigned int i;\r\nif (index >= ARRAY_SIZE(gsc_formats))\r\nreturn NULL;\r\nfor (i = 0; i < ARRAY_SIZE(gsc_formats); ++i) {\r\nfmt = get_format(i);\r\nif (pixelformat && fmt->pixelformat == *pixelformat)\r\nreturn fmt;\r\nif (mbus_code && fmt->mbus_code == *mbus_code)\r\nreturn fmt;\r\nif (index == i)\r\ndef_fmt = fmt;\r\n}\r\nreturn def_fmt;\r\n}\r\nvoid gsc_set_frame_size(struct gsc_frame *frame, int width, int height)\r\n{\r\nframe->f_width = width;\r\nframe->f_height = height;\r\nframe->crop.width = width;\r\nframe->crop.height = height;\r\nframe->crop.left = 0;\r\nframe->crop.top = 0;\r\n}\r\nint gsc_cal_prescaler_ratio(struct gsc_variant *var, u32 src, u32 dst,\r\nu32 *ratio)\r\n{\r\nif ((dst > src) || (dst >= src / var->poly_sc_down_max)) {\r\n*ratio = 1;\r\nreturn 0;\r\n}\r\nif ((src / var->poly_sc_down_max / var->pre_sc_down_max) > dst) {\r\npr_err("Exceeded maximum downscaling ratio (1/16))");\r\nreturn -EINVAL;\r\n}\r\n*ratio = (dst > (src / 8)) ? 2 : 4;\r\nreturn 0;\r\n}\r\nvoid gsc_get_prescaler_shfactor(u32 hratio, u32 vratio, u32 *sh)\r\n{\r\nif (hratio == 4 && vratio == 4)\r\n*sh = 4;\r\nelse if ((hratio == 4 && vratio == 2) ||\r\n(hratio == 2 && vratio == 4))\r\n*sh = 3;\r\nelse if ((hratio == 4 && vratio == 1) ||\r\n(hratio == 1 && vratio == 4) ||\r\n(hratio == 2 && vratio == 2))\r\n*sh = 2;\r\nelse if (hratio == 1 && vratio == 1)\r\n*sh = 0;\r\nelse\r\n*sh = 1;\r\n}\r\nvoid gsc_check_src_scale_info(struct gsc_variant *var,\r\nstruct gsc_frame *s_frame, u32 *wratio,\r\nu32 tx, u32 ty, u32 *hratio)\r\n{\r\nint remainder = 0, walign, halign;\r\nif (is_yuv420(s_frame->fmt->color)) {\r\nwalign = GSC_SC_ALIGN_4;\r\nhalign = GSC_SC_ALIGN_4;\r\n} else if (is_yuv422(s_frame->fmt->color)) {\r\nwalign = GSC_SC_ALIGN_4;\r\nhalign = GSC_SC_ALIGN_2;\r\n} else {\r\nwalign = GSC_SC_ALIGN_2;\r\nhalign = GSC_SC_ALIGN_2;\r\n}\r\nremainder = s_frame->crop.width % (*wratio * walign);\r\nif (remainder) {\r\ns_frame->crop.width -= remainder;\r\ngsc_cal_prescaler_ratio(var, s_frame->crop.width, tx, wratio);\r\npr_info("cropped src width size is recalculated from %d to %d",\r\ns_frame->crop.width + remainder, s_frame->crop.width);\r\n}\r\nremainder = s_frame->crop.height % (*hratio * halign);\r\nif (remainder) {\r\ns_frame->crop.height -= remainder;\r\ngsc_cal_prescaler_ratio(var, s_frame->crop.height, ty, hratio);\r\npr_info("cropped src height size is recalculated from %d to %d",\r\ns_frame->crop.height + remainder, s_frame->crop.height);\r\n}\r\n}\r\nint gsc_enum_fmt_mplane(struct v4l2_fmtdesc *f)\r\n{\r\nconst struct gsc_fmt *fmt;\r\nfmt = find_fmt(NULL, NULL, f->index);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, fmt->name, sizeof(f->description));\r\nf->pixelformat = fmt->pixelformat;\r\nreturn 0;\r\n}\r\nstatic u32 get_plane_info(struct gsc_frame *frm, u32 addr, u32 *index)\r\n{\r\nif (frm->addr.y == addr) {\r\n*index = 0;\r\nreturn frm->addr.y;\r\n} else if (frm->addr.cb == addr) {\r\n*index = 1;\r\nreturn frm->addr.cb;\r\n} else if (frm->addr.cr == addr) {\r\n*index = 2;\r\nreturn frm->addr.cr;\r\n} else {\r\npr_err("Plane address is wrong");\r\nreturn -EINVAL;\r\n}\r\n}\r\nvoid gsc_set_prefbuf(struct gsc_dev *gsc, struct gsc_frame *frm)\r\n{\r\nu32 f_chk_addr, f_chk_len, s_chk_addr, s_chk_len;\r\nf_chk_addr = f_chk_len = s_chk_addr = s_chk_len = 0;\r\nf_chk_addr = frm->addr.y;\r\nf_chk_len = frm->payload[0];\r\nif (frm->fmt->num_planes == 2) {\r\ns_chk_addr = frm->addr.cb;\r\ns_chk_len = frm->payload[1];\r\n} else if (frm->fmt->num_planes == 3) {\r\nu32 low_addr, low_plane, mid_addr, mid_plane;\r\nu32 high_addr, high_plane;\r\nu32 t_min, t_max;\r\nt_min = min3(frm->addr.y, frm->addr.cb, frm->addr.cr);\r\nlow_addr = get_plane_info(frm, t_min, &low_plane);\r\nt_max = max3(frm->addr.y, frm->addr.cb, frm->addr.cr);\r\nhigh_addr = get_plane_info(frm, t_max, &high_plane);\r\nmid_plane = 3 - (low_plane + high_plane);\r\nif (mid_plane == 0)\r\nmid_addr = frm->addr.y;\r\nelse if (mid_plane == 1)\r\nmid_addr = frm->addr.cb;\r\nelse if (mid_plane == 2)\r\nmid_addr = frm->addr.cr;\r\nelse\r\nreturn;\r\nf_chk_addr = low_addr;\r\nif (mid_addr + frm->payload[mid_plane] - low_addr >\r\nhigh_addr + frm->payload[high_plane] - mid_addr) {\r\nf_chk_len = frm->payload[low_plane];\r\ns_chk_addr = mid_addr;\r\ns_chk_len = high_addr +\r\nfrm->payload[high_plane] - mid_addr;\r\n} else {\r\nf_chk_len = mid_addr +\r\nfrm->payload[mid_plane] - low_addr;\r\ns_chk_addr = high_addr;\r\ns_chk_len = frm->payload[high_plane];\r\n}\r\n}\r\npr_debug("f_addr = 0x%08x, f_len = %d, s_addr = 0x%08x, s_len = %d\n",\r\nf_chk_addr, f_chk_len, s_chk_addr, s_chk_len);\r\n}\r\nint gsc_try_fmt_mplane(struct gsc_ctx *ctx, struct v4l2_format *f)\r\n{\r\nstruct gsc_dev *gsc = ctx->gsc_dev;\r\nstruct gsc_variant *variant = gsc->variant;\r\nstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\r\nconst struct gsc_fmt *fmt;\r\nu32 max_w, max_h, mod_x, mod_y;\r\nu32 min_w, min_h, tmp_w, tmp_h;\r\nint i;\r\npr_debug("user put w: %d, h: %d", pix_mp->width, pix_mp->height);\r\nfmt = find_fmt(&pix_mp->pixelformat, NULL, 0);\r\nif (!fmt) {\r\npr_err("pixelformat format (0x%X) invalid\n",\r\npix_mp->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nif (pix_mp->field == V4L2_FIELD_ANY)\r\npix_mp->field = V4L2_FIELD_NONE;\r\nelse if (pix_mp->field != V4L2_FIELD_NONE) {\r\npr_err("Not supported field order(%d)\n", pix_mp->field);\r\nreturn -EINVAL;\r\n}\r\nmax_w = variant->pix_max->target_rot_dis_w;\r\nmax_h = variant->pix_max->target_rot_dis_h;\r\nmod_x = ffs(variant->pix_align->org_w) - 1;\r\nif (is_yuv420(fmt->color))\r\nmod_y = ffs(variant->pix_align->org_h) - 1;\r\nelse\r\nmod_y = ffs(variant->pix_align->org_h) - 2;\r\nif (V4L2_TYPE_IS_OUTPUT(f->type)) {\r\nmin_w = variant->pix_min->org_w;\r\nmin_h = variant->pix_min->org_h;\r\n} else {\r\nmin_w = variant->pix_min->target_rot_dis_w;\r\nmin_h = variant->pix_min->target_rot_dis_h;\r\n}\r\npr_debug("mod_x: %d, mod_y: %d, max_w: %d, max_h = %d",\r\nmod_x, mod_y, max_w, max_h);\r\ntmp_w = pix_mp->width;\r\ntmp_h = pix_mp->height;\r\nv4l_bound_align_image(&pix_mp->width, min_w, max_w, mod_x,\r\n&pix_mp->height, min_h, max_h, mod_y, 0);\r\nif (tmp_w != pix_mp->width || tmp_h != pix_mp->height)\r\npr_info("Image size has been modified from %dx%d to %dx%d",\r\ntmp_w, tmp_h, pix_mp->width, pix_mp->height);\r\npix_mp->num_planes = fmt->num_planes;\r\nif (pix_mp->width >= 1280)\r\npix_mp->colorspace = V4L2_COLORSPACE_REC709;\r\nelse\r\npix_mp->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nfor (i = 0; i < pix_mp->num_planes; ++i) {\r\nint bpl = (pix_mp->width * fmt->depth[i]) >> 3;\r\npix_mp->plane_fmt[i].bytesperline = bpl;\r\npix_mp->plane_fmt[i].sizeimage = bpl * pix_mp->height;\r\npr_debug("[%d]: bpl: %d, sizeimage: %d",\r\ni, bpl, pix_mp->plane_fmt[i].sizeimage);\r\n}\r\nreturn 0;\r\n}\r\nint gsc_g_fmt_mplane(struct gsc_ctx *ctx, struct v4l2_format *f)\r\n{\r\nstruct gsc_frame *frame;\r\nstruct v4l2_pix_format_mplane *pix_mp;\r\nint i;\r\nframe = ctx_get_frame(ctx, f->type);\r\nif (IS_ERR(frame))\r\nreturn PTR_ERR(frame);\r\npix_mp = &f->fmt.pix_mp;\r\npix_mp->width = frame->f_width;\r\npix_mp->height = frame->f_height;\r\npix_mp->field = V4L2_FIELD_NONE;\r\npix_mp->pixelformat = frame->fmt->pixelformat;\r\npix_mp->colorspace = V4L2_COLORSPACE_REC709;\r\npix_mp->num_planes = frame->fmt->num_planes;\r\nfor (i = 0; i < pix_mp->num_planes; ++i) {\r\npix_mp->plane_fmt[i].bytesperline = (frame->f_width *\r\nframe->fmt->depth[i]) / 8;\r\npix_mp->plane_fmt[i].sizeimage =\r\npix_mp->plane_fmt[i].bytesperline * frame->f_height;\r\n}\r\nreturn 0;\r\n}\r\nvoid gsc_check_crop_change(u32 tmp_w, u32 tmp_h, u32 *w, u32 *h)\r\n{\r\nif (tmp_w != *w || tmp_h != *h) {\r\npr_info("Cropped size has been modified from %dx%d to %dx%d",\r\n*w, *h, tmp_w, tmp_h);\r\n*w = tmp_w;\r\n*h = tmp_h;\r\n}\r\n}\r\nint gsc_g_crop(struct gsc_ctx *ctx, struct v4l2_crop *cr)\r\n{\r\nstruct gsc_frame *frame;\r\nframe = ctx_get_frame(ctx, cr->type);\r\nif (IS_ERR(frame))\r\nreturn PTR_ERR(frame);\r\ncr->c = frame->crop;\r\nreturn 0;\r\n}\r\nint gsc_try_crop(struct gsc_ctx *ctx, struct v4l2_crop *cr)\r\n{\r\nstruct gsc_frame *f;\r\nstruct gsc_dev *gsc = ctx->gsc_dev;\r\nstruct gsc_variant *variant = gsc->variant;\r\nu32 mod_x = 0, mod_y = 0, tmp_w, tmp_h;\r\nu32 min_w, min_h, max_w, max_h;\r\nif (cr->c.top < 0 || cr->c.left < 0) {\r\npr_err("doesn't support negative values for top & left\n");\r\nreturn -EINVAL;\r\n}\r\npr_debug("user put w: %d, h: %d", cr->c.width, cr->c.height);\r\nif (cr->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nf = &ctx->d_frame;\r\nelse if (cr->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nf = &ctx->s_frame;\r\nelse\r\nreturn -EINVAL;\r\nmax_w = f->f_width;\r\nmax_h = f->f_height;\r\ntmp_w = cr->c.width;\r\ntmp_h = cr->c.height;\r\nif (V4L2_TYPE_IS_OUTPUT(cr->type)) {\r\nif ((is_yuv422(f->fmt->color) && f->fmt->num_comp == 1) ||\r\nis_rgb(f->fmt->color))\r\nmin_w = 32;\r\nelse\r\nmin_w = 64;\r\nif ((is_yuv422(f->fmt->color) && f->fmt->num_comp == 3) ||\r\nis_yuv420(f->fmt->color))\r\nmin_h = 32;\r\nelse\r\nmin_h = 16;\r\n} else {\r\nif (is_yuv420(f->fmt->color) || is_yuv422(f->fmt->color))\r\nmod_x = ffs(variant->pix_align->target_w) - 1;\r\nif (is_yuv420(f->fmt->color))\r\nmod_y = ffs(variant->pix_align->target_h) - 1;\r\nif (ctx->gsc_ctrls.rotate->val == 90 ||\r\nctx->gsc_ctrls.rotate->val == 270) {\r\nmax_w = f->f_height;\r\nmax_h = f->f_width;\r\nmin_w = variant->pix_min->target_rot_en_w;\r\nmin_h = variant->pix_min->target_rot_en_h;\r\ntmp_w = cr->c.height;\r\ntmp_h = cr->c.width;\r\n} else {\r\nmin_w = variant->pix_min->target_rot_dis_w;\r\nmin_h = variant->pix_min->target_rot_dis_h;\r\n}\r\n}\r\npr_debug("mod_x: %d, mod_y: %d, min_w: %d, min_h = %d",\r\nmod_x, mod_y, min_w, min_h);\r\npr_debug("tmp_w : %d, tmp_h : %d", tmp_w, tmp_h);\r\nv4l_bound_align_image(&tmp_w, min_w, max_w, mod_x,\r\n&tmp_h, min_h, max_h, mod_y, 0);\r\nif (!V4L2_TYPE_IS_OUTPUT(cr->type) &&\r\n(ctx->gsc_ctrls.rotate->val == 90 ||\r\nctx->gsc_ctrls.rotate->val == 270))\r\ngsc_check_crop_change(tmp_h, tmp_w,\r\n&cr->c.width, &cr->c.height);\r\nelse\r\ngsc_check_crop_change(tmp_w, tmp_h,\r\n&cr->c.width, &cr->c.height);\r\nif (cr->c.left + tmp_w > max_w)\r\ncr->c.left = max_w - tmp_w;\r\nif (cr->c.top + tmp_h > max_h)\r\ncr->c.top = max_h - tmp_h;\r\nif ((is_yuv420(f->fmt->color) || is_yuv422(f->fmt->color)) &&\r\ncr->c.left & 1)\r\ncr->c.left -= 1;\r\npr_debug("Aligned l:%d, t:%d, w:%d, h:%d, f_w: %d, f_h: %d",\r\ncr->c.left, cr->c.top, cr->c.width, cr->c.height, max_w, max_h);\r\nreturn 0;\r\n}\r\nint gsc_check_scaler_ratio(struct gsc_variant *var, int sw, int sh, int dw,\r\nint dh, int rot, int out_path)\r\n{\r\nint tmp_w, tmp_h, sc_down_max;\r\nif (out_path == GSC_DMA)\r\nsc_down_max = var->sc_down_max;\r\nelse\r\nsc_down_max = var->local_sc_down;\r\nif (rot == 90 || rot == 270) {\r\ntmp_w = dh;\r\ntmp_h = dw;\r\n} else {\r\ntmp_w = dw;\r\ntmp_h = dh;\r\n}\r\nif ((sw / tmp_w) > sc_down_max ||\r\n(sh / tmp_h) > sc_down_max ||\r\n(tmp_w / sw) > var->sc_up_max ||\r\n(tmp_h / sh) > var->sc_up_max)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint gsc_set_scaler_info(struct gsc_ctx *ctx)\r\n{\r\nstruct gsc_scaler *sc = &ctx->scaler;\r\nstruct gsc_frame *s_frame = &ctx->s_frame;\r\nstruct gsc_frame *d_frame = &ctx->d_frame;\r\nstruct gsc_variant *variant = ctx->gsc_dev->variant;\r\nstruct device *dev = &ctx->gsc_dev->pdev->dev;\r\nint tx, ty;\r\nint ret;\r\nret = gsc_check_scaler_ratio(variant, s_frame->crop.width,\r\ns_frame->crop.height, d_frame->crop.width, d_frame->crop.height,\r\nctx->gsc_ctrls.rotate->val, ctx->out_path);\r\nif (ret) {\r\npr_err("out of scaler range");\r\nreturn ret;\r\n}\r\nif (ctx->gsc_ctrls.rotate->val == 90 ||\r\nctx->gsc_ctrls.rotate->val == 270) {\r\nty = d_frame->crop.width;\r\ntx = d_frame->crop.height;\r\n} else {\r\ntx = d_frame->crop.width;\r\nty = d_frame->crop.height;\r\n}\r\nif (tx <= 0 || ty <= 0) {\r\ndev_err(dev, "Invalid target size: %dx%d", tx, ty);\r\nreturn -EINVAL;\r\n}\r\nret = gsc_cal_prescaler_ratio(variant, s_frame->crop.width,\r\ntx, &sc->pre_hratio);\r\nif (ret) {\r\npr_err("Horizontal scale ratio is out of range");\r\nreturn ret;\r\n}\r\nret = gsc_cal_prescaler_ratio(variant, s_frame->crop.height,\r\nty, &sc->pre_vratio);\r\nif (ret) {\r\npr_err("Vertical scale ratio is out of range");\r\nreturn ret;\r\n}\r\ngsc_check_src_scale_info(variant, s_frame, &sc->pre_hratio,\r\ntx, ty, &sc->pre_vratio);\r\ngsc_get_prescaler_shfactor(sc->pre_hratio, sc->pre_vratio,\r\n&sc->pre_shfactor);\r\nsc->main_hratio = (s_frame->crop.width << 16) / tx;\r\nsc->main_vratio = (s_frame->crop.height << 16) / ty;\r\npr_debug("scaler input/output size : sx = %d, sy = %d, tx = %d, ty = %d",\r\ns_frame->crop.width, s_frame->crop.height, tx, ty);\r\npr_debug("scaler ratio info : pre_shfactor : %d, pre_h : %d",\r\nsc->pre_shfactor, sc->pre_hratio);\r\npr_debug("pre_v :%d, main_h : %d, main_v : %d",\r\nsc->pre_vratio, sc->main_hratio, sc->main_vratio);\r\nreturn 0;\r\n}\r\nstatic int __gsc_s_ctrl(struct gsc_ctx *ctx, struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gsc_dev *gsc = ctx->gsc_dev;\r\nstruct gsc_variant *variant = gsc->variant;\r\nunsigned int flags = GSC_DST_FMT | GSC_SRC_FMT;\r\nint ret = 0;\r\nif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_HFLIP:\r\nctx->hflip = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nctx->vflip = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_ROTATE:\r\nif ((ctx->state & flags) == flags) {\r\nret = gsc_check_scaler_ratio(variant,\r\nctx->s_frame.crop.width,\r\nctx->s_frame.crop.height,\r\nctx->d_frame.crop.width,\r\nctx->d_frame.crop.height,\r\nctx->gsc_ctrls.rotate->val,\r\nctx->out_path);\r\nif (ret)\r\nreturn -EINVAL;\r\n}\r\nctx->rotation = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_ALPHA_COMPONENT:\r\nctx->d_frame.alpha = ctrl->val;\r\nbreak;\r\n}\r\nctx->state |= GSC_PARAMS;\r\nreturn 0;\r\n}\r\nstatic int gsc_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gsc_ctx *ctx = ctrl_to_ctx(ctrl);\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&ctx->gsc_dev->slock, flags);\r\nret = __gsc_s_ctrl(ctx, ctrl);\r\nspin_unlock_irqrestore(&ctx->gsc_dev->slock, flags);\r\nreturn ret;\r\n}\r\nint gsc_ctrls_create(struct gsc_ctx *ctx)\r\n{\r\nif (ctx->ctrls_rdy) {\r\npr_err("Control handler of this context was created already");\r\nreturn 0;\r\n}\r\nv4l2_ctrl_handler_init(&ctx->ctrl_handler, GSC_MAX_CTRL_NUM);\r\nctx->gsc_ctrls.rotate = v4l2_ctrl_new_std(&ctx->ctrl_handler,\r\n&gsc_ctrl_ops, V4L2_CID_ROTATE, 0, 270, 90, 0);\r\nctx->gsc_ctrls.hflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\r\n&gsc_ctrl_ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\r\nctx->gsc_ctrls.vflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\r\n&gsc_ctrl_ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\r\nctx->gsc_ctrls.global_alpha = v4l2_ctrl_new_std(&ctx->ctrl_handler,\r\n&gsc_ctrl_ops, V4L2_CID_ALPHA_COMPONENT, 0, 255, 1, 0);\r\nctx->ctrls_rdy = ctx->ctrl_handler.error == 0;\r\nif (ctx->ctrl_handler.error) {\r\nint err = ctx->ctrl_handler.error;\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\npr_err("Failed to create G-Scaler control handlers");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nvoid gsc_ctrls_delete(struct gsc_ctx *ctx)\r\n{\r\nif (ctx->ctrls_rdy) {\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nctx->ctrls_rdy = false;\r\n}\r\n}\r\nint gsc_prepare_addr(struct gsc_ctx *ctx, struct vb2_buffer *vb,\r\nstruct gsc_frame *frame, struct gsc_addr *addr)\r\n{\r\nint ret = 0;\r\nu32 pix_size;\r\nif ((vb == NULL) || (frame == NULL))\r\nreturn -EINVAL;\r\npix_size = frame->f_width * frame->f_height;\r\npr_debug("num_planes= %d, num_comp= %d, pix_size= %d",\r\nframe->fmt->num_planes, frame->fmt->num_comp, pix_size);\r\naddr->y = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nif (frame->fmt->num_planes == 1) {\r\nswitch (frame->fmt->num_comp) {\r\ncase 1:\r\naddr->cb = 0;\r\naddr->cr = 0;\r\nbreak;\r\ncase 2:\r\naddr->cb = (dma_addr_t)(addr->y + pix_size);\r\naddr->cr = 0;\r\nbreak;\r\ncase 3:\r\naddr->cb = (dma_addr_t)(addr->y + pix_size);\r\nif (GSC_YUV420 == frame->fmt->color)\r\naddr->cr = (dma_addr_t)(addr->cb\r\n+ (pix_size >> 2));\r\nelse\r\naddr->cr = (dma_addr_t)(addr->cb\r\n+ (pix_size >> 1));\r\nbreak;\r\ndefault:\r\npr_err("Invalid the number of color planes");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (frame->fmt->num_planes >= 2)\r\naddr->cb = vb2_dma_contig_plane_dma_addr(vb, 1);\r\nif (frame->fmt->num_planes == 3)\r\naddr->cr = vb2_dma_contig_plane_dma_addr(vb, 2);\r\n}\r\nif ((frame->fmt->pixelformat == V4L2_PIX_FMT_VYUY) ||\r\n(frame->fmt->pixelformat == V4L2_PIX_FMT_YVYU) ||\r\n(frame->fmt->pixelformat == V4L2_PIX_FMT_NV61) ||\r\n(frame->fmt->pixelformat == V4L2_PIX_FMT_YVU420) ||\r\n(frame->fmt->pixelformat == V4L2_PIX_FMT_NV21) ||\r\n(frame->fmt->pixelformat == V4L2_PIX_FMT_YVU420M))\r\nswap(addr->cb, addr->cr);\r\npr_debug("ADDR: y= 0x%X cb= 0x%X cr= 0x%X ret= %d",\r\naddr->y, addr->cb, addr->cr, ret);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t gsc_irq_handler(int irq, void *priv)\r\n{\r\nstruct gsc_dev *gsc = priv;\r\nstruct gsc_ctx *ctx;\r\nint gsc_irq;\r\ngsc_irq = gsc_hw_get_irq_status(gsc);\r\ngsc_hw_clear_irq(gsc, gsc_irq);\r\nif (gsc_irq == GSC_IRQ_OVERRUN) {\r\npr_err("Local path input over-run interrupt has occurred!\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nspin_lock(&gsc->slock);\r\nif (test_and_clear_bit(ST_M2M_PEND, &gsc->state)) {\r\ngsc_hw_enable_control(gsc, false);\r\nif (test_and_clear_bit(ST_M2M_SUSPENDING, &gsc->state)) {\r\nset_bit(ST_M2M_SUSPENDED, &gsc->state);\r\nwake_up(&gsc->irq_queue);\r\ngoto isr_unlock;\r\n}\r\nctx = v4l2_m2m_get_curr_priv(gsc->m2m.m2m_dev);\r\nif (!ctx || !ctx->m2m_ctx)\r\ngoto isr_unlock;\r\nspin_unlock(&gsc->slock);\r\ngsc_m2m_job_finish(ctx, VB2_BUF_STATE_DONE);\r\nif (ctx->state & GSC_CTX_STOP_REQ) {\r\nctx->state &= ~GSC_CTX_STOP_REQ;\r\nwake_up(&gsc->irq_queue);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nisr_unlock:\r\nspin_unlock(&gsc->slock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void *gsc_get_drv_data(struct platform_device *pdev)\r\n{\r\nstruct gsc_driverdata *driver_data = NULL;\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(exynos_gsc_match,\r\npdev->dev.of_node);\r\nif (match)\r\ndriver_data = (struct gsc_driverdata *)match->data;\r\n} else {\r\ndriver_data = (struct gsc_driverdata *)\r\nplatform_get_device_id(pdev)->driver_data;\r\n}\r\nreturn driver_data;\r\n}\r\nstatic void gsc_clk_put(struct gsc_dev *gsc)\r\n{\r\nif (!IS_ERR(gsc->clock))\r\nclk_unprepare(gsc->clock);\r\n}\r\nstatic int gsc_clk_get(struct gsc_dev *gsc)\r\n{\r\nint ret;\r\ndev_dbg(&gsc->pdev->dev, "gsc_clk_get Called\n");\r\ngsc->clock = devm_clk_get(&gsc->pdev->dev, GSC_CLOCK_GATE_NAME);\r\nif (IS_ERR(gsc->clock)) {\r\ndev_err(&gsc->pdev->dev, "failed to get clock~~~: %s\n",\r\nGSC_CLOCK_GATE_NAME);\r\nreturn PTR_ERR(gsc->clock);\r\n}\r\nret = clk_prepare(gsc->clock);\r\nif (ret < 0) {\r\ndev_err(&gsc->pdev->dev, "clock prepare failed for clock: %s\n",\r\nGSC_CLOCK_GATE_NAME);\r\ngsc->clock = ERR_PTR(-EINVAL);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gsc_m2m_suspend(struct gsc_dev *gsc)\r\n{\r\nunsigned long flags;\r\nint timeout;\r\nspin_lock_irqsave(&gsc->slock, flags);\r\nif (!gsc_m2m_pending(gsc)) {\r\nspin_unlock_irqrestore(&gsc->slock, flags);\r\nreturn 0;\r\n}\r\nclear_bit(ST_M2M_SUSPENDED, &gsc->state);\r\nset_bit(ST_M2M_SUSPENDING, &gsc->state);\r\nspin_unlock_irqrestore(&gsc->slock, flags);\r\ntimeout = wait_event_timeout(gsc->irq_queue,\r\ntest_bit(ST_M2M_SUSPENDED, &gsc->state),\r\nGSC_SHUTDOWN_TIMEOUT);\r\nclear_bit(ST_M2M_SUSPENDING, &gsc->state);\r\nreturn timeout == 0 ? -EAGAIN : 0;\r\n}\r\nstatic int gsc_m2m_resume(struct gsc_dev *gsc)\r\n{\r\nstruct gsc_ctx *ctx;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gsc->slock, flags);\r\nctx = gsc->m2m.ctx;\r\ngsc->m2m.ctx = NULL;\r\nspin_unlock_irqrestore(&gsc->slock, flags);\r\nif (test_and_clear_bit(ST_M2M_SUSPENDED, &gsc->state))\r\ngsc_m2m_job_finish(ctx, VB2_BUF_STATE_ERROR);\r\nreturn 0;\r\n}\r\nstatic int gsc_probe(struct platform_device *pdev)\r\n{\r\nstruct gsc_dev *gsc;\r\nstruct resource *res;\r\nstruct gsc_driverdata *drv_data = gsc_get_drv_data(pdev);\r\nstruct device *dev = &pdev->dev;\r\nint ret = 0;\r\ngsc = devm_kzalloc(dev, sizeof(struct gsc_dev), GFP_KERNEL);\r\nif (!gsc)\r\nreturn -ENOMEM;\r\nif (dev->of_node)\r\ngsc->id = of_alias_get_id(pdev->dev.of_node, "gsc");\r\nelse\r\ngsc->id = pdev->id;\r\nif (gsc->id < 0 || gsc->id >= drv_data->num_entities) {\r\ndev_err(dev, "Invalid platform device id: %d\n", gsc->id);\r\nreturn -EINVAL;\r\n}\r\ngsc->variant = drv_data->variant[gsc->id];\r\ngsc->pdev = pdev;\r\ngsc->pdata = dev->platform_data;\r\ninit_waitqueue_head(&gsc->irq_queue);\r\nspin_lock_init(&gsc->slock);\r\nmutex_init(&gsc->lock);\r\ngsc->clock = ERR_PTR(-EINVAL);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ngsc->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(gsc->regs))\r\nreturn PTR_ERR(gsc->regs);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(dev, "failed to get IRQ resource\n");\r\nreturn -ENXIO;\r\n}\r\nret = gsc_clk_get(gsc);\r\nif (ret)\r\nreturn ret;\r\nret = devm_request_irq(dev, res->start, gsc_irq_handler,\r\n0, pdev->name, gsc);\r\nif (ret) {\r\ndev_err(dev, "failed to install irq (%d)\n", ret);\r\ngoto err_clk;\r\n}\r\nret = v4l2_device_register(dev, &gsc->v4l2_dev);\r\nif (ret)\r\ngoto err_clk;\r\nret = gsc_register_m2m_device(gsc);\r\nif (ret)\r\ngoto err_v4l2;\r\nplatform_set_drvdata(pdev, gsc);\r\npm_runtime_enable(dev);\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0)\r\ngoto err_m2m;\r\ngsc->alloc_ctx = vb2_dma_contig_init_ctx(dev);\r\nif (IS_ERR(gsc->alloc_ctx)) {\r\nret = PTR_ERR(gsc->alloc_ctx);\r\ngoto err_pm;\r\n}\r\ndev_dbg(dev, "gsc-%d registered successfully\n", gsc->id);\r\npm_runtime_put(dev);\r\nreturn 0;\r\nerr_pm:\r\npm_runtime_put(dev);\r\nerr_m2m:\r\ngsc_unregister_m2m_device(gsc);\r\nerr_v4l2:\r\nv4l2_device_unregister(&gsc->v4l2_dev);\r\nerr_clk:\r\ngsc_clk_put(gsc);\r\nreturn ret;\r\n}\r\nstatic int gsc_remove(struct platform_device *pdev)\r\n{\r\nstruct gsc_dev *gsc = platform_get_drvdata(pdev);\r\ngsc_unregister_m2m_device(gsc);\r\nv4l2_device_unregister(&gsc->v4l2_dev);\r\nvb2_dma_contig_cleanup_ctx(gsc->alloc_ctx);\r\npm_runtime_disable(&pdev->dev);\r\ngsc_clk_put(gsc);\r\ndev_dbg(&pdev->dev, "%s driver unloaded\n", pdev->name);\r\nreturn 0;\r\n}\r\nstatic int gsc_runtime_resume(struct device *dev)\r\n{\r\nstruct gsc_dev *gsc = dev_get_drvdata(dev);\r\nint ret = 0;\r\npr_debug("gsc%d: state: 0x%lx", gsc->id, gsc->state);\r\nret = clk_enable(gsc->clock);\r\nif (ret)\r\nreturn ret;\r\ngsc_hw_set_sw_reset(gsc);\r\ngsc_wait_reset(gsc);\r\nreturn gsc_m2m_resume(gsc);\r\n}\r\nstatic int gsc_runtime_suspend(struct device *dev)\r\n{\r\nstruct gsc_dev *gsc = dev_get_drvdata(dev);\r\nint ret = 0;\r\nret = gsc_m2m_suspend(gsc);\r\nif (!ret)\r\nclk_disable(gsc->clock);\r\npr_debug("gsc%d: state: 0x%lx", gsc->id, gsc->state);\r\nreturn ret;\r\n}\r\nstatic int gsc_resume(struct device *dev)\r\n{\r\nstruct gsc_dev *gsc = dev_get_drvdata(dev);\r\nunsigned long flags;\r\npr_debug("gsc%d: state: 0x%lx", gsc->id, gsc->state);\r\nspin_lock_irqsave(&gsc->slock, flags);\r\nif (!test_and_clear_bit(ST_SUSPEND, &gsc->state) ||\r\n!gsc_m2m_opened(gsc)) {\r\nspin_unlock_irqrestore(&gsc->slock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&gsc->slock, flags);\r\nif (!pm_runtime_suspended(dev))\r\nreturn gsc_runtime_resume(dev);\r\nreturn 0;\r\n}\r\nstatic int gsc_suspend(struct device *dev)\r\n{\r\nstruct gsc_dev *gsc = dev_get_drvdata(dev);\r\npr_debug("gsc%d: state: 0x%lx", gsc->id, gsc->state);\r\nif (test_and_set_bit(ST_SUSPEND, &gsc->state))\r\nreturn 0;\r\nif (!pm_runtime_suspended(dev))\r\nreturn gsc_runtime_suspend(dev);\r\nreturn 0;\r\n}
