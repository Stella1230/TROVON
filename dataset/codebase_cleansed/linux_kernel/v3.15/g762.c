static inline unsigned int rpm_from_cnt(u8 cnt, u32 clk_freq, u16 p,\r\nu8 clk_div, u8 gear_mult)\r\n{\r\nif (cnt == 0xff)\r\nreturn 0;\r\nreturn (clk_freq * 30 * gear_mult) / ((cnt ? cnt : 1) * p * clk_div);\r\n}\r\nstatic inline unsigned char cnt_from_rpm(u32 rpm, u32 clk_freq, u16 p,\r\nu8 clk_div, u8 gear_mult)\r\n{\r\nif (!rpm)\r\nreturn 0xff;\r\nreturn clamp_val(((clk_freq * 30 * gear_mult) / (rpm * p * clk_div)),\r\n0, 255);\r\n}\r\nstatic struct g762_data *g762_update_client(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g762_data *data = i2c_get_clientdata(client);\r\nint ret = 0;\r\nmutex_lock(&data->update_lock);\r\nif (time_before(jiffies, data->last_updated + G762_UPDATE_INTERVAL) &&\r\nlikely(data->valid))\r\ngoto out;\r\nret = i2c_smbus_read_byte_data(client, G762_REG_SET_CNT);\r\nif (ret < 0)\r\ngoto out;\r\ndata->set_cnt = ret;\r\nret = i2c_smbus_read_byte_data(client, G762_REG_ACT_CNT);\r\nif (ret < 0)\r\ngoto out;\r\ndata->act_cnt = ret;\r\nret = i2c_smbus_read_byte_data(client, G762_REG_FAN_STA);\r\nif (ret < 0)\r\ngoto out;\r\ndata->fan_sta = ret;\r\nret = i2c_smbus_read_byte_data(client, G762_REG_SET_OUT);\r\nif (ret < 0)\r\ngoto out;\r\ndata->set_out = ret;\r\nret = i2c_smbus_read_byte_data(client, G762_REG_FAN_CMD1);\r\nif (ret < 0)\r\ngoto out;\r\ndata->fan_cmd1 = ret;\r\nret = i2c_smbus_read_byte_data(client, G762_REG_FAN_CMD2);\r\nif (ret < 0)\r\ngoto out;\r\ndata->fan_cmd2 = ret;\r\ndata->last_updated = jiffies;\r\ndata->valid = true;\r\nout:\r\nmutex_unlock(&data->update_lock);\r\nif (ret < 0)\r\ndata = ERR_PTR(ret);\r\nreturn data;\r\n}\r\nstatic int do_set_clk_freq(struct device *dev, unsigned long val)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g762_data *data = i2c_get_clientdata(client);\r\nif (val > 0xffffff)\r\nreturn -EINVAL;\r\nif (!val)\r\nval = 32768;\r\ndata->clk_freq = val;\r\nreturn 0;\r\n}\r\nstatic int do_set_pwm_mode(struct device *dev, unsigned long val)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g762_data *data = g762_update_client(dev);\r\nint ret;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nmutex_lock(&data->update_lock);\r\nswitch (val) {\r\ncase G762_OUT_MODE_PWM:\r\ndata->fan_cmd1 |= G762_REG_FAN_CMD1_OUT_MODE;\r\nbreak;\r\ncase G762_OUT_MODE_DC:\r\ndata->fan_cmd1 &= ~G762_REG_FAN_CMD1_OUT_MODE;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = i2c_smbus_write_byte_data(client, G762_REG_FAN_CMD1,\r\ndata->fan_cmd1);\r\ndata->valid = false;\r\nout:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int do_set_fan_div(struct device *dev, unsigned long val)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g762_data *data = g762_update_client(dev);\r\nint ret;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nmutex_lock(&data->update_lock);\r\nswitch (val) {\r\ncase 1:\r\ndata->fan_cmd1 &= ~G762_REG_FAN_CMD1_CLK_DIV_ID0;\r\ndata->fan_cmd1 &= ~G762_REG_FAN_CMD1_CLK_DIV_ID1;\r\nbreak;\r\ncase 2:\r\ndata->fan_cmd1 |= G762_REG_FAN_CMD1_CLK_DIV_ID0;\r\ndata->fan_cmd1 &= ~G762_REG_FAN_CMD1_CLK_DIV_ID1;\r\nbreak;\r\ncase 4:\r\ndata->fan_cmd1 &= ~G762_REG_FAN_CMD1_CLK_DIV_ID0;\r\ndata->fan_cmd1 |= G762_REG_FAN_CMD1_CLK_DIV_ID1;\r\nbreak;\r\ncase 8:\r\ndata->fan_cmd1 |= G762_REG_FAN_CMD1_CLK_DIV_ID0;\r\ndata->fan_cmd1 |= G762_REG_FAN_CMD1_CLK_DIV_ID1;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = i2c_smbus_write_byte_data(client, G762_REG_FAN_CMD1,\r\ndata->fan_cmd1);\r\ndata->valid = false;\r\nout:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int do_set_fan_gear_mode(struct device *dev, unsigned long val)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g762_data *data = g762_update_client(dev);\r\nint ret;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nmutex_lock(&data->update_lock);\r\nswitch (val) {\r\ncase 0:\r\ndata->fan_cmd2 &= ~G762_REG_FAN_CMD2_GEAR_MODE_0;\r\ndata->fan_cmd2 &= ~G762_REG_FAN_CMD2_GEAR_MODE_1;\r\nbreak;\r\ncase 1:\r\ndata->fan_cmd2 |= G762_REG_FAN_CMD2_GEAR_MODE_0;\r\ndata->fan_cmd2 &= ~G762_REG_FAN_CMD2_GEAR_MODE_1;\r\nbreak;\r\ncase 2:\r\ndata->fan_cmd2 &= ~G762_REG_FAN_CMD2_GEAR_MODE_0;\r\ndata->fan_cmd2 |= G762_REG_FAN_CMD2_GEAR_MODE_1;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = i2c_smbus_write_byte_data(client, G762_REG_FAN_CMD2,\r\ndata->fan_cmd2);\r\ndata->valid = false;\r\nout:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int do_set_fan_pulses(struct device *dev, unsigned long val)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g762_data *data = g762_update_client(dev);\r\nint ret;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nmutex_lock(&data->update_lock);\r\nswitch (val) {\r\ncase 2:\r\ndata->fan_cmd1 &= ~G762_REG_FAN_CMD1_PULSE_PER_REV;\r\nbreak;\r\ncase 4:\r\ndata->fan_cmd1 |= G762_REG_FAN_CMD1_PULSE_PER_REV;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = i2c_smbus_write_byte_data(client, G762_REG_FAN_CMD1,\r\ndata->fan_cmd1);\r\ndata->valid = false;\r\nout:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int do_set_pwm_enable(struct device *dev, unsigned long val)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g762_data *data = g762_update_client(dev);\r\nint ret;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nmutex_lock(&data->update_lock);\r\nswitch (val) {\r\ncase G762_FAN_MODE_CLOSED_LOOP:\r\ndata->fan_cmd1 |= G762_REG_FAN_CMD1_FAN_MODE;\r\nbreak;\r\ncase G762_FAN_MODE_OPEN_LOOP:\r\ndata->fan_cmd1 &= ~G762_REG_FAN_CMD1_FAN_MODE;\r\nif (data->set_cnt == 0xff)\r\ni2c_smbus_write_byte_data(client, G762_REG_SET_CNT,\r\n254);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = i2c_smbus_write_byte_data(client, G762_REG_FAN_CMD1,\r\ndata->fan_cmd1);\r\ndata->valid = false;\r\nout:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int do_set_pwm_polarity(struct device *dev, unsigned long val)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g762_data *data = g762_update_client(dev);\r\nint ret;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nmutex_lock(&data->update_lock);\r\nswitch (val) {\r\ncase G762_PWM_POLARITY_POSITIVE:\r\ndata->fan_cmd1 &= ~G762_REG_FAN_CMD1_PWM_POLARITY;\r\nbreak;\r\ncase G762_PWM_POLARITY_NEGATIVE:\r\ndata->fan_cmd1 |= G762_REG_FAN_CMD1_PWM_POLARITY;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = i2c_smbus_write_byte_data(client, G762_REG_FAN_CMD1,\r\ndata->fan_cmd1);\r\ndata->valid = false;\r\nout:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int do_set_pwm(struct device *dev, unsigned long val)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g762_data *data = i2c_get_clientdata(client);\r\nint ret;\r\nif (val > 255)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nret = i2c_smbus_write_byte_data(client, G762_REG_SET_OUT, val);\r\ndata->valid = false;\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int do_set_fan_target(struct device *dev, unsigned long val)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g762_data *data = g762_update_client(dev);\r\nint ret;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nmutex_lock(&data->update_lock);\r\ndata->set_cnt = cnt_from_rpm(val, data->clk_freq,\r\nG762_PULSE_FROM_REG(data->fan_cmd1),\r\nG762_CLKDIV_FROM_REG(data->fan_cmd1),\r\nG762_GEARMULT_FROM_REG(data->fan_cmd2));\r\nret = i2c_smbus_write_byte_data(client, G762_REG_SET_CNT,\r\ndata->set_cnt);\r\ndata->valid = false;\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int do_set_fan_startv(struct device *dev, unsigned long val)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g762_data *data = g762_update_client(dev);\r\nint ret;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nmutex_lock(&data->update_lock);\r\nswitch (val) {\r\ncase 0:\r\ndata->fan_cmd2 &= ~G762_REG_FAN_CMD2_FAN_STARTV_0;\r\ndata->fan_cmd2 &= ~G762_REG_FAN_CMD2_FAN_STARTV_1;\r\nbreak;\r\ncase 1:\r\ndata->fan_cmd2 |= G762_REG_FAN_CMD2_FAN_STARTV_0;\r\ndata->fan_cmd2 &= ~G762_REG_FAN_CMD2_FAN_STARTV_1;\r\nbreak;\r\ncase 2:\r\ndata->fan_cmd2 &= ~G762_REG_FAN_CMD2_FAN_STARTV_0;\r\ndata->fan_cmd2 |= G762_REG_FAN_CMD2_FAN_STARTV_1;\r\nbreak;\r\ncase 3:\r\ndata->fan_cmd2 |= G762_REG_FAN_CMD2_FAN_STARTV_0;\r\ndata->fan_cmd2 |= G762_REG_FAN_CMD2_FAN_STARTV_1;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = i2c_smbus_write_byte_data(client, G762_REG_FAN_CMD2,\r\ndata->fan_cmd2);\r\ndata->valid = false;\r\nout:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int g762_of_clock_enable(struct i2c_client *client)\r\n{\r\nstruct g762_data *data;\r\nunsigned long clk_freq;\r\nstruct clk *clk;\r\nint ret;\r\nif (!client->dev.of_node)\r\nreturn 0;\r\nclk = of_clk_get(client->dev.of_node, 0);\r\nif (IS_ERR(clk)) {\r\ndev_err(&client->dev, "failed to get clock\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to enable clock\n");\r\ngoto clk_put;\r\n}\r\nclk_freq = clk_get_rate(clk);\r\nret = do_set_clk_freq(&client->dev, clk_freq);\r\nif (ret) {\r\ndev_err(&client->dev, "invalid clock freq %lu\n", clk_freq);\r\ngoto clk_unprep;\r\n}\r\ndata = i2c_get_clientdata(client);\r\ndata->clk = clk;\r\nreturn 0;\r\nclk_unprep:\r\nclk_disable_unprepare(clk);\r\nclk_put:\r\nclk_put(clk);\r\nreturn ret;\r\n}\r\nstatic void g762_of_clock_disable(struct i2c_client *client)\r\n{\r\nstruct g762_data *data = i2c_get_clientdata(client);\r\nif (!data->clk)\r\nreturn;\r\nclk_disable_unprepare(data->clk);\r\nclk_put(data->clk);\r\n}\r\nstatic int g762_of_prop_import_one(struct i2c_client *client,\r\nconst char *pname,\r\nint (*psetter)(struct device *dev,\r\nunsigned long val))\r\n{\r\nconst __be32 *prop;\r\nint len, ret;\r\nu32 pval;\r\nprop = of_get_property(client->dev.of_node, pname, &len);\r\nif (!prop || len != sizeof(u32))\r\nreturn 0;\r\npval = be32_to_cpu(prop[0]);\r\ndev_dbg(&client->dev, "found %s (%d)\n", pname, pval);\r\nret = (*psetter)(&client->dev, pval);\r\nif (ret)\r\ndev_err(&client->dev, "unable to set %s (%d)\n", pname, pval);\r\nreturn ret;\r\n}\r\nstatic int g762_of_prop_import(struct i2c_client *client)\r\n{\r\nint ret;\r\nif (!client->dev.of_node)\r\nreturn 0;\r\nret = g762_of_prop_import_one(client, "fan_gear_mode",\r\ndo_set_fan_gear_mode);\r\nif (ret)\r\nreturn ret;\r\nret = g762_of_prop_import_one(client, "pwm_polarity",\r\ndo_set_pwm_polarity);\r\nif (ret)\r\nreturn ret;\r\nreturn g762_of_prop_import_one(client, "fan_startv",\r\ndo_set_fan_startv);\r\n}\r\nstatic int g762_of_prop_import(struct i2c_client *client)\r\n{\r\nreturn 0;\r\n}\r\nstatic int g762_of_clock_enable(struct i2c_client *client)\r\n{\r\nreturn 0;\r\n}\r\nstatic void g762_of_clock_disable(struct i2c_client *client) { }\r\nstatic int g762_pdata_prop_import(struct i2c_client *client)\r\n{\r\nstruct g762_platform_data *pdata = dev_get_platdata(&client->dev);\r\nint ret;\r\nif (!pdata)\r\nreturn 0;\r\nret = do_set_fan_gear_mode(&client->dev, pdata->fan_gear_mode);\r\nif (ret)\r\nreturn ret;\r\nret = do_set_pwm_polarity(&client->dev, pdata->pwm_polarity);\r\nif (ret)\r\nreturn ret;\r\nret = do_set_fan_startv(&client->dev, pdata->fan_startv);\r\nif (ret)\r\nreturn ret;\r\nreturn do_set_clk_freq(&client->dev, pdata->clk_freq);\r\n}\r\nstatic ssize_t get_fan_rpm(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct g762_data *data = g762_update_client(dev);\r\nunsigned int rpm = 0;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nmutex_lock(&data->update_lock);\r\nif (data->fan_sta & G762_REG_FAN_STA_OOC) {\r\nrpm = rpm_from_cnt(data->act_cnt, data->clk_freq,\r\nG762_PULSE_FROM_REG(data->fan_cmd1),\r\nG762_CLKDIV_FROM_REG(data->fan_cmd1),\r\nG762_GEARMULT_FROM_REG(data->fan_cmd2));\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%u\n", rpm);\r\n}\r\nstatic ssize_t get_pwm_mode(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct g762_data *data = g762_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%d\n",\r\n!!(data->fan_cmd1 & G762_REG_FAN_CMD1_OUT_MODE));\r\n}\r\nstatic ssize_t set_pwm_mode(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nret = do_set_pwm_mode(dev, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t get_fan_div(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct g762_data *data = g762_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%d\n", G762_CLKDIV_FROM_REG(data->fan_cmd1));\r\n}\r\nstatic ssize_t set_fan_div(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nret = do_set_fan_div(dev, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t get_fan_pulses(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct g762_data *data = g762_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%d\n", G762_PULSE_FROM_REG(data->fan_cmd1));\r\n}\r\nstatic ssize_t set_fan_pulses(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nret = do_set_fan_pulses(dev, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t get_pwm_enable(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct g762_data *data = g762_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%d\n",\r\n(!!(data->fan_cmd1 & G762_REG_FAN_CMD1_FAN_MODE)) + 1);\r\n}\r\nstatic ssize_t set_pwm_enable(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nret = do_set_pwm_enable(dev, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t get_pwm(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct g762_data *data = g762_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%d\n", data->set_out);\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nret = do_set_pwm(dev, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t get_fan_target(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct g762_data *data = g762_update_client(dev);\r\nunsigned int rpm;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nmutex_lock(&data->update_lock);\r\nrpm = rpm_from_cnt(data->set_cnt, data->clk_freq,\r\nG762_PULSE_FROM_REG(data->fan_cmd1),\r\nG762_CLKDIV_FROM_REG(data->fan_cmd1),\r\nG762_GEARMULT_FROM_REG(data->fan_cmd2));\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%u\n", rpm);\r\n}\r\nstatic ssize_t set_fan_target(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nret = do_set_fan_target(dev, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t get_fan_failure(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct g762_data *data = g762_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%u\n", !!(data->fan_sta & G762_REG_FAN_STA_FAIL));\r\n}\r\nstatic ssize_t get_fan_ooc(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct g762_data *data = g762_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%u\n", !(data->fan_sta & G762_REG_FAN_STA_OOC));\r\n}\r\nstatic inline int g762_fan_init(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct g762_data *data = g762_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\ndata->fan_cmd1 |= G762_REG_FAN_CMD1_DET_FAN_FAIL;\r\ndata->fan_cmd1 |= G762_REG_FAN_CMD1_DET_FAN_OOC;\r\ndata->valid = false;\r\nreturn i2c_smbus_write_byte_data(client, G762_REG_FAN_CMD1,\r\ndata->fan_cmd1);\r\n}\r\nstatic int g762_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct g762_data *data;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct g762_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\ndata->client = client;\r\nmutex_init(&data->update_lock);\r\nret = g762_fan_init(&client->dev);\r\nif (ret)\r\nreturn ret;\r\nret = g762_of_clock_enable(client);\r\nif (ret)\r\nreturn ret;\r\nret = g762_of_prop_import(client);\r\nif (ret)\r\ngoto clock_dis;\r\nret = g762_pdata_prop_import(client);\r\nif (ret)\r\ngoto clock_dis;\r\nret = sysfs_create_group(&client->dev.kobj, &g762_group);\r\nif (ret)\r\ngoto clock_dis;\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nret = PTR_ERR(data->hwmon_dev);\r\ngoto sysfs_rem;\r\n}\r\nreturn 0;\r\nsysfs_rem:\r\nsysfs_remove_group(&client->dev.kobj, &g762_group);\r\nclock_dis:\r\ng762_of_clock_disable(client);\r\nreturn ret;\r\n}\r\nstatic int g762_remove(struct i2c_client *client)\r\n{\r\nstruct g762_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &g762_group);\r\ng762_of_clock_disable(client);\r\nreturn 0;\r\n}
