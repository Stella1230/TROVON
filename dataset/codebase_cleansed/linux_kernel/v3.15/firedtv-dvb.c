static int alloc_channel(struct firedtv *fdtv)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++)\r\nif (!__test_and_set_bit(i, &fdtv->channel_active))\r\nbreak;\r\nreturn i;\r\n}\r\nstatic void collect_channels(struct firedtv *fdtv, int *pidc, u16 pid[])\r\n{\r\nint i, n;\r\nfor (i = 0, n = 0; i < 16; i++)\r\nif (test_bit(i, &fdtv->channel_active))\r\npid[n++] = fdtv->channel_pid[i];\r\n*pidc = n;\r\n}\r\nstatic inline void dealloc_channel(struct firedtv *fdtv, int i)\r\n{\r\n__clear_bit(i, &fdtv->channel_active);\r\n}\r\nint fdtv_start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct firedtv *fdtv = dvbdmxfeed->demux->priv;\r\nint pidc, c, ret;\r\nu16 pids[16];\r\nswitch (dvbdmxfeed->type) {\r\ncase DMX_TYPE_TS:\r\ncase DMX_TYPE_SEC:\r\nbreak;\r\ndefault:\r\ndev_err(fdtv->device, "can't start dmx feed: invalid type %u\n",\r\ndvbdmxfeed->type);\r\nreturn -EINVAL;\r\n}\r\nif (mutex_lock_interruptible(&fdtv->demux_mutex))\r\nreturn -EINTR;\r\nif (dvbdmxfeed->type == DMX_TYPE_TS) {\r\nswitch (dvbdmxfeed->pes_type) {\r\ncase DMX_PES_VIDEO:\r\ncase DMX_PES_AUDIO:\r\ncase DMX_PES_TELETEXT:\r\ncase DMX_PES_PCR:\r\ncase DMX_PES_OTHER:\r\nc = alloc_channel(fdtv);\r\nbreak;\r\ndefault:\r\ndev_err(fdtv->device,\r\n"can't start dmx feed: invalid pes type %u\n",\r\ndvbdmxfeed->pes_type);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n} else {\r\nc = alloc_channel(fdtv);\r\n}\r\nif (c > 15) {\r\ndev_err(fdtv->device, "can't start dmx feed: busy\n");\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ndvbdmxfeed->priv = (typeof(dvbdmxfeed->priv))(unsigned long)c;\r\nfdtv->channel_pid[c] = dvbdmxfeed->pid;\r\ncollect_channels(fdtv, &pidc, pids);\r\nif (dvbdmxfeed->pid == 8192) {\r\nret = avc_tuner_get_ts(fdtv);\r\nif (ret) {\r\ndealloc_channel(fdtv, c);\r\ndev_err(fdtv->device, "can't get TS\n");\r\ngoto out;\r\n}\r\n} else {\r\nret = avc_tuner_set_pids(fdtv, pidc, pids);\r\nif (ret) {\r\ndealloc_channel(fdtv, c);\r\ndev_err(fdtv->device, "can't set PIDs\n");\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&fdtv->demux_mutex);\r\nreturn ret;\r\n}\r\nint fdtv_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *demux = dvbdmxfeed->demux;\r\nstruct firedtv *fdtv = demux->priv;\r\nint pidc, c, ret;\r\nu16 pids[16];\r\nif (dvbdmxfeed->type == DMX_TYPE_TS &&\r\n!((dvbdmxfeed->ts_type & TS_PACKET) &&\r\n(demux->dmx.frontend->source != DMX_MEMORY_FE))) {\r\nif (dvbdmxfeed->ts_type & TS_DECODER) {\r\nif (dvbdmxfeed->pes_type >= DMX_PES_OTHER ||\r\n!demux->pesfilter[dvbdmxfeed->pes_type])\r\nreturn -EINVAL;\r\ndemux->pids[dvbdmxfeed->pes_type] |= 0x8000;\r\ndemux->pesfilter[dvbdmxfeed->pes_type] = NULL;\r\n}\r\nif (!(dvbdmxfeed->ts_type & TS_DECODER &&\r\ndvbdmxfeed->pes_type < DMX_PES_OTHER))\r\nreturn 0;\r\n}\r\nif (mutex_lock_interruptible(&fdtv->demux_mutex))\r\nreturn -EINTR;\r\nc = (unsigned long)dvbdmxfeed->priv;\r\ndealloc_channel(fdtv, c);\r\ncollect_channels(fdtv, &pidc, pids);\r\nret = avc_tuner_set_pids(fdtv, pidc, pids);\r\nmutex_unlock(&fdtv->demux_mutex);\r\nreturn ret;\r\n}\r\nint fdtv_dvb_register(struct firedtv *fdtv, const char *name)\r\n{\r\nint err;\r\nerr = dvb_register_adapter(&fdtv->adapter, name,\r\nTHIS_MODULE, fdtv->device, adapter_nr);\r\nif (err < 0)\r\ngoto fail_log;\r\nfdtv->demux.dmx.capabilities = 0;\r\nfdtv->demux.priv = fdtv;\r\nfdtv->demux.filternum = 16;\r\nfdtv->demux.feednum = 16;\r\nfdtv->demux.start_feed = fdtv_start_feed;\r\nfdtv->demux.stop_feed = fdtv_stop_feed;\r\nfdtv->demux.write_to_decoder = NULL;\r\nerr = dvb_dmx_init(&fdtv->demux);\r\nif (err)\r\ngoto fail_unreg_adapter;\r\nfdtv->dmxdev.filternum = 16;\r\nfdtv->dmxdev.demux = &fdtv->demux.dmx;\r\nfdtv->dmxdev.capabilities = 0;\r\nerr = dvb_dmxdev_init(&fdtv->dmxdev, &fdtv->adapter);\r\nif (err)\r\ngoto fail_dmx_release;\r\nfdtv->frontend.source = DMX_FRONTEND_0;\r\nerr = fdtv->demux.dmx.add_frontend(&fdtv->demux.dmx, &fdtv->frontend);\r\nif (err)\r\ngoto fail_dmxdev_release;\r\nerr = fdtv->demux.dmx.connect_frontend(&fdtv->demux.dmx,\r\n&fdtv->frontend);\r\nif (err)\r\ngoto fail_rem_frontend;\r\nerr = dvb_net_init(&fdtv->adapter, &fdtv->dvbnet, &fdtv->demux.dmx);\r\nif (err)\r\ngoto fail_disconnect_frontend;\r\nfdtv_frontend_init(fdtv, name);\r\nerr = dvb_register_frontend(&fdtv->adapter, &fdtv->fe);\r\nif (err)\r\ngoto fail_net_release;\r\nerr = fdtv_ca_register(fdtv);\r\nif (err)\r\ndev_info(fdtv->device,\r\n"Conditional Access Module not enabled\n");\r\nreturn 0;\r\nfail_net_release:\r\ndvb_net_release(&fdtv->dvbnet);\r\nfail_disconnect_frontend:\r\nfdtv->demux.dmx.close(&fdtv->demux.dmx);\r\nfail_rem_frontend:\r\nfdtv->demux.dmx.remove_frontend(&fdtv->demux.dmx, &fdtv->frontend);\r\nfail_dmxdev_release:\r\ndvb_dmxdev_release(&fdtv->dmxdev);\r\nfail_dmx_release:\r\ndvb_dmx_release(&fdtv->demux);\r\nfail_unreg_adapter:\r\ndvb_unregister_adapter(&fdtv->adapter);\r\nfail_log:\r\ndev_err(fdtv->device, "DVB initialization failed\n");\r\nreturn err;\r\n}\r\nvoid fdtv_dvb_unregister(struct firedtv *fdtv)\r\n{\r\nfdtv_ca_release(fdtv);\r\ndvb_unregister_frontend(&fdtv->fe);\r\ndvb_net_release(&fdtv->dvbnet);\r\nfdtv->demux.dmx.close(&fdtv->demux.dmx);\r\nfdtv->demux.dmx.remove_frontend(&fdtv->demux.dmx, &fdtv->frontend);\r\ndvb_dmxdev_release(&fdtv->dmxdev);\r\ndvb_dmx_release(&fdtv->demux);\r\ndvb_unregister_adapter(&fdtv->adapter);\r\n}
