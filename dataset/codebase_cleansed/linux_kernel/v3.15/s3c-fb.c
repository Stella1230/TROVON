static bool s3c_fb_validate_win_bpp(struct s3c_fb_win *win, unsigned int bpp)\r\n{\r\nreturn win->variant.valid_bpp & VALID_BPP(bpp);\r\n}\r\nstatic int s3c_fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct s3c_fb_win *win = info->par;\r\nstruct s3c_fb *sfb = win->parent;\r\ndev_dbg(sfb->dev, "checking parameters\n");\r\nvar->xres_virtual = max(var->xres_virtual, var->xres);\r\nvar->yres_virtual = max(var->yres_virtual, var->yres);\r\nif (!s3c_fb_validate_win_bpp(win, var->bits_per_pixel)) {\r\ndev_dbg(sfb->dev, "win %d: unsupported bpp %d\n",\r\nwin->index, var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\nif (sfb->variant.palette[win->index] != 0) {\r\nvar->red.offset = 5;\r\nvar->green.offset = 2;\r\nvar->blue.offset = 0;\r\nvar->red.length = 2;\r\nvar->green.length = 3;\r\nvar->blue.length = 2;\r\nvar->transp.offset = 7;\r\nvar->transp.length = 1;\r\n} else {\r\nvar->red.offset = 0;\r\nvar->red.length = var->bits_per_pixel;\r\nvar->green = var->red;\r\nvar->blue = var->red;\r\n}\r\nbreak;\r\ncase 19:\r\nvar->transp.offset = 18;\r\nvar->transp.length = 1;\r\ncase 18:\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 12;\r\nvar->green.offset = 6;\r\nvar->blue.offset = 0;\r\nvar->red.length = 6;\r\nvar->green.length = 6;\r\nvar->blue.length = 6;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.length = 6;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 32:\r\ncase 28:\r\ncase 25:\r\nvar->transp.length = var->bits_per_pixel - 24;\r\nvar->transp.offset = 24;\r\ncase 24:\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nbreak;\r\ndefault:\r\ndev_err(sfb->dev, "invalid bpp\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(sfb->dev, "%s: verified parameters\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int s3c_fb_calc_pixclk(struct s3c_fb *sfb, unsigned int pixclk)\r\n{\r\nunsigned long clk;\r\nunsigned long long tmp;\r\nunsigned int result;\r\nif (sfb->variant.has_clksel)\r\nclk = clk_get_rate(sfb->bus_clk);\r\nelse\r\nclk = clk_get_rate(sfb->lcd_clk);\r\ntmp = (unsigned long long)clk;\r\ntmp *= pixclk;\r\ndo_div(tmp, 1000000000UL);\r\nresult = (unsigned int)tmp / 1000;\r\ndev_dbg(sfb->dev, "pixclk=%u, clk=%lu, div=%d (%lu)\n",\r\npixclk, clk, result, result ? clk / result : clk);\r\nreturn result;\r\n}\r\nstatic int s3c_fb_align_word(unsigned int bpp, unsigned int pix)\r\n{\r\nint pix_per_word;\r\nif (bpp > 16)\r\nreturn pix;\r\npix_per_word = (8 * 32) / bpp;\r\nreturn ALIGN(pix, pix_per_word);\r\n}\r\nstatic void vidosd_set_size(struct s3c_fb_win *win, u32 size)\r\n{\r\nstruct s3c_fb *sfb = win->parent;\r\nif (win->variant.osd_size_off)\r\nwritel(size, sfb->regs + OSD_BASE(win->index, sfb->variant)\r\n+ win->variant.osd_size_off);\r\n}\r\nstatic void vidosd_set_alpha(struct s3c_fb_win *win, u32 alpha)\r\n{\r\nstruct s3c_fb *sfb = win->parent;\r\nif (win->variant.has_osd_alpha)\r\nwritel(alpha, sfb->regs + VIDOSD_C(win->index, sfb->variant));\r\n}\r\nstatic void shadow_protect_win(struct s3c_fb_win *win, bool protect)\r\n{\r\nstruct s3c_fb *sfb = win->parent;\r\nu32 reg;\r\nif (protect) {\r\nif (sfb->variant.has_prtcon) {\r\nwritel(PRTCON_PROTECT, sfb->regs + PRTCON);\r\n} else if (sfb->variant.has_shadowcon) {\r\nreg = readl(sfb->regs + SHADOWCON);\r\nwritel(reg | SHADOWCON_WINx_PROTECT(win->index),\r\nsfb->regs + SHADOWCON);\r\n}\r\n} else {\r\nif (sfb->variant.has_prtcon) {\r\nwritel(0, sfb->regs + PRTCON);\r\n} else if (sfb->variant.has_shadowcon) {\r\nreg = readl(sfb->regs + SHADOWCON);\r\nwritel(reg & ~SHADOWCON_WINx_PROTECT(win->index),\r\nsfb->regs + SHADOWCON);\r\n}\r\n}\r\n}\r\nstatic void s3c_fb_enable(struct s3c_fb *sfb, int enable)\r\n{\r\nu32 vidcon0 = readl(sfb->regs + VIDCON0);\r\nif (enable && !sfb->output_on)\r\npm_runtime_get_sync(sfb->dev);\r\nif (enable) {\r\nvidcon0 |= VIDCON0_ENVID | VIDCON0_ENVID_F;\r\n} else {\r\nif (vidcon0 & VIDCON0_ENVID) {\r\nvidcon0 |= VIDCON0_ENVID;\r\nvidcon0 &= ~VIDCON0_ENVID_F;\r\n}\r\n}\r\nwritel(vidcon0, sfb->regs + VIDCON0);\r\nif (!enable && sfb->output_on)\r\npm_runtime_put_sync(sfb->dev);\r\nsfb->output_on = enable;\r\n}\r\nstatic int s3c_fb_set_par(struct fb_info *info)\r\n{\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct s3c_fb_win *win = info->par;\r\nstruct s3c_fb *sfb = win->parent;\r\nvoid __iomem *regs = sfb->regs;\r\nvoid __iomem *buf = regs;\r\nint win_no = win->index;\r\nu32 alpha = 0;\r\nu32 data;\r\nu32 pagewidth;\r\ndev_dbg(sfb->dev, "setting framebuffer parameters\n");\r\npm_runtime_get_sync(sfb->dev);\r\nshadow_protect_win(win, 1);\r\nswitch (var->bits_per_pixel) {\r\ncase 32:\r\ncase 24:\r\ncase 16:\r\ncase 12:\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\ncase 8:\r\nif (win->variant.palette_sz >= 256)\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\ncase 1:\r\ninfo->fix.visual = FB_VISUAL_MONO01;\r\nbreak;\r\ndefault:\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\n}\r\ninfo->fix.line_length = (var->xres_virtual * var->bits_per_pixel) / 8;\r\ninfo->fix.xpanstep = info->var.xres_virtual > info->var.xres ? 1 : 0;\r\ninfo->fix.ypanstep = info->var.yres_virtual > info->var.yres ? 1 : 0;\r\nwritel(0, regs + WINCON(win_no));\r\nif (!sfb->output_on)\r\ns3c_fb_enable(sfb, 1);\r\nbuf = regs + win_no * 8;\r\nwritel(info->fix.smem_start, buf + sfb->variant.buf_start);\r\ndata = info->fix.smem_start + info->fix.line_length * var->yres;\r\nwritel(data, buf + sfb->variant.buf_end);\r\npagewidth = (var->xres * var->bits_per_pixel) >> 3;\r\ndata = VIDW_BUF_SIZE_OFFSET(info->fix.line_length - pagewidth) |\r\nVIDW_BUF_SIZE_PAGEWIDTH(pagewidth) |\r\nVIDW_BUF_SIZE_OFFSET_E(info->fix.line_length - pagewidth) |\r\nVIDW_BUF_SIZE_PAGEWIDTH_E(pagewidth);\r\nwritel(data, regs + sfb->variant.buf_size + (win_no * 4));\r\ndata = VIDOSDxA_TOPLEFT_X(0) | VIDOSDxA_TOPLEFT_Y(0) |\r\nVIDOSDxA_TOPLEFT_X_E(0) | VIDOSDxA_TOPLEFT_Y_E(0);\r\nwritel(data, regs + VIDOSD_A(win_no, sfb->variant));\r\ndata = VIDOSDxB_BOTRIGHT_X(s3c_fb_align_word(var->bits_per_pixel,\r\nvar->xres - 1)) |\r\nVIDOSDxB_BOTRIGHT_Y(var->yres - 1) |\r\nVIDOSDxB_BOTRIGHT_X_E(s3c_fb_align_word(var->bits_per_pixel,\r\nvar->xres - 1)) |\r\nVIDOSDxB_BOTRIGHT_Y_E(var->yres - 1);\r\nwritel(data, regs + VIDOSD_B(win_no, sfb->variant));\r\ndata = var->xres * var->yres;\r\nalpha = VIDISD14C_ALPHA1_R(0xf) |\r\nVIDISD14C_ALPHA1_G(0xf) |\r\nVIDISD14C_ALPHA1_B(0xf);\r\nvidosd_set_alpha(win, alpha);\r\nvidosd_set_size(win, data);\r\nif (sfb->variant.has_shadowcon) {\r\ndata = readl(sfb->regs + SHADOWCON);\r\ndata |= SHADOWCON_CHx_ENABLE(win_no);\r\nwritel(data, sfb->regs + SHADOWCON);\r\n}\r\ndata = WINCONx_ENWIN;\r\nsfb->enabled |= (1 << win->index);\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\ndata |= WINCON0_BPPMODE_1BPP;\r\ndata |= WINCONx_BITSWP;\r\ndata |= WINCONx_BURSTLEN_4WORD;\r\nbreak;\r\ncase 2:\r\ndata |= WINCON0_BPPMODE_2BPP;\r\ndata |= WINCONx_BITSWP;\r\ndata |= WINCONx_BURSTLEN_8WORD;\r\nbreak;\r\ncase 4:\r\ndata |= WINCON0_BPPMODE_4BPP;\r\ndata |= WINCONx_BITSWP;\r\ndata |= WINCONx_BURSTLEN_8WORD;\r\nbreak;\r\ncase 8:\r\nif (var->transp.length != 0)\r\ndata |= WINCON1_BPPMODE_8BPP_1232;\r\nelse\r\ndata |= WINCON0_BPPMODE_8BPP_PALETTE;\r\ndata |= WINCONx_BURSTLEN_8WORD;\r\ndata |= WINCONx_BYTSWP;\r\nbreak;\r\ncase 16:\r\nif (var->transp.length != 0)\r\ndata |= WINCON1_BPPMODE_16BPP_A1555;\r\nelse\r\ndata |= WINCON0_BPPMODE_16BPP_565;\r\ndata |= WINCONx_HAWSWP;\r\ndata |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nif (var->red.length == 6) {\r\nif (var->transp.length != 0)\r\ndata |= WINCON1_BPPMODE_19BPP_A1666;\r\nelse\r\ndata |= WINCON1_BPPMODE_18BPP_666;\r\n} else if (var->transp.length == 1)\r\ndata |= WINCON1_BPPMODE_25BPP_A1888\r\n| WINCON1_BLD_PIX;\r\nelse if ((var->transp.length == 4) ||\r\n(var->transp.length == 8))\r\ndata |= WINCON1_BPPMODE_28BPP_A4888\r\n| WINCON1_BLD_PIX | WINCON1_ALPHA_SEL;\r\nelse\r\ndata |= WINCON0_BPPMODE_24BPP_888;\r\ndata |= WINCONx_WSWP;\r\ndata |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\n}\r\nif (win_no > 0) {\r\nu32 keycon0_data = 0, keycon1_data = 0;\r\nvoid __iomem *keycon = regs + sfb->variant.keycon;\r\nkeycon0_data = ~(WxKEYCON0_KEYBL_EN |\r\nWxKEYCON0_KEYEN_F |\r\nWxKEYCON0_DIRCON) | WxKEYCON0_COMPKEY(0);\r\nkeycon1_data = WxKEYCON1_COLVAL(0xffffff);\r\nkeycon += (win_no - 1) * 8;\r\nwritel(keycon0_data, keycon + WKEYCON0);\r\nwritel(keycon1_data, keycon + WKEYCON1);\r\n}\r\nwritel(data, regs + sfb->variant.wincon + (win_no * 4));\r\nwritel(0x0, regs + sfb->variant.winmap + (win_no * 4));\r\nif (sfb->variant.has_blendcon) {\r\ndata = readl(sfb->regs + BLENDCON);\r\ndata &= ~BLENDCON_NEW_MASK;\r\nif (var->transp.length > 4)\r\ndata |= BLENDCON_NEW_8BIT_ALPHA_VALUE;\r\nelse\r\ndata |= BLENDCON_NEW_4BIT_ALPHA_VALUE;\r\nwritel(data, sfb->regs + BLENDCON);\r\n}\r\nshadow_protect_win(win, 0);\r\npm_runtime_put_sync(sfb->dev);\r\nreturn 0;\r\n}\r\nstatic void s3c_fb_update_palette(struct s3c_fb *sfb,\r\nstruct s3c_fb_win *win,\r\nunsigned int reg,\r\nu32 value)\r\n{\r\nvoid __iomem *palreg;\r\nu32 palcon;\r\npalreg = sfb->regs + sfb->variant.palette[win->index];\r\ndev_dbg(sfb->dev, "%s: win %d, reg %d (%p): %08x\n",\r\n__func__, win->index, reg, palreg, value);\r\nwin->palette_buffer[reg] = value;\r\npalcon = readl(sfb->regs + WPALCON);\r\nwritel(palcon | WPALCON_PAL_UPDATE, sfb->regs + WPALCON);\r\nif (win->variant.palette_16bpp)\r\nwritew(value, palreg + (reg * 2));\r\nelse\r\nwritel(value, palreg + (reg * 4));\r\nwritel(palcon, sfb->regs + WPALCON);\r\n}\r\nstatic inline unsigned int chan_to_field(unsigned int chan,\r\nstruct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int s3c_fb_setcolreg(unsigned regno,\r\nunsigned red, unsigned green, unsigned blue,\r\nunsigned transp, struct fb_info *info)\r\n{\r\nstruct s3c_fb_win *win = info->par;\r\nstruct s3c_fb *sfb = win->parent;\r\nunsigned int val;\r\ndev_dbg(sfb->dev, "%s: win %d: %d => rgb=%d/%d/%d\n",\r\n__func__, win->index, regno, red, green, blue);\r\npm_runtime_get_sync(sfb->dev);\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = info->pseudo_palette;\r\nval = chan_to_field(red, &info->var.red);\r\nval |= chan_to_field(green, &info->var.green);\r\nval |= chan_to_field(blue, &info->var.blue);\r\npal[regno] = val;\r\n}\r\nbreak;\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nif (regno < win->variant.palette_sz) {\r\nval = chan_to_field(red, &win->palette.r);\r\nval |= chan_to_field(green, &win->palette.g);\r\nval |= chan_to_field(blue, &win->palette.b);\r\ns3c_fb_update_palette(sfb, win, regno, val);\r\n}\r\nbreak;\r\ndefault:\r\npm_runtime_put_sync(sfb->dev);\r\nreturn 1;\r\n}\r\npm_runtime_put_sync(sfb->dev);\r\nreturn 0;\r\n}\r\nstatic int s3c_fb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct s3c_fb_win *win = info->par;\r\nstruct s3c_fb *sfb = win->parent;\r\nunsigned int index = win->index;\r\nu32 wincon;\r\nu32 output_on = sfb->output_on;\r\ndev_dbg(sfb->dev, "blank mode %d\n", blank_mode);\r\npm_runtime_get_sync(sfb->dev);\r\nwincon = readl(sfb->regs + sfb->variant.wincon + (index * 4));\r\nswitch (blank_mode) {\r\ncase FB_BLANK_POWERDOWN:\r\nwincon &= ~WINCONx_ENWIN;\r\nsfb->enabled &= ~(1 << index);\r\ncase FB_BLANK_NORMAL:\r\nshadow_protect_win(win, 1);\r\nwritel(WINxMAP_MAP | WINxMAP_MAP_COLOUR(0x0),\r\nsfb->regs + sfb->variant.winmap + (index * 4));\r\nshadow_protect_win(win, 0);\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nshadow_protect_win(win, 1);\r\nwritel(0x0, sfb->regs + sfb->variant.winmap + (index * 4));\r\nshadow_protect_win(win, 0);\r\nwincon |= WINCONx_ENWIN;\r\nsfb->enabled |= (1 << index);\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ndefault:\r\npm_runtime_put_sync(sfb->dev);\r\nreturn 1;\r\n}\r\nshadow_protect_win(win, 1);\r\nwritel(wincon, sfb->regs + sfb->variant.wincon + (index * 4));\r\ns3c_fb_enable(sfb, sfb->enabled ? 1 : 0);\r\nshadow_protect_win(win, 0);\r\npm_runtime_put_sync(sfb->dev);\r\nreturn output_on == sfb->output_on;\r\n}\r\nstatic int s3c_fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct s3c_fb_win *win = info->par;\r\nstruct s3c_fb *sfb = win->parent;\r\nvoid __iomem *buf = sfb->regs + win->index * 8;\r\nunsigned int start_boff, end_boff;\r\npm_runtime_get_sync(sfb->dev);\r\nstart_boff = var->yoffset * info->fix.line_length;\r\nif (info->var.bits_per_pixel >= 8) {\r\nstart_boff += var->xoffset * (info->var.bits_per_pixel >> 3);\r\n} else {\r\nswitch (info->var.bits_per_pixel) {\r\ncase 4:\r\nstart_boff += var->xoffset >> 1;\r\nbreak;\r\ncase 2:\r\nstart_boff += var->xoffset >> 2;\r\nbreak;\r\ncase 1:\r\nstart_boff += var->xoffset >> 3;\r\nbreak;\r\ndefault:\r\ndev_err(sfb->dev, "invalid bpp\n");\r\npm_runtime_put_sync(sfb->dev);\r\nreturn -EINVAL;\r\n}\r\n}\r\nend_boff = start_boff + info->var.yres * info->fix.line_length;\r\nshadow_protect_win(win, 1);\r\nwritel(info->fix.smem_start + start_boff, buf + sfb->variant.buf_start);\r\nwritel(info->fix.smem_start + end_boff, buf + sfb->variant.buf_end);\r\nshadow_protect_win(win, 0);\r\npm_runtime_put_sync(sfb->dev);\r\nreturn 0;\r\n}\r\nstatic void s3c_fb_enable_irq(struct s3c_fb *sfb)\r\n{\r\nvoid __iomem *regs = sfb->regs;\r\nu32 irq_ctrl_reg;\r\nif (!test_and_set_bit(S3C_FB_VSYNC_IRQ_EN, &sfb->irq_flags)) {\r\nirq_ctrl_reg = readl(regs + VIDINTCON0);\r\nirq_ctrl_reg |= VIDINTCON0_INT_ENABLE;\r\nirq_ctrl_reg |= VIDINTCON0_INT_FRAME;\r\nirq_ctrl_reg &= ~VIDINTCON0_FRAMESEL0_MASK;\r\nirq_ctrl_reg |= VIDINTCON0_FRAMESEL0_VSYNC;\r\nirq_ctrl_reg &= ~VIDINTCON0_FRAMESEL1_MASK;\r\nirq_ctrl_reg |= VIDINTCON0_FRAMESEL1_NONE;\r\nwritel(irq_ctrl_reg, regs + VIDINTCON0);\r\n}\r\n}\r\nstatic void s3c_fb_disable_irq(struct s3c_fb *sfb)\r\n{\r\nvoid __iomem *regs = sfb->regs;\r\nu32 irq_ctrl_reg;\r\nif (test_and_clear_bit(S3C_FB_VSYNC_IRQ_EN, &sfb->irq_flags)) {\r\nirq_ctrl_reg = readl(regs + VIDINTCON0);\r\nirq_ctrl_reg &= ~VIDINTCON0_INT_FRAME;\r\nirq_ctrl_reg &= ~VIDINTCON0_INT_ENABLE;\r\nwritel(irq_ctrl_reg, regs + VIDINTCON0);\r\n}\r\n}\r\nstatic irqreturn_t s3c_fb_irq(int irq, void *dev_id)\r\n{\r\nstruct s3c_fb *sfb = dev_id;\r\nvoid __iomem *regs = sfb->regs;\r\nu32 irq_sts_reg;\r\nspin_lock(&sfb->slock);\r\nirq_sts_reg = readl(regs + VIDINTCON1);\r\nif (irq_sts_reg & VIDINTCON1_INT_FRAME) {\r\nwritel(VIDINTCON1_INT_FRAME, regs + VIDINTCON1);\r\nsfb->vsync_info.count++;\r\nwake_up_interruptible(&sfb->vsync_info.wait);\r\n}\r\ns3c_fb_disable_irq(sfb);\r\nspin_unlock(&sfb->slock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c_fb_wait_for_vsync(struct s3c_fb *sfb, u32 crtc)\r\n{\r\nunsigned long count;\r\nint ret;\r\nif (crtc != 0)\r\nreturn -ENODEV;\r\npm_runtime_get_sync(sfb->dev);\r\ncount = sfb->vsync_info.count;\r\ns3c_fb_enable_irq(sfb);\r\nret = wait_event_interruptible_timeout(sfb->vsync_info.wait,\r\ncount != sfb->vsync_info.count,\r\nmsecs_to_jiffies(VSYNC_TIMEOUT_MSEC));\r\npm_runtime_put_sync(sfb->dev);\r\nif (ret == 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int s3c_fb_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct s3c_fb_win *win = info->par;\r\nstruct s3c_fb *sfb = win->parent;\r\nint ret;\r\nu32 crtc;\r\nswitch (cmd) {\r\ncase FBIO_WAITFORVSYNC:\r\nif (get_user(crtc, (u32 __user *)arg)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nret = s3c_fb_wait_for_vsync(sfb, crtc);\r\nbreak;\r\ndefault:\r\nret = -ENOTTY;\r\n}\r\nreturn ret;\r\n}\r\nstatic void s3c_fb_missing_pixclock(struct fb_videomode *mode)\r\n{\r\nu64 pixclk = 1000000000000ULL;\r\nu32 div;\r\ndiv = mode->left_margin + mode->hsync_len + mode->right_margin +\r\nmode->xres;\r\ndiv *= mode->upper_margin + mode->vsync_len + mode->lower_margin +\r\nmode->yres;\r\ndiv *= mode->refresh ? : 60;\r\ndo_div(pixclk, div);\r\nmode->pixclock = pixclk;\r\n}\r\nstatic int s3c_fb_alloc_memory(struct s3c_fb *sfb, struct s3c_fb_win *win)\r\n{\r\nstruct s3c_fb_pd_win *windata = win->windata;\r\nunsigned int real_size, virt_size, size;\r\nstruct fb_info *fbi = win->fbinfo;\r\ndma_addr_t map_dma;\r\ndev_dbg(sfb->dev, "allocating memory for display\n");\r\nreal_size = windata->xres * windata->yres;\r\nvirt_size = windata->virtual_x * windata->virtual_y;\r\ndev_dbg(sfb->dev, "real_size=%u (%u.%u), virt_size=%u (%u.%u)\n",\r\nreal_size, windata->xres, windata->yres,\r\nvirt_size, windata->virtual_x, windata->virtual_y);\r\nsize = (real_size > virt_size) ? real_size : virt_size;\r\nsize *= (windata->max_bpp > 16) ? 32 : windata->max_bpp;\r\nsize /= 8;\r\nfbi->fix.smem_len = size;\r\nsize = PAGE_ALIGN(size);\r\ndev_dbg(sfb->dev, "want %u bytes for window\n", size);\r\nfbi->screen_base = dma_alloc_writecombine(sfb->dev, size,\r\n&map_dma, GFP_KERNEL);\r\nif (!fbi->screen_base)\r\nreturn -ENOMEM;\r\ndev_dbg(sfb->dev, "mapped %x to %p\n",\r\n(unsigned int)map_dma, fbi->screen_base);\r\nmemset(fbi->screen_base, 0x0, size);\r\nfbi->fix.smem_start = map_dma;\r\nreturn 0;\r\n}\r\nstatic void s3c_fb_free_memory(struct s3c_fb *sfb, struct s3c_fb_win *win)\r\n{\r\nstruct fb_info *fbi = win->fbinfo;\r\nif (fbi->screen_base)\r\ndma_free_writecombine(sfb->dev, PAGE_ALIGN(fbi->fix.smem_len),\r\nfbi->screen_base, fbi->fix.smem_start);\r\n}\r\nstatic void s3c_fb_release_win(struct s3c_fb *sfb, struct s3c_fb_win *win)\r\n{\r\nu32 data;\r\nif (win->fbinfo) {\r\nif (sfb->variant.has_shadowcon) {\r\ndata = readl(sfb->regs + SHADOWCON);\r\ndata &= ~SHADOWCON_CHx_ENABLE(win->index);\r\ndata &= ~SHADOWCON_CHx_LOCAL_ENABLE(win->index);\r\nwritel(data, sfb->regs + SHADOWCON);\r\n}\r\nunregister_framebuffer(win->fbinfo);\r\nif (win->fbinfo->cmap.len)\r\nfb_dealloc_cmap(&win->fbinfo->cmap);\r\ns3c_fb_free_memory(sfb, win);\r\nframebuffer_release(win->fbinfo);\r\n}\r\n}\r\nstatic int s3c_fb_probe_win(struct s3c_fb *sfb, unsigned int win_no,\r\nstruct s3c_fb_win_variant *variant,\r\nstruct s3c_fb_win **res)\r\n{\r\nstruct fb_var_screeninfo *var;\r\nstruct fb_videomode initmode;\r\nstruct s3c_fb_pd_win *windata;\r\nstruct s3c_fb_win *win;\r\nstruct fb_info *fbinfo;\r\nint palette_size;\r\nint ret;\r\ndev_dbg(sfb->dev, "probing window %d, variant %p\n", win_no, variant);\r\ninit_waitqueue_head(&sfb->vsync_info.wait);\r\npalette_size = variant->palette_sz * 4;\r\nfbinfo = framebuffer_alloc(sizeof(struct s3c_fb_win) +\r\npalette_size * sizeof(u32), sfb->dev);\r\nif (!fbinfo) {\r\ndev_err(sfb->dev, "failed to allocate framebuffer\n");\r\nreturn -ENOENT;\r\n}\r\nwindata = sfb->pdata->win[win_no];\r\ninitmode = *sfb->pdata->vtiming;\r\nWARN_ON(windata->max_bpp == 0);\r\nWARN_ON(windata->xres == 0);\r\nWARN_ON(windata->yres == 0);\r\nwin = fbinfo->par;\r\n*res = win;\r\nvar = &fbinfo->var;\r\nwin->variant = *variant;\r\nwin->fbinfo = fbinfo;\r\nwin->parent = sfb;\r\nwin->windata = windata;\r\nwin->index = win_no;\r\nwin->palette_buffer = (u32 *)(win + 1);\r\nret = s3c_fb_alloc_memory(sfb, win);\r\nif (ret) {\r\ndev_err(sfb->dev, "failed to allocate display memory\n");\r\nreturn ret;\r\n}\r\nif (win->variant.palette_16bpp) {\r\nwin->palette.r.offset = 11;\r\nwin->palette.r.length = 5;\r\nwin->palette.g.offset = 5;\r\nwin->palette.g.length = 6;\r\nwin->palette.b.offset = 0;\r\nwin->palette.b.length = 5;\r\n} else {\r\nwin->palette.r.offset = 16;\r\nwin->palette.r.length = 8;\r\nwin->palette.g.offset = 8;\r\nwin->palette.g.length = 8;\r\nwin->palette.b.offset = 0;\r\nwin->palette.b.length = 8;\r\n}\r\ninitmode.xres = windata->xres;\r\ninitmode.yres = windata->yres;\r\nfb_videomode_to_var(&fbinfo->var, &initmode);\r\nfbinfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\nfbinfo->fix.accel = FB_ACCEL_NONE;\r\nfbinfo->var.activate = FB_ACTIVATE_NOW;\r\nfbinfo->var.vmode = FB_VMODE_NONINTERLACED;\r\nfbinfo->var.bits_per_pixel = windata->default_bpp;\r\nfbinfo->fbops = &s3c_fb_ops;\r\nfbinfo->flags = FBINFO_FLAG_DEFAULT;\r\nfbinfo->pseudo_palette = &win->pseudo_palette;\r\nret = s3c_fb_check_var(&fbinfo->var, fbinfo);\r\nif (ret < 0) {\r\ndev_err(sfb->dev, "check_var failed on initial video params\n");\r\nreturn ret;\r\n}\r\nret = fb_alloc_cmap(&fbinfo->cmap, win->variant.palette_sz, 1);\r\nif (ret == 0)\r\nfb_set_cmap(&fbinfo->cmap, fbinfo);\r\nelse\r\ndev_err(sfb->dev, "failed to allocate fb cmap\n");\r\ns3c_fb_set_par(fbinfo);\r\ndev_dbg(sfb->dev, "about to register framebuffer\n");\r\nret = register_framebuffer(fbinfo);\r\nif (ret < 0) {\r\ndev_err(sfb->dev, "failed to register framebuffer\n");\r\nreturn ret;\r\n}\r\ndev_info(sfb->dev, "window %d: fb %s\n", win_no, fbinfo->fix.id);\r\nreturn 0;\r\n}\r\nstatic void s3c_fb_set_rgb_timing(struct s3c_fb *sfb)\r\n{\r\nstruct fb_videomode *vmode = sfb->pdata->vtiming;\r\nvoid __iomem *regs = sfb->regs;\r\nint clkdiv;\r\nu32 data;\r\nif (!vmode->pixclock)\r\ns3c_fb_missing_pixclock(vmode);\r\nclkdiv = s3c_fb_calc_pixclk(sfb, vmode->pixclock);\r\ndata = sfb->pdata->vidcon0;\r\ndata &= ~(VIDCON0_CLKVAL_F_MASK | VIDCON0_CLKDIR);\r\nif (clkdiv > 1)\r\ndata |= VIDCON0_CLKVAL_F(clkdiv-1) | VIDCON0_CLKDIR;\r\nelse\r\ndata &= ~VIDCON0_CLKDIR;\r\nif (sfb->variant.is_2443)\r\ndata |= (1 << 5);\r\nwritel(data, regs + VIDCON0);\r\ndata = VIDTCON0_VBPD(vmode->upper_margin - 1) |\r\nVIDTCON0_VFPD(vmode->lower_margin - 1) |\r\nVIDTCON0_VSPW(vmode->vsync_len - 1);\r\nwritel(data, regs + sfb->variant.vidtcon);\r\ndata = VIDTCON1_HBPD(vmode->left_margin - 1) |\r\nVIDTCON1_HFPD(vmode->right_margin - 1) |\r\nVIDTCON1_HSPW(vmode->hsync_len - 1);\r\nwritel(data, regs + sfb->variant.vidtcon + 4);\r\ndata = VIDTCON2_LINEVAL(vmode->yres - 1) |\r\nVIDTCON2_HOZVAL(vmode->xres - 1) |\r\nVIDTCON2_LINEVAL_E(vmode->yres - 1) |\r\nVIDTCON2_HOZVAL_E(vmode->xres - 1);\r\nwritel(data, regs + sfb->variant.vidtcon + 8);\r\n}\r\nstatic void s3c_fb_clear_win(struct s3c_fb *sfb, int win)\r\n{\r\nvoid __iomem *regs = sfb->regs;\r\nu32 reg;\r\nwritel(0, regs + sfb->variant.wincon + (win * 4));\r\nwritel(0, regs + VIDOSD_A(win, sfb->variant));\r\nwritel(0, regs + VIDOSD_B(win, sfb->variant));\r\nwritel(0, regs + VIDOSD_C(win, sfb->variant));\r\nif (sfb->variant.has_shadowcon) {\r\nreg = readl(sfb->regs + SHADOWCON);\r\nreg &= ~(SHADOWCON_WINx_PROTECT(win) |\r\nSHADOWCON_CHx_ENABLE(win) |\r\nSHADOWCON_CHx_LOCAL_ENABLE(win));\r\nwritel(reg, sfb->regs + SHADOWCON);\r\n}\r\n}\r\nstatic int s3c_fb_probe(struct platform_device *pdev)\r\n{\r\nconst struct platform_device_id *platid;\r\nstruct s3c_fb_driverdata *fbdrv;\r\nstruct device *dev = &pdev->dev;\r\nstruct s3c_fb_platdata *pd;\r\nstruct s3c_fb *sfb;\r\nstruct resource *res;\r\nint win;\r\nint ret = 0;\r\nu32 reg;\r\nplatid = platform_get_device_id(pdev);\r\nfbdrv = (struct s3c_fb_driverdata *)platid->driver_data;\r\nif (fbdrv->variant.nr_windows > S3C_FB_MAX_WIN) {\r\ndev_err(dev, "too many windows, cannot attach\n");\r\nreturn -EINVAL;\r\n}\r\npd = dev_get_platdata(&pdev->dev);\r\nif (!pd) {\r\ndev_err(dev, "no platform data specified\n");\r\nreturn -EINVAL;\r\n}\r\nsfb = devm_kzalloc(dev, sizeof(struct s3c_fb), GFP_KERNEL);\r\nif (!sfb) {\r\ndev_err(dev, "no memory for framebuffers\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(dev, "allocate new framebuffer %p\n", sfb);\r\nsfb->dev = dev;\r\nsfb->pdata = pd;\r\nsfb->variant = fbdrv->variant;\r\nspin_lock_init(&sfb->slock);\r\nsfb->bus_clk = devm_clk_get(dev, "lcd");\r\nif (IS_ERR(sfb->bus_clk)) {\r\ndev_err(dev, "failed to get bus clock\n");\r\nreturn PTR_ERR(sfb->bus_clk);\r\n}\r\nclk_prepare_enable(sfb->bus_clk);\r\nif (!sfb->variant.has_clksel) {\r\nsfb->lcd_clk = devm_clk_get(dev, "sclk_fimd");\r\nif (IS_ERR(sfb->lcd_clk)) {\r\ndev_err(dev, "failed to get lcd clock\n");\r\nret = PTR_ERR(sfb->lcd_clk);\r\ngoto err_bus_clk;\r\n}\r\nclk_prepare_enable(sfb->lcd_clk);\r\n}\r\npm_runtime_enable(sfb->dev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nsfb->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(sfb->regs)) {\r\nret = PTR_ERR(sfb->regs);\r\ngoto err_lcd_clk;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(dev, "failed to acquire irq resource\n");\r\nret = -ENOENT;\r\ngoto err_lcd_clk;\r\n}\r\nsfb->irq_no = res->start;\r\nret = devm_request_irq(dev, sfb->irq_no, s3c_fb_irq,\r\n0, "s3c_fb", sfb);\r\nif (ret) {\r\ndev_err(dev, "irq request failed\n");\r\ngoto err_lcd_clk;\r\n}\r\ndev_dbg(dev, "got resources (regs %p), probing windows\n", sfb->regs);\r\nplatform_set_drvdata(pdev, sfb);\r\npm_runtime_get_sync(sfb->dev);\r\npd->setup_gpio();\r\nwritel(pd->vidcon1, sfb->regs + VIDCON1);\r\nif (sfb->variant.has_fixvclk) {\r\nreg = readl(sfb->regs + VIDCON1);\r\nreg &= ~VIDCON1_VCLK_MASK;\r\nreg |= VIDCON1_VCLK_RUN;\r\nwritel(reg, sfb->regs + VIDCON1);\r\n}\r\nfor (win = 0; win < fbdrv->variant.nr_windows; win++)\r\ns3c_fb_clear_win(sfb, win);\r\nfor (win = 0; win < (fbdrv->variant.nr_windows - 1); win++) {\r\nvoid __iomem *regs = sfb->regs + sfb->variant.keycon;\r\nregs += (win * 8);\r\nwritel(0xffffff, regs + WKEYCON0);\r\nwritel(0xffffff, regs + WKEYCON1);\r\n}\r\ns3c_fb_set_rgb_timing(sfb);\r\nfor (win = 0; win < fbdrv->variant.nr_windows; win++) {\r\nif (!pd->win[win])\r\ncontinue;\r\nret = s3c_fb_probe_win(sfb, win, fbdrv->win[win],\r\n&sfb->windows[win]);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to create window %d\n", win);\r\nfor (; win >= 0; win--)\r\ns3c_fb_release_win(sfb, sfb->windows[win]);\r\ngoto err_pm_runtime;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, sfb);\r\npm_runtime_put_sync(sfb->dev);\r\nreturn 0;\r\nerr_pm_runtime:\r\npm_runtime_put_sync(sfb->dev);\r\nerr_lcd_clk:\r\npm_runtime_disable(sfb->dev);\r\nif (!sfb->variant.has_clksel)\r\nclk_disable_unprepare(sfb->lcd_clk);\r\nerr_bus_clk:\r\nclk_disable_unprepare(sfb->bus_clk);\r\nreturn ret;\r\n}\r\nstatic int s3c_fb_remove(struct platform_device *pdev)\r\n{\r\nstruct s3c_fb *sfb = platform_get_drvdata(pdev);\r\nint win;\r\npm_runtime_get_sync(sfb->dev);\r\nfor (win = 0; win < S3C_FB_MAX_WIN; win++)\r\nif (sfb->windows[win])\r\ns3c_fb_release_win(sfb, sfb->windows[win]);\r\nif (!sfb->variant.has_clksel)\r\nclk_disable_unprepare(sfb->lcd_clk);\r\nclk_disable_unprepare(sfb->bus_clk);\r\npm_runtime_put_sync(sfb->dev);\r\npm_runtime_disable(sfb->dev);\r\nreturn 0;\r\n}\r\nstatic int s3c_fb_suspend(struct device *dev)\r\n{\r\nstruct s3c_fb *sfb = dev_get_drvdata(dev);\r\nstruct s3c_fb_win *win;\r\nint win_no;\r\npm_runtime_get_sync(sfb->dev);\r\nfor (win_no = S3C_FB_MAX_WIN - 1; win_no >= 0; win_no--) {\r\nwin = sfb->windows[win_no];\r\nif (!win)\r\ncontinue;\r\ns3c_fb_blank(FB_BLANK_POWERDOWN, win->fbinfo);\r\n}\r\nif (!sfb->variant.has_clksel)\r\nclk_disable_unprepare(sfb->lcd_clk);\r\nclk_disable_unprepare(sfb->bus_clk);\r\npm_runtime_put_sync(sfb->dev);\r\nreturn 0;\r\n}\r\nstatic int s3c_fb_resume(struct device *dev)\r\n{\r\nstruct s3c_fb *sfb = dev_get_drvdata(dev);\r\nstruct s3c_fb_platdata *pd = sfb->pdata;\r\nstruct s3c_fb_win *win;\r\nint win_no;\r\nu32 reg;\r\npm_runtime_get_sync(sfb->dev);\r\nclk_prepare_enable(sfb->bus_clk);\r\nif (!sfb->variant.has_clksel)\r\nclk_prepare_enable(sfb->lcd_clk);\r\npd->setup_gpio();\r\nwritel(pd->vidcon1, sfb->regs + VIDCON1);\r\nif (sfb->variant.has_fixvclk) {\r\nreg = readl(sfb->regs + VIDCON1);\r\nreg &= ~VIDCON1_VCLK_MASK;\r\nreg |= VIDCON1_VCLK_RUN;\r\nwritel(reg, sfb->regs + VIDCON1);\r\n}\r\nfor (win_no = 0; win_no < sfb->variant.nr_windows; win_no++)\r\ns3c_fb_clear_win(sfb, win_no);\r\nfor (win_no = 0; win_no < sfb->variant.nr_windows - 1; win_no++) {\r\nvoid __iomem *regs = sfb->regs + sfb->variant.keycon;\r\nwin = sfb->windows[win_no];\r\nif (!win)\r\ncontinue;\r\nshadow_protect_win(win, 1);\r\nregs += (win_no * 8);\r\nwritel(0xffffff, regs + WKEYCON0);\r\nwritel(0xffffff, regs + WKEYCON1);\r\nshadow_protect_win(win, 0);\r\n}\r\ns3c_fb_set_rgb_timing(sfb);\r\nfor (win_no = 0; win_no < S3C_FB_MAX_WIN; win_no++) {\r\nwin = sfb->windows[win_no];\r\nif (!win)\r\ncontinue;\r\ndev_dbg(dev, "resuming window %d\n", win_no);\r\ns3c_fb_set_par(win->fbinfo);\r\n}\r\npm_runtime_put_sync(sfb->dev);\r\nreturn 0;\r\n}\r\nstatic int s3c_fb_runtime_suspend(struct device *dev)\r\n{\r\nstruct s3c_fb *sfb = dev_get_drvdata(dev);\r\nif (!sfb->variant.has_clksel)\r\nclk_disable_unprepare(sfb->lcd_clk);\r\nclk_disable_unprepare(sfb->bus_clk);\r\nreturn 0;\r\n}\r\nstatic int s3c_fb_runtime_resume(struct device *dev)\r\n{\r\nstruct s3c_fb *sfb = dev_get_drvdata(dev);\r\nstruct s3c_fb_platdata *pd = sfb->pdata;\r\nclk_prepare_enable(sfb->bus_clk);\r\nif (!sfb->variant.has_clksel)\r\nclk_prepare_enable(sfb->lcd_clk);\r\npd->setup_gpio();\r\nwritel(pd->vidcon1, sfb->regs + VIDCON1);\r\nreturn 0;\r\n}
