static inline void rfbi_write_reg(const struct rfbi_reg idx, u32 val)\r\n{\r\n__raw_writel(val, rfbi.base + idx.idx);\r\n}\r\nstatic inline u32 rfbi_read_reg(const struct rfbi_reg idx)\r\n{\r\nreturn __raw_readl(rfbi.base + idx.idx);\r\n}\r\nstatic int rfbi_runtime_get(void)\r\n{\r\nint r;\r\nDSSDBG("rfbi_runtime_get\n");\r\nr = pm_runtime_get_sync(&rfbi.pdev->dev);\r\nWARN_ON(r < 0);\r\nreturn r < 0 ? r : 0;\r\n}\r\nstatic void rfbi_runtime_put(void)\r\n{\r\nint r;\r\nDSSDBG("rfbi_runtime_put\n");\r\nr = pm_runtime_put_sync(&rfbi.pdev->dev);\r\nWARN_ON(r < 0 && r != -ENOSYS);\r\n}\r\nstatic void rfbi_bus_lock(void)\r\n{\r\ndown(&rfbi.bus_lock);\r\n}\r\nstatic void rfbi_bus_unlock(void)\r\n{\r\nup(&rfbi.bus_lock);\r\n}\r\nstatic void rfbi_write_command(const void *buf, u32 len)\r\n{\r\nswitch (rfbi.parallelmode) {\r\ncase OMAP_DSS_RFBI_PARALLELMODE_8:\r\n{\r\nconst u8 *b = buf;\r\nfor (; len; len--)\r\nrfbi_write_reg(RFBI_CMD, *b++);\r\nbreak;\r\n}\r\ncase OMAP_DSS_RFBI_PARALLELMODE_16:\r\n{\r\nconst u16 *w = buf;\r\nBUG_ON(len & 1);\r\nfor (; len; len -= 2)\r\nrfbi_write_reg(RFBI_CMD, *w++);\r\nbreak;\r\n}\r\ncase OMAP_DSS_RFBI_PARALLELMODE_9:\r\ncase OMAP_DSS_RFBI_PARALLELMODE_12:\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void rfbi_read_data(void *buf, u32 len)\r\n{\r\nswitch (rfbi.parallelmode) {\r\ncase OMAP_DSS_RFBI_PARALLELMODE_8:\r\n{\r\nu8 *b = buf;\r\nfor (; len; len--) {\r\nrfbi_write_reg(RFBI_READ, 0);\r\n*b++ = rfbi_read_reg(RFBI_READ);\r\n}\r\nbreak;\r\n}\r\ncase OMAP_DSS_RFBI_PARALLELMODE_16:\r\n{\r\nu16 *w = buf;\r\nBUG_ON(len & ~1);\r\nfor (; len; len -= 2) {\r\nrfbi_write_reg(RFBI_READ, 0);\r\n*w++ = rfbi_read_reg(RFBI_READ);\r\n}\r\nbreak;\r\n}\r\ncase OMAP_DSS_RFBI_PARALLELMODE_9:\r\ncase OMAP_DSS_RFBI_PARALLELMODE_12:\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void rfbi_write_data(const void *buf, u32 len)\r\n{\r\nswitch (rfbi.parallelmode) {\r\ncase OMAP_DSS_RFBI_PARALLELMODE_8:\r\n{\r\nconst u8 *b = buf;\r\nfor (; len; len--)\r\nrfbi_write_reg(RFBI_PARAM, *b++);\r\nbreak;\r\n}\r\ncase OMAP_DSS_RFBI_PARALLELMODE_16:\r\n{\r\nconst u16 *w = buf;\r\nBUG_ON(len & 1);\r\nfor (; len; len -= 2)\r\nrfbi_write_reg(RFBI_PARAM, *w++);\r\nbreak;\r\n}\r\ncase OMAP_DSS_RFBI_PARALLELMODE_9:\r\ncase OMAP_DSS_RFBI_PARALLELMODE_12:\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void rfbi_write_pixels(const void __iomem *buf, int scr_width,\r\nu16 x, u16 y,\r\nu16 w, u16 h)\r\n{\r\nint start_offset = scr_width * y + x;\r\nint horiz_offset = scr_width - w;\r\nint i;\r\nif (rfbi.datatype == OMAP_DSS_RFBI_DATATYPE_16 &&\r\nrfbi.parallelmode == OMAP_DSS_RFBI_PARALLELMODE_8) {\r\nconst u16 __iomem *pd = buf;\r\npd += start_offset;\r\nfor (; h; --h) {\r\nfor (i = 0; i < w; ++i) {\r\nconst u8 __iomem *b = (const u8 __iomem *)pd;\r\nrfbi_write_reg(RFBI_PARAM, __raw_readb(b+1));\r\nrfbi_write_reg(RFBI_PARAM, __raw_readb(b+0));\r\n++pd;\r\n}\r\npd += horiz_offset;\r\n}\r\n} else if (rfbi.datatype == OMAP_DSS_RFBI_DATATYPE_24 &&\r\nrfbi.parallelmode == OMAP_DSS_RFBI_PARALLELMODE_8) {\r\nconst u32 __iomem *pd = buf;\r\npd += start_offset;\r\nfor (; h; --h) {\r\nfor (i = 0; i < w; ++i) {\r\nconst u8 __iomem *b = (const u8 __iomem *)pd;\r\nrfbi_write_reg(RFBI_PARAM, __raw_readb(b+2));\r\nrfbi_write_reg(RFBI_PARAM, __raw_readb(b+1));\r\nrfbi_write_reg(RFBI_PARAM, __raw_readb(b+0));\r\n++pd;\r\n}\r\npd += horiz_offset;\r\n}\r\n} else if (rfbi.datatype == OMAP_DSS_RFBI_DATATYPE_16 &&\r\nrfbi.parallelmode == OMAP_DSS_RFBI_PARALLELMODE_16) {\r\nconst u16 __iomem *pd = buf;\r\npd += start_offset;\r\nfor (; h; --h) {\r\nfor (i = 0; i < w; ++i) {\r\nrfbi_write_reg(RFBI_PARAM, __raw_readw(pd));\r\n++pd;\r\n}\r\npd += horiz_offset;\r\n}\r\n} else {\r\nBUG();\r\n}\r\n}\r\nstatic int rfbi_transfer_area(struct omap_dss_device *dssdev,\r\nvoid (*callback)(void *data), void *data)\r\n{\r\nu32 l;\r\nint r;\r\nstruct omap_overlay_manager *mgr = rfbi.output.manager;\r\nu16 width = rfbi.timings.x_res;\r\nu16 height = rfbi.timings.y_res;\r\nBUG_ON(rfbi.framedone_callback != NULL);\r\nDSSDBG("rfbi_transfer_area %dx%d\n", width, height);\r\ndss_mgr_set_timings(mgr, &rfbi.timings);\r\nr = dss_mgr_enable(mgr);\r\nif (r)\r\nreturn r;\r\nrfbi.framedone_callback = callback;\r\nrfbi.framedone_callback_data = data;\r\nrfbi_write_reg(RFBI_PIXEL_CNT, width * height);\r\nl = rfbi_read_reg(RFBI_CONTROL);\r\nl = FLD_MOD(l, 1, 0, 0);\r\nif (!rfbi.te_enabled)\r\nl = FLD_MOD(l, 1, 4, 4);\r\nrfbi_write_reg(RFBI_CONTROL, l);\r\nreturn 0;\r\n}\r\nstatic void framedone_callback(void *data)\r\n{\r\nvoid (*callback)(void *data);\r\nDSSDBG("FRAMEDONE\n");\r\nREG_FLD_MOD(RFBI_CONTROL, 0, 0, 0);\r\ncallback = rfbi.framedone_callback;\r\nrfbi.framedone_callback = NULL;\r\nif (callback != NULL)\r\ncallback(rfbi.framedone_callback_data);\r\n}\r\nstatic void rfbi_print_timings(void)\r\n{\r\nu32 l;\r\nu32 time;\r\nl = rfbi_read_reg(RFBI_CONFIG(0));\r\ntime = 1000000000 / rfbi.l4_khz;\r\nif (l & (1 << 4))\r\ntime *= 2;\r\nDSSDBG("Tick time %u ps\n", time);\r\nl = rfbi_read_reg(RFBI_ONOFF_TIME(0));\r\nDSSDBG("CSONTIME %d, CSOFFTIME %d, WEONTIME %d, WEOFFTIME %d, "\r\n"REONTIME %d, REOFFTIME %d\n",\r\nl & 0x0f, (l >> 4) & 0x3f, (l >> 10) & 0x0f, (l >> 14) & 0x3f,\r\n(l >> 20) & 0x0f, (l >> 24) & 0x3f);\r\nl = rfbi_read_reg(RFBI_CYCLE_TIME(0));\r\nDSSDBG("WECYCLETIME %d, RECYCLETIME %d, CSPULSEWIDTH %d, "\r\n"ACCESSTIME %d\n",\r\n(l & 0x3f), (l >> 6) & 0x3f, (l >> 12) & 0x3f,\r\n(l >> 22) & 0x3f);\r\n}\r\nstatic void rfbi_print_timings(void) {}\r\nstatic inline unsigned long round_to_extif_ticks(unsigned long ps, int div)\r\n{\r\nint bus_tick = extif_clk_period * div;\r\nreturn (ps + bus_tick - 1) / bus_tick * bus_tick;\r\n}\r\nstatic int calc_reg_timing(struct rfbi_timings *t, int div)\r\n{\r\nt->clk_div = div;\r\nt->cs_on_time = round_to_extif_ticks(t->cs_on_time, div);\r\nt->we_on_time = round_to_extif_ticks(t->we_on_time, div);\r\nt->we_off_time = round_to_extif_ticks(t->we_off_time, div);\r\nt->we_cycle_time = round_to_extif_ticks(t->we_cycle_time, div);\r\nt->re_on_time = round_to_extif_ticks(t->re_on_time, div);\r\nt->re_off_time = round_to_extif_ticks(t->re_off_time, div);\r\nt->re_cycle_time = round_to_extif_ticks(t->re_cycle_time, div);\r\nt->access_time = round_to_extif_ticks(t->access_time, div);\r\nt->cs_off_time = round_to_extif_ticks(t->cs_off_time, div);\r\nt->cs_pulse_width = round_to_extif_ticks(t->cs_pulse_width, div);\r\nDSSDBG("[reg]cson %d csoff %d reon %d reoff %d\n",\r\nt->cs_on_time, t->cs_off_time, t->re_on_time, t->re_off_time);\r\nDSSDBG("[reg]weon %d weoff %d recyc %d wecyc %d\n",\r\nt->we_on_time, t->we_off_time, t->re_cycle_time,\r\nt->we_cycle_time);\r\nDSSDBG("[reg]rdaccess %d cspulse %d\n",\r\nt->access_time, t->cs_pulse_width);\r\nreturn rfbi_convert_timings(t);\r\n}\r\nstatic int calc_extif_timings(struct rfbi_timings *t)\r\n{\r\nu32 max_clk_div;\r\nint div;\r\nrfbi_get_clk_info(&extif_clk_period, &max_clk_div);\r\nfor (div = 1; div <= max_clk_div; div++) {\r\nif (calc_reg_timing(t, div) == 0)\r\nbreak;\r\n}\r\nif (div <= max_clk_div)\r\nreturn 0;\r\nDSSERR("can't setup timings\n");\r\nreturn -1;\r\n}\r\nstatic void rfbi_set_timings(int rfbi_module, struct rfbi_timings *t)\r\n{\r\nint r;\r\nif (!t->converted) {\r\nr = calc_extif_timings(t);\r\nif (r < 0)\r\nDSSERR("Failed to calc timings\n");\r\n}\r\nBUG_ON(!t->converted);\r\nrfbi_write_reg(RFBI_ONOFF_TIME(rfbi_module), t->tim[0]);\r\nrfbi_write_reg(RFBI_CYCLE_TIME(rfbi_module), t->tim[1]);\r\nREG_FLD_MOD(RFBI_CONFIG(rfbi_module),\r\n(t->tim[2] ? 1 : 0), 4, 4);\r\nrfbi_print_timings();\r\n}\r\nstatic int ps_to_rfbi_ticks(int time, int div)\r\n{\r\nunsigned long tick_ps;\r\nint ret;\r\ntick_ps = 1000000000 / (rfbi.l4_khz) * div;\r\nret = (time + tick_ps - 1) / tick_ps;\r\nreturn ret;\r\n}\r\nstatic void rfbi_get_clk_info(u32 *clk_period, u32 *max_clk_div)\r\n{\r\n*clk_period = 1000000000 / rfbi.l4_khz;\r\n*max_clk_div = 2;\r\n}\r\nstatic int rfbi_convert_timings(struct rfbi_timings *t)\r\n{\r\nu32 l;\r\nint reon, reoff, weon, weoff, cson, csoff, cs_pulse;\r\nint actim, recyc, wecyc;\r\nint div = t->clk_div;\r\nif (div <= 0 || div > 2)\r\nreturn -1;\r\nweon = ps_to_rfbi_ticks(t->we_on_time, div);\r\nweoff = ps_to_rfbi_ticks(t->we_off_time, div);\r\nif (weoff <= weon)\r\nweoff = weon + 1;\r\nif (weon > 0x0f)\r\nreturn -1;\r\nif (weoff > 0x3f)\r\nreturn -1;\r\nreon = ps_to_rfbi_ticks(t->re_on_time, div);\r\nreoff = ps_to_rfbi_ticks(t->re_off_time, div);\r\nif (reoff <= reon)\r\nreoff = reon + 1;\r\nif (reon > 0x0f)\r\nreturn -1;\r\nif (reoff > 0x3f)\r\nreturn -1;\r\ncson = ps_to_rfbi_ticks(t->cs_on_time, div);\r\ncsoff = ps_to_rfbi_ticks(t->cs_off_time, div);\r\nif (csoff <= cson)\r\ncsoff = cson + 1;\r\nif (csoff < max(weoff, reoff))\r\ncsoff = max(weoff, reoff);\r\nif (cson > 0x0f)\r\nreturn -1;\r\nif (csoff > 0x3f)\r\nreturn -1;\r\nl = cson;\r\nl |= csoff << 4;\r\nl |= weon << 10;\r\nl |= weoff << 14;\r\nl |= reon << 20;\r\nl |= reoff << 24;\r\nt->tim[0] = l;\r\nactim = ps_to_rfbi_ticks(t->access_time, div);\r\nif (actim <= reon)\r\nactim = reon + 1;\r\nif (actim > 0x3f)\r\nreturn -1;\r\nwecyc = ps_to_rfbi_ticks(t->we_cycle_time, div);\r\nif (wecyc < weoff)\r\nwecyc = weoff;\r\nif (wecyc > 0x3f)\r\nreturn -1;\r\nrecyc = ps_to_rfbi_ticks(t->re_cycle_time, div);\r\nif (recyc < reoff)\r\nrecyc = reoff;\r\nif (recyc > 0x3f)\r\nreturn -1;\r\ncs_pulse = ps_to_rfbi_ticks(t->cs_pulse_width, div);\r\nif (cs_pulse > 0x3f)\r\nreturn -1;\r\nl = wecyc;\r\nl |= recyc << 6;\r\nl |= cs_pulse << 12;\r\nl |= actim << 22;\r\nt->tim[1] = l;\r\nt->tim[2] = div - 1;\r\nt->converted = 1;\r\nreturn 0;\r\n}\r\nstatic int rfbi_setup_te(enum omap_rfbi_te_mode mode,\r\nunsigned hs_pulse_time, unsigned vs_pulse_time,\r\nint hs_pol_inv, int vs_pol_inv, int extif_div)\r\n{\r\nint hs, vs;\r\nint min;\r\nu32 l;\r\nhs = ps_to_rfbi_ticks(hs_pulse_time, 1);\r\nvs = ps_to_rfbi_ticks(vs_pulse_time, 1);\r\nif (hs < 2)\r\nreturn -EDOM;\r\nif (mode == OMAP_DSS_RFBI_TE_MODE_2)\r\nmin = 2;\r\nelse\r\nmin = 4;\r\nif (vs < min)\r\nreturn -EDOM;\r\nif (vs == hs)\r\nreturn -EINVAL;\r\nrfbi.te_mode = mode;\r\nDSSDBG("setup_te: mode %d hs %d vs %d hs_inv %d vs_inv %d\n",\r\nmode, hs, vs, hs_pol_inv, vs_pol_inv);\r\nrfbi_write_reg(RFBI_HSYNC_WIDTH, hs);\r\nrfbi_write_reg(RFBI_VSYNC_WIDTH, vs);\r\nl = rfbi_read_reg(RFBI_CONFIG(0));\r\nif (hs_pol_inv)\r\nl &= ~(1 << 21);\r\nelse\r\nl |= 1 << 21;\r\nif (vs_pol_inv)\r\nl &= ~(1 << 20);\r\nelse\r\nl |= 1 << 20;\r\nreturn 0;\r\n}\r\nstatic int rfbi_enable_te(bool enable, unsigned line)\r\n{\r\nu32 l;\r\nDSSDBG("te %d line %d mode %d\n", enable, line, rfbi.te_mode);\r\nif (line > (1 << 11) - 1)\r\nreturn -EINVAL;\r\nl = rfbi_read_reg(RFBI_CONFIG(0));\r\nl &= ~(0x3 << 2);\r\nif (enable) {\r\nrfbi.te_enabled = 1;\r\nl |= rfbi.te_mode << 2;\r\n} else\r\nrfbi.te_enabled = 0;\r\nrfbi_write_reg(RFBI_CONFIG(0), l);\r\nrfbi_write_reg(RFBI_LINE_NUMBER, line);\r\nreturn 0;\r\n}\r\nstatic int rfbi_configure_bus(int rfbi_module, int bpp, int lines)\r\n{\r\nu32 l;\r\nint cycle1 = 0, cycle2 = 0, cycle3 = 0;\r\nenum omap_rfbi_cycleformat cycleformat;\r\nenum omap_rfbi_datatype datatype;\r\nenum omap_rfbi_parallelmode parallelmode;\r\nswitch (bpp) {\r\ncase 12:\r\ndatatype = OMAP_DSS_RFBI_DATATYPE_12;\r\nbreak;\r\ncase 16:\r\ndatatype = OMAP_DSS_RFBI_DATATYPE_16;\r\nbreak;\r\ncase 18:\r\ndatatype = OMAP_DSS_RFBI_DATATYPE_18;\r\nbreak;\r\ncase 24:\r\ndatatype = OMAP_DSS_RFBI_DATATYPE_24;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 1;\r\n}\r\nrfbi.datatype = datatype;\r\nswitch (lines) {\r\ncase 8:\r\nparallelmode = OMAP_DSS_RFBI_PARALLELMODE_8;\r\nbreak;\r\ncase 9:\r\nparallelmode = OMAP_DSS_RFBI_PARALLELMODE_9;\r\nbreak;\r\ncase 12:\r\nparallelmode = OMAP_DSS_RFBI_PARALLELMODE_12;\r\nbreak;\r\ncase 16:\r\nparallelmode = OMAP_DSS_RFBI_PARALLELMODE_16;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 1;\r\n}\r\nrfbi.parallelmode = parallelmode;\r\nif ((bpp % lines) == 0) {\r\nswitch (bpp / lines) {\r\ncase 1:\r\ncycleformat = OMAP_DSS_RFBI_CYCLEFORMAT_1_1;\r\nbreak;\r\ncase 2:\r\ncycleformat = OMAP_DSS_RFBI_CYCLEFORMAT_2_1;\r\nbreak;\r\ncase 3:\r\ncycleformat = OMAP_DSS_RFBI_CYCLEFORMAT_3_1;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 1;\r\n}\r\n} else if ((2 * bpp % lines) == 0) {\r\nif ((2 * bpp / lines) == 3)\r\ncycleformat = OMAP_DSS_RFBI_CYCLEFORMAT_3_2;\r\nelse {\r\nBUG();\r\nreturn 1;\r\n}\r\n} else {\r\nBUG();\r\nreturn 1;\r\n}\r\nswitch (cycleformat) {\r\ncase OMAP_DSS_RFBI_CYCLEFORMAT_1_1:\r\ncycle1 = lines;\r\nbreak;\r\ncase OMAP_DSS_RFBI_CYCLEFORMAT_2_1:\r\ncycle1 = lines;\r\ncycle2 = lines;\r\nbreak;\r\ncase OMAP_DSS_RFBI_CYCLEFORMAT_3_1:\r\ncycle1 = lines;\r\ncycle2 = lines;\r\ncycle3 = lines;\r\nbreak;\r\ncase OMAP_DSS_RFBI_CYCLEFORMAT_3_2:\r\ncycle1 = lines;\r\ncycle2 = (lines / 2) | ((lines / 2) << 16);\r\ncycle3 = (lines << 16);\r\nbreak;\r\n}\r\nREG_FLD_MOD(RFBI_CONTROL, 0, 3, 2);\r\nl = 0;\r\nl |= FLD_VAL(parallelmode, 1, 0);\r\nl |= FLD_VAL(0, 3, 2);\r\nl |= FLD_VAL(0, 4, 4);\r\nl |= FLD_VAL(datatype, 6, 5);\r\nl |= FLD_VAL(0, 8, 7);\r\nl |= FLD_VAL(cycleformat, 10, 9);\r\nl |= FLD_VAL(0, 12, 11);\r\nl |= FLD_VAL(0, 16, 16);\r\nl |= FLD_VAL(0, 17, 17);\r\nl |= FLD_VAL(0, 18, 18);\r\nl |= FLD_VAL(0, 19, 19);\r\nl |= FLD_VAL(1, 20, 20);\r\nl |= FLD_VAL(1, 21, 21);\r\nrfbi_write_reg(RFBI_CONFIG(rfbi_module), l);\r\nrfbi_write_reg(RFBI_DATA_CYCLE1(rfbi_module), cycle1);\r\nrfbi_write_reg(RFBI_DATA_CYCLE2(rfbi_module), cycle2);\r\nrfbi_write_reg(RFBI_DATA_CYCLE3(rfbi_module), cycle3);\r\nl = rfbi_read_reg(RFBI_CONTROL);\r\nl = FLD_MOD(l, rfbi_module+1, 3, 2);\r\nl = FLD_MOD(l, 0, 1, 1);\r\nrfbi_write_reg(RFBI_CONTROL, l);\r\nDSSDBG("RFBI config: bpp %d, lines %d, cycles: 0x%x 0x%x 0x%x\n",\r\nbpp, lines, cycle1, cycle2, cycle3);\r\nreturn 0;\r\n}\r\nstatic int rfbi_configure(struct omap_dss_device *dssdev)\r\n{\r\nreturn rfbi_configure_bus(dssdev->phy.rfbi.channel, rfbi.pixel_size,\r\nrfbi.data_lines);\r\n}\r\nstatic int rfbi_update(struct omap_dss_device *dssdev, void (*callback)(void *),\r\nvoid *data)\r\n{\r\nreturn rfbi_transfer_area(dssdev, callback, data);\r\n}\r\nstatic void rfbi_set_size(struct omap_dss_device *dssdev, u16 w, u16 h)\r\n{\r\nrfbi.timings.x_res = w;\r\nrfbi.timings.y_res = h;\r\n}\r\nstatic void rfbi_set_pixel_size(struct omap_dss_device *dssdev, int pixel_size)\r\n{\r\nrfbi.pixel_size = pixel_size;\r\n}\r\nstatic void rfbi_set_data_lines(struct omap_dss_device *dssdev, int data_lines)\r\n{\r\nrfbi.data_lines = data_lines;\r\n}\r\nstatic void rfbi_set_interface_timings(struct omap_dss_device *dssdev,\r\nstruct rfbi_timings *timings)\r\n{\r\nrfbi.intf_timings = *timings;\r\n}\r\nstatic void rfbi_dump_regs(struct seq_file *s)\r\n{\r\n#define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, rfbi_read_reg(r))\r\nif (rfbi_runtime_get())\r\nreturn;\r\nDUMPREG(RFBI_REVISION);\r\nDUMPREG(RFBI_SYSCONFIG);\r\nDUMPREG(RFBI_SYSSTATUS);\r\nDUMPREG(RFBI_CONTROL);\r\nDUMPREG(RFBI_PIXEL_CNT);\r\nDUMPREG(RFBI_LINE_NUMBER);\r\nDUMPREG(RFBI_CMD);\r\nDUMPREG(RFBI_PARAM);\r\nDUMPREG(RFBI_DATA);\r\nDUMPREG(RFBI_READ);\r\nDUMPREG(RFBI_STATUS);\r\nDUMPREG(RFBI_CONFIG(0));\r\nDUMPREG(RFBI_ONOFF_TIME(0));\r\nDUMPREG(RFBI_CYCLE_TIME(0));\r\nDUMPREG(RFBI_DATA_CYCLE1(0));\r\nDUMPREG(RFBI_DATA_CYCLE2(0));\r\nDUMPREG(RFBI_DATA_CYCLE3(0));\r\nDUMPREG(RFBI_CONFIG(1));\r\nDUMPREG(RFBI_ONOFF_TIME(1));\r\nDUMPREG(RFBI_CYCLE_TIME(1));\r\nDUMPREG(RFBI_DATA_CYCLE1(1));\r\nDUMPREG(RFBI_DATA_CYCLE2(1));\r\nDUMPREG(RFBI_DATA_CYCLE3(1));\r\nDUMPREG(RFBI_VSYNC_WIDTH);\r\nDUMPREG(RFBI_HSYNC_WIDTH);\r\nrfbi_runtime_put();\r\n#undef DUMPREG\r\n}\r\nstatic void rfbi_config_lcd_manager(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_overlay_manager *mgr = rfbi.output.manager;\r\nstruct dss_lcd_mgr_config mgr_config;\r\nmgr_config.io_pad_mode = DSS_IO_PAD_MODE_RFBI;\r\nmgr_config.stallmode = true;\r\nmgr_config.fifohandcheck = false;\r\nmgr_config.video_port_width = rfbi.pixel_size;\r\nmgr_config.lcden_sig_polarity = 0;\r\ndss_mgr_set_lcd_config(mgr, &mgr_config);\r\nrfbi.timings.hsw = 1;\r\nrfbi.timings.hfp = 1;\r\nrfbi.timings.hbp = 1;\r\nrfbi.timings.vsw = 1;\r\nrfbi.timings.vfp = 0;\r\nrfbi.timings.vbp = 0;\r\nrfbi.timings.interlace = false;\r\nrfbi.timings.hsync_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\nrfbi.timings.vsync_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\nrfbi.timings.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;\r\nrfbi.timings.de_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\nrfbi.timings.sync_pclk_edge = OMAPDSS_DRIVE_SIG_OPPOSITE_EDGES;\r\ndss_mgr_set_timings(mgr, &rfbi.timings);\r\n}\r\nstatic int rfbi_display_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_dss_device *out = &rfbi.output;\r\nint r;\r\nif (out == NULL || out->manager == NULL) {\r\nDSSERR("failed to enable display: no output/manager\n");\r\nreturn -ENODEV;\r\n}\r\nr = rfbi_runtime_get();\r\nif (r)\r\nreturn r;\r\nr = dss_mgr_register_framedone_handler(out->manager,\r\nframedone_callback, NULL);\r\nif (r) {\r\nDSSERR("can't get FRAMEDONE irq\n");\r\ngoto err1;\r\n}\r\nrfbi_config_lcd_manager(dssdev);\r\nrfbi_configure_bus(dssdev->phy.rfbi.channel, rfbi.pixel_size,\r\nrfbi.data_lines);\r\nrfbi_set_timings(dssdev->phy.rfbi.channel, &rfbi.intf_timings);\r\nreturn 0;\r\nerr1:\r\nrfbi_runtime_put();\r\nreturn r;\r\n}\r\nstatic void rfbi_display_disable(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_dss_device *out = &rfbi.output;\r\ndss_mgr_unregister_framedone_handler(out->manager,\r\nframedone_callback, NULL);\r\nrfbi_runtime_put();\r\n}\r\nstatic int rfbi_init_display(struct omap_dss_device *dssdev)\r\n{\r\nrfbi.dssdev[dssdev->phy.rfbi.channel] = dssdev;\r\nreturn 0;\r\n}\r\nstatic void rfbi_init_output(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_device *out = &rfbi.output;\r\nout->dev = &pdev->dev;\r\nout->id = OMAP_DSS_OUTPUT_DBI;\r\nout->output_type = OMAP_DISPLAY_TYPE_DBI;\r\nout->name = "rfbi.0";\r\nout->dispc_channel = OMAP_DSS_CHANNEL_LCD;\r\nout->owner = THIS_MODULE;\r\nomapdss_register_output(out);\r\n}\r\nstatic void __exit rfbi_uninit_output(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_device *out = &rfbi.output;\r\nomapdss_unregister_output(out);\r\n}\r\nstatic int omap_rfbihw_probe(struct platform_device *pdev)\r\n{\r\nu32 rev;\r\nstruct resource *rfbi_mem;\r\nstruct clk *clk;\r\nint r;\r\nrfbi.pdev = pdev;\r\nsema_init(&rfbi.bus_lock, 1);\r\nrfbi_mem = platform_get_resource(rfbi.pdev, IORESOURCE_MEM, 0);\r\nif (!rfbi_mem) {\r\nDSSERR("can't get IORESOURCE_MEM RFBI\n");\r\nreturn -EINVAL;\r\n}\r\nrfbi.base = devm_ioremap(&pdev->dev, rfbi_mem->start,\r\nresource_size(rfbi_mem));\r\nif (!rfbi.base) {\r\nDSSERR("can't ioremap RFBI\n");\r\nreturn -ENOMEM;\r\n}\r\nclk = clk_get(&pdev->dev, "ick");\r\nif (IS_ERR(clk)) {\r\nDSSERR("can't get ick\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nrfbi.l4_khz = clk_get_rate(clk) / 1000;\r\nclk_put(clk);\r\npm_runtime_enable(&pdev->dev);\r\nr = rfbi_runtime_get();\r\nif (r)\r\ngoto err_runtime_get;\r\nmsleep(10);\r\nrev = rfbi_read_reg(RFBI_REVISION);\r\ndev_dbg(&pdev->dev, "OMAP RFBI rev %d.%d\n",\r\nFLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));\r\nrfbi_runtime_put();\r\ndss_debugfs_create_file("rfbi", rfbi_dump_regs);\r\nrfbi_init_output(pdev);\r\nreturn 0;\r\nerr_runtime_get:\r\npm_runtime_disable(&pdev->dev);\r\nreturn r;\r\n}\r\nstatic int __exit omap_rfbihw_remove(struct platform_device *pdev)\r\n{\r\nrfbi_uninit_output(pdev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int rfbi_runtime_suspend(struct device *dev)\r\n{\r\ndispc_runtime_put();\r\nreturn 0;\r\n}\r\nstatic int rfbi_runtime_resume(struct device *dev)\r\n{\r\nint r;\r\nr = dispc_runtime_get();\r\nif (r < 0)\r\nreturn r;\r\nreturn 0;\r\n}\r\nint __init rfbi_init_platform_driver(void)\r\n{\r\nreturn platform_driver_register(&omap_rfbihw_driver);\r\n}\r\nvoid __exit rfbi_uninit_platform_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_rfbihw_driver);\r\n}
