static int nandsim_debugfs_show(struct seq_file *m, void *private)\r\n{\r\nunsigned long wmin = -1, wmax = 0, avg;\r\nunsigned long deciles[10], decile_max[10], tot = 0;\r\nunsigned int i;\r\nfor (i = 0; i < wear_eb_count; ++i) {\r\nunsigned long wear = erase_block_wear[i];\r\nif (wear < wmin)\r\nwmin = wear;\r\nif (wear > wmax)\r\nwmax = wear;\r\ntot += wear;\r\n}\r\nfor (i = 0; i < 9; ++i) {\r\ndeciles[i] = 0;\r\ndecile_max[i] = (wmax * (i + 1) + 5) / 10;\r\n}\r\ndeciles[9] = 0;\r\ndecile_max[9] = wmax;\r\nfor (i = 0; i < wear_eb_count; ++i) {\r\nint d;\r\nunsigned long wear = erase_block_wear[i];\r\nfor (d = 0; d < 10; ++d)\r\nif (wear <= decile_max[d]) {\r\ndeciles[d] += 1;\r\nbreak;\r\n}\r\n}\r\navg = tot / wear_eb_count;\r\nseq_printf(m, "Total numbers of erases: %lu\n", tot);\r\nseq_printf(m, "Number of erase blocks: %u\n", wear_eb_count);\r\nseq_printf(m, "Average number of erases: %lu\n", avg);\r\nseq_printf(m, "Maximum number of erases: %lu\n", wmax);\r\nseq_printf(m, "Minimum number of erases: %lu\n", wmin);\r\nfor (i = 0; i < 10; ++i) {\r\nunsigned long from = (i ? decile_max[i - 1] + 1 : 0);\r\nif (from > decile_max[i])\r\ncontinue;\r\nseq_printf(m, "Number of ebs with erase counts from %lu to %lu : %lu\n",\r\nfrom,\r\ndecile_max[i],\r\ndeciles[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nandsim_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, nandsim_debugfs_show, inode->i_private);\r\n}\r\nstatic int nandsim_debugfs_create(struct nandsim *dev)\r\n{\r\nstruct nandsim_debug_info *dbg = &dev->dbg;\r\nstruct dentry *dent;\r\nint err;\r\nif (!IS_ENABLED(CONFIG_DEBUG_FS))\r\nreturn 0;\r\ndent = debugfs_create_dir("nandsim", NULL);\r\nif (IS_ERR_OR_NULL(dent)) {\r\nint err = dent ? -ENODEV : PTR_ERR(dent);\r\nNS_ERR("cannot create \"nandsim\" debugfs directory, err %d\n",\r\nerr);\r\nreturn err;\r\n}\r\ndbg->dfs_root = dent;\r\ndent = debugfs_create_file("wear_report", S_IRUSR,\r\ndbg->dfs_root, dev, &dfs_fops);\r\nif (IS_ERR_OR_NULL(dent))\r\ngoto out_remove;\r\ndbg->dfs_wear_report = dent;\r\nreturn 0;\r\nout_remove:\r\ndebugfs_remove_recursive(dbg->dfs_root);\r\nerr = dent ? PTR_ERR(dent) : -ENODEV;\r\nreturn err;\r\n}\r\nstatic void nandsim_debugfs_remove(struct nandsim *ns)\r\n{\r\nif (IS_ENABLED(CONFIG_DEBUG_FS))\r\ndebugfs_remove_recursive(ns->dbg.dfs_root);\r\n}\r\nstatic int alloc_device(struct nandsim *ns)\r\n{\r\nstruct file *cfile;\r\nint i, err;\r\nif (cache_file) {\r\ncfile = filp_open(cache_file, O_CREAT | O_RDWR | O_LARGEFILE, 0600);\r\nif (IS_ERR(cfile))\r\nreturn PTR_ERR(cfile);\r\nif (!cfile->f_op->read && !cfile->f_op->aio_read) {\r\nNS_ERR("alloc_device: cache file not readable\n");\r\nerr = -EINVAL;\r\ngoto err_close;\r\n}\r\nif (!cfile->f_op->write && !cfile->f_op->aio_write) {\r\nNS_ERR("alloc_device: cache file not writeable\n");\r\nerr = -EINVAL;\r\ngoto err_close;\r\n}\r\nns->pages_written = vzalloc(BITS_TO_LONGS(ns->geom.pgnum) *\r\nsizeof(unsigned long));\r\nif (!ns->pages_written) {\r\nNS_ERR("alloc_device: unable to allocate pages written array\n");\r\nerr = -ENOMEM;\r\ngoto err_close;\r\n}\r\nns->file_buf = kmalloc(ns->geom.pgszoob, GFP_KERNEL);\r\nif (!ns->file_buf) {\r\nNS_ERR("alloc_device: unable to allocate file buf\n");\r\nerr = -ENOMEM;\r\ngoto err_free;\r\n}\r\nns->cfile = cfile;\r\nreturn 0;\r\n}\r\nns->pages = vmalloc(ns->geom.pgnum * sizeof(union ns_mem));\r\nif (!ns->pages) {\r\nNS_ERR("alloc_device: unable to allocate page array\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < ns->geom.pgnum; i++) {\r\nns->pages[i].byte = NULL;\r\n}\r\nns->nand_pages_slab = kmem_cache_create("nandsim",\r\nns->geom.pgszoob, 0, 0, NULL);\r\nif (!ns->nand_pages_slab) {\r\nNS_ERR("cache_create: unable to create kmem_cache\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\nerr_free:\r\nvfree(ns->pages_written);\r\nerr_close:\r\nfilp_close(cfile, NULL);\r\nreturn err;\r\n}\r\nstatic void free_device(struct nandsim *ns)\r\n{\r\nint i;\r\nif (ns->cfile) {\r\nkfree(ns->file_buf);\r\nvfree(ns->pages_written);\r\nfilp_close(ns->cfile, NULL);\r\nreturn;\r\n}\r\nif (ns->pages) {\r\nfor (i = 0; i < ns->geom.pgnum; i++) {\r\nif (ns->pages[i].byte)\r\nkmem_cache_free(ns->nand_pages_slab,\r\nns->pages[i].byte);\r\n}\r\nkmem_cache_destroy(ns->nand_pages_slab);\r\nvfree(ns->pages);\r\n}\r\n}\r\nstatic char *get_partition_name(int i)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "NAND simulator partition %d", i);\r\n}\r\nstatic int init_nandsim(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct nandsim *ns = chip->priv;\r\nint i, ret = 0;\r\nuint64_t remains;\r\nuint64_t next_offset;\r\nif (NS_IS_INITIALIZED(ns)) {\r\nNS_ERR("init_nandsim: nandsim is already initialized\n");\r\nreturn -EIO;\r\n}\r\nchip->chip_delay = 0;\r\nns->busw = chip->options & NAND_BUSWIDTH_16 ? 16 : 8;\r\nns->geom.totsz = mtd->size;\r\nns->geom.pgsz = mtd->writesize;\r\nns->geom.oobsz = mtd->oobsize;\r\nns->geom.secsz = mtd->erasesize;\r\nns->geom.pgszoob = ns->geom.pgsz + ns->geom.oobsz;\r\nns->geom.pgnum = div_u64(ns->geom.totsz, ns->geom.pgsz);\r\nns->geom.totszoob = ns->geom.totsz + (uint64_t)ns->geom.pgnum * ns->geom.oobsz;\r\nns->geom.secshift = ffs(ns->geom.secsz) - 1;\r\nns->geom.pgshift = chip->page_shift;\r\nns->geom.pgsec = ns->geom.secsz / ns->geom.pgsz;\r\nns->geom.secszoob = ns->geom.secsz + ns->geom.oobsz * ns->geom.pgsec;\r\nns->options = 0;\r\nif (ns->geom.pgsz == 512) {\r\nns->options |= OPT_PAGE512;\r\nif (ns->busw == 8)\r\nns->options |= OPT_PAGE512_8BIT;\r\n} else if (ns->geom.pgsz == 2048) {\r\nns->options |= OPT_PAGE2048;\r\n} else if (ns->geom.pgsz == 4096) {\r\nns->options |= OPT_PAGE4096;\r\n} else {\r\nNS_ERR("init_nandsim: unknown page size %u\n", ns->geom.pgsz);\r\nreturn -EIO;\r\n}\r\nif (ns->options & OPT_SMALLPAGE) {\r\nif (ns->geom.totsz <= (32 << 20)) {\r\nns->geom.pgaddrbytes = 3;\r\nns->geom.secaddrbytes = 2;\r\n} else {\r\nns->geom.pgaddrbytes = 4;\r\nns->geom.secaddrbytes = 3;\r\n}\r\n} else {\r\nif (ns->geom.totsz <= (128 << 20)) {\r\nns->geom.pgaddrbytes = 4;\r\nns->geom.secaddrbytes = 2;\r\n} else {\r\nns->geom.pgaddrbytes = 5;\r\nns->geom.secaddrbytes = 3;\r\n}\r\n}\r\nif (parts_num > ARRAY_SIZE(ns->partitions)) {\r\nNS_ERR("too many partitions.\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nremains = ns->geom.totsz;\r\nnext_offset = 0;\r\nfor (i = 0; i < parts_num; ++i) {\r\nuint64_t part_sz = (uint64_t)parts[i] * ns->geom.secsz;\r\nif (!part_sz || part_sz > remains) {\r\nNS_ERR("bad partition size.\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nns->partitions[i].name = get_partition_name(i);\r\nns->partitions[i].offset = next_offset;\r\nns->partitions[i].size = part_sz;\r\nnext_offset += ns->partitions[i].size;\r\nremains -= ns->partitions[i].size;\r\n}\r\nns->nbparts = parts_num;\r\nif (remains) {\r\nif (parts_num + 1 > ARRAY_SIZE(ns->partitions)) {\r\nNS_ERR("too many partitions.\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nns->partitions[i].name = get_partition_name(i);\r\nns->partitions[i].offset = next_offset;\r\nns->partitions[i].size = remains;\r\nns->nbparts += 1;\r\n}\r\nif (ns->busw == 16)\r\nNS_WARN("16-bit flashes support wasn't tested\n");\r\nprintk("flash size: %llu MiB\n",\r\n(unsigned long long)ns->geom.totsz >> 20);\r\nprintk("page size: %u bytes\n", ns->geom.pgsz);\r\nprintk("OOB area size: %u bytes\n", ns->geom.oobsz);\r\nprintk("sector size: %u KiB\n", ns->geom.secsz >> 10);\r\nprintk("pages number: %u\n", ns->geom.pgnum);\r\nprintk("pages per sector: %u\n", ns->geom.pgsec);\r\nprintk("bus width: %u\n", ns->busw);\r\nprintk("bits in sector size: %u\n", ns->geom.secshift);\r\nprintk("bits in page size: %u\n", ns->geom.pgshift);\r\nprintk("bits in OOB size: %u\n", ffs(ns->geom.oobsz) - 1);\r\nprintk("flash size with OOB: %llu KiB\n",\r\n(unsigned long long)ns->geom.totszoob >> 10);\r\nprintk("page address bytes: %u\n", ns->geom.pgaddrbytes);\r\nprintk("sector address bytes: %u\n", ns->geom.secaddrbytes);\r\nprintk("options: %#x\n", ns->options);\r\nif ((ret = alloc_device(ns)) != 0)\r\ngoto error;\r\nns->buf.byte = kmalloc(ns->geom.pgszoob, GFP_KERNEL);\r\nif (!ns->buf.byte) {\r\nNS_ERR("init_nandsim: unable to allocate %u bytes for the internal buffer\n",\r\nns->geom.pgszoob);\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nmemset(ns->buf.byte, 0xFF, ns->geom.pgszoob);\r\nreturn 0;\r\nerror:\r\nfree_device(ns);\r\nreturn ret;\r\n}\r\nstatic void free_nandsim(struct nandsim *ns)\r\n{\r\nkfree(ns->buf.byte);\r\nfree_device(ns);\r\nreturn;\r\n}\r\nstatic int parse_badblocks(struct nandsim *ns, struct mtd_info *mtd)\r\n{\r\nchar *w;\r\nint zero_ok;\r\nunsigned int erase_block_no;\r\nloff_t offset;\r\nif (!badblocks)\r\nreturn 0;\r\nw = badblocks;\r\ndo {\r\nzero_ok = (*w == '0' ? 1 : 0);\r\nerase_block_no = simple_strtoul(w, &w, 0);\r\nif (!zero_ok && !erase_block_no) {\r\nNS_ERR("invalid badblocks.\n");\r\nreturn -EINVAL;\r\n}\r\noffset = erase_block_no * ns->geom.secsz;\r\nif (mtd_block_markbad(mtd, offset)) {\r\nNS_ERR("invalid badblocks.\n");\r\nreturn -EINVAL;\r\n}\r\nif (*w == ',')\r\nw += 1;\r\n} while (*w);\r\nreturn 0;\r\n}\r\nstatic int parse_weakblocks(void)\r\n{\r\nchar *w;\r\nint zero_ok;\r\nunsigned int erase_block_no;\r\nunsigned int max_erases;\r\nstruct weak_block *wb;\r\nif (!weakblocks)\r\nreturn 0;\r\nw = weakblocks;\r\ndo {\r\nzero_ok = (*w == '0' ? 1 : 0);\r\nerase_block_no = simple_strtoul(w, &w, 0);\r\nif (!zero_ok && !erase_block_no) {\r\nNS_ERR("invalid weakblocks.\n");\r\nreturn -EINVAL;\r\n}\r\nmax_erases = 3;\r\nif (*w == ':') {\r\nw += 1;\r\nmax_erases = simple_strtoul(w, &w, 0);\r\n}\r\nif (*w == ',')\r\nw += 1;\r\nwb = kzalloc(sizeof(*wb), GFP_KERNEL);\r\nif (!wb) {\r\nNS_ERR("unable to allocate memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nwb->erase_block_no = erase_block_no;\r\nwb->max_erases = max_erases;\r\nlist_add(&wb->list, &weak_blocks);\r\n} while (*w);\r\nreturn 0;\r\n}\r\nstatic int erase_error(unsigned int erase_block_no)\r\n{\r\nstruct weak_block *wb;\r\nlist_for_each_entry(wb, &weak_blocks, list)\r\nif (wb->erase_block_no == erase_block_no) {\r\nif (wb->erases_done >= wb->max_erases)\r\nreturn 1;\r\nwb->erases_done += 1;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_weakpages(void)\r\n{\r\nchar *w;\r\nint zero_ok;\r\nunsigned int page_no;\r\nunsigned int max_writes;\r\nstruct weak_page *wp;\r\nif (!weakpages)\r\nreturn 0;\r\nw = weakpages;\r\ndo {\r\nzero_ok = (*w == '0' ? 1 : 0);\r\npage_no = simple_strtoul(w, &w, 0);\r\nif (!zero_ok && !page_no) {\r\nNS_ERR("invalid weakpagess.\n");\r\nreturn -EINVAL;\r\n}\r\nmax_writes = 3;\r\nif (*w == ':') {\r\nw += 1;\r\nmax_writes = simple_strtoul(w, &w, 0);\r\n}\r\nif (*w == ',')\r\nw += 1;\r\nwp = kzalloc(sizeof(*wp), GFP_KERNEL);\r\nif (!wp) {\r\nNS_ERR("unable to allocate memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nwp->page_no = page_no;\r\nwp->max_writes = max_writes;\r\nlist_add(&wp->list, &weak_pages);\r\n} while (*w);\r\nreturn 0;\r\n}\r\nstatic int write_error(unsigned int page_no)\r\n{\r\nstruct weak_page *wp;\r\nlist_for_each_entry(wp, &weak_pages, list)\r\nif (wp->page_no == page_no) {\r\nif (wp->writes_done >= wp->max_writes)\r\nreturn 1;\r\nwp->writes_done += 1;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_gravepages(void)\r\n{\r\nchar *g;\r\nint zero_ok;\r\nunsigned int page_no;\r\nunsigned int max_reads;\r\nstruct grave_page *gp;\r\nif (!gravepages)\r\nreturn 0;\r\ng = gravepages;\r\ndo {\r\nzero_ok = (*g == '0' ? 1 : 0);\r\npage_no = simple_strtoul(g, &g, 0);\r\nif (!zero_ok && !page_no) {\r\nNS_ERR("invalid gravepagess.\n");\r\nreturn -EINVAL;\r\n}\r\nmax_reads = 3;\r\nif (*g == ':') {\r\ng += 1;\r\nmax_reads = simple_strtoul(g, &g, 0);\r\n}\r\nif (*g == ',')\r\ng += 1;\r\ngp = kzalloc(sizeof(*gp), GFP_KERNEL);\r\nif (!gp) {\r\nNS_ERR("unable to allocate memory.\n");\r\nreturn -ENOMEM;\r\n}\r\ngp->page_no = page_no;\r\ngp->max_reads = max_reads;\r\nlist_add(&gp->list, &grave_pages);\r\n} while (*g);\r\nreturn 0;\r\n}\r\nstatic int read_error(unsigned int page_no)\r\n{\r\nstruct grave_page *gp;\r\nlist_for_each_entry(gp, &grave_pages, list)\r\nif (gp->page_no == page_no) {\r\nif (gp->reads_done >= gp->max_reads)\r\nreturn 1;\r\ngp->reads_done += 1;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_lists(void)\r\n{\r\nstruct list_head *pos, *n;\r\nlist_for_each_safe(pos, n, &weak_blocks) {\r\nlist_del(pos);\r\nkfree(list_entry(pos, struct weak_block, list));\r\n}\r\nlist_for_each_safe(pos, n, &weak_pages) {\r\nlist_del(pos);\r\nkfree(list_entry(pos, struct weak_page, list));\r\n}\r\nlist_for_each_safe(pos, n, &grave_pages) {\r\nlist_del(pos);\r\nkfree(list_entry(pos, struct grave_page, list));\r\n}\r\nkfree(erase_block_wear);\r\n}\r\nstatic int setup_wear_reporting(struct mtd_info *mtd)\r\n{\r\nsize_t mem;\r\nwear_eb_count = div_u64(mtd->size, mtd->erasesize);\r\nmem = wear_eb_count * sizeof(unsigned long);\r\nif (mem / sizeof(unsigned long) != wear_eb_count) {\r\nNS_ERR("Too many erase blocks for wear reporting\n");\r\nreturn -ENOMEM;\r\n}\r\nerase_block_wear = kzalloc(mem, GFP_KERNEL);\r\nif (!erase_block_wear) {\r\nNS_ERR("Too many erase blocks for wear reporting\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void update_wear(unsigned int erase_block_no)\r\n{\r\nif (!erase_block_wear)\r\nreturn;\r\ntotal_wear += 1;\r\nif (total_wear == 0)\r\nNS_ERR("Erase counter total overflow\n");\r\nerase_block_wear[erase_block_no] += 1;\r\nif (erase_block_wear[erase_block_no] == 0)\r\nNS_ERR("Erase counter overflow for erase block %u\n", erase_block_no);\r\n}\r\nstatic char *get_state_name(uint32_t state)\r\n{\r\nswitch (NS_STATE(state)) {\r\ncase STATE_CMD_READ0:\r\nreturn "STATE_CMD_READ0";\r\ncase STATE_CMD_READ1:\r\nreturn "STATE_CMD_READ1";\r\ncase STATE_CMD_PAGEPROG:\r\nreturn "STATE_CMD_PAGEPROG";\r\ncase STATE_CMD_READOOB:\r\nreturn "STATE_CMD_READOOB";\r\ncase STATE_CMD_READSTART:\r\nreturn "STATE_CMD_READSTART";\r\ncase STATE_CMD_ERASE1:\r\nreturn "STATE_CMD_ERASE1";\r\ncase STATE_CMD_STATUS:\r\nreturn "STATE_CMD_STATUS";\r\ncase STATE_CMD_SEQIN:\r\nreturn "STATE_CMD_SEQIN";\r\ncase STATE_CMD_READID:\r\nreturn "STATE_CMD_READID";\r\ncase STATE_CMD_ERASE2:\r\nreturn "STATE_CMD_ERASE2";\r\ncase STATE_CMD_RESET:\r\nreturn "STATE_CMD_RESET";\r\ncase STATE_CMD_RNDOUT:\r\nreturn "STATE_CMD_RNDOUT";\r\ncase STATE_CMD_RNDOUTSTART:\r\nreturn "STATE_CMD_RNDOUTSTART";\r\ncase STATE_ADDR_PAGE:\r\nreturn "STATE_ADDR_PAGE";\r\ncase STATE_ADDR_SEC:\r\nreturn "STATE_ADDR_SEC";\r\ncase STATE_ADDR_ZERO:\r\nreturn "STATE_ADDR_ZERO";\r\ncase STATE_ADDR_COLUMN:\r\nreturn "STATE_ADDR_COLUMN";\r\ncase STATE_DATAIN:\r\nreturn "STATE_DATAIN";\r\ncase STATE_DATAOUT:\r\nreturn "STATE_DATAOUT";\r\ncase STATE_DATAOUT_ID:\r\nreturn "STATE_DATAOUT_ID";\r\ncase STATE_DATAOUT_STATUS:\r\nreturn "STATE_DATAOUT_STATUS";\r\ncase STATE_DATAOUT_STATUS_M:\r\nreturn "STATE_DATAOUT_STATUS_M";\r\ncase STATE_READY:\r\nreturn "STATE_READY";\r\ncase STATE_UNKNOWN:\r\nreturn "STATE_UNKNOWN";\r\n}\r\nNS_ERR("get_state_name: unknown state, BUG\n");\r\nreturn NULL;\r\n}\r\nstatic int check_command(int cmd)\r\n{\r\nswitch (cmd) {\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_READ1:\r\ncase NAND_CMD_READSTART:\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_READOOB:\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_STATUS:\r\ncase NAND_CMD_SEQIN:\r\ncase NAND_CMD_READID:\r\ncase NAND_CMD_ERASE2:\r\ncase NAND_CMD_RESET:\r\ncase NAND_CMD_RNDOUT:\r\ncase NAND_CMD_RNDOUTSTART:\r\nreturn 0;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic uint32_t get_state_by_command(unsigned command)\r\n{\r\nswitch (command) {\r\ncase NAND_CMD_READ0:\r\nreturn STATE_CMD_READ0;\r\ncase NAND_CMD_READ1:\r\nreturn STATE_CMD_READ1;\r\ncase NAND_CMD_PAGEPROG:\r\nreturn STATE_CMD_PAGEPROG;\r\ncase NAND_CMD_READSTART:\r\nreturn STATE_CMD_READSTART;\r\ncase NAND_CMD_READOOB:\r\nreturn STATE_CMD_READOOB;\r\ncase NAND_CMD_ERASE1:\r\nreturn STATE_CMD_ERASE1;\r\ncase NAND_CMD_STATUS:\r\nreturn STATE_CMD_STATUS;\r\ncase NAND_CMD_SEQIN:\r\nreturn STATE_CMD_SEQIN;\r\ncase NAND_CMD_READID:\r\nreturn STATE_CMD_READID;\r\ncase NAND_CMD_ERASE2:\r\nreturn STATE_CMD_ERASE2;\r\ncase NAND_CMD_RESET:\r\nreturn STATE_CMD_RESET;\r\ncase NAND_CMD_RNDOUT:\r\nreturn STATE_CMD_RNDOUT;\r\ncase NAND_CMD_RNDOUTSTART:\r\nreturn STATE_CMD_RNDOUTSTART;\r\n}\r\nNS_ERR("get_state_by_command: unknown command, BUG\n");\r\nreturn 0;\r\n}\r\nstatic inline void accept_addr_byte(struct nandsim *ns, u_char bt)\r\n{\r\nuint byte = (uint)bt;\r\nif (ns->regs.count < (ns->geom.pgaddrbytes - ns->geom.secaddrbytes))\r\nns->regs.column |= (byte << 8 * ns->regs.count);\r\nelse {\r\nns->regs.row |= (byte << 8 * (ns->regs.count -\r\nns->geom.pgaddrbytes +\r\nns->geom.secaddrbytes));\r\n}\r\nreturn;\r\n}\r\nstatic inline void switch_to_ready_state(struct nandsim *ns, u_char status)\r\n{\r\nNS_DBG("switch_to_ready_state: switch to %s state\n", get_state_name(STATE_READY));\r\nns->state = STATE_READY;\r\nns->nxstate = STATE_UNKNOWN;\r\nns->op = NULL;\r\nns->npstates = 0;\r\nns->stateidx = 0;\r\nns->regs.num = 0;\r\nns->regs.count = 0;\r\nns->regs.off = 0;\r\nns->regs.row = 0;\r\nns->regs.column = 0;\r\nns->regs.status = status;\r\n}\r\nstatic int find_operation(struct nandsim *ns, uint32_t flag)\r\n{\r\nint opsfound = 0;\r\nint i, j, idx = 0;\r\nfor (i = 0; i < NS_OPER_NUM; i++) {\r\nint found = 1;\r\nif (!(ns->options & ops[i].reqopts))\r\ncontinue;\r\nif (flag) {\r\nif (!(ops[i].states[ns->npstates] & STATE_ADDR_MASK))\r\ncontinue;\r\n} else {\r\nif (NS_STATE(ns->state) != NS_STATE(ops[i].states[ns->npstates]))\r\ncontinue;\r\n}\r\nfor (j = 0; j < ns->npstates; j++)\r\nif (NS_STATE(ops[i].states[j]) != NS_STATE(ns->pstates[j])\r\n&& (ns->options & ops[idx].reqopts)) {\r\nfound = 0;\r\nbreak;\r\n}\r\nif (found) {\r\nidx = i;\r\nopsfound += 1;\r\n}\r\n}\r\nif (opsfound == 1) {\r\nns->op = &ops[idx].states[0];\r\nif (flag) {\r\nns->stateidx = ns->npstates - 1;\r\n} else {\r\nns->stateidx = ns->npstates;\r\n}\r\nns->npstates = 0;\r\nns->state = ns->op[ns->stateidx];\r\nns->nxstate = ns->op[ns->stateidx + 1];\r\nNS_DBG("find_operation: operation found, index: %d, state: %s, nxstate %s\n",\r\nidx, get_state_name(ns->state), get_state_name(ns->nxstate));\r\nreturn 0;\r\n}\r\nif (opsfound == 0) {\r\nif (ns->npstates != 0) {\r\nNS_DBG("find_operation: no operation found, try again with state %s\n",\r\nget_state_name(ns->state));\r\nns->npstates = 0;\r\nreturn find_operation(ns, 0);\r\n}\r\nNS_DBG("find_operation: no operations found\n");\r\nswitch_to_ready_state(ns, NS_STATUS_FAILED(ns));\r\nreturn -2;\r\n}\r\nif (flag) {\r\nNS_DBG("find_operation: BUG, operation must be known if address is input\n");\r\nreturn -2;\r\n}\r\nNS_DBG("find_operation: there is still ambiguity\n");\r\nns->pstates[ns->npstates++] = ns->state;\r\nreturn -1;\r\n}\r\nstatic void put_pages(struct nandsim *ns)\r\n{\r\nint i;\r\nfor (i = 0; i < ns->held_cnt; i++)\r\npage_cache_release(ns->held_pages[i]);\r\n}\r\nstatic int get_pages(struct nandsim *ns, struct file *file, size_t count, loff_t pos)\r\n{\r\npgoff_t index, start_index, end_index;\r\nstruct page *page;\r\nstruct address_space *mapping = file->f_mapping;\r\nstart_index = pos >> PAGE_CACHE_SHIFT;\r\nend_index = (pos + count - 1) >> PAGE_CACHE_SHIFT;\r\nif (end_index - start_index + 1 > NS_MAX_HELD_PAGES)\r\nreturn -EINVAL;\r\nns->held_cnt = 0;\r\nfor (index = start_index; index <= end_index; index++) {\r\npage = find_get_page(mapping, index);\r\nif (page == NULL) {\r\npage = find_or_create_page(mapping, index, GFP_NOFS);\r\nif (page == NULL) {\r\nwrite_inode_now(mapping->host, 1);\r\npage = find_or_create_page(mapping, index, GFP_NOFS);\r\n}\r\nif (page == NULL) {\r\nput_pages(ns);\r\nreturn -ENOMEM;\r\n}\r\nunlock_page(page);\r\n}\r\nns->held_pages[ns->held_cnt++] = page;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_memalloc(void)\r\n{\r\nif (current->flags & PF_MEMALLOC)\r\nreturn 0;\r\ncurrent->flags |= PF_MEMALLOC;\r\nreturn 1;\r\n}\r\nstatic void clear_memalloc(int memalloc)\r\n{\r\nif (memalloc)\r\ncurrent->flags &= ~PF_MEMALLOC;\r\n}\r\nstatic ssize_t read_file(struct nandsim *ns, struct file *file, void *buf, size_t count, loff_t pos)\r\n{\r\nssize_t tx;\r\nint err, memalloc;\r\nerr = get_pages(ns, file, count, pos);\r\nif (err)\r\nreturn err;\r\nmemalloc = set_memalloc();\r\ntx = kernel_read(file, pos, buf, count);\r\nclear_memalloc(memalloc);\r\nput_pages(ns);\r\nreturn tx;\r\n}\r\nstatic ssize_t write_file(struct nandsim *ns, struct file *file, void *buf, size_t count, loff_t pos)\r\n{\r\nssize_t tx;\r\nint err, memalloc;\r\nerr = get_pages(ns, file, count, pos);\r\nif (err)\r\nreturn err;\r\nmemalloc = set_memalloc();\r\ntx = kernel_write(file, buf, count, pos);\r\nclear_memalloc(memalloc);\r\nput_pages(ns);\r\nreturn tx;\r\n}\r\nstatic inline union ns_mem *NS_GET_PAGE(struct nandsim *ns)\r\n{\r\nreturn &(ns->pages[ns->regs.row]);\r\n}\r\nstatic inline u_char *NS_PAGE_BYTE_OFF(struct nandsim *ns)\r\n{\r\nreturn NS_GET_PAGE(ns)->byte + ns->regs.column + ns->regs.off;\r\n}\r\nstatic int do_read_error(struct nandsim *ns, int num)\r\n{\r\nunsigned int page_no = ns->regs.row;\r\nif (read_error(page_no)) {\r\nprandom_bytes(ns->buf.byte, num);\r\nNS_WARN("simulating read error in page %u\n", page_no);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void do_bit_flips(struct nandsim *ns, int num)\r\n{\r\nif (bitflips && prandom_u32() < (1 << 22)) {\r\nint flips = 1;\r\nif (bitflips > 1)\r\nflips = (prandom_u32() % (int) bitflips) + 1;\r\nwhile (flips--) {\r\nint pos = prandom_u32() % (num * 8);\r\nns->buf.byte[pos / 8] ^= (1 << (pos % 8));\r\nNS_WARN("read_page: flipping bit %d in page %d "\r\n"reading from %d ecc: corrected=%u failed=%u\n",\r\npos, ns->regs.row, ns->regs.column + ns->regs.off,\r\nnsmtd->ecc_stats.corrected, nsmtd->ecc_stats.failed);\r\n}\r\n}\r\n}\r\nstatic void read_page(struct nandsim *ns, int num)\r\n{\r\nunion ns_mem *mypage;\r\nif (ns->cfile) {\r\nif (!test_bit(ns->regs.row, ns->pages_written)) {\r\nNS_DBG("read_page: page %d not written\n", ns->regs.row);\r\nmemset(ns->buf.byte, 0xFF, num);\r\n} else {\r\nloff_t pos;\r\nssize_t tx;\r\nNS_DBG("read_page: page %d written, reading from %d\n",\r\nns->regs.row, ns->regs.column + ns->regs.off);\r\nif (do_read_error(ns, num))\r\nreturn;\r\npos = (loff_t)NS_RAW_OFFSET(ns) + ns->regs.off;\r\ntx = read_file(ns, ns->cfile, ns->buf.byte, num, pos);\r\nif (tx != num) {\r\nNS_ERR("read_page: read error for page %d ret %ld\n", ns->regs.row, (long)tx);\r\nreturn;\r\n}\r\ndo_bit_flips(ns, num);\r\n}\r\nreturn;\r\n}\r\nmypage = NS_GET_PAGE(ns);\r\nif (mypage->byte == NULL) {\r\nNS_DBG("read_page: page %d not allocated\n", ns->regs.row);\r\nmemset(ns->buf.byte, 0xFF, num);\r\n} else {\r\nNS_DBG("read_page: page %d allocated, reading from %d\n",\r\nns->regs.row, ns->regs.column + ns->regs.off);\r\nif (do_read_error(ns, num))\r\nreturn;\r\nmemcpy(ns->buf.byte, NS_PAGE_BYTE_OFF(ns), num);\r\ndo_bit_flips(ns, num);\r\n}\r\n}\r\nstatic void erase_sector(struct nandsim *ns)\r\n{\r\nunion ns_mem *mypage;\r\nint i;\r\nif (ns->cfile) {\r\nfor (i = 0; i < ns->geom.pgsec; i++)\r\nif (__test_and_clear_bit(ns->regs.row + i,\r\nns->pages_written)) {\r\nNS_DBG("erase_sector: freeing page %d\n", ns->regs.row + i);\r\n}\r\nreturn;\r\n}\r\nmypage = NS_GET_PAGE(ns);\r\nfor (i = 0; i < ns->geom.pgsec; i++) {\r\nif (mypage->byte != NULL) {\r\nNS_DBG("erase_sector: freeing page %d\n", ns->regs.row+i);\r\nkmem_cache_free(ns->nand_pages_slab, mypage->byte);\r\nmypage->byte = NULL;\r\n}\r\nmypage++;\r\n}\r\n}\r\nstatic int prog_page(struct nandsim *ns, int num)\r\n{\r\nint i;\r\nunion ns_mem *mypage;\r\nu_char *pg_off;\r\nif (ns->cfile) {\r\nloff_t off;\r\nssize_t tx;\r\nint all;\r\nNS_DBG("prog_page: writing page %d\n", ns->regs.row);\r\npg_off = ns->file_buf + ns->regs.column + ns->regs.off;\r\noff = (loff_t)NS_RAW_OFFSET(ns) + ns->regs.off;\r\nif (!test_bit(ns->regs.row, ns->pages_written)) {\r\nall = 1;\r\nmemset(ns->file_buf, 0xff, ns->geom.pgszoob);\r\n} else {\r\nall = 0;\r\ntx = read_file(ns, ns->cfile, pg_off, num, off);\r\nif (tx != num) {\r\nNS_ERR("prog_page: read error for page %d ret %ld\n", ns->regs.row, (long)tx);\r\nreturn -1;\r\n}\r\n}\r\nfor (i = 0; i < num; i++)\r\npg_off[i] &= ns->buf.byte[i];\r\nif (all) {\r\nloff_t pos = (loff_t)ns->regs.row * ns->geom.pgszoob;\r\ntx = write_file(ns, ns->cfile, ns->file_buf, ns->geom.pgszoob, pos);\r\nif (tx != ns->geom.pgszoob) {\r\nNS_ERR("prog_page: write error for page %d ret %ld\n", ns->regs.row, (long)tx);\r\nreturn -1;\r\n}\r\n__set_bit(ns->regs.row, ns->pages_written);\r\n} else {\r\ntx = write_file(ns, ns->cfile, pg_off, num, off);\r\nif (tx != num) {\r\nNS_ERR("prog_page: write error for page %d ret %ld\n", ns->regs.row, (long)tx);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nmypage = NS_GET_PAGE(ns);\r\nif (mypage->byte == NULL) {\r\nNS_DBG("prog_page: allocating page %d\n", ns->regs.row);\r\nmypage->byte = kmem_cache_alloc(ns->nand_pages_slab, GFP_NOFS);\r\nif (mypage->byte == NULL) {\r\nNS_ERR("prog_page: error allocating memory for page %d\n", ns->regs.row);\r\nreturn -1;\r\n}\r\nmemset(mypage->byte, 0xFF, ns->geom.pgszoob);\r\n}\r\npg_off = NS_PAGE_BYTE_OFF(ns);\r\nfor (i = 0; i < num; i++)\r\npg_off[i] &= ns->buf.byte[i];\r\nreturn 0;\r\n}\r\nstatic int do_state_action(struct nandsim *ns, uint32_t action)\r\n{\r\nint num;\r\nint busdiv = ns->busw == 8 ? 1 : 2;\r\nunsigned int erase_block_no, page_no;\r\naction &= ACTION_MASK;\r\nif (action != ACTION_SECERASE && ns->regs.row >= ns->geom.pgnum) {\r\nNS_WARN("do_state_action: wrong page number (%#x)\n", ns->regs.row);\r\nreturn -1;\r\n}\r\nswitch (action) {\r\ncase ACTION_CPY:\r\nif (ns->regs.column >= (ns->geom.pgszoob - ns->regs.off)) {\r\nNS_ERR("do_state_action: column number is too large\n");\r\nbreak;\r\n}\r\nnum = ns->geom.pgszoob - ns->regs.off - ns->regs.column;\r\nread_page(ns, num);\r\nNS_DBG("do_state_action: (ACTION_CPY:) copy %d bytes to int buf, raw offset %d\n",\r\nnum, NS_RAW_OFFSET(ns) + ns->regs.off);\r\nif (ns->regs.off == 0)\r\nNS_LOG("read page %d\n", ns->regs.row);\r\nelse if (ns->regs.off < ns->geom.pgsz)\r\nNS_LOG("read page %d (second half)\n", ns->regs.row);\r\nelse\r\nNS_LOG("read OOB of page %d\n", ns->regs.row);\r\nNS_UDELAY(access_delay);\r\nNS_UDELAY(input_cycle * ns->geom.pgsz / 1000 / busdiv);\r\nbreak;\r\ncase ACTION_SECERASE:\r\nif (ns->lines.wp) {\r\nNS_ERR("do_state_action: device is write-protected, ignore sector erase\n");\r\nreturn -1;\r\n}\r\nif (ns->regs.row >= ns->geom.pgnum - ns->geom.pgsec\r\n|| (ns->regs.row & ~(ns->geom.secsz - 1))) {\r\nNS_ERR("do_state_action: wrong sector address (%#x)\n", ns->regs.row);\r\nreturn -1;\r\n}\r\nns->regs.row = (ns->regs.row <<\r\n8 * (ns->geom.pgaddrbytes - ns->geom.secaddrbytes)) | ns->regs.column;\r\nns->regs.column = 0;\r\nerase_block_no = ns->regs.row >> (ns->geom.secshift - ns->geom.pgshift);\r\nNS_DBG("do_state_action: erase sector at address %#x, off = %d\n",\r\nns->regs.row, NS_RAW_OFFSET(ns));\r\nNS_LOG("erase sector %u\n", erase_block_no);\r\nerase_sector(ns);\r\nNS_MDELAY(erase_delay);\r\nif (erase_block_wear)\r\nupdate_wear(erase_block_no);\r\nif (erase_error(erase_block_no)) {\r\nNS_WARN("simulating erase failure in erase block %u\n", erase_block_no);\r\nreturn -1;\r\n}\r\nbreak;\r\ncase ACTION_PRGPAGE:\r\nif (ns->lines.wp) {\r\nNS_WARN("do_state_action: device is write-protected, programm\n");\r\nreturn -1;\r\n}\r\nnum = ns->geom.pgszoob - ns->regs.off - ns->regs.column;\r\nif (num != ns->regs.count) {\r\nNS_ERR("do_state_action: too few bytes were input (%d instead of %d)\n",\r\nns->regs.count, num);\r\nreturn -1;\r\n}\r\nif (prog_page(ns, num) == -1)\r\nreturn -1;\r\npage_no = ns->regs.row;\r\nNS_DBG("do_state_action: copy %d bytes from int buf to (%#x, %#x), raw off = %d\n",\r\nnum, ns->regs.row, ns->regs.column, NS_RAW_OFFSET(ns) + ns->regs.off);\r\nNS_LOG("programm page %d\n", ns->regs.row);\r\nNS_UDELAY(programm_delay);\r\nNS_UDELAY(output_cycle * ns->geom.pgsz / 1000 / busdiv);\r\nif (write_error(page_no)) {\r\nNS_WARN("simulating write failure in page %u\n", page_no);\r\nreturn -1;\r\n}\r\nbreak;\r\ncase ACTION_ZEROOFF:\r\nNS_DBG("do_state_action: set internal offset to 0\n");\r\nns->regs.off = 0;\r\nbreak;\r\ncase ACTION_HALFOFF:\r\nif (!(ns->options & OPT_PAGE512_8BIT)) {\r\nNS_ERR("do_state_action: BUG! can't skip half of page for non-512"\r\n"byte page size 8x chips\n");\r\nreturn -1;\r\n}\r\nNS_DBG("do_state_action: set internal offset to %d\n", ns->geom.pgsz/2);\r\nns->regs.off = ns->geom.pgsz/2;\r\nbreak;\r\ncase ACTION_OOBOFF:\r\nNS_DBG("do_state_action: set internal offset to %d\n", ns->geom.pgsz);\r\nns->regs.off = ns->geom.pgsz;\r\nbreak;\r\ndefault:\r\nNS_DBG("do_state_action: BUG! unknown action\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void switch_state(struct nandsim *ns)\r\n{\r\nif (ns->op) {\r\nns->stateidx += 1;\r\nns->state = ns->nxstate;\r\nns->nxstate = ns->op[ns->stateidx + 1];\r\nNS_DBG("switch_state: operation is known, switch to the next state, "\r\n"state: %s, nxstate: %s\n",\r\nget_state_name(ns->state), get_state_name(ns->nxstate));\r\nif ((ns->state & ACTION_MASK) && do_state_action(ns, ns->state) < 0) {\r\nswitch_to_ready_state(ns, NS_STATUS_FAILED(ns));\r\nreturn;\r\n}\r\n} else {\r\nns->state = get_state_by_command(ns->regs.command);\r\nNS_DBG("switch_state: operation is unknown, try to find it\n");\r\nif (find_operation(ns, 0) != 0)\r\nreturn;\r\nif ((ns->state & ACTION_MASK) && do_state_action(ns, ns->state) < 0) {\r\nswitch_to_ready_state(ns, NS_STATUS_FAILED(ns));\r\nreturn;\r\n}\r\n}\r\nif ((ns->nxstate & STATE_ADDR_MASK) && ns->busw == 16) {\r\nNS_DBG("switch_state: double the column number for 16x device\n");\r\nns->regs.column <<= 1;\r\n}\r\nif (NS_STATE(ns->nxstate) == STATE_READY) {\r\nu_char status = NS_STATUS_OK(ns);\r\nif ((ns->state & (STATE_DATAIN_MASK | STATE_DATAOUT_MASK))\r\n&& ns->regs.count != ns->regs.num) {\r\nNS_WARN("switch_state: not all bytes were processed, %d left\n",\r\nns->regs.num - ns->regs.count);\r\nstatus = NS_STATUS_FAILED(ns);\r\n}\r\nNS_DBG("switch_state: operation complete, switch to STATE_READY state\n");\r\nswitch_to_ready_state(ns, status);\r\nreturn;\r\n} else if (ns->nxstate & (STATE_DATAIN_MASK | STATE_DATAOUT_MASK)) {\r\nns->state = ns->nxstate;\r\nns->nxstate = ns->op[++ns->stateidx + 1];\r\nns->regs.num = ns->regs.count = 0;\r\nNS_DBG("switch_state: the next state is data I/O, switch, "\r\n"state: %s, nxstate: %s\n",\r\nget_state_name(ns->state), get_state_name(ns->nxstate));\r\nswitch (NS_STATE(ns->state)) {\r\ncase STATE_DATAIN:\r\ncase STATE_DATAOUT:\r\nns->regs.num = ns->geom.pgszoob - ns->regs.off - ns->regs.column;\r\nbreak;\r\ncase STATE_DATAOUT_ID:\r\nns->regs.num = ns->geom.idbytes;\r\nbreak;\r\ncase STATE_DATAOUT_STATUS:\r\ncase STATE_DATAOUT_STATUS_M:\r\nns->regs.count = ns->regs.num = 0;\r\nbreak;\r\ndefault:\r\nNS_ERR("switch_state: BUG! unknown data state\n");\r\n}\r\n} else if (ns->nxstate & STATE_ADDR_MASK) {\r\nns->regs.count = 0;\r\nswitch (NS_STATE(ns->nxstate)) {\r\ncase STATE_ADDR_PAGE:\r\nns->regs.num = ns->geom.pgaddrbytes;\r\nbreak;\r\ncase STATE_ADDR_SEC:\r\nns->regs.num = ns->geom.secaddrbytes;\r\nbreak;\r\ncase STATE_ADDR_ZERO:\r\nns->regs.num = 1;\r\nbreak;\r\ncase STATE_ADDR_COLUMN:\r\nns->regs.num = ns->geom.pgaddrbytes - ns->geom.secaddrbytes;\r\nbreak;\r\ndefault:\r\nNS_ERR("switch_state: BUG! unknown address state\n");\r\n}\r\n} else {\r\nns->regs.num = 0;\r\nns->regs.count = 0;\r\n}\r\n}\r\nstatic u_char ns_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nandsim *ns = ((struct nand_chip *)mtd->priv)->priv;\r\nu_char outb = 0x00;\r\nif (!ns->lines.ce) {\r\nNS_ERR("read_byte: chip is disabled, return %#x\n", (uint)outb);\r\nreturn outb;\r\n}\r\nif (ns->lines.ale || ns->lines.cle) {\r\nNS_ERR("read_byte: ALE or CLE pin is high, return %#x\n", (uint)outb);\r\nreturn outb;\r\n}\r\nif (!(ns->state & STATE_DATAOUT_MASK)) {\r\nNS_WARN("read_byte: unexpected data output cycle, state is %s "\r\n"return %#x\n", get_state_name(ns->state), (uint)outb);\r\nreturn outb;\r\n}\r\nif (NS_STATE(ns->state) == STATE_DATAOUT_STATUS) {\r\nNS_DBG("read_byte: return %#x status\n", ns->regs.status);\r\nreturn ns->regs.status;\r\n}\r\nif (ns->regs.count == ns->regs.num) {\r\nNS_WARN("read_byte: no more data to output, return %#x\n", (uint)outb);\r\nreturn outb;\r\n}\r\nswitch (NS_STATE(ns->state)) {\r\ncase STATE_DATAOUT:\r\nif (ns->busw == 8) {\r\noutb = ns->buf.byte[ns->regs.count];\r\nns->regs.count += 1;\r\n} else {\r\noutb = (u_char)cpu_to_le16(ns->buf.word[ns->regs.count >> 1]);\r\nns->regs.count += 2;\r\n}\r\nbreak;\r\ncase STATE_DATAOUT_ID:\r\nNS_DBG("read_byte: read ID byte %d, total = %d\n", ns->regs.count, ns->regs.num);\r\noutb = ns->ids[ns->regs.count];\r\nns->regs.count += 1;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (ns->regs.count == ns->regs.num) {\r\nNS_DBG("read_byte: all bytes were read\n");\r\nif (NS_STATE(ns->nxstate) == STATE_READY)\r\nswitch_state(ns);\r\n}\r\nreturn outb;\r\n}\r\nstatic void ns_nand_write_byte(struct mtd_info *mtd, u_char byte)\r\n{\r\nstruct nandsim *ns = ((struct nand_chip *)mtd->priv)->priv;\r\nif (!ns->lines.ce) {\r\nNS_ERR("write_byte: chip is disabled, ignore write\n");\r\nreturn;\r\n}\r\nif (ns->lines.ale && ns->lines.cle) {\r\nNS_ERR("write_byte: ALE and CLE pins are high simultaneously, ignore write\n");\r\nreturn;\r\n}\r\nif (ns->lines.cle == 1) {\r\nif (byte == NAND_CMD_RESET) {\r\nNS_LOG("reset chip\n");\r\nswitch_to_ready_state(ns, NS_STATUS_OK(ns));\r\nreturn;\r\n}\r\nif (check_command(byte)) {\r\nNS_ERR("write_byte: unknown command %#x\n", (uint)byte);\r\nreturn;\r\n}\r\nif (NS_STATE(ns->state) == STATE_DATAOUT_STATUS\r\n|| NS_STATE(ns->state) == STATE_DATAOUT_STATUS_M\r\n|| NS_STATE(ns->state) == STATE_DATAOUT) {\r\nint row = ns->regs.row;\r\nswitch_state(ns);\r\nif (byte == NAND_CMD_RNDOUT)\r\nns->regs.row = row;\r\n}\r\nif (NS_STATE(ns->nxstate) != STATE_UNKNOWN && !(ns->nxstate & STATE_CMD_MASK)) {\r\nif (!(ns->regs.command == NAND_CMD_READID &&\r\nNS_STATE(ns->state) == STATE_DATAOUT_ID && ns->regs.count == 2)) {\r\nNS_WARN("write_byte: command (%#x) wasn't expected, expected state is %s, "\r\n"ignore previous states\n", (uint)byte, get_state_name(ns->nxstate));\r\n}\r\nswitch_to_ready_state(ns, NS_STATUS_FAILED(ns));\r\n}\r\nNS_DBG("command byte corresponding to %s state accepted\n",\r\nget_state_name(get_state_by_command(byte)));\r\nns->regs.command = byte;\r\nswitch_state(ns);\r\n} else if (ns->lines.ale == 1) {\r\nif (NS_STATE(ns->nxstate) == STATE_UNKNOWN) {\r\nNS_DBG("write_byte: operation isn't known yet, identify it\n");\r\nif (find_operation(ns, 1) < 0)\r\nreturn;\r\nif ((ns->state & ACTION_MASK) && do_state_action(ns, ns->state) < 0) {\r\nswitch_to_ready_state(ns, NS_STATUS_FAILED(ns));\r\nreturn;\r\n}\r\nns->regs.count = 0;\r\nswitch (NS_STATE(ns->nxstate)) {\r\ncase STATE_ADDR_PAGE:\r\nns->regs.num = ns->geom.pgaddrbytes;\r\nbreak;\r\ncase STATE_ADDR_SEC:\r\nns->regs.num = ns->geom.secaddrbytes;\r\nbreak;\r\ncase STATE_ADDR_ZERO:\r\nns->regs.num = 1;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nif (!(ns->nxstate & STATE_ADDR_MASK)) {\r\nNS_ERR("write_byte: address (%#x) isn't expected, expected state is %s, "\r\n"switch to STATE_READY\n", (uint)byte, get_state_name(ns->nxstate));\r\nswitch_to_ready_state(ns, NS_STATUS_FAILED(ns));\r\nreturn;\r\n}\r\nif (ns->regs.count == ns->regs.num) {\r\nNS_ERR("write_byte: no more address bytes expected\n");\r\nswitch_to_ready_state(ns, NS_STATUS_FAILED(ns));\r\nreturn;\r\n}\r\naccept_addr_byte(ns, byte);\r\nns->regs.count += 1;\r\nNS_DBG("write_byte: address byte %#x was accepted (%d bytes input, %d expected)\n",\r\n(uint)byte, ns->regs.count, ns->regs.num);\r\nif (ns->regs.count == ns->regs.num) {\r\nNS_DBG("address (%#x, %#x) is accepted\n", ns->regs.row, ns->regs.column);\r\nswitch_state(ns);\r\n}\r\n} else {\r\nif (!(ns->state & STATE_DATAIN_MASK)) {\r\nNS_ERR("write_byte: data input (%#x) isn't expected, state is %s, "\r\n"switch to %s\n", (uint)byte,\r\nget_state_name(ns->state), get_state_name(STATE_READY));\r\nswitch_to_ready_state(ns, NS_STATUS_FAILED(ns));\r\nreturn;\r\n}\r\nif (ns->regs.count == ns->regs.num) {\r\nNS_WARN("write_byte: %u input bytes has already been accepted, ignore write\n",\r\nns->regs.num);\r\nreturn;\r\n}\r\nif (ns->busw == 8) {\r\nns->buf.byte[ns->regs.count] = byte;\r\nns->regs.count += 1;\r\n} else {\r\nns->buf.word[ns->regs.count >> 1] = cpu_to_le16((uint16_t)byte);\r\nns->regs.count += 2;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void ns_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int bitmask)\r\n{\r\nstruct nandsim *ns = ((struct nand_chip *)mtd->priv)->priv;\r\nns->lines.cle = bitmask & NAND_CLE ? 1 : 0;\r\nns->lines.ale = bitmask & NAND_ALE ? 1 : 0;\r\nns->lines.ce = bitmask & NAND_NCE ? 1 : 0;\r\nif (cmd != NAND_CMD_NONE)\r\nns_nand_write_byte(mtd, cmd);\r\n}\r\nstatic int ns_device_ready(struct mtd_info *mtd)\r\n{\r\nNS_DBG("device_ready\n");\r\nreturn 1;\r\n}\r\nstatic uint16_t ns_nand_read_word(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = (struct nand_chip *)mtd->priv;\r\nNS_DBG("read_word\n");\r\nreturn chip->read_byte(mtd) | (chip->read_byte(mtd) << 8);\r\n}\r\nstatic void ns_nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct nandsim *ns = ((struct nand_chip *)mtd->priv)->priv;\r\nif (!(ns->state & STATE_DATAIN_MASK)) {\r\nNS_ERR("write_buf: data input isn't expected, state is %s, "\r\n"switch to STATE_READY\n", get_state_name(ns->state));\r\nswitch_to_ready_state(ns, NS_STATUS_FAILED(ns));\r\nreturn;\r\n}\r\nif (ns->regs.count + len > ns->regs.num) {\r\nNS_ERR("write_buf: too many input bytes\n");\r\nswitch_to_ready_state(ns, NS_STATUS_FAILED(ns));\r\nreturn;\r\n}\r\nmemcpy(ns->buf.byte + ns->regs.count, buf, len);\r\nns->regs.count += len;\r\nif (ns->regs.count == ns->regs.num) {\r\nNS_DBG("write_buf: %d bytes were written\n", ns->regs.count);\r\n}\r\n}\r\nstatic void ns_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nandsim *ns = ((struct nand_chip *)mtd->priv)->priv;\r\nif (!ns->lines.ce) {\r\nNS_ERR("read_buf: chip is disabled\n");\r\nreturn;\r\n}\r\nif (ns->lines.ale || ns->lines.cle) {\r\nNS_ERR("read_buf: ALE or CLE pin is high\n");\r\nreturn;\r\n}\r\nif (!(ns->state & STATE_DATAOUT_MASK)) {\r\nNS_WARN("read_buf: unexpected data output cycle, current state is %s\n",\r\nget_state_name(ns->state));\r\nreturn;\r\n}\r\nif (NS_STATE(ns->state) != STATE_DATAOUT) {\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = ((struct nand_chip *)mtd->priv)->read_byte(mtd);\r\nreturn;\r\n}\r\nif (ns->regs.count + len > ns->regs.num) {\r\nNS_ERR("read_buf: too many bytes to read\n");\r\nswitch_to_ready_state(ns, NS_STATUS_FAILED(ns));\r\nreturn;\r\n}\r\nmemcpy(buf, ns->buf.byte + ns->regs.count, len);\r\nns->regs.count += len;\r\nif (ns->regs.count == ns->regs.num) {\r\nif (NS_STATE(ns->nxstate) == STATE_READY)\r\nswitch_state(ns);\r\n}\r\nreturn;\r\n}\r\nstatic int __init ns_init_module(void)\r\n{\r\nstruct nand_chip *chip;\r\nstruct nandsim *nand;\r\nint retval = -ENOMEM, i;\r\nif (bus_width != 8 && bus_width != 16) {\r\nNS_ERR("wrong bus width (%d), use only 8 or 16\n", bus_width);\r\nreturn -EINVAL;\r\n}\r\nnsmtd = kzalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip)\r\n+ sizeof(struct nandsim), GFP_KERNEL);\r\nif (!nsmtd) {\r\nNS_ERR("unable to allocate core structures.\n");\r\nreturn -ENOMEM;\r\n}\r\nchip = (struct nand_chip *)(nsmtd + 1);\r\nnsmtd->priv = (void *)chip;\r\nnand = (struct nandsim *)(chip + 1);\r\nchip->priv = (void *)nand;\r\nchip->cmd_ctrl = ns_hwcontrol;\r\nchip->read_byte = ns_nand_read_byte;\r\nchip->dev_ready = ns_device_ready;\r\nchip->write_buf = ns_nand_write_buf;\r\nchip->read_buf = ns_nand_read_buf;\r\nchip->read_word = ns_nand_read_word;\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\nchip->options |= NAND_SKIP_BBTSCAN;\r\nswitch (bbt) {\r\ncase 2:\r\nchip->bbt_options |= NAND_BBT_NO_OOB;\r\ncase 1:\r\nchip->bbt_options |= NAND_BBT_USE_FLASH;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nNS_ERR("bbt has to be 0..2\n");\r\nretval = -EINVAL;\r\ngoto error;\r\n}\r\nif (third_id_byte != 0xFF || fourth_id_byte != 0xFF)\r\nnand->geom.idbytes = 4;\r\nelse\r\nnand->geom.idbytes = 2;\r\nnand->regs.status = NS_STATUS_OK(nand);\r\nnand->nxstate = STATE_UNKNOWN;\r\nnand->options |= OPT_PAGE512;\r\nnand->ids[0] = first_id_byte;\r\nnand->ids[1] = second_id_byte;\r\nnand->ids[2] = third_id_byte;\r\nnand->ids[3] = fourth_id_byte;\r\nif (bus_width == 16) {\r\nnand->busw = 16;\r\nchip->options |= NAND_BUSWIDTH_16;\r\n}\r\nnsmtd->owner = THIS_MODULE;\r\nif ((retval = parse_weakblocks()) != 0)\r\ngoto error;\r\nif ((retval = parse_weakpages()) != 0)\r\ngoto error;\r\nif ((retval = parse_gravepages()) != 0)\r\ngoto error;\r\nretval = nand_scan_ident(nsmtd, 1, NULL);\r\nif (retval) {\r\nNS_ERR("cannot scan NAND Simulator device\n");\r\nif (retval > 0)\r\nretval = -ENXIO;\r\ngoto error;\r\n}\r\nif (bch) {\r\nunsigned int eccsteps, eccbytes;\r\nif (!mtd_nand_has_bch()) {\r\nNS_ERR("BCH ECC support is disabled\n");\r\nretval = -EINVAL;\r\ngoto error;\r\n}\r\neccsteps = nsmtd->writesize/512;\r\neccbytes = (bch*13+7)/8;\r\nif ((nsmtd->oobsize < 64) || !eccsteps) {\r\nNS_ERR("bch not available on small page devices\n");\r\nretval = -EINVAL;\r\ngoto error;\r\n}\r\nif ((eccbytes*eccsteps+2) > nsmtd->oobsize) {\r\nNS_ERR("invalid bch value %u\n", bch);\r\nretval = -EINVAL;\r\ngoto error;\r\n}\r\nchip->ecc.mode = NAND_ECC_SOFT_BCH;\r\nchip->ecc.size = 512;\r\nchip->ecc.bytes = eccbytes;\r\nNS_INFO("using %u-bit/%u bytes BCH ECC\n", bch, chip->ecc.size);\r\n}\r\nretval = nand_scan_tail(nsmtd);\r\nif (retval) {\r\nNS_ERR("can't register NAND Simulator\n");\r\nif (retval > 0)\r\nretval = -ENXIO;\r\ngoto error;\r\n}\r\nif (overridesize) {\r\nuint64_t new_size = (uint64_t)nsmtd->erasesize << overridesize;\r\nif (new_size >> overridesize != nsmtd->erasesize) {\r\nNS_ERR("overridesize is too big\n");\r\nretval = -EINVAL;\r\ngoto err_exit;\r\n}\r\nnsmtd->size = new_size;\r\nchip->chipsize = new_size;\r\nchip->chip_shift = ffs(nsmtd->erasesize) + overridesize - 1;\r\nchip->pagemask = (chip->chipsize >> chip->page_shift) - 1;\r\n}\r\nif ((retval = setup_wear_reporting(nsmtd)) != 0)\r\ngoto err_exit;\r\nif ((retval = nandsim_debugfs_create(nand)) != 0)\r\ngoto err_exit;\r\nif ((retval = init_nandsim(nsmtd)) != 0)\r\ngoto err_exit;\r\nif ((retval = chip->scan_bbt(nsmtd)) != 0)\r\ngoto err_exit;\r\nif ((retval = parse_badblocks(nand, nsmtd)) != 0)\r\ngoto err_exit;\r\nretval = mtd_device_register(nsmtd, &nand->partitions[0],\r\nnand->nbparts);\r\nif (retval != 0)\r\ngoto err_exit;\r\nreturn 0;\r\nerr_exit:\r\nfree_nandsim(nand);\r\nnand_release(nsmtd);\r\nfor (i = 0;i < ARRAY_SIZE(nand->partitions); ++i)\r\nkfree(nand->partitions[i].name);\r\nerror:\r\nkfree(nsmtd);\r\nfree_lists();\r\nreturn retval;\r\n}\r\nstatic void __exit ns_cleanup_module(void)\r\n{\r\nstruct nandsim *ns = ((struct nand_chip *)nsmtd->priv)->priv;\r\nint i;\r\nnandsim_debugfs_remove(ns);\r\nfree_nandsim(ns);\r\nnand_release(nsmtd);\r\nfor (i = 0;i < ARRAY_SIZE(ns->partitions); ++i)\r\nkfree(ns->partitions[i].name);\r\nkfree(nsmtd);\r\nfree_lists();\r\n}
