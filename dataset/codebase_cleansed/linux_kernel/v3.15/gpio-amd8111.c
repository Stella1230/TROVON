static int amd_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct amd_gpio *agp = to_agp(chip);\r\nagp->orig[offset] = ioread8(agp->pm + AMD_REG_GPIO(offset)) &\r\n(AMD_GPIO_DEBOUNCE | AMD_GPIO_MODE_MASK | AMD_GPIO_X_MASK);\r\ndev_dbg(&agp->pdev->dev, "Requested gpio %d, data %x\n", offset, agp->orig[offset]);\r\nreturn 0;\r\n}\r\nstatic void amd_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct amd_gpio *agp = to_agp(chip);\r\ndev_dbg(&agp->pdev->dev, "Freed gpio %d, data %x\n", offset, agp->orig[offset]);\r\niowrite8(agp->orig[offset], agp->pm + AMD_REG_GPIO(offset));\r\n}\r\nstatic void amd_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct amd_gpio *agp = to_agp(chip);\r\nu8 temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&agp->lock, flags);\r\ntemp = ioread8(agp->pm + AMD_REG_GPIO(offset));\r\ntemp = (temp & AMD_GPIO_DEBOUNCE) | AMD_GPIO_MODE_OUT | (value ? AMD_GPIO_X_OUT_HI : AMD_GPIO_X_OUT_LOW);\r\niowrite8(temp, agp->pm + AMD_REG_GPIO(offset));\r\nspin_unlock_irqrestore(&agp->lock, flags);\r\ndev_dbg(&agp->pdev->dev, "Setting gpio %d, value %d, reg=%02x\n", offset, !!value, temp);\r\n}\r\nstatic int amd_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct amd_gpio *agp = to_agp(chip);\r\nu8 temp;\r\ntemp = ioread8(agp->pm + AMD_REG_GPIO(offset));\r\ndev_dbg(&agp->pdev->dev, "Getting gpio %d, reg=%02x\n", offset, temp);\r\nreturn (temp & AMD_GPIO_RTIN) ? 1 : 0;\r\n}\r\nstatic int amd_gpio_dirout(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct amd_gpio *agp = to_agp(chip);\r\nu8 temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&agp->lock, flags);\r\ntemp = ioread8(agp->pm + AMD_REG_GPIO(offset));\r\ntemp = (temp & AMD_GPIO_DEBOUNCE) | AMD_GPIO_MODE_OUT | (value ? AMD_GPIO_X_OUT_HI : AMD_GPIO_X_OUT_LOW);\r\niowrite8(temp, agp->pm + AMD_REG_GPIO(offset));\r\nspin_unlock_irqrestore(&agp->lock, flags);\r\ndev_dbg(&agp->pdev->dev, "Dirout gpio %d, value %d, reg=%02x\n", offset, !!value, temp);\r\nreturn 0;\r\n}\r\nstatic int amd_gpio_dirin(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct amd_gpio *agp = to_agp(chip);\r\nu8 temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&agp->lock, flags);\r\ntemp = ioread8(agp->pm + AMD_REG_GPIO(offset));\r\ntemp = (temp & AMD_GPIO_DEBOUNCE) | AMD_GPIO_MODE_IN;\r\niowrite8(temp, agp->pm + AMD_REG_GPIO(offset));\r\nspin_unlock_irqrestore(&agp->lock, flags);\r\ndev_dbg(&agp->pdev->dev, "Dirin gpio %d, reg=%02x\n", offset, temp);\r\nreturn 0;\r\n}\r\nstatic int __init amd_gpio_init(void)\r\n{\r\nint err = -ENODEV;\r\nstruct pci_dev *pdev = NULL;\r\nconst struct pci_device_id *ent;\r\nfor_each_pci_dev(pdev) {\r\nent = pci_match_id(pci_tbl, pdev);\r\nif (ent)\r\ngoto found;\r\n}\r\ngoto out;\r\nfound:\r\nerr = pci_read_config_dword(pdev, 0x58, &gp.pmbase);\r\nif (err)\r\ngoto out;\r\nerr = -EIO;\r\ngp.pmbase &= 0x0000FF00;\r\nif (gp.pmbase == 0)\r\ngoto out;\r\nif (!request_region(gp.pmbase + PMBASE_OFFSET, PMBASE_SIZE, "AMD GPIO")) {\r\ndev_err(&pdev->dev, "AMD GPIO region 0x%x already in use!\n",\r\ngp.pmbase + PMBASE_OFFSET);\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\ngp.pm = ioport_map(gp.pmbase + PMBASE_OFFSET, PMBASE_SIZE);\r\ngp.pdev = pdev;\r\ngp.chip.dev = &pdev->dev;\r\nspin_lock_init(&gp.lock);\r\nprintk(KERN_INFO "AMD-8111 GPIO detected\n");\r\nerr = gpiochip_add(&gp.chip);\r\nif (err) {\r\nprintk(KERN_ERR "GPIO registering failed (%d)\n",\r\nerr);\r\nrelease_region(gp.pmbase + PMBASE_OFFSET, PMBASE_SIZE);\r\ngoto out;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit amd_gpio_exit(void)\r\n{\r\nint err = gpiochip_remove(&gp.chip);\r\nWARN_ON(err);\r\nioport_unmap(gp.pm);\r\nrelease_region(gp.pmbase + PMBASE_OFFSET, PMBASE_SIZE);\r\n}
