static int mmcc_msm8974_probe(struct platform_device *pdev)\r\n{\r\nvoid __iomem *base;\r\nstruct resource *res;\r\nint i, ret;\r\nstruct device *dev = &pdev->dev;\r\nstruct clk *clk;\r\nstruct clk_onecell_data *data;\r\nstruct clk **clks;\r\nstruct regmap *regmap;\r\nsize_t num_clks;\r\nstruct qcom_reset_controller *reset;\r\nstruct qcom_cc *cc;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nregmap = devm_regmap_init_mmio(dev, base, &mmcc_msm8974_regmap_config);\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nnum_clks = ARRAY_SIZE(mmcc_msm8974_clocks);\r\ncc = devm_kzalloc(dev, sizeof(*cc) + sizeof(*clks) * num_clks,\r\nGFP_KERNEL);\r\nif (!cc)\r\nreturn -ENOMEM;\r\nclks = cc->clks;\r\ndata = &cc->data;\r\ndata->clks = clks;\r\ndata->clk_num = num_clks;\r\nclk_pll_configure_sr_hpm_lp(&mmpll1, regmap, &mmpll1_config, true);\r\nclk_pll_configure_sr_hpm_lp(&mmpll3, regmap, &mmpll3_config, false);\r\nfor (i = 0; i < num_clks; i++) {\r\nif (!mmcc_msm8974_clocks[i])\r\ncontinue;\r\nclk = devm_clk_register_regmap(dev, mmcc_msm8974_clocks[i]);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nclks[i] = clk;\r\n}\r\nret = of_clk_add_provider(dev->of_node, of_clk_src_onecell_get, data);\r\nif (ret)\r\nreturn ret;\r\nreset = &cc->reset;\r\nreset->rcdev.of_node = dev->of_node;\r\nreset->rcdev.ops = &qcom_reset_ops,\r\nreset->rcdev.owner = THIS_MODULE,\r\nreset->rcdev.nr_resets = ARRAY_SIZE(mmcc_msm8974_resets),\r\nreset->regmap = regmap;\r\nreset->reset_map = mmcc_msm8974_resets,\r\nplatform_set_drvdata(pdev, &reset->rcdev);\r\nret = reset_controller_register(&reset->rcdev);\r\nif (ret)\r\nof_clk_del_provider(dev->of_node);\r\nreturn ret;\r\n}\r\nstatic int mmcc_msm8974_remove(struct platform_device *pdev)\r\n{\r\nof_clk_del_provider(pdev->dev.of_node);\r\nreset_controller_unregister(platform_get_drvdata(pdev));\r\nreturn 0;\r\n}
