static int dra7_apll_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nint r = 0, i = 0;\r\nstruct dpll_data *ad;\r\nconst char *clk_name;\r\nu8 state = 1;\r\nu32 v;\r\nad = clk->dpll_data;\r\nif (!ad)\r\nreturn -EINVAL;\r\nclk_name = __clk_get_name(clk->hw.clk);\r\nstate <<= __ffs(ad->idlest_mask);\r\nv = ti_clk_ll_ops->clk_readl(ad->idlest_reg);\r\nif ((v & ad->idlest_mask) == state)\r\nreturn r;\r\nv = ti_clk_ll_ops->clk_readl(ad->control_reg);\r\nv &= ~ad->enable_mask;\r\nv |= APLL_FORCE_LOCK << __ffs(ad->enable_mask);\r\nti_clk_ll_ops->clk_writel(v, ad->control_reg);\r\nstate <<= __ffs(ad->idlest_mask);\r\nwhile (1) {\r\nv = ti_clk_ll_ops->clk_readl(ad->idlest_reg);\r\nif ((v & ad->idlest_mask) == state)\r\nbreak;\r\nif (i > MAX_APLL_WAIT_TRIES)\r\nbreak;\r\ni++;\r\nudelay(1);\r\n}\r\nif (i == MAX_APLL_WAIT_TRIES) {\r\npr_warn("clock: %s failed transition to '%s'\n",\r\nclk_name, (state) ? "locked" : "bypassed");\r\n} else {\r\npr_debug("clock: %s transition to '%s' in %d loops\n",\r\nclk_name, (state) ? "locked" : "bypassed", i);\r\nr = 0;\r\n}\r\nreturn r;\r\n}\r\nstatic void dra7_apll_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nstruct dpll_data *ad;\r\nu8 state = 1;\r\nu32 v;\r\nad = clk->dpll_data;\r\nstate <<= __ffs(ad->idlest_mask);\r\nv = ti_clk_ll_ops->clk_readl(ad->control_reg);\r\nv &= ~ad->enable_mask;\r\nv |= APLL_AUTO_IDLE << __ffs(ad->enable_mask);\r\nti_clk_ll_ops->clk_writel(v, ad->control_reg);\r\n}\r\nstatic int dra7_apll_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nstruct dpll_data *ad;\r\nu32 v;\r\nad = clk->dpll_data;\r\nv = ti_clk_ll_ops->clk_readl(ad->control_reg);\r\nv &= ad->enable_mask;\r\nv >>= __ffs(ad->enable_mask);\r\nreturn v == APLL_AUTO_IDLE ? 0 : 1;\r\n}\r\nstatic u8 dra7_init_apll_parent(struct clk_hw *hw)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __init omap_clk_register_apll(struct clk_hw *hw,\r\nstruct device_node *node)\r\n{\r\nstruct clk_hw_omap *clk_hw = to_clk_hw_omap(hw);\r\nstruct dpll_data *ad = clk_hw->dpll_data;\r\nstruct clk *clk;\r\nad->clk_ref = of_clk_get(node, 0);\r\nad->clk_bypass = of_clk_get(node, 1);\r\nif (IS_ERR(ad->clk_ref) || IS_ERR(ad->clk_bypass)) {\r\npr_debug("clk-ref or clk-bypass for %s not ready, retry\n",\r\nnode->name);\r\nif (!ti_clk_retry_init(node, hw, omap_clk_register_apll))\r\nreturn;\r\ngoto cleanup;\r\n}\r\nclk = clk_register(NULL, &clk_hw->hw);\r\nif (!IS_ERR(clk)) {\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nkfree(clk_hw->hw.init->parent_names);\r\nkfree(clk_hw->hw.init);\r\nreturn;\r\n}\r\ncleanup:\r\nkfree(clk_hw->dpll_data);\r\nkfree(clk_hw->hw.init->parent_names);\r\nkfree(clk_hw->hw.init);\r\nkfree(clk_hw);\r\n}\r\nstatic void __init of_dra7_apll_setup(struct device_node *node)\r\n{\r\nstruct dpll_data *ad = NULL;\r\nstruct clk_hw_omap *clk_hw = NULL;\r\nstruct clk_init_data *init = NULL;\r\nconst char **parent_names = NULL;\r\nint i;\r\nad = kzalloc(sizeof(*ad), GFP_KERNEL);\r\nclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\r\ninit = kzalloc(sizeof(*init), GFP_KERNEL);\r\nif (!ad || !clk_hw || !init)\r\ngoto cleanup;\r\nclk_hw->dpll_data = ad;\r\nclk_hw->hw.init = init;\r\nclk_hw->flags = MEMMAP_ADDRESSING;\r\ninit->name = node->name;\r\ninit->ops = &apll_ck_ops;\r\ninit->num_parents = of_clk_get_parent_count(node);\r\nif (init->num_parents < 1) {\r\npr_err("dra7 apll %s must have parent(s)\n", node->name);\r\ngoto cleanup;\r\n}\r\nparent_names = kzalloc(sizeof(char *) * init->num_parents, GFP_KERNEL);\r\nif (!parent_names)\r\ngoto cleanup;\r\nfor (i = 0; i < init->num_parents; i++)\r\nparent_names[i] = of_clk_get_parent_name(node, i);\r\ninit->parent_names = parent_names;\r\nad->control_reg = ti_clk_get_reg_addr(node, 0);\r\nad->idlest_reg = ti_clk_get_reg_addr(node, 1);\r\nif (!ad->control_reg || !ad->idlest_reg)\r\ngoto cleanup;\r\nad->idlest_mask = 0x1;\r\nad->enable_mask = 0x3;\r\nomap_clk_register_apll(&clk_hw->hw, node);\r\nreturn;\r\ncleanup:\r\nkfree(parent_names);\r\nkfree(ad);\r\nkfree(clk_hw);\r\nkfree(init);\r\n}
