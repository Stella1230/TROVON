static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)\r\n{\r\nstruct hw_fib * kfib;\r\nstruct fib *fibptr;\r\nstruct hw_fib * hw_fib = (struct hw_fib *)0;\r\ndma_addr_t hw_fib_pa = (dma_addr_t)0LL;\r\nunsigned size;\r\nint retval;\r\nif (dev->in_reset) {\r\nreturn -EBUSY;\r\n}\r\nfibptr = aac_fib_alloc(dev);\r\nif(fibptr == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nkfib = fibptr->hw_fib_va;\r\nif (copy_from_user((void *)kfib, arg, sizeof(struct aac_fibhdr))) {\r\naac_fib_free(fibptr);\r\nreturn -EFAULT;\r\n}\r\nsize = le16_to_cpu(kfib->header.Size) + sizeof(struct aac_fibhdr);\r\nif (size < le16_to_cpu(kfib->header.SenderSize))\r\nsize = le16_to_cpu(kfib->header.SenderSize);\r\nif (size > dev->max_fib_size) {\r\ndma_addr_t daddr;\r\nif (size > 2048) {\r\nretval = -EINVAL;\r\ngoto cleanup;\r\n}\r\nkfib = pci_alloc_consistent(dev->pdev, size, &daddr);\r\nif (!kfib) {\r\nretval = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nhw_fib = fibptr->hw_fib_va;\r\nhw_fib_pa = fibptr->hw_fib_pa;\r\nfibptr->hw_fib_va = kfib;\r\nfibptr->hw_fib_pa = daddr;\r\nmemset(((char *)kfib) + dev->max_fib_size, 0, size - dev->max_fib_size);\r\nmemcpy(kfib, hw_fib, dev->max_fib_size);\r\n}\r\nif (copy_from_user(kfib, arg, size)) {\r\nretval = -EFAULT;\r\ngoto cleanup;\r\n}\r\nif (kfib->header.Command == cpu_to_le16(TakeABreakPt)) {\r\naac_adapter_interrupt(dev);\r\nkfib->header.XferState = 0;\r\n} else {\r\nretval = aac_fib_send(le16_to_cpu(kfib->header.Command), fibptr,\r\nle16_to_cpu(kfib->header.Size) , FsaNormal,\r\n1, 1, NULL, NULL);\r\nif (retval) {\r\ngoto cleanup;\r\n}\r\nif (aac_fib_complete(fibptr) != 0) {\r\nretval = -EINVAL;\r\ngoto cleanup;\r\n}\r\n}\r\nretval = 0;\r\nif (copy_to_user(arg, (void *)kfib, size))\r\nretval = -EFAULT;\r\ncleanup:\r\nif (hw_fib) {\r\npci_free_consistent(dev->pdev, size, kfib, fibptr->hw_fib_pa);\r\nfibptr->hw_fib_pa = hw_fib_pa;\r\nfibptr->hw_fib_va = hw_fib;\r\n}\r\nif (retval != -ERESTARTSYS)\r\naac_fib_free(fibptr);\r\nreturn retval;\r\n}\r\nstatic int open_getadapter_fib(struct aac_dev * dev, void __user *arg)\r\n{\r\nstruct aac_fib_context * fibctx;\r\nint status;\r\nfibctx = kmalloc(sizeof(struct aac_fib_context), GFP_KERNEL);\r\nif (fibctx == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nunsigned long flags;\r\nstruct list_head * entry;\r\nstruct aac_fib_context * context;\r\nfibctx->type = FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT;\r\nfibctx->size = sizeof(struct aac_fib_context);\r\nfibctx->unique = (u32)((ulong)fibctx & 0xFFFFFFFF);\r\nsema_init(&fibctx->wait_sem, 0);\r\nfibctx->wait = 0;\r\nfibctx->count = 0;\r\nINIT_LIST_HEAD(&fibctx->fib_list);\r\nfibctx->jiffies = jiffies/HZ;\r\nspin_lock_irqsave(&dev->fib_lock, flags);\r\nentry = dev->fib_list.next;\r\nwhile (entry != &dev->fib_list) {\r\ncontext = list_entry(entry, struct aac_fib_context, next);\r\nif (context->unique == fibctx->unique) {\r\nfibctx->unique++;\r\nentry = dev->fib_list.next;\r\n} else {\r\nentry = entry->next;\r\n}\r\n}\r\nlist_add_tail(&fibctx->next, &dev->fib_list);\r\nspin_unlock_irqrestore(&dev->fib_lock, flags);\r\nif (copy_to_user(arg, &fibctx->unique,\r\nsizeof(fibctx->unique))) {\r\nstatus = -EFAULT;\r\n} else {\r\nstatus = 0;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int next_getadapter_fib(struct aac_dev * dev, void __user *arg)\r\n{\r\nstruct fib_ioctl f;\r\nstruct fib *fib;\r\nstruct aac_fib_context *fibctx;\r\nint status;\r\nstruct list_head * entry;\r\nunsigned long flags;\r\nif(copy_from_user((void *)&f, arg, sizeof(struct fib_ioctl)))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&dev->fib_lock, flags);\r\nentry = dev->fib_list.next;\r\nfibctx = NULL;\r\nwhile (entry != &dev->fib_list) {\r\nfibctx = list_entry(entry, struct aac_fib_context, next);\r\nif (fibctx->unique == f.fibctx) {\r\nbreak;\r\n}\r\nentry = entry->next;\r\nfibctx = NULL;\r\n}\r\nif (!fibctx) {\r\nspin_unlock_irqrestore(&dev->fib_lock, flags);\r\ndprintk ((KERN_INFO "Fib Context not found\n"));\r\nreturn -EINVAL;\r\n}\r\nif((fibctx->type != FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT) ||\r\n(fibctx->size != sizeof(struct aac_fib_context))) {\r\nspin_unlock_irqrestore(&dev->fib_lock, flags);\r\ndprintk ((KERN_INFO "Fib Context corrupt?\n"));\r\nreturn -EINVAL;\r\n}\r\nstatus = 0;\r\nreturn_fib:\r\nif (!list_empty(&fibctx->fib_list)) {\r\nentry = fibctx->fib_list.next;\r\nlist_del(entry);\r\nfib = list_entry(entry, struct fib, fiblink);\r\nfibctx->count--;\r\nspin_unlock_irqrestore(&dev->fib_lock, flags);\r\nif (copy_to_user(f.fib, fib->hw_fib_va, sizeof(struct hw_fib))) {\r\nkfree(fib->hw_fib_va);\r\nkfree(fib);\r\nreturn -EFAULT;\r\n}\r\nkfree(fib->hw_fib_va);\r\nkfree(fib);\r\nstatus = 0;\r\n} else {\r\nspin_unlock_irqrestore(&dev->fib_lock, flags);\r\nstatus = !dev->aif_thread;\r\nif (status && !dev->in_reset && dev->queues && dev->fsa_dev) {\r\nkthread_stop(dev->thread);\r\nssleep(1);\r\ndev->aif_thread = 0;\r\ndev->thread = kthread_run(aac_command_thread, dev,\r\n"%s", dev->name);\r\nssleep(1);\r\n}\r\nif (f.wait) {\r\nif(down_interruptible(&fibctx->wait_sem) < 0) {\r\nstatus = -ERESTARTSYS;\r\n} else {\r\nspin_lock_irqsave(&dev->fib_lock, flags);\r\ngoto return_fib;\r\n}\r\n} else {\r\nstatus = -EAGAIN;\r\n}\r\n}\r\nfibctx->jiffies = jiffies/HZ;\r\nreturn status;\r\n}\r\nint aac_close_fib_context(struct aac_dev * dev, struct aac_fib_context * fibctx)\r\n{\r\nstruct fib *fib;\r\nwhile (!list_empty(&fibctx->fib_list)) {\r\nstruct list_head * entry;\r\nentry = fibctx->fib_list.next;\r\nlist_del(entry);\r\nfib = list_entry(entry, struct fib, fiblink);\r\nfibctx->count--;\r\nkfree(fib->hw_fib_va);\r\nkfree(fib);\r\n}\r\nlist_del(&fibctx->next);\r\nfibctx->type = 0;\r\nkfree(fibctx);\r\nreturn 0;\r\n}\r\nstatic int close_getadapter_fib(struct aac_dev * dev, void __user *arg)\r\n{\r\nstruct aac_fib_context *fibctx;\r\nint status;\r\nunsigned long flags;\r\nstruct list_head * entry;\r\nentry = dev->fib_list.next;\r\nfibctx = NULL;\r\nwhile(entry != &dev->fib_list) {\r\nfibctx = list_entry(entry, struct aac_fib_context, next);\r\nif (fibctx->unique == (u32)(uintptr_t)arg)\r\nbreak;\r\nentry = entry->next;\r\nfibctx = NULL;\r\n}\r\nif (!fibctx)\r\nreturn 0;\r\nif((fibctx->type != FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT) ||\r\n(fibctx->size != sizeof(struct aac_fib_context)))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&dev->fib_lock, flags);\r\nstatus = aac_close_fib_context(dev, fibctx);\r\nspin_unlock_irqrestore(&dev->fib_lock, flags);\r\nreturn status;\r\n}\r\nstatic int check_revision(struct aac_dev *dev, void __user *arg)\r\n{\r\nstruct revision response;\r\nchar *driver_version = aac_driver_version;\r\nu32 version;\r\nresponse.compat = 1;\r\nversion = (simple_strtol(driver_version,\r\n&driver_version, 10) << 24) | 0x00000400;\r\nversion += simple_strtol(driver_version + 1, &driver_version, 10) << 16;\r\nversion += simple_strtol(driver_version + 1, NULL, 10);\r\nresponse.version = cpu_to_le32(version);\r\n# ifdef AAC_DRIVER_BUILD\r\nresponse.build = cpu_to_le32(AAC_DRIVER_BUILD);\r\n# else\r\nresponse.build = cpu_to_le32(9999);\r\n# endif\r\nif (copy_to_user(arg, &response, sizeof(response)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int aac_send_raw_srb(struct aac_dev* dev, void __user * arg)\r\n{\r\nstruct fib* srbfib;\r\nint status;\r\nstruct aac_srb *srbcmd = NULL;\r\nstruct user_aac_srb *user_srbcmd = NULL;\r\nstruct user_aac_srb __user *user_srb = arg;\r\nstruct aac_srb_reply __user *user_reply;\r\nstruct aac_srb_reply* reply;\r\nu32 fibsize = 0;\r\nu32 flags = 0;\r\ns32 rcode = 0;\r\nu32 data_dir;\r\nvoid __user *sg_user[32];\r\nvoid *sg_list[32];\r\nu32 sg_indx = 0;\r\nu32 byte_count = 0;\r\nu32 actual_fibsize64, actual_fibsize = 0;\r\nint i;\r\nif (dev->in_reset) {\r\ndprintk((KERN_DEBUG"aacraid: send raw srb -EBUSY\n"));\r\nreturn -EBUSY;\r\n}\r\nif (!capable(CAP_SYS_ADMIN)){\r\ndprintk((KERN_DEBUG"aacraid: No permission to send raw srb\n"));\r\nreturn -EPERM;\r\n}\r\nif (!(srbfib = aac_fib_alloc(dev))) {\r\nreturn -ENOMEM;\r\n}\r\naac_fib_init(srbfib);\r\nsrbfib->hw_fib_va->header.XferState &= ~cpu_to_le32(FastResponseCapable);\r\nsrbcmd = (struct aac_srb*) fib_data(srbfib);\r\nmemset(sg_list, 0, sizeof(sg_list));\r\nif(copy_from_user(&fibsize, &user_srb->count,sizeof(u32))){\r\ndprintk((KERN_DEBUG"aacraid: Could not copy data size from user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\nif ((fibsize < (sizeof(struct user_aac_srb) - sizeof(struct user_sgentry))) ||\r\n(fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr)))) {\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\nuser_srbcmd = kmalloc(fibsize, GFP_KERNEL);\r\nif (!user_srbcmd) {\r\ndprintk((KERN_DEBUG"aacraid: Could not make a copy of the srb\n"));\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nif(copy_from_user(user_srbcmd, user_srb,fibsize)){\r\ndprintk((KERN_DEBUG"aacraid: Could not copy srb from user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\nuser_reply = arg+fibsize;\r\nflags = user_srbcmd->flags;\r\nsrbcmd->function = cpu_to_le32(SRBF_ExecuteScsi);\r\nsrbcmd->channel = cpu_to_le32(user_srbcmd->channel);\r\nsrbcmd->id = cpu_to_le32(user_srbcmd->id);\r\nsrbcmd->lun = cpu_to_le32(user_srbcmd->lun);\r\nsrbcmd->timeout = cpu_to_le32(user_srbcmd->timeout);\r\nsrbcmd->flags = cpu_to_le32(flags);\r\nsrbcmd->retry_limit = 0;\r\nsrbcmd->cdb_size = cpu_to_le32(user_srbcmd->cdb_size);\r\nmemcpy(srbcmd->cdb, user_srbcmd->cdb, sizeof(srbcmd->cdb));\r\nswitch (flags & (SRB_DataIn | SRB_DataOut)) {\r\ncase SRB_DataOut:\r\ndata_dir = DMA_TO_DEVICE;\r\nbreak;\r\ncase (SRB_DataIn | SRB_DataOut):\r\ndata_dir = DMA_BIDIRECTIONAL;\r\nbreak;\r\ncase SRB_DataIn:\r\ndata_dir = DMA_FROM_DEVICE;\r\nbreak;\r\ndefault:\r\ndata_dir = DMA_NONE;\r\n}\r\nif (user_srbcmd->sg.count > ARRAY_SIZE(sg_list)) {\r\ndprintk((KERN_DEBUG"aacraid: too many sg entries %d\n",\r\nle32_to_cpu(srbcmd->sg.count)));\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\nactual_fibsize = sizeof(struct aac_srb) - sizeof(struct sgentry) +\r\n((user_srbcmd->sg.count & 0xff) * sizeof(struct sgentry));\r\nactual_fibsize64 = actual_fibsize + (user_srbcmd->sg.count & 0xff) *\r\n(sizeof(struct sgentry64) - sizeof(struct sgentry));\r\nif ((actual_fibsize != fibsize) && (actual_fibsize64 != fibsize)) {\r\ndprintk((KERN_DEBUG"aacraid: Bad Size specified in "\r\n"Raw SRB command calculated fibsize=%lu;%lu "\r\n"user_srbcmd->sg.count=%d aac_srb=%lu sgentry=%lu;%lu "\r\n"issued fibsize=%d\n",\r\nactual_fibsize, actual_fibsize64, user_srbcmd->sg.count,\r\nsizeof(struct aac_srb), sizeof(struct sgentry),\r\nsizeof(struct sgentry64), fibsize));\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\nif ((data_dir == DMA_NONE) && user_srbcmd->sg.count) {\r\ndprintk((KERN_DEBUG"aacraid: SG with no direction specified in Raw SRB command\n"));\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\nbyte_count = 0;\r\nif (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64) {\r\nstruct user_sgmap64* upsg = (struct user_sgmap64*)&user_srbcmd->sg;\r\nstruct sgmap64* psg = (struct sgmap64*)&srbcmd->sg;\r\nif (actual_fibsize64 == fibsize) {\r\nactual_fibsize = actual_fibsize64;\r\nfor (i = 0; i < upsg->count; i++) {\r\nu64 addr;\r\nvoid* p;\r\nif (upsg->sg[i].count >\r\n((dev->adapter_info.options &\r\nAAC_OPT_NEW_COMM) ?\r\n(dev->scsi_host_ptr->max_sectors << 9) :\r\n65536)) {\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\np = kmalloc(upsg->sg[i].count,GFP_KERNEL|__GFP_DMA);\r\nif(!p) {\r\ndprintk((KERN_DEBUG"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n",\r\nupsg->sg[i].count,i,upsg->count));\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\naddr = (u64)upsg->sg[i].addr[0];\r\naddr += ((u64)upsg->sg[i].addr[1]) << 32;\r\nsg_user[i] = (void __user *)(uintptr_t)addr;\r\nsg_list[i] = p;\r\nsg_indx = i;\r\nif (flags & SRB_DataOut) {\r\nif(copy_from_user(p,sg_user[i],upsg->sg[i].count)){\r\ndprintk((KERN_DEBUG"aacraid: Could not copy sg data from user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\naddr = pci_map_single(dev->pdev, p, upsg->sg[i].count, data_dir);\r\npsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\r\npsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\r\nbyte_count += upsg->sg[i].count;\r\npsg->sg[i].count = cpu_to_le32(upsg->sg[i].count);\r\n}\r\n} else {\r\nstruct user_sgmap* usg;\r\nusg = kmalloc(actual_fibsize - sizeof(struct aac_srb)\r\n+ sizeof(struct sgmap), GFP_KERNEL);\r\nif (!usg) {\r\ndprintk((KERN_DEBUG"aacraid: Allocation error in Raw SRB command\n"));\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nmemcpy (usg, upsg, actual_fibsize - sizeof(struct aac_srb)\r\n+ sizeof(struct sgmap));\r\nactual_fibsize = actual_fibsize64;\r\nfor (i = 0; i < usg->count; i++) {\r\nu64 addr;\r\nvoid* p;\r\nif (usg->sg[i].count >\r\n((dev->adapter_info.options &\r\nAAC_OPT_NEW_COMM) ?\r\n(dev->scsi_host_ptr->max_sectors << 9) :\r\n65536)) {\r\nkfree(usg);\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\np = kmalloc(usg->sg[i].count,GFP_KERNEL|__GFP_DMA);\r\nif(!p) {\r\ndprintk((KERN_DEBUG "aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n",\r\nusg->sg[i].count,i,usg->count));\r\nkfree(usg);\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nsg_user[i] = (void __user *)(uintptr_t)usg->sg[i].addr;\r\nsg_list[i] = p;\r\nsg_indx = i;\r\nif (flags & SRB_DataOut) {\r\nif(copy_from_user(p,sg_user[i],upsg->sg[i].count)){\r\nkfree (usg);\r\ndprintk((KERN_DEBUG"aacraid: Could not copy sg data from user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\naddr = pci_map_single(dev->pdev, p, usg->sg[i].count, data_dir);\r\npsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\r\npsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\r\nbyte_count += usg->sg[i].count;\r\npsg->sg[i].count = cpu_to_le32(usg->sg[i].count);\r\n}\r\nkfree (usg);\r\n}\r\nsrbcmd->count = cpu_to_le32(byte_count);\r\npsg->count = cpu_to_le32(sg_indx+1);\r\nstatus = aac_fib_send(ScsiPortCommand64, srbfib, actual_fibsize, FsaNormal, 1, 1,NULL,NULL);\r\n} else {\r\nstruct user_sgmap* upsg = &user_srbcmd->sg;\r\nstruct sgmap* psg = &srbcmd->sg;\r\nif (actual_fibsize64 == fibsize) {\r\nstruct user_sgmap64* usg = (struct user_sgmap64 *)upsg;\r\nfor (i = 0; i < upsg->count; i++) {\r\nuintptr_t addr;\r\nvoid* p;\r\nif (usg->sg[i].count >\r\n((dev->adapter_info.options &\r\nAAC_OPT_NEW_COMM) ?\r\n(dev->scsi_host_ptr->max_sectors << 9) :\r\n65536)) {\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\np = kmalloc(usg->sg[i].count,GFP_KERNEL|__GFP_DMA);\r\nif(!p) {\r\ndprintk((KERN_DEBUG"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n",\r\nusg->sg[i].count,i,usg->count));\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\naddr = (u64)usg->sg[i].addr[0];\r\naddr += ((u64)usg->sg[i].addr[1]) << 32;\r\nsg_user[i] = (void __user *)addr;\r\nsg_list[i] = p;\r\nsg_indx = i;\r\nif (flags & SRB_DataOut) {\r\nif(copy_from_user(p,sg_user[i],usg->sg[i].count)){\r\ndprintk((KERN_DEBUG"aacraid: Could not copy sg data from user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\naddr = pci_map_single(dev->pdev, p, usg->sg[i].count, data_dir);\r\npsg->sg[i].addr = cpu_to_le32(addr & 0xffffffff);\r\nbyte_count += usg->sg[i].count;\r\npsg->sg[i].count = cpu_to_le32(usg->sg[i].count);\r\n}\r\n} else {\r\nfor (i = 0; i < upsg->count; i++) {\r\ndma_addr_t addr;\r\nvoid* p;\r\nif (upsg->sg[i].count >\r\n((dev->adapter_info.options &\r\nAAC_OPT_NEW_COMM) ?\r\n(dev->scsi_host_ptr->max_sectors << 9) :\r\n65536)) {\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\np = kmalloc(upsg->sg[i].count, GFP_KERNEL);\r\nif (!p) {\r\ndprintk((KERN_DEBUG"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n",\r\nupsg->sg[i].count, i, upsg->count));\r\nrcode = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nsg_user[i] = (void __user *)(uintptr_t)upsg->sg[i].addr;\r\nsg_list[i] = p;\r\nsg_indx = i;\r\nif (flags & SRB_DataOut) {\r\nif(copy_from_user(p, sg_user[i],\r\nupsg->sg[i].count)) {\r\ndprintk((KERN_DEBUG"aacraid: Could not copy sg data from user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\naddr = pci_map_single(dev->pdev, p,\r\nupsg->sg[i].count, data_dir);\r\npsg->sg[i].addr = cpu_to_le32(addr);\r\nbyte_count += upsg->sg[i].count;\r\npsg->sg[i].count = cpu_to_le32(upsg->sg[i].count);\r\n}\r\n}\r\nsrbcmd->count = cpu_to_le32(byte_count);\r\npsg->count = cpu_to_le32(sg_indx+1);\r\nstatus = aac_fib_send(ScsiPortCommand, srbfib, actual_fibsize, FsaNormal, 1, 1, NULL, NULL);\r\n}\r\nif (status == -ERESTARTSYS) {\r\nrcode = -ERESTARTSYS;\r\ngoto cleanup;\r\n}\r\nif (status != 0){\r\ndprintk((KERN_DEBUG"aacraid: Could not send raw srb fib to hba\n"));\r\nrcode = -ENXIO;\r\ngoto cleanup;\r\n}\r\nif (flags & SRB_DataIn) {\r\nfor(i = 0 ; i <= sg_indx; i++){\r\nbyte_count = le32_to_cpu(\r\n(dev->adapter_info.options & AAC_OPT_SGMAP_HOST64)\r\n? ((struct sgmap64*)&srbcmd->sg)->sg[i].count\r\n: srbcmd->sg.sg[i].count);\r\nif(copy_to_user(sg_user[i], sg_list[i], byte_count)){\r\ndprintk((KERN_DEBUG"aacraid: Could not copy sg data to user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\n}\r\n}\r\nreply = (struct aac_srb_reply *) fib_data(srbfib);\r\nif(copy_to_user(user_reply,reply,sizeof(struct aac_srb_reply))){\r\ndprintk((KERN_DEBUG"aacraid: Could not copy reply to user\n"));\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\ncleanup:\r\nkfree(user_srbcmd);\r\nfor(i=0; i <= sg_indx; i++){\r\nkfree(sg_list[i]);\r\n}\r\nif (rcode != -ERESTARTSYS) {\r\naac_fib_complete(srbfib);\r\naac_fib_free(srbfib);\r\n}\r\nreturn rcode;\r\n}\r\nstatic int aac_get_pci_info(struct aac_dev* dev, void __user *arg)\r\n{\r\nstruct aac_pci_info pci_info;\r\npci_info.bus = dev->pdev->bus->number;\r\npci_info.slot = PCI_SLOT(dev->pdev->devfn);\r\nif (copy_to_user(arg, &pci_info, sizeof(struct aac_pci_info))) {\r\ndprintk((KERN_DEBUG "aacraid: Could not copy pci info\n"));\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nint aac_do_ioctl(struct aac_dev * dev, int cmd, void __user *arg)\r\n{\r\nint status;\r\nstatus = aac_dev_ioctl(dev, cmd, arg);\r\nif (status != -ENOTTY)\r\nreturn status;\r\nswitch (cmd) {\r\ncase FSACTL_MINIPORT_REV_CHECK:\r\nstatus = check_revision(dev, arg);\r\nbreak;\r\ncase FSACTL_SEND_LARGE_FIB:\r\ncase FSACTL_SENDFIB:\r\nstatus = ioctl_send_fib(dev, arg);\r\nbreak;\r\ncase FSACTL_OPEN_GET_ADAPTER_FIB:\r\nstatus = open_getadapter_fib(dev, arg);\r\nbreak;\r\ncase FSACTL_GET_NEXT_ADAPTER_FIB:\r\nstatus = next_getadapter_fib(dev, arg);\r\nbreak;\r\ncase FSACTL_CLOSE_GET_ADAPTER_FIB:\r\nstatus = close_getadapter_fib(dev, arg);\r\nbreak;\r\ncase FSACTL_SEND_RAW_SRB:\r\nstatus = aac_send_raw_srb(dev,arg);\r\nbreak;\r\ncase FSACTL_GET_PCI_INFO:\r\nstatus = aac_get_pci_info(dev,arg);\r\nbreak;\r\ndefault:\r\nstatus = -ENOTTY;\r\nbreak;\r\n}\r\nreturn status;\r\n}
