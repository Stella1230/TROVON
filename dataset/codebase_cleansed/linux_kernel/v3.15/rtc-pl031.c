static int pl031_alarm_irq_enable(struct device *dev,\r\nunsigned int enabled)\r\n{\r\nstruct pl031_local *ldata = dev_get_drvdata(dev);\r\nunsigned long imsc;\r\nwritel(RTC_BIT_AI, ldata->base + RTC_ICR);\r\nimsc = readl(ldata->base + RTC_IMSC);\r\nif (enabled == 1)\r\nwritel(imsc | RTC_BIT_AI, ldata->base + RTC_IMSC);\r\nelse\r\nwritel(imsc & ~RTC_BIT_AI, ldata->base + RTC_IMSC);\r\nreturn 0;\r\n}\r\nstatic int pl031_stv2_tm_to_time(struct device *dev,\r\nstruct rtc_time *tm, unsigned long *st_time,\r\nunsigned long *bcd_year)\r\n{\r\nint year = tm->tm_year + 1900;\r\nint wday = tm->tm_wday;\r\nif (wday < -1 || wday > 6) {\r\ndev_err(dev, "invalid wday value %d\n", tm->tm_wday);\r\nreturn -EINVAL;\r\n} else if (wday == -1) {\r\nunsigned long time;\r\nstruct rtc_time calc_tm;\r\nrtc_tm_to_time(tm, &time);\r\nrtc_time_to_tm(time, &calc_tm);\r\nwday = calc_tm.tm_wday;\r\n}\r\n*bcd_year = (bin2bcd(year % 100) | bin2bcd(year / 100) << 8);\r\n*st_time = ((tm->tm_mon + 1) << RTC_MON_SHIFT)\r\n| (tm->tm_mday << RTC_MDAY_SHIFT)\r\n| ((wday + 1) << RTC_WDAY_SHIFT)\r\n| (tm->tm_hour << RTC_HOUR_SHIFT)\r\n| (tm->tm_min << RTC_MIN_SHIFT)\r\n| (tm->tm_sec << RTC_SEC_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int pl031_stv2_time_to_tm(unsigned long st_time, unsigned long bcd_year,\r\nstruct rtc_time *tm)\r\n{\r\ntm->tm_year = bcd2bin(bcd_year) + (bcd2bin(bcd_year >> 8) * 100);\r\ntm->tm_mon = ((st_time & RTC_MON_MASK) >> RTC_MON_SHIFT) - 1;\r\ntm->tm_mday = ((st_time & RTC_MDAY_MASK) >> RTC_MDAY_SHIFT);\r\ntm->tm_wday = ((st_time & RTC_WDAY_MASK) >> RTC_WDAY_SHIFT) - 1;\r\ntm->tm_hour = ((st_time & RTC_HOUR_MASK) >> RTC_HOUR_SHIFT);\r\ntm->tm_min = ((st_time & RTC_MIN_MASK) >> RTC_MIN_SHIFT);\r\ntm->tm_sec = ((st_time & RTC_SEC_MASK) >> RTC_SEC_SHIFT);\r\ntm->tm_yday = rtc_year_days(tm->tm_mday, tm->tm_mon, tm->tm_year);\r\ntm->tm_year -= 1900;\r\nreturn 0;\r\n}\r\nstatic int pl031_stv2_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct pl031_local *ldata = dev_get_drvdata(dev);\r\npl031_stv2_time_to_tm(readl(ldata->base + RTC_DR),\r\nreadl(ldata->base + RTC_YDR), tm);\r\nreturn 0;\r\n}\r\nstatic int pl031_stv2_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nunsigned long time;\r\nunsigned long bcd_year;\r\nstruct pl031_local *ldata = dev_get_drvdata(dev);\r\nint ret;\r\nret = pl031_stv2_tm_to_time(dev, tm, &time, &bcd_year);\r\nif (ret == 0) {\r\nwritel(bcd_year, ldata->base + RTC_YLR);\r\nwritel(time, ldata->base + RTC_LR);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pl031_stv2_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct pl031_local *ldata = dev_get_drvdata(dev);\r\nint ret;\r\nret = pl031_stv2_time_to_tm(readl(ldata->base + RTC_MR),\r\nreadl(ldata->base + RTC_YMR), &alarm->time);\r\nalarm->pending = readl(ldata->base + RTC_RIS) & RTC_BIT_AI;\r\nalarm->enabled = readl(ldata->base + RTC_IMSC) & RTC_BIT_AI;\r\nreturn ret;\r\n}\r\nstatic int pl031_stv2_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct pl031_local *ldata = dev_get_drvdata(dev);\r\nunsigned long time;\r\nunsigned long bcd_year;\r\nint ret;\r\nret = rtc_valid_tm(&alarm->time);\r\nif (ret == 0) {\r\nret = pl031_stv2_tm_to_time(dev, &alarm->time,\r\n&time, &bcd_year);\r\nif (ret == 0) {\r\nwritel(bcd_year, ldata->base + RTC_YMR);\r\nwritel(time, ldata->base + RTC_MR);\r\npl031_alarm_irq_enable(dev, alarm->enabled);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t pl031_interrupt(int irq, void *dev_id)\r\n{\r\nstruct pl031_local *ldata = dev_id;\r\nunsigned long rtcmis;\r\nunsigned long events = 0;\r\nrtcmis = readl(ldata->base + RTC_MIS);\r\nif (rtcmis & RTC_BIT_AI) {\r\nwritel(RTC_BIT_AI, ldata->base + RTC_ICR);\r\nevents |= (RTC_AF | RTC_IRQF);\r\nrtc_update_irq(ldata->rtc, 1, events);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int pl031_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct pl031_local *ldata = dev_get_drvdata(dev);\r\nrtc_time_to_tm(readl(ldata->base + RTC_DR), tm);\r\nreturn 0;\r\n}\r\nstatic int pl031_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nunsigned long time;\r\nstruct pl031_local *ldata = dev_get_drvdata(dev);\r\nint ret;\r\nret = rtc_tm_to_time(tm, &time);\r\nif (ret == 0)\r\nwritel(time, ldata->base + RTC_LR);\r\nreturn ret;\r\n}\r\nstatic int pl031_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct pl031_local *ldata = dev_get_drvdata(dev);\r\nrtc_time_to_tm(readl(ldata->base + RTC_MR), &alarm->time);\r\nalarm->pending = readl(ldata->base + RTC_RIS) & RTC_BIT_AI;\r\nalarm->enabled = readl(ldata->base + RTC_IMSC) & RTC_BIT_AI;\r\nreturn 0;\r\n}\r\nstatic int pl031_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct pl031_local *ldata = dev_get_drvdata(dev);\r\nunsigned long time;\r\nint ret;\r\nret = rtc_valid_tm(&alarm->time);\r\nif (ret == 0) {\r\nret = rtc_tm_to_time(&alarm->time, &time);\r\nif (ret == 0) {\r\nwritel(time, ldata->base + RTC_MR);\r\npl031_alarm_irq_enable(dev, alarm->enabled);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int pl031_remove(struct amba_device *adev)\r\n{\r\nstruct pl031_local *ldata = dev_get_drvdata(&adev->dev);\r\nfree_irq(adev->irq[0], ldata);\r\nrtc_device_unregister(ldata->rtc);\r\niounmap(ldata->base);\r\nkfree(ldata);\r\namba_release_regions(adev);\r\nreturn 0;\r\n}\r\nstatic int pl031_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nint ret;\r\nstruct pl031_local *ldata;\r\nstruct pl031_vendor_data *vendor = id->data;\r\nstruct rtc_class_ops *ops = &vendor->ops;\r\nunsigned long time, data;\r\nret = amba_request_regions(adev, NULL);\r\nif (ret)\r\ngoto err_req;\r\nldata = kzalloc(sizeof(struct pl031_local), GFP_KERNEL);\r\nif (!ldata) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nldata->vendor = vendor;\r\nldata->base = ioremap(adev->res.start, resource_size(&adev->res));\r\nif (!ldata->base) {\r\nret = -ENOMEM;\r\ngoto out_no_remap;\r\n}\r\namba_set_drvdata(adev, ldata);\r\ndev_dbg(&adev->dev, "designer ID = 0x%02x\n", amba_manf(adev));\r\ndev_dbg(&adev->dev, "revision = 0x%01x\n", amba_rev(adev));\r\ndata = readl(ldata->base + RTC_CR);\r\nif (vendor->clockwatch)\r\ndata |= RTC_CR_CWEN;\r\nelse\r\ndata |= RTC_CR_EN;\r\nwritel(data, ldata->base + RTC_CR);\r\nif (vendor->st_weekday) {\r\nif (readl(ldata->base + RTC_YDR) == 0x2000) {\r\ntime = readl(ldata->base + RTC_DR);\r\nif ((time &\r\n(RTC_MON_MASK | RTC_MDAY_MASK | RTC_WDAY_MASK))\r\n== 0x02120000) {\r\ntime = time | (0x7 << RTC_WDAY_SHIFT);\r\nwritel(0x2000, ldata->base + RTC_YLR);\r\nwritel(time, ldata->base + RTC_LR);\r\n}\r\n}\r\n}\r\ndevice_init_wakeup(&adev->dev, 1);\r\nldata->rtc = rtc_device_register("pl031", &adev->dev, ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(ldata->rtc)) {\r\nret = PTR_ERR(ldata->rtc);\r\ngoto out_no_rtc;\r\n}\r\nif (request_irq(adev->irq[0], pl031_interrupt,\r\nvendor->irqflags, "rtc-pl031", ldata)) {\r\nret = -EIO;\r\ngoto out_no_irq;\r\n}\r\nreturn 0;\r\nout_no_irq:\r\nrtc_device_unregister(ldata->rtc);\r\nout_no_rtc:\r\niounmap(ldata->base);\r\nout_no_remap:\r\nkfree(ldata);\r\nout:\r\namba_release_regions(adev);\r\nerr_req:\r\nreturn ret;\r\n}
