static int btmrvl_sdio_get_rx_unit(struct btmrvl_sdio_card *card)\r\n{\r\nu8 reg;\r\nint ret;\r\nreg = sdio_readb(card->func, card->reg->card_rx_unit, &ret);\r\nif (!ret)\r\ncard->rx_unit = reg;\r\nreturn ret;\r\n}\r\nstatic int btmrvl_sdio_read_fw_status(struct btmrvl_sdio_card *card, u16 *dat)\r\n{\r\nu8 fws0, fws1;\r\nint ret;\r\n*dat = 0;\r\nfws0 = sdio_readb(card->func, card->reg->card_fw_status0, &ret);\r\nif (ret)\r\nreturn -EIO;\r\nfws1 = sdio_readb(card->func, card->reg->card_fw_status1, &ret);\r\nif (ret)\r\nreturn -EIO;\r\n*dat = (((u16) fws1) << 8) | fws0;\r\nreturn 0;\r\n}\r\nstatic int btmrvl_sdio_read_rx_len(struct btmrvl_sdio_card *card, u16 *dat)\r\n{\r\nu8 reg;\r\nint ret;\r\nreg = sdio_readb(card->func, card->reg->card_rx_len, &ret);\r\nif (!ret)\r\n*dat = (u16) reg << card->rx_unit;\r\nreturn ret;\r\n}\r\nstatic int btmrvl_sdio_enable_host_int_mask(struct btmrvl_sdio_card *card,\r\nu8 mask)\r\n{\r\nint ret;\r\nsdio_writeb(card->func, mask, card->reg->host_int_mask, &ret);\r\nif (ret) {\r\nBT_ERR("Unable to enable the host interrupt!");\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int btmrvl_sdio_disable_host_int_mask(struct btmrvl_sdio_card *card,\r\nu8 mask)\r\n{\r\nu8 host_int_mask;\r\nint ret;\r\nhost_int_mask = sdio_readb(card->func, card->reg->host_int_mask, &ret);\r\nif (ret)\r\nreturn -EIO;\r\nhost_int_mask &= ~mask;\r\nsdio_writeb(card->func, host_int_mask, card->reg->host_int_mask, &ret);\r\nif (ret < 0) {\r\nBT_ERR("Unable to disable the host interrupt!");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int btmrvl_sdio_poll_card_status(struct btmrvl_sdio_card *card, u8 bits)\r\n{\r\nunsigned int tries;\r\nu8 status;\r\nint ret;\r\nfor (tries = 0; tries < MAX_POLL_TRIES * 1000; tries++) {\r\nstatus = sdio_readb(card->func, card->reg->card_status, &ret);\r\nif (ret)\r\ngoto failed;\r\nif ((status & bits) == bits)\r\nreturn ret;\r\nudelay(1);\r\n}\r\nret = -ETIMEDOUT;\r\nfailed:\r\nBT_ERR("FAILED! ret=%d", ret);\r\nreturn ret;\r\n}\r\nstatic int btmrvl_sdio_verify_fw_download(struct btmrvl_sdio_card *card,\r\nint pollnum)\r\n{\r\nu16 firmwarestat;\r\nint tries, ret;\r\nfor (tries = 0; tries < pollnum; tries++) {\r\nsdio_claim_host(card->func);\r\nret = btmrvl_sdio_read_fw_status(card, &firmwarestat);\r\nsdio_release_host(card->func);\r\nif (ret < 0)\r\ncontinue;\r\nif (firmwarestat == FIRMWARE_READY)\r\nreturn 0;\r\nmsleep(10);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int btmrvl_sdio_download_helper(struct btmrvl_sdio_card *card)\r\n{\r\nconst struct firmware *fw_helper = NULL;\r\nconst u8 *helper = NULL;\r\nint ret;\r\nvoid *tmphlprbuf = NULL;\r\nint tmphlprbufsz, hlprblknow, helperlen;\r\nu8 *helperbuf;\r\nu32 tx_len;\r\nret = request_firmware(&fw_helper, card->helper,\r\n&card->func->dev);\r\nif ((ret < 0) || !fw_helper) {\r\nBT_ERR("request_firmware(helper) failed, error code = %d",\r\nret);\r\nret = -ENOENT;\r\ngoto done;\r\n}\r\nhelper = fw_helper->data;\r\nhelperlen = fw_helper->size;\r\nBT_DBG("Downloading helper image (%d bytes), block size %d bytes",\r\nhelperlen, SDIO_BLOCK_SIZE);\r\ntmphlprbufsz = ALIGN_SZ(BTM_UPLD_SIZE, BTSDIO_DMA_ALIGN);\r\ntmphlprbuf = kzalloc(tmphlprbufsz, GFP_KERNEL);\r\nif (!tmphlprbuf) {\r\nBT_ERR("Unable to allocate buffer for helper."\r\n" Terminating download");\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nhelperbuf = (u8 *) ALIGN_ADDR(tmphlprbuf, BTSDIO_DMA_ALIGN);\r\ntx_len = (FIRMWARE_TRANSFER_NBLOCK * SDIO_BLOCK_SIZE)\r\n- SDIO_HEADER_LEN;\r\nhlprblknow = 0;\r\ndo {\r\nret = btmrvl_sdio_poll_card_status(card,\r\nCARD_IO_READY | DN_LD_CARD_RDY);\r\nif (ret < 0) {\r\nBT_ERR("Helper download poll status timeout @ %d",\r\nhlprblknow);\r\ngoto done;\r\n}\r\nif (hlprblknow >= helperlen)\r\nbreak;\r\nif (helperlen - hlprblknow < tx_len)\r\ntx_len = helperlen - hlprblknow;\r\nhelperbuf[0] = ((tx_len & 0x000000ff) >> 0);\r\nhelperbuf[1] = ((tx_len & 0x0000ff00) >> 8);\r\nhelperbuf[2] = ((tx_len & 0x00ff0000) >> 16);\r\nhelperbuf[3] = ((tx_len & 0xff000000) >> 24);\r\nmemcpy(&helperbuf[SDIO_HEADER_LEN], &helper[hlprblknow],\r\ntx_len);\r\nret = sdio_writesb(card->func, card->ioport, helperbuf,\r\nFIRMWARE_TRANSFER_NBLOCK * SDIO_BLOCK_SIZE);\r\nif (ret < 0) {\r\nBT_ERR("IO error during helper download @ %d",\r\nhlprblknow);\r\ngoto done;\r\n}\r\nhlprblknow += tx_len;\r\n} while (true);\r\nBT_DBG("Transferring helper image EOF block");\r\nmemset(helperbuf, 0x0, SDIO_BLOCK_SIZE);\r\nret = sdio_writesb(card->func, card->ioport, helperbuf,\r\nSDIO_BLOCK_SIZE);\r\nif (ret < 0) {\r\nBT_ERR("IO error in writing helper image EOF block");\r\ngoto done;\r\n}\r\nret = 0;\r\ndone:\r\nkfree(tmphlprbuf);\r\nrelease_firmware(fw_helper);\r\nreturn ret;\r\n}\r\nstatic int btmrvl_sdio_download_fw_w_helper(struct btmrvl_sdio_card *card)\r\n{\r\nconst struct firmware *fw_firmware = NULL;\r\nconst u8 *firmware = NULL;\r\nint firmwarelen, tmpfwbufsz, ret;\r\nunsigned int tries, offset;\r\nu8 base0, base1;\r\nvoid *tmpfwbuf = NULL;\r\nu8 *fwbuf;\r\nu16 len, blksz_dl = card->sd_blksz_fw_dl;\r\nint txlen = 0, tx_blocks = 0, count = 0;\r\nret = request_firmware(&fw_firmware, card->firmware,\r\n&card->func->dev);\r\nif ((ret < 0) || !fw_firmware) {\r\nBT_ERR("request_firmware(firmware) failed, error code = %d",\r\nret);\r\nret = -ENOENT;\r\ngoto done;\r\n}\r\nfirmware = fw_firmware->data;\r\nfirmwarelen = fw_firmware->size;\r\nBT_DBG("Downloading FW image (%d bytes)", firmwarelen);\r\ntmpfwbufsz = ALIGN_SZ(BTM_UPLD_SIZE, BTSDIO_DMA_ALIGN);\r\ntmpfwbuf = kzalloc(tmpfwbufsz, GFP_KERNEL);\r\nif (!tmpfwbuf) {\r\nBT_ERR("Unable to allocate buffer for firmware."\r\n" Terminating download");\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nfwbuf = (u8 *) ALIGN_ADDR(tmpfwbuf, BTSDIO_DMA_ALIGN);\r\noffset = 0;\r\ndo {\r\nret = btmrvl_sdio_poll_card_status(card,\r\nCARD_IO_READY | DN_LD_CARD_RDY);\r\nif (ret < 0) {\r\nBT_ERR("FW download with helper poll status"\r\n" timeout @ %d", offset);\r\ngoto done;\r\n}\r\nif (offset >= firmwarelen)\r\nbreak;\r\nfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\r\nbase0 = sdio_readb(card->func,\r\ncard->reg->sq_read_base_addr_a0, &ret);\r\nif (ret) {\r\nBT_ERR("BASE0 register read failed:"\r\n" base0 = 0x%04X(%d)."\r\n" Terminating download",\r\nbase0, base0);\r\nret = -EIO;\r\ngoto done;\r\n}\r\nbase1 = sdio_readb(card->func,\r\ncard->reg->sq_read_base_addr_a1, &ret);\r\nif (ret) {\r\nBT_ERR("BASE1 register read failed:"\r\n" base1 = 0x%04X(%d)."\r\n" Terminating download",\r\nbase1, base1);\r\nret = -EIO;\r\ngoto done;\r\n}\r\nlen = (((u16) base1) << 8) | base0;\r\nif (len)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!len)\r\nbreak;\r\nelse if (len > BTM_UPLD_SIZE) {\r\nBT_ERR("FW download failure @%d, invalid length %d",\r\noffset, len);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\ntxlen = len;\r\nif (len & BIT(0)) {\r\ncount++;\r\nif (count > MAX_WRITE_IOMEM_RETRY) {\r\nBT_ERR("FW download failure @%d, "\r\n"over max retry count", offset);\r\nret = -EIO;\r\ngoto done;\r\n}\r\nBT_ERR("FW CRC error indicated by the helper: "\r\n"len = 0x%04X, txlen = %d", len, txlen);\r\nlen &= ~BIT(0);\r\ntxlen = 0;\r\n} else {\r\ncount = 0;\r\nif (firmwarelen - offset < txlen)\r\ntxlen = firmwarelen - offset;\r\ntx_blocks = DIV_ROUND_UP(txlen, blksz_dl);\r\nmemcpy(fwbuf, &firmware[offset], txlen);\r\n}\r\nret = sdio_writesb(card->func, card->ioport, fwbuf,\r\ntx_blocks * blksz_dl);\r\nif (ret < 0) {\r\nBT_ERR("FW download, writesb(%d) failed @%d",\r\ncount, offset);\r\nsdio_writeb(card->func, HOST_CMD53_FIN,\r\ncard->reg->cfg, &ret);\r\nif (ret)\r\nBT_ERR("writeb failed (CFG)");\r\n}\r\noffset += txlen;\r\n} while (true);\r\nBT_DBG("FW download over, size %d bytes", offset);\r\nret = 0;\r\ndone:\r\nkfree(tmpfwbuf);\r\nrelease_firmware(fw_firmware);\r\nreturn ret;\r\n}\r\nstatic int btmrvl_sdio_card_to_host(struct btmrvl_private *priv)\r\n{\r\nu16 buf_len = 0;\r\nint ret, num_blocks, blksz;\r\nstruct sk_buff *skb = NULL;\r\nu32 type;\r\nu8 *payload = NULL;\r\nstruct hci_dev *hdev = priv->btmrvl_dev.hcidev;\r\nstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\r\nif (!card || !card->func) {\r\nBT_ERR("card or function is NULL!");\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nret = btmrvl_sdio_read_rx_len(card, &buf_len);\r\nif (ret < 0) {\r\nBT_ERR("read rx_len failed");\r\nret = -EIO;\r\ngoto exit;\r\n}\r\nblksz = SDIO_BLOCK_SIZE;\r\nnum_blocks = DIV_ROUND_UP(buf_len, blksz);\r\nif (buf_len <= SDIO_HEADER_LEN\r\n|| (num_blocks * blksz) > ALLOC_BUF_SIZE) {\r\nBT_ERR("invalid packet length: %d", buf_len);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nskb = bt_skb_alloc(num_blocks * blksz + BTSDIO_DMA_ALIGN, GFP_ATOMIC);\r\nif (skb == NULL) {\r\nBT_ERR("No free skb");\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nif ((unsigned long) skb->data & (BTSDIO_DMA_ALIGN - 1)) {\r\nskb_put(skb, (unsigned long) skb->data &\r\n(BTSDIO_DMA_ALIGN - 1));\r\nskb_pull(skb, (unsigned long) skb->data &\r\n(BTSDIO_DMA_ALIGN - 1));\r\n}\r\npayload = skb->data;\r\nret = sdio_readsb(card->func, payload, card->ioport,\r\nnum_blocks * blksz);\r\nif (ret < 0) {\r\nBT_ERR("readsb failed: %d", ret);\r\nret = -EIO;\r\ngoto exit;\r\n}\r\nbuf_len = payload[0];\r\nbuf_len |= payload[1] << 8;\r\nbuf_len |= payload[2] << 16;\r\nif (buf_len > blksz * num_blocks) {\r\nBT_ERR("Skip incorrect packet: hdrlen %d buffer %d",\r\nbuf_len, blksz * num_blocks);\r\nret = -EIO;\r\ngoto exit;\r\n}\r\ntype = payload[3];\r\nswitch (type) {\r\ncase HCI_ACLDATA_PKT:\r\ncase HCI_SCODATA_PKT:\r\ncase HCI_EVENT_PKT:\r\nbt_cb(skb)->pkt_type = type;\r\nskb_put(skb, buf_len);\r\nskb_pull(skb, SDIO_HEADER_LEN);\r\nif (type == HCI_EVENT_PKT) {\r\nif (btmrvl_check_evtpkt(priv, skb))\r\nhci_recv_frame(hdev, skb);\r\n} else {\r\nhci_recv_frame(hdev, skb);\r\n}\r\nhdev->stat.byte_rx += buf_len;\r\nbreak;\r\ncase MRVL_VENDOR_PKT:\r\nbt_cb(skb)->pkt_type = HCI_VENDOR_PKT;\r\nskb_put(skb, buf_len);\r\nskb_pull(skb, SDIO_HEADER_LEN);\r\nif (btmrvl_process_event(priv, skb))\r\nhci_recv_frame(hdev, skb);\r\nhdev->stat.byte_rx += buf_len;\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown packet type:%d", type);\r\nBT_ERR("hex: %*ph", blksz * num_blocks, payload);\r\nkfree_skb(skb);\r\nskb = NULL;\r\nbreak;\r\n}\r\nexit:\r\nif (ret) {\r\nhdev->stat.err_rx++;\r\nkfree_skb(skb);\r\n}\r\nreturn ret;\r\n}\r\nstatic int btmrvl_sdio_process_int_status(struct btmrvl_private *priv)\r\n{\r\nulong flags;\r\nu8 ireg;\r\nstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\r\nspin_lock_irqsave(&priv->driver_lock, flags);\r\nireg = sdio_ireg;\r\nsdio_ireg = 0;\r\nspin_unlock_irqrestore(&priv->driver_lock, flags);\r\nsdio_claim_host(card->func);\r\nif (ireg & DN_LD_HOST_INT_STATUS) {\r\nif (priv->btmrvl_dev.tx_dnld_rdy)\r\nBT_DBG("tx_done already received: "\r\n" int_status=0x%x", ireg);\r\nelse\r\npriv->btmrvl_dev.tx_dnld_rdy = true;\r\n}\r\nif (ireg & UP_LD_HOST_INT_STATUS)\r\nbtmrvl_sdio_card_to_host(priv);\r\nsdio_release_host(card->func);\r\nreturn 0;\r\n}\r\nstatic void btmrvl_sdio_interrupt(struct sdio_func *func)\r\n{\r\nstruct btmrvl_private *priv;\r\nstruct btmrvl_sdio_card *card;\r\nulong flags;\r\nu8 ireg = 0;\r\nint ret;\r\ncard = sdio_get_drvdata(func);\r\nif (!card || !card->priv) {\r\nBT_ERR("sbi_interrupt(%p) card or priv is "\r\n"NULL, card=%p\n", func, card);\r\nreturn;\r\n}\r\npriv = card->priv;\r\nireg = sdio_readb(card->func, card->reg->host_intstatus, &ret);\r\nif (ret) {\r\nBT_ERR("sdio_readb: read int status register failed");\r\nreturn;\r\n}\r\nif (ireg != 0) {\r\nBT_DBG("ireg = 0x%x", ireg);\r\nsdio_writeb(card->func, ~(ireg) & (DN_LD_HOST_INT_STATUS |\r\nUP_LD_HOST_INT_STATUS),\r\ncard->reg->host_intstatus, &ret);\r\nif (ret) {\r\nBT_ERR("sdio_writeb: clear int status register failed");\r\nreturn;\r\n}\r\n}\r\nspin_lock_irqsave(&priv->driver_lock, flags);\r\nsdio_ireg |= ireg;\r\nspin_unlock_irqrestore(&priv->driver_lock, flags);\r\nbtmrvl_interrupt(priv);\r\n}\r\nstatic int btmrvl_sdio_register_dev(struct btmrvl_sdio_card *card)\r\n{\r\nstruct sdio_func *func;\r\nu8 reg;\r\nint ret = 0;\r\nif (!card || !card->func) {\r\nBT_ERR("Error: card or function is NULL!");\r\nret = -EINVAL;\r\ngoto failed;\r\n}\r\nfunc = card->func;\r\nsdio_claim_host(func);\r\nret = sdio_enable_func(func);\r\nif (ret) {\r\nBT_ERR("sdio_enable_func() failed: ret=%d", ret);\r\nret = -EIO;\r\ngoto release_host;\r\n}\r\nret = sdio_claim_irq(func, btmrvl_sdio_interrupt);\r\nif (ret) {\r\nBT_ERR("sdio_claim_irq failed: ret=%d", ret);\r\nret = -EIO;\r\ngoto disable_func;\r\n}\r\nret = sdio_set_block_size(card->func, SDIO_BLOCK_SIZE);\r\nif (ret) {\r\nBT_ERR("cannot set SDIO block size");\r\nret = -EIO;\r\ngoto release_irq;\r\n}\r\nreg = sdio_readb(func, card->reg->io_port_0, &ret);\r\nif (ret < 0) {\r\nret = -EIO;\r\ngoto release_irq;\r\n}\r\ncard->ioport = reg;\r\nreg = sdio_readb(func, card->reg->io_port_1, &ret);\r\nif (ret < 0) {\r\nret = -EIO;\r\ngoto release_irq;\r\n}\r\ncard->ioport |= (reg << 8);\r\nreg = sdio_readb(func, card->reg->io_port_2, &ret);\r\nif (ret < 0) {\r\nret = -EIO;\r\ngoto release_irq;\r\n}\r\ncard->ioport |= (reg << 16);\r\nBT_DBG("SDIO FUNC%d IO port: 0x%x", func->num, card->ioport);\r\nsdio_set_drvdata(func, card);\r\nsdio_release_host(func);\r\nreturn 0;\r\nrelease_irq:\r\nsdio_release_irq(func);\r\ndisable_func:\r\nsdio_disable_func(func);\r\nrelease_host:\r\nsdio_release_host(func);\r\nfailed:\r\nreturn ret;\r\n}\r\nstatic int btmrvl_sdio_unregister_dev(struct btmrvl_sdio_card *card)\r\n{\r\nif (card && card->func) {\r\nsdio_claim_host(card->func);\r\nsdio_release_irq(card->func);\r\nsdio_disable_func(card->func);\r\nsdio_release_host(card->func);\r\nsdio_set_drvdata(card->func, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int btmrvl_sdio_enable_host_int(struct btmrvl_sdio_card *card)\r\n{\r\nint ret;\r\nif (!card || !card->func)\r\nreturn -EINVAL;\r\nsdio_claim_host(card->func);\r\nret = btmrvl_sdio_enable_host_int_mask(card, HIM_ENABLE);\r\nbtmrvl_sdio_get_rx_unit(card);\r\nsdio_release_host(card->func);\r\nreturn ret;\r\n}\r\nstatic int btmrvl_sdio_disable_host_int(struct btmrvl_sdio_card *card)\r\n{\r\nint ret;\r\nif (!card || !card->func)\r\nreturn -EINVAL;\r\nsdio_claim_host(card->func);\r\nret = btmrvl_sdio_disable_host_int_mask(card, HIM_DISABLE);\r\nsdio_release_host(card->func);\r\nreturn ret;\r\n}\r\nstatic int btmrvl_sdio_host_to_card(struct btmrvl_private *priv,\r\nu8 *payload, u16 nb)\r\n{\r\nstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\r\nint ret = 0;\r\nint buf_block_len;\r\nint blksz;\r\nint i = 0;\r\nu8 *buf = NULL;\r\nvoid *tmpbuf = NULL;\r\nint tmpbufsz;\r\nif (!card || !card->func) {\r\nBT_ERR("card or function is NULL!");\r\nreturn -EINVAL;\r\n}\r\nbuf = payload;\r\nif ((unsigned long) payload & (BTSDIO_DMA_ALIGN - 1)) {\r\ntmpbufsz = ALIGN_SZ(nb, BTSDIO_DMA_ALIGN);\r\ntmpbuf = kzalloc(tmpbufsz, GFP_KERNEL);\r\nif (!tmpbuf)\r\nreturn -ENOMEM;\r\nbuf = (u8 *) ALIGN_ADDR(tmpbuf, BTSDIO_DMA_ALIGN);\r\nmemcpy(buf, payload, nb);\r\n}\r\nblksz = SDIO_BLOCK_SIZE;\r\nbuf_block_len = DIV_ROUND_UP(nb, blksz);\r\nsdio_claim_host(card->func);\r\ndo {\r\nret = sdio_writesb(card->func, card->ioport, buf,\r\nbuf_block_len * blksz);\r\nif (ret < 0) {\r\ni++;\r\nBT_ERR("i=%d writesb failed: %d", i, ret);\r\nBT_ERR("hex: %*ph", nb, payload);\r\nret = -EIO;\r\nif (i > MAX_WRITE_IOMEM_RETRY)\r\ngoto exit;\r\n}\r\n} while (ret);\r\npriv->btmrvl_dev.tx_dnld_rdy = false;\r\nexit:\r\nsdio_release_host(card->func);\r\nkfree(tmpbuf);\r\nreturn ret;\r\n}\r\nstatic int btmrvl_sdio_download_fw(struct btmrvl_sdio_card *card)\r\n{\r\nint ret;\r\nu8 fws0;\r\nint pollnum = MAX_POLL_TRIES;\r\nif (!card || !card->func) {\r\nBT_ERR("card or function is NULL!");\r\nreturn -EINVAL;\r\n}\r\nif (!btmrvl_sdio_verify_fw_download(card, 1)) {\r\nBT_DBG("Firmware already downloaded!");\r\nreturn 0;\r\n}\r\nsdio_claim_host(card->func);\r\nfws0 = sdio_readb(card->func, card->reg->card_fw_status0, &ret);\r\nif (ret) {\r\nBT_ERR("Failed to read FW downloading status!");\r\nret = -EIO;\r\ngoto done;\r\n}\r\nif (fws0) {\r\nBT_DBG("BT not the winner (%#x). Skip FW downloading", fws0);\r\npollnum *= 10;\r\n} else {\r\nif (card->helper) {\r\nret = btmrvl_sdio_download_helper(card);\r\nif (ret) {\r\nBT_ERR("Failed to download helper!");\r\nret = -EIO;\r\ngoto done;\r\n}\r\n}\r\nif (btmrvl_sdio_download_fw_w_helper(card)) {\r\nBT_ERR("Failed to download firmware!");\r\nret = -EIO;\r\ngoto done;\r\n}\r\n}\r\nsdio_release_host(card->func);\r\nif (btmrvl_sdio_verify_fw_download(card, pollnum)) {\r\nBT_ERR("FW failed to be active in time!");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\ndone:\r\nsdio_release_host(card->func);\r\nreturn ret;\r\n}\r\nstatic int btmrvl_sdio_wakeup_fw(struct btmrvl_private *priv)\r\n{\r\nstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\r\nint ret = 0;\r\nif (!card || !card->func) {\r\nBT_ERR("card or function is NULL!");\r\nreturn -EINVAL;\r\n}\r\nsdio_claim_host(card->func);\r\nsdio_writeb(card->func, HOST_POWER_UP, card->reg->cfg, &ret);\r\nsdio_release_host(card->func);\r\nBT_DBG("wake up firmware");\r\nreturn ret;\r\n}\r\nstatic int btmrvl_sdio_probe(struct sdio_func *func,\r\nconst struct sdio_device_id *id)\r\n{\r\nint ret = 0;\r\nstruct btmrvl_private *priv = NULL;\r\nstruct btmrvl_sdio_card *card = NULL;\r\nBT_INFO("vendor=0x%x, device=0x%x, class=%d, fn=%d",\r\nid->vendor, id->device, id->class, func->num);\r\ncard = devm_kzalloc(&func->dev, sizeof(*card), GFP_KERNEL);\r\nif (!card)\r\nreturn -ENOMEM;\r\ncard->func = func;\r\nif (id->driver_data) {\r\nstruct btmrvl_sdio_device *data = (void *) id->driver_data;\r\ncard->helper = data->helper;\r\ncard->firmware = data->firmware;\r\ncard->reg = data->reg;\r\ncard->sd_blksz_fw_dl = data->sd_blksz_fw_dl;\r\n}\r\nif (btmrvl_sdio_register_dev(card) < 0) {\r\nBT_ERR("Failed to register BT device!");\r\nreturn -ENODEV;\r\n}\r\nbtmrvl_sdio_disable_host_int(card);\r\nif (btmrvl_sdio_download_fw(card)) {\r\nBT_ERR("Downloading firmware failed!");\r\nret = -ENODEV;\r\ngoto unreg_dev;\r\n}\r\nbtmrvl_sdio_enable_host_int(card);\r\npriv = btmrvl_add_card(card);\r\nif (!priv) {\r\nBT_ERR("Initializing card failed!");\r\nret = -ENODEV;\r\ngoto disable_host_int;\r\n}\r\ncard->priv = priv;\r\npriv->hw_host_to_card = btmrvl_sdio_host_to_card;\r\npriv->hw_wakeup_firmware = btmrvl_sdio_wakeup_fw;\r\npriv->hw_process_int_status = btmrvl_sdio_process_int_status;\r\nif (btmrvl_register_hdev(priv)) {\r\nBT_ERR("Register hdev failed!");\r\nret = -ENODEV;\r\ngoto disable_host_int;\r\n}\r\nreturn 0;\r\ndisable_host_int:\r\nbtmrvl_sdio_disable_host_int(card);\r\nunreg_dev:\r\nbtmrvl_sdio_unregister_dev(card);\r\nreturn ret;\r\n}\r\nstatic void btmrvl_sdio_remove(struct sdio_func *func)\r\n{\r\nstruct btmrvl_sdio_card *card;\r\nif (func) {\r\ncard = sdio_get_drvdata(func);\r\nif (card) {\r\nif (user_rmmod) {\r\nbtmrvl_send_module_cfg_cmd(card->priv,\r\nMODULE_SHUTDOWN_REQ);\r\nbtmrvl_sdio_disable_host_int(card);\r\n}\r\nBT_DBG("unregester dev");\r\nbtmrvl_sdio_unregister_dev(card);\r\nbtmrvl_remove_card(card->priv);\r\n}\r\n}\r\n}\r\nstatic int btmrvl_sdio_suspend(struct device *dev)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(dev);\r\nstruct btmrvl_sdio_card *card;\r\nstruct btmrvl_private *priv;\r\nmmc_pm_flag_t pm_flags;\r\nstruct hci_dev *hcidev;\r\nif (func) {\r\npm_flags = sdio_get_host_pm_caps(func);\r\nBT_DBG("%s: suspend: PM flags = 0x%x", sdio_func_id(func),\r\npm_flags);\r\nif (!(pm_flags & MMC_PM_KEEP_POWER)) {\r\nBT_ERR("%s: cannot remain alive while suspended",\r\nsdio_func_id(func));\r\nreturn -ENOSYS;\r\n}\r\ncard = sdio_get_drvdata(func);\r\nif (!card || !card->priv) {\r\nBT_ERR("card or priv structure is not valid");\r\nreturn 0;\r\n}\r\n} else {\r\nBT_ERR("sdio_func is not specified");\r\nreturn 0;\r\n}\r\npriv = card->priv;\r\nif (priv->adapter->hs_state != HS_ACTIVATED) {\r\nif (btmrvl_enable_hs(priv)) {\r\nBT_ERR("HS not actived, suspend failed!");\r\nreturn -EBUSY;\r\n}\r\n}\r\nhcidev = priv->btmrvl_dev.hcidev;\r\nBT_DBG("%s: SDIO suspend", hcidev->name);\r\nhci_suspend_dev(hcidev);\r\nskb_queue_purge(&priv->adapter->tx_queue);\r\npriv->adapter->is_suspended = true;\r\nif (priv->adapter->hs_state == HS_ACTIVATED) {\r\nBT_DBG("suspend with MMC_PM_KEEP_POWER");\r\nreturn sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\r\n} else {\r\nBT_DBG("suspend without MMC_PM_KEEP_POWER");\r\nreturn 0;\r\n}\r\n}\r\nstatic int btmrvl_sdio_resume(struct device *dev)\r\n{\r\nstruct sdio_func *func = dev_to_sdio_func(dev);\r\nstruct btmrvl_sdio_card *card;\r\nstruct btmrvl_private *priv;\r\nmmc_pm_flag_t pm_flags;\r\nstruct hci_dev *hcidev;\r\nif (func) {\r\npm_flags = sdio_get_host_pm_caps(func);\r\nBT_DBG("%s: resume: PM flags = 0x%x", sdio_func_id(func),\r\npm_flags);\r\ncard = sdio_get_drvdata(func);\r\nif (!card || !card->priv) {\r\nBT_ERR("card or priv structure is not valid");\r\nreturn 0;\r\n}\r\n} else {\r\nBT_ERR("sdio_func is not specified");\r\nreturn 0;\r\n}\r\npriv = card->priv;\r\nif (!priv->adapter->is_suspended) {\r\nBT_DBG("device already resumed");\r\nreturn 0;\r\n}\r\npriv->adapter->is_suspended = false;\r\nhcidev = priv->btmrvl_dev.hcidev;\r\nBT_DBG("%s: SDIO resume", hcidev->name);\r\nhci_resume_dev(hcidev);\r\npriv->hw_wakeup_firmware(priv);\r\npriv->adapter->hs_state = HS_DEACTIVATED;\r\nBT_DBG("%s: HS DEACTIVATED in resume!", hcidev->name);\r\nreturn 0;\r\n}\r\nstatic int __init btmrvl_sdio_init_module(void)\r\n{\r\nif (sdio_register_driver(&bt_mrvl_sdio) != 0) {\r\nBT_ERR("SDIO Driver Registration Failed");\r\nreturn -ENODEV;\r\n}\r\nuser_rmmod = 0;\r\nreturn 0;\r\n}\r\nstatic void __exit btmrvl_sdio_exit_module(void)\r\n{\r\nuser_rmmod = 1;\r\nsdio_unregister_driver(&bt_mrvl_sdio);\r\n}
