int zlib_inflate_table(codetype type, unsigned short *lens, unsigned codes,\r\ncode **table, unsigned *bits, unsigned short *work)\r\n{\r\nunsigned len;\r\nunsigned sym;\r\nunsigned min, max;\r\nunsigned root;\r\nunsigned curr;\r\nunsigned drop;\r\nint left;\r\nunsigned used;\r\nunsigned huff;\r\nunsigned incr;\r\nunsigned fill;\r\nunsigned low;\r\nunsigned mask;\r\ncode this;\r\ncode *next;\r\nconst unsigned short *base;\r\nconst unsigned short *extra;\r\nint end;\r\nunsigned short count[MAXBITS+1];\r\nunsigned short offs[MAXBITS+1];\r\nstatic const unsigned short lbase[31] = {\r\n3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\r\n35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\r\nstatic const unsigned short lext[31] = {\r\n16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\r\n19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196};\r\nstatic const unsigned short dbase[32] = {\r\n1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\r\n257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\r\n8193, 12289, 16385, 24577, 0, 0};\r\nstatic const unsigned short dext[32] = {\r\n16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\r\n23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\r\n28, 28, 29, 29, 64, 64};\r\nfor (len = 0; len <= MAXBITS; len++)\r\ncount[len] = 0;\r\nfor (sym = 0; sym < codes; sym++)\r\ncount[lens[sym]]++;\r\nroot = *bits;\r\nfor (max = MAXBITS; max >= 1; max--)\r\nif (count[max] != 0) break;\r\nif (root > max) root = max;\r\nif (max == 0) {\r\nthis.op = (unsigned char)64;\r\nthis.bits = (unsigned char)1;\r\nthis.val = (unsigned short)0;\r\n*(*table)++ = this;\r\n*(*table)++ = this;\r\n*bits = 1;\r\nreturn 0;\r\n}\r\nfor (min = 1; min <= MAXBITS; min++)\r\nif (count[min] != 0) break;\r\nif (root < min) root = min;\r\nleft = 1;\r\nfor (len = 1; len <= MAXBITS; len++) {\r\nleft <<= 1;\r\nleft -= count[len];\r\nif (left < 0) return -1;\r\n}\r\nif (left > 0 && (type == CODES || max != 1))\r\nreturn -1;\r\noffs[1] = 0;\r\nfor (len = 1; len < MAXBITS; len++)\r\noffs[len + 1] = offs[len] + count[len];\r\nfor (sym = 0; sym < codes; sym++)\r\nif (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;\r\nswitch (type) {\r\ncase CODES:\r\nbase = extra = work;\r\nend = 19;\r\nbreak;\r\ncase LENS:\r\nbase = lbase;\r\nbase -= 257;\r\nextra = lext;\r\nextra -= 257;\r\nend = 256;\r\nbreak;\r\ndefault:\r\nbase = dbase;\r\nextra = dext;\r\nend = -1;\r\n}\r\nhuff = 0;\r\nsym = 0;\r\nlen = min;\r\nnext = *table;\r\ncurr = root;\r\ndrop = 0;\r\nlow = (unsigned)(-1);\r\nused = 1U << root;\r\nmask = used - 1;\r\nif (type == LENS && used >= ENOUGH - MAXD)\r\nreturn 1;\r\nfor (;;) {\r\nthis.bits = (unsigned char)(len - drop);\r\nif ((int)(work[sym]) < end) {\r\nthis.op = (unsigned char)0;\r\nthis.val = work[sym];\r\n}\r\nelse if ((int)(work[sym]) > end) {\r\nthis.op = (unsigned char)(extra[work[sym]]);\r\nthis.val = base[work[sym]];\r\n}\r\nelse {\r\nthis.op = (unsigned char)(32 + 64);\r\nthis.val = 0;\r\n}\r\nincr = 1U << (len - drop);\r\nfill = 1U << curr;\r\nmin = fill;\r\ndo {\r\nfill -= incr;\r\nnext[(huff >> drop) + fill] = this;\r\n} while (fill != 0);\r\nincr = 1U << (len - 1);\r\nwhile (huff & incr)\r\nincr >>= 1;\r\nif (incr != 0) {\r\nhuff &= incr - 1;\r\nhuff += incr;\r\n}\r\nelse\r\nhuff = 0;\r\nsym++;\r\nif (--(count[len]) == 0) {\r\nif (len == max) break;\r\nlen = lens[work[sym]];\r\n}\r\nif (len > root && (huff & mask) != low) {\r\nif (drop == 0)\r\ndrop = root;\r\nnext += min;\r\ncurr = len - drop;\r\nleft = (int)(1 << curr);\r\nwhile (curr + drop < max) {\r\nleft -= count[curr + drop];\r\nif (left <= 0) break;\r\ncurr++;\r\nleft <<= 1;\r\n}\r\nused += 1U << curr;\r\nif (type == LENS && used >= ENOUGH - MAXD)\r\nreturn 1;\r\nlow = huff & mask;\r\n(*table)[low].op = (unsigned char)curr;\r\n(*table)[low].bits = (unsigned char)root;\r\n(*table)[low].val = (unsigned short)(next - *table);\r\n}\r\n}\r\nthis.op = (unsigned char)64;\r\nthis.bits = (unsigned char)(len - drop);\r\nthis.val = (unsigned short)0;\r\nwhile (huff != 0) {\r\nif (drop != 0 && (huff & mask) != low) {\r\ndrop = 0;\r\nlen = root;\r\nnext = *table;\r\nthis.bits = (unsigned char)len;\r\n}\r\nnext[huff >> drop] = this;\r\nincr = 1U << (len - 1);\r\nwhile (huff & incr)\r\nincr >>= 1;\r\nif (incr != 0) {\r\nhuff &= incr - 1;\r\nhuff += incr;\r\n}\r\nelse\r\nhuff = 0;\r\n}\r\n*table += used;\r\n*bits = root;\r\nreturn 0;\r\n}
