static int temp_to_code(struct exynos_tmu_data *data, u8 temp)\r\n{\r\nstruct exynos_tmu_platform_data *pdata = data->pdata;\r\nint temp_code;\r\nif (pdata->cal_mode == HW_MODE)\r\nreturn temp;\r\nif (data->soc == SOC_ARCH_EXYNOS4210)\r\nif (temp < 25 || temp > 125) {\r\ntemp_code = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (pdata->cal_type) {\r\ncase TYPE_TWO_POINT_TRIMMING:\r\ntemp_code = (temp - pdata->first_point_trim) *\r\n(data->temp_error2 - data->temp_error1) /\r\n(pdata->second_point_trim - pdata->first_point_trim) +\r\ndata->temp_error1;\r\nbreak;\r\ncase TYPE_ONE_POINT_TRIMMING:\r\ntemp_code = temp + data->temp_error1 - pdata->first_point_trim;\r\nbreak;\r\ndefault:\r\ntemp_code = temp + pdata->default_temp_offset;\r\nbreak;\r\n}\r\nout:\r\nreturn temp_code;\r\n}\r\nstatic int code_to_temp(struct exynos_tmu_data *data, u8 temp_code)\r\n{\r\nstruct exynos_tmu_platform_data *pdata = data->pdata;\r\nint temp;\r\nif (pdata->cal_mode == HW_MODE)\r\nreturn temp_code;\r\nif (data->soc == SOC_ARCH_EXYNOS4210)\r\nif (temp_code < 75 || temp_code > 175) {\r\ntemp = -ENODATA;\r\ngoto out;\r\n}\r\nswitch (pdata->cal_type) {\r\ncase TYPE_TWO_POINT_TRIMMING:\r\ntemp = (temp_code - data->temp_error1) *\r\n(pdata->second_point_trim - pdata->first_point_trim) /\r\n(data->temp_error2 - data->temp_error1) +\r\npdata->first_point_trim;\r\nbreak;\r\ncase TYPE_ONE_POINT_TRIMMING:\r\ntemp = temp_code - data->temp_error1 + pdata->first_point_trim;\r\nbreak;\r\ndefault:\r\ntemp = temp_code - pdata->default_temp_offset;\r\nbreak;\r\n}\r\nout:\r\nreturn temp;\r\n}\r\nstatic int exynos_tmu_initialize(struct platform_device *pdev)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct exynos_tmu_platform_data *pdata = data->pdata;\r\nconst struct exynos_tmu_registers *reg = pdata->registers;\r\nunsigned int status, trim_info = 0, con;\r\nunsigned int rising_threshold = 0, falling_threshold = 0;\r\nint ret = 0, threshold_code, i, trigger_levs = 0;\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\nif (TMU_SUPPORTS(pdata, READY_STATUS)) {\r\nstatus = readb(data->base + reg->tmu_status);\r\nif (!status) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\n}\r\nif (TMU_SUPPORTS(pdata, TRIM_RELOAD))\r\n__raw_writel(1, data->base + reg->triminfo_ctrl);\r\nif (pdata->cal_mode == HW_MODE)\r\ngoto skip_calib_data;\r\nif (data->soc == SOC_ARCH_EXYNOS5440) {\r\nswitch (data->id) {\r\ncase 0:\r\ntrim_info = readl(data->base +\r\nEXYNOS5440_EFUSE_SWAP_OFFSET + reg->triminfo_data);\r\nbreak;\r\ncase 1:\r\ntrim_info = readl(data->base + reg->triminfo_data);\r\nbreak;\r\ncase 2:\r\ntrim_info = readl(data->base -\r\nEXYNOS5440_EFUSE_SWAP_OFFSET + reg->triminfo_data);\r\n}\r\n} else {\r\ntrim_info = readl(data->base + reg->triminfo_data);\r\n}\r\ndata->temp_error1 = trim_info & EXYNOS_TMU_TEMP_MASK;\r\ndata->temp_error2 = ((trim_info >> reg->triminfo_85_shift) &\r\nEXYNOS_TMU_TEMP_MASK);\r\nif (!data->temp_error1 ||\r\n(pdata->min_efuse_value > data->temp_error1) ||\r\n(data->temp_error1 > pdata->max_efuse_value))\r\ndata->temp_error1 = pdata->efuse_value & EXYNOS_TMU_TEMP_MASK;\r\nif (!data->temp_error2)\r\ndata->temp_error2 =\r\n(pdata->efuse_value >> reg->triminfo_85_shift) &\r\nEXYNOS_TMU_TEMP_MASK;\r\nskip_calib_data:\r\nif (pdata->max_trigger_level > MAX_THRESHOLD_LEVS) {\r\ndev_err(&pdev->dev, "Invalid max trigger level\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < pdata->max_trigger_level; i++) {\r\nif (!pdata->trigger_levels[i])\r\ncontinue;\r\nif ((pdata->trigger_type[i] == HW_TRIP) &&\r\n(!pdata->trigger_levels[pdata->max_trigger_level - 1])) {\r\ndev_err(&pdev->dev, "Invalid hw trigger level\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!(pdata->trigger_type[i] == HW_TRIP))\r\ntrigger_levs++;\r\n}\r\nif (data->soc == SOC_ARCH_EXYNOS4210) {\r\nthreshold_code = temp_to_code(data, pdata->threshold);\r\nif (threshold_code < 0) {\r\nret = threshold_code;\r\ngoto out;\r\n}\r\nwriteb(threshold_code,\r\ndata->base + reg->threshold_temp);\r\nfor (i = 0; i < trigger_levs; i++)\r\nwriteb(pdata->trigger_levels[i], data->base +\r\nreg->threshold_th0 + i * sizeof(reg->threshold_th0));\r\nwritel(reg->inten_rise_mask, data->base + reg->tmu_intclear);\r\n} else {\r\nfor (i = 0;\r\ni < trigger_levs && i < EXYNOS_MAX_TRIGGER_PER_REG; i++) {\r\nthreshold_code = temp_to_code(data,\r\npdata->trigger_levels[i]);\r\nif (threshold_code < 0) {\r\nret = threshold_code;\r\ngoto out;\r\n}\r\nrising_threshold |= threshold_code << 8 * i;\r\nif (pdata->threshold_falling) {\r\nthreshold_code = temp_to_code(data,\r\npdata->trigger_levels[i] -\r\npdata->threshold_falling);\r\nif (threshold_code > 0)\r\nfalling_threshold |=\r\nthreshold_code << 8 * i;\r\n}\r\n}\r\nwritel(rising_threshold,\r\ndata->base + reg->threshold_th0);\r\nwritel(falling_threshold,\r\ndata->base + reg->threshold_th1);\r\nwritel((reg->inten_rise_mask << reg->inten_rise_shift) |\r\n(reg->inten_fall_mask << reg->inten_fall_shift),\r\ndata->base + reg->tmu_intclear);\r\ni = pdata->max_trigger_level - 1;\r\nif (pdata->trigger_levels[i] &&\r\n(pdata->trigger_type[i] == HW_TRIP)) {\r\nthreshold_code = temp_to_code(data,\r\npdata->trigger_levels[i]);\r\nif (threshold_code < 0) {\r\nret = threshold_code;\r\ngoto out;\r\n}\r\nif (i == EXYNOS_MAX_TRIGGER_PER_REG - 1) {\r\nrising_threshold |= threshold_code << 8 * i;\r\nwritel(rising_threshold,\r\ndata->base + reg->threshold_th0);\r\n} else if (i == EXYNOS_MAX_TRIGGER_PER_REG) {\r\nrising_threshold =\r\nthreshold_code << reg->threshold_th3_l0_shift;\r\nwritel(rising_threshold,\r\ndata->base + reg->threshold_th2);\r\n}\r\ncon = readl(data->base + reg->tmu_ctrl);\r\ncon |= (1 << reg->therm_trip_en_shift);\r\nwritel(con, data->base + reg->tmu_ctrl);\r\n}\r\n}\r\nif (reg->tmu_pmin && !data->id)\r\nwritel(0, data->base_common + reg->tmu_pmin);\r\nout:\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic void exynos_tmu_control(struct platform_device *pdev, bool on)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct exynos_tmu_platform_data *pdata = data->pdata;\r\nconst struct exynos_tmu_registers *reg = pdata->registers;\r\nunsigned int con, interrupt_en, cal_val;\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\ncon = readl(data->base + reg->tmu_ctrl);\r\nif (pdata->test_mux)\r\ncon |= (pdata->test_mux << reg->test_mux_addr_shift);\r\nif (pdata->reference_voltage) {\r\ncon &= ~(reg->buf_vref_sel_mask << reg->buf_vref_sel_shift);\r\ncon |= pdata->reference_voltage << reg->buf_vref_sel_shift;\r\n}\r\nif (pdata->gain) {\r\ncon &= ~(reg->buf_slope_sel_mask << reg->buf_slope_sel_shift);\r\ncon |= (pdata->gain << reg->buf_slope_sel_shift);\r\n}\r\nif (pdata->noise_cancel_mode) {\r\ncon &= ~(reg->therm_trip_mode_mask <<\r\nreg->therm_trip_mode_shift);\r\ncon |= (pdata->noise_cancel_mode << reg->therm_trip_mode_shift);\r\n}\r\nif (pdata->cal_mode == HW_MODE) {\r\ncon &= ~(reg->calib_mode_mask << reg->calib_mode_shift);\r\ncal_val = 0;\r\nswitch (pdata->cal_type) {\r\ncase TYPE_TWO_POINT_TRIMMING:\r\ncal_val = 3;\r\nbreak;\r\ncase TYPE_ONE_POINT_TRIMMING_85:\r\ncal_val = 2;\r\nbreak;\r\ncase TYPE_ONE_POINT_TRIMMING_25:\r\ncal_val = 1;\r\nbreak;\r\ncase TYPE_NONE:\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Invalid calibration type, using none\n");\r\n}\r\ncon |= cal_val << reg->calib_mode_shift;\r\n}\r\nif (on) {\r\ncon |= (1 << reg->core_en_shift);\r\ninterrupt_en =\r\npdata->trigger_enable[3] << reg->inten_rise3_shift |\r\npdata->trigger_enable[2] << reg->inten_rise2_shift |\r\npdata->trigger_enable[1] << reg->inten_rise1_shift |\r\npdata->trigger_enable[0] << reg->inten_rise0_shift;\r\nif (TMU_SUPPORTS(pdata, FALLING_TRIP))\r\ninterrupt_en |=\r\ninterrupt_en << reg->inten_fall0_shift;\r\n} else {\r\ncon &= ~(1 << reg->core_en_shift);\r\ninterrupt_en = 0;\r\n}\r\nwritel(interrupt_en, data->base + reg->tmu_inten);\r\nwritel(con, data->base + reg->tmu_ctrl);\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic int exynos_tmu_read(struct exynos_tmu_data *data)\r\n{\r\nstruct exynos_tmu_platform_data *pdata = data->pdata;\r\nconst struct exynos_tmu_registers *reg = pdata->registers;\r\nu8 temp_code;\r\nint temp;\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\ntemp_code = readb(data->base + reg->tmu_cur_temp);\r\ntemp = code_to_temp(data, temp_code);\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\nreturn temp;\r\n}\r\nstatic int exynos_tmu_set_emulation(void *drv_data, unsigned long temp)\r\n{\r\nstruct exynos_tmu_data *data = drv_data;\r\nstruct exynos_tmu_platform_data *pdata = data->pdata;\r\nconst struct exynos_tmu_registers *reg = pdata->registers;\r\nunsigned int val;\r\nint ret = -EINVAL;\r\nif (!TMU_SUPPORTS(pdata, EMULATION))\r\ngoto out;\r\nif (temp && temp < MCELSIUS)\r\ngoto out;\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\nval = readl(data->base + reg->emul_con);\r\nif (temp) {\r\ntemp /= MCELSIUS;\r\nif (TMU_SUPPORTS(pdata, EMUL_TIME)) {\r\nval &= ~(EXYNOS_EMUL_TIME_MASK << reg->emul_time_shift);\r\nval |= (EXYNOS_EMUL_TIME << reg->emul_time_shift);\r\n}\r\nval &= ~(EXYNOS_EMUL_DATA_MASK << reg->emul_temp_shift);\r\nval |= (temp_to_code(data, temp) << reg->emul_temp_shift) |\r\nEXYNOS_EMUL_ENABLE;\r\n} else {\r\nval &= ~EXYNOS_EMUL_ENABLE;\r\n}\r\nwritel(val, data->base + reg->emul_con);\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int exynos_tmu_set_emulation(void *drv_data, unsigned long temp)\r\n{ return -EINVAL; }\r\nstatic void exynos_tmu_work(struct work_struct *work)\r\n{\r\nstruct exynos_tmu_data *data = container_of(work,\r\nstruct exynos_tmu_data, irq_work);\r\nstruct exynos_tmu_platform_data *pdata = data->pdata;\r\nconst struct exynos_tmu_registers *reg = pdata->registers;\r\nunsigned int val_irq, val_type;\r\nif (reg->tmu_irqstatus) {\r\nval_type = readl(data->base_common + reg->tmu_irqstatus);\r\nif (!((val_type >> data->id) & 0x1))\r\ngoto out;\r\n}\r\nexynos_report_trigger(data->reg_conf);\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\nval_irq = readl(data->base + reg->tmu_intstat);\r\nwritel(val_irq, data->base + reg->tmu_intclear);\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\nout:\r\nenable_irq(data->irq);\r\n}\r\nstatic irqreturn_t exynos_tmu_irq(int irq, void *id)\r\n{\r\nstruct exynos_tmu_data *data = id;\r\ndisable_irq_nosync(irq);\r\nschedule_work(&data->irq_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline struct exynos_tmu_platform_data *exynos_get_driver_data(\r\nstruct platform_device *pdev, int id)\r\n{\r\nstruct exynos_tmu_init_data *data_table;\r\nstruct exynos_tmu_platform_data *tmu_data;\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(exynos_tmu_match, pdev->dev.of_node);\r\nif (!match)\r\nreturn NULL;\r\ndata_table = (struct exynos_tmu_init_data *) match->data;\r\nif (!data_table || id >= data_table->tmu_count)\r\nreturn NULL;\r\ntmu_data = data_table->tmu_data;\r\nreturn (struct exynos_tmu_platform_data *) (tmu_data + id);\r\n}\r\nstatic int exynos_map_dt_data(struct platform_device *pdev)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct exynos_tmu_platform_data *pdata;\r\nstruct resource res;\r\nint ret;\r\nif (!data || !pdev->dev.of_node)\r\nreturn -ENODEV;\r\ndata->regulator = devm_regulator_get(&pdev->dev, "vtmu");\r\nif (!IS_ERR(data->regulator)) {\r\nret = regulator_enable(data->regulator);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable vtmu\n");\r\nreturn ret;\r\n}\r\n} else {\r\ndev_info(&pdev->dev, "Regulator node (vtmu) not found\n");\r\n}\r\ndata->id = of_alias_get_id(pdev->dev.of_node, "tmuctrl");\r\nif (data->id < 0)\r\ndata->id = 0;\r\ndata->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);\r\nif (data->irq <= 0) {\r\ndev_err(&pdev->dev, "failed to get IRQ\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_address_to_resource(pdev->dev.of_node, 0, &res)) {\r\ndev_err(&pdev->dev, "failed to get Resource 0\n");\r\nreturn -ENODEV;\r\n}\r\ndata->base = devm_ioremap(&pdev->dev, res.start, resource_size(&res));\r\nif (!data->base) {\r\ndev_err(&pdev->dev, "Failed to ioremap memory\n");\r\nreturn -EADDRNOTAVAIL;\r\n}\r\npdata = exynos_get_driver_data(pdev, data->id);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform init data supplied.\n");\r\nreturn -ENODEV;\r\n}\r\ndata->pdata = pdata;\r\nif (!TMU_SUPPORTS(pdata, SHARED_MEMORY))\r\nreturn 0;\r\nif (of_address_to_resource(pdev->dev.of_node, 1, &res)) {\r\ndev_err(&pdev->dev, "failed to get Resource 1\n");\r\nreturn -ENODEV;\r\n}\r\ndata->base_common = devm_ioremap(&pdev->dev, res.start,\r\nresource_size(&res));\r\nif (!data->base_common) {\r\ndev_err(&pdev->dev, "Failed to ioremap memory\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_tmu_probe(struct platform_device *pdev)\r\n{\r\nstruct exynos_tmu_data *data;\r\nstruct exynos_tmu_platform_data *pdata;\r\nstruct thermal_sensor_conf *sensor_conf;\r\nint ret, i;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct exynos_tmu_data),\r\nGFP_KERNEL);\r\nif (!data) {\r\ndev_err(&pdev->dev, "Failed to allocate driver structure\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, data);\r\nmutex_init(&data->lock);\r\nret = exynos_map_dt_data(pdev);\r\nif (ret)\r\nreturn ret;\r\npdata = data->pdata;\r\nINIT_WORK(&data->irq_work, exynos_tmu_work);\r\ndata->clk = devm_clk_get(&pdev->dev, "tmu_apbif");\r\nif (IS_ERR(data->clk)) {\r\ndev_err(&pdev->dev, "Failed to get clock\n");\r\nreturn PTR_ERR(data->clk);\r\n}\r\nret = clk_prepare(data->clk);\r\nif (ret)\r\nreturn ret;\r\nif (pdata->type == SOC_ARCH_EXYNOS4210 ||\r\npdata->type == SOC_ARCH_EXYNOS4412 ||\r\npdata->type == SOC_ARCH_EXYNOS5250 ||\r\npdata->type == SOC_ARCH_EXYNOS5440)\r\ndata->soc = pdata->type;\r\nelse {\r\nret = -EINVAL;\r\ndev_err(&pdev->dev, "Platform not supported\n");\r\ngoto err_clk;\r\n}\r\nret = exynos_tmu_initialize(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to initialize TMU\n");\r\ngoto err_clk;\r\n}\r\nexynos_tmu_control(pdev, true);\r\nsensor_conf = devm_kzalloc(&pdev->dev,\r\nsizeof(struct thermal_sensor_conf), GFP_KERNEL);\r\nif (!sensor_conf) {\r\ndev_err(&pdev->dev, "Failed to allocate registration struct\n");\r\nret = -ENOMEM;\r\ngoto err_clk;\r\n}\r\nsprintf(sensor_conf->name, "therm_zone%d", data->id);\r\nsensor_conf->read_temperature = (int (*)(void *))exynos_tmu_read;\r\nsensor_conf->write_emul_temp =\r\n(int (*)(void *, unsigned long))exynos_tmu_set_emulation;\r\nsensor_conf->driver_data = data;\r\nsensor_conf->trip_data.trip_count = pdata->trigger_enable[0] +\r\npdata->trigger_enable[1] + pdata->trigger_enable[2]+\r\npdata->trigger_enable[3];\r\nfor (i = 0; i < sensor_conf->trip_data.trip_count; i++) {\r\nsensor_conf->trip_data.trip_val[i] =\r\npdata->threshold + pdata->trigger_levels[i];\r\nsensor_conf->trip_data.trip_type[i] =\r\npdata->trigger_type[i];\r\n}\r\nsensor_conf->trip_data.trigger_falling = pdata->threshold_falling;\r\nsensor_conf->cooling_data.freq_clip_count = pdata->freq_tab_count;\r\nfor (i = 0; i < pdata->freq_tab_count; i++) {\r\nsensor_conf->cooling_data.freq_data[i].freq_clip_max =\r\npdata->freq_tab[i].freq_clip_max;\r\nsensor_conf->cooling_data.freq_data[i].temp_level =\r\npdata->freq_tab[i].temp_level;\r\n}\r\nsensor_conf->dev = &pdev->dev;\r\nret = exynos_register_thermal(sensor_conf);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register thermal interface\n");\r\ngoto err_clk;\r\n}\r\ndata->reg_conf = sensor_conf;\r\nret = devm_request_irq(&pdev->dev, data->irq, exynos_tmu_irq,\r\nIRQF_TRIGGER_RISING | IRQF_SHARED, dev_name(&pdev->dev), data);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request irq: %d\n", data->irq);\r\ngoto err_clk;\r\n}\r\nreturn 0;\r\nerr_clk:\r\nclk_unprepare(data->clk);\r\nreturn ret;\r\n}\r\nstatic int exynos_tmu_remove(struct platform_device *pdev)\r\n{\r\nstruct exynos_tmu_data *data = platform_get_drvdata(pdev);\r\nexynos_tmu_control(pdev, false);\r\nexynos_unregister_thermal(data->reg_conf);\r\nclk_unprepare(data->clk);\r\nif (!IS_ERR(data->regulator))\r\nregulator_disable(data->regulator);\r\nreturn 0;\r\n}\r\nstatic int exynos_tmu_suspend(struct device *dev)\r\n{\r\nexynos_tmu_control(to_platform_device(dev), false);\r\nreturn 0;\r\n}\r\nstatic int exynos_tmu_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nexynos_tmu_initialize(pdev);\r\nexynos_tmu_control(pdev, true);\r\nreturn 0;\r\n}
