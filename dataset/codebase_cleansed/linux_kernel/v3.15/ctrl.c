static int\r\nnouveau_control_mthd_pstate_info(struct nouveau_object *object, u32 mthd,\r\nvoid *data, u32 size)\r\n{\r\nstruct nouveau_clock *clk = nouveau_clock(object);\r\nstruct nv_control_pstate_info *args = data;\r\nif (size < sizeof(*args))\r\nreturn -EINVAL;\r\nif (clk) {\r\nargs->count = clk->state_nr;\r\nargs->ustate = clk->ustate;\r\nargs->pstate = clk->pstate;\r\n} else {\r\nargs->count = 0;\r\nargs->ustate = NV_CONTROL_PSTATE_INFO_USTATE_DISABLE;\r\nargs->pstate = NV_CONTROL_PSTATE_INFO_PSTATE_UNKNOWN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_control_mthd_pstate_attr(struct nouveau_object *object, u32 mthd,\r\nvoid *data, u32 size)\r\n{\r\nstruct nouveau_clock *clk = nouveau_clock(object);\r\nstruct nv_control_pstate_attr *args = data;\r\nstruct nouveau_clocks *domain;\r\nstruct nouveau_pstate *pstate;\r\nstruct nouveau_cstate *cstate;\r\nint i = 0, j = -1;\r\nu32 lo, hi;\r\nif ((size < sizeof(*args)) || !clk ||\r\n(args->state >= 0 && args->state >= clk->state_nr))\r\nreturn -EINVAL;\r\ndomain = clk->domains;\r\nwhile (domain->name != nv_clk_src_max) {\r\nif (domain->mname && ++j == args->index)\r\nbreak;\r\ndomain++;\r\n}\r\nif (domain->name == nv_clk_src_max)\r\nreturn -EINVAL;\r\nif (args->state != NV_CONTROL_PSTATE_ATTR_STATE_CURRENT) {\r\nlist_for_each_entry(pstate, &clk->states, head) {\r\nif (i++ == args->state)\r\nbreak;\r\n}\r\nlo = pstate->base.domain[domain->name];\r\nhi = lo;\r\nlist_for_each_entry(cstate, &pstate->list, head) {\r\nlo = min(lo, cstate->domain[domain->name]);\r\nhi = max(hi, cstate->domain[domain->name]);\r\n}\r\nargs->state = pstate->pstate;\r\n} else {\r\nlo = max(clk->read(clk, domain->name), 0);\r\nhi = lo;\r\n}\r\nsnprintf(args->name, sizeof(args->name), "%s", domain->mname);\r\nsnprintf(args->unit, sizeof(args->unit), "MHz");\r\nargs->min = lo / domain->mdiv;\r\nargs->max = hi / domain->mdiv;\r\nargs->index = 0;\r\nwhile ((++domain)->name != nv_clk_src_max) {\r\nif (domain->mname) {\r\nargs->index = ++j;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_control_mthd_pstate_user(struct nouveau_object *object, u32 mthd,\r\nvoid *data, u32 size)\r\n{\r\nstruct nouveau_clock *clk = nouveau_clock(object);\r\nstruct nv_control_pstate_user *args = data;\r\nif (size < sizeof(*args) || !clk)\r\nreturn -EINVAL;\r\nreturn nouveau_clock_ustate(clk, args->state);\r\n}
