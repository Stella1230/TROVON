static void opticon_process_data_packet(struct usb_serial_port *port,\r\nconst unsigned char *buf, size_t len)\r\n{\r\ntty_insert_flip_string(&port->port, buf, len);\r\ntty_flip_buffer_push(&port->port);\r\n}\r\nstatic void opticon_process_status_packet(struct usb_serial_port *port,\r\nconst unsigned char *buf, size_t len)\r\n{\r\nstruct opticon_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (buf[0] == 0x00)\r\npriv->cts = false;\r\nelse\r\npriv->cts = true;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void opticon_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nconst unsigned char *hdr = urb->transfer_buffer;\r\nconst unsigned char *data = hdr + 2;\r\nsize_t data_len = urb->actual_length - 2;\r\nif (urb->actual_length <= 2) {\r\ndev_dbg(&port->dev, "malformed packet received: %d bytes\n",\r\nurb->actual_length);\r\nreturn;\r\n}\r\nif ((hdr[0] == 0x00) && (hdr[1] == 0x00)) {\r\nopticon_process_data_packet(port, data, data_len);\r\n} else if ((hdr[0] == 0x00) && (hdr[1] == 0x01)) {\r\nopticon_process_status_packet(port, data, data_len);\r\n} else {\r\ndev_dbg(&port->dev, "unknown packet received: %02x %02x\n",\r\nhdr[0], hdr[1]);\r\n}\r\n}\r\nstatic int send_control_msg(struct usb_serial_port *port, u8 requesttype,\r\nu8 val)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nint retval;\r\nu8 *buffer;\r\nbuffer = kzalloc(1, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nbuffer[0] = val;\r\nretval = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nrequesttype,\r\nUSB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\r\n0, 0, buffer, 1, 0);\r\nkfree(buffer);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn 0;\r\n}\r\nstatic int opticon_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct opticon_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nint res;\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->rts = false;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nsend_control_msg(port, CONTROL_RTS, 0);\r\nusb_clear_halt(port->serial->dev, port->read_urb->pipe);\r\nres = usb_serial_generic_open(tty, port);\r\nif (!res)\r\nreturn res;\r\nsend_control_msg(port, RESEND_CTS_STATE, 1);\r\nreturn res;\r\n}\r\nstatic void opticon_write_control_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct opticon_private *priv = usb_get_serial_port_data(port);\r\nint status = urb->status;\r\nunsigned long flags;\r\nkfree(urb->transfer_buffer);\r\nkfree(urb->setup_packet);\r\nif (status)\r\ndev_dbg(&port->dev,\r\n"%s - non-zero urb status received: %d\n",\r\n__func__, status);\r\nspin_lock_irqsave(&priv->lock, flags);\r\n--priv->outstanding_urbs;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nusb_serial_port_softint(port);\r\n}\r\nstatic int opticon_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct opticon_private *priv = usb_get_serial_port_data(port);\r\nstruct usb_serial *serial = port->serial;\r\nstruct urb *urb;\r\nunsigned char *buffer;\r\nunsigned long flags;\r\nint status;\r\nstruct usb_ctrlrequest *dr;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->outstanding_urbs > URB_UPPER_LIMIT) {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndev_dbg(&port->dev, "%s - write limit hit\n", __func__);\r\nreturn 0;\r\n}\r\npriv->outstanding_urbs++;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nbuffer = kmalloc(count, GFP_ATOMIC);\r\nif (!buffer) {\r\ncount = -ENOMEM;\r\ngoto error_no_buffer;\r\n}\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\ncount = -ENOMEM;\r\ngoto error_no_urb;\r\n}\r\nmemcpy(buffer, buf, count);\r\nusb_serial_debug_data(&port->dev, __func__, count, buffer);\r\ndr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_NOIO);\r\nif (!dr) {\r\ncount = -ENOMEM;\r\ngoto error_no_dr;\r\n}\r\ndr->bRequestType = USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT;\r\ndr->bRequest = 0x01;\r\ndr->wValue = 0;\r\ndr->wIndex = 0;\r\ndr->wLength = cpu_to_le16(count);\r\nusb_fill_control_urb(urb, serial->dev,\r\nusb_sndctrlpipe(serial->dev, 0),\r\n(unsigned char *)dr, buffer, count,\r\nopticon_write_control_callback, port);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status) {\r\ndev_err(&port->dev,\r\n"%s - usb_submit_urb(write endpoint) failed status = %d\n",\r\n__func__, status);\r\ncount = status;\r\ngoto error;\r\n}\r\nusb_free_urb(urb);\r\nreturn count;\r\nerror:\r\nkfree(dr);\r\nerror_no_dr:\r\nusb_free_urb(urb);\r\nerror_no_urb:\r\nkfree(buffer);\r\nerror_no_buffer:\r\nspin_lock_irqsave(&priv->lock, flags);\r\n--priv->outstanding_urbs;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn count;\r\n}\r\nstatic int opticon_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct opticon_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->outstanding_urbs > URB_UPPER_LIMIT * 2 / 3) {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndev_dbg(&port->dev, "%s - write limit hit\n", __func__);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 2048;\r\n}\r\nstatic int opticon_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct opticon_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nint result = 0;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->rts)\r\nresult |= TIOCM_RTS;\r\nif (priv->cts)\r\nresult |= TIOCM_CTS;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndev_dbg(&port->dev, "%s - %x\n", __func__, result);\r\nreturn result;\r\n}\r\nstatic int opticon_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct opticon_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nbool rts;\r\nbool changed = false;\r\nint ret;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrts = priv->rts;\r\nif (set & TIOCM_RTS)\r\npriv->rts = true;\r\nif (clear & TIOCM_RTS)\r\npriv->rts = false;\r\nchanged = rts ^ priv->rts;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (!changed)\r\nreturn 0;\r\nret = send_control_msg(port, CONTROL_RTS, !rts);\r\nif (ret)\r\nreturn usb_translate_errors(ret);\r\nreturn 0;\r\n}\r\nstatic int get_serial_info(struct usb_serial_port *port,\r\nstruct serial_struct __user *serial)\r\n{\r\nstruct serial_struct tmp;\r\nif (!serial)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0x00, sizeof(tmp));\r\ntmp.type = PORT_16550A;\r\ntmp.line = port->minor;\r\ntmp.port = 0;\r\ntmp.irq = 0;\r\ntmp.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\r\ntmp.xmit_fifo_size = 1024;\r\ntmp.baud_base = 9600;\r\ntmp.close_delay = 5*HZ;\r\ntmp.closing_wait = 30*HZ;\r\nif (copy_to_user(serial, &tmp, sizeof(*serial)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int opticon_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn get_serial_info(port,\r\n(struct serial_struct __user *)arg);\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int opticon_startup(struct usb_serial *serial)\r\n{\r\nif (!serial->num_bulk_in) {\r\ndev_err(&serial->dev->dev, "no bulk in endpoint\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int opticon_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct opticon_private *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&priv->lock);\r\nusb_set_serial_port_data(port, priv);\r\nreturn 0;\r\n}\r\nstatic int opticon_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct opticon_private *priv = usb_get_serial_port_data(port);\r\nkfree(priv);\r\nreturn 0;\r\n}
