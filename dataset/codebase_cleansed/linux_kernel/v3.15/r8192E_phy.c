static u32 rtl8192_CalculateBitShift(u32 dwBitMask)\r\n{\r\nu32 i;\r\nfor (i = 0; i <= 31; i++) {\r\nif (((dwBitMask >> i) & 0x1) == 1)\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nu8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 eRFPath)\r\n{\r\nu8 ret = 1;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->rf_type == RF_2T4R)\r\nret = 0;\r\nelse if (priv->rf_type == RF_1T2R) {\r\nif (eRFPath == RF90_PATH_A || eRFPath == RF90_PATH_B)\r\nret = 1;\r\nelse if (eRFPath == RF90_PATH_C || eRFPath == RF90_PATH_D)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nvoid rtl8192_setBBreg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask,\r\nu32 dwData)\r\n{\r\nu32 OriginalValue, BitShift, NewValue;\r\nif (dwBitMask != bMaskDWord) {\r\nOriginalValue = read_nic_dword(dev, dwRegAddr);\r\nBitShift = rtl8192_CalculateBitShift(dwBitMask);\r\nNewValue = (((OriginalValue) & (~dwBitMask)) |\r\n(dwData << BitShift));\r\nwrite_nic_dword(dev, dwRegAddr, NewValue);\r\n} else\r\nwrite_nic_dword(dev, dwRegAddr, dwData);\r\nreturn;\r\n}\r\nu32 rtl8192_QueryBBReg(struct net_device *dev, u32 dwRegAddr, u32 dwBitMask)\r\n{\r\nu32 Ret = 0, OriginalValue, BitShift;\r\nOriginalValue = read_nic_dword(dev, dwRegAddr);\r\nBitShift = rtl8192_CalculateBitShift(dwBitMask);\r\nRet = (OriginalValue & dwBitMask) >> BitShift;\r\nreturn Ret;\r\n}\r\nstatic u32 rtl8192_phy_RFSerialRead(struct net_device *dev,\r\nenum rf90_radio_path eRFPath, u32 Offset)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 ret = 0;\r\nu32 NewOffset = 0;\r\nstruct bb_reg_definition *pPhyReg = &priv->PHYRegDef[eRFPath];\r\nOffset &= 0x3f;\r\nif (priv->rf_chip == RF_8256) {\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00, 0x0);\r\nif (Offset >= 31) {\r\npriv->RfReg0Value[eRFPath] |= 0x140;\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath]<<16));\r\nNewOffset = Offset - 30;\r\n} else if (Offset >= 16) {\r\npriv->RfReg0Value[eRFPath] |= 0x100;\r\npriv->RfReg0Value[eRFPath] &= (~0x40);\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath]<<16));\r\nNewOffset = Offset - 15;\r\n} else\r\nNewOffset = Offset;\r\n} else {\r\nRT_TRACE((COMP_PHY|COMP_ERR), "check RF type here, need"\r\n" to be 8256\n");\r\nNewOffset = Offset;\r\n}\r\nrtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadAddress,\r\nNewOffset);\r\nrtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadEdge, 0x0);\r\nrtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadEdge, 0x1);\r\nmdelay(1);\r\nret = rtl8192_QueryBBReg(dev, pPhyReg->rfLSSIReadBack,\r\nbLSSIReadBackData);\r\nif (priv->rf_chip == RF_8256) {\r\npriv->RfReg0Value[eRFPath] &= 0xebf;\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord,\r\n(priv->RfReg0Value[eRFPath] << 16));\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3);\r\n}\r\nreturn ret;\r\n}\r\nstatic void rtl8192_phy_RFSerialWrite(struct net_device *dev,\r\nenum rf90_radio_path eRFPath, u32 Offset,\r\nu32 Data)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 DataAndAddr = 0, NewOffset = 0;\r\nstruct bb_reg_definition *pPhyReg = &priv->PHYRegDef[eRFPath];\r\nOffset &= 0x3f;\r\nif (priv->rf_chip == RF_8256) {\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00, 0x0);\r\nif (Offset >= 31) {\r\npriv->RfReg0Value[eRFPath] |= 0x140;\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath] << 16));\r\nNewOffset = Offset - 30;\r\n} else if (Offset >= 16) {\r\npriv->RfReg0Value[eRFPath] |= 0x100;\r\npriv->RfReg0Value[eRFPath] &= (~0x40);\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath] << 16));\r\nNewOffset = Offset - 15;\r\n} else\r\nNewOffset = Offset;\r\n} else {\r\nRT_TRACE((COMP_PHY|COMP_ERR), "check RF type here, need to be"\r\n" 8256\n");\r\nNewOffset = Offset;\r\n}\r\nDataAndAddr = (Data<<16) | (NewOffset&0x3f);\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);\r\nif (Offset == 0x0)\r\npriv->RfReg0Value[eRFPath] = Data;\r\nif (priv->rf_chip == RF_8256) {\r\nif (Offset != 0) {\r\npriv->RfReg0Value[eRFPath] &= 0xebf;\r\nrtl8192_setBBreg(\r\ndev,\r\npPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\n(priv->RfReg0Value[eRFPath] << 16));\r\n}\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3);\r\n}\r\nreturn;\r\n}\r\nvoid rtl8192_phy_SetRFReg(struct net_device *dev, enum rf90_radio_path eRFPath,\r\nu32 RegAddr, u32 BitMask, u32 Data)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 Original_Value, BitShift, New_Value;\r\nif (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))\r\nreturn;\r\nif (priv->rtllib->eRFPowerState != eRfOn && !priv->being_init_adapter)\r\nreturn;\r\nRT_TRACE(COMP_PHY, "FW RF CTRL is not ready now\n");\r\nif (priv->Rf_Mode == RF_OP_By_FW) {\r\nif (BitMask != bMask12Bits) {\r\nOriginal_Value = phy_FwRFSerialRead(dev, eRFPath,\r\nRegAddr);\r\nBitShift = rtl8192_CalculateBitShift(BitMask);\r\nNew_Value = (((Original_Value) & (~BitMask)) |\r\n(Data << BitShift));\r\nphy_FwRFSerialWrite(dev, eRFPath, RegAddr, New_Value);\r\n} else\r\nphy_FwRFSerialWrite(dev, eRFPath, RegAddr, Data);\r\nudelay(200);\r\n} else {\r\nif (BitMask != bMask12Bits) {\r\nOriginal_Value = rtl8192_phy_RFSerialRead(dev, eRFPath,\r\nRegAddr);\r\nBitShift = rtl8192_CalculateBitShift(BitMask);\r\nNew_Value = (((Original_Value) & (~BitMask)) |\r\n(Data << BitShift));\r\nrtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr,\r\nNew_Value);\r\n} else\r\nrtl8192_phy_RFSerialWrite(dev, eRFPath, RegAddr, Data);\r\n}\r\nreturn;\r\n}\r\nu32 rtl8192_phy_QueryRFReg(struct net_device *dev, enum rf90_radio_path eRFPath,\r\nu32 RegAddr, u32 BitMask)\r\n{\r\nu32 Original_Value, Readback_Value, BitShift;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))\r\nreturn 0;\r\nif (priv->rtllib->eRFPowerState != eRfOn && !priv->being_init_adapter)\r\nreturn 0;\r\ndown(&priv->rf_sem);\r\nif (priv->Rf_Mode == RF_OP_By_FW) {\r\nOriginal_Value = phy_FwRFSerialRead(dev, eRFPath, RegAddr);\r\nudelay(200);\r\n} else {\r\nOriginal_Value = rtl8192_phy_RFSerialRead(dev, eRFPath,\r\nRegAddr);\r\n}\r\nBitShift = rtl8192_CalculateBitShift(BitMask);\r\nReadback_Value = (Original_Value & BitMask) >> BitShift;\r\nup(&priv->rf_sem);\r\nreturn Readback_Value;\r\n}\r\nstatic u32 phy_FwRFSerialRead(struct net_device *dev,\r\nenum rf90_radio_path eRFPath, u32 Offset)\r\n{\r\nu32 retValue = 0;\r\nu32 Data = 0;\r\nu8 time = 0;\r\nData |= ((Offset & 0xFF) << 12);\r\nData |= ((eRFPath & 0x3) << 20);\r\nData |= 0x80000000;\r\nwhile (read_nic_dword(dev, QPNR)&0x80000000) {\r\nif (time++ < 100)\r\nudelay(10);\r\nelse\r\nbreak;\r\n}\r\nwrite_nic_dword(dev, QPNR, Data);\r\nwhile (read_nic_dword(dev, QPNR) & 0x80000000) {\r\nif (time++ < 100)\r\nudelay(10);\r\nelse\r\nreturn 0;\r\n}\r\nretValue = read_nic_dword(dev, RF_DATA);\r\nreturn retValue;\r\n}\r\nstatic void phy_FwRFSerialWrite(struct net_device *dev,\r\nenum rf90_radio_path eRFPath,\r\nu32 Offset, u32 Data)\r\n{\r\nu8 time = 0;\r\nData |= ((Offset & 0xFF) << 12);\r\nData |= ((eRFPath & 0x3) << 20);\r\nData |= 0x400000;\r\nData |= 0x80000000;\r\nwhile (read_nic_dword(dev, QPNR) & 0x80000000) {\r\nif (time++ < 100)\r\nudelay(10);\r\nelse\r\nbreak;\r\n}\r\nwrite_nic_dword(dev, QPNR, Data);\r\n}\r\nvoid rtl8192_phy_configmac(struct net_device *dev)\r\n{\r\nu32 dwArrayLen = 0, i = 0;\r\nu32 *pdwArray = NULL;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->bTXPowerDataReadFromEEPORM) {\r\nRT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array_PG\n");\r\ndwArrayLen = MACPHY_Array_PGLength;\r\npdwArray = Rtl819XMACPHY_Array_PG;\r\n} else {\r\nRT_TRACE(COMP_PHY, "Read rtl819XMACPHY_Array\n");\r\ndwArrayLen = MACPHY_ArrayLength;\r\npdwArray = Rtl819XMACPHY_Array;\r\n}\r\nfor (i = 0; i < dwArrayLen; i += 3) {\r\nRT_TRACE(COMP_DBG, "The Rtl8190MACPHY_Array[0] is %x Rtl8190MAC"\r\n"PHY_Array[1] is %x Rtl8190MACPHY_Array[2] is %x\n",\r\npdwArray[i], pdwArray[i+1], pdwArray[i+2]);\r\nif (pdwArray[i] == 0x318)\r\npdwArray[i+2] = 0x00000800;\r\nrtl8192_setBBreg(dev, pdwArray[i], pdwArray[i+1],\r\npdwArray[i+2]);\r\n}\r\nreturn;\r\n}\r\nvoid rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)\r\n{\r\nint i;\r\nu32 *Rtl819XPHY_REGArray_Table = NULL;\r\nu32 *Rtl819XAGCTAB_Array_Table = NULL;\r\nu16 AGCTAB_ArrayLen, PHY_REGArrayLen = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nAGCTAB_ArrayLen = AGCTAB_ArrayLength;\r\nRtl819XAGCTAB_Array_Table = Rtl819XAGCTAB_Array;\r\nif (priv->rf_type == RF_2T4R) {\r\nPHY_REGArrayLen = PHY_REGArrayLength;\r\nRtl819XPHY_REGArray_Table = Rtl819XPHY_REGArray;\r\n} else if (priv->rf_type == RF_1T2R) {\r\nPHY_REGArrayLen = PHY_REG_1T2RArrayLength;\r\nRtl819XPHY_REGArray_Table = Rtl819XPHY_REG_1T2RArray;\r\n}\r\nif (ConfigType == BaseBand_Config_PHY_REG) {\r\nfor (i = 0; i < PHY_REGArrayLen; i += 2) {\r\nrtl8192_setBBreg(dev, Rtl819XPHY_REGArray_Table[i],\r\nbMaskDWord,\r\nRtl819XPHY_REGArray_Table[i+1]);\r\nRT_TRACE(COMP_DBG, "i: %x, The Rtl819xUsbPHY_REGArray"\r\n"[0] is %x Rtl819xUsbPHY_REGArray[1] is %x\n",\r\ni, Rtl819XPHY_REGArray_Table[i],\r\nRtl819XPHY_REGArray_Table[i+1]);\r\n}\r\n} else if (ConfigType == BaseBand_Config_AGC_TAB) {\r\nfor (i = 0; i < AGCTAB_ArrayLen; i += 2) {\r\nrtl8192_setBBreg(dev, Rtl819XAGCTAB_Array_Table[i],\r\nbMaskDWord,\r\nRtl819XAGCTAB_Array_Table[i+1]);\r\nRT_TRACE(COMP_DBG, "i:%x, The rtl819XAGCTAB_Array[0] "\r\n"is %x rtl819XAGCTAB_Array[1] is %x\n", i,\r\nRtl819XAGCTAB_Array_Table[i],\r\nRtl819XAGCTAB_Array_Table[i+1]);\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void rtl8192_InitBBRFRegDef(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->PHYRegDef[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfo = rFPGA0_XC_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfo = rFPGA0_XD_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfe = rFPGA0_XC_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfe = rFPGA0_XD_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_B].rf3wireOffset = rFPGA0_XB_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_C].rf3wireOffset = rFPGA0_XC_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_D].rf3wireOffset = rFPGA0_XD_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_A].rfLSSI_Select = rFPGA0_XAB_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_B].rfLSSI_Select = rFPGA0_XAB_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_C].rfLSSI_Select = rFPGA0_XCD_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_D].rfLSSI_Select = rFPGA0_XCD_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_A].rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_B].rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_C].rfHSSIPara1 = rFPGA0_XC_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_D].rfHSSIPara1 = rFPGA0_XD_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_C].rfHSSIPara2 = rFPGA0_XC_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_D].rfHSSIPara2 = rFPGA0_XD_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_A].rfSwitchControl = rFPGA0_XAB_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_B].rfSwitchControl = rFPGA0_XAB_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_C].rfSwitchControl = rFPGA0_XCD_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_D].rfSwitchControl = rFPGA0_XCD_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_A].rfAGCControl1 = rOFDM0_XAAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_B].rfAGCControl1 = rOFDM0_XBAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_C].rfAGCControl1 = rOFDM0_XCAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_D].rfAGCControl1 = rOFDM0_XDAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_A].rfAGCControl2 = rOFDM0_XAAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_B].rfAGCControl2 = rOFDM0_XBAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_C].rfAGCControl2 = rOFDM0_XCAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_D].rfAGCControl2 = rOFDM0_XDAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_A].rfRxIQImbalance = rOFDM0_XARxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_B].rfRxIQImbalance = rOFDM0_XBRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_C].rfRxIQImbalance = rOFDM0_XCRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_D].rfRxIQImbalance = rOFDM0_XDRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_A].rfRxAFE = rOFDM0_XARxAFE;\r\npriv->PHYRegDef[RF90_PATH_B].rfRxAFE = rOFDM0_XBRxAFE;\r\npriv->PHYRegDef[RF90_PATH_C].rfRxAFE = rOFDM0_XCRxAFE;\r\npriv->PHYRegDef[RF90_PATH_D].rfRxAFE = rOFDM0_XDRxAFE;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxIQImbalance = rOFDM0_XATxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxIQImbalance = rOFDM0_XBTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxIQImbalance = rOFDM0_XCTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxIQImbalance = rOFDM0_XDTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxAFE = rOFDM0_XATxAFE;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxAFE = rOFDM0_XBTxAFE;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxAFE = rOFDM0_XCTxAFE;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxAFE = rOFDM0_XDTxAFE;\r\npriv->PHYRegDef[RF90_PATH_A].rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_C].rfLSSIReadBack = rFPGA0_XC_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_D].rfLSSIReadBack = rFPGA0_XD_LSSIReadBack;\r\n}\r\nbool rtl8192_phy_checkBBAndRF(struct net_device *dev,\r\nenum hw90_block CheckBlock,\r\nenum rf90_radio_path eRFPath)\r\n{\r\nbool ret = true;\r\nu32 i, CheckTimes = 4, dwRegRead = 0;\r\nu32 WriteAddr[4];\r\nu32 WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};\r\nWriteAddr[HW90_BLOCK_MAC] = 0x100;\r\nWriteAddr[HW90_BLOCK_PHY0] = 0x900;\r\nWriteAddr[HW90_BLOCK_PHY1] = 0x800;\r\nWriteAddr[HW90_BLOCK_RF] = 0x3;\r\nRT_TRACE(COMP_PHY, "=======>%s(), CheckBlock:%d\n", __func__,\r\nCheckBlock);\r\nfor (i = 0; i < CheckTimes; i++) {\r\nswitch (CheckBlock) {\r\ncase HW90_BLOCK_MAC:\r\nRT_TRACE(COMP_ERR, "PHY_CheckBBRFOK(): Never Write "\r\n"0x100 here!");\r\nbreak;\r\ncase HW90_BLOCK_PHY0:\r\ncase HW90_BLOCK_PHY1:\r\nwrite_nic_dword(dev, WriteAddr[CheckBlock],\r\nWriteData[i]);\r\ndwRegRead = read_nic_dword(dev, WriteAddr[CheckBlock]);\r\nbreak;\r\ncase HW90_BLOCK_RF:\r\nWriteData[i] &= 0xfff;\r\nrtl8192_phy_SetRFReg(dev, eRFPath,\r\nWriteAddr[HW90_BLOCK_RF],\r\nbMask12Bits, WriteData[i]);\r\nmdelay(10);\r\ndwRegRead = rtl8192_phy_QueryRFReg(dev, eRFPath,\r\nWriteAddr[HW90_BLOCK_RF],\r\nbMaskDWord);\r\nmdelay(10);\r\nbreak;\r\ndefault:\r\nret = false;\r\nbreak;\r\n}\r\nif (dwRegRead != WriteData[i]) {\r\nRT_TRACE(COMP_ERR, "====>error=====dwRegRead: %x, "\r\n"WriteData: %x\n", dwRegRead, WriteData[i]);\r\nret = false;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic bool rtl8192_BB_Config_ParaFile(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nbool rtStatus = true;\r\nu8 bRegValue = 0, eCheckItem = 0;\r\nu32 dwRegValue = 0;\r\nbRegValue = read_nic_byte(dev, BB_GLOBAL_RESET);\r\nwrite_nic_byte(dev, BB_GLOBAL_RESET, (bRegValue|BB_GLOBAL_RESET_BIT));\r\ndwRegValue = read_nic_dword(dev, CPU_GEN);\r\nwrite_nic_dword(dev, CPU_GEN, (dwRegValue&(~CPU_GEN_BB_RST)));\r\nfor (eCheckItem = (enum hw90_block)HW90_BLOCK_PHY0;\r\neCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {\r\nrtStatus = rtl8192_phy_checkBBAndRF(dev,\r\n(enum hw90_block)eCheckItem,\r\n(enum rf90_radio_path)0);\r\nif (!rtStatus) {\r\nRT_TRACE((COMP_ERR | COMP_PHY), "PHY_RF8256_Config():"\r\n"Check PHY%d Fail!!\n", eCheckItem-1);\r\nreturn rtStatus;\r\n}\r\n}\r\nrtl8192_setBBreg(dev, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x0);\r\nrtl8192_phyConfigBB(dev, BaseBand_Config_PHY_REG);\r\ndwRegValue = read_nic_dword(dev, CPU_GEN);\r\nwrite_nic_dword(dev, CPU_GEN, (dwRegValue|CPU_GEN_BB_RST));\r\nrtl8192_phyConfigBB(dev, BaseBand_Config_AGC_TAB);\r\nif (priv->IC_Cut > VERSION_8190_BD) {\r\nif (priv->rf_type == RF_2T4R)\r\ndwRegValue = (priv->AntennaTxPwDiff[2]<<8 |\r\npriv->AntennaTxPwDiff[1]<<4 |\r\npriv->AntennaTxPwDiff[0]);\r\nelse\r\ndwRegValue = 0x0;\r\nrtl8192_setBBreg(dev, rFPGA0_TxGainStage,\r\n(bXBTxAGC|bXCTxAGC|bXDTxAGC), dwRegValue);\r\ndwRegValue = priv->CrystalCap;\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, bXtalCap92x,\r\ndwRegValue);\r\n}\r\nreturn rtStatus;\r\n}\r\nbool rtl8192_BBConfig(struct net_device *dev)\r\n{\r\nbool rtStatus = true;\r\nrtl8192_InitBBRFRegDef(dev);\r\nrtStatus = rtl8192_BB_Config_ParaFile(dev);\r\nreturn rtStatus;\r\n}\r\nvoid rtl8192_phy_getTxPower(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->MCSTxPowerLevelOriginalOffset[0] =\r\nread_nic_dword(dev, rTxAGC_Rate18_06);\r\npriv->MCSTxPowerLevelOriginalOffset[1] =\r\nread_nic_dword(dev, rTxAGC_Rate54_24);\r\npriv->MCSTxPowerLevelOriginalOffset[2] =\r\nread_nic_dword(dev, rTxAGC_Mcs03_Mcs00);\r\npriv->MCSTxPowerLevelOriginalOffset[3] =\r\nread_nic_dword(dev, rTxAGC_Mcs07_Mcs04);\r\npriv->MCSTxPowerLevelOriginalOffset[4] =\r\nread_nic_dword(dev, rTxAGC_Mcs11_Mcs08);\r\npriv->MCSTxPowerLevelOriginalOffset[5] =\r\nread_nic_dword(dev, rTxAGC_Mcs15_Mcs12);\r\npriv->DefaultInitialGain[0] = read_nic_byte(dev, rOFDM0_XAAGCCore1);\r\npriv->DefaultInitialGain[1] = read_nic_byte(dev, rOFDM0_XBAGCCore1);\r\npriv->DefaultInitialGain[2] = read_nic_byte(dev, rOFDM0_XCAGCCore1);\r\npriv->DefaultInitialGain[3] = read_nic_byte(dev, rOFDM0_XDAGCCore1);\r\nRT_TRACE(COMP_INIT, "Default initial gain (c50=0x%x, c58=0x%x, "\r\n"c60=0x%x, c68=0x%x)\n",\r\npriv->DefaultInitialGain[0], priv->DefaultInitialGain[1],\r\npriv->DefaultInitialGain[2], priv->DefaultInitialGain[3]);\r\npriv->framesync = read_nic_byte(dev, rOFDM0_RxDetector3);\r\npriv->framesyncC34 = read_nic_dword(dev, rOFDM0_RxDetector2);\r\nRT_TRACE(COMP_INIT, "Default framesync (0x%x) = 0x%x\n",\r\nrOFDM0_RxDetector3, priv->framesync);\r\npriv->SifsTime = read_nic_word(dev, SIFS);\r\nreturn;\r\n}\r\nvoid rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 powerlevel = 0, powerlevelOFDM24G = 0;\r\nchar ant_pwr_diff;\r\nu32 u4RegValue;\r\nif (priv->epromtype == EEPROM_93C46) {\r\npowerlevel = priv->TxPowerLevelCCK[channel-1];\r\npowerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];\r\n} else if (priv->epromtype == EEPROM_93C56) {\r\nif (priv->rf_type == RF_1T2R) {\r\npowerlevel = priv->TxPowerLevelCCK_C[channel-1];\r\npowerlevelOFDM24G = priv->TxPowerLevelOFDM24G_C[channel-1];\r\n} else if (priv->rf_type == RF_2T4R) {\r\npowerlevel = priv->TxPowerLevelCCK_A[channel-1];\r\npowerlevelOFDM24G = priv->TxPowerLevelOFDM24G_A[channel-1];\r\nant_pwr_diff = priv->TxPowerLevelOFDM24G_C[channel-1]\r\n- priv->TxPowerLevelOFDM24G_A[channel-1];\r\npriv->RF_C_TxPwDiff = ant_pwr_diff;\r\nant_pwr_diff &= 0xf;\r\npriv->AntennaTxPwDiff[2] = 0;\r\npriv->AntennaTxPwDiff[1] = (u8)(ant_pwr_diff);\r\npriv->AntennaTxPwDiff[0] = 0;\r\nu4RegValue = (priv->AntennaTxPwDiff[2]<<8 |\r\npriv->AntennaTxPwDiff[1]<<4 |\r\npriv->AntennaTxPwDiff[0]);\r\nrtl8192_setBBreg(dev, rFPGA0_TxGainStage,\r\n(bXBTxAGC|bXCTxAGC|bXDTxAGC), u4RegValue);\r\n}\r\n}\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\nbreak;\r\ncase RF_8256:\r\nPHY_SetRF8256CCKTxPower(dev, powerlevel);\r\nPHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "unknown rf chip in function %s()\n",\r\n__func__);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nbool rtl8192_phy_RFConfig(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nbool rtStatus = true;\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\nbreak;\r\ncase RF_8256:\r\nrtStatus = PHY_RF8256_Config(dev);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ncase RF_PSEUDO_11N:\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "error chip id\n");\r\nbreak;\r\n}\r\nreturn rtStatus;\r\n}\r\nvoid rtl8192_phy_updateInitGain(struct net_device *dev)\r\n{\r\nreturn;\r\n}\r\nu8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,\r\nenum rf90_radio_path eRFPath)\r\n{\r\nint i;\r\nu8 ret = 0;\r\nswitch (eRFPath) {\r\ncase RF90_PATH_A:\r\nfor (i = 0; i < RadioA_ArrayLength; i += 2) {\r\nif (Rtl819XRadioA_Array[i] == 0xfe) {\r\nmsleep(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(dev, eRFPath,\r\nRtl819XRadioA_Array[i],\r\nbMask12Bits,\r\nRtl819XRadioA_Array[i+1]);\r\n}\r\nbreak;\r\ncase RF90_PATH_B:\r\nfor (i = 0; i < RadioB_ArrayLength; i += 2) {\r\nif (Rtl819XRadioB_Array[i] == 0xfe) {\r\nmsleep(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(dev, eRFPath,\r\nRtl819XRadioB_Array[i],\r\nbMask12Bits,\r\nRtl819XRadioB_Array[i+1]);\r\n}\r\nbreak;\r\ncase RF90_PATH_C:\r\nfor (i = 0; i < RadioC_ArrayLength; i += 2) {\r\nif (Rtl819XRadioC_Array[i] == 0xfe) {\r\nmsleep(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(dev, eRFPath,\r\nRtl819XRadioC_Array[i],\r\nbMask12Bits,\r\nRtl819XRadioC_Array[i+1]);\r\n}\r\nbreak;\r\ncase RF90_PATH_D:\r\nfor (i = 0; i < RadioD_ArrayLength; i += 2) {\r\nif (Rtl819XRadioD_Array[i] == 0xfe) {\r\nmsleep(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(dev, eRFPath,\r\nRtl819XRadioD_Array[i], bMask12Bits,\r\nRtl819XRadioD_Array[i+1]);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 powerlevel = priv->TxPowerLevelCCK[channel-1];\r\nu8 powerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\nbreak;\r\ncase RF_8256:\r\nPHY_SetRF8256CCKTxPower(dev, powerlevel);\r\nPHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "unknown rf chip ID in rtl8192_SetTxPower"\r\n"Level()\n");\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic u8 rtl8192_phy_SetSwChnlCmdArray(struct sw_chnl_cmd *CmdTable,\r\nu32 CmdTableIdx, u32 CmdTableSz,\r\nenum sw_chnl_cmd_id CmdID,\r\nu32 Para1, u32 Para2, u32 msDelay)\r\n{\r\nstruct sw_chnl_cmd *pCmd;\r\nif (CmdTable == NULL) {\r\nRT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): CmdTable cannot "\r\n"be NULL.\n");\r\nreturn false;\r\n}\r\nif (CmdTableIdx >= CmdTableSz) {\r\nRT_TRACE(COMP_ERR, "phy_SetSwChnlCmdArray(): Access invalid"\r\n" index, please check size of the table, CmdTableIdx:"\r\n"%d, CmdTableSz:%d\n",\r\nCmdTableIdx, CmdTableSz);\r\nreturn false;\r\n}\r\npCmd = CmdTable + CmdTableIdx;\r\npCmd->CmdID = CmdID;\r\npCmd->Para1 = Para1;\r\npCmd->Para2 = Para2;\r\npCmd->msDelay = msDelay;\r\nreturn true;\r\n}\r\nstatic u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,\r\nu8 *stage, u8 *step, u32 *delay)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nu32 PreCommonCmdCnt;\r\nu32 PostCommonCmdCnt;\r\nu32 RfDependCmdCnt;\r\nstruct sw_chnl_cmd *CurrentCmd = NULL;\r\nu8 eRFPath;\r\nRT_TRACE(COMP_TRACE, "====>%s()====stage:%d, step:%d, channel:%d\n",\r\n__func__, *stage, *step, channel);\r\nif (!rtllib_legal_channel(priv->rtllib, channel)) {\r\nRT_TRACE(COMP_ERR, "=============>set to illegal channel:%d\n",\r\nchannel);\r\nreturn true;\r\n}\r\n{\r\nPreCommonCmdCnt = 0;\r\nrtl8192_phy_SetSwChnlCmdArray(ieee->PreCommonCmd,\r\nPreCommonCmdCnt++,\r\nMAX_PRECMD_CNT, CmdID_SetTxPowerLevel,\r\n0, 0, 0);\r\nrtl8192_phy_SetSwChnlCmdArray(ieee->PreCommonCmd,\r\nPreCommonCmdCnt++,\r\nMAX_PRECMD_CNT, CmdID_End, 0, 0, 0);\r\nPostCommonCmdCnt = 0;\r\nrtl8192_phy_SetSwChnlCmdArray(ieee->PostCommonCmd,\r\nPostCommonCmdCnt++,\r\nMAX_POSTCMD_CNT, CmdID_End, 0, 0, 0);\r\nRfDependCmdCnt = 0;\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\nif (!(channel >= 1 && channel <= 14)) {\r\nRT_TRACE(COMP_ERR, "illegal channel for Zebra "\r\n"8225: %d\n", channel);\r\nreturn false;\r\n}\r\nrtl8192_phy_SetSwChnlCmdArray(ieee->RfDependCmd,\r\nRfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,\r\nCmdID_RF_WriteReg, rZebra1_Channel,\r\nRF_CHANNEL_TABLE_ZEBRA[channel], 10);\r\nrtl8192_phy_SetSwChnlCmdArray(ieee->RfDependCmd,\r\nRfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,\r\nCmdID_End, 0, 0, 0);\r\nbreak;\r\ncase RF_8256:\r\nif (!(channel >= 1 && channel <= 14)) {\r\nRT_TRACE(COMP_ERR, "illegal channel for Zebra"\r\n" 8256: %d\n", channel);\r\nreturn false;\r\n}\r\nrtl8192_phy_SetSwChnlCmdArray(ieee->RfDependCmd,\r\nRfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,\r\nCmdID_RF_WriteReg, rZebra1_Channel, channel,\r\n10);\r\nrtl8192_phy_SetSwChnlCmdArray(ieee->RfDependCmd,\r\nRfDependCmdCnt++,\r\nMAX_RFDEPENDCMD_CNT,\r\nCmdID_End, 0, 0, 0);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n",\r\npriv->rf_chip);\r\nreturn false;\r\nbreak;\r\n}\r\ndo {\r\nswitch (*stage) {\r\ncase 0:\r\nCurrentCmd = &ieee->PreCommonCmd[*step];\r\nbreak;\r\ncase 1:\r\nCurrentCmd = &ieee->RfDependCmd[*step];\r\nbreak;\r\ncase 2:\r\nCurrentCmd = &ieee->PostCommonCmd[*step];\r\nbreak;\r\n}\r\nif (CurrentCmd && CurrentCmd->CmdID == CmdID_End) {\r\nif ((*stage) == 2) {\r\nreturn true;\r\n} else {\r\n(*stage)++;\r\n(*step) = 0;\r\ncontinue;\r\n}\r\n}\r\nif (!CurrentCmd)\r\ncontinue;\r\nswitch (CurrentCmd->CmdID) {\r\ncase CmdID_SetTxPowerLevel:\r\nif (priv->IC_Cut > (u8)VERSION_8190_BD)\r\nrtl8192_SetTxPowerLevel(dev, channel);\r\nbreak;\r\ncase CmdID_WritePortUlong:\r\nwrite_nic_dword(dev, CurrentCmd->Para1,\r\nCurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_WritePortUshort:\r\nwrite_nic_word(dev, CurrentCmd->Para1,\r\n(u16)CurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_WritePortUchar:\r\nwrite_nic_byte(dev, CurrentCmd->Para1,\r\n(u8)CurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_RF_WriteReg:\r\nfor (eRFPath = 0; eRFPath <\r\npriv->NumTotalRFPath; eRFPath++)\r\nrtl8192_phy_SetRFReg(dev,\r\n(enum rf90_radio_path)eRFPath,\r\nCurrentCmd->Para1, bMask12Bits,\r\nCurrentCmd->Para2<<7);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n} while (true);\r\n}\r\n(*delay) = CurrentCmd->msDelay;\r\n(*step)++;\r\nreturn false;\r\n}\r\nstatic void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 delay = 0;\r\nwhile (!rtl8192_phy_SwChnlStepByStep(dev, channel, &priv->SwChnlStage,\r\n&priv->SwChnlStep, &delay)) {\r\nif (delay > 0)\r\nmsleep(delay);\r\nif (IS_NIC_DOWN(priv))\r\nbreak;\r\n}\r\n}\r\nvoid rtl8192_SwChnl_WorkItem(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nRT_TRACE(COMP_TRACE, "==> SwChnlCallback819xUsbWorkItem()\n");\r\nRT_TRACE(COMP_TRACE, "=====>--%s(), set chan:%d, priv:%p\n", __func__,\r\npriv->chan, priv);\r\nrtl8192_phy_FinishSwChnlNow(dev , priv->chan);\r\nRT_TRACE(COMP_TRACE, "<== SwChnlCallback819xUsbWorkItem()\n");\r\n}\r\nu8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nRT_TRACE(COMP_PHY, "=====>%s()\n", __func__);\r\nif (IS_NIC_DOWN(priv)) {\r\nRT_TRACE(COMP_ERR, "%s(): ERR !! driver is not up\n", __func__);\r\nreturn false;\r\n}\r\nif (priv->SwChnlInProgress)\r\nreturn false;\r\nswitch (priv->rtllib->mode) {\r\ncase WIRELESS_MODE_A:\r\ncase WIRELESS_MODE_N_5G:\r\nif (channel <= 14) {\r\nRT_TRACE(COMP_ERR, "WIRELESS_MODE_A but channel<=14");\r\nreturn false;\r\n}\r\nbreak;\r\ncase WIRELESS_MODE_B:\r\nif (channel > 14) {\r\nRT_TRACE(COMP_ERR, "WIRELESS_MODE_B but channel>14");\r\nreturn false;\r\n}\r\nbreak;\r\ncase WIRELESS_MODE_G:\r\ncase WIRELESS_MODE_N_24G:\r\nif (channel > 14) {\r\nRT_TRACE(COMP_ERR, "WIRELESS_MODE_G but channel>14");\r\nreturn false;\r\n}\r\nbreak;\r\n}\r\npriv->SwChnlInProgress = true;\r\nif (channel == 0)\r\nchannel = 1;\r\npriv->chan = channel;\r\npriv->SwChnlStage = 0;\r\npriv->SwChnlStep = 0;\r\nif (!IS_NIC_DOWN(priv))\r\nrtl8192_SwChnl_WorkItem(dev);\r\npriv->SwChnlInProgress = false;\r\nreturn true;\r\n}\r\nstatic void CCK_Tx_Power_Track_BW_Switch_TSSI(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nswitch (priv->CurrentChannelBW) {\r\ncase HT_CHANNEL_WIDTH_20:\r\npriv->CCKPresentAttentuation =\r\npriv->CCKPresentAttentuation_20Mdefault +\r\npriv->CCKPresentAttentuation_difference;\r\nif (priv->CCKPresentAttentuation >\r\n(CCKTxBBGainTableLength-1))\r\npriv->CCKPresentAttentuation =\r\nCCKTxBBGainTableLength-1;\r\nif (priv->CCKPresentAttentuation < 0)\r\npriv->CCKPresentAttentuation = 0;\r\nRT_TRACE(COMP_POWER_TRACKING, "20M, priv->CCKPresent"\r\n"Attentuation = %d\n",\r\npriv->CCKPresentAttentuation);\r\nif (priv->rtllib->current_network.channel == 14 &&\r\n!priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = true;\r\ndm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else if (priv->rtllib->current_network.channel !=\r\n14 && priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = false;\r\ndm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else {\r\ndm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n}\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\npriv->CCKPresentAttentuation =\r\npriv->CCKPresentAttentuation_40Mdefault +\r\npriv->CCKPresentAttentuation_difference;\r\nRT_TRACE(COMP_POWER_TRACKING, "40M, priv->CCKPresent"\r\n"Attentuation = %d\n",\r\npriv->CCKPresentAttentuation);\r\nif (priv->CCKPresentAttentuation >\r\n(CCKTxBBGainTableLength - 1))\r\npriv->CCKPresentAttentuation =\r\nCCKTxBBGainTableLength-1;\r\nif (priv->CCKPresentAttentuation < 0)\r\npriv->CCKPresentAttentuation = 0;\r\nif (priv->rtllib->current_network.channel == 14 &&\r\n!priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = true;\r\ndm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else if (priv->rtllib->current_network.channel != 14\r\n&& priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = false;\r\ndm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else {\r\ndm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void CCK_Tx_Power_Track_BW_Switch_ThermalMeter(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->rtllib->current_network.channel == 14 &&\r\n!priv->bcck_in_ch14)\r\npriv->bcck_in_ch14 = true;\r\nelse if (priv->rtllib->current_network.channel != 14 &&\r\npriv->bcck_in_ch14)\r\npriv->bcck_in_ch14 = false;\r\nswitch (priv->CurrentChannelBW) {\r\ncase HT_CHANNEL_WIDTH_20:\r\nif (priv->Record_CCK_20Mindex == 0)\r\npriv->Record_CCK_20Mindex = 6;\r\npriv->CCK_index = priv->Record_CCK_20Mindex;\r\nRT_TRACE(COMP_POWER_TRACKING, "20MHz, CCK_Tx_Power_Track_BW_"\r\n"Switch_ThermalMeter(),CCK_index = %d\n",\r\npriv->CCK_index);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\npriv->CCK_index = priv->Record_CCK_40Mindex;\r\nRT_TRACE(COMP_POWER_TRACKING, "40MHz, CCK_Tx_Power_Track_BW_"\r\n"Switch_ThermalMeter(), CCK_index = %d\n",\r\npriv->CCK_index);\r\nbreak;\r\n}\r\ndm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n}\r\nstatic void CCK_Tx_Power_Track_BW_Switch(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->IC_Cut >= IC_VersionCut_D)\r\nCCK_Tx_Power_Track_BW_Switch_TSSI(dev);\r\nelse\r\nCCK_Tx_Power_Track_BW_Switch_ThermalMeter(dev);\r\n}\r\nvoid rtl8192_SetBWModeWorkItem(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 regBwOpMode;\r\nRT_TRACE(COMP_SWBW, "==>rtl8192_SetBWModeWorkItem() Switch to %s "\r\n"bandwidth\n", priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20 ?\r\n"20MHz" : "40MHz");\r\nif (priv->rf_chip == RF_PSEUDO_11N) {\r\npriv->SetBWModeInProgress = false;\r\nreturn;\r\n}\r\nif (IS_NIC_DOWN(priv)) {\r\nRT_TRACE(COMP_ERR, "%s(): ERR!! driver is not up\n", __func__);\r\nreturn;\r\n}\r\nregBwOpMode = read_nic_byte(dev, BW_OPMODE);\r\nswitch (priv->CurrentChannelBW) {\r\ncase HT_CHANNEL_WIDTH_20:\r\nregBwOpMode |= BW_OPMODE_20MHZ;\r\nwrite_nic_byte(dev, BW_OPMODE, regBwOpMode);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nregBwOpMode &= ~BW_OPMODE_20MHZ;\r\nwrite_nic_byte(dev, BW_OPMODE, regBwOpMode);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown "\r\n"Bandwidth: %#X\n", priv->CurrentChannelBW);\r\nbreak;\r\n}\r\nswitch (priv->CurrentChannelBW) {\r\ncase HT_CHANNEL_WIDTH_20:\r\nrtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x0);\r\nrtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x0);\r\nif (!priv->btxpower_tracking) {\r\nwrite_nic_dword(dev, rCCK0_TxFilter1, 0x1a1b0000);\r\nwrite_nic_dword(dev, rCCK0_TxFilter2, 0x090e1317);\r\nwrite_nic_dword(dev, rCCK0_DebugPort, 0x00000204);\r\n} else {\r\nCCK_Tx_Power_Track_BW_Switch(dev);\r\n}\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 1);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nrtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x1);\r\nrtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x1);\r\nif (!priv->btxpower_tracking) {\r\nwrite_nic_dword(dev, rCCK0_TxFilter1, 0x35360000);\r\nwrite_nic_dword(dev, rCCK0_TxFilter2, 0x121c252e);\r\nwrite_nic_dword(dev, rCCK0_DebugPort, 0x00000409);\r\n} else {\r\nCCK_Tx_Power_Track_BW_Switch(dev);\r\n}\r\nrtl8192_setBBreg(dev, rCCK0_System, bCCKSideBand,\r\n(priv->nCur40MhzPrimeSC>>1));\r\nrtl8192_setBBreg(dev, rOFDM1_LSTF, 0xC00,\r\npriv->nCur40MhzPrimeSC);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "SetChannelBandwidth819xUsb(): unknown "\r\n"Bandwidth: %#X\n", priv->CurrentChannelBW);\r\nbreak;\r\n}\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\nbreak;\r\ncase RF_8256:\r\nPHY_SetRF8256Bandwidth(dev, priv->CurrentChannelBW);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ncase RF_PSEUDO_11N:\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);\r\nbreak;\r\n}\r\natomic_dec(&(priv->rtllib->atm_swbw));\r\npriv->SetBWModeInProgress = false;\r\nRT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb()");\r\n}\r\nvoid rtl8192_SetBWMode(struct net_device *dev, enum ht_channel_width Bandwidth,\r\nenum ht_extchnl_offset Offset)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->SetBWModeInProgress)\r\nreturn;\r\natomic_inc(&(priv->rtllib->atm_swbw));\r\npriv->SetBWModeInProgress = true;\r\npriv->CurrentChannelBW = Bandwidth;\r\nif (Offset == HT_EXTCHNL_OFFSET_LOWER)\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_UPPER;\r\nelse if (Offset == HT_EXTCHNL_OFFSET_UPPER)\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_LOWER;\r\nelse\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nrtl8192_SetBWModeWorkItem(dev);\r\n}\r\nvoid InitialGain819xPci(struct net_device *dev, u8 Operation)\r\n{\r\n#define SCAN_RX_INITIAL_GAIN 0x17\r\n#define POWER_DETECTION_TH 0x08\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 BitMask;\r\nu8 initial_gain;\r\nif (!IS_NIC_DOWN(priv)) {\r\nswitch (Operation) {\r\ncase IG_Backup:\r\nRT_TRACE(COMP_SCAN, "IG_Backup, backup the initial"\r\n" gain.\n");\r\ninitial_gain = SCAN_RX_INITIAL_GAIN;\r\nBitMask = bMaskByte0;\r\nif (dm_digtable.dig_algorithm ==\r\nDIG_ALGO_BY_FALSE_ALARM)\r\nrtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);\r\npriv->initgain_backup.xaagccore1 =\r\n(u8)rtl8192_QueryBBReg(dev, rOFDM0_XAAGCCore1,\r\nBitMask);\r\npriv->initgain_backup.xbagccore1 =\r\n(u8)rtl8192_QueryBBReg(dev, rOFDM0_XBAGCCore1,\r\nBitMask);\r\npriv->initgain_backup.xcagccore1 =\r\n(u8)rtl8192_QueryBBReg(dev, rOFDM0_XCAGCCore1,\r\nBitMask);\r\npriv->initgain_backup.xdagccore1 =\r\n(u8)rtl8192_QueryBBReg(dev, rOFDM0_XDAGCCore1,\r\nBitMask);\r\nBitMask = bMaskByte2;\r\npriv->initgain_backup.cca = (u8)rtl8192_QueryBBReg(dev,\r\nrCCK0_CCA, BitMask);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc50 is"\r\n" %x\n", priv->initgain_backup.xaagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc58 is"\r\n" %x\n", priv->initgain_backup.xbagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc60 is"\r\n" %x\n", priv->initgain_backup.xcagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc68 is"\r\n" %x\n", priv->initgain_backup.xdagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xa0a is"\r\n" %x\n", priv->initgain_backup.cca);\r\nRT_TRACE(COMP_SCAN, "Write scan initial gain = 0x%x\n",\r\ninitial_gain);\r\nwrite_nic_byte(dev, rOFDM0_XAAGCCore1, initial_gain);\r\nwrite_nic_byte(dev, rOFDM0_XBAGCCore1, initial_gain);\r\nwrite_nic_byte(dev, rOFDM0_XCAGCCore1, initial_gain);\r\nwrite_nic_byte(dev, rOFDM0_XDAGCCore1, initial_gain);\r\nRT_TRACE(COMP_SCAN, "Write scan 0xa0a = 0x%x\n",\r\nPOWER_DETECTION_TH);\r\nwrite_nic_byte(dev, 0xa0a, POWER_DETECTION_TH);\r\nbreak;\r\ncase IG_Restore:\r\nRT_TRACE(COMP_SCAN, "IG_Restore, restore the initial "\r\n"gain.\n");\r\nBitMask = 0x7f;\r\nif (dm_digtable.dig_algorithm ==\r\nDIG_ALGO_BY_FALSE_ALARM)\r\nrtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);\r\nrtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, BitMask,\r\n(u32)priv->initgain_backup.xaagccore1);\r\nrtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, BitMask,\r\n(u32)priv->initgain_backup.xbagccore1);\r\nrtl8192_setBBreg(dev, rOFDM0_XCAGCCore1, BitMask,\r\n(u32)priv->initgain_backup.xcagccore1);\r\nrtl8192_setBBreg(dev, rOFDM0_XDAGCCore1, BitMask,\r\n(u32)priv->initgain_backup.xdagccore1);\r\nBitMask = bMaskByte2;\r\nrtl8192_setBBreg(dev, rCCK0_CCA, BitMask,\r\n(u32)priv->initgain_backup.cca);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc50"\r\n" is %x\n", priv->initgain_backup.xaagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc58"\r\n" is %x\n", priv->initgain_backup.xbagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc60"\r\n" is %x\n", priv->initgain_backup.xcagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc68"\r\n" is %x\n", priv->initgain_backup.xdagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xa0a"\r\n" is %x\n", priv->initgain_backup.cca);\r\nrtl8192_phy_setTxPower(dev,\r\npriv->rtllib->current_network.channel);\r\nif (dm_digtable.dig_algorithm ==\r\nDIG_ALGO_BY_FALSE_ALARM)\r\nrtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_SCAN, "Unknown IG Operation.\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid PHY_SetRtl8192eRfOff(struct net_device *dev)\r\n{\r\nrtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x0);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x0);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18, 0x0);\r\nrtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0x0);\r\nrtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x0);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x0);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x4, 0x0);\r\nwrite_nic_byte(dev, ANAPAR_FOR_8192PciE, 0x07);\r\n}\r\nstatic bool SetRFPowerState8190(struct net_device *dev,\r\nenum rt_rf_power_state eRFPowerState)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)\r\n(&(priv->rtllib->PowerSaveControl));\r\nbool bResult = true;\r\nu8 i = 0, QueueID = 0;\r\nstruct rtl8192_tx_ring *ring = NULL;\r\nif (priv->SetRFPowerStateInProgress)\r\nreturn false;\r\nRT_TRACE(COMP_PS, "===========> SetRFPowerState8190()!\n");\r\npriv->SetRFPowerStateInProgress = true;\r\nswitch (priv->rf_chip) {\r\ncase RF_8256:\r\nswitch (eRFPowerState) {\r\ncase eRfOn:\r\nRT_TRACE(COMP_PS, "SetRFPowerState8190() eRfOn!\n");\r\nif ((priv->rtllib->eRFPowerState == eRfOff) &&\r\nRT_IN_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC)) {\r\nbool rtstatus = true;\r\nu32 InitilizeCount = 3;\r\ndo {\r\nInitilizeCount--;\r\npriv->RegRfOff = false;\r\nrtstatus = NicIFEnableNIC(dev);\r\n} while (!rtstatus && (InitilizeCount > 0));\r\nif (!rtstatus) {\r\nRT_TRACE(COMP_ERR, "%s():Initialize Ada"\r\n"pter fail,return\n",\r\n__func__);\r\npriv->SetRFPowerStateInProgress = false;\r\nreturn false;\r\n}\r\nRT_CLEAR_PS_LEVEL(pPSC,\r\nRT_RF_OFF_LEVL_HALT_NIC);\r\n} else {\r\nwrite_nic_byte(dev, ANAPAR, 0x37);\r\nmdelay(1);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1,\r\n0x4, 0x1);\r\npriv->bHwRfOffAction = 0;\r\nrtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE,\r\nBIT4, 0x1);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter4,\r\n0x300, 0x3);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1,\r\n0x18, 0x3);\r\nrtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0x3,\r\n0x3);\r\nrtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0x3,\r\n0x3);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1,\r\n0x60, 0x3);\r\n}\r\nbreak;\r\ncase eRfSleep:\r\nif (priv->rtllib->eRFPowerState == eRfOff)\r\nbreak;\r\nfor (QueueID = 0, i = 0; QueueID < MAX_TX_QUEUE; ) {\r\nring = &priv->tx_ring[QueueID];\r\nif (skb_queue_len(&ring->queue) == 0) {\r\nQueueID++;\r\ncontinue;\r\n} else {\r\nRT_TRACE((COMP_POWER|COMP_RF), "eRf Off"\r\n"/Sleep: %d times TcbBusyQueue"\r\n"[%d] !=0 before doze!\n",\r\n(i+1), QueueID);\r\nudelay(10);\r\ni++;\r\n}\r\nif (i >= MAX_DOZE_WAITING_TIMES_9x) {\r\nRT_TRACE(COMP_POWER, "\n\n\n TimeOut!! "\r\n"SetRFPowerState8190(): eRfOff"\r\n": %d times TcbBusyQueue[%d] "\r\n"!= 0 !!!\n",\r\nMAX_DOZE_WAITING_TIMES_9x,\r\nQueueID);\r\nbreak;\r\n}\r\n}\r\nPHY_SetRtl8192eRfOff(dev);\r\nbreak;\r\ncase eRfOff:\r\nRT_TRACE(COMP_PS, "SetRFPowerState8190() eRfOff/"\r\n"Sleep !\n");\r\nfor (QueueID = 0, i = 0; QueueID < MAX_TX_QUEUE; ) {\r\nring = &priv->tx_ring[QueueID];\r\nif (skb_queue_len(&ring->queue) == 0) {\r\nQueueID++;\r\ncontinue;\r\n} else {\r\nRT_TRACE(COMP_POWER, "eRf Off/Sleep: %d"\r\n" times TcbBusyQueue[%d] !=0 b"\r\n"efore doze!\n", (i+1),\r\nQueueID);\r\nudelay(10);\r\ni++;\r\n}\r\nif (i >= MAX_DOZE_WAITING_TIMES_9x) {\r\nRT_TRACE(COMP_POWER, "\n\n\n SetZebra: "\r\n"RFPowerState8185B(): eRfOff:"\r\n" %d times TcbBusyQueue[%d] "\r\n"!= 0 !!!\n",\r\nMAX_DOZE_WAITING_TIMES_9x,\r\nQueueID);\r\nbreak;\r\n}\r\n}\r\nif (pPSC->RegRfPsLevel & RT_RF_OFF_LEVL_HALT_NIC &&\r\n!RT_IN_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC)) {\r\nNicIFDisableNIC(dev);\r\nRT_SET_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC);\r\n} else if (!(pPSC->RegRfPsLevel &\r\nRT_RF_OFF_LEVL_HALT_NIC)) {\r\nPHY_SetRtl8192eRfOff(dev);\r\n}\r\nbreak;\r\ndefault:\r\nbResult = false;\r\nRT_TRACE(COMP_ERR, "SetRFPowerState8190(): unknow state"\r\n" to set: 0x%X!!!\n", eRFPowerState);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "SetRFPowerState8190(): Unknown RF type\n");\r\nbreak;\r\n}\r\nif (bResult) {\r\npriv->rtllib->eRFPowerState = eRFPowerState;\r\nswitch (priv->rf_chip) {\r\ncase RF_8256:\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "SetRFPowerState8190(): Unknown "\r\n"RF type\n");\r\nbreak;\r\n}\r\n}\r\npriv->SetRFPowerStateInProgress = false;\r\nRT_TRACE(COMP_PS, "<=========== SetRFPowerState8190() bResult = %d!\n",\r\nbResult);\r\nreturn bResult;\r\n}\r\nbool SetRFPowerState(struct net_device *dev,\r\nenum rt_rf_power_state eRFPowerState)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nbool bResult = false;\r\nRT_TRACE(COMP_PS, "---------> SetRFPowerState(): eRFPowerState(%d)\n",\r\neRFPowerState);\r\nif (eRFPowerState == priv->rtllib->eRFPowerState &&\r\npriv->bHwRfOffAction == 0) {\r\nRT_TRACE(COMP_PS, "<--------- SetRFPowerState(): discard the "\r\n"request for eRFPowerState(%d) is the same.\n",\r\neRFPowerState);\r\nreturn bResult;\r\n}\r\nbResult = SetRFPowerState8190(dev, eRFPowerState);\r\nRT_TRACE(COMP_PS, "<--------- SetRFPowerState(): bResult(%d)\n",\r\nbResult);\r\nreturn bResult;\r\n}\r\nvoid PHY_ScanOperationBackup8192(struct net_device *dev, u8 Operation)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->up) {\r\nswitch (Operation) {\r\ncase SCAN_OPT_BACKUP:\r\npriv->rtllib->InitialGainHandler(dev, IG_Backup);\r\nbreak;\r\ncase SCAN_OPT_RESTORE:\r\npriv->rtllib->InitialGainHandler(dev, IG_Restore);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_SCAN, "Unknown Scan Backup Operation.\n");\r\nbreak;\r\n}\r\n}\r\n}
