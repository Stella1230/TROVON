static inline void write_ssi_mask(u32 __iomem *addr, u32 clear, u32 set)\r\n{\r\nu32 val = readl(addr);\r\nval = (val & ~clear) | set;\r\nwritel(val, addr);\r\n}\r\nstatic irqreturn_t fsl_ssi_isr(int irq, void *dev_id)\r\n{\r\nstruct fsl_ssi_private *ssi_private = dev_id;\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nirqreturn_t ret = IRQ_NONE;\r\n__be32 sisr;\r\n__be32 sisr2;\r\n__be32 sisr_write_mask = 0;\r\nswitch (ssi_private->hw_type) {\r\ncase FSL_SSI_MX21:\r\nsisr_write_mask = 0;\r\nbreak;\r\ncase FSL_SSI_MCP8610:\r\ncase FSL_SSI_MX35:\r\nsisr_write_mask = CCSR_SSI_SISR_RFRC | CCSR_SSI_SISR_TFRC |\r\nCCSR_SSI_SISR_ROE0 | CCSR_SSI_SISR_ROE1 |\r\nCCSR_SSI_SISR_TUE0 | CCSR_SSI_SISR_TUE1;\r\nbreak;\r\ncase FSL_SSI_MX51:\r\nsisr_write_mask = CCSR_SSI_SISR_ROE0 | CCSR_SSI_SISR_ROE1 |\r\nCCSR_SSI_SISR_TUE0 | CCSR_SSI_SISR_TUE1;\r\nbreak;\r\n}\r\nsisr = read_ssi(&ssi->sisr) & FSLSSI_SISR_MASK;\r\nif (sisr & CCSR_SSI_SISR_RFRC) {\r\nssi_private->stats.rfrc++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TFRC) {\r\nssi_private->stats.tfrc++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_CMDAU) {\r\nssi_private->stats.cmdau++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_CMDDU) {\r\nssi_private->stats.cmddu++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RXT) {\r\nssi_private->stats.rxt++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RDR1) {\r\nssi_private->stats.rdr1++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RDR0) {\r\nssi_private->stats.rdr0++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TDE1) {\r\nssi_private->stats.tde1++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TDE0) {\r\nssi_private->stats.tde0++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_ROE1) {\r\nssi_private->stats.roe1++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_ROE0) {\r\nssi_private->stats.roe0++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TUE1) {\r\nssi_private->stats.tue1++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TUE0) {\r\nssi_private->stats.tue0++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TFS) {\r\nssi_private->stats.tfs++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RFS) {\r\nssi_private->stats.rfs++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TLS) {\r\nssi_private->stats.tls++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RLS) {\r\nssi_private->stats.rls++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RFF1) {\r\nssi_private->stats.rff1++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RFF0) {\r\nssi_private->stats.rff0++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TFE1) {\r\nssi_private->stats.tfe1++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TFE0) {\r\nssi_private->stats.tfe0++;\r\nret = IRQ_HANDLED;\r\n}\r\nsisr2 = sisr & sisr_write_mask;\r\nif (sisr2)\r\nwrite_ssi(sisr2, &ssi->sisr);\r\nreturn ret;\r\n}\r\nstatic int fsl_ssi_stats_show(struct seq_file *s, void *unused)\r\n{\r\nstruct fsl_ssi_private *ssi_private = s->private;\r\nSIER_SHOW(RFRC_EN, rfrc);\r\nSIER_SHOW(TFRC_EN, tfrc);\r\nSIER_SHOW(CMDAU_EN, cmdau);\r\nSIER_SHOW(CMDDU_EN, cmddu);\r\nSIER_SHOW(RXT_EN, rxt);\r\nSIER_SHOW(RDR1_EN, rdr1);\r\nSIER_SHOW(RDR0_EN, rdr0);\r\nSIER_SHOW(TDE1_EN, tde1);\r\nSIER_SHOW(TDE0_EN, tde0);\r\nSIER_SHOW(ROE1_EN, roe1);\r\nSIER_SHOW(ROE0_EN, roe0);\r\nSIER_SHOW(TUE1_EN, tue1);\r\nSIER_SHOW(TUE0_EN, tue0);\r\nSIER_SHOW(TFS_EN, tfs);\r\nSIER_SHOW(RFS_EN, rfs);\r\nSIER_SHOW(TLS_EN, tls);\r\nSIER_SHOW(RLS_EN, rls);\r\nSIER_SHOW(RFF1_EN, rff1);\r\nSIER_SHOW(RFF0_EN, rff0);\r\nSIER_SHOW(TFE1_EN, tfe1);\r\nSIER_SHOW(TFE0_EN, tfe0);\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_stats_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, fsl_ssi_stats_show, inode->i_private);\r\n}\r\nstatic int fsl_ssi_debugfs_create(struct fsl_ssi_private *ssi_private,\r\nstruct device *dev)\r\n{\r\nssi_private->dbg_dir = debugfs_create_dir(dev_name(dev), NULL);\r\nif (!ssi_private->dbg_dir)\r\nreturn -ENOMEM;\r\nssi_private->dbg_stats = debugfs_create_file("stats", S_IRUGO,\r\nssi_private->dbg_dir, ssi_private, &fsl_ssi_stats_ops);\r\nif (!ssi_private->dbg_stats) {\r\ndebugfs_remove(ssi_private->dbg_dir);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fsl_ssi_debugfs_remove(struct fsl_ssi_private *ssi_private)\r\n{\r\ndebugfs_remove(ssi_private->dbg_stats);\r\ndebugfs_remove(ssi_private->dbg_dir);\r\n}\r\nstatic int fsl_ssi_debugfs_create(struct fsl_ssi_private *ssi_private,\r\nstruct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void fsl_ssi_debugfs_remove(struct fsl_ssi_private *ssi_private)\r\n{\r\n}\r\nstatic void fsl_ssi_rxtx_config(struct fsl_ssi_private *ssi_private,\r\nbool enable)\r\n{\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nstruct fsl_ssi_rxtx_reg_val *vals = &ssi_private->rxtx_reg_val;\r\nif (enable) {\r\nwrite_ssi_mask(&ssi->sier, 0, vals->rx.sier | vals->tx.sier);\r\nwrite_ssi_mask(&ssi->srcr, 0, vals->rx.srcr | vals->tx.srcr);\r\nwrite_ssi_mask(&ssi->stcr, 0, vals->rx.stcr | vals->tx.stcr);\r\n} else {\r\nwrite_ssi_mask(&ssi->srcr, vals->rx.srcr | vals->tx.srcr, 0);\r\nwrite_ssi_mask(&ssi->stcr, vals->rx.stcr | vals->tx.stcr, 0);\r\nwrite_ssi_mask(&ssi->sier, vals->rx.sier | vals->tx.sier, 0);\r\n}\r\n}\r\nstatic void fsl_ssi_config(struct fsl_ssi_private *ssi_private, bool enable,\r\nstruct fsl_ssi_reg_val *vals)\r\n{\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nstruct fsl_ssi_reg_val *avals;\r\nu32 scr_val = read_ssi(&ssi->scr);\r\nint nr_active_streams = !!(scr_val & CCSR_SSI_SCR_TE) +\r\n!!(scr_val & CCSR_SSI_SCR_RE);\r\nif (&ssi_private->rxtx_reg_val.rx == vals)\r\navals = &ssi_private->rxtx_reg_val.tx;\r\nelse\r\navals = &ssi_private->rxtx_reg_val.rx;\r\nif (!enable) {\r\nu32 scr = vals->scr & (vals->scr ^ avals->scr);\r\nwrite_ssi_mask(&ssi->scr, scr, 0);\r\n}\r\nif (ssi_private->offline_config) {\r\nif ((enable && !nr_active_streams) ||\r\n(!enable && nr_active_streams == 1))\r\nfsl_ssi_rxtx_config(ssi_private, enable);\r\ngoto config_done;\r\n}\r\nif (enable) {\r\nwrite_ssi_mask(&ssi->sier, 0, vals->sier);\r\nwrite_ssi_mask(&ssi->srcr, 0, vals->srcr);\r\nwrite_ssi_mask(&ssi->stcr, 0, vals->stcr);\r\n} else {\r\nu32 sier;\r\nu32 srcr;\r\nu32 stcr;\r\nsier = vals->sier & (vals->sier ^ avals->sier);\r\nsrcr = vals->srcr & (vals->srcr ^ avals->srcr);\r\nstcr = vals->stcr & (vals->stcr ^ avals->stcr);\r\nwrite_ssi_mask(&ssi->srcr, srcr, 0);\r\nwrite_ssi_mask(&ssi->stcr, stcr, 0);\r\nwrite_ssi_mask(&ssi->sier, sier, 0);\r\n}\r\nconfig_done:\r\nif (enable)\r\nwrite_ssi_mask(&ssi->scr, 0, vals->scr);\r\n}\r\nstatic void fsl_ssi_rx_config(struct fsl_ssi_private *ssi_private, bool enable)\r\n{\r\nfsl_ssi_config(ssi_private, enable, &ssi_private->rxtx_reg_val.rx);\r\n}\r\nstatic void fsl_ssi_tx_config(struct fsl_ssi_private *ssi_private, bool enable)\r\n{\r\nfsl_ssi_config(ssi_private, enable, &ssi_private->rxtx_reg_val.tx);\r\n}\r\nstatic void fsl_ssi_setup_reg_vals(struct fsl_ssi_private *ssi_private)\r\n{\r\nstruct fsl_ssi_rxtx_reg_val *reg = &ssi_private->rxtx_reg_val;\r\nreg->rx.sier = CCSR_SSI_SIER_RFF0_EN;\r\nreg->rx.srcr = CCSR_SSI_SRCR_RFEN0;\r\nreg->rx.scr = 0;\r\nreg->tx.sier = CCSR_SSI_SIER_TFE0_EN;\r\nreg->tx.stcr = CCSR_SSI_STCR_TFEN0;\r\nreg->tx.scr = 0;\r\nif (!ssi_private->imx_ac97) {\r\nreg->rx.scr = CCSR_SSI_SCR_SSIEN | CCSR_SSI_SCR_RE;\r\nreg->rx.sier |= CCSR_SSI_SIER_RFF0_EN;\r\nreg->tx.scr = CCSR_SSI_SCR_SSIEN | CCSR_SSI_SCR_TE;\r\nreg->tx.sier |= CCSR_SSI_SIER_TFE0_EN;\r\n}\r\nif (ssi_private->use_dma) {\r\nreg->rx.sier |= CCSR_SSI_SIER_RDMAE;\r\nreg->tx.sier |= CCSR_SSI_SIER_TDMAE;\r\n} else {\r\nreg->rx.sier |= CCSR_SSI_SIER_RIE;\r\nreg->tx.sier |= CCSR_SSI_SIER_TIE;\r\n}\r\nreg->rx.sier |= FSLSSI_SIER_DBG_RX_FLAGS;\r\nreg->tx.sier |= FSLSSI_SIER_DBG_TX_FLAGS;\r\n}\r\nstatic void fsl_ssi_setup_ac97(struct fsl_ssi_private *ssi_private)\r\n{\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nwrite_ssi(CCSR_SSI_SxCCR_WL(17) | CCSR_SSI_SxCCR_DC(13),\r\n&ssi->stccr);\r\nwrite_ssi(CCSR_SSI_SxCCR_WL(17) | CCSR_SSI_SxCCR_DC(13),\r\n&ssi->srccr);\r\nwrite_ssi(CCSR_SSI_SACNT_AC97EN | CCSR_SSI_SACNT_FV,\r\n&ssi->sacnt);\r\nwrite_ssi(0xff, &ssi->saccdis);\r\nwrite_ssi(0x300, &ssi->saccen);\r\nwrite_ssi_mask(&ssi->scr, 0, CCSR_SSI_SCR_SSIEN |\r\nCCSR_SSI_SCR_TE | CCSR_SSI_SCR_RE);\r\nwrite_ssi(CCSR_SSI_SOR_WAIT(3), &ssi->sor);\r\n}\r\nstatic int fsl_ssi_setup(struct fsl_ssi_private *ssi_private)\r\n{\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nu8 wm;\r\nint synchronous = ssi_private->cpu_dai_drv.symmetric_rates;\r\nfsl_ssi_setup_reg_vals(ssi_private);\r\nif (ssi_private->imx_ac97)\r\nssi_private->i2s_mode = CCSR_SSI_SCR_I2S_MODE_NORMAL | CCSR_SSI_SCR_NET;\r\nelse\r\nssi_private->i2s_mode = CCSR_SSI_SCR_I2S_MODE_SLAVE;\r\nwrite_ssi_mask(&ssi->scr, CCSR_SSI_SCR_SSIEN, 0);\r\nwrite_ssi_mask(&ssi->scr,\r\nCCSR_SSI_SCR_I2S_MODE_MASK | CCSR_SSI_SCR_SYN,\r\nCCSR_SSI_SCR_TFR_CLK_DIS |\r\nssi_private->i2s_mode |\r\n(synchronous ? CCSR_SSI_SCR_SYN : 0));\r\nwrite_ssi(CCSR_SSI_STCR_TXBIT0 | CCSR_SSI_STCR_TFSI |\r\nCCSR_SSI_STCR_TEFS | CCSR_SSI_STCR_TSCKP, &ssi->stcr);\r\nwrite_ssi(CCSR_SSI_SRCR_RXBIT0 | CCSR_SSI_SRCR_RFSI |\r\nCCSR_SSI_SRCR_REFS | CCSR_SSI_SRCR_RSCKP, &ssi->srcr);\r\nif (ssi_private->use_dma)\r\nwm = ssi_private->fifo_depth - 2;\r\nelse\r\nwm = ssi_private->fifo_depth;\r\nwrite_ssi(CCSR_SSI_SFCSR_TFWM0(wm) | CCSR_SSI_SFCSR_RFWM0(wm) |\r\nCCSR_SSI_SFCSR_TFWM1(wm) | CCSR_SSI_SFCSR_RFWM1(wm),\r\n&ssi->sfcsr);\r\nif (ssi_private->imx_ac97)\r\nfsl_ssi_setup_ac97(ssi_private);\r\nif (!ssi_private->imx_ac97) {\r\nwrite_ssi_mask(&ssi->stccr, CCSR_SSI_SxCCR_DC_MASK,\r\nCCSR_SSI_SxCCR_DC(2));\r\nwrite_ssi_mask(&ssi->srccr, CCSR_SSI_SxCCR_DC_MASK,\r\nCCSR_SSI_SxCCR_DC(2));\r\n}\r\nif (ssi_private->use_dual_fifo) {\r\nwrite_ssi_mask(&ssi->srcr, 0, CCSR_SSI_SRCR_RFEN1);\r\nwrite_ssi_mask(&ssi->stcr, 0, CCSR_SSI_STCR_TFEN1);\r\nwrite_ssi_mask(&ssi->scr, 0, CCSR_SSI_SCR_TCH_EN);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_ssi_private *ssi_private =\r\nsnd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nunsigned long flags;\r\nif (!dai->active && !ssi_private->imx_ac97) {\r\nfsl_ssi_setup(ssi_private);\r\nspin_lock_irqsave(&ssi_private->baudclk_lock, flags);\r\nssi_private->baudclk_locked = false;\r\nspin_unlock_irqrestore(&ssi_private->baudclk_lock, flags);\r\n}\r\nif (ssi_private->use_dual_fifo)\r\nsnd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE, 2);\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params, struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nunsigned int channels = params_channels(hw_params);\r\nunsigned int sample_size =\r\nsnd_pcm_format_width(params_format(hw_params));\r\nu32 wl = CCSR_SSI_SxCCR_WL(sample_size);\r\nint enabled = read_ssi(&ssi->scr) & CCSR_SSI_SCR_SSIEN;\r\nif (enabled && ssi_private->cpu_dai_drv.symmetric_rates)\r\nreturn 0;\r\nif ((substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ||\r\nssi_private->cpu_dai_drv.symmetric_rates)\r\nwrite_ssi_mask(&ssi->stccr, CCSR_SSI_SxCCR_WL_MASK, wl);\r\nelse\r\nwrite_ssi_mask(&ssi->srccr, CCSR_SSI_SxCCR_WL_MASK, wl);\r\nif (!ssi_private->imx_ac97)\r\nwrite_ssi_mask(&ssi->scr,\r\nCCSR_SSI_SCR_NET | CCSR_SSI_SCR_I2S_MODE_MASK,\r\nchannels == 1 ? 0 : ssi_private->i2s_mode);\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\r\n{\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nu32 strcr = 0, stcr, srcr, scr, mask;\r\nscr = read_ssi(&ssi->scr) & ~(CCSR_SSI_SCR_SYN | CCSR_SSI_SCR_I2S_MODE_MASK);\r\nscr |= CCSR_SSI_SCR_NET;\r\nmask = CCSR_SSI_STCR_TXBIT0 | CCSR_SSI_STCR_TFDIR | CCSR_SSI_STCR_TXDIR |\r\nCCSR_SSI_STCR_TSCKP | CCSR_SSI_STCR_TFSI | CCSR_SSI_STCR_TFSL |\r\nCCSR_SSI_STCR_TEFS;\r\nstcr = read_ssi(&ssi->stcr) & ~mask;\r\nsrcr = read_ssi(&ssi->srcr) & ~mask;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nssi_private->i2s_mode = CCSR_SSI_SCR_I2S_MODE_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nssi_private->i2s_mode = CCSR_SSI_SCR_I2S_MODE_SLAVE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nscr |= ssi_private->i2s_mode;\r\nstrcr |= CCSR_SSI_STCR_TFSI | CCSR_SSI_STCR_TSCKP |\r\nCCSR_SSI_STCR_TXBIT0 | CCSR_SSI_STCR_TEFS;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nstrcr |= CCSR_SSI_STCR_TXBIT0 | CCSR_SSI_STCR_TSCKP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nstrcr |= CCSR_SSI_STCR_TFSL | CCSR_SSI_STCR_TSCKP |\r\nCCSR_SSI_STCR_TXBIT0 | CCSR_SSI_STCR_TEFS;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nstrcr |= CCSR_SSI_STCR_TFSL | CCSR_SSI_STCR_TSCKP |\r\nCCSR_SSI_STCR_TXBIT0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nstrcr ^= CCSR_SSI_STCR_TSCKP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nstrcr ^= CCSR_SSI_STCR_TFSI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nstrcr ^= CCSR_SSI_STCR_TSCKP;\r\nstrcr ^= CCSR_SSI_STCR_TFSI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nstrcr |= CCSR_SSI_STCR_TFDIR | CCSR_SSI_STCR_TXDIR;\r\nscr |= CCSR_SSI_SCR_SYS_CLK_EN;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nscr &= ~CCSR_SSI_SCR_SYS_CLK_EN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstcr |= strcr;\r\nsrcr |= strcr;\r\nif (ssi_private->cpu_dai_drv.symmetric_rates) {\r\nsrcr &= ~CCSR_SSI_SRCR_RXDIR;\r\nscr |= CCSR_SSI_SCR_SYN;\r\n}\r\nwrite_ssi(stcr, &ssi->stcr);\r\nwrite_ssi(srcr, &ssi->srcr);\r\nwrite_ssi(scr, &ssi->scr);\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nint synchronous = ssi_private->cpu_dai_drv.symmetric_rates, ret;\r\nu32 pm = 999, div2, psr, stccr, mask, afreq, factor, i;\r\nunsigned long flags, clkrate, baudrate, tmprate;\r\nu64 sub, savesub = 100000;\r\nif (IS_ERR(ssi_private->baudclk))\r\nreturn -EINVAL;\r\npsr = 0;\r\ndiv2 = 0;\r\nfactor = (div2 + 1) * (7 * psr + 1) * 2;\r\nfor (i = 0; i < 255; i++) {\r\nif (factor * (i + 1) < 5)\r\ncontinue;\r\ntmprate = freq * factor * (i + 2);\r\nclkrate = clk_round_rate(ssi_private->baudclk, tmprate);\r\ndo_div(clkrate, factor);\r\nafreq = (u32)clkrate / (i + 1);\r\nif (freq == afreq)\r\nsub = 0;\r\nelse if (freq / afreq == 1)\r\nsub = freq - afreq;\r\nelse if (afreq / freq == 1)\r\nsub = afreq - freq;\r\nelse\r\ncontinue;\r\nsub *= 100000;\r\ndo_div(sub, freq);\r\nif (sub < savesub) {\r\nbaudrate = tmprate;\r\nsavesub = sub;\r\npm = i;\r\n}\r\nif (savesub == 0)\r\nbreak;\r\n}\r\nif (pm == 999) {\r\ndev_err(cpu_dai->dev, "failed to handle the required sysclk\n");\r\nreturn -EINVAL;\r\n}\r\nstccr = CCSR_SSI_SxCCR_PM(pm + 1) | (div2 ? CCSR_SSI_SxCCR_DIV2 : 0) |\r\n(psr ? CCSR_SSI_SxCCR_PSR : 0);\r\nmask = CCSR_SSI_SxCCR_PM_MASK | CCSR_SSI_SxCCR_DIV2 | CCSR_SSI_SxCCR_PSR;\r\nif (dir == SND_SOC_CLOCK_OUT || synchronous)\r\nwrite_ssi_mask(&ssi->stccr, mask, stccr);\r\nelse\r\nwrite_ssi_mask(&ssi->srccr, mask, stccr);\r\nspin_lock_irqsave(&ssi_private->baudclk_lock, flags);\r\nif (!ssi_private->baudclk_locked) {\r\nret = clk_set_rate(ssi_private->baudclk, baudrate);\r\nif (ret) {\r\nspin_unlock_irqrestore(&ssi_private->baudclk_lock, flags);\r\ndev_err(cpu_dai->dev, "failed to set baudclk rate\n");\r\nreturn -EINVAL;\r\n}\r\nssi_private->baudclk_locked = true;\r\n}\r\nspin_unlock_irqrestore(&ssi_private->baudclk_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai, u32 tx_mask,\r\nu32 rx_mask, int slots, int slot_width)\r\n{\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nu32 val;\r\nval = read_ssi(&ssi->scr) & (CCSR_SSI_SCR_I2S_MODE_MASK | CCSR_SSI_SCR_NET);\r\nif (val && slots < 2) {\r\ndev_err(cpu_dai->dev, "slot number should be >= 2 in I2S or NET\n");\r\nreturn -EINVAL;\r\n}\r\nwrite_ssi_mask(&ssi->stccr, CCSR_SSI_SxCCR_DC_MASK,\r\nCCSR_SSI_SxCCR_DC(slots));\r\nwrite_ssi_mask(&ssi->srccr, CCSR_SSI_SxCCR_DC_MASK,\r\nCCSR_SSI_SxCCR_DC(slots));\r\nval = read_ssi(&ssi->scr) & CCSR_SSI_SCR_SSIEN;\r\nwrite_ssi_mask(&ssi->scr, 0, CCSR_SSI_SCR_SSIEN);\r\nwrite_ssi(tx_mask, &ssi->stmsk);\r\nwrite_ssi(rx_mask, &ssi->srmsk);\r\nwrite_ssi_mask(&ssi->scr, CCSR_SSI_SCR_SSIEN, val);\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nunsigned long flags;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nfsl_ssi_tx_config(ssi_private, true);\r\nelse\r\nfsl_ssi_rx_config(ssi_private, true);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nfsl_ssi_tx_config(ssi_private, false);\r\nelse\r\nfsl_ssi_rx_config(ssi_private, false);\r\nif (!ssi_private->imx_ac97 && (read_ssi(&ssi->scr) &\r\n(CCSR_SSI_SCR_TE | CCSR_SSI_SCR_RE)) == 0) {\r\nspin_lock_irqsave(&ssi_private->baudclk_lock, flags);\r\nssi_private->baudclk_locked = false;\r\nspin_unlock_irqrestore(&ssi_private->baudclk_lock, flags);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (ssi_private->imx_ac97) {\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nwrite_ssi(CCSR_SSI_SOR_TX_CLR, &ssi->sor);\r\nelse\r\nwrite_ssi(CCSR_SSI_SOR_RX_CLR, &ssi->sor);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(dai);\r\nif (ssi_private->ssi_on_imx && ssi_private->use_dma) {\r\ndai->playback_dma_data = &ssi_private->dma_params_tx;\r\ndai->capture_dma_data = &ssi_private->dma_params_rx;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fsl_ssi_ac97_init(void)\r\n{\r\nfsl_ssi_setup(fsl_ac97_data);\r\n}\r\nstatic void fsl_ssi_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct ccsr_ssi *ssi = fsl_ac97_data->ssi;\r\nunsigned int lreg;\r\nunsigned int lval;\r\nif (reg > 0x7f)\r\nreturn;\r\nlreg = reg << 12;\r\nwrite_ssi(lreg, &ssi->sacadd);\r\nlval = val << 4;\r\nwrite_ssi(lval , &ssi->sacdat);\r\nwrite_ssi_mask(&ssi->sacnt, CCSR_SSI_SACNT_RDWR_MASK,\r\nCCSR_SSI_SACNT_WR);\r\nudelay(100);\r\n}\r\nstatic unsigned short fsl_ssi_ac97_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct ccsr_ssi *ssi = fsl_ac97_data->ssi;\r\nunsigned short val = -1;\r\nunsigned int lreg;\r\nlreg = (reg & 0x7f) << 12;\r\nwrite_ssi(lreg, &ssi->sacadd);\r\nwrite_ssi_mask(&ssi->sacnt, CCSR_SSI_SACNT_RDWR_MASK,\r\nCCSR_SSI_SACNT_RD);\r\nudelay(100);\r\nval = (read_ssi(&ssi->sacdat) >> 4) & 0xffff;\r\nreturn val;\r\n}\r\nstatic void make_lowercase(char *s)\r\n{\r\nchar *p = s;\r\nchar c;\r\nwhile ((c = *p)) {\r\nif ((c >= 'A') && (c <= 'Z'))\r\n*p = c + ('a' - 'A');\r\np++;\r\n}\r\n}\r\nstatic int fsl_ssi_probe(struct platform_device *pdev)\r\n{\r\nstruct fsl_ssi_private *ssi_private;\r\nint ret = 0;\r\nstruct device_attribute *dev_attr = NULL;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id;\r\nenum fsl_ssi_type hw_type;\r\nconst char *p, *sprop;\r\nconst uint32_t *iprop;\r\nstruct resource res;\r\nchar name[64];\r\nbool shared;\r\nbool ac97 = false;\r\nif (!of_device_is_available(np))\r\nreturn -ENODEV;\r\nof_id = of_match_device(fsl_ssi_ids, &pdev->dev);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nhw_type = (enum fsl_ssi_type) of_id->data;\r\nsprop = of_get_property(np, "fsl,mode", NULL);\r\nif (!sprop) {\r\ndev_err(&pdev->dev, "fsl,mode property is necessary\n");\r\nreturn -EINVAL;\r\n}\r\nif (!strcmp(sprop, "ac97-slave"))\r\nac97 = true;\r\np = strrchr(np->full_name, '/') + 1;\r\nssi_private = devm_kzalloc(&pdev->dev, sizeof(*ssi_private) + strlen(p),\r\nGFP_KERNEL);\r\nif (!ssi_private) {\r\ndev_err(&pdev->dev, "could not allocate DAI object\n");\r\nreturn -ENOMEM;\r\n}\r\nstrcpy(ssi_private->name, p);\r\nssi_private->use_dma = !of_property_read_bool(np,\r\n"fsl,fiq-stream-filter");\r\nssi_private->hw_type = hw_type;\r\nif (ac97) {\r\nmemcpy(&ssi_private->cpu_dai_drv, &fsl_ssi_ac97_dai,\r\nsizeof(fsl_ssi_ac97_dai));\r\nfsl_ac97_data = ssi_private;\r\nssi_private->imx_ac97 = true;\r\nsnd_soc_set_ac97_ops_of_reset(&fsl_ssi_ac97_ops, pdev);\r\n} else {\r\nmemcpy(&ssi_private->cpu_dai_drv, &fsl_ssi_dai_template,\r\nsizeof(fsl_ssi_dai_template));\r\n}\r\nssi_private->cpu_dai_drv.name = ssi_private->name;\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not determine device resources\n");\r\nreturn ret;\r\n}\r\nssi_private->ssi = of_iomap(np, 0);\r\nif (!ssi_private->ssi) {\r\ndev_err(&pdev->dev, "could not map device resources\n");\r\nreturn -ENOMEM;\r\n}\r\nssi_private->ssi_phys = res.start;\r\nssi_private->irq = irq_of_parse_and_map(np, 0);\r\nif (!ssi_private->irq) {\r\ndev_err(&pdev->dev, "no irq for node %s\n", np->full_name);\r\nreturn -ENXIO;\r\n}\r\nif (!of_find_property(np, "fsl,ssi-asynchronous", NULL)) {\r\nssi_private->cpu_dai_drv.symmetric_rates = 1;\r\nssi_private->cpu_dai_drv.symmetric_channels = 1;\r\nssi_private->cpu_dai_drv.symmetric_samplebits = 1;\r\n}\r\niprop = of_get_property(np, "fsl,fifo-depth", NULL);\r\nif (iprop)\r\nssi_private->fifo_depth = be32_to_cpup(iprop);\r\nelse\r\nssi_private->fifo_depth = 8;\r\nssi_private->baudclk_locked = false;\r\nspin_lock_init(&ssi_private->baudclk_lock);\r\nswitch (hw_type) {\r\ncase FSL_SSI_MCP8610:\r\ncase FSL_SSI_MX21:\r\ncase FSL_SSI_MX35:\r\nssi_private->offline_config = true;\r\nbreak;\r\ncase FSL_SSI_MX51:\r\nssi_private->offline_config = false;\r\nbreak;\r\n}\r\nif (hw_type == FSL_SSI_MX21 || hw_type == FSL_SSI_MX51 ||\r\nhw_type == FSL_SSI_MX35) {\r\nu32 dma_events[2], dmas[4];\r\nssi_private->ssi_on_imx = true;\r\nssi_private->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(ssi_private->clk)) {\r\nret = PTR_ERR(ssi_private->clk);\r\ndev_err(&pdev->dev, "could not get clock: %d\n", ret);\r\ngoto error_irqmap;\r\n}\r\nret = clk_prepare_enable(ssi_private->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "clk_prepare_enable failed: %d\n",\r\nret);\r\ngoto error_irqmap;\r\n}\r\nssi_private->baudclk = devm_clk_get(&pdev->dev, "baud");\r\nif (IS_ERR(ssi_private->baudclk))\r\ndev_dbg(&pdev->dev, "could not get baud clock: %ld\n",\r\nPTR_ERR(ssi_private->baudclk));\r\nelse\r\nclk_prepare_enable(ssi_private->baudclk);\r\nssi_private->dma_params_tx.maxburst =\r\nssi_private->fifo_depth - 2;\r\nssi_private->dma_params_rx.maxburst =\r\nssi_private->fifo_depth - 2;\r\nssi_private->dma_params_tx.addr =\r\nssi_private->ssi_phys + offsetof(struct ccsr_ssi, stx0);\r\nssi_private->dma_params_rx.addr =\r\nssi_private->ssi_phys + offsetof(struct ccsr_ssi, srx0);\r\nssi_private->dma_params_tx.filter_data =\r\n&ssi_private->filter_data_tx;\r\nssi_private->dma_params_rx.filter_data =\r\n&ssi_private->filter_data_rx;\r\nif (!of_property_read_bool(pdev->dev.of_node, "dmas") &&\r\nssi_private->use_dma) {\r\nret = of_property_read_u32_array(pdev->dev.of_node,\r\n"fsl,ssi-dma-events", dma_events, 2);\r\nif (ret && ssi_private->use_dma) {\r\ndev_err(&pdev->dev, "could not get dma events but fsl-ssi is configured to use DMA\n");\r\ngoto error_clk;\r\n}\r\n}\r\nif (!of_property_read_u32_array(pdev->dev.of_node, "dmas", dmas, 4)\r\n&& dmas[2] == IMX_DMATYPE_SSI_DUAL) {\r\nssi_private->use_dual_fifo = true;\r\nssi_private->dma_params_tx.maxburst &= ~0x1;\r\nssi_private->dma_params_rx.maxburst &= ~0x1;\r\n}\r\nshared = of_device_is_compatible(of_get_parent(np),\r\n"fsl,spba-bus");\r\nimx_pcm_dma_params_init_data(&ssi_private->filter_data_tx,\r\ndma_events[0], shared ? IMX_DMATYPE_SSI_SP : IMX_DMATYPE_SSI);\r\nimx_pcm_dma_params_init_data(&ssi_private->filter_data_rx,\r\ndma_events[1], shared ? IMX_DMATYPE_SSI_SP : IMX_DMATYPE_SSI);\r\n}\r\nif (ssi_private->use_dma) {\r\nret = devm_request_irq(&pdev->dev, ssi_private->irq,\r\nfsl_ssi_isr, 0, ssi_private->name,\r\nssi_private);\r\nssi_private->irq_stats = true;\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not claim irq %u\n",\r\nssi_private->irq);\r\ngoto error_clk;\r\n}\r\n}\r\ndev_set_drvdata(&pdev->dev, ssi_private);\r\nret = snd_soc_register_component(&pdev->dev, &fsl_ssi_component,\r\n&ssi_private->cpu_dai_drv, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register DAI: %d\n", ret);\r\ngoto error_dev;\r\n}\r\nret = fsl_ssi_debugfs_create(ssi_private, &pdev->dev);\r\nif (ret)\r\ngoto error_dbgfs;\r\nif (ssi_private->ssi_on_imx) {\r\nif (!ssi_private->use_dma) {\r\nssi_private->fiq_params.irq = ssi_private->irq;\r\nssi_private->fiq_params.base = ssi_private->ssi;\r\nssi_private->fiq_params.dma_params_rx =\r\n&ssi_private->dma_params_rx;\r\nssi_private->fiq_params.dma_params_tx =\r\n&ssi_private->dma_params_tx;\r\nret = imx_pcm_fiq_init(pdev, &ssi_private->fiq_params);\r\nif (ret)\r\ngoto error_pcm;\r\n} else {\r\nret = imx_pcm_dma_init(pdev);\r\nif (ret)\r\ngoto error_pcm;\r\n}\r\n}\r\nif (!of_get_property(np, "codec-handle", NULL)) {\r\nssi_private->new_binding = true;\r\ngoto done;\r\n}\r\nsprop = of_get_property(of_find_node_by_path("/"), "compatible", NULL);\r\np = strrchr(sprop, ',');\r\nif (p)\r\nsprop = p + 1;\r\nsnprintf(name, sizeof(name), "snd-soc-%s", sprop);\r\nmake_lowercase(name);\r\nssi_private->pdev =\r\nplatform_device_register_data(&pdev->dev, name, 0, NULL, 0);\r\nif (IS_ERR(ssi_private->pdev)) {\r\nret = PTR_ERR(ssi_private->pdev);\r\ndev_err(&pdev->dev, "failed to register platform: %d\n", ret);\r\ngoto error_dai;\r\n}\r\ndone:\r\nif (ssi_private->imx_ac97)\r\nfsl_ssi_ac97_init();\r\nreturn 0;\r\nerror_dai:\r\nif (ssi_private->ssi_on_imx && !ssi_private->use_dma)\r\nimx_pcm_fiq_exit(pdev);\r\nerror_pcm:\r\nfsl_ssi_debugfs_remove(ssi_private);\r\nerror_dbgfs:\r\nsnd_soc_unregister_component(&pdev->dev);\r\nerror_dev:\r\ndevice_remove_file(&pdev->dev, dev_attr);\r\nerror_clk:\r\nif (ssi_private->ssi_on_imx) {\r\nif (!IS_ERR(ssi_private->baudclk))\r\nclk_disable_unprepare(ssi_private->baudclk);\r\nclk_disable_unprepare(ssi_private->clk);\r\n}\r\nerror_irqmap:\r\nif (ssi_private->irq_stats)\r\nirq_dispose_mapping(ssi_private->irq);\r\nreturn ret;\r\n}\r\nstatic int fsl_ssi_remove(struct platform_device *pdev)\r\n{\r\nstruct fsl_ssi_private *ssi_private = dev_get_drvdata(&pdev->dev);\r\nfsl_ssi_debugfs_remove(ssi_private);\r\nif (!ssi_private->new_binding)\r\nplatform_device_unregister(ssi_private->pdev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nif (ssi_private->ssi_on_imx) {\r\nif (!IS_ERR(ssi_private->baudclk))\r\nclk_disable_unprepare(ssi_private->baudclk);\r\nclk_disable_unprepare(ssi_private->clk);\r\n}\r\nif (ssi_private->irq_stats)\r\nirq_dispose_mapping(ssi_private->irq);\r\nreturn 0;\r\n}
