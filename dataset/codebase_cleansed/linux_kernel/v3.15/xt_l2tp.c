static bool l2tp_match(const struct xt_l2tp_info *info, struct l2tp_data *data)\r\n{\r\nif ((info->flags & XT_L2TP_TYPE) && (info->type != data->type))\r\nreturn false;\r\nif ((info->flags & XT_L2TP_VERSION) && (info->version != data->version))\r\nreturn false;\r\nif ((info->flags & XT_L2TP_TID) &&\r\n((data->type == XT_L2TP_TYPE_CONTROL) || (data->version == 2)) &&\r\n(info->tid != data->tid))\r\nreturn false;\r\nif ((info->flags & XT_L2TP_SID) && (data->type == XT_L2TP_TYPE_DATA) &&\r\n(info->sid != data->sid))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool l2tp_udp_mt(const struct sk_buff *skb, struct xt_action_param *par, u16 thoff)\r\n{\r\nconst struct xt_l2tp_info *info = par->matchinfo;\r\nint uhlen = sizeof(struct udphdr);\r\nint offs = thoff + uhlen;\r\nunion l2tp_val *lh;\r\nunion l2tp_val lhbuf;\r\nu16 flags;\r\nstruct l2tp_data data = { 0, };\r\nif (par->fragoff != 0)\r\nreturn false;\r\nlh = skb_header_pointer(skb, offs, 2, &lhbuf);\r\nif (lh == NULL)\r\nreturn false;\r\nflags = ntohs(lh->val16[0]);\r\nif (flags & L2TP_HDR_T_BIT)\r\ndata.type = XT_L2TP_TYPE_CONTROL;\r\nelse\r\ndata.type = XT_L2TP_TYPE_DATA;\r\ndata.version = (u8) flags & L2TP_HDR_VER;\r\nif (data.version == 3) {\r\nlh = skb_header_pointer(skb, offs + 4, 4, &lhbuf);\r\nif (lh == NULL)\r\nreturn false;\r\nif (data.type == XT_L2TP_TYPE_CONTROL)\r\ndata.tid = ntohl(lh->val32);\r\nelse\r\ndata.sid = ntohl(lh->val32);\r\n} else if (data.version == 2) {\r\nif (flags & L2TP_HDR_L_BIT)\r\noffs += 2;\r\nlh = skb_header_pointer(skb, offs + 2, 4, &lhbuf);\r\nif (lh == NULL)\r\nreturn false;\r\ndata.tid = (u32) ntohs(lh->val16[0]);\r\ndata.sid = (u32) ntohs(lh->val16[1]);\r\n} else\r\nreturn false;\r\nreturn l2tp_match(info, &data);\r\n}\r\nstatic bool l2tp_ip_mt(const struct sk_buff *skb, struct xt_action_param *par, u16 thoff)\r\n{\r\nconst struct xt_l2tp_info *info = par->matchinfo;\r\nunion l2tp_val *lh;\r\nunion l2tp_val lhbuf;\r\nstruct l2tp_data data = { 0, };\r\nlh = skb_header_pointer(skb, thoff, sizeof(lhbuf), &lhbuf);\r\nif (lh == NULL)\r\nreturn false;\r\nif (lh->val32 == 0) {\r\ndata.type = XT_L2TP_TYPE_CONTROL;\r\nlh = skb_header_pointer(skb, thoff + 8, sizeof(lhbuf),\r\n&lhbuf);\r\nif (lh == NULL)\r\nreturn false;\r\ndata.tid = ntohl(lh->val32);\r\n} else {\r\ndata.sid = ntohl(lh->val32);\r\ndata.type = XT_L2TP_TYPE_DATA;\r\n}\r\ndata.version = 3;\r\nreturn l2tp_match(info, &data);\r\n}\r\nstatic bool l2tp_mt4(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct iphdr *iph = ip_hdr(skb);\r\nu8 ipproto = iph->protocol;\r\nswitch (ipproto) {\r\ncase IPPROTO_UDP:\r\nreturn l2tp_udp_mt(skb, par, par->thoff);\r\ncase IPPROTO_L2TP:\r\nreturn l2tp_ip_mt(skb, par, par->thoff);\r\n}\r\nreturn false;\r\n}\r\nstatic bool l2tp_mt6(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nunsigned int thoff = 0;\r\nunsigned short fragoff = 0;\r\nint ipproto;\r\nipproto = ipv6_find_hdr(skb, &thoff, -1, &fragoff, NULL);\r\nif (fragoff != 0)\r\nreturn false;\r\nswitch (ipproto) {\r\ncase IPPROTO_UDP:\r\nreturn l2tp_udp_mt(skb, par, thoff);\r\ncase IPPROTO_L2TP:\r\nreturn l2tp_ip_mt(skb, par, thoff);\r\n}\r\nreturn false;\r\n}\r\nstatic int l2tp_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_l2tp_info *info = par->matchinfo;\r\nif (info->flags & ~(XT_L2TP_TID | XT_L2TP_SID | XT_L2TP_VERSION |\r\nXT_L2TP_TYPE)) {\r\npr_info("unknown flags: %x\n", info->flags);\r\nreturn -EINVAL;\r\n}\r\nif ((!(info->flags & XT_L2TP_TID)) &&\r\n(!(info->flags & XT_L2TP_SID)) &&\r\n((!(info->flags & XT_L2TP_TYPE)) ||\r\n(info->type != XT_L2TP_TYPE_CONTROL))) {\r\npr_info("invalid flags combination: %x\n", info->flags);\r\nreturn -EINVAL;\r\n}\r\nif (info->flags & XT_L2TP_VERSION) {\r\nif ((info->version < 2) || (info->version > 3)) {\r\npr_info("wrong L2TP version: %u\n", info->version);\r\nreturn -EINVAL;\r\n}\r\nif (info->version == 2) {\r\nif ((info->flags & XT_L2TP_TID) &&\r\n(info->tid > 0xffff)) {\r\npr_info("v2 tid > 0xffff: %u\n", info->tid);\r\nreturn -EINVAL;\r\n}\r\nif ((info->flags & XT_L2TP_SID) &&\r\n(info->sid > 0xffff)) {\r\npr_info("v2 sid > 0xffff: %u\n", info->sid);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int l2tp_mt_check4(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_l2tp_info *info = par->matchinfo;\r\nconst struct ipt_entry *e = par->entryinfo;\r\nconst struct ipt_ip *ip = &e->ip;\r\nint ret;\r\nret = l2tp_mt_check(par);\r\nif (ret != 0)\r\nreturn ret;\r\nif ((ip->proto != IPPROTO_UDP) &&\r\n(ip->proto != IPPROTO_L2TP)) {\r\npr_info("missing protocol rule (udp|l2tpip)\n");\r\nreturn -EINVAL;\r\n}\r\nif ((ip->proto == IPPROTO_L2TP) &&\r\n(info->version == 2)) {\r\npr_info("v2 doesn't support IP mode\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int l2tp_mt_check6(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_l2tp_info *info = par->matchinfo;\r\nconst struct ip6t_entry *e = par->entryinfo;\r\nconst struct ip6t_ip6 *ip = &e->ipv6;\r\nint ret;\r\nret = l2tp_mt_check(par);\r\nif (ret != 0)\r\nreturn ret;\r\nif ((ip->proto != IPPROTO_UDP) &&\r\n(ip->proto != IPPROTO_L2TP)) {\r\npr_info("missing protocol rule (udp|l2tpip)\n");\r\nreturn -EINVAL;\r\n}\r\nif ((ip->proto == IPPROTO_L2TP) &&\r\n(info->version == 2)) {\r\npr_info("v2 doesn't support IP mode\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init l2tp_mt_init(void)\r\n{\r\nreturn xt_register_matches(&l2tp_mt_reg[0], ARRAY_SIZE(l2tp_mt_reg));\r\n}\r\nstatic void __exit l2tp_mt_exit(void)\r\n{\r\nxt_unregister_matches(&l2tp_mt_reg[0], ARRAY_SIZE(l2tp_mt_reg));\r\n}
