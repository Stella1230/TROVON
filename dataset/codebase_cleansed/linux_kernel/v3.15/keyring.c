static inline bool keyring_ptr_is_keyring(const struct assoc_array_ptr *x)\r\n{\r\nreturn (unsigned long)x & KEYRING_PTR_SUBTYPE;\r\n}\r\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\r\n{\r\nvoid *object = assoc_array_ptr_to_leaf(x);\r\nreturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\r\n}\r\nstatic inline void *keyring_key_to_ptr(struct key *key)\r\n{\r\nif (key->type == &key_type_keyring)\r\nreturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\r\nreturn key;\r\n}\r\nstatic inline unsigned keyring_hash(const char *desc)\r\n{\r\nunsigned bucket = 0;\r\nfor (; *desc; desc++)\r\nbucket += (unsigned char)*desc;\r\nreturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\r\n}\r\nstatic void keyring_publish_name(struct key *keyring)\r\n{\r\nint bucket;\r\nif (keyring->description) {\r\nbucket = keyring_hash(keyring->description);\r\nwrite_lock(&keyring_name_lock);\r\nif (!keyring_name_hash[bucket].next)\r\nINIT_LIST_HEAD(&keyring_name_hash[bucket]);\r\nlist_add_tail(&keyring->type_data.link,\r\n&keyring_name_hash[bucket]);\r\nwrite_unlock(&keyring_name_lock);\r\n}\r\n}\r\nstatic int keyring_instantiate(struct key *keyring,\r\nstruct key_preparsed_payload *prep)\r\n{\r\nint ret;\r\nret = -EINVAL;\r\nif (prep->datalen == 0) {\r\nassoc_array_init(&keyring->keys);\r\nkeyring_publish_name(keyring);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic u64 mult_64x32_and_fold(u64 x, u32 y)\r\n{\r\nu64 hi = (u64)(u32)(x >> 32) * y;\r\nu64 lo = (u64)(u32)(x) * y;\r\nreturn lo + ((u64)(u32)hi << 32) + (u32)(hi >> 32);\r\n}\r\nstatic unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\r\n{\r\nconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\r\nconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\r\nconst char *description = index_key->description;\r\nunsigned long hash, type;\r\nu32 piece;\r\nu64 acc;\r\nint n, desc_len = index_key->desc_len;\r\ntype = (unsigned long)index_key->type;\r\nacc = mult_64x32_and_fold(type, desc_len + 13);\r\nacc = mult_64x32_and_fold(acc, 9207);\r\nfor (;;) {\r\nn = desc_len;\r\nif (n <= 0)\r\nbreak;\r\nif (n > 4)\r\nn = 4;\r\npiece = 0;\r\nmemcpy(&piece, description, n);\r\ndescription += n;\r\ndesc_len -= n;\r\nacc = mult_64x32_and_fold(acc, piece);\r\nacc = mult_64x32_and_fold(acc, 9207);\r\n}\r\nhash = acc;\r\nif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\r\nhash ^= acc >> 32;\r\nif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\r\nreturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\r\nif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\r\nreturn (hash + (hash << level_shift)) & ~fan_mask;\r\nreturn hash;\r\n}\r\nstatic unsigned long keyring_get_key_chunk(const void *data, int level)\r\n{\r\nconst struct keyring_index_key *index_key = data;\r\nunsigned long chunk = 0;\r\nlong offset = 0;\r\nint desc_len = index_key->desc_len, n = sizeof(chunk);\r\nlevel /= ASSOC_ARRAY_KEY_CHUNK_SIZE;\r\nswitch (level) {\r\ncase 0:\r\nreturn hash_key_type_and_desc(index_key);\r\ncase 1:\r\nreturn ((unsigned long)index_key->type << 8) | desc_len;\r\ncase 2:\r\nif (desc_len == 0)\r\nreturn (u8)((unsigned long)index_key->type >>\r\n(ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\r\nn--;\r\noffset = 1;\r\ndefault:\r\noffset += sizeof(chunk) - 1;\r\noffset += (level - 3) * sizeof(chunk);\r\nif (offset >= desc_len)\r\nreturn 0;\r\ndesc_len -= offset;\r\nif (desc_len > n)\r\ndesc_len = n;\r\noffset += desc_len;\r\ndo {\r\nchunk <<= 8;\r\nchunk |= ((u8*)index_key->description)[--offset];\r\n} while (--desc_len > 0);\r\nif (level == 2) {\r\nchunk <<= 8;\r\nchunk |= (u8)((unsigned long)index_key->type >>\r\n(ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\r\n}\r\nreturn chunk;\r\n}\r\n}\r\nstatic unsigned long keyring_get_object_key_chunk(const void *object, int level)\r\n{\r\nconst struct key *key = keyring_ptr_to_key(object);\r\nreturn keyring_get_key_chunk(&key->index_key, level);\r\n}\r\nstatic bool keyring_compare_object(const void *object, const void *data)\r\n{\r\nconst struct keyring_index_key *index_key = data;\r\nconst struct key *key = keyring_ptr_to_key(object);\r\nreturn key->index_key.type == index_key->type &&\r\nkey->index_key.desc_len == index_key->desc_len &&\r\nmemcmp(key->index_key.description, index_key->description,\r\nindex_key->desc_len) == 0;\r\n}\r\nstatic int keyring_diff_objects(const void *object, const void *data)\r\n{\r\nconst struct key *key_a = keyring_ptr_to_key(object);\r\nconst struct keyring_index_key *a = &key_a->index_key;\r\nconst struct keyring_index_key *b = data;\r\nunsigned long seg_a, seg_b;\r\nint level, i;\r\nlevel = 0;\r\nseg_a = hash_key_type_and_desc(a);\r\nseg_b = hash_key_type_and_desc(b);\r\nif ((seg_a ^ seg_b) != 0)\r\ngoto differ;\r\nlevel += ASSOC_ARRAY_KEY_CHUNK_SIZE / 8;\r\nseg_a = a->desc_len;\r\nseg_b = b->desc_len;\r\nif ((seg_a ^ seg_b) != 0)\r\ngoto differ;\r\nlevel++;\r\nseg_a = (unsigned long)a->type;\r\nseg_b = (unsigned long)b->type;\r\nif ((seg_a ^ seg_b) != 0)\r\ngoto differ;\r\nlevel += sizeof(unsigned long);\r\nif (a->desc_len == 0)\r\ngoto same;\r\ni = 0;\r\nif (((unsigned long)a->description | (unsigned long)b->description) &\r\n(sizeof(unsigned long) - 1)) {\r\ndo {\r\nseg_a = *(unsigned long *)(a->description + i);\r\nseg_b = *(unsigned long *)(b->description + i);\r\nif ((seg_a ^ seg_b) != 0)\r\ngoto differ_plus_i;\r\ni += sizeof(unsigned long);\r\n} while (i < (a->desc_len & (sizeof(unsigned long) - 1)));\r\n}\r\nfor (; i < a->desc_len; i++) {\r\nseg_a = *(unsigned char *)(a->description + i);\r\nseg_b = *(unsigned char *)(b->description + i);\r\nif ((seg_a ^ seg_b) != 0)\r\ngoto differ_plus_i;\r\n}\r\nsame:\r\nreturn -1;\r\ndiffer_plus_i:\r\nlevel += i;\r\ndiffer:\r\ni = level * 8 + __ffs(seg_a ^ seg_b);\r\nreturn i;\r\n}\r\nstatic void keyring_free_object(void *object)\r\n{\r\nkey_put(keyring_ptr_to_key(object));\r\n}\r\nstatic void keyring_destroy(struct key *keyring)\r\n{\r\nif (keyring->description) {\r\nwrite_lock(&keyring_name_lock);\r\nif (keyring->type_data.link.next != NULL &&\r\n!list_empty(&keyring->type_data.link))\r\nlist_del(&keyring->type_data.link);\r\nwrite_unlock(&keyring_name_lock);\r\n}\r\nassoc_array_destroy(&keyring->keys, &keyring_assoc_array_ops);\r\n}\r\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m)\r\n{\r\nif (keyring->description)\r\nseq_puts(m, keyring->description);\r\nelse\r\nseq_puts(m, "[anon]");\r\nif (key_is_instantiated(keyring)) {\r\nif (keyring->keys.nr_leaves_on_tree != 0)\r\nseq_printf(m, ": %lu", keyring->keys.nr_leaves_on_tree);\r\nelse\r\nseq_puts(m, ": empty");\r\n}\r\n}\r\nstatic int keyring_read_iterator(const void *object, void *data)\r\n{\r\nstruct keyring_read_iterator_context *ctx = data;\r\nconst struct key *key = keyring_ptr_to_key(object);\r\nint ret;\r\nkenter("{%s,%d},,{%zu/%zu}",\r\nkey->type->name, key->serial, ctx->count, ctx->qty);\r\nif (ctx->count >= ctx->qty)\r\nreturn 1;\r\nret = put_user(key->serial, ctx->buffer);\r\nif (ret < 0)\r\nreturn ret;\r\nctx->buffer++;\r\nctx->count += sizeof(key->serial);\r\nreturn 0;\r\n}\r\nstatic long keyring_read(const struct key *keyring,\r\nchar __user *buffer, size_t buflen)\r\n{\r\nstruct keyring_read_iterator_context ctx;\r\nunsigned long nr_keys;\r\nint ret;\r\nkenter("{%d},,%zu", key_serial(keyring), buflen);\r\nif (buflen & (sizeof(key_serial_t) - 1))\r\nreturn -EINVAL;\r\nnr_keys = keyring->keys.nr_leaves_on_tree;\r\nif (nr_keys == 0)\r\nreturn 0;\r\nctx.qty = nr_keys * sizeof(key_serial_t);\r\nif (!buffer || !buflen)\r\nreturn ctx.qty;\r\nif (buflen > ctx.qty)\r\nctx.qty = buflen;\r\nctx.buffer = (key_serial_t __user *)buffer;\r\nctx.count = 0;\r\nret = assoc_array_iterate(&keyring->keys, keyring_read_iterator, &ctx);\r\nif (ret < 0) {\r\nkleave(" = %d [iterate]", ret);\r\nreturn ret;\r\n}\r\nkleave(" = %zu [ok]", ctx.count);\r\nreturn ctx.count;\r\n}\r\nstruct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\r\nconst struct cred *cred, key_perm_t perm,\r\nunsigned long flags, struct key *dest)\r\n{\r\nstruct key *keyring;\r\nint ret;\r\nkeyring = key_alloc(&key_type_keyring, description,\r\nuid, gid, cred, perm, flags);\r\nif (!IS_ERR(keyring)) {\r\nret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\r\nif (ret < 0) {\r\nkey_put(keyring);\r\nkeyring = ERR_PTR(ret);\r\n}\r\n}\r\nreturn keyring;\r\n}\r\nstatic int keyring_search_iterator(const void *object, void *iterator_data)\r\n{\r\nstruct keyring_search_context *ctx = iterator_data;\r\nconst struct key *key = keyring_ptr_to_key(object);\r\nunsigned long kflags = key->flags;\r\nkenter("{%d}", key->serial);\r\nif (key->type != ctx->index_key.type) {\r\nkleave(" = 0 [!type]");\r\nreturn 0;\r\n}\r\nif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\r\nif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\r\n(1 << KEY_FLAG_REVOKED))) {\r\nctx->result = ERR_PTR(-EKEYREVOKED);\r\nkleave(" = %d [invrev]", ctx->skipped_ret);\r\ngoto skipped;\r\n}\r\nif (key->expiry && ctx->now.tv_sec >= key->expiry) {\r\nctx->result = ERR_PTR(-EKEYEXPIRED);\r\nkleave(" = %d [expire]", ctx->skipped_ret);\r\ngoto skipped;\r\n}\r\n}\r\nif (!ctx->match(key, ctx->match_data)) {\r\nkleave(" = 0 [!match]");\r\nreturn 0;\r\n}\r\nif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\r\nkey_task_permission(make_key_ref(key, ctx->possessed),\r\nctx->cred, KEY_SEARCH) < 0) {\r\nctx->result = ERR_PTR(-EACCES);\r\nkleave(" = %d [!perm]", ctx->skipped_ret);\r\ngoto skipped;\r\n}\r\nif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\r\nif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\r\nsmp_rmb();\r\nctx->result = ERR_PTR(key->type_data.reject_error);\r\nkleave(" = %d [neg]", ctx->skipped_ret);\r\ngoto skipped;\r\n}\r\n}\r\nctx->result = make_key_ref(key, ctx->possessed);\r\nkleave(" = 1 [found]");\r\nreturn 1;\r\nskipped:\r\nreturn ctx->skipped_ret;\r\n}\r\nstatic int search_keyring(struct key *keyring, struct keyring_search_context *ctx)\r\n{\r\nif ((ctx->flags & KEYRING_SEARCH_LOOKUP_TYPE) ==\r\nKEYRING_SEARCH_LOOKUP_DIRECT) {\r\nconst void *object;\r\nobject = assoc_array_find(&keyring->keys,\r\n&keyring_assoc_array_ops,\r\n&ctx->index_key);\r\nreturn object ? ctx->iterator(object, ctx) : 0;\r\n}\r\nreturn assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);\r\n}\r\nstatic bool search_nested_keyrings(struct key *keyring,\r\nstruct keyring_search_context *ctx)\r\n{\r\nstruct {\r\nstruct key *keyring;\r\nstruct assoc_array_node *node;\r\nint slot;\r\n} stack[KEYRING_SEARCH_MAX_DEPTH];\r\nstruct assoc_array_shortcut *shortcut;\r\nstruct assoc_array_node *node;\r\nstruct assoc_array_ptr *ptr;\r\nstruct key *key;\r\nint sp = 0, slot;\r\nkenter("{%d},{%s,%s}",\r\nkeyring->serial,\r\nctx->index_key.type->name,\r\nctx->index_key.description);\r\nif (ctx->index_key.description)\r\nctx->index_key.desc_len = strlen(ctx->index_key.description);\r\nif (ctx->flags & KEYRING_SEARCH_LOOKUP_ITERATE ||\r\nkeyring_compare_object(keyring, &ctx->index_key)) {\r\nctx->skipped_ret = 2;\r\nctx->flags |= KEYRING_SEARCH_DO_STATE_CHECK;\r\nswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\r\ncase 1:\r\ngoto found;\r\ncase 2:\r\nreturn false;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nctx->skipped_ret = 0;\r\nif (ctx->flags & KEYRING_SEARCH_NO_STATE_CHECK)\r\nctx->flags &= ~KEYRING_SEARCH_DO_STATE_CHECK;\r\ndescend_to_keyring:\r\nkdebug("descend to %d", keyring->serial);\r\nif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\r\n(1 << KEY_FLAG_REVOKED)))\r\ngoto not_this_keyring;\r\nif (search_keyring(keyring, ctx))\r\ngoto found;\r\nptr = ACCESS_ONCE(keyring->keys.root);\r\nif (!ptr)\r\ngoto not_this_keyring;\r\nif (assoc_array_ptr_is_shortcut(ptr)) {\r\nshortcut = assoc_array_ptr_to_shortcut(ptr);\r\nsmp_read_barrier_depends();\r\nif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\r\ngoto not_this_keyring;\r\nptr = ACCESS_ONCE(shortcut->next_node);\r\nnode = assoc_array_ptr_to_node(ptr);\r\ngoto begin_node;\r\n}\r\nnode = assoc_array_ptr_to_node(ptr);\r\nsmp_read_barrier_depends();\r\nptr = node->slots[0];\r\nif (!assoc_array_ptr_is_meta(ptr))\r\ngoto begin_node;\r\ndescend_to_node:\r\nkdebug("descend");\r\nif (assoc_array_ptr_is_shortcut(ptr)) {\r\nshortcut = assoc_array_ptr_to_shortcut(ptr);\r\nsmp_read_barrier_depends();\r\nptr = ACCESS_ONCE(shortcut->next_node);\r\nBUG_ON(!assoc_array_ptr_is_node(ptr));\r\n}\r\nnode = assoc_array_ptr_to_node(ptr);\r\nbegin_node:\r\nkdebug("begin_node");\r\nsmp_read_barrier_depends();\r\nslot = 0;\r\nascend_to_node:\r\nfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\r\nptr = ACCESS_ONCE(node->slots[slot]);\r\nif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\r\ngoto descend_to_node;\r\nif (!keyring_ptr_is_keyring(ptr))\r\ncontinue;\r\nkey = keyring_ptr_to_key(ptr);\r\nif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\r\nif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\r\nctx->result = ERR_PTR(-ELOOP);\r\nreturn false;\r\n}\r\ngoto not_this_keyring;\r\n}\r\nif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\r\nkey_task_permission(make_key_ref(key, ctx->possessed),\r\nctx->cred, KEY_SEARCH) < 0)\r\ncontinue;\r\nstack[sp].keyring = keyring;\r\nstack[sp].node = node;\r\nstack[sp].slot = slot;\r\nsp++;\r\nkeyring = key;\r\ngoto descend_to_keyring;\r\n}\r\nptr = ACCESS_ONCE(node->back_pointer);\r\nslot = node->parent_slot;\r\nif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\r\nshortcut = assoc_array_ptr_to_shortcut(ptr);\r\nsmp_read_barrier_depends();\r\nptr = ACCESS_ONCE(shortcut->back_pointer);\r\nslot = shortcut->parent_slot;\r\n}\r\nif (!ptr)\r\ngoto not_this_keyring;\r\nnode = assoc_array_ptr_to_node(ptr);\r\nsmp_read_barrier_depends();\r\nslot++;\r\nif (node->back_pointer) {\r\nkdebug("ascend %d", slot);\r\ngoto ascend_to_node;\r\n}\r\nnot_this_keyring:\r\nkdebug("not_this_keyring %d", sp);\r\nif (sp <= 0) {\r\nkleave(" = false");\r\nreturn false;\r\n}\r\nsp--;\r\nkeyring = stack[sp].keyring;\r\nnode = stack[sp].node;\r\nslot = stack[sp].slot + 1;\r\nkdebug("ascend to %d [%d]", keyring->serial, slot);\r\ngoto ascend_to_node;\r\nfound:\r\nkey = key_ref_to_ptr(ctx->result);\r\nkey_check(key);\r\nif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\r\nkey->last_used_at = ctx->now.tv_sec;\r\nkeyring->last_used_at = ctx->now.tv_sec;\r\nwhile (sp > 0)\r\nstack[--sp].keyring->last_used_at = ctx->now.tv_sec;\r\n}\r\nkleave(" = true");\r\nreturn true;\r\n}\r\nkey_ref_t keyring_search_aux(key_ref_t keyring_ref,\r\nstruct keyring_search_context *ctx)\r\n{\r\nstruct key *keyring;\r\nlong err;\r\nctx->iterator = keyring_search_iterator;\r\nctx->possessed = is_key_possessed(keyring_ref);\r\nctx->result = ERR_PTR(-EAGAIN);\r\nkeyring = key_ref_to_ptr(keyring_ref);\r\nkey_check(keyring);\r\nif (keyring->type != &key_type_keyring)\r\nreturn ERR_PTR(-ENOTDIR);\r\nif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {\r\nerr = key_task_permission(keyring_ref, ctx->cred, KEY_SEARCH);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\n}\r\nrcu_read_lock();\r\nctx->now = current_kernel_time();\r\nif (search_nested_keyrings(keyring, ctx))\r\n__key_get(key_ref_to_ptr(ctx->result));\r\nrcu_read_unlock();\r\nreturn ctx->result;\r\n}\r\nkey_ref_t keyring_search(key_ref_t keyring,\r\nstruct key_type *type,\r\nconst char *description)\r\n{\r\nstruct keyring_search_context ctx = {\r\n.index_key.type = type,\r\n.index_key.description = description,\r\n.cred = current_cred(),\r\n.match = type->match,\r\n.match_data = description,\r\n.flags = (type->def_lookup_type |\r\nKEYRING_SEARCH_DO_STATE_CHECK),\r\n};\r\nif (!ctx.match)\r\nreturn ERR_PTR(-ENOKEY);\r\nreturn keyring_search_aux(keyring, &ctx);\r\n}\r\nkey_ref_t find_key_to_update(key_ref_t keyring_ref,\r\nconst struct keyring_index_key *index_key)\r\n{\r\nstruct key *keyring, *key;\r\nconst void *object;\r\nkeyring = key_ref_to_ptr(keyring_ref);\r\nkenter("{%d},{%s,%s}",\r\nkeyring->serial, index_key->type->name, index_key->description);\r\nobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\r\nindex_key);\r\nif (object)\r\ngoto found;\r\nkleave(" = NULL");\r\nreturn NULL;\r\nfound:\r\nkey = keyring_ptr_to_key(object);\r\nif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\r\n(1 << KEY_FLAG_REVOKED))) {\r\nkleave(" = NULL [x]");\r\nreturn NULL;\r\n}\r\n__key_get(key);\r\nkleave(" = {%d}", key->serial);\r\nreturn make_key_ref(key, is_key_possessed(keyring_ref));\r\n}\r\nstruct key *find_keyring_by_name(const char *name, bool skip_perm_check)\r\n{\r\nstruct key *keyring;\r\nint bucket;\r\nif (!name)\r\nreturn ERR_PTR(-EINVAL);\r\nbucket = keyring_hash(name);\r\nread_lock(&keyring_name_lock);\r\nif (keyring_name_hash[bucket].next) {\r\nlist_for_each_entry(keyring,\r\n&keyring_name_hash[bucket],\r\ntype_data.link\r\n) {\r\nif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\r\ncontinue;\r\nif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\r\ncontinue;\r\nif (strcmp(keyring->description, name) != 0)\r\ncontinue;\r\nif (!skip_perm_check &&\r\nkey_permission(make_key_ref(keyring, 0),\r\nKEY_SEARCH) < 0)\r\ncontinue;\r\nif (!atomic_inc_not_zero(&keyring->usage))\r\ncontinue;\r\nkeyring->last_used_at = current_kernel_time().tv_sec;\r\ngoto out;\r\n}\r\n}\r\nkeyring = ERR_PTR(-ENOKEY);\r\nout:\r\nread_unlock(&keyring_name_lock);\r\nreturn keyring;\r\n}\r\nstatic int keyring_detect_cycle_iterator(const void *object,\r\nvoid *iterator_data)\r\n{\r\nstruct keyring_search_context *ctx = iterator_data;\r\nconst struct key *key = keyring_ptr_to_key(object);\r\nkenter("{%d}", key->serial);\r\nif (key != ctx->match_data)\r\nreturn 0;\r\nctx->result = ERR_PTR(-EDEADLK);\r\nreturn 1;\r\n}\r\nstatic int keyring_detect_cycle(struct key *A, struct key *B)\r\n{\r\nstruct keyring_search_context ctx = {\r\n.index_key = A->index_key,\r\n.match_data = A,\r\n.iterator = keyring_detect_cycle_iterator,\r\n.flags = (KEYRING_SEARCH_LOOKUP_DIRECT |\r\nKEYRING_SEARCH_NO_STATE_CHECK |\r\nKEYRING_SEARCH_NO_UPDATE_TIME |\r\nKEYRING_SEARCH_NO_CHECK_PERM |\r\nKEYRING_SEARCH_DETECT_TOO_DEEP),\r\n};\r\nrcu_read_lock();\r\nsearch_nested_keyrings(B, &ctx);\r\nrcu_read_unlock();\r\nreturn PTR_ERR(ctx.result) == -EAGAIN ? 0 : PTR_ERR(ctx.result);\r\n}\r\nint __key_link_begin(struct key *keyring,\r\nconst struct keyring_index_key *index_key,\r\nstruct assoc_array_edit **_edit)\r\n__acquires(&keyring->sem\r\nint __key_link_check_live_key(struct key *keyring, struct key *key)\r\n{\r\nif (key->type == &key_type_keyring)\r\nreturn keyring_detect_cycle(keyring, key);\r\nreturn 0;\r\n}\r\nvoid __key_link(struct key *key, struct assoc_array_edit **_edit)\r\n{\r\n__key_get(key);\r\nassoc_array_insert_set_object(*_edit, keyring_key_to_ptr(key));\r\nassoc_array_apply_edit(*_edit);\r\n*_edit = NULL;\r\n}\r\nvoid __key_link_end(struct key *keyring,\r\nconst struct keyring_index_key *index_key,\r\nstruct assoc_array_edit *edit)\r\n__releases(&keyring->sem\r\nint key_link(struct key *keyring, struct key *key)\r\n{\r\nstruct assoc_array_edit *edit;\r\nint ret;\r\nkenter("{%d,%d}", keyring->serial, atomic_read(&keyring->usage));\r\nkey_check(keyring);\r\nkey_check(key);\r\nif (test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags) &&\r\n!test_bit(KEY_FLAG_TRUSTED, &key->flags))\r\nreturn -EPERM;\r\nret = __key_link_begin(keyring, &key->index_key, &edit);\r\nif (ret == 0) {\r\nkdebug("begun {%d,%d}", keyring->serial, atomic_read(&keyring->usage));\r\nret = __key_link_check_live_key(keyring, key);\r\nif (ret == 0)\r\n__key_link(key, &edit);\r\n__key_link_end(keyring, &key->index_key, edit);\r\n}\r\nkleave(" = %d {%d,%d}", ret, keyring->serial, atomic_read(&keyring->usage));\r\nreturn ret;\r\n}\r\nint key_unlink(struct key *keyring, struct key *key)\r\n{\r\nstruct assoc_array_edit *edit;\r\nint ret;\r\nkey_check(keyring);\r\nkey_check(key);\r\nif (keyring->type != &key_type_keyring)\r\nreturn -ENOTDIR;\r\ndown_write(&keyring->sem);\r\nedit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,\r\n&key->index_key);\r\nif (IS_ERR(edit)) {\r\nret = PTR_ERR(edit);\r\ngoto error;\r\n}\r\nret = -ENOENT;\r\nif (edit == NULL)\r\ngoto error;\r\nassoc_array_apply_edit(edit);\r\nkey_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);\r\nret = 0;\r\nerror:\r\nup_write(&keyring->sem);\r\nreturn ret;\r\n}\r\nint keyring_clear(struct key *keyring)\r\n{\r\nstruct assoc_array_edit *edit;\r\nint ret;\r\nif (keyring->type != &key_type_keyring)\r\nreturn -ENOTDIR;\r\ndown_write(&keyring->sem);\r\nedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\r\nif (IS_ERR(edit)) {\r\nret = PTR_ERR(edit);\r\n} else {\r\nif (edit)\r\nassoc_array_apply_edit(edit);\r\nkey_payload_reserve(keyring, 0);\r\nret = 0;\r\n}\r\nup_write(&keyring->sem);\r\nreturn ret;\r\n}\r\nstatic void keyring_revoke(struct key *keyring)\r\n{\r\nstruct assoc_array_edit *edit;\r\nedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\r\nif (!IS_ERR(edit)) {\r\nif (edit)\r\nassoc_array_apply_edit(edit);\r\nkey_payload_reserve(keyring, 0);\r\n}\r\n}\r\nstatic bool keyring_gc_select_iterator(void *object, void *iterator_data)\r\n{\r\nstruct key *key = keyring_ptr_to_key(object);\r\ntime_t *limit = iterator_data;\r\nif (key_is_dead(key, *limit))\r\nreturn false;\r\nkey_get(key);\r\nreturn true;\r\n}\r\nstatic int keyring_gc_check_iterator(const void *object, void *iterator_data)\r\n{\r\nconst struct key *key = keyring_ptr_to_key(object);\r\ntime_t *limit = iterator_data;\r\nkey_check(key);\r\nreturn key_is_dead(key, *limit);\r\n}\r\nvoid keyring_gc(struct key *keyring, time_t limit)\r\n{\r\nint result;\r\nkenter("%x{%s}", keyring->serial, keyring->description ?: "");\r\nif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\r\n(1 << KEY_FLAG_REVOKED)))\r\ngoto dont_gc;\r\nrcu_read_lock();\r\nresult = assoc_array_iterate(&keyring->keys,\r\nkeyring_gc_check_iterator, &limit);\r\nrcu_read_unlock();\r\nif (result == true)\r\ngoto do_gc;\r\ndont_gc:\r\nkleave(" [no gc]");\r\nreturn;\r\ndo_gc:\r\ndown_write(&keyring->sem);\r\nassoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,\r\nkeyring_gc_select_iterator, &limit);\r\nup_write(&keyring->sem);\r\nkleave(" [gc]");\r\n}
