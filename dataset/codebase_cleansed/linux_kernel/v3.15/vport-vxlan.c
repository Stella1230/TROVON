static inline struct vxlan_port *vxlan_vport(const struct vport *vport)\r\n{\r\nreturn vport_priv(vport);\r\n}\r\nstatic void vxlan_rcv(struct vxlan_sock *vs, struct sk_buff *skb, __be32 vx_vni)\r\n{\r\nstruct ovs_key_ipv4_tunnel tun_key;\r\nstruct vport *vport = vs->data;\r\nstruct iphdr *iph;\r\n__be64 key;\r\niph = ip_hdr(skb);\r\nkey = cpu_to_be64(ntohl(vx_vni) >> 8);\r\novs_flow_tun_key_init(&tun_key, iph, key, TUNNEL_KEY);\r\novs_vport_receive(vport, skb, &tun_key);\r\n}\r\nstatic int vxlan_get_options(const struct vport *vport, struct sk_buff *skb)\r\n{\r\nstruct vxlan_port *vxlan_port = vxlan_vport(vport);\r\n__be16 dst_port = inet_sk(vxlan_port->vs->sock->sk)->inet_sport;\r\nif (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(dst_port)))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic void vxlan_tnl_destroy(struct vport *vport)\r\n{\r\nstruct vxlan_port *vxlan_port = vxlan_vport(vport);\r\nvxlan_sock_release(vxlan_port->vs);\r\novs_vport_deferred_free(vport);\r\n}\r\nstatic struct vport *vxlan_tnl_create(const struct vport_parms *parms)\r\n{\r\nstruct net *net = ovs_dp_get_net(parms->dp);\r\nstruct nlattr *options = parms->options;\r\nstruct vxlan_port *vxlan_port;\r\nstruct vxlan_sock *vs;\r\nstruct vport *vport;\r\nstruct nlattr *a;\r\nu16 dst_port;\r\nint err;\r\nif (!options) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\na = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);\r\nif (a && nla_len(a) == sizeof(u16)) {\r\ndst_port = nla_get_u16(a);\r\n} else {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nvport = ovs_vport_alloc(sizeof(struct vxlan_port),\r\n&ovs_vxlan_vport_ops, parms);\r\nif (IS_ERR(vport))\r\nreturn vport;\r\nvxlan_port = vxlan_vport(vport);\r\nstrncpy(vxlan_port->name, parms->name, IFNAMSIZ);\r\nvs = vxlan_sock_add(net, htons(dst_port), vxlan_rcv, vport, true, false);\r\nif (IS_ERR(vs)) {\r\novs_vport_free(vport);\r\nreturn (void *)vs;\r\n}\r\nvxlan_port->vs = vs;\r\nreturn vport;\r\nerror:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int vxlan_tnl_send(struct vport *vport, struct sk_buff *skb)\r\n{\r\nstruct net *net = ovs_dp_get_net(vport->dp);\r\nstruct vxlan_port *vxlan_port = vxlan_vport(vport);\r\n__be16 dst_port = inet_sk(vxlan_port->vs->sock->sk)->inet_sport;\r\nstruct rtable *rt;\r\nstruct flowi4 fl;\r\n__be16 src_port;\r\nint port_min;\r\nint port_max;\r\n__be16 df;\r\nint err;\r\nif (unlikely(!OVS_CB(skb)->tun_key)) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nmemset(&fl, 0, sizeof(fl));\r\nfl.daddr = OVS_CB(skb)->tun_key->ipv4_dst;\r\nfl.saddr = OVS_CB(skb)->tun_key->ipv4_src;\r\nfl.flowi4_tos = RT_TOS(OVS_CB(skb)->tun_key->ipv4_tos);\r\nfl.flowi4_mark = skb->mark;\r\nfl.flowi4_proto = IPPROTO_UDP;\r\nrt = ip_route_output_key(net, &fl);\r\nif (IS_ERR(rt)) {\r\nerr = PTR_ERR(rt);\r\ngoto error;\r\n}\r\ndf = OVS_CB(skb)->tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ?\r\nhtons(IP_DF) : 0;\r\nskb->local_df = 1;\r\ninet_get_local_port_range(net, &port_min, &port_max);\r\nsrc_port = vxlan_src_port(port_min, port_max, skb);\r\nerr = vxlan_xmit_skb(vxlan_port->vs, rt, skb,\r\nfl.saddr, OVS_CB(skb)->tun_key->ipv4_dst,\r\nOVS_CB(skb)->tun_key->ipv4_tos,\r\nOVS_CB(skb)->tun_key->ipv4_ttl, df,\r\nsrc_port, dst_port,\r\nhtonl(be64_to_cpu(OVS_CB(skb)->tun_key->tun_id) << 8));\r\nif (err < 0)\r\nip_rt_put(rt);\r\nerror:\r\nreturn err;\r\n}\r\nstatic const char *vxlan_get_name(const struct vport *vport)\r\n{\r\nstruct vxlan_port *vxlan_port = vxlan_vport(vport);\r\nreturn vxlan_port->name;\r\n}
