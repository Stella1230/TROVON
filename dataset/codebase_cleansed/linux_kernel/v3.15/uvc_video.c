static int\r\nuvc_video_encode_header(struct uvc_video *video, struct uvc_buffer *buf,\r\nu8 *data, int len)\r\n{\r\ndata[0] = 2;\r\ndata[1] = UVC_STREAM_EOH | video->fid;\r\nif (buf->bytesused - video->queue.buf_used <= len - 2)\r\ndata[1] |= UVC_STREAM_EOF;\r\nreturn 2;\r\n}\r\nstatic int\r\nuvc_video_encode_data(struct uvc_video *video, struct uvc_buffer *buf,\r\nu8 *data, int len)\r\n{\r\nstruct uvc_video_queue *queue = &video->queue;\r\nunsigned int nbytes;\r\nvoid *mem;\r\nmem = buf->mem + queue->buf_used;\r\nnbytes = min((unsigned int)len, buf->bytesused - queue->buf_used);\r\nmemcpy(data, mem, nbytes);\r\nqueue->buf_used += nbytes;\r\nreturn nbytes;\r\n}\r\nstatic void\r\nuvc_video_encode_bulk(struct usb_request *req, struct uvc_video *video,\r\nstruct uvc_buffer *buf)\r\n{\r\nvoid *mem = req->buf;\r\nint len = video->req_size;\r\nint ret;\r\nif (video->payload_size == 0) {\r\nret = uvc_video_encode_header(video, buf, mem, len);\r\nvideo->payload_size += ret;\r\nmem += ret;\r\nlen -= ret;\r\n}\r\nlen = min((int)(video->max_payload_size - video->payload_size), len);\r\nret = uvc_video_encode_data(video, buf, mem, len);\r\nvideo->payload_size += ret;\r\nlen -= ret;\r\nreq->length = video->req_size - len;\r\nreq->zero = video->payload_size == video->max_payload_size;\r\nif (buf->bytesused == video->queue.buf_used) {\r\nvideo->queue.buf_used = 0;\r\nbuf->state = UVC_BUF_STATE_DONE;\r\nuvc_queue_next_buffer(&video->queue, buf);\r\nvideo->fid ^= UVC_STREAM_FID;\r\nvideo->payload_size = 0;\r\n}\r\nif (video->payload_size == video->max_payload_size ||\r\nbuf->bytesused == video->queue.buf_used)\r\nvideo->payload_size = 0;\r\n}\r\nstatic void\r\nuvc_video_encode_isoc(struct usb_request *req, struct uvc_video *video,\r\nstruct uvc_buffer *buf)\r\n{\r\nvoid *mem = req->buf;\r\nint len = video->req_size;\r\nint ret;\r\nret = uvc_video_encode_header(video, buf, mem, len);\r\nmem += ret;\r\nlen -= ret;\r\nret = uvc_video_encode_data(video, buf, mem, len);\r\nlen -= ret;\r\nreq->length = video->req_size - len;\r\nif (buf->bytesused == video->queue.buf_used) {\r\nvideo->queue.buf_used = 0;\r\nbuf->state = UVC_BUF_STATE_DONE;\r\nuvc_queue_next_buffer(&video->queue, buf);\r\nvideo->fid ^= UVC_STREAM_FID;\r\n}\r\n}\r\nstatic void\r\nuvc_video_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct uvc_video *video = req->context;\r\nstruct uvc_video_queue *queue = &video->queue;\r\nstruct uvc_buffer *buf;\r\nunsigned long flags;\r\nint ret;\r\nswitch (req->status) {\r\ncase 0:\r\nbreak;\r\ncase -ESHUTDOWN:\r\nprintk(KERN_INFO "VS request cancelled.\n");\r\nuvc_queue_cancel(queue, 1);\r\ngoto requeue;\r\ndefault:\r\nprintk(KERN_INFO "VS request completed with status %d.\n",\r\nreq->status);\r\nuvc_queue_cancel(queue, 0);\r\ngoto requeue;\r\n}\r\nspin_lock_irqsave(&video->queue.irqlock, flags);\r\nbuf = uvc_queue_head(&video->queue);\r\nif (buf == NULL) {\r\nspin_unlock_irqrestore(&video->queue.irqlock, flags);\r\ngoto requeue;\r\n}\r\nvideo->encode(req, video, buf);\r\nif ((ret = usb_ep_queue(ep, req, GFP_ATOMIC)) < 0) {\r\nprintk(KERN_INFO "Failed to queue request (%d).\n", ret);\r\nusb_ep_set_halt(ep);\r\nspin_unlock_irqrestore(&video->queue.irqlock, flags);\r\ngoto requeue;\r\n}\r\nspin_unlock_irqrestore(&video->queue.irqlock, flags);\r\nreturn;\r\nrequeue:\r\nspin_lock_irqsave(&video->req_lock, flags);\r\nlist_add_tail(&req->list, &video->req_free);\r\nspin_unlock_irqrestore(&video->req_lock, flags);\r\n}\r\nstatic int\r\nuvc_video_free_requests(struct uvc_video *video)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < UVC_NUM_REQUESTS; ++i) {\r\nif (video->req[i]) {\r\nusb_ep_free_request(video->ep, video->req[i]);\r\nvideo->req[i] = NULL;\r\n}\r\nif (video->req_buffer[i]) {\r\nkfree(video->req_buffer[i]);\r\nvideo->req_buffer[i] = NULL;\r\n}\r\n}\r\nINIT_LIST_HEAD(&video->req_free);\r\nvideo->req_size = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nuvc_video_alloc_requests(struct uvc_video *video)\r\n{\r\nunsigned int req_size;\r\nunsigned int i;\r\nint ret = -ENOMEM;\r\nBUG_ON(video->req_size);\r\nreq_size = video->ep->maxpacket\r\n* max_t(unsigned int, video->ep->maxburst, 1)\r\n* (video->ep->mult + 1);\r\nfor (i = 0; i < UVC_NUM_REQUESTS; ++i) {\r\nvideo->req_buffer[i] = kmalloc(req_size, GFP_KERNEL);\r\nif (video->req_buffer[i] == NULL)\r\ngoto error;\r\nvideo->req[i] = usb_ep_alloc_request(video->ep, GFP_KERNEL);\r\nif (video->req[i] == NULL)\r\ngoto error;\r\nvideo->req[i]->buf = video->req_buffer[i];\r\nvideo->req[i]->length = 0;\r\nvideo->req[i]->complete = uvc_video_complete;\r\nvideo->req[i]->context = video;\r\nlist_add_tail(&video->req[i]->list, &video->req_free);\r\n}\r\nvideo->req_size = req_size;\r\nreturn 0;\r\nerror:\r\nuvc_video_free_requests(video);\r\nreturn ret;\r\n}\r\nstatic int\r\nuvc_video_pump(struct uvc_video *video)\r\n{\r\nstruct usb_request *req;\r\nstruct uvc_buffer *buf;\r\nunsigned long flags;\r\nint ret;\r\nwhile (1) {\r\nspin_lock_irqsave(&video->req_lock, flags);\r\nif (list_empty(&video->req_free)) {\r\nspin_unlock_irqrestore(&video->req_lock, flags);\r\nreturn 0;\r\n}\r\nreq = list_first_entry(&video->req_free, struct usb_request,\r\nlist);\r\nlist_del(&req->list);\r\nspin_unlock_irqrestore(&video->req_lock, flags);\r\nspin_lock_irqsave(&video->queue.irqlock, flags);\r\nbuf = uvc_queue_head(&video->queue);\r\nif (buf == NULL) {\r\nspin_unlock_irqrestore(&video->queue.irqlock, flags);\r\nbreak;\r\n}\r\nvideo->encode(req, video, buf);\r\nret = usb_ep_queue(video->ep, req, GFP_ATOMIC);\r\nif (ret < 0) {\r\nprintk(KERN_INFO "Failed to queue request (%d)\n", ret);\r\nusb_ep_set_halt(video->ep);\r\nspin_unlock_irqrestore(&video->queue.irqlock, flags);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&video->queue.irqlock, flags);\r\n}\r\nspin_lock_irqsave(&video->req_lock, flags);\r\nlist_add_tail(&req->list, &video->req_free);\r\nspin_unlock_irqrestore(&video->req_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nuvc_video_enable(struct uvc_video *video, int enable)\r\n{\r\nunsigned int i;\r\nint ret;\r\nif (video->ep == NULL) {\r\nprintk(KERN_INFO "Video enable failed, device is "\r\n"uninitialized.\n");\r\nreturn -ENODEV;\r\n}\r\nif (!enable) {\r\nfor (i = 0; i < UVC_NUM_REQUESTS; ++i)\r\nusb_ep_dequeue(video->ep, video->req[i]);\r\nuvc_video_free_requests(video);\r\nuvc_queue_enable(&video->queue, 0);\r\nreturn 0;\r\n}\r\nif ((ret = uvc_queue_enable(&video->queue, 1)) < 0)\r\nreturn ret;\r\nif ((ret = uvc_video_alloc_requests(video)) < 0)\r\nreturn ret;\r\nif (video->max_payload_size) {\r\nvideo->encode = uvc_video_encode_bulk;\r\nvideo->payload_size = 0;\r\n} else\r\nvideo->encode = uvc_video_encode_isoc;\r\nreturn uvc_video_pump(video);\r\n}\r\nstatic int\r\nuvc_video_init(struct uvc_video *video)\r\n{\r\nINIT_LIST_HEAD(&video->req_free);\r\nspin_lock_init(&video->req_lock);\r\nvideo->fcc = V4L2_PIX_FMT_YUYV;\r\nvideo->bpp = 16;\r\nvideo->width = 320;\r\nvideo->height = 240;\r\nvideo->imagesize = 320 * 240 * 2;\r\nuvc_queue_init(&video->queue, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nreturn 0;\r\n}
