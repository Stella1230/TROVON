static int __init parse_tag_core(const struct tag *tag)\r\n{\r\nif (tag->hdr.size > 2) {\r\nif ((tag->u.core.flags & 1) == 0)\r\nroot_mountflags &= ~MS_RDONLY;\r\nROOT_DEV = old_decode_dev(tag->u.core.rootdev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init parse_tag_mem32(const struct tag *tag)\r\n{\r\nreturn arm_add_memory(tag->u.mem.start, tag->u.mem.size);\r\n}\r\nstatic int __init parse_tag_videotext(const struct tag *tag)\r\n{\r\nscreen_info.orig_x = tag->u.videotext.x;\r\nscreen_info.orig_y = tag->u.videotext.y;\r\nscreen_info.orig_video_page = tag->u.videotext.video_page;\r\nscreen_info.orig_video_mode = tag->u.videotext.video_mode;\r\nscreen_info.orig_video_cols = tag->u.videotext.video_cols;\r\nscreen_info.orig_video_ega_bx = tag->u.videotext.video_ega_bx;\r\nscreen_info.orig_video_lines = tag->u.videotext.video_lines;\r\nscreen_info.orig_video_isVGA = tag->u.videotext.video_isvga;\r\nscreen_info.orig_video_points = tag->u.videotext.video_points;\r\nreturn 0;\r\n}\r\nstatic int __init parse_tag_ramdisk(const struct tag *tag)\r\n{\r\nextern int rd_size, rd_image_start, rd_prompt, rd_doload;\r\nrd_image_start = tag->u.ramdisk.start;\r\nrd_doload = (tag->u.ramdisk.flags & 1) == 0;\r\nrd_prompt = (tag->u.ramdisk.flags & 2) == 0;\r\nif (tag->u.ramdisk.size)\r\nrd_size = tag->u.ramdisk.size;\r\nreturn 0;\r\n}\r\nstatic int __init parse_tag_serialnr(const struct tag *tag)\r\n{\r\nsystem_serial_low = tag->u.serialnr.low;\r\nsystem_serial_high = tag->u.serialnr.high;\r\nreturn 0;\r\n}\r\nstatic int __init parse_tag_revision(const struct tag *tag)\r\n{\r\nsystem_rev = tag->u.revision.rev;\r\nreturn 0;\r\n}\r\nstatic int __init parse_tag_cmdline(const struct tag *tag)\r\n{\r\n#if defined(CONFIG_CMDLINE_EXTEND)\r\nstrlcat(default_command_line, " ", COMMAND_LINE_SIZE);\r\nstrlcat(default_command_line, tag->u.cmdline.cmdline,\r\nCOMMAND_LINE_SIZE);\r\n#elif defined(CONFIG_CMDLINE_FORCE)\r\npr_warning("Ignoring tag cmdline (using the default kernel command line)\n");\r\n#else\r\nstrlcpy(default_command_line, tag->u.cmdline.cmdline,\r\nCOMMAND_LINE_SIZE);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init parse_tag(const struct tag *tag)\r\n{\r\nextern struct tagtable __tagtable_begin, __tagtable_end;\r\nstruct tagtable *t;\r\nfor (t = &__tagtable_begin; t < &__tagtable_end; t++)\r\nif (tag->hdr.tag == t->tag) {\r\nt->parse(tag);\r\nbreak;\r\n}\r\nreturn t < &__tagtable_end;\r\n}\r\nstatic void __init parse_tags(const struct tag *t)\r\n{\r\nfor (; t->hdr.size; t = tag_next(t))\r\nif (!parse_tag(t))\r\nprintk(KERN_WARNING\r\n"Ignoring unrecognised tag 0x%08x\n",\r\nt->hdr.tag);\r\n}\r\nstatic void __init squash_mem_tags(struct tag *tag)\r\n{\r\nfor (; tag->hdr.size; tag = tag_next(tag))\r\nif (tag->hdr.tag == ATAG_MEM)\r\ntag->hdr.tag = ATAG_NONE;\r\n}\r\nconst struct machine_desc * __init\r\nsetup_machine_tags(phys_addr_t __atags_pointer, unsigned int machine_nr)\r\n{\r\nstruct tag *tags = (struct tag *)&default_tags;\r\nconst struct machine_desc *mdesc = NULL, *p;\r\nchar *from = default_command_line;\r\ndefault_tags.mem.start = PHYS_OFFSET;\r\nfor_each_machine_desc(p)\r\nif (machine_nr == p->nr) {\r\nprintk("Machine: %s\n", p->name);\r\nmdesc = p;\r\nbreak;\r\n}\r\nif (!mdesc) {\r\nearly_print("\nError: unrecognized/unsupported machine ID"\r\n" (r1 = 0x%08x).\n\n", machine_nr);\r\ndump_machine_table();\r\n}\r\nif (__atags_pointer)\r\ntags = phys_to_virt(__atags_pointer);\r\nelse if (mdesc->atag_offset)\r\ntags = (void *)(PAGE_OFFSET + mdesc->atag_offset);\r\n#if defined(CONFIG_DEPRECATED_PARAM_STRUCT)\r\nif (tags->hdr.tag != ATAG_CORE)\r\nconvert_to_tag_list(tags);\r\n#endif\r\nif (tags->hdr.tag != ATAG_CORE) {\r\nearly_print("Warning: Neither atags nor dtb found\n");\r\ntags = (struct tag *)&default_tags;\r\n}\r\nif (mdesc->fixup)\r\nmdesc->fixup(tags, &from, &meminfo);\r\nif (tags->hdr.tag == ATAG_CORE) {\r\nif (meminfo.nr_banks != 0)\r\nsquash_mem_tags(tags);\r\nsave_atags(tags);\r\nparse_tags(tags);\r\n}\r\nstrlcpy(boot_command_line, from, COMMAND_LINE_SIZE);\r\nreturn mdesc;\r\n}
