static inline int tps65010_set_vbus_draw(unsigned mA)\r\n{\r\npr_debug("tps65010: draw %d mA (STUB)\n", mA);\r\nreturn 0;\r\n}\r\nstatic void enable_vbus_draw(struct isp1301 *isp, unsigned mA)\r\n{\r\nint status = tps65010_set_vbus_draw(mA);\r\nif (status < 0)\r\npr_debug(" VBUS %d mA error %d\n", mA, status);\r\n}\r\nstatic void enable_vbus_draw(struct isp1301 *isp, unsigned mA)\r\n{\r\n}\r\nstatic void enable_vbus_source(struct isp1301 *isp)\r\n{\r\n}\r\nstatic inline void notresponding(struct isp1301 *isp)\r\n{\r\nprintk(KERN_NOTICE "OTG device not responding.\n");\r\n}\r\nstatic inline u8\r\nisp1301_get_u8(struct isp1301 *isp, u8 reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(isp->client, reg + 0);\r\n}\r\nstatic inline int\r\nisp1301_get_u16(struct isp1301 *isp, u8 reg)\r\n{\r\nreturn i2c_smbus_read_word_data(isp->client, reg);\r\n}\r\nstatic inline int\r\nisp1301_set_bits(struct isp1301 *isp, u8 reg, u8 bits)\r\n{\r\nreturn i2c_smbus_write_byte_data(isp->client, reg + 0, bits);\r\n}\r\nstatic inline int\r\nisp1301_clear_bits(struct isp1301 *isp, u8 reg, u8 bits)\r\n{\r\nreturn i2c_smbus_write_byte_data(isp->client, reg + 1, bits);\r\n}\r\nstatic inline const char *state_name(struct isp1301 *isp)\r\n{\r\nreturn usb_otg_state_string(isp->phy.state);\r\n}\r\nstatic void power_down(struct isp1301 *isp)\r\n{\r\nisp->phy.state = OTG_STATE_UNDEFINED;\r\nisp1301_set_bits(isp, ISP1301_MODE_CONTROL_1, MC1_SUSPEND);\r\nisp1301_clear_bits(isp, ISP1301_OTG_CONTROL_1, OTG1_ID_PULLDOWN);\r\nisp1301_clear_bits(isp, ISP1301_MODE_CONTROL_1, MC1_DAT_SE0);\r\n}\r\nstatic void power_up(struct isp1301 *isp)\r\n{\r\nisp1301_clear_bits(isp, ISP1301_MODE_CONTROL_1, MC1_SUSPEND);\r\nisp1301_set_bits(isp, ISP1301_MODE_CONTROL_1, MC1_DAT_SE0);\r\n}\r\nstatic int host_suspend(struct isp1301 *isp)\r\n{\r\n#ifdef NO_HOST_SUSPEND\r\nreturn 0;\r\n#else\r\nstruct device *dev;\r\nif (!isp->phy.otg->host)\r\nreturn -ENODEV;\r\ndev = isp->phy.otg->host->controller;\r\nreturn dev->driver->suspend(dev, 3, 0);\r\n#endif\r\n}\r\nstatic int host_resume(struct isp1301 *isp)\r\n{\r\n#ifdef NO_HOST_SUSPEND\r\nreturn 0;\r\n#else\r\nstruct device *dev;\r\nif (!isp->phy.otg->host)\r\nreturn -ENODEV;\r\ndev = isp->phy.otg->host->controller;\r\nreturn dev->driver->resume(dev, 0);\r\n#endif\r\n}\r\nstatic int gadget_suspend(struct isp1301 *isp)\r\n{\r\nisp->phy.otg->gadget->b_hnp_enable = 0;\r\nisp->phy.otg->gadget->a_hnp_support = 0;\r\nisp->phy.otg->gadget->a_alt_hnp_support = 0;\r\nreturn usb_gadget_vbus_disconnect(isp->phy.otg->gadget);\r\n}\r\nstatic void isp1301_defer_work(struct isp1301 *isp, int work)\r\n{\r\nint status;\r\nif (isp && !test_and_set_bit(work, &isp->todo)) {\r\n(void) get_device(&isp->client->dev);\r\nstatus = schedule_work(&isp->work);\r\nif (!status && !isp->working)\r\ndev_vdbg(&isp->client->dev,\r\n"work item %d may be lost\n", work);\r\n}\r\n}\r\nstatic void a_idle(struct isp1301 *isp, const char *tag)\r\n{\r\nu32 l;\r\nif (isp->phy.state == OTG_STATE_A_IDLE)\r\nreturn;\r\nisp->phy.otg->default_a = 1;\r\nif (isp->phy.otg->host) {\r\nisp->phy.otg->host->is_b_host = 0;\r\nhost_suspend(isp);\r\n}\r\nif (isp->phy.otg->gadget) {\r\nisp->phy.otg->gadget->is_a_peripheral = 1;\r\ngadget_suspend(isp);\r\n}\r\nisp->phy.state = OTG_STATE_A_IDLE;\r\nl = omap_readl(OTG_CTRL) & OTG_XCEIV_OUTPUTS;\r\nomap_writel(l, OTG_CTRL);\r\nisp->last_otg_ctrl = l;\r\npr_debug(" --> %s/%s\n", state_name(isp), tag);\r\n}\r\nstatic void b_idle(struct isp1301 *isp, const char *tag)\r\n{\r\nu32 l;\r\nif (isp->phy.state == OTG_STATE_B_IDLE)\r\nreturn;\r\nisp->phy.otg->default_a = 0;\r\nif (isp->phy.otg->host) {\r\nisp->phy.otg->host->is_b_host = 1;\r\nhost_suspend(isp);\r\n}\r\nif (isp->phy.otg->gadget) {\r\nisp->phy.otg->gadget->is_a_peripheral = 0;\r\ngadget_suspend(isp);\r\n}\r\nisp->phy.state = OTG_STATE_B_IDLE;\r\nl = omap_readl(OTG_CTRL) & OTG_XCEIV_OUTPUTS;\r\nomap_writel(l, OTG_CTRL);\r\nisp->last_otg_ctrl = l;\r\npr_debug(" --> %s/%s\n", state_name(isp), tag);\r\n}\r\nstatic void\r\ndump_regs(struct isp1301 *isp, const char *label)\r\n{\r\nu8 ctrl = isp1301_get_u8(isp, ISP1301_OTG_CONTROL_1);\r\nu8 status = isp1301_get_u8(isp, ISP1301_OTG_STATUS);\r\nu8 src = isp1301_get_u8(isp, ISP1301_INTERRUPT_SOURCE);\r\npr_debug("otg: %06x, %s %s, otg/%02x stat/%02x.%02x\n",\r\nomap_readl(OTG_CTRL), label, state_name(isp),\r\nctrl, status, src);\r\n}\r\nstatic void check_state(struct isp1301 *isp, const char *tag)\r\n{\r\nenum usb_otg_state state = OTG_STATE_UNDEFINED;\r\nu8 fsm = omap_readw(OTG_TEST) & 0x0ff;\r\nunsigned extra = 0;\r\nswitch (fsm) {\r\ncase 0x0:\r\nstate = OTG_STATE_B_IDLE;\r\nbreak;\r\ncase 0x3:\r\ncase 0x7:\r\nextra = 1;\r\ncase 0x1:\r\nstate = OTG_STATE_B_PERIPHERAL;\r\nbreak;\r\ncase 0x11:\r\nstate = OTG_STATE_B_SRP_INIT;\r\nbreak;\r\ncase 0x12:\r\ncase 0x13:\r\ncase 0x16:\r\nextra = 1;\r\ncase 0x17:\r\nstate = OTG_STATE_B_WAIT_ACON;\r\nbreak;\r\ncase 0x34:\r\nstate = OTG_STATE_B_HOST;\r\nbreak;\r\ncase 0x36:\r\nstate = OTG_STATE_A_IDLE;\r\nbreak;\r\ncase 0x3c:\r\nstate = OTG_STATE_A_WAIT_VFALL;\r\nbreak;\r\ncase 0x7d:\r\nstate = OTG_STATE_A_VBUS_ERR;\r\nbreak;\r\ncase 0x9e:\r\ncase 0x9f:\r\nextra = 1;\r\ncase 0x89:\r\nstate = OTG_STATE_A_PERIPHERAL;\r\nbreak;\r\ncase 0xb7:\r\nstate = OTG_STATE_A_WAIT_VRISE;\r\nbreak;\r\ncase 0xb8:\r\nstate = OTG_STATE_A_WAIT_BCON;\r\nbreak;\r\ncase 0xb9:\r\nstate = OTG_STATE_A_HOST;\r\nbreak;\r\ncase 0xba:\r\nstate = OTG_STATE_A_SUSPEND;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (isp->phy.state == state && !extra)\r\nreturn;\r\npr_debug("otg: %s FSM %s/%02x, %s, %06x\n", tag,\r\nusb_otg_state_string(state), fsm, state_name(isp),\r\nomap_readl(OTG_CTRL));\r\n}\r\nstatic inline void check_state(struct isp1301 *isp, const char *tag) { }\r\nstatic void update_otg1(struct isp1301 *isp, u8 int_src)\r\n{\r\nu32 otg_ctrl;\r\notg_ctrl = omap_readl(OTG_CTRL) & OTG_CTRL_MASK;\r\notg_ctrl &= ~OTG_XCEIV_INPUTS;\r\notg_ctrl &= ~(OTG_ID|OTG_ASESSVLD|OTG_VBUSVLD);\r\nif (int_src & INTR_SESS_VLD)\r\notg_ctrl |= OTG_ASESSVLD;\r\nelse if (isp->phy.state == OTG_STATE_A_WAIT_VFALL) {\r\na_idle(isp, "vfall");\r\notg_ctrl &= ~OTG_CTRL_BITS;\r\n}\r\nif (int_src & INTR_VBUS_VLD)\r\notg_ctrl |= OTG_VBUSVLD;\r\nif (int_src & INTR_ID_GND) {\r\nif (isp->phy.state == OTG_STATE_B_IDLE\r\n|| isp->phy.state\r\n== OTG_STATE_UNDEFINED) {\r\na_idle(isp, "init");\r\nreturn;\r\n}\r\n} else {\r\notg_ctrl |= OTG_ID;\r\nif (isp->phy.state == OTG_STATE_A_IDLE\r\n|| isp->phy.state == OTG_STATE_UNDEFINED) {\r\nb_idle(isp, "init");\r\nreturn;\r\n}\r\n}\r\nomap_writel(otg_ctrl, OTG_CTRL);\r\n}\r\nstatic void update_otg2(struct isp1301 *isp, u8 otg_status)\r\n{\r\nu32 otg_ctrl;\r\notg_ctrl = omap_readl(OTG_CTRL) & OTG_CTRL_MASK;\r\notg_ctrl &= ~OTG_XCEIV_INPUTS;\r\notg_ctrl &= ~(OTG_BSESSVLD | OTG_BSESSEND);\r\nif (otg_status & OTG_B_SESS_VLD)\r\notg_ctrl |= OTG_BSESSVLD;\r\nelse if (otg_status & OTG_B_SESS_END)\r\notg_ctrl |= OTG_BSESSEND;\r\nomap_writel(otg_ctrl, OTG_CTRL);\r\n}\r\nstatic void otg_update_isp(struct isp1301 *isp)\r\n{\r\nu32 otg_ctrl, otg_change;\r\nu8 set = OTG1_DM_PULLDOWN, clr = OTG1_DM_PULLUP;\r\notg_ctrl = omap_readl(OTG_CTRL);\r\notg_change = otg_ctrl ^ isp->last_otg_ctrl;\r\nisp->last_otg_ctrl = otg_ctrl;\r\notg_ctrl = otg_ctrl & OTG_XCEIV_INPUTS;\r\nswitch (isp->phy.state) {\r\ncase OTG_STATE_B_IDLE:\r\ncase OTG_STATE_B_PERIPHERAL:\r\ncase OTG_STATE_B_SRP_INIT:\r\nif (!(otg_ctrl & OTG_PULLUP)) {\r\nif (isp->phy.otg->gadget->b_hnp_enable) {\r\nisp->phy.state = OTG_STATE_B_WAIT_ACON;\r\npr_debug(" --> b_wait_acon\n");\r\n}\r\ngoto pulldown;\r\n}\r\npullup:\r\nset |= OTG1_DP_PULLUP;\r\nclr |= OTG1_DP_PULLDOWN;\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\ncase OTG_STATE_A_PERIPHERAL:\r\nif (otg_ctrl & OTG_PULLUP)\r\ngoto pullup;\r\ndefault:\r\npulldown:\r\nset |= OTG1_DP_PULLDOWN;\r\nclr |= OTG1_DP_PULLUP;\r\nbreak;\r\n}\r\n# define toggle(OTG,ISP) do { \\r\nif (otg_ctrl & OTG) set |= ISP; \\r\nelse clr |= ISP; \\r\n} while (0)\r\nif (!(isp->phy.otg->host))\r\notg_ctrl &= ~OTG_DRV_VBUS;\r\nswitch (isp->phy.state) {\r\ncase OTG_STATE_A_SUSPEND:\r\nif (otg_ctrl & OTG_DRV_VBUS) {\r\nset |= OTG1_VBUS_DRV;\r\nbreak;\r\n}\r\nnotresponding(isp);\r\ncase OTG_STATE_A_VBUS_ERR:\r\nisp->phy.state = OTG_STATE_A_WAIT_VFALL;\r\npr_debug(" --> a_wait_vfall\n");\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nclr |= OTG1_VBUS_DRV;\r\nbreak;\r\ncase OTG_STATE_A_IDLE:\r\nif (otg_ctrl & OTG_DRV_VBUS) {\r\nisp->phy.state = OTG_STATE_A_WAIT_VRISE;\r\npr_debug(" --> a_wait_vrise\n");\r\n}\r\ndefault:\r\ntoggle(OTG_DRV_VBUS, OTG1_VBUS_DRV);\r\n}\r\ntoggle(OTG_PU_VBUS, OTG1_VBUS_CHRG);\r\ntoggle(OTG_PD_VBUS, OTG1_VBUS_DISCHRG);\r\n# undef toggle\r\nisp1301_set_bits(isp, ISP1301_OTG_CONTROL_1, set);\r\nisp1301_clear_bits(isp, ISP1301_OTG_CONTROL_1, clr);\r\nif (otg_change & OTG_PULLUP) {\r\nu32 l;\r\nswitch (isp->phy.state) {\r\ncase OTG_STATE_B_IDLE:\r\nif (clr & OTG1_DP_PULLUP)\r\nbreak;\r\nisp->phy.state = OTG_STATE_B_PERIPHERAL;\r\npr_debug(" --> b_peripheral\n");\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\nif (clr & OTG1_DP_PULLUP)\r\nbreak;\r\nisp->phy.state = OTG_STATE_A_PERIPHERAL;\r\npr_debug(" --> a_peripheral\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nl = omap_readl(OTG_CTRL);\r\nl |= OTG_PULLUP;\r\nomap_writel(l, OTG_CTRL);\r\n}\r\ncheck_state(isp, __func__);\r\ndump_regs(isp, "otg->isp1301");\r\n}\r\nstatic irqreturn_t omap_otg_irq(int irq, void *_isp)\r\n{\r\nu16 otg_irq = omap_readw(OTG_IRQ_SRC);\r\nu32 otg_ctrl;\r\nint ret = IRQ_NONE;\r\nstruct isp1301 *isp = _isp;\r\nstruct usb_otg *otg = isp->phy.otg;\r\nif (otg_irq & OPRT_CHG) {\r\nomap_writew(OPRT_CHG, OTG_IRQ_SRC);\r\nisp1301_defer_work(isp, WORK_UPDATE_ISP);\r\nret = IRQ_HANDLED;\r\n} else if (otg_irq & B_SRP_TMROUT) {\r\npr_debug("otg: B_SRP_TIMEOUT, %06x\n", omap_readl(OTG_CTRL));\r\nnotresponding(isp);\r\nif (isp->phy.state == OTG_STATE_B_SRP_INIT)\r\nb_idle(isp, "srp_timeout");\r\nomap_writew(B_SRP_TMROUT, OTG_IRQ_SRC);\r\nret = IRQ_HANDLED;\r\n} else if (otg_irq & B_HNP_FAIL) {\r\npr_debug("otg: %s B_HNP_FAIL, %06x\n",\r\nstate_name(isp), omap_readl(OTG_CTRL));\r\nnotresponding(isp);\r\notg_ctrl = omap_readl(OTG_CTRL);\r\notg_ctrl |= OTG_BUSDROP;\r\notg_ctrl &= OTG_CTRL_MASK & ~OTG_XCEIV_INPUTS;\r\nomap_writel(otg_ctrl, OTG_CTRL);\r\nisp->phy.state = OTG_STATE_B_PERIPHERAL;\r\npr_debug(" --> b_peripheral\n");\r\nomap_writew(B_HNP_FAIL, OTG_IRQ_SRC);\r\nret = IRQ_HANDLED;\r\n} else if (otg_irq & A_SRP_DETECT) {\r\npr_debug("otg: %s SRP_DETECT, %06x\n",\r\nstate_name(isp), omap_readl(OTG_CTRL));\r\nisp1301_defer_work(isp, WORK_UPDATE_OTG);\r\nswitch (isp->phy.state) {\r\ncase OTG_STATE_A_IDLE:\r\nif (!otg->host)\r\nbreak;\r\nisp1301_defer_work(isp, WORK_HOST_RESUME);\r\notg_ctrl = omap_readl(OTG_CTRL);\r\notg_ctrl |= OTG_A_BUSREQ;\r\notg_ctrl &= ~(OTG_BUSDROP|OTG_B_BUSREQ)\r\n& ~OTG_XCEIV_INPUTS\r\n& OTG_CTRL_MASK;\r\nomap_writel(otg_ctrl, OTG_CTRL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nomap_writew(A_SRP_DETECT, OTG_IRQ_SRC);\r\nret = IRQ_HANDLED;\r\n} else if (otg_irq & A_REQ_TMROUT) {\r\notg_ctrl = omap_readl(OTG_CTRL);\r\npr_info("otg: BCON_TMOUT from %s, %06x\n",\r\nstate_name(isp), otg_ctrl);\r\nnotresponding(isp);\r\notg_ctrl |= OTG_BUSDROP;\r\notg_ctrl &= ~OTG_A_BUSREQ & OTG_CTRL_MASK & ~OTG_XCEIV_INPUTS;\r\nomap_writel(otg_ctrl, OTG_CTRL);\r\nisp->phy.state = OTG_STATE_A_WAIT_VFALL;\r\nomap_writew(A_REQ_TMROUT, OTG_IRQ_SRC);\r\nret = IRQ_HANDLED;\r\n} else if (otg_irq & A_VBUS_ERR) {\r\notg_ctrl = omap_readl(OTG_CTRL);\r\nprintk(KERN_ERR "otg: %s, VBUS_ERR %04x ctrl %06x\n",\r\nstate_name(isp), otg_irq, otg_ctrl);\r\notg_ctrl |= OTG_BUSDROP;\r\notg_ctrl &= ~OTG_A_BUSREQ & OTG_CTRL_MASK & ~OTG_XCEIV_INPUTS;\r\nomap_writel(otg_ctrl, OTG_CTRL);\r\nisp->phy.state = OTG_STATE_A_VBUS_ERR;\r\nomap_writew(A_VBUS_ERR, OTG_IRQ_SRC);\r\nret = IRQ_HANDLED;\r\n} else if (otg_irq & DRIVER_SWITCH) {\r\nint kick = 0;\r\notg_ctrl = omap_readl(OTG_CTRL);\r\nprintk(KERN_NOTICE "otg: %s, SWITCH to %s, ctrl %06x\n",\r\nstate_name(isp),\r\n(otg_ctrl & OTG_DRIVER_SEL)\r\n? "gadget" : "host",\r\notg_ctrl);\r\nisp1301_defer_work(isp, WORK_UPDATE_ISP);\r\nif (otg_ctrl & OTG_DRIVER_SEL) {\r\nswitch (isp->phy.state) {\r\ncase OTG_STATE_A_IDLE:\r\nb_idle(isp, __func__);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nisp1301_defer_work(isp, WORK_UPDATE_ISP);\r\n} else {\r\nif (!(otg_ctrl & OTG_ID)) {\r\notg_ctrl &= OTG_CTRL_MASK & ~OTG_XCEIV_INPUTS;\r\nomap_writel(otg_ctrl | OTG_A_BUSREQ, OTG_CTRL);\r\n}\r\nif (otg->host) {\r\nswitch (isp->phy.state) {\r\ncase OTG_STATE_B_WAIT_ACON:\r\nisp->phy.state = OTG_STATE_B_HOST;\r\npr_debug(" --> b_host\n");\r\nkick = 1;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_BCON:\r\nisp->phy.state = OTG_STATE_A_HOST;\r\npr_debug(" --> a_host\n");\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\nisp->phy.state = OTG_STATE_A_WAIT_BCON;\r\npr_debug(" --> a_wait_bcon\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nisp1301_defer_work(isp, WORK_HOST_RESUME);\r\n}\r\n}\r\nomap_writew(DRIVER_SWITCH, OTG_IRQ_SRC);\r\nret = IRQ_HANDLED;\r\nif (kick)\r\nusb_bus_start_enum(otg->host, otg->host->otg_port);\r\n}\r\ncheck_state(isp, __func__);\r\nreturn ret;\r\n}\r\nstatic int isp1301_otg_init(struct isp1301 *isp)\r\n{\r\nu32 l;\r\nif (!otg_dev)\r\nreturn -ENODEV;\r\ndump_regs(isp, __func__);\r\nl = omap_readl(OTG_SYSCON_2);\r\nl |= OTG_EN\r\n| SRP_GPDATA\r\n| SRP_GPDVBUS\r\n| (0 << 20)\r\n| SRP_DPW\r\n| SRP_DATA | SRP_VBUS\r\n;\r\nomap_writel(l, OTG_SYSCON_2);\r\nupdate_otg1(isp, isp1301_get_u8(isp, ISP1301_INTERRUPT_SOURCE));\r\nupdate_otg2(isp, isp1301_get_u8(isp, ISP1301_OTG_STATUS));\r\ncheck_state(isp, __func__);\r\npr_debug("otg: %s, %s %06x\n",\r\nstate_name(isp), __func__, omap_readl(OTG_CTRL));\r\nomap_writew(DRIVER_SWITCH | OPRT_CHG\r\n| B_SRP_TMROUT | B_HNP_FAIL\r\n| A_VBUS_ERR | A_SRP_DETECT | A_REQ_TMROUT, OTG_IRQ_EN);\r\nl = omap_readl(OTG_SYSCON_2);\r\nl |= OTG_EN;\r\nomap_writel(l, OTG_SYSCON_2);\r\nreturn 0;\r\n}\r\nstatic int otg_probe(struct platform_device *dev)\r\n{\r\notg_dev = dev;\r\nreturn 0;\r\n}\r\nstatic int otg_remove(struct platform_device *dev)\r\n{\r\notg_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int otg_bind(struct isp1301 *isp)\r\n{\r\nint status;\r\nif (otg_dev)\r\nreturn -EBUSY;\r\nstatus = platform_driver_register(&omap_otg_driver);\r\nif (status < 0)\r\nreturn status;\r\nif (otg_dev)\r\nstatus = request_irq(otg_dev->resource[1].start, omap_otg_irq,\r\n0, DRIVER_NAME, isp);\r\nelse\r\nstatus = -ENODEV;\r\nif (status < 0)\r\nplatform_driver_unregister(&omap_otg_driver);\r\nreturn status;\r\n}\r\nstatic void otg_unbind(struct isp1301 *isp)\r\n{\r\nif (!otg_dev)\r\nreturn;\r\nfree_irq(otg_dev->resource[1].start, isp);\r\n}\r\nstatic void b_peripheral(struct isp1301 *isp)\r\n{\r\nu32 l;\r\nl = omap_readl(OTG_CTRL) & OTG_XCEIV_OUTPUTS;\r\nomap_writel(l, OTG_CTRL);\r\nusb_gadget_vbus_connect(isp->phy.otg->gadget);\r\n#ifdef CONFIG_USB_OTG\r\nenable_vbus_draw(isp, 8);\r\notg_update_isp(isp);\r\n#else\r\nenable_vbus_draw(isp, 100);\r\nisp1301_set_bits(isp, ISP1301_OTG_CONTROL_1, OTG1_DP_PULLUP);\r\nisp1301_clear_bits(isp, ISP1301_OTG_CONTROL_1, OTG1_DP_PULLDOWN);\r\nisp->phy.state = OTG_STATE_B_PERIPHERAL;\r\npr_debug(" --> b_peripheral\n");\r\ndump_regs(isp, "2periph");\r\n#endif\r\n}\r\nstatic void isp_update_otg(struct isp1301 *isp, u8 stat)\r\n{\r\nstruct usb_otg *otg = isp->phy.otg;\r\nu8 isp_stat, isp_bstat;\r\nenum usb_otg_state state = isp->phy.state;\r\nif (stat & INTR_BDIS_ACON)\r\npr_debug("OTG: BDIS_ACON, %s\n", state_name(isp));\r\nisp_stat = isp1301_get_u8(isp, ISP1301_INTERRUPT_SOURCE);\r\nif (isp_stat & INTR_ID_GND) {\r\nif (otg->default_a) {\r\nswitch (state) {\r\ncase OTG_STATE_B_IDLE:\r\na_idle(isp, "idle");\r\ncase OTG_STATE_A_IDLE:\r\nenable_vbus_source(isp);\r\ncase OTG_STATE_A_WAIT_VRISE:\r\nif (isp_stat & INTR_VBUS_VLD)\r\nisp->phy.state = OTG_STATE_A_HOST;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nif (!(isp_stat & INTR_SESS_VLD))\r\na_idle(isp, "vfell");\r\nbreak;\r\ndefault:\r\nif (!(isp_stat & INTR_VBUS_VLD))\r\nisp->phy.state = OTG_STATE_A_VBUS_ERR;\r\nbreak;\r\n}\r\nisp_bstat = isp1301_get_u8(isp, ISP1301_OTG_STATUS);\r\n} else {\r\nswitch (state) {\r\ncase OTG_STATE_B_PERIPHERAL:\r\ncase OTG_STATE_B_HOST:\r\ncase OTG_STATE_B_WAIT_ACON:\r\nusb_gadget_vbus_disconnect(otg->gadget);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (state != OTG_STATE_A_IDLE)\r\na_idle(isp, "id");\r\nif (otg->host && state == OTG_STATE_A_IDLE)\r\nisp1301_defer_work(isp, WORK_HOST_RESUME);\r\nisp_bstat = 0;\r\n}\r\n} else {\r\nu32 l;\r\nif (otg->default_a) {\r\nswitch (state) {\r\ndefault:\r\nisp->phy.state = OTG_STATE_A_WAIT_VFALL;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nstate = OTG_STATE_A_IDLE;\r\nbreak;\r\ncase OTG_STATE_A_IDLE:\r\nhost_suspend(isp);\r\nisp1301_clear_bits(isp, ISP1301_MODE_CONTROL_1,\r\nMC1_BDIS_ACON_EN);\r\nisp->phy.state = OTG_STATE_B_IDLE;\r\nl = omap_readl(OTG_CTRL) & OTG_CTRL_MASK;\r\nl &= ~OTG_CTRL_BITS;\r\nomap_writel(l, OTG_CTRL);\r\nbreak;\r\ncase OTG_STATE_B_IDLE:\r\nbreak;\r\n}\r\n}\r\nisp_bstat = isp1301_get_u8(isp, ISP1301_OTG_STATUS);\r\nswitch (isp->phy.state) {\r\ncase OTG_STATE_B_PERIPHERAL:\r\ncase OTG_STATE_B_WAIT_ACON:\r\ncase OTG_STATE_B_HOST:\r\nif (likely(isp_bstat & OTG_B_SESS_VLD))\r\nbreak;\r\nenable_vbus_draw(isp, 0);\r\n#ifndef CONFIG_USB_OTG\r\nisp1301_set_bits(isp, ISP1301_OTG_CONTROL_1,\r\nOTG1_DP_PULLDOWN);\r\nisp1301_clear_bits(isp, ISP1301_OTG_CONTROL_1,\r\nOTG1_DP_PULLUP);\r\ndump_regs(isp, __func__);\r\n#endif\r\ncase OTG_STATE_B_SRP_INIT:\r\nb_idle(isp, __func__);\r\nl = omap_readl(OTG_CTRL) & OTG_XCEIV_OUTPUTS;\r\nomap_writel(l, OTG_CTRL);\r\ncase OTG_STATE_B_IDLE:\r\nif (otg->gadget && (isp_bstat & OTG_B_SESS_VLD)) {\r\n#ifdef CONFIG_USB_OTG\r\nupdate_otg1(isp, isp_stat);\r\nupdate_otg2(isp, isp_bstat);\r\n#endif\r\nb_peripheral(isp);\r\n} else if (!(isp_stat & (INTR_VBUS_VLD|INTR_SESS_VLD)))\r\nisp_bstat |= OTG_B_SESS_END;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nbreak;\r\ndefault:\r\npr_debug("otg: unsupported b-device %s\n",\r\nstate_name(isp));\r\nbreak;\r\n}\r\n}\r\nif (state != isp->phy.state)\r\npr_debug(" isp, %s -> %s\n",\r\nusb_otg_state_string(state), state_name(isp));\r\n#ifdef CONFIG_USB_OTG\r\nupdate_otg1(isp, isp_stat);\r\nupdate_otg2(isp, isp_bstat);\r\ncheck_state(isp, __func__);\r\n#endif\r\ndump_regs(isp, "isp1301->otg");\r\n}\r\nstatic u8 isp1301_clear_latch(struct isp1301 *isp)\r\n{\r\nu8 latch = isp1301_get_u8(isp, ISP1301_INTERRUPT_LATCH);\r\nisp1301_clear_bits(isp, ISP1301_INTERRUPT_LATCH, latch);\r\nreturn latch;\r\n}\r\nstatic void\r\nisp1301_work(struct work_struct *work)\r\n{\r\nstruct isp1301 *isp = container_of(work, struct isp1301, work);\r\nint stop;\r\nisp->working = 1;\r\ndo {\r\nstop = test_bit(WORK_STOP, &isp->todo);\r\n#ifdef CONFIG_USB_OTG\r\nif (test_and_clear_bit(WORK_UPDATE_ISP, &isp->todo)) {\r\notg_update_isp(isp);\r\nput_device(&isp->client->dev);\r\n}\r\n#endif\r\nif (test_and_clear_bit(WORK_UPDATE_OTG, &isp->todo)) {\r\nu8 stat = isp1301_clear_latch(isp);\r\nisp_update_otg(isp, stat);\r\nput_device(&isp->client->dev);\r\n}\r\nif (test_and_clear_bit(WORK_HOST_RESUME, &isp->todo)) {\r\nu32 otg_ctrl;\r\nswitch (isp->phy.state) {\r\ncase OTG_STATE_A_WAIT_BCON:\r\ncase OTG_STATE_A_WAIT_VRISE:\r\nisp->phy.state = OTG_STATE_A_HOST;\r\npr_debug(" --> a_host\n");\r\notg_ctrl = omap_readl(OTG_CTRL);\r\notg_ctrl |= OTG_A_BUSREQ;\r\notg_ctrl &= ~(OTG_BUSDROP|OTG_B_BUSREQ)\r\n& OTG_CTRL_MASK;\r\nomap_writel(otg_ctrl, OTG_CTRL);\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\nisp->phy.state = OTG_STATE_B_HOST;\r\npr_debug(" --> b_host (acon)\n");\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\ncase OTG_STATE_B_IDLE:\r\ncase OTG_STATE_A_IDLE:\r\nbreak;\r\ndefault:\r\npr_debug(" host resume in %s\n",\r\nstate_name(isp));\r\n}\r\nhost_resume(isp);\r\nput_device(&isp->client->dev);\r\n}\r\nif (test_and_clear_bit(WORK_TIMER, &isp->todo)) {\r\n#ifdef VERBOSE\r\ndump_regs(isp, "timer");\r\nif (!stop)\r\nmod_timer(&isp->timer, jiffies + TIMER_JIFFIES);\r\n#endif\r\nput_device(&isp->client->dev);\r\n}\r\nif (isp->todo)\r\ndev_vdbg(&isp->client->dev,\r\n"work done, todo = 0x%lx\n",\r\nisp->todo);\r\nif (stop) {\r\ndev_dbg(&isp->client->dev, "stop\n");\r\nbreak;\r\n}\r\n} while (isp->todo);\r\nisp->working = 0;\r\n}\r\nstatic irqreturn_t isp1301_irq(int irq, void *isp)\r\n{\r\nisp1301_defer_work(isp, WORK_UPDATE_OTG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void isp1301_timer(unsigned long _isp)\r\n{\r\nisp1301_defer_work((void *)_isp, WORK_TIMER);\r\n}\r\nstatic void isp1301_release(struct device *dev)\r\n{\r\nstruct isp1301 *isp;\r\nisp = dev_get_drvdata(dev);\r\nif (isp->i2c_release)\r\nisp->i2c_release(dev);\r\nkfree(isp->phy.otg);\r\nkfree (isp);\r\n}\r\nstatic int isp1301_remove(struct i2c_client *i2c)\r\n{\r\nstruct isp1301 *isp;\r\nisp = i2c_get_clientdata(i2c);\r\nisp1301_clear_bits(isp, ISP1301_INTERRUPT_FALLING, ~0);\r\nisp1301_clear_bits(isp, ISP1301_INTERRUPT_RISING, ~0);\r\nfree_irq(i2c->irq, isp);\r\n#ifdef CONFIG_USB_OTG\r\notg_unbind(isp);\r\n#endif\r\nif (machine_is_omap_h2())\r\ngpio_free(2);\r\nisp->timer.data = 0;\r\nset_bit(WORK_STOP, &isp->todo);\r\ndel_timer_sync(&isp->timer);\r\nflush_work(&isp->work);\r\nput_device(&i2c->dev);\r\nthe_transceiver = NULL;\r\nreturn 0;\r\n}\r\nstatic int isp1301_otg_enable(struct isp1301 *isp)\r\n{\r\npower_up(isp);\r\nisp1301_otg_init(isp);\r\nisp1301_set_bits(isp, ISP1301_INTERRUPT_RISING,\r\nINTR_VBUS_VLD | INTR_SESS_VLD | INTR_ID_GND);\r\nisp1301_set_bits(isp, ISP1301_INTERRUPT_FALLING,\r\nINTR_VBUS_VLD | INTR_SESS_VLD | INTR_ID_GND);\r\ndev_info(&isp->client->dev, "ready for dual-role USB ...\n");\r\nreturn 0;\r\n}\r\nstatic int\r\nisp1301_set_host(struct usb_otg *otg, struct usb_bus *host)\r\n{\r\nstruct isp1301 *isp = container_of(otg->phy, struct isp1301, phy);\r\nif (isp != the_transceiver)\r\nreturn -ENODEV;\r\nif (!host) {\r\nomap_writew(0, OTG_IRQ_EN);\r\npower_down(isp);\r\notg->host = NULL;\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_USB_OTG\r\notg->host = host;\r\ndev_dbg(&isp->client->dev, "registered host\n");\r\nhost_suspend(isp);\r\nif (otg->gadget)\r\nreturn isp1301_otg_enable(isp);\r\nreturn 0;\r\n#elif !defined(CONFIG_USB_GADGET_OMAP)\r\notg->host = host;\r\npower_up(isp);\r\nif (machine_is_omap_h2())\r\nisp1301_set_bits(isp, ISP1301_MODE_CONTROL_1, MC1_DAT_SE0);\r\ndev_info(&isp->client->dev, "A-Host sessions ok\n");\r\nisp1301_set_bits(isp, ISP1301_INTERRUPT_RISING,\r\nINTR_ID_GND);\r\nisp1301_set_bits(isp, ISP1301_INTERRUPT_FALLING,\r\nINTR_ID_GND);\r\nisp1301_set_bits(isp, ISP1301_OTG_CONTROL_1, OTG1_VBUS_DRV);\r\ndump_regs(isp, __func__);\r\nreturn 0;\r\n#else\r\ndev_dbg(&isp->client->dev, "host sessions not allowed\n");\r\nreturn -EINVAL;\r\n#endif\r\n}\r\nstatic int\r\nisp1301_set_peripheral(struct usb_otg *otg, struct usb_gadget *gadget)\r\n{\r\nstruct isp1301 *isp = container_of(otg->phy, struct isp1301, phy);\r\nif (isp != the_transceiver)\r\nreturn -ENODEV;\r\nif (!gadget) {\r\nomap_writew(0, OTG_IRQ_EN);\r\nif (!otg->default_a)\r\nenable_vbus_draw(isp, 0);\r\nusb_gadget_vbus_disconnect(otg->gadget);\r\notg->gadget = NULL;\r\npower_down(isp);\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_USB_OTG\r\notg->gadget = gadget;\r\ndev_dbg(&isp->client->dev, "registered gadget\n");\r\nif (otg->host)\r\nreturn isp1301_otg_enable(isp);\r\nreturn 0;\r\n#elif !defined(CONFIG_USB_OHCI_HCD) && !defined(CONFIG_USB_OHCI_HCD_MODULE)\r\notg->gadget = gadget;\r\n{\r\nu32 l;\r\nl = omap_readl(OTG_CTRL) & OTG_CTRL_MASK;\r\nl &= ~(OTG_XCEIV_OUTPUTS|OTG_CTRL_BITS);\r\nl |= OTG_ID;\r\nomap_writel(l, OTG_CTRL);\r\n}\r\npower_up(isp);\r\nisp->phy.state = OTG_STATE_B_IDLE;\r\nif (machine_is_omap_h2() || machine_is_omap_h3())\r\nisp1301_set_bits(isp, ISP1301_MODE_CONTROL_1, MC1_DAT_SE0);\r\nisp1301_set_bits(isp, ISP1301_INTERRUPT_RISING,\r\nINTR_SESS_VLD);\r\nisp1301_set_bits(isp, ISP1301_INTERRUPT_FALLING,\r\nINTR_VBUS_VLD);\r\ndev_info(&isp->client->dev, "B-Peripheral sessions ok\n");\r\ndump_regs(isp, __func__);\r\nif (isp1301_get_u8(isp, ISP1301_INTERRUPT_SOURCE) & INTR_VBUS_VLD)\r\nb_peripheral(isp);\r\nreturn 0;\r\n#else\r\ndev_dbg(&isp->client->dev, "peripheral sessions not allowed\n");\r\nreturn -EINVAL;\r\n#endif\r\n}\r\nstatic int\r\nisp1301_set_power(struct usb_phy *dev, unsigned mA)\r\n{\r\nif (!the_transceiver)\r\nreturn -ENODEV;\r\nif (dev->state == OTG_STATE_B_PERIPHERAL)\r\nenable_vbus_draw(the_transceiver, mA);\r\nreturn 0;\r\n}\r\nstatic int\r\nisp1301_start_srp(struct usb_otg *otg)\r\n{\r\nstruct isp1301 *isp = container_of(otg->phy, struct isp1301, phy);\r\nu32 otg_ctrl;\r\nif (isp != the_transceiver || isp->phy.state != OTG_STATE_B_IDLE)\r\nreturn -ENODEV;\r\notg_ctrl = omap_readl(OTG_CTRL);\r\nif (!(otg_ctrl & OTG_BSESSEND))\r\nreturn -EINVAL;\r\notg_ctrl |= OTG_B_BUSREQ;\r\notg_ctrl &= ~OTG_A_BUSREQ & OTG_CTRL_MASK;\r\nomap_writel(otg_ctrl, OTG_CTRL);\r\nisp->phy.state = OTG_STATE_B_SRP_INIT;\r\npr_debug("otg: SRP, %s ... %06x\n", state_name(isp),\r\nomap_readl(OTG_CTRL));\r\n#ifdef CONFIG_USB_OTG\r\ncheck_state(isp, __func__);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\nisp1301_start_hnp(struct usb_otg *otg)\r\n{\r\n#ifdef CONFIG_USB_OTG\r\nstruct isp1301 *isp = container_of(otg->phy, struct isp1301, phy);\r\nu32 l;\r\nif (isp != the_transceiver)\r\nreturn -ENODEV;\r\nif (otg->default_a && (otg->host == NULL || !otg->host->b_hnp_enable))\r\nreturn -ENOTCONN;\r\nif (!otg->default_a && (otg->gadget == NULL\r\n|| !otg->gadget->b_hnp_enable))\r\nreturn -ENOTCONN;\r\nswitch (isp->phy.state) {\r\ncase OTG_STATE_B_HOST:\r\nisp->phy.state = OTG_STATE_B_PERIPHERAL;\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\n#if 0\r\nisp1301_set_bits(isp, ISP1301_MODE_CONTROL_1,\r\nMC1_BDIS_ACON_EN);\r\n#endif\r\nusb_gadget_vbus_connect(otg->gadget);\r\nl = omap_readl(OTG_CTRL);\r\nl |= OTG_A_SETB_HNPEN;\r\nomap_writel(l, OTG_CTRL);\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\nbreak;\r\ndefault:\r\nreturn -EILSEQ;\r\n}\r\npr_debug("otg: HNP %s, %06x ...\n",\r\nstate_name(isp), omap_readl(OTG_CTRL));\r\ncheck_state(isp, __func__);\r\nreturn 0;\r\n#else\r\nreturn -EINVAL;\r\n#endif\r\n}\r\nstatic int\r\nisp1301_probe(struct i2c_client *i2c, const struct i2c_device_id *id)\r\n{\r\nint status;\r\nstruct isp1301 *isp;\r\nif (the_transceiver)\r\nreturn 0;\r\nisp = kzalloc(sizeof *isp, GFP_KERNEL);\r\nif (!isp)\r\nreturn 0;\r\nisp->phy.otg = kzalloc(sizeof *isp->phy.otg, GFP_KERNEL);\r\nif (!isp->phy.otg) {\r\nkfree(isp);\r\nreturn 0;\r\n}\r\nINIT_WORK(&isp->work, isp1301_work);\r\ninit_timer(&isp->timer);\r\nisp->timer.function = isp1301_timer;\r\nisp->timer.data = (unsigned long) isp;\r\ni2c_set_clientdata(i2c, isp);\r\nisp->client = i2c;\r\nstatus = isp1301_get_u16(isp, ISP1301_VENDOR_ID);\r\nif (status != I2C_VENDOR_ID_PHILIPS) {\r\ndev_dbg(&i2c->dev, "not philips id: %d\n", status);\r\ngoto fail;\r\n}\r\nstatus = isp1301_get_u16(isp, ISP1301_PRODUCT_ID);\r\nif (status != I2C_PRODUCT_ID_PHILIPS_1301) {\r\ndev_dbg(&i2c->dev, "not isp1301, %d\n", status);\r\ngoto fail;\r\n}\r\nisp->i2c_release = i2c->dev.release;\r\ni2c->dev.release = isp1301_release;\r\nstatus = i2c_smbus_read_word_data(i2c, ISP1301_BCD_DEVICE);\r\ndev_info(&i2c->dev, "chiprev %x.%02x, driver " DRIVER_VERSION "\n",\r\nstatus >> 8, status & 0xff);\r\nisp1301_clear_bits(isp, ISP1301_MODE_CONTROL_1, MC1_MASK);\r\nisp1301_set_bits(isp, ISP1301_MODE_CONTROL_2, MC2_BI_DI);\r\nisp1301_clear_bits(isp, ISP1301_MODE_CONTROL_2, ~MC2_BI_DI);\r\nisp1301_set_bits(isp, ISP1301_OTG_CONTROL_1,\r\nOTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN);\r\nisp1301_clear_bits(isp, ISP1301_OTG_CONTROL_1,\r\n~(OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN));\r\nisp1301_clear_bits(isp, ISP1301_INTERRUPT_LATCH, ~0);\r\nisp1301_clear_bits(isp, ISP1301_INTERRUPT_FALLING, ~0);\r\nisp1301_clear_bits(isp, ISP1301_INTERRUPT_RISING, ~0);\r\n#ifdef CONFIG_USB_OTG\r\nstatus = otg_bind(isp);\r\nif (status < 0) {\r\ndev_dbg(&i2c->dev, "can't bind OTG\n");\r\ngoto fail;\r\n}\r\n#endif\r\nif (machine_is_omap_h2()) {\r\nisp1301_set_bits(isp, ISP1301_MODE_CONTROL_1,\r\nMC1_SPEED);\r\nisp1301_set_bits(isp, ISP1301_MODE_CONTROL_2,\r\nMC2_SPD_SUSP_CTRL);\r\nomap_cfg_reg(M14_1510_GPIO2);\r\nif (gpio_request(2, "isp1301") == 0)\r\ngpio_direction_input(2);\r\nisp->irq_type = IRQF_TRIGGER_FALLING;\r\n}\r\nstatus = request_irq(i2c->irq, isp1301_irq,\r\nisp->irq_type, DRIVER_NAME, isp);\r\nif (status < 0) {\r\ndev_dbg(&i2c->dev, "can't get IRQ %d, err %d\n",\r\ni2c->irq, status);\r\ngoto fail;\r\n}\r\nisp->phy.dev = &i2c->dev;\r\nisp->phy.label = DRIVER_NAME;\r\nisp->phy.set_power = isp1301_set_power,\r\nisp->phy.otg->phy = &isp->phy;\r\nisp->phy.otg->set_host = isp1301_set_host,\r\nisp->phy.otg->set_peripheral = isp1301_set_peripheral,\r\nisp->phy.otg->start_srp = isp1301_start_srp,\r\nisp->phy.otg->start_hnp = isp1301_start_hnp,\r\nenable_vbus_draw(isp, 0);\r\npower_down(isp);\r\nthe_transceiver = isp;\r\n#ifdef CONFIG_USB_OTG\r\nupdate_otg1(isp, isp1301_get_u8(isp, ISP1301_INTERRUPT_SOURCE));\r\nupdate_otg2(isp, isp1301_get_u8(isp, ISP1301_OTG_STATUS));\r\n#endif\r\ndump_regs(isp, __func__);\r\n#ifdef VERBOSE\r\nmod_timer(&isp->timer, jiffies + TIMER_JIFFIES);\r\ndev_dbg(&i2c->dev, "scheduled timer, %d min\n", TIMER_MINUTES);\r\n#endif\r\nstatus = usb_add_phy(&isp->phy, USB_PHY_TYPE_USB2);\r\nif (status < 0)\r\ndev_err(&i2c->dev, "can't register transceiver, %d\n",\r\nstatus);\r\nreturn 0;\r\nfail:\r\nkfree(isp->phy.otg);\r\nkfree(isp);\r\nreturn -ENODEV;\r\n}\r\nstatic int __init isp_init(void)\r\n{\r\nreturn i2c_add_driver(&isp1301_driver);\r\n}\r\nstatic void __exit isp_exit(void)\r\n{\r\nif (the_transceiver)\r\nusb_remove_phy(&the_transceiver->phy);\r\ni2c_del_driver(&isp1301_driver);\r\n}
