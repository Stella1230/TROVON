static int __drm_class_suspend(struct device *dev, pm_message_t state)\r\n{\r\nif (dev->type == &drm_sysfs_device_minor) {\r\nstruct drm_minor *drm_minor = to_drm_minor(dev);\r\nstruct drm_device *drm_dev = drm_minor->dev;\r\nif (drm_minor->type == DRM_MINOR_LEGACY &&\r\n!drm_core_check_feature(drm_dev, DRIVER_MODESET) &&\r\ndrm_dev->driver->suspend)\r\nreturn drm_dev->driver->suspend(drm_dev, state);\r\n}\r\nreturn 0;\r\n}\r\nstatic int drm_class_suspend(struct device *dev)\r\n{\r\nreturn __drm_class_suspend(dev, PMSG_SUSPEND);\r\n}\r\nstatic int drm_class_freeze(struct device *dev)\r\n{\r\nreturn __drm_class_suspend(dev, PMSG_FREEZE);\r\n}\r\nstatic int drm_class_resume(struct device *dev)\r\n{\r\nif (dev->type == &drm_sysfs_device_minor) {\r\nstruct drm_minor *drm_minor = to_drm_minor(dev);\r\nstruct drm_device *drm_dev = drm_minor->dev;\r\nif (drm_minor->type == DRM_MINOR_LEGACY &&\r\n!drm_core_check_feature(drm_dev, DRIVER_MODESET) &&\r\ndrm_dev->driver->resume)\r\nreturn drm_dev->driver->resume(drm_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic char *drm_devnode(struct device *dev, umode_t *mode)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "dri/%s", dev_name(dev));\r\n}\r\nstruct class *drm_sysfs_create(struct module *owner, char *name)\r\n{\r\nstruct class *class;\r\nint err;\r\nclass = class_create(owner, name);\r\nif (IS_ERR(class)) {\r\nerr = PTR_ERR(class);\r\ngoto err_out;\r\n}\r\nclass->pm = &drm_class_dev_pm_ops;\r\nerr = class_create_file(class, &class_attr_version.attr);\r\nif (err)\r\ngoto err_out_class;\r\nclass->devnode = drm_devnode;\r\nreturn class;\r\nerr_out_class:\r\nclass_destroy(class);\r\nerr_out:\r\nreturn ERR_PTR(err);\r\n}\r\nvoid drm_sysfs_destroy(void)\r\n{\r\nif ((drm_class == NULL) || (IS_ERR(drm_class)))\r\nreturn;\r\nclass_remove_file(drm_class, &class_attr_version.attr);\r\nclass_destroy(drm_class);\r\ndrm_class = NULL;\r\n}\r\nstatic ssize_t status_show(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_connector *connector = to_drm_connector(device);\r\nenum drm_connector_status status;\r\nint ret;\r\nret = mutex_lock_interruptible(&connector->dev->mode_config.mutex);\r\nif (ret)\r\nreturn ret;\r\nstatus = connector->funcs->detect(connector, true);\r\nmutex_unlock(&connector->dev->mode_config.mutex);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\ndrm_get_connector_status_name(status));\r\n}\r\nstatic ssize_t dpms_show(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_connector *connector = to_drm_connector(device);\r\nstruct drm_device *dev = connector->dev;\r\nuint64_t dpms_status;\r\nint ret;\r\nret = drm_object_property_get_value(&connector->base,\r\ndev->mode_config.dpms_property,\r\n&dpms_status);\r\nif (ret)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\ndrm_get_dpms_name((int)dpms_status));\r\n}\r\nstatic ssize_t enabled_show(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_connector *connector = to_drm_connector(device);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", connector->encoder ? "enabled" :\r\n"disabled");\r\n}\r\nstatic ssize_t edid_show(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nstruct device *connector_dev = container_of(kobj, struct device, kobj);\r\nstruct drm_connector *connector = to_drm_connector(connector_dev);\r\nunsigned char *edid;\r\nsize_t size;\r\nif (!connector->edid_blob_ptr)\r\nreturn 0;\r\nedid = connector->edid_blob_ptr->data;\r\nsize = connector->edid_blob_ptr->length;\r\nif (!edid)\r\nreturn 0;\r\nif (off >= size)\r\nreturn 0;\r\nif (off + count > size)\r\ncount = size - off;\r\nmemcpy(buf, edid + off, count);\r\nreturn count;\r\n}\r\nstatic ssize_t modes_show(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_connector *connector = to_drm_connector(device);\r\nstruct drm_display_mode *mode;\r\nint written = 0;\r\nlist_for_each_entry(mode, &connector->modes, head) {\r\nwritten += snprintf(buf + written, PAGE_SIZE - written, "%s\n",\r\nmode->name);\r\n}\r\nreturn written;\r\n}\r\nstatic ssize_t subconnector_show(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_connector *connector = to_drm_connector(device);\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_property *prop = NULL;\r\nuint64_t subconnector;\r\nint is_tv = 0;\r\nint ret;\r\nswitch (connector->connector_type) {\r\ncase DRM_MODE_CONNECTOR_DVII:\r\nprop = dev->mode_config.dvi_i_subconnector_property;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_Composite:\r\ncase DRM_MODE_CONNECTOR_SVIDEO:\r\ncase DRM_MODE_CONNECTOR_Component:\r\ncase DRM_MODE_CONNECTOR_TV:\r\nprop = dev->mode_config.tv_subconnector_property;\r\nis_tv = 1;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Wrong connector type for this property\n");\r\nreturn 0;\r\n}\r\nif (!prop) {\r\nDRM_ERROR("Unable to find subconnector property\n");\r\nreturn 0;\r\n}\r\nret = drm_object_property_get_value(&connector->base, prop, &subconnector);\r\nif (ret)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%s", is_tv ?\r\ndrm_get_tv_subconnector_name((int)subconnector) :\r\ndrm_get_dvi_i_subconnector_name((int)subconnector));\r\n}\r\nstatic ssize_t select_subconnector_show(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_connector *connector = to_drm_connector(device);\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_property *prop = NULL;\r\nuint64_t subconnector;\r\nint is_tv = 0;\r\nint ret;\r\nswitch (connector->connector_type) {\r\ncase DRM_MODE_CONNECTOR_DVII:\r\nprop = dev->mode_config.dvi_i_select_subconnector_property;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_Composite:\r\ncase DRM_MODE_CONNECTOR_SVIDEO:\r\ncase DRM_MODE_CONNECTOR_Component:\r\ncase DRM_MODE_CONNECTOR_TV:\r\nprop = dev->mode_config.tv_select_subconnector_property;\r\nis_tv = 1;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Wrong connector type for this property\n");\r\nreturn 0;\r\n}\r\nif (!prop) {\r\nDRM_ERROR("Unable to find select subconnector property\n");\r\nreturn 0;\r\n}\r\nret = drm_object_property_get_value(&connector->base, prop, &subconnector);\r\nif (ret)\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%s", is_tv ?\r\ndrm_get_tv_select_name((int)subconnector) :\r\ndrm_get_dvi_i_select_name((int)subconnector));\r\n}\r\nint drm_sysfs_connector_add(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nint attr_cnt = 0;\r\nint opt_cnt = 0;\r\nint i;\r\nint ret;\r\nif (connector->kdev)\r\nreturn 0;\r\nconnector->kdev = device_create(drm_class, dev->primary->kdev,\r\n0, connector, "card%d-%s",\r\ndev->primary->index, drm_get_connector_name(connector));\r\nDRM_DEBUG("adding \"%s\" to sysfs\n",\r\ndrm_get_connector_name(connector));\r\nif (IS_ERR(connector->kdev)) {\r\nDRM_ERROR("failed to register connector device: %ld\n", PTR_ERR(connector->kdev));\r\nret = PTR_ERR(connector->kdev);\r\ngoto out;\r\n}\r\nfor (attr_cnt = 0; attr_cnt < ARRAY_SIZE(connector_attrs); attr_cnt++) {\r\nret = device_create_file(connector->kdev, &connector_attrs[attr_cnt]);\r\nif (ret)\r\ngoto err_out_files;\r\n}\r\nswitch (connector->connector_type) {\r\ncase DRM_MODE_CONNECTOR_DVII:\r\ncase DRM_MODE_CONNECTOR_Composite:\r\ncase DRM_MODE_CONNECTOR_SVIDEO:\r\ncase DRM_MODE_CONNECTOR_Component:\r\ncase DRM_MODE_CONNECTOR_TV:\r\nfor (opt_cnt = 0; opt_cnt < ARRAY_SIZE(connector_attrs_opt1); opt_cnt++) {\r\nret = device_create_file(connector->kdev, &connector_attrs_opt1[opt_cnt]);\r\nif (ret)\r\ngoto err_out_files;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret = sysfs_create_bin_file(&connector->kdev->kobj, &edid_attr);\r\nif (ret)\r\ngoto err_out_files;\r\ndrm_sysfs_hotplug_event(dev);\r\nreturn 0;\r\nerr_out_files:\r\nfor (i = 0; i < opt_cnt; i++)\r\ndevice_remove_file(connector->kdev, &connector_attrs_opt1[i]);\r\nfor (i = 0; i < attr_cnt; i++)\r\ndevice_remove_file(connector->kdev, &connector_attrs[i]);\r\ndevice_unregister(connector->kdev);\r\nout:\r\nreturn ret;\r\n}\r\nvoid drm_sysfs_connector_remove(struct drm_connector *connector)\r\n{\r\nint i;\r\nif (!connector->kdev)\r\nreturn;\r\nDRM_DEBUG("removing \"%s\" from sysfs\n",\r\ndrm_get_connector_name(connector));\r\nfor (i = 0; i < ARRAY_SIZE(connector_attrs); i++)\r\ndevice_remove_file(connector->kdev, &connector_attrs[i]);\r\nsysfs_remove_bin_file(&connector->kdev->kobj, &edid_attr);\r\ndevice_unregister(connector->kdev);\r\nconnector->kdev = NULL;\r\n}\r\nvoid drm_sysfs_hotplug_event(struct drm_device *dev)\r\n{\r\nchar *event_string = "HOTPLUG=1";\r\nchar *envp[] = { event_string, NULL };\r\nDRM_DEBUG("generating hotplug event\n");\r\nkobject_uevent_env(&dev->primary->kdev->kobj, KOBJ_CHANGE, envp);\r\n}\r\nstatic void drm_sysfs_release(struct device *dev)\r\n{\r\nkfree(dev);\r\n}\r\nint drm_sysfs_device_add(struct drm_minor *minor)\r\n{\r\nchar *minor_str;\r\nint r;\r\nif (minor->type == DRM_MINOR_CONTROL)\r\nminor_str = "controlD%d";\r\nelse if (minor->type == DRM_MINOR_RENDER)\r\nminor_str = "renderD%d";\r\nelse\r\nminor_str = "card%d";\r\nminor->kdev = kzalloc(sizeof(*minor->kdev), GFP_KERNEL);\r\nif (!minor->kdev) {\r\nr = -ENOMEM;\r\ngoto error;\r\n}\r\ndevice_initialize(minor->kdev);\r\nminor->kdev->devt = MKDEV(DRM_MAJOR, minor->index);\r\nminor->kdev->class = drm_class;\r\nminor->kdev->type = &drm_sysfs_device_minor;\r\nminor->kdev->parent = minor->dev->dev;\r\nminor->kdev->release = drm_sysfs_release;\r\ndev_set_drvdata(minor->kdev, minor);\r\nr = dev_set_name(minor->kdev, minor_str, minor->index);\r\nif (r < 0)\r\ngoto error;\r\nr = device_add(minor->kdev);\r\nif (r < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nDRM_ERROR("device create failed %d\n", r);\r\nput_device(minor->kdev);\r\nreturn r;\r\n}\r\nvoid drm_sysfs_device_remove(struct drm_minor *minor)\r\n{\r\nif (minor->kdev)\r\ndevice_unregister(minor->kdev);\r\nminor->kdev = NULL;\r\n}\r\nint drm_class_device_register(struct device *dev)\r\n{\r\nif (!drm_class || IS_ERR(drm_class))\r\nreturn -ENOENT;\r\ndev->class = drm_class;\r\nreturn device_register(dev);\r\n}\r\nvoid drm_class_device_unregister(struct device *dev)\r\n{\r\nreturn device_unregister(dev);\r\n}
