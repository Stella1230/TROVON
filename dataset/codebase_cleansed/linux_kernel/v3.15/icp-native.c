static inline unsigned int icp_native_get_xirr(void)\r\n{\r\nint cpu = smp_processor_id();\r\nunsigned int xirr;\r\nxirr = kvmppc_get_xics_latch();\r\nif (xirr)\r\nreturn xirr;\r\nreturn in_be32(&icp_native_regs[cpu]->xirr.word);\r\n}\r\nstatic inline void icp_native_set_xirr(unsigned int value)\r\n{\r\nint cpu = smp_processor_id();\r\nout_be32(&icp_native_regs[cpu]->xirr.word, value);\r\n}\r\nstatic inline void icp_native_set_cppr(u8 value)\r\n{\r\nint cpu = smp_processor_id();\r\nout_8(&icp_native_regs[cpu]->xirr.bytes[0], value);\r\n}\r\nstatic inline void icp_native_set_qirr(int n_cpu, u8 value)\r\n{\r\nout_8(&icp_native_regs[n_cpu]->qirr.bytes[0], value);\r\n}\r\nstatic void icp_native_set_cpu_priority(unsigned char cppr)\r\n{\r\nxics_set_base_cppr(cppr);\r\nicp_native_set_cppr(cppr);\r\niosync();\r\n}\r\nvoid icp_native_eoi(struct irq_data *d)\r\n{\r\nunsigned int hw_irq = (unsigned int)irqd_to_hwirq(d);\r\niosync();\r\nicp_native_set_xirr((xics_pop_cppr() << 24) | hw_irq);\r\n}\r\nstatic void icp_native_teardown_cpu(void)\r\n{\r\nint cpu = smp_processor_id();\r\nicp_native_set_qirr(cpu, 0xff);\r\n}\r\nstatic void icp_native_flush_ipi(void)\r\n{\r\nicp_native_set_xirr((0x00 << 24) | XICS_IPI);\r\n}\r\nstatic unsigned int icp_native_get_irq(void)\r\n{\r\nunsigned int xirr = icp_native_get_xirr();\r\nunsigned int vec = xirr & 0x00ffffff;\r\nunsigned int irq;\r\nif (vec == XICS_IRQ_SPURIOUS)\r\nreturn NO_IRQ;\r\nirq = irq_find_mapping(xics_host, vec);\r\nif (likely(irq != NO_IRQ)) {\r\nxics_push_cppr(vec);\r\nreturn irq;\r\n}\r\nxics_mask_unknown_vec(vec);\r\nicp_native_set_xirr(xirr);\r\nreturn NO_IRQ;\r\n}\r\nstatic void icp_native_cause_ipi(int cpu, unsigned long data)\r\n{\r\nkvmppc_set_host_ipi(cpu, 1);\r\nicp_native_set_qirr(cpu, IPI_PRIORITY);\r\n}\r\nvoid xics_wake_cpu(int cpu)\r\n{\r\nicp_native_set_qirr(cpu, IPI_PRIORITY);\r\n}\r\nstatic irqreturn_t icp_native_ipi_action(int irq, void *dev_id)\r\n{\r\nint cpu = smp_processor_id();\r\nkvmppc_set_host_ipi(cpu, 0);\r\nicp_native_set_qirr(cpu, 0xff);\r\nreturn smp_ipi_demux();\r\n}\r\nstatic int __init icp_native_map_one_cpu(int hw_id, unsigned long addr,\r\nunsigned long size)\r\n{\r\nchar *rname;\r\nint i, cpu = -1;\r\nfor_each_possible_cpu(i) {\r\nif (!cpu_present(i))\r\ncontinue;\r\nif (hw_id == get_hard_smp_processor_id(i)) {\r\ncpu = i;\r\nbreak;\r\n}\r\n}\r\nif (cpu == -1)\r\nreturn 0;\r\nrname = kasprintf(GFP_KERNEL, "CPU %d [0x%x] Interrupt Presentation",\r\ncpu, hw_id);\r\nif (!request_mem_region(addr, size, rname)) {\r\npr_warning("icp_native: Could not reserve ICP MMIO"\r\n" for CPU %d, interrupt server #0x%x\n",\r\ncpu, hw_id);\r\nreturn -EBUSY;\r\n}\r\nicp_native_regs[cpu] = ioremap(addr, size);\r\nkvmppc_set_xics_phys(cpu, addr);\r\nif (!icp_native_regs[cpu]) {\r\npr_warning("icp_native: Failed ioremap for CPU %d, "\r\n"interrupt server #0x%x, addr %#lx\n",\r\ncpu, hw_id, addr);\r\nrelease_mem_region(addr, size);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init icp_native_init_one_node(struct device_node *np,\r\nunsigned int *indx)\r\n{\r\nunsigned int ilen;\r\nconst __be32 *ireg;\r\nint i;\r\nint reg_tuple_size;\r\nint num_servers = 0;\r\nireg = of_get_property(np, "ibm,interrupt-server-ranges", &ilen);\r\nWARN_ON((ireg == NULL) || (ilen != 2*sizeof(u32)));\r\nif (ireg) {\r\n*indx = of_read_number(ireg, 1);\r\nif (ilen >= 2*sizeof(u32))\r\nnum_servers = of_read_number(ireg + 1, 1);\r\n}\r\nireg = of_get_property(np, "reg", &ilen);\r\nif (!ireg) {\r\npr_err("icp_native: Can't find interrupt reg property");\r\nreturn -1;\r\n}\r\nreg_tuple_size = (of_n_addr_cells(np) + of_n_size_cells(np)) * 4;\r\nif (((ilen % reg_tuple_size) != 0)\r\n|| (num_servers && (num_servers != (ilen / reg_tuple_size)))) {\r\npr_err("icp_native: ICP reg len (%d) != num servers (%d)",\r\nilen / reg_tuple_size, num_servers);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < (ilen / reg_tuple_size); i++) {\r\nstruct resource r;\r\nint err;\r\nerr = of_address_to_resource(np, i, &r);\r\nif (err) {\r\npr_err("icp_native: Could not translate ICP MMIO"\r\n" for interrupt server 0x%x (%d)\n", *indx, err);\r\nreturn -1;\r\n}\r\nif (icp_native_map_one_cpu(*indx, r.start, resource_size(&r)))\r\nreturn -1;\r\n(*indx)++;\r\n}\r\nreturn 0;\r\n}\r\nint __init icp_native_init(void)\r\n{\r\nstruct device_node *np;\r\nu32 indx = 0;\r\nint found = 0;\r\nfor_each_compatible_node(np, NULL, "ibm,ppc-xicp")\r\nif (icp_native_init_one_node(np, &indx) == 0)\r\nfound = 1;\r\nif (!found) {\r\nfor_each_node_by_type(np,\r\n"PowerPC-External-Interrupt-Presentation") {\r\nif (icp_native_init_one_node(np, &indx) == 0)\r\nfound = 1;\r\n}\r\n}\r\nif (found == 0)\r\nreturn -ENODEV;\r\nicp_ops = &icp_native_ops;\r\nreturn 0;\r\n}
