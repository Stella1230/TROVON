static int subdev_8255_io(int dir, int port, int data, unsigned long iobase)\r\n{\r\nif (dir) {\r\noutb(data, iobase + port);\r\nreturn 0;\r\n} else {\r\nreturn inb(iobase + port);\r\n}\r\n}\r\nvoid subdev_8255_interrupt(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct subdev_8255_private *spriv = s->private;\r\nunsigned long iobase = spriv->iobase;\r\nunsigned short d;\r\nd = spriv->io(0, _8255_DATA, 0, iobase);\r\nd |= (spriv->io(0, _8255_DATA + 1, 0, iobase) << 8);\r\ncomedi_buf_put(s->async, d);\r\ns->async->events |= COMEDI_CB_EOS;\r\ncomedi_event(dev, s);\r\n}\r\nstatic int subdev_8255_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct subdev_8255_private *spriv = s->private;\r\nunsigned long iobase = spriv->iobase;\r\nunsigned int mask;\r\nunsigned int v;\r\nmask = comedi_dio_update_state(s, data);\r\nif (mask) {\r\nif (mask & 0xff)\r\nspriv->io(1, _8255_DATA, s->state & 0xff, iobase);\r\nif (mask & 0xff00)\r\nspriv->io(1, _8255_DATA + 1, (s->state >> 8) & 0xff,\r\niobase);\r\nif (mask & 0xff0000)\r\nspriv->io(1, _8255_DATA + 2, (s->state >> 16) & 0xff,\r\niobase);\r\n}\r\nv = spriv->io(0, _8255_DATA, 0, iobase);\r\nv |= (spriv->io(0, _8255_DATA + 1, 0, iobase) << 8);\r\nv |= (spriv->io(0, _8255_DATA + 2, 0, iobase) << 16);\r\ndata[1] = v;\r\nreturn insn->n;\r\n}\r\nstatic void subdev_8255_do_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct subdev_8255_private *spriv = s->private;\r\nunsigned long iobase = spriv->iobase;\r\nint config;\r\nconfig = CR_CW;\r\nif (!(s->io_bits & 0x0000ff))\r\nconfig |= CR_A_IO;\r\nif (!(s->io_bits & 0x00ff00))\r\nconfig |= CR_B_IO;\r\nif (!(s->io_bits & 0x0f0000))\r\nconfig |= CR_C_LO_IO;\r\nif (!(s->io_bits & 0xf00000))\r\nconfig |= CR_C_HI_IO;\r\nspriv->io(1, _8255_CR, config, iobase);\r\n}\r\nstatic int subdev_8255_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int mask;\r\nint ret;\r\nif (chan < 8)\r\nmask = 0x0000ff;\r\nelse if (chan < 16)\r\nmask = 0x00ff00;\r\nelse if (chan < 20)\r\nmask = 0x0f0000;\r\nelse\r\nmask = 0xf00000;\r\nret = comedi_dio_insn_config(dev, s, insn, data, mask);\r\nif (ret)\r\nreturn ret;\r\nsubdev_8255_do_config(dev, s);\r\nreturn insn->n;\r\n}\r\nstatic int subdev_8255_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_FOLLOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, 1);\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int subdev_8255_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nreturn 0;\r\n}\r\nstatic int subdev_8255_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nreturn 0;\r\n}\r\nint subdev_8255_init(struct comedi_device *dev, struct comedi_subdevice *s,\r\nint (*io)(int, int, int, unsigned long),\r\nunsigned long iobase)\r\n{\r\nstruct subdev_8255_private *spriv;\r\nspriv = comedi_alloc_spriv(s, sizeof(*spriv));\r\nif (!spriv)\r\nreturn -ENOMEM;\r\nspriv->iobase = iobase;\r\nspriv->io = io ? io : subdev_8255_io;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 24;\r\ns->range_table = &range_digital;\r\ns->maxdata = 1;\r\ns->insn_bits = subdev_8255_insn;\r\ns->insn_config = subdev_8255_insn_config;\r\nsubdev_8255_do_config(dev, s);\r\nreturn 0;\r\n}\r\nint subdev_8255_init_irq(struct comedi_device *dev, struct comedi_subdevice *s,\r\nint (*io)(int, int, int, unsigned long),\r\nunsigned long iobase)\r\n{\r\nint ret;\r\nret = subdev_8255_init(dev, s, io, iobase);\r\nif (ret)\r\nreturn ret;\r\ns->do_cmdtest = subdev_8255_cmdtest;\r\ns->do_cmd = subdev_8255_cmd;\r\ns->cancel = subdev_8255_cancel;\r\nreturn 0;\r\n}\r\nstatic int dev_8255_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nunsigned long iobase;\r\nint i;\r\nfor (i = 0; i < COMEDI_NDEVCONFOPTS; i++) {\r\niobase = it->options[i];\r\nif (!iobase)\r\nbreak;\r\n}\r\nif (i == 0) {\r\ndev_warn(dev->class_dev, "no devices specified\n");\r\nreturn -EINVAL;\r\n}\r\nret = comedi_alloc_subdevices(dev, i);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = &dev->subdevices[i];\r\niobase = it->options[i];\r\nret = __comedi_request_region(dev, iobase, _8255_SIZE);\r\nif (ret) {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n} else {\r\nret = subdev_8255_init(dev, s, NULL, iobase);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dev_8255_detach(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s;\r\nstruct subdev_8255_private *spriv;\r\nint i;\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = &dev->subdevices[i];\r\nif (s->type != COMEDI_SUBD_UNUSED) {\r\nspriv = s->private;\r\nrelease_region(spriv->iobase, _8255_SIZE);\r\n}\r\n}\r\n}
