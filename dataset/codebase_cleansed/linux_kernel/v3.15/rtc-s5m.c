static void s5m8767_data_to_tm(u8 *data, struct rtc_time *tm,\r\nint rtc_24hr_mode)\r\n{\r\ntm->tm_sec = data[RTC_SEC] & 0x7f;\r\ntm->tm_min = data[RTC_MIN] & 0x7f;\r\nif (rtc_24hr_mode) {\r\ntm->tm_hour = data[RTC_HOUR] & 0x1f;\r\n} else {\r\ntm->tm_hour = data[RTC_HOUR] & 0x0f;\r\nif (data[RTC_HOUR] & HOUR_PM_MASK)\r\ntm->tm_hour += 12;\r\n}\r\ntm->tm_wday = ffs(data[RTC_WEEKDAY] & 0x7f);\r\ntm->tm_mday = data[RTC_DATE] & 0x1f;\r\ntm->tm_mon = (data[RTC_MONTH] & 0x0f) - 1;\r\ntm->tm_year = (data[RTC_YEAR1] & 0x7f) + 100;\r\ntm->tm_yday = 0;\r\ntm->tm_isdst = 0;\r\n}\r\nstatic int s5m8767_tm_to_data(struct rtc_time *tm, u8 *data)\r\n{\r\ndata[RTC_SEC] = tm->tm_sec;\r\ndata[RTC_MIN] = tm->tm_min;\r\nif (tm->tm_hour >= 12)\r\ndata[RTC_HOUR] = tm->tm_hour | HOUR_PM_MASK;\r\nelse\r\ndata[RTC_HOUR] = tm->tm_hour & ~HOUR_PM_MASK;\r\ndata[RTC_WEEKDAY] = 1 << tm->tm_wday;\r\ndata[RTC_DATE] = tm->tm_mday;\r\ndata[RTC_MONTH] = tm->tm_mon + 1;\r\ndata[RTC_YEAR1] = tm->tm_year > 100 ? (tm->tm_year - 100) : 0;\r\nif (tm->tm_year < 100) {\r\npr_err("s5m8767 RTC cannot handle the year %d.\n",\r\n1900 + tm->tm_year);\r\nreturn -EINVAL;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic inline int s5m8767_wait_for_udr_update(struct s5m_rtc_info *info)\r\n{\r\nint ret, retry = UDR_READ_RETRY_CNT;\r\nunsigned int data;\r\ndo {\r\nret = regmap_read(info->regmap, SEC_RTC_UDR_CON, &data);\r\n} while (--retry && (data & RTC_UDR_MASK) && !ret);\r\nif (!retry)\r\ndev_err(info->dev, "waiting for UDR update, reached max number of retries\n");\r\nreturn ret;\r\n}\r\nstatic inline int s5m8767_rtc_set_time_reg(struct s5m_rtc_info *info)\r\n{\r\nint ret;\r\nunsigned int data;\r\nret = regmap_read(info->regmap, SEC_RTC_UDR_CON, &data);\r\nif (ret < 0) {\r\ndev_err(info->dev, "failed to read update reg(%d)\n", ret);\r\nreturn ret;\r\n}\r\ndata |= RTC_TIME_EN_MASK;\r\ndata |= RTC_UDR_MASK;\r\nret = regmap_write(info->regmap, SEC_RTC_UDR_CON, data);\r\nif (ret < 0) {\r\ndev_err(info->dev, "failed to write update reg(%d)\n", ret);\r\nreturn ret;\r\n}\r\nret = s5m8767_wait_for_udr_update(info);\r\nreturn ret;\r\n}\r\nstatic inline int s5m8767_rtc_set_alarm_reg(struct s5m_rtc_info *info)\r\n{\r\nint ret;\r\nunsigned int data;\r\nret = regmap_read(info->regmap, SEC_RTC_UDR_CON, &data);\r\nif (ret < 0) {\r\ndev_err(info->dev, "%s: fail to read update reg(%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\ndata &= ~RTC_TIME_EN_MASK;\r\ndata |= RTC_UDR_MASK;\r\nret = regmap_write(info->regmap, SEC_RTC_UDR_CON, data);\r\nif (ret < 0) {\r\ndev_err(info->dev, "%s: fail to write update reg(%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = s5m8767_wait_for_udr_update(info);\r\nreturn ret;\r\n}\r\nstatic void s5m8763_data_to_tm(u8 *data, struct rtc_time *tm)\r\n{\r\ntm->tm_sec = bcd2bin(data[RTC_SEC]);\r\ntm->tm_min = bcd2bin(data[RTC_MIN]);\r\nif (data[RTC_HOUR] & HOUR_12) {\r\ntm->tm_hour = bcd2bin(data[RTC_HOUR] & 0x1f);\r\nif (data[RTC_HOUR] & HOUR_PM)\r\ntm->tm_hour += 12;\r\n} else {\r\ntm->tm_hour = bcd2bin(data[RTC_HOUR] & 0x3f);\r\n}\r\ntm->tm_wday = data[RTC_WEEKDAY] & 0x07;\r\ntm->tm_mday = bcd2bin(data[RTC_DATE]);\r\ntm->tm_mon = bcd2bin(data[RTC_MONTH]);\r\ntm->tm_year = bcd2bin(data[RTC_YEAR1]) + bcd2bin(data[RTC_YEAR2]) * 100;\r\ntm->tm_year -= 1900;\r\n}\r\nstatic void s5m8763_tm_to_data(struct rtc_time *tm, u8 *data)\r\n{\r\ndata[RTC_SEC] = bin2bcd(tm->tm_sec);\r\ndata[RTC_MIN] = bin2bcd(tm->tm_min);\r\ndata[RTC_HOUR] = bin2bcd(tm->tm_hour);\r\ndata[RTC_WEEKDAY] = tm->tm_wday;\r\ndata[RTC_DATE] = bin2bcd(tm->tm_mday);\r\ndata[RTC_MONTH] = bin2bcd(tm->tm_mon);\r\ndata[RTC_YEAR1] = bin2bcd(tm->tm_year % 100);\r\ndata[RTC_YEAR2] = bin2bcd((tm->tm_year + 1900) / 100);\r\n}\r\nstatic int s5m_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct s5m_rtc_info *info = dev_get_drvdata(dev);\r\nu8 data[8];\r\nint ret;\r\nret = regmap_bulk_read(info->regmap, SEC_RTC_SEC, data, 8);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (info->device_type) {\r\ncase S5M8763X:\r\ns5m8763_data_to_tm(data, tm);\r\nbreak;\r\ncase S5M8767X:\r\ns5m8767_data_to_tm(data, tm, info->rtc_24hr_mode);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dev, "%s: %d/%d/%d %d:%d:%d(%d)\n", __func__,\r\n1900 + tm->tm_year, 1 + tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec, tm->tm_wday);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int s5m_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct s5m_rtc_info *info = dev_get_drvdata(dev);\r\nu8 data[8];\r\nint ret = 0;\r\nswitch (info->device_type) {\r\ncase S5M8763X:\r\ns5m8763_tm_to_data(tm, data);\r\nbreak;\r\ncase S5M8767X:\r\nret = s5m8767_tm_to_data(tm, data);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(dev, "%s: %d/%d/%d %d:%d:%d(%d)\n", __func__,\r\n1900 + tm->tm_year, 1 + tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec, tm->tm_wday);\r\nret = regmap_raw_write(info->regmap, SEC_RTC_SEC, data, 8);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5m8767_rtc_set_time_reg(info);\r\nreturn ret;\r\n}\r\nstatic int s5m_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct s5m_rtc_info *info = dev_get_drvdata(dev);\r\nu8 data[8];\r\nunsigned int val;\r\nint ret, i;\r\nret = regmap_bulk_read(info->regmap, SEC_ALARM0_SEC, data, 8);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (info->device_type) {\r\ncase S5M8763X:\r\ns5m8763_data_to_tm(data, &alrm->time);\r\nret = regmap_read(info->regmap, SEC_ALARM0_CONF, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nalrm->enabled = !!val;\r\nret = regmap_read(info->regmap, SEC_RTC_STATUS, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase S5M8767X:\r\ns5m8767_data_to_tm(data, &alrm->time, info->rtc_24hr_mode);\r\ndev_dbg(dev, "%s: %d/%d/%d %d:%d:%d(%d)\n", __func__,\r\n1900 + alrm->time.tm_year, 1 + alrm->time.tm_mon,\r\nalrm->time.tm_mday, alrm->time.tm_hour,\r\nalrm->time.tm_min, alrm->time.tm_sec,\r\nalrm->time.tm_wday);\r\nalrm->enabled = 0;\r\nfor (i = 0; i < 7; i++) {\r\nif (data[i] & ALARM_ENABLE_MASK) {\r\nalrm->enabled = 1;\r\nbreak;\r\n}\r\n}\r\nalrm->pending = 0;\r\nret = regmap_read(info->regmap, SEC_RTC_STATUS, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (val & ALARM0_STATUS)\r\nalrm->pending = 1;\r\nelse\r\nalrm->pending = 0;\r\nreturn 0;\r\n}\r\nstatic int s5m_rtc_stop_alarm(struct s5m_rtc_info *info)\r\n{\r\nu8 data[8];\r\nint ret, i;\r\nstruct rtc_time tm;\r\nret = regmap_bulk_read(info->regmap, SEC_ALARM0_SEC, data, 8);\r\nif (ret < 0)\r\nreturn ret;\r\ns5m8767_data_to_tm(data, &tm, info->rtc_24hr_mode);\r\ndev_dbg(info->dev, "%s: %d/%d/%d %d:%d:%d(%d)\n", __func__,\r\n1900 + tm.tm_year, 1 + tm.tm_mon, tm.tm_mday,\r\ntm.tm_hour, tm.tm_min, tm.tm_sec, tm.tm_wday);\r\nswitch (info->device_type) {\r\ncase S5M8763X:\r\nret = regmap_write(info->regmap, SEC_ALARM0_CONF, 0);\r\nbreak;\r\ncase S5M8767X:\r\nfor (i = 0; i < 7; i++)\r\ndata[i] &= ~ALARM_ENABLE_MASK;\r\nret = regmap_raw_write(info->regmap, SEC_ALARM0_SEC, data, 8);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5m8767_rtc_set_alarm_reg(info);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5m_rtc_start_alarm(struct s5m_rtc_info *info)\r\n{\r\nint ret;\r\nu8 data[8];\r\nu8 alarm0_conf;\r\nstruct rtc_time tm;\r\nret = regmap_bulk_read(info->regmap, SEC_ALARM0_SEC, data, 8);\r\nif (ret < 0)\r\nreturn ret;\r\ns5m8767_data_to_tm(data, &tm, info->rtc_24hr_mode);\r\ndev_dbg(info->dev, "%s: %d/%d/%d %d:%d:%d(%d)\n", __func__,\r\n1900 + tm.tm_year, 1 + tm.tm_mon, tm.tm_mday,\r\ntm.tm_hour, tm.tm_min, tm.tm_sec, tm.tm_wday);\r\nswitch (info->device_type) {\r\ncase S5M8763X:\r\nalarm0_conf = 0x77;\r\nret = regmap_write(info->regmap, SEC_ALARM0_CONF, alarm0_conf);\r\nbreak;\r\ncase S5M8767X:\r\ndata[RTC_SEC] |= ALARM_ENABLE_MASK;\r\ndata[RTC_MIN] |= ALARM_ENABLE_MASK;\r\ndata[RTC_HOUR] |= ALARM_ENABLE_MASK;\r\ndata[RTC_WEEKDAY] &= ~ALARM_ENABLE_MASK;\r\nif (data[RTC_DATE] & 0x1f)\r\ndata[RTC_DATE] |= ALARM_ENABLE_MASK;\r\nif (data[RTC_MONTH] & 0xf)\r\ndata[RTC_MONTH] |= ALARM_ENABLE_MASK;\r\nif (data[RTC_YEAR1] & 0x7f)\r\ndata[RTC_YEAR1] |= ALARM_ENABLE_MASK;\r\nret = regmap_raw_write(info->regmap, SEC_ALARM0_SEC, data, 8);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5m8767_rtc_set_alarm_reg(info);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5m_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct s5m_rtc_info *info = dev_get_drvdata(dev);\r\nu8 data[8];\r\nint ret;\r\nswitch (info->device_type) {\r\ncase S5M8763X:\r\ns5m8763_tm_to_data(&alrm->time, data);\r\nbreak;\r\ncase S5M8767X:\r\ns5m8767_tm_to_data(&alrm->time, data);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dev, "%s: %d/%d/%d %d:%d:%d(%d)\n", __func__,\r\n1900 + alrm->time.tm_year, 1 + alrm->time.tm_mon,\r\nalrm->time.tm_mday, alrm->time.tm_hour, alrm->time.tm_min,\r\nalrm->time.tm_sec, alrm->time.tm_wday);\r\nret = s5m_rtc_stop_alarm(info);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_raw_write(info->regmap, SEC_ALARM0_SEC, data, 8);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5m8767_rtc_set_alarm_reg(info);\r\nif (ret < 0)\r\nreturn ret;\r\nif (alrm->enabled)\r\nret = s5m_rtc_start_alarm(info);\r\nreturn ret;\r\n}\r\nstatic int s5m_rtc_alarm_irq_enable(struct device *dev,\r\nunsigned int enabled)\r\n{\r\nstruct s5m_rtc_info *info = dev_get_drvdata(dev);\r\nif (enabled)\r\nreturn s5m_rtc_start_alarm(info);\r\nelse\r\nreturn s5m_rtc_stop_alarm(info);\r\n}\r\nstatic irqreturn_t s5m_rtc_alarm_irq(int irq, void *data)\r\n{\r\nstruct s5m_rtc_info *info = data;\r\nrtc_update_irq(info->rtc_dev, 1, RTC_IRQF | RTC_AF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void s5m_rtc_enable_wtsr(struct s5m_rtc_info *info, bool enable)\r\n{\r\nint ret;\r\nret = regmap_update_bits(info->regmap, SEC_WTSR_SMPL_CNTL,\r\nWTSR_ENABLE_MASK,\r\nenable ? WTSR_ENABLE_MASK : 0);\r\nif (ret < 0)\r\ndev_err(info->dev, "%s: fail to update WTSR reg(%d)\n",\r\n__func__, ret);\r\n}\r\nstatic void s5m_rtc_enable_smpl(struct s5m_rtc_info *info, bool enable)\r\n{\r\nint ret;\r\nret = regmap_update_bits(info->regmap, SEC_WTSR_SMPL_CNTL,\r\nSMPL_ENABLE_MASK,\r\nenable ? SMPL_ENABLE_MASK : 0);\r\nif (ret < 0)\r\ndev_err(info->dev, "%s: fail to update SMPL reg(%d)\n",\r\n__func__, ret);\r\n}\r\nstatic int s5m8767_rtc_init_reg(struct s5m_rtc_info *info)\r\n{\r\nu8 data[2];\r\nunsigned int tp_read;\r\nint ret;\r\nstruct rtc_time tm;\r\nret = regmap_read(info->regmap, SEC_RTC_UDR_CON, &tp_read);\r\nif (ret < 0) {\r\ndev_err(info->dev, "%s: fail to read control reg(%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\ndata[0] = (1 << BCD_EN_SHIFT) | (1 << MODEL24_SHIFT);\r\ndata[1] = (0 << BCD_EN_SHIFT) | (1 << MODEL24_SHIFT);\r\ninfo->rtc_24hr_mode = 1;\r\nret = regmap_raw_write(info->regmap, SEC_ALARM0_CONF, data, 2);\r\nif (ret < 0) {\r\ndev_err(info->dev, "%s: fail to write controlm reg(%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nif ((tp_read & RTC_TCON_MASK) == 0) {\r\ndev_dbg(info->dev, "rtc init\n");\r\ntm.tm_sec = 0;\r\ntm.tm_min = 0;\r\ntm.tm_hour = 0;\r\ntm.tm_wday = 0;\r\ntm.tm_mday = 1;\r\ntm.tm_mon = 0;\r\ntm.tm_year = 112;\r\ntm.tm_yday = 0;\r\ntm.tm_isdst = 0;\r\nret = s5m_rtc_set_time(info->dev, &tm);\r\n}\r\nret = regmap_update_bits(info->regmap, SEC_RTC_UDR_CON,\r\nRTC_TCON_MASK, tp_read | RTC_TCON_MASK);\r\nif (ret < 0)\r\ndev_err(info->dev, "%s: fail to update TCON reg(%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic int s5m_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct sec_pmic_dev *s5m87xx = dev_get_drvdata(pdev->dev.parent);\r\nstruct sec_platform_data *pdata = s5m87xx->pdata;\r\nstruct s5m_rtc_info *info;\r\nint ret;\r\nif (!pdata) {\r\ndev_err(pdev->dev.parent, "Platform data not supplied\n");\r\nreturn -ENODEV;\r\n}\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->dev = &pdev->dev;\r\ninfo->s5m87xx = s5m87xx;\r\ninfo->regmap = s5m87xx->regmap_rtc;\r\ninfo->device_type = s5m87xx->device_type;\r\ninfo->wtsr_smpl = s5m87xx->wtsr_smpl;\r\nswitch (pdata->device_type) {\r\ncase S5M8763X:\r\ninfo->irq = regmap_irq_get_virq(s5m87xx->irq_data,\r\nS5M8763_IRQ_ALARM0);\r\nbreak;\r\ncase S5M8767X:\r\ninfo->irq = regmap_irq_get_virq(s5m87xx->irq_data,\r\nS5M8767_IRQ_RTCA1);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ndev_err(&pdev->dev, "Unsupported device type: %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nret = s5m8767_rtc_init_reg(info);\r\nif (info->wtsr_smpl) {\r\ns5m_rtc_enable_wtsr(info, true);\r\ns5m_rtc_enable_smpl(info, true);\r\n}\r\ndevice_init_wakeup(&pdev->dev, 1);\r\ninfo->rtc_dev = devm_rtc_device_register(&pdev->dev, "s5m-rtc",\r\n&s5m_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(info->rtc_dev))\r\nreturn PTR_ERR(info->rtc_dev);\r\nret = devm_request_threaded_irq(&pdev->dev, info->irq, NULL,\r\ns5m_rtc_alarm_irq, 0, "rtc-alarm0",\r\ninfo);\r\nif (ret < 0)\r\ndev_err(&pdev->dev, "Failed to request alarm IRQ: %d: %d\n",\r\ninfo->irq, ret);\r\nreturn ret;\r\n}\r\nstatic void s5m_rtc_shutdown(struct platform_device *pdev)\r\n{\r\nstruct s5m_rtc_info *info = platform_get_drvdata(pdev);\r\nint i;\r\nunsigned int val = 0;\r\nif (info->wtsr_smpl) {\r\nfor (i = 0; i < 3; i++) {\r\ns5m_rtc_enable_wtsr(info, false);\r\nregmap_read(info->regmap, SEC_WTSR_SMPL_CNTL, &val);\r\npr_debug("%s: WTSR_SMPL reg(0x%02x)\n", __func__, val);\r\nif (val & WTSR_ENABLE_MASK)\r\npr_emerg("%s: fail to disable WTSR\n",\r\n__func__);\r\nelse {\r\npr_info("%s: success to disable WTSR\n",\r\n__func__);\r\nbreak;\r\n}\r\n}\r\n}\r\ns5m_rtc_enable_smpl(info, false);\r\n}\r\nstatic int s5m_rtc_resume(struct device *dev)\r\n{\r\nstruct s5m_rtc_info *info = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (device_may_wakeup(dev))\r\nret = disable_irq_wake(info->irq);\r\nreturn ret;\r\n}\r\nstatic int s5m_rtc_suspend(struct device *dev)\r\n{\r\nstruct s5m_rtc_info *info = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (device_may_wakeup(dev))\r\nret = enable_irq_wake(info->irq);\r\nreturn ret;\r\n}
