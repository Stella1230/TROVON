static inline struct dw_apb_clock_event_device *\r\nced_to_dw_apb_ced(struct clock_event_device *evt)\r\n{\r\nreturn container_of(evt, struct dw_apb_clock_event_device, ced);\r\n}\r\nstatic inline struct dw_apb_clocksource *\r\nclocksource_to_dw_apb_clocksource(struct clocksource *cs)\r\n{\r\nreturn container_of(cs, struct dw_apb_clocksource, cs);\r\n}\r\nstatic unsigned long apbt_readl(struct dw_apb_timer *timer, unsigned long offs)\r\n{\r\nreturn readl(timer->base + offs);\r\n}\r\nstatic void apbt_writel(struct dw_apb_timer *timer, unsigned long val,\r\nunsigned long offs)\r\n{\r\nwritel(val, timer->base + offs);\r\n}\r\nstatic void apbt_disable_int(struct dw_apb_timer *timer)\r\n{\r\nunsigned long ctrl = apbt_readl(timer, APBTMR_N_CONTROL);\r\nctrl |= APBTMR_CONTROL_INT;\r\napbt_writel(timer, ctrl, APBTMR_N_CONTROL);\r\n}\r\nvoid dw_apb_clockevent_pause(struct dw_apb_clock_event_device *dw_ced)\r\n{\r\ndisable_irq(dw_ced->timer.irq);\r\napbt_disable_int(&dw_ced->timer);\r\n}\r\nstatic void apbt_eoi(struct dw_apb_timer *timer)\r\n{\r\napbt_readl(timer, APBTMR_N_EOI);\r\n}\r\nstatic irqreturn_t dw_apb_clockevent_irq(int irq, void *data)\r\n{\r\nstruct clock_event_device *evt = data;\r\nstruct dw_apb_clock_event_device *dw_ced = ced_to_dw_apb_ced(evt);\r\nif (!evt->event_handler) {\r\npr_info("Spurious APBT timer interrupt %d", irq);\r\nreturn IRQ_NONE;\r\n}\r\nif (dw_ced->eoi)\r\ndw_ced->eoi(&dw_ced->timer);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void apbt_enable_int(struct dw_apb_timer *timer)\r\n{\r\nunsigned long ctrl = apbt_readl(timer, APBTMR_N_CONTROL);\r\napbt_readl(timer, APBTMR_N_EOI);\r\nctrl &= ~APBTMR_CONTROL_INT;\r\napbt_writel(timer, ctrl, APBTMR_N_CONTROL);\r\n}\r\nstatic void apbt_set_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *evt)\r\n{\r\nunsigned long ctrl;\r\nunsigned long period;\r\nstruct dw_apb_clock_event_device *dw_ced = ced_to_dw_apb_ced(evt);\r\npr_debug("%s CPU %d mode=%d\n", __func__, first_cpu(*evt->cpumask),\r\nmode);\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nperiod = DIV_ROUND_UP(dw_ced->timer.freq, HZ);\r\nctrl = apbt_readl(&dw_ced->timer, APBTMR_N_CONTROL);\r\nctrl |= APBTMR_CONTROL_MODE_PERIODIC;\r\napbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\r\nctrl &= ~APBTMR_CONTROL_ENABLE;\r\napbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\r\nudelay(1);\r\npr_debug("Setting clock period %lu for HZ %d\n", period, HZ);\r\napbt_writel(&dw_ced->timer, period, APBTMR_N_LOAD_COUNT);\r\nctrl |= APBTMR_CONTROL_ENABLE;\r\napbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nctrl = apbt_readl(&dw_ced->timer, APBTMR_N_CONTROL);\r\nctrl &= ~APBTMR_CONTROL_ENABLE;\r\nctrl &= ~APBTMR_CONTROL_MODE_PERIODIC;\r\napbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\r\napbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\r\napbt_writel(&dw_ced->timer, ~0, APBTMR_N_LOAD_COUNT);\r\nctrl &= ~APBTMR_CONTROL_INT;\r\nctrl |= APBTMR_CONTROL_ENABLE;\r\napbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\r\nbreak;\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\nctrl = apbt_readl(&dw_ced->timer, APBTMR_N_CONTROL);\r\nctrl &= ~APBTMR_CONTROL_ENABLE;\r\napbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\r\nbreak;\r\ncase CLOCK_EVT_MODE_RESUME:\r\napbt_enable_int(&dw_ced->timer);\r\nbreak;\r\n}\r\n}\r\nstatic int apbt_next_event(unsigned long delta,\r\nstruct clock_event_device *evt)\r\n{\r\nunsigned long ctrl;\r\nstruct dw_apb_clock_event_device *dw_ced = ced_to_dw_apb_ced(evt);\r\nctrl = apbt_readl(&dw_ced->timer, APBTMR_N_CONTROL);\r\nctrl &= ~APBTMR_CONTROL_ENABLE;\r\napbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\r\napbt_writel(&dw_ced->timer, delta, APBTMR_N_LOAD_COUNT);\r\nctrl |= APBTMR_CONTROL_ENABLE;\r\napbt_writel(&dw_ced->timer, ctrl, APBTMR_N_CONTROL);\r\nreturn 0;\r\n}\r\nstruct dw_apb_clock_event_device *\r\ndw_apb_clockevent_init(int cpu, const char *name, unsigned rating,\r\nvoid __iomem *base, int irq, unsigned long freq)\r\n{\r\nstruct dw_apb_clock_event_device *dw_ced =\r\nkzalloc(sizeof(*dw_ced), GFP_KERNEL);\r\nint err;\r\nif (!dw_ced)\r\nreturn NULL;\r\ndw_ced->timer.base = base;\r\ndw_ced->timer.irq = irq;\r\ndw_ced->timer.freq = freq;\r\nclockevents_calc_mult_shift(&dw_ced->ced, freq, APBT_MIN_PERIOD);\r\ndw_ced->ced.max_delta_ns = clockevent_delta2ns(0x7fffffff,\r\n&dw_ced->ced);\r\ndw_ced->ced.min_delta_ns = clockevent_delta2ns(5000, &dw_ced->ced);\r\ndw_ced->ced.cpumask = cpumask_of(cpu);\r\ndw_ced->ced.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\r\ndw_ced->ced.set_mode = apbt_set_mode;\r\ndw_ced->ced.set_next_event = apbt_next_event;\r\ndw_ced->ced.irq = dw_ced->timer.irq;\r\ndw_ced->ced.rating = rating;\r\ndw_ced->ced.name = name;\r\ndw_ced->irqaction.name = dw_ced->ced.name;\r\ndw_ced->irqaction.handler = dw_apb_clockevent_irq;\r\ndw_ced->irqaction.dev_id = &dw_ced->ced;\r\ndw_ced->irqaction.irq = irq;\r\ndw_ced->irqaction.flags = IRQF_TIMER | IRQF_IRQPOLL |\r\nIRQF_NOBALANCING;\r\ndw_ced->eoi = apbt_eoi;\r\nerr = setup_irq(irq, &dw_ced->irqaction);\r\nif (err) {\r\npr_err("failed to request timer irq\n");\r\nkfree(dw_ced);\r\ndw_ced = NULL;\r\n}\r\nreturn dw_ced;\r\n}\r\nvoid dw_apb_clockevent_resume(struct dw_apb_clock_event_device *dw_ced)\r\n{\r\nenable_irq(dw_ced->timer.irq);\r\n}\r\nvoid dw_apb_clockevent_stop(struct dw_apb_clock_event_device *dw_ced)\r\n{\r\nfree_irq(dw_ced->timer.irq, &dw_ced->ced);\r\n}\r\nvoid dw_apb_clockevent_register(struct dw_apb_clock_event_device *dw_ced)\r\n{\r\napbt_writel(&dw_ced->timer, 0, APBTMR_N_CONTROL);\r\nclockevents_register_device(&dw_ced->ced);\r\napbt_enable_int(&dw_ced->timer);\r\n}\r\nvoid dw_apb_clocksource_start(struct dw_apb_clocksource *dw_cs)\r\n{\r\nunsigned long ctrl = apbt_readl(&dw_cs->timer, APBTMR_N_CONTROL);\r\nctrl &= ~APBTMR_CONTROL_ENABLE;\r\napbt_writel(&dw_cs->timer, ctrl, APBTMR_N_CONTROL);\r\napbt_writel(&dw_cs->timer, ~0, APBTMR_N_LOAD_COUNT);\r\nctrl &= ~APBTMR_CONTROL_MODE_PERIODIC;\r\nctrl |= (APBTMR_CONTROL_ENABLE | APBTMR_CONTROL_INT);\r\napbt_writel(&dw_cs->timer, ctrl, APBTMR_N_CONTROL);\r\ndw_apb_clocksource_read(dw_cs);\r\n}\r\nstatic cycle_t __apbt_read_clocksource(struct clocksource *cs)\r\n{\r\nunsigned long current_count;\r\nstruct dw_apb_clocksource *dw_cs =\r\nclocksource_to_dw_apb_clocksource(cs);\r\ncurrent_count = apbt_readl(&dw_cs->timer, APBTMR_N_CURRENT_VALUE);\r\nreturn (cycle_t)~current_count;\r\n}\r\nstatic void apbt_restart_clocksource(struct clocksource *cs)\r\n{\r\nstruct dw_apb_clocksource *dw_cs =\r\nclocksource_to_dw_apb_clocksource(cs);\r\ndw_apb_clocksource_start(dw_cs);\r\n}\r\nstruct dw_apb_clocksource *\r\ndw_apb_clocksource_init(unsigned rating, const char *name, void __iomem *base,\r\nunsigned long freq)\r\n{\r\nstruct dw_apb_clocksource *dw_cs = kzalloc(sizeof(*dw_cs), GFP_KERNEL);\r\nif (!dw_cs)\r\nreturn NULL;\r\ndw_cs->timer.base = base;\r\ndw_cs->timer.freq = freq;\r\ndw_cs->cs.name = name;\r\ndw_cs->cs.rating = rating;\r\ndw_cs->cs.read = __apbt_read_clocksource;\r\ndw_cs->cs.mask = CLOCKSOURCE_MASK(32);\r\ndw_cs->cs.flags = CLOCK_SOURCE_IS_CONTINUOUS;\r\ndw_cs->cs.resume = apbt_restart_clocksource;\r\nreturn dw_cs;\r\n}\r\nvoid dw_apb_clocksource_register(struct dw_apb_clocksource *dw_cs)\r\n{\r\nclocksource_register_hz(&dw_cs->cs, dw_cs->timer.freq);\r\n}\r\ncycle_t dw_apb_clocksource_read(struct dw_apb_clocksource *dw_cs)\r\n{\r\nreturn (cycle_t)~apbt_readl(&dw_cs->timer, APBTMR_N_CURRENT_VALUE);\r\n}
