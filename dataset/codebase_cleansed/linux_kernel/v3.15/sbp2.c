static void sbp2_queue_work(struct sbp2_logical_unit *lu, unsigned long delay)\r\n{\r\nqueue_delayed_work(fw_workqueue, &lu->work, delay);\r\n}\r\nstatic struct fw_device *target_parent_device(struct sbp2_target *tgt)\r\n{\r\nreturn fw_parent_device(tgt->unit);\r\n}\r\nstatic const struct device *tgt_dev(const struct sbp2_target *tgt)\r\n{\r\nreturn &tgt->unit->device;\r\n}\r\nstatic const struct device *lu_dev(const struct sbp2_logical_unit *lu)\r\n{\r\nreturn &lu->tgt->unit->device;\r\n}\r\nstatic void free_orb(struct kref *kref)\r\n{\r\nstruct sbp2_orb *orb = container_of(kref, struct sbp2_orb, kref);\r\nkfree(orb);\r\n}\r\nstatic void sbp2_status_write(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source,\r\nint generation, unsigned long long offset,\r\nvoid *payload, size_t length, void *callback_data)\r\n{\r\nstruct sbp2_logical_unit *lu = callback_data;\r\nstruct sbp2_orb *orb;\r\nstruct sbp2_status status;\r\nunsigned long flags;\r\nif (tcode != TCODE_WRITE_BLOCK_REQUEST ||\r\nlength < 8 || length > sizeof(status)) {\r\nfw_send_response(card, request, RCODE_TYPE_ERROR);\r\nreturn;\r\n}\r\nstatus.status = be32_to_cpup(payload);\r\nstatus.orb_low = be32_to_cpup(payload + 4);\r\nmemset(status.data, 0, sizeof(status.data));\r\nif (length > 8)\r\nmemcpy(status.data, payload + 8, length - 8);\r\nif (STATUS_GET_SOURCE(status) == 2 || STATUS_GET_SOURCE(status) == 3) {\r\ndev_notice(lu_dev(lu),\r\n"non-ORB related status write, not handled\n");\r\nfw_send_response(card, request, RCODE_COMPLETE);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&card->lock, flags);\r\nlist_for_each_entry(orb, &lu->orb_list, link) {\r\nif (STATUS_GET_ORB_HIGH(status) == 0 &&\r\nSTATUS_GET_ORB_LOW(status) == orb->request_bus) {\r\norb->rcode = RCODE_COMPLETE;\r\nlist_del(&orb->link);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nif (&orb->link != &lu->orb_list) {\r\norb->callback(orb, &status);\r\nkref_put(&orb->kref, free_orb);\r\n} else {\r\ndev_err(lu_dev(lu), "status write for unknown ORB\n");\r\n}\r\nfw_send_response(card, request, RCODE_COMPLETE);\r\n}\r\nstatic void complete_transaction(struct fw_card *card, int rcode,\r\nvoid *payload, size_t length, void *data)\r\n{\r\nstruct sbp2_orb *orb = data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (orb->rcode == -1)\r\norb->rcode = rcode;\r\nif (orb->rcode != RCODE_COMPLETE) {\r\nlist_del(&orb->link);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\norb->callback(orb, NULL);\r\nkref_put(&orb->kref, free_orb);\r\n} else {\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nkref_put(&orb->kref, free_orb);\r\n}\r\nstatic void sbp2_send_orb(struct sbp2_orb *orb, struct sbp2_logical_unit *lu,\r\nint node_id, int generation, u64 offset)\r\n{\r\nstruct fw_device *device = target_parent_device(lu->tgt);\r\nstruct sbp2_pointer orb_pointer;\r\nunsigned long flags;\r\norb_pointer.high = 0;\r\norb_pointer.low = cpu_to_be32(orb->request_bus);\r\nspin_lock_irqsave(&device->card->lock, flags);\r\nlist_add_tail(&orb->link, &lu->orb_list);\r\nspin_unlock_irqrestore(&device->card->lock, flags);\r\nkref_get(&orb->kref);\r\nkref_get(&orb->kref);\r\nfw_send_request(device->card, &orb->t, TCODE_WRITE_BLOCK_REQUEST,\r\nnode_id, generation, device->max_speed, offset,\r\n&orb_pointer, 8, complete_transaction, orb);\r\n}\r\nstatic int sbp2_cancel_orbs(struct sbp2_logical_unit *lu)\r\n{\r\nstruct fw_device *device = target_parent_device(lu->tgt);\r\nstruct sbp2_orb *orb, *next;\r\nstruct list_head list;\r\nunsigned long flags;\r\nint retval = -ENOENT;\r\nINIT_LIST_HEAD(&list);\r\nspin_lock_irqsave(&device->card->lock, flags);\r\nlist_splice_init(&lu->orb_list, &list);\r\nspin_unlock_irqrestore(&device->card->lock, flags);\r\nlist_for_each_entry_safe(orb, next, &list, link) {\r\nretval = 0;\r\nif (fw_cancel_transaction(device->card, &orb->t) == 0)\r\ncontinue;\r\norb->rcode = RCODE_CANCELLED;\r\norb->callback(orb, NULL);\r\nkref_put(&orb->kref, free_orb);\r\n}\r\nreturn retval;\r\n}\r\nstatic void complete_management_orb(struct sbp2_orb *base_orb,\r\nstruct sbp2_status *status)\r\n{\r\nstruct sbp2_management_orb *orb =\r\ncontainer_of(base_orb, struct sbp2_management_orb, base);\r\nif (status)\r\nmemcpy(&orb->status, status, sizeof(*status));\r\ncomplete(&orb->done);\r\n}\r\nstatic int sbp2_send_management_orb(struct sbp2_logical_unit *lu, int node_id,\r\nint generation, int function,\r\nint lun_or_login_id, void *response)\r\n{\r\nstruct fw_device *device = target_parent_device(lu->tgt);\r\nstruct sbp2_management_orb *orb;\r\nunsigned int timeout;\r\nint retval = -ENOMEM;\r\nif (function == SBP2_LOGOUT_REQUEST && fw_device_is_shutdown(device))\r\nreturn 0;\r\norb = kzalloc(sizeof(*orb), GFP_NOIO);\r\nif (orb == NULL)\r\nreturn -ENOMEM;\r\nkref_init(&orb->base.kref);\r\norb->response_bus =\r\ndma_map_single(device->card->device, &orb->response,\r\nsizeof(orb->response), DMA_FROM_DEVICE);\r\nif (dma_mapping_error(device->card->device, orb->response_bus))\r\ngoto fail_mapping_response;\r\norb->request.response.high = 0;\r\norb->request.response.low = cpu_to_be32(orb->response_bus);\r\norb->request.misc = cpu_to_be32(\r\nMANAGEMENT_ORB_NOTIFY |\r\nMANAGEMENT_ORB_FUNCTION(function) |\r\nMANAGEMENT_ORB_LUN(lun_or_login_id));\r\norb->request.length = cpu_to_be32(\r\nMANAGEMENT_ORB_RESPONSE_LENGTH(sizeof(orb->response)));\r\norb->request.status_fifo.high =\r\ncpu_to_be32(lu->address_handler.offset >> 32);\r\norb->request.status_fifo.low =\r\ncpu_to_be32(lu->address_handler.offset);\r\nif (function == SBP2_LOGIN_REQUEST) {\r\norb->request.misc |= cpu_to_be32(\r\nMANAGEMENT_ORB_RECONNECT(2) |\r\nMANAGEMENT_ORB_EXCLUSIVE(sbp2_param_exclusive_login));\r\ntimeout = lu->tgt->mgt_orb_timeout;\r\n} else {\r\ntimeout = SBP2_ORB_TIMEOUT;\r\n}\r\ninit_completion(&orb->done);\r\norb->base.callback = complete_management_orb;\r\norb->base.request_bus =\r\ndma_map_single(device->card->device, &orb->request,\r\nsizeof(orb->request), DMA_TO_DEVICE);\r\nif (dma_mapping_error(device->card->device, orb->base.request_bus))\r\ngoto fail_mapping_request;\r\nsbp2_send_orb(&orb->base, lu, node_id, generation,\r\nlu->tgt->management_agent_address);\r\nwait_for_completion_timeout(&orb->done, msecs_to_jiffies(timeout));\r\nretval = -EIO;\r\nif (sbp2_cancel_orbs(lu) == 0) {\r\ndev_err(lu_dev(lu), "ORB reply timed out, rcode 0x%02x\n",\r\norb->base.rcode);\r\ngoto out;\r\n}\r\nif (orb->base.rcode != RCODE_COMPLETE) {\r\ndev_err(lu_dev(lu), "management write failed, rcode 0x%02x\n",\r\norb->base.rcode);\r\ngoto out;\r\n}\r\nif (STATUS_GET_RESPONSE(orb->status) != 0 ||\r\nSTATUS_GET_SBP_STATUS(orb->status) != 0) {\r\ndev_err(lu_dev(lu), "error status: %d:%d\n",\r\nSTATUS_GET_RESPONSE(orb->status),\r\nSTATUS_GET_SBP_STATUS(orb->status));\r\ngoto out;\r\n}\r\nretval = 0;\r\nout:\r\ndma_unmap_single(device->card->device, orb->base.request_bus,\r\nsizeof(orb->request), DMA_TO_DEVICE);\r\nfail_mapping_request:\r\ndma_unmap_single(device->card->device, orb->response_bus,\r\nsizeof(orb->response), DMA_FROM_DEVICE);\r\nfail_mapping_response:\r\nif (response)\r\nmemcpy(response, orb->response, sizeof(orb->response));\r\nkref_put(&orb->base.kref, free_orb);\r\nreturn retval;\r\n}\r\nstatic void sbp2_agent_reset(struct sbp2_logical_unit *lu)\r\n{\r\nstruct fw_device *device = target_parent_device(lu->tgt);\r\n__be32 d = 0;\r\nfw_run_transaction(device->card, TCODE_WRITE_QUADLET_REQUEST,\r\nlu->tgt->node_id, lu->generation, device->max_speed,\r\nlu->command_block_agent_address + SBP2_AGENT_RESET,\r\n&d, 4);\r\n}\r\nstatic void complete_agent_reset_write_no_wait(struct fw_card *card,\r\nint rcode, void *payload, size_t length, void *data)\r\n{\r\nkfree(data);\r\n}\r\nstatic void sbp2_agent_reset_no_wait(struct sbp2_logical_unit *lu)\r\n{\r\nstruct fw_device *device = target_parent_device(lu->tgt);\r\nstruct fw_transaction *t;\r\nstatic __be32 d;\r\nt = kmalloc(sizeof(*t), GFP_ATOMIC);\r\nif (t == NULL)\r\nreturn;\r\nfw_send_request(device->card, t, TCODE_WRITE_QUADLET_REQUEST,\r\nlu->tgt->node_id, lu->generation, device->max_speed,\r\nlu->command_block_agent_address + SBP2_AGENT_RESET,\r\n&d, 4, complete_agent_reset_write_no_wait, t);\r\n}\r\nstatic inline void sbp2_allow_block(struct sbp2_logical_unit *lu)\r\n{\r\n--lu->tgt->dont_block;\r\n}\r\nstatic void sbp2_conditionally_block(struct sbp2_logical_unit *lu)\r\n{\r\nstruct sbp2_target *tgt = lu->tgt;\r\nstruct fw_card *card = target_parent_device(tgt)->card;\r\nstruct Scsi_Host *shost =\r\ncontainer_of((void *)tgt, struct Scsi_Host, hostdata[0]);\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (!tgt->dont_block && !lu->blocked &&\r\nlu->generation != card->generation) {\r\nlu->blocked = true;\r\nif (++tgt->blocked == 1)\r\nscsi_block_requests(shost);\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nstatic void sbp2_conditionally_unblock(struct sbp2_logical_unit *lu)\r\n{\r\nstruct sbp2_target *tgt = lu->tgt;\r\nstruct fw_card *card = target_parent_device(tgt)->card;\r\nstruct Scsi_Host *shost =\r\ncontainer_of((void *)tgt, struct Scsi_Host, hostdata[0]);\r\nunsigned long flags;\r\nbool unblock = false;\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (lu->blocked && lu->generation == card->generation) {\r\nlu->blocked = false;\r\nunblock = --tgt->blocked == 0;\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nif (unblock)\r\nscsi_unblock_requests(shost);\r\n}\r\nstatic void sbp2_unblock(struct sbp2_target *tgt)\r\n{\r\nstruct fw_card *card = target_parent_device(tgt)->card;\r\nstruct Scsi_Host *shost =\r\ncontainer_of((void *)tgt, struct Scsi_Host, hostdata[0]);\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\n++tgt->dont_block;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nscsi_unblock_requests(shost);\r\n}\r\nstatic int sbp2_lun2int(u16 lun)\r\n{\r\nstruct scsi_lun eight_bytes_lun;\r\nmemset(&eight_bytes_lun, 0, sizeof(eight_bytes_lun));\r\neight_bytes_lun.scsi_lun[0] = (lun >> 8) & 0xff;\r\neight_bytes_lun.scsi_lun[1] = lun & 0xff;\r\nreturn scsilun_to_int(&eight_bytes_lun);\r\n}\r\nstatic void sbp2_set_busy_timeout(struct sbp2_logical_unit *lu)\r\n{\r\nstruct fw_device *device = target_parent_device(lu->tgt);\r\n__be32 d = cpu_to_be32(SBP2_CYCLE_LIMIT | SBP2_RETRY_LIMIT);\r\nfw_run_transaction(device->card, TCODE_WRITE_QUADLET_REQUEST,\r\nlu->tgt->node_id, lu->generation, device->max_speed,\r\nCSR_REGISTER_BASE + CSR_BUSY_TIMEOUT, &d, 4);\r\n}\r\nstatic void sbp2_login(struct work_struct *work)\r\n{\r\nstruct sbp2_logical_unit *lu =\r\ncontainer_of(work, struct sbp2_logical_unit, work.work);\r\nstruct sbp2_target *tgt = lu->tgt;\r\nstruct fw_device *device = target_parent_device(tgt);\r\nstruct Scsi_Host *shost;\r\nstruct scsi_device *sdev;\r\nstruct sbp2_login_response response;\r\nint generation, node_id, local_node_id;\r\nif (fw_device_is_shutdown(device))\r\nreturn;\r\ngeneration = device->generation;\r\nsmp_rmb();\r\nnode_id = device->node_id;\r\nlocal_node_id = device->card->node_id;\r\nif (lu->has_sdev)\r\nsbp2_send_management_orb(lu, device->node_id, generation,\r\nSBP2_LOGOUT_REQUEST, lu->login_id, NULL);\r\nif (sbp2_send_management_orb(lu, node_id, generation,\r\nSBP2_LOGIN_REQUEST, lu->lun, &response) < 0) {\r\nif (lu->retries++ < 5) {\r\nsbp2_queue_work(lu, DIV_ROUND_UP(HZ, 5));\r\n} else {\r\ndev_err(tgt_dev(tgt), "failed to login to LUN %04x\n",\r\nlu->lun);\r\nsbp2_unblock(lu->tgt);\r\n}\r\nreturn;\r\n}\r\ntgt->node_id = node_id;\r\ntgt->address_high = local_node_id << 16;\r\nsmp_wmb();\r\nlu->generation = generation;\r\nlu->command_block_agent_address =\r\n((u64)(be32_to_cpu(response.command_block_agent.high) & 0xffff)\r\n<< 32) | be32_to_cpu(response.command_block_agent.low);\r\nlu->login_id = be32_to_cpu(response.misc) & 0xffff;\r\ndev_notice(tgt_dev(tgt), "logged in to LUN %04x (%d retries)\n",\r\nlu->lun, lu->retries);\r\nsbp2_set_busy_timeout(lu);\r\nlu->workfn = sbp2_reconnect;\r\nsbp2_agent_reset(lu);\r\nif (lu->has_sdev) {\r\nsbp2_cancel_orbs(lu);\r\nsbp2_conditionally_unblock(lu);\r\nreturn;\r\n}\r\nif (lu->tgt->workarounds & SBP2_WORKAROUND_DELAY_INQUIRY)\r\nssleep(SBP2_INQUIRY_DELAY);\r\nshost = container_of((void *)tgt, struct Scsi_Host, hostdata[0]);\r\nsdev = __scsi_add_device(shost, 0, 0, sbp2_lun2int(lu->lun), lu);\r\nif (IS_ERR(sdev))\r\ngoto out_logout_login;\r\nsmp_rmb();\r\nif (generation != device->card->generation) {\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\ngoto out_logout_login;\r\n}\r\nlu->has_sdev = true;\r\nscsi_device_put(sdev);\r\nsbp2_allow_block(lu);\r\nreturn;\r\nout_logout_login:\r\nsmp_rmb();\r\ngeneration = device->generation;\r\nsmp_rmb();\r\nsbp2_send_management_orb(lu, device->node_id, generation,\r\nSBP2_LOGOUT_REQUEST, lu->login_id, NULL);\r\nlu->workfn = sbp2_login;\r\n}\r\nstatic void sbp2_reconnect(struct work_struct *work)\r\n{\r\nstruct sbp2_logical_unit *lu =\r\ncontainer_of(work, struct sbp2_logical_unit, work.work);\r\nstruct sbp2_target *tgt = lu->tgt;\r\nstruct fw_device *device = target_parent_device(tgt);\r\nint generation, node_id, local_node_id;\r\nif (fw_device_is_shutdown(device))\r\nreturn;\r\ngeneration = device->generation;\r\nsmp_rmb();\r\nnode_id = device->node_id;\r\nlocal_node_id = device->card->node_id;\r\nif (sbp2_send_management_orb(lu, node_id, generation,\r\nSBP2_RECONNECT_REQUEST,\r\nlu->login_id, NULL) < 0) {\r\nsmp_rmb();\r\nif (generation == device->card->generation ||\r\nlu->retries++ >= 5) {\r\ndev_err(tgt_dev(tgt), "failed to reconnect\n");\r\nlu->retries = 0;\r\nlu->workfn = sbp2_login;\r\n}\r\nsbp2_queue_work(lu, DIV_ROUND_UP(HZ, 5));\r\nreturn;\r\n}\r\ntgt->node_id = node_id;\r\ntgt->address_high = local_node_id << 16;\r\nsmp_wmb();\r\nlu->generation = generation;\r\ndev_notice(tgt_dev(tgt), "reconnected to LUN %04x (%d retries)\n",\r\nlu->lun, lu->retries);\r\nsbp2_agent_reset(lu);\r\nsbp2_cancel_orbs(lu);\r\nsbp2_conditionally_unblock(lu);\r\n}\r\nstatic void sbp2_lu_workfn(struct work_struct *work)\r\n{\r\nstruct sbp2_logical_unit *lu = container_of(to_delayed_work(work),\r\nstruct sbp2_logical_unit, work);\r\nlu->workfn(work);\r\n}\r\nstatic int sbp2_add_logical_unit(struct sbp2_target *tgt, int lun_entry)\r\n{\r\nstruct sbp2_logical_unit *lu;\r\nlu = kmalloc(sizeof(*lu), GFP_KERNEL);\r\nif (!lu)\r\nreturn -ENOMEM;\r\nlu->address_handler.length = 0x100;\r\nlu->address_handler.address_callback = sbp2_status_write;\r\nlu->address_handler.callback_data = lu;\r\nif (fw_core_add_address_handler(&lu->address_handler,\r\n&fw_high_memory_region) < 0) {\r\nkfree(lu);\r\nreturn -ENOMEM;\r\n}\r\nlu->tgt = tgt;\r\nlu->lun = lun_entry & 0xffff;\r\nlu->login_id = INVALID_LOGIN_ID;\r\nlu->retries = 0;\r\nlu->has_sdev = false;\r\nlu->blocked = false;\r\n++tgt->dont_block;\r\nINIT_LIST_HEAD(&lu->orb_list);\r\nlu->workfn = sbp2_login;\r\nINIT_DELAYED_WORK(&lu->work, sbp2_lu_workfn);\r\nlist_add_tail(&lu->link, &tgt->lu_list);\r\nreturn 0;\r\n}\r\nstatic void sbp2_get_unit_unique_id(struct sbp2_target *tgt,\r\nconst u32 *leaf)\r\n{\r\nif ((leaf[0] & 0xffff0000) == 0x00020000)\r\ntgt->guid = (u64)leaf[1] << 32 | leaf[2];\r\n}\r\nstatic int sbp2_scan_logical_unit_dir(struct sbp2_target *tgt,\r\nconst u32 *directory)\r\n{\r\nstruct fw_csr_iterator ci;\r\nint key, value;\r\nfw_csr_iterator_init(&ci, directory);\r\nwhile (fw_csr_iterator_next(&ci, &key, &value))\r\nif (key == SBP2_CSR_LOGICAL_UNIT_NUMBER &&\r\nsbp2_add_logical_unit(tgt, value) < 0)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int sbp2_scan_unit_dir(struct sbp2_target *tgt, const u32 *directory,\r\nu32 *model, u32 *firmware_revision)\r\n{\r\nstruct fw_csr_iterator ci;\r\nint key, value;\r\nfw_csr_iterator_init(&ci, directory);\r\nwhile (fw_csr_iterator_next(&ci, &key, &value)) {\r\nswitch (key) {\r\ncase CSR_DEPENDENT_INFO | CSR_OFFSET:\r\ntgt->management_agent_address =\r\nCSR_REGISTER_BASE + 4 * value;\r\nbreak;\r\ncase CSR_DIRECTORY_ID:\r\ntgt->directory_id = value;\r\nbreak;\r\ncase CSR_MODEL:\r\n*model = value;\r\nbreak;\r\ncase SBP2_CSR_FIRMWARE_REVISION:\r\n*firmware_revision = value;\r\nbreak;\r\ncase SBP2_CSR_UNIT_CHARACTERISTICS:\r\ntgt->mgt_orb_timeout = (value >> 8 & 0xff) * 500;\r\nbreak;\r\ncase SBP2_CSR_LOGICAL_UNIT_NUMBER:\r\nif (sbp2_add_logical_unit(tgt, value) < 0)\r\nreturn -ENOMEM;\r\nbreak;\r\ncase SBP2_CSR_UNIT_UNIQUE_ID:\r\nsbp2_get_unit_unique_id(tgt, ci.p - 1 + value);\r\nbreak;\r\ncase SBP2_CSR_LOGICAL_UNIT_DIRECTORY:\r\nif (sbp2_scan_logical_unit_dir(tgt, ci.p - 1 + value) < 0)\r\nreturn -ENOMEM;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sbp2_clamp_management_orb_timeout(struct sbp2_target *tgt)\r\n{\r\nunsigned int timeout = tgt->mgt_orb_timeout;\r\nif (timeout > 40000)\r\ndev_notice(tgt_dev(tgt), "%ds mgt_ORB_timeout limited to 40s\n",\r\ntimeout / 1000);\r\ntgt->mgt_orb_timeout = clamp_val(timeout, 5000, 40000);\r\n}\r\nstatic void sbp2_init_workarounds(struct sbp2_target *tgt, u32 model,\r\nu32 firmware_revision)\r\n{\r\nint i;\r\nunsigned int w = sbp2_param_workarounds;\r\nif (w)\r\ndev_notice(tgt_dev(tgt),\r\n"Please notify linux1394-devel@lists.sf.net "\r\n"if you need the workarounds parameter\n");\r\nif (w & SBP2_WORKAROUND_OVERRIDE)\r\ngoto out;\r\nfor (i = 0; i < ARRAY_SIZE(sbp2_workarounds_table); i++) {\r\nif (sbp2_workarounds_table[i].firmware_revision !=\r\n(firmware_revision & 0xffffff00))\r\ncontinue;\r\nif (sbp2_workarounds_table[i].model != model &&\r\nsbp2_workarounds_table[i].model != SBP2_ROM_VALUE_WILDCARD)\r\ncontinue;\r\nw |= sbp2_workarounds_table[i].workarounds;\r\nbreak;\r\n}\r\nout:\r\nif (w)\r\ndev_notice(tgt_dev(tgt), "workarounds 0x%x "\r\n"(firmware_revision 0x%06x, model_id 0x%06x)\n",\r\nw, firmware_revision, model);\r\ntgt->workarounds = w;\r\n}\r\nstatic int sbp2_probe(struct fw_unit *unit, const struct ieee1394_device_id *id)\r\n{\r\nstruct fw_device *device = fw_parent_device(unit);\r\nstruct sbp2_target *tgt;\r\nstruct sbp2_logical_unit *lu;\r\nstruct Scsi_Host *shost;\r\nu32 model, firmware_revision;\r\nif (device->is_local)\r\nreturn -ENODEV;\r\nif (dma_get_max_seg_size(device->card->device) > SBP2_MAX_SEG_SIZE)\r\nWARN_ON(dma_set_max_seg_size(device->card->device,\r\nSBP2_MAX_SEG_SIZE));\r\nshost = scsi_host_alloc(&scsi_driver_template, sizeof(*tgt));\r\nif (shost == NULL)\r\nreturn -ENOMEM;\r\ntgt = (struct sbp2_target *)shost->hostdata;\r\ndev_set_drvdata(&unit->device, tgt);\r\ntgt->unit = unit;\r\nINIT_LIST_HEAD(&tgt->lu_list);\r\ntgt->guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];\r\nif (fw_device_enable_phys_dma(device) < 0)\r\ngoto fail_shost_put;\r\nshost->max_cmd_len = SBP2_MAX_CDB_SIZE;\r\nif (scsi_add_host_with_dma(shost, &unit->device,\r\ndevice->card->device) < 0)\r\ngoto fail_shost_put;\r\ntgt->directory_id = ((unit->directory - device->config_rom) * 4\r\n+ CSR_CONFIG_ROM) & 0xffffff;\r\nfirmware_revision = SBP2_ROM_VALUE_MISSING;\r\nmodel = SBP2_ROM_VALUE_MISSING;\r\nif (sbp2_scan_unit_dir(tgt, unit->directory, &model,\r\n&firmware_revision) < 0)\r\ngoto fail_remove;\r\nsbp2_clamp_management_orb_timeout(tgt);\r\nsbp2_init_workarounds(tgt, model, firmware_revision);\r\ntgt->max_payload = min3(device->max_speed + 7, 10U,\r\ndevice->card->max_receive - 1);\r\nlist_for_each_entry(lu, &tgt->lu_list, link)\r\nsbp2_queue_work(lu, DIV_ROUND_UP(HZ, 5));\r\nreturn 0;\r\nfail_remove:\r\nsbp2_remove(unit);\r\nreturn -ENOMEM;\r\nfail_shost_put:\r\nscsi_host_put(shost);\r\nreturn -ENOMEM;\r\n}\r\nstatic void sbp2_update(struct fw_unit *unit)\r\n{\r\nstruct sbp2_target *tgt = dev_get_drvdata(&unit->device);\r\nstruct sbp2_logical_unit *lu;\r\nfw_device_enable_phys_dma(fw_parent_device(unit));\r\nlist_for_each_entry(lu, &tgt->lu_list, link) {\r\nsbp2_conditionally_block(lu);\r\nlu->retries = 0;\r\nsbp2_queue_work(lu, 0);\r\n}\r\n}\r\nstatic void sbp2_remove(struct fw_unit *unit)\r\n{\r\nstruct fw_device *device = fw_parent_device(unit);\r\nstruct sbp2_target *tgt = dev_get_drvdata(&unit->device);\r\nstruct sbp2_logical_unit *lu, *next;\r\nstruct Scsi_Host *shost =\r\ncontainer_of((void *)tgt, struct Scsi_Host, hostdata[0]);\r\nstruct scsi_device *sdev;\r\nsbp2_unblock(tgt);\r\nlist_for_each_entry_safe(lu, next, &tgt->lu_list, link) {\r\ncancel_delayed_work_sync(&lu->work);\r\nsdev = scsi_device_lookup(shost, 0, 0, sbp2_lun2int(lu->lun));\r\nif (sdev) {\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\n}\r\nif (lu->login_id != INVALID_LOGIN_ID) {\r\nint generation, node_id;\r\ngeneration = device->generation;\r\nsmp_rmb();\r\nnode_id = device->node_id;\r\nsbp2_send_management_orb(lu, node_id, generation,\r\nSBP2_LOGOUT_REQUEST,\r\nlu->login_id, NULL);\r\n}\r\nfw_core_remove_address_handler(&lu->address_handler);\r\nlist_del(&lu->link);\r\nkfree(lu);\r\n}\r\nscsi_remove_host(shost);\r\ndev_notice(&unit->device, "released target %d:0:0\n", shost->host_no);\r\nscsi_host_put(shost);\r\n}\r\nstatic void sbp2_unmap_scatterlist(struct device *card_device,\r\nstruct sbp2_command_orb *orb)\r\n{\r\nscsi_dma_unmap(orb->cmd);\r\nif (orb->request.misc & cpu_to_be32(COMMAND_ORB_PAGE_TABLE_PRESENT))\r\ndma_unmap_single(card_device, orb->page_table_bus,\r\nsizeof(orb->page_table), DMA_TO_DEVICE);\r\n}\r\nstatic unsigned int sbp2_status_to_sense_data(u8 *sbp2_status, u8 *sense_data)\r\n{\r\nint sam_status;\r\nint sfmt = (sbp2_status[0] >> 6) & 0x03;\r\nif (sfmt == 2 || sfmt == 3) {\r\nreturn DID_ERROR << 16;\r\n}\r\nsense_data[0] = 0x70 | sfmt | (sbp2_status[1] & 0x80);\r\nsense_data[1] = 0x0;\r\nsense_data[2] = ((sbp2_status[1] << 1) & 0xe0) | (sbp2_status[1] & 0x0f);\r\nsense_data[3] = sbp2_status[4];\r\nsense_data[4] = sbp2_status[5];\r\nsense_data[5] = sbp2_status[6];\r\nsense_data[6] = sbp2_status[7];\r\nsense_data[7] = 10;\r\nsense_data[8] = sbp2_status[8];\r\nsense_data[9] = sbp2_status[9];\r\nsense_data[10] = sbp2_status[10];\r\nsense_data[11] = sbp2_status[11];\r\nsense_data[12] = sbp2_status[2];\r\nsense_data[13] = sbp2_status[3];\r\nsense_data[14] = sbp2_status[12];\r\nsense_data[15] = sbp2_status[13];\r\nsam_status = sbp2_status[0] & 0x3f;\r\nswitch (sam_status) {\r\ncase SAM_STAT_GOOD:\r\ncase SAM_STAT_CHECK_CONDITION:\r\ncase SAM_STAT_CONDITION_MET:\r\ncase SAM_STAT_BUSY:\r\ncase SAM_STAT_RESERVATION_CONFLICT:\r\ncase SAM_STAT_COMMAND_TERMINATED:\r\nreturn DID_OK << 16 | sam_status;\r\ndefault:\r\nreturn DID_ERROR << 16;\r\n}\r\n}\r\nstatic void complete_command_orb(struct sbp2_orb *base_orb,\r\nstruct sbp2_status *status)\r\n{\r\nstruct sbp2_command_orb *orb =\r\ncontainer_of(base_orb, struct sbp2_command_orb, base);\r\nstruct fw_device *device = target_parent_device(orb->lu->tgt);\r\nint result;\r\nif (status != NULL) {\r\nif (STATUS_GET_DEAD(*status))\r\nsbp2_agent_reset_no_wait(orb->lu);\r\nswitch (STATUS_GET_RESPONSE(*status)) {\r\ncase SBP2_STATUS_REQUEST_COMPLETE:\r\nresult = DID_OK << 16;\r\nbreak;\r\ncase SBP2_STATUS_TRANSPORT_FAILURE:\r\nresult = DID_BUS_BUSY << 16;\r\nbreak;\r\ncase SBP2_STATUS_ILLEGAL_REQUEST:\r\ncase SBP2_STATUS_VENDOR_DEPENDENT:\r\ndefault:\r\nresult = DID_ERROR << 16;\r\nbreak;\r\n}\r\nif (result == DID_OK << 16 && STATUS_GET_LEN(*status) > 1)\r\nresult = sbp2_status_to_sense_data(STATUS_GET_DATA(*status),\r\norb->cmd->sense_buffer);\r\n} else {\r\nresult = DID_BUS_BUSY << 16;\r\nsbp2_conditionally_block(orb->lu);\r\n}\r\ndma_unmap_single(device->card->device, orb->base.request_bus,\r\nsizeof(orb->request), DMA_TO_DEVICE);\r\nsbp2_unmap_scatterlist(device->card->device, orb);\r\norb->cmd->result = result;\r\norb->cmd->scsi_done(orb->cmd);\r\n}\r\nstatic int sbp2_map_scatterlist(struct sbp2_command_orb *orb,\r\nstruct fw_device *device, struct sbp2_logical_unit *lu)\r\n{\r\nstruct scatterlist *sg = scsi_sglist(orb->cmd);\r\nint i, n;\r\nn = scsi_dma_map(orb->cmd);\r\nif (n <= 0)\r\ngoto fail;\r\nif (n == 1) {\r\norb->request.data_descriptor.high =\r\ncpu_to_be32(lu->tgt->address_high);\r\norb->request.data_descriptor.low =\r\ncpu_to_be32(sg_dma_address(sg));\r\norb->request.misc |=\r\ncpu_to_be32(COMMAND_ORB_DATA_SIZE(sg_dma_len(sg)));\r\nreturn 0;\r\n}\r\nfor_each_sg(sg, sg, n, i) {\r\norb->page_table[i].high = cpu_to_be32(sg_dma_len(sg) << 16);\r\norb->page_table[i].low = cpu_to_be32(sg_dma_address(sg));\r\n}\r\norb->page_table_bus =\r\ndma_map_single(device->card->device, orb->page_table,\r\nsizeof(orb->page_table), DMA_TO_DEVICE);\r\nif (dma_mapping_error(device->card->device, orb->page_table_bus))\r\ngoto fail_page_table;\r\norb->request.data_descriptor.high = cpu_to_be32(lu->tgt->address_high);\r\norb->request.data_descriptor.low = cpu_to_be32(orb->page_table_bus);\r\norb->request.misc |= cpu_to_be32(COMMAND_ORB_PAGE_TABLE_PRESENT |\r\nCOMMAND_ORB_DATA_SIZE(n));\r\nreturn 0;\r\nfail_page_table:\r\nscsi_dma_unmap(orb->cmd);\r\nfail:\r\nreturn -ENOMEM;\r\n}\r\nstatic int sbp2_scsi_queuecommand(struct Scsi_Host *shost,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct sbp2_logical_unit *lu = cmd->device->hostdata;\r\nstruct fw_device *device = target_parent_device(lu->tgt);\r\nstruct sbp2_command_orb *orb;\r\nint generation, retval = SCSI_MLQUEUE_HOST_BUSY;\r\nif (cmd->sc_data_direction == DMA_BIDIRECTIONAL) {\r\ndev_err(lu_dev(lu), "cannot handle bidirectional command\n");\r\ncmd->result = DID_ERROR << 16;\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\norb = kzalloc(sizeof(*orb), GFP_ATOMIC);\r\nif (orb == NULL)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\norb->base.rcode = -1;\r\nkref_init(&orb->base.kref);\r\norb->lu = lu;\r\norb->cmd = cmd;\r\norb->request.next.high = cpu_to_be32(SBP2_ORB_NULL);\r\norb->request.misc = cpu_to_be32(\r\nCOMMAND_ORB_MAX_PAYLOAD(lu->tgt->max_payload) |\r\nCOMMAND_ORB_SPEED(device->max_speed) |\r\nCOMMAND_ORB_NOTIFY);\r\nif (cmd->sc_data_direction == DMA_FROM_DEVICE)\r\norb->request.misc |= cpu_to_be32(COMMAND_ORB_DIRECTION);\r\ngeneration = device->generation;\r\nsmp_rmb();\r\nif (scsi_sg_count(cmd) && sbp2_map_scatterlist(orb, device, lu) < 0)\r\ngoto out;\r\nmemcpy(orb->request.command_block, cmd->cmnd, cmd->cmd_len);\r\norb->base.callback = complete_command_orb;\r\norb->base.request_bus =\r\ndma_map_single(device->card->device, &orb->request,\r\nsizeof(orb->request), DMA_TO_DEVICE);\r\nif (dma_mapping_error(device->card->device, orb->base.request_bus)) {\r\nsbp2_unmap_scatterlist(device->card->device, orb);\r\ngoto out;\r\n}\r\nsbp2_send_orb(&orb->base, lu, lu->tgt->node_id, generation,\r\nlu->command_block_agent_address + SBP2_ORB_POINTER);\r\nretval = 0;\r\nout:\r\nkref_put(&orb->base.kref, free_orb);\r\nreturn retval;\r\n}\r\nstatic int sbp2_scsi_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct sbp2_logical_unit *lu = sdev->hostdata;\r\nif (!lu)\r\nreturn -ENOSYS;\r\nsdev->allow_restart = 1;\r\nblk_queue_update_dma_alignment(sdev->request_queue, 4 - 1);\r\nif (lu->tgt->workarounds & SBP2_WORKAROUND_INQUIRY_36)\r\nsdev->inquiry_len = 36;\r\nreturn 0;\r\n}\r\nstatic int sbp2_scsi_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct sbp2_logical_unit *lu = sdev->hostdata;\r\nsdev->use_10_for_rw = 1;\r\nif (sbp2_param_exclusive_login)\r\nsdev->manage_start_stop = 1;\r\nif (sdev->type == TYPE_ROM)\r\nsdev->use_10_for_ms = 1;\r\nif (sdev->type == TYPE_DISK &&\r\nlu->tgt->workarounds & SBP2_WORKAROUND_MODE_SENSE_8)\r\nsdev->skip_ms_page_8 = 1;\r\nif (lu->tgt->workarounds & SBP2_WORKAROUND_FIX_CAPACITY)\r\nsdev->fix_capacity = 1;\r\nif (lu->tgt->workarounds & SBP2_WORKAROUND_POWER_CONDITION)\r\nsdev->start_stop_pwr_cond = 1;\r\nif (lu->tgt->workarounds & SBP2_WORKAROUND_128K_MAX_TRANS)\r\nblk_queue_max_hw_sectors(sdev->request_queue, 128 * 1024 / 512);\r\nreturn 0;\r\n}\r\nstatic int sbp2_scsi_abort(struct scsi_cmnd *cmd)\r\n{\r\nstruct sbp2_logical_unit *lu = cmd->device->hostdata;\r\ndev_notice(lu_dev(lu), "sbp2_scsi_abort\n");\r\nsbp2_agent_reset(lu);\r\nsbp2_cancel_orbs(lu);\r\nreturn SUCCESS;\r\n}\r\nstatic ssize_t sbp2_sysfs_ieee1394_id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct sbp2_logical_unit *lu;\r\nif (!sdev)\r\nreturn 0;\r\nlu = sdev->hostdata;\r\nreturn sprintf(buf, "%016llx:%06x:%04x\n",\r\n(unsigned long long)lu->tgt->guid,\r\nlu->tgt->directory_id, lu->lun);\r\n}\r\nstatic int __init sbp2_init(void)\r\n{\r\nreturn driver_register(&sbp2_driver.driver);\r\n}\r\nstatic void __exit sbp2_cleanup(void)\r\n{\r\ndriver_unregister(&sbp2_driver.driver);\r\n}
