static inline u32 regr(u32 offset)\r\n{\r\nreturn __raw_readl(ccdc_cfg.base_addr + offset);\r\n}\r\nstatic inline void regw(u32 val, u32 offset)\r\n{\r\n__raw_writel(val, ccdc_cfg.base_addr + offset);\r\n}\r\nstatic void ccdc_enable(int flag)\r\n{\r\nregw(flag, CCDC_PCR);\r\n}\r\nstatic void ccdc_enable_vport(int flag)\r\n{\r\nif (flag)\r\nregw(CCDC_ENABLE_VIDEO_PORT, CCDC_FMTCFG);\r\nelse\r\nregw(CCDC_DISABLE_VIDEO_PORT, CCDC_FMTCFG);\r\n}\r\nvoid ccdc_setwin(struct v4l2_rect *image_win,\r\nenum ccdc_frmfmt frm_fmt,\r\nint ppc)\r\n{\r\nint horz_start, horz_nr_pixels;\r\nint vert_start, vert_nr_lines;\r\nint val = 0, mid_img = 0;\r\ndev_dbg(ccdc_cfg.dev, "\nStarting ccdc_setwin...");\r\nhorz_start = image_win->left << (ppc - 1);\r\nhorz_nr_pixels = (image_win->width << (ppc - 1)) - 1;\r\nregw((horz_start << CCDC_HORZ_INFO_SPH_SHIFT) | horz_nr_pixels,\r\nCCDC_HORZ_INFO);\r\nvert_start = image_win->top;\r\nif (frm_fmt == CCDC_FRMFMT_INTERLACED) {\r\nvert_nr_lines = (image_win->height >> 1) - 1;\r\nvert_start >>= 1;\r\nvert_start += 1;\r\nval = (vert_start << CCDC_VDINT_VDINT0_SHIFT);\r\nregw(val, CCDC_VDINT);\r\n} else {\r\nvert_start += 1;\r\nvert_nr_lines = image_win->height - 1;\r\nmid_img = vert_start + (image_win->height / 2);\r\nval = (vert_start << CCDC_VDINT_VDINT0_SHIFT) |\r\n(mid_img & CCDC_VDINT_VDINT1_MASK);\r\nregw(val, CCDC_VDINT);\r\n}\r\nregw((vert_start << CCDC_VERT_START_SLV0_SHIFT) | vert_start,\r\nCCDC_VERT_START);\r\nregw(vert_nr_lines, CCDC_VERT_LINES);\r\ndev_dbg(ccdc_cfg.dev, "\nEnd of ccdc_setwin...");\r\n}\r\nstatic void ccdc_readregs(void)\r\n{\r\nunsigned int val = 0;\r\nval = regr(CCDC_ALAW);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to ALAW...\n", val);\r\nval = regr(CCDC_CLAMP);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to CLAMP...\n", val);\r\nval = regr(CCDC_DCSUB);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to DCSUB...\n", val);\r\nval = regr(CCDC_BLKCMP);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to BLKCMP...\n", val);\r\nval = regr(CCDC_FPC_ADDR);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to FPC_ADDR...\n", val);\r\nval = regr(CCDC_FPC);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to FPC...\n", val);\r\nval = regr(CCDC_FMTCFG);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to FMTCFG...\n", val);\r\nval = regr(CCDC_COLPTN);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to COLPTN...\n", val);\r\nval = regr(CCDC_FMT_HORZ);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to FMT_HORZ...\n", val);\r\nval = regr(CCDC_FMT_VERT);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to FMT_VERT...\n", val);\r\nval = regr(CCDC_HSIZE_OFF);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to HSIZE_OFF...\n", val);\r\nval = regr(CCDC_SDOFST);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to SDOFST...\n", val);\r\nval = regr(CCDC_VP_OUT);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to VP_OUT...\n", val);\r\nval = regr(CCDC_SYN_MODE);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to SYN_MODE...\n", val);\r\nval = regr(CCDC_HORZ_INFO);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to HORZ_INFO...\n", val);\r\nval = regr(CCDC_VERT_START);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to VERT_START...\n", val);\r\nval = regr(CCDC_VERT_LINES);\r\ndev_notice(ccdc_cfg.dev, "\nReading 0x%x to VERT_LINES...\n", val);\r\n}\r\nstatic int validate_ccdc_param(struct ccdc_config_params_raw *ccdcparam)\r\n{\r\nif (ccdcparam->alaw.enable) {\r\nu8 max_gamma = ccdc_gamma_width_max_bit(ccdcparam->alaw.gamma_wd);\r\nu8 max_data = ccdc_data_size_max_bit(ccdcparam->data_sz);\r\nif ((ccdcparam->alaw.gamma_wd > CCDC_GAMMA_BITS_09_0) ||\r\n(ccdcparam->alaw.gamma_wd < CCDC_GAMMA_BITS_15_6) ||\r\n(max_gamma > max_data)) {\r\ndev_dbg(ccdc_cfg.dev, "\nInvalid data line select");\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ccdc_update_raw_params(struct ccdc_config_params_raw *raw_params)\r\n{\r\nstruct ccdc_config_params_raw *config_params =\r\n&ccdc_cfg.bayer.config_params;\r\nunsigned int *fpc_virtaddr = NULL;\r\nunsigned int *fpc_physaddr = NULL;\r\nmemcpy(config_params, raw_params, sizeof(*raw_params));\r\nif (!config_params->fault_pxl.enable)\r\nreturn 0;\r\nfpc_physaddr = (unsigned int *)config_params->fault_pxl.fpc_table_addr;\r\nfpc_virtaddr = (unsigned int *)phys_to_virt(\r\n(unsigned long)fpc_physaddr);\r\nif (raw_params->fault_pxl.fp_num != config_params->fault_pxl.fp_num) {\r\nif (fpc_physaddr != NULL) {\r\nfree_pages((unsigned long)fpc_physaddr,\r\nget_order\r\n(config_params->fault_pxl.fp_num *\r\nFP_NUM_BYTES));\r\n}\r\nfpc_virtaddr =\r\n(unsigned int *)__get_free_pages(GFP_KERNEL | GFP_DMA,\r\nget_order(raw_params->\r\nfault_pxl.fp_num *\r\nFP_NUM_BYTES));\r\nif (fpc_virtaddr == NULL) {\r\ndev_dbg(ccdc_cfg.dev,\r\n"\nUnable to allocate memory for FPC");\r\nreturn -EFAULT;\r\n}\r\nfpc_physaddr =\r\n(unsigned int *)virt_to_phys((void *)fpc_virtaddr);\r\n}\r\nconfig_params->fault_pxl.fp_num = raw_params->fault_pxl.fp_num;\r\nif (copy_from_user(fpc_virtaddr,\r\n(void __user *)raw_params->fault_pxl.fpc_table_addr,\r\nconfig_params->fault_pxl.fp_num * FP_NUM_BYTES)) {\r\ndev_dbg(ccdc_cfg.dev, "\n copy_from_user failed");\r\nreturn -EFAULT;\r\n}\r\nconfig_params->fault_pxl.fpc_table_addr = (unsigned int)fpc_physaddr;\r\nreturn 0;\r\n}\r\nstatic int ccdc_close(struct device *dev)\r\n{\r\nstruct ccdc_config_params_raw *config_params =\r\n&ccdc_cfg.bayer.config_params;\r\nunsigned int *fpc_physaddr = NULL, *fpc_virtaddr = NULL;\r\nfpc_physaddr = (unsigned int *)config_params->fault_pxl.fpc_table_addr;\r\nif (fpc_physaddr != NULL) {\r\nfpc_virtaddr = (unsigned int *)\r\nphys_to_virt((unsigned long)fpc_physaddr);\r\nfree_pages((unsigned long)fpc_virtaddr,\r\nget_order(config_params->fault_pxl.fp_num *\r\nFP_NUM_BYTES));\r\n}\r\nreturn 0;\r\n}\r\nstatic void ccdc_restore_defaults(void)\r\n{\r\nint i;\r\nccdc_enable(0);\r\nfor (i = 4; i <= 0x94; i += 4)\r\nregw(0, i);\r\nregw(CCDC_NO_CULLING, CCDC_CULLING);\r\nregw(CCDC_GAMMA_BITS_11_2, CCDC_ALAW);\r\n}\r\nstatic int ccdc_open(struct device *device)\r\n{\r\nccdc_restore_defaults();\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nccdc_enable_vport(1);\r\nreturn 0;\r\n}\r\nstatic void ccdc_sbl_reset(void)\r\n{\r\nvpss_clear_wbl_overflow(VPSS_PCR_CCDC_WBL_O);\r\n}\r\nstatic int ccdc_set_params(void __user *params)\r\n{\r\nstruct ccdc_config_params_raw ccdc_raw_params;\r\nint x;\r\nif (ccdc_cfg.if_type != VPFE_RAW_BAYER)\r\nreturn -EINVAL;\r\nx = copy_from_user(&ccdc_raw_params, params, sizeof(ccdc_raw_params));\r\nif (x) {\r\ndev_dbg(ccdc_cfg.dev, "ccdc_set_params: error in copying"\r\n"ccdc params, %d\n", x);\r\nreturn -EFAULT;\r\n}\r\nif (!validate_ccdc_param(&ccdc_raw_params)) {\r\nif (!ccdc_update_raw_params(&ccdc_raw_params))\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid ccdc_config_ycbcr(void)\r\n{\r\nstruct ccdc_params_ycbcr *params = &ccdc_cfg.ycbcr;\r\nu32 syn_mode;\r\ndev_dbg(ccdc_cfg.dev, "\nStarting ccdc_config_ycbcr...");\r\nccdc_restore_defaults();\r\nsyn_mode = (((params->pix_fmt & CCDC_SYN_MODE_INPMOD_MASK) <<\r\nCCDC_SYN_MODE_INPMOD_SHIFT) |\r\n((params->frm_fmt & CCDC_SYN_FLDMODE_MASK) <<\r\nCCDC_SYN_FLDMODE_SHIFT) | CCDC_VDHDEN_ENABLE |\r\nCCDC_WEN_ENABLE | CCDC_DATA_PACK_ENABLE);\r\nif (params->bt656_enable) {\r\nregw(CCDC_REC656IF_BT656_EN, CCDC_REC656IF);\r\nsyn_mode |= CCDC_SYN_MODE_VD_POL_NEGATIVE;\r\nif (ccdc_cfg.if_type == VPFE_BT656_10BIT)\r\nsyn_mode |= CCDC_SYN_MODE_10BITS;\r\nelse\r\nsyn_mode |= CCDC_SYN_MODE_8BITS;\r\n} else {\r\nsyn_mode |= (((params->fid_pol & CCDC_FID_POL_MASK) <<\r\nCCDC_FID_POL_SHIFT) |\r\n((params->hd_pol & CCDC_HD_POL_MASK) <<\r\nCCDC_HD_POL_SHIFT) |\r\n((params->vd_pol & CCDC_VD_POL_MASK) <<\r\nCCDC_VD_POL_SHIFT));\r\n}\r\nregw(syn_mode, CCDC_SYN_MODE);\r\nccdc_setwin(&params->win, params->frm_fmt, 2);\r\nif (ccdc_cfg.if_type == VPFE_BT656_10BIT)\r\nregw((params->pix_order << CCDC_CCDCFG_Y8POS_SHIFT) |\r\nCCDC_LATCH_ON_VSYNC_DISABLE | CCDC_CCDCFG_BW656_10BIT,\r\nCCDC_CCDCFG);\r\nelse\r\nregw((params->pix_order << CCDC_CCDCFG_Y8POS_SHIFT) |\r\nCCDC_LATCH_ON_VSYNC_DISABLE, CCDC_CCDCFG);\r\nregw(((params->win.width * 2 + 31) & ~0x1f), CCDC_HSIZE_OFF);\r\nif (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED)\r\nregw(CCDC_SDOFST_FIELD_INTERLEAVED, CCDC_SDOFST);\r\nccdc_sbl_reset();\r\ndev_dbg(ccdc_cfg.dev, "\nEnd of ccdc_config_ycbcr...\n");\r\n}\r\nstatic void ccdc_config_black_clamp(struct ccdc_black_clamp *bclamp)\r\n{\r\nu32 val;\r\nif (!bclamp->enable) {\r\nval = (bclamp->dc_sub) & CCDC_BLK_DC_SUB_MASK;\r\nregw(val, CCDC_DCSUB);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to DCSUB...\n", val);\r\nregw(CCDC_CLAMP_DEFAULT_VAL, CCDC_CLAMP);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x0000 to CLAMP...\n");\r\nreturn;\r\n}\r\nval = ((bclamp->sgain & CCDC_BLK_SGAIN_MASK) |\r\n((bclamp->start_pixel & CCDC_BLK_ST_PXL_MASK) <<\r\nCCDC_BLK_ST_PXL_SHIFT) |\r\n((bclamp->sample_ln & CCDC_BLK_SAMPLE_LINE_MASK) <<\r\nCCDC_BLK_SAMPLE_LINE_SHIFT) |\r\n((bclamp->sample_pixel & CCDC_BLK_SAMPLE_LN_MASK) <<\r\nCCDC_BLK_SAMPLE_LN_SHIFT) | CCDC_BLK_CLAMP_ENABLE);\r\nregw(val, CCDC_CLAMP);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to CLAMP...\n", val);\r\nregw(CCDC_DCSUB_DEFAULT_VAL, CCDC_DCSUB);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x00000000 to DCSUB...\n");\r\n}\r\nstatic void ccdc_config_black_compense(struct ccdc_black_compensation *bcomp)\r\n{\r\nu32 val;\r\nval = ((bcomp->b & CCDC_BLK_COMP_MASK) |\r\n((bcomp->gb & CCDC_BLK_COMP_MASK) <<\r\nCCDC_BLK_COMP_GB_COMP_SHIFT) |\r\n((bcomp->gr & CCDC_BLK_COMP_MASK) <<\r\nCCDC_BLK_COMP_GR_COMP_SHIFT) |\r\n((bcomp->r & CCDC_BLK_COMP_MASK) <<\r\nCCDC_BLK_COMP_R_COMP_SHIFT));\r\nregw(val, CCDC_BLKCMP);\r\n}\r\nstatic void ccdc_config_fpc(struct ccdc_fault_pixel *fpc)\r\n{\r\nu32 val;\r\nval = CCDC_FPC_DISABLE;\r\nregw(val, CCDC_FPC);\r\nif (!fpc->enable)\r\nreturn;\r\nregw(fpc->fpc_table_addr, CCDC_FPC_ADDR);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to FPC_ADDR...\n",\r\n(fpc->fpc_table_addr));\r\nval = fpc->fp_num & CCDC_FPC_FPC_NUM_MASK;\r\nregw(val, CCDC_FPC);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to FPC...\n", val);\r\nval = regr(CCDC_FPC) | CCDC_FPC_ENABLE;\r\nregw(val, CCDC_FPC);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to FPC...\n", val);\r\n}\r\nvoid ccdc_config_raw(void)\r\n{\r\nstruct ccdc_params_raw *params = &ccdc_cfg.bayer;\r\nstruct ccdc_config_params_raw *config_params =\r\n&ccdc_cfg.bayer.config_params;\r\nunsigned int syn_mode = 0;\r\nunsigned int val;\r\ndev_dbg(ccdc_cfg.dev, "\nStarting ccdc_config_raw...");\r\nccdc_restore_defaults();\r\nregw(CCDC_LATCH_ON_VSYNC_DISABLE, CCDC_CCDCFG);\r\nsyn_mode =\r\n(((params->vd_pol & CCDC_VD_POL_MASK) << CCDC_VD_POL_SHIFT) |\r\n((params->hd_pol & CCDC_HD_POL_MASK) << CCDC_HD_POL_SHIFT) |\r\n((params->fid_pol & CCDC_FID_POL_MASK) << CCDC_FID_POL_SHIFT) |\r\n((params->frm_fmt & CCDC_FRM_FMT_MASK) << CCDC_FRM_FMT_SHIFT) |\r\n((config_params->data_sz & CCDC_DATA_SZ_MASK) <<\r\nCCDC_DATA_SZ_SHIFT) |\r\n((params->pix_fmt & CCDC_PIX_FMT_MASK) << CCDC_PIX_FMT_SHIFT) |\r\nCCDC_WEN_ENABLE | CCDC_VDHDEN_ENABLE);\r\nif (config_params->alaw.enable) {\r\nval = ((config_params->alaw.gamma_wd &\r\nCCDC_ALAW_GAMMA_WD_MASK) | CCDC_ALAW_ENABLE);\r\nregw(val, CCDC_ALAW);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to ALAW...\n", val);\r\n}\r\nccdc_setwin(&params->win, params->frm_fmt, CCDC_PPC_RAW);\r\nccdc_config_black_clamp(&config_params->blk_clamp);\r\nccdc_config_black_compense(&config_params->blk_comp);\r\nccdc_config_fpc(&config_params->fault_pxl);\r\nif ((config_params->data_sz == CCDC_DATA_8BITS) ||\r\nconfig_params->alaw.enable)\r\nsyn_mode |= CCDC_DATA_PACK_ENABLE;\r\n#ifdef CONFIG_DM644X_VIDEO_PORT_ENABLE\r\nval = CCDC_ENABLE_VIDEO_PORT;\r\n#else\r\nval = CCDC_DISABLE_VIDEO_PORT;\r\n#endif\r\nif (config_params->data_sz == CCDC_DATA_8BITS)\r\nval |= (CCDC_DATA_10BITS & CCDC_FMTCFG_VPIN_MASK)\r\n<< CCDC_FMTCFG_VPIN_SHIFT;\r\nelse\r\nval |= (config_params->data_sz & CCDC_FMTCFG_VPIN_MASK)\r\n<< CCDC_FMTCFG_VPIN_SHIFT;\r\nregw(val, CCDC_FMTCFG);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to FMTCFG...\n", val);\r\nregw(CCDC_COLPTN_VAL, CCDC_COLPTN);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0xBB11BB11 to COLPTN...\n");\r\nval = ((params->win.left & CCDC_FMT_HORZ_FMTSPH_MASK) <<\r\nCCDC_FMT_HORZ_FMTSPH_SHIFT) |\r\n(params->win.width & CCDC_FMT_HORZ_FMTLNH_MASK);\r\nregw(val, CCDC_FMT_HORZ);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to FMT_HORZ...\n", val);\r\nval = (params->win.top & CCDC_FMT_VERT_FMTSLV_MASK)\r\n<< CCDC_FMT_VERT_FMTSLV_SHIFT;\r\nif (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE)\r\nval |= (params->win.height) & CCDC_FMT_VERT_FMTLNV_MASK;\r\nelse\r\nval |= (params->win.height >> 1) & CCDC_FMT_VERT_FMTLNV_MASK;\r\ndev_dbg(ccdc_cfg.dev, "\nparams->win.height 0x%x ...\n",\r\nparams->win.height);\r\nregw(val, CCDC_FMT_VERT);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to FMT_VERT...\n", val);\r\ndev_dbg(ccdc_cfg.dev, "\nbelow regw(val, FMT_VERT)...");\r\nif ((config_params->data_sz == CCDC_DATA_8BITS) ||\r\nconfig_params->alaw.enable)\r\nregw((params->win.width + CCDC_32BYTE_ALIGN_VAL) &\r\nCCDC_HSIZE_OFF_MASK, CCDC_HSIZE_OFF);\r\nelse\r\nregw(((params->win.width * CCDC_TWO_BYTES_PER_PIXEL) +\r\nCCDC_32BYTE_ALIGN_VAL) & CCDC_HSIZE_OFF_MASK,\r\nCCDC_HSIZE_OFF);\r\nif (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {\r\nif (params->image_invert_enable) {\r\nregw(CCDC_INTERLACED_IMAGE_INVERT, CCDC_SDOFST);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x4B6D to SDOFST..\n");\r\n}\r\nelse {\r\nregw(CCDC_INTERLACED_NO_IMAGE_INVERT, CCDC_SDOFST);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x0249 to SDOFST..\n");\r\n}\r\n} else if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {\r\nregw(CCDC_PROGRESSIVE_NO_IMAGE_INVERT, CCDC_SDOFST);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x0000 to SDOFST...\n");\r\n}\r\nif (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE)\r\nval = (((params->win.height - 1) & CCDC_VP_OUT_VERT_NUM_MASK))\r\n<< CCDC_VP_OUT_VERT_NUM_SHIFT;\r\nelse\r\nval =\r\n((((params->win.height >> CCDC_INTERLACED_HEIGHT_SHIFT) -\r\n1) & CCDC_VP_OUT_VERT_NUM_MASK)) <<\r\nCCDC_VP_OUT_VERT_NUM_SHIFT;\r\nval |= ((((params->win.width))) & CCDC_VP_OUT_HORZ_NUM_MASK)\r\n<< CCDC_VP_OUT_HORZ_NUM_SHIFT;\r\nval |= (params->win.left) & CCDC_VP_OUT_HORZ_ST_MASK;\r\nregw(val, CCDC_VP_OUT);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to VP_OUT...\n", val);\r\nregw(syn_mode, CCDC_SYN_MODE);\r\ndev_dbg(ccdc_cfg.dev, "\nWriting 0x%x to SYN_MODE...\n", syn_mode);\r\nccdc_sbl_reset();\r\ndev_dbg(ccdc_cfg.dev, "\nend of ccdc_config_raw...");\r\nccdc_readregs();\r\n}\r\nstatic int ccdc_configure(void)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nccdc_config_raw();\r\nelse\r\nccdc_config_ycbcr();\r\nreturn 0;\r\n}\r\nstatic int ccdc_set_buftype(enum ccdc_buftype buf_type)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nccdc_cfg.bayer.buf_type = buf_type;\r\nelse\r\nccdc_cfg.ycbcr.buf_type = buf_type;\r\nreturn 0;\r\n}\r\nstatic enum ccdc_buftype ccdc_get_buftype(void)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nreturn ccdc_cfg.bayer.buf_type;\r\nreturn ccdc_cfg.ycbcr.buf_type;\r\n}\r\nstatic int ccdc_enum_pix(u32 *pix, int i)\r\n{\r\nint ret = -EINVAL;\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER) {\r\nif (i < ARRAY_SIZE(ccdc_raw_bayer_pix_formats)) {\r\n*pix = ccdc_raw_bayer_pix_formats[i];\r\nret = 0;\r\n}\r\n} else {\r\nif (i < ARRAY_SIZE(ccdc_raw_yuv_pix_formats)) {\r\n*pix = ccdc_raw_yuv_pix_formats[i];\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ccdc_set_pixel_format(u32 pixfmt)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER) {\r\nccdc_cfg.bayer.pix_fmt = CCDC_PIXFMT_RAW;\r\nif (pixfmt == V4L2_PIX_FMT_SBGGR8)\r\nccdc_cfg.bayer.config_params.alaw.enable = 1;\r\nelse if (pixfmt != V4L2_PIX_FMT_SBGGR16)\r\nreturn -EINVAL;\r\n} else {\r\nif (pixfmt == V4L2_PIX_FMT_YUYV)\r\nccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_YCBYCR;\r\nelse if (pixfmt == V4L2_PIX_FMT_UYVY)\r\nccdc_cfg.ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 ccdc_get_pixel_format(void)\r\n{\r\nstruct ccdc_a_law *alaw = &ccdc_cfg.bayer.config_params.alaw;\r\nu32 pixfmt;\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nif (alaw->enable)\r\npixfmt = V4L2_PIX_FMT_SBGGR8;\r\nelse\r\npixfmt = V4L2_PIX_FMT_SBGGR16;\r\nelse {\r\nif (ccdc_cfg.ycbcr.pix_order == CCDC_PIXORDER_YCBYCR)\r\npixfmt = V4L2_PIX_FMT_YUYV;\r\nelse\r\npixfmt = V4L2_PIX_FMT_UYVY;\r\n}\r\nreturn pixfmt;\r\n}\r\nstatic int ccdc_set_image_window(struct v4l2_rect *win)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nccdc_cfg.bayer.win = *win;\r\nelse\r\nccdc_cfg.ycbcr.win = *win;\r\nreturn 0;\r\n}\r\nstatic void ccdc_get_image_window(struct v4l2_rect *win)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\n*win = ccdc_cfg.bayer.win;\r\nelse\r\n*win = ccdc_cfg.ycbcr.win;\r\n}\r\nstatic unsigned int ccdc_get_line_length(void)\r\n{\r\nstruct ccdc_config_params_raw *config_params =\r\n&ccdc_cfg.bayer.config_params;\r\nunsigned int len;\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER) {\r\nif ((config_params->alaw.enable) ||\r\n(config_params->data_sz == CCDC_DATA_8BITS))\r\nlen = ccdc_cfg.bayer.win.width;\r\nelse\r\nlen = ccdc_cfg.bayer.win.width * 2;\r\n} else\r\nlen = ccdc_cfg.ycbcr.win.width * 2;\r\nreturn ALIGN(len, 32);\r\n}\r\nstatic int ccdc_set_frame_format(enum ccdc_frmfmt frm_fmt)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nccdc_cfg.bayer.frm_fmt = frm_fmt;\r\nelse\r\nccdc_cfg.ycbcr.frm_fmt = frm_fmt;\r\nreturn 0;\r\n}\r\nstatic enum ccdc_frmfmt ccdc_get_frame_format(void)\r\n{\r\nif (ccdc_cfg.if_type == VPFE_RAW_BAYER)\r\nreturn ccdc_cfg.bayer.frm_fmt;\r\nelse\r\nreturn ccdc_cfg.ycbcr.frm_fmt;\r\n}\r\nstatic int ccdc_getfid(void)\r\n{\r\nreturn (regr(CCDC_SYN_MODE) >> 15) & 1;\r\n}\r\nstatic inline void ccdc_setfbaddr(unsigned long addr)\r\n{\r\nregw(addr & 0xffffffe0, CCDC_SDR_ADDR);\r\n}\r\nstatic int ccdc_set_hw_if_params(struct vpfe_hw_if_param *params)\r\n{\r\nccdc_cfg.if_type = params->if_type;\r\nswitch (params->if_type) {\r\ncase VPFE_BT656:\r\ncase VPFE_YCBCR_SYNC_16:\r\ncase VPFE_YCBCR_SYNC_8:\r\ncase VPFE_BT656_10BIT:\r\nccdc_cfg.ycbcr.vd_pol = params->vdpol;\r\nccdc_cfg.ycbcr.hd_pol = params->hdpol;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ccdc_save_context(void)\r\n{\r\nccdc_ctx[CCDC_PCR >> 2] = regr(CCDC_PCR);\r\nccdc_ctx[CCDC_SYN_MODE >> 2] = regr(CCDC_SYN_MODE);\r\nccdc_ctx[CCDC_HD_VD_WID >> 2] = regr(CCDC_HD_VD_WID);\r\nccdc_ctx[CCDC_PIX_LINES >> 2] = regr(CCDC_PIX_LINES);\r\nccdc_ctx[CCDC_HORZ_INFO >> 2] = regr(CCDC_HORZ_INFO);\r\nccdc_ctx[CCDC_VERT_START >> 2] = regr(CCDC_VERT_START);\r\nccdc_ctx[CCDC_VERT_LINES >> 2] = regr(CCDC_VERT_LINES);\r\nccdc_ctx[CCDC_CULLING >> 2] = regr(CCDC_CULLING);\r\nccdc_ctx[CCDC_HSIZE_OFF >> 2] = regr(CCDC_HSIZE_OFF);\r\nccdc_ctx[CCDC_SDOFST >> 2] = regr(CCDC_SDOFST);\r\nccdc_ctx[CCDC_SDR_ADDR >> 2] = regr(CCDC_SDR_ADDR);\r\nccdc_ctx[CCDC_CLAMP >> 2] = regr(CCDC_CLAMP);\r\nccdc_ctx[CCDC_DCSUB >> 2] = regr(CCDC_DCSUB);\r\nccdc_ctx[CCDC_COLPTN >> 2] = regr(CCDC_COLPTN);\r\nccdc_ctx[CCDC_BLKCMP >> 2] = regr(CCDC_BLKCMP);\r\nccdc_ctx[CCDC_FPC >> 2] = regr(CCDC_FPC);\r\nccdc_ctx[CCDC_FPC_ADDR >> 2] = regr(CCDC_FPC_ADDR);\r\nccdc_ctx[CCDC_VDINT >> 2] = regr(CCDC_VDINT);\r\nccdc_ctx[CCDC_ALAW >> 2] = regr(CCDC_ALAW);\r\nccdc_ctx[CCDC_REC656IF >> 2] = regr(CCDC_REC656IF);\r\nccdc_ctx[CCDC_CCDCFG >> 2] = regr(CCDC_CCDCFG);\r\nccdc_ctx[CCDC_FMTCFG >> 2] = regr(CCDC_FMTCFG);\r\nccdc_ctx[CCDC_FMT_HORZ >> 2] = regr(CCDC_FMT_HORZ);\r\nccdc_ctx[CCDC_FMT_VERT >> 2] = regr(CCDC_FMT_VERT);\r\nccdc_ctx[CCDC_FMT_ADDR0 >> 2] = regr(CCDC_FMT_ADDR0);\r\nccdc_ctx[CCDC_FMT_ADDR1 >> 2] = regr(CCDC_FMT_ADDR1);\r\nccdc_ctx[CCDC_FMT_ADDR2 >> 2] = regr(CCDC_FMT_ADDR2);\r\nccdc_ctx[CCDC_FMT_ADDR3 >> 2] = regr(CCDC_FMT_ADDR3);\r\nccdc_ctx[CCDC_FMT_ADDR4 >> 2] = regr(CCDC_FMT_ADDR4);\r\nccdc_ctx[CCDC_FMT_ADDR5 >> 2] = regr(CCDC_FMT_ADDR5);\r\nccdc_ctx[CCDC_FMT_ADDR6 >> 2] = regr(CCDC_FMT_ADDR6);\r\nccdc_ctx[CCDC_FMT_ADDR7 >> 2] = regr(CCDC_FMT_ADDR7);\r\nccdc_ctx[CCDC_PRGEVEN_0 >> 2] = regr(CCDC_PRGEVEN_0);\r\nccdc_ctx[CCDC_PRGEVEN_1 >> 2] = regr(CCDC_PRGEVEN_1);\r\nccdc_ctx[CCDC_PRGODD_0 >> 2] = regr(CCDC_PRGODD_0);\r\nccdc_ctx[CCDC_PRGODD_1 >> 2] = regr(CCDC_PRGODD_1);\r\nccdc_ctx[CCDC_VP_OUT >> 2] = regr(CCDC_VP_OUT);\r\n}\r\nstatic void ccdc_restore_context(void)\r\n{\r\nregw(ccdc_ctx[CCDC_SYN_MODE >> 2], CCDC_SYN_MODE);\r\nregw(ccdc_ctx[CCDC_HD_VD_WID >> 2], CCDC_HD_VD_WID);\r\nregw(ccdc_ctx[CCDC_PIX_LINES >> 2], CCDC_PIX_LINES);\r\nregw(ccdc_ctx[CCDC_HORZ_INFO >> 2], CCDC_HORZ_INFO);\r\nregw(ccdc_ctx[CCDC_VERT_START >> 2], CCDC_VERT_START);\r\nregw(ccdc_ctx[CCDC_VERT_LINES >> 2], CCDC_VERT_LINES);\r\nregw(ccdc_ctx[CCDC_CULLING >> 2], CCDC_CULLING);\r\nregw(ccdc_ctx[CCDC_HSIZE_OFF >> 2], CCDC_HSIZE_OFF);\r\nregw(ccdc_ctx[CCDC_SDOFST >> 2], CCDC_SDOFST);\r\nregw(ccdc_ctx[CCDC_SDR_ADDR >> 2], CCDC_SDR_ADDR);\r\nregw(ccdc_ctx[CCDC_CLAMP >> 2], CCDC_CLAMP);\r\nregw(ccdc_ctx[CCDC_DCSUB >> 2], CCDC_DCSUB);\r\nregw(ccdc_ctx[CCDC_COLPTN >> 2], CCDC_COLPTN);\r\nregw(ccdc_ctx[CCDC_BLKCMP >> 2], CCDC_BLKCMP);\r\nregw(ccdc_ctx[CCDC_FPC >> 2], CCDC_FPC);\r\nregw(ccdc_ctx[CCDC_FPC_ADDR >> 2], CCDC_FPC_ADDR);\r\nregw(ccdc_ctx[CCDC_VDINT >> 2], CCDC_VDINT);\r\nregw(ccdc_ctx[CCDC_ALAW >> 2], CCDC_ALAW);\r\nregw(ccdc_ctx[CCDC_REC656IF >> 2], CCDC_REC656IF);\r\nregw(ccdc_ctx[CCDC_CCDCFG >> 2], CCDC_CCDCFG);\r\nregw(ccdc_ctx[CCDC_FMTCFG >> 2], CCDC_FMTCFG);\r\nregw(ccdc_ctx[CCDC_FMT_HORZ >> 2], CCDC_FMT_HORZ);\r\nregw(ccdc_ctx[CCDC_FMT_VERT >> 2], CCDC_FMT_VERT);\r\nregw(ccdc_ctx[CCDC_FMT_ADDR0 >> 2], CCDC_FMT_ADDR0);\r\nregw(ccdc_ctx[CCDC_FMT_ADDR1 >> 2], CCDC_FMT_ADDR1);\r\nregw(ccdc_ctx[CCDC_FMT_ADDR2 >> 2], CCDC_FMT_ADDR2);\r\nregw(ccdc_ctx[CCDC_FMT_ADDR3 >> 2], CCDC_FMT_ADDR3);\r\nregw(ccdc_ctx[CCDC_FMT_ADDR4 >> 2], CCDC_FMT_ADDR4);\r\nregw(ccdc_ctx[CCDC_FMT_ADDR5 >> 2], CCDC_FMT_ADDR5);\r\nregw(ccdc_ctx[CCDC_FMT_ADDR6 >> 2], CCDC_FMT_ADDR6);\r\nregw(ccdc_ctx[CCDC_FMT_ADDR7 >> 2], CCDC_FMT_ADDR7);\r\nregw(ccdc_ctx[CCDC_PRGEVEN_0 >> 2], CCDC_PRGEVEN_0);\r\nregw(ccdc_ctx[CCDC_PRGEVEN_1 >> 2], CCDC_PRGEVEN_1);\r\nregw(ccdc_ctx[CCDC_PRGODD_0 >> 2], CCDC_PRGODD_0);\r\nregw(ccdc_ctx[CCDC_PRGODD_1 >> 2], CCDC_PRGODD_1);\r\nregw(ccdc_ctx[CCDC_VP_OUT >> 2], CCDC_VP_OUT);\r\nregw(ccdc_ctx[CCDC_PCR >> 2], CCDC_PCR);\r\n}\r\nstatic int dm644x_ccdc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint status = 0;\r\nstatus = vpfe_register_ccdc_device(&ccdc_hw_dev);\r\nif (status < 0)\r\nreturn status;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nstatus = -ENODEV;\r\ngoto fail_nores;\r\n}\r\nres = request_mem_region(res->start, resource_size(res), res->name);\r\nif (!res) {\r\nstatus = -EBUSY;\r\ngoto fail_nores;\r\n}\r\nccdc_cfg.base_addr = ioremap_nocache(res->start, resource_size(res));\r\nif (!ccdc_cfg.base_addr) {\r\nstatus = -ENOMEM;\r\ngoto fail_nomem;\r\n}\r\nccdc_cfg.dev = &pdev->dev;\r\nprintk(KERN_NOTICE "%s is registered with vpfe.\n", ccdc_hw_dev.name);\r\nreturn 0;\r\nfail_nomem:\r\nrelease_mem_region(res->start, resource_size(res));\r\nfail_nores:\r\nvpfe_unregister_ccdc_device(&ccdc_hw_dev);\r\nreturn status;\r\n}\r\nstatic int dm644x_ccdc_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\niounmap(ccdc_cfg.base_addr);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\nvpfe_unregister_ccdc_device(&ccdc_hw_dev);\r\nreturn 0;\r\n}\r\nstatic int dm644x_ccdc_suspend(struct device *dev)\r\n{\r\nccdc_save_context();\r\nccdc_enable(0);\r\nreturn 0;\r\n}\r\nstatic int dm644x_ccdc_resume(struct device *dev)\r\n{\r\nccdc_restore_context();\r\nreturn 0;\r\n}
