static void cirrus_user_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct cirrus_framebuffer *cirrus_fb = to_cirrus_framebuffer(fb);\r\nif (cirrus_fb->obj)\r\ndrm_gem_object_unreference_unlocked(cirrus_fb->obj);\r\ndrm_framebuffer_cleanup(fb);\r\nkfree(fb);\r\n}\r\nint cirrus_framebuffer_init(struct drm_device *dev,\r\nstruct cirrus_framebuffer *gfb,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object *obj)\r\n{\r\nint ret;\r\ndrm_helper_mode_fill_fb_struct(&gfb->base, mode_cmd);\r\ngfb->obj = obj;\r\nret = drm_framebuffer_init(dev, &gfb->base, &cirrus_fb_funcs);\r\nif (ret) {\r\nDRM_ERROR("drm_framebuffer_init failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct drm_framebuffer *\r\ncirrus_user_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *filp,\r\nstruct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct cirrus_framebuffer *cirrus_fb;\r\nint ret;\r\nu32 bpp, depth;\r\ndrm_fb_get_bpp_depth(mode_cmd->pixel_format, &depth, &bpp);\r\nif (bpp > 24)\r\nreturn ERR_PTR(-EINVAL);\r\nobj = drm_gem_object_lookup(dev, filp, mode_cmd->handles[0]);\r\nif (obj == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\ncirrus_fb = kzalloc(sizeof(*cirrus_fb), GFP_KERNEL);\r\nif (!cirrus_fb) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nret = cirrus_framebuffer_init(dev, cirrus_fb, mode_cmd, obj);\r\nif (ret) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nkfree(cirrus_fb);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn &cirrus_fb->base;\r\n}\r\nstatic void cirrus_vram_fini(struct cirrus_device *cdev)\r\n{\r\niounmap(cdev->rmmio);\r\ncdev->rmmio = NULL;\r\nif (cdev->mc.vram_base)\r\nrelease_mem_region(cdev->mc.vram_base, cdev->mc.vram_size);\r\n}\r\nstatic int cirrus_vram_init(struct cirrus_device *cdev)\r\n{\r\ncdev->mc.vram_base = pci_resource_start(cdev->dev->pdev, 0);\r\ncdev->mc.vram_size = 4 * 1024 * 1024;\r\nif (!request_mem_region(cdev->mc.vram_base, cdev->mc.vram_size,\r\n"cirrusdrmfb_vram")) {\r\nDRM_ERROR("can't reserve VRAM\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nint cirrus_device_init(struct cirrus_device *cdev,\r\nstruct drm_device *ddev,\r\nstruct pci_dev *pdev, uint32_t flags)\r\n{\r\nint ret;\r\ncdev->dev = ddev;\r\ncdev->flags = flags;\r\ncdev->num_crtc = 1;\r\ncdev->rmmio_base = pci_resource_start(cdev->dev->pdev, 1);\r\ncdev->rmmio_size = pci_resource_len(cdev->dev->pdev, 1);\r\nif (!request_mem_region(cdev->rmmio_base, cdev->rmmio_size,\r\n"cirrusdrmfb_mmio")) {\r\nDRM_ERROR("can't reserve mmio registers\n");\r\nreturn -ENOMEM;\r\n}\r\ncdev->rmmio = ioremap(cdev->rmmio_base, cdev->rmmio_size);\r\nif (cdev->rmmio == NULL)\r\nreturn -ENOMEM;\r\nret = cirrus_vram_init(cdev);\r\nif (ret) {\r\nrelease_mem_region(cdev->rmmio_base, cdev->rmmio_size);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid cirrus_device_fini(struct cirrus_device *cdev)\r\n{\r\nrelease_mem_region(cdev->rmmio_base, cdev->rmmio_size);\r\ncirrus_vram_fini(cdev);\r\n}\r\nint cirrus_driver_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct cirrus_device *cdev;\r\nint r;\r\ncdev = kzalloc(sizeof(struct cirrus_device), GFP_KERNEL);\r\nif (cdev == NULL)\r\nreturn -ENOMEM;\r\ndev->dev_private = (void *)cdev;\r\nr = cirrus_device_init(cdev, dev, dev->pdev, flags);\r\nif (r) {\r\ndev_err(&dev->pdev->dev, "Fatal error during GPU init: %d\n", r);\r\ngoto out;\r\n}\r\nr = cirrus_mm_init(cdev);\r\nif (r)\r\ndev_err(&dev->pdev->dev, "fatal err on mm init\n");\r\nr = cirrus_modeset_init(cdev);\r\nif (r)\r\ndev_err(&dev->pdev->dev, "Fatal error during modeset init: %d\n", r);\r\ndev->mode_config.funcs = (void *)&cirrus_mode_funcs;\r\nout:\r\nif (r)\r\ncirrus_driver_unload(dev);\r\nreturn r;\r\n}\r\nint cirrus_driver_unload(struct drm_device *dev)\r\n{\r\nstruct cirrus_device *cdev = dev->dev_private;\r\nif (cdev == NULL)\r\nreturn 0;\r\ncirrus_modeset_fini(cdev);\r\ncirrus_mm_fini(cdev);\r\ncirrus_device_fini(cdev);\r\nkfree(cdev);\r\ndev->dev_private = NULL;\r\nreturn 0;\r\n}\r\nint cirrus_gem_create(struct drm_device *dev,\r\nu32 size, bool iskernel,\r\nstruct drm_gem_object **obj)\r\n{\r\nstruct cirrus_bo *cirrusbo;\r\nint ret;\r\n*obj = NULL;\r\nsize = roundup(size, PAGE_SIZE);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nret = cirrus_bo_create(dev, size, 0, 0, &cirrusbo);\r\nif (ret) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("failed to allocate GEM object\n");\r\nreturn ret;\r\n}\r\n*obj = &cirrusbo->gem;\r\nreturn 0;\r\n}\r\nint cirrus_dumb_create(struct drm_file *file,\r\nstruct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nint ret;\r\nstruct drm_gem_object *gobj;\r\nu32 handle;\r\nargs->pitch = args->width * ((args->bpp + 7) / 8);\r\nargs->size = args->pitch * args->height;\r\nret = cirrus_gem_create(dev, args->size, false,\r\n&gobj);\r\nif (ret)\r\nreturn ret;\r\nret = drm_gem_handle_create(file, gobj, &handle);\r\ndrm_gem_object_unreference_unlocked(gobj);\r\nif (ret)\r\nreturn ret;\r\nargs->handle = handle;\r\nreturn 0;\r\n}\r\nstatic void cirrus_bo_unref(struct cirrus_bo **bo)\r\n{\r\nstruct ttm_buffer_object *tbo;\r\nif ((*bo) == NULL)\r\nreturn;\r\ntbo = &((*bo)->bo);\r\nttm_bo_unref(&tbo);\r\nif (tbo == NULL)\r\n*bo = NULL;\r\n}\r\nvoid cirrus_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nstruct cirrus_bo *cirrus_bo = gem_to_cirrus_bo(obj);\r\nif (!cirrus_bo)\r\nreturn;\r\ncirrus_bo_unref(&cirrus_bo);\r\n}\r\nstatic inline u64 cirrus_bo_mmap_offset(struct cirrus_bo *bo)\r\n{\r\nreturn drm_vma_node_offset_addr(&bo->bo.vma_node);\r\n}\r\nint\r\ncirrus_dumb_mmap_offset(struct drm_file *file,\r\nstruct drm_device *dev,\r\nuint32_t handle,\r\nuint64_t *offset)\r\n{\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nstruct cirrus_bo *bo;\r\nmutex_lock(&dev->struct_mutex);\r\nobj = drm_gem_object_lookup(dev, file, handle);\r\nif (obj == NULL) {\r\nret = -ENOENT;\r\ngoto out_unlock;\r\n}\r\nbo = gem_to_cirrus_bo(obj);\r\n*offset = cirrus_bo_mmap_offset(bo);\r\ndrm_gem_object_unreference(obj);\r\nret = 0;\r\nout_unlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}
