u8 tusb_get_revision(struct musb *musb)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nu32 die_id;\r\nu8 rev;\r\nrev = musb_readl(tbase, TUSB_DMA_CTRL_REV) & 0xff;\r\nif (TUSB_REV_MAJOR(rev) == 3) {\r\ndie_id = TUSB_DIDR1_HI_CHIP_REV(musb_readl(tbase,\r\nTUSB_DIDR1_HI));\r\nif (die_id >= TUSB_DIDR1_HI_REV_31)\r\nrev |= 1;\r\n}\r\nreturn rev;\r\n}\r\nstatic int tusb_print_revision(struct musb *musb)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nu8 rev;\r\nrev = tusb_get_revision(musb);\r\npr_info("tusb: %s%i.%i %s%i.%i %s%i.%i %s%i.%i %s%i %s%i.%i\n",\r\n"prcm",\r\nTUSB_REV_MAJOR(musb_readl(tbase, TUSB_PRCM_REV)),\r\nTUSB_REV_MINOR(musb_readl(tbase, TUSB_PRCM_REV)),\r\n"int",\r\nTUSB_REV_MAJOR(musb_readl(tbase, TUSB_INT_CTRL_REV)),\r\nTUSB_REV_MINOR(musb_readl(tbase, TUSB_INT_CTRL_REV)),\r\n"gpio",\r\nTUSB_REV_MAJOR(musb_readl(tbase, TUSB_GPIO_REV)),\r\nTUSB_REV_MINOR(musb_readl(tbase, TUSB_GPIO_REV)),\r\n"dma",\r\nTUSB_REV_MAJOR(musb_readl(tbase, TUSB_DMA_CTRL_REV)),\r\nTUSB_REV_MINOR(musb_readl(tbase, TUSB_DMA_CTRL_REV)),\r\n"dieid",\r\nTUSB_DIDR1_HI_CHIP_REV(musb_readl(tbase, TUSB_DIDR1_HI)),\r\n"rev",\r\nTUSB_REV_MAJOR(rev), TUSB_REV_MINOR(rev));\r\nreturn tusb_get_revision(musb);\r\n}\r\nstatic void tusb_wbus_quirk(struct musb *musb, int enabled)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nstatic u32 phy_otg_ctrl, phy_otg_ena;\r\nu32 tmp;\r\nif (enabled) {\r\nphy_otg_ctrl = musb_readl(tbase, TUSB_PHY_OTG_CTRL);\r\nphy_otg_ena = musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE);\r\ntmp = TUSB_PHY_OTG_CTRL_WRPROTECT\r\n| phy_otg_ena | WBUS_QUIRK_MASK;\r\nmusb_writel(tbase, TUSB_PHY_OTG_CTRL, tmp);\r\ntmp = phy_otg_ena & ~WBUS_QUIRK_MASK;\r\ntmp |= TUSB_PHY_OTG_CTRL_WRPROTECT | TUSB_PHY_OTG_CTRL_TESTM2;\r\nmusb_writel(tbase, TUSB_PHY_OTG_CTRL_ENABLE, tmp);\r\ndev_dbg(musb->controller, "Enabled tusb wbus quirk ctrl %08x ena %08x\n",\r\nmusb_readl(tbase, TUSB_PHY_OTG_CTRL),\r\nmusb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE));\r\n} else if (musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE)\r\n& TUSB_PHY_OTG_CTRL_TESTM2) {\r\ntmp = TUSB_PHY_OTG_CTRL_WRPROTECT | phy_otg_ctrl;\r\nmusb_writel(tbase, TUSB_PHY_OTG_CTRL, tmp);\r\ntmp = TUSB_PHY_OTG_CTRL_WRPROTECT | phy_otg_ena;\r\nmusb_writel(tbase, TUSB_PHY_OTG_CTRL_ENABLE, tmp);\r\ndev_dbg(musb->controller, "Disabled tusb wbus quirk ctrl %08x ena %08x\n",\r\nmusb_readl(tbase, TUSB_PHY_OTG_CTRL),\r\nmusb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE));\r\nphy_otg_ctrl = 0;\r\nphy_otg_ena = 0;\r\n}\r\n}\r\nstatic inline void\r\ntusb_fifo_write_unaligned(void __iomem *fifo, const u8 *buf, u16 len)\r\n{\r\nu32 val;\r\nint i;\r\nif (len > 4) {\r\nfor (i = 0; i < (len >> 2); i++) {\r\nmemcpy(&val, buf, 4);\r\nmusb_writel(fifo, 0, val);\r\nbuf += 4;\r\n}\r\nlen %= 4;\r\n}\r\nif (len > 0) {\r\nmemcpy(&val, buf, len);\r\nmusb_writel(fifo, 0, val);\r\n}\r\n}\r\nstatic inline void tusb_fifo_read_unaligned(void __iomem *fifo,\r\nvoid *buf, u16 len)\r\n{\r\nu32 val;\r\nint i;\r\nif (len > 4) {\r\nfor (i = 0; i < (len >> 2); i++) {\r\nval = musb_readl(fifo, 0);\r\nmemcpy(buf, &val, 4);\r\nbuf += 4;\r\n}\r\nlen %= 4;\r\n}\r\nif (len > 0) {\r\nval = musb_readl(fifo, 0);\r\nmemcpy(buf, &val, len);\r\n}\r\n}\r\nvoid musb_write_fifo(struct musb_hw_ep *hw_ep, u16 len, const u8 *buf)\r\n{\r\nstruct musb *musb = hw_ep->musb;\r\nvoid __iomem *ep_conf = hw_ep->conf;\r\nvoid __iomem *fifo = hw_ep->fifo;\r\nu8 epnum = hw_ep->epnum;\r\nprefetch(buf);\r\ndev_dbg(musb->controller, "%cX ep%d fifo %p count %d buf %p\n",\r\n'T', epnum, fifo, len, buf);\r\nif (epnum)\r\nmusb_writel(ep_conf, TUSB_EP_TX_OFFSET,\r\nTUSB_EP_CONFIG_XFR_SIZE(len));\r\nelse\r\nmusb_writel(ep_conf, 0, TUSB_EP0_CONFIG_DIR_TX |\r\nTUSB_EP0_CONFIG_XFR_SIZE(len));\r\nif (likely((0x01 & (unsigned long) buf) == 0)) {\r\nif ((0x02 & (unsigned long) buf) == 0) {\r\nif (len >= 4) {\r\niowrite32_rep(fifo, buf, len >> 2);\r\nbuf += (len & ~0x03);\r\nlen &= 0x03;\r\n}\r\n} else {\r\nif (len >= 2) {\r\nu32 val;\r\nint i;\r\nfor (i = 0; i < (len >> 2); i++) {\r\nval = (u32)(*(u16 *)buf);\r\nbuf += 2;\r\nval |= (*(u16 *)buf) << 16;\r\nbuf += 2;\r\nmusb_writel(fifo, 0, val);\r\n}\r\nlen &= 0x03;\r\n}\r\n}\r\n}\r\nif (len > 0)\r\ntusb_fifo_write_unaligned(fifo, buf, len);\r\n}\r\nvoid musb_read_fifo(struct musb_hw_ep *hw_ep, u16 len, u8 *buf)\r\n{\r\nstruct musb *musb = hw_ep->musb;\r\nvoid __iomem *ep_conf = hw_ep->conf;\r\nvoid __iomem *fifo = hw_ep->fifo;\r\nu8 epnum = hw_ep->epnum;\r\ndev_dbg(musb->controller, "%cX ep%d fifo %p count %d buf %p\n",\r\n'R', epnum, fifo, len, buf);\r\nif (epnum)\r\nmusb_writel(ep_conf, TUSB_EP_RX_OFFSET,\r\nTUSB_EP_CONFIG_XFR_SIZE(len));\r\nelse\r\nmusb_writel(ep_conf, 0, TUSB_EP0_CONFIG_XFR_SIZE(len));\r\nif (likely((0x01 & (unsigned long) buf) == 0)) {\r\nif ((0x02 & (unsigned long) buf) == 0) {\r\nif (len >= 4) {\r\nioread32_rep(fifo, buf, len >> 2);\r\nbuf += (len & ~0x03);\r\nlen &= 0x03;\r\n}\r\n} else {\r\nif (len >= 2) {\r\nu32 val;\r\nint i;\r\nfor (i = 0; i < (len >> 2); i++) {\r\nval = musb_readl(fifo, 0);\r\n*(u16 *)buf = (u16)(val & 0xffff);\r\nbuf += 2;\r\n*(u16 *)buf = (u16)(val >> 16);\r\nbuf += 2;\r\n}\r\nlen &= 0x03;\r\n}\r\n}\r\n}\r\nif (len > 0)\r\ntusb_fifo_read_unaligned(fifo, buf, len);\r\n}\r\nstatic int tusb_draw_power(struct usb_phy *x, unsigned mA)\r\n{\r\nstruct musb *musb = the_musb;\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nu32 reg;\r\nif (x->otg->default_a || mA < (musb->min_power << 1))\r\nmA = 0;\r\nreg = musb_readl(tbase, TUSB_PRCM_MNGMT);\r\nif (mA) {\r\nmusb->is_bus_powered = 1;\r\nreg |= TUSB_PRCM_MNGMT_15_SW_EN | TUSB_PRCM_MNGMT_33_SW_EN;\r\n} else {\r\nmusb->is_bus_powered = 0;\r\nreg &= ~(TUSB_PRCM_MNGMT_15_SW_EN | TUSB_PRCM_MNGMT_33_SW_EN);\r\n}\r\nmusb_writel(tbase, TUSB_PRCM_MNGMT, reg);\r\ndev_dbg(musb->controller, "draw max %d mA VBUS\n", mA);\r\nreturn 0;\r\n}\r\nstatic void tusb_set_clock_source(struct musb *musb, unsigned mode)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nu32 reg;\r\nreg = musb_readl(tbase, TUSB_PRCM_CONF);\r\nreg &= ~TUSB_PRCM_CONF_SYS_CLKSEL(0x3);\r\nif (mode > 0)\r\nreg |= TUSB_PRCM_CONF_SYS_CLKSEL(mode & 0x3);\r\nmusb_writel(tbase, TUSB_PRCM_CONF, reg);\r\n}\r\nstatic void tusb_allow_idle(struct musb *musb, u32 wakeup_enables)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nu32 reg;\r\nif ((wakeup_enables & TUSB_PRCM_WBUS)\r\n&& (tusb_get_revision(musb) == TUSB_REV_30))\r\ntusb_wbus_quirk(musb, 1);\r\ntusb_set_clock_source(musb, 0);\r\nwakeup_enables |= TUSB_PRCM_WNORCS;\r\nmusb_writel(tbase, TUSB_PRCM_WAKEUP_MASK, ~wakeup_enables);\r\nreg = musb_readl(tbase, TUSB_PRCM_MNGMT);\r\nif (is_host_active(musb)) {\r\nreg |= TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN;\r\nreg &= ~TUSB_PRCM_MNGMT_OTG_SESS_END_EN;\r\n} else {\r\nreg |= TUSB_PRCM_MNGMT_OTG_SESS_END_EN;\r\nreg &= ~TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN;\r\n}\r\nreg |= TUSB_PRCM_MNGMT_PM_IDLE | TUSB_PRCM_MNGMT_DEV_IDLE;\r\nmusb_writel(tbase, TUSB_PRCM_MNGMT, reg);\r\ndev_dbg(musb->controller, "idle, wake on %02x\n", wakeup_enables);\r\n}\r\nstatic int tusb_musb_vbus_status(struct musb *musb)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nu32 otg_stat, prcm_mngmt;\r\nint ret = 0;\r\notg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);\r\nprcm_mngmt = musb_readl(tbase, TUSB_PRCM_MNGMT);\r\nif (!(prcm_mngmt & TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN)) {\r\nu32 tmp = prcm_mngmt;\r\ntmp |= TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN;\r\nmusb_writel(tbase, TUSB_PRCM_MNGMT, tmp);\r\notg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);\r\nmusb_writel(tbase, TUSB_PRCM_MNGMT, prcm_mngmt);\r\n}\r\nif (otg_stat & TUSB_DEV_OTG_STAT_VBUS_VALID)\r\nret = 1;\r\nreturn ret;\r\n}\r\nstatic void musb_do_idle(unsigned long _musb)\r\n{\r\nstruct musb *musb = (void *)_musb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_WAIT_BCON:\r\nif ((musb->a_wait_bcon != 0)\r\n&& (musb->idle_timeout == 0\r\n|| time_after(jiffies, musb->idle_timeout))) {\r\ndev_dbg(musb->controller, "Nothing connected %s, turning off VBUS\n",\r\nusb_otg_state_string(musb->xceiv->state));\r\n}\r\ncase OTG_STATE_A_IDLE:\r\ntusb_musb_set_vbus(musb, 0);\r\ndefault:\r\nbreak;\r\n}\r\nif (!musb->is_active) {\r\nu32 wakeups;\r\nif (is_host_active(musb) && (musb->port1_status >> 16))\r\ngoto done;\r\nif (!musb->gadget_driver) {\r\nwakeups = 0;\r\n} else {\r\nwakeups = TUSB_PRCM_WHOSTDISCON\r\n| TUSB_PRCM_WBUS\r\n| TUSB_PRCM_WVBUS;\r\nwakeups |= TUSB_PRCM_WID;\r\n}\r\ntusb_allow_idle(musb, wakeups);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic void tusb_musb_try_idle(struct musb *musb, unsigned long timeout)\r\n{\r\nunsigned long default_timeout = jiffies + msecs_to_jiffies(3);\r\nstatic unsigned long last_timer;\r\nif (timeout == 0)\r\ntimeout = default_timeout;\r\nif (musb->is_active || ((musb->a_wait_bcon == 0)\r\n&& (musb->xceiv->state == OTG_STATE_A_WAIT_BCON))) {\r\ndev_dbg(musb->controller, "%s active, deleting timer\n",\r\nusb_otg_state_string(musb->xceiv->state));\r\ndel_timer(&musb_idle_timer);\r\nlast_timer = jiffies;\r\nreturn;\r\n}\r\nif (time_after(last_timer, timeout)) {\r\nif (!timer_pending(&musb_idle_timer))\r\nlast_timer = timeout;\r\nelse {\r\ndev_dbg(musb->controller, "Longer idle timer already pending, ignoring\n");\r\nreturn;\r\n}\r\n}\r\nlast_timer = timeout;\r\ndev_dbg(musb->controller, "%s inactive, for idle timer for %lu ms\n",\r\nusb_otg_state_string(musb->xceiv->state),\r\n(unsigned long)jiffies_to_msecs(timeout - jiffies));\r\nmod_timer(&musb_idle_timer, timeout);\r\n}\r\nstatic void tusb_musb_set_vbus(struct musb *musb, int is_on)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nu32 conf, prcm, timer;\r\nu8 devctl;\r\nstruct usb_otg *otg = musb->xceiv->otg;\r\nprcm = musb_readl(tbase, TUSB_PRCM_MNGMT);\r\nconf = musb_readl(tbase, TUSB_DEV_CONF);\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif (is_on) {\r\ntimer = OTG_TIMER_MS(OTG_TIME_A_WAIT_VRISE);\r\notg->default_a = 1;\r\nmusb->xceiv->state = OTG_STATE_A_WAIT_VRISE;\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\nconf |= TUSB_DEV_CONF_USB_HOST_MODE;\r\nMUSB_HST_MODE(musb);\r\n} else {\r\nu32 otg_stat;\r\ntimer = 0;\r\notg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);\r\nif (!(otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS)) {\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_WAIT_VRISE:\r\ncase OTG_STATE_A_WAIT_BCON:\r\nmusb->xceiv->state = OTG_STATE_A_WAIT_VFALL;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nmusb->xceiv->state = OTG_STATE_A_IDLE;\r\nbreak;\r\ndefault:\r\nmusb->xceiv->state = OTG_STATE_A_IDLE;\r\n}\r\nmusb->is_active = 0;\r\notg->default_a = 1;\r\nMUSB_HST_MODE(musb);\r\n} else {\r\nmusb->is_active = 0;\r\notg->default_a = 0;\r\nmusb->xceiv->state = OTG_STATE_B_IDLE;\r\nMUSB_DEV_MODE(musb);\r\n}\r\ndevctl &= ~MUSB_DEVCTL_SESSION;\r\nconf &= ~TUSB_DEV_CONF_USB_HOST_MODE;\r\n}\r\nprcm &= ~(TUSB_PRCM_MNGMT_15_SW_EN | TUSB_PRCM_MNGMT_33_SW_EN);\r\nmusb_writel(tbase, TUSB_PRCM_MNGMT, prcm);\r\nmusb_writel(tbase, TUSB_DEV_OTG_TIMER, timer);\r\nmusb_writel(tbase, TUSB_DEV_CONF, conf);\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\ndev_dbg(musb->controller, "VBUS %s, devctl %02x otg %3x conf %08x prcm %08x\n",\r\nusb_otg_state_string(musb->xceiv->state),\r\nmusb_readb(musb->mregs, MUSB_DEVCTL),\r\nmusb_readl(tbase, TUSB_DEV_OTG_STAT),\r\nconf, prcm);\r\n}\r\nstatic int tusb_musb_set_mode(struct musb *musb, u8 musb_mode)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nu32 otg_stat, phy_otg_ctrl, phy_otg_ena, dev_conf;\r\notg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);\r\nphy_otg_ctrl = musb_readl(tbase, TUSB_PHY_OTG_CTRL);\r\nphy_otg_ena = musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE);\r\ndev_conf = musb_readl(tbase, TUSB_DEV_CONF);\r\nswitch (musb_mode) {\r\ncase MUSB_HOST:\r\nphy_otg_ctrl &= ~TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\r\nphy_otg_ena |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\r\ndev_conf |= TUSB_DEV_CONF_ID_SEL;\r\ndev_conf &= ~TUSB_DEV_CONF_SOFT_ID;\r\nbreak;\r\ncase MUSB_PERIPHERAL:\r\nphy_otg_ctrl |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\r\nphy_otg_ena |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\r\ndev_conf |= (TUSB_DEV_CONF_ID_SEL | TUSB_DEV_CONF_SOFT_ID);\r\nbreak;\r\ncase MUSB_OTG:\r\nphy_otg_ctrl |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\r\nphy_otg_ena |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\r\ndev_conf &= ~(TUSB_DEV_CONF_ID_SEL | TUSB_DEV_CONF_SOFT_ID);\r\nbreak;\r\ndefault:\r\ndev_dbg(musb->controller, "Trying to set mode %i\n", musb_mode);\r\nreturn -EINVAL;\r\n}\r\nmusb_writel(tbase, TUSB_PHY_OTG_CTRL,\r\nTUSB_PHY_OTG_CTRL_WRPROTECT | phy_otg_ctrl);\r\nmusb_writel(tbase, TUSB_PHY_OTG_CTRL_ENABLE,\r\nTUSB_PHY_OTG_CTRL_WRPROTECT | phy_otg_ena);\r\nmusb_writel(tbase, TUSB_DEV_CONF, dev_conf);\r\notg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);\r\nif ((musb_mode == MUSB_PERIPHERAL) &&\r\n!(otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS))\r\nINFO("Cannot be peripheral with mini-A cable "\r\n"otg_stat: %08x\n", otg_stat);\r\nreturn 0;\r\n}\r\nstatic inline unsigned long\r\ntusb_otg_ints(struct musb *musb, u32 int_src, void __iomem *tbase)\r\n{\r\nu32 otg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);\r\nunsigned long idle_timeout = 0;\r\nstruct usb_otg *otg = musb->xceiv->otg;\r\nif ((int_src & TUSB_INT_SRC_ID_STATUS_CHNG)) {\r\nint default_a;\r\ndefault_a = !(otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS);\r\ndev_dbg(musb->controller, "Default-%c\n", default_a ? 'A' : 'B');\r\notg->default_a = default_a;\r\ntusb_musb_set_vbus(musb, default_a);\r\nif (default_a)\r\nidle_timeout = jiffies + (HZ * 3);\r\n}\r\nif (int_src & TUSB_INT_SRC_VBUS_SENSE_CHNG) {\r\nif (!otg->default_a) {\r\nmusb->port1_status &=\r\n~(USB_PORT_STAT_CONNECTION\r\n| USB_PORT_STAT_ENABLE\r\n| USB_PORT_STAT_LOW_SPEED\r\n| USB_PORT_STAT_HIGH_SPEED\r\n| USB_PORT_STAT_TEST\r\n);\r\nif (otg_stat & TUSB_DEV_OTG_STAT_SESS_END) {\r\ndev_dbg(musb->controller, "Forcing disconnect (no interrupt)\n");\r\nif (musb->xceiv->state != OTG_STATE_B_IDLE) {\r\nmusb->xceiv->state = OTG_STATE_B_IDLE;\r\nmusb->int_usb |= MUSB_INTR_DISCONNECT;\r\n}\r\nmusb->is_active = 0;\r\n}\r\ndev_dbg(musb->controller, "vbus change, %s, otg %03x\n",\r\nusb_otg_state_string(musb->xceiv->state), otg_stat);\r\nidle_timeout = jiffies + (1 * HZ);\r\nschedule_work(&musb->irq_work);\r\n} else {\r\ndev_dbg(musb->controller, "vbus change, %s, otg %03x\n",\r\nusb_otg_state_string(musb->xceiv->state), otg_stat);\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_IDLE:\r\ndev_dbg(musb->controller, "Got SRP, turning on VBUS\n");\r\nmusb_platform_set_vbus(musb, 1);\r\nif (musb->a_wait_bcon != 0)\r\nmusb->is_active = 0;\r\nelse\r\nmusb->is_active = 1;\r\nidle_timeout = jiffies + (2 * HZ);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VRISE:\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nif (musb->vbuserr_retry) {\r\nmusb->vbuserr_retry--;\r\ntusb_musb_set_vbus(musb, 1);\r\n} else {\r\nmusb->vbuserr_retry\r\n= VBUSERR_RETRY_COUNT;\r\ntusb_musb_set_vbus(musb, 0);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nif (int_src & TUSB_INT_SRC_OTG_TIMEOUT) {\r\nu8 devctl;\r\ndev_dbg(musb->controller, "%s timer, %03x\n",\r\nusb_otg_state_string(musb->xceiv->state), otg_stat);\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_WAIT_VRISE:\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif (otg_stat & TUSB_DEV_OTG_STAT_VBUS_VALID) {\r\nif ((devctl & MUSB_DEVCTL_VBUS)\r\n!= MUSB_DEVCTL_VBUS) {\r\ndev_dbg(musb->controller, "devctl %02x\n", devctl);\r\nbreak;\r\n}\r\nmusb->xceiv->state = OTG_STATE_A_WAIT_BCON;\r\nmusb->is_active = 0;\r\nidle_timeout = jiffies\r\n+ msecs_to_jiffies(musb->a_wait_bcon);\r\n} else {\r\nERR("vbus too slow, devctl %02x\n", devctl);\r\ntusb_musb_set_vbus(musb, 0);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_WAIT_BCON:\r\nif (musb->a_wait_bcon != 0)\r\nidle_timeout = jiffies\r\n+ msecs_to_jiffies(musb->a_wait_bcon);\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nschedule_work(&musb->irq_work);\r\nreturn idle_timeout;\r\n}\r\nstatic irqreturn_t tusb_musb_interrupt(int irq, void *__hci)\r\n{\r\nstruct musb *musb = __hci;\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nunsigned long flags, idle_timeout = 0;\r\nu32 int_mask, int_src;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nint_mask = musb_readl(tbase, TUSB_INT_MASK);\r\nmusb_writel(tbase, TUSB_INT_MASK, ~TUSB_INT_MASK_RESERVED_BITS);\r\nint_src = musb_readl(tbase, TUSB_INT_SRC) & ~TUSB_INT_SRC_RESERVED_BITS;\r\ndev_dbg(musb->controller, "TUSB IRQ %08x\n", int_src);\r\nmusb->int_usb = (u8) int_src;\r\nif (int_src & TUSB_INT_SRC_DEV_WAKEUP) {\r\nu32 reg;\r\nu32 i;\r\nif (tusb_get_revision(musb) == TUSB_REV_30)\r\ntusb_wbus_quirk(musb, 0);\r\nfor (i = 0xf7f7f7; i > 0xf7f7f7 - 1000; i--) {\r\nmusb_writel(tbase, TUSB_SCRATCH_PAD, 0);\r\nmusb_writel(tbase, TUSB_SCRATCH_PAD, i);\r\nreg = musb_readl(tbase, TUSB_SCRATCH_PAD);\r\nif (reg == i)\r\nbreak;\r\ndev_dbg(musb->controller, "TUSB NOR not ready\n");\r\n}\r\ntusb_set_clock_source(musb, 1);\r\nreg = musb_readl(tbase, TUSB_PRCM_WAKEUP_SOURCE);\r\nmusb_writel(tbase, TUSB_PRCM_WAKEUP_CLEAR, reg);\r\nif (reg & ~TUSB_PRCM_WNORCS) {\r\nmusb->is_active = 1;\r\nschedule_work(&musb->irq_work);\r\n}\r\ndev_dbg(musb->controller, "wake %sactive %02x\n",\r\nmusb->is_active ? "" : "in", reg);\r\n}\r\nif (int_src & TUSB_INT_SRC_USB_IP_CONN)\r\ndel_timer(&musb_idle_timer);\r\nif (int_src & (TUSB_INT_SRC_VBUS_SENSE_CHNG\r\n| TUSB_INT_SRC_OTG_TIMEOUT\r\n| TUSB_INT_SRC_ID_STATUS_CHNG))\r\nidle_timeout = tusb_otg_ints(musb, int_src, tbase);\r\nif ((int_src & TUSB_INT_SRC_TXRX_DMA_DONE)) {\r\nu32 dma_src = musb_readl(tbase, TUSB_DMA_INT_SRC);\r\nu32 real_dma_src = musb_readl(tbase, TUSB_DMA_INT_MASK);\r\ndev_dbg(musb->controller, "DMA IRQ %08x\n", dma_src);\r\nreal_dma_src = ~real_dma_src & dma_src;\r\nif (tusb_dma_omap() && real_dma_src) {\r\nint tx_source = (real_dma_src & 0xffff);\r\nint i;\r\nfor (i = 1; i <= 15; i++) {\r\nif (tx_source & (1 << i)) {\r\ndev_dbg(musb->controller, "completing ep%i %s\n", i, "tx");\r\nmusb_dma_completion(musb, i, 1);\r\n}\r\n}\r\n}\r\nmusb_writel(tbase, TUSB_DMA_INT_CLEAR, dma_src);\r\n}\r\nif (int_src & (TUSB_INT_SRC_USB_IP_TX | TUSB_INT_SRC_USB_IP_RX)) {\r\nu32 musb_src = musb_readl(tbase, TUSB_USBIP_INT_SRC);\r\nmusb_writel(tbase, TUSB_USBIP_INT_CLEAR, musb_src);\r\nmusb->int_rx = (((musb_src >> 16) & 0xffff) << 1);\r\nmusb->int_tx = (musb_src & 0xffff);\r\n} else {\r\nmusb->int_rx = 0;\r\nmusb->int_tx = 0;\r\n}\r\nif (int_src & (TUSB_INT_SRC_USB_IP_TX | TUSB_INT_SRC_USB_IP_RX | 0xff))\r\nmusb_interrupt(musb);\r\nmusb_writel(tbase, TUSB_INT_SRC_CLEAR,\r\nint_src & ~TUSB_INT_MASK_RESERVED_BITS);\r\ntusb_musb_try_idle(musb, idle_timeout);\r\nmusb_writel(tbase, TUSB_INT_MASK, int_mask);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tusb_musb_enable(struct musb *musb)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nmusb_writel(tbase, TUSB_INT_MASK, TUSB_INT_SRC_USB_IP_SOF);\r\nmusb_writel(tbase, TUSB_USBIP_INT_MASK, 0);\r\nmusb_writel(tbase, TUSB_DMA_INT_MASK, 0x7fffffff);\r\nmusb_writel(tbase, TUSB_GPIO_INT_MASK, 0x1ff);\r\nmusb_writel(tbase, TUSB_USBIP_INT_CLEAR, 0x7fffffff);\r\nmusb_writel(tbase, TUSB_DMA_INT_CLEAR, 0x7fffffff);\r\nmusb_writel(tbase, TUSB_GPIO_INT_CLEAR, 0x1ff);\r\nmusb_writel(tbase, TUSB_INT_SRC_CLEAR, ~TUSB_INT_MASK_RESERVED_BITS);\r\nmusb_writel(tbase, TUSB_INT_CTRL_CONF,\r\nTUSB_INT_CTRL_CONF_INT_RELCYC(0));\r\nirq_set_irq_type(musb->nIrq, IRQ_TYPE_LEVEL_LOW);\r\nif (!(musb_readl(tbase, TUSB_DEV_OTG_STAT)\r\n& TUSB_DEV_OTG_STAT_ID_STATUS))\r\nmusb_writel(tbase, TUSB_INT_SRC_SET,\r\nTUSB_INT_SRC_ID_STATUS_CHNG);\r\nif (is_dma_capable() && dma_off)\r\nprintk(KERN_WARNING "%s %s: dma not reactivated\n",\r\n__FILE__, __func__);\r\nelse\r\ndma_off = 1;\r\n}\r\nstatic void tusb_musb_disable(struct musb *musb)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nmusb_writel(tbase, TUSB_INT_MASK, ~TUSB_INT_MASK_RESERVED_BITS);\r\nmusb_writel(tbase, TUSB_USBIP_INT_MASK, 0x7fffffff);\r\nmusb_writel(tbase, TUSB_DMA_INT_MASK, 0x7fffffff);\r\nmusb_writel(tbase, TUSB_GPIO_INT_MASK, 0x1ff);\r\ndel_timer(&musb_idle_timer);\r\nif (is_dma_capable() && !dma_off) {\r\nprintk(KERN_WARNING "%s %s: dma still active\n",\r\n__FILE__, __func__);\r\ndma_off = 1;\r\n}\r\n}\r\nstatic void tusb_setup_cpu_interface(struct musb *musb)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nmusb_writel(tbase, TUSB_PULLUP_1_CTRL, 0x0000003F);\r\nmusb_writel(tbase, TUSB_PULLUP_2_CTRL, 0x01FFFFFF);\r\nmusb_writel(tbase, TUSB_GPIO_CONF, TUSB_GPIO_CONF_DMAREQ(0x3f));\r\nmusb_writel(tbase, TUSB_DMA_REQ_CONF,\r\nTUSB_DMA_REQ_CONF_BURST_SIZE(2) |\r\nTUSB_DMA_REQ_CONF_DMA_REQ_EN(0x3f) |\r\nTUSB_DMA_REQ_CONF_DMA_REQ_ASSER(2));\r\nmusb_writel(tbase, TUSB_WAIT_COUNT, 1);\r\n}\r\nstatic int tusb_musb_start(struct musb *musb)\r\n{\r\nvoid __iomem *tbase = musb->ctrl_base;\r\nint ret = 0;\r\nunsigned long flags;\r\nu32 reg;\r\nif (musb->board_set_power)\r\nret = musb->board_set_power(1);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "tusb: Cannot enable TUSB6010\n");\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&musb->lock, flags);\r\nif (musb_readl(tbase, TUSB_PROD_TEST_RESET) !=\r\nTUSB_PROD_TEST_RESET_VAL) {\r\nprintk(KERN_ERR "tusb: Unable to detect TUSB6010\n");\r\ngoto err;\r\n}\r\nret = tusb_print_revision(musb);\r\nif (ret < 2) {\r\nprintk(KERN_ERR "tusb: Unsupported TUSB6010 revision %i\n",\r\nret);\r\ngoto err;\r\n}\r\nmusb_writel(tbase, TUSB_VLYNQ_CTRL, 8);\r\ntusb_set_clock_source(musb, 1);\r\nmusb_writel(tbase, TUSB_PRCM_MNGMT,\r\nTUSB_PRCM_MNGMT_VBUS_VALID_TIMER(0xa) |\r\nTUSB_PRCM_MNGMT_VBUS_VALID_FLT_EN |\r\nTUSB_PRCM_MNGMT_OTG_SESS_END_EN |\r\nTUSB_PRCM_MNGMT_OTG_VBUS_DET_EN |\r\nTUSB_PRCM_MNGMT_OTG_ID_PULLUP);\r\ntusb_setup_cpu_interface(musb);\r\nreg = musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE);\r\nreg |= TUSB_PHY_OTG_CTRL_WRPROTECT | TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\r\nmusb_writel(tbase, TUSB_PHY_OTG_CTRL_ENABLE, reg);\r\nreg = musb_readl(tbase, TUSB_PHY_OTG_CTRL);\r\nreg |= TUSB_PHY_OTG_CTRL_WRPROTECT | TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\r\nmusb_writel(tbase, TUSB_PHY_OTG_CTRL, reg);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn 0;\r\nerr:\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nif (musb->board_set_power)\r\nmusb->board_set_power(0);\r\nreturn -ENODEV;\r\n}\r\nstatic int tusb_musb_init(struct musb *musb)\r\n{\r\nstruct platform_device *pdev;\r\nstruct resource *mem;\r\nvoid __iomem *sync = NULL;\r\nint ret;\r\nusb_nop_xceiv_register();\r\nmusb->xceiv = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (IS_ERR_OR_NULL(musb->xceiv))\r\nreturn -EPROBE_DEFER;\r\npdev = to_platform_device(musb->controller);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmusb->async = mem->start;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!mem) {\r\npr_debug("no sync dma resource?\n");\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nmusb->sync = mem->start;\r\nsync = ioremap(mem->start, resource_size(mem));\r\nif (!sync) {\r\npr_debug("ioremap for sync failed\n");\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nmusb->sync_va = sync;\r\nmusb->mregs += TUSB_BASE_OFFSET;\r\nret = tusb_musb_start(musb);\r\nif (ret) {\r\nprintk(KERN_ERR "Could not start tusb6010 (%d)\n",\r\nret);\r\ngoto done;\r\n}\r\nmusb->isr = tusb_musb_interrupt;\r\nmusb->xceiv->set_power = tusb_draw_power;\r\nthe_musb = musb;\r\nsetup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);\r\ndone:\r\nif (ret < 0) {\r\nif (sync)\r\niounmap(sync);\r\nusb_put_phy(musb->xceiv);\r\nusb_nop_xceiv_unregister();\r\n}\r\nreturn ret;\r\n}\r\nstatic int tusb_musb_exit(struct musb *musb)\r\n{\r\ndel_timer_sync(&musb_idle_timer);\r\nthe_musb = NULL;\r\nif (musb->board_set_power)\r\nmusb->board_set_power(0);\r\niounmap(musb->sync_va);\r\nusb_put_phy(musb->xceiv);\r\nusb_nop_xceiv_unregister();\r\nreturn 0;\r\n}\r\nstatic int tusb_probe(struct platform_device *pdev)\r\n{\r\nstruct resource musb_resources[3];\r\nstruct musb_hdrc_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct platform_device *musb;\r\nstruct tusb6010_glue *glue;\r\nstruct platform_device_info pinfo;\r\nint ret = -ENOMEM;\r\nglue = kzalloc(sizeof(*glue), GFP_KERNEL);\r\nif (!glue) {\r\ndev_err(&pdev->dev, "failed to allocate glue context\n");\r\ngoto err0;\r\n}\r\nglue->dev = &pdev->dev;\r\npdata->platform_ops = &tusb_ops;\r\nplatform_set_drvdata(pdev, glue);\r\nmemset(musb_resources, 0x00, sizeof(*musb_resources) *\r\nARRAY_SIZE(musb_resources));\r\nmusb_resources[0].name = pdev->resource[0].name;\r\nmusb_resources[0].start = pdev->resource[0].start;\r\nmusb_resources[0].end = pdev->resource[0].end;\r\nmusb_resources[0].flags = pdev->resource[0].flags;\r\nmusb_resources[1].name = pdev->resource[1].name;\r\nmusb_resources[1].start = pdev->resource[1].start;\r\nmusb_resources[1].end = pdev->resource[1].end;\r\nmusb_resources[1].flags = pdev->resource[1].flags;\r\nmusb_resources[2].name = pdev->resource[2].name;\r\nmusb_resources[2].start = pdev->resource[2].start;\r\nmusb_resources[2].end = pdev->resource[2].end;\r\nmusb_resources[2].flags = pdev->resource[2].flags;\r\npinfo = tusb_dev_info;\r\npinfo.parent = &pdev->dev;\r\npinfo.res = musb_resources;\r\npinfo.num_res = ARRAY_SIZE(musb_resources);\r\npinfo.data = pdata;\r\npinfo.size_data = sizeof(*pdata);\r\nglue->musb = musb = platform_device_register_full(&pinfo);\r\nif (IS_ERR(musb)) {\r\nret = PTR_ERR(musb);\r\ndev_err(&pdev->dev, "failed to register musb device: %d\n", ret);\r\ngoto err3;\r\n}\r\nreturn 0;\r\nerr3:\r\nkfree(glue);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int tusb_remove(struct platform_device *pdev)\r\n{\r\nstruct tusb6010_glue *glue = platform_get_drvdata(pdev);\r\nplatform_device_unregister(glue->musb);\r\nkfree(glue);\r\nreturn 0;\r\n}
