void tcp_fastopen_init_key_once(bool publish)\r\n{\r\nstatic u8 key[TCP_FASTOPEN_KEY_LENGTH];\r\nif (net_get_random_once(key, sizeof(key)) && publish)\r\ntcp_fastopen_reset_cipher(key, sizeof(key));\r\n}\r\nstatic void tcp_fastopen_ctx_free(struct rcu_head *head)\r\n{\r\nstruct tcp_fastopen_context *ctx =\r\ncontainer_of(head, struct tcp_fastopen_context, rcu);\r\ncrypto_free_cipher(ctx->tfm);\r\nkfree(ctx);\r\n}\r\nint tcp_fastopen_reset_cipher(void *key, unsigned int len)\r\n{\r\nint err;\r\nstruct tcp_fastopen_context *ctx, *octx;\r\nctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->tfm = crypto_alloc_cipher("aes", 0, 0);\r\nif (IS_ERR(ctx->tfm)) {\r\nerr = PTR_ERR(ctx->tfm);\r\nerror: kfree(ctx);\r\npr_err("TCP: TFO aes cipher alloc error: %d\n", err);\r\nreturn err;\r\n}\r\nerr = crypto_cipher_setkey(ctx->tfm, key, len);\r\nif (err) {\r\npr_err("TCP: TFO cipher key error: %d\n", err);\r\ncrypto_free_cipher(ctx->tfm);\r\ngoto error;\r\n}\r\nmemcpy(ctx->key, key, len);\r\nspin_lock(&tcp_fastopen_ctx_lock);\r\noctx = rcu_dereference_protected(tcp_fastopen_ctx,\r\nlockdep_is_held(&tcp_fastopen_ctx_lock));\r\nrcu_assign_pointer(tcp_fastopen_ctx, ctx);\r\nspin_unlock(&tcp_fastopen_ctx_lock);\r\nif (octx)\r\ncall_rcu(&octx->rcu, tcp_fastopen_ctx_free);\r\nreturn err;\r\n}\r\nvoid tcp_fastopen_cookie_gen(__be32 src, __be32 dst,\r\nstruct tcp_fastopen_cookie *foc)\r\n{\r\n__be32 path[4] = { src, dst, 0, 0 };\r\nstruct tcp_fastopen_context *ctx;\r\ntcp_fastopen_init_key_once(true);\r\nrcu_read_lock();\r\nctx = rcu_dereference(tcp_fastopen_ctx);\r\nif (ctx) {\r\ncrypto_cipher_encrypt_one(ctx->tfm, foc->val, (__u8 *)path);\r\nfoc->len = TCP_FASTOPEN_COOKIE_SIZE;\r\n}\r\nrcu_read_unlock();\r\n}
