static int udp4_ufo_send_check(struct sk_buff *skb)\r\n{\r\nif (!pskb_may_pull(skb, sizeof(struct udphdr)))\r\nreturn -EINVAL;\r\nif (likely(!skb->encapsulation)) {\r\nconst struct iphdr *iph;\r\nstruct udphdr *uh;\r\niph = ip_hdr(skb);\r\nuh = udp_hdr(skb);\r\nuh->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr, skb->len,\r\nIPPROTO_UDP, 0);\r\nskb->csum_start = skb_transport_header(skb) - skb->head;\r\nskb->csum_offset = offsetof(struct udphdr, check);\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *udp4_ufo_fragment(struct sk_buff *skb,\r\nnetdev_features_t features)\r\n{\r\nstruct sk_buff *segs = ERR_PTR(-EINVAL);\r\nunsigned int mss;\r\nint offset;\r\n__wsum csum;\r\nif (skb->encapsulation &&\r\nskb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL) {\r\nsegs = skb_udp_tunnel_segment(skb, features);\r\ngoto out;\r\n}\r\nmss = skb_shinfo(skb)->gso_size;\r\nif (unlikely(skb->len <= mss))\r\ngoto out;\r\nif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\r\nint type = skb_shinfo(skb)->gso_type;\r\nif (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY |\r\nSKB_GSO_UDP_TUNNEL |\r\nSKB_GSO_IPIP |\r\nSKB_GSO_GRE | SKB_GSO_MPLS) ||\r\n!(type & (SKB_GSO_UDP))))\r\ngoto out;\r\nskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\r\nsegs = NULL;\r\ngoto out;\r\n}\r\noffset = skb_checksum_start_offset(skb);\r\ncsum = skb_checksum(skb, offset, skb->len - offset, 0);\r\noffset += skb->csum_offset;\r\n*(__sum16 *)(skb->data + offset) = csum_fold(csum);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nsegs = skb_segment(skb, features);\r\nout:\r\nreturn segs;\r\n}\r\nint udp_add_offload(struct udp_offload *uo)\r\n{\r\nstruct udp_offload_priv *new_offload = kzalloc(sizeof(*new_offload), GFP_ATOMIC);\r\nif (!new_offload)\r\nreturn -ENOMEM;\r\nnew_offload->offload = uo;\r\nspin_lock(&udp_offload_lock);\r\nnew_offload->next = udp_offload_base;\r\nrcu_assign_pointer(udp_offload_base, new_offload);\r\nspin_unlock(&udp_offload_lock);\r\nreturn 0;\r\n}\r\nstatic void udp_offload_free_routine(struct rcu_head *head)\r\n{\r\nstruct udp_offload_priv *ou_priv = container_of(head, struct udp_offload_priv, rcu);\r\nkfree(ou_priv);\r\n}\r\nvoid udp_del_offload(struct udp_offload *uo)\r\n{\r\nstruct udp_offload_priv __rcu **head = &udp_offload_base;\r\nstruct udp_offload_priv *uo_priv;\r\nspin_lock(&udp_offload_lock);\r\nuo_priv = udp_deref_protected(*head);\r\nfor (; uo_priv != NULL;\r\nuo_priv = udp_deref_protected(*head)) {\r\nif (uo_priv->offload == uo) {\r\nrcu_assign_pointer(*head,\r\nudp_deref_protected(uo_priv->next));\r\ngoto unlock;\r\n}\r\nhead = &uo_priv->next;\r\n}\r\npr_warn("udp_del_offload: didn't find offload for port %d\n", ntohs(uo->port));\r\nunlock:\r\nspin_unlock(&udp_offload_lock);\r\nif (uo_priv != NULL)\r\ncall_rcu(&uo_priv->rcu, udp_offload_free_routine);\r\n}\r\nstatic struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb)\r\n{\r\nstruct udp_offload_priv *uo_priv;\r\nstruct sk_buff *p, **pp = NULL;\r\nstruct udphdr *uh, *uh2;\r\nunsigned int hlen, off;\r\nint flush = 1;\r\nif (NAPI_GRO_CB(skb)->udp_mark ||\r\n(!skb->encapsulation && skb->ip_summed != CHECKSUM_COMPLETE))\r\ngoto out;\r\nNAPI_GRO_CB(skb)->udp_mark = 1;\r\noff = skb_gro_offset(skb);\r\nhlen = off + sizeof(*uh);\r\nuh = skb_gro_header_fast(skb, off);\r\nif (skb_gro_header_hard(skb, hlen)) {\r\nuh = skb_gro_header_slow(skb, hlen, off);\r\nif (unlikely(!uh))\r\ngoto out;\r\n}\r\nrcu_read_lock();\r\nuo_priv = rcu_dereference(udp_offload_base);\r\nfor (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {\r\nif (uo_priv->offload->port == uh->dest &&\r\nuo_priv->offload->callbacks.gro_receive)\r\ngoto unflush;\r\n}\r\ngoto out_unlock;\r\nunflush:\r\nflush = 0;\r\nfor (p = *head; p; p = p->next) {\r\nif (!NAPI_GRO_CB(p)->same_flow)\r\ncontinue;\r\nuh2 = (struct udphdr *)(p->data + off);\r\nif ((*(u32 *)&uh->source != *(u32 *)&uh2->source)) {\r\nNAPI_GRO_CB(p)->same_flow = 0;\r\ncontinue;\r\n}\r\n}\r\nskb_gro_pull(skb, sizeof(struct udphdr));\r\npp = uo_priv->offload->callbacks.gro_receive(head, skb);\r\nout_unlock:\r\nrcu_read_unlock();\r\nout:\r\nNAPI_GRO_CB(skb)->flush |= flush;\r\nreturn pp;\r\n}\r\nstatic int udp_gro_complete(struct sk_buff *skb, int nhoff)\r\n{\r\nstruct udp_offload_priv *uo_priv;\r\n__be16 newlen = htons(skb->len - nhoff);\r\nstruct udphdr *uh = (struct udphdr *)(skb->data + nhoff);\r\nint err = -ENOSYS;\r\nuh->len = newlen;\r\nrcu_read_lock();\r\nuo_priv = rcu_dereference(udp_offload_base);\r\nfor (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {\r\nif (uo_priv->offload->port == uh->dest &&\r\nuo_priv->offload->callbacks.gro_complete)\r\nbreak;\r\n}\r\nif (uo_priv != NULL)\r\nerr = uo_priv->offload->callbacks.gro_complete(skb, nhoff + sizeof(struct udphdr));\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nint __init udpv4_offload_init(void)\r\n{\r\nreturn inet_add_offload(&udpv4_offload, IPPROTO_UDP);\r\n}
