static int SearchVcid(struct bcm_mini_adapter *Adapter, unsigned short usVcid)\r\n{\r\nint iIndex = 0;\r\nfor (iIndex = (NO_OF_QUEUES-1); iIndex >= 0; iIndex--)\r\nif (Adapter->PackInfo[iIndex].usVCID_Value == usVcid)\r\nreturn iIndex;\r\nreturn NO_OF_QUEUES+1;\r\n}\r\nstatic struct bcm_usb_rcb *\r\nGetBulkInRcb(struct bcm_interface_adapter *psIntfAdapter)\r\n{\r\nstruct bcm_usb_rcb *pRcb = NULL;\r\nUINT index = 0;\r\nif ((atomic_read(&psIntfAdapter->uNumRcbUsed) < MAXIMUM_USB_RCB) &&\r\n(psIntfAdapter->psAdapter->StopAllXaction == false)) {\r\nindex = atomic_read(&psIntfAdapter->uCurrRcb);\r\npRcb = &psIntfAdapter->asUsbRcb[index];\r\npRcb->bUsed = TRUE;\r\npRcb->psIntfAdapter = psIntfAdapter;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL, "Got Rx desc %d used %d",\r\nindex, atomic_read(&psIntfAdapter->uNumRcbUsed));\r\nindex = (index + 1) % MAXIMUM_USB_RCB;\r\natomic_set(&psIntfAdapter->uCurrRcb, index);\r\natomic_inc(&psIntfAdapter->uNumRcbUsed);\r\n}\r\nreturn pRcb;\r\n}\r\nstatic void read_bulk_callback(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nbool bHeaderSupressionEnabled = false;\r\nint QueueIndex = NO_OF_QUEUES + 1;\r\nUINT uiIndex = 0;\r\nint process_done = 1;\r\nstruct bcm_usb_rcb *pRcb = (struct bcm_usb_rcb *)urb->context;\r\nstruct bcm_interface_adapter *psIntfAdapter = pRcb->psIntfAdapter;\r\nstruct bcm_mini_adapter *Adapter = psIntfAdapter->psAdapter;\r\nstruct bcm_leader *pLeader = urb->transfer_buffer;\r\nif (unlikely(netif_msg_rx_status(Adapter)))\r\npr_info(PFX "%s: rx urb status %d length %d\n",\r\nAdapter->dev->name, urb->status, urb->actual_length);\r\nif ((Adapter->device_removed == TRUE) ||\r\n(TRUE == Adapter->bEndPointHalted) ||\r\n(0 == urb->actual_length)) {\r\npRcb->bUsed = false;\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nreturn;\r\n}\r\nif (urb->status != STATUS_SUCCESS) {\r\nif (urb->status == -EPIPE) {\r\nAdapter->bEndPointHalted = TRUE;\r\nwake_up(&Adapter->tx_packet_wait_queue);\r\n} else {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL, "Rx URB has got cancelled. status :%d", urb->status);\r\n}\r\npRcb->bUsed = false;\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nurb->status = STATUS_SUCCESS;\r\nreturn;\r\n}\r\nif (Adapter->bDoSuspend && (Adapter->bPreparingForLowPowerMode)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL, "device is going in low power mode while PMU option selected..hence rx packet should not be process");\r\nreturn;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL, "Read back done len %d\n", pLeader->PLength);\r\nif (!pLeader->PLength) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL, "Leader Length 0");\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nreturn;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL, "Leader Status:0x%hX, Length:0x%hX, VCID:0x%hX", pLeader->Status, pLeader->PLength, pLeader->Vcid);\r\nif (MAX_CNTL_PKT_SIZE < pLeader->PLength) {\r\nif (netif_msg_rx_err(Adapter))\r\npr_info(PFX "%s: corrupted leader length...%d\n",\r\nAdapter->dev->name, pLeader->PLength);\r\n++Adapter->dev->stats.rx_dropped;\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nreturn;\r\n}\r\nQueueIndex = SearchVcid(Adapter, pLeader->Vcid);\r\nif (QueueIndex < NO_OF_QUEUES) {\r\nbHeaderSupressionEnabled =\r\nAdapter->PackInfo[QueueIndex].bHeaderSuppressionEnabled;\r\nbHeaderSupressionEnabled =\r\nbHeaderSupressionEnabled & Adapter->bPHSEnabled;\r\n}\r\nskb = dev_alloc_skb(pLeader->PLength + SKB_RESERVE_PHS_BYTES + SKB_RESERVE_ETHERNET_HEADER);\r\nif (!skb) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "NO SKBUFF!!! Dropping the Packet");\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nreturn;\r\n}\r\nif ((ntohs(pLeader->Vcid) == VCID_CONTROL_PACKET) ||\r\n(!(pLeader->Status >= 0x20 && pLeader->Status <= 0x3F))) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_RX, RX_CTRL, DBG_LVL_ALL, "Received control pkt...");\r\n*(PUSHORT)skb->data = pLeader->Status;\r\nmemcpy(skb->data+sizeof(USHORT), urb->transfer_buffer +\r\n(sizeof(struct bcm_leader)), pLeader->PLength);\r\nskb->len = pLeader->PLength + sizeof(USHORT);\r\nspin_lock(&Adapter->control_queue_lock);\r\nENQUEUEPACKET(Adapter->RxControlHead, Adapter->RxControlTail, skb);\r\nspin_unlock(&Adapter->control_queue_lock);\r\natomic_inc(&Adapter->cntrlpktCnt);\r\nwake_up(&Adapter->process_rx_cntrlpkt);\r\n} else {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_RX, RX_DATA, DBG_LVL_ALL, "Received Data pkt...");\r\nskb_reserve(skb, 2 + SKB_RESERVE_PHS_BYTES);\r\nmemcpy(skb->data+ETH_HLEN, (PUCHAR)urb->transfer_buffer + sizeof(struct bcm_leader), pLeader->PLength);\r\nskb->dev = Adapter->dev;\r\nskb_put(skb, pLeader->PLength + ETH_HLEN);\r\nAdapter->PackInfo[QueueIndex].uiTotalRxBytes += pLeader->PLength;\r\nAdapter->PackInfo[QueueIndex].uiThisPeriodRxBytes += pLeader->PLength;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_RX, RX_DATA, DBG_LVL_ALL, "Received Data pkt of len :0x%X", pLeader->PLength);\r\nif (netif_running(Adapter->dev)) {\r\nskb_pull(skb, ETH_HLEN);\r\nPHSReceive(Adapter, pLeader->Vcid, skb, &skb->len,\r\nNULL, bHeaderSupressionEnabled);\r\nif (!Adapter->PackInfo[QueueIndex].bEthCSSupport) {\r\nskb_push(skb, ETH_HLEN);\r\nmemcpy(skb->data, skb->dev->dev_addr, 6);\r\nmemcpy(skb->data+6, skb->dev->dev_addr, 6);\r\n(*(skb->data+11))++;\r\n*(skb->data+12) = 0x08;\r\n*(skb->data+13) = 0x00;\r\npLeader->PLength += ETH_HLEN;\r\n}\r\nskb->protocol = eth_type_trans(skb, Adapter->dev);\r\nprocess_done = netif_rx(skb);\r\n} else {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_RX, RX_DATA, DBG_LVL_ALL, "i/f not up hance freeing SKB...");\r\ndev_kfree_skb(skb);\r\n}\r\n++Adapter->dev->stats.rx_packets;\r\nAdapter->dev->stats.rx_bytes += pLeader->PLength;\r\nfor (uiIndex = 0; uiIndex < MIBS_MAX_HIST_ENTRIES; uiIndex++) {\r\nif ((pLeader->PLength <= MIBS_PKTSIZEHIST_RANGE*(uiIndex+1)) &&\r\n(pLeader->PLength > MIBS_PKTSIZEHIST_RANGE*(uiIndex)))\r\nAdapter->aRxPktSizeHist[uiIndex]++;\r\n}\r\n}\r\nAdapter->PrevNumRecvDescs++;\r\npRcb->bUsed = false;\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\n}\r\nstatic int ReceiveRcb(struct bcm_interface_adapter *psIntfAdapter, struct bcm_usb_rcb *pRcb)\r\n{\r\nstruct urb *urb = pRcb->urb;\r\nint retval = 0;\r\nusb_fill_bulk_urb(urb, psIntfAdapter->udev, usb_rcvbulkpipe(psIntfAdapter->udev, psIntfAdapter->sBulkIn.bulk_in_endpointAddr),\r\nurb->transfer_buffer, BCM_USB_MAX_READ_LENGTH, read_bulk_callback, pRcb);\r\nif (false == psIntfAdapter->psAdapter->device_removed &&\r\nfalse == psIntfAdapter->psAdapter->bEndPointHalted &&\r\nfalse == psIntfAdapter->bSuspended &&\r\nfalse == psIntfAdapter->bPreparingForBusSuspend) {\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL, "failed submitting read urb, error %d", retval);\r\nif (retval == -EPIPE) {\r\npsIntfAdapter->psAdapter->bEndPointHalted = TRUE;\r\nwake_up(&psIntfAdapter->psAdapter->tx_packet_wait_queue);\r\n}\r\n}\r\n}\r\nreturn retval;\r\n}\r\nbool InterfaceRx(struct bcm_interface_adapter *psIntfAdapter)\r\n{\r\nUSHORT RxDescCount = NUM_RX_DESC - atomic_read(&psIntfAdapter->uNumRcbUsed);\r\nstruct bcm_usb_rcb *pRcb = NULL;\r\nwhile (RxDescCount) {\r\npRcb = GetBulkInRcb(psIntfAdapter);\r\nif (pRcb == NULL) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0, "Unable to get Rcb pointer");\r\nreturn false;\r\n}\r\nReceiveRcb(psIntfAdapter, pRcb);\r\nRxDescCount--;\r\n}\r\nreturn TRUE;\r\n}
