static void __init sr_set_nvalues(struct omap_volt_data *volt_data,\r\nstruct omap_sr_data *sr_data)\r\n{\r\nstruct omap_sr_nvalue_table *nvalue_table;\r\nint i, j, count = 0;\r\nsr_data->nvalue_count = 0;\r\nsr_data->nvalue_table = NULL;\r\nwhile (volt_data[count].volt_nominal)\r\ncount++;\r\nnvalue_table = kzalloc(sizeof(struct omap_sr_nvalue_table)*count,\r\nGFP_KERNEL);\r\nif (!nvalue_table) {\r\npr_err("OMAP: SmartReflex: cannot allocate memory for n-value table\n");\r\nreturn;\r\n}\r\nfor (i = 0, j = 0; i < count; i++) {\r\nu32 v;\r\nif (cpu_is_omap44xx()) {\r\nu16 offset = volt_data[i].sr_efuse_offs;\r\nv = omap_ctrl_readb(offset) |\r\nomap_ctrl_readb(offset + 1) << 8 |\r\nomap_ctrl_readb(offset + 2) << 16;\r\n} else {\r\nv = omap_ctrl_readl(volt_data[i].sr_efuse_offs);\r\n}\r\nif (v == 0)\r\ncontinue;\r\nnvalue_table[j].nvalue = v;\r\nnvalue_table[j].efuse_offs = volt_data[i].sr_efuse_offs;\r\nnvalue_table[j].errminlimit = volt_data[i].sr_errminlimit;\r\nnvalue_table[j].volt_nominal = volt_data[i].volt_nominal;\r\nj++;\r\n}\r\nsr_data->nvalue_table = nvalue_table;\r\nsr_data->nvalue_count = j;\r\n}\r\nstatic int __init sr_dev_init(struct omap_hwmod *oh, void *user)\r\n{\r\nstruct omap_sr_data *sr_data;\r\nstruct platform_device *pdev;\r\nstruct omap_volt_data *volt_data;\r\nstruct omap_smartreflex_dev_attr *sr_dev_attr;\r\nchar *name = "smartreflex";\r\nstatic int i;\r\nsr_data = kzalloc(sizeof(struct omap_sr_data), GFP_KERNEL);\r\nif (!sr_data) {\r\npr_err("%s: Unable to allocate memory for %s sr_data\n",\r\n__func__, oh->name);\r\nreturn -ENOMEM;\r\n}\r\nsr_dev_attr = (struct omap_smartreflex_dev_attr *)oh->dev_attr;\r\nif (!sr_dev_attr || !sr_dev_attr->sensor_voltdm_name) {\r\npr_err("%s: No voltage domain specified for %s. Cannot initialize\n",\r\n__func__, oh->name);\r\ngoto exit;\r\n}\r\nsr_data->name = oh->name;\r\nsr_data->ip_type = oh->class->rev;\r\nsr_data->senn_mod = 0x1;\r\nsr_data->senp_mod = 0x1;\r\nif (cpu_is_omap34xx() || cpu_is_omap44xx()) {\r\nsr_data->err_weight = OMAP3430_SR_ERRWEIGHT;\r\nsr_data->err_maxlimit = OMAP3430_SR_ERRMAXLIMIT;\r\nsr_data->accum_data = OMAP3430_SR_ACCUMDATA;\r\nif (!(strcmp(sr_data->name, "smartreflex_mpu"))) {\r\nsr_data->senn_avgweight = OMAP3430_SR1_SENNAVGWEIGHT;\r\nsr_data->senp_avgweight = OMAP3430_SR1_SENPAVGWEIGHT;\r\n} else {\r\nsr_data->senn_avgweight = OMAP3430_SR2_SENNAVGWEIGHT;\r\nsr_data->senp_avgweight = OMAP3430_SR2_SENPAVGWEIGHT;\r\n}\r\n}\r\nsr_data->voltdm = voltdm_lookup(sr_dev_attr->sensor_voltdm_name);\r\nif (!sr_data->voltdm) {\r\npr_err("%s: Unable to get voltage domain pointer for VDD %s\n",\r\n__func__, sr_dev_attr->sensor_voltdm_name);\r\ngoto exit;\r\n}\r\nomap_voltage_get_volttable(sr_data->voltdm, &volt_data);\r\nif (!volt_data) {\r\npr_err("%s: No Voltage table registered for VDD%d\n",\r\n__func__, i + 1);\r\ngoto exit;\r\n}\r\nsr_set_nvalues(volt_data, sr_data);\r\nsr_data->enable_on_init = sr_enable_on_init;\r\npdev = omap_device_build(name, i, oh, sr_data, sizeof(*sr_data));\r\nif (IS_ERR(pdev))\r\npr_warning("%s: Could not build omap_device for %s: %s.\n\n",\r\n__func__, name, oh->name);\r\nexit:\r\ni++;\r\nkfree(sr_data);\r\nreturn 0;\r\n}\r\nvoid __init omap_enable_smartreflex_on_init(void)\r\n{\r\nsr_enable_on_init = true;\r\n}\r\nint __init omap_devinit_smartreflex(void)\r\n{\r\nreturn omap_hwmod_for_each_by_class("smartreflex", sr_dev_init, NULL);\r\n}
