int SendControlPacket(struct bcm_mini_adapter *Adapter, char *pControlPacket)\r\n{\r\nstruct bcm_leader *PLeader = (struct bcm_leader *)pControlPacket;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, TX_CONTROL, DBG_LVL_ALL, "Tx");\r\nif (!pControlPacket || !Adapter) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, TX_CONTROL, DBG_LVL_ALL, "Got NULL Control Packet or Adapter");\r\nreturn STATUS_FAILURE;\r\n}\r\nif ((atomic_read(&Adapter->CurrNumFreeTxDesc) <\r\n((PLeader->PLength-1)/MAX_DEVICE_DESC_SIZE)+1)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, TX_CONTROL, DBG_LVL_ALL, "NO FREE DESCRIPTORS TO SEND CONTROL PACKET");\r\nreturn STATUS_FAILURE;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, TX_CONTROL, DBG_LVL_ALL, "Leader Status: %x", PLeader->Status);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, TX_CONTROL, DBG_LVL_ALL, "Leader VCID: %x", PLeader->Vcid);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, TX_CONTROL, DBG_LVL_ALL, "Leader Length: %x", PLeader->PLength);\r\nif (Adapter->device_removed)\r\nreturn 0;\r\nif (netif_msg_pktdata(Adapter))\r\nprint_hex_dump(KERN_DEBUG, PFX "tx control: ", DUMP_PREFIX_NONE,\r\n16, 1, pControlPacket, PLeader->PLength + LEADER_SIZE, 0);\r\nAdapter->interface_transmit(Adapter->pvInterfaceAdapter,\r\npControlPacket, (PLeader->PLength + LEADER_SIZE));\r\natomic_dec(&Adapter->CurrNumFreeTxDesc);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, TX_CONTROL, DBG_LVL_ALL, "<=========");\r\nreturn STATUS_SUCCESS;\r\n}\r\nint SetupNextSend(struct bcm_mini_adapter *Adapter, struct sk_buff *Packet, USHORT Vcid)\r\n{\r\nint status = 0;\r\nbool bHeaderSupressionEnabled = false;\r\nB_UINT16 uiClassifierRuleID;\r\nu16 QueueIndex = skb_get_queue_mapping(Packet);\r\nstruct bcm_leader Leader = {0};\r\nif (Packet->len > MAX_DEVICE_DESC_SIZE) {\r\nstatus = STATUS_FAILURE;\r\ngoto errExit;\r\n}\r\nuiClassifierRuleID = *((UINT32 *) (Packet->cb) + SKB_CB_CLASSIFICATION_OFFSET);\r\nbHeaderSupressionEnabled = Adapter->PackInfo[QueueIndex].bHeaderSuppressionEnabled\r\n& Adapter->bPHSEnabled;\r\nif (Adapter->device_removed) {\r\nstatus = STATUS_FAILURE;\r\ngoto errExit;\r\n}\r\nstatus = PHSTransmit(Adapter, &Packet, Vcid, uiClassifierRuleID, bHeaderSupressionEnabled,\r\n(UINT *)&Packet->len, Adapter->PackInfo[QueueIndex].bEthCSSupport);\r\nif (status != STATUS_SUCCESS) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL, "PHS Transmit failed..\n");\r\ngoto errExit;\r\n}\r\nLeader.Vcid = Vcid;\r\nif (TCP_ACK == *((UINT32 *) (Packet->cb) + SKB_CB_TCPACK_OFFSET))\r\nLeader.Status = LEADER_STATUS_TCP_ACK;\r\nelse\r\nLeader.Status = LEADER_STATUS;\r\nif (Adapter->PackInfo[QueueIndex].bEthCSSupport) {\r\nLeader.PLength = Packet->len;\r\nif (skb_headroom(Packet) < LEADER_SIZE) {\r\nstatus = skb_cow(Packet, LEADER_SIZE);\r\nif (status) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL, "bcm_transmit : Failed To Increase headRoom\n");\r\ngoto errExit;\r\n}\r\n}\r\nskb_push(Packet, LEADER_SIZE);\r\nmemcpy(Packet->data, &Leader, LEADER_SIZE);\r\n} else {\r\nLeader.PLength = Packet->len - ETH_HLEN;\r\nmemcpy((struct bcm_leader *)skb_pull(Packet, (ETH_HLEN - LEADER_SIZE)), &Leader, LEADER_SIZE);\r\n}\r\nstatus = Adapter->interface_transmit(Adapter->pvInterfaceAdapter,\r\nPacket->data, (Leader.PLength + LEADER_SIZE));\r\nif (status) {\r\n++Adapter->dev->stats.tx_errors;\r\nif (netif_msg_tx_err(Adapter))\r\npr_info(PFX "%s: transmit error %d\n", Adapter->dev->name,\r\nstatus);\r\n} else {\r\nstruct net_device_stats *netstats = &Adapter->dev->stats;\r\nAdapter->PackInfo[QueueIndex].uiTotalTxBytes += Leader.PLength;\r\nnetstats->tx_bytes += Leader.PLength;\r\n++netstats->tx_packets;\r\nAdapter->PackInfo[QueueIndex].uiCurrentTokenCount -= Leader.PLength << 3;\r\nAdapter->PackInfo[QueueIndex].uiSentBytes += (Packet->len);\r\nAdapter->PackInfo[QueueIndex].uiSentPackets++;\r\nAdapter->PackInfo[QueueIndex].NumOfPacketsSent++;\r\natomic_dec(&Adapter->PackInfo[QueueIndex].uiPerSFTxResourceCount);\r\nAdapter->PackInfo[QueueIndex].uiThisPeriodSentBytes += Leader.PLength;\r\n}\r\natomic_dec(&Adapter->CurrNumFreeTxDesc);\r\nerrExit:\r\ndev_kfree_skb(Packet);\r\nreturn status;\r\n}\r\nstatic int tx_pending(struct bcm_mini_adapter *Adapter)\r\n{\r\nreturn (atomic_read(&Adapter->TxPktAvail)\r\n&& MINIMUM_PENDING_DESCRIPTORS < atomic_read(&Adapter->CurrNumFreeTxDesc))\r\n|| Adapter->device_removed || (1 == Adapter->downloadDDR);\r\n}\r\nint tx_pkt_handler(struct bcm_mini_adapter *Adapter )\r\n{\r\nint status = 0;\r\nwhile (!kthread_should_stop()) {\r\nif (Adapter->LinkUpStatus)\r\nwait_event_timeout(Adapter->tx_packet_wait_queue,\r\ntx_pending(Adapter), msecs_to_jiffies(10));\r\nelse\r\nwait_event_interruptible(Adapter->tx_packet_wait_queue,\r\ntx_pending(Adapter));\r\nif (Adapter->device_removed)\r\nbreak;\r\nif (Adapter->downloadDDR == 1) {\r\nAdapter->downloadDDR += 1;\r\nstatus = download_ddr_settings(Adapter);\r\nif (status)\r\npr_err(PFX "DDR DOWNLOAD FAILED! %d\n", status);\r\ncontinue;\r\n}\r\nif (Adapter->bEndPointHalted == TRUE) {\r\nBcm_clear_halt_of_endpoints(Adapter);\r\nAdapter->bEndPointHalted = false;\r\nStartInterruptUrb((struct bcm_interface_adapter *)(Adapter->pvInterfaceAdapter));\r\n}\r\nif (Adapter->LinkUpStatus && !Adapter->IdleMode) {\r\nif (atomic_read(&Adapter->TotalPacketCount))\r\nupdate_per_sf_desc_cnts(Adapter);\r\n}\r\nif (atomic_read(&Adapter->CurrNumFreeTxDesc) &&\r\nAdapter->LinkStatus == SYNC_UP_REQUEST &&\r\n!Adapter->bSyncUpRequestSent) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "Calling LinkMessage");\r\nLinkMessage(Adapter);\r\n}\r\nif ((Adapter->IdleMode || Adapter->bShutStatus) && atomic_read(&Adapter->TotalPacketCount)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "Device in Low Power mode...waking up");\r\nAdapter->usIdleModePattern = ABORT_IDLE_MODE;\r\nAdapter->bWakeUpDevice = TRUE;\r\nwake_up(&Adapter->process_rx_cntrlpkt);\r\n}\r\ntransmit_packets(Adapter);\r\natomic_set(&Adapter->TxPktAvail, 0);\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "Exiting the tx thread..\n");\r\nAdapter->transmit_packet_thread = NULL;\r\nreturn 0;\r\n}
