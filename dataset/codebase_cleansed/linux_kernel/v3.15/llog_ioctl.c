static int str2logid(struct llog_logid *logid, char *str, int len)\r\n{\r\nchar *start, *end, *endp;\r\n__u64 id, seq;\r\nstart = str;\r\nif (*start != '#')\r\nreturn -EINVAL;\r\nstart++;\r\nif (start - str >= len - 1)\r\nreturn -EINVAL;\r\nend = strchr(start, '#');\r\nif (end == NULL || end == start)\r\nreturn -EINVAL;\r\n*end = '\0';\r\nid = simple_strtoull(start, &endp, 0);\r\nif (endp != end)\r\nreturn -EINVAL;\r\nstart = ++end;\r\nif (start - str >= len - 1)\r\nreturn -EINVAL;\r\nend = strchr(start, '#');\r\nif (end == NULL || end == start)\r\nreturn -EINVAL;\r\n*end = '\0';\r\nseq = simple_strtoull(start, &endp, 0);\r\nif (endp != end)\r\nreturn -EINVAL;\r\nostid_set_seq(&logid->lgl_oi, seq);\r\nostid_set_id(&logid->lgl_oi, id);\r\nstart = ++end;\r\nif (start - str >= len - 1)\r\nreturn -EINVAL;\r\nlogid->lgl_ogen = simple_strtoul(start, &endp, 16);\r\nif (*endp != '\0')\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int llog_check_cb(const struct lu_env *env, struct llog_handle *handle,\r\nstruct llog_rec_hdr *rec, void *data)\r\n{\r\nstruct obd_ioctl_data *ioc_data = (struct obd_ioctl_data *)data;\r\nstatic int l, remains, from, to;\r\nstatic char *out;\r\nchar *endp;\r\nint cur_index, rc = 0;\r\nif (ioc_data && ioc_data->ioc_inllen1 > 0) {\r\nl = 0;\r\nremains = ioc_data->ioc_inllen4 +\r\ncfs_size_round(ioc_data->ioc_inllen1) +\r\ncfs_size_round(ioc_data->ioc_inllen2) +\r\ncfs_size_round(ioc_data->ioc_inllen3);\r\nfrom = simple_strtol(ioc_data->ioc_inlbuf2, &endp, 0);\r\nif (*endp != '\0')\r\nreturn -EINVAL;\r\nto = simple_strtol(ioc_data->ioc_inlbuf3, &endp, 0);\r\nif (*endp != '\0')\r\nreturn -EINVAL;\r\nioc_data->ioc_inllen1 = 0;\r\nout = ioc_data->ioc_bulk;\r\n}\r\ncur_index = rec->lrh_index;\r\nif (cur_index < from)\r\nreturn 0;\r\nif (to > 0 && cur_index > to)\r\nreturn -LLOG_EEMPTY;\r\nif (handle->lgh_hdr->llh_flags & LLOG_F_IS_CAT) {\r\nstruct llog_logid_rec *lir = (struct llog_logid_rec *)rec;\r\nstruct llog_handle *loghandle;\r\nif (rec->lrh_type != LLOG_LOGID_MAGIC) {\r\nl = snprintf(out, remains, "[index]: %05d [type]: "\r\n"%02x [len]: %04d failed\n",\r\ncur_index, rec->lrh_type,\r\nrec->lrh_len);\r\n}\r\nif (handle->lgh_ctxt == NULL)\r\nreturn -EOPNOTSUPP;\r\nrc = llog_cat_id2handle(env, handle, &loghandle, &lir->lid_id);\r\nif (rc) {\r\nCDEBUG(D_IOCTL, "cannot find log #"DOSTID"#%08x\n",\r\nPOSTID(&lir->lid_id.lgl_oi),\r\nlir->lid_id.lgl_ogen);\r\nreturn rc;\r\n}\r\nrc = llog_process(env, loghandle, llog_check_cb, NULL, NULL);\r\nllog_handle_put(loghandle);\r\n} else {\r\nbool ok;\r\nswitch (rec->lrh_type) {\r\ncase OST_SZ_REC:\r\ncase MDS_UNLINK_REC:\r\ncase MDS_UNLINK64_REC:\r\ncase MDS_SETATTR64_REC:\r\ncase OBD_CFG_REC:\r\ncase LLOG_GEN_REC:\r\ncase LLOG_HDR_MAGIC:\r\nok = true;\r\nbreak;\r\ndefault:\r\nok = false;\r\n}\r\nl = snprintf(out, remains, "[index]: %05d [type]: "\r\n"%02x [len]: %04d %s\n",\r\ncur_index, rec->lrh_type, rec->lrh_len,\r\nok ? "ok" : "failed");\r\nout += l;\r\nremains -= l;\r\nif (remains <= 0) {\r\nCERROR("%s: no space to print log records\n",\r\nhandle->lgh_ctxt->loc_obd->obd_name);\r\nreturn -LLOG_EEMPTY;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int llog_print_cb(const struct lu_env *env, struct llog_handle *handle,\r\nstruct llog_rec_hdr *rec, void *data)\r\n{\r\nstruct obd_ioctl_data *ioc_data = (struct obd_ioctl_data *)data;\r\nstatic int l, remains, from, to;\r\nstatic char *out;\r\nchar *endp;\r\nint cur_index;\r\nif (ioc_data != NULL && ioc_data->ioc_inllen1 > 0) {\r\nl = 0;\r\nremains = ioc_data->ioc_inllen4 +\r\ncfs_size_round(ioc_data->ioc_inllen1) +\r\ncfs_size_round(ioc_data->ioc_inllen2) +\r\ncfs_size_round(ioc_data->ioc_inllen3);\r\nfrom = simple_strtol(ioc_data->ioc_inlbuf2, &endp, 0);\r\nif (*endp != '\0')\r\nreturn -EINVAL;\r\nto = simple_strtol(ioc_data->ioc_inlbuf3, &endp, 0);\r\nif (*endp != '\0')\r\nreturn -EINVAL;\r\nout = ioc_data->ioc_bulk;\r\nioc_data->ioc_inllen1 = 0;\r\n}\r\ncur_index = rec->lrh_index;\r\nif (cur_index < from)\r\nreturn 0;\r\nif (to > 0 && cur_index > to)\r\nreturn -LLOG_EEMPTY;\r\nif (handle->lgh_hdr->llh_flags & LLOG_F_IS_CAT) {\r\nstruct llog_logid_rec *lir = (struct llog_logid_rec *)rec;\r\nif (rec->lrh_type != LLOG_LOGID_MAGIC) {\r\nCERROR("invalid record in catalog\n");\r\nreturn -EINVAL;\r\n}\r\nl = snprintf(out, remains,\r\n"[index]: %05d [logid]: #"DOSTID"#%08x\n",\r\ncur_index, POSTID(&lir->lid_id.lgl_oi),\r\nlir->lid_id.lgl_ogen);\r\n} else if (rec->lrh_type == OBD_CFG_REC) {\r\nint rc;\r\nrc = class_config_parse_rec(rec, out, remains);\r\nif (rc < 0)\r\nreturn rc;\r\nl = rc;\r\n} else {\r\nl = snprintf(out, remains,\r\n"[index]: %05d [type]: %02x [len]: %04d\n",\r\ncur_index, rec->lrh_type, rec->lrh_len);\r\n}\r\nout += l;\r\nremains -= l;\r\nif (remains <= 0) {\r\nCERROR("not enough space for print log records\n");\r\nreturn -LLOG_EEMPTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int llog_remove_log(const struct lu_env *env, struct llog_handle *cat,\r\nstruct llog_logid *logid)\r\n{\r\nstruct llog_handle *log;\r\nint rc;\r\nrc = llog_cat_id2handle(env, cat, &log, logid);\r\nif (rc) {\r\nCDEBUG(D_IOCTL, "cannot find log #"DOSTID"#%08x\n",\r\nPOSTID(&logid->lgl_oi), logid->lgl_ogen);\r\nreturn -ENOENT;\r\n}\r\nrc = llog_destroy(env, log);\r\nif (rc) {\r\nCDEBUG(D_IOCTL, "cannot destroy log\n");\r\nGOTO(out, rc);\r\n}\r\nllog_cat_cleanup(env, cat, log, log->u.phd.phd_cookie.lgc_index);\r\nout:\r\nllog_handle_put(log);\r\nreturn rc;\r\n}\r\nstatic int llog_delete_cb(const struct lu_env *env, struct llog_handle *handle,\r\nstruct llog_rec_hdr *rec, void *data)\r\n{\r\nstruct llog_logid_rec *lir = (struct llog_logid_rec *)rec;\r\nint rc;\r\nif (rec->lrh_type != LLOG_LOGID_MAGIC)\r\nreturn -EINVAL;\r\nrc = llog_remove_log(env, handle, &lir->lid_id);\r\nreturn rc;\r\n}\r\nint llog_ioctl(const struct lu_env *env, struct llog_ctxt *ctxt, int cmd,\r\nstruct obd_ioctl_data *data)\r\n{\r\nstruct llog_logid logid;\r\nint rc = 0;\r\nstruct llog_handle *handle = NULL;\r\nif (*data->ioc_inlbuf1 == '#') {\r\nrc = str2logid(&logid, data->ioc_inlbuf1, data->ioc_inllen1);\r\nif (rc)\r\nreturn rc;\r\nrc = llog_open(env, ctxt, &handle, &logid, NULL,\r\nLLOG_OPEN_EXISTS);\r\nif (rc)\r\nreturn rc;\r\n} else if (*data->ioc_inlbuf1 == '$') {\r\nchar *name = data->ioc_inlbuf1 + 1;\r\nrc = llog_open(env, ctxt, &handle, NULL, name,\r\nLLOG_OPEN_EXISTS);\r\nif (rc)\r\nreturn rc;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nrc = llog_init_handle(env, handle, 0, NULL);\r\nif (rc)\r\nGOTO(out_close, rc = -ENOENT);\r\nswitch (cmd) {\r\ncase OBD_IOC_LLOG_INFO: {\r\nint l;\r\nint remains = data->ioc_inllen2 +\r\ncfs_size_round(data->ioc_inllen1);\r\nchar *out = data->ioc_bulk;\r\nl = snprintf(out, remains,\r\n"logid: #"DOSTID"#%08x\n"\r\n"flags: %x (%s)\n"\r\n"records count: %d\n"\r\n"last index: %d\n",\r\nPOSTID(&handle->lgh_id.lgl_oi),\r\nhandle->lgh_id.lgl_ogen,\r\nhandle->lgh_hdr->llh_flags,\r\nhandle->lgh_hdr->llh_flags &\r\nLLOG_F_IS_CAT ? "cat" : "plain",\r\nhandle->lgh_hdr->llh_count,\r\nhandle->lgh_last_idx);\r\nout += l;\r\nremains -= l;\r\nif (remains <= 0) {\r\nCERROR("%s: not enough space for log header info\n",\r\nctxt->loc_obd->obd_name);\r\nrc = -ENOSPC;\r\n}\r\nbreak;\r\n}\r\ncase OBD_IOC_LLOG_CHECK:\r\nLASSERT(data->ioc_inllen1 > 0);\r\nrc = llog_process(env, handle, llog_check_cb, data, NULL);\r\nif (rc == -LLOG_EEMPTY)\r\nrc = 0;\r\nelse if (rc)\r\nGOTO(out_close, rc);\r\nbreak;\r\ncase OBD_IOC_LLOG_PRINT:\r\nLASSERT(data->ioc_inllen1 > 0);\r\nrc = llog_process(env, handle, llog_print_cb, data, NULL);\r\nif (rc == -LLOG_EEMPTY)\r\nrc = 0;\r\nelse if (rc)\r\nGOTO(out_close, rc);\r\nbreak;\r\ncase OBD_IOC_LLOG_CANCEL: {\r\nstruct llog_cookie cookie;\r\nstruct llog_logid plain;\r\nchar *endp;\r\ncookie.lgc_index = simple_strtoul(data->ioc_inlbuf3, &endp, 0);\r\nif (*endp != '\0')\r\nGOTO(out_close, rc = -EINVAL);\r\nif (handle->lgh_hdr->llh_flags & LLOG_F_IS_PLAIN) {\r\nrc = llog_cancel_rec(NULL, handle, cookie.lgc_index);\r\nGOTO(out_close, rc);\r\n} else if (!(handle->lgh_hdr->llh_flags & LLOG_F_IS_CAT)) {\r\nGOTO(out_close, rc = -EINVAL);\r\n}\r\nif (data->ioc_inlbuf2 == NULL)\r\nGOTO(out_close, rc = -ENOTTY);\r\nrc = str2logid(&plain, data->ioc_inlbuf2, data->ioc_inllen2);\r\nif (rc)\r\nGOTO(out_close, rc);\r\ncookie.lgc_lgl = plain;\r\nrc = llog_cat_cancel_records(env, handle, 1, &cookie);\r\nif (rc)\r\nGOTO(out_close, rc);\r\nbreak;\r\n}\r\ncase OBD_IOC_LLOG_REMOVE: {\r\nstruct llog_logid plain;\r\nif (handle->lgh_hdr->llh_flags & LLOG_F_IS_PLAIN) {\r\nrc = llog_destroy(env, handle);\r\nGOTO(out_close, rc);\r\n} else if (!(handle->lgh_hdr->llh_flags & LLOG_F_IS_CAT)) {\r\nGOTO(out_close, rc = -EINVAL);\r\n}\r\nif (data->ioc_inlbuf2 > 0) {\r\nrc = str2logid(&plain, data->ioc_inlbuf2,\r\ndata->ioc_inllen2);\r\nif (rc)\r\nGOTO(out_close, rc);\r\nrc = llog_remove_log(env, handle, &plain);\r\n} else {\r\nrc = llog_process(env, handle, llog_delete_cb, NULL,\r\nNULL);\r\nif (rc)\r\nGOTO(out_close, rc);\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nCERROR("%s: Unknown ioctl cmd %#x\n",\r\nctxt->loc_obd->obd_name, cmd);\r\nGOTO(out_close, rc = -ENOTTY);\r\n}\r\nout_close:\r\nif (handle->lgh_hdr &&\r\nhandle->lgh_hdr->llh_flags & LLOG_F_IS_CAT)\r\nllog_cat_close(env, handle);\r\nelse\r\nllog_close(env, handle);\r\nreturn rc;\r\n}
