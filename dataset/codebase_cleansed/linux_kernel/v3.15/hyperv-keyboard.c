static void hv_kbd_on_receive(struct hv_device *hv_dev,\r\nstruct synth_kbd_msg *msg, u32 msg_length)\r\n{\r\nstruct hv_kbd_dev *kbd_dev = hv_get_drvdata(hv_dev);\r\nstruct synth_kbd_keystroke *ks_msg;\r\nunsigned long flags;\r\nu32 msg_type = __le32_to_cpu(msg->header.type);\r\nu32 info;\r\nu16 scan_code;\r\nswitch (msg_type) {\r\ncase SYNTH_KBD_PROTOCOL_RESPONSE:\r\nif (msg_length < sizeof(struct synth_kbd_protocol_response)) {\r\ndev_err(&hv_dev->device,\r\n"Illegal protocol response packet (len: %d)\n",\r\nmsg_length);\r\nbreak;\r\n}\r\nmemcpy(&kbd_dev->protocol_resp, msg,\r\nsizeof(struct synth_kbd_protocol_response));\r\ncomplete(&kbd_dev->wait_event);\r\nbreak;\r\ncase SYNTH_KBD_EVENT:\r\nif (msg_length < sizeof(struct synth_kbd_keystroke)) {\r\ndev_err(&hv_dev->device,\r\n"Illegal keyboard event packet (len: %d)\n",\r\nmsg_length);\r\nbreak;\r\n}\r\nks_msg = (struct synth_kbd_keystroke *)msg;\r\ninfo = __le32_to_cpu(ks_msg->info);\r\nspin_lock_irqsave(&kbd_dev->lock, flags);\r\nif (kbd_dev->started) {\r\nif (info & IS_E0)\r\nserio_interrupt(kbd_dev->hv_serio,\r\nXTKBD_EMUL0, 0);\r\nif (info & IS_E1)\r\nserio_interrupt(kbd_dev->hv_serio,\r\nXTKBD_EMUL1, 0);\r\nscan_code = __le16_to_cpu(ks_msg->make_code);\r\nif (info & IS_BREAK)\r\nscan_code |= XTKBD_RELEASE;\r\nserio_interrupt(kbd_dev->hv_serio, scan_code, 0);\r\n}\r\nspin_unlock_irqrestore(&kbd_dev->lock, flags);\r\nbreak;\r\ndefault:\r\ndev_err(&hv_dev->device,\r\n"unhandled message type %d\n", msg_type);\r\n}\r\n}\r\nstatic void hv_kbd_handle_received_packet(struct hv_device *hv_dev,\r\nstruct vmpacket_descriptor *desc,\r\nu32 bytes_recvd,\r\nu64 req_id)\r\n{\r\nstruct synth_kbd_msg *msg;\r\nu32 msg_sz;\r\nswitch (desc->type) {\r\ncase VM_PKT_COMP:\r\nbreak;\r\ncase VM_PKT_DATA_INBAND:\r\nmsg_sz = bytes_recvd - (desc->offset8 << 3);\r\nif (msg_sz <= sizeof(struct synth_kbd_msg_hdr)) {\r\ndev_err(&hv_dev->device,\r\n"Illegal packet (type: %d, tid: %llx, size: %d)\n",\r\ndesc->type, req_id, msg_sz);\r\nbreak;\r\n}\r\nmsg = (void *)desc + (desc->offset8 << 3);\r\nhv_kbd_on_receive(hv_dev, msg, msg_sz);\r\nbreak;\r\ndefault:\r\ndev_err(&hv_dev->device,\r\n"unhandled packet type %d, tid %llx len %d\n",\r\ndesc->type, req_id, bytes_recvd);\r\nbreak;\r\n}\r\n}\r\nstatic void hv_kbd_on_channel_callback(void *context)\r\n{\r\nstruct hv_device *hv_dev = context;\r\nvoid *buffer;\r\nint bufferlen = 0x100;\r\nu32 bytes_recvd;\r\nu64 req_id;\r\nint error;\r\nbuffer = kmalloc(bufferlen, GFP_ATOMIC);\r\nif (!buffer)\r\nreturn;\r\nwhile (1) {\r\nerror = vmbus_recvpacket_raw(hv_dev->channel, buffer, bufferlen,\r\n&bytes_recvd, &req_id);\r\nswitch (error) {\r\ncase 0:\r\nif (bytes_recvd == 0) {\r\nkfree(buffer);\r\nreturn;\r\n}\r\nhv_kbd_handle_received_packet(hv_dev, buffer,\r\nbytes_recvd, req_id);\r\nbreak;\r\ncase -ENOBUFS:\r\nkfree(buffer);\r\nbufferlen = bytes_recvd;\r\nbuffer = kmalloc(bytes_recvd, GFP_ATOMIC);\r\nif (!buffer)\r\nreturn;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int hv_kbd_connect_to_vsp(struct hv_device *hv_dev)\r\n{\r\nstruct hv_kbd_dev *kbd_dev = hv_get_drvdata(hv_dev);\r\nstruct synth_kbd_protocol_request *request;\r\nstruct synth_kbd_protocol_response *response;\r\nu32 proto_status;\r\nint error;\r\nrequest = &kbd_dev->protocol_req;\r\nmemset(request, 0, sizeof(struct synth_kbd_protocol_request));\r\nrequest->header.type = __cpu_to_le32(SYNTH_KBD_PROTOCOL_REQUEST);\r\nrequest->version_requested.version = __cpu_to_le32(SYNTH_KBD_VERSION);\r\nerror = vmbus_sendpacket(hv_dev->channel, request,\r\nsizeof(struct synth_kbd_protocol_request),\r\n(unsigned long)request,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (error)\r\nreturn error;\r\nif (!wait_for_completion_timeout(&kbd_dev->wait_event, 10 * HZ))\r\nreturn -ETIMEDOUT;\r\nresponse = &kbd_dev->protocol_resp;\r\nproto_status = __le32_to_cpu(response->proto_status);\r\nif (!(proto_status & PROTOCOL_ACCEPTED)) {\r\ndev_err(&hv_dev->device,\r\n"synth_kbd protocol request failed (version %d)\n",\r\nSYNTH_KBD_VERSION);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hv_kbd_start(struct serio *serio)\r\n{\r\nstruct hv_kbd_dev *kbd_dev = serio->port_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&kbd_dev->lock, flags);\r\nkbd_dev->started = true;\r\nspin_unlock_irqrestore(&kbd_dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void hv_kbd_stop(struct serio *serio)\r\n{\r\nstruct hv_kbd_dev *kbd_dev = serio->port_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&kbd_dev->lock, flags);\r\nkbd_dev->started = false;\r\nspin_unlock_irqrestore(&kbd_dev->lock, flags);\r\n}\r\nstatic int hv_kbd_probe(struct hv_device *hv_dev,\r\nconst struct hv_vmbus_device_id *dev_id)\r\n{\r\nstruct hv_kbd_dev *kbd_dev;\r\nstruct serio *hv_serio;\r\nint error;\r\nkbd_dev = kzalloc(sizeof(struct hv_kbd_dev), GFP_KERNEL);\r\nhv_serio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!kbd_dev || !hv_serio) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nkbd_dev->hv_dev = hv_dev;\r\nkbd_dev->hv_serio = hv_serio;\r\nspin_lock_init(&kbd_dev->lock);\r\ninit_completion(&kbd_dev->wait_event);\r\nhv_set_drvdata(hv_dev, kbd_dev);\r\nhv_serio->dev.parent = &hv_dev->device;\r\nhv_serio->id.type = SERIO_8042_XL;\r\nhv_serio->port_data = kbd_dev;\r\nstrlcpy(hv_serio->name, dev_name(&hv_dev->device),\r\nsizeof(hv_serio->name));\r\nstrlcpy(hv_serio->phys, dev_name(&hv_dev->device),\r\nsizeof(hv_serio->phys));\r\nhv_serio->start = hv_kbd_start;\r\nhv_serio->stop = hv_kbd_stop;\r\nerror = vmbus_open(hv_dev->channel,\r\nKBD_VSC_SEND_RING_BUFFER_SIZE,\r\nKBD_VSC_RECV_RING_BUFFER_SIZE,\r\nNULL, 0,\r\nhv_kbd_on_channel_callback,\r\nhv_dev);\r\nif (error)\r\ngoto err_free_mem;\r\nerror = hv_kbd_connect_to_vsp(hv_dev);\r\nif (error)\r\ngoto err_close_vmbus;\r\nserio_register_port(kbd_dev->hv_serio);\r\nreturn 0;\r\nerr_close_vmbus:\r\nvmbus_close(hv_dev->channel);\r\nerr_free_mem:\r\nkfree(hv_serio);\r\nkfree(kbd_dev);\r\nreturn error;\r\n}\r\nstatic int hv_kbd_remove(struct hv_device *hv_dev)\r\n{\r\nstruct hv_kbd_dev *kbd_dev = hv_get_drvdata(hv_dev);\r\nserio_unregister_port(kbd_dev->hv_serio);\r\nvmbus_close(hv_dev->channel);\r\nkfree(kbd_dev);\r\nhv_set_drvdata(hv_dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init hv_kbd_init(void)\r\n{\r\nreturn vmbus_driver_register(&hv_kbd_drv);\r\n}\r\nstatic void __exit hv_kbd_exit(void)\r\n{\r\nvmbus_driver_unregister(&hv_kbd_drv);\r\n}
