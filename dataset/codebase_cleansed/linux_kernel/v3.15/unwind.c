inline long get_frame_size(unsigned long instr)\r\n{\r\nreturn abs((s16)(instr & 0xFFFF));\r\n}\r\nstatic unsigned long *find_frame_creation(unsigned long *pc)\r\n{\r\nint i;\r\nfor (i = 0; i < 1000; i++, pc--) {\r\nunsigned long instr;\r\ns16 frame_size;\r\nif (!kernel_text_address((unsigned long) pc))\r\nreturn NULL;\r\ninstr = *pc;\r\nif ((instr & 0xFFFF0000) != 0x30210000)\r\ncontinue;\r\nframe_size = get_frame_size(instr);\r\nif ((frame_size < 8) || (frame_size & 3)) {\r\npr_debug(" Invalid frame size %d at 0x%p\n",\r\nframe_size, pc);\r\nreturn NULL;\r\n}\r\npr_debug(" Found frame creation at 0x%p, size %d\n", pc,\r\nframe_size);\r\nreturn pc;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int lookup_prev_stack_frame(unsigned long fp, unsigned long pc,\r\nunsigned long leaf_return,\r\nunsigned long *pprev_fp,\r\nunsigned long *pprev_pc)\r\n{\r\nunsigned long *prologue = NULL;\r\nif (pc != (unsigned long) &_switch_to)\r\nprologue = find_frame_creation((unsigned long *)pc);\r\nif (prologue) {\r\nlong frame_size = get_frame_size(*prologue);\r\n*pprev_fp = fp + frame_size;\r\n*pprev_pc = *(unsigned long *)fp;\r\n} else {\r\nif (!leaf_return)\r\nreturn -EINVAL;\r\n*pprev_pc = leaf_return;\r\n*pprev_fp = fp;\r\n}\r\nreturn (!*pprev_pc || (*pprev_pc & 3)) ? -EINVAL : 0;\r\n}\r\nstatic inline void unwind_trap(struct task_struct *task, unsigned long pc,\r\nunsigned long fp, struct stack_trace *trace)\r\n{\r\n}\r\nstatic inline void unwind_trap(struct task_struct *task, unsigned long pc,\r\nunsigned long fp, struct stack_trace *trace)\r\n{\r\nconst struct pt_regs *regs = (const struct pt_regs *) fp;\r\nmicroblaze_unwind_inner(task, regs->pc, regs->r1, regs->r15, trace);\r\n}\r\nstatic void microblaze_unwind_inner(struct task_struct *task,\r\nunsigned long pc, unsigned long fp,\r\nunsigned long leaf_return,\r\nstruct stack_trace *trace)\r\n{\r\nint ofs = 0;\r\npr_debug(" Unwinding with PC=%p, FP=%p\n", (void *)pc, (void *)fp);\r\nif (!pc || !fp || (pc & 3) || (fp & 3)) {\r\npr_debug(" Invalid state for unwind, aborting\n");\r\nreturn;\r\n}\r\nfor (; pc != 0;) {\r\nunsigned long next_fp, next_pc = 0;\r\nunsigned long return_to = pc + 2 * sizeof(unsigned long);\r\nconst struct trap_handler_info *handler =\r\n&microblaze_trap_handlers;\r\nif ((return_to >= (unsigned long)&_hw_exception_handler)\r\n&&(return_to < (unsigned long)&ex_handler_unhandled)) {\r\n#ifndef CONFIG_MMU\r\nconst struct pt_regs *regs =\r\n(const struct pt_regs *) fp;\r\n#endif\r\npr_info("HW EXCEPTION\n");\r\n#ifndef CONFIG_MMU\r\nmicroblaze_unwind_inner(task, regs->r17 - 4,\r\nfp + EX_HANDLER_STACK_SIZ,\r\nregs->r15, trace);\r\n#endif\r\nreturn;\r\n}\r\nfor (; handler->start_addr; ++handler) {\r\nif ((return_to >= handler->start_addr)\r\n&& (return_to <= handler->end_addr)) {\r\nif (!trace)\r\npr_info("%s\n", handler->trap_name);\r\nunwind_trap(task, pc, fp, trace);\r\nreturn;\r\n}\r\n}\r\npc -= ofs;\r\nif (trace) {\r\n#ifdef CONFIG_STACKTRACE\r\nif (trace->skip > 0)\r\ntrace->skip--;\r\nelse\r\ntrace->entries[trace->nr_entries++] = pc;\r\nif (trace->nr_entries >= trace->max_entries)\r\nbreak;\r\n#endif\r\n} else {\r\nif (unlikely(pc == task_pt_regs(task)->pc)) {\r\npr_info("[<%p>] PID %lu [%s]\n",\r\n(void *) pc,\r\n(unsigned long) task->pid,\r\ntask->comm);\r\nbreak;\r\n} else\r\nprint_ip_sym(pc);\r\n}\r\nif (!kernel_text_address(pc))\r\nbreak;\r\nif (lookup_prev_stack_frame(fp, pc, leaf_return, &next_fp,\r\n&next_pc) == 0) {\r\nofs = sizeof(unsigned long);\r\npc = next_pc & ~3;\r\nfp = next_fp;\r\nleaf_return = 0;\r\n} else {\r\npr_debug(" Failed to find previous stack frame\n");\r\nbreak;\r\n}\r\npr_debug(" Next PC=%p, next FP=%p\n",\r\n(void *)next_pc, (void *)next_fp);\r\n}\r\n}\r\nvoid microblaze_unwind(struct task_struct *task, struct stack_trace *trace)\r\n{\r\nif (task) {\r\nif (task == current) {\r\nconst struct pt_regs *regs = task_pt_regs(task);\r\nmicroblaze_unwind_inner(task, regs->pc, regs->r1,\r\nregs->r15, trace);\r\n} else {\r\nstruct thread_info *thread_info =\r\n(struct thread_info *)(task->stack);\r\nconst struct cpu_context *cpu_context =\r\n&thread_info->cpu_context;\r\nmicroblaze_unwind_inner(task,\r\n(unsigned long) &_switch_to,\r\ncpu_context->r1,\r\ncpu_context->r15, trace);\r\n}\r\n} else {\r\nunsigned long pc, fp;\r\n__asm__ __volatile__ ("or %0, r1, r0" : "=r" (fp));\r\n__asm__ __volatile__ (\r\n"brlid %0, 0f;"\r\n"nop;"\r\n"0:"\r\n: "=r" (pc)\r\n);\r\nmicroblaze_unwind_inner(current, pc, fp, 0, trace);\r\n}\r\n}
