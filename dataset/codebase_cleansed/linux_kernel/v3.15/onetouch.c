static void usb_onetouch_irq(struct urb *urb)\r\n{\r\nstruct usb_onetouch *onetouch = urb->context;\r\nsigned char *data = onetouch->data;\r\nstruct input_dev *dev = onetouch->dev;\r\nint status = urb->status;\r\nint retval;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ngoto resubmit;\r\n}\r\ninput_report_key(dev, ONETOUCH_BUTTON, data[0] & 0x02);\r\ninput_sync(dev);\r\nresubmit:\r\nretval = usb_submit_urb (urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&dev->dev, "can't resubmit intr, %s-%s/input0, "\r\n"retval %d\n", onetouch->udev->bus->bus_name,\r\nonetouch->udev->devpath, retval);\r\n}\r\nstatic int usb_onetouch_open(struct input_dev *dev)\r\n{\r\nstruct usb_onetouch *onetouch = input_get_drvdata(dev);\r\nonetouch->is_open = 1;\r\nonetouch->irq->dev = onetouch->udev;\r\nif (usb_submit_urb(onetouch->irq, GFP_KERNEL)) {\r\ndev_err(&dev->dev, "usb_submit_urb failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void usb_onetouch_close(struct input_dev *dev)\r\n{\r\nstruct usb_onetouch *onetouch = input_get_drvdata(dev);\r\nusb_kill_urb(onetouch->irq);\r\nonetouch->is_open = 0;\r\n}\r\nstatic void usb_onetouch_pm_hook(struct us_data *us, int action)\r\n{\r\nstruct usb_onetouch *onetouch = (struct usb_onetouch *) us->extra;\r\nif (onetouch->is_open) {\r\nswitch (action) {\r\ncase US_SUSPEND:\r\nusb_kill_urb(onetouch->irq);\r\nbreak;\r\ncase US_RESUME:\r\nif (usb_submit_urb(onetouch->irq, GFP_NOIO) != 0)\r\ndev_err(&onetouch->irq->dev->dev,\r\n"usb_submit_urb failed\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int onetouch_connect_input(struct us_data *ss)\r\n{\r\nstruct usb_device *udev = ss->pusb_dev;\r\nstruct usb_host_interface *interface;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct usb_onetouch *onetouch;\r\nstruct input_dev *input_dev;\r\nint pipe, maxp;\r\nint error = -ENOMEM;\r\ninterface = ss->pusb_intf->cur_altsetting;\r\nif (interface->desc.bNumEndpoints != 3)\r\nreturn -ENODEV;\r\nendpoint = &interface->endpoint[2].desc;\r\nif (!usb_endpoint_is_int_in(endpoint))\r\nreturn -ENODEV;\r\npipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);\r\nmaxp = usb_maxpacket(udev, pipe, usb_pipeout(pipe));\r\nmaxp = min(maxp, ONETOUCH_PKT_LEN);\r\nonetouch = kzalloc(sizeof(struct usb_onetouch), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!onetouch || !input_dev)\r\ngoto fail1;\r\nonetouch->data = usb_alloc_coherent(udev, ONETOUCH_PKT_LEN,\r\nGFP_KERNEL, &onetouch->data_dma);\r\nif (!onetouch->data)\r\ngoto fail1;\r\nonetouch->irq = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!onetouch->irq)\r\ngoto fail2;\r\nonetouch->udev = udev;\r\nonetouch->dev = input_dev;\r\nif (udev->manufacturer)\r\nstrlcpy(onetouch->name, udev->manufacturer,\r\nsizeof(onetouch->name));\r\nif (udev->product) {\r\nif (udev->manufacturer)\r\nstrlcat(onetouch->name, " ", sizeof(onetouch->name));\r\nstrlcat(onetouch->name, udev->product, sizeof(onetouch->name));\r\n}\r\nif (!strlen(onetouch->name))\r\nsnprintf(onetouch->name, sizeof(onetouch->name),\r\n"Maxtor Onetouch %04x:%04x",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct));\r\nusb_make_path(udev, onetouch->phys, sizeof(onetouch->phys));\r\nstrlcat(onetouch->phys, "/input0", sizeof(onetouch->phys));\r\ninput_dev->name = onetouch->name;\r\ninput_dev->phys = onetouch->phys;\r\nusb_to_input_id(udev, &input_dev->id);\r\ninput_dev->dev.parent = &udev->dev;\r\nset_bit(EV_KEY, input_dev->evbit);\r\nset_bit(ONETOUCH_BUTTON, input_dev->keybit);\r\nclear_bit(0, input_dev->keybit);\r\ninput_set_drvdata(input_dev, onetouch);\r\ninput_dev->open = usb_onetouch_open;\r\ninput_dev->close = usb_onetouch_close;\r\nusb_fill_int_urb(onetouch->irq, udev, pipe, onetouch->data, maxp,\r\nusb_onetouch_irq, onetouch, endpoint->bInterval);\r\nonetouch->irq->transfer_dma = onetouch->data_dma;\r\nonetouch->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nss->extra_destructor = onetouch_release_input;\r\nss->extra = onetouch;\r\n#ifdef CONFIG_PM\r\nss->suspend_resume_hook = usb_onetouch_pm_hook;\r\n#endif\r\nerror = input_register_device(onetouch->dev);\r\nif (error)\r\ngoto fail3;\r\nreturn 0;\r\nfail3: usb_free_urb(onetouch->irq);\r\nfail2: usb_free_coherent(udev, ONETOUCH_PKT_LEN,\r\nonetouch->data, onetouch->data_dma);\r\nfail1: kfree(onetouch);\r\ninput_free_device(input_dev);\r\nreturn error;\r\n}\r\nstatic void onetouch_release_input(void *onetouch_)\r\n{\r\nstruct usb_onetouch *onetouch = (struct usb_onetouch *) onetouch_;\r\nif (onetouch) {\r\nusb_kill_urb(onetouch->irq);\r\ninput_unregister_device(onetouch->dev);\r\nusb_free_urb(onetouch->irq);\r\nusb_free_coherent(onetouch->udev, ONETOUCH_PKT_LEN,\r\nonetouch->data, onetouch->data_dma);\r\n}\r\n}\r\nstatic int onetouch_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct us_data *us;\r\nint result;\r\nresult = usb_stor_probe1(&us, intf, id,\r\n(id - onetouch_usb_ids) + onetouch_unusual_dev_list);\r\nif (result)\r\nreturn result;\r\nresult = usb_stor_probe2(us);\r\nreturn result;\r\n}
