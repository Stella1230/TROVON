static void gpio_beeper_toggle(struct gpio_beeper *beep, bool on)\r\n{\r\ngpio_set_value_cansleep(beep->gpio, on ^ beep->active_low);\r\n}\r\nstatic void gpio_beeper_work(struct work_struct *work)\r\n{\r\nstruct gpio_beeper *beep = container_of(work, struct gpio_beeper, work);\r\ngpio_beeper_toggle(beep, beep->beeping);\r\n}\r\nstatic int gpio_beeper_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int value)\r\n{\r\nstruct gpio_beeper *beep = input_get_drvdata(dev);\r\nif (type != EV_SND || code != SND_BELL)\r\nreturn -ENOTSUPP;\r\nif (value < 0)\r\nreturn -EINVAL;\r\nbeep->beeping = value;\r\nschedule_work(&beep->work);\r\nreturn 0;\r\n}\r\nstatic void gpio_beeper_close(struct input_dev *input)\r\n{\r\nstruct gpio_beeper *beep = input_get_drvdata(input);\r\ncancel_work_sync(&beep->work);\r\ngpio_beeper_toggle(beep, false);\r\n}\r\nstatic int gpio_beeper_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_beeper *beep;\r\nenum of_gpio_flags flags;\r\nstruct input_dev *input;\r\nunsigned long gflags;\r\nint err;\r\nbeep = devm_kzalloc(&pdev->dev, sizeof(*beep), GFP_KERNEL);\r\nif (!beep)\r\nreturn -ENOMEM;\r\nbeep->gpio = of_get_gpio_flags(pdev->dev.of_node, 0, &flags);\r\nif (!gpio_is_valid(beep->gpio))\r\nreturn beep->gpio;\r\ninput = devm_input_allocate_device(&pdev->dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\nINIT_WORK(&beep->work, gpio_beeper_work);\r\ninput->name = pdev->name;\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0100;\r\ninput->close = gpio_beeper_close;\r\ninput->event = gpio_beeper_event;\r\ninput_set_capability(input, EV_SND, SND_BELL);\r\nbeep->active_low = flags & OF_GPIO_ACTIVE_LOW;\r\ngflags = beep->active_low ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;\r\nerr = devm_gpio_request_one(&pdev->dev, beep->gpio, gflags, pdev->name);\r\nif (err)\r\nreturn err;\r\ninput_set_drvdata(input, beep);\r\nreturn input_register_device(input);\r\n}
